{
  "metadata": {
    "timestamp": 1736710351599,
    "page": 159,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "cmus/cmus",
      "stars": 5639,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.205078125,
          "content": "# normal ignores\n.*\n*~\n*.[ao]\n*.lo\n*.so\ntags\ncscope.out\n!.gitignore\n!.travis.yml\n!.github\n\n# top-level ignores\n/*.spec\n/config\n/config.mk\n/cmus\n/cmus-remote\n\n# Cygwin stuff\n*.exe\n/cmus.base\n/cmus.def\n/cmus.exp\n"
        },
        {
          "name": "AUTHORS",
          "type": "blob",
          "size": 1.53515625,
          "content": "Maintainers\n-----------\nGregory Petrosyan <gregory.petrosyan@gmail.com>\nJason Woofenden <jason@jasonwoof.com>\n\nOriginal Author\n---------------\nTimo Hirvonen <tihirvon@gmail.com>\n\nNOTE: This list is not complete.  Especially small changes/bug fixes may\n      not be listed here.  See the git repository for full list of\n      contributors.\n\nCredits\n-------\noriginal help window code and mad.charset option by Sergey Kuleshov\n<svyatogor@gentoo.org>\n\nartist/album mode idea and \"display artist/album as a tree instead of two\nwindows\" idea from divxero <divxero@gmx.net>\n\nplay queue idea and other misc ideas from Martin Stubenschrott\n<stubenschrott@gmx.net>\n\noriginal RPM spec file by Eugene Vlasov <eugene@ikz.ru>\n\nClaes Nästen <pekdon@gmail.com>\n  :seek command\n  --volume option for cmus-remote\n\nFrank Terbeck <ft@bewatermyfriend.org>\n  dynamic keybindings patch\n\nalex <pukpuk@gmx.de>\n  Sun output plugin\n  Tremor support for vorbis plugin\n  NetBSD and OpenBSD port\n  Various bug fixes\n\nChun-Yu Shei <cshei@cs.indiana.edu>\n  mpc plugin\n  gapless MP3 playback\n\nJohannes Weißl <jargon@molb.org>\n  ao plugin\n\nGregory Petrosyan <gregory.petrosyan@gmail.com>\n  PulseAudio output plugin\n\nPhilipp 'ph3-der-loewe' Schafft <lion@lion.leolix.org>\n  RoarAudio output plugin\n\nJason Woofenden <jason@jasonwoof.com>\n  Tutorial\n  cmus-unofficial patch-commiter\n\nNiko Efthymiou <nefthy-cmus@nefthy.de>\n  Jack plugin\n\nTuncer Ayaz <tuncer.ayaz@gmail.com>\n  Opus input plugin\n\nBoris Timofeev <mashin87@gmail.com>\n  vtx plugin\n\nYue Wang <yuleopen@gmail.com>\n  CoreAudio plugin\n\nGoogle Inc.\n"
        },
        {
          "name": "COPYING",
          "type": "blob",
          "size": 17.66796875,
          "content": "                    GNU GENERAL PUBLIC LICENSE\n                       Version 2, June 1991\n\n Copyright (C) 1989, 1991 Free Software Foundation, Inc.,\n 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The licenses for most software are designed to take away your\nfreedom to share and change it.  By contrast, the GNU General Public\nLicense is intended to guarantee your freedom to share and change free\nsoftware--to make sure the software is free for all its users.  This\nGeneral Public License applies to most of the Free Software\nFoundation's software and to any other program whose authors commit to\nusing it.  (Some other Free Software Foundation software is covered by\nthe GNU Lesser General Public License instead.)  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthis service if you wish), that you receive source code or can get it\nif you want it, that you can change the software or use pieces of it\nin new free programs; and that you know you can do these things.\n\n  To protect your rights, we need to make restrictions that forbid\nanyone to deny you these rights or to ask you to surrender the rights.\nThese restrictions translate to certain responsibilities for you if you\ndistribute copies of the software, or if you modify it.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must give the recipients all the rights that\nyou have.  You must make sure that they, too, receive or can get the\nsource code.  And you must show them these terms so they know their\nrights.\n\n  We protect your rights with two steps: (1) copyright the software, and\n(2) offer you this license which gives you legal permission to copy,\ndistribute and/or modify the software.\n\n  Also, for each author's protection and ours, we want to make certain\nthat everyone understands that there is no warranty for this free\nsoftware.  If the software is modified by someone else and passed on, we\nwant its recipients to know that what they have is not the original, so\nthat any problems introduced by others will not reflect on the original\nauthors' reputations.\n\n  Finally, any free program is threatened constantly by software\npatents.  We wish to avoid the danger that redistributors of a free\nprogram will individually obtain patent licenses, in effect making the\nprogram proprietary.  To prevent this, we have made it clear that any\npatent must be licensed for everyone's free use or not licensed at all.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                    GNU GENERAL PUBLIC LICENSE\n   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n\n  0. This License applies to any program or other work which contains\na notice placed by the copyright holder saying it may be distributed\nunder the terms of this General Public License.  The \"Program\", below,\nrefers to any such program or work, and a \"work based on the Program\"\nmeans either the Program or any derivative work under copyright law:\nthat is to say, a work containing the Program or a portion of it,\neither verbatim or with modifications and/or translated into another\nlanguage.  (Hereinafter, translation is included without limitation in\nthe term \"modification\".)  Each licensee is addressed as \"you\".\n\nActivities other than copying, distribution and modification are not\ncovered by this License; they are outside its scope.  The act of\nrunning the Program is not restricted, and the output from the Program\nis covered only if its contents constitute a work based on the\nProgram (independent of having been made by running the Program).\nWhether that is true depends on what the Program does.\n\n  1. You may copy and distribute verbatim copies of the Program's\nsource code as you receive it, in any medium, provided that you\nconspicuously and appropriately publish on each copy an appropriate\ncopyright notice and disclaimer of warranty; keep intact all the\nnotices that refer to this License and to the absence of any warranty;\nand give any other recipients of the Program a copy of this License\nalong with the Program.\n\nYou may charge a fee for the physical act of transferring a copy, and\nyou may at your option offer warranty protection in exchange for a fee.\n\n  2. You may modify your copy or copies of the Program or any portion\nof it, thus forming a work based on the Program, and copy and\ndistribute such modifications or work under the terms of Section 1\nabove, provided that you also meet all of these conditions:\n\n    a) You must cause the modified files to carry prominent notices\n    stating that you changed the files and the date of any change.\n\n    b) You must cause any work that you distribute or publish, that in\n    whole or in part contains or is derived from the Program or any\n    part thereof, to be licensed as a whole at no charge to all third\n    parties under the terms of this License.\n\n    c) If the modified program normally reads commands interactively\n    when run, you must cause it, when started running for such\n    interactive use in the most ordinary way, to print or display an\n    announcement including an appropriate copyright notice and a\n    notice that there is no warranty (or else, saying that you provide\n    a warranty) and that users may redistribute the program under\n    these conditions, and telling the user how to view a copy of this\n    License.  (Exception: if the Program itself is interactive but\n    does not normally print such an announcement, your work based on\n    the Program is not required to print an announcement.)\n\nThese requirements apply to the modified work as a whole.  If\nidentifiable sections of that work are not derived from the Program,\nand can be reasonably considered independent and separate works in\nthemselves, then this License, and its terms, do not apply to those\nsections when you distribute them as separate works.  But when you\ndistribute the same sections as part of a whole which is a work based\non the Program, the distribution of the whole must be on the terms of\nthis License, whose permissions for other licensees extend to the\nentire whole, and thus to each and every part regardless of who wrote it.\n\nThus, it is not the intent of this section to claim rights or contest\nyour rights to work written entirely by you; rather, the intent is to\nexercise the right to control the distribution of derivative or\ncollective works based on the Program.\n\nIn addition, mere aggregation of another work not based on the Program\nwith the Program (or with a work based on the Program) on a volume of\na storage or distribution medium does not bring the other work under\nthe scope of this License.\n\n  3. You may copy and distribute the Program (or a work based on it,\nunder Section 2) in object code or executable form under the terms of\nSections 1 and 2 above provided that you also do one of the following:\n\n    a) Accompany it with the complete corresponding machine-readable\n    source code, which must be distributed under the terms of Sections\n    1 and 2 above on a medium customarily used for software interchange; or,\n\n    b) Accompany it with a written offer, valid for at least three\n    years, to give any third party, for a charge no more than your\n    cost of physically performing source distribution, a complete\n    machine-readable copy of the corresponding source code, to be\n    distributed under the terms of Sections 1 and 2 above on a medium\n    customarily used for software interchange; or,\n\n    c) Accompany it with the information you received as to the offer\n    to distribute corresponding source code.  (This alternative is\n    allowed only for noncommercial distribution and only if you\n    received the program in object code or executable form with such\n    an offer, in accord with Subsection b above.)\n\nThe source code for a work means the preferred form of the work for\nmaking modifications to it.  For an executable work, complete source\ncode means all the source code for all modules it contains, plus any\nassociated interface definition files, plus the scripts used to\ncontrol compilation and installation of the executable.  However, as a\nspecial exception, the source code distributed need not include\nanything that is normally distributed (in either source or binary\nform) with the major components (compiler, kernel, and so on) of the\noperating system on which the executable runs, unless that component\nitself accompanies the executable.\n\nIf distribution of executable or object code is made by offering\naccess to copy from a designated place, then offering equivalent\naccess to copy the source code from the same place counts as\ndistribution of the source code, even though third parties are not\ncompelled to copy the source along with the object code.\n\n  4. You may not copy, modify, sublicense, or distribute the Program\nexcept as expressly provided under this License.  Any attempt\notherwise to copy, modify, sublicense or distribute the Program is\nvoid, and will automatically terminate your rights under this License.\nHowever, parties who have received copies, or rights, from you under\nthis License will not have their licenses terminated so long as such\nparties remain in full compliance.\n\n  5. You are not required to accept this License, since you have not\nsigned it.  However, nothing else grants you permission to modify or\ndistribute the Program or its derivative works.  These actions are\nprohibited by law if you do not accept this License.  Therefore, by\nmodifying or distributing the Program (or any work based on the\nProgram), you indicate your acceptance of this License to do so, and\nall its terms and conditions for copying, distributing or modifying\nthe Program or works based on it.\n\n  6. Each time you redistribute the Program (or any work based on the\nProgram), the recipient automatically receives a license from the\noriginal licensor to copy, distribute or modify the Program subject to\nthese terms and conditions.  You may not impose any further\nrestrictions on the recipients' exercise of the rights granted herein.\nYou are not responsible for enforcing compliance by third parties to\nthis License.\n\n  7. If, as a consequence of a court judgment or allegation of patent\ninfringement or for any other reason (not limited to patent issues),\nconditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot\ndistribute so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you\nmay not distribute the Program at all.  For example, if a patent\nlicense would not permit royalty-free redistribution of the Program by\nall those who receive copies directly or indirectly through you, then\nthe only way you could satisfy both it and this License would be to\nrefrain entirely from distribution of the Program.\n\nIf any portion of this section is held invalid or unenforceable under\nany particular circumstance, the balance of the section is intended to\napply and the section as a whole is intended to apply in other\ncircumstances.\n\nIt is not the purpose of this section to induce you to infringe any\npatents or other property right claims or to contest validity of any\nsuch claims; this section has the sole purpose of protecting the\nintegrity of the free software distribution system, which is\nimplemented by public license practices.  Many people have made\ngenerous contributions to the wide range of software distributed\nthrough that system in reliance on consistent application of that\nsystem; it is up to the author/donor to decide if he or she is willing\nto distribute software through any other system and a licensee cannot\nimpose that choice.\n\nThis section is intended to make thoroughly clear what is believed to\nbe a consequence of the rest of this License.\n\n  8. If the distribution and/or use of the Program is restricted in\ncertain countries either by patents or by copyrighted interfaces, the\noriginal copyright holder who places the Program under this License\nmay add an explicit geographical distribution limitation excluding\nthose countries, so that distribution is permitted only in or among\ncountries not thus excluded.  In such case, this License incorporates\nthe limitation as if written in the body of this License.\n\n  9. The Free Software Foundation may publish revised and/or new versions\nof the General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\nEach version is given a distinguishing version number.  If the Program\nspecifies a version number of this License which applies to it and \"any\nlater version\", you have the option of following the terms and conditions\neither of that version or of any later version published by the Free\nSoftware Foundation.  If the Program does not specify a version number of\nthis License, you may choose any version ever published by the Free Software\nFoundation.\n\n  10. If you wish to incorporate parts of the Program into other free\nprograms whose distribution conditions are different, write to the author\nto ask for permission.  For software which is copyrighted by the Free\nSoftware Foundation, write to the Free Software Foundation; we sometimes\nmake exceptions for this.  Our decision will be guided by the two goals\nof preserving the free status of all derivatives of our free software and\nof promoting the sharing and reuse of software generally.\n\n                            NO WARRANTY\n\n  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY\nFOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN\nOTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES\nPROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED\nOR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS\nTO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE\nPROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,\nREPAIR OR CORRECTION.\n\n  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR\nREDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,\nINCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING\nOUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED\nTO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY\nYOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER\nPROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGES.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nconvey the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\nAlso add information on how to contact you by electronic and paper mail.\n\nIf the program is interactive, make it output a short notice like this\nwhen it starts in an interactive mode:\n\n    Gnomovision version 69, Copyright (C) year name of author\n    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, the commands you use may\nbe called something other than `show w' and `show c'; they could even be\nmouse-clicks or menu items--whatever suits your program.\n\nYou should also get your employer (if you work as a programmer) or your\nschool, if any, to sign a \"copyright disclaimer\" for the program, if\nnecessary.  Here is a sample; alter the names:\n\n  Yoyodyne, Inc., hereby disclaims all copyright interest in the program\n  `Gnomovision' (which makes passes at compilers) written by James Hacker.\n\n  <signature of Ty Coon>, 1 April 1989\n  Ty Coon, President of Vice\n\nThis General Public License does not permit incorporating your program into\nproprietary programs.  If your program is a subroutine library, you may\nconsider it more useful to permit linking proprietary applications with the\nlibrary.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.\n"
        },
        {
          "name": "Doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 8.5966796875,
          "content": "REV\t= HEAD\n\n# version from an annotated tag\n_ver0\t= $(shell git describe $(REV) 2>/dev/null)\n# version from a plain tag\n_ver1\t= $(shell git describe --tags $(REV) 2>/dev/null)\n# SHA1\n_ver2\t= $(shell git rev-parse --verify --short $(REV) 2>/dev/null)\n# hand-made\n_ver3\t= v2.12.0\n\nVERSION\t= $(or $(_ver0),$(_ver1),$(_ver2),$(_ver3))\n\nall: main plugins man\n\n-include config.mk\ninclude scripts/lib.mk\n\nCFLAGS += -D_FILE_OFFSET_BITS=64\n\nCMUS_LIBS = $(PTHREAD_LIBS) $(NCURSES_LIBS) $(ICONV_LIBS) $(DL_LIBS) $(DISCID_LIBS) \\\n\t\t\t-lm $(COMPAT_LIBS) $(LIBSYSTEMD_LIBS)\n\ncommand_mode.o input.o main.o ui_curses.o op/pulse.lo: .version\ncommand_mode.o input.o main.o ui_curses.o op/pulse.lo: CFLAGS += -DVERSION=\\\"$(VERSION)\\\"\nmain.o server.o: CFLAGS += -DDEFAULT_PORT=3000\ndiscid.o: CFLAGS += $(DISCID_CFLAGS)\nmpris.o: CFLAGS += $(LIBSYSTEMD_CFLAGS)\n\n.version: Makefile\n\t@test \"`cat $@ 2> /dev/null`\" = \"$(VERSION)\" && exit 0; \\\n\techo \"   GEN    $@\"; echo $(VERSION) > $@\n\n# programs {{{\ncmus-y := \\\n\tape.o browser.o buffer.o cache.o channelmap.o cmdline.o cmus.o command_mode.o \\\n\tcomment.o convert.lo cue.o cue_utils.o debug.o discid.o editable.o expr.o \\\n\tfilters.o format_print.o gbuf.o glob.o help.o history.o http.o id3.o input.o \\\n\tjob.o keys.o keyval.o lib.o load_dir.o locking.o mergesort.o misc.o options.o \\\n\toutput.o pcm.o player.o play_queue.o pl.o pl_env.o rbtree.o read_wrapper.o \\\n\tsearch_mode.o search.o server.o spawn.o tabexp_file.o tabexp.o track_info.o \\\n\ttrack.o tree.o uchar.o u_collate.o ui_curses.o window.o worker.o xstrjoin.o\n\ncmus-$(CONFIG_MPRIS) += mpris.o\n\n$(cmus-y): CFLAGS += $(PTHREAD_CFLAGS) $(NCURSES_CFLAGS) $(ICONV_CFLAGS) $(DL_CFLAGS)\n\ncmus: $(cmus-y) file.o path.o prog.o xmalloc.o\n\t$(call cmd,ld,$(CMUS_LIBS))\n\ncmus-remote: main.o file.o misc.o path.o prog.o xmalloc.o xstrjoin.o\n\t$(call cmd,ld,$(COMPAT_LIBS))\n\n# cygwin compat\nDLLTOOL=dlltool\n\nlibcmus-$(CONFIG_CYGWIN) := libcmus.a\n\nlibcmus.a: $(cmus-y) file.o path.o prog.o xmalloc.o\n\t$(LD) -shared -o cmus.exe -Wl,--out-implib=libcmus.a -Wl,--base-file,cmus.base \\\n\t\t-Wl,--export-all-symbols -Wl,--no-whole-archive $^ $(CMUS_LIBS)\n\t$(DLLTOOL) --output-def cmus.def --dllname cmus.exe --export-all-symbols $^\n\t$(DLLTOOL) --base-file cmus.base --dllname cmus.exe --input-def cmus.def --output-exp cmus.exp\n\t$(LD) -o cmus.exe -Wl,cmus.exp $^ $(CMUS_LIBS)\n\n# }}}\n\n# input plugins {{{\ncdio-objs\t\t:= ip/cdio.lo\nflac-objs\t\t:= ip/flac.lo\nmad-objs\t\t:= ip/mad.lo ip/nomad.lo\nmikmod-objs\t\t:= ip/mikmod.lo\nmodplug-objs\t\t:= ip/modplug.lo\nbass-objs\t\t:= ip/bass.lo\nmpc-objs\t\t:= ip/mpc.lo\nvorbis-objs\t\t:= ip/vorbis.lo\nopus-objs\t\t:= ip/opus.lo\nwavpack-objs\t\t:= ip/wavpack.lo\nwav-objs\t\t:= ip/wav.lo\nmp4-objs\t\t:= ip/mp4.lo\naac-objs\t\t:= ip/aac.lo\nffmpeg-objs\t\t:= ip/ffmpeg.lo\ncue-objs\t\t:= ip/cue.lo\nvtx-objs\t\t:= ip/vtx.lo\n\nip-$(CONFIG_CDIO)\t+= ip/cdio.so\nip-$(CONFIG_FLAC)\t+= ip/flac.so\nip-$(CONFIG_MAD)\t+= ip/mad.so\nip-$(CONFIG_MIKMOD)\t+= ip/mikmod.so\nip-$(CONFIG_MODPLUG)\t+= ip/modplug.so\nip-$(CONFIG_BASS)\t+= ip/bass.so\nip-$(CONFIG_MPC)\t+= ip/mpc.so\nip-$(CONFIG_VORBIS)\t+= ip/vorbis.so\nip-$(CONFIG_OPUS)\t+= ip/opus.so\nip-$(CONFIG_WAVPACK)\t+= ip/wavpack.so\nip-$(CONFIG_WAV)\t+= ip/wav.so\nip-$(CONFIG_MP4)\t+= ip/mp4.so\nip-$(CONFIG_AAC)\t+= ip/aac.so\nip-$(CONFIG_FFMPEG)\t+= ip/ffmpeg.so\nip-$(CONFIG_CUE)\t+= ip/cue.so\nip-$(CONFIG_VTX)\t+= ip/vtx.so\n\n$(cdio-objs):\t\tCFLAGS += $(CDIO_CFLAGS) $(CDDB_CFLAGS)\n$(flac-objs):\t\tCFLAGS += $(FLAC_CFLAGS)\n$(mad-objs):\t\tCFLAGS += $(MAD_CFLAGS)\n$(mikmod-objs):\t\tCFLAGS += $(MIKMOD_CFLAGS)\n$(modplug-objs):\tCFLAGS += $(MODPLUG_CFLAGS)\n$(bass-objs):\t\tCFLAGS += $(BASS_CFLAGS)\n$(mpc-objs):\t\tCFLAGS += $(MPC_CFLAGS)\n$(vorbis-objs):\t\tCFLAGS += $(VORBIS_CFLAGS)\n$(opus-objs):\t\tCFLAGS += $(OPUS_CFLAGS)\n$(wavpack-objs):\tCFLAGS += $(WAVPACK_CFLAGS)\n$(mp4-objs):\t\tCFLAGS += $(MP4_CFLAGS)\n$(aac-objs):\t\tCFLAGS += $(AAC_CFLAGS)\n$(ffmpeg-objs):\t\tCFLAGS += $(FFMPEG_CFLAGS)\n$(vtx-objs):\t\tCFLAGS += $(VTX_CFLAGS)\n\nip/cdio.so: $(cdio-objs) $(libcmus-y)\n\t$(call cmd,ld_dl,$(CDIO_LIBS) $(CDDB_LIBS))\n\nip/flac.so: $(flac-objs) $(libcmus-y)\n\t$(call cmd,ld_dl,$(FLAC_LIBS))\n\nip/mad.so: $(mad-objs) $(libcmus-y)\n\t$(call cmd,ld_dl,-lm $(MAD_LIBS) $(ICONV_LIBS))\n\nip/mikmod.so: $(mikmod-objs) $(libcmus-y)\n\t$(call cmd,ld_dl,$(MIKMOD_LIBS))\n\nip/modplug.so: $(modplug-objs) $(libcmus-y)\n\t$(call cmd,ld_dl,$(MODPLUG_LIBS))\n\nip/bass.so: $(bass-objs) $(libcmus-y)\n\t$(call cmd,ld_dl,$(BASS_LIBS))\n\nip/mpc.so: $(mpc-objs) $(libcmus-y)\n\t$(call cmd,ld_dl,$(MPC_LIBS))\n\nip/vorbis.so: $(vorbis-objs) $(libcmus-y)\n\t$(call cmd,ld_dl,-lm $(VORBIS_LIBS))\n\nip/opus.so: $(opus-objs) $(libcmus-y)\n\t$(call cmd,ld_dl,$(OPUS_LIBS))\n\nip/wavpack.so: $(wavpack-objs) $(libcmus-y)\n\t$(call cmd,ld_dl,$(WAVPACK_LIBS))\n\nip/wav.so: $(wav-objs) $(libcmus-y)\n\t$(call cmd,ld_dl,)\n\nip/mp4.so: $(mp4-objs) $(libcmus-y)\n\t$(call cmd,ld_dl,$(MP4_LIBS))\n\nip/aac.so: $(aac-objs) $(libcmus-y)\n\t$(call cmd,ld_dl,$(AAC_LIBS))\n\nip/ffmpeg.so: $(ffmpeg-objs) $(libcmus-y)\n\t$(call cmd,ld_dl,$(FFMPEG_LIBS))\n\nip/cue.so: $(cue-objs) $(libcmus-y)\n\t$(call cmd,ld_dl,-lm)\n\nip/vtx.so: $(vtx-objs) $(libcmus-y)\n\t$(call cmd,ld_dl,$(VTX_LIBS))\n\n# }}}\n\n# output plugins {{{\npulse-objs\t\t:= op/pulse.lo\nalsa-objs\t\t:= op/alsa.lo op/mixer_alsa.lo\njack-objs\t\t:= op/jack.lo\narts-objs\t\t:= op/arts.lo\noss-objs\t\t:= op/oss.lo op/mixer_oss.lo\nsun-objs\t\t:= op/sun.lo op/mixer_sun.lo\nsndio-objs\t\t:= op/sndio.lo\nao-objs\t\t\t:= op/ao.lo\ncoreaudio-objs\t\t:= op/coreaudio.lo\nwaveout-objs\t\t:= op/waveout.lo\nroar-objs               := op/roar.lo\naaudio-objs\t\t:= op/aaudio.lo\n\nop-$(CONFIG_PULSE)\t+= op/pulse.so\nop-$(CONFIG_ALSA)\t+= op/alsa.so\nop-$(CONFIG_JACK)\t+= op/jack.so\nop-$(CONFIG_ARTS)\t+= op/arts.so\nop-$(CONFIG_OSS)\t+= op/oss.so\nop-$(CONFIG_SNDIO)\t+= op/sndio.so\nop-$(CONFIG_SUN)\t+= op/sun.so\nop-$(CONFIG_COREAUDIO)\t+= op/coreaudio.so\nop-$(CONFIG_AO)\t\t+= op/ao.so\nop-$(CONFIG_WAVEOUT)\t+= op/waveout.so\nop-$(CONFIG_ROAR)       += op/roar.so\nop-$(CONFIG_AAUDIO)\t+= op/aaudio.so\n\n$(pulse-objs): CFLAGS\t\t+= $(PULSE_CFLAGS)\n$(alsa-objs): CFLAGS\t\t+= $(ALSA_CFLAGS)\n$(jack-objs): CFLAGS\t\t+= $(JACK_CFLAGS) $(SAMPLERATE_CFLAGS)\n$(arts-objs): CFLAGS\t\t+= $(ARTS_CFLAGS)\n$(oss-objs):  CFLAGS\t\t+= $(OSS_CFLAGS)\n$(sndio-objs): CFLAGS\t\t+= $(SNDIO_CFLAGS)\n$(sun-objs):  CFLAGS\t\t+= $(SUN_CFLAGS)\n$(ao-objs):   CFLAGS\t\t+= $(AO_CFLAGS)\n$(coreaudio-objs): CFLAGS\t+= $(COREAUDIO_CFLAGS)\n$(waveout-objs): CFLAGS \t+= $(WAVEOUT_CFLAGS)\n$(roar-objs): CFLAGS\t\t+= $(ROAR_CFLAGS)\n$(aaudio-objs): CFLAGS\t\t+= $(AAUDIO_CFLAGS)\n\nop/pulse.so: $(pulse-objs) $(libcmus-y)\n\t$(call cmd,ld_dl,$(PULSE_LIBS))\n\nop/alsa.so: $(alsa-objs) $(libcmus-y)\n\t$(call cmd,ld_dl,$(ALSA_LIBS))\n\nop/jack.so: $(jack-objs) $(libcmus-y)\n\t$(call cmd,ld_dl,$(JACK_LIBS) $(SAMPLERATE_LIBS))\n\nop/arts.so: $(arts-objs) $(libcmus-y)\n\t$(call cmd,ld_dl,$(ARTS_LIBS))\n\nop/oss.so: $(oss-objs) $(libcmus-y)\n\t$(call cmd,ld_dl,$(OSS_LIBS))\n\nop/sndio.so: $(sndio-objs) $(libcmus-y)\n\t$(call cmd,ld_dl,$(SNDIO_LIBS))\n\nop/sun.so: $(sun-objs) $(libcmus-y)\n\t$(call cmd,ld_dl,$(SUN_LIBS))\n\nop/ao.so: $(ao-objs) $(libcmus-y)\n\t$(call cmd,ld_dl,$(AO_LIBS))\n\nop/coreaudio.so: $(coreaudio-objs) $(libcmus-y)\n\t$(call cmd,ld_dl,$(COREAUDIO_LIBS))\n\nop/waveout.so: $(waveout-objs) $(libcmus-y)\n\t$(call cmd,ld_dl,$(WAVEOUT_LIBS))\n\nop/roar.so: $(roar-objs) $(libcmus-y)\n\t$(call cmd,ld_dl,$(ROAR_LIBS))\n\nop/aaudio.so: $(aaudio-objs) $(libcmus-y)\n\t$(call cmd,ld_dl,$(AAUDIO_LIBS))\n# }}}\n\n# man {{{\nman1\t:= Doc/cmus.1 Doc/cmus-remote.1\nman7\t:= Doc/cmus-tutorial.7\n\n$(man1): Doc/ttman\n$(man7): Doc/ttman\n\n%.1: %.txt\n\t$(call cmd,ttman)\n\n%.7: %.txt\n\t$(call cmd,ttman)\n\nDoc/ttman.o: Doc/ttman.c\n\t$(call cmd,hostcc,)\n\nDoc/ttman: Doc/ttman.o\n\t$(call cmd,hostld,)\n\nquiet_cmd_ttman = MAN    $@\n      cmd_ttman = Doc/ttman $< $@\n# }}}\n\ndata\t\t= $(wildcard data/*)\n\nclean\t\t+= *.o ip/*.lo op/*.lo ip/*.so op/*.so *.lo cmus libcmus.a cmus.def cmus.base cmus.exp cmus-remote Doc/*.o Doc/ttman Doc/*.1 Doc/*.7 .install.log\ndistclean\t+= .version config.mk config/*.h tags\n\nmain: cmus cmus-remote\nplugins: $(ip-y) $(op-y)\nman: $(man1) $(man7)\n\ninstall-main: main\n\t$(INSTALL) -m755 $(bindir) cmus cmus-remote\n\ninstall-plugins: plugins\n\t$(INSTALL) -m755 $(libdir)/cmus/ip $(ip-y)\n\t$(INSTALL) -m755 $(libdir)/cmus/op $(op-y)\n\ninstall-data: man\n\t$(INSTALL) -m644 $(datadir)/cmus $(data)\n\t$(INSTALL) -m644 $(mandir)/man1 $(man1)\n\t$(INSTALL) -m644 $(mandir)/man7 $(man7)\n\t$(INSTALL) -m755 $(exampledir) cmus-status-display\n\ninstall: all install-main install-plugins install-data\n\ntags:\n\texuberant-ctags *.[ch]\n\n# generating tarball using GIT {{{\nTARNAME\t= cmus-$(VERSION)\n\ndist:\n\t@tarname=$(TARNAME);\t\t\t\t\t\t\\\n\ttest \"$(_ver2)\" || { echo \"No such revision $(REV)\"; exit 1; };\t\\\n\techo \"   DIST   $$tarname.tar.bz2\";\t\t\t\t\\\n\tgit archive --format=tar --prefix=$$tarname/ $(REV)^{tree} | bzip2 -c -9 > $$tarname.tar.bz2\n\n# }}}\n\n.PHONY: all main plugins man dist tags\n.PHONY: install install-main install-plugins install-man\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.091796875,
          "content": "# cmus — C\\* Music Player\n\nhttps://cmus.github.io/\n\n[![Build Status](https://github.com/cmus/cmus/actions/workflows/build.yml/badge.svg)](https://github.com/cmus/cmus/actions/workflows/build.yml)\n\nCopyright © 2004-2008 Timo Hirvonen <tihirvon@gmail.com>\n\nCopyright © 2008-2017 Various Authors\n\n\n## Configuration\n\n    $ ./configure\n\nBy default, features are auto-detected. To list all configuration options, run\n`./configure --help`. Some common autoconf-style options like `--prefix` are\nalso available.\n\nAfter running configure you can see from the generated `config.mk` file\nwhat features have been configured in (see the `CONFIG_*` options).\n\nThe packages containing dependencies on common distributions are listed below. All dependencies other than pkg-config and ncurses, iconv, and elogind/systemd are for optional input/output plugins. It is assumed that libc headers, a C compiler, git, and GNU Make are available.\n\n| Distro            | Dependencies |\n| :--               | :--          |\n| **Debian/Ubuntu** | apt install pkg-config libncursesw5-dev libfaad-dev libao-dev libasound2-dev libcddb2-dev libcdio-cdda-dev libdiscid-dev libavformat-dev libavcodec-dev libswresample-dev libflac-dev libjack-dev libmad0-dev libmodplug-dev libmpcdec-dev libsystemd-dev libopusfile-dev libpulse-dev libsamplerate0-dev libsndio-dev libvorbis-dev libwavpack-dev |\n| **Fedora/RHEL**   | dnf install 'pkgconfig(ncursesw)' 'pkgconfig(alsa)' 'pkgconfig(ao)' 'pkgconfig(libcddb)' 'pkgconfig(libcdio_cdda)' 'pkgconfig(libdiscid)' 'pkgconfig(libavformat)' 'pkgconfig(libavcodec)' 'pkgconfig(libswresample)' 'pkgconfig(flac)' 'pkgconfig(jack)' 'pkgconfig(mad)' 'pkgconfig(libmodplug)' libmpcdec-devel 'pkgconfig(libsystemd)' 'pkgconfig(opusfile)' 'pkgconfig(libpulse)' 'pkgconfig(samplerate)' 'pkgconfig(vorbisfile)' 'pkgconfig(wavpack)' |\n| **+ RPMFusion**   | dnf install faad2-devel libmp4v2-devel |\n| **Arch Linux**    | pacman -S pkg-config ncurses libiconv faad2 alsa-lib libao libcddb libcdio-paranoia libdiscid ffmpeg flac jack libmad libmodplug libmp4v2 libmpcdec systemd opusfile libpulse libsamplerate libvorbis wavpack |\n| **Alpine**        | apk add pkgconf ncurses-dev gnu-libiconv-dev alsa-lib-dev libao-dev libcddb-dev ffmpeg-dev flac-dev jack-dev libmad-dev libmodplug-dev elogind-dev opus-dev opusfile-dev pulseaudio-dev libsamplerate-dev libvorbis-dev wavpack-dev |\n| **Termux**        | apt install libandroid-support ncurses libiconv ffmpeg libmad libmodplug opusfile pulseaudio libflac libvorbis libwavpack |\n| **Homebrew**      | brew install pkg-config ncurses faad2 libao libcddb libcdio libdiscid ffmpeg flac jack mad libmodplug mp4v2 musepack opusfile libsamplerate libvorbis wavpack |\n\n\n## Building\n\n    $ make\n\nOr on some BSD systems you need to explicitly use GNU make:\n\n    $ gmake\n\n\n## Installation\n\n    $ make install\n\nOr to install to a temporary directory:\n\n    $ make install DESTDIR=~/tmp/cmus\n\nThis is useful when creating binary packages.\n\nRemember to replace `make` with `gmake` if needed.\n\n\n## Manuals\n\n    $ man cmus-tutorial\n\nAnd\n\n    $ man cmus\n\n\n## IRC Channel\n\nFeel free to join IRC channel #cmus on Libera.chat and share you experience,\nproblems and issues. Note: This is an unofficial channel and all people hanging\naround there are for the love of cmus.\n\n\n## Reporting Bugs\n\nBugs should be reported using the GitHub [issue\ntracker](https://github.com/cmus/cmus/issues). When creating a new issue, a\ntemplate will be shown containing instructions on how to collect the necessary\ninformation.\n\nAdditional debug information can be found in `~/cmus-debug.txt` if you\nconfigured cmus with maximum debug level (`./configure DEBUG=2`). In case of a\ncrash the last lines may be helpful.\n\n\n## Git Repository\n\nhttps://github.com/cmus/cmus\n\n    $ git clone https://github.com/cmus/cmus.git\n\n\n## Hacking\n\ncmus uses the [Linux kernel coding\nstyle](https://www.kernel.org/doc/html/latest/process/coding-style.html). Use\nhard tabs. Tabs are _always_ 8 characters wide. Keep the style consistent with\nrest of the code.\n\nBug fixes and implementations of new features should be suggested as a\n[pull request](https://github.com/cmus/cmus/pulls) directly on GitHub.\n\n"
        },
        {
          "name": "ape.c",
          "type": "blob",
          "size": 5.4365234375,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2006 Chun-Yu Shei <cshei AT cs.indiana.edu>\n *\n * Cleaned up by Timo Hirvonen <tihirvon@gmail.com>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"ape.h\"\n#include \"file.h\"\n#include \"xmalloc.h\"\n#include \"utils.h\"\n\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <strings.h>\n\n/* http://www.personal.uni-jena.de/~pfk/mpp/sv8/apetag.html */\n\n#define PREAMBLE_SIZE (8)\nstatic const char preamble[PREAMBLE_SIZE] = { 'A', 'P', 'E', 'T', 'A', 'G', 'E', 'X' };\n\n/* NOTE: not sizeof(struct ape_header)! */\n#define HEADER_SIZE (32)\n\n/* returns position of APE header or -1 if not found */\nstatic int find_ape_tag_slow(int fd)\n{\n\tchar buf[4096];\n\tint match = 0;\n\tint pos = 0;\n\n\t/* seek to start of file */\n\tif (lseek(fd, pos, SEEK_SET) == -1)\n\t\treturn -1;\n\n\twhile (1) {\n\t\tint i, got = read(fd, buf, sizeof(buf));\n\n\t\tif (got == -1) {\n\t\t\tif (errno == EAGAIN || errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\t\tif (got == 0)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < got; i++) {\n\t\t\tif (buf[i] != preamble[match]) {\n\t\t\t\tmatch = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmatch++;\n\t\t\tif (match == PREAMBLE_SIZE)\n\t\t\t\treturn pos + i + 1 - PREAMBLE_SIZE;\n\t\t}\n\t\tpos += got;\n\t}\n\treturn -1;\n}\n\nstatic int ape_parse_header(const char *buf, struct ape_header *h)\n{\n\tif (memcmp(buf, preamble, PREAMBLE_SIZE))\n\t\treturn 0;\n\n\th->version = read_le32(buf + 8);\n\th->size = read_le32(buf + 12);\n\th->count = read_le32(buf + 16);\n\th->flags = read_le32(buf + 20);\n\treturn 1;\n}\n\nstatic int read_header(int fd, struct ape_header *h)\n{\n\tchar buf[HEADER_SIZE];\n\n\tif (read_all(fd, buf, sizeof(buf)) != sizeof(buf))\n\t\treturn 0;\n\n\treturn ape_parse_header(buf, h);\n}\n\n/* sets fd right after the header and returns 1 if found,\n * otherwise returns 0\n */\nstatic int find_ape_tag(int fd, struct ape_header *h, int slow)\n{\n\tint pos;\n\n\tif (lseek(fd, -HEADER_SIZE, SEEK_END) == -1)\n\t\treturn 0;\n\tif (read_header(fd, h))\n\t\treturn 1;\n\n\t/* try to skip ID3v1 tag at the end of the file */\n\tif (lseek(fd, -(HEADER_SIZE + 128), SEEK_END) == -1)\n\t\treturn 0;\n\tif (read_header(fd, h))\n\t\treturn 1;\n\n\tif (!slow)\n\t\treturn 0;\n\n\tpos = find_ape_tag_slow(fd);\n\tif (pos == -1)\n\t\treturn 0;\n\tif (lseek(fd, pos, SEEK_SET) == -1)\n\t\treturn 0;\n\treturn read_header(fd, h);\n}\n\n/*\n * All keys are ASCII and length is 2..255\n *\n * UTF-8:\tArtist, Album, Title, Genre\n * Integer:\tTrack (N or N/M)\n * Date:\tYear (release), \"Record Date\"\n *\n * UTF-8 strings are NOT zero terminated.\n *\n * Also support \"discnumber\" (vorbis) and \"disc\" (non-standard)\n */\nstatic int ape_parse_one(const char *buf, int size, char **keyp, char **valp)\n{\n\tint pos = 0;\n\n\twhile (size - pos > 8) {\n\t\tuint32_t val_len, flags;\n\t\tchar *key, *val;\n\t\tint64_t max_key_len, key_len;\n\n\t\tval_len = read_le32(buf + pos); pos += 4;\n\t\tflags = read_le32(buf + pos); pos += 4;\n\n\t\tmax_key_len = size - pos - (int64_t)val_len - 1;\n\t\tif (max_key_len < 0) {\n\t\t\t/* corrupt */\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (key_len = 0; key_len < max_key_len && buf[pos + key_len]; key_len++)\n\t\t\t; /* nothing */\n\t\tif (buf[pos + key_len]) {\n\t\t\t/* corrupt */\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!AF_IS_UTF8(flags)) {\n\t\t\t/* ignore binary data */\n\t\t\tpos += key_len + 1 + val_len;\n\t\t\tcontinue;\n\t\t}\n\n\t\tkey = xstrdup(buf + pos);\n\t\tpos += key_len + 1;\n\n\t\t/* should not be NUL-terminated */\n\t\tval = xstrndup(buf + pos, val_len);\n\t\tpos += val_len;\n\n\t\t/* could be moved to comment.c but I don't think anyone else would use it */\n\t\tif (!strcasecmp(key, \"record date\") || !strcasecmp(key, \"year\")) {\n\t\t\tfree(key);\n\t\t\tkey = xstrdup(\"date\");\n\t\t}\n\n\t\tif (!strcasecmp(key, \"date\")) {\n\t\t\t/* Date format\n\t\t\t *\n\t\t\t * 1999-08-11 12:34:56\n\t\t\t * 1999-08-11 12:34\n\t\t\t * 1999-08-11\n\t\t\t * 1999-08\n\t\t\t * 1999\n\t\t\t * 1999-W34\t(week 34, totally crazy)\n\t\t\t *\n\t\t\t * convert to year, pl.c supports only years anyways\n\t\t\t *\n\t\t\t * FIXME: which one is the most common tag (year or record date)?\n\t\t\t */\n\t\t\tif (strlen(val) > 4)\n\t\t\t\tval[4] = 0;\n\t\t}\n\n\t\t*keyp = key;\n\t\t*valp = val;\n\t\treturn pos;\n\t}\n\treturn -1;\n}\n\n/* return the number of comments, or -1 */\nint ape_read_tags(struct apetag *ape, int fd, int slow)\n{\n\tstruct ape_header *h = &ape->header;\n\tint rc = -1;\n\toff_t old_pos;\n\n\t/* save position */\n\told_pos = lseek(fd, 0, SEEK_CUR);\n\n\tif (!find_ape_tag(fd, h, slow))\n\t\tgoto fail;\n\n\tif (AF_IS_FOOTER(h->flags)) {\n\t\t/* seek back right after the header */\n\t\tif (lseek(fd, -((int)h->size), SEEK_CUR) == -1)\n\t\t\tgoto fail;\n\t}\n\n\t/* ignore insane tags */\n\tif (h->size > 1024 * 1024)\n\t\tgoto fail;\n\n\tape->buf = xnew(char, h->size);\n\tif (read_all(fd, ape->buf, h->size) != h->size)\n\t\tgoto fail;\n\n\trc = h->count;\n\nfail:\n\tlseek(fd, old_pos, SEEK_SET);\n\treturn rc;\n}\n\n/* returned key-name must be free'd */\nchar *ape_get_comment(struct apetag *ape, char **val)\n{\n\tstruct ape_header *h = &ape->header;\n\tchar *key;\n\tint rc;\n\n\tif (ape->pos >= h->size)\n\t\treturn NULL;\n\n\trc = ape_parse_one(ape->buf + ape->pos, h->size - ape->pos, &key, val);\n\tif (rc < 0)\n\t\treturn NULL;\n\tape->pos += rc;\n\n\treturn key;\n}\n"
        },
        {
          "name": "ape.h",
          "type": "blob",
          "size": 1.525390625,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2007 Johannes Weißl\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_APE_H\n#define CMUS_APE_H\n\n#include <stdint.h>\n#include <stdlib.h>\n\nstruct ape_header {\n\t/* 1000 or 2000 (1.0, 2.0) */\n\tuint32_t version;\n\n\t/* tag size (header + tags, excluding footer) */\n\tuint32_t size;\n\n\t/* number of items */\n\tuint32_t count;\n\n\t/* global flags for each tag\n\t * there are also private flags for every tag\n\t * NOTE: 0 for version 1.0 (1000)\n\t */\n\tuint32_t flags;\n};\n\n/* ape flags */\n#define AF_IS_UTF8(f)\t\t(((f) & 6) == 0)\n#define AF_IS_FOOTER(f)\t\t(((f) & (1 << 29)) == 0)\n\nstruct apetag {\n\tchar *buf;\n\tint pos;\n\tstruct ape_header header;\n};\n\n#define APETAG(name) struct apetag name = { .buf = NULL, .pos = 0, }\n\nint ape_read_tags(struct apetag *ape, int fd, int slow);\nchar *ape_get_comment(struct apetag *ape, char **val);\n\nstatic inline void ape_free(struct apetag *ape)\n{\n\tfree(ape->buf);\n}\n\n#endif\n"
        },
        {
          "name": "browser.c",
          "type": "blob",
          "size": 10.28515625,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004-2005 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"browser.h\"\n#include \"load_dir.h\"\n#include \"cmus.h\"\n#include \"xmalloc.h\"\n#include \"ui_curses.h\"\n#include \"file.h\"\n#include \"misc.h\"\n#include \"options.h\"\n#include \"uchar.h\"\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/mman.h>\n\nstruct window *browser_win;\nstruct searchable *browser_searchable;\nchar *browser_dir;\n\nstatic LIST_HEAD(browser_head);\n\nstatic inline void browser_entry_to_iter(struct browser_entry *e, struct iter *iter)\n{\n\titer->data0 = &browser_head;\n\titer->data1 = e;\n\titer->data2 = NULL;\n}\n\n/* filter out names starting with '.' except '..' */\nstatic int normal_filter(const char *name, const struct stat *s)\n{\n\tif (name[0] == '.') {\n\t\tif (name[1] == '.' && name[2] == 0)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\tif (S_ISDIR(s->st_mode))\n\t\treturn 1;\n\treturn cmus_is_supported(name);\n}\n\n/* filter out '.' */\nstatic int hidden_filter(const char *name, const struct stat *s)\n{\n\tif (name[0] == '.' && name[1] == 0)\n\t\treturn 0;\n\treturn 1;\n}\n\n/* only works for BROWSER_ENTRY_DIR and BROWSER_ENTRY_FILE */\nstatic int entry_cmp(const struct browser_entry *a, const struct browser_entry *b)\n{\n\tif (a->type == BROWSER_ENTRY_DIR) {\n\t\tif (b->type == BROWSER_ENTRY_FILE)\n\t\t\treturn -1;\n\t\tif (!strcmp(a->name, \"../\"))\n\t\t\treturn -1;\n\t\tif (!strcmp(b->name, \"../\"))\n\t\t\treturn 1;\n\t\treturn strcmp(a->name, b->name);\n\t}\n\tif (b->type == BROWSER_ENTRY_DIR)\n\t\treturn 1;\n\treturn strcmp(a->name, b->name);\n}\n\nstatic char *fullname(const char *path, const char *name)\n{\n\tint l1, l2;\n\tchar *full;\n\n\tl1 = strlen(path);\n\tl2 = strlen(name);\n\tif (path[l1 - 1] == '/')\n\t\tl1--;\n\tfull = xnew(char, l1 + 1 + l2 + 1);\n\tmemcpy(full, path, l1);\n\tfull[l1] = '/';\n\tmemcpy(full + l1 + 1, name, l2 + 1);\n\treturn full;\n}\n\nstatic void free_browser_list(void)\n{\n\tstruct list_head *item;\n\n\titem = browser_head.next;\n\twhile (item != &browser_head) {\n\t\tstruct list_head *next = item->next;\n\t\tstruct browser_entry *entry;\n\n\t\tentry = list_entry(item, struct browser_entry, node);\n\t\tfree(entry);\n\t\titem = next;\n\t}\n\tlist_init(&browser_head);\n}\n\nstatic int add_pl_line(void *data, const char *line)\n{\n\tstruct browser_entry *e;\n\tint name_size = strlen(line) + 1;\n\n\te = xmalloc(sizeof(struct browser_entry) + name_size);\n\tmemcpy(e->name, line, name_size);\n\te->type = BROWSER_ENTRY_PLLINE;\n\tlist_add_tail(&e->node, &browser_head);\n\treturn 0;\n}\n\nstatic int do_browser_load(const char *name)\n{\n\tstruct stat st;\n\n\tif (stat(name, &st))\n\t\treturn -1;\n\n\tif (S_ISREG(st.st_mode) && cmus_is_playlist(name)) {\n\t\tchar *buf;\n\t\tssize_t size;\n\n\t\tbuf = mmap_file(name, &size);\n\t\tif (size == -1)\n\t\t\treturn -1;\n\n\t\tfree_browser_list();\n\n\t\tif (buf) {\n\t\t\tstruct browser_entry *parent_dir_e = xmalloc(sizeof(struct browser_entry) + 4);\n\t\t\tstrcpy(parent_dir_e->name, \"../\");\n\t\t\tparent_dir_e->type = BROWSER_ENTRY_DIR;\n\t\t\tlist_add_tail(&parent_dir_e->node, &browser_head);\n\n\t\t\tcmus_playlist_for_each(buf, size, 0, add_pl_line, NULL);\n\t\t\tmunmap(buf, size);\n\t\t}\n\t} else if (S_ISDIR(st.st_mode)) {\n\t\tint (*filter)(const char *, const struct stat *) = normal_filter;\n\t\tstruct directory dir;\n\t\tconst char *str;\n\t\tint root = !strcmp(name, \"/\");\n\n\t\tif (show_hidden)\n\t\t\tfilter = hidden_filter;\n\n\t\tif (dir_open(&dir, name))\n\t\t\treturn -1;\n\n\t\tfree_browser_list();\n\t\twhile ((str = dir_read(&dir))) {\n\t\t\tstruct browser_entry *e;\n\t\t\tstruct list_head *item;\n\t\t\tint len;\n\n\t\t\tif (!filter(str, &dir.st))\n\t\t\t\tcontinue;\n\n\t\t\t/* ignore .. if we are in the root dir */\n\t\t\tif (root && !strcmp(str, \"..\"))\n\t\t\t\tcontinue;\n\n\t\t\tlen = strlen(str);\n\t\t\te = xmalloc(sizeof(struct browser_entry) + len + 2);\n\t\t\te->type = BROWSER_ENTRY_FILE;\n\t\t\tmemcpy(e->name, str, len);\n\t\t\tif (S_ISDIR(dir.st.st_mode)) {\n\t\t\t\te->type = BROWSER_ENTRY_DIR;\n\t\t\t\te->name[len++] = '/';\n\t\t\t}\n\t\t\te->name[len] = 0;\n\n\t\t\titem = browser_head.prev;\n\t\t\twhile (item != &browser_head) {\n\t\t\t\tstruct browser_entry *other;\n\n\t\t\t\tother = container_of(item, struct browser_entry, node);\n\t\t\t\tif (entry_cmp(e, other) >= 0)\n\t\t\t\t\tbreak;\n\t\t\t\titem = item->prev;\n\t\t\t}\n\t\t\t/* add after item */\n\t\t\tlist_add(&e->node, item);\n\t\t}\n\t\tdir_close(&dir);\n\n\t\t/* try to update currect working directory */\n\t\tif (chdir(name))\n\t\t\treturn -1;\n\t} else {\n\t\terrno = ENOTDIR;\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int browser_load(const char *name)\n{\n\tint rc;\n\n\trc = do_browser_load(name);\n\tif (rc)\n\t\treturn rc;\n\n\twindow_set_contents(browser_win, &browser_head);\n\tfree(browser_dir);\n\tbrowser_dir = xstrdup(name);\n\treturn 0;\n}\n\nstatic GENERIC_ITER_PREV(browser_get_prev, struct browser_entry, node)\nstatic GENERIC_ITER_NEXT(browser_get_next, struct browser_entry, node)\n\nstatic int browser_search_get_current(void *data, struct iter *iter, enum search_direction dir)\n{\n\treturn window_get_sel(browser_win, iter);\n}\n\nstatic int browser_search_matches(void *data, struct iter *iter, const char *text)\n{\n\tchar **words = get_words(text);\n\tint matched = 0;\n\n\tif (words[0] != NULL) {\n\t\tstruct browser_entry *e;\n\t\tint i;\n\n\t\te = iter_to_browser_entry(iter);\n\t\tfor (i = 0; ; i++) {\n\t\t\tif (words[i] == NULL) {\n\t\t\t\twindow_set_sel(browser_win, iter);\n\t\t\t\tmatched = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (u_strcasestr_filename(e->name, words[i]) == NULL)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tfree_str_array(words);\n\treturn matched;\n}\n\nstatic const struct searchable_ops browser_search_ops = {\n\t.get_prev = browser_get_prev,\n\t.get_next = browser_get_next,\n\t.get_current = browser_search_get_current,\n\t.matches = browser_search_matches\n};\n\nvoid browser_init(void)\n{\n\tstruct iter iter;\n\tchar cwd[1024];\n\tchar *dir;\n\n\tif (getcwd(cwd, sizeof(cwd)) == NULL) {\n\t\tdir = xstrdup(\"/\");\n\t} else {\n\t\tdir = xstrdup(cwd);\n\t}\n\tif (do_browser_load(dir)) {\n\t\tfree(dir);\n\t\tdo_browser_load(\"/\");\n\t\tbrowser_dir = xstrdup(\"/\");\n\t} else {\n\t\tbrowser_dir = dir;\n\t}\n\n\tbrowser_win = window_new(browser_get_prev, browser_get_next);\n\twindow_set_contents(browser_win, &browser_head);\n\twindow_changed(browser_win);\n\n\titer.data0 = &browser_head;\n\titer.data1 = NULL;\n\titer.data2 = NULL;\n\tbrowser_searchable = searchable_new(NULL, &iter, &browser_search_ops);\n}\n\nvoid browser_exit(void)\n{\n\tsearchable_free(browser_searchable);\n\tfree_browser_list();\n\twindow_free(browser_win);\n\tfree(browser_dir);\n}\n\nint browser_chdir(const char *dir)\n{\n\tif (browser_load(dir)) {\n\t}\n\treturn 0;\n}\n\nvoid browser_up(void)\n{\n\tchar *new, *ptr, *pos;\n\tstruct browser_entry *e;\n\tint len;\n\n\tif (strcmp(browser_dir, \"/\") == 0)\n\t\treturn;\n\n\tptr = strrchr(browser_dir, '/');\n\tif (ptr == browser_dir) {\n\t\tnew = xstrdup(\"/\");\n\t} else {\n\t\tnew = xstrndup(browser_dir, ptr - browser_dir);\n\t}\n\n\t/* remember old position */\n\tptr++;\n\tlen = strlen(ptr);\n\tpos = xstrdup(ptr);\n\n\terrno = 0;\n\tif (browser_load(new)) {\n\t\tif (errno == ENOENT) {\n\t\t\tfree(pos);\n\t\t\tfree(browser_dir);\n\t\t\tbrowser_dir = new;\n\t\t\tbrowser_up();\n\t\t\treturn;\n\t\t}\n\t\terror_msg(\"could not open directory '%s': %s\\n\", new, strerror(errno));\n\t\tfree(new);\n\t\tfree(pos);\n\t\treturn;\n\t}\n\tfree(new);\n\n\t/* select old position */\n\tlist_for_each_entry(e, &browser_head, node) {\n\t\tif (strncmp(e->name, pos, len) == 0 &&\n\t\t    (e->name[len] == '/' || e->name[len] == '\\0')) {\n\t\t\tstruct iter iter;\n\n\t\t\tbrowser_entry_to_iter(e, &iter);\n\t\t\twindow_set_sel(browser_win, &iter);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree(pos);\n}\n\nstatic void browser_cd(const char *dir)\n{\n\tchar *new;\n\tint len;\n\n\tif (strcmp(dir, \"../\") == 0) {\n\t\tbrowser_up();\n\t\treturn;\n\t}\n\n\tnew = fullname(browser_dir, dir);\n\tlen = strlen(new);\n\tif (new[len - 1] == '/')\n\t\tnew[len - 1] = 0;\n\tif (browser_load(new))\n\t\terror_msg(\"could not open directory '%s': %s\\n\", dir, strerror(errno));\n\tfree(new);\n}\n\nstatic void browser_cd_playlist(const char *filename)\n{\n\tif (browser_load(filename))\n\t\terror_msg(\"could not read playlist '%s': %s\\n\", filename, strerror(errno));\n}\n\nvoid browser_enter(void)\n{\n\tstruct browser_entry *e;\n\tstruct iter sel;\n\tint len;\n\n\tif (!window_get_sel(browser_win, &sel))\n\t\treturn;\n\te = iter_to_browser_entry(&sel);\n\tlen = strlen(e->name);\n\tif (len == 0)\n\t\treturn;\n\tif (e->type == BROWSER_ENTRY_DIR) {\n\t\tbrowser_cd(e->name);\n\t} else {\n\t\tif (e->type == BROWSER_ENTRY_PLLINE) {\n\t\t\tcmus_play_file(e->name);\n\t\t} else {\n\t\t\tchar *filename;\n\n\t\t\tfilename = fullname(browser_dir, e->name);\n\t\t\tif (cmus_is_playlist(filename)) {\n\t\t\t\tbrowser_cd_playlist(filename);\n\t\t\t} else {\n\t\t\t\tcmus_play_file(filename);\n\t\t\t}\n\t\t\tfree(filename);\n\t\t}\n\t}\n}\n\nchar *browser_get_sel(void)\n{\n\tstruct browser_entry *e;\n\tstruct iter sel;\n\n\tif (!window_get_sel(browser_win, &sel))\n\t\treturn NULL;\n\n\te = iter_to_browser_entry(&sel);\n\tif (e->type == BROWSER_ENTRY_PLLINE)\n\t\treturn xstrdup(e->name);\n\n\treturn fullname(browser_dir, e->name);\n}\n\nvoid browser_delete(void)\n{\n\tstruct browser_entry *e;\n\tstruct iter sel;\n\tint len;\n\n\tif (!window_get_sel(browser_win, &sel))\n\t\treturn;\n\te = iter_to_browser_entry(&sel);\n\tlen = strlen(e->name);\n\tif (len == 0)\n\t\treturn;\n\tif (e->type == BROWSER_ENTRY_FILE) {\n\t\tchar *name;\n\n\t\tname = fullname(browser_dir, e->name);\n\t\tif (yes_no_query(\"Delete file '%s'? [y/N]\", e->name) == UI_QUERY_ANSWER_YES) {\n\t\t\tif (unlink(name) == -1) {\n\t\t\t\terror_msg(\"deleting '%s': %s\", e->name, strerror(errno));\n\t\t\t} else {\n\t\t\t\twindow_row_vanishes(browser_win, &sel);\n\t\t\t\tlist_del(&e->node);\n\t\t\t\tfree(e);\n\t\t\t}\n\t\t}\n\t\tfree(name);\n\t}\n}\n\nvoid browser_reload(void)\n{\n\tchar *tmp = xstrdup(browser_dir);\n\tchar *sel = NULL;\n\tstruct iter iter;\n\tstruct browser_entry *e;\n\n\t/* remember selection */\n\tif (window_get_sel(browser_win, &iter)) {\n\t\te = iter_to_browser_entry(&iter);\n\t\tsel = xstrdup(e->name);\n\t}\n\n\t/* have to use tmp  */\n\tif (browser_load(tmp)) {\n\t\terror_msg(\"could not update contents '%s': %s\\n\", tmp, strerror(errno));\n\t\tfree(tmp);\n\t\tfree(sel);\n\t\treturn;\n\t}\n\n\tif (sel) {\n\t\t/* set selection */\n\t\tlist_for_each_entry(e, &browser_head, node) {\n\t\t\tif (strcmp(e->name, sel) == 0) {\n\t\t\t\tbrowser_entry_to_iter(e, &iter);\n\t\t\t\twindow_set_sel(browser_win, &iter);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfree(tmp);\n\tfree(sel);\n}\n"
        },
        {
          "name": "browser.h",
          "type": "blob",
          "size": 1.4169921875,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_BROWSER_H\n#define CMUS_BROWSER_H\n\n#include \"list.h\"\n#include \"window.h\"\n#include \"search.h\"\n\nstruct browser_entry {\n\tstruct list_head node;\n\n\tenum { BROWSER_ENTRY_DIR, BROWSER_ENTRY_FILE, BROWSER_ENTRY_PLLINE } type;\n\tchar name[];\n};\n\nstatic inline struct browser_entry *iter_to_browser_entry(struct iter *iter)\n{\n\treturn iter->data1;\n}\n\nextern struct window *browser_win;\nextern char *browser_dir;\nextern struct searchable *browser_searchable;\n\nvoid browser_init(void);\nvoid browser_exit(void);\nint browser_chdir(const char *dir);\nchar *browser_get_sel(void);\nvoid browser_up(void);\nvoid browser_enter(void);\nvoid browser_delete(void);\nvoid browser_reload(void);\nvoid browser_toggle_show_hidden(void);\n\n#endif\n"
        },
        {
          "name": "buffer.c",
          "type": "blob",
          "size": 4.2587890625,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"buffer.h\"\n#include \"xmalloc.h\"\n#include \"locking.h\"\n#include \"debug.h\"\n\n/*\n * chunk can be accessed by either consumer OR producer, not both at same time\n * -> no need to lock\n */\nstruct chunk {\n\tchar data[CHUNK_SIZE];\n\n\t/* index to data, first filled byte */\n\tunsigned int l;\n\n\t/* index to data, last filled byte + 1\n\t *\n\t * there are h - l bytes available (filled)\n\t */\n\tunsigned int h : 31;\n\n\t/* if chunk is marked filled it can only be accessed by consumer\n\t * otherwise only producer is allowed to access the chunk\n\t */\n\tunsigned int filled : 1;\n};\n\nunsigned int buffer_nr_chunks;\n\nstatic pthread_mutex_t buffer_mutex = CMUS_MUTEX_INITIALIZER;\nstatic struct chunk *buffer_chunks = NULL;\nstatic unsigned int buffer_ridx;\nstatic unsigned int buffer_widx;\n\nvoid buffer_init(void)\n{\n\tfree(buffer_chunks);\n\tbuffer_chunks = xnew(struct chunk, buffer_nr_chunks);\n\tbuffer_reset();\n}\n\nvoid buffer_free(void)\n{\n\tfree(buffer_chunks);\n}\n\n/*\n * @pos: returned pointer to available data\n *\n * Returns number of bytes available at @pos\n *\n * After reading bytes mark them consumed calling buffer_consume().\n */\nint buffer_get_rpos(char **pos)\n{\n\tstruct chunk *c;\n\tint size = 0;\n\n\tcmus_mutex_lock(&buffer_mutex);\n\tc = &buffer_chunks[buffer_ridx];\n\tif (c->filled) {\n\t\tsize = c->h - c->l;\n\t\t*pos = c->data + c->l;\n\t}\n\tcmus_mutex_unlock(&buffer_mutex);\n\n\treturn size;\n}\n\n/*\n * @pos: pointer to buffer position where data can be written\n *\n * Returns number of bytes can be written to @pos.  If the return value is\n * non-zero it is guaranteed to be >= 1024.\n *\n * After writing bytes mark them filled calling buffer_fill().\n */\nint buffer_get_wpos(char **pos)\n{\n\tstruct chunk *c;\n\tint size = 0;\n\n\tcmus_mutex_lock(&buffer_mutex);\n\tc = &buffer_chunks[buffer_widx];\n\tif (!c->filled) {\n\t\tsize = CHUNK_SIZE - c->h;\n\t\t*pos = c->data + c->h;\n\t}\n\tcmus_mutex_unlock(&buffer_mutex);\n\n\treturn size;\n}\n\nvoid buffer_consume(int count)\n{\n\tstruct chunk *c;\n\n\tBUG_ON(count < 0);\n\tcmus_mutex_lock(&buffer_mutex);\n\tc = &buffer_chunks[buffer_ridx];\n\tBUG_ON(!c->filled);\n\tc->l += count;\n\tif (c->l == c->h) {\n\t\tc->l = 0;\n\t\tc->h = 0;\n\t\tc->filled = 0;\n\t\tbuffer_ridx++;\n\t\tbuffer_ridx %= buffer_nr_chunks;\n\t}\n\tcmus_mutex_unlock(&buffer_mutex);\n}\n\n/* chunk is marked filled if free bytes < 1024 or count == 0 */\nint buffer_fill(int count)\n{\n\tstruct chunk *c;\n\tint filled = 0;\n\n\tcmus_mutex_lock(&buffer_mutex);\n\tc = &buffer_chunks[buffer_widx];\n\tBUG_ON(c->filled);\n\tc->h += count;\n\n\tif (CHUNK_SIZE - c->h < 1024 || (count == 0 && c->h > 0)) {\n\t\tc->filled = 1;\n\t\tbuffer_widx++;\n\t\tbuffer_widx %= buffer_nr_chunks;\n\t\tfilled = 1;\n\t}\n\n\tcmus_mutex_unlock(&buffer_mutex);\n\treturn filled;\n}\n\nvoid buffer_reset(void)\n{\n\tint i;\n\n\tcmus_mutex_lock(&buffer_mutex);\n\tbuffer_ridx = 0;\n\tbuffer_widx = 0;\n\tfor (i = 0; i < buffer_nr_chunks; i++) {\n\t\tbuffer_chunks[i].l = 0;\n\t\tbuffer_chunks[i].h = 0;\n\t\tbuffer_chunks[i].filled = 0;\n\t}\n\tcmus_mutex_unlock(&buffer_mutex);\n}\n\nint buffer_get_filled_chunks(void)\n{\n\tint c;\n\n\tcmus_mutex_lock(&buffer_mutex);\n\tif (buffer_ridx < buffer_widx) {\n\t\t/*\n\t\t * |__##########____|\n\t\t *    r         w\n\t\t *\n\t\t * |############____|\n\t\t *  r           w\n\t\t */\n\t\tc = buffer_widx - buffer_ridx;\n\t} else if (buffer_ridx > buffer_widx) {\n\t\t/*\n\t\t * |#######______###|\n\t\t *         w     r\n\t\t *\n\t\t * |_____________###|\n\t\t *  w            r\n\t\t */\n\t\tc = buffer_nr_chunks - buffer_ridx + buffer_widx;\n\t} else {\n\t\t/*\n\t\t * |################|\n\t\t *     r\n\t\t *     w\n\t\t *\n\t\t * |________________|\n\t\t *     r\n\t\t *     w\n\t\t */\n\t\tif (buffer_chunks[buffer_ridx].filled) {\n\t\t\tc = buffer_nr_chunks;\n\t\t} else {\n\t\t\tc = 0;\n\t\t}\n\t}\n\tcmus_mutex_unlock(&buffer_mutex);\n\treturn c;\n}\n"
        },
        {
          "name": "buffer.h",
          "type": "blob",
          "size": 1.416015625,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_BUFFER_H\n#define CMUS_BUFFER_H\n\n/*\n * must be a multiple of any supported frame size\n *\n * 12 is the LCM of 1, 2, 3 and 4, which corresponds to\n * 8, 16, 24 and 32 bits respectively\n *\n * 840 is the LCM of 1, 2, 3, 4, 5, 6, 7 and 8, which\n * are the numbers of supported channels\n *\n * we used to define the value as 60 * 1024 = 61440\n * hence the extra 6, which makes the new value 60480\n */\n#define CHUNK_SIZE (12 * 840 * 6)\n\nextern unsigned int buffer_nr_chunks;\n\nvoid buffer_init(void);\nvoid buffer_free(void);\nint buffer_get_rpos(char **pos);\nint buffer_get_wpos(char **pos);\nvoid buffer_consume(int count);\nint buffer_fill(int count);\nvoid buffer_reset(void);\nint buffer_get_filled_chunks(void);\n\n#endif\n"
        },
        {
          "name": "cache.c",
          "type": "blob",
          "size": 12.1396484375,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"cache.h\"\n#include \"misc.h\"\n#include \"file.h\"\n#include \"input.h\"\n#include \"track_info.h\"\n#include \"utils.h\"\n#include \"xmalloc.h\"\n#include \"xstrjoin.h\"\n#include \"gbuf.h\"\n#include \"options.h\"\n#include \"pl_env.h\"\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdbool.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/mman.h>\n\n#define CACHE_VERSION   0x0d\n\n#define CACHE_64_BIT\t0x01\n#define CACHE_BE\t0x02\n\n#define CACHE_RESERVED_PATTERN  \t0xff\n\n#define CACHE_ENTRY_USED_SIZE\t\t28\n#define CACHE_ENTRY_RESERVED_SIZE\t52\n#define CACHE_ENTRY_TOTAL_SIZE\t(CACHE_ENTRY_RESERVED_SIZE + CACHE_ENTRY_USED_SIZE)\n\n// Cmus Track Cache version X + 4 bytes flags\nstatic char cache_header[8] = \"CTC\\0\\0\\0\\0\\0\";\n\n// host byte order\n// mtime is either 32 or 64 bits\nstruct cache_entry {\n\t// size of this struct including size itself\n\tuint32_t size;\n\n\tint32_t play_count;\n\tint64_t mtime;\n\tint32_t duration;\n\tint32_t bitrate;\n\tint32_t bpm;\n\n\t// when introducing new fields decrease the reserved space accordingly\n\tuint8_t _reserved[CACHE_ENTRY_RESERVED_SIZE];\n\n\t// filename, codec, codec_profile and N * (key, val)\n\tchar strings[];\n};\n\n// make sure our mmap/sizeof-based code works\nSTATIC_ASSERT(CACHE_ENTRY_TOTAL_SIZE == sizeof(struct cache_entry));\nSTATIC_ASSERT(CACHE_ENTRY_TOTAL_SIZE == offsetof(struct cache_entry, strings));\n\n\n#define ALIGN(size) (((size) + sizeof(long) - 1) & ~(sizeof(long) - 1))\n#define HASH_SIZE 1023\n\nstatic struct track_info *hash_table[HASH_SIZE];\nstatic char *cache_filename;\nstatic int total;\n\nstruct fifo_mutex cache_mutex = FIFO_MUTEX_INITIALIZER;\n\n\nstatic void add_ti(struct track_info *ti, unsigned int hash)\n{\n\tunsigned int pos = hash % HASH_SIZE;\n\tstruct track_info *next = hash_table[pos];\n\n\tti->next = next;\n\thash_table[pos] = ti;\n\ttotal++;\n}\n\nstatic int valid_cache_entry(const struct cache_entry *e, unsigned int avail)\n{\n\tunsigned int min_size = sizeof(*e);\n\tunsigned int str_size;\n\tint i, count;\n\n\tif (avail < min_size)\n\t\treturn 0;\n\n\tif (e->size < min_size || e->size > avail)\n\t\treturn 0;\n\n\tstr_size = e->size - min_size;\n\tcount = 0;\n\tfor (i = 0; i < str_size; i++) {\n\t\tif (!e->strings[i])\n\t\t\tcount++;\n\t}\n\tif (count % 2 == 0)\n\t\treturn 0;\n\tif (e->strings[str_size - 1])\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic struct track_info *cache_entry_to_ti(struct cache_entry *e)\n{\n\tconst char *strings = e->strings;\n\tstruct track_info *ti;\n\tstruct keyval *kv;\n\tint str_size = e->size - sizeof(*e);\n\tint pos, i, count;\n\tchar *proc_filename;\n\n\tif (pl_env_var(strings, NULL) && (proc_filename = pl_env_expand(strings))) {\n\t\tti = track_info_new(proc_filename);\n\t\tfree(proc_filename);\n\t} else {\n\t\tti = track_info_new(strings);\n\t}\n\n\tti->duration = e->duration;\n\tti->bitrate = e->bitrate;\n\tti->mtime = e->mtime;\n\tti->play_count = e->play_count;\n\tti->bpm = e->bpm;\n\n\t// count strings (filename + codec + codec_profile + key/val pairs)\n\tcount = 0;\n\tfor (i = 0; i < str_size; i++) {\n\t\tif (!strings[i])\n\t\t\tcount++;\n\t}\n\tcount = (count - 3) / 2;\n\n\t// NOTE: filename already copied by track_info_new()\n\tpos = strlen(strings) + 1;\n\tti->codec = strings[pos] ? xstrdup(strings + pos) : NULL;\n\tpos += strlen(strings + pos) + 1;\n\tti->codec_profile = strings[pos] ? xstrdup(strings + pos) : NULL;\n\tpos += strlen(strings + pos) + 1;\n\tkv = xnew(struct keyval, count + 1);\n\tfor (i = 0; i < count; i++) {\n\t\tint size;\n\n\t\tsize = strlen(strings + pos) + 1;\n\t\tkv[i].key = xstrdup(strings + pos);\n\t\tpos += size;\n\n\t\tsize = strlen(strings + pos) + 1;\n\t\tkv[i].val = xstrdup(strings + pos);\n\t\tpos += size;\n\t}\n\tkv[i].key = NULL;\n\tkv[i].val = NULL;\n\ttrack_info_set_comments(ti, kv);\n\treturn ti;\n}\n\nstruct track_info *lookup_cache_entry(const char *filename, unsigned int hash)\n{\n\tstruct track_info *ti = hash_table[hash % HASH_SIZE];\n\n\twhile (ti) {\n\t\tif (!strcmp(filename, ti->filename))\n\t\t\treturn ti;\n\t\tti = ti->next;\n\t}\n\treturn NULL;\n}\n\nstatic void do_cache_remove_ti(struct track_info *ti, unsigned int hash)\n{\n\tunsigned int pos = hash % HASH_SIZE;\n\tstruct track_info *t = hash_table[pos];\n\tstruct track_info *next, *prev = NULL;\n\n\twhile (t) {\n\t\tnext = t->next;\n\t\tif (t == ti) {\n\t\t\tif (prev) {\n\t\t\t\tprev->next = next;\n\t\t\t} else {\n\t\t\t\thash_table[pos] = next;\n\t\t\t}\n\t\t\ttotal--;\n\t\t\ttrack_info_unref(ti);\n\t\t\treturn;\n\t\t}\n\t\tprev = t;\n\t\tt = next;\n\t}\n}\n\nvoid cache_remove_ti(struct track_info *ti)\n{\n\tdo_cache_remove_ti(ti, hash_str(ti->filename));\n}\n\nstatic int read_cache(void)\n{\n\tunsigned int size, offset = 0;\n\tstruct stat st = {};\n\tchar *buf;\n\tint fd;\n\n\tfd = open(cache_filename, O_RDONLY);\n\tif (fd < 0) {\n\t\tif (errno == ENOENT)\n\t\t\treturn 0;\n\t\treturn -1;\n\t}\n\tfstat(fd, &st);\n\tif (st.st_size < sizeof(cache_header))\n\t\tgoto close;\n\tsize = st.st_size;\n\n\tbuf = mmap(NULL, size, PROT_READ, MAP_PRIVATE, fd, 0);\n\tif (buf == MAP_FAILED) {\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\tif (memcmp(buf, cache_header, sizeof(cache_header)))\n\t\tgoto corrupt;\n\n\toffset = sizeof(cache_header);\n\twhile (offset < size) {\n\t\tstruct cache_entry *e = (void *)(buf + offset);\n\t\tstruct track_info *ti;\n\n\t\tif (!valid_cache_entry(e, size - offset))\n\t\t\tgoto corrupt;\n\n\t\tti = cache_entry_to_ti(e);\n\t\tadd_ti(ti, hash_str(ti->filename));\n\t\toffset += ALIGN(e->size);\n\t}\n\tmunmap(buf, size);\n\tclose(fd);\n\treturn 0;\ncorrupt:\n\tmunmap(buf, size);\nclose:\n\tclose(fd);\n\t// corrupt\n\treturn -2;\n}\n\nint cache_init(void)\n{\n\tunsigned int flags = 0;\n\n#ifdef WORDS_BIGENDIAN\n\tflags |= CACHE_BE;\n#endif\n\tif (sizeof(long) == 8)\n\t\tflags |= CACHE_64_BIT;\n\n\tcache_header[7] = flags & 0xff; flags >>= 8;\n\tcache_header[6] = flags & 0xff; flags >>= 8;\n\tcache_header[5] = flags & 0xff; flags >>= 8;\n\tcache_header[4] = flags & 0xff;\n\n\t/* assumed version */\n\tcache_header[3] = CACHE_VERSION;\n\n\tcache_filename = xstrjoin(cmus_config_dir, \"/cache\");\n\treturn read_cache();\n}\n\nstatic int ti_filename_cmp(const void *a, const void *b)\n{\n\tconst struct track_info *ai = *(const struct track_info **)a;\n\tconst struct track_info *bi = *(const struct track_info **)b;\n\n\treturn strcmp(ai->filename, bi->filename);\n}\n\nstatic struct track_info **get_track_infos(bool reference)\n{\n\tstruct track_info **tis;\n\tint i, c;\n\n\ttis = xnew(struct track_info *, total);\n\tc = 0;\n\tfor (i = 0; i < HASH_SIZE; i++) {\n\t\tstruct track_info *ti = hash_table[i];\n\n\t\twhile (ti) {\n\t\t\tif (reference)\n\t\t\t\ttrack_info_ref(ti);\n\t\t\ttis[c++] = ti;\n\t\t\tti = ti->next;\n\t\t}\n\t}\n\tqsort(tis, total, sizeof(struct track_info *), ti_filename_cmp);\n\treturn tis;\n}\n\nstatic void flush_buffer(int fd, struct gbuf *buf)\n{\n\tif (buf->len) {\n\t\twrite_all(fd, buf->buffer, buf->len);\n\t\tgbuf_clear(buf);\n\t}\n}\n\nstatic void write_ti(int fd, struct gbuf *buf, struct track_info *ti, unsigned int *offsetp)\n{\n\tchar *proc_filename = pl_env_reduce(ti->filename);\n\tconst struct keyval *kv = ti->comments;\n\tunsigned int offset = *offsetp;\n\tunsigned int pad;\n\tstruct cache_entry e;\n\tint *len, alloc = 64, count, i;\n\n\tmemset(e._reserved, CACHE_RESERVED_PATTERN, sizeof(e._reserved));\n\n\tcount = 0;\n\tlen = xnew(int, alloc);\n\te.size = sizeof(e);\n\te.duration = ti->duration;\n\te.bitrate = ti->bitrate;\n\te.mtime = ti->mtime;\n\te.play_count = ti->play_count;\n\te.bpm = ti->bpm;\n\tlen[count] = strlen(proc_filename) + 1;\n\te.size += len[count++];\n\tlen[count] = (ti->codec ? strlen(ti->codec) : 0) + 1;\n\te.size += len[count++];\n\tlen[count] = (ti->codec_profile ? strlen(ti->codec_profile) : 0) + 1;\n\te.size += len[count++];\n\tfor (i = 0; kv[i].key; i++) {\n\t\tif (count + 2 > alloc) {\n\t\t\talloc *= 2;\n\t\t\tlen = xrenew(int, len, alloc);\n\t\t}\n\t\tlen[count] = strlen(kv[i].key) + 1;\n\t\te.size += len[count++];\n\t\tlen[count] = strlen(kv[i].val) + 1;\n\t\te.size += len[count++];\n\t}\n\n\tpad = ALIGN(offset) - offset;\n\tif (gbuf_avail(buf) < pad + e.size)\n\t\tflush_buffer(fd, buf);\n\n\tcount = 0;\n\tif (pad)\n\t\tgbuf_set(buf, 0, pad);\n\tgbuf_add_bytes(buf, &e, sizeof(e));\n\tgbuf_add_bytes(buf, proc_filename, len[count++]);\n\tgbuf_add_bytes(buf, ti->codec ? ti->codec : \"\", len[count++]);\n\tgbuf_add_bytes(buf, ti->codec_profile ? ti->codec_profile : \"\", len[count++]);\n\tfor (i = 0; kv[i].key; i++) {\n\t\tgbuf_add_bytes(buf, kv[i].key, len[count++]);\n\t\tgbuf_add_bytes(buf, kv[i].val, len[count++]);\n\t}\n\n\tfree(len);\n\t*offsetp = offset + pad + e.size;\n\n\tfree(proc_filename);\n}\n\nint cache_close(void)\n{\n\tGBUF(buf);\n\tstruct track_info **tis;\n\tunsigned int offset;\n\tint i, fd, rc;\n\tchar *tmp;\n\n\ttmp = xstrjoin(cmus_config_dir, \"/cache.tmp\");\n\tfd = open(tmp, O_WRONLY | O_CREAT | O_TRUNC, 0666);\n\tif (fd < 0) {\n\t\tfree(tmp);\n\t\treturn -1;\n\t}\n\n\ttis = get_track_infos(false);\n\n\tgbuf_grow(&buf, 64 * 1024 - 1);\n\tgbuf_add_bytes(&buf, cache_header, sizeof(cache_header));\n\toffset = sizeof(cache_header);\n\tfor (i = 0; i < total; i++)\n\t\twrite_ti(fd, &buf, tis[i], &offset);\n\tflush_buffer(fd, &buf);\n\tgbuf_free(&buf);\n\tfree(tis);\n\n\tclose(fd);\n\trc = rename(tmp, cache_filename);\n\tfree(tmp);\n\treturn rc;\n}\n\nstatic struct track_info *ip_get_ti(const char *filename)\n{\n\tstruct track_info *ti = NULL;\n\tstruct input_plugin *ip;\n\tstruct keyval *comments;\n\tint rc;\n\n\tip = ip_new(filename);\n\trc = ip_open(ip);\n\tif (rc) {\n\t\tip_delete(ip);\n\t\treturn NULL;\n\t}\n\n\trc = ip_read_comments(ip, &comments);\n\tif (!rc) {\n\t\tti = track_info_new(filename);\n\t\ttrack_info_set_comments(ti, comments);\n\t\tti->duration = ip_duration(ip);\n\t\tti->bitrate = ip_bitrate(ip);\n\t\tti->codec = ip_codec(ip);\n\t\tti->codec_profile = ip_codec_profile(ip);\n\t\tti->mtime = ip_is_remote(ip) ? -1 : file_get_mtime(filename);\n\t}\n\tip_delete(ip);\n\treturn ti;\n}\n\nstruct track_info *cache_get_ti(const char *filename, int force)\n{\n\tunsigned int hash = hash_str(filename);\n\tstruct track_info *ti;\n\tint reload = 0;\n\n\tif (pl_env_var(filename, NULL)) {\n\t\tstruct growing_keyvals c = {NULL, 0, 0};\n\t\tkeyvals_terminate(&c);\n\n\t\tti = track_info_new(filename);\n\t\tti->duration = 0;\n\t\ttrack_info_set_comments(ti, c.keyvals);\n\n\t\ttrack_info_ref(ti);\n\t\treturn ti;\n\t}\n\n\tti = lookup_cache_entry(filename, hash);\n\tif (ti) {\n\t\tif ((!skip_track_info && ti->duration == 0 && !is_http_url(filename)) || force){\n\t\t\tdo_cache_remove_ti(ti, hash);\n\t\t\tti = NULL;\n\t\t\treload = 1;\n\t\t}\n\t}\n\tif (!ti) {\n\t\tif (skip_track_info && !reload && !force) {\n\t\t\tstruct growing_keyvals c = {NULL, 0, 0};\n\n\t\t\tti = track_info_new(filename);\n\n\t\t\tkeyvals_terminate(&c);\n\t\t\ttrack_info_set_comments(ti, c.keyvals);\n\n\t\t\tti->duration = 0;\n\t\t} else {\n\t\t       \tti = ip_get_ti(filename);\n\t\t}\n\t\tif (!ti)\n\t\t\treturn NULL;\n\t\tadd_ti(ti, hash);\n\t}\n\ttrack_info_ref(ti);\n\treturn ti;\n}\n\nstruct track_info **cache_refresh(int *count, int force)\n{\n\tstruct track_info **tis = get_track_infos(true);\n\tint i, n = total;\n\n\tfor (i = 0; i < n; i++) {\n\t\tunsigned int hash;\n\t\tstruct track_info *ti = tis[i];\n\t\tstruct stat st;\n\t\tint rc = 0;\n\n\t\tcache_yield();\n\n\t\t/*\n\t\t * If no-one else has reference to tis[i] then it is set to NULL\n\t\t * otherwise:\n\t\t *\n\t\t * unchanged: tis[i] = NULL\n\t\t * deleted:   tis[i]->next = NULL\n\t\t * changed:   tis[i]->next = new\n\t\t */\n\n\t\tif (!is_url(ti->filename)) {\n\t\t\trc = stat(ti->filename, &st);\n\t\t\tif (!rc && !force && ti->mtime == st.st_mtime) {\n\t\t\t\t// unchanged\n\t\t\t\ttrack_info_unref(ti);\n\t\t\t\ttis[i] = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\thash = hash_str(ti->filename);\n\t\tdo_cache_remove_ti(ti, hash);\n\n\t\tif (!rc) {\n\t\t\t// changed\n\t\t\tstruct track_info *new_ti;\n\n\t\t\t// clear cache-only entries\n\t\t\tif (force && track_info_unique_ref(ti)) {\n\t\t\t\ttrack_info_unref(ti);\n\t\t\t\ttis[i] = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnew_ti = ip_get_ti(ti->filename);\n\t\t\tif (new_ti) {\n\t\t\t\tadd_ti(new_ti, hash);\n\n\t\t\t\tif (track_info_unique_ref(ti)) {\n\t\t\t\t\ttrack_info_unref(ti);\n\t\t\t\t\ttis[i] = NULL;\n\t\t\t\t} else {\n\t\t\t\t\ttrack_info_ref(new_ti);\n\t\t\t\t\tti->next = new_ti;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// treat as deleted\n\t\t}\n\n\t\t// deleted\n\t\tif (track_info_unique_ref(ti)) {\n\t\t\ttrack_info_unref(ti);\n\t\t\ttis[i] = NULL;\n\t\t} else {\n\t\t\tti->next = NULL;\n\t\t}\n\t}\n\t*count = n;\n\treturn tis;\n}\n"
        },
        {
          "name": "cache.h",
          "type": "blob",
          "size": 1.2861328125,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_CACHE_H\n#define CMUS_CACHE_H\n\n#include \"track_info.h\"\n#include \"locking.h\"\n\nextern struct fifo_mutex cache_mutex;\n\n#define cache_lock() fifo_mutex_lock(&cache_mutex)\n#define cache_yield() fifo_mutex_yield(&cache_mutex)\n#define cache_unlock() fifo_mutex_unlock(&cache_mutex)\n\nint cache_init(void);\nint cache_close(void);\nstruct track_info *cache_get_ti(const char *filename, int force);\nvoid cache_remove_ti(struct track_info *ti);\nstruct track_info **cache_refresh(int *count, int force);\nstruct track_info *lookup_cache_entry(const char *filename, unsigned int hash);\n\n#endif\n"
        },
        {
          "name": "channelmap.c",
          "type": "blob",
          "size": 1.9677734375,
          "content": "/*\n * Copyright 2011-2013 Various Authors\n * Copyright 2011 Johannes Weißl\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"channelmap.h\"\n#include \"utils.h\"\n\nvoid channel_map_init_waveex(int channels, unsigned int mask, channel_position_t *map)\n{\n\t/* http://www.microsoft.com/whdc/device/audio/multichaud.mspx#EMLAC */\n\tconst channel_position_t channel_map_waveex[] = {\n\t\tCHANNEL_POSITION_FRONT_LEFT,\n\t\tCHANNEL_POSITION_FRONT_RIGHT,\n\t\tCHANNEL_POSITION_FRONT_CENTER,\n\t\tCHANNEL_POSITION_LFE,\n\t\tCHANNEL_POSITION_REAR_LEFT,\n\t\tCHANNEL_POSITION_REAR_RIGHT,\n\t\tCHANNEL_POSITION_FRONT_LEFT_OF_CENTER,\n\t\tCHANNEL_POSITION_FRONT_RIGHT_OF_CENTER,\n\t\tCHANNEL_POSITION_REAR_CENTER,\n\t\tCHANNEL_POSITION_SIDE_LEFT,\n\t\tCHANNEL_POSITION_SIDE_RIGHT,\n\t\tCHANNEL_POSITION_TOP_CENTER,\n\t\tCHANNEL_POSITION_TOP_FRONT_LEFT,\n\t\tCHANNEL_POSITION_TOP_FRONT_CENTER,\n\t\tCHANNEL_POSITION_TOP_FRONT_RIGHT,\n\t\tCHANNEL_POSITION_TOP_REAR_LEFT,\n\t\tCHANNEL_POSITION_TOP_REAR_CENTER,\n\t\tCHANNEL_POSITION_TOP_REAR_RIGHT\n\t};\n\n\tif (channels == 1) {\n\t\tmap[0] = CHANNEL_POSITION_MONO;\n\t} else if (channels > 1 && channels < N_ELEMENTS(channel_map_waveex)) {\n\t\tint i, j = 0;\n\n\t\tif (!mask)\n\t\t\tmask = (1 << channels) - 1;\n\n\t\tfor (i = 0; i < N_ELEMENTS(channel_map_waveex); i++) {\n\t\t\tif (mask & (1 << i))\n\t\t\t\tmap[j++] = channel_map_waveex[i];\n\t\t}\n\t\tif (j != channels)\n\t\t\tmap[0] = CHANNEL_POSITION_INVALID;\n\t} else {\n\t\tmap[0] = CHANNEL_POSITION_INVALID;\n\t}\n}\n"
        },
        {
          "name": "channelmap.h",
          "type": "blob",
          "size": 2.5947265625,
          "content": "/*\n * Copyright 2011-2013 Various Authors\n * Copyright 2011 Johannes Weißl\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_CHANNELMAP_H\n#define CMUS_CHANNELMAP_H\n\n#include <string.h>\n\n#define CHANNELS_MAX 32\n\n/* Modelled after PulseAudio */\nenum channel_position {\n\tCHANNEL_POSITION_INVALID = -1,\n\tCHANNEL_POSITION_MONO = 0,\n\tCHANNEL_POSITION_FRONT_LEFT,\n\tCHANNEL_POSITION_FRONT_RIGHT,\n\tCHANNEL_POSITION_FRONT_CENTER,\n\n\tCHANNEL_POSITION_LEFT = CHANNEL_POSITION_FRONT_LEFT,\n\tCHANNEL_POSITION_RIGHT = CHANNEL_POSITION_FRONT_RIGHT,\n\tCHANNEL_POSITION_CENTER = CHANNEL_POSITION_FRONT_CENTER,\n\n\tCHANNEL_POSITION_REAR_CENTER,\n\tCHANNEL_POSITION_REAR_LEFT,\n\tCHANNEL_POSITION_REAR_RIGHT,\n\n\tCHANNEL_POSITION_LFE,\n\tCHANNEL_POSITION_SUBWOOFER = CHANNEL_POSITION_LFE,\n\n\tCHANNEL_POSITION_FRONT_LEFT_OF_CENTER,\n\tCHANNEL_POSITION_FRONT_RIGHT_OF_CENTER,\n\n\tCHANNEL_POSITION_SIDE_LEFT,\n\tCHANNEL_POSITION_SIDE_RIGHT,\n\n\tCHANNEL_POSITION_TOP_CENTER,\n\n\tCHANNEL_POSITION_TOP_FRONT_LEFT,\n\tCHANNEL_POSITION_TOP_FRONT_RIGHT,\n\tCHANNEL_POSITION_TOP_FRONT_CENTER,\n\n\tCHANNEL_POSITION_TOP_REAR_LEFT,\n\tCHANNEL_POSITION_TOP_REAR_RIGHT,\n\tCHANNEL_POSITION_TOP_REAR_CENTER,\n\n\tCHANNEL_POSITION_MAX\n};\n\ntypedef enum channel_position\tchannel_position_t;\n\n#define CHANNEL_MAP_INIT\t{ CHANNEL_POSITION_INVALID }\n\n#define CHANNEL_MAP(name) \\\n\tchannel_position_t name[CHANNELS_MAX] = CHANNEL_MAP_INIT\n\nstatic inline int channel_map_valid(const channel_position_t *map)\n{\n\treturn map[0] != CHANNEL_POSITION_INVALID;\n}\n\nstatic inline int channel_map_equal(const channel_position_t *a, const channel_position_t *b, int channels)\n{\n\treturn memcmp(a, b, sizeof(*a) * channels) == 0;\n}\n\nstatic inline channel_position_t *channel_map_copy(channel_position_t *dst, const channel_position_t *src)\n{\n\treturn memcpy(dst, src, sizeof(*dst) * CHANNELS_MAX);\n}\n\nstatic inline void channel_map_init_stereo(channel_position_t *map)\n{\n\tmap[0] = CHANNEL_POSITION_LEFT;\n\tmap[1] = CHANNEL_POSITION_RIGHT;\n}\n\nvoid channel_map_init_waveex(int channels, unsigned int mask, channel_position_t *map);\n\n#endif\n"
        },
        {
          "name": "cmdline.c",
          "type": "blob",
          "size": 4.68359375,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2005 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"cmdline.h\"\n#include \"uchar.h\"\n#include \"xmalloc.h\"\n\nstruct cmdline cmdline;\n\nconst char cmdline_word_delimiters[]     = \" \";\nconst char cmdline_filename_delimiters[] = \"/\";\n\nvoid cmdline_init(void)\n{\n\tcmdline.blen = 0;\n\tcmdline.clen = 0;\n\tcmdline.bpos = 0;\n\tcmdline.cpos = 0;\n\tcmdline.size = 128;\n\tcmdline.line = xnew(char, cmdline.size);\n\tcmdline.line[0] = 0;\n}\n\nvoid cmdline_insert_ch(uchar ch)\n{\n\tint size;\n\n\tsize = u_char_size(ch);\n\tif (cmdline.blen + size > cmdline.size) {\n\t\tcmdline.size *= 2;\n\t\tcmdline.line = xrenew(char, cmdline.line, cmdline.size);\n\t}\n\tmemmove(cmdline.line + cmdline.bpos + size,\n\t\tcmdline.line + cmdline.bpos,\n\t\tcmdline.blen - cmdline.bpos + 1);\n\tu_set_char_raw(cmdline.line, &cmdline.bpos, ch);\n\tcmdline.cpos++;\n\tcmdline.blen += size;\n\tcmdline.clen++;\n}\n\nvoid cmdline_backspace(void)\n{\n\tint bpos, size;\n\n\tif (cmdline.bpos == 0)\n\t\treturn;\n\n\tbpos = cmdline.bpos;\n\tu_prev_char_pos(cmdline.line, &bpos);\n\tsize = cmdline.bpos - bpos;\n\n\tmemmove(cmdline.line + bpos,\n\t\tcmdline.line + cmdline.bpos,\n\t\tcmdline.blen - cmdline.bpos + 1);\n\tcmdline.bpos -= size;\n\tcmdline.cpos--;\n\tcmdline.blen -= size;\n\tcmdline.clen--;\n}\n\nvoid cmdline_backspace_to_bol(void)\n{\n\twhile (cmdline.bpos)\n\t\tcmdline_backspace();\n}\n\nvoid cmdline_delete_ch(void)\n{\n\tuchar ch;\n\tint size, bpos;\n\n\tif (cmdline.bpos == cmdline.blen)\n\t\treturn;\n\tbpos = cmdline.bpos;\n\tch = u_get_char(cmdline.line, &bpos);\n\tsize = u_char_size(ch);\n\tcmdline.blen -= size;\n\tcmdline.clen--;\n\tmemmove(cmdline.line + cmdline.bpos,\n\t\tcmdline.line + cmdline.bpos + size,\n\t\tcmdline.blen - cmdline.bpos + 1);\n}\n\nvoid cmdline_set_text(const char *text)\n{\n\tint len = strlen(text);\n\n\tif (len >= cmdline.size) {\n\t\twhile (len >= cmdline.size)\n\t\t\tcmdline.size *= 2;\n\t\tcmdline.line = xrenew(char, cmdline.line, cmdline.size);\n\t}\n\tmemcpy(cmdline.line, text, len + 1);\n\tcmdline.cpos = u_strlen_safe(cmdline.line);\n\tcmdline.bpos = len;\n\tcmdline.clen = cmdline.cpos;\n\tcmdline.blen = len;\n}\n\nvoid cmdline_clear(void)\n{\n\tcmdline.blen = 0;\n\tcmdline.clen = 0;\n\tcmdline.bpos = 0;\n\tcmdline.cpos = 0;\n\tcmdline.line[0] = 0;\n}\n\nvoid cmdline_clear_end(void)\n{\n\tcmdline.line[cmdline.bpos] = 0;\n\n\tcmdline.clen = u_strlen_safe(cmdline.line);\n\tcmdline.blen = strlen(cmdline.line);\n}\n\nvoid cmdline_move_left(void)\n{\n\tif (cmdline.bpos > 0) {\n\t\tcmdline.cpos--;\n\t\tu_prev_char_pos(cmdline.line, &cmdline.bpos);\n\t}\n}\n\nvoid cmdline_move_right(void)\n{\n\tif (cmdline.bpos < cmdline.blen) {\n\t\tu_get_char(cmdline.line, &cmdline.bpos);\n\t\tcmdline.cpos++;\n\t}\n}\n\nvoid cmdline_move_home(void)\n{\n\tcmdline.cpos = 0;\n\tcmdline.bpos = 0;\n}\n\nvoid cmdline_move_end(void)\n{\n\tcmdline.cpos = cmdline.clen;\n\tcmdline.bpos = cmdline.blen;\n}\n\nstatic int next_word(const char *str, int bpos, int *cdiff, const char *delim, int direction)\n{\n\tint skip_delim = 1;\n\twhile ((direction > 0) ? str[bpos] : (bpos > 0)) {\n\t\tuchar ch;\n\t\tint oldp = bpos;\n\n\t\tif (direction > 0) {\n\t\t\tch = u_get_char(str, &bpos);\n\t\t} else {\n\t\t\tu_prev_char_pos(str, &bpos);\n\t\t\toldp = bpos;\n\t\t\tch = u_get_char(str, &oldp);\n\t\t}\n\n\t\tif (u_strchr(delim, ch)) {\n\t\t\tif (!skip_delim) {\n\t\t\t\tbpos -= bpos - oldp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\tskip_delim = 0;\n\n\t\t*cdiff += direction;\n\t}\n\treturn bpos;\n}\n\nvoid cmdline_forward_word(const char *delim)\n{\n\tcmdline.bpos = next_word(cmdline.line, cmdline.bpos, &cmdline.cpos, delim, +1);\n}\n\nvoid cmdline_backward_word(const char *delim)\n{\n\tcmdline.bpos = next_word(cmdline.line, cmdline.bpos, &cmdline.cpos, delim, -1);\n}\n\nvoid cmdline_delete_word(const char *delim)\n{\n\tint bpos, cdiff = 0;\n\n\tbpos = next_word(cmdline.line, cmdline.bpos, &cdiff, delim, +1);\n\n\tmemmove(cmdline.line + cmdline.bpos,\n\t\tcmdline.line + bpos,\n\t\tcmdline.blen - bpos + 1);\n\tcmdline.blen -= bpos - cmdline.bpos;\n\tcmdline.clen -= cdiff;\n}\n\nvoid cmdline_backward_delete_word(const char *delim)\n{\n\tint bpos, cdiff = 0;\n\n\tbpos = next_word(cmdline.line, cmdline.bpos, &cdiff, delim, -1);\n\n\tcmdline.blen += bpos - cmdline.bpos;\n\tmemmove(cmdline.line + bpos,\n\t\tcmdline.line + cmdline.bpos,\n\t\tcmdline.blen - bpos + 1);\n\tcmdline.bpos = bpos;\n\tcmdline.clen += cdiff;\n\tcmdline.cpos += cdiff;\n}\n"
        },
        {
          "name": "cmdline.h",
          "type": "blob",
          "size": 1.6572265625,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2005 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMDLINE_H\n#define CMDLINE_H\n\n#include \"uchar.h\"\n\nstruct cmdline {\n\t/* length in bytes */\n\tint blen;\n\n\t/* length in characters */\n\tint clen;\n\n\t/* pos in bytes */\n\tint bpos;\n\n\t/* pos in characters */\n\tint cpos;\n\n\t/* allocated size */\n\tint size;\n\n\tchar *line;\n};\n\nextern struct cmdline cmdline;\n\nextern const char cmdline_word_delimiters[];\nextern const char cmdline_filename_delimiters[];\n\nvoid cmdline_init(void);\nvoid cmdline_insert_ch(uchar ch);\nvoid cmdline_backspace(void);\nvoid cmdline_backspace_to_bol(void);\nvoid cmdline_delete_ch(void);\nvoid cmdline_set_text(const char *text);\nvoid cmdline_clear(void);\nvoid cmdline_clear_end(void);\nvoid cmdline_move_left(void);\nvoid cmdline_move_right(void);\nvoid cmdline_move_home(void);\nvoid cmdline_move_end(void);\n\nvoid cmdline_forward_word(const char *delim);\nvoid cmdline_backward_word(const char *delim);\nvoid cmdline_delete_word(const char *delim);\nvoid cmdline_backward_delete_word(const char *delim);\n\n#endif\n"
        },
        {
          "name": "cmus-status-display",
          "type": "blob",
          "size": 1.0947265625,
          "content": "#!/bin/sh\n#\n# cmus-status-display\n#\n# Usage:\n#   in cmus command \":set status_display_program=cmus-status-display\"\n#\n# This scripts is executed by cmus when status changes:\n#   cmus-status-display key1 val1 key2 val2 ...\n#\n# All keys contain only chars a-z. Values are UTF-8 strings.\n#\n# Keys: status file url artist album discnumber tracknumber title date\n#   - status (stopped, playing, paused) is always given\n#   - file or url is given only if track is 'loaded' in cmus\n#   - other keys/values are given only if they are available\n#\n\noutput()\n{\n\t# write status to ~/cmus-status.txt (not very useful though)\n\techo \"$*\" >> ~/cmus-status.txt 2>&1\n\n\t# WMI (http://wmi.modprobe.de/)\n\t#wmiremote -t \"$*\" &> /dev/null\n}\n\nwhile test $# -ge 2\ndo\n\teval _$1='$2'\n\tshift\n\tshift\ndone\n\nif test -n \"$_file\"\nthen\n\th=$(($_duration / 3600))\n\tm=$(($_duration % 3600))\n\n\tduration=\"\"\n\ttest $h -gt 0 && dur=\"$h:\"\n\tduration=\"$dur$(printf '%02d:%02d' $(($m / 60)) $(($m % 60)))\"\n\n\toutput \"[$_status] $_artist - $_album - $_title ($_date) $duration\"\nelif test -n \"$_url\"\nthen\n\toutput \"[$_status] $_url - $_title\"\nelse\n\toutput \"[$_status]\"\nfi\n"
        },
        {
          "name": "cmus.c",
          "type": "blob",
          "size": 11.158203125,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"cmus.h\"\n#include \"job.h\"\n#include \"lib.h\"\n#include \"pl.h\"\n#include \"player.h\"\n#include \"input.h\"\n#include \"play_queue.h\"\n#include \"cache.h\"\n#include \"misc.h\"\n#include \"file.h\"\n#include \"utils.h\"\n#include \"path.h\"\n#include \"options.h\"\n#include \"command_mode.h\"\n#include \"xmalloc.h\"\n#include \"debug.h\"\n#include \"load_dir.h\"\n#include \"ui_curses.h\"\n#include \"cache.h\"\n#include \"gbuf.h\"\n#include \"discid.h\"\n#include \"locking.h\"\n#include \"pl_env.h\"\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <dlfcn.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <strings.h>\n\n/* save_playlist_cb, save_ext_playlist_cb */\ntypedef int (*save_tracks_cb)(void *data, struct track_info *ti);\n\nstatic char **playable_exts;\nstatic const char * const playlist_exts[] = { \"m3u\", \"pl\", \"pls\", NULL };\n\nint cmus_next_track_request_fd;\nstatic bool play_queue_active = false;\nstatic int cmus_next_track_request_fd_priv;\nstatic pthread_mutex_t cmus_next_file_mutex = CMUS_MUTEX_INITIALIZER;\nstatic pthread_cond_t cmus_next_file_cond = CMUS_COND_INITIALIZER;\nstatic int cmus_next_file_provided;\nstatic struct track_info *cmus_next_file;\n\nstatic int x11_init_done = 0;\nstatic void *(*x11_open)(void *) = NULL;\nstatic int (*x11_raise)(void *, int) = NULL;\nstatic int (*x11_close)(void *) = NULL;\n\nint cmus_init(void)\n{\n\tplayable_exts = ip_get_supported_extensions();\n\tcache_init();\n\tjob_init();\n\tplay_queue_init();\n\treturn 0;\n}\n\nvoid cmus_exit(void)\n{\n\tjob_exit();\n\tif (cache_close())\n\t\td_print(\"error: %s\\n\", strerror(errno));\n}\n\nvoid cmus_next(void)\n{\n\tstruct track_info *info = cmus_get_next_track();\n\tif (info)\n\t\tplayer_set_file(info);\n}\n\nvoid cmus_prev(void)\n{\n\tstruct track_info *info;\n\n\tif (play_library) {\n\t\tinfo = lib_goto_prev();\n\t} else {\n\t\tinfo = pl_goto_prev();\n\t}\n\n\tif (info)\n\t\tplayer_set_file(info);\n}\n\nvoid cmus_next_album(void)\n{\n\tstruct track_info *info;\n\n\tif (play_library) {\n\t\tinfo = lib_goto_next_album();\n\t} else {\n\t\tinfo = pl_goto_next();\n\t}\n\n\tif (info)\n\t\tplayer_set_file(info);\n}\n\nvoid cmus_prev_album(void)\n{\n\tstruct track_info *info;\n\n\tif (play_library) {\n\t\tinfo = lib_goto_prev_album();\n\t} else {\n\t\tinfo = pl_goto_prev();\n\t}\n\n\tif (info)\n\t\tplayer_set_file(info);\n}\n\nvoid cmus_play_file(const char *filename)\n{\n\tstruct track_info *ti;\n\n\tcache_lock();\n\tti = cache_get_ti(filename, 0);\n\tcache_unlock();\n\tif (!ti) {\n\t\terror_msg(\"Couldn't get file information for %s\\n\", filename);\n\t\treturn;\n\t}\n\n\tplayer_play_file(ti);\n}\n\nenum file_type cmus_detect_ft(const char *name, char **ret)\n{\n\tchar *absolute;\n\tstruct stat st;\n\n\tif (is_http_url(name) || is_cue_url(name)) {\n\t\t*ret = xstrdup(name);\n\t\treturn FILE_TYPE_URL;\n\t}\n\n\tif (is_cdda_url(name)) {\n\t\t*ret = complete_cdda_url(cdda_device, name);\n\t\treturn FILE_TYPE_CDDA;\n\t}\n\n\t*ret = NULL;\n\tabsolute = path_absolute(name);\n\tif (absolute == NULL)\n\t\treturn FILE_TYPE_INVALID;\n\n\t/* stat follows symlinks, lstat does not */\n\tif (stat(absolute, &st) == -1) {\n\t\tfree(absolute);\n\t\treturn FILE_TYPE_INVALID;\n\t}\n\n\tif (S_ISDIR(st.st_mode)) {\n\t\t*ret = absolute;\n\t\treturn FILE_TYPE_DIR;\n\t}\n\tif (!S_ISREG(st.st_mode)) {\n\t\tfree(absolute);\n\t\terrno = EINVAL;\n\t\treturn FILE_TYPE_INVALID;\n\t}\n\n\t*ret = absolute;\n\tif (cmus_is_playlist(absolute))\n\t\treturn FILE_TYPE_PL;\n\n\t/* NOTE: it could be FILE_TYPE_PL too! */\n\treturn FILE_TYPE_FILE;\n}\n\nvoid cmus_add(add_ti_cb add, const char *name, enum file_type ft, int jt, int force,\n\t\tvoid *opaque)\n{\n\tstruct add_data *data = xnew(struct add_data, 1);\n\n\tdata->add = add;\n\tdata->name = xstrdup(name);\n\tdata->type = ft;\n\tdata->force = force;\n\tdata->opaque = opaque;\n\n\tjob_schedule_add(jt, data);\n}\n\nstatic int save_ext_playlist_cb(void *data, struct track_info *ti)\n{\n\tGBUF(buf);\n\tint fd = *(int *)data;\n\tint i, rc;\n\n\tgbuf_addf(&buf, \"file %s\\n\", escape(ti->filename));\n\tgbuf_addf(&buf, \"duration %d\\n\", ti->duration);\n\tgbuf_addf(&buf, \"codec %s\\n\", ti->codec);\n\tgbuf_addf(&buf, \"bitrate %ld\\n\", ti->bitrate);\n\tfor (i = 0; ti->comments[i].key; i++)\n\t\tgbuf_addf(&buf, \"tag %s %s\\n\",\n\t\t\t\tti->comments[i].key,\n\t\t\t\tescape(ti->comments[i].val));\n\n\trc = write_all(fd, buf.buffer, buf.len);\n\tgbuf_free(&buf);\n\n\tif (rc == -1)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic int save_playlist_cb(void *data, struct track_info *ti)\n{\n\tchar *proc_filename = pl_env_reduce(ti->filename);\n\tint fd = *(int *)data;\n\tconst char nl = '\\n';\n\tint rc;\n\n\trc = write_all(fd, proc_filename, strlen(proc_filename));\n\tfree(proc_filename);\n\tif (rc == -1)\n\t\treturn -1;\n\n\trc = write_all(fd, &nl, 1);\n\tif (rc == -1)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int do_cmus_save(for_each_ti_cb for_each_ti, const char *filename,\n\t\tsave_tracks_cb save_tracks, void *opaque)\n{\n\tint fd, rc;\n\n\tif (strcmp(filename, \"-\") == 0) {\n\t\tif (get_client_fd() == -1) {\n\t\t\terror_msg(\"saving to stdout works only remotely\");\n\t\t\treturn 0;\n\t\t}\n\t\tfd = dup(get_client_fd());\n\t} else\n\t\tfd = open(filename, O_CREAT | O_WRONLY | O_TRUNC, 0666);\n\tif (fd == -1)\n\t\treturn -1;\n\trc = for_each_ti(save_tracks, &fd, opaque);\n\tclose(fd);\n\treturn rc;\n}\n\nint cmus_save(for_each_ti_cb for_each_ti, const char *filename, void *opaque)\n{\n\treturn do_cmus_save(for_each_ti, filename, save_playlist_cb, opaque);\n}\n\nint cmus_save_ext(for_each_ti_cb for_each_ti, const char *filename,\n\t\tvoid *opaque)\n{\n\treturn do_cmus_save(for_each_ti, filename, save_ext_playlist_cb,\n\t\t\topaque);\n}\n\nstatic int update_cb(void *data, struct track_info *ti)\n{\n\tstruct update_data *d = data;\n\n\tif (d->size == d->used) {\n\t\tif (d->size == 0)\n\t\t\td->size = 16;\n\t\td->size *= 2;\n\t\td->ti = xrenew(struct track_info *, d->ti, d->size);\n\t}\n\ttrack_info_ref(ti);\n\td->ti[d->used++] = ti;\n\treturn 0;\n}\n\nvoid cmus_update_cache(int force)\n{\n\tstruct update_cache_data *data;\n\n\tdata = xnew(struct update_cache_data, 1);\n\tdata->force = force;\n\n\tjob_schedule_update_cache(JOB_TYPE_LIB, data);\n}\n\nvoid cmus_update_lib(void)\n{\n\tstruct update_data *data;\n\n\tdata = xnew0(struct update_data, 1);\n\n\tlib_for_each(update_cb, data, NULL);\n\n\tjob_schedule_update(data);\n}\n\nvoid cmus_update_tis(struct track_info **tis, int nr, int force)\n{\n\tstruct update_data *data;\n\n\tdata = xnew(struct update_data, 1);\n\tdata->size = nr;\n\tdata->used = nr;\n\tdata->ti = tis;\n\tdata->force = force;\n\n\tjob_schedule_update(data);\n}\n\nstatic const char *get_ext(const char *filename)\n{\n\tconst char *ext = strrchr(filename, '.');\n\n\tif (ext)\n\t\text++;\n\treturn ext;\n}\n\nstatic int str_in_array(const char *str, const char * const *array)\n{\n\tint i;\n\n\tfor (i = 0; array[i]; i++) {\n\t\tif (strcasecmp(str, array[i]) == 0)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint cmus_is_playlist(const char *filename)\n{\n\tconst char *ext = get_ext(filename);\n\n\treturn ext && str_in_array(ext, playlist_exts);\n}\n\nint cmus_is_playable(const char *filename)\n{\n\tconst char *ext = get_ext(filename);\n\n\treturn ext && str_in_array(ext, (const char * const *)playable_exts);\n}\n\nint cmus_is_supported(const char *filename)\n{\n\tconst char *ext = get_ext(filename);\n\n\treturn ext && (str_in_array(ext, (const char * const *)playable_exts) ||\n\t\t\tstr_in_array(ext, playlist_exts));\n}\n\nstruct pl_data {\n\tint (*cb)(void *data, const char *line);\n\tvoid *data;\n};\n\nstatic int pl_handle_line(void *data, const char *line)\n{\n\tstruct pl_data *d = data;\n\tint i = 0;\n\n\twhile (isspace((unsigned char)line[i]))\n\t\ti++;\n\tif (line[i] == 0)\n\t\treturn 0;\n\n\tif (line[i] == '#')\n\t\treturn 0;\n\n\treturn d->cb(d->data, line);\n}\n\nstatic int pls_handle_line(void *data, const char *line)\n{\n\tstruct pl_data *d = data;\n\n\tif (strncasecmp(line, \"file\", 4))\n\t\treturn 0;\n\tline = strchr(line, '=');\n\tif (line == NULL)\n\t\treturn 0;\n\treturn d->cb(d->data, line + 1);\n}\n\nint cmus_playlist_for_each(const char *buf, int size, int reverse,\n\t\tint (*cb)(void *data, const char *line),\n\t\tvoid *data)\n{\n\tstruct pl_data d = { cb, data };\n\tint (*handler)(void *, const char *);\n\n\thandler = pl_handle_line;\n\tif (size >= 10 && strncasecmp(buf, \"[playlist]\", 10) == 0)\n\t\thandler = pls_handle_line;\n\n\tif (reverse) {\n\t\tbuffer_for_each_line_reverse(buf, size, handler, &d);\n\t} else {\n\t\tbuffer_for_each_line(buf, size, handler, &d);\n\t}\n\treturn 0;\n}\n\n/* multi-threaded next track requests */\n\n#define cmus_next_file_lock() cmus_mutex_lock(&cmus_next_file_mutex)\n#define cmus_next_file_unlock() cmus_mutex_unlock(&cmus_next_file_mutex)\n\nstatic struct track_info *cmus_get_next_from_main_thread(void)\n{\n\tstruct track_info *ti = play_queue_remove();\n\tif (ti) {\n\t\tplay_queue_active = true;\n\t} else {\n\t\tif (!play_queue_active || !stop_after_queue)\n\t\t\tti = play_library ? lib_goto_next() : pl_goto_next();\n\t\tplay_queue_active = false;\n\t}\n\treturn ti;\n}\n\nstatic struct track_info *cmus_get_next_from_other_thread(void)\n{\n\tstatic pthread_mutex_t mutex = CMUS_MUTEX_INITIALIZER;\n\tcmus_mutex_lock(&mutex);\n\n\t/* only one thread may request a track at a time */\n\n\tnotify_via_pipe(cmus_next_track_request_fd_priv);\n\n\tcmus_next_file_lock();\n\twhile (!cmus_next_file_provided)\n\t\tpthread_cond_wait(&cmus_next_file_cond, &cmus_next_file_mutex);\n\tstruct track_info *ti = cmus_next_file;\n\tcmus_next_file_provided = 0;\n\tcmus_next_file_unlock();\n\n\tcmus_mutex_unlock(&mutex);\n\n\treturn ti;\n}\n\nstruct track_info *cmus_get_next_track(void)\n{\n\tpthread_t this_thread = pthread_self();\n\tif (pthread_equal(this_thread, main_thread))\n\t\treturn cmus_get_next_from_main_thread();\n\treturn cmus_get_next_from_other_thread();\n}\n\nvoid cmus_provide_next_track(void)\n{\n\tclear_pipe(cmus_next_track_request_fd, 1);\n\n\tcmus_next_file_lock();\n\tcmus_next_file = cmus_get_next_from_main_thread();\n\tcmus_next_file_provided = 1;\n\tcmus_next_file_unlock();\n\n\tpthread_cond_broadcast(&cmus_next_file_cond);\n}\n\nvoid cmus_track_request_init(void)\n{\n\tinit_pipes(&cmus_next_track_request_fd, &cmus_next_track_request_fd_priv);\n}\n\nstatic int cmus_can_raise_vte_x11(void)\n{\n\treturn getenv(\"DISPLAY\") && getenv(\"WINDOWID\");\n}\n\nint cmus_can_raise_vte(void)\n{\n\treturn cmus_can_raise_vte_x11();\n}\n\nstatic int cmus_raise_vte_x11_error(void)\n{\n\treturn 0;\n}\n\nvoid cmus_raise_vte(void)\n{\n\tif (cmus_can_raise_vte_x11()) {\n\t\tif (!x11_init_done) {\n\t\t\tvoid *x11;\n\n\t\t\tx11_init_done = 1;\n\t\t\tx11 = dlopen(\"libX11.so\", RTLD_LAZY);\n\n\t\t\tif (x11) {\n\t\t\t\tint (*x11_error)(void *);\n\n\t\t\t\tx11_error = dlsym(x11, \"XSetErrorHandler\");\n\t\t\t\tx11_open = dlsym(x11, \"XOpenDisplay\");\n\t\t\t\tx11_raise = dlsym(x11, \"XRaiseWindow\");\n\t\t\t\tx11_close = dlsym(x11, \"XCloseDisplay\");\n\n\t\t\t\tif (x11_error) {\n\t\t\t\t\tx11_error(cmus_raise_vte_x11_error);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (x11_open && x11_raise && x11_close) {\n\t\t\tchar *xid_str;\n\t\t\tlong int xid = 0;\n\n\t\t\txid_str = getenv(\"WINDOWID\");\n\t\t\tif (!str_to_int(xid_str, &xid) && xid != 0) {\n\t\t\t\tvoid *display;\n\n\t\t\t\tdisplay = x11_open(NULL);\n\t\t\t\tif (display) {\n\t\t\t\t\tx11_raise(display, (int) xid);\n\t\t\t\t\tx11_close(display);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool cmus_queue_active(void) {\n\treturn play_queue_active;\n}\n"
        },
        {
          "name": "cmus.h",
          "type": "blob",
          "size": 3,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_API_H\n#define CMUS_API_H\n\n#include \"track_info.h\"\n\nenum file_type {\n\t/* not found, device file... */\n\tFILE_TYPE_INVALID,\n\n\tFILE_TYPE_URL,\n\tFILE_TYPE_PL,\n\tFILE_TYPE_DIR,\n\tFILE_TYPE_FILE,\n\tFILE_TYPE_CDDA\n};\n\ntypedef int (*track_info_cb)(void *data, struct track_info *ti);\n\n/* lib_for_each, lib_for_each_filtered, pl_for_each, play_queue_for_each */\ntypedef int (*for_each_ti_cb)(track_info_cb cb, void *data, void *opaque);\n\n/* lib_for_each_sel, pl_for_each_sel, play_queue_for_each_sel */\ntypedef int (*for_each_sel_ti_cb)(track_info_cb cb, void *data, int reverse, int advance);\n\n/* lib_add_track, pl_add_track, play_queue_append, play_queue_prepend */\ntypedef void (*add_ti_cb)(struct track_info *, void *opaque);\n\n/* cmus_save, cmus_save_ext */\ntypedef int (*save_ti_cb)(for_each_ti_cb for_each_ti, const char *filename,\n\t\tvoid *opaque);\n\nint cmus_init(void);\nvoid cmus_exit(void);\nvoid cmus_play_file(const char *filename);\n\n/* detect file type, returns absolute path or url in @ret */\nenum file_type cmus_detect_ft(const char *name, char **ret);\n\n/* add to library, playlist or queue view\n *\n * @add   callback that does the actual adding\n * @name  playlist, directory, file, URL\n * @ft    detected FILE_TYPE_*\n * @jt    JOB_TYPE_{LIB,PL,QUEUE}\n *\n * returns immediately, actual work is done in the worker thread.\n */\nvoid cmus_add(add_ti_cb, const char *name, enum file_type ft, int jt,\n\t\tint force, void *opaque);\n\nint cmus_save(for_each_ti_cb for_each_ti, const char *filename, void *opaque);\nint cmus_save_ext(for_each_ti_cb for_each_ti, const char *filename,\n\t\tvoid *opaque);\n\nvoid cmus_update_cache(int force);\nvoid cmus_update_lib(void);\nvoid cmus_update_tis(struct track_info **tis, int nr, int force);\n\nint cmus_is_playlist(const char *filename);\nint cmus_is_playable(const char *filename);\nint cmus_is_supported(const char *filename);\n\nint cmus_playlist_for_each(const char *buf, int size, int reverse,\n\t\tint (*cb)(void *data, const char *line),\n\t\tvoid *data);\n\nvoid cmus_next(void);\nvoid cmus_prev(void);\nvoid cmus_next_album(void);\nvoid cmus_prev_album(void);\n\nextern int cmus_next_track_request_fd;\nstruct track_info *cmus_get_next_track(void);\nvoid cmus_provide_next_track(void);\nvoid cmus_track_request_init(void);\n\nint cmus_can_raise_vte(void);\nvoid cmus_raise_vte(void);\n\nbool cmus_queue_active(void);\n\n#endif\n"
        },
        {
          "name": "command_mode.c",
          "type": "blob",
          "size": 66.072265625,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004-2005 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"command_mode.h\"\n#include \"search_mode.h\"\n#include \"cmdline.h\"\n#include \"options.h\"\n#include \"ui_curses.h\"\n#include \"history.h\"\n#include \"tabexp.h\"\n#include \"tabexp_file.h\"\n#include \"browser.h\"\n#include \"filters.h\"\n#include \"player.h\"\n#include \"output.h\"\n#include \"editable.h\"\n#include \"lib.h\"\n#include \"pl.h\"\n#include \"play_queue.h\"\n#include \"cmus.h\"\n#include \"worker.h\"\n#include \"keys.h\"\n#include \"xmalloc.h\"\n#include \"xstrjoin.h\"\n#include \"misc.h\"\n#include \"path.h\"\n#include \"spawn.h\"\n#include \"utils.h\"\n#include \"list.h\"\n#include \"debug.h\"\n#include \"load_dir.h\"\n#include \"help.h\"\n#include \"op.h\"\n#include \"mpris.h\"\n#include \"job.h\"\n\n#include <stdlib.h>\n#include <ctype.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <dirent.h>\n\nstatic struct history cmd_history;\nstatic char *cmd_history_filename;\nstatic char *history_search_text = NULL;\nstatic int arg_expand_cmd = -1;\nstatic int mute_vol_l = 0, mute_vol_r = 0;\n\n/* view {{{ */\n\nvoid view_clear(int view)\n{\n\tswitch (view) {\n\tcase TREE_VIEW:\n\tcase SORTED_VIEW:\n\t\tworker_remove_jobs_by_type(JOB_TYPE_LIB);\n\t\teditable_clear(&lib_editable);\n\n\t\t/* FIXME: make this optional? */\n\t\tlib_clear_store();\n\t\tbreak;\n\tcase PLAYLIST_VIEW:\n\t\tpl_clear();\n\t\tbreak;\n\tcase QUEUE_VIEW:\n\t\tworker_remove_jobs_by_type(JOB_TYPE_QUEUE);\n\t\teditable_clear(&pq_editable);\n\t\tbreak;\n\tdefault:\n\t\tinfo_msg(\":clear only works in views 1-4\");\n\t}\n}\n\nvoid view_add(int view, char *arg, int prepend)\n{\n\tchar *tmp, *name;\n\tenum file_type ft;\n\n\ttmp = expand_filename(arg);\n\tft = cmus_detect_ft(tmp, &name);\n\tif (ft == FILE_TYPE_INVALID) {\n\t\terror_msg(\"adding '%s': %s\", tmp, strerror(errno));\n\t\tfree(tmp);\n\t\treturn;\n\t}\n\tfree(tmp);\n\n\tswitch (view) {\n\tcase TREE_VIEW:\n\tcase SORTED_VIEW:\n\t\tcmus_add(lib_add_track, name, ft, JOB_TYPE_LIB, 0, NULL);\n\t\tbreak;\n\tcase PLAYLIST_VIEW:\n\t\tpl_add_file_to_marked_pl(name);\n\t\tbreak;\n\tcase QUEUE_VIEW:\n\t\tif (prepend) {\n\t\t\tcmus_add(play_queue_prepend, name, ft, JOB_TYPE_QUEUE,\n\t\t\t\t\t0, NULL);\n\t\t} else {\n\t\t\tcmus_add(play_queue_append, name, ft, JOB_TYPE_QUEUE, 0,\n\t\t\t\t\tNULL);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tinfo_msg(\":add only works in views 1-4\");\n\t}\n\tfree(name);\n}\n\nstatic char *view_load_prepare(char *arg)\n{\n\tchar *name, *tmp = expand_filename(arg);\n\tenum file_type ft = cmus_detect_ft(tmp, &name);\n\tif (ft == FILE_TYPE_INVALID) {\n\t\terror_msg(\"loading '%s': %s\", tmp, strerror(errno));\n\t\tfree(tmp);\n\t\treturn NULL;\n\t}\n\tfree(tmp);\n\n\tif (ft == FILE_TYPE_FILE)\n\t\tft = FILE_TYPE_PL;\n\tif (ft != FILE_TYPE_PL) {\n\t\terror_msg(\"loading '%s': not a playlist file\", name);\n\t\tfree(name);\n\t\treturn NULL;\n\t}\n\treturn name;\n}\n\nvoid view_load(int view, char *arg)\n{\n\tchar *name = view_load_prepare(arg);\n\tif (!name)\n\t\treturn;\n\n\tswitch (view) {\n\tcase TREE_VIEW:\n\tcase SORTED_VIEW:\n\t\tworker_remove_jobs_by_type(JOB_TYPE_LIB);\n\t\teditable_clear(&lib_editable);\n\t\tcmus_add(lib_add_track, name, FILE_TYPE_PL, JOB_TYPE_LIB, 0,\n\t\t\t\tNULL);\n\t\tfree(lib_filename);\n\t\tlib_filename = name;\n\t\tbreak;\n\tdefault:\n\t\tinfo_msg(\":load only works in views 1-2\");\n\t\tfree(name);\n\t}\n}\n\nstatic void do_save(for_each_ti_cb for_each_ti, const char *arg, char **filenamep,\n\t\tsave_ti_cb save_ti)\n{\n\tchar *filename = *filenamep;\n\n\tif (arg) {\n\t\tif (strcmp(arg, \"-\") == 0) {\n\t\t\tfilename = (char *) arg;\n\t\t} else {\n\t\t\tfree(filename);\n\t\t\tfilename = xstrdup(arg);\n\t\t\t*filenamep = filename;\n\t\t}\n\t} else if (!filename) {\n\t\terror_msg(\"need a file as argument, no default stored yet\");\n\t\treturn;\n\t}\n\n\tif (save_ti(for_each_ti, filename, NULL) == -1)\n\t\terror_msg(\"saving '%s': %s\", filename, strerror(errno));\n}\n\nvoid view_save(int view, char *arg, int to_stdout, int filtered, int extended)\n{\n\tchar **dest;\n\tsave_ti_cb     save_ti         = extended ? cmus_save_ext         : cmus_save;\n\tfor_each_ti_cb lib_for_each_ti = filtered ? lib_for_each_filtered : lib_for_each;\n\n\tif (arg) {\n\t\tif (to_stdout) {\n\t\t\targ = xstrdup(arg);\n\t\t} else {\n\t\t\tchar *tmp = expand_filename(arg);\n\t\t\targ = path_absolute(tmp);\n\t\t\tfree(tmp);\n\t\t}\n\t}\n\n\tswitch (view) {\n\tcase TREE_VIEW:\n\tcase SORTED_VIEW:\n\t\tif (worker_has_job_by_type(JOB_TYPE_LIB))\n\t\t\tgoto worker_running;\n\t\tdest = extended ? &lib_ext_filename : &lib_filename;\n\t\tdo_save(lib_for_each_ti, arg, dest, save_ti);\n\t\tbreak;\n\tcase PLAYLIST_VIEW:\n\t\tif (arg)\n\t\t\tpl_export_selected_pl(arg);\n\t\telse\n\t\t\tpl_save();\n\t\tbreak;\n\tcase QUEUE_VIEW:\n\t\tif (worker_has_job_by_type(JOB_TYPE_QUEUE))\n\t\t\tgoto worker_running;\n\t\tdest = extended ? &play_queue_ext_filename : &play_queue_filename;\n\t\tdo_save(play_queue_for_each, arg, dest, save_ti);\n\t\tbreak;\n\tdefault:\n\t\tinfo_msg(\":save only works in views 1 - 4\");\n\t}\n\tfree(arg);\n\treturn;\nworker_running:\n\terror_msg(\"can't save when tracks are being added\");\n\tfree(arg);\n}\n\n/* }}} */\n\n/* if only_last != 0, only return the last flag */\nstatic int do_parse_flags(const char **strp, const char *flags, int only_last)\n{\n\tconst char *str = *strp;\n\tint flag = 0;\n\n\tif (str == NULL)\n\t\treturn flag;\n\n\twhile (*str && (only_last || !flag)) {\n\t\tif (*str != '-')\n\t\t\tbreak;\n\n\t\t// \"-\"\n\t\tif (str[1] == 0)\n\t\t\tbreak;\n\n\t\t// \"--\" or \"-- \"\n\t\tif (str[1] == '-' && (str[2] == 0 || str[2] == ' ')) {\n\t\t\tstr += 2;\n\t\t\tbreak;\n\t\t}\n\n\t\t// not \"-?\" or \"-? \"\n\t\tif (str[2] && str[2] != ' ')\n\t\t\tbreak;\n\n\t\tflag = str[1];\n\t\tif (!strchr(flags, flag)) {\n\t\t\terror_msg(\"invalid option -%c\", flag);\n\t\t\treturn -1;\n\t\t}\n\n\t\tstr += 2;\n\n\t\twhile (*str == ' ')\n\t\t\tstr++;\n\t}\n\twhile (*str == ' ')\n\t\tstr++;\n\tif (*str == 0)\n\t\tstr = NULL;\n\t*strp = str;\n\treturn flag;\n}\n\nstatic int parse_flags(const char **strp, const char *flags)\n{\n\treturn do_parse_flags(strp, flags, 1);\n}\n\nstatic int parse_one_flag(const char **strp, const char *flags)\n{\n\treturn do_parse_flags(strp, flags, 0);\n}\n\n/* is str == \"...-\", but not \"...-- -\" ? copied from do_parse_flags() */\nstatic int is_stdout_filename(const char *str)\n{\n\tif (!str)\n\t\treturn 0;\n\n\twhile (*str) {\n\t\tif (*str != '-')\n\t\t\treturn 0;\n\t\t// \"-\"\n\t\tif (str[1] == 0)\n\t\t\treturn 1;\n\t\t// \"--\" or \"-- \"\n\t\tif (str[1] == '-' && (str[2] == 0 || str[2] == ' '))\n\t\t\treturn 0;\n\t\t// not \"-?\" or \"-? \"\n\t\tif (str[2] && str[2] != ' ')\n\t\t\treturn 0;\n\t\tstr += 2;\n\t\twhile (*str == ' ')\n\t\t\tstr++;\n\t}\n\n\treturn 0;\n}\n\nstatic int flag_to_view(int flag)\n{\n\tswitch (flag) {\n\tcase 'l':\n\tcase 'L':\n\t\treturn TREE_VIEW;\n\tcase 'p':\n\t\treturn PLAYLIST_VIEW;\n\tcase 'q':\n\tcase 'Q':\n\t\treturn QUEUE_VIEW;\n\tdefault:\n\t\treturn cur_view;\n\t}\n}\n\nstruct window *current_win(void)\n{\n\tswitch (cur_view) {\n\tcase TREE_VIEW:\n\t\treturn lib_cur_win;\n\tcase SORTED_VIEW:\n\t\treturn lib_editable.shared->win;\n\tcase PLAYLIST_VIEW:\n\t\treturn pl_cursor_win();\n\tcase QUEUE_VIEW:\n\t\treturn pq_editable.shared->win;\n\tcase BROWSER_VIEW:\n\t\treturn browser_win;\n\tcase HELP_VIEW:\n\t\treturn help_win;\n\tcase FILTERS_VIEW:\n\tdefault:\n\t\treturn filters_win;\n\t}\n}\n\nstatic void cmd_add(char *arg)\n{\n\tint flag = parse_flags((const char **)&arg, \"lpqQ\");\n\n\tif (flag == -1)\n\t\treturn;\n\tif (arg == NULL) {\n\t\terror_msg(\"not enough arguments\\n\");\n\t\treturn;\n\t}\n\tview_add(flag_to_view(flag), arg, flag == 'Q');\n}\n\nstatic void cmd_clear(char *arg)\n{\n\tint flag = parse_flags((const char **)&arg, \"lpq\");\n\n\tif (flag == -1)\n\t\treturn;\n\tif (arg) {\n\t\terror_msg(\"too many arguments\\n\");\n\t\treturn;\n\t}\n\tview_clear(flag_to_view(flag));\n}\n\nstatic void cmd_load(char *arg)\n{\n\tint flag = parse_flags((const char **)&arg, \"l\");\n\n\tif (flag == -1)\n\t\treturn;\n\tif (arg == NULL) {\n\t\terror_msg(\"not enough arguments\\n\");\n\t\treturn;\n\t}\n\tview_load(flag_to_view(flag), arg);\n}\n\nstatic void cmd_save(char *arg)\n{\n\tint to_stdout = is_stdout_filename(arg);\n\tint flag = 0, f, extended = 0;\n\n\tdo {\n\t\tf = parse_one_flag((const char **)&arg, \"eLlpq\");\n\t\tif (f == 'e')\n\t\t\textended = 1;\n\t\telse if (f)\n\t\t\tflag = f;\n\t} while (f > 0);\n\n\tif (flag == -1)\n\t\treturn;\n\tview_save(flag_to_view(flag), arg, to_stdout, flag == 'L', extended);\n}\n\nstatic void cmd_set(char *arg)\n{\n\tchar *value = NULL;\n\tint i;\n\n\tfor (i = 0; arg[i]; i++) {\n\t\tif (arg[i] == '=') {\n\t\t\targ[i] = 0;\n\t\t\tvalue = &arg[i + 1];\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (value) {\n\t\toption_set(arg, value);\n\t\thelp_win->changed = 1;\n\t\tif (cur_view == TREE_VIEW) {\n\t\t\tlib_track_win->changed = 1;\n\t\t\tlib_tree_win->changed = 1;\n\t\t} else if (cur_view == PLAYLIST_VIEW) {\n\t\t\tpl_mark_for_redraw();\n\t\t} else {\n\t\t\tcurrent_win()->changed = 1;\n\t\t}\n\t\tupdate_titleline();\n\t\tupdate_statusline();\n\t} else {\n\t\tstruct cmus_opt *opt;\n\t\tchar buf[OPTION_MAX_SIZE];\n\n\t\t/* support \"set <option>?\" */\n\t\ti--;\n\t\tif (arg[i] == '?')\n\t\t\targ[i] = 0;\n\n\t\topt = option_find(arg);\n\t\tif (opt) {\n\t\t\topt->get(opt->data, buf, OPTION_MAX_SIZE);\n\t\t\tinfo_msg(\"setting: '%s=%s'\", arg, buf);\n\t\t}\n\t}\n}\n\nstatic void cmd_toggle(char *arg)\n{\n\tstruct cmus_opt *opt = option_find(arg);\n\n\tif (opt == NULL)\n\t\treturn;\n\n\tif (opt->toggle == NULL) {\n\t\terror_msg(\"%s is not toggle option\", opt->name);\n\t\treturn;\n\t}\n\topt->toggle(opt->data);\n\thelp_win->changed = 1;\n\tif (cur_view == TREE_VIEW) {\n\t\tlib_track_win->changed = 1;\n\t\tlib_tree_win->changed = 1;\n\t} else if (cur_view == PLAYLIST_VIEW) {\n\t\tpl_mark_for_redraw();\n\t} else {\n\t\tcurrent_win()->changed = 1;\n\t}\n\tupdate_titleline();\n\tupdate_statusline();\n}\n\nstatic int get_number(char *str, char **end)\n{\n\tint val = 0;\n\n\twhile (*str >= '0' && *str <= '9') {\n\t\tval *= 10;\n\t\tval += *str++ - '0';\n\t}\n\t*end = str;\n\treturn val;\n}\n\nstatic void cmd_seek(char *arg)\n{\n\tint relative = 0;\n\tint seek = 0, sign = 1, count;\n\n\tswitch (*arg) {\n\tcase '-':\n\t\tsign = -1;\n\t\t/* fallthrough */\n\tcase '+':\n\t\trelative = 1;\n\t\targ++;\n\t\tbreak;\n\t}\n\n\tcount = 0;\n\tgoto inside;\n\n\tdo {\n\t\tint num;\n\t\tchar *end;\n\n\t\tif (*arg != ':')\n\t\t\tbreak;\n\t\targ++;\ninside:\n\t\tnum = get_number(arg, &end);\n\t\tif (arg == end)\n\t\t\tbreak;\n\t\targ = end;\n\t\tseek = seek * 60 + num;\n\t} while (++count < 3);\n\n\tseek *= sign;\n\tif (!count)\n\t\tgoto err;\n\n\tif (count == 1) {\n\t\tswitch (tolower((unsigned char)*arg)) {\n\t\tcase 'h':\n\t\t\tseek *= 60;\n\t\t\t/* fallthrough */\n\t\tcase 'm':\n\t\t\tseek *= 60;\n\t\t\t/* fallthrough */\n\t\tcase 's':\n\t\t\targ++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!*arg) {\n\t\tplayer_seek(seek, relative, 0);\n\t\treturn;\n\t}\nerr:\n\terror_msg(\"expecting one argument: [+-]INTEGER[mh] or [+-]H:MM:SS\");\n}\n\nstatic void cmd_factivate(char *arg)\n{\n\tfilters_activate_names(arg);\n}\n\nstatic void cmd_live_filter(char *arg)\n{\n\tfilters_set_live(arg);\n}\n\nstatic void cmd_filter(char *arg)\n{\n\tfilters_set_anonymous(arg);\n}\n\nstatic void cmd_fset(char *arg)\n{\n\tfilters_set_filter(arg);\n}\n\nstatic void cmd_help(char *arg)\n{\n\tinfo_msg(\"To get started with cmus, read cmus-tutorial(7) and cmus(1) man pages\");\n}\n\nstatic void cmd_invert(char *arg)\n{\n\tswitch (cur_view) {\n\tcase SORTED_VIEW:\n\t\teditable_invert_marks(&lib_editable);\n\t\tbreak;\n\tcase PLAYLIST_VIEW:\n\t\tpl_invert_marks();\n\t\tbreak;\n\tcase QUEUE_VIEW:\n\t\teditable_invert_marks(&pq_editable);\n\t\tbreak;\n\tdefault:\n\t\tinfo_msg(\":invert only works in views 2-4\");\n\t}\n}\n\nstatic void cmd_mark(char *arg)\n{\n\tswitch (cur_view) {\n\tcase SORTED_VIEW:\n\t\teditable_mark(&lib_editable, arg);\n\t\tbreak;\n\tcase PLAYLIST_VIEW:\n\t\tpl_mark(arg);\n\t\tbreak;\n\tcase QUEUE_VIEW:\n\t\teditable_mark(&pq_editable, arg);\n\t\tbreak;\n\tdefault:\n\t\tinfo_msg(\":mark only works in views 2-4\");\n\t}\n}\n\nstatic void cmd_unmark(char *arg)\n{\n\tswitch (cur_view) {\n\tcase SORTED_VIEW:\n\t\teditable_unmark(&lib_editable);\n\t\tbreak;\n\tcase PLAYLIST_VIEW:\n\t\tpl_unmark();\n\t\tbreak;\n\tcase QUEUE_VIEW:\n\t\teditable_unmark(&pq_editable);\n\t\tbreak;\n\tdefault:\n\t\tinfo_msg(\":unmark only works in views 2-4\");\n\t}\n}\n\nstatic void cmd_update_cache(char *arg)\n{\n\tint flag = parse_flags((const char **)&arg, \"f\");\n\tcmus_update_cache(flag == 'f');\n}\n\nstatic void cmd_cd(char *arg)\n{\n\tif (arg) {\n\t\tchar *dir, *absolute;\n\n\t\tdir = expand_filename(arg);\n\t\tabsolute = path_absolute(dir);\n\t\tif (chdir(dir) == -1) {\n\t\t\terror_msg(\"could not cd to '%s': %s\", dir, strerror(errno));\n\t\t} else {\n\t\t\tbrowser_chdir(absolute);\n\t\t}\n\t\tfree(absolute);\n\t\tfree(dir);\n\t} else {\n\t\tif (chdir(home_dir) == -1) {\n\t\t\terror_msg(\"could not cd to '%s': %s\", home_dir, strerror(errno));\n\t\t} else {\n\t\t\tbrowser_chdir(home_dir);\n\t\t}\n\t}\n}\n\nstatic void cmd_bind(char *arg)\n{\n\tint flag = parse_flags((const char **)&arg, \"f\");\n\tchar *key, *func;\n\n\tif (flag == -1)\n\t\treturn;\n\n\tif (arg == NULL)\n\t\tgoto err;\n\n\tkey = strchr(arg, ' ');\n\tif (key == NULL)\n\t\tgoto err;\n\t*key++ = 0;\n\twhile (*key == ' ')\n\t\tkey++;\n\n\tfunc = strchr(key, ' ');\n\tif (func == NULL)\n\t\tgoto err;\n\t*func++ = 0;\n\twhile (*func == ' ')\n\t\tfunc++;\n\tif (*func == 0)\n\t\tgoto err;\n\n\tkey_bind(arg, key, func, flag == 'f');\n\tif (cur_view == HELP_VIEW)\n\t\twindow_changed(help_win);\n\treturn;\nerr:\n\terror_msg(\"expecting 3 arguments (context, key and function)\\n\");\n}\n\nstatic void cmd_unbind(char *arg)\n{\n\tint flag = parse_flags((const char **)&arg, \"f\");\n\tchar *key;\n\n\tif (flag == -1)\n\t\treturn;\n\n\tif (arg == NULL)\n\t\tgoto err;\n\n\tkey = strchr(arg, ' ');\n\tif (key == NULL)\n\t\tgoto err;\n\t*key++ = 0;\n\twhile (*key == ' ')\n\t\tkey++;\n\tif (*key == 0)\n\t\tgoto err;\n\n\tstrip_trailing_spaces(key);\n\n\tkey_unbind(arg, key, flag == 'f');\n\treturn;\nerr:\n\terror_msg(\"expecting 2 arguments (context and key)\\n\");\n}\n\nstatic void cmd_showbind(char *arg)\n{\n\tchar *key;\n\n\tkey = strchr(arg, ' ');\n\tif (key == NULL)\n\t\tgoto err;\n\t*key++ = 0;\n\twhile (*key == ' ')\n\t\tkey++;\n\tif (*key == 0)\n\t\tgoto err;\n\n\tstrip_trailing_spaces(key);\n\n\tshow_binding(arg, key);\n\treturn;\nerr:\n\terror_msg(\"expecting 2 arguments (context and key)\\n\");\n}\n\nstatic void cmd_quit(char *arg)\n{\n\tint flag = parse_flags((const char **)&arg, \"i\");\n\tenum ui_query_answer answer;\n\tif (!worker_has_job_by_type(JOB_TYPE_ANY)) {\n\t\tif (flag != 'i' || yes_no_query(\"Quit cmus? [y/N]\") != UI_QUERY_ANSWER_NO)\n\t\t\tcmus_running = 0;\n\t} else {\n\t\tanswer = yes_no_query(\"Tracks are being added. Quit and truncate playlist(s)? [y/N]\");\n\t\tif (answer != UI_QUERY_ANSWER_NO)\n\t\t\tcmus_running = 0;\n\t}\n}\n\nstatic void cmd_reshuffle(char *arg)\n{\n\tlib_reshuffle();\n\tpl_reshuffle();\n}\n\nstatic void cmd_source(char *arg)\n{\n\tchar *filename = expand_filename(arg);\n\n\tif (source_file(filename) == -1)\n\t\terror_msg(\"sourcing %s: %s\", filename, strerror(errno));\n\tfree(filename);\n}\n\nstatic void cmd_colorscheme(char *arg)\n{\n\tchar filename[512];\n\n\tsnprintf(filename, sizeof(filename), \"%s/%s.theme\", cmus_config_dir, arg);\n\tif (source_file(filename) == -1) {\n\t\tsnprintf(filename, sizeof(filename), \"%s/%s.theme\", cmus_data_dir, arg);\n\t\tif (source_file(filename) == -1)\n\t\t\terror_msg(\"sourcing %s: %s\", filename, strerror(errno));\n\t}\n}\n\n/*\n * \\\" inside double-quotes becomes \"\n * \\\\ inside double-quotes becomes \\\n */\nstatic char *parse_quoted(const char **strp)\n{\n\tconst char *str = *strp;\n\tconst char *start;\n\tchar *ret, *dst;\n\n\tstr++;\n\tstart = str;\n\twhile (1) {\n\t\tint c = *str++;\n\n\t\tif (c == 0)\n\t\t\tgoto error;\n\t\tif (c == '\"')\n\t\t\tbreak;\n\t\tif (c == '\\\\') {\n\t\t\tif (*str++ == 0)\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\t*strp = str;\n\tret = xnew(char, str - start);\n\tstr = start;\n\tdst = ret;\n\twhile (1) {\n\t\tint c = *str++;\n\n\t\tif (c == '\"')\n\t\t\tbreak;\n\t\tif (c == '\\\\') {\n\t\t\tc = *str++;\n\t\t\tif (c != '\"' && c != '\\\\')\n\t\t\t\t*dst++ = '\\\\';\n\t\t}\n\t\t*dst++ = c;\n\t}\n\t*dst = 0;\n\treturn ret;\nerror:\n\terror_msg(\"`\\\"' expected\");\n\treturn NULL;\n}\n\nstatic char *parse_escaped(const char **strp)\n{\n\tconst char *str = *strp;\n\tconst char *start;\n\tchar *ret, *dst;\n\n\tstart = str;\n\twhile (1) {\n\t\tint c = *str;\n\n\t\tif (c == 0 || c == ' ' || c == '\\'' || c == '\"')\n\t\t\tbreak;\n\n\t\tstr++;\n\t\tif (c == '\\\\') {\n\t\t\tc = *str;\n\t\t\tif (c == 0)\n\t\t\t\tbreak;\n\t\t\tstr++;\n\t\t}\n\t}\n\t*strp = str;\n\tret = xnew(char, str - start + 1);\n\tstr = start;\n\tdst = ret;\n\twhile (1) {\n\t\tint c = *str;\n\n\t\tif (c == 0 || c == ' ' || c == '\\'' || c == '\"')\n\t\t\tbreak;\n\n\t\tstr++;\n\t\tif (c == '\\\\') {\n\t\t\tc = *str;\n\t\t\tif (c == 0) {\n\t\t\t\t*dst++ = '\\\\';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstr++;\n\t\t}\n\t\t*dst++ = c;\n\t}\n\t*dst = 0;\n\treturn ret;\n}\n\nstatic char *parse_one(const char **strp)\n{\n\tconst char *str = *strp;\n\tchar *ret = NULL;\n\n\twhile (1) {\n\t\tchar *part = NULL;\n\t\tint c = *str;\n\n\t\tif (!c || c == ' ')\n\t\t\tbreak;\n\t\tif (c == '\"') {\n\t\t\tpart = parse_quoted(&str);\n\t\t\tif (part == NULL)\n\t\t\t\tgoto error;\n\t\t} else if (c == '\\'') {\n\t\t\t/* backslashes are normal chars inside single-quotes */\n\t\t\tconst char *end;\n\n\t\t\tstr++;\n\t\t\tend = strchr(str, '\\'');\n\t\t\tif (end == NULL)\n\t\t\t\tgoto sq_missing;\n\t\t\tpart = xstrndup(str, end - str);\n\t\t\tstr = end + 1;\n\t\t} else {\n\t\t\tpart = parse_escaped(&str);\n\t\t}\n\n\t\tif (ret == NULL) {\n\t\t\tret = xstrdup(part);\n\t\t} else {\n\t\t\tchar *tmp = xstrjoin(ret, part);\n\t\t\tfree(ret);\n\t\t\tret = tmp;\n\t\t}\n\t\tfree(part);\n\t}\n\t*strp = str;\n\treturn ret;\nsq_missing:\n\terror_msg(\"`'' expected\");\nerror:\n\tfree(ret);\n\treturn NULL;\n}\n\nchar **parse_cmd(const char *cmd, int *args_idx, int *ac)\n{\n\tchar **av = NULL;\n\tint nr = 0;\n\tint alloc = 0;\n\n\twhile (*cmd) {\n\t\tchar *arg;\n\n\t\t/* there can't be spaces at start of command\n\t\t * and there is at least one argument */\n\t\tif (cmd[0] == '{' && cmd[1] == '}' && (cmd[2] == ' ' || cmd[2] == 0)) {\n\t\t\t/* {} is replaced with file arguments */\n\t\t\tif (*args_idx != -1)\n\t\t\t\tgoto only_once_please;\n\t\t\t*args_idx = nr;\n\t\t\tcmd += 2;\n\t\t\tgoto skip_spaces;\n\t\t} else {\n\t\t\targ = parse_one(&cmd);\n\t\t\tif (arg == NULL)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tif (nr == alloc) {\n\t\t\talloc = alloc ? alloc * 2 : 4;\n\t\t\tav = xrenew(char *, av, alloc + 1);\n\t\t}\n\t\tav[nr++] = arg;\nskip_spaces:\n\t\twhile (*cmd == ' ')\n\t\t\tcmd++;\n\t}\n\tav[nr] = NULL;\n\t*ac = nr;\n\treturn av;\nonly_once_please:\n\terror_msg(\"{} can be used only once\");\nerror:\n\twhile (nr > 0)\n\t\tfree(av[--nr]);\n\tfree(av);\n\treturn NULL;\n}\n\nstruct track_info_selection {\n\tstruct track_info **tis;\n\tint tis_alloc;\n\tint tis_nr;\n};\n\nstatic int add_ti(void *data, struct track_info *ti)\n{\n\tstruct track_info_selection *sel = data;\n\tif (sel->tis_nr == sel->tis_alloc) {\n\t\tsel->tis_alloc = sel->tis_alloc ? sel->tis_alloc * 2 : 8;\n\t\tsel->tis = xrenew(struct track_info *, sel->tis, sel->tis_alloc);\n\t}\n\ttrack_info_ref(ti);\n\tsel->tis[sel->tis_nr++] = ti;\n\treturn 0;\n}\n\nstatic void cmd_run(char *arg)\n{\n\tchar **av, **argv;\n\tint ac, argc, i, run, files_idx = -1;\n\tstruct track_info_selection sel = { .tis = NULL };\n\n\tif (cur_view > QUEUE_VIEW) {\n\t\tinfo_msg(\"Command execution is supported only in views 1-4\");\n\t\treturn;\n\t}\n\n\tav = parse_cmd(arg, &files_idx, &ac);\n\tif (av == NULL) {\n\t\treturn;\n\t}\n\n\t/* collect selected files (struct track_info) */\n\tswitch (cur_view) {\n\tcase TREE_VIEW:\n\t\t_tree_for_each_sel(add_ti, &sel, 0);\n\t\tbreak;\n\tcase SORTED_VIEW:\n\t\t_editable_for_each_sel(&lib_editable, add_ti, &sel, 0);\n\t\tbreak;\n\tcase PLAYLIST_VIEW:\n\t\t_pl_for_each_sel(add_ti, &sel, 0);\n\t\tbreak;\n\tcase QUEUE_VIEW:\n\t\t_editable_for_each_sel(&pq_editable, add_ti, &sel, 0);\n\t\tbreak;\n\t}\n\n\tif (sel.tis_nr == 0) {\n\t\t/* no files selected, do nothing */\n\t\tfree_str_array(av);\n\t\treturn;\n\t}\n\tsel.tis[sel.tis_nr] = NULL;\n\n\t/* build argv */\n\targv = xnew(char *, ac + sel.tis_nr + 1);\n\targc = 0;\n\tif (files_idx == -1) {\n\t\t/* add selected files after rest of the args */\n\t\tfor (i = 0; i < ac; i++)\n\t\t\targv[argc++] = av[i];\n\t\tfor (i = 0; i < sel.tis_nr; i++)\n\t\t\targv[argc++] = sel.tis[i]->filename;\n\t} else {\n\t\tfor (i = 0; i < files_idx; i++)\n\t\t\targv[argc++] = av[i];\n\t\tfor (i = 0; i < sel.tis_nr; i++)\n\t\t\targv[argc++] = sel.tis[i]->filename;\n\t\tfor (i = files_idx; i < ac; i++)\n\t\t\targv[argc++] = av[i];\n\t}\n\targv[argc] = NULL;\n\n\tfor (i = 0; argv[i]; i++)\n\t\td_print(\"ARG: '%s'\\n\", argv[i]);\n\n\trun = 1;\n\tif (confirm_run && (sel.tis_nr > 1 || strcmp(argv[0], \"rm\") == 0)) {\n\t\tif (yes_no_query(\"Execute %s for the %d selected files? [y/N]\", arg, sel.tis_nr) != UI_QUERY_ANSWER_YES) {\n\t\t\tinfo_msg(\"Aborted\");\n\t\t\trun = 0;\n\t\t}\n\t}\n\tif (run) {\n\t\tint status;\n\n\t\tif (spawn(argv, &status, 1)) {\n\t\t\terror_msg(\"executing %s: %s\", argv[0], strerror(errno));\n\t\t} else {\n\t\t\tif (WIFEXITED(status)) {\n\t\t\t\tint rc = WEXITSTATUS(status);\n\n\t\t\t\tif (rc)\n\t\t\t\t\terror_msg(\"%s returned %d\", argv[0], rc);\n\t\t\t}\n\t\t\tif (WIFSIGNALED(status))\n\t\t\t\terror_msg(\"%s received signal %d\", argv[0], WTERMSIG(status));\n\n\t\t\tswitch (cur_view) {\n\t\t\tcase TREE_VIEW:\n\t\t\tcase SORTED_VIEW:\n\t\t\t\t/* this must be done before sel.tis are unreffed */\n\t\t\t\tfree_str_array(av);\n\t\t\t\tfree(argv);\n\n\t\t\t\t/* remove non-existed files, update tags for changed files */\n\t\t\t\tcmus_update_tis(sel.tis, sel.tis_nr, 0);\n\n\t\t\t\t/* we don't own sel.tis anymore! */\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tfree_str_array(av);\n\tfree(argv);\n\tfor (i = 0; sel.tis[i]; i++)\n\t\ttrack_info_unref(sel.tis[i]);\n\tfree(sel.tis);\n}\n\nstatic void cmd_shell(char *arg)\n{\n\tconst char * const argv[] = { \"sh\", \"-c\", arg, NULL };\n\n\tif (spawn((char **) argv, NULL, 0))\n\t\terror_msg(\"executing '%s': %s\", arg, strerror(errno));\n}\n\nstatic int get_one_ti(void *data, struct track_info *ti)\n{\n\tstruct track_info **sel_ti = data;\n\n\ttrack_info_ref(ti);\n\t*sel_ti = ti;\n\t/* stop the for each loop, we need only the first selected track */\n\treturn 1;\n}\n\nstatic void cmd_echo(char *arg)\n{\n\tstruct track_info *sel_ti;\n\tchar *ptr = arg;\n\n\twhile (1) {\n\t\tptr = strchr(ptr, '{');\n\t\tif (ptr == NULL)\n\t\t\tbreak;\n\t\tif (ptr[1] == '}')\n\t\t\tbreak;\n\t\tptr++;\n\t}\n\n\tif (ptr == NULL) {\n\t\tinfo_msg(\"%s\", arg);\n\t\treturn;\n\t}\n\n\tif (cur_view > QUEUE_VIEW) {\n\t\tinfo_msg(\"echo with {} in its arguments is supported only in views 1-4\");\n\t\treturn;\n\t}\n\n\t*ptr = 0;\n\tptr += 2;\n\n\t/* get only the first selected track */\n\tsel_ti = NULL;\n\n\tswitch (cur_view) {\n\tcase TREE_VIEW:\n\t\t_tree_for_each_sel(get_one_ti, &sel_ti, 0);\n\t\tbreak;\n\tcase SORTED_VIEW:\n\t\t_editable_for_each_sel(&lib_editable, get_one_ti, &sel_ti, 0);\n\t\tbreak;\n\tcase PLAYLIST_VIEW:\n\t\t_pl_for_each_sel(get_one_ti, &sel_ti, 0);\n\t\tbreak;\n\tcase QUEUE_VIEW:\n\t\t_editable_for_each_sel(&pq_editable, get_one_ti, &sel_ti, 0);\n\t\tbreak;\n\t}\n\n\tif (sel_ti == NULL)\n\t\treturn;\n\n\tinfo_msg(\"%s%s%s\", arg, sel_ti->filename, ptr);\n\ttrack_info_unref(sel_ti);\n}\n\nstatic int parse_vol_arg(const char *arg, int *value, unsigned int *flags)\n{\n\tunsigned int f = 0;\n\tint ch, val = 0, digits = 0, sign = 1;\n\n\tif (*arg == '-') {\n\t\targ++;\n\t\tf |= VF_RELATIVE;\n\t\tsign = -1;\n\t} else if (*arg == '+') {\n\t\targ++;\n\t\tf |= VF_RELATIVE;\n\t}\n\n\twhile (1) {\n\t\tch = *arg++;\n\t\tif (ch < '0' || ch > '9')\n\t\t\tbreak;\n\t\tval *= 10;\n\t\tval += ch - '0';\n\t\tdigits++;\n\t}\n\tif (digits == 0)\n\t\tgoto err;\n\n\tif (ch == '%') {\n\t\tf |= VF_PERCENTAGE;\n\t\tch = *arg;\n\t}\n\tif (ch)\n\t\tgoto err;\n\n\t*value = sign * val;\n\t*flags = f;\n\treturn 0;\nerr:\n\treturn -1;\n}\n\nstatic void cmd_mute(char *arg)\n{\n\tint l = 0, r = 0;\n\tint *vl, *vr;\n\n\tif (soft_vol) {\n\t\tvl = &soft_vol_l;\n\t\tvr = &soft_vol_r;\n\t} else {\n\t\tvl = &volume_l;\n\t\tvr = &volume_r;\n\t}\n\n\tif (*vl == 0 && *vr == 0) {\n\t\t// unmute\n\t\tl = mute_vol_l;\n\t\tr = mute_vol_r;\n\t} else {\n\t\tmute_vol_l = *vl;\n\t\tmute_vol_r = *vr;\n\t}\n\n\tint rc = player_set_vol(l, 0, r, 0);\n\tif (rc != OP_ERROR_SUCCESS) {\n\t\tchar *msg = op_get_error_msg(rc, \"can't change volume\");\n\t\terror_msg(\"%s\", msg);\n\t\tfree(msg);\n\t} else {\n\t\tmpris_volume_changed();\n\t}\n\tupdate_statusline();\n}\n\n\n/*\n * :vol value [value]\n *\n * where value is [-+]?[0-9]+%?\n */\nstatic void cmd_vol(char *arg)\n{\n\tchar **values = get_words(arg);\n\tunsigned int lf, rf;\n\tint l, r;\n\n\tif (values[1] && values[2])\n\t\tgoto err;\n\n\tif (parse_vol_arg(values[0], &l, &lf))\n\t\tgoto err;\n\n\tr = l;\n\trf = lf;\n\tif (values[1] && parse_vol_arg(values[1], &r, &rf))\n\t\tgoto err;\n\n\tfree_str_array(values);\n\n\tint rc = player_set_vol(l, lf, r, rf);\n\tif (rc != OP_ERROR_SUCCESS) {\n\t\tchar *msg = op_get_error_msg(rc, \"can't change volume\");\n\t\terror_msg(\"%s\", msg);\n\t\tfree(msg);\n\t} else {\n\t\tmpris_volume_changed();\n\t}\n\tupdate_statusline();\n\treturn;\nerr:\n\tfree_str_array(values);\n\terror_msg(\"expecting 1 or 2 arguments (total or L and R volumes [+-]INTEGER[%%])\\n\");\n}\n\nstatic void cmd_prev_view(char *arg)\n{\n\tif (prev_view >= 0) {\n\t\tset_view(prev_view);\n\t}\n}\n\nstatic void cmd_left_view(char *arg)\n{\n\tint flag = parse_flags((const char **)&arg, \"n\");\n\n\tif (cur_view == TREE_VIEW) {\n\t\tif (flag != 'n') {\n\t\t\tset_view(HELP_VIEW);\n\t\t}\n\t} else {\n\t\tset_view(cur_view - 1);\n\t}\n}\n\nstatic void cmd_right_view(char *arg)\n{\n\tint flag = parse_flags((const char **)&arg, \"n\");\n\n\tif (cur_view == HELP_VIEW) {\n\t\tif (flag != 'n') {\n\t\t\tset_view(TREE_VIEW);\n\t\t}\n\t} else {\n\t\tset_view(cur_view + 1);\n\t}\n}\n\nstatic void cmd_pl_create(char *arg)\n{\n\tpl_create(arg);\n}\n\nstatic void cmd_pl_export(char *arg)\n{\n\tif (cur_view == PLAYLIST_VIEW)\n\t\tpl_export_selected_pl(arg);\n\telse\n\t\tinfo_msg(\":pl-export only works in view 3\");\n}\n\nstatic char *get_browser_add_file(void)\n{\n\tchar *sel = browser_get_sel();\n\n\tif (sel && (ends_with(sel, \"/../\") || ends_with(sel, \"/..\"))) {\n\t\tinfo_msg(\"For convenience, you can not add \\\"..\\\" directory from the browser view\");\n\t\tfree(sel);\n\t\tsel = NULL;\n\t}\n\n\treturn sel;\n}\n\nstatic void cmd_pl_import(char *arg)\n{\n\tchar *name = NULL;\n\n\tif (arg)\n\t\tname = view_load_prepare(arg);\n\telse if (cur_view == BROWSER_VIEW)\n\t\tname = get_browser_add_file();\n\telse\n\t\terror_msg(\"not enough arguments\");\n\n\tif (name) {\n\t\tpl_import(name);\n\t\tfree(name);\n\t}\n}\n\nstatic void cmd_pl_rename(char *arg)\n{\n\tif (cur_view == PLAYLIST_VIEW)\n\t\tpl_rename_selected_pl(arg);\n\telse\n\t\tinfo_msg(\":pl-rename only works in view 3\");\n}\n\nstatic void cmd_pl_delete(char *arg)\n{\n\tint flag = parse_flags((const char **)&arg, \"a\");\n\tif (flag == 'a')\n\t\tpl_delete_all();\n\telse\n\t\tpl_delete_by_name(arg);\n}\n\nstatic void cmd_version(char *arg)\n{\n\tinfo_msg(VERSION);\n}\n\nstatic void cmd_view(char *arg)\n{\n\tint view;\n\n\tif (parse_enum(arg, 1, NR_VIEWS, view_names, &view) && (view - 1) != cur_view) {\n\t\tset_view(view - 1);\n\t}\n}\n\nstatic void cmd_push(char *arg)\n{\n\tif (arg)\n\t\tcmdline_set_text(arg);\n\tenter_command_mode();\n}\n\nstatic void cmd_p_next(char *arg)\n{\n\tcmus_next();\n}\n\nstatic void cmd_p_pause(char *arg)\n{\n\tplayer_pause();\n}\n\nstatic void cmd_p_pause_playback(char *arg)\n{\n\tplayer_pause_playback();\n}\n\nstatic void cmd_p_play(char *arg)\n{\n\tif (arg) {\n\t\tchar *tmp = expand_filename(arg);\n\t\tcmus_play_file(tmp);\n\t\tfree(tmp);\n\t} else {\n\t\tplayer_play();\n\t}\n}\n\nstatic void cmd_p_prev(char *arg)\n{\n\tif (rewind_offset < 0 || player_info.pos < rewind_offset) {\n\t\tcmus_prev();\n\t} else {\n\t\tplayer_play();\n\t}\n}\n\nstatic void cmd_p_next_album(char *arg)\n{\n\tcmus_next_album();\n}\n\nstatic void cmd_p_prev_album(char *arg)\n{\n\tcmus_prev_album();\n}\n\nstatic void cmd_p_stop(char *arg)\n{\n\tplayer_stop();\n}\n\nstatic void cmd_pwd(char *arg)\n{\n\tchar buf[4096];\n\tif (getcwd(buf, sizeof buf)) {\n\t\tinfo_msg(\"%s\", buf);\n\t}\n}\n\nstatic void cmd_raise_vte(char *arg)\n{\n\tcmus_raise_vte();\n}\n\nstatic void cmd_rand(char *arg)\n{\n\tswitch (cur_view) {\n\tcase TREE_VIEW:\n\t\tbreak;\n\tcase SORTED_VIEW:\n\t\teditable_rand(&lib_editable);\n\t\tbreak;\n\tcase PLAYLIST_VIEW:\n\t\tpl_rand();\n\t\tbreak;\n\tcase QUEUE_VIEW:\n\t\teditable_rand(&pq_editable);\n\t\tbreak;\n\t}\n}\n\nstatic void cmd_search_next(char *arg)\n{\n\tif (search_str) {\n\t\tif (!search_next(searchable, search_str, search_direction))\n\t\t\tsearch_not_found();\n\t}\n}\n\nstatic void cmd_search_prev(char *arg)\n{\n\tif (search_str) {\n\t\tif (!search_next(searchable, search_str, !search_direction))\n\t\t\tsearch_not_found();\n\t}\n}\n\nstatic void cmd_search_start(char *arg)\n{\n\tenter_search_mode();\n}\n\nstatic void cmd_search_b_start(char *arg)\n{\n\tenter_search_backward_mode();\n}\n\nstatic int sorted_for_each_sel(track_info_cb cb, void *data, int reverse, int advance)\n{\n\treturn editable_for_each_sel(&lib_editable, cb, data, reverse, advance);\n}\n\nstatic int pq_for_each_sel(track_info_cb cb, void *data, int reverse, int advance)\n{\n\treturn editable_for_each_sel(&pq_editable, cb, data, reverse, advance);\n}\n\nstatic for_each_sel_ti_cb view_for_each_sel[4] = {\n\ttree_for_each_sel,\n\tsorted_for_each_sel,\n\tpl_for_each_sel,\n\tpq_for_each_sel\n};\n\n/* wrapper for add_ti_cb, (void *) can't store function pointers */\nstruct wrapper_cb_data {\n\tadd_ti_cb cb;\n};\n\n/* wrapper for void lib_add_track(struct track_info *) etc. */\nstatic int wrapper_cb(void *data, struct track_info *ti)\n{\n\tstruct wrapper_cb_data *add = data;\n\n\tadd->cb(ti, NULL);\n\treturn 0;\n}\n\nstatic void add_from_browser(add_ti_cb add, int job_type, int advance)\n{\n\tchar *sel = get_browser_add_file();\n\n\tif (sel) {\n\t\tenum file_type ft;\n\t\tchar *ret;\n\n\t\tft = cmus_detect_ft(sel, &ret);\n\t\tif (ft != FILE_TYPE_INVALID) {\n\t\t\tcmus_add(add, ret, ft, job_type, 0, NULL);\n\t\t\tif (advance)\n\t\t\t\twindow_down(browser_win, 1);\n\t\t}\n\t\tfree(ret);\n\t\tfree(sel);\n\t}\n}\n\nstatic void cmd_win_add_l(char *arg)\n{\n\tint flag = parse_flags((const char **)&arg, \"n\");\n\tif (flag == -1)\n\t\treturn;\n\n\tif (cur_view == TREE_VIEW || cur_view == SORTED_VIEW)\n\t\treturn;\n\n\tif (cur_view <= QUEUE_VIEW) {\n\t\tstruct wrapper_cb_data add = { lib_add_track };\n\t\tview_for_each_sel[cur_view](wrapper_cb, &add, 0, flag != 'n');\n\t} else if (cur_view == BROWSER_VIEW) {\n\t\tadd_from_browser(lib_add_track, JOB_TYPE_LIB, flag != 'n');\n\t}\n}\n\nstatic void cmd_win_add_p(char *arg)\n{\n\tint flag = parse_flags((const char **)&arg, \"n\");\n\tif (flag == -1)\n\t\treturn;\n\n\tif (cur_view == PLAYLIST_VIEW && pl_visible_is_marked())\n\t\treturn;\n\n\tif (cur_view <= QUEUE_VIEW) {\n\t\tstruct wrapper_cb_data add = { pl_add_track_to_marked_pl2 };\n\t\tview_for_each_sel[cur_view](wrapper_cb, &add, 0, flag != 'n');\n\t} else if (cur_view == BROWSER_VIEW) {\n\t\tchar *sel = get_browser_add_file();\n\t\tif (sel) {\n\t\t\tif (pl_add_file_to_marked_pl(sel) && flag != 'n')\n\t\t\t\twindow_down(browser_win, 1);\n\t\t\tfree(sel);\n\t\t}\n\t}\n}\n\nstatic void cmd_win_add_Q(char *arg)\n{\n\tint flag = parse_flags((const char **)&arg, \"n\");\n\tif (flag == -1)\n\t\treturn;\n\n\tif (cur_view == QUEUE_VIEW)\n\t\treturn;\n\n\tif (cur_view <= QUEUE_VIEW) {\n\t\tstruct wrapper_cb_data add = { play_queue_prepend };\n\t\tview_for_each_sel[cur_view](wrapper_cb, &add, 1, flag != 'n');\n\t} else if (cur_view == BROWSER_VIEW) {\n\t\tadd_from_browser(play_queue_prepend, JOB_TYPE_QUEUE, flag != 'n');\n\t}\n}\n\nstatic void cmd_win_add_q(char *arg)\n{\n\tint flag = parse_flags((const char **)&arg, \"n\");\n\tif (flag == -1)\n\t\treturn;\n\n\tif (cur_view == QUEUE_VIEW)\n\t\treturn;\n\n\tif (cur_view <= QUEUE_VIEW) {\n\t\tstruct wrapper_cb_data add = { play_queue_append };\n\t\tview_for_each_sel[cur_view](wrapper_cb, &add, 0, flag != 'n');\n\t} else if (cur_view == BROWSER_VIEW) {\n\t\tadd_from_browser(play_queue_append, JOB_TYPE_QUEUE, flag != 'n');\n\t}\n}\n\nstatic void cmd_win_activate(char *arg)\n{\n\tstruct track_info *info = NULL;\n\tstruct shuffle_info *previous = NULL, *next = NULL;\n\tstruct rb_root *shuffle_root = NULL;\n\n\tif (cur_view == TREE_VIEW || cur_view == SORTED_VIEW) {\n\t\tif (shuffle == SHUFFLE_TRACKS) {\n\t\t\tif (lib_cur_track)\n\t\t\t\tprevious = &lib_cur_track->simple_track.shuffle_info;\n\t\t\tshuffle_root = &lib_shuffle_root;\n\t\t} else if (shuffle == SHUFFLE_ALBUMS) {\n\t\t\tif (lib_cur_track)\n\t\t\t\tprevious = &lib_cur_track->album->shuffle_info;\n\t\t\tshuffle_root = &lib_album_shuffle_root;\n\t\t}\n\t}\n\n\tswitch (cur_view) {\n\tcase TREE_VIEW:\n\t\tinfo = tree_activate_selected();\n\t\tif (shuffle == SHUFFLE_TRACKS)\n\t\t\tnext = &lib_cur_track->simple_track.shuffle_info;\n\t\telse if (shuffle == SHUFFLE_ALBUMS)\n\t\t\tnext = &lib_cur_track->album->shuffle_info;\n\t\tbreak;\n\tcase SORTED_VIEW:\n\t\tinfo = sorted_activate_selected();\n\t\tif (shuffle == SHUFFLE_TRACKS)\n\t\t\tnext = &lib_cur_track->simple_track.shuffle_info;\n\t\telse if (shuffle == SHUFFLE_ALBUMS)\n\t\t\tnext = &lib_cur_track->album->shuffle_info;\n\t\tbreak;\n\tcase PLAYLIST_VIEW:\n\t\tinfo = pl_play_selected_row();\n\t\tbreak;\n\tcase QUEUE_VIEW:\n\t\tbreak;\n\tcase BROWSER_VIEW:\n\t\tbrowser_enter();\n\t\tbreak;\n\tcase FILTERS_VIEW:\n\t\tfilters_activate(1);\n\t\tbreak;\n\tcase HELP_VIEW:\n\t\thelp_select();\n\t\tbreak;\n\t}\n\n\tif (info) {\n\t\tif (shuffle && next)\n\t\t\tshuffle_insert(shuffle_root, previous, next);\n\t\t/* update lib/pl mode */\n\t\tif (cur_view < 2)\n\t\t\tplay_library = 1;\n\t\tif (cur_view == 2)\n\t\t\tplay_library = 0;\n\n\t\tplayer_play_file(info);\n\t}\n}\n\nstatic void cmd_win_mv_after(char *arg)\n{\n\tswitch (cur_view) {\n\tcase SORTED_VIEW:\n\t\teditable_move_after(&lib_editable);\n\t\tbreak;\n\tcase PLAYLIST_VIEW:\n\t\tpl_win_mv_after();\n\t\tbreak;\n\tcase QUEUE_VIEW:\n\t\teditable_move_after(&pq_editable);\n\t\tbreak;\n\t}\n}\n\nstatic void cmd_win_mv_before(char *arg)\n{\n\tswitch (cur_view) {\n\tcase SORTED_VIEW:\n\t\teditable_move_before(&lib_editable);\n\t\tbreak;\n\tcase PLAYLIST_VIEW:\n\t\tpl_win_mv_before();\n\t\tbreak;\n\tcase QUEUE_VIEW:\n\t\teditable_move_before(&pq_editable);\n\t\tbreak;\n\t}\n}\n\nstatic void cmd_win_remove(char *arg)\n{\n\tswitch (cur_view) {\n\tcase TREE_VIEW:\n\t\ttree_remove_sel();\n\t\tbreak;\n\tcase SORTED_VIEW:\n\t\teditable_remove_sel(&lib_editable);\n\t\tbreak;\n\tcase PLAYLIST_VIEW:\n\t\tpl_win_remove();\n\t\tbreak;\n\tcase QUEUE_VIEW:\n\t\teditable_remove_sel(&pq_editable);\n\t\tbreak;\n\tcase BROWSER_VIEW:\n\t\tbrowser_delete();\n\t\tbreak;\n\tcase FILTERS_VIEW:\n\t\tfilters_delete_filter();\n\t\tbreak;\n\tcase HELP_VIEW:\n\t\thelp_remove();\n\t\tbreak;\n\t}\n}\n\nstatic void cmd_win_sel_cur(char *arg)\n{\n\tswitch (cur_view) {\n\tcase TREE_VIEW:\n\t\ttree_sel_current(auto_expand_albums_selcur);\n\t\tbreak;\n\tcase SORTED_VIEW:\n\t\tsorted_sel_current();\n\t\tbreak;\n\tcase PLAYLIST_VIEW:\n\t\tpl_select_playing_track();\n\t\tbreak;\n\t}\n}\n\nstatic void cmd_win_toggle(char *arg)\n{\n\tswitch (cur_view) {\n\tcase TREE_VIEW:\n\t\ttree_toggle_expand_artist();\n\t\tbreak;\n\tcase SORTED_VIEW:\n\t\teditable_toggle_mark(&lib_editable);\n\t\tbreak;\n\tcase PLAYLIST_VIEW:\n\t\tpl_win_toggle();\n\t\tbreak;\n\tcase QUEUE_VIEW:\n\t\teditable_toggle_mark(&pq_editable);\n\t\tbreak;\n\tcase FILTERS_VIEW:\n\t\tfilters_toggle_filter();\n\t\tbreak;\n\tcase HELP_VIEW:\n\t\thelp_toggle();\n\t\tbreak;\n\t}\n}\n\nstatic void cmd_win_scroll_down(char *arg)\n{\n\twindow_scroll_down(current_win());\n}\n\nstatic void cmd_win_scroll_up(char *arg)\n{\n\twindow_scroll_up(current_win());\n}\n\nstatic void cmd_win_bottom(char *arg)\n{\n\twindow_goto_bottom(current_win());\n}\n\nstatic void cmd_win_down(char *arg)\n{\n\tunsigned num_rows = 1;\n\tchar *end;\n\n\tif (arg) {\n\t\tif ((num_rows = get_number(arg, &end)) == 0 || *end) {\n\t\t\terror_msg(\"invalid argument\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\twindow_down(current_win(), num_rows);\n}\n\nstatic void cmd_win_next(char *arg)\n{\n\tif (cur_view == TREE_VIEW)\n\t\ttree_toggle_active_window();\n\telse if (cur_view == PLAYLIST_VIEW)\n\t\tpl_win_next();\n}\n\nstatic void cmd_win_pg_down(char *arg)\n{\n\twindow_page_down(current_win());\n}\n\nstatic void cmd_win_pg_up(char *arg)\n{\n\twindow_page_up(current_win());\n}\n\nstatic void cmd_win_hf_pg_down(char *arg)\n{\n\twindow_half_page_down(current_win());\n}\n\nstatic void cmd_win_hf_pg_up(char *arg)\n{\n\twindow_half_page_up(current_win());\n}\n\nstatic void cmd_win_pg_top(char *arg)\n{\n\twindow_page_top(current_win());\n}\n\nstatic void cmd_win_pg_bottom(char *arg)\n{\n\twindow_page_bottom(current_win());\n}\n\nstatic void cmd_win_pg_middle(char *arg)\n{\n\twindow_page_middle(current_win());\n}\n\nstatic void cmd_win_update_cache(char *arg)\n{\n\tstruct track_info_selection sel = { .tis = NULL };\n\tint flag = parse_flags((const char **)&arg, \"f\");\n\n\tif (cur_view != TREE_VIEW && cur_view != SORTED_VIEW)\n\t\treturn;\n\n\tview_for_each_sel[cur_view](add_ti, &sel, 0, 1);\n\tif (sel.tis_nr == 0)\n\t\treturn;\n\tsel.tis[sel.tis_nr] = NULL;\n\tcmus_update_tis(sel.tis, sel.tis_nr, flag == 'f');\n}\n\nstatic void cmd_win_top(char *arg)\n{\n\twindow_goto_top(current_win());\n}\n\nstatic void cmd_win_up(char *arg)\n{\n\tunsigned num_rows = 1;\n\tchar *end;\n\n\tif (arg) {\n\t\tif ((num_rows = get_number(arg, &end)) == 0 || *end) {\n\t\t\terror_msg(\"invalid argument\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\twindow_up(current_win(), num_rows);\n}\n\nstatic void cmd_win_update(char *arg)\n{\n\tswitch (cur_view) {\n\tcase TREE_VIEW:\n\tcase SORTED_VIEW:\n\t\tcmus_update_lib();\n\t\tbreak;\n\tcase PLAYLIST_VIEW:\n\t\tpl_win_update();\n\t\tbreak;\n\tcase BROWSER_VIEW:\n\t\tbrowser_reload();\n\t\tbreak;\n\t}\n}\n\nstatic void cmd_browser_up(char *arg)\n{\n\tbrowser_up();\n}\n\nstatic void cmd_refresh(char *arg)\n{\n\tclearok(curscr, TRUE);\n\trefresh();\n}\n\nstatic int cmp_intp(const void *ap, const void *bp)\n{\n\tint a = *(int *)ap;\n\tint b = *(int *)bp;\n\treturn a - b;\n}\n\nstatic int *rand_array(int size, int nmax)\n{\n\tint *r = xnew(int, size + 1);\n\tint i, offset = 0;\n\tint count = size;\n\n\tif (count > nmax / 2) {\n\t\t/*\n\t\t * Imagine that there are 1000 tracks in library and we want to\n\t\t * add 998 random tracks to queue.  After we have added 997\n\t\t * random numbers to the array it would be quite hard to find a\n\t\t * random number that isn't already in the array (3/1000\n\t\t * probability).\n\t\t *\n\t\t * So we invert the logic:\n\t\t *\n\t\t * Find two (1000 - 998) random numbers in 0..999 range and put\n\t\t * them at end of the array.  Sort the numbers and then fill\n\t\t * the array starting at index 0 with incrementing values that\n\t\t * are not in the set of random numbers.\n\t\t */\n\t\tcount = nmax - count;\n\t\toffset = size - count;\n\t}\n\n\tfor (i = 0; i < count; ) {\n\t\tint v, j;\nfound:\n\t\tv = rand() % nmax;\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tif (r[offset + j] == v)\n\t\t\t\tgoto found;\n\t\t}\n\t\tr[offset + i++] = v;\n\t}\n\tqsort(r + offset, count, sizeof(*r), cmp_intp);\n\n\tif (offset) {\n\t\tint j, n;\n\n\t\t/* simplifies next loop */\n\t\tr[size] = nmax;\n\n\t\t/* convert the indexes we don't want to those we want */\n\t\ti = 0;\n\t\tj = offset;\n\t\tn = 0;\n\t\tdo {\n\t\t\twhile (n < r[j])\n\t\t\t\tr[i++] = n++;\n\t\t\tj++;\n\t\t\tn++;\n\t\t} while (i < size);\n\t}\n\treturn r;\n}\n\nstatic int count_albums(void)\n{\n\tstruct artist *artist;\n\tstruct rb_node *tmp1, *tmp2;\n\tint count = 0;\n\n\trb_for_each_entry(artist, tmp1, &lib_artist_root, tree_node) {\n\t\trb_for_each(tmp2, &artist->album_root)\n\t\t\tcount++;\n\t}\n\treturn count;\n}\n\nstruct album_list {\n\tstruct list_head node;\n\tconst struct album *album;\n};\n\nstatic void cmd_lqueue(char *arg)\n{\n\tLIST_HEAD(head);\n\tconst struct list_head *item;\n\tconst struct album *album;\n\tint count = 1, nmax, i, pos;\n\tint *r;\n\n\tif (arg) {\n\t\tlong int val;\n\n\t\tif (str_to_int(arg, &val) || val <= 0) {\n\t\t\terror_msg(\"argument must be positive integer\");\n\t\t\treturn;\n\t\t}\n\t\tcount = val;\n\t}\n\tnmax = count_albums();\n\tif (count > nmax)\n\t\tcount = nmax;\n\tif (!count)\n\t\treturn;\n\n\tr = rand_array(count, nmax);\n\talbum = to_album(rb_first(&to_artist(rb_first(&lib_artist_root))->album_root));\n\tpos = 0;\n\tfor (i = 0; i < count; i++) {\n\t\tstruct album_list *a;\n\n\t\twhile (pos < r[i]) {\n\t\t\tstruct artist *artist = album->artist;\n\t\t\tif (!rb_next(&album->tree_node)) {\n\t\t\t\tartist = to_artist(rb_next(&artist->tree_node));\n\t\t\t\talbum = to_album(rb_first(&artist->album_root));\n\t\t\t} else {\n\t\t\t\talbum = to_album(rb_next(&album->tree_node));\n\t\t\t}\n\t\t\tpos++;\n\t\t}\n\t\ta = xnew(struct album_list, 1);\n\t\ta->album = album;\n\t\tlist_add_rand(&head, &a->node, i);\n\t}\n\tfree(r);\n\n\titem = head.next;\n\tdo {\n\t\tstruct list_head *next = item->next;\n\t\tstruct album_list *a = container_of(item, struct album_list, node);\n\t\tstruct tree_track *t;\n\t\tstruct rb_node *tmp;\n\n\t\trb_for_each_entry(t, tmp, &a->album->track_root, tree_node)\n\t\t\tplay_queue_append(tree_track_info(t), NULL);\n\t\tfree(a);\n\t\titem = next;\n\t} while (item != &head);\n}\n\nstruct track_list {\n\tstruct list_head node;\n\tconst struct simple_track *track;\n};\n\nstatic void cmd_tqueue(char *arg)\n{\n\tLIST_HEAD(head);\n\tstruct list_head *item;\n\tint count = 1, i, pos;\n\tint *r;\n\n\tif (arg) {\n\t\tlong int val;\n\n\t\tif (str_to_int(arg, &val) || val <= 0) {\n\t\t\terror_msg(\"argument must be positive integer\");\n\t\t\treturn;\n\t\t}\n\t\tcount = val;\n\t}\n\tif (count > lib_editable.nr_tracks)\n\t\tcount = lib_editable.nr_tracks;\n\tif (!count)\n\t\treturn;\n\n\tr = rand_array(count, lib_editable.nr_tracks);\n\titem = lib_editable.head.next;\n\tpos = 0;\n\tfor (i = 0; i < count; i++) {\n\t\tstruct track_list *t;\n\n\t\twhile (pos < r[i]) {\n\t\t\titem = item->next;\n\t\t\tpos++;\n\t\t}\n\t\tt = xnew(struct track_list, 1);\n\t\tt->track = to_simple_track(item);\n\t\tlist_add_rand(&head, &t->node, i);\n\t}\n\tfree(r);\n\n\titem = head.next;\n\tdo {\n\t\tstruct list_head *next = item->next;\n\t\tstruct track_list *t = container_of(item, struct track_list, node);\n\t\tplay_queue_append(t->track->info, NULL);\n\t\tfree(t);\n\t\titem = next;\n\t} while (item != &head);\n}\n\n/* tab exp {{{\n *\n * these functions fill tabexp struct, which is resetted beforehand\n */\n\n/* buffer used for tab expansion */\nstatic char expbuf[512];\n\nstatic int filter_directories(const char *name, const struct stat *s)\n{\n\treturn S_ISDIR(s->st_mode);\n}\n\nstatic int filter_executable_files(const char *name, const struct stat *s)\n{\n\treturn S_ISREG(s->st_mode) && (s->st_mode & 0111);\n}\n\nstatic int filter_any(const char *name, const struct stat *s)\n{\n\treturn 1;\n}\n\nstatic int filter_playable(const char *name, const struct stat *s)\n{\n\treturn S_ISDIR(s->st_mode) || cmus_is_playable(name);\n}\n\nstatic int filter_playlist(const char *name, const struct stat *s)\n{\n\treturn S_ISDIR(s->st_mode) || cmus_is_playlist(name);\n}\n\nstatic int filter_supported(const char *name, const struct stat *s)\n{\n\treturn S_ISDIR(s->st_mode) || cmus_is_supported(name);\n}\n\nstatic void expand_files(const char *str)\n{\n\texpand_files_and_dirs(str, filter_any);\n}\n\nstatic void expand_directories(const char *str)\n{\n\texpand_files_and_dirs(str, filter_directories);\n}\n\nstatic void expand_playable(const char *str)\n{\n\texpand_files_and_dirs(str, filter_playable);\n}\n\nstatic void expand_playlist(const char *str)\n{\n\texpand_files_and_dirs(str, filter_playlist);\n}\n\nstatic void expand_supported(const char *str)\n{\n\texpand_files_and_dirs(str, filter_supported);\n}\n\nstatic void expand_add(const char *str)\n{\n\tint flag = parse_flags(&str, \"lpqQ\");\n\n\tif (flag == -1)\n\t\treturn;\n\tif (str == NULL)\n\t\tstr = \"\";\n\texpand_supported(str);\n\n\tif (tabexp.head && flag) {\n\t\tsnprintf(expbuf, sizeof(expbuf), \"-%c %s\", flag, tabexp.head);\n\t\tfree(tabexp.head);\n\t\ttabexp.head = xstrdup(expbuf);\n\t}\n}\n\nstatic void expand_program_paths(const char *str)\n{\n\tif (str == NULL)\n\t\tstr = \"\";\n\tif (str[0] == '~' || strchr(str, '/'))\n\t\texpand_files(str);\n\telse\n\t\texpand_env_path(str, filter_executable_files);\n}\n\nstatic void expand_program_paths_option(const char *str, const char *opt)\n{\n\texpand_program_paths(str);\n\n\tif (tabexp.head && opt) {\n\t\tsnprintf(expbuf, sizeof(expbuf), \"%s=%s\", opt, tabexp.head);\n\t\tfree(tabexp.head);\n\t\ttabexp.head = xstrdup(expbuf);\n\t}\n}\n\nstatic void expand_load_save(const char *str)\n{\n\tint flag = parse_flags(&str, \"lp\");\n\n\tif (flag == -1)\n\t\treturn;\n\tif (str == NULL)\n\t\tstr = \"\";\n\texpand_playlist(str);\n\n\tif (tabexp.head && flag) {\n\t\tsnprintf(expbuf, sizeof(expbuf), \"-%c %s\", flag, tabexp.head);\n\t\tfree(tabexp.head);\n\t\ttabexp.head = xstrdup(expbuf);\n\t}\n}\n\nstatic void expand_key_context(const char *str, const char *force)\n{\n\tint pos, i, len = strlen(str);\n\tchar **tails;\n\n\ttails = xnew(char *, NR_CTXS);\n\tpos = 0;\n\tfor (i = 0; key_context_names[i]; i++) {\n\t\tint cmp = strncmp(str, key_context_names[i], len);\n\t\tif (cmp > 0)\n\t\t\tcontinue;\n\t\tif (cmp < 0)\n\t\t\tbreak;\n\t\ttails[pos++] = xstrdup(key_context_names[i] + len);\n\t}\n\n\tif (pos == 0) {\n\t\tfree(tails);\n\t\treturn;\n\t}\n\tif (pos == 1) {\n\t\tchar *tmp = xstrjoin(tails[0], \" \");\n\t\tfree(tails[0]);\n\t\ttails[0] = tmp;\n\t}\n\tsnprintf(expbuf, sizeof(expbuf), \"%s%s\", force, str);\n\ttabexp.head = xstrdup(expbuf);\n\ttabexp.tails = tails;\n\ttabexp.count = pos;\n}\n\nstatic int get_context(const char *str, int len)\n{\n\tint i, c = -1, count = 0;\n\n\tfor (i = 0; key_context_names[i]; i++) {\n\t\tif (strncmp(str, key_context_names[i], len) == 0) {\n\t\t\tif (key_context_names[i][len] == 0) {\n\t\t\t\t/* exact */\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\tc = i;\n\t\t\tcount++;\n\t\t}\n\t}\n\tif (count == 1)\n\t\treturn c;\n\treturn -1;\n}\n\nstatic void expand_command_line(const char *str);\n\nstatic void expand_bind_args(const char *str)\n{\n\t/* :bind context key function\n\t *\n\t * possible values for str:\n\t *   c\n\t *   context k\n\t *   context key f\n\t *\n\t * you need to know context before you can expand function\n\t */\n\t/* start and end pointers for context, key and function */\n\tconst char *cs, *ce, *ks, *ke, *fs;\n\tint i, c, k, count;\n\tint flag = parse_flags((const char **)&str, \"f\");\n\tconst char *force = \"\";\n\n\tif (flag == -1)\n\t\treturn;\n\tif (str == NULL)\n\t\tstr = \"\";\n\n\tif (flag == 'f')\n\t\tforce = \"-f \";\n\n\tcs = str;\n\tce = strchr(cs, ' ');\n\tif (ce == NULL) {\n\t\texpand_key_context(cs, force);\n\t\treturn;\n\t}\n\n\t/* context must be expandable */\n\tc = get_context(cs, ce - cs);\n\tif (c == -1) {\n\t\t/* context is ambiguous or invalid */\n\t\treturn;\n\t}\n\n\tks = ce;\n\twhile (*ks == ' ')\n\t\tks++;\n\tke = strchr(ks, ' ');\n\tif (ke == NULL) {\n\t\t/* expand key */\n\t\tint len = strlen(ks);\n\t\tPTR_ARRAY(array);\n\n\t\tfor (i = 0; key_table[i].name; i++) {\n\t\t\tint cmp = strncmp(ks, key_table[i].name, len);\n\t\t\tif (cmp > 0)\n\t\t\t\tcontinue;\n\t\t\tif (cmp < 0)\n\t\t\t\tbreak;\n\t\t\tptr_array_add(&array, xstrdup(key_table[i].name + len));\n\t\t}\n\n\t\tif (!array.count)\n\t\t\treturn;\n\n\t\tif (array.count == 1) {\n\t\t\tchar **ptrs = array.ptrs;\n\t\t\tchar *tmp = xstrjoin(ptrs[0], \" \");\n\t\t\tfree(ptrs[0]);\n\t\t\tptrs[0] = tmp;\n\t\t}\n\n\t\tsnprintf(expbuf, sizeof(expbuf), \"%s%s %s\", force, key_context_names[c], ks);\n\n\t\ttabexp.head = xstrdup(expbuf);\n\t\ttabexp.tails = array.ptrs;\n\t\ttabexp.count = array.count;\n\t\treturn;\n\t}\n\n\t/* key must be expandable */\n\tk = -1;\n\tcount = 0;\n\tfor (i = 0; key_table[i].name; i++) {\n\t\tif (strncmp(ks, key_table[i].name, ke - ks) == 0) {\n\t\t\tif (key_table[i].name[ke - ks] == 0) {\n\t\t\t\t/* exact */\n\t\t\t\tk = i;\n\t\t\t\tcount = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tk = i;\n\t\t\tcount++;\n\t\t}\n\t}\n\tif (count != 1) {\n\t\t/* key is ambiguous or invalid */\n\t\treturn;\n\t}\n\n\tfs = ke;\n\twhile (*fs == ' ')\n\t\tfs++;\n\n\tif (*fs == ':')\n\t\tfs++;\n\n\t/* expand com [arg...] */\n\texpand_command_line(fs);\n\tif (tabexp.head == NULL) {\n\t\t/* command expand failed */\n\t\treturn;\n\t}\n\n\t/*\n\t * tabexp.head is now \"com\"\n\t * tabexp.tails is [ mand1 mand2 ... ]\n\t *\n\t * need to change tabexp.head to \"context key com\"\n\t */\n\n\tsnprintf(expbuf, sizeof(expbuf), \"%s%s %s %s\", force, key_context_names[c],\n\t\t\tkey_table[k].name, tabexp.head);\n\tfree(tabexp.head);\n\ttabexp.head = xstrdup(expbuf);\n}\n\nstatic void expand_unbind_args(const char *str)\n{\n\t/* :unbind context key */\n\t/* start and end pointers for context and key */\n\tconst char *cs, *ce, *ks;\n\tconst struct binding *b;\n\tPTR_ARRAY(array);\n\tint c, len;\n\n\tcs = str;\n\tce = strchr(cs, ' ');\n\tif (ce == NULL) {\n\t\texpand_key_context(cs, \"\");\n\t\treturn;\n\t}\n\n\t/* context must be expandable */\n\tc = get_context(cs, ce - cs);\n\tif (c == -1) {\n\t\t/* context is ambiguous or invalid */\n\t\treturn;\n\t}\n\n\tks = ce;\n\twhile (*ks == ' ')\n\t\tks++;\n\n\t/* expand key */\n\tlen = strlen(ks);\n\tb = key_bindings[c];\n\twhile (b) {\n\t\tif (!strncmp(ks, b->key->name, len))\n\t\t\tptr_array_add(&array, xstrdup(b->key->name + len));\n\t\tb = b->next;\n\t}\n\tif (!array.count)\n\t\treturn;\n\n\tsnprintf(expbuf, sizeof(expbuf), \"%s %s\", key_context_names[c], ks);\n\n\ttabexp.head = xstrdup(expbuf);\n\ttabexp.tails = array.ptrs;\n\ttabexp.count = array.count;\n}\n\nstatic void expand_factivate(const char *str)\n{\n\t/* \"name1 name2 name3\", expand only name3 */\n\tstruct filter_entry *e;\n\tconst char *name;\n\tPTR_ARRAY(array);\n\tint str_len, len, i;\n\n\tstr_len = strlen(str);\n\ti = str_len;\n\twhile (i > 0) {\n\t\tif (str[i - 1] == ' ')\n\t\t\tbreak;\n\t\ti--;\n\t}\n\tlen = str_len - i;\n\tname = str + i;\n\n\tlist_for_each_entry(e, &filters_head, node) {\n\t\tif (!strncmp(name, e->name, len))\n\t\t\tptr_array_add(&array, xstrdup(e->name + len));\n\t}\n\tif (!array.count)\n\t\treturn;\n\n\ttabexp.head = xstrdup(str);\n\ttabexp.tails = array.ptrs;\n\ttabexp.count = array.count;\n}\n\nstatic void expand_fset(const char *str)\n{\n\tstruct filter_entry *e;\n\tPTR_ARRAY(array);\n\n\tlist_for_each_entry(e, &filters_head, node) {\n\t\tchar *line = xnew(char, strlen(e->name) + strlen(e->filter) + 2);\n\t\tsprintf(line, \"%s=%s\", e->name, e->filter);\n\t\tif (!strncmp(str, line, strlen(str)))\n\t\t\tptr_array_add(&array, xstrdup(line + strlen(str)));\n\t\tfree(line);\n\t}\n\tif (!array.count)\n\t\treturn;\n\n\ttabexp.head = xstrdup(str);\n\ttabexp.tails = array.ptrs;\n\ttabexp.count = array.count;\n}\n\nstatic void expand_options(const char *str)\n{\n\tstruct cmus_opt *opt;\n\tint len;\n\tchar **tails, *sep;\n\n\t/* tabexp is resetted */\n\tlen = strlen(str);\n\tsep = strchr(str, '=');\n\tif (len > 1 && sep) {\n\t\t/* expand value */\n\t\tchar *var = xstrndup(str, sep - str);\n\n\t\tlist_for_each_entry(opt, &option_head, node) {\n\t\t\tif (strcmp(var, opt->name) == 0) {\n\t\t\t\tif (str[len - 1] == '=') {\n\t\t\t\t\tchar buf[OPTION_MAX_SIZE];\n\n\t\t\t\t\ttails = xnew(char *, 1);\n\n\t\t\t\t\tbuf[0] = 0;\n\t\t\t\t\topt->get(opt->data, buf, OPTION_MAX_SIZE);\n\t\t\t\t\ttails[0] = xstrdup(buf);\n\n\t\t\t\t\ttabexp.head = xstrdup(str);\n\t\t\t\t\ttabexp.tails = tails;\n\t\t\t\t\ttabexp.count = 1;\n\t\t\t\t} else if (opt->flags & OPT_PROGRAM_PATH) {\n\t\t\t\t\texpand_program_paths_option(sep + 1, var);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfree(var);\n\t} else {\n\t\t/* expand variable */\n\t\tint pos;\n\n\t\ttails = xnew(char *, nr_options);\n\t\tpos = 0;\n\t\tlist_for_each_entry(opt, &option_head, node) {\n\t\t\tif (strncmp(str, opt->name, len) == 0)\n\t\t\t\ttails[pos++] = xstrdup(opt->name + len);\n\t\t}\n\t\tif (pos > 0) {\n\t\t\tif (pos == 1) {\n\t\t\t\t/* only one variable matches, add '=' */\n\t\t\t\tchar *tmp = xstrjoin(tails[0], \"=\");\n\n\t\t\t\tfree(tails[0]);\n\t\t\t\ttails[0] = tmp;\n\t\t\t}\n\n\t\t\ttabexp.head = xstrdup(str);\n\t\t\ttabexp.tails = tails;\n\t\t\ttabexp.count = pos;\n\t\t} else {\n\t\t\tfree(tails);\n\t\t}\n\t}\n}\n\nstatic void expand_toptions(const char *str)\n{\n\tstruct cmus_opt *opt;\n\tint len, pos;\n\tchar **tails;\n\n\ttails = xnew(char *, nr_options);\n\tlen = strlen(str);\n\tpos = 0;\n\tlist_for_each_entry(opt, &option_head, node) {\n\t\tif (opt->toggle == NULL)\n\t\t\tcontinue;\n\t\tif (strncmp(str, opt->name, len) == 0)\n\t\t\ttails[pos++] = xstrdup(opt->name + len);\n\t}\n\tif (pos > 0) {\n\t\ttabexp.head = xstrdup(str);\n\t\ttabexp.tails = tails;\n\t\ttabexp.count = pos;\n\t} else {\n\t\tfree(tails);\n\t}\n}\n\nstatic void load_themes(const char *dirname, const char *str, struct ptr_array *array)\n{\n\tstruct directory dir;\n\tconst char *name, *dot;\n\tint len = strlen(str);\n\n\tif (dir_open(&dir, dirname))\n\t\treturn;\n\n\twhile ((name = dir_read(&dir))) {\n\t\tif (!S_ISREG(dir.st.st_mode))\n\t\t\tcontinue;\n\t\tif (strncmp(name, str, len))\n\t\t\tcontinue;\n\t\tdot = strrchr(name, '.');\n\t\tif (dot == NULL || strcmp(dot, \".theme\"))\n\t\t\tcontinue;\n\t\tif (dot - name < len)\n\t\t\t/* str is  \"foo.th\"\n\t\t\t * matches \"foo.theme\"\n\t\t\t * which also ends with \".theme\"\n\t\t\t */\n\t\t\tcontinue;\n\t\tptr_array_add(array, xstrndup(name + len, dot - name - len));\n\t}\n\tdir_close(&dir);\n}\n\nstatic void expand_colorscheme(const char *str)\n{\n\tPTR_ARRAY(array);\n\n\tload_themes(cmus_config_dir, str, &array);\n\tload_themes(cmus_data_dir, str, &array);\n\n\tif (array.count) {\n\t\tptr_array_sort(&array, strptrcmp);\n\n\t\ttabexp.head = xstrdup(str);\n\t\ttabexp.tails = array.ptrs;\n\t\ttabexp.count = array.count;\n\t}\n}\n\nstatic void expand_commands(const char *str);\n\n/* tab exp }}} */\n\n/* sort by name */\nstruct command commands[] = {\n\t{ \"add\",                   cmd_add,              1, 1,  expand_add,           0, 0          },\n\t{ \"bind\",                  cmd_bind,             1, 1,  expand_bind_args,     0, CMD_UNSAFE },\n\t{ \"browser-up\",            cmd_browser_up,       0, 0,  NULL,                 0, 0          },\n\t{ \"cd\",                    cmd_cd,               0, 1,  expand_directories,   0, 0          },\n\t{ \"clear\",                 cmd_clear,            0, 1,  NULL,                 0, 0          },\n\t{ \"colorscheme\",           cmd_colorscheme,      1, 1,  expand_colorscheme,   0, 0          },\n\t{ \"echo\",                  cmd_echo,             1, -1, NULL,                 0, 0          },\n\t{ \"factivate\",             cmd_factivate,        0, 1,  expand_factivate,     0, 0          },\n\t{ \"filter\",                cmd_filter,           0, 1,  NULL,                 0, 0          },\n\t{ \"fset\",                  cmd_fset,             1, 1,  expand_fset,          0, 0          },\n\t{ \"help\",                  cmd_help,             0, 0,  NULL,                 0, 0          },\n\t{ \"invert\",                cmd_invert,           0, 0,  NULL,                 0, 0          },\n\t{ \"live-filter\",           cmd_live_filter,      0, 1,  NULL,                 0, CMD_LIVE   },\n\t{ \"load\",                  cmd_load,             1, 1,  expand_load_save,     0, 0          },\n\t{ \"lqueue\",                cmd_lqueue,           0, 1,  NULL,                 0, 0          },\n\t{ \"mark\",                  cmd_mark,             0, 1,  NULL,                 0, 0          },\n\t{ \"mute\",                  cmd_mute,             0, 0,  NULL,                 0, 0          },\n\t{ \"player-next\",           cmd_p_next,           0, 0,  NULL,                 0, 0          },\n\t{ \"player-next-album\",     cmd_p_next_album,     0, 0,  NULL,                 0, 0          },\n\t{ \"player-pause\",          cmd_p_pause,          0, 0,  NULL,                 0, 0          },\n\t{ \"player-pause-playback\", cmd_p_pause_playback, 0, 0,  NULL,                 0, 0          },\n\t{ \"player-play\",           cmd_p_play,           0, 1,  expand_playable,      0, 0          },\n\t{ \"player-prev\",           cmd_p_prev,           0, 0,  NULL,                 0, 0          },\n\t{ \"player-prev-album\",     cmd_p_prev_album,     0, 0,  NULL,                 0, 0          },\n\t{ \"player-stop\",           cmd_p_stop,           0, 0,  NULL,                 0, 0          },\n\t{ \"prev-view\",             cmd_prev_view,        0, 0,  NULL,                 0, 0          },\n\t{ \"left-view\",             cmd_left_view,        0, 1,  NULL,                 0, 0          },\n\t{ \"right-view\",            cmd_right_view,       0, 1,  NULL,                 0, 0          },\n\t{ \"pl-create\",             cmd_pl_create,        1, -1, NULL,                 0, 0          },\n\t{ \"pl-export\",             cmd_pl_export,        1, -1, NULL,                 0, 0          },\n\t{ \"pl-import\",             cmd_pl_import,        0, -1, NULL,                 0, 0          },\n\t{ \"pl-rename\",             cmd_pl_rename,        1, -1, NULL,                 0, 0          },\n\t{ \"pl-delete\",             cmd_pl_delete,        1, 1,  NULL,                 0, 0          },\n\t{ \"push\",                  cmd_push,             0, -1, expand_commands,      0, 0          },\n\t{ \"pwd\",                   cmd_pwd,              0, 0,  NULL,                 0, 0          },\n\t{ \"raise-vte\",             cmd_raise_vte,        0, 0,  NULL,                 0, 0          },\n\t{ \"rand\",                  cmd_rand,             0, 0,  NULL,                 0, 0          },\n\t{ \"quit\",                  cmd_quit,             0, 1,  NULL,                 0, 0          },\n\t{ \"refresh\",               cmd_refresh,          0, 0,  NULL,                 0, 0          },\n\t{ \"reshuffle\",             cmd_reshuffle,        0, 0,  NULL,                 0, 0          },\n\t{ \"run\",                   cmd_run,              1, -1, expand_program_paths, 0, CMD_UNSAFE },\n\t{ \"save\",                  cmd_save,             0, 1,  expand_load_save,     0, CMD_UNSAFE },\n\t{ \"search-b-start\",        cmd_search_b_start,   0, 0,  NULL,                 0, 0          },\n\t{ \"search-next\",           cmd_search_next,      0, 0,  NULL,                 0, 0          },\n\t{ \"search-prev\",           cmd_search_prev,      0, 0,  NULL,                 0, 0          },\n\t{ \"search-start\",          cmd_search_start,     0, 0,  NULL,                 0, 0          },\n\t{ \"seek\",                  cmd_seek,             1, 1,  NULL,                 0, 0          },\n\t{ \"set\",                   cmd_set,              1, 1,  expand_options,       0, 0          },\n\t{ \"shell\",                 cmd_shell,            1, -1, expand_program_paths, 0, CMD_UNSAFE },\n\t{ \"showbind\",              cmd_showbind,         1, 1,  expand_unbind_args,   0, 0          },\n\t{ \"shuffle\",               cmd_reshuffle,        0, 0,  NULL,                 0, CMD_HIDDEN },\n\t{ \"source\",                cmd_source,           1, 1,  expand_files,         0, CMD_UNSAFE },\n\t{ \"toggle\",                cmd_toggle,           1, 1,  expand_toptions,      0, 0          },\n\t{ \"tqueue\",                cmd_tqueue,           0, 1,  NULL,                 0, 0          },\n\t{ \"unbind\",                cmd_unbind,           1, 1,  expand_unbind_args,   0, 0          },\n\t{ \"unmark\",                cmd_unmark,           0, 0,  NULL,                 0, 0          },\n\t{ \"update-cache\",          cmd_update_cache,     0, 1,  NULL,                 0, 0          },\n\t{ \"version\",               cmd_version,          0, 0,  NULL,                 0, 0          },\n\t{ \"view\",                  cmd_view,             1, 1,  NULL,                 0, 0          },\n\t{ \"vol\",                   cmd_vol,              1, 2,  NULL,                 0, 0          },\n\t{ \"w\",                     cmd_save,             0, 1,  expand_load_save,     0, CMD_UNSAFE },\n\t{ \"win-activate\",          cmd_win_activate,     0, 0,  NULL,                 0, 0          },\n\t{ \"win-add-l\",             cmd_win_add_l,        0, 1,  NULL,                 0, 0          },\n\t{ \"win-add-p\",             cmd_win_add_p,        0, 1,  NULL,                 0, 0          },\n\t{ \"win-add-Q\",             cmd_win_add_Q,        0, 1,  NULL,                 0, 0          },\n\t{ \"win-add-q\",             cmd_win_add_q,        0, 1,  NULL,                 0, 0          },\n\t{ \"win-bottom\",            cmd_win_bottom,       0, 0,  NULL,                 0, 0          },\n\t{ \"win-down\",              cmd_win_down,         0, 1,  NULL,                 0, 0          },\n\t{ \"win-half-page-down\",    cmd_win_hf_pg_down,   0, 0,  NULL,                 0, 0          },\n\t{ \"win-half-page-up\",      cmd_win_hf_pg_up,     0, 0,  NULL,                 0, 0          },\n\t{ \"win-mv-after\",          cmd_win_mv_after,     0, 0,  NULL,                 0, 0          },\n\t{ \"win-mv-before\",         cmd_win_mv_before,    0, 0,  NULL,                 0, 0          },\n\t{ \"win-next\",              cmd_win_next,         0, 0,  NULL,                 0, 0          },\n\t{ \"win-page-bottom\",       cmd_win_pg_bottom,    0, 0,  NULL,                 0, 0          },\n\t{ \"win-page-down\",         cmd_win_pg_down,      0, 0,  NULL,                 0, 0          },\n\t{ \"win-page-middle\",       cmd_win_pg_middle,    0, 0,  NULL,                 0, 0          },\n\t{ \"win-page-top\",          cmd_win_pg_top,       0, 0,  NULL,                 0, 0          },\n\t{ \"win-page-up\",           cmd_win_pg_up,        0, 0,  NULL,                 0, 0          },\n\t{ \"win-remove\",            cmd_win_remove,       0, 0,  NULL,                 0, CMD_UNSAFE },\n\t{ \"win-scroll-down\",       cmd_win_scroll_down,  0, 0,  NULL,                 0, 0          },\n\t{ \"win-scroll-up\",         cmd_win_scroll_up,    0, 0,  NULL,                 0, 0          },\n\t{ \"win-sel-cur\",           cmd_win_sel_cur,      0, 0,  NULL,                 0, 0          },\n\t{ \"win-toggle\",            cmd_win_toggle,       0, 0,  NULL,                 0, 0          },\n\t{ \"win-top\",               cmd_win_top,          0, 0,  NULL,                 0, 0          },\n\t{ \"win-up\",                cmd_win_up,           0, 1,  NULL,                 0, 0          },\n\t{ \"win-update\",            cmd_win_update,       0, 0,  NULL,                 0, 0          },\n\t{ \"win-update-cache\",      cmd_win_update_cache, 0, 1,  NULL,                 0, 0          },\n\t{ \"wq\",                    cmd_quit,             0, 1,  NULL,                 0, 0          },\n\t{ NULL,                    NULL,                 0, 0,  0,                    0, 0          }\n};\n\n/* fills tabexp struct */\nstatic void expand_commands(const char *str)\n{\n\tint i, len, pos;\n\tchar **tails;\n\n\t/* tabexp is resetted */\n\ttails = xnew(char *, N_ELEMENTS(commands) - 1);\n\tlen = strlen(str);\n\tpos = 0;\n\tfor (i = 0; commands[i].name; i++) {\n\t\tif (strncmp(str, commands[i].name, len) == 0 && !(commands[i].flags & CMD_HIDDEN))\n\t\t\ttails[pos++] = xstrdup(commands[i].name + len);\n\t}\n\tif (pos > 0) {\n\t\tif (pos == 1) {\n\t\t\t/* only one command matches, add ' ' */\n\t\t\tchar *tmp = xstrjoin(tails[0], \" \");\n\n\t\t\tfree(tails[0]);\n\t\t\ttails[0] = tmp;\n\t\t}\n\t\ttabexp.head = xstrdup(str);\n\t\ttabexp.tails = tails;\n\t\ttabexp.count = pos;\n\t} else {\n\t\tfree(tails);\n\t}\n}\n\nstruct command *get_command(const char *str)\n{\n\tint i, len;\n\n\twhile (*str == ' ')\n\t\tstr++;\n\tfor (len = 0; str[len] && str[len] != ' '; len++)\n\t\t;\n\n\tfor (i = 0; commands[i].name; i++) {\n\t\tif (strncmp(str, commands[i].name, len))\n\t\t\tcontinue;\n\n\t\tif (commands[i].name[len] == 0) {\n\t\t\t/* exact */\n\t\t\treturn &commands[i];\n\t\t}\n\n\t\tif (commands[i + 1].name && strncmp(str, commands[i + 1].name, len) == 0) {\n\t\t\t/* ambiguous */\n\t\t\treturn NULL;\n\t\t}\n\t\treturn &commands[i];\n\t}\n\treturn NULL;\n}\n\n/* fills tabexp struct */\nstatic void expand_command_line(const char *str)\n{\n\t/* :command [arg]...\n\t *\n\t * examples:\n\t *\n\t * str      expanded value (tabexp.head)\n\t * -------------------------------------\n\t *   fs     fset\n\t *   b c    bind common\n\t *   se     se          (tabexp.tails = [ ek t ])\n\t */\n\t/* command start/end, argument start */\n\tconst char *cs, *ce, *as;\n\tconst struct command *cmd;\n\n\tcs = str;\n\tce = strchr(cs, ' ');\n\tif (ce == NULL) {\n\t\t/* expand command */\n\t\texpand_commands(cs);\n\t\treturn;\n\t}\n\n\t/* command must be expandable */\n\tcmd = get_command(cs);\n\tif (cmd == NULL) {\n\t\t/* command ambiguous or invalid */\n\t\treturn;\n\t}\n\n\tif (cmd->expand == NULL) {\n\t\t/* can't expand argument */\n\t\treturn;\n\t}\n\n\tas = ce;\n\twhile (*as == ' ')\n\t\tas++;\n\n\t/* expand argument */\n\tcmd->expand(as);\n\tif (tabexp.head == NULL) {\n\t\t/* argument expansion failed */\n\t\treturn;\n\t}\n\n\t/* tabexp.head is now start of the argument string */\n\tsnprintf(expbuf, sizeof(expbuf), \"%s %s\", cmd->name, tabexp.head);\n\tfree(tabexp.head);\n\ttabexp.head = xstrdup(expbuf);\n}\n\nstatic void tab_expand(int direction)\n{\n\tchar *s1, *s2, *tmp;\n\tint pos;\n\n\t/* strip white space */\n\tpos = 0;\n\twhile (cmdline.line[pos] == ' ' && pos < cmdline.bpos)\n\t\tpos++;\n\n\t/* string to expand */\n\ts1 = xstrndup(cmdline.line + pos, cmdline.bpos - pos);\n\n\t/* tail */\n\ts2 = xstrdup(cmdline.line + cmdline.bpos);\n\n\ttmp = tabexp_expand(s1, expand_command_line, direction);\n\tif (tmp) {\n\t\t/* tmp.s2 */\n\t\tint l1, l2;\n\n\t\tl1 = strlen(tmp);\n\t\tl2 = strlen(s2);\n\t\tcmdline.blen = l1 + l2;\n\t\tif (cmdline.blen >= cmdline.size) {\n\t\t\twhile (cmdline.blen >= cmdline.size)\n\t\t\t\tcmdline.size *= 2;\n\t\t\tcmdline.line = xrenew(char, cmdline.line, cmdline.size);\n\t\t}\n\t\tsprintf(cmdline.line, \"%s%s\", tmp, s2);\n\t\tcmdline.bpos = l1;\n\t\tcmdline.cpos = u_strlen_safe(tmp);\n\t\tcmdline.clen = u_strlen_safe(cmdline.line);\n\t\tfree(tmp);\n\t}\n\tfree(s1);\n\tfree(s2);\n}\n\nstatic void reset_tab_expansion(void)\n{\n\ttabexp_reset();\n\targ_expand_cmd = -1;\n}\n\nstatic void cmdline_modified(void)\n{\n\tchar *cmd, *arg;\n\tstruct command *c;\n\n\tif (!parse_command(cmdline.line, &cmd, &arg))\n\t\treturn;\n\n\tc = get_command(cmd);\n\tif (!c)\n\t\tgoto end;\n\n\tif (c->flags & CMD_LIVE)\n\t\trun_parsed_command(cmd, arg);\n\nend:\n\tfree(cmd);\n\tfree(arg);\n}\n\nint parse_command(const char *buf, char **cmdp, char **argp)\n{\n\tint cmd_start, cmd_end, cmd_len;\n\tint arg_start, arg_end;\n\tint i;\n\n\ti = 0;\n\twhile (buf[i] && buf[i] == ' ')\n\t\ti++;\n\n\tif (buf[i] == '#')\n\t\treturn 0;\n\n\tcmd_start = i;\n\twhile (buf[i] && buf[i] != ' ')\n\t\ti++;\n\tcmd_end = i;\n\twhile (buf[i] && buf[i] == ' ')\n\t\ti++;\n\targ_start = i;\n\twhile (buf[i])\n\t\ti++;\n\targ_end = i;\n\n\tcmd_len = cmd_end - cmd_start;\n\tif (cmd_len == 0)\n\t\treturn 0;\n\n\t*cmdp = xstrndup(buf + cmd_start, cmd_len);\n\tif (arg_start == arg_end) {\n\t\t*argp = NULL;\n\t} else {\n\t\t*argp = xstrndup(buf + arg_start, arg_end - arg_start);\n\t}\n\treturn 1;\n}\n\nint run_only_safe_commands;\n\nvoid run_parsed_command(char *cmd, char *arg)\n{\n\tint cmd_len = strlen(cmd);\n\tint i = 0;\n\n\twhile (1) {\n\t\tconst struct command *c = &commands[i];\n\n\t\tif (c->name == NULL) {\n\t\t\terror_msg(\"unknown command\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (strncmp(cmd, c->name, cmd_len) == 0) {\n\t\t\tconst char *next = commands[i + 1].name;\n\t\t\tint exact = c->name[cmd_len] == 0;\n\n\t\t\tif (!exact && next && strncmp(cmd, next, cmd_len) == 0) {\n\t\t\t\terror_msg(\"ambiguous command\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (c->min_args > 0 && arg == NULL) {\n\t\t\t\terror_msg(\"not enough arguments\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (c->max_args == 0 && arg) {\n\t\t\t\terror_msg(\"too many arguments\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (run_only_safe_commands && (c->flags & CMD_UNSAFE)) {\n\t\t\t\tif (c->func != cmd_save || !is_stdout_filename(arg)) {\n\t\t\t\t\td_print(\"trying to execute unsafe command over net\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tc->func(arg);\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n}\n\nvoid run_command(const char *buf)\n{\n\tchar *cmd, *arg;\n\n\tif (!parse_command(buf, &cmd, &arg))\n\t\treturn;\n\n\trun_parsed_command(cmd, arg);\n\tfree(arg);\n\tfree(cmd);\n}\n\nstatic void reset_history_search(void)\n{\n\thistory_reset_search(&cmd_history);\n\tfree(history_search_text);\n\thistory_search_text = NULL;\n}\n\nstatic void backspace(void)\n{\n\tif (cmdline.clen > 0) {\n\t\tcmdline_backspace();\n\t} else {\n\t\tinput_mode = NORMAL_MODE;\n\t}\n}\n\nvoid command_mode_ch(uchar ch)\n{\n\tswitch (ch) {\n\tcase 0x01: // ^A\n\t\tcmdline_move_home();\n\t\tbreak;\n\tcase 0x02: // ^B\n\t\tcmdline_move_left();\n\t\tbreak;\n\tcase 0x04: // ^D\n\t\tcmdline_delete_ch();\n\t\tcmdline_modified();\n\t\tbreak;\n\tcase 0x05: // ^E\n\t\tcmdline_move_end();\n\t\tbreak;\n\tcase 0x06: // ^F\n\t\tcmdline_move_right();\n\t\tbreak;\n\tcase 0x03: // ^C\n\tcase 0x07: // ^G\n\tcase 0x1B: // ESC\n\t\tif (cmdline.blen) {\n\t\t\thistory_add_line(&cmd_history, cmdline.line);\n\t\t\tcmdline_clear();\n\t\t}\n\t\tinput_mode = NORMAL_MODE;\n\t\tbreak;\n\tcase 0x10: // ^P\n\t\tcommand_mode_key(KEY_UP);\n\t\treturn;\n\tcase 0xE: // ^N\n\t\tcommand_mode_key(KEY_DOWN);\n\t\treturn;\n\tcase 0x0A:\n\t\tif (cmdline.blen) {\n\t\t\trun_command(cmdline.line);\n\t\t\thistory_add_line(&cmd_history, cmdline.line);\n\t\t\tcmdline_clear();\n\t\t}\n\t\tinput_mode = NORMAL_MODE;\n\t\tbreak;\n\tcase 0x0B:\n\t\tcmdline_clear_end();\n\t\tcmdline_modified();\n\t\tbreak;\n\tcase 0x09:\n\t\ttab_expand(1);\n\t\tbreak;\n\tcase 0x15:\n\t\tcmdline_backspace_to_bol();\n\t\tcmdline_modified();\n\t\tbreak;\n\tcase 0x17: // ^W\n\t\tcmdline_backward_delete_word(cmdline_word_delimiters);\n\t\tcmdline_modified();\n\t\tbreak;\n\tcase 0x08: // ^H\n\tcase 127:\n\t\tbackspace();\n\t\tcmdline_modified();\n\t\tbreak;\n\tdefault:\n\t\tcmdline_insert_ch(ch);\n\t\tcmdline_modified();\n\t}\n\treset_history_search();\n\tif (ch != 0x09)\n\t\treset_tab_expansion();\n}\n\nvoid command_mode_escape(int c)\n{\n\tswitch (c) {\n\tcase 98:\n\t\tcmdline_backward_word(cmdline_filename_delimiters);\n\t\tbreak;\n\tcase 100:\n\t\tcmdline_delete_word(cmdline_filename_delimiters);\n\t\tcmdline_modified();\n\t\tbreak;\n\tcase 102:\n\t\tcmdline_forward_word(cmdline_filename_delimiters);\n\t\tbreak;\n\tcase 127:\n\tcase KEY_BACKSPACE:\n\t\tcmdline_backward_delete_word(cmdline_filename_delimiters);\n\t\tcmdline_modified();\n\t\tbreak;\n\t}\n\treset_history_search();\n}\n\nvoid command_mode_key(int key)\n{\n\tif (key != KEY_BTAB)\n\t\treset_tab_expansion();\n\tswitch (key) {\n\tcase KEY_DC:\n\t\tcmdline_delete_ch();\n\t\tcmdline_modified();\n\t\tbreak;\n\tcase KEY_BACKSPACE:\n\t\tbackspace();\n\t\tcmdline_modified();\n\t\tbreak;\n\tcase KEY_LEFT:\n\t\tcmdline_move_left();\n\t\treturn;\n\tcase KEY_RIGHT:\n\t\tcmdline_move_right();\n\t\treturn;\n\tcase KEY_HOME:\n\t\tcmdline_move_home();\n\t\treturn;\n\tcase KEY_END:\n\t\tcmdline_move_end();\n\t\treturn;\n\tcase KEY_UP:\n\t\t{\n\t\t\tconst char *s;\n\n\t\t\tif (history_search_text == NULL)\n\t\t\t\thistory_search_text = xstrdup(cmdline.line);\n\t\t\ts = history_search_forward(&cmd_history, history_search_text);\n\t\t\tif (s)\n\t\t\t\tcmdline_set_text(s);\n\t\t}\n\t\treturn;\n\tcase KEY_DOWN:\n\t\tif (history_search_text) {\n\t\t\tconst char *s;\n\n\t\t\ts = history_search_backward(&cmd_history, history_search_text);\n\t\t\tif (s) {\n\t\t\t\tcmdline_set_text(s);\n\t\t\t} else {\n\t\t\t\tcmdline_set_text(history_search_text);\n\t\t\t}\n\t\t}\n\t\treturn;\n\tcase KEY_BTAB:\n\t\ttab_expand(-1);\n\t\tbreak;\n\tdefault:\n\t\td_print(\"key = %c (%d)\\n\", key, key);\n\t}\n\treset_history_search();\n}\n\nvoid command_mode_mouse(MEVENT *event)\n{\n\tif ((event->bstate & BUTTON1_PRESSED) || (event->bstate & BUTTON3_PRESSED)) {\n\t\tif (event->y <= window_get_nr_rows(current_win()) + 2) {\n\t\t\tif (cmdline.blen) {\n\t\t\t\thistory_add_line(&cmd_history, cmdline.line);\n\t\t\t\tcmdline_clear();\n\t\t\t}\n\t\t\tinput_mode = NORMAL_MODE;\n\t\t\tnormal_mode_mouse(event);\n\t\t\treturn;\n\t\t}\n\t\tif (event->x == 0)\n\t\t\treturn;\n\t\tint i = event->x > cmdline.clen ? cmdline.clen : event->x - 1;\n\t\twhile (i < cmdline.cpos)\n\t\t\tcmdline_move_left();\n\t\twhile (i > cmdline.cpos)\n\t\t\tcmdline_move_right();\n\t} else if (event->bstate & BUTTON4_PRESSED) {\n\t\tcommand_mode_key(KEY_UP);\n\t} else if (event->bstate & BUTTON5_PRESSED) {\n\t\tcommand_mode_key(KEY_DOWN);\n\t}\n}\n\nvoid commands_init(void)\n{\n\tcmd_history_filename = xstrjoin(cmus_config_dir, \"/command-history\");\n\thistory_load(&cmd_history, cmd_history_filename, 2000);\n}\n\nvoid commands_exit(void)\n{\n\tview_clear(TREE_VIEW);\n\tview_clear(SORTED_VIEW);\n\tview_clear(PLAYLIST_VIEW);\n\tview_clear(QUEUE_VIEW);\n\thistory_save(&cmd_history);\n\thistory_free(&cmd_history);\n\tfree(cmd_history_filename);\n\ttabexp_reset();\n}\n"
        },
        {
          "name": "command_mode.h",
          "type": "blob",
          "size": 2.078125,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004-2006 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_COMMAND_MODE_H\n#define CMUS_COMMAND_MODE_H\n\n#include \"uchar.h\"\n\n#if defined(__sun__)\n#include <ncurses.h>\n#else\n#include <curses.h>\n#endif\n\nenum {\n\t/* executing command is disabled over net */\n\tCMD_UNSAFE\t= 1 << 0,\n\t/* execute command after every typed/deleted character */\n\tCMD_LIVE\t= 1 << 1,\n\t/* hide command from completion, useful for deprecated commands */\n\tCMD_HIDDEN\t= 1 << 2,\n};\n\nstruct command {\n\tconst char *name;\n\tvoid (*func)(char *arg);\n\n\t/* min/max number of arguments */\n\tint min_args;\n\tint max_args;\n\n\tvoid (*expand)(const char *str);\n\n\t/* bind count (0 means: unbound) */\n\tint bc;\n\n\t/* CMD_* */\n\tunsigned int flags;\n};\n\nextern struct command commands[];\nextern int run_only_safe_commands;\n\nvoid command_mode_ch(uchar ch);\nvoid command_mode_escape(int c);\nvoid command_mode_key(int key);\nvoid command_mode_mouse(MEVENT *event);\nvoid commands_init(void);\nvoid commands_exit(void);\nint parse_command(const char *buf, char **cmdp, char **argp);\nchar **parse_cmd(const char *cmd, int *args_idx, int *ac);\nvoid run_parsed_command(char *cmd, char *arg);\nvoid run_command(const char *buf);\n\nstruct command *get_command(const char *str);\n\nvoid view_clear(int view);\nvoid view_add(int view, char *arg, int prepend);\nvoid view_load(int view, char *arg);\nvoid view_save(int view, char *arg, int to_stdout, int filtered, int extended);\n\nstruct window *current_win(void);\n\n#endif\n"
        },
        {
          "name": "comment.c",
          "type": "blob",
          "size": 6.751953125,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004-2007 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"comment.h\"\n#include \"xmalloc.h\"\n#include \"utils.h\"\n#include \"uchar.h\"\n\n#include <string.h>\n#include <strings.h>\n\nstatic int is_various_artists(const char *a)\n{\n\treturn strcasecmp(a, \"Various Artists\") == 0 ||\n\t       strcasecmp(a, \"Various\")         == 0 ||\n\t       strcasecmp(a, \"VA\")              == 0 ||\n\t       strcasecmp(a, \"V/A\")             == 0;\n}\n\nint track_is_compilation(const struct keyval *comments)\n{\n\tconst char *c, *a, *aa;\n\n\tc = keyvals_get_val(comments, \"compilation\");\n\tif (c && is_freeform_true(c))\n\t\treturn 1;\n\n\tc = keyvals_get_val(comments, \"partofacompilation\");\n\tif (c && is_freeform_true(c))\n\t\treturn 1;\n\n\taa = keyvals_get_val(comments, \"albumartist\");\n\tif (aa && is_various_artists(aa))\n\t\treturn 1;\n\n\ta = keyvals_get_val(comments, \"artist\");\n\tif (a && is_various_artists(a))\n\t\treturn 1;\n\n\tif (aa && a && !u_strcase_equal(aa, a))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nint track_is_va_compilation(const struct keyval *comments)\n{\n\tconst char *c, *a, *aa;\n\n\taa = keyvals_get_val(comments, \"albumartist\");\n\tif (aa)\n\t\treturn is_various_artists(aa);\n\n\ta = keyvals_get_val(comments, \"artist\");\n\tif (a && is_various_artists(a))\n\t\treturn 1;\n\n\tc = keyvals_get_val(comments, \"compilation\");\n\tif (c && is_freeform_true(c))\n\t\treturn 1;\n\n\tc = keyvals_get_val(comments, \"partofacompilation\");\n\tif (c && is_freeform_true(c))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nconst char *comments_get_albumartist(const struct keyval *comments)\n{\n\tconst char *val = keyvals_get_val(comments, \"albumartist\");\n\n\tif (!val || strcmp(val, \"\") == 0)\n\t\tval = keyvals_get_val(comments, \"artist\");\n\n\treturn val;\n}\n\nconst char *comments_get_artistsort(const struct keyval *comments)\n{\n\tconst char *val;\n\n\tif (track_is_va_compilation(comments))\n\t\treturn NULL;\n\n\tval = keyvals_get_val(comments, \"albumartistsort\");\n\tif (!track_is_compilation(comments)) {\n\t\tif (!val || strcmp(val, \"\") == 0)\n\t\t\tval = keyvals_get_val(comments, \"artistsort\");\n\t}\n\n\tif (!val || strcmp(val, \"\") == 0)\n\t\treturn NULL;\n\n\treturn val;\n}\n\nint comments_get_int(const struct keyval *comments, const char *key)\n{\n\tconst char *val;\n\tlong int ival;\n\n\tval = keyvals_get_val(comments, key);\n\tif (val == NULL)\n\t\treturn -1;\n\twhile (*val && !(*val >= '0' && *val <= '9'))\n\t\tval++;\n\tif (str_to_int(val, &ival) == -1)\n\t\treturn -1;\n\treturn ival;\n}\n\nint comments_get_signed_int(const struct keyval *comments, const char *key, long int *ival)\n{\n\tconst char *val;\n\n\tval = keyvals_get_val(comments, key);\n\tif (val == NULL)\n\t\treturn -1;\n\twhile (*val && !(*val == '+' || *val == '-' || (*val >= '0' && *val <= '9')))\n\t\tval++;\n\treturn str_to_int(val, ival);\n}\n\ndouble comments_get_double(const struct keyval *comments, const char *key)\n{\n\tconst char *val;\n\tchar *end;\n\tdouble d;\n\n\tval = keyvals_get_val(comments, key);\n\tif (!val || strcmp(val, \"\") == 0)\n\t\tgoto error;\n\n\td = strtod(val, &end);\n\tif (val == end)\n\t\tgoto error;\n\n\treturn d;\n\nerror:\n\treturn strtod(\"NAN\", NULL);\n}\n\n/* Return date as an integer in the form YYYYMMDD, for sorting purposes.\n * This function is not year 10000 compliant. */\nint comments_get_date(const struct keyval *comments, const char *key)\n{\n\tconst char *val;\n\tchar *endptr;\n\tint year, month, day;\n\tlong int ival;\n\n\tval = keyvals_get_val(comments, key);\n\tif (val == NULL)\n\t\treturn -1;\n\n\tyear = strtol(val, &endptr, 10);\n\t/* Looking for a four-digit number */\n\tif (year < 1000 || year > 9999)\n\t\treturn -1;\n\tival = year * 10000;\n\n\tif (*endptr == '-' || *endptr == ' ' || *endptr == '/') {\n\t\tmonth = strtol(endptr+1, &endptr, 10);\n\t\tif (month < 1 || month > 12)\n\t\t\treturn ival;\n\t\tival += month * 100;\n\t}\n\n\tif (*endptr == '-' || *endptr == ' ' || *endptr == '/') {\n\t\tday = strtol(endptr+1, &endptr, 10);\n\t\tif (day < 1 || day > 31)\n\t\t\treturn ival;\n\t\tival += day;\n\t}\n\n\n\treturn ival;\n}\n\nstatic const char *interesting[] = {\n\t\"artist\", \"album\", \"title\", \"tracknumber\", \"discnumber\", \"totaldiscs\", \"genre\",\n\t\"date\", \"compilation\", \"partofacompilation\", \"albumartist\", \"artistsort\", \"albumartistsort\",\n\t\"albumsort\",\n\t\"originaldate\",\n\t\"r128_track_gain\",\n\t\"r128_album_gain\",\n\t\"replaygain_track_gain\",\n\t\"replaygain_track_peak\",\n\t\"replaygain_album_gain\",\n\t\"replaygain_album_peak\",\n\t\"musicbrainz_trackid\",\n\t\"comment\",\n\t\"bpm\",\n\t\"arranger\", \"composer\", \"conductor\", \"lyricist\", \"performer\",\n\t\"remixer\", \"label\", \"publisher\", \"work\", \"opus\",\n\t\"subtitle\", \"media\",\n\tNULL\n};\n\nstatic struct {\n\tconst char *old;\n\tconst char *new;\n} key_map[] = {\n\t{ \"album_artist\", \"albumartist\" },\n\t{ \"album artist\", \"albumartist\" },\n\t{ \"disc\", \"discnumber\" },\n\t{ \"part\", \"discnumber\" },\n\t{ \"partnumber\", \"discnumber\" },\n\t{ \"disctotal\", \"totaldiscs\" },\n\t{ \"tempo\", \"bpm\" },\n\t{ \"track\", \"tracknumber\" },\n\t{ \"WM/Year\", \"date\" },\n\t{ \"WM/ArtistSortOrder\", \"artistsort\" },\n\t{ \"WM/AlbumArtistSortOrder\", \"albumartistsort\" },\n\t{ \"WM/AlbumSortOrder\", \"albumsort\" },\n\t{ \"WM/OriginalReleaseYear\", \"originaldate\" },\n\t{ \"WM/Media\", \"media\" },\n\t{ \"sourcemedia\", \"media\" },\n\t{ \"MusicBrainz Track Id\", \"musicbrainz_trackid\" },\n\t{ \"version\", \"subtitle\" },\n\t/* ffmpeg id3 */\n\t{ \"artist-sort\", \"artistsort\" },\n\t{ \"TSO2\", \"albumartistsort\" },\n\t{ \"album-sort\", \"albumsort\" },\n\t/* ffmpeg mp4 */\n\t{ \"sort_artist\", \"artistsort\" },\n\t{ \"sort_album_artist\", \"albumartistsort\" },\n\t{ \"sort_album\", \"albumsort\" },\n\t{ NULL, NULL }\n};\n\nstatic const char *fix_key(const char *key)\n{\n\tint i;\n\n\tfor (i = 0; interesting[i]; i++) {\n\t\tif (!strcasecmp(key, interesting[i]))\n\t\t\treturn interesting[i];\n\t}\n\tfor (i = 0; key_map[i].old; i++) {\n\t\tif (!strcasecmp(key, key_map[i].old))\n\t\t\treturn key_map[i].new;\n\t}\n\treturn NULL;\n}\n\nint comments_add(struct growing_keyvals *c, const char *key, char *val)\n{\n\tif (!strcasecmp(key, \"songwriter\")) {\n\t\tint r = comments_add_const(c, \"lyricist\", val);\n\t\treturn comments_add(c, \"composer\", val) && r;\n\t}\n\n\tkey = fix_key(key);\n\tif (!key) {\n\t\tfree(val);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(key, \"tracknumber\") || !strcmp(key, \"discnumber\")) {\n\t\tchar *slash = strchr(val, '/');\n\t\tif (slash)\n\t\t\t*slash = 0;\n\t}\n\n\t/* don't add duplicates */\n\tif (keyvals_get_val_growing(c, key)) {\n\t\tfree(val);\n\t\treturn 0;\n\t}\n\n\tkeyvals_add(c, key, val);\n\treturn 1;\n}\n\nint comments_add_const(struct growing_keyvals *c, const char *key, const char *val)\n{\n\treturn comments_add(c, key, xstrdup(val));\n}\n"
        },
        {
          "name": "comment.h",
          "type": "blob",
          "size": 1.513671875,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_COMMENT_H\n#define CMUS_COMMENT_H\n\n#include \"keyval.h\"\n\nint track_is_compilation(const struct keyval *comments);\nint track_is_va_compilation(const struct keyval *comments);\n\nconst char *comments_get_albumartist(const struct keyval *comments);\nconst char *comments_get_artistsort(const struct keyval *comments); /* can return NULL */\n\nint comments_get_int(const struct keyval *comments, const char *key);\nint comments_get_signed_int(const struct keyval *comments, const char *key, long int *ival);\ndouble comments_get_double(const struct keyval *comments, const char *key);\nint comments_get_date(const struct keyval *comments, const char *key);\n\nint comments_add(struct growing_keyvals *c, const char *key, char *val);\nint comments_add_const(struct growing_keyvals *c, const char *key, const char *val);\n\n#endif\n"
        },
        {
          "name": "compiler.h",
          "type": "blob",
          "size": 2.4150390625,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2005 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_COMPILER_H\n#define CMUS_COMPILER_H\n\n#include <stddef.h>\n\n/*\n * GCC 2.96 or compatible required\n */\n#if defined(__GNUC__)\n\n#if __GNUC__ > 3\n#undef offsetof\n#define offsetof(type, member) __builtin_offsetof(type, member)\n#endif\n\n/* Optimization: Condition @x is likely */\n#define likely(x)\t__builtin_expect(!!(x), 1)\n\n/* Optimization: Condition @x is unlikely */\n#define unlikely(x)\t__builtin_expect(!!(x), 0)\n\n#ifndef UNUSED\n#define UNUSED __attribute__((unused))\n#endif\n\n#else\n\n#define likely(x)\t(x)\n#define unlikely(x)\t(x)\n#define UNUSED\n\n#endif\n\n/* Optimization: Function never returns */\n#define CMUS_NORETURN\t__attribute__((__noreturn__))\n\n/* Argument at index @fmt_idx is printf compatible format string and\n * argument at index @first_idx is the first format argument */\n#define CMUS_FORMAT(fmt_idx, first_idx) __attribute__((format(printf, (fmt_idx), (first_idx))))\n\n#if defined(__GNUC__) && (__GNUC__ >= 3)\n\n/* Optimization: Pointer returned can't alias other pointers */\n#define CMUS_MALLOC\t__attribute__((__malloc__))\n\n#else\n\n#define CMUS_MALLOC\n\n#endif\n\n\n/**\n * container_of - cast a member of a structure out to the containing structure\n *\n * @ptr:\tthe pointer to the member.\n * @type:\tthe type of the container struct this is embedded in.\n * @member:\tthe name of the member within the struct.\n *\n */\n#define container_of_portable(ptr, type, member) \\\n\t((type *)(void *)( (char *)(ptr) - offsetof(type,member)))\n#undef container_of\n#if defined(__GNUC__)\n#define container_of(ptr, type, member) __extension__ ({\t\t\\\n\tconst __typeof__( ((type *)0)->member) *_mptr = (ptr);\t\\\n\tcontainer_of_portable(_mptr, type, member);})\n#else\n#define container_of(ptr, type, member) container_of_portable(ptr, type, member)\n#endif\n\n#endif\n"
        },
        {
          "name": "configure",
          "type": "blob",
          "size": 16.591796875,
          "content": "#!/bin/sh\n\n. scripts/configure.sh || exit 1\n\nc11_code=\"\n#include <stdatomic.h>\n\nint main(void)\n{\n#ifdef __STDC_NO_ATOMICS__\n#error No C11 atomics\n#endif\n\t_Atomic int res = ATOMIC_VAR_INIT(0);\n\n\treturn res;\n}\n\"\n\ncheck_c11()\n{\n\tmsg_checking \"for C11 (with atomics support)\"\n\n\tfor flag in -std=gnu11 -std=c11 \"\"\n\tdo\n\t\tif try_compile_link \"$c11_code\" $flag\n\t\tthen\n\t\t\tEXTRA_CFLAGS=\"$EXTRA_CFLAGS $flag\"\n\t\t\tmsg_result yes\n\t\t\tworking_c11=y\n\t\t\tbreak\n\t\tfi\n\tdone\n\n\tif test -z \"$working_c11\"\n\tthen\n\t\tmsg_result no\n\t\treturn 1\n\tfi\n\n\treturn 0\n}\n\ncheck_cflags()\n{\n\tcheck_cc_flag -pipe -Wall -Wshadow -Wcast-align -Wpointer-arith \\\n\t\t-Wwrite-strings -Wundef -Wmissing-prototypes -Wredundant-decls \\\n\t\t-Wextra -Wno-sign-compare -Wformat-security\n\n\tfor i in -Wold-style-definition \\\n\t\t-Wno-pointer-sign \\\n\t\t-Werror-implicit-function-declaration \\\n\t\t-Wno-unused-parameter \\\n\t\t-Wno-missing-field-initializers\n\tdo\n\t\tcheck_cc_flag $i\n\tdone\n\treturn 0\n}\n\ncheck_sndio()\n{\n\tcheck_library SNDIO \"\" \"-lsndio\"\n\treturn $?\n}\n\ncheck_coreaudio()\n{\n\tcase `uname -s` in\n\tDarwin)\n\t\tcheck_library COREAUDIO \"\" \"-framework CoreAudio -framework AudioUnit\"\n\t\treturn $?\n\tesac\n\treturn 1\n}\n\nwcwidth_code=\"\n#include <wchar.h>\n\n/* wchar_t must be 4 bytes to support full unicode */\nextern char check[1/!(4 - sizeof(wchar_t))];\n\nint main(int argc, char *argv[])\n{\n\t(void) wcwidth('a');\n\treturn 0;\n}\n\"\n\ncheck_wcwidth()\n{\n\tmsg_checking \"for uchar compatible wcwidth\"\n\tif try_compile \"$wcwidth_code\"\n\tthen\n\t\tmsg_result yes\n\t\tHAVE_WCWIDTH=1\n\telse\n\t\tmsg_result no\n\t\tHAVE_WCWIDTH=0\n\tfi\n\treturn 0\n}\n\ncheck_compat()\n{\n\tCOMPAT_LIBS=\n\tcase `uname -s` in\n\tSunOS)\n\t\t# connect() etc.\n\t\ttry_link -lsocket && COMPAT_LIBS=\"$COMPAT_LIBS -lsocket\"\n\n\t\t# gethostbyname()\n\t\ttry_link -lnsl && COMPAT_LIBS=\"$COMPAT_LIBS -lnsl\"\n\n\t\t# nanosleep()\n\t\tif try_link -lrt\n\t\tthen\n\t\t\tCOMPAT_LIBS=\"$COMPAT_LIBS -lrt\"\n\t\telif try_link -lposix4\n\t\tthen\n\t\t\tCOMPAT_LIBS=\"$COMPAT_LIBS -lposix4\"\n\t\tfi\n\t\t;;\n\tCYGWIN*)\n\t\tCONFIG_CYGWIN=y\n\t\tmakefile_vars CONFIG_CYGWIN\n\tesac\n\tmakefile_vars COMPAT_LIBS\n}\n\nrtsched_code=\"\n#include <pthread.h>\n\nint main(int argc, char *argv[])\n{\n\tpthread_attr_t attr;\n\tstruct sched_param param;\n\n\tpthread_attr_init(&attr);\n\tpthread_attr_setschedpolicy(&attr, SCHED_RR);\n\tparam.sched_priority = sched_get_priority_max(SCHED_RR);\n\tpthread_attr_setschedparam(&attr, &param);\n\treturn 0;\n}\n\"\n\ncheck_rtsched()\n{\n\tmsg_checking \"for realtime scheduling\"\n\tif try_compile_link \"$rtsched_code\" $PTHREAD_CFLAGS $PTHREAD_LIBS\n\tthen\n\t\tmsg_result yes\n\t\tEXTRA_CFLAGS=\"$EXTRA_CFLAGS -DREALTIME_SCHEDULING\"\n\telse\n\t\tmsg_result no\n\tfi\n\treturn 0\n}\n\nncurses_include=\"\n#if defined(__sun__) || defined(__CYGWIN__)\n#include <termios.h>\n#include <ncurses.h>\n#else\n#include <curses.h>\n#endif\n\"\n\nncurses_code=\"\n$ncurses_include\n\nint main(void)\n{\n\tinitscr();\n\tendwin();\n\treturn 0;\n}\n\"\n\ncheck_ncurses()\n{\n\tif pkg_config NCURSES \"ncursesw\" \"\" \"-lncursesw\"\n\tthen\n\t\twidechars=y\n\telif pkg_config NCURSES \"ncurses\" \"\" \"-lncurses\" || pkg_config NCURSES \"curses\" \"\" \"-lcurses\"\n\tthen\n\t\twidechars=n\n\t\tmsg_error \"Your ncurses does not support wide characters!\"\n\t\tmsg_error \"Install ncursesw if you need wide character support,\"\n\t\tmsg_error \"you can ignore this warning otherwise.\"\n\tfi\n\ttest -z \"$widechars\" && return 1\n\n\tmsg_checking \"for working ncurses setup\"\n\tfor flag in \"\" \"-I/usr/include/ncurses\" \"-I/usr/include/ncursesw\"\n\tdo\n\t\tif try_compile_link \"$ncurses_code\" $NCURSES_CFLAGS $flag $NCURSES_LIBS\n\t\tthen\n\t\t\tNCURSES_CFLAGS=\"$NCURSES_CFLAGS $flag\"\n\t\t\tmsg_result yes\n\t\t\tworking_curses=y\n\t\t\tbreak\n\t\tfi\n\tdone\n\tif test -z \"$working_curses\"\n\tthen\n\t\tmsg_result no\n\t\treturn 1\n\tfi\n\n\tcheck_function \"resizeterm\" $NCURSES_CFLAGS $NCURSES_LIBS\n\tHAVE_RESIZETERM=`test $? -ne 0 ; echo $?`\n\n\tcheck_function \"use_default_colors\" $NCURSES_CFLAGS $NCURSES_LIBS\n\tHAVE_USE_DEFAULT_COLORS=`test $? -ne 0 ; echo $?`\n\n\tmsg_checking \"for A_ITALIC\"\n\tif try_compile_link \"$ncurses_include int main(int argc, char *argv[]) { unsigned long x = A_ITALIC; return !!x; }\" $NCURSES_CFLAGS $NCURSES_LIBS\n\tthen\n\t\tmsg_result yes\n\t\tHAVE_ITALIC=\"1\"\n\telse\n\t\tmsg_result no\n\t\tHAVE_ITALIC=\"0\"\n\tfi\n\n\treturn 0\n}\n\ncheck_discid()\n{\n\tHAVE_DISCID=n\n\tpkg_config DISCID \"libdiscid\" \"\" \"-ldiscid\" && HAVE_DISCID=y\n\treturn $?\n}\n\ncheck_mpc()\n{\n\tMPC_SV8=0\n\tif check_header mpc/mpcdec.h\n\tthen\n\t\tMPC_SV8=1\n\telse\n\t\tcheck_header mpcdec/mpcdec.h || return $?\n\tfi\n\tcheck_library MPC \"\" \"-lmpcdec -lm\"\n\treturn $?\n}\n\ncheck_cddb()\n{\n\tpkg_config CDDB \"libcddb\" \"\" \"-lcddb\" && HAVE_CDDB=y\n\treturn $?\n}\n\ncheck_cdio()\n{\n\tpkg_config CDIO \"libcdio_cdda\" \"\" \"-lcdio_cdio -lcdio -lm\"\n\treturn $?\n}\n\ncheck_flac()\n{\n\tpkg_config FLAC \"flac\" \"\" \"-lFLAC -lm\" || return $?\n\n\t# Make sure the FLAC_CFLAGS value is sane, strip trailing '/FLAC'.\n\tFLAC_CFLAGS=`echo $FLAC_CFLAGS | sed \"s/FLAC$//\"`\n\treturn 0\n}\n\ncheck_mad()\n{\n\tpkg_config MAD \"mad\" \"\" \"-lmad -lm\"\n\treturn $?\n}\n\nmikmod_code=\"\n#include <mikmod.h>\nint main() {\n\tMikMod_RegisterAllDrivers();\n\treturn 0;\n}\n\"\ncheck_mikmod()\n{\n\t# mikmod is linked against pthread\n\tapp_config MIKMOD libmikmod-config || \\\n\t\tcheck_library MIKMOD \"$PTHREAD_CFLAGS\" \"-lmikmod $PTHREAD_LIBS\" || \\\n\t\treturn 1\n\ttry_compile_link \"$mikmod_code\" $MIKMOD_CFLAGS $MIKMOD_LIBS\n\treturn $?\n}\n\ncheck_modplug()\n{\n\tpkg_config MODPLUG \"libmodplug\" \"-I/usr/include/libmodplug\" \"-lmodplug -lstdc++ -lm\" || return $?\n\tMODPLUG_API_8=0\n\tif check_function \"ModPlug_GetModuleType\" $MODPLUG_CFLAGS $MODPLUG_LIBS\n\tthen\n\t\tMODPLUG_API_8=1\n\tfi\n\treturn 0\n}\n\ncheck_bass()\n{\n    check_header bass.h &&\n    check_library BASS \"\" \"-lbass\"\n    return $?\n}\n\ncheck_vtx()\n{\n\tcheck_header ayemu.h &&\n\tcheck_library VTX \"\" \"-layemu\"\n\treturn $?\n}\n\ncheck_vorbis()\n{\n\tif test \"$CONFIG_TREMOR\" = y\n\tthen\n\t\tpkg_config VORBIS \"vorbisidec\" \"\" \"-lvorbisidec -lm\"\n\t\treturn $?\n\telse\n\t\tpkg_config VORBIS \"vorbisfile\" \"\" \"-lvorbisfile -lvorbis -lm -logg\"\n\t\treturn $?\n\tfi\n}\n\ncheck_libsystemd()\n{\n\tpkg_config LIBSYSTEMD \"libsystemd\" || pkg_config LIBSYSTEMD \"libelogind >= 239.3\" || {\n\t\tpkg_config LIBSYSTEMD \"basu\" && CFLAGS=\"${CFLAGS} -DCONFIG_MPRIS_BASU\"\n\t}\n\treturn $?\n}\n\ncheck_opus()\n{\n\tpkg_config OPUS \"opusfile\"\n\treturn $?\n}\n\ncheck_wavpack()\n{\n\tpkg_config WAVPACK \"wavpack >= 4.40\" \"\" \"-lwavpack\"\n\treturn $?\n}\n\ncheck_pulse()\n{\n\tpkg_config PULSE \"libpulse >= 0.9.19\"\n\treturn $?\n}\n\ncheck_alsa()\n{\n\t# the alsa.pc file should be always available\n\tpkg_config ALSA \"alsa >= 1.0.11\"\n\treturn $?\n}\n\ncheck_jack()\n{\n\tpkg_config JACK \"jack\"\n\treturn $?\n}\n\ncheck_samplerate()\n{\n\tpkg_config SAMPLERATE \"samplerate\" && HAVE_SAMPLERATE=y\n\treturn $?\n}\n\ncheck_ao()\n{\n\tpkg_config AO \"ao\" \"\" \"-lao\"\n\treturn $?\n}\n\narts_code=\"\n#include <artsc.h>\nint main() {\n\treturn arts_init();\n}\n\"\ncheck_arts()\n{\n\tapp_config ARTS artsc-config || return 1\n\ttry_compile_link \"$arts_code\" $ARTS_CFLAGS $ARTS_LIBS\n\treturn $?\n}\n\ncheck_oss()\n{\n\tcase `uname -s` in\n\t\tLinux|*FreeBSD)\n\t\t\t;;\n\t\t*BSD)\n\t\t\tcheck_library OSS \"\" \"-lossaudio\"\n\t\t\treturn $?\n\t\t\t;;\n\t\t*)\n\t\t\t# unknown\n\t\t\t;;\n\tesac\n\n\tOSS_CFLAGS=\"\"\n\tOSS_LIBS=\"\"\n\tmsg_checking \"for header <sys/soundcard.h>\"\n\tif test -f /usr/include/sys/soundcard.h\n\tthen\n\t\tmsg_result \"yes\"\n\t\tmakefile_vars OSS_CFLAGS OSS_LIBS\n\t\treturn 0\n\telse\n\t\tmsg_result \"no\"\n\tfi\n\treturn 1\n}\n\ncheck_sun()\n{\n\tmsg_checking \"for header <sys/audioio.h>\"\n\tif test -f /usr/include/sys/audioio.h\n\tthen\n\t\tmsg_result \"yes\"\n\t\treturn 0\n\telse\n\t\tmsg_result \"no\"\n\t\treturn 1\n\tfi\n}\n\ncheck_waveout()\n{\n\tcase `uname -s` in\n\tCYGWIN*)\n\t\tcheck_library WAVEOUT \"\" \"-lwinmm\"\n\t\treturn $?\n\tesac\n\treturn 1\n}\n\ncheck_roar()\n{\n\tpkg_config ROAR \"libroar >= 0.4.5\"\n\treturn $?\n}\n\ncheck_mp4()\n{\n\tpkg_config MP4 \"mp4v2 faad2\" \"\" \"-lmp4v2 -lfaad -lm\" || return $?\n\tUSE_MPEG4IP=0\n\tif ! check_header mp4v2/mp4v2.h $MP4_CFLAGS\n\tthen\n\t\t# couldn't find the v2 header, try falling back to mp4.h\n\t\tUSE_MPEG4IP=1\n\t\tcheck_header mp4.h $MP4_CFLAGS || return $?\n\tfi\n\tcheck_header neaacdec.h $MP4_CFLAGS\n\treturn $?\n}\n\ncheck_aac()\n{\n\tpkg_config AAC faad2 \"\" \"-lfaad -lm\" || return $?\n\tcheck_header neaacdec.h $AAC_CFLAGS\n\treturn $?\n}\n\ncheck_ffmpeg()\n{\n\tpkg_config FFMPEG \"libavformat libavcodec libswresample libavutil\" || return $?\n\t# check the existence of specific headers since they've been renamed before\n\tcheck_header \"libavformat/avformat.h\" $FFMPEG_CFLAGS || return $?\n\tcheck_header \"libavcodec/avcodec.h\" $FFMPEG_CFLAGS || return $?\n\tcheck_header \"libswresample/swresample.h\" $FFMPEG_CFLAGS || return $?\n\tcheck_header \"libavutil/avutil.h\" $FFMPEG_CFLAGS || return $?\n\t# ffmpeg api changes so frequently that it is best to compile the module\n\tlibs=\"$LDDLFLAGS $FFMPEG_LIBS\"\n\tcflags=\"$SOFLAGS $FFMPEG_CFLAGS\"\n\ttopdir=`dirname \"$0\"`\n\tffmpeg_code=`cat \"$topdir\"/ip/ffmpeg.c | sed 's/\\\\\\n//g'`\n\tmsg_checking \"for successful build of ffmpeg.c\"\n\tif try_compile_link \"$ffmpeg_code\" $cflags -I$topdir/ip $libs\n\tthen\n\t\tmsg_result yes\n\t\treturn 0\n\tfi\n\tmsg_result no\n\treturn 1\n}\n\naaudio_code=\"\n#include <aaudio/AAudio.h>\nint main() {\n\t// ensure basic aaudio support\n\tif (__builtin_available(android 26, *)) {\n\t\tAAudioStreamBuilder *bld;\n\t\tAAudio_createStreamBuilder(&bld);\n\n\t\t// ensure we have at least api 32 headers\n\t\tif (__builtin_available(android 32, *)) {\n\t\t\tAAudioStreamBuilder_setChannelMask(bld, AAUDIO_CHANNEL_9POINT1POINT6);\n\t\t}\n\t}\n\treturn 0;\n}\n\"\n\ncheck_aaudio()\n{\n\tcheck_header aaudio/AAudio.h || return $?\n\tcheck_library AAUDIO \"-D__ANDROID_UNAVAILABLE_SYMBOLS_ARE_WEAK__ -Werror=unguarded-availability\" \"-Wl,--no-as-needed -laaudio\" || return $?\n\n\tmsg_checking \"for working aaudio api 32 linkage\"\n\tif try_compile_link \"$aaudio_code\" $AAUDIO_CFLAGS $AAUDIO_LIBS\n\tthen\n\t\tmsg_result yes\n\t\treturn 0\n\tfi\n\tmsg_result no\n\treturn 1\n}\n\ncheck_string_function()\n{\n\tmsg_checking \"for function $1\"\n\tstring_function_code=\"\n#include <string.h>\nint (*ptr)() = (int (*)()) &$1;\nint main() { return 0; }\n\"\n\tif try_compile_link \"$string_function_code\"\n\tthen\n\t\tmsg_result yes\n\t\treturn 0\n\tfi\n\tmsg_result no\n\treturn 1\n}\n\n\n# defaults\nprefix=/usr/local\nDEBUG=1\nHAVE_CDDB=n\nCONFIG_TREMOR=n\nCONFIG_MIKMOD=n\nCONFIG_BASS=n\nUSE_FALLBACK_IP=n\nHAVE_BYTESWAP_H=n\nHAVE_STRDUP=n\nHAVE_STRNDUP=n\nHAVE_SAMPLERATE=n\n# unset CONFIG_* variables: if check succeeds 'y', otherwise 'n'\n\nUSAGE=\"\nOptions:\n  prefix          Installation prefix    [$prefix]\n  bindir          User executables       [\\$prefix/bin]\n  datadir         Read-only data         [\\$prefix/share]\n  libdir          Libraries              [\\$prefix/lib]\n  mandir          Man pages              [\\$datadir/man]\n  docdir          Other documentation    [\\$datadir/doc/cmus]\n  exampledir      Examples               [\\$docdir/examples]\n  DEBUG           Debugging level (0-2)  [$DEBUG]\n\nOptional Features: y/n\n  CONFIG_AAC            AAC (.aac, audio/aac, audio/aacp)               [auto]\n  CONFIG_AAUDIO         Android 8.0+ native audio output                [auto]\n  CONFIG_ALSA           ALSA                                            [auto]\n  CONFIG_AO             Libao cross-platform audio library              [auto]\n  CONFIG_ARTS           ARTS                                            [auto]\n  CONFIG_CDDB           libcddb CDDA identification                     [auto]\n  CONFIG_CDIO           libcdio CDDA input                              [auto]\n  CONFIG_COREAUDIO      CoreAudio                                       [auto]\n  CONFIG_CUE            CUE sheets (.cue)                               [y]\n  CONFIG_DISCID         libdiscid CDDA identification                   [auto]\n  CONFIG_FFMPEG         FFMPEG (.shn, .wma)                             [auto]\n  CONFIG_FLAC           Free Lossless Audio Codec (.flac, .fla)         [auto]\n  CONFIG_JACK           JACK                                            [auto]\n  CONFIG_MAD            MPEG Audio Decoder (.mp3, .mp2, streams)        [auto]\n  CONFIG_MIKMOD         libmikmod (.mod, .x3m, ...)                     [n]\n  CONFIG_BASS           libbass (.mod, .x3m, ...)                       [n]\n  CONFIG_MODPLUG        libmodplug (.mod, .x3m, ...)                    [auto]\n  CONFIG_MP4            MPEG-4 AAC (.mp4, .m4a, .m4b)                   [auto]\n  CONFIG_MPC            libmpcdec (Musepack .mpc, .mpp, .mp+)           [auto]\n  CONFIG_MPRIS          MPRIS                                           [auto]\n  CONFIG_OPUS           Opus (.opus)                                    [auto]\n  CONFIG_OSS            Open Sound System                               [auto]\n  CONFIG_PULSE          native PulseAudio output                        [auto]\n  CONFIG_ROAR           native RoarAudio output                         [auto]\n  CONFIG_SAMPLERATE     Use libsamplerate to resample to JACK's rate    [auto]\n  CONFIG_SNDIO          Sndio                                           [auto]\n  CONFIG_SUN            Sun Audio                                       [auto]\n  CONFIG_TREMOR         Use Tremor as Ogg/Vorbis input plugin           [n]\n  CONFIG_VORBIS         Ogg/Vorbis (.ogg, application/ogg, audio/x-ogg) [auto]\n  CONFIG_VTX            libayemu (.vtx)                                 [auto]\n  CONFIG_WAVEOUT        Windows Wave Out                                [auto]\n  CONFIG_WAVPACK        WavPack (.wv, audio/x-wavpack)                  [auto]\n  CONFIG_WAV            WAV                                             [y]\n  USE_FALLBACK_IP       Use a specific IP for every unrecognized        [n]\n                        input format. Currently set to FFMPEG.\n\nAlso many standard variables like CC, LD, CFLAGS, LDFLAGS are recognized.\nCross compiling is supported via CROSS=target-prefix-\n    optionally set HOSTCC=this-machine-gcc, HOSTLD, HOST_CFLAGS, HOST_LDFLAGS.\"\n\nparse_command_line \"$@\"\n\ncase $DEBUG in\n[0-2])\n\t;;\n*)\n\tdie \"DEBUG must be 0-2\"\n\t;;\nesac\n\nvar_default bindir \"${prefix}/bin\"\nvar_default datadir \"${prefix}/share\"\nvar_default libdir \"${prefix}/lib\"\nvar_default mandir \"${datadir}/man\"\nvar_default docdir \"${datadir}/doc/cmus\"\nvar_default exampledir \"${docdir}/examples\"\n\ncheck check_cc\ncheck check_host_cc\ncheck check_c11\ncheck check_cflags\ncheck check_cc_depgen\ncheck check_endianness\ncheck check_compat\ncheck check_dl\ncheck check_pthread\ncheck check_rtsched\ncheck check_ncurses\ncheck check_iconv\ncheck check_wcwidth\ncheck_header byteswap.h && HAVE_BYTESWAP_H=y\ncheck_string_function \"strdup\" && HAVE_STRDUP=y\ncheck_string_function \"strndup\" && HAVE_STRNDUP=y\n\ncheck check_cddb       CONFIG_CDDB\ncheck check_cdio       CONFIG_CDIO\ncheck check_flac       CONFIG_FLAC\ncheck check_mad        CONFIG_MAD\ncheck check_mikmod     CONFIG_MIKMOD\ncheck check_modplug    CONFIG_MODPLUG\ncheck check_bass       CONFIG_BASS\ncheck check_mpc        CONFIG_MPC\ncheck check_vorbis     CONFIG_VORBIS\ncheck check_opus       CONFIG_OPUS\ncheck check_libsystemd CONFIG_MPRIS\ncheck check_wavpack    CONFIG_WAVPACK\ncheck check_mp4        CONFIG_MP4\ncheck check_aac        CONFIG_AAC\ncheck check_ffmpeg     CONFIG_FFMPEG\ncheck check_vtx        CONFIG_VTX\n# nothing to check, just validate the variable values\ncheck true             CONFIG_TREMOR\ncheck true             CONFIG_WAV\ncheck true             CONFIG_CUE\ncheck check_pulse      CONFIG_PULSE\ncheck check_alsa       CONFIG_ALSA\ncheck check_jack       CONFIG_JACK\ncheck check_samplerate CONFIG_SAMPLERATE\ncheck check_ao         CONFIG_AO\ncheck check_coreaudio  CONFIG_COREAUDIO\ncheck check_arts       CONFIG_ARTS\ncheck check_oss        CONFIG_OSS\ncheck check_sndio      CONFIG_SNDIO\ncheck check_sun        CONFIG_SUN\ncheck check_waveout    CONFIG_WAVEOUT\ncheck check_roar       CONFIG_ROAR\ncheck check_aaudio     CONFIG_AAUDIO\n\n# discid is only needed if at least one cdda plugin is active\ntest -z \"$CONFIG_DISCID\" && CONFIG_DISCID=a\nif test \"$CONFIG_DISCID\" = a\nthen\n\ttest \"$CONFIG_CDIO\" = n && CONFIG_DISCID=n\nfi\ncheck check_discid  CONFIG_DISCID\n\ntest \"$WORDS_BIGENDIAN\" = y && CFLAGS=\"${CFLAGS} -DWORDS_BIGENDIAN\"\ntest \"$HAVE_DISCID\" = y && CFLAGS=\"${CFLAGS} -DHAVE_DISCID\"\n\nDATADIR=\"$datadir\"\nLIBDIR=\"$libdir\"\n\nconfig_header config/cdio.h HAVE_CDDB\nconfig_header config/mpris.h CONFIG_MPRIS\nconfig_header config/datadir.h DATADIR\nconfig_header config/libdir.h LIBDIR\nconfig_header config/debug.h DEBUG\nconfig_header config/tremor.h CONFIG_TREMOR\nconfig_header config/modplug.h MODPLUG_API_8\nconfig_header config/mpc.h MPC_SV8\nconfig_header config/mp4.h USE_MPEG4IP\nconfig_header config/curses.h HAVE_RESIZETERM HAVE_USE_DEFAULT_COLORS HAVE_ITALIC\nconfig_header config/ffmpeg.h HAVE_FFMPEG_AVCODEC_H USE_FALLBACK_IP\nconfig_header config/utils.h HAVE_BYTESWAP_H\nconfig_header config/iconv.h HAVE_ICONV\nconfig_header config/wcwidth.h HAVE_WCWIDTH\nconfig_header config/samplerate.h HAVE_SAMPLERATE\nconfig_header config/xmalloc.h HAVE_STRDUP HAVE_STRNDUP\n\nCFLAGS=\"${CFLAGS} -DHAVE_CONFIG\"\n\nmakefile_vars bindir datadir libdir mandir docdir exampledir\nmakefile_vars \\\n\tCONFIG_AAC CONFIG_ALSA CONFIG_AO CONFIG_ARTS CONFIG_CDIO \\\n\tCONFIG_COREAUDIO CONFIG_CUE CONFIG_FFMPEG CONFIG_FLAC CONFIG_JACK \\\n\tCONFIG_MAD CONFIG_MIKMOD CONFIG_MODPLUG CONFIG_MP4 CONFIG_MPC \\\n\tCONFIG_MPRIS CONFIG_OPUS CONFIG_OSS CONFIG_PULSE CONFIG_ROAR \\\n\tCONFIG_SAMPLERATE CONFIG_SNDIO CONFIG_SUN CONFIG_VORBIS CONFIG_VTX \\\n\tCONFIG_WAV CONFIG_WAVEOUT CONFIG_WAVPACK CONFIG_BASS CONFIG_AAUDIO\n\ngenerate_config_mk\n"
        },
        {
          "name": "contrib",
          "type": "tree",
          "content": null
        },
        {
          "name": "convert.c",
          "type": "blob",
          "size": 2.896484375,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"convert.h\"\n#include \"xmalloc.h\"\n#include \"uchar.h\"\n#ifdef HAVE_CONFIG\n#include \"config/iconv.h\"\n#endif\n\n#ifdef HAVE_ICONV\n#include <iconv.h>\n#endif\n#include <string.h>\n#include <errno.h>\n\nssize_t convert(const char *inbuf, ssize_t inbuf_size,\n\t\tchar **outbuf, ssize_t outbuf_estimate,\n\t\tconst char *tocode, const char *fromcode)\n{\n#ifdef HAVE_ICONV\n\tconst char *in;\n\tchar *out;\n\tsize_t rc, outbuf_size, inbytesleft, outbytesleft;\n\ticonv_t cd;\n\tint finished = 0, err_save;\n\n\tcd = iconv_open(tocode, fromcode);\n\tif (cd == (iconv_t) -1)\n\t\treturn -1;\n\n\tif (inbuf_size < 0)\n\t\tinbuf_size = strlen(inbuf);\n\tinbytesleft = inbuf_size;\n\n\tif (outbuf_estimate < 0)\n\t\toutbuf_size = inbuf_size;\n\telse\n\t\toutbuf_size = outbuf_estimate;\n\toutbytesleft = outbuf_size;\n\n\tin = inbuf;\n\tout = *outbuf = xnew(char, outbuf_size + 1);\n\n\twhile (!finished) {\n\t\tfinished = 1;\n\t\trc = iconv(cd, (char **)&in, &inbytesleft, &out, &outbytesleft);\n\t\tif (rc == (size_t) -1) {\n\t\t\tif (errno == E2BIG) {\n\t\t\t\tsize_t used = out - *outbuf;\n\t\t\t\toutbytesleft += outbuf_size;\n\t\t\t\toutbuf_size *= 2;\n\t\t\t\t*outbuf = xrenew(char, *outbuf, outbuf_size + 1);\n\t\t\t\tout = *outbuf + used;\n\t\t\t\tcontinue;\n\t\t\t} else if (errno != EINVAL)\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\t/* NUL-terminate for safety reasons */\n\t*out = '\\0';\n\ticonv_close(cd);\n\treturn outbuf_size - outbytesleft;\n\nerror:\n\terr_save = errno;\n\tfree(*outbuf);\n\t*outbuf = NULL;\n\ticonv_close(cd);\n\terrno = err_save;\n\treturn -1;\n\n#else\n\tif (inbuf_size < 0)\n\t\tinbuf_size = strlen(inbuf);\n\t*outbuf = xnew(char, inbuf_size + 1);\n\tmemcpy(*outbuf, inbuf, inbuf_size);\n\t(*outbuf)[inbuf_size] = '\\0';\n\treturn inbuf_size;\n#endif\n}\n\nint utf8_encode(const char *inbuf, const char *encoding, char **outbuf)\n{\n\tsize_t inbuf_size, outbuf_size, i;\n\tint rc;\n\n\tinbuf_size = strlen(inbuf);\n\toutbuf_size = inbuf_size;\n\tfor (i = 0; i < inbuf_size; i++) {\n\t\tunsigned char ch;\n\n\t\tch = inbuf[i];\n\t\tif (ch > 127)\n\t\t\toutbuf_size++;\n\t}\n\n\trc = convert(inbuf, inbuf_size, outbuf, outbuf_size, \"UTF-8\", encoding);\n\n\treturn rc < 0 ? -1 : 0;\n}\n\nchar *to_utf8(const char *str, const char *enc)\n{\n\tchar *outbuf = NULL;\n\tint rc;\n\n\tif (u_is_valid(str)) {\n\t\treturn xstrdup(str);\n\t} else {\n\t\trc = utf8_encode(str, enc, &outbuf);\n\t\treturn rc < 0 ? xstrdup(str) : outbuf;\n\t}\n}\n"
        },
        {
          "name": "convert.h",
          "type": "blob",
          "size": 1.13671875,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_CONVERT_H\n#define CMUS_CONVERT_H\n\n#include <sys/types.h> /* ssize_t */\n\n/* Returns length of *outbuf in bytes (without closing '\\0'), -1 on error. */\nssize_t convert(const char *inbuf, ssize_t inbuf_size,\n\t\tchar **outbuf, ssize_t outbuf_estimate,\n\t\tconst char *tocode, const char *fromcode);\n\nint utf8_encode(const char *inbuf, const char *encoding, char **outbuf);\n\nchar *to_utf8(const char *str, const char *enc);\n\n#endif\n"
        },
        {
          "name": "cue.c",
          "type": "blob",
          "size": 10.7001953125,
          "content": "/*\n * Copyright 2016 Various Authors\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <stdlib.h>\n#include <stdbool.h>\n#include <ctype.h>\n#include <sys/stat.h>\n#include <sys/mman.h>\n#include <fcntl.h>\n#include <unistd.h>\n\n#include \"cue.h\"\n#include \"xmalloc.h\"\n#include \"file.h\"\n#include \"list.h\"\n\n#define ASCII_LOWER_TO_UPPER(c) ((c) & ~0x20)\n\nstruct cue_track_proto {\n\tstruct list_head node;\n\n\tchar *file;\n\tuint32_t nr;\n\tint32_t pregap;\n\tint32_t postgap;\n\tint32_t index0;\n\tint32_t index1;\n\n\tstruct cue_meta meta;\n};\n\nstruct cue_track_file {\n\tstruct list_head node;\n\n\tchar *file;\n};\n\nstruct cue_parser {\n\tconst char *src;\n\tsize_t len;\n\tbool err;\n\n\tstruct list_head files;\n\tstruct list_head tracks;\n\tsize_t num_tracks;\n\n\tstruct cue_meta meta;\n};\n\nstruct cue_switch {\n\tconst char *cmd;\n\tvoid (*parser)(struct cue_parser *p);\n};\n\nstatic struct cue_track_proto *cue_proto_from_node(struct list_head *n)\n{\n\treturn container_of(n, struct cue_track_proto, node);\n}\n\nstatic struct cue_track_proto *cue_last_proto(struct cue_parser *p)\n{\n\tif (p->num_tracks == 0)\n\t\treturn NULL;\n\treturn cue_proto_from_node(p->tracks.prev);\n}\n\nstatic inline void cue_consume(struct cue_parser *p)\n{\n\tp->len--;\n\tp->src++;\n}\n\nstatic void cue_set_err(struct cue_parser *p)\n{\n\tp->err = true;\n}\n\nstatic bool cue_str_eq(const char *a, size_t a_len, const char *b, size_t b_len)\n{\n\tif (a_len != b_len)\n\t\treturn false;\n\tfor (size_t i = 0; i < a_len; i++) {\n\t\tif (ASCII_LOWER_TO_UPPER(a[i]) != ASCII_LOWER_TO_UPPER(b[i]))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic void cue_skip_spaces(struct cue_parser *p)\n{\n\twhile (p->len > 0 && (*p->src == ' ' || *p->src == '\\t'))\n\t\tcue_consume(p);\n}\n\nstatic size_t cue_extract_token(struct cue_parser *p, const char **start)\n{\n\tcue_skip_spaces(p);\n\n\tbool quoted = p->len > 0 && *p->src == '\"';\n\tif (quoted)\n\t\tcue_consume(p);\n\n\t*start = p->src;\n\n\twhile (p->len > 0) {\n\t\tchar c = *p->src;\n\t\tif (c == '\\n' || c == '\\r')\n\t\t\tbreak;\n\t\tif (quoted) {\n\t\t\tif (c == '\"')\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (c == ' ' || c == '\\t')\n\t\t\t\tbreak;\n\t\t}\n\t\tcue_consume(p);\n\t}\n\n\tif (quoted) {\n\t\tsize_t len = p->src - *start;\n\t\tif (p->len > 0 && *p->src == '\"')\n\t\t\tcue_consume(p);\n\t\treturn len;\n\t}\n\n\treturn p->src - *start;\n}\n\nstatic void cue_skip_line(struct cue_parser *p)\n{\n\twhile (p->len > 0 && *p->src != '\\n' && *p->src != '\\r')\n\t\tcue_consume(p);\n\n\tif (p->len > 0) {\n\t\tchar c = *p->src;\n\t\tcue_consume(p);\n\t\tif (p->len > 0 && c == '\\r' && *p->src == '\\n')\n\t\t\tcue_consume(p);\n\t}\n}\n\nstatic char *cue_strdup(const char *start, size_t len)\n{\n\tchar *s = xnew(char, len + 1);\n\ts[len] = 0;\n\tmemcpy(s, start, len);\n\treturn s;\n}\n\nstatic uint32_t cue_parse_int(struct cue_parser *p, const char *start, size_t len)\n{\n\tuint32_t val = 0;\n\tfor (size_t i = 0; i < len; i++) {\n\t\tif (!isdigit(start[i])) {\n\t\t\tcue_set_err(p);\n\t\t\treturn 0;\n\t\t}\n\t\tval = val * 10 + start[i] - '0';\n\t}\n\treturn val;\n}\n\nstatic void cue_parse_str(struct cue_parser *p, char **dst)\n{\n\tconst char *start;\n\tsize_t len = cue_extract_token(p, &start);\n\tif (!*dst)\n\t\t*dst = cue_strdup(start, len);\n}\n\n#define CUE_PARSE_STR(field) \\\n\tstatic void cue_parse_##field(struct cue_parser *p) \\\n\t{ \\\n\t\tstruct cue_track_proto *t = cue_last_proto(p); \\\n\t\tif (t) \\\n\t\t\tcue_parse_str(p, &t->meta.field); \\\n\t\telse \\\n\t\t\tcue_parse_str(p, &p->meta.field); \\\n\t}\n\nCUE_PARSE_STR(performer)\nCUE_PARSE_STR(songwriter)\nCUE_PARSE_STR(title)\nCUE_PARSE_STR(genre)\nCUE_PARSE_STR(date)\nCUE_PARSE_STR(comment)\nCUE_PARSE_STR(compilation);\nCUE_PARSE_STR(discnumber);\n\nstatic void cue_parse_file(struct cue_parser *p)\n{\n\tstruct cue_track_file *f = xnew(struct cue_track_file, 1);\n\n\tf->file = NULL;\n\tcue_parse_str(p, &f->file);\n\n\tlist_add_tail(&f->node, &p->files);\n}\n\nstatic char* cue_dup_current_file(struct cue_parser *p)\n{\n\tif (list_empty(&p->files))\n\t\treturn NULL;\n\n\tstruct list_head *tail = list_prev(&p->files);\n\tchar* file = list_entry(tail, struct cue_track_file, node)->file;\n\treturn cue_strdup(file, strlen(file));\n}\n\nstatic void cue_parse_track(struct cue_parser *p)\n{\n\tchar *curr_file = cue_dup_current_file(p);\n\n\tif (!curr_file) {\n\t\tcue_set_err(p);\n\t\treturn;\n\t}\n\n\tconst char *nr;\n\tsize_t len = cue_extract_token(p, &nr);\n\n\tuint32_t d = cue_parse_int(p, nr, len);\n\tif (p->err)\n\t\treturn;\n\n\tstruct cue_track_proto *t = xnew(struct cue_track_proto, 1);\n\t*t = (struct cue_track_proto) {\n\t\t.nr = d,\n\t\t.pregap = -1,\n\t\t.postgap = -1,\n\t\t.index0 = -1,\n\t\t.index1 = -1,\n\t\t.file = curr_file,\n\t};\n\n\tlist_add_tail(&t->node, &p->tracks);\n\tp->num_tracks++;\n}\n\nstatic uint32_t cue_parse_time(struct cue_parser *p, const char *start, size_t len)\n{\n\tuint32_t vals[] = { 0, 0, 0 };\n\tuint32_t *val = vals;\n\tfor (size_t i = 0; i < len; i++) {\n\t\tif (start[i] == ':') {\n\t\t\tif (val != &vals[2]) {\n\t\t\t\tval++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (!isdigit(start[i])) {\n\t\t\tcue_set_err(p);\n\t\t\treturn 0;\n\t\t}\n\t\t*val = *val * 10 + start[i] - '0';\n\t}\n\treturn (vals[0] * 60 + vals[1]) * 75 + vals[2];\n}\n\nstatic void cue_parse_index(struct cue_parser *p)\n{\n\tconst char *nr;\n\tsize_t nr_len = cue_extract_token(p, &nr);\n\n\tuint32_t d = cue_parse_int(p, nr, nr_len);\n\tif (p->err || d > 1)\n\t\treturn;\n\n\tconst char *offset_str;\n\tsize_t offset_len = cue_extract_token(p, &offset_str);\n\n\tuint32_t offset = cue_parse_time(p, offset_str, offset_len);\n\tif (p->err)\n\t\treturn;\n\n\tstruct cue_track_proto *last = cue_last_proto(p);\n\tif (!last)\n\t\treturn;\n\n\tif (d == 0)\n\t\tlast->index0 = offset;\n\telse\n\t\tlast->index1 = offset;\n}\n\nstatic void cue_parse_cmd(struct cue_parser *p, struct cue_switch *s)\n{\n\tconst char *start;\n\tsize_t len = cue_extract_token(p, &start);\n\n\twhile (s->cmd) {\n\t\tif (cue_str_eq(start, len, s->cmd, strlen(s->cmd))) {\n\t\t\ts->parser(p);\n\t\t\treturn;\n\t\t}\n\t\ts++;\n\t}\n}\n\nstatic void cue_parse_rem(struct cue_parser *p)\n{\n\tstruct cue_switch cmds[] = {\n\t\t{ \"DATE\",        cue_parse_date        },\n\t\t{ \"GENRE\",       cue_parse_genre       },\n\t\t{ \"COMMENT\",     cue_parse_comment     },\n\t\t{ \"COMPILATION\", cue_parse_compilation },\n\t\t{ \"DISCNUMBER\",  cue_parse_discnumber  },\n\t\t{ 0 },\n\t};\n\n\tcue_parse_cmd(p, cmds);\n}\n\nstatic void cue_parse_gap(struct cue_parser *p, bool post)\n{\n\tconst char *gap_str;\n\tsize_t gap_len = cue_extract_token(p, &gap_str);\n\n\tuint32_t gap = cue_parse_time(p, gap_str, gap_len);\n\tif (p->err)\n\t\treturn;\n\n\tstruct cue_track_proto *last = cue_last_proto(p);\n\tif (!last)\n\t\treturn;\n\n\tif (post)\n\t\tlast->postgap = gap;\n\telse\n\t\tlast->pregap = gap;\n}\n\nstatic void cue_parse_pregap(struct cue_parser *p)\n{\n\tcue_parse_gap(p, false);\n}\n\nstatic void cue_parse_postgap(struct cue_parser *p)\n{\n\tcue_parse_gap(p, true);\n}\n\nstatic void cue_parse_line(struct cue_parser *p)\n{\n\tstruct cue_switch cmds[] = {\n\t\t{ \"FILE\",       cue_parse_file       },\n\t\t{ \"PERFORMER\",  cue_parse_performer  },\n\t\t{ \"SONGWRITER\", cue_parse_songwriter },\n\t\t{ \"TITLE\",      cue_parse_title      },\n\t\t{ \"TRACK\",      cue_parse_track      },\n\t\t{ \"INDEX\",      cue_parse_index      },\n\t\t{ \"REM\",        cue_parse_rem        },\n\t\t{ \"PREGAP\",     cue_parse_pregap     },\n\t\t{ \"POSTGAP\",    cue_parse_postgap    },\n\t\t{ 0 },\n\t};\n\n\tcue_parse_cmd(p, cmds);\n\tcue_skip_line(p);\n}\n\nstatic void cue_post_process(struct cue_parser *p)\n{\n\tif (list_empty(&p->files) || p->num_tracks == 0) {\n\t\tcue_set_err(p);\n\t\treturn;\n\t}\n\n\tstruct cue_track_proto *t;\n\n\tint32_t last = -1;\n\n\tlist_for_each_entry(t, &p->tracks, node) {\n\t\tif (last != -1 && t->nr != last + 1) {\n\t\t\tcue_set_err(p);\n\t\t\treturn;\n\t\t}\n\t\tlast = t->nr;\n\t}\n\n\tlast = -1;\n\tchar *last_file = NULL;\n\n\tlist_for_each_entry(t, &p->tracks, node) {\n\t\tif (t->index0 == -1 && t->index1 == -1) {\n\t\t\tcue_set_err(p);\n\t\t\treturn;\n\t\t}\n\t\tif (t->index0 == -1 || t->index1 == -1) {\n\t\t\tint32_t pregap = t->pregap != -1 ? t->pregap : 0;\n\t\t\tif (t->index1 != -1)\n\t\t\t\tt->index0 = t->index1 - pregap;\n\t\t\telse\n\t\t\t\tt->index1 = t->index0 + pregap;\n\t\t}\n\t\tif (last != -1 && (t->file == last_file && t->index0 < last)) {\n\t\t\tcue_set_err(p);\n\t\t\treturn;\n\t\t}\n\t\tint32_t postgap = t->postgap != -1 ? t->postgap : 0;\n\t\tlast = t->index1 + postgap;\n\t\tlast_file = t->file;\n\t}\n}\n\nstatic void cue_meta_move(struct cue_meta *l, struct cue_meta *r)\n{\n\t*l = *r;\n\t*r = (struct cue_meta) { 0 };\n}\n\nstatic struct cue_sheet *cue_parser_to_sheet(struct cue_parser *p)\n{\n\tstruct cue_sheet *s = xnew(struct cue_sheet, 1);\n\n\ts->tracks = xnew(struct cue_track, p->num_tracks);\n\ts->num_tracks = p->num_tracks;\n\ts->track_base = cue_last_proto(p)->nr + 1 - p->num_tracks;\n\n\tcue_meta_move(&s->meta, &p->meta);\n\n\tsize_t idx = 0;\n\tstruct cue_track_proto *t, *prev;\n\tlist_for_each_entry(t, &p->tracks, node) {\n\t\ts->tracks[idx].file = t->file;\n\t\tt->file = NULL;\n\n\t\ts->tracks[idx].offset = t->index1 / 75.0;\n\t\ts->tracks[idx].length = -1;\n\n\t\tif (idx > 0) {\n\t\t\tint32_t postgap = prev->postgap != -1 ? prev->postgap : 0;\n\t\t\ts->tracks[idx - 1].length =\n\t\t\t\t(t->index1 - prev->index1 - postgap) / 75.0;\n\t\t}\n\n\t\tcue_meta_move(&s->tracks[idx].meta, &t->meta);\n\n\t\tprev = t;\n\t\tidx++;\n\t}\n\n\treturn s;\n}\n\nstatic void cue_meta_free(struct cue_meta *m)\n{\n\tfree(m->performer);\n\tfree(m->songwriter);\n\tfree(m->title);\n\tfree(m->genre);\n\tfree(m->date);\n\tfree(m->comment);\n\tfree(m->compilation);\n}\n\nstatic void cue_parser_free(struct cue_parser *p)\n{\n\tstruct cue_track_proto *t, *next;\n\tstruct cue_track_file *tf, *nexttf;\n\n\tlist_for_each_entry_safe(tf, nexttf, &p->files, node) {\n\t\tfree(tf->file);\n\t\tfree(tf);\n\t}\n\n\tlist_for_each_entry_safe(t, next, &p->tracks, node) {\n\t\tcue_meta_free(&t->meta);\n\t\tfree(t->file);\n\t\tfree(t);\n\t}\n\n\tcue_meta_free(&p->meta);\n}\n\nstruct cue_sheet *cue_parse(const char *src, size_t len)\n{\n\tstruct cue_sheet *res = NULL;\n\n\tstruct cue_parser p = {\n\t\t.src = src,\n\t\t.len = len,\n\t};\n\tlist_init(&p.tracks);\n\tlist_init(&p.files);\n\n\twhile (p.len > 0 && !p.err)\n\t\tcue_parse_line(&p);\n\n\tif (p.err)\n\t\tgoto out;\n\n\tcue_post_process(&p);\n\n\tif (p.err)\n\t\tgoto out;\n\n\tres = cue_parser_to_sheet(&p);\n\nout:\n\tcue_parser_free(&p);\n\treturn res;\n}\n\nstruct cue_sheet *cue_from_file(const char *file)\n{\n\tssize_t size;\n\tchar *buf = mmap_file(file, &size);\n\tif (size == -1)\n\t\treturn NULL;\n\tstruct cue_sheet *rv;\n\n\t// Check for UTF-8 BOM, and skip ahead if found\n\tif (size >= 3 && memcmp(buf, \"\\xEF\\xBB\\xBF\", 3) == 0) {\n\t\trv = cue_parse(buf + 3, size - 3);\n\t} else {\n\t\trv = cue_parse(buf, size);\n\t}\n\n\tmunmap(buf, size);\n\treturn rv;\n}\n\nvoid cue_free(struct cue_sheet *s)\n{\n\tfor (size_t i = 0; i < s->num_tracks; i++) {\n\t\tcue_meta_free(&s->tracks[i].meta);\n\t\tfree(s->tracks[i].file);\n\t}\n\tfree(s->tracks);\n\n\tcue_meta_free(&s->meta);\n\tfree(s);\n}\n"
        },
        {
          "name": "cue.h",
          "type": "blob",
          "size": 1.4404296875,
          "content": "/*\n * Copyright 2016 Various Authors\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_CUE_H\n#define CMUS_CUE_H\n\n#include <stdint.h>\n\nstruct cue_meta {\n\tchar *performer;\n\tchar *songwriter;\n\tchar *title;\n\tchar *genre;\n\tchar *date;\n\tchar *comment;\n\tchar *compilation;\n\tchar *discnumber;\n};\n\nstruct cue_track {\n\tchar *file;\n\tdouble offset;\n\tdouble length;\n\tstruct cue_meta meta;\n};\n\nstruct cue_sheet {\n\tstruct cue_track *tracks;\n\tsize_t num_tracks;\n\tsize_t track_base;\n\n\tstruct cue_meta meta;\n};\n\nstruct cue_sheet *cue_parse(const char *src, size_t len);\nstruct cue_sheet *cue_from_file(const char *file);\nvoid cue_free(struct cue_sheet *s);\n\nstatic inline struct cue_track *cue_get_track(struct cue_sheet *s, size_t n)\n{\n\tsize_t offset = n - s->track_base;\n\tif (n < s->track_base || offset > s->num_tracks)\n\t\treturn NULL;\n\treturn &s->tracks[offset];\n}\n\n#endif\n"
        },
        {
          "name": "cue_utils.c",
          "type": "blob",
          "size": 1.650390625,
          "content": "/*\n * Copyright (C) 2008-2013 Various Authors\n * Copyright (C) 2011 Gregory Petrosyan\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"path.h\"\n#include \"utils.h\"\n#include \"cue_utils.h\"\n#include \"xmalloc.h\"\n#include \"cue.h\"\n\n#include <stdio.h>\n\nchar *associated_cue(const char *filename)\n{\n\tFILE *fp;\n\tconst char *ext;\n\tchar buf[4096] = {0};\n\tconst char *dot;\n\n\text = get_extension(filename);\n\tif (ext != NULL && strcmp(ext, \"cue\") == 0)\n\t\treturn NULL;\n\n\tdot = strrchr(filename, '.');\n\tif (dot == NULL)\n\t\treturn NULL;\n\n\tsnprintf(buf, sizeof buf, \"%.*s.cue\", (int) (dot - filename), filename);\n\tfp = fopen(buf, \"r\");\n\tif (!fp)\n\t\tsnprintf(buf, sizeof buf, \"%s.cue\", filename);\n\telse\n\t\tfclose(fp);\n\n\treturn xstrdup(buf);\n}\n\n\nint cue_get_ntracks(const char *filename)\n{\n\tstruct cue_sheet *cd = cue_from_file(filename);\n\tif (!cd)\n\t\treturn -1;\n\tsize_t n = cd->num_tracks;\n\tcue_free(cd);\n\treturn n;\n}\n\n\nchar *construct_cue_url(const char *cue_filename, int track_n)\n{\n\tchar buf[4096] = {0};\n\n\tsnprintf(buf, sizeof buf, \"cue://%s/%d\", cue_filename, track_n);\n\n\treturn xstrdup(buf);\n}\n"
        },
        {
          "name": "cue_utils.h",
          "type": "blob",
          "size": 0.9482421875,
          "content": "/*\n * Copyright (C) 2008-2013 Various Authors\n * Copyright (C) 2011 Gregory Petrosyan\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_CUE_UTILS_H\n#define CMUS_CUE_UTILS_H\n\n#include <stdio.h>\n\nchar *associated_cue(const char *filename);\nint cue_get_ntracks(const char *filename);\nchar *construct_cue_url(const char *cue_filename, int track_n);\n\n\n#endif\n"
        },
        {
          "name": "data",
          "type": "tree",
          "content": null
        },
        {
          "name": "debug.c",
          "type": "blob",
          "size": 2.462890625,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004-2005 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"debug.h\"\n#include \"prog.h\"\n\n#include <stdio.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <sys/time.h>\n\n#if DEBUG > 1\nstatic FILE *debug_stream = NULL;\n#endif\n\nvoid debug_init(void)\n{\n#if DEBUG > 1\n\tchar filename[512];\n\tconst char *dir = getenv(\"CMUS_HOME\");\n\n\tif (!dir || !dir[0]) {\n\t\tdir = getenv(\"HOME\");\n\t\tif (!dir)\n\t\t\tdie(\"error: environment variable HOME not set\\n\");\n\t}\n\tsnprintf(filename, sizeof(filename), \"%s/cmus-debug.txt\", dir);\n\n\tdebug_stream = fopen(filename, \"w\");\n\tif (debug_stream == NULL)\n\t\tdie_errno(\"error opening `%s' for writing\", filename);\n#endif\n}\n\n/* This function must be defined even if debugging is disabled in the program\n * because debugging might still be enabled in some plugin.\n */\nvoid _debug_bug(const char *function, const char *fmt, ...)\n{\n\tconst char *format = \"\\n%s: BUG: \";\n\tva_list ap;\n\n\t/* debug_stream exists only if debugging is enabled */\n#if DEBUG > 1\n\tfprintf(debug_stream, format, function);\n\tva_start(ap, fmt);\n\tvfprintf(debug_stream, fmt, ap);\n\tva_end(ap);\n#endif\n\n\t/* always print bug message to stderr */\n\tfprintf(stderr, format, function);\n\tva_start(ap, fmt);\n\tvfprintf(stderr, fmt, ap);\n\tva_end(ap);\n\texit(127);\n}\n\nvoid _debug_print(const char *function, const char *fmt, ...)\n{\n#if DEBUG > 1\n\tva_list ap;\n\n\tfprintf(debug_stream, \"%s: \", function);\n\tva_start(ap, fmt);\n\tvfprintf(debug_stream, fmt, ap);\n\tva_end(ap);\n\tfflush(debug_stream);\n#endif\n}\n\nuint64_t timer_get(void)\n{\n#if DEBUG > 1\n\tstruct timeval tv;\n\n\tgettimeofday(&tv, NULL);\n\treturn tv.tv_sec * 1e6L + tv.tv_usec;\n#else\n\treturn 0;\n#endif\n}\n\nvoid timer_print(const char *what, uint64_t usec)\n{\n#if DEBUG > 1\n\tuint64_t a = usec / 1e6;\n\tuint64_t b = usec - a * 1e6;\n\n\t_debug_print(\"TIMER\", \"%s: %11u.%06u\\n\", what, (unsigned int)a, (unsigned int)b);\n#endif\n}\n"
        },
        {
          "name": "debug.h",
          "type": "blob",
          "size": 1.37890625,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004-2005 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_DEBUG_H\n#define CMUS_DEBUG_H\n\n#include \"compiler.h\"\n#ifdef HAVE_CONFIG\n#include \"config/debug.h\"\n#endif\n\n#include <errno.h>\n#include <stdint.h>\n\nvoid debug_init(void);\nvoid _debug_bug(const char *function, const char *fmt, ...) CMUS_FORMAT(2, 3) CMUS_NORETURN;\nvoid _debug_print(const char *function, const char *fmt, ...) CMUS_FORMAT(2, 3);\n\nuint64_t timer_get(void);\nvoid timer_print(const char *what, uint64_t usec);\n\n#define BUG(...) _debug_bug(__FUNCTION__, __VA_ARGS__)\n\n#define CMUS_STR(a) #a\n\n#define BUG_ON(a)\t\t\t\\\ndo {\t\t\t\t\t\\\n\tif (unlikely(a))\t\t\\\n\t\tBUG(\"%s\\n\", CMUS_STR(a));\t\\\n} while (0)\n\n#define d_print(...) _debug_print(__FUNCTION__, __VA_ARGS__)\n\n#endif\n"
        },
        {
          "name": "discid.c",
          "type": "blob",
          "size": 3.435546875,
          "content": "/*\n * Copyright 2011-2013 Various Authors\n * Copyright 2011 Johannes Weißl\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"discid.h\"\n#include \"xmalloc.h\"\n#include \"path.h\"\n#include \"utils.h\"\n#include \"debug.h\"\n\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <limits.h>\n\n#ifdef HAVE_DISCID\n#include <discid/discid.h>\n#endif\n\nchar *get_default_cdda_device(void)\n{\n\tconst char *dev = NULL;\n#ifdef HAVE_DISCID\n\tdev = discid_get_default_device();\n#endif\n\tif (!dev)\n\t\tdev = \"/dev/cdrom\";\n\treturn xstrdup(dev);\n}\n\nint parse_cdda_url(const char *url, char **disc_id, int *start_track, int *end_track)\n{\n\tchar *slash, *dash;\n\tlong int t;\n\n\tif (!is_cdda_url(url))\n\t\treturn 0;\n\turl += 7;\n\n\tslash = strrchr(url, '/');\n\tif (slash) {\n\t\t*disc_id = xstrndup(url, slash - url);\n\t\turl = slash + 1;\n\t}\n\tdash = strchr(url, '-');\n\tif (dash) {\n\t\tchar *tmp = xstrndup(url, dash - url);\n\t\tif (str_to_int(tmp, &t) == 0)\n\t\t\t*start_track = t;\n\t\tif (end_track) {\n\t\t\tif (str_to_int(dash + 1, &t) == 0)\n\t\t\t\t*end_track = t;\n\t\t\telse\n\t\t\t\t*end_track = INT_MAX;\n\t\t}\n\t\tfree(tmp);\n\t} else {\n\t\tif (str_to_int(url, &t) == 0)\n\t\t\t*start_track = t;\n\t}\n\n\treturn 1;\n}\n\nchar *gen_cdda_url(const char *disc_id, int start_track, int end_track)\n{\n\tchar buf[256];\n\tif (end_track != -1)\n\t\tsnprintf(buf, sizeof(buf), \"cdda://%s/%d-%d\", disc_id, start_track, end_track);\n\telse\n\t\tsnprintf(buf, sizeof(buf), \"cdda://%s/%d\", disc_id, start_track);\n\treturn xstrdup(buf);\n}\n\nchar *complete_cdda_url(const char *device, const char *url)\n{\n\tchar *new_url, *url_disc_id = NULL, *disc_id = NULL;\n\tint is_range, start_track = -1, end_track = -1, num_tracks = -1;\n\n\tparse_cdda_url(url, &url_disc_id, &start_track, &end_track);\n\tis_range = (start_track == -1 && end_track == -1) || end_track == INT_MAX;\n\tif (!url_disc_id || is_range) {\n\t\tif (url_disc_id && strchr(url_disc_id, '/'))\n\t\t\tdevice = url_disc_id;\n\t\tget_disc_id(device, &disc_id, &num_tracks);\n\t\tif (is_range)\n\t\t\tend_track = num_tracks;\n\t\tif (!url_disc_id)\n\t\t\turl_disc_id = disc_id;\n\t}\n\tif (start_track == -1)\n\t\tstart_track = 1;\n\n\tnew_url = gen_cdda_url(url_disc_id, start_track, end_track);\n\tfree(disc_id);\n\n\treturn new_url;\n}\n\nstatic int get_device_disc_id(const char *device, char **disc_id, int *num_tracks)\n{\n#ifdef HAVE_DISCID\n\tDiscId *disc = discid_new();\n\tif (!disc)\n\t\treturn 0;\n\n\tif (!discid_read(disc, device)) {\n\t\td_print(\"%s\\n\", discid_get_error_msg(disc));\n\t\tdiscid_free(disc);\n\t\treturn 0;\n\t}\n\n\t*disc_id = xstrdup(discid_get_id(disc));\n\tif (num_tracks)\n\t\t*num_tracks = discid_get_last_track_num(disc);\n\n\tdiscid_free(disc);\n\treturn 1;\n#else\n\treturn 0;\n#endif\n}\n\nint get_disc_id(const char *device, char **disc_id, int *num_tracks)\n{\n\tstruct stat st;\n\n\tif (stat(device, &st) == -1)\n\t\treturn 0;\n\n\tif (S_ISBLK(st.st_mode))\n\t\treturn get_device_disc_id(device, disc_id, num_tracks);\n\n\t*disc_id = path_absolute(device);\n\treturn 1;\n}\n"
        },
        {
          "name": "discid.h",
          "type": "blob",
          "size": 1.0849609375,
          "content": "/*\n * Copyright 2011-2013 Various Authors\n * Copyright 2011 Johannes Weißl\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_DISCID_H\n#define CMUS_DISCID_H\n\nchar *get_default_cdda_device(void);\nint parse_cdda_url(const char *url, char **disc_id, int *start_track, int *end_track);\nchar *gen_cdda_url(const char *disc_id, int start_track, int end_track);\nchar *complete_cdda_url(const char *device, const char *url);\nint get_disc_id(const char *device, char **disc_id, int *num_tracks);\n\n#endif\n"
        },
        {
          "name": "editable.c",
          "type": "blob",
          "size": 10.34765625,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2006 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"editable.h\"\n#include \"search.h\"\n#include \"track.h\"\n#include \"track_info.h\"\n#include \"expr.h\"\n#include \"filters.h\"\n#include \"locking.h\"\n#include \"mergesort.h\"\n#include \"xmalloc.h\"\n\nstatic const struct searchable_ops simple_search_ops = {\n\t.get_prev = simple_track_get_prev,\n\t.get_next = simple_track_get_next,\n\t.get_current = simple_track_search_get_current,\n\t.matches = simple_track_search_matches\n};\n\nstatic struct simple_track *get_selected(struct editable *e)\n{\n\tstruct iter sel;\n\n\tif (window_get_sel(e->shared->win, &sel))\n\t\treturn iter_to_simple_track(&sel);\n\treturn NULL;\n}\n\nvoid editable_shared_init(struct editable_shared *shared,\n\t\teditable_free_track free_track)\n{\n\tshared->win = window_new(simple_track_get_prev, simple_track_get_next);\n\tshared->sort_keys = xnew(sort_key_t, 1);\n\tshared->sort_keys[0] = SORT_INVALID;\n\tshared->sort_str[0] = 0;\n\tshared->free_track = free_track;\n\tshared->owner = NULL;\n\n\tstruct iter iter = { 0 };\n\tshared->searchable = searchable_new(shared->win, &iter,\n\t\t\t&simple_search_ops);\n}\n\nvoid editable_init(struct editable *e, struct editable_shared *shared,\n\t\tint take_ownership)\n{\n\tlist_init(&e->head);\n\te->tree_root = RB_ROOT;\n\te->nr_tracks = 0;\n\te->nr_marked = 0;\n\te->total_time = 0;\n\te->shared = shared;\n\n\n\tif (take_ownership)\n\t\teditable_take_ownership(e);\n}\n\nstatic int editable_owns_shared(struct editable *e)\n{\n\treturn e->shared->owner == e;\n}\n\nvoid editable_take_ownership(struct editable *e)\n{\n\tif (!editable_owns_shared(e)) {\n\t\te->shared->owner = e;\n\t\twindow_set_contents(e->shared->win, &e->head);\n\t\te->shared->win->changed = 1;\n\n\t\tstruct iter iter = { .data0 = &e->head };\n\t\tsearchable_set_head(e->shared->searchable, &iter);\n\t}\n}\n\nstatic void do_editable_add(struct editable *e, struct simple_track *track, int tiebreak)\n{\n\tsorted_list_add_track(&e->head, &e->tree_root, track,\n\t\t\te->shared->sort_keys, tiebreak);\n\te->nr_tracks++;\n\tif (track->info->duration != -1)\n\t\te->total_time += track->info->duration;\n\tif (editable_owns_shared(e))\n\t\twindow_changed(e->shared->win);\n}\n\nvoid editable_add(struct editable *e, struct simple_track *track)\n{\n\tdo_editable_add(e, track, +1);\n}\n\nvoid editable_add_before(struct editable *e, struct simple_track *track)\n{\n\tdo_editable_add(e, track, -1);\n}\n\nvoid editable_remove_track(struct editable *e, struct simple_track *track)\n{\n\tstruct track_info *ti = track->info;\n\tstruct iter iter;\n\n\teditable_track_to_iter(e, track, &iter);\n\tif (editable_owns_shared(e))\n\t\twindow_row_vanishes(e->shared->win, &iter);\n\n\te->nr_tracks--;\n\te->nr_marked -= track->marked;\n\tif (ti->duration != -1)\n\t\te->total_time -= ti->duration;\n\n\tsorted_list_remove_track(&e->head, &e->tree_root, track);\n\te->shared->free_track(e, &track->node);\n}\n\nvoid editable_remove_sel(struct editable *e)\n{\n\tstruct simple_track *t;\n\n\tif (e->nr_marked) {\n\t\t/* treat marked tracks as selected */\n\t\tstruct list_head *next, *item = e->head.next;\n\n\t\twhile (item != &e->head) {\n\t\t\tnext = item->next;\n\t\t\tt = to_simple_track(item);\n\t\t\tif (t->marked)\n\t\t\t\teditable_remove_track(e, t);\n\t\t\titem = next;\n\t\t}\n\t} else {\n\t\tt = get_selected(e);\n\t\tif (t)\n\t\t\teditable_remove_track(e, t);\n\t}\n}\n\nvoid editable_sort(struct editable *e)\n{\n\tif (e->nr_tracks <= 1)\n\t\treturn;\n\tsorted_list_rebuild(&e->head, &e->tree_root, e->shared->sort_keys);\n\n\tif (editable_owns_shared(e)) {\n\t\twindow_changed(e->shared->win);\n\t\twindow_goto_top(e->shared->win);\n\t}\n}\n\nvoid editable_shared_set_sort_keys(struct editable_shared *shared,\n\t\tsort_key_t *keys)\n{\n\tfree(shared->sort_keys);\n\tshared->sort_keys = keys;\n}\n\nvoid editable_toggle_mark(struct editable *e)\n{\n\tstruct simple_track *t;\n\n\tt = get_selected(e);\n\tif (t) {\n\t\te->nr_marked -= t->marked;\n\t\tt->marked ^= 1;\n\t\te->nr_marked += t->marked;\n\t\tif (editable_owns_shared(e)) {\n\t\t\te->shared->win->changed = 1;\n\t\t\twindow_down(e->shared->win, 1);\n\t\t}\n\t}\n}\n\nstatic void move_item(struct editable *e, struct list_head *head, struct list_head *item)\n{\n\tstruct simple_track *t = to_simple_track(item);\n\tstruct iter iter;\n\n\teditable_track_to_iter(e, t, &iter);\n\tif (editable_owns_shared(e))\n\t\twindow_row_vanishes(e->shared->win, &iter);\n\n\tlist_del(item);\n\tlist_add(item, head);\n}\n\nstatic void reset_tree(struct editable *e)\n{\n\tstruct simple_track *old, *first_track;\n\n\told = tree_node_to_simple_track(rb_first(&e->tree_root));\n\tfirst_track = to_simple_track(e->head.next);\n\tif (old != first_track) {\n\t\trb_replace_node(&old->tree_node, &first_track->tree_node, &e->tree_root);\n\t\tRB_CLEAR_NODE(&old->tree_node);\n\t}\n}\n\nstatic void move_sel(struct editable *e, struct list_head *after)\n{\n\tstruct simple_track *t;\n\tstruct list_head *item, *next;\n\tstruct iter iter;\n\tLIST_HEAD(tmp_head);\n\n\tif (e->nr_marked) {\n\t\t/* collect marked */\n\t\titem = e->head.next;\n\t\twhile (item != &e->head) {\n\t\t\tt = to_simple_track(item);\n\t\t\tnext = item->next;\n\t\t\tif (t->marked)\n\t\t\t\tmove_item(e, &tmp_head, item);\n\t\t\titem = next;\n\t\t}\n\t} else {\n\t\t/* collect the selected track */\n\t\tt = get_selected(e);\n\t\tif (t)\n\t\t\tmove_item(e, &tmp_head, &t->node);\n\t}\n\n\t/* put them back to the list after @after */\n\titem = tmp_head.next;\n\twhile (item != &tmp_head) {\n\t\tnext = item->next;\n\t\tlist_add(item, after);\n\t\titem = next;\n\t}\n\treset_tree(e);\n\n\t/* select top-most of the moved tracks */\n\teditable_track_to_iter(e, to_simple_track(after->next), &iter);\n\n\tif (editable_owns_shared(e)) {\n\t\twindow_changed(e->shared->win);\n\t\twindow_set_sel(e->shared->win, &iter);\n\t}\n}\n\nstatic struct list_head *find_insert_after_point(struct editable *e, struct list_head *item)\n{\n\tif (e->nr_marked == 0) {\n\t\t/* move the selected track down one row */\n\t\treturn item->next;\n\t}\n\n\t/* move marked after the selected\n\t *\n\t * if the selected track itself is marked we find the first unmarked\n\t * track (or head) before the selected one\n\t */\n\twhile (item != &e->head) {\n\t\tstruct simple_track *t = to_simple_track(item);\n\n\t\tif (!t->marked)\n\t\t\tbreak;\n\t\titem = item->prev;\n\t}\n\treturn item;\n}\n\nstatic struct list_head *find_insert_before_point(struct editable *e, struct list_head *item)\n{\n\titem = item->prev;\n\tif (e->nr_marked == 0) {\n\t\t/* move the selected track up one row */\n\t\treturn item->prev;\n\t}\n\n\t/* move marked before the selected\n\t *\n\t * if the selected track itself is marked we find the first unmarked\n\t * track (or head) before the selected one\n\t */\n\twhile (item != &e->head) {\n\t\tstruct simple_track *t = to_simple_track(item);\n\n\t\tif (!t->marked)\n\t\t\tbreak;\n\t\titem = item->prev;\n\t}\n\treturn item;\n}\n\nvoid editable_move_after(struct editable *e)\n{\n\tstruct simple_track *sel;\n\n\tif (e->nr_tracks <= 1 || e->shared->sort_keys[0] != SORT_INVALID)\n\t\treturn;\n\n\tsel = get_selected(e);\n\tif (sel)\n\t\tmove_sel(e, find_insert_after_point(e, &sel->node));\n}\n\nvoid editable_move_before(struct editable *e)\n{\n\tstruct simple_track *sel;\n\n\tif (e->nr_tracks <= 1 || e->shared->sort_keys[0] != SORT_INVALID)\n\t\treturn;\n\n\tsel = get_selected(e);\n\tif (sel)\n\t\tmove_sel(e, find_insert_before_point(e, &sel->node));\n}\n\nvoid editable_clear(struct editable *e)\n{\n\tstruct list_head *item, *tmp;\n\n\tlist_for_each_safe(item, tmp, &e->head)\n\t\teditable_remove_track(e, to_simple_track(item));\n}\n\nvoid editable_remove_matching_tracks(struct editable *e,\n\t\tint (*cb)(void *data, struct track_info *ti), void *data)\n{\n\tstruct list_head *item, *tmp;\n\n\tlist_for_each_safe(item, tmp, &e->head) {\n\t\tstruct simple_track *t = to_simple_track(item);\n\t\tif (cb(data, t->info))\n\t\t\teditable_remove_track(e, t);\n\t}\n}\n\nvoid editable_mark(struct editable *e, const char *filter)\n{\n\tstruct expr *expr = NULL;\n\tstruct simple_track *t;\n\n\tif (filter) {\n\t\texpr = parse_filter(filter);\n\t\tif (expr == NULL)\n\t\t\treturn;\n\t}\n\n\tlist_for_each_entry(t, &e->head, node) {\n\t\te->nr_marked -= t->marked;\n\t\tt->marked = 0;\n\t\tif (expr == NULL || expr_eval(expr, t->info)) {\n\t\t\tt->marked = 1;\n\t\t\te->nr_marked++;\n\t\t}\n\t}\n\n\tif (editable_owns_shared(e))\n\t\te->shared->win->changed = 1;\n}\n\nvoid editable_unmark(struct editable *e)\n{\n\tstruct simple_track *t;\n\n\tlist_for_each_entry(t, &e->head, node) {\n\t\te->nr_marked -= t->marked;\n\t\tt->marked = 0;\n\t}\n\n\tif (editable_owns_shared(e))\n\t\te->shared->win->changed = 1;\n}\n\nvoid editable_invert_marks(struct editable *e)\n{\n\tstruct simple_track *t;\n\n\tlist_for_each_entry(t, &e->head, node) {\n\t\te->nr_marked -= t->marked;\n\t\tt->marked ^= 1;\n\t\te->nr_marked += t->marked;\n\t}\n\n\tif (editable_owns_shared(e))\n\t\te->shared->win->changed = 1;\n}\n\nint _editable_for_each_sel(struct editable *e, track_info_cb cb, void *data,\n\t\tint reverse)\n{\n\tint rc = 0;\n\n\tif (e->nr_marked) {\n\t\t/* treat marked tracks as selected */\n\t\trc = simple_list_for_each_marked(&e->head, cb, data, reverse);\n\t} else {\n\t\tstruct simple_track *t = get_selected(e);\n\n\t\tif (t)\n\t\t\trc = cb(data, t->info);\n\t}\n\treturn rc;\n}\n\nint editable_for_each_sel(struct editable *e, track_info_cb cb, void *data,\n\t\tint reverse, int advance)\n{\n\tint rc;\n\n\trc = _editable_for_each_sel(e, cb, data, reverse);\n\tif (advance && e->nr_marked == 0 && editable_owns_shared(e))\n\t\twindow_down(e->shared->win, 1);\n\treturn rc;\n}\n\nint editable_for_each(struct editable *e, track_info_cb cb, void *data,\n\t\tint reverse)\n{\n\treturn simple_list_for_each(&e->head, cb, data, reverse);\n}\n\nvoid editable_update_track(struct editable *e, struct track_info *old, struct track_info *new)\n{\n\tstruct list_head *item, *tmp;\n\tint changed = 0;\n\n\tlist_for_each_safe(item, tmp, &e->head) {\n\t\tstruct simple_track *track = to_simple_track(item);\n\t\tif (track->info == old) {\n\t\t\tif (new) {\n\t\t\t\ttrack_info_unref(old);\n\t\t\t\ttrack_info_ref(new);\n\t\t\t\ttrack->info = new;\n\t\t\t} else {\n\t\t\t\teditable_remove_track(e, track);\n\t\t\t}\n\t\t\tchanged = 1;\n\t\t}\n\t}\n\tif (editable_owns_shared(e))\n\t\te->shared->win->changed |= changed;\n}\n\nvoid editable_rand(struct editable *e)\n{\n\tif (e->nr_tracks <=1)\n\t\treturn;\n\trand_list_rebuild(&e->head, &e->tree_root);\n\n\tif (editable_owns_shared(e)) {\n\t\twindow_changed(e->shared->win);\n\t\twindow_goto_top(e->shared->win);\n\t}\n}\n\nint editable_empty(struct editable *e)\n{\n\treturn list_empty(&e->head);\n}\n"
        },
        {
          "name": "editable.h",
          "type": "blob",
          "size": 3.0185546875,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2006 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_EDITABLE_H\n#define CMUS_EDITABLE_H\n\n#include \"window.h\"\n#include \"list.h\"\n#include \"rbtree.h\"\n#include \"track.h\"\n#include \"locking.h\"\n#include \"cmus.h\"\n\nstruct editable;\n\ntypedef void (*editable_free_track)(struct editable *e, struct list_head *head);\n\nstruct editable_shared {\n\tstruct editable *owner;\n\n\tstruct window *win;\n\tsort_key_t *sort_keys;\n\tchar sort_str[128];\n\teditable_free_track free_track;\n\tstruct searchable *searchable;\n};\n\nstruct editable {\n\tstruct list_head head;\n\tstruct rb_root tree_root;\n\tunsigned int nr_tracks;\n\tunsigned int nr_marked;\n\tunsigned int total_time;\n\tstruct editable_shared *shared;\n};\n\nvoid editable_shared_init(struct editable_shared *shared,\n\t\teditable_free_track free_track);\nvoid editable_shared_set_sort_keys(struct editable_shared *shared,\n\t\tsort_key_t *keys);\n\nvoid editable_init(struct editable *e, struct editable_shared *shared,\n\t\tint take_ownership);\nvoid editable_take_ownership(struct editable *e);\nvoid editable_add(struct editable *e, struct simple_track *track);\nvoid editable_add_before(struct editable *e, struct simple_track *track);\nvoid editable_remove_track(struct editable *e, struct simple_track *track);\nvoid editable_remove_sel(struct editable *e);\nvoid editable_sort(struct editable *e);\nvoid editable_rand(struct editable *e);\nvoid editable_toggle_mark(struct editable *e);\nvoid editable_move_after(struct editable *e);\nvoid editable_move_before(struct editable *e);\nvoid editable_clear(struct editable *e);\nvoid editable_remove_matching_tracks(struct editable *e,\n\t\tint (*cb)(void *data, struct track_info *ti), void *data);\nvoid editable_mark(struct editable *e, const char *filter);\nvoid editable_unmark(struct editable *e);\nvoid editable_invert_marks(struct editable *e);\nint _editable_for_each_sel(struct editable *e, track_info_cb cb, void *data,\n\t\tint reverse);\nint editable_for_each_sel(struct editable *e, track_info_cb cb, void *data,\n\t\tint reverse, int advance);\nint editable_for_each(struct editable *e, track_info_cb cb, void *data,\n\t\tint reverse);\nvoid editable_update_track(struct editable *e, struct track_info *old, struct track_info *new);\nint editable_empty(struct editable *e);\n\nstatic inline void editable_track_to_iter(struct editable *e, struct simple_track *track, struct iter *iter)\n{\n\titer->data0 = &e->head;\n\titer->data1 = track;\n\titer->data2 = NULL;\n}\n\n#endif\n"
        },
        {
          "name": "expr.c",
          "type": "blob",
          "size": 21.306640625,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2005 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"expr.h\"\n#include \"glob.h\"\n#include \"uchar.h\"\n#include \"track_info.h\"\n#include \"comment.h\"\n#include \"xmalloc.h\"\n#include \"utils.h\"\n#include \"debug.h\"\n#include \"list.h\"\n#include \"ui_curses.h\" /* using_utf8, charset */\n#include \"convert.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <limits.h>\n\nenum token_type {\n\t/* special chars */\n\tTOK_NOT,\n\tTOK_LT,\n\tTOK_GT,\n\n#define NR_COMBINATIONS TOK_EQ\n\n\t/* special chars */\n\tTOK_EQ,\n\tTOK_AND,\n\tTOK_OR,\n\tTOK_LPAREN,\n\tTOK_RPAREN,\n\n#define NR_SPECIALS TOK_NE\n#define COMB_BASE TOK_NE\n\n\t/* same as the first 3 + '=' */\n\tTOK_NE,\n\tTOK_LE,\n\tTOK_GE,\n\n\tTOK_KEY,\n\tTOK_INT_OR_KEY,\n\tTOK_STR\n};\n#define NR_TOKS (TOK_STR + 1)\n\nstruct token {\n\tstruct list_head node;\n\tenum token_type type;\n\t/* for TOK_KEY, TOK_INT_OR_KEY and TOK_STR */\n\tchar str[];\n};\n\n/* same order as TOK_* */\nstatic const char specials[NR_SPECIALS] = \"!<>=&|()\";\n\nstatic const int tok_to_op[NR_TOKS] = {\n\t-1, OP_LT, OP_GT, OP_EQ, -1, -1, -1, -1, OP_NE, OP_LE, OP_GE, -1, -1, -1\n};\n\nstatic const char * const op_names[NR_OPS] = { \"<\", \"<=\", \"=\", \">=\", \">\", \"!=\" };\nstatic const char * const expr_names[NR_EXPRS] = {\n\t\"&\", \"|\", \"!\", \"a string\", \"an integer\", \"a boolean\"\n};\n\nstatic char error_buf[64] = { 0, };\n\n\nstatic void set_error(const char *format, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, format);\n\tvsnprintf(error_buf, sizeof(error_buf), format, ap);\n\tva_end(ap);\n}\n\nstatic struct token *get_str(const char *str, int *idxp)\n{\n\tstruct token *tok;\n\tint s = *idxp + 1;\n\tint e = s;\n\n\t/* can't remove all backslashes here => don't remove any */\n\twhile (str[e] != '\"') {\n\t\tint c = str[e];\n\n\t\tif (c == 0)\n\t\t\tgoto err;\n\t\tif (c == '\\\\') {\n\t\t\tif (str[e + 1] == 0)\n\t\t\t\tgoto err;\n\t\t\te += 2;\n\t\t\tcontinue;\n\t\t}\n\t\te++;\n\t}\n\n\ttok = xmalloc(sizeof(struct token) + e - s + 1);\n\tmemcpy(tok->str, str + s, e - s);\n\ttok->str[e - s] = 0;\n\ttok->type = TOK_STR;\n\t*idxp = e + 1;\n\treturn tok;\nerr:\n\tset_error(\"end of expression at middle of string\");\n\treturn NULL;\n}\n\nstatic struct token *get_int_or_key(const char *str, int *idxp)\n{\n\tint s = *idxp;\n\tint e = s;\n\tint digits_only = 1;\n\tstruct token *tok;\n\n\tif (str[e] == '-')\n\t\te++;\n\twhile (str[e]) {\n\t\tint i, c = str[e];\n\n\t\tif (isspace(c))\n\t\t\tgoto out;\n\t\tfor (i = 0; i < NR_SPECIALS; i++) {\n\t\t\tif (c == specials[i])\n\t\t\t\tgoto out;\n\t\t}\n\t\tif (c < '0' || c > '9') {\n\t\t\tdigits_only = 0;\n\t\t\tif (!isalpha(c) && c != '_' && c != '-') {\n\t\t\t\tset_error(\"unexpected '%c'\", c);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\te++;\n\t}\nout:\n\ttok = xmalloc(sizeof(struct token) + e - s + 1);\n\tmemcpy(tok->str, str + s, e - s);\n\ttok->str[e - s] = 0;\n\ttok->type = TOK_KEY;\n\tif (digits_only)\n\t\ttok->type = TOK_INT_OR_KEY;\n\t*idxp = e;\n\treturn tok;\n}\n\nstatic struct token *get_token(const char *str, int *idxp)\n{\n\tint idx = *idxp;\n\tint c, i;\n\n\tc = str[idx];\n\tfor (i = 0; i < NR_SPECIALS; i++) {\n\t\tstruct token *tok;\n\n\t\tif (c != specials[i])\n\t\t\tcontinue;\n\n\t\tidx++;\n\t\ttok = xnew(struct token, 1);\n\t\ttok->type = i;\n\t\tif (i < NR_COMBINATIONS && str[idx] == '=') {\n\t\t\ttok->type = COMB_BASE + i;\n\t\t\tidx++;\n\t\t}\n\t\t*idxp = idx;\n\t\treturn tok;\n\t}\n\tif (c == '\"')\n\t\treturn get_str(str, idxp);\n\treturn get_int_or_key(str, idxp);\n}\n\nstatic void free_tokens(struct list_head *head)\n{\n\tstruct list_head *item = head->next;\n\n\twhile (item != head) {\n\t\tstruct list_head *next = item->next;\n\t\tstruct token *tok = container_of(item, struct token, node);\n\n\t\tfree(tok);\n\t\titem = next;\n\t}\n}\n\nstatic int tokenize(struct list_head *head, const char *str)\n{\n\tstruct token *tok;\n\tint idx = 0;\n\n\twhile (1) {\n\t\twhile (isspace(str[idx]))\n\t\t\t++idx;\n\t\tif (str[idx] == 0)\n\t\t\tbreak;\n\t\ttok = get_token(str, &idx);\n\t\tif (tok == NULL) {\n\t\t\tfree_tokens(head);\n\t\t\treturn -1;\n\t\t}\n\t\tlist_add_tail(&tok->node, head);\n\t}\n\treturn 0;\n}\n\nstatic struct expr *expr_new(int type)\n{\n\tstruct expr *new = xnew0(struct expr, 1);\n\n\tnew->type = type;\n\n\treturn new;\n}\n\nstatic int parse(struct expr **rootp, struct list_head *head, struct list_head **itemp, int level);\n\nstatic int parse_one(struct expr **exprp, struct list_head *head, struct list_head **itemp)\n{\n\tstruct list_head *item = *itemp;\n\tstruct token *tok;\n\tenum token_type type;\n\tint rc;\n\n\t*exprp = NULL;\n\tif (item == head) {\n\t\tset_error(\"expression expected\");\n\t\treturn -1;\n\t}\n\n\ttok = container_of(item, struct token, node);\n\ttype = tok->type;\n\tif (type == TOK_NOT) {\n\t\tstruct expr *new, *tmp;\n\n\t\t*itemp = item->next;\n\t\trc = parse_one(&tmp, head, itemp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tnew = expr_new(EXPR_NOT);\n\t\tnew->left = tmp;\n\t\t*exprp = new;\n\t\treturn 0;\n\t} else if (type == TOK_LPAREN) {\n\t\t*itemp = item->next;\n\t\t*exprp = NULL;\n\t\treturn parse(exprp, head, itemp, 1);\n\t\t/* ')' already eaten */\n\t} else if (type == TOK_KEY || type == TOK_INT_OR_KEY) {\n\t\tconst char *key = tok->str;\n\t\tstruct expr *new;\n\t\tint op = -1;\n\n\t\titem = item->next;\n\t\tif (item != head) {\n\t\t\ttok = container_of(item, struct token, node);\n\t\t\top = tok_to_op[tok->type];\n\t\t}\n\t\tif (item == head || op == -1) {\n\t\t\t/* must be a bool */\n\t\t\tnew = expr_new(EXPR_BOOL);\n\t\t\tnew->key = xstrdup(key);\n\t\t\t*itemp = item;\n\t\t\t*exprp = new;\n\t\t\treturn 0;\n\t\t}\n\t\titem = item->next;\n\t\tif (item == head) {\n\t\t\tset_error(\"right side of expression expected\");\n\t\t\treturn -1;\n\t\t}\n\t\ttok = container_of(item, struct token, node);\n\t\ttype = tok->type;\n\t\t*itemp = item->next;\n\t\tif (type == TOK_STR) {\n\t\t\tif (op != OP_EQ && op != OP_NE) {\n\t\t\t\tset_error(\"invalid string operator '%s'\", op_names[op]);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tnew = expr_new(EXPR_STR);\n\t\t\tnew->key = xstrdup(key);\n\t\t\tglob_compile(&new->estr.glob_head, tok->str);\n\t\t\tnew->estr.op = op;\n\t\t\t*exprp = new;\n\t\t\treturn 0;\n\t\t} else if (type == TOK_INT_OR_KEY) {\n\t\t\tlong int val = 0;\n\n\t\t\tif (str_to_int(tok->str, &val)) {\n\t\t\t}\n\t\t\tnew = expr_new(EXPR_INT);\n\t\t\tnew->key = xstrdup(key);\n\t\t\tnew->eint.val = val;\n\t\t\tnew->eint.op = op;\n\t\t\t*exprp = new;\n\t\t\treturn 0;\n\t\t} else if (type == TOK_KEY) {\n\t\t\tnew = expr_new(EXPR_ID);\n\t\t\tnew->key = xstrdup(key);\n\t\t\tnew->eid.key = xstrdup(tok->str);\n\t\t\tnew->eid.op = op;\n\t\t\t*exprp = new;\n\t\t\treturn 0;\n\t\t}\n\t\tif (op == OP_EQ || op == OP_NE) {\n\t\t\tset_error(\"integer or string expected\");\n\t\t} else {\n\t\t\tset_error(\"integer expected\");\n\t\t}\n\t\treturn -1;\n\t}\n\tset_error(\"key expected\");\n\treturn -1;\n}\n\nstatic void add(struct expr **rootp, struct expr *expr)\n{\n\tstruct expr *tmp, *root = *rootp;\n\n\tif (root == NULL) {\n\t\t*rootp = expr;\n\t\treturn;\n\t}\n\n\ttmp = root;\n\twhile (tmp->right)\n\t\ttmp = tmp->right;\n\tif (tmp->type <= EXPR_OR) {\n\t\t/* tmp is binary, tree is incomplete */\n\t\ttmp->right = expr;\n\t\texpr->parent = tmp;\n\t\treturn;\n\t}\n\n\t/* tmp is unary, tree is complete\n\t * expr must be a binary operator */\n\tBUG_ON(expr->type > EXPR_OR);\n\n\texpr->left = root;\n\troot->parent = expr;\n\t*rootp = expr;\n}\n\nstatic int parse(struct expr **rootp, struct list_head *head, struct list_head **itemp, int level)\n{\n\tstruct list_head *item = *itemp;\n\n\twhile (1) {\n\t\tstruct token *tok;\n\t\tstruct expr *expr;\n\t\tint rc, type;\n\n\t\trc = parse_one(&expr, head, &item);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tadd(rootp, expr);\n\t\tif (item == head) {\n\t\t\tif (level > 0) {\n\t\t\t\tset_error(\"')' expected\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t*itemp = item;\n\t\t\treturn 0;\n\t\t}\n\t\ttok = container_of(item, struct token, node);\n\t\tif (tok->type == TOK_RPAREN) {\n\t\t\tif (level == 0) {\n\t\t\t\tset_error(\"unexpected ')'\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t*itemp = item->next;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (tok->type == TOK_AND) {\n\t\t\ttype = EXPR_AND;\n\t\t} else if (tok->type == TOK_OR) {\n\t\t\ttype = EXPR_OR;\n\t\t} else {\n\t\t\tset_error(\"'&' or '|' expected\");\n\t\t\treturn -1;\n\t\t}\n\t\texpr = expr_new(type);\n\t\tadd(rootp, expr);\n\t\titem = item->next;\n\t}\n}\n\nstatic const struct {\n\tchar short_key;\n\tconst char *long_key;\n} map_short2long[] = {\n\t{ 'A',\t\"albumartist\"\t},\n\t{ 'D',\t\"discnumber\"\t},\n\t{ 'T',\t\"tag\",\t\t},\n\t{ 'a',\t\"artist\"\t},\n\t{ 'c',\t\"comment\"\t},\n\t{ 'd',\t\"duration\"\t},\n\t{ 'f',\t\"filename\"\t},\n\t{ 'g',\t\"genre\"\t\t},\n\t{ 'l',\t\"album\"\t\t},\n\t{ 'n',\t\"tracknumber\"\t},\n\t{ 'X',\t\"play_count\"\t},\n\t{ 's',\t\"stream\"\t},\n\t{ 't',\t\"title\"\t\t},\n\t{ 'y',\t\"date\"\t\t},\n\t{ '\\0',\tNULL\t\t},\n};\n\nstatic const struct {\n\tconst char *key;\n\tenum expr_type type;\n} builtin[] = {\n\t{ \"album\",\tEXPR_STR\t},\n\t{ \"albumartist\",EXPR_STR\t},\n\t{ \"artist\",\tEXPR_STR\t},\n\t{ \"bitrate\",\tEXPR_INT\t},\n\t{ \"bpm\",\tEXPR_INT\t},\n\t{ \"codec\",\tEXPR_STR\t},\n\t{ \"codec_profile\",EXPR_STR\t},\n\t{ \"comment\",\tEXPR_STR\t},\n\t{ \"date\",\tEXPR_INT\t},\n\t{ \"discnumber\", EXPR_INT\t},\n\t{ \"duration\",\tEXPR_INT\t},\n\t{ \"filename\",\tEXPR_STR\t},\n\t{ \"genre\",\tEXPR_STR\t},\n\t{ \"media\",\tEXPR_STR\t},\n\t{ \"originaldate\",EXPR_INT\t},\n\t{ \"play_count\", EXPR_INT\t},\n\t{ \"stream\",\tEXPR_BOOL\t},\n\t{ \"tag\",\tEXPR_BOOL\t},\n\t{ \"title\",\tEXPR_STR\t},\n\t{ \"tracknumber\",EXPR_INT\t},\n\t{ NULL,\t\t-1\t\t},\n};\n\nstatic const char *lookup_long_key(char c)\n{\n\tint i;\n\tfor (i = 0; map_short2long[i].short_key; i++) {\n\t\tif (map_short2long[i].short_key == c)\n\t\t\treturn map_short2long[i].long_key;\n\t}\n\treturn NULL;\n}\n\nstatic enum expr_type lookup_key_type(const char *key)\n{\n\tint i;\n\tfor (i = 0; builtin[i].key; i++) {\n\t\tint cmp = strcmp(key, builtin[i].key);\n\t\tif (cmp == 0)\n\t\t\treturn builtin[i].type;\n\t\tif (cmp < 0)\n\t\t\tbreak;\n\t}\n\treturn -1;\n}\n\nstatic unsigned long stack4_new(void)\n{\n\treturn 0;\n}\nstatic void stack4_push(unsigned long *s, unsigned long e)\n{\n\t*s = (*s << 4) | e;\n}\nstatic void stack4_pop(unsigned long *s)\n{\n\t*s = *s >> 4;\n}\nstatic unsigned long stack4_top(unsigned long s)\n{\n\treturn s & 0xf;\n}\nstatic void stack4_replace_top(unsigned long *s, unsigned long e)\n{\n\t*s = (*s & ~0xf) | e;\n}\n\nstatic char *expand_short_expr(const char *expr_short)\n{\n\t/* state space, can contain maximal 15 states */\n\tenum state_type {\n\t\tST_SKIP_SPACE = 1,\n\t\tST_TOP,\n\t\tST_EXPECT_KEY,\n\t\tST_EXPECT_OP,\n\t\tST_EXPECT_INT,\n\t\tST_IN_INT,\n\t\tST_MEM_INT,\n\t\tST_IN_2ND_INT,\n\t\tST_EXPECT_STR,\n\t\tST_IN_QUOTE_STR,\n\t\tST_IN_STR,\n\t};\n\n\tsize_t len_expr_short = strlen(expr_short);\n\t/* worst case blowup of expr_short is 31/5 (e.g. ~n1-2), so take x7:\n\t * strlen(\"~n1-2\") == 5\n\t * strlen(\"(tracknumber>=1&tracknumber<=2)\") == 31\n\t */\n\tchar *out = xnew(char, len_expr_short * 7);\n\tchar *num = NULL;\n\tsize_t i, i_num = 0, k = 0;\n\tconst char *key = NULL;\n\tint level = 0;\n\tenum expr_type etype;\n\t/* used as state-stack, can contain at least 32/4 = 8 states */\n\tunsigned long state_stack = stack4_new();\n\tstack4_push(&state_stack, ST_TOP);\n\tstack4_push(&state_stack, ST_SKIP_SPACE);\n\n\t/* include terminal '\\0' to recognize end of string */\n\tfor (i = 0; i <= len_expr_short; i++) {\n\t\tunsigned char c = expr_short[i];\n\t\tswitch (stack4_top(state_stack)) {\n\t\tcase ST_SKIP_SPACE:\n\t\t\tif (c != ' ') {\n\t\t\t\tstack4_pop(&state_stack);\n\t\t\t\ti--;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ST_TOP:\n\t\t\tswitch (c) {\n\t\t\tcase '~':\n\t\t\t\tstack4_push(&state_stack, ST_EXPECT_OP);\n\t\t\t\tstack4_push(&state_stack, ST_SKIP_SPACE);\n\t\t\t\tstack4_push(&state_stack, ST_EXPECT_KEY);\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\tlevel++;\n\t\t\t/* Fall through */\n\t\t\tcase '!':\n\t\t\tcase '|':\n\t\t\t\tout[k++] = c;\n\t\t\t\tstack4_push(&state_stack, ST_SKIP_SPACE);\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\tlevel--;\n\t\t\t\tout[k++] = c;\n\t\t\t\tstack4_push(&state_stack, ST_EXPECT_OP);\n\t\t\t\tstack4_push(&state_stack, ST_SKIP_SPACE);\n\t\t\t\tbreak;\n\t\t\tcase '\\0':\n\t\t\t\tif (level > 0) {\n\t\t\t\t\tset_error(\"')' expected\");\n\t\t\t\t\tgoto error_exit;\n\t\t\t\t}\n\t\t\t\tout[k++] = c;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tset_error(\"unexpected '%c'\", c);\n\t\t\t\tgoto error_exit;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ST_EXPECT_KEY:\n\t\t\tstack4_pop(&state_stack);\n\t\t\tkey = lookup_long_key(c);\n\t\t\tif (!key) {\n\t\t\t\tset_error(\"unknown short key %c\", c);\n\t\t\t\tgoto error_exit;\n\t\t\t}\n\t\t\tetype = lookup_key_type(key);\n\t\t\tif (etype == EXPR_INT) {\n\t\t\t\tstack4_push(&state_stack, ST_EXPECT_INT);\n\t\t\t\tout[k++] = '(';\n\t\t\t} else if (etype == EXPR_STR) {\n\t\t\t\tstack4_push(&state_stack, ST_EXPECT_STR);\n\t\t\t} else if (etype != EXPR_BOOL) {\n\t\t\t\tBUG(\"wrong etype: %d\\n\", etype);\n\t\t\t}\n\t\t\tstrcpy(out+k, key);\n\t\t\tk += strlen(key);\n\t\t\tstack4_push(&state_stack, ST_SKIP_SPACE);\n\t\t\tbreak;\n\t\tcase ST_EXPECT_OP:\n\t\t\tif (c == '~' || c == '(' || c == '!')\n\t\t\t\tout[k++] = '&';\n\t\t\ti--;\n\t\t\tstack4_replace_top(&state_stack, ST_SKIP_SPACE);\n\t\t\tbreak;\n\t\tcase ST_EXPECT_INT:\n\t\t\tif (c == '<' || c == '>') {\n\t\t\t\tout[k++] = c;\n\t\t\t\tstack4_replace_top(&state_stack, ST_IN_INT);\n\t\t\t} else if (c == '-') {\n\t\t\t\tout[k++] = '<';\n\t\t\t\tout[k++] = '=';\n\t\t\t\tstack4_replace_top(&state_stack, ST_IN_INT);\n\t\t\t} else if (isdigit(c)) {\n\t\t\t\tif (!num)\n\t\t\t\t\tnum = xnew(char, len_expr_short);\n\t\t\t\tnum[i_num++] = c;\n\t\t\t\tstack4_replace_top(&state_stack, ST_MEM_INT);\n\t\t\t} else {\n\t\t\t\tset_error(\"integer expected\", expr_short);\n\t\t\t\tgoto error_exit;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ST_IN_INT:\n\t\t\tif (isdigit(c)) {\n\t\t\t\tout[k++] = c;\n\t\t\t} else {\n\t\t\t\ti -= 1;\n\t\t\t\tstack4_pop(&state_stack);\n\t\t\t\tout[k++] = ')';\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ST_MEM_INT:\n\t\t\tif (isdigit(c)) {\n\t\t\t\tnum[i_num++] = c;\n\t\t\t} else {\n\t\t\t\tif (c == '-') {\n\t\t\t\t\tout[k++] = '>';\n\t\t\t\t\tout[k++] = '=';\n\t\t\t\t\tstack4_replace_top(&state_stack, ST_IN_2ND_INT);\n\t\t\t\t} else {\n\t\t\t\t\tout[k++] = '=';\n\t\t\t\t\ti--;\n\t\t\t\t\tstack4_pop(&state_stack);\n\t\t\t\t}\n\t\t\t\tstrncpy(out+k, num, i_num);\n\t\t\t\tk += i_num;\n\t\t\t\ti_num = 0;\n\t\t\t\tif (c != '-')\n\t\t\t\t\tout[k++] = ')';\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ST_IN_2ND_INT:\n\t\t\tif (isdigit(c)) {\n\t\t\t\tnum[i_num++] = c;\n\t\t\t} else {\n\t\t\t\ti--;\n\t\t\t\tstack4_pop(&state_stack);\n\t\t\t\tif (i_num > 0) {\n\t\t\t\t\tout[k++] = '&';\n\t\t\t\t\tstrcpy(out+k, key);\n\t\t\t\t\tk += strlen(key);\n\t\t\t\t\tout[k++] = '<';\n\t\t\t\t\tout[k++] = '=';\n\t\t\t\t\tstrncpy(out+k, num, i_num);\n\t\t\t\t\tk += i_num;\n\t\t\t\t}\n\t\t\t\tout[k++] = ')';\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ST_EXPECT_STR:\n\t\t\tout[k++] = '=';\n\t\t\tif (c == '\"') {\n\t\t\t\tstack4_replace_top(&state_stack, ST_IN_QUOTE_STR);\n\t\t\t\tout[k++] = c;\n\t\t\t} else {\n\t\t\t\tstack4_replace_top(&state_stack, ST_IN_STR);\n\t\t\t\tout[k++] = '\"';\n\t\t\t\tout[k++] = '*';\n\t\t\t\tout[k++] = c;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ST_IN_QUOTE_STR:\n\t\t\tif (c == '\"' && expr_short[i-1] != '\\\\') {\n\t\t\t\tstack4_pop(&state_stack);\n\t\t\t}\n\t\t\tout[k++] = c;\n\t\t\tbreak;\n\t\tcase ST_IN_STR:\n\t\t\t/* isalnum() doesn't work for multi-byte characters */\n\t\t\tif (c != '~' && c != '!' && c != '|' &&\n\t\t\t\t\tc != '(' && c != ')' && c != '\\0') {\n\t\t\t\tout[k++] = c;\n\t\t\t} else {\n\t\t\t\twhile (k > 0 && out[k-1] == ' ')\n\t\t\t\t\tk--;\n\t\t\t\tout[k++] = '*';\n\t\t\t\tout[k++] = '\"';\n\t\t\t\ti--;\n\t\t\t\tstack4_pop(&state_stack);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG(\"state %ld not covered\", stack4_top(state_stack));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (num)\n\t\tfree(num);\n\n\td_print(\"expanded \\\"%s\\\" to \\\"%s\\\"\\n\", expr_short, out);\n\n\treturn out;\n\nerror_exit:\n\tif (num)\n\t\tfree(num);\n\tfree(out);\n\treturn NULL;\n}\n\nint expr_is_short(const char *str)\n{\n\tint i;\n\tfor (i = 0; str[i]; i++) {\n\t\tif (str[i] == '~')\n\t\t\treturn 1;\n\t\tif (str[i] != '!' && str[i] != '(' && str[i] != ' ')\n\t\t\treturn 0;\n\t}\n\treturn 0;\n}\n\nstruct expr *expr_parse(const char *str)\n{\n\treturn expr_parse_i(str, \"filter contains control characters\", 1);\n}\n\nstruct expr *expr_parse_i(const char *str, const char *err_msg, int check_short)\n{\n\tLIST_HEAD(head);\n\tstruct expr *root = NULL;\n\tstruct list_head *item;\n\tchar *long_str = NULL, *u_str = NULL;\n\tint i;\n\n\tfor (i = 0; str[i]; i++) {\n\t\tunsigned char c = str[i];\n\t\tif (c < 0x20) {\n\t\t\tset_error(err_msg);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (!using_utf8 && utf8_encode(str, charset, &u_str) == 0) {\n\t\tstr = u_str;\n\t}\n\tif (!u_is_valid(str)) {\n\t\tset_error(\"invalid UTF-8\");\n\t\tgoto out;\n\t}\n\n\tif (check_short && expr_is_short(str)) {\n\t\tstr = long_str = expand_short_expr(str);\n\t\tif (!str)\n\t\t\tgoto out;\n\t}\n\n\tif (tokenize(&head, str))\n\t\tgoto out;\n\n\titem = head.next;\n\tif (parse(&root, &head, &item, 0))\n\t\troot = NULL;\n\tfree_tokens(&head);\n\nout:\n\tfree(u_str);\n\tfree(long_str);\n\treturn root;\n}\n\nint expr_check_leaves(struct expr **exprp, const char *(*get_filter)(const char *name))\n{\n\tstruct expr *expr = *exprp;\n\tstruct expr *e;\n\tconst char *filter;\n\tint i, rc;\n\n\tif (expr->left) {\n\t\tif (expr_check_leaves(&expr->left, get_filter))\n\t\t\treturn -1;\n\t\tif (expr->right)\n\t\t\treturn expr_check_leaves(&expr->right, get_filter);\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; builtin[i].key; i++) {\n\t\tint cmp = strcmp(expr->key, builtin[i].key);\n\n\t\tif (cmp > 0)\n\t\t\tcontinue;\n\t\tif (cmp < 0)\n\t\t\tbreak;\n\n\t\tif (builtin[i].type != expr->type) {\n\t\t\t/* type mismatch */\n\t\t\tset_error(\"%s is %s\", builtin[i].key, expr_names[builtin[i].type]);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (expr->type != EXPR_BOOL) {\n\t\t/* unknown key */\n\t\tset_error(\"unknown key %s\", expr->key);\n\t\treturn -1;\n\t}\n\n\t/* user defined filter */\n\tfilter = get_filter(expr->key);\n\tif (filter == NULL) {\n\t\tset_error(\"unknown filter or boolean %s\", expr->key);\n\t\treturn -1;\n\t}\n\te = expr_parse(filter);\n\tif (e == NULL) {\n\t\treturn -1;\n\t}\n\trc = expr_check_leaves(&e, get_filter);\n\tif (rc) {\n\t\texpr_free(e);\n\t\treturn rc;\n\t}\n\n\t/* replace */\n\te->parent = expr->parent;\n\texpr_free(expr);\n\n\t/* this sets parents left pointer */\n\t*exprp = e;\n\treturn 0;\n}\n\nunsigned int expr_get_match_type(struct expr *expr)\n{\n\tconst char *key;\n\n\tif (expr->left) {\n\t\tunsigned int left = expr_get_match_type(expr->left);\n\t\tif (expr->type == EXPR_AND || expr->type == EXPR_OR)\n\t\t\treturn left | expr_get_match_type(expr->right);\n\t\treturn left;\n\t}\n\n\tkey = expr->key;\n\tif (strcmp(key, \"artist\") == 0 || strcmp(key, \"albumartist\") == 0)\n\t\treturn TI_MATCH_ARTIST;\n\tif (strcmp(key, \"album\") == 0 || strcmp(key, \"discnumber\") == 0)\n\t\treturn TI_MATCH_ALBUM;\n\tif (strcmp(key, \"title\") == 0 || strcmp(key, \"tracknumber\") == 0)\n\t\treturn TI_MATCH_TITLE;\n\n\treturn 0;\n}\n\nint expr_is_harmless(const struct expr *expr)\n{\n\tswitch (expr->type) {\n\tcase EXPR_OR:\n\tcase EXPR_NOT:\n\t\treturn 0;\n\tcase EXPR_AND:\n\t\texpr = expr->right;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (expr->type == EXPR_INT) {\n\t\tswitch (expr->eint.op) {\n\t\tcase IOP_LT:\n\t\tcase IOP_EQ:\n\t\tcase IOP_LE:\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif (expr->type == EXPR_ID)\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic const char *str_val(const char *key, struct track_info *ti, char **need_free)\n{\n\tconst char *val;\n\t*need_free = NULL;\n\tif (strcmp(key, \"filename\") == 0) {\n\t\tval = ti->filename;\n\t\tif (!using_utf8 && utf8_encode(val, charset, need_free) == 0) {\n\t\t\tval = *need_free;\n\t\t}\n\t} else if (strcmp(key, \"codec\") == 0) {\n\t\tval = ti->codec;\n\t} else if (strcmp(key, \"codec_profile\") == 0) {\n\t\tval = ti->codec_profile;\n\t} else {\n\t\tval = keyvals_get_val(ti->comments, key);\n\t}\n\treturn val;\n}\n\nstatic int int_val(const char *key, struct track_info *ti)\n{\n\tint val;\n\tif (strcmp(key, \"duration\") == 0) {\n\t\tval = ti->duration;\n\t\t/* duration of a stream is infinite (well, almost) */\n\t\tif (is_http_url(ti->filename))\n\t\t\tval = INT_MAX;\n\t} else if (strcmp(key, \"date\") == 0) {\n\t\tval = (ti->date >= 0) ? (ti->date / 10000) : -1;\n\t} else if (strcmp(key, \"originaldate\") == 0) {\n\t\tval = (ti->originaldate >= 0) ? (ti->originaldate / 10000) : -1;\n\t} else if (strcmp(key, \"bitrate\") == 0) {\n\t\tval = (ti->bitrate >= 0) ? (int) (ti->bitrate / 1000. + 0.5) : -1;\n\t} else if (strcmp(key, \"play_count\") == 0) {\n\t\tval = ti->play_count;\n\t} else if (strcmp(key, \"bpm\") == 0) {\n\t\tval = ti->bpm;\n\t} else {\n\t\tval = comments_get_int(ti->comments, key);\n\t}\n\treturn val;\n}\n\nint expr_op_to_bool(int res, int op)\n{\n\tswitch (op) {\n\tcase OP_LT:\n\t\treturn res < 0;\n\tcase OP_LE:\n\t\treturn res <= 0;\n\tcase OP_EQ:\n\t\treturn res == 0;\n\tcase OP_GE:\n\t\treturn res >= 0;\n\tcase OP_GT:\n\t\treturn res > 0;\n\tcase OP_NE:\n\t\treturn res != 0;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nint expr_eval(struct expr *expr, struct track_info *ti)\n{\n\tenum expr_type type = expr->type;\n\tconst char *key;\n\n\tif (expr->left) {\n\t\tint left = expr_eval(expr->left, ti);\n\n\t\tif (type == EXPR_AND)\n\t\t\treturn left && expr_eval(expr->right, ti);\n\t\tif (type == EXPR_OR)\n\t\t\treturn left || expr_eval(expr->right, ti);\n\t\t/* EXPR_NOT */\n\t\treturn !left;\n\t}\n\n\tkey = expr->key;\n\tif (type == EXPR_STR) {\n\t\tint res;\n\t\tchar *need_free;\n\t\tconst char *val = str_val(key, ti, &need_free);\n\t\tif (!val)\n\t\t\tval = \"\";\n\t\tres = glob_match(&expr->estr.glob_head, val);\n\t\tfree(need_free);\n\t\tif (expr->estr.op == SOP_EQ)\n\t\t\treturn res;\n\t\treturn !res;\n\t} else if (type == EXPR_INT) {\n\t\tint val = int_val(key, ti);\n\t\tint res;\n\t\tif (expr->eint.val == -1) {\n\t\t\t/* -1 is \"not set\"\n\t\t\t * doesn't make sense to do 123 < \"not set\"\n\t\t\t * but it makes sense to do date=-1 (date is not set)\n\t\t\t */\n\t\t\tif (expr->eint.op == IOP_EQ)\n\t\t\t\treturn val == -1;\n\t\t\tif (expr->eint.op == IOP_NE)\n\t\t\t\treturn val != -1;\n\t\t}\n\t\tif (val == -1) {\n\t\t\t/* tag not set, can't compare */\n\t\t\treturn 0;\n\t\t}\n\t\tres = val - expr->eint.val;\n\t\treturn expr_op_to_bool(res, expr->eint.op);\n\t} else if (type == EXPR_ID) {\n\t\tint a = 0, b = 0;\n\t\tconst char *sa, *sb;\n\t\tchar *fa, *fb;\n\t\tint res = 0;\n\t\tif ((sa = str_val(key, ti, &fa))) {\n\t\t\tif ((sb = str_val(expr->eid.key, ti, &fb))) {\n\t\t\t\tres = strcmp(sa, sb);\n\t\t\t\tfree(fa);\n\t\t\t\tfree(fb);\n\t\t\t\treturn expr_op_to_bool(res, expr->eid.op);\n\t\t\t}\n\t\t\tfree(fa);\n\t\t} else {\n\t\t\ta = int_val(key, ti);\n\t\t\tb = int_val(expr->eid.key, ti);\n\t\t\tres = a - b;\n\t\t\tif (a == -1 || b == -1) {\n\t\t\t\tswitch (expr->eid.op) {\n\t\t\t\tcase KOP_EQ:\n\t\t\t\t\treturn res == 0;\n\t\t\t\tcase KOP_NE:\n\t\t\t\t\treturn res != 0;\n\t\t\t\tdefault:\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn expr_op_to_bool(res, expr->eid.op);\n\t\t}\n\t\treturn res;\n\t}\n\tif (strcmp(key, \"stream\") == 0)\n\t\treturn is_http_url(ti->filename);\n\treturn track_info_has_tag(ti);\n}\n\nvoid expr_free(struct expr *expr)\n{\n\tif (expr->left) {\n\t\texpr_free(expr->left);\n\t\tif (expr->right)\n\t\t\texpr_free(expr->right);\n\t}\n\tfree(expr->key);\n\tif (expr->type == EXPR_STR)\n\t\tglob_free(&expr->estr.glob_head);\n\telse if (expr->type == EXPR_ID)\n\t\tfree(expr->eid.key);\n\tfree(expr);\n}\n\nconst char *expr_error(void)\n{\n\treturn error_buf;\n}\n"
        },
        {
          "name": "expr.h",
          "type": "blob",
          "size": 2.142578125,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2005 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_EXPR_H\n#define CMUS_EXPR_H\n\n#include \"track_info.h\"\n#include \"list.h\"\n\nenum { OP_LT, OP_LE, OP_EQ, OP_GE, OP_GT, OP_NE };\n#define NR_OPS (OP_NE + 1)\n\nenum expr_type {\n\tEXPR_AND,\n\tEXPR_OR,\n\n\tEXPR_NOT,\n\n\tEXPR_STR,\n\tEXPR_INT,\n\tEXPR_ID,\n\tEXPR_BOOL\n};\n#define NR_EXPRS (EXPR_BOOL + 1)\n\nstruct expr {\n\tstruct expr *left, *right, *parent;\n\tenum expr_type type;\n\tchar *key;\n\tunion {\n\t\tstruct {\n\t\t\tstruct list_head glob_head;\n\t\t\tenum {\n\t\t\t\tSOP_EQ = OP_EQ,\n\t\t\t\tSOP_NE = OP_NE\n\t\t\t} op;\n\t\t} estr;\n\t\tstruct {\n\t\t\tint val;\n\t\t\tenum {\n\t\t\t\tIOP_LT = OP_LT,\n\t\t\t\tIOP_LE = OP_LE,\n\t\t\t\tIOP_EQ = OP_EQ,\n\t\t\t\tIOP_GE = OP_GE,\n\t\t\t\tIOP_GT = OP_GT,\n\t\t\t\tIOP_NE = OP_NE\n\t\t\t} op;\n\t\t} eint;\n\t\tstruct {\n\t\t\tchar* key;\n\t\t\tenum {\n\t\t\t\tKOP_LT = OP_LT,\n\t\t\t\tKOP_LE = OP_LE,\n\t\t\t\tKOP_EQ = OP_EQ,\n\t\t\t\tKOP_GE = OP_GE,\n\t\t\t\tKOP_GT = OP_GT,\n\t\t\t\tKOP_NE = OP_NE\n\t\t\t} op;\n\t\t} eid;\n\t};\n};\n\nstruct expr *expr_parse(const char *str);\nstruct expr* expr_parse_i(const char *str, const char *err_msg, int check_short);\nint expr_check_leaves(struct expr **exprp, const char *(*get_filter)(const char *name));\nint expr_op_to_bool(int res, int op);\nint expr_eval(struct expr *expr, struct track_info *ti);\nvoid expr_free(struct expr *expr);\nconst char *expr_error(void);\nint expr_is_short(const char *str);\n\nunsigned int expr_get_match_type(struct expr *expr);\n/* \"harmless\" expressions will reduce filter results when adding characters at the beginning/end */\nint expr_is_harmless(const struct expr *expr);\n\n#endif\n"
        },
        {
          "name": "file.c",
          "type": "blob",
          "size": 3.4130859375,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2005 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"file.h\"\n#include \"xmalloc.h\"\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/mman.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <errno.h>\n\nssize_t read_all(int fd, void *buf, size_t count)\n{\n\tchar *buffer = buf;\n\tssize_t pos = 0;\n\n\tdo {\n\t\tssize_t rc;\n\n\t\trc = read(fd, buffer + pos, count - pos);\n\t\tif (rc == -1) {\n\t\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\t\tcontinue;\n\t\t\treturn -1;\n\t\t}\n\t\tif (rc == 0) {\n\t\t\t/* eof */\n\t\t\tbreak;\n\t\t}\n\t\tpos += rc;\n\t} while (count - pos > 0);\n\treturn pos;\n}\n\nssize_t write_all(int fd, const void *buf, size_t count)\n{\n\tconst char *buffer = buf;\n\tint count_save = count;\n\n\tdo {\n\t\tint rc;\n\n\t\trc = write(fd, buffer, count);\n\t\tif (rc == -1) {\n\t\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\t\tcontinue;\n\t\t\treturn -1;\n\t\t}\n\t\tbuffer += rc;\n\t\tcount -= rc;\n\t} while (count > 0);\n\treturn count_save;\n}\n\nchar *mmap_file(const char *filename, ssize_t *size)\n{\n\tstruct stat st;\n\tchar *buf;\n\tint fd;\n\n\tfd = open(filename, O_RDONLY);\n\tif (fd == -1)\n\t\tgoto err;\n\n\tif (fstat(fd, &st) == -1)\n\t\tgoto close_err;\n\n\t/* can't mmap empty files */\n\tbuf = NULL;\n\tif (st.st_size) {\n\t\tbuf = mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);\n\t\tif (buf == MAP_FAILED)\n\t\t\tgoto close_err;\n\t}\n\n\tclose(fd);\n\t*size = st.st_size;\n\treturn buf;\n\nclose_err:\n\tclose(fd);\nerr:\n\t*size = -1;\n\treturn NULL;\n}\n\nvoid buffer_for_each_line(const char *buf, int size,\n\t\tint (*cb)(void *data, const char *line),\n\t\tvoid *data)\n{\n\tchar *line = NULL;\n\tint line_size = 0, pos = 0;\n\n\twhile (pos < size) {\n\t\tint end, len;\n\n\t\tend = pos;\n\t\twhile (end < size && buf[end] != '\\n')\n\t\t\tend++;\n\n\t\tlen = end - pos;\n\t\tif (end > pos && buf[end - 1] == '\\r')\n\t\t\tlen--;\n\n\t\tif (len >= line_size) {\n\t\t\tline_size = len + 1;\n\t\t\tline = xrenew(char, line, line_size);\n\t\t}\n\t\tmemcpy(line, buf + pos, len);\n\t\tline[len] = 0;\n\t\tpos = end + 1;\n\n\t\tif (cb(data, line))\n\t\t\tbreak;\n\t}\n\tfree(line);\n}\n\nvoid buffer_for_each_line_reverse(const char *buf, int size,\n\t\tint (*cb)(void *data, const char *line),\n\t\tvoid *data)\n{\n\tchar *line = NULL;\n\tint line_size = 0, end = size - 1;\n\n\twhile (end >= 0) {\n\t\tint pos, len;\n\n\t\tif (end > 1 && buf[end] == '\\n' && buf[end - 1] == '\\r')\n\t\t\tend--;\n\n\t\tpos = end;\n\t\twhile (pos > 0 && buf[pos - 1] != '\\n')\n\t\t\tpos--;\n\n\t\tlen = end - pos;\n\t\tif (len >= line_size) {\n\t\t\tline_size = len + 1;\n\t\t\tline = xrenew(char, line, line_size);\n\t\t}\n\t\tmemcpy(line, buf + pos, len);\n\t\tline[len] = 0;\n\t\tend = pos - 1;\n\n\t\tif (cb(data, line))\n\t\t\tbreak;\n\t}\n\tfree(line);\n}\n\nint file_for_each_line(const char *filename,\n\t\tint (*cb)(void *data, const char *line),\n\t\tvoid *data)\n{\n\tchar *buf;\n\tssize_t size;\n\n\tbuf = mmap_file(filename, &size);\n\tif (size == -1)\n\t\treturn -1;\n\n\tif (buf) {\n\t\tbuffer_for_each_line(buf, size, cb, data);\n\t\tmunmap(buf, size);\n\t}\n\treturn 0;\n}\n"
        },
        {
          "name": "file.h",
          "type": "blob",
          "size": 1.4619140625,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2005 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_FILE_H\n#define CMUS_FILE_H\n\n#include <stddef.h> /* size_t */\n#include <sys/types.h> /* ssize_t */\n\nssize_t read_all(int fd, void *buf, size_t count);\nssize_t write_all(int fd, const void *buf, size_t count);\n\n/* @filename  file to mmap for reading\n * @size      returned size of the file or -1 if failed\n *\n * returns buffer or NULL if empty file or failed\n */\nchar *mmap_file(const char *filename, ssize_t *size);\n\nvoid buffer_for_each_line(const char *buf, int size,\n\t\tint (*cb)(void *data, const char *line),\n\t\tvoid *data);\nvoid buffer_for_each_line_reverse(const char *buf, int size,\n\t\tint (*cb)(void *data, const char *line),\n\t\tvoid *data);\nint file_for_each_line(const char *filename,\n\t\tint (*cb)(void *data, const char *line),\n\t\tvoid *data);\n\n#endif\n"
        },
        {
          "name": "filters.c",
          "type": "blob",
          "size": 9.52734375,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2005 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"filters.h\"\n#include \"cmdline.h\"\n#include \"expr.h\"\n#include \"window.h\"\n#include \"search.h\"\n#include \"uchar.h\"\n#include \"lib.h\"\n#include \"misc.h\"\n#include \"file.h\"\n#include \"ui_curses.h\"\n#include \"xmalloc.h\"\n\n#include <stdio.h>\n#include <ctype.h>\n\nstruct window *filters_win;\nstruct searchable *filters_searchable;\nLIST_HEAD(filters_head);\n\nstatic const char *recursive_filter;\n\nstatic inline void filter_entry_to_iter(struct filter_entry *e, struct iter *iter)\n{\n\titer->data0 = &filters_head;\n\titer->data1 = e;\n\titer->data2 = NULL;\n}\n\nstatic GENERIC_ITER_PREV(filters_get_prev, struct filter_entry, node)\nstatic GENERIC_ITER_NEXT(filters_get_next, struct filter_entry, node)\n\nstatic int filters_search_get_current(void *data, struct iter *iter, enum search_direction dir)\n{\n\treturn window_get_sel(filters_win, iter);\n}\n\nstatic int filters_search_matches(void *data, struct iter *iter, const char *text)\n{\n\tchar **words = get_words(text);\n\tint matched = 0;\n\n\tif (words[0] != NULL) {\n\t\tstruct filter_entry *e;\n\t\tint i;\n\n\t\te = iter_to_filter_entry(iter);\n\t\tfor (i = 0; ; i++) {\n\t\t\tif (words[i] == NULL) {\n\t\t\t\twindow_set_sel(filters_win, iter);\n\t\t\t\tmatched = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (u_strcasestr(e->name, words[i]) == NULL)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tfree_str_array(words);\n\treturn matched;\n}\n\nstatic const struct searchable_ops filters_search_ops = {\n\t.get_prev = filters_get_prev,\n\t.get_next = filters_get_next,\n\t.get_current = filters_search_get_current,\n\t.matches = filters_search_matches\n};\n\nstatic void free_filter(struct filter_entry *e)\n{\n\tfree(e->name);\n\tfree(e->filter);\n\tfree(e);\n}\n\nstatic struct filter_entry *find_filter(const char *name)\n{\n\tstruct filter_entry *e;\n\n\tlist_for_each_entry(e, &filters_head, node) {\n\t\tif (strcmp(e->name, name) == 0)\n\t\t\treturn e;\n\t}\n\treturn NULL;\n}\n\nstatic const char *get_filter(const char *name)\n{\n\tstruct filter_entry *e = find_filter(name);\n\n\tif (e) {\n\t\tif (e->visited) {\n\t\t\trecursive_filter = e->name;\n\t\t\treturn NULL;\n\t\t}\n\t\te->visited = 1;\n\t\treturn e->filter;\n\t}\n\treturn NULL;\n}\n\nstatic void edit_sel_filter(void)\n{\n\tstruct iter sel;\n\tstruct filter_entry *e;\n\tchar buf[512];\n\n\tif (!window_get_sel(filters_win, &sel))\n\t\treturn;\n\n\te = iter_to_filter_entry(&sel);\n\tsnprintf(buf, sizeof(buf), \"fset %s=%s\", e->name, e->filter);\n\tcmdline_set_text(buf);\n\tenter_command_mode();\n}\n\nvoid filters_activate(int win_activate)\n{\n\tstruct filter_entry *f;\n\tstruct expr *e, *expr = NULL;\n\tint unchanged = 1;\n\n\t/* if no pending selection is to apply, edit currently select filter */\n\tlist_for_each_entry(f, &filters_head, node) {\n\t\tif (f->act_stat != f->sel_stat)\n\t\t\tunchanged = 0;\n\t}\n\n\tif (unchanged) {\n\t\tif (win_activate)\n\t\t\tedit_sel_filter();\n\t\telse\n\t\t\treturn;\n\t}\n\n\t/* mark visited and AND together all selected filters\n\t * mark any other filters unvisited */\n\tlist_for_each_entry(f, &filters_head, node) {\n\t\tf->visited = 0;\n\t\tif (f->sel_stat == FS_IGNORE)\n\t\t\tcontinue;\n\n\t\tf->visited = 1;\n\t\te = expr_parse(f->filter);\n\t\tif (e == NULL) {\n\t\t\terror_msg(\"error parsing filter %s: %s\", f->name, expr_error());\n\t\t\tif (expr)\n\t\t\t\texpr_free(expr);\n\t\t\treturn;\n\t\t}\n\n\t\tif (f->sel_stat == FS_NO) {\n\t\t\t/* add ! */\n\t\t\tstruct expr *not = xnew(struct expr, 1);\n\n\t\t\tnot->type = EXPR_NOT;\n\t\t\tnot->key = NULL;\n\t\t\tnot->left = e;\n\t\t\tnot->right = NULL;\n\t\t\te = not;\n\t\t}\n\t\tif (expr == NULL) {\n\t\t\texpr = e;\n\t\t} else {\n\t\t\tstruct expr *and = xnew(struct expr, 1);\n\n\t\t\tand->type = EXPR_AND;\n\t\t\tand->key = NULL;\n\t\t\tand->left = expr;\n\t\t\tand->right = e;\n\t\t\texpr->parent = and;\n\t\t\te->parent = and;\n\t\t\texpr = and;\n\t\t}\n\t}\n\n\trecursive_filter = NULL;\n\tif (expr && expr_check_leaves(&expr, get_filter)) {\n\t\tif (recursive_filter) {\n\t\t\terror_msg(\"recursion detected in filter %s\", recursive_filter);\n\t\t} else {\n\t\t\terror_msg(\"error parsing filter: %s\", expr_error());\n\t\t}\n\t\texpr_free(expr);\n\t\treturn;\n\t}\n\n\t/* update active flag */\n\tlist_for_each_entry(f, &filters_head, node) {\n\t\tf->act_stat = f->sel_stat;\n\t}\n\tlib_set_filter(expr);\n\tfilters_win->changed = 1;\n}\n\nstatic int for_each_name(const char *str, int (*cb)(const char *name, int sel_stat))\n{\n\tchar buf[64];\n\tint s, e, len;\n\n\te = 0;\n\tdo {\n\t\tint sel_stat = FS_YES;\n\n\t\ts = e;\n\t\twhile (str[s] == ' ')\n\t\t\ts++;\n\t\tif (str[s] == '!') {\n\t\t\tsel_stat = FS_NO;\n\t\t\ts++;\n\t\t}\n\t\te = s;\n\t\twhile (str[e] && str[e] != ' ')\n\t\t\te++;\n\n\t\tlen = e - s;\n\t\tif (len == 0)\n\t\t\treturn 0;\n\t\tif (len >= sizeof(buf)) {\n\t\t\terror_msg(\"filter name too long\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tmemcpy(buf, str + s, len);\n\t\tbuf[len] = 0;\n\n\t\tif (cb(buf, sel_stat))\n\t\t\treturn -1;\n\t} while (1);\n}\n\nstatic int ensure_filter_name(const char *name, int sel_stat)\n{\n\tif (find_filter(name) == NULL) {\n\t\terror_msg(\"no such filter %s\", name);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int select_filter(const char *name, int sel_stat)\n{\n\tstruct filter_entry *e = find_filter(name);\n\n\te->sel_stat = sel_stat;\n\treturn 0;\n}\n\nvoid filters_activate_names(const char *str)\n{\n\tstruct filter_entry *f;\n\n\t/* first validate all filter names */\n\tif (str && for_each_name(str, ensure_filter_name))\n\t\treturn;\n\n\t/* mark all filters unselected  */\n\tlist_for_each_entry(f, &filters_head, node)\n\t\tf->sel_stat = FS_IGNORE;\n\n\t/* select the filters */\n\tif (str)\n\t\tfor_each_name(str, select_filter);\n\n\t/* activate selected */\n\tfilters_activate(0);\n}\n\nvoid filters_toggle_filter(void)\n{\n\tstruct iter iter;\n\n\tif (window_get_sel(filters_win, &iter)) {\n\t\tstruct filter_entry *e;\n\n\t\te = iter_to_filter_entry(&iter);\n\t\te->sel_stat = (e->sel_stat + 1) % 3;\n\t\tfilters_win->changed = 1;\n\t}\n}\n\nvoid filters_delete_filter(void)\n{\n\tstruct iter iter;\n\n\tif (window_get_sel(filters_win, &iter)) {\n\t\tstruct filter_entry *e;\n\n\t\te = iter_to_filter_entry(&iter);\n\t\tif (yes_no_query(\"Delete filter '%s'? [y/N]\", e->name) == UI_QUERY_ANSWER_YES) {\n\t\t\twindow_row_vanishes(filters_win, &iter);\n\t\t\tlist_del(&e->node);\n\t\t\tfree_filter(e);\n\t\t}\n\t}\n}\n\nstatic int validate_filter_name(const char *name)\n{\n\tint i;\n\n\tfor (i = 0; name[i]; i++) {\n\t\tif (isalnum((unsigned char)name[i]))\n\t\t\tcontinue;\n\t\tif (name[i] == '_' || name[i] == '-')\n\t\t\tcontinue;\n\t\treturn 0;\n\t}\n\treturn i != 0;\n}\n\nstatic void do_filters_set_filter(const char *keyval)\n{\n\tconst char *eq = strchr(keyval, '=');\n\tchar *key, *val;\n\tstruct expr *expr;\n\tstruct filter_entry *new;\n\tstruct list_head *item;\n\n\tif (eq == NULL) {\n\t\tif (ui_initialized)\n\t\t\terror_msg(\"invalid argument ('key=value' expected)\");\n\t\treturn;\n\t}\n\tkey = xstrndup(keyval, eq - keyval);\n\tval = xstrdup(eq + 1);\n\tif (!validate_filter_name(key)) {\n\t\tif (ui_initialized)\n\t\t\terror_msg(\"invalid filter name (can only contain 'a-zA-Z0-9_-' characters)\");\n\t\tfree(key);\n\t\tfree(val);\n\t\treturn;\n\t}\n\texpr = expr_parse(val);\n\tif (expr == NULL) {\n\t\tif (ui_initialized)\n\t\t\terror_msg(\"error parsing filter %s: %s\", val, expr_error());\n\t\tfree(key);\n\t\tfree(val);\n\t\treturn;\n\t}\n\texpr_free(expr);\n\n\tnew = xnew(struct filter_entry, 1);\n\tnew->name = key;\n\tnew->filter = val;\n\tnew->act_stat = FS_IGNORE;\n\tnew->sel_stat = FS_IGNORE;\n\n\t/* add or replace filter */\n\tlist_for_each(item, &filters_head) {\n\t\tstruct filter_entry *e = container_of(item, struct filter_entry, node);\n\t\tint res = strcmp(key, e->name);\n\n\t\tif (res < 0)\n\t\t\tbreak;\n\t\tif (res == 0) {\n\t\t\t/* replace */\n\t\t\tstruct iter iter;\n\n\t\t\tnew->sel_stat = e->sel_stat;\n\t\t\tif (ui_initialized) {\n\t\t\t\tfilter_entry_to_iter(e, &iter);\n\t\t\t\twindow_row_vanishes(filters_win, &iter);\n\t\t\t}\n\t\t\titem = item->next;\n\t\t\tlist_del(&e->node);\n\t\t\tfree_filter(e);\n\t\t\tbreak;\n\t\t}\n\t}\n\t/* add before item */\n\tlist_add_tail(&new->node, item);\n\tif (ui_initialized)\n\t\twindow_changed(filters_win);\n}\n\nvoid filters_init(void)\n{\n\tstruct iter iter;\n\n\tfilters_win = window_new(filters_get_prev, filters_get_next);\n\twindow_set_contents(filters_win, &filters_head);\n\twindow_changed(filters_win);\n\n\titer.data0 = &filters_head;\n\titer.data1 = NULL;\n\titer.data2 = NULL;\n\tfilters_searchable = searchable_new(NULL, &iter, &filters_search_ops);\n}\n\nvoid filters_exit(void)\n{\n\tsearchable_free(filters_searchable);\n\twindow_free(filters_win);\n}\n\nvoid filters_set_filter(const char *keyval)\n{\n\tdo_filters_set_filter(keyval);\n}\n\nstruct expr *parse_filter(const char *val)\n{\n\tstruct expr *e = NULL;\n\tstruct filter_entry *f;\n\n\tif (val) {\n\t\te = expr_parse(val);\n\t\tif (e == NULL) {\n\t\t\terror_msg(\"error parsing filter %s: %s\", val, expr_error());\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t/* mark all unvisited so that we can check recursion */\n\tlist_for_each_entry(f, &filters_head, node)\n\t\tf->visited = 0;\n\n\trecursive_filter = NULL;\n\tif (e && expr_check_leaves(&e, get_filter)) {\n\t\tif (recursive_filter) {\n\t\t\terror_msg(\"recursion detected in filter %s\", recursive_filter);\n\t\t} else {\n\t\t\terror_msg(\"error parsing filter: %s\", expr_error());\n\t\t}\n\t\texpr_free(e);\n\t\treturn NULL;\n\t}\n\treturn e;\n}\n\nvoid filters_set_anonymous(const char *val)\n{\n\tstruct filter_entry *f;\n\tstruct expr *e = NULL;\n\n\tif (val) {\n\t\te = parse_filter(val);\n\t\tif (e == NULL)\n\t\t\treturn;\n\t}\n\n\t/* deactive all filters */\n\tlist_for_each_entry(f, &filters_head, node)\n\t\tf->act_stat = FS_IGNORE;\n\n\tlib_set_filter(e);\n\n\tfilters_win->changed = 1;\n}\n\nvoid filters_set_live(const char *val)\n{\n\tlib_set_live_filter(val);\n\tupdate_filterline();\n}\n"
        },
        {
          "name": "filters.h",
          "type": "blob",
          "size": 2.181640625,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2005 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_FILTERS_H\n#define CMUS_FILTERS_H\n\n#include \"list.h\"\n#include \"window.h\"\n#include \"search.h\"\n\n/* factivate foo !bar\n *\n * foo: FS_YES\n * bar: FS_NO\n * baz: FS_IGNORE\n */\nenum {\n\t/* [ ] filter not selected */\n\tFS_IGNORE,\n\t/* [*] filter selected */\n\tFS_YES,\n\t/* [!] filter selected and inverted */\n\tFS_NO,\n};\n\nstruct filter_entry {\n\tstruct list_head node;\n\n\tchar *name;\n\tchar *filter;\n\tunsigned visited : 1;\n\n\t/* selected and activated status (FS_* enum) */\n\tunsigned sel_stat : 2;\n\tunsigned act_stat : 2;\n};\n\nstatic inline struct filter_entry *iter_to_filter_entry(struct iter *iter)\n{\n\treturn iter->data1;\n}\n\nextern struct window *filters_win;\nextern struct searchable *filters_searchable;\nextern struct list_head filters_head;\n\nvoid filters_init(void);\nvoid filters_exit(void);\n\n/* parse filter and expand sub filters */\nstruct expr *parse_filter(const char *val);\n\n/* add filter to filter list (replaces old filter with same name)\n *\n * @keyval  \"name=value\" where value is filter\n */\nvoid filters_set_filter(const char *keyval);\n\n/* set throwaway filter (not saved to the filter list)\n *\n * @val   filter or NULL to disable filtering\n */\nvoid filters_set_anonymous(const char *val);\n\n/* set live filter (not saved to the filter list)\n *\n * @val   filter or NULL to disable filtering\n */\nvoid filters_set_live(const char *val);\n\nvoid filters_activate_names(const char *str);\n\nvoid filters_activate(int win_activate);\nvoid filters_toggle_filter(void);\nvoid filters_delete_filter(void);\n\n#endif\n"
        },
        {
          "name": "format_print.c",
          "type": "blob",
          "size": 15.4931640625,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"format_print.h\"\n#include \"expr.h\"\n#include \"glob.h\"\n#include \"utils.h\"\n#include \"options.h\"\n#include \"uchar.h\"\n#include \"xmalloc.h\"\n#include \"debug.h\"\n\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nstatic int width;\nstatic int align_left;\nstatic int pad;\nstatic bool width_is_exact;\n\nstatic GBUF(cond_buffer);\nstatic GBUF(l_str);\nstatic GBUF(m_str);\nstatic GBUF(r_str);\nstatic struct fp_len str_len = {0, 0, 0};\nstatic int *len = &str_len.llen;\nstatic struct gbuf* str = &l_str;\n\nstatic void stack_print(char *stack, int stack_len)\n{\n\tint i = 0;\n\n\tgbuf_grow(str, width ? width : stack_len);\n\tchar* buf = str->buffer + str->len;\n\n\tif (width) {\n\t\tif (align_left) {\n\t\t\twhile (i < width && stack_len)\n\t\t\t\tbuf[i++] = stack[--stack_len];\n\t\t\twhile (i < width)\n\t\t\t\tbuf[i++] = pad;\n\t\t} else {\n\t\t\tint pad_len;\n\n\t\t\tif (stack_len > width)\n\t\t\t\tstack_len = width;\n\t\t\tpad_len = width - stack_len;\n\t\t\twhile (i < pad_len)\n\t\t\t\tbuf[i++] = pad;\n\t\t\twhile (i < width)\n\t\t\t\tbuf[i++] = stack[--stack_len];\n\t\t}\n\t} else {\n\t\twhile (stack_len)\n\t\t\tbuf[i++] = stack[--stack_len];\n\t}\n\tgbuf_used(str, i);\n\t*len += i;\n}\n\nstatic void print_num(int num)\n{\n\tchar stack[20];\n\tint i, p;\n\n\tif (num < 0) {\n\t\tif (width == 0)\n\t\t\twidth = 1;\n\t\tfor (i = 0; i < width; i++)\n\t\t\tgbuf_add_ch(str, '?');\n\t\t*len += width;\n\t\treturn;\n\t}\n\tp = 0;\n\tdo {\n\t\tstack[p++] = num % 10 + '0';\n\t\tnum /= 10;\n\t} while (num);\n\n\tstack_print(stack, p);\n}\n\n#define DBL_MAX_LEN (20)\n\nstatic void print_double(double num)\n{\n\tchar stack[DBL_MAX_LEN], b[DBL_MAX_LEN];\n\tint i, p = 0;\n\n\ti = snprintf(b, DBL_MAX_LEN, \"%g\", num) - 1;\n\twhile (i >= 0) {\n\t\tstack[p++] = b[i];\n\t\ti--;\n\t}\n\tstack_print(stack, p);\n}\n\n/* print '{,-}{h:,}mm:ss' */\nstatic void print_time(int t)\n{\n\tint h, m, s;\n\tchar stack[32];\n\tint neg = 0;\n\tint p = 0;\n\n\tif (t < 0) {\n\t\tneg = 1;\n\t\tt *= -1;\n\t}\n\th = t / 3600;\n\tt = t % 3600;\n\tm = t / 60;\n\ts = t % 60;\n\n\t/* put all chars to stack in reverse order ;) */\n\tstack[p++] = s % 10 + '0';\n\tstack[p++] = s / 10 + '0';\n\tstack[p++] = ':';\n\tstack[p++] = m % 10 + '0';\n\tif (m / 10 || h || time_show_leading_zero)\n\t\tstack[p++] = m / 10 + '0';\n\tif (h) {\n\t\tstack[p++] = ':';\n\t\tdo {\n\t\t\tstack[p++] = h % 10 + '0';\n\t\t\th /= 10;\n\t\t} while (h);\n\t}\n\tif (neg)\n\t\tstack[p++] = '-';\n\n\tstack_print(stack, p);\n}\n\nstatic void print_str(const char *src)\n{\n\tint str_width = u_str_width(src);\n\n\tif (width && width_is_exact) {\n\t\t*len += width;\n\t\tif (align_left) {\n\t\t\tgbuf_add_ustr(str, src, &width);\n\t\t\tgbuf_set(str, ' ', width);\n\t\t} else {\n\t\t\tint s = 0;\n\t\t\tint ws_len = width - str_width;\n\t\t\tif (ws_len < 0) {\n\t\t\t\tint skip = -ws_len;\n\t\t\t\tint clipped_mark_len = min_u(u_str_width(clipped_text_internal), width);\n\t\t\t\tskip += clipped_mark_len;\n\t\t\t\tgbuf_add_ustr(str, clipped_text_internal, &clipped_mark_len);\n\t\t\t\ts = u_skip_chars(src, &skip, true);\n\t\t\t\t/* pad if a wide character caused us to skip too much */\n\t\t\t\tws_len = -skip;\n\n\t\t\t}\n\t\t\tgbuf_set(str, ' ', ws_len);\n\t\t\tgbuf_add_ustr(str, src + s, &width);\n\t\t}\n\t} else {\n\t\tif (!width)\n\t\t\twidth = str_width;\n\t\t*len += width;\n\t\tgbuf_add_ustr(str, src, &width);\n\t\t*len -= width;\n\t}\n}\n\nstatic inline int strnequal(const char *a, const char *b, size_t b_len)\n{\n\treturn a && (strlen(a) == b_len) && (memcmp(a, b, b_len) == 0);\n}\n\nstatic const struct format_option *find_fopt(const struct format_option *fopts, const char *key)\n{\n\tconst struct format_option *fo;\n\tchar ch = strlen(key) == 1 ? *key : 0;\n\tfor (fo = fopts; fo->type != 0; fo++) {\n\t\tif ((ch != 0 && fo->ch == ch) || strnequal(fo->str, key, strlen(key))) {\n\t\t\treturn fo;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic const char *str_val(const char *key, const struct format_option *fopts, char *buf)\n{\n\tconst struct format_option *fo;\n\tconst struct cmus_opt *opt;\n\tconst char *val = NULL;\n\n\tfo = find_fopt(fopts, key);\n\tif (fo && !fo->empty) {\n\t\tif (fo->type == FO_STR)\n\t\t\tval = fo->fo_str;\n\t} else {\n\t\topt = option_find_silent(key);\n\t\tif (opt) {\n\t\t\topt->get(opt->data, buf, OPTION_MAX_SIZE);\n\t\t\tval = buf;\n\t\t}\n\t}\n\treturn val;\n}\n\nstatic int int_val(const char *key, const struct format_option *fopts, char *buf)\n{\n\tconst struct format_option *fo;\n\tint val = -1;\n\n\tfo = find_fopt(fopts, key);\n\tif (fo && !fo->empty) {\n\t\tif (fo->type == FO_INT)\n\t\t\tval = fo->fo_int;\n\t}\n\treturn val;\n}\n\nstatic int format_eval_cond(struct expr* expr, const struct format_option *fopts)\n{\n\tif (!expr)\n\t\treturn -1;\n\tenum expr_type type = expr->type;\n\tconst char *key;\n\tconst struct format_option *fo;\n\tconst struct cmus_opt *opt;\n\tchar buf[OPTION_MAX_SIZE];\n\n\tif (expr->left) {\n\t\tint left = format_eval_cond(expr->left, fopts);\n\n\t\tif (type == EXPR_AND)\n\t\t\treturn left && format_eval_cond(expr->right, fopts);\n\t\tif (type == EXPR_OR)\n\t\t\treturn left || format_eval_cond(expr->right, fopts);\n\t\t/* EXPR_NOT */\n\t\treturn !left;\n\t}\n\n\tkey = expr->key;\n\tif (type == EXPR_STR) {\n\t\tconst char *val = str_val(key, fopts, buf);\n\t\tint res;\n\n\t\tif (!val)\n\t\t\tval = \"\";\n\t\tres = glob_match(&expr->estr.glob_head, val);\n\t\tif (expr->estr.op == SOP_EQ)\n\t\t\treturn res;\n\t\treturn !res;\n\t} else if (type == EXPR_INT) {\n\t\tint val = int_val(key, fopts, buf);\n\t\tint res = val - expr->eint.val;\n\t\tif (val == -1 || expr->eint.val == -1) {\n\t\t\tswitch (expr->eid.op) {\n\t\t\tcase KOP_EQ:\n\t\t\t\treturn res == 0;\n\t\t\tcase KOP_NE:\n\t\t\t\treturn res != 0;\n\t\t\tdefault:\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\treturn expr_op_to_bool(res, expr->eint.op);\n\t} else if (type == EXPR_ID) {\n\t\tint a = 0, b = 0;\n\t\tconst char *sa, *sb;\n\t\tint res = 0;\n\t\tif ((sa = str_val(key, fopts, buf)) && (sb = str_val(expr->eid.key, fopts, buf))) {\n\t\t\tres = strcmp(sa, sb);\n\t\t\treturn expr_op_to_bool(res, expr->eid.op);\n\t\t} else {\n\t\t\ta = int_val(key, fopts, buf);\n\t\t\tb = int_val(expr->eid.key, fopts, buf);\n\t\t\tres = a - b;\n\t\t\tif (a == -1 || b == -1) {\n\t\t\t\tswitch (expr->eid.op) {\n\t\t\t\tcase KOP_EQ:\n\t\t\t\t\treturn res == 0;\n\t\t\t\tcase KOP_NE:\n\t\t\t\t\treturn res != 0;\n\t\t\t\tdefault:\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn expr_op_to_bool(res, expr->eid.op);\n\t\t}\n\t\treturn res;\n\t}\n\tif (strcmp(key, \"stream\") == 0) {\n\t\tfo = find_fopt(fopts, \"filename\");\n\t\treturn fo && is_http_url(fo->fo_str);\n\t}\n\tfo = find_fopt(fopts, key);\n\tif (fo)\n\t\treturn !fo->empty;\n\topt = option_find_silent(key);\n\tif (opt) {\n\t\topt->get(opt->data, buf, OPTION_MAX_SIZE);\n\t\tif (strcmp(buf, \"false\") != 0 && strlen(buf) != 0)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic struct expr *format_parse_cond(const char* format, int size)\n{\n\tgbuf_clear(&cond_buffer);\n\tgbuf_add_bytes(&cond_buffer, format, size);\n\treturn expr_parse_i(cond_buffer.buffer, \"condition contains control characters\", 0);\n}\n\nstatic uchar format_skip_cond_expr(const char *format, int *s)\n{\n\tuchar r = 0;\n\twhile (format[*s]) {\n\t\tuchar u = u_get_char(format, s);\n\t\tif (u == '}' || u == '?') {\n\t\t\treturn u;\n\t\t}\n\t\tif (u != '%') {\n\t\t\tcontinue;\n\t\t}\n\t\tu = u_get_char(format, s);\n\t\tif (u == '%' || u == '?' || u == '!' || u == '=') {\n\t\t\tcontinue;\n\t\t}\n\t\tif (u == '-') {\n\t\t\tu = u_get_char(format, s);\n\t\t}\n\t\tif (u == '.')\n\t\t\tu = u_get_char(format, s);\n\t\twhile (isdigit(u)) {\n\t\t\tu = u_get_char(format, s);\n\t\t}\n\t\tif (u == '{') {\n\t\t\tunsigned level = 1;\n\t\t\twhile (level) {\n\t\t\t\tu = u_get_char(format, s);\n\t\t\t\tif (u == 0)\n\t\t\t\t\treturn 0;\n\t\t\t\tif (u == '}')\n\t\t\t\t\t--level;\n\t\t\t\tif (u != '%')\n\t\t\t\t\tcontinue;\n\t\t\t\tu = u_get_char(format, s);\n\t\t\t\tif (u == '%' || u == '?' || u == '!' || u == '=')\n\t\t\t\t\tcontinue;\n\t\t\t\tif (u == '-')\n\t\t\t\t\tu = u_get_char(format, s);\n\t\t\t\tif (u == '.')\n\t\t\t\t\tu = u_get_char(format, s);\n\t\t\t\twhile (isdigit(u))\n\t\t\t\t\tu = u_get_char(format, s);\n\t\t\t\tif (u == 0)\n\t\t\t\t\treturn 0;\n\t\t\t\tif (u == '{')\n\t\t\t\t\t++level;\n\t\t\t}\n\t\t}\n\t}\n\treturn r;\n}\n\nstatic int format_read_cond(const char *format, int *s, int *a, int *b, int *end)\n{\n\tuchar t = format_skip_cond_expr(format, s);\n\tif (t != '?')\n\t\treturn 1;\n\t*a = *s - 1;\n\tt = format_skip_cond_expr(format, s);\n\tif (t == 0)\n\t\treturn 1;\n\tif (t == '?') {\n\t\t*b = *s - 1;\n\t\tt = format_skip_cond_expr(format, s);\n\t\tif (t != '}')\n\t\t\treturn 1;\n\t}\n\t*end = *s - 1;\n\treturn 0;\n}\n\nstatic void format_parse(int str_width, const char *format, const struct format_option *fopts, int f_size);\n\nstatic void format_parse_if(int str_width, const char *format, const struct format_option *fopts, int *s)\n{\n\tint cond_pos = *s, then_pos = -1, else_pos = -1, end_pos = -1, cond_res = -1;\n\tBUG_ON(format_read_cond(format, s, &then_pos, &else_pos, &end_pos) != 0);\n\n\tstruct expr *cond = format_parse_cond(format + cond_pos, then_pos - cond_pos);\n\tcond_res = format_eval_cond(cond, fopts);\n\tif (cond)\n\t\texpr_free(cond);\n\n\tBUG_ON(cond_res < 0);\n\tif (cond_res) {\n\t\tformat_parse(str_width, format + then_pos + 1, fopts,\n\t\t\t\t(else_pos > 0 ? else_pos : end_pos) - then_pos - 1);\n\t} else if (else_pos > 0) {\n\t\tformat_parse(str_width, format + else_pos + 1, fopts, end_pos - else_pos - 1);\n\t}\n\n\t*s = end_pos + 1;\n}\n\nstatic void format_parse(int str_width, const char *format, const struct format_option *fopts, int f_size)\n{\n\tint s = 0;\n\n\twhile (s < f_size) {\n\t\tconst struct format_option *fo;\n\t\tint long_len = 0;\n\t\tconst char *long_begin = NULL;\n\t\tuchar u;\n\n\t\tu = u_get_char(format, &s);\n\t\tif (u != '%') {\n\t\t\tgbuf_add_uchar(str, u);\n\t\t\t(*len) += u_char_width(u);\n\t\t\tcontinue;\n\t\t}\n\t\tu = u_get_char(format, &s);\n\t\tif (u == '%' || u == '?') {\n\t\t\tgbuf_add_ch(str, u);\n\t\t\t++(*len);\n\t\t\tcontinue;\n\t\t}\n\t\tif (u == '!') {\n\t\t\t/* middle (priority) text starts */\n\t\t\tstr = &m_str;\n\t\t\tlen = &str_len.mlen;\n\t\t\tcontinue;\n\t\t}\n\t\tif (u == '=') {\n\t\t\t/* right aligned text starts */\n\t\t\tstr = &r_str;\n\t\t\tlen = &str_len.rlen;\n\t\t\tcontinue;\n\t\t}\n\t\talign_left = 0;\n\t\tif (u == '-') {\n\t\t\talign_left = 1;\n\t\t\tu = u_get_char(format, &s);\n\t\t}\n\t\twidth_is_exact = true;\n\t\tif (u == '.') {\n\t\t\twidth_is_exact = false;\n\t\t\tu = u_get_char(format, &s);\n\t\t}\n\t\tpad = ' ';\n\t\tif (u == '0') {\n\t\t\tpad = '0';\n\t\t\tu = u_get_char(format, &s);\n\t\t}\n\t\twidth = 0;\n\t\twhile (isdigit(u)) {\n\t\t\t/* minimum length of this field */\n\t\t\twidth *= 10;\n\t\t\twidth += u - '0';\n\t\t\tu = u_get_char(format, &s);\n\t\t}\n\t\tif (u == '%') {\n\t\t\twidth = (width * str_width) / 100.0 + 0.5;\n\t\t\tu = u_get_char(format, &s);\n\t\t}\n\t\tif (u == '{') {\n\t\t\tlong_begin = format + s;\n\t\t\tif (*long_begin == '?') {\n\t\t\t\t++s;\n\t\t\t\tformat_parse_if(str_width, format, fopts, &s);\n\t\t\t\tBUG_ON(s > f_size);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twhile (1) {\n\t\t\t\tBUG_ON(s >= f_size);\n\t\t\t\tu = u_get_char(format, &s);\n\t\t\t\tif (u == '}')\n\t\t\t\t\tbreak;\n\t\t\t\tlong_len++;\n\t\t\t}\n\t\t}\n\t\tfor (fo = fopts; ; fo++) {\n\t\t\tBUG_ON(fo->type == 0);\n\t\t\tif (long_len ? strnequal(fo->str, long_begin, long_len)\n\t\t\t\t     : (fo->ch == u)) {\n\n\t\t\t\tint type = fo->type;\n\n\t\t\t\tif (fo->empty) {\n\t\t\t\t\tgbuf_set(str, ' ', width);\n\t\t\t\t\t*len += width;\n\t\t\t\t} else if (type == FO_STR) {\n\t\t\t\t\tprint_str(fo->fo_str);\n\t\t\t\t} else if (type == FO_INT) {\n\t\t\t\t\tprint_num(fo->fo_int);\n\t\t\t\t} else if (type == FO_TIME) {\n\t\t\t\t\tprint_time(fo->fo_time);\n\t\t\t\t} else if (type == FO_DOUBLE) {\n\t\t\t\t\tprint_double(fo->fo_double);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void format_read(int str_width, const char *format, const struct format_option *fopts)\n{\n\tgbuf_clear(&l_str);\n\tgbuf_clear(&m_str);\n\tgbuf_clear(&r_str);\n\tstr_len.llen = 0;\n\tstr_len.mlen = 0;\n\tstr_len.rlen = 0;\n\tstr = &l_str;\n\tlen = &str_len.llen;\n\tformat_parse(str_width, format, fopts, strlen(format));\n}\n\nstatic void format_write(struct gbuf *buf, int str_width)\n{\n\tif (str_width == 0)\n\t\tstr_width = str_len.llen + str_len.mlen + str_len.rlen + (str_len.rlen > 0);\n\n\t/* NOTE: any invalid UTF-8 bytes have already been converted to <xx>\n\t *       (ASCII) where x is hex digit\n\t */\n\n\tif (str_len.llen + str_len.mlen + str_len.rlen <= str_width) {\n\t\t/* all fit */\n\t\tint ws_len = str_width - (str_len.llen + str_len.mlen + str_len.rlen);\n\n\t\tgbuf_add_bytes(buf, l_str.buffer, l_str.len);\n\t\tgbuf_add_bytes(buf, m_str.buffer, m_str.len);\n\t\tgbuf_set(buf, ' ', ws_len);\n\t\tgbuf_add_bytes(buf, r_str.buffer, r_str.len);\n\t} else {\n\t\t/* keep first character since it's almost always padding */\n\t\tint clipped_mark_len = min_u(u_str_width(clipped_text_internal) + 1, str_width);\n\t\tint r_space = str_width - clipped_mark_len;\n\t\tint r_width = min_i(r_space, str_len.rlen);\n\t\tint m_space = r_space - r_width;\n\t\tint m_width = min_i(m_space, str_len.mlen);\n\t\tint l_space = m_space - m_width;\n\t\tint l_width = l_space + clipped_mark_len;\n\t\tint r_idx = 0, ws_pad = 0;\n\n\t\tgbuf_add_ustr(buf, l_str.buffer, &l_width);\n\t\tws_pad += l_width;\n\t\tgbuf_add_ustr(buf, m_str.buffer, &m_width);\n\t\tws_pad += m_width;\n\n\t\tint r_skip = str_len.rlen - r_width;\n\t\tr_idx = u_skip_chars(r_str.buffer, &r_skip, true);\n\t\tws_pad += -r_skip;\n\t\tgbuf_set(buf, ' ', ws_pad);\n\t\tgbuf_add_bytes(buf, r_str.buffer + r_idx, r_str.len - r_idx);\n\t}\n}\n\nstruct fp_len format_print(struct gbuf *buf, int str_width, const char *format, const struct format_option *fopts)\n{\n\tformat_read(str_width, format, fopts);\n\n#if DEBUG > 1\n\tif (str_len.llen > 0) {\n\t\tint ul = u_str_width(l_str.buffer);\n\t\tif (ul != str_len.llen)\n\t\t\td_print(\"L %d != %d: size=%zu '%s'\\n\", ul, str_len.llen, l_str.len, l_str.buffer);\n\t}\n\n\tif (str_len.rlen > 0) {\n\t\tint ul = u_str_width(r_str.buffer);\n\t\tif (ul != str_len.rlen)\n\t\t\td_print(\"R %d != %d: size=%zu '%s'\\n\", ul, str_len.rlen, r_str.len, r_str.buffer);\n\t}\n#endif\n\n\tformat_write(buf, str_width);\n\treturn str_len;\n}\n\nstatic int format_valid_sub(const char *format, const struct format_option *fopts, int f_size);\n\nstatic int format_valid_if(const char *format, const struct format_option *fopts, int *s)\n{\n\tint cond_pos = *s, then_pos = -1, else_pos = -1, end_pos = -1;\n\tif (format_read_cond(format, s, &then_pos, &else_pos, &end_pos) != 0)\n\t\treturn 0;\n\n\tstruct expr *cond = format_parse_cond(format + cond_pos, then_pos - cond_pos);\n\tif (cond == NULL)\n\t\treturn 0;\n\texpr_free(cond);\n\n\tif (!format_valid_sub(format + then_pos + 1, fopts,\n\t\t\t\t(else_pos > 0 ? else_pos : end_pos) - then_pos - 1))\n\t\treturn 0;\n\tif (else_pos > 0)\n\t\tif (!format_valid_sub(format + else_pos + 1, fopts, end_pos - else_pos - 1))\n\t\t\treturn 0;\n\n\t*s = end_pos + 1;\n\treturn 1;\n}\n\nstatic int format_valid_sub(const char *format, const struct format_option *fopts, int f_size)\n{\n\tint s = 0;\n\n\twhile (s < f_size) {\n\t\tuchar u;\n\n\t\tu = u_get_char(format, &s);\n\t\tif (u == '%') {\n\t\t\tint pad_zero = 0, long_len = 0;\n\t\t\tconst struct format_option *fo;\n\t\t\tconst char *long_begin = NULL;\n\n\t\t\tu = u_get_char(format, &s);\n\t\t\tif (u == '%' || u == '?' || u == '!' || u == '=')\n\t\t\t\tcontinue;\n\t\t\tif (u == '-')\n\t\t\t\tu = u_get_char(format, &s);\n\t\t\tif (u == '.')\n\t\t\t\tu = u_get_char(format, &s);\n\t\t\tif (u == '0') {\n\t\t\t\tpad_zero = 1;\n\t\t\t\tu = u_get_char(format, &s);\n\t\t\t}\n\t\t\twhile (isdigit(u))\n\t\t\t\tu = u_get_char(format, &s);\n\t\t\tif (u == '%')\n\t\t\t\tu = u_get_char(format, &s);\n\t\t\tif (u == '{') {\n\t\t\t\tlong_begin = format + s;\n\t\t\t\tif (*long_begin == '?') {\n\t\t\t\t\t++s;\n\t\t\t\t\tif (!format_valid_if(format, fopts, &s))\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\tif (s > f_size)\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\twhile (1) {\n\t\t\t\t\tif (s >= f_size)\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\tu = u_get_char(format, &s);\n\t\t\t\t\tif (u == '}')\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tlong_len++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (fo = fopts; fo->type; fo++) {\n\t\t\t\tif (long_len ? strnequal(fo->str, long_begin, long_len)\n\t\t\t\t\t     : (fo->ch == u)) {\n\t\t\t\t\tif (pad_zero && !fo->pad_zero)\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (! fo->type)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nint format_valid(const char *format, const struct format_option *fopts)\n{\n\treturn format_valid_sub(format, fopts, strlen(format));\n}\n"
        },
        {
          "name": "format_print.h",
          "type": "blob",
          "size": 2.2333984375,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_FORMAT_PRINT_H\n#define CMUS_FORMAT_PRINT_H\n\n#include \"gbuf.h\"\n\nstruct format_option {\n\tunion {\n\t\t/* NULL is treated like \"\" */\n\t\tconst char *fo_str;\n\t\tint fo_int;\n\t\t/* [h:]mm:ss. can be negative */\n\t\tint fo_time;\n\t\tdouble fo_double;\n\t};\n\t/* set to 1 if you want to disable printing */\n\tunsigned int empty : 1;\n\t/* set to 1 if zero padding is allowed */\n\tunsigned int pad_zero : 1;\n\tenum { FO_STR = 1, FO_INT, FO_TIME, FO_DOUBLE } type;\n\tchar ch;\n\tconst char *str;\n};\n\n/* gcc < 4.6 and icc < 12.0 can't properly initialize anonymous unions */\n#if (defined(__GNUC__) && defined(__GNUC_MINOR__) && (__GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 6))) || \\\n\t(defined(__INTEL_COMPILER) && __INTEL_COMPILER < 1200)\n#define UNION_INIT(f, v) { .f = v }\n#else\n#define UNION_INIT(f, v) .f = v\n#endif\n\n#define DEF_FO_STR(c, s, z)    { UNION_INIT(fo_str,  \"\"),   .type = FO_STR,    .pad_zero = z, .ch = c, .str = s }\n#define DEF_FO_INT(c, s, z)    { UNION_INIT(fo_int,  0),    .type = FO_INT,    .pad_zero = z, .ch = c, .str = s }\n#define DEF_FO_TIME(c, s, z)   { UNION_INIT(fo_time, 0),    .type = FO_TIME,   .pad_zero = z, .ch = c, .str = s }\n#define DEF_FO_DOUBLE(c, s, z) { UNION_INIT(fo_double, 0.), .type = FO_DOUBLE, .pad_zero = z, .ch = c, .str = s }\n#define DEF_FO_END             { .type = 0 }\n\nstruct fp_len {\n\tint llen;\n\tint mlen;\n\tint rlen;\n};\n\nstruct fp_len format_print(struct gbuf *buf, int str_width, const char *format, const struct format_option *fopts);\nint format_valid(const char *format, const struct format_option *fopts);\n\n#endif\n"
        },
        {
          "name": "gbuf.c",
          "type": "blob",
          "size": 3.7333984375,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2008 Timo Hirvonen\n *\n * This code is largely based on strbuf in the GIT version control system.\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"gbuf.h\"\n#include \"options.h\"\n#include \"utils.h\"\n#include \"xmalloc.h\"\n\n#include <stdio.h>\n#include <stdarg.h>\n\nchar gbuf_empty_buffer[1];\n\nstatic inline void gbuf_init(struct gbuf *buf)\n{\n\tbuf->buffer = gbuf_empty_buffer;\n\tbuf->alloc = 0;\n\tbuf->len = 0;\n}\n\nvoid gbuf_grow(struct gbuf *buf, size_t more)\n{\n\tsize_t align = 64 - 1;\n\tsize_t alloc = (buf->len + more + 1 + align) & ~align;\n\n\tif (alloc > buf->alloc) {\n\t\tif (!buf->alloc)\n\t\t\tbuf->buffer = NULL;\n\t\tbuf->alloc = alloc;\n\t\tbuf->buffer = xrealloc(buf->buffer, buf->alloc);\n\t\t// gbuf is not NUL terminated if this was first alloc\n\t\tbuf->buffer[buf->len] = 0;\n\t}\n}\n\nvoid gbuf_used(struct gbuf *buf, size_t used)\n{\n\tbuf->len += used;\n\tbuf->buffer[buf->len] = 0;\n}\n\nvoid gbuf_free(struct gbuf *buf)\n{\n\tif (buf->alloc)\n\t\tfree(buf->buffer);\n\tgbuf_init(buf);\n}\n\nvoid gbuf_add_ch(struct gbuf *buf, char ch)\n{\n\tgbuf_grow(buf, 1);\n\tbuf->buffer[buf->len] = ch;\n\tgbuf_used(buf, 1);\n}\n\nvoid gbuf_add_uchar(struct gbuf *buf, uchar u)\n{\n\tsize_t uchar_len = 0;\n\tgbuf_grow(buf, 4);\n\tu_set_char(buf->buffer + buf->len, &uchar_len, u);\n\tgbuf_used(buf, uchar_len);\n}\n\nvoid gbuf_add_bytes(struct gbuf *buf, const void *data, size_t len)\n{\n\tgbuf_grow(buf, len);\n\tmemcpy(buf->buffer + buf->len, data, len);\n\tgbuf_used(buf, len);\n}\n\nvoid gbuf_add_str(struct gbuf *buf, const char *str)\n{\n\tint len = strlen(str);\n\n\tif (!len)\n\t\treturn;\n\tgbuf_grow(buf, len);\n\tmemcpy(buf->buffer + buf->len, str, len);\n\tgbuf_used(buf, len);\n}\n\nstatic int gbuf_mark_clipped_text(struct gbuf *buf)\n{\n\tint buf_width = u_str_width(buf->buffer);\n\tint clipped_mark_len = min_u(u_str_width(clipped_text_internal), buf_width);\n\tint skip = buf_width - clipped_mark_len;\n\tbuf->len = u_skip_chars(buf->buffer, &skip, false);\n\tgbuf_grow(buf, strlen(clipped_text_internal));\n\tgbuf_used(buf, u_copy_chars(buf->buffer + buf->len, clipped_text_internal, &clipped_mark_len));\n\treturn skip;\n}\n\nvoid gbuf_add_ustr(struct gbuf *buf, const char *src, int *width)\n{\n\tint src_bytes = u_str_print_size(src) - 1;\n\tgbuf_grow(buf, src_bytes);\n\tsize_t copy_bytes = u_copy_chars(buf->buffer + buf->len, src, width);\n\tgbuf_used(buf, copy_bytes);\n\tif (copy_bytes != src_bytes) {\n\t\tgbuf_set(buf, ' ', *width);\n\t\t*width = gbuf_mark_clipped_text(buf);\n\t}\n}\n\nvoid gbuf_addf(struct gbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tva_start(ap, fmt);\n\tgbuf_vaddf(buf, fmt, ap);\n\tva_end(ap);\n}\n\nvoid gbuf_vaddf(struct gbuf *buf, const char *fmt, va_list ap)\n{\n\tva_list ap2;\n\tint slen;\n\n\tva_copy(ap2, ap);\n\tslen = vsnprintf(buf->buffer + buf->len, buf->alloc - buf->len, fmt, ap);\n\n\tif (slen > gbuf_avail(buf)) {\n\t\tgbuf_grow(buf, slen);\n\t\tslen = vsnprintf(buf->buffer + buf->len, buf->alloc - buf->len, fmt, ap2);\n\t}\n\tva_end(ap2);\n\tgbuf_used(buf, slen);\n}\n\nvoid gbuf_set(struct gbuf *buf, int c, size_t count)\n{\n\tgbuf_grow(buf, count);\n\tmemset(buf->buffer + buf->len, c, count);\n\tgbuf_used(buf, count);\n}\n\nchar *gbuf_steal(struct gbuf *buf)\n{\n\tchar *b = buf->buffer;\n\tif (!buf->alloc)\n\t\tb = xnew0(char, 1);\n\tgbuf_init(buf);\n\treturn b;\n}\n"
        },
        {
          "name": "gbuf.h",
          "type": "blob",
          "size": 1.9130859375,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2008 Timo Hirvonen\n *\n * This code is largely based on strbuf in the GIT version control system.\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_GBUF_H\n#define CMUS_GBUF_H\n\n#include \"compiler.h\"\n#include \"uchar.h\"\n\n#include <stddef.h> /* size_t */\n#include <stdarg.h>\n\nstruct gbuf {\n\tchar *buffer;\n\tsize_t alloc;\n\tsize_t len;\n};\n\nextern char gbuf_empty_buffer[];\n\n#define GBUF(name) struct gbuf name = { gbuf_empty_buffer, 0, 0 }\n\nstatic inline void gbuf_clear(struct gbuf *buf)\n{\n\tbuf->len = 0;\n\tbuf->buffer[0] = 0;\n}\n\nstatic inline size_t gbuf_avail(struct gbuf *buf)\n{\n\tif (buf->alloc)\n\t\treturn buf->alloc - buf->len - 1;\n\treturn 0;\n}\n\nvoid gbuf_grow(struct gbuf *buf, size_t more);\nvoid gbuf_used(struct gbuf *buf, size_t used);\nvoid gbuf_free(struct gbuf *buf);\nvoid gbuf_add_ch(struct gbuf *buf, char ch);\nvoid gbuf_add_uchar(struct gbuf *buf, uchar u);\nvoid gbuf_add_bytes(struct gbuf *buf, const void *data, size_t len);\nvoid gbuf_add_str(struct gbuf *buf, const char *str);\nvoid gbuf_add_ustr(struct gbuf *buf, const char *src, int *width);\nvoid gbuf_addf(struct gbuf *buf, const char *fmt, ...) CMUS_FORMAT(2, 3);\nvoid gbuf_vaddf(struct gbuf *buf, const char *fmt, va_list ap);\nvoid gbuf_set(struct gbuf *buf, int c, size_t count);\nchar *gbuf_steal(struct gbuf *buf);\n\n#endif\n"
        },
        {
          "name": "glob.c",
          "type": "blob",
          "size": 4.8916015625,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2005 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"glob.h\"\n#include \"uchar.h\"\n#include \"list.h\"\n#include \"xmalloc.h\"\n#include \"debug.h\"\n\n#include <string.h>\n\nstruct glob_item {\n\tstruct list_head node;\n\tenum {\n\t\tGLOB_STAR,\n\t\tGLOB_QMARK,\n\t\tGLOB_TEXT\n\t} type;\n\tchar text[];\n};\n\n/* simplification:\n *\n *   ??*? => ???*\n *   *?*  => ?*\n *   *?   => ?*\n *   ...\n */\nstatic void simplify(struct list_head *head)\n{\n\tstruct list_head *item;\n\n\titem = head->next;\n\twhile (item != head) {\n\t\tstruct list_head *i, *next;\n\t\tint qcount = 0;\n\t\tint scount = 0;\n\n\t\ti = item;\n\t\tdo {\n\t\t\tstruct glob_item *gi;\n\n\t\t\tgi = container_of(i, struct glob_item, node);\n\t\t\tif (gi->type == GLOB_STAR) {\n\t\t\t\tscount++;\n\t\t\t} else if (gi->type == GLOB_QMARK) {\n\t\t\t\tqcount++;\n\t\t\t} else {\n\t\t\t\ti = i->next;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti = i->next;\n\t\t} while (i != head);\n\n\t\tnext = i;\n\n\t\tif (scount) {\n\t\t\t/* move all qmarks to front and\n\t\t\t * if there are >1 stars remove all but the last */\n\t\t\tstruct list_head *insert_after = item->prev;\n\n\t\t\ti = item;\n\t\t\twhile (qcount) {\n\t\t\t\tstruct glob_item *gi;\n\n\t\t\t\tgi = container_of(i, struct glob_item, node);\n\t\t\t\ti = i->next;\n\t\t\t\tif (gi->type == GLOB_QMARK) {\n\t\t\t\t\tlist_del(&gi->node);\n\t\t\t\t\tlist_add(&gi->node, insert_after);\n\t\t\t\t\tqcount--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ti = item;\n\t\t\twhile (scount > 1) {\n\t\t\t\tstruct glob_item *gi;\n\n\t\t\t\tgi = container_of(i, struct glob_item, node);\n\t\t\t\ti = i->next;\n\t\t\t\tif (gi->type == GLOB_STAR) {\n\t\t\t\t\tlist_del(&gi->node);\n\t\t\t\t\tfree(gi);\n\t\t\t\t\tscount--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\titem = next;\n\t}\n}\n\nvoid glob_compile(struct list_head *head, const char *pattern)\n{\n\tint i = 0;\n\n\tlist_init(head);\n\twhile (pattern[i]) {\n\t\tstruct glob_item *item;\n\n\t\tif (pattern[i] == '*') {\n\t\t\titem = xnew(struct glob_item, 1);\n\t\t\titem->type = GLOB_STAR;\n\t\t\ti++;\n\t\t} else if (pattern[i] == '?') {\n\t\t\titem = xnew(struct glob_item, 1);\n\t\t\titem->type = GLOB_QMARK;\n\t\t\ti++;\n\t\t} else {\n\t\t\tint start, len, j;\n\t\t\tchar *str;\n\n\t\t\tstart = i;\n\t\t\tlen = 0;\n\t\t\twhile (pattern[i]) {\n\t\t\t\tif (pattern[i] == '\\\\') {\n\t\t\t\t\ti++;\n\t\t\t\t\tlen++;\n\t\t\t\t\tif (pattern[i])\n\t\t\t\t\t\ti++;\n\t\t\t\t} else if (pattern[i] == '*') {\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (pattern[i] == '?') {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\ti++;\n\t\t\t\t\tlen++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\titem = xmalloc(sizeof(struct glob_item) + len + 1);\n\t\t\titem->type = GLOB_TEXT;\n\n\t\t\tstr = item->text;\n\t\t\ti = start;\n\t\t\tj = 0;\n\t\t\twhile (j < len) {\n\t\t\t\tif (pattern[i] == '\\\\') {\n\t\t\t\t\ti++;\n\t\t\t\t\tif (pattern[i]) {\n\t\t\t\t\t\tstr[j++] = pattern[i++];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstr[j++] = '\\\\';\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tstr[j++] = pattern[i++];\n\t\t\t\t}\n\t\t\t}\n\t\t\tstr[j] = 0;\n\t\t}\n\t\tlist_add_tail(&item->node, head);\n\t}\n\tsimplify(head);\n}\n\nvoid glob_free(struct list_head *head)\n{\n\tstruct list_head *item = head->next;\n\n\twhile (item != head) {\n\t\tstruct glob_item *gi;\n\t\tstruct list_head *next = item->next;\n\n\t\tgi = container_of(item, struct glob_item, node);\n\t\tfree(gi);\n\t\titem = next;\n\t}\n}\n\nstatic int do_glob_match(struct list_head *head, struct list_head *first, const char *text)\n{\n\tstruct list_head *item = first;\n\n\twhile (item != head) {\n\t\tstruct glob_item *gitem;\n\n\t\tgitem = container_of(item, struct glob_item, node);\n\t\tif (gitem->type == GLOB_TEXT) {\n\t\t\tint len = u_strlen(gitem->text);\n\n\t\t\tif (!u_strncase_equal_base(gitem->text, text, len))\n\t\t\t\treturn 0;\n\t\t\ttext += strlen(gitem->text);\n\t\t} else if (gitem->type == GLOB_QMARK) {\n\t\t\tuchar u;\n\t\t\tint idx = 0;\n\n\t\t\tu = u_get_char(text, &idx);\n\t\t\tif (u == 0)\n\t\t\t\treturn 0;\n\t\t\ttext += idx;\n\t\t} else if (gitem->type == GLOB_STAR) {\n\t\t\t/* after star there MUST be normal text (or nothing),\n\t\t\t * question marks have been moved before this star and\n\t\t\t * other stars have been stripped (see simplify)\n\t\t\t */\n\t\t\tstruct list_head *next;\n\t\t\tstruct glob_item *next_gi;\n\t\t\tconst char *t;\n\t\t\tint tlen;\n\n\t\t\tnext = item->next;\n\t\t\tif (next == head) {\n\t\t\t\t/* this star was the last item => matched */\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tnext_gi = container_of(next, struct glob_item, node);\n\t\t\tBUG_ON(next_gi->type != GLOB_TEXT);\n\t\t\tt = next_gi->text;\n\t\t\ttlen = strlen(t);\n\t\t\twhile (1) {\n\t\t\t\tconst char *pos;\n\n\t\t\t\tpos = u_strcasestr_base(text, t);\n\t\t\t\tif (pos == NULL)\n\t\t\t\t\treturn 0;\n\t\t\t\tif (do_glob_match(head, next->next, pos + tlen))\n\t\t\t\t\treturn 1;\n\t\t\t\ttext = pos + 1;\n\t\t\t}\n\t\t}\n\t\titem = item->next;\n\t}\n\treturn text[0] == 0;\n}\n\nint glob_match(struct list_head *head, const char *text)\n{\n\treturn do_glob_match(head, head->next, text);\n}\n"
        },
        {
          "name": "glob.h",
          "type": "blob",
          "size": 0.9345703125,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2005 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_GLOB_H\n#define CMUS_GLOB_H\n\n#include \"list.h\"\n\nvoid glob_compile(struct list_head *head, const char *pattern);\nvoid glob_free(struct list_head *head);\nint glob_match(struct list_head *head, const char *text);\n\n#endif\n"
        },
        {
          "name": "help.c",
          "type": "blob",
          "size": 7.4365234375,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2006 <ft@bewatermyfriend.org>\n *\n * heavily based on filters.c\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"help.h\"\n#include \"window.h\"\n#include \"search.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include \"keys.h\"\n#include \"command_mode.h\"\n#include \"ui_curses.h\"\n#include \"options.h\"\n#include \"cmdline.h\"\n\n#include <stdio.h>\n\nstruct window *help_win;\nstruct searchable *help_searchable;\n\nstatic LIST_HEAD(help_head);\nstatic struct list_head *bound_head;\nstatic struct list_head *bound_tail;\nstatic struct list_head *unbound_head;\nstatic struct list_head *unbound_tail;\n\nstatic inline void help_entry_to_iter(struct help_entry *e, struct iter *iter)\n{\n\titer->data0 = &help_head;\n\titer->data1 = e;\n\titer->data2 = NULL;\n}\n\nstatic GENERIC_ITER_PREV(help_get_prev, struct help_entry, node)\nstatic GENERIC_ITER_NEXT(help_get_next, struct help_entry, node)\n\nstatic int help_search_get_current(void *data, struct iter *iter, enum search_direction dir)\n{\n\treturn window_get_sel(help_win, iter);\n}\n\nstatic int help_search_matches(void *data, struct iter *iter, const char *text)\n{\n\tint matched = 0;\n\tchar **words = get_words(text);\n\n\tif (words[0] != NULL) {\n\t\tstruct help_entry *ent;\n\t\tint i;\n\n\t\tent = iter_to_help_entry(iter);\n\t\tfor (i = 0; ; i++) {\n\t\t\tif (words[i] == NULL) {\n\t\t\t\twindow_set_sel(help_win, iter);\n\t\t\t\tmatched = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ent->type == HE_TEXT) {\n\t\t\t\tif (!u_strcasestr(ent->text, words[i]))\n\t\t\t\t\tbreak;\n\t\t\t} else if (ent->type == HE_BOUND) {\n\t\t\t\tif (!u_strcasestr(ent->binding->cmd, words[i]) &&\n\t\t\t\t\t!u_strcasestr(ent->binding->key->name, words[i]))\n\t\t\t\t\tbreak;\n\t\t\t} else if (ent->type == HE_UNBOUND) {\n\t\t\t\tif (!u_strcasestr(ent->command->name, words[i]))\n\t\t\t\t\tbreak;\n\t\t\t} else if (ent->type == HE_OPTION) {\n\t\t\t\tif (!u_strcasestr(ent->option->name, words[i]))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfree_str_array(words);\n\treturn matched;\n}\n\nstatic const struct searchable_ops help_search_ops = {\n\t.get_prev = help_get_prev,\n\t.get_next = help_get_next,\n\t.get_current = help_search_get_current,\n\t.matches = help_search_matches\n};\n\nstatic void help_add_text(const char *s)\n{\n\tstruct help_entry *ent;\n\tent = xnew(struct help_entry, 1);\n\tent->type = HE_TEXT;\n\tent->text = s;\n\tlist_add_tail(&ent->node, &help_head);\n}\n\nstatic void help_add_defaults(void)\n{\n\tstruct cmus_opt *opt;\n\n\thelp_add_text(\"Keybindings\");\n\thelp_add_text(\"-----------\");\n\tbound_head = help_head.prev;\n\thelp_add_text(\"\");\n\thelp_add_text(\"Unbound Commands\");\n\thelp_add_text(\"----------------\");\n\tunbound_head = help_head.prev;\n\thelp_add_text(\"\");\n\thelp_add_text(\"Options\");\n\thelp_add_text(\"-------\");\n\n\tlist_for_each_entry(opt, &option_head, node) {\n\t\tstruct help_entry *ent = xnew(struct help_entry, 1);\n\n\t\tent->type = HE_OPTION;\n\t\tent->option = opt;\n\t\tlist_add_tail(&ent->node, &help_head);\n\t}\n\n\tbound_tail = bound_head->next;\n\tunbound_tail = unbound_head->next;\n}\n\nvoid help_remove_unbound(struct command *cmd)\n{\n\tstruct help_entry *ent;\n\tstruct iter i;\n\tlist_for_each_entry(ent, &help_head, node) {\n\t\tif (ent->type != HE_UNBOUND)\n\t\t\tcontinue;\n\t\tif (ent->command == cmd) {\n\t\t\thelp_entry_to_iter(ent, &i);\n\t\t\twindow_row_vanishes(help_win, &i);\n\t\t\tlist_del(&ent->node);\n\t\t\tfree(ent);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic void list_add_sorted(struct list_head *new, struct list_head *head,\n\t\tstruct list_head *tail,\n\t\tint (*cmp)(struct list_head *, struct list_head *))\n{\n\tstruct list_head *item = tail->prev;\n\n\twhile (item != head) {\n\t\tif (cmp(new, item) >= 0)\n\t\t\tbreak;\n\t\titem = item->prev;\n\t}\n\t/* add after item */\n\tlist_add(new, item);\n}\n\nstatic int bound_cmp(struct list_head *ai, struct list_head *bi)\n{\n\tstruct help_entry *a = container_of(ai, struct help_entry, node);\n\tstruct help_entry *b = container_of(bi, struct help_entry, node);\n\tint ret = a->binding->ctx - b->binding->ctx;\n\n\tif (!ret)\n\t\tret = strcmp(a->binding->key->name, b->binding->key->name);\n\treturn ret;\n}\n\nstatic int unbound_cmp(struct list_head *ai, struct list_head *bi)\n{\n\tstruct help_entry *a = container_of(ai, struct help_entry, node);\n\tstruct help_entry *b = container_of(bi, struct help_entry, node);\n\n\treturn strcmp(a->command->name, b->command->name);\n}\n\nvoid help_add_unbound(struct command *cmd)\n{\n\tstruct help_entry *ent;\n\n\tent = xnew(struct help_entry, 1);\n\tent->type = HE_UNBOUND;\n\tent->command = cmd;\n\tlist_add_sorted(&ent->node, unbound_head, unbound_tail, unbound_cmp);\n}\n\nvoid help_add_all_unbound(void)\n{\n\tint i;\n\tfor (i = 0; commands[i].name; ++i)\n\t\tif (!commands[i].bc)\n\t\t\thelp_add_unbound(&commands[i]);\n}\n\nvoid help_select(void)\n{\n\tstruct iter sel;\n\tstruct help_entry *ent;\n\tchar buf[OPTION_MAX_SIZE];\n\n\tif (!window_get_sel(help_win, &sel))\n\t\treturn;\n\n\tent = iter_to_help_entry(&sel);\n\tswitch (ent->type) {\n\tcase HE_BOUND:\n\t\tsnprintf(buf, sizeof(buf), \"bind -f %s %s %s\",\n\t\t\t\tkey_context_names[ent->binding->ctx],\n\t\t\t\tent->binding->key->name,\n\t\t\t\tent->binding->cmd);\n\t\tcmdline_set_text(buf);\n\t\tenter_command_mode();\n\t\tbreak;\n\tcase HE_UNBOUND:\n\t\tsnprintf(buf, sizeof(buf), \"bind common <key> %s\",\n\t\t\t\tent->command->name);\n\t\tcmdline_set_text(buf);\n\t\tenter_command_mode();\n\t\tbreak;\n\tcase HE_OPTION:\n\t\tsnprintf(buf, sizeof(buf), \"set %s=\", ent->option->name);\n\t\tsize_t len = strlen(buf);\n\t\tent->option->get(ent->option->data, buf + len, sizeof(buf) - len);\n\t\tcmdline_set_text(buf);\n\t\tenter_command_mode();\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nvoid help_toggle(void)\n{\n\tstruct iter sel;\n\tstruct help_entry *ent;\n\n\tif (!window_get_sel(help_win, &sel))\n\t\treturn;\n\n\tent = iter_to_help_entry(&sel);\n\tswitch (ent->type) {\n\tcase HE_OPTION:\n\t\tif (ent->option->toggle) {\n\t\t\tent->option->toggle(ent->option->data);\n\t\t\thelp_win->changed = 1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nvoid help_remove(void)\n{\n\tstruct iter sel;\n\tstruct help_entry *ent;\n\n\tif (!window_get_sel(help_win, &sel))\n\t\treturn;\n\n\tent = iter_to_help_entry(&sel);\n\tswitch (ent->type) {\n\tcase HE_BOUND:\n\t\tif (yes_no_query(\"Remove selected binding? [y/N]\") == UI_QUERY_ANSWER_YES)\n\t\t\tkey_unbind(key_context_names[ent->binding->ctx],\n\t\t\t\t\tent->binding->key->name, 0);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nvoid help_add_bound(const struct binding *bind)\n{\n\tstruct help_entry *ent;\n\tent = xnew(struct help_entry, 1);\n\tent->type = HE_BOUND;\n\tent->binding = bind;\n\tlist_add_sorted(&ent->node, bound_head, bound_tail, bound_cmp);\n}\n\nvoid help_remove_bound(const struct binding *bind)\n{\n\tstruct help_entry *ent;\n\tstruct iter i;\n\tlist_for_each_entry(ent, &help_head, node) {\n\t\tif (ent->binding == bind) {\n\t\t\thelp_entry_to_iter(ent, &i);\n\t\t\twindow_row_vanishes(help_win, &i);\n\t\t\tlist_del(&ent->node);\n\t\t\tfree(ent);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nvoid help_init(void)\n{\n\tstruct iter iter;\n\n\thelp_win = window_new(help_get_prev, help_get_next);\n\twindow_set_contents(help_win, &help_head);\n\twindow_changed(help_win);\n\thelp_add_defaults();\n\n\titer.data0 = &help_head;\n\titer.data1 = NULL;\n\titer.data2 = NULL;\n\thelp_searchable = searchable_new(NULL, &iter, &help_search_ops);\n}\n\nvoid help_exit(void)\n{\n\tsearchable_free(help_searchable);\n\twindow_free(help_win);\n}\n"
        },
        {
          "name": "help.h",
          "type": "blob",
          "size": 1.7451171875,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2006 <ft@bewatermyfriend.org>\n *\n * heavily based on filters.h\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_HELP_H\n#define CMUS_HELP_H\n\n#include \"list.h\"\n#include \"window.h\"\n#include \"search.h\"\n#include \"keys.h\"\n\nstruct help_entry {\n\tstruct list_head node;\n\tenum {\n\t\tHE_TEXT,\t\t/* text entries \t*/\n\t\tHE_BOUND,\t\t/* bound keys\t\t*/\n\t\tHE_UNBOUND,\t\t/* unbound commands\t*/\n\t\tHE_OPTION,\n\t} type;\n\tunion {\n\t\tconst char *text;\t\t\t/* HE_TEXT\t*/\n\t\tconst struct binding *binding;\t\t/* HE_BOUND\t*/\n\t\tconst struct command *command;\t\t/* HE_UNBOUND\t*/\n\t\tconst struct cmus_opt *option;\n\t};\n};\n\nstatic inline struct help_entry *iter_to_help_entry(struct iter *iter)\n{\n\treturn iter->data1;\n}\n\nextern struct window *help_win;\nextern struct searchable *help_searchable;\n\nvoid help_select(void);\nvoid help_toggle(void);\nvoid help_remove(void);\n\nvoid help_add_bound(const struct binding *bind);\nvoid help_remove_bound(const struct binding *bind);\nvoid help_remove_unbound(struct command *cmd);\nvoid help_add_unbound(struct command *cmd);\nvoid help_add_all_unbound(void);\n\nvoid help_init(void);\nvoid help_exit(void);\n\n#endif /* HELP_H */\n"
        },
        {
          "name": "history.c",
          "type": "blob",
          "size": 4.8359375,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004-2005 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"history.h\"\n#include \"xmalloc.h\"\n#include \"file.h\"\n#include \"uchar.h\"\n#include \"list.h\"\n#include \"prog.h\"\n\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdio.h>\n\nstruct history_entry {\n\tstruct list_head node;\n\tchar *text;\n};\n\nstatic struct history_entry *history_entry_new(const char *text)\n{\n\tstruct history_entry *new;\n\tnew = xnew(struct history_entry, 1);\n\tnew->text = xstrdup(text);\n\treturn new;\n}\n\nstatic void history_entry_free(struct history_entry *history)\n{\n\tfree(history->text);\n\tfree(history);\n}\n\nvoid history_free(struct history *history)\n{\n\tstruct list_head *item, *temp;\n\tlist_for_each_safe(item, temp, &history->head) {\n\t\tstruct history_entry *history_entry;\n\t\thistory_entry = list_entry(item, struct history_entry, node);\n\t\thistory_entry_free(history_entry);\n\t}\n}\n\nstatic int history_add_tail(void *data, const char *line)\n{\n\tstruct history *history = data;\n\n\tif (history->lines < history->max_lines) {\n\t\tstruct history_entry *new;\n\n\t\tnew = history_entry_new(line);\n\t\tlist_add_tail(&new->node, &history->head);\n\t\thistory->lines++;\n\t}\n\treturn 0;\n}\n\nvoid history_load(struct history *history, char *filename, int max_lines)\n{\n\tlist_init(&history->head);\n\thistory->max_lines = max_lines;\n\thistory->lines = 0;\n\thistory->search_pos = NULL;\n\thistory->filename = filename;\n\tfile_for_each_line(filename, history_add_tail, history);\n}\n\nvoid history_save(struct history *history)\n{\n\tchar filename_tmp[512];\n\tstruct list_head *item;\n\tint fd;\n\tssize_t rc;\n\n\tsnprintf(filename_tmp, sizeof(filename_tmp), \"%s.tmp\", history->filename);\n\tfd = open(filename_tmp, O_CREAT | O_WRONLY | O_TRUNC, 0666);\n\tif (fd == -1)\n\t\treturn;\n\tlist_for_each(item, &history->head) {\n\t\tstruct history_entry *history_entry;\n\t\tconst char nl = '\\n';\n\n\t\thistory_entry = list_entry(item, struct history_entry, node);\n\n\t\trc = write(fd, history_entry->text, strlen(history_entry->text));\n\t\tif (rc == -1)\n\t\t\tgoto out;\n\n\t\trc = write(fd, &nl, 1);\n\t\tif (rc == -1)\n\t\t\tgoto out;\n\t}\nout:\n\tclose(fd);\n\n\trc = rename(filename_tmp, history->filename);\n\tif (rc)\n\t\twarn_errno(\"renaming %s to %s\", filename_tmp, history->filename);\n}\n\nvoid history_add_line(struct history *history, const char *line)\n{\n\tstruct history_entry *new;\n\tstruct list_head *item;\n\n\tnew = history_entry_new(line);\n\tlist_add(&new->node, &history->head);\n\thistory->lines++;\n\n\t/* remove identical */\n\titem = history->head.next->next;\n\twhile (item != &history->head) {\n\t\tstruct list_head *next = item->next;\n\t\tstruct history_entry *hentry;\n\n\t\thentry = container_of(item, struct history_entry, node);\n\t\tif (strcmp(hentry->text, new->text) == 0) {\n\t\t\tlist_del(item);\n\t\t\thistory_entry_free(hentry);\n\t\t\thistory->lines--;\n\t\t}\n\t\titem = next;\n\t}\n\n\t/* remove oldest if history is 'full' */\n\tif (history->lines > history->max_lines) {\n\t\tstruct list_head *node;\n\t\tstruct history_entry *hentry;\n\n\t\tnode = history->head.prev;\n\t\tlist_del(node);\n\t\thentry = list_entry(node, struct history_entry, node);\n\t\thistory_entry_free(hentry);\n\t\thistory->lines--;\n\t}\n}\n\nvoid history_reset_search(struct history *history)\n{\n\thistory->search_pos = NULL;\n}\n\nconst char *history_search_forward(struct history *history, const char *text)\n{\n\tstruct list_head *item;\n\tint search_len;\n\n\tif (history->search_pos == NULL) {\n\t\t/* first time to search. set search */\n\t\titem = history->head.next;\n\t} else {\n\t\titem = history->search_pos->next;\n\t}\n\tsearch_len = strlen(text);\n\twhile (item != &history->head) {\n\t\tstruct history_entry *hentry;\n\n\t\thentry = list_entry(item, struct history_entry, node);\n\t\tif (strncmp(text, hentry->text, search_len) == 0) {\n\t\t\thistory->search_pos = item;\n\t\t\treturn hentry->text;\n\t\t}\n\t\titem = item->next;\n\t}\n\treturn NULL;\n}\n\nconst char *history_search_backward(struct history *history, const char *text)\n{\n\tstruct list_head *item;\n\tint search_len;\n\n\tif (history->search_pos == NULL)\n\t\treturn NULL;\n\titem = history->search_pos->prev;\n\tsearch_len = strlen(text);\n\twhile (item != &history->head) {\n\t\tstruct history_entry *hentry;\n\n\t\thentry = list_entry(item, struct history_entry, node);\n\t\tif (strncmp(text, hentry->text, search_len) == 0) {\n\t\t\thistory->search_pos = item;\n\t\t\treturn hentry->text;\n\t\t}\n\t\titem = item->prev;\n\t}\n\thistory->search_pos = NULL;\n\treturn NULL;\n}\n"
        },
        {
          "name": "history.h",
          "type": "blob",
          "size": 1.330078125,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_HISTORY_H\n#define CMUS_HISTORY_H\n\n#include \"list.h\"\n\nstruct history {\n\tstruct list_head head;\n\tstruct list_head *search_pos;\n\tchar *filename;\n\tint max_lines;\n\tint lines;\n};\n\nvoid history_load(struct history *history, char *filename, int max_lines);\nvoid history_save(struct history *history);\nvoid history_free(struct history *history);\nvoid history_add_line(struct history *history, const char *line);\nvoid history_reset_search(struct history *history);\nconst char *history_search_forward(struct history *history, const char *text);\nconst char *history_search_backward(struct history *history, const char *text);\n\n#endif\n"
        },
        {
          "name": "http.c",
          "type": "blob",
          "size": 10.1162109375,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004-2005 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"http.h\"\n#include \"file.h\"\n#include \"debug.h\"\n#include \"xmalloc.h\"\n#include \"gbuf.h\"\n\n#include <stdio.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/select.h>\n#include <netinet/in.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <string.h>\n#include <errno.h>\n\n/*\n * @uri is http://[user[:pass]@]host[:port][/path][?query]\n *\n * uri(7): If the URL supplies a user  name  but no  password, and the remote\n * server requests a password, the program interpreting the URL should request\n * one from the user.\n */\nint http_parse_uri(const char *uri, struct http_uri *u)\n{\n\tconst char *str, *colon, *at, *slash, *host_start;\n\n\t/* initialize all fields */\n\tu->uri  = xstrdup(uri);\n\tu->user = NULL;\n\tu->pass = NULL;\n\tu->host = NULL;\n\tu->path = NULL;\n\tu->port = 80;\n\n\tif (strncmp(uri, \"http://\", 7))\n\t\treturn -1;\n\tstr = uri + 7;\n\thost_start = str;\n\n\t/* [/path] */\n\tslash = strchr(str, '/');\n\tif (slash) {\n\t\tu->path = xstrdup(slash);\n\t} else {\n\t\tu->path = xstrdup(\"/\");\n\t}\n\n\t/* [user[:pass]@] */\n\tat = strchr(str, '@');\n\tif (at && (!slash || at < slash)) {\n\t\t/* user[:pass]@ */\n\t\thost_start = at + 1;\n\t\tcolon = strchr(str, ':');\n\t\tif (colon == NULL || colon > at) {\n\t\t\t/* user */\n\t\t\tu->user = xstrndup(str, at - str);\n\t\t} else {\n\t\t\t/* user:pass */\n\t\t\tu->user = xstrndup(str, colon - str);\n\t\t\tu->pass = xstrndup(colon + 1, at - (colon + 1));\n\t\t}\n\t}\n\n\t/* host[:port] */\n\tcolon = strchr(host_start, ':');\n\tif (colon && (!slash || colon < slash)) {\n\t\t/* host:port */\n\t\tconst char *start;\n\t\tint port;\n\n\t\tu->host = xstrndup(host_start, colon - host_start);\n\t\tcolon++;\n\t\tstart = colon;\n\n\t\tport = 0;\n\t\twhile (*colon >= '0' && *colon <= '9') {\n\t\t\tport *= 10;\n\t\t\tport += *colon - '0';\n\t\t\tcolon++;\n\t\t}\n\t\tu->port = port;\n\n\t\tif (colon == start || (*colon != 0 && *colon != '/')) {\n\t\t\thttp_free_uri(u);\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\t/* host */\n\t\tif (slash) {\n\t\t\tu->host = xstrndup(host_start, slash - host_start);\n\t\t} else {\n\t\t\tu->host = xstrdup(host_start);\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid http_free_uri(struct http_uri *u)\n{\n\tfree(u->uri);\n\tfree(u->user);\n\tfree(u->pass);\n\tfree(u->host);\n\tfree(u->path);\n\n\tu->uri  = NULL;\n\tu->user = NULL;\n\tu->pass = NULL;\n\tu->host = NULL;\n\tu->path = NULL;\n}\n\nint http_open(struct http_get *hg, int timeout_ms)\n{\n\tconst struct addrinfo hints = {\n\t\t.ai_socktype = SOCK_STREAM\n\t};\n\tstruct addrinfo *result;\n\tunion {\n\t\tstruct sockaddr sa;\n\t\tstruct sockaddr_storage sas;\n\t} addr;\n\tsize_t addrlen;\n\tstruct timeval tv;\n\tint save, flags, rc;\n\tchar port[16];\n\n\tchar *proxy = getenv(\"http_proxy\");\n\tif (proxy) {\n\t\thg->proxy = xnew(struct http_uri, 1);\n\t\tif (http_parse_uri(proxy, hg->proxy)) {\n\t\t\td_print(\"Failed to parse HTTP proxy URI '%s'\\n\", proxy);\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\thg->proxy = NULL;\n\t}\n\n\tsnprintf(port, sizeof(port), \"%d\", hg->proxy ? hg->proxy->port : hg->uri.port);\n\trc = getaddrinfo(hg->proxy ? hg->proxy->host : hg->uri.host, port, &hints, &result);\n\tif (rc != 0) {\n\t\td_print(\"getaddrinfo: %s\\n\", gai_strerror(rc));\n\t\treturn -1;\n\t}\n\tmemcpy(&addr.sa, result->ai_addr, result->ai_addrlen);\n\taddrlen = result->ai_addrlen;\n\tfreeaddrinfo(result);\n\n\thg->fd = socket(addr.sa.sa_family, SOCK_STREAM, 0);\n\tif (hg->fd == -1)\n\t\treturn -1;\n\n\tflags = fcntl(hg->fd, F_GETFL);\n\tif (fcntl(hg->fd, F_SETFL, O_NONBLOCK) == -1)\n\t\tgoto close_exit;\n\n\ttv.tv_sec = timeout_ms / 1000;\n\ttv.tv_usec = (timeout_ms % 1000) * 1000;\n\twhile (1) {\n\t\tfd_set wfds;\n\n\t\td_print(\"connecting. timeout=%lld s %lld us\\n\", (long long)tv.tv_sec, (long long)tv.tv_usec);\n\t\tif (connect(hg->fd, &addr.sa, addrlen) == 0)\n\t\t\tbreak;\n\t\tif (errno == EISCONN)\n\t\t\tbreak;\n\t\tif (errno != EAGAIN && errno != EINPROGRESS)\n\t\t\tgoto close_exit;\n\n\t\tFD_ZERO(&wfds);\n\t\tFD_SET(hg->fd, &wfds);\n\t\twhile (1) {\n\t\t\trc = select(hg->fd + 1, NULL, &wfds, NULL, &tv);\n\t\t\tif (rc == -1) {\n\t\t\t\tif (errno != EINTR)\n\t\t\t\t\tgoto close_exit;\n\t\t\t\t/* signalled */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (rc == 1) {\n\t\t\t\t/* socket ready */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (tv.tv_sec == 0 && tv.tv_usec == 0) {\n\t\t\t\terrno = ETIMEDOUT;\n\t\t\t\tgoto close_exit;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* restore old flags */\n\tif (fcntl(hg->fd, F_SETFL, flags) == -1)\n\t\tgoto close_exit;\n\treturn 0;\nclose_exit:\n\tsave = errno;\n\tclose(hg->fd);\n\terrno = save;\n\treturn -1;\n}\n\nstatic int http_write(int fd, const char *buf, int count, int timeout_ms)\n{\n\tstruct timeval tv;\n\tint pos = 0;\n\n\ttv.tv_sec = timeout_ms / 1000;\n\ttv.tv_usec = (timeout_ms % 1000) * 1000;\n\twhile (1) {\n\t\tfd_set wfds;\n\t\tint rc;\n\n\t\td_print(\"timeout=%lld s %lld us\\n\", (long long)tv.tv_sec, (long long)tv.tv_usec);\n\n\t\tFD_ZERO(&wfds);\n\t\tFD_SET(fd, &wfds);\n\t\trc = select(fd + 1, NULL, &wfds, NULL, &tv);\n\t\tif (rc == -1) {\n\t\t\tif (errno != EINTR)\n\t\t\t\treturn -1;\n\t\t\t/* signalled */\n\t\t\tcontinue;\n\t\t}\n\t\tif (rc == 1) {\n\t\t\trc = write(fd, buf + pos, count - pos);\n\t\t\tif (rc == -1) {\n\t\t\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\t\t\tcontinue;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tpos += rc;\n\t\t\tif (pos == count)\n\t\t\t\treturn 0;\n\t\t} else if (tv.tv_sec == 0 && tv.tv_usec == 0) {\n\t\t\terrno = ETIMEDOUT;\n\t\t\treturn -1;\n\t\t}\n\t}\n}\n\nstatic int read_timeout(int fd, int timeout_ms)\n{\n\tstruct timeval tv;\n\n\ttv.tv_sec = timeout_ms / 1000;\n\ttv.tv_usec = (timeout_ms % 1000) * 1000;\n\twhile (1) {\n\t\tfd_set rfds;\n\t\tint rc;\n\n\t\tFD_ZERO(&rfds);\n\t\tFD_SET(fd, &rfds);\n\t\trc = select(fd + 1, &rfds, NULL, NULL, &tv);\n\t\tif (rc == -1) {\n\t\t\tif (errno != EINTR)\n\t\t\t\treturn -1;\n\t\t\t/* signalled */\n\t\t\tcontinue;\n\t\t}\n\t\tif (rc == 1)\n\t\t\treturn 0;\n\t\tif (tv.tv_sec == 0 && tv.tv_usec == 0) {\n\t\t\terrno = ETIMEDOUT;\n\t\t\treturn -1;\n\t\t}\n\t}\n}\n\n/* reads response, ignores fscking carriage returns */\nstatic int http_read_response(int fd, struct gbuf *buf, int timeout_ms)\n{\n\tchar prev = 0;\n\n\tif (read_timeout(fd, timeout_ms))\n\t\treturn -1;\n\twhile (1) {\n\t\tint rc;\n\t\tchar ch;\n\n\t\trc = read(fd, &ch, 1);\n\t\tif (rc == -1) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (rc == 0) {\n\t\t\treturn -2;\n\t\t}\n\t\tif (ch == '\\r')\n\t\t\tcontinue;\n\t\tif (ch == '\\n' && prev == '\\n')\n\t\t\treturn 0;\n\t\tgbuf_add_ch(buf, ch);\n\t\tprev = ch;\n\t}\n}\n\nstatic int http_parse_response(char *str, struct http_get *hg)\n{\n\t/* str is 0 terminated buffer of lines\n\t * every line ends with '\\n'\n\t * no carriage returns\n\t * no empty lines\n\t */\n\tGROWING_KEYVALS(h);\n\tchar *end;\n\n\tif (strncmp(str, \"HTTP/\", 5) == 0) {\n\t\tstr += 5;\n\t\twhile (*str != ' ') {\n\t\t\tif (*str == '\\n') {\n\t\t\t\treturn -2;\n\t\t\t}\n\t\t\tstr++;\n\t\t}\n\t} else if (strncmp(str, \"ICY\", 3) == 0) {\n\t\tstr += 3;\n\t} else {\n\t\treturn -2;\n\t}\n\twhile (*str == ' ')\n\t\tstr++;\n\n\thg->code = 0;\n\twhile (*str >= '0' && *str <= '9') {\n\t\thg->code *= 10;\n\t\thg->code += *str - '0';\n\t\tstr++;\n\t}\n\tif (!hg->code)\n\t\treturn -2;\n\twhile (*str == ' ')\n\t\tstr++;\n\n\tend = strchr(str, '\\n');\n\thg->reason = xstrndup(str, end - str);\n\tstr = end + 1;\n\n\t/* headers */\n\twhile (*str) {\n\t\tchar *ptr;\n\n\t\tend = strchr(str, '\\n');\n\t\tptr = strchr(str, ':');\n\t\tif (ptr == NULL || ptr > end) {\n\t\t\tfree(hg->reason);\n\t\t\thg->reason = NULL;\n\t\t\tkeyvals_terminate(&h);\n\t\t\tkeyvals_free(h.keyvals);\n\t\t\treturn -2;\n\t\t}\n\n\t\t*ptr++ = 0;\n\t\twhile (*ptr == ' ')\n\t\t\tptr++;\n\n\t\tkeyvals_add(&h, str, xstrndup(ptr, end - ptr));\n\t\tstr = end + 1;\n\t}\n\tkeyvals_terminate(&h);\n\thg->headers = h.keyvals;\n\treturn 0;\n}\n\nint http_get(struct http_get *hg, struct keyval *headers, int timeout_ms)\n{\n\tGBUF(buf);\n\tint i, rc, save;\n\n\tgbuf_add_str(&buf, \"GET \");\n\tgbuf_add_str(&buf, hg->proxy ? hg->uri.uri : hg->uri.path);\n\tgbuf_add_str(&buf, \" HTTP/1.0\\r\\n\");\n\tfor (i = 0; headers[i].key; i++) {\n\t\tgbuf_add_str(&buf, headers[i].key);\n\t\tgbuf_add_str(&buf, \": \");\n\t\tgbuf_add_str(&buf, headers[i].val);\n\t\tgbuf_add_str(&buf, \"\\r\\n\");\n\t}\n\tgbuf_add_str(&buf, \"\\r\\n\");\n\n\trc = http_write(hg->fd, buf.buffer, buf.len, timeout_ms);\n\tif (rc)\n\t\tgoto out;\n\n\tgbuf_clear(&buf);\n\trc = http_read_response(hg->fd, &buf, timeout_ms);\n\tif (rc)\n\t\tgoto out;\n\n\trc = http_parse_response(buf.buffer, hg);\nout:\n\tsave = errno;\n\tgbuf_free(&buf);\n\terrno = save;\n\treturn rc;\n}\n\nchar *http_read_body(int fd, size_t *size, int timeout_ms)\n{\n\tGBUF(buf);\n\n\tif (read_timeout(fd, timeout_ms))\n\t\treturn NULL;\n\twhile (1) {\n\t\tint count = 1023;\n\t\tint rc;\n\n\t\tgbuf_grow(&buf, count);\n\t\trc = read_all(fd, buf.buffer + buf.len, count);\n\t\tif (rc == -1) {\n\t\t\tgbuf_free(&buf);\n\t\t\treturn NULL;\n\t\t}\n\t\tbuf.len += rc;\n\t\tif (rc == 0) {\n\t\t\t*size = buf.len;\n\t\t\treturn gbuf_steal(&buf);\n\t\t}\n\t}\n}\n\nvoid http_get_free(struct http_get *hg)\n{\n\thttp_free_uri(&hg->uri);\n\tif (hg->proxy) {\n\t\thttp_free_uri(hg->proxy);\n\t\tfree(hg->proxy);\n\t}\n\tif (hg->headers)\n\t\tkeyvals_free(hg->headers);\n\tfree(hg->reason);\n}\n\nchar *base64_encode(const char *str)\n{\n\tstatic const char t[64] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\tint str_len, buf_len, i, s, d;\n\tchar *buf;\n\tunsigned char b0, b1, b2;\n\n\tstr_len = strlen(str);\n\tbuf_len = (str_len + 2) / 3 * 4 + 1;\n\tbuf = xnew(char, buf_len);\n\ts = 0;\n\td = 0;\n\tfor (i = 0; i < str_len / 3; i++) {\n\t\tb0 = str[s++];\n\t\tb1 = str[s++];\n\t\tb2 = str[s++];\n\n\t\t/* 6 ms bits of b0 */\n\t\tbuf[d++] = t[b0 >> 2];\n\n\t\t/* 2 ls bits of b0 . 4 ms bits of b1 */\n\t\tbuf[d++] = t[((b0 << 4) | (b1 >> 4)) & 0x3f];\n\n\t\t/* 4 ls bits of b1 . 2 ms bits of b2 */\n\t\tbuf[d++] = t[((b1 << 2) | (b2 >> 6)) & 0x3f];\n\n\t\t/* 6 ls bits of b2 */\n\t\tbuf[d++] = t[b2 & 0x3f];\n\t}\n\tswitch (str_len % 3) {\n\tcase 2:\n\t\tb0 = str[s++];\n\t\tb1 = str[s++];\n\n\t\t/* 6 ms bits of b0 */\n\t\tbuf[d++] = t[b0 >> 2];\n\n\t\t/* 2 ls bits of b0 . 4 ms bits of b1 */\n\t\tbuf[d++] = t[((b0 << 4) | (b1 >> 4)) & 0x3f];\n\n\t\t/* 4 ls bits of b1 */\n\t\tbuf[d++] = t[(b1 << 2) & 0x3f];\n\n\t\tbuf[d++] = '=';\n\t\tbreak;\n\tcase 1:\n\t\tb0 = str[s++];\n\n\t\t/* 6 ms bits of b0 */\n\t\tbuf[d++] = t[b0 >> 2];\n\n\t\t/* 2 ls bits of b0 */\n\t\tbuf[d++] = t[(b0 << 4) & 0x3f];\n\n\t\tbuf[d++] = '=';\n\t\tbuf[d++] = '=';\n\t\tbreak;\n\tcase 0:\n\t\tbreak;\n\t}\n\tbuf[d] = 0;\n\treturn buf;\n}\n"
        },
        {
          "name": "http.h",
          "type": "blob",
          "size": 1.7431640625,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004-2005 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_HTTP_H\n#define CMUS_HTTP_H\n\n#include \"keyval.h\"\n\n#include <stddef.h> /* size_t */\n\n/*\n * 1xx indicates an informational message only\n * 2xx indicates success of some kind\n * 3xx redirects the client to another URL\n * 4xx indicates an error on the client's part\n * 5xx indicates an error on the server's part\n */\n\nstruct http_uri {\n\tchar *uri;\n\tchar *user;\n\tchar *pass;\n\tchar *host;\n\tchar *path;\n\tint port;\n};\n\nstruct http_get {\n\tstruct http_uri uri;\n\tstruct http_uri *proxy;\n\tint fd;\n\tstruct keyval *headers;\n\tchar *reason;\n\tint code;\n};\n\nint http_parse_uri(const char *uri, struct http_uri *u);\n\n/* frees contents of @u, not @u itself */\nvoid http_free_uri(struct http_uri *u);\n\nint http_open(struct http_get *hg, int timeout_ms);\n\n/*\n * returns:  0 success\n *          -1 check errno\n *          -2 parse error\n */\nint http_get(struct http_get *hg, struct keyval *headers, int timeout_ms);\nvoid http_get_free(struct http_get *hg);\n\nchar *http_read_body(int fd, size_t *size, int timeout_ms);\nchar *base64_encode(const char *str);\n\n#endif\n"
        },
        {
          "name": "id3.c",
          "type": "blob",
          "size": 25.078125,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2005 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"id3.h\"\n#include \"xmalloc.h\"\n#include \"convert.h\"\n#include \"uchar.h\"\n#include \"options.h\"\n#include \"debug.h\"\n#include \"utils.h\"\n#include \"file.h\"\n\n#include <unistd.h>\n#include <stdint.h>\n#include <errno.h>\n#include <stdio.h>\n#include <string.h>\n#include <strings.h>\n#include <limits.h>\n\nenum {\n\tID3_ENCODING_ISO_8859_1 = 0x00,\n\tID3_ENCODING_UTF_16     = 0x01,\n\tID3_ENCODING_UTF_16_BE  = 0x02,\n\tID3_ENCODING_UTF_8      = 0x03,\n\n\tID3_ENCODING_MAX        = 0x03\n};\n\n/*\n * position:\n *\n *    0 \"ID3\"\n *  -10 \"3DI\"\n * -128 \"TAG\"\n * -138 \"3DI\"\n *\n * if v2 is at beginning _and_ at end then there must be a seek tag at beginning\n */\n\nstruct v2_header {\n\tunsigned char ver_major;\n\tunsigned char ver_minor;\n\tunsigned char flags;\n\tuint32_t size;\n};\n\nstruct v2_extended_header {\n\tuint32_t size;\n};\n\nstruct v2_frame_header {\n\tchar id[4];\n\tuint32_t size;\n\tuint16_t flags;\n};\n\n#define V2_HEADER_UNSYNC\t(1 << 7)\n#define V2_HEADER_EXTENDED\t(1 << 6)\n#define V2_HEADER_EXPERIMENTAL\t(1 << 5)\n#define V2_HEADER_FOOTER\t(1 << 4)\n\n#define V2_FRAME_COMPRESSED\t(1 << 3) /* great idea!!1 */\n#define V2_FRAME_ENCRYPTHED\t(1 << 2) /* wow, this is very neat! */\n#define V2_FRAME_UNSYNC\t\t(1 << 1)\n#define V2_FRAME_LEN_INDICATOR\t(1 << 0)\n\n#define NR_GENRES 148\n/* genres {{{ */\nstatic const char *genres[NR_GENRES] = {\n\t\"Blues\",\n\t\"Classic Rock\",\n\t\"Country\",\n\t\"Dance\",\n\t\"Disco\",\n\t\"Funk\",\n\t\"Grunge\",\n\t\"Hip-Hop\",\n\t\"Jazz\",\n\t\"Metal\",\n\t\"New Age\",\n\t\"Oldies\",\n\t\"Other\",\n\t\"Pop\",\n\t\"R&B\",\n\t\"Rap\",\n\t\"Reggae\",\n\t\"Rock\",\n\t\"Techno\",\n\t\"Industrial\",\n\t\"Alternative\",\n\t\"Ska\",\n\t\"Death Metal\",\n\t\"Pranks\",\n\t\"Soundtrack\",\n\t\"Euro-Techno\",\n\t\"Ambient\",\n\t\"Trip-Hop\",\n\t\"Vocal\",\n\t\"Jazz+Funk\",\n\t\"Fusion\",\n\t\"Trance\",\n\t\"Classical\",\n\t\"Instrumental\",\n\t\"Acid\",\n\t\"House\",\n\t\"Game\",\n\t\"Sound Clip\",\n\t\"Gospel\",\n\t\"Noise\",\n\t\"Alt\",\n\t\"Bass\",\n\t\"Soul\",\n\t\"Punk\",\n\t\"Space\",\n\t\"Meditative\",\n\t\"Instrumental Pop\",\n\t\"Instrumental Rock\",\n\t\"Ethnic\",\n\t\"Gothic\",\n\t\"Darkwave\",\n\t\"Techno-Industrial\",\n\t\"Electronic\",\n\t\"Pop-Folk\",\n\t\"Eurodance\",\n\t\"Dream\",\n\t\"Southern Rock\",\n\t\"Comedy\",\n\t\"Cult\",\n\t\"Gangsta Rap\",\n\t\"Top 40\",\n\t\"Christian Rap\",\n\t\"Pop/Funk\",\n\t\"Jungle\",\n\t\"Native American\",\n\t\"Cabaret\",\n\t\"New Wave\",\n\t\"Psychedelic\",\n\t\"Rave\",\n\t\"Showtunes\",\n\t\"Trailer\",\n\t\"Lo-Fi\",\n\t\"Tribal\",\n\t\"Acid Punk\",\n\t\"Acid Jazz\",\n\t\"Polka\",\n\t\"Retro\",\n\t\"Musical\",\n\t\"Rock & Roll\",\n\t\"Hard Rock\",\n\t\"Folk\",\n\t\"Folk/Rock\",\n\t\"National Folk\",\n\t\"Swing\",\n\t\"Fast-Fusion\",\n\t\"Bebob\",\n\t\"Latin\",\n\t\"Revival\",\n\t\"Celtic\",\n\t\"Bluegrass\",\n\t\"Avantgarde\",\n\t\"Gothic Rock\",\n\t\"Progressive Rock\",\n\t\"Psychedelic Rock\",\n\t\"Symphonic Rock\",\n\t\"Slow Rock\",\n\t\"Big Band\",\n\t\"Chorus\",\n\t\"Easy Listening\",\n\t\"Acoustic\",\n\t\"Humour\",\n\t\"Speech\",\n\t\"Chanson\",\n\t\"Opera\",\n\t\"Chamber Music\",\n\t\"Sonata\",\n\t\"Symphony\",\n\t\"Booty Bass\",\n\t\"Primus\",\n\t\"Porn Groove\",\n\t\"Satire\",\n\t\"Slow Jam\",\n\t\"Club\",\n\t\"Tango\",\n\t\"Samba\",\n\t\"Folklore\",\n\t\"Ballad\",\n\t\"Power Ballad\",\n\t\"Rhythmic Soul\",\n\t\"Freestyle\",\n\t\"Duet\",\n\t\"Punk Rock\",\n\t\"Drum Solo\",\n\t\"A Cappella\",\n\t\"Euro-House\",\n\t\"Dance Hall\",\n\t\"Goa\",\n\t\"Drum & Bass\",\n\t\"Club-House\",\n\t\"Hardcore\",\n\t\"Terror\",\n\t\"Indie\",\n\t\"BritPop\",\n\t\"Negerpunk\",\n\t\"Polsk Punk\",\n\t\"Beat\",\n\t\"Christian Gangsta Rap\",\n\t\"Heavy Metal\",\n\t\"Black Metal\",\n\t\"Crossover\",\n\t\"Contemporary Christian\",\n\t\"Christian Rock\",\n\t\"Merengue\",\n\t\"Salsa\",\n\t\"Thrash Metal\",\n\t\"Anime\",\n\t\"JPop\",\n\t\"Synthpop\"\n};\n/* }}} */\n\n#define id3_debug(...) d_print(__VA_ARGS__)\n\nconst char * const id3_key_names[NUM_ID3_KEYS] = {\n\t\"artist\",\n\t\"album\",\n\t\"title\",\n\t\"date\",\n\t\"originaldate\",\n\t\"genre\",\n\t\"discnumber\",\n\t\"tracknumber\",\n\t\"albumartist\",\n\t\"artistsort\",\n\t\"albumartistsort\",\n\t\"albumsort\",\n\t\"compilation\",\n\t\"replaygain_track_gain\",\n\t\"replaygain_track_peak\",\n\t\"replaygain_album_gain\",\n\t\"replaygain_album_peak\",\n\t\"composer\",\n\t\"conductor\",\n\t\"lyricist\",\n\t\"remixer\",\n\t\"label\",\n\t\"publisher\",\n\t\"subtitle\",\n\t\"comment\",\n\t\"musicbrainz_trackid\",\n\t\"media\",\n\t\"bpm\",\n};\n\nstatic int utf16_is_lsurrogate(uchar uch)\n{\n\treturn 0xdc00 <= uch && 0xdfff >= uch;\n}\n\nstatic int utf16_is_hsurrogate(uchar uch)\n{\n\treturn 0xd800 <= uch && 0xdbff >= uch;\n}\n\nstatic int utf16_is_bom(uchar uch)\n{\n\treturn uch == 0xfeff;\n}\n\nstatic int utf16_is_special(uchar uch)\n{\n\treturn utf16_is_hsurrogate(uch) || utf16_is_lsurrogate(uch) || utf16_is_bom(uch);\n}\n\nstatic char *utf16_to_utf8(const unsigned char *buf, size_t buf_size)\n{\n\tchar *out;\n\tsize_t i, idx;\n\tint little_endian = 0;\n\n\tif (buf_size < 2)\n\t\treturn NULL;\n\n\tif (buf[0] == 0xff && buf[1] == 0xfe)\n\t\tlittle_endian = 1;\n\n\tout = xnew(char, (buf_size / 2) * 4 + 1);\n\ti = idx = 0;\n\n\twhile (buf_size - i >= 2) {\n\t\tuchar u;\n\n\t\tif (little_endian)\n\t\t\tu = buf[i] + (buf[i + 1] << 8);\n\t\telse\n\t\t\tu = buf[i + 1] + (buf[i] << 8);\n\n\t\tif (u_is_unicode(u)) {\n\t\t\tif (!utf16_is_special(u))\n\t\t\t\tu_set_char(out, &idx, u);\n\t\t} else {\n\t\t\tfree(out);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (u == 0)\n\t\t\treturn out;\n\n\t\ti += 2;\n\t}\n\n\tu_set_char(out, &idx, 0);\n\treturn out;\n}\n\nstatic int is_v1(const char *buf)\n{\n\treturn buf[0] == 'T' && buf[1] == 'A' && buf[2] == 'G';\n}\n\nstatic int u32_unsync(const unsigned char *buf, uint32_t *up)\n{\n\tuint32_t b, u = 0;\n\tint i;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tb = buf[i];\n\t\tif (b >= 0x80)\n\t\t\treturn 0;\n\t\tu <<= 7;\n\t\tu |= b;\n\t}\n\t*up = u;\n\treturn 1;\n}\n\nstatic void get_u32(const unsigned char *buf, uint32_t *up)\n{\n\tuint32_t b, u = 0;\n\tint i;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tb = buf[i];\n\t\tu <<= 8;\n\t\tu |= b;\n\t}\n\t*up = u;\n}\n\nstatic void get_u24(const unsigned char *buf, uint32_t *up)\n{\n\tuint32_t b, u = 0;\n\tint i;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tb = buf[i];\n\t\tu <<= 8;\n\t\tu |= b;\n\t}\n\t*up = u;\n}\n\nstatic void get_i16(const unsigned char *buf, int16_t *ip)\n{\n\tuint16_t b, u = 0;\n\tint i;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tb = buf[i];\n\t\tu <<= 8;\n\t\tu |= b;\n\t}\n\t*ip = u;\n}\n\nstatic int v2_header_footer_parse(struct v2_header *header, const char *buf)\n{\n\tconst unsigned char *b = (const unsigned char *)buf;\n\n\theader->ver_major = b[3];\n\theader->ver_minor = b[4];\n\theader->flags = b[5];\n\tif (header->ver_major == 0xff || header->ver_minor == 0xff)\n\t\treturn 0;\n\treturn u32_unsync(b + 6, &header->size);\n}\n\nstatic int v2_header_parse(struct v2_header *header, const char *buf)\n{\n\tif (buf[0] != 'I' || buf[1] != 'D' || buf[2] != '3')\n\t\treturn 0;\n\treturn v2_header_footer_parse(header, buf);\n}\n\nstatic int v2_footer_parse(struct v2_header *header, const char *buf)\n{\n\tif (buf[0] != '3' || buf[1] != 'D' || buf[2] != 'I')\n\t\treturn 0;\n\treturn v2_header_footer_parse(header, buf);\n}\n\nstatic int v2_extended_header_parse(struct v2_extended_header *header, const char *buf)\n{\n\treturn u32_unsync((const unsigned char *)buf, &header->size);\n}\n\nstatic int is_frame_id_char(char ch)\n{\n\treturn (ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9');\n}\n\n/* XXXYYY\n *\n * X = [A-Z0-9]\n * Y = byte\n *\n * XXX is frame\n * YYY is frame size excluding this 6 byte header\n */\nstatic int v2_2_0_frame_header_parse(struct v2_frame_header *header, const char *buf)\n{\n\tint i;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tif (!is_frame_id_char(buf[i]))\n\t\t\treturn 0;\n\t\theader->id[i] = buf[i];\n\t}\n\theader->id[3] = 0;\n\tget_u24((const unsigned char *)(buf + 3), &header->size);\n\theader->flags = 0;\n\tif (header->size == 0)\n\t\treturn 0;\n\tid3_debug(\"%c%c%c %d\\n\", header->id[0], header->id[1], header->id[2], header->size);\n\treturn 1;\n}\n\n/* XXXXYYYYZZ\n *\n * X = [A-Z0-9]\n * Y = byte\n * Z = byte\n *\n * XXXX is frame\n * YYYY is frame size excluding this 10 byte header\n * ZZ   is flags\n */\nstatic int v2_3_0_frame_header_parse(struct v2_frame_header *header, const char *buf)\n{\n\tint i;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tif (!(is_frame_id_char(buf[i]) || (i == 3 && buf[i] == '\\0')))\n\t\t\treturn 0;\n\t\theader->id[i] = buf[i];\n\t}\n\tget_u32((const unsigned char *)(buf + 4), &header->size);\n\theader->flags = (buf[8] << 8) | buf[9];\n\tif (header->size == 0)\n\t\treturn 0;\n\tid3_debug(\"%c%c%c%c %d\\n\", header->id[0], header->id[1], header->id[2],\n\t\t\theader->id[3], header->size);\n\treturn 1;\n}\n\n/* same as 2.3 but header size is sync safe */\nstatic int v2_4_0_frame_header_parse(struct v2_frame_header *header, const char *buf)\n{\n\tint i;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tif (!(is_frame_id_char(buf[i]) || (i == 3 && buf[i] == '\\0')))\n\t\t\treturn 0;\n\t\theader->id[i] = buf[i];\n\t}\n\tif (!u32_unsync((const unsigned char *)(buf + 4), &header->size))\n\t\treturn 0;\n\theader->flags = (buf[8] << 8) | buf[9];\n\tif (header->size == 0)\n\t\treturn 0;\n\tid3_debug(\"%c%c%c%c %d\\n\", header->id[0], header->id[1], header->id[2],\n\t\t\theader->id[3], header->size);\n\treturn 1;\n}\n\nstatic char *parse_genre(const char *str)\n{\n\tint parenthesis = 0;\n\tlong int idx;\n\tchar *end;\n\n\tif (strncasecmp(str, \"(RX\", 3) == 0)\n\t\treturn xstrdup(\"Remix\");\n\n\tif (strncasecmp(str, \"(CR\", 3) == 0)\n\t\treturn xstrdup(\"Cover\");\n\n\tif (*str == '(') {\n\t\tparenthesis = 1;\n\t\tstr++;\n\t}\n\n\tidx = strtol(str, &end, 10);\n\tif (str != end) {\n\t\t/* Number parsed but there may be some crap after the number.\n\t\t * I don't care, ID3v2 by definition contains crap.\n\t\t */\n\t\tif (idx >= 0 && idx < NR_GENRES)\n\t\t\treturn xstrdup(genres[idx]);\n\t}\n\n\tif (parenthesis) {\n\t\tconst char *ptr = strchr(str, ')');\n\n\t\tif (ptr && ptr[1]) {\n\t\t\t/* genre name after random crap in parenthesis,\n\t\t\t * return the genre name */\n\t\t\treturn xstrdup(ptr + 1);\n\t\t}\n\t\tstr--;\n\t}\n\n\t/* random crap, just return it and wait for a bug report */\n\treturn xstrdup(str);\n}\n\n/* http://www.id3.org/id3v2.4.0-structure.txt */\nstatic struct {\n\tconst char name[8];\n\tenum id3_key key;\n} frame_tab[] = {\n\t/* 2.4.0 */\n\t{ \"TDRC\", ID3_DATE }, // recording date\n\t{ \"TDRL\", ID3_DATE }, // release date\n\t{ \"TDOR\", ID3_ORIGINALDATE }, // original release date\n\t{ \"TSOP\", ID3_ARTISTSORT },\n\t{ \"TSOA\", ID3_ALBUMSORT },\n\n\t/* >= 2.3.0 */\n\t{ \"TPE1\", ID3_ARTIST },\n\t{ \"TALB\", ID3_ALBUM },\n\t{ \"TIT2\", ID3_TITLE },\n\t{ \"TYER\", ID3_DATE },\n\t{ \"TCON\", ID3_GENRE },\n\t{ \"TPOS\", ID3_DISC },\n\t{ \"TRCK\", ID3_TRACK },\n\t{ \"TPE2\", ID3_ALBUMARTIST },\n\t{ \"TSO2\", ID3_ALBUMARTISTSORT },\n\t{ \"XSOP\", ID3_ARTISTSORT }, // obsolete\n\t{ \"XSOA\", ID3_ALBUMSORT }, // obsolete\n\t{ \"TCMP\", ID3_COMPILATION },\n\t{ \"TORY\", ID3_ORIGINALDATE },\n\t{ \"TCOM\", ID3_COMPOSER },\n\t{ \"TPE3\", ID3_CONDUCTOR },\n\t{ \"TEXT\", ID3_LYRICIST },\n\t{ \"TPE4\", ID3_REMIXER },\n\t{ \"TPUB\", ID3_PUBLISHER }, // TPUB can be both publisher or label\n\t{ \"TIT3\", ID3_SUBTITLE },\n\t{ \"TMED\", ID3_MEDIA },\n\t{ \"TBPM\", ID3_BPM},\n\n\t/* obsolete frames (2.2.0) */\n\t{ \"TP1\",  ID3_ARTIST },\n\t{ \"TP2\",  ID3_ALBUMARTIST },\n\t{ \"TAL\",  ID3_ALBUM },\n\t{ \"TT2\",  ID3_TITLE },\n\t{ \"TYE\",  ID3_DATE },\n\t{ \"TCO\",  ID3_GENRE },\n\t{ \"TPA\",  ID3_DISC },\n\t{ \"TRK\",  ID3_TRACK },\n\t{ \"TSP\",  ID3_ARTISTSORT },\n\t{ \"TS2\",  ID3_ALBUMARTISTSORT },\n\t{ \"TSA\",  ID3_ALBUMSORT },\n\t{ \"TCP\",  ID3_COMPILATION },\n\t{ \"TBP\",  ID3_BPM },\n};\n\nstatic int frame_tab_index(const char *id)\n{\n\tint i = 0;\n\n\twhile (i < N_ELEMENTS(frame_tab)) {\n\t\tif (!strncmp(id, frame_tab[i].name, 4))\n\t\t\treturn i;\n\t\ti++;\n\t}\n\treturn -1;\n}\n\nstatic int check_date_format(const char *buf)\n{\n\tint i, ch;\n\n\t/* year */\n\tfor (i = 0; i < 4; i++) {\n\t\tch = *buf++;\n\t\tif (ch < '0' || ch > '9')\n\t\t\treturn 0;\n\t}\n\tch = *buf++;\n\tif (!ch)\n\t\treturn 4;\n\tif (ch != '-')\n\t\treturn 0;\n\n\t/* month */\n\tfor (i = 0; i < 2; i++) {\n\t\tch = *buf++;\n\t\tif (ch < '0' || ch > '9')\n\t\t\treturn 0;\n\t}\n\tch = *buf++;\n\tif (!ch)\n\t\treturn 7;\n\tif (ch != '-')\n\t\treturn 0;\n\n\t/* day */\n\tfor (i = 0; i < 2; i++) {\n\t\tch = *buf++;\n\t\tif (ch < '0' || ch > '9')\n\t\t\treturn 0;\n\t}\n\tch = *buf;\n\tif (!ch || (ch >= '0' && ch <= '9'))\n\t\treturn 10;\n\treturn 0;\n}\n\nstatic void fix_date(char *buf)\n{\n\tconst char *ptr = buf;\n\tint ch, len = 0;\n\n\tdo {\n\t\tch = *ptr++;\n\t\tif (ch >= '0' && ch <= '9') {\n\t\t\tlen++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (len == 4) {\n\t\t\t// number which length is 4, must be year\n\t\t\tmemmove(buf, ptr - 5, 4);\n\t\t\tbuf[4] = 0;\n\t\t\treturn;\n\t\t}\n\t\tlen = 0;\n\t} while (ch);\n\t*buf = 0;\n}\n\nstatic char *decode_str(const char *buf, int len, int encoding)\n{\n\tchar *in, *out = NULL;\n\n\tswitch (encoding) {\n\tcase ID3_ENCODING_ISO_8859_1:\n\t\tin = xstrndup(buf, len);\n\t\tutf8_encode(in, id3_default_charset, &out);\n\t\tfree(in);\n\t\tbreak;\n\tcase ID3_ENCODING_UTF_8:\n\t\tin = xstrndup(buf, len);\n\t\tif (u_is_valid(in)) {\n\t\t\tout = in;\n\t\t} else {\n\t\t\tutf8_encode(in, id3_default_charset, &out);\n\t\t\tfree(in);\n\t\t}\n\t\tbreak;\n\tcase ID3_ENCODING_UTF_16:\n\tcase ID3_ENCODING_UTF_16_BE:\n\t\tout = utf16_to_utf8((const unsigned char *)buf, len);\n\t\tbreak;\n\t}\n\treturn out;\n}\n\nstatic void add_v2(struct id3tag *id3, enum id3_key key, char *value)\n{\n\tfree(id3->v2[key]);\n\tid3->v2[key] = value;\n\tid3->has_v2 = 1;\n}\n\nstatic void decode_normal(struct id3tag *id3, const char *buf, int len, int encoding, enum id3_key key)\n{\n\tchar *out = decode_str(buf, len, encoding);\n\n\tif (!out)\n\t\treturn;\n\n\tif (key == ID3_GENRE) {\n\t\tchar *tmp;\n\n\t\tid3_debug(\"genre before: '%s'\\n\", out);\n\t\ttmp = parse_genre(out);\n\t\tfree(out);\n\t\tout = tmp;\n\t} else if (key == ID3_DATE || key == ID3_ORIGINALDATE) {\n\t\tint date_len = check_date_format(out);\n\t\tid3_debug(\"date before: '%s'\\n\", out);\n\t\tif (date_len)\n\t\t\tout[date_len] = '\\0';\n\t\telse\n\t\t\tfix_date(out);\n\t\tif (!*out) {\n\t\t\tid3_debug(\"date parsing failed\\n\");\n\t\t\tfree(out);\n\t\t\treturn;\n\t\t}\n\t} else if (key == ID3_ALBUMARTIST) {\n\t\t/*\n\t\t * This must be TPE2 frame; ignore it if ID3_ALBUMARTIST is\n\t\t * already present\n\t\t */\n\t\tif (id3->v2[key]) {\n\t\t\tfree(out);\n\t\t\treturn;\n\t\t}\n\t} else if (key == ID3_PUBLISHER) {\n\t\t add_v2(id3, ID3_LABEL, strdup(out));\n\t}\n\n\tadd_v2(id3, key, out);\n}\n\nstatic size_t id3_skiplen(const char *buf, size_t len, int encoding)\n{\n\tif (encoding == ID3_ENCODING_ISO_8859_1 || encoding == ID3_ENCODING_UTF_8) {\n\t\treturn strlen(buf) + 1;\n\t} else {\n\t\tint i = 0;\n\t\twhile (i + 1 < len) {\n\t\t\tif (buf[i] == '\\0' && buf[i + 1] == '\\0')\n\t\t\t\treturn i + 2;\n\n\t\t\t/* Assume every character is exactly 2 bytes */\n\t\t\ti += 2;\n\t\t}\n\n\t\treturn len;\n\t}\n}\n\nstatic void decode_txxx(struct id3tag *id3, const char *buf, int len, int encoding)\n{\n\tconst char ql_prefix[] = \"QuodLibet::\";\n\tenum id3_key key = NUM_ID3_KEYS;\n\tint size;\n\tchar *out, *out_mem;\n\n\tout = decode_str(buf, len, encoding);\n\tif (!out)\n\t\treturn;\n\n\tid3_debug(\"TXXX, key = '%s'\\n\", out);\n\n\tout_mem = out;\n\n\t/* skip braindead QuodLibet TXXX frame prefix */\n\tif (!strncmp(out, ql_prefix, sizeof(ql_prefix) - 1))\n\t\tout += sizeof(ql_prefix) - 1;\n\n\tif (!strcasecmp(out, \"replaygain_track_gain\"))\n\t\tkey = ID3_RG_TRACK_GAIN;\n\telse if (!strcasecmp(out, \"replaygain_track_peak\"))\n\t\tkey = ID3_RG_TRACK_PEAK;\n\telse if (!strcasecmp(out, \"replaygain_album_gain\"))\n\t\tkey = ID3_RG_ALBUM_GAIN;\n\telse if (!strcasecmp(out, \"replaygain_album_peak\"))\n\t\tkey = ID3_RG_ALBUM_PEAK;\n\telse if (!strcasecmp(out, \"album artist\"))\n\t\tkey = ID3_ALBUMARTIST;\n\telse if (!strcasecmp(out, \"albumartist\"))\n\t\tkey = ID3_ALBUMARTIST;\n\telse if (!strcasecmp(out, \"albumartistsort\"))\n\t\tkey = ID3_ALBUMARTISTSORT;\n\telse if (!strcasecmp(out, \"albumsort\"))\n\t\tkey = ID3_ALBUMSORT;\n\telse if (!strcasecmp(out, \"compilation\"))\n\t\tkey = ID3_COMPILATION;\n\n\tsize = id3_skiplen(buf, len, encoding);\n\tfree(out_mem);\n\n\tif (key == NUM_ID3_KEYS)\n\t\treturn;\n\n\tbuf += size;\n\tlen -= size;\n\tif (len <= 0)\n\t\treturn;\n\n\tout = decode_str(buf, len, encoding);\n\tif (!out)\n\t\treturn;\n\n\tadd_v2(id3, key, out);\n}\n\nstatic void decode_comment(struct id3tag *id3, const char *buf, int len, int encoding)\n{\n\tint slen;\n\tchar *out;\n\tint valid_description;\n\n\tif (len <= 3)\n\t\treturn;\n\n\t/* skip language */\n\tbuf += 3;\n\tlen -= 3;\n\n\t/* \"Short content description\" part of COMM frame */\n\tout = decode_str(buf, len, encoding);\n\tif (!out)\n\t\treturn;\n\n\tvalid_description = strcmp(out, \"\") == 0 || strcmp(out, \"description\") == 0;\n\tfree(out);\n\n\tif (!valid_description)\n\t\treturn;\n\n\tslen = id3_skiplen(buf, len, encoding);\n\tif (slen >= len)\n\t\treturn;\n\n\tbuf += slen;\n\tlen -= slen;\n\n\tout = decode_str(buf, len, encoding);\n\tif (!out)\n\t\treturn;\n\n\tadd_v2(id3, ID3_COMMENT, out);\n}\n\n/*\n * From http://id3.org/id3v2.4.0-frames:\n *\n * The volume adjustment is encoded as a fixed point decibel value, 16 bit signed\n * integer representing (adjustment*512), giving +/- 64 dB with a precision of\n * 0.001953125 dB. E.g. +2 dB is stored as $04 00 and -2 dB is $FC 00. There may\n * be more than one \"RVA2\" frame in each tag, but only one with the same\n * identification string.\n *\n * \t<Header for 'Relative volume adjustment (2)', ID: \"RVA2\">\n * \tIdentification          <text string> $00\n *\n * The 'identification' string is used to identify the situation and/or device\n * where this adjustment should apply. The following is then repeated for every\n * channel\n *\n * \tType of channel         $xx\n * \tVolume adjustment       $xx xx\n * \tBits representing peak  $xx\n * \tPeak volume             $xx (xx ...)\n *\n * Type of channel:\t$00 Other\n * \t\t\t$01 Master volume\n * \t\t\t$02 Front right\n * \t\t\t$03 Front left\n * \t\t\t$04 Back right\n * \t\t\t$05 Back left\n * \t\t\t$06 Front centre\n * \t\t\t$07 Back centre\n * \t\t\t$08 Subwoofer\n *\n * Bits representing peak can be any number between 0 and 255. 0 means that there\n * is no peak volume field. The peak volume field is always padded to whole\n * bytes, setting the most significant bits to zero.\n */\nstatic void decode_rva2(struct id3tag *id3, const char *buf, int len)\n{\n\tconst int rva2_min_len\t= 6 + 1 + 2 + 1;\n\n\tint audiophile_rg\t= 0;\n\tint channel\t\t= 0;\n\tint16_t volume_adj\t= 0;\n\tint peak_bits\t\t= 0;\n\tint peak_bytes\t\t= 0;\n\tint peak_shift\t\t= 0;\n\tuint32_t peak\t\t= 0;\n\n\tchar *gain_str\t\t= NULL;\n\tchar *peak_str\t\t= NULL;\n\n\tint i;\n\n\tif (len < rva2_min_len) {\n\t\tid3_debug(\"frame length %d too small\\n\", len);\n\t\treturn;\n\t}\n\n\tif (!strcasecmp(buf, \"album\")) {\n\t\taudiophile_rg = 1;\n\t} else if (strcasecmp(buf, \"track\")) {\n\t\tid3_debug(\"unsupported identifier: %s\\n\", buf);\n\t\treturn;\n\t}\n\n\tbuf += 6;\n\n\tchannel = *buf++;\n\tif (channel != 0x1) {\n\t\tid3_debug(\"unsupported channel: %d\\n\", channel);\n\t\treturn;\n\t}\n\n\tget_i16((unsigned char *)buf, &volume_adj);\n\tbuf += 2;\n\n\tpeak_bits = *buf++;\n\n\tif (peak_bits == 0)\n\t\tid3_debug(\"no peak data\\n\");\n\n\t/*\n\t * This crazy code comes from Mutagen\n\t */\n\tpeak_bytes = min_i(4, (peak_bits + 7) >> 3);\n\tpeak_shift = ((8 - (peak_bits & 7)) & 7) + (4 - peak_bytes) * 8;\n\n\tif (len < rva2_min_len + peak_bytes) {\n\t\tid3_debug(\"peak data %d does not fit frame with length %d\\n\", peak_bytes, len);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < peak_bytes; ++i) {\n\t\tpeak <<= 8;\n\t\tpeak |= (unsigned char)*buf++;\n\t}\n\n\tgain_str = xnew(char, 32);\n\tsnprintf(gain_str, 32, \"%lf dB\", volume_adj / 512.0);\n\n\tadd_v2(id3, audiophile_rg ? ID3_RG_ALBUM_GAIN : ID3_RG_TRACK_GAIN, gain_str);\n\n\tif (peak_bytes) {\n\t\tpeak_str = xnew(char, 32);\n\t\tsnprintf(peak_str, 32, \"%lf\", ((double)peak * (1 << peak_shift)) / INT_MAX);\n\n\t\tadd_v2(id3, audiophile_rg ? ID3_RG_ALBUM_PEAK : ID3_RG_TRACK_PEAK, peak_str);\n\t}\n\n\tid3_debug(\"gain %s, peak %s\\n\", gain_str, peak_str ? peak_str : \"none\");\n}\n\nstatic void decode_ufid(struct id3tag *id3, const char *buf, int len)\n{\n\tchar *ufid;\n\tint ufid_len = len - 22 - 1;\n\n\tif (ufid_len < 0 || strcmp(buf, \"http://musicbrainz.org\") != 0)\n\t\treturn;\n\n\tufid = xnew(char, ufid_len + 1);\n\tmemcpy(ufid, buf + len - ufid_len, ufid_len);\n\tufid[ufid_len] = '\\0';\n\n\tid3_debug(\"%s: %s\\n\", buf, ufid);\n\tadd_v2(id3, ID3_MUSICBRAINZ_TRACKID, ufid);\n}\n\n\nstatic void v2_add_frame(struct id3tag *id3, struct v2_frame_header *fh, const char *buf)\n{\n\tint encoding;\n\tint len;\n\tint idx;\n\n\tif (!strncmp(fh->id, \"RVA2\", 4)) {\n\t\tdecode_rva2(id3, buf, fh->size);\n\t\treturn;\n\t} else if (!strncmp(fh->id, \"UFID\", 4)) {\n\t\tdecode_ufid(id3, buf, fh->size);\n\t\treturn;\n\t}\n\n\tencoding = *buf++;\n\tlen = fh->size - 1;\n\n\tif (encoding > ID3_ENCODING_MAX)\n\t\treturn;\n\n\tidx = frame_tab_index(fh->id);\n\tif (idx >= 0) {\n\t\tdecode_normal(id3, buf, len, encoding, frame_tab[idx].key);\n\t} else if (!strncmp(fh->id, \"TXXX\", 4)) {\n\t\tdecode_txxx(id3, buf, len, encoding);\n\t} else if (!strncmp(fh->id, \"COMM\", 4)) {\n\t\tdecode_comment(id3, buf, len, encoding);\n\t} else if (!strncmp(fh->id, \"COM\", 3)) {\n\t\tdecode_comment(id3, buf, len, encoding);\n\t}\n}\n\nstatic void unsync(unsigned char *buf, int *lenp)\n{\n\tint len = *lenp;\n\tint s, d;\n\n\ts = d = 0;\n\twhile (s < len - 1) {\n\t\tif (buf[s] == 0xff && buf[s + 1] == 0x00) {\n\t\t\t/* 0xff 0x00 -> 0xff */\n\t\t\tbuf[d++] = 0xff;\n\t\t\ts += 2;\n\n\t\t\tif (s < len - 2 && buf[s] == 0x00) {\n\t\t\t\t/* 0xff 0x00 0x00 -> 0xff 0x00 */\n\t\t\t\tbuf[d++] = 0x00;\n\t\t\t\ts++;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tbuf[d++] = buf[s++];\n\t}\n\tif (s < len)\n\t\tbuf[d++] = buf[s++];\n\n\td_print(\"de-synchronization removed %d bytes\\n\", s - d);\n\t*lenp = d;\n}\n\nstatic int v2_read(struct id3tag *id3, int fd, const struct v2_header *header)\n{\n\tchar *buf;\n\tint rc, buf_size;\n\tint frame_start, i;\n\tint frame_header_size;\n\n\tbuf_size = header->size;\n\tbuf = xnew(char, buf_size);\n\trc = read_all(fd, buf, buf_size);\n\tif (rc == -1) {\n\t\tfree(buf);\n\t\treturn rc;\n\t}\n\n\tframe_start = 0;\n\tif (header->flags & V2_HEADER_EXTENDED) {\n\t\tstruct v2_extended_header ext;\n\n\t\tif (!v2_extended_header_parse(&ext, buf) || ext.size > buf_size) {\n\t\t\tid3_debug(\"extended header corrupted\\n\");\n\t\t\tfree(buf);\n\t\t\treturn -2;\n\t\t}\n\t\tframe_start = ext.size;\n\t\t/* should check if update flag is set */\n\t}\n\n\tframe_header_size = 10;\n\tif (header->ver_major == 2)\n\t\tframe_header_size = 6;\n\n\ti = frame_start;\n\twhile (i < buf_size - frame_header_size) {\n\t\tstruct v2_frame_header fh;\n\t\tint len_unsync;\n\n\t\tif (header->ver_major == 2) {\n\t\t\tif (!v2_2_0_frame_header_parse(&fh, buf + i))\n\t\t\t\tbreak;\n\t\t} else if (header->ver_major == 3) {\n\t\t\tif (!v2_3_0_frame_header_parse(&fh, buf + i))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t/* assume v2.4 */\n\t\t\tif (!v2_4_0_frame_header_parse(&fh, buf + i))\n\t\t\t\tbreak;\n\t\t}\n\n\t\ti += frame_header_size;\n\n\t\tif (fh.size > buf_size - i) {\n\t\t\tid3_debug(\"frame too big\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (fh.flags & V2_FRAME_LEN_INDICATOR) {\n\t\t\t/*\n\t\t\t * Ignore the frame length 4-byte field\n\t\t\t */\n\t\t\ti\t+= 4;\n\t\t\tfh.size\t-= 4;\n\t\t}\n\n\t\tlen_unsync = fh.size;\n\n\t\tif ((fh.flags & V2_FRAME_UNSYNC) || (header->flags & V2_HEADER_UNSYNC))\n\t\t\tunsync((unsigned char *)(buf + i), (int *)&fh.size);\n\n\t\tv2_add_frame(id3, &fh, buf + i);\n\n\t\ti += len_unsync;\n\t}\n\n\tfree(buf);\n\treturn 0;\n}\n\nint id3_tag_size(const char *buf, int buf_size)\n{\n\tstruct v2_header header;\n\n\tif (buf_size < 10)\n\t\treturn 0;\n\tif (v2_header_parse(&header, buf)) {\n\t\tif (header.flags & V2_HEADER_FOOTER) {\n\t\t\t/* header + data + footer */\n\t\t\tid3_debug(\"v2.%d.%d with footer\\n\", header.ver_major, header.ver_minor);\n\t\t\treturn 10 + header.size + 10;\n\t\t}\n\t\t/* header */\n\t\tid3_debug(\"v2.%d.%d\\n\", header.ver_major, header.ver_minor);\n\t\treturn 10 + header.size;\n\t}\n\tif (buf_size >= 3 && is_v1(buf)) {\n\t\tid3_debug(\"v1\\n\");\n\t\treturn 128;\n\t}\n\treturn 0;\n}\n\nvoid id3_init(struct id3tag *id3)\n{\n\tconst struct id3tag t = { .has_v1 = 0, .has_v2 = 0 };\n\t*id3 = t;\n}\n\nvoid id3_free(struct id3tag *id3)\n{\n\tint i;\n\n\tfor (i = 0; i < NUM_ID3_KEYS; i++)\n\t\tfree(id3->v2[i]);\n}\n\nint id3_read_tags(struct id3tag *id3, int fd, unsigned int flags)\n{\n\toff_t off;\n\tint rc;\n\n\tif (flags & ID3_V2) {\n\t\tstruct v2_header header;\n\t\tchar buf[138];\n\n\t\trc = read_all(fd, buf, 10);\n\t\tif (rc == -1)\n\t\t\tgoto rc_error;\n\t\tif (v2_header_parse(&header, buf)) {\n\t\t\trc = v2_read(id3, fd, &header);\n\t\t\tif (rc)\n\t\t\t\tgoto rc_error;\n\t\t\t/* get v1 if needed */\n\t\t} else {\n\t\t\t/* get v2 from end and optionally v1 */\n\n\t\t\toff = lseek(fd, -138, SEEK_END);\n\t\t\tif (off == -1)\n\t\t\t\tgoto error;\n\t\t\trc = read_all(fd, buf, 138);\n\t\t\tif (rc == -1)\n\t\t\t\tgoto rc_error;\n\n\t\t\tif (is_v1(buf + 10)) {\n\t\t\t\tif (flags & ID3_V1) {\n\t\t\t\t\tmemcpy(id3->v1, buf + 10, 128);\n\t\t\t\t\tid3->has_v1 = 1;\n\t\t\t\t}\n\t\t\t\tif (v2_footer_parse(&header, buf)) {\n\t\t\t\t\t/* footer at end of file - 128 */\n\t\t\t\t\toff = lseek(fd, -((off_t) header.size + 138), SEEK_END);\n\t\t\t\t\tif (off == -1)\n\t\t\t\t\t\tgoto error;\n\t\t\t\t\trc = v2_read(id3, fd, &header);\n\t\t\t\t\tif (rc)\n\t\t\t\t\t\tgoto rc_error;\n\t\t\t\t}\n\t\t\t} else if (v2_footer_parse(&header, buf + 128)) {\n\t\t\t\t/* footer at end of file */\n\t\t\t\toff = lseek(fd, -((off_t) header.size + 10), SEEK_END);\n\t\t\t\tif (off == -1)\n\t\t\t\t\tgoto error;\n\t\t\t\trc = v2_read(id3, fd, &header);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto rc_error;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (flags & ID3_V1) {\n\t\toff = lseek(fd, -128, SEEK_END);\n\t\tif (off == -1)\n\t\t\tgoto error;\n\t\trc = read_all(fd, id3->v1, 128);\n\t\tif (rc == -1)\n\t\t\tgoto rc_error;\n\t\tid3->has_v1 = is_v1(id3->v1);\n\t}\n\treturn 0;\nerror:\n\trc = -1;\nrc_error:\n\treturn rc;\n}\n\nstatic char *v1_get_str(const char *buf, int len)\n{\n\tchar in[32];\n\tchar *out;\n\tint i;\n\n\tfor (i = len - 1; i >= 0; i--) {\n\t\tif (buf[i] != 0 && buf[i] != ' ')\n\t\t\tbreak;\n\t}\n\tif (i == -1)\n\t\treturn NULL;\n\tmemcpy(in, buf, i + 1);\n\tin[i + 1] = 0;\n\tif (u_is_valid(in))\n\t\treturn xstrdup(in);\n\tif (utf8_encode(in, id3_default_charset, &out))\n\t\treturn NULL;\n\treturn out;\n}\n\nchar *id3_get_comment(struct id3tag *id3, enum id3_key key)\n{\n\tif (id3->has_v2) {\n\t\tif (id3->v2[key])\n\t\t\treturn xstrdup(id3->v2[key]);\n\t}\n\tif (id3->has_v1) {\n\t\tswitch (key) {\n\t\tcase ID3_ARTIST:\n\t\t\treturn v1_get_str(id3->v1 + 33, 30);\n\t\tcase ID3_ALBUM:\n\t\t\treturn v1_get_str(id3->v1 + 63, 30);\n\t\tcase ID3_TITLE:\n\t\t\treturn v1_get_str(id3->v1 + 3, 30);\n\t\tcase ID3_DATE:\n\t\t\treturn v1_get_str(id3->v1 + 93, 4);\n\t\tcase ID3_GENRE:\n\t\t\t{\n\t\t\t\tunsigned char idx = id3->v1[127];\n\n\t\t\t\tif (idx >= NR_GENRES)\n\t\t\t\t\treturn NULL;\n\t\t\t\treturn xstrdup(genres[idx]);\n\t\t\t}\n\t\tcase ID3_TRACK:\n\t\t\t{\n\t\t\t\tchar *t;\n\n\t\t\t\tif (id3->v1[125] != 0)\n\t\t\t\t\treturn NULL;\n\t\t\t\tt = xnew(char, 4);\n\t\t\t\tsnprintf(t, 4, \"%d\", ((unsigned char *)id3->v1)[126]);\n\t\t\t\treturn t;\n\t\t\t}\n\t\tdefault:\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nchar const *id3_get_genre(uint16_t id)\n{\n\tif (id >= NR_GENRES)\n\t\treturn NULL;\n\treturn genres[id];\n}\n"
        },
        {
          "name": "id3.h",
          "type": "blob",
          "size": 1.7626953125,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2005 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_ID3_H\n#define CMUS_ID3_H\n\n#include <stdint.h>\n\n/* flags for id3_read_tags */\n#define ID3_V1\t(1 << 0)\n#define ID3_V2\t(1 << 1)\n\nenum id3_key {\n\tID3_ARTIST,\n\tID3_ALBUM,\n\tID3_TITLE,\n\tID3_DATE,\n\tID3_ORIGINALDATE,\n\tID3_GENRE,\n\tID3_DISC,\n\tID3_TRACK,\n\tID3_ALBUMARTIST,\n\tID3_ARTISTSORT,\n\tID3_ALBUMARTISTSORT,\n\tID3_ALBUMSORT,\n\tID3_COMPILATION,\n\tID3_RG_TRACK_GAIN,\n\tID3_RG_TRACK_PEAK,\n\tID3_RG_ALBUM_GAIN,\n\tID3_RG_ALBUM_PEAK,\n\tID3_COMPOSER,\n\tID3_CONDUCTOR,\n\tID3_LYRICIST,\n\tID3_REMIXER,\n\tID3_LABEL,\n\tID3_PUBLISHER,\n\tID3_SUBTITLE,\n\tID3_COMMENT,\n\tID3_MUSICBRAINZ_TRACKID,\n\tID3_MEDIA,\n\tID3_BPM,\n\n\tNUM_ID3_KEYS\n};\n\nstruct id3tag {\n\tchar v1[128];\n\tchar *v2[NUM_ID3_KEYS];\n\n\tunsigned int has_v1 : 1;\n\tunsigned int has_v2 : 1;\n};\n\nextern const char * const id3_key_names[NUM_ID3_KEYS];\n\nint id3_tag_size(const char *buf, int buf_size);\n\nvoid id3_init(struct id3tag *id3);\nvoid id3_free(struct id3tag *id3);\n\nint id3_read_tags(struct id3tag *id3, int fd, unsigned int flags);\nchar *id3_get_comment(struct id3tag *id3, enum id3_key key);\n\nchar const *id3_get_genre(uint16_t id);\n\n#endif\n"
        },
        {
          "name": "input.c",
          "type": "blob",
          "size": 22.91015625,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004-2005 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"convert.h\"\n#include \"input.h\"\n#include \"ip.h\"\n#include \"pcm.h\"\n#include \"http.h\"\n#include \"xmalloc.h\"\n#include \"file.h\"\n#include \"path.h\"\n#include \"utils.h\"\n#include \"cmus.h\"\n#include \"options.h\"\n#include \"list.h\"\n#include \"mergesort.h\"\n#include \"misc.h\"\n#include \"debug.h\"\n#include \"ui_curses.h\"\n#include \"locking.h\"\n#include \"xstrjoin.h\"\n\n#include <unistd.h>\n#include <stdbool.h>\n#include <string.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <dlfcn.h>\n#include <strings.h>\n\nstruct input_plugin {\n\tconst struct input_plugin_ops *ops;\n\tstruct input_plugin_data data;\n\tunsigned int open : 1;\n\tunsigned int eof : 1;\n\tint http_code;\n\tchar *http_reason;\n\n\t/* cached duration, -1 = unset */\n\tint duration;\n\t/* cached bitrate, -1 = unset */\n\tlong bitrate;\n\t/* cached codec, NULL = unset */\n\tchar *codec;\n\t/* cached codec_profile, NULL = unset */\n\tchar *codec_profile;\n\n\t/*\n\t * pcm is converted to 16-bit signed little-endian stereo\n\t * NOTE: no conversion is done if channels > 2 or bits > 16\n\t */\n\tvoid (*pcm_convert)(void *, const void *, int);\n\tvoid (*pcm_convert_in_place)(void *, int);\n\t/*\n\t * 4  if 8-bit mono\n\t * 2  if 8-bit stereo or 16-bit mono\n\t * 1  otherwise\n\t */\n\tint pcm_convert_scale;\n};\n\nstruct ip {\n\tstruct list_head node;\n\tchar *name;\n\tvoid *handle;\n\n\tint priority;\n\tconst char * const *extensions;\n\tconst char * const *mime_types;\n\tconst struct input_plugin_ops *ops;\n\tconst struct input_plugin_opt *options;\n};\n\nstatic const char *plugin_dir;\nstatic LIST_HEAD(ip_head);\n\n/* protects ip->priority and ip_head */\nstatic pthread_rwlock_t ip_lock = CMUS_RWLOCK_INITIALIZER;\n\n#define ip_rdlock() cmus_rwlock_rdlock(&ip_lock)\n#define ip_wrlock() cmus_rwlock_wrlock(&ip_lock)\n#define ip_unlock() cmus_rwlock_unlock(&ip_lock)\n\n/* timeouts (ms) */\nstatic int http_connection_timeout = 5e3;\nstatic int http_read_timeout = 5e3;\n\nstatic const char *pl_mime_types[] = {\n\t\"audio/m3u\",\n\t\"audio/x-scpls\",\n\t\"audio/x-mpegurl\"\n};\n\nstatic const struct input_plugin_ops *\nget_ops_by_extension_locked(const char *ext, struct list_head **headp)\n{\n\tstruct list_head *node = *headp;\n\n\tfor (node = node->next; node != &ip_head; node = node->next) {\n\t\tstruct ip *ip = list_entry(node, struct ip, node);\n\t\tconst char * const *exts = ip->extensions;\n\t\tint i;\n\n\t\tif (ip->priority <= 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; exts[i]; i++) {\n\t\t\tif (strcasecmp(ext, exts[i]) == 0 || strcmp(\"*\", exts[i]) == 0) {\n\t\t\t\t*headp = node;\n\t\t\t\treturn ip->ops;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic const struct input_plugin_ops *\nget_ops_by_extension(const char *ext, struct list_head **headp)\n{\n\tip_rdlock();\n\tconst struct input_plugin_ops *rv = get_ops_by_extension_locked(ext,\n\t\t\theadp);\n\tip_unlock();\n\treturn rv;\n}\n\nstatic const struct input_plugin_ops *\nget_ops_by_mime_type_locked(const char *mime_type)\n{\n\tstruct ip *ip;\n\n\tlist_for_each_entry(ip, &ip_head, node) {\n\t\tconst char * const *types = ip->mime_types;\n\t\tint i;\n\n\t\tif (ip->priority <= 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; types[i]; i++) {\n\t\t\tif (strcasecmp(mime_type, types[i]) == 0)\n\t\t\t\treturn ip->ops;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic const struct input_plugin_ops *\nget_ops_by_mime_type(const char *mime_type)\n{\n\tip_rdlock();\n\tconst struct input_plugin_ops *rv =\n\t\tget_ops_by_mime_type_locked(mime_type);\n\tip_unlock();\n\treturn rv;\n}\n\nstatic void keyvals_add_basic_auth(struct growing_keyvals *c,\n\t\t\t\t   const char *user,\n\t\t\t\t   const char *pass,\n\t\t\t\t   const char *header)\n{\n\tchar buf[256];\n\tchar *encoded;\n\n\tsnprintf(buf, sizeof(buf), \"%s:%s\", user, pass);\n\tencoded = base64_encode(buf);\n\tif (encoded == NULL) {\n\t\td_print(\"couldn't base64 encode '%s'\\n\", buf);\n\t} else {\n\t\tsnprintf(buf, sizeof(buf), \"Basic %s\", encoded);\n\t\tfree(encoded);\n\t\tkeyvals_add(c, header, xstrdup(buf));\n\t}\n}\n\nstatic int do_http_get(struct http_get *hg, const char *uri, int redirections)\n{\n\tGROWING_KEYVALS(h);\n\tint i, rc;\n\tconst char *val;\n\tchar *redirloc;\n\n\td_print(\"%s\\n\", uri);\n\n\thg->headers = NULL;\n\thg->reason = NULL;\n\thg->proxy = NULL;\n\thg->code = -1;\n\thg->fd = -1;\n\tif (http_parse_uri(uri, &hg->uri))\n\t\treturn -IP_ERROR_INVALID_URI;\n\n\tif (http_open(hg, http_connection_timeout))\n\t\treturn -IP_ERROR_ERRNO;\n\n\tkeyvals_add(&h, \"Host\", xstrdup(hg->uri.host));\n\tif (hg->proxy && hg->proxy->user && hg->proxy->pass)\n\t\tkeyvals_add_basic_auth(&h, hg->proxy->user, hg->proxy->pass, \"Proxy-Authorization\");\n\tkeyvals_add(&h, \"User-Agent\", xstrdup(\"cmus/\" VERSION));\n\tkeyvals_add(&h, \"Icy-MetaData\", xstrdup(\"1\"));\n\tif (hg->uri.user && hg->uri.pass)\n\t\tkeyvals_add_basic_auth(&h, hg->uri.user, hg->uri.pass, \"Authorization\");\n\tkeyvals_terminate(&h);\n\n\trc = http_get(hg, h.keyvals, http_read_timeout);\n\tkeyvals_free(h.keyvals);\n\tswitch (rc) {\n\tcase -1:\n\t\treturn -IP_ERROR_ERRNO;\n\tcase -2:\n\t\treturn -IP_ERROR_HTTP_RESPONSE;\n\t}\n\n\td_print(\"HTTP response: %d %s\\n\", hg->code, hg->reason);\n\tfor (i = 0; hg->headers[i].key != NULL; i++)\n\t\td_print(\"  %s: %s\\n\", hg->headers[i].key, hg->headers[i].val);\n\n\tswitch (hg->code) {\n\tcase 200: /* OK */\n\t\treturn 0;\n\t/*\n\t * 3xx Codes (Redirections)\n\t *     unhandled: 300 Multiple Choices\n\t */\n\tcase 301: /* Moved Permanently */\n\tcase 302: /* Found */\n\tcase 303: /* See Other */\n\tcase 307: /* Temporary Redirect */\n\t\tval = keyvals_get_val(hg->headers, \"location\");\n\t\tif (!val)\n\t\t\treturn -IP_ERROR_HTTP_RESPONSE;\n\n\t\tredirections++;\n\t\tif (redirections > 2)\n\t\t\treturn -IP_ERROR_HTTP_REDIRECT_LIMIT;\n\n\t\tredirloc = xstrdup(val);\n\t\thttp_get_free(hg);\n\t\tclose(hg->fd);\n\n\t\trc = do_http_get(hg, redirloc, redirections);\n\n\t\tfree(redirloc);\n\t\treturn rc;\n\tdefault:\n\t\treturn -IP_ERROR_HTTP_STATUS;\n\t}\n}\n\nstatic int setup_remote(struct input_plugin *ip, const struct keyval *headers, int sock)\n{\n\tconst char *val;\n\n\tval = keyvals_get_val(headers, \"Content-Type\");\n\tif (val) {\n\t\td_print(\"Content-Type: %s\\n\", val);\n\t\tip->ops = get_ops_by_mime_type(val);\n\t\tif (ip->ops == NULL) {\n\t\t\td_print(\"unsupported content type: %s\\n\", val);\n\t\t\tclose(sock);\n\t\t\treturn -IP_ERROR_FILE_FORMAT;\n\t\t}\n\t} else {\n\t\tconst char *type = \"audio/mpeg\";\n\n\t\td_print(\"assuming %s content type\\n\", type);\n\t\tip->ops = get_ops_by_mime_type(type);\n\t\tif (ip->ops == NULL) {\n\t\t\td_print(\"unsupported content type: %s\\n\", type);\n\t\t\tclose(sock);\n\t\t\treturn -IP_ERROR_FILE_FORMAT;\n\t\t}\n\t}\n\n\tip->data.fd = sock;\n\tip->data.metadata = xnew(char, 16 * 255 + 1);\n\n\tval = keyvals_get_val(headers, \"icy-metaint\");\n\tif (val) {\n\t\tlong int lint;\n\n\t\tif (str_to_int(val, &lint) == 0 && lint >= 0) {\n\t\t\tip->data.metaint = lint;\n\t\t\td_print(\"metaint: %d\\n\", ip->data.metaint);\n\t\t}\n\t}\n\n\tval = keyvals_get_val(headers, \"icy-name\");\n\tif (val)\n\t\tip->data.icy_name = to_utf8(val, icecast_default_charset);\n\n\tval = keyvals_get_val(headers, \"icy-genre\");\n\tif (val)\n\t\tip->data.icy_genre = to_utf8(val, icecast_default_charset);\n\n\tval = keyvals_get_val(headers, \"icy-url\");\n\tif (val)\n\t\tip->data.icy_url = to_utf8(val, icecast_default_charset);\n\n\treturn 0;\n}\n\nstruct read_playlist_data {\n\tstruct input_plugin *ip;\n\tint rc;\n\tint count;\n};\n\nstatic int handle_line(void *data, const char *uri)\n{\n\tstruct read_playlist_data *rpd = data;\n\tstruct http_get hg;\n\n\trpd->count++;\n\trpd->rc = do_http_get(&hg, uri, 0);\n\tif (rpd->rc) {\n\t\trpd->ip->http_code = hg.code;\n\t\trpd->ip->http_reason = hg.reason;\n\t\tif (hg.fd >= 0)\n\t\t\tclose(hg.fd);\n\n\t\thg.reason = NULL;\n\t\thttp_get_free(&hg);\n\t\treturn 0;\n\t}\n\n\trpd->rc = setup_remote(rpd->ip, hg.headers, hg.fd);\n\thttp_get_free(&hg);\n\treturn 1;\n}\n\nstatic int read_playlist(struct input_plugin *ip, int sock)\n{\n\tstruct read_playlist_data rpd = { ip, 0, 0 };\n\tchar *body;\n\tsize_t size;\n\n\tbody = http_read_body(sock, &size, http_read_timeout);\n\tclose(sock);\n\tif (!body)\n\t\treturn -IP_ERROR_ERRNO;\n\n\tcmus_playlist_for_each(body, size, 0, handle_line, &rpd);\n\tfree(body);\n\tif (!rpd.count) {\n\t\td_print(\"empty playlist\\n\");\n\t\trpd.rc = -IP_ERROR_HTTP_RESPONSE;\n\t}\n\treturn rpd.rc;\n}\n\nstatic int open_remote(struct input_plugin *ip)\n{\n\tstruct input_plugin_data *d = &ip->data;\n\tstruct http_get hg;\n\tconst char *val;\n\tint rc;\n\n\trc = do_http_get(&hg, d->filename, 0);\n\tif (rc) {\n\t\tip->http_code = hg.code;\n\t\tip->http_reason = hg.reason;\n\t\thg.reason = NULL;\n\t\thttp_get_free(&hg);\n\t\treturn rc;\n\t}\n\n\tval = keyvals_get_val(hg.headers, \"Content-Type\");\n\tif (val) {\n\t\tint i;\n\n\t\tfor (i = 0; i < N_ELEMENTS(pl_mime_types); i++) {\n\t\t\tif (!strcasecmp(val, pl_mime_types[i])) {\n\t\t\t\td_print(\"Content-Type: %s\\n\", val);\n\t\t\t\thttp_get_free(&hg);\n\t\t\t\treturn read_playlist(ip, hg.fd);\n\t\t\t}\n\t\t}\n\t}\n\n\trc = setup_remote(ip, hg.headers, hg.fd);\n\thttp_get_free(&hg);\n\treturn rc;\n}\n\nstatic void ip_init(struct input_plugin *ip, char *filename)\n{\n\tconst struct input_plugin t = {\n\t\t.http_code          = -1,\n\t\t.pcm_convert_scale  = -1,\n\t\t.duration           = -1,\n\t\t.bitrate            = -1,\n\t\t.data = {\n\t\t\t.fd         = -1,\n\t\t\t.filename   = filename,\n\t\t\t.remote     = is_http_url(filename),\n\t\t\t.channel_map = CHANNEL_MAP_INIT\n\t\t}\n\t};\n\t*ip = t;\n}\n\nstatic void ip_reset(struct input_plugin *ip, int close_fd)\n{\n\tint fd = ip->data.fd;\n\tfree(ip->data.metadata);\n\tip_init(ip, ip->data.filename);\n\tif (fd != -1) {\n\t\tif (close_fd)\n\t\t\tclose(fd);\n\t\telse {\n\t\t\tlseek(fd, 0, SEEK_SET);\n\t\t\tip->data.fd = fd;\n\t\t}\n\t}\n}\n\nstatic int open_file_locked(struct input_plugin *ip)\n{\n\tconst struct input_plugin_ops *ops;\n\tstruct list_head *head = &ip_head;\n\tconst char *ext;\n\tint rc = 0;\n\n\text = get_extension(ip->data.filename);\n\tif (!ext)\n\t\treturn -IP_ERROR_UNRECOGNIZED_FILE_TYPE;\n\n\tops = get_ops_by_extension(ext, &head);\n\tif (!ops)\n\t\treturn -IP_ERROR_UNRECOGNIZED_FILE_TYPE;\n\n\tip->data.fd = open(ip->data.filename, O_RDONLY);\n\tif (ip->data.fd == -1)\n\t\treturn -IP_ERROR_ERRNO;\n\n\twhile (1) {\n\t\tip->ops = ops;\n\t\trc = ip->ops->open(&ip->data);\n\t\tif (rc != -IP_ERROR_UNSUPPORTED_FILE_TYPE)\n\t\t\tbreak;\n\n\t\tops = get_ops_by_extension(ext, &head);\n\t\tif (!ops)\n\t\t\tbreak;\n\n\t\tip_reset(ip, 0);\n\t\td_print(\"fallback: try next plugin for `%s'\\n\", ip->data.filename);\n\t}\n\n\treturn rc;\n}\n\nstatic int open_file(struct input_plugin *ip)\n{\n\tip_rdlock();\n\tint rv = open_file_locked(ip);\n\tip_unlock();\n\treturn rv;\n}\n\nstatic int sort_ip(const struct list_head *a_, const struct list_head *b_)\n{\n\tconst struct ip *a = list_entry(a_, struct ip, node);\n\tconst struct ip *b = list_entry(b_, struct ip, node);\n\treturn b->priority - a->priority;\n}\n\nvoid ip_load_plugins(void)\n{\n\tDIR *dir;\n\tstruct dirent *d;\n\n\tplugin_dir = xstrjoin(cmus_lib_dir, \"/ip\");\n\tdir = opendir(plugin_dir);\n\tif (dir == NULL) {\n\t\terror_msg(\"couldn't open directory `%s': %s\", plugin_dir, strerror(errno));\n\t\treturn;\n\t}\n\n\tip_wrlock();\n\twhile ((d = (struct dirent *) readdir(dir)) != NULL) {\n\t\tchar filename[512];\n\t\tstruct ip *ip;\n\t\tvoid *so;\n\t\tchar *ext;\n\t\tconst int *priority_ptr;\n\t\tconst unsigned *abi_version_ptr;\n\t\tbool err = false;\n\n\t\tif (d->d_name[0] == '.')\n\t\t\tcontinue;\n\t\text = strrchr(d->d_name, '.');\n\t\tif (ext == NULL)\n\t\t\tcontinue;\n\t\tif (strcmp(ext, \".so\"))\n\t\t\tcontinue;\n\n\t\tsnprintf(filename, sizeof(filename), \"%s/%s\", plugin_dir, d->d_name);\n\n\t\tso = dlopen(filename, RTLD_NOW);\n\t\tif (so == NULL) {\n\t\t\td_print(\"%s: %s\\n\", filename, dlerror());\n\t\t\tcontinue;\n\t\t}\n\n\t\tip = xnew(struct ip, 1);\n\n\t\tabi_version_ptr = dlsym(so, \"ip_abi_version\");\n\t\tpriority_ptr = dlsym(so, \"ip_priority\");\n\t\tip->extensions = dlsym(so, \"ip_extensions\");\n\t\tip->mime_types = dlsym(so, \"ip_mime_types\");\n\t\tip->ops = dlsym(so, \"ip_ops\");\n\t\tip->options = dlsym(so, \"ip_options\");\n\t\tif (!priority_ptr || !ip->extensions || !ip->mime_types || !ip->ops || !ip->options) {\n\t\t\terror_msg(\"%s: missing symbol\", filename);\n\t\t\terr = true;\n\t\t}\n\t\tif (!abi_version_ptr || *abi_version_ptr != IP_ABI_VERSION) {\n\t\t\terror_msg(\"%s: incompatible plugin version\", filename);\n\t\t\terr = true;\n\t\t}\n\t\tif (err) {\n\t\t\tfree(ip);\n\t\t\tdlclose(so);\n\t\t\tcontinue;\n\t\t}\n\t\tip->priority = *priority_ptr;\n\n\t\tip->name = xstrndup(d->d_name, ext - d->d_name);\n\t\tip->handle = so;\n\n\t\tlist_add_tail(&ip->node, &ip_head);\n\t}\n\tlist_mergesort(&ip_head, sort_ip);\n\tclosedir(dir);\n\tip_unlock();\n}\n\nstruct input_plugin *ip_new(const char *filename)\n{\n\tstruct input_plugin *ip = xnew(struct input_plugin, 1);\n\n\tip_init(ip, xstrdup(filename));\n\treturn ip;\n}\n\nvoid ip_delete(struct input_plugin *ip)\n{\n\tif (ip->open)\n\t\tip_close(ip);\n\tfree(ip->data.filename);\n\tfree(ip);\n}\n\nint ip_open(struct input_plugin *ip)\n{\n\tint rc;\n\n\tBUG_ON(ip->open);\n\n\t/* set fd and ops, call ops->open */\n\tif (ip->data.remote) {\n\t\trc = open_remote(ip);\n\t\tif (rc == 0)\n\t\t\trc = ip->ops->open(&ip->data);\n\t} else {\n\t\tif (is_cdda_url(ip->data.filename)) {\n\t\t\tip->ops = get_ops_by_mime_type(\"x-content/audio-cdda\");\n\t\t\trc = ip->ops ? ip->ops->open(&ip->data) : 1;\n\t\t} else if (is_cue_url(ip->data.filename)) {\n\t\t\tip->ops = get_ops_by_mime_type(\"application/x-cue\");\n\t\t\trc = ip->ops ? ip->ops->open(&ip->data) : 1;\n\t\t} else\n\t\t\trc = open_file(ip);\n\t}\n\n\tif (rc) {\n\t\td_print(\"opening `%s' failed: %d %s\\n\", ip->data.filename, rc,\n\t\t\t\trc == -1 ? strerror(errno) : \"\");\n\t\tip_reset(ip, 1);\n\t\treturn rc;\n\t}\n\tip->open = 1;\n\treturn 0;\n}\n\nvoid ip_setup(struct input_plugin *ip)\n{\n\tunsigned int bits, is_signed, channels;\n\tsample_format_t sf = ip->data.sf;\n\n\tbits = sf_get_bits(sf);\n\tis_signed = sf_get_signed(sf);\n\tchannels = sf_get_channels(sf);\n\n\tip->pcm_convert_scale = 1;\n\tip->pcm_convert = NULL;\n\tip->pcm_convert_in_place = NULL;\n\n\tif (bits <= 16 && channels <= 2) {\n\t\tunsigned int mask = ((bits >> 2) & 4) | (is_signed << 1);\n\n\t\tip->pcm_convert = pcm_conv[mask | (channels - 1)];\n\t\tip->pcm_convert_in_place = pcm_conv_in_place[mask | sf_get_bigendian(sf)];\n\n\t\tip->pcm_convert_scale = (3 - channels) * (3 - bits / 8);\n\t}\n\n\td_print(\"pcm convert: scale=%d convert=%d convert_in_place=%d\\n\",\n\t\t\tip->pcm_convert_scale,\n\t\t\tip->pcm_convert != NULL,\n\t\t\tip->pcm_convert_in_place != NULL);\n}\n\nint ip_close(struct input_plugin *ip)\n{\n\tint rc;\n\n\trc = ip->ops->close(&ip->data);\n\tBUG_ON(ip->data.private);\n\tif (ip->data.fd != -1)\n\t\tclose(ip->data.fd);\n\tfree(ip->data.metadata);\n\tfree(ip->data.icy_name);\n\tfree(ip->data.icy_genre);\n\tfree(ip->data.icy_url);\n\tfree(ip->http_reason);\n\n\tip_init(ip, ip->data.filename);\n\treturn rc;\n}\n\nint ip_read(struct input_plugin *ip, char *buffer, int count)\n{\n\tstruct timeval tv;\n\tfd_set readfds;\n\t/* 4608 seems to be optimal for mp3s, 4096 for oggs */\n\tchar tmp[8 * 1024];\n\tchar *buf;\n\tint sample_size;\n\tint rc;\n\n\tBUG_ON(count <= 0);\n\n\tFD_ZERO(&readfds);\n\tFD_SET(ip->data.fd, &readfds);\n\t/* zero timeout -> return immediately */\n\ttv.tv_sec = 0;\n\ttv.tv_usec = 50e3;\n\trc = select(ip->data.fd + 1, &readfds, NULL, NULL, &tv);\n\tif (rc == -1) {\n\t\tif (errno == EINTR)\n\t\t\terrno = EAGAIN;\n\t\treturn -1;\n\t}\n\tif (rc == 0) {\n\t\terrno = EAGAIN;\n\t\treturn -1;\n\t}\n\n\tbuf = buffer;\n\tif (ip->pcm_convert_scale > 1) {\n\t\t/* use tmp buffer for 16-bit mono and 8-bit */\n\t\tbuf = tmp;\n\t\tcount /= ip->pcm_convert_scale;\n\t\tif (count > sizeof(tmp))\n\t\t\tcount = sizeof(tmp);\n\t}\n\n\trc = ip->ops->read(&ip->data, buf, count);\n\tif (rc == -1 && (errno == EAGAIN || errno == EINTR)) {\n\t\terrno = EAGAIN;\n\t\treturn -1;\n\t}\n\tif (rc <= 0) {\n\t\tip->eof = 1;\n\t\treturn rc;\n\t}\n\n\tBUG_ON(rc % sf_get_frame_size(ip->data.sf) != 0);\n\n\tsample_size = sf_get_sample_size(ip->data.sf);\n\tif (ip->pcm_convert_in_place != NULL)\n\t\tip->pcm_convert_in_place(buf, rc / sample_size);\n\tif (ip->pcm_convert != NULL)\n\t\tip->pcm_convert(buffer, tmp, rc / sample_size);\n\treturn rc * ip->pcm_convert_scale;\n}\n\nint ip_seek(struct input_plugin *ip, double offset)\n{\n\tint rc;\n\n\tif (ip->data.remote)\n\t\treturn -IP_ERROR_FUNCTION_NOT_SUPPORTED;\n\trc = ip->ops->seek(&ip->data, offset);\n\tif (rc == 0)\n\t\tip->eof = 0;\n\treturn rc;\n}\n\nint ip_read_comments(struct input_plugin *ip, struct keyval **comments)\n{\n\tstruct keyval *kv = NULL;\n\tint rc;\n\n\trc = ip->ops->read_comments(&ip->data, &kv);\n\n\tif (ip->data.remote) {\n\t\tGROWING_KEYVALS(c);\n\n\t\tif (kv) {\n\t\t\tkeyvals_init(&c, kv);\n\t\t\tkeyvals_free(kv);\n\t\t}\n\n\t\tif (ip->data.icy_name && !keyvals_get_val_growing(&c, \"title\"))\n\t\t\tkeyvals_add(&c, \"title\", xstrdup(ip->data.icy_name));\n\n\t\tif (ip->data.icy_genre && !keyvals_get_val_growing(&c, \"genre\"))\n\t\t\tkeyvals_add(&c, \"genre\", xstrdup(ip->data.icy_genre));\n\n\t\tif (ip->data.icy_url && !keyvals_get_val_growing(&c, \"comment\"))\n\t\t\tkeyvals_add(&c, \"comment\", xstrdup(ip->data.icy_url));\n\n\t\tkeyvals_terminate(&c);\n\n\t\tkv = c.keyvals;\n\t}\n\n\t*comments = kv;\n\n\treturn ip->data.remote ? 0 : rc;\n}\n\nint ip_duration(struct input_plugin *ip)\n{\n\tif (ip->data.remote)\n\t\treturn -1;\n\tif (ip->duration == -1)\n\t\tip->duration = ip->ops->duration(&ip->data);\n\tif (ip->duration < 0)\n\t\treturn -1;\n\treturn ip->duration;\n}\n\nint ip_bitrate(struct input_plugin *ip)\n{\n\tif (ip->data.remote)\n\t\treturn -1;\n\tif (ip->bitrate == -1)\n\t\tip->bitrate = ip->ops->bitrate(&ip->data);\n\tif (ip->bitrate < 0)\n\t\treturn -1;\n\treturn ip->bitrate;\n}\n\nint ip_current_bitrate(struct input_plugin *ip)\n{\n\treturn ip->ops->bitrate_current(&ip->data);\n}\n\nchar *ip_codec(struct input_plugin *ip)\n{\n\tif (ip->data.remote)\n\t\treturn NULL;\n\tif (!ip->codec)\n\t\tip->codec = ip->ops->codec(&ip->data);\n\treturn ip->codec;\n}\n\nchar *ip_codec_profile(struct input_plugin *ip)\n{\n\tif (ip->data.remote)\n\t\treturn NULL;\n\tif (!ip->codec_profile)\n\t\tip->codec_profile = ip->ops->codec_profile(&ip->data);\n\treturn ip->codec_profile;\n}\n\nsample_format_t ip_get_sf(struct input_plugin *ip)\n{\n\tBUG_ON(!ip->open);\n\treturn ip->data.sf;\n}\n\nvoid ip_get_channel_map(struct input_plugin *ip, channel_position_t *channel_map)\n{\n\tBUG_ON(!ip->open);\n\tchannel_map_copy(channel_map, ip->data.channel_map);\n}\n\nconst char *ip_get_filename(struct input_plugin *ip)\n{\n\treturn ip->data.filename;\n}\n\nconst char *ip_get_metadata(struct input_plugin *ip)\n{\n\tBUG_ON(!ip->open);\n\treturn ip->data.metadata;\n}\n\nint ip_is_remote(struct input_plugin *ip)\n{\n\treturn ip->data.remote;\n}\n\nint ip_metadata_changed(struct input_plugin *ip)\n{\n\tint ret = ip->data.metadata_changed;\n\n\tBUG_ON(!ip->open);\n\tip->data.metadata_changed = 0;\n\treturn ret;\n}\n\nint ip_eof(struct input_plugin *ip)\n{\n\tBUG_ON(!ip->open);\n\treturn ip->eof;\n}\n\nstatic void option_error(int rc)\n{\n\tchar *msg = ip_get_error_msg(NULL, rc, \"setting option\");\n\terror_msg(\"%s\", msg);\n\tfree(msg);\n}\n\nstatic void set_ip_option(void *data, const char *val)\n{\n\tconst struct input_plugin_opt *ipo = data;\n\tint rc;\n\n\trc = ipo->set(val);\n\tif (rc)\n\t\toption_error(rc);\n}\n\nstatic void get_ip_option(void *data, char *buf, size_t size)\n{\n\tconst struct input_plugin_opt *ipo = data;\n\tchar *val = NULL;\n\n\tipo->get(&val);\n\tif (val) {\n\t\tstrscpy(buf, val, size);\n\t\tfree(val);\n\t}\n}\n\nstatic void set_ip_priority(void *data, const char *val)\n{\n\t/* warn only once during the lifetime of the program. */\n\tstatic bool warned = false;\n\tlong tmp;\n\tstruct ip *ip = data;\n\n\tif (str_to_int(val, &tmp) == -1 || tmp < 0 || (long)(int)tmp != tmp) {\n\t\terror_msg(\"non-negative integer expected\");\n\t\treturn;\n\t}\n\tif (ui_initialized) {\n\t\tif (!warned) {\n\t\t\tstatic const char *msg =\n\t\t\t\t\"Metadata might become inconsistent \"\n\t\t\t\t\"after this change. Continue? [y/N]\";\n\t\t\tif (yes_no_query(\"%s\", msg) != UI_QUERY_ANSWER_YES) {\n\t\t\t\tinfo_msg(\"Aborted\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\twarned = true;\n\t\t}\n\t\tinfo_msg(\"Run \\\":update-cache -f\\\" to refresh the metadata.\");\n\t}\n\n\tip_wrlock();\n\tip->priority = (int)tmp;\n\tlist_mergesort(&ip_head, sort_ip);\n\tip_unlock();\n}\n\nstatic void get_ip_priority(void *data, char *val, size_t size)\n{\n\tconst struct ip *ip = data;\n\tip_rdlock();\n\tsnprintf(val, size, \"%d\", ip->priority);\n\tip_unlock();\n}\n\nvoid ip_add_options(void)\n{\n\tstruct ip *ip;\n\tconst struct input_plugin_opt *ipo;\n\tchar key[64];\n\n\tip_rdlock();\n\tlist_for_each_entry(ip, &ip_head, node) {\n\t\tfor (ipo = ip->options; ipo->name; ipo++) {\n\t\t\tsnprintf(key, sizeof(key), \"input.%s.%s\", ip->name,\n\t\t\t\t\tipo->name);\n\t\t\toption_add(xstrdup(key), ipo, get_ip_option,\n\t\t\t\t\tset_ip_option, NULL, 0);\n\t\t}\n\t\tsnprintf(key, sizeof(key), \"input.%s.priority\", ip->name);\n\t\toption_add(xstrdup(key), ip, get_ip_priority, set_ip_priority, NULL, 0);\n\t}\n\tip_unlock();\n}\n\nchar *ip_get_error_msg(struct input_plugin *ip, int rc, const char *arg)\n{\n\tchar buffer[1024];\n\n\tswitch (-rc) {\n\tcase IP_ERROR_ERRNO:\n\t\tsnprintf(buffer, sizeof(buffer), \"%s: %s\", arg, strerror(errno));\n\t\tbreak;\n\tcase IP_ERROR_UNRECOGNIZED_FILE_TYPE:\n\t\tsnprintf(buffer, sizeof(buffer),\n\t\t\t\t\"%s: unrecognized filename extension\", arg);\n\t\tbreak;\n\tcase IP_ERROR_UNSUPPORTED_FILE_TYPE:\n\t\tsnprintf(buffer, sizeof(buffer),\n\t\t\t\t\"%s: unsupported file format\", arg);\n\t\tbreak;\n\tcase IP_ERROR_FUNCTION_NOT_SUPPORTED:\n\t\tsnprintf(buffer, sizeof(buffer),\n\t\t\t\t\"%s: function not supported\", arg);\n\t\tbreak;\n\tcase IP_ERROR_FILE_FORMAT:\n\t\tsnprintf(buffer, sizeof(buffer),\n\t\t\t\t\"%s: file format not supported or corrupted file\",\n\t\t\t\targ);\n\t\tbreak;\n\tcase IP_ERROR_INVALID_URI:\n\t\tsnprintf(buffer, sizeof(buffer), \"%s: invalid URI\", arg);\n\t\tbreak;\n\tcase IP_ERROR_SAMPLE_FORMAT:\n\t\tsnprintf(buffer, sizeof(buffer),\n\t\t\t\t\"%s: input plugin doesn't support the sample format\",\n\t\t\t\targ);\n\t\tbreak;\n\tcase IP_ERROR_WRONG_DISC:\n\t\tsnprintf(buffer, sizeof(buffer), \"%s: wrong disc inserted, aborting!\", arg);\n\t\tbreak;\n\tcase IP_ERROR_NO_DISC:\n\t\tsnprintf(buffer, sizeof(buffer), \"%s: could not read disc\", arg);\n\t\tbreak;\n\tcase IP_ERROR_HTTP_RESPONSE:\n\t\tsnprintf(buffer, sizeof(buffer), \"%s: invalid HTTP response\", arg);\n\t\tbreak;\n\tcase IP_ERROR_HTTP_STATUS:\n\t\tsnprintf(buffer, sizeof(buffer), \"%s: %d %s\", arg, ip->http_code, ip->http_reason);\n\t\tfree(ip->http_reason);\n\t\tip->http_reason = NULL;\n\t\tip->http_code = -1;\n\t\tbreak;\n\tcase IP_ERROR_HTTP_REDIRECT_LIMIT:\n\t\tsnprintf(buffer, sizeof(buffer), \"%s: too many HTTP redirections\", arg);\n\t\tbreak;\n\tcase IP_ERROR_NOT_OPTION:\n\t\tsnprintf(buffer, sizeof(buffer),\n\t\t\t\t\"%s: no such option\", arg);\n\t\tbreak;\n\tcase IP_ERROR_INTERNAL:\n\t\tsnprintf(buffer, sizeof(buffer), \"%s: internal error\", arg);\n\t\tbreak;\n\tcase IP_ERROR_SUCCESS:\n\tdefault:\n\t\tsnprintf(buffer, sizeof(buffer),\n\t\t\t\t\"%s: this is not an error (%d), this is a bug\",\n\t\t\t\targ, rc);\n\t\tbreak;\n\t}\n\treturn xstrdup(buffer);\n}\n\nchar **ip_get_supported_extensions(void)\n{\n\tstruct ip *ip;\n\tchar **exts;\n\tint i, size;\n\tint count = 0;\n\n\tsize = 8;\n\texts = xnew(char *, size);\n\tip_rdlock();\n\tlist_for_each_entry(ip, &ip_head, node) {\n\t\tconst char * const *e = ip->extensions;\n\n\t\tfor (i = 0; e[i]; i++) {\n\t\t\tif (count == size - 1) {\n\t\t\t\tsize *= 2;\n\t\t\t\texts = xrenew(char *, exts, size);\n\t\t\t}\n\t\t\texts[count++] = xstrdup(e[i]);\n\t\t}\n\t}\n\tip_unlock();\n\texts[count] = NULL;\n\tqsort(exts, count, sizeof(char *), strptrcmp);\n\treturn exts;\n}\n\nvoid ip_dump_plugins(void)\n{\n\tstruct ip *ip;\n\tint i;\n\n\tprintf(\"Input Plugins: %s\\n\", plugin_dir);\n\tip_rdlock();\n\tlist_for_each_entry(ip, &ip_head, node) {\n\t\tprintf(\"  %s:\\n    Default Priority: %d\\n    File Types:\", ip->name, ip->priority);\n\t\tfor (i = 0; ip->extensions[i]; i++)\n\t\t\tprintf(\" %s\", ip->extensions[i]);\n\t\tprintf(\"\\n    MIME Types:\");\n\t\tfor (i = 0; ip->mime_types[i]; i++)\n\t\t\tprintf(\" %s\", ip->mime_types[i]);\n\t\tprintf(\"\\n\");\n\t}\n\tip_unlock();\n}\n"
        },
        {
          "name": "input.h",
          "type": "blob",
          "size": 2.400390625,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2005 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_INPUT_H\n#define CMUS_INPUT_H\n\n#include \"keyval.h\"\n#include \"sf.h\"\n#include \"channelmap.h\"\n\nstruct input_plugin;\n\nvoid ip_load_plugins(void);\n\n/*\n * allocates new struct input_plugin.\n * never fails. does not check if the file is really playable\n */\nstruct input_plugin *ip_new(const char *filename);\n\n/*\n * frees struct input_plugin closing it first if necessary\n */\nvoid ip_delete(struct input_plugin *ip);\n\n/*\n * errors: IP_ERROR_{ERRNO, FILE_FORMAT, SAMPLE_FORMAT}\n */\nint ip_open(struct input_plugin *ip);\n\nvoid ip_setup(struct input_plugin *ip);\n\n/*\n * errors: none?\n */\nint ip_close(struct input_plugin *ip);\n\n/*\n * errors: IP_ERROR_{ERRNO, FILE_FORMAT}\n */\nint ip_read(struct input_plugin *ip, char *buffer, int count);\n\n/*\n * errors: IP_ERROR_{FUNCTION_NOT_SUPPORTED}\n */\nint ip_seek(struct input_plugin *ip, double offset);\n\n/*\n * errors: IP_ERROR_{ERRNO}\n */\nint ip_read_comments(struct input_plugin *ip, struct keyval **comments);\n\nint ip_duration(struct input_plugin *ip);\nint ip_bitrate(struct input_plugin *ip);\nint ip_current_bitrate(struct input_plugin *ip);\nchar *ip_codec(struct input_plugin *ip);\nchar *ip_codec_profile(struct input_plugin *ip);\n\nsample_format_t ip_get_sf(struct input_plugin *ip);\nvoid ip_get_channel_map(struct input_plugin *ip, channel_position_t *channel_map);\nconst char *ip_get_filename(struct input_plugin *ip);\nconst char *ip_get_metadata(struct input_plugin *ip);\nint ip_is_remote(struct input_plugin *ip);\nint ip_metadata_changed(struct input_plugin *ip);\nint ip_eof(struct input_plugin *ip);\nvoid ip_add_options(void);\nchar *ip_get_error_msg(struct input_plugin *ip, int rc, const char *arg);\nchar **ip_get_supported_extensions(void);\nvoid ip_dump_plugins(void);\n\n#endif\n"
        },
        {
          "name": "ip.h",
          "type": "blob",
          "size": 3.099609375,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004-2005 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_IP_H\n#define CMUS_IP_H\n\n#include \"keyval.h\"\n#include \"sf.h\"\n#include \"channelmap.h\"\n\n#ifndef __GNUC__\n#include <fcntl.h>\n#include <unistd.h>\n#endif\n\n#define IP_ABI_VERSION 2\n\nenum {\n\t/* no error */\n\tIP_ERROR_SUCCESS,\n\t/* system error (error code in errno) */\n\tIP_ERROR_ERRNO,\n\t/* file type not recognized */\n\tIP_ERROR_UNRECOGNIZED_FILE_TYPE,\n\t/* file type recognized, but not supported */\n\tIP_ERROR_UNSUPPORTED_FILE_TYPE,\n\t/* function not supported (usually seek) */\n\tIP_ERROR_FUNCTION_NOT_SUPPORTED,\n\t/* input plugin detected corrupted file */\n\tIP_ERROR_FILE_FORMAT,\n\t/* malformed uri */\n\tIP_ERROR_INVALID_URI,\n\t/* sample format not supported */\n\tIP_ERROR_SAMPLE_FORMAT,\n\t/* wrong disc inserted */\n\tIP_ERROR_WRONG_DISC,\n\t/* could not read disc */\n\tIP_ERROR_NO_DISC,\n\t/* error parsing response line / headers */\n\tIP_ERROR_HTTP_RESPONSE,\n\t/* usually 404 */\n\tIP_ERROR_HTTP_STATUS,\n\t/* too many redirections */\n\tIP_ERROR_HTTP_REDIRECT_LIMIT,\n\t/* plugin does not have this option */\n\tIP_ERROR_NOT_OPTION,\n\t/*  */\n\tIP_ERROR_INTERNAL\n};\n\nstruct input_plugin_data {\n\t/* filled by ip-layer */\n\tchar *filename;\n\tint fd;\n\n\tunsigned int remote : 1;\n\tunsigned int metadata_changed : 1;\n\n\t/* shoutcast */\n\tint counter;\n\tint metaint;\n\tchar *metadata;\n\tchar *icy_name;\n\tchar *icy_genre;\n\tchar *icy_url;\n\n\t/* filled by plugin */\n\tsample_format_t sf;\n\tchannel_position_t channel_map[CHANNELS_MAX];\n\tvoid *private;\n};\n\nstruct input_plugin_ops {\n\tint (*open)(struct input_plugin_data *ip_data);\n\tint (*close)(struct input_plugin_data *ip_data);\n\tint (*read)(struct input_plugin_data *ip_data, char *buffer, int count);\n\tint (*seek)(struct input_plugin_data *ip_data, double offset);\n\tint (*read_comments)(struct input_plugin_data *ip_data,\n\t\t\tstruct keyval **comments);\n\tint (*duration)(struct input_plugin_data *ip_data);\n\tlong (*bitrate)(struct input_plugin_data *ip_data);\n\tlong (*bitrate_current)(struct input_plugin_data *ip_data);\n\tchar *(*codec)(struct input_plugin_data *ip_data);\n\tchar *(*codec_profile)(struct input_plugin_data *ip_data);\n};\n\nstruct input_plugin_opt {\n\tconst char *name;\n\tint (*set)(const char *val);\n\tint (*get)(char **val);\n};\n\n/* symbols exported by plugin */\nextern const struct input_plugin_ops ip_ops;\nextern const int ip_priority;\nextern const char * const ip_extensions[];\nextern const char * const ip_mime_types[];\nextern const struct input_plugin_opt ip_options[];\nextern const unsigned ip_abi_version;\n\n#endif\n"
        },
        {
          "name": "ip",
          "type": "tree",
          "content": null
        },
        {
          "name": "iter.h",
          "type": "blob",
          "size": 4.380859375,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2005 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_ITER_H\n#define CMUS_ITER_H\n\n#include <stddef.h> /* NULL */\n\nstruct iter {\n\t/* this usually points to the list head */\n\tvoid *data0;\n\n\t/* these point to the list item, for simple lists data2 is usually NULL */\n\tvoid *data1;\n\tvoid *data2;\n};\n\nstatic inline void iter_init(struct iter *iter)\n{\n\titer->data0 = NULL;\n\titer->data1 = NULL;\n\titer->data2 = NULL;\n}\n\nstatic inline void iter_head(struct iter *iter)\n{\n\titer->data1 = NULL;\n\titer->data2 = NULL;\n}\n\nstatic inline int iters_equal(struct iter *a, struct iter *b)\n{\n\treturn a->data0 == b->data0 &&\n\t\ta->data1 == b->data1 &&\n\t\ta->data2 == b->data2;\n}\n\nstatic inline int iter_is_head(struct iter *iter)\n{\n\treturn iter->data0 != NULL &&\n\t\titer->data1 == NULL &&\n\t\titer->data2 == NULL;\n}\n\nstatic inline int iter_is_null(struct iter *iter)\n{\n\treturn iter->data0 == NULL &&\n\t\titer->data1 == NULL &&\n\t\titer->data2 == NULL;\n}\n\nstatic inline int iter_is_empty(struct iter *iter)\n{\n\treturn iter->data0 == NULL || (iter->data1 == NULL && iter->data2 == NULL);\n}\n\n#define GENERIC_ITER_PREV(FUNC, TYPE, MEMBER)\t\t\t\t\\\nint FUNC(struct iter *iter)\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct list_head *head = iter->data0;\t\t\t\t\\\n\tTYPE *e = iter->data1;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (head == NULL)\t\t\t\t\t\t\\\n\t\treturn 0;\t\t\t\t\t\t\\\n\tif (e == NULL) {\t\t\t\t\t\t\\\n\t\t/* head, get last */\t\t\t\t\t\\\n\t\tif (head->prev == head) {\t\t\t\t\\\n\t\t\t/* empty, iter points to the head already */\t\\\n\t\t\treturn 0;\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t\titer->data1 = container_of(head->prev, TYPE, MEMBER);\t\\\n\t\treturn 1;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tif (e->MEMBER.prev == head) {\t\t\t\t\t\\\n\t\titer->data1 = NULL;\t\t\t\t\t\\\n\t\treturn 0;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\titer->data1 = container_of(e->MEMBER.prev, TYPE, MEMBER);\t\\\n\treturn 1;\t\t\t\t\t\t\t\\\n}\n\n#define GENERIC_ITER_NEXT(FUNC, TYPE, MEMBER)\t\t\t\t\\\nint FUNC(struct iter *iter)\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct list_head *head = iter->data0;\t\t\t\t\\\n\tTYPE *e = iter->data1;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (head == NULL)\t\t\t\t\t\t\\\n\t\treturn 0;\t\t\t\t\t\t\\\n\tif (e == NULL) {\t\t\t\t\t\t\\\n\t\t/* head, get first */\t\t\t\t\t\\\n\t\tif (head->next == head) {\t\t\t\t\\\n\t\t\t/* empty, iter points to the head already */\t\\\n\t\t\treturn 0;\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t\titer->data1 = container_of(head->next, TYPE, MEMBER);\t\\\n\t\treturn 1;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tif (e->MEMBER.next == head) {\t\t\t\t\t\\\n\t\titer->data1 = NULL;\t\t\t\t\t\\\n\t\treturn 0;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\titer->data1 = container_of(e->MEMBER.next, TYPE, MEMBER);\t\\\n\treturn 1;\t\t\t\t\t\t\t\\\n}\n\n#define GENERIC_TREE_ITER_PREV(FUNC, TYPE, MEMBER)\t\t\t\t\\\nint FUNC(struct iter *iter)\t\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\t\\\n\tstruct rb_root *root = iter->data0;\t\t\t\t\t\\\n\tTYPE *e = iter->data1;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\tif (root == NULL)\t\t\t\t\t\t\t\\\n\t\treturn 0;\t\t\t\t\t\t\t\\\n\tif (e == NULL) {\t\t\t\t\t\t\t\\\n\t\t/* head, get last */\t\t\t\t\t\t\\\n\t\tif (rb_root_empty(root)) {\t\t\t\t\t\\\n\t\t\t/* empty, iter points to the head already */\t\t\\\n\t\t\treturn 0;\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\\\n\t\titer->data1 = container_of(rb_last(root), TYPE, MEMBER);\t\\\n\t\treturn 1;\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\\\n\tif (rb_prev(&e->MEMBER) == NULL) {\t\t\t\t\t\\\n\t\titer->data1 = NULL;\t\t\t\t\t\t\\\n\t\treturn 0;\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\\\n\titer->data1 = container_of(rb_prev(&e->MEMBER), TYPE, MEMBER);\t\t\\\n\treturn 1;\t\t\t\t\t\t\t\t\\\n}\n\n#define GENERIC_TREE_ITER_NEXT(FUNC, TYPE, MEMBER)\t\t\t\t\\\nint FUNC(struct iter *iter)\t\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\t\\\n\tstruct rb_root *root = iter->data0;\t\t\t\t\t\\\n\tTYPE *e = iter->data1;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\tif (root == NULL)\t\t\t\t\t\t\t\\\n\t\treturn 0;\t\t\t\t\t\t\t\\\n\tif (e == NULL) {\t\t\t\t\t\t\t\\\n\t\t/* head, get first */\t\t\t\t\t\t\\\n\t\tif (rb_root_empty(root)) {\t\t\t\t\t\\\n\t\t\t/* empty, iter points to the head already */\t\t\\\n\t\t\treturn 0;\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\\\n\t\titer->data1 = container_of(rb_first(root), TYPE, MEMBER);\t\\\n\t\treturn 1;\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\\\n\tif (rb_next(&e->MEMBER) == NULL) {\t\t\t\t\t\\\n\t\titer->data1 = NULL;\t\t\t\t\t\t\\\n\t\treturn 0;\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\\\n\titer->data1 = container_of(rb_next(&e->MEMBER), TYPE, MEMBER);\t\t\\\n\treturn 1;\t\t\t\t\t\t\t\t\\\n}\n\n#endif\n"
        },
        {
          "name": "job.c",
          "type": "blob",
          "size": 12.6748046875,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2008 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"utils.h\"\n#include \"job.h\"\n#include \"worker.h\"\n#include \"cache.h\"\n#include \"xmalloc.h\"\n#include \"debug.h\"\n#include \"load_dir.h\"\n#include \"path.h\"\n#include \"editable.h\"\n#include \"pl.h\"\n#include \"play_queue.h\"\n#include \"lib.h\"\n#include \"utils.h\"\n#include \"file.h\"\n#include \"cache.h\"\n#include \"player.h\"\n#include \"discid.h\"\n#include \"xstrjoin.h\"\n#include \"ui_curses.h\"\n#include \"cue_utils.h\"\n#include \"pl_env.h\"\n\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <sys/mman.h>\n\nenum job_result_var {\n\tJOB_RES_ADD,\n\tJOB_RES_UPDATE,\n\tJOB_RES_UPDATE_CACHE,\n\tJOB_RES_PL_DELETE,\n};\n\nenum update_kind {\n\tUPDATE_NONE = 0,\n\tUPDATE_REMOVE = 1,\n\tUPDATE_MTIME_CHANGED = 2,\n};\n\nstruct job_result {\n\tstruct list_head node;\n\n\tenum job_result_var var;\n\tunion {\n\t\tstruct {\n\t\t\tadd_ti_cb add_cb;\n\t\t\tsize_t add_num;\n\t\t\tstruct track_info **add_ti;\n\t\t\tvoid *add_opaque;\n\t\t};\n\t\tstruct {\n\t\t\tsize_t update_num;\n\t\t\tstruct track_info **update_ti;\n\t\t\tenum update_kind *update_kind;\n\t\t};\n\t\tstruct {\n\t\t\tsize_t update_cache_num;\n\t\t\tstruct track_info **update_cache_ti;\n\t\t};\n\t\tstruct {\n\t\t\tvoid (*pl_delete_cb)(struct playlist *);\n\t\t\tstruct playlist *pl_delete_pl;\n\t\t};\n\t};\n};\n\nint job_fd;\nstatic int job_fd_priv;\n\nstatic LIST_HEAD(job_result_head);\nstatic pthread_mutex_t job_mutex = CMUS_MUTEX_INITIALIZER;\n\n#define TI_CAP 32\nstatic struct track_info **ti_buffer;\nstatic size_t ti_buffer_fill;\nstatic struct add_data *jd;\n\n#define job_lock() cmus_mutex_lock(&job_mutex)\n#define job_unlock() cmus_mutex_unlock(&job_mutex)\n\nvoid job_init(void)\n{\n\tinit_pipes(&job_fd, &job_fd_priv);\n\n\tworker_init();\n}\n\nvoid job_exit(void)\n{\n\tworker_remove_jobs_by_type(JOB_TYPE_ANY);\n\tworker_exit();\n\n\tclose(job_fd);\n\tclose(job_fd_priv);\n}\n\nstatic void job_push_result(struct job_result *res)\n{\n\tjob_lock();\n\tlist_add_tail(&res->node, &job_result_head);\n\tjob_unlock();\n\n\tnotify_via_pipe(job_fd_priv);\n}\n\nstatic struct job_result *job_pop_result(void)\n{\n\tstruct job_result *res = NULL;\n\n\tjob_lock();\n\tif (!list_empty(&job_result_head)) {\n\t\tstruct list_head *item = job_result_head.next;\n\t\tlist_del(item);\n\t\tres = container_of(item, struct job_result, node);\n\t}\n\tjob_unlock();\n\n\treturn res;\n}\n\nstatic void flush_ti_buffer(void)\n{\n\tstruct job_result *res = xnew(struct job_result, 1);\n\n\tres->var = JOB_RES_ADD;\n\tres->add_cb = jd->add;\n\tres->add_num = ti_buffer_fill;\n\tres->add_ti = ti_buffer;\n\tres->add_opaque = jd->opaque;\n\n\tjob_push_result(res);\n\n\tti_buffer_fill = 0;\n\tti_buffer = NULL;\n}\n\nstatic void add_ti(struct track_info *ti)\n{\n\tif (ti_buffer_fill == TI_CAP)\n\t\tflush_ti_buffer();\n\tif (!ti_buffer)\n\t\tti_buffer = xnew(struct track_info *, TI_CAP);\n\tti_buffer[ti_buffer_fill++] = ti;\n}\n\nstatic int add_file_cue(const char *filename);\n\nstatic void add_file(const char *filename, int force)\n{\n\tstruct track_info *ti;\n\n\tif (!is_cue_url(filename)) {\n\t\tif (force || lookup_cache_entry(filename, hash_str(filename)) == NULL) {\n\t\t\tint done = add_file_cue(filename);\n\t\t\tif (done)\n\t\t\t\treturn;\n\t\t}\n\t}\n\n\tcache_lock();\n\tti = cache_get_ti(filename, force);\n\tcache_unlock();\n\n\tif (ti)\n\t\tadd_ti(ti);\n}\n\nstatic int add_file_cue(const char *filename)\n{\n\tint n_tracks;\n\tchar *url;\n\tchar *cue_filename;\n\n\tcue_filename = associated_cue(filename);\n\tif (cue_filename == NULL)\n\t\treturn 0;\n\n\tn_tracks = cue_get_ntracks(cue_filename);\n\tif (n_tracks <= 0) {\n\t\tfree(cue_filename);\n\t\treturn 0;\n\t}\n\n\tfor (int i = 1; i <= n_tracks; ++i) {\n\t\turl = construct_cue_url(cue_filename, i);\n\t\tadd_file(url, 0);\n\t\tfree(url);\n\t}\n\n\tfree(cue_filename);\n\treturn 1;\n}\n\nstatic void add_url(const char *url)\n{\n\tadd_file(url, 0);\n}\n\nstatic void add_cdda(const char *url)\n{\n\tchar *disc_id = NULL;\n\tint start_track = 1, end_track = -1;\n\n\tparse_cdda_url(url, &disc_id, &start_track, &end_track);\n\n\tif (end_track != -1) {\n\t\tint i;\n\t\tfor (i = start_track; i <= end_track; i++) {\n\t\t\tchar *new_url = gen_cdda_url(disc_id, i, -1);\n\t\t\tadd_file(new_url, 0);\n\t\t\tfree(new_url);\n\t\t}\n\t} else\n\t\tadd_file(url, 0);\n\tfree(disc_id);\n}\n\nstatic int dir_entry_cmp(const void *ap, const void *bp)\n{\n\tstruct dir_entry *a = *(struct dir_entry **)ap;\n\tstruct dir_entry *b = *(struct dir_entry **)bp;\n\n\treturn strcmp(a->name, b->name);\n}\n\nstatic int dir_entry_cmp_reverse(const void *ap, const void *bp)\n{\n\tstruct dir_entry *a = *(struct dir_entry **)ap;\n\tstruct dir_entry *b = *(struct dir_entry **)bp;\n\n\treturn strcmp(b->name, a->name);\n}\n\nstatic int points_within_and_visible(const char *target, const char *root)\n{\n\tint tlen = strlen(target);\n\tint rlen = strlen(root);\n\n\tif (rlen > tlen)\n\t\treturn 0;\n\tif (strncmp(target, root, rlen))\n\t\treturn 0;\n\tif (target[rlen] != '/' && target[rlen] != '\\0')\n\t\treturn 0;\n\t/* assume the path is normalized */\n\tif (strstr(target + rlen, \"/.\"))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic void add_dir(const char *dirname, const char *root)\n{\n\tstruct directory dir;\n\tstruct dir_entry **ents;\n\tconst char *name;\n\tPTR_ARRAY(array);\n\tint i;\n\n\tif (dir_open(&dir, dirname)) {\n\t\td_print(\"error: opening %s: %s\\n\", dirname, strerror(errno));\n\t\treturn;\n\t}\n\twhile ((name = dir_read(&dir))) {\n\t\tstruct dir_entry *ent;\n\t\tint size;\n\n\t\tif (strcmp(name, \".nomusic\") == 0 || strcmp(name, \".nomedia\") == 0) {\n\t\t\tptr_array_clear(&array);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (name[0] == '.')\n\t\t\tcontinue;\n\n\t\tif (dir.is_link) {\n\t\t\tchar buf[1024];\n\t\t\tchar *target;\n\t\t\tint rc = readlink(dir.path, buf, sizeof(buf));\n\n\t\t\tif (rc < 0 || rc == sizeof(buf))\n\t\t\t\tcontinue;\n\t\t\tbuf[rc] = 0;\n\t\t\ttarget = path_absolute_cwd(buf, dirname);\n\t\t\tif (points_within_and_visible(target, root)) {\n\t\t\t\td_print(\"%s -> %s points within %s. ignoring\\n\",\n\t\t\t\t\t\tdir.path, target, root);\n\t\t\t\tfree(target);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfree(target);\n\t\t}\n\n\t\tsize = strlen(name) + 1;\n\t\tent = xmalloc(sizeof(struct dir_entry) + size);\n\t\tent->mode = dir.st.st_mode;\n\t\tmemcpy(ent->name, name, size);\n\t\tptr_array_add(&array, ent);\n\t}\n\tdir_close(&dir);\n\n\tif (jd->add == play_queue_prepend) {\n\t\tptr_array_sort(&array, dir_entry_cmp_reverse);\n\t} else {\n\t\tptr_array_sort(&array, dir_entry_cmp);\n\t}\n\tents = array.ptrs;\n\tfor (i = 0; i < array.count; i++) {\n\t\tif (!worker_cancelling()) {\n\t\t\t/* abuse dir.path because\n\t\t\t *  - it already contains dirname + '/'\n\t\t\t *  - it is guaranteed to be large enough\n\t\t\t */\n\t\t\tint len = strlen(ents[i]->name);\n\n\t\t\tmemcpy(dir.path + dir.len, ents[i]->name, len + 1);\n\t\t\tif (S_ISDIR(ents[i]->mode)) {\n\t\t\t\tadd_dir(dir.path, root);\n\t\t\t} else {\n\t\t\t\tadd_file(dir.path, 0);\n\t\t\t}\n\t\t}\n\t\tfree(ents[i]);\n\t}\n\tfree(ents);\n}\n\nstatic int handle_line(void *data, const char *line)\n{\n\tif (worker_cancelling())\n\t\treturn 1;\n\n\tif (is_http_url(line) || is_cue_url(line)) {\n\t\tadd_url(line);\n\t} else {\n\t\tchar *absolute = pl_env_var(line, NULL)\n\t\t\t? pl_env_expand(line)\n\t\t\t: path_absolute_cwd(line, data);\n\t\tadd_file(absolute, 0);\n\t\tfree(absolute);\n\t}\n\n\treturn 0;\n}\n\nstatic void add_pl(const char *filename)\n{\n\tchar *buf;\n\tssize_t size;\n\tint reverse;\n\n\tbuf = mmap_file(filename, &size);\n\tif (size == -1)\n\t\treturn;\n\n\tif (buf) {\n\t\tchar *cwd = xstrjoin(filename, \"/..\");\n\t\t/* beautiful hack */\n\t\treverse = jd->add == play_queue_prepend;\n\n\t\tcmus_playlist_for_each(buf, size, reverse, handle_line, cwd);\n\t\tfree(cwd);\n\t\tmunmap(buf, size);\n\t\tadd_ti(NULL); // marks end of load\n\t}\n}\n\nstatic void do_add_job(void *data)\n{\n\tjd = data;\n\tswitch (jd->type) {\n\tcase FILE_TYPE_URL:\n\t\tadd_url(jd->name);\n\t\tbreak;\n\tcase FILE_TYPE_CDDA:\n\t\tadd_cdda(jd->name);\n\t\tbreak;\n\tcase FILE_TYPE_PL:\n\t\tadd_pl(jd->name);\n\t\tbreak;\n\tcase FILE_TYPE_DIR:\n\t\tadd_dir(jd->name, jd->name);\n\t\tbreak;\n\tcase FILE_TYPE_FILE:\n\t\tadd_file(jd->name, jd->force);\n\t\tbreak;\n\tcase FILE_TYPE_INVALID:\n\t\tbreak;\n\t}\n\tif (ti_buffer)\n\t\tflush_ti_buffer();\n\tjd = NULL;\n}\n\nstatic void free_add_job(void *data)\n{\n\tstruct add_data *d = data;\n\tfree(d->name);\n\tfree(d);\n}\n\nstatic void job_handle_add_result(struct job_result *res)\n{\n\tfor (size_t i = 0; i < res->add_num; i++) {\n\t\tres->add_cb(res->add_ti[i], res->add_opaque);\n\t\tif (res->add_ti[i] != NULL)\n\t\t\ttrack_info_unref(res->add_ti[i]);\n\t}\n\n\tfree(res->add_ti);\n}\n\nvoid job_schedule_add(int type, struct add_data *data)\n{\n\tworker_add_job(type | JOB_TYPE_ADD, do_add_job, free_add_job, data);\n}\n\nstatic void do_update_job(void *data)\n{\n\tstruct update_data *d = data;\n\tint i;\n\tenum update_kind *kind = xnew(enum update_kind, d->used);\n\tstruct job_result *res;\n\n\tfor (i = 0; i < d->used; i++) {\n\t\tstruct track_info *ti = d->ti[i];\n\t\tstruct stat s;\n\t\tint rc;\n\n\t\trc = stat(ti->filename, &s);\n\t\tif (rc || d->force || ti->mtime != s.st_mtime || ti->duration == 0) {\n\t\t\tkind[i] = UPDATE_NONE;\n\t\t\tif (!is_cue_url(ti->filename) && !is_http_url(ti->filename) && rc)\n\t\t\t\tkind[i] |= UPDATE_REMOVE;\n\t\t\telse if (ti->mtime != s.st_mtime)\n\t\t\t\tkind[i] |= UPDATE_MTIME_CHANGED;\n\t\t} else {\n\t\t\ttrack_info_unref(ti);\n\t\t\td->ti[i] = NULL;\n\t\t}\n\t}\n\n\tres = xnew(struct job_result, 1);\n\n\tres->var = JOB_RES_UPDATE;\n\tres->update_num = d->used;\n\tres->update_ti = d->ti;\n\tres->update_kind = kind;\n\n\tjob_push_result(res);\n\n\td->ti = NULL;\n}\n\nstatic void free_update_job(void *data)\n{\n\tstruct update_data *d = data;\n\n\tif (d->ti) {\n\t\tfor (size_t i = 0; i < d->used; i++)\n\t\t\ttrack_info_unref(d->ti[i]);\n\t\tfree(d->ti);\n\t}\n\tfree(d);\n}\n\nstatic void job_handle_update_result(struct job_result *res)\n{\n\tfor (size_t i = 0; i < res->update_num; i++) {\n\t\tstruct track_info *ti = res->update_ti[i];\n\t\tint force;\n\n\t\tif (!ti)\n\t\t\tcontinue;\n\n\t\tlib_remove(ti);\n\n\t\tcache_lock();\n\t\tcache_remove_ti(ti);\n\t\tcache_unlock();\n\n\t\tif (res->update_kind[i] & UPDATE_REMOVE) {\n\t\t\td_print(\"removing dead file %s\\n\", ti->filename);\n\t\t} else {\n\t\t\tif (res->update_kind[i] & UPDATE_MTIME_CHANGED)\n\t\t\t\td_print(\"mtime changed: %s\\n\", ti->filename);\n\t\t\tforce = ti->duration == 0;\n\t\t\tcmus_add(lib_add_track, ti->filename, FILE_TYPE_FILE,\n\t\t\t\t\tJOB_TYPE_LIB, force, NULL);\n\t\t}\n\n\t\ttrack_info_unref(ti);\n\t}\n\n\tfree(res->update_kind);\n\tfree(res->update_ti);\n}\n\nvoid job_schedule_update(struct update_data *data)\n{\n\tworker_add_job(JOB_TYPE_LIB | JOB_TYPE_UPDATE, do_update_job,\n\t\t\tfree_update_job, data);\n}\n\nstatic void do_update_cache_job(void *data)\n{\n\tstruct update_cache_data *d = data;\n\tint count;\n\tstruct track_info **tis;\n\tstruct job_result *res;\n\n\tcache_lock();\n\ttis = cache_refresh(&count, d->force);\n\tcache_unlock();\n\n\tres = xnew(struct job_result, 1);\n\tres->var = JOB_RES_UPDATE_CACHE;\n\tres->update_cache_ti = tis;\n\tres->update_cache_num = count;\n\tjob_push_result(res);\n}\n\nstatic void free_update_cache_job(void *data)\n{\n\tfree(data);\n}\n\nstatic void job_handle_update_cache_result(struct job_result *res)\n{\n\tfor (size_t i = 0; i < res->update_cache_num; i++) {\n\t\tstruct track_info *new, *old = res->update_cache_ti[i];\n\n\t\tif (!old)\n\t\t\tcontinue;\n\n\t\tnew = old->next;\n\t\tif (lib_remove(old) && new)\n\t\t\tlib_add_track(new, NULL);\n\t\tpl_update_track(old, new);\n\t\teditable_update_track(&pq_editable, old, new);\n\t\tif (player_info.ti == old && new) {\n\t\t\ttrack_info_ref(new);\n\t\t\tplayer_file_changed(new);\n\t\t}\n\n\t\ttrack_info_unref(old);\n\t\tif (new)\n\t\t\ttrack_info_unref(new);\n\t}\n\tfree(res->update_cache_ti);\n}\n\nvoid job_schedule_update_cache(int type, struct update_cache_data *data)\n{\n\tworker_add_job(type | JOB_TYPE_UPDATE_CACHE, do_update_cache_job,\n\t\t\tfree_update_cache_job, data);\n}\n\nstatic void do_pl_delete_job(void *data)\n{\n\t/*\n\t * If PL jobs are canceled this function won't run. Hence we push the\n\t * result in the free function.\n\t */\n}\n\nstatic void free_pl_delete_job(void *data)\n{\n\tstruct pl_delete_data *pdd = data;\n\tstruct job_result *res;\n\n\tres = xnew(struct job_result, 1);\n\tres->var = JOB_RES_PL_DELETE;\n\tres->pl_delete_cb = pdd->cb;\n\tres->pl_delete_pl = pdd->pl;\n\tjob_push_result(res);\n\n\tfree(pdd);\n}\n\nstatic void job_handle_pl_delete_result(struct job_result *res)\n{\n\tres->pl_delete_cb(res->pl_delete_pl);\n}\n\nvoid job_schedule_pl_delete(struct pl_delete_data *data)\n{\n\tworker_add_job(JOB_TYPE_PL | JOB_TYPE_DELETE, do_pl_delete_job,\n\t\t\tfree_pl_delete_job, data);\n}\n\nstatic void job_handle_result(struct job_result *res)\n{\n\tswitch (res->var) {\n\tcase JOB_RES_ADD:\n\t\tjob_handle_add_result(res);\n\t\tbreak;\n\tcase JOB_RES_UPDATE:\n\t\tjob_handle_update_result(res);\n\t\tbreak;\n\tcase JOB_RES_UPDATE_CACHE:\n\t\tjob_handle_update_cache_result(res);\n\t\tbreak;\n\tcase JOB_RES_PL_DELETE:\n\t\tjob_handle_pl_delete_result(res);\n\t\tbreak;\n\t}\n\tfree(res);\n}\n\nvoid job_handle(void)\n{\n\tclear_pipe(job_fd, -1);\n\n\tstruct job_result *res;\n\twhile ((res = job_pop_result()))\n\t\tjob_handle_result(res);\n}\n"
        },
        {
          "name": "job.h",
          "type": "blob",
          "size": 1.67578125,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2008 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_JOB_H\n#define CMUS_JOB_H\n\n#include \"cmus.h\"\n\n#define JOB_TYPE_LIB   1 << 0\n#define JOB_TYPE_PL    1 << 1\n#define JOB_TYPE_QUEUE 1 << 2\n\n#define JOB_TYPE_ADD          1 << 16\n#define JOB_TYPE_UPDATE       1 << 17\n#define JOB_TYPE_UPDATE_CACHE 1 << 18\n#define JOB_TYPE_DELETE       1 << 19\n\nstruct add_data {\n\tenum file_type type;\n\tchar *name;\n\tadd_ti_cb add;\n\tvoid *opaque;\n\tunsigned int force : 1;\n};\n\nstruct update_data {\n\tsize_t size;\n\tsize_t used;\n\tstruct track_info **ti;\n\tunsigned int force : 1;\n};\n\nstruct update_cache_data {\n\tunsigned int force : 1;\n};\n\nstruct pl_delete_data {\n\tstruct playlist *pl;\n\tvoid (*cb)(struct playlist *);\n};\n\nextern int job_fd;\n\nvoid job_init(void);\nvoid job_exit(void);\nvoid job_schedule_add(int type, struct add_data *data);\nvoid job_schedule_update(struct update_data *data);\nvoid job_schedule_update_cache(int type, struct update_cache_data *data);\nvoid job_schedule_pl_delete(struct pl_delete_data *data);\nvoid job_handle(void);\n\n#endif\n"
        },
        {
          "name": "keys.c",
          "type": "blob",
          "size": 21.5283203125,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004-2006 Timo Hirvonen\n *\n * keys.[ch] by Frank Terbeck <ft@bewatermyfriend.org>\n * heavily modified by Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"keys.h\"\n#include \"help.h\"\n#include \"ui_curses.h\"\n#include \"command_mode.h\"\n#include \"xmalloc.h\"\n\n#include \"window.h\"\n#include \"options.h\"\n#include \"editable.h\"\n#include \"lib.h\"\n#include \"pl.h\"\n\nconst char * const key_context_names[NR_CTXS + 1] = {\n\t\"browser\",\n\t\"common\",\n\t\"filters\",\n\t\"library\",\n\t\"playlist\",\n\t\"queue\",\n\t\"settings\",\n\tNULL\n};\n\nstruct binding *key_bindings[NR_CTXS] = { NULL, };\n\nstatic const enum key_context view_to_context[] = {\n\tCTX_LIBRARY,\n\tCTX_LIBRARY,\n\tCTX_PLAYLIST,\n\tCTX_QUEUE,\n\tCTX_BROWSER,\n\tCTX_FILTERS,\n\tCTX_SETTINGS,\n};\n\n#define KEY_IS_CHAR -255\n\n#define KEY_M_TYPE_NONE \t(0<<3)\n#define KEY_M_TYPE_SEL\t\t(1<<3)\n#define KEY_M_TYPE_BAR\t\t(2<<3)\n#define KEY_M_TYPE_TIT\t\t(3<<3)\n#define KEY_M_TYPE_BAR_R\t(4<<3)\n\n#define KEY_MLB_CLICK\t\t\t0\n#define KEY_MRB_CLICK \t\t\t1\n#define KEY_MSCRL_UP\t \t\t2\n#define KEY_MSCRL_DOWN\t\t\t3\n#define KEY_MLB_CLICK_SEL\t\t(KEY_MLB_CLICK|KEY_M_TYPE_SEL)\n#define KEY_MRB_CLICK_SEL \t\t(KEY_MRB_CLICK|KEY_M_TYPE_SEL)\n#define KEY_MLB_CLICK_BAR\t\t(KEY_MLB_CLICK|KEY_M_TYPE_BAR)\n#define KEY_MRB_CLICK_BAR \t\t(KEY_MRB_CLICK|KEY_M_TYPE_BAR)\n#define KEY_MSCRL_UP_BAR\t\t(KEY_MSCRL_UP|KEY_M_TYPE_BAR)\n#define KEY_MSCRL_DOWN_BAR\t\t(KEY_MSCRL_DOWN|KEY_M_TYPE_BAR)\n#define KEY_MLB_CLICK_BAR_R\t\t(KEY_MLB_CLICK|KEY_M_TYPE_BAR_R)\n#define KEY_MRB_CLICK_BAR_R\t\t(KEY_MRB_CLICK|KEY_M_TYPE_BAR_R)\n#define KEY_MSCRL_UP_BAR_R\t\t(KEY_MSCRL_UP|KEY_M_TYPE_BAR_R)\n#define KEY_MSCRL_DOWN_BAR_R\t(KEY_MSCRL_DOWN|KEY_M_TYPE_BAR_R)\n#define KEY_MLB_CLICK_TIT\t\t(KEY_MLB_CLICK|KEY_M_TYPE_TIT)\n#define KEY_MRB_CLICK_TIT \t\t(KEY_MRB_CLICK|KEY_M_TYPE_TIT)\n#define KEY_MSCRL_UP_TIT\t\t(KEY_MSCRL_UP|KEY_M_TYPE_TIT)\n#define KEY_MSCRL_DOWN_TIT\t\t(KEY_MSCRL_DOWN|KEY_M_TYPE_TIT)\n\n/* key_table {{{\n *\n * key: KEY_IS_CHAR, not a key\n * ch:  0, not a char\n * key: KEY_MOUSE, neither key, nor char\n */\nconst struct key key_table[] = {\n\t{ \"!\",\t\t\tKEY_IS_CHAR,\t\t33\t},\n\t{ \"\\\"\",\t\t\tKEY_IS_CHAR,\t\t34\t},\n\t{ \"#\",\t\t\tKEY_IS_CHAR,\t\t35\t},\n\t{ \"$\",\t\t\tKEY_IS_CHAR,\t\t36\t},\n\t{ \"%\",\t\t\tKEY_IS_CHAR,\t\t37\t},\n\t{ \"&\",\t\t\tKEY_IS_CHAR,\t\t38\t},\n\t{ \"'\",\t\t\tKEY_IS_CHAR,\t\t39\t},\n\t{ \"(\",\t\t\tKEY_IS_CHAR,\t\t40\t},\n\t{ \")\",\t\t\tKEY_IS_CHAR,\t\t41\t},\n\t{ \"*\",\t\t\tKEY_IS_CHAR,\t\t42\t},\n\t{ \"+\",\t\t\tKEY_IS_CHAR,\t\t43\t},\n\t{ \",\",\t\t\tKEY_IS_CHAR,\t\t44\t},\n\t{ \"-\",\t\t\tKEY_IS_CHAR,\t\t45\t},\n\t{ \".\",\t\t\tKEY_IS_CHAR,\t\t46\t},\n\t{ \"/\",\t\t\tKEY_IS_CHAR,\t\t47\t},\n\t{ \"0\",\t\t\tKEY_IS_CHAR,\t\t48\t},\n\t{ \"1\",\t\t\tKEY_IS_CHAR,\t\t49\t},\n\t{ \"2\",\t\t\tKEY_IS_CHAR,\t\t50\t},\n\t{ \"3\",\t\t\tKEY_IS_CHAR,\t\t51\t},\n\t{ \"4\",\t\t\tKEY_IS_CHAR,\t\t52\t},\n\t{ \"5\",\t\t\tKEY_IS_CHAR,\t\t53\t},\n\t{ \"6\",\t\t\tKEY_IS_CHAR,\t\t54\t},\n\t{ \"7\",\t\t\tKEY_IS_CHAR,\t\t55\t},\n\t{ \"8\",\t\t\tKEY_IS_CHAR,\t\t56\t},\n\t{ \"9\",\t\t\tKEY_IS_CHAR,\t\t57\t},\n\t{ \":\",\t\t\tKEY_IS_CHAR,\t\t58\t},\n\t{ \";\",\t\t\tKEY_IS_CHAR,\t\t59\t},\n\t{ \"<\",\t\t\tKEY_IS_CHAR,\t\t60\t},\n\t{ \"=\",\t\t\tKEY_IS_CHAR,\t\t61\t},\n\t{ \">\",\t\t\tKEY_IS_CHAR,\t\t62\t},\n\t{ \"?\",\t\t\tKEY_IS_CHAR,\t\t63\t},\n\t{ \"@\",\t\t\tKEY_IS_CHAR,\t\t64\t},\n\t{ \"A\",\t\t\tKEY_IS_CHAR,\t\t65\t},\n\t{ \"B\",\t\t\tKEY_IS_CHAR,\t\t66\t},\n\t{ \"C\",\t\t\tKEY_IS_CHAR,\t\t67\t},\n\t{ \"D\",\t\t\tKEY_IS_CHAR,\t\t68\t},\n\t{ \"E\",\t\t\tKEY_IS_CHAR,\t\t69\t},\n\t{ \"F\",\t\t\tKEY_IS_CHAR,\t\t70\t},\n\t{ \"F1\",\t\t\tKEY_F(1),\t\t0\t},\n\t{ \"F10\",\t\tKEY_F(10),\t\t0\t},\n\t{ \"F11\",\t\tKEY_F(11),\t\t0\t},\n\t{ \"F12\",\t\tKEY_F(12),\t\t0\t},\n\t{ \"F2\",\t\t\tKEY_F(2),\t\t0\t},\n\t{ \"F3\",\t\t\tKEY_F(3),\t\t0\t},\n\t{ \"F4\",\t\t\tKEY_F(4),\t\t0\t},\n\t{ \"F5\",\t\t\tKEY_F(5),\t\t0\t},\n\t{ \"F6\",\t\t\tKEY_F(6),\t\t0\t},\n\t{ \"F7\",\t\t\tKEY_F(7),\t\t0\t},\n\t{ \"F8\",\t\t\tKEY_F(8),\t\t0\t},\n\t{ \"F9\",\t\t\tKEY_F(9),\t\t0\t},\n\t{ \"G\",\t\t\tKEY_IS_CHAR,\t\t71\t},\n\t{ \"H\",\t\t\tKEY_IS_CHAR,\t\t72\t},\n\t{ \"I\",\t\t\tKEY_IS_CHAR,\t\t73\t},\n\t{ \"J\",\t\t\tKEY_IS_CHAR,\t\t74\t},\n\t{ \"K\",\t\t\tKEY_IS_CHAR,\t\t75\t},\n\t{ \"KP_center\",\t\tKEY_B2,\t\t\t0\t},\n\t{ \"KP_lower_left\",\tKEY_C1,\t\t\t0\t},\n\t{ \"KP_lower_right\",\tKEY_C3,\t\t\t0\t},\n\t{ \"KP_upper_left\",\tKEY_A1,\t\t\t0\t},\n\t{ \"KP_upper_right\",\tKEY_A3,\t\t\t0\t},\n\t{ \"L\",\t\t\tKEY_IS_CHAR,\t\t76\t},\n\t{ \"M\",\t\t\tKEY_IS_CHAR,\t\t77\t},\n\t{ \"M-!\",\t\tKEY_IS_CHAR,\t\t161\t},\n\t{ \"M-\\\"\",\t\tKEY_IS_CHAR,\t\t162\t},\n\t{ \"M-#\",\t\tKEY_IS_CHAR,\t\t163\t},\n\t{ \"M-$\",\t\tKEY_IS_CHAR,\t\t164\t},\n\t{ \"M-%\",\t\tKEY_IS_CHAR,\t\t165\t},\n\t{ \"M-&\",\t\tKEY_IS_CHAR,\t\t166\t},\n\t{ \"M-'\",\t\tKEY_IS_CHAR,\t\t167\t},\n\t{ \"M-(\",\t\tKEY_IS_CHAR,\t\t168\t},\n\t{ \"M-)\",\t\tKEY_IS_CHAR,\t\t169\t},\n\t{ \"M-*\",\t\tKEY_IS_CHAR,\t\t170\t},\n\t{ \"M-+\",\t\tKEY_IS_CHAR,\t\t171\t},\n\t{ \"M-,\",\t\tKEY_IS_CHAR,\t\t172\t},\n\t{ \"M--\",\t\tKEY_IS_CHAR,\t\t173\t},\n\t{ \"M-.\",\t\tKEY_IS_CHAR,\t\t174\t},\n\t{ \"M-/\",\t\tKEY_IS_CHAR,\t\t175\t},\n\t{ \"M-0\",\t\tKEY_IS_CHAR,\t\t176\t},\n\t{ \"M-1\",\t\tKEY_IS_CHAR,\t\t177\t},\n\t{ \"M-2\",\t\tKEY_IS_CHAR,\t\t178\t},\n\t{ \"M-3\",\t\tKEY_IS_CHAR,\t\t179\t},\n\t{ \"M-4\",\t\tKEY_IS_CHAR,\t\t180\t},\n\t{ \"M-5\",\t\tKEY_IS_CHAR,\t\t181\t},\n\t{ \"M-6\",\t\tKEY_IS_CHAR,\t\t182\t},\n\t{ \"M-7\",\t\tKEY_IS_CHAR,\t\t183\t},\n\t{ \"M-8\",\t\tKEY_IS_CHAR,\t\t184\t},\n\t{ \"M-9\",\t\tKEY_IS_CHAR,\t\t185\t},\n\t{ \"M-:\",\t\tKEY_IS_CHAR,\t\t186\t},\n\t{ \"M-;\",\t\tKEY_IS_CHAR,\t\t187\t},\n\t{ \"M-<\",\t\tKEY_IS_CHAR,\t\t188\t},\n\t{ \"M-=\",\t\tKEY_IS_CHAR,\t\t189\t},\n\t{ \"M->\",\t\tKEY_IS_CHAR,\t\t190\t},\n\t{ \"M-?\",\t\tKEY_IS_CHAR,\t\t191\t},\n\t{ \"M-@\",\t\tKEY_IS_CHAR,\t\t192\t},\n\t{ \"M-A\",\t\tKEY_IS_CHAR,\t\t193\t},\n\t{ \"M-B\",\t\tKEY_IS_CHAR,\t\t194\t},\n\t{ \"M-C\",\t\tKEY_IS_CHAR,\t\t195\t},\n\t{ \"M-D\",\t\tKEY_IS_CHAR,\t\t196\t},\n\t{ \"M-E\",\t\tKEY_IS_CHAR,\t\t197\t},\n\t{ \"M-F\",\t\tKEY_IS_CHAR,\t\t198\t},\n\t{ \"M-G\",\t\tKEY_IS_CHAR,\t\t199\t},\n\t{ \"M-H\",\t\tKEY_IS_CHAR,\t\t200\t},\n\t{ \"M-I\",\t\tKEY_IS_CHAR,\t\t201\t},\n\t{ \"M-J\",\t\tKEY_IS_CHAR,\t\t202\t},\n\t{ \"M-K\",\t\tKEY_IS_CHAR,\t\t203\t},\n\t{ \"M-L\",\t\tKEY_IS_CHAR,\t\t204\t},\n\t{ \"M-M\",\t\tKEY_IS_CHAR,\t\t205\t},\n\t{ \"M-N\",\t\tKEY_IS_CHAR,\t\t206\t},\n\t{ \"M-O\",\t\tKEY_IS_CHAR,\t\t207\t},\n\t{ \"M-P\",\t\tKEY_IS_CHAR,\t\t208\t},\n\t{ \"M-Q\",\t\tKEY_IS_CHAR,\t\t209\t},\n\t{ \"M-R\",\t\tKEY_IS_CHAR,\t\t210\t},\n\t{ \"M-S\",\t\tKEY_IS_CHAR,\t\t211\t},\n\t{ \"M-T\",\t\tKEY_IS_CHAR,\t\t212\t},\n\t{ \"M-U\",\t\tKEY_IS_CHAR,\t\t213\t},\n\t{ \"M-V\",\t\tKEY_IS_CHAR,\t\t214\t},\n\t{ \"M-W\",\t\tKEY_IS_CHAR,\t\t215\t},\n\t{ \"M-X\",\t\tKEY_IS_CHAR,\t\t216\t},\n\t{ \"M-Y\",\t\tKEY_IS_CHAR,\t\t217\t},\n\t{ \"M-Z\",\t\tKEY_IS_CHAR,\t\t218\t},\n\t{ \"M-[\",\t\tKEY_IS_CHAR,\t\t219\t},\n\t{ \"M-\\\\\",\t\tKEY_IS_CHAR,\t\t220\t},\n\t{ \"M-]\",\t\tKEY_IS_CHAR,\t\t221\t},\n\t{ \"M-^\",\t\tKEY_IS_CHAR,\t\t222\t},\n\t{ \"M-^?\",\t\tKEY_IS_CHAR,\t\t255\t},\n\t{ \"M-^@\",\t\tKEY_IS_CHAR,\t\t128\t},\n\t{ \"M-^A\",\t\tKEY_IS_CHAR,\t\t129\t},\n\t{ \"M-^B\",\t\tKEY_IS_CHAR,\t\t130\t},\n\t{ \"M-^C\",\t\tKEY_IS_CHAR,\t\t131\t},\n\t{ \"M-^D\",\t\tKEY_IS_CHAR,\t\t132\t},\n\t{ \"M-^E\",\t\tKEY_IS_CHAR,\t\t133\t},\n\t{ \"M-^F\",\t\tKEY_IS_CHAR,\t\t134\t},\n\t{ \"M-^G\",\t\tKEY_IS_CHAR,\t\t135\t},\n\t{ \"M-^H\",\t\tKEY_IS_CHAR,\t\t136\t},\n\t{ \"M-^I\",\t\tKEY_IS_CHAR,\t\t137\t},\n\t{ \"M-^J\",\t\tKEY_IS_CHAR,\t\t138\t},\n\t{ \"M-^K\",\t\tKEY_IS_CHAR,\t\t139\t},\n\t{ \"M-^L\",\t\tKEY_IS_CHAR,\t\t140\t},\n\t{ \"M-^M\",\t\tKEY_IS_CHAR,\t\t141\t},\n\t{ \"M-^N\",\t\tKEY_IS_CHAR,\t\t142\t},\n\t{ \"M-^O\",\t\tKEY_IS_CHAR,\t\t143\t},\n\t{ \"M-^P\",\t\tKEY_IS_CHAR,\t\t144\t},\n\t{ \"M-^Q\",\t\tKEY_IS_CHAR,\t\t145\t},\n\t{ \"M-^R\",\t\tKEY_IS_CHAR,\t\t146\t},\n\t{ \"M-^S\",\t\tKEY_IS_CHAR,\t\t147\t},\n\t{ \"M-^T\",\t\tKEY_IS_CHAR,\t\t148\t},\n\t{ \"M-^U\",\t\tKEY_IS_CHAR,\t\t149\t},\n\t{ \"M-^V\",\t\tKEY_IS_CHAR,\t\t150\t},\n\t{ \"M-^W\",\t\tKEY_IS_CHAR,\t\t151\t},\n\t{ \"M-^X\",\t\tKEY_IS_CHAR,\t\t152\t},\n\t{ \"M-^Y\",\t\tKEY_IS_CHAR,\t\t153\t},\n\t{ \"M-^Z\",\t\tKEY_IS_CHAR,\t\t154\t},\n\t{ \"M-^[\",\t\tKEY_IS_CHAR,\t\t155\t},\n\t{ \"M-^\\\\\",\t\tKEY_IS_CHAR,\t\t156\t},\n\t{ \"M-^]\",\t\tKEY_IS_CHAR,\t\t157\t},\n\t{ \"M-^^\",\t\tKEY_IS_CHAR,\t\t158\t},\n\t{ \"M-^_\",\t\tKEY_IS_CHAR,\t\t159\t},\n\t{ \"M-_\",\t\tKEY_IS_CHAR,\t\t223\t},\n\t{ \"M-`\",\t\tKEY_IS_CHAR,\t\t224\t},\n\t{ \"M-a\",\t\tKEY_IS_CHAR,\t\t225\t},\n\t{ \"M-b\",\t\tKEY_IS_CHAR,\t\t226\t},\n\t{ \"M-c\",\t\tKEY_IS_CHAR,\t\t227\t},\n\t{ \"M-d\",\t\tKEY_IS_CHAR,\t\t228\t},\n\t{ \"M-e\",\t\tKEY_IS_CHAR,\t\t229\t},\n\t{ \"M-f\",\t\tKEY_IS_CHAR,\t\t230\t},\n\t{ \"M-g\",\t\tKEY_IS_CHAR,\t\t231\t},\n\t{ \"M-h\",\t\tKEY_IS_CHAR,\t\t232\t},\n\t{ \"M-i\",\t\tKEY_IS_CHAR,\t\t233\t},\n\t{ \"M-j\",\t\tKEY_IS_CHAR,\t\t234\t},\n\t{ \"M-k\",\t\tKEY_IS_CHAR,\t\t235\t},\n\t{ \"M-l\",\t\tKEY_IS_CHAR,\t\t236\t},\n\t{ \"M-m\",\t\tKEY_IS_CHAR,\t\t237\t},\n\t{ \"M-n\",\t\tKEY_IS_CHAR,\t\t238\t},\n\t{ \"M-o\",\t\tKEY_IS_CHAR,\t\t239\t},\n\t{ \"M-p\",\t\tKEY_IS_CHAR,\t\t240\t},\n\t{ \"M-q\",\t\tKEY_IS_CHAR,\t\t241\t},\n\t{ \"M-r\",\t\tKEY_IS_CHAR,\t\t242\t},\n\t{ \"M-s\",\t\tKEY_IS_CHAR,\t\t243\t},\n\t{ \"M-space\",\t\tKEY_IS_CHAR,\t\t160\t},\n\t{ \"M-t\",\t\tKEY_IS_CHAR,\t\t244\t},\n\t{ \"M-u\",\t\tKEY_IS_CHAR,\t\t245\t},\n\t{ \"M-v\",\t\tKEY_IS_CHAR,\t\t246\t},\n\t{ \"M-w\",\t\tKEY_IS_CHAR,\t\t247\t},\n\t{ \"M-x\",\t\tKEY_IS_CHAR,\t\t248\t},\n\t{ \"M-y\",\t\tKEY_IS_CHAR,\t\t249\t},\n\t{ \"M-z\",\t\tKEY_IS_CHAR,\t\t250\t},\n\t{ \"M-{\",\t\tKEY_IS_CHAR,\t\t251\t},\n\t{ \"M-|\",\t\tKEY_IS_CHAR,\t\t252\t},\n\t{ \"M-}\",\t\tKEY_IS_CHAR,\t\t253\t},\n\t{ \"M-~\",\t\tKEY_IS_CHAR,\t\t254\t},\n\t{ \"N\",\t\t\tKEY_IS_CHAR,\t\t78\t},\n\t{ \"O\",\t\t\tKEY_IS_CHAR,\t\t79\t},\n\t{ \"P\",\t\t\tKEY_IS_CHAR,\t\t80\t},\n\t{ \"Q\",\t\t\tKEY_IS_CHAR,\t\t81\t},\n\t{ \"R\",\t\t\tKEY_IS_CHAR,\t\t82\t},\n\t{ \"S\",\t\t\tKEY_IS_CHAR,\t\t83\t},\n\t{ \"S-begin\",\t\tKEY_SBEG,\t\t0\t},\n\t{ \"S-cancel\",\t\tKEY_SCANCEL,\t\t0\t},\n\t{ \"S-command\",\t\tKEY_SCOMMAND,\t\t0\t},\n\t{ \"S-copy\",\t\tKEY_SCOPY,\t\t0\t},\n\t{ \"S-create\",\t\tKEY_SCREATE,\t\t0\t},\n\t{ \"S-del_line\",\t\tKEY_SDL,\t\t0\t},\n\t{ \"S-delete\",\t\tKEY_SDC,\t\t0\t},\n\t{ \"S-eol\",\t\tKEY_SEOL,\t\t0\t},\n\t{ \"S-exit\",\t\tKEY_SEXIT,\t\t0\t},\n\t{ \"S-find\",\t\tKEY_SFIND,\t\t0\t},\n\t{ \"S-help\",\t\tKEY_SHELP,\t\t0\t},\n\t{ \"S-home\",\t\tKEY_SHOME,\t\t0\t},\n\t{ \"S-insert\",\t\tKEY_SIC,\t\t0\t},\n\t{ \"S-left\",\t\tKEY_SLEFT,\t\t0\t},\n\t{ \"S-message\",\t\tKEY_SMESSAGE,\t\t0\t},\n\t{ \"S-move\",\t\tKEY_SMOVE,\t\t0\t},\n\t{ \"S-next\",\t\tKEY_SNEXT,\t\t0\t},\n\t{ \"S-options\",\t\tKEY_SOPTIONS,\t\t0\t},\n\t{ \"S-previous\",\t\tKEY_SPREVIOUS,\t\t0\t},\n\t{ \"S-print\",\t\tKEY_SPRINT,\t\t0\t},\n\t{ \"S-redo\",\t\tKEY_SREDO,\t\t0\t},\n\t{ \"S-replace\",\t\tKEY_SREPLACE,\t\t0\t},\n\t{ \"S-resume\",\t\tKEY_SRSUME,\t\t0\t},\n\t{ \"S-right\",\t\tKEY_SRIGHT,\t\t0\t},\n\t{ \"S-save\",\t\tKEY_SSAVE,\t\t0\t},\n\t{ \"S-suspend\",\t\tKEY_SSUSPEND,\t\t0\t},\n\t{ \"S-undo\",\t\tKEY_SUNDO,\t\t0\t},\n\t{ \"T\",\t\t\tKEY_IS_CHAR,\t\t84\t},\n\t{ \"U\",\t\t\tKEY_IS_CHAR,\t\t85\t},\n\t{ \"V\",\t\t\tKEY_IS_CHAR,\t\t86\t},\n\t{ \"W\",\t\t\tKEY_IS_CHAR,\t\t87\t},\n\t{ \"X\",\t\t\tKEY_IS_CHAR,\t\t88\t},\n\t{ \"Y\",\t\t\tKEY_IS_CHAR,\t\t89\t},\n\t{ \"Z\",\t\t\tKEY_IS_CHAR,\t\t90\t},\n\t{ \"[\",\t\t\tKEY_IS_CHAR,\t\t91\t},\n\t{ \"\\\\\",\t\t\tKEY_IS_CHAR,\t\t92\t},\n\t{ \"]\",\t\t\tKEY_IS_CHAR,\t\t93\t},\n\t{ \"^\",\t\t\tKEY_IS_CHAR,\t\t94\t},\n\t{ \"^A\",\t\t\tKEY_IS_CHAR,\t\t1\t},\n\t{ \"^B\",\t\t\tKEY_IS_CHAR,\t\t2\t},\n\t{ \"^C\",\t\t\tKEY_IS_CHAR,\t\t3\t},\n\t{ \"^D\",\t\t\tKEY_IS_CHAR,\t\t4\t},\n\t{ \"^E\",\t\t\tKEY_IS_CHAR,\t\t5\t},\n\t{ \"^F\",\t\t\tKEY_IS_CHAR,\t\t6\t},\n\t{ \"^G\",\t\t\tKEY_IS_CHAR,\t\t7\t},\n\t{ \"^H\",\t\t\tKEY_IS_CHAR,\t\t8\t},\n\t{ \"^K\",\t\t\tKEY_IS_CHAR,\t\t11\t},\n\t{ \"^L\",\t\t\tKEY_IS_CHAR,\t\t12\t},\n\t{ \"^M\",\t\t\tKEY_IS_CHAR,\t\t13\t},\n\t{ \"^N\",\t\t\tKEY_IS_CHAR,\t\t14\t},\n\t{ \"^O\",\t\t\tKEY_IS_CHAR,\t\t15\t},\n\t{ \"^P\",\t\t\tKEY_IS_CHAR,\t\t16\t},\n\t{ \"^Q\",\t\t\tKEY_IS_CHAR,\t\t17\t},\n\t{ \"^R\",\t\t\tKEY_IS_CHAR,\t\t18\t},\n\t{ \"^S\",\t\t\tKEY_IS_CHAR,\t\t19\t},\n\t{ \"^T\",\t\t\tKEY_IS_CHAR,\t\t20\t},\n\t{ \"^U\",\t\t\tKEY_IS_CHAR,\t\t21\t},\n\t{ \"^V\",\t\t\tKEY_IS_CHAR,\t\t22\t},\n\t{ \"^W\",\t\t\tKEY_IS_CHAR,\t\t23\t},\n\t{ \"^X\",\t\t\tKEY_IS_CHAR,\t\t24\t},\n\t{ \"^Y\",\t\t\tKEY_IS_CHAR,\t\t25\t},\n\t{ \"^Z\",\t\t\tKEY_IS_CHAR,\t\t26\t},\n\t{ \"^\\\\\",\t\tKEY_IS_CHAR,\t\t28\t},\n\t{ \"^]\",\t\t\tKEY_IS_CHAR,\t\t29\t},\n\t{ \"^^\",\t\t\tKEY_IS_CHAR,\t\t30\t},\n\t{ \"^_\",\t\t\tKEY_IS_CHAR,\t\t31\t},\n\t{ \"_\",\t\t\tKEY_IS_CHAR,\t\t95\t},\n\t{ \"`\",\t\t\tKEY_IS_CHAR,\t\t96\t},\n\t{ \"a\",\t\t\tKEY_IS_CHAR,\t\t97\t},\n\t{ \"b\",\t\t\tKEY_IS_CHAR,\t\t98\t},\n\t{ \"back_tab\",\t\tKEY_BTAB,\t\t0\t},\n\t{ \"backspace\",\t\tKEY_BACKSPACE,\t\t127\t}, /* NOTE: both key and ch */\n\t{ \"begin\",\t\tKEY_BEG,\t\t0\t},\n\t{ \"c\",\t\t\tKEY_IS_CHAR,\t\t99\t},\n\t{ \"cancel\",\t\tKEY_CANCEL,\t\t0\t},\n\t{ \"clear\",\t\tKEY_CLEAR,\t\t0\t},\n\t{ \"clear_all_tabs\",\tKEY_CATAB,\t\t0\t},\n\t{ \"clear_tab\",\t\tKEY_CTAB,\t\t0\t},\n\t{ \"close\",\t\tKEY_CLOSE,\t\t0\t},\n\t{ \"command\",\t\tKEY_COMMAND,\t\t0\t},\n\t{ \"copy\",\t\tKEY_COPY,\t\t0\t},\n\t{ \"create\",\t\tKEY_CREATE,\t\t0\t},\n\t{ \"d\",\t\t\tKEY_IS_CHAR,\t\t100\t},\n\t{ \"del_line\",\t\tKEY_DL,\t\t\t0\t},\n\t{ \"delete\",\t\tKEY_DC,\t\t\t0\t},\n\t{ \"down\",\t\tKEY_DOWN,\t\t0\t},\n\t{ \"e\",\t\t\tKEY_IS_CHAR,\t\t101\t},\n\t{ \"eic\",\t\tKEY_EIC,\t\t0\t},\n\t{ \"end\",\t\tKEY_END,\t\t0\t},\n\t{ \"enter\",\t\tKEY_IS_CHAR,\t\t10\t},\n\t{ \"eol\",\t\tKEY_EOL,\t\t0\t},\n\t{ \"eos\",\t\tKEY_EOS,\t\t0\t},\n\t{ \"exit\",\t\tKEY_EXIT,\t\t0\t},\n\t{ \"f\",\t\t\tKEY_IS_CHAR,\t\t102\t},\n\t{ \"find\",\t\tKEY_FIND,\t\t0\t},\n\t{ \"g\",\t\t\tKEY_IS_CHAR,\t\t103\t},\n\t{ \"h\",\t\t\tKEY_IS_CHAR,\t\t104\t},\n\t{ \"help\",\t\tKEY_HELP,\t\t0\t},\n\t{ \"home\",\t\tKEY_HOME,\t\t0\t},\n\t{ \"i\",\t\t\tKEY_IS_CHAR,\t\t105\t},\n\t{ \"ins_line\",\t\tKEY_IL,\t\t\t0\t},\n\t{ \"insert\",\t\tKEY_IC,\t\t\t0\t},\n\t{ \"j\",\t\t\tKEY_IS_CHAR,\t\t106\t},\n\t{ \"k\",\t\t\tKEY_IS_CHAR,\t\t107\t},\n\t{ \"l\",\t\t\tKEY_IS_CHAR,\t\t108\t},\n\t{ \"left\",\t\tKEY_LEFT,\t\t0\t},\n\t{ \"lower_left\",\t\tKEY_LL,\t\t\t0\t},\n\t{ \"m\",\t\t\tKEY_IS_CHAR,\t\t109\t},\n\t{ \"mark\",\t\tKEY_MARK,\t\t0\t},\n\t{ \"message\",\t\tKEY_MESSAGE,\t\t0\t},\n\t{ \"move\",\t\tKEY_MOVE,\t\t0\t},\n\t{ \"n\",\t\t\tKEY_IS_CHAR,\t\t110\t},\n\t{ \"next\",\t\tKEY_NEXT,\t\t0\t},\n\t{ \"o\",\t\t\tKEY_IS_CHAR,\t\t111\t},\n\t{ \"open\",\t\tKEY_OPEN,\t\t0\t},\n\t{ \"options\",\t\tKEY_OPTIONS,\t\t0\t},\n\t{ \"p\",\t\t\tKEY_IS_CHAR,\t\t112\t},\n\t{ \"page_down\",\t\tKEY_NPAGE,\t\t0\t},\n\t{ \"page_up\",\t\tKEY_PPAGE,\t\t0\t},\n\t{ \"previous\",\t\tKEY_PREVIOUS,\t\t0\t},\n\t{ \"print\",\t\tKEY_PRINT,\t\t0\t},\n\t{ \"q\",\t\t\tKEY_IS_CHAR,\t\t113\t},\n\t{ \"r\",\t\t\tKEY_IS_CHAR,\t\t114\t},\n\t{ \"redo\",\t\tKEY_REDO,\t\t0\t},\n\t{ \"reference\",\t\tKEY_REFERENCE,\t\t0\t},\n\t{ \"refresh\",\t\tKEY_REFRESH,\t\t0\t},\n\t{ \"replace\",\t\tKEY_REPLACE,\t\t0\t},\n\t{ \"restart\",\t\tKEY_RESTART,\t\t0\t},\n\t{ \"resume\",\t\tKEY_RESUME,\t\t0\t},\n\t{ \"right\",\t\tKEY_RIGHT,\t\t0\t},\n\t{ \"s\",\t\t\tKEY_IS_CHAR,\t\t115\t},\n\t{ \"save\",\t\tKEY_SAVE,\t\t0\t},\n\t{ \"scroll_b\",\t\tKEY_SR,\t\t\t0\t},\n\t{ \"scroll_f\",\t\tKEY_SF,\t\t\t0\t},\n\t{ \"select\",\t\tKEY_SELECT,\t\t0\t},\n\t{ \"send\",\t\tKEY_SEND,\t\t0\t},\n\t{ \"set_tab\",\t\tKEY_STAB,\t\t0\t},\n\t{ \"space\",\t\tKEY_IS_CHAR,\t\t32\t},\n\t{ \"suspend\",\t\tKEY_SUSPEND,\t\t0\t},\n\t{ \"t\",\t\t\tKEY_IS_CHAR,\t\t116\t},\n\t{ \"tab\",\t\tKEY_IS_CHAR,\t\t9\t},\n\t{ \"u\",\t\t\tKEY_IS_CHAR,\t\t117\t},\n\t{ \"undo\",\t\tKEY_UNDO,\t\t0\t},\n\t{ \"up\",\t\t\tKEY_UP,\t\t\t0\t},\n\t{ \"v\",\t\t\tKEY_IS_CHAR,\t\t118\t},\n\t{ \"w\",\t\t\tKEY_IS_CHAR,\t\t119\t},\n\t{ \"x\",\t\t\tKEY_IS_CHAR,\t\t120\t},\n\t{ \"y\",\t\t\tKEY_IS_CHAR,\t\t121\t},\n\t{ \"z\",\t\t\tKEY_IS_CHAR,\t\t122\t},\n\t{ \"{\",\t\t\tKEY_IS_CHAR,\t\t123\t},\n\t{ \"|\",\t\t\tKEY_IS_CHAR,\t\t124\t},\n\t{ \"}\",\t\t\tKEY_IS_CHAR,\t\t125\t},\n\t{ \"~\",\t\t\tKEY_IS_CHAR,\t\t126\t},\n\t{ \"mlb_click\",\t\tKEY_MOUSE,\t\tKEY_MLB_CLICK\t\t},\n\t{ \"mlb_click_selected\",\tKEY_MOUSE,\t\tKEY_MLB_CLICK_SEL\t},\n\t{ \"mlb_click_bar\",\tKEY_MOUSE,\t\tKEY_MLB_CLICK_BAR\t},\n\t{ \"mlb_click_bar_right\",\tKEY_MOUSE,\t\tKEY_MLB_CLICK_BAR_R\t},\n\t{ \"mlb_click_title\",\tKEY_MOUSE,\t\tKEY_MLB_CLICK_TIT\t},\n\t{ \"mrb_click\",\t\tKEY_MOUSE,\t\tKEY_MRB_CLICK\t\t},\n\t{ \"mrb_click_selected\",\tKEY_MOUSE,\t\tKEY_MRB_CLICK_SEL\t},\n\t{ \"mrb_click_bar\",\tKEY_MOUSE,\t\tKEY_MRB_CLICK_BAR\t},\n\t{ \"mrb_click_bar_right\",\tKEY_MOUSE,\t\tKEY_MRB_CLICK_BAR_R\t},\n\t{ \"mrb_click_title\",\tKEY_MOUSE,\t\tKEY_MRB_CLICK_TIT\t},\n\t{ \"mouse_scroll_up\",\tKEY_MOUSE,\t\tKEY_MSCRL_UP\t\t},\n\t{ \"mouse_scroll_up_bar\",\tKEY_MOUSE,\t\tKEY_MSCRL_UP_BAR\t\t},\n\t{ \"mouse_scroll_up_bar_right\",\tKEY_MOUSE,\t\tKEY_MSCRL_UP_BAR_R\t\t},\n\t{ \"mouse_scroll_up_title\",\tKEY_MOUSE,\t\tKEY_MSCRL_UP_TIT\t\t},\n\t{ \"mouse_scroll_down\",\tKEY_MOUSE,\t\tKEY_MSCRL_DOWN\t\t},\n\t{ \"mouse_scroll_down_bar\",\tKEY_MOUSE,\t\tKEY_MSCRL_DOWN_BAR\t\t},\n\t{ \"mouse_scroll_down_bar_right\",\tKEY_MOUSE,\t\tKEY_MSCRL_DOWN_BAR_R\t\t},\n\t{ \"mouse_scroll_down_title\",\tKEY_MOUSE,\t\tKEY_MSCRL_DOWN_TIT\t\t},\n\t{ NULL,\t\t\t0,\t\t\t0\t}\n};\n/* }}} */\n\nstatic int find_context(const char *name)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_CTXS; i++) {\n\t\tif (strcmp(name, key_context_names[i]) == 0)\n\t\t\treturn i;\n\t}\n\terror_msg(\"invalid context '%s'\", name);\n\treturn -1;\n}\n\nstatic const struct key *find_key(const char *name)\n{\n\tint i;\n\n\tfor (i = 0; key_table[i].name; i++) {\n\t\tif (strcmp(name, key_table[i].name) == 0)\n\t\t\treturn &key_table[i];\n\t}\n\terror_msg(\"invalid key '%s'\", name);\n\treturn NULL;\n}\n\nstatic struct binding *find_binding(enum key_context c, const struct key *k)\n{\n\tstruct binding *b = key_bindings[c];\n\n\twhile (b) {\n\t\tif (b->key == k)\n\t\t\tbreak;\n\t\tb = b->next;\n\t}\n\treturn b;\n}\n\nvoid show_binding(const char *context, const char *key)\n{\n\tconst struct key *k;\n\tconst struct binding *b;\n\tint c;\n\n\tc = find_context(context);\n\tif (c < 0)\n\t\treturn;\n\n\tk = find_key(key);\n\tif (k == NULL)\n\t\treturn;\n\n\tb = find_binding(c, k);\n\tif (b == NULL) {\n\t\tinfo_msg(\"No such binding\");\n\t} else {\n\t\tinfo_msg(\"bind %s %s %s\", context, key, b->cmd);\n\t}\n}\n\nint key_bind(const char *context, const char *key, const char *cmd, int force)\n{\n\tconst struct key *k;\n\tstruct binding *b, *ptr, *prev;\n\tstruct command *command;\n\tint c, size;\n\n\tc = find_context(context);\n\tif (c < 0)\n\t\treturn -1;\n\n\tk = find_key(key);\n\tif (k == NULL)\n\t\treturn -1;\n\n\t/* check if already bound */\n\tb = find_binding(c, k);\n\tif (b) {\n\t\tif (!force)\n\t\t\tgoto bound;\n\t\tkey_unbind(context, key, 0);\n\t}\n\n\tif (*cmd == ':')\n\t\tcmd++;\n\tsize = strlen(cmd) + 1;\n\n\tb = xmalloc(sizeof(struct binding) + size);\n\tb->key = k;\n\tb->ctx = c;\n\tmemcpy(b->cmd, cmd, size);\n\n\t/* insert keeping sorted by key */\n\tprev = NULL;\n\tptr = key_bindings[c];\n\twhile (ptr) {\n\t\tif (strcmp(b->key->name, ptr->key->name) < 0)\n\t\t\tbreak;\n\t\tprev = ptr;\n\t\tptr = ptr->next;\n\t}\n\tb->next = ptr;\n\tif (prev) {\n\t\tprev->next = b;\n\t} else {\n\t\tkey_bindings[c] = b;\n\t}\n\tcommand = get_command(cmd);\n\tif (command && !command->bc++)\n\t\thelp_remove_unbound(command);\n\thelp_add_bound(b);\n\treturn 0;\nbound:\n\terror_msg(\"key %s already bound in context %s\", key, key_context_names[c]);\n\treturn -1;\n}\n\nint key_unbind(const char *context, const char *key, int force)\n{\n\tint c;\n\tconst struct key *k;\n\tstruct binding *b, *prev;\n\tstruct command *command;\n\n\tc = find_context(context);\n\tif (c < 0)\n\t\treturn -1;\n\n\tk = find_key(key);\n\tif (k == NULL)\n\t\treturn -1;\n\n\tprev = NULL;\n\tb = key_bindings[c];\n\twhile (b) {\n\t\tif (b->key == k) {\n\t\t\tif (prev) {\n\t\t\t\tprev->next = b->next;\n\t\t\t} else {\n\t\t\t\tkey_bindings[c] = b->next;\n\t\t\t}\n\t\t\tcommand = get_command(b->cmd);\n\t\t\tif (command && !--command->bc)\n\t\t\t\thelp_add_unbound(command);\n\t\t\thelp_remove_bound(b);\n\t\t\tfree(b);\n\t\t\treturn 0;\n\t\t}\n\t\tprev = b;\n\t\tb = b->next;\n\t}\n\tif (!force) {\n\t\terror_msg(\"key %s not bound in context %s\", key, context);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int handle_key(const struct binding *b, const struct key *k)\n{\n\twhile (b) {\n\t\tif (b->key == k) {\n\t\t\trun_command(b->cmd);\n\t\t\treturn 1;\n\t\t}\n\t\tb = b->next;\n\t}\n\treturn 0;\n}\n\nstatic const struct key *ch_to_key(uchar ch)\n{\n\tint i;\n\n\tfor (i = 0; key_table[i].name; i++) {\n\t\tif (key_table[i].key != KEY_MOUSE && key_table[i].ch == ch)\n\t\t\treturn &key_table[i];\n\t}\n\treturn NULL;\n}\n\nstatic const struct key *keycode_to_key(int key)\n{\n\tint i;\n\n\tfor (i = 0; key_table[i].name; i++) {\n\t\tif (key_table[i].key != KEY_IS_CHAR &&\n\t\t\tkey_table[i].key != KEY_MOUSE && key_table[i].key == key)\n\t\t\treturn &key_table[i];\n\t}\n\treturn NULL;\n}\n\n#define DEF_ME_START if (event->bstate == 0) { return NULL; }\n#define DEF_ME_KEY(s, k) else if (event->bstate & s) { key = k | type; }\n#define DEF_ME_END else { return NULL; }\n\nstatic const struct key *mevent_to_key(MEVENT *event, int type)\n{\n\tint i, key = -255;\n\n\tDEF_ME_START\n\tDEF_ME_KEY(BUTTON1_CLICKED, KEY_MLB_CLICK)\n\tDEF_ME_KEY(BUTTON1_PRESSED, KEY_MLB_CLICK)\n\tDEF_ME_KEY(BUTTON3_CLICKED, KEY_MRB_CLICK)\n\tDEF_ME_KEY(BUTTON3_PRESSED, KEY_MRB_CLICK)\n\tDEF_ME_KEY(BUTTON4_PRESSED, KEY_MSCRL_UP)\n\tDEF_ME_KEY(BUTTON5_PRESSED, KEY_MSCRL_DOWN)\n\tDEF_ME_END\n\n\tfor (i = 0; key_table[i].name; i++) {\n\t\tif (key_table[i].key == KEY_MOUSE && key_table[i].ch == key)\n\t\t\treturn &key_table[i];\n\t}\n\treturn NULL;\n}\n\n#undef DEF_ME_START\n#undef DEF_ME_KEY\n#undef DEF_ME_END\n\nvoid normal_mode_ch(uchar ch)\n{\n\tenum key_context c;\n\tconst struct key *k;\n\n\tc = view_to_context[cur_view];\n\tk = ch_to_key(ch);\n\n\tif (k == NULL) {\n\t\treturn;\n\t}\n\n\t/* view-specific ch */\n\tif (handle_key(key_bindings[c], k))\n\t\treturn;\n\n\t/* common ch */\n\tif (handle_key(key_bindings[CTX_COMMON], k))\n\t\treturn;\n\n\t/* these can be overridden but have default magic */\n\tswitch (ch) {\n\tcase ':':\n\t\tenter_command_mode();\n\t\treturn;\n\tcase '/':\n\t\tenter_search_mode();\n\t\treturn;\n\tcase '?':\n\t\tenter_search_backward_mode();\n\t\treturn;\n\t}\n}\n\nvoid normal_mode_key(int key)\n{\n\tenum key_context c = view_to_context[cur_view];\n\tconst struct key *k = keycode_to_key(key);\n\n\tif (k == NULL) {\n\t\treturn;\n\t}\n\n\t/* view-specific key */\n\tif (handle_key(key_bindings[c], k))\n\t\treturn;\n\n\t/* common key */\n\thandle_key(key_bindings[CTX_COMMON], k);\n}\n\nstatic const struct key *normal_mode_mouse_handle(MEVENT* event)\n{\n\tint track_win_x = get_track_win_x(), i = event->y - 1, need_sel, type;\n\tstruct window* win = NULL;\n\tstruct iter it, sel;\n\n\tif (event->y == 0) {\n\t\tneed_sel = 0;\n\t\ttype = KEY_M_TYPE_TIT;\n\t} else if (event->y == LINES - 2) {\n\t\tneed_sel = 0;\n\t\ttype = event->x >= (COLS - COLS/3)\n\t\t\t? KEY_M_TYPE_BAR_R\n\t\t\t: KEY_M_TYPE_BAR;\n\t} else {\n\t\tif (cur_view == TREE_VIEW) {\n\t\t\tif (event->x >= track_win_x)\n\t\t\t\twin = lib_track_win;\n\t\t\telse if (event->x < track_win_x - 1)\n\t\t\t\twin = lib_tree_win;\n\t\t\telse\n\t\t\t\treturn NULL;\n\t\t\ttype = (lib_cur_win == win) ? KEY_M_TYPE_SEL : KEY_M_TYPE_NONE;\n\t\t} else if (cur_view == PLAYLIST_VIEW) {\n\t\t\tif (event->x >= track_win_x)\n\t\t\t\twin = pl_editable_shared.win;\n\t\t\telse if (event->x < track_win_x)\n\t\t\t\twin = pl_list_win;\n\t\t\telse\n\t\t\t\treturn NULL;\n\t\t\ttype = (pl_cursor_win() == win) ? KEY_M_TYPE_SEL : KEY_M_TYPE_NONE;\n\t\t} else {\n\t\t\twin = current_win();\n\t\t\ttype = KEY_M_TYPE_SEL;\n\t\t}\n\n\t\tif ((event->bstate & BUTTON4_PRESSED) || (event->bstate & BUTTON5_PRESSED)) {\n\t\t\tneed_sel = 0;\n\t\t\ttype = KEY_M_TYPE_NONE;\n\t\t\tif (event->y < 1 || event->y >= LINES - 3)\n\t\t\t\treturn NULL;\n\t\t\tif (cur_view == TREE_VIEW && lib_cur_win != win)\n\t\t\t\ttree_toggle_active_window();\n\t\t\tif (cur_view == PLAYLIST_VIEW && pl_cursor_win() != win)\n\t\t\t\tpl_win_next();\n\t\t} else {\n\t\t\tif (event->y < 1 || event->y > window_get_nr_rows(win))\n\t\t\t\treturn NULL;\n\t\t\tif (cur_view == TREE_VIEW && lib_cur_win != win)\n\t\t\t\ttree_toggle_active_window();\n\t\t\tif (cur_view == PLAYLIST_VIEW && pl_cursor_win() != win)\n\t\t\t\tpl_win_next();\n\t\t\tif (!window_get_top(win, &it) || !window_get_sel(win, &sel))\n\t\t\t\treturn NULL;\n\t\t\twhile (i-- > 0)\n\t\t\t\tif (!window_get_next(win, &it))\n\t\t\t\t\treturn NULL;\n\t\t\twhile (win->selectable && !win->selectable(&it))\n\t\t\t\tif (!window_get_next(win, &it))\n\t\t\t\t\treturn NULL;\n\n\t\t\ttype = (type == KEY_M_TYPE_SEL && iters_equal(&sel, &it)) ? KEY_M_TYPE_SEL : KEY_M_TYPE_NONE;\n\t\t\tneed_sel = !iters_equal(&sel, &it);\n\t\t}\n\t}\n\n\tconst struct key *k = mevent_to_key(event, type);\n\tif (k == NULL)\n\t\treturn NULL;\n\n\tif (need_sel)\n\t\twindow_set_sel(win, &it);\n\n\treturn k;\n}\n\nvoid normal_mode_mouse(MEVENT *event)\n{\n\tenum key_context c = view_to_context[cur_view];\n\tconst struct key *k = normal_mode_mouse_handle(event);\n\n\tif (k == NULL)\n\t\treturn;\n\n\t/* view-specific key */\n\tif (handle_key(key_bindings[c], k))\n\t\treturn;\n\n\t/* common key */\n\thandle_key(key_bindings[CTX_COMMON], k);\n}\n"
        },
        {
          "name": "keys.h",
          "type": "blob",
          "size": 1.8232421875,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004-2006 Timo Hirvonen\n *\n * keys.[ch] by Frank Terbeck <ft@bewatermyfriend.org>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_KEYS_H\n#define CMUS_KEYS_H\n\n#include \"uchar.h\"\n\n#if defined(__sun__) || defined(__CYGWIN__)\n/* TIOCGWINSZ */\n#include <termios.h>\n#include <ncurses.h>\n#else\n#include <curses.h>\n#endif\n\nenum key_context {\n\tCTX_BROWSER,\n\tCTX_COMMON,\n\tCTX_FILTERS,\n\tCTX_LIBRARY,\n\tCTX_PLAYLIST,\n\tCTX_QUEUE,\n\tCTX_SETTINGS,\n};\n#define NR_CTXS (CTX_SETTINGS + 1)\n\n#if NCURSES_MOUSE_VERSION <= 1\n#define BUTTON5_PRESSED ((REPORT_MOUSE_POSITION) | (BUTTON2_PRESSED))\n#endif\n\nstruct key {\n\tconst char *name;\n\tint key;\n\tuchar ch;\n};\n\nstruct binding {\n\tstruct binding *next;\n\tconst struct key *key;\n\tenum key_context ctx;\n\tchar cmd[];\n};\n\nextern const char * const key_context_names[NR_CTXS + 1];\nextern const struct key key_table[];\nextern struct binding *key_bindings[NR_CTXS];\n\nvoid show_binding(const char *context, const char *key);\nint key_bind(const char *context, const char *key, const char *cmd, int force);\nint key_unbind(const char *context, const char *key, int force);\n\nvoid normal_mode_ch(uchar ch);\nvoid normal_mode_key(int key);\nvoid normal_mode_mouse(MEVENT *event);\n\n#endif\n"
        },
        {
          "name": "keyval.c",
          "type": "blob",
          "size": 2.6474609375,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2008 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"debug.h\"\n#include \"keyval.h\"\n#include \"xmalloc.h\"\n\n#include <strings.h>\n\nstruct keyval *keyvals_new(int num)\n{\n\tstruct keyval *c = xnew(struct keyval, num + 1);\n\tint i;\n\n\tfor (i = 0; i <= num; i++) {\n\t\tc[i].key = NULL;\n\t\tc[i].val = NULL;\n\t}\n\treturn c;\n}\n\nstruct keyval *keyvals_dup(const struct keyval *keyvals)\n{\n\tstruct keyval *c;\n\tint i;\n\n\tfor (i = 0; keyvals[i].key; i++)\n\t\t; /* nothing */\n\tc = xnew(struct keyval, i + 1);\n\tfor (i = 0; keyvals[i].key; i++) {\n\t\tc[i].key = xstrdup(keyvals[i].key);\n\t\tc[i].val = xstrdup(keyvals[i].val);\n\t}\n\tc[i].key = NULL;\n\tc[i].val = NULL;\n\treturn c;\n}\n\nvoid keyvals_free(struct keyval *keyvals)\n{\n\tint i;\n\n\tfor (i = 0; keyvals[i].key; i++) {\n\t\tfree(keyvals[i].key);\n\t\tfree(keyvals[i].val);\n\t}\n\tfree(keyvals);\n}\n\nconst char *keyvals_get_val(const struct keyval *keyvals, const char *key)\n{\n\tint i;\n\n\tfor (i = 0; keyvals[i].key; i++) {\n\t\tif (strcasecmp(keyvals[i].key, key) == 0)\n\t\t\treturn keyvals[i].val;\n\t}\n\treturn NULL;\n}\n\nvoid keyvals_init(struct growing_keyvals *c, const struct keyval *keyvals)\n{\n\tint i;\n\n\tBUG_ON(c->keyvals);\n\n\tfor (i = 0; keyvals[i].key; i++)\n\t\t; /* nothing */\n\n\tc->keyvals = keyvals_dup(keyvals);\n\tc->alloc = i;\n\tc->count = i;\n}\n\nvoid keyvals_add(struct growing_keyvals *c, const char *key, char *val)\n{\n\tint n = c->count + 1;\n\n\tif (n > c->alloc) {\n\t\tn = (n + 3) & ~3;\n\t\tc->keyvals = xrenew(struct keyval, c->keyvals, n);\n\t\tc->alloc = n;\n\t}\n\n\tc->keyvals[c->count].key = xstrdup(key);\n\tc->keyvals[c->count].val = val;\n\tc->count++;\n}\n\nconst char *keyvals_get_val_growing(const struct growing_keyvals *c, const char *key)\n{\n\tint i;\n\n\tfor (i = 0; i < c->count; ++i)\n\t\tif (strcasecmp(c->keyvals[i].key, key) == 0)\n\t\t\treturn c->keyvals[i].val;\n\n\treturn NULL;\n}\n\nvoid keyvals_terminate(struct growing_keyvals *c)\n{\n\tint alloc = c->count + 1;\n\n\tif (alloc > c->alloc) {\n\t\tc->keyvals = xrenew(struct keyval, c->keyvals, alloc);\n\t\tc->alloc = alloc;\n\t}\n\tc->keyvals[c->count].key = NULL;\n\tc->keyvals[c->count].val = NULL;\n}\n"
        },
        {
          "name": "keyval.h",
          "type": "blob",
          "size": 1.4443359375,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2008 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_KEYVAL_H\n#define CMUS_KEYVAL_H\n\nstruct keyval {\n\tchar *key;\n\tchar *val;\n};\n\nstruct growing_keyvals {\n\tstruct keyval *keyvals;\n\tint alloc;\n\tint count;\n};\n\n#define GROWING_KEYVALS(name) struct growing_keyvals name = { NULL, 0, 0 }\n\nstruct keyval *keyvals_new(int num);\nvoid keyvals_init(struct growing_keyvals *c, const struct keyval *keyvals);\nvoid keyvals_add(struct growing_keyvals *c, const char *key, char *val);\nconst char *keyvals_get_val_growing(const struct growing_keyvals *c, const char *key);\nvoid keyvals_terminate(struct growing_keyvals *c);\nvoid keyvals_free(struct keyval *keyvals);\nstruct keyval *keyvals_dup(const struct keyval *keyvals);\nconst char *keyvals_get_val(const struct keyval *keyvals, const char *key);\n\n#endif\n"
        },
        {
          "name": "lib.c",
          "type": "blob",
          "size": 21.576171875,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004-2006 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"lib.h\"\n#include \"editable.h\"\n#include \"track_info.h\"\n#include \"options.h\"\n#include \"xmalloc.h\"\n#include \"rbtree.h\"\n#include \"debug.h\"\n#include \"utils.h\"\n#include \"u_collate.h\"\n#include \"ui_curses.h\" /* cur_view */\n\n#include <pthread.h>\n#include <string.h>\n\nstruct editable lib_editable;\nstatic struct editable_shared lib_editable_shared;\n\nstruct tree_track *lib_cur_track = NULL;\nunsigned int play_sorted = 0;\nenum aaa_mode aaa_mode = AAA_MODE_ALL;\n/* used in ui_curses.c for status display */\nchar *lib_live_filter = NULL;\n\nstruct rb_root lib_shuffle_root;\nstruct rb_root lib_album_shuffle_root;\nstatic struct expr *filter = NULL;\nstatic struct expr *add_filter = NULL;\nstatic int remove_from_hash = 1;\n\nstatic struct expr *live_filter_expr = NULL;\nstatic struct track_info *cur_track_ti = NULL;\nstatic struct track_info *sel_track_ti = NULL;\n\nconst char *artist_sort_name(const struct artist *a)\n{\n\tif (a->sort_name)\n\t\treturn a->sort_name;\n\n\tif (smart_artist_sort && a->auto_sort_name)\n\t\treturn a->auto_sort_name;\n\n\treturn a->name;\n}\n\nstatic inline void sorted_track_to_iter(struct tree_track *track, struct iter *iter)\n{\n\titer->data0 = &lib_editable.head;\n\titer->data1 = track;\n\titer->data2 = NULL;\n}\n\nstatic void all_wins_changed(void)\n{\n\tlib_tree_win->changed = 1;\n\tlib_track_win->changed = 1;\n\tlib_editable.shared->win->changed = 1;\n}\n\nstatic void shuffle_add(struct tree_track *track)\n{\n\tshuffle_list_add(&track->simple_track.shuffle_info, &lib_shuffle_root, track->album);\n}\n\nstatic void album_shuffle_list_add(struct album *album)\n{\n\tshuffle_list_add(&album->shuffle_info, &lib_album_shuffle_root, album);\n}\n\nstatic void album_shuffle_list_remove(struct album *album)\n{\n\trb_erase(&album->shuffle_info.tree_node, &lib_album_shuffle_root);\n}\n\nstatic void views_add_track(struct track_info *ti)\n{\n\tstruct tree_track *track = xnew(struct tree_track, 1);\n\n\t/* NOTE: does not ref ti */\n\tsimple_track_init((struct simple_track *)track, ti);\n\n\t/* both the hash table and views have refs */\n\ttrack_info_ref(ti);\n\n\ttree_add_track(track, album_shuffle_list_add);\n\tshuffle_add(track);\n\teditable_add(&lib_editable, (struct simple_track *)track);\n}\n\nstruct fh_entry {\n\tstruct fh_entry *next;\n\n\t/* ref count is increased when added to this hash */\n\tstruct track_info *ti;\n};\n\n#define FH_SIZE (1024)\nstatic struct fh_entry *ti_hash[FH_SIZE] = { NULL, };\n\nstatic int hash_insert(struct track_info *ti)\n{\n\tconst char *filename = ti->filename;\n\tunsigned int pos = hash_str(filename) % FH_SIZE;\n\tstruct fh_entry **entryp;\n\tstruct fh_entry *e;\n\n\tentryp = &ti_hash[pos];\n\te = *entryp;\n\twhile (e) {\n\t\tif (strcmp(e->ti->filename, filename) == 0) {\n\t\t\t/* found, don't insert */\n\t\t\treturn 0;\n\t\t}\n\t\te = e->next;\n\t}\n\n\te = xnew(struct fh_entry, 1);\n\ttrack_info_ref(ti);\n\te->ti = ti;\n\te->next = *entryp;\n\t*entryp = e;\n\treturn 1;\n}\n\nstatic void hash_remove(struct track_info *ti)\n{\n\tconst char *filename = ti->filename;\n\tunsigned int pos = hash_str(filename) % FH_SIZE;\n\tstruct fh_entry **entryp;\n\n\tentryp = &ti_hash[pos];\n\twhile (1) {\n\t\tstruct fh_entry *e = *entryp;\n\n\t\tBUG_ON(e == NULL);\n\t\tif (strcmp(e->ti->filename, filename) == 0) {\n\t\t\t*entryp = e->next;\n\t\t\ttrack_info_unref(e->ti);\n\t\t\tfree(e);\n\t\t\tbreak;\n\t\t}\n\t\tentryp = &e->next;\n\t}\n}\n\nstatic int is_filtered(struct track_info *ti)\n{\n\tif (live_filter_expr && !expr_eval(live_filter_expr, ti))\n\t\treturn 1;\n\tif (!live_filter_expr && lib_live_filter && !track_info_matches(ti, lib_live_filter, TI_MATCH_ALL))\n\t\treturn 1;\n\tif (filter && !expr_eval(filter, ti))\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic bool track_exists(struct track_info *ti)\n{\n\tstruct rb_node *node;\n\tstruct artist *artist;\n\tstruct album *album;\n\tstruct tree_track *track;\n\n\tif (!ti->collkey_title)\n\t\treturn false;\n\n\tchar *artist_collkey_name = u_strcasecoll_key(tree_artist_name(ti));\n\trb_for_each_entry(artist, node, &lib_artist_root, tree_node) {\n\t\tif (strcmp(artist->collkey_name, artist_collkey_name) == 0)\n\t\t\tbreak;\n\t}\n\tfree(artist_collkey_name);\n\n\tif (!artist)\n\t\treturn false;\n\n\tchar *album_collkey_name = u_strcasecoll_key(tree_album_name(ti));\n\trb_for_each_entry(album, node, &artist->album_root, tree_node) {\n\t\tif (strcmp(album->collkey_name, album_collkey_name) == 0)\n\t\t\tbreak;\n\t}\n\tfree(album_collkey_name);\n\n\tif (!album)\n\t\treturn false;\n\n\trb_for_each_entry(track, node, &album->track_root, tree_node) {\n\t\tstruct track_info *iter_ti = tree_track_info(track);\n\t\tif (iter_ti->tracknumber == ti->tracknumber\n\t\t\t\t&& iter_ti->discnumber == ti->discnumber\n\t\t\t\t&& iter_ti->collkey_title && strcmp(iter_ti->collkey_title, ti->collkey_title) == 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nvoid lib_add_track(struct track_info *ti, void *opaque)\n{\n\tif (!ti)\n\t\treturn;\n\n\tif (add_filter && !expr_eval(add_filter, ti)) {\n\t\t/* filter any files excluded by lib_add_filter */\n\t\treturn;\n\t}\n\n\tif (ignore_duplicates && track_exists(ti))\n\t\treturn;\n\n\tif (!hash_insert(ti)) {\n\t\t/* duplicate files not allowed */\n\t\treturn;\n\t}\n\n\tif (!is_filtered(ti))\n\t\tviews_add_track(ti);\n}\n\nstatic struct tree_track *album_first_track(const struct album *album)\n{\n\treturn to_tree_track(rb_first(&album->track_root));\n}\n\nstatic struct tree_track *artist_first_track(const struct artist *artist)\n{\n\treturn album_first_track(to_album(rb_first(&artist->album_root)));\n}\n\nstatic struct tree_track *normal_get_first(void)\n{\n\treturn artist_first_track(to_artist(rb_first(&lib_artist_root)));\n}\n\nstatic struct tree_track *album_last_track(const struct album *album)\n{\n\treturn to_tree_track(rb_last(&album->track_root));\n}\n\nstatic struct tree_track *artist_last_track(const struct artist *artist)\n{\n\treturn album_last_track(to_album(rb_last(&artist->album_root)));\n}\n\nstatic struct tree_track *normal_get_last(void)\n{\n\treturn artist_last_track(to_artist(rb_last(&lib_artist_root)));\n}\n\nstatic int aaa_mode_filter(const struct album *album)\n{\n\tif (aaa_mode == AAA_MODE_ALBUM)\n\t\treturn CUR_ALBUM == album;\n\n\tif (aaa_mode == AAA_MODE_ARTIST)\n\t\treturn CUR_ARTIST == album->artist;\n\n\t/* AAA_MODE_ALL */\n\treturn 1;\n}\n\nstatic int cur_album_filter(const struct album *album)\n{\n\treturn CUR_ALBUM == album;\n}\n\n/* set next/prev (tree) {{{ */\n\nstatic struct tree_track *normal_get_next(enum aaa_mode aaa, bool allow_repeat, bool skip_album)\n{\n\tif (lib_cur_track == NULL) {\n\t\tif (!allow_repeat)\n\t\t\treturn NULL;\n\t\treturn normal_get_first();\n\t}\n\n\t/* not last track of the album? */\n\tif (!skip_album && rb_next(&lib_cur_track->tree_node)) {\n\t\t/* next track of the current album */\n\t\treturn to_tree_track(rb_next(&lib_cur_track->tree_node));\n\t}\n\n\tif (aaa == AAA_MODE_ALBUM) {\n\t\tif (!allow_repeat || !repeat)\n\t\t\treturn NULL;\n\t\t/* first track of the current album */\n\t\treturn album_first_track(CUR_ALBUM);\n\t}\n\n\t/* not last album of the artist? */\n\tif (rb_next(&CUR_ALBUM->tree_node) != NULL) {\n\t\t/* first track of the next album */\n\t\treturn album_first_track(to_album(rb_next(&CUR_ALBUM->tree_node)));\n\t}\n\n\tif (aaa == AAA_MODE_ARTIST) {\n\t\tif (!allow_repeat || !repeat)\n\t\t\treturn NULL;\n\t\t/* first track of the first album of the current artist */\n\t\treturn artist_first_track(CUR_ARTIST);\n\t}\n\n\t/* not last artist of the library? */\n\tif (rb_next(&CUR_ARTIST->tree_node) != NULL) {\n\t\t/* first track of the next artist */\n\t\treturn artist_first_track(to_artist(rb_next(&CUR_ARTIST->tree_node)));\n\t}\n\n\tif (!allow_repeat || !repeat)\n\t\treturn NULL;\n\n\t/* first track */\n\treturn normal_get_first();\n}\n\nstatic struct tree_track *normal_get_prev(enum aaa_mode aaa, bool allow_repeat, bool skip_album)\n{\n\tif (lib_cur_track == NULL) {\n\t\tif (!allow_repeat)\n\t\t\treturn NULL;\n\t\treturn normal_get_last();\n\t}\n\n\t/* not first track of the album? */\n\tif (!skip_album && rb_prev(&lib_cur_track->tree_node)) {\n\t\t/* prev track of the album */\n\t\treturn to_tree_track(rb_prev(&lib_cur_track->tree_node));\n\t}\n\n\tif (aaa == AAA_MODE_ALBUM) {\n\t\tif (!allow_repeat || !repeat)\n\t\t\treturn NULL;\n\t\t/* last track of the album */\n\t\treturn album_last_track(CUR_ALBUM);\n\t}\n\n\t/* not first album of the artist? */\n\tif (rb_prev(&CUR_ALBUM->tree_node) != NULL) {\n\t\t/* last track of the prev album of the artist */\n\t\treturn album_last_track(to_album(rb_prev(&CUR_ALBUM->tree_node)));\n\t}\n\n\tif (aaa == AAA_MODE_ARTIST) {\n\t\tif (!allow_repeat || !repeat)\n\t\t\treturn NULL;\n\t\t/* last track of the last album of the artist */\n\t\treturn album_last_track(to_album(rb_last(&CUR_ARTIST->album_root)));\n\t}\n\n\t/* not first artist of the library? */\n\tif (rb_prev(&CUR_ARTIST->tree_node) != NULL) {\n\t\t/* last track of the last album of the prev artist */\n\t\treturn artist_last_track(to_artist(rb_prev(&CUR_ARTIST->tree_node)));\n\t}\n\n\tif (!allow_repeat || !repeat)\n\t\treturn NULL;\n\n\t/* last track */\n\treturn normal_get_last();\n}\n\nstatic struct tree_track *shuffle_album_get_next(void)\n{\n\tstruct shuffle_info *shuffle_info = NULL;\n\tstruct album *album;\n\n\tif (lib_cur_track != NULL)\n\t\tshuffle_info = &lib_cur_track->album->shuffle_info;\n\talbum = (struct album *)shuffle_list_get_next(&lib_album_shuffle_root,\n\t\t\tshuffle_info, aaa_mode_filter);\n\tif (album != NULL)\n\t\treturn album_first_track(album);\n\treturn NULL;\n}\n\nstatic struct tree_track *shuffle_album_get_prev(void)\n{\n\tstruct shuffle_info *shuffle_info = NULL;\n\tstruct album *album;\n\n\tif (lib_cur_track != NULL)\n\t\tshuffle_info = &lib_cur_track->album->shuffle_info;\n\talbum = (struct album *)shuffle_list_get_prev(&lib_album_shuffle_root,\n\t\t\tshuffle_info, aaa_mode_filter);\n\tif (album != NULL)\n\t\treturn album_last_track(album);\n\treturn NULL;\n}\n\nstatic struct tree_track *sorted_album_first_track(struct tree_track *track)\n{\n\tstruct tree_track *prev = track;\n\n\twhile (true) {\n\t\tprev = (struct tree_track *)simple_list_get_prev(&lib_editable.head,\n\t\t\t   (struct simple_track *)prev, NULL, false);\n\t\tif (prev == NULL)\n\t\t\treturn track;\n\t\tif (prev->album == track->album)\n\t\t\ttrack = prev;\n\t}\n}\n\nstatic struct tree_track *sorted_album_last_track(struct tree_track *track)\n{\n\tstruct tree_track *next = track;\n\n\twhile (true) {\n\t\tnext = (struct tree_track *)simple_list_get_next(&lib_editable.head,\n\t\t\t   (struct simple_track *)next, NULL, false);\n\t\tif (next == NULL)\n\t\t\treturn track;\n\t\tif (next->album == track->album)\n\t\t\ttrack = next;\n\t}\n}\n\n/* set next/prev (tree) }}} */\n\nvoid lib_reshuffle(void)\n{\n\tshuffle_list_reshuffle(&lib_shuffle_root);\n\tshuffle_list_reshuffle(&lib_album_shuffle_root);\n\tif (lib_cur_track) {\n\t\tshuffle_insert(&lib_shuffle_root, NULL, &lib_cur_track->simple_track.shuffle_info);\n\t\tshuffle_insert(&lib_album_shuffle_root, NULL, &lib_cur_track->album->shuffle_info);\n\t}\n}\n\nvoid lib_sort_artists(void) {\n\ttree_sort_artists(album_shuffle_list_add, album_shuffle_list_remove);\n}\n\nstatic void free_lib_track(struct editable *e, struct list_head *item)\n{\n\tstruct tree_track *track = (struct tree_track *)to_simple_track(item);\n\tstruct track_info *ti = tree_track_info(track);\n\n\tif (track == lib_cur_track)\n\t\tlib_cur_track = NULL;\n\n\tif (remove_from_hash)\n\t\thash_remove(ti);\n\n\trb_erase(&track->simple_track.shuffle_info.tree_node, &lib_shuffle_root);\n\ttree_remove(track, album_shuffle_list_remove);\n\n\ttrack_info_unref(ti);\n\tfree(track);\n}\n\nvoid lib_init(void)\n{\n\teditable_shared_init(&lib_editable_shared, free_lib_track);\n\teditable_init(&lib_editable, &lib_editable_shared, 1);\n\ttree_init();\n\tsrand(time(NULL));\n}\n\nstruct track_info *lib_set_track(struct tree_track *track)\n{\n\tstruct track_info *ti = NULL;\n\n\tif (track) {\n\t\tlib_cur_track = track;\n\t\tti = tree_track_info(track);\n\t\ttrack_info_ref(ti);\n\t\tif (follow) {\n\t\t\ttree_sel_current(auto_expand_albums_follow);\n\t\t\tsorted_sel_current();\n\t\t}\n\t\tall_wins_changed();\n\t}\n\treturn ti;\n}\n\nstruct track_info *lib_goto_next(void)\n{\n\tstruct tree_track *track;\n\n\tif (rb_root_empty(&lib_artist_root)) {\n\t\tBUG_ON(lib_cur_track != NULL);\n\t\treturn NULL;\n\t}\n\tif (shuffle == SHUFFLE_TRACKS) {\n\t\ttrack = (struct tree_track *)shuffle_list_get_next(&lib_shuffle_root,\n\t\t\t\t(struct shuffle_info *)lib_cur_track, aaa_mode_filter);\n\t} else if (shuffle == SHUFFLE_ALBUMS) {\n\t\tif (play_sorted)\n\t\t\ttrack = (struct tree_track *)simple_list_get_next(&lib_editable.head,\n\t\t\t\t\t(struct simple_track *)lib_cur_track, cur_album_filter, false);\n\t\telse\n\t\t\ttrack = normal_get_next(AAA_MODE_ALBUM, false, false);\n\t\tif (track == NULL) {\n\t\t\ttrack = shuffle_album_get_next();\n\t\t\tif (play_sorted)\n\t\t\t\ttrack = sorted_album_first_track(track);\n\t\t}\n\t} else if (play_sorted) {\n\t\ttrack = (struct tree_track *)simple_list_get_next(&lib_editable.head,\n\t\t\t\t(struct simple_track *)lib_cur_track, aaa_mode_filter, true);\n\t} else {\n\t\ttrack = normal_get_next(aaa_mode, true, false);\n\t}\n\treturn lib_set_track(track);\n}\n\nstruct track_info *lib_goto_prev(void)\n{\n\tstruct tree_track *track;\n\n\tif (rb_root_empty(&lib_artist_root)) {\n\t\tBUG_ON(lib_cur_track != NULL);\n\t\treturn NULL;\n\t}\n\tif (shuffle == SHUFFLE_TRACKS) {\n\t\ttrack = (struct tree_track *)shuffle_list_get_prev(&lib_shuffle_root,\n\t\t\t\t(struct shuffle_info *)lib_cur_track, aaa_mode_filter);\n\t} else if (shuffle == SHUFFLE_ALBUMS) {\n\t\tif (play_sorted)\n\t\t\ttrack = (struct tree_track *)simple_list_get_prev(&lib_editable.head,\n\t\t\t\t\t(struct simple_track *)lib_cur_track, cur_album_filter, false);\n\t\telse\n\t\t\ttrack = normal_get_prev(AAA_MODE_ALBUM, false, false);\n\t\tif (track == NULL) {\n\t\t\ttrack = shuffle_album_get_prev();\n\t\t\tif (play_sorted)\n\t\t\t\ttrack = sorted_album_last_track(track);\n\t\t}\n\t} else if (play_sorted) {\n\t\ttrack = (struct tree_track *)simple_list_get_prev(&lib_editable.head,\n\t\t\t\t(struct simple_track *)lib_cur_track, aaa_mode_filter, true);\n\t} else {\n\t\ttrack = normal_get_prev(aaa_mode, true, false);\n\t}\n\treturn lib_set_track(track);\n}\n\nstruct track_info *lib_goto_next_album(void)\n{\n\tstruct tree_track *track = NULL;\n\n\tif (rb_root_empty(&lib_artist_root)) {\n\t\tBUG_ON(lib_cur_track != NULL);\n\t\treturn NULL;\n\t}\n\tif (shuffle == SHUFFLE_TRACKS) {\n\t\treturn lib_goto_next();\n\t} else if (shuffle == SHUFFLE_ALBUMS) {\n\t\ttrack = shuffle_album_get_next();\n\t\tif (play_sorted)\n\t\t\ttrack = sorted_album_first_track(track);\n\t} else if (play_sorted) {\n\t\ttrack = sorted_album_last_track(lib_cur_track);\n\t\ttrack = (struct tree_track *)simple_list_get_next(&lib_editable.head,\n\t\t\t\t(struct simple_track *)track, aaa_mode_filter, true);\n\t} else {\n\t\ttrack = normal_get_next(aaa_mode, true, true);\n\t}\n\n\treturn lib_set_track(track);\n}\n\nstruct track_info *lib_goto_prev_album(void)\n{\n\tstruct tree_track *track = NULL;\n\n\tif (rb_root_empty(&lib_artist_root)) {\n\t\tBUG_ON(lib_cur_track != NULL);\n\t\treturn NULL;\n\t}\n\tif (shuffle == SHUFFLE_TRACKS) {\n\t\treturn lib_goto_prev();\n\t} else if (shuffle == SHUFFLE_ALBUMS) {\n\t\ttrack = shuffle_album_get_prev();\n\t\tif (play_sorted)\n\t\t\ttrack = sorted_album_first_track(track);\n\t\telse if (track)\n\t\t\ttrack = album_first_track(track->album);\n\t} else if (play_sorted) {\n\t\ttrack = sorted_album_first_track(lib_cur_track);\n\t\ttrack = (struct tree_track *)simple_list_get_prev(&lib_editable.head,\n\t\t\t\t(struct simple_track *)track, aaa_mode_filter, true);\n\t\ttrack = sorted_album_first_track(track);\n\t} else {\n\t\ttrack = normal_get_prev(aaa_mode, true, true);\n\t\tif (track)\n\t\t\ttrack = album_first_track(track->album);\n\t}\n\n\treturn lib_set_track(track);\n}\n\nstatic struct tree_track *sorted_get_selected(void)\n{\n\tstruct iter sel;\n\n\tif (list_empty(&lib_editable.head))\n\t\treturn NULL;\n\n\twindow_get_sel(lib_editable.shared->win, &sel);\n\treturn iter_to_sorted_track(&sel);\n}\n\nstruct track_info *sorted_activate_selected(void)\n{\n\treturn lib_set_track(sorted_get_selected());\n}\n\nstatic void hash_add_to_views(void)\n{\n\tint i;\n\tfor (i = 0; i < FH_SIZE; i++) {\n\t\tstruct fh_entry *e;\n\n\t\te = ti_hash[i];\n\t\twhile (e) {\n\t\t\tstruct track_info *ti = e->ti;\n\n\t\t\tif (!is_filtered(ti) && !(ignore_duplicates && track_exists(ti)))\n\t\t\t\tviews_add_track(ti);\n\t\t\te = e->next;\n\t\t}\n\t}\n}\n\nstruct tree_track *lib_find_track(struct track_info *ti)\n{\n\tstruct simple_track *track;\n\n\tlist_for_each_entry(track, &lib_editable.head, node) {\n\t\tif (strcmp(track->info->filename, ti->filename) == 0) {\n\t\t\tstruct tree_track *tt = (struct tree_track *)track;\n\t\t\treturn tt;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nvoid lib_store_cur_track(struct track_info *ti)\n{\n\tif (cur_track_ti)\n\t\ttrack_info_unref(cur_track_ti);\n\tcur_track_ti = ti;\n\ttrack_info_ref(cur_track_ti);\n}\n\nstruct track_info *lib_get_cur_stored_track(void)\n{\n\tif (cur_track_ti && lib_find_track(cur_track_ti))\n\t\treturn cur_track_ti;\n\treturn NULL;\n}\n\nstatic void restore_cur_track(struct track_info *ti)\n{\n\tstruct tree_track *tt = lib_find_track(ti);\n\tif (tt)\n\t\tlib_cur_track = tt;\n}\n\nstatic int is_filtered_cb(void *data, struct track_info *ti)\n{\n\treturn is_filtered(ti);\n}\n\nstatic void do_lib_filter(int clear_before)\n{\n\t/* try to save cur_track */\n\tif (lib_cur_track)\n\t\tlib_store_cur_track(tree_track_info(lib_cur_track));\n\n\tif (clear_before)\n\t\td_print(\"filter results could grow, clear tracks and re-add (slow)\\n\");\n\n\tremove_from_hash = 0;\n\tif (clear_before) {\n\t\teditable_clear(&lib_editable);\n\t\thash_add_to_views();\n\t} else\n\t\teditable_remove_matching_tracks(&lib_editable, is_filtered_cb, NULL);\n\tremove_from_hash = 1;\n\n\twindow_changed(lib_editable.shared->win);\n\twindow_goto_top(lib_editable.shared->win);\n\tlib_cur_win = lib_tree_win;\n\twindow_goto_top(lib_tree_win);\n\n\t/* restore cur_track */\n\tif (cur_track_ti && !lib_cur_track)\n\t\trestore_cur_track(cur_track_ti);\n}\n\nstatic void unset_live_filter(void)\n{\n\tfree(lib_live_filter);\n\tlib_live_filter = NULL;\n\tfree(live_filter_expr);\n\tlive_filter_expr = NULL;\n}\n\nvoid lib_set_filter(struct expr *expr)\n{\n\tint clear_before = lib_live_filter || filter;\n\tunset_live_filter();\n\tif (filter)\n\t\texpr_free(filter);\n\tfilter = expr;\n\tdo_lib_filter(clear_before);\n}\n\nvoid lib_set_add_filter(struct expr *expr)\n{\n\tif (add_filter)\n\t\texpr_free(add_filter);\n\tadd_filter = expr;\n}\n\nstatic struct tree_track *get_sel_track(void)\n{\n\tswitch (cur_view) {\n\tcase TREE_VIEW:\n\t\treturn tree_get_selected();\n\tcase SORTED_VIEW:\n\t\treturn sorted_get_selected();\n\t}\n\treturn NULL;\n}\n\nstatic void set_sel_track(struct tree_track *tt)\n{\n\tstruct iter iter;\n\n\tswitch (cur_view) {\n\tcase TREE_VIEW:\n\t\ttree_sel_track(tt, auto_expand_albums_selcur);\n\t\tbreak;\n\tcase SORTED_VIEW:\n\t\tsorted_track_to_iter(tt, &iter);\n\t\twindow_set_sel(lib_editable.shared->win, &iter);\n\t\tbreak;\n\t}\n}\n\nstatic void store_sel_track(void)\n{\n\tstruct tree_track *tt = get_sel_track();\n\tif (tt) {\n\t\tsel_track_ti = tree_track_info(tt);\n\t\ttrack_info_ref(sel_track_ti);\n\t}\n}\n\nstatic void restore_sel_track(void)\n{\n\tif (sel_track_ti) {\n\t\tstruct tree_track *tt = lib_find_track(sel_track_ti);\n\t\tif (tt) {\n\t\t\tset_sel_track(tt);\n\t\t\ttrack_info_unref(sel_track_ti);\n\t\t\tsel_track_ti = NULL;\n\t\t}\n\t}\n}\n\n/* determine if filter results could grow, in which case all tracks must be cleared and re-added */\nstatic int do_clear_before(const char *str, struct expr *expr)\n{\n\tif (!lib_live_filter)\n\t\treturn 0;\n\tif (!str)\n\t\treturn 1;\n\tif ((!expr && live_filter_expr) || (expr && !live_filter_expr))\n\t\treturn 1;\n\tif (!expr || expr_is_harmless(expr))\n\t\treturn !strstr(str, lib_live_filter);\n\treturn 1;\n}\n\nvoid lib_set_live_filter(const char *str)\n{\n\tint clear_before;\n\tstruct expr *expr = NULL;\n\n\tif (strcmp0(str, lib_live_filter) == 0)\n\t\treturn;\n\n\tif (str && expr_is_short(str)) {\n\t\texpr = expr_parse(str);\n\t\tif (!expr)\n\t\t\treturn;\n\t}\n\n\tclear_before = do_clear_before(str, expr);\n\n\tif (!str)\n\t\tstore_sel_track();\n\n\tunset_live_filter();\n\tlib_live_filter = str ? xstrdup(str) : NULL;\n\tlive_filter_expr = expr;\n\tdo_lib_filter(clear_before);\n\n\tif (expr) {\n\t\tunsigned int match_type = expr_get_match_type(expr);\n\t\tif (match_type & TI_MATCH_ALBUM)\n\t\t\ttree_expand_all();\n\t\tif (match_type & TI_MATCH_TITLE)\n\t\t\ttree_sel_first();\n\t} else if (str)\n\t\ttree_expand_matching(str);\n\n\tif (!str)\n\t\trestore_sel_track();\n}\n\nint lib_remove(struct track_info *ti)\n{\n\tstruct simple_track *track;\n\n\tlist_for_each_entry(track, &lib_editable.head, node) {\n\t\tif (track->info == ti) {\n\t\t\teditable_remove_track(&lib_editable, track);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid lib_clear_store(void)\n{\n\tint i;\n\n\tfor (i = 0; i < FH_SIZE; i++) {\n\t\tstruct fh_entry *e, *next;\n\n\t\te = ti_hash[i];\n\t\twhile (e) {\n\t\t\tnext = e->next;\n\t\t\ttrack_info_unref(e->ti);\n\t\t\tfree(e);\n\t\t\te = next;\n\t\t}\n\t\tti_hash[i] = NULL;\n\t}\n}\n\nvoid sorted_sel_current(void)\n{\n\tif (lib_cur_track) {\n\t\tstruct iter iter;\n\n\t\tsorted_track_to_iter(lib_cur_track, &iter);\n\t\twindow_set_sel(lib_editable.shared->win, &iter);\n\t}\n}\n\nstatic int ti_cmp(const void *a, const void *b)\n{\n\tconst struct track_info *ai = *(const struct track_info **)a;\n\tconst struct track_info *bi = *(const struct track_info **)b;\n\n\treturn track_info_cmp(ai, bi, lib_editable.shared->sort_keys);\n}\n\nstatic int do_lib_for_each(int (*cb)(void *data, struct track_info *ti), void *data, int filtered)\n{\n\tint i, rc = 0, count = 0, size = 1024;\n\tstruct track_info **tis;\n\n\ttis = xnew(struct track_info *, size);\n\n\t/* collect all track_infos */\n\tfor (i = 0; i < FH_SIZE; i++) {\n\t\tstruct fh_entry *e;\n\n\t\te = ti_hash[i];\n\t\twhile (e) {\n\t\t\tif (count == size) {\n\t\t\t\tsize *= 2;\n\t\t\t\ttis = xrenew(struct track_info *, tis, size);\n\t\t\t}\n\t\t\tif (!filtered || !filter || expr_eval(filter, e->ti))\n\t\t\t\ttis[count++] = e->ti;\n\t\t\te = e->next;\n\t\t}\n\t}\n\n\t/* sort to speed up playlist loading */\n\tqsort(tis, count, sizeof(struct track_info *), ti_cmp);\n\tfor (i = 0; i < count; i++) {\n\t\trc = cb(data, tis[i]);\n\t\tif (rc)\n\t\t\tbreak;\n\t}\n\n\tfree(tis);\n\treturn rc;\n}\n\nint lib_for_each(int (*cb)(void *data, struct track_info *ti), void *data,\n\t\tvoid *opaque)\n{\n\treturn do_lib_for_each(cb, data, 0);\n}\n\nint lib_for_each_filtered(int (*cb)(void *data, struct track_info *ti),\n\t\tvoid *data, void *opaque)\n{\n\treturn do_lib_for_each(cb, data, 1);\n}\n"
        },
        {
          "name": "lib.h",
          "type": "blob",
          "size": 5.369140625,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004-2006 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_LIB_H\n#define CMUS_LIB_H\n\n#include \"editable.h\"\n#include \"search.h\"\n#include \"track_info.h\"\n#include \"expr.h\"\n#include \"rbtree.h\"\n\nstruct tree_track {\n\tstruct simple_track simple_track;\n\n\t/* position in track search tree */\n\tstruct rb_node tree_node;\n\n\tstruct album *album;\n};\n\nstatic inline struct track_info *tree_track_info(const struct tree_track *track)\n{\n\treturn ((struct simple_track *)track)->info;\n}\n\nstatic inline struct tree_track *to_tree_track(const struct rb_node *node)\n{\n\treturn container_of(node, struct tree_track, tree_node);\n}\n\n\nstruct album {\n\tstruct shuffle_info shuffle_info;\n\n\t/* position in album search tree */\n\tstruct rb_node tree_node;\n\n\t/* root of track tree */\n\tstruct rb_root track_root;\n\n\tstruct artist *artist;\n\tchar *name;\n\tchar *sort_name;\n\tchar *collkey_name;\n\tchar *collkey_sort_name;\n\t/* max date of the tracks added to this album */\n\tint date;\n\t/* min date of the tracks added to this album */\n\tint min_date;\n};\n\nstruct artist {\n\t/* position in artist search tree */\n\tstruct rb_node tree_node;\n\n\t/* root of album tree */\n\tstruct rb_root album_root;\n\n\tchar *name;\n\tchar *sort_name;\n\tchar *auto_sort_name;\n\tchar *collkey_name;\n\tchar *collkey_sort_name;\n\tchar *collkey_auto_sort_name;\n\n\t/* albums visible for this artist in the tree_win? */\n\tunsigned int expanded : 1;\n\tunsigned int is_compilation : 1;\n};\n\nconst char *artist_sort_name(const struct artist *);\n\nenum aaa_mode {\n\tAAA_MODE_ALL,\n\tAAA_MODE_ARTIST,\n\tAAA_MODE_ALBUM\n};\n\nextern struct editable lib_editable;\nextern struct tree_track *lib_cur_track;\nextern struct rb_root lib_shuffle_root;\nextern struct rb_root lib_album_shuffle_root;\nextern enum aaa_mode aaa_mode;\nextern unsigned int play_sorted;\nextern char *lib_live_filter;\n\nextern struct searchable *tree_searchable;\nextern struct window *lib_tree_win;\nextern struct window *lib_track_win;\nextern struct window *lib_cur_win;\nextern struct rb_root lib_artist_root;\n\n#define CUR_ALBUM\t(lib_cur_track->album)\n#define CUR_ARTIST\t(lib_cur_track->album->artist)\n\nvoid lib_init(void);\nvoid tree_init(void);\nstruct track_info *lib_goto_next(void);\nstruct track_info *lib_goto_prev(void);\nstruct track_info *lib_goto_next_album(void);\nstruct track_info *lib_goto_prev_album(void);\nvoid lib_add_track(struct track_info *track_info, void *opaque);\nvoid lib_set_filter(struct expr *expr);\nvoid lib_set_live_filter(const char *str);\nvoid lib_set_add_filter(struct expr *expr);\nint lib_remove(struct track_info *ti);\nvoid lib_clear_store(void);\nvoid lib_reshuffle(void);\nvoid lib_sort_artists(void);\nvoid lib_set_view(int view);\nint lib_for_each(int (*cb)(void *data, struct track_info *ti), void *data,\n\t\tvoid *opaque);\nint lib_for_each_filtered(int (*cb)(void *data, struct track_info *ti),\n\t\tvoid *data, void *opaque);\n\nstruct tree_track *lib_find_track(struct track_info *ti);\nstruct track_info *lib_set_track(struct tree_track *track);\nvoid lib_store_cur_track(struct track_info *ti);\nstruct track_info *lib_get_cur_stored_track(void);\n\nstruct tree_track *tree_get_selected(void);\nstruct track_info *tree_activate_selected(void);\nconst char *tree_artist_name(const struct track_info* ti);\nconst char *tree_album_name(const struct track_info* ti);\nvoid tree_sort_artists(void (*add_album_cb)(struct album *), void (*remove_album_cb)(struct album *));\nvoid tree_add_track(struct tree_track *track, void (*add_album_cb)(struct album *));\nvoid tree_remove(struct tree_track *track, void (*remove_album_cb)(struct album *));\nvoid tree_remove_sel(void);\nvoid tree_toggle_active_window(void);\nvoid tree_toggle_expand_artist(void);\nvoid tree_expand_matching(const char *text);\nvoid tree_expand_all(void);\nvoid tree_sel_update(int changed);\nvoid tree_sel_current(int auto_expand_albums);\nvoid tree_sel_first(void);\nvoid tree_sel_track(struct tree_track *t, int auto_expand_albums);\nint tree_for_each_sel(int (*cb)(void *data, struct track_info *ti), void *data, int reverse, int advance);\nint _tree_for_each_sel(int (*cb)(void *data, struct track_info *ti), void *data, int reverse);\n\nstruct track_info *sorted_activate_selected(void);\nvoid sorted_sel_current(void);\n\nstatic inline struct tree_track *iter_to_sorted_track(const struct iter *iter)\n{\n\treturn iter->data1;\n}\n\nstatic inline struct artist *iter_to_artist(const struct iter *iter)\n{\n\treturn iter->data1;\n}\n\nstatic inline struct album *iter_to_album(const struct iter *iter)\n{\n\treturn iter->data2;\n}\n\nstatic inline struct tree_track *iter_to_tree_track(const struct iter *iter)\n{\n\treturn iter->data1;\n}\n\nstatic inline struct artist *to_artist(const struct rb_node *node)\n{\n\treturn container_of(node, struct artist, tree_node);\n}\n\nstatic inline struct album *to_album(const struct rb_node *node)\n{\n\treturn container_of(node, struct album, tree_node);\n}\n\n#endif\n"
        },
        {
          "name": "list.h",
          "type": "blob",
          "size": 9.6376953125,
          "content": "/*\n * Stolen from Linux 2.6.7\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; version 2 of the\n * License.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_LIST_H\n#define CMUS_LIST_H\n\n#include \"compiler.h\" /* container_of */\n\nstatic inline void prefetch(const void *x)\n{\n}\n\n/*\n * These are non-NULL pointers that will result in page faults\n * under normal circumstances, used to verify that nobody uses\n * non-initialized list entries.\n */\n#define LIST_POISON1  ((void *) 0x00100100)\n#define LIST_POISON2  ((void *) 0x00200200)\n\n/*\n * Simple doubly linked list implementation.\n *\n * Some of the internal functions (\"_xxx\") are useful when\n * manipulating whole lists rather than single entries, as\n * sometimes we already know the next/prev entries and we can\n * generate better code by using them directly rather than\n * using the generic single-entry routines.\n */\n\nstruct list_head {\n\tstruct list_head *next, *prev;\n};\n\n#define LIST_HEAD_INIT(name) { &(name), &(name) }\n\n#define LIST_HEAD(name) \\\n\tstruct list_head name = LIST_HEAD_INIT(name)\n\nstatic inline void list_init(struct list_head *head)\n{\n\thead->next = head;\n\thead->prev = head;\n}\n\n/*\n * Insert a new entry between two known consecutive entries.\n *\n * This is only for internal list manipulation where we know\n * the prev/next entries already!\n */\nstatic inline void _list_add(struct list_head *new,\n\t\t\t      struct list_head *prev,\n\t\t\t      struct list_head *next)\n{\n\tnext->prev = new;\n\tnew->next = next;\n\tnew->prev = prev;\n\tprev->next = new;\n}\n\nstatic inline struct list_head *list_prev(struct list_head *list)\n{\n\treturn list->prev;\n}\n\nstatic inline struct list_head *list_next(struct list_head *list)\n{\n\treturn list->next;\n}\n\n/**\n * list_add - add a new entry\n * @new: new entry to be added\n * @head: list head to add it after\n *\n * Insert a new entry after the specified head.\n * This is good for implementing stacks.\n */\nstatic inline void list_add(struct list_head *new, struct list_head *head)\n{\n\t_list_add(new, head, head->next);\n}\n\n/**\n * list_add_tail - add a new entry\n * @new: new entry to be added\n * @head: list head to add it before\n *\n * Insert a new entry before the specified head.\n * This is useful for implementing queues.\n */\nstatic inline void list_add_tail(struct list_head *new, struct list_head *head)\n{\n\t_list_add(new, head->prev, head);\n}\n\n/*\n * Delete a list entry by making the prev/next entries\n * point to each other.\n *\n * This is only for internal list manipulation where we know\n * the prev/next entries already!\n */\nstatic inline void _list_del(struct list_head *prev, struct list_head *next)\n{\n\tnext->prev = prev;\n\tprev->next = next;\n}\n\n/**\n * list_del - deletes entry from list.\n * @entry: the element to delete from the list.\n * Note: list_empty on entry does not return true after this, the entry is\n * in an undefined state.\n */\nstatic inline void list_del(struct list_head *entry)\n{\n\t_list_del(entry->prev, entry->next);\n\tentry->next = LIST_POISON1;\n\tentry->prev = LIST_POISON2;\n}\n\n/**\n * list_del_init - deletes entry from list and reinitialize it.\n * @entry: the element to delete from the list.\n */\nstatic inline void list_del_init(struct list_head *entry)\n{\n\t_list_del(entry->prev, entry->next);\n\tlist_init(entry);\n}\n\n/**\n * list_move - delete from one list and add as another one's head\n * @list: the entry to move\n * @head: the head that will precede our entry\n */\nstatic inline void list_move(struct list_head *list, struct list_head *head)\n{\n\t_list_del(list->prev, list->next);\n\tlist_add(list, head);\n}\n\n/**\n * list_move_tail - delete from one list and add as another one's tail\n * @list: the entry to move\n * @head: the head that will follow our entry\n */\nstatic inline void list_move_tail(struct list_head *list,\n\t\t\t\t  struct list_head *head)\n{\n\t_list_del(list->prev, list->next);\n\tlist_add_tail(list, head);\n}\n\n/**\n * list_empty - tests whether a list is empty\n * @head: the list to test.\n */\nstatic inline int list_empty(const struct list_head *head)\n{\n\treturn head->next == head;\n}\n\nstatic inline void _list_splice(struct list_head *list,\n\t\t\t\t struct list_head *head)\n{\n\tstruct list_head *first = list->next;\n\tstruct list_head *last = list->prev;\n\tstruct list_head *at = head->next;\n\n\tfirst->prev = head;\n\thead->next = first;\n\n\tlast->next = at;\n\tat->prev = last;\n}\n\n/**\n * list_splice - join two lists\n * @list: the new list to add.\n * @head: the place to add it in the first list.\n */\nstatic inline void list_splice(struct list_head *list, struct list_head *head)\n{\n\tif (!list_empty(list))\n\t\t_list_splice(list, head);\n}\n\n/**\n * list_splice_init - join two lists and reinitialize the emptied list.\n * @list: the new list to add.\n * @head: the place to add it in the first list.\n *\n * The list at @list is reinitialized\n */\nstatic inline void list_splice_init(struct list_head *list,\n\t\t\t\t    struct list_head *head)\n{\n\tif (!list_empty(list)) {\n\t\t_list_splice(list, head);\n\t\tlist_init(list);\n\t}\n}\n\n/**\n * list_entry - get the struct for this entry\n * @ptr:\tthe &struct list_head pointer.\n * @type:\tthe type of the struct this is embedded in.\n * @member:\tthe name of the list_struct within the struct.\n */\n#define list_entry(ptr, type, member) \\\n\tcontainer_of(ptr, type, member)\n\n/**\n * list_for_each\t-\titerate over a list\n * @pos:\tthe &struct list_head to use as a loop counter.\n * @head:\tthe head for your list.\n */\n#define list_for_each(pos, head) \\\n\tfor (pos = (head)->next, prefetch(pos->next); pos != (head); \\\n\t\tpos = pos->next, prefetch(pos->next))\n\n/**\n * _list_for_each\t-\titerate over a list\n * @pos:\tthe &struct list_head to use as a loop counter.\n * @head:\tthe head for your list.\n *\n * This variant differs from list_for_each() in that it's the\n * simplest possible list iteration code, no prefetching is done.\n * Use this for code that knows the list to be very short (empty\n * or 1 entry) most of the time.\n */\n#define _list_for_each(pos, head) \\\n\tfor (pos = (head)->next; pos != (head); pos = pos->next)\n\n/**\n * list_for_each_prev\t-\titerate over a list backwards\n * @pos:\tthe &struct list_head to use as a loop counter.\n * @head:\tthe head for your list.\n */\n#define list_for_each_prev(pos, head) \\\n\tfor (pos = (head)->prev, prefetch(pos->prev); pos != (head); \\\n\t\tpos = pos->prev, prefetch(pos->prev))\n\n/**\n * list_for_each_safe\t-\titerate over a list safe against removal of list entry\n * @pos:\tthe &struct list_head to use as a loop counter.\n * @n:\t\tanother &struct list_head to use as temporary storage\n * @head:\tthe head for your list.\n */\n#define list_for_each_safe(pos, n, head) \\\n\tfor (pos = (head)->next, n = pos->next; pos != (head); \\\n\t\tpos = n, n = pos->next)\n\n/**\n * list_for_each_entry\t-\titerate over list of given type\n * @pos:\tthe type * to use as a loop counter.\n * @head:\tthe head for your list.\n * @member:\tthe name of the list_struct within the struct.\n */\n#define list_for_each_entry(pos, head, member)\t\t\t\t\\\n\tfor (pos = list_entry((head)->next, __typeof__(*pos), member),\t\\\n\t\t     prefetch(pos->member.next);\t\t\t\\\n\t     &pos->member != (head); \t\t\t\t\t\\\n\t     pos = list_entry(pos->member.next, __typeof__(*pos), member),\t\\\n\t\t     prefetch(pos->member.next))\n\n/**\n * list_for_each_entry_reverse - iterate backwards over list of given type.\n * @pos:\tthe type * to use as a loop counter.\n * @head:\tthe head for your list.\n * @member:\tthe name of the list_struct within the struct.\n */\n#define list_for_each_entry_reverse(pos, head, member)\t\t\t\\\n\tfor (pos = list_entry((head)->prev, __typeof__(*pos), member),\t\\\n\t\t     prefetch(pos->member.prev);\t\t\t\\\n\t     &pos->member != (head); \t\t\t\t\t\\\n\t     pos = list_entry(pos->member.prev, __typeof__(*pos), member),\t\\\n\t\t     prefetch(pos->member.prev))\n\n/**\n * list_prepare_entry - prepare a pos entry for use as a start point in\n *\t\t\tlist_for_each_entry_continue\n * @pos:\tthe type * to use as a start point\n * @head:\tthe head of the list\n * @member:\tthe name of the list_struct within the struct.\n */\n#define list_prepare_entry(pos, head, member) \\\n\t((pos) ? : list_entry(head, __typeof__(*pos), member))\n\n/**\n * list_for_each_entry_continue -\titerate over list of given type\n *\t\t\tcontinuing after existing point\n * @pos:\tthe type * to use as a loop counter.\n * @head:\tthe head for your list.\n * @member:\tthe name of the list_struct within the struct.\n */\n#define list_for_each_entry_continue(pos, head, member) \t\t\\\n\tfor (pos = list_entry(pos->member.next, __typeof__(*pos), member),\t\\\n\t\t     prefetch(pos->member.next);\t\t\t\\\n\t     &pos->member != (head);\t\t\t\t\t\\\n\t     pos = list_entry(pos->member.next, __typeof__(*pos), member),\t\\\n\t\t     prefetch(pos->member.next))\n\n/**\n * list_for_each_entry_safe - iterate over list of given type safe against removal of list entry\n * @pos:\tthe type * to use as a loop counter.\n * @n:\t\tanother type * to use as temporary storage\n * @head:\tthe head for your list.\n * @member:\tthe name of the list_struct within the struct.\n */\n#define list_for_each_entry_safe(pos, n, head, member)\t\t\t\\\n\tfor (pos = list_entry((head)->next, __typeof__(*pos), member),\t\\\n\t\tn = list_entry(pos->member.next, __typeof__(*pos), member);\t\\\n\t     &pos->member != (head); \t\t\t\t\t\\\n\t     pos = n, n = list_entry(n->member.next, __typeof__(*n), member))\n\n\n/**\n * list_len - get the length of a list\n * @list: the list to measure\n */\nstatic inline size_t list_len(struct list_head *list)\n{\n\tsize_t len = 0;\n\tstruct list_head *pos;\n\tlist_for_each(pos, list)\n\t\tlen++;\n\treturn len;\n}\n\n#endif\n"
        },
        {
          "name": "load_dir.c",
          "type": "blob",
          "size": 2.3212890625,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"load_dir.h\"\n#include \"xmalloc.h\"\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <errno.h>\n\nint dir_open(struct directory *dir, const char *name)\n{\n\tint len = strlen(name);\n\n\tif (len >= sizeof(dir->path) - 2) {\n\t\terrno = ENAMETOOLONG;\n\t\treturn -1;\n\t}\n\n\tdir->d = opendir(name);\n\tif (!dir->d)\n\t\treturn -1;\n\n\tmemcpy(dir->path, name, len);\n\tdir->path[len++] = '/';\n\tdir->path[len] = 0;\n\tdir->len = len;\n\treturn 0;\n}\n\nvoid dir_close(struct directory *dir)\n{\n\tclosedir(dir->d);\n}\n\nconst char *dir_read(struct directory *dir)\n{\n\tDIR *d = dir->d;\n\tint len = dir->len;\n\tchar *full = dir->path;\n\tstruct dirent *de;\n\n#if defined(__CYGWIN__)\n\t/* Fix for cygwin \"hang\" bug when browsing /\n\t * Windows treats // as a network path.\n\t */\n\tif (strcmp(full, \"//\") == 0)\n\t\tfull++;\n#endif\n\n\twhile ((de = (struct dirent *) readdir(d))) {\n\t\tconst char *name = de->d_name;\n\t\tint nlen = strlen(name);\n\n\t\t/* just ignore too long paths\n\t\t * + 2 -> space for \\0 or / and \\0\n\t\t */\n\t\tif (len + nlen + 2 >= sizeof(dir->path))\n\t\t\tcontinue;\n\n\t\tmemcpy(full + len, name, nlen + 1);\n\t\tif (lstat(full, &dir->st))\n\t\t\tcontinue;\n\n\t\tdir->is_link = 0;\n\t\tif (S_ISLNK(dir->st.st_mode)) {\n\t\t\t/* argh. must stat the target */\n\t\t\tif (stat(full, &dir->st))\n\t\t\t\tcontinue;\n\t\t\tdir->is_link = 1;\n\t\t}\n\n\t\treturn full + len;\n\t}\n\treturn NULL;\n}\n\nvoid ptr_array_add(struct ptr_array *array, void *ptr)\n{\n\tvoid **ptrs = array->ptrs;\n\tint alloc = array->alloc;\n\n\tif (alloc == array->count) {\n\t\talloc = alloc * 3 / 2 + 16;\n\t\tptrs = xrealloc(ptrs, alloc * sizeof(void *));\n\t\tarray->ptrs = ptrs;\n\t\tarray->alloc = alloc;\n\t}\n\tptrs[array->count++] = ptr;\n}\n"
        },
        {
          "name": "load_dir.h",
          "type": "blob",
          "size": 2.28515625,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_LOAD_DIR_H\n#define CMUS_LOAD_DIR_H\n\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <dirent.h>\n\nstruct directory {\n\tDIR *d;\n\tint len;\n\t/* we need stat information for symlink targets */\n\tint is_link;\n\t/* stat() information. ie. for the symlink target */\n\tstruct stat st;\n\tchar path[1024];\n};\n\nint dir_open(struct directory *dir, const char *name);\nvoid dir_close(struct directory *dir);\nconst char *dir_read(struct directory *dir);\n\n\nstruct ptr_array {\n\t/* allocated with malloc(). contains pointers */\n\tvoid *ptrs;\n\tint alloc;\n\tint count;\n};\n\n/* ptr_array.ptrs is either char ** or struct dir_entry ** */\nstruct dir_entry {\n\tmode_t mode;\n\tchar name[];\n};\n\n#define PTR_ARRAY(name) struct ptr_array name = { NULL, 0, 0 }\n\nvoid ptr_array_add(struct ptr_array *array, void *ptr);\n\nstatic inline void ptr_array_plug(struct ptr_array *array)\n{\n\tptr_array_add(array, NULL);\n\tarray->count--;\n}\n\nstatic inline void ptr_array_sort(struct ptr_array *array,\n\t\tint (*cmp)(const void *a, const void *b))\n{\n\tint count = array->count;\n\tif (count)\n\t\tqsort(array->ptrs, count, sizeof(void *), cmp);\n}\n\nstatic inline void ptr_array_unique(struct ptr_array *array,\n\t\tint (*cmp)(const void *a, const void *b))\n{\n\tvoid **ptrs = array->ptrs;\n\tint i, j = 0;\n\n\tfor (i = 1; i < array->count; i++) {\n\t\tif (cmp(&ptrs[i-1], &ptrs[i]) != 0)\n\t\t\tptrs[j++] = ptrs[i];\n\t}\n\tarray->count = j;\n}\n\nstatic inline void ptr_array_clear(struct ptr_array *array)\n{\n\tvoid **ptrs = array->ptrs;\n\n\tfor (int i = 0; i != array->count; i++) {\n\t\tfree(ptrs[i]);\n\t}\n\tfree(ptrs);\n\tarray->ptrs = NULL;\n\tarray->alloc = 0;\n\tarray->count = 0;\n}\n\n#endif\n"
        },
        {
          "name": "locking.c",
          "type": "blob",
          "size": 2.8466796875,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"locking.h\"\n#include \"debug.h\"\n\n#include <string.h>\n#include <stdatomic.h>\n#include <stdbool.h>\n\nstruct fifo_waiter {\n\tstruct fifo_waiter * _Atomic next;\n\tpthread_cond_t cond;\n};\n\npthread_t main_thread;\n\nvoid cmus_mutex_lock(pthread_mutex_t *mutex)\n{\n\tint rc = pthread_mutex_lock(mutex);\n\tif (unlikely(rc))\n\t\tBUG(\"error locking mutex: %s\\n\", strerror(rc));\n}\n\nvoid cmus_mutex_unlock(pthread_mutex_t *mutex)\n{\n\tint rc = pthread_mutex_unlock(mutex);\n\tif (unlikely(rc))\n\t\tBUG(\"error unlocking mutex: %s\\n\", strerror(rc));\n}\n\nvoid cmus_rwlock_rdlock(pthread_rwlock_t *lock)\n{\n\tint rc = pthread_rwlock_rdlock(lock);\n\tif (unlikely(rc))\n\t\tBUG(\"error locking mutex: %s\\n\", strerror(rc));\n}\n\nvoid cmus_rwlock_wrlock(pthread_rwlock_t *lock)\n{\n\tint rc = pthread_rwlock_wrlock(lock);\n\tif (unlikely(rc))\n\t\tBUG(\"error locking mutex: %s\\n\", strerror(rc));\n}\n\nvoid cmus_rwlock_unlock(pthread_rwlock_t *lock)\n{\n\tint rc = pthread_rwlock_unlock(lock);\n\tif (unlikely(rc))\n\t\tBUG(\"error unlocking mutex: %s\\n\", strerror(rc));\n}\n\nvoid fifo_mutex_lock(struct fifo_mutex *fifo)\n{\n\tstruct fifo_waiter self = {\n\t\t.cond = PTHREAD_COND_INITIALIZER,\n\t\t.next = ATOMIC_VAR_INIT(NULL),\n\t};\n\n\tstruct fifo_waiter *old_tail = atomic_exchange_explicit(&fifo->tail, &self,\n\t\t\tmemory_order_relaxed);\n\tif (old_tail)\n\t\tatomic_store_explicit(&old_tail->next, &self, memory_order_release);\n\n\tcmus_mutex_lock(&fifo->mutex);\n\tif (old_tail) {\n\t\twhile (fifo->head != &self)\n\t\t\tpthread_cond_wait(&self.cond, &fifo->mutex);\n\t\tpthread_cond_destroy(&self.cond);\n\t}\n\n\tstruct fifo_waiter *self_addr = &self;\n\tbool was_tail = atomic_compare_exchange_strong_explicit(&fifo->tail, &self_addr,\n\t\t\tNULL, memory_order_relaxed, memory_order_relaxed);\n\tstruct fifo_waiter *next = NULL;\n\tif (!was_tail) {\n\t\twhile (!(next = atomic_load_explicit(&self.next, memory_order_consume)))\n\t\t\t;\n\t}\n\tfifo->head = next;\n}\n\nvoid fifo_mutex_unlock(struct fifo_mutex *fifo)\n{\n\tif (fifo->head)\n\t\tpthread_cond_signal(&fifo->head->cond);\n\tcmus_mutex_unlock(&fifo->mutex);\n}\n\nvoid fifo_mutex_yield(struct fifo_mutex *fifo)\n{\n\tif (fifo->head || atomic_load_explicit(&fifo->tail, memory_order_relaxed)) {\n\t\tfifo_mutex_unlock(fifo);\n\t\tfifo_mutex_lock(fifo);\n\t}\n}\n"
        },
        {
          "name": "locking.h",
          "type": "blob",
          "size": 1.6025390625,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_LOCKING_H\n#define CMUS_LOCKING_H\n\n#include <pthread.h>\n#include <stdatomic.h>\n\nstruct fifo_mutex {\n\tstruct fifo_waiter * _Atomic tail;\n\tstruct fifo_waiter *head;\n\tpthread_mutex_t mutex;\n};\n\nextern pthread_t main_thread;\n\n#define CMUS_MUTEX_INITIALIZER PTHREAD_MUTEX_INITIALIZER\n#define CMUS_COND_INITIALIZER PTHREAD_COND_INITIALIZER\n#define CMUS_RWLOCK_INITIALIZER PTHREAD_RWLOCK_INITIALIZER\n\n#define FIFO_MUTEX_INITIALIZER { \\\n\t\t.mutex = PTHREAD_MUTEX_INITIALIZER, \\\n\t\t.tail = ATOMIC_VAR_INIT(NULL), \\\n\t}\n\nvoid cmus_mutex_lock(pthread_mutex_t *mutex);\nvoid cmus_mutex_unlock(pthread_mutex_t *mutex);\nvoid cmus_rwlock_rdlock(pthread_rwlock_t *lock);\nvoid cmus_rwlock_wrlock(pthread_rwlock_t *lock);\nvoid cmus_rwlock_unlock(pthread_rwlock_t *lock);\n\nvoid fifo_mutex_lock(struct fifo_mutex *fifo);\nvoid fifo_mutex_unlock(struct fifo_mutex *fifo);\nvoid fifo_mutex_yield(struct fifo_mutex *fifo);\n\n#endif\n"
        },
        {
          "name": "main.c",
          "type": "blob",
          "size": 8.7138671875,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2005-2006 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"misc.h\"\n#include \"prog.h\"\n#include \"file.h\"\n#include \"path.h\"\n#include \"xmalloc.h\"\n#include \"utils.h\"\n\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <errno.h>\n\nstatic int sock;\nstatic int raw_args = 0;\nstatic char *passwd;\n\nstatic int read_answer(void)\n{\n\tchar buf[8192];\n\tint got_nl = 0;\n\tint len = 0;\n\n\twhile (1) {\n\t\tint rc = read(sock, buf, sizeof(buf));\n\n\t\tif (rc < 0) {\n\t\t\twarn_errno(\"read\");\n\t\t\tbreak;\n\t\t}\n\t\tif (!rc)\n\t\t\tdie(\"unexpected EOF\\n\");\n\n\t\tlen += rc;\n\n\t\t// Last line should be empty (i.e. read \"\\n\" or \"...\\n\\n\").\n\t\t// Write everything but the last \\n to stdout.\n\t\tif (got_nl && buf[0] == '\\n')\n\t\t\tbreak;\n\t\tif (len == 1 && buf[0] == '\\n')\n\t\t\tbreak;\n\t\tif (rc > 1 && buf[rc - 1] == '\\n' && buf[rc - 2] == '\\n') {\n\t\t\twrite_all(1, buf, rc - 1);\n\t\t\tbreak;\n\t\t}\n\t\tgot_nl = buf[rc - 1] == '\\n';\n\t\twrite_all(1, buf, rc);\n\t}\n\treturn len;\n}\n\nstatic int write_line(const char *line)\n{\n\tif (write_all(sock, line, strlen(line)) == -1)\n\t\tdie_errno(\"write\");\n\n\treturn read_answer();\n}\n\nstatic int send_cmd(const char *format, ...)\n{\n\tchar buf[512];\n\tva_list ap;\n\n\tva_start(ap, format);\n\tvsnprintf(buf, sizeof(buf), format, ap);\n\tva_end(ap);\n\n\treturn write_line(buf);\n}\n\nstatic int remote_connect(const char *address)\n{\n\tunion {\n\t\tstruct sockaddr sa;\n\t\tstruct sockaddr_un un;\n\t\tstruct sockaddr_storage sas;\n\t} addr;\n\tsize_t addrlen;\n\n\tif (strchr(address, '/')) {\n\t\tif (passwd)\n\t\t\twarn(\"password ignored for unix connections\\n\");\n\t\tpasswd = NULL;\n\n\t\taddr.sa.sa_family = AF_UNIX;\n\t\tstrncpy(addr.un.sun_path, address, sizeof(addr.un.sun_path) - 1);\n\n\t\taddrlen = sizeof(addr.un);\n\t} else {\n\t\tconst struct addrinfo hints = {\n\t\t\t.ai_socktype = SOCK_STREAM\n\t\t};\n\t\tconst char *port = STRINGIZE(DEFAULT_PORT);\n\t\tstruct addrinfo *result;\n\t\tchar *s = strrchr(address, ':');\n\t\tint rc;\n\n\t\tif (!passwd)\n\t\t\tdie(\"password required for tcp/ip connection\\n\");\n\n\t\tif (s) {\n\t\t\t*s++ = 0;\n\t\t\tport = s;\n\t\t}\n\n\t\trc = getaddrinfo(address, port, &hints, &result);\n\t\tif (rc != 0)\n\t\t\tdie(\"getaddrinfo: %s\\n\", gai_strerror(rc));\n\t\tmemcpy(&addr.sa, result->ai_addr, result->ai_addrlen);\n\t\taddrlen = result->ai_addrlen;\n\t\tfreeaddrinfo(result);\n\t}\n\n\tsock = socket(addr.sa.sa_family, SOCK_STREAM, 0);\n\tif (sock == -1)\n\t\tdie_errno(\"socket\");\n\n\tif (connect(sock, &addr.sa, addrlen)) {\n\t\tif (errno == ENOENT || errno == ECONNREFUSED) {\n\t\t\t/* \"cmus-remote -C\" can be used to check if cmus is running */\n\t\t\tif (!raw_args)\n\t\t\t\twarn(\"cmus is not running\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tdie_errno(\"connect\");\n\t}\n\n\tif (passwd)\n\t\treturn send_cmd(\"passwd %s\\n\", passwd) == 1;\n\treturn 1;\n}\n\nstatic char *file_url_absolute(const char *str)\n{\n\tchar *absolute;\n\n\tif (strncmp(str, \"http://\", 7) == 0)\n\t\treturn xstrdup(str);\n\n\tabsolute = path_absolute(str);\n\tif (absolute == NULL)\n\t\tdie_errno(\"get_current_dir_name\");\n\treturn absolute;\n}\n\nenum flags {\n\tFLAG_SERVER,\n\tFLAG_PASSWD,\n\tFLAG_HELP,\n\tFLAG_VERSION,\n\n\tFLAG_PLAY,\n\tFLAG_PAUSE,\n\tFLAG_PAUSE_PLAYBACK,\n\tFLAG_STOP,\n\tFLAG_NEXT,\n\tFLAG_PREV,\n\tFLAG_FILE,\n\tFLAG_REPEAT,\n\tFLAG_SHUFFLE,\n\tFLAG_VOLUME,\n\tFLAG_SEEK,\n\tFLAG_QUERY,\n\n\tFLAG_LIBRARY,\n\tFLAG_PLAYLIST,\n\tFLAG_QUEUE,\n\tFLAG_CLEAR,\n\n\tFLAG_RAW\n#define NR_FLAGS (FLAG_RAW + 1)\n};\n\nstatic struct option options[NR_FLAGS + 1] = {\n\t{ 0, \"server\", 1 },\n\t{ 0, \"passwd\", 1 },\n\t{ 0, \"help\", 0 },\n\t{ 0, \"version\", 0 },\n\n\t{ 'p', \"play\", 0 },\n\t{ 'u', \"pause\", 0 },\n\t{ 'U', \"pause-playback\", 0 },\n\t{ 's', \"stop\", 0 },\n\t{ 'n', \"next\", 0 },\n\t{ 'r', \"prev\", 0 },\n\t{ 'f', \"file\", 1 },\n\t{ 'R', \"repeat\", 0 },\n\t{ 'S', \"shuffle\", 0 },\n\t{ 'v', \"volume\", 1 },\n\t{ 'k', \"seek\", 1 },\n\t{ 'Q', \"query\", 0 },\n\n\t{ 'l', \"library\", 0 },\n\t{ 'P', \"playlist\", 0 },\n\t{ 'q', \"queue\", 0 },\n\t{ 'c', \"clear\", 0 },\n\n\t{ 'C', \"raw\", 0 },\n\t{ 0, NULL, 0 }\n};\n\nstatic int flags[NR_FLAGS] = { 0, };\n\nstatic const char *usage =\n\"Usage: %s [OPTION]... [FILE|DIR|PLAYLIST]...\\n\"\n\"   or: %s -C COMMAND...\\n\"\n\"   or: %s\\n\"\n\"Control cmus through socket.\\n\"\n\"\\n\"\n\"      --server ADDR    connect using ADDR instead of $CMUS_SOCKET or $XDG_RUNTIME_DIR/cmus-socket\\n\"\n\"                       ADDR is either a UNIX socket or host[:port]\\n\"\n\"                       WARNING: using TCP/IP is insecure!\\n\"\n\"      --passwd PASSWD  password to use for TCP/IP connection\\n\"\n\"      --help           display this help and exit\\n\"\n\"      --version        \" VERSION \"\\n\"\n\"\\n\"\n\"Cooked mode:\\n\"\n\"  -p, --play           player-play\\n\"\n\"  -u, --pause          player-pause\\n\"\n\"  -U, --pause-playback player-pause-playback\\n\"\n\"  -s, --stop           player-stop\\n\"\n\"  -n, --next           player-next\\n\"\n\"  -r, --prev           player-prev\\n\"\n\"  -f, --file           player-play FILE\\n\"\n\"  -R, --repeat         toggle repeat\\n\"\n\"  -S, --shuffle        toggle shuffle\\n\"\n\"  -v, --volume VOL     vol VOL\\n\"\n\"  -k, --seek SEEK      seek SEEK\\n\"\n\"  -Q, --query          get player status (same as -C status)\\n\"\n\"\\n\"\n\"  -l, --library        modify library instead of playlist\\n\"\n\"  -P, --playlist       modify playlist (default)\\n\"\n\"  -q, --queue          modify play queue instead of playlist\\n\"\n\"  -c, --clear          clear playlist, library (-l) or play queue (-q)\\n\"\n\"\\n\"\n\"  Add FILE/DIR/PLAYLIST to playlist, library (-l) or play queue (-q).\\n\"\n\"\\n\"\n\"Raw mode:\\n\"\n\"  -C, --raw            treat arguments (instead of stdin) as raw commands\\n\"\n\"\\n\"\n\"  By default cmus-remote reads raw commands from stdin (one command per line).\\n\"\n\"\\n\"\n\"Report bugs to <cmus-devel@lists.sourceforge.net>.\\n\";\n\nint main(int argc, char *argv[])\n{\n\tchar *server = NULL;\n\tchar *play_file = NULL;\n\tchar *volume = NULL;\n\tchar *seek = NULL;\n\tint query = 0;\n\tint i, nr_cmds = 0;\n\tint context = 'p';\n\n\tprogram_name = argv[0];\n\targv++;\n\twhile (1) {\n\t\tint idx;\n\t\tchar *arg;\n\n\t\tidx = get_option(&argv, options, &arg);\n\t\tif (idx < 0)\n\t\t\tbreak;\n\n\t\tflags[idx] = 1;\n\t\tswitch ((enum flags)idx) {\n\t\tcase FLAG_HELP:\n\t\t\tprintf(usage, program_name, program_name, program_name);\n\t\t\treturn 0;\n\t\tcase FLAG_VERSION:\n\t\t\tprintf(\"cmus \" VERSION\n\t\t\t       \"\\nCopyright 2004-2006 Timo Hirvonen\"\n\t\t\t       \"\\nCopyright 2008-2016 Various Authors\\n\");\n\t\t\treturn 0;\n\t\tcase FLAG_SERVER:\n\t\t\tserver = arg;\n\t\t\tbreak;\n\t\tcase FLAG_PASSWD:\n\t\t\tpasswd = arg;\n\t\t\tbreak;\n\t\tcase FLAG_VOLUME:\n\t\t\tvolume = arg;\n\t\t\tnr_cmds++;\n\t\t\tbreak;\n\t\tcase FLAG_SEEK:\n\t\t\tseek = arg;\n\t\t\tnr_cmds++;\n\t\t\tbreak;\n\t\tcase FLAG_QUERY:\n\t\t\tquery = 1;\n\t\t\tnr_cmds++;\n\t\t\tbreak;\n\t\tcase FLAG_FILE:\n\t\t\tplay_file = arg;\n\t\t\tnr_cmds++;\n\t\t\tbreak;\n\t\tcase FLAG_LIBRARY:\n\t\t\tcontext = 'l';\n\t\t\tbreak;\n\t\tcase FLAG_PLAYLIST:\n\t\t\tcontext = 'p';\n\t\t\tbreak;\n\t\tcase FLAG_QUEUE:\n\t\t\tcontext = 'q';\n\t\t\tbreak;\n\t\tcase FLAG_PLAY:\n\t\tcase FLAG_PAUSE:\n\t\tcase FLAG_PAUSE_PLAYBACK:\n\t\tcase FLAG_STOP:\n\t\tcase FLAG_NEXT:\n\t\tcase FLAG_PREV:\n\t\tcase FLAG_REPEAT:\n\t\tcase FLAG_SHUFFLE:\n\t\tcase FLAG_CLEAR:\n\t\t\tnr_cmds++;\n\t\t\tbreak;\n\t\tcase FLAG_RAW:\n\t\t\traw_args = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (nr_cmds && raw_args)\n\t\tdie(\"don't mix raw and cooked stuff\\n\");\n\n\tmisc_init();\n\tif (server == NULL)\n\t\tserver = xstrdup(cmus_socket_path);\n\n\tif (!remote_connect(server))\n\t\treturn 1;\n\n\tif (raw_args) {\n\t\twhile (*argv)\n\t\t\tsend_cmd(\"%s\\n\", *argv++);\n\t\treturn 0;\n\t}\n\n\tif (nr_cmds == 0 && argv[0] == NULL) {\n\t\tchar line[512];\n\n\t\twhile (fgets(line, sizeof(line), stdin))\n\t\t\twrite_line(line);\n\t\treturn 0;\n\t}\n\n\tif (flags[FLAG_CLEAR])\n\t\tsend_cmd(\"clear -%c\\n\", context);\n\tfor (i = 0; argv[i]; i++) {\n\t\tchar *filename = file_url_absolute(argv[i]);\n\n\t\tsend_cmd(\"add -%c %s\\n\", context, filename);\n\t\tfree(filename);\n\t}\n\tif (flags[FLAG_REPEAT])\n\t\tsend_cmd(\"toggle repeat\\n\");\n\tif (flags[FLAG_SHUFFLE])\n\t\tsend_cmd(\"toggle shuffle\\n\");\n\tif (flags[FLAG_STOP])\n\t\tsend_cmd(\"player-stop\\n\");\n\tif (flags[FLAG_NEXT])\n\t\tsend_cmd(\"player-next\\n\");\n\tif (flags[FLAG_PREV])\n\t\tsend_cmd(\"player-prev\\n\");\n\tif (flags[FLAG_PLAY])\n\t\tsend_cmd(\"player-play\\n\");\n\tif (flags[FLAG_PAUSE])\n\t\tsend_cmd(\"player-pause\\n\");\n\tif (flags[FLAG_PAUSE_PLAYBACK])\n\t\tsend_cmd(\"player-pause-playback\\n\");\n\tif (flags[FLAG_FILE])\n\t\tsend_cmd(\"player-play %s\\n\", file_url_absolute(play_file));\n\tif (volume)\n\t\tsend_cmd(\"vol %s\\n\", volume);\n\tif (seek)\n\t\tsend_cmd(\"seek %s\\n\", seek);\n\tif (query)\n\t\tsend_cmd(\"status\\n\");\n\treturn 0;\n}\n"
        },
        {
          "name": "mergesort.c",
          "type": "blob",
          "size": 1.8984375,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"mergesort.h\"\n#include \"list.h\"\n\nvoid list_mergesort(struct list_head *head,\n\tint (*compare)(const struct list_head *, const struct list_head *))\n{\n\tLIST_HEAD(empty);\n\tstruct list_head *unsorted_head, *sorted_head, *p, *q, *tmp;\n\tint psize, qsize, K, count;\n\n\tif (list_empty(head))\n\t\treturn;\n\n\tunsorted_head = head;\n\tsorted_head = &empty;\n\tK = 1;\n\twhile (1) {\n\t\tp = unsorted_head->next;\n\t\tcount = 0;\n\t\tdo {\n\t\t\tq = p;\n\t\t\tpsize = 0;\n\t\t\twhile (psize < K) {\n\t\t\t\tif (q == unsorted_head)\n\t\t\t\t\tbreak;\n\t\t\t\tpsize++;\n\t\t\t\tq = q->next;\n\t\t\t}\n\t\t\tqsize = K;\n\t\t\twhile (1) {\n\t\t\t\tstruct list_head *e;\n\n\t\t\t\tif (q == unsorted_head)\n\t\t\t\t\tqsize = 0;\n\t\t\t\tif (psize == 0 && qsize == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tif (!psize || (qsize && compare(p, q) > 0)) {\n\t\t\t\t\te = q;\n\t\t\t\t\tq = q->next;\n\t\t\t\t\tqsize--;\n\t\t\t\t} else {\n\t\t\t\t\te = p;\n\t\t\t\t\tp = p->next;\n\t\t\t\t\tpsize--;\n\t\t\t\t}\n\t\t\t\tlist_del(e);\n\t\t\t\tlist_add_tail(e, sorted_head);\n\t\t\t}\n\t\t\tcount++;\n\t\t\tp = q;\n\t\t} while (p != unsorted_head);\n\n\t\tif (count == 1) {\n\t\t\thead->next = sorted_head->next;\n\t\t\thead->prev = sorted_head->prev;\n\t\t\tsorted_head->prev->next = head;\n\t\t\tsorted_head->next->prev = head;\n\t\t\treturn;\n\t\t}\n\t\ttmp = unsorted_head;\n\t\tunsorted_head = sorted_head;\n\t\tsorted_head = tmp;\n\t\tK *= 2;\n\t}\n}\n"
        },
        {
          "name": "mergesort.h",
          "type": "blob",
          "size": 0.8974609375,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_MERGESORT_H\n#define CMUS_MERGESORT_H\n\n#include \"list.h\"\n\nvoid list_mergesort(struct list_head *head,\n\tint (*compare)(const struct list_head *, const struct list_head *));\n\n#endif\n"
        },
        {
          "name": "misc.c",
          "type": "blob",
          "size": 7.4453125,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004-2005 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"misc.h\"\n#include \"prog.h\"\n#include \"xmalloc.h\"\n#include \"xstrjoin.h\"\n#include \"ui_curses.h\"\n#include \"config/libdir.h\"\n#include \"config/datadir.h\"\n\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <dirent.h>\n#include <stdarg.h>\n#include <pwd.h>\n\nconst char *cmus_config_dir = NULL;\nconst char *cmus_playlist_dir = NULL;\nconst char *cmus_socket_path = NULL;\nconst char *cmus_data_dir = NULL;\nconst char *cmus_lib_dir = NULL;\nconst char *home_dir = NULL;\n\nchar **get_words(const char *text)\n{\n\tchar **words;\n\tint i, j, count;\n\n\twhile (*text == ' ')\n\t\ttext++;\n\n\tcount = 0;\n\ti = 0;\n\twhile (text[i]) {\n\t\tcount++;\n\t\twhile (text[i] && text[i] != ' ')\n\t\t\ti++;\n\t\twhile (text[i] == ' ')\n\t\t\ti++;\n\t}\n\twords = xnew(char *, count + 1);\n\n\ti = 0;\n\tj = 0;\n\twhile (text[i]) {\n\t\tint start = i;\n\n\t\twhile (text[i] && text[i] != ' ')\n\t\t\ti++;\n\t\twords[j++] = xstrndup(text + start, i - start);\n\t\twhile (text[i] == ' ')\n\t\t\ti++;\n\t}\n\twords[j] = NULL;\n\treturn words;\n}\n\nint strptrcmp(const void *a, const void *b)\n{\n\tconst char *as = *(char **)a;\n\tconst char *bs = *(char **)b;\n\n\treturn strcmp(as, bs);\n}\n\nint strptrcoll(const void *a, const void *b)\n{\n\tconst char *as = *(char **)a;\n\tconst char *bs = *(char **)b;\n\n\treturn strcoll(as, bs);\n}\n\nconst char *escape(const char *str)\n{\n\tstatic char *buf = NULL;\n\tstatic size_t alloc = 0;\n\tsize_t len = strlen(str);\n\tsize_t need = len * 2 + 1;\n\tint s, d;\n\n\tif (need > alloc) {\n\t\talloc = (need + 16) & ~(16 - 1);\n\t\tbuf = xrealloc(buf, alloc);\n\t}\n\n\td = 0;\n\tfor (s = 0; str[s]; s++) {\n\t\tif (str[s] == '\\\\') {\n\t\t\tbuf[d++] = '\\\\';\n\t\t\tbuf[d++] = '\\\\';\n\t\t\tcontinue;\n\t\t}\n\t\tif (str[s] == '\\n') {\n\t\t\tbuf[d++] = '\\\\';\n\t\t\tbuf[d++] = 'n';\n\t\t\tcontinue;\n\t\t}\n\t\tbuf[d++] = str[s];\n\t}\n\tbuf[d] = 0;\n\treturn buf;\n}\n\nconst char *unescape(const char *str)\n{\n\tstatic char *buf = NULL;\n\tstatic size_t alloc = 0;\n\tsize_t need = strlen(str) + 1;\n\tint do_escape = 0;\n\tint s, d;\n\n\tif (need > alloc) {\n\t\talloc = (need + 16) & ~(16 - 1);\n\t\tbuf = xrealloc(buf, alloc);\n\t}\n\n\td = 0;\n\tfor (s = 0; str[s]; s++) {\n\t\tif (!do_escape && str[s] == '\\\\')\n\t\t\tdo_escape = 1;\n\t\telse {\n\t\t\tbuf[d++] = (do_escape && str[s] == 'n') ? '\\n' : str[s];\n\t\t\tdo_escape = 0;\n\t\t}\n\t}\n\tbuf[d] = 0;\n\treturn buf;\n}\n\nstatic int dir_exists(const char *dirname)\n{\n\tDIR *dir;\n\n\tdir = opendir(dirname);\n\tif (dir == NULL) {\n\t\tif (errno == ENOENT)\n\t\t\treturn 0;\n\t\treturn -1;\n\t}\n\tclosedir(dir);\n\treturn 1;\n}\n\nstatic void make_dir(const char *dirname)\n{\n\tint rc;\n\n\trc = dir_exists(dirname);\n\tif (rc == 1)\n\t\treturn;\n\tif (rc == -1)\n\t\tdie_errno(\"error: opening `%s'\", dirname);\n\trc = mkdir(dirname, 0700);\n\tif (rc == -1)\n\t\tdie_errno(\"error: creating directory `%s'\", dirname);\n}\n\nstatic char *get_non_empty_env(const char *name)\n{\n\tconst char *val;\n\n\tval = getenv(name);\n\tif (val == NULL || val[0] == 0)\n\t\treturn NULL;\n\treturn xstrdup(val);\n}\n\nconst char *get_filename(const char *path)\n{\n\tconst char *file = strrchr(path, '/');\n\tif (!file)\n\t\tfile = path;\n\telse\n\t\tfile++;\n\tif (!*file)\n\t\treturn NULL;\n\treturn file;\n}\n\nstatic void move_old_playlist(void)\n{\n\tchar *default_playlist = xstrjoin(cmus_playlist_dir, \"/Default\");\n\tchar *old_playlist = xstrjoin(cmus_config_dir, \"/playlist.pl\");\n\tint rc = rename(old_playlist, default_playlist);\n\tif (rc && errno != ENOENT)\n\t\tdie_errno(\"error: unable to move %s to playlist directory\",\n\t\t\t\told_playlist);\n\tfree(default_playlist);\n\tfree(old_playlist);\n}\n\nint misc_init(void)\n{\n\tchar *xdg_runtime_dir = get_non_empty_env(\"XDG_RUNTIME_DIR\");\n\n\thome_dir = get_non_empty_env(\"HOME\");\n\tif (home_dir == NULL)\n\t\tdie(\"error: environment variable HOME not set\\n\");\n\n\tcmus_config_dir = get_non_empty_env(\"CMUS_HOME\");\n\tif (cmus_config_dir == NULL) {\n\t\tchar *cmus_home = xstrjoin(home_dir, \"/.cmus\");\n\t\tint cmus_home_exists = dir_exists(cmus_home);\n\n\t\tif (cmus_home_exists == 1) {\n\t\t\tcmus_config_dir = xstrdup(cmus_home);\n\t\t} else if (cmus_home_exists == -1) {\n\t\t\tdie_errno(\"error: opening `%s'\", cmus_home);\n\t\t} else {\n\t\t\tchar *xdg_config_home = get_non_empty_env(\"XDG_CONFIG_HOME\");\n\t\t\tif (xdg_config_home == NULL) {\n\t\t\t\txdg_config_home = xstrjoin(home_dir, \"/.config\");\n\t\t\t}\n\n\t\t\tmake_dir(xdg_config_home);\n\t\t\tcmus_config_dir = xstrjoin(xdg_config_home, \"/cmus\");\n\n\t\t\tfree(xdg_config_home);\n\t\t}\n\n\t\tfree(cmus_home);\n\t}\n\tmake_dir(cmus_config_dir);\n\n\tcmus_playlist_dir = get_non_empty_env(\"CMUS_PLAYLIST_DIR\");\n\tif (!cmus_playlist_dir)\n\t\tcmus_playlist_dir = xstrjoin(cmus_config_dir, \"/playlists\");\n\n\tint playlist_dir_is_new = dir_exists(cmus_playlist_dir) == 0;\n\tmake_dir(cmus_playlist_dir);\n\tif (playlist_dir_is_new)\n\t\tmove_old_playlist();\n\n\tcmus_socket_path = get_non_empty_env(\"CMUS_SOCKET\");\n\tif (cmus_socket_path == NULL) {\n\t\tif (xdg_runtime_dir == NULL) {\n\t\t\tcmus_socket_path = xstrjoin(cmus_config_dir, \"/socket\");\n\t\t} else {\n\t\t\tcmus_socket_path = xstrjoin(xdg_runtime_dir, \"/cmus-socket\");\n\t\t}\n\t}\n\n\tcmus_lib_dir = getenv(\"CMUS_LIB_DIR\");\n\tif (!cmus_lib_dir)\n\t\tcmus_lib_dir = LIBDIR \"/cmus\";\n\n\tcmus_data_dir = getenv(\"CMUS_DATA_DIR\");\n\tif (!cmus_data_dir)\n\t\tcmus_data_dir = DATADIR \"/cmus\";\n\n\tfree(xdg_runtime_dir);\n\treturn 0;\n}\n\nint replaygain_decode(unsigned int field, int *gain)\n{\n\tunsigned int name_code, originator_code, sign_bit, val;\n\n\tname_code = (field >> 13) & 0x7;\n\tif (!name_code || name_code > 2)\n\t\treturn 0;\n\toriginator_code = (field >> 10) & 0x7;\n\tif (!originator_code)\n\t\treturn 0;\n\tsign_bit = (field >> 9) & 0x1;\n\tval = field & 0x1ff;\n\tif (sign_bit && !val)\n\t\treturn 0;\n\t*gain = (sign_bit ? -1 : 1) * val;\n\treturn name_code;\n}\n\nstatic char *get_home_dir(const char *username)\n{\n\tstruct passwd *passwd;\n\n\tif (username == NULL)\n\t\treturn xstrdup(home_dir);\n\tpasswd = getpwnam(username);\n\tif (passwd == NULL)\n\t\treturn NULL;\n\t/* don't free passwd */\n\treturn xstrdup(passwd->pw_dir);\n}\n\nchar *expand_filename(const char *name)\n{\n\tif (name[0] == '~') {\n\t\tchar *slash;\n\n\t\tslash = strchr(name, '/');\n\t\tif (slash) {\n\t\t\tchar *username, *home;\n\n\t\t\tif (slash - name - 1 > 0) {\n\t\t\t\t/* ~user/... */\n\t\t\t\tusername = xstrndup(name + 1, slash - name - 1);\n\t\t\t} else {\n\t\t\t\t/* ~/... */\n\t\t\t\tusername = NULL;\n\t\t\t}\n\t\t\thome = get_home_dir(username);\n\t\t\tfree(username);\n\t\t\tif (home) {\n\t\t\t\tchar *expanded;\n\n\t\t\t\texpanded = xstrjoin(home, slash);\n\t\t\t\tfree(home);\n\t\t\t\treturn expanded;\n\t\t\t} else {\n\t\t\t\treturn xstrdup(name);\n\t\t\t}\n\t\t} else {\n\t\t\tif (name[1] == 0) {\n\t\t\t\treturn xstrdup(home_dir);\n\t\t\t} else {\n\t\t\t\tchar *home;\n\n\t\t\t\thome = get_home_dir(name + 1);\n\t\t\t\tif (home)\n\t\t\t\t\treturn home;\n\t\t\t\treturn xstrdup(name);\n\t\t\t}\n\t\t}\n\t} else {\n\t\treturn xstrdup(name);\n\t}\n}\n\nvoid shuffle_array(void *array, size_t n, size_t size)\n{\n\tchar tmp[size];\n\tchar *arr = array;\n\tfor (ssize_t i = 0; i < (ssize_t)n - 1; ++i) {\n\t\tsize_t rnd = (size_t) rand();\n\t\tsize_t j = i + rnd / (RAND_MAX / (n - i) + 1);\n\t\tmemcpy(tmp, arr + j * size, size);\n\t\tmemcpy(arr + j * size, arr + i * size, size);\n\t\tmemcpy(arr + i * size, tmp, size);\n\t}\n}\n"
        },
        {
          "name": "misc.h",
          "type": "blob",
          "size": 1.7265625,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_MISC_H\n#define CMUS_MISC_H\n\n#include <stddef.h>\n\nextern const char *cmus_config_dir;\nextern const char *cmus_playlist_dir;\nextern const char *cmus_socket_path;\nextern const char *cmus_data_dir;\nextern const char *cmus_lib_dir;\nextern const char *home_dir;\n\nchar **get_words(const char *text);\nint strptrcmp(const void *a, const void *b);\nint strptrcoll(const void *a, const void *b);\nint misc_init(void);\nconst char *escape(const char *str);\nconst char *unescape(const char *str);\nconst char *get_filename(const char *path);\n\n/*\n * @field   contains Replay Gain data format in bit representation\n * @gain    pointer where to store gain value * 10\n *\n * Returns 0 if @field doesn't contain a valid gain value,\n *         1 for track (= radio) adjustment\n *         2 for album (= audiophile) adjustment\n *\n * http://replaygain.hydrogenaudio.org/rg_data_format.html\n */\nint replaygain_decode(unsigned int field, int *gain);\n\nchar *expand_filename(const char *name);\nvoid shuffle_array(void *array, size_t n, size_t size);\n\n#endif\n"
        },
        {
          "name": "mixer.h",
          "type": "blob",
          "size": 1.4609375,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_MIXER_H\n#define CMUS_MIXER_H\n\n#ifndef __GNUC__\n#include <fcntl.h>\n#endif\n\n#define NR_MIXER_FDS 4\n\nenum {\n    /* volume changes */\n    MIXER_FDS_VOLUME,\n    /* output changes */\n    MIXER_FDS_OUTPUT\n};\n\nstruct mixer_plugin_ops {\n\tint (*init)(void);\n\tint (*exit)(void);\n\tint (*open)(int *volume_max);\n\tint (*close)(void);\n\tunion {\n\t    int (*abi_1)(int *fds); // MIXER_FDS_VOLUME\n\t    int (*abi_2)(int what, int *fds);\n\t} get_fds;\n\tint (*set_volume)(int l, int r);\n\tint (*get_volume)(int *l, int *r);\n};\n\nstruct mixer_plugin_opt {\n\tconst char *name;\n\tint (*set)(const char *val);\n\tint (*get)(char **val);\n};\n\n/* symbols exported by plugin */\nextern const struct mixer_plugin_ops op_mixer_ops;\nextern const struct mixer_plugin_opt op_mixer_options[];\n\n#endif\n"
        },
        {
          "name": "mpris.c",
          "type": "blob",
          "size": 16.384765625,
          "content": "/*\n * Copyright 2016 Various Authors\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifdef CONFIG_MPRIS_BASU\n#include <basu/sd-bus.h>\n#else\n#include <systemd/sd-bus.h>\n#endif\n\n#include \"mpris.h\"\n#include \"ui_curses.h\"\n#include \"cmus.h\"\n#include \"player.h\"\n#include \"options.h\"\n#include \"output.h\"\n#include \"track_info.h\"\n#include \"utils.h\"\n#include \"uchar.h\"\n#include \"path.h\"\n\n#define CK(v) \\\ndo { \\\n\tint tmp = (v); \\\n\tif (tmp < 0) \\\n\t\treturn tmp; \\\n} while (0)\n\nstatic sd_bus *bus;\nint mpris_fd = -1;\n\nstatic int mpris_msg_ignore(sd_bus_message *m, void *_userdata,\n\t\tsd_bus_error *_ret_error)\n{\n\treturn sd_bus_reply_method_return(m, \"\");\n}\n\nstatic int mpris_read_false(sd_bus *_bus, const char *_path,\n\t\tconst char *_interface, const char *_property,\n\t\tsd_bus_message *reply, void *_userdata,\n\t\tsd_bus_error *_ret_error)\n{\n\tuint32_t b = 0;\n\treturn sd_bus_message_append_basic(reply, 'b', &b);\n}\n\nstatic int mpris_read_true(sd_bus *_bus, const char *_path,\n\t\tconst char *_interface, const char *_property,\n\t\tsd_bus_message *reply, void *_userdata,\n\t\tsd_bus_error *_ret_error)\n{\n\tuint32_t b = 1;\n\treturn sd_bus_message_append_basic(reply, 'b', &b);\n}\n\nstatic int mpris_write_ignore(sd_bus *_bus, const char *_path,\n\t\tconst char *_interface, const char *_property,\n\t\tsd_bus_message *value, void *_userdata,\n\t\tsd_bus_error *_ret_error)\n{\n\treturn sd_bus_reply_method_return(value, \"\");\n}\n\nstatic int mpris_raise_vte(sd_bus_message *m, void *_userdata,\n\t\tsd_bus_error *_ret_error)\n{\n\tcmus_raise_vte();\n\treturn sd_bus_reply_method_return(m, \"\");\n}\n\nstatic int mpris_can_raise_vte(sd_bus *_bus, const char *_path,\n\t\tconst char *_interface, const char *_property,\n\t\tsd_bus_message *reply, void *_userdata,\n\t\tsd_bus_error *_ret_error)\n{\n\tuint32_t b = cmus_can_raise_vte();\n\treturn sd_bus_message_append_basic(reply, 'b', &b);\n}\n\nstatic int mpris_identity(sd_bus *_bus, const char *_path,\n\t\tconst char *_interface, const char *_property,\n\t\tsd_bus_message *reply, void *_userdata,\n\t\tsd_bus_error *_ret_error)\n{\n\tconst char *id = \"cmus\";\n\treturn sd_bus_message_append_basic(reply, 's', id);\n}\n\nstatic int mpris_uri_schemes(sd_bus *_bus, const char *_path,\n\t\tconst char *_interface, const char *_property,\n\t\tsd_bus_message *reply, void *_userdata,\n\t\tsd_bus_error *_ret_error)\n{\n\tstatic const char * const schemes[] = { \"file\", \"http\", NULL };\n\treturn sd_bus_message_append_strv(reply, (char **)schemes);\n}\n\nstatic int mpris_mime_types(sd_bus *_bus, const char *_path,\n\t\tconst char *_interface, const char *_property,\n\t\tsd_bus_message *reply, void *_userdata,\n\t\tsd_bus_error *_ret_error)\n{\n\tstatic const char * const types[] = { NULL };\n\treturn sd_bus_message_append_strv(reply, (char **)types);\n}\n\nstatic int mpris_next(sd_bus_message *m, void *_userdata,\n\t\tsd_bus_error *_ret_error)\n{\n\tcmus_next();\n\treturn sd_bus_reply_method_return(m, \"\");\n}\n\nstatic int mpris_prev(sd_bus_message *m, void *_userdata,\n\t\tsd_bus_error *_ret_error)\n{\n\tcmus_prev();\n\treturn sd_bus_reply_method_return(m, \"\");\n}\n\nstatic int mpris_pause(sd_bus_message *m, void *_userdata,\n\t\tsd_bus_error *_ret_error)\n{\n\tplayer_pause_playback();\n\treturn sd_bus_reply_method_return(m, \"\");\n}\n\nstatic int mpris_toggle_pause(sd_bus_message *m, void *_userdata,\n\t\tsd_bus_error *_ret_error)\n{\n\tplayer_pause();\n\treturn sd_bus_reply_method_return(m, \"\");\n}\n\nstatic int mpris_stop(sd_bus_message *m, void *_userdata,\n\t\tsd_bus_error *_ret_error)\n{\n\tplayer_stop();\n\treturn sd_bus_reply_method_return(m, \"\");\n}\n\nstatic int mpris_play(sd_bus_message *m, void *_userdata,\n\t\tsd_bus_error *_ret_error)\n{\n\tplayer_play();\n\treturn sd_bus_reply_method_return(m, \"\");\n}\n\nstatic int mpris_seek(sd_bus_message *m, void *_userdata,\n\t\tsd_bus_error *_ret_error)\n{\n\tint64_t val = 0;\n\tCK(sd_bus_message_read_basic(m, 'x', &val));\n\tplayer_seek(val / (1000 * 1000), 1, 0);\n\treturn sd_bus_reply_method_return(m, \"\");\n}\n\nstatic int mpris_seek_abs(sd_bus_message *m, void *_userdata,\n\t\tsd_bus_error *_ret_error)\n{\n\tchar buf[] = \"/1122334455667788\";\n\tif (player_info.ti)\n\t\tsprintf(buf, \"/%\"PRIx64, player_info.ti->uid);\n\telse\n\t\tsprintf(buf, \"/\");\n\n\tconst char *path = NULL;\n\tint64_t val = 0;\n\tCK(sd_bus_message_read_basic(m, 'o', &path));\n\tCK(sd_bus_message_read_basic(m, 'x', &val));\n\n\tif (strcmp(buf, path) == 0)\n\t\tplayer_seek(val / (1000 * 1000), 0, 0);\n\treturn sd_bus_reply_method_return(m, \"\");\n}\n\nstatic int mpris_play_file(sd_bus_message *m, void *_userdata,\n\t\tsd_bus_error *_ret_error)\n{\n\tconst char *path = NULL;\n\tCK(sd_bus_message_read_basic(m, 's', &path));\n\tcmus_play_file(path);\n\treturn sd_bus_reply_method_return(m, \"\");\n}\n\nstatic int mpris_playback_status(sd_bus *_bus, const char *_path,\n\t\tconst char *_interface, const char *_property,\n\t\tsd_bus_message *reply, void *_userdata,\n\t\tsd_bus_error *_ret_error)\n{\n\tconst char *ss[] = { \"Stopped\", \"Playing\", \"Paused\" };\n\tconst char *s = ss[player_info.status];\n\treturn sd_bus_message_append_basic(reply, 's', s);\n}\n\nstatic int mpris_loop_status(sd_bus *_bus, const char *_path,\n\t\tconst char *_interface, const char *_property,\n\t\tsd_bus_message *reply, void *_userdata,\n\t\tsd_bus_error *_ret_error)\n{\n\tconst char *t = \"None\";\n\tif (player_repeat_current)\n\t\tt = \"Track\";\n\telse if (repeat)\n\t\tt = \"Playlist\";\n\treturn sd_bus_message_append_basic(reply, 's', t);\n}\n\nstatic int mpris_set_loop_status(sd_bus *_bus, const char *_path,\n\t\tconst char *_interface, const char *_property,\n\t\tsd_bus_message *value, void *_userdata,\n\t\tsd_bus_error *_ret_error)\n{\n\tconst char *t = NULL;\n\tCK(sd_bus_message_read_basic(value, 's', &t));\n\tif (strcmp(t, \"None\") == 0) {\n\t\tplayer_repeat_current = 0;\n\t\trepeat = 0;\n\t} else if (strcmp(t, \"Track\") == 0) {\n\t\tplayer_repeat_current = 1;\n\t} else if (strcmp(t, \"Playlist\") == 0) {\n\t\tplayer_repeat_current = 0;\n\t\trepeat = 1;\n\t}\n\tupdate_statusline();\n\treturn sd_bus_reply_method_return(value, \"\");\n}\n\nstatic int mpris_rate(sd_bus *_bus, const char *_path,\n\t\tconst char *_interface, const char *_property,\n\t\tsd_bus_message *reply, void *_userdata,\n\t\tsd_bus_error *_ret_error)\n{\n\tstatic const double d = 1.0;\n\treturn sd_bus_message_append_basic(reply, 'd', &d);\n}\n\nstatic int mpris_shuffle(sd_bus *_bus, const char *_path,\n\t\tconst char *_interface, const char *_property,\n\t\tsd_bus_message *reply, void *_userdata,\n\t\tsd_bus_error *_ret_error)\n{\n\tconst uint32_t s = shuffle;\n\treturn sd_bus_message_append_basic(reply, 'b', &s);\n}\n\nstatic int mpris_set_shuffle(sd_bus *_bus, const char *_path,\n\t\tconst char *_interface, const char *_property,\n\t\tsd_bus_message *value, void *_userdata,\n\t\tsd_bus_error *_ret_error)\n{\n\tuint32_t s = 0;\n\tCK(sd_bus_message_read_basic(value, 'b', &s));\n\tshuffle = s;\n\tupdate_statusline();\n\treturn sd_bus_reply_method_return(value, \"\");\n}\n\nstatic int mpris_volume(sd_bus *_bus, const char *_path,\n\t\tconst char *_interface, const char *_property,\n\t\tsd_bus_message *reply, void *_userdata,\n\t\tsd_bus_error *_ret_error)\n{\n\tdouble vol;\n\tif (soft_vol) {\n\t\tvol = (soft_vol_l + soft_vol_r) / 200.0;\n\t} else if (volume_max && volume_l >= 0 && volume_r >= 0) {\n\t\tint vol_left = scale_to_percentage(volume_l, volume_max);\n\t\tint vol_right = scale_to_percentage(volume_r, volume_max);\n\t\tvol = (vol_left + vol_right) / 200.0;\n\t}\n\treturn sd_bus_message_append_basic(reply, 'd', &vol);\n}\n\nstatic int mpris_set_volume(sd_bus *_bus, const char *_path,\n\t\tconst char *_interface, const char *_property,\n\t\tsd_bus_message *value, void *_userdata,\n\t\tsd_bus_error *_ret_error)\n{\n\tdouble vol;\n\tCK(sd_bus_message_read_basic(value, 'd', &vol));\n\tif (vol < 0.0)\n\t\tvol = 0.0;\n\telse if (vol > 1.0)\n\t\tvol = 1.0;\n\tint ivol = vol * 100;\n\tplayer_set_vol(ivol, VF_PERCENTAGE, ivol, VF_PERCENTAGE);\n\tupdate_statusline();\n\treturn sd_bus_reply_method_return(value, \"\");\n}\n\nstatic int mpris_position(sd_bus *_bus, const char *_path,\n\t\tconst char *_interface, const char *_property,\n\t\tsd_bus_message *reply, void *_userdata,\n\t\tsd_bus_error *_ret_error)\n{\n\tint64_t pos = player_info.pos;\n\tpos *= 1000 * 1000;\n\treturn sd_bus_message_append_basic(reply, 'x', &pos);\n}\n\nstatic int mpris_msg_append_simple_dict(sd_bus_message *m, const char *tag,\n\t\tchar type, const void *val)\n{\n\tconst char s[] = { type, 0 };\n\tCK(sd_bus_message_open_container(m, 'e', \"sv\"));\n\tCK(sd_bus_message_append_basic(m, 's', tag));\n\tCK(sd_bus_message_open_container(m, 'v', s));\n\tCK(sd_bus_message_append_basic(m, type, val));\n\tCK(sd_bus_message_close_container(m));\n\tCK(sd_bus_message_close_container(m));\n\treturn 0;\n}\n\nstatic int mpris_msg_append_si_dict(sd_bus_message *m, const char *a,\n\t\tint32_t i)\n{\n\treturn mpris_msg_append_simple_dict(m, a, 'i', &i);\n}\n\nstatic int mpris_msg_append_sx_dict(sd_bus_message *m, const char *a,\n\t\tint64_t i)\n{\n\treturn mpris_msg_append_simple_dict(m, a, 'x', &i);\n}\n\nstatic int mpris_msg_append_ss_dict(sd_bus_message *m, const char *a,\n\t\tconst char *b)\n{\n\treturn mpris_msg_append_simple_dict(m, a, 's', b);\n}\n\nstatic int mpris_msg_append_so_dict(sd_bus_message *m, const char *a,\n\t\tconst char *b)\n{\n\treturn mpris_msg_append_simple_dict(m, a, 'o', b);\n}\n\nstatic int mpris_msg_append_sas_dict(sd_bus_message *m, const char *a,\n\t\tconst char *b)\n{\n\tCK(sd_bus_message_open_container(m, 'e', \"sv\"));\n\tCK(sd_bus_message_append_basic(m, 's', a));\n\tCK(sd_bus_message_open_container(m, 'v', \"as\"));\n\tCK(sd_bus_message_open_container(m, 'a', \"s\"));\n\tCK(sd_bus_message_append_basic(m, 's', b));\n\tCK(sd_bus_message_close_container(m));\n\tCK(sd_bus_message_close_container(m));\n\tCK(sd_bus_message_close_container(m));\n\treturn 0;\n}\n\nstatic int mpris_metadata(sd_bus *_bus, const char *_path,\n\t\tconst char *_interface, const char *_property,\n\t\tsd_bus_message *reply, void *_userdata,\n\t\tsd_bus_error *_ret_error)\n{\n\tCK(sd_bus_message_open_container(reply, 'a', \"{sv}\"));\n\n\tstruct track_info *ti = player_info.ti;\n\tif (ti) {\n\t\tchar buf[] = \"/1122334455667788\";\n\t\tsprintf(buf, \"/%\"PRIx64, ti->uid);\n\t\tCK(mpris_msg_append_so_dict(reply, \"mpris:trackid\", buf));\n\n\t\tint64_t dur = ti->duration;\n\t\tdur *= 1000 * 1000;\n\t\tCK(mpris_msg_append_sx_dict(reply, \"mpris:length\", dur));\n\n\t\t//The dbus connection closes if invalid data is sent.\n\t\t//As a *temporary* fix, ensure all strings are encoded in utf8.\n\t\tif (ti->artist) {\n\t\t\tchar corrected[u_str_print_size(ti->artist)];\n\t\t\tu_to_utf8(corrected, ti->artist);\n\t\t\tCK(mpris_msg_append_sas_dict(reply,\n\t\t\t\t\t\"xesam:artist\", corrected));\n\t\t}\n\t\tif (ti->title) {\n\t\t\tchar corrected[u_str_print_size(ti->title)];\n\t\t\tu_to_utf8(corrected, ti->title);\n\t\t\tCK(mpris_msg_append_ss_dict(reply,\n\t\t\t\t\t\"xesam:title\", corrected));\n\t\t} else {\n\t\t\tchar corrected[u_str_print_size(path_basename(ti->filename))];\n\t\t\tu_to_utf8(corrected, path_basename(ti->filename));\n\t\t\tCK(mpris_msg_append_ss_dict(reply,\n\t\t\t\t\"xesam:title\", corrected));\n\t\t}\n\t\tif (ti->album) {\n\t\t\tchar corrected[u_str_print_size(ti->album)];\n\t\t\tu_to_utf8(corrected, ti->album);\n\t\t\tCK(mpris_msg_append_ss_dict(reply,\n\t\t\t\t\t\"xesam:album\", corrected));\n\t\t}\n\t\tif (ti->albumartist) {\n\t\t\tchar corrected[u_str_print_size(ti->albumartist)];\n\t\t\tu_to_utf8(corrected, ti->albumartist);\n\t\t\tCK(mpris_msg_append_sas_dict(reply,\n\t\t\t\t\t\"xesam:albumArtist\", corrected));\n\t\t}\n\t\tif (ti->genre) {\n\t\t\tchar corrected[u_str_print_size(ti->genre)];\n\t\t\tu_to_utf8(corrected, ti->genre);\n\t\t\tCK(mpris_msg_append_sas_dict(reply,\n\t\t\t\t\t\"xesam:genre\", corrected));\n\t\t}\n\t\tif (ti->comment) {\n\t\t\tchar corrected[u_str_print_size(ti->comment)];\n\t\t\tu_to_utf8(corrected, ti->comment);\n\t\t\tCK(mpris_msg_append_sas_dict(reply,\n\t\t\t\t\t\"xesam:comment\", corrected));\n\t\t}\n\t\tif (ti->bpm != -1)\n\t\t\tCK(mpris_msg_append_si_dict(reply, \"xesam:audioBPM\",\n\t\t\t\t\t\tti->bpm));\n\t\tif (ti->tracknumber != -1)\n\t\t\tCK(mpris_msg_append_si_dict(reply, \"xesam:trackNumber\",\n\t\t\t\t\t\tti->tracknumber));\n\t\tif (ti->discnumber != -1)\n\t\t\tCK(mpris_msg_append_si_dict(reply, \"xesam:discNumber\",\n\t\t\t\t\t\tti->discnumber));\n\t\tif (is_http_url(ti->filename))\n\t\t\tCK(mpris_msg_append_ss_dict(reply, \"cmus:stream_title\",\n\t\t\t\t\t\tget_stream_title()));\n\t}\n\n\tCK(sd_bus_message_close_container(reply));\n\treturn 0;\n}\n\n#define MPRIS_PROP(name, type, read) \\\n\tSD_BUS_PROPERTY(name, type, read, 0, \\\n\t\t\tSD_BUS_VTABLE_PROPERTY_EMITS_CHANGE)\n\n#define MPRIS_WPROP(name, type, read, write) \\\n\tSD_BUS_WRITABLE_PROPERTY(name, type, read, write, 0, \\\n\t\t\tSD_BUS_VTABLE_PROPERTY_EMITS_CHANGE)\n\nstatic const sd_bus_vtable media_player2_vt[] = {\n\tSD_BUS_VTABLE_START(0),\n\tSD_BUS_METHOD(\"Raise\", \"\", \"\", mpris_raise_vte, 0),\n\tSD_BUS_METHOD(\"Quit\", \"\", \"\", mpris_msg_ignore, 0),\n\tMPRIS_PROP(\"CanQuit\", \"b\", mpris_read_false),\n\tMPRIS_WPROP(\"Fullscreen\", \"b\", mpris_read_false, mpris_write_ignore),\n\tMPRIS_PROP(\"CanSetFullscreen\", \"b\", mpris_read_false),\n\tMPRIS_PROP(\"CanRaise\", \"b\", mpris_can_raise_vte),\n\tMPRIS_PROP(\"HasTrackList\", \"b\", mpris_read_false),\n\tMPRIS_PROP(\"Identity\", \"s\", mpris_identity),\n\tMPRIS_PROP(\"SupportedUriSchemes\", \"as\", mpris_uri_schemes),\n\tMPRIS_PROP(\"SupportedMimeTypes\", \"as\", mpris_mime_types),\n\tSD_BUS_VTABLE_END,\n};\n\nstatic const sd_bus_vtable media_player2_player_vt[] = {\n\tSD_BUS_VTABLE_START(0),\n\tSD_BUS_METHOD(\"Next\", \"\", \"\", mpris_next, 0),\n\tSD_BUS_METHOD(\"Previous\", \"\", \"\", mpris_prev, 0),\n\tSD_BUS_METHOD(\"Pause\", \"\", \"\", mpris_pause, 0),\n\tSD_BUS_METHOD(\"PlayPause\", \"\", \"\", mpris_toggle_pause, 0),\n\tSD_BUS_METHOD(\"Stop\", \"\", \"\", mpris_stop, 0),\n\tSD_BUS_METHOD(\"Play\", \"\", \"\", mpris_play, 0),\n\tSD_BUS_METHOD(\"Seek\", \"x\", \"\", mpris_seek, 0),\n\tSD_BUS_METHOD(\"SetPosition\", \"ox\", \"\", mpris_seek_abs, 0),\n\tSD_BUS_METHOD(\"OpenUri\", \"s\", \"\", mpris_play_file, 0),\n\tMPRIS_PROP(\"PlaybackStatus\", \"s\", mpris_playback_status),\n\tMPRIS_WPROP(\"LoopStatus\", \"s\", mpris_loop_status, mpris_set_loop_status),\n\tMPRIS_WPROP(\"Rate\", \"d\", mpris_rate, mpris_write_ignore),\n\tMPRIS_WPROP(\"Shuffle\", \"b\", mpris_shuffle, mpris_set_shuffle),\n\tMPRIS_WPROP(\"Volume\", \"d\", mpris_volume, mpris_set_volume),\n\tSD_BUS_PROPERTY(\"Position\", \"x\", mpris_position, 0, 0),\n\tMPRIS_PROP(\"MinimumRate\", \"d\", mpris_rate),\n\tMPRIS_PROP(\"MaximumRate\", \"d\", mpris_rate),\n\tMPRIS_PROP(\"CanGoNext\", \"b\", mpris_read_true),\n\tMPRIS_PROP(\"CanGoPrevious\", \"b\", mpris_read_true),\n\tMPRIS_PROP(\"CanPlay\", \"b\", mpris_read_true),\n\tMPRIS_PROP(\"CanPause\", \"b\", mpris_read_true),\n\tMPRIS_PROP(\"CanSeek\", \"b\", mpris_read_true),\n\tSD_BUS_PROPERTY(\"CanControl\", \"b\", mpris_read_true, 0, 0),\n\tMPRIS_PROP(\"Metadata\", \"a{sv}\", mpris_metadata),\n\tSD_BUS_SIGNAL(\"Seeked\", \"x\", 0),\n\tSD_BUS_VTABLE_END,\n};\n\nvoid mpris_init(void)\n{\n\tint res = 0;\n\n\tres = sd_bus_default_user(&bus);\n\tif (res < 0)\n\t\tgoto out;\n\tres = sd_bus_add_object_vtable(bus, NULL, \"/org/mpris/MediaPlayer2\",\n\t\t\t\"org.mpris.MediaPlayer2\", media_player2_vt, NULL);\n\tif (res < 0)\n\t\tgoto out;\n\tres = sd_bus_add_object_vtable(bus, NULL, \"/org/mpris/MediaPlayer2\",\n\t\t\t\"org.mpris.MediaPlayer2.Player\",\n\t\t\tmedia_player2_player_vt, NULL);\n\tif (res < 0)\n\t\tgoto out;\n\tres = sd_bus_request_name(bus, \"org.mpris.MediaPlayer2.cmus\", 0);\n\tmpris_fd = sd_bus_get_fd(bus);\n\nout:\n\tif (res < 0) {\n\t\tsd_bus_unref(bus);\n\t\tbus = NULL;\n\t\tmpris_fd = -1;\n\n\t\tconst char *msg = \"an error occurred while initializing \"\n\t\t\t          \"MPRIS: %s. MPRIS will be disabled.\";\n\n\t\terror_msg(msg, strerror(-res));\n\t}\n}\n\nvoid mpris_process(void)\n{\n\tif (bus) {\n\t\twhile (sd_bus_process(bus, NULL) > 0)\n\t\t\t;\n\t}\n}\n\nvoid mpris_free(void)\n{\n\tsd_bus_unref(bus);\n\tbus = NULL;\n\tmpris_fd = -1;\n}\n\nstatic void mpris_player_property_changed(const char *name)\n{\n\tconst char * const strv[] = { name, NULL };\n\tif (bus) {\n\t\tsd_bus_emit_properties_changed_strv(bus,\n\t\t\t\t\"/org/mpris/MediaPlayer2\",\n\t\t\t\t\"org.mpris.MediaPlayer2.Player\", (char **)strv);\n\t\tsd_bus_flush(bus);\n\t}\n}\n\nvoid mpris_playback_status_changed(void)\n{\n\tmpris_player_property_changed(\"PlaybackStatus\");\n}\n\nvoid mpris_loop_status_changed(void)\n{\n\tmpris_player_property_changed(\"LoopStatus\");\n}\n\nvoid mpris_shuffle_changed(void)\n{\n\tmpris_player_property_changed(\"Shuffle\");\n}\n\nvoid mpris_volume_changed(void)\n{\n\tmpris_player_property_changed(\"Volume\");\n}\n\nvoid mpris_metadata_changed(void)\n{\n\tmpris_player_property_changed(\"Metadata\");\n\t// the following is not necessary according to the spec but some\n\t// applications seem to disregard the spec and expect this to happen\n\tmpris_seeked();\n}\n\nvoid mpris_seeked(void)\n{\n\tif (!bus)\n\t\treturn;\n\tint64_t pos = player_info.pos;\n\tpos *= 1000 * 1000;\n\tsd_bus_emit_signal(bus, \"/org/mpris/MediaPlayer2\",\n\t\t\t\"org.mpris.MediaPlayer2.Player\", \"Seeked\", \"x\", pos);\n}\n"
        },
        {
          "name": "mpris.h",
          "type": "blob",
          "size": 1.4248046875,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_MPRIS_H\n#define CMUS_MPRIS_H\n\n#include \"config/mpris.h\"\n\n#ifdef CONFIG_MPRIS\n\nextern int mpris_fd;\nvoid mpris_init(void);\nvoid mpris_process(void);\nvoid mpris_free(void);\nvoid mpris_playback_status_changed(void);\nvoid mpris_loop_status_changed(void);\nvoid mpris_shuffle_changed(void);\nvoid mpris_volume_changed(void);\nvoid mpris_metadata_changed(void);\nvoid mpris_seeked(void);\n\n#else\n\n#define mpris_fd -1\n#define mpris_init() { }\n#define mpris_process() { }\n#define mpris_free() { }\n#define mpris_playback_status_changed() { }\n#define mpris_loop_status_changed() { }\n#define mpris_shuffle_changed() { }\n#define mpris_volume_changed() { }\n#define mpris_metadata_changed() { }\n#define mpris_seeked() { }\n\n#endif\n\n#endif\n"
        },
        {
          "name": "op.h",
          "type": "blob",
          "size": 2.03125,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_OP_H\n#define CMUS_OP_H\n\n#include \"sf.h\"\n#include \"channelmap.h\"\n\n#ifndef __GNUC__\n#include <fcntl.h>\n#endif\n\n#define OP_ABI_VERSION 3\n\nenum {\n\t/* no error */\n\tOP_ERROR_SUCCESS,\n\t/* system error (error code in errno) */\n\tOP_ERROR_ERRNO,\n\t/* no such plugin */\n\tOP_ERROR_NO_PLUGIN,\n\t/* plugin not initialized */\n\tOP_ERROR_NOT_INITIALIZED,\n\t/* function not supported */\n\tOP_ERROR_NOT_SUPPORTED,\n\t/* mixer not open */\n\tOP_ERROR_NOT_OPEN,\n\t/* plugin does not support the sample format */\n\tOP_ERROR_SAMPLE_FORMAT,\n\t/* plugin does not have this option */\n\tOP_ERROR_NOT_OPTION,\n\t/*  */\n\tOP_ERROR_INTERNAL\n};\n\nstruct output_plugin_ops {\n\tint (*init)(void);\n\tint (*exit)(void);\n\tint (*open)(sample_format_t sf, const channel_position_t *channel_map);\n\tint (*close)(void);\n\tint (*drop)(void);\n\tint (*write)(const char *buffer, int count);\n\tint (*buffer_space)(void);\n\n\t/* these can be NULL */\n\tint (*pause)(void);\n\tint (*unpause)(void);\n\n};\n\n#define OPT(prefix, name) { #name, prefix ## _set_ ## name, \\\n\tprefix ## _get_ ## name }\n\nstruct output_plugin_opt {\n\tconst char *name;\n\tint (*set)(const char *val);\n\tint (*get)(char **val);\n};\n\n/* symbols exported by plugin */\nextern const struct output_plugin_ops op_pcm_ops;\nextern const struct output_plugin_opt op_pcm_options[];\nextern const int op_priority;\nextern const unsigned op_abi_version;\n\n#endif\n"
        },
        {
          "name": "op",
          "type": "tree",
          "content": null
        },
        {
          "name": "options.c",
          "type": "blob",
          "size": 46.216796875,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2006 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"options.h\"\n#include \"list.h\"\n#include \"utils.h\"\n#include \"xmalloc.h\"\n#include \"player.h\"\n#include \"buffer.h\"\n#include \"ui_curses.h\"\n#include \"cmus.h\"\n#include \"misc.h\"\n#include \"lib.h\"\n#include \"pl.h\"\n#include \"browser.h\"\n#include \"keys.h\"\n#include \"filters.h\"\n#include \"command_mode.h\"\n#include \"file.h\"\n#include \"prog.h\"\n#include \"output.h\"\n#include \"input.h\"\n#include \"xstrjoin.h\"\n#include \"track_info.h\"\n#include \"cache.h\"\n#include \"debug.h\"\n#include \"discid.h\"\n#include \"mpris.h\"\n#ifdef HAVE_CONFIG\n#include \"config/curses.h\"\n#endif\n\n#include <stdio.h>\n#include <errno.h>\n#include <strings.h>\n\n#if defined(__sun__)\n#include <ncurses.h>\n#else\n#include <curses.h>\n#endif\n\n/* initialized option variables */\n\nchar *cdda_device = NULL;\nchar *output_plugin = NULL;\nchar *status_display_program = NULL;\nchar *server_password;\nint auto_reshuffle = 1;\nint confirm_run = 1;\nint resume_cmus = 0;\nint show_hidden = 0;\nint show_current_bitrate = 0;\nint show_playback_position = 1;\nint show_remaining_time = 0;\nint set_term_title = 1;\nint wrap_search = 1;\nint play_library = 1;\nint repeat = 0;\nint shuffle = 0;\nint follow = 0;\nint display_artist_sort_name;\nint smart_artist_sort = 1;\nint sort_albums_by_name = 0;\nint scroll_offset = 2;\nint rewind_offset = 5;\nint skip_track_info = 0;\nint ignore_duplicates = 0;\nint auto_expand_albums_follow = 1;\nint auto_expand_albums_search = 1;\nint auto_expand_albums_selcur = 1;\nint auto_hide_playlists_panel = 0;\nint show_all_tracks = 1;\nint mouse = 0;\nint mpris = 1;\nint time_show_leading_zero = 1;\nint start_view = TREE_VIEW;\nint stop_after_queue = 0;\nint tree_width_percent = 33;\nint tree_width_max = 0;\nint pause_on_output_change = 0;\nint block_key_paste = 1;\nint progress_bar = 1;\nint search_resets_position = 1;\n\nint colors[NR_COLORS] = {\n\t-1,\n\t-1,\n\tCOLOR_RED | BRIGHT,\n\tCOLOR_YELLOW | BRIGHT,\n\n\tCOLOR_BLUE,\n\tCOLOR_WHITE,\n\tCOLOR_BLACK,\n\tCOLOR_BLUE,\n\n\tCOLOR_WHITE | BRIGHT,\n\tCOLOR_BLUE,\n\tCOLOR_WHITE | BRIGHT,\n\t-1,\n\n\tCOLOR_YELLOW | BRIGHT,\n\tCOLOR_BLUE,\n\tCOLOR_YELLOW | BRIGHT,\n\tCOLOR_BLUE | BRIGHT,\n\n\t-1,\n\tCOLOR_WHITE,\n\tCOLOR_YELLOW | BRIGHT,\n\tCOLOR_WHITE,\n\n\tCOLOR_BLACK,\n\tCOLOR_BLUE,\n\tCOLOR_WHITE | BRIGHT,\n\tCOLOR_BLUE,\n\n\tCOLOR_WHITE | BRIGHT,\n\t-1,\n\t-1,\n};\n\nint attrs[NR_ATTRS] = {\n\tA_NORMAL,\n\tA_NORMAL,\n\tA_NORMAL,\n\tA_NORMAL,\n\tA_NORMAL,\n\tA_NORMAL,\n\tA_NORMAL,\n\tA_NORMAL,\n\tA_NORMAL,\n\tA_NORMAL,\n\tA_NORMAL,\n\tA_BOLD,\n\tA_NORMAL,\n};\n\n/* uninitialized option variables */\nchar *tree_win_format = NULL;\nchar *tree_win_artist_format = NULL;\nchar *track_win_album_format = NULL;\nchar *track_win_format = NULL;\nchar *track_win_format_va = NULL;\nchar *track_win_alt_format = NULL;\nchar *list_win_format = NULL;\nchar *list_win_format_va = NULL;\nchar *list_win_alt_format = NULL;\nchar *clipped_text_format = NULL;\nchar *clipped_text_internal = NULL;\nchar *current_format = NULL;\nchar *current_alt_format = NULL;\nchar *heading_album_format = NULL;\nchar *heading_artist_format = NULL;\nchar *heading_playlist_format = NULL;\nchar *statusline_format = NULL;\nchar *window_title_format = NULL;\nchar *window_title_alt_format = NULL;\nchar *id3_default_charset = NULL;\nchar *icecast_default_charset = NULL;\nchar *lib_add_filter = NULL;\nchar **pl_env_vars;\n\nstatic void buf_int(char *buf, int val, size_t size)\n{\n\tsnprintf(buf, size, \"%d\", val);\n}\n\nstatic int parse_int(const char *buf, int minval, int maxval, int *val)\n{\n\tlong int tmp;\n\n\tif (str_to_int(buf, &tmp) == -1 || tmp < minval || tmp > maxval) {\n\t\terror_msg(\"integer in range %d..%d expected\", minval, maxval);\n\t\treturn 0;\n\t}\n\t*val = tmp;\n\treturn 1;\n}\n\nint parse_enum(const char *buf, int minval, int maxval, const char * const names[], int *val)\n{\n\tlong int tmp;\n\tint i;\n\tGBUF(names_buf);\n\n\tif (str_to_int(buf, &tmp) == 0) {\n\t\tif (tmp < minval || tmp > maxval)\n\t\t\tgoto err;\n\t\t*val = tmp;\n\t\treturn 1;\n\t}\n\n\tfor (i = 0; names[i]; i++) {\n\t\tif (strcasecmp(buf, names[i]) == 0) {\n\t\t\t*val = i + minval;\n\t\t\treturn 1;\n\t\t}\n\t}\nerr:\n\tfor (i = 0; names[i]; i++) {\n\t\tif (i)\n\t\t\tgbuf_add_str(&names_buf, \", \");\n\t\tgbuf_add_str(&names_buf, names[i]);\n\t}\n\terror_msg(\"expected [%d..%d] or [%s]\", minval, maxval, names_buf.buffer);\n\tgbuf_free(&names_buf);\n\treturn 0;\n}\n\nstatic const char * const bool_names[] = {\n\t\"false\", \"true\", NULL\n};\n\nstatic int parse_bool(const char *buf, int *val)\n{\n\treturn parse_enum(buf, 0, 1, bool_names, val);\n}\n\n/* this is used as id in struct cmus_opt */\nenum format_id {\n\tFMT_CLIPPED_TEXT,\n\tFMT_CURRENT_ALT,\n\tFMT_CURRENT,\n\tFMT_HEADING_ALBUM,\n\tFMT_HEADING_ARTIST,\n\tFMT_HEADING_PLAYLIST,\n\tFMT_STATUSLINE,\n\tFMT_PLAYLIST,\n\tFMT_PLAYLIST_ALT,\n\tFMT_PLAYLIST_VA,\n\tFMT_TITLE,\n\tFMT_TITLE_ALT,\n\tFMT_TRACKWIN,\n\tFMT_TRACKWIN_ALBUM,\n\tFMT_TRACKWIN_ALT,\n\tFMT_TRACKWIN_VA,\n\tFMT_TREEWIN,\n\tFMT_TREEWIN_ARTIST,\n\n\tNR_FMTS\n};\n\n/* default values for the variables which we must initialize but\n * can't do it statically */\nstatic const struct {\n\tconst char *name;\n\tconst char *value;\n} str_defaults[] = {\n\t[FMT_CLIPPED_TEXT]\t= { \"format_clipped_text\"\t, \"…\"\t\t\t\t\t\t\t},\n\t[FMT_CURRENT_ALT]\t= { \"altformat_current\"\t\t, \" %F \"\t\t\t\t\t\t},\n\t[FMT_CURRENT]\t\t= { \"format_current\"\t\t, \" %a - %l%! - %n. %t%= %y \"\t\t\t\t},\n\t[FMT_HEADING_ALBUM]\t= { \"format_heading_album\"\t, \"%a - %l%= %y %{duration}\"\t\t\t\t},\n\t[FMT_HEADING_ARTIST]\t= { \"format_heading_artist\"\t, \"%a%= %{duration}\"\t\t\t\t\t},\n\t[FMT_HEADING_PLAYLIST]\t= { \"format_heading_playlist\"\t, \"%{?!panel?Playlist - }%{title}%= %{duration}    \"\t},\n\t[FMT_STATUSLINE]\t= { \"format_statusline\"\t\t,\n\t\t\" %{status} %{?show_playback_position?%{position} %{?duration?/ %{duration} }?%{?duration?%{duration} }}\"\n\t\t\"%{?bpm>0?at %{bpm} BPM }\"\n\t\t\"%{?stream?buf: %{buffer} }\"\n\t\t\"%{?show_current_bitrate & bitrate>=0? %{bitrate} kbps }\"\n\t\t\"%= \"\n\t\t\"%{?repeat_current?repeat current?%{?play_library?%{?playlist_mode!=\\\"all\\\"?%{playlist_mode} from }%{?play_sorted?sorted }library?playlist}} | \"\n\t\t\"%{?volume>=0?%{?lvolume!=rvolume?%{lvolume}%% %{rvolume}?%{volume}}%% | }\"\n\t\t\"%1{continue}%1{follow}%1{repeat}%1{shuffle} \"\n\t},\n\t[FMT_PLAYLIST_ALT]\t= { \"altformat_playlist\"\t, \" %f%= %d %{?X!=0?%3X ?    }\"\t\t\t\t},\n\t[FMT_PLAYLIST]\t\t= { \"format_playlist\"\t\t, \" %-21%a %3n. %t%= %y %d %{?X!=0?%3X ?    }\"\t\t},\n\t[FMT_PLAYLIST_VA]\t= { \"format_playlist_va\"\t, \" %-21%A %3n. %t (%a)%= %y %d %{?X!=0?%3X ?    }\"\t},\n\t[FMT_TITLE_ALT]\t\t= { \"altformat_title\"\t\t, \"%f\"\t\t\t\t\t\t\t},\n\t[FMT_TITLE]\t\t= { \"format_title\"\t\t, \"%a - %l - %t (%y)\"\t\t\t\t\t},\n\t[FMT_TRACKWIN_ALBUM]\t= { \"format_trackwin_album\"\t, \" %l %= %y %{duration} \"\t\t\t\t},\n\t[FMT_TRACKWIN_ALT]\t= { \"altformat_trackwin\"\t, \" %f%= %d \"\t\t\t\t\t\t},\n\t[FMT_TRACKWIN]\t\t= { \"format_trackwin\"\t\t, \"%3n. %t%= %d \"\t\t\t\t\t},\n\t[FMT_TRACKWIN_VA]\t= { \"format_trackwin_va\"\t, \"%3n. %t (%a)%= %d \"\t\t\t\t\t},\n\t[FMT_TREEWIN]\t\t= { \"format_treewin\"\t\t, \"  %l\"\t\t\t\t\t\t},\n\t[FMT_TREEWIN_ARTIST]\t= { \"format_treewin_artist\"\t, \"%a\"\t\t\t\t\t\t\t},\n\n\t[NR_FMTS] =\n\n\t{ \"lib_sort\", \"albumartist date album discnumber tracknumber title filename play_count\" },\n\t{ \"pl_sort\", \"\" },\n\t{ \"id3_default_charset\", \"ISO-8859-1\" },\n\t{ \"icecast_default_charset\", \"ISO-8859-1\" },\n\t{ \"pl_env_vars\", \"\" },\n\t{ NULL, NULL }\n};\n\nstatic int seen_pr1317_fmts = 0;\n\n/* callbacks for normal options {{{ */\n\nstatic void get_device(void *data, char *buf, size_t size)\n{\n\tstrscpy(buf, cdda_device, size);\n}\n\nstatic void set_device(void *data, const char *buf)\n{\n\tfree(cdda_device);\n\tcdda_device = expand_filename(buf);\n}\n\n#define SECOND_SIZE (44100 * 16 / 8 * 2)\nstatic void get_buffer_seconds(void *data, char *buf, size_t size)\n{\n\tint val = (player_get_buffer_chunks() * CHUNK_SIZE + SECOND_SIZE / 2) /\n\t\tSECOND_SIZE;\n\tbuf_int(buf, val, size);\n}\n\nstatic void set_buffer_seconds(void *data, const char *buf)\n{\n\tint sec;\n\n\tif (parse_int(buf, 1, 300, &sec))\n\t\tplayer_set_buffer_chunks((sec * SECOND_SIZE + CHUNK_SIZE / 2) / CHUNK_SIZE);\n}\n\nstatic void get_scroll_offset(void *data, char *buf, size_t size)\n{\n\tbuf_int(buf, scroll_offset, size);\n}\n\nstatic void set_scroll_offset(void *data, const char *buf)\n{\n\tint offset;\n\n\tif (parse_int(buf, 0, 9999, &offset))\n\t\tscroll_offset = offset;\n}\n\nstatic void get_rewind_offset(void *data, char *buf, size_t size)\n{\n\tbuf_int(buf, rewind_offset, size);\n}\n\nstatic void set_rewind_offset(void *data, const char *buf)\n{\n\tint offset;\n\n\tif (parse_int(buf, -1, 9999, &offset))\n\t\trewind_offset = offset;\n}\n\nstatic void get_id3_default_charset(void *data, char *buf, size_t size)\n{\n\tstrscpy(buf, id3_default_charset, size);\n}\n\nstatic void get_icecast_default_charset(void *data, char *buf, size_t size)\n{\n\tstrscpy(buf, icecast_default_charset, size);\n}\n\nstatic void set_id3_default_charset(void *data, const char *buf)\n{\n\tfree(id3_default_charset);\n\tid3_default_charset = xstrdup(buf);\n}\n\nstatic void set_icecast_default_charset(void *data, const char *buf)\n{\n\tfree(icecast_default_charset);\n\ticecast_default_charset = xstrdup(buf);\n}\n\nstatic void get_lib_sort(void *data, char *buf, size_t size)\n{\n\tstrscpy(buf, lib_editable.shared->sort_str, size);\n}\n\nstatic void set_lib_sort(void *data, const char *buf)\n{\n\tsort_key_t *keys = parse_sort_keys(buf);\n\n\tif (keys) {\n\t\teditable_shared_set_sort_keys(lib_editable.shared, keys);\n\t\teditable_sort(&lib_editable);\n\t\tsort_keys_to_str(keys, lib_editable.shared->sort_str,\n\t\t\t\tsizeof(lib_editable.shared->sort_str));\n\t}\n}\n\nstatic void get_pl_sort(void *data, char *buf, size_t size)\n{\n\tpl_get_sort_str(buf, size);\n}\n\nstatic void set_pl_sort(void *data, const char *buf)\n{\n\tpl_set_sort_str(buf);\n}\n\nstatic void get_output_plugin(void *data, char *buf, size_t size)\n{\n\tconst char *value = op_get_current();\n\n\tif (value)\n\t\tstrscpy(buf, value, size);\n}\n\nstatic void set_output_plugin(void *data, const char *buf)\n{\n\tif (ui_initialized) {\n\t\tif (!soft_vol || pause_on_output_change)\n\t\t\tmixer_close();\n\t\tplayer_set_op(buf);\n\t\tif (!soft_vol || pause_on_output_change)\n\t\t\tmixer_open();\n\t} else {\n\t\t/* must set it later manually */\n\t\toutput_plugin = xstrdup(buf);\n\t}\n}\n\nstatic void get_passwd(void *data, char *buf, size_t size)\n{\n\tif (server_password)\n\t\tstrscpy(buf, server_password, size);\n}\n\nstatic void set_passwd(void *data, const char *buf)\n{\n\tint len = strlen(buf);\n\n\tif (len == 0) {\n\t\tfree(server_password);\n\t\tserver_password = NULL;\n\t} else if (len < 6) {\n\t\terror_msg(\"unsafe password\");\n\t} else {\n\t\tfree(server_password);\n\t\tserver_password = xstrdup(buf);\n\t}\n}\n\nstatic void get_replaygain_preamp(void *data, char *buf, size_t size)\n{\n\tsnprintf(buf, size, \"%f\", replaygain_preamp);\n}\n\nstatic void set_replaygain_preamp(void *data, const char *buf)\n{\n\tdouble val;\n\tchar *end;\n\n\tval = strtod(buf, &end);\n\tif (end == buf) {\n\t\terror_msg(\"floating point number expected (dB)\");\n\t\treturn;\n\t}\n\tplayer_set_rg_preamp(val);\n}\n\nstatic void get_softvol_state(void *data, char *buf, size_t size)\n{\n\tsnprintf(buf, size, \"%d %d\", soft_vol_l, soft_vol_r);\n}\n\nstatic void set_softvol_state(void *data, const char *buf)\n{\n\tchar buffer[OPTION_MAX_SIZE];\n\tchar *ptr;\n\tlong int l, r;\n\n\tstrscpy(buffer, buf, sizeof(buffer));\n\tptr = strchr(buffer, ' ');\n\tif (!ptr)\n\t\tgoto err;\n\twhile (*ptr == ' ')\n\t\t*ptr++ = 0;\n\n\tif (str_to_int(buffer, &l) == -1 || l < 0 || l > 100)\n\t\tgoto err;\n\tif (str_to_int(ptr, &r) == -1 || r < 0 || r > 100)\n\t\tgoto err;\n\n\tplayer_set_soft_volume(l, r);\n\treturn;\nerr:\n\terror_msg(\"two integers in range 0..100 expected\");\n}\n\nstatic void get_status_display_program(void *data, char *buf, size_t size)\n{\n\tif (status_display_program)\n\t\tstrscpy(buf, status_display_program, size);\n}\n\nstatic void set_status_display_program(void *data, const char *buf)\n{\n\tfree(status_display_program);\n\tstatus_display_program = NULL;\n\tif (buf[0])\n\t\tstatus_display_program = expand_filename(buf);\n}\n\nstatic void get_tree_width_percent(void *data, char *buf, size_t size)\n{\n\tbuf_int(buf, tree_width_percent, size);\n}\n\nstatic void set_tree_width_percent(void *data, const char *buf)\n{\n\tint percent;\n\n\tif (parse_int(buf, 1, 100, &percent))\n\t\ttree_width_percent = percent;\n\tupdate_size();\n}\n\nstatic void get_tree_width_max(void *data, char *buf, size_t size)\n{\n\tbuf_int(buf, tree_width_max, size);\n}\n\nstatic void set_tree_width_max(void *data, const char *buf)\n{\n\tint cols;\n\n\tif (parse_int(buf, 0, 9999, &cols))\n\t\ttree_width_max = cols;\n\tupdate_size();\n}\n\n/* get_pl_env_vars converts the pl_env_vars array into a comma-separated list */\nstatic void get_pl_env_vars(void *data, char *buf, size_t size)\n{\n\tif (!pl_env_vars) {\n\t\tstrscpy(buf, \"\", size);\n\t\treturn;\n\t}\n\tchar *p = buf;\n\tsize_t r = size - 1;\n\tfor (char **x = pl_env_vars; *x; x++) {\n\t\tif (x != pl_env_vars) {\n\t\t\tif (!--r)\n\t\t\t\treturn; /* overflow */\n\t\t\t*p++ = ',';\n\t\t}\n\t\tsize_t l = strlen(*x);\n\t\tif (!(r -= l))\n\t\t\treturn; /* overflow */\n\t\tstrcpy(p, *x);\n\t\tp += l;\n\t}\n\t*p = '\\0';\n}\n\n/* set_pl_env_vars splits the pl_env_vars config into the pl_env_vars array */\nstatic void set_pl_env_vars(void *data, const char *buf)\n{\n\tif (pl_env_vars) {\n\t\tfree(*pl_env_vars);\n\t\tfree(pl_env_vars);\n\t}\n\tif (!*buf) {\n\t\tpl_env_vars = NULL;\n\t}\n\tsize_t n = 1;\n\tfor (const char *x = buf; *x; x++) {\n\t\tif (*x == ',') {\n\t\t\tn++;\n\t\t}\n\t}\n\tchar **a = pl_env_vars = xnew(char*, n+1);\n\tfor (char *x = *a++ = xstrdup(buf); *x; x++) {\n\t\tif (*x == ',') {\n\t\t\t*a++ = x+1;\n\t\t\t*x = '\\0';\n\t\t}\n\t}\n\t*a = NULL;\n}\n\n/* }}} */\n\n/* callbacks for toggle options {{{ */\n\nstatic void get_auto_hide_playlists_panel(void *data, char *buf, size_t size)\n{\n\tstrscpy(buf, bool_names[auto_hide_playlists_panel], size);\n}\n\nstatic void set_auto_hide_playlists_panel(void *data, const char *buf)\n{\n\tparse_bool(buf, &auto_hide_playlists_panel);\n}\n\nstatic void toggle_auto_hide_playlists_panel(void *data)\n{\n\tauto_hide_playlists_panel ^= 1;\n}\n\nstatic void get_auto_reshuffle(void *data, char *buf, size_t size)\n{\n\tstrscpy(buf, bool_names[auto_reshuffle], size);\n}\n\nstatic void set_auto_reshuffle(void *data, const char *buf)\n{\n\tparse_bool(buf, &auto_reshuffle);\n}\n\nstatic void toggle_auto_reshuffle(void *data)\n{\n\tauto_reshuffle ^= 1;\n}\n\nstatic void get_follow(void *data, char *buf, size_t size)\n{\n\tstrscpy(buf, bool_names[follow], size);\n}\n\nstatic void set_follow(void *data, const char *buf)\n{\n\tif (!parse_bool(buf, &follow))\n\t\treturn;\n\tupdate_statusline();\n}\n\nstatic void toggle_follow(void *data)\n{\n\tfollow ^= 1;\n\tupdate_statusline();\n}\n\nstatic void get_continue(void *data, char *buf, size_t size)\n{\n\tstrscpy(buf, bool_names[player_cont], size);\n}\n\nstatic void set_continue(void *data, const char *buf)\n{\n\tif (!parse_bool(buf, &player_cont))\n\t\treturn;\n\tupdate_statusline();\n}\n\nstatic void toggle_continue(void *data)\n{\n\tplayer_cont ^= 1;\n\tupdate_statusline();\n}\n\nstatic void get_continue_album(void *data, char *buf, size_t size)\n{\n\tstrscpy(buf, bool_names[player_cont_album], size);\n}\n\nstatic void set_continue_album(void *data, const char *buf)\n{\n\tif (!parse_bool(buf, &player_cont_album))\n\t\treturn;\n\tupdate_statusline();\n}\n\nstatic void toggle_continue_album(void *data)\n{\n\tplayer_cont_album ^= 1;\n\tupdate_statusline();\n}\n\nstatic void get_repeat_current(void *data, char *buf, size_t size)\n{\n\tstrscpy(buf, bool_names[player_repeat_current], size);\n}\n\nstatic void set_repeat_current(void *data, const char *buf)\n{\n\tint old = player_repeat_current;\n\tif (!parse_bool(buf, &player_repeat_current))\n\t\treturn;\n\tif (old != player_repeat_current)\n\t\tmpris_loop_status_changed();\n\tupdate_statusline();\n}\n\nstatic void toggle_repeat_current(void *data)\n{\n\tplayer_repeat_current ^= 1;\n\tmpris_loop_status_changed();\n\tupdate_statusline();\n}\n\nstatic void get_confirm_run(void *data, char *buf, size_t size)\n{\n\tstrscpy(buf, bool_names[confirm_run], size);\n}\n\nstatic void set_confirm_run(void *data, const char *buf)\n{\n\tparse_bool(buf, &confirm_run);\n}\n\nstatic void toggle_confirm_run(void *data)\n{\n\tconfirm_run ^= 1;\n}\n\nconst char * const view_names[NR_VIEWS + 1] = {\n\t\"tree\", \"sorted\", \"playlist\", \"queue\", \"browser\", \"filters\", \"settings\", NULL\n};\n\nstatic void get_play_library(void *data, char *buf, size_t size)\n{\n\tstrscpy(buf, bool_names[play_library], size);\n}\n\nstatic void set_play_library(void *data, const char *buf)\n{\n\tif (!parse_bool(buf, &play_library))\n\t\treturn;\n\tupdate_statusline();\n}\n\nstatic void toggle_play_library(void *data)\n{\n\tplay_library ^= 1;\n\tupdate_statusline();\n}\n\nstatic void get_play_sorted(void *data, char *buf, size_t size)\n{\n\tstrscpy(buf, bool_names[play_sorted], size);\n}\n\nstatic void set_play_sorted(void *data, const char *buf)\n{\n\tint tmp;\n\n\tif (!parse_bool(buf, &tmp))\n\t\treturn;\n\n\tplay_sorted = tmp;\n\n\tupdate_statusline();\n}\n\nstatic void toggle_play_sorted(void *data)\n{\n\tplay_sorted = play_sorted ^ 1;\n\n\tif (play_sorted) {\n\t\t/* play_sorted makes no sense in playlist */\n\t\tplay_library = 1;\n\t}\n\n\tupdate_statusline();\n}\n\nstatic void get_smart_artist_sort(void *data, char *buf, size_t size)\n{\n\tstrscpy(buf, bool_names[smart_artist_sort], size);\n}\n\nstatic void set_smart_artist_sort(void *data, const char *buf)\n{\n\tif (parse_bool(buf, &smart_artist_sort))\n\t\tlib_sort_artists();\n}\n\nstatic void toggle_smart_artist_sort(void *data)\n{\n\tsmart_artist_sort ^= 1;\n\tlib_sort_artists();\n}\n\nstatic void get_sort_albums_by_name(void *data, char *buf, size_t size)\n{\n\tstrscpy(buf, bool_names[sort_albums_by_name], size);\n}\n\nstatic void set_sort_albums_by_name(void *data, const char *buf)\n{\n\tparse_bool(buf, &sort_albums_by_name);\n\tlib_sort_artists();\n}\n\nstatic void toggle_sort_albums_by_name(void *data)\n{\n\tsort_albums_by_name ^= 1;\n\tlib_sort_artists();\n}\n\nstatic void get_display_artist_sort_name(void *data, char *buf, size_t size)\n{\n\tstrscpy(buf, bool_names[display_artist_sort_name], size);\n}\n\nstatic void set_display_artist_sort_name(void *data, const char *buf)\n{\n\tparse_bool(buf, &display_artist_sort_name);\n\tlib_tree_win->changed = 1;\n}\n\nstatic void toggle_display_artist_sort_name(void *data)\n{\n\tdisplay_artist_sort_name ^= 1;\n\tlib_tree_win->changed = 1;\n}\n\nconst char * const aaa_mode_names[] = {\n\t\"all\", \"artist\", \"album\", NULL\n};\n\nstatic void get_aaa_mode(void *data, char *buf, size_t size)\n{\n\tstrscpy(buf, aaa_mode_names[aaa_mode], size);\n}\n\nstatic void set_aaa_mode(void *data, const char *buf)\n{\n\tint tmp;\n\n\tif (!parse_enum(buf, 0, 2, aaa_mode_names, &tmp))\n\t\treturn;\n\n\taaa_mode = tmp;\n\tupdate_statusline();\n}\n\nstatic void toggle_aaa_mode(void *data)\n{\n\t/* aaa mode makes no sense in playlist */\n\tplay_library = 1;\n\n\taaa_mode++;\n\taaa_mode %= 3;\n\tupdate_statusline();\n}\n\nstatic void get_repeat(void *data, char *buf, size_t size)\n{\n\tstrscpy(buf, bool_names[repeat], size);\n}\n\nstatic void set_repeat(void *data, const char *buf)\n{\n\tint old = repeat;\n\tif (!parse_bool(buf, &repeat))\n\t\treturn;\n\tif (!player_repeat_current && old != repeat)\n\t\tmpris_loop_status_changed();\n\tupdate_statusline();\n}\n\nstatic void toggle_repeat(void *data)\n{\n\trepeat ^= 1;\n\tif (!player_repeat_current)\n\t\tmpris_loop_status_changed();\n\tupdate_statusline();\n}\n\nstatic const char * const replaygain_names[] = {\n\t\"disabled\", \"track\", \"album\", \"track-preferred\", \"album-preferred\", \"smart\", NULL\n};\n\nstatic const size_t replaygain_names_len = sizeof(replaygain_names) / sizeof(replaygain_names[0]) - 1;\n\nstatic void get_replaygain(void *data, char *buf, size_t size)\n{\n\tstrscpy(buf, replaygain_names[replaygain], size);\n}\n\nstatic void set_replaygain(void *data, const char *buf)\n{\n\tint tmp;\n\n\tif (!parse_enum(buf, 0, replaygain_names_len - 1, replaygain_names, &tmp))\n\t\treturn;\n\tplayer_set_rg(tmp);\n}\n\nstatic void toggle_replaygain(void *data)\n{\n\tplayer_set_rg((replaygain + 1) % replaygain_names_len);\n}\n\nstatic void get_replaygain_limit(void *data, char *buf, size_t size)\n{\n\tstrscpy(buf, bool_names[replaygain_limit], size);\n}\n\nstatic void set_replaygain_limit(void *data, const char *buf)\n{\n\tint tmp;\n\n\tif (!parse_bool(buf, &tmp))\n\t\treturn;\n\tplayer_set_rg_limit(tmp);\n}\n\nstatic void toggle_replaygain_limit(void *data)\n{\n\tplayer_set_rg_limit(replaygain_limit ^ 1);\n}\n\nstatic void get_resume(void *data, char *buf, size_t size)\n{\n\tstrscpy(buf, bool_names[resume_cmus], size);\n}\n\nstatic void set_resume(void *data, const char *buf)\n{\n\tparse_bool(buf, &resume_cmus);\n}\n\nstatic void toggle_resume(void *data)\n{\n\tresume_cmus ^= 1;\n}\n\nstatic void get_show_hidden(void *data, char *buf, size_t size)\n{\n\tstrscpy(buf, bool_names[show_hidden], size);\n}\n\nstatic void set_show_hidden(void *data, const char *buf)\n{\n\tif (!parse_bool(buf, &show_hidden))\n\t\treturn;\n\tbrowser_reload();\n}\n\nstatic void toggle_show_hidden(void *data)\n{\n\tshow_hidden ^= 1;\n\tbrowser_reload();\n}\n\nstatic void set_show_all_tracks_int(int); /* defined below */\n\nstatic void get_auto_expand_albums_follow(void *data, char *buf, size_t size)\n{\n\tstrscpy(buf, bool_names[auto_expand_albums_follow], size);\n}\n\nstatic void set_auto_expand_albums_follow_int(int value)\n{\n\tauto_expand_albums_follow = !!value;\n\tif (!auto_expand_albums_follow && !show_all_tracks)\n\t\tset_show_all_tracks_int(1);\n}\n\nstatic void set_auto_expand_albums_follow(void *data, const char *buf)\n{\n\tint tmp = 0;\n\tparse_bool(buf, &tmp);\n\tset_auto_expand_albums_follow_int(tmp);\n}\n\nstatic void toggle_auto_expand_albums_follow(void *data)\n{\n\tset_auto_expand_albums_follow_int(!auto_expand_albums_follow);\n}\n\nstatic void get_auto_expand_albums_search(void *data, char *buf, size_t size)\n{\n\tstrscpy(buf, bool_names[auto_expand_albums_search], size);\n}\n\nstatic void set_auto_expand_albums_search_int(int value)\n{\n\tauto_expand_albums_search = !!value;\n\tif (!auto_expand_albums_search && !show_all_tracks)\n\t\tset_show_all_tracks_int(1);\n}\n\nstatic void set_auto_expand_albums_search(void *data, const char *buf)\n{\n\tint tmp = 0;\n\tparse_bool(buf, &tmp);\n\tset_auto_expand_albums_search_int(tmp);\n}\n\nstatic void toggle_auto_expand_albums_search(void *data)\n{\n\tset_auto_expand_albums_search_int(!auto_expand_albums_search);\n}\n\nstatic void get_auto_expand_albums_selcur(void *data, char *buf, size_t size)\n{\n\tstrscpy(buf, bool_names[auto_expand_albums_selcur], size);\n}\n\nstatic void set_auto_expand_albums_selcur_int(int value)\n{\n\tauto_expand_albums_selcur = !!value;\n\tif (!auto_expand_albums_selcur && !show_all_tracks)\n\t\tset_show_all_tracks_int(1);\n}\n\nstatic void set_auto_expand_albums_selcur(void *data, const char *buf)\n{\n\tint tmp = 0;\n\tparse_bool(buf, &tmp);\n\tset_auto_expand_albums_selcur_int(tmp);\n}\n\nstatic void toggle_auto_expand_albums_selcur(void *data)\n{\n\tset_auto_expand_albums_selcur_int(!auto_expand_albums_selcur);\n}\n\n\nstatic void get_show_all_tracks(void *data, char *buf, size_t size)\n{\n\tstrscpy(buf, bool_names[show_all_tracks], size);\n}\n\nstatic void set_show_all_tracks_int(int value)\n{\n\tvalue = !!value;\n\tif (show_all_tracks == value)\n\t\treturn;\n\tshow_all_tracks = value;\n\tif (!show_all_tracks) {\n\t\tif  (!auto_expand_albums_follow)\n\t\t\tset_auto_expand_albums_follow_int(1);\n\t\tif  (!auto_expand_albums_search)\n\t\t\tset_auto_expand_albums_search_int(1);\n\t\tif  (!auto_expand_albums_selcur)\n\t\t\tset_auto_expand_albums_selcur_int(1);\n\t}\n\ttree_sel_update(0);\n}\n\nstatic void set_show_all_tracks(void *data, const char *buf)\n{\n\tint tmp = 0;\n\tparse_bool(buf, &tmp);\n\tset_show_all_tracks_int(tmp);\n}\n\nstatic void toggle_show_all_tracks(void *data)\n{\n\tset_show_all_tracks_int(!show_all_tracks);\n}\n\nstatic void get_show_current_bitrate(void *data, char *buf, size_t size)\n{\n\tstrscpy(buf, bool_names[show_current_bitrate], size);\n}\n\nstatic void set_show_current_bitrate(void *data, const char *buf)\n{\n\tif (parse_bool(buf, &show_current_bitrate))\n\t\tupdate_statusline();\n}\n\nstatic void toggle_show_current_bitrate(void *data)\n{\n\tshow_current_bitrate ^= 1;\n\tupdate_statusline();\n}\n\nstatic void get_show_playback_position(void *data, char *buf, size_t size)\n{\n\tstrscpy(buf, bool_names[show_playback_position], size);\n}\n\nstatic void set_show_playback_position(void *data, const char *buf)\n{\n\tif (!parse_bool(buf, &show_playback_position))\n\t\treturn;\n\tupdate_statusline();\n}\n\nstatic void toggle_show_playback_position(void *data)\n{\n\tshow_playback_position ^= 1;\n\tupdate_statusline();\n}\n\nstatic void get_show_remaining_time(void *data, char *buf, size_t size)\n{\n\tstrscpy(buf, bool_names[show_remaining_time], size);\n}\n\nstatic void set_show_remaining_time(void *data, const char *buf)\n{\n\tif (!parse_bool(buf, &show_remaining_time))\n\t\treturn;\n\tupdate_statusline();\n}\n\nstatic void toggle_show_remaining_time(void *data)\n{\n\tshow_remaining_time ^= 1;\n\tupdate_statusline();\n}\n\nstatic void get_set_term_title(void *data, char *buf, size_t size)\n{\n\tstrscpy(buf, bool_names[set_term_title], size);\n}\n\nstatic void set_set_term_title(void *data, const char *buf)\n{\n\tparse_bool(buf, &set_term_title);\n}\n\nstatic void toggle_set_term_title(void *data)\n{\n\tset_term_title ^= 1;\n}\n\nconst char * const shuffle_names[] = {\n\t\"off\", \"tracks\", \"albums\", \"false\", \"true\", NULL\n};\n\nstatic void get_shuffle(void *data, char *buf, size_t size)\n{\n\tstrscpy(buf, shuffle_names[shuffle], size);\n}\n\nstatic void set_shuffle(void *data, const char *buf)\n{\n\tint tmp;\n\n\tif (!parse_enum(buf, 0, 4, shuffle_names, &tmp))\n\t\treturn;\n\n\tif (tmp == SHUFFLE_FALSE)\n\t\ttmp = SHUFFLE_OFF;\n\telse if (tmp == SHUFFLE_TRUE)\n\t\ttmp = SHUFFLE_TRACKS;\n\n\tif (tmp != shuffle)\n\t\tmpris_shuffle_changed();\n\n\tshuffle = tmp;\n\tupdate_statusline();\n}\n\nstatic void toggle_shuffle(void *data)\n{\n\tshuffle++;\n\tshuffle %= 3;\n\n\t/* album mode makes no sense in playlist */\n\tif (!play_library && shuffle == SHUFFLE_ALBUMS)\n\t\tshuffle = SHUFFLE_OFF;\n\n\tupdate_statusline();\n}\n\nstatic void get_softvol(void *data, char *buf, size_t size)\n{\n\tstrscpy(buf, bool_names[soft_vol], size);\n}\n\nstatic void do_set_softvol(int soft)\n{\n\tif (!soft_vol || pause_on_output_change)\n\t\tmixer_close();\n\tplayer_set_soft_vol(soft);\n\tif (!soft_vol || pause_on_output_change)\n\t\tmixer_open();\n\tupdate_statusline();\n}\n\nstatic void set_softvol(void *data, const char *buf)\n{\n\tint soft;\n\n\tif (!parse_bool(buf, &soft))\n\t\treturn;\n\tdo_set_softvol(soft);\n}\n\nstatic void toggle_softvol(void *data)\n{\n\tdo_set_softvol(soft_vol ^ 1);\n}\n\nstatic void get_wrap_search(void *data, char *buf, size_t size)\n{\n\tstrscpy(buf, bool_names[wrap_search], size);\n}\n\nstatic void set_wrap_search(void *data, const char *buf)\n{\n\tparse_bool(buf, &wrap_search);\n}\n\nstatic void toggle_wrap_search(void *data)\n{\n\twrap_search ^= 1;\n}\n\nstatic void get_skip_track_info(void *data, char *buf, size_t size)\n{\n\tstrscpy(buf, bool_names[skip_track_info], size);\n}\n\nstatic void set_skip_track_info(void *data, const char *buf)\n{\n\tparse_bool(buf, &skip_track_info);\n}\n\nstatic void toggle_skip_track_info(void *data)\n{\n\tskip_track_info ^= 1;\n}\n\nstatic void get_ignore_duplicates(void *data, char *buf, size_t size)\n{\n\tstrscpy(buf, bool_names[ignore_duplicates], size);\n}\n\nstatic void set_ignore_duplicates(void *data, const char *buf)\n{\n\tparse_bool(buf, &ignore_duplicates);\n}\n\nstatic void toggle_ignore_duplicates(void *data)\n{\n\tignore_duplicates ^= 1;\n}\n\nvoid update_mouse(void)\n{\n\tif (mouse) {\n\t\tmouseinterval(25);\n\t\tmousemask(BUTTON_CTRL | BUTTON_ALT\n\t\t  | BUTTON1_PRESSED | BUTTON1_RELEASED | BUTTON1_CLICKED\n\t\t  | BUTTON1_DOUBLE_CLICKED | BUTTON1_TRIPLE_CLICKED\n\t\t  | BUTTON2_PRESSED | BUTTON2_RELEASED | BUTTON2_CLICKED\n\t\t  | BUTTON3_PRESSED | BUTTON3_RELEASED | BUTTON3_CLICKED\n\t\t  | BUTTON3_DOUBLE_CLICKED | BUTTON3_TRIPLE_CLICKED\n\t\t  | BUTTON4_PRESSED | BUTTON4_RELEASED | BUTTON4_CLICKED\n\t\t  | BUTTON4_DOUBLE_CLICKED | BUTTON4_TRIPLE_CLICKED\n#if NCURSES_MOUSE_VERSION >= 2\n\t\t  | BUTTON5_PRESSED | BUTTON5_RELEASED | BUTTON5_CLICKED\n\t\t  | BUTTON5_DOUBLE_CLICKED | BUTTON5_TRIPLE_CLICKED\n#endif\n\t\t  , NULL);\n\t} else {\n\t\tmousemask(0, NULL);\n\t}\n}\n\nstatic void get_mouse(void *data, char *buf, size_t size)\n{\n\tstrscpy(buf, bool_names[mouse], size);\n}\n\nstatic void set_mouse(void *data, const char *buf)\n{\n\tparse_bool(buf, &mouse);\n\tupdate_mouse();\n}\n\nstatic void toggle_mouse(void *data)\n{\n\tmouse ^= 1;\n\tupdate_mouse();\n}\n\nstatic void get_mpris(void *data, char *buf, size_t size)\n{\n\tstrscpy(buf, bool_names[mpris], size);\n}\n\nstatic void set_mpris(void *data, const char *buf)\n{\n\tparse_bool(buf, &mpris);\n}\n\nstatic void toggle_mpris(void *data)\n{\n\tmpris ^= 1;\n}\n\nstatic void get_time_show_leading_zero(void *data, char *buf, size_t size)\n{\n\tstrscpy(buf, bool_names[time_show_leading_zero], size);\n}\n\nstatic void set_time_show_leading_zero(void *data, const char *buf)\n{\n\tif (!parse_bool(buf, &time_show_leading_zero))\n\t\treturn;\n\tupdate_statusline();\n}\n\nstatic void toggle_time_show_leading_zero(void *data)\n{\n\ttime_show_leading_zero ^= 1;\n\tupdate_statusline();\n}\n\nstatic void get_lib_add_filter(void *data, char *buf, size_t size)\n{\n\tstrscpy(buf, lib_add_filter ? lib_add_filter : \"\", size);\n}\n\nstatic void set_lib_add_filter(void *data, const char *buf)\n{\n\tstruct expr *expr = NULL;\n\n\tif (strlen(buf) != 0) {\n\t\t/* parse expression if non-empty string given */\n\t\texpr = expr_parse(buf);\n\n\t\tif (!expr)\n\t\t\treturn;\n\t}\n\n\tfree(lib_add_filter);\n\tlib_add_filter = xstrdup(buf);\n\n\tlib_set_add_filter(expr);\n}\n\nstatic void get_stop_after_queue(void *data, char *buf, size_t size)\n{\n\tstrscpy(buf, bool_names[stop_after_queue], size);\n}\n\nstatic void set_stop_after_queue(void *data, const char *buf)\n{\n\tparse_bool(buf, &stop_after_queue);\n}\n\nstatic void toggle_stop_after_queue(void *data)\n{\n\tstop_after_queue ^= 1;\n}\n\nstatic void get_pause_on_output_change(void *data, char *buf, size_t size)\n{\n\tstrscpy(buf, bool_names[pause_on_output_change], size);\n}\n\nstatic void set_pause_on_output_change(void *data, const char *buf)\n{\n\tparse_bool(buf, &pause_on_output_change);\n}\n\nstatic void toggle_pause_on_output_change(void *data)\n{\n\tpause_on_output_change ^= 1;\n}\n\nstatic void get_block_key_paste(void *data, char *buf, size_t size)\n{\n\tstrscpy(buf, bool_names[block_key_paste], size);\n}\n\nstatic void set_block_key_paste(void *data, const char *buf)\n{\n\tparse_bool(buf, &block_key_paste);\n}\n\nstatic void toggle_block_key_paste(void *data)\n{\n\tblock_key_paste ^= 1;\n}\n\nconst char * const progress_bar_names[] = {\n\t\"disabled\", \"line\", \"shuttle\", \"color\", \"color_shuttle\", NULL\n};\n\nstatic void get_progress_bar(void *data, char *buf, size_t size)\n{\n\tstrscpy(buf, progress_bar_names[progress_bar], size);\n}\n\nstatic void set_progress_bar(void *data, const char *buf)\n{\n\tparse_enum(buf, 0, 4, progress_bar_names, &progress_bar);\n}\n\nstatic void toggle_progress_bar(void *data)\n{\n\tprogress_bar++;\n\tprogress_bar %= NR_PROGRESS_BAR_MODES;\n\tupdate_statusline();\n}\n\nstatic void get_search_resets_position(void *data, char *buf, size_t size)\n{\n\tstrscpy(buf, bool_names[search_resets_position], size);\n}\n\nstatic void set_search_resets_position(void *data, const char *buf)\n{\n\tparse_bool(buf, &search_resets_position);\n}\n\nstatic void toggle_search_resets_position(void *data)\n{\n\tsearch_resets_position ^= 1;\n}\n\n/* }}} */\n\n/* special callbacks (id set) {{{ */\n\nstatic const char * const color_enum_names[1 + 8 * 2 + 1] = {\n\t\"default\",\n\t\"black\", \"red\", \"green\", \"yellow\", \"blue\", \"magenta\", \"cyan\", \"gray\",\n\t\"darkgray\", \"lightred\", \"lightgreen\", \"lightyellow\", \"lightblue\", \"lightmagenta\", \"lightcyan\", \"white\",\n\tNULL\n};\n\nstatic void get_color(void *data, char *buf, size_t size)\n{\n\tint val = *(int *)data;\n\tif (val < 16) {\n\t\tstrscpy(buf, color_enum_names[val + 1], size);\n\t} else {\n\t\tbuf_int(buf, val, size);\n\t}\n}\n\nstatic void set_color(void *data, const char *buf)\n{\n\tint color;\n\n\tif (!parse_enum(buf, -1, 255, color_enum_names, &color))\n\t\treturn;\n\n\t*(int *)data = color;\n\tupdate_colors();\n\tupdate_full();\n}\n\nstatic void get_start_view(void *data, char *buf, size_t size)\n{\n\tstrscpy(buf, view_names[start_view], size);\n}\n\nstatic void set_start_view(void *data, const char *buf)\n{\n\tint view;\n\n\tif (parse_enum(buf, 0, NR_VIEWS - 1, view_names, &view)) {\n\t\tstart_view = view;\n\t}\n}\n\nstatic void get_attr(void *data, char *buf, size_t size)\n{\n\tint attr = *(int *)data;\n\n\tif (attr == 0) {\n\t\tstrscpy(buf, \"default\", size);\n\t\treturn;\n\t}\n\n\tconst char *standout = \"\";\n\tconst char *underline = \"\";\n\tconst char *reverse = \"\";\n\tconst char *blink = \"\";\n\tconst char *bold = \"\";\n\tconst char *italic = \"\";\n\n\tif (attr & A_STANDOUT)\n\t\tstandout = \"standout|\";\n\tif (attr & A_UNDERLINE)\n\t\tunderline = \"underline|\";\n\tif (attr & A_REVERSE)\n\t\treverse = \"reverse|\";\n\tif (attr & A_BLINK)\n\t\tblink = \"blink|\";\n\tif (attr & A_BOLD)\n\t\tbold = \"bold|\";\n\t#if HAVE_ITALIC\n\tif (attr & A_ITALIC)\n\t\titalic = \"italic|\";\n\t#endif\n\n\tsize_t len = snprintf(buf, size, \"%s%s%s%s%s%s\",\n\t\t\tstandout, underline, reverse, blink, bold, italic);\n\n\tif (0 < len && len < size)\n\t\tbuf[len - 1] = 0;\n}\n\nstatic void set_attr(void *data, const char *buf)\n{\n\tint attr = 0;\n\tsize_t i = 0;\n\tsize_t offset = 0;\n\tsize_t length = 0;\n\tchar*  current;\n\n\tdo {\n\t\tif (buf[i] == '|' || buf[i] == '\\0') {\n\t\t\tcurrent = xstrndup(&buf[offset], length);\n\n\t\t\tif (strcmp(current, \"default\") == 0)\n\t\t\t\tattr |= A_NORMAL;\n\t\t\telse if (strcmp(current, \"standout\") == 0)\n\t\t\t\tattr |= A_STANDOUT;\n\t\t\telse if (strcmp(current, \"underline\") == 0)\n\t\t\t\tattr |= A_UNDERLINE;\n\t\t\telse if (strcmp(current, \"reverse\") == 0)\n\t\t\t\tattr |= A_REVERSE;\n\t\t\telse if (strcmp(current, \"blink\") == 0)\n\t\t\t\tattr |= A_BLINK;\n\t\t\telse if (strcmp(current, \"bold\") == 0)\n\t\t\t\tattr |= A_BOLD;\n\t\t\t#if HAVE_ITALIC\n\t\t\telse if (strcmp(current, \"italic\") == 0)\n\t\t\t\tattr |= A_ITALIC;\n\t\t\t#endif\n\n\t\t\tfree(current);\n\n\t\t\toffset = i;\n\t\t\tlength = -1;\n\t\t}\n\n\t\ti++;\n\t\tlength++;\n\t} while (buf[i - 1] != '\\0');\n\n\t*(int *)data = attr;\n\tupdate_colors();\n\tupdate_full();\n}\n\nstatic char **id_to_fmt(enum format_id id)\n{\n\tswitch (id) {\n\tcase FMT_CLIPPED_TEXT:\n\t\treturn &clipped_text_format;\n\tcase FMT_CURRENT_ALT:\n\t\treturn &current_alt_format;\n\tcase FMT_PLAYLIST_ALT:\n\t\treturn &list_win_alt_format;\n\tcase FMT_TITLE_ALT:\n\t\treturn &window_title_alt_format;\n\tcase FMT_TRACKWIN_ALT:\n\t\treturn &track_win_alt_format;\n\tcase FMT_CURRENT:\n\t\treturn &current_format;\n\tcase FMT_HEADING_ALBUM:\n\t\treturn &heading_album_format;\n\tcase FMT_HEADING_ARTIST:\n\t\treturn &heading_artist_format;\n\tcase FMT_HEADING_PLAYLIST:\n\t\treturn &heading_playlist_format;\n\tcase FMT_PLAYLIST:\n\t\treturn &list_win_format;\n\tcase FMT_PLAYLIST_VA:\n\t\treturn &list_win_format_va;\n\tcase FMT_TITLE:\n\t\treturn &window_title_format;\n\tcase FMT_TRACKWIN:\n\t\treturn &track_win_format;\n\tcase FMT_TRACKWIN_ALBUM:\n\t\treturn &track_win_album_format;\n\tcase FMT_TRACKWIN_VA:\n\t\treturn &track_win_format_va;\n\tcase FMT_TREEWIN:\n\t\treturn &tree_win_format;\n\tcase FMT_TREEWIN_ARTIST:\n\t\treturn &tree_win_artist_format;\n\tcase FMT_STATUSLINE:\n\t\treturn &statusline_format;\n\tdefault:\n\t\tdie(\"unhandled format code: %d\\n\", id);\n\t}\n\treturn NULL;\n}\n\nstatic void get_format(void *data, char *buf, size_t size)\n{\n\tchar **fmtp = data;\n\n\tstrscpy(buf, *fmtp, size);\n}\n\nstatic void set_format(void *data, const char *buf)\n{\n\tchar **fmtp = data;\n\n\tif (fmtp == id_to_fmt(FMT_HEADING_ALBUM) || fmtp == id_to_fmt(FMT_HEADING_ARTIST) || fmtp == id_to_fmt(FMT_HEADING_PLAYLIST))\n\t\tseen_pr1317_fmts = 1;\n\n\tif (!track_format_valid(buf)) {\n\t\terror_msg(\"invalid format string\");\n\t\treturn;\n\t}\n\tfree(*fmtp);\n\t*fmtp = xstrdup(buf);\n\n\tupdate_full();\n}\n\nstatic void set_clipped_text_format(void *data, const char *buf)\n{\n\tfree(clipped_text_format);\n\tclipped_text_format = clipped_text_internal = xstrdup(buf);\n\n\tupdate_full();\n}\n\n/* }}} */\n\n#define DN(name) { #name, get_ ## name, set_ ## name, NULL, 0 },\n#define DN_FLAGS(name, flags) { #name, get_ ## name, set_ ## name, NULL, flags },\n#define DT(name) { #name, get_ ## name, set_ ## name, toggle_ ## name, 0 },\n\nstatic const struct {\n\tconst char *name;\n\topt_get_cb get;\n\topt_set_cb set;\n\topt_toggle_cb toggle;\n\tunsigned int flags;\n} simple_options[] = {\n\tDT(aaa_mode)\n\tDT(auto_reshuffle)\n\tDN_FLAGS(device, OPT_PROGRAM_PATH)\n\tDN(buffer_seconds)\n\tDN(scroll_offset)\n\tDN(rewind_offset)\n\tDT(confirm_run)\n\tDT(continue)\n\tDT(continue_album)\n\tDT(smart_artist_sort)\n\tDT(sort_albums_by_name)\n\tDN(id3_default_charset)\n\tDN(icecast_default_charset)\n\tDN(lib_sort)\n\tDN(output_plugin)\n\tDN(passwd)\n\tDN(pl_sort)\n\tDT(play_library)\n\tDT(play_sorted)\n\tDT(display_artist_sort_name)\n\tDT(repeat)\n\tDT(repeat_current)\n\tDT(replaygain)\n\tDT(replaygain_limit)\n\tDN(replaygain_preamp)\n\tDT(resume)\n\tDT(show_hidden)\n\tDT(auto_expand_albums_follow)\n\tDT(auto_expand_albums_search)\n\tDT(auto_expand_albums_selcur)\n\tDT(auto_hide_playlists_panel)\n\tDT(show_all_tracks)\n\tDT(show_current_bitrate)\n\tDT(show_playback_position)\n\tDT(show_remaining_time)\n\tDT(set_term_title)\n\tDT(shuffle)\n\tDT(follow)\n\tDT(softvol)\n\tDN(softvol_state)\n\tDN_FLAGS(status_display_program, OPT_PROGRAM_PATH)\n\tDT(wrap_search)\n\tDT(skip_track_info)\n\tDT(ignore_duplicates)\n\tDT(mouse)\n\tDT(mpris)\n\tDT(time_show_leading_zero)\n\tDN(lib_add_filter)\n\tDN(start_view)\n\tDT(stop_after_queue)\n\tDN(tree_width_percent)\n\tDN(tree_width_max)\n\tDT(pause_on_output_change)\n\tDN(pl_env_vars)\n\tDT(block_key_paste)\n\tDT(progress_bar)\n\tDT(search_resets_position)\n\t{ NULL, NULL, NULL, NULL, 0 }\n};\n\nstatic const char * const color_names[NR_COLORS] = {\n\t\"color_cmdline_bg\",\n\t\"color_cmdline_fg\",\n\t\"color_error\",\n\t\"color_info\",\n\t\"color_separator\",\n\t\"color_statusline_bg\",\n\t\"color_statusline_fg\",\n\t\"color_statusline_progress_bg\",\n\t\"color_statusline_progress_fg\",\n\t\"color_titleline_bg\",\n\t\"color_titleline_fg\",\n\t\"color_win_bg\",\n\t\"color_win_cur\",\n\t\"color_win_cur_sel_bg\",\n\t\"color_win_cur_sel_fg\",\n\t\"color_win_dir\",\n\t\"color_win_fg\",\n\t\"color_win_inactive_cur_sel_bg\",\n\t\"color_win_inactive_cur_sel_fg\",\n\t\"color_win_inactive_sel_bg\",\n\t\"color_win_inactive_sel_fg\",\n\t\"color_win_sel_bg\",\n\t\"color_win_sel_fg\",\n\t\"color_win_title_bg\",\n\t\"color_win_title_fg\",\n\t\"color_trackwin_album_bg\",\n\t\"color_trackwin_album_fg\",\n};\n\nstatic const char * const attr_names[NR_ATTRS] = {\n\t\"color_cmdline_attr\",\n\t\"color_statusline_attr\",\n\t\"color_statusline_progress_attr\",\n\t\"color_titleline_attr\",\n\t\"color_win_attr\",\n\t\"color_win_cur_sel_attr\",\n\t\"color_cur_sel_attr\",\n\t\"color_win_inactive_cur_sel_attr\",\n\t\"color_win_inactive_sel_attr\",\n\t\"color_win_sel_attr\",\n\t\"color_win_title_attr\",\n\t\"color_trackwin_album_attr\",\n\t\"color_win_cur_attr\",\n};\n\nLIST_HEAD(option_head);\nint nr_options = 0;\n\nvoid option_add(const char *name, const void *data, opt_get_cb get,\n\t\topt_set_cb set, opt_toggle_cb toggle, unsigned int flags)\n{\n\tstruct cmus_opt *opt = xnew(struct cmus_opt, 1);\n\tstruct list_head *item;\n\n\topt->name = name;\n\topt->data = (void *)data;\n\topt->get = get;\n\topt->set = set;\n\topt->toggle = toggle;\n\topt->flags = flags;\n\n\titem = option_head.next;\n\twhile (item != &option_head) {\n\t\tstruct cmus_opt *o = container_of(item, struct cmus_opt, node);\n\n\t\tif (strcmp(name, o->name) < 0)\n\t\t\tbreak;\n\t\titem = item->next;\n\t}\n\t/* add before item */\n\tlist_add_tail(&opt->node, item);\n\tnr_options++;\n}\n\nstruct cmus_opt *option_find(const char *name)\n{\n\tstruct cmus_opt *opt = option_find_silent(name);\n\tif (opt == NULL)\n\t\terror_msg(\"no such option %s\", name);\n\treturn opt;\n}\n\nstruct cmus_opt *option_find_silent(const char *name)\n{\n\tstruct cmus_opt *opt;\n\n\tlist_for_each_entry(opt, &option_head, node) {\n\t\tif (strcmp(name, opt->name) == 0)\n\t\t\treturn opt;\n\t}\n\treturn NULL;\n}\n\nvoid option_set(const char *name, const char *value)\n{\n\tstruct cmus_opt *opt = option_find(name);\n\n\tif (opt)\n\t\topt->set(opt->data, value);\n}\n\nvoid options_add(void)\n{\n\tint i;\n\n\tfor (i = 0; simple_options[i].name; i++)\n\t\toption_add(simple_options[i].name, NULL, simple_options[i].get,\n\t\t\t\tsimple_options[i].set, simple_options[i].toggle,\n\t\t\t\tsimple_options[i].flags);\n\n\tfor (i = 0; i < NR_FMTS; i++)\n\t\toption_add(str_defaults[i].name, id_to_fmt(i), get_format,\n\t\t\t\tset_format, NULL, 0);\n\n\toption_find(\"format_clipped_text\")->set = set_clipped_text_format;\n\n\tfor (i = 0; i < NR_COLORS; i++)\n\t\toption_add(color_names[i], &colors[i], get_color, set_color,\n\t\t\t\tNULL, 0);\n\n\tfor (i = 0; i < NR_ATTRS; i++)\n\t\toption_add(attr_names[i], &attrs[i], get_attr, set_attr, NULL,\n\t\t\t\t0);\n\n\tip_add_options();\n\top_add_options();\n}\n\nstatic int handle_line(void *data, const char *line)\n{\n\trun_command(line);\n\treturn 0;\n}\n\nint source_file(const char *filename)\n{\n\treturn file_for_each_line(filename, handle_line, NULL);\n}\n\nvoid options_load(void)\n{\n\tchar filename[512];\n\tint i;\n\n\t/* initialize those that can't be statically initialized */\n\tcdda_device = get_default_cdda_device();\n\tfor (i = 0; str_defaults[i].name; i++)\n\t\toption_set(str_defaults[i].name, str_defaults[i].value);\n\n\t/* reset the flag before loading the autosave */\n\tseen_pr1317_fmts = 0;\n\n\t/* load autosave config */\n\tsnprintf(filename, sizeof(filename), \"%s/autosave\", cmus_config_dir);\n\tif (source_file(filename) == -1) {\n\t\tchar *def = xstrjoin(cmus_data_dir, \"/rc\");\n\n\t\tif (errno != ENOENT)\n\t\t\terror_msg(\"loading %s: %s\", filename, strerror(errno));\n\n\t\t/* load defaults */\n\t\tif (source_file(def) == -1)\n\t\t\tdie_errno(\"loading %s\", def);\n\n\t\tfree(def);\n\t}\n\n\t/* replace old format with new one if upgrading past PR #1317 */\n\tif (!seen_pr1317_fmts) {\n\t\toption_set(str_defaults[FMT_STATUSLINE].name, str_defaults[FMT_STATUSLINE].value);\n\t\toption_set(str_defaults[FMT_PLAYLIST_ALT].name, str_defaults[FMT_PLAYLIST_ALT].value);\n\t\toption_set(str_defaults[FMT_TRACKWIN_ALBUM].name, str_defaults[FMT_TRACKWIN_ALBUM].value);\n\t\toption_set(str_defaults[FMT_TRACKWIN].name, str_defaults[FMT_TRACKWIN].value);\n\t\toption_set(str_defaults[FMT_TRACKWIN_VA].name, str_defaults[FMT_TRACKWIN_VA].value);\n\t}\n\n\t/* load optional static config */\n\tsnprintf(filename, sizeof(filename), \"%s/rc\", cmus_config_dir);\n\tif (source_file(filename) == -1) {\n\t\tif (errno != ENOENT)\n\t\t\terror_msg(\"loading %s: %s\", filename, strerror(errno));\n\t}\n\n\t/* replace the default format_clipped_text symbol in ascii terminal */\n\tif (!using_utf8 && strcmp(clipped_text_format, str_defaults[FMT_CLIPPED_TEXT].value) == 0) {\n\t\tclipped_text_internal = xstrdup(\"...\");\n\t}\n}\n\nvoid options_exit(void)\n{\n\tstruct cmus_opt *opt;\n\tstruct filter_entry *filt;\n\tchar filename_tmp[512];\n\tchar filename[512];\n\tFILE *f;\n\tint i;\n\n\tsnprintf(filename_tmp, sizeof(filename_tmp), \"%s/autosave.tmp\", cmus_config_dir);\n\tf = fopen(filename_tmp, \"w\");\n\tif (f == NULL) {\n\t\twarn_errno(\"creating %s\", filename_tmp);\n\t\treturn;\n\t}\n\n\t/* save options */\n\tlist_for_each_entry(opt, &option_head, node) {\n\t\tchar buf[OPTION_MAX_SIZE];\n\n\t\tbuf[0] = 0;\n\t\topt->get(opt->data, buf, OPTION_MAX_SIZE);\n\t\tfprintf(f, \"set %s=%s\\n\", opt->name, buf);\n\t}\n\n\t/* save key bindings */\n\tfor (i = 0; i < NR_CTXS; i++) {\n\t\tstruct binding *b = key_bindings[i];\n\n\t\twhile (b) {\n\t\t\tfprintf(f, \"bind %s %s %s\\n\", key_context_names[i], b->key->name, b->cmd);\n\t\t\tb = b->next;\n\t\t}\n\t}\n\n\t/* save filters */\n\tlist_for_each_entry(filt, &filters_head, node)\n\t\tfprintf(f, \"fset %s=%s\\n\", filt->name, filt->filter);\n\tfprintf(f, \"factivate\");\n\tlist_for_each_entry(filt, &filters_head, node) {\n\t\tswitch (filt->act_stat) {\n\t\tcase FS_YES:\n\t\t\tfprintf(f, \" %s\", filt->name);\n\t\t\tbreak;\n\t\tcase FS_NO:\n\t\t\tfprintf(f, \" !%s\", filt->name);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfprintf(f, \"\\n\");\n\n\tfclose(f);\n\n\tsnprintf(filename, sizeof(filename), \"%s/autosave\", cmus_config_dir);\n\ti = rename(filename_tmp, filename);\n\tif (i)\n\t\twarn_errno(\"renaming %s to %s\", filename_tmp, filename);\n}\n\nstruct resume {\n\tenum player_status status;\n\tchar *filename;\n\tlong int position;\n\tchar *lib_filename;\n\tint view;\n\tchar *live_filter;\n\tchar *browser_dir;\n\tchar *marked_pl;\n};\n\nstatic int handle_resume_line(void *data, const char *line)\n{\n\tstruct resume *resume = data;\n\tchar *cmd, *arg;\n\n\tif (!parse_command(line, &cmd, &arg))\n\t\treturn 0;\n\tif (!arg)\n\t\tgoto out;\n\n\tif (strcmp(cmd, \"status\") == 0) {\n\t\tparse_enum(arg, 0, NR_PLAYER_STATUS, player_status_names, (int *) &resume->status);\n\t} else if (strcmp(cmd, \"file\") == 0) {\n\t\tfree(resume->filename);\n\t\tresume->filename = xstrdup(unescape(arg));\n\t} else if (strcmp(cmd, \"position\") == 0) {\n\t\tstr_to_int(arg, &resume->position);\n\t} else if (strcmp(cmd, \"lib_file\") == 0) {\n\t\tfree(resume->lib_filename);\n\t\tresume->lib_filename = xstrdup(unescape(arg));\n\t} else if (strcmp(cmd, \"view\") == 0) {\n\t\tparse_enum(arg, 0, NR_VIEWS, view_names, &resume->view);\n\t} else if (strcmp(cmd, \"live-filter\") == 0) {\n\t\tfree(resume->live_filter);\n\t\tresume->live_filter = xstrdup(unescape(arg));\n\t} else if (strcmp(cmd, \"browser-dir\") == 0) {\n\t\tfree(resume->browser_dir);\n\t\tresume->browser_dir = xstrdup(unescape(arg));\n\t} else if (strcmp(cmd, \"active-pl\") == 0) {\n\t\tfree(pl_resume_name);\n\t\tpl_resume_name = xstrdup(unescape(arg));\n\t} else if (strcmp(cmd, \"active-pl-row\") == 0) {\n\t\tstr_to_int(arg, &pl_resume_row);\n\t} else if (strcmp(cmd, \"marked-pl\") == 0) {\n\t\tfree(resume->marked_pl);\n\t\tresume->marked_pl = xstrdup(unescape(arg));\n\t}\n\n\tfree(arg);\nout:\n\tfree(cmd);\n\treturn 0;\n}\n\nvoid resume_load(void)\n{\n\tchar filename[512];\n\tstruct track_info *ti, *old;\n\tstruct resume resume = { .status = PLAYER_STATUS_STOPPED, .view = -1 };\n\n\tsnprintf(filename, sizeof(filename), \"%s/resume\", cmus_config_dir);\n\tif (file_for_each_line(filename, handle_resume_line, &resume) == -1) {\n\t\tif (errno != ENOENT)\n\t\t\terror_msg(\"loading %s: %s\", filename, strerror(errno));\n\t\treturn;\n\t}\n\tif (resume.view >= 0 && resume.view != cur_view)\n\t\tset_view(resume.view);\n\tif (resume.lib_filename) {\n\t\tcache_lock();\n\t\tti = old = cache_get_ti(resume.lib_filename, 0);\n\t\tcache_unlock();\n\t\tif (ti) {\n\t\t\tlib_add_track(ti, NULL);\n\t\t\ttrack_info_unref(ti);\n\t\t\tlib_store_cur_track(ti);\n\t\t\ttrack_info_unref(ti);\n\t\t\tti = lib_set_track(lib_find_track(ti));\n\t\t\tif (ti) {\n\t\t\t\tBUG_ON(ti != old);\n\t\t\t\ttrack_info_unref(ti);\n\t\t\t\ttree_sel_current(auto_expand_albums_follow);\n\t\t\t\tsorted_sel_current();\n\t\t\t}\n\t\t}\n\t\tfree(resume.lib_filename);\n\t}\n\tif (resume.filename) {\n\t\tcache_lock();\n\t\tti = cache_get_ti(resume.filename, 0);\n\t\tcache_unlock();\n\t\tif (ti) {\n\t\t\tplayer_set_file(ti);\n\t\t\tif (resume.status != PLAYER_STATUS_STOPPED)\n\t\t\t\tplayer_seek(resume.position, 0, resume.status == PLAYER_STATUS_PLAYING);\n\t\t}\n\t\tfree(resume.filename);\n\t}\n\tif (resume.live_filter) {\n\t\tfilters_set_live(resume.live_filter);\n\t\tfree(resume.live_filter);\n\t}\n\tif (resume.browser_dir) {\n\t\tbrowser_chdir(resume.browser_dir);\n\t\tfree(resume.browser_dir);\n\t}\n\tif (resume.marked_pl) {\n\t\tpl_set_marked_pl_by_name(resume.marked_pl);\n\t\tfree(resume.marked_pl);\n\t}\n}\n\nvoid resume_exit(void)\n{\n\tchar filename_tmp[512];\n\tchar filename[512];\n\tconst char *pl_name;\n\tstruct track_info *ti;\n\tFILE *f;\n\tint rc;\n\n\tsnprintf(filename_tmp, sizeof(filename_tmp), \"%s/resume.tmp\", cmus_config_dir);\n\tf = fopen(filename_tmp, \"w\");\n\tif (!f) {\n\t\twarn_errno(\"creating %s\", filename_tmp);\n\t\treturn;\n\t}\n\n\tfprintf(f, \"status %s\\n\", player_status_names[player_info.status]);\n\tti = player_info.ti;\n\tif (ti) {\n\t\tfprintf(f, \"file %s\\n\", escape(ti->filename));\n\t\tfprintf(f, \"position %d\\n\", player_info.pos);\n\t}\n\tif (lib_cur_track)\n\t\tti = tree_track_info(lib_cur_track);\n\telse\n\t\tti = lib_get_cur_stored_track();\n\tif (ti)\n\t\tfprintf(f, \"lib_file %s\\n\", escape(ti->filename));\n\tfprintf(f, \"view %s\\n\", view_names[cur_view]);\n\tif (lib_live_filter)\n\t\tfprintf(f, \"live-filter %s\\n\", escape(lib_live_filter));\n\tfprintf(f, \"browser-dir %s\\n\", escape(browser_dir));\n\n\tif ((pl_name = pl_playing_pl_name())) {\n\t\tfprintf(f, \"active-pl %s\\n\", escape(pl_name));\n\t\tfprintf(f, \"active-pl-row %d\\n\", pl_playing_pl_row());\n\t}\n\n\tfprintf(f, \"marked-pl %s\\n\", escape(pl_marked_pl_name()));\n\n\tfclose(f);\n\n\tsnprintf(filename, sizeof(filename), \"%s/resume\", cmus_config_dir);\n\trc = rename(filename_tmp, filename);\n\tif (rc)\n\t\twarn_errno(\"renaming %s to %s\", filename_tmp, filename);\n}\n"
        },
        {
          "name": "options.h",
          "type": "blob",
          "size": 5.94140625,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2005 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_OPTIONS_H\n#define CMUS_OPTIONS_H\n\n#include \"list.h\"\n\n#define OPTION_MAX_SIZE\t4096\n\ntypedef void (*opt_get_cb)(void *data, char *buf, size_t size);\ntypedef void (*opt_set_cb)(void *data, const char *buf);\ntypedef void (*opt_toggle_cb)(void *data);\n\nenum {\n\tOPT_PROGRAM_PATH = 1 << 0,\n};\n\nstruct cmus_opt {\n\tstruct list_head node;\n\n\tconst char *name;\n\n\t/* If there are many similar options you should write generic get(),\n\t * set() and optionally toggle() and distinguish the concrete option\n\t * via this pointer.\n\t */\n\tvoid *data;\n\n\topt_get_cb get;\n\topt_set_cb set;\n\n\t/* NULL if not toggle-able */\n\topt_toggle_cb toggle;\n\n\tunsigned int flags;\n};\n\nextern struct list_head option_head;\nextern int nr_options;\n\nenum {\n\tTREE_VIEW,\n\tSORTED_VIEW,\n\tPLAYLIST_VIEW,\n\tQUEUE_VIEW,\n\tBROWSER_VIEW,\n\tFILTERS_VIEW,\n\tHELP_VIEW,\n\tNR_VIEWS\n};\n\nenum {\n\tCOLOR_CMDLINE_BG,\n\tCOLOR_CMDLINE_FG,\n\tCOLOR_ERROR,\n\tCOLOR_INFO,\n\n\tCOLOR_SEPARATOR,\n\tCOLOR_STATUSLINE_BG,\n\tCOLOR_STATUSLINE_FG,\n\tCOLOR_STATUSLINE_PROGRESS_BG,\n\n\tCOLOR_STATUSLINE_PROGRESS_FG,\n\tCOLOR_TITLELINE_BG,\n\tCOLOR_TITLELINE_FG,\n\tCOLOR_WIN_BG,\n\n\tCOLOR_WIN_CUR,\n\tCOLOR_WIN_CUR_SEL_BG,\n\tCOLOR_WIN_CUR_SEL_FG,\n\tCOLOR_WIN_DIR,\n\n\tCOLOR_WIN_FG,\n\tCOLOR_WIN_INACTIVE_CUR_SEL_BG,\n\tCOLOR_WIN_INACTIVE_CUR_SEL_FG,\n\tCOLOR_WIN_INACTIVE_SEL_BG,\n\n\tCOLOR_WIN_INACTIVE_SEL_FG,\n\tCOLOR_WIN_SEL_BG,\n\tCOLOR_WIN_SEL_FG,\n\tCOLOR_WIN_TITLE_BG,\n\n\tCOLOR_WIN_TITLE_FG,\n\tCOLOR_TRACKWIN_ALBUM_BG,\n\tCOLOR_TRACKWIN_ALBUM_FG,\n\n\tNR_COLORS\n};\n\nenum {\n\tCOLOR_CMDLINE_ATTR,\n\tCOLOR_STATUSLINE_ATTR,\n\tCOLOR_STATUSLINE_PROGRESS_ATTR,\n\tCOLOR_TITLELINE_ATTR,\n\tCOLOR_WIN_ATTR,\n\tCOLOR_WIN_CUR_SEL_ATTR,\n\tCOLOR_CUR_SEL_ATTR,\n\tCOLOR_WIN_INACTIVE_CUR_SEL_ATTR,\n\tCOLOR_WIN_INACTIVE_SEL_ATTR,\n\tCOLOR_WIN_SEL_ATTR,\n\tCOLOR_WIN_TITLE_ATTR,\n\tCOLOR_TRACKWIN_ALBUM_ATTR,\n\tCOLOR_WIN_CUR_ATTR,\n\tNR_ATTRS\n};\n\nenum shuffle_mode {\n\tSHUFFLE_OFF,\n\tSHUFFLE_TRACKS,\n\tSHUFFLE_ALBUMS,\n\t/* backwards compatability */\n\tSHUFFLE_FALSE,\n\tSHUFFLE_TRUE\n};\n\nenum progress_bar_mode {\n\tPROGRESS_BAR_DISABLED,\n\tPROGRESS_BAR_LINE,\n\tPROGRESS_BAR_SHUTTLE,\n\tPROGRESS_BAR_COLOR,\n\tPROGRESS_BAR_COLOR_SHUTTLE,\n\tNR_PROGRESS_BAR_MODES\n};\n\n#define BRIGHT (1 << 3)\n\nextern char *cdda_device;\nextern char *output_plugin;\nextern char *status_display_program;\nextern char *server_password;\nextern int auto_expand_albums_follow;\nextern int auto_expand_albums_search;\nextern int auto_expand_albums_selcur;\nextern int auto_hide_playlists_panel;\nextern int show_all_tracks;\nextern int auto_reshuffle;\nextern int confirm_run;\nextern int resume_cmus;\nextern int show_hidden;\nextern int show_current_bitrate;\nextern int show_playback_position;\nextern int show_remaining_time;\nextern int set_term_title;\nextern int wrap_search;\nextern int play_library;\nextern int repeat;\nextern int shuffle;\nextern int follow;\nextern int display_artist_sort_name;\nextern int smart_artist_sort;\nextern int sort_albums_by_name;\nextern int scroll_offset;\nextern int rewind_offset;\nextern int skip_track_info;\nextern int ignore_duplicates;\nextern int mouse;\nextern int mpris;\nextern int time_show_leading_zero;\nextern int start_view;\nextern int stop_after_queue;\nextern int tree_width_percent;\nextern int tree_width_max;\nextern int pause_on_output_change;\nextern int block_key_paste;\nextern int progress_bar;\nextern int search_resets_position;\n\nextern const char * const aaa_mode_names[];\nextern const char * const view_names[NR_VIEWS + 1];\n\nextern int colors[NR_COLORS];\nextern int attrs[NR_ATTRS];\n\n/* format string for tree window (tree view) */\nextern char *tree_win_format;\nextern char *tree_win_artist_format;\n\n/* format string for track window (tree view) */\nextern char *track_win_album_format;\nextern char *track_win_format;\nextern char *track_win_format_va;\nextern char *track_win_alt_format;\n\n/* format string for shuffle, sorted and play queue views */\nextern char *list_win_format;\nextern char *list_win_format_va;\nextern char *list_win_alt_format;\n\n/* format string for currently playing track */\nextern char *current_format;\nextern char *current_alt_format;\n\n/* format string for trackwin heading bar */\nextern char *heading_album_format;\nextern char *heading_artist_format;\nextern char *heading_playlist_format;\n\n/* format string for status line */\nextern char *statusline_format;\n\n/* format string for window title */\nextern char *window_title_format;\nextern char *window_title_alt_format;\n\n/* format string used to terminate all clipped text */\nextern char *clipped_text_format;\nextern char *clipped_text_internal;\n\nextern char *id3_default_charset;\nextern char *icecast_default_charset;\n\n/* comma-separated list of env vars to substitute in saved library/cache paths */\nextern char **pl_env_vars;\n\n/* build option list */\nvoid options_add(void);\n\n/* load options from the config file */\nvoid options_load(void);\n\nint source_file(const char *filename);\n\n/* save options */\nvoid options_exit(void);\n\n/* load resume file */\nvoid resume_load(void);\n/* save resume file */\nvoid resume_exit(void);\n\nvoid option_add(const char *name, const void *data, opt_get_cb get,\n\t\topt_set_cb set, opt_toggle_cb toggle, unsigned int flags);\nstruct cmus_opt *option_find(const char *name);\nstruct cmus_opt *option_find_silent(const char *name);\nvoid option_set(const char *name, const char *value);\nint parse_enum(const char *buf, int minval, int maxval, const char * const names[], int *val);\n\nvoid update_mouse(void);\n\n#endif\n"
        },
        {
          "name": "output.c",
          "type": "blob",
          "size": 10.4521484375,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004-2006 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"output.h\"\n#include \"op.h\"\n#include \"mixer.h\"\n#include \"sf.h\"\n#include \"utils.h\"\n#include \"xmalloc.h\"\n#include \"list.h\"\n#include \"debug.h\"\n#include \"ui_curses.h\"\n#include \"options.h\"\n#include \"xstrjoin.h\"\n#include \"misc.h\"\n\n#include <string.h>\n#include <strings.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <sys/types.h>\n#include <dirent.h>\n#include <dlfcn.h>\n\nstruct output_plugin {\n\tstruct list_head node;\n\tchar *name;\n\tvoid *handle;\n\n\tconst unsigned *abi_version_ptr;\n\tconst struct output_plugin_ops *pcm_ops;\n\tconst struct mixer_plugin_ops *mixer_ops;\n\tconst struct output_plugin_opt *pcm_options;\n\tconst struct mixer_plugin_opt *mixer_options;\n\tint priority;\n\n\tunsigned int pcm_initialized : 1;\n\tunsigned int mixer_initialized : 1;\n\tunsigned int mixer_open : 1;\n};\n\nstatic const char *plugin_dir;\nstatic LIST_HEAD(op_head);\nstatic struct output_plugin *op = NULL;\n\n/* volume is between 0 and volume_max */\nint volume_max = 0;\nint volume_l = -1;\nint volume_r = -1;\n\nstatic void add_plugin(struct output_plugin *plugin)\n{\n\tstruct list_head *item = op_head.next;\n\n\twhile (item != &op_head) {\n\t\tstruct output_plugin *o = container_of(item, struct output_plugin, node);\n\n\t\tif (plugin->priority < o->priority)\n\t\t\tbreak;\n\t\titem = item->next;\n\t}\n\n\t/* add before item */\n\tlist_add_tail(&plugin->node, item);\n}\n\nvoid op_load_plugins(void)\n{\n\tDIR *dir;\n\tstruct dirent *d;\n\n\tplugin_dir = xstrjoin(cmus_lib_dir, \"/op\");\n\tdir = opendir(plugin_dir);\n\tif (dir == NULL) {\n\t\terror_msg(\"couldn't open directory `%s': %s\", plugin_dir, strerror(errno));\n\t\treturn;\n\t}\n\twhile ((d = (struct dirent *) readdir(dir)) != NULL) {\n\t\tchar filename[512];\n\t\tstruct output_plugin *plug;\n\t\tvoid *so, *symptr;\n\t\tchar *ext;\n\t\tbool err = false;\n\n\t\tif (d->d_name[0] == '.')\n\t\t\tcontinue;\n\t\text = strrchr(d->d_name, '.');\n\t\tif (ext == NULL)\n\t\t\tcontinue;\n\t\tif (strcmp(ext, \".so\"))\n\t\t\tcontinue;\n\n\t\tsnprintf(filename, sizeof(filename), \"%s/%s\", plugin_dir, d->d_name);\n\n\t\tso = dlopen(filename, RTLD_NOW);\n\t\tif (so == NULL) {\n\t\t\td_print(\"%s: %s\\n\", filename, dlerror());\n\t\t\tcontinue;\n\t\t}\n\n\t\tplug = xnew(struct output_plugin, 1);\n\n\t\tplug->pcm_ops = dlsym(so, \"op_pcm_ops\");\n\t\tplug->pcm_options = dlsym(so, \"op_pcm_options\");\n\t\tsymptr = dlsym(so, \"op_priority\");\n\t\tplug->abi_version_ptr = dlsym(so, \"op_abi_version\");\n\t\tif (!plug->pcm_ops || !plug->pcm_options || !symptr) {\n\t\t\terror_msg(\"%s: missing symbol\", filename);\n\t\t\terr = true;\n\t\t}\n\t\tif (!plug->abi_version_ptr || *plug->abi_version_ptr != OP_ABI_VERSION) {\n\t\t\terror_msg(\"%s: incompatible plugin version\", filename);\n\t\t\terr = true;\n\t\t}\n\t\tif (err) {\n\t\t\tfree(plug);\n\t\t\tdlclose(so);\n\t\t\tcontinue;\n\t\t}\n\t\tplug->priority = *(int *)symptr;\n\n\t\tplug->mixer_ops = dlsym(so, \"op_mixer_ops\");\n\t\tplug->mixer_options = dlsym(so, \"op_mixer_options\");\n\t\tif (plug->mixer_ops == NULL || plug->mixer_options == NULL) {\n\t\t\tplug->mixer_ops = NULL;\n\t\t\tplug->mixer_options = NULL;\n\t\t}\n\n\t\tplug->name = xstrndup(d->d_name, ext - d->d_name);\n\t\tplug->handle = so;\n\t\tplug->pcm_initialized = 0;\n\t\tplug->mixer_initialized = 0;\n\t\tplug->mixer_open = 0;\n\n\t\tadd_plugin(plug);\n\t}\n\tclosedir(dir);\n}\n\nstatic void init_plugin(struct output_plugin *o)\n{\n\tif (!o->mixer_initialized && o->mixer_ops) {\n\t\tif (o->mixer_ops->init() == 0) {\n\t\t\td_print(\"initialized mixer for %s\\n\", o->name);\n\t\t\to->mixer_initialized = 1;\n\t\t} else {\n\t\t\td_print(\"could not initialize mixer `%s'\\n\", o->name);\n\t\t}\n\t}\n\tif (!o->pcm_initialized) {\n\t\tif (o->pcm_ops->init() == 0) {\n\t\t\td_print(\"initialized pcm for %s\\n\", o->name);\n\t\t\to->pcm_initialized = 1;\n\t\t} else {\n\t\t\td_print(\"could not initialize pcm `%s'\\n\", o->name);\n\t\t}\n\t}\n}\n\nvoid op_exit_plugins(void)\n{\n\tstruct output_plugin *o;\n\n\tlist_for_each_entry(o, &op_head, node) {\n\t\tif (o->mixer_initialized && o->mixer_ops)\n\t\t\to->mixer_ops->exit();\n\t\tif (o->pcm_initialized)\n\t\t\to->pcm_ops->exit();\n\t}\n}\n\nvoid mixer_close(void)\n{\n\tvolume_max = 0;\n\tif (op && op->mixer_open) {\n\t\tBUG_ON(op->mixer_ops == NULL);\n\t\top->mixer_ops->close();\n\t\top->mixer_open = 0;\n\t}\n}\n\nvoid mixer_open(void)\n{\n\tif (op == NULL)\n\t\treturn;\n\n\tBUG_ON(op->mixer_open);\n\tif (op->mixer_ops && op->mixer_initialized) {\n\t\tint rc;\n\n\t\trc = op->mixer_ops->open(&volume_max);\n\t\tif (rc == 0) {\n\t\t\top->mixer_open = 1;\n\t\t\tmixer_read_volume();\n\t\t} else {\n\t\t\tvolume_max = 0;\n\t\t}\n\t}\n}\n\nstatic int select_plugin(struct output_plugin *o)\n{\n\t/* try to initialize if not initialized yet */\n\tinit_plugin(o);\n\n\tif (!o->pcm_initialized)\n\t\treturn -OP_ERROR_NOT_INITIALIZED;\n\top = o;\n\treturn 0;\n}\n\nint op_select(const char *name)\n{\n\tstruct output_plugin *o;\n\n\tlist_for_each_entry(o, &op_head, node) {\n\t\tif (strcasecmp(name, o->name) == 0)\n\t\t\treturn select_plugin(o);\n\t}\n\treturn -OP_ERROR_NO_PLUGIN;\n}\n\nint op_select_any(void)\n{\n\tstruct output_plugin *o;\n\tint rc = -OP_ERROR_NO_PLUGIN;\n\tsample_format_t sf = sf_channels(2) | sf_rate(44100) | sf_bits(16) | sf_signed(1);\n\n\tlist_for_each_entry(o, &op_head, node) {\n\t\trc = select_plugin(o);\n\t\tif (rc != 0)\n\t\t\tcontinue;\n\t\trc = o->pcm_ops->open(sf, NULL);\n\t\tif (rc == 0) {\n\t\t\to->pcm_ops->close();\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn rc;\n}\n\nint op_open(sample_format_t sf, const channel_position_t *channel_map)\n{\n\tif (op == NULL)\n\t\treturn -OP_ERROR_NOT_INITIALIZED;\n\treturn op->pcm_ops->open(sf, channel_map);\n}\n\nint op_drop(void)\n{\n\tif (op->pcm_ops->drop == NULL)\n\t\treturn -OP_ERROR_NOT_SUPPORTED;\n\treturn op->pcm_ops->drop();\n}\n\nint op_close(void)\n{\n\treturn op->pcm_ops->close();\n}\n\nint op_write(const char *buffer, int count)\n{\n\treturn op->pcm_ops->write(buffer, count);\n}\n\nint op_pause(void)\n{\n\tif (op->pcm_ops->pause == NULL)\n\t\treturn 0;\n\treturn op->pcm_ops->pause();\n}\n\nint op_unpause(void)\n{\n\tif (op->pcm_ops->unpause == NULL)\n\t\treturn 0;\n\treturn op->pcm_ops->unpause();\n}\n\nint op_buffer_space(void)\n{\n\treturn op->pcm_ops->buffer_space();\n}\n\nint mixer_set_volume(int left, int right)\n{\n\tif (op == NULL)\n\t\treturn -OP_ERROR_NOT_INITIALIZED;\n\tif (!op->mixer_open)\n\t\treturn -OP_ERROR_NOT_OPEN;\n\treturn op->mixer_ops->set_volume(left, right);\n}\n\nint mixer_read_volume(void)\n{\n\tif (op == NULL)\n\t\treturn -OP_ERROR_NOT_INITIALIZED;\n\tif (!op->mixer_open)\n\t\treturn -OP_ERROR_NOT_OPEN;\n\treturn op->mixer_ops->get_volume(&volume_l, &volume_r);\n}\n\nint mixer_get_fds(int what, int *fds)\n{\n\tif (op == NULL)\n\t\treturn -OP_ERROR_NOT_INITIALIZED;\n\tif (!op->mixer_open)\n\t\treturn -OP_ERROR_NOT_OPEN;\n\tswitch (*op->abi_version_ptr) {\n\tcase 1:\n\t\tif (!op->mixer_ops->get_fds.abi_1)\n\t\t\treturn -OP_ERROR_NOT_SUPPORTED;\n\t\tif (what != MIXER_FDS_VOLUME)\n\t\t\treturn 0;\n\t\treturn op->mixer_ops->get_fds.abi_1(fds);\n\tdefault:\n\t\tif (!op->mixer_ops->get_fds.abi_2)\n\t\t\treturn -OP_ERROR_NOT_SUPPORTED;\n\t\treturn op->mixer_ops->get_fds.abi_2(what, fds);\n\t}\n}\n\nextern int soft_vol;\n\nstatic void option_error(int rc)\n{\n\tchar *msg = op_get_error_msg(rc, \"setting option\");\n\terror_msg(\"%s\", msg);\n\tfree(msg);\n}\n\nstatic void set_dsp_option(void *data, const char *val)\n{\n\tconst struct output_plugin_opt *o = data;\n\tint rc;\n\n\trc = o->set(val);\n\tif (rc)\n\t\toption_error(rc);\n}\n\nstatic bool option_of_current_mixer(const struct mixer_plugin_opt *opt)\n{\n\tconst struct mixer_plugin_opt *mpo;\n\n\tif (!op)\n\t\treturn false;\n\tfor (mpo = op->mixer_options; mpo && mpo->name; mpo++) {\n\t\tif (mpo == opt)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic void set_mixer_option(void *data, const char *val)\n{\n\tconst struct mixer_plugin_opt *o = data;\n\tint rc;\n\n\trc = o->set(val);\n\tif (rc) {\n\t\toption_error(rc);\n\t} else if (option_of_current_mixer(o)) {\n\t\t/* option of the current op was set\n\t\t * try to reopen the mixer */\n\t\tmixer_close();\n\t\tif (!soft_vol || pause_on_output_change)\n\t\t\tmixer_open();\n\t}\n}\n\nstatic void get_dsp_option(void *data, char *buf, size_t size)\n{\n\tconst struct output_plugin_opt *o = data;\n\tchar *val = NULL;\n\n\to->get(&val);\n\tif (val) {\n\t\tstrscpy(buf, val, size);\n\t\tfree(val);\n\t}\n}\n\nstatic void get_mixer_option(void *data, char *buf, size_t size)\n{\n\tconst struct mixer_plugin_opt *o = data;\n\tchar *val = NULL;\n\n\to->get(&val);\n\tif (val) {\n\t\tstrscpy(buf, val, size);\n\t\tfree(val);\n\t}\n}\n\nvoid op_add_options(void)\n{\n\tstruct output_plugin *o;\n\tconst struct output_plugin_opt *opo;\n\tconst struct mixer_plugin_opt *mpo;\n\tchar key[64];\n\n\tlist_for_each_entry(o, &op_head, node) {\n\t\tfor (opo = o->pcm_options; opo->name; opo++) {\n\t\t\tsnprintf(key, sizeof(key), \"dsp.%s.%s\", o->name,\n\t\t\t\t\topo->name);\n\t\t\toption_add(xstrdup(key), opo, get_dsp_option,\n\t\t\t\t\tset_dsp_option, NULL, 0);\n\t\t}\n\t\tfor (mpo = o->mixer_options; mpo && mpo->name; mpo++) {\n\t\t\tsnprintf(key, sizeof(key), \"mixer.%s.%s\", o->name,\n\t\t\t\t\tmpo->name);\n\t\t\toption_add(xstrdup(key), mpo, get_mixer_option,\n\t\t\t\t\tset_mixer_option, NULL, 0);\n\t\t}\n\t}\n}\n\nchar *op_get_error_msg(int rc, const char *arg)\n{\n\tchar buffer[1024];\n\n\tswitch (-rc) {\n\tcase OP_ERROR_ERRNO:\n\t\tsnprintf(buffer, sizeof(buffer), \"%s: %s\", arg, strerror(errno));\n\t\tbreak;\n\tcase OP_ERROR_NO_PLUGIN:\n\t\tsnprintf(buffer, sizeof(buffer),\n\t\t\t\t\"%s: no such plugin\", arg);\n\t\tbreak;\n\tcase OP_ERROR_NOT_INITIALIZED:\n\t\tsnprintf(buffer, sizeof(buffer),\n\t\t\t\t\"%s: couldn't initialize required output plugin\", arg);\n\t\tbreak;\n\tcase OP_ERROR_NOT_SUPPORTED:\n\t\tsnprintf(buffer, sizeof(buffer),\n\t\t\t\t\"%s: function not supported\", arg);\n\t\tbreak;\n\tcase OP_ERROR_NOT_OPEN:\n\t\tsnprintf(buffer, sizeof(buffer),\n\t\t\t\t\"%s: mixer is not open\", arg);\n\t\tbreak;\n\tcase OP_ERROR_SAMPLE_FORMAT:\n\t\tsnprintf(buffer, sizeof(buffer),\n\t\t\t\t\"%s: sample format not supported\", arg);\n\t\tbreak;\n\tcase OP_ERROR_NOT_OPTION:\n\t\tsnprintf(buffer, sizeof(buffer),\n\t\t\t\t\"%s: no such option\", arg);\n\t\tbreak;\n\tcase OP_ERROR_INTERNAL:\n\t\tsnprintf(buffer, sizeof(buffer), \"%s: internal error\", arg);\n\t\tbreak;\n\tcase OP_ERROR_SUCCESS:\n\tdefault:\n\t\tsnprintf(buffer, sizeof(buffer),\n\t\t\t\t\"%s: this is not an error (%d), this is a bug\",\n\t\t\t\targ, rc);\n\t\tbreak;\n\t}\n\treturn xstrdup(buffer);\n}\n\nvoid op_dump_plugins(void)\n{\n\tstruct output_plugin *o;\n\n\tprintf(\"\\nOutput Plugins: %s\\n\", plugin_dir);\n\tlist_for_each_entry(o, &op_head, node) {\n\t\tprintf(\"  %s\\n\", o->name);\n\t}\n}\n\nconst char *op_get_current(void)\n{\n\tif (op)\n\t\treturn op->name;\n\treturn NULL;\n}\n"
        },
        {
          "name": "output.h",
          "type": "blob",
          "size": 1.9541015625,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2005 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_OUTPUT_H\n#define CMUS_OUTPUT_H\n\n#include \"sf.h\"\n#include \"channelmap.h\"\n\nextern int volume_max;\nextern int volume_l;\nextern int volume_r;\n\nvoid op_load_plugins(void);\nvoid op_exit_plugins(void);\n\n/*\n * select output plugin and open its mixer\n *\n * errors: OP_ERROR_{ERRNO, NO_PLUGIN}\n */\nint op_select(const char *name);\nint op_select_any(void);\n\n/*\n * open selected plugin\n *\n * errors: OP_ERROR_{}\n */\nint op_open(sample_format_t sf, const channel_position_t *channel_map);\n\n/*\n * drop pcm data\n *\n * errors: OP_ERROR_{ERRNO}\n */\nint op_drop(void);\n\n/*\n * close plugin\n *\n * errors: OP_ERROR_{}\n */\nint op_close(void);\n\n/*\n * returns bytes written or error\n *\n * errors: OP_ERROR_{ERRNO}\n */\nint op_write(const char *buffer, int count);\n\n/*\n * errors: OP_ERROR_{}\n */\nint op_pause(void);\nint op_unpause(void);\n\n/*\n * returns space in output buffer in bytes or -1 if busy\n */\nint op_buffer_space(void);\n\n/*\n * errors: OP_ERROR_{}\n */\nint op_reset(void);\n\nvoid mixer_open(void);\nvoid mixer_close(void);\nint mixer_set_volume(int left, int right);\nint mixer_read_volume(void);\nint mixer_get_fds(int what, int *fds);\n\nvoid op_add_options(void);\nchar *op_get_error_msg(int rc, const char *arg);\nvoid op_dump_plugins(void);\nconst char *op_get_current(void);\n\n#endif\n"
        },
        {
          "name": "path.c",
          "type": "blob",
          "size": 2.787109375,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"path.h\"\n#include \"xmalloc.h\"\n\n#include <stdlib.h>\n#include <unistd.h>\n\nconst char *get_extension(const char *filename)\n{\n\tconst char *ext;\n\n\text = filename + strlen(filename) - 1;\n\twhile (ext >= filename && *ext != '/') {\n\t\tif (*ext == '.') {\n\t\t\text++;\n\t\t\treturn ext;\n\t\t}\n\t\text--;\n\t}\n\treturn NULL;\n}\n\nconst char *path_basename(const char *path)\n{\n\tconst char *f;\n\n\tf = strrchr(path, '/');\n\n\treturn f ? f + 1 : path;\n}\n\nvoid path_strip(char *str)\n{\n\tint i, s, d;\n\n\ti = 0;\n\tif (str[0] == '/')\n\t\ti = 1;\n\twhile (str[i]) {\n\t\tif (str[i] == '/') {\n\t\t\td = i;\n\t\t\ts = i + 1;\n\t\t\twhile (str[s] && str[s] == '/')\n\t\t\t\ts++;\n\t\t\ts--;\n\t\t\tdo {\n\t\t\t\tstr[d++] = str[++s];\n\t\t\t} while (str[s]);\n\t\t} else if (i && str[i] == '.') {\n\t\t\tif (str[i + 1] == '/') {\n\t\t\t\td = i;\n\t\t\t\ts = i + 1;\n\t\t\t\tdo {\n\t\t\t\t\tstr[d++] = str[++s];\n\t\t\t\t} while (str[s]);\n\t\t\t} else if (str[i + 1] == 0) {\n\t\t\t\tstr[i] = 0;\n\t\t\t\tbreak;\n\t\t\t} else if (str[i + 1] == '.' &&\n\t\t\t\t  (str[i + 2] == '/' || str[i + 2] == 0)) {\n\t\t\t\t/* aaa/bbb/../ccc */\n\t\t\t\t/* aaa/ccc */\n\t\t\t\tif (str[i + 2]) {\n\t\t\t\t\ts = i + 3; /* ccc */\n\t\t\t\t} else {\n\t\t\t\t\ts = i + 2;\n\t\t\t\t}\n\t\t\t\td = i - 1; /* /../ccc */\n\t\t\t\tdo {\n\t\t\t\t\tif (d == 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\td--;\n\t\t\t\t} while (str[d] != '/');\n\t\t\t\td++;\n\t\t\t\t/* std[d] is bbb/../ccc */\n\t\t\t\ti = d;\n\t\t\t\ts--;\n\t\t\t\tdo {\n\t\t\t\t\tstr[d++] = str[++s];\n\t\t\t\t} while (str[s]);\n\t\t\t} else {\n\t\t\t\twhile (str[i] && str[i] != '/')\n\t\t\t\t\ti++;\n\t\t\t\tif (str[i])\n\t\t\t\t\ti++;\n\t\t\t}\n\t\t} else {\n\t\t\twhile (str[i] && str[i] != '/')\n\t\t\t\ti++;\n\t\t\tif (str[i])\n\t\t\t\ti++;\n\t\t}\n\t}\n\tif (i > 1 && str[i - 1] == '/')\n\t\tstr[i - 1] = 0;\n}\n\nchar *path_absolute_cwd(const char *src, const char *cwd)\n{\n\tchar *str;\n\n\tif (src[0] == '/') {\n\t\t/* already absolute */\n\t\tstr = xstrdup(src);\n\t} else {\n\t\tint src_len;\n\t\tint cwd_len;\n\n\t\tsrc_len = strlen(src);\n\t\tcwd_len = strlen(cwd);\n\t\tstr = xnew(char, cwd_len + 1 + src_len + 1);\n\t\tmemcpy(str, cwd, cwd_len);\n\t\tstr[cwd_len] = '/';\n\t\tmemcpy(str + cwd_len + 1, src, src_len + 1);\n\t}\n\tpath_strip(str);\n\treturn str;\n}\n\nchar *path_absolute(const char *src)\n{\n\tchar cwd[1024];\n\n\tif (!getcwd(cwd, sizeof(cwd))) {\n\t\tcwd[0] = '/';\n\t\tcwd[1] = 0;\n\t}\n\treturn path_absolute_cwd(src, cwd);\n}\n"
        },
        {
          "name": "path.h",
          "type": "blob",
          "size": 0.9716796875,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_PATH_H\n#define CMUS_PATH_H\n\nconst char *get_extension(const char *filename);\nconst char *path_basename(const char *path);\nvoid path_strip(char *str);\nchar *path_absolute_cwd(const char *src, const char *cwd);\nchar *path_absolute(const char *src);\n\n#endif\n"
        },
        {
          "name": "pcm.c",
          "type": "blob",
          "size": 3.634765625,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"pcm.h\"\n#include \"utils.h\"\n\n#include <stdint.h>\n#include <stdlib.h>\n\n/*\n * Functions to convert PCM to 16-bit signed little-endian stereo\n *\n * Conversion for 8-bit PCM):\n *   1. phase\n *      unsigned -> signed\n *      mono -> stereo\n *      8 -> 16\n *\n * Conversion for 16-bit PCM:\n *   1. phase\n *      be -> le\n *      unsigned -> signed\n *\n *   2. phase\n *      mono -> stereo\n *\n * There's no reason to split 8-bit conversion to 2 phases because we need to\n * use separate buffer for 8->16 conversion anyway.\n *\n * Conversions for 16-bit stereo can be done in place. 16-bit mono needs to be\n * converted to stereo so it's worthwhile to split the conversion to 2 phases.\n */\n\nstatic void convert_u8_1ch_to_s16_2ch(void *dst, const void *src, int count)\n{\n\tint16_t *d = dst;\n\tconst uint8_t *s = src;\n\tint i, j = 0;\n\n\tfor (i = 0; i < count; i++) {\n\t\tint16_t sample = s[i] << 8;\n\t\tsample -= 32768;\n\t\td[j++] = sample;\n\t\td[j++] = sample;\n\t}\n}\n\nstatic void convert_s8_1ch_to_s16_2ch(void *dst, const void *src, int count)\n{\n\tint16_t *d = dst;\n\tconst int8_t *s = src;\n\tint i, j = 0;\n\n\tfor (i = 0; i < count; i++) {\n\t\tint16_t sample = s[i] << 8;\n\t\td[j++] = sample;\n\t\td[j++] = sample;\n\t}\n}\n\nstatic void convert_u8_2ch_to_s16_2ch(void *dst, const void *src, int count)\n{\n\tint16_t *d = dst;\n\tconst int8_t *s = src;\n\tint i;\n\n\tfor (i = 0; i < count; i++) {\n\t\tint16_t sample = s[i] << 8;\n\t\tsample -= 32768;\n\t\td[i] = sample;\n\t}\n}\n\nstatic void convert_s8_2ch_to_s16_2ch(void *dst, const void *src, int count)\n{\n\tint16_t *d = dst;\n\tconst int8_t *s = src;\n\tint i;\n\n\tfor (i = 0; i < count; i++) {\n\t\tint16_t sample = s[i] << 8;\n\t\td[i] = sample;\n\t}\n}\n\nstatic void convert_u16_le_to_s16_le(void *buf, int count)\n{\n\tint16_t *b = buf;\n\tint i;\n\n\tfor (i = 0; i < count; i++) {\n\t\tint sample = (uint16_t)b[i];\n\t\tsample -= 32768;\n\t\tb[i] = sample;\n\t}\n}\n\nstatic void convert_u16_be_to_s16_le(void *buf, int count)\n{\n\tint16_t *b = buf;\n\tint i;\n\n\tfor (i = 0; i < count; i++) {\n\t\tuint16_t u = b[i];\n\t\tint sample;\n\n\t\tu = swap_uint16(u);\n\t\tsample = (int)u - 32768;\n\t\tb[i] = sample;\n\t}\n}\n\nstatic void swap_s16_byte_order(void *buf, int count)\n{\n\tint16_t *b = buf;\n\tint i;\n\n\tfor (i = 0; i < count; i++)\n\t\tb[i] = swap_uint16(b[i]);\n}\n\nstatic void convert_16_1ch_to_16_2ch(void *dst, const void *src, int count)\n{\n\tint16_t *d = dst;\n\tconst int16_t *s = src;\n\tint i, j = 0;\n\n\tfor (i = 0; i < count; i++) {\n\t\td[j++] = s[i];\n\t\td[j++] = s[i];\n\t}\n}\n\n/* index is ((bits >> 2) & 4) | (is_signed << 1) | (channels - 1) */\npcm_conv_func pcm_conv[8] = {\n\tconvert_u8_1ch_to_s16_2ch,\n\tconvert_u8_2ch_to_s16_2ch,\n\tconvert_s8_1ch_to_s16_2ch,\n\tconvert_s8_2ch_to_s16_2ch,\n\n\tconvert_16_1ch_to_16_2ch,\n\tNULL,\n\tconvert_16_1ch_to_16_2ch,\n\tNULL\n};\n\n/* index is ((bits >> 2) & 4) | (is_signed << 1) | bigendian */\npcm_conv_in_place_func pcm_conv_in_place[8] = {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\n\tconvert_u16_le_to_s16_le,\n\tconvert_u16_be_to_s16_le,\n\n#ifdef WORDS_BIGENDIAN\n\tswap_s16_byte_order,\n\tNULL,\n#else\n\tNULL,\n\tswap_s16_byte_order,\n#endif\n};\n"
        },
        {
          "name": "pcm.h",
          "type": "blob",
          "size": 0.9697265625,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_PCM_H\n#define CMUS_PCM_H\n\ntypedef void (*pcm_conv_func)(void *dst, const void *src, int count);\ntypedef void (*pcm_conv_in_place_func)(void *buf, int count);\n\nextern pcm_conv_func pcm_conv[8];\nextern pcm_conv_in_place_func pcm_conv_in_place[8];\n\n#endif\n"
        },
        {
          "name": "pl.c",
          "type": "blob",
          "size": 22.3076171875,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2006 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"pl.h\"\n#include \"prog.h\"\n#include \"editable.h\"\n#include \"options.h\"\n#include \"xmalloc.h\"\n#include \"load_dir.h\"\n#include \"list.h\"\n#include \"job.h\"\n#include \"misc.h\"\n#include \"ui_curses.h\"\n#include \"xstrjoin.h\"\n#include \"worker.h\"\n#include \"uchar.h\"\n#include \"mergesort.h\"\n\n#include <unistd.h>\n#include <stdio.h>\n#include <signal.h>\n\nstruct playlist {\n\tstruct list_head node;\n\n\tchar *name;\n\tstruct editable editable;\n\tstruct rb_root shuffle_root;\n\tstruct simple_track *cur_track;\n};\n\nchar *pl_resume_name;\nunsigned long pl_resume_row;\n\nstatic struct playlist *pl_visible; /* never NULL */\nstatic struct playlist *pl_marked; /* never NULL */\nstruct window *pl_list_win;\n\n/* pl_playing_track shares its track_info reference with the playlist it's in.\n * pl_playing_track and pl_playing might be null but pl_playing_track != NULL\n * implies pl_playing != NULL and pl_playing_track is in pl_playing.\n */\nstatic struct simple_track *pl_playing_track;\nstatic struct playlist *pl_playing;\n\nstatic int pl_cursor_in_track_window;\nstruct editable_shared pl_editable_shared;\nstatic LIST_HEAD(pl_head); /* never empty */\n\nstatic struct searchable *pl_searchable;\n\nstatic char *pl_name_to_pl_file(const char *name)\n{\n\treturn xstrjoin(cmus_playlist_dir, \"/\", name);\n}\n\nstatic void pl_to_iter(struct playlist *pl, struct iter *iter)\n{\n\t*iter = (struct iter) {\n\t\t.data0 = &pl_head,\n\t\t.data1 = &pl->node\n\t};\n}\n\nstatic struct playlist *pl_from_list(const struct list_head *list)\n{\n\treturn container_of(list, struct playlist, node);\n}\n\nstatic struct playlist *pl_from_editable(const struct editable *editable)\n{\n\treturn container_of(editable, struct playlist, editable);\n}\n\nstatic int pl_search_get_generic(struct iter *iter,\n\t\tstruct list_head *(*list_step)(struct list_head *list),\n\t\tint (*iter_step)(struct iter *iter))\n{\n\tstruct list_head *pl_node = iter->data2;\n\tstruct playlist *pl;\n\n\tif (!pl_node)\n\t\tpl_node = &pl_head;\n\n\tif (iter_step(iter))\n\t\treturn 1;\n\n\tpl_node = list_step(pl_node);\n\tif (pl_node == &pl_head)\n\t\treturn 0;\n\n\tpl = pl_from_list(pl_node);\n\titer->data0 = &pl->editable.head;\n\titer->data1 = NULL;\n\titer->data2 = pl_node;\n\treturn 1;\n}\n\nstatic int pl_search_get_prev(struct iter *iter)\n{\n\treturn pl_search_get_generic(iter, list_prev, simple_track_get_prev);\n}\n\nstatic int pl_search_get_next(struct iter *iter)\n{\n\treturn pl_search_get_generic(iter, list_next, simple_track_get_next);\n}\n\nstatic int pl_search_get_current(void *data, struct iter *iter, enum search_direction dir)\n{\n\twindow_get_sel(pl_editable_shared.win, iter);\n\titer->data2 = &pl_visible->node;\n\treturn 1;\n}\n\nstatic int pl_search_matches(void *data, struct iter *iter, const char *text)\n{\n\tstruct playlist *pl = pl_from_list(iter->data2);\n\tint matched = 0;\n\n\tchar **words = get_words(text);\n\tfor (size_t i = 0; words[i]; i++) {\n\n\t\t/* set in the loop to deal with empty search string */\n\t\tmatched = 1;\n\n\t\tif (!u_strcasestr_base(pl->name, words[i])) {\n\t\t\tmatched = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree_str_array(words);\n\n\tif (!matched && iter->data1)\n\t\tmatched = _simple_track_search_matches(iter, text);\n\n\tif (matched) {\n\t\tstruct iter list_iter;\n\t\tpl_to_iter(pl, &list_iter);\n\t\twindow_set_sel(pl_list_win, &list_iter);\n\n\t\teditable_take_ownership(&pl->editable);\n\n\t\tif (iter->data1) {\n\t\t\tstruct iter track_iter = *iter;\n\t\t\ttrack_iter.data2 = NULL;\n\t\t\twindow_set_sel(pl_editable_shared.win, &track_iter);\n\t\t}\n\n\t\tpl_cursor_in_track_window = !!iter->data1;\n\t}\n\n\treturn matched;\n}\n\nstatic const struct searchable_ops pl_searchable_ops = {\n\t.get_prev = pl_search_get_prev,\n\t.get_next = pl_search_get_next,\n\t.get_current = pl_search_get_current,\n\t.matches = pl_search_matches,\n};\n\nstatic void pl_free_track(struct editable *e, struct list_head *item)\n{\n\tstruct playlist *pl = pl_from_editable(e);\n\tstruct simple_track *track = to_simple_track(item);\n\tstruct shuffle_info *shuffle_info = &track->shuffle_info;\n\n\tif (track == pl->cur_track)\n\t\tpl->cur_track = NULL;\n\n\trb_erase(&shuffle_info->tree_node, &pl->shuffle_root);\n\ttrack_info_unref(track->info);\n\tfree(track);\n}\n\nstatic struct playlist *pl_new(const char *name)\n{\n\tstruct playlist *pl = xnew0(struct playlist, 1);\n\tpl->name = xstrdup(name);\n\teditable_init(&pl->editable, &pl_editable_shared, 0);\n\treturn pl;\n}\n\nstatic void pl_free(struct playlist *pl)\n{\n\teditable_clear(&pl->editable);\n\tfree(pl->name);\n\tfree(pl);\n}\n\nstatic void pl_add_track(struct playlist *pl, struct track_info *ti)\n{\n\tstruct simple_track *track = xnew(struct simple_track, 1);\n\n\ttrack_info_ref(ti);\n\tsimple_track_init(track, ti);\n\tshuffle_list_add(&track->shuffle_info, &pl->shuffle_root, NULL);\n\teditable_add(&pl->editable, track);\n}\n\nstatic void pl_loaded(struct playlist *pl)\n{\n\tif (!pl_resume_name || strcmp(pl->name, pl_resume_name) != 0\n\t\t\t|| pl_resume_row >= pl->editable.nr_tracks)\n\t\treturn;\n\n\tstruct list_head *li = pl->editable.head.next;\n\tfor (int i = 0; i < pl_resume_row; i++)\n\t\tli = li->next;\n\tpl_playing_track = to_simple_track(li);\n\tpl_playing = pl;\n\tpl_select_playing_track();\n\n\tfree(pl_resume_name);\n\tpl_resume_name = NULL;\n}\n\nstatic void pl_add_cb(struct track_info *ti, void *opaque)\n{\n\tif (ti)\n\t\tpl_add_track(opaque, ti);\n\telse\n\t\tpl_loaded(opaque);\n}\n\nint pl_add_file_to_marked_pl(const char *file)\n{\n\tchar *full = NULL;\n\tenum file_type type = cmus_detect_ft(file, &full);\n\tint not_invalid = type != FILE_TYPE_INVALID;\n\tif (not_invalid)\n\t\tcmus_add(pl_add_cb, full, type, JOB_TYPE_PL, 0, pl_marked);\n\tfree(full);\n\treturn not_invalid;\n}\n\nvoid pl_add_track_to_marked_pl(struct track_info *ti)\n{\n\tpl_add_track(pl_marked, ti);\n}\n\nstatic int pl_list_compare(const struct list_head *l, const struct list_head *r)\n{\n\tstruct playlist *pl = pl_from_list(l);\n\tstruct playlist *pr = pl_from_list(r);\n\treturn strcmp(pl->name, pr->name);\n}\n\nstatic void pl_sort_all(void)\n{\n\tlist_mergesort(&pl_head, pl_list_compare);\n}\n\nstatic void pl_load_one(const char *file)\n{\n\tchar *full = pl_name_to_pl_file(file);\n\n\tstruct playlist *pl = pl_new(file);\n\tcmus_add(pl_add_cb, full, FILE_TYPE_PL, JOB_TYPE_PL, 0, pl);\n\tlist_add_tail(&pl->node, &pl_head);\n\n\tfree(full);\n}\n\nstatic void pl_load_all(void)\n{\n\tstruct directory dir;\n\tif (dir_open(&dir, cmus_playlist_dir))\n\t\tdie_errno(\"error: cannot open playlist directory %s\", cmus_playlist_dir);\n\tconst char *file;\n\twhile ((file = dir_read(&dir))) {\n\t\tif (strcmp(file, \".\") == 0 || strcmp(file, \"..\") == 0)\n\t\t\tcontinue;\n\t\tif (!S_ISREG(dir.st.st_mode)) {\n\t\t\terror_msg(\"error: %s in %s is not a regular file\", file,\n\t\t\t\t\tcmus_playlist_dir);\n\t\t\tcontinue;\n\t\t}\n\t\tpl_load_one(file);\n\t}\n\tdir_close(&dir);\n}\n\nstatic void pl_create_default(void)\n{\n\tstruct playlist *pl = pl_new(\"Default\");\n\tlist_add_tail(&pl->node, &pl_head);\n}\n\nstatic GENERIC_ITER_PREV(pl_list_get_prev, struct playlist, node);\nstatic GENERIC_ITER_NEXT(pl_list_get_next, struct playlist, node);\n\nstatic void pl_list_sel_changed(void)\n{\n\tstruct list_head *list = pl_list_win->sel.data1;\n\tstruct playlist *pl = pl_from_list(list);\n\tpl_visible = pl;\n\teditable_take_ownership(&pl_visible->editable);\n}\n\nstatic int pl_empty(struct playlist *pl)\n{\n\treturn editable_empty(&pl->editable);\n}\n\nstatic struct simple_track *pl_get_selected_track(void)\n{\n\t/* pl_visible is not empty */\n\n\tstruct iter sel = pl_editable_shared.win->sel;\n\treturn iter_to_simple_track(&sel);\n}\n\nstatic struct simple_track *pl_get_first_track(struct playlist *pl)\n{\n\t/* pl is not empty */\n\n\tif (shuffle) {\n\t\tstruct shuffle_info *si = shuffle_list_get_next(&pl->shuffle_root, NULL, NULL);\n\t\treturn shuffle_info_to_simple_track(si);\n\t} else {\n\t\treturn to_simple_track(pl->editable.head.next);\n\t}\n}\n\nstatic struct track_info *pl_play_track(struct playlist *pl, struct simple_track *t, bool force_follow)\n{\n\t/* t is a track in pl */\n\n\tif (pl != pl_playing)\n\t\tpl_list_win->changed = 1;\n\n\tpl_playing_track = t;\n\tpl_playing = pl;\n\tpl_editable_shared.win->changed = 1;\n\n\tif (force_follow || follow)\n\t\tpl_select_playing_track();\n\n\t/* reference owned by the caller */\n\ttrack_info_ref(pl_playing_track->info);\n\n\treturn pl_playing_track->info;\n}\n\nstatic struct track_info *pl_play_selected_track(void)\n{\n\tif (pl_empty(pl_visible))\n\t\treturn NULL;\n\n\treturn pl_play_track(pl_visible, pl_get_selected_track(), false);\n}\n\nstatic struct track_info *pl_play_first_in_pl_playing(void)\n{\n\tif (!pl_playing)\n\t\tpl_playing = pl_visible;\n\n\tif (pl_empty(pl_playing)) {\n\t\tpl_playing = NULL;\n\t\treturn NULL;\n\t}\n\n\treturn pl_play_track(pl_playing, pl_get_first_track(pl_playing), false);\n}\n\nstatic struct simple_track *pl_get_next(struct playlist *pl, struct simple_track *cur)\n{\n\treturn simple_list_get_next(&pl->editable.head, cur, NULL, true);\n}\n\nstatic struct simple_track *pl_get_next_shuffled(struct playlist *pl,\n\t\tstruct simple_track *cur)\n{\n\tstruct shuffle_info *si = &cur->shuffle_info;\n\tsi = shuffle_list_get_next(&pl->shuffle_root, si, NULL);\n\treturn shuffle_info_to_simple_track(si);\n}\n\nstatic struct simple_track *pl_get_prev(struct playlist *pl,\n\t\tstruct simple_track *cur)\n{\n\treturn simple_list_get_prev(&pl->editable.head, cur, NULL, true);\n}\n\nstatic struct simple_track *pl_get_prev_shuffled(struct playlist *pl,\n\t\tstruct simple_track *cur)\n{\n\tstruct shuffle_info *si = &cur->shuffle_info;\n\tsi = shuffle_list_get_prev(&pl->shuffle_root, si, NULL);\n\treturn shuffle_info_to_simple_track(si);\n}\n\nstatic int pl_match_add_job(uint32_t type, void *job_data, void *opaque)\n{\n\tuint32_t pat = JOB_TYPE_PL | JOB_TYPE_ADD;\n\tif (type != pat)\n\t\treturn 0;\n\n\tstruct add_data *add_data= job_data;\n\treturn add_data->opaque == opaque;\n}\n\nstatic void pl_cancel_add_jobs(struct playlist *pl)\n{\n\tworker_remove_jobs_by_cb(pl_match_add_job, pl);\n}\n\nstatic int pl_save_cb(track_info_cb cb, void *data, void *opaque)\n{\n\tstruct playlist *pl = opaque;\n\treturn editable_for_each(&pl->editable, cb, data, 0);\n}\n\nstatic void pl_save_one(struct playlist *pl)\n{\n\tchar *path = pl_name_to_pl_file(pl->name);\n\tcmus_save(pl_save_cb, path, pl);\n\tfree(path);\n}\n\nstatic void pl_save_all(void)\n{\n\tstruct playlist *pl;\n\tlist_for_each_entry(pl, &pl_head, node)\n\t\tpl_save_one(pl);\n}\n\nstatic void pl_delete(struct playlist *pl)\n{\n\tif (list_len(&pl_head) == 1)\n\t\tpl_create_default();\n\n\tstruct iter iter;\n\tpl_to_iter(pl, &iter);\n\twindow_row_vanishes(pl_list_win, &iter);\n\n\tlist_del(&pl->node);\n\n\tif (pl == pl_marked)\n\t\tpl_marked = pl_visible;\n\tif (pl == pl_playing) {\n\t\tpl_playing = NULL;\n\t\tpl_playing_track = NULL;\n\t}\n\n\tchar *path = pl_name_to_pl_file(pl->name);\n\tunlink(path);\n\tfree(path);\n\n\tpl_cancel_add_jobs(pl);\n\n\t/* can't free the pl now because the worker thread might hold a\n\t * reference to it. instead free it once all running jobs are done.\n\t */\n\tstruct pl_delete_data *pdd = xnew(struct pl_delete_data, 1);\n\tpdd->cb = pl_free;\n\tpdd->pl = pl;\n\tjob_schedule_pl_delete(pdd);\n}\n\nstatic void pl_delete_selected_pl(void)\n{\n\tif (yes_no_query(\"Delete selected playlist? [y/N]\") != UI_QUERY_ANSWER_YES)\n\t\treturn;\n\n\tpl_delete(pl_visible);\n}\n\nvoid pl_delete_by_name(char *name)\n{\n\tstruct playlist *pl;\n\tlist_for_each_entry(pl, &pl_head, node) {\n\t\tif (strcmp(pl->name, name) == 0) {\n\t\t\tpl_delete(pl);\n\t\t\treturn;\n\t\t}\n\t}\n\terror_msg(\"couldn't find a playlist named '%s' to delete\", name);\n}\n\nvoid pl_delete_all(void)\n{\n\tstruct playlist *pl;\n\tstruct playlist *temp;\n\tlist_for_each_entry_safe(pl, temp, &pl_head, node) {\n\t\tif (list_len(&pl_head) == 1)\n\t\t\tbreak;\n\t\tpl_delete(pl);\n\t}\n\tpl_delete(pl);\n}\n\nstatic void pl_mark_selected_pl(void)\n{\n\tpl_marked = pl_visible;\n\tpl_list_win->changed = 1;\n}\n\ntypedef struct simple_track *(*pl_shuffled_move)(struct playlist *pl,\n\t\tstruct simple_track *cur);\ntypedef struct simple_track *(*pl_normal_move)(struct playlist *pl,\n\t\tstruct simple_track *cur);\n\nstatic struct track_info *pl_goto_generic(pl_shuffled_move shuffled,\n\t\tpl_normal_move normal)\n{\n\tif (!pl_playing_track)\n\t\treturn pl_play_first_in_pl_playing();\n\n\tstruct simple_track *track;\n\n\tif (shuffle)\n\t\ttrack = shuffled(pl_playing, pl_playing_track);\n\telse\n\t\ttrack = normal(pl_playing, pl_playing_track);\n\n\tif (track)\n\t\treturn pl_play_track(pl_playing, track, false);\n\treturn NULL;\n}\n\nstatic void pl_clear_visible_pl(void)\n{\n\tif (pl_cursor_in_track_window)\n\t\tpl_win_next();\n\tif (pl_visible == pl_playing)\n\t\tpl_playing_track = NULL;\n\teditable_clear(&pl_visible->editable);\n\tpl_cancel_add_jobs(pl_visible);\n}\n\nstatic int pl_name_exists(const char *name)\n{\n\tstruct playlist *pl;\n\tlist_for_each_entry(pl, &pl_head, node) {\n\t\tif (strcmp(pl->name, name) == 0)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int pl_check_new_pl_name(const char *name)\n{\n\tif (strchr(name, '/')) {\n\t\terror_msg(\"playlists cannot contain the '/' character\");\n\t\treturn 0;\n\t}\n\n\tif (pl_name_exists(name)) {\n\t\terror_msg(\"another playlist named %s already exists\", name);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic char *pl_create_name(const char *file)\n{\n\tsize_t file_len = strlen(file);\n\n\tchar *name = xnew(char, file_len + 10);\n\tstrcpy(name, file);\n\n\tfor (int i = 1; pl_name_exists(name); i++) {\n\t\tif (i == 100) {\n\t\t\tfree(name);\n\t\t\treturn NULL;\n\t\t}\n\t\tsprintf(name + file_len, \".%d\", i);\n\t}\n\n\treturn name;\n}\n\nstatic void pl_delete_selected_track(void)\n{\n\t/* pl_cursor_in_track_window == true */\n\n\tif (pl_get_selected_track() == pl_playing_track)\n\t\tpl_playing_track = NULL;\n\teditable_remove_sel(&pl_visible->editable);\n\tif (pl_empty(pl_visible))\n\t\tpl_win_next();\n}\n\nvoid pl_init(void)\n{\n\teditable_shared_init(&pl_editable_shared, pl_free_track);\n\n\tpl_load_all();\n\tif (list_empty(&pl_head))\n\t\tpl_create_default();\n\n\tpl_sort_all();\n\n\tpl_list_win = window_new(pl_list_get_prev, pl_list_get_next);\n\tpl_list_win->sel_changed = pl_list_sel_changed;\n\twindow_set_contents(pl_list_win, &pl_head);\n\twindow_changed(pl_list_win);\n\n\t/* pl_visible set by window_set_contents */\n\tpl_marked = pl_visible;\n\n\tstruct iter iter = { 0 };\n\tpl_searchable = searchable_new(NULL, &iter, &pl_searchable_ops);\n}\n\nvoid pl_init_options(void)\n{\n\tif (auto_hide_playlists_panel)\n\t\tpl_cursor_in_track_window = 1;\n}\n\nvoid pl_exit(void)\n{\n\tpl_save_all();\n}\n\nvoid pl_save(void)\n{\n\tpl_save_all();\n}\n\nvoid pl_import(const char *path)\n{\n\tconst char *file = get_filename(path);\n\tif (!file) {\n\t\terror_msg(\"\\\"%s\\\" is not a valid path\", path);\n\t\treturn;\n\t}\n\n\tchar *name = pl_create_name(file);\n\tif (!name) {\n\t\terror_msg(\"a playlist named \\\"%s\\\" already exists \", file);\n\t\treturn;\n\t}\n\n\tif (strcmp(name, file) != 0)\n\t\tinfo_msg(\"adding \\\"%s\\\" as \\\"%s\\\"\", file, name);\n\n\tstruct playlist *pl = pl_new(name);\n\tcmus_add(pl_add_cb, path, FILE_TYPE_PL, JOB_TYPE_PL, 0, pl);\n\tlist_add_tail(&pl->node, &pl_head);\n\tpl_list_win->changed = 1;\n\n\tfree(name);\n}\n\nvoid pl_export_selected_pl(const char *path)\n{\n\tchar *tmp = expand_filename(path);\n\tif (access(tmp, F_OK) != 0 || yes_no_query(\"File exists. Overwrite? [y/N]\") == UI_QUERY_ANSWER_YES)\n\t\tcmus_save(pl_save_cb, tmp, pl_visible);\n\tfree(tmp);\n}\n\nstruct searchable *pl_get_searchable(void)\n{\n\treturn pl_searchable;\n}\n\nstruct track_info *pl_goto_next(void)\n{\n\treturn pl_goto_generic(pl_get_next_shuffled, pl_get_next);\n}\n\nstruct track_info *pl_goto_prev(void)\n{\n\treturn pl_goto_generic(pl_get_prev_shuffled, pl_get_prev);\n}\n\nstruct track_info *pl_play_selected_row(void)\n{\n\t/* a bit tricky because we want to insert the selected track at the\n\t * current position in the shuffle list. but we must be careful not to\n\t * insert a track into a foreign shuffle list.\n\t */\n\n\tint was_in_track_window = pl_cursor_in_track_window;\n\n\tstruct playlist *prev_pl = pl_playing;\n\tstruct simple_track *prev_track = pl_playing_track;\n\n\tstruct track_info *rv = NULL;\n\n\tif (!pl_cursor_in_track_window) {\n\t\tif (shuffle && !pl_empty(pl_visible)) {\n\t\t\tstruct shuffle_info *si = shuffle_list_get_next(&pl_visible->shuffle_root, NULL, NULL);\n\t\t\tstruct simple_track *track = shuffle_info_to_simple_track(si);\n\t\t\trv = pl_play_track(pl_visible, track, true);\n\t\t}\n\t}\n\n\tif (!rv)\n\t\trv = pl_play_selected_track();\n\n\tif (shuffle && rv && (pl_playing == prev_pl) && prev_track) {\n\t\tstruct shuffle_info *prev_si = &prev_track->shuffle_info;\n\t\tstruct shuffle_info *cur_si = &pl_playing_track->shuffle_info;\n\t\tshuffle_insert(&pl_playing->shuffle_root, prev_si, cur_si);\n\t}\n\n\tpl_cursor_in_track_window = was_in_track_window;\n\n\treturn rv;\n}\n\nvoid pl_select_playing_track(void)\n{\n\tif (!pl_playing_track)\n\t\treturn;\n\n\tstruct iter iter;\n\n\teditable_take_ownership(&pl_playing->editable);\n\n\teditable_track_to_iter(&pl_playing->editable, pl_playing_track, &iter);\n\twindow_set_sel(pl_editable_shared.win, &iter);\n\n\tpl_to_iter(pl_playing, &iter);\n\twindow_set_sel(pl_list_win, &iter);\n\n\tif (!pl_cursor_in_track_window)\n\t\tpl_mark_for_redraw();\n\n\tpl_cursor_in_track_window = 1;\n}\n\nvoid pl_reshuffle(void)\n{\n\tif (pl_playing) {\n\t\tshuffle_list_reshuffle(&pl_playing->shuffle_root);\n\t\tif (pl_playing_track)\n\t\t\tshuffle_insert(&pl_playing->shuffle_root, NULL, &pl_playing_track->shuffle_info);\n\t}\n}\n\nvoid pl_get_sort_str(char *buf, size_t size)\n{\n\tstrscpy(buf, pl_editable_shared.sort_str, size);\n}\n\nvoid pl_set_sort_str(const char *buf)\n{\n\tsort_key_t *keys = parse_sort_keys(buf);\n\n\tif (!keys)\n\t\treturn;\n\n\teditable_shared_set_sort_keys(&pl_editable_shared, keys);\n\tsort_keys_to_str(keys, pl_editable_shared.sort_str,\n\t\t\tsizeof(pl_editable_shared.sort_str));\n\n\tstruct playlist *pl;\n\tlist_for_each_entry(pl, &pl_head, node)\n\t\teditable_sort(&pl->editable);\n}\n\nvoid pl_rename_selected_pl(const char *name)\n{\n\tif (strcmp(pl_visible->name, name) == 0)\n\t\treturn;\n\n\tif (!pl_check_new_pl_name(name))\n\t\treturn;\n\n\tchar *full_cur = pl_name_to_pl_file(pl_visible->name);\n\tchar *full_new = pl_name_to_pl_file(name);\n\trename(full_cur, full_new);\n\tfree(full_cur);\n\tfree(full_new);\n\n\tfree(pl_visible->name);\n\tpl_visible->name = xstrdup(name);\n\n\tpl_mark_for_redraw();\n}\n\nvoid pl_clear(void)\n{\n\tif (!pl_cursor_in_track_window)\n\t\treturn;\n\n\tpl_clear_visible_pl();\n}\n\nvoid pl_mark_for_redraw(void)\n{\n\tpl_list_win->changed = 1;\n\tpl_editable_shared.win->changed = 1;\n}\n\nint pl_needs_redraw(void)\n{\n\treturn pl_list_win->changed || pl_editable_shared.win->changed;\n}\n\nstruct window *pl_cursor_win(void)\n{\n\tif (pl_cursor_in_track_window)\n\t\treturn pl_editable_shared.win;\n\telse\n\t\treturn pl_list_win;\n}\n\nint _pl_for_each_sel(track_info_cb cb, void *data, int reverse)\n{\n\tif (pl_cursor_in_track_window)\n\t\treturn _editable_for_each_sel(&pl_visible->editable, cb, data, reverse);\n\telse\n\t\treturn editable_for_each(&pl_visible->editable, cb, data, reverse);\n}\n\nint pl_for_each_sel(track_info_cb cb, void *data, int reverse, int advance)\n{\n\tif (pl_cursor_in_track_window)\n\t\treturn editable_for_each_sel(&pl_visible->editable, cb, data, reverse, advance);\n\telse\n\t\treturn editable_for_each(&pl_visible->editable, cb, data, reverse);\n}\n\n#define pl_tw_only(cmd) if (!pl_cursor_in_track_window) { \\\n\tinfo_msg(\":%s only works in the track window\", cmd); \\\n} else\n\nvoid pl_invert_marks(void)\n{\n\tpl_tw_only(\"invert\")\n\t\teditable_invert_marks(&pl_visible->editable);\n}\n\nvoid pl_mark(char *arg)\n{\n\tpl_tw_only(\"mark\")\n\t\teditable_mark(&pl_visible->editable, arg);\n}\n\nvoid pl_unmark(void)\n{\n\tpl_tw_only(\"unmark\")\n\t\teditable_unmark(&pl_visible->editable);\n}\n\nvoid pl_rand(void)\n{\n\tpl_tw_only(\"rand\")\n\t\teditable_rand(&pl_visible->editable);\n}\n\nvoid pl_win_mv_after(void)\n{\n\tif (pl_cursor_in_track_window)\n\t\teditable_move_after(&pl_visible->editable);\n}\n\nvoid pl_win_mv_before(void)\n{\n\tif (pl_cursor_in_track_window)\n\t\teditable_move_before(&pl_visible->editable);\n}\n\nvoid pl_win_remove(void)\n{\n\tif (pl_cursor_in_track_window)\n\t\tpl_delete_selected_track();\n\telse\n\t\tpl_delete_selected_pl();\n}\n\nvoid pl_win_toggle(void)\n{\n\tif (pl_cursor_in_track_window)\n\t\teditable_toggle_mark(&pl_visible->editable);\n\telse\n\t\tpl_mark_selected_pl();\n}\n\nvoid pl_win_update(void)\n{\n\tif (yes_no_query(\"Reload this playlist? [y/N]\") != UI_QUERY_ANSWER_YES)\n\t\treturn;\n\n\tpl_clear_visible_pl();\n\n\tchar *full = pl_name_to_pl_file(pl_visible->name);\n\tcmus_add(pl_add_cb, full, FILE_TYPE_PL, JOB_TYPE_PL, 0, pl_visible);\n\tfree(full);\n}\n\nvoid pl_win_next(void)\n{\n\tpl_cursor_in_track_window ^= 1;\n\tif (pl_empty(pl_visible))\n\t\tpl_cursor_in_track_window = 0;\n\tpl_mark_for_redraw();\n}\n\nvoid pl_set_nr_rows(int h)\n{\n\twindow_set_nr_rows(pl_list_win, h);\n\twindow_set_nr_rows(pl_editable_shared.win, h);\n}\n\nbool pl_show_panel(void)\n{\n\treturn !auto_hide_playlists_panel || !pl_cursor_in_track_window;\n}\n\nchar *pl_visible_get_name(void)\n{\n\treturn pl_visible->name;\n}\n\nunsigned int pl_visible_total_time(void)\n{\n\treturn pl_visible->editable.total_time;\n}\n\nunsigned int pl_playing_total_time(void)\n{\n\tif (pl_playing)\n\t\treturn pl_playing->editable.total_time;\n\treturn 0;\n}\n\nvoid pl_list_iter_to_info(struct iter *iter, struct pl_list_info *info)\n{\n\tstruct playlist *pl = pl_from_list(iter->data1);\n\n\tinfo->name = pl->name;\n\tinfo->marked = pl == pl_marked;\n\tinfo->active = !pl_cursor_in_track_window;\n\tinfo->selected = pl == pl_visible;\n\tinfo->current = pl == pl_playing;\n}\n\nvoid pl_draw(void (*list)(struct window *win),\n\t\tvoid (*tracks)(struct window *win), int full)\n{\n\tif (full || pl_list_win->changed)\n\t\tlist(pl_list_win);\n\tif (full || pl_editable_shared.win->changed)\n\t\ttracks(pl_editable_shared.win);\n\tpl_list_win->changed = 0;\n\tpl_editable_shared.win->changed = 0;\n}\n\nstruct simple_track *pl_get_playing_track(void)\n{\n\treturn pl_playing_track;\n}\n\nvoid pl_update_track(struct track_info *old, struct track_info *new)\n{\n\tstruct playlist *pl;\n\tlist_for_each_entry(pl, &pl_head, node)\n\t\teditable_update_track(&pl->editable, old, new);\n}\n\nint pl_get_cursor_in_track_window(void)\n{\n\treturn pl_cursor_in_track_window;\n}\n\nvoid pl_create(const char *name)\n{\n\tif (!pl_check_new_pl_name(name))\n\t\treturn;\n\n\tstruct playlist *pl = pl_new(name);\n\tlist_add_tail(&pl->node, &pl_head);\n\tpl_list_win->changed = 1;\n}\n\nint pl_visible_is_marked(void)\n{\n\treturn pl_visible == pl_marked;\n}\n\nconst char *pl_marked_pl_name(void)\n{\n\treturn pl_marked->name;\n}\n\nvoid pl_set_marked_pl_by_name(const char *name)\n{\n\tstruct playlist *pl;\n\tlist_for_each_entry(pl, &pl_head, node) {\n\t\tif (strcmp(pl->name, name) == 0) {\n\t\t\tpl_marked = pl;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nconst char *pl_playing_pl_name(void)\n{\n\treturn pl_playing ? pl_playing->name : NULL;\n}\n\nint pl_playing_pl_row(void)\n{\n\tstruct list_head *li;\n\tint n = 0;\n\n\tif (!pl_playing_track)\n\t\treturn n;\n\n\tlist_for_each(li, &pl_playing->editable.head) {\n\t\tif (li == &pl_playing_track->node)\n\t\t\tbreak;\n\t\tn++;\n\t}\n\treturn n;\n}\n"
        },
        {
          "name": "pl.h",
          "type": "blob",
          "size": 3.166015625,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2006 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_PL_H\n#define CMUS_PL_H\n\n#include \"track_info.h\"\n#include \"window.h\"\n#include \"editable.h\"\n#include \"cmus.h\"\n\nstruct pl_list_info {\n\tconst char *name;\n\tunsigned marked : 1;\n\tunsigned active : 1;\n\tunsigned selected : 1;\n\tunsigned current : 1;\n};\n\nextern struct window *pl_list_win;\nextern struct editable_shared pl_editable_shared;\n\nextern char *pl_resume_name;\nextern unsigned long pl_resume_row;\n\nvoid pl_init(void);\nvoid pl_init_options(void);\nvoid pl_exit(void);\nvoid pl_save(void);\nvoid pl_import(const char *path);\nvoid pl_export_selected_pl(const char *path);\nstruct searchable *pl_get_searchable(void);\nint pl_add_file_to_marked_pl(const char *file);\nvoid pl_add_track_to_marked_pl(struct track_info *ti);\nvoid pl_rename_selected_pl(const char *name);\nvoid pl_create(const char *name);\nvoid pl_get_sort_str(char *buf, size_t size);\nvoid pl_set_sort_str(const char *buf);\nvoid pl_clear(void);\nstruct track_info *pl_goto_next(void);\nstruct track_info *pl_goto_prev(void);\nstruct track_info *pl_play_selected_row(void);\nvoid pl_select_playing_track(void);\nvoid pl_reshuffle(void);\nint _pl_for_each_sel(track_info_cb cb, void *data, int reverse);\nint pl_for_each_sel(track_info_cb cb, void *data, int reverse, int advance);\nvoid pl_reload_visible(void);\nstruct window *pl_cursor_win(void);\nvoid pl_set_nr_rows(int h);\nbool pl_show_panel(void);\nchar *pl_visible_get_name(void);\nunsigned int pl_visible_total_time(void);\nunsigned int pl_playing_total_time(void);\nstruct simple_track *pl_get_playing_track(void);\nvoid pl_update_track(struct track_info *old, struct track_info *new);\nint pl_get_cursor_in_track_window(void);\nint pl_visible_is_marked(void);\nconst char *pl_marked_pl_name(void);\nvoid pl_set_marked_pl_by_name(const char *name);\nconst char *pl_playing_pl_name(void);\nint pl_playing_pl_row(void);\n\nvoid pl_mark_for_redraw(void);\nint pl_needs_redraw(void);\nvoid pl_draw(void (*list)(struct window *win),\n\t\tvoid (*tracks)(struct window *win), int full);\nvoid pl_list_iter_to_info(struct iter *iter, struct pl_list_info *info);\n\nstatic inline void pl_add_track_to_marked_pl2(struct track_info *ti,\n\t\tvoid *opaque)\n{\n\tpl_add_track_to_marked_pl(ti);\n}\n\n/* cmd wrappers */\n\nvoid pl_invert_marks(void);\nvoid pl_mark(char *arg);\nvoid pl_unmark(void);\nvoid pl_rand(void);\nvoid pl_delete_all(void);\nvoid pl_delete_by_name(char *arg);\nvoid pl_win_mv_after(void);\nvoid pl_win_mv_before(void);\nvoid pl_win_remove(void);\nvoid pl_win_toggle(void);\nvoid pl_win_update(void);\nvoid pl_win_next(void);\n\n#endif\n"
        },
        {
          "name": "pl_env.c",
          "type": "blob",
          "size": 5.9462890625,
          "content": "/*\n * Copyright 2021-2023 Patrick Gaskin\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"pl_env.h\"\n#include \"options.h\"\n#include \"xmalloc.h\"\n\n#include <ctype.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <string.h>\n\nextern char **environ;\nstatic char **pl_env_cache = NULL;\n\nstatic bool pl_env_contains_delimiter(const char *str)\n{\n\treturn !!strchr(str, PL_ENV_DELIMITER);\n}\n\n/**\n * pl_env_norm gets an env var and puts it into the required format for\n * pl_env_reduce and pl_env_expand, which does exact string matching/replacement\n * against the file paths. It converts backslashes to slashes on Windows,\n * removes consecutive slashes, removes './' path segments, simplifies '../'\n * path segments (and returns NULL if it would result in going above the\n * uppermost directory), and removes the trailing slash. In addition, it trims\n * the variable name before looking it up.\n */\nstatic char *pl_env_norm(char *path)\n{\n#ifdef _WIN32\n\t/* convert backslashes to slashes */\n\t/* note: cmus uses forward slashes internally, but Windows accepts both */\n\t/* even though they will get normalized on windows, we need paths to match exactly */\n\tfor (char *p = path; *p; p++)\n\t\t*p = *p == '\\\\' ? '/' : *p;\n#endif\n\n\t/* canonicalize the path in-place */\n\tsize_t r = 1, w = 1;\n\twhile (path[r]) {\n\n\t\t/* handle the start of a segment */\n\t\tif (w == 0 || path[w-1] == '/') {\n\n\t\t\t/* handle empty segments */\n\t\t\tif (path[r] == '/') {\n\n\t\t\t\t/* skip the duplicate slashes */\n\t\t\t\twhile (path[r] == '/') r++;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* handle '.' segments */\n\t\t\tif (path[r] == '.' && (path[r+1] == '/' || !path[r+1])) {\n\n\t\t\t\t/* skip them */\n\t\t\t\tif (path[r += 1]) r++;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* handle '..' segments */\n\t\t\tif (path[r] == '.' && path[r+1] == '.' && (path[r+2] == '/' || !path[r+2])) {\n\n\t\t\t\t/* if there aren't any parent directories left to skip, return NULL */\n\t\t\t\tif (!w) return NULL;\n\n\t\t\t\t/* remove the previous segment up to the '/' */\n\t\t\t\tfor (w--; w && path[w-1] != '/'; ) w--;\n\n\t\t\t\t/* skip the '..' */\n\t\t\t\tif (path[r += 2]) r++;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* write the next character */\n\t\tpath[w++] = path[r++];\n\t}\n\n\t/* remove the trailing slash if the path isn't / */\n\tif (w >= 2 && path[w-1] == '/') {\n\t\tw--;\n\t}\n\n\t/* terminate the path */\n\tpath[w] = '\\0';\n\n\treturn path;\n}\n\n/**\n * pl_env_get is like getenv, but it allows using non-null-terminated variable\n * names, trims the variable name, ensures the environment variable doesn't\n * contain the marker used by pl_env, and normalizes the paths in environment\n * variables with pl_env_norm.\n */\nstatic const char *pl_env_get(const char *var, int var_len)\n{\n\tif (!var)\n\t\treturn NULL;\n\n\tsize_t vl = var_len == -1\n\t\t? strlen(var)\n\t\t: var_len;\n\n\tconst char *vs = var;\n\tconst char *ve = var + vl;\n\twhile (vs < ve && isspace(*vs)) vs++;\n\twhile (ve > vs && isspace(*(ve-1))) ve--;\n\tvl = ve-vs;\n\n\tif (!vl)\n\t\treturn NULL;\n\n\tfor (const char *c = vs; c < ve; c++)\n\t\tif (*c == PL_ENV_DELIMITER || *c == '=')\n\t\t\treturn NULL;\n\n\tfor (char **x = pl_env_cache; x && *x; x++)\n\t\tif (strncmp(*x, vs, vl) == 0 && (*x)[vl] == '=')\n\t\t\treturn *x + vl + 1;\n\n\treturn NULL;\n}\n\nvoid pl_env_init(void)\n{\n\tfor (char **x = pl_env_cache; x && *x; x++)\n\t\tfree(*x);\n\tfree(pl_env_cache);\n\n\tsize_t n = 0;\n\tfor (char **x = environ; *x; x++)\n\t\tn++;\n\n\tchar **new = pl_env_cache = xnew(char*, n+1);\n\tfor (char **x = environ; *x; x++)\n\t\tif (!pl_env_contains_delimiter(*x))\n\t\t\tif (!pl_env_norm(strchr((*new++ = xstrdup(*x)), '=') + 1))\n\t\t\t\tfree(*--new);\n\t*new = NULL;\n}\n\nchar *pl_env_reduce(const char *path)\n{\n\tif (!pl_env_vars || !*pl_env_vars || pl_env_var(path, NULL))\n\t\treturn xstrdup(path);\n\n\tfor (char **var = pl_env_vars; *var && **var; var++) {\n\t\tconst char *val = pl_env_get(*var, -1);\n\t\tif (!val)\n\t\t\tcontinue;\n\n\t\tsize_t val_len = strlen(val);\n\n#ifdef _WIN32\n\t\tif (strncasecmp(path, val, val_len) != 0)\n\t\t\tcontinue;\n#else\n\t\tif (strncmp(path, val, val_len) != 0)\n\t\t\tcontinue;\n#endif\n\n\t\tconst char *rem = path + val_len;\n\n\t\t/* always keep the slash at the beginning of the path, and only\n\t\t   use the env var if it replaces an entire path component (i.e.\n\t\t   it is a directory) */\n\t\tif (*rem != '/')\n\t\t\tcontinue;\n\n\t\tsize_t var_len = strlen(*var);\n\t\tsize_t rem_len = strlen(rem);\n\n\t\tchar *new, *ptr;\n\t\tnew = ptr = xmalloc(1+var_len+1+rem_len+1);\n\t\t*ptr++ = PL_ENV_DELIMITER;\n\t\tstrncpy(ptr, *var, var_len);\n\t\tptr += var_len;\n\t\t*ptr++ = PL_ENV_DELIMITER;\n\t\tstrcpy(ptr, rem);\n\t\tptr += rem_len;\n\t\t*ptr = '\\0';\n\n\t\treturn new;\n\t}\n\n\treturn xstrdup(path);\n}\n\nchar *pl_env_expand(const char *path)\n{\n\tif (!path)\n\t\treturn NULL;\n\n\tint len;\n\tconst char *var;\n\tif (!(var = pl_env_var(path, &len)))\n\t\treturn xstrdup(path);\n\n\tconst char *val = pl_env_get(var, len);\n\tif (!val)\n\t\treturn xstrdup(path);\n\n\tconst char *rem = pl_env_var_remainder(path, len);\n\tsize_t val_len = strlen(val);\n\tsize_t rem_len = strlen(rem);\n\n\tchar *new, *ptr;\n\tnew = ptr = xmalloc(val_len+rem_len+1);\n\tstrcpy(ptr, val);\n\tptr += val_len;\n\tstrcpy(ptr, rem);\n\tptr += rem_len;\n\t*ptr = '\\0';\n\n\treturn new;\n}\n\nconst char *pl_env_var(const char *path, int *out_length)\n{\n\tconst char *end;\n\tif (!path || *path++ != PL_ENV_DELIMITER)\n\t\treturn NULL;\n\tif (!(end = strrchr(path, PL_ENV_DELIMITER)) || path == end)\n\t\treturn NULL;\n\tif (out_length)\n\t\t*out_length = (int) (end-path);\n\treturn path;\n}\n\nconst char *pl_env_var_remainder(const char *path, int length)\n{\n\treturn path+length+2;\n}\n\nint pl_env_var_len(const char *path)\n{\n\tint len;\n\treturn pl_env_var(path, &len) ? len : 0;\n}\n"
        },
        {
          "name": "pl_env.h",
          "type": "blob",
          "size": 10.08984375,
          "content": "/*\n * Copyright 2021 Patrick Gaskin\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_PL_ENV_H\n#define CMUS_PL_ENV_H\n\n/**\n * ABOUT\n *   This file contains functions related to the pl_env_vars configuration\n *   option, which allows the library to be relocated by specifying a list of\n *   environment variables to use instead of the base path they contain when\n *   saving library/playlist and cache paths.\n *\n * CONFIGURATION\n * - options.h / pl_env_vars\n *   The array of environment variables to substitute. These are checked in the\n *   order they are specified in, and the first matching variable is used.\n *   Note that it is safe for the configuration to be changed regardless of if\n *   cmus is currently running, but cmus must be restarted for this to take full\n *   effect.\n *\n * - options.c / get_pl_env_vars + set_pl_env_vars\n *   Encodes and decodes the config entry to/from a comma-separated list.\n *\n * SUBSTITUTION\n * - cmus.c / save_playlist_cb\n *   Where the in-memory library/playlists are written on exit.\n *\n *   Paths are transformed into the versions with env var substitutions here to\n *   allow tracks to be relocated based on the path in the env var.\n *\n * - job.c / handle_line\n *   Where the on-disk library/playlists are parsed on startup.\n *\n *   Paths are subsituted from environment variables here as the inverse of\n *   save_playlist_cb.\n *\n * - cache.c / write_ti\n *   Where the in-memory track_info's are converted into cache entries, which\n *   are written to the on-disk cache file.\n *\n *   Paths are transformed into the versions with env var substitutions here to\n *   allow metadata (including the play count) to follow the track regardless of\n *   its real on-disk location.\n *\n * - cache.c / cache_entry_to_ti\n *   Where the on-disk cache entries are parsed into the in-memory hashtable of\n *   read/write track_info's on startup.\n *\n *   Paths are subsituted from environment variables here as the inverse of\n *   write_ti.\n *\n * - cache.c / cache_get_ti\n *   Where cmus reads the metadata for tracks when reading the library/playlists\n *   at startup, or when the user adds a track.\n *\n *   This is important because if this returns an error, the track is removed\n *   from the library/playlist. Since we don't want the user to lose their\n *   tracks if one of their environment variables in pl_env_vars was unset\n *   mistakenly, we just return a dummy track if the filename still contains a\n *   substitution.\n *\n * - player.c / _producer_play\n *   Where track playback is started and errors are handled.\n *\n *   If the error is due to a missing env var (see cache_get_ti above), we add\n *   to the error message so the cause is clear.\n *\n * FAQ\n * - Why use '\\x1F' as the delimiter?\n *   1. To prevent compatibility issues if the user happened to use unusual\n *      characters in their filenames. Control characters like this one will not\n *      generally be found in filenames on any platform.\n *   2. This is the ASCII \"Unit Separator\" control character, which is supposed\n *      to be an (old-fashioned) invisible delimiter, which makes sense for our\n *      purposes.\n *   3. Since it is invisible, we don't need to deal with everywhere it might be\n *      printed to the UI if it is not substituted by pl_env_expand (i.e. if\n *      the env var is missing or invalid).\n *\n * - Why not remove the substitution if the env var is missing or invalid?\n *   1. When combined with the invisibility of the delimiter, this allows us to\n *      easily show the user the missing env var without needing to hook into\n *      all of the UI printing/formatting code.\n *   2. See the part above about cache_get_ti for a technical reason why we\n *      leave missing env var substitutions in.\n *\n * - What other approaches were considered?\n *   1. Using relative paths and resolving the filenames passed to input\n *      plugins. This would have required rewriting the library/playlist and\n *      cache code to handle relative paths, and would have resulted in a high\n *      risk of regressions and taken a long time to implement.\n *   2. Wrapping the filesystem functions. This is simpler to implement than the\n *      previous option, but even more risky.\n *   3. Same as this approach, but using native OS env var syntax. This would be\n *      significantly more complex to implement, and is likely to cause\n *      compatibility issues requiring manual intervention.\n *   4. Adding a configuration option for a base directory, and only storing\n *      relative paths against that. This seems simple at first, but it's has\n *      all the disadvantages of the aforementioned approaches, is more complex\n *      to implement, makes it harder to handle configuration changes while cmus\n *      is not running, and is a lot less flexible.\n *\n * - What are the advantages of this approach?\n *    1. This approach is mostly self-contained. There are very few places which\n *       this needs to hook, and the mechanism is easy to reason about.\n *    2. This approach works well with cmus. It takes advantage of the way it\n *       keeps all metadata in-memory during runtime.\n *    3. This approach does not have a risk of causing compatibility issues,\n *       behaviour changes, or regressions for users who do not enable this\n *       feature.\n *    4. This approach can handle configuration changes regardless of whether\n *       cmus is running.\n *    5. This approach is easy to disable, simply by clearing the configuration\n *       option. On the next exit, the paths will be restored to their\n *       un-substituted values. Note that this will still work even if the path\n *       in the environment variable does not exist, keeping the behaviour\n *       consistent with how cmus normally works (the paths will be preserved as\n *       long as they are also in the metadata cache, and an error will be\n *       displayed on playback). This is possible because env var substitions\n *       are always parsed at launch regardless of pl_env_vars.\n *    6. This approach does not require modifying input/output plugins.\n *    7. This approach is os-independent, and can even handle sharing libraries\n *       with platforms using the backslash as a path separator.\n *    8. This approach does not interfere with the stream mechanism.\n *    9. This approach can handle multiple replacement paths (i.e. base\n *       folders).\n *   10. This approach preserves library/playlist/cache backwards compatibility\n *       while pl_env_vars is disabled.\n *   11. This approach results in behaviour comparable to without it.\n *\n * - What are the disadvantages of this approach?\n *   1. While the substitution works correctly and reliably, it is a somewhat\n *      hacky method. Nevertheless, it is also the least intrusive method, which\n *      is a significant advantage.\n *   2. Certain error messages will be somewhat misleading when an environment\n *      variable is missing. This is mitigated by improving the error message\n *      for the most common error, failed playback due to a nonexistent path\n *      caused by a missing environment variable.\n *   3. It is not possible to implement a mechanism for fallback paths within\n *      cmus for searching for individual tracks.\n *\n * - What are some potential uses of pl_env_vars?\n *   1. Syncing a $CMUS_HOME with multiple devices with different home folders.\n *   2. Syncing a $CMUS_HOME with multiple devices with one or more different\n *      music paths.\n *   3. The above case, but also with a path which only exists on certain\n *      devices.\n *   4. Easily relocating the cache/library/playlists while preserving metadata\n *      including the play count. This can be done by setting pl_env_vars,\n *      exiting cmus, updating the env var to the new path, starting cmus,\n *      clearing pl_env_vars, and exiting cmus again.\n */\n\n/**\n * PL_ENV_DELIMITER surrounds env var substitutions at the beginning of paths.\n */\n#define PL_ENV_DELIMITER '\\x1F'\n\n/**\n * pl_env_init initializes the environment variable cache used by pl_env_get. It\n * must be called before loading the library, playlists, or cache.\n */\nvoid pl_env_init(void);\n\n/**\n * pl_env_reduce checks the base path against the configured environment\n * variables, replaces the first match with a substitution, and returns a\n * malloc'd copy of the result. If there isn't any valid match or the path\n * already contains a substitution, a copy of the original path is returned\n * as-is.\n */\nchar *pl_env_reduce(const char *path);\n\n/**\n * pl_env_expand returns a malloc'd copy of path, with the environment variable\n * substitution. The provided path must use forward slashes, and begin with a\n * slash or a substitution followed by a slash (which will always be true for\n * library paths within cmus). If the path does not have a substitution, the\n * original path is returned. If the environment variable does not exist or is\n * invalid, the original path is also returned.\n */\nchar *pl_env_expand(const char *path);\n\n/**\n * pl_env_var returns a pointer to the start of the substituted environment\n * variable name, or NULL if it is not present. If a variable is present and\n * out_length is not NULL, it is set to the length of the variable name. The\n * remainder of the path will be at pl_env_var_remainder(path, out_length).\n */\nconst char *pl_env_var(const char *path, int *out_length);\n\n/**\n * pl_env_var_remainder returns a pointer to the remainder of the path after the\n * substitution. See pl_env_var.\n */\nconst char *pl_env_var_remainder(const char *path, int length);\n\n/**\n * pl_env_var_len returns the length of the substituted environment variable\n * name, if present. Otherwise, it returns 0.\n */\nint pl_env_var_len(const char *path);\n\n#endif\n"
        },
        {
          "name": "play_queue.c",
          "type": "blob",
          "size": 2.2861328125,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2005-2006 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"play_queue.h\"\n#include \"editable.h\"\n#include \"track.h\"\n#include \"xmalloc.h\"\n\nstruct editable pq_editable;\nstatic struct editable_shared pq_editable_shared;\n\nstatic void pq_free_track(struct editable *e, struct list_head *item)\n{\n\tstruct simple_track *track = to_simple_track(item);\n\n\ttrack_info_unref(track->info);\n\tfree(track);\n}\n\nvoid play_queue_init(void)\n{\n\teditable_shared_init(&pq_editable_shared, pq_free_track);\n\teditable_init(&pq_editable, &pq_editable_shared, 1);\n}\n\nvoid play_queue_append(struct track_info *ti, void *opaque)\n{\n\tif (!ti)\n\t\treturn;\n\n\tstruct simple_track *t = simple_track_new(ti);\n\teditable_add(&pq_editable, t);\n}\n\nvoid play_queue_prepend(struct track_info *ti, void *opaque)\n{\n\tif (!ti)\n\t\treturn;\n\n\tstruct simple_track *t = simple_track_new(ti);\n\teditable_add_before(&pq_editable, t);\n}\n\nstruct track_info *play_queue_remove(void)\n{\n\tstruct track_info *info = NULL;\n\n\tif (!list_empty(&pq_editable.head)) {\n\t\tstruct simple_track *t = to_simple_track(pq_editable.head.next);\n\t\tinfo = t->info;\n\t\ttrack_info_ref(info);\n\t\teditable_remove_track(&pq_editable, t);\n\t}\n\n\treturn info;\n}\n\nint play_queue_for_each(int (*cb)(void *data, struct track_info *ti),\n\t\tvoid *data, void *opaque)\n{\n\tstruct simple_track *track;\n\tint rc = 0;\n\n\tlist_for_each_entry(track, &pq_editable.head, node) {\n\t\trc = cb(data, track->info);\n\t\tif (rc)\n\t\t\tbreak;\n\t}\n\treturn rc;\n}\n\nunsigned int play_queue_total_time(void)\n{\n\treturn pq_editable.total_time;\n}\n\nint queue_needs_redraw(void)\n{\n\treturn pq_editable.shared->win->changed;\n}\n\nvoid queue_post_update(void)\n{\n\tpq_editable.shared->win->changed = 0;\n}\n"
        },
        {
          "name": "play_queue.h",
          "type": "blob",
          "size": 1.2431640625,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2005-2006 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_PLAY_QUEUE_H\n#define CMUS_PLAY_QUEUE_H\n\n#include \"editable.h\"\n#include \"track_info.h\"\n\nextern struct editable pq_editable;\n\nvoid play_queue_init(void);\nvoid play_queue_append(struct track_info *ti, void *opaque);\nvoid play_queue_prepend(struct track_info *ti, void *opaque);\nstruct track_info *play_queue_remove(void);\nint play_queue_for_each(int (*cb)(void *data, struct track_info *ti),\n\t\tvoid *data, void *opaque);\nunsigned int play_queue_total_time(void);\nint queue_needs_redraw(void);\nvoid queue_post_update(void);\n\n#endif\n"
        },
        {
          "name": "player.c",
          "type": "blob",
          "size": 33.353515625,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004-2006 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"player.h\"\n#include \"buffer.h\"\n#include \"input.h\"\n#include \"output.h\"\n#include \"sf.h\"\n#include \"op.h\"\n#include \"utils.h\"\n#include \"xmalloc.h\"\n#include \"debug.h\"\n#include \"compiler.h\"\n#include \"options.h\"\n#include \"mpris.h\"\n#include \"cmus.h\"\n#include \"lib.h\"\n#include \"pl_env.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n#include <errno.h>\n#include <string.h>\n#include <sys/time.h>\n#include <stdarg.h>\n#include <math.h>\n\nconst char * const player_status_names[] = {\n\t\"stopped\", \"playing\", \"paused\", NULL\n};\n\nenum producer_status {\n\tPS_UNLOADED,\n\tPS_STOPPED,\n\tPS_PLAYING,\n\tPS_PAUSED\n};\n\nenum consumer_status {\n\tCS_STOPPED,\n\tCS_PLAYING,\n\tCS_PAUSED\n};\n\n/* protects player_info_priv and player_metadata */\nstatic pthread_mutex_t player_info_mutex = CMUS_MUTEX_INITIALIZER;\nstruct player_info player_info;\nchar player_metadata[255 * 16 + 1];\nstatic struct player_info player_info_priv = {\n\t.ti = NULL,\n\t.status = PLAYER_STATUS_STOPPED,\n\t.pos = 0,\n\t.current_bitrate = -1,\n\t.buffer_fill = 0,\n\t.buffer_size = 0,\n\t.error_msg = NULL,\n\t.file_changed = 0,\n\t.metadata_changed = 0,\n\t.status_changed = 0,\n\t.position_changed = 0,\n\t.buffer_fill_changed = 0,\n};\n\n/* continue playing after track is finished? */\nint player_cont = 1;\n\n/* continue playing after album is finished? */\nint player_cont_album = 1;\n\n/* repeat current track forever? */\nint player_repeat_current;\n\nenum replaygain replaygain;\nint replaygain_limit = 1;\ndouble replaygain_preamp = 0.0;\n\nint soft_vol;\nint soft_vol_l;\nint soft_vol_r;\n\nstatic sample_format_t buffer_sf;\nstatic CHANNEL_MAP(buffer_channel_map);\n\nstatic pthread_t producer_thread;\nstatic pthread_mutex_t producer_mutex = CMUS_MUTEX_INITIALIZER;\nstatic pthread_cond_t producer_playing = CMUS_COND_INITIALIZER;\nstatic int producer_running = 1;\nstatic enum producer_status producer_status = PS_UNLOADED;\nstatic struct input_plugin *ip = NULL;\n\nstatic pthread_t consumer_thread;\nstatic pthread_mutex_t consumer_mutex = CMUS_MUTEX_INITIALIZER;\nstatic pthread_cond_t consumer_playing = CMUS_COND_INITIALIZER;\nstatic int consumer_running = 1;\nstatic enum consumer_status consumer_status = CS_STOPPED;\nstatic unsigned long consumer_pos = 0;\n\n/* for replay gain and soft vol\n * usually same as consumer_pos, sometimes more than consumer_pos\n */\nstatic unsigned long scale_pos;\nstatic double replaygain_scale = 1.0;\n\n/* locking {{{ */\n\n#define player_info_priv_lock() cmus_mutex_lock(&player_info_mutex)\n#define player_info_priv_unlock() cmus_mutex_unlock(&player_info_mutex)\n\n#define producer_lock() cmus_mutex_lock(&producer_mutex)\n#define producer_unlock() cmus_mutex_unlock(&producer_mutex)\n\n#define consumer_lock() cmus_mutex_lock(&consumer_mutex)\n#define consumer_unlock() cmus_mutex_unlock(&consumer_mutex)\n\n#define player_lock() \\\n\tdo { \\\n\t\tconsumer_lock(); \\\n\t\tproducer_lock(); \\\n\t} while (0)\n\n#define player_unlock() \\\n\tdo { \\\n\t\tproducer_unlock(); \\\n\t\tconsumer_unlock(); \\\n\t} while (0)\n\n/* locking }}} */\n\nstatic void reset_buffer(void)\n{\n\tbuffer_reset();\n\tconsumer_pos = 0;\n\tscale_pos = 0;\n\tpthread_cond_broadcast(&producer_playing);\n}\n\nstatic void set_buffer_sf(void)\n{\n\tbuffer_sf = ip_get_sf(ip);\n\tip_get_channel_map(ip, buffer_channel_map);\n\n\t/* ip_read converts samples to this format */\n\tif (sf_get_channels(buffer_sf) <= 2 && sf_get_bits(buffer_sf) <= 16) {\n\t\tbuffer_sf &= SF_RATE_MASK;\n\t\tbuffer_sf |= sf_channels(2) | sf_bits(16) | sf_signed(1);\n\t\tbuffer_sf |= sf_host_endian();\n\t\tchannel_map_init_stereo(buffer_channel_map);\n\t}\n}\n\n#define SOFT_VOL_SCALE 65536\n\n/* coefficients for volumes 0..99, for 100 65536 is used\n * data copied from alsa-lib src/pcm/pcm_softvol.c\n */\nstatic const unsigned short soft_vol_db[100] = {\n\t0x0000, 0x0110, 0x011c, 0x012f, 0x013d, 0x0152, 0x0161, 0x0179,\n\t0x018a, 0x01a5, 0x01c1, 0x01d5, 0x01f5, 0x020b, 0x022e, 0x0247,\n\t0x026e, 0x028a, 0x02b6, 0x02d5, 0x0306, 0x033a, 0x035f, 0x0399,\n\t0x03c2, 0x0403, 0x0431, 0x0479, 0x04ac, 0x04fd, 0x0553, 0x058f,\n\t0x05ef, 0x0633, 0x069e, 0x06ea, 0x0761, 0x07b5, 0x083a, 0x0898,\n\t0x092c, 0x09cb, 0x0a3a, 0x0aeb, 0x0b67, 0x0c2c, 0x0cb6, 0x0d92,\n\t0x0e2d, 0x0f21, 0x1027, 0x10de, 0x1202, 0x12cf, 0x1414, 0x14f8,\n\t0x1662, 0x1761, 0x18f5, 0x1a11, 0x1bd3, 0x1db4, 0x1f06, 0x211d,\n\t0x2297, 0x24ec, 0x2690, 0x292a, 0x2aff, 0x2de5, 0x30fe, 0x332b,\n\t0x369f, 0x390d, 0x3ce6, 0x3f9b, 0x43e6, 0x46eb, 0x4bb3, 0x4f11,\n\t0x5466, 0x5a18, 0x5e19, 0x6472, 0x68ea, 0x6ffd, 0x74f8, 0x7cdc,\n\t0x826a, 0x8b35, 0x9499, 0x9b35, 0xa5ad, 0xad0b, 0xb8b7, 0xc0ee,\n\t0xcdf1, 0xd71a, 0xe59c, 0xefd3\n};\n\nstatic inline void scale_sample_int16_t(int16_t *buf, int i, int vol, int swap)\n{\n\tint32_t sample = swap ? (int16_t)swap_uint16(buf[i]) : buf[i];\n\n\tif (sample < 0) {\n\t\tsample = (sample * vol - SOFT_VOL_SCALE / 2) / SOFT_VOL_SCALE;\n\t\tif (sample < INT16_MIN)\n\t\t\tsample = INT16_MIN;\n\t} else {\n\t\tsample = (sample * vol + SOFT_VOL_SCALE / 2) / SOFT_VOL_SCALE;\n\t\tif (sample > INT16_MAX)\n\t\t\tsample = INT16_MAX;\n\t}\n\tbuf[i] = swap ? swap_uint16(sample) : sample;\n}\n\nstatic inline int32_t scale_sample_s24le(int32_t s, int vol)\n{\n\tint64_t sample = s;\n\tif (sample < 0) {\n\t\tsample = (sample * vol - SOFT_VOL_SCALE / 2) / SOFT_VOL_SCALE;\n\t\tif (sample < -0x800000)\n\t\t\tsample = -0x800000;\n\t} else {\n\t\tsample = (sample * vol + SOFT_VOL_SCALE / 2) / SOFT_VOL_SCALE;\n\t\tif (sample > 0x7fffff)\n\t\t\tsample = 0x7fffff;\n\t}\n\treturn sample;\n}\n\nstatic inline void scale_sample_int32_t(int32_t *buf, int i, int vol, int swap)\n{\n\tint64_t sample = swap ? (int32_t)swap_uint32(buf[i]) : buf[i];\n\n\tif (sample < 0) {\n\t\tsample = (sample * vol - SOFT_VOL_SCALE / 2) / SOFT_VOL_SCALE;\n\t\tif (sample < INT32_MIN)\n\t\t\tsample = INT32_MIN;\n\t} else {\n\t\tsample = (sample * vol + SOFT_VOL_SCALE / 2) / SOFT_VOL_SCALE;\n\t\tif (sample > INT32_MAX)\n\t\t\tsample = INT32_MAX;\n\t}\n\tbuf[i] = swap ? swap_uint32(sample) : sample;\n}\n\nstatic inline int sf_need_swap(sample_format_t sf)\n{\n#ifdef WORDS_BIGENDIAN\n\treturn !sf_get_bigendian(sf);\n#else\n\treturn sf_get_bigendian(sf);\n#endif\n}\n\n#define SCALE_SAMPLES(TYPE, buffer, count, l, r, swap)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\t\\\n\tconst int frames = count / sizeof(TYPE) / 2;\t\t\t\t\\\n\tTYPE *buf = (void *) buffer;\t\t\t\t\t\t\\\n\tint i;\t\t\t\t\t\t\t\t\t\\\n\t/* avoid underflowing -32768 to 32767 when scale is 65536 */\t\t\\\n\tif (l != SOFT_VOL_SCALE && r != SOFT_VOL_SCALE) {\t\t\t\\\n\t\tfor (i = 0; i < frames; i++) {\t\t\t\t\t\\\n\t\t\tscale_sample_##TYPE(buf, i * 2, l, swap);\t\t\\\n\t\t\tscale_sample_##TYPE(buf, i * 2 + 1, r, swap);\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\\\n\t} else if (l != SOFT_VOL_SCALE) {\t\t\t\t\t\\\n\t\tfor (i = 0; i < frames; i++)\t\t\t\t\t\\\n\t\t\tscale_sample_##TYPE(buf, i * 2, l, swap);\t\t\\\n\t} else if (r != SOFT_VOL_SCALE) {\t\t\t\t\t\\\n\t\tfor (i = 0; i < frames; i++)\t\t\t\t\t\\\n\t\t\tscale_sample_##TYPE(buf, i * 2 + 1, r, swap);\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\\\n}\n\nstatic inline int32_t read_s24le(const char *buf)\n{\n\tconst unsigned char *b = (const unsigned char *) buf;\n\treturn b[0] | (b[1] << 8) | (((const signed char *) buf)[2] << 16);\n}\n\nstatic inline void write_s24le(char *buf, int32_t x)\n{\n\tunsigned char *b = (unsigned char *) buf;\n\tb[0] = x;\n\tb[1] = x >> 8;\n\tb[2] = x >> 16;\n}\n\nstatic void scale_samples_s24le(char *buf, unsigned int count, int l, int r)\n{\n\tint frames = count / 3 / 2;\n\tif (l != SOFT_VOL_SCALE && r != SOFT_VOL_SCALE) {\n\t\twhile (frames--) {\n\t\t\twrite_s24le(buf, scale_sample_s24le(read_s24le(buf), l));\n\t\t\tbuf += 3;\n\t\t\twrite_s24le(buf, scale_sample_s24le(read_s24le(buf), r));\n\t\t\tbuf += 3;\n\t\t}\n\t} else if (l != SOFT_VOL_SCALE) {\n\t\twhile (frames--) {\n\t\t\twrite_s24le(buf, scale_sample_s24le(read_s24le(buf), l));\n\t\t\tbuf += 3 * 2;\n\t\t}\n\t} else if (r != SOFT_VOL_SCALE) {\n\t\tbuf += 3;\n\t\twhile (frames--) {\n\t\t\twrite_s24le(buf, scale_sample_s24le(read_s24le(buf), r));\n\t\t\tbuf += 3 * 2;\n\t\t}\n\t}\n}\n\nstatic void scale_samples(char *buffer, unsigned int *countp)\n{\n\tunsigned int count = *countp;\n\tint ch, bits, l, r;\n\n\tBUG_ON(scale_pos < consumer_pos);\n\n\tif (consumer_pos != scale_pos) {\n\t\tunsigned int offs = scale_pos - consumer_pos;\n\n\t\tif (offs >= count)\n\t\t\treturn;\n\t\tbuffer += offs;\n\t\tcount -= offs;\n\t}\n\tscale_pos += count;\n\n\tif (replaygain_scale == 1.0 && soft_vol_l == 100 && soft_vol_r == 100)\n\t\treturn;\n\n\tch = sf_get_channels(buffer_sf);\n\tbits = sf_get_bits(buffer_sf);\n\tif (ch != 2 || (bits != 16 && bits != 24 && bits != 32))\n\t\treturn;\n\n\tl = SOFT_VOL_SCALE;\n\tr = SOFT_VOL_SCALE;\n\tif (soft_vol && soft_vol_l != 100)\n\t\tl = soft_vol_db[soft_vol_l];\n\tif (soft_vol && soft_vol_r != 100)\n\t\tr = soft_vol_db[soft_vol_r];\n\n\tl *= replaygain_scale;\n\tr *= replaygain_scale;\n\n\tswitch (bits) {\n\tcase 16:\n\t\tSCALE_SAMPLES(int16_t, buffer, count, l, r, sf_need_swap(buffer_sf));\n\t\tbreak;\n\tcase 24:\n\t\tif (likely(!sf_get_bigendian(buffer_sf)))\n\t\t\tscale_samples_s24le(buffer, count, l, r);\n\t\tbreak;\n\tcase 32:\n\t\tSCALE_SAMPLES(int32_t, buffer, count, l, r, sf_need_swap(buffer_sf));\n\t\tbreak;\n\t}\n}\n\nstatic void update_rg_scale(void)\n{\n\tdouble gain, peak, db, scale, limit;\n\n\treplaygain_scale = 1.0;\n\tif (!player_info_priv.ti || !replaygain)\n\t\treturn;\n\n\tbool avoid_album_gain = replaygain == RG_SMART && (!play_library || shuffle == SHUFFLE_TRACKS || cmus_queue_active());\n\t\n\tif (replaygain == RG_TRACK || replaygain == RG_TRACK_PREFERRED || avoid_album_gain) {\n\t\tgain = player_info_priv.ti->rg_track_gain;\n\t\tpeak = player_info_priv.ti->rg_track_peak;\n\t} else {\n\t\tgain = player_info_priv.ti->rg_album_gain;\n\t\tpeak = player_info_priv.ti->rg_album_peak;\n\t}\n\n\tif (isnan(gain)) {\n\t\tif (replaygain == RG_TRACK_PREFERRED || avoid_album_gain) {\n\t\t\tgain = player_info_priv.ti->rg_album_gain;\n\t\t\tpeak = player_info_priv.ti->rg_album_peak;\n\t\t} else if (replaygain == RG_ALBUM_PREFERRED) {\n\t\t\tgain = player_info_priv.ti->rg_track_gain;\n\t\t\tpeak = player_info_priv.ti->rg_track_peak;\n\t\t}\n\t}\n\n\tif (isnan(gain)) {\n\t\td_print(\"gain not available\\n\");\n\t\treturn;\n\t}\n\tif (isnan(peak)) {\n\t\td_print(\"peak not available, deriving from output gain\\n\");\n\t\tpeak = pow(10.0, player_info_priv.ti->output_gain / 20.0);\n\t}\n\tif (peak < 0.05) {\n\t\td_print(\"peak (%g) is too small\\n\", peak);\n\t\treturn;\n\t}\n\n\tdb = replaygain_preamp + gain;\n\n\tscale = pow(10.0, db / 20.0);\n\treplaygain_scale = scale;\n\tlimit = 1.0 / peak;\n\tif (replaygain_limit && !isnan(peak)) {\n\t\tif (replaygain_scale > limit)\n\t\t\treplaygain_scale = limit;\n\t}\n\n\td_print(\"gain = %f, peak = %f, db = %f, scale = %f, limit = %f, replaygain_scale = %f\\n\",\n\t\t\tgain, peak, db, scale, limit, replaygain_scale);\n}\n\nstatic inline unsigned int buffer_second_size(void)\n{\n\treturn sf_get_second_size(buffer_sf);\n}\n\n/* updating player status {{{ */\n\nstatic inline void _file_changed(struct track_info *ti)\n{\n\tplayer_info_priv_lock();\n\tif (player_info_priv.ti)\n\t\ttrack_info_unref(player_info_priv.ti);\n\n\tplayer_info_priv.ti = ti;\n\tupdate_rg_scale();\n\tplayer_metadata[0] = 0;\n\tplayer_info_priv.file_changed = 1;\n\tplayer_info_priv_unlock();\n}\n\nstatic inline void file_changed(struct track_info *ti)\n{\n\tif (ti) {\n\t\td_print(\"file: %s\\n\", ti->filename);\n\t} else {\n\t\td_print(\"unloaded\\n\");\n\t}\n\t_file_changed(ti);\n}\n\nstatic inline void metadata_changed(void)\n{\n\tstruct keyval *comments;\n\tint rc;\n\n\tplayer_info_priv_lock();\n\tif (ip_get_metadata(ip)) {\n\t\td_print(\"metadata changed: %s\\n\", ip_get_metadata(ip));\n\t\tmemcpy(player_metadata, ip_get_metadata(ip), 255 * 16 + 1);\n\t}\n\n\trc = ip_read_comments(ip, &comments);\n\tif (!rc) {\n\t\tif (player_info_priv.ti->comments)\n\t\t\tkeyvals_free(player_info_priv.ti->comments);\n\t\ttrack_info_set_comments(player_info_priv.ti, comments);\n\t}\n\n\tplayer_info_priv.metadata_changed = 1;\n\tplayer_info_priv_unlock();\n}\n\nstatic void player_error(const char *msg)\n{\n\tplayer_info_priv_lock();\n\tplayer_info_priv.status = (enum player_status)consumer_status;\n\tplayer_info_priv.pos = 0;\n\tplayer_info_priv.current_bitrate = -1;\n\tplayer_info_priv.buffer_fill = buffer_get_filled_chunks();\n\tplayer_info_priv.buffer_size = buffer_nr_chunks;\n\tplayer_info_priv.status_changed = 1;\n\n\tfree(player_info_priv.error_msg);\n\tplayer_info_priv.error_msg = xstrdup(msg);\n\tplayer_info_priv_unlock();\n\n\td_print(\"ERROR: '%s'\\n\", msg);\n}\n\nstatic void CMUS_FORMAT(2, 3) player_ip_error(int rc, const char *format, ...)\n{\n\tchar buffer[1024];\n\tva_list ap;\n\tchar *msg;\n\tint save = errno;\n\n\tva_start(ap, format);\n\tvsnprintf(buffer, sizeof(buffer), format, ap);\n\tva_end(ap);\n\n\terrno = save;\n\tmsg = ip_get_error_msg(ip, rc, buffer);\n\tplayer_error(msg);\n\tfree(msg);\n}\n\nstatic void CMUS_FORMAT(2, 3) player_op_error(int rc, const char *format, ...)\n{\n\tchar buffer[1024];\n\tva_list ap;\n\tchar *msg;\n\tint save = errno;\n\n\tva_start(ap, format);\n\tvsnprintf(buffer, sizeof(buffer), format, ap);\n\tva_end(ap);\n\n\terrno = save;\n\tmsg = op_get_error_msg(rc, buffer);\n\tplayer_error(msg);\n\tfree(msg);\n}\n\n/*\n * buffer-fill changed\n */\nstatic void _producer_buffer_fill_update(void)\n{\n\tint fill;\n\n\tplayer_info_priv_lock();\n\tfill = buffer_get_filled_chunks();\n\tif (fill != player_info_priv.buffer_fill) {\n/* \t\td_print(\"\\n\"); */\n\t\tplayer_info_priv.buffer_fill = fill;\n\t\tplayer_info_priv.buffer_fill_changed = 1;\n\t}\n\tplayer_info_priv_unlock();\n}\n\n/*\n * playing position changed\n */\nstatic void _consumer_position_update(void)\n{\n\tstatic unsigned int old_pos = -1;\n\tunsigned int pos = 0;\n\tlong bitrate;\n\n\tif (consumer_status == CS_PLAYING || consumer_status == CS_PAUSED)\n\t\tpos = consumer_pos / buffer_second_size();\n\tif (pos != old_pos) {\n\t\told_pos = pos;\n\n\t\tplayer_info_priv_lock();\n\t\tplayer_info_priv.pos = pos;\n\n\t\tif (show_current_bitrate) {\n\t\t\tbitrate = ip_current_bitrate(ip);\n\t\t\tif (bitrate != -1)\n\t\t\t\tplayer_info_priv.current_bitrate = bitrate;\n\t\t}\n\t\tplayer_info_priv.position_changed = 1;\n\t\tplayer_info_priv_unlock();\n\t}\n}\n\n/*\n * something big happened (stopped/paused/unpaused...)\n */\nstatic void _player_status_changed(void)\n{\n\tunsigned int pos = 0;\n\n/* \td_print(\"\\n\"); */\n\tif (consumer_status == CS_PLAYING || consumer_status == CS_PAUSED)\n\t\tpos = consumer_pos / buffer_second_size();\n\n\tplayer_info_priv_lock();\n\tplayer_info_priv.status = (enum player_status)consumer_status;\n\tplayer_info_priv.pos = pos;\n\tplayer_info_priv.current_bitrate = -1;\n\tplayer_info_priv.buffer_fill = buffer_get_filled_chunks();\n\tplayer_info_priv.buffer_size = buffer_nr_chunks;\n\tplayer_info_priv.status_changed = 1;\n\tplayer_info_priv_unlock();\n}\n\n/* updating player status }}} */\n\nstatic void _prebuffer(void)\n{\n\tint limit_chunks;\n\n\tBUG_ON(producer_status != PS_PLAYING);\n\tif (ip_is_remote(ip)) {\n\t\tlimit_chunks = buffer_nr_chunks;\n\t} else {\n\t\tint limit_ms, limit_size;\n\n\t\tlimit_ms = 250;\n\t\tlimit_size = limit_ms * buffer_second_size() / 1000;\n\t\tlimit_chunks = limit_size / CHUNK_SIZE;\n\t\tif (limit_chunks < 1)\n\t\t\tlimit_chunks = 1;\n\t}\n\twhile (1) {\n\t\tint nr_read, size, filled;\n\t\tchar *wpos;\n\n\t\tfilled = buffer_get_filled_chunks();\n/* \t\td_print(\"PREBUF: %2d / %2d\\n\", filled, limit_chunks); */\n\n\t\t/* not fatal */\n\t\t//BUG_ON(filled > limit_chunks);\n\n\t\tif (filled >= limit_chunks)\n\t\t\tbreak;\n\n\t\tsize = buffer_get_wpos(&wpos);\n\t\tnr_read = ip_read(ip, wpos, size);\n\t\tif (nr_read < 0) {\n\t\t\tif (nr_read == -1 && errno == EAGAIN)\n\t\t\t\tcontinue;\n\t\t\tplayer_ip_error(nr_read, \"reading file %s\", ip_get_filename(ip));\n\t\t\t/* ip_read sets eof */\n\t\t\tnr_read = 0;\n\t\t}\n\t\tif (ip_metadata_changed(ip))\n\t\t\tmetadata_changed();\n\n\t\t/* buffer_fill with 0 count marks current chunk filled */\n\t\tbuffer_fill(nr_read);\n\n\t\t_producer_buffer_fill_update();\n\t\tif (nr_read == 0) {\n\t\t\t/* EOF */\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/* setting producer status {{{ */\n\nstatic void _producer_status_update(enum producer_status status)\n{\n\tproducer_status =  status;\n\tpthread_cond_broadcast(&producer_playing);\n}\n\nstatic void _producer_play(void)\n{\n\tif (producer_status == PS_UNLOADED) {\n\t\tstruct track_info *ti;\n\n\t\tif ((ti = cmus_get_next_track())) {\n\t\t\tint rc;\n\n\t\t\tip = ip_new(ti->filename);\n\t\t\trc = ip_open(ip);\n\t\t\tif (rc) {\n\t\t\t\tplayer_ip_error(rc, \"opening file `%s'\", ti->filename);\n\t\t\t\tip_delete(ip);\n\t\t\t\ttrack_info_unref(ti);\n\t\t\t\tfile_changed(NULL);\n\t\t\t} else {\n\t\t\t\tip_setup(ip);\n\t\t\t\t_producer_status_update(PS_PLAYING);\n\t\t\t\tfile_changed(ti);\n\t\t\t}\n\t\t}\n\t} else if (producer_status == PS_PLAYING) {\n\t\tif (ip_seek(ip, 0.0) == 0) {\n\t\t\treset_buffer();\n\t\t}\n\t} else if (producer_status == PS_STOPPED) {\n\t\tint rc;\n\n\t\trc = ip_open(ip);\n\t\tif (rc) {\n\t\t\tint var_len;\n\t\t\tconst char *fn = ip_get_filename(ip), *var;\n\t\t\tif ((var = pl_env_var(fn, &var_len)))\n\t\t\t\tplayer_ip_error(rc, \"opening file `%s': missing env var `%.*s`\", pl_env_var_remainder(fn, var_len), var_len, var);\n\t\t\telse\n\t\t\t\tplayer_ip_error(rc, \"opening file `%s'\", fn);\n\t\t\tip_delete(ip);\n\t\t\t_producer_status_update(PS_UNLOADED);\n\t\t} else {\n\t\t\tip_setup(ip);\n\t\t\t_producer_status_update(PS_PLAYING);\n\t\t}\n\t} else if (producer_status == PS_PAUSED) {\n\t\t_producer_status_update(PS_PLAYING);\n\t}\n}\n\nstatic void _producer_stop(void)\n{\n\tif (producer_status == PS_PLAYING || producer_status == PS_PAUSED) {\n\t\tip_close(ip);\n\t\t_producer_status_update(PS_STOPPED);\n\t\treset_buffer();\n\t}\n}\n\nstatic void _producer_unload(void)\n{\n\t_producer_stop();\n\tif (producer_status == PS_STOPPED) {\n\t\tip_delete(ip);\n\t\t_producer_status_update(PS_UNLOADED);\n\t}\n}\n\nstatic void _producer_pause(void)\n{\n\tif (producer_status == PS_PLAYING) {\n\t\t_producer_status_update(PS_PAUSED);\n\t} else if (producer_status == PS_PAUSED) {\n\t\t_producer_status_update(PS_PLAYING);\n\t}\n}\n\nstatic void _producer_set_file(struct track_info *ti)\n{\n\t_producer_unload();\n\tip = ip_new(ti->filename);\n\t_producer_status_update(PS_STOPPED);\n\tfile_changed(ti);\n}\n\n/* setting producer status }}} */\n\n/* setting consumer status {{{ */\n\nstatic void _consumer_status_update(enum consumer_status status)\n{\n\tconsumer_status = status;\n\tpthread_cond_broadcast(&consumer_playing);\n}\n\nstatic void _consumer_play(void)\n{\n\tif (consumer_status == CS_PLAYING) {\n\t\top_drop();\n\t} else if (consumer_status == CS_STOPPED) {\n\t\tint rc;\n\n\t\tset_buffer_sf();\n\t\trc = op_open(buffer_sf, buffer_channel_map);\n\t\tif (rc) {\n\t\t\tplayer_op_error(rc, \"opening audio device\");\n\t\t} else {\n\t\t\t_consumer_status_update(CS_PLAYING);\n\t\t}\n\t} else if (consumer_status == CS_PAUSED) {\n\t\top_unpause();\n\t\t_consumer_status_update(CS_PLAYING);\n\t}\n}\n\nstatic void _consumer_drain_and_stop(void)\n{\n\tif (consumer_status == CS_PLAYING || consumer_status == CS_PAUSED) {\n\t\top_close();\n\t\t_consumer_status_update(CS_STOPPED);\n\t}\n}\n\nstatic void _consumer_stop(void)\n{\n\tif (consumer_status == CS_PLAYING || consumer_status == CS_PAUSED) {\n\t\top_drop();\n\t\top_close();\n\t\t_consumer_status_update(CS_STOPPED);\n\t}\n}\n\nstatic void _consumer_pause(void)\n{\n\tif (consumer_status == CS_PLAYING) {\n\t\top_pause();\n\t\t_consumer_status_update(CS_PAUSED);\n\t} else if (consumer_status == CS_PAUSED) {\n\t\top_unpause();\n\t\t_consumer_status_update(CS_PLAYING);\n\t}\n}\n\n/* setting consumer status }}} */\n\nstatic int change_sf(int drop)\n{\n\tint old_sf = buffer_sf;\n\tCHANNEL_MAP(old_channel_map);\n\tchannel_map_copy(old_channel_map, buffer_channel_map);\n\n\tset_buffer_sf();\n\tif (buffer_sf != old_sf || !channel_map_equal(buffer_channel_map, old_channel_map, sf_get_channels(buffer_sf))) {\n\t\t/* reopen */\n\t\tint rc;\n\n\t\tif (drop)\n\t\t\top_drop();\n\t\top_close();\n\t\trc = op_open(buffer_sf, buffer_channel_map);\n\t\tif (rc) {\n\t\t\tplayer_op_error(rc, \"opening audio device\");\n\t\t\t_consumer_status_update(CS_STOPPED);\n\t\t\t_producer_stop();\n\t\t\treturn rc;\n\t\t}\n\t} else if (consumer_status == CS_PAUSED) {\n\t\top_drop();\n\t\top_unpause();\n\t}\n\t_consumer_status_update(CS_PLAYING);\n\treturn 0;\n}\n\nstatic void _consumer_handle_eof(void)\n{\n\tstruct track_info *ti;\n\n\tif (ip_is_remote(ip)) {\n\t\t_producer_stop();\n\t\t_consumer_drain_and_stop();\n\t\tplayer_error(\"lost connection\");\n\t\treturn;\n\t}\n\n\tif (player_info_priv.ti)\n\t\tplayer_info_priv.ti->play_count++;\n\n\tif (player_repeat_current) {\n\t\tif (player_cont) {\n\t\t\tip_seek(ip, 0);\n\t\t\treset_buffer();\n\t\t} else {\n\t\t\t_producer_stop();\n\t\t\t_consumer_drain_and_stop();\n\t\t}\n\t\t_player_status_changed();\n\t\treturn;\n\t}\n\n\tif ((ti = cmus_get_next_track())) {\n\t\t_producer_unload();\n\t\tip = ip_new(ti->filename);\n\t\t_producer_status_update(PS_STOPPED);\n\t\t/* PS_STOPPED, CS_PLAYING */\n\t\tif (player_cont && (player_cont_album == 1 || (player_info_priv.ti->album && ti->album && strcmp(player_info_priv.ti->album,ti->album) == 0))) {\n\t\t\t_producer_play();\n\t\t\tif (producer_status == PS_UNLOADED) {\n\t\t\t\t_consumer_stop();\n\t\t\t\ttrack_info_unref(ti);\n\t\t\t\tfile_changed(NULL);\n\t\t\t} else {\n\t\t\t\t/* PS_PLAYING */\n\t\t\t\tfile_changed(ti);\n\t\t\t\tif (!change_sf(0))\n\t\t\t\t\t_prebuffer();\n\t\t\t}\n\t\t} else {\n\t\t\t_consumer_drain_and_stop();\n\t\t\tfile_changed(ti);\n\t\t}\n\t} else {\n\t\t_producer_unload();\n\t\t_consumer_drain_and_stop();\n\t\tfile_changed(NULL);\n\t}\n\t_player_status_changed();\n}\n\nstatic void *consumer_loop(void *arg)\n{\n\twhile (1) {\n\t\tint rc, space;\n\t\tint size;\n\t\tchar *rpos;\n\n\t\tconsumer_lock();\n\t\tif (!consumer_running)\n\t\t\tbreak;\n\n\t\tif (consumer_status == CS_PAUSED || consumer_status == CS_STOPPED) {\n\t\t\tpthread_cond_wait(&consumer_playing, &consumer_mutex);\n\t\t\tconsumer_unlock();\n\t\t\tcontinue;\n\t\t}\n\t\tspace = op_buffer_space();\n\t\tif (space < 0) {\n\t\t\td_print(\"op_buffer_space returned %d %s\\n\", space,\n\t\t\t\t\tspace == -1 ? strerror(errno) : \"\");\n\n\t\t\t/* try to reopen */\n\t\t\top_close();\n\t\t\t_consumer_status_update(CS_STOPPED);\n\t\t\t_consumer_play();\n\n\t\t\tconsumer_unlock();\n\t\t\tcontinue;\n\t\t}\n/* \t\td_print(\"BS: %6d %3d\\n\", space, space * 1000 / (44100 * 2 * 2)); */\n\n\t\twhile (1) {\n\t\t\tif (space == 0) {\n\t\t\t\t_consumer_position_update();\n\t\t\t\tconsumer_unlock();\n\t\t\t\tms_sleep(25);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsize = buffer_get_rpos(&rpos);\n\t\t\tif (size == 0) {\n\t\t\t\tproducer_lock();\n\t\t\t\tif (producer_status != PS_PLAYING) {\n\t\t\t\t\tproducer_unlock();\n\t\t\t\t\tconsumer_unlock();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* must recheck rpos */\n\t\t\t\tsize = buffer_get_rpos(&rpos);\n\t\t\t\tif (size == 0) {\n\t\t\t\t\t/* OK. now it's safe to check if we are at EOF */\n\t\t\t\t\tif (ip_eof(ip)) {\n\t\t\t\t\t\t/* EOF */\n\t\t\t\t\t\t_consumer_handle_eof();\n\t\t\t\t\t\tproducer_unlock();\n\t\t\t\t\t\tconsumer_unlock();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* possible underrun */\n\t\t\t\t\t\tproducer_unlock();\n\t\t\t\t\t\t_consumer_position_update();\n\t\t\t\t\t\tconsumer_unlock();\n/* \t\t\t\t\t\td_print(\"possible underrun\\n\"); */\n\t\t\t\t\t\tms_sleep(10);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* player_buffer and ip.eof were inconsistent */\n\t\t\t\tproducer_unlock();\n\t\t\t}\n\t\t\tif (size > space)\n\t\t\t\tsize = space;\n\t\t\tif (soft_vol || replaygain)\n\t\t\t\tscale_samples(rpos, (unsigned int *)&size);\n\t\t\trc = op_write(rpos, size);\n\t\t\tif (rc < 0) {\n\t\t\t\td_print(\"op_write returned %d %s\\n\", rc,\n\t\t\t\t\t\trc == -1 ? strerror(errno) : \"\");\n\n\t\t\t\t/* try to reopen */\n\t\t\t\top_close();\n\t\t\t\t_consumer_status_update(CS_STOPPED);\n\t\t\t\t_consumer_play();\n\n\t\t\t\tconsumer_unlock();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbuffer_consume(rc);\n\t\t\tconsumer_pos += rc;\n\t\t\tspace -= rc;\n\t\t}\n\t}\n\t_consumer_stop();\n\tconsumer_unlock();\n\treturn NULL;\n}\n\nstatic void *producer_loop(void *arg)\n{\n\twhile (1) {\n\t\t/* number of chunks to fill\n\t\t * too big   => seeking is slow\n\t\t * too small => underruns?\n\t\t */\n\t\tconst int chunks = 1;\n\t\tint size, nr_read, i;\n\t\tchar *wpos;\n\n\t\tproducer_lock();\n\t\tif (!producer_running)\n\t\t\tbreak;\n\n\t\tif (producer_status == PS_UNLOADED ||\n\t\t    producer_status == PS_PAUSED ||\n\t\t    producer_status == PS_STOPPED || ip_eof(ip)) {\n\t\t\tpthread_cond_wait(&producer_playing, &producer_mutex);\n\t\t\tproducer_unlock();\n\t\t\tcontinue;\n\t\t}\n\t\tfor (i = 0; ; i++) {\n\t\t\tsize = buffer_get_wpos(&wpos);\n\t\t\tif (size == 0) {\n\t\t\t\t/* buffer is full */\n\t\t\t\tproducer_unlock();\n\t\t\t\tms_sleep(50);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnr_read = ip_read(ip, wpos, size);\n\t\t\tif (nr_read < 0) {\n\t\t\t\tif (nr_read != -1 || errno != EAGAIN) {\n\t\t\t\t\tplayer_ip_error(nr_read, \"reading file %s\",\n\t\t\t\t\t\t\tip_get_filename(ip));\n\t\t\t\t\t/* ip_read sets eof */\n\t\t\t\t\tnr_read = 0;\n\t\t\t\t} else {\n\t\t\t\t\tproducer_unlock();\n\t\t\t\t\tms_sleep(50);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ip_metadata_changed(ip))\n\t\t\t\tmetadata_changed();\n\n\t\t\t/* buffer_fill with 0 count marks current chunk filled */\n\t\t\tbuffer_fill(nr_read);\n\t\t\tif (nr_read == 0) {\n\t\t\t\t/* consumer handles EOF */\n\t\t\t\tproducer_unlock();\n\t\t\t\tms_sleep(50);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i == chunks) {\n\t\t\t\tproducer_unlock();\n\t\t\t\t/* don't sleep! */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t_producer_buffer_fill_update();\n\t}\n\t_producer_unload();\n\tproducer_unlock();\n\treturn NULL;\n}\n\nvoid player_init(void)\n{\n\tint rc;\n#ifdef REALTIME_SCHEDULING\n\tpthread_attr_t attr;\n#endif\n\tpthread_attr_t *attrp = NULL;\n\n\t/*  1 s is 176400 B (0.168 MB)\n\t * 10 s is 1.68 MB\n\t */\n\tbuffer_nr_chunks = 10 * 44100 * 16 / 8 * 2 / CHUNK_SIZE;\n\tbuffer_init();\n\n#ifdef REALTIME_SCHEDULING\n\trc = pthread_attr_init(&attr);\n\tBUG_ON(rc);\n\trc = pthread_attr_setschedpolicy(&attr, SCHED_RR);\n\tif (rc) {\n\t\td_print(\"could not set real-time scheduling priority: %s\\n\", strerror(rc));\n\t} else {\n\t\tstruct sched_param param;\n\n\t\td_print(\"using real-time scheduling\\n\");\n\t\tparam.sched_priority = sched_get_priority_max(SCHED_RR);\n\t\td_print(\"setting priority to %d\\n\", param.sched_priority);\n\t\trc = pthread_attr_setschedparam(&attr, &param);\n\t\tBUG_ON(rc);\n\t\tattrp = &attr;\n\t}\n#endif\n\n\trc = pthread_create(&producer_thread, NULL, producer_loop, NULL);\n\tBUG_ON(rc);\n\n\trc = pthread_create(&consumer_thread, attrp, consumer_loop, NULL);\n\tif (rc && attrp) {\n\t\td_print(\"could not create thread using real-time scheduling: %s\\n\", strerror(rc));\n\t\trc = pthread_create(&consumer_thread, NULL, consumer_loop, NULL);\n\t}\n\tBUG_ON(rc);\n\n\t/* update player_info_priv.cont etc. */\n\tplayer_lock();\n\t_player_status_changed();\n\tplayer_unlock();\n}\n\nvoid player_exit(void)\n{\n\tint rc;\n\n\tplayer_lock();\n\tconsumer_running = 0;\n\tpthread_cond_broadcast(&consumer_playing);\n\tproducer_running = 0;\n\tpthread_cond_broadcast(&producer_playing);\n\tplayer_unlock();\n\n\trc = pthread_join(consumer_thread, NULL);\n\tBUG_ON(rc);\n\trc = pthread_join(producer_thread, NULL);\n\tBUG_ON(rc);\n\tbuffer_free();\n}\n\nvoid player_stop(void)\n{\n\tplayer_lock();\n\t_consumer_stop();\n\t_producer_stop();\n\t_player_status_changed();\n\tplayer_unlock();\n}\n\nvoid player_play(void)\n{\n\tint prebuffer;\n\n\tplayer_lock();\n\tif (producer_status == PS_PLAYING && ip_is_remote(ip)) {\n\t\t/* seeking not allowed */\n\t\tplayer_unlock();\n\t\treturn;\n\t}\n\tprebuffer = consumer_status == CS_STOPPED;\n\t_producer_play();\n\tif (producer_status == PS_PLAYING) {\n\t\t_consumer_play();\n\t\tif (consumer_status != CS_PLAYING)\n\t\t\t_producer_stop();\n\t} else {\n\t\t_consumer_stop();\n\t}\n\t_player_status_changed();\n\tif (consumer_status == CS_PLAYING && prebuffer)\n\t\t_prebuffer();\n\tplayer_unlock();\n}\n\nvoid player_pause(void)\n{\n\tif (ip && ip_is_remote(ip) && consumer_status == CS_PLAYING) {\n\t\t/* pausing not allowed */\n\t\tplayer_stop();\n\t\treturn;\n\t}\n\tplayer_lock();\n\n\tif (consumer_status == CS_STOPPED) {\n\t\t_producer_play();\n\t\tif (producer_status == PS_PLAYING) {\n\t\t\t_consumer_play();\n\t\t\tif (consumer_status != CS_PLAYING)\n\t\t\t\t_producer_stop();\n\t\t}\n\t\t_player_status_changed();\n\t\tif (consumer_status == CS_PLAYING)\n\t\t\t_prebuffer();\n\t\tplayer_unlock();\n\t\treturn;\n\t}\n\n\t_producer_pause();\n\t_consumer_pause();\n\t_player_status_changed();\n\tplayer_unlock();\n}\n\nvoid player_pause_playback(void)\n{\n\tif (consumer_status == CS_PLAYING)\n\t\tplayer_pause();\n}\n\nvoid player_set_file(struct track_info *ti)\n{\n\tplayer_lock();\n\t_producer_set_file(ti);\n\tif (producer_status == PS_UNLOADED) {\n\t\t_consumer_stop();\n\t\tgoto out;\n\t}\n\n\t/* PS_STOPPED */\n\tif (consumer_status == CS_PLAYING || consumer_status == CS_PAUSED) {\n\t\top_drop();\n\t\t_producer_play();\n\t\tif (producer_status == PS_UNLOADED) {\n\t\t\t_consumer_stop();\n\t\t\tgoto out;\n\t\t}\n\t\tchange_sf(1);\n\t}\nout:\n\t_player_status_changed();\n\tif (producer_status == PS_PLAYING)\n\t\t_prebuffer();\n\tplayer_unlock();\n}\n\nvoid player_play_file(struct track_info *ti)\n{\n\tplayer_lock();\n\t_producer_set_file(ti);\n\tif (producer_status == PS_UNLOADED) {\n\t\t_consumer_stop();\n\t\tgoto out;\n\t}\n\n\t/* PS_STOPPED */\n\t_producer_play();\n\n\t/* PS_UNLOADED,PS_PLAYING */\n\tif (producer_status == PS_UNLOADED) {\n\t\t_consumer_stop();\n\t\tgoto out;\n\t}\n\n\t/* PS_PLAYING */\n\tif (consumer_status == CS_STOPPED) {\n\t\t_consumer_play();\n\t\tif (consumer_status == CS_STOPPED)\n\t\t\t_producer_stop();\n\t} else {\n\t\top_drop();\n\t\tchange_sf(1);\n\t}\nout:\n\t_player_status_changed();\n\tif (producer_status == PS_PLAYING)\n\t\t_prebuffer();\n\tplayer_unlock();\n}\n\nvoid player_file_changed(struct track_info *ti)\n{\n\t_file_changed(ti);\n}\n\nvoid player_seek(double offset, int relative, int start_playing)\n{\n\tint stopped = 0;\n\tplayer_lock();\n\tif (consumer_status == CS_STOPPED) {\n\t\tstopped = 1;\n\t\t_producer_play();\n\t\tif (producer_status == PS_PLAYING) {\n\t\t\t_consumer_play();\n\t\t\tif (consumer_status != CS_PLAYING) {\n\t\t\t\t_producer_stop();\n\t\t\t\tplayer_unlock();\n\t\t\t\treturn;\n\t\t\t} else\n\t\t\t\t_player_status_changed();\n\t\t}\n\t}\n\tif (consumer_status == CS_PLAYING || consumer_status == CS_PAUSED) {\n\t\tdouble pos, duration, new_pos;\n\t\tint rc;\n\n\t\tpos = (double)consumer_pos / (double)buffer_second_size();\n\t\tduration = ip_duration(ip);\n\t\tif (duration < 0) {\n\t\t\t/* can't seek */\n\t\t\td_print(\"can't seek\\n\");\n\t\t\tplayer_unlock();\n\t\t\treturn;\n\t\t}\n\t\tif (relative) {\n\t\t\tnew_pos = pos + offset;\n\t\t\tif (new_pos < 0.0)\n\t\t\t\tnew_pos = 0.0;\n\t\t\tif (offset > 0.0) {\n\t\t\t\t/* seeking forward */\n\t\t\t\tif (new_pos > duration) {\n\t\t\t\t\tplayer_unlock();\n\t\t\t\t\tcmus_next();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (new_pos < 0.0)\n\t\t\t\t\tnew_pos = 0.0;\n\t\t\t\tif (new_pos < pos - 0.5) {\n\t\t\t\t\t/* must seek at least 0.5s */\n\t\t\t\t\td_print(\"must seek at least 0.5s\\n\");\n\t\t\t\t\tplayer_unlock();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tnew_pos = offset;\n\t\t\tif (new_pos < 0.0) {\n\t\t\t\td_print(\"seek offset negative\\n\");\n\t\t\t\tplayer_unlock();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (new_pos > duration - 5.0) {\n\t\t\t\tnew_pos = duration - 5.0;\n\t\t\t\tif (new_pos < 0.0)\n\t\t\t\t\tnew_pos = 0.0;\n\t\t\t}\n\t\t}\n/* \t\td_print(\"seeking %g/%g (%g from eof)\\n\", new_pos, duration, duration - new_pos); */\n\t\trc = ip_seek(ip, new_pos);\n\t\tif (rc == 0) {\n\t\t\td_print(\"doing op_drop after seek\\n\");\n\t\t\top_drop();\n\t\t\treset_buffer();\n\t\t\tconsumer_pos = new_pos * buffer_second_size();\n\t\t\tscale_pos = consumer_pos;\n\t\t\t_consumer_position_update();\n\t\t\tif (stopped && !start_playing) {\n\t\t\t\t_producer_pause();\n\t\t\t\t_consumer_pause();\n\t\t\t\t_player_status_changed();\n\t\t\t}\n\t\t} else {\n\t\t\tplayer_ip_error(rc, \"seeking in file %s\", ip_get_filename(ip));\n\t\t\td_print(\"error: ip_seek returned %d\\n\", rc);\n\t\t}\n\t}\n\tmpris_seeked();\n\tplayer_unlock();\n}\n\n/*\n * change output plugin without stopping playback\n */\nvoid player_set_op(const char *name)\n{\n\tint rc;\n\n\tplayer_lock();\n\n\t/* drop needed because close drains the buffer */\n\tif (consumer_status == CS_PAUSED)\n\t\top_drop();\n\n\tif (consumer_status == CS_PLAYING || consumer_status == CS_PAUSED)\n\t\top_close();\n\n\tif (name) {\n\t\td_print(\"setting op to '%s'\\n\", name);\n\t\trc = op_select(name);\n\t} else {\n\t\t/* first initialized plugin */\n\t\td_print(\"selecting first initialized op\\n\");\n\t\trc = op_select_any();\n\t}\n\tif (rc) {\n\t\t_consumer_status_update(CS_STOPPED);\n\n\t\t_producer_stop();\n\t\tif (name)\n\t\t\tplayer_op_error(rc, \"selecting output plugin '%s'\", name);\n\t\telse\n\t\t\tplayer_op_error(rc, \"selecting any output plugin\");\n\t\tplayer_unlock();\n\t\treturn;\n\t}\n\n\tif (consumer_status == CS_PLAYING || consumer_status == CS_PAUSED) {\n\t\tset_buffer_sf();\n\t\trc = op_open(buffer_sf, buffer_channel_map);\n\t\tif (rc) {\n\t\t\t_consumer_status_update(CS_STOPPED);\n\t\t\t_producer_stop();\n\t\t\tplayer_op_error(rc, \"opening audio device\");\n\t\t\tplayer_unlock();\n\t\t\treturn;\n\t\t}\n\t\tif (consumer_status == CS_PAUSED)\n\t\t\top_pause();\n\t}\n\n\tplayer_unlock();\n}\n\nvoid player_set_buffer_chunks(unsigned int nr_chunks)\n{\n\tplayer_lock();\n\t_producer_stop();\n\t_consumer_stop();\n\n\tbuffer_nr_chunks = nr_chunks;\n\tbuffer_init();\n\n\t_player_status_changed();\n\tplayer_unlock();\n}\n\nint player_get_buffer_chunks(void)\n{\n\treturn buffer_nr_chunks;\n}\n\nvoid player_set_soft_volume(int l, int r)\n{\n\tconsumer_lock();\n\tsoft_vol_l = l;\n\tsoft_vol_r = r;\n\tconsumer_unlock();\n}\n\nvoid player_set_soft_vol(int soft)\n{\n\tconsumer_lock();\n\t/* don't mess with scale_pos if soft_vol or replaygain is already enabled */\n\tif (!soft_vol && !replaygain)\n\t\tscale_pos = consumer_pos;\n\tsoft_vol = soft;\n\tconsumer_unlock();\n}\n\nstatic int calc_vol(int val, int old, int max_vol, unsigned int flags)\n{\n\tif (flags & VF_RELATIVE) {\n\t\tif (flags & VF_PERCENTAGE)\n\t\t\tval = scale_from_percentage(val, max_vol);\n\t\tval += old;\n\t} else if (flags & VF_PERCENTAGE) {\n\t\tval = scale_from_percentage(val, max_vol);\n\t}\n\treturn clamp(val, 0, max_vol);\n}\n\nint player_set_vol(int l, int lf, int r, int rf)\n{\n\tint rc = OP_ERROR_SUCCESS;\n\tif (soft_vol) {\n\t\tl = calc_vol(l, soft_vol_l, 100, lf);\n\t\tr = calc_vol(r, soft_vol_r, 100, rf);\n\t\tplayer_set_soft_volume(l, r);\n\t} else {\n\t\tmixer_read_volume();\n\t\tl = calc_vol(l, volume_l, volume_max, lf);\n\t\tr = calc_vol(r, volume_r, volume_max, rf);\n\t\trc = mixer_set_volume(l, r);\n\t\tmixer_read_volume();\n\t}\n\treturn rc;\n}\n\nvoid player_set_rg(enum replaygain rg)\n{\n\tplayer_lock();\n\t/* don't mess with scale_pos if soft_vol or replaygain is already enabled */\n\tif (!soft_vol && !replaygain)\n\t\tscale_pos = consumer_pos;\n\treplaygain = rg;\n\n\tplayer_info_priv_lock();\n\tupdate_rg_scale();\n\tplayer_info_priv_unlock();\n\n\tplayer_unlock();\n}\n\nvoid player_set_rg_limit(int limit)\n{\n\tplayer_lock();\n\treplaygain_limit = limit;\n\n\tplayer_info_priv_lock();\n\tupdate_rg_scale();\n\tplayer_info_priv_unlock();\n\n\tplayer_unlock();\n}\n\nvoid player_set_rg_preamp(double db)\n{\n\tplayer_lock();\n\treplaygain_preamp = db;\n\n\tplayer_info_priv_lock();\n\tupdate_rg_scale();\n\tplayer_info_priv_unlock();\n\n\tplayer_unlock();\n}\n\nvoid player_info_snapshot(void)\n{\n\tplayer_info_priv_lock();\n\n\tfree(player_info.error_msg);\n\tif (player_info.ti)\n\t\ttrack_info_unref(player_info.ti);\n\tmemcpy(&player_info, &player_info_priv, sizeof(player_info));\n\tif (player_info.ti)\n\t\ttrack_info_ref(player_info.ti);\n\n\tplayer_info_priv.file_changed = 0;\n\tplayer_info_priv.metadata_changed = 0;\n\tplayer_info_priv.status_changed = 0;\n\tplayer_info_priv.position_changed = 0;\n\tplayer_info_priv.buffer_fill_changed = 0;\n\tplayer_info_priv.error_msg = NULL;\n\n\tplayer_info_priv_unlock();\n}\n\nvoid player_metadata_lock(void)\n{\n\tcmus_mutex_lock(&player_info_mutex);\n}\n\nvoid player_metadata_unlock(void)\n{\n\tcmus_mutex_unlock(&player_info_mutex);\n}\n"
        },
        {
          "name": "player.h",
          "type": "blob",
          "size": 2.94921875,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_PLAYER_H\n#define CMUS_PLAYER_H\n\n#include \"locking.h\"\n#include \"track_info.h\"\n\n#include <pthread.h>\n\nenum {\n\t/* no error */\n\tPLAYER_ERROR_SUCCESS,\n\t/* system error (error code in errno) */\n\tPLAYER_ERROR_ERRNO,\n\t/* function not supported */\n\tPLAYER_ERROR_NOT_SUPPORTED\n};\n\nextern const char * const player_status_names[];\nenum player_status {\n\tPLAYER_STATUS_STOPPED,\n\tPLAYER_STATUS_PLAYING,\n\tPLAYER_STATUS_PAUSED,\n\tNR_PLAYER_STATUS\n};\n\nenum replaygain {\n\tRG_DISABLED,\n\tRG_TRACK,\n\tRG_ALBUM,\n\tRG_TRACK_PREFERRED,\n\tRG_ALBUM_PREFERRED,\n\tRG_SMART\n};\n\nstruct player_info {\n\t/* current track */\n\tstruct track_info *ti;\n\n\t/* status */\n\tenum player_status status;\n\tint pos;\n\tint current_bitrate;\n\n\tint buffer_fill;\n\tint buffer_size;\n\n\t/* display this if not NULL */\n\tchar *error_msg;\n\n\tunsigned int file_changed : 1;\n\tunsigned int metadata_changed : 1;\n\tunsigned int status_changed : 1;\n\tunsigned int position_changed : 1;\n\tunsigned int buffer_fill_changed : 1;\n};\n\nextern char player_metadata[255 * 16 + 1];\nextern struct player_info player_info;\nextern int player_cont;\nextern int player_cont_album;\nextern int player_repeat_current;\nextern enum replaygain replaygain;\nextern int replaygain_limit;\nextern double replaygain_preamp;\nextern int soft_vol;\nextern int soft_vol_l;\nextern int soft_vol_r;\n\nvoid player_init(void);\nvoid player_exit(void);\n\n/* set current file */\nvoid player_set_file(struct track_info *ti);\n\n/* set current file and start playing */\nvoid player_play_file(struct track_info *ti);\n\n/* update track info */\nvoid player_file_changed(struct track_info *ti);\n\nvoid player_play(void);\nvoid player_stop(void);\nvoid player_pause(void);\nvoid player_pause_playback(void);\nvoid player_seek(double offset, int relative, int start_playing);\nvoid player_set_op(const char *name);\nvoid player_set_buffer_chunks(unsigned int nr_chunks);\nint player_get_buffer_chunks(void);\nvoid player_info_snapshot(void);\n\nvoid player_set_soft_volume(int l, int r);\nvoid player_set_soft_vol(int soft);\nvoid player_set_rg(enum replaygain rg);\nvoid player_set_rg_limit(int limit);\nvoid player_set_rg_preamp(double db);\n\n#define VF_RELATIVE\t0x01\n#define VF_PERCENTAGE\t0x02\nint player_set_vol(int l, int lf, int r, int rf);\n\nvoid player_metadata_lock(void);\nvoid player_metadata_unlock(void);\n\n#endif\n"
        },
        {
          "name": "prog.c",
          "type": "blob",
          "size": 3.029296875,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2005 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"prog.h\"\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <errno.h>\n\nchar *program_name = NULL;\n\nvoid warn(const char *format, ...)\n{\n\tva_list ap;\n\n\tfprintf(stderr, \"%s: \", program_name);\n\tva_start(ap, format);\n\tvfprintf(stderr, format, ap);\n\tva_end(ap);\n}\n\nvoid warn_errno(const char *format, ...)\n{\n\tint e = errno;\n\tva_list ap;\n\n\tfprintf(stderr, \"%s: \", program_name);\n\tva_start(ap, format);\n\tvfprintf(stderr, format, ap);\n\tva_end(ap);\n\tfprintf(stderr, \": %s\\n\", strerror(e));\n}\n\nvoid CMUS_NORETURN die(const char *format, ...)\n{\n\tva_list ap;\n\n\tfprintf(stderr, \"%s: \", program_name);\n\tva_start(ap, format);\n\tvfprintf(stderr, format, ap);\n\tva_end(ap);\n\texit(1);\n}\n\nvoid CMUS_NORETURN die_errno(const char *format, ...)\n{\n\tint e = errno;\n\tva_list ap;\n\n\tfprintf(stderr, \"%s: \", program_name);\n\tva_start(ap, format);\n\tvfprintf(stderr, format, ap);\n\tva_end(ap);\n\tfprintf(stderr, \": %s\\n\", strerror(e));\n\texit(1);\n}\n\nstatic int short_option(int ch, const struct option *options)\n{\n\tint i;\n\n\tfor (i = 0; ; i++) {\n\t\tif (!options[i].short_opt) {\n\t\t\tif (!options[i].long_opt)\n\t\t\t\tdie(\"unrecognized option `-%c'\\n\", ch);\n\t\t\tcontinue;\n\t\t}\n\t\tif (options[i].short_opt != ch)\n\t\t\tcontinue;\n\t\treturn i;\n\t}\n}\n\nstatic int long_option(const char *opt, const struct option *options)\n{\n\tint len, i, idx, num;\n\n\tlen = strlen(opt);\n\tidx = -1;\n\tnum = 0;\n\tfor (i = 0; options[i].short_opt || options[i].long_opt; i++) {\n\t\tif (options[i].long_opt && strncmp(opt, options[i].long_opt, len) == 0) {\n\t\t\tidx = i;\n\t\t\tnum++;\n\t\t\tif (options[i].long_opt[len] == 0) {\n\t\t\t\t/* exact */\n\t\t\t\tnum = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (num > 1)\n\t\tdie(\"option `--%s' is ambiguous\\n\", opt);\n\tif (num == 0)\n\t\tdie(\"unrecognized option `--%s'\\n\", opt);\n\treturn idx;\n}\n\nint get_option(char **argvp[], const struct option *options, char **arg)\n{\n\tchar **argv = *argvp;\n\tconst char *opt = *argv;\n\tint i;\n\n\t*arg = NULL;\n\tif (opt == NULL || opt[0] != '-' || opt[1] == 0)\n\t\treturn -1;\n\n\tif (opt[1] == '-') {\n\t\tif (opt[2] == 0) {\n\t\t\t/* '--' => no more options */\n\t\t\t*argvp = argv + 1;\n\t\t\treturn -1;\n\t\t}\n\t\ti = long_option(opt + 2, options);\n\t} else if (opt[2]) {\n\t\treturn -1;\n\t} else {\n\t\ti = short_option(opt[1], options);\n\t}\n\targv++;\n\tif (options[i].has_arg) {\n\t\tif (*argv == NULL)\n\t\t\tdie(\"option `%s' requires an argument\\n\", opt);\n\t\t*arg = *argv++;\n\t}\n\t*argvp = argv;\n\treturn i;\n}\n"
        },
        {
          "name": "prog.h",
          "type": "blob",
          "size": 1.427734375,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2005 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_PROG_H\n#define CMUS_PROG_H\n\n#include \"compiler.h\"\n\n/* set in beginning of main */\nextern char *program_name;\n\nstruct option {\n\t/* short option or 0 */\n\tint short_opt;\n\n\t/* long option or NULL */\n\tconst char *long_opt;\n\n\t/* does option have an argument */\n\tint has_arg;\n};\n\n/*\n * arg: returned argument if .has_arg is 1\n *\n * returns: index to options array or -1 of no more options\n */\nint get_option(char **argv[], const struct option *options, char **arg);\n\nvoid warn(const char *format, ...) CMUS_FORMAT(1, 2);\nvoid warn_errno(const char *format, ...) CMUS_FORMAT(1, 2);\nvoid die(const char *format, ...) CMUS_FORMAT(1, 2) CMUS_NORETURN;\nvoid die_errno(const char *format, ...) CMUS_FORMAT(1, 2) CMUS_NORETURN;\n\n#endif\n"
        },
        {
          "name": "rbtree.c",
          "type": "blob",
          "size": 8.1943359375,
          "content": "/* Stolen from Linux 2.6.34 */\n\n/*\n  Red Black Trees\n  (C) 1999  Andrea Arcangeli <andrea@suse.de>\n  (C) 2002  David Woodhouse <dwmw2@infradead.org>\n\n  This program is free software; you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation; either version 2 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program; if not, see <http://www.gnu.org/licenses/>.\n\n  linux/lib/rbtree.c\n*/\n\n#include \"rbtree.h\"\n\nstatic void _rb_rotate_left(struct rb_node *node, struct rb_root *root)\n{\n\tstruct rb_node *right = node->rb_right;\n\tstruct rb_node *parent = rb_parent(node);\n\n\tif ((node->rb_right = right->rb_left))\n\t\trb_set_parent(right->rb_left, node);\n\tright->rb_left = node;\n\n\trb_set_parent(right, parent);\n\n\tif (parent)\n\t{\n\t\tif (node == parent->rb_left)\n\t\t\tparent->rb_left = right;\n\t\telse\n\t\t\tparent->rb_right = right;\n\t}\n\telse\n\t\troot->rb_node = right;\n\trb_set_parent(node, right);\n}\n\nstatic void _rb_rotate_right(struct rb_node *node, struct rb_root *root)\n{\n\tstruct rb_node *left = node->rb_left;\n\tstruct rb_node *parent = rb_parent(node);\n\n\tif ((node->rb_left = left->rb_right))\n\t\trb_set_parent(left->rb_right, node);\n\tleft->rb_right = node;\n\n\trb_set_parent(left, parent);\n\n\tif (parent)\n\t{\n\t\tif (node == parent->rb_right)\n\t\t\tparent->rb_right = left;\n\t\telse\n\t\t\tparent->rb_left = left;\n\t}\n\telse\n\t\troot->rb_node = left;\n\trb_set_parent(node, left);\n}\n\nvoid rb_insert_color(struct rb_node *node, struct rb_root *root)\n{\n\tstruct rb_node *parent, *gparent;\n\n\twhile ((parent = rb_parent(node)) && rb_is_red(parent))\n\t{\n\t\tgparent = rb_parent(parent);\n\n\t\tif (parent == gparent->rb_left)\n\t\t{\n\t\t\t{\n\t\t\t\tregister struct rb_node *uncle = gparent->rb_right;\n\t\t\t\tif (uncle && rb_is_red(uncle))\n\t\t\t\t{\n\t\t\t\t\trb_set_black(uncle);\n\t\t\t\t\trb_set_black(parent);\n\t\t\t\t\trb_set_red(gparent);\n\t\t\t\t\tnode = gparent;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (parent->rb_right == node)\n\t\t\t{\n\t\t\t\tregister struct rb_node *tmp;\n\t\t\t\t_rb_rotate_left(parent, root);\n\t\t\t\ttmp = parent;\n\t\t\t\tparent = node;\n\t\t\t\tnode = tmp;\n\t\t\t}\n\n\t\t\trb_set_black(parent);\n\t\t\trb_set_red(gparent);\n\t\t\t_rb_rotate_right(gparent, root);\n\t\t} else {\n\t\t\t{\n\t\t\t\tregister struct rb_node *uncle = gparent->rb_left;\n\t\t\t\tif (uncle && rb_is_red(uncle))\n\t\t\t\t{\n\t\t\t\t\trb_set_black(uncle);\n\t\t\t\t\trb_set_black(parent);\n\t\t\t\t\trb_set_red(gparent);\n\t\t\t\t\tnode = gparent;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (parent->rb_left == node)\n\t\t\t{\n\t\t\t\tregister struct rb_node *tmp;\n\t\t\t\t_rb_rotate_right(parent, root);\n\t\t\t\ttmp = parent;\n\t\t\t\tparent = node;\n\t\t\t\tnode = tmp;\n\t\t\t}\n\n\t\t\trb_set_black(parent);\n\t\t\trb_set_red(gparent);\n\t\t\t_rb_rotate_left(gparent, root);\n\t\t}\n\t}\n\n\trb_set_black(root->rb_node);\n}\n\nstatic void _rb_erase_color(struct rb_node *node, struct rb_node *parent,\n\t\t\t     struct rb_root *root)\n{\n\tstruct rb_node *other;\n\n\twhile ((!node || rb_is_black(node)) && node != root->rb_node)\n\t{\n\t\tif (parent->rb_left == node)\n\t\t{\n\t\t\tother = parent->rb_right;\n\t\t\tif (rb_is_red(other))\n\t\t\t{\n\t\t\t\trb_set_black(other);\n\t\t\t\trb_set_red(parent);\n\t\t\t\t_rb_rotate_left(parent, root);\n\t\t\t\tother = parent->rb_right;\n\t\t\t}\n\t\t\tif ((!other->rb_left || rb_is_black(other->rb_left)) &&\n\t\t\t    (!other->rb_right || rb_is_black(other->rb_right)))\n\t\t\t{\n\t\t\t\trb_set_red(other);\n\t\t\t\tnode = parent;\n\t\t\t\tparent = rb_parent(node);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!other->rb_right || rb_is_black(other->rb_right))\n\t\t\t\t{\n\t\t\t\t\trb_set_black(other->rb_left);\n\t\t\t\t\trb_set_red(other);\n\t\t\t\t\t_rb_rotate_right(other, root);\n\t\t\t\t\tother = parent->rb_right;\n\t\t\t\t}\n\t\t\t\trb_set_color(other, rb_color(parent));\n\t\t\t\trb_set_black(parent);\n\t\t\t\trb_set_black(other->rb_right);\n\t\t\t\t_rb_rotate_left(parent, root);\n\t\t\t\tnode = root->rb_node;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tother = parent->rb_left;\n\t\t\tif (rb_is_red(other))\n\t\t\t{\n\t\t\t\trb_set_black(other);\n\t\t\t\trb_set_red(parent);\n\t\t\t\t_rb_rotate_right(parent, root);\n\t\t\t\tother = parent->rb_left;\n\t\t\t}\n\t\t\tif ((!other->rb_left || rb_is_black(other->rb_left)) &&\n\t\t\t    (!other->rb_right || rb_is_black(other->rb_right)))\n\t\t\t{\n\t\t\t\trb_set_red(other);\n\t\t\t\tnode = parent;\n\t\t\t\tparent = rb_parent(node);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!other->rb_left || rb_is_black(other->rb_left))\n\t\t\t\t{\n\t\t\t\t\trb_set_black(other->rb_right);\n\t\t\t\t\trb_set_red(other);\n\t\t\t\t\t_rb_rotate_left(other, root);\n\t\t\t\t\tother = parent->rb_left;\n\t\t\t\t}\n\t\t\t\trb_set_color(other, rb_color(parent));\n\t\t\t\trb_set_black(parent);\n\t\t\t\trb_set_black(other->rb_left);\n\t\t\t\t_rb_rotate_right(parent, root);\n\t\t\t\tnode = root->rb_node;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (node)\n\t\trb_set_black(node);\n}\n\nvoid rb_erase(struct rb_node *node, struct rb_root *root)\n{\n\tstruct rb_node *child, *parent;\n\tint color;\n\n\tif (!node->rb_left)\n\t\tchild = node->rb_right;\n\telse if (!node->rb_right)\n\t\tchild = node->rb_left;\n\telse\n\t{\n\t\tstruct rb_node *old = node, *left;\n\n\t\tnode = node->rb_right;\n\t\twhile ((left = node->rb_left) != NULL)\n\t\t\tnode = left;\n\n\t\tif (rb_parent(old)) {\n\t\t\tif (rb_parent(old)->rb_left == old)\n\t\t\t\trb_parent(old)->rb_left = node;\n\t\t\telse\n\t\t\t\trb_parent(old)->rb_right = node;\n\t\t} else\n\t\t\troot->rb_node = node;\n\n\t\tchild = node->rb_right;\n\t\tparent = rb_parent(node);\n\t\tcolor = rb_color(node);\n\n\t\tif (parent == old) {\n\t\t\tparent = node;\n\t\t} else {\n\t\t\tif (child)\n\t\t\t\trb_set_parent(child, parent);\n\t\t\tparent->rb_left = child;\n\n\t\t\tnode->rb_right = old->rb_right;\n\t\t\trb_set_parent(old->rb_right, node);\n\t\t}\n\n\t\tnode->rb_parent_color = old->rb_parent_color;\n\t\tnode->rb_left = old->rb_left;\n\t\trb_set_parent(old->rb_left, node);\n\n\t\tgoto color;\n\t}\n\n\tparent = rb_parent(node);\n\tcolor = rb_color(node);\n\n\tif (child)\n\t\trb_set_parent(child, parent);\n\tif (parent)\n\t{\n\t\tif (parent->rb_left == node)\n\t\t\tparent->rb_left = child;\n\t\telse\n\t\t\tparent->rb_right = child;\n\t}\n\telse\n\t\troot->rb_node = child;\n\n color:\n\tif (color == RB_BLACK)\n\t\t_rb_erase_color(child, parent, root);\n}\n\n/*\n * This function returns the first node (in sort order) of the tree.\n */\nstruct rb_node *rb_first(const struct rb_root *root)\n{\n\tstruct rb_node\t*n;\n\n\tn = root->rb_node;\n\tif (!n)\n\t\treturn NULL;\n\twhile (n->rb_left)\n\t\tn = n->rb_left;\n\treturn n;\n}\n\nstruct rb_node *rb_last(const struct rb_root *root)\n{\n\tstruct rb_node\t*n;\n\n\tn = root->rb_node;\n\tif (!n)\n\t\treturn NULL;\n\twhile (n->rb_right)\n\t\tn = n->rb_right;\n\treturn n;\n}\n\nstruct rb_node *rb_next(const struct rb_node *node)\n{\n\tstruct rb_node *parent;\n\n\tif (rb_parent(node) == node)\n\t\treturn NULL;\n\n\t/* If we have a right-hand child, go down and then left as far\n\t   as we can. */\n\tif (node->rb_right) {\n\t\tnode = node->rb_right;\n\t\twhile (node->rb_left)\n\t\t\tnode=node->rb_left;\n\t\treturn (struct rb_node *)node;\n\t}\n\n\t/* No right-hand children.  Everything down and left is\n\t   smaller than us, so any 'next' node must be in the general\n\t   direction of our parent. Go up the tree; any time the\n\t   ancestor is a right-hand child of its parent, keep going\n\t   up. First time it's a left-hand child of its parent, said\n\t   parent is our 'next' node. */\n\twhile ((parent = rb_parent(node)) && node == parent->rb_right)\n\t\tnode = parent;\n\n\treturn parent;\n}\n\nstruct rb_node *rb_prev(const struct rb_node *node)\n{\n\tstruct rb_node *parent;\n\n\tif (rb_parent(node) == node)\n\t\treturn NULL;\n\n\t/* If we have a left-hand child, go down and then right as far\n\t   as we can. */\n\tif (node->rb_left) {\n\t\tnode = node->rb_left;\n\t\twhile (node->rb_right)\n\t\t\tnode=node->rb_right;\n\t\treturn (struct rb_node *)node;\n\t}\n\n\t/* No left-hand children. Go up till we find an ancestor which\n\t   is a right-hand child of its parent */\n\twhile ((parent = rb_parent(node)) && node == parent->rb_left)\n\t\tnode = parent;\n\n\treturn parent;\n}\n\nvoid rb_replace_node(struct rb_node *victim, struct rb_node *new,\n\t\t     struct rb_root *root)\n{\n\tstruct rb_node *parent = rb_parent(victim);\n\n\t/* Set the surrounding nodes to point to the replacement */\n\tif (parent) {\n\t\tif (victim == parent->rb_left)\n\t\t\tparent->rb_left = new;\n\t\telse\n\t\t\tparent->rb_right = new;\n\t} else {\n\t\troot->rb_node = new;\n\t}\n\tif (victim->rb_left)\n\t\trb_set_parent(victim->rb_left, new);\n\tif (victim->rb_right)\n\t\trb_set_parent(victim->rb_right, new);\n\n\t/* Copy the pointers/colour from the victim to the replacement */\n\t*new = *victim;\n}\n"
        },
        {
          "name": "rbtree.h",
          "type": "blob",
          "size": 6.87109375,
          "content": "/* Stolen from Linux 2.6.34 */\n\n/*\n  Red Black Trees\n  (C) 1999  Andrea Arcangeli <andrea@suse.de>\n\n  This program is free software; you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation; either version 2 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program; if not, see <http://www.gnu.org/licenses/>.\n\n  linux/include/linux/rbtree.h\n\n  To use rbtrees you'll have to implement your own insert and search cores.\n  This will avoid us to use callbacks and to drop drammatically performances.\n  I know it's not the cleaner way,  but in C (not in C++) to get\n  performances and genericity...\n\n  Some example of insert and search follows here. The search is a plain\n  normal search over an ordered tree. The insert instead must be implemented\n  int two steps: as first thing the code must insert the element in\n  order as a red leaf in the tree, then the support library function\n  rb_insert_color() must be called. Such function will do the\n  not trivial work to rebalance the rbtree if necessary.\n\n-----------------------------------------------------------------------\nstatic inline struct page * rb_search_page_cache(struct inode * inode,\n\t\t\t\t\t\t unsigned long offset)\n{\n\tstruct rb_node * n = inode->i_rb_page_cache.rb_node;\n\tstruct page * page;\n\n\twhile (n)\n\t{\n\t\tpage = rb_entry(n, struct page, rb_page_cache);\n\n\t\tif (offset < page->offset)\n\t\t\tn = n->rb_left;\n\t\telse if (offset > page->offset)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn page;\n\t}\n\treturn NULL;\n}\n\nstatic inline struct page * _rb_insert_page_cache(struct inode * inode,\n\t\t\t\t\t\t   unsigned long offset,\n\t\t\t\t\t\t   struct rb_node * node)\n{\n\tstruct rb_node ** p = &inode->i_rb_page_cache.rb_node;\n\tstruct rb_node * parent = NULL;\n\tstruct page * page;\n\n\twhile (*p)\n\t{\n\t\tparent = *p;\n\t\tpage = rb_entry(parent, struct page, rb_page_cache);\n\n\t\tif (offset < page->offset)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (offset > page->offset)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn page;\n\t}\n\n\trb_link_node(node, parent, p);\n\n\treturn NULL;\n}\n\nstatic inline struct page * rb_insert_page_cache(struct inode * inode,\n\t\t\t\t\t\t unsigned long offset,\n\t\t\t\t\t\t struct rb_node * node)\n{\n\tstruct page * ret;\n\tif ((ret = _rb_insert_page_cache(inode, offset, node)))\n\t\tgoto out;\n\trb_insert_color(node, &inode->i_rb_page_cache);\n out:\n\treturn ret;\n}\n-----------------------------------------------------------------------\n*/\n\n#ifndef CMUS_RBTREE_H\n#define CMUS_RBTREE_H\n\n#include \"compiler.h\" /* container_of */\n#include <stddef.h>\n\nstruct rb_node\n{\n\tunsigned long  rb_parent_color;\n#define\tRB_RED\t\t0\n#define\tRB_BLACK\t1\n\tstruct rb_node *rb_right;\n\tstruct rb_node *rb_left;\n} __attribute__((aligned(sizeof(long))));\n\t/* The alignment might seem pointless, but allegedly CRIS needs it */\n\nstruct rb_root\n{\n\tstruct rb_node *rb_node;\n};\n\n\n#define rb_parent(r)   ((struct rb_node *)((r)->rb_parent_color & ~3))\n#define rb_color(r)   ((r)->rb_parent_color & 1)\n#define rb_is_red(r)   (!rb_color(r))\n#define rb_is_black(r) rb_color(r)\n#define rb_set_red(r)  do { (r)->rb_parent_color &= ~1; } while (0)\n#define rb_set_black(r)  do { (r)->rb_parent_color |= 1; } while (0)\n\nstatic inline void rb_set_parent(struct rb_node *rb, struct rb_node *p)\n{\n\trb->rb_parent_color = (rb->rb_parent_color & 3) | (unsigned long)p;\n}\nstatic inline void rb_set_color(struct rb_node *rb, int color)\n{\n\trb->rb_parent_color = (rb->rb_parent_color & ~1) | color;\n}\n\n#define RB_ROOT\t(struct rb_root) { NULL, }\n#define\trb_entry(ptr, type, member) container_of(ptr, type, member)\n\n#define RB_EMPTY_ROOT(root)\t((root)->rb_node == NULL)\n#define RB_EMPTY_NODE(node)\t(rb_parent(node) == node)\n#define RB_CLEAR_NODE(node)\t(rb_set_parent(node, node))\n\nvoid rb_insert_color(struct rb_node *, struct rb_root *);\nvoid rb_erase(struct rb_node *, struct rb_root *);\n\n/* Find logical next and previous nodes in a tree */\nstruct rb_node *rb_next(const struct rb_node *);\nstruct rb_node *rb_prev(const struct rb_node *);\nstruct rb_node *rb_first(const struct rb_root *);\nstruct rb_node *rb_last(const struct rb_root *);\n\n/* Fast replacement of a single node without remove/rebalance/add/rebalance */\nvoid rb_replace_node(struct rb_node *victim, struct rb_node *new,\n\t\t\tstruct rb_root *root);\n\nstatic inline void rb_link_node(struct rb_node * node, struct rb_node * parent,\n\t\t\t\tstruct rb_node ** rb_link)\n{\n\tnode->rb_parent_color = (unsigned long)parent;\n\tnode->rb_left = node->rb_right = NULL;\n\n\t*rb_link = node;\n}\n\n\n/* Cmus extensions */\n\nstatic inline void rb_root_init(struct rb_root *root)\n{\n\troot->rb_node = NULL;\n}\n\nstatic inline int rb_root_empty(struct rb_root *root)\n{\n\treturn RB_EMPTY_ROOT(root);\n}\n\n/**\n * rb_for_each        -       iterate over a rbtree\n * @pos:        the &struct rb_node to use as a loop counter.\n * @root:       the root for your rbtree.\n */\n#define rb_for_each(pos, root) \\\n\tfor (pos = rb_first(root); pos; pos = rb_next(pos))\n\n/**\n * rb_for_each_prev   -       iterate over a rbtree backwards\n * @pos:        the &struct rb_node to use as a loop counter.\n * @root:       the root for your rbtree.\n */\n#define rb_for_each_prev(pos, root) \\\n\tfor (pos = rb_last(root); pos; pos = rb_prev(pos))\n\n/**\n * rb_for_each_safe   -       iterate over a rbtree safe against removal of rbtree node\n * @pos:        the &struct rb_node to use as a loop counter.\n * @n:          another &struct rb_node to use as temporary storage\n * @root:       the root for your rbtree.\n */\n#define rb_for_each_safe(pos, n, root) \\\n\tfor (pos = rb_first(root), n = pos ? rb_next(pos) : NULL; pos; \\\n\t\tpos = n, n = pos ? rb_next(pos) : NULL)\n\n/**\n * rb_for_each_entry        -       iterate over a rbtree of given type\n * @pos:        the &struct rb_node to use as a loop counter.\n * @t:          the type * to use as a loop counter.\n * @root:       the root for your rbtree.\n * @member:\tthe name of the rb_node-struct within the struct.\n */\n#define rb_for_each_entry(t, pos, root, member) \\\n\tfor (pos = rb_first(root), t = pos ? rb_entry(pos, __typeof__(*t), member) : NULL; \\\n\t\tpos; pos = rb_next(pos), t = pos ? rb_entry(pos, __typeof__(*t), member) : NULL)\n\n/**\n * rb_for_each_entry_reverse        -       iterate backwards over a rbtree of given type\n * @pos:        the &struct rb_node to use as a loop counter.\n * @t:          the type * to use as a loop counter.\n * @root:       the root for your rbtree.\n * @member:\tthe name of the rb_node-struct within the struct.\n */\n#define rb_for_each_entry_reverse(t, pos, root, member) \\\n\tfor (pos = rb_last(root), t = pos ? rb_entry(pos, __typeof__(*t), member) : NULL; \\\n\t\tpos; pos = rb_prev(pos), t = pos ? rb_entry(pos, __typeof__(*t), member) : NULL)\n\n#endif\t/* _LINUX_RBTREE_H */\n"
        },
        {
          "name": "read_wrapper.c",
          "type": "blob",
          "size": 1.6865234375,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"read_wrapper.h\"\n#include \"ip.h\"\n#include \"file.h\"\n\n#include <unistd.h>\n\nssize_t read_wrapper(struct input_plugin_data *ip_data, void *buffer, size_t count)\n{\n\tint rc;\n\n\tif (ip_data->metaint == 0) {\n\t\t/* no metadata in the stream */\n\t\treturn read(ip_data->fd, buffer, count);\n\t}\n\n\tif (ip_data->counter == ip_data->metaint) {\n\t\t/* read metadata */\n\t\tunsigned char byte;\n\t\tint len;\n\n\t\trc = read(ip_data->fd, &byte, 1);\n\t\tif (rc == -1)\n\t\t\treturn -1;\n\t\tif (rc == 0)\n\t\t\treturn 0;\n\t\tif (byte != 0) {\n\t\t\tlen = ((int)byte) * 16;\n\t\t\tip_data->metadata[0] = 0;\n\t\t\trc = read_all(ip_data->fd, ip_data->metadata, len);\n\t\t\tif (rc == -1)\n\t\t\t\treturn -1;\n\t\t\tif (rc < len) {\n\t\t\t\tip_data->metadata[0] = 0;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tip_data->metadata[len] = 0;\n\t\t\tip_data->metadata_changed = 1;\n\t\t}\n\t\tip_data->counter = 0;\n\t}\n\tif (count + ip_data->counter > ip_data->metaint)\n\t\tcount = ip_data->metaint - ip_data->counter;\n\trc = read(ip_data->fd, buffer, count);\n\tif (rc > 0)\n\t\tip_data->counter += rc;\n\treturn rc;\n}\n"
        },
        {
          "name": "read_wrapper.h",
          "type": "blob",
          "size": 0.9423828125,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_READ_WRAPPER_H\n#define CMUS_READ_WRAPPER_H\n\n#include \"ip.h\"\n\n#include <stddef.h> /* size_t */\n#include <sys/types.h> /* ssize_t */\n\nssize_t read_wrapper(struct input_plugin_data *ip_data, void *buffer, size_t count);\n\n#endif\n"
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "search.c",
          "type": "blob",
          "size": 3.7490234375,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2005 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"search.h\"\n#include \"editable.h\"\n#include \"xmalloc.h\"\n#include \"ui_curses.h\"\n#include \"convert.h\"\n#include \"options.h\"\n#include \"debug.h\"\n\nstruct searchable {\n\tvoid *data;\n\tstruct iter head;\n\tstruct searchable_ops ops;\n};\n\nstatic int advance(struct searchable *s, struct iter *iter,\n\t\tenum search_direction dir, int *wrapped)\n{\n\tif (dir == SEARCH_FORWARD) {\n\t\tif (!s->ops.get_next(iter)) {\n\t\t\tif (!wrap_search)\n\t\t\t\treturn 0;\n\t\t\t*iter = s->head;\n\t\t\tif (!s->ops.get_next(iter))\n\t\t\t\treturn 0;\n\t\t\t*wrapped += 1;\n\t\t}\n\t} else {\n\t\tif (!s->ops.get_prev(iter)) {\n\t\t\tif (!wrap_search)\n\t\t\t\treturn 0;\n\t\t\t*iter = s->head;\n\t\t\tif (!s->ops.get_prev(iter))\n\t\t\t\treturn 0;\n\t\t\t*wrapped += 1;\n\t\t}\n\t}\n\treturn 1;\n}\n\n/* returns next matching item or NULL if not found\n * result can be the current item unless skip_current is set */\nstatic int do_u_search(struct searchable *s, struct iter *iter, const char *text,\n\t\tenum search_direction dir, int skip_current)\n{\n\tstruct iter start;\n\tint wrapped = 0;\n\n\tif (skip_current && !advance(s, iter, dir, &wrapped))\n\t\treturn 0;\n\n\tstart = *iter;\n\twhile (1) {\n\t\tif (s->ops.matches(s->data, iter, text)) {\n\t\t\tif (wrapped)\n\t\t\t\tinfo_msg(dir == SEARCH_FORWARD ?\n\t\t\t\t\t \"search hit BOTTOM, continuing at TOP\" :\n\t\t\t\t\t \"search hit TOP, continuing at BOTTOM\");\n\t\t\treturn 1;\n\t\t}\n\t\tif (!advance(s, iter, dir, &wrapped) || iters_equal(iter, &start))\n\t\t\treturn 0;\n\t\t/**\n\t\t * workaround for buggy implementations of search_ops where\n\t\t * get_next/get_prev never equals the initial get_current\n\t\t * (#1332)\n\t\t */\n\t\tif (wrapped > 1) {\n\t\t\td_print(\"fixme: bailing since search wrapped more than once without a match\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n}\n\nstatic int do_search(struct searchable *s, struct iter *iter, const char *text,\n\t\tenum search_direction dir, int skip_current)\n{\n\tchar *u_text = NULL;\n\tint r;\n\n\t/* search text is always in locale encoding (because cmdline is) */\n\tif (!using_utf8 && utf8_encode(text, charset, &u_text) == 0)\n\t\ttext = u_text;\n\n\tr = do_u_search(s, iter, text, dir, skip_current);\n\n\tfree(u_text);\n\treturn r;\n}\n\nstruct searchable *searchable_new(void *data, const struct iter *head, const struct searchable_ops *ops)\n{\n\tstruct searchable *s;\n\n\ts = xnew(struct searchable, 1);\n\ts->data = data;\n\ts->head = *head;\n\ts->ops = *ops;\n\treturn s;\n}\n\nvoid searchable_free(struct searchable *s)\n{\n\tfree(s);\n}\n\nvoid searchable_set_head(struct searchable *s, const struct iter *head)\n{\n\ts->head = *head;\n}\n\nint search(struct searchable *s, const char *text, enum search_direction dir, int beginning)\n{\n\tstruct iter iter;\n\tint ret;\n\n\tif (beginning) {\n\t\t/* first or last item */\n\t\titer = s->head;\n\t\tif (dir == SEARCH_FORWARD) {\n\t\t\tret = s->ops.get_next(&iter);\n\t\t} else {\n\t\t\tret = s->ops.get_prev(&iter);\n\t\t}\n\t} else {\n\t\t/* selected item */\n\t\tret = s->ops.get_current(s->data, &iter, dir);\n\t}\n\tif (ret)\n\t\tret = do_search(s, &iter, text, dir, 0);\n\treturn ret;\n}\n\nint search_next(struct searchable *s, const char *text, enum search_direction dir)\n{\n\tstruct iter iter;\n\tint ret;\n\n\tif (!s->ops.get_current(s->data, &iter, dir)) {\n\t\treturn 0;\n\t}\n\tret = do_search(s, &iter, text, dir, 1);\n\treturn ret;\n}\n"
        },
        {
          "name": "search.h",
          "type": "blob",
          "size": 1.4921875,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2005 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_SEARCH_H\n#define CMUS_SEARCH_H\n\n#include \"iter.h\"\n\nenum search_direction { SEARCH_FORWARD, SEARCH_BACKWARD };\n\nstruct searchable_ops {\n\tint (*get_prev)(struct iter *iter);\n\tint (*get_next)(struct iter *iter);\n\tint (*get_current)(void *data, struct iter *iter, enum search_direction dir);\n\tint (*matches)(void *data, struct iter *iter, const char *text);\n};\n\nstruct searchable;\n\nstruct searchable *searchable_new(void *data, const struct iter *head, const struct searchable_ops *ops);\nvoid searchable_free(struct searchable *s);\nvoid searchable_set_head(struct searchable *s, const struct iter *head);\n\nint search(struct searchable *s, const char *text, enum search_direction dir, int beginning);\nint search_next(struct searchable *s, const char *text, enum search_direction dir);\n\n#endif\n"
        },
        {
          "name": "search_mode.c",
          "type": "blob",
          "size": 7.28125,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"search_mode.h\"\n#include \"cmdline.h\"\n#include \"history.h\"\n#include \"ui_curses.h\"\n#include \"search.h\"\n#include \"xmalloc.h\"\n#include \"xstrjoin.h\"\n#include \"misc.h\"\n#include \"lib.h\"\n#include \"options.h\"\n#include \"command_mode.h\"\n#include \"keys.h\"\n\n#include <ctype.h>\n\n/* this is set in ui_curses.c */\nenum search_direction search_direction = SEARCH_FORWARD;\n\n/* current search string, this is set _only_ when user presses enter\n * this string is used when 'n' or 'N' is pressed\n * incremental search does not use this, it uses cmdline.line directly\n */\nchar *search_str = NULL;\nint search_restricted = 0;\n\nstatic struct history search_history;\nstatic char *search_history_filename;\nstatic char *history_search_text = NULL;\n\nstatic void update_search_line(const char *text, int restricted)\n{\n\tint len = strlen(text);\n\tchar ch = search_direction == SEARCH_FORWARD ? '/' : '?';\n\tchar *buf, *ptr;\n\n\tbuf = xnew(char, len + 2);\n\tptr = buf;\n\tif (restricted)\n\t\t*ptr++ = ch;\n\tmemcpy(ptr, text, len + 1);\n\tcmdline_set_text(buf);\n\tfree(buf);\n}\n\nstatic int search_line_empty(void)\n{\n\tchar ch;\n\n\tif (cmdline.clen == 0)\n\t\treturn 1;\n\tif (cmdline.clen > 1)\n\t\treturn 0;\n\tch = search_direction == SEARCH_FORWARD ? '/' : '?';\n\treturn cmdline.line[0] == ch;\n}\n\nstatic void parse_line(const char **text, int *restricted)\n{\n\tchar ch = search_direction == SEARCH_FORWARD ? '/' : '?';\n\tint r = 0;\n\n\tif (cmdline.line[0] == ch) {\n\t\t/* //WORDS or ??WORDS */\n\t\tr = 1;\n\t}\n\t*text = cmdline.line + r;\n\t*restricted = r;\n}\n\nstatic void reset_history_search(void)\n{\n\thistory_reset_search(&search_history);\n\tfree(history_search_text);\n\thistory_search_text = NULL;\n}\n\nstatic void backspace(void)\n{\n\tif (cmdline.clen > 0) {\n\t\tcmdline_backspace();\n\t} else {\n\t\tinput_mode = NORMAL_MODE;\n\t}\n}\n\nstatic void delete(void)\n{\n\t/* save old value */\n\tint restricted = search_restricted;\n\tconst char *text;\n\n\tcmdline_delete_ch();\n\tparse_line(&text, &search_restricted);\n\tif (text[0])\n\t\tsearch(searchable, text, search_direction, 0);\n\n\t/* restore old value */\n\tsearch_restricted = restricted;\n}\n\nvoid search_text(const char *text, int restricted, int beginning)\n{\n\tif (text[0] == 0) {\n\t\t/* cmdline is \"/\", \"?\", \"//\" or \"??\" */\n\t\tif (search_str) {\n\t\t\t/* use old search string */\n\t\t\tsearch_restricted = restricted;\n\t\t\tif (!search_next(searchable, search_str, search_direction))\n\t\t\t\tsearch_not_found();\n\t\t}\n\t} else {\n\t\t/* set new search string and add it to the history */\n\t\tfree(search_str);\n\t\tsearch_str = xstrdup(text);\n\t\thistory_add_line(&search_history, text);\n\n\t\t/* search not yet done if up or down arrow was pressed */\n\t\tsearch_restricted = restricted;\n\t\tif (!search(searchable, search_str, search_direction, beginning))\n\t\t\tsearch_not_found();\n\t}\n}\n\nvoid search_mode_ch(uchar ch)\n{\n\tconst char *text;\n\tint restricted;\n\n\tswitch (ch) {\n\tcase 0x01: // ^A\n\t\tcmdline_move_home();\n\t\tbreak;\n\tcase 0x02: // ^B\n\t\tcmdline_move_left();\n\t\tbreak;\n\tcase 0x04: // ^D\n\t\tdelete();\n\t\tbreak;\n\tcase 0x05: // ^E\n\t\tcmdline_move_end();\n\t\tbreak;\n\tcase 0x06: // ^F\n\t\tcmdline_move_right();\n\t\tbreak;\n\tcase 0x03: // ^C\n\tcase 0x07: // ^G\n\tcase 0x1B: // ESC\n\t\tparse_line(&text, &restricted);\n\t\tif (text[0]) {\n\t\t\thistory_add_line(&search_history, text);\n\t\t\tcmdline_clear();\n\t\t}\n\t\tinput_mode = NORMAL_MODE;\n\t\tbreak;\n\tcase 0x0A:\n\t\tparse_line(&text, &restricted);\n\t\tsearch_text(text, restricted, 0);\n\t\tcmdline_clear();\n\t\tinput_mode = NORMAL_MODE;\n\t\tbreak;\n\tcase 0x0B:\n\t\tcmdline_clear_end();\n\t\tbreak;\n\tcase 0x10: // ^P\n\t\tsearch_mode_key(KEY_UP);\n\t\treturn;\n\tcase 0xE: // ^N\n\t\tsearch_mode_key(KEY_DOWN);\n\t\treturn;\n\tcase 0x15:\n\t\tcmdline_backspace_to_bol();\n\t\tbreak;\n\tcase 0x17: // ^W\n\t\tcmdline_backward_delete_word(cmdline_word_delimiters);\n\t\tbreak;\n\tcase 0x08: // ^H\n\tcase 127:\n\t\tbackspace();\n\t\tbreak;\n\tdefault:\n\t\tif (ch < 0x20) {\n\t\t\treturn;\n\t\t} else {\n\t\t\t/* start from beginning if this is first char */\n\t\t\tint beginning = search_resets_position && search_line_empty();\n\n\t\t\t/* save old value\n\t\t\t *\n\t\t\t * don't set search_{str,restricted} here because\n\t\t\t * search can be cancelled by pressing ESC\n\t\t\t */\n\t\t\trestricted = search_restricted;\n\n\t\t\tcmdline_insert_ch(ch);\n\t\t\tparse_line(&text, &search_restricted);\n\t\t\tsearch(searchable, text, search_direction, beginning);\n\n\t\t\t/* restore old value */\n\t\t\tsearch_restricted = restricted;\n\t\t}\n\t\tbreak;\n\t}\n\treset_history_search();\n}\n\nvoid search_mode_escape(int c)\n{\n\tswitch (c) {\n\tcase 98:\n\t\tcmdline_backward_word(cmdline_filename_delimiters);\n\t\tbreak;\n\tcase 100:\n\t\tcmdline_delete_word(cmdline_filename_delimiters);\n\t\tbreak;\n\tcase 102:\n\t\tcmdline_forward_word(cmdline_filename_delimiters);\n\t\tbreak;\n\tcase 127:\n\tcase KEY_BACKSPACE:\n\t\tcmdline_backward_delete_word(cmdline_filename_delimiters);\n\t\tbreak;\n\t}\n\treset_history_search();\n}\n\nvoid search_mode_key(int key)\n{\n\tconst char *text;\n\tint restricted;\n\n\tswitch (key) {\n\tcase KEY_DC:\n\t\tdelete();\n\t\tbreak;\n\tcase KEY_BACKSPACE:\n\t\tbackspace();\n\t\tbreak;\n\tcase KEY_LEFT:\n\t\tcmdline_move_left();\n\t\treturn;\n\tcase KEY_RIGHT:\n\t\tcmdline_move_right();\n\t\treturn;\n\tcase KEY_HOME:\n\t\tcmdline_move_home();\n\t\treturn;\n\tcase KEY_END:\n\t\tcmdline_move_end();\n\t\treturn;\n\tcase KEY_UP:\n\t\tparse_line(&text, &restricted);\n\t\tif (history_search_text == NULL)\n\t\t\thistory_search_text = xstrdup(text);\n\t\ttext = history_search_forward(&search_history, history_search_text);\n\t\tif (text)\n\t\t\tupdate_search_line(text, restricted);\n\t\treturn;\n\tcase KEY_DOWN:\n\t\tif (history_search_text) {\n\t\t\tparse_line(&text, &restricted);\n\t\t\ttext = history_search_backward(&search_history, history_search_text);\n\t\t\tif (text) {\n\t\t\t\tupdate_search_line(text, restricted);\n\t\t\t} else {\n\t\t\t\tupdate_search_line(history_search_text, restricted);\n\t\t\t}\n\t\t}\n\t\treturn;\n\tdefault:\n\t\treturn;\n\t}\n\treset_history_search();\n}\n\nvoid search_mode_mouse(MEVENT *event)\n{\n\tif ((event->bstate & BUTTON1_PRESSED) || (event->bstate & BUTTON3_PRESSED)) {\n\t\tconst char *text;\n\t\tint restricted;\n\t\tif (event->y <= window_get_nr_rows(current_win()) + 2) {\n\t\t\tparse_line(&text, &restricted);\n\t\t\tif (text[0]) {\n\t\t\t\thistory_add_line(&search_history, text);\n\t\t\t\tcmdline_clear();\n\t\t\t}\n\t\t\tinput_mode = NORMAL_MODE;\n\t\t\tnormal_mode_mouse(event);\n\t\t\treturn;\n\t\t}\n\t\tif (event->x == 0)\n\t\t\treturn;\n\t\tint i = event->x > cmdline.clen ? cmdline.clen : event->x - 1;\n\t\twhile (i < cmdline.cpos)\n\t\t\tcmdline_move_left();\n\t\twhile (i > cmdline.cpos)\n\t\t\tcmdline_move_right();\n\t} else if (event->bstate & BUTTON4_PRESSED) {\n\t\tsearch_mode_key(KEY_UP);\n\t} else if (event->bstate & BUTTON5_PRESSED) {\n\t\tsearch_mode_key(KEY_DOWN);\n\t}\n}\n\nvoid search_mode_init(void)\n{\n\tsearch_history_filename = xstrjoin(cmus_config_dir, \"/search-history\");\n\thistory_load(&search_history, search_history_filename, 100);\n}\n\nvoid search_mode_exit(void)\n{\n\thistory_save(&search_history);\n\thistory_free(&search_history);\n\tfree(search_history_filename);\n}\n"
        },
        {
          "name": "search_mode.h",
          "type": "blob",
          "size": 1.275390625,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_SEARCH_MODE_H\n#define CMUS_SEARCH_MODE_H\n\n#include \"search.h\"\n#include \"uchar.h\"\n\n#if defined(__sun__)\n#include <ncurses.h>\n#else\n#include <curses.h>\n#endif\n\nextern char *search_str;\nextern enum search_direction search_direction;\n\n/* //WORDS or ??WORDS search mode */\nextern int search_restricted;\n\nvoid search_mode_ch(uchar ch);\nvoid search_mode_escape(int c);\nvoid search_mode_key(int key);\nvoid search_mode_mouse(MEVENT *event);\nvoid search_mode_init(void);\nvoid search_mode_exit(void);\n\nvoid search_text(const char *text, int restricted, int beginning);\n\n#endif\n"
        },
        {
          "name": "server.c",
          "type": "blob",
          "size": 9.3828125,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004-2005 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"server.h\"\n#include \"prog.h\"\n#include \"command_mode.h\"\n#include \"search_mode.h\"\n#include \"options.h\"\n#include \"output.h\"\n#include \"utils.h\"\n#include \"xmalloc.h\"\n#include \"player.h\"\n#include \"file.h\"\n#include \"compiler.h\"\n#include \"debug.h\"\n#include \"gbuf.h\"\n#include \"ui_curses.h\"\n#include \"misc.h\"\n#include \"keyval.h\"\n#include \"convert.h\"\n#include \"format_print.h\"\n\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <errno.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <ctype.h>\n\nint server_socket;\nLIST_HEAD(client_head);\n\nstatic char *title_buf = NULL;\n\nstatic union {\n\tstruct sockaddr sa;\n\tstruct sockaddr_un un;\n\tstruct sockaddr_storage sas;\n} addr;\n\n#define MAX_CLIENTS 10\n\nstatic int cmd_status(struct client *client)\n{\n\tconst char *export_options[] = {\n\t\t\"aaa_mode\",\n\t\t\"continue\",\n\t\t\"play_library\",\n\t\t\"play_sorted\",\n\t\t\"replaygain\",\n\t\t\"replaygain_limit\",\n\t\t\"replaygain_preamp\",\n\t\t\"repeat\",\n\t\t\"repeat_current\",\n\t\t\"shuffle\",\n\t\t\"softvol\",\n\t\tNULL\n\t};\n\tconst struct track_info *ti;\n\tstruct cmus_opt *opt;\n\tchar optbuf[OPTION_MAX_SIZE];\n\tGBUF(buf);\n\tint vol_left, vol_right;\n\tint i, ret;\n\tenum player_status status;\n\n\tgbuf_addf(&buf, \"status %s\\n\", player_status_names[player_info.status]);\n\tti = player_info.ti;\n\tif (ti) {\n\t\tgbuf_addf(&buf, \"file %s\\n\", escape(ti->filename));\n\t\tgbuf_addf(&buf, \"duration %d\\n\", ti->duration);\n\t\tgbuf_addf(&buf, \"position %d\\n\", player_info.pos);\n\t\tfor (i = 0; ti->comments[i].key; i++)\n\t\t\tgbuf_addf(&buf, \"tag %s %s\\n\",\n\t\t\t\t\tti->comments[i].key,\n\t\t\t\t\tescape(ti->comments[i].val));\n\t}\n\n\t/* add track metadata to cmus-status */\n\tstatus = player_info.status;\n\tif (status == PLAYER_STATUS_PLAYING && ti && is_http_url(player_info.ti->filename)) {\n\tconst char *title = get_stream_title();\n\t\tif (title != NULL) {\n\t\t\tfree(title_buf);\n\t\t\ttitle_buf = to_utf8(title, icecast_default_charset);\n\t\t\t// we have a stream title (probably artist/track/album info)\n\t\t\tgbuf_addf(&buf, \"stream %s\\n\", escape(title_buf));\n\t\t} else if (ti->comment != NULL) {\n\t\t\t// fallback to the radio station name\n\t\t\tgbuf_addf(&buf, \"stream %s\\n\", escape(ti->comment));\n\t\t}\n\t}\n\n\t/* output options */\n\tfor (i = 0; export_options[i]; i++) {\n\t\topt = option_find(export_options[i]);\n\t\tif (opt) {\n\t\t\topt->get(opt->data, optbuf, OPTION_MAX_SIZE);\n\t\t\tgbuf_addf(&buf, \"set %s %s\\n\", opt->name, optbuf);\n\t\t}\n\t}\n\n\t/* get volume (copied from ui_curses.c) */\n\tif (soft_vol) {\n\t\tvol_left = soft_vol_l;\n\t\tvol_right = soft_vol_r;\n\t} else if (!volume_max) {\n\t\tvol_left = vol_right = -1;\n\t} else {\n\t\tvol_left = scale_to_percentage(volume_l, volume_max);\n\t\tvol_right = scale_to_percentage(volume_r, volume_max);\n\t}\n\n\t/* output volume */\n\tgbuf_addf(&buf, \"set vol_left %d\\n\", vol_left);\n\tgbuf_addf(&buf, \"set vol_right %d\\n\", vol_right);\n\n\tgbuf_add_str(&buf, \"\\n\");\n\n\tret = write_all(client->fd, buf.buffer, buf.len);\n\tgbuf_free(&buf);\n\treturn ret;\n}\n\nstatic int cmd_format_print(struct client *client, char *arg)\n{\n\tif (run_only_safe_commands) {\n\t\td_print(\"trying to execute unsafe command over net\\n\");\n\t\treturn write_all(client->fd, \"\\n\", strlen(\"\\n\"));\n\t}\n\n\tint args_idx, ac, i, ret;\n\tchar **args = NULL;\n\n\tif (arg)\n\t\targs = parse_cmd(arg, &args_idx, &ac);\n\n\tif (args == NULL) {\n\t\terror_msg(\"not enough arguments\\n\");\n\t\treturn write_all(client->fd, \"\\n\", strlen(\"\\n\"));\n\t}\n\n\tGBUF(buf);\n\n\tconst struct format_option *fopts = get_global_fopts();\n\tfor (i = 0; i < ac; ++i) {\n\t\tif (format_valid(args[i], fopts))\n\t\t\tformat_print(&buf, 0, args[i], fopts);\n\t\tgbuf_add_ch(&buf, '\\n');\n\t\tfree(args[i]);\n\t}\n\tgbuf_add_ch(&buf, '\\n');\n\n\tret = write_all(client->fd, buf.buffer, buf.len);\n\tgbuf_free(&buf);\n\tfree(args);\n\treturn ret;\n}\n\nstatic ssize_t send_answer(int fd, const char *format, ...)\n{\n\tchar buf[512];\n\tva_list ap;\n\n\tva_start(ap, format);\n\tvsnprintf(buf, sizeof(buf), format, ap);\n\tva_end(ap);\n\n\treturn write_all(fd, buf, strlen(buf));\n}\n\nstatic void read_commands(struct client *client)\n{\n\tchar buf[1024];\n\tint pos = 0;\n\tif (!client->authenticated)\n\t\tclient->authenticated = addr.sa.sa_family == AF_UNIX;\n\n\twhile (1) {\n\t\tint rc, s, i;\n\n\t\trc = read(client->fd, buf + pos, sizeof(buf) - pos);\n\t\tif (rc == -1) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tif (errno == EAGAIN)\n\t\t\t\treturn;\n\t\t\tgoto close;\n\t\t}\n\t\tif (rc == 0)\n\t\t\tgoto close;\n\t\tpos += rc;\n\n\t\ts = 0;\n\t\tfor (i = 0; i < pos; i++) {\n\t\t\tconst char *line, *msg;\n\t\t\tchar *cmd, *arg;\n\t\t\tint ret;\n\n\t\t\tif (buf[i] != '\\n')\n\t\t\t\tcontinue;\n\n\t\t\tbuf[i] = 0;\n\t\t\tline = buf + s;\n\t\t\ts = i + 1;\n\n\t\t\tif (!client->authenticated) {\n\t\t\t\tif (!server_password) {\n\t\t\t\t\tmsg = \"password is unset, tcp/ip disabled\";\n\t\t\t\t\td_print(\"%s\\n\", msg);\n\t\t\t\t\tret = send_answer(client->fd, \"%s\\n\\n\", msg);\n\t\t\t\t\tgoto close;\n\t\t\t\t}\n\t\t\t\tif (strncmp(line, \"passwd \", 7) == 0)\n\t\t\t\t\tline += 7;\n\t\t\t\tclient->authenticated = !strcmp(line, server_password);\n\t\t\t\tif (!client->authenticated) {\n\t\t\t\t\tmsg = \"authentication failed\";\n\t\t\t\t\td_print(\"%s\\n\", msg);\n\t\t\t\t\tret = send_answer(client->fd, \"%s\\n\\n\", msg);\n\t\t\t\t\tgoto close;\n\t\t\t\t}\n\t\t\t\tret = write_all(client->fd, \"\\n\", 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\twhile (isspace((unsigned char)*line))\n\t\t\t\tline++;\n\n\t\t\tif (*line == '/') {\n\t\t\t\tint restricted = 0;\n\t\t\t\tline++;\n\t\t\t\tsearch_direction = SEARCH_FORWARD;\n\t\t\t\tif (*line == '/') {\n\t\t\t\t\tline++;\n\t\t\t\t\trestricted = 1;\n\t\t\t\t}\n\t\t\t\tsearch_text(line, restricted, 1);\n\t\t\t\tret = write_all(client->fd, \"\\n\", 1);\n\t\t\t} else if (*line == '?') {\n\t\t\t\tint restricted = 0;\n\t\t\t\tline++;\n\t\t\t\tsearch_direction = SEARCH_BACKWARD;\n\t\t\t\tif (*line == '?') {\n\t\t\t\t\tline++;\n\t\t\t\t\trestricted = 1;\n\t\t\t\t}\n\t\t\t\tsearch_text(line, restricted, 1);\n\t\t\t\tret = write_all(client->fd, \"\\n\", 1);\n\t\t\t} else if (parse_command(line, &cmd, &arg)) {\n\t\t\t\tif (!strcmp(cmd, \"status\")) {\n\t\t\t\t\tret = cmd_status(client);\n\t\t\t\t} else if (!strcmp(cmd, \"format_print\")) {\n\t\t\t\t\tret = cmd_format_print(client, arg);\n\t\t\t\t} else {\n\t\t\t\t\tif (strcmp(cmd, \"passwd\") != 0) {\n\t\t\t\t\t\tset_client_fd(client->fd);\n\t\t\t\t\t\trun_parsed_command(cmd, arg);\n\t\t\t\t\t\tset_client_fd(-1);\n\t\t\t\t\t}\n\t\t\t\t\tret = write_all(client->fd, \"\\n\", 1);\n\t\t\t\t}\n\t\t\t\tfree(cmd);\n\t\t\t\tfree(arg);\n\t\t\t} else {\n\t\t\t\t// don't hang cmus-remote\n\t\t\t\tret = write_all(client->fd, \"\\n\", 1);\n\t\t\t}\n\t\t\tif (ret < 0) {\n\t\t\t\td_print(\"write: %s\\n\", strerror(errno));\n\t\t\t\tgoto close;\n\t\t\t}\n\t\t}\n\t\tmemmove(buf, buf + s, pos - s);\n\t\tpos -= s;\n\t}\n\treturn;\nclose:\n\tclose(client->fd);\n\tlist_del(&client->node);\n\tfree(client);\n}\n\nvoid server_accept(void)\n{\n\tstruct client *client;\n\tstruct sockaddr saddr;\n\tsocklen_t saddr_size = sizeof(saddr);\n\tint fd;\n\n\tfd = accept(server_socket, &saddr, &saddr_size);\n\tif (fd == -1)\n\t\treturn;\n\n\tfcntl(fd, F_SETFL, O_NONBLOCK);\n\n\tclient = xnew(struct client, 1);\n\tclient->fd = fd;\n\tclient->authenticated = 0;\n\tlist_add_tail(&client->node, &client_head);\n}\n\nvoid server_serve(struct client *client)\n{\n\t/* unix connection is secure, other insecure */\n\trun_only_safe_commands = addr.sa.sa_family != AF_UNIX;\n\tread_commands(client);\n\trun_only_safe_commands = 0;\n}\n\nvoid server_init(char *address)\n{\n\tconst char *port = STRINGIZE(DEFAULT_PORT);\n\tsize_t addrlen;\n\n\tif (strchr(address, '/')) {\n\t\taddr.sa.sa_family = AF_UNIX;\n\t\tstrncpy(addr.un.sun_path, address, sizeof(addr.un.sun_path) - 1);\n\n\t\taddrlen = sizeof(struct sockaddr_un);\n\t} else {\n\t\tconst struct addrinfo hints = {\n\t\t\t.ai_socktype = SOCK_STREAM\n\t\t};\n\t\tstruct addrinfo *result;\n\t\tchar *s = strrchr(address, ':');\n\t\tint rc;\n\n\t\tif (s) {\n\t\t\t*s++ = 0;\n\t\t\tport = s;\n\t\t}\n\n\t\trc = getaddrinfo(address, port, &hints, &result);\n\t\tif (rc != 0)\n\t\t\tdie(\"getaddrinfo: %s\\n\", gai_strerror(rc));\n\t\tmemcpy(&addr.sa, result->ai_addr, result->ai_addrlen);\n\t\taddrlen = result->ai_addrlen;\n\t\tfreeaddrinfo(result);\n\t}\n\n\tserver_socket = socket(addr.sa.sa_family, SOCK_STREAM, 0);\n\tif (server_socket == -1)\n\t\tdie_errno(\"socket\");\n\n\tif (bind(server_socket, &addr.sa, addrlen) == -1) {\n\t\tint sock;\n\n\t\tif (errno != EADDRINUSE)\n\t\t\tdie_errno(\"bind\");\n\n\t\t/* address already in use */\n\t\tif (addr.sa.sa_family != AF_UNIX)\n\t\t\tdie(\"cmus is already listening on %s:%s\\n\", address, port);\n\n\t\t/* try to connect to server */\n\t\tsock = socket(AF_UNIX, SOCK_STREAM, 0);\n\t\tif (sock == -1)\n\t\t\tdie_errno(\"socket\");\n\n\t\tif (connect(sock, &addr.sa, addrlen) == -1) {\n\t\t\tif (errno != ENOENT && errno != ECONNREFUSED)\n\t\t\t\tdie_errno(\"connect\");\n\n\t\t\t/* server not running => dead socket */\n\n\t\t\t/* try to remove dead socket */\n\t\t\tif (unlink(addr.un.sun_path) == -1 && errno != ENOENT)\n\t\t\t\tdie_errno(\"unlink\");\n\t\t\tif (bind(server_socket, &addr.sa, addrlen) == -1)\n\t\t\t\tdie_errno(\"bind\");\n\t\t} else {\n\t\t\t/* server already running */\n\t\t\tdie(\"cmus is already listening on socket %s\\n\", address);\n\t\t}\n\t\tclose(sock);\n\t}\n\n\tif (listen(server_socket, MAX_CLIENTS) == -1)\n\t\tdie_errno(\"listen\");\n}\n\nvoid server_exit(void)\n{\n\tclose(server_socket);\n\tif (addr.sa.sa_family == AF_UNIX)\n\t\tunlink(addr.un.sun_path);\n}\n"
        },
        {
          "name": "server.h",
          "type": "blob",
          "size": 1.0537109375,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004-2005 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_SERVER_H\n#define CMUS_SERVER_H\n\n#include \"list.h\"\n\nstruct client {\n\tstruct list_head node;\n\tint fd;\n\tunsigned int authenticated : 1;\n};\n\nextern int server_socket;\nextern struct list_head client_head;\n\nvoid server_init(char *address);\nvoid server_exit(void);\nvoid server_accept(void);\nvoid server_serve(struct client *client);\n\n#endif\n"
        },
        {
          "name": "sf.h",
          "type": "blob",
          "size": 2.30859375,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_SF_H\n#define CMUS_SF_H\n\n/*\n *  0     1 big_endian 0-1\n *  1     1 is_signed  0-1\n *  2-20 19 rate       0-524286\n * 21-23  3 bits >> 3  0-7 (* 8 = 0-56)\n * 24-31  8 channels   0-255\n */\ntypedef unsigned int sample_format_t;\n\n#define SF_BIGENDIAN_MASK\t0x00000001\n#define SF_SIGNED_MASK\t\t0x00000002\n#define SF_RATE_MASK\t\t0x001ffffc\n#define SF_BITS_MASK\t\t0x00e00000\n#define SF_CHANNELS_MASK\t0xff000000\n\n#define SF_BIGENDIAN_SHIFT\t0\n#define SF_SIGNED_SHIFT\t\t1\n#define SF_RATE_SHIFT\t\t2\n#define SF_BITS_SHIFT\t\t(21-3)\n#define SF_CHANNELS_SHIFT\t24\n\n#define sf_get_bigendian(sf)\t(((sf) & SF_BIGENDIAN_MASK) >> SF_BIGENDIAN_SHIFT)\n#define sf_get_signed(sf)\t(((sf) & SF_SIGNED_MASK   ) >> SF_SIGNED_SHIFT)\n#define sf_get_rate(sf)\t\t(((sf) & SF_RATE_MASK     ) >> SF_RATE_SHIFT)\n#define sf_get_bits(sf)\t\t(((sf) & SF_BITS_MASK     ) >> SF_BITS_SHIFT)\n#define sf_get_channels(sf)\t(((sf) & SF_CHANNELS_MASK ) >> SF_CHANNELS_SHIFT)\n\n#define sf_signed(val)\t\t(((val) << SF_SIGNED_SHIFT   ) & SF_SIGNED_MASK)\n#define sf_rate(val)\t\t(((val) << SF_RATE_SHIFT     ) & SF_RATE_MASK)\n#define sf_bits(val)\t\t(((val) << SF_BITS_SHIFT     ) & SF_BITS_MASK)\n#define sf_channels(val)\t(((val) << SF_CHANNELS_SHIFT ) & SF_CHANNELS_MASK)\n#define sf_bigendian(val)\t(((val) << SF_BIGENDIAN_SHIFT) & SF_BIGENDIAN_MASK)\n#ifdef WORDS_BIGENDIAN\n#\tdefine sf_host_endian()\tsf_bigendian(1)\n#else\n#\tdefine sf_host_endian()\tsf_bigendian(0)\n#endif\n\n#define sf_get_sample_size(sf)\t(sf_get_bits((sf)) >> 3)\n#define sf_get_frame_size(sf)\t(sf_get_sample_size((sf)) * sf_get_channels((sf)))\n#define sf_get_second_size(sf)\t(sf_get_rate((sf)) * sf_get_frame_size((sf)))\n\n#endif\n"
        },
        {
          "name": "spawn.c",
          "type": "blob",
          "size": 2.2626953125,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2005 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"spawn.h\"\n#include \"file.h\"\n\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n\nint spawn(char *argv[], int *status, int do_wait)\n{\n\tpid_t pid;\n\tint err_pipe[2];\n\n\tif (pipe(err_pipe) == -1)\n\t\treturn -1;\n\n\tpid = fork();\n\tif (pid == -1) {\n\t\t/* error */\n\t\treturn -1;\n\t} else if (pid == 0) {\n\t\t/* child */\n\t\tint dev_null, err, i;\n\n\t\t/* create grandchild and exit child to avoid zombie processes */\n\t\tif (!do_wait) {\n\t\t\tswitch (fork()) {\n\t\t\tcase 0:\n\t\t\t\t/* grandchild */\n\t\t\t\tbreak;\n\t\t\tcase -1:\n\t\t\t\t/* error */\n\t\t\t\t_exit(127);\n\t\t\tdefault:\n\t\t\t\t/* parent of grandchild */\n\t\t\t\t_exit(0);\n\t\t\t}\n\t\t}\n\n\t\tclose(err_pipe[0]);\n\t\tfcntl(err_pipe[1], F_SETFD, FD_CLOEXEC);\n\n\t\t/* redirect stdout and stderr to /dev/null if possible */\n\t\tdev_null = open(\"/dev/null\", O_WRONLY);\n\t\tif (dev_null != -1) {\n\t\t\tdup2(dev_null, 1);\n\t\t\tdup2(dev_null, 2);\n\t\t}\n\n\t\t/* not interactive, close stdin */\n\t\tclose(0);\n\n\t\t/* close unused fds */\n\t\tfor (i = 3; i < 30; i++)\n\t\t\tclose(i);\n\n\t\texecvp(argv[0], argv);\n\n\t\t/* error */\n\t\terr = errno;\n\t\twrite_all(err_pipe[1], &err, sizeof(int));\n\t\texit(1);\n\t} else {\n\t\t/* parent */\n\t\tint rc, errno_save, child_errno, tmp;\n\n\t\tclose(err_pipe[1]);\n\t\trc = read_all(err_pipe[0], &child_errno, sizeof(int));\n\t\terrno_save = errno;\n\t\tclose(err_pipe[0]);\n\n\t\tif (!do_wait)\n\t\t\tstatus = &tmp;\n\t\twaitpid(pid, status, 0);\n\n\t\tif (rc == -1) {\n\t\t\terrno = errno_save;\n\t\t\treturn -1;\n\t\t}\n\t\tif (rc == sizeof(int)) {\n\t\t\terrno = child_errno;\n\t\t\treturn -1;\n\t\t}\n\t\tif (rc != 0) {\n\t\t\terrno = EMSGSIZE;\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n}\n"
        },
        {
          "name": "spawn.h",
          "type": "blob",
          "size": 0.8095703125,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2005 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_SPAWN_H\n#define CMUS_SPAWN_H\n\nint spawn(char *argv[], int *status, int do_wait);\n\n#endif\n"
        },
        {
          "name": "tabexp.c",
          "type": "blob",
          "size": 1.595703125,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"tabexp.h\"\n#include \"xmalloc.h\"\n#include \"xstrjoin.h\"\n#include \"debug.h\"\n\n#include <stdlib.h>\n\nstruct tabexp tabexp = {\n\t.head = NULL,\n\t.tails = NULL,\n\t.count = 0\n};\n\nchar *tabexp_expand(const char *src, void (*load_matches)(const char *src), int direction)\n{\n\tstatic int idx = -1;\n\tchar *expanded;\n\n\tif (tabexp.tails == NULL) {\n\t\tload_matches(src);\n\t\tif (tabexp.tails == NULL) {\n\t\t\tBUG_ON(tabexp.head != NULL);\n\t\t\treturn NULL;\n\t\t}\n\t\tBUG_ON(tabexp.head == NULL);\n\t\tidx = -1;\n\t}\n\tidx += direction;\n\n\tif (idx >= tabexp.count)\n\t\tidx = 0;\n\telse if (idx < 0)\n\t\tidx = tabexp.count - 1;\n\n\texpanded = xstrjoin(tabexp.head, tabexp.tails[idx]);\n\tif (tabexp.count == 1)\n\t\ttabexp_reset();\n\treturn expanded;\n}\n\nvoid tabexp_reset(void)\n{\n\tint i;\n\tfor (i = 0; i < tabexp.count; i++)\n\t\tfree(tabexp.tails[i]);\n\tfree(tabexp.tails);\n\tfree(tabexp.head);\n\ttabexp.tails = NULL;\n\ttabexp.head = NULL;\n\ttabexp.count = 0;\n}\n"
        },
        {
          "name": "tabexp.h",
          "type": "blob",
          "size": 1.0029296875,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004-2005 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_TABEXP_H\n#define CMUS_TABEXP_H\n\nstruct tabexp {\n\tchar *head;\n\tchar **tails;\n\tint count;\n};\n\nextern struct tabexp tabexp;\n\n/* return expanded src or NULL */\nchar *tabexp_expand(const char *src, void (*load_matches)(const char *src), int direction);\n\nvoid tabexp_reset(void);\n\n#endif\n"
        },
        {
          "name": "tabexp_file.c",
          "type": "blob",
          "size": 4.5322265625,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004-2005 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"tabexp_file.h\"\n#include \"tabexp.h\"\n#include \"load_dir.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include \"xstrjoin.h\"\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <dirent.h>\n\nstatic char *get_home(const char *user)\n{\n\tstruct passwd *passwd;\n\tchar *home;\n\tint len;\n\n\tif (user[0] == 0) {\n\t\tpasswd = getpwuid(getuid());\n\t} else {\n\t\tpasswd = getpwnam(user);\n\t}\n\tif (passwd == NULL)\n\t\treturn NULL;\n\tlen = strlen(passwd->pw_dir);\n\thome = xnew(char, len + 2);\n\tmemcpy(home, passwd->pw_dir, len);\n\thome[len] = '/';\n\thome[len + 1] = 0;\n\treturn home;\n}\n\nstatic char *get_full_dir_name(const char *dir)\n{\n\tchar *full;\n\n\tif (dir[0] == 0) {\n\t\tfull = xstrdup(\"./\");\n\t} else if (dir[0] == '~') {\n\t\tchar *first_slash, *tmp, *home;\n\n\t\tfirst_slash = strchr(dir, '/');\n\t\ttmp = xstrndup(dir, first_slash - dir);\n\t\thome = get_home(tmp + 1);\n\t\tfree(tmp);\n\t\tif (home == NULL)\n\t\t\treturn NULL;\n\t\tfull = xstrjoin(home, first_slash);\n\t\tfree(home);\n\t} else {\n\t\tfull = xstrdup(dir);\n\t}\n\treturn full;\n}\n\nstatic void load_dir(struct ptr_array *array,\n\t\tconst char *dirname, const char *start,\n\t\tint (*filter)(const char *, const struct stat *))\n{\n\tint start_len = strlen(start);\n\tstruct directory dir;\n\tchar *full_dir_name;\n\tconst char *name;\n\n\tfull_dir_name = get_full_dir_name(dirname);\n\tif (!full_dir_name)\n\t\treturn;\n\n\tif (dir_open(&dir, full_dir_name))\n\t\tgoto out;\n\n\twhile ((name = dir_read(&dir))) {\n\t\tchar *str;\n\n\t\tif (!start_len) {\n\t\t\tif (name[0] == '.')\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tif (strncmp(name, start, start_len))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (!filter(name, &dir.st))\n\t\t\tcontinue;\n\n\t\tif (S_ISDIR(dir.st.st_mode)) {\n\t\t\tint len = strlen(name);\n\n\t\t\tstr = xnew(char, len + 2);\n\t\t\tmemcpy(str, name, len);\n\t\t\tstr[len++] = '/';\n\t\t\tstr[len] = 0;\n\t\t} else {\n\t\t\tstr = xstrdup(name);\n\t\t}\n\t\tptr_array_add(array, str);\n\t}\n\tdir_close(&dir);\nout:\n\tfree(full_dir_name);\n}\n\n/*\n * load all directory entries from directory 'dir' starting with 'start' and\n * filtered with 'filter'\n */\nstatic void tabexp_load_dir(const char *dirname, const char *start,\n\t\tint (*filter)(const char *, const struct stat *))\n{\n\tPTR_ARRAY(array);\n\n\t/* tabexp is reset */\n\tload_dir(&array, dirname, start, filter);\n\n\tif (array.count) {\n\t\tptr_array_sort(&array, strptrcmp);\n\n\t\ttabexp.head = xstrdup(dirname);\n\t\ttabexp.tails = array.ptrs;\n\t\ttabexp.count = array.count;\n\t}\n}\n\nstatic void tabexp_load_env_path(const char *env_path, const char *start,\n\t\tint (*filter)(const char *, const struct stat *))\n{\n\tchar *path = xstrdup(env_path);\n\tPTR_ARRAY(array);\n\tchar cwd[1024];\n\tchar *p = path, *n;\n\n\t/* tabexp is reset */\n\tdo {\n\t\tn = strchr(p, ':');\n\t\tif (n)\n\t\t\t*n = '\\0';\n\t\tif (strcmp(p, \"\") == 0 && getcwd(cwd, sizeof(cwd)))\n\t\t\tp = cwd;\n\t\tload_dir(&array, p, start, filter);\n\t\tp = n + 1;\n\t} while (n);\n\n\tif (array.count) {\n\t\tptr_array_sort(&array, strptrcoll);\n\t\tptr_array_unique(&array, strptrcmp);\n\n\t\ttabexp.head = xstrdup(\"\");\n\t\ttabexp.tails = array.ptrs;\n\t\ttabexp.count = array.count;\n\t}\n\n\tfree(path);\n}\n\nvoid expand_files_and_dirs(const char *src,\n\t\tint (*filter)(const char *name, const struct stat *s))\n{\n\tchar *slash;\n\n\t/* split src to dir and file */\n\tslash = strrchr(src, '/');\n\tif (slash) {\n\t\tchar *dir;\n\t\tconst char *file;\n\n\t\t/* split */\n\t\tdir = xstrndup(src, slash - src + 1);\n\t\tfile = slash + 1;\n\t\t/* get all dentries starting with file from dir */\n\t\ttabexp_load_dir(dir, file, filter);\n\t\tfree(dir);\n\t} else {\n\t\tif (src[0] == '~') {\n\t\t\tchar *home = get_home(src + 1);\n\n\t\t\tif (home) {\n\t\t\t\ttabexp.head = xstrdup(\"\");\n\t\t\t\ttabexp.tails = xnew(char *, 1);\n\t\t\t\ttabexp.tails[0] = home;\n\t\t\t\ttabexp.count = 1;\n\t\t\t}\n\t\t} else {\n\t\t\ttabexp_load_dir(\"\", src, filter);\n\t\t}\n\t}\n}\n\nvoid expand_env_path(const char *src,\n\t\tint (*filter)(const char *name, const struct stat *s))\n{\n\tconst char *env_path = getenv(\"PATH\");\n\n\tif (!env_path || strcmp(env_path, \"\") == 0)\n\t\treturn;\n\n\ttabexp_load_env_path(env_path, src, filter);\n}\n"
        },
        {
          "name": "tabexp_file.h",
          "type": "blob",
          "size": 0.9921875,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004-2005 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_TABEXP_FILE_H\n#define CMUS_TABEXP_FILE_H\n\n#include <sys/stat.h>\n\nvoid expand_files_and_dirs(const char *src,\n\t\tint (*filter)(const char *name, const struct stat *s));\nvoid expand_env_path(const char *src,\n\t\tint (*filter)(const char *name, const struct stat *s));\n\n#endif\n"
        },
        {
          "name": "track.c",
          "type": "blob",
          "size": 10.8681640625,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2006 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"track.h\"\n#include \"lib.h\"\n#include \"iter.h\"\n#include \"search_mode.h\"\n#include \"window.h\"\n#include \"options.h\"\n#include \"uchar.h\"\n#include \"xmalloc.h\"\n#include \"debug.h\"\n#include \"misc.h\"\n\n#include <string.h>\n\nvoid simple_track_init(struct simple_track *track, struct track_info *ti)\n{\n\ttrack->info = ti;\n\ttrack->marked = 0;\n\tRB_CLEAR_NODE(&track->tree_node);\n}\n\nstruct simple_track *simple_track_new(struct track_info *ti)\n{\n\tstruct simple_track *t = xnew(struct simple_track, 1);\n\n\ttrack_info_ref(ti);\n\tsimple_track_init(t, ti);\n\treturn t;\n}\n\nGENERIC_ITER_PREV(simple_track_get_prev, struct simple_track, node)\nGENERIC_ITER_NEXT(simple_track_get_next, struct simple_track, node)\n\nint simple_track_search_get_current(void *data, struct iter *iter, enum search_direction dir)\n{\n\treturn window_get_sel(data, iter);\n}\n\nint _simple_track_search_matches(struct iter *iter, const char *text)\n{\n\tunsigned int flags = TI_MATCH_TITLE;\n\tstruct simple_track *track = iter_to_simple_track(iter);\n\n\tif (!search_restricted)\n\t\tflags |= TI_MATCH_ARTIST | TI_MATCH_ALBUM | TI_MATCH_ALBUMARTIST;\n\n\treturn track_info_matches(track->info, text, flags);\n}\n\nint simple_track_search_matches(void *data, struct iter *iter, const char *text)\n{\n\tint rc = _simple_track_search_matches(iter, text);\n\tif (rc)\n\t\twindow_set_sel(data, iter);\n\treturn rc;\n}\n\nvoid shuffle_insert(struct rb_root *root, struct shuffle_info *previous, struct shuffle_info *next)\n{\n\tBUG_ON(root == NULL);\n\tBUG_ON(next == NULL);\n\n\tif (previous == next)\n\t\treturn;\n\trb_erase(&next->tree_node, root);\n\n\tstruct rb_node *parent = previous ? &previous->tree_node : NULL;\n\tstruct rb_node **new = parent ? &parent->rb_right : &root->rb_node;\n\twhile (*new) {\n\t\tparent = *new;\n\t\tnew = &(*new)->rb_left;\n\t}\n\n\trb_link_node(&next->tree_node, parent, new);\n\trb_insert_color(&next->tree_node, root);\n}\n\nstruct shuffle_info *shuffle_list_get_next(struct rb_root *root, struct shuffle_info *cur,\n\t\tint (*filter_callback)(const struct album *))\n{\n\tstruct rb_node *node;\n\n\tif (!cur) {\n\t\tif (auto_reshuffle)\n\t\t\tshuffle_list_reshuffle(root);\n\t\treturn tree_node_to_shuffle_info(rb_first(root));\n\t}\n\n\tnode = rb_next(&cur->tree_node);\nagain:\n\twhile (node) {\n\t\tstruct shuffle_info *track = tree_node_to_shuffle_info(node);\n\n\t\tif (filter_callback == NULL || filter_callback(track->album))\n\t\t\treturn track;\n\t\tnode = rb_next(node);\n\t}\n\tif (repeat) {\n\t\tif (auto_reshuffle)\n\t\t\tshuffle_list_reshuffle(root);\n\t\tnode = rb_first(root);\n\t\tgoto again;\n\t}\n\treturn NULL;\n}\n\nstruct shuffle_info *shuffle_list_get_prev(struct rb_root *root, struct shuffle_info *cur,\n\t\tint (*filter_callback)(const struct album *))\n{\n\tstruct rb_node *node;\n\n\tif (!cur) {\n\t\tif (auto_reshuffle)\n\t\t\tshuffle_list_reshuffle(root);\n\t\treturn tree_node_to_shuffle_info(rb_last(root));\n\t}\n\n\tnode = rb_prev(&cur->tree_node);\nagain:\n\twhile (node) {\n\t\tstruct shuffle_info *track = tree_node_to_shuffle_info(node);\n\n\t\tif (filter_callback == NULL || filter_callback(track->album))\n\t\t\treturn track;\n\t\tnode = rb_prev(node);\n\t}\n\tif (repeat) {\n\t\tif (auto_reshuffle)\n\t\t\tshuffle_list_reshuffle(root);\n\t\tnode = rb_last(root);\n\t\tgoto again;\n\t}\n\treturn NULL;\n}\n\nstruct simple_track *simple_list_get_next(struct list_head *head, struct simple_track *cur,\n\t\tint (*filter_callback)(const struct album *), bool allow_repeat)\n{\n\tstruct list_head *item;\n\n\tif (cur == NULL) {\n\t\tif (!allow_repeat)\n\t\t\treturn NULL;\n\t\treturn to_simple_track(head->next);\n\t}\n\n\titem = cur->node.next;\nagain:\n\twhile (item != head) {\n\t\tstruct simple_track *track = to_simple_track(item);\n\n\t\tif (filter_callback == NULL || filter_callback(((struct tree_track *)track)->album))\n\t\t\treturn track;\n\t\titem = item->next;\n\t}\n\titem = head->next;\n\tif (allow_repeat && repeat)\n\t\tgoto again;\n\treturn NULL;\n}\n\nstruct simple_track *simple_list_get_prev(struct list_head *head, struct simple_track *cur,\n\t\tint (*filter_callback)(const struct album *), bool allow_repeat)\n{\n\tstruct list_head *item;\n\n\tif (cur == NULL) {\n\t\tif (!allow_repeat)\n\t\t\treturn NULL;\n\t\treturn to_simple_track(head->prev);\n\t}\n\n\titem = cur->node.prev;\nagain:\n\twhile (item != head) {\n\t\tstruct simple_track *track = to_simple_track(item);\n\n\t\tif (filter_callback == NULL || filter_callback(((struct tree_track *)track)->album))\n\t\t\treturn track;\n\t\titem = item->prev;\n\t}\n\titem = head->prev;\n\tif (allow_repeat && repeat)\n\t\tgoto again;\n\treturn NULL;\n}\n\nvoid sorted_list_add_track(struct list_head *head, struct rb_root *tree_root, struct simple_track *track,\n\t\tconst sort_key_t *keys, int tiebreak)\n{\n\tstruct rb_node **new = &(tree_root->rb_node), *parent = NULL, *curr, *next;\n\tstruct list_head *node;\n\tint result = 0;\n\n\t/* try to locate track in tree */\n\twhile (*new) {\n\t\tconst struct simple_track *t = tree_node_to_simple_track(*new);\n\t\tresult = track_info_cmp(track->info, t->info, keys);\n\n\t\tparent = *new;\n\t\tif (result < 0)\n\t\t\tnew = &(parent->rb_left);\n\t\telse if (result > 0)\n\t\t\tnew = &(parent->rb_right);\n\t\telse\n\t\t\tbreak;\n\t}\n\n\t/* duplicate is present in the tree */\n\tif (parent && result == 0) {\n\t\tif (tiebreak < 0) {\n\t\t\tnode = &(tree_node_to_simple_track(parent)->node);\n\t\t\trb_replace_node(parent, &track->tree_node, tree_root);\n\t\t\tRB_CLEAR_NODE(parent);\n\t\t} else {\n\t\t\tnext = rb_next(parent);\n\t\t\tnode = next ? &(tree_node_to_simple_track(next)->node) : head;\n\t\t}\n\t} else {\n\t\trb_link_node(&track->tree_node, parent, new);\n\t\tcurr = *new;\n\t\trb_insert_color(&track->tree_node, tree_root);\n\t\tif (result < 0) {\n\t\t\tnode = &(tree_node_to_simple_track(parent)->node);\n\t\t} else if (result > 0) {\n\t\t\tnext = rb_next(curr);\n\t\t\tnode = next ? &(tree_node_to_simple_track(next)->node) : head;\n\t\t} else {\n\t\t\t/* rbtree was empty, just add after list head */\n\t\t\tnode = head;\n\t\t}\n\t}\n\tlist_add(&track->node, node->prev);\n}\n\nvoid sorted_list_remove_track(struct list_head *head, struct rb_root *tree_root, struct simple_track *track)\n{\n\tstruct simple_track *next_track;\n\tstruct rb_node *tree_next;\n\n\tif (!RB_EMPTY_NODE(&track->tree_node)) {\n\t\tnext_track = (track->node.next != head) ? to_simple_track(track->node.next) : NULL;\n\t\ttree_next = rb_next(&track->tree_node);\n\n\t\tif (next_track && (!tree_next || tree_node_to_simple_track(tree_next) != next_track)) {\n\t\t\trb_replace_node(&track->tree_node, &next_track->tree_node, tree_root);\n\t\t\tRB_CLEAR_NODE(&track->tree_node);\n\t\t} else\n\t\t\trb_erase(&track->tree_node, tree_root);\n\t}\n\tlist_del(&track->node);\n}\n\nvoid rand_list_rebuild(struct list_head *head, struct rb_root *tree_root)\n{\n\tstruct list_head *item, *tmp;\n\tstruct rb_root tmp_tree = RB_ROOT;\n\tstruct simple_track **track_array;\n\tstatic const sort_key_t empty_sort_keys[] = { SORT_INVALID };\n\n\tunsigned int len = 0, track_cnt = 0;\n\n\tlist_for_each(item, head) {\n\t\tlen++;\n\t}\n\ttrack_array = xmalloc(len * sizeof(track_array[0]));\n\n\tLIST_HEAD(tmp_head);\n\tlist_for_each_safe(item, tmp, head) {\n\t\tstruct simple_track *track = to_simple_track(item);\n\t\tsorted_list_remove_track(head, tree_root, track);\n\t\ttrack_array[track_cnt] = track;\n\t\ttrack_cnt++;\n\t}\n\tshuffle_array(track_array, len, sizeof(track_array[0]));\n\tfor (unsigned int i=0; i<len; i++) {\n\t\tsorted_list_add_track(&tmp_head, &tmp_tree, track_array[i], empty_sort_keys, 0);\n\t}\n\tfree(track_array);\n\n\ttree_root->rb_node = tmp_tree.rb_node;\n\t_list_add(head, tmp_head.prev, tmp_head.next);\n}\n\nvoid sorted_list_rebuild(struct list_head *head, struct rb_root *tree_root, const sort_key_t *keys)\n{\n\tstruct list_head *item, *tmp;\n\tstruct rb_root tmp_tree = RB_ROOT;\n\tLIST_HEAD(tmp_head);\n\n\tlist_for_each_safe(item, tmp, head) {\n\t\tstruct simple_track *track = to_simple_track(item);\n\t\tsorted_list_remove_track(head, tree_root, track);\n\t\tsorted_list_add_track(&tmp_head, &tmp_tree, track, keys, 0);\n\t}\n\ttree_root->rb_node = tmp_tree.rb_node;\n\t_list_add(head, tmp_head.prev, tmp_head.next);\n}\n\nstatic int compare_rand(const struct rb_node *a, const struct rb_node *b)\n{\n\tstruct shuffle_info *tr_a = tree_node_to_shuffle_info(a);\n\tstruct shuffle_info *tr_b = tree_node_to_shuffle_info(b);\n\n\tif (tr_a->rand < tr_b->rand)\n\t\treturn -1;\n\tif (tr_a->rand > tr_b->rand)\n\t\treturn +1;\n\n\treturn 0;\n}\n\nstatic void shuffle_info_init(struct shuffle_info *info, struct album *album)\n{\n\tinfo->rand = rand() / ((double) RAND_MAX + 1);\n\tinfo->album = album;\n}\n\nvoid shuffle_list_add(struct shuffle_info *track, struct rb_root *tree_root, struct album *album)\n{\n\tstruct rb_node **new = &(tree_root->rb_node), *parent = NULL;\n\n\tshuffle_info_init(track, album);\n\n\t/* try to locate track in tree */\n\twhile (*new) {\n\t\tint result = compare_rand(&track->tree_node, *new);\n\n\t\tparent = *new;\n\t\tif (result < 0)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse if (result > 0)\n\t\t\tnew = &((*new)->rb_right);\n\t\telse {\n\t\t\t/* very unlikely, try again! */\n\t\t\tshuffle_list_add(track, tree_root, album);\n\t\t\treturn;\n\t\t}\n\t}\n\n\trb_link_node(&track->tree_node, parent, new);\n\trb_insert_color(&track->tree_node, tree_root);\n}\n\nvoid shuffle_list_reshuffle(struct rb_root *tree_root)\n{\n\tstruct rb_node *node, *tmp;\n\tstruct rb_root tmptree = RB_ROOT;\n\n\trb_for_each_safe(node, tmp, tree_root) {\n\t\tstruct shuffle_info *track = tree_node_to_shuffle_info(node);\n\t\tstruct album *album = track->album;\n\t\trb_erase(node, tree_root);\n\t\tshuffle_list_add(track, &tmptree, album);\n\t}\n\n\ttree_root->rb_node = tmptree.rb_node;\n}\n\n/* expensive */\nvoid list_add_rand(struct list_head *head, struct list_head *node, int nr)\n{\n\tstruct list_head *item;\n\tint pos;\n\n\tpos = rand() % (nr + 1);\n\titem = head;\n\tif (pos <= nr / 2) {\n\t\twhile (pos) {\n\t\t\titem = item->next;\n\t\t\tpos--;\n\t\t}\n\t\t/* add after item */\n\t\tlist_add(node, item);\n\t} else {\n\t\tpos = nr - pos;\n\t\twhile (pos) {\n\t\t\titem = item->prev;\n\t\t\tpos--;\n\t\t}\n\t\t/* add before item */\n\t\tlist_add_tail(node, item);\n\t}\n}\n\nint simple_list_for_each_marked(struct list_head *head, track_info_cb cb,\n\t\tvoid *data, int reverse)\n{\n\tstruct simple_track *t;\n\tint rc = 0;\n\n\tif (reverse) {\n\t\tlist_for_each_entry_reverse(t, head, node) {\n\t\t\tif (t->marked) {\n\t\t\t\trc = cb(data, t->info);\n\t\t\t\tif (rc)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tlist_for_each_entry(t, head, node) {\n\t\t\tif (t->marked) {\n\t\t\t\trc = cb(data, t->info);\n\t\t\t\tif (rc)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn rc;\n}\n\nint simple_list_for_each(struct list_head *head, track_info_cb cb, void *data,\n\t\tint reverse)\n{\n\tstruct simple_track *t;\n\tint rc = 0;\n\n\tif (reverse) {\n\t\tlist_for_each_entry_reverse(t, head, node) {\n\t\t\tif ((rc = cb(data, t->info)))\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tlist_for_each_entry(t, head, node) {\n\t\t\tif ((rc = cb(data, t->info)))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn rc;\n}\n"
        },
        {
          "name": "track.h",
          "type": "blob",
          "size": 3.9765625,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2006 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_TRACK_H\n#define CMUS_TRACK_H\n\n#include \"list.h\"\n#include \"rbtree.h\"\n#include \"iter.h\"\n#include \"track_info.h\"\n#include \"cmus.h\"\n#include \"search.h\"\n\nstruct shuffle_info {\n\tstruct rb_node tree_node;\n\tstruct album *album;\n\tdouble rand;\n};\n\nstruct simple_track {\n\tstruct shuffle_info shuffle_info;\n\tstruct list_head node;\n\tstruct rb_node tree_node;\n\tstruct track_info *info;\n\tunsigned int marked : 1;\n};\n\nstatic inline struct simple_track *\nshuffle_info_to_simple_track(struct shuffle_info *track)\n{\n\treturn container_of(track, struct simple_track, shuffle_info);\n}\n\nstatic inline struct track_info *shuffle_info_info(const struct shuffle_info *track)\n{\n\treturn ((struct simple_track *)track)->info;\n}\n\nstatic inline struct simple_track *to_simple_track(const struct list_head *item)\n{\n\treturn container_of(item, struct simple_track, node);\n}\n\nstatic inline struct simple_track *iter_to_simple_track(const struct iter *iter)\n{\n\treturn iter->data1;\n}\n\nstatic inline struct simple_track *tree_node_to_simple_track(const struct rb_node *node)\n{\n\treturn container_of(node, struct simple_track, tree_node);\n}\n\nstatic inline struct shuffle_info *tree_node_to_shuffle_info(const struct rb_node *node)\n{\n\treturn container_of(node, struct shuffle_info, tree_node);\n}\n\n/* NOTE: does not ref ti */\nvoid simple_track_init(struct simple_track *track, struct track_info *ti);\n\n/* refs ti */\nstruct simple_track *simple_track_new(struct track_info *ti);\n\nint simple_track_get_prev(struct iter *);\nint simple_track_get_next(struct iter *);\n\n/* data is window */\nint simple_track_search_get_current(void *data, struct iter *iter, enum search_direction dir);\nint simple_track_search_matches(void *data, struct iter *iter, const char *text);\nint _simple_track_search_matches(struct iter *iter, const char *text);\n\nstruct shuffle_info *shuffle_list_get_next(struct rb_root *root, struct shuffle_info *cur,\n\t\tint (*filter)(const struct album *));\n\nstruct shuffle_info *shuffle_list_get_prev(struct rb_root *root, struct shuffle_info *cur,\n\t\tint (*filter)(const struct album *));\n\nstruct simple_track *simple_list_get_next(struct list_head *head, struct simple_track *cur,\n\t\tint (*filter)(const struct album *), bool allow_repeat);\n\nstruct simple_track *simple_list_get_prev(struct list_head *head, struct simple_track *cur,\n\t\tint (*filter)(const struct album *), bool allow_repeat);\n\nvoid sorted_list_add_track(struct list_head *head, struct rb_root *tree_root, struct simple_track *track,\n\t\tconst sort_key_t *keys, int tiebreak);\nvoid sorted_list_remove_track(struct list_head *head, struct rb_root *tree_root, struct simple_track *track);\nvoid sorted_list_rebuild(struct list_head *head, struct rb_root *tree_root, const sort_key_t *keys);\nvoid rand_list_rebuild(struct list_head *head, struct rb_root *tree_root);\n\nvoid list_add_rand(struct list_head *head, struct list_head *node, int nr);\n\nint simple_list_for_each_marked(struct list_head *head, track_info_cb cb,\n\t\tvoid *data, int reverse);\nint simple_list_for_each(struct list_head *head, track_info_cb cb,\n\t\tvoid *data, int reverse);\n\nvoid shuffle_list_add(struct shuffle_info *track, struct rb_root *tree_root, struct album *album);\nvoid shuffle_list_reshuffle(struct rb_root *tree_root);\nvoid shuffle_insert(struct rb_root *root, struct shuffle_info *previous, struct shuffle_info *new);\n\n#endif\n"
        },
        {
          "name": "track_info.c",
          "type": "blob",
          "size": 11.193359375,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004-2005 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"track_info.h\"\n#include \"comment.h\"\n#include \"uchar.h\"\n#include \"u_collate.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include \"utils.h\"\n#include \"debug.h\"\n#include \"path.h\"\n#include \"ui_curses.h\"\n\n#include <string.h>\n#include <stdatomic.h>\n#include <math.h>\n\nstruct track_info_priv {\n\tstruct track_info ti;\n\t_Atomic uint32_t ref_count;\n};\n\nstatic struct track_info_priv *track_info_to_priv(struct track_info *ti)\n{\n\treturn container_of(ti, struct track_info_priv, ti);\n}\n\nstruct track_info *track_info_new(const char *filename)\n{\n\tstatic _Atomic uint64_t cur_uid = ATOMIC_VAR_INIT(1);\n\tuint64_t uid = atomic_fetch_add_explicit(&cur_uid, 1, memory_order_relaxed);\n\tBUG_ON(uid == 0);\n\n\tstruct track_info_priv *priv = xnew(struct track_info_priv, 1);\n\tatomic_init(&priv->ref_count, 1);\n\n\tstruct track_info *ti = &priv->ti;\n\tti->uid = uid;\n\tti->filename = xstrdup(filename);\n\tti->play_count = 0;\n\tti->comments = NULL;\n\tti->bpm = -1;\n\tti->codec = NULL;\n\tti->codec_profile = NULL;\n\tti->output_gain = 0;\n\n\treturn ti;\n}\n\nvoid track_info_set_comments(struct track_info *ti, struct keyval *comments) {\n\tlong int r128_track_gain;\n\tlong int r128_album_gain;\n\tlong int output_gain;\n\n\tti->comments = comments;\n\tti->artist = keyvals_get_val(comments, \"artist\");\n\tti->album = keyvals_get_val(comments, \"album\");\n\tti->title = keyvals_get_val(comments, \"title\");\n\tti->tracknumber = comments_get_int(comments, \"tracknumber\");\n\tti->discnumber = comments_get_int(comments, \"discnumber\");\n\tti->totaldiscs = comments_get_int(comments, \"totaldiscs\");\n\tti->date = comments_get_date(comments, \"date\");\n\tti->originaldate = comments_get_date(comments, \"originaldate\");\n\tti->genre = keyvals_get_val(comments, \"genre\");\n\tti->comment = keyvals_get_val(comments, \"comment\");\n\tti->albumartist = comments_get_albumartist(comments);\n\tti->artistsort = comments_get_artistsort(comments);\n\tti->albumsort = keyvals_get_val(comments, \"albumsort\");\n\tti->is_va_compilation = track_is_va_compilation(comments);\n\tti->media = keyvals_get_val(comments, \"media\");\n\n\tint bpm = comments_get_int(comments, \"bpm\");\n\tif (ti->bpm == 0 || ti->bpm == -1) {\n\t\tti->bpm = bpm;\n\t}\n\n\tif (ti->artist == NULL && ti->albumartist != NULL) {\n\t\t/* best guess */\n\t\tti->artist = ti->albumartist;\n\t}\n\n\tif (track_info_has_tag(ti) && ti->title == NULL) {\n\t\t/* best guess */\n\t\tti->title = path_basename(ti->filename);\n\t}\n\n\tti->rg_track_gain = comments_get_double(comments, \"replaygain_track_gain\");\n\tti->rg_track_peak = comments_get_double(comments, \"replaygain_track_peak\");\n\tti->rg_album_gain = comments_get_double(comments, \"replaygain_album_gain\");\n\tti->rg_album_peak = comments_get_double(comments, \"replaygain_album_peak\");\n\n\tif (comments_get_signed_int(comments, \"r128_track_gain\", &r128_track_gain) != -1) {\n\t\tdouble rg = (r128_track_gain / 256.0) + 5;\n\t\tti->rg_track_gain = round(rg * 100) / 100.0;\n\t}\n\n\tif (comments_get_signed_int(comments, \"r128_album_gain\", &r128_album_gain) != -1) {\n\t\tdouble rg = (r128_album_gain / 256.0) + 5;\n\t\tti->rg_album_gain = round(rg * 100) / 100.0;\n\t}\n\n\tif (comments_get_signed_int(comments, \"output_gain\", &output_gain) != -1) {\n\t\tti->output_gain = (output_gain / 256.0);\n\t}\n\n\tti->collkey_artist = u_strcasecoll_key0(ti->artist);\n\tti->collkey_album = u_strcasecoll_key0(ti->album);\n\tti->collkey_title = u_strcasecoll_key0(ti->title);\n\tti->collkey_genre = u_strcasecoll_key0(ti->genre);\n\tti->collkey_comment = u_strcasecoll_key0(ti->comment);\n\tti->collkey_albumartist = u_strcasecoll_key0(ti->albumartist);\n}\n\nvoid track_info_ref(struct track_info *ti)\n{\n\tstruct track_info_priv *priv = track_info_to_priv(ti);\n\tatomic_fetch_add_explicit(&priv->ref_count, 1, memory_order_relaxed);\n}\n\nvoid track_info_unref(struct track_info *ti)\n{\n\tstruct track_info_priv *priv = track_info_to_priv(ti);\n\tuint32_t prev = atomic_fetch_sub_explicit(&priv->ref_count, 1,\n\t\t\tmemory_order_acq_rel);\n\tif (prev == 1) {\n\t\tkeyvals_free(ti->comments);\n\t\tfree(ti->filename);\n\t\tfree(ti->codec);\n\t\tfree(ti->codec_profile);\n\t\tfree(ti->collkey_artist);\n\t\tfree(ti->collkey_album);\n\t\tfree(ti->collkey_title);\n\t\tfree(ti->collkey_genre);\n\t\tfree(ti->collkey_comment);\n\t\tfree(ti->collkey_albumartist);\n\t\tfree(priv);\n\t}\n}\n\nbool track_info_unique_ref(struct track_info *ti)\n{\n\tstruct track_info_priv *priv = track_info_to_priv(ti);\n\treturn atomic_load_explicit(&priv->ref_count, memory_order_relaxed) == 1;\n}\n\nint track_info_has_tag(const struct track_info *ti)\n{\n\treturn ti->artist || ti->album || ti->title;\n}\n\nstatic inline int match_word(const struct track_info *ti, const char *word, unsigned int flags)\n{\n\treturn ((flags & TI_MATCH_ARTIST) && ti->artist && u_strcasestr_base(ti->artist, word)) ||\n\t       ((flags & TI_MATCH_ALBUM) && ti->album && u_strcasestr_base(ti->album, word)) ||\n\t       ((flags & TI_MATCH_TITLE) && ti->title && u_strcasestr_base(ti->title, word)) ||\n\t       ((flags & TI_MATCH_ALBUMARTIST) && ti->albumartist && u_strcasestr_base(ti->albumartist, word));\n}\n\nstatic inline int flags_set(const struct track_info *ti, unsigned int flags)\n{\n\treturn ((flags & TI_MATCH_ARTIST) && ti->artist) ||\n\t       ((flags & TI_MATCH_ALBUM) && ti->album) ||\n\t       ((flags & TI_MATCH_TITLE) && ti->title) ||\n\t       ((flags & TI_MATCH_ALBUMARTIST) && ti->albumartist);\n}\n\nint track_info_matches_full(const struct track_info *ti, const char *text,\n\t\tunsigned int flags, unsigned int exclude_flags, int match_all_words)\n{\n\tchar **words;\n\tint i, matched = 0;\n\n\twords = get_words(text);\n\tfor (i = 0; words[i]; i++) {\n\t\tconst char *word = words[i];\n\n\t\tmatched = 0;\n\t\tif (flags_set(ti, flags)) {\n\t\t\tmatched = match_word(ti, word, flags);\n\t\t} else {\n\t\t\t/* compare with url or filename without path */\n\t\t\tconst char *filename = ti->filename;\n\n\t\t\tif (!is_url(filename))\n\t\t\t\tfilename = path_basename(filename);\n\n\t\t\tif (u_strcasestr_filename(filename, word))\n\t\t\t\tmatched = 1;\n\t\t}\n\n\t\tif (match_word(ti, word, exclude_flags))\n\t\t\tmatched = 0;\n\n\t\tif (match_all_words ? !matched : matched)\n\t\t\tbreak;\n\n\t}\n\tfree_str_array(words);\n\treturn matched;\n}\n\nint track_info_matches(const struct track_info *ti, const char *text, unsigned int flags)\n{\n\treturn track_info_matches_full(ti, text, flags, 0, 1);\n}\n\nstatic int doublecmp0(double a, double b)\n{\n\tdouble x;\n\t/* fast check for NaN */\n\tint r = (b != b) - (a != a);\n\tif (r)\n\t\treturn r;\n\tx = a - b;\n\treturn (x > 0) - (x < 0);\n}\n\n/* this function gets called *a lot*, it must be very fast */\nint track_info_cmp(const struct track_info *a, const struct track_info *b, const sort_key_t *keys)\n{\n\tint i, rev = 0, res = 0;\n\n\tfor (i = 0; keys[i] != SORT_INVALID; i++) {\n\t\tsort_key_t key = keys[i];\n\t\tconst char *av, *bv;\n\n\t\trev = 0;\n\t\tif (key >= REV_SORT__START) {\n\t\t\trev = 1;\n\t\t\tkey -= REV_SORT__START;\n\t\t}\n\n\t\tswitch (key) {\n\t\tcase SORT_TRACKNUMBER:\n\t\tcase SORT_DISCNUMBER:\n\t\tcase SORT_TOTALDISCS:\n\t\tcase SORT_DATE:\n\t\tcase SORT_ORIGINALDATE:\n\t\tcase SORT_PLAY_COUNT:\n\t\tcase SORT_BPM:\n\t\t\tres = getentry(a, key, int) - getentry(b, key, int);\n\t\t\tbreak;\n\t\tcase SORT_FILEMTIME:\n\t\t\tres = a->mtime - b->mtime;\n\t\t\tbreak;\n\t\tcase SORT_FILENAME:\n\t\t\t/* NOTE: filenames are not necessarily UTF-8 */\n\t\t\tres = strcoll(a->filename, b->filename);\n\t\t\tbreak;\n\t\tcase SORT_RG_TRACK_GAIN:\n\t\tcase SORT_RG_TRACK_PEAK:\n\t\tcase SORT_RG_ALBUM_GAIN:\n\t\tcase SORT_RG_ALBUM_PEAK:\n\t\t\tres = doublecmp0(getentry(a, key, double), getentry(b, key, double));\n\t\t\tbreak;\n\t\tcase SORT_BITRATE:\n\t\t\tres = getentry(a, key, long) - getentry(b, key, long);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tav = getentry(a, key, const char *);\n\t\t\tbv = getentry(b, key, const char *);\n\t\t\tres = strcmp0(av, bv);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (res)\n\t\t\tbreak;\n\t}\n\treturn rev ? -res : res;\n}\n\nstatic const struct {\n\tconst char *str;\n\tsort_key_t key;\n} sort_key_map[] = {\n\t{ \"artist\",\t\tSORT_ARTIST\t\t},\n\t{ \"album\",\t\tSORT_ALBUM\t\t},\n\t{ \"title\",\t\tSORT_TITLE\t\t},\n\t{ \"play_count\",\t\tSORT_PLAY_COUNT\t\t},\n\t{ \"tracknumber\",\tSORT_TRACKNUMBER\t},\n\t{ \"discnumber\",\t\tSORT_DISCNUMBER\t\t},\n\t{ \"totaldiscs\",\t\tSORT_TOTALDISCS\t\t},\n\t{ \"date\",\t\tSORT_DATE\t\t},\n\t{ \"originaldate\",\tSORT_ORIGINALDATE\t},\n\t{ \"genre\",\t\tSORT_GENRE\t\t},\n\t{ \"comment\",\t\tSORT_COMMENT\t\t},\n\t{ \"albumartist\",\tSORT_ALBUMARTIST\t},\n\t{ \"filename\",\t\tSORT_FILENAME\t\t},\n\t{ \"filemtime\",\t\tSORT_FILEMTIME\t\t},\n\t{ \"rg_track_gain\",\tSORT_RG_TRACK_GAIN\t},\n\t{ \"rg_track_peak\",\tSORT_RG_TRACK_PEAK\t},\n\t{ \"rg_album_gain\",\tSORT_RG_ALBUM_GAIN\t},\n\t{ \"rg_album_peak\",\tSORT_RG_ALBUM_PEAK\t},\n\t{ \"bitrate\",\t\tSORT_BITRATE\t\t},\n\t{ \"codec\",\t\tSORT_CODEC\t\t},\n\t{ \"codec_profile\",\tSORT_CODEC_PROFILE\t},\n\t{ \"media\",\t\tSORT_MEDIA\t\t},\n\t{ \"bpm\",\t\tSORT_BPM\t\t},\n\t{ \"-artist\",\t\tREV_SORT_ARTIST\t\t},\n\t{ \"-album\",\t\tREV_SORT_ALBUM\t\t},\n\t{ \"-title\",\t\tREV_SORT_TITLE\t\t},\n\t{ \"-play_count\", \tREV_SORT_PLAY_COUNT\t},\n\t{ \"-tracknumber\",\tREV_SORT_TRACKNUMBER\t},\n\t{ \"-discnumber\",\tREV_SORT_DISCNUMBER\t},\n\t{ \"-totaldiscs\",\tREV_SORT_TOTALDISCS\t},\n\t{ \"-date\",\t\tREV_SORT_DATE\t\t},\n\t{ \"-originaldate\",\tREV_SORT_ORIGINALDATE\t},\n\t{ \"-genre\",\t\tREV_SORT_GENRE\t\t},\n\t{ \"-comment\",\t\tREV_SORT_COMMENT\t},\n\t{ \"-albumartist\",\tREV_SORT_ALBUMARTIST\t},\n\t{ \"-filename\",\t\tREV_SORT_FILENAME\t},\n\t{ \"-filemtime\",\t\tREV_SORT_FILEMTIME\t},\n\t{ \"-rg_track_gain\",\tREV_SORT_RG_TRACK_GAIN\t},\n\t{ \"-rg_track_peak\",\tREV_SORT_RG_TRACK_PEAK\t},\n\t{ \"-rg_album_gain\",\tREV_SORT_RG_ALBUM_GAIN\t},\n\t{ \"-rg_album_peak\",\tREV_SORT_RG_ALBUM_PEAK\t},\n\t{ \"-bitrate\",\t\tREV_SORT_BITRATE\t},\n\t{ \"-codec\",\t\tREV_SORT_CODEC\t\t},\n\t{ \"-codec_profile\",\tREV_SORT_CODEC_PROFILE\t},\n\t{ \"-media\",\t\tREV_SORT_MEDIA\t\t},\n\t{ \"-bpm\",\t\tREV_SORT_BPM\t\t},\n\t{ NULL,                 SORT_INVALID            }\n};\n\nsort_key_t *parse_sort_keys(const char *value)\n{\n\tsort_key_t *keys;\n\tconst char *s, *e;\n\tint size = 4;\n\tint pos = 0;\n\n\tkeys = xnew(sort_key_t, size);\n\n\ts = value;\n\twhile (1) {\n\t\tchar buf[32];\n\t\tint i, len;\n\n\t\twhile (*s == ' ')\n\t\t\ts++;\n\n\t\te = s;\n\t\twhile (*e && *e != ' ')\n\t\t\te++;\n\n\t\tlen = e - s;\n\t\tif (len == 0)\n\t\t\tbreak;\n\t\tif (len > 31)\n\t\t\tlen = 31;\n\n\t\tmemcpy(buf, s, len);\n\t\tbuf[len] = 0;\n\t\ts = e;\n\n\t\tfor (i = 0; ; i++) {\n\t\t\tif (sort_key_map[i].str == NULL) {\n\t\t\t\terror_msg(\"invalid sort key '%s'\", buf);\n\t\t\t\tfree(keys);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tif (strcmp(buf, sort_key_map[i].str) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (pos == size - 1) {\n\t\t\tsize *= 2;\n\t\t\tkeys = xrenew(sort_key_t, keys, size);\n\t\t}\n\t\tkeys[pos++] = sort_key_map[i].key;\n\t}\n\tkeys[pos] = SORT_INVALID;\n\treturn keys;\n}\n\nconst char *sort_key_to_str(sort_key_t key)\n{\n\tint i;\n\tfor (i = 0; sort_key_map[i].str; i++) {\n\t\tif (sort_key_map[i].key == key)\n\t\t\treturn sort_key_map[i].str;\n\t}\n\treturn NULL;\n}\n\nvoid sort_keys_to_str(const sort_key_t *keys, char *buf, size_t bufsize)\n{\n\tint i, pos = 0;\n\n\tfor (i = 0; keys[i] != SORT_INVALID; i++) {\n\t\tconst char *key = sort_key_to_str(keys[i]);\n\t\tint len = strlen(key);\n\n\t\tif ((int)bufsize - pos - len - 2 < 0)\n\t\t\tbreak;\n\n\t\tmemcpy(buf + pos, key, len);\n\t\tpos += len;\n\t\tbuf[pos++] = ' ';\n\t}\n\tif (pos > 0)\n\t\tpos--;\n\tbuf[pos] = 0;\n}\n"
        },
        {
          "name": "track_info.h",
          "type": "blob",
          "size": 6.99609375,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004-2005 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_TRACK_INFO_H\n#define CMUS_TRACK_INFO_H\n\n#include <time.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdbool.h>\n\nstruct track_info {\n\tuint64_t uid;\n\tstruct keyval *comments;\n\n\t// next track_info in the hash table (cache.c)\n\tstruct track_info *next;\n\n\ttime_t mtime;\n\tint duration;\n\tlong bitrate;\n\tchar *codec;\n\tchar *codec_profile;\n\tchar *filename;\n\n\tint tracknumber;\n\tint discnumber;\n\tint totaldiscs;\n\tint date;\n\tint originaldate;\n\tdouble rg_track_gain;\n\tdouble rg_track_peak;\n\tdouble rg_album_gain;\n\tdouble rg_album_peak;\n\tdouble output_gain;\n\tconst char *artist;\n\tconst char *album;\n\tconst char *title;\n\tconst char *genre;\n\tconst char *comment;\n\tconst char *albumartist;\n\tconst char *artistsort;\n\tconst char *albumsort;\n\tconst char *media;\n\n\tchar *collkey_artist;\n\tchar *collkey_album;\n\tchar *collkey_title;\n\tchar *collkey_genre;\n\tchar *collkey_comment;\n\tchar *collkey_albumartist;\n\n\tunsigned int play_count;\n\n\tint is_va_compilation : 1;\n\tint bpm;\n};\n\ntypedef size_t sort_key_t;\n\n#define SORT_INVALID            ((sort_key_t) (-1))\n#define SORT_ARTIST        \toffsetof(struct track_info, collkey_artist)\n#define SORT_ALBUM         \toffsetof(struct track_info, collkey_album)\n#define SORT_TITLE         \toffsetof(struct track_info, collkey_title)\n#define SORT_TRACKNUMBER   \toffsetof(struct track_info, tracknumber)\n#define SORT_DISCNUMBER    \toffsetof(struct track_info, discnumber)\n#define SORT_TOTALDISCS    \toffsetof(struct track_info, totaldiscs)\n#define SORT_DATE          \toffsetof(struct track_info, date)\n#define SORT_ORIGINALDATE  \toffsetof(struct track_info, originaldate)\n#define SORT_RG_TRACK_GAIN \toffsetof(struct track_info, rg_track_gain)\n#define SORT_RG_TRACK_PEAK \toffsetof(struct track_info, rg_track_peak)\n#define SORT_RG_ALBUM_GAIN \toffsetof(struct track_info, rg_album_gain)\n#define SORT_RG_ALBUM_PEAK \toffsetof(struct track_info, rg_album_peak)\n#define SORT_GENRE         \toffsetof(struct track_info, collkey_genre)\n#define SORT_COMMENT       \toffsetof(struct track_info, collkey_comment)\n#define SORT_ALBUMARTIST   \toffsetof(struct track_info, collkey_albumartist)\n#define SORT_PLAY_COUNT   \toffsetof(struct track_info, play_count)\n#define SORT_FILENAME      \toffsetof(struct track_info, filename)\n#define SORT_FILEMTIME     \toffsetof(struct track_info, mtime)\n#define SORT_BITRATE       \toffsetof(struct track_info, bitrate)\n#define SORT_CODEC         \toffsetof(struct track_info, codec)\n#define SORT_CODEC_PROFILE \toffsetof(struct track_info, codec_profile)\n#define SORT_MEDIA\t\toffsetof(struct track_info, media)\n#define SORT_BPM\t\toffsetof(struct track_info, bpm)\n#define REV_SORT__START\t\tsizeof(struct track_info)\n#define REV_SORT_ARTIST\t\t(REV_SORT__START + offsetof(struct track_info, collkey_artist))\n#define REV_SORT_ALBUM          (REV_SORT__START + offsetof(struct track_info, collkey_album))\n#define REV_SORT_TITLE          (REV_SORT__START + offsetof(struct track_info, collkey_title))\n#define REV_SORT_PLAY_COUNT   \t(REV_SORT__START + offsetof(struct track_info, play_count))\n#define REV_SORT_TRACKNUMBER    (REV_SORT__START + offsetof(struct track_info, tracknumber))\n#define REV_SORT_DISCNUMBER     (REV_SORT__START + offsetof(struct track_info, discnumber))\n#define REV_SORT_TOTALDISCS     (REV_SORT__START + offsetof(struct track_info, totaldiscs))\n#define REV_SORT_DATE           (REV_SORT__START + offsetof(struct track_info, date))\n#define REV_SORT_ORIGINALDATE   (REV_SORT__START + offsetof(struct track_info, originaldate))\n#define REV_SORT_RG_TRACK_GAIN  (REV_SORT__START + offsetof(struct track_info, rg_track_gain))\n#define REV_SORT_RG_TRACK_PEAK  (REV_SORT__START + offsetof(struct track_info, rg_track_peak))\n#define REV_SORT_RG_ALBUM_GAIN  (REV_SORT__START + offsetof(struct track_info, rg_album_gain))\n#define REV_SORT_RG_ALBUM_PEAK  (REV_SORT__START + offsetof(struct track_info, rg_album_peak))\n#define REV_SORT_GENRE          (REV_SORT__START + offsetof(struct track_info, collkey_genre))\n#define REV_SORT_COMMENT        (REV_SORT__START + offsetof(struct track_info, collkey_comment))\n#define REV_SORT_ALBUMARTIST    (REV_SORT__START + offsetof(struct track_info, collkey_albumartist))\n#define REV_SORT_FILENAME       (REV_SORT__START + offsetof(struct track_info, filename))\n#define REV_SORT_FILEMTIME      (REV_SORT__START + offsetof(struct track_info, mtime))\n#define REV_SORT_BITRATE        (REV_SORT__START + offsetof(struct track_info, bitrate))\n#define REV_SORT_CODEC          (REV_SORT__START + offsetof(struct track_info, codec))\n#define REV_SORT_CODEC_PROFILE  (REV_SORT__START + offsetof(struct track_info, codec_profile))\n#define REV_SORT_MEDIA          (REV_SORT__START + offsetof(struct track_info, media))\n#define REV_SORT_BPM            (REV_SORT__START + offsetof(struct track_info, bpm))\n\n#define TI_MATCH_ARTIST       (1 << 0)\n#define TI_MATCH_ALBUM        (1 << 1)\n#define TI_MATCH_TITLE        (1 << 2)\n#define TI_MATCH_ALBUMARTIST  (1 << 3)\n#define TI_MATCH_ALL          (~0)\n\n/* initializes only filename and ref */\nstruct track_info *track_info_new(const char *filename);\nvoid track_info_set_comments(struct track_info *ti, struct keyval *comments);\n\nvoid track_info_ref(struct track_info *ti);\nvoid track_info_unref(struct track_info *ti);\nbool track_info_unique_ref(struct track_info *ti);\n\n/*\n * returns: 1 if @ti has any of the following tags: artist, album, title\n *          0 otherwise\n */\nint track_info_has_tag(const struct track_info *ti);\n\n/*\n * @flags  fields to search in (TI_MATCH_*)\n *\n * returns: 1 if all words in @text are found to match defined fields (@flags) in @ti\n *          0 otherwise\n */\nint track_info_matches(const struct track_info *ti, const char *text, unsigned int flags);\n\n/*\n * @flags            fields to search in (TI_MATCH_*)\n * @exclude_flags    fields which must not match (TI_MATCH_*)\n * @match_all_words  if true, all words must be found in @ti\n *\n * returns: 1 if all/any words in @text are found to match defined fields (@flags) in @ti\n *          0 otherwise\n */\nint track_info_matches_full(const struct track_info *ti, const char *text, unsigned int flags,\n\t\tunsigned int exclude_flags, int match_all_words);\n\nint track_info_cmp(const struct track_info *a, const struct track_info *b, const sort_key_t *keys);\n\nsort_key_t *parse_sort_keys(const char *value);\nconst char *sort_key_to_str(sort_key_t key);\nvoid sort_keys_to_str(const sort_key_t *keys, char *buf, size_t bufsize);\n\n#endif\n"
        },
        {
          "name": "tree.c",
          "type": "blob",
          "size": 34.2939453125,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2006 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"lib.h\"\n#include \"search_mode.h\"\n#include \"xmalloc.h\"\n#include \"utils.h\"\n#include \"debug.h\"\n#include \"mergesort.h\"\n#include \"options.h\"\n#include \"u_collate.h\"\n#include \"rbtree.h\"\n\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <strings.h>\n\nstruct searchable *tree_searchable;\nstruct window *lib_tree_win;\nstruct window *lib_track_win;\nstruct window *lib_cur_win;\nstruct rb_root lib_artist_root;\n\nstruct track_iter {\n\tstruct rb_root *root;\n\tstruct tree_track *track;\n\tstruct album *album;\n};\n\nstatic inline int tree_album_selected(void)\n{\n\treturn iter_to_album(&lib_tree_win->sel) != NULL;\n}\n\nstatic inline int track_visible(struct tree_track *track)\n{\n\tif (tree_album_selected())\n\t\treturn track->album == iter_to_album(&lib_tree_win->sel);\n\telse if (show_all_tracks)\n\t\treturn track->album->artist == iter_to_artist(&lib_tree_win->sel);\n\telse\n\t\treturn 0;\n}\n\nstatic inline void tree_search_track_to_iter(struct tree_track *track, struct iter *iter)\n{\n\titer->data0 = &lib_artist_root;\n\titer->data1 = track;\n\titer->data2 = NULL;\n}\n\nstatic inline void album_to_iter(struct album *album, struct iter *iter)\n{\n\titer->data0 = &lib_artist_root;\n\titer->data1 = album->artist;\n\titer->data2 = album;\n}\n\nstatic inline void album_to_track_iter(struct album *album, struct track_iter *iter)\n{\n\titer->root = &album->artist->album_root;\n\titer->album = album;\n\titer->track = (struct tree_track *)album;\n}\n\nstatic inline void artist_to_iter(struct artist *artist, struct iter *iter)\n{\n\titer->data0 = &lib_artist_root;\n\titer->data1 = artist;\n\titer->data2 = NULL;\n}\n\nstatic inline void tree_track_to_track_iter(struct tree_track *track, struct track_iter *iter)\n{\n\tif (tree_album_selected()) {\n\t\titer->root = &track->album->track_root;\n\t\titer->album = NULL;\n\t} else {\n\t\titer->root = &track->album->artist->album_root;\n\t\titer->album = track->album;\n\t}\n\titer->track = track;\n}\n\nstatic void tree_set_expand_artist(struct artist *artist, int expand)\n{\n\tstruct iter sel;\n\n\tif (!expand) {\n\t\t/* deselect album, select artist */\n\t\tartist_to_iter(artist, &sel);\n\t\twindow_set_sel(lib_tree_win, &sel);\n\n\t\tif (!show_all_tracks)\n\t\t\tlib_cur_win = lib_tree_win;\n\t}\n\tartist->expanded = expand;\n\twindow_changed(lib_tree_win);\n}\n\n/* tree (search) iterators {{{ */\nstatic int tree_search_get_prev(struct iter *iter)\n{\n\tstruct rb_root *root = iter->data0;\n\tstruct tree_track *track = iter->data1;\n\tstruct artist *artist;\n\tstruct album *album;\n\n\tBUG_ON(iter->data2);\n\tif (root == NULL)\n\t\treturn 0;\n\tif (track == NULL) {\n\t\t/* head, get last track */\n\t\tif (rb_root_empty(root)) {\n\t\t\t/* empty, iter points to the head already */\n\t\t\treturn 0;\n\t\t}\n\t\tartist = to_artist(rb_last(root));\n\t\talbum = to_album(rb_last(&artist->album_root));\n\t\titer->data1 = to_tree_track(rb_last(&album->track_root));\n\t\treturn 1;\n\t}\n\t/* prev track */\n\tif (rb_prev(&track->tree_node) == NULL || search_restricted) {\n\t\t/* prev album */\n\t\tif (rb_prev(&track->album->tree_node) == NULL) {\n\t\t\t/* prev artist */\n\t\t\tif (rb_prev(&track->album->artist->tree_node) == NULL)\n\t\t\t\treturn 0;\n\t\t\tartist = to_artist(rb_prev(&track->album->artist->tree_node));\n\t\t\talbum = to_album(rb_last(&artist->album_root));\n\t\t\ttrack = to_tree_track(rb_last(&album->track_root));\n\t\t} else {\n\t\t\talbum = to_album(rb_prev(&track->album->tree_node));\n\t\t\ttrack = to_tree_track(rb_last(&album->track_root));\n\t\t}\n\t} else {\n\t\ttrack = to_tree_track(rb_prev(&track->tree_node));\n\t}\n\titer->data1 = track;\n\treturn 1;\n}\n\nstatic int tree_search_get_next(struct iter *iter)\n{\n\tstruct rb_root *root = iter->data0;\n\tstruct tree_track *track = iter->data1;\n\tstruct artist *artist;\n\tstruct album *album;\n\n\tBUG_ON(iter->data2);\n\tif (root == NULL)\n\t\treturn 0;\n\tif (track == NULL) {\n\t\t/* head, get first track */\n\t\tif (rb_root_empty(root)) {\n\t\t\t/* empty, iter points to the head already */\n\t\t\treturn 0;\n\t\t}\n\t\tartist = to_artist(rb_first(root));\n\t\talbum = to_album(rb_first(&artist->album_root));\n\t\titer->data1 = to_tree_track(rb_first(&album->track_root));\n\t\treturn 1;\n\t}\n\t/* next track */\n\tif (rb_next(&track->tree_node) == NULL || search_restricted) {\n\t\t/* next album */\n\t\tif (rb_next(&track->album->tree_node) == NULL) {\n\t\t\t/* next artist */\n\t\t\tif (rb_next(&track->album->artist->tree_node) == NULL)\n\t\t\t\treturn 0;\n\t\t\tartist = to_artist(rb_next(&track->album->artist->tree_node));\n\t\t\talbum = to_album(rb_first(&artist->album_root));\n\t\t\ttrack = to_tree_track(rb_first(&album->track_root));\n\t\t} else {\n\t\t\talbum = to_album(rb_next(&track->album->tree_node));\n\t\t\ttrack = to_tree_track(rb_first(&album->track_root));\n\t\t}\n\t} else {\n\t\ttrack = to_tree_track(rb_next(&track->tree_node));\n\t}\n\titer->data1 = track;\n\treturn 1;\n}\n/* }}} */\n\n/* tree window iterators {{{ */\nstatic int tree_get_prev(struct iter *iter)\n{\n\tstruct rb_root *root = iter->data0;\n\tstruct artist *artist = iter->data1;\n\tstruct album *album = iter->data2;\n\n\tBUG_ON(root == NULL);\n\tBUG_ON(artist == NULL && album != NULL);\n\tif (artist == NULL) {\n\t\t/* head, get last artist and/or album */\n\t\tif (rb_root_empty(root)) {\n\t\t\t/* empty, iter points to the head already */\n\t\t\treturn 0;\n\t\t}\n\t\tartist = to_artist(rb_last(root));\n\t\tif (artist->expanded) {\n\t\t\talbum = to_album(rb_last(&artist->album_root));\n\t\t} else {\n\t\t\talbum = NULL;\n\t\t}\n\t\titer->data1 = artist;\n\t\titer->data2 = album;\n\t\treturn 1;\n\t}\n\tif (artist->expanded && album) {\n\t\t/* prev album */\n\t\tif (rb_prev(&album->tree_node) == NULL) {\n\t\t\titer->data2 = NULL;\n\t\t\treturn 1;\n\t\t} else {\n\t\t\titer->data2 = to_album(rb_prev(&album->tree_node));\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/* prev artist */\n\tif (rb_prev(&artist->tree_node) == NULL) {\n\t\titer->data1 = NULL;\n\t\titer->data2 = NULL;\n\t\treturn 0;\n\t}\n\tartist = to_artist(rb_prev(&artist->tree_node));\n\titer->data1 = artist;\n\titer->data2 = NULL;\n\tif (artist->expanded) {\n\t\t/* last album */\n\t\titer->data2 = to_album(rb_last(&artist->album_root));\n\t}\n\treturn 1;\n}\n\nstatic int tree_get_next(struct iter *iter)\n{\n\tstruct rb_root *root = iter->data0;\n\tstruct artist *artist = iter->data1;\n\tstruct album *album = iter->data2;\n\n\tBUG_ON(root == NULL);\n\tBUG_ON(artist == NULL && album != NULL);\n\tif (artist == NULL) {\n\t\t/* head, get first artist */\n\t\tif (rb_root_empty(root)) {\n\t\t\t/* empty, iter points to the head already */\n\t\t\treturn 0;\n\t\t}\n\t\titer->data1 = to_artist(rb_first(root));\n\t\titer->data2 = NULL;\n\t\treturn 1;\n\t}\n\tif (artist->expanded) {\n\t\t/* next album */\n\t\tif (album == NULL) {\n\t\t\t/* first album */\n\t\t\titer->data2 = to_album(rb_first(&artist->album_root));\n\t\t\treturn 1;\n\t\t}\n\t\tif (rb_next(&album->tree_node) != NULL) {\n\t\t\titer->data2 = to_album(rb_next(&album->tree_node));\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/* next artist */\n\tif (rb_next(&artist->tree_node) == NULL) {\n\t\titer->data1 = NULL;\n\t\titer->data2 = NULL;\n\t\treturn 0;\n\t}\n\titer->data1 = to_artist(rb_next(&artist->tree_node));\n\titer->data2 = NULL;\n\treturn 1;\n}\n/* }}} */\n\nstatic GENERIC_TREE_ITER_PREV(tree_track_get_prev_by_album, struct tree_track, tree_node)\nstatic GENERIC_TREE_ITER_NEXT(tree_track_get_next_by_album, struct tree_track, tree_node)\n\n/* track window iterators by artist */\nstatic int tree_track_get_prev_by_artist(struct iter *iter)\n{\n\tstruct track_iter *it = (struct track_iter *)iter;\n\n\t/* get last album */\n\tif (it->album == NULL) {\n\t\tif (rb_root_empty(it->root))\n\t\t\treturn 0;\n\t\tit->album = to_album(rb_last(it->root));\n\t\tit->track = NULL;\n\t\treturn tree_track_get_prev_by_artist(iter);\n\t}\n\n\t/* get previous album */\n\tif (it->track == (struct tree_track *)it->album) {\n\t\t/* no more albums */\n\t\tif (rb_prev(&it->album->tree_node) == NULL)\n\t\t\treturn 0;\n\t\tit->album = to_album(rb_prev(&it->album->tree_node));\n\t\tit->track = NULL;\n\t\treturn tree_track_get_prev_by_artist(iter);\n\t}\n\n\t/* get last track */\n\tif (it->track == NULL) {\n\t\tif (rb_root_empty(&it->album->track_root))\n\t\t\tit->track = (struct tree_track *)it->album;\n\t\telse\n\t\t\tit->track = to_tree_track(rb_last(&it->album->track_root));\n\t\treturn 1;\n\t}\n\n\t/* get previous track */\n\tif (rb_prev(&it->track->tree_node) != NULL) {\n\t\tit->track = to_tree_track(rb_prev(&it->track->tree_node));\n\t\treturn 1;\n\t}\n\n\t/* no more tracks\n\t * get album header */\n\tit->track = (struct tree_track *)it->album;\n\treturn 1;\n}\n\nstatic int tree_track_get_next_by_artist(struct iter *iter)\n{\n\tstruct track_iter *it = (struct track_iter *)iter;\n\n\t/* get first album */\n\tif (it->album == NULL) {\n\t\tif (rb_root_empty(it->root))\n\t\t\treturn 0;\n\t\tit->album = to_album(rb_first(it->root));\n\t\tit->track = (struct tree_track *)it->album;\n\t\treturn 1;\n\t}\n\n\t/* get first track */\n\tif (it->track == (struct tree_track *)it->album) {\n\t\t/* this happens when the last track in an album is deleted but\n\t\t * the album header is still referenced in lib_track_win->top\n\t\t * set track = NULL to skip the next `if` without goto */\n\t\tif (rb_root_empty(&it->album->track_root)) {\n\t\t\tit->track = NULL;\n\t\t} else {\n\t\t\tit->track = to_tree_track(rb_first(&it->album->track_root));\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/* get next track */\n\tif (it->track != NULL && rb_next(&it->track->tree_node) != NULL) {\n\t\tit->track = to_tree_track(rb_next(&it->track->tree_node));\n\t\treturn 1;\n\t}\n\n\t/* no more tracks\n\t * get next album */\n\tif (rb_next(&it->album->tree_node) != NULL) {\n\t\tit->album = to_album(rb_next(&it->album->tree_node));\n\t\tit->track = (struct tree_track *)it->album;\n\t\treturn 1;\n\t}\n\n\t/* no more albums */\n\treturn 0;\n}\n\n/* track window iterators */\nstatic int tree_track_get_prev(struct iter *iter)\n{\n\tif (tree_album_selected())\n\t\treturn tree_track_get_prev_by_album(iter);\n\telse\n\t\treturn tree_track_get_prev_by_artist(iter);\n}\n\nstatic int tree_track_get_next(struct iter *iter)\n{\n\tif (tree_album_selected())\n\t\treturn tree_track_get_next_by_album(iter);\n\telse\n\t\treturn tree_track_get_next_by_artist(iter);\n}\n\n/* search (tree) {{{ */\nstatic int tree_search_get_current(void *data, struct iter *iter, enum search_direction dir)\n{\n\tstruct artist *artist;\n\tstruct album *album;\n\tstruct tree_track *track;\n\tstruct iter tmpiter;\n\n\tif (rb_root_empty(&lib_artist_root))\n\t\treturn 0;\n\tif (window_get_sel(lib_track_win, &tmpiter)) {\n\t\ttrack = iter_to_tree_track(&tmpiter);\n\t\tif (search_restricted) {\n\t\t\t/**\n\t\t\t * tree_search_get_next/tree_search_get_prev only return\n\t\t\t * the first/last (for forward/backwards) track node for\n\t\t\t * restricted search, so we need to make this match so\n\t\t\t * do_u_search's check for if we've gone back to the\n\t\t\t * starting iter eventually succeeds\n\t\t\t */\n\t\t\tif (dir == SEARCH_FORWARD) {\n\t\t\t\ttrack = to_tree_track(rb_first(&track->album->track_root));\n\t\t\t} else {\n\t\t\t\ttrack = to_tree_track(rb_last(&track->album->track_root));\n\t\t\t}\n\t\t}\n\t\ttree_search_track_to_iter(track, iter);\n\t\treturn 1;\n\t}\n\n\t/* artist not expanded. track_win is empty set tmp to the first/last\n\t * track of the selected artist for forwards/backwards respectively */\n\twindow_get_sel(lib_tree_win, &tmpiter);\n\tartist = iter_to_artist(&tmpiter);\n\talbum = to_album(rb_first(&artist->album_root));\n\tif (search_restricted) {\n\t\tif (dir == SEARCH_FORWARD) {\n\t\t\ttrack = to_tree_track(rb_first(&album->track_root));\n\t\t} else {\n\t\t\ttrack = to_tree_track(rb_last(&album->track_root));\n\t\t}\n\t} else {\n\t\ttrack = to_tree_track(rb_first(&album->track_root));\n\t}\n\ttree_search_track_to_iter(track, iter);\n\treturn 1;\n}\n\nstatic inline struct tree_track *iter_to_tree_search_track(const struct iter *iter)\n{\n\tBUG_ON(iter->data0 != &lib_artist_root);\n\treturn iter->data1;\n}\n\nstatic int tree_search_matches(void *data, struct iter *iter, const char *text);\n\nstatic const struct searchable_ops tree_search_ops = {\n\t.get_prev = tree_search_get_prev,\n\t.get_next = tree_search_get_next,\n\t.get_current = tree_search_get_current,\n\t.matches = tree_search_matches\n};\n/* search (tree) }}} */\n\nstatic void tree_sel_changed(void)\n{\n\ttree_sel_update(1);\n}\n\nvoid tree_sel_update(int changed)\n{\n\tstruct iter sel;\n\tstruct album *album;\n\tstruct artist *artist;\n\n\twindow_get_sel(lib_tree_win, &sel);\n\talbum = iter_to_album(&sel);\n\tartist = show_all_tracks ? iter_to_artist(&sel) : NULL;\n\n\tif (album != NULL) {\n\t\tif (changed)\n\t\t\twindow_set_contents(lib_track_win, &album->track_root);\n\t} else if (artist != NULL) {\n\t\twindow_set_contents(lib_track_win, &artist->album_root);\n\t} else {\n\t\tif (lib_cur_win != lib_tree_win) {\n\t\t\tlib_cur_win = lib_tree_win;\n\t\t\tlib_tree_win->changed = 1;\n\t\t}\n\t\twindow_set_empty(lib_track_win);\n\t}\n}\n\nstatic inline void tree_win_get_selected(struct artist **artist, struct album **album)\n{\n\tstruct iter sel;\n\n\t*artist = NULL;\n\t*album = NULL;\n\tif (window_get_sel(lib_tree_win, &sel)) {\n\t\t*artist = iter_to_artist(&sel);\n\t\t*album = iter_to_album(&sel);\n\t}\n}\n\nstatic char *auto_artist_sort_name(const char *name)\n{\n\tconst char *name_orig = name;\n\tchar *buf;\n\n\tif (strncasecmp(name, \"the \", 4) != 0)\n\t\treturn NULL;\n\n\tname += 4;\n\twhile (isspace((int)*name))\n\t\t++name;\n\n\tif (*name == '\\0')\n\t\treturn NULL;\n\n\tbuf = xnew(char, strlen(name_orig) + 2);\n\tsprintf(buf, \"%s, %c%c%c\", name, name_orig[0],\n\t\t\t\t\t name_orig[1],\n\t\t\t\t\t name_orig[2]);\n\treturn buf;\n}\n\nstatic struct artist *artist_new(const char *name, const char *sort_name, int is_compilation)\n{\n\tstruct artist *a = xnew(struct artist, 1);\n\n\ta->name = xstrdup(name);\n\ta->sort_name = sort_name ? xstrdup(sort_name) : NULL;\n\ta->auto_sort_name = auto_artist_sort_name(name);\n\ta->collkey_name = u_strcasecoll_key(a->name);\n\ta->collkey_sort_name = u_strcasecoll_key0(a->sort_name);\n\ta->collkey_auto_sort_name = u_strcasecoll_key0(a->auto_sort_name);\n\ta->expanded = 0;\n\ta->is_compilation = is_compilation;\n\trb_root_init(&a->album_root);\n\n\treturn a;\n}\n\nstatic struct artist *artist_copy(const struct artist *artist)\n{\n\treturn artist_new(artist->name, artist->sort_name, artist->is_compilation);\n}\n\nstatic void artist_free(struct artist *artist)\n{\n\tfree(artist->name);\n\tfree(artist->sort_name);\n\tfree(artist->auto_sort_name);\n\tfree(artist->collkey_name);\n\tfree(artist->collkey_sort_name);\n\tfree(artist->collkey_auto_sort_name);\n\tfree(artist);\n}\n\nstatic struct album *album_new(struct artist *artist, const char *name,\n\t\tconst char *sort_name, int date)\n{\n\tstruct album *album = xnew(struct album, 1);\n\n\talbum->name = xstrdup(name);\n\talbum->sort_name = sort_name ? xstrdup(sort_name) : NULL;\n\talbum->collkey_name = u_strcasecoll_key(name);\n\talbum->collkey_sort_name = u_strcasecoll_key0(sort_name);\n\talbum->date = date;\n\talbum->min_date = date;\n\trb_root_init(&album->track_root);\n\talbum->artist = artist;\n\n\treturn album;\n}\n\nstatic void album_free(struct album *album)\n{\n\tfree(album->name);\n\tfree(album->sort_name);\n\tfree(album->collkey_name);\n\tfree(album->collkey_sort_name);\n\tfree(album);\n}\n\nstatic int track_selectable(struct iter *iter)\n{\n\tstruct track_iter *it = (struct track_iter *)iter;\n\treturn it->album != (struct album *)it->track;\n}\n\nvoid tree_init(void)\n{\n\tstruct iter iter;\n\n\trb_root_init(&lib_artist_root);\n\n\tlib_tree_win = window_new(tree_get_prev, tree_get_next);\n\tlib_track_win = window_new(tree_track_get_prev, tree_track_get_next);\n\tlib_cur_win = lib_tree_win;\n\n\tlib_tree_win->sel_changed = tree_sel_changed;\n\tlib_track_win->selectable = track_selectable;\n\n\twindow_set_empty(lib_track_win);\n\twindow_set_contents(lib_tree_win, &lib_artist_root);\n\n\titer.data0 = &lib_artist_root;\n\titer.data1 = NULL;\n\titer.data2 = NULL;\n\ttree_searchable = searchable_new(NULL, &iter, &tree_search_ops);\n}\n\nstruct tree_track *tree_get_selected(void)\n{\n\tstruct artist *artist;\n\tstruct album *album;\n\tstruct tree_track *track;\n\tstruct iter sel;\n\n\tif (rb_root_empty(&lib_artist_root))\n\t\treturn NULL;\n\n\ttree_win_get_selected(&artist, &album);\n\tif (album == NULL && !show_all_tracks) {\n\t\t/* track window is empty\n\t\t * => get first album of the selected artist and first track of that album\n\t\t */\n\t\talbum = to_album(rb_first(&artist->album_root));\n\t\ttrack = to_tree_track(rb_first(&album->track_root));\n\t} else {\n\t\twindow_get_sel(lib_track_win, &sel);\n\t\ttrack = iter_to_tree_track(&sel);\n\t}\n\n\treturn track;\n}\n\nstruct track_info *tree_activate_selected(void)\n{\n\tstruct track_info *info;\n\n\tlib_cur_track = tree_get_selected();\n\tif (!lib_cur_track)\n\t\treturn NULL;\n\n\tlib_tree_win->changed = 1;\n\tlib_track_win->changed = 1;\n\n\tinfo = tree_track_info(lib_cur_track);\n\ttrack_info_ref(info);\n\treturn info;\n}\n\nstatic int special_name_cmp(const char *a, const char *collkey_a,\n\t\t               const char *b, const char *collkey_b)\n{\n\t/* keep <Stream> etc. top */\n\tint cmp = (*a != '<') - (*b != '<');\n\n\tif (cmp)\n\t\treturn cmp;\n\treturn strcmp(collkey_a, collkey_b);\n}\n\nstatic inline const char *album_sort_collkey(const struct album *a)\n{\n\tif (a->sort_name)\n\t\treturn a->collkey_sort_name;\n\n\treturn a->collkey_name;\n}\n\nstatic int special_album_cmp(const struct album *a, const struct album *b)\n{\n\treturn special_name_cmp(a->name, album_sort_collkey(a), b->name, album_sort_collkey(b));\n}\n\nstatic int special_album_cmp_date(const struct album *a, const struct album *b)\n{\n\t/* keep <Stream> etc. top */\n\tint cmp = (*a->name != '<') - (*b->name != '<');\n\tif (cmp)\n\t\treturn cmp;\n\n\tcmp = a->date - b->date;\n\tif (cmp)\n\t\treturn cmp;\n\n\treturn strcmp(album_sort_collkey(a), album_sort_collkey(b));\n}\n\n/* has to follow the same logic as artist_sort_name() */\nstatic inline const char *artist_sort_collkey(const struct artist *a)\n{\n\tif (a->sort_name)\n\t\treturn a->collkey_sort_name;\n\n\tif (smart_artist_sort && a->auto_sort_name)\n\t\treturn a->collkey_auto_sort_name;\n\n\treturn a->collkey_name;\n}\n\nstatic struct artist *do_find_artist(const struct artist *artist,\n\t\t                     struct rb_root *root,\n\t\t\t\t     struct rb_node ***p_new,\n\t\t\t\t     struct rb_node **p_parent)\n{\n\tstruct rb_node **new = &(root->rb_node), *parent = NULL;\n\tconst char *a = artist_sort_name(artist);\n\tconst char *collkey_a = artist_sort_collkey(artist);\n\n\twhile (*new) {\n\t\tstruct artist *cur_artist = to_artist(*new);\n\t\tconst char *b = artist_sort_name(cur_artist);\n\t\tconst char *collkey_b = artist_sort_collkey(cur_artist);\n\t\tint result = special_name_cmp(a, collkey_a, b, collkey_b);\n\n\t\tparent = *new;\n\t\tif (result < 0)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse if (result > 0)\n\t\t\tnew = &((*new)->rb_right);\n\t\telse\n\t\t\treturn cur_artist;\n\t}\n\tif (p_new)\n\t\t*p_new = new;\n\tif (p_parent)\n\t\t*p_parent = parent;\n\treturn NULL;\n}\n\n/* search (tree) {{{ */\nstatic struct artist *collapse_artist;\n\nstatic int tree_search_matches(void *data, struct iter *iter, const char *text)\n{\n\tstruct tree_track *track;\n\tstruct iter tmpiter;\n\tunsigned int flags = TI_MATCH_ARTIST | TI_MATCH_ALBUM | TI_MATCH_ALBUMARTIST;\n\n\tif (!search_restricted)\n\t\tflags |= TI_MATCH_TITLE;\n\ttrack = iter_to_tree_search_track(iter);\n\tif (!track_info_matches(tree_track_info(track), text, flags))\n\t\treturn 0;\n\n\tif (auto_expand_albums_search) {\n\t\t/* collapse old search result */\n\t\tif (collapse_artist) {\n\t\t\tstruct artist *artist = do_find_artist(collapse_artist, &lib_artist_root, NULL, NULL);\n\t\t\tif (artist && artist != track->album->artist) {\n\t\t\t\tif (artist->expanded)\n\t\t\t\t\ttree_set_expand_artist(artist, 0);\n\t\t\t\tartist_free(collapse_artist);\n\t\t\t\tcollapse_artist = (!track->album->artist->expanded) ? artist_copy(track->album->artist) : NULL;\n\t\t\t}\n\t\t} else if (!track->album->artist->expanded) {\n\t\t\tcollapse_artist = artist_copy(track->album->artist);\n\t\t}\n\n\t\ttrack->album->artist->expanded = 1;\n\t\talbum_to_iter(track->album, &tmpiter);\n\t} else {\n\t\tartist_to_iter(track->album->artist, &tmpiter);\n\t}\n\n\twindow_set_sel(lib_tree_win, &tmpiter);\n\n\ttree_track_to_track_iter(track, (struct track_iter *)&tmpiter);\n\twindow_set_sel(lib_track_win, &tmpiter);\n\n\treturn 1;\n}\n/* search (tree) }}} */\n\nstatic void insert_artist(struct artist *artist, struct rb_root *root)\n{\n\tstruct rb_node **new = &(root->rb_node), *parent = NULL;\n\tstruct artist *found;\n\n\tfound = do_find_artist(artist, root, &new, &parent);\n\tif (!found) {\n\t\trb_link_node(&artist->tree_node, parent, new);\n\t\trb_insert_color(&artist->tree_node, root);\n\t}\n}\n\nstatic void add_artist(struct artist *artist)\n{\n\tinsert_artist(artist, &lib_artist_root);\n}\n\nstatic struct artist *find_artist(const struct artist *artist)\n{\n\treturn do_find_artist(artist, &lib_artist_root, NULL, NULL);\n}\n\nstatic struct album *do_find_album(const struct album *album,\n\t\t\t\t   int (*cmp)(const struct album *, const struct album *),\n\t\t\t\t   struct rb_node ***p_new,\n\t\t\t\t   struct rb_node **p_parent)\n{\n\tstruct rb_node **new = &(album->artist->album_root.rb_node), *parent = NULL;\n\n\twhile (*new) {\n\t\tstruct album *a = to_album(*new);\n\n\t\tint result = cmp(album, a);\n\n\t\tparent = *new;\n\t\tif (result < 0)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse if (result > 0)\n\t\t\tnew = &((*new)->rb_right);\n\t\telse\n\t\t\treturn a;\n\t}\n\tif (p_new)\n\t\t*p_new = new;\n\tif (p_parent)\n\t\t*p_parent = parent;\n\treturn NULL;\n}\n\nstatic struct album *find_album(const struct album *album)\n{\n\tstruct album *a;\n\tstruct rb_node *tmp;\n\n\t/* do a linear search because we want find albums with different date */\n\trb_for_each_entry(a, tmp, &album->artist->album_root, tree_node) {\n\t\tif (special_album_cmp(album, a) == 0)\n\t\t\treturn a;\n\t}\n\treturn NULL;\n}\n\nstatic void add_album(struct album *album)\n{\n\tstruct rb_node **new = &(album->artist->album_root.rb_node), *parent = NULL;\n\tstruct album *found;\n\n\tif (sort_albums_by_name || album->artist->is_compilation)\n\t\tfound = do_find_album(album, special_album_cmp, &new, &parent);\n\telse\n\t\tfound = do_find_album(album, special_album_cmp_date, &new, &parent);\n\n\tif (!found) {\n\t\trb_link_node(&album->tree_node, parent, new);\n\t\trb_insert_color(&album->tree_node, &album->artist->album_root);\n\t}\n}\n\nstatic void album_add_track(struct album *album, struct tree_track *track)\n{\n\t/*\n\t * NOTE: This is not perfect.  You should ignore track numbers if\n\t *       either is unset and use filename instead, but usually you\n\t *       have all track numbers set or all unset (within one album\n\t *       of course).\n\t */\n\tstatic const sort_key_t album_track_sort_keys[] = {\n\t\tSORT_DISCNUMBER, SORT_TRACKNUMBER, SORT_FILENAME, SORT_INVALID\n\t};\n\tstruct rb_node **new = &(album->track_root.rb_node), *parent = NULL;\n\n\ttrack->album = album;\n\twhile (*new) {\n\t\tconst struct simple_track *a = (const struct simple_track *) track;\n\t\tconst struct simple_track *b = (const struct simple_track *) to_tree_track(*new);\n\t\tint result = track_info_cmp(a->info, b->info, album_track_sort_keys);\n\n\t\tparent = *new;\n\t\tif (result < 0)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse\n\t\t\tnew = &((*new)->rb_right);\n\t}\n\n\trb_link_node(&track->tree_node, parent, new);\n\trb_insert_color(&track->tree_node, &album->track_root);\n}\n\nconst char *tree_artist_name(const struct track_info* ti)\n{\n\tconst char *val = ti->albumartist;\n\n\tif (ti->is_va_compilation)\n\t\tval = \"<Various Artists>\";\n\tif (!val || strcmp(val, \"\") == 0)\n\t\tval = \"<No Name>\";\n\n\treturn val;\n}\n\nconst char *tree_album_name(const struct track_info* ti)\n{\n\tconst char *val = ti->album;\n\n\tif (!val || strcmp(val, \"\") == 0)\n\t\tval = \"<No Name>\";\n\n\treturn val;\n}\n\nstatic void remove_album(struct album *album)\n{\n\tif (album->artist->expanded) {\n\t\tstruct iter iter;\n\n\t\talbum_to_iter(album, &iter);\n\t\twindow_row_vanishes(lib_tree_win, &iter);\n\t}\n\trb_erase(&album->tree_node, &album->artist->album_root);\n}\n\nstatic void remove_artist(struct artist *artist)\n{\n\tstruct iter iter;\n\n\tartist_to_iter(artist, &iter);\n\twindow_row_vanishes(lib_tree_win, &iter);\n\trb_erase(&artist->tree_node, &lib_artist_root);\n}\n\nvoid tree_add_track(struct tree_track *track,\n\t\tvoid (*add_album_cb)(struct album *))\n{\n\tconst struct track_info *ti = tree_track_info(track);\n\tconst char *album_name, *artist_name, *artistsort_name = NULL;\n\tconst char *albumsort_name = NULL;\n\tstruct artist *artist, *new_artist;\n\tstruct album *album, *new_album;\n\tint date;\n\tint is_va_compilation = 0;\n\n\tdate = ti->originaldate;\n\tif (date < 0)\n\t\tdate = ti->date;\n\n\tif (is_http_url(ti->filename)) {\n\t\tartist_name = \"<Stream>\";\n\t\talbum_name = \"<Stream>\";\n\t} else {\n\t\talbum_name\t= tree_album_name(ti);\n\t\tartist_name\t= tree_artist_name(ti);\n\t\tartistsort_name\t= ti->artistsort;\n\t\talbumsort_name\t= ti->albumsort;\n\n\t\tis_va_compilation = ti->is_va_compilation;\n\t}\n\n\tnew_artist = artist_new(artist_name, artistsort_name, is_va_compilation);\n\talbum = NULL;\n\n\tartist = find_artist(new_artist);\n\tif (artist) {\n\t\tartist_free(new_artist);\n\t\tnew_album = album_new(artist, album_name, albumsort_name, date);\n\t\talbum = find_album(new_album);\n\t\tif (album)\n\t\t\talbum_free(new_album);\n\t} else\n\t\tnew_album = album_new(new_artist, album_name, albumsort_name, date);\n\n\tif (artist) {\n\t\tint changed = 0;\n\t\t/* If it makes sense to update sort_name, do it */\n\t\tif (!artist->sort_name && artistsort_name) {\n\t\t\tartist->sort_name = xstrdup(artistsort_name);\n\t\t\tartist->collkey_sort_name = u_strcasecoll_key(artistsort_name);\n\t\t\tchanged = 1;\n\t\t}\n\t\t/* If names differ, update */\n\t\tif (!artist->auto_sort_name) {\n\t\t\tchar *auto_sort_name = auto_artist_sort_name(artist_name);\n\t\t\tif (auto_sort_name) {\n\t\t\t\tfree(artist->name);\n\t\t\t\tfree(artist->collkey_name);\n\t\t\t\tartist->name = xstrdup(artist_name);\n\t\t\t\tartist->collkey_name = u_strcasecoll_key(artist_name);\n\t\t\t\tartist->auto_sort_name = auto_sort_name;\n\t\t\t\tartist->collkey_auto_sort_name = u_strcasecoll_key(auto_sort_name);\n\t\t\t\tchanged = 1;\n\t\t\t}\n\t\t}\n\t\tif (changed) {\n\t\t\tremove_artist(artist);\n\t\t\tadd_artist(artist);\n\t\t\twindow_changed(lib_tree_win);\n\t\t}\n\t}\n\n\tif (album) {\n\t\talbum_add_track(album, track);\n\n\t\t/* If it makes sense to update album date, do it */\n\t\tif (album->date < date) {\n\t\t\talbum->date = date;\n\n\t\t\tremove_album(album);\n\t\t\tadd_album(album);\n\t\t\tif (artist->expanded)\n\t\t\t\twindow_changed(lib_tree_win);\n\t\t}\n\n\t\tif (album->min_date <= 0 || (album->min_date > date && date > 0)) {\n\t\t\talbum->min_date = date;\n\n\t\t\tremove_album(album);\n\t\t\tadd_album(album);\n\t\t\tif (artist->expanded)\n\t\t\t\twindow_changed(lib_tree_win);\n\t\t}\n\n\t} else if (artist) {\n\t\tadd_album(new_album);\n\t\tadd_album_cb(new_album);\n\t\talbum_add_track(new_album, track);\n\n\t\tif (artist->expanded)\n\t\t\twindow_changed(lib_tree_win);\n\t} else {\n\t\tadd_artist(new_artist);\n\t\tadd_album(new_album);\n\t\tadd_album_cb(new_album);\n\t\talbum_add_track(new_album, track);\n\n\t\twindow_changed(lib_tree_win);\n\t}\n\n\tif (track_visible(track))\n\t\twindow_changed(lib_track_win);\n}\n\nstatic void remove_sel_artist(struct artist *artist)\n{\n\tstruct rb_node *a_node, *a_tmp;\n\n\trb_for_each_safe(a_node, a_tmp, &artist->album_root) {\n\t\tstruct rb_node *t_node, *t_tmp;\n\t\tstruct album *album = to_album(a_node);\n\n\t\trb_for_each_safe(t_node, t_tmp, &album->track_root) {\n\t\t\tstruct tree_track *track = to_tree_track(t_node);\n\n\t\t\teditable_remove_track(&lib_editable, (struct simple_track *)track);\n\t\t}\n\t\t/* all tracks removed => album removed\n\t\t * if the last album was removed then the artist was removed too\n\t\t */\n\t}\n}\n\nstatic void remove_sel_album(struct album *album)\n{\n\tstruct rb_node *node, *tmp;\n\n\trb_for_each_safe(node, tmp, &album->track_root) {\n\t\tstruct tree_track *track = to_tree_track(node);\n\n\t\teditable_remove_track(&lib_editable, (struct simple_track *)track);\n\t}\n}\n\nstatic void tree_win_remove_sel(void)\n{\n\tstruct artist *artist;\n\tstruct album *album;\n\n\ttree_win_get_selected(&artist, &album);\n\tif (album) {\n\t\tremove_sel_album(album);\n\t} else if (artist) {\n\t\tremove_sel_artist(artist);\n\t}\n}\n\nstatic void track_win_remove_sel(void)\n{\n\tstruct iter sel;\n\tstruct tree_track *track;\n\n\tif (window_get_sel(lib_track_win, &sel)) {\n\t\ttrack = iter_to_tree_track(&sel);\n\t\tBUG_ON(track == NULL);\n\t\teditable_remove_track(&lib_editable, (struct simple_track *)track);\n\t}\n}\n\nvoid tree_toggle_active_window(void)\n{\n\tif (lib_cur_win == lib_tree_win) {\n\t\tstruct artist *artist;\n\t\tstruct album *album;\n\n\t\ttree_win_get_selected(&artist, &album);\n\t\tif (album || (artist && show_all_tracks)) {\n\t\t\tlib_cur_win = lib_track_win;\n\t\t\tlib_tree_win->changed = 1;\n\t\t\tlib_track_win->changed = 1;\n\t\t}\n\t} else if (lib_cur_win == lib_track_win) {\n\t\tlib_cur_win = lib_tree_win;\n\t\tlib_tree_win->changed = 1;\n\t\tlib_track_win->changed = 1;\n\t}\n}\n\nvoid tree_toggle_expand_artist(void)\n{\n\tstruct track_iter sel;\n\tstruct artist *artist;\n\tstruct album *album;\n\tstruct tree_track *track;\n\n\ttree_win_get_selected(&artist, &album);\n\tif (album != NULL && show_all_tracks) {\n\t\twindow_get_sel(lib_track_win, (struct iter *)&sel);\n\t\ttrack = sel.track;\n\t\ttree_set_expand_artist(artist, !artist->expanded);\n\t\ttree_track_to_track_iter(track, &sel);\n\t\twindow_set_sel(lib_track_win, (struct iter *)&sel);\n\t} else if (artist != NULL) {\n\t\ttree_set_expand_artist(artist, !artist->expanded);\n\t}\n\n}\n\nvoid tree_expand_matching(const char *text)\n{\n\tstruct artist *artist;\n\tstruct rb_node *tmp1;\n\tint have_track_selected = 0;\n\n\trb_for_each_entry(artist, tmp1, &lib_artist_root, tree_node) {\n\t\tstruct album *album = NULL;\n\t\tstruct rb_node *tmp2;\n\t\tint album_matched = 0;\n\n\t\trb_for_each_entry(album, tmp2, &artist->album_root, tree_node) {\n\t\t\tstruct tree_track *tree_track = to_tree_track(rb_first(&album->track_root));\n\t\t\tstruct track_info *ti = ((struct simple_track *) tree_track)->info;\n\t\t\talbum_matched = track_info_matches_full(ti, text, TI_MATCH_ALBUM, TI_MATCH_ARTIST | TI_MATCH_ALBUMARTIST, 0);\n\t\t\tif (album_matched)\n\t\t\t\tbreak;\n\t\t}\n\t\tartist->expanded = album_matched;\n\t\tif (!have_track_selected) {\n\t\t\tstruct tree_track *tree_track;\n\t\t\tint track_matched = 0;\n\n\t\t\tif (!album)\n\t\t\t\talbum = to_album(rb_first(&artist->album_root));\n\n\t\t\trb_for_each_entry(tree_track, tmp2, &album->track_root, tree_node) {\n\t\t\t\tstruct track_info *ti = ((struct simple_track *) tree_track)->info;\n\t\t\t\ttrack_matched = track_info_matches_full(ti, text, TI_MATCH_TITLE, 0, 0);\n\t\t\t\tif (track_matched)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (album_matched || track_matched) {\n\t\t\t\tif (!tree_track)\n\t\t\t\t\ttree_track = to_tree_track(rb_first(&album->track_root));\n\t\t\t\ttree_sel_track(tree_track, auto_expand_albums_search);\n\t\t\t\thave_track_selected = 1;\n\t\t\t}\n\t\t}\n\t}\n\twindow_changed(lib_tree_win);\n}\n\nvoid tree_expand_all(void)\n{\n\tstruct artist *artist;\n\tstruct rb_node *tmp;\n\n\trb_for_each_entry(artist, tmp, &lib_artist_root, tree_node) {\n\t\tartist->expanded = 1;\n\t}\n\twindow_changed(lib_tree_win);\n}\n\nstatic void remove_track(struct tree_track *track)\n{\n\tif (track_visible(track)) {\n\t\tstruct track_iter iter;\n\t\ttree_track_to_track_iter(track, &iter);\n\t\twindow_row_vanishes(lib_track_win, (struct iter *)&iter);\n\t}\n\trb_erase(&track->tree_node, &track->album->track_root);\n}\n\nvoid tree_remove(struct tree_track *track,\n\t\tvoid (*remove_album_cb)(struct album *))\n{\n\tstruct album *album = track->album;\n\tstruct artist *sel_artist;\n\tstruct album *sel_album;\n\n\ttree_win_get_selected(&sel_artist, &sel_album);\n\n\tremove_track(track);\n\t/* don't free the track */\n\n\tif (rb_root_empty(&album->track_root)) {\n\t\tstruct artist *artist = album->artist;\n\n\t\tif (sel_album == album)\n\t\t\tlib_cur_win = lib_tree_win;\n\n\t\tif (track_visible(track) && !tree_album_selected()) {\n\t\t\tstruct iter iter;\n\t\t\talbum_to_track_iter(album, (struct track_iter*)&iter);\n\t\t\twindow_row_vanishes(lib_track_win, &iter);\n\t\t}\n\n\t\tremove_album(album);\n\t\tremove_album_cb(album);\n\t\talbum_free(album);\n\n\t\tif (rb_root_empty(&artist->album_root)) {\n\t\t\tartist->expanded = 0;\n\t\t\tremove_artist(artist);\n\t\t\tartist_free(artist);\n\t\t}\n\t}\n}\n\nvoid tree_remove_sel(void)\n{\n\tif (lib_cur_win == lib_tree_win) {\n\t\ttree_win_remove_sel();\n\t} else {\n\t\ttrack_win_remove_sel();\n\t}\n}\n\nvoid tree_sort_artists(void (*add_album_cb)(struct album *),\n\t\tvoid (*remove_album_cb)(struct album *))\n{\n\tstruct rb_node *a_node, *a_tmp;\n\n\trb_for_each_safe(a_node, a_tmp, &lib_artist_root) {\n\t\tstruct rb_node *l_node, *l_tmp;\n\t\tstruct artist *artist = to_artist(a_node);\n\n\t\trb_for_each_safe(l_node, l_tmp, &artist->album_root) {\n\t\t\tstruct rb_node *t_node, *t_tmp;\n\t\t\tstruct album *album = to_album(l_node);\n\n\t\t\tremove_album(album);\n\t\t\tadd_album(album);\n\t\t\trb_for_each_safe(t_node, t_tmp, &album->track_root) {\n\t\t\t\tstruct tree_track *track = to_tree_track(t_node);\n\n\t\t\t\ttree_remove(track, remove_album_cb);\n\t\t\t\ttree_add_track(track, add_album_cb);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid tree_sel_current(int auto_expand_albums)\n{\n\ttree_sel_track(lib_cur_track, auto_expand_albums);\n}\n\nvoid tree_sel_first(void)\n{\n\tif (!rb_root_empty(&lib_artist_root)) {\n\t\tstruct artist *artist = to_artist(rb_first(&lib_artist_root));\n\t\tstruct album *album = to_album(rb_first(&artist->album_root));\n\t\tstruct tree_track *tree_track = to_tree_track(rb_first(&album->track_root));\n\t\ttree_sel_track(tree_track, auto_expand_albums_search);\n\t}\n}\n\nvoid tree_sel_track(struct tree_track *t, int auto_expand_albums)\n{\n\tif (t) {\n\t\tstruct iter iter;\n\n\t\tif (auto_expand_albums)\n\t\t\tt->album->artist->expanded = 1;\n\t\tif (t->album->artist->expanded)\n\t\t\talbum_to_iter(t->album, &iter);\n\t\telse\n\t\t\tartist_to_iter(t->album->artist, &iter);\n\n\t\twindow_set_sel(lib_tree_win, &iter);\n\n\t\ttree_track_to_track_iter(t, (struct track_iter *)&iter);\n\t\twindow_set_sel(lib_track_win, &iter);\n\n\t\tif (lib_cur_win == lib_tree_win) {\n\t\t\tlib_cur_win = lib_track_win;\n\t\t\tlib_tree_win->changed = 1;\n\t\t\tlib_track_win->changed = 1;\n\t\t}\n\t}\n}\n\nstatic int album_for_each_track(struct album *album, int (*cb)(void *data, struct track_info *ti),\n\t\tvoid *data, int reverse)\n{\n\tstruct tree_track *track;\n\tstruct rb_node *tmp;\n\tint rc = 0;\n\n\tif (reverse) {\n\t\trb_for_each_entry_reverse(track, tmp, &album->track_root, tree_node) {\n\t\t\trc = cb(data, tree_track_info(track));\n\t\t\tif (rc)\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\trb_for_each_entry(track, tmp, &album->track_root, tree_node) {\n\t\t\trc = cb(data, tree_track_info(track));\n\t\t\tif (rc)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn rc;\n}\n\nstatic int artist_for_each_track(struct artist *artist, int (*cb)(void *data, struct track_info *ti),\n\t\tvoid *data, int reverse)\n{\n\tstruct album *album;\n\tstruct rb_node *tmp;\n\tint rc = 0;\n\n\tif (reverse) {\n\t\trb_for_each_entry_reverse(album, tmp, &artist->album_root, tree_node) {\n\t\t\trc = album_for_each_track(album, cb, data, 1);\n\t\t\tif (rc)\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\trb_for_each_entry(album, tmp, &artist->album_root, tree_node) {\n\t\t\trc = album_for_each_track(album, cb, data, 0);\n\t\t\tif (rc)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn rc;\n}\n\nint _tree_for_each_sel(int (*cb)(void *data, struct track_info *ti), void *data, int reverse)\n{\n\tint rc = 0;\n\n\tif (lib_cur_win == lib_tree_win) {\n\t\tstruct artist *artist;\n\t\tstruct album *album;\n\n\t\ttree_win_get_selected(&artist, &album);\n\t\tif (artist) {\n\t\t\tif (album == NULL) {\n\t\t\t\trc = artist_for_each_track(artist, cb, data, reverse);\n\t\t\t} else {\n\t\t\t\trc = album_for_each_track(album, cb, data, reverse);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tstruct iter sel;\n\t\tstruct tree_track *track;\n\n\t\tif (window_get_sel(lib_track_win, &sel)) {\n\t\t\ttrack = iter_to_tree_track(&sel);\n\t\t\trc = cb(data, tree_track_info(track));\n\t\t}\n\t}\n\treturn rc;\n}\n\nint tree_for_each_sel(int (*cb)(void *data, struct track_info *ti), void *data, int reverse, int advance)\n{\n\tint rc = _tree_for_each_sel(cb, data, reverse);\n\n\tif (advance)\n\t\twindow_down(lib_cur_win, 1);\n\treturn rc;\n}\n"
        },
        {
          "name": "u_collate.c",
          "type": "blob",
          "size": 2.8642578125,
          "content": "/*\n * Copyright 2010-2013 Various Authors\n * Copyright 2010 Johannes Weißl\n *\n * based on gunicollate.c from glib\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"u_collate.h\"\n#include \"uchar.h\"\n#include \"xmalloc.h\"\n#include \"ui_curses.h\" /* using_utf8, charset */\n#include \"convert.h\"\n\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\nint u_strcoll(const char *str1, const char *str2)\n{\n\tint result;\n\n\tif (using_utf8) {\n\t\tresult = strcoll(str1, str2);\n\t} else {\n\t\tchar *str1_locale = NULL, *str2_locale = NULL;\n\n\t\tconvert(str1, -1, &str1_locale, -1, charset, \"UTF-8\");\n\t\tconvert(str2, -1, &str2_locale, -1, charset, \"UTF-8\");\n\n\t\tif (str1_locale && str2_locale)\n\t\t\tresult = strcoll(str1_locale, str2_locale);\n\t\telse\n\t\t\tresult = strcmp(str1, str2);\n\n\t\tif (str2_locale)\n\t\t\tfree(str2_locale);\n\t\tif (str1_locale)\n\t\t\tfree(str1_locale);\n\t}\n\n\treturn result;\n}\n\nint u_strcasecoll(const char *str1, const char *str2)\n{\n\tchar *cf_a, *cf_b;\n\tint res;\n\n\tcf_a = u_casefold(str1);\n\tcf_b = u_casefold(str2);\n\n\tres = u_strcoll(cf_a, cf_b);\n\n\tfree(cf_b);\n\tfree(cf_a);\n\n\treturn res;\n}\n\nint u_strcasecoll0(const char *str1, const char *str2)\n{\n\tif (!str1)\n\t\treturn str2 ? -1 : 0;\n\tif (!str2)\n\t\treturn 1;\n\n\treturn u_strcasecoll(str1, str2);\n}\n\nchar *u_strcoll_key(const char *str)\n{\n\tchar *result = NULL;\n\n\tif (using_utf8) {\n\t\tsize_t xfrm_len = strxfrm(NULL, str, 0);\n\t\tif ((ssize_t) xfrm_len >= 0 && xfrm_len < INT_MAX - 2) {\n\t\t\tresult = xnew(char, xfrm_len + 1);\n\t\t\tstrxfrm(result, str, xfrm_len + 1);\n\t\t}\n\t}\n\n\tif (!result) {\n\t\tchar *str_locale = NULL;\n\n\t\tconvert(str, -1, &str_locale, -1, charset, \"UTF-8\");\n\n\t\tif (str_locale) {\n\t\t\tsize_t xfrm_len = strxfrm(NULL, str_locale, 0);\n\t\t\tif ((ssize_t) xfrm_len >= 0 && xfrm_len < INT_MAX - 2) {\n\t\t\t\tresult = xnew(char, xfrm_len + 2);\n\t\t\t\tresult[0] = 'A';\n\t\t\t\tstrxfrm(result + 1, str_locale, xfrm_len + 1);\n\t\t\t}\n\t\t\tfree(str_locale);\n\t\t}\n\t}\n\n\tif (!result) {\n\t\tsize_t xfrm_len = strlen(str);\n\t\tresult = xmalloc(xfrm_len + 2);\n\t\tresult[0] = 'B';\n\t\tmemcpy(result + 1, str, xfrm_len);\n\t\tresult[xfrm_len+1] = '\\0';\n\t}\n\n\treturn result;\n}\n\nchar *u_strcasecoll_key(const char *str)\n{\n\tchar *key, *cf_str;\n\n\tcf_str = u_casefold(str);\n\n\tkey = u_strcoll_key(cf_str);\n\n\tfree(cf_str);\n\n\treturn key;\n}\n\nchar *u_strcasecoll_key0(const char *str)\n{\n\treturn str ? u_strcasecoll_key(str) : NULL;\n}\n"
        },
        {
          "name": "u_collate.h",
          "type": "blob",
          "size": 2.3134765625,
          "content": "/*\n * Copyright 2010-2013 Various Authors\n * Copyright 2010 Johannes Weißl\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_U_COLLATE_H\n#define CMUS_U_COLLATE_H\n\n/*\n * @str1  valid, normalized, null-terminated UTF-8 string\n * @str2  valid, normalized, null-terminated UTF-8 string\n *\n * Compares two strings for ordering using the linguistically\n * correct rules for the current locale.\n *\n * Returns -1 if @str1 compares before @str2, 0 if they compare equal,\n * +1 if @str1 compares after @str2.\n */\nint u_strcoll(const char *str1, const char *str2);\n\n/*\n * @str1  valid, normalized, null-terminated UTF-8 string\n * @str2  valid, normalized, null-terminated UTF-8 string\n *\n * Like u_strcoll(), but do casefolding before comparing.\n */\nint u_strcasecoll(const char *str1, const char *str2);\n\n/*\n * @str1  valid, normalized, null-terminated UTF-8 string or NULL\n * @str2  valid, normalized, null-terminated UTF-8 string or NULL\n *\n * Like u_strcasecoll(), but handle NULL pointers gracefully.\n */\nint u_strcasecoll0(const char *str1, const char *str2);\n\n/*\n * @str  valid, normalized, null-terminated UTF-8 string\n *\n * Converts a string into a collation key that can be compared\n * with other collation keys produced by the same function using\n * strcmp().\n *\n * Returns a newly allocated string.\n */\nchar *u_strcoll_key(const char *str);\n\n/*\n * @str  valid, normalized, null-terminated UTF-8 string\n *\n * Like u_strcoll_key(), but do casefolding before generating key.\n *\n * Returns a newly allocated string.\n */\nchar *u_strcasecoll_key(const char *str);\n\n/*\n * @str  valid, normalized, null-terminated UTF-8 string or NULL\n *\n * Like u_strcasecoll_key(), but handle NULL pointers gracefully.\n */\nchar *u_strcasecoll_key0(const char *str);\n\n#endif\n"
        },
        {
          "name": "uchar.c",
          "type": "blob",
          "size": 13.5771484375,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004-2005 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"uchar.h\"\n#include \"compiler.h\"\n#include \"gbuf.h\"\n#include \"utils.h\" /* N_ELEMENTS */\n#include \"ui_curses.h\" /* using_utf8, charset */\n#include \"convert.h\"\n\n#include <stdlib.h>\n#include <string.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <ctype.h>\n\n#include \"unidecomp.h\"\n#include \"wcwidth_uchar.h\"\n\nconst char hex_tab[16] = \"0123456789abcdef\";\n\n/*\n * Byte Sequence                                             Min       Min        Max\n * ----------------------------------------------------------------------------------\n * 0xxxxxxx                                              0000000   0x00000   0x00007f\n * 110xxxxx 10xxxxxx                                000 10000000   0x00080   0x0007ff\n * 1110xxxx 10xxxxxx 10xxxxxx                  00001000 00000000   0x00800   0x00ffff\n * 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx   00001 00000000 00000000   0x10000   0x10ffff (not 0x1fffff)\n *\n * max: 100   001111   111111   111111  (0x10ffff)\n */\n\n/* Length of UTF-8 byte sequence.\n * Table index is the first byte of UTF-8 sequence.\n */\nstatic const signed char len_tab[256] = {\n\t/*   0-127  0xxxxxxx */\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\n\t/* 128-191  10xxxxxx (invalid first byte) */\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\n\t/* 192-223  110xxxxx */\n\t2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n\t2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n\n\t/* 224-239  1110xxxx */\n\t3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n\n\t/* 240-244  11110xxx (000 - 100) */\n\t4, 4, 4, 4, 4,\n\n\t/* 11110xxx (101 - 111) (always invalid) */\n\t-1, -1, -1,\n\n\t/* 11111xxx (always invalid) */\n\t-1, -1, -1, -1, -1, -1, -1, -1\n};\n\n/* fault-tolerant equivalent to len_tab, from glib */\nstatic const char utf8_skip_data[256] = {\n\t1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n\t1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n\t1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n\t1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n\t1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n\t1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n\t2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,\n\t3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,6,6,1,1\n};\nconst char * const utf8_skip = utf8_skip_data;\n\n/* index is length of the UTF-8 sequence - 1 */\nstatic int min_val[4] = { 0x000000, 0x000080, 0x000800, 0x010000 };\nstatic int max_val[4] = { 0x00007f, 0x0007ff, 0x00ffff, 0x10ffff };\n\n/* get value bits from the first UTF-8 sequence byte */\nstatic unsigned int first_byte_mask[4] = { 0x7f, 0x1f, 0x0f, 0x07 };\n\nint u_is_valid(const char *str)\n{\n\tconst unsigned char *s = (const unsigned char *)str;\n\tint i = 0;\n\n\twhile (s[i]) {\n\t\tunsigned char ch = s[i++];\n\t\tint len = len_tab[ch];\n\n\t\tif (len <= 0)\n\t\t\treturn 0;\n\n\t\tif (len > 1) {\n\t\t\t/* len - 1 10xxxxxx bytes */\n\t\t\tuchar u;\n\t\t\tint c;\n\n\t\t\tlen--;\n\t\t\tu = ch & first_byte_mask[len];\n\t\t\tc = len;\n\t\t\tdo {\n\t\t\t\tch = s[i++];\n\t\t\t\tif (len_tab[ch] != 0)\n\t\t\t\t\treturn 0;\n\t\t\t\tu = (u << 6) | (ch & 0x3f);\n\t\t\t} while (--c);\n\n\t\t\tif (u < min_val[len] || u > max_val[len])\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nsize_t u_strlen(const char *str)\n{\n\tsize_t len;\n\tfor (len = 0; *str; len++)\n\t\tstr = u_next_char(str);\n\treturn len;\n}\n\nsize_t u_strlen_safe(const char *str)\n{\n\tconst unsigned char *s = (const unsigned char *)str;\n\tsize_t len = 0;\n\n\twhile (*s) {\n\t\tint l = len_tab[*s];\n\n\t\tif (unlikely(l > 1)) {\n\t\t\t/* next l - 1 bytes must be 0x10xxxxxx */\n\t\t\tint c = 1;\n\t\t\tdo {\n\t\t\t\tif (len_tab[s[c]] != 0) {\n\t\t\t\t\t/* invalid sequence */\n\t\t\t\t\tgoto single_char;\n\t\t\t\t}\n\t\t\t\tc++;\n\t\t\t} while (c < l);\n\n\t\t\t/* valid sequence */\n\t\t\ts += l;\n\t\t\tlen++;\n\t\t\tcontinue;\n\t\t}\nsingle_char:\n\t\t/* l is -1, 0 or 1\n\t\t * invalid chars counted as single characters */\n\t\ts++;\n\t\tlen++;\n\t}\n\treturn len;\n}\n\nint u_char_width(uchar u)\n{\n\tint w;\n\n\tif (unlikely(u < 0x20))\n\t\tgoto control;\n\n\tif (unlikely(!using_utf8))\n\t\treturn 1;\n\n\t/* invalid bytes in unicode stream are rendered \"<xx>\" */\n\tif (u & U_INVALID_MASK)\n\t\tgoto invalid;\n\n\tw = wcwidth_uchar(u);\n\tif (w >= 0)\n\t\treturn w;\n\telse\n\t\treturn 1;\n\ncontrol:\n\t/* special case */\n\tif (u == 0)\n\t\treturn 1;\n\n\t/* print control chars as <xx> */\ninvalid:\n\treturn 4;\n}\n\nint u_str_width(const char *str)\n{\n\tint idx = 0, w = 0;\n\n\twhile (str[idx]) {\n\t\tuchar u = u_get_char(str, &idx);\n\t\tw += u_char_width(u);\n\t}\n\treturn w;\n}\n\nint u_str_nwidth(const char *str, int len)\n{\n\tint idx = 0;\n\tint w = 0;\n\n\twhile (len > 0) {\n\t\tuchar u = u_get_char(str, &idx);\n\t\tif (u == 0)\n\t\t\tbreak;\n\t\tw += u_char_width(u);\n\t\tlen--;\n\t}\n\treturn w;\n}\n\nchar *u_strchr(const char *str, uchar uch)\n{\n\tint idx = 0;\n\n\twhile (str[idx]) {\n\t\tuchar u = u_get_char(str, &idx);\n\t\tif (uch == u)\n\t\t\treturn (char *) (str + idx);\n\t}\n\treturn NULL;\n}\n\nvoid u_prev_char_pos(const char *str, int *idx)\n{\n\tconst unsigned char *s = (const unsigned char *)str;\n\tint c, len, i = *idx;\n\tuchar ch;\n\n\tch = s[--i];\n\tlen = len_tab[ch];\n\tif (len != 0) {\n\t\t/* start of byte sequence or invalid uchar */\n\t\tgoto one;\n\t}\n\n\tc = 1;\n\twhile (1) {\n\t\tif (i == 0) {\n\t\t\t/* first byte of the sequence is missing */\n\t\t\tbreak;\n\t\t}\n\n\t\tch = s[--i];\n\t\tlen = len_tab[ch];\n\t\tc++;\n\n\t\tif (len == 0) {\n\t\t\tif (c < 4)\n\t\t\t\tcontinue;\n\n\t\t\t/* too long sequence */\n\t\t\tbreak;\n\t\t}\n\t\tif (len != c) {\n\t\t\t/* incorrect length */\n\t\t\tbreak;\n\t\t}\n\n\t\t/* ok */\n\t\t*idx = i;\n\t\treturn;\n\t}\none:\n\t*idx = *idx - 1;\n\treturn;\n}\n\nuchar u_get_char(const char *str, int *idx)\n{\n\tconst unsigned char *s = (const unsigned char *)str;\n\tint len, i, x = 0;\n\tuchar ch, u;\n\n\tif (idx)\n\t\ts += *idx;\n\telse\n\t\tidx = &x;\n\tch = s[0];\n\n\t/* ASCII optimization */\n\tif (ch < 128) {\n\t\t*idx += 1;\n\t\treturn ch;\n\t}\n\n\tlen = len_tab[ch];\n\tif (unlikely(len < 1))\n\t\tgoto invalid;\n\n\tu = ch & first_byte_mask[len - 1];\n\tfor (i = 1; i < len; i++) {\n\t\tch = s[i];\n\t\tif (unlikely(len_tab[ch] != 0))\n\t\t\tgoto invalid;\n\t\tu = (u << 6) | (ch & 0x3f);\n\t}\n\t*idx += len;\n\treturn u;\ninvalid:\n\t*idx += 1;\n\tu = s[0];\n\treturn u | U_INVALID_MASK;\n}\n\nvoid u_set_char_raw(char *str, int *idx, uchar uch)\n{\n\tint i = *idx;\n\n\tif (uch <= 0x0000007fU) {\n\t\tstr[i++] = uch;\n\t\t*idx = i;\n\t} else if (uch <= 0x000007ffU) {\n\t\tstr[i + 1] = (uch & 63) | 0x80; uch >>= 6;\n\t\tstr[i + 0] = uch | 0x000000c0U;\n\t\ti += 2;\n\t\t*idx = i;\n\t} else if (uch <= 0x0000ffffU) {\n\t\tstr[i + 2] = (uch & 63) | 0x80; uch >>= 6;\n\t\tstr[i + 1] = (uch & 63) | 0x80; uch >>= 6;\n\t\tstr[i + 0] = uch | 0x000000e0U;\n\t\ti += 3;\n\t\t*idx = i;\n\t} else if (uch <= 0x0010ffffU) {\n\t\tstr[i + 3] = (uch & 63) | 0x80; uch >>= 6;\n\t\tstr[i + 2] = (uch & 63) | 0x80; uch >>= 6;\n\t\tstr[i + 1] = (uch & 63) | 0x80; uch >>= 6;\n\t\tstr[i + 0] = uch | 0x000000f0U;\n\t\ti += 4;\n\t\t*idx = i;\n\t} else {\n\t\t/* must be an invalid uchar */\n\t\tstr[i++] = uch & 0xff;\n\t\t*idx = i;\n\t}\n}\n\n/*\n * Printing functions, these lose information\n */\n\nvoid u_set_char(char *str, size_t *idx, uchar uch)\n{\n\tint i = *idx;\n\n\tif (unlikely(uch <= 0x0000001fU))\n\t\tgoto invalid;\n\n\tif (uch <= 0x0000007fU) {\n\t\tstr[i++] = uch;\n\t\t*idx = i;\n\t\treturn;\n\t} else if (uch <= 0x000007ffU) {\n\t\tstr[i + 1] = (uch & 63) | 0x80; uch >>= 6;\n\t\tstr[i + 0] = uch | 0x000000c0U;\n\t\ti += 2;\n\t\t*idx = i;\n\t\treturn;\n\t} else if (uch <= 0x0000ffffU) {\n\t\tstr[i + 2] = (uch & 63) | 0x80; uch >>= 6;\n\t\tstr[i + 1] = (uch & 63) | 0x80; uch >>= 6;\n\t\tstr[i + 0] = uch | 0x000000e0U;\n\t\ti += 3;\n\t\t*idx = i;\n\t\treturn;\n\t} else if (uch <= 0x0010ffffU) {\n\t\tstr[i + 3] = (uch & 63) | 0x80; uch >>= 6;\n\t\tstr[i + 2] = (uch & 63) | 0x80; uch >>= 6;\n\t\tstr[i + 1] = (uch & 63) | 0x80; uch >>= 6;\n\t\tstr[i + 0] = uch | 0x000000f0U;\n\t\ti += 4;\n\t\t*idx = i;\n\t\treturn;\n\t}\ninvalid:\n\t/* control character or invalid unicode */\n\tif (uch == 0) {\n\t\t/* handle this special case here to make the common case fast */\n\t\tstr[i++] = 0;\n\t\t*idx = i;\n\t} else {\n\t\tstr[i++] = '<';\n\t\tstr[i++] = hex_tab[(uch >> 4) & 0xf];\n\t\tstr[i++] = hex_tab[uch & 0xf];\n\t\tstr[i++] = '>';\n\t\t*idx = i;\n\t}\n}\n\nsize_t u_copy_chars(char *dst, const char *src, int *width)\n{\n\tint w = *width;\n\tint si = 0;\n\tsize_t di = 0;\n\tint cw;\n\tuchar u;\n\n\twhile (w >= 0) {\n\t\tu = u_get_char(src, &si);\n\t\tif (u == 0)\n\t\t\tbreak;\n\n\t\tcw = u_char_width(u);\n\t\tw -= cw;\n\n\t\tif (unlikely(w < 0)) {\n\t\t\tif (cw == 4 && w >= -3) {\n\t\t\t\tdst[di++] = '<';\n\t\t\t\tif (w >= -2)\n\t\t\t\t\tdst[di++] = hex_tab[(u >> 4) & 0xf];\n\t\t\t\tif (w >= -1)\n\t\t\t\t\tdst[di++] = hex_tab[u & 0xf];\n\t\t\t\tw = 0;\n\t\t\t} else\n\t\t\t\tw += cw;\n\t\t\tbreak;\n\t\t}\n\t\tu_set_char(dst, &di, u);\n\t}\n\t*width = w;\n\treturn di;\n}\n\nint u_to_ascii(char *dst, const char *src, int len)\n{\n\tint i, idx = 0;\n\tfor (i = 0; i < len && src[idx]; i++) {\n\t\tuchar u = u_get_char(src, &idx);\n\t\tdst[i] = (u < 128) ? u : '?';\n\t}\n\treturn i;\n}\n\nvoid u_to_utf8(char *dst, const char *src)\n{\n\tint s = 0;\n\tsize_t d = 0;\n\tuchar u;\n\tdo {\n\t\tu = u_get_char(src, &s);\n\t\tu_set_char(dst, &d, u);\n\t} while (u!=0);\n}\n\nint u_print_size(uchar uch)\n{\n\tint s = u_char_size(uch);\n\t/* control characters and invalid unicode set as <XX> */\n\tif (uch < 0x0000001fU && uch != 0){\n\t\treturn 4;\n\t}\n\treturn s;\n}\n\nint u_str_print_size(const char *str)\n{\n\tint l = 0;\n\tint idx = 0;\n\tuchar u;\n\tdo {\n\t\tu = u_get_char(str, &idx);\n\t\tl += u_print_size(u);\n\t} while (u!=0);\n\treturn l;\n}\n\nint u_skip_chars(const char *str, int *width, bool overskip)\n{\n\tint w = *width;\n\tint last_idx = 0, idx = 0;\n\tuchar u = 0;\n\n\twhile (w > 0) {\n\t\tlast_idx = idx;\n\t\tu = u_get_char(str, &idx);\n\t\tw -= u_char_width(u);\n\t}\n\t/* undo last get if skipped 'too much' (the last char was double width or invalid (<xx>)) */\n\tif (w < 0 && !overskip) {\n\t\tw += u_char_width(u);\n\t\tidx = last_idx;\n\t} else while (1) {\n\t\t/* consume any zero-width characters (e.g. combining marks) */\n\t\tlast_idx = idx;\n\t\tu = u_get_char(str, &idx);\n\t\tif (u_char_width(u) != 0) {\n\t\t\tidx = last_idx;\n\t\t\tbreak;\n\t\t}\n\t}\n\t*width = w;\n\treturn idx;\n}\n\n/*\n * Case-folding functions\n */\n\nstatic inline uchar u_casefold_char(uchar ch)\n{\n\t/* faster lookup for for A-Z, rest of ASCII unaffected */\n\tif (ch < 0x0041)\n\t\treturn ch;\n\tif (ch <= 0x005A)\n\t\treturn ch + 0x20;\n#if defined(_WIN32) || defined(__STDC_ISO_10646__) || defined(__APPLE__)\n\tif (ch < 128)\n\t\treturn ch;\n\tch = towlower(ch);\n#endif\n\treturn ch;\n}\n\nchar *u_casefold(const char *str)\n{\n\tGBUF(out);\n\tint i = 0;\n\n\twhile (str[i]) {\n\t\tchar buf[4];\n\t\tint buflen = 0;\n\t\tuchar ch = u_get_char(str, &i);\n\n\t\tch = u_casefold_char(ch);\n\t\tu_set_char_raw(buf, &buflen, ch);\n\t\tgbuf_add_bytes(&out, buf, buflen);\n\t}\n\n\treturn gbuf_steal(&out);\n}\n\n/*\n * Comparison functions\n */\n\nint u_strcase_equal(const char *a, const char *b)\n{\n\tint ai = 0, bi = 0;\n\n\twhile (a[ai]) {\n\t\tuchar au, bu;\n\n\t\tau = u_get_char(a, &ai);\n\t\tbu = u_get_char(b, &bi);\n\n\t\tif (u_casefold_char(au) != u_casefold_char(bu))\n\t\t\treturn 0;\n\t}\n\n\treturn b[bi] ? 0 : 1;\n}\n\nstatic uchar get_base_from_composed(uchar ch)\n{\n\tint begin = 0;\n\tint end = N_ELEMENTS(unidecomp_map);\n\n\tif (ch < unidecomp_map[begin].composed || ch > unidecomp_map[end - 1].composed)\n\t\treturn ch;\n\n\t/* binary search */\n\twhile (1) {\n\t\tint half = (begin + end) / 2;\n\t\tif (ch == unidecomp_map[half].composed)\n\t\t\treturn unidecomp_map[half].base;\n\t\telse if (half == begin)\n\t\t\tbreak;\n\t\telse if (ch > unidecomp_map[half].composed)\n\t\t\tbegin = half;\n\t\telse\n\t\t\tend = half;\n\t}\n\treturn ch;\n}\n\nstatic inline int do_u_strncase_equal(const char *a, const char *b, size_t len, int only_base_chars)\n{\n\tint ai = 0, bi = 0;\n\tsize_t i;\n\n\tfor (i = 0; i < len; i++) {\n\t\tuchar au, bu;\n\n\t\tau = u_get_char(a, &ai);\n\t\tbu = u_get_char(b, &bi);\n\n\t\tif (only_base_chars) {\n\t\t\tau = get_base_from_composed(au);\n\t\t\tbu = get_base_from_composed(bu);\n\t\t}\n\n\t\tif (u_casefold_char(au) != u_casefold_char(bu))\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nint u_strncase_equal(const char *a, const char *b, size_t len)\n{\n\treturn do_u_strncase_equal(a, b, len, 0);\n}\n\nint u_strncase_equal_base(const char *a, const char *b, size_t len)\n{\n\treturn do_u_strncase_equal(a, b, len, 1);\n}\n\nstatic inline char *do_u_strcasestr(const char *haystack, const char *needle, int only_base_chars)\n{\n\t/* strlen is faster and works here */\n\tint haystack_len = strlen(haystack);\n\tint needle_len = u_strlen(needle);\n\n\tdo {\n\t\tint idx;\n\n\t\tif (haystack_len < needle_len)\n\t\t\treturn NULL;\n\t\tif (do_u_strncase_equal(needle, haystack, needle_len, only_base_chars))\n\t\t\treturn (char *)haystack;\n\n\t\t/* skip one char */\n\t\tidx = 0;\n\t\tu_get_char(haystack, &idx);\n\t\thaystack += idx;\n\t\thaystack_len -= idx;\n\t} while (1);\n}\n\nchar *u_strcasestr(const char *haystack, const char *needle)\n{\n\treturn do_u_strcasestr(haystack, needle, 0);\n}\n\nchar *u_strcasestr_base(const char *haystack, const char *needle)\n{\n\treturn do_u_strcasestr(haystack, needle, 1);\n}\n\nchar *u_strcasestr_filename(const char *haystack, const char *needle)\n{\n\tchar *r = NULL, *ustr = NULL;\n\tif (!using_utf8 && utf8_encode(haystack, charset, &ustr) == 0)\n\t\thaystack = ustr;\n\tr = u_strcasestr_base(haystack, needle);\n\tfree(ustr);\n\treturn r;\n}\n"
        },
        {
          "name": "uchar.h",
          "type": "blob",
          "size": 6.94921875,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004-2005 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_UCHAR_H\n#define CMUS_UCHAR_H\n\n#include <stddef.h> /* size_t */\n#include <stdbool.h>\n\ntypedef unsigned int uchar;\n\nextern const char hex_tab[16];\n\n/*\n * Invalid bytes are or'ed with this\n * for example 0xff -> 0x100000ff\n */\n#define U_INVALID_MASK 0x10000000U\n\n/*\n * @uch  potential unicode character\n *\n * Returns 1 if @uch is valid unicode character, 0 otherwise\n */\nstatic inline int u_is_unicode(uchar uch)\n{\n\treturn uch <= 0x0010ffffU;\n}\n\n/*\n * Returns size of @uch in bytes\n */\nstatic inline int u_char_size(uchar uch)\n{\n\tif (uch <= 0x0000007fU) {\n\t\treturn 1;\n\t} else if (uch <= 0x000007ffU) {\n\t\treturn 2;\n\t} else if (uch <= 0x0000ffffU) {\n\t\treturn 3;\n\t} else if (uch <= 0x0010ffffU) {\n\t\treturn 4;\n\t} else {\n\t\treturn 1;\n\t}\n}\n\n/*\n * Returns width of @uch (normally 1 or 2, 4 for invalid chars (<xx>))\n */\nint u_char_width(uchar uch);\n\n/*\n * @str  any null-terminated string\n *\n * Returns 1 if @str is valid UTF-8 string, 0 otherwise.\n */\nint u_is_valid(const char *str);\n\n/*\n * @str  valid, null-terminated UTF-8 string\n *\n * Returns position of next unicode character in @str.\n */\nextern const char * const utf8_skip;\nstatic inline char *u_next_char(const char *str)\n{\n\treturn (char *) (str + utf8_skip[*((const unsigned char *) str)]);\n}\n\n/*\n * @str  valid, null-terminated UTF-8 string\n *\n * Retuns length of @str in UTF-8 characters.\n */\nsize_t u_strlen(const char *str);\n\n/*\n * @str  null-terminated UTF-8 string\n *\n * Retuns length of @str in UTF-8 characters.\n * Invalid chars are counted as single characters.\n */\nsize_t u_strlen_safe(const char *str);\n\n/*\n * @str  null-terminated UTF-8 string\n *\n * Retuns width of @str.\n */\nint u_str_width(const char *str);\n\n/*\n * @uch  unicode character\n *\n * Retuns size of @uch if it were printed.\n */\nint u_print_size(uchar uch);\n\n/*\n * @str  null-terminated UTF-8 string\n *\n * Retuns size of @str if it were printed.\n */\nint u_str_print_size(const char *str);\n\n/*\n * @str  null-terminated UTF-8 string\n * @len  number of characters to measure\n *\n * Retuns width of the first @len characters in @str.\n */\nint u_str_nwidth(const char *str, int len);\n\n/*\n * @str  null-terminated UTF-8 string\n * @uch  unicode character\n *\n * Returns a pointer to the first occurrence of @uch in the @str.\n */\nchar *u_strchr(const char *str, uchar uch);\n\nvoid u_prev_char_pos(const char *str, int *idx);\n\n/*\n * @str  null-terminated UTF-8 string\n * @idx  pointer to byte index in @str (not UTF-8 character index!) or NULL\n *\n * Returns unicode character at @str[*@idx] or @str[0] if @idx is NULL.\n * Stores byte index of the next char back to @idx if set.\n */\nuchar u_get_char(const char *str, int *idx);\n\n/*\n * @str  destination buffer\n * @idx  pointer to byte index in @str (not UTF-8 character index!)\n * @uch  unicode character\n */\nvoid u_set_char_raw(char *str, int *idx, uchar uch);\nvoid u_set_char(char *str, size_t *idx, uchar uch);\n\n/*\n * @dst    destination buffer\n * @src    null-terminated UTF-8 string\n * @width  how much to copy (at most)\n *\n * Copies at most @width columns, less if null byte was hit.\n * Null byte is _never_ copied.\n * Remaining width is stored to @width.\n *\n * Returns number of _bytes_ copied.\n */\nsize_t u_copy_chars(char *dst, const char *src, int *width);\n\n/*\n * @dst    destination buffer\n * @src    null-terminated UTF-8 string\n * @len    how many bytes are available in @dst\n *\n * Copies at most @len bytes, less if null byte was hit. Replaces every\n * non-ascii character by '?'. Null byte is _never_ copied.\n *\n * Returns number of bytes written to @dst.\n */\nint u_to_ascii(char *dst, const char *src, int len);\n\n/*\n * @dst    destination buffer\n * @src    null-terminated string\n *\n * Copies src into dst, changing all invalid utf8 bytes into <xx>,\n * where xx is the value of the byte in hex.\n *\n * Expects dst to be large enough to fit src + the conversions.\n */\nvoid u_to_utf8(char *dst, const char *src);\n\n/*\n * @str    null-terminated UTF-8 string, must be long enough\n * @width  how much to skip\n * @overskip skip a final wide character even when it overshoots @width\n *\n * Skips @width columns in a UTF-8 string.\n * Underskip (positive) or overskip (negative) is stored to @width.\n *\n * Returns number of _bytes_ skipped.\n */\nint u_skip_chars(const char *str, int *width, bool overskip);\n\n/*\n * @str  valid null-terminated UTF-8 string\n *\n * Converts a string into a form that is independent of case.\n *\n * Returns a newly allocated string\n */\nchar *u_casefold(const char *str);\n\n/*\n * @str1  valid, normalized, null-terminated UTF-8 string\n * @str2  valid, normalized, null-terminated UTF-8 string\n *\n * Returns 1 if @str1 is equal to @str2, ignoring the case of the characters.\n */\nint u_strcase_equal(const char *str1, const char *str2);\n\n/*\n * @str1    valid, normalized, null-terminated UTF-8 string\n * @str2    valid, normalized, null-terminated UTF-8 string\n * @len  number of characters to consider for comparison\n *\n * Returns 1 if the first @len characters of @str1 and @str2 are equal,\n * ignoring the case of the characters (0 otherwise).\n */\nint u_strncase_equal(const char *str1, const char *str2, size_t len);\n\n/*\n * @str1    valid, normalized, null-terminated UTF-8 string\n * @str2    valid, normalized, null-terminated UTF-8 string\n * @len  number of characters to consider for comparison\n *\n * Like u_strncase_equal(), but uses only base characters for comparison\n * (e.g. \"Trentemöller\" matches \"Trentemøller\")\n */\nint u_strncase_equal_base(const char *str1, const char *str2, size_t len);\n\n/*\n * @haystack  valid, normalized, null-terminated UTF-8 string\n * @needle    valid, normalized, null-terminated UTF-8 string\n *\n * Returns position of @needle in @haystack (case insensitive comparison).\n */\nchar *u_strcasestr(const char *haystack, const char *needle);\n\n/*\n * @haystack  valid, normalized, null-terminated UTF-8 string\n * @needle    valid, normalized, null-terminated UTF-8 string\n *\n * Like u_strcasestr(), but uses only base characters for comparison\n * (e.g. \"Trentemöller\" matches \"Trentemøller\")\n */\nchar *u_strcasestr_base(const char *haystack, const char *needle);\n\n/*\n * @haystack  null-terminated string in local encoding\n * @needle    valid, normalized, null-terminated UTF-8 string\n *\n * Like u_strcasestr_base(), but converts @haystack to UTF-8 if necessary.\n */\nchar *u_strcasestr_filename(const char *haystack, const char *needle);\n\n#endif\n"
        },
        {
          "name": "ui_curses.c",
          "type": "blob",
          "size": 59.3203125,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004-2005 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"job.h\"\n#include \"convert.h\"\n#include \"ui_curses.h\"\n#include \"cmdline.h\"\n#include \"search_mode.h\"\n#include \"command_mode.h\"\n#include \"options.h\"\n#include \"play_queue.h\"\n#include \"browser.h\"\n#include \"filters.h\"\n#include \"cmus.h\"\n#include \"player.h\"\n#include \"output.h\"\n#include \"utils.h\"\n#include \"lib.h\"\n#include \"pl.h\"\n#include \"xmalloc.h\"\n#include \"xstrjoin.h\"\n#include \"window.h\"\n#include \"comment.h\"\n#include \"misc.h\"\n#include \"prog.h\"\n#include \"uchar.h\"\n#include \"spawn.h\"\n#include \"server.h\"\n#include \"keys.h\"\n#include \"debug.h\"\n#include \"help.h\"\n#include \"worker.h\"\n#include \"input.h\"\n#include \"file.h\"\n#include \"path.h\"\n#include \"mixer.h\"\n#include \"mpris.h\"\n#include \"locking.h\"\n#include \"pl_env.h\"\n#ifdef HAVE_CONFIG\n#include \"config/curses.h\"\n#include \"config/iconv.h\"\n#endif\n\n#include <unistd.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <sys/ioctl.h>\n#include <sys/select.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <locale.h>\n#include <langinfo.h>\n#ifdef HAVE_ICONV\n#include <iconv.h>\n#endif\n#include <signal.h>\n#include <stdarg.h>\n#include <math.h>\n#include <sys/time.h>\n\n#if defined(__sun__) || defined(__CYGWIN__)\n/* TIOCGWINSZ */\n#include <termios.h>\n#include <ncurses.h>\n#else\n#include <curses.h>\n#endif\n\n/* defined in <term.h> but without const */\nchar *tgetstr(const char *id, char **area);\nchar *tgoto(const char *cap, int col, int row);\n\n/* globals. documented in ui_curses.h */\n\nvolatile sig_atomic_t cmus_running = 1;\nint ui_initialized = 0;\nenum ui_input_mode input_mode = NORMAL_MODE;\nint cur_view = TREE_VIEW;\nint prev_view = -1;\nstruct searchable *searchable;\nchar *lib_filename = NULL;\nchar *lib_ext_filename = NULL;\nchar *play_queue_filename = NULL;\nchar *play_queue_ext_filename = NULL;\nchar *charset = NULL;\nint using_utf8 = 0;\n\n/* ------------------------------------------------------------------------- */\n\nstatic char *lib_autosave_filename;\nstatic char *play_queue_autosave_filename;\n\nstatic GBUF(print_buffer);\n\n/* destination buffer for utf8_encode_to_buf and utf8_decode */\nstatic char conv_buffer[4096];\n\n/* shown error message and time stamp\n * error is cleared if it is older than 3s and key was pressed\n */\nstatic GBUF(error_buf);\nstatic time_t error_time = 0;\n/* info messages are displayed in different color */\nstatic int msg_is_error;\nstatic int error_count = 0;\n\nstatic char *server_address = NULL;\n\n/* used for messages to the client */\nstatic int client_fd = -1;\n\nstatic char tcap_buffer[64];\nstatic const char *t_ts;\nstatic const char *t_fs;\n\nstatic int tree_win_x = 0;\nstatic int tree_win_w = 0;\n\nstatic int track_win_x = 0;\nstatic int track_win_w = 0;\n\nstatic int win_x = 0;\nstatic int win_w = 0;\nstatic int win_active = 1;\n\nstatic int show_cursor;\nstatic int cursor_x;\nstatic int cursor_y;\nstatic int cmdline_cursor_x;\n\nstatic const int default_esc_delay = 25;\n\nstatic char *title_buf = NULL;\n\nstatic int in_bracketed_paste = 0;\n\nenum {\n\tCURSED_WIN,\n\tCURSED_WIN_CUR,\n\tCURSED_WIN_SEL,\n\tCURSED_WIN_SEL_CUR,\n\n\tCURSED_WIN_ACTIVE,\n\tCURSED_WIN_ACTIVE_CUR,\n\tCURSED_WIN_ACTIVE_SEL,\n\tCURSED_WIN_ACTIVE_SEL_CUR,\n\n\tCURSED_SEPARATOR,\n\tCURSED_WIN_TITLE,\n\tCURSED_COMMANDLINE,\n\tCURSED_STATUSLINE,\n\n\tCURSED_STATUSLINE_PROGRESS,\n\tCURSED_TITLELINE,\n\tCURSED_DIR,\n\tCURSED_ERROR,\n\n\tCURSED_INFO,\n\tCURSED_TRACKWIN_ALBUM,\n\n\tNR_CURSED\n};\n\nstatic unsigned char cursed_to_bg_idx[NR_CURSED] = {\n\tCOLOR_WIN_BG,\n\tCOLOR_WIN_BG,\n\tCOLOR_WIN_INACTIVE_SEL_BG,\n\tCOLOR_WIN_INACTIVE_CUR_SEL_BG,\n\n\tCOLOR_WIN_BG,\n\tCOLOR_WIN_BG,\n\tCOLOR_WIN_SEL_BG,\n\tCOLOR_WIN_CUR_SEL_BG,\n\n\tCOLOR_WIN_BG,\n\tCOLOR_WIN_TITLE_BG,\n\tCOLOR_CMDLINE_BG,\n\tCOLOR_STATUSLINE_BG,\n\n\tCOLOR_STATUSLINE_PROGRESS_BG,\n\tCOLOR_TITLELINE_BG,\n\tCOLOR_WIN_BG,\n\tCOLOR_CMDLINE_BG,\n\n\tCOLOR_CMDLINE_BG,\n\tCOLOR_TRACKWIN_ALBUM_BG,\n};\n\nstatic unsigned char cursed_to_fg_idx[NR_CURSED] = {\n\tCOLOR_WIN_FG,\n\tCOLOR_WIN_CUR,\n\tCOLOR_WIN_INACTIVE_SEL_FG,\n\tCOLOR_WIN_INACTIVE_CUR_SEL_FG,\n\n\tCOLOR_WIN_FG,\n\tCOLOR_WIN_CUR,\n\tCOLOR_WIN_SEL_FG,\n\tCOLOR_WIN_CUR_SEL_FG,\n\n\tCOLOR_SEPARATOR,\n\tCOLOR_WIN_TITLE_FG,\n\tCOLOR_CMDLINE_FG,\n\tCOLOR_STATUSLINE_FG,\n\n\tCOLOR_STATUSLINE_PROGRESS_FG,\n\tCOLOR_TITLELINE_FG,\n\tCOLOR_WIN_DIR,\n\tCOLOR_ERROR,\n\n\tCOLOR_INFO,\n\tCOLOR_TRACKWIN_ALBUM_FG,\n};\n\nstatic unsigned char cursed_to_attr_idx[NR_CURSED] = {\n\tCOLOR_WIN_ATTR,\n\tCOLOR_WIN_CUR_ATTR,\n\tCOLOR_WIN_INACTIVE_SEL_ATTR,\n\tCOLOR_WIN_INACTIVE_CUR_SEL_ATTR,\n\n\tCOLOR_WIN_ATTR,\n\tCOLOR_WIN_CUR_ATTR,\n\tCOLOR_WIN_SEL_ATTR,\n\tCOLOR_WIN_CUR_SEL_ATTR,\n\n\tCOLOR_WIN_ATTR,\n\tCOLOR_WIN_TITLE_ATTR,\n\tCOLOR_CMDLINE_ATTR,\n\tCOLOR_STATUSLINE_ATTR,\n\n\tCOLOR_STATUSLINE_PROGRESS_ATTR,\n\tCOLOR_TITLELINE_ATTR,\n\tCOLOR_WIN_ATTR,\n\tCOLOR_CMDLINE_ATTR,\n\n\tCOLOR_CMDLINE_ATTR,\n\tCOLOR_TRACKWIN_ALBUM_ATTR,\n};\n\n/* index is CURSED_*, value is fucking color pair */\nstatic int pairs[NR_CURSED];\n\nenum {\n\tTF_ALBUMARTIST,\n\tTF_ARTIST,\n\tTF_ALBUM,\n\tTF_DISC,\n\tTF_TOTAL_DISCS,\n\tTF_TRACK,\n\tTF_TITLE,\n\tTF_PLAY_COUNT,\n\tTF_YEAR,\n\tTF_MAX_YEAR,\n\tTF_ORIGINALYEAR,\n\tTF_GENRE,\n\tTF_COMMENT,\n\tTF_DURATION,\n\tTF_DURATION_SEC,\n\tTF_ALBUMDURATION,\n\tTF_BITRATE,\n\tTF_CODEC,\n\tTF_CODEC_PROFILE,\n\tTF_PATHFILE,\n\tTF_FILE,\n\tTF_RG_TRACK_GAIN,\n\tTF_RG_TRACK_PEAK,\n\tTF_RG_ALBUM_GAIN,\n\tTF_RG_ALBUM_PEAK,\n\tTF_ARRANGER,\n\tTF_COMPOSER,\n\tTF_CONDUCTOR,\n\tTF_LYRICIST,\n\tTF_PERFORMER,\n\tTF_REMIXER,\n\tTF_LABEL,\n\tTF_PUBLISHER,\n\tTF_WORK,\n\tTF_OPUS,\n\tTF_PARTNUMBER,\n\tTF_PART,\n\tTF_SUBTITLE,\n\tTF_MEDIA,\n\tTF_VA,\n\tTF_STATUS,\n\tTF_POSITION,\n\tTF_POSITION_SEC,\n\tTF_TOTAL,\n\tTF_VOLUME,\n\tTF_LVOLUME,\n\tTF_RVOLUME,\n\tTF_BUFFER,\n\tTF_REPEAT,\n\tTF_CONTINUE,\n\tTF_FOLLOW,\n\tTF_SHUFFLE,\n\tTF_PLAYLISTMODE,\n\tTF_BPM,\n\tTF_PANEL,\n\n\tNR_TFS\n};\n\nstatic struct format_option track_fopts[NR_TFS + 1] = {\n\tDEF_FO_STR('A', \"albumartist\", 0),\n\tDEF_FO_STR('a', \"artist\", 0),\n\tDEF_FO_STR('l', \"album\", 0),\n\tDEF_FO_INT('D', \"discnumber\", 1),\n\tDEF_FO_INT('T', \"totaldiscs\", 1),\n\tDEF_FO_INT('n', \"tracknumber\", 1),\n\tDEF_FO_STR('t', \"title\", 0),\n\tDEF_FO_INT('X', \"play_count\", 0),\n\tDEF_FO_INT('y', \"date\", 1),\n\tDEF_FO_INT('\\0', \"maxdate\", 1),\n\tDEF_FO_INT('\\0', \"originaldate\", 1),\n\tDEF_FO_STR('g', \"genre\", 0),\n\tDEF_FO_STR('c', \"comment\", 0),\n\tDEF_FO_TIME('d', \"duration\", 0),\n\tDEF_FO_INT('\\0', \"duration_sec\", 1),\n\tDEF_FO_TIME('\\0', \"albumduration\", 0),\n\tDEF_FO_INT('\\0', \"bitrate\", 0),\n\tDEF_FO_STR('\\0', \"codec\", 0),\n\tDEF_FO_STR('\\0', \"codec_profile\", 0),\n\tDEF_FO_STR('f', \"path\", 0),\n\tDEF_FO_STR('F', \"filename\", 0),\n\tDEF_FO_DOUBLE('\\0', \"rg_track_gain\", 0),\n\tDEF_FO_DOUBLE('\\0', \"rg_track_peak\", 0),\n\tDEF_FO_DOUBLE('\\0', \"rg_album_gain\", 0),\n\tDEF_FO_DOUBLE('\\0', \"rg_album_peak\", 0),\n\tDEF_FO_STR('\\0', \"arranger\", 0),\n\tDEF_FO_STR('\\0', \"composer\", 0),\n\tDEF_FO_STR('\\0', \"conductor\", 0),\n\tDEF_FO_STR('\\0', \"lyricist\", 0),\n\tDEF_FO_STR('\\0', \"performer\", 0),\n\tDEF_FO_STR('\\0', \"remixer\", 0),\n\tDEF_FO_STR('\\0', \"label\", 0),\n\tDEF_FO_STR('\\0', \"publisher\", 0),\n\tDEF_FO_STR('\\0', \"work\", 0),\n\tDEF_FO_STR('\\0', \"opus\", 0),\n\tDEF_FO_STR('\\0', \"partnumber\", 0),\n\tDEF_FO_STR('\\0', \"part\", 0),\n\tDEF_FO_STR('\\0', \"subtitle\", 0),\n\tDEF_FO_STR('\\0', \"media\", 0),\n\tDEF_FO_INT('\\0', \"va\", 0),\n\tDEF_FO_STR('\\0', \"status\", 0),\n\tDEF_FO_TIME('\\0', \"position\", 0),\n\tDEF_FO_INT('\\0', \"position_sec\", 1),\n\tDEF_FO_TIME('\\0', \"total\", 0),\n\tDEF_FO_INT('\\0', \"volume\", 1),\n\tDEF_FO_INT('\\0', \"lvolume\", 1),\n\tDEF_FO_INT('\\0', \"rvolume\", 1),\n\tDEF_FO_INT('\\0', \"buffer\", 1),\n\tDEF_FO_STR('\\0', \"repeat\", 0),\n\tDEF_FO_STR('\\0', \"continue\", 0),\n\tDEF_FO_STR('\\0', \"follow\", 0),\n\tDEF_FO_STR('\\0', \"shuffle\", 0),\n\tDEF_FO_STR('\\0', \"playlist_mode\", 0),\n\tDEF_FO_INT('\\0', \"bpm\", 0),\n\tDEF_FO_INT('\\0', \"panel\", 0),\n\tDEF_FO_END\n};\n\nint get_track_win_x(void)\n{\n\treturn track_win_x;\n}\n\nint track_format_valid(const char *format)\n{\n\treturn format_valid(format, track_fopts);\n}\n\nstatic void utf8_encode_to_buf(const char *buffer)\n{\n\tint n;\n#ifdef HAVE_ICONV\n\tstatic iconv_t cd = (iconv_t)-1;\n\tsize_t is, os;\n\tconst char *i;\n\tchar *o;\n\tint rc;\n\n\tif (cd == (iconv_t)-1) {\n\t\td_print(\"iconv_open(UTF-8, %s)\\n\", charset);\n\t\tcd = iconv_open(\"UTF-8\", charset);\n\t\tif (cd == (iconv_t)-1) {\n\t\t\td_print(\"iconv_open failed: %s\\n\", strerror(errno));\n\t\t\tgoto fallback;\n\t\t}\n\t}\n\ti = buffer;\n\to = conv_buffer;\n\tis = strlen(i);\n\tos = sizeof(conv_buffer) - 1;\n\trc = iconv(cd, (void *)&i, &is, &o, &os);\n\t*o = 0;\n\tif (rc == -1) {\n\t\td_print(\"iconv failed: %s\\n\", strerror(errno));\n\t\tgoto fallback;\n\t}\n\treturn;\nfallback:\n#endif\n\tn = min_i(sizeof(conv_buffer) - 1, strlen(buffer));\n\tmemmove(conv_buffer, buffer, n);\n\tconv_buffer[n] = '\\0';\n}\n\nstatic void utf8_decode(const char *buffer)\n{\n\tint n;\n#ifdef HAVE_ICONV\n\tstatic iconv_t cd = (iconv_t)-1;\n\tsize_t is, os;\n\tconst char *i;\n\tchar *o;\n\tint rc;\n\n\tif (cd == (iconv_t)-1) {\n\t\td_print(\"iconv_open(%s, UTF-8)\\n\", charset);\n\t\tcd = iconv_open(charset, \"UTF-8\");\n\t\tif (cd == (iconv_t)-1) {\n\t\t\td_print(\"iconv_open failed: %s\\n\", strerror(errno));\n\t\t\tgoto fallback;\n\t\t}\n\t}\n\ti = buffer;\n\to = conv_buffer;\n\tis = strlen(i);\n\tos = sizeof(conv_buffer) - 1;\n\trc = iconv(cd, (void *)&i, &is, &o, &os);\n\t*o = 0;\n\tif (rc == -1) {\n\t\td_print(\"iconv failed: %s\\n\", strerror(errno));\n\t\tgoto fallback;\n\t}\n\treturn;\nfallback:\n#endif\n\tn = u_to_ascii(conv_buffer, buffer, sizeof(conv_buffer) - 1);\n\tconv_buffer[n] = '\\0';\n}\n\n/* screen updates {{{ */\n\nstatic void dump_print_buffer_no_clear(int row, int col, size_t offset)\n{\n\tif (using_utf8) {\n\t\t(void) mvaddstr(row, col, print_buffer.buffer + offset);\n\t} else {\n\t\tutf8_decode(print_buffer.buffer + offset);\n\t\t(void) mvaddstr(row, col, conv_buffer);\n\t}\n}\n\nstatic void dump_print_buffer(int row, int col)\n{\n\tdump_print_buffer_no_clear(row, col, 0);\n\tgbuf_clear(&print_buffer);\n}\n\n/* print @str into @buf\n *\n * if @str is shorter than @width pad with spaces\n * if @str is wider than @width truncate and add \"...\"\n */\nstatic void format_str(struct gbuf *buf, const char *str, int width)\n{\n\tgbuf_add_ustr(buf, str, &width);\n\tgbuf_set(buf, ' ', width);\n}\n\nstatic void sprint(int row, int col, const char *str, int width)\n{\n\tgbuf_add_ch(&print_buffer, ' ');\n\tformat_str(&print_buffer, str, width - 2);\n\tgbuf_add_ch(&print_buffer, ' ');\n\tdump_print_buffer(row, col);\n}\n\nstatic inline void fopt_set_str(struct format_option *fopt, const char *str)\n{\n\tBUG_ON(fopt->type != FO_STR);\n\tif (str) {\n\t\tfopt->fo_str = str;\n\t\tfopt->empty = 0;\n\t} else {\n\t\tfopt->empty = 1;\n\t}\n}\n\nstatic inline void fopt_set_int(struct format_option *fopt, int value, int empty)\n{\n\tBUG_ON(fopt->type != FO_INT);\n\tfopt->fo_int = value;\n\tfopt->empty = empty;\n}\n\nstatic inline void fopt_set_double(struct format_option *fopt, double value, int empty)\n{\n\tBUG_ON(fopt->type != FO_DOUBLE);\n\tfopt->fo_double = value;\n\tfopt->empty = empty;\n}\n\nstatic inline void fopt_set_time(struct format_option *fopt, int value, int empty)\n{\n\tBUG_ON(fopt->type != FO_TIME);\n\tfopt->fo_time = value;\n\tfopt->empty = empty;\n}\n\nstatic void fill_track_fopts_track_info(struct track_info *info)\n{\n\tchar *filename;\n\n\tif (using_utf8) {\n\t\tfilename = info->filename;\n\t} else {\n\t\tutf8_encode_to_buf(info->filename);\n\t\tfilename = conv_buffer;\n\t}\n\n\tfopt_set_str(&track_fopts[TF_ALBUMARTIST], info->albumartist);\n\tfopt_set_str(&track_fopts[TF_ARTIST], info->artist);\n\tfopt_set_str(&track_fopts[TF_ALBUM], info->album);\n\tfopt_set_int(&track_fopts[TF_PLAY_COUNT], info->play_count, 0);\n\tfopt_set_int(&track_fopts[TF_DISC], info->discnumber, info->discnumber == -1);\n\tfopt_set_int(&track_fopts[TF_TOTAL_DISCS], info->totaldiscs, info->totaldiscs == -1);\n\tfopt_set_int(&track_fopts[TF_TRACK], info->tracknumber, info->tracknumber == -1);\n\tfopt_set_str(&track_fopts[TF_TITLE], info->title);\n\tfopt_set_int(&track_fopts[TF_YEAR], info->date / 10000, info->date <= 0);\n\tfopt_set_str(&track_fopts[TF_GENRE], info->genre);\n\tfopt_set_str(&track_fopts[TF_COMMENT], info->comment);\n\tfopt_set_time(&track_fopts[TF_DURATION], info->duration, info->duration == -1);\n\tfopt_set_int(&track_fopts[TF_DURATION_SEC], info->duration, info->duration == -1);\n\tfopt_set_double(&track_fopts[TF_RG_TRACK_GAIN], info->rg_track_gain, isnan(info->rg_track_gain));\n\tfopt_set_double(&track_fopts[TF_RG_TRACK_PEAK], info->rg_track_peak, isnan(info->rg_track_peak));\n\tfopt_set_double(&track_fopts[TF_RG_ALBUM_GAIN], info->rg_album_gain, isnan(info->rg_album_gain));\n\tfopt_set_double(&track_fopts[TF_RG_ALBUM_PEAK], info->rg_album_peak, isnan(info->rg_album_peak));\n\tfopt_set_int(&track_fopts[TF_ORIGINALYEAR], info->originaldate / 10000, info->originaldate <= 0);\n\tfopt_set_int(&track_fopts[TF_BITRATE], (int) (info->bitrate / 1000. + 0.5), info->bitrate == -1);\n\tfopt_set_str(&track_fopts[TF_CODEC], info->codec);\n\tfopt_set_str(&track_fopts[TF_CODEC_PROFILE], info->codec_profile);\n\tfopt_set_str(&track_fopts[TF_PATHFILE], filename);\n\tfopt_set_str(&track_fopts[TF_ARRANGER], keyvals_get_val(info->comments, \"arranger\"));\n\tfopt_set_str(&track_fopts[TF_COMPOSER], keyvals_get_val(info->comments, \"composer\"));\n\tfopt_set_str(&track_fopts[TF_CONDUCTOR], keyvals_get_val(info->comments, \"conductor\"));\n\tfopt_set_str(&track_fopts[TF_LYRICIST], keyvals_get_val(info->comments, \"lyricist\"));\n\tfopt_set_str(&track_fopts[TF_PERFORMER], keyvals_get_val(info->comments, \"performer\"));\n\tfopt_set_str(&track_fopts[TF_REMIXER], keyvals_get_val(info->comments, \"remixer\"));\n\tfopt_set_str(&track_fopts[TF_LABEL], keyvals_get_val(info->comments, \"label\"));\n\tfopt_set_str(&track_fopts[TF_PUBLISHER], keyvals_get_val(info->comments, \"publisher\"));\n\tfopt_set_str(&track_fopts[TF_WORK], keyvals_get_val(info->comments, \"work\"));\n\tfopt_set_str(&track_fopts[TF_OPUS], keyvals_get_val(info->comments, \"opus\"));\n\tfopt_set_str(&track_fopts[TF_PARTNUMBER], keyvals_get_val(info->comments, \"discnumber\"));\n\tfopt_set_str(&track_fopts[TF_PART], keyvals_get_val(info->comments, \"discnumber\"));\n\tfopt_set_str(&track_fopts[TF_SUBTITLE], keyvals_get_val(info->comments, \"subtitle\"));\n\tfopt_set_str(&track_fopts[TF_MEDIA], info->media);\n\tfopt_set_int(&track_fopts[TF_VA], 0, !track_is_compilation(info->comments));\n\tif (is_http_url(info->filename)) {\n\t\tfopt_set_str(&track_fopts[TF_FILE], filename);\n\t} else {\n\t\tfopt_set_str(&track_fopts[TF_FILE], path_basename(filename));\n\t}\n\tfopt_set_int(&track_fopts[TF_BPM], info->bpm, info->bpm == -1);\n}\n\nstatic int get_album_length(struct album *album)\n{\n\tstruct tree_track *track;\n\tstruct rb_node *tmp;\n\tint duration = 0;\n\n\trb_for_each_entry(track, tmp, &album->track_root, tree_node) {\n\t\tduration += max_i(0, tree_track_info(track)->duration);\n\t}\n\n\treturn duration;\n}\n\nstatic int get_artist_length(struct artist *artist)\n{\n\tstruct album *album;\n\tstruct rb_node *tmp;\n\tint duration = 0;\n\n\trb_for_each_entry(album, tmp, &artist->album_root, tree_node) {\n\t\tduration += get_album_length(album);\n\t}\n\n\treturn duration;\n}\n\nstatic void fill_track_fopts_album(struct album *album)\n{\n\tfopt_set_int(&track_fopts[TF_YEAR], album->min_date / 10000, album->min_date <= 0);\n\tfopt_set_int(&track_fopts[TF_MAX_YEAR], album->date / 10000, album->date <= 0);\n\tfopt_set_str(&track_fopts[TF_ALBUMARTIST], album->artist->name);\n\tfopt_set_str(&track_fopts[TF_ARTIST], album->artist->name);\n\tfopt_set_str(&track_fopts[TF_ALBUM], album->name);\n\tint duration = get_album_length(album);\n\tfopt_set_time(&track_fopts[TF_DURATION], duration, 0);\n\tfopt_set_time(&track_fopts[TF_ALBUMDURATION], duration, 0);\n}\n\nstatic void fill_track_fopts_artist(struct artist *artist)\n{\n\tconst char *name = display_artist_sort_name ? artist_sort_name(artist) : artist->name;\n\tfopt_set_str(&track_fopts[TF_ARTIST], name);\n\tfopt_set_str(&track_fopts[TF_ALBUMARTIST], name);\n\tfopt_set_time(&track_fopts[TF_DURATION], get_artist_length(artist), 0);\n}\n\nconst struct format_option *get_global_fopts(void)\n{\n\tif (player_info.ti)\n\t\tfill_track_fopts_track_info(player_info.ti);\n\n\tstatic const char *status_strs[] = { \".\", \">\", \"|\" };\n\tstatic const char *cont_strs[] = { \" \", \"C\" };\n\tstatic const char *follow_strs[] = { \" \", \"F\" };\n\tstatic const char *repeat_strs[] = { \" \", \"R\" };\n\tstatic const char *shuffle_strs[] = { \" \", \"S\", \"&\" };\n\tint buffer_fill, vol, vol_left, vol_right;\n\tint duration = -1;\n\n\tunsigned int total_time = pl_playing_total_time();\n\tif (cmus_queue_active())\n\t\ttotal_time = play_queue_total_time();\n\telse if (play_library)\n\t\ttotal_time = lib_editable.total_time;\n\tfopt_set_time(&track_fopts[TF_TOTAL], total_time, 0);\n\n\tfopt_set_str(&track_fopts[TF_FOLLOW], follow_strs[follow]);\n\tfopt_set_str(&track_fopts[TF_REPEAT], repeat_strs[repeat]);\n\tfopt_set_str(&track_fopts[TF_SHUFFLE], shuffle_strs[shuffle]);\n\tfopt_set_str(&track_fopts[TF_PLAYLISTMODE], aaa_mode_names[aaa_mode]);\n\n\tif (player_info.ti)\n\t\tduration = player_info.ti->duration;\n\n\tvol_left = vol_right = vol = -1;\n\tif (soft_vol) {\n\t\tvol_left = soft_vol_l;\n\t\tvol_right = soft_vol_r;\n\t\tvol = (vol_left + vol_right + 1) / 2;\n\t} else if (volume_max && volume_l >= 0 && volume_r >= 0) {\n\t\tvol_left = scale_to_percentage(volume_l, volume_max);\n\t\tvol_right = scale_to_percentage(volume_r, volume_max);\n\t\tvol = (vol_left + vol_right + 1) / 2;\n\t}\n\tbuffer_fill = scale_to_percentage(player_info.buffer_fill, player_info.buffer_size);\n\n\tfopt_set_str(&track_fopts[TF_STATUS], status_strs[player_info.status]);\n\n\tif (show_remaining_time && duration != -1) {\n\t\tfopt_set_time(&track_fopts[TF_POSITION], player_info.pos - duration, 0);\n\t} else {\n\t\tfopt_set_time(&track_fopts[TF_POSITION], player_info.pos, 0);\n\t}\n\n\tfopt_set_int(&track_fopts[TF_POSITION_SEC], player_info.pos, player_info.pos < 0);\n\tfopt_set_time(&track_fopts[TF_DURATION], duration, duration < 0);\n\tfopt_set_int(&track_fopts[TF_VOLUME], vol, vol < 0);\n\tfopt_set_int(&track_fopts[TF_LVOLUME], vol_left, vol_left < 0);\n\tfopt_set_int(&track_fopts[TF_RVOLUME], vol_right, vol_right < 0);\n\tfopt_set_int(&track_fopts[TF_BUFFER], buffer_fill, 0);\n\tfopt_set_str(&track_fopts[TF_CONTINUE], cont_strs[player_cont]);\n\tfopt_set_int(&track_fopts[TF_BITRATE], player_info.current_bitrate / 1000. + 0.5, 0);\n\n\treturn track_fopts;\n}\n\nstatic void print_tree(struct window *win, int row, struct iter *iter)\n{\n\tstruct artist *artist;\n\tstruct album *album;\n\tstruct iter sel;\n\tint current, selected, active;\n\n\tartist = iter_to_artist(iter);\n\talbum = iter_to_album(iter);\n\tcurrent = 0;\n\tif (lib_cur_track) {\n\t\tif (album) {\n\t\t\tcurrent = CUR_ALBUM == album;\n\t\t} else {\n\t\t\tcurrent = CUR_ARTIST == artist;\n\t\t}\n\t}\n\twindow_get_sel(win, &sel);\n\tselected = iters_equal(iter, &sel);\n\tactive = lib_cur_win == lib_tree_win;\n\tbkgdset(pairs[(active << 2) | (selected << 1) | current]);\n\n\tif (active && selected) {\n\t\tcursor_x = 0;\n\t\tcursor_y = 1 + row;\n\t}\n\n\tgbuf_add_ch(&print_buffer, ' ');\n\tif (album) {\n\t\tfill_track_fopts_album(album);\n\t\tformat_print(&print_buffer, tree_win_w - 1, tree_win_format, track_fopts);\n\t} else {\n\t\tfill_track_fopts_artist(artist);\n\t\tformat_print(&print_buffer, tree_win_w - 1, tree_win_artist_format, track_fopts);\n\t}\n\tdump_print_buffer(row + 1, tree_win_x);\n}\n\nstatic void print_track(struct window *win, int row, struct iter *iter)\n{\n\tstruct tree_track *track;\n\tstruct album *album;\n\tstruct track_info *ti;\n\tstruct iter sel;\n\tint current, selected, active;\n\tconst char *format;\n\n\ttrack = iter_to_tree_track(iter);\n\talbum = iter_to_album(iter);\n\n\tif (track == (struct tree_track*)album) {\n\t\tint pos;\n\t\tstruct fp_len len;\n\n\t\tbkgdset(pairs[CURSED_TRACKWIN_ALBUM]);\n\n\t\tfill_track_fopts_album(album);\n\n\t\tlen = format_print(&print_buffer, track_win_w, track_win_album_format, track_fopts);\n\t\tdump_print_buffer(row + 1, track_win_x);\n\n\t\tbkgdset(pairs[CURSED_SEPARATOR]);\n\t\tfor(pos = track_win_x + len.llen + len.mlen; pos < win_w - len.rlen; ++pos)\n\t\t\t(void) mvaddch(row + 1, pos, ACS_HLINE);\n\n\t\treturn;\n\t}\n\n\tcurrent = lib_cur_track == track;\n\twindow_get_sel(win, &sel);\n\tselected = iters_equal(iter, &sel);\n\tactive = lib_cur_win == lib_track_win;\n\tbkgdset(pairs[(active << 2) | (selected << 1) | current]);\n\n\tif (active && selected) {\n\t\tcursor_x = track_win_x;\n\t\tcursor_y = 1 + row;\n\t}\n\n\tti = tree_track_info(track);\n\tfill_track_fopts_track_info(ti);\n\n\tformat = track_win_format;\n\tif (track_info_has_tag(ti)) {\n\t\tif (*track_win_format_va && track_is_compilation(ti->comments))\n\t\t\tformat = track_win_format_va;\n\t} else if (*track_win_alt_format) {\n\t\tformat = track_win_alt_format;\n\t}\n\tformat_print(&print_buffer, track_win_w, format, track_fopts);\n\tdump_print_buffer(row + 1, track_win_x);\n}\n\n/* used by print_editable only */\nstatic struct simple_track *current_track;\n\nstatic void print_editable(struct window *win, int row, struct iter *iter)\n{\n\tstruct simple_track *track;\n\tstruct iter sel;\n\tint current, selected, active;\n\tconst char *format;\n\n\ttrack = iter_to_simple_track(iter);\n\tcurrent = current_track == track;\n\twindow_get_sel(win, &sel);\n\tselected = iters_equal(iter, &sel);\n\n\tif (selected) {\n\t\tcursor_x = win_x;\n\t\tcursor_y = 1 + row;\n\t}\n\n\tactive = win_active;\n\tif (!selected && !!track->marked) {\n\t\tselected = 1;\n\t\tactive = 0;\n\t}\n\n\tbkgdset(pairs[(active << 2) | (selected << 1) | current]);\n\n\tfill_track_fopts_track_info(track->info);\n\n\tformat = list_win_format;\n\tif (track_info_has_tag(track->info)) {\n\t\tif (*list_win_format_va && track_is_compilation(track->info->comments))\n\t\t\tformat = list_win_format_va;\n\t} else if (*list_win_alt_format) {\n\t\tformat = list_win_alt_format;\n\t}\n\tformat_print(&print_buffer, win_w, format, track_fopts);\n\tdump_print_buffer(row + 1, win_x);\n}\n\nstatic void print_browser(struct window *win, int row, struct iter *iter)\n{\n\tstruct browser_entry *e;\n\tstruct iter sel;\n\tint selected;\n\n\te = iter_to_browser_entry(iter);\n\twindow_get_sel(win, &sel);\n\tselected = iters_equal(iter, &sel);\n\tif (selected) {\n\t\tint active = 1;\n\t\tint current = 0;\n\n\t\tbkgdset(pairs[(active << 2) | (selected << 1) | current]);\n\t} else {\n\t\tif (e->type == BROWSER_ENTRY_DIR) {\n\t\t\tbkgdset(pairs[CURSED_DIR]);\n\t\t} else {\n\t\t\tbkgdset(pairs[CURSED_WIN]);\n\t\t}\n\t}\n\n\tif (selected) {\n\t\tcursor_x = 0;\n\t\tcursor_y = 1 + row;\n\t}\n\n\tsprint(row + 1, 0, e->name, win_w);\n}\n\nstatic void print_filter(struct window *win, int row, struct iter *iter)\n{\n\tchar buf[256];\n\tstruct filter_entry *e = iter_to_filter_entry(iter);\n\tstruct iter sel;\n\t/* window active? */\n\tint active = 1;\n\t/* row selected? */\n\tint selected;\n\t/* is the filter currently active? */\n\tint current = !!e->act_stat;\n\tconst char stat_chars[3] = \" *!\";\n\tint ch1, ch2, ch3;\n\tconst char *e_filter;\n\n\twindow_get_sel(win, &sel);\n\tselected = iters_equal(iter, &sel);\n\tbkgdset(pairs[(active << 2) | (selected << 1) | current]);\n\n\tif (selected) {\n\t\tcursor_x = 0;\n\t\tcursor_y = 1 + row;\n\t}\n\n\tch1 = ' ';\n\tch3 = ' ';\n\tif (e->sel_stat != e->act_stat) {\n\t\tch1 = '[';\n\t\tch3 = ']';\n\t}\n\tch2 = stat_chars[e->sel_stat];\n\n\te_filter = e->filter;\n\tif (!using_utf8) {\n\t\tutf8_encode_to_buf(e_filter);\n\t\te_filter = conv_buffer;\n\t}\n\n\tsnprintf(buf, sizeof(buf), \"%c%c%c%-15s  %.235s\", ch1, ch2, ch3, e->name, e_filter);\n\tformat_str(&print_buffer, buf, win_w - 1);\n\tgbuf_add_ch(&print_buffer, ' ');\n\tdump_print_buffer(row + 1, 0);\n}\n\nstatic void print_help(struct window *win, int row, struct iter *iter)\n{\n\tstruct iter sel;\n\tint selected;\n\tint active = 1;\n\tchar buf[OPTION_MAX_SIZE];\n\tconst struct help_entry *e = iter_to_help_entry(iter);\n\tconst struct cmus_opt *opt;\n\n\twindow_get_sel(win, &sel);\n\tselected = iters_equal(iter, &sel);\n\tbkgdset(pairs[(active << 2) | (selected << 1)]);\n\n\tif (selected) {\n\t\tcursor_x = 0;\n\t\tcursor_y = 1 + row;\n\t}\n\n\tswitch (e->type) {\n\tcase HE_TEXT:\n\t\tsnprintf(buf, sizeof(buf), \" %s\", e->text);\n\t\tbreak;\n\tcase HE_BOUND:\n\t\tsnprintf(buf, sizeof(buf), \" %-8s %-23s %s\",\n\t\t\t\tkey_context_names[e->binding->ctx],\n\t\t\t\te->binding->key->name,\n\t\t\t\te->binding->cmd);\n\t\tbreak;\n\tcase HE_UNBOUND:\n\t\tsnprintf(buf, sizeof(buf), \" %s\", e->command->name);\n\t\tbreak;\n\tcase HE_OPTION:\n\t\topt = e->option;\n\t\tsnprintf(buf, sizeof(buf), \" %-29s \", opt->name);\n\t\tsize_t len = strlen(buf);\n\t\topt->get(opt->data, buf + len, sizeof(buf) - len);\n\t\tbreak;\n\t}\n\tformat_str(&print_buffer, buf, win_w - 1);\n\tgbuf_add_ch(&print_buffer, ' ');\n\tdump_print_buffer(row + 1, 0);\n}\n\nstatic void update_window(struct window *win, int x, int y, int w, const char *title,\n\t\tvoid (*print)(struct window *, int, struct iter *))\n{\n\tstruct iter iter;\n\tint nr_rows;\n\tint i;\n\n\twin->changed = 0;\n\n\tbkgdset(pairs[CURSED_WIN_TITLE]);\n\tsprint(y, x, title, w);\n\n\tnr_rows = window_get_nr_rows(win);\n\ti = 0;\n\tif (window_get_top(win, &iter)) {\n\t\twhile (i < nr_rows) {\n\t\t\tprint(win, i, &iter);\n\t\t\ti++;\n\t\t\tif (!window_get_next(win, &iter))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tbkgdset(pairs[0]);\n\tgbuf_set(&print_buffer, ' ', w);\n\twhile (i < nr_rows) {\n\t\tdump_print_buffer_no_clear(y + i + 1, x, 0);\n\t\ti++;\n\t}\n\tgbuf_clear(&print_buffer);\n}\n\nstatic void update_tree_window(void)\n{\n\tstatic GBUF(buf);\n\tgbuf_clear(&buf);\n\n\tgbuf_add_str(&buf, \"Library\");\n\tif (worker_has_job())\n\t\tgbuf_addf(&buf, \" - %d tracks\", lib_editable.nr_tracks);\n\tupdate_window(lib_tree_win, tree_win_x, 0, tree_win_w + 1, buf.buffer, print_tree);\n}\n\nstatic void update_track_window(void)\n{\n\tstatic GBUF(title);\n\tgbuf_clear(&title);\n\n\tstruct iter iter;\n\tstruct album *album;\n\tstruct artist *artist;\n\n\tconst char *format_str = \"Empty (use :add)\";\n\n\tif (window_get_sel(lib_tree_win, &iter)) {\n\t\tif ((album = iter_to_album(&iter))) {\n\t\t\tfill_track_fopts_album(album);\n\t\t\tformat_str = heading_album_format;\n\t\t} else if ((artist = iter_to_artist(&iter))) {\n\t\t\tfill_track_fopts_artist(artist);\n\t\t\tformat_str = heading_artist_format;\n\t\t}\n\t}\n\tformat_print(&title, track_win_w - 2, format_str, track_fopts);\n\tupdate_window(lib_track_win, track_win_x, 0, track_win_w, title.buffer,\n\t\t\tprint_track);\n}\n\nstatic void print_pl_list(struct window *win, int row, struct iter *iter)\n{\n\tstruct pl_list_info info;\n\n\tpl_list_iter_to_info(iter, &info);\n\n\tbkgdset(pairs[(info.active<<2) | (info.selected<<1) | info.current]);\n\n\tconst char *prefix = \"   \";\n\tif (info.marked)\n\t\tprefix = \" * \";\n\tsize_t prefix_w = strlen(prefix);\n\tformat_str(&print_buffer, prefix, prefix_w);\n\n\tif (tree_win_w > prefix_w)\n\t\tformat_str(&print_buffer, info.name,\n\t\t\t\ttree_win_w - prefix_w);\n\n\tdump_print_buffer(row + 1, 0);\n}\n\nstatic void draw_separator(void)\n{\n\tint row;\n\n\tbkgdset(pairs[CURSED_WIN_TITLE]);\n\t(void) mvaddch(0, tree_win_w, ' ');\n\tbkgdset(pairs[CURSED_SEPARATOR]);\n\tfor (row = 1; row < LINES - 3; row++)\n\t\t(void) mvaddch(row, tree_win_w, ACS_VLINE);\n}\n\nstatic void update_pl_list(struct window *win)\n{\n\tif (pl_show_panel()) {\n\t\tupdate_window(win, tree_win_x, 0, tree_win_w + 1, \"Playlist\", print_pl_list);\n\t\tdraw_separator();\n\t}\n}\n\nstatic void update_pl_tracks(struct window *win)\n{\n\tstatic GBUF(title);\n\tgbuf_clear(&title);\n\tint win_w_tmp = win_w;\n\n\tif (pl_show_panel()) {\n\t\twin_x = track_win_x;\n\t\twin_w = track_win_w;\n\t} else {\n\t\twin_x = 0;\n\t\twin_w = tree_win_w + 1 + track_win_w;\n\t}\n\twin_active = pl_get_cursor_in_track_window();\n\n\tget_global_fopts();\n\tfopt_set_int(&track_fopts[TF_PANEL], 1, !pl_show_panel());\n\tfopt_set_str(&track_fopts[TF_TITLE], pl_visible_get_name());\n\tfopt_set_time(&track_fopts[TF_DURATION], pl_visible_total_time(), 0);\n\n\tformat_print(&title, win_w - 2, heading_playlist_format, track_fopts);\n\tupdate_window(win, win_x, 0, win_w, title.buffer, print_editable);\n\n\twin_active = 1;\n\twin_x = 0;\n\twin_w = win_w_tmp;\n}\n\nstatic const char *pretty_path(const char *path)\n{\n\tstatic int home_len = -1;\n\tstatic GBUF(buf);\n\n\tif (home_len == -1)\n\t\thome_len = strlen(home_dir);\n\n\tif (strncmp(path, home_dir, home_len) || path[home_len] != '/')\n\t\treturn path;\n\n\tgbuf_clear(&buf);\n\tgbuf_add_ch(&buf, '~');\n\tgbuf_add_str(&buf, path + home_len);\n\treturn buf.buffer;\n}\n\nstatic const char * const sorted_names[2] = { \"\", \"sorted by \" };\n\nstatic void update_editable_window(struct editable *e, const char *title, const char *filename)\n{\n\tstatic GBUF(buf);\n\tgbuf_clear(&buf);\n\n\tif (filename) {\n\t\tif (using_utf8) {\n\t\t\t/* already UTF-8 */\n\t\t} else {\n\t\t\tutf8_encode_to_buf(filename);\n\t\t\tfilename = conv_buffer;\n\t\t}\n\t\tgbuf_addf(&buf, \"%s %.256s - %d tracks\", title, pretty_path(filename), e->nr_tracks);\n\t} else {\n\t\tgbuf_addf(&buf, \"%s - %d tracks\", title, e->nr_tracks);\n\t}\n\n\tfopt_set_time(&track_fopts[TF_TOTAL], e->total_time, 0);\n\tformat_print(&buf, 0, \" (%{total})\", track_fopts);\n\n\tif (e->nr_marked) {\n\t\tgbuf_addf(&buf, \" (%d marked)\", e->nr_marked);\n\t}\n\tgbuf_addf(&buf, \" %s%s\",\n\t\t\tsorted_names[e->shared->sort_str[0] != 0],\n\t\t\te->shared->sort_str);\n\n\tupdate_window(e->shared->win, 0, 0, win_w, buf.buffer, &print_editable);\n}\n\nstatic void update_sorted_window(void)\n{\n\tcurrent_track = (struct simple_track *)lib_cur_track;\n\tupdate_editable_window(&lib_editable, \"Library\", NULL);\n}\n\nstatic void update_play_queue_window(void)\n{\n\tcurrent_track = NULL;\n\tupdate_editable_window(&pq_editable, \"Play Queue\", NULL);\n}\n\nstatic void update_browser_window(void)\n{\n\tstatic GBUF(title);\n\tgbuf_clear(&title);\n\tchar *dirname;\n\n\tif (using_utf8) {\n\t\t/* already UTF-8 */\n\t\tdirname = browser_dir;\n\t} else {\n\t\tutf8_encode_to_buf(browser_dir);\n\t\tdirname = conv_buffer;\n\t}\n\tgbuf_add_str(&title, \"Browser - \");\n\tgbuf_add_str(&title, dirname);\n\tupdate_window(browser_win, 0, 0, win_w, title.buffer, print_browser);\n}\n\nstatic void update_filters_window(void)\n{\n\tupdate_window(filters_win, 0, 0, win_w, \"Library Filters\", print_filter);\n}\n\nstatic void update_help_window(void)\n{\n\tupdate_window(help_win, 0, 0, win_w, \"Settings\", print_help);\n}\n\nstatic void update_pl_view(int full)\n{\n\tcurrent_track = pl_get_playing_track();\n\tpl_draw(update_pl_list, update_pl_tracks, full);\n}\n\nstatic void do_update_view(int full)\n{\n\tif (!ui_initialized)\n\t\treturn;\n\n\tcursor_x = -1;\n\tcursor_y = -1;\n\n\tswitch (cur_view) {\n\tcase TREE_VIEW:\n\t\tif (full || lib_tree_win->changed)\n\t\t\tupdate_tree_window();\n\t\tif (full || lib_track_win->changed)\n\t\t\tupdate_track_window();\n\t\tdraw_separator();\n\t\tupdate_filterline();\n\t\tbreak;\n\tcase SORTED_VIEW:\n\t\tupdate_sorted_window();\n\t\tupdate_filterline();\n\t\tbreak;\n\tcase PLAYLIST_VIEW:\n\t\tupdate_pl_view(full);\n\t\tbreak;\n\tcase QUEUE_VIEW:\n\t\tupdate_play_queue_window();\n\t\tbreak;\n\tcase BROWSER_VIEW:\n\t\tupdate_browser_window();\n\t\tbreak;\n\tcase FILTERS_VIEW:\n\t\tupdate_filters_window();\n\t\tbreak;\n\tcase HELP_VIEW:\n\t\tupdate_help_window();\n\t\tbreak;\n\t}\n}\n\nstatic void do_update_statusline(void)\n{\n\tstruct fp_len len;\n\tlen = format_print(&print_buffer, win_w, statusline_format, get_global_fopts());\n\tbkgdset(pairs[CURSED_STATUSLINE]);\n\tdump_print_buffer_no_clear(LINES - 2, 0, 0);\n\n\tif (progress_bar && player_info.ti) {\n\t\tint duration = player_info.ti->duration;\n\t\tif (duration && duration >= player_info.pos) {\n\t\t\tif (progress_bar == PROGRESS_BAR_LINE || progress_bar == PROGRESS_BAR_SHUTTLE) {\n\t\t\t\t/* Draw a bar or short position marker within the blank space */\n\t\t\t\tint shuttle_len = (progress_bar == PROGRESS_BAR_SHUTTLE) ? 2 : 0;\n\t\t\t\tint bar_start = len.llen + len.mlen;\n\t\t\t\tint bar_space = win_w - len.rlen - bar_start - shuttle_len;\n\t\t\t\tif (bar_space >= 5) {\n\t\t\t\t\tint bar_len = bar_space * player_info.pos / duration;\n\t\t\t\t        if (progress_bar == PROGRESS_BAR_SHUTTLE) {\n\t\t\t\t\t\tbar_start += bar_len;\n\t\t\t\t\t\tbar_len = shuttle_len;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int x = bar_start; bar_len; --bar_len)\n\t\t\t\t\t\t(void) mvaddstr(LINES - 2, x++, using_utf8 ? \"━\" : \"-\");\n\t\t\t\t}\n\t\t\t} else if (progress_bar == PROGRESS_BAR_COLOR) {\n\t\t\t\t/* Draw over the played portion of bar in alt color */\n\t\t\t\tint w = win_w * player_info.pos / duration;\n\n\t\t\t\tint skip = w;\n\t\t\t\tint buf_index = u_skip_chars(print_buffer.buffer, &skip, false);\n\t\t\t\tprint_buffer.buffer[buf_index] = '\\0';\n\n\t\t\t\tbkgdset(pairs[CURSED_STATUSLINE_PROGRESS]);\n\t\t\t\tdump_print_buffer_no_clear(LINES - 2, 0, 0);\n\n\t\t\t} else { // PROGRESS_BAR_COLOR_SHUTTLE\n\t\t\t\t/* Redraw a few cols in alt color to mark the current position */\n\t\t\t\tint shuttle_len = min_u(6, win_w);\n\t\t\t\tint x = (win_w - shuttle_len) * player_info.pos / duration;\n\n\t\t\t\tint skip = x;\n\t\t\t\tint buf_index = u_skip_chars(print_buffer.buffer, &skip, false);\n\n\t\t\t\tint end_offset = u_skip_chars(print_buffer.buffer + buf_index, &shuttle_len, true);\n\t\t\t\tprint_buffer.buffer[buf_index+end_offset] = '\\0';\n\n\t\t\t\tbkgdset(pairs[CURSED_STATUSLINE_PROGRESS]);\n\t\t\t\tdump_print_buffer_no_clear(LINES - 2, x, buf_index);\n\t\t\t}\n\t\t}\n\t}\n\n\tgbuf_clear(&print_buffer);\n\n\tif (player_info.error_msg)\n\t\terror_msg(\"%s\", player_info.error_msg);\n}\n\nstatic void dump_buffer(const char *buffer)\n{\n\tif (using_utf8) {\n\t\taddstr(buffer);\n\t} else {\n\t\tutf8_decode(buffer);\n\t\taddstr(conv_buffer);\n\t}\n}\n\nstatic void do_update_commandline(void)\n{\n\tchar *str;\n\tsize_t idx = 0;\n\tchar ch;\n\n\tmove(LINES - 1, 0);\n\tif (error_buf.len != 0) {\n\t\tif (msg_is_error) {\n\t\t\tbkgdset(pairs[CURSED_ERROR]);\n\t\t} else {\n\t\t\tbkgdset(pairs[CURSED_INFO]);\n\t\t}\n\t\taddstr(error_buf.buffer);\n\t\tclrtoeol();\n\t\treturn;\n\t}\n\tbkgdset(pairs[CURSED_COMMANDLINE]);\n\tif (input_mode == NORMAL_MODE) {\n\t\tclrtoeol();\n\t\treturn;\n\t}\n\n\tstr = cmdline.line;\n\tif (!using_utf8) {\n\t\t/* cmdline.line actually pretends to be UTF-8 but all non-ASCII\n\t\t * characters are invalid UTF-8 so it really is in locale's\n\t\t * encoding.\n\t\t *\n\t\t * This code should be safe because cmdline.bpos ==\n\t\t * cmdline.cpos as every non-ASCII character is counted as one\n\t\t * invalid UTF-8 byte.\n\t\t *\n\t\t * NOTE: This has nothing to do with widths of printed\n\t\t * characters.  I.e. even if there were control characters\n\t\t * (displayed as <xx>) there would be no problem because bpos\n\t\t * still equals to cpos, I think.\n\t\t */\n\t\tutf8_encode_to_buf(cmdline.line);\n\t\tstr = conv_buffer;\n\t}\n\n\t/* COMMAND_MODE or SEARCH_MODE */\n\tch = ':';\n\tif (input_mode == SEARCH_MODE)\n\t\tch = search_direction == SEARCH_FORWARD ? '/' : '?';\n\n\tint width = win_w - 2; // ':' at start and ' ' at end\n\n\t/* width of the text in the buffer before and after cursor */\n\tint cw = u_str_nwidth(str, cmdline.cpos);\n\tint extra_w = u_str_width(str + cmdline.bpos);\n\n\t/* shift by third of bar width to provide visual context when editing */\n\tint context_w = min_u(extra_w, win_w / 3);\n\n\tint skip = cw + context_w - width;\n\tif (skip <= 0) {\n\t\taddch(ch);\n\t\tcmdline_cursor_x = 1 + cw;\n\t} else {\n\t\t/* ':' will not be printed */\n\t\tskip--;\n\t\twidth++;\n\t\tidx = u_skip_chars(str, &skip, true);\n\t\tgbuf_set(&print_buffer, ' ', -skip);\n\t\twidth += skip;\n\t\tcmdline_cursor_x = win_w - 1 - context_w;\n\t}\n\t/* allow printing in ' ' space we kept at end, cursor isn't always there */\n\twidth++;\n\tgbuf_add_ustr(&print_buffer, str + idx, &width);\n\tdump_buffer(print_buffer.buffer);\n\tgbuf_clear(&print_buffer);\n\tclrtoeol();\n}\n\nstatic void set_title(const char *title)\n{\n\tif (!set_term_title)\n\t\treturn;\n\n\tif (t_ts) {\n\t\tprintf(\"%s%s%s\", tgoto(t_ts, 0, 0), title, t_fs);\n\t\tfflush(stdout);\n\t}\n}\n\nstatic void do_update_titleline(void)\n{\n\tif (!ui_initialized)\n\t\treturn;\n\n\tbkgdset(pairs[CURSED_TITLELINE]);\n\tif (player_info.ti) {\n\t\tint use_alt_format = 0;\n\t\tchar *wtitle;\n\n\t\tfill_track_fopts_track_info(player_info.ti);\n\n\t\tuse_alt_format = !track_info_has_tag(player_info.ti);\n\n\t\tif (is_http_url(player_info.ti->filename)) {\n\t\t\tconst char *title = get_stream_title();\n\n\t\t\tif (title != NULL) {\n\t\t\t\tfree(title_buf);\n\t\t\t\ttitle_buf = to_utf8(title, icecast_default_charset);\n\t\t\t\t/*\n\t\t\t\t * StreamTitle overrides radio station name\n\t\t\t\t */\n\t\t\t\tuse_alt_format = 0;\n\t\t\t\tfopt_set_str(&track_fopts[TF_TITLE], title_buf);\n\t\t\t}\n\t\t}\n\n\t\tif (use_alt_format && *current_alt_format) {\n\t\t\tformat_print(&print_buffer, win_w, current_alt_format, track_fopts);\n\t\t} else {\n\t\t\tformat_print(&print_buffer, win_w, current_format, track_fopts);\n\t\t}\n\t\tdump_print_buffer(LINES - 3, 0);\n\n\t\t/* set window title */\n\t\tif (use_alt_format && *window_title_alt_format) {\n\t\t\tformat_print(&print_buffer, 0,\n\t\t\t\t\twindow_title_alt_format, track_fopts);\n\t\t} else {\n\t\t\tformat_print(&print_buffer, 0,\n\t\t\t\t\twindow_title_format, track_fopts);\n\t\t}\n\n\t\tif (using_utf8) {\n\t\t\twtitle = print_buffer.buffer;\n\t\t} else {\n\t\t\tutf8_decode(print_buffer.buffer);\n\t\t\twtitle = conv_buffer;\n\t\t}\n\n\t\tset_title(wtitle);\n\t\tgbuf_clear(&print_buffer);\n\t} else {\n\t\tmove(LINES - 3, 0);\n\t\tclrtoeol();\n\n\t\tset_title(\"cmus \" VERSION);\n\t}\n}\n\nstatic void post_update(void)\n{\n\t/* refresh makes cursor visible at least for urxvt */\n\tif (input_mode == COMMAND_MODE || input_mode == SEARCH_MODE) {\n\t\tmove(LINES - 1, cmdline_cursor_x);\n\t\trefresh();\n\t\tcurs_set(1);\n\t} else {\n\t\tif (cursor_x >= 0) {\n\t\t\tmove(cursor_y, cursor_x);\n\t\t} else {\n\t\t\tmove(LINES - 1, 0);\n\t\t}\n\t\trefresh();\n\n\t\t/* visible cursor is useful for screen readers */\n\t\tif (show_cursor) {\n\t\t\tcurs_set(1);\n\t\t} else {\n\t\t\tcurs_set(0);\n\t\t}\n\t}\n}\n\nstatic const char *get_stream_title_locked(void)\n{\n\tstatic char stream_title[255 * 16 + 1];\n\tchar *ptr, *title;\n\n\tptr = strstr(player_metadata, \"StreamTitle='\");\n\tif (ptr == NULL)\n\t\treturn NULL;\n\tptr += 13;\n\ttitle = ptr;\n\twhile (*ptr) {\n\t\tif (*ptr == '\\'' && *(ptr + 1) == ';') {\n\t\t\tmemcpy(stream_title, title, ptr - title);\n\t\t\tstream_title[ptr - title] = 0;\n\t\t\treturn stream_title;\n\t\t}\n\t\tptr++;\n\t}\n\treturn NULL;\n}\n\nconst char *get_stream_title(void)\n{\n\tplayer_metadata_lock();\n\tconst char *rv = get_stream_title_locked();\n\tplayer_metadata_unlock();\n\treturn rv;\n}\n\nvoid update_titleline(void)\n{\n\tcurs_set(0);\n\tdo_update_titleline();\n\tpost_update();\n}\n\nvoid update_full(void)\n{\n\tif (!ui_initialized)\n\t\treturn;\n\n\tcurs_set(0);\n\n\tdo_update_view(1);\n\tdo_update_titleline();\n\tdo_update_statusline();\n\tdo_update_commandline();\n\n\tpost_update();\n}\n\nstatic void update_commandline(void)\n{\n\tcurs_set(0);\n\tdo_update_commandline();\n\tpost_update();\n}\n\nvoid update_statusline(void)\n{\n\tif (!ui_initialized)\n\t\treturn;\n\n\tcurs_set(0);\n\tdo_update_statusline();\n\tpost_update();\n}\n\nvoid update_filterline(void)\n{\n\tif (cur_view != TREE_VIEW && cur_view != SORTED_VIEW)\n\t\treturn;\n\tif (lib_live_filter) {\n\t\tstatic GBUF(buf);\n\t\tgbuf_clear(&buf);\n\t\tint w;\n\t\tbkgdset(pairs[CURSED_STATUSLINE]);\n\t\tgbuf_addf(&buf, \"filtered: %s\", lib_live_filter);\n\t\tw = clamp(u_str_width(buf.buffer) + 2, win_w/4, win_w/2);\n\t\tsprint(LINES-4, win_w-w, buf.buffer, w);\n\t}\n}\n\nvoid info_msg(const char *format, ...)\n{\n\tva_list ap;\n\n\tgbuf_clear(&error_buf);\n\tva_start(ap, format);\n\tgbuf_vaddf(&error_buf, format, ap);\n\tva_end(ap);\n\n\tif (client_fd != -1) {\n\t\twrite_all(client_fd, error_buf.buffer, error_buf.len);\n\t\twrite_all(client_fd, \"\\n\", 1);\n\t}\n\n\tmsg_is_error = 0;\n\n\tupdate_commandline();\n}\n\nvoid error_msg(const char *format, ...)\n{\n\tva_list ap;\n\n\tgbuf_clear(&error_buf);\n\tgbuf_add_str(&error_buf, \"Error: \");\n\tva_start(ap, format);\n\tgbuf_vaddf(&error_buf, format, ap);\n\tva_end(ap);\n\n\td_print(\"%s\\n\", error_buf.buffer);\n\tif (client_fd != -1) {\n\t\twrite_all(client_fd, error_buf.buffer, error_buf.len);\n\t\twrite_all(client_fd, \"\\n\", 1);\n\t}\n\n\tmsg_is_error = 1;\n\terror_count++;\n\n\tif (ui_initialized) {\n\t\terror_time = time(NULL);\n\t\tupdate_commandline();\n\t} else {\n\t\twarn(\"%s\\n\", error_buf.buffer);\n\t\tgbuf_clear(&error_buf);\n\t}\n}\n\nenum ui_query_answer yes_no_query(const char *format, ...)\n{\n\tstatic GBUF(buffer);\n\tgbuf_clear(&buffer);\n\tva_list ap;\n\tint ret = 0;\n\n\tva_start(ap, format);\n\tgbuf_vaddf(&buffer, format, ap);\n\tva_end(ap);\n\n\tmove(LINES - 1, 0);\n\tbkgdset(pairs[CURSED_INFO]);\n\n\t/* no need to convert buffer.\n\t * it is always encoded in the right charset (assuming filenames are\n\t * encoded in same charset as LC_CTYPE).\n\t */\n\n\taddstr(buffer.buffer);\n\tclrtoeol();\n\trefresh();\n\n\twhile (1) {\n\t\tint ch = getch();\n\t\tif (ch == ERR || ch == 0) {\n\t\t\tif (!cmus_running) {\n\t\t\t\tret = UI_QUERY_ANSWER_ERROR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ch == 'y') {\n\t\t\tret = UI_QUERY_ANSWER_YES;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tret = UI_QUERY_ANSWER_NO;\n\t\t\tbreak;\n\t\t}\n\t}\n\tupdate_commandline();\n\treturn ret;\n}\n\nvoid search_not_found(void)\n{\n\tconst char *what = \"Track\";\n\n\tif (search_restricted) {\n\t\tswitch (cur_view) {\n\t\tcase TREE_VIEW:\n\t\t\twhat = \"Artist/album\";\n\t\t\tbreak;\n\t\tcase SORTED_VIEW:\n\t\tcase PLAYLIST_VIEW:\n\t\tcase QUEUE_VIEW:\n\t\t\twhat = \"Title\";\n\t\t\tbreak;\n\t\tcase BROWSER_VIEW:\n\t\t\twhat = \"File/Directory\";\n\t\t\tbreak;\n\t\tcase FILTERS_VIEW:\n\t\t\twhat = \"Filter\";\n\t\t\tbreak;\n\t\tcase HELP_VIEW:\n\t\t\twhat = \"Binding/command/option\";\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (cur_view) {\n\t\tcase TREE_VIEW:\n\t\tcase SORTED_VIEW:\n\t\tcase PLAYLIST_VIEW:\n\t\tcase QUEUE_VIEW:\n\t\t\twhat = \"Track\";\n\t\t\tbreak;\n\t\tcase BROWSER_VIEW:\n\t\t\twhat = \"File/Directory\";\n\t\t\tbreak;\n\t\tcase FILTERS_VIEW:\n\t\t\twhat = \"Filter\";\n\t\t\tbreak;\n\t\tcase HELP_VIEW:\n\t\t\twhat = \"Binding/command/option\";\n\t\t\tbreak;\n\t\t}\n\t}\n\tinfo_msg(\"%s not found: %s\", what, search_str ? search_str : \"\");\n}\n\nvoid set_client_fd(int fd)\n{\n\tclient_fd = fd;\n}\n\nint get_client_fd(void)\n{\n\treturn client_fd;\n}\n\nvoid set_view(int view)\n{\n\tif (view == cur_view)\n\t\treturn;\n\n\tprev_view = cur_view;\n\tcur_view = view;\n\tswitch (cur_view) {\n\tcase TREE_VIEW:\n\t\tsearchable = tree_searchable;\n\t\tbreak;\n\tcase SORTED_VIEW:\n\t\tsearchable = lib_editable.shared->searchable;\n\t\tbreak;\n\tcase PLAYLIST_VIEW:\n\t\tsearchable = pl_get_searchable();\n\t\tbreak;\n\tcase QUEUE_VIEW:\n\t\tsearchable = pq_editable.shared->searchable;\n\t\tbreak;\n\tcase BROWSER_VIEW:\n\t\tsearchable = browser_searchable;\n\t\tbreak;\n\tcase FILTERS_VIEW:\n\t\tsearchable = filters_searchable;\n\t\tbreak;\n\tcase HELP_VIEW:\n\t\tsearchable = help_searchable;\n\t\tupdate_help_window();\n\t\tbreak;\n\t}\n\n\tcurs_set(0);\n\tdo_update_view(1);\n\tpost_update();\n}\n\nvoid enter_command_mode(void)\n{\n\tgbuf_clear(&error_buf);\n\terror_time = 0;\n\tinput_mode = COMMAND_MODE;\n\tupdate_commandline();\n}\n\nvoid enter_search_mode(void)\n{\n\tgbuf_clear(&error_buf);\n\terror_time = 0;\n\tinput_mode = SEARCH_MODE;\n\tsearch_direction = SEARCH_FORWARD;\n\tupdate_commandline();\n}\n\nvoid enter_search_backward_mode(void)\n{\n\tgbuf_clear(&error_buf);\n\terror_time = 0;\n\tinput_mode = SEARCH_MODE;\n\tsearch_direction = SEARCH_BACKWARD;\n\tupdate_commandline();\n}\n\nvoid update_colors(void)\n{\n\tint i;\n\n\tif (!ui_initialized)\n\t\treturn;\n\n\tfor (i = 0; i < NR_CURSED; i++) {\n\t\tint bg = colors[cursed_to_bg_idx[i]];\n\t\tint fg = colors[cursed_to_fg_idx[i]];\n\t\tint attr = attrs[cursed_to_attr_idx[i]];\n\t\tint pair = i + 1;\n\n\t\tif (fg >= 8 && fg <= 15) {\n\t\t\t/* fg colors 8..15 are special (0..7 + bold) */\n\t\t\tinit_pair(pair, fg & 7, bg);\n\t\t\tpairs[i] = COLOR_PAIR(pair) | (fg & BRIGHT ? A_BOLD : 0) | attr;\n\t\t} else {\n\t\t\tinit_pair(pair, fg, bg);\n\t\t\tpairs[i] = COLOR_PAIR(pair) | attr;\n\t\t}\n\t}\n}\n\nstatic void clear_error(void)\n{\n\ttime_t t = time(NULL);\n\n\t/* prevent accidental clearing of error messages */\n\tif (t - error_time < 2)\n\t\treturn;\n\n\tif (error_buf.len != 0) {\n\t\terror_time = 0;\n\t\tgbuf_clear(&error_buf);\n\t\tupdate_commandline();\n\t}\n}\n\n/* screen updates }}} */\n\nstatic int fill_status_program_track_info_args(char **argv, int i, struct track_info *ti)\n{\n\t/* returns first free argument index */\n\n\tconst char *stream_title = NULL;\n\tif (player_info.status == PLAYER_STATUS_PLAYING && is_http_url(ti->filename))\n\t\tstream_title = get_stream_title();\n\n\tstatic const char *keys[] = {\n\t\t\"artist\", \"albumartist\", \"album\", \"discnumber\", \"tracknumber\", \"title\",\n\t\t\"date\",\t\"musicbrainz_trackid\", NULL\n\t};\n\tint j;\n\n\tif (is_http_url(ti->filename)) {\n\t\targv[i++] = xstrdup(\"url\");\n\t} else {\n\t\targv[i++] = xstrdup(\"file\");\n\t}\n\targv[i++] = xstrdup(ti->filename);\n\n\tif (track_info_has_tag(ti)) {\n\t\tfor (j = 0; keys[j]; j++) {\n\t\t\tconst char *key = keys[j];\n\t\t\tconst char *val;\n\n\t\t\tif (strcmp(key, \"title\") == 0 && stream_title)\n\t\t\t\t/*\n\t\t\t\t * StreamTitle overrides radio station name\n\t\t\t\t */\n\t\t\t\tval = stream_title;\n\t\t\telse\n\t\t\t\tval = keyvals_get_val(ti->comments, key);\n\n\t\t\tif (val) {\n\t\t\t\targv[i++] = xstrdup(key);\n\t\t\t\targv[i++] = xstrdup(val);\n\t\t\t}\n\t\t}\n\t\tif (ti->duration > 0) {\n\t\t\tchar buf[32];\n\t\t\tsnprintf(buf, sizeof(buf), \"%d\", ti->duration);\n\t\t\targv[i++] = xstrdup(\"duration\");\n\t\t\targv[i++] = xstrdup(buf);\n\t\t}\n\t} else if (stream_title) {\n\t\targv[i++] = xstrdup(\"title\");\n\t\targv[i++] = xstrdup(stream_title);\n\t}\n\n\treturn i;\n}\n\nstatic void spawn_status_program_inner(const char *status_text, struct track_info *ti)\n{\n\tif (status_display_program == NULL || status_display_program[0] == 0)\n\t\treturn;\n\n\tchar *argv[32];\n\tint i = 0;\n\n\targv[i++] = xstrdup(status_display_program);\n\n\targv[i++] = xstrdup(\"status\");\n\targv[i++] = xstrdup(status_text);\n\n\tif (ti) {\n\t\ti = fill_status_program_track_info_args(argv, i, ti);\n\t}\n\targv[i++] = NULL;\n\n\tif (spawn(argv, NULL, 0) == -1)\n\t\terror_msg(\"couldn't run `%s': %s\", status_display_program, strerror(errno));\n\tfor (i = 0; argv[i]; i++)\n\t\tfree(argv[i]);\n}\n\nstatic void spawn_status_program(void)\n{\n\tspawn_status_program_inner(player_status_names[player_info.status], player_info.ti);\n}\n\nstatic volatile sig_atomic_t ctrl_c_pressed = 0;\n\nstatic void sig_int(int sig)\n{\n\tctrl_c_pressed = 1;\n}\n\nstatic void sig_shutdown(int sig)\n{\n\td_print(\"sig_shutdown %d\\n\", sig);\n\tcmus_running = 0;\n}\n\nstatic volatile sig_atomic_t needs_to_resize = 0;\n\nstatic void sig_winch(int sig)\n{\n\tneeds_to_resize = 1;\n}\n\nvoid update_size(void) {\n\tneeds_to_resize = 1;\n}\n\nstatic int get_window_size(int *lines, int *columns)\n{\n\tstruct winsize ws;\n\n\tif (ioctl(0, TIOCGWINSZ, &ws) == -1)\n\t\treturn -1;\n\t*columns = ws.ws_col;\n\t*lines = ws.ws_row;\n\treturn 0;\n}\n\nstatic void resize_tree_view(int w, int h)\n{\n\ttree_win_w = w * ((float)tree_width_percent / 100.0f);\n\tif (tree_width_max && tree_win_w > tree_width_max)\n\t\ttree_win_w = tree_width_max;\n\t/* at least one character of formatted text and one space either side */\n\tif (tree_win_w < 3)\n\t\ttree_win_w = 3;\n\ttrack_win_w = w - tree_win_w - 1;\n\tif (track_win_w < 3)\n\t\ttrack_win_w = 3;\n\n\ttree_win_x = 0;\n\ttrack_win_x = tree_win_w + 1;\n\n\th--;\n\twindow_set_nr_rows(lib_tree_win, h);\n\twindow_set_nr_rows(lib_track_win, h);\n}\n\nstatic void update_window_size(void)\n{\n\tint w, h;\n\tint columns, lines;\n\n\tif (get_window_size(&lines, &columns) == 0) {\n\t\tneeds_to_resize = 0;\n#if HAVE_RESIZETERM\n\t\tresizeterm(lines, columns);\n#endif\n\t\tw = COLS;\n\t\th = LINES - 3;\n\t\tif (w < 4)\n\t\t\tw = 4;\n\t\tif (h < 2)\n\t\t\th = 2;\n\t\twin_w = w;\n\t\tresize_tree_view(w, h);\n\t\twindow_set_nr_rows(lib_editable.shared->win, h - 1);\n\t\tpl_set_nr_rows(h - 1);\n\t\twindow_set_nr_rows(pq_editable.shared->win, h - 1);\n\t\twindow_set_nr_rows(filters_win, h - 1);\n\t\twindow_set_nr_rows(help_win, h - 1);\n\t\twindow_set_nr_rows(browser_win, h - 1);\n\t}\n\tclearok(curscr, TRUE);\n\trefresh();\n}\n\nstatic void update(void)\n{\n\tstatic bool first_update = true;\n\tint needs_view_update = 0;\n\tint needs_title_update = 0;\n\tint needs_status_update = 0;\n\tint needs_command_update = 0;\n\tint needs_spawn = 0;\n\n\tif (first_update) {\n\t\tneeds_title_update = 1;\n\t\tneeds_command_update = 1;\n\t\tfirst_update = false;\n\t}\n\n\tif (needs_to_resize) {\n\t\tupdate_window_size();\n\t\tneeds_title_update = 1;\n\t\tneeds_status_update = 1;\n\t\tneeds_command_update = 1;\n\t}\n\n\tif (player_info.status_changed)\n\t\tmpris_playback_status_changed();\n\n\tif (player_info.file_changed || player_info.metadata_changed)\n\t\tmpris_metadata_changed();\n\n\tneeds_spawn = player_info.status_changed || player_info.file_changed ||\n\t\tplayer_info.metadata_changed;\n\n\tif (player_info.file_changed) {\n\t\tneeds_title_update = 1;\n\t\tneeds_status_update = 1;\n\t}\n\tif (player_info.metadata_changed)\n\t\tneeds_title_update = 1;\n\tif (player_info.position_changed || player_info.status_changed)\n\t\tneeds_status_update = 1;\n\tswitch (cur_view) {\n\tcase TREE_VIEW:\n\t\tneeds_view_update += lib_tree_win->changed || lib_track_win->changed;\n\t\tbreak;\n\tcase SORTED_VIEW:\n\t\tneeds_view_update += lib_editable.shared->win->changed;\n\t\tbreak;\n\tcase PLAYLIST_VIEW:\n\t\tneeds_view_update += pl_needs_redraw();\n\t\tbreak;\n\tcase QUEUE_VIEW:\n\t\tneeds_view_update += pq_editable.shared->win->changed;\n\t\tbreak;\n\tcase BROWSER_VIEW:\n\t\tneeds_view_update += browser_win->changed;\n\t\tbreak;\n\tcase FILTERS_VIEW:\n\t\tneeds_view_update += filters_win->changed;\n\t\tbreak;\n\tcase HELP_VIEW:\n\t\tneeds_view_update += help_win->changed;\n\t\tbreak;\n\t}\n\n\t/* total time changed? */\n\tif (cmus_queue_active()) {\n\t\tneeds_status_update += queue_needs_redraw();\n\t} else if (play_library) {\n\t\tneeds_status_update += lib_editable.shared->win->changed;\n\t\tlib_editable.shared->win->changed = 0;\n\t} else {\n\t\tneeds_status_update += pl_needs_redraw();\n\t}\n\n\tif (needs_spawn)\n\t\tspawn_status_program();\n\n\tif (needs_view_update || needs_title_update || needs_status_update || needs_command_update) {\n\t\tcurs_set(0);\n\n\t\tif (needs_view_update)\n\t\t\tdo_update_view(0);\n\t\tif (needs_title_update)\n\t\t\tdo_update_titleline();\n\t\tif (needs_status_update)\n\t\t\tdo_update_statusline();\n\t\tif (needs_command_update)\n\t\t\tdo_update_commandline();\n\t\tpost_update();\n\t}\n\n\t/* Reset changed flags */\n\tqueue_post_update();\n}\n\nstatic void handle_ch(uchar ch)\n{\n\tclear_error();\n\tif (input_mode == NORMAL_MODE) {\n\t\tif (!block_key_paste || !in_bracketed_paste) {\n\t\t\tnormal_mode_ch(ch);\n\t\t}\n\t} else if (input_mode == COMMAND_MODE) {\n\t\tcommand_mode_ch(ch);\n\t\tupdate_commandline();\n\t} else if (input_mode == SEARCH_MODE) {\n\t\tsearch_mode_ch(ch);\n\t\tupdate_commandline();\n\t}\n}\n\nstatic void handle_csi(void) {\n\t// after ESC[ until 0x40-0x7E (@A–Z[\\]^_`a–z{|}~)\n\t// https://en.wikipedia.org/wiki/ANSI_escape_code#CSI_(Control_Sequence_Introducer)_sequences\n\t// https://www.ecma-international.org/wp-content/uploads/ECMA-48_5th_edition_june_1991.pdf\n\n\tint c;\n\tint buf[16]; // buffer a reasonable length\n\tsize_t buf_n = 0;\n\tint overflow = 0;\n\n\twhile (1) {\n\t\tc = getch();\n\t\tif (c == ERR || c == 0) {\n\t\t\treturn;\n\t\t}\n\t\tif (buf_n < sizeof(buf)/sizeof(*buf)) {\n\t\t\tbuf[buf_n++] = c;\n\t\t} else {\n\t\t\toverflow = 1;\n\t\t}\n\t\tif (c >= 0x40 && c <= 0x7E) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (overflow) {\n\t\treturn;\n\t}\n\n\tif (buf_n == 4) {\n\t\t// bracketed paste\n\t\t// https://invisible-island.net/xterm/ctlseqs/ctlseqs.html#h2-Bracketed-Paste-Mode\n\t\tif (buf[0] == '2' && buf[1] == '0' && (buf[2] == '0' || buf[2] == '1') && buf[3] == '~') {\n\t\t\tin_bracketed_paste = buf[2] == '0';\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic void handle_escape(int c)\n{\n\tclear_error();\n\tif (input_mode == NORMAL_MODE) {\n\t\tnormal_mode_ch(c + 128);\n\t} else if (input_mode == COMMAND_MODE) {\n\t\tcommand_mode_escape(c);\n\t\tupdate_commandline();\n\t} else if (input_mode == SEARCH_MODE) {\n\t\tsearch_mode_escape(c);\n\t\tupdate_commandline();\n\t}\n}\n\nstatic void handle_key(int key)\n{\n\tclear_error();\n\tif (input_mode == NORMAL_MODE) {\n\t\tif (!block_key_paste || !in_bracketed_paste) {\n\t\t\tnormal_mode_key(key);\n\t\t}\n\t} else if (input_mode == COMMAND_MODE) {\n\t\tcommand_mode_key(key);\n\t\tupdate_commandline();\n\t} else if (input_mode == SEARCH_MODE) {\n\t\tsearch_mode_key(key);\n\t\tupdate_commandline();\n\t}\n}\n\nstatic void handle_mouse(MEVENT *event)\n{\n#if NCURSES_MOUSE_VERSION <= 1\n\tstatic int last_mevent;\n\n\tif ((last_mevent & BUTTON1_PRESSED) && (event->bstate & REPORT_MOUSE_POSITION))\n\t\tevent->bstate = BUTTON1_RELEASED;\n\tlast_mevent = event->bstate;\n#endif\n\n\tclear_error();\n\tif (input_mode == NORMAL_MODE) {\n\t\tnormal_mode_mouse(event);\n\t} else if (input_mode == COMMAND_MODE) {\n\t\tcommand_mode_mouse(event);\n\t\tupdate_commandline();\n\t} else if (input_mode == SEARCH_MODE) {\n\t\tsearch_mode_mouse(event);\n\t\tupdate_commandline();\n\t}\n}\n\nstatic void u_getch(void)\n{\n\tint key;\n\tint bit = 7;\n\tint mask = (1 << 7);\n\tuchar u, ch;\n\n\tkey = getch();\n\tif (key == ERR || key == 0)\n\t\treturn;\n\n\tif (key == KEY_MOUSE) {\n\t\tMEVENT event;\n\t\tif (getmouse(&event) == OK)\n\t\t\thandle_mouse(&event);\n\t\treturn;\n\t}\n\n\tif (key > 255) {\n\t\thandle_key(key);\n\t\treturn;\n\t}\n\n\t/* escape sequence */\n\tif (key == 0x1B) {\n\t\tcbreak();\n\t\tint e_key = getch();\n\t\thalfdelay(5);\n\t\tif (e_key != ERR) {\n\t\t\tif (e_key == '[')\n\t\t\t\thandle_csi();\n\t\t\telse if (e_key != 0)\n\t\t\t\thandle_escape(e_key);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tch = (unsigned char)key;\n\twhile (bit > 0 && ch & mask) {\n\t\tmask >>= 1;\n\t\tbit--;\n\t}\n\tif (bit == 7) {\n\t\t/* ascii */\n\t\tu = ch;\n\t} else if (using_utf8) {\n\t\tint count;\n\n\t\tu = ch & ((1 << bit) - 1);\n\t\tcount = 6 - bit;\n\t\twhile (count) {\n\t\t\tkey = getch();\n\t\t\tif (key == ERR || key == 0)\n\t\t\t\treturn;\n\n\t\t\tch = (unsigned char)key;\n\t\t\tu = (u << 6) | (ch & 63);\n\t\t\tcount--;\n\t\t}\n\t} else\n\t\tu = ch | U_INVALID_MASK;\n\thandle_ch(u);\n}\n\nstatic void main_loop(void)\n{\n\tint rc, fd_high;\n\n#define SELECT_ADD_FD(fd) do {\\\n\tFD_SET((fd), &set); \\\n\tif ((fd) > fd_high) \\\n\t\tfd_high = (fd); \\\n} while(0)\n\n\tfd_high = server_socket;\n\twhile (cmus_running) {\n\t\tfd_set set;\n\t\tstruct timeval tv;\n\t\tint poll_mixer = 0;\n\t\tint i;\n\t\tint nr_fds_vol = 0, fds_vol[NR_MIXER_FDS];\n\t\tint nr_fds_out = 0, fds_out[NR_MIXER_FDS];\n\t\tstruct list_head *item;\n\t\tstruct client *client;\n\n\t\tplayer_info_snapshot();\n\n\t\tupdate();\n\n\t\t/* Timeout must be so small that screen updates seem instant.\n\t\t * Only affects changes done in other threads (player).\n\t\t *\n\t\t * Too small timeout makes window updates too fast (wastes CPU).\n\t\t *\n\t\t * Too large timeout makes status line (position) updates too slow.\n\t\t * The timeout is accuracy of player position.\n\t\t */\n\t\ttv.tv_sec = 0;\n\t\ttv.tv_usec = 0;\n\n\t\tif (player_info.status == PLAYER_STATUS_PLAYING) {\n\t\t\t// player position updates need to be fast\n\t\t\ttv.tv_usec = 100e3;\n\t\t}\n\n\t\tFD_ZERO(&set);\n\t\tSELECT_ADD_FD(0);\n\t\tSELECT_ADD_FD(job_fd);\n\t\tSELECT_ADD_FD(cmus_next_track_request_fd);\n\t\tSELECT_ADD_FD(server_socket);\n\t\tif (mpris_fd != -1)\n\t\t\tSELECT_ADD_FD(mpris_fd);\n\t\tlist_for_each_entry(client, &client_head, node) {\n\t\t\tSELECT_ADD_FD(client->fd);\n\t\t}\n\t\tif (!soft_vol) {\n\t\t\tnr_fds_vol = mixer_get_fds(MIXER_FDS_VOLUME, fds_vol);\n\t\t\tif (nr_fds_vol <= 0) {\n\t\t\t\tpoll_mixer = 1;\n\t\t\t\tif (!tv.tv_usec)\n\t\t\t\t\ttv.tv_usec = 500e3;\n\t\t\t}\n\t\t\tfor (i = 0; i < nr_fds_vol; i++) {\n\t\t\t\tBUG_ON(fds_vol[i] <= 0);\n\t\t\t\tSELECT_ADD_FD(fds_vol[i]);\n\t\t\t}\n\t\t}\n\n\t\tnr_fds_out = mixer_get_fds(MIXER_FDS_OUTPUT, fds_out);\n\t\tfor (i = 0; i < nr_fds_out; i++) {\n\t\t\tBUG_ON(fds_out[i] <= 0);\n\t\t\tSELECT_ADD_FD(fds_out[i]);\n\t\t}\n\n\t\trc = select(fd_high + 1, &set, NULL, NULL, tv.tv_usec ? &tv : NULL);\n\t\tif (poll_mixer) {\n\t\t\tint ol = volume_l;\n\t\t\tint or = volume_r;\n\n\t\t\tmixer_read_volume();\n\t\t\tif (ol != volume_l || or != volume_r) {\n\t\t\t\tmpris_volume_changed();\n\t\t\t\tupdate_statusline();\n\t\t\t}\n\n\t\t}\n\t\tif (rc <= 0) {\n\t\t\tif (ctrl_c_pressed) {\n\t\t\t\thandle_ch(0x03);\n\t\t\t\tctrl_c_pressed = 0;\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (i = 0; i < nr_fds_vol; i++) {\n\t\t\tif (FD_ISSET(fds_vol[i], &set)) {\n\t\t\t\td_print(\"vol changed\\n\");\n\t\t\t\tmixer_read_volume();\n\t\t\t\tmpris_volume_changed();\n\t\t\t\tupdate_statusline();\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < nr_fds_out; i++) {\n\t\t\tif (FD_ISSET(fds_out[i], &set)) {\n\t\t\t\td_print(\"out changed\\n\");\n\t\t\t\tif (pause_on_output_change) {\n\t\t\t\t\tplayer_pause_playback();\n\t\t\t\t\tupdate_statusline();\n\t\t\t\t}\n\t\t\t\tclear_pipe(fds_out[i], -1);\n\t\t\t}\n\t\t}\n\t\tif (FD_ISSET(server_socket, &set))\n\t\t\tserver_accept();\n\n\t\t// server_serve() can remove client from the list\n\t\titem = client_head.next;\n\t\twhile (item != &client_head) {\n\t\t\tstruct list_head *next = item->next;\n\t\t\tclient = container_of(item, struct client, node);\n\t\t\tif (FD_ISSET(client->fd, &set))\n\t\t\t\tserver_serve(client);\n\t\t\titem = next;\n\t\t}\n\n\t\tif (FD_ISSET(0, &set))\n\t\t\tu_getch();\n\n\t\tif (mpris_fd != -1 && FD_ISSET(mpris_fd, &set))\n\t\t\tmpris_process();\n\n\t\tif (FD_ISSET(job_fd, &set))\n\t\t\tjob_handle();\n\n\t\tif (FD_ISSET(cmus_next_track_request_fd, &set))\n\t\t\tcmus_provide_next_track();\n\t}\n}\n\nstatic void init_curses(void)\n{\n\tstruct sigaction act;\n\tchar *ptr, *term;\n\n\tsigemptyset(&act.sa_mask);\n\tact.sa_flags = 0;\n\tact.sa_handler = sig_int;\n\tsigaction(SIGINT, &act, NULL);\n\n\tsigemptyset(&act.sa_mask);\n\tact.sa_flags = 0;\n\tact.sa_handler = sig_shutdown;\n\tsigaction(SIGHUP, &act, NULL);\n\tsigaction(SIGTERM, &act, NULL);\n\n\tsigemptyset(&act.sa_mask);\n\tact.sa_flags = 0;\n\tact.sa_handler = SIG_IGN;\n\tsigaction(SIGPIPE, &act, NULL);\n\n\tsigemptyset(&act.sa_mask);\n\tact.sa_flags = 0;\n\tact.sa_handler = sig_winch;\n\tsigaction(SIGWINCH, &act, NULL);\n\n\tinitscr();\n\tnodelay(stdscr, TRUE);\n\tkeypad(stdscr, TRUE);\n\thalfdelay(5);\n\tnoecho();\n\n\tif (has_colors()) {\n#if HAVE_USE_DEFAULT_COLORS\n\t\tstart_color();\n\t\tuse_default_colors();\n#endif\n\t}\n\td_print(\"Number of supported colors: %d\\n\", COLORS);\n\tui_initialized = 1;\n\n\t/* this was disabled while initializing because it needs to be\n\t * called only once after all colors have been set\n\t */\n\tupdate_colors();\n\n\tptr = tcap_buffer;\n\tt_ts = tgetstr(\"ts\", &ptr);\n\tt_fs = tgetstr(\"fs\", &ptr);\n\td_print(\"ts: %d fs: %d\\n\", !!t_ts, !!t_fs);\n\n\tif (!t_fs)\n\t\tt_ts = NULL;\n\n\tterm = getenv(\"TERM\");\n\tif (!t_ts && term) {\n\t\t/*\n\t\t * Eterm:            Eterm\n\t\t * aterm:            rxvt\n\t\t * mlterm:           xterm\n\t\t * terminal (xfce):  xterm\n\t\t * urxvt:            rxvt-unicode\n\t\t * xterm:            xterm, xterm-{,16,88,256}color\n\t\t */\n\t\tif (!strcmp(term, \"screen\")) {\n\t\t\tt_ts = \"\\033_\";\n\t\t\tt_fs = \"\\033\\\\\";\n\t\t} else if (!strncmp(term, \"xterm\", 5) ||\n\t\t\t   !strncmp(term, \"rxvt\", 4) ||\n\t\t\t   !strcmp(term, \"Eterm\")) {\n\t\t\t/* \\033]1;  change icon\n\t\t\t * \\033]2;  change title\n\t\t\t * \\033]0;  change both\n\t\t\t */\n\t\t\tt_ts = \"\\033]0;\";\n\t\t\tt_fs = \"\\007\";\n\t\t}\n\t}\n\tupdate_mouse();\n\n\tif (!getenv(\"ESCDELAY\")) {\n\t\tset_escdelay(default_esc_delay);\n\t}\n\n\tupdate_window_size();\n}\n\nstatic void init_all(void)\n{\n\tmain_thread = pthread_self();\n\tcmus_track_request_init();\n\n\tserver_init(server_address);\n\n\t/* does not select output plugin */\n\tplayer_init();\n\n\t/* plugins have been loaded so we know what plugin options are available */\n\toptions_add();\n\n\t/* cache the normalized env vars for pl_env */\n\tpl_env_init();\n\n\tlib_init();\n\tsearchable = tree_searchable;\n\tcmus_init();\n\tpl_init();\n\tbrowser_init();\n\tfilters_init();\n\thelp_init();\n\tcmdline_init();\n\tcommands_init();\n\tsearch_mode_init();\n\n\t/* almost everything must be initialized now */\n\toptions_load();\n\tpl_init_options();\n\tif (mpris)\n\t\tmpris_init();\n\n\t/* finally we can set the output plugin */\n\tplayer_set_op(output_plugin);\n\tif (!soft_vol || pause_on_output_change)\n\t\tmixer_open();\n\n\tlib_autosave_filename = xstrjoin(cmus_config_dir, \"/lib.pl\");\n\tplay_queue_autosave_filename = xstrjoin(cmus_config_dir, \"/queue.pl\");\n\tlib_filename = xstrdup(lib_autosave_filename);\n\n\tif (error_count) {\n\t\tchar buf[16];\n\t\tchar *ret;\n\n\t\twarn(\"Press <enter> to continue.\");\n\n\t\tret = fgets(buf, sizeof(buf), stdin);\n\t\tBUG_ON(ret == NULL);\n\t}\n\thelp_add_all_unbound();\n\n\tinit_curses();\n\n\t// enable bracketed paste (will be ignored if not supported)\n\tprintf(\"\\033[?2004h\");\n\tfflush(stdout);\n\n\tif (resume_cmus) {\n\t\tresume_load();\n\t\tcmus_add(play_queue_append, play_queue_autosave_filename,\n\t\t\t\tFILE_TYPE_PL, JOB_TYPE_QUEUE, 0, NULL);\n\t} else {\n\t\tset_view(start_view);\n\t}\n\n\tcmus_add(lib_add_track, lib_autosave_filename, FILE_TYPE_PL,\n\t\t\tJOB_TYPE_LIB, 0, NULL);\n\n\tworker_start();\n}\n\nstatic void exit_all(void)\n{\n\tendwin();\n\n\t// disable bracketed paste\n\tprintf(\"\\033[?2004l\");\n\tfflush(stdout);\n\n\tif (resume_cmus)\n\t\tresume_exit();\n\toptions_exit();\n\n\tserver_exit();\n\tcmus_exit();\n\tif (resume_cmus)\n\t\tcmus_save(play_queue_for_each, play_queue_autosave_filename,\n\t\t\t\tNULL);\n\tcmus_save(lib_for_each, lib_autosave_filename, NULL);\n\n\tpl_exit();\n\tplayer_exit();\n\top_exit_plugins();\n\tcommands_exit();\n\tsearch_mode_exit();\n\tfilters_exit();\n\thelp_exit();\n\tbrowser_exit();\n\tmpris_free();\n}\n\nenum {\n\tFLAG_LISTEN,\n\tFLAG_PLUGINS,\n\tFLAG_SHOW_CURSOR,\n\tFLAG_HELP,\n\tFLAG_VERSION,\n\tNR_FLAGS\n};\n\nstatic struct option options[NR_FLAGS + 1] = {\n\t{ 0, \"listen\", 1 },\n\t{ 0, \"plugins\", 0 },\n\t{ 0, \"show-cursor\", 0 },\n\t{ 0, \"help\", 0 },\n\t{ 0, \"version\", 0 },\n\t{ 0, NULL, 0 }\n};\n\nstatic const char *usage =\n\"Usage: %s [OPTION]...\\n\"\n\"Curses based music player.\\n\"\n\"\\n\"\n\"      --listen ADDR   listen on ADDR instead of $CMUS_SOCKET or $XDG_RUNTIME_DIR/cmus-socket\\n\"\n\"                      ADDR is either a UNIX socket or host[:port]\\n\"\n\"                      WARNING: using TCP/IP is insecure!\\n\"\n\"      --plugins       list available plugins and exit\\n\"\n\"      --show-cursor   always visible cursor\\n\"\n\"      --help          display this help and exit\\n\"\n\"      --version       \" VERSION \"\\n\"\n\"\\n\"\n\"Use cmus-remote to control cmus from command line.\\n\"\n\"Report bugs to <cmus-devel@lists.sourceforge.net>.\\n\";\n\nint main(int argc, char *argv[])\n{\n\tint list_plugins = 0;\n\n\tprogram_name = argv[0];\n\targv++;\n\twhile (1) {\n\t\tint idx;\n\t\tchar *arg;\n\n\t\tidx = get_option(&argv, options, &arg);\n\t\tif (idx < 0)\n\t\t\tbreak;\n\n\t\tswitch (idx) {\n\t\tcase FLAG_HELP:\n\t\t\tprintf(usage, program_name);\n\t\t\treturn 0;\n\t\tcase FLAG_VERSION:\n\t\t\tprintf(\"cmus \" VERSION\n\t\t\t       \"\\nCopyright 2004-2006 Timo Hirvonen\"\n\t\t\t       \"\\nCopyright 2008-2016 Various Authors\\n\");\n\t\t\treturn 0;\n\t\tcase FLAG_PLUGINS:\n\t\t\tlist_plugins = 1;\n\t\t\tbreak;\n\t\tcase FLAG_LISTEN:\n\t\t\tserver_address = xstrdup(arg);\n\t\t\tbreak;\n\t\tcase FLAG_SHOW_CURSOR:\n\t\t\tshow_cursor = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tsetlocale(LC_CTYPE, \"\");\n\tsetlocale(LC_COLLATE, \"\");\n\tcharset = getenv(\"CMUS_CHARSET\");\n\tif (!charset || !charset[0]) {\n#ifdef CODESET\n\t\tcharset = nl_langinfo(CODESET);\n#else\n\t\tcharset = \"ISO-8859-1\";\n#endif\n\t}\n\tif (strcmp(charset, \"UTF-8\") == 0)\n\t\tusing_utf8 = 1;\n\n\tmisc_init();\n\tif (server_address == NULL)\n\t\tserver_address = xstrdup(cmus_socket_path);\n\tdebug_init();\n\td_print(\"charset = '%s'\\n\", charset);\n\n\tip_load_plugins();\n\top_load_plugins();\n\tif (list_plugins) {\n\t\tip_dump_plugins();\n\t\top_dump_plugins();\n\t\treturn 0;\n\t}\n\tinit_all();\n\tmain_loop();\n\texit_all();\n\tspawn_status_program_inner(\"exiting\", NULL);\n\treturn 0;\n}\n"
        },
        {
          "name": "ui_curses.h",
          "type": "blob",
          "size": 2.1474609375,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004-2006 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_UI_CURSES_H\n#define CMUS_UI_CURSES_H\n\n#include \"search.h\"\n#include \"compiler.h\"\n#include \"format_print.h\"\n\nenum ui_input_mode {\n\tNORMAL_MODE,\n\tCOMMAND_MODE,\n\tSEARCH_MODE\n};\n\nenum ui_query_answer {\n\tUI_QUERY_ANSWER_ERROR = -1,\n\tUI_QUERY_ANSWER_NO = 0,\n\tUI_QUERY_ANSWER_YES = 1\n};\n\n#include <signal.h>\n\nextern volatile sig_atomic_t cmus_running;\nextern int ui_initialized;\nextern enum ui_input_mode input_mode;\nextern int cur_view;\nextern int prev_view;\nextern struct searchable *searchable;\n\nextern char *lib_filename;\nextern char *lib_ext_filename;\nextern char *pl_filename;\nextern char *play_queue_filename;\nextern char *play_queue_ext_filename;\n\nextern char *charset;\nextern int using_utf8;\n\nvoid update_titleline(void);\nvoid update_statusline(void);\nvoid update_filterline(void);\nvoid update_colors(void);\nvoid update_full(void);\nvoid update_size(void);\nvoid info_msg(const char *format, ...) CMUS_FORMAT(1, 2);\nvoid error_msg(const char *format, ...) CMUS_FORMAT(1, 2);\nenum ui_query_answer yes_no_query(const char *format, ...) CMUS_FORMAT(1, 2);\nvoid search_not_found(void);\nvoid set_view(int view);\nvoid set_client_fd(int fd);\nint get_client_fd(void);\nvoid enter_command_mode(void);\nvoid enter_search_mode(void);\nvoid enter_search_backward_mode(void);\n\nint track_format_valid(const char *format);\n\n/* lock player_info ! */\nconst char *get_stream_title(void);\nconst struct format_option *get_global_fopts(void);\n\nint get_track_win_x(void);\n\n#endif\n"
        },
        {
          "name": "unidecomp.h",
          "type": "blob",
          "size": 40.083984375,
          "content": "/* This file is automatically generated. DO NOT EDIT!\nInstead, edit gen_decomp.py and re-run. */\n\nstatic struct {\n\tuchar composed;\n\tuchar base;\n} unidecomp_map[] = {\n\t{   0xc0,   0x41 },\t// À -> A,\t ̀ (300)\n\t{   0xc1,   0x41 },\t// Á -> A,\t ́ (301)\n\t{   0xc2,   0x41 },\t// Â -> A,\t ̂ (302)\n\t{   0xc3,   0x41 },\t// Ã -> A,\t ̃ (303)\n\t{   0xc4,   0x41 },\t// Ä -> A,\t ̈ (308)\n\t{   0xc5,   0x41 },\t// Å -> A,\t ̊ (30a)\n\t{   0xc6,   0x41 },\t// Æ -> A,\n\t{   0xc7,   0x43 },\t// Ç -> C,\t ̧ (327)\n\t{   0xc8,   0x45 },\t// È -> E,\t ̀ (300)\n\t{   0xc9,   0x45 },\t// É -> E,\t ́ (301)\n\t{   0xca,   0x45 },\t// Ê -> E,\t ̂ (302)\n\t{   0xcb,   0x45 },\t// Ë -> E,\t ̈ (308)\n\t{   0xcc,   0x49 },\t// Ì -> I,\t ̀ (300)\n\t{   0xcd,   0x49 },\t// Í -> I,\t ́ (301)\n\t{   0xce,   0x49 },\t// Î -> I,\t ̂ (302)\n\t{   0xcf,   0x49 },\t// Ï -> I,\t ̈ (308)\n\t{   0xd0,   0x44 },\t// Ð -> D,\n\t{   0xd1,   0x4e },\t// Ñ -> N,\t ̃ (303)\n\t{   0xd2,   0x4f },\t// Ò -> O,\t ̀ (300)\n\t{   0xd3,   0x4f },\t// Ó -> O,\t ́ (301)\n\t{   0xd4,   0x4f },\t// Ô -> O,\t ̂ (302)\n\t{   0xd5,   0x4f },\t// Õ -> O,\t ̃ (303)\n\t{   0xd6,   0x4f },\t// Ö -> O,\t ̈ (308)\n\t{   0xd7,   0x78 },\t// × -> x,\n\t{   0xd8,   0x4f },\t// Ø -> O,\n\t{   0xd9,   0x55 },\t// Ù -> U,\t ̀ (300)\n\t{   0xda,   0x55 },\t// Ú -> U,\t ́ (301)\n\t{   0xdb,   0x55 },\t// Û -> U,\t ̂ (302)\n\t{   0xdc,   0x55 },\t// Ü -> U,\t ̈ (308)\n\t{   0xdd,   0x59 },\t// Ý -> Y,\t ́ (301)\n\t{   0xde,   0x50 },\t// Þ -> P,\n\t{   0xdf,   0x42 },\t// ß -> B,\n\t{   0xe0,   0x61 },\t// à -> a,\t ̀ (300)\n\t{   0xe1,   0x61 },\t// á -> a,\t ́ (301)\n\t{   0xe2,   0x61 },\t// â -> a,\t ̂ (302)\n\t{   0xe3,   0x61 },\t// ã -> a,\t ̃ (303)\n\t{   0xe4,   0x61 },\t// ä -> a,\t ̈ (308)\n\t{   0xe5,   0x61 },\t// å -> a,\t ̊ (30a)\n\t{   0xe6,   0x61 },\t// æ -> a,\n\t{   0xe7,   0x63 },\t// ç -> c,\t ̧ (327)\n\t{   0xe8,   0x65 },\t// è -> e,\t ̀ (300)\n\t{   0xe9,   0x65 },\t// é -> e,\t ́ (301)\n\t{   0xea,   0x65 },\t// ê -> e,\t ̂ (302)\n\t{   0xeb,   0x65 },\t// ë -> e,\t ̈ (308)\n\t{   0xec,   0x69 },\t// ì -> i,\t ̀ (300)\n\t{   0xed,   0x69 },\t// í -> i,\t ́ (301)\n\t{   0xee,   0x69 },\t// î -> i,\t ̂ (302)\n\t{   0xef,   0x69 },\t// ï -> i,\t ̈ (308)\n\t{   0xf0,   0x64 },\t// ð -> d,\n\t{   0xf1,   0x6e },\t// ñ -> n,\t ̃ (303)\n\t{   0xf2,   0x6f },\t// ò -> o,\t ̀ (300)\n\t{   0xf3,   0x6f },\t// ó -> o,\t ́ (301)\n\t{   0xf4,   0x6f },\t// ô -> o,\t ̂ (302)\n\t{   0xf5,   0x6f },\t// õ -> o,\t ̃ (303)\n\t{   0xf6,   0x6f },\t// ö -> o,\t ̈ (308)\n\t{   0xf8,   0x6f },\t// ø -> o,\n\t{   0xf9,   0x75 },\t// ù -> u,\t ̀ (300)\n\t{   0xfa,   0x75 },\t// ú -> u,\t ́ (301)\n\t{   0xfb,   0x75 },\t// û -> u,\t ̂ (302)\n\t{   0xfc,   0x75 },\t// ü -> u,\t ̈ (308)\n\t{   0xfd,   0x79 },\t// ý -> y,\t ́ (301)\n\t{   0xfe,   0x70 },\t// þ -> p,\n\t{   0xff,   0x79 },\t// ÿ -> y,\t ̈ (308)\n\t{  0x100,   0x41 },\t// Ā -> A,\t ̄ (304)\n\t{  0x101,   0x61 },\t// ā -> a,\t ̄ (304)\n\t{  0x102,   0x41 },\t// Ă -> A,\t ̆ (306)\n\t{  0x103,   0x61 },\t// ă -> a,\t ̆ (306)\n\t{  0x104,   0x41 },\t// Ą -> A,\t ̨ (328)\n\t{  0x105,   0x61 },\t// ą -> a,\t ̨ (328)\n\t{  0x106,   0x43 },\t// Ć -> C,\t ́ (301)\n\t{  0x107,   0x63 },\t// ć -> c,\t ́ (301)\n\t{  0x108,   0x43 },\t// Ĉ -> C,\t ̂ (302)\n\t{  0x109,   0x63 },\t// ĉ -> c,\t ̂ (302)\n\t{  0x10a,   0x43 },\t// Ċ -> C,\t ̇ (307)\n\t{  0x10b,   0x63 },\t// ċ -> c,\t ̇ (307)\n\t{  0x10c,   0x43 },\t// Č -> C,\t ̌ (30c)\n\t{  0x10d,   0x63 },\t// č -> c,\t ̌ (30c)\n\t{  0x10e,   0x44 },\t// Ď -> D,\t ̌ (30c)\n\t{  0x10f,   0x64 },\t// ď -> d,\t ̌ (30c)\n\t{  0x112,   0x45 },\t// Ē -> E,\t ̄ (304)\n\t{  0x113,   0x65 },\t// ē -> e,\t ̄ (304)\n\t{  0x114,   0x45 },\t// Ĕ -> E,\t ̆ (306)\n\t{  0x115,   0x65 },\t// ĕ -> e,\t ̆ (306)\n\t{  0x116,   0x45 },\t// Ė -> E,\t ̇ (307)\n\t{  0x117,   0x65 },\t// ė -> e,\t ̇ (307)\n\t{  0x118,   0x45 },\t// Ę -> E,\t ̨ (328)\n\t{  0x119,   0x65 },\t// ę -> e,\t ̨ (328)\n\t{  0x11a,   0x45 },\t// Ě -> E,\t ̌ (30c)\n\t{  0x11b,   0x65 },\t// ě -> e,\t ̌ (30c)\n\t{  0x11c,   0x47 },\t// Ĝ -> G,\t ̂ (302)\n\t{  0x11d,   0x67 },\t// ĝ -> g,\t ̂ (302)\n\t{  0x11e,   0x47 },\t// Ğ -> G,\t ̆ (306)\n\t{  0x11f,   0x67 },\t// ğ -> g,\t ̆ (306)\n\t{  0x120,   0x47 },\t// Ġ -> G,\t ̇ (307)\n\t{  0x121,   0x67 },\t// ġ -> g,\t ̇ (307)\n\t{  0x122,   0x47 },\t// Ģ -> G,\t ̧ (327)\n\t{  0x123,   0x67 },\t// ģ -> g,\t ̧ (327)\n\t{  0x124,   0x48 },\t// Ĥ -> H,\t ̂ (302)\n\t{  0x125,   0x68 },\t// ĥ -> h,\t ̂ (302)\n\t{  0x128,   0x49 },\t// Ĩ -> I,\t ̃ (303)\n\t{  0x129,   0x69 },\t// ĩ -> i,\t ̃ (303)\n\t{  0x12a,   0x49 },\t// Ī -> I,\t ̄ (304)\n\t{  0x12b,   0x69 },\t// ī -> i,\t ̄ (304)\n\t{  0x12c,   0x49 },\t// Ĭ -> I,\t ̆ (306)\n\t{  0x12d,   0x69 },\t// ĭ -> i,\t ̆ (306)\n\t{  0x12e,   0x49 },\t// Į -> I,\t ̨ (328)\n\t{  0x12f,   0x69 },\t// į -> i,\t ̨ (328)\n\t{  0x130,   0x49 },\t// İ -> I,\t ̇ (307)\n\t{  0x134,   0x4a },\t// Ĵ -> J,\t ̂ (302)\n\t{  0x135,   0x6a },\t// ĵ -> j,\t ̂ (302)\n\t{  0x136,   0x4b },\t// Ķ -> K,\t ̧ (327)\n\t{  0x137,   0x6b },\t// ķ -> k,\t ̧ (327)\n\t{  0x139,   0x4c },\t// Ĺ -> L,\t ́ (301)\n\t{  0x13a,   0x6c },\t// ĺ -> l,\t ́ (301)\n\t{  0x13b,   0x4c },\t// Ļ -> L,\t ̧ (327)\n\t{  0x13c,   0x6c },\t// ļ -> l,\t ̧ (327)\n\t{  0x13d,   0x4c },\t// Ľ -> L,\t ̌ (30c)\n\t{  0x13e,   0x6c },\t// ľ -> l,\t ̌ (30c)\n\t{  0x143,   0x4e },\t// Ń -> N,\t ́ (301)\n\t{  0x144,   0x6e },\t// ń -> n,\t ́ (301)\n\t{  0x145,   0x4e },\t// Ņ -> N,\t ̧ (327)\n\t{  0x146,   0x6e },\t// ņ -> n,\t ̧ (327)\n\t{  0x147,   0x4e },\t// Ň -> N,\t ̌ (30c)\n\t{  0x148,   0x6e },\t// ň -> n,\t ̌ (30c)\n\t{  0x14c,   0x4f },\t// Ō -> O,\t ̄ (304)\n\t{  0x14d,   0x6f },\t// ō -> o,\t ̄ (304)\n\t{  0x14e,   0x4f },\t// Ŏ -> O,\t ̆ (306)\n\t{  0x14f,   0x6f },\t// ŏ -> o,\t ̆ (306)\n\t{  0x150,   0x4f },\t// Ő -> O,\t ̋ (30b)\n\t{  0x151,   0x6f },\t// ő -> o,\t ̋ (30b)\n\t{  0x154,   0x52 },\t// Ŕ -> R,\t ́ (301)\n\t{  0x155,   0x72 },\t// ŕ -> r,\t ́ (301)\n\t{  0x156,   0x52 },\t// Ŗ -> R,\t ̧ (327)\n\t{  0x157,   0x72 },\t// ŗ -> r,\t ̧ (327)\n\t{  0x158,   0x52 },\t// Ř -> R,\t ̌ (30c)\n\t{  0x159,   0x72 },\t// ř -> r,\t ̌ (30c)\n\t{  0x15a,   0x53 },\t// Ś -> S,\t ́ (301)\n\t{  0x15b,   0x73 },\t// ś -> s,\t ́ (301)\n\t{  0x15c,   0x53 },\t// Ŝ -> S,\t ̂ (302)\n\t{  0x15d,   0x73 },\t// ŝ -> s,\t ̂ (302)\n\t{  0x15e,   0x53 },\t// Ş -> S,\t ̧ (327)\n\t{  0x15f,   0x73 },\t// ş -> s,\t ̧ (327)\n\t{  0x160,   0x53 },\t// Š -> S,\t ̌ (30c)\n\t{  0x161,   0x73 },\t// š -> s,\t ̌ (30c)\n\t{  0x162,   0x54 },\t// Ţ -> T,\t ̧ (327)\n\t{  0x163,   0x74 },\t// ţ -> t,\t ̧ (327)\n\t{  0x164,   0x54 },\t// Ť -> T,\t ̌ (30c)\n\t{  0x165,   0x74 },\t// ť -> t,\t ̌ (30c)\n\t{  0x168,   0x55 },\t// Ũ -> U,\t ̃ (303)\n\t{  0x169,   0x75 },\t// ũ -> u,\t ̃ (303)\n\t{  0x16a,   0x55 },\t// Ū -> U,\t ̄ (304)\n\t{  0x16b,   0x75 },\t// ū -> u,\t ̄ (304)\n\t{  0x16c,   0x55 },\t// Ŭ -> U,\t ̆ (306)\n\t{  0x16d,   0x75 },\t// ŭ -> u,\t ̆ (306)\n\t{  0x16e,   0x55 },\t// Ů -> U,\t ̊ (30a)\n\t{  0x16f,   0x75 },\t// ů -> u,\t ̊ (30a)\n\t{  0x170,   0x55 },\t// Ű -> U,\t ̋ (30b)\n\t{  0x171,   0x75 },\t// ű -> u,\t ̋ (30b)\n\t{  0x172,   0x55 },\t// Ų -> U,\t ̨ (328)\n\t{  0x173,   0x75 },\t// ų -> u,\t ̨ (328)\n\t{  0x174,   0x57 },\t// Ŵ -> W,\t ̂ (302)\n\t{  0x175,   0x77 },\t// ŵ -> w,\t ̂ (302)\n\t{  0x176,   0x59 },\t// Ŷ -> Y,\t ̂ (302)\n\t{  0x177,   0x79 },\t// ŷ -> y,\t ̂ (302)\n\t{  0x178,   0x59 },\t// Ÿ -> Y,\t ̈ (308)\n\t{  0x179,   0x5a },\t// Ź -> Z,\t ́ (301)\n\t{  0x17a,   0x7a },\t// ź -> z,\t ́ (301)\n\t{  0x17b,   0x5a },\t// Ż -> Z,\t ̇ (307)\n\t{  0x17c,   0x7a },\t// ż -> z,\t ̇ (307)\n\t{  0x17d,   0x5a },\t// Ž -> Z,\t ̌ (30c)\n\t{  0x17e,   0x7a },\t// ž -> z,\t ̌ (30c)\n\t{  0x1a0,   0x4f },\t// Ơ -> O,\t ̛ (31b)\n\t{  0x1a1,   0x6f },\t// ơ -> o,\t ̛ (31b)\n\t{  0x1af,   0x55 },\t// Ư -> U,\t ̛ (31b)\n\t{  0x1b0,   0x75 },\t// ư -> u,\t ̛ (31b)\n\t{  0x1c4,   0x44 },\t// Ǆ -> D,\t Z (5a),  ̌ (30c)\n\t{  0x1c5,   0x44 },\t// ǅ -> D,\t z (7a),  ̌ (30c)\n\t{  0x1c6,   0x64 },\t// ǆ -> d,\t z (7a),  ̌ (30c)\n\t{  0x1cd,   0x41 },\t// Ǎ -> A,\t ̌ (30c)\n\t{  0x1ce,   0x61 },\t// ǎ -> a,\t ̌ (30c)\n\t{  0x1cf,   0x49 },\t// Ǐ -> I,\t ̌ (30c)\n\t{  0x1d0,   0x69 },\t// ǐ -> i,\t ̌ (30c)\n\t{  0x1d1,   0x4f },\t// Ǒ -> O,\t ̌ (30c)\n\t{  0x1d2,   0x6f },\t// ǒ -> o,\t ̌ (30c)\n\t{  0x1d3,   0x55 },\t// Ǔ -> U,\t ̌ (30c)\n\t{  0x1d4,   0x75 },\t// ǔ -> u,\t ̌ (30c)\n\t{  0x1d5,   0x55 },\t// Ǖ -> U,\t ̈ (308),  ̄ (304)\n\t{  0x1d6,   0x75 },\t// ǖ -> u,\t ̈ (308),  ̄ (304)\n\t{  0x1d7,   0x55 },\t// Ǘ -> U,\t ̈ (308),  ́ (301)\n\t{  0x1d8,   0x75 },\t// ǘ -> u,\t ̈ (308),  ́ (301)\n\t{  0x1d9,   0x55 },\t// Ǚ -> U,\t ̈ (308),  ̌ (30c)\n\t{  0x1da,   0x75 },\t// ǚ -> u,\t ̈ (308),  ̌ (30c)\n\t{  0x1db,   0x55 },\t// Ǜ -> U,\t ̈ (308),  ̀ (300)\n\t{  0x1dc,   0x75 },\t// ǜ -> u,\t ̈ (308),  ̀ (300)\n\t{  0x1de,   0x41 },\t// Ǟ -> A,\t ̈ (308),  ̄ (304)\n\t{  0x1df,   0x61 },\t// ǟ -> a,\t ̈ (308),  ̄ (304)\n\t{  0x1e0,   0x41 },\t// Ǡ -> A,\t ̇ (307),  ̄ (304)\n\t{  0x1e1,   0x61 },\t// ǡ -> a,\t ̇ (307),  ̄ (304)\n\t{  0x1e2,   0x41 },\t// Ǣ -> A,\t ̄ (304)\n\t{  0x1e3,   0x61 },\t// ǣ -> a,\t ̄ (304)\n\t{  0x1e6,   0x47 },\t// Ǧ -> G,\t ̌ (30c)\n\t{  0x1e7,   0x67 },\t// ǧ -> g,\t ̌ (30c)\n\t{  0x1e8,   0x4b },\t// Ǩ -> K,\t ̌ (30c)\n\t{  0x1e9,   0x6b },\t// ǩ -> k,\t ̌ (30c)\n\t{  0x1ea,   0x4f },\t// Ǫ -> O,\t ̨ (328)\n\t{  0x1eb,   0x6f },\t// ǫ -> o,\t ̨ (328)\n\t{  0x1ec,   0x4f },\t// Ǭ -> O,\t ̨ (328),  ̄ (304)\n\t{  0x1ed,   0x6f },\t// ǭ -> o,\t ̨ (328),  ̄ (304)\n\t{  0x1ee,  0x1b7 },\t// Ǯ -> Ʒ,\t ̌ (30c)\n\t{  0x1ef,  0x292 },\t// ǯ -> ʒ,\t ̌ (30c)\n\t{  0x1f0,   0x6a },\t// ǰ -> j,\t ̌ (30c)\n\t{  0x1f4,   0x47 },\t// Ǵ -> G,\t ́ (301)\n\t{  0x1f5,   0x67 },\t// ǵ -> g,\t ́ (301)\n\t{  0x1f8,   0x4e },\t// Ǹ -> N,\t ̀ (300)\n\t{  0x1f9,   0x6e },\t// ǹ -> n,\t ̀ (300)\n\t{  0x1fa,   0x41 },\t// Ǻ -> A,\t ̊ (30a),  ́ (301)\n\t{  0x1fb,   0x61 },\t// ǻ -> a,\t ̊ (30a),  ́ (301)\n\t{  0x1fc,   0x41 },\t// Ǽ -> A,\t ́ (301)\n\t{  0x1fd,   0x61 },\t// ǽ -> a,\t ́ (301)\n\t{  0x1fe,   0x4f },\t// Ǿ -> O,\t ́ (301)\n\t{  0x1ff,   0x6f },\t// ǿ -> o,\t ́ (301)\n\t{  0x200,   0x41 },\t// Ȁ -> A,\t ̏ (30f)\n\t{  0x201,   0x61 },\t// ȁ -> a,\t ̏ (30f)\n\t{  0x202,   0x41 },\t// Ȃ -> A,\t ̑ (311)\n\t{  0x203,   0x61 },\t// ȃ -> a,\t ̑ (311)\n\t{  0x204,   0x45 },\t// Ȅ -> E,\t ̏ (30f)\n\t{  0x205,   0x65 },\t// ȅ -> e,\t ̏ (30f)\n\t{  0x206,   0x45 },\t// Ȇ -> E,\t ̑ (311)\n\t{  0x207,   0x65 },\t// ȇ -> e,\t ̑ (311)\n\t{  0x208,   0x49 },\t// Ȉ -> I,\t ̏ (30f)\n\t{  0x209,   0x69 },\t// ȉ -> i,\t ̏ (30f)\n\t{  0x20a,   0x49 },\t// Ȋ -> I,\t ̑ (311)\n\t{  0x20b,   0x69 },\t// ȋ -> i,\t ̑ (311)\n\t{  0x20c,   0x4f },\t// Ȍ -> O,\t ̏ (30f)\n\t{  0x20d,   0x6f },\t// ȍ -> o,\t ̏ (30f)\n\t{  0x20e,   0x4f },\t// Ȏ -> O,\t ̑ (311)\n\t{  0x20f,   0x6f },\t// ȏ -> o,\t ̑ (311)\n\t{  0x210,   0x52 },\t// Ȑ -> R,\t ̏ (30f)\n\t{  0x211,   0x72 },\t// ȑ -> r,\t ̏ (30f)\n\t{  0x212,   0x52 },\t// Ȓ -> R,\t ̑ (311)\n\t{  0x213,   0x72 },\t// ȓ -> r,\t ̑ (311)\n\t{  0x214,   0x55 },\t// Ȕ -> U,\t ̏ (30f)\n\t{  0x215,   0x75 },\t// ȕ -> u,\t ̏ (30f)\n\t{  0x216,   0x55 },\t// Ȗ -> U,\t ̑ (311)\n\t{  0x217,   0x75 },\t// ȗ -> u,\t ̑ (311)\n\t{  0x218,   0x53 },\t// Ș -> S,\t ̦ (326)\n\t{  0x219,   0x73 },\t// ș -> s,\t ̦ (326)\n\t{  0x21a,   0x54 },\t// Ț -> T,\t ̦ (326)\n\t{  0x21b,   0x74 },\t// ț -> t,\t ̦ (326)\n\t{  0x21e,   0x48 },\t// Ȟ -> H,\t ̌ (30c)\n\t{  0x21f,   0x68 },\t// ȟ -> h,\t ̌ (30c)\n\t{  0x226,   0x41 },\t// Ȧ -> A,\t ̇ (307)\n\t{  0x227,   0x61 },\t// ȧ -> a,\t ̇ (307)\n\t{  0x228,   0x45 },\t// Ȩ -> E,\t ̧ (327)\n\t{  0x229,   0x65 },\t// ȩ -> e,\t ̧ (327)\n\t{  0x22a,   0x4f },\t// Ȫ -> O,\t ̈ (308),  ̄ (304)\n\t{  0x22b,   0x6f },\t// ȫ -> o,\t ̈ (308),  ̄ (304)\n\t{  0x22c,   0x4f },\t// Ȭ -> O,\t ̃ (303),  ̄ (304)\n\t{  0x22d,   0x6f },\t// ȭ -> o,\t ̃ (303),  ̄ (304)\n\t{  0x22e,   0x4f },\t// Ȯ -> O,\t ̇ (307)\n\t{  0x22f,   0x6f },\t// ȯ -> o,\t ̇ (307)\n\t{  0x230,   0x4f },\t// Ȱ -> O,\t ̇ (307),  ̄ (304)\n\t{  0x231,   0x6f },\t// ȱ -> o,\t ̇ (307),  ̄ (304)\n\t{  0x232,   0x59 },\t// Ȳ -> Y,\t ̄ (304)\n\t{  0x233,   0x79 },\t// ȳ -> y,\t ̄ (304)\n\t{  0x386,  0x391 },\t// Ά -> Α,\t ́ (301)\n\t{  0x388,  0x395 },\t// Έ -> Ε,\t ́ (301)\n\t{  0x389,  0x397 },\t// Ή -> Η,\t ́ (301)\n\t{  0x38a,  0x399 },\t// Ί -> Ι,\t ́ (301)\n\t{  0x38c,  0x39f },\t// Ό -> Ο,\t ́ (301)\n\t{  0x38e,  0x3a5 },\t// Ύ -> Υ,\t ́ (301)\n\t{  0x38f,  0x3a9 },\t// Ώ -> Ω,\t ́ (301)\n\t{  0x390,  0x3b9 },\t// ΐ -> ι,\t ̈ (308),  ́ (301)\n\t{  0x3aa,  0x399 },\t// Ϊ -> Ι,\t ̈ (308)\n\t{  0x3ab,  0x3a5 },\t// Ϋ -> Υ,\t ̈ (308)\n\t{  0x3ac,  0x3b1 },\t// ά -> α,\t ́ (301)\n\t{  0x3ad,  0x3b5 },\t// έ -> ε,\t ́ (301)\n\t{  0x3ae,  0x3b7 },\t// ή -> η,\t ́ (301)\n\t{  0x3af,  0x3b9 },\t// ί -> ι,\t ́ (301)\n\t{  0x3b0,  0x3c5 },\t// ΰ -> υ,\t ̈ (308),  ́ (301)\n\t{  0x3ca,  0x3b9 },\t// ϊ -> ι,\t ̈ (308)\n\t{  0x3cb,  0x3c5 },\t// ϋ -> υ,\t ̈ (308)\n\t{  0x3cc,  0x3bf },\t// ό -> ο,\t ́ (301)\n\t{  0x3cd,  0x3c5 },\t// ύ -> υ,\t ́ (301)\n\t{  0x3ce,  0x3c9 },\t// ώ -> ω,\t ́ (301)\n\t{  0x3d3,  0x3a5 },\t// ϓ -> Υ,\t ́ (301)\n\t{  0x3d4,  0x3a5 },\t// ϔ -> Υ,\t ̈ (308)\n\t{  0x400,  0x415 },\t// Ѐ -> Е,\t ̀ (300)\n\t{  0x401,  0x415 },\t// Ё -> Е,\t ̈ (308)\n\t{  0x403,  0x413 },\t// Ѓ -> Г,\t ́ (301)\n\t{  0x407,  0x406 },\t// Ї -> І,\t ̈ (308)\n\t{  0x40c,  0x41a },\t// Ќ -> К,\t ́ (301)\n\t{  0x40d,  0x418 },\t// Ѝ -> И,\t ̀ (300)\n\t{  0x40e,  0x423 },\t// Ў -> У,\t ̆ (306)\n\t{  0x419,  0x418 },\t// Й -> И,\t ̆ (306)\n\t{  0x439,  0x438 },\t// й -> и,\t ̆ (306)\n\t{  0x450,  0x435 },\t// ѐ -> е,\t ̀ (300)\n\t{  0x451,  0x435 },\t// ё -> е,\t ̈ (308)\n\t{  0x453,  0x433 },\t// ѓ -> г,\t ́ (301)\n\t{  0x457,  0x456 },\t// ї -> і,\t ̈ (308)\n\t{  0x45c,  0x43a },\t// ќ -> к,\t ́ (301)\n\t{  0x45d,  0x438 },\t// ѝ -> и,\t ̀ (300)\n\t{  0x45e,  0x443 },\t// ў -> у,\t ̆ (306)\n\t{  0x476,  0x474 },\t// Ѷ -> Ѵ,\t ̏ (30f)\n\t{  0x477,  0x475 },\t// ѷ -> ѵ,\t ̏ (30f)\n\t{  0x4c1,  0x416 },\t// Ӂ -> Ж,\t ̆ (306)\n\t{  0x4c2,  0x436 },\t// ӂ -> ж,\t ̆ (306)\n\t{  0x4d0,  0x410 },\t// Ӑ -> А,\t ̆ (306)\n\t{  0x4d1,  0x430 },\t// ӑ -> а,\t ̆ (306)\n\t{  0x4d2,  0x410 },\t// Ӓ -> А,\t ̈ (308)\n\t{  0x4d3,  0x430 },\t// ӓ -> а,\t ̈ (308)\n\t{  0x4d6,  0x415 },\t// Ӗ -> Е,\t ̆ (306)\n\t{  0x4d7,  0x435 },\t// ӗ -> е,\t ̆ (306)\n\t{  0x4da,  0x4d8 },\t// Ӛ -> Ә,\t ̈ (308)\n\t{  0x4db,  0x4d9 },\t// ӛ -> ә,\t ̈ (308)\n\t{  0x4dc,  0x416 },\t// Ӝ -> Ж,\t ̈ (308)\n\t{  0x4dd,  0x436 },\t// ӝ -> ж,\t ̈ (308)\n\t{  0x4de,  0x417 },\t// Ӟ -> З,\t ̈ (308)\n\t{  0x4df,  0x437 },\t// ӟ -> з,\t ̈ (308)\n\t{  0x4e2,  0x418 },\t// Ӣ -> И,\t ̄ (304)\n\t{  0x4e3,  0x438 },\t// ӣ -> и,\t ̄ (304)\n\t{  0x4e4,  0x418 },\t// Ӥ -> И,\t ̈ (308)\n\t{  0x4e5,  0x438 },\t// ӥ -> и,\t ̈ (308)\n\t{  0x4e6,  0x41e },\t// Ӧ -> О,\t ̈ (308)\n\t{  0x4e7,  0x43e },\t// ӧ -> о,\t ̈ (308)\n\t{  0x4ea,  0x4e8 },\t// Ӫ -> Ө,\t ̈ (308)\n\t{  0x4eb,  0x4e9 },\t// ӫ -> ө,\t ̈ (308)\n\t{  0x4ec,  0x42d },\t// Ӭ -> Э,\t ̈ (308)\n\t{  0x4ed,  0x44d },\t// ӭ -> э,\t ̈ (308)\n\t{  0x4ee,  0x423 },\t// Ӯ -> У,\t ̄ (304)\n\t{  0x4ef,  0x443 },\t// ӯ -> у,\t ̄ (304)\n\t{  0x4f0,  0x423 },\t// Ӱ -> У,\t ̈ (308)\n\t{  0x4f1,  0x443 },\t// ӱ -> у,\t ̈ (308)\n\t{  0x4f2,  0x423 },\t// Ӳ -> У,\t ̋ (30b)\n\t{  0x4f3,  0x443 },\t// ӳ -> у,\t ̋ (30b)\n\t{  0x4f4,  0x427 },\t// Ӵ -> Ч,\t ̈ (308)\n\t{  0x4f5,  0x447 },\t// ӵ -> ч,\t ̈ (308)\n\t{  0x4f8,  0x42b },\t// Ӹ -> Ы,\t ̈ (308)\n\t{  0x4f9,  0x44b },\t// ӹ -> ы,\t ̈ (308)\n\t{ 0x1e00,   0x41 },\t// Ḁ -> A,\t ̥ (325)\n\t{ 0x1e01,   0x61 },\t// ḁ -> a,\t ̥ (325)\n\t{ 0x1e02,   0x42 },\t// Ḃ -> B,\t ̇ (307)\n\t{ 0x1e03,   0x62 },\t// ḃ -> b,\t ̇ (307)\n\t{ 0x1e04,   0x42 },\t// Ḅ -> B,\t ̣ (323)\n\t{ 0x1e05,   0x62 },\t// ḅ -> b,\t ̣ (323)\n\t{ 0x1e06,   0x42 },\t// Ḇ -> B,\t ̱ (331)\n\t{ 0x1e07,   0x62 },\t// ḇ -> b,\t ̱ (331)\n\t{ 0x1e08,   0x43 },\t// Ḉ -> C,\t ̧ (327),  ́ (301)\n\t{ 0x1e09,   0x63 },\t// ḉ -> c,\t ̧ (327),  ́ (301)\n\t{ 0x1e0a,   0x44 },\t// Ḋ -> D,\t ̇ (307)\n\t{ 0x1e0b,   0x64 },\t// ḋ -> d,\t ̇ (307)\n\t{ 0x1e0c,   0x44 },\t// Ḍ -> D,\t ̣ (323)\n\t{ 0x1e0d,   0x64 },\t// ḍ -> d,\t ̣ (323)\n\t{ 0x1e0e,   0x44 },\t// Ḏ -> D,\t ̱ (331)\n\t{ 0x1e0f,   0x64 },\t// ḏ -> d,\t ̱ (331)\n\t{ 0x1e10,   0x44 },\t// Ḑ -> D,\t ̧ (327)\n\t{ 0x1e11,   0x64 },\t// ḑ -> d,\t ̧ (327)\n\t{ 0x1e12,   0x44 },\t// Ḓ -> D,\t ̭ (32d)\n\t{ 0x1e13,   0x64 },\t// ḓ -> d,\t ̭ (32d)\n\t{ 0x1e14,   0x45 },\t// Ḕ -> E,\t ̄ (304),  ̀ (300)\n\t{ 0x1e15,   0x65 },\t// ḕ -> e,\t ̄ (304),  ̀ (300)\n\t{ 0x1e16,   0x45 },\t// Ḗ -> E,\t ̄ (304),  ́ (301)\n\t{ 0x1e17,   0x65 },\t// ḗ -> e,\t ̄ (304),  ́ (301)\n\t{ 0x1e18,   0x45 },\t// Ḙ -> E,\t ̭ (32d)\n\t{ 0x1e19,   0x65 },\t// ḙ -> e,\t ̭ (32d)\n\t{ 0x1e1a,   0x45 },\t// Ḛ -> E,\t ̰ (330)\n\t{ 0x1e1b,   0x65 },\t// ḛ -> e,\t ̰ (330)\n\t{ 0x1e1c,   0x45 },\t// Ḝ -> E,\t ̧ (327),  ̆ (306)\n\t{ 0x1e1d,   0x65 },\t// ḝ -> e,\t ̧ (327),  ̆ (306)\n\t{ 0x1e1e,   0x46 },\t// Ḟ -> F,\t ̇ (307)\n\t{ 0x1e1f,   0x66 },\t// ḟ -> f,\t ̇ (307)\n\t{ 0x1e20,   0x47 },\t// Ḡ -> G,\t ̄ (304)\n\t{ 0x1e21,   0x67 },\t// ḡ -> g,\t ̄ (304)\n\t{ 0x1e22,   0x48 },\t// Ḣ -> H,\t ̇ (307)\n\t{ 0x1e23,   0x68 },\t// ḣ -> h,\t ̇ (307)\n\t{ 0x1e24,   0x48 },\t// Ḥ -> H,\t ̣ (323)\n\t{ 0x1e25,   0x68 },\t// ḥ -> h,\t ̣ (323)\n\t{ 0x1e26,   0x48 },\t// Ḧ -> H,\t ̈ (308)\n\t{ 0x1e27,   0x68 },\t// ḧ -> h,\t ̈ (308)\n\t{ 0x1e28,   0x48 },\t// Ḩ -> H,\t ̧ (327)\n\t{ 0x1e29,   0x68 },\t// ḩ -> h,\t ̧ (327)\n\t{ 0x1e2a,   0x48 },\t// Ḫ -> H,\t ̮ (32e)\n\t{ 0x1e2b,   0x68 },\t// ḫ -> h,\t ̮ (32e)\n\t{ 0x1e2c,   0x49 },\t// Ḭ -> I,\t ̰ (330)\n\t{ 0x1e2d,   0x69 },\t// ḭ -> i,\t ̰ (330)\n\t{ 0x1e2e,   0x49 },\t// Ḯ -> I,\t ̈ (308),  ́ (301)\n\t{ 0x1e2f,   0x69 },\t// ḯ -> i,\t ̈ (308),  ́ (301)\n\t{ 0x1e30,   0x4b },\t// Ḱ -> K,\t ́ (301)\n\t{ 0x1e31,   0x6b },\t// ḱ -> k,\t ́ (301)\n\t{ 0x1e32,   0x4b },\t// Ḳ -> K,\t ̣ (323)\n\t{ 0x1e33,   0x6b },\t// ḳ -> k,\t ̣ (323)\n\t{ 0x1e34,   0x4b },\t// Ḵ -> K,\t ̱ (331)\n\t{ 0x1e35,   0x6b },\t// ḵ -> k,\t ̱ (331)\n\t{ 0x1e36,   0x4c },\t// Ḷ -> L,\t ̣ (323)\n\t{ 0x1e37,   0x6c },\t// ḷ -> l,\t ̣ (323)\n\t{ 0x1e38,   0x4c },\t// Ḹ -> L,\t ̣ (323),  ̄ (304)\n\t{ 0x1e39,   0x6c },\t// ḹ -> l,\t ̣ (323),  ̄ (304)\n\t{ 0x1e3a,   0x4c },\t// Ḻ -> L,\t ̱ (331)\n\t{ 0x1e3b,   0x6c },\t// ḻ -> l,\t ̱ (331)\n\t{ 0x1e3c,   0x4c },\t// Ḽ -> L,\t ̭ (32d)\n\t{ 0x1e3d,   0x6c },\t// ḽ -> l,\t ̭ (32d)\n\t{ 0x1e3e,   0x4d },\t// Ḿ -> M,\t ́ (301)\n\t{ 0x1e3f,   0x6d },\t// ḿ -> m,\t ́ (301)\n\t{ 0x1e40,   0x4d },\t// Ṁ -> M,\t ̇ (307)\n\t{ 0x1e41,   0x6d },\t// ṁ -> m,\t ̇ (307)\n\t{ 0x1e42,   0x4d },\t// Ṃ -> M,\t ̣ (323)\n\t{ 0x1e43,   0x6d },\t// ṃ -> m,\t ̣ (323)\n\t{ 0x1e44,   0x4e },\t// Ṅ -> N,\t ̇ (307)\n\t{ 0x1e45,   0x6e },\t// ṅ -> n,\t ̇ (307)\n\t{ 0x1e46,   0x4e },\t// Ṇ -> N,\t ̣ (323)\n\t{ 0x1e47,   0x6e },\t// ṇ -> n,\t ̣ (323)\n\t{ 0x1e48,   0x4e },\t// Ṉ -> N,\t ̱ (331)\n\t{ 0x1e49,   0x6e },\t// ṉ -> n,\t ̱ (331)\n\t{ 0x1e4a,   0x4e },\t// Ṋ -> N,\t ̭ (32d)\n\t{ 0x1e4b,   0x6e },\t// ṋ -> n,\t ̭ (32d)\n\t{ 0x1e4c,   0x4f },\t// Ṍ -> O,\t ̃ (303),  ́ (301)\n\t{ 0x1e4d,   0x6f },\t// ṍ -> o,\t ̃ (303),  ́ (301)\n\t{ 0x1e4e,   0x4f },\t// Ṏ -> O,\t ̃ (303),  ̈ (308)\n\t{ 0x1e4f,   0x6f },\t// ṏ -> o,\t ̃ (303),  ̈ (308)\n\t{ 0x1e50,   0x4f },\t// Ṑ -> O,\t ̄ (304),  ̀ (300)\n\t{ 0x1e51,   0x6f },\t// ṑ -> o,\t ̄ (304),  ̀ (300)\n\t{ 0x1e52,   0x4f },\t// Ṓ -> O,\t ̄ (304),  ́ (301)\n\t{ 0x1e53,   0x6f },\t// ṓ -> o,\t ̄ (304),  ́ (301)\n\t{ 0x1e54,   0x50 },\t// Ṕ -> P,\t ́ (301)\n\t{ 0x1e55,   0x70 },\t// ṕ -> p,\t ́ (301)\n\t{ 0x1e56,   0x50 },\t// Ṗ -> P,\t ̇ (307)\n\t{ 0x1e57,   0x70 },\t// ṗ -> p,\t ̇ (307)\n\t{ 0x1e58,   0x52 },\t// Ṙ -> R,\t ̇ (307)\n\t{ 0x1e59,   0x72 },\t// ṙ -> r,\t ̇ (307)\n\t{ 0x1e5a,   0x52 },\t// Ṛ -> R,\t ̣ (323)\n\t{ 0x1e5b,   0x72 },\t// ṛ -> r,\t ̣ (323)\n\t{ 0x1e5c,   0x52 },\t// Ṝ -> R,\t ̣ (323),  ̄ (304)\n\t{ 0x1e5d,   0x72 },\t// ṝ -> r,\t ̣ (323),  ̄ (304)\n\t{ 0x1e5e,   0x52 },\t// Ṟ -> R,\t ̱ (331)\n\t{ 0x1e5f,   0x72 },\t// ṟ -> r,\t ̱ (331)\n\t{ 0x1e60,   0x53 },\t// Ṡ -> S,\t ̇ (307)\n\t{ 0x1e61,   0x73 },\t// ṡ -> s,\t ̇ (307)\n\t{ 0x1e62,   0x53 },\t// Ṣ -> S,\t ̣ (323)\n\t{ 0x1e63,   0x73 },\t// ṣ -> s,\t ̣ (323)\n\t{ 0x1e64,   0x53 },\t// Ṥ -> S,\t ́ (301),  ̇ (307)\n\t{ 0x1e65,   0x73 },\t// ṥ -> s,\t ́ (301),  ̇ (307)\n\t{ 0x1e66,   0x53 },\t// Ṧ -> S,\t ̌ (30c),  ̇ (307)\n\t{ 0x1e67,   0x73 },\t// ṧ -> s,\t ̌ (30c),  ̇ (307)\n\t{ 0x1e68,   0x53 },\t// Ṩ -> S,\t ̣ (323),  ̇ (307)\n\t{ 0x1e69,   0x73 },\t// ṩ -> s,\t ̣ (323),  ̇ (307)\n\t{ 0x1e6a,   0x54 },\t// Ṫ -> T,\t ̇ (307)\n\t{ 0x1e6b,   0x74 },\t// ṫ -> t,\t ̇ (307)\n\t{ 0x1e6c,   0x54 },\t// Ṭ -> T,\t ̣ (323)\n\t{ 0x1e6d,   0x74 },\t// ṭ -> t,\t ̣ (323)\n\t{ 0x1e6e,   0x54 },\t// Ṯ -> T,\t ̱ (331)\n\t{ 0x1e6f,   0x74 },\t// ṯ -> t,\t ̱ (331)\n\t{ 0x1e70,   0x54 },\t// Ṱ -> T,\t ̭ (32d)\n\t{ 0x1e71,   0x74 },\t// ṱ -> t,\t ̭ (32d)\n\t{ 0x1e72,   0x55 },\t// Ṳ -> U,\t ̤ (324)\n\t{ 0x1e73,   0x75 },\t// ṳ -> u,\t ̤ (324)\n\t{ 0x1e74,   0x55 },\t// Ṵ -> U,\t ̰ (330)\n\t{ 0x1e75,   0x75 },\t// ṵ -> u,\t ̰ (330)\n\t{ 0x1e76,   0x55 },\t// Ṷ -> U,\t ̭ (32d)\n\t{ 0x1e77,   0x75 },\t// ṷ -> u,\t ̭ (32d)\n\t{ 0x1e78,   0x55 },\t// Ṹ -> U,\t ̃ (303),  ́ (301)\n\t{ 0x1e79,   0x75 },\t// ṹ -> u,\t ̃ (303),  ́ (301)\n\t{ 0x1e7a,   0x55 },\t// Ṻ -> U,\t ̄ (304),  ̈ (308)\n\t{ 0x1e7b,   0x75 },\t// ṻ -> u,\t ̄ (304),  ̈ (308)\n\t{ 0x1e7c,   0x56 },\t// Ṽ -> V,\t ̃ (303)\n\t{ 0x1e7d,   0x76 },\t// ṽ -> v,\t ̃ (303)\n\t{ 0x1e7e,   0x56 },\t// Ṿ -> V,\t ̣ (323)\n\t{ 0x1e7f,   0x76 },\t// ṿ -> v,\t ̣ (323)\n\t{ 0x1e80,   0x57 },\t// Ẁ -> W,\t ̀ (300)\n\t{ 0x1e81,   0x77 },\t// ẁ -> w,\t ̀ (300)\n\t{ 0x1e82,   0x57 },\t// Ẃ -> W,\t ́ (301)\n\t{ 0x1e83,   0x77 },\t// ẃ -> w,\t ́ (301)\n\t{ 0x1e84,   0x57 },\t// Ẅ -> W,\t ̈ (308)\n\t{ 0x1e85,   0x77 },\t// ẅ -> w,\t ̈ (308)\n\t{ 0x1e86,   0x57 },\t// Ẇ -> W,\t ̇ (307)\n\t{ 0x1e87,   0x77 },\t// ẇ -> w,\t ̇ (307)\n\t{ 0x1e88,   0x57 },\t// Ẉ -> W,\t ̣ (323)\n\t{ 0x1e89,   0x77 },\t// ẉ -> w,\t ̣ (323)\n\t{ 0x1e8a,   0x58 },\t// Ẋ -> X,\t ̇ (307)\n\t{ 0x1e8b,   0x78 },\t// ẋ -> x,\t ̇ (307)\n\t{ 0x1e8c,   0x58 },\t// Ẍ -> X,\t ̈ (308)\n\t{ 0x1e8d,   0x78 },\t// ẍ -> x,\t ̈ (308)\n\t{ 0x1e8e,   0x59 },\t// Ẏ -> Y,\t ̇ (307)\n\t{ 0x1e8f,   0x79 },\t// ẏ -> y,\t ̇ (307)\n\t{ 0x1e90,   0x5a },\t// Ẑ -> Z,\t ̂ (302)\n\t{ 0x1e91,   0x7a },\t// ẑ -> z,\t ̂ (302)\n\t{ 0x1e92,   0x5a },\t// Ẓ -> Z,\t ̣ (323)\n\t{ 0x1e93,   0x7a },\t// ẓ -> z,\t ̣ (323)\n\t{ 0x1e94,   0x5a },\t// Ẕ -> Z,\t ̱ (331)\n\t{ 0x1e95,   0x7a },\t// ẕ -> z,\t ̱ (331)\n\t{ 0x1e96,   0x68 },\t// ẖ -> h,\t ̱ (331)\n\t{ 0x1e97,   0x74 },\t// ẗ -> t,\t ̈ (308)\n\t{ 0x1e98,   0x77 },\t// ẘ -> w,\t ̊ (30a)\n\t{ 0x1e99,   0x79 },\t// ẙ -> y,\t ̊ (30a)\n\t{ 0x1e9b,   0x73 },\t// ẛ -> s,\t ̇ (307)\n\t{ 0x1ea0,   0x41 },\t// Ạ -> A,\t ̣ (323)\n\t{ 0x1ea1,   0x61 },\t// ạ -> a,\t ̣ (323)\n\t{ 0x1ea2,   0x41 },\t// Ả -> A,\t ̉ (309)\n\t{ 0x1ea3,   0x61 },\t// ả -> a,\t ̉ (309)\n\t{ 0x1ea4,   0x41 },\t// Ấ -> A,\t ̂ (302),  ́ (301)\n\t{ 0x1ea5,   0x61 },\t// ấ -> a,\t ̂ (302),  ́ (301)\n\t{ 0x1ea6,   0x41 },\t// Ầ -> A,\t ̂ (302),  ̀ (300)\n\t{ 0x1ea7,   0x61 },\t// ầ -> a,\t ̂ (302),  ̀ (300)\n\t{ 0x1ea8,   0x41 },\t// Ẩ -> A,\t ̂ (302),  ̉ (309)\n\t{ 0x1ea9,   0x61 },\t// ẩ -> a,\t ̂ (302),  ̉ (309)\n\t{ 0x1eaa,   0x41 },\t// Ẫ -> A,\t ̂ (302),  ̃ (303)\n\t{ 0x1eab,   0x61 },\t// ẫ -> a,\t ̂ (302),  ̃ (303)\n\t{ 0x1eac,   0x41 },\t// Ậ -> A,\t ̣ (323),  ̂ (302)\n\t{ 0x1ead,   0x61 },\t// ậ -> a,\t ̣ (323),  ̂ (302)\n\t{ 0x1eae,   0x41 },\t// Ắ -> A,\t ̆ (306),  ́ (301)\n\t{ 0x1eaf,   0x61 },\t// ắ -> a,\t ̆ (306),  ́ (301)\n\t{ 0x1eb0,   0x41 },\t// Ằ -> A,\t ̆ (306),  ̀ (300)\n\t{ 0x1eb1,   0x61 },\t// ằ -> a,\t ̆ (306),  ̀ (300)\n\t{ 0x1eb2,   0x41 },\t// Ẳ -> A,\t ̆ (306),  ̉ (309)\n\t{ 0x1eb3,   0x61 },\t// ẳ -> a,\t ̆ (306),  ̉ (309)\n\t{ 0x1eb4,   0x41 },\t// Ẵ -> A,\t ̆ (306),  ̃ (303)\n\t{ 0x1eb5,   0x61 },\t// ẵ -> a,\t ̆ (306),  ̃ (303)\n\t{ 0x1eb6,   0x41 },\t// Ặ -> A,\t ̣ (323),  ̆ (306)\n\t{ 0x1eb7,   0x61 },\t// ặ -> a,\t ̣ (323),  ̆ (306)\n\t{ 0x1eb8,   0x45 },\t// Ẹ -> E,\t ̣ (323)\n\t{ 0x1eb9,   0x65 },\t// ẹ -> e,\t ̣ (323)\n\t{ 0x1eba,   0x45 },\t// Ẻ -> E,\t ̉ (309)\n\t{ 0x1ebb,   0x65 },\t// ẻ -> e,\t ̉ (309)\n\t{ 0x1ebc,   0x45 },\t// Ẽ -> E,\t ̃ (303)\n\t{ 0x1ebd,   0x65 },\t// ẽ -> e,\t ̃ (303)\n\t{ 0x1ebe,   0x45 },\t// Ế -> E,\t ̂ (302),  ́ (301)\n\t{ 0x1ebf,   0x65 },\t// ế -> e,\t ̂ (302),  ́ (301)\n\t{ 0x1ec0,   0x45 },\t// Ề -> E,\t ̂ (302),  ̀ (300)\n\t{ 0x1ec1,   0x65 },\t// ề -> e,\t ̂ (302),  ̀ (300)\n\t{ 0x1ec2,   0x45 },\t// Ể -> E,\t ̂ (302),  ̉ (309)\n\t{ 0x1ec3,   0x65 },\t// ể -> e,\t ̂ (302),  ̉ (309)\n\t{ 0x1ec4,   0x45 },\t// Ễ -> E,\t ̂ (302),  ̃ (303)\n\t{ 0x1ec5,   0x65 },\t// ễ -> e,\t ̂ (302),  ̃ (303)\n\t{ 0x1ec6,   0x45 },\t// Ệ -> E,\t ̣ (323),  ̂ (302)\n\t{ 0x1ec7,   0x65 },\t// ệ -> e,\t ̣ (323),  ̂ (302)\n\t{ 0x1ec8,   0x49 },\t// Ỉ -> I,\t ̉ (309)\n\t{ 0x1ec9,   0x69 },\t// ỉ -> i,\t ̉ (309)\n\t{ 0x1eca,   0x49 },\t// Ị -> I,\t ̣ (323)\n\t{ 0x1ecb,   0x69 },\t// ị -> i,\t ̣ (323)\n\t{ 0x1ecc,   0x4f },\t// Ọ -> O,\t ̣ (323)\n\t{ 0x1ecd,   0x6f },\t// ọ -> o,\t ̣ (323)\n\t{ 0x1ece,   0x4f },\t// Ỏ -> O,\t ̉ (309)\n\t{ 0x1ecf,   0x6f },\t// ỏ -> o,\t ̉ (309)\n\t{ 0x1ed0,   0x4f },\t// Ố -> O,\t ̂ (302),  ́ (301)\n\t{ 0x1ed1,   0x6f },\t// ố -> o,\t ̂ (302),  ́ (301)\n\t{ 0x1ed2,   0x4f },\t// Ồ -> O,\t ̂ (302),  ̀ (300)\n\t{ 0x1ed3,   0x6f },\t// ồ -> o,\t ̂ (302),  ̀ (300)\n\t{ 0x1ed4,   0x4f },\t// Ổ -> O,\t ̂ (302),  ̉ (309)\n\t{ 0x1ed5,   0x6f },\t// ổ -> o,\t ̂ (302),  ̉ (309)\n\t{ 0x1ed6,   0x4f },\t// Ỗ -> O,\t ̂ (302),  ̃ (303)\n\t{ 0x1ed7,   0x6f },\t// ỗ -> o,\t ̂ (302),  ̃ (303)\n\t{ 0x1ed8,   0x4f },\t// Ộ -> O,\t ̣ (323),  ̂ (302)\n\t{ 0x1ed9,   0x6f },\t// ộ -> o,\t ̣ (323),  ̂ (302)\n\t{ 0x1eda,   0x4f },\t// Ớ -> O,\t ̛ (31b),  ́ (301)\n\t{ 0x1edb,   0x6f },\t// ớ -> o,\t ̛ (31b),  ́ (301)\n\t{ 0x1edc,   0x4f },\t// Ờ -> O,\t ̛ (31b),  ̀ (300)\n\t{ 0x1edd,   0x6f },\t// ờ -> o,\t ̛ (31b),  ̀ (300)\n\t{ 0x1ede,   0x4f },\t// Ở -> O,\t ̛ (31b),  ̉ (309)\n\t{ 0x1edf,   0x6f },\t// ở -> o,\t ̛ (31b),  ̉ (309)\n\t{ 0x1ee0,   0x4f },\t// Ỡ -> O,\t ̛ (31b),  ̃ (303)\n\t{ 0x1ee1,   0x6f },\t// ỡ -> o,\t ̛ (31b),  ̃ (303)\n\t{ 0x1ee2,   0x4f },\t// Ợ -> O,\t ̛ (31b),  ̣ (323)\n\t{ 0x1ee3,   0x6f },\t// ợ -> o,\t ̛ (31b),  ̣ (323)\n\t{ 0x1ee4,   0x55 },\t// Ụ -> U,\t ̣ (323)\n\t{ 0x1ee5,   0x75 },\t// ụ -> u,\t ̣ (323)\n\t{ 0x1ee6,   0x55 },\t// Ủ -> U,\t ̉ (309)\n\t{ 0x1ee7,   0x75 },\t// ủ -> u,\t ̉ (309)\n\t{ 0x1ee8,   0x55 },\t// Ứ -> U,\t ̛ (31b),  ́ (301)\n\t{ 0x1ee9,   0x75 },\t// ứ -> u,\t ̛ (31b),  ́ (301)\n\t{ 0x1eea,   0x55 },\t// Ừ -> U,\t ̛ (31b),  ̀ (300)\n\t{ 0x1eeb,   0x75 },\t// ừ -> u,\t ̛ (31b),  ̀ (300)\n\t{ 0x1eec,   0x55 },\t// Ử -> U,\t ̛ (31b),  ̉ (309)\n\t{ 0x1eed,   0x75 },\t// ử -> u,\t ̛ (31b),  ̉ (309)\n\t{ 0x1eee,   0x55 },\t// Ữ -> U,\t ̛ (31b),  ̃ (303)\n\t{ 0x1eef,   0x75 },\t// ữ -> u,\t ̛ (31b),  ̃ (303)\n\t{ 0x1ef0,   0x55 },\t// Ự -> U,\t ̛ (31b),  ̣ (323)\n\t{ 0x1ef1,   0x75 },\t// ự -> u,\t ̛ (31b),  ̣ (323)\n\t{ 0x1ef2,   0x59 },\t// Ỳ -> Y,\t ̀ (300)\n\t{ 0x1ef3,   0x79 },\t// ỳ -> y,\t ̀ (300)\n\t{ 0x1ef4,   0x59 },\t// Ỵ -> Y,\t ̣ (323)\n\t{ 0x1ef5,   0x79 },\t// ỵ -> y,\t ̣ (323)\n\t{ 0x1ef6,   0x59 },\t// Ỷ -> Y,\t ̉ (309)\n\t{ 0x1ef7,   0x79 },\t// ỷ -> y,\t ̉ (309)\n\t{ 0x1ef8,   0x59 },\t// Ỹ -> Y,\t ̃ (303)\n\t{ 0x1ef9,   0x79 },\t// ỹ -> y,\t ̃ (303)\n\t{ 0x1f00,  0x3b1 },\t// ἀ -> α,\t ̓ (313)\n\t{ 0x1f01,  0x3b1 },\t// ἁ -> α,\t ̔ (314)\n\t{ 0x1f02,  0x3b1 },\t// ἂ -> α,\t ̓ (313),  ̀ (300)\n\t{ 0x1f03,  0x3b1 },\t// ἃ -> α,\t ̔ (314),  ̀ (300)\n\t{ 0x1f04,  0x3b1 },\t// ἄ -> α,\t ̓ (313),  ́ (301)\n\t{ 0x1f05,  0x3b1 },\t// ἅ -> α,\t ̔ (314),  ́ (301)\n\t{ 0x1f06,  0x3b1 },\t// ἆ -> α,\t ̓ (313),  ͂ (342)\n\t{ 0x1f07,  0x3b1 },\t// ἇ -> α,\t ̔ (314),  ͂ (342)\n\t{ 0x1f08,  0x391 },\t// Ἀ -> Α,\t ̓ (313)\n\t{ 0x1f09,  0x391 },\t// Ἁ -> Α,\t ̔ (314)\n\t{ 0x1f0a,  0x391 },\t// Ἂ -> Α,\t ̓ (313),  ̀ (300)\n\t{ 0x1f0b,  0x391 },\t// Ἃ -> Α,\t ̔ (314),  ̀ (300)\n\t{ 0x1f0c,  0x391 },\t// Ἄ -> Α,\t ̓ (313),  ́ (301)\n\t{ 0x1f0d,  0x391 },\t// Ἅ -> Α,\t ̔ (314),  ́ (301)\n\t{ 0x1f0e,  0x391 },\t// Ἆ -> Α,\t ̓ (313),  ͂ (342)\n\t{ 0x1f0f,  0x391 },\t// Ἇ -> Α,\t ̔ (314),  ͂ (342)\n\t{ 0x1f10,  0x3b5 },\t// ἐ -> ε,\t ̓ (313)\n\t{ 0x1f11,  0x3b5 },\t// ἑ -> ε,\t ̔ (314)\n\t{ 0x1f12,  0x3b5 },\t// ἒ -> ε,\t ̓ (313),  ̀ (300)\n\t{ 0x1f13,  0x3b5 },\t// ἓ -> ε,\t ̔ (314),  ̀ (300)\n\t{ 0x1f14,  0x3b5 },\t// ἔ -> ε,\t ̓ (313),  ́ (301)\n\t{ 0x1f15,  0x3b5 },\t// ἕ -> ε,\t ̔ (314),  ́ (301)\n\t{ 0x1f18,  0x395 },\t// Ἐ -> Ε,\t ̓ (313)\n\t{ 0x1f19,  0x395 },\t// Ἑ -> Ε,\t ̔ (314)\n\t{ 0x1f1a,  0x395 },\t// Ἒ -> Ε,\t ̓ (313),  ̀ (300)\n\t{ 0x1f1b,  0x395 },\t// Ἓ -> Ε,\t ̔ (314),  ̀ (300)\n\t{ 0x1f1c,  0x395 },\t// Ἔ -> Ε,\t ̓ (313),  ́ (301)\n\t{ 0x1f1d,  0x395 },\t// Ἕ -> Ε,\t ̔ (314),  ́ (301)\n\t{ 0x1f20,  0x3b7 },\t// ἠ -> η,\t ̓ (313)\n\t{ 0x1f21,  0x3b7 },\t// ἡ -> η,\t ̔ (314)\n\t{ 0x1f22,  0x3b7 },\t// ἢ -> η,\t ̓ (313),  ̀ (300)\n\t{ 0x1f23,  0x3b7 },\t// ἣ -> η,\t ̔ (314),  ̀ (300)\n\t{ 0x1f24,  0x3b7 },\t// ἤ -> η,\t ̓ (313),  ́ (301)\n\t{ 0x1f25,  0x3b7 },\t// ἥ -> η,\t ̔ (314),  ́ (301)\n\t{ 0x1f26,  0x3b7 },\t// ἦ -> η,\t ̓ (313),  ͂ (342)\n\t{ 0x1f27,  0x3b7 },\t// ἧ -> η,\t ̔ (314),  ͂ (342)\n\t{ 0x1f28,  0x397 },\t// Ἠ -> Η,\t ̓ (313)\n\t{ 0x1f29,  0x397 },\t// Ἡ -> Η,\t ̔ (314)\n\t{ 0x1f2a,  0x397 },\t// Ἢ -> Η,\t ̓ (313),  ̀ (300)\n\t{ 0x1f2b,  0x397 },\t// Ἣ -> Η,\t ̔ (314),  ̀ (300)\n\t{ 0x1f2c,  0x397 },\t// Ἤ -> Η,\t ̓ (313),  ́ (301)\n\t{ 0x1f2d,  0x397 },\t// Ἥ -> Η,\t ̔ (314),  ́ (301)\n\t{ 0x1f2e,  0x397 },\t// Ἦ -> Η,\t ̓ (313),  ͂ (342)\n\t{ 0x1f2f,  0x397 },\t// Ἧ -> Η,\t ̔ (314),  ͂ (342)\n\t{ 0x1f30,  0x3b9 },\t// ἰ -> ι,\t ̓ (313)\n\t{ 0x1f31,  0x3b9 },\t// ἱ -> ι,\t ̔ (314)\n\t{ 0x1f32,  0x3b9 },\t// ἲ -> ι,\t ̓ (313),  ̀ (300)\n\t{ 0x1f33,  0x3b9 },\t// ἳ -> ι,\t ̔ (314),  ̀ (300)\n\t{ 0x1f34,  0x3b9 },\t// ἴ -> ι,\t ̓ (313),  ́ (301)\n\t{ 0x1f35,  0x3b9 },\t// ἵ -> ι,\t ̔ (314),  ́ (301)\n\t{ 0x1f36,  0x3b9 },\t// ἶ -> ι,\t ̓ (313),  ͂ (342)\n\t{ 0x1f37,  0x3b9 },\t// ἷ -> ι,\t ̔ (314),  ͂ (342)\n\t{ 0x1f38,  0x399 },\t// Ἰ -> Ι,\t ̓ (313)\n\t{ 0x1f39,  0x399 },\t// Ἱ -> Ι,\t ̔ (314)\n\t{ 0x1f3a,  0x399 },\t// Ἲ -> Ι,\t ̓ (313),  ̀ (300)\n\t{ 0x1f3b,  0x399 },\t// Ἳ -> Ι,\t ̔ (314),  ̀ (300)\n\t{ 0x1f3c,  0x399 },\t// Ἴ -> Ι,\t ̓ (313),  ́ (301)\n\t{ 0x1f3d,  0x399 },\t// Ἵ -> Ι,\t ̔ (314),  ́ (301)\n\t{ 0x1f3e,  0x399 },\t// Ἶ -> Ι,\t ̓ (313),  ͂ (342)\n\t{ 0x1f3f,  0x399 },\t// Ἷ -> Ι,\t ̔ (314),  ͂ (342)\n\t{ 0x1f40,  0x3bf },\t// ὀ -> ο,\t ̓ (313)\n\t{ 0x1f41,  0x3bf },\t// ὁ -> ο,\t ̔ (314)\n\t{ 0x1f42,  0x3bf },\t// ὂ -> ο,\t ̓ (313),  ̀ (300)\n\t{ 0x1f43,  0x3bf },\t// ὃ -> ο,\t ̔ (314),  ̀ (300)\n\t{ 0x1f44,  0x3bf },\t// ὄ -> ο,\t ̓ (313),  ́ (301)\n\t{ 0x1f45,  0x3bf },\t// ὅ -> ο,\t ̔ (314),  ́ (301)\n\t{ 0x1f48,  0x39f },\t// Ὀ -> Ο,\t ̓ (313)\n\t{ 0x1f49,  0x39f },\t// Ὁ -> Ο,\t ̔ (314)\n\t{ 0x1f4a,  0x39f },\t// Ὂ -> Ο,\t ̓ (313),  ̀ (300)\n\t{ 0x1f4b,  0x39f },\t// Ὃ -> Ο,\t ̔ (314),  ̀ (300)\n\t{ 0x1f4c,  0x39f },\t// Ὄ -> Ο,\t ̓ (313),  ́ (301)\n\t{ 0x1f4d,  0x39f },\t// Ὅ -> Ο,\t ̔ (314),  ́ (301)\n\t{ 0x1f50,  0x3c5 },\t// ὐ -> υ,\t ̓ (313)\n\t{ 0x1f51,  0x3c5 },\t// ὑ -> υ,\t ̔ (314)\n\t{ 0x1f52,  0x3c5 },\t// ὒ -> υ,\t ̓ (313),  ̀ (300)\n\t{ 0x1f53,  0x3c5 },\t// ὓ -> υ,\t ̔ (314),  ̀ (300)\n\t{ 0x1f54,  0x3c5 },\t// ὔ -> υ,\t ̓ (313),  ́ (301)\n\t{ 0x1f55,  0x3c5 },\t// ὕ -> υ,\t ̔ (314),  ́ (301)\n\t{ 0x1f56,  0x3c5 },\t// ὖ -> υ,\t ̓ (313),  ͂ (342)\n\t{ 0x1f57,  0x3c5 },\t// ὗ -> υ,\t ̔ (314),  ͂ (342)\n\t{ 0x1f59,  0x3a5 },\t// Ὑ -> Υ,\t ̔ (314)\n\t{ 0x1f5b,  0x3a5 },\t// Ὓ -> Υ,\t ̔ (314),  ̀ (300)\n\t{ 0x1f5d,  0x3a5 },\t// Ὕ -> Υ,\t ̔ (314),  ́ (301)\n\t{ 0x1f5f,  0x3a5 },\t// Ὗ -> Υ,\t ̔ (314),  ͂ (342)\n\t{ 0x1f60,  0x3c9 },\t// ὠ -> ω,\t ̓ (313)\n\t{ 0x1f61,  0x3c9 },\t// ὡ -> ω,\t ̔ (314)\n\t{ 0x1f62,  0x3c9 },\t// ὢ -> ω,\t ̓ (313),  ̀ (300)\n\t{ 0x1f63,  0x3c9 },\t// ὣ -> ω,\t ̔ (314),  ̀ (300)\n\t{ 0x1f64,  0x3c9 },\t// ὤ -> ω,\t ̓ (313),  ́ (301)\n\t{ 0x1f65,  0x3c9 },\t// ὥ -> ω,\t ̔ (314),  ́ (301)\n\t{ 0x1f66,  0x3c9 },\t// ὦ -> ω,\t ̓ (313),  ͂ (342)\n\t{ 0x1f67,  0x3c9 },\t// ὧ -> ω,\t ̔ (314),  ͂ (342)\n\t{ 0x1f68,  0x3a9 },\t// Ὠ -> Ω,\t ̓ (313)\n\t{ 0x1f69,  0x3a9 },\t// Ὡ -> Ω,\t ̔ (314)\n\t{ 0x1f6a,  0x3a9 },\t// Ὢ -> Ω,\t ̓ (313),  ̀ (300)\n\t{ 0x1f6b,  0x3a9 },\t// Ὣ -> Ω,\t ̔ (314),  ̀ (300)\n\t{ 0x1f6c,  0x3a9 },\t// Ὤ -> Ω,\t ̓ (313),  ́ (301)\n\t{ 0x1f6d,  0x3a9 },\t// Ὥ -> Ω,\t ̔ (314),  ́ (301)\n\t{ 0x1f6e,  0x3a9 },\t// Ὦ -> Ω,\t ̓ (313),  ͂ (342)\n\t{ 0x1f6f,  0x3a9 },\t// Ὧ -> Ω,\t ̔ (314),  ͂ (342)\n\t{ 0x1f70,  0x3b1 },\t// ὰ -> α,\t ̀ (300)\n\t{ 0x1f71,  0x3b1 },\t// ά -> α,\t ́ (301)\n\t{ 0x1f72,  0x3b5 },\t// ὲ -> ε,\t ̀ (300)\n\t{ 0x1f73,  0x3b5 },\t// έ -> ε,\t ́ (301)\n\t{ 0x1f74,  0x3b7 },\t// ὴ -> η,\t ̀ (300)\n\t{ 0x1f75,  0x3b7 },\t// ή -> η,\t ́ (301)\n\t{ 0x1f76,  0x3b9 },\t// ὶ -> ι,\t ̀ (300)\n\t{ 0x1f77,  0x3b9 },\t// ί -> ι,\t ́ (301)\n\t{ 0x1f78,  0x3bf },\t// ὸ -> ο,\t ̀ (300)\n\t{ 0x1f79,  0x3bf },\t// ό -> ο,\t ́ (301)\n\t{ 0x1f7a,  0x3c5 },\t// ὺ -> υ,\t ̀ (300)\n\t{ 0x1f7b,  0x3c5 },\t// ύ -> υ,\t ́ (301)\n\t{ 0x1f7c,  0x3c9 },\t// ὼ -> ω,\t ̀ (300)\n\t{ 0x1f7d,  0x3c9 },\t// ώ -> ω,\t ́ (301)\n\t{ 0x1f80,  0x3b1 },\t// ᾀ -> α,\t ̓ (313),  ͅ (345)\n\t{ 0x1f81,  0x3b1 },\t// ᾁ -> α,\t ̔ (314),  ͅ (345)\n\t{ 0x1f82,  0x3b1 },\t// ᾂ -> α,\t ̓ (313),  ̀ (300),  ͅ (345)\n\t{ 0x1f83,  0x3b1 },\t// ᾃ -> α,\t ̔ (314),  ̀ (300),  ͅ (345)\n\t{ 0x1f84,  0x3b1 },\t// ᾄ -> α,\t ̓ (313),  ́ (301),  ͅ (345)\n\t{ 0x1f85,  0x3b1 },\t// ᾅ -> α,\t ̔ (314),  ́ (301),  ͅ (345)\n\t{ 0x1f86,  0x3b1 },\t// ᾆ -> α,\t ̓ (313),  ͂ (342),  ͅ (345)\n\t{ 0x1f87,  0x3b1 },\t// ᾇ -> α,\t ̔ (314),  ͂ (342),  ͅ (345)\n\t{ 0x1f88,  0x391 },\t// ᾈ -> Α,\t ̓ (313),  ͅ (345)\n\t{ 0x1f89,  0x391 },\t// ᾉ -> Α,\t ̔ (314),  ͅ (345)\n\t{ 0x1f8a,  0x391 },\t// ᾊ -> Α,\t ̓ (313),  ̀ (300),  ͅ (345)\n\t{ 0x1f8b,  0x391 },\t// ᾋ -> Α,\t ̔ (314),  ̀ (300),  ͅ (345)\n\t{ 0x1f8c,  0x391 },\t// ᾌ -> Α,\t ̓ (313),  ́ (301),  ͅ (345)\n\t{ 0x1f8d,  0x391 },\t// ᾍ -> Α,\t ̔ (314),  ́ (301),  ͅ (345)\n\t{ 0x1f8e,  0x391 },\t// ᾎ -> Α,\t ̓ (313),  ͂ (342),  ͅ (345)\n\t{ 0x1f8f,  0x391 },\t// ᾏ -> Α,\t ̔ (314),  ͂ (342),  ͅ (345)\n\t{ 0x1f90,  0x3b7 },\t// ᾐ -> η,\t ̓ (313),  ͅ (345)\n\t{ 0x1f91,  0x3b7 },\t// ᾑ -> η,\t ̔ (314),  ͅ (345)\n\t{ 0x1f92,  0x3b7 },\t// ᾒ -> η,\t ̓ (313),  ̀ (300),  ͅ (345)\n\t{ 0x1f93,  0x3b7 },\t// ᾓ -> η,\t ̔ (314),  ̀ (300),  ͅ (345)\n\t{ 0x1f94,  0x3b7 },\t// ᾔ -> η,\t ̓ (313),  ́ (301),  ͅ (345)\n\t{ 0x1f95,  0x3b7 },\t// ᾕ -> η,\t ̔ (314),  ́ (301),  ͅ (345)\n\t{ 0x1f96,  0x3b7 },\t// ᾖ -> η,\t ̓ (313),  ͂ (342),  ͅ (345)\n\t{ 0x1f97,  0x3b7 },\t// ᾗ -> η,\t ̔ (314),  ͂ (342),  ͅ (345)\n\t{ 0x1f98,  0x397 },\t// ᾘ -> Η,\t ̓ (313),  ͅ (345)\n\t{ 0x1f99,  0x397 },\t// ᾙ -> Η,\t ̔ (314),  ͅ (345)\n\t{ 0x1f9a,  0x397 },\t// ᾚ -> Η,\t ̓ (313),  ̀ (300),  ͅ (345)\n\t{ 0x1f9b,  0x397 },\t// ᾛ -> Η,\t ̔ (314),  ̀ (300),  ͅ (345)\n\t{ 0x1f9c,  0x397 },\t// ᾜ -> Η,\t ̓ (313),  ́ (301),  ͅ (345)\n\t{ 0x1f9d,  0x397 },\t// ᾝ -> Η,\t ̔ (314),  ́ (301),  ͅ (345)\n\t{ 0x1f9e,  0x397 },\t// ᾞ -> Η,\t ̓ (313),  ͂ (342),  ͅ (345)\n\t{ 0x1f9f,  0x397 },\t// ᾟ -> Η,\t ̔ (314),  ͂ (342),  ͅ (345)\n\t{ 0x1fa0,  0x3c9 },\t// ᾠ -> ω,\t ̓ (313),  ͅ (345)\n\t{ 0x1fa1,  0x3c9 },\t// ᾡ -> ω,\t ̔ (314),  ͅ (345)\n\t{ 0x1fa2,  0x3c9 },\t// ᾢ -> ω,\t ̓ (313),  ̀ (300),  ͅ (345)\n\t{ 0x1fa3,  0x3c9 },\t// ᾣ -> ω,\t ̔ (314),  ̀ (300),  ͅ (345)\n\t{ 0x1fa4,  0x3c9 },\t// ᾤ -> ω,\t ̓ (313),  ́ (301),  ͅ (345)\n\t{ 0x1fa5,  0x3c9 },\t// ᾥ -> ω,\t ̔ (314),  ́ (301),  ͅ (345)\n\t{ 0x1fa6,  0x3c9 },\t// ᾦ -> ω,\t ̓ (313),  ͂ (342),  ͅ (345)\n\t{ 0x1fa7,  0x3c9 },\t// ᾧ -> ω,\t ̔ (314),  ͂ (342),  ͅ (345)\n\t{ 0x1fa8,  0x3a9 },\t// ᾨ -> Ω,\t ̓ (313),  ͅ (345)\n\t{ 0x1fa9,  0x3a9 },\t// ᾩ -> Ω,\t ̔ (314),  ͅ (345)\n\t{ 0x1faa,  0x3a9 },\t// ᾪ -> Ω,\t ̓ (313),  ̀ (300),  ͅ (345)\n\t{ 0x1fab,  0x3a9 },\t// ᾫ -> Ω,\t ̔ (314),  ̀ (300),  ͅ (345)\n\t{ 0x1fac,  0x3a9 },\t// ᾬ -> Ω,\t ̓ (313),  ́ (301),  ͅ (345)\n\t{ 0x1fad,  0x3a9 },\t// ᾭ -> Ω,\t ̔ (314),  ́ (301),  ͅ (345)\n\t{ 0x1fae,  0x3a9 },\t// ᾮ -> Ω,\t ̓ (313),  ͂ (342),  ͅ (345)\n\t{ 0x1faf,  0x3a9 },\t// ᾯ -> Ω,\t ̔ (314),  ͂ (342),  ͅ (345)\n\t{ 0x1fb0,  0x3b1 },\t// ᾰ -> α,\t ̆ (306)\n\t{ 0x1fb1,  0x3b1 },\t// ᾱ -> α,\t ̄ (304)\n\t{ 0x1fb2,  0x3b1 },\t// ᾲ -> α,\t ̀ (300),  ͅ (345)\n\t{ 0x1fb3,  0x3b1 },\t// ᾳ -> α,\t ͅ (345)\n\t{ 0x1fb4,  0x3b1 },\t// ᾴ -> α,\t ́ (301),  ͅ (345)\n\t{ 0x1fb6,  0x3b1 },\t// ᾶ -> α,\t ͂ (342)\n\t{ 0x1fb7,  0x3b1 },\t// ᾷ -> α,\t ͂ (342),  ͅ (345)\n\t{ 0x1fb8,  0x391 },\t// Ᾰ -> Α,\t ̆ (306)\n\t{ 0x1fb9,  0x391 },\t// Ᾱ -> Α,\t ̄ (304)\n\t{ 0x1fba,  0x391 },\t// Ὰ -> Α,\t ̀ (300)\n\t{ 0x1fbb,  0x391 },\t// Ά -> Α,\t ́ (301)\n\t{ 0x1fbc,  0x391 },\t// ᾼ -> Α,\t ͅ (345)\n\t{ 0x1fc2,  0x3b7 },\t// ῂ -> η,\t ̀ (300),  ͅ (345)\n\t{ 0x1fc3,  0x3b7 },\t// ῃ -> η,\t ͅ (345)\n\t{ 0x1fc4,  0x3b7 },\t// ῄ -> η,\t ́ (301),  ͅ (345)\n\t{ 0x1fc6,  0x3b7 },\t// ῆ -> η,\t ͂ (342)\n\t{ 0x1fc7,  0x3b7 },\t// ῇ -> η,\t ͂ (342),  ͅ (345)\n\t{ 0x1fc8,  0x395 },\t// Ὲ -> Ε,\t ̀ (300)\n\t{ 0x1fc9,  0x395 },\t// Έ -> Ε,\t ́ (301)\n\t{ 0x1fca,  0x397 },\t// Ὴ -> Η,\t ̀ (300)\n\t{ 0x1fcb,  0x397 },\t// Ή -> Η,\t ́ (301)\n\t{ 0x1fcc,  0x397 },\t// ῌ -> Η,\t ͅ (345)\n\t{ 0x1fd0,  0x3b9 },\t// ῐ -> ι,\t ̆ (306)\n\t{ 0x1fd1,  0x3b9 },\t// ῑ -> ι,\t ̄ (304)\n\t{ 0x1fd2,  0x3b9 },\t// ῒ -> ι,\t ̈ (308),  ̀ (300)\n\t{ 0x1fd3,  0x3b9 },\t// ΐ -> ι,\t ̈ (308),  ́ (301)\n\t{ 0x1fd6,  0x3b9 },\t// ῖ -> ι,\t ͂ (342)\n\t{ 0x1fd7,  0x3b9 },\t// ῗ -> ι,\t ̈ (308),  ͂ (342)\n\t{ 0x1fd8,  0x399 },\t// Ῐ -> Ι,\t ̆ (306)\n\t{ 0x1fd9,  0x399 },\t// Ῑ -> Ι,\t ̄ (304)\n\t{ 0x1fda,  0x399 },\t// Ὶ -> Ι,\t ̀ (300)\n\t{ 0x1fdb,  0x399 },\t// Ί -> Ι,\t ́ (301)\n\t{ 0x1fe0,  0x3c5 },\t// ῠ -> υ,\t ̆ (306)\n\t{ 0x1fe1,  0x3c5 },\t// ῡ -> υ,\t ̄ (304)\n\t{ 0x1fe2,  0x3c5 },\t// ῢ -> υ,\t ̈ (308),  ̀ (300)\n\t{ 0x1fe3,  0x3c5 },\t// ΰ -> υ,\t ̈ (308),  ́ (301)\n\t{ 0x1fe4,  0x3c1 },\t// ῤ -> ρ,\t ̓ (313)\n\t{ 0x1fe5,  0x3c1 },\t// ῥ -> ρ,\t ̔ (314)\n\t{ 0x1fe6,  0x3c5 },\t// ῦ -> υ,\t ͂ (342)\n\t{ 0x1fe7,  0x3c5 },\t// ῧ -> υ,\t ̈ (308),  ͂ (342)\n\t{ 0x1fe8,  0x3a5 },\t// Ῠ -> Υ,\t ̆ (306)\n\t{ 0x1fe9,  0x3a5 },\t// Ῡ -> Υ,\t ̄ (304)\n\t{ 0x1fea,  0x3a5 },\t// Ὺ -> Υ,\t ̀ (300)\n\t{ 0x1feb,  0x3a5 },\t// Ύ -> Υ,\t ́ (301)\n\t{ 0x1fec,  0x3a1 },\t// Ῥ -> Ρ,\t ̔ (314)\n\t{ 0x1ff2,  0x3c9 },\t// ῲ -> ω,\t ̀ (300),  ͅ (345)\n\t{ 0x1ff3,  0x3c9 },\t// ῳ -> ω,\t ͅ (345)\n\t{ 0x1ff4,  0x3c9 },\t// ῴ -> ω,\t ́ (301),  ͅ (345)\n\t{ 0x1ff6,  0x3c9 },\t// ῶ -> ω,\t ͂ (342)\n\t{ 0x1ff7,  0x3c9 },\t// ῷ -> ω,\t ͂ (342),  ͅ (345)\n\t{ 0x1ff8,  0x39f },\t// Ὸ -> Ο,\t ̀ (300)\n\t{ 0x1ff9,  0x39f },\t// Ό -> Ο,\t ́ (301)\n\t{ 0x1ffa,  0x3a9 },\t// Ὼ -> Ω,\t ̀ (300)\n\t{ 0x1ffb,  0x3a9 },\t// Ώ -> Ω,\t ́ (301)\n\t{ 0x1ffc,  0x3a9 },\t// ῼ -> Ω,\t ͅ (345)\n\t{ 0x2010,   0x2d },\t// ‐ -> -,\n\t{ 0x2012,   0x2d },\t// ‒ -> -,\n\t{ 0x2013,   0x2d },\t// – -> -,\n\t{ 0x2014,   0x2d },\t// — -> -,\n\t{ 0x2015,   0x2d },\t// ― -> -,\n\t{ 0x2018,   0x27 },\t// ‘ -> ',\n\t{ 0x2019,   0x27 },\t// ’ -> ',\n\t{ 0x201c,   0x22 },\t// “ -> \",\n\t{ 0x201d,   0x22 },\t// ” -> \",\n\t{ 0x2026,   0x2e },\t// … -> .,\n\t{ 0x2032,   0x27 },\t// ′ -> ',\n\t{ 0x2033,   0x22 },\t// ″ -> \",\n\t{ 0x212b,   0x41 },\t// Å -> A,\t ̊ (30a)\n\t{ 0x219a, 0x2190 },\t// ↚ -> ←,\t ̸ (338)\n\t{ 0x219b, 0x2192 },\t// ↛ -> →,\t ̸ (338)\n\t{ 0x21ae, 0x2194 },\t// ↮ -> ↔,\t ̸ (338)\n\t{ 0x21cd, 0x21d0 },\t// ⇍ -> ⇐,\t ̸ (338)\n\t{ 0x21ce, 0x21d4 },\t// ⇎ -> ⇔,\t ̸ (338)\n\t{ 0x21cf, 0x21d2 },\t// ⇏ -> ⇒,\t ̸ (338)\n\t{ 0x2204, 0x2203 },\t// ∄ -> ∃,\t ̸ (338)\n\t{ 0x2209, 0x2208 },\t// ∉ -> ∈,\t ̸ (338)\n\t{ 0x220c, 0x220b },\t// ∌ -> ∋,\t ̸ (338)\n\t{ 0x2212,   0x2d },\t// − -> -,\n\t{ 0x2224, 0x2223 },\t// ∤ -> ∣,\t ̸ (338)\n\t{ 0x2226, 0x2225 },\t// ∦ -> ∥,\t ̸ (338)\n\t{ 0x2241, 0x223c },\t// ≁ -> ∼,\t ̸ (338)\n\t{ 0x2244, 0x2243 },\t// ≄ -> ≃,\t ̸ (338)\n\t{ 0x2247, 0x2245 },\t// ≇ -> ≅,\t ̸ (338)\n\t{ 0x2249, 0x2248 },\t// ≉ -> ≈,\t ̸ (338)\n\t{ 0x2260,   0x3d },\t// ≠ -> =,\t ̸ (338)\n\t{ 0x2262, 0x2261 },\t// ≢ -> ≡,\t ̸ (338)\n\t{ 0x226d, 0x224d },\t// ≭ -> ≍,\t ̸ (338)\n\t{ 0x226e,   0x3c },\t// ≮ -> <,\t ̸ (338)\n\t{ 0x226f,   0x3e },\t// ≯ -> >,\t ̸ (338)\n\t{ 0x2270, 0x2264 },\t// ≰ -> ≤,\t ̸ (338)\n\t{ 0x2271, 0x2265 },\t// ≱ -> ≥,\t ̸ (338)\n\t{ 0x2274, 0x2272 },\t// ≴ -> ≲,\t ̸ (338)\n\t{ 0x2275, 0x2273 },\t// ≵ -> ≳,\t ̸ (338)\n\t{ 0x2278, 0x2276 },\t// ≸ -> ≶,\t ̸ (338)\n\t{ 0x2279, 0x2277 },\t// ≹ -> ≷,\t ̸ (338)\n\t{ 0x2280, 0x227a },\t// ⊀ -> ≺,\t ̸ (338)\n\t{ 0x2281, 0x227b },\t// ⊁ -> ≻,\t ̸ (338)\n\t{ 0x2284, 0x2282 },\t// ⊄ -> ⊂,\t ̸ (338)\n\t{ 0x2285, 0x2283 },\t// ⊅ -> ⊃,\t ̸ (338)\n\t{ 0x2288, 0x2286 },\t// ⊈ -> ⊆,\t ̸ (338)\n\t{ 0x2289, 0x2287 },\t// ⊉ -> ⊇,\t ̸ (338)\n\t{ 0x22ac, 0x22a2 },\t// ⊬ -> ⊢,\t ̸ (338)\n\t{ 0x22ad, 0x22a8 },\t// ⊭ -> ⊨,\t ̸ (338)\n\t{ 0x22ae, 0x22a9 },\t// ⊮ -> ⊩,\t ̸ (338)\n\t{ 0x22af, 0x22ab },\t// ⊯ -> ⊫,\t ̸ (338)\n\t{ 0x22e0, 0x227c },\t// ⋠ -> ≼,\t ̸ (338)\n\t{ 0x22e1, 0x227d },\t// ⋡ -> ≽,\t ̸ (338)\n\t{ 0x22e2, 0x2291 },\t// ⋢ -> ⊑,\t ̸ (338)\n\t{ 0x22e3, 0x2292 },\t// ⋣ -> ⊒,\t ̸ (338)\n\t{ 0x22ea, 0x22b2 },\t// ⋪ -> ⊲,\t ̸ (338)\n\t{ 0x22eb, 0x22b3 },\t// ⋫ -> ⊳,\t ̸ (338)\n\t{ 0x22ec, 0x22b4 },\t// ⋬ -> ⊴,\t ̸ (338)\n\t{ 0x22ed, 0x22b5 },\t// ⋭ -> ⊵,\t ̸ (338)\n\t{ 0x2adc, 0x2add },\t// ⫝̸ -> ⫝,\t ̸ (338)\n\t{ 0x3003,   0x22 },\t// 〃 -> \",\n};\n"
        },
        {
          "name": "utils.h",
          "type": "blob",
          "size": 6.966796875,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_UTILS_H\n#define CMUS_UTILS_H\n\n#ifdef HAVE_CONFIG\n#include \"config/utils.h\"\n#endif\n\n#include \"compiler.h\"\n#include \"debug.h\"\n\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <stdio.h>\n#include <time.h>\n#include <stdint.h>\n#ifdef HAVE_BYTESWAP_H\n#include <byteswap.h>\n#endif\n\n\n#define N_ELEMENTS(array) (sizeof(array) / sizeof((array)[0]))\n\nstruct slice {\n\tvoid *ptr;\n\tsize_t len;\n};\n\n#define TO_SLICE(type, ...) ((struct slice) { \\\n\t.ptr = ((type[]){__VA_ARGS__}), \\\n\t.len = N_ELEMENTS(((type[]){__VA_ARGS__})), \\\n})\n\n#define STRINGIZE_HELPER(x) #x\n#define STRINGIZE(x) STRINGIZE_HELPER(x)\n\n#define CONCATENATE_HELPER(x,y) x##y\n#define CONCATENATE(x,y) CONCATENATE_HELPER(x,y)\n\n#define getentry(ptr, offset, type) (*((type *) ((void *) ((char *) (ptr) + (offset)))))\n\n#define STATIC_ASSERT(cond) \\\n\tstatic uint8_t CONCATENATE(_cmus_unused_, __LINE__)[2*(cond) - 1] UNUSED\n\nstatic inline long min_i(long a, long b)\n{\n\treturn a < b ? a : b;\n}\n\nstatic inline unsigned long min_u(unsigned long a, unsigned long b)\n{\n\treturn a < b ? a : b;\n}\n\nstatic inline long max_i(long a, long b)\n{\n\treturn a > b ? a : b;\n}\n\nstatic inline unsigned long abs_delta(unsigned long a, unsigned long b)\n{\n\treturn a > b ? a - b : b - a;\n}\n\nstatic inline int clamp(int val, int minval, int maxval)\n{\n\tif (val < minval)\n\t\treturn minval;\n\tif (val > maxval)\n\t\treturn maxval;\n\treturn val;\n}\n\nstatic inline int scale_from_percentage(int val, int max_val)\n{\n\tif (val < 0)\n\t\treturn (val * max_val - 50) / 100;\n\treturn (val * max_val + 50) / 100;\n}\n\nstatic inline int scale_to_percentage(int val, int max_val)\n{\n\tint half = max_val / 2;\n\n\tif (max_val <= 0)\n\t\treturn 100;\n\n\tif (val < 0)\n\t\treturn (val * 100 - half) / max_val;\n\treturn (val * 100 + half) / max_val;\n}\n\nstatic inline int str_to_int(const char *str, long int *val)\n{\n\tchar *end;\n\n\t*val = strtol(str, &end, 10);\n\tif (*str == 0 || *end != 0)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic inline int strcmp0(const char *str1, const char *str2)\n{\n\tif (!str1)\n\t\treturn str2 ? -1 : 0;\n\tif (!str2)\n\t\treturn 1;\n\n\treturn strcmp(str1, str2);\n}\n\nstatic inline int is_space(const char ch)\n{\n\treturn (ch == ' ' || ch == '\\t');\n}\n\nstatic inline int ends_with(const char *str, const char *suffix)\n{\n\treturn strstr(str, suffix) + strlen(suffix) == str + strlen(str);\n}\n\nstatic inline void strip_trailing_spaces(char *str)\n{\n\tchar *end = str + strlen(str);\n\twhile (end > str && is_space(*(end-1))) {\n\t\tend--;\n\t}\n\t*end = 0;\n}\n\nstatic inline uint32_t hash_str(const char *s)\n{\n\tconst unsigned char *p = (const unsigned char *)s;\n\tuint32_t h = 5381;\n\n\twhile (*p) {\n\t\th *= 33;\n\t\th ^= *p++;\n\t}\n\n\treturn h ^ (h >> 16);\n}\n\nstatic inline time_t file_get_mtime(const char *filename)\n{\n\tstruct stat s;\n\n\t/* stat follows symlinks, lstat does not */\n\tif (stat(filename, &s) == -1)\n\t\treturn -1;\n\treturn s.st_mtime;\n}\n\nstatic inline void ns_sleep(int ns)\n{\n\tstruct timespec req;\n\n\treq.tv_sec = 0;\n\treq.tv_nsec = ns;\n\tnanosleep(&req, NULL);\n}\n\nstatic inline void us_sleep(int us)\n{\n\tns_sleep(us * 1e3);\n}\n\nstatic inline void ms_sleep(int ms)\n{\n\tns_sleep(ms * 1e6);\n}\n\nstatic inline int is_http_url(const char *name)\n{\n\treturn strncmp(name, \"http://\", 7) == 0;\n}\n\nstatic inline int is_cdda_url(const char *name)\n{\n\treturn strncmp(name, \"cdda://\", 7) == 0;\n}\n\nstatic inline int is_cue_url(const char *name)\n{\n\treturn strncmp(name, \"cue://\", 6) == 0;\n}\n\nstatic inline int is_url(const char *name)\n{\n\treturn is_http_url(name) || is_cdda_url(name) || is_cue_url(name);\n}\n\nstatic inline int is_freeform_true(const char *c)\n{\n\treturn\tc[0] == '1' ||\n\t\tc[0] == 'y' || c[0] == 'Y' ||\n\t\tc[0] == 't' || c[0] == 'T';\n}\n\n/* e.g. NetBSD */\n#if defined(bswap16)\n/* GNU libc */\n#elif defined(bswap_16)\n# define bswap16 bswap_16\n/* e.g. OpenBSD */\n#elif defined(swap16)\n# define bswap16 swap16\n#else\n# define bswap16(x) \\\n\t((((x) >> 8) & 0xff) | (((x) & 0xff) << 8))\n#endif\n\nstatic inline uint16_t swap_uint16(uint16_t x)\n{\n\treturn bswap16(x);\n}\n\n/* e.g. NetBSD */\n#if defined(bswap32)\n/* GNU libc */\n#elif defined(bswap_32)\n# define bswap32 bswap_32\n/* e.g. OpenBSD */\n#elif defined(swap32)\n# define bswap32 swap32\n#else\n# define bswap32(x) \\\n\t((((x) & 0xff000000) >> 24) | (((x) & 0x00ff0000) >>  8) |\t\\\n\t (((x) & 0x0000ff00) <<  8) | (((x) & 0x000000ff) << 24))\n#endif\n\nstatic inline uint32_t swap_uint32(uint32_t x)\n{\n\treturn bswap32(x);\n}\n\nstatic inline uint32_t read_le32(const char *buf)\n{\n\tconst unsigned char *b = (const unsigned char *)buf;\n\n\treturn b[0] | (b[1] << 8) | (b[2] << 16) | (b[3] << 24);\n}\n\nstatic inline uint32_t read_le24(const char *buf)\n{\n\tconst unsigned char *b = (const unsigned char *)buf;\n\n\treturn b[0] | (b[1] << 8) | (b[2] << 16);\n}\n\nstatic inline int32_t read_le24i(const char *buf)\n{\n\tuint32_t a = read_le24(buf);\n\treturn (a & 0x800000) ? 0xFF000000 | a : a;\n}\n\nstatic inline uint16_t read_le16(const char *buf)\n{\n\tconst unsigned char *b = (const unsigned char *)buf;\n\n\treturn b[0] | (b[1] << 8);\n}\n\nstatic int _saved_stdout;\nstatic int _saved_stderr;\n\nstatic inline void disable_stdio(void)\n{\n\t_saved_stdout = dup(1);\n\t_saved_stderr = dup(2);\n\tif (_saved_stdout == -1 || _saved_stderr == -1) {\n\t\treturn;\n\t}\n\n\tint devnull = open(\"/dev/null\", O_WRONLY);\n\tdup2(devnull, 1);\n\tdup2(devnull, 2);\n\tclose(devnull);\n}\n\nstatic inline void enable_stdio(void)\n{\n\tfflush(stdout);\n\tfflush(stderr);\n\twhile (dup2(_saved_stdout, 1) == -1 && errno == EINTR) { }\n\twhile (dup2(_saved_stderr, 2) == -1 && errno == EINTR) { }\n\tclose(_saved_stdout);\n\tclose(_saved_stderr);\n}\n\nstatic inline void init_pipes(int *out, int *in)\n{\n\tint fds[2];\n\tint rc = pipe(fds);\n\tBUG_ON(rc);\n\t*out = fds[0];\n\t*in = fds[1];\n\tint flags = fcntl(*out, F_GETFL);\n\trc = fcntl(*out, F_SETFL, flags | O_NONBLOCK);\n\tBUG_ON(rc);\n}\n\nstatic inline void notify_via_pipe(int pipe)\n{\n\tchar buf = 0;\n\tif (write(pipe, &buf, 1) != 1) {\n\t\td_print(\"write to pipe failed. errno = %d\\n\", errno);\n\t}\n}\n\nstatic inline void clear_pipe(int pipe, size_t bytes)\n{\n\tchar buf[128];\n\tsize_t bytes_to_read = min_u(sizeof(buf), bytes);\n\tif (read(pipe, buf, bytes_to_read) < 0) {\n\t\td_print(\"read from pipe failed. errno = %d\\n\", errno);\n\t}\n}\n\nstatic inline ssize_t strscpy(char *dst, const char *src, size_t size)\n{\n\tfor (size_t i = 0; i < size; i++) {\n\t\tdst[i] = src[i];\n\t\tif (src[i] == 0)\n\t\t\treturn i;\n\t}\n\tif (size > 0)\n\t\tdst[size - 1] = 0;\n\treturn -1;\n}\n\n#endif\n"
        },
        {
          "name": "wcwidth_uchar.h",
          "type": "blob",
          "size": 13.2861328125,
          "content": "/* fallback wcwidth implementation adapted from musl libc 1.2.3\n *\n * Copyright (C) 2005-2020 Rich Felker, et al.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n * \n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n#ifdef HAVE_CONFIG\n#include \"config/wcwidth.h\"\n#endif\n\n#if HAVE_WCWIDTH\nstatic int wcwidth_uchar(uchar wc) {\n\treturn wcwidth((wchar_t) wc);\n}\n#else\nstatic const unsigned char table[] = {\n16,16,16,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,16,33,16,16,16,34,35,36,\n37,38,39,40,16,16,41,16,16,16,16,16,16,16,16,16,16,16,42,43,16,16,44,16,16,16,\n16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n16,16,16,16,16,16,16,16,16,16,45,16,46,47,48,49,16,16,16,16,16,16,16,16,16,16,\n16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n16,16,16,16,16,16,16,50,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,51,16,16,52,\n53,16,54,55,56,16,16,16,16,16,16,57,16,16,58,16,59,60,61,62,63,64,65,66,67,68,\n69,70,16,71,72,73,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n16,74,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n16,16,16,75,76,16,16,16,77,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n16,16,16,16,16,16,16,78,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n16,16,79,80,16,16,16,16,16,16,16,81,16,16,16,16,16,82,83,84,16,16,16,16,16,85,\n86,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,\n255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n255,255,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,248,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,254,255,255,255,255,191,182,0,0,0,0,0,0,0,63,0,255,23,0,0,0,0,0,248,255,\n255,0,0,1,0,0,0,0,0,0,0,0,0,0,0,192,191,159,61,0,0,0,128,2,0,0,0,255,255,255,\n7,0,0,0,0,0,0,0,0,0,0,192,255,1,0,0,0,0,0,0,248,15,32,0,0,192,251,239,62,0,0,\n0,0,0,14,0,0,0,0,0,0,0,0,0,0,0,0,0,0,248,255,255,255,255,\n255,7,0,0,0,0,0,0,20,254,33,254,0,12,0,0,0,2,0,0,0,0,0,0,16,30,32,0,0,12,0,0,\n64,6,0,0,0,0,0,0,16,134,57,2,0,0,0,35,0,6,0,0,0,0,0,0,16,190,33,0,0,12,0,0,\n252,2,0,0,0,0,0,0,144,30,32,64,0,12,0,0,0,4,0,0,0,0,0,0,0,1,32,0,0,0,0,0,0,17,\n0,0,0,0,0,0,192,193,61,96,0,12,0,0,0,2,0,0,0,0,0,0,144,64,48,0,0,12,0,0,0,3,0,\n0,0,0,0,0,24,30,32,0,0,12,0,0,0,0,0,0,0,0,0,0,0,0,4,92,0,0,0,0,0,0,0,0,0,0,0,\n242,7,128,127,0,0,0,0,0,0,0,0,0,0,0,0,242,31,0,63,0,0,0,0,0,0,0,0,0,3,0,0,160,\n2,0,0,0,0,0,0,254,127,223,224,255,254,255,255,255,31,64,0,0,0,0,0,0,0,0,0,0,0,\n0,224,253,102,0,0,0,195,1,0,30,0,100,32,0,32,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,\n255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0,224,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,28,0,0,0,28,0,0,0,12,0,0,0,12,0,0,0,0,0,0,0,176,63,64,254,\n15,32,0,0,0,0,0,120,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,0,0,0,0,2,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,135,1,4,14,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n128,9,0,0,0,0,0,0,64,127,229,31,248,159,0,0,0,0,0,0,255,127,0,0,0,0,0,0,0,0,\n15,0,0,0,0,0,208,23,4,0,0,0,0,248,15,0,3,0,0,0,60,59,0,0,0,0,0,0,64,163,3,0,0,\n0,0,0,0,240,207,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,247,255,253,33,16,\n3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,\n251,0,248,0,0,0,124,0,0,0,0,0,0,223,255,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,\n255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,3,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,0,0,0,0,\n0,60,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,128,247,63,0,0,0,192,0,0,0,0,0,0,0,0,0,0,3,0,68,8,0,0,96,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,48,0,0,0,255,255,3,128,0,0,0,0,192,63,0,0,128,255,3,0,\n0,0,0,0,7,0,0,0,0,0,200,51,0,0,0,0,32,0,0,\n0,0,0,0,0,0,126,102,0,8,16,0,0,0,0,0,16,0,0,0,0,0,0,157,193,2,0,0,0,0,48,64,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,33,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,0,0,0,\n64,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,0,0,255,\n255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,14,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,1,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,110,240,0,\n0,0,0,0,135,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,0,0,0,0,0,0,0,240,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,255,1,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,255,127,0,0,0,0,0,0,128,\n3,0,0,0,0,0,120,38,0,32,0,0,0,0,0,0,7,0,0,0,128,239,31,0,0,0,0,0,0,0,8,0,3,0,\n0,0,0,0,192,127,0,30,0,0,0,0,0,0,0,0,0,0,0,128,211,64,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,128,248,7,0,0,3,0,0,0,0,0,0,24,1,0,0,0,192,31,31,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,255,92,0,0,64,0,0,0,0,0,0,0,0,0,0,248,133,13,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,60,176,1,0,0,48,0,0,0,0,0,0,0,0,0,0,\n248,167,1,0,0,0,0,0,0,0,0,0,0,0,0,40,191,0,0,0,0,0,0,0,0,0,0,0,0,224,188,15,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,255,6,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,240,12,1,0,0,0,254,7,0,0,0,0,248,121,128,0,126,14,0,0,0,0,0,252,\n127,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,127,191,0,0,0,0,0,0,0,0,0,0,252,255,\n255,252,109,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,126,180,191,0,0,0,0,0,0,0,0,0,163,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,24,0,0,0,0,0,0,0,255,\n1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,31,0,0,0,0,0,0,0,127,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,128,7,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,15,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,3,248,255,231,15,0,0,0,60,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,28,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,\n255,255,255,255,127,248,255,255,255,255,255,31,32,0,16,0,0,248,254,255,0,0,0,\n0,0,0,0,0,0,0,127,255,255,249,219,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,240,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,127,0,0,0,0,0,0,0,0,0,0,0,0,0,240,7,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n};\n\nstatic const unsigned char wtable[] = {\n16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,18,16,16,16,16,16,16,16,16,\n16,16,16,16,16,16,16,16,16,19,16,20,21,22,16,16,16,23,16,16,24,25,26,27,28,17,\n17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,29,\n17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n17,17,17,17,17,17,17,17,30,16,16,16,16,31,16,16,17,17,17,17,17,17,17,17,17,17,\n17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n17,17,17,17,17,17,17,32,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,17,16,16,16,33,\n34,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n16,16,16,16,16,16,16,16,35,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n17,17,17,17,17,17,36,17,17,37,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,38,39,16,16,\n16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n16,16,16,16,16,16,16,40,41,42,43,44,45,46,47,16,48,49,16,16,16,16,\n16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,\n255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n255,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,0,6,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,30,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,0,0,48,0,0,0,0,0,0,255,15,0,0,0,0,128,0,0,8,\n0,2,12,0,96,48,64,16,0,0,4,44,36,32,12,0,0,0,1,0,0,0,80,184,0,0,0,0,0,0,0,224,\n0,0,0,1,128,0,0,0,0,0,0,0,0,0,0,0,24,0,0,0,0,0,0,33,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,251,255,255,255,255,255,255,255,\n255,255,255,15,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n255,255,255,255,255,255,255,255,255,255,255,63,0,0,0,255,15,255,255,255,255,\n255,255,255,127,254,255,255,255,255,255,255,255,255,255,127,254,255,255,255,\n255,255,255,255,255,255,255,255,255,224,255,255,255,255,255,254,255,255,255,\n255,255,255,255,255,255,255,127,255,255,255,255,255,7,255,255,255,255,15,0,\n255,255,255,255,255,127,255,255,255,255,255,0,255,255,255,255,255,255,255,255,\n255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,\n0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n255,31,255,255,255,255,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,\n255,255,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,255,3,0,0,255,255,255,255,247,255,127,15,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,254,255,255,255,255,255,255,255,255,255,255,\n255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,15,0,0,0,255,255,255,255,255,255,255,255,255,255,255,\n255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n255,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n255,255,255,255,255,255,255,255,255,255,255,255,7,0,255,255,255,127,0,0,0,0,0,\n0,7,0,240,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n15,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,64,254,7,0,0,0,0,0,0,0,0,0,0,0,0,7,0,255,255,255,\n255,255,15,255,1,3,0,63,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,\n1,224,191,255,255,255,255,255,255,255,255,223,255,255,15,0,255,255,255,255,\n255,135,15,0,255,255,17,255,255,255,255,255,255,255,255,127,253,255,255,255,\n255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n159,255,255,255,255,255,255,255,63,0,120,255,255,255,0,0,4,0,0,96,0,16,0,0,0,\n0,0,0,0,0,0,0,248,255,255,255,255,255,255,255,255,255,255,0,0,0,0,0,0,255,255,\n255,255,255,255,255,255,63,16,39,0,0,24,240,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,255,15,0,\n0,0,224,255,255,255,255,255,255,255,255,255,255,255,255,123,252,255,255,255,\n255,231,199,255,255,255,231,255,255,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,15,7,7,0,63,0,0,0,0,0,0,0,0,0,0,0,0,0,\n};\n\nstatic int wcwidth_uchar(uchar wc)\n{\n\tif (wc < 0xffU)\n\t\treturn ((wc+1) & 0x7f) >= 0x21 ? 1 : wc ? -1 : 0;\n\tif ((wc & 0xfffeffffU) < 0xfffe) {\n\t\tif ((table[table[wc>>8]*32+((wc&255)>>3)]>>(wc&7))&1)\n\t\t\treturn 0;\n\t\tif ((wtable[wtable[wc>>8]*32+((wc&255)>>3)]>>(wc&7))&1)\n\t\t\treturn 2;\n\t\treturn 1;\n\t}\n\tif ((wc & 0xfffe) == 0xfffe)\n\t\treturn -1;\n\tif (wc-0x20000U < 0x20000)\n\t\treturn 2;\n\tif (wc == 0xe0001 || wc-0xe0020U < 0x5f || wc-0xe0100U < 0xef)\n\t\treturn 0;\n\treturn 1;\n}\n#endif\n"
        },
        {
          "name": "window.c",
          "type": "blob",
          "size": 12.853515625,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004-2005 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"window.h\"\n#include \"options.h\"\n#include \"xmalloc.h\"\n#include \"debug.h\"\n#include \"utils.h\"\n\n#include <stdlib.h>\n\nstatic void sel_changed(struct window *win)\n{\n\tif (win->sel_changed)\n\t\twin->sel_changed();\n\twin->changed = 1;\n}\n\nstatic int selectable(struct window *win, struct iter *iter)\n{\n\tif (win->selectable)\n\t\treturn win->selectable(iter);\n\treturn 1;\n}\n\nstruct window *window_new(int (*get_prev)(struct iter *), int (*get_next)(struct iter *))\n{\n\tstruct window *win;\n\n\twin = xnew(struct window, 1);\n\twin->get_next = get_next;\n\twin->get_prev = get_prev;\n\twin->selectable = NULL;\n\twin->sel_changed = NULL;\n\twin->nr_rows = 1;\n\twin->changed = 1;\n\titer_init(&win->head);\n\titer_init(&win->top);\n\titer_init(&win->sel);\n\treturn win;\n}\n\nvoid window_free(struct window *win)\n{\n\tfree(win);\n}\n\nvoid window_set_empty(struct window *win)\n{\n\titer_init(&win->head);\n\titer_init(&win->top);\n\titer_init(&win->sel);\n\tsel_changed(win);\n}\n\nvoid window_set_contents(struct window *win, void *head)\n{\n\tstruct iter first;\n\n\twin->head.data0 = head;\n\twin->head.data1 = NULL;\n\twin->head.data2 = NULL;\n\tfirst = win->head;\n\twin->get_next(&first);\n\twin->top = first;\n\twin->sel = first;\n\twhile (!selectable(win, &win->sel))\n\t\twin->get_next(&win->sel);\n\tsel_changed(win);\n}\n\nvoid window_set_nr_rows(struct window *win, int nr_rows)\n{\n\tif (nr_rows < 1)\n\t\treturn;\n\twin->nr_rows = nr_rows;\n\twindow_changed(win);\n\twin->changed = 1;\n}\n\nvoid window_up(struct window *win, int rows)\n{\n\tstruct iter iter;\n\tint upper_bound   = min_i(scroll_offset,  win->nr_rows/2);\n\tint buffer        = 0; /* rows between `old sel` and `old top` */\n\tint sel_up        = 0; /* selectable rows between `old sel` and `new sel` */\n\tint skipped       = 0; /* unselectable rows between `old sel` and `new sel` */\n\tint actual_offset = 0; /* rows between `new sel` and `new top` */\n\tint top_up        = 0; /* rows between `old top` and `new top` */\n\n\titer = win->top;\n\twhile (!iters_equal(&iter, &win->sel)) {\n\t\twin->get_next(&iter);\n\t\tbuffer++;\n\t}\n\n\titer = win->sel;\n\twhile (sel_up < rows) {\n\t\tif (!win->get_prev(&iter)) {\n\t\t\tbreak;\n\t\t}\n\t\tif (selectable(win, &iter)) {\n\t\t\tsel_up++;\n\t\t\twin->sel = iter;\n\t\t} else {\n\t\t\tskipped++;\n\t\t}\n\t}\n\t/* if there is no selectable row above the current, we move win->top instead\n\t * this is necessary when scroll_offset=0 to make the first album header visible */\n\tif (sel_up == 0) {\n\t\tskipped = 0;\n\t\tupper_bound = min_i(buffer+rows, win->nr_rows/2);\n\t}\n\n\titer = win->sel;\n\twhile (actual_offset < upper_bound) {\n\t\tif (!win->get_prev(&iter)) {\n\t\t\tbreak;\n\t\t}\n\t\tactual_offset++;\n\t}\n\n\ttop_up = actual_offset + sel_up + skipped - buffer;\n\twhile (top_up > 0) {\n\t\twin->get_prev(&win->top);\n\t\ttop_up--;\n\t}\n\n\tif (sel_up > 0 || actual_offset > 0)\n\t\tsel_changed(win);\n}\n\nvoid window_down(struct window *win, int rows)\n{\n\tstruct iter iter;\n\tint upper_bound   = min_i(scroll_offset, (win->nr_rows-1)/2);\n\tint buffer        = 0; /* rows between `old sel` and `old bottom` */\n\tint sel_down      = 0; /* selectable rows between `old sel` and `new sel` */\n\tint skipped       = 0; /* unselectable rows between `old sel` and `new sel` */\n\tint actual_offset = 0; /* rows between `new sel` and `new bottom` */\n\tint top_down      = 0; /* rows between `old top` and `new top` */\n\n\tbuffer = win->nr_rows - 1;\n\titer = win->top;\n\twhile (!iters_equal(&iter, &win->sel)) {\n\t\twin->get_next(&iter);\n\t\tbuffer--;\n\t}\n\n\titer = win->sel;\n\twhile (sel_down < rows) {\n\t\tif (!win->get_next(&iter)) {\n\t\t\tbreak;\n\t\t}\n\t\tif (selectable(win, &iter)) {\n\t\t\tsel_down++;\n\t\t\twin->sel = iter;\n\t\t} else {\n\t\t\tskipped++;\n\t\t}\n\t}\n\tif (sel_down == 0) {\n\t\tskipped = 0;\n\t\tupper_bound = min_i(buffer+rows, (win->nr_rows-1)/2);\n\t}\n\n\titer = win->sel;\n\twhile (actual_offset < upper_bound) {\n\t\tif (!win->get_next(&iter))\n\t\t\tbreak;\n\t\tactual_offset++;\n\t}\n\n\ttop_down = actual_offset + sel_down + skipped - buffer;\n\twhile (top_down > 0) {\n\t\twin->get_next(&win->top);\n\t\ttop_down--;\n\t}\n\n\tif (sel_down > 0 || actual_offset > 0)\n\t\tsel_changed(win);\n}\n\n/*\n * minimize number of empty lines visible\n * make sure selection is visible\n */\nvoid window_changed(struct window *win)\n{\n\tstruct iter iter;\n\tint delta, rows;\n\n\tif (iter_is_null(&win->head)) {\n\t\tBUG_ON(!iter_is_null(&win->top));\n\t\tBUG_ON(!iter_is_null(&win->sel));\n\t\treturn;\n\t}\n\tBUG_ON(iter_is_null(&win->top));\n\tBUG_ON(iter_is_null(&win->sel));\n\n\t/* make sure top and sel point to real row if possible */\n\tif (iter_is_head(&win->top)) {\n\t\twin->get_next(&win->top);\n\t\twin->sel = win->top;\n\t\tsel_changed(win);\n\t\treturn;\n\t}\n\n\t/* make sure the selected row is visible */\n\n\t/* get distance between top and sel */\n\tdelta = 0;\n\titer = win->top;\n\twhile (!iters_equal(&iter, &win->sel)) {\n\t\tif (!win->get_next(&iter)) {\n\t\t\t/* sel < top, scroll up until top == sel */\n\t\t\twhile (!iters_equal(&win->top, &win->sel))\n\t\t\t\twin->get_prev(&win->top);\n\t\t\tgoto minimize;\n\t\t}\n\t\tdelta++;\n\t}\n\n\t/* scroll down until sel is visible */\n\twhile (delta > win->nr_rows - 1) {\n\t\twin->get_next(&win->top);\n\t\tdelta--;\n\t}\nminimize:\n\t/* minimize number of empty lines shown */\n\titer = win->top;\n\trows = 1;\n\twhile (rows < win->nr_rows) {\n\t\tif (!win->get_next(&iter))\n\t\t\tbreak;\n\t\trows++;\n\t}\n\twhile (rows < win->nr_rows) {\n\t\titer = win->top;\n\t\tif (!win->get_prev(&iter))\n\t\t\tbreak;\n\t\twin->top = iter;\n\t\trows++;\n\t}\n\twin->changed = 1;\n}\n\nvoid window_row_vanishes(struct window *win, struct iter *iter)\n{\n\tstruct iter new = *iter;\n\tif (!win->get_next(&new) && !win->get_prev(&new)) {\n\t\twindow_set_empty(win);\n\t}\n\n\tBUG_ON(iter->data0 != win->head.data0);\n\tif (iters_equal(&win->top, iter)) {\n\t\tnew = *iter;\n\t\tif (win->get_next(&new)) {\n\t\t\twin->top = new;\n\t\t} else {\n\t\t\tnew = *iter;\n\t\t\twin->get_prev(&new);\n\t\t\twin->top = new;\n\t\t}\n\t}\n\tif (iters_equal(&win->sel, iter)) {\n\t\t/* calculate minimal distance to next selectable */\n\t\tint down = 0;\n\t\tint up = 0;\n\t\tnew = *iter;\n\t\tdo {\n\t\t\tif (!win->get_next(&new)) {\n\t\t\t\tdown = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdown++;\n\t\t} while (!selectable(win, &new));\n\t\tnew = *iter;\n\t\tdo {\n\t\t\tif (!win->get_prev(&new)) {\n\t\t\t\tup = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tup++;\n\t\t} while (!selectable(win, &new));\n\t\tnew = *iter;\n\t\tif (down > 0 && (up == 0 || down <= up)) {\n\t\t\tdo {\n\t\t\t\twin->get_next(&new);\n\t\t\t} while (!selectable(win, &new));\n\t\t} else if (up > 0) {\n\t\t\tdo {\n\t\t\t\twin->get_prev(&new);\n\t\t\t} while (!selectable(win, &new));\n\t\t} else {\n\t\t\t/* no selectable item left but window not empty */\n\t\t\tnew.data1 = new.data2 = NULL;\n\t\t}\n\t\twin->sel = new;\n\t\tsel_changed(win);\n\t}\n\n\twin->changed = 1;\n}\n\nint window_get_top(struct window *win, struct iter *iter)\n{\n\t*iter = win->top;\n\treturn !iter_is_empty(iter);\n}\n\nint window_get_sel(struct window *win, struct iter *iter)\n{\n\t*iter = win->sel;\n\treturn !iter_is_empty(iter);\n}\n\nint window_get_prev(struct window *win, struct iter *iter)\n{\n\treturn win->get_prev(iter);\n}\n\nint window_get_next(struct window *win, struct iter *iter)\n{\n\treturn win->get_next(iter);\n}\n\nvoid window_set_sel(struct window *win, struct iter *iter)\n{\n\tint sel_nr, top_nr, bottom_nr;\n\tint upper_bound;\n\tstruct iter tmp;\n\n\tBUG_ON(iter_is_empty(&win->top));\n\tBUG_ON(iter_is_empty(iter));\n\tBUG_ON(iter->data0 != win->head.data0);\n\n\tif (iters_equal(&win->sel, iter))\n\t\treturn;\n\twin->sel = *iter;\n\n\ttmp = win->head;\n\twin->get_next(&tmp);\n\ttop_nr = 0;\n\twhile (!iters_equal(&tmp, &win->top)) {\n\t\twin->get_next(&tmp);\n\t\ttop_nr++;\n\t}\n\n\ttmp = win->head;\n\twin->get_next(&tmp);\n\tsel_nr = 0;\n\twhile (!iters_equal(&tmp, &win->sel)) {\n\t\tBUG_ON(!win->get_next(&tmp));\n\t\tsel_nr++;\n\t}\n\n\tupper_bound = win->nr_rows / 2;\n\tif (scroll_offset < upper_bound)\n\t\tupper_bound = scroll_offset;\n\n\tif (sel_nr < top_nr + upper_bound) { /* scroll up */\n\t\ttmp = win->head;\n\t\twin->get_next(&tmp);\n\t\tif (sel_nr < upper_bound) { /* no space above */\n\t\t\twin->top = tmp;\n\t\t} else {\n\t\t\twin->top = win->sel;\n\t\t\twhile (upper_bound > 0) {\n\t\t\t\twin->get_prev(&win->top);\n\t\t\t\tupper_bound--;\n\t\t\t}\n\t\t}\n\t} else { /* scroll down */\n\t\tupper_bound = (win->nr_rows - 1) / 2;\n\t\tif (scroll_offset < upper_bound)\n\t\t\tupper_bound = scroll_offset;\n\n\t\ttmp = win->sel;\n\t\tbottom_nr = sel_nr;\n\t\tif (sel_nr >= top_nr + win->nr_rows) { /* selected element not visible */\n\t\t\twhile (sel_nr >= top_nr + win->nr_rows) {\n\t\t\t\twin->get_next(&win->top);\n\t\t\t\ttop_nr++;\n\t\t\t}\n\t\t} else { /* selected element visible */\n\t\t\twhile (bottom_nr + 1 < top_nr + win->nr_rows) {\n\t\t\t\tif (!win->get_next(&tmp)) { /* no space below */\n\t\t\t\t\tbottom_nr = sel_nr + upper_bound;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbottom_nr++;\n\t\t\t}\n\t\t}\n\n\t\twhile (bottom_nr < sel_nr + upper_bound) {\n\t\t\tif (!win->get_next(&tmp))\n\t\t\t\tbreak;\n\t\t\tbottom_nr++;\n\t\t\twin->get_next(&win->top);\n\t\t}\n\t}\n\tsel_changed(win);\n}\n\nvoid window_goto_top(struct window *win)\n{\n\tstruct iter old_sel;\n\n\told_sel = win->sel;\n\twin->sel = win->head;\n\twin->get_next(&win->sel);\n\twin->top = win->sel;\n\twhile (!selectable(win, &win->sel))\n\t\twin->get_next(&win->sel);\n\tif (!iters_equal(&old_sel, &win->sel))\n\t\tsel_changed(win);\n}\n\nvoid window_goto_bottom(struct window *win)\n{\n\tstruct iter old_sel;\n\tint count;\n\n\told_sel = win->sel;\n\twin->sel = win->head;\n\twin->get_prev(&win->sel);\n\twin->top = win->sel;\n\tcount = win->nr_rows - 1;\n\twhile (count) {\n\t\tstruct iter iter = win->top;\n\n\t\tif (!win->get_prev(&iter))\n\t\t\tbreak;\n\t\twin->top = iter;\n\t\tcount--;\n\t}\n\twhile (!selectable(win, &win->sel))\n\t\twin->get_prev(&win->sel);\n\tif (!iters_equal(&old_sel, &win->sel))\n\t\tsel_changed(win);\n}\n\nvoid window_page_up(struct window *win)\n{\n\tstruct iter sel = win->sel;\n\tstruct iter top = win->top;\n\tint up;\n\n\tfor (up = 0; up < win->nr_rows - 1; up++) {\n\t\tif (!win->get_prev(&sel) || !win->get_prev(&top))\n\t\t\tbreak;\n\t\tif (selectable(win, &sel)) {\n\t\t\twin->sel = sel;\n\t\t\twin->top = top;\n\t\t}\n\t}\n\n\tsel_changed(win);\n}\n\nvoid window_half_page_up(struct window *win)\n{\n\tstruct iter sel = win->sel;\n\tstruct iter top = win->top;\n\tint up;\n\n\tfor (up = 0; up < (win->nr_rows - 1) / 2; up++) {\n\t\tif (!win->get_prev(&sel) || !win->get_prev(&top))\n\t\t\tbreak;\n\t\tif (selectable(win, &sel)) {\n\t\t\twin->sel = sel;\n\t\t\twin->top = top;\n\t\t}\n\t}\n\n\tsel_changed(win);\n}\n\nstatic struct iter window_bottom(struct window *win)\n{\n\tstruct iter bottom = win->top;\n\tstruct iter iter = win->top;\n\tint down;\n\n\tfor (down = 0; down < win->nr_rows - 1; down++) {\n\t\tif (!win->get_next(&iter))\n\t\t\tbreak;\n\t\tbottom = iter;\n\t}\n\n\treturn bottom;\n}\n\nvoid window_page_down(struct window *win)\n{\n\tstruct iter sel = win->sel;\n\tstruct iter bot = window_bottom(win);\n\tstruct iter top = win->top;\n\tint down;\n\n\tfor (down = 0; down < win->nr_rows - 1; down++) {\n\t\tif (!win->get_next(&sel) || !win->get_next(&bot))\n\t\t\tbreak;\n\t\twin->get_next(&top);\n\t\tif (selectable(win, &sel)) {\n\t\t\twin->sel = sel;\n\t\t\twin->top = top;\n\t\t}\n\t}\n\n\tsel_changed(win);\n}\n\nvoid window_half_page_down(struct window *win)\n{\n\tstruct iter sel = win->sel;\n\tstruct iter bot = window_bottom(win);\n\tstruct iter top = win->top;\n\tint down;\n\n\tfor (down = 0; down < (win-> nr_rows - 1) / 2; down++) {\n\t\tif (!win->get_next(&sel) || !win->get_next(&bot))\n\t\t\tbreak;\n\t\twin->get_next(&top);\n\t\tif (selectable(win, &sel)) {\n\t\t\twin->sel = sel;\n\t\t\twin->top = top;\n\t\t}\n\t}\n\n\tsel_changed(win);\n}\n\n\nvoid window_scroll_down(struct window *win)\n{\n\tstruct iter bot = window_bottom(win);\n\tstruct iter top = win->top;\n\tif (!win->get_next(&bot)) return;\n\tif (!win->get_next(&top)) return;\n\tif (iters_equal(&win->top, &win->sel))\n\t\twin->get_next(&win->sel);\n\twin->top = top;\n\twhile (!selectable(win, &win->sel))\n\t\twin->get_next(&win->sel);\n\tsel_changed(win);\n}\n\nvoid window_scroll_up(struct window *win)\n{\n\tstruct iter top = win->top;\n\tif (!win->get_prev(&top)) return;\n\tstruct iter bot = window_bottom(win);\n\t/* keep selected row on screen: */\n\tif (iters_equal(&bot, &win->sel))\n\t\twin->get_prev(&win->sel);\n\twin->top = top;\n\twhile (!selectable(win, &win->sel))\n\t\twin->get_prev(&win->sel);\n\tsel_changed(win);\n}\n\nstatic void window_goto_pos(struct window *win, int pos)\n{\n\tstruct iter old_sel;\n\tint i;\n\n\told_sel = win->sel;\n\twin->sel = win->top;\n\tfor (i = 0; i < pos; i++)\n\t\twin->get_next(&win->sel);\n\tif (!iters_equal(&old_sel, &win->sel))\n\t\tsel_changed(win);\n}\n\nvoid window_page_top(struct window *win)\n{\n\twindow_goto_pos(win, 0);\n\twhile (!selectable(win, &win->sel))\n\t\twin->get_next(&win->sel);\n}\n\nvoid window_page_bottom(struct window *win)\n{\n\twindow_goto_pos(win, win->nr_rows - 1);\n\twhile (!selectable(win, &win->sel))\n\t\twin->get_prev(&win->sel);\n}\n\nvoid window_page_middle(struct window *win)\n{\n\twindow_goto_pos(win, win->nr_rows / 2);\n\twhile (!selectable(win, &win->sel))\n\t\twin->get_next(&win->sel);\n}\n\nint window_get_nr_rows(struct window *win)\n{\n\treturn win->nr_rows;\n}\n"
        },
        {
          "name": "window.h",
          "type": "blob",
          "size": 3.4111328125,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004-2005 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_WINDOW_H\n#define CMUS_WINDOW_H\n\n#include \"iter.h\"\n\n/*\n * window contains list of rows\n * - the list is double linked circular list\n * - head contains no data. head is not a real row\n * - head->prev gets the last row (or head if the list is empty) in the list\n * - head->next gets the first row (or head if the list is empty) in the list\n *\n * get_prev(&iter) always stores prev row to the iter\n * get_next(&iter) always stores next row to the iter\n *\n * these return 1 if the new row is real row (not head), 0 otherwise\n *\n * sel_changed callback is called if not NULL and selection has changed\n */\n\nstruct window {\n\t/* head of the row list */\n\tstruct iter head;\n\n\t/* top row */\n\tstruct iter top;\n\n\t/* selected row */\n\tstruct iter sel;\n\n\t/* window height */\n\tint nr_rows;\n\n\tunsigned changed : 1;\n\n\t/* return 1 if got next/prev, otherwise 0 */\n\tint (*get_prev)(struct iter *iter);\n\tint (*get_next)(struct iter *iter);\n\t/* NULL if all rows are selectable */\n\tint (*selectable)(struct iter *iter);\n\tvoid (*sel_changed)(void);\n};\n\nstruct window *window_new(int (*get_prev)(struct iter *), int (*get_next)(struct iter *));\nvoid window_free(struct window *win);\nvoid window_set_empty(struct window *win);\nvoid window_set_contents(struct window *win, void *head);\n\n/* call this after rows were added to window or order of rows was changed.\n * top and sel MUST point to valid rows (or window must be empty, but then\n * why do you want to call this function :)).\n *\n * if you remove row from window then call window_row_vanishes BEFORE removing\n * the row instead of this function.\n */\nvoid window_changed(struct window *win);\n\n/* call this BEFORE row is removed from window */\nvoid window_row_vanishes(struct window *win, struct iter *iter);\n\nint window_get_top(struct window *win, struct iter *iter);\nint window_get_sel(struct window *win, struct iter *iter);\nint window_get_prev(struct window *win, struct iter *iter);\nint window_get_next(struct window *win, struct iter *iter);\n\n/* set selected row */\nvoid window_set_sel(struct window *win, struct iter *iter);\n\nvoid window_set_nr_rows(struct window *win, int nr_rows);\nvoid window_up(struct window *win, int rows);\nvoid window_down(struct window *win, int rows);\nvoid window_goto_top(struct window *win);\nvoid window_goto_bottom(struct window *win);\nvoid window_page_up(struct window *win);\nvoid window_half_page_up(struct window *win);\nvoid window_page_down(struct window *win);\nvoid window_half_page_down(struct window *win);\nvoid window_scroll_down(struct window *win);\nvoid window_scroll_up(struct window *win);\nvoid window_page_top(struct window *win);\nvoid window_page_bottom(struct window *win);\nvoid window_page_middle(struct window *win);\n\nint window_get_nr_rows(struct window *win);\n\n#endif\n"
        },
        {
          "name": "worker.c",
          "type": "blob",
          "size": 4.8935546875,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"worker.h\"\n#include \"locking.h\"\n#include \"list.h\"\n#include \"xmalloc.h\"\n#include \"debug.h\"\n#include \"job.h\"\n\n#include <stdlib.h>\n#include <stdint.h>\n#include <pthread.h>\n\nstruct worker_job {\n\tstruct list_head node;\n\n\tuint32_t type;\n\tvoid (*job_cb)(void *data);\n\tvoid (*free_cb)(void *data);\n\tvoid *data;\n};\n\nenum worker_state {\n\tWORKER_PAUSED,\n\tWORKER_RUNNING,\n\tWORKER_STOPPED,\n};\n\nstatic LIST_HEAD(worker_job_head);\nstatic pthread_mutex_t worker_mutex = CMUS_MUTEX_INITIALIZER;\nstatic pthread_cond_t worker_cond = PTHREAD_COND_INITIALIZER;\nstatic pthread_t worker_thread;\nstatic enum worker_state state = WORKER_PAUSED;\nstatic int cancel_current = 0;\n\n/*\n * - only worker thread modifies this\n * - cur_job->job_cb can read this without locking\n * - anyone else must lock worker before reading this\n */\nstatic struct worker_job *cur_job = NULL;\n\n#define worker_lock() cmus_mutex_lock(&worker_mutex)\n#define worker_unlock() cmus_mutex_unlock(&worker_mutex)\n\nstatic void *worker_loop(void *arg)\n{\n\tsrand(time(NULL));\n\n\tworker_lock();\n\twhile (1) {\n\t\tif (state != WORKER_RUNNING || list_empty(&worker_job_head)) {\n\t\t\tint rc;\n\n\t\t\tif (state == WORKER_STOPPED)\n\t\t\t\tbreak;\n\n\t\t\trc = pthread_cond_wait(&worker_cond, &worker_mutex);\n\t\t\tif (rc)\n\t\t\t\td_print(\"pthread_cond_wait: %s\\n\", strerror(rc));\n\t\t} else {\n\t\t\tstruct list_head *item = worker_job_head.next;\n\t\t\tuint64_t t;\n\n\t\t\tlist_del(item);\n\t\t\tcur_job = container_of(item, struct worker_job, node);\n\t\t\tworker_unlock();\n\n\t\t\tt = timer_get();\n\t\t\tcur_job->job_cb(cur_job->data);\n\t\t\ttimer_print(\"worker job\", timer_get() - t);\n\n\t\t\tworker_lock();\n\t\t\tcur_job->free_cb(cur_job->data);\n\t\t\tfree(cur_job);\n\t\t\tcur_job = NULL;\n\n\t\t\t// wakeup worker_remove_jobs_*() if needed\n\t\t\tif (cancel_current) {\n\t\t\t\tcancel_current = 0;\n\t\t\t\tpthread_cond_signal(&worker_cond);\n\t\t\t}\n\t\t}\n\t}\n\tworker_unlock();\n\treturn NULL;\n}\n\nvoid worker_init(void)\n{\n\tint rc = pthread_create(&worker_thread, NULL, worker_loop, NULL);\n\n\tBUG_ON(rc);\n}\n\nstatic void worker_set_state(enum worker_state s)\n{\n\tworker_lock();\n\tstate = s;\n\tpthread_cond_signal(&worker_cond);\n\tworker_unlock();\n}\n\nvoid worker_start(void)\n{\n\tworker_set_state(WORKER_RUNNING);\n}\n\nvoid worker_exit(void)\n{\n\tworker_set_state(WORKER_STOPPED);\n\tpthread_join(worker_thread, NULL);\n}\n\nvoid worker_add_job(uint32_t type, void (*job_cb)(void *data),\n\t\tvoid (*free_cb)(void *data), void *data)\n{\n\tstruct worker_job *job;\n\n\tjob = xnew(struct worker_job, 1);\n\tjob->type = type;\n\tjob->job_cb = job_cb;\n\tjob->free_cb = free_cb;\n\tjob->data = data;\n\n\tworker_lock();\n\tlist_add_tail(&job->node, &worker_job_head);\n\tpthread_cond_signal(&worker_cond);\n\tworker_unlock();\n}\n\nstatic int worker_matches_type(uint32_t type, void *job_data,\n\t\tvoid *opaque)\n{\n\tuint32_t *pat = opaque;\n\treturn !!(type & *pat);\n}\n\nvoid worker_remove_jobs_by_type(uint32_t pat)\n{\n\tworker_remove_jobs_by_cb(worker_matches_type, &pat);\n}\n\nvoid worker_remove_jobs_by_cb(worker_match_cb cb, void *opaque)\n{\n\tstruct list_head *item;\n\n\tworker_lock();\n\n\titem = worker_job_head.next;\n\twhile (item != &worker_job_head) {\n\t\tstruct worker_job *job = container_of(item, struct worker_job,\n\t\t\t\tnode);\n\t\tstruct list_head *next = item->next;\n\n\t\tif (cb(job->type, job->data, opaque)) {\n\t\t\tlist_del(&job->node);\n\t\t\tjob->free_cb(job->data);\n\t\t\tfree(job);\n\t\t}\n\t\titem = next;\n\t}\n\n\t/* wait current job to finish or cancel if it's of the specified type */\n\tif (cur_job && cb(cur_job->type, cur_job->data, opaque)) {\n\t\tcancel_current = 1;\n\t\twhile (cancel_current)\n\t\t\tpthread_cond_wait(&worker_cond, &worker_mutex);\n\t}\n\n\tworker_unlock();\n}\n\nint worker_has_job(void)\n{\n\t/* lock not needed for this simple check */\n\treturn cur_job || !list_empty(&worker_job_head);\n}\n\nint worker_has_job_by_type(uint32_t pat)\n{\n\treturn worker_has_job_by_cb(worker_matches_type, &pat);\n}\n\nint worker_has_job_by_cb(worker_match_cb cb, void *opaque)\n{\n\tstruct worker_job *job;\n\tint has_job = 0;\n\n\tworker_lock();\n\tlist_for_each_entry(job, &worker_job_head, node) {\n\t\tif (cb(job->type, job->data, opaque)) {\n\t\t\thas_job = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (cur_job && cb(cur_job->type, cur_job->data, opaque))\n\t\thas_job = 1;\n\tworker_unlock();\n\treturn has_job;\n}\n\n/*\n * this is only called from the worker thread\n * cur_job is guaranteed to be non-NULL\n */\nint worker_cancelling(void)\n{\n\treturn cancel_current;\n}\n"
        },
        {
          "name": "worker.h",
          "type": "blob",
          "size": 1.478515625,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_WORKER_H\n#define CMUS_WORKER_H\n\n#include <stdint.h>\n\n#define JOB_TYPE_NONE 0\n#define JOB_TYPE_ANY  ~0\n\ntypedef int (*worker_match_cb)(uint32_t type, void *job_data, void *opaque);\n\nvoid worker_init(void);\nvoid worker_start(void);\nvoid worker_exit(void);\n\nvoid worker_add_job(uint32_t type, void (*job_cb)(void *job_data),\n\t\tvoid (*free_cb)(void *job_data), void *job_data);\n\n/* NOTE: The callbacks below run in parallel with the job_cb function. Access to\n * job_data must by synchronized.\n */\n\nvoid worker_remove_jobs_by_type(uint32_t pat);\nvoid worker_remove_jobs_by_cb(worker_match_cb cb, void *opaque);\n\nint worker_has_job(void);\nint worker_has_job_by_type(uint32_t pat);\nint worker_has_job_by_cb(worker_match_cb cb, void *opaque);\n\nint worker_cancelling(void);\n\n#endif\n"
        },
        {
          "name": "xmalloc.c",
          "type": "blob",
          "size": 1.173828125,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004-2005 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"xmalloc.h\"\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n\nextern char *program_name;\n\nvoid malloc_fail(void)\n{\n\tfprintf(stderr, \"%s: could not allocate memory: %s\\n\", program_name, strerror(errno));\n\texit(42);\n}\n\n#ifndef HAVE_STRNDUP\nchar *xstrndup(const char *str, size_t n)\n{\n\tsize_t len;\n\tchar *s;\n\n\tfor (len = 0; len < n && str[len]; len++)\n\t\t;\n\ts = xmalloc(len + 1);\n\tmemcpy(s, str, len);\n\ts[len] = 0;\n\treturn s;\n}\n#endif\n"
        },
        {
          "name": "xmalloc.h",
          "type": "blob",
          "size": 2.203125,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004-2005 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_XMALLOC_H\n#define CMUS_XMALLOC_H\n\n#include \"compiler.h\"\n#ifdef HAVE_CONFIG\n#include \"config/xmalloc.h\"\n#endif\n\n#include <stdlib.h>\n#include <string.h>\n\nvoid malloc_fail(void) CMUS_NORETURN;\n\n#define xnew(type, n)\t\t(type *)xmalloc(sizeof(type) * (n))\n#define xnew0(type, n)\t\t(type *)xmalloc0(sizeof(type) * (n))\n#define xrenew(type, mem, n)\t(type *)xrealloc(mem, sizeof(type) * (n))\n\nstatic inline void * CMUS_MALLOC xmalloc(size_t size)\n{\n\tvoid *ptr = malloc(size);\n\n\tif (unlikely(ptr == NULL))\n\t\tmalloc_fail();\n\treturn ptr;\n}\n\nstatic inline void * CMUS_MALLOC xmalloc0(size_t size)\n{\n\tvoid *ptr = calloc(1, size);\n\n\tif (unlikely(ptr == NULL))\n\t\tmalloc_fail();\n\treturn ptr;\n}\n\nstatic inline void * CMUS_MALLOC xrealloc(void *ptr, size_t size)\n{\n\tptr = realloc(ptr, size);\n\tif (unlikely(ptr == NULL))\n\t\tmalloc_fail();\n\treturn ptr;\n}\n\nstatic inline char * CMUS_MALLOC xstrdup(const char *str)\n{\n#ifdef HAVE_STRDUP\n\tchar *s = strdup(str);\n\tif (unlikely(s == NULL))\n\t\tmalloc_fail();\n\treturn s;\n#else\n\tsize_t size = strlen(str) + 1;\n\tvoid *ptr = xmalloc(size);\n\treturn (char *) memcpy(ptr, str, size);\n#endif\n}\n\n#ifdef HAVE_STRNDUP\nstatic inline char * CMUS_MALLOC xstrndup(const char *str, size_t n)\n{\n\tchar *s = strndup(str, n);\n\tif (unlikely(s == NULL))\n\t\tmalloc_fail();\n\treturn s;\n}\n#else\nchar * CMUS_MALLOC xstrndup(const char *str, size_t n);\n#endif\n\nstatic inline void free_str_array(char **array)\n{\n\tint i;\n\n\tif (array == NULL)\n\t\treturn;\n\tfor (i = 0; array[i]; i++)\n\t\tfree(array[i]);\n\tfree(array);\n}\n\n#endif\n"
        },
        {
          "name": "xstrjoin.c",
          "type": "blob",
          "size": 1.1923828125,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"xstrjoin.h\"\n#include \"xmalloc.h\"\n#include \"utils.h\"\n\nchar *xstrjoin_slice(struct slice slice)\n{\n\tconst char **str = slice.ptr;\n\tsize_t i, pos = 0, len = 0;\n\tchar *joined;\n\tsize_t *lens;\n\n\tlens = xnew(size_t, slice.len);\n\tfor (i = 0; i < slice.len; i++) {\n\t\tlens[i] = strlen(str[i]);\n\t\tlen += lens[i];\n\t}\n\n\tjoined = xnew(char, len + 1);\n\tfor (i = 0; i < slice.len; i++) {\n\t\tmemcpy(joined + pos, str[i], lens[i]);\n\t\tpos += lens[i];\n\t}\n\tjoined[len] = 0;\n\n\tfree(lens);\n\n\treturn joined;\n}\n"
        },
        {
          "name": "xstrjoin.h",
          "type": "blob",
          "size": 0.892578125,
          "content": "/*\n * Copyright 2008-2013 Various Authors\n * Copyright 2004 Timo Hirvonen\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CMUS_XSTRJOIN_H\n#define CMUS_XSTRJOIN_H\n\n#include \"utils.h\"\n\nchar *xstrjoin_slice(struct slice);\n#define xstrjoin(...) xstrjoin_slice(TO_SLICE(const char *, __VA_ARGS__))\n\n#endif\n"
        }
      ]
    }
  ]
}