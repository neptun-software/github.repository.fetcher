{
  "metadata": {
    "timestamp": 1736710291866,
    "page": 68,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjcw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "shellphish/how2heap",
      "stars": 7404,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1904296875,
          "content": "glibc_build\nglibc_src\nglibc_versions\n.gdb_history\n\n# ignore binaries in root\ncalc_tcache_idx\nfirst_fit\nmalloc_playground\n\n# ignore all built binaries\nglibc_2.*/*\n!glibc_2.*/*.*\n\n# general\n**.swp\n"
        },
        {
          "name": ".gitmodules",
          "type": "blob",
          "size": 0.166015625,
          "content": "[submodule \"glibc-all-in-one\"]\n\tpath = glibc-all-in-one\n\t#url = https://github.com/matrix1001/glibc-all-in-one.git\n\turl = https://github.com/fr0ster/glibc-all-in-one.git\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.3037109375,
          "content": "from ubuntu:20.04\n\nrun apt-get update && apt-get install -y binutils git make vim gcc patchelf python-is-python3 python3-pip\nrun pip3 install requests\nrun git clone --depth 1 https://github.com/shellphish/how2heap /root/how2heap\nrun git config --global --add safe.directory \"*\"\n\nworkdir /root/how2heap\nrun bash\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0419921875,
          "content": "MIT License\n\nCopyright (c) 2020 Shellphish\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 3.078125,
          "content": ".PHONY: help clean distclean all test\n\nVERSIONS := 2.23 2.24 2.27 2.31 2.32 2.33 2.34 2.35 2.36 2.37 2.38 2.39\nTECH_BINS := $(patsubst %.c,%,$(wildcard glibc_*/*.c))\nBASE_BINS := $(patsubst %.c,%,$(wildcard *.c))\nDOWNLOADED := glibc-all-in-one/libs glibc-all-in-one/debs\nBINS := $(TECH_BINS) $(BASE_BINS)\nARCH := amd64\n\nifeq ($(H2H_USE_SYSTEM_LIBC),)\nH2H_USE_SYSTEM_LIBC := Y\nendif\n\nhelp:\n\t@echo 'make help                    - show this message'\n\t@echo 'make base                    - build all base binaries, namely `malloc_playground`, `first_fit`, `calc_tcache_idx`'\n\t@echo 'make <version>               - build all the techniques for a specific version. e.g. `make v2.39`'\n\t@echo 'make clean                   - remove all built binaries'\n\t@echo 'make distclean               - remove all built binaries and downloaded libcs'\n\t@echo 'make all                     - build all binaries'\n\t@echo 'make test version=<version>  - test run all techniques for a specific version. e.g. `make test version=2.39`'\n\nCFLAGS += -std=c99 -g -Wno-unused-result -Wno-free-nonheap-object\nLDLIBS += -ldl\n\nbase: $(BASE_BINS)\n\n# initialize glibc-all-in-one\nlibc_ready:\n\tgit submodule update --init --recursive\n\tcd glibc-all-in-one && ./update_list\n\n# populate the download_glibc_<version> rules\n$(addprefix download_glibc_, $(VERSIONS)): libc_ready\n\t@echo $@\n\n\tversion=$(patsubst download_glibc_%,%,$@); \\\n\tlibc=$$(cat glibc-all-in-one/list | grep \"$$version\" | grep \"$(ARCH)\" | head -n 1); \\\n\told_libc=$$(cat glibc-all-in-one/old_list | grep \"$$version\" | grep \"$(ARCH)\" | head -n 1); \\\n\tif [ -z $$libc ]; then libc=$$old_libc; script=\"download_old\"; else libc=$$libc; script=\"download\"; fi; \\\n\tcd glibc-all-in-one; \\\n\trm -rf libs/$$libc; \\\n\t./$$script $$libc\n\n# populate the make <version> rules\nifeq ($(H2H_USE_SYSTEM_LIBC),Y)\n$(foreach version,$(VERSIONS),$(eval v$(version): $(patsubst %.c,%,$(wildcard glibc_$(version)/*.c))))\nelse\n$(foreach version,$(VERSIONS),$(eval v$(version): download_glibc_$(version) $(patsubst %.c,%,$(wildcard glibc_$(version)/*.c)) ))\nendif\n\n# the compilation rules\n%: %.c\n\tversion=$(word 1, $(subst /, ,$(patsubst glibc_%,%,$@))); \\\n\tif [ \"$(H2H_USE_SYSTEM_LIBC)\" = \"Y\" ]; \\\n\tthen \\\n\t\t$(CC) $(CFLAGS) $(DIR_CFLAGS_$(@D)) $^ -o $@ $(LDLIBS); \\\n\telse \\\n\t\t$(CC) $(CFLAGS) $(DIR_CFLAGS_$(@D)) $^ -o $@ $(LDLIBS) \\\n\t\t-Xlinker -rpath=$$(realpath glibc-all-in-one/libs/$$version*) \\\n\t\t-Xlinker -I$$(realpath glibc-all-in-one/libs/$$version*/ld-linux-x86-64.so.2) \\\n\t\t-Xlinker $$(realpath glibc-all-in-one/libs/$$version*/libc.so.6) \\\n\t\t-Xlinker $$(realpath glibc-all-in-one/libs/$$version*/libdl.so.2); \\\n\tfi\n\nall: $(BINS)\n\nclean:\n\t@rm -f $(BINS)\n\t@echo \"all the built binaries are removed.\"\n\ndistclean:\n\t@rm -f $(BINS)\n\t@rm -rf $(DOWNLOADED)\n\t@echo \"all the built binaries and all downloaded libcs are removed.\"\n\ndefine test_poc =\necho $(poc)\nfor i in $$(seq 0 20);\\\ndo\\\n\tLIBC_FATAL_STDERR_=1 $(poc) 1>/dev/null 2>&1 0>&1;\\\n\tif [ \"$$?\" = \"0\" ]; then break; fi;\\\n\tif [ \"$$i\" = \"20\" ]; then exit 1; fi;\\\ndone\necho \"success\"\nendef\n\ntest: v$(version)\n\t@$(foreach poc,$(patsubst %.c,%,$(wildcard glibc_$(version)/*.c)),$(call test_poc,$(poc));)\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 18.9072265625,
          "content": "# Educational Heap Exploitation\n\nThis repo is for learning various heap exploitation techniques.\nWe use Ubuntu's Libc releases as the gold-standard. Each technique is verified to work on corresponding Ubuntu releases.\nYou can run `apt source libc6` to download the source code of the Libc your are using on Debian-based operating system. You can also click :arrow_forward: to debug the technique in your browser using gdb.\n\nWe came up with the idea during a hack meeting, and have implemented the following techniques:\n\n| File | :arrow_forward: | Technique | Glibc-Version | Patch | Applicable CTF Challenges |\n|------|-----|-----------|---------------|-------|---------------------------|\n| [first_fit.c](first_fit.c) | |  Demonstrating glibc malloc's first-fit behavior. | | | |\n| [calc_tcache_idx.c](calc_tcache_idx.c)| |  Demonstrating glibc's tcache index calculation.| | | |\n| [fastbin_dup.c](glibc_2.35/fastbin_dup.c) | <a href=\"https://wargames.ret2.systems/level/how2heap_fastbin_dup_2.34\" title=\"Debug Technique In Browser\">:arrow_forward:</a> | Tricking malloc into returning an already-allocated heap pointer by abusing the fastbin freelist. | latest | | |\n| [fastbin_dup_into_stack.c](glibc_2.35/fastbin_dup_into_stack.c) | <a href=\"https://wargames.ret2.systems/level/how2heap_fastbin_dup_into_stack_2.23\" title=\"Debug Technique In Browser\">:arrow_forward:</a> | Tricking malloc into returning a nearly-arbitrary pointer by abusing the fastbin freelist. | latest | | [9447-search-engine](https://github.com/ctfs/write-ups-2015/tree/master/9447-ctf-2015/exploitation/search-engine), [0ctf 2017-babyheap](http://uaf.io/exploitation/2017/03/19/0ctf-Quals-2017-BabyHeap2017.html) |\n| [fastbin_dup_consolidate.c](glibc_2.35/fastbin_dup_consolidate.c) | <a href=\"https://wargames.ret2.systems/level/how2heap_fastbin_dup_consolidate_2.23\" title=\"Debug Technique In Browser\">:arrow_forward:</a> | Tricking malloc into returning an already-allocated heap pointer by putting a pointer on both fastbin freelist and the top chunk. | latest | | [Hitcon 2016 SleepyHolder](https://github.com/mehQQ/public_writeup/tree/master/hitcon2016/SleepyHolder) |\n| [unsafe_unlink.c](glibc_2.35/unsafe_unlink.c) | <a href=\"https://wargames.ret2.systems/level/how2heap_unsafe_unlink_2.34\" title=\"Debug Technique In Browser\">:arrow_forward:</a> | Exploiting free on a corrupted chunk to get arbitrary write. | latest | | [HITCON CTF 2014-stkof](http://acez.re/ctf-writeup-hitcon-ctf-2014-stkof-or-modern-heap-overflow/), [Insomni'hack 2017-Wheel of Robots](https://gist.github.com/niklasb/074428333b817d2ecb63f7926074427a) |\n| [house_of_spirit.c](glibc_2.35/house_of_spirit.c) | <a href=\"https://wargames.ret2.systems/level/how2heap_house_of_spirit_2.23\" title=\"Debug Technique In Browser\">:arrow_forward:</a> | Frees a fake fastbin chunk to get malloc to return a nearly-arbitrary pointer. | latest | | [hack.lu CTF 2014-OREO](https://github.com/ctfs/write-ups-2014/tree/master/hack-lu-ctf-2014/oreo) |\n| [poison_null_byte.c](glibc_2.35/poison_null_byte.c) | <a href=\"https://wargames.ret2.systems/level/how2heap_poison_null_byte_2.34\" title=\"Debug Technique In Browser\">:arrow_forward:</a> | Exploiting a single null byte overflow. | latest | | [PlaidCTF 2015-plaiddb](https://github.com/ctfs/write-ups-2015/tree/master/plaidctf-2015/pwnable/plaiddb), [BalsnCTF 2019-PlainNote](https://gist.github.com/st424204/6b5c007cfa2b62ed3fd2ef30f6533e94?fbclid=IwAR3n0h1WeL21MY6cQ_C51wbXimdts53G3FklVIHw2iQSgtgGo0kR3Lt-1Ek)|\n| [house_of_lore.c](glibc_2.35/house_of_lore.c) | <a href=\"https://wargames.ret2.systems/level/how2heap_house_of_lore_2.34\" title=\"Debug Technique In Browser\">:arrow_forward:</a> | Tricking malloc into returning a nearly-arbitrary pointer by abusing the smallbin freelist. | latest | | |\n| [overlapping_chunks.c](glibc_2.27/overlapping_chunks.c) | <a href=\"https://wargames.ret2.systems/level/how2heap_overlapping_chunks_2.34\" title=\"Debug Technique In Browser\">:arrow_forward:</a> | Exploit the overwrite of a freed chunk size in the unsorted bin in order to make a new allocation overlap with an existing chunk | < 2.29 | [patch](https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=b90ddd08f6dd688e651df9ee89ca3a69ff88cd0c) | [hack.lu CTF 2015-bookstore](https://github.com/ctfs/write-ups-2015/tree/master/hack-lu-ctf-2015/exploiting/bookstore), [Nuit du Hack 2016-night-deamonic-heap](https://github.com/ctfs/write-ups-2016/tree/master/nuitduhack-quals-2016/exploit-me/night-deamonic-heap-400) |\n| [overlapping_chunks_2.c](glibc_2.23/overlapping_chunks_2.c) | <a href=\"https://wargames.ret2.systems/level/how2heap_overlapping_chunks_2_2.23\" title=\"Debug Technique In Browser\">:arrow_forward:</a> | Exploit the overwrite of an in use chunk size in order to make a new allocation overlap with an existing chunk  | < 2.29|[patch](https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=b90ddd08f6dd688e651df9ee89ca3a69ff88cd0c) | |\n| [mmap_overlapping_chunks.c](glibc_2.35/mmap_overlapping_chunks.c) | |  Exploit an in use mmap chunk in order to make a new allocation overlap with a current mmap chunk | latest | | |\n| [house_of_force.c](glibc_2.27/house_of_force.c) | <a href=\"https://wargames.ret2.systems/level/how2heap_house_of_force_2.27\" title=\"Debug Technique In Browser\">:arrow_forward:</a> | Exploiting the Top Chunk (Wilderness) header in order to get malloc to return a nearly-arbitrary pointer | < 2.29 | [patch](https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=30a17d8c95fbfb15c52d1115803b63aaa73a285c) | [Boston Key Party 2016-cookbook](https://github.com/ctfs/write-ups-2016/tree/master/boston-key-party-2016/pwn/cookbook-6), [BCTF 2016-bcloud](https://github.com/ctfs/write-ups-2016/tree/master/bctf-2016/exploit/bcloud-200) |\n| [unsorted_bin_into_stack.c](glibc_2.27/unsorted_bin_into_stack.c) | <a href=\"https://wargames.ret2.systems/level/how2heap_unsorted_bin_into_stack_2.23\" title=\"Debug Technique In Browser\">:arrow_forward:</a> | Exploiting the overwrite of a freed chunk on unsorted bin freelist to return a nearly-arbitrary pointer.  | < 2.29 | [patch](https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=b90ddd08f6dd688e651df9ee89ca3a69ff88cd0c)| |\n| [unsorted_bin_attack.c](glibc_2.27/unsorted_bin_attack.c) | <a href=\"https://wargames.ret2.systems/level/how2heap_unsorted_bin_attack_2.27\" title=\"Debug Technique In Browser\">:arrow_forward:</a> | Exploiting the overwrite of a freed chunk on unsorted bin freelist to write a large value into arbitrary address  | < 2.29 | [patch](https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=b90ddd08f6dd688e651df9ee89ca3a69ff88cd0c) | [0ctf 2016-zerostorage](https://github.com/ctfs/write-ups-2016/tree/master/0ctf-2016/exploit/zerostorage-6) |\n| [large_bin_attack.c](glibc_2.35/large_bin_attack.c) | <a href=\"https://wargames.ret2.systems/level/how2heap_large_bin_attack_2.34\" title=\"Debug Technique In Browser\">:arrow_forward:</a> | Exploiting the overwrite of a freed chunk on large bin freelist to write a large value into arbitrary address  | latest | | [0ctf 2018-heapstorm2](https://dangokyo.me/2018/04/07/0ctf-2018-pwn-heapstorm2-write-up/) |\n| [house_of_einherjar.c](glibc_2.35/house_of_einherjar.c) | <a href=\"https://wargames.ret2.systems/level/how2heap_house_of_einherjar_2.34\" title=\"Debug Technique In Browser\">:arrow_forward:</a> | Exploiting a single null byte overflow to trick malloc into returning a controlled pointer  | latest | | [Seccon 2016-tinypad](https://gist.github.com/hhc0null/4424a2a19a60c7f44e543e32190aaabf) |\n| [house_of_water.c](glibc_2.36/house_of_water.c) | | Exploit a UAF or double free to gain leakless control of the t-cache metadata and a leakless way to link libc in t-cache | latest | | [37c3 Potluck - Tamagoyaki](https://github.com/UDPctf/CTF-challenges/tree/main/Potluck-CTF-2023/Tamagoyaki)|\n| [sysmalloc_int_free.c](glibc_2.39/sysmalloc_int_free.c) | | Demonstrating freeing the nearly arbitrary sized Top Chunk (Wilderness) using malloc (sysmalloc  `_int_free()` ) | latest | | |\n| [house_of_orange.c](glibc_2.23/house_of_orange.c) | <a href=\"https://wargames.ret2.systems/level/how2heap_house_of_orange_2.23\" title=\"Debug Technique In Browser\">:arrow_forward:</a> | Exploiting the Top Chunk (Wilderness) in order to gain arbitrary code execution  | < 2.26 | [patch](https://sourceware.org/git/?p=glibc.git;a=blobdiff;f=stdlib/abort.c;h=117a507ff88d862445551f2c07abb6e45a716b75;hp=19882f3e3dc1ab830431506329c94dcf1d7cc252;hb=91e7cf982d0104f0e71770f5ae8e3faf352dea9f;hpb=0c25125780083cbba22ed627756548efe282d1a0) | [Hitcon 2016 houseoforange](https://github.com/ctfs/write-ups-2016/tree/master/hitcon-ctf-2016/pwn/house-of-orange-500) |\n| [house_of_tangerine.c](glibc_2.39/house_of_tangerine.c) |  | Exploiting the Top Chunk (Wilderness) in order to trick malloc into returning a completely arbitrary pointer by abusing the tcache freelist | >= 2.26 |  | [PicoCTF 2024- high frequency troubles](https://play.picoctf.org/practice/challenge/441?category=6&page=1&search=high%20frequency%20troubles) |\n| [house_of_roman.c](glibc_2.23/house_of_roman.c) | <a href=\"https://wargames.ret2.systems/level/how2heap_house_of_roman_2.23\" title=\"Debug Technique In Browser\">:arrow_forward:</a> | Leakless technique in order to gain remote code execution via fake fastbins, the unsorted\\_bin attack and relative overwrites. |< 2.29 |[patch](https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=b90ddd08f6dd688e651df9ee89ca3a69ff88cd0c) ||\n| [tcache_poisoning.c](glibc_2.35/tcache_poisoning.c) | <a href=\"https://wargames.ret2.systems/level/how2heap_tcache_poisoning_2.34\" title=\"Debug Technique In Browser\">:arrow_forward:</a> | Tricking malloc into returning a completely arbitrary pointer by abusing the tcache freelist. (requires heap leak on and after 2.32) | > 2.25  | [patch](https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=a1a486d70ebcc47a686ff5846875eacad0940e41) | |\n| [tcache_house_of_spirit.c](glibc_2.35/tcache_house_of_spirit.c) | <a href=\"https://wargames.ret2.systems/level/how2heap_tcache_house_of_spirit_2.34\" title=\"Debug Technique In Browser\">:arrow_forward:</a> | Frees a fake chunk to get malloc to return a nearly-arbitrary pointer. | > 2.25 | | |\n| [house_of_botcake.c](glibc_2.35/house_of_botcake.c) | <a href=\"https://wargames.ret2.systems/level/how2heap_house_of_botcake_2.34\" title=\"Debug Technique In Browser\">:arrow_forward:</a> | Bypass double free restriction on tcache. Make `tcache_dup` great again. | > 2.25 | | |\n| [tcache_stashing_unlink_attack.c](glibc_2.35/tcache_stashing_unlink_attack.c) | <a href=\"https://wargames.ret2.systems/level/how2heap_tcache_stashing_unlink_attack_2.34\" title=\"Debug Technique In Browser\">:arrow_forward:</a> | Exploiting the overwrite of a freed chunk on small bin freelist to trick malloc into returning an arbitrary pointer and write a large value into arbitraty address with the help of calloc. | > 2.25 | | [Hitcon 2019 one punch man](https://github.com/xmzyshypnc/xz_files/tree/master/hitcon2019_one_punch_man) |\n| [fastbin_reverse_into_tcache.c](glibc_2.35/fastbin_reverse_into_tcache.c) | <a href=\"https://wargames.ret2.systems/level/how2heap_fastbin_reverse_into_tcache_2.34\" title=\"Debug Technique In Browser\">:arrow_forward:</a> | Exploiting the overwrite of a freed chunk in the fastbin to write a large value into an arbitrary address. | > 2.25 | | |\n| [house_of_mind_fastbin.c](glibc_2.35/house_of_mind_fastbin.c) | <a href=\"https://wargames.ret2.systems/level/how2heap_house_of_mind_fastbin_2.34\" title=\"Debug Technique In Browser\">:arrow_forward:</a> | Exploiting a single byte overwrite with arena handling to write a large value (heap pointer) to an arbitrary address | latest | | |\n| [house_of_storm.c](glibc_2.27/house_of_storm.c) | <a href=\"https://wargames.ret2.systems/level/how2heap_house_of_storm_2.27\" title=\"Debug Technique In Browser\">:arrow_forward:</a> | Exploiting a use after free on both a large and unsorted bin chunk to return an arbitrary chunk from malloc| < 2.29 | | |\n| [house_of_gods.c](glibc_2.24/house_of_gods.c) | <a href=\"https://wargames.ret2.systems/level/how2heap_house_of_gods_2.24\" title=\"Debug Technique In Browser\">:arrow_forward:</a> | A technique to hijack a thread's arena within 8 allocations | < 2.27 | | |\n| [decrypt_safe_linking.c](glibc_2.35/decrypt_safe_linking.c) | <a href=\"https://wargames.ret2.systems/level/how2heap_decrypt_safe_linking_2.34\" title=\"Debug Technique In Browser\">:arrow_forward:</a> | Decrypt the poisoned value in linked list to recover the actual pointer | >= 2.32 | | |\n| [safe_link_double_protect.c](glibc_2.36/safe_link_double_protect.c) | | Leakless bypass for PROTECT_PTR by protecting a pointer twice, allowing for arbitrary pointer linking in t-cache | >= 2.32 | | [37c3 Potluck - Tamagoyaki](https://github.com/UDPctf/CTF-challenges/tree/main/Potluck-CTF-2023/Tamagoyaki)|\n| [tcache_dup.c](obsolete/glibc_2.27/tcache_dup.c)(obsolete) | |  Tricking malloc into returning an already-allocated heap pointer by abusing the tcache freelist. | 2.26 - 2.28 | [patch](https://sourceware.org/git/?p=glibc.git;a=commit;h=bcdaad21d4635931d1bd3b54a7894276925d081d) | |\n\nThe GnuLibc is under constant development and several of the techniques above have let to consistency checks introduced in the malloc/free logic.\nConsequently, these checks regularly break some of the techniques and require adjustments to bypass them (if possible).\nWe address this issue by keeping multiple versions of the same technique for each Glibc-release that required an adjustment.\nThe structure is `glibc_<version>/technique.c`.\n\nHave a good example?\nAdd it here!\nTry to inline the whole technique in a single `.c` -- it's a lot easier to learn that way.\n\n# Get Started\n\n## Quick Setup\n\n- make sure you have the following packages/tools installed: `patchelf zstd wget` (of course also `build-essential` or similar for compilers, `make`, ...)\n- also, `/usr/bin/python` must be/point to your `python` binary (e. g. `/usr/bin/python3`)\n\n```shell\ngit clone https://github.com/shellphish/how2heap\ncd how2heap\nmake clean base\n./malloc_playground\n```\nNotice that this will link the binaries with your system libc. If you want to play with other libc versions. Please refer to `Complete Setup`.\n\n## Complete Setup\n\nYou will encounter symbol versioning issues (see [this](https://github.com/shellphish/how2heap/issues/169)) if you try to `LD_PRELOAD` libcs to a binary that's compiled on your host machine.\nWe have two ways to bypass it.\n\n### Method 1: link against older libc\nThis one tells linker to link the target binary with the target libc.\n```shell\ngit clone https://github.com/shellphish/how2heap\ncd how2heap\nH2H_USE_SYSTEM_LIBC=N make v2.23\n```\nThis will link all the binaries against corresponding libcs. What's better is that it comes with debug symbols. Now you can play with any libc versions on your host machine.\nIn this example, it will compile all glibc-2.23 binaries and link them with libc-2.23. You can change the number to play with other libc versions.\n\n### Method 2: use docker\nThis uses Docker-based approach to complie binaries inside an old ubuntu container so it is runnable with the target libc version.\n\n```shell\ngit clone https://github.com/shellphish/how2heap\ncd how2heap\n\n# the next command will prepare the target binary so it runs with\n# the expected libc version\nmake base\n./glibc_run.sh 2.30 ./malloc_playground -d -p\n\n# now you can play with the binary with glibc-2.30\n# and even debug it with the correct symbols\nreadelf -d -W malloc_playground | grep RUNPATH # or use checksec\nreadelf -l -W malloc_playground | grep interpreter\ngdb -q -ex \"start\" ./malloc_playground\n```\n\n# Heap Exploitation Tools\n\nThere are some heap exploitation tools floating around.\n\n## Malloc Playground\n\nThe `malloc_playground.c` file given is the source for a program that prompts the user for commands to allocate and free memory interactively.\n\n## Pwngdb\n\nExamine the glibc heap in gdb: https://github.com/scwuaptx/Pwngdb\n\n## pwndbg\n\nAn exploitation-centric gdb plugin that provides the ability to view/tamper with the glibc heap: https://github.com/pwndbg/pwndbg\n\n## gef\n\nAnother excellent gdb plugin that provides the ability to examine the glibc heap: https://github.com/hugsy/gef\n\n## heap-viewer\n\nExamine the glibc heap in IDA Pro: https://github.com/danigargu/heap-viewer\n\n## Forkever\n\nDebugger that lets you set \"checkpoints\" as well as view and edit the heap using a hexeditor: https://github.com/haxkor/forkever\n\n## heaptrace\n\nHelps you visualize heap operations by replacing addresses with symbols: https://github.com/Arinerron/heaptrace\n\n# Other resources\n\nSome good heap exploitation resources, roughly in order of their publication, are:\n\n- glibc in-depth tutorial (https://heap-exploitation.dhavalkapil.com/) - book and exploit samples\n- ptmalloc fanzine, a set of resources and examples related to meta-data attacks on ptmalloc (http://tukan.farm/2016/07/26/ptmalloc-fanzine/)\n- A malloc diagram, from libheap (https://raw.githubusercontent.com/cloudburst/libheap/master/heap.png)\n- Glibc Adventures: The Forgotten Chunk (https://go.contextis.com/rs/140-OCV-459/images/Glibc_Adventures-The_Forgotten_Chunks.pdf) - advanced heap exploitation\n- Pseudomonarchia jemallocum (http://www.phrack.org/issues/68/10.html)\n- The House Of Lore: Reloaded (http://phrack.org/issues/67/8.html)\n- Malloc Des-Maleficarum (http://phrack.org/issues/66/10.html) - some malloc exploitation techniques\n- Yet another free() exploitation technique (http://phrack.org/issues/66/6.html)\n- Understanding the heap by breaking it (https://www.blackhat.com/presentations/bh-usa-07/Ferguson/Whitepaper/bh-usa-07-ferguson-WP.pdf) - explains heap implementation and a couple exploits\n- The use of set_head to defeat the wilderness (http://phrack.org/issues/64/9.html)\n- The Malloc Maleficarum (http://seclists.org/bugtraq/2005/Oct/118)\n- OS X heap exploitation techniques (http://phrack.org/issues/63/5.html)\n- Exploiting The Wilderness (http://seclists.org/vuln-dev/2004/Feb/25)\n- Advanced Doug lea's malloc exploits (http://phrack.org/issues/61/6.html)\n- GDB Enhanced Features (GEF) Heap Exploration Tools (https://hugsy.github.io/gef/commands/heap/)\n- pwndbg Heap Commands (https://browserpwndbg.readthedocs.io/en/docs/commands/heap/heap/)\n- Painless intro to the Linux userland heap (https://sensepost.com/blog/2017/painless-intro-to-the-linux-userland-heap/)\n- Heap exploitation techniques that work on glibc-2.31 (https://github.com/StarCross-Tech/heap_exploit_2.31)\n- Overview of GLIBC heap exploitation techniques (https://0x434b.dev/overview-of-glibc-heap-exploitation-techniques/)\n\n# Hardening\nThere are a couple of \"hardening\" measures embedded in glibc, like `export MALLOC_CHECK_=1` (enables some checks), `export MALLOC_PERTURB_=1` (data is overwritten), `export MALLOC_MMAP_THRESHOLD_=1` (always use mmap()), ...\n\nMore info: [mcheck()](http://www.gnu.org/software/libc/manual/html_node/Heap-Consistency-Checking.html), [mallopt()](http://www.gnu.org/software/libc/manual/html_node/Malloc-Tunable-Parameters.html).\n\nThere's also some tracing support as [mtrace()](http://manpages.ubuntu.com/mtrace), [malloc_stats()](http://manpages.ubuntu.com/malloc_stats), [malloc_info()](http://manpages.ubuntu.com/malloc_info), [memusage](http://manpages.ubuntu.com/memusage), and in other functions in this family.\n\n"
        },
        {
          "name": "calc_tcache_idx.c",
          "type": "blob",
          "size": 3.0546875,
          "content": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <malloc.h>\n\n\nstruct malloc_chunk {\n\n  size_t      mchunk_prev_size;  /* Size of previous chunk (if free).  */\n  size_t      mchunk_size;       /* Size in bytes, including overhead. */\n\n  struct malloc_chunk* fd;         /* double links -- used only if free. */\n  struct malloc_chunk* bk;\n\n  /* Only used for large blocks: pointer to next larger size.  */\n  struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */\n  struct malloc_chunk* bk_nextsize;\n};\n\n/* The corresponding word size.  */\n#define SIZE_SZ (sizeof (size_t))\n\n#define MALLOC_ALIGNMENT (2 * SIZE_SZ < __alignof__ (long double) \\\n\t\t\t  ? __alignof__ (long double) : 2 * SIZE_SZ)\n\n/* The corresponding bit mask value.  */\n#define MALLOC_ALIGN_MASK (MALLOC_ALIGNMENT - 1)\n\n/* The smallest possible chunk */\n#define MIN_CHUNK_SIZE        (offsetof(struct malloc_chunk, fd_nextsize))\n\n/* The smallest size we can malloc is an aligned minimal chunk */\n#define MINSIZE  \\\n  (unsigned long)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) & ~MALLOC_ALIGN_MASK))\n\n#define request2size(req)                                         \\\n  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK < MINSIZE)  ?             \\\n   MINSIZE :                                                      \\\n   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) & ~MALLOC_ALIGN_MASK)\n\n/* When \"x\" is from chunksize().  */\n# define csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)\n\n/* When \"x\" is a user-provided size.  */\n# define usize2tidx(x) csize2tidx (request2size (x))\n\nint main()\n{\n    unsigned long long req;\n    unsigned long long tidx;\n\tfprintf(stderr, \"This file doesn't demonstrate an attack, but calculates the tcache idx for a given chunk size.\\n\");\n\tfprintf(stderr, \"The basic formula is as follows:\\n\");\n    fprintf(stderr, \"\\tIDX = (CHUNKSIZE - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT\\n\");\n    fprintf(stderr, \"\\tOn a 64 bit system the current values are:\\n\");\n    fprintf(stderr, \"\\t\\tMINSIZE: 0x%lx\\n\", MINSIZE);\n    fprintf(stderr, \"\\t\\tMALLOC_ALIGNMENT: 0x%lx\\n\", MALLOC_ALIGNMENT);\n    fprintf(stderr, \"\\tSo we get the following equation:\\n\");\n    fprintf(stderr, \"\\tIDX = (CHUNKSIZE - 0x%lx) / 0x%lx\\n\\n\", MINSIZE-MALLOC_ALIGNMENT+1, MALLOC_ALIGNMENT);\n    fprintf(stderr, \"BUT be AWARE that CHUNKSIZE is not the x in malloc(x)\\n\");\n    fprintf(stderr, \"It is calculated as follows:\\n\");\n    fprintf(stderr, \"\\tIF x + SIZE_SZ + MALLOC_ALIGN_MASK < MINSIZE(0x%lx) CHUNKSIZE = MINSIZE (0x%lx)\\n\", MINSIZE, MINSIZE);\n    fprintf(stderr, \"\\tELSE: CHUNKSIZE = (x + SIZE_SZ + MALLOC_ALIGN_MASK) & ~MALLOC_ALIGN_MASK) \\n\");\n    fprintf(stderr, \"\\t=> CHUNKSIZE = (x + 0x%lx + 0x%lx) & ~0x%lx\\n\\n\\n\", SIZE_SZ, MALLOC_ALIGN_MASK, MALLOC_ALIGN_MASK);\n    while(1) {\n        fprintf(stderr, \"[CTRL-C to exit] Please enter a size x (malloc(x)) in hex (e.g. 0x10): \");\n        scanf(\"%llx\", &req);\n        tidx = usize2tidx(req);\n        if (tidx > 63) {\n            fprintf(stderr, \"\\nWARNING: NOT IN TCACHE RANGE!\\n\");\n        }\n        fprintf(stderr, \"\\nTCache Idx: %llu\\n\", tidx);\n    }\n    return 0;\n}\n"
        },
        {
          "name": "ci",
          "type": "tree",
          "content": null
        },
        {
          "name": "first_fit.c",
          "type": "blob",
          "size": 1.5146484375,
          "content": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main()\n{\n\tfprintf(stderr, \"This file doesn't demonstrate an attack, but shows the nature of glibc's allocator.\\n\");\n\tfprintf(stderr, \"glibc uses a first-fit algorithm to select a free chunk.\\n\");\n\tfprintf(stderr, \"If a chunk is free and large enough, malloc will select this chunk.\\n\");\n\tfprintf(stderr, \"This can be exploited in a use-after-free situation.\\n\");\n\n\tfprintf(stderr, \"Allocating 2 buffers. They can be large, don't have to be fastbin.\\n\");\n\tchar* a = malloc(0x512);\n\tchar* b = malloc(0x256);\n\tchar* c;\n\n\tfprintf(stderr, \"1st malloc(0x512): %p\\n\", a);\n\tfprintf(stderr, \"2nd malloc(0x256): %p\\n\", b);\n\tfprintf(stderr, \"we could continue mallocing here...\\n\");\n\tfprintf(stderr, \"now let's put a string at a that we can read later \\\"this is A!\\\"\\n\");\n\tstrcpy(a, \"this is A!\");\n\tfprintf(stderr, \"first allocation %p points to %s\\n\", a, a);\n\n\tfprintf(stderr, \"Freeing the first one...\\n\");\n\tfree(a);\n\n\tfprintf(stderr, \"We don't need to free anything again. As long as we allocate smaller than 0x512, it will end up at %p\\n\", a);\n\n\tfprintf(stderr, \"So, let's allocate 0x500 bytes\\n\");\n\tc = malloc(0x500);\n\tfprintf(stderr, \"3rd malloc(0x500): %p\\n\", c);\n\tfprintf(stderr, \"And put a different string here, \\\"this is C!\\\"\\n\");\n\tstrcpy(c, \"this is C!\");\n\tfprintf(stderr, \"3rd allocation %p points to %s\\n\", c, c);\n\tfprintf(stderr, \"first allocation %p points to %s\\n\", a, a);\n\tfprintf(stderr, \"If we reuse the first allocation, it now holds the data from the third allocation.\\n\");\n}\n"
        },
        {
          "name": "glibc-all-in-one",
          "type": "commit",
          "content": null
        },
        {
          "name": "glibc_2.23",
          "type": "tree",
          "content": null
        },
        {
          "name": "glibc_2.24",
          "type": "tree",
          "content": null
        },
        {
          "name": "glibc_2.27",
          "type": "tree",
          "content": null
        },
        {
          "name": "glibc_2.31",
          "type": "tree",
          "content": null
        },
        {
          "name": "glibc_2.32",
          "type": "tree",
          "content": null
        },
        {
          "name": "glibc_2.33",
          "type": "tree",
          "content": null
        },
        {
          "name": "glibc_2.34",
          "type": "tree",
          "content": null
        },
        {
          "name": "glibc_2.35",
          "type": "tree",
          "content": null
        },
        {
          "name": "glibc_2.36",
          "type": "tree",
          "content": null
        },
        {
          "name": "glibc_2.37",
          "type": "tree",
          "content": null
        },
        {
          "name": "glibc_2.38",
          "type": "tree",
          "content": null
        },
        {
          "name": "glibc_2.39",
          "type": "tree",
          "content": null
        },
        {
          "name": "glibc_ChangeLog.md",
          "type": "blob",
          "size": 0.86328125,
          "content": "ChangeLog for relevant heap-protection changes\n--------------------------------------------\n\n## Version 2.25\n\nAll attacks in this repo work at least in this version.\n\n## Version 2.26\n\n- tcache (per-thread cache) is introduced (enabled in ubuntu-build since 2.27)\n    * See [tukan.farm](http://tukan.farm/2017/07/08/tcache/) for a short overview\n    \n\n- `unlink(AV, P, BK, FD)`:\n    * Add size consistency check:\n        ```\n            if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))\n              malloc_printerr (\"corrupted size vs. prev_size\");\n        ```\n\n## Version 2.27\n\n- `malloc_consolidate(mstate av)`:\n    * Add size check when placing chunks into fastbins:\n        ```\n        unsigned int idx = fastbin_index (chunksize (p));\n        if ((&fastbin (av, idx)) != fb)\n          malloc_printerr (\"malloc_consolidate(): invalid chunk size\");\n        ```\n"
        },
        {
          "name": "glibc_run.sh",
          "type": "blob",
          "size": 5.1728515625,
          "content": "#!/bin/bash\n\nVERSION=\"./glibc_versions\"\n#DIR_TCACHE='tcache'\nDIR_TCACHE=''\nDIR_HOST='x64'\nLIB_HOST='amd64'\nGLIBC_VERSION=''\nTARGET=''\nUPDATE=''\nRELOAD=''\nDOCKER=''\nGDB=''\nRADARE2=''\nNOT_EXECUTION=''\nFORCE_TARGET_INTERPRETER=''\nHOW2HEAP_PATH=$( cd -- \"$( dirname -- \"${BASH_SOURCE[0]}\" )\" &> /dev/null && pwd )\n\n# Handle arguments\nfunction show_help {\n    echo \"Usage: $0 <version> <target> [-h] [-i686] [-u] [-r] [-d] [-gdb | -r2 | -p]\"\n    echo \"-i686 - use x32 bits libc\"\n    echo \"-u - update libc list in glibc-all-in-one\"\n    echo \"-r - download libc in glibc-all-in-one\"\n    echo \"-d - build the debugging environment in docker\"\n    echo \"-gdb - start target in GDB\"\n    echo \"-r2 - start target in radare2\"\n    echo \"-p - just set interpreter and rpath in target without execution\"\n}\n\nif [[ $# < 2 ]]; then\n    show_help\n    exit 1\nfi\n\nfunction init_glibc(){\n    git submodule update --init --recursive\n}\n\nfunction update_glibc (){\n    if [ \"$1\" == \"X\" ] || [ ! -f glibc-all-in-one/list ]; then\n        cd glibc-all-in-one\n        ./update_list\n        cd -\n    fi\n}\n\nfunction download_glibc (){\n    if [ \"$2\" == \"X\" ] || [ ! -d glibc-all-in-one/libs/$libc ]; then\n        cd glibc-all-in-one\n        rm -rf libs/$1 debs/$1\n        ./download $1\n        ./download_old $1\n        cd -\n    fi\n}\n\nfunction copy_glibc (){\n    if [ ! -f \"$OUTPUT_DIR/libc-$GLIBC_VERSION.so\" ]; then\n        cp -r glibc-all-in-one/libs/$1/* $OUTPUT_DIR\n        cp -r glibc-all-in-one/libs/$1/.debug $OUTPUT_DIR\n    fi\n}\n\nfunction set_interpreter (){\n    local curr_interp=$(patchelf --print-interpreter \"$TARGET\")\n    \n    if [[ $curr_interp != $1 ]];\n    then\n        patchelf --set-interpreter \"$1\" \"$TARGET\"\n        echo \"INERPERETER as $1 for $TARGET\"\n    fi\n}\n\nfunction set_rpath (){\n    curr_rpath=$(patchelf --print-rpath \"$TARGET\")\n    \n    if [[ $curr_rpath != $OUTPUT_DIR ]];\n    then\n        patchelf --set-rpath \"$OUTPUT_DIR\" \"$TARGET\"\n        echo \"RPATH as $OUTPUT_DIR\"\n    fi\n}\n\nfunction prep_in_docker () {\n\t# choose the correct base ubuntu container\n\tif (( $(echo \"$1 > 2.33\" |bc -l) ));\n\tthen\n\t\tUBUNTU_VERSION=\"22.04\"\n\telse\n\t\tUBUNTU_VERSION=\"20.04\"\n\tfi\n\n\t# make sure we have access to docker\n\tdocker --version >/dev/null 2>&1\n\tif test $? -ne 0;\n\tthen\n\t\techo \"please make sure docker is installed and you have access to it first\"\n\t\texit -1\n\tfi\n\n\t# build the docker image\n\tsed -i \"1s/.*/from ubuntu:$UBUNTU_VERSION/\" Dockerfile\n\techo \"building the how2heap_docker image!\"\n\tdocker build -t how2heap_docker .\n\n\tdocker run --rm -it -u $(id -u ${USER}):$(id -g ${USER}) -v $HOW2HEAP_PATH:/root/how2heap how2heap_docker make clean all >/dev/null\n}\n\nGLIBC_VERSION=$1\nGLIBC_MAJOR=$(echo $GLIBC_VERSION | cut -d'.' -f1)\nGLIBC_MINOR=$(echo $GLIBC_VERSION | cut -d'.' -f2)\nTARGET=$2\nSYSTEM_GLIBC_VERSION=$(lsof -p $$ 2>/dev/null | grep libc- | awk ' { print $NF\" --version\"; } ' | sh | head -n 1 | cut -d' ' -f 10 | cut -d'.' -f 1-2)\nSYSTEM_GLIBC_MAJOR=$(echo $SYSTEM_GLIBC_VERSION | cut -d'.' -f1)\nSYSTEM_GLIBC_MINOR=$(echo $SYSTEM_GLIBC_VERSION | cut -d'.' -f2)\nSYSTEM_GLIBC=$(lsof -p $$ 2>/dev/null | grep libc- | awk ' { print $NF\" --version\"; } ' | sh | head -n 1 | cut -d' ' -f 10)\n\nif [ ! -f $TARGET ]; then\n    echo \"Create binaries by make\"\n    exit\nfi\n\nwhile :; do\n    case $3 in\n        -h|-\\?|--help)\n            show_help\n            exit\n        ;;\n        #        -disable-tcache)\n        #            DIR_TCACHE='notcache'\n        #            ;;\n        -i686)\n            DIR_HOST='i686'\n            LIB_HOST='i386'\n        ;;\n        -u)\n            UPDATE='X'\n        ;;\n        -r)\n            RELOAD='X'\n        ;;\n        -d)\n            DOCKER='X'\n        ;;\n        -gdb)\n            GDB='X'\n        ;;\n        -r2)\n            RADARE2='X'\n        ;;\n        -p)\n            NOT_EXECUTION='X'\n        ;;\n        -ti)\n            FORCE_TARGET_INTERPRETER='X'\n        ;;\n        '')\n            break\n        ;;\n    esac\n    shift\ndone\n\n\nif [ ! -d ./glibc-all-in-one/LICENSE ]; then\n    init_glibc\nfi\n\nif [ -z $DIR_TCACHE ]; then\n    OUTPUT_DIR=\"$VERSION/$GLIBC_VERSION/${DIR_HOST}/lib\"\nelse\n    OUTPUT_DIR=\"$VERSION/$GLIBC_VERSION/${DIR_HOST}_${DIR_TCACHE}/lib\"\nfi\n\nif [ ! -d \"$OUTPUT_DIR\" ];\nthen\n    mkdir -p $OUTPUT_DIR\nfi\n\nupdate_glibc $UPDATE\nlibc=$(cat glibc-all-in-one/list | grep \"$GLIBC_VERSION\" | grep \"$LIB_HOST\" | head -n 1) \n\nif [ -z \"$libc\" ]\nthen\n    libc=$(cat glibc-all-in-one/old_list | grep \"$GLIBC_VERSION\" | grep \"$LIB_HOST\" | head -n 1)\nfi\n\ndownload_glibc $libc $RELOAD\ncopy_glibc $libc\nif [ -z \"$(ls -A $OUTPUT_DIR)\" ]; then\n    echo \"Couldn't download and extract glibc.\"\n    echo \"Check you have installed zstd\"\n    exit\nfi\ntarget_interpreter=\"$OUTPUT_DIR/$(ls $OUTPUT_DIR | grep ld)\"\n\nif [ \"$DOCKER\" == 'X' ];\nthen\n\tprep_in_docker $GLIBC_VERSION\nfi\n\nif [[ $GLIBC_MAJOR != $SYSTEM_GLIBC_MAJOR ]] || [[ $GLIBC_MINOR != $SYSTEM_GLIBC_MINOR ]]; then\n    set_interpreter $target_interpreter\n    set_rpath\nfi\n\nif [ \"$GDB\" == 'X' ];\nthen\n    if [[ $GLIBC_VERSION != $SYSTEM_GLIBC_VERSION ]]; then\n        gdb $TARGET -iex \"set debug-file-directory $OUTPUT_DIR/.debug\"\n    else\n        gdb $TARGET\n    fi\nelif [ \"$RADARE2\" == 'X' ];\nthen\n    r2 -d $TARGET\nelif [ \"$NOT_EXECUTION\" == ''  ];\nthen\n    \"$TARGET\"\nelse\n    echo \"$TARGET It's ready for discovering\"\nfi\n"
        },
        {
          "name": "malloc_playground.c",
          "type": "blob",
          "size": 2.2587890625,
          "content": "#include <inttypes.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#ifdef __GLIBC__\n# include <malloc.h>\n# include <mcheck.h>\nvoid print_mcheck_status(enum mcheck_status s)\n{\n\tfprintf(stderr, \"%s\\n\", (s == MCHECK_DISABLED) ? \"N/A, you didn't enable mcheck()\" :\n\t\t\t\t   (s == MCHECK_OK) ? \"No inconsistency detected\" :\n\t\t\t\t   (s == MCHECK_HEAD) ? \"Memory preceding an allocated block was clobbered\" :\n\t\t\t\t   (s == MCHECK_TAIL) ? \"Memory following an allocated block was clobbered\" :\n\t\t\t\t   (s == MCHECK_FREE) ? \"A block of memory was freed twice\" :\n\t\t\t\t   \"unknown memory check code!\");\n}\nvoid report_mcheck_fail(enum mcheck_status s)\n{\n\tfprintf(stderr, \"*** PROGRAM WOULD ABORT: \"); print_mcheck_status(s);\n}\n#endif\n\nint main(int argc, char ** argv) {\n\n\tfprintf(stderr, \"pid: %d\\n\", getpid());\n\n\tchar buffer[1000];\n\twhile (1) {\n\t\tfprintf(stderr, \"> \");\n\t\tfgets(buffer, sizeof(buffer), stdin);\n\t\tchar cmd[1000];\n\t\tintptr_t arg1, arg2;\n\t\tint num = sscanf(buffer, \"%s %\"SCNiPTR\" %\"SCNiPTR, cmd, &arg1, &arg2);\n\t\tif (strcmp(cmd, \"malloc\") == 0) {\n\t\t\tvoid* result = malloc(arg1);\n\t\t\tfprintf(stderr, \"==> %p\\n\", result);\n\t\t} else if (strcmp(cmd, \"free\") == 0) {\n\t\t\tfree((void*) arg1);\n\t\t\tfprintf(stderr, \"==> ok\\n\");\n\t\t} else if (strcmp(cmd, \"show\") == 0) {\n\t\t\tif (num == 2) {\n\t\t\t\targ2 = 1;\n\t\t\t}\n\t\t\tlong * src = (long*) arg1;\n\t\t\tfor (int i = 0; i < arg2; i++) {\n\t\t\t\tfprintf(stderr, \"%p: %#16.0lx\\n\", &src[i], src[i]);\n\t\t\t}\n#ifdef __GLIBC__\n\t\t} else if (strcmp(cmd, \"usable\") == 0) {\n\t\t\tfprintf(stderr, \"usable size: %zu\\n\", malloc_usable_size((void*) arg1));\n\t\t} else if (strcmp(cmd, \"stats\") == 0) {\n\t\t\tmalloc_stats();\n\t\t} else if (strcmp(cmd, \"info\") == 0) {\n\t\t\tmalloc_info(0, stdout);\n\t\t} else if (strcmp(cmd, \"mcheck\") == 0) {\n\t\t\tfprintf(stderr, \"==> %s\\n\", mcheck(report_mcheck_fail) == 0 ? \"OK\" : \"ERROR\");\n\t\t} else if (strcmp(cmd, \"mcheck_pedantic\") == 0) {\n\t\t\tfprintf(stderr, \"==> %s\\n\", mcheck_pedantic(report_mcheck_fail) == 0 ? \"OK\" : \"ERROR\");\n\t\t} else if (strcmp(cmd, \"mprobe\") == 0) {\n\t\t\tif (num > 1) {\n\t\t\t\tprint_mcheck_status(mprobe((void*) arg1));\n\t\t\t} else {\n\t\t\t\tmcheck_check_all();\n\t\t\t\tfprintf(stderr, \"==> check_all ok\\n\");\n\t\t\t}\n#endif\n\t\t} else {\n\t\t\tputs(\"Commands: malloc n, free p, show p [n], usable p, stats, info, mprobe [p], mcheck, mcheck_pedantic\");\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "obsolete",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}