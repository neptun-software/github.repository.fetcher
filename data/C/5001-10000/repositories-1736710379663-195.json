{
  "metadata": {
    "timestamp": 1736710379663,
    "page": 195,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "facebook/fishhook",
      "stars": 5236,
      "defaultBranch": "main",
      "files": [
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 0.2353515625,
          "content": "# Code of Conduct\nFacebook has adopted a Code of Conduct that we expect project participants to adhere to. Please [read the full text](https://code.fb.com/codeofconduct) so that you can understand what actions will and will not be tolerated."
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 1.22265625,
          "content": "# Contributing to fishhook\nWe want to make contributing to this project as easy and transparent as\npossible.\n\n## Pull Requests\nWe actively welcome your pull requests.\n\n1. Fork the repo and create your branch from `master`.\n2. If you've added code that should be tested, add tests.\n3. If you've changed APIs, update the documentation.\n4. Ensure the test suite passes.\n5. Make sure your code lints.\n6. If you haven't already, complete the Contributor License Agreement (\"CLA\").\n\n## Contributor License Agreement (\"CLA\")\nIn order to accept your pull request, we need you to submit a CLA. You only need\nto do this once to work on any of Facebook's open source projects.\n\nComplete your CLA here: <https://code.facebook.com/cla>\n\n## Issues\nWe use GitHub issues to track public bugs. Please ensure your description is\nclear and has sufficient instructions to be able to reproduce the issue.\n\nFacebook has a [bounty program](https://www.facebook.com/whitehat/) for the safe\ndisclosure of security bugs. In those cases, please go through the process\noutlined on that page and do not file a public issue.\n\n## License\nBy contributing to fishhook, you agree that your contributions will be licensed\nunder the LICENSE file in the root directory of this source tree."
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.5166015625,
          "content": "// Copyright (c) 2013, Facebook, Inc.\n// All rights reserved.\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//   * Redistributions of source code must retain the above copyright notice,\n//     this list of conditions and the following disclaimer.\n//   * Redistributions in binary form must reproduce the above copyright notice,\n//     this list of conditions and the following disclaimer in the documentation\n//     and/or other materials provided with the distribution.\n//   * Neither the name Facebook nor the names of its contributors may be used to\n//     endorse or promote products derived from this software without specific\n//     prior written permission.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.306640625,
          "content": "# fishhook\n\n__fishhook__ is a very simple library that enables dynamically rebinding symbols in Mach-O binaries running on iOS in the simulator and on device. This provides functionality that is similar to using [`DYLD_INTERPOSE`][interpose] on OS X. At Facebook, we've found it useful as a way to hook calls in libSystem for debugging/tracing purposes (for example, auditing for double-close issues with file descriptors).\n\n[interpose]: http://opensource.apple.com/source/dyld/dyld-210.2.3/include/mach-o/dyld-interposing.h \"<mach-o/dyld-interposing.h>\"\n\n## Usage\n\nOnce you add `fishhook.h`/`fishhook.c` to your project, you can rebind symbols as follows:\n```Objective-C\n#import <dlfcn.h>\n\n#import <UIKit/UIKit.h>\n\n#import \"AppDelegate.h\"\n#import \"fishhook.h\"\n \nstatic int (*orig_close)(int);\nstatic int (*orig_open)(const char *, int, ...);\n \nint my_close(int fd) {\n  printf(\"Calling real close(%d)\\n\", fd);\n  return orig_close(fd);\n}\n \nint my_open(const char *path, int oflag, ...) {\n  va_list ap = {0};\n  mode_t mode = 0;\n \n  if ((oflag & O_CREAT) != 0) {\n    // mode only applies to O_CREAT\n    va_start(ap, oflag);\n    mode = va_arg(ap, int);\n    va_end(ap);\n    printf(\"Calling real open('%s', %d, %d)\\n\", path, oflag, mode);\n    return orig_open(path, oflag, mode);\n  } else {\n    printf(\"Calling real open('%s', %d)\\n\", path, oflag);\n    return orig_open(path, oflag, mode);\n  }\n}\n \nint main(int argc, char * argv[])\n{\n  @autoreleasepool {\n    rebind_symbols((struct rebinding[2]){{\"close\", my_close, (void *)&orig_close}, {\"open\", my_open, (void *)&orig_open}}, 2);\n \n    // Open our own binary and print out first 4 bytes (which is the same\n    // for all Mach-O binaries on a given architecture)\n    int fd = open(argv[0], O_RDONLY);\n    uint32_t magic_number = 0;\n    read(fd, &magic_number, 4);\n    printf(\"Mach-O Magic Number: %x \\n\", magic_number);\n    close(fd);\n \n    return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));\n  }\n}\n```\n### Sample output\n```\nCalling real open('/var/mobile/Applications/161DA598-5B83-41F5-8A44-675491AF6A2C/Test.app/Test', 0)\nMach-O Magic Number: feedface \nCalling real close(3)\n...\n```\n\n## How it works\n\n`dyld` binds lazy and non-lazy symbols by updating pointers in particular sections of the `__DATA` segment of a Mach-O binary. __fishhook__ re-binds these symbols by determining the locations to update for each of the symbol names passed to `rebind_symbols` and then writing out the corresponding replacements.\n\nFor a given image, the `__DATA` segment may contain two sections that are relevant for dynamic symbol bindings: `__nl_symbol_ptr` and `__la_symbol_ptr`. `__nl_symbol_ptr` is an array of pointers to non-lazily bound data (these are bound at the time a library is loaded) and `__la_symbol_ptr` is an array of pointers to imported functions that is generally filled by a routine called `dyld_stub_binder` during the first call to that symbol (it's also possible to tell `dyld` to bind these at launch). In order to find the name of the symbol that corresponds to a particular location in one of these sections, we have to jump through several layers of indirection. For the two relevant sections, the section headers (`struct section`s from `<mach-o/loader.h>`) provide an offset (in the `reserved1` field) into what is known as the indirect symbol table. The indirect symbol table, which is located in the `__LINKEDIT` segment of the binary, is just an array of indexes into the symbol table (also in `__LINKEDIT`) whose order is identical to that of the pointers in the non-lazy and lazy symbol sections. So, given `struct section nl_symbol_ptr`, the corresponding index in the symbol table of the first address in that section is `indirect_symbol_table[nl_symbol_ptr->reserved1]`. The symbol table itself is an array of `struct nlist`s (see `<mach-o/nlist.h>`), and each `nlist` contains an index into the string table in `__LINKEDIT` which where the actual symbol names are stored. So, for each pointer `__nl_symbol_ptr` and `__la_symbol_ptr`, we are able to find the corresponding symbol and then the corresponding string to compare against the requested symbol names, and if there is a match, we replace the pointer in the section with the replacement.\n\nThe process of looking up the name of a given entry in the lazy or non-lazy pointer tables looks like this:\n![Visual explanation](http://i.imgur.com/HVXqHCz.png)"
        },
        {
          "name": "fishhook.c",
          "type": "blob",
          "size": 10.20703125,
          "content": "// Copyright (c) 2013, Facebook, Inc.\n// All rights reserved.\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//   * Redistributions of source code must retain the above copyright notice,\n//     this list of conditions and the following disclaimer.\n//   * Redistributions in binary form must reproduce the above copyright notice,\n//     this list of conditions and the following disclaimer in the documentation\n//     and/or other materials provided with the distribution.\n//   * Neither the name Facebook nor the names of its contributors may be used to\n//     endorse or promote products derived from this software without specific\n//     prior written permission.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n#include \"fishhook.h\"\n\n#include <dlfcn.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n#include <mach/mach.h>\n#include <mach/vm_map.h>\n#include <mach/vm_region.h>\n#include <mach-o/dyld.h>\n#include <mach-o/loader.h>\n#include <mach-o/nlist.h>\n\n#ifdef __LP64__\ntypedef struct mach_header_64 mach_header_t;\ntypedef struct segment_command_64 segment_command_t;\ntypedef struct section_64 section_t;\ntypedef struct nlist_64 nlist_t;\n#define LC_SEGMENT_ARCH_DEPENDENT LC_SEGMENT_64\n#else\ntypedef struct mach_header mach_header_t;\ntypedef struct segment_command segment_command_t;\ntypedef struct section section_t;\ntypedef struct nlist nlist_t;\n#define LC_SEGMENT_ARCH_DEPENDENT LC_SEGMENT\n#endif\n\n#ifndef SEG_DATA_CONST\n#define SEG_DATA_CONST  \"__DATA_CONST\"\n#endif\n\nstruct rebindings_entry {\n  struct rebinding *rebindings;\n  size_t rebindings_nel;\n  struct rebindings_entry *next;\n};\n\nstatic struct rebindings_entry *_rebindings_head;\n\nstatic int prepend_rebindings(struct rebindings_entry **rebindings_head,\n                              struct rebinding rebindings[],\n                              size_t nel) {\n  struct rebindings_entry *new_entry = (struct rebindings_entry *) malloc(sizeof(struct rebindings_entry));\n  if (!new_entry) {\n    return -1;\n  }\n  new_entry->rebindings = (struct rebinding *) malloc(sizeof(struct rebinding) * nel);\n  if (!new_entry->rebindings) {\n    free(new_entry);\n    return -1;\n  }\n  memcpy(new_entry->rebindings, rebindings, sizeof(struct rebinding) * nel);\n  new_entry->rebindings_nel = nel;\n  new_entry->next = *rebindings_head;\n  *rebindings_head = new_entry;\n  return 0;\n}\n\n#if 0\nstatic int get_protection(void *addr, vm_prot_t *prot, vm_prot_t *max_prot) {\n  mach_port_t task = mach_task_self();\n  vm_size_t size = 0;\n  vm_address_t address = (vm_address_t)addr;\n  memory_object_name_t object;\n#ifdef __LP64__\n  mach_msg_type_number_t count = VM_REGION_BASIC_INFO_COUNT_64;\n  vm_region_basic_info_data_64_t info;\n  kern_return_t info_ret = vm_region_64(\n      task, &address, &size, VM_REGION_BASIC_INFO_64, (vm_region_info_64_t)&info, &count, &object);\n#else\n  mach_msg_type_number_t count = VM_REGION_BASIC_INFO_COUNT;\n  vm_region_basic_info_data_t info;\n  kern_return_t info_ret = vm_region(task, &address, &size, VM_REGION_BASIC_INFO, (vm_region_info_t)&info, &count, &object);\n#endif\n  if (info_ret == KERN_SUCCESS) {\n    if (prot != NULL)\n      *prot = info.protection;\n\n    if (max_prot != NULL)\n      *max_prot = info.max_protection;\n\n    return 0;\n  }\n\n  return -1;\n}\n#endif\n\nstatic void perform_rebinding_with_section(struct rebindings_entry *rebindings,\n                                           section_t *section,\n                                           intptr_t slide,\n                                           nlist_t *symtab,\n                                           char *strtab,\n                                           uint32_t *indirect_symtab) {\n  uint32_t *indirect_symbol_indices = indirect_symtab + section->reserved1;\n  void **indirect_symbol_bindings = (void **)((uintptr_t)slide + section->addr);\n\n  for (uint i = 0; i < section->size / sizeof(void *); i++) {\n    uint32_t symtab_index = indirect_symbol_indices[i];\n    if (symtab_index == INDIRECT_SYMBOL_ABS || symtab_index == INDIRECT_SYMBOL_LOCAL ||\n        symtab_index == (INDIRECT_SYMBOL_LOCAL   | INDIRECT_SYMBOL_ABS)) {\n      continue;\n    }\n    uint32_t strtab_offset = symtab[symtab_index].n_un.n_strx;\n    char *symbol_name = strtab + strtab_offset;\n    bool symbol_name_longer_than_1 = symbol_name[0] && symbol_name[1];\n    struct rebindings_entry *cur = rebindings;\n    while (cur) {\n      for (uint j = 0; j < cur->rebindings_nel; j++) {\n        if (symbol_name_longer_than_1 && strcmp(&symbol_name[1], cur->rebindings[j].name) == 0) {\n          kern_return_t err;\n\n          if (cur->rebindings[j].replaced != NULL && indirect_symbol_bindings[i] != cur->rebindings[j].replacement)\n            *(cur->rebindings[j].replaced) = indirect_symbol_bindings[i];\n\n          /**\n           * 1. Moved the vm protection modifying codes to here to reduce the\n           *    changing scope.\n           * 2. Adding VM_PROT_WRITE mode unconditionally because vm_region\n           *    API on some iOS/Mac reports mismatch vm protection attributes.\n           * -- Lianfu Hao Jun 16th, 2021\n           **/\n          err = vm_protect (mach_task_self (), (uintptr_t)indirect_symbol_bindings, section->size, 0, VM_PROT_READ | VM_PROT_WRITE | VM_PROT_COPY);\n          if (err == KERN_SUCCESS) {\n            /**\n             * Once we failed to change the vm protection, we\n             * MUST NOT continue the following write actions!\n             * iOS 15 has corrected the const segments prot.\n             * -- Lionfore Hao Jun 11th, 2021\n             **/\n            indirect_symbol_bindings[i] = cur->rebindings[j].replacement;\n          }\n          goto symbol_loop;\n        }\n      }\n      cur = cur->next;\n    }\n  symbol_loop:;\n  }\n}\n\nstatic void rebind_symbols_for_image(struct rebindings_entry *rebindings,\n                                     const struct mach_header *header,\n                                     intptr_t slide) {\n  Dl_info info;\n  if (dladdr(header, &info) == 0) {\n    return;\n  }\n\n  segment_command_t *cur_seg_cmd;\n  segment_command_t *linkedit_segment = NULL;\n  struct symtab_command* symtab_cmd = NULL;\n  struct dysymtab_command* dysymtab_cmd = NULL;\n\n  uintptr_t cur = (uintptr_t)header + sizeof(mach_header_t);\n  for (uint i = 0; i < header->ncmds; i++, cur += cur_seg_cmd->cmdsize) {\n    cur_seg_cmd = (segment_command_t *)cur;\n    if (cur_seg_cmd->cmd == LC_SEGMENT_ARCH_DEPENDENT) {\n      if (strcmp(cur_seg_cmd->segname, SEG_LINKEDIT) == 0) {\n        linkedit_segment = cur_seg_cmd;\n      }\n    } else if (cur_seg_cmd->cmd == LC_SYMTAB) {\n      symtab_cmd = (struct symtab_command*)cur_seg_cmd;\n    } else if (cur_seg_cmd->cmd == LC_DYSYMTAB) {\n      dysymtab_cmd = (struct dysymtab_command*)cur_seg_cmd;\n    }\n  }\n\n  if (!symtab_cmd || !dysymtab_cmd || !linkedit_segment ||\n      !dysymtab_cmd->nindirectsyms) {\n    return;\n  }\n\n  // Find base symbol/string table addresses\n  uintptr_t linkedit_base = (uintptr_t)slide + linkedit_segment->vmaddr - linkedit_segment->fileoff;\n  nlist_t *symtab = (nlist_t *)(linkedit_base + symtab_cmd->symoff);\n  char *strtab = (char *)(linkedit_base + symtab_cmd->stroff);\n\n  // Get indirect symbol table (array of uint32_t indices into symbol table)\n  uint32_t *indirect_symtab = (uint32_t *)(linkedit_base + dysymtab_cmd->indirectsymoff);\n\n  cur = (uintptr_t)header + sizeof(mach_header_t);\n  for (uint i = 0; i < header->ncmds; i++, cur += cur_seg_cmd->cmdsize) {\n    cur_seg_cmd = (segment_command_t *)cur;\n    if (cur_seg_cmd->cmd == LC_SEGMENT_ARCH_DEPENDENT) {\n      if (strcmp(cur_seg_cmd->segname, SEG_DATA) != 0 &&\n          strcmp(cur_seg_cmd->segname, SEG_DATA_CONST) != 0) {\n        continue;\n      }\n      for (uint j = 0; j < cur_seg_cmd->nsects; j++) {\n        section_t *sect =\n          (section_t *)(cur + sizeof(segment_command_t)) + j;\n        if ((sect->flags & SECTION_TYPE) == S_LAZY_SYMBOL_POINTERS) {\n          perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab);\n        }\n        if ((sect->flags & SECTION_TYPE) == S_NON_LAZY_SYMBOL_POINTERS) {\n          perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab);\n        }\n      }\n    }\n  }\n}\n\nstatic void _rebind_symbols_for_image(const struct mach_header *header,\n                                      intptr_t slide) {\n    rebind_symbols_for_image(_rebindings_head, header, slide);\n}\n\nint rebind_symbols_image(void *header,\n                         intptr_t slide,\n                         struct rebinding rebindings[],\n                         size_t rebindings_nel) {\n    struct rebindings_entry *rebindings_head = NULL;\n    int retval = prepend_rebindings(&rebindings_head, rebindings, rebindings_nel);\n    rebind_symbols_for_image(rebindings_head, (const struct mach_header *) header, slide);\n    if (rebindings_head) {\n      free(rebindings_head->rebindings);\n    }\n    free(rebindings_head);\n    return retval;\n}\n\nint rebind_symbols(struct rebinding rebindings[], size_t rebindings_nel) {\n  int retval = prepend_rebindings(&_rebindings_head, rebindings, rebindings_nel);\n  if (retval < 0) {\n    return retval;\n  }\n  // If this was the first call, register callback for image additions (which is also invoked for\n  // existing images, otherwise, just run on existing images\n  if (!_rebindings_head->next) {\n    _dyld_register_func_for_add_image(_rebind_symbols_for_image);\n  } else {\n    uint32_t c = _dyld_image_count();\n    for (uint32_t i = 0; i < c; i++) {\n      _rebind_symbols_for_image(_dyld_get_image_header(i), _dyld_get_image_vmaddr_slide(i));\n    }\n  }\n  return retval;\n}\n"
        },
        {
          "name": "fishhook.h",
          "type": "blob",
          "size": 2.9873046875,
          "content": "// Copyright (c) 2013, Facebook, Inc.\n// All rights reserved.\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//   * Redistributions of source code must retain the above copyright notice,\n//     this list of conditions and the following disclaimer.\n//   * Redistributions in binary form must reproduce the above copyright notice,\n//     this list of conditions and the following disclaimer in the documentation\n//     and/or other materials provided with the distribution.\n//   * Neither the name Facebook nor the names of its contributors may be used to\n//     endorse or promote products derived from this software without specific\n//     prior written permission.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n#ifndef fishhook_h\n#define fishhook_h\n\n#include <stddef.h>\n#include <stdint.h>\n\n#if !defined(FISHHOOK_EXPORT)\n#define FISHHOOK_VISIBILITY __attribute__((visibility(\"hidden\")))\n#else\n#define FISHHOOK_VISIBILITY __attribute__((visibility(\"default\")))\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif //__cplusplus\n\n/*\n * A structure representing a particular intended rebinding from a symbol\n * name to its replacement\n */\nstruct rebinding {\n  const char *name;\n  void *replacement;\n  void **replaced;\n};\n\n/*\n * For each rebinding in rebindings, rebinds references to external, indirect\n * symbols with the specified name to instead point at replacement for each\n * image in the calling process as well as for all future images that are loaded\n * by the process. If rebind_functions is called more than once, the symbols to\n * rebind are added to the existing list of rebindings, and if a given symbol\n * is rebound more than once, the later rebinding will take precedence.\n */\nFISHHOOK_VISIBILITY\nint rebind_symbols(struct rebinding rebindings[], size_t rebindings_nel);\n\n/*\n * Rebinds as above, but only in the specified image. The header should point\n * to the mach-o header, the slide should be the slide offset. Others as above.\n */\nFISHHOOK_VISIBILITY\nint rebind_symbols_image(void *header,\n                         intptr_t slide,\n                         struct rebinding rebindings[],\n                         size_t rebindings_nel);\n\n#ifdef __cplusplus\n}\n#endif //__cplusplus\n\n#endif //fishhook_h\n\n"
        },
        {
          "name": "fishhook.podspec",
          "type": "blob",
          "size": 0.64453125,
          "content": "Pod::Spec.new do |spec|\n  spec.name             = \"fishhook\"\n  spec.version          = \"0.2\"\n  spec.license          = { :type => \"BSD\", :file => \"LICENSE\" }\n  spec.homepage         = 'https://github.com/facebook/fishhook'\n  spec.author           = { \"Facebook, Inc.\" => \"https://github.com/facebook\" }\n  spec.summary          = \"A library that enables dynamically rebinding symbols in Mach-O binaries running on iOS.\"\n  spec.source           = { :git => \"https://github.com/facebook/fishhook.git\", :tag => '0.2'}\n  spec.source_files     = \"fishhook.{h,c}\"\n  spec.social_media_url = 'https://twitter.com/fbOpenSource'\n\n  spec.ios.deployment_target = '6.0'\nend\n"
        }
      ]
    }
  ]
}