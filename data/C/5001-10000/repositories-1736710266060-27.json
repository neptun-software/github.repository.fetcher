{
  "metadata": {
    "timestamp": 1736710266060,
    "page": 27,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "AppImage/AppImageKit",
      "stars": 8839,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.158203125,
          "content": "# Build directory\n*build*/\ncmake-build-*/\n.idea/\nTesting/\n*.swp\nruntime\nruntime-*\nAppRun\nAppRun-*\nvalidate\nvalidate-*\ndigest\ndigest-*\nappimagetool\nappimagetool-*\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.4560546875,
          "content": "MIT License\n\nIf not stated otherwise within the individual file or subdirectory, the\noriginal source code in this repository is licensed as below. This does not\nnecessarily apply for all dependencies. For the sake of clarity, this license\ndoes NOT apply to the contents of AppImages that anyone may create.\nSoftware contained inside an AppImage may be licensed under any license at the\ndiscretion of the respecive rights holder(s).\n\nCopyright (c) 2004-20 Simon Peter\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 6.34765625,
          "content": "# AppImageKit  [![irc](https://img.shields.io/badge/IRC-%23AppImage%20on%20libera.chat-blue.svg)](https://web.libera.chat/#AppImage) [![Donate](https://img.shields.io/badge/Donate-PayPal-green.svg)](https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=ZT9CL8M5TJU72)\n\nThe __AppImage__ format is a format for packaging applications in a way that allows them to\nrun on a variety of different target systems (base operating systems, distributions) without further modification. \n\nUsing the AppImage format you can package desktop applications as AppImages that run on common Linux-based operating systems, such as RHEL, CentOS, Ubuntu, Fedora, Debian and derivatives.\n\nCopyright (c) 2004-24 Simon Peter <probono@puredarwin.org> and contributors.\n\nhttps://en.wikipedia.org/wiki/AppImage\n\nProviding an [AppImage](http://appimage.org/) for distributing application has, among others, these advantages:\n- Applications packaged as an AppImage can run on many distributions (including Debian, Ubuntu, Fedora, openSUSE, Linux Mint, and others)\n- One app = one file = super simple for users: just download one AppImage file, [make it executable](http://discourse.appimage.org/t/how-to-make-an-appimage-executable/80), and run\n- No unpacking or installation necessary\n- No root needed\n- No system libraries changed\n- Works out of the box, no installation of runtimes needed\n- Optional desktop integration with [appimaged](https://github.com/probonopd/go-appimage/tree/master/src/appimaged#appimaged)\n- Optional binary delta updates, e.g., for continuous builds (only download the binary diff) using AppImageUpdate\n- Can optionally GPG2-sign your AppImages (inside the file)\n- Works on Live ISOs\n- Can use the same AppImages when dual-booting multiple distributions\n- Can be listed in the [AppImageHub](https://appimage.github.io/apps) central directory of available AppImages\n- Can double as a self-extracting compressed archive with the `--appimage-extract` parameter\n\n[Here is an overview](https://appimage.github.io/apps) of projects that are distributing AppImages.\n\nIf you have questions, AppImage developers are on #AppImage on irc.libera.chat.\n\n## AppImage usage\n\nRunning an AppImage mounts the filesystem image and transparently runs the contained application. So the usage of an AppImage normally should equal the usage of the application contained in it. However, there is special functionality, as described here. If an AppImage you have received does not support these options, ask the author of the AppImage to recreate it using the latest tooling).\n\n### Command line arguments\n\nIf you invoke an AppImage built with a recent version of AppImageKit with one of these special command line arguments, then the AppImage will behave differently:\n\n- `--appimage-help` prints the help options\n- `--appimage-offset` prints the offset at which the embedded filesystem image starts, and then exits. This is useful in case you would like to loop-mount the filesystem image using the `mount -o loop,offset=...` command \n- `--appimage-extract` extracts the contents from the embedded filesystem image, then exits. This is useful if you are using an AppImage on a system on which FUSE is not available\n- `--appimage-mount` mounts the embedded filesystem image and prints the mount point, then waits until it is killed. This is useful if you would like to inspect the contents of an AppImage without executing the contained payload application\n- `--appimage-version` prints the version of AppImageKit, then exits. This is useful if you would like to file issues\n- `--appimage-updateinformation` prints the update information embedded into the AppImage, then exits. This is useful for debugging binary delta updates\n- `--appimage-signature` prints the digital signature embedded into the AppImage, then exits. This is useful for debugging binary delta updates. If you would like to validate the embedded signature, you should use the `validate` command line tool that is part of AppImageKit\n\n### Special directories\n\nNormally the application contained inside an AppImage will store its configuration files wherever it normally stores them (most frequently somewhere inside `$HOME`). If you invoke an AppImage built with a recent version of AppImageKit and have one of these special directories in place, then the configuration files will be stored alongside the AppImage. This can be useful for portable use cases, e.g., carrying an AppImage on a USB stick, along with its data.\n\n- If there is a directory with the same name as the AppImage plus `.home`, then `$HOME` will automatically be set to it before executing the payload application\n- If there is a directory with the same name as the AppImage plus `.config`, then `$XDG_CONFIG_HOME` will automatically be set to it before executing the payload application\n\nExample: Imagine you want to use the Leafpad text editor, but carry its settings around with the executable. You can do the following:\n\n```bash\n# Download Leafpad AppImage and make it executable\nchmod a+x Leafpad-0.8.18.1.glibc2.4-x86_64.AppImage\n\n# Create a directory with the same name as the AppImage plus the \".config\" extension\n# in the same directory as the AppImage\nmkdir Leafpad-0.8.18.1.glibc2.4-x86_64.AppImage.config\n\n# Run Leafpad, change some setting (e.g., change the default font size) then close Leafpad\n./Leafpad-0.8.18.1.glibc2.4-x86_64.AppImage\n\n# Now, check where the settings were written:\nlinux@linux:~> find Leafpad-0.8.18.1.glibc2.4-x86_64.AppImage.config\n(...)\nLeafpad-0.8.18.1.glibc2.4-x86_64.AppImage.config/leafpad/leafpadrc\n```\n\nNote that the file `leafpadrc` was written in the directory we have created before.\n\n## appimagetool\n\n`appimagetool` is a low-level tool used to convert a valid AppDir into an AppImage. It us usually used by [higher-level tools](https://github.com/AppImageCommunity/awesome-appimage?tab=readme-ov-file#appimage-developer-tools) that can be used by application developers to provide AppImages of their applications to end users. `appimagetool` itself is not needed by end users, and is normally not used directly by developers.\nPlease see https://github.com/AppImage/appimagetool.\n\n## AppImage runtime\n\nThe AppImage runtime is a small piece of code that becomes part of every AppImage. It mounts the AppImage and executes the application contained in it.\nPlease see https://github.com/AppImage/type2-runtime.\n\n## AppImageSpec\n\nThe AppImageSpec defines the AppImage format.\nPlease see https://github.com/AppImage/AppImageSpec.\n"
        },
        {
          "name": "motivation.md",
          "type": "blob",
          "size": 4.9912109375,
          "content": "# Motivation\n\nLinus addresses some core issues of Linux on the desktop in his [DebConf 14_ QA with Linus Torvalds talk](https://www.youtube.com/watch?v=5PmHRSeA2c8). At 05:40 Linus highlights application packaging: \n\n> I'm talking about actual application writers that want to make a package of their application for Linux. And I've seen this firsthand with the other project I've been involved with, which is my divelog application.\n\nObviously Linus is talking about [Subsurface](https://subsurface-divelog.org). \n\n> We make binaries for Windows and OS X. \n\nBoth bundle not only the application itself, but also the required Qt libraries that the application needs to run. Also included are dependency libraries like `libssh2.1.dylib`and `libzip.2.dylib`.\n\n> We basically don't make binaries for Linux. Why? Because binaries for Linux desktop applications is a major f*ing pain in the ass. Right. You don't make binaries for Linux. You make binaries for Fedora 19, Fedora 20, maybe there's even like RHEL 5 from ten years ago, you make binaries for debian stable.\n\nSo why not use the same approach as on Windows and OS X, namely, treat the base operating system as a _platform_ on top of which we run the application we care about. This means that we have to bundle the application with all their dependencies that are _not_ part of the base operating system. Welcome [application bundles](https://blogs.gnome.org/tvb/2013/12/10/application-bundles-for-glade/).\n\n> Or actually you don't make binaries for debian stable because debian stable has libraries that are so old that anything that was built in the last century doesn't work. But you might make binaries for debian... whatever the codename is for unstable. And even that is a major pain because (...) debian has those rules that you are supposed to use shared libraries. Right. \n\nThis is why binaries going into an AppImage should be built against the oldest still-supported LTS or Enterprise distributions, or _all_ dependencies should be privately bundled in the AppImage.\n\n> And if you don't use shared libraries, getting your package in, like, is just painful. \n\n\"Getting your package in\" means that the distribution accepts the package as part of the base operating system. For an application, that might not be desired at all. As long as we can package the application in a way that it seamlessly runs on top of the base operating system. \n\n> But using shared libraries is not an option when the libraries are experimental and the libraries are used by two people and one of them is crazy, so every other day some ABI breaks. \n\nOne simple way to achieve this is to bundle private copies of the libraries in question with the application that uses them. Preferably in a way that does not interfere with anything else that is running on the base operating system. Note that this does not have to be true for all libraries; core libraries that are matured, have stable interfaces and can reasonably expected to be present in all distributions do not necessarily have to be bundled with the application.\n\n> So you actually want to just compile one binary and have it work. Preferably forever. And preferably across all Linux distributions. \n\nThat is actually possible, as long as you stay away from any distribution-specific packaging, and as long as you privately bundle all dependencies.\n\n> And I actually think distributions have done a horribly, horribly bad job. \n\nDistributions are all about building the base operating system. But I don't think distributions are a good way to get applications. Rather, I would prefer to get the latest versions of applications directly from the people who write them. And this is already a reality for software like Google Chrome, Eclipse, Arduino and other applications. Who uses the (mostly outdated and changed) versions that are part of the distributions? Probably most people don't.\n\n> One of the things that I do on the kernel - and I have to fight this every single release and I think it's sad - we have one rule in the kernel, one rule: we don't break userspace. (...) People break userspace, I get really, really angry. (...) \n\nExcellent. Thank you for this policy! This is why I can still run the Mosaic browser from over a decade ago on modern Linux-based operating systems. (I tried and it works.)\n\n> And then all the distributions come in and they screw it all up. Because they break binary compatibility left and right. \n\nLuckily, binaries built on older distributions tend to still work on newer distributions. At least that has been my experience over the last decade with building application bundles using AppImageKit, and before that, klik.\n\n> They update glibc and everything breaks. (...) \n\nThere is a [way around this](https://blogs.gnome.org/tvb/2013/12/14/application-bundles-revisited/), although not many people actually care to use the workaround (yet).\n\n> So that's my rant. And that's what I really fundamentally think needs to change for Linux to work on the desktop because you can't have applications writers to do fifteen billion different versions.\n\nAppImage to the rescue!\n"
        }
      ]
    }
  ]
}