{
  "metadata": {
    "timestamp": 1736710317811,
    "page": 110,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjExMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "OpenMathLib/OpenBLAS",
      "stars": 6510,
      "defaultBranch": "develop",
      "files": [
        {
          "name": ".cirrus.yml",
          "type": "blob",
          "size": 5.6103515625,
          "content": "macos_instance:\n  image: ghcr.io/cirruslabs/macos-monterey-xcode:latest\n\n#task:\n#  name: AppleM1/LLVM\n#  compile_script:\n#  - brew install llvm\n#  - export PATH=/opt/homebrew/opt/llvm/bin:$PATH\n#  - export LDFLAGS=\"-L/opt/homebrew/opt/llvm/lib\"\n#  - export CPPFLAGS=\"-I/opt/homebrew/opt/llvm/include\"\n#  - make TARGET=VORTEX USE_OPENMP=1 CC=clang\n\n#task:\n#  name: AppleM1/LLVM/ILP64\n#  compile_script:\n#  - brew install llvm\n#  - export PATH=/opt/homebrew/opt/llvm/bin:$PATH\n#  - export LDFLAGS=\"-L/opt/homebrew/opt/llvm/lib\"\n#  - export CPPFLAGS=\"-I/opt/homebrew/opt/llvm/include\"\n#  - make TARGET=VORTEX USE_OPENMP=1 CC=clang INTERFACE64=1\n\n#task:\n#  name: AppleM1/LLVM/CMAKE\n#  compile_script:\n#  - brew install llvm\n#  - export PATH=/opt/homebrew/opt/llvm/bin:$PATH\n#  - export LDFLAGS=\"-L/opt/homebrew/opt/llvm/lib\"\n#  - export CPPFLAGS=\"-I/opt/homebrew/opt/llvm/include\"\n#  - mkdir build\n#  - cd build\n#  - cmake -DTARGET=VORTEX -DCMAKE_C_COMPILER=clang -DBUILD_SHARED_LIBS=ON ..\n#  - make -j 4\n\n#task:\n#  name: AppleM1/GCC/MAKE/OPENMP\n#  compile_script:\n#  - brew install gcc@11\n#  - export PATH=/opt/homebrew/bin:$PATH\n#  - export LDFLAGS=\"-L/opt/homebrew/lib\"\n#  - export CPPFLAGS=\"-I/opt/homebrew/include\"\n#  - make CC=gcc-11 FC=gfortran-11 USE_OPENMP=1\n  \nmacos_instance:\n  image: ghcr.io/cirruslabs/macos-sonoma-xcode:latest\ntask:\n  name: AppleM1/LLVM x86_64 xbuild\n  compile_script:\n  - #brew install llvm\n  - export #PATH=/opt/homebrew/opt/llvm/bin:$PATH\n  - export #LDFLAGS=\"-L/opt/homebrew/opt/llvm/lib\"\n  - export #CPPFLAGS=\"-I/opt/homebrew/opt/llvm/include\" \n  - export ARCHS=\"i386 x86_64\"\n  - export ARCHS_STANDARD=\"i386 x86_64\"\n  - export ARCHS_STANDARD_32_64_BIT=\"i386 x86_64\"\n  - export ARCHS_STANDARD_64_BIT=x86_64\n  - export ARCHS_STANDARD_INCLUDING_64_BIT=\"i386 x86_64\"\n  - export ARCHS_UNIVERSAL_IPHONE_OS=\"i386 x86_64\"\n  - export VALID_ARCHS=\"i386 x86_64\"\n  - xcrun --sdk macosx --show-sdk-path\n  - xcodebuild -version\n  - export CC=/Applications/Xcode_15.4.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang\n  - export CFLAGS=\"-O2 -unwindlib=none -Wno-macro-redefined -isysroot /Applications/Xcode_15.4.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.5.sdk -arch x86_64\"\n  - make TARGET=CORE2 DYNAMIC_ARCH=1 NUM_THREADS=32 HOSTCC=clang NOFORTRAN=1 RANLIB=\"ls -l\"\n  always:\n    config_artifacts:\n      path: \"*conf*\"\n      type: text/plain\n#  lib_artifacts:\n#    path: \"libopenblas*\"\n#    type: application/octet-streamm\n\nmacos_instance:\n  image: ghcr.io/cirruslabs/macos-sonoma-xcode:latest\ntask:\n  name: AppleM1/LLVM armv8-ios xbuild\n  compile_script:\n  - #brew install llvm\n  - export #PATH=/opt/homebrew/opt/llvm/bin:$PATH\n  - export #LDFLAGS=\"-L/opt/homebrew/opt/llvm/lib\"\n  - export #CPPFLAGS=\"-I/opt/homebrew/opt/llvm/include\" \n  - export CC=/Applications/Xcode_15.4.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang\n  - export CFLAGS=\"-O2 -unwindlib=none -Wno-macro-redefined -isysroot /Applications/Xcode_15.4.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS17.5.sdk -arch arm64 -miphoneos-version-min=10.0\"\n  - xcrun --sdk iphoneos --show-sdk-path\n  - ls -l /Applications\n  - make TARGET=ARMV8 NUM_THREADS=32 HOSTCC=clang NOFORTRAN=1 CROSS=1\n  always:\n    config_artifacts:\n      path: \"*conf*\"\n      type: text/plain\n\nmacos_instance:\n  image: ghcr.io/cirruslabs/macos-sonoma-xcode:latest\ntask:\n  name: AppleM1/LLVM armv7-androidndk xbuild\n  compile_script:\n  - brew install --cask android-ndk\n  - export ANDROID_NDK_HOME=\"/opt/homebrew/share/android-ndk\"\n  - export CC=/opt/homebrew/share/android-ndk/toolchains/llvm/prebuilt/darwin-x86_64/bin/armv7a-linux-androideabi23-clang\n  - make TARGET=ARMV7 ARM_SOFTFP_ABI=1 NUM_THREADS=32 HOSTCC=clang NOFORTRAN=1 RANLIB=\"ls -l\"\n  always:\n    config_artifacts:\n      path: \"*conf*\"\n      type: text/plain\n\ntask:\n  name: NeoverseN1\n  arm_container:\n    image: node:latest\n  compile_script:\n  - make\n\n  task:\n  name: NeoverseN1-ILP64\n  arm_container:\n    image: node:latest\n  compile_script:\n  - make INTERFACE64=1\n\ntask:\n  name: NeoverseN1-OMP\n  arm_container:\n    image: node:latest\n    cpu: 8\n  compile_script:\n  - make USE_OPENMP=1\n\nFreeBSD_task:\n  name: FreeBSD-gcc\n  freebsd_instance:\n    image_family: freebsd-14-1\n  install_script:\n  - pkg update -f && pkg upgrade -y && pkg install -y gmake gcc\n  compile_script:\n  - ls -l /usr/local/lib\n  - gmake CC=gcc \n\n\nFreeBSD_task:\n  name: freebsd-gcc-ilp64\n  freebsd_instance:\n    image_family: freebsd-14-1\n  install_script:\n  - pkg update -f && pkg upgrade -y && pkg install -y gmake gcc\n  compile_script:\n  - ls -l /usr/local/lib\n  - gmake CC=gcc INTERFACE64=1\n\nFreeBSD_task:\n  name: FreeBSD-clang-openmp\n  freebsd_instance:\n    image_family: freebsd-14-1\n  install_script:\n  - pkg update -f && pkg upgrade -y && pkg install -y gmake gcc \n  - ln -s /usr/local/lib/gcc13/libgfortran.so.5.0.0 /usr/lib/libgfortran.so\n  compile_script:\n  - gmake CC=clang FC=gfortran USE_OPENMP=1 CPP_THREAD_SAFETY_TEST=1\n\n#task:\n#  name: Windows/LLVM16     --- too slow ---\n#  windows_container:\n#    image: cirrusci/windowsservercore:cmake-2021.12.07\n#  install_script: \n#    - choco list --localonly\n#    - choco install -y llvm\n#    - # choco install -y cmake --installargs '\"ADD_CMAKE_TO_PATH=System\"'\n#    - choco install -y ninja\n#    - refreshenv\n#    - cd \"c:/Program Files (x86)/Microsoft Visual Studio/2019/BuildTools/VC/Auxiliary/Build\"\n#    - vcvarsall x64\n#    - cd \"C:\\Users\\ContainerAdministrator\\AppData\\Local\\Temp\\cirrus-ci-build\"\n#    - cmake -S . -B build -G \"Ninja\" -DCMAKE_CXX_COMPILER=clang-cl -DCMAKE_C_COMPILER=clang-cl -DCMAKE_MT=mt -DCMAKE_BUILD_TYPE=Release\n#    - cd build\n#    - cmake --build .\n#    - ctest\n"
        },
        {
          "name": ".cirun.yml",
          "type": "blob",
          "size": 0.5478515625,
          "content": "# Self-Hosted Github Action Runners on AWS via Cirun.io\n# Reference: https://docs.cirun.io/reference/yaml\nrunners:\n  - name: \"aws-runner-graviton\"\n    # Cloud Provider: AWS\n    cloud: \"aws\"\n    region: \"us-east-1\"\n    # Cheapest VM on AWS\n    instance_type: \"c7g.large\"\n    # Ubuntu-22.04, ami image\n    machine_image: \"ami-0a0c8eebcdd6dcbd0\"\n    preemptible: false\n    # Add this label in the \"runs-on\" param in .github/workflows/<workflow-name>.yml\n    # So that this runner is created for running the workflow\n    labels:\n      - \"cirun-aws-runner-graviton\"\n"
        },
        {
          "name": ".drone.yml",
          "type": "blob",
          "size": 4.46484375,
          "content": "---\nkind: pipeline\nname: arm64_gcc_make\n\nplatform:\n  os: linux\n  arch: arm64\n\nsteps:\n- name: Build and Test\n  image: ubuntu:18.04\n  environment:\n    CC: gcc\n    COMMON_FLAGS: 'DYNAMIC_ARCH=1 TARGET=ARMV8 NUM_THREADS=32'\n  commands:\n    - echo \"MAKE_FLAGS:= $COMMON_FLAGS\"\n    - apt-get update -y\n    - apt-get install -y make $CC gfortran perl\n    - $CC --version\n    - make QUIET_MAKE=1 $COMMON_FLAGS\n    - make -C test $COMMON_FLAGS\n    - make -C ctest $COMMON_FLAGS\n    - make -C utest $COMMON_FLAGS\n\n---\nkind: pipeline\nname: arm32_gcc_make\n\nplatform:\n  os: linux\n  arch: arm\n\nsteps:\n- name: Build and Test\n  image: ubuntu:18.04\n  environment:\n    CC: gcc\n    COMMON_FLAGS: 'DYNAMIC_ARCH=1 TARGET=ARMV6 NUM_THREADS=32'\n  commands:\n    - echo \"MAKE_FLAGS:= $COMMON_FLAGS\"\n    - apt-get update -y\n    - apt-get install -y make $CC gfortran perl\n    - $CC --version\n    - make QUIET_MAKE=1 $COMMON_FLAGS\n    - make -C test $COMMON_FLAGS\n    - make -C ctest $COMMON_FLAGS\n    - make -C utest $COMMON_FLAGS\n\n---\nkind: pipeline\nname: arm64_clang_make\n\nplatform:\n  os: linux\n  arch: arm64\n\nsteps:\n- name: Build and Test\n  image: ubuntu:18.04\n  environment:\n    CC: clang\n    COMMON_FLAGS: 'DYNAMIC_ARCH=1 TARGET=ARMV8 NUM_THREADS=32'\n  commands:\n    - echo \"MAKE_FLAGS:= $COMMON_FLAGS\"\n    - apt-get update -y\n    - apt-get install -y make $CC gfortran perl\n    - $CC --version\n    - make QUIET_MAKE=1 $COMMON_FLAGS\n    - make -C test $COMMON_FLAGS\n    - make -C ctest $COMMON_FLAGS\n    - make -C utest $COMMON_FLAGS\n\n---\nkind: pipeline\nname: arm32_clang_cmake\n\nplatform:\n  os: linux\n  arch: arm\n\nsteps:\n- name: Build and Test\n  image: ubuntu:18.04\n  environment:\n    CC: clang\n    CMAKE_FLAGS: '-DDYNAMIC_ARCH=1 -DTARGET=ARMV6 -DNUM_THREADS=32 -DNOFORTRAN=ON -DBUILD_WITHOUT_LAPACK=ON'\n  commands:\n    - echo \"CMAKE_FLAGS:= $CMAKE_FLAGS\"\n    - apt-get update -y\n    - apt-get install -y make $CC g++ perl cmake\n    - $CC --version\n    - mkdir build && cd build\n    - cmake $CMAKE_FLAGS ..\n    - make -j\n    - ctest -V\n\n---\nkind: pipeline\nname: arm64_gcc_cmake\n\nplatform:\n  os: linux\n  arch: arm64\n\nsteps:\n- name: Build and Test\n  image: ubuntu:18.04\n  environment:\n    CC: gcc\n    CMAKE_FLAGS: '-DDYNAMIC_ARCH=1 -DTARGET=ARMV8 -DNUM_THREADS=32 -DNOFORTRAN=ON -DBUILD_WITHOUT_LAPACK=ON'\n  commands:\n    - echo \"CMAKE_FLAGS:= $CMAKE_FLAGS\"\n    - apt-get update -y\n    - apt-get install -y make $CC g++ perl cmake\n    - $CC --version\n    - mkdir build && cd build\n    - cmake $CMAKE_FLAGS ..\n    - make -j\n    - ctest -V\n\n---\nkind: pipeline\nname: arm64_clang_cmake\n\nplatform:\n  os: linux\n  arch: arm64\n\nsteps:\n- name: Build and Test\n  image: ubuntu:18.04\n  environment:\n    CC: clang\n    CMAKE_FLAGS: '-DDYNAMIC_ARCH=1 -DTARGET=ARMV8 -DNUM_THREADS=32 -DNOFORTRAN=ON -DBUILD_WITHOUT_LAPACK=ON'\n  commands:\n    - echo \"CMAKE_FLAGS:= $CMAKE_FLAGS\"\n    - apt-get update -y\n    - apt-get install -y make $CC g++ perl cmake\n    - $CC --version\n    - mkdir build && cd build\n    - cmake $CMAKE_FLAGS ..\n    - make -j\n    - ctest -V\n\n---\nkind: pipeline\nname: arm64_native_test\n\nplatform:\n  os: linux\n  arch: arm64\n\nsteps:\n- name: Build and Test\n  image: ubuntu:18.04\n  environment:\n    CC: gcc\n    COMMON_FLAGS: 'USE_OPENMP=1'\n  commands:\n    - echo \"MAKE_FLAGS:= $COMMON_FLAGS\"\n    - apt-get update -y\n    - apt-get install -y make $CC gfortran perl python g++\n    - $CC --version\n    - make QUIET_MAKE=1 $COMMON_FLAGS\n    - make -C test $COMMON_FLAGS\n    - make -C ctest $COMMON_FLAGS\n    - make -C utest $COMMON_FLAGS\n    - make -C cpp_thread_test dgemm_tester\n---\nkind: pipeline\nname: epyc_native_test\n\nplatform:\n  os: linux\n  arch: amd64\n\nsteps:\n- name: Build and Test\n  image: ubuntu:18.04\n  environment:\n    CC: gcc\n    COMMON_FLAGS: 'USE_OPENMP=1'\n  commands:\n    - echo \"MAKE_FLAGS:= $COMMON_FLAGS\"\n    - apt-get update -y\n    - apt-get install -y make $CC gfortran perl python g++\n    - $CC --version\n    - make QUIET_MAKE=1 $COMMON_FLAGS\n    - make -C test $COMMON_FLAGS\n    - make -C ctest $COMMON_FLAGS\n    - make -C utest $COMMON_FLAGS\n    - make -C cpp_thread_test dgemm_tester\n---\nkind: pipeline\nname: arm64_gcc10\n\nplatform:\n  os: linux\n  arch: arm64\n\nsteps:\n- name: Build and Test\n  image: ubuntu:20.04\n  environment:\n    CC: gcc-10\n    FC: gfortran-10\n    COMMON_FLAGS: 'TARGET=ARMV8 DYNAMIC_ARCH=1'\n  commands:\n    - echo \"MAKE_FLAGS:= $COMMON_FLAGS\"\n    - apt-get update -y\n    - apt-get install -y make $CC gfortran-10 perl python g++\n    - $CC --version\n    - make QUIET_MAKE=1 $COMMON_FLAGS\n    - make -C utest $COMMON_FLAGS\n    - make -C test $COMMON_FLAGS\n    \n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 1.8515625,
          "content": "*.obj\n*.lib\n*.dll\n*.dylib\n*.def\n*.o\n*.out\n*.tmp\nlapack-3.1.1\nlapack-3.1.1.tgz\nlapack-3.4.1\nlapack-3.4.1.tgz\nlapack-3.4.2\nlapack-3.4.2.tgz\nlapack-netlib/make.inc\nlapack-netlib/lapacke/include/lapacke_mangling.h\nlapack-netlib/SRC/la_constants.mod\nlapack-netlib/TESTING/testing_results.txt\nlapack-netlib/INSTALL/test*\nlapack-netlib/TESTING/xeigtstc\nlapack-netlib/TESTING/xeigtstd\nlapack-netlib/TESTING/xeigtsts\nlapack-netlib/TESTING/xeigtstz\nlapack-netlib/TESTING/xlintstc\nlapack-netlib/TESTING/xlintstd\nlapack-netlib/TESTING/xlintstds\nlapack-netlib/TESTING/xlintstrfc\nlapack-netlib/TESTING/xlintstrfd\nlapack-netlib/TESTING/xlintstrfs\nlapack-netlib/TESTING/xlintstrfz\nlapack-netlib/TESTING/xlintsts\nlapack-netlib/TESTING/xlintstz\nlapack-netlib/TESTING/xlintstzc\n*.so\n*.so.*\n*.a\n.svn\n*~\nlib.grd\nnohup.out\nconfig.h\nconfig_kernel.h\nMakefile.conf\nMakefile.conf_last\nMakefile_kernel.conf\nconfig_last.h\ngetarch\ngetarch_2nd\nutest/openblas_utest\nutest/openblas_utest_ext\nctest/xccblat1\nctest/xccblat2\nctest/xccblat3\nctest/xccblat3_3m\nctest/xdcblat1\nctest/xdcblat2\nctest/xdcblat3\nctest/xdcblat3_3m\nctest/xscblat1\nctest/xscblat2\nctest/xscblat3\nctest/xscblat3_3m\nctest/xzcblat1\nctest/xzcblat2\nctest/xzcblat3\nctest/xzcblat3_3m\nexports/linktest.c\nexports/linux.def\nkernel/setparam_*.c\nkernel/kernel_*.h\ntest/CBLAT2.SUMM\ntest/CBLAT3.SUMM\ntest/CBLAT3_3M.SUMM\ntest/DBLAT2.SUMM\ntest/DBLAT3.SUMM\ntest/DBLAT3_3M.SUMM\ntest/SBLAT2.SUMM\ntest/SBLAT3.SUMM\ntest/SBLAT3_3M.SUMM\ntest/ZBLAT2.SUMM\ntest/ZBLAT3.SUMM\ntest/ZBLAT3_3M.SUMM\ntest/SHBLAT3.SUMM\ntest/SBBLAT3.SUMM\ntest/cblat1\ntest/cblat2\ntest/cblat3\ntest/cblat3_3m\ntest/dblat1\ntest/dblat2\ntest/dblat3\ntest/dblat3_3m\ntest/sblat1\ntest/sblat2\ntest/sblat3\ntest/sblat3_3m\ntest/test_shgemm\ntest/test_sbgemm\ntest/zblat1\ntest/zblat2\ntest/zblat3\ntest/zblat3_3m\nbuild\nbuild.*\n*.swp\nbenchmark/*.goto\nbenchmark/smallscaling\n.vscode\nCMakeCache.txt\nCMakeFiles/*\n.vscode\n**/__pycache__\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 10.361328125,
          "content": "# XXX: Precise is already deprecated, new default is Trusty.\n# https://blog.travis-ci.com/2017-07-11-trusty-as-default-linux-is-coming\ndist: focal\nsudo: true\nlanguage: c\n\nmatrix:\n  include:\n    - &test-ubuntu\n#      os: linux\n      compiler: gcc\n      addons:\n        apt:\n          packages:\n            - gfortran\n#      before_script: &common-before\n#        - COMMON_FLAGS=\"DYNAMIC_ARCH=1 TARGET=NEHALEM NUM_THREADS=32\"\n#      script:\n#        - make QUIET_MAKE=1 $COMMON_FLAGS $BTYPE\n#        - make -C test $COMMON_FLAGS $BTYPE\n#        - make -C ctest $COMMON_FLAGS $BTYPE\n#        - make -C utest $COMMON_FLAGS $BTYPE\n#      env:\n#        - TARGET_BOX=LINUX64\n#        - BTYPE=\"BINARY=64\"\n#\n#    - <<: *test-ubuntu\n      os: linux\n      arch: ppc64le\n      before_script: &common-before\n        - COMMON_FLAGS=\"DYNAMIC_ARCH=1 TARGET=POWER8 NUM_THREADS=32\"\n      script:\n        - travis_wait 50 make QUIET_MAKE=1 $COMMON_FLAGS $BTYPE\n        - make -C test $COMMON_FLAGS $BTYPE\n        - make -C ctest $COMMON_FLAGS $BTYPE\n        - make -C utest $COMMON_FLAGS $BTYPE\n      env:\n        # for matrix annotation only\n        - TARGET_BOX=PPC64LE_LINUX\n        - BTYPE=\"BINARY=64 USE_OPENMP=1\"\n\n    - <<: *test-ubuntu\n      os: linux\n      arch: s390x\n      before_script:\n        - COMMON_FLAGS=\"DYNAMIC_ARCH=1 TARGET=Z13 NUM_THREADS=32\"\n        - sudo apt-get install --only-upgrade binutils\n      env:\n        # for matrix annotation only\n        - TARGET_BOX=IBMZ_LINUX\n        - BTYPE=\"BINARY=64 USE_OPENMP=1\"\n\n    - <<: *test-ubuntu\n      os: linux\n      dist: focal\n      arch: s390x\n      compiler: clang\n      before_script:\n        - COMMON_FLAGS=\"DYNAMIC_ARCH=1 TARGET=Z13 NUM_THREADS=32\"\n        - sudo apt-get install --only-upgrade binutils\n      env:\n        # for matrix annotation only\n        - TARGET_BOX=IBMZ_LINUX\n        - BTYPE=\"BINARY=64 USE_OPENMP=0 CC=clang\"\n\n#    - <<: *test-ubuntu\n#      env:\n#        - TARGET_BOX=LINUX64\n#        - BTYPE=\"BINARY=64 USE_OPENMP=1\"\n#\n#    - <<: *test-ubuntu\n#      env:\n#        - TARGET_BOX=LINUX64\n#        - BTYPE=\"BINARY=64 INTERFACE64=1\"\n#\n#    - <<: *test-ubuntu\n#      compiler: clang\n#      env:\n#        - TARGET_BOX=LINUX64\n#        - BTYPE=\"BINARY=64 CC=clang\"\n#\n#    - <<: *test-ubuntu\n#      compiler: clang\n#      env:\n#        - TARGET_BOX=LINUX64\n#        - BTYPE=\"BINARY=64 INTERFACE64=1 CC=clang\"\n#\n#    - <<: *test-ubuntu\n#      addons:\n#        apt:\n#          packages:\n#            - gcc-multilib\n#            - gfortran-multilib\n#      env:\n#        - TARGET_BOX=LINUX32\n#        - BTYPE=\"BINARY=32\"\n#\n    - os: linux\n      arch: ppc64le\n      dist: bionic\n      compiler: gcc\n      before_script:\n        - sudo add-apt-repository 'ppa:ubuntu-toolchain-r/test' -y\n        - sudo apt-get update\n        - sudo apt-get install gcc-9 gfortran-9 -y\n      script:\n        - travis_wait 50 make QUIET_MAKE=1  BINARY=64 USE_OPENMP=1 CC=gcc-9 FC=gfortran-9\n        - make -C test $COMMON_FLAGS $BTYPE\n        - make -C ctest $COMMON_FLAGS $BTYPE\n        - make -C utest $COMMON_FLAGS $BTYPE \n      env:\n        # for matrix annotation only\n        - TARGET_BOX=PPC64LE_LINUX_P9\n\n    - os: linux\n      arch: ppc64le\n      dist: bionic\n      compiler: gcc\n      before_script:\n        - sudo add-apt-repository 'ppa:ubuntu-toolchain-r/test' -y\n        - sudo apt-get update\n        - sudo apt-get install gcc-9 gfortran-9 -y\n      script:\n        - travis_wait 50 make QUIET_MAKE=1  BUILD_BFLOAT16=1 BINARY=64 USE_OPENMP=1 CC=gcc-9 FC=gfortran-9\n        - make -C test $COMMON_FLAGS $BTYPE\n        - make -C ctest $COMMON_FLAGS $BTYPE\n        - make -C utest $COMMON_FLAGS $BTYPE \n      env:\n        # for matrix annotation only\n        - TARGET_BOX=PPC64LE_LINUX_P9\n\n#    - os: linux\n#      compiler: gcc\n#      addons:\n#        apt:\n#          packages:\n#            - binutils-mingw-w64-x86-64\n#            - gcc-mingw-w64-x86-64\n#            - gfortran-mingw-w64-x86-64\n#      before_script: *common-before\n#      script:\n#        - travis_wait 45 make QUIET_MAKE=1 $COMMON_FLAGS $BTYPE\n#      env:\n#        - TARGET_BOX=WIN64\n#        - BTYPE=\"BINARY=64 HOSTCC=gcc CC=x86_64-w64-mingw32-gcc FC=x86_64-w64-mingw32-gfortran\"\n#\n    # Build & test on Alpine Linux inside chroot, i.e. on system with musl libc.\n    # These jobs needs sudo, so Travis runs them on VM-based infrastructure\n    # which is slower than container-based infrastructure used for jobs\n    # that don't require sudo.\n #   - &test-alpine\n #     os: linux\n #     dist: trusty\n #     sudo: true\n #     language: minimal\n #     before_install:\n #       - \"wget 'https://raw.githubusercontent.com/alpinelinux/alpine-chroot-install/v0.9.0/alpine-chroot-install' \\\n #         && echo 'e5dfbbdc0c4b3363b99334510976c86bfa6cb251  alpine-chroot-install' | sha1sum -c || exit 1\"\n #       - alpine() { /alpine/enter-chroot -u \"$USER\" \"$@\"; }\n #     install:\n #       - sudo sh alpine-chroot-install -p 'build-base gfortran perl linux-headers'\n #     before_script: *common-before\n #     script:\n #       # XXX: Disable some warnings for now to avoid exceeding Travis limit for log size.\n #       - alpine make QUIET_MAKE=1 $COMMON_FLAGS $BTYPE\n #             CFLAGS=\"-Wno-misleading-indentation -Wno-sign-conversion -Wno-incompatible-pointer-types\"\n #       - alpine make -C test $COMMON_FLAGS $BTYPE\n #       - alpine make -C ctest $COMMON_FLAGS $BTYPE\n #       - alpine make -C utest $COMMON_FLAGS $BTYPE\n #     env:\n #       - TARGET_BOX=LINUX64_MUSL\n #       - BTYPE=\"BINARY=64\"\n\n    # XXX: This job segfaults in TESTS OF THE COMPLEX LEVEL 3 BLAS,\n    # but only on Travis CI, cannot reproduce it elsewhere.\n    #- &test-alpine-openmp\n    #  <<: *test-alpine\n    #  env:\n    #    - TARGET_BOX=LINUX64_MUSL\n    #    - BTYPE=\"BINARY=64 USE_OPENMP=1\"\n\n#    - <<: *test-alpine\n#      env:\n#        - TARGET_BOX=LINUX64_MUSL\n#        - BTYPE=\"BINARY=64 INTERFACE64=1\"\n#\n#    # Build with the same flags as Alpine do in OpenBLAS package.\n#    - <<: *test-alpine\n#      env:\n#        - TARGET_BOX=LINUX64_MUSL\n#        - BTYPE=\"BINARY=64 NO_AFFINITY=1 USE_OPENMP=0 NO_LAPACK=0 TARGET=CORE2\"\n\n#    - &test-cmake\n#      os: linux\n#      compiler: clang\n#      addons:\n#        apt:\n#          packages:\n#            - gfortran\n#            - cmake\n#      dist: trusty\n#      sudo: true\n#      before_script:\n#        - COMMON_ARGS=\"-DTARGET=NEHALEM -DNUM_THREADS=32\"\n#      script:\n#        - mkdir build\n#        - CONFIG=Release\n#        - cmake -Bbuild -H. $CMAKE_ARGS $COMMON_ARGS -DCMAKE_BUILD_TYPE=$CONFIG\n#        - cmake --build build --config $CONFIG -- -j2\n#      env:\n#        - CMAKE=1\n#    - <<: *test-cmake\n#      env:\n#        - CMAKE=1 CMAKE_ARGS=\"-DNOFORTRAN=1\"\n#    - <<: *test-cmake\n#      compiler: gcc\n#      env:\n#        - CMAKE=1\n\n#    - &test-macos\n#      os: osx\n#      osx_image: xcode11.5\n#      before_script:\n#        - COMMON_FLAGS=\"DYNAMIC_ARCH=1 NUM_THREADS=32\"\n#      script:\n#        - travis_wait 45 make QUIET_MAKE=1 $COMMON_FLAGS $BTYPE\n#      env:\n#        - BTYPE=\"TARGET=NEHALEM BINARY=64 INTERFACE64=1 FC=gfortran-9\"\n#\n#    - <<: *test-macos\n#      osx_image: xcode12\n#      before_script:\n#        - COMMON_FLAGS=\"DYNAMIC_ARCH=1 NUM_THREADS=32\"\n#        - brew update\n#      script:\n#        - travis_wait 45 make QUIET_MAKE=1 $COMMON_FLAGS $BTYPE\n#      env:\n#        - BTYPE=\"TARGET=HASWELL USE_OPENMP=1 BINARY=64 INTERFACE64=1 CC=gcc-10 FC=gfortran-10\"\n#\n#    - <<: *test-macos\n#      osx_image: xcode12\n#      before_script:\n#        - COMMON_FLAGS=\"DYNAMIC_ARCH=1 NUM_THREADS=32\"\n#        - brew update\n#      script:\n#        - travis_wait 45 make QUIET_MAKE=1 $COMMON_FLAGS $BTYPE\n#      env:\n#        - BTYPE=\"TARGET=NEHALEM BINARY=64 INTERFACE64=1 FC=gfortran-10\"      \n\n  #  - <<: *test-macos\n  #    osx_image: xcode10\n  #    env:\n  #      - BTYPE=\"TARGET=NEHALEM BINARY=32 NOFORTRAN=1\"\n\n#    - <<: *test-macos\n#      osx_image: xcode11.5\n#      before_script:\n#        - COMMON_FLAGS=\"DYNAMIC_ARCH=1 NUM_THREADS=32\"\n#        - brew update\n#      env:\n#        - CC=\"/Applications/Xcode-10.1.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang\"\n#        - CFLAGS=\"-O2 -Wno-macro-redefined -isysroot /Applications/Xcode-10.1.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS12.1.sdk -arch arm64 -miphoneos-version-min=10.0\"\n#        - CC=\"/Applications/Xcode-11.5.GM.Seed.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang\"\n#        - CFLAGS=\"-O2 -Wno-macro-redefined -isysroot /Applications/Xcode-11.5.GM.Seed.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk -arch arm64 -miphoneos-version-min=10.0\"\n#        - BTYPE=\"TARGET=ARMV8 BINARY=64 HOSTCC=clang NOFORTRAN=1\"\n#    - <<: *test-macos\n#      osx_image: xcode11.5\n#      env:\n##        - CC=\"/Applications/Xcode-10.1.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang\"\n##        - CFLAGS=\"-O2 -mno-thumb -Wno-macro-redefined -isysroot /Applications/Xcode-10.1.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS12.1.sdk -arch armv7 -miphoneos-version-min=5.1\"\n#        - CC=\"/Applications/Xcode-11.5.GM.Seed.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang\"\n#        - CFLAGS=\"-O2 -mno-thumb -Wno-macro-redefined -isysroot /Applications/Xcode-11.5.GM.Seed.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk -arch armv7 -miphoneos-version-min=5.1\"\n#        - BTYPE=\"TARGET=ARMV7 HOSTCC=clang NOFORTRAN=1\"\n\n    - &test-neoversen1\n      os: linux\n      arch: arm64\n      dist: focal\n      group: edge\n      virt: lxd\n      compiler: gcc\n      addons:\n        apt:\n          packages:\n            - gfortran\n      script:\n        - travis_wait 45 make && make lapack-test\n      env:\n        - TARGET_BOX=NEOVERSE_N1 \n  \n    - &test-neon1-gcc8\n      os: linux\n      arch: arm64\n      dist: focal\n      group: edge\n      virt: lxd\n      compiler: gcc\n      addons:\n        apt:\n          packages:\n            - gcc-8\n            - gfortran-8\n      script:\n        - travis_wait 45 make QUIET_MAKE=1 CC=gcc-8 FC=gfortran-8 DYNAMIC_ARCH=1 \n      env:\n        - TARGET_BOX=NEOVERSE_N1-GCC8\n        \n# whitelist\nbranches:\n  only:\n    - master\n    - develop\n\nnotifications:\n  webhooks:\n    urls:\n      - https://webhooks.gitter.im/e/8a6e4470a0cebd090344\n    on_success: change  # options: [always|never|change] default: always\n    on_failure: always  # options: [always|never|change] default: always\n    on_start: never     # options: [always|never|change] default: always\n"
        },
        {
          "name": "BACKERS.md",
          "type": "blob",
          "size": 1.0556640625,
          "content": "Thank you for the support.\n\n### [2019.12/2021.9] [Chan-Zuckerberg Foundation EOSS Initiative](https://chanzuckerberg.com/eoss/)\n\nBetween December 2019 and September 2021, development and maintaining of OpenBLAS was funded in part by the Chan-Zuckerberg Foundation in the context of  two grants awarded to the NumPy Foundation and managed by NumFocus (Cycles 1 and 3 of the Essential Open Source Software for Science (EOSS) Initiative of the Chan-Zuckerberg Foundation)  \n\n### [2013.8] [Testbed for OpenBLAS project](https://www.bountysource.com/fundraisers/443-testbed-for-openblas-project)\n\nhttps://www.bountysource.com/fundraisers/443-testbed-for-openblas-project/pledges\n\nIn chronological order:\n\n* aeberspaecher\n* fmolina\n* saullocastro\n* xianyi\n* cuda\n* carter\n* StefanKarpinski\n* staticfloat\n* sebastien-villemot\n* JeffBezanson\n* ihnorton\n* simonp0420\n* andrioni\n* Tim Holy\n* ivarne\n* johnmyleswhite\n* traz\n* Jean-Francis Roy\n* bkalpert\n* Anirban\n* pgermain\n* alexandre.lacoste.18\n* foges\n* ssam\n* WestleyArgentum\n* daniebmariani\n* pjpuglia\n* albarrentine\n* Alexander Vogt\n\n\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 24.6220703125,
          "content": "##\n## Author: Hank Anderson <hank@statease.com>\n##\n\ncmake_minimum_required(VERSION 3.16.0)\n\nset (CMAKE_ASM_SOURCE_FILE_EXTENSIONS \"S\")\nproject(OpenBLAS C ASM)\n\nset(OpenBLAS_MAJOR_VERSION 0)\nset(OpenBLAS_MINOR_VERSION 3)\nset(OpenBLAS_PATCH_VERSION 29.dev)\n\nset(OpenBLAS_VERSION \"${OpenBLAS_MAJOR_VERSION}.${OpenBLAS_MINOR_VERSION}.${OpenBLAS_PATCH_VERSION}\")\n\n# Adhere to GNU filesystem layout conventions\ninclude(GNUInstallDirs)\n\ninclude(CMakePackageConfigHelpers)\n\n#######\noption(BUILD_WITHOUT_LAPACK \"Do not build LAPACK and LAPACKE (Only BLAS or CBLAS)\" OFF)\n\noption(BUILD_LAPACK_DEPRECATED \"When building LAPACK, include also some older, deprecated routines\" ON)\n\nset(LAPACK_STRLEN \"\" CACHE STRING \"When building LAPACK, use this type (e.g. \\\"int\\\") for character lengths (defaults to size_t)\")\n\noption(BUILD_TESTING \"Build LAPACK testsuite when building LAPACK\" ON)\n\noption(BUILD_BENCHMARKS \"Build the collection of BLAS/LAPACK benchmarks\" OFF)\n\noption(C_LAPACK \"Build LAPACK from C sources instead of the original Fortran\" OFF)\n\noption(BUILD_WITHOUT_CBLAS \"Do not build the C interface (CBLAS) to the BLAS functions\" OFF)\n\noption(DYNAMIC_ARCH \"Include support for multiple CPU targets, with automatic selection at runtime (x86/x86_64, aarch64, ppc or RISCV64-RVV1.0 only)\" OFF)\n\noption(DYNAMIC_OLDER \"Include specific support for older x86 cpu models (Penryn,Dunnington,Atom,Nano,Opteron) with DYNAMIC_ARCH\" OFF)\n\noption(BUILD_RELAPACK \"Build with ReLAPACK (recursive implementation of several LAPACK functions on top of standard LAPACK)\" OFF)\n\noption(USE_LOCKING \"Use locks even in single-threaded builds to make them callable from multiple threads\" OFF)\n\noption(USE_PERL \"Use the older PERL scripts for build preparation instead of universal shell scripts\" OFF)\n\noption(NO_WARMUP \"Do not run a benchmark on each startup just to find the best location for the memory buffer\" ON)\n\noption(FIXED_LIBNAME \"Use a non-versioned name for the library and no symbolic linking to variant names\" OFF)\n\nset(LIBNAMEPREFIX \"\" CACHE STRING  \"Add a prefix to the openblas part of the library name\" )\nset(LIBNAMESUFFIX \"\" CACHE STRING  \"Add a suffix after the openblas part of the library name\" )\n\nif(${CMAKE_SYSTEM_NAME} MATCHES \"Linux\")\n  option(NO_AFFINITY \"Disable support for CPU affinity masks to avoid binding processes from e.g. R or numpy/scipy to a single core\" ON)\nelse()\n  set(NO_AFFINITY 1)\nendif()\n\noption(CPP_THREAD_SAFETY_TEST \"Run a massively parallel DGEMM test to confirm thread safety of the library (requires OpenMP and about 1.3GB of RAM)\" OFF)\n\noption(CPP_THREAD_SAFETY_GEMV \"Run a massively parallel DGEMV test to confirm thread safety of the library (requires OpenMP)\" OFF)\noption(BUILD_STATIC_LIBS \"Build static library\" OFF)\nif(NOT BUILD_STATIC_LIBS AND NOT BUILD_SHARED_LIBS)\n  set(BUILD_STATIC_LIBS ON CACHE BOOL \"Build static library\" FORCE)\nendif()\nif((BUILD_STATIC_LIBS AND BUILD_SHARED_LIBS) AND MSVC)\n  message(WARNING \"Could not enable both BUILD_STATIC_LIBS and BUILD_SHARED_LIBS with MSVC, Disable BUILD_SHARED_LIBS\")\n  set(BUILD_SHARED_LIBS OFF CACHE BOOL \"Build static library\" FORCE)\nendif()\n\n# Add a prefix or suffix to all exported symbol names in the shared library.\n# Avoids conflicts with other BLAS libraries, especially when using\n# 64 bit integer interfaces in OpenBLAS.\nset(SYMBOLPREFIX \"\" CACHE STRING  \"Add a prefix to all exported symbol names in the shared library to avoid conflicts with other BLAS libraries\" )\n\nset(SYMBOLSUFFIX \"\" CACHE STRING  \"Add a suffix to all exported symbol names in the shared library, e.g. _64 for INTERFACE64 builds\" )\n\n#######\nif(BUILD_WITHOUT_LAPACK)\n  set(NO_LAPACK 1)\n  set(NO_LAPACKE 1)\nendif()\n\nif(BUILD_WITHOUT_CBLAS)\n  set(NO_CBLAS 1)\nendif()\n\n#######\n\nif(MSVC AND MSVC_STATIC_CRT)\n  set(CompilerFlags\n        CMAKE_CXX_FLAGS\n        CMAKE_CXX_FLAGS_DEBUG\n        CMAKE_CXX_FLAGS_RELEASE\n        CMAKE_C_FLAGS\n        CMAKE_C_FLAGS_DEBUG\n        CMAKE_C_FLAGS_RELEASE\n        )\n  foreach(CompilerFlag ${CompilerFlags})\n    string(REPLACE \"/MD\" \"/MT\" ${CompilerFlag} \"${${CompilerFlag}}\")\n  endforeach()\nendif()\n\nmessage(WARNING \"CMake support is experimental. It does not yet support all build options and may not produce the same Makefiles that OpenBLAS ships with.\")\n\nif (USE_OPENMP)\n  find_package(OpenMP REQUIRED)\nendif ()\n\ninclude(\"${PROJECT_SOURCE_DIR}/cmake/utils.cmake\")\ninclude(\"${PROJECT_SOURCE_DIR}/cmake/system.cmake\")\n\nset(OpenBLAS_LIBNAME ${LIBNAMEPREFIX}openblas${LIBNAMESUFFIX}${SUFFIX64_UNDERSCORE})\n\nset(BLASDIRS interface driver/level2 driver/level3 driver/others)\n\nif (NOT DYNAMIC_ARCH)\n  list(APPEND BLASDIRS kernel)\nendif ()\n\nif (DEFINED SANITY_CHECK)\n  list(APPEND BLASDIRS reference)\nendif ()\n\nset(SUBDIRS\t${BLASDIRS})\nif (NOT NO_LAPACK)\n  if(BUILD_RELAPACK)\n    list(APPEND SUBDIRS relapack/src)\n  endif()\n  list(APPEND SUBDIRS lapack)\nendif ()\n\nif (NOT DEFINED BUILD_BFLOAT16)\n set (BUILD_BFLOAT16 false)\nendif ()\n# set which float types we want to build for\nif (NOT DEFINED BUILD_SINGLE AND NOT DEFINED BUILD_DOUBLE AND NOT DEFINED BUILD_COMPLEX AND NOT DEFINED BUILD_COMPLEX16)\n  # if none are defined, build for all\n  # set(BUILD_BFLOAT16 true)\n  set(BUILD_SINGLE true)\n  set(BUILD_DOUBLE true)\n  set(BUILD_COMPLEX true)\n  set(BUILD_COMPLEX16 true)\nendif ()\n\nif (NOT DEFINED BUILD_MATGEN)\n  set(BUILD_MATGEN true)\nendif()\n\nset(FLOAT_TYPES \"\")\nif (BUILD_SINGLE)\n  message(STATUS \"Building Single Precision\")\n  list(APPEND FLOAT_TYPES \"SINGLE\") # defines nothing\nendif ()\n\nif (BUILD_DOUBLE)\n  message(STATUS \"Building Double Precision\")\n  list(APPEND FLOAT_TYPES \"DOUBLE\") # defines DOUBLE\nendif ()\n\nif (BUILD_COMPLEX)\n  message(STATUS \"Building Complex Precision\")\n  list(APPEND FLOAT_TYPES \"COMPLEX\") # defines COMPLEX\nendif ()\n\nif (BUILD_COMPLEX16)\n  message(STATUS \"Building Double Complex Precision\")\n  list(APPEND FLOAT_TYPES \"ZCOMPLEX\") # defines COMPLEX and DOUBLE\nendif ()\n\nif (BUILD_BFLOAT16)\n  message(STATUS \"Building Half Precision\")\n  #  list(APPEND FLOAT_TYPES \"BFLOAT16\") # defines nothing\nendif ()\n\nif (NOT DEFINED CORE OR \"${CORE}\" STREQUAL \"UNKNOWN\")\n  message(FATAL_ERROR \"Detecting CPU failed. Please set TARGET explicitly, e.g. make TARGET=your_cpu_target. Please read README for details.\")\nendif ()\n\n#Set default output directory\nset( CMAKE_LIBRARY_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/lib)\nset( CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/lib)\nif(MSVC)\n  set( CMAKE_LIBRARY_OUTPUT_DIRECTORY_DEBUG ${PROJECT_BINARY_DIR}/lib/Debug)\n  set( CMAKE_ARCHIVE_OUTPUT_DIRECTORY_RELEASE ${PROJECT_BINARY_DIR}/lib/Release)\nendif ()\n\n# get obj vars into format that add_library likes: $<TARGET_OBJS:objlib> (see http://www.cmake.org/cmake/help/v3.0/command/add_library.html)\nset(TARGET_OBJS \"\")\nforeach (SUBDIR ${SUBDIRS})\n  add_subdirectory(${SUBDIR})\n  string(REPLACE \"/\" \"_\" subdir_obj ${SUBDIR})\n  list(APPEND TARGET_OBJS \"$<TARGET_OBJECTS:${subdir_obj}>\")\nendforeach ()\n\n# netlib:\n\n# Can't just use lapack-netlib's CMake files, since they are set up to search for BLAS, build and install a binary. We just want to build a couple of lib files out of lapack and lapacke.\n# Not using add_subdirectory here because lapack-netlib already has its own CMakeLists.txt. Instead include a cmake script with the sources we want.\nif (NOT NO_LAPACK)\n  include(\"${PROJECT_SOURCE_DIR}/cmake/lapack.cmake\")\n  if (NOT NO_LAPACKE)\n    include(\"${PROJECT_SOURCE_DIR}/cmake/lapacke.cmake\")\n  endif ()\nendif ()\n\n# Only generate .def for dll on MSVC and always produce pdb files for debug and release\nif(MSVC)\n  if (${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION} VERSION_LESS 3.4)\n    set(OpenBLAS_DEF_FILE \"${PROJECT_BINARY_DIR}/openblas.def\")\n  endif()\n  set(CMAKE_C_FLAGS_RELEASE \"${CMAKE_C_FLAGS_RELEASE} /Zi\")\n  set(CMAKE_SHARED_LINKER_FLAGS_RELEASE \"${CMAKE_SHARED_LINKER_FLAGS_RELEASE} /DEBUG /OPT:REF /OPT:ICF\")\nendif()\n\nif (${DYNAMIC_ARCH})\n  add_subdirectory(kernel)\n  foreach(TARGET_CORE ${DYNAMIC_CORE})\n    message(\"${TARGET_CORE}\")\n    list(APPEND TARGET_OBJS \"$<TARGET_OBJECTS:kernel_${TARGET_CORE}>\")\n  endforeach()\nendif ()\n\n# add objects to the openblas lib\nif(NOT NO_LAPACK)\n  add_library(LAPACK_OVERRIDES OBJECT ${LA_SOURCES})\n  list(APPEND TARGET_OBJS \"$<TARGET_OBJECTS:LAPACK_OVERRIDES>\")\nendif()\nif(NOT NO_LAPACKE)\n  add_library(LAPACKE OBJECT ${LAPACKE_SOURCES})\n  list(APPEND TARGET_OBJS \"$<TARGET_OBJECTS:LAPACKE>\")\nendif()\n#if(BUILD_RELAPACK)\n#  add_library(RELAPACK OBJECT ${RELA_SOURCES})\n#  list(APPEND TARGET_OBJS \"$<TARGET_OBJECTS:RELAPACK>\")\n#endif()\nset(OpenBLAS_LIBS \"\")\nif(BUILD_STATIC_LIBS)\n  add_library(${OpenBLAS_LIBNAME}_static STATIC ${TARGET_OBJS} ${OpenBLAS_DEF_FILE})\n  target_include_directories(${OpenBLAS_LIBNAME}_static INTERFACE $<INSTALL_INTERFACE:include/openblas${SUFFIX64}>)\n  list(APPEND OpenBLAS_LIBS ${OpenBLAS_LIBNAME}_static)\nendif()\nif(BUILD_SHARED_LIBS)\n  add_library(${OpenBLAS_LIBNAME}_shared SHARED ${TARGET_OBJS} ${OpenBLAS_DEF_FILE})\n  target_include_directories(${OpenBLAS_LIBNAME}_shared INTERFACE $<INSTALL_INTERFACE:include/openblas${SUFFIX64}>)\n  list(APPEND OpenBLAS_LIBS ${OpenBLAS_LIBNAME}_shared)\nendif()\nif(BUILD_STATIC_LIBS)\n  add_library(${OpenBLAS_LIBNAME} ALIAS ${OpenBLAS_LIBNAME}_static)\nelse()\n  add_library(${OpenBLAS_LIBNAME} ALIAS ${OpenBLAS_LIBNAME}_shared)\nendif()\n\nset_target_properties(${OpenBLAS_LIBS} PROPERTIES OUTPUT_NAME ${OpenBLAS_LIBNAME})\n\n# Android needs to explicitly link against libm\nif (${CMAKE_SYSTEM_NAME} MATCHES \"AIX|Android|Linux|FreeBSD|OpenBSD|NetBSD|DragonFly|Darwin\")\n  if(BUILD_STATIC_LIBS)\n    target_link_libraries(${OpenBLAS_LIBNAME}_static m)\n  endif()\n  if(BUILD_SHARED_LIBS)\n    target_link_libraries(${OpenBLAS_LIBNAME}_shared m)\n  endif()\nendif()\n\nif (USE_OPENMP)\n  if(BUILD_STATIC_LIBS)\n    target_link_libraries(${OpenBLAS_LIBNAME}_static OpenMP::OpenMP_C)\n  endif()\n  if(BUILD_SHARED_LIBS)\n    target_link_libraries(${OpenBLAS_LIBNAME}_shared OpenMP::OpenMP_C)\n  endif()\nendif()\n\n# Seems that this hack doesn't required since macOS 11 Big Sur\nif (APPLE AND BUILD_SHARED_LIBS AND CMAKE_HOST_SYSTEM_VERSION VERSION_LESS 20)\n  set (CMAKE_C_USE_RESPONSE_FILE_FOR_OBJECTS 1)\n  if (NOT NOFORTRAN)\n  set (CMAKE_Fortran_USE_RESPONSE_FILE_FOR_OBJECTS 1)\n  set (CMAKE_Fortran_CREATE_SHARED_LIBRARY\n \"sh -c 'cat ${CMAKE_BINARY_DIR}/CMakeFiles/openblas_shared.dir/objects*.rsp | xargs -n 1024 ${CMAKE_AR} -ru libopenblas.a && exit 0' \"\n \"sh -c '${CMAKE_AR} -rs libopenblas.a ${CMAKE_BINARY_DIR}/driver/others/CMakeFiles/driver_others.dir/xerbla.c.o && exit 0' \"\n \"sh -c 'echo \\\"\\\" | ${CMAKE_Fortran_COMPILER} -o dummy.o -c -x f95-cpp-input - '\"\n \"sh -c '${CMAKE_Fortran_COMPILER} -fpic -shared -Wl,-all_load -Wl,-force_load,libopenblas.a -Wl,-noall_load dummy.o -o ${CMAKE_LIBRARY_OUTPUT_DIRECTORY}/libopenblas.${OpenBLAS_MAJOR_VERSION}.${OpenBLAS_MINOR_VERSION}.dylib'\"\n \"sh -c 'ls -l ${CMAKE_BINARY_DIR}/lib'\")\n  else ()\n  set (CMAKE_C_CREATE_SHARED_LIBRARY\n   \"sh -c 'cat ${CMAKE_BINARY_DIR}/CMakeFiles/openblas_shared.dir/objects*.rsp | xargs -n 1024 ${CMAKE_AR} -ru libopenblas.a && exit 0' \"\n   \"sh -c '${CMAKE_AR} -rs libopenblas.a ${CMAKE_BINARY_DIR}/driver/others/CMakeFiles/driver_others.dir/xerbla.c.o && exit 0' \"\n   \"sh -c '${CMAKE_C_COMPILER} -fpic -shared -Wl,-all_load -Wl,-force_load,libopenblas.a -Wl,-noall_load -o ${CMAKE_LIBRARY_OUTPUT_DIRECTORY}/libopenblas.${OpenBLAS_MAJOR_VERSION}.${OpenBLAS_MINOR_VERSION}.dylib'\")\n  endif ()\nendif()\n\n# Handle MSVC exports\nif(MSVC AND BUILD_SHARED_LIBS)\n  if (${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION} VERSION_LESS 3.4)\n    include(\"${PROJECT_SOURCE_DIR}/cmake/export.cmake\")\n  else()\n    # Creates verbose .def file (51KB vs 18KB)\n    set_target_properties(${OpenBLAS_LIBNAME}_shared PROPERTIES WINDOWS_EXPORT_ALL_SYMBOLS true)\n  endif()\nendif()\n\n# Set output for libopenblas\nset_target_properties( ${OpenBLAS_LIBS} PROPERTIES RUNTIME_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/lib)\nset_target_properties( ${OpenBLAS_LIBS} PROPERTIES LIBRARY_OUTPUT_NAME_DEBUG \"${OpenBLAS_LIBNAME}_d\")\nset_target_properties( ${OpenBLAS_LIBS} PROPERTIES EXPORT_NAME \"OpenBLAS\")\n\nforeach (OUTPUTCONFIG ${CMAKE_CONFIGURATION_TYPES})\n  string( TOUPPER ${OUTPUTCONFIG} OUTPUTCONFIG )\n\n  set_target_properties( ${OpenBLAS_LIBS} PROPERTIES RUNTIME_OUTPUT_DIRECTORY_${OUTPUTCONFIG} ${PROJECT_BINARY_DIR}/lib/${OUTPUTCONFIG} )\n  set_target_properties( ${OpenBLAS_LIBS} PROPERTIES LIBRARY_OUTPUT_DIRECTORY_${OUTPUTCONFIG} ${PROJECT_BINARY_DIR}/lib/${OUTPUTCONFIG} )\n  set_target_properties( ${OpenBLAS_LIBS} PROPERTIES ARCHIVE_OUTPUT_DIRECTORY_${OUTPUTCONFIG} ${PROJECT_BINARY_DIR}/lib/${OUTPUTCONFIG} )\nendforeach()\n\nenable_testing()\n\nif (USE_THREAD)\n  # Add threading library to linker\n  find_package(Threads)\n  if (THREADS_HAVE_PTHREAD_ARG)\n    set_target_properties(${OpenBLAS_LIBS} PROPERTIES\n      COMPILE_OPTIONS \"-pthread\"\n      INTERFACE_COMPILE_OPTIONS \"-pthread\"\n    )\n  endif()\n  if(BUILD_STATIC_LIBS)\n    target_link_libraries(${OpenBLAS_LIBNAME}_static ${CMAKE_THREAD_LIBS_INIT})\n  endif()\n  if(BUILD_SHARED_LIBS)\n    target_link_libraries(${OpenBLAS_LIBNAME}_shared ${CMAKE_THREAD_LIBS_INIT})\n  endif()\nendif()\n\n#if (MSVC OR NOT NOFORTRAN)\nif (NOT NO_CBLAS)\n  if (NOT ONLY_CBLAS)\n  # Broken without fortran on unix\n    add_subdirectory(utest)\nendif()\nendif()\n\nif (NOT NOFORTRAN)\n if (NOT ONLY_CBLAS)\n  # Build test and ctest\n  add_subdirectory(test)\n endif()\n if (BUILD_TESTING AND NOT BUILD_WITHOUT_LAPACK)\n    add_subdirectory(lapack-netlib/TESTING)\n  endif()\nendif()\n  if(NOT NO_CBLAS)\n   if (NOT ONLY_CBLAS)\n    add_subdirectory(ctest)\n   endif()\n  endif()\n  if (CPP_THREAD_SAFETY_TEST OR CPP_THREAD_SAFETY_GEMV)\n    add_subdirectory(cpp_thread_test)\n  endif()\n\nif (NOT FIXED_LIBNAME)\nset_target_properties(${OpenBLAS_LIBS} PROPERTIES\n  VERSION ${OpenBLAS_MAJOR_VERSION}.${OpenBLAS_MINOR_VERSION}\n  SOVERSION ${OpenBLAS_MAJOR_VERSION}\n)\nendif()\nif (BUILD_SHARED_LIBS AND BUILD_RELAPACK)\n  if (NOT MSVC)\n    target_link_libraries(${OpenBLAS_LIBNAME}_shared \"-Wl,-allow-multiple-definition\")\n  else()\n    set(CMAKE_SHARED_LINKER_FLAGS \"${CMAKE_SHARED_LINKER_FLAGS} /FORCE:MULTIPLE\")\n  endif()\nendif()\n\nif (BUILD_SHARED_LIBS AND NOT ${SYMBOLPREFIX}${SYMBOLSUFFIX} STREQUAL \"\")\n  if (NOT DEFINED ARCH)\n    set(ARCH_IN \"x86_64\")\n  else()\n    set(ARCH_IN ${ARCH})\n  endif()\n\n  if (${CORE} STREQUAL \"generic\")\n    set(ARCH_IN \"GENERIC\")\n  endif ()\n\n  if (NOT DEFINED EXPRECISION)\n    set(EXPRECISION_IN 0)\n  else()\n    set(EXPRECISION_IN ${EXPRECISION})\n  endif()\n\n  if (NOT DEFINED NO_CBLAS)\n    set(NO_CBLAS_IN 0)\n  else()\n    set(NO_CBLAS_IN ${NO_CBLAS})\n  endif()\n\n  if (NOT DEFINED NO_LAPACK)\n    set(NO_LAPACK_IN 0)\n  else()\n    set(NO_LAPACK_IN ${NO_LAPACK})\n  endif()\n\n  if (NOT DEFINED NO_LAPACKE)\n    set(NO_LAPACKE_IN 0)\n  else()\n    set(NO_LAPACKE_IN ${NO_LAPACKE})\n  endif()\n\n  if (NOT DEFINED NEED2UNDERSCORES)\n    set(NEED2UNDERSCORES_IN 0)\n  else()\n    set(NEED2UNDERSCORES_IN ${NEED2UNDERSCORES})\n  endif()\n\n  if (NOT DEFINED ONLY_CBLAS)\n    set(ONLY_CBLAS_IN 0)\n  else()\n    set(ONLY_CBLAS_IN ${ONLY_CBLAS})\n  endif()\n\n  if (NOT DEFINED BU)\n    set(BU _)\n  endif()\n\n  if (NOT ${SYMBOLPREFIX} STREQUAL \"\")\n    message(STATUS \"adding prefix ${SYMBOLPREFIX} to names of exported symbols in ${OpenBLAS_LIBNAME}\")\n  endif()\n  if (NOT ${SYMBOLSUFFIX} STREQUAL \"\")\n    message(STATUS \"adding suffix ${SYMBOLSUFFIX} to names of exported symbols in ${OpenBLAS_LIBNAME}\")\n  endif()\n\n  if (${BUILD_LAPACK_DEPRECATED})\n\t  set (BLD 1)\n  else ()\n\t  set (BLD 0)\n  endif()\n  if (${BUILD_BFLOAT16})\n\t  set (BBF16 1)\n  else ()\n\t  set (BBF16 0)\n  endif()\n  if (${BUILD_SINGLE})\n\t  set (BS 1)\n  else ()\n\t  set (BS 0)\n  endif()\n  if (${BUILD_DOUBLE})\n\t  set (BD 1)\n  else ()\n\t  set (BD 0)\n  endif()\n  if (${BUILD_COMPLEX})\n\t  set (BC 1)\n  else ()\n\t  set (BC 0)\n  endif()\n  if (${BUILD_COMPLEX16})\n\t  set (BZ 1)\n  else ()\n\t  set (BZ 0)\n  endif()\n  if (NOT USE_PERL)\n  add_custom_command(TARGET ${OpenBLAS_LIBNAME}_shared POST_BUILD\n\t  COMMAND  ${PROJECT_SOURCE_DIR}/exports/gensymbol \"objcopy\" \"${ARCH}\" \"${BU}\" \"${EXPRECISION_IN}\" \"${NO_CBLAS_IN}\" \"${NO_LAPACK_IN}\" \"${NO_LAPACKE_IN}\" \"${NEED2UNDERSCORES_IN}\" \"${ONLY_CBLAS_IN}\" \\\"${SYMBOLPREFIX}\\\" \\\"${SYMBOLSUFFIX}\\\" \"${BLD}\" \"${BBF16}\" \"${BS}\" \"${BD}\" \"${BC}\" \"${BZ}\" > ${PROJECT_BINARY_DIR}/objcopy.def\n    COMMAND objcopy -v --redefine-syms ${PROJECT_BINARY_DIR}/objcopy.def  ${PROJECT_BINARY_DIR}/lib/lib${OpenBLAS_LIBNAME}.so\n    COMMENT \"renaming symbols\"\n    )\n  else()\n  add_custom_command(TARGET ${OpenBLAS_LIBNAME}_shared POST_BUILD\n    COMMAND perl ${PROJECT_SOURCE_DIR}/exports/gensymbol.pl \"objcopy\" \"${ARCH}\" \"${BU}\" \"${EXPRECISION_IN}\" \"${NO_CBLAS_IN}\" \"${NO_LAPACK_IN}\" \"${NO_LAPACKE_IN}\" \"${NEED2UNDERSCORES_IN}\" \"${ONLY_CBLAS_IN}\" \\\"${SYMBOLPREFIX}\\\" \\\"${SYMBOLSUFFIX}\\\" \"${BLD}\" \"${BBF16}\" \"${BS}\" \"${BD}\" \"${BC}\" \"${BZ}\" > ${PROJECT_BINARY_DIR}/objcopy.def\n    COMMAND objcopy -v --redefine-syms ${PROJECT_BINARY_DIR}/objcopy.def  ${PROJECT_BINARY_DIR}/lib/lib${OpenBLAS_LIBNAME}.so\n    COMMENT \"renaming symbols\"\n    )\n  endif()\nendif()\n\nif (BUILD_BENCHMARKS)\n\t#find_package(OpenMP REQUIRED)\n  file(GLOB SOURCES \"benchmark/*.c\")\n  if (NOT USE_OPENMP)\n  file(GLOB REMFILE \"benchmark/smallscaling.c\")\n  list(REMOVE_ITEM SOURCES ${REMFILE})\n  endif()\n  if (BUILD_WITHOUT_LAPACK)\n  file(GLOB REMFILE \"benchmark/cholesky.c\")\n  list(REMOVE_ITEM SOURCES ${REMFILE})\n  file(GLOB REMFILE \"benchmark/geev.c\")\n  list(REMOVE_ITEM SOURCES ${REMFILE})\n  file(GLOB REMFILE \"benchmark/gesv.c\")\n  list(REMOVE_ITEM SOURCES ${REMFILE})\n  file(GLOB REMFILE \"benchmark/getri.c\")\n  list(REMOVE_ITEM SOURCES ${REMFILE})\n  file(GLOB REMFILE \"benchmark/potrf.c\")\n  list(REMOVE_ITEM SOURCES ${REMFILE})\n  file(GLOB REMFILE \"benchmark/spmv.c\")\n  list(REMOVE_ITEM SOURCES ${REMFILE})\n  file(GLOB REMFILE \"benchmark/symv.c\")\n  list(REMOVE_ITEM SOURCES ${REMFILE})\n  file(GLOB REMFILE \"benchmark/linpack.c\")\n  list(REMOVE_ITEM SOURCES ${REMFILE})\n  endif()\n  if (NOT USE_GEMM3M)\n  file(GLOB REMFILE \"benchmark/gemm3m.c\")\n  list(REMOVE_ITEM SOURCES ${REMFILE})\n  endif()\n  foreach(source ${SOURCES})\n    get_filename_component(name ${source} NAME_WE)\n    if ((NOT ${name} STREQUAL \"zdot-intel\") AND (NOT ${name} STREQUAL \"cula_wrapper\"))\n        set(defines DEFAULT COMPLEX DOUBLE \"COMPLEX\\;DOUBLE\")\n      foreach(define ${defines})\n        set(target_name \"benchmark_${name}\")\n        if (NOT \"${define}\" STREQUAL \"DEFAULT\")\n          string(JOIN \"_\" define_str ${define})\n          set(target_name \"${target_name}_${define_str}\")\n        endif()\n        if ((NOT ${target_name} STREQUAL \"benchmark_imax_COMPLEX\") AND (NOT ${target_name} STREQUAL \"benchmark_imax_COMPLEX_DOUBLE\") AND\n            (NOT ${target_name} STREQUAL \"benchmark_imin_COMPLEX\") AND (NOT ${target_name} STREQUAL \"benchmark_imin_COMPLEX_DOUBLE\") AND\n            (NOT ${target_name} STREQUAL \"benchmark_max_COMPLEX\") AND (NOT ${target_name} STREQUAL \"benchmark_max_COMPLEX_DOUBLE\") AND\n            (NOT ${target_name} STREQUAL \"benchmark_min_COMPLEX\") AND (NOT ${target_name} STREQUAL \"benchmark_min_COMPLEX_DOUBLE\"))\n          add_executable(${target_name} ${source})\n          target_include_directories(${target_name} PRIVATE ${CMAKE_CURRENT_SOURCE_DIR} ${CMAKE_CURRENT_BINARY_DIR})\n\t    target_link_libraries(${target_name} ${OpenBLAS_LIBNAME} )\n\t  #  target_link_libraries(${target_name} ${OpenBLAS_LIBNAME} OpenMP::OpenMP_C)\n          if (NOT \"${define}\" STREQUAL \"DEFAULT\")\n            target_compile_definitions(${target_name} PRIVATE ${define})\n          endif()\n        endif()\n      endforeach()\n    endif()\n  endforeach()\nendif()\n\n\n# Install project\n\n# Install libraries\nif(BUILD_SHARED_LIBS AND BUILD_STATIC_LIBS)\n  install(TARGETS ${OpenBLAS_LIBNAME}_shared\n    EXPORT \"OpenBLAS${SUFFIX64}Targets\"\n    RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}\n    ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}\n    LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR} )\n  install(TARGETS ${OpenBLAS_LIBNAME}_static\n    ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}\n    LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR} )\nelse()\n  install(TARGETS ${OpenBLAS_LIBS}\n    EXPORT \"OpenBLAS${SUFFIX64}Targets\"\n    RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}\n    ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}\n    LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR} )\nendif()\n\n# Install headers\nset(CMAKE_INSTALL_INCLUDEDIR ${CMAKE_INSTALL_INCLUDEDIR}/openblas${SUFFIX64})\nset(CMAKE_INSTALL_FULL_INCLUDEDIR ${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_INCLUDEDIR})\n\nmessage(STATUS \"Generating openblas_config.h in ${CMAKE_INSTALL_INCLUDEDIR}\")\n\nset(OPENBLAS_CONFIG_H ${CMAKE_BINARY_DIR}/openblas_config.h)\nfile(WRITE  ${OPENBLAS_CONFIG_H} \"#ifndef OPENBLAS_CONFIG_H\\n\")\nfile(APPEND ${OPENBLAS_CONFIG_H} \"#define OPENBLAS_CONFIG_H\\n\")\nfile(STRINGS ${PROJECT_BINARY_DIR}/config.h __lines)\nforeach(line ${__lines})\n  string(REPLACE \"#define \" \"\" line ${line})\n  file(APPEND ${OPENBLAS_CONFIG_H} \"#define OPENBLAS_${line}\\n\")\nendforeach()\nfile(APPEND ${OPENBLAS_CONFIG_H} \"#define OPENBLAS_VERSION \\\"OpenBLAS ${OpenBLAS_VERSION}\\\"\\n\")\nfile(READ   ${CMAKE_CURRENT_SOURCE_DIR}/openblas_config_template.h OPENBLAS_CONFIG_TEMPLATE_H_CONTENTS)\nfile(APPEND ${OPENBLAS_CONFIG_H} \"${OPENBLAS_CONFIG_TEMPLATE_H_CONTENTS}\\n\")\nfile(APPEND ${OPENBLAS_CONFIG_H} \"#endif /* OPENBLAS_CONFIG_H */\\n\")\ninstall (FILES ${OPENBLAS_CONFIG_H} DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})\n\nif(NOT NOFORTRAN)\n  message(STATUS \"Generating f77blas.h in ${CMAKE_INSTALL_INCLUDEDIR}\")\n\n  set(F77BLAS_H ${CMAKE_BINARY_DIR}/generated/f77blas.h)\n  file(WRITE  ${F77BLAS_H} \"#ifndef OPENBLAS_F77BLAS_H\\n\")\n  file(APPEND ${F77BLAS_H} \"#define OPENBLAS_F77BLAS_H\\n\")\n  file(APPEND ${F77BLAS_H} \"#include \\\"openblas_config.h\\\"\\n\")\n  file(READ ${CMAKE_CURRENT_SOURCE_DIR}/common_interface.h COMMON_INTERFACE_H_CONTENTS)\n  file(APPEND ${F77BLAS_H} \"${COMMON_INTERFACE_H_CONTENTS}\\n\")\n  file(APPEND ${F77BLAS_H} \"#endif\")\n  install (FILES ${F77BLAS_H} DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})\nendif()\n\nif(NOT NO_CBLAS)\n  message (STATUS \"Generating cblas.h in ${CMAKE_INSTALL_INCLUDEDIR}\")\n  set(CBLAS_H ${CMAKE_BINARY_DIR}/generated/cblas.h)\n  file(READ ${CMAKE_CURRENT_SOURCE_DIR}/cblas.h CBLAS_H_CONTENTS)\n  string(REPLACE \"common\" \"openblas_config\" CBLAS_H_CONTENTS_NEW \"${CBLAS_H_CONTENTS}\")\n  if (NOT ${SYMBOLPREFIX} STREQUAL \"\")\n    string(REPLACE \" cblas\" \" ${SYMBOLPREFIX}cblas\" CBLAS_H_CONTENTS\t\"${CBLAS_H_CONTENTS_NEW}\")\n    string(REPLACE \" openblas\" \" ${SYMBOLPREFIX}openblas\" CBLAS_H_CONTENTS_NEW\t\"${CBLAS_H_CONTENTS}\")\n    string (REPLACE \" ${SYMBOLPREFIX}openblas_complex\" \" openblas_complex\" CBLAS_H_CONTENTS\t\"${CBLAS_H_CONTENTS_NEW}\")\n    string(REPLACE \" goto\" \" ${SYMBOLPREFIX}goto\" CBLAS_H_CONTENTS_NEW \"${CBLAS_H_CONTENTS}\")\n  endif()\n  if (NOT ${SYMBOLSUFFIX} STREQUAL \"\")\n    string(REGEX REPLACE \"(cblas[^ (]*)\" \"\\\\1${SYMBOLSUFFIX}\" CBLAS_H_CONTENTS\t\"${CBLAS_H_CONTENTS_NEW}\")\n    string(REGEX REPLACE \"(openblas[^ (]*)\" \"\\\\1${SYMBOLSUFFIX}\" CBLAS_H_CONTENTS_NEW \"${CBLAS_H_CONTENTS}\")\n    string(REGEX REPLACE \"(openblas_complex[^ ]*)${SYMBOLSUFFIX}\" \"\\\\1\" CBLAS_H_CONTENTS\t\"${CBLAS_H_CONTENTS_NEW}\")\n    string(REGEX REPLACE \"(goto[^ (]*)\" \"\\\\1${SYMBOLSUFFIX}\" CBLAS_H_CONTENTS_NEW\t\"${CBLAS_H_CONTENTS}\")\n  endif()\n  file(WRITE ${CBLAS_H} \"${CBLAS_H_CONTENTS_NEW}\")\n  install (FILES ${CBLAS_H} DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})\nendif()\n\nif(NOT NO_LAPACKE)\n  message (STATUS \"Copying LAPACKE header files to ${CMAKE_INSTALL_INCLUDEDIR}\")\n  if(BUILD_STATIC_LIBS)\n    add_dependencies( ${OpenBLAS_LIBNAME}_static genlapacke)\n  endif()\n  if(BUILD_SHARED_LIBS)\n    add_dependencies( ${OpenBLAS_LIBNAME}_shared genlapacke)\n  endif()\n  FILE(GLOB_RECURSE INCLUDE_FILES \"${CMAKE_CURRENT_SOURCE_DIR}/lapack-netlib/LAPACKE/*.h\")\n  install (FILES ${INCLUDE_FILES} DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})\n\n  ADD_CUSTOM_TARGET(genlapacke\n  COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_CURRENT_SOURCE_DIR}/lapack-netlib/LAPACKE/include/lapacke_mangling_with_flags.h.in \"${CMAKE_BINARY_DIR}/lapacke_mangling.h\"\n  )\n  install (FILES ${CMAKE_BINARY_DIR}/lapacke_mangling.h DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})\nendif()\n\n# Install pkg-config files\nconfigure_file(${PROJECT_SOURCE_DIR}/cmake/openblas.pc.in ${PROJECT_BINARY_DIR}/openblas${SUFFIX64}.pc @ONLY)\ninstall (FILES ${PROJECT_BINARY_DIR}/openblas${SUFFIX64}.pc DESTINATION ${CMAKE_INSTALL_LIBDIR}/pkgconfig/)\n\n\nset(PN OpenBLAS)\nset(CMAKECONFIG_INSTALL_DIR \"${CMAKE_INSTALL_LIBDIR}/cmake/${PN}${SUFFIX64}\")\nconfigure_package_config_file(cmake/${PN}Config.cmake.in\n                              \"${CMAKE_CURRENT_BINARY_DIR}/${PN}${SUFFIX64}Config.cmake\"\n                              INSTALL_DESTINATION ${CMAKECONFIG_INSTALL_DIR})\nwrite_basic_package_version_file(${CMAKE_CURRENT_BINARY_DIR}/${PN}ConfigVersion.cmake\n                                 VERSION ${${PN}_VERSION}\n                                 COMPATIBILITY AnyNewerVersion)\ninstall(FILES ${CMAKE_CURRENT_BINARY_DIR}/${PN}${SUFFIX64}Config.cmake\n        DESTINATION ${CMAKECONFIG_INSTALL_DIR})\ninstall(FILES ${CMAKE_CURRENT_BINARY_DIR}/${PN}ConfigVersion.cmake\n        RENAME ${PN}${SUFFIX64}ConfigVersion.cmake\n        DESTINATION ${CMAKECONFIG_INSTALL_DIR})\ninstall(EXPORT \"${PN}${SUFFIX64}Targets\"\n        NAMESPACE \"${PN}${SUFFIX64}::\"\n        DESTINATION ${CMAKECONFIG_INSTALL_DIR})\n"
        },
        {
          "name": "CONTRIBUTORS.md",
          "type": "blob",
          "size": 9.380859375,
          "content": "# Contributions to the OpenBLAS project\n\n## Creator & Maintainer\n\n* Zhang Xianyi <traits.zhang@gmail.com>\n\n## Active Developers\n\n* Wang Qian <traz0824@gmail.com>\n  * Optimize BLAS3 on ICT Loongson 3A.\n  * Optimize BLAS3 on Intel Sandy Bridge.\n\n* Werner Saar <wernsaar@googlemail.com>\n  * [2013-03-04] Optimize AVX and FMA4 DGEMM on AMD Bulldozer\n  * [2013-04-27] Optimize AVX and FMA4 TRSM on AMD Bulldozer\n  * [2013-06-09] Optimize AVX and FMA4 SGEMM on AMD Bulldozer\n  * [2013-06-11] Optimize AVX and FMA4 ZGEMM on AMD Bulldozer\n  * [2013-06-12] Optimize AVX and FMA4 CGEMM on AMD Bulldozer\n  * [2013-06-16] Optimize dgemv_n kernel on AMD Bulldozer\n  * [2013-06-20] Optimize ddot, daxpy kernel on AMD Bulldozer\n  * [2013-06-21] Optimize dcopy kernel on AMD Bulldozer\n  * Porting and Optimization on ARM Cortex-A9\n  * Optimization on AMD Piledriver\n  * Optimization on Intel Haswell\n\n* Chris Sidebottom <chris.sidebottom@arm.com>\n  * Optimizations and other improvements targeting AArch64\n\n## Previous Developers\n\n* Zaheer Chothia <zaheer.chothia@gmail.com>\n  * Improve the compatibility about complex number\n  * Build LAPACKE: C interface to LAPACK\n  * Improve the windows build.\n\n* Chen Shaohu <huhumartinwar@gmail.com>\n  * Optimize GEMV on the Loongson 3A processor.\n\n* Luo Wen\n  * Intern. Test Level-2 BLAS.\n\n## Contributors\n\nIn chronological order:\n\n* pipping <http://page.mi.fu-berlin.de/pipping>\n  * [2011-06-11] Make USE_OPENMP=0 disable openmp.\n\n* Stefan Karpinski <stefan@karpinski.org>\n  * [2011-12-28] Fix a bug about SystemStubs on Mac OS X.\n\n* Alexander Eberspächer <https://github.com/aeberspaecher>\n  * [2012-05-02] Add note on patch for segfaults on Linux kernel 2.6.32.\n\n* Mike Nolta <mike@nolta.net>\n  * [2012-05-19] Fix building bug on FreeBSD and NetBSD.\n\n* Sylvestre Ledru <https://github.com/sylvestre>\n  * [2012-07-01] Improve the detection of sparc. Fix building bug under\n    Hurd and kfreebsd.\n\n* Jameson Nash <https://github.com/vtjnash>\n  * [2012-08-20] Provide support for passing CFLAGS, FFLAGS, PFLAGS, FPFLAGS to\n    make on the command line.\n\n* Alexander Nasonov <alnsn@yandex.ru>\n  * [2012-11-10] Fix NetBSD build.\n\n* Sébastien Villemot <sebastien@debian.org>\n  * [2012-11-14] Fix compilation with TARGET=GENERIC. Patch applied to Debian package.\n  * [2013-08-28] Avoid failure on qemu guests declaring an Athlon CPU without 3dnow!\n\n* Kang-Che Sung <Explorer09@gmail.com>\n  * [2013-05-17] Fix typo in the document. Re-order the architecture list in getarch.c.\n\n* Kenneth Hoste <kenneth.hoste@gmail.com>\n  * [2013-05-22] Adjust Makefile about downloading LAPACK source files.\n\n* Lei WANG <https://github.com/wlbksy>\n  * [2013-05-22] Fix a bug about wget.\n\n* Dan Luu <http://www.linkedin.com/in/danluu>\n  * [2013-06-30] Add Intel Haswell support (using sandybridge optimizations).\n\n* grisuthedragon <https://github.com/grisuthedragon>\n  * [2013-07-11] create openblas_get_parallel to retrieve information which parallelization\n    model is used by OpenBLAS.\n\n* Elliot Saba <staticfloat@gmail.com>\n  * [2013-07-22] Add in return value for `interface/trtri.c`\n\n* Sébastien Fabbro <bicatali@gentoo.org>\n  * [2013-07-24] Modify makefile to respect user's LDFLAGS\n  * [2013-07-24] Add stack markings for GNU as arch-independent for assembler files\n\n* Viral B. Shah <viral@mayin.org>\n  * [2013-08-21] Patch LAPACK XLASD4.f as discussed in JuliaLang/julia#2340\n\n* Lars Buitinck <https://github.com/larsmans>\n  * [2013-08-28] get rid of the generated cblas_noconst.h file\n  * [2013-08-28] Missing threshold in gemm.c\n  * [2013-08-28] fix default prefix handling in makefiles\n\n* yieldthought <https://github.com/yieldthought>\n  * [2013-10-08] Remove -Wl,--retain-symbols-file from dynamic link line to fix tool support\n\n* Keno Fischer <https://github.com/loladiro>\n  * [2013-10-23] Use FC instead of CC to link the dynamic library on OS X\n\n* Christopher Meng <cickumqt@gmail.com>\n  * [2013-12-09] Add DESTDIR support for easier building on RPM based distros.\n                 Use install command instead of cp to install files with permissions control.\n\n* Lucas Beyer <lucasb.eyer.be@gmail.com>\n  * [2013-12-10] Added support for NO_SHARED in make install.\n\n* carlkl <https://github.com/carlkl>\n  * [2013-12-13] Fixed LAPACKE building bug on Windows\n\n* Isaac Dunham <https://github.com/idunham>\n  * [2014-08-03] Fixed link error on Linux/musl\n\n* Dave Nuechterlein\n  * [2014-10-10] trmm and sgemm kernels (optimized for APM's X-Gene 1).\n                 ARMv8 support.\n\n* Jerome Robert <jeromerobert@gmx.com>\n  * [2015-01-01] Speed-up small `ger` and `gemv` using stack allocation (bug #478)\n  * [2015-12-23] `stack_check` in `gemv.c` (bug #722)\n  * [2015-12-28] Allow to force the number of parallel make job\n  * [2015-12-28] Fix detection of AMD E2-3200 detection\n  * [2015-12-31] Let `make MAX_STACK_ALLOC=0` do what expected\n  * [2016-01-19] Disable multi-threading in `ger` and `swap` for small matrices (bug #731)\n  * [2016-01-24] Use `GEMM_MULTITHREAD_THRESHOLD` as a number of ops (bug #742)\n  * [2016-01-26] Let `openblas_get_num_threads` return the number of active threads (bug #760)\n  * [2016-01-30] Speed-up small `zger`, `zgemv`, `ztrmv` using stack allocation (bug #727)\n\n* Dan Kortschak\n  * [2015-01-07] Added test for drotmg bug #484.\n\n* Ton van den Heuvel <https://github.com/ton>\n  * [2015-03-18] Fix race condition during shutdown causing a crash in gotoblas_set_affinity().\n\n* Martin Koehler <https://github.com/grisuthedragon/>\n  * [2015-09-07] Improved imatcopy\n\n* Ashwin Sekhar T K <https://github.com/ashwinyes/>\n  * [2015-11-09] Assembly kernels for Cortex-A57 (ARMv8)\n  * [2015-11-20] lapack-test fixes for Cortex-A57\n  * [2016-03-14] Additional functional Assembly Kernels for Cortex-A57\n  * [2016-03-14] Optimize Dgemm 4x4 for Cortex-A57\n\n* theoractice <https://github.com/theoractice/>\n  * [2016-03-20] Fix compiler error in VisualStudio with CMake\n  * [2016-03-22] Fix access violation on Windows while static linking\n\n* Paul Mustière <https://github.com/buffer51/>\n  * [2016-02-04] Fix Android build on ARMV7\n  * [2016-04-26] Android build with LAPACK for ARMV7 & ARMV8\n\n* Shivraj Patil <https://github.com/sva-img/>\n  * [2016-05-03] DGEMM optimization for MIPS P5600 and I6400 using MSA\n\n* Kaustubh Raste <https://github.com/ksraste/>\n  * [2016-05-09] DTRSM optimization for MIPS P5600 and I6400 using MSA\n  * [2016-05-20] STRSM optimization for MIPS P5600 and I6400 using MSA\n\n* Abdelrauf  <https://github.com/quickwritereader>\n  * [2017-01-01] dgemm and dtrmm kernels for IBM z13\n  * [2017-02-26] ztrmm kernel for IBM z13\n  * [2017-03-13] strmm and ctrmm kernel for IBM z13\n  * [2017-09-01] initial Blas Level-1,2 (double precision) for IBM z13\n  * [2018-03-07] added missing Blas Level 1-2  (double precision) simd codes\n  * [2019-02-01] added missing Blas Level-1,2 (single precision)  simd codes\n  * [2019-03-14] power9 dgemm/dtrmm kernel\n  * [2019-04-29] power9 sgemm/strmm kernel \n\n* Jiachen Wang <https://github.com/wjc404>\n  * [2019-07-29] optimize AVX2 DGEMM\n  * [2019-10-20] AVX512 DGEMM kernel (4x8)\n  * [2019-11-06] optimize AVX512 SGEMM\n  * [2019-11-12] AVX512 CGEMM & ZGEMM kernels\n  * [2019-12-23] optimize AVX2 CGEMM and ZGEMM\n  * [2019-12-30] AVX2 CGEMM3M & ZGEMM3M kernels\n  * [2020-01-07] optimize AVX2 SGEMM and STRMM\n\n* Rajalakshmi Srinivasaraghavan <https://github.com/RajalakshmiSR>\n  * [2020-04-15] Half-precision GEMM for bfloat16\n\n* Marius Hillenbrand <https://github.com/mhillenibm>\n  * [2020-05-12] Revise dynamic architecture detection for IBM z\n  * [2020-05-12] Add new sgemm and strmm kernel for IBM z14\n  * [2020-09-07] Fix builds with clang on IBM z, including dynamic architecture support\n\n* Danfeng Zhang <https://github.com/craft-zhang>\n  * [2020-05-20] Improve performance of SGEMM and STRMM on Arm Cortex-A53\n\n* PingTouGe Semiconductor Co., Ltd.\n  * [2020-10] Add RISC-V Vector (0.7.1) support. Optimize BLAS kernels for Xuantie C910\n\n* Jake Arkinstall <https://github.com/jake-arkinstall>\n  * [2021-02-10] Remove in-source configure_file to enable builds in read-only contexts (issue #3100, PR #3101)\n\n* River Dillon <oss@outerpassage.net>\n  * [2021-07-10] fix compilation with musl libc\n\n* Bine Brank <https://github.com/binebrank>\n  * [2021-10-27] Add vector-length-agnostic DGEMM kernels for Arm SVE\n  * [2021-11-20] Vector-length-agnostic Arm SVE copy routines for DGEMM, DTRMM, DSYMM\n  * [2021-11-12] SVE kernels for SGEMM, STRMM and corresponding SVE copy functions\n  * [2022-01-06] SVE kernels for CGEMM, ZGEMM, CTRMM, ZTRMM and corresponding SVE copy functions\n  * [2022-01-18] SVE kernels and copy functions for TRSM\n\n* Ilya Kurdyukov <https://github.com/ilyakurdyukov>\n  * [2021-02-21] Add basic support for the Elbrus E2000 architecture\n\n* PLCT Lab, Institute of Software Chinese Academy of Sciences\n  * [2022-03] Support RISC-V Vector Intrinisc 1.0 version.\n  \n* Pablo Romero <https://github.com/pablorcum>\n  * [2022-08] Fix building from sources for QNX\n\n* Mark Seminatore <https://github.com/mseminatore>\n  * [2023-11-09] Improve Windows threading performance scaling\n  * [2024-02-09] Introduce MT_TRACE facility and improve code consistency\n\n* Dirreke <https://github.com/mseminatore>\n  * [2024-01-16] Add basic support for the CSKY architecture\n\n* Christopher Daley <https://github.com/cdaley>\n  * [2024-01-24] Optimize GEMV forwarding on ARM64 systems\n\n* Aniket P. Garade <https://github.com/garadeaniket>   Sushil Pratap Singh <https://github.com/SushilPratap04>  Juliya James <https://github.com/Juliya32> \n  *  [2024-12-13] Optimized swap and rot  Level-1 BLAS routines with ARM SVE  \n"
        },
        {
          "name": "Changelog.txt",
          "type": "blob",
          "size": 95.80078125,
          "content": "OpenBLAS ChangeLog\n====================================================================\nVersion 0.3.29\n12-Jan-2025\n\ngeneral:\n - fixed a potential NULL pointer dereference in multithreaded builds\n - added function aliases for GEMMT using its new name GEMMTR adopted by Reference-BLAS\n - fixed a build failure when building without LAPACK_DEPRECATED functions\n - the minimum required CMake version for CMake-based builds was raised to 3.16.0 in order \n   to remove many compatibility and deprecation warnings\n - added more detailed CMake rules for OpenMP builds (mainly to support recent LLVM)\n - fixed the behavior of the recently added CBLAS_?GEMMT functions with row-major data\n - improved thread scaling of multithreaded SBGEMV \n - improved thread scaling of multithreaded TRTRI \n - fixed compilation of the CBLAS testsuite with gcc14 (and no Fortran compiler)\n - added support for option handling changes in flang-new from LLVM18 onwards \n - added support for recent calling conventions changes in Cray and NVIDIA compilers\n - added support for compilation with the NAG Fortran compiler\n - fixed placement of the -fopenmp flag and libsuffix in the generated pkgconfig file\n - improved the CMakeConfig file generated by the Makefile build\n - fixed const-correctness of cblas_?geadd in cblas.h\n - fixed a potential inaccuracy in multithreaded BLAS3 calls\n - fixed empty implementations of get/set_affinity that print a warning in OpenMP builds\n - fixed function signatures for TRTRS in the converted C version of LAPACK\n - fixed omission of several single-precision LAPACK symbols in the shared library \n - improved build instructions for the provided \"pybench\" benchmarks\n - improved documentation, including added build instructions for WoA and HarmonyOS\n   as well as descriptions of environment variables that affect build and runtime behavior\n - added a separate \"make install_tests\" target for use with cross-compilations\n - integrated improvements and corrections from Reference-LAPACK:\n   - removed a comparison in LAPACKE ?tpmqrt that is always false (LAPACK PR 1062)\n   - fixed the leading dimension for B in tests for GGEV (LAPACK PR 1064)\n   - replaced the ?LARFT functions with a recursive implementation (LAPACK PR 1080)\n\narm:\n - fixed build with recent versions of the NDK (missing .type declaration of symbols)\n\narm64:\n - fixed a long-standing bug in the (generic) c/zgemm_beta kernel that could lead to\n   reads and writes outside the array bounds in some circumstances\n - rewrote cpu autodetection to scan all cores and return the highest performing type\n - improved the DGEMM performance for SVE targets and small matrix sizes\n - improved dimension criteria for forwarding from GEMM to GEMV kernels\n - added SVE kernels for ROT and SWAP\n - improved SVE kernels for SGEMV and DGEMV on A64FX and NEOVERSEV1\n - added support for using the \"small matrix\" kernels with CMake as well\n - fixed compilation on Windows on Arm\n - improved compile-time detection of SVE capability\n - added cpu autodetection and initial support for Apple M4\n - added support for compilation on systems running IOS\n - added support for compilation on NetBSD (\"evbarm\" architecture)\n - fixed NRM2 implementations for generic SVE targets and the Neoverse N2\n - fixed compilation for SVE-capable targets with the NVIDIA compiler\n\nx86_64:\n - fixed a wrong storage size in the SBGEMV kernel for Cooper Lake\n - added cpu autodetection for Intel Granite Rapids\n - added cpu autodetection for AMD Ryzen 5 series\n - added optimized SOMATCOPY_CT for AVX-capable targets\n - fixed the fallback implementation of GEMM3M in GENERIC builds\n - tentatively re-enabled builds with the EXPRECISION option\n - worked around a miscompilation of tests with mingw32-gfortran14\n - added support for compilation with the Intel oneAPI 2025.0 compiler on Windows\n\npower:\n - fixed multithreaded SBGEMM\n - fixed a CMake build problem on POWER10\n - improved the performance of SGEMV\n - added vectorized implementations of SBGEMV and support for forwarding 1xN SBGEMM to them\n - fixed illegal instructions and potential memory overflow in SGEMM on PPCG4\n - fixed handling of NaN and Inf arguments in SSCAL and DSCAL on PPC440,G4 and 970\n - added improved CGEMM and ZGEMM kernels for POWER10\n - added Makefile logic to remove all optimization flags in DEBUG builds\n\nmips64:\n - fixed compilation with gcc14\n - fixed GEMM parameter selection for the MIPS64_GENERIC target\n - fixed a potential build failure when compiling with OpenMP\n\nloongarch64:\n - fixed compilation for Loongson3 with recent versions of gmake\n - fixed a potential loss of precision in Loongson3A GEMM\n - fixed a potential build failure when compiling with OpenMP\n - added optimized SOMATCOPY for LASX-capable targets\n - introduced a new cpu naming scheme while retaining compatibility\n - added support for cross-compiling Loongarch64 targets with CMake\n - added support for compilation with LLVM\n\nriscv64:\n - removed thread yielding overhead caused by sched_yield\n - replaced some non-standard intrinsics with their official names\n - fixed and sped up the implementations of CGEMM/ZGEMM TCOPY for vector lenghts 128 and 256\n - improved the performance of SNRM2/DNRM2 for RVV1.0 targets\n - added optimized ?OMATCOPY_CN kernels for RVV1.0 targets\n\n====================================================================\nVersion 0.3.28\n 8-Aug-2024\n\ngeneral:\n- Reworked the unfinished implementation of HUGETLB from GotoBLAS\n  for allocating huge memory pages as buffers on suitable systems\n- Changed the unfinished implementation of GEMM3M for the generic\n  target on all architectures to at least forward to regular GEMM\n- Improved multithreaded GEMM performance for large non-skinny matrices\n- Improved BLAS3 performance on larger multicore systems through improved\n  parallelism\n- Improved performance of the initial memory allocation by reducing\n  locking overhead\n- Improved performance of GBMV at small problem sizes by introducing\n  a size barrier for the switch to multithreading\n- Added an implementation of the CBLAS_GEMM_BATCH extension\n- Fixed miscompilation of CAXPYC and ZAXPYC on all architectures in \n  CMAKE builds (error introduced in 0.3.27)\n- Fixed corner cases involving the handling of NAN and INFINITY\n  arguments in ?SCAL on all architectures\n- Added support for cross-compiling to WEBM with CMAKE (in addition\n  to the already present makefile support)\n- Fixed NAN handling and potential accuracy issues in compilations with\n  Intel ICX by supplying a suitable fp-model option by default\n- The contents of the github project wiki have been converted into\n  a new set of documentation included with the source code.\n- It is now possible to register a callback function that replaces\n  the built-in support for multithreading with an external backend\n  like TBB (openblas_set_threads_callback_function)\n- Fixed potential duplication of suffixes in shared library naming\n- Improved C compiler detection by the build system to tolerate more\n  naming variants for gcc builds\n- Fixed an unnecessary dependency of the utest on CBLAS\n- Fixed spurious error reports from the BLAS extensions utest\n- Fixed unwanted invocation of the GEMM3M tests in cross-compilation\n- Fixed a flaw in the makefile build that could lead to the pkgconfig\n  file containing an entry of UNKNOWN for the target cpu after installing\n- Integrated fixes from the Reference-LAPACK project:\n  - Fixed uninitialized variables in the LAPACK tests for ?QP3RK (PR 961)\n  - Fixed potential bounds error in ?UNHR_COL/?ORHR_COL (PR 1018)\n  - Fixed potential infinite loop in the LAPACK testsuite (PR 1024)\n  - Make the variable type used for hidden length arguments configurable (PR 1025)  \n  - Fixed SYTRD workspace computation and various typos (PR 1030)\n  - Prevent compiler use of FMA that could increase numerical error in ?GEEVX (PR 1033)\n\nx86-64:\n- reverted thread management under Windows to its state before 0.3.26\n  due to signs of race conditions in some circumstances now under study\n- fixed accidental selection of the unoptimized generic SBGEMM kernel\n  in CMAKE builds for CooperLake and SapphireRapids targets\n- fixed a potential thread buffer overrun in SBSTOBF16 on small systems\n- fixed an accuracy issue in ZSCAL introduced in 0.3.26\n- fixed compilation with CMAKE and recent releases of LLVM\n- added support for Intel Emerald Rapids and Meteor Lake cpus\n- added autodetection support for the Zhaoxin KX-7000 cpu\n- fixed autodetection of Intel Prescott (probably broken since 0.3.19)\n- fixed compilation for older targets with the Yocto SDK\n- fixed compilation of the converter-generated C versions\n  of the LAPACK sources with gcc-14\n- improved compiler options when building with CMAKE and LLVM for\n  AVX512-capable targets\n- added support for supplying the L2 cache size via an environment\n  variable (OPENBLAS_L2_SIZE) in case it is not correctly reported\n  (as in some VM configurations)\n- improved the error message shown when thread creation fails on startup\n- fixed setting the rpath entry of the dylib in CMAKE builds on MacOS\n\narm:\n- fixed building for baremetal targets with make\n\narm64:\n- Added a fast path forwarding SGEMM and DGEMM calls with a 1xN or Mx1\n  matrix to the corresponding GEMV kernel \n- added optimized SGEMV and DGEMV kernels for A64FX\n- added optimized SVE kernels for small-matrix GEMM\n- added A64FX to the cpu list for DYNAMIC_ARCH\n- fixed building with support for cpu affinity\n- worked around accuracy problems with C/ZNRM2 on NeoverseN1 and\n  Apple M targets\n- improved GEMM performance on Neoverse V1\n- fixed compilation for NEOVERSEN2 with older compilers\n- fixed potential miscompilation of the SVE SDOT and DDOT kernels\n- fixed potential miscompilation of the non-SVE CDOT and ZDOT kernels\n- fixed a potential overflow when using very large user-defined BUFFERSIZE\n- fixed setting the rpath entry of the dylib in CMAKE builds on MacOS\n\npower:\n- Added a fast path forwarding SGEMM and DGEMM calls with a 1xN or Mx1\n  matrix to the corresponding GEMV kernel \n- significantly improved performance of SBGEMM on POWER10\n- fixed compilation with OpenMP and the XLF compiler\n- fixed building of the BLAS extension utests under AIX\n- fixed building of parts of the LAPACK testsuite with XLF\n- fixed CSWAP/ZSWAP on big-endian POWER10 targets\n- fixed a performance regression in SAXPY on POWER10 with OpenXL\n- fixed accuracy issues in CSCAL/ZSCAL when compiled with LLVM\n- fixed building for POWER9 under FreeBSD\n- fixed a potential overflow when using very large user-defined BUFFERSIZE\n- fixed an accuracy issue in the POWER6 kernels for GEMM and GEMV\n\nriscv64:\n- Added a fast path forwarding SGEMM and DGEMM calls with a 1xN or Mx1\n  matrix to the corresponding GEMV kernel \n- fixed building for RISCV64_GENERIC with OpenMP enabled\n- added DYNAMIC_ARCH support (comprising GENERIC_RISCV64 and the two\n  RVV 1.0 targets with vector length of 128 and 256)\n- worked around the ZVL128B kernels for AXPBY mishandling the special\n  case of zero Y increment\n\nloongarch64:\n- improved GEMM performance on servers of the 3C5000 generation\n- improved performance and stability of DGEMM\n- improved GEMV and TRSM kernels for LSX and LASX vector ABIs\n- fixed CMAKE compilation with the INTERFACE64 option set\n- fixed compilation with CMAKE\n- worked around spurious errors flagged by the BLAS3 tests\n- worked around a miscompilation of the POTRS utest by gcc 14.1\n\nmips64:\n- fixed ASUM and SUM kernels to accept negative step sizes in X\n- fixed complex GEMV kernels for MSA\n\n====================================================================\nVersion 0.3.27\n 4-Apr-2024\n\ngeneral:\n- added initial (generic) support for the CSKY architecture\n- capped the maximum number of threads used in GEMM, GETRF and POTRF to avoid creating\n  underutilized or idle threads\n- sped up multithreaded POTRF on all platforms\n- added extension openblas_set_num_threads_local() that returns the previous thread count\n- re-evaluated the SGEMV and DGEMV load thresholds to avoid activating multithreading \n  for too small workloads\n- improved the fallback code used when the precompiled number of threads is exceeded,\n  and made it callable multiple times during the lifetime of an instance\n- added CBLAS interfaces for the BLAS extensions ?AMIN,?AMAX, CAXPYC and ZAXPYC\n- fixed a potential buffer overflow in the interface to the GEMMT kernels\n- fixed use of incompatible pointer types in GEMMT and C/ZAXPBY as flagged by GCC-14\n- fixed unwanted case sensitivity of the character parameters in ?TRTRS\n- sped up the OpenMP thread management code\n- fixed sizing of logical variables in INTERFACE64 builds of the C version of LAPACK\n- fixed inclusion of new LAPACK and LAPACKE functions from LAPACK 3.11 in the shared library\n- added a testsuite for the BLAS extensions\n- modified the error thresholds for SGS/DGS functions in the LAPACK testsuite to suppress\n  spurious errors\n- added support for building the benchmark collection with CMAKE\n- added rewriting of linker options to avoid linking both libgomp and libomp in CMAKE builds\n  with OpenMP enabled that use clang with gfortran\n- fixed building on systems with ucLibc\n- added support for calling ?NRM2 with a negative increment value on all architectures\n- added support for the LLVM18 version of the flang-new compiler\n- fixed handling of the OPENBLAS_LOOPS variable in several benchmarks\n- Integrated fixes from the Reference-LAPACK project:\n  - Increased accuracy in C/ZLARFGP (Reference-LAPACK PR 981)\n  \nx86:\n- fixed handling of NaN and Inf arguments in ZSCAL\n- fixed GEMM3M functions failing in CMAKE builds\n\nx86-64:\n- removed all instances of sched_yield() on Linux and BSD\n- fixed a potential deadlock in the thread server on MSWindows (introduced in 0.3.26)\n- fixed GEMM3M functions failing in CMAKE builds\n- fixed handling of NaN and Inf arguments in ZSCAL\n- added compiler checks for AVX512BF16 compatibility\n- fixed LLVM compiler options for Sapphire Rapids \n- fixed cpu handling fallbacks for Sapphire Rapids with\n  disabled AVX2 in DYNAMIC_ARCH mode\n- fixed extensions SCSUM and DZSUM\n- improved GEMM performance for ZEN targets\n\narm:\n- fixed handling of NaN and Inf arguments in ZSCAL\n\narm64:\n- added initial support for the Cortex-A76 cpu\n- fixed handling of NaN and Inf arguments in ZSCAL\n- fixed default compiler options for gcc (-march and -mtune)\n- added support for ArmCompilerForLinux\n- added support for the NeoverseV2 cpu in DYNAMIC_ARCH builds\n- fixed mishandling of the INTERFACE64 option in CMAKE builds\n- corrected SCSUM kernels (erroneously duplicating SCASUM behaviour)  \n- added SVE-enabled kernels for CSUM/ZSUM\n- worked around an inaccuracy in the NRM2 kernels for NeoverseN1 and Apple M\n\npower:\n- improved performance of SGEMM on POWER8/9/10\n- improved performance of DGEMM on POWER10\n- added support for OpenMP builds with xlc/xlf on AIX\n- improved cpu autodetection for DYNAMIC_ARCH builds on older AIX\n- fixed cpu core counting on AIX\n- added support for building a shared library on AIX\n\nriscv64:\n- added support for the X280 cpu\n- added support for semi-generic RISCV models with vector length 128 or 256\n- added support for compiling with either RVV 0.7.1 or RVV 1.0 standard compilers\n- fixed handling of NaN and Inf arguments in ZSCAL\n- improved cpu model autodetection\n- fixed corner cases in ?AXPBY for C910V\n- fixed handling of zero increments in ?AXPY kernels for C910V\n\nloongarch64:\n- added optimized kernels for ?AMIN and ?AMAX\n- fixed handling of NaN and Inf arguments in ZSCAL\n- fixed handling of corner cases in ?AXPBY\n- fixed computation of SAMIN and DAMIN in LSX mode\n- fixed computation of ?ROT\n- added optimized SSYMV and DSYMV kernels for LSX and LASX mode\n- added optimized CGEMM and ZGEMM kernels for LSX and LASX mode\n- added optimized CGEMV and ZGEMV kernels\n\nmips:\n- fixed utilizing MSA on P5600 and related cpus (broken in 0.3.22)\n- fixed handling of NaN and Inf arguments in ZSCAL\n- fixed mishandling of the INTERFACE64 option in CMAKE builds\n\nzarch:\n- fixed handling of NaN and Inf arguments in ZSCAL\n- fixed calculation of ?SUM on Z13\n\n====================================================================\nVersion 0.3.26\n 2-Jan-2024\n\ngeneral:\n- improved the version of openblas.pc that is created by the CMAKE build\n- fixed a CMAKE-specific build problem on older versions of MacOS\n- worked around linking problems on old versions of MacOS\n- corrected installation location of the lapacke_mangling header in CMAKE builds\n- added type declarations for complex variables to the MSVC-specific parts of the LAPACK header\n- significantly sped up ?GESV for small problem sizes by introducing a lower bound for multithreading\n- imported additions and corrections from the Reference-LAPACK project:\n  - added new LAPACK functions for truncated QR with pivoting (Reference-LAPACK PRs 891&941)\n  - handle miscalculation of minimum work array size in corner cases (Reference-LAPACK PR 942)\n  - fixed use of uninitialized variables in ?GEDMD and improved inline documentation (PR 959)\n  - fixed use of uninitialized variables (and consequential failures) in ?BBCSD (PR 967)\n  - added tests for the recently introduced Dynamic Mode Decomposition functions (PR 736)\n  - fixed several memory leaks in the LAPACK testsuite (PR 953)\n  - fixed counting of testsuite results by the Python script (PR 954)\n   \nx86-64:\n- fixed computation of CASUM on SkylakeX and newer targets in the special\n  case that AVX512 is not supported by the compiler or operating environment\n- fixed potential undefined behaviour in the CASUM/ZASUM kernels for AVX512 targets\n- worked around a problem in the pre-AVX kernels for GEMV\n- sped up the thread management code on MS Windows\n\narm64:\n- fixed building of the LAPACK testsuite with Xcode 15 on Apple M1 and newer\n- sped up the thread management code on MS Windows\n- sped up SGEMM and DGEMM on Neoverse V1 and N1\n- sped up ?DOT on SVE-capable targets\n- reduced the number of targets in DYNAMIC_ARCH builds by eliminating functionally equivalent ones\n- included support for Apple M1 and newer targets in DYNAMIC_ARCH builds\n\npower:\n- improved the SGEMM kernel for POWER10\n- fixed compilation with (very) old versions of gcc\n- fixed detection of old 32bit PPC targets in CMAKE-based builds\n- added autodetection of the POWERPC 7400 subtype\n- fixed CMAKE-based compilation for PPCG4 and PPC970 targets\n\nloongarch64:\n- added and improved optimized kernels for almost all BLAS functions\n\n====================================================================\nVersion 0.3.25\n 12-Nov-2023\n\ngeneral:\n- improved the error message shown on exceeding the maximum thread count\n- improved the code to add supplementary thread buffers in case of overflow\n- fixed a potential division by zero in ?ROTG\n- improved the ?MATCOPY functions to accept zero-sized rows or columns\n- corrected empty prototypes in function declarations\n- cleaned up unused declarations in the f2c-converted versions of the LAPACK sources\n- fixed compilation with the Cray CCE Compiler suite\n- improved link line rewriting to avoid mixed libgomp/libomp builds with clang&gfortran\n- worked around OPENMP builds with LLVM14's libomp hanging on FreeBSD\n- improved the Makefiles to require less option duplication on \"make install\"\n- imported the following changes from the upcoming release 3.12 of Reference-LAPACK\n  - deprecate utility functions ?GELQS and ?GEQRS (LAPACK PR 900)\n  - apply rounding up to workspace calculations done in floating point (LAPACK PR 904)\n  - avoid overflow in STGEX2/DTGEX2 (LAPACK PR 907)\n  - fix accumulation in ?LASSQ (LAPACK PR 909)\n  - fix handling of NaN values in ?GECON (LAPACK PR 926)\n  - avoid overflow in CBDSQR/ZBDSQR (LAPACK PR 927)\n  - fix poor vector orthogonalizations in ?ORBDB5/?UNBDB5 (LAPACK PR 928 & 930)\n\nx86-64:\n- fixed compile-time autodetection of AMD Ryzen3 and Ryzen4 cpus\n- fixed capability-based fallback selection for unknown cpus in DYNAMIC_ARCH\n- added AVX512 optimizations for ?ASUM on Sapphire Rapids and Cooper Lake\n\nARM64:\n- fixed building on Apple with homebrew gcc\n- fixed building with XCODE 15\n- fixed building on A64FX and Cortex A710/X1/X2\n- increased the default buffer size for recent ARM server cpus \n\nPOWER:\n- fixed building with the IBM xlf 16.1.1 compiler\n- fixed building with IBM XL C\n- added support for DYNAMIC_ARCH builds with clang\n- fixed union declaration in the BFLOAT16 test case\n- enable optimizations for the AIX assembler on POWER10\n\nLOONGARCH64:\n- added an optimized SGEMV kernel\n- added an optimized DTRSM kernel\n\n====================================================================\nVersion 0.3.24\n 03-Sep-2023\n\ngeneral:\n   - declared the arguments of cblas_xerbla as const (in accordance with the reference implementation \n     and others, the previous discrepancy appears to have dated back to GotoBLAS)\n   - fixed the implementation of ?GEMMT that was added in 0.3.23\n   - made cpu-specific SWITCH_RATIO parameters for GEMM available to DYNAMIC_ARCH builds\n   - fixed application of SYMBOLSUFFIX in CMAKE builds\n   - fixed missing SSYCONVF function in the shared library\n   - fixed parallel build logic used with gmake\n   - added support for compilation with LLVM17, in particular its new Fortran compiler\n   - added support for CMAKE builds using the NVIDIA HPC compiler\n   - fixed INTERFACE64 builds with CMAKE and the f95 Fortran compiler\n   - fixed cross-build detection and management in c_check\n   - disabled building of the tests with CMAKE when ONLY_CBLAS is defined\n   - fixed several issues with the handling of runtime limits on the number of OPENMP threads\n   - corrected the error code returned by SGEADD/DGEADD when LDA is too small\n   - corrected the error code returned by IMATCOPY when LDB is too small\n   - updated ?NRM2 to support negative increment values (as introduced in release 3.10 \n     of the reference BLAS)\n   - fixed OpenMP builds with CLANG for the case where libomp is not in a standard location\n   - fixed a potential overwrite of unrelated memory during thread initialisation on startup\n   - fixed a potential integer overflow in the multithreading threshold for ?SYMM/?SYRK\n   - fixed build of the LAPACKE interfaces for the LAPACK 3.11.0 ?TRSYL functions added in 0.3.22\n   - fixed installation of .cmake files in concurrent 32 and 64bit builds with CMAKE\n   - applied additions and corrections from the development branch of Reference-LAPACK:\n   - fixed actual arguments passed to a number of LAPACK functions (from Reference-LAPACK PR 885)\n   - fixed workspace query results in LAPACK ?SYTRF/?TRECV3 (from Reference-LAPACK PR 883)\n   - fixed derivation of the UPLO parameter in LAPACKE_?larfb (from Reference-LAPACK PR 878)\n   - fixed a crash in LAPACK ?GELSDD on NRHS=0 (from Reference-LAPACK PR 876)\n   - added new LAPACK utility functions CRSCL and ZRSCL (from Reference-LAPACK PR 839)\n\t- corrected the order of eigenvalues for 2x2 matrices in ?STEMR (Reference-LAPACK PR 867)\n\t- removed spurious reference to OpenMP variables outside OpenMP contexts (Reference-LAPACK PR 860)\n\t- updated file comments on use of LAMBDA variable in LAPACK (Reference-LAPACK PR 852)\n\t- fixed documentation of LAPACK SLASD0/DLASD0 (Reference-LAPACK PR 855)\n\t- fixed confusing use of \"minor\" in LAPACK documentation (Reference-LAPACK PR 849)\n\t- added new LAPACK functions ?GEDMD for dynamic mode decomposition (Reference-LAPACK PR 736)\n\t- fixed potential stack overflows in the EIG part of the LAPACK testsuite (Reference-LAPACK PR 854)\n\t- applied small improvements to the variants of Cholesky and QR functions (Reference-LAPACK PR 847)\n\t- removed unused variables from LAPACK ?BDSQR (Reference-LAPACK PR 832)\n\t- fixed a potential crash on allocation failure in LAPACKE SGEESX/DGEESX (Reference-LAPACK PR 836)\n\t- added a quick return from SLARUV/DLARUV for N < 1 (Reference-LAPACK PR 837)\n\t- updated function descriptions in LAPACK ?GEGS/?GEGV (Reference-LAPACK PR 831)\n\t- improved algorithm description in ?GELSY (Reference-LAPACK PR 833)\n\t- fixed scaling in LAPACK STGSNA/DTGSNA (Reference-LAPACK PR 830)\n\t- fixed crash in LAPACKE_?geqrt with row-major data (Reference-LAPACK PR 768)\n\t- added LAPACKE interfaces for C/ZUNHR_COL and S/DORHR_COL (Reference-LAPACK PR 827)\n\t- added error exit tests for SYSV/SYTD2/GEHD2 to the testsuite (Reference-LAPACK PR 795)\n\t- fixed typos in LAPACK source and comments (Reference-LAPACK PRs 809,811,812,814,820)\n\t- adopt refactored ?GEBAL implementation (Reference-LAPACK PR 808)\n\nx86_64:\n   - added cpu model autodetection for Intel Alder Lake N\n   - added activation of the AMX tile to the Sapphire Rapids SBGEMM kernel\n   - worked around miscompilations of GEMV/SYMV kernels by gcc's tree-vectorizer\n   - fixed compilation of Cooperlake and Sapphire Rapids kernels with CLANG\n   - fixed runtime detection of Cooperlake and Sapphire Rapids in DYNAMIC_ARCH\n   - fixed feature-based cputype fallback in DYNAMIC_ARCH\n   - added support for building the AVX512 kernels with the NVIDIA HPC compiler\n   - corrected ZAXPY result on old pre-AVX hardware for the INCX=0 case\n   - fixed a potential use of uninitialized variables in ZTRSM\n\nARM64:\n   - added cpu model autodetection for Apple M2\n   - fixed wrong results of CGEMM/CTRMM/DNRM2 under OSX (use of reserved register)\n   - added support for building the SVE kernels with the NVIDIA HPC compiler\n   - added support for building the SVE kernels with the Apple Clang compiler\n   - fixed compiler option handling for building the SVE kernels with LLVM\n   - implemented SWITCH_RATIO parameter for improved GEMM performance on Neoverse\n   - activated SVE SGEMM and DGEMM kernels for Neoverse V1\n   - improved performance of the SVE CGEMM and ZGEMM kernels on Neoverse V1\n   - improved kernel selection for the ARMV8SVE target and added it to DYNAMIC_ARCH\n   - fixed runtime check for SVE availability in DYNAMIC_ARCH builds to take OS or\n     container restrictions into account\n   - fixed a potential use of uninitialized variables in ZTRSM\n   - fix a potential misdetection of ARMV8 hardware as 32bit in CMAKE builds\n\nLOONGARCH64:\n   - added ABI detection\n   - added support for cpu affinity handling\n   - fixed compilation with early versions of the Loongson toolchain\n   - added an optimized SGEMM kernel for 3A5000\n   - added optimized DGEMV kernels for 3A5000\n   - improved the performance of the DGEMM kernel for 3A5000\n\nMIPS64:\n   - fixed miscompilation of TRMM kernels for the MIPS64_GENERIC target\n\nPOWER:\n   - fixed compiler warnings in the POWER10 SBGEMM kernel\n\nRISCV:\n   - fixed application of the INTERFACE64 option when building with CMAKE\n   - fix a potential misdetection of RISCV hardware as 32bit in CMAKE builds\n   - fixed IDAMAX and DOT kernels for C910V\n   - fixed corner cases in the ROT and SWAP kernels for C910V\n   - fixed compilation of the C910V target with recent vendor compilers\n\n====================================================================\nVersion 0.3.23\n 01-Apr-2023\n \n general:\n   - fixed a serious regression in GETRF/GETF2 and ZGETRF/ZGETF2 where\n     subnormal but nonzero data elements triggered the singularity flag\n   - fixed a long-standing bug in CSPR/ZSPR in single-threaded operation\n     for cases where elements of the X vector are real numbers (or \n     complex with only the real part zero)\n   - fixed gmake builds with the option NO_LAPACK\n   - fixed a few instances in the gmake Makefiles where expressly\n     setting NO_LAPACK=0 or NO_LAPACKE=0 would have the opposite effect\n   \nx86_64:\n   - added further CPUID values for Intel Raptor Lake\n\n====================================================================\nVersion 0.3.22\n 26-Mar-2023\n\ngeneral:\n - Updated the included LAPACK to Reference-LAPACK release 3.11.0\n   plus post-release corrections and improvements\n - Added initial support for processing with the EMSCRIPTEN javascript\n   converter (yielding a single-threaded build only)\n - Added a threshold for multithreading in SYMM, SYMV and SYR2K\n - Increased the threshold for multithreading in SYRK\n - OpenBLAS no longer decreases the global OMP_NUM_THREADS when it\n   exceeds the maximum thread count the library was compiled for.\n - fixed ?GETF2 potentially returning NaN with tiny matrix elements\n - fixed openblas_set_num_threads to work in USE_OPENMP builds\n - fixed cpu core counting in USE_OPENMP builds returning the number\n   of OMP \"places\" rather than cores\n - fixed interpretation of USE_PERL=0 in build scripts\n - fixed linking of the library with libm in CMAKE builds\n - fixed startup delays resulting from a wrong default setting of \n   NO_WARMUP in CMAKE builds\n - fixed inconsistent defaults for overriding of LAPACK SPMV, SPR, \n   SYMV, SYR functions in gmake and CMAKE builds\n - fixed stride calculation in the optimized small-matrix path of \n   complex SYR\n - fixed compilation of ReLAPACK with CMAKE\n - fixed pkgconfig file contents for INTERFACE64 builds\n - fixed building of Reference-LAPACK with recent gfortran\n - fixed building with only a subset of precision types on Windows\n - added new environment variable OPENBLAS_DEFAULT_NUM_THREADS\n - added a GEMV-based implementation of GEMMT \n - added support for building under QNX\n - updated support for (cross-)building for ALPHA targets\n\nx86_64:\n - added autodetection of Intel Raptor Lake cpu models\n - added SSCAL microkernels for Haswell and newer targets\n - improved the performance of the Haswell DSCAL microkernel\n - added CSCAL and ZSCAL microkernels for SkylakeX targets\n - fixed detection of gfortran and Cray CCE compilers\n - fixed detection of recent versions of the Intel Fortran compiler\n - fixed compilation with LLVM to no longer run out of AVX512 registers\n - fix cpu type option setting with recent NVIDIA HPC compiler versions\n - fixed compilation for/on AMD Ryzen 4 cpus\n - fixed compilation of AVX2-capable targets with Apple Clang\n - fixed runtime selection of COOPERLAKE in DYNAMIC_ARCH builds\n - worked around gcc/llvm using risky FMA operations in CSCAL/ZSCAL\n - worked around miscompilations of GEMV, SYMV and ZDOT kernels\n   by gcc12's tree-vectorizer on OSX and Windows\n\nARM:\n - fixed cross-compilation to ARMV5 and ARMV6 targets with CMAKE\n\nARMV8:\n - fixed cross-compilation to CortexA53 with CMAKE\n - fixed compilation with CMAKE and \"Arm Compiler for Linux 22.1\"\n - added cpu autodetection for Cortex X3 and A715\n - fixed conditional compilation of SVE-capable targets in DYNAMIC_ARCH\n - sped up SVE kernels by removing unnecessary prefetches\n - improved the GEMM performance of Neoverse V1\n - added SVE kernels for SDOT and DDOT\n - added an SBGEMM kernel for Neoverse N2\n - improved cpu-specific compiler option selection for Neoverse cpus\n - added support for setting CONSISTENT_FPCSR \n\nMIPS64:\n - improved MSA capability detection and handling\n - added a MIPS64_GENERIC build target\n - fixed corner cases in DNRM2\n\nLOONGARCH64:\n - fixed handling of the INTERFACE64 option\n\nRISCV:\n - fixed handling of the INTERFACE64 option\n\n====================================================================\nVersion 0.3.21\n 07-Aug-2022\n\ngeneral:\n - Updated the included LAPACK to Reference-LAPACK release 3.10.1\n - when no Fortran compiler is available, OpenBLAS builds will now automatically\n   build LAPACK from an f2c-converted copy of LAPACK 3.9.0 unless the NO_LAPACK option\n   is specified\n - similarly added C versions of the BLAS and CBLAS tests\n - enabled building of the ReLAPACK GEMMT kernels when ReLAPACK is built\n - function LAPACKE_lsame is now annotated with the GCC attribute \"const\" to aid static analyzers\n - added USE_TLS to the list of options reported by the openblas_get_config() function\n - CMAKE builds now support the BUILD_TESTING keyword (to disable the LAPACK testsuite) of Reference-LAPACK\n - fixed CMAKE builds of the laswp_ncopy and neg_tcopy kernels\n - removed the build system requirements for PERL (while keeping the original perl scripts as backup)\n - handle building and running OpenBLAS on systems that report zero available cpu cores\n - added SYMBOLPREFIX/SYMBOLSUFFIX handling for LAPACK 3.10.0 functions added in 0.3.20\n - fixed linking of the utests on QNX\n - Added support for compilation with the Intel ifx compiler\n - Added support for compilation with the Fujitsu FCC compiler for Fugaku\n - Added support for compilation with the Cray C and Fortran compilers\n - reverted OpenMP threadpool behaviour in the exec_blas call to its state before 0.3.11, that is\n   the threadpool will no longer grow or shrink on demand as the overhead for this is too big at least with\n   GNU OpenMP. The adaptive behaviour introduced in 0.3.11 can still be requested at runtime by setting\n   the environment variable OMP_ADAPTIVE\n - worked around spurious STFSM/CTFSM errors reported by the LAPACK testsuite\n\nx86_64:\n - fixed determination of compiler support for AVX512 and removed the 0.3.19\n   workaround for building SKYLAKEX kernels on Sandybridge hardware\n - fixed compilation for the SKYLAKEX target with gcc 6\n - fixed compilation of the CooperLake SBGEMM kernel with LLVM\n - fixed compilation of the SkyLakeX small matrix GEMM kernels with LLVM or ICC\n - fixed compilation of some BFLOAT16 kernels with CMAKE\n - added support for the Zhaoxin/Centaur KH40000 cpu\n - fixed a potential crash in the ZSYMV kernel used for all targets except generic\n - fixed gmake compilation for DYNAMIC_ARCH with a DYNAMIC_LIST including ATOM\n - fixed compilation of LAPACKE with the INTEGER64 option on Windows\n - added support for cross-compiling to individual Intel or AMD targets using CMAKE\n   (previously only CORE2 supported, added targets are ATOM, PRESCOTT, NEHALEM, SANDYBRIDGE,\n   HASWELL,SKYLAKEX, COOPERLAKE, SAPPHIRERAPIDS, OPTERON, BARCELONA, BULLDOZER, PILEDRIVER,\n   STEAMROLLER,EXCAVATOR, ZEN)\n\nSPARC:\n - worked around an overflow error in the DNRM2 kernel\n\nPOWER:\n - worked around an overflow error in the POWER6 DNRM2 kernel\n - fixed compilation on PPC440\n - fixed a performance regression in the level1 BLAS on POWER10\n - fixed the POWER10 ZGEMM kernel\n - fixed singlethreaded builds for POWER10\n - fixed compilation of the POWER10 DGEMV kernel with older gcc versions\n - enabled compilation of the BFLOAT16 kernels by default\n - enabled the small matrix kernels by default for DYNAMIC_ARCH builds\n - added a workaround for a miscompilation of the CDOT and ZDOT kernels by GCC 12\n\n- RISCV:\n - fixed cpu autodetection logic\n\nARMV8:\n - added an SBGEMM kernel for Neoverse N2\n - worked around an overflow error in the DNRM2 kernel used on M1, NeoverseN1, ThunderX2T99\n - added support for ARM64 systems running MS Windows\n - added support for cross-compiling to the GENERIC ARMV8 target under CMAKE (Windows/MSVC)\n - fixed a performance regression in the generic ARMV8 DGEMM kernel introduced in 0.3.19\n - added initial support for the Apple M1 cpu under Linux\n - added initial support for the Phytium FT2000 cpu\n - added initial support for the Cortex A510, A710, X1 and X2 cpu\n - fixed an accidental mixup of cpu identifiers in the autodetection code introduced in 0.3.20\n - fixed linking of Apple M1 builds on macOS 12 and later with recent XCode\n - made Neoverse N2 available in DYNAMIC_ARCH builds\n\nMIPS,MIPS64:\n - worked around an overflow error in the DNRM2 kernel\n\nLOONGARCH64:\n - worked around an overflow error in the DNRM2 kernel\n - added preliminary support for the LOONGSON2K1000 cpu\n - added DYNAMIC_ARCH support\n\n====================================================================\nVersion 0.3.20\n 20-Feb-2022\n\ngeneral:\n - some code cleanup, with added casts etc.\n - fixed obtaining the cpu count with OpenMP and OMP_PROC_BIND unset\n - fixed pivot index calculation by ?LASWP for negative increments other than one\n - fixed input argument check in LAPACK ? GEQRT2\n - improved the check for a Fortran compiler in CMAKE builds\n - disabled building OpenBLAS' optimized versions of LAPACK complex SPMV,SPR,SYMV,SYR with NO_LAPACK=1\n - fixed building of LAPACK on certain distributed filesystems with parallel gmake\n - fixed building the shared library on MacOS with classic flang\n\nx86_64:\n - fixed cross-compilation with CMAKE for CORE2 target\n - fixed miscompilation of AVX512 code in DYNAMIC_ARCH builds\n - added support for the \"incidental\" AVX512 hardware in Alder Lake when enabled in BIOS\n\nE2K:\n - add new architecture (Russian Elbrus E2000 family)\n\nSPARC:\n - fix IMIN/IMAX\n\nARMV8:\n - added SVE-enabled CGEMM and ZGEMM kernels for ARMV8SVE and A64FX\n - added support for Neoverse N2 and V1 cpus\n\nMIPS,MIPS64:\n - fixed autodetection of MSA capability\n\nLOONGARCH64:\n - added an optimized DGEMM kernel\n\n====================================================================\nVersion 0.3.19\n 19-Dec-2021\n \n general:\n - reverted unsafe TRSV/ZRSV optimizations introduced in 0.3.16\n - fixed a potential thread race in the thread buffer reallocation routines\n   that were introduced in 0.3.18\n - fixed miscounting of thread pool size on Linux with OMP_PROC_BIND=TRUE\n - fixed CBLAS interfaces for CSROT/ZSROT and CROTG/ZROTG\n - made automatic library suffix for CMAKE builds with INTERFACE64 available\n   to CBLAS-only builds\n\nx86_64:\n - DYNAMIC_ARCH builds now fall back to the cpu with most similar capabilities\n   when an unknown CPUID is encountered, instead of defaulting to Prescott\n - added cpu detection for Intel Alder Lake\n - added cpu detection for Intel Sapphire Rapids\n - added an optimized SBGEMM kernel for Sapphire Rapids\n - fixed DYNAMIC_ARCH builds on OSX with CMAKE\n - worked around DYNAMIC_ARCH builds made on Sandybridge failing on SkylakeX\n - fixed missing thread initialization for static builds on Windows/MSVC\n - fixed an excessive read in ZSYMV\n\nPOWER:\n - added support for POWER10 in big-endian mode\n - added support for building with CMAKE\n - added optimized SGEMM and DGEMM kernels for small matrix sizes\n\nARMV8:\n - added basic support and cputype detection for Fujitsu A64FX\n - added a generic ARMV8SVE target  \n - added SVE-enabled SGEMM and DGEMM kernels for ARMV8SVE and A64FX\n - added optimized CGEMM and ZGEMM kernels for Cortex A53 and A55 cpus\n - fixed cpuid detection for Apple M1 and improved performance\n - improved compiler flag setting in CMAKE builds\n\nRISCV64:\n - fixed improper initialization in CSCAL/ZSCAL for strided access patterns\n\nMIPS:\n - added a GENERIC target for MIPS32\n - added support for cross-compiling to MIPS32 on x86_64 using CMAKE\n\nMIPS64:\n - fixed misdetection of MSA capability\n\n====================================================================\nVersion 0.3.18\n 02-Oct-2021\n\ngeneral:\n - when the build-time number of preconfigured threads is exceeded\n   at runtime (typically by an external program calling BLAS functions\n   from a larger number of threads in parallel), OpenBLAS will now \n   allocate an auxiliary control structure for up to 512 additional\n   threads instead of aborting\n - added support for Loongson's LoongArch64 cpu architecture\n - fixed building OpenBLAS with CMAKE and -DBUILD_BFLOAT16=ON\n - added support for building OpenBLAS as a CMAKE subproject\n - added support for building for Windows/ARM64 targets with clang\n - improved support for building with the IBM xlf compiler\n - imported Reference-LAPACK PR 625 (out-of-bounds reads in ?LARRV)\n - imported Reference-LAPACK PR 597 for testsuite compatibility with\n   LLVM's libomp\n\nx86_64:\n - added SkylakeX S/DGEMM kernels for small problem sizes (M*N*K<=1000000)\n - added optimized SBGEMM for Intel Cooper Lake\n - reinstated the performance patch for AVX512 SGEMV_T with a proper fix\n - added a workaround for a gcc11 tree-vectorizer bug that caused spurious\n   failures in the test programs for complex BLAS3 when compiling at -O3\n   (the default for cmake \"release\" builds)\n - added support for runtime cpu count detection under Haiku OS\n - worked around a long-standing miscompilation issue of the Haswell DGEMV_T\n   kernel with gcc that could produce NaN output in some corner cases\n\nPOWER:\n - improved performance of DASUM on POWER10\n\nARMV8:\n - fixed crashes (use of reserved register x18) on Apple M1 under OSX\n - fixed building with gcc releases earlier than 5.1\n\nMIPS:\n - fixed building under BSD\n\nMIPS64:\n - fixed building under BSD\n\n====================================================================\nVersion 0.3.17\n 15-Jul-2021\n\ncommon:\n - reverted the optimization of SGEMV_N/DGEMV_N for small input sizes\n   and consecutive arguments as it led to stack overflows on x86_64\n   with some operating systems (notably OSX and Windows)\n \n x86_64:\n  - reverted the performance patch for SGEMV_T on AVX512 as it caused\n    wrong results in some applications\n    \n SPARC:\n  - fixed compilation with compilers other than gcc\n====================================================================\nVersion 0.3.16\n 11-Jul-2021\n\ncommon:\n - drastically reduced the stack size requirements for running the LAPACK\n   testsuite (Reference-LAPACK PR 553)\n - fixed spurious test failures in the LAPACK testsuite (Reference-LAPACK\n   PR 564)\n - expressly setting DYNAMIC_ARCH=0 no longer enables dynamic_arch mode \n - improved performance of xGER, xSPR, xSPR2, xSYR, xSYR2, xTRSV, SGEMV_N \n   and DGEMV_N, for small input sizes and consecutive arguments\n - improved performance of xGETRF, xPORTF and xPOTRI for small input sizes\n   by disabling multithreading\n - fixed installing with BSD versions of the \"install\" utility\n\nRISCV:\n - fixed the implementation of xIMIN\n - improved the performance of DSDOT\n - fixed linking of the tests on C910V with current vendor gcc\n\nPOWER:\n- fixed SBGEMM computation for some odd value inputs\n- fixed compilation for PPCG4, PPC970, POWER3, POWER4 and POWER5\n\nx86_64:\n - improved performance of SGEMV_N and SGEMV_T for small N on AVX512-capable cpus\n - worked around a miscompilation of ZGEMM/ZTRMM on Sandybridge with old gcc\n   versions\n - fixed compilation with MS Visual Studio versions older than 2017\n - fixed macro name collision with winnt.h from the latest Win10 SDK\n - added cpu type autodetection for Intel Ice Lake SP\n - fixed cpu type autodetection for Intel Tiger Lake\n - added cpu type autodetection for recent Centaur/Zhaoxin models\n - fixed compilation with musl libc\n\nARM64:\n- fixed compilation with gcc/gfortran on the Apple M1\n- fixed linking of the tests on FreeBSD\n- fixed missing restore of a register in the recently rewritten DNRM2 kernel\n  for ThunderX2 and Neoverse N1 that could cause spurious failures in e.g.\n  DGEEV\n- added compiler optimization flags for the EMAG8180\n- added initial support for Cortex A55\n\nARM:\n- fixed linking of the tests on FreeBSD\n\n====================================================================\nVersion 0.3.15\n  2-May-2021\n\ncommon:\n - imported improvements and bugfixes from Reference-LAPACK 3.9.1\n - imported LAPACKE interface fixes from Reference-LAPACK PRs 534 + 537\n - fixed a problem in the cpu detection of 0.3.14 that prevented cross-compilation\n - fixed a sequence problem in the generation of softlinks to the library in GMAKE\n\nRISC V:\n - fixed compilation on RISCV (missing entry in getarch)\n - fixed a potential division by zero in CROTG and ZROTG\n\nPOWER:\n - fixed LAPACK testsuite failures seen with the NVIDIA HPC compiler\n - improved CGEMM, DGEMM and ZGEMM performance on POWER10\n - added an optimized ZGEMV kernel for POWER10\n - fixed a potential division by zero in CROTG and ZROTG\n\nx86_64:\n - added support for Intel Control-flow Enforcement Technology (CET)\n - reverted the DOMATCOPY_RT code to the generic C version\n - fixed a bug in the AVX512 SGEMM kernel introduced in 0.3.14\n - fixed misapplication of -msse flag to non-SSE cpus in DYNAMIC_ARCH\n - added support for compilation of the benchmarks on older OSX versions\n - fix propagation of the NO_AVX512 option in CMAKE builds\n - fix compilation of the AVX512 SGEMM kernel with clang-cl on Windows\n - fixed compilation of the CTESTs with INTERFACE64=1 (random faults on OSX)\n - corrected the Haswell DROT kernel to require AVX2/FMA3 rather than AVX512\n\nARM:\n - fixed a potential division by zero in CROTG and ZROTG\n - fixed a potential overflow in IMATCOPY/ZIMATCOPY and the CTESTs\n\nARM64:\n - fixed spurious reads outside the array in the SGEMM tcopy macro\n - fixed a potential division by zero in CROTG and ZROTG\n - fixed a segmentation fault in DYNAMIC_ARCH builds (reappeared in 0.3.14)\n\nMIPS\n - fixed a potential division by zero in CROTG and ZROTG\n - fixed a potential overflow in IMATCOPY/ZIMATCOPY and the CTESTs\n\nMIPS64:\n - fixed a potential division by zero in CROTG and ZROTG\n\nSPARC:\n - fixed a potential division by zero in CROTG and ZROTG\n\n====================================================================\nVersion 0.3.14\n 17-Mar-2021\n \n common:\n\t* Fixed a race condition on thread shutdown in non-OpenMP builds\n\t* Fixed custom BUFFERSIZE option getting ignored in gmake builds\n\t* Fixed CMAKE compilation of the TRMM kernels for GENERIC platforms\n\t* Added CBLAS interfaces for CROTG, ZROTG, CSROT and ZDROT\n\t* Improved performance of OMATCOPY_RT across all platforms\n\t* Changed perl scripts to use env instead of a hardcoded /usr/bin/perl\n\t* Fixed potential misreading of the GCC compiler version in the build scripts\n\t* Fixed convergence problems in LAPACK complex GGEV/GGES (Reference-LAPACK #477)\n\t* Reduced the stacksize requirements for running the LAPACK testsuite (Reference-LAPACK #335)\n\n RISCV:\n \t* Fixed compilation on RISCV (missing entry in getarch)\n\t\n POWER:\n \t* Fixed compilation for DYNAMIC_ARCH with clang and with old gcc versions\n\t* Added support for compilation on FreeBSD/ppc64le\n \t* Added optimized POWER10 kernels for SSCAL, DSCAL, CSCAL, ZSCAL\n\t* Added optimized POWER10 kernels for SROT, DROT, CDOT, SASUM, DASUM\n\t* Improved SSWAP, DSWAP, CSWAP, ZSWAP performance on POWER10\n\t* Improved SCOPY and CCOPY performance on POWER10\n\t* Improved SGEMM and DGEMM performance on POWER10\n\t* Added support for compilation with the NVIDIA HPC compiler\n\n x86_64:\n\t* Added an optimized bfloat16 GEMM kernel for Cooperlake\n\t* Added CPUID autodetection for Intel Rocket Lake and Tiger Lake cpus\n\t* Improved the performance of SASUM,DASUM,SROT,DROT on AMD Ryzen cpus\n\t* Added support for compilation with the NAG Fortran compiler\n\t* Fixed recognition of the AMD AOCC compiler\n\t* Fixed compilation for DYNAMIC_ARCH with clang on Windows\n\t* Added support for running the BLAS/CBLAS tests on Windows\n\t* Fixed signatures of the tls callback functions for Windows x64\n\t* Fixed various issues with fma intrinsics support handling \n\n ARM:\n\t* Added support for embedded Cortex M targets via a new option EMBEDDED\n\n ARMV8:\n \t* Fixed the THUNDERX2T99 and NEOVERSEN1 DNRM2/ZNRM2 kernels for inputs with Inf\n\t* Added support for the DYNAMIC_LIST option\n\t* Added support for compilation with the NVIDIA HPC compiler\n \t* Added support for compiling with the NAG Fortran compiler\n\n====================================================================\nVersion 0.3.13\n 12-Dec-2020\n \n common:\n\t* Added a generic bfloat16 SBGEMV kernel\n\t* Fixed a potentially severe memory leak after fork in OpenMP builds\n\t  that was introduced in 0.3.12\n\t* Added detection of the Fujitsu Fortran compiler\n\t* Added detection of the (e)gfortran compiler on OpenBSD\n\t* Added support for overriding the default name of the library independently\n\t  from symbol suffixing in the gmake builds (already supported in cmake)\n\nRISCV:\n\t* Added a RISC V port optimized for C910V\n\nPOWER:\n\t* Added optimized POWER10 kernels for SAXPY, CAXPY, SDOT, DDOT and DGEMV_N\n\t* Improved DGEMM performance on POWER10\n\t* Improved STRSM and DTRSM performance on POWER9 and POWER10\n\t* Fixed segmemtation faults in DYNAMIC_ARCH builds\n \t* Fixed compilation with the PGI compiler\n\nx86:\n\t* Fixed compilation of kernels that require SSE2 intrinsics since 0.3.12\n\t\nx86_64:\n\t* Added an optimized bfloat16 SBGEMV kernel for SkylakeX and Cooperlake\n\t* Improved the performance of SASUM and DASUM kernels through parallelization\n\t* Improved the performance of SROT and DROT kernels\n\t* Improved the performance of multithreaded xSYRK\n\t* Fixed OpenMP builds that use the LLVM Clang compiler together with GNU gfortran\n\t  (where linking of both the LLVM libomp and GNU libgomp could lead to lockups or\n\t  wrong results)\n\t* Fixed miscompilations by old gcc 4.6\n\t* Fixed misdetection of AVX2 capability in some Sandybridge cpus\n\t* Fixed lockups in builds combining DYNAMIC_ARCH with TARGET=GENERIC on OpenBSD\n\nARM64:\n\t* Fixed segmemtation faults in DYNAMIC_ARCH builds\n\nMIPS:\n\t* Improved kernels for Loongson 3R3 (\"3A\") and 3R4 (\"3B\") models, including MSA\n\t* Fixed bugs in the MSA kernels for CGEMM, CTRMM, CGEMV and ZGEMV\n\t* Added handling of zero increments in the MSA kernels for SSWAP and DSWAP\n\t* Added DYNAMIC_ARCH support for MIPS64 (currently Loongson3R3/3R4 only)\n\nSPARC:\n\t* Fixed building 32 and 64 bit SPARC kernels with the SolarisStudio compilers\n\n====================================================================\nVersion 0.3.12\n 24-Oct-2020\n\ncommon:\n\t* Fixed missing BLAS/LAPACK functions (inadvertently dropped during\n\t  the build system restructuring)\n\t* Fixed argument conversion macro in LAPACKE_zgesvdq (LAPACK #458)\n\nPOWER:\n\t* Added optimized SCOPY/CCOPY kernels for POWER10\n\t* Increased and unified the default size of the GEMM BUFFER\n\t* Fixed building for POWER10 in DYNAMIC_ARCH mode\n\t* POWER10 compatibility test now checks binutils version as well\n\t* Cleaned up compiler warnings\n\nx86_64:\n\t* corrected compiler version checks for AVX2 compatibility\n\t* added compiler option -mavx2 for building with flang\n\t* fixed direct SGEMM pathway for small matrix sizes (broken by\n\t  the code refactoring in 0.3.11)\n\t* fixed unhandled partial register clobbers in several kernels\n\t  for AXPY,DOT,GEMV_N and GEMV_T flagged by gcc10 tree-vectorizer\n\nARMV8:\n\t* improved Apple Vortex support to include cross-compiling\n\n====================================================================\nVersion 0.3.11\n 17-Oct-2020\n\ncommon:\n \t* API change:\n\t  the newly added BFLOAT16 functions were renamed to use the\n\t  letter \"B\" instead of \"H\" to avoid potential confusion with\n\t  the IEEE \"half precision float\" type, i.e. the 0.3.10\n\t  SHGEMM is now SBGEMM and the corresponding build option\n\t  was changed from \"BUILD_HALF\" to \"BUILD_BFLOAT16\".\n\t* Reduced the default BLAS3_MEM_ALLOC_THRESHOLD (used as an upper\n\t  limit for placing temporary arrays on the stack) to be compatible\n\t  with a stack size of 1mb (as imposed by the JAVA runtime library) \n\t* Added mixed-precision dot function SBDOT and utility functions\n\t  shstobf16, shdtobf16, sbf16tos and dbf16tod to convert between\n\t  single or double precision float arrays and bfloat16 arrays\n\t* Fixed prototypes of LAPACK_?ggsvp and LAPACK_?ggsvd functions\n\t  in lapack.h\n\t* Fixed underflow and rounding errors in LAPACK SLANV2 and DLANV2\n\t  (causing miscalculations in e.g. SHSEQR/DHSEQR, LAPACK issue #263)\n\t* Fixed workspace calculation in LAPACK ?GELQ (LAPACK issue #415)\n\t* Fixed several bugs in the LAPACK testsuite\n\t* Improved performance of TRMM and TRSM for certain problem sizes\n\t* Fixed infinite recursions and workspace miscalculations in ReLAPACK\n\t* CMAKE builds no longer require pkg-config for creating the .pc file\n\t* Makefile builds no longer misread NO_CBLAS=0 or NO_LAPACK=0 as \n\t  enabling these options\n\t* Fixed detection of gfortran when invoked through an mpi wrapper\n\t* Improve thread reinitialization performance with OpenMP after a fork \n\t* Added support for building only the subset of the library required\n\t  for a particular precision by specifying BUILD_SINGLE, BUILD_DOUBLE\n\t* Optional function name prefixes and suffixes are now correctly\n\t  reflected in the generated cblas.h\n\t* Added CMAKE build support for the LAPACK and multithreading tests\n\nPOWER:\n\t* Added optimized support for POWER10\n\t* Added support for compiling for POWER8 in 32bit mode\n\t* Added support for compilation with LLVM/clang\n\t* Added support for compilation with NVIDIA/PGI compilers\n\t* Fixed building on big-endian POWER8\n\t* Fixed miscompilation of ZDOTC by gcc10\n\t* Fixed alignment errors in the POWER8 SAXPY kernel\n\t* Improved CPU detection on AIX\n\t* Supported building with older compilers on POWER9\n\nx86_64:\n\t* Added support for Intel Cooperlake\n\t* Added autodetection of AMD Renoir/Matisse/Zen3 cpus\n\t* Added autodetection of Intel Comet Lake cpus\n\t* Reimplemented ?sum, ?dot and daxpy using universal intrinsics\n\t* Reset the fpu state before using the fpu on Windows as a workaround\n\t  for a problem introduced in Windows 10 build 19041 (a.k.a. SDK 2004)\n\t* Fixed potentially undefined behaviour in the dot and gemv_t kernels\n\t* Fixed a potential segmentation fault in DYNAMIC_ARCH builds\n\t* Fixed building for ZEN with PGI/NVIDIA and AMD AOCC compilers\n\t\nARMV7:\n\t* Fixed cpu detection on BSD-like systems\n\nARMV8:\n\t* Added preliminary support for Apple Vortex cpus\n\t* Added support for the Cavium ThunderX3T110 cpu\n\t* Fixed cpu detection on BSD-like systems\n\t* Fixed compilation in -std=C18 mode\n\nIBM Z:\n\t* Added support for compiling with the clang compiler\n\t* Improved GEMM performance on Z14\n\n====================================================================\nVersion 0.3.10\n 14-Jun-2020\n\ncommon:\n\t* Improved thread locking behaviour in blas_server and parallel getrf                         \n\t* Imported bugfix 394 from LAPACK (spurious reference to \"XERBL\"\n\t  due to overlong lines)\n\t* Imported bugfix 403 from LAPACK (compile option \"recursive\" required\n\t  for correctness with Intel and PGI)\n\t* Imported bugfix 408 from LAPACK (wrong scaling in ZHEEQUB)\n\t* Imported bugfix 411 from LAPACK (infinite loop in LARGV/LARTG/LARTGP)\n\t* Fixed mismatches between BUFFERSIZE and GEMM_UNROLL parameters that\n\t  could lead to crashes at large matrix sizes  \n\t* Restored internal soname in dynamic libraries on FreeBSD and Dragonfly \n\t* Added API (openblas_setaffinity) to set the thread affinity on Linux\n\t* Added initial infrastructure for half-precision floating point \n\t  (bfloat16) support with a generic implementation of SHGEMM     \n\t* Added CMAKE build system support for building the cblas_Xgemm3m\n\t  functions\n\t* Fixed CMAKE support for building in a path with embedded spaces\n\t* Fixed CMAKE (non)handling of NO_EXPRECISION and MAX_STACK_ALLOC\n\t* Fixed GCC version detection in the Makefiles\n\t* Allowed overriding the names of AR, AS and LD in Makefile builds\n\nPOWER:\n\t* Fixed big-endian POWER8 ELFv2 builds on FreeBSD\n\t* Fixed GCC version checks and DYNAMIC_ARCH builds on POWER9\n\t* Fixed CMAKE build support for POWER9\n\t* fixed a potential race condition in the thread buffer allocation\n\t* Worked around LAPACK test failures on PPC G4\n\nMIPS:\n\t* Fixed a potential race condition in the thread buffer allocation\n\t* Added support for MIPS 24K/24KE family based on P5600 kernels\n\nMIPS64:\n\t* fixed a potential race condition in the thread buffer allocation\n\t* Added TARGET=GENERIC\n\nARMV7:\n\t* Fixed a race condition in the thread buffer allocation\n\nARMV8:\n\t* Fixed a race condition in the thread buffer allocation\n\t* Fixed zero initialisation in the assembly for SGEMM and DGEMM BETA\n\t* Improved performance of the ThunderX2 DAXPY kernel\n\t* Added an optimized SGEMM kernel for Cortex A53    \n\t* Fixed Makefile support for INTERFACE64 (8-byte integer)\n\nx86_64:\n\t* Fixed a syntax error in the CMAKE setup for SkylakeX\n\t* Improved performance of STRSM on Haswell, SkylakeX and Ryzen\n\t* Improved SGEMM performance on SGEMM for workloads with ldc a\n\t  multiple of 1024\n\t* Improved DGEMM performance on Skylake X\n\t* Fixed unwanted AVX512-dependency of SGEMM in DYNAMIC_ARCH\n\t  builds created on SkylakeX\n\t* Removed data alignment requirement in the SSE2 copy kernels\n\t  that could cause spurious crashes\n\t* Added a workaround for an optimizer bug in AppleClang 11.0.3\n\t* Fixed LAPACK test failures due to wrong options for Intel Fortran\n\t* Fixed compilation and LAPACK test results with recent Flang\n\t  and AMD AOCC\n\t* Fixed DYNAMIC_ARCH builds with CMAKE on OS X\n\t* Fixed missing exports of cblas_i?amin, cblas_i?min, cblas_i?max,\n\t  cblas_?sum, cblas_?gemm3m in the shared library on OS \n\t* Fixed reporting of cpu name in DYNAMIC_ARCH builds (would sometimes\n\t  show the name of an older generation chip supported by the same kernels)\n\nIBM Z:\n\t* Improved performance of SGEMM/STRMM and DGEMM/DTRMM on Z14\n\n====================================================================\nVersion 0.3.9\n 1-Mar-2020\n \n common:\n \t* Fixed a miscompilation of the GETRF functions with CMAKE\n\t* Imported bugfix 390 from LAPACK (missing NaN propagation in xCOMBSSQ)\n\t* The size of the memory buffer used for splitting GEMM tasks across\n          multiple threads can now be configured in the build system.\n\nPOWER:\n\t* Fixed several compilation problems related to endianness\n\t  and ELF version on POWER8 and POWER9\n\t* Fixed use of the absolute value IAMIN/IAMAX instead of IMIN/IMAX\n\t* Fixed a race condition in the level3 blas code\n\t\nMIPS64:\n\t* Fixed use of the absoltute value IAMIN/IAMAX instead of IMIN/IMAX\n\t\nARMV7:\n\t* Fixed a race condition in the level3 blas code\n\t* Fixed compilation on Android\nARMV8:\n\t* Added support for Ampere EMAG8180\n\t* Added support for Neoverse N1\n\t* Improved performance of the blas_lock function\n\t* Fixed a race condition in the level3 blas code\n\t* Fixed a performance regression on TSV110-based servers\n\nx86_64:\n\t* Fixed a long-standing error with undeclared register overwrites\n\t  in the DSCAL microkernel for HASWELL,SKYLAKEX and ZEN\n\t* Fixed a long-standing bug in the SSE implementation of IAMAX\n\t* Fixed a CMAKE build failure with DYNAMIC_ARCH\n\t* Fixed cpu autodetection of Goldmont+, Cannon Lake and Ice Lake\n\t* Fixed a compilation failure on OSX with compiler name containing dash\n\t* Fixed compilation with MinGW on SkylakeX\n\t* Improved speed of the AVX512 GEMM3M kernel on SkylakeX\n\t* Added an AVX512 STRMM kernel for SkylakeX\n\t* Improved GEMM performance on Haswell and Zen\n\nzarch:\n\t* fixed compilation of the DYNAMIC_ARCH code\n\t\n====================================================================\nVersion 0.3.8\n 9-Feb-2020\n\ncommon: \n`\t* LAPACK has been updated to 3.9.0 (plus patches up to \n\t  January 2nd, 2020)\n\t* CMAKE support has been improved in several areas including\n\t  cross-compilation\n\t* a thread race condition in the GEMM3M kernels was resolved\n\t* the \"generic\" (plain C) gemm beta kernel used by many targets\n\t  has been sped up\n\t* an optimized version of the LAPACK trtrs functions has been added\n\t* an incompatibilty between the LAPACK tests and the OpenBLAS\n\t  implementation of XERBLA was resolved, removing the numerous\n\t  warnings about wrong error exits in the former \n\t* support for NetBSD has been added\n\t* support for compilation with g95 and non-GNU versions of ld\n\t  has been improved\n\t* support for compilation with (upcoming) gcc 10 has been added\n\nPOWER:\n\t* worked around miscompilation of several POWER8 and POWER9 \n\t  kernels by older versions of gcc\n\t* added support for big-endian POWER8 and for compilation on AIX\n\t* corrected bugs in the big-endian support for PPC440 and PPC970\n\t* DYNAMIC_ARCH support is now available in CMAKE builds as well\n\nARMV8:\n\t* performance of DGEMM_BETA and SGEMM_NCOPY has been improved\n\t* compilation for 32bit works again \n\t* performance of the RPCC function has been improved\n\t* improved performance on small systems\n\t* DYNAMIC_ARCH support is now available in CMAKE builds as well\n\t* cross-compilation from OSX to IOS was simplified\n \nx86_64:\n\t* a new AVX512 DGEMM kernel was added and the AVX512 SGEMM kernel\n\t  was significantly improved\n\t* optimized AVX512 kernels for CGEMM and ZGEMM have been added\n\t* AVX2 kernels for STRMM, SGEMM, and CGEMM have been significantly\n\t  sped up and optimized CGEMM3M and ZGEMM3M kernels have been added \n\t* added support for QEMU virtual cpus\n\t* a compilation problem with PGI and SUN compilers was fixed\n\t* Intel \"Goldmont plus\" is now autodetected\n\t* a potential crash on program exit on MS Windows has been fixed\n\nx86:\n\t* an unwanted case sensitivity in the implementation of LSAME\n  \t  on older 32bit AMD cpus was fixed\n\nzarch:\n\t* Z15 is now supported as Z14\n\t* DYNAMIC_ARCH is now available on ZARCH as well\n\n====================================================================\nVersion 0.3.7\n11-Aug 2019\n\ncommon:\n  * having the gmake special variables TARGET_ARCH or TARGET_MACH\n    defined no longer causes build failures in ctest or utest\n  * defining NO_AFFINITY or USE_TLS to 0 in gmake builds no longer\n    has the same effect as setting them to 1\n  * a new test program was added to allow checking the library for\n    thread safety\n  * a new option USE_LOCKING was added to ensure thread safety when\n    OpenBLAS itself is built without multithreading but will be \n    called from multiple threads.\n  * a build failure on Linux with glibc versions earlier than 2.5\n    was fixed\n  * a runtime error with CPU enumeration (and NO_AFFINITY not set)\n    on glibc 2.6 was fixed\n  * NO_AFFINITY was added to the CMAKE options (and defaults to being\n    active on Linux, as in the gmake builds)\n\nx86_64:\n  * the build-time logic for detection of AVX512 availability in\n    the processor and compiler was fixed\n  * gmake builds on OSX now set the internal name of the library to \n    libopenblas.0.dylib (consistent with CMAKE)\n  * the Haswell DGEMM kernel received a significant speedup through\n    improved prefetch and load instructions\n  * performance of DGEMM, DTRMM, DTRSM and ZDOT on Zen/Zen2 was markedly\n    increased by avoiding vpermpd instructions\n  * the SKYLAKEX (AVX512) DGEMM helper functions have now been disabled\n    to fix remaining errors in DGEMM, DSYMM and DTRMM\n\nPOWER:\n  * added support for building on FreeBSD/powerpc64 and FreeBSD/ppc970\n  * added optimized kernels for POWER9 SGEMM and STRMM\n\nARMV7:\n  * fixed the softfp implementations of xAMAX and IxAMAX\n  * removed the predefined -march= flags on both ARMV5 and ARMV6 as\n    they were appropriate for only a subset of platforms\n\n====================================================================\nVersion 0.3.6\n29-Apr-2019\n\ncommon:\n\t* the build tools now check that a given cpu TARGET is actually valid\n\t* the build-time check of system features (c_check) has been made\n  \t  less dependent on particular perl features (this should mainly\n  \t  benefit building on Windows)\n\t* several problem with the ReLAPACK integration were fixed,\n\t  including INTERFACE64 support and building a shared library\n\t* building with CMAKE on BSD systems was improved\n\t* a non-absolute SUM function was added based on the\n  \t  existing optimized code for ASUM\n\t* CBLAS interfaces to the IxMIN and IxMAX functions were added\n\t* a name clash between LAPACKE and BOOST headers was resolved\n\t* CMAKE builds with OpenMP failed to include the appropriate getrf_parallel\n\t  kernels\n\t* a crash on thread (key) deletion with the USE_TLS=1 memory management\n\t  option was fixed\n\t* restored several earlier fixes, in particular for OpenMP performance,\n  \t  building on BSD, and calling fork on CYGWIN, which had inadvertently\n  \t  been dropped in the 0.3.3 rewrite of the memory management code.\n\nx86_64:\n\t* the AVX512 DGEMM kernel has been disabled again due to unsolved problems\n\t* building with old versions of MSVC was fixed\n\t* it is now possible to build a static library on Windows with CMAKE\n\t* accessing environment variables on CYGWIN at run time was fixed\n\t* the CMAKE build system now recognizes 32bit userspace on 64bit hardware\n\t* Intel \"Denverton\" atom and Hygon \"Dhyana\" zen CPUs are now autodetected\n\t* building for DYNAMIC_ARCH with a DYNAMIC_LIST of targets is now supported\n  \t  with CMAKE as well\n\t* building for DYNAMIC_ARCH with GENERIC as the default target is now supported\n\t* a buffer overflow in the SSE GEMM kernel for Intel Nano targets was fixed\n\t* assembly bugs involving undeclared modification of input operands were fixed\n  \t  in the AXPY, DOT, GEMV, GER, SCAL, SYMV and TRSM microkernels for Nehalem,\n\t  Sandybridge, Haswell, Bulldozer and Piledriver. These would typically cause\n\t  test failures or segfaults when compiled with recent versions of gcc from 8 onward.\n\t* a similar bug was fixed in the blas_quickdivide code used to split workloads\n\t  in most functions\n\t* a bug in the IxMIN implementation for the GENERIC target made it return the result of IxMAX\n\t* fixed building on SkylakeX systems when either the compiler or the (emulated) operating\n\t  environment does not support AVX512\n\t* improved GEMM performance on ZEN targets\n\nx86:\n\t* build failures caused by the recently added checks for AVX512 were fixed\n\t* an inline assembly bug involving undeclared modification of an input argument was\n  \t  fixed in the blas_quickdivide code used to split workloads in most functions\n\t* a bug in the IMIN implementation for the GENERIC target made it return the result of IMAX\n\nMIPS32:\n\t* a bug in the IMIN implementation made it return the result of IMAX\n\nPOWER:\n\t* single precision BLAS1/2 functions have received optimized POWER8 kernels\n\t* POWER9 is now a separate target, with an optimized DGEMM/DTRMM kernel\n\t* building on PPC970 systems under OSX Leopard or Tiger is now supported\n\t* out-of-bounds memory accesses in the gemm_beta microkernels were fixed\n\t* building a shared library on AIX is now supported for POWER6\n\t* DYNAMIC_ARCH support has been added for POWER6 and newer\n\nARMv7:\n\t* corrected xDOT behaviour with zero INC_X or INC_Y\n\t* a bug in the IMIN implementation made it return the result of IMAX\n\nARMv8:\n\t* added support for HiSilicon TSV110 cpus\n\t* the CMAKE build system now recognizes 32bit userspace on 64bit hardware\n\t* cross-compilation with CMAKE now works again\n\t* a bug in the IMIN implementation made it return the result of IMAX\n\t* ARMV8 builds with the BINARY=32 option are now automatically handled as ARMV7\n\nIBM Z:\n\t* optimized microkernels for single precicion BLAS1/2 functions have been added\n\t  for both Z13 and Z14\n\n====================================================================\nVersion 0.3.5\n31-Dec-2018\n\ncommon:\n\t* loop unrolling in TRMV has been enabled again.\n\t* A domain error in the thread workload distribution for SYRK\n\t  has been fixed.\n\t* gmake builds will now automatically add -fPIC to the build\n\t  options if the platform requires it.\n\t* a pthreads key leakage (and associate crash on dlclose) in\n\t  the USE_TLS codepath was fixed.\n\t* building of the utest cases on systems that do not provide\n\t  an implementation of complex.h was fixed.\n\t  \nx86_64:\n\t* the SkylakeX code was changed to compile on OSX.\n\t* unwanted application of the -march=skylake-avx512 option\n\t  to the common code parts of a DYNAMIC_ARCH build was fixed.\n\t* improved performance of SGEMM for small workloads on Skylake X.\n\t* performance of SGEMM and DGEMM was improved on Haswell.\n\nARMV8:\n\t* a configuration error that broke the CNRM2 kernel was corrected.\n\t* compilation of the GEMM kernels with CMAKE was fixed.\n\t* DYNAMIC_ARCH builds are now available with CMAKE as well.\n\t* using CMAKE for cross-compilation to the new cpu TARGETs\n\t  introduced in 0.3.4 now works.\n\t  \nPOWER:\n\t* a problem in cpu autodetection for AIX has been corrected.\n\t\n====================================================================\nVersion 0.3.4\n02-Dec-2018\n\ncommon:\n\t* the new, experimental thread-local memory allocation had \n\t  inadvertently been left enabled for gmake builds in 0.3.3\n\t  despite the announcement. It is now disabled by default, and\n\t  single-threaded builds will keep using the old allocator even\n\t  if the USE_TLS option is turned on.\n\t* OpenBLAS will now provide enough buffer space for at least 50\n\t  threads by default.\n\t* The output of openblas_get_config() now contains the version\n\t  number.\n\t* A serious thread safety bug in GEMV operation with small M and\n\t  large N size has been fixed.\n\t* The code will now automatically call blas_thread_init after a\n\t  fork if needed before handling a call to openblas_set_num_threads\n\t* Accesses to parallelized level3 functions from multiple callers\n\t  are now serialized to avoid thread races (unless using OpenMP).\n\t  This should provide better performance than the known-threadsafe\n\t  (but non-default) USE_SIMPLE_THREADED_LEVEL3 option.\n\t* When building LAPACK with gfortran, -frecursive is now (again)\n\t  enabled by default to ensure correct behaviour.\n        * The OpenBLAS version cblas.h now supports both CBLAS_ORDER and\n\t  CBLAS_LAYOUT as the name of the matrix row/column order option.\n\t* Externally set LDFLAGS are now passed through to the final compile/link\n\t  steps to facilitate setting platform-specific linker flags.\n\t* A potential race condition during the build of LAPACK (that would \n\t  usually manifest itself as a failure to build TESTING/MATGEN) has been \n\t  fixed.\n\t* xHEMV has been changed to stay single-threaded for small input sizes\n\t  where the overhead of multithreading exceeds any possible gains\n\t* CSWAP and ZSWAP have been limited to a single thread except on ARMV8 or\n\t  ThunderX hardware with sizable input.\n\t* Linker flags for the PGI compiler have been updated\n\t* Behaviour of AXPY with zero increments is now handled in the C interface,\n\t  correcting the result on at least Intel Atom.\n\t* The result matrix from calling SGELSS with an all-zero input matrix is \n\t  now zeroed completely.\n\t  \nx86_64:\n\t* Autodetection of AMD Ryzen2 has been fixed (again).\n        * CMAKE builds now support labeling of an INTERFACE64=1 build of\n\t  the library with the _64 suffix.\n\t* AVX512 version of DGEMM has been added and the AVX512 SGEMM kernel\n\t  has been sped up by rewriting with C intrinsics\n\t* Fixed compilation on RHEL5/CENTOS5 (issue with typename __WAIT_STATUS)\n\t\nPOWER:\n\t* added support for building on AIX (with gcc and GNU tools from AIX Toolbox).\n\t* CPU type detection has been implemented for AIX.\n\t* CPU type detection has been fixed for NETBSD.\n\t\nMIPS64:\n\t* AXPY on LOONGSON3A has been corrected to pass \"zero increment\" utest.\n\t* DSDOT on LOONGSON3A has been fixed.\n\t* the SGEMM microkernel has been hardened against potential data loss.\n\t\nARMV8:\n\t* DYNAMic_ARCH support is now available for 64bit ARM\n\t* cross-compiling for ARMV8 under iOS now works.\n\t* cpu-specific code has been rearranged to make better use of both\n\t  hardware commonalities and model-specific compiler optimizations.\n\t* XGENE1 has been removed as a TARGET, superseded by the improved generic\n\t  ARMV8 support.\n\t\nARMV7:\n\t* Older assembly mnemonics have been converted to UAL form to allow\n\t  building with clang 7.0\n\t* Cross compiling LAPACKE for Android has been fixed again (broken by\n\t  update to LAPACK 3.7.0 some while ago).  \n\t  \n====================================================================\nVersion 0.3.3\n31-Aug-2018\n\ncommon:\n\t* thread memory allocation has been switched back to the method\n\t  used before version 0.3.1 due to unexpected problems caused by\n\t  the new code under some circumstances. A new compile-time option\n\t  USE_TLS has been added to enable the new code, and it is hoped\n\t  that this can become the default again in the next version.\n\t* LAPAck PR272 has been integrated, which fixes spurious errors\n\t  in DSYEVR and related functions caused by missing conversion \n\t  from ILAENV to ILAENV_2STAGE in several _2stage routines.\n\t* the cmake-generated OpenBLASConfig.cmake now uses correct case\n\t  for the name of the library\n\t* added support for Haiku OS  \n\nx86_64:\n\t* added AVX512 implementations of SDOT, DDOT, SAXPY, DAXPY,\n\t  DSCAL, DGEMVN and DSYMVL \n\t* added a workaround for a cygwin issue that prevented compilation\n\t  of AVX512 code\n\t  \nIBM Z:\n\t* added autodetection of Z14\n\t* fixed TRMM errors in the generic target\n\t\n====================================================================\nVersion 0.3.2\n30-Jul-2018\n\ncommon:\n\t* fixes for regressions caused by the rewrite of the thread\n\t  initialization code in 0.3.1\n\nPOWER:\n\t* fixed cpu autodetection for the BSDs\n\nMIPS64:\n\t* fixed utest errors in AXPY, DSDOT, ROT and SWAP\n\nx86_64:\n\t* added autodetection of AMD Ryzen 2\n\t* fixed build with older versions of MSVC\n\n====================================================================\nVersion 0.3.1\n01-Jul-2018\n\ncommon:\n\t* rewritten thread initialization code with significantly reduced overhead\n\t* added CBLAS interfaces to the IxAMIN BLAS extension functions\n\t* fixed the lapack-test target\n\t* CMAKE builds now create an OpenBLASConfig.cmake file\n\t* ZAXPY now uses a single thread for small input sizes\n\t* the LAPACK code was updated from Reference-LAPACK/lapack#253\n          (fixing LAPACKE interfaces to Aasen's functions)\n\nPOWER:\n\t* corrected CROT and ZROT behaviour with zero INC_X\n\nARMV7:\n\t* corrected xDOT behaviour with zero INC_X or INC_Y\n\nx86_64:\n\t* retired some older targets of DYNAMIC_ARCH builds to a new option DYNAMIC_OLDER,\n\t  this affects PENRYN,DUNNINGTON,OPTERON,OPTERON_SSE3,BOBCAT,ATOM and NANO\n\t  (which will still be supported via the slower PRESCOTT kernels when this option is not set)\n\t* added an option DYNAMIC_LIST that (used in conjunction with DYNAMIC_ARCH) allows to \n\t  specify the list of x86_64 targets to include. Any target not on the list will be supported \n\t  by the Sandybridge or Nehalem kernels if available, or by Prescott.\n\t* improved SWITCH_RATIO on Haswell for increased GEMM throughput\n\t* added initial support for Intel Skylake X, including an AVX512 SGEMM kernel\n\t* added autodetection of Intel Cannon Lake series as Skylake X\n\t* added a default L2 cache size for hypervisors that return zero here (Chromebook)\n\t* fixed a name clash with recent Windows10 headers that broke the build with (at least)\n\t  recent mingw from MSYS2\n\t* fixed a link error in mixed clang/gfortran builds with OpenMP\n\t* updated the OSX deployment target to 10.8\n\t* switched on parallel make for builds on MS Windows by default\n\nx86:\n\t* fixed SSWAP and DSWAP behaviour with zero INC_X and INC_Y\n\n====================================================================\nVersion 0.3.0\n23-May-2108\n\ncommon:\n\t* fixed some more thread race and locking bugs\n\t* added preliminary support for calling an OpenMP build of the library from multiple threads\n\t* removed performance impact of thread locks added in 0.2.20 on OpenMP code\n\t* general code cleanup \n\t* optimized DSDOT implementation\n\t* improved thread distribution for GEMM\n\t* corrected IMATCOPY/OMATCOPY implementation\n\t* fixed out-of-bounds accesses in the multithreaded xBMV/xPMV and SYMV implementations\n\t* cmake build improvements\n\t* pkgconfig file now contains build options\n\t* openblas_get_config() now reports USE_OPENMP and NUM_THREADS settings used for the build\n\t* corrections and improvements for systems with more than 64 cpus\n\t* LAPACK code updated to 3.8.0 including later fixes\n\t* added ReLAPACK, a recursive implementation of several LAPACK functions\n\t* Rewrote ROTMG to handle cases that the netlib code failed to address\n\t* Disabled (broken) multithreading code for xTRMV\n\t* corrected prototypes of complex CBLAS functions to make our cblas.h match the generally accepted standard\n\t* shared memory access failures on startup are now handled more gracefully\n\t* restored utests from earlier releases (and made them pass on all affected systems)\n\nSPARC:\n\t* several fixes for cpu autodetection\n\nPOWER:\n\t* corrected vector register overwriting in several Power8 kernels\n\t* optimized additional BLAS functions\n\nARM:\n\t* added support for CortexA53 and A72 \n\t* added autodetection for ThunderX2T99\n\t* made most optimized kernels the default for generic ARMv8 targets \n\nx86_64:\n\t* parallelized DDOT kernel for Haswell\n\t* changed alignment directives in assembly kernels to boost performance on OSX\n\t* fixed register handling in the GEMV microkernels (bug exposed by gcc7)\n\t* added support for building on OpenBSD and Dragonfly \n\t* updated compiler options to work with Intel release 2018\n\t* support fully optimized build with clang/flang on Microsoft Windows\n\t* fixed building on AIX\n\nIBM Z:\n\t* added optimized BLAS 1/2 functions\n\nMIPS:\n\t* fixed cpu autodetection helper code\n\t* added mips32 1004K cpu (Mediatek MT7621 and similar SoC)\n\t* added mips64 I6500 cpu\n\n====================================================================\nVersion 0.2.20\n24-Jul-2017\n\ncommon:\n        * Improved CMake support\n        * Fixed several thread race and locking bugs\n        * Fixed default LAPACK optimization level\n        * Updated LAPACK to 3.7.0\n        * Added ReLAPACK (https://github.com/HPAC/ReLAPACK, make BUILD_RELAPACK=1)\n\nPOWER:\n        * Optimizations for Power9\n        * Fixed several Power8 assembly bugs\n\nARM:\n        * New optimized Vulcan and ThunderX2T99 targets\n        * Support for ARMV7 SOFT_FP ABI (make ARM_SOFTFP_ABI=1)\n        * Detect all cpu cores including offline ones\n        * Fix compilation with CLANG\n        * Support building a shared library for Android\n\nMIPS:\n        * Fixed several threading issues\n        * Fix compilation with CLANG\n\nx86_64:\n        * Detect Intel Bay Trail and Apollo Lake\n        * Detect Intel Sky Lake and Kaby Lake\n        * Detect Intel Knights Landing\n        * Detect AMD A8, A10, A12 and Ryzen\n        * Support 64bit builds with Visual Studio\n        * Fix building with Intel and PGI compilers\n        * Fix building with MINGW and TDM-GCC\n        * Fix cmake builds for Haswell and related cpus\n        * Fix building for Sandybridge with CLANG 3.9\n\t* Add support for the FLANG compiler\n\nIBM Z:\n        * New target z13 with BLAS3 optimizations\n\n====================================================================\nVersion 0.2.19\n1-Sep-2016\ncommon:\n\t* Improved cross compiling.\n\t* Fix the bug on musl libc.\n\nPOWER:\n\t* Optimize BLAS on Power8\n\t* Fixed Julia+OpenBLAS bugs on Power8\n\nMIPS:\n\t* Optimize BLAS on MIPS P5600 and I6400 (Thanks, Shivraj Patil, Kaustubh Raste)\n\nARM:\n\t* Improved on ARM Cortex-A57. (Thanks, Ashwin Sekhar T K)\n\n\n====================================================================\nVersion 0.2.18\n12-Apr-2016\ncommon:\n\t* If you set MAKE_NB_JOBS flag less or equal than zero,\n\t  make will be without -j.\n\nx86/x86_64:\n\t* Support building Visual Studio static library. (#813, Thanks, theoractice)\n\t* Fix bugs to pass buidbot CI tests (http://build.openblas.net)\n\nARM:\n\t* Provide DGEMM 8x4 kernel for Cortex-A57 (Thanks, Ashwin Sekhar T K)\n\nPOWER:\n\t* Optimize S and C BLAS3 on Power8\n\t* Optimize BLAS2/1 on Power8\n\n====================================================================\nVersion 0.2.17\n20-Mar-2016\ncommon:\n\t* Enable BUILD_LAPACK_DEPRECATED=1 by default.\n\n====================================================================\nVersion 0.2.16\n15-Mar-2016\ncommon:\n\t* Avoid potential getenv segfault. (#716)\n\t* Import LAPACK svn bugfix #142-#147,#150-#155\n\nx86/x86_64:\n\t* Optimize c/zgemv for AMD Bulldozer, Piledriver, Steamroller\n\t* Fix bug with scipy linalg test.\n\nARM:\n\t* Improve DGEMM for ARM Cortex-A57. (Thanks, Ashwin Sekhar T K)\n\nPOWER:\n\t* Optimize D and Z BLAS3 functions for Power8.\n\n====================================================================\nVersion 0.2.16.rc1\n23-Feb-2016\ncommon:\n\t* Upgrade LAPACK to 3.6.0 version.\n\t  Add BUILD_LAPACK_DEPRECATED option in Makefile.rule to build\n\t  LAPACK deprecated functions.\n\t* Add MAKE_NB_JOBS option in Makefile.\n\t  Force number of make jobs.This is particularly\n\t  useful when using distcc. (#735. Thanks, Jerome Robert.)\n\t* Redesign unit test. Run unit/regression test at every build (Travis-CI and Appveyor).\n\t* Disable multi-threading for small size swap and ger. (#744. Thanks, Jerome Robert)\n\t* Improve small zger, zgemv, ztrmv using stack alloction (#727. Thanks, Jerome Robert)\n\t* Let openblas_get_num_threads return the number of active threads. \n\t  (#760. Thanks, Jerome Robert)\n\t* Support illumos(OmniOS). (#749. Thanks, Lauri Tirkkonen)\n\t* Fix LAPACK Dormbr, Dormlq bug. (#711, #713. Thanks, Brendan Tracey)\n\t* Update scipy benchmark script. (#745. Thanks, John Kirkham)\n\nx86/x86_64:\n\t* Optimize trsm kernels for AMD Bulldozer, Piledriver, Steamroller.\n\t* Detect Intel Avoton.\n\t* Detect AMD Trinity, Richland, E2-3200.\n\t* Fix gemv performance bug on Mac OSX Intel Haswell.\n\t* Fix some bugs with CMake and Visual Studio\n\nARM:\n\t* Support and optimize Cortex-A57 AArch64.\n\t  (#686. Thanks, Ashwin Sekhar TK)\n\t* Fix Android build on ARMV7 (#778. Thanks, Paul Mustiere)\n\t* Update ARMV6 kernels.\n\nPOWER:\n\t* Fix detection of POWER architecture\n\t  (#684. Thanks, Sebastien Villemot)\n\n====================================================================\nVersion 0.2.15\n27-Oct-2015\ncommon:\n\t* Support cmake on x86/x86-64. Natively compiling on MS Visual Studio.\n\t  (experimental. Thank Hank Anderson for the initial cmake porting work.)\n\t  \n\t  On Linux and Mac OSX, OpenBLAS cmake supports assembly kernels.\n\t  e.g. cmake .\n\t       make\n\t       make test (Optional)\n\n\t  On Windows MS Visual Studio, OpenBLAS cmake only support C kernels.\n\t  (OpenBLAS uses AT&T style assembly, which is not supported by MSVC.)\n\t  e.g. cmake -G \"Visual Studio 12 Win64\" .\n\t       Open OpenBLAS.sln and build.\n\t  \n\t* Enable MAX_STACK_ALLOC flags by default.\n\t  Improve ger and gemv for small matrices.\n\t* Improve gemv parallel with small m and large n case.\n\t* Improve ?imatcopy when lda==ldb (#633. Thanks, Martin Koehler)\n\t* Add vecLib benchmarks (#565. Thanks, Andreas Noack.)\n\t* Fix LAPACK lantr for row major matrices (#634. Thanks, Dan Kortschak)\n\t* Fix LAPACKE lansy (#640. Thanks, Dan Kortschak)\n\t* Import bug fixes for LAPACKE s/dormlq, c/zunmlq \n\t* Raise the signal when pthread_create fails (#668. Thanks, James K. Lowden)\n\t* Remove g77 from compiler list.\n\t* Enable AppVeyor Windows CI.\n\nx86/x86-64:\n\t* Support pure C generic kernels for x86/x86-64.\n\t* Support Intel Boardwell and Skylake by Haswell kernels.\n\t* Support AMD Excavator by Steamroller kernels.\n\t* Optimize s/d/c/zdot for Intel SandyBridge and Haswell.\n\t* Optimize s/d/c/zdot for AMD Piledriver and Steamroller.\n\t* Optimize s/d/c/zapxy for Intel SandyBridge and Haswell.\n\t* Optimize s/d/c/zapxy for AMD Piledriver and Steamroller.\n\t* Optimize d/c/zscal for Intel Haswell, dscal for Intel SandyBridge.\n\t* Optimize d/c/zscal for AMD Bulldozer, Piledriver and Steamroller.\n\t* Optimize s/dger for Intel SandyBridge.\n\t* Optimize s/dsymv for Intel SandyBridge.\n\t* Optimize ssymv for Intel Haswell.\n\t* Optimize dgemv for Intel Nehalem and Haswell.\n\t* Optimize dtrmm for Intel Haswell.\n\nARM:\n\t* Support Android NDK armeabi-v7a-hard ABI (-mfloat-abi=hard)\n\t  e.g. make HOSTCC=gcc CC=arm-linux-androideabi-gcc NO_LAPACK=1 TARGET=ARMV7\n\t* Fix lock, rpcc bugs (#616, #617. Thanks, Grazvydas Ignotas)\nPOWER:\n\t* Support ppc64le platform (ELF ABI v2. #612. Thanks, Matthew Brandyberry.)\n\t* Support POWER7/8 by POWER6 kernels. (#612. Thanks, Fábio Perez.)\n\n====================================================================\nVersion 0.2.14\n24-Mar-2015\ncommon:\n\t* Improve OpenBLASConfig.cmake. (#474, #475. Thanks, xantares.)\n\t* Improve ger and gemv for small matrices by stack allocation.\n\t  e.g. make -DMAX_STACK_ALLOC=2048 (#482. Thanks, Jerome Robert.)\n\t* Introduce openblas_get_num_threads and openblas_get_num_procs.\n\t  (#497. Thanks, Erik Schnetter.)\n\t* Add ATLAS-style ?geadd function. (#509. Thanks, Martin Köhler.)\n\t* Fix c/zsyr bug with negative incx. (#492.)\n\t* Fix race condition during shutdown causing a crash in\n\t  gotoblas_set_affinity(). (#508. Thanks, Ton van den Heuvel.)\n\nx86/x86-64:\n\t* Support AMD Streamroller.\n\nARM:\n\t* Add Cortex-A9 and Cortex-A15 targets.\n\n====================================================================\nVersion 0.2.13\n3-Dec-2014\ncommon:\n\t* Add SYMBOLPREFIX and SYMBOLSUFFIX makefile options\n\t  for adding a prefix or suffix to all exported symbol names\n\t  in the shared library.(#459, Thanks Tony Kelman)\n\t* Provide OpenBLASConfig.cmake at installation.\n\t* Fix Fortran compiler detection on FreeBSD.\n\t  (#470, Thanks Mike Nolta)\n\n\nx86/x86-64:\n\t* Add generic kernel files for x86-64. make TARGET=GENERIC\n\t* Fix a bug of sgemm kernel on Intel Sandy Bridge.\n\t* Fix c_check bug on some amd64 systems. (#471, Thanks Mike Nolta)\n\nARM:\n\t* Support APM's X-Gene 1 AArch64 processors.\n\t  Optimize trmm and sgemm. (#465, Thanks Dave Nuechterlein)\n\n====================================================================\nVersion 0.2.12\n13-Oct-2014\ncommon:\n\t* Added CBLAS interface for ?omatcopy and ?imatcopy.\n\t* Enable ?gemm3m functions.\n\t* Added benchmark for ?gemm3m.\n\t* Optimized multithreading lower limits.\n\t* Disabled SYMM3M and HEMM3M functions \n\t  because of segment violations.\n\nx86/x86-64:\n\t* Improved axpy and symv performance on AMD Bulldozer.\n\t* Improved gemv performance on modern Intel and AMD CPUs.\n\n====================================================================\nVersion 0.2.11\n18-Aug-2014\ncommon:\n\t* Added some benchmark codes.\n\t* Fix link error on Linux/musl.(Thanks Isaac Dunham)\n\nx86/x86-64:\n\t* Improved s/c/zgemm performance for Intel Haswell.\n\t* Improved s/d/c/zgemv performance.\n\t* Support the big numa machine.(EXPERIMENT)\n\nARM:\n\t* Fix detection when cpuinfo uses \"Processor\". (Thanks Isaiah)\n\n====================================================================\nVersion 0.2.10\n16-Jul-2014\ncommon:\n\t* Added BLAS extensions as following.\n\t  s/d/c/zaxpby, s/d/c/zimatcopy, s/d/c/zomatcopy.\n\t* Added OPENBLAS_CORETYPE environment for dynamic_arch. (a86d34)\n\t* Added NO_AVX2 flag for old binutils. (#401)\n\t* Support outputing the CPU corename on runtime.(#407)\n\t* Patched LAPACK to fix bug 114, 117, 118. \n\t  (http://www.netlib.org/lapack/bug_list.html)\n\t* Disabled ?gemm3m for a work-around fix. (#400)\nx86/x86-64:\n\t* Fixed lots of bugs for optimized kernels on sandybridge,Haswell, \n\t  bulldozer, and piledriver.\n\t  https://github.com/xianyi/OpenBLAS/wiki/Fixed-optimized-kernels-To-do-List\n\nARM:\n\t* Improved LAPACK testing.\n\n====================================================================\nVersion 0.2.9\n10-Jun-2014\ncommon:\n\t* Improved the result for LAPACK testing. (#372)\n\t* Installed DLL to prefix/bin instead of prefix/lib. (#366)\n\t* Build import library on Windows.(#374)\nx86/x86-64:\n\t* To improve LAPACK testing, we fallback some kernels. (#372)\n\thttps://github.com/xianyi/OpenBLAS/wiki/Fixed-optimized-kernels-To-do-List\n\n====================================================================\nVersion 0.2.9.rc2\n06-Mar-2014\ncommon:\n\t* Added OPENBLAS_VERBOSE environment variable.(#338)\n\t* Make OpenBLAS thread-pool resilient to fork via pthread_atfork.\n\t  (#294, Thank Olivier Grisel)\n\t* Rewrote rotmg\n\t* Fixed sdsdot bug.\nx86/x86-64:\n\t* Detect Intel Haswell for new Macbook.\n\n====================================================================\nVersion 0.2.9.rc1\n13-Jan-2013\ncommon:\n\t* Update LAPACK to 3.5.0 version\n\t* Fixed compatiable issues with Clang and Pathscale compilers.\n\nx86/x86-64:\n\t* Optimization on Intel Haswell.\n\t* Enable optimization kernels on AMD Bulldozer and Piledriver.\n\nARM:\n\t* Support ARMv6 and ARMv7 ISA.\n\t* Optimization on ARM Cortex-A9.\n\n====================================================================\nVersion 0.2.8\n01-Aug-2013\ncommon:\n\t* Support Open64 5.0. (#266)\n\t* Add executable stack markings. (#262, Thank Sébastien Fabbro)\n\t* Respect user's LDFLAGS (Thank Sébastien Fabbro)\n\nx86/x86-64:\n\t* Rollback bulldozer and piledriver kernels to barcelona kernels (#263)\n\t  We will fix the compuational error bug in bulldozer and piledriver kernels.\n\n====================================================================\nVersion 0.2.7\n20-Jul-2013\ncommon:\n\t* Support LSB (Linux Standard Base) 4.1.\n          e.g. make CC=lsbcc\n\t* Include LAPACK 3.4.2 source codes to the repo.\n          Avoid downloading at compile time.\n\t* Add NO_PARALLEL_MAKE flag to disable parallel make.\n        * Create openblas_get_parallel to retrieve information which\n          parallelization model is used by OpenBLAS. (Thank grisuthedragon)\n\t* Detect LLVM/Clang compiler. The default compiler is Clang on Mac OS X.\n        * Change LIBSUFFIX from .lib to .a on windows.\n\t* A work-around for dtrti_U single thread bug. Replace it with LAPACK codes. (#191)\n\nx86/x86-64:\n\t* Optimize c/zgemm, trsm, dgemv_n, ddot, daxpy, dcopy on\n          AMD Bulldozer. (Thank Werner Saar)\n        * Add Intel Haswell support (using Sandybridge optimizations).\n          (Thank Dan Luu)\n\t* Add AMD Piledriver support (using Bulldozer optimizations).\n        * Fix the computational error in zgemm avx kernel on\n          Sandybridge. (#237)\n        * Fix the overflow bug in gemv.\n\t* Fix the overflow bug in multi-threaded BLAS3, getrf when NUM_THREADS\n          is very large.(#214, #221, #246).\nMIPS64:\n        * Support loongcc (Open64 based) compiler for ICT Loongson 3A/B.\n\nPower:\n        * Support Power7 by old Power6 kernels. (#220)\n\n====================================================================\nVersion 0.2.6\n2-Mar-2013\ncommon:\n\t* Improved OpenMP performance slightly. (d744c9)\n\t* Improved cblas.h compatibility with Intel MKL.(#185)\n\t* Fixed the overflowing bug in single thread cholesky factorization.\n\t* Fixed the overflowing buffer bug of multithreading hbmv and sbmv.(#174)\n\nx86/x86-64:\n\t* Added AMD Bulldozer x86-64 S/DGEMM AVX kernels. (Thank Werner Saar)\n\t  We will tune the performance in future.\n\t* Auto-detect Intel Xeon E7540.\n\t* Fixed the overflowing buffer bug of gemv. (#173)\n\t* Fixed the bug of s/cdot about invalid reading NAN on x86_64. (#189)\n\nMIPS64:\n\n====================================================================\nVersion 0.2.5\n26-Nov-2012\ncommon:\n\t* Added NO_SHARED flag to disable generating the shared library.\n\t* Compile LAPACKE with ILP64 modle when INTERFACE64=1 (#158)\n\t* Export LAPACK 3.4.2 symbols in shared library. (#147)\n\t* Only detect the number of physical CPU cores on Mac OSX. (#157)\n\t* Fixed NetBSD build. (#155)\n\t* Fixed compilation with TARGET=GENERIC. (#160)\nx86/x86-64:\n\t* Restore the original CPU affinity when calling\n\t  openblas_set_num_threads(1) (#153)\n\t* Fixed a SEGFAULT bug in dgemv_t when m is very large.(#154)\nMIPS64:\n\n====================================================================\nVersion 0.2.4\n8-Oct-2012\ncommon:\n\t* Upgraded LAPACK to 3.4.2 version. (#145)\n\t* Provided support for passing CFLAGS, FFLAGS, PFLAGS,\n\t  FPFLAGS to make. (#137)\n\t* f77blas.h:compatibility for compilers without C99 complex\n\t  number support. (#141)\nx86/x86-64:\n\t* Added NO_AVX flag. Check OS supporting AVX on runtime. (#139)\n\t* Fixed zdot incompatibility ABI issue with GCC 4.7 on\n\t  Windows 32-bit. (#140)\nMIPS64:\n\t* Fixed the generation of shared library bug.\n\t* Fixed the detection bug on the Loongson 3A server.\n====================================================================\nVersion 0.2.3\n20-Aug-2012\ncommon:\n\t* Fixed LAPACK unstable bug about ?laswp. (#130)\n\t* Fixed the shared library bug about unloading the library on\n\t  Linux (#132).\n\t* Fixed the compilation failure on BlueGene/P (TARGET=PPC440FP2)\n\t  Please use gcc and IBM xlf. (#134)\nx86/x86-64:\n\t* Supported goto_set_num_threads and openblas_set_num_threads\n\t  APIs in Windows. They can set the number of threads on runtime.\n\n====================================================================\nVersion 0.2.2\n6-July-2012\ncommon:\n\t* Fixed exporting DLL functions bug on Windows/MingW\n\t* Support GNU Hurd (Thank Sylvestre Ledru)\n\t* Support kfreebsd kernel (Thank Sylvestre Ledru)\nx86/x86-64:\n\t* Support Intel Sandy Bridge 22nm desktop/mobile CPU\nSPARC:\n\t* Improve the detection of SPARC (Thank Sylvestre Ledru)\n\n====================================================================\nVersion 0.2.1\n30-Jun-2012\ncommon:\nx86/x86-64:\n\t* Fixed the SEGFAULT bug about hyper-theading\n\t* Support AMD Bulldozer by using GotoBLAS2 AMD Barcelona codes\n\n====================================================================\nVersion 0.2.0\n26-Jun-2012\ncommon:\n\t* Removed the limitation (64) of numbers of CPU cores.\n\t  Now, it supports 256 cores at max.\n\t* Supported clang compiler.\n\t* Fixed some build bugs on FreeBSD\nx86/x86-64:\n\t* Optimized Level-3 BLAS on Intel Sandy Bridge x86-64 by AVX instructions.\n\t  Please use gcc >= 4.6 or clang >=3.1.\n\t* Support AMD Bobcat by using GotoBLAS2 AMD Barcelona codes.\n\n====================================================================\nVersion 0.1.1\n29-Apr-2012\ncommon:\n\t* Upgraded LAPACK to 3.4.1 version. (Thank Zaheer Chothia)\n\t* Supported LAPACKE, a C interface to LAPACKE. (Thank Zaheer Chothia)\n\t* Fixed the build bug (MD5 and download) on Mac OSX.\n\t* Auto download CUnit 2.1.2-2 from SF.net with UTEST_CHECK=1.\n\t* Fxied the compatibility issue for compilers without C99 complex number\n\t  (e.g. Visual Studio)\nx86/x86_64:\n\t* Auto-detect Intel Sandy Bridge Core i7-3xxx & Xeon E7 Westmere-EX.\n\t* Test alpha=Nan in dscale.\n\t* Fixed a SEGFAULT bug in samax on x86 windows.\n\n====================================================================\nVersion 0.1.0\n23-Mar-2012\ncommon:\n\t* Set soname of shared library on Linux.\n\t* Added LIBNAMESUFFIX flag in Makefile.rule. The user can use\n\t  this flag to control the library name, e.g. libopenblas.a,\n\t  libopenblas_ifort.a or libopenblas_omp.a.\n\t* Added GEMM_MULTITHREAD_THRESHOLD flag in Makefile.rule.\n\t  The lib use single thread in GEMM function with small matrices.\nx86/x86_64:\n\t* Used GEMV SSE/SSE2 kernels on x86 32-bit.\n\t* Exported CBLAS functions in Windows DLL.\nMIPS64:\n\t* Completed Level-3 BLAS optimization on Loongson 3A CPU.\n\t* Improved GEMV performance on Loongson 3A CPU.\n\t* Improved Level-3 BLAS performance on Loongson 3B CPU. (EXPERIMENT)\n\n====================================================================\nVersion 0.1 alpha2.5\n19-Feb-2012\ncommon:\n\t* Fixed missing \"#include <sched.h>\" bug on Mac OS X.\n\t  Thank Mike Nolta for the patch.\n\t* Upgraded LAPACK to 3.4.0 version\n\t* Fixed a bug on Mac OS X. Don't require SystemStubs on OS X.\n\t  SystemStubs does not exist on Lion. Thank Stefan Karpinski.\n\t* Improved README with using OpenMP. Check the internal threads\n\t  count less than or equal to omp_get_max_threads()\nx86/x86_64:\n\t* Auto-detect Intel Core i6/i7 (Sandy Bridge) CPU with Nehalem assembly kernels\n\t* Fixed some bugs on MingW 64-bit including zgemv, cdot, zdot.\n\n====================================================================\nVersion 0.1 alpha2.4\n18-Sep-2011\ncommon:\n\t* Fixed a bug about installation. The header file \"fblas77.h\"\n\t  works fine now.\n\t* Fixed #61 a building bug about setting TARGET and DYNAMIC_ARCH.\n\t* Try to handle absolute path of shared library in OSX. (#57)\n\t  Thank Dr Kane O'Donnell.\n\t* Changed the installation folder layout to $(PREFIX)/include and\n\t  $(PREFIX)/lib\n\nx86/x86_64:\n\t* Fixed #58 zdot/xdot SEGFAULT bug with GCC-4.6 on x86. According\n\t  to i386 calling convention, The callee should remove the first\n\t  hidden parameter.Thank Mr. John for this patch.\n\n====================================================================\nVersion 0.1 alpha2.3\n5-Sep-2011\n\nx86/x86_64:\n\t*  Added DTB_ENTRIES into dynamic arch setting parameters. Now,\n\t   it can read DTB_ENTRIES on runtime. (Refs issue #55 on github)\n\n====================================================================\nVersion 0.1 alpha2.2\n14-Jul-2011\n\ncommon:\n\t* Fixed a building bug when DYNAMIC_ARCH=1 & INTERFACE64=1.\n\t  (Refs issue #44 on github)\n\n====================================================================\nVersion 0.1 alpha2.1\n28-Jun-2011\n\ncommon:\n\t* Stop the build and output the error message when detecting\n\t  fortran compiler failed. (Refs issue #42 on github)\n\n====================================================================\nVersion 0.1 alpha2\n23-Jun-2011\n\ncommon:\n\t* Fixed blasint undefined bug in <cblas.h> file. Other software\n\t  could include this header successfully(Refs issue #13 on github)\n\t* Fixed the SEGFAULT bug on 64 cores. On SMP server, the number\n\t  of CPUs or cores should be less than or equal to 64.(Refs issue #14\n\t  on github)\n\t* Support \"void goto_set_num_threads(int num_threads)\" and \"void\n\t  openblas_set_num_threads(int num_threads)\" when USE_OPENMP=1\n\t* Added extern \"C\" to support C++. Thank Tasio for the patch(Refs\n\t  issue #21 on github)\n\t* Provided an error message when the arch is not supported.(Refs\n\t  issue #19 on github)\n\t* Fixed issue #23. Fixed a bug of f_check script about generating link flags.\n\t* Added openblas_set_num_threads for Fortran.\n\t* Fixed #25 a wrong result of rotmg.\n\t* Fixed a bug about detecting underscore prefix in c_check.\n\t* Print the wall time (cycles) with enabling FUNCTION_PROFILE\n\t* Fixed #35 a build bug with NO_LAPACK=1 & DYNAMIC_ARCH=1\n\t* Added install target. You can use \"make install\". (Refs #20)\n\n\nx86/x86_64:\n\t* Fixed #28 a wrong result of dsdot on x86_64.\n\t* Fixed #32 a SEGFAULT bug of zdotc with gcc-4.6.\n\t* Fixed #33 ztrmm bug on Nehalem.\n\t* Work-around #27 the low performance axpy issue with small imput size & multithreads.\n\nMIPS64:\n\t* Fixed #28 a wrong result of dsdot on Loongson3A/MIPS64.\n\t* Optimized single/double precision BLAS Level3 on Loongson3A/MIPS64. (Refs #2)\n\t* Optimized single/double precision axpy function on Loongson3A/MIPS64. (Refs #3)\n\n====================================================================\nVersion 0.1 alpha1\n20-Mar-2011\n\ncommon:\n\t* Support \"make  NO_LAPACK=1\" to build the library without\n\t  LAPACK functions.\n\t* Fixed randomly SEGFAULT when nodemask==NULL with above Linux 2.6.34.\n\t  Thank Mr.Ei-ji Nakama providing this patch. (Refs issue #12 on github)\n\t* Added DEBUG=1 rule in Makefile.rule to build debug version.\n\t* Disable compiling quad precision in reference BLAS library(netlib BLAS).\n\t* Added unit testcases in utest/ subdir. Used  CUnit framework.\n\t* Supported OPENBLAS_* & GOTO_* environment variables (Pleas see README)\n\t* Imported GotoBLAS2 1.13 BSD version\n\nx86/x86_64:\n\t* On x86 32bits, fixed a bug in zdot_sse2.S line 191. This would casue\n\t  zdotu & zdotc failures. Instead, work-around it. (Refs issue #8 #9 on github)\n\t* Modified ?axpy functions to return same netlib BLAS results\n\t  when incx==0 or incy==0 (Refs issue #7 on github)\n\t* Modified ?swap functions to return same netlib BLAS results\n\t  when incx==0 or incy==0 (Refs issue #6 on github)\n\t* Modified ?rot functions to return same netlib BLAS results\n\t  when incx==0 or incy==0 (Refs issue #4 on github)\n\t* Detect Intel Westmere,Intel Clarkdale and Intel Arrandale\n\t  to use Nehalem codes.\n\t* Fixed a typo bug about compiling dynamic ARCH library.\nMIPS64:\n\t* Improve daxpy performance on ICT Loongson 3A.\n\t* Supported ICT Loongson 3A CPU (Refs issue #1 on github)\n====================================================================\n"
        },
        {
          "name": "GotoBLAS_00License.txt",
          "type": "blob",
          "size": 1.5703125,
          "content": "\nCopyright 2009, 2010 The University of Texas at Austin.\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   1. Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n\n   2. Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in\n      the documentation and/or other materials provided with the\n      distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF TEXAS AT AUSTIN ``AS IS''\nAND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT  LIMITED TO,\nTHE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS  FOR A PARTICULAR\nPURPOSE ARE  DISCLAIMED.  IN NO EVENT  SHALL THE UNIVERSITY  OF TEXAS AT\nAUSTIN OR  CONTRIBUTORS BE LIABLE FOR ANY  DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\nTO, PROCUREMENT OF  SUBSTITUTE GOODS OR SERVICES; LOSS  OF USE, DATA, OR\nPROFITS; OR BUSINESS  INTERRUPTION) HOWEVER CAUSED AND ON  ANY THEORY OF\nLIABILITY,  WHETHER IN  CONTRACT, STRICT  LIABILITY, OR  TORT (INCLUDING\nNEGLIGENCE  OR OTHERWISE)  ARISING IN  ANY WAY  OUT OF  THE USE  OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nThe views and conclusions contained in the software and documentation\nare those of the authors and should not be interpreted as representing\nofficial policies, either expressed or implied, of The University of\nTexas at Austin.\n"
        },
        {
          "name": "GotoBLAS_01Readme.txt",
          "type": "blob",
          "size": 1.99609375,
          "content": "              Optimized GotoBLAS2 libraries version 1.13\n\n                       By Kazushige Goto <kgoto@tacc.utexas.edu>\n\n# This is the last update and done on 5th Feb. 2010.\n\n0. License\n\n   See 00TACC_Research_License.txt.\n\n1. Supported OS\n\n     Linux\n     FreeBSD(Also it may work on NetBSD)\n     OSX\n     Soralis\n     Windows 2k, XP, Server 2003 and 2008(both 32bit and 64bit)\n     AIX\n     Tru64 UNIX\n\n2. Supported Architecture\n\n    X86  : Pentium3 Katmai\n                    Coppermine\n           Athlon  (not well optimized, though)\n           PentiumM Banias, Yonah\n           Pentium4 Northwood\n                    Nocona (Prescott)\n\t   Core 2   Woodcrest\n\t   Core 2   Penryn\n           Nehalem-EP  Corei{3,5,7}\n\t   Atom\n           AMD Opteron\n\t   AMD Barlcelona, Shanghai, Istanbul\n\t   VIA NANO\n\n   X86_64: Pentium4 Nocona\n\t   Core 2   Woodcrest\n\t   Core 2   Penryn\n           Nehalem\n\t   Atom\n           AMD Opteron\n\t   AMD Barlcelona, Shanghai, Istanbul\n\t   VIA NANO\n\n   IA64  : Itanium2\n\n   Alpha : EV4, EV5, EV6\n\n   POWER : POWER4\n           PPC970/PPC970FX\n           PPC970MP\n\t   CELL (PPU only)\n           POWER5\n           PPC440   (QCDOC)\n           PPC440FP2(BG/L)\n\t   POWERPC G4(PPC7450)\n           POWER6\n\n   SPARC : SPARC IV\n           SPARC VI, VII (Fujitsu chip)\n\n   MIPS64/32: Sicortex\n\n3. Supported compiler\n\n   C compiler       : GNU CC\n                      Cygwin, MinGW\n                      Other commercial compiler(especially for x86/x86_64)\n\n   Fortran Compiler : GNU G77, GFORTRAN\n\t\t      G95\n\t\t      Open64\n                      Compaq\n                      F2C\n                      IBM\n                      Intel\n                      PathScale\n                      PGI\n                      SUN\n                      Fujitsu\n\n4. Supported precision\n\n Now x86/x86_64 version support 80bit FP precision in addition to\nnormal double presicion and single precision. Currently only\ngfortran supports 80bit FP with \"REAL*10\".\n\n\n5. How to build library?\n\n Please see 02QuickInstall.txt or just type \"make\".\n\n"
        },
        {
          "name": "GotoBLAS_02QuickInstall.txt",
          "type": "blob",
          "size": 3.61328125,
          "content": "                Quick installation for GotoBLAS2\n\n***************************************************************************\n***************************************************************************\n**                                                                       **\n**                                                                       **\n**                    Just type \"make\" <<return>>.                       **\n**                                                                       **\n**           If you're not satisfied with this library,                  **\n**           please read following instruction and customize it.         **\n**                                                                       **\n**                                                                       **\n***************************************************************************\n***************************************************************************\n\n\n1. REALLY REALLY quick way to build library\n\n    Type \"make\" or \"gmake\".\n\n   $shell> make\n\n   The script will detect Fortran compiler, number of cores and\n   architecture which you're using. If default gcc binary type is\n   64bit, 64 bit library will be created. Otherwise 32 bit library\n   will be created.\n\n   After finishing compile, you'll find various information about\n   generated library.\n\n =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n\n GotoBLAS2 build complete.\n\n  OS               ... Linux\n  Architecture     ... x86_64\n  BINARY           ... 64bit\n  C compiler       ... GCC  (command line : gcc)\n  Fortran compiler ... PATHSCALE  (command line : pathf90)\n  Library Name     ... libgoto_barcelonap-r1.27.a (Multi threaded; Max\n  num-threads is 16)\n\n =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n\n\n2. Specifying 32bit or 64bit library\n\n   If you need 32bit binary,\n\n   $shell> make BINARY=32\n\n   If you need 64bit binary,\n\n   $shell> make BINARY=64\n\n\n3. Specifying target architecture\n\n   If you need library for different architecture, you can use TARGET\n   option. You can find current available options in top of getarch.c.\n   For example, if you need library for Intel core2 architecture,\n   you'll find FORCE_CORE2 option in getarch.c. Therefore you can\n   specify TARGET=CORE2 (get rid of FORCE_) with make.\n\n   $shell> make TARGET=CORE2\n\n   Also if you want GotoBLAS2 to support multiple architecture,\n\n   $shell> make DYNAMIC_ARCH=1\n\n   All kernel will be included in the library and dynamically switched\n   the best architecutre at run time.\n\n\n4. Specifying for enabling multi-threaded\n\n   Script will detect number of cores and will enable multi threaded\n   library if number of cores is more than two. If you still want to\n   create single threaded library,\n\n   $shell> make USE_THREAD=0\n\n   Or if you need threaded library by force,\n\n   $shell> make USE_THREAD=1\n\n\n5. Specifying target OS\n\n   Target architecture will be determined by the CC. If you\n   specify cross compiler for MIPS, you can create library for\n   MIPS architecture.\n\n   $shell> make CC=mips64el-linux-gcc TARGET=SICORTEX\n\n   Or you can specify your favorite C compiler with absolute path.\n\n   $shell> make CC=/opt/intel/cc/32/10.0.026/bin/icc TARGET=BARCELONA\n\n   Binary type (32bit/64bit) is determined by checking CC, you\n   can control binary type with this option.\n\n   $shell> make CC=\"pathcc -m32\"\n\n   In this case, 32bit library will be created.\n\n\n6. Specifying Fortran compiler\n\n   If you need to support other Fortran compiler, you can specify with\n   FC option.\n\n   $shell> make FC=gfortran\n\n\n7. Other useful options\n\n   You'll find other useful options in Makefile.rule.\n"
        },
        {
          "name": "GotoBLAS_03FAQ.txt",
          "type": "blob",
          "size": 4.552734375,
          "content": "\tGotoBLAS2 FAQ\n\n1. General\n\n1.1  Q Can I find useful paper about GotoBLAS2?\n\n     A You may check following URL.\n\n     http://www.cs.utexas.edu/users/flame/Publications/index.htm\n\n    11. Kazushige Goto and Robert A. van de Geijn, \" Anatomy of\n\tHigh-Performance Matrix Multiplication,\" ACM Transactions on\n\tMathematical Software, accepted.\n\n    15. Kazushige Goto and Robert van de Geijn, \"High-Performance\n        Implementation of the Level-3 BLAS.\" ACM Transactions on\n        Mathematical Software, submitted.\n\n\n1.2  Q Does GotoBLAS2 work with Hyperthread (SMT)?\n\n     A Yes, it will work. GotoBLAS2 detects Hyperthread and\n       avoid scheduling on the same core.\n\n\n1.3  Q When I type \"make\", following error occured. What's wrong?\n\n\t$shell> make\n\t\"./Makefile.rule\", line 58: Missing dependency operator\n\t\"./Makefile.rule\", line 61: Need an operator\n\t...\n\n     A This error occurs because you didn't use GNU make. Some binary\n       packages install GNU make as \"gmake\" and it's worth to try.\n\n\n1.4  Q Function \"xxx\" is slow. Why?\n\n     A Generally GotoBLAS2 has many well optimized functions, but it's\n       far and far from perfect. Especially Level 1/2 function\n       performance depends on how you call BLAS. You should understand\n       what happends between your function and GotoBLAS2 by using profile\n       enabled version or hardware performance counter. Again, please\n       don't regard GotoBLAS2 as a black box.\n\n\n1.5  Q I have a commercial C compiler and want to compile GotoBLAS2 with\n       it. Is it possible?\n\n     A All function that affects performance is written in assembler\n       and C code is just used for wrapper of assembler functions or\n       complicated functions. Also I use many inline assembler functions,\n       unfortunately most of commercial compiler can't handle inline\n       assembler. Therefore you should use gcc.\n\n\n1.6  Q I use OpenMP compiler. How can I use GotoBLAS2 with it?\n\n     A Please understand that OpenMP is a compromised method to use\n       thread. If you want to use OpenMP based code with GotoBLAS2, you\n       should enable \"USE_OPENMP=1\" in Makefile.rule.\n\n\n1.7  Q Could you tell me how to use profiled library?\n\n     A You need to build and link your application with -pg\n       option. After executing your application, \"gmon.out\" is\n       generated in your current directory.\n\n       $shell> gprof <your application name> gmon.out\n\n       Each sample counts as 0.01 seconds.\n\t %   cumulative   self              self     total\n\ttime   seconds   seconds    calls  Ks/call  Ks/call  name\n\t89.86    975.02   975.02    79317     0.00     0.00  .dgemm_kernel\n\t 4.19   1020.47    45.45       40     0.00     0.00  .dlaswp00N\n\t 2.28   1045.16    24.69     2539     0.00     0.00  .dtrsm_kernel_LT\n\t 1.19   1058.03    12.87    79317     0.00     0.00  .dgemm_otcopy\n\t 1.05   1069.40    11.37     4999     0.00     0.00  .dgemm_oncopy\n       ....\n\n       I think profiled BLAS library is really useful for your\n       research. Please find bottleneck of your application and\n       improve it.\n\n1.8  Q Is number of thread limited?\n\n     A Basically, there is no limitation about number of threads. You\n       can specify number of threads as many as you want, but larger\n       number of threads will consume extra resource. I recommend you to\n       specify minimum number of threads.\n\n1.9  Q I have segfaults when I compile with USE_OPENMP=1. What's wrong?\n\n     A This may be related to a bug in the Linux kernel 2.6.32. Try applying\n     the patch segaults.patch using\n\n     patch < segfaults.patch\n\n     and see if the crashes persist. Note that this patch will lead to many\n     compiler warnings.\n\n2. Architecture Specific issue or Implementation\n\n2.1 Q GotoBLAS2 seems to support any combination with OS and\n      architecture. Is it possible?\n\n    A Combination is limited by current OS and architecture. For\n      examble, the combination OSX with SPARC is impossible. But it\n      will be possible with slight modification if these combination\n      appears in front of us.\n\n\n2.2 Q I have POWER architecture systems. Do I need extra work?\n\n    A Although POWER architecture defined special instruction\n      like CPUID to detect correct architecture, it's privileged\n      and can't be accessed by user process. So you have to set\n      the architecture that you have manually in getarch.c.\n\n\n2.3 Q I can't create DLL on Cygwin (Error 53). What's wrong?\n\n    A You have to make sure if lib.exe and mspdb80.dll are in Microsoft\n      Studio PATH. The easiest way is to use 'which' command.\n\n    $shell> which lib.exe\n    /cygdrive/c/Program Files/Microsoft Visual Studio/VC98/bin/lib.exe\n"
        },
        {
          "name": "GotoBLAS_04FAQ.txt",
          "type": "blob",
          "size": 0.2890625,
          "content": "\nQuick guide to build library for Windows 64bit.\n\n1. What you need\n\n a. Windows Server 2003 or later\n b. Cygwin environment(make, gcc, g77, perl, sed, wget)\n c. MinGW64 compiler\n d. Microsoft Visual Studio (lib.exe and mspdb80.dll are required to create dll)\n\n2. Do ./quickbuild.win64\n\nGood luck\n"
        },
        {
          "name": "GotoBLAS_05LargePage.txt",
          "type": "blob",
          "size": 1.482421875,
          "content": " To enhance perfomance, I'd recommend you to enable large page on\n your OS (root account is required).\n\n  A) Linux\n\n    x86   32bit    ... (number of core) * 4 pages\n    x86   64bit    ... (number of core) * 8 pages\n    POWER 32/64bit ... (number of core) * 1 pages\n\n    If you want to allocate 64 large pages,\n\n    $shell> echo  0 > /proc/sys/vm/nr_hugepages\t\t# need to be reset\n    $shell> echo 65 > /proc/sys/vm/nr_hugepages\t\t# add 1 extra page\n    $shell> echo 3355443200 > /proc/sys/kernel/shmmax   # just large number\n    $shell> echo 3355443200 > /proc/sys/kernel/shmall\n\n    Also may add a few lines into /etc/security/limits.conf file.\n\n    *       hard    memlock          unlimited\n    *       soft    memlock          unlimited\n\n    Then restart sshd (/etc/init.d/sshd restart).\n\n  B) Solaris\n\n    You don't have to set up.\n\n  C) Windows (Windows Server 2003 or later, XP 64bit)\n\n    You have to assign memory lock operation to your account.\n\n     Control Panel -> Administrative Tools -> Local Security Policy ->\n     Local Policies -> User Rights Assignment -> Lock pages in memory\n\n  D) AIX\n\n    Ask your administrator\n\n  E) Tru64 UNIX\n\n    Assign shared memory at boot time.\n\n  F) Other aarchitecture which doesn't have Large TLB enhancement\n\n   If you have root permission, please install device driver which\n   located in drivers/mapper.\n\n   $shell> cd drivers/mapper\n   $shell> make\n   $shell> insmod mapper.ko\n   $shell> ./device_setup\n\n   Then enable DEVICEDRIVER_ALLOCATION = 1 in Makefile.rule.\n"
        },
        {
          "name": "GotoBLAS_06WeirdPerformance.txt",
          "type": "blob",
          "size": 0.8740234375,
          "content": "        Weird Performance\n\n1. If you see serious performance loss (extremely low performance),\n   probably you created too many threads or process. Basically GotoBLAS\n   assumes that available cores that you specify are exclusively for\n   BLAS computation. Even one small thread/process conflicts with BLAS\n   threads, performance will become worse.\n\n   The best solution is to reduce your number of threads or insert\n   some synchronization mechanism and suspend your threads until BLAS\n   operation is finished.\n\n\n2. Similar problem may happen under virtual machine. If supervisor\n   allocates different cores for each scheduling, BLAS performnace\n   will be bad. This is because BLAS also utilizes all cache,\n   unexpected re-schedule for different core may result of heavy\n   performance loss.\n\n\nAnyway, if you see any weird performance loss, it means your code or\nalgorithm is not optimal.\n"
        },
        {
          "name": "Jenkinsfile",
          "type": "blob",
          "size": 0.2216796875,
          "content": "pipeline {\n    agent { \n        docker {\n            image 'osuosl/ubuntu-s390x'\n        }\n    }\n    stages {\n        stage('Build') {\n            steps {\n                sh 'make clean && make'\n            }\n        }\n    }\n}\n"
        },
        {
          "name": "Jenkinsfile.pwr",
          "type": "blob",
          "size": 0.314453125,
          "content": "pipeline {\n    agent { \n        docker {\n            image 'osuosl/ubuntu-ppc64le:18.04'\n        }\n    }\n    stages {\n        stage('Build') {\n            steps {\n                sh 'sudo apt update'\n                sh 'sudo apt install gfortran -y'\n                sh 'make clean && make'\n            }\n        }\n    }\n}\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.51171875,
          "content": "Copyright (c) 2011-2014, The OpenBLAS Project\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   1. Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n\n   2. Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in\n      the documentation and/or other materials provided with the\n      distribution.\n   3. Neither the name of the OpenBLAS project nor the names of \n      its contributors may be used to endorse or promote products \n      derived from this software without specific prior written \n      permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\nUSE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 13.337890625,
          "content": "TOPDIR\t= .\ninclude ./Makefile.system\nLNCMD = ln -fs\nifeq ($(FIXED_LIBNAME), 1)\nLNCMD = true\nendif\n\nBLASDIRS = interface driver/level2 driver/level3 driver/others\n\nifneq ($(DYNAMIC_ARCH), 1)\nBLASDIRS += kernel\nendif\n\nifdef SANITY_CHECK\nBLASDIRS += reference\nendif\n\nSUBDIRS\t= $(BLASDIRS)\nifneq ($(NO_LAPACK), 1)\nSUBDIRS\t+= lapack\nendif\n\nRELA =\nifeq ($(BUILD_RELAPACK), 1)\nRELA = re_lapack\nendif\n\nifeq ($(NO_FORTRAN), 1)\ndefine NOFORTRAN\n1\nendef\nifneq ($(NO_LAPACK), 1)\ndefine C_LAPACK\n1\nendef\nendif\nexport NOFORTRAN\nexport NO_LAPACK\nexport C_LAPACK\nendif\n\nifeq ($(F_COMPILER),CRAY)\nLAPACK_NOOPT := $(filter-out -O0 -O1 -O2 -O3 -Ofast -Og -Os,$(LAPACK_FFLAGS))\nelse\nLAPACK_NOOPT := $(filter-out -O0 -O1 -O2 -O3 -Ofast -O -Og -Os,$(LAPACK_FFLAGS))\nendif\n\nifdef LAPACK_STRLEN\nLAPACK_FFLAGS += -DLAPACK_STRLEN=$(LAPACK_STRLEN)\nendif\n\nSUBDIRS_ALL = $(SUBDIRS) test ctest utest exports benchmark ../laswp ../bench cpp_thread_test\n\n.PHONY : all libs netlib $(RELA) test ctest shared install\n.NOTPARALLEL : shared\n\nall :: tests\n\t@echo\n\t@echo \" OpenBLAS build complete. ($(LIB_COMPONENTS))\"\n\t@echo\n\t@echo \"  OS               ... $(OSNAME)             \"\n\t@echo \"  Architecture     ... $(ARCH)               \"\nifndef BINARY64\n\t@echo \"  BINARY           ... 32bit                 \"\nelse\n\t@echo \"  BINARY           ... 64bit                 \"\nendif\n\nifdef INTERFACE64\nifneq ($(INTERFACE64), 0)\n\t@echo \"  Use 64 bits int    (equivalent to \\\"-i8\\\" in Fortran)      \"\nendif\nendif\n\t@$(CC) --version > /dev/null 2>&1;\\\n\tif [ $$? -eq 0 ]; then \\\n\t   cverinfo=`$(CC) --version | sed -n '1p'`; \\\n\t   if [ -z \"$${cverinfo}\" ]; then \\\n\t   cverinfo=`$(CC) --version | sed -n '2p'`; \\\n\t   fi; \\\n\t   echo \"  C compiler       ... $(C_COMPILER)  (cmd & version : $${cverinfo})\";\\\n\telse  \\\n\t   echo \"  C compiler       ... $(C_COMPILER)  (command line : $(CC))\";\\\n\tfi\nifeq ($(NOFORTRAN), $(filter 0,$(NOFORTRAN)))\n\t@$(FC) --version > /dev/null 2>&1;\\\n\tif [ $$? -eq 0 ]; then \\\n\t   fverinfo=`$(FC) --version | sed -n '1p'`; \\\n\t   if [ -z \"$${fverinfo}\" ]; then \\\n\t   fverinfo=`$(FC) --version | sed -n '2p'`; \\\n\t   fi; \\\n\t   echo \"  Fortran compiler ... $(F_COMPILER)  (cmd & version : $${fverinfo})\";\\\n\telse \\\n\t   echo \"  Fortran compiler ... $(F_COMPILER)  (command line : $(FC))\";\\\n\tfi\nendif\nifneq ($(OSNAME), AIX)\n\t@echo -n \"  Library Name     ... $(LIBNAME)\"\nelse\n\t@echo \"  Library Name     ... $(LIBNAME)\"\nendif\n\nifndef SMP\n\t@echo \" (Single-threading)  \"\nelse\n\t@echo \" (Multi-threading; Max num-threads is $(NUM_THREADS))\"\nendif\n\nifeq ($(DYNAMIC_ARCH), 1)\n\t@echo \"  Supporting multiple $(ARCH) cpu models with minimum requirement for the common code being $(CORE)\"\nendif\n\nifeq ($(USE_OPENMP), 1)\n\t@echo\n\t@echo \" Use OpenMP in the multithreading. Because of ignoring OPENBLAS_NUM_THREADS and GOTO_NUM_THREADS flags, \"\n\t@echo \" you should use OMP_NUM_THREADS environment variable to control the number of threads.\"\n\t@echo\nendif\n\nifeq ($(OSNAME), Darwin)\n\t@echo \"WARNING: If you plan to use the dynamic library $(LIBDYNNAME), you must run:\"\n\t@echo\n\t@echo \"\\\"make PREFIX=/your_installation_path/ install\\\".\"\n\t@echo\n\t@echo \"(or set PREFIX in Makefile.rule and run make install.\"\n\t@echo\n\t@echo \"Note that any flags passed to make during build should also be passed to make install\"\n\t@echo \"to circumvent any install errors.\"\n\t@echo\n\t@echo \"If you want to move the .dylib to a new location later, make sure you change\"\n\t@echo \"the internal name of the dylib with:\"\n\t@echo\n\t@echo \"install_name_tool -id /new/absolute/path/to/$(LIBDYNNAME) $(LIBDYNNAME)\"\nendif\n\t@echo\n\t@echo \"To install the library, you can run \\\"make PREFIX=/path/to/your/installation install\\\".\"\n\t@echo\n\t@echo \"Note that any flags passed to make during build should also be passed to make install\"\n\t@echo \"to circumvent any install errors.\"\n\t@echo\n\nshared : libs netlib $(RELA)\nifneq ($(NO_SHARED), 1)\nifeq ($(OSNAME), $(filter $(OSNAME),Linux SunOS Android Haiku FreeBSD DragonFly))\n\t@$(MAKE) -C exports so\n\t@$(LNCMD) $(LIBSONAME) $(LIBPREFIX).so\n\t@$(LNCMD) $(LIBSONAME) $(LIBPREFIX).so.$(MAJOR_VERSION)\nendif\nifeq ($(OSNAME), $(filter $(OSNAME),OpenBSD NetBSD))\n\t@$(MAKE) -C exports so\n\t@$(LNCMD) $(LIBSONAME) $(LIBPREFIX).so\nendif\nifeq ($(OSNAME), Darwin)\n\t@$(MAKE) -C exports dyn\n\t@$(LNCMD) $(LIBDYNNAME) $(LIBPREFIX).dylib\n\t@$(LNCMD) $(LIBDYNNAME) $(LIBPREFIX).$(MAJOR_VERSION).dylib\nendif\nifeq ($(OSNAME), WINNT)\n\t@$(MAKE) -C exports dll\nendif\nifeq ($(OSNAME), CYGWIN_NT)\n\t@$(MAKE) -C exports dll\nendif\nifeq ($(OSNAME), AIX)\n\t@$(MAKE) -C exports so\nendif\nendif\n\ntests : shared\nifeq ($(NOFORTRAN), $(filter 0,$(NOFORTRAN)))\n\ttouch $(LIBNAME)\nifndef NO_FBLAS\n\t$(MAKE) -C test all\nendif\nendif\nifneq ($(ONLY_CBLAS), 1)\n\t$(MAKE) -C utest all\nendif\nifneq ($(NO_CBLAS), 1)\nifneq ($(ONLY_CBLAS), 1)\n\t$(MAKE) -C ctest all\nendif\nifeq ($(CPP_THREAD_SAFETY_TEST), 1)\n\t$(MAKE) -C cpp_thread_test all\nendif\nendif\n\nlibs :\nifeq ($(CORE), UNKNOWN)\n\t$(error OpenBLAS: Detecting CPU failed. Please set TARGET explicitly, e.g. make TARGET=your_cpu_target. Please read README for the detail.)\nendif\nifeq ($(NOFORTRAN), 1)\n\t$(info OpenBLAS: Detecting fortran compiler failed. Can only compile BLAS and f2c-converted LAPACK.)\nendif\nifeq ($(NO_STATIC), 1)\nifeq ($(NO_SHARED), 1)\n\t$(error OpenBLAS: neither static nor shared are enabled.)\nendif\nendif\n\t@for d in $(SUBDIRS) ; \\\n\tdo if test -d $$d; then \\\n\t  $(MAKE) -C $$d $(@F) || exit 1 ; \\\n\tfi; \\\n\tdone\n#Save the config files for installation\n\t@cp Makefile.conf Makefile.conf_last\n\t@cp config.h config_last.h\nifdef QUAD_PRECISION\n\t@echo \"#define QUAD_PRECISION\">> config_last.h\nendif\nifeq ($(EXPRECISION), 1)\n\t@echo \"#define EXPRECISION\">> config_last.h\nendif\n##\nifeq ($(DYNAMIC_ARCH), 1)\n\t@$(MAKE) -C kernel commonlibs || exit 1\n\t@for d in $(DYNAMIC_CORE) ; \\\n\tdo  $(MAKE) GOTOBLAS_MAKEFILE= -C kernel TARGET_CORE=$$d kernel || exit 1 ;\\\n\tdone\n\t@echo DYNAMIC_ARCH=1 >> Makefile.conf_last\nifeq ($(DYNAMIC_OLDER), 1)\n\t@echo DYNAMIC_OLDER=1 >> Makefile.conf_last\nendif\t\nendif\n\t@echo TARGET=$(CORE) >> Makefile.conf_last\nifdef USE_THREAD\n\t@echo USE_THREAD=$(USE_THREAD) >>  Makefile.conf_last\nendif\nifdef SMP\nifdef NUM_THREADS\n\t@echo NUM_THREADS=$(NUM_THREADS) >>  Makefile.conf_last\nelse\n\t@echo NUM_THREADS=$(NUM_CORES) >>  Makefile.conf_last\nendif\nendif\nifeq ($(USE_OPENMP),1)\n\t@echo USE_OPENMP=1 >>  Makefile.conf_last\nendif\nifeq ($(INTERFACE64),1)\n\t@echo INTERFACE64=1 >>  Makefile.conf_last\nendif\n\t@echo THELIBNAME=$(LIBNAME) >>  Makefile.conf_last\n\t@echo THELIBSONAME=$(LIBSONAME) >>  Makefile.conf_last\n\t@-$(LNCMD) $(LIBNAME) $(LIBPREFIX).$(LIBSUFFIX)\n\t@touch lib.grd\n\nprof : prof_blas prof_lapack\n\nprof_blas :\n\t$(LNCMD) $(LIBNAME_P) $(LIBPREFIX)_p.$(LIBSUFFIX)\n\tfor d in $(SUBDIRS) ; \\\n\tdo if test -d $$d; then \\\n\t  $(MAKE) -C $$d prof || exit 1 ; \\\n\tfi; \\\n\tdone\nifeq ($(DYNAMIC_ARCH), 1)\n\t  $(MAKE) -C kernel commonprof || exit 1\nendif\n\nblas :\n\t$(LNCMD) $(LIBNAME) $(LIBPREFIX).$(LIBSUFFIX)\n\tfor d in $(BLASDIRS) ; \\\n\tdo if test -d $$d; then \\\n\t  $(MAKE) -C $$d libs || exit 1 ; \\\n\tfi; \\\n\tdone\n\nhpl :\n\t$(LNCMD) $(LIBNAME) $(LIBPREFIX).$(LIBSUFFIX)\n\tfor d in $(BLASDIRS) ../laswp exports ; \\\n\tdo if test -d $$d; then \\\n\t  $(MAKE) -C $$d $(@F) || exit 1 ; \\\n\tfi; \\\n\tdone\nifeq ($(DYNAMIC_ARCH), 1)\n\t  $(MAKE) -C kernel commonlibs || exit 1\n\tfor d in $(DYNAMIC_CORE) ; \\\n\tdo  $(MAKE) GOTOBLAS_MAKEFILE= -C kernel TARGET_CORE=$$d kernel || exit 1 ;\\\n\tdone\nendif\n\nhpl_p :\n\t$(LNCMD) $(LIBNAME_P) $(LIBPREFIX)_p.$(LIBSUFFIX)\n\tfor d in $(SUBDIRS) ../laswp exports ; \\\n\tdo if test -d $$d; then \\\n\t  $(MAKE) -C $$d $(@F) || exit 1 ; \\\n\tfi; \\\n\tdone\n\nnetlib : lapack_prebuild\nifneq ($(NO_LAPACK), 1)\n\t@$(MAKE) -C $(NETLIB_LAPACK_DIR) lapacklib\n\t@$(MAKE) -C $(NETLIB_LAPACK_DIR) tmglib\nendif\nifneq ($(NO_LAPACKE), 1)\n\t@$(MAKE) -C $(NETLIB_LAPACK_DIR) lapackelib\nendif\n\nifeq ($(NO_LAPACK), 1)\nre_lapack :\n\nelse\nre_lapack :\n\t@$(MAKE) -C relapack\nendif\n\nprof_lapack : lapack_prebuild\n\t@$(MAKE) -C $(NETLIB_LAPACK_DIR) lapack_prof\n\nlapack_prebuild :\nifeq ($(NO_LAPACK), $(filter 0,$(NO_LAPACK)))\n\t-@echo \"FC          = $(FC)\" > $(NETLIB_LAPACK_DIR)/make.inc\nifeq ($(F_COMPILER), GFORTRAN)\n\t-@echo \"override FFLAGS      = $(LAPACK_FFLAGS) -fno-tree-vectorize\" >> $(NETLIB_LAPACK_DIR)/make.inc\nelse\n\t-@echo \"override FFLAGS      = $(LAPACK_FFLAGS)\" >> $(NETLIB_LAPACK_DIR)/make.inc\nendif\n\t-@echo \"FFLAGS_DRV  = $(LAPACK_FFLAGS)\" >> $(NETLIB_LAPACK_DIR)/make.inc\n\t-@echo \"POPTS       = $(LAPACK_FPFLAGS)\" >> $(NETLIB_LAPACK_DIR)/make.inc\n\t-@echo \"FFLAGS_NOOPT       = -O0 $(LAPACK_NOOPT)\" >> $(NETLIB_LAPACK_DIR)/make.inc\n\t-@echo \"PNOOPT      = $(LAPACK_FPFLAGS) -O0\" >> $(NETLIB_LAPACK_DIR)/make.inc\nifeq ($(C_COMPILER)$(F_COMPILER)$(USE_OPENMP), CLANGGFORTRAN1)\n\t-@echo \"LDFLAGS     = $(FFLAGS) $(EXTRALIB) -lomp\" >> $(NETLIB_LAPACK_DIR)/make.inc\nelse\nifeq ($(C_COMPILER)$(F_COMPILER)$(USE_OPENMP), CLANGIBM1)\n\t-@echo \"LDFLAGS     = $(FFLAGS) $(EXTRALIB) -lomp\" >> $(NETLIB_LAPACK_DIR)/make.inc\nelse\n\t-@echo \"LDFLAGS     = $(FFLAGS) $(EXTRALIB)\" >> $(NETLIB_LAPACK_DIR)/make.inc\nendif\nendif\n\t-@echo \"CC          = $(CC)\" >> $(NETLIB_LAPACK_DIR)/make.inc\n\t-@echo \"override CFLAGS      = $(LAPACK_CFLAGS)\" >> $(NETLIB_LAPACK_DIR)/make.inc\n\t-@echo \"AR          = $(AR)\" >> $(NETLIB_LAPACK_DIR)/make.inc\n\t-@echo \"ARFLAGS     = $(ARFLAGS) -ru\" >> $(NETLIB_LAPACK_DIR)/make.inc\n\t-@echo \"RANLIB      = $(RANLIB)\" >> $(NETLIB_LAPACK_DIR)/make.inc\n\t-@echo \"LAPACKLIB   = ../../$(LIBNAME)\" >> $(NETLIB_LAPACK_DIR)/make.inc\n\t-@echo \"TMGLIB      = ../../../$(LIBNAME)\" >> $(NETLIB_LAPACK_DIR)/make.inc\n\t-@echo \"BLASLIB     = ../../../$(LIBNAME)\" >> $(NETLIB_LAPACK_DIR)/make.inc\n\t-@echo \"LAPACKELIB  = ../../../$(LIBNAME)\" >> $(NETLIB_LAPACK_DIR)/make.inc\n\t-@echo \"LAPACKLIB_P = ../$(LIBNAME_P)\" >> $(NETLIB_LAPACK_DIR)/make.inc\n\t-@echo \"SUFFIX      = $(SUFFIX)\" >> $(NETLIB_LAPACK_DIR)/make.inc\n\t-@echo \"PSUFFIX     = $(PSUFFIX)\" >> $(NETLIB_LAPACK_DIR)/make.inc\n\t-@echo \"CEXTRALIB   = $(EXTRALIB)\" >> $(NETLIB_LAPACK_DIR)/make.inc\nifeq ($(F_COMPILER), GFORTRAN)\n\t-@echo \"TIMER       = INT_ETIME\" >> $(NETLIB_LAPACK_DIR)/make.inc\nifdef SMP\nifeq ($(OSNAME), WINNT)\n\t-@echo \"LOADER      = $(FC)\" >> $(NETLIB_LAPACK_DIR)/make.inc\nelse ifeq ($(OSNAME), Haiku)\n\t-@echo \"LOADER      = $(FC)\" >> $(NETLIB_LAPACK_DIR)/make.inc\nelse\n\t-@echo \"LOADER      = $(FC) -pthread\" >> $(NETLIB_LAPACK_DIR)/make.inc\nendif\nelse\n\t-@echo \"LOADER      = $(FC)\" >> $(NETLIB_LAPACK_DIR)/make.inc\nendif\nelse\n\t-@echo \"TIMER       = NONE\" >> $(NETLIB_LAPACK_DIR)/make.inc\n\t-@echo \"LOADER      = $(FC)\" >> $(NETLIB_LAPACK_DIR)/make.inc\nendif\nifeq ($(BUILD_LAPACK_DEPRECATED), 1)\n\t-@echo \"BUILD_DEPRECATED      = 1\" >> $(NETLIB_LAPACK_DIR)/make.inc\nendif\nifeq ($(BUILD_SINGLE), 1)\n\t-@echo \"BUILD_SINGLE      = 1\" >> $(NETLIB_LAPACK_DIR)/make.inc\nendif\nifeq ($(BUILD_DOUBLE), 1)\n\t-@echo \"BUILD_DOUBLE      = 1\" >> $(NETLIB_LAPACK_DIR)/make.inc\nendif\nifeq ($(BUILD_COMPLEX), 1)\n\t-@echo \"BUILD_COMPLEX      = 1\" >> $(NETLIB_LAPACK_DIR)/make.inc\nendif\nifeq ($(BUILD_COMPLEX16), 1)\n\t-@echo \"BUILD_COMPLEX16      = 1\" >> $(NETLIB_LAPACK_DIR)/make.inc\nendif\n\t-@echo \"LAPACKE_WITH_TMG      = 1\" >> $(NETLIB_LAPACK_DIR)/make.inc\n\t-@cat  make.inc >> $(NETLIB_LAPACK_DIR)/make.inc\nendif\n\nlarge.tgz :\nifeq ($(NOFORTRAN), $(filter 0,$(NOFORTRAN)))\n\tif [ ! -a $< ]; then\n\t-wget http://www.netlib.org/lapack/timing/large.tgz;\n\tfi\nendif\n\ntiming.tgz :\nifeq ($(NOFORTRAN), $(filter 0,$(NOFORTRAN)))\n\tif [ ! -a $< ]; then\n\t-wget http://www.netlib.org/lapack/timing/timing.tgz;\n\tfi\nendif\n\nlapack-timing : large.tgz timing.tgz\nifeq ($(NOFORTRAN), $(filter 0,$(NOFORTRAN)))\n\t(cd $(NETLIB_LAPACK_DIR); $(TAR) zxf ../timing.tgz TIMING)\n\t(cd $(NETLIB_LAPACK_DIR)/TIMING; $(TAR) zxf ../../large.tgz )\n\t$(MAKE) -C $(NETLIB_LAPACK_DIR)/TIMING\nendif\n\n\nlapack-test :\n\t(cd $(NETLIB_LAPACK_DIR)/TESTING && rm -f x* *.out)\n\t$(MAKE) -j 1 -C $(NETLIB_LAPACK_DIR)/TESTING/EIG xeigtstc  xeigtstd  xeigtsts  xeigtstz \n\t$(MAKE) -j 1 -C $(NETLIB_LAPACK_DIR)/TESTING/LIN xlintstc  xlintstd  xlintstds  xlintstrfd  xlintstrfz  xlintsts  xlintstz  xlintstzc xlintstrfs xlintstrfc\nifneq ($(CROSS), 1)\n\t( cd $(NETLIB_LAPACK_DIR)/INSTALL; $(MAKE) all; ./testlsame; ./testslamch; ./testdlamch; \\\n        ./testsecond; ./testdsecnd; ./testieee; ./testversion )\n\t(cd $(NETLIB_LAPACK_DIR); ./lapack_testing.py -r -b TESTING)\nendif\n\nlapack-runtest: lapack-test\n\t( cd $(NETLIB_LAPACK_DIR)/INSTALL; ./testlsame; ./testslamch; ./testdlamch; \\\n        ./testsecond; ./testdsecnd; ./testieee; ./testversion )\n\t(cd $(NETLIB_LAPACK_DIR); ./lapack_testing.py -r -b TESTING )\n\n\nblas-test:\n\t(cd $(NETLIB_LAPACK_DIR)/BLAS/TESTING && rm -f x* *.out)\n\n\t$(MAKE) -j 1 -C $(NETLIB_LAPACK_DIR) blas_testing\n\t(cd $(NETLIB_LAPACK_DIR)/BLAS/TESTING && cat *.out)\n\n\ndummy :\n\ninstall :\n\t$(MAKE) -f Makefile.install install\n\ninstall_tests :\n\t$(MAKE) -f Makefile.install install_tests\n\nclean ::\n\t@for d in $(SUBDIRS_ALL) ; \\\n\tdo if test -d $$d; then \\\n\t  $(MAKE) -C $$d $(@F) || exit 1 ; \\\n\tfi; \\\n\tdone\n#ifdef DYNAMIC_ARCH\n\t@$(MAKE) -C kernel clean\n#endif\n\t@$(MAKE) -C reference clean\n\t@rm -f *.$(LIBSUFFIX) *.so *~ *.exe getarch getarch_2nd *.dll *.lib *.$(SUFFIX) *.dwf $(LIBPREFIX).$(LIBSUFFIX) $(LIBPREFIX)_p.$(LIBSUFFIX) $(LIBPREFIX).so.$(MAJOR_VERSION) *.lnk myconfig.h *.so.renamed *.a.renamed *.so.0\nifeq ($(OSNAME), Darwin)\n\t@rm -rf getarch.dSYM getarch_2nd.dSYM\nendif\n\t@rm -f Makefile.conf config.h Makefile_kernel.conf config_kernel.h st* *.dylib\n\t@rm -f cblas.tmp cblas.tmp2\n\t@touch $(NETLIB_LAPACK_DIR)/make.inc\n\t@$(MAKE) -C $(NETLIB_LAPACK_DIR) clean\n\t@rm -f $(NETLIB_LAPACK_DIR)/make.inc $(NETLIB_LAPACK_DIR)/lapacke/include/lapacke_mangling.h\n\t@$(MAKE) -C relapack clean\n\t@rm -f *.grd Makefile.conf_last config_last.h\n\t@(cd $(NETLIB_LAPACK_DIR)/TESTING && rm -f x* *.out testing_results.txt)\n\t@echo Done.\n"
        },
        {
          "name": "Makefile.alpha",
          "type": "blob",
          "size": 0.7294921875,
          "content": "ifneq ($(COMPILER), NATIVE)\n# GCC User\nifeq ($(CORE), EV4)\nCCOMMON_OPT += -mcpu=ev4\nendif\nifeq ($(CORE), EV5)\nCCOMMON_OPT += -mcpu=ev5\nendif\nifeq ($(CORE), EV6)\nCCOMMON_OPT += -mcpu=ev6\nendif\nelse\n# Compaq Compiler User\nifeq ($(CORE), EV4)\nCCOMMON_OPT += -tune ev4 -arch ev4\nendif\nifeq ($(CORE), EV5)\nCCOMMON_OPT += -tune ev5 -arch ev5\nendif\nifeq ($(CORE), EV6)\nCCOMMON_OPT += -tune ev6 -arch ev6\nendif\nendif\n\nifeq ($(F_COMPILER), GFORTRAN)\nFCOMMON_OPT\t+= -mieee\nendif\n\nifeq ($(F_COMPILER), G77)\nFCOMMON_OPT\t+= -mieee\nendif\n\nifndef SMP\nLIBCXML\t\t= -lcxml  -lots -lm\nLIBATLAS\t= -L/usr/lib/atlas3.7.8 -lf77blas -latlas -lm\nelse\nLIBCXML\t\t= -lcxmlp -lots -lm\nLIBATLAS\t= -L/usr/lib/atlas3.7.8p -llapack -lptcblas -lptf77blas -latlas -lpthread -lm\nendif\n"
        },
        {
          "name": "Makefile.arm",
          "type": "blob",
          "size": 0.412109375,
          "content": "ifeq ($(CORE), $(filter $(CORE),ARMV7 CORTEXA9 CORTEXA15))\nifeq ($(OSNAME), Android)\nCCOMMON_OPT += -mfpu=neon -march=armv7-a\nFCOMMON_OPT += -mfpu=neon -march=armv7-a\nelse\nCCOMMON_OPT += -mfpu=vfpv3 -march=armv7-a\nFCOMMON_OPT += -mfpu=vfpv3 -march=armv7-a\nendif\nendif\n\nifeq ($(CORE), ARMV6)\nCCOMMON_OPT += -mfpu=vfp\nFCOMMON_OPT += -mfpu=vfp\nendif\n\nifdef HAVE_NEON\nCCOMMON_OPT += -mfpu=neon\nFCOMMON_OPT += -mfpu=neon\nendif\n"
        },
        {
          "name": "Makefile.arm64",
          "type": "blob",
          "size": 8.8828125,
          "content": "ifneq ($(C_COMPILER), PGI)\n\nifeq ($(C_COMPILER), CLANG)\nISCLANG=1\nendif\nifeq ($(C_COMPILER), FUJITSU)\nISCLANG=1\nendif\nifneq (1, $(filter 1,$(GCCVERSIONGT4) $(ISCLANG)))\nCCOMMON_OPT += -march=armv8-a\nifneq ($(F_COMPILER), NAG)\nFCOMMON_OPT += -march=armv8-a\nendif\n\n\nelse \n\n\nifeq ($(CORE), ARMV8)\nCCOMMON_OPT += -march=armv8-a\nifneq ($(F_COMPILER), NAG)\nFCOMMON_OPT += -march=armv8-a\nendif\nendif\n\nifeq ($(CORE), ARMV8SVE)\nCCOMMON_OPT += -march=armv8-a+sve\nifneq ($(F_COMPILER), NAG)\nFCOMMON_OPT += -march=armv8-a+sve\nendif\nendif\n\nifeq ($(CORE), CORTEXA53)\nCCOMMON_OPT += -march=armv8-a -mtune=cortex-a53\nifneq ($(F_COMPILER), NAG)\nFCOMMON_OPT += -march=armv8-a -mtune=cortex-a53\nendif\nendif\n\nifeq ($(CORE), CORTEXA57)\nCCOMMON_OPT += -march=armv8-a -mtune=cortex-a57\nifneq ($(F_COMPILER), NAG)\nFCOMMON_OPT += -march=armv8-a -mtune=cortex-a57\nendif\nendif\n\nifeq ($(CORE), CORTEXA72)\nCCOMMON_OPT += -march=armv8-a -mtune=cortex-a72\nifneq ($(F_COMPILER), NAG)\nFCOMMON_OPT += -march=armv8-a -mtune=cortex-a72\nendif\nendif\n\nifeq ($(CORE), CORTEXA73)\nCCOMMON_OPT += -march=armv8-a -mtune=cortex-a73\nifneq ($(F_COMPILER), NAG)\nFCOMMON_OPT += -march=armv8-a -mtune=cortex-a73\nendif\nendif\n\nifeq ($(CORE), CORTEXA76)\nCCOMMON_OPT += -march=armv8.2-a -mtune=cortex-a76\nifneq ($(F_COMPILER), NAG)\nFCOMMON_OPT += -march=armv8.2-a -mtune=cortex-a76\nendif\nendif\n\nifeq ($(CORE), FT2000)\nCCOMMON_OPT += -march=armv8-a -mtune=cortex-a72\nifneq ($(F_COMPILER), NAG)\nFCOMMON_OPT += -march=armv8-a -mtune=cortex-a72\nendif\nendif\n\n# Use a72 tunings because Neoverse-N1 is only available\n# in GCC>=9\nifeq ($(CORE), NEOVERSEN1)\nifeq (1, $(filter 1,$(GCCVERSIONGTEQ7) $(ISCLANG)))\nifeq (1, $(filter 1,$(GCCVERSIONGTEQ9) $(ISCLANG)))\nCCOMMON_OPT += -march=armv8.2-a -mtune=neoverse-n1\nifneq ($(F_COMPILER), NAG)\nFCOMMON_OPT += -march=armv8.2-a -mtune=neoverse-n1\nendif\nelse\nCCOMMON_OPT += -march=armv8.2-a -mtune=cortex-a72\nifneq ($(F_COMPILER), NAG)\nFCOMMON_OPT += -march=armv8.2-a -mtune=cortex-a72\nendif\nendif\nelse\nCCOMMON_OPT += -march=armv8-a -mtune=cortex-a72\nifneq ($(F_COMPILER), NAG)\nFCOMMON_OPT += -march=armv8-a -mtune=cortex-a72\nendif\nendif\nendif\n\n# Use a72 tunings because Neoverse-V1 is only available\n# in GCC>=10.4\nifeq ($(CORE), NEOVERSEV1)\nifeq (1, $(filter 1,$(GCCVERSIONGTEQ7) $(ISCLANG)))\nifeq (1, $(filter 1,$(GCCVERSIONGTEQ10) $(ISCLANG)))\nifeq (1, $(filter 1,$(GCCMINORVERSIONGTEQ4) $(GCCVERSIONGTEQ11) $(ISCLANG)))\nCCOMMON_OPT += -march=armv8.4-a+sve\nifeq (1, $(ISCLANG))\nCCOMMON_OPT += -mtune=cortex-x1\nelse\nCCOMMON_OPT += -mtune=neoverse-v1\nendif\nifneq ($(F_COMPILER), NAG)\nFCOMMON_OPT += -march=armv8.4-a -mtune=neoverse-v1\nendif\nelse\nCCOMMON_OPT += -march=armv8.4-a+sve \nifneq ($(CROSS), 1)\nCCOMMON_OPT += -mtune=native\nendif\nifneq ($(F_COMPILER), NAG)\nFCOMMON_OPT += -march=armv8.4-a \nifneq ($(CROSS), 1)\nFCOMMON_OPT += -mtune=native\nendif\nendif\nendif\nelse\nCCOMMON_OPT += -march=armv8.2-a+sve -mtune=cortex-a72\nifneq ($(F_COMPILER), NAG)\nFCOMMON_OPT += -march=armv8.2-a -mtune=cortex-a72\nendif\nendif\nelse\nCCOMMON_OPT += -march=armv8-a+sve -mtune=cortex-a72\nifneq ($(F_COMPILER), NAG)\nFCOMMON_OPT += -march=armv8-a -mtune=cortex-a72\nendif\nendif\nendif\n\n# Use a72 tunings because Neoverse-N2 is only available\n# in GCC>=10.4\nifeq ($(CORE), NEOVERSEN2)\nifeq (1, $(filter 1,$(GCCVERSIONGTEQ7) $(ISCLANG)))\nifeq (1, $(filter 1,$(GCCVERSIONGTEQ10) $(ISCLANG)))\nifeq (1, $(filter 1,$(GCCMINORVERSIONGTEQ4) $(GCCVERSIONGTEQ11) $(ISCLANG)))\nifneq ($(OSNAME), Darwin)\nCCOMMON_OPT += -march=armv8.5-a+sve+sve2+bf16 -mtune=neoverse-n2\nelse\nCCOMMON_OPT += -march=armv8.2-a+sve+bf16 -mtune=cortex-a72\nendif\nifneq ($(F_COMPILER), NAG)\nFCOMMON_OPT += -march=armv8.5-a+sve+sve2+bf16 -mtune=neoverse-n2\nendif\nelse\nCCOMMON_OPT += -march=armv8.5-a+sve+bf16\nifneq ($(CROSS), 1)\nCCOMMON_OPT += -mtune=native\nendif\nifneq ($(F_COMPILER), NAG)\nFCOMMON_OPT += -march=armv8.5-a \nifneq ($(CROSS), 1)\nFCOMMON_OPT += -mtune=native\nendif\nendif\nendif\nelse\nCCOMMON_OPT += -march=armv8.2-a+sve+bf16 -mtune=cortex-a72\nifneq ($(F_COMPILER), NAG)\nFCOMMON_OPT += -march=armv8.2-a -mtune=cortex-a72\nendif\nendif\nelse\nCCOMMON_OPT += -march=armv8-a+sve+bf16 -mtune=cortex-a72\nifneq ($(F_COMPILER), NAG)\nFCOMMON_OPT += -march=armv8-a -mtune=cortex-a72\nendif\nendif\nendif\n\n# Detect ARM Neoverse V2.\nifeq ($(CORE), NEOVERSEV2)\nifeq (1, $(filter 1,$(GCCVERSIONGTEQ12) $(ISCLANG)))\nCCOMMON_OPT += -march=armv9-a -mtune=neoverse-v2\nifneq ($(F_COMPILER), NAG)\nFCOMMON_OPT += -march=armv9-a -mtune=neoverse-v2\nendif\nendif\nendif\n\n# Use a53 tunings because a55 is only available in GCC>=8.1\nifeq ($(CORE), CORTEXA55)\nifeq (1, $(filter 1,$(GCCVERSIONGTEQ7) $(ISCLANG)))\nifeq (1, $(filter 1,$(GCCVERSIONGTEQ8) $(ISCLANG)))\nCCOMMON_OPT += -march=armv8.2-a -mtune=cortex-a55\nifneq ($(F_COMPILER), NAG)\nFCOMMON_OPT += -march=armv8.2-a -mtune=cortex-a55\nendif\nelse\nCCOMMON_OPT += -march=armv8.2-a -mtune=cortex-a53\nifneq ($(F_COMPILER), NAG)\nFCOMMON_OPT += -march=armv8.2-a -mtune=cortex-a53\nendif\nendif\nelse\nCCOMMON_OPT += -march=armv8-a -mtune=cortex-a53\nifneq ($(F_COMPILER), NAG)\nFCOMMON_OPT += -march=armv8-a -mtune=cortex-a53\nendif\nendif\nendif\n\nifeq ($(CORE), THUNDERX)\nCCOMMON_OPT += -march=armv8-a -mtune=thunderx\nifneq ($(F_COMPILER), NAG)\nFCOMMON_OPT += -march=armv8-a -mtune=thunderx\nendif\nendif\n\nifeq ($(CORE), FALKOR)\nCCOMMON_OPT += -march=armv8-a -mtune=falkor\nifneq ($(F_COMPILER), NAG)\nFCOMMON_OPT += -march=armv8-a -mtune=falkor\nendif\nendif\n\nifeq ($(CORE), THUNDERX2T99)\nCCOMMON_OPT += -march=armv8.1-a -mtune=thunderx2t99\nifneq ($(F_COMPILER), NAG)\nFCOMMON_OPT += -march=armv8.1-a -mtune=thunderx2t99\nendif\nendif\n\nifeq ($(CORE), THUNDERX3T110)\nifeq (1, $(filter 1,$(GCCVERSIONGTEQ10) $(ISCLANG)))\nCCOMMON_OPT += -march=armv8.3-a \nifeq (0, $(ISCLANG))\nCCOMMON_OPT += -mtune=thunderx3t110\nelse\nCCOMMON_OPT += -mtune=thunderx2t99\nendif\nifneq ($(F_COMPILER), NAG)\nFCOMMON_OPT += -march=armv8.3-a -mtune=thunderx3t110\nendif\nelse\nCCOMMON_OPT += -march=armv8.1-a -mtune=thunderx2t99\nifneq ($(F_COMPILER), NAG)\nFCOMMON_OPT += -march=armv8.1-a -mtune=thunderx2t99\nendif\nendif\nendif\n\nifeq ($(CORE), VORTEX)\nCCOMMON_OPT += -march=armv8.3-a\nifneq ($(F_COMPILER), NAG)\nFCOMMON_OPT += -march=armv8.3-a\nendif\nendif\n\nifeq (1, $(filter 1,$(GCCVERSIONGTEQ9) $(ISCLANG)))\nifeq ($(CORE), TSV110)\nCCOMMON_OPT += -march=armv8.2-a -mtune=tsv110\nifneq ($(F_COMPILER), NAG)\nFCOMMON_OPT += -march=armv8.2-a -mtune=tsv110\nendif\nendif\nendif\n\nifeq (1, $(filter 1,$(GCCVERSIONGTEQ9) $(ISCLANG)))\nifeq ($(CORE), EMAG8180)\nCCOMMON_OPT += -march=armv8-a\nifeq  ($(ISCLANG), 0)\nCCOMMON_OPT += -mtune=emag\nendif\nifneq ($(F_COMPILER), NAG)\nFCOMMON_OPT += -march=armv8-a -mtune=emag\nendif\nendif\nendif\n\nifeq ($(CORE), A64FX)\nifeq (1, $(filter 1,$(GCCVERSIONGTEQ10) $(ISCLANG)))\nifeq (1, $(filter 1,$(GCCMINORVERSIONGTEQ3) $(GCCVERSIONGTEQ11) $(ISCLANG)))\nCCOMMON_OPT += -march=armv8.2-a+sve -mtune=a64fx\nifneq ($(F_COMPILER), NAG)\nFCOMMON_OPT += -march=armv8.2-a+sve -mtune=a64fx\nendif\nelse\nCCOMMON_OPT += -march=armv8.4-a+sve -mtune=neoverse-n1\nifneq ($(F_COMPILER), NAG)\nFCOMMON_OPT += -march=armv8.4-a -mtune=neoverse-n1\nendif\nendif\nendif\nendif\n\nifeq (1, $(filter 1,$(GCCVERSIONGTEQ11) $(ISCLANG)))\nifeq ($(CORE), CORTEXX1)\nCCOMMON_OPT += -march=armv8.2-a\nifeq (1, $(filter 1,$(GCCMINORVERSIONGTEQ4) $(GCCVERSIONGTEQ12) $(ISCLANG)))\nCCOMMON_OPT += -mtune=cortex-x1\nifneq ($(F_COMPILER), NAG)\nFCOMMON_OPT += -march=armv8.2-a -mtune=cortex-x1\nendif\nelse\nCCOMMON_OPT += -mtune=cortex-a72\nifneq ($(F_COMPILER), NAG)\nFCOMMON_OPT += -march=armv8.2-a -mtune=cortex-a72\nendif\nendif\nendif\nendif\n\nifeq (1, $(filter 1,$(GCCVERSIONGTEQ11) $(ISCLANG)))\nifeq ($(CORE), CORTEXX2)\nCCOMMON_OPT += -march=armv8.4-a+sve\nifneq ($(F_COMPILER), NAG)\nFCOMMON_OPT += -march=armv8.4-a+sve\nendif\nifeq (1, $(filter 1,$(GCCVERSIONGTEQ12) $(ISCLANG)))\nCCOMMON_OPT += -mtune=cortex-x2\nifneq ($(F_COMPILER), NAG)\nFCOMMON_OPT += -mtune=cortex-x2\nendif\nendif\nendif\nendif\n\n#ifeq (1, $(filter 1,$(ISCLANG)))\nifeq (1, $(filter 1,$(GCCVERSIONGTEQ11) $(ISCLANG)))\nifeq ($(CORE), CORTEXA510)\nCCOMMON_OPT += -march=armv8.4-a+sve\nifneq ($(F_COMPILER), NAG)\nFCOMMON_OPT += -march=armv8.4-a+sve\nendif\nendif\nendif\n\nifeq (1, $(filter 1,$(GCCVERSIONGTEQ11) $(ISCLANG)))\nifeq ($(CORE), CORTEXA710)\nCCOMMON_OPT += -march=armv8.4-a+sve\nifneq ($(F_COMPILER), NAG)\nFCOMMON_OPT += -march=armv8.4-a+sve\nendif\nifeq (1, $(filter 1,$(GCCVERSIONGTEQ12) $(ISCLANG)))\nCCOMMON_OPT += -mtune=cortex-a710\nifneq ($(F_COMPILER), NAG)\nFCOMMON_OPT += -mtune=cortex-a710\nendif\nendif\nendif\nendif\n\nendif\n\nelse\n# NVIDIA HPC options necessary to enable SVE in the compiler\nifeq ($(CORE), THUNDERX2T99)\nCCOMMON_OPT += -tp=thunderx2t99\nFCOMMON_OPT += -tp=thunderx2t99\nendif\nifeq ($(CORE), NEOVERSEN1)\nCCOMMON_OPT += -tp=neoverse-n1\nFCOMMON_OPT += -tp=neoverse-n1\nendif\nifeq ($(CORE), NEOVERSEV1)\nCCOMMON_OPT += -tp=neoverse-v1\nFCOMMON_OPT += -tp=neoverse-v1\nendif\nifeq ($(CORE), NEOVERSEV2)\nCCOMMON_OPT += -tp=neoverse-v2\nFCOMMON_OPT += -tp=neoverse-v2\nendif\nifeq ($(CORE), ARMV8SVE)\nCCOMMON_OPT += -tp=neoverse-v2\nFCOMMON_OPT += -tp=neoverse-v2\nendif\nifeq ($(CORE), ARMV9SVE)\nCCOMMON_OPT += -tp=neoverse-v2\nFCOMMON_OPT += -tp=neoverse-v2\nendif\n\nendif\n"
        },
        {
          "name": "Makefile.csky",
          "type": "blob",
          "size": 0.1640625,
          "content": "ifeq ($(CORE), CK860FV)\nCCOMMON_OPT += -march=ck860v -mcpu=ck860fv -mfdivdu -mhard-float\nFCOMMON_OPT += -march=ck860v -mcpu=ck860fv -mfdivdu -mhard-float -static\nendif\n"
        },
        {
          "name": "Makefile.e2k",
          "type": "blob",
          "size": 0.029296875,
          "content": "COPT\t= -Wall -O2 # -DGEMMTEST\n"
        },
        {
          "name": "Makefile.generic",
          "type": "blob",
          "size": 0.029296875,
          "content": "COPT\t= -Wall -O2 # -DGEMMTEST\n"
        },
        {
          "name": "Makefile.ia64",
          "type": "blob",
          "size": 0.8427734375,
          "content": "CCOMMON_COPT += # -DUSE64BITINT  # -DGEMMTEST\n\n# CCOMMON_OPT\t += -DPARAMTEST\nFLAMEPATH\t= $(HOME)/flame/lib/ia64\n\nifndef SMP\nLIBMKL\t\t= -L$(MKLPATH)/64 -Wl,-rpath,$(MKLPATH)/64 -lmkl_intel_lp64 -lmkl_sequential -lmkl_core -lguide -lpthread -lm\nelse\nLIBMKL\t\t= -L$(MKLPATH)/64 -Wl,-rpath,$(MKLPATH)/64 -lmkl_intel_lp64 -lmkl_intel_thread -lmkl_core -lguide -lpthread -lm\nendif\n\nLIBFLAME\t= -L$(FLAMEPATH) -llapack2flame -lflame $(TOPDIR)/$(LIBNAME) -lgfortran -lpthread -lm\n\nLIBMLIB\t\t= ../../level1/others/libmisc.a -L/opt/intel/fc/ia64/9.1.040/lib -L/opt/mlib/lib \\\n\t\t -llapack -lguide -lifcore -lm -lpthread\nLIBSCSL\t\t= -L/opt/scsl/1.4.1.0/lib -Wl,-rpath,/opt/scsl/1.4.1.0/lib -lscs\n\nifndef SMP\nLIBATLAS\t= -L/usr/lib/atlas3.6.0 -lf77blas -latlas -lm\nelse\nLIBATLAS\t= -L$(HOME)/misc/lib -L/usr/lib/atlas3.6.0p -llapack -lptcblas -lptf77blas -latlas -lpthread -lm\nendif\n"
        },
        {
          "name": "Makefile.install",
          "type": "blob",
          "size": 14.966796875,
          "content": "TOPDIR\t= .\nexport GOTOBLAS_MAKEFILE = 1\n-include $(TOPDIR)/Makefile.conf_last\ninclude ./Makefile.system\nLNCMD = ln -fs\n\nifdef THELIBNAME\nLIBNAME=$(THELIBNAME)\nLIBSONAME=$(THELIBSONAME)\nendif\nifeq ($(FIXED_LIBNAME), 1)\nLNCMD = true\nendif\nifeq ($(INTERFACE64),1)\nUSE_64BITINT=1\nendif\nifeq ($(USE_OPENMP),1)\n\tFOMP_OPT:= -fopenmp\nendif\n\nPREFIX ?= /opt/OpenBLAS\n\nOPENBLAS_INCLUDE_DIR := $(PREFIX)/include\nOPENBLAS_LIBRARY_DIR := $(PREFIX)/lib\nOPENBLAS_BINARY_DIR := $(PREFIX)/bin\nOPENBLAS_BUILD_DIR := $(CURDIR)\nOPENBLAS_CMAKE_DIR := $(OPENBLAS_LIBRARY_DIR)/cmake/$(LIBSONAMEBASE)\nOPENBLAS_CMAKE_CONFIG := OpenBLASConfig.cmake\nOPENBLAS_CMAKE_CONFIG_VERSION := OpenBLASConfigVersion.cmake\nOPENBLAS_PKGCONFIG_DIR := $(OPENBLAS_LIBRARY_DIR)/pkgconfig\nPKG_EXTRALIB := $(EXTRALIB)\nifeq ($(INTERFACE64),1)\n\tSUFFIX64=64\nendif\nPKGFILE=\"$(DESTDIR)$(OPENBLAS_PKGCONFIG_DIR)/$(LIBSONAMEBASE)$(SUFFIX64).pc\"\n\nifeq ($(USE_OPENMP), 1)\n  ifeq ($(C_COMPILER), PGI)\n          PKG_EXTRALIB += -lomp\n  else\t  \n          PKG_EXTRALIB += -lgomp\n  endif\nendif\t  \n\n.PHONY : install\n.NOTPARALLEL : install\n\nlib.grd :\n\t$(error OpenBLAS: Please run \"make\" firstly)\n\ninstall : \tlib.grd\n\t@-mkdir -p \"$(DESTDIR)$(PREFIX)\"\n\t@-mkdir -p \"$(DESTDIR)$(OPENBLAS_INCLUDE_DIR)\"\n\t@-mkdir -p \"$(DESTDIR)$(OPENBLAS_LIBRARY_DIR)\"\n\t@-mkdir -p \"$(DESTDIR)$(OPENBLAS_BINARY_DIR)\"\n\t@-mkdir -p \"$(DESTDIR)$(OPENBLAS_CMAKE_DIR)\"\n\t@-mkdir -p \"$(DESTDIR)$(OPENBLAS_PKGCONFIG_DIR)\"\n\t@echo Generating openblas_config.h in $(DESTDIR)$(OPENBLAS_INCLUDE_DIR)\n#for inc\n\t@echo \\#ifndef OPENBLAS_CONFIG_H > \"$(DESTDIR)$(OPENBLAS_INCLUDE_DIR)/openblas_config.h\"\n\t@echo \\#define OPENBLAS_CONFIG_H >> \"$(DESTDIR)$(OPENBLAS_INCLUDE_DIR)/openblas_config.h\"\n\t@$(AWK) 'NF {print $$1, \"OPENBLAS_\"$$2, $$3}' config_last.h >> \"$(DESTDIR)$(OPENBLAS_INCLUDE_DIR)/openblas_config.h\"\n\t@echo \\#define OPENBLAS_VERSION \\\" OpenBLAS $(VERSION) \\\" >> \"$(DESTDIR)$(OPENBLAS_INCLUDE_DIR)/openblas_config.h\"\n\t@cat openblas_config_template.h >> \"$(DESTDIR)$(OPENBLAS_INCLUDE_DIR)/openblas_config.h\"\n\t@echo \\#endif  \\/\\* OPENBLAS_CONFIG_H \\*\\/ >> \"$(DESTDIR)$(OPENBLAS_INCLUDE_DIR)/openblas_config.h\"\n\n\t@echo Generating f77blas.h in $(DESTDIR)$(OPENBLAS_INCLUDE_DIR)\n\t@echo \\#ifndef OPENBLAS_F77BLAS_H > \"$(DESTDIR)$(OPENBLAS_INCLUDE_DIR)/f77blas.h\"\n\t@echo \\#define OPENBLAS_F77BLAS_H >> \"$(DESTDIR)$(OPENBLAS_INCLUDE_DIR)/f77blas.h\"\n\t@echo \\#include \\\"openblas_config.h\\\" >> \"$(DESTDIR)$(OPENBLAS_INCLUDE_DIR)/f77blas.h\"\n\t@cat common_interface.h >> \"$(DESTDIR)$(OPENBLAS_INCLUDE_DIR)/f77blas.h\"\n\t@echo \\#endif >> \"$(DESTDIR)$(OPENBLAS_INCLUDE_DIR)/f77blas.h\"\n\nifndef NO_CBLAS\n\t@echo Generating cblas.h in $(DESTDIR)$(OPENBLAS_INCLUDE_DIR)\n\t@cp cblas.h cblas.tmp\nifdef SYMBOLPREFIX\n\t@sed 's/cblas[^() ]*/$(SYMBOLPREFIX)&/g' cblas.tmp > cblas.tmp2\n\t@sed 's/openblas[^() ]*/$(SYMBOLPREFIX)&/g'  cblas.tmp2 > cblas.tmp\n\t#change back any openblas_complex_float and double that got hit\n\t@sed 's/$(SYMBOLPREFIX)openblas_complex_/openblas_complex_/g'  cblas.tmp > cblas.tmp2\n\t@sed 's/goto[^() ]*/$(SYMBOLPREFIX)&/g'  cblas.tmp2 > cblas.tmp\nendif\nifdef SYMBOLSUFFIX\n\t@sed 's/cblas[^() ]*/&$(SYMBOLSUFFIX)/g' cblas.tmp > cblas.tmp2\n\t@sed 's/openblas[^() ]*/&$(SYMBOLSUFFIX)/g'  cblas.tmp2 > cblas.tmp\n\t#change back any openblas_complex_float and double that got hit\n\t@sed 's/\\(openblas_complex_\\)\\([^ ]*\\)$(SYMBOLSUFFIX)/\\1\\2 /g'  cblas.tmp > cblas.tmp2\n\t@sed 's/goto[^() ]*/&$(SYMBOLSUFFIX)/g'  cblas.tmp2 > cblas.tmp\nendif\n\t@sed 's/common/openblas_config/g' cblas.tmp > \"$(DESTDIR)$(OPENBLAS_INCLUDE_DIR)/cblas.h\"\nendif\n\nifneq ($(OSNAME), AIX)\nifneq ($(NO_LAPACKE), 1)\n\t@echo Copying LAPACKE header files to $(DESTDIR)$(OPENBLAS_INCLUDE_DIR)\n\t@-install -m644 $(NETLIB_LAPACK_DIR)/LAPACKE/include/lapack.h \"$(DESTDIR)$(OPENBLAS_INCLUDE_DIR)/lapack.h\"\n\t@-install -m644 $(NETLIB_LAPACK_DIR)/LAPACKE/include/lapacke.h \"$(DESTDIR)$(OPENBLAS_INCLUDE_DIR)/lapacke.h\"\n\t@-install -m644 $(NETLIB_LAPACK_DIR)/LAPACKE/include/lapacke_config.h \"$(DESTDIR)$(OPENBLAS_INCLUDE_DIR)/lapacke_config.h\"\n\t@-install -m644 $(NETLIB_LAPACK_DIR)/LAPACKE/include/lapacke_mangling_with_flags.h.in \"$(DESTDIR)$(OPENBLAS_INCLUDE_DIR)/lapacke_mangling.h\"\n\t@-install -m644 $(NETLIB_LAPACK_DIR)/LAPACKE/include/lapacke_utils.h \"$(DESTDIR)$(OPENBLAS_INCLUDE_DIR)/lapacke_utils.h\"\nendif\n\n#for install static library\nifneq ($(NO_STATIC),1)\n\t@echo Copying the static library to $(DESTDIR)$(OPENBLAS_LIBRARY_DIR)\n\t@install -m644 $(LIBNAME) \"$(DESTDIR)$(OPENBLAS_LIBRARY_DIR)\"\n\t@cd \"$(DESTDIR)$(OPENBLAS_LIBRARY_DIR)\" ; \\\n\t$(LNCMD) $(LIBNAME) $(LIBPREFIX).$(LIBSUFFIX)\nendif\n#for install shared library\nifneq ($(NO_SHARED),1)\n\t@echo Copying the shared library to $(DESTDIR)$(OPENBLAS_LIBRARY_DIR)\nifeq ($(OSNAME), $(filter $(OSNAME),Linux SunOS Android Haiku FreeBSD DragonFly))\n\t@install -m755 $(LIBSONAME) \"$(DESTDIR)$(OPENBLAS_LIBRARY_DIR)\"\n\t@cd \"$(DESTDIR)$(OPENBLAS_LIBRARY_DIR)\" ; \\\n\t$(LNCMD) $(LIBSONAME) $(LIBPREFIX).so ; \\\n\t$(LNCMD) $(LIBSONAME) $(LIBPREFIX).so.$(MAJOR_VERSION)\nendif\n\nifeq ($(OSNAME), $(filter $(OSNAME),OpenBSD NetBSD))\n\t@cp $(LIBSONAME) \"$(DESTDIR)$(OPENBLAS_LIBRARY_DIR)\"\n\t@cd \"$(DESTDIR)$(OPENBLAS_LIBRARY_DIR)\" ; \\\n\t$(LNCMD) $(LIBSONAME) $(LIBPREFIX).so\nendif\nifeq ($(OSNAME), Darwin)\n\t@-cp $(LIBDYNNAME) \"$(DESTDIR)$(OPENBLAS_LIBRARY_DIR)\"\n\t@-install_name_tool -id \"$(OPENBLAS_LIBRARY_DIR)/$(LIBPREFIX).$(MAJOR_VERSION).dylib\" \"$(DESTDIR)$(OPENBLAS_LIBRARY_DIR)/$(LIBDYNNAME)\"\n\t@cd \"$(DESTDIR)$(OPENBLAS_LIBRARY_DIR)\" ; \\\n\t$(LNCMD) $(LIBDYNNAME) $(LIBPREFIX).dylib ; \\\n\t$(LNCMD) $(LIBDYNNAME) $(LIBPREFIX).$(MAJOR_VERSION).dylib\nendif\nifeq ($(OSNAME), WINNT)\n\t@-cp $(LIBDLLNAME) \"$(DESTDIR)$(OPENBLAS_BINARY_DIR)\"\n\t@-cp $(IMPLIBNAME) \"$(DESTDIR)$(OPENBLAS_LIBRARY_DIR)\"\nendif\nifeq ($(OSNAME), CYGWIN_NT)\n\t@-cp $(LIBDLLNAME) \"$(DESTDIR)$(OPENBLAS_BINARY_DIR)\"\n\t@-cp $(IMPLIBNAME) \"$(DESTDIR)$(OPENBLAS_LIBRARY_DIR)\"\nendif\nendif\n\nelse\n#install on AIX has different options syntax\nifneq ($(NO_LAPACKE), 1)\n\t@echo Copying LAPACKE header files to $(DESTDIR)$(OPENBLAS_INCLUDE_DIR)\n\t@-installbsd -c -m 644 $(NETLIB_LAPACK_DIR)/LAPACKE/include/lapack.h \"$(DESTDIR)$(OPENBLAS_INCLUDE_DIR)/lapack.h\"\n\t@-installbsd -c -m 644 $(NETLIB_LAPACK_DIR)/LAPACKE/include/lapacke.h \"$(DESTDIR)$(OPENBLAS_INCLUDE_DIR)/lapacke.h\"\n\t@-installbsd -c -m 644 $(NETLIB_LAPACK_DIR)/LAPACKE/include/lapacke_config.h \"$(DESTDIR)$(OPENBLAS_INCLUDE_DIR)/lapacke_config.h\"\n\t@-installbsd -c -m 644 $(NETLIB_LAPACK_DIR)/LAPACKE/include/lapacke_mangling_with_flags.h.in \"$(DESTDIR)$(OPENBLAS_INCLUDE_DIR)/lapacke_mangling.h\"\n\t@-installbsd -c -m 644 $(NETLIB_LAPACK_DIR)/LAPACKE/include/lapacke_utils.h \"$(DESTDIR)$(OPENBLAS_INCLUDE_DIR)/lapacke_utils.h\"\nendif\n\n#for install static library\nifneq ($(NO_STATIC),1)\n\t@echo Copying the static library to $(DESTDIR)$(OPENBLAS_LIBRARY_DIR)\n\t@installbsd -c -m 644 $(LIBNAME) \"$(DESTDIR)$(OPENBLAS_LIBRARY_DIR)\"\n\t@cd \"$(DESTDIR)$(OPENBLAS_LIBRARY_DIR)\" ; \\\n\t$(LNCMD) $(LIBNAME) $(LIBPREFIX).$(LIBSUFFIX)\nendif\n#for install shared library\nifneq ($(NO_SHARED),1)\n\t@echo Copying the shared library to $(DESTDIR)$(OPENBLAS_LIBRARY_DIR)\n\t@installbsd -c -m 755 $(LIBSONAME) \"$(DESTDIR)$(OPENBLAS_LIBRARY_DIR)\"\n\t@cd \"$(DESTDIR)$(OPENBLAS_LIBRARY_DIR)\" ; \\\n\t$(LNCMD) $(LIBSONAME) $(LIBPREFIX).so ; \\\n\t$(LNCMD) $(LIBSONAME) $(LIBPREFIX).so.$(MAJOR_VERSION)\nendif\n\nendif\n\n#Generating openblas.pc\nifeq ($(INTERFACE64),1)\n\tSUFFIX64=64\nendif\n\tPKGFILE=\"$(DESTDIR)$(OPENBLAS_PKGCONFIG_DIR)/$(LIBSONAMEBASE)$(SUFFIX64).pc\"\n\n\t@echo Generating $(LIBSONAMEBASE)$(SUFFIX64).pc in \"$(DESTDIR)$(OPENBLAS_PKGCONFIG_DIR)\"\n\t@echo 'libdir='$(OPENBLAS_LIBRARY_DIR) > \"$(PKGFILE)\"\n\t@echo 'libprefix='$(LIBNAMEPREFIX) >> \"$(PKGFILE)\"\n\t@echo 'libnamesuffix='$(LIBNAMESUFFIX) >> \"$(PKGFILE)\"\n\t@echo 'libsuffix='$(SYMBOLSUFFIX) >> \"$(PKGFILE)\"\n\t@echo 'includedir='$(OPENBLAS_INCLUDE_DIR) >> \"$(PKGFILE)\"\n\t@echo 'omp_opt='$(FOMP_OPT) >> \"$(PKGFILE)\"\n\t@echo 'openblas_config= USE_64BITINT='$(INTERFACE64) 'DYNAMIC_ARCH='$(DYNAMIC_ARCH) 'DYNAMIC_OLDER='$(DYNAMIC_OLDER) 'NO_CBLAS='$(NO_CBLAS) 'NO_LAPACK='$(NO_LAPACK) 'NO_LAPACKE='$(NO_LAPACKE) 'NO_AFFINITY='$(NO_AFFINITY) 'USE_OPENMP='$(USE_OPENMP) $(TARGET) 'MAX_THREADS='$(NUM_THREADS)>> \"$(PKGFILE)\"\n\t@echo 'version='$(VERSION) >> \"$(PKGFILE)\"\n\t@echo 'extralib='$(PKG_EXTRALIB) >> \"$(PKGFILE)\"\n\t@cat openblas.pc.in >> \"$(PKGFILE)\"\n\n\n#Generating OpenBLASConfig.cmake\n\t@echo Generating $(OPENBLAS_CMAKE_CONFIG) in $(DESTDIR)$(OPENBLAS_CMAKE_DIR)\n\t@echo \"SET(OpenBLAS_VERSION \\\"${VERSION}\\\")\" > \"$(DESTDIR)$(OPENBLAS_CMAKE_DIR)/$(OPENBLAS_CMAKE_CONFIG)\"\n\t@echo \"file(REAL_PATH \\\"../../..\\\" _OpenBLAS_ROOT_DIR BASE_DIRECTORY \\$${CMAKE_CURRENT_LIST_DIR} )\" >> \"$(DESTDIR)$(OPENBLAS_CMAKE_DIR)/$(OPENBLAS_CMAKE_CONFIG)\"\n\t@echo \"SET(OpenBLAS_INCLUDE_DIRS \\$${_OpenBLAS_ROOT_DIR}/include)\" >> \"$(DESTDIR)$(OPENBLAS_CMAKE_DIR)/$(OPENBLAS_CMAKE_CONFIG)\"\n\nifneq ($(NO_SHARED),1)\n#ifeq logical or\nifeq ($(OSNAME), $(filter $(OSNAME),Linux FreeBSD NetBSD OpenBSD DragonFly))\n\t@echo \"SET(OpenBLAS_LIBRARIES \\$${_OpenBLAS_ROOT_DIR}/lib/$(LIBPREFIX).so)\" >> \"$(DESTDIR)$(OPENBLAS_CMAKE_DIR)/$(OPENBLAS_CMAKE_CONFIG)\"\nendif\nifeq ($(OSNAME), $(filter $(OSNAME),WINNT CYGWIN_NT))\n\t@echo \"SET(OpenBLAS_LIBRARIES \\$${_OpenBLAS_ROOT_DIR}/bin/$(LIBDLLNAME))\" >> \"$(DESTDIR)$(OPENBLAS_CMAKE_DIR)/$(OPENBLAS_CMAKE_CONFIG)\"\nendif\nifeq ($(OSNAME), Darwin)\n\t@echo \"SET(OpenBLAS_LIBRARIES \\$${_OpenBLAS_ROOT_DIR}/lib/$(LIBPREFIX).dylib)\" >> \"$(DESTDIR)$(OPENBLAS_CMAKE_DIR)/$(OPENBLAS_CMAKE_CONFIG)\"\nendif\n\t@echo \"add_library(OpenBLAS::OpenBLAS SHARED IMPORTED)\"\n\t@echo \"target_include_directories(OpenBLAS::OpenBLAS INTERFACE \\$${OpenBLAS_INCLUDE_DIRS})\"\nifeq ($(OSNAME), $(filter $(OSNAME),WINNT CYGWIN_NT))\n\t@echo \"set_property(TARGET OpenBLAS::OpenBLAS PROPERTY IMPORTED_LOCATION \\$${OpenBLAS_LIBRARIES})\"\n\t@echo \"set_property(TARGET OpenBLAS::OpenBLAS PROPERTY IMPORTED_IMPLIB \\$${_OpenBLAS_ROOT_DIR}/lib/libopenblas.lib)\"\nendif\nelse\n#only static\n\t@echo \"SET(OpenBLAS_LIBRARIES \\$${_OpenBLAS_ROOT_DIR}/lib/$(LIBPREFIX).$(LIBSUFFIX))\" >> \"$(DESTDIR)$(OPENBLAS_CMAKE_DIR)/$(OPENBLAS_CMAKE_CONFIG)\"\nendif\n#Generating OpenBLASConfigVersion.cmake\n\t@echo Generating $(OPENBLAS_CMAKE_CONFIG_VERSION) in $(DESTDIR)$(OPENBLAS_CMAKE_DIR)\n\t@echo \"set (PACKAGE_VERSION \\\"${VERSION}\\\")\" > \"$(DESTDIR)$(OPENBLAS_CMAKE_DIR)/$(OPENBLAS_CMAKE_CONFIG_VERSION)\"\n\t@echo \"if (PACKAGE_VERSION VERSION_LESS PACKAGE_FIND_VERSION)\" >> \"$(DESTDIR)$(OPENBLAS_CMAKE_DIR)/$(OPENBLAS_CMAKE_CONFIG_VERSION)\"\n\t@echo \"  set (PACKAGE_VERSION_COMPATIBLE FALSE)\" >> \"$(DESTDIR)$(OPENBLAS_CMAKE_DIR)/$(OPENBLAS_CMAKE_CONFIG_VERSION)\"\n\t@echo \"else ()\" >> \"$(DESTDIR)$(OPENBLAS_CMAKE_DIR)/$(OPENBLAS_CMAKE_CONFIG_VERSION)\"\n\t@echo \"  set (PACKAGE_VERSION_COMPATIBLE TRUE)\" >> \"$(DESTDIR)$(OPENBLAS_CMAKE_DIR)/$(OPENBLAS_CMAKE_CONFIG_VERSION)\"\n\t@echo \"  if (PACKAGE_FIND_VERSION STREQUAL PACKAGE_VERSION)\" >> \"$(DESTDIR)$(OPENBLAS_CMAKE_DIR)/$(OPENBLAS_CMAKE_CONFIG_VERSION)\"\n\t@echo \"    set (PACKAGE_VERSION_EXACT TRUE)\" >> \"$(DESTDIR)$(OPENBLAS_CMAKE_DIR)/$(OPENBLAS_CMAKE_CONFIG_VERSION)\"\n\t@echo \"  endif ()\" >> \"$(DESTDIR)$(OPENBLAS_CMAKE_DIR)/$(OPENBLAS_CMAKE_CONFIG_VERSION)\"\n\t@echo \"endif ()\" >> \"$(DESTDIR)$(OPENBLAS_CMAKE_DIR)/$(OPENBLAS_CMAKE_CONFIG_VERSION)\"\n\t@echo Install OK!\n\ninstall_tests : lib.grd\nifneq ($(ONLY_CBLAS), 1)\n\t@install -m 666 utest/openblas_utest $(DESTDIR)$(OPENBLAS_BINARY_DIR)\n\t@install -m 666 utest/openblas_utest_ext $(DESTDIR)$(OPENBLAS_BINARY_DIR)\nifeq ($(NOFORTRAN), $(filter 0,$(NOFORTRAN)))\nifndef NO_FBLAS\nifeq ($(BUILD_BFLOAT16),1)\n\t@install -m 666 test/test_sbgemm $(DESTDIR)$(OPENBLAS_BINARY_DIR)\nendif\nifeq ($(BUILD_SINGLE),1)\n\t@install -m 666 test/sblat1 $(DESTDIR)$(OPENBLAS_BINARY_DIR)\n\t@install -m 666 test/sblat2 $(DESTDIR)$(OPENBLAS_BINARY_DIR)\n\t@install -m 666 test/sblat3 $(DESTDIR)$(OPENBLAS_BINARY_DIR)\n\t@install -m 666 test/sblat2.dat $(DESTDIR)$(OPENBLAS_BINARY_DIR)\n\t@install -m 666 test/sblat3.dat $(DESTDIR)$(OPENBLAS_BINARY_DIR)\nendif\nifeq ($(BUILD_DOUBLE),1)\n\t@install -m 666 test/dblat1 $(DESTDIR)$(OPENBLAS_BINARY_DIR)\n\t@install -m 666 test/dblat2 $(DESTDIR)$(OPENBLAS_BINARY_DIR)\n\t@install -m 666 test/dblat3 $(DESTDIR)$(OPENBLAS_BINARY_DIR)\n\t@install -m 666 test/dblat2.dat $(DESTDIR)$(OPENBLAS_BINARY_DIR)\n\t@install -m 666 test/dblat3.dat $(DESTDIR)$(OPENBLAS_BINARY_DIR)\nendif\nifeq ($(BUILD_COMPLEX),1)\n\t@install -m 666 test/cblat1 $(DESTDIR)$(OPENBLAS_BINARY_DIR)\n\t@install -m 666 test/cblat2 $(DESTDIR)$(OPENBLAS_BINARY_DIR)\n\t@install -m 666 test/cblat3 $(DESTDIR)$(OPENBLAS_BINARY_DIR)\n\t@install -m 666 test/cblat2.dat $(DESTDIR)$(OPENBLAS_BINARY_DIR)\n\t@install -m 666 test/cblat3.dat $(DESTDIR)$(OPENBLAS_BINARY_DIR)\nifeq ($(ARCH), filter($(ARCH), x86 x86_64 ia64 MIPS))\n\t@install -m 666 test/cblat3_3m $(DESTDIR)$(OPENBLAS_BINARY_DIR)\n\t@install -m 666 test/cblat3_3m.dat $(DESTDIR)$(OPENBLAS_BINARY_DIR)\nendif\nendif\nifeq ($(BUILD_COMPLEX16),1)\n\t@install -m 666 test/zblat1 $(DESTDIR)$(OPENBLAS_BINARY_DIR)\n\t@install -m 666 test/zblat2 $(DESTDIR)$(OPENBLAS_BINARY_DIR)\n\t@install -m 666 test/zblat3 $(DESTDIR)$(OPENBLAS_BINARY_DIR)\n\t@install -m 666 test/zblat2.dat $(DESTDIR)$(OPENBLAS_BINARY_DIR)\n\t@install -m 666 test/zblat3.dat $(DESTDIR)$(OPENBLAS_BINARY_DIR)\nifeq ($(ARCH), filter($(ARCH), x86 x86_64 ia64 MIPS))\n\t@install -m 666 test/zblat3_3m $(DESTDIR)$(OPENBLAS_BINARY_DIR)\n\t@install -m 666 test/zblat3_3m.dat $(DESTDIR)$(OPENBLAS_BINARY_DIR)\nendif\nendif\nendif\nendif\nifneq ($(ONLY_CBLAS), 1)\nifeq ($(BUILD_SINGLE),1)\n\t@install -m 666 ctest/xscblat1 $(DESTDIR)$(OPENBLAS_BINARY_DIR)\n\t@install -m 666 ctest/xscblat2 $(DESTDIR)$(OPENBLAS_BINARY_DIR)\n\t@install -m 666 ctest/xscblat3 $(DESTDIR)$(OPENBLAS_BINARY_DIR)\n\t@install -m 666 ctest/sin2 $(DESTDIR)$(OPENBLAS_BINARY_DIR)\n\t@install -m 666 ctest/sin3 $(DESTDIR)$(OPENBLAS_BINARY_DIR)\nendif\nifeq ($(BUILD_DOUBLE),1)\n\t@install -m 666 ctest/xdcblat1 $(DESTDIR)$(OPENBLAS_BINARY_DIR)\n\t@install -m 666 ctest/xdcblat2 $(DESTDIR)$(OPENBLAS_BINARY_DIR)\n\t@install -m 666 ctest/xdcblat3 $(DESTDIR)$(OPENBLAS_BINARY_DIR)\n\t@install -m 666 ctest/din2 $(DESTDIR)$(OPENBLAS_BINARY_DIR)\n\t@install -m 666 ctest/din3 $(DESTDIR)$(OPENBLAS_BINARY_DIR)\nendif\nifeq ($(BUILD_COMPLEX),1)\n\t@install -m 666 ctest/xccblat1 $(DESTDIR)$(OPENBLAS_BINARY_DIR)\n\t@install -m 666 ctest/xccblat2 $(DESTDIR)$(OPENBLAS_BINARY_DIR)\n\t@install -m 666 ctest/xccblat3 $(DESTDIR)$(OPENBLAS_BINARY_DIR)\n\t@install -m 666 ctest/cin2 $(DESTDIR)$(OPENBLAS_BINARY_DIR)\n\t@install -m 666 ctest/cin3 $(DESTDIR)$(OPENBLAS_BINARY_DIR)\nifeq ($(ARCH), filter($(ARCH), x86 x86_64 ia64 MIPS))\n\t@install -m 666 ctest/xccblat3_3m $(DESTDIR)$(OPENBLAS_BINARY_DIR)\n\t@install -m 666 ctest/cin3_3m $(DESTDIR)$(OPENBLAS_BINARY_DIR)\nendif\nendif\nifeq ($(BUILD_COMPLEX16),1)\n\t@install -m 666 ctest/xzcblat1 $(DESTDIR)$(OPENBLAS_BINARY_DIR)\n\t@install -m 666 ctest/xzcblat2 $(DESTDIR)$(OPENBLAS_BINARY_DIR)\n\t@install -m 666 ctest/xzcblat3 $(DESTDIR)$(OPENBLAS_BINARY_DIR)\n\t@install -m 666 ctest/zin2 $(DESTDIR)$(OPENBLAS_BINARY_DIR)\n\t@install -m 666 ctest/zin3 $(DESTDIR)$(OPENBLAS_BINARY_DIR)\nifeq ($(ARCH), filter($(ARCH), x86 x86_64 ia64 MIPS))\n\t@install -m 666 ctest/xzcblat3_3m $(DESTDIR)$(OPENBLAS_BINARY_DIR)\n\t@install -m 666 ctest/zin3_3m $(DESTDIR)$(OPENBLAS_BINARY_DIR)\nendif\nendif\n\nendif\nifeq ($(CPP_THREAD_SAFETY_TEST), 1)\n@install -m 666 cpp_thread_test/dgemm_tester $(DESTDIR)$(OPENBLAS_BINARY_DIR)\n@install -m 666 cpp_thread_test/dgemv_tester $(DESTDIR)$(OPENBLAS_BINARY_DIR)\nendif\nendif\n\n"
        },
        {
          "name": "Makefile.loongarch64",
          "type": "blob",
          "size": 0.025390625,
          "content": "ifdef BINARY64\nelse\nendif\n"
        },
        {
          "name": "Makefile.mips",
          "type": "blob",
          "size": 0.068359375,
          "content": "MSA_FLAGS = -mmsa -mfp64 -mload-store-pairs\nifdef BINARY64\nelse\nendif\n"
        },
        {
          "name": "Makefile.mips64",
          "type": "blob",
          "size": 0.068359375,
          "content": "MSA_FLAGS = -mmsa -mfp64 -mload-store-pairs\nifdef BINARY64\nelse\nendif\n"
        },
        {
          "name": "Makefile.power",
          "type": "blob",
          "size": 5.7490234375,
          "content": "\nifdef USE_THREAD\nifeq ($(USE_THREAD), 0)\nUSE_OPENMP = 0\nelse\nUSE_OPENMP = 1\nendif\nelse\nUSE_OPENMP = 1\nendif\n\nifeq ($(CORE), POWER10)\nifneq ($(C_COMPILER), PGI)\nifeq ($(C_COMPILER), GCC)\nifeq ($(GCCVERSIONGTEQ10), 1)\nCCOMMON_OPT += -Ofast -mcpu=power10 -mtune=power10 -mvsx -fno-fast-math\nelse ifneq ($(GCCVERSIONGT4), 1)\n$(warning your compiler is too old to fully support POWER9, getting a newer version of gcc is recommended)\nCCOMMON_OPT += -Ofast -mcpu=power8 -mtune=power8 -mvsx -fno-fast-math\nelse\n$(warning your compiler is too old to fully support POWER10, getting a newer version of gcc is recommended)\nCCOMMON_OPT += -Ofast -mcpu=power9 -mtune=power9 -mvsx -fno-fast-math\nendif\nelse\nCCOMMON_OPT += -Ofast -mcpu=power10 -mtune=power10 -mvsx -fno-fast-math\nendif\nifeq ($(F_COMPILER), IBM)\nFCOMMON_OPT += -O2 -qrecur -qnosave -qarch=pwr10 -qtune=pwr10 -qfloat=nomaf -qzerosize\nelse\nFCOMMON_OPT += -O2 -frecursive -mcpu=power10 -mtune=power10 -fno-fast-math\nendif\nendif\nendif\n\nifeq ($(CORE), POWER9)\nifneq ($(C_COMPILER), PGI)\nCCOMMON_OPT += -Ofast -mvsx -fno-fast-math\nifeq ($(C_COMPILER), GCC)\nifneq ($(GCCVERSIONGT4), 1)\n$(warning your compiler is too old to fully support POWER9, getting a newer version of gcc is recommended)\nCCOMMON_OPT += -mcpu=power8 -mtune=power8 \nelse\nCCOMMON_OPT += -mcpu=power9 -mtune=power9 \nendif\nelse\nCCOMMON_OPT += -mcpu=power9 -mtune=power9\nendif\nelse\nCCOMMON_OPT += -fast -Mvect=simd -Mcache_align\nendif\nifneq ($(F_COMPILER), PGI)\nifeq ($(F_COMPILER), IBM)\nFCOMMON_OPT += -O2 -qrecur -qnosave -qarch=pwr9 -qtune=pwr9 -qfloat=nomaf -qzerosize\nelse\nFCOMMON_OPT += -O2 -frecursive -fno-fast-math -mcpu=power9 -mtune=power9\nendif\n\nifeq ($(F_COMPILER), GFORTRAN)\nifneq ($(GCCVERSIONGT4), 1)\n$(warning your compiler is too old to fully support POWER9, getting a newer version of gcc is recommended)\nFCOMMON_OPT += -mcpu=power8 -mtune=power8 \nelse\nFCOMMON_OPT += -mcpu=power9 -mtune=power9 \nendif\nendif\nelse\nFCOMMON_OPT += -O2 -Mrecursive\nendif\nendif\n\nifeq ($(CORE), POWER8)\nifneq ($(C_COMPILER), PGI)\nCCOMMON_OPT += -Ofast -mcpu=power8 -mtune=power8 -mvsx  -fno-fast-math\nelse\nCCOMMON_OPT += -fast -Mvect=simd -Mcache_align\nendif\nifneq ($(F_COMPILER), PGI)\nifeq ($(OSNAME), AIX)\nifeq ($(F_COMPILER), IBM)\nFCOMMON_OPT += -O2 -qrecur -qnosave -qarch=pwr8 -qtune=pwr8 -qfloat=nomaf -qzerosize\nelse\nFCOMMON_OPT += -O1 -frecursive -mcpu=power8 -mtune=power8 -fno-fast-math\nendif\nelse\nifeq ($(F_COMPILER), IBM)\nFCOMMON_OPT += -O2 -qrecur -qnosave -qarch=pwr8 -qtune=pwr8 -qfloat=nomaf -qzerosize\nelse\nFCOMMON_OPT += -O2 -frecursive -mcpu=power8 -mtune=power8 -fno-fast-math\nendif\nendif\nelse\nFCOMMON_OPT += -O2 -Mrecursive\nendif\nendif\n\nifeq ($(USE_OPENMP), 1)\nifneq ($(C_COMPILER), PGI)\nCCOMMON_OPT += -DUSE_OPENMP -fopenmp\nelse\nCCOMMON_OPT += -DUSE_OPENMP -mp\nendif\nifeq ($(F_COMPILER), IBM)\nFCOMMON_OPT += -DUSE_OPENMP \nelse\nifneq ($(F_COMPILER), PGI)\nFCOMMON_OPT += -DUSE_OPENMP -fopenmp\nelse\nFCOMMON_OPT += -DUSE_OPENMP -mp\nendif\nendif\nendif\n\nifeq ($(C_COMPILER), CLANG)\nCCOMMON_OPT += -fno-integrated-as\nendif\n# workaround for C->FORTRAN ABI violation in LAPACKE\nifeq ($(F_COMPILER), GFORTRAN)\nFCOMMON_OPT += -fno-optimize-sibling-calls\nendif\n\nFLAMEPATH\t= $(HOME)/flame/lib\n\n#ifeq ($(CORE), CELL)\n#CELL_SDK_ROOT = /opt/IBM/cell-sdk-1.1/sysroot/usr\n#SPU_CC\t         = spu-gcc\n#EXTRALIB\t+= -lspe\n#endif\n\nifeq ($(OSNAME), Linux)\nifdef BINARY64\n# COMPILER_PREFIX = powerpc64-linux-\nelse\n# COMPILER_PREFIX = powerpc-linux-\nendif\nendif\n\n#Either uncomment below line or run make with `USE_MASS=1` to enable support of MASS library\n#USE_MASS = 1\n\nifeq ($(USE_MASS), 1)\n# Path to MASS libs, change it if the libs are installed at any other location\nMASSPATH        = /opt/ibm/xlmass/8.1.5/lib\nCOMMON_OPT     += -mveclibabi=mass -ftree-vectorize -funsafe-math-optimizations -DUSE_MASS\nEXTRALIB       += -L$(MASSPATH) -lmass -lmassvp8 -lmass_simdp8\nendif\n\nifdef BINARY64\n\n\nifeq ($(C_COMPILER)$(F_COMPILER)$(OSNAME), GCCIBMAIX)\n$(error Using GCC and XLF on AIX is not a supported combination.)\nendif\nifeq ($(C_COMPILER)$(F_COMPILER)$(OSNAME), CLANGGFORTRANAIX)\n$(error Using Clang and gFortran on AIX is not a supported combination.)\nendif\n\nifeq ($(OSNAME), AIX)\nifeq ($(C_COMPILER), GCC)\nCCOMMON_OPT\t+= -mpowerpc64 -maix64\nelse\nCCOMMON_OPT\t+= -m64\nendif\nifeq ($(COMPILER_F77), g77)\nFCOMMON_OPT\t+= -mpowerpc64 -maix64\nendif\nifeq ($(F_COMPILER), GFORTRAN)\nFCOMMON_OPT\t+= -mpowerpc64 -maix64\nendif\nifeq ($(COMPILER_F77), xlf)\nFCOMMON_OPT\t+= -q64\nendif\nARFLAGS\t\t= -X 64\nASFLAGS\t\t= -a64\nendif\nelse\nifeq ($(OSNAME), AIX)\nCCOMMON_OPT\t+= -Wa,-a32\nARFLAGS\t\t= -X 32\nASFLAGS\t\t= -a32\nendif\nendif\n\n# CCOMMON_OPT\t+= -maltivec -mabi=altivec\n\nLIBFLAME\t= -L$(FLAMEPATH) -llapack2flame -lflame-lapack -lflame-base $(LIBS)\n\nifeq ($(OSNAME), Darwin)\nCCOMMON_OPT\t+= -force_cpusubtype_ALL\nendif\n\n\nifndef BINARY64\nifeq ($(OSNAME), Linux)\nESSLPATH = -L/opt/ibmcmp/lib -L/opt/ibmcmp/xlf/11.1/lib -Wl,-rpath,/opt/ibmcmp/lib -Wl,-rpath,/opt/ibmcmp/xlf/11.1/lib -lxlf90_r -lxlomp_ser -lxlfmath -lxl -lpthread\nelse\nESSLPATH = -lxlf90_r\nendif\n\n\nLIBVECLIB\t= -framework VecLib\nifndef SMP\nLIBATLAS\t= -L/usr/lib/atlas3.7.11 -lf77blas -latlas -lg2c -lm\nLIBESSL\t\t= -lessl $(ESSLPATH) ../../level1/others/libmisc.a -lm\nelse\nLIBATLAS\t= -L/usr/lib/atlas3.7.11p -lptf77blas -latlas -lm -lpthread\nLIBESSL\t\t= -lesslsmp $(ESSLPATH)  ../../level1/others/libmisc.a -lm\nendif\nelse\nifeq ($(OSNAME), Linux)\nESSLPATH = -L/opt/ibmcmp/lib64 -Wl,-rpath,/opt/ibmcmp/lib64 -L/opt/ibmcmp/xlf/11.1/lib64 -Wl,-rpath,/opt/ibmcmp/xlf/11.1/lib64 -lxlf90_r -lxlomp_ser\nelse\nESSLPATH = -lxlf90_r\nendif\n\nLIBVECLIB\t= /System/Library/Frameworks/vecLib.framework/Versions/Current/vecLib\n\nifndef SMP\nLIBATLAS\t= -L/usr/lib64/atlas3.7.11  -lf77blas -latlas -lg2c -lm\nLIBESSL\t\t= -lessl $(ESSLPATH) -lm\nelse\nLIBATLAS\t= -L/usr/lib64/atlas3.7.11p -lptf77blas -latlas -lm -lpthread\nLIBESSL\t\t= -lesslsmp $(ESSLPATH) -lxlsmp -lm\nendif\nendif\n"
        },
        {
          "name": "Makefile.prebuild",
          "type": "blob",
          "size": 2.60546875,
          "content": "# This is triggered by Makefile.system and runs before any of the code is built.\n\nexport BINARY\nexport USE_OPENMP\n\nifdef DYNAMIC_ARCH\noverride HOST_CFLAGS += -DDYNAMIC_ARCH\nendif\n\nifdef TARGET_CORE\nTARGET_MAKE = Makefile_kernel.conf\nTARGET_CONF = config_kernel.h\nelse\nTARGET_MAKE = Makefile.conf\nTARGET_CONF = config.h\nendif\n\nifdef USE_PERL\nSCRIPTSUFFIX = .pl\nelse\nSCRIPTSUFFIX =\nendif\n\n# CPUIDEMU = ../../cpuid/table.o\n\nifdef CPUIDEMU\nEXFLAGS = -DCPUIDEMU -DVENDOR=99\nendif\n\nifeq ($(TARGET), MIPS24K)\nTARGET_FLAGS = -mips32r2\nendif\n\nifeq ($(TARGET), MIPS1004K)\nTARGET_FLAGS = -mips32r2\nendif\n\nifeq ($(TARGET), P5600)\nTARGET_FLAGS = -mips32r5\nendif\n\nifeq ($(TARGET), I6400)\nTARGET_FLAGS = -mips64r6\nendif\n\nifeq ($(TARGET), P6600)\nTARGET_FLAGS = -mips64r6\nendif\n\nifeq ($(TARGET), I6500)\nTARGET_FLAGS = -mips64r6\nendif\n\nifeq ($(TARGET), C910V)\nTARGET_FLAGS = -march=rv64gcv0p7_zfh_xtheadc -mabi=lp64d\nendif\n\nifeq ($(TARGET), CK860FV)\nTARGET_FLAGS = -march=ck860v -mcpu=ck860fv -mfdivdu -mhard-float\nendif\n\nifeq ($(TARGET), x280)\nTARGET_FLAGS = -march=rv64imafdcv_zba_zbb_zfh -mabi=lp64d\nendif\n\nifeq ($(TARGET), RISCV64_ZVL256B)\nTARGET_FLAGS = -march=rv64imafdcv -mabi=lp64d\nendif\n\nifeq ($(TARGET), RISCV64_ZVL128B)\nTARGET_FLAGS = -march=rv64imafdcv -mabi=lp64d\nendif\n\nifeq ($(TARGET), RISCV64_GENERIC)\nTARGET_FLAGS = -march=rv64imafdc -mabi=lp64d\nendif\n\nall: getarch_2nd\n\t./getarch_2nd  0 >> $(TARGET_MAKE)\n\t./getarch_2nd  1 >> $(TARGET_CONF)\n\n$(TARGET_CONF): c_check$(SCRIPTSUFFIX) f_check$(SCRIPTSUFFIX) getarch\n\t./c_check$(SCRIPTSUFFIX) $(TARGET_MAKE) $(TARGET_CONF) \"$(CC)\" $(TARGET_FLAGS) $(CFLAGS)\nifneq ($(ONLY_CBLAS), 1)\n\t./f_check$(SCRIPTSUFFIX) $(TARGET_MAKE) $(TARGET_CONF) \"$(FC)\" $(TARGET_FLAGS)\nelse\n#When we only build CBLAS, we set NOFORTRAN=2\n\techo \"NOFORTRAN=2\" >> $(TARGET_MAKE)\n\techo \"NO_FBLAS=1\" >> $(TARGET_MAKE)\n\techo \"F_COMPILER=GFORTRAN\"  >> $(TARGET_MAKE)\n\techo \"BU=_\"  >> $(TARGET_MAKE)\n\techo \"#define BUNDERSCORE _\" >> $(TARGET_CONF)\n\techo \"#define NEEDBUNDERSCORE 1\" >> $(TARGET_CONF)\nendif\n\t./getarch 0 >> $(TARGET_MAKE)\n\t./getarch 1 >> $(TARGET_CONF)\n\n\ngetarch : getarch.c cpuid.S dummy $(CPUIDEMU)\n\tavx512=$$(./c_check$(SCRIPTSUFFIX) - - \"$(CC)\" $(TARGET_FLAGS) $(CFLAGS) | grep NO_AVX512); \\\n\trv64gv=$$(./c_check$(SCRIPTSUFFIX) - - \"$(CC)\" $(TARGET_FLAGS) $(CFLAGS) | grep NO_RV64GV); \\\n\t$(HOSTCC) $(HOST_CFLAGS) $(EXFLAGS) $${avx512:+-D$${avx512}} $${rv64gv:+-D$${rv64gv}} -o $(@F) getarch.c cpuid.S $(CPUIDEMU)\n\ngetarch_2nd : getarch_2nd.c $(TARGET_CONF) dummy\nifndef TARGET_CORE\n\t$(HOSTCC) -I. $(HOST_CFLAGS) -o $(@F) getarch_2nd.c\nelse\n\t$(HOSTCC) -I. $(HOST_CFLAGS) -DBUILD_KERNEL -o $(@F) getarch_2nd.c\nendif\n\ndummy:\n\n.PHONY: dummy\n"
        },
        {
          "name": "Makefile.riscv64",
          "type": "blob",
          "size": 0.7216796875,
          "content": "ifeq ($(CORE), C910V)\nCCOMMON_OPT += -march=rv64imafdcv0p7_zfh_xtheadc -mabi=lp64d -mtune=c920\nFCOMMON_OPT += -march=rv64imafdcv0p7_zfh_xtheadc -mabi=lp64d -mtune=c920 -static\nendif\nifeq ($(CORE), x280)\nCCOMMON_OPT += -march=rv64imafdcv_zba_zbb_zfh_zvl512b -mabi=lp64d \nFCOMMON_OPT += -march=rv64imafdcv_zba_zbb_zfh -mabi=lp64d -static\nendif\nifeq ($(CORE), RISCV64_ZVL256B)\nCCOMMON_OPT += -march=rv64imafdcv_zvl256b -mabi=lp64d\nFCOMMON_OPT += -march=rv64imafdcv -mabi=lp64d\nendif\nifeq ($(CORE), RISCV64_ZVL128B)\nCCOMMON_OPT += -march=rv64imafdcv -mabi=lp64d \nFCOMMON_OPT += -march=rv64imafdcv -mabi=lp64d\nendif\nifeq ($(CORE), RISCV64_GENERIC)\nCCOMMON_OPT += -march=rv64imafdc -mabi=lp64d\nFCOMMON_OPT += -march=rv64imafdc -mabi=lp64d\nendif\n"
        },
        {
          "name": "Makefile.rule",
          "type": "blob",
          "size": 13.7490234375,
          "content": "#\n#  Beginning of user configuration\n#\n\n# This library's version\nVERSION = 0.3.29.dev\n\n# If you set this prefix, the library name will be lib$(LIBNAMESUFFIX)openblas.a\n# and lib$(LIBNAMESUFFIX)openblas.so, with a matching soname in the shared library\n# \n# LIBNAMEPREFIX = scipy\n\n# If you set the suffix, the library name will be libopenblas_$(LIBNAMESUFFIX).a\n# and libopenblas_$(LIBNAMESUFFIX).so. Meanwhile, the soname in shared library\n# is libopenblas_$(LIBNAMESUFFIX).so.0.\n# LIBNAMESUFFIX = omp\n\n# You can specify the target architecture, otherwise it's\n# automatically detected.\n# TARGET = PENRYN\n\n# If you want to support multiple architecture in one binary\n# DYNAMIC_ARCH = 1\n\n# If you want the full list of x86_64 architectures supported in DYNAMIC_ARCH\n# mode (including individual optimizied codes for PENRYN, DUNNINGTON, OPTERON,\n# OPTERON_SSE3, ATOM and NANO rather than fallbacks to older architectures)\n# DYNAMIC_OLDER = 1\n\n# C compiler including binary type(32bit / 64bit). Default is gcc.\n# Don't use Intel Compiler or PGI, it won't generate right codes as I expect.\n# CC = gcc\n\n# Fortran compiler. Default is g77.\n# FC = gfortran\n\n# Even you can specify cross compiler. Meanwhile, please set HOSTCC.\n\n# cross compiler for Windows\n# CC = x86_64-w64-mingw32-gcc\n# FC = x86_64-w64-mingw32-gfortran\n\n# cross compiler for 32bit ARM\n# CC = arm-linux-gnueabihf-gcc\n# FC = arm-linux-gnueabihf-gfortran\n\n# cross compiler for 64bit ARM\n# CC = aarch64-linux-gnu-gcc\n# FC = aarch64-linux-gnu-gfortran\n\n\n# If you use the cross compiler, please set this host compiler.\n# HOSTCC = gcc\n\n# If you need 32bit binary, define BINARY=32, otherwise define BINARY=64\n# Please note that AVX is not available on 32-bit.\n# Setting BINARY=32 disables AVX/AVX2/AVX-512.\n# BINARY=64\n\n# About threaded BLAS. It will be automatically detected if you don't\n# specify it.\n# For force setting for single threaded, specify USE_THREAD = 0\n# For force setting for multi  threaded, specify USE_THREAD = 1\n# USE_THREAD = 0\n\n# If you want to build a single-threaded OpenBLAS, but expect to call this\n# from several concurrent threads in some other program, comment this in for\n# thread safety. (This is done automatically for USE_THREAD=1 , and should not\n# be necessary when USE_OPENMP=1)\n# USE_LOCKING = 1\n\n# If you're going to use this library with OpenMP, please comment it in.\n# This flag is always set for POWER8. Don't set USE_OPENMP = 0 if you're targeting POWER8.\n# USE_OPENMP = 1\n\n# The OpenMP scheduler to use - by default this is \"static\" and you\n# will normally not want to change this unless you know that your main\n# workload will involve tasks that have highly unbalanced running times\n# for individual threads. Changing away from \"static\" may also adversely\n# affect memory access locality in NUMA systems. Setting to \"runtime\" will\n# allow you to select the scheduler from the environment variable OMP_SCHEDULE\n# CCOMMON_OPT += -DOMP_SCHED=dynamic\n\n# You can define the maximum number of threads. Basically it should be less\n# than or equal to the number of CPU threads. If you don't specify one, it's\n# automatically detected by the build system.\n# If SMT (aka. HT) is enabled on the system, it may or may not be beneficial to \n# restrict NUM_THREADS to the number of physical cores. By default, the automatic \n# detection includes logical CPUs, thus allowing the use of SMT.\n# Users may opt at runtime to use less than NUM_THREADS threads.\n#\n# Note for package maintainers: you can build OpenBLAS with a large NUM_THREADS\n# value (eg. 32-256) if you expect your users to use that many threads. Due to the way\n# some internal structures are allocated, using a large NUM_THREADS value has a RAM\n# footprint penalty, even if users reduce the actual number of threads at runtime.\n# NUM_THREADS = 24\n\n# If you have enabled USE_OPENMP and your application would call\n# OpenBLAS's calculation API from multiple threads, please comment this in.\n# This flag defines how many instances of OpenBLAS's calculation API can actually\n# run in parallel. If more than NUM_PARALLEL threads call OpenBLAS's calculation API,\n# they need to wait for the preceding API calls to finish or risk data corruption.\n# NUM_PARALLEL = 2\n\n# When multithreading, OpenBLAS needs to use a memory buffer for communicating\n# and collating results for individual subranges of the original matrix. Since\n# the original GotoBLAS of the early 2000s, the default size of this buffer has\n# been set at a value of 32<<20 (which is 32MB) on x86_64 , twice that on PPC.\n# If you expect to handle large problem sizes (beyond about 30000x30000) uncomment\n# this line and adjust the (32<<n) factor if necessary. Usually an insufficient value\n# manifests itself as a crash in the relevant scal kernel (sscal_k, dscal_k etc) \n# BUFFERSIZE = 25\n\n# If you don't need to install the static library, please comment this in.\n# NO_STATIC = 1\n\n# If you don't need to generate the shared library, please comment this in.\n# NO_SHARED = 1\n\n# If you don't need the CBLAS interface, please comment this in.\n# NO_CBLAS = 1\n\n# If you only want the CBLAS interface without installing a Fortran compiler,\n# please comment this in.\n# ONLY_CBLAS = 1\n\n# If you don't need LAPACK, please comment this in.\n# If you set NO_LAPACK=1, the build system automatically sets NO_LAPACKE=1.\n# NO_LAPACK = 1\n\n# If you don't need LAPACKE (C Interface to LAPACK), please comment this in.\n# NO_LAPACKE = 1\n\n# Build LAPACK Deprecated functions since LAPACK 3.6.0\nBUILD_LAPACK_DEPRECATED = 1\n\n# The variable type assumed for the length of character arguments when passing\n# data between Fortran LAPACK and C BLAS (defaults to \"size_t\", but older GCC\n# versions used \"int\"). Mismatches will not cause runtime failures but may result\n# in build warnings or errors when building with link-time optimization (LTO)\n# LAPACK_STRLEN=int\n\n# Build RecursiveLAPACK on top of LAPACK\n# BUILD_RELAPACK = 1\n# Have RecursiveLAPACK actually replace standard LAPACK routines instead of \n# just adding its equivalents with a RELAPACK_ prefix\n# RELAPACK_REPLACE = 1\n\n# If you want to use the legacy threaded Level 3 implementation.\n# USE_SIMPLE_THREADED_LEVEL3 = 1\n\n# If you want to use the new, still somewhat experimental code that uses\n# thread-local storage instead of a central memory buffer in memory.c\n# Note that if your system uses GLIBC, it needs to have at least glibc 2.21\n# for this to work.\n# USE_TLS = 1\n\n# If you want to drive whole 64bit region by BLAS. Not all Fortran\n# compilers support this. It's safe to keep this commented out if you\n# are not sure. (This is equivalent to the \"-i8\" ifort option).\n# INTERFACE64 = 1\n\n# Unfortunately most of kernel won't give us high quality buffer.\n# BLAS tries to find the best region before entering main function,\n# but it will consume time. If you don't like it, you can disable one.\nNO_WARMUP = 1\n\n# Comment this in if you want to disable OpenBLAS's CPU/Memory affinity handling.\n# This feature is only implemented on Linux, and is always disabled on other platforms.\n# Enabling affinity handling may improve performance, especially on NUMA systems, but \n# it may conflict with certain applications that also try to manage affinity.\n# This conflict can result in threads of the application calling OpenBLAS ending up locked\n# to the same core(s) as OpenBLAS, possibly binding all threads to a single core.\n# For this reason, affinity handling is disabled by default. Can be safely enabled if nothing\n# else modifies affinity settings.\n# Note: enabling affinity has been known to cause problems with NumPy and R\nNO_AFFINITY = 1\n\n# If you are compiling for Linux and you have more than 16 numa nodes or more than 256 cpus\n# BIGNUMA = 1\n\n# If you are compiling for an embedded system (\"bare metal\") like Cortex M series\n# Note that you will have to provide implementations of malloc() and free() in this case\n# EMBEDDED = 1\n\n# Don't use AVX kernel on Sandy Bridge. It is compatible with old compilers\n# and OS. However, the performance is low.\n# NO_AVX = 1\n\n# Don't use Haswell optimizations if binutils is too old (e.g. RHEL6)\n# NO_AVX2 = 1\n\n# Don't use SkylakeX optimizations if binutils or compiler are too old (the build\n# system will try to determine this automatically)\n# NO_AVX512 = 1\n\n# Don't use parallel make.\n# NO_PARALLEL_MAKE = 1\n\n# Force number of make jobs. The default is the number of logical CPU of the host.\n# This is particularly useful when using distcc.\n# A negative value will disable adding a -j flag to make, allowing to use a parent\n# make -j value. This is useful to call OpenBLAS make from an other project\n# makefile\n# MAKE_NB_JOBS = 2\n\n# If you would like to know minute performance report of GotoBLAS.\n# FUNCTION_PROFILE = 1\n\n# Support for IEEE quad precision(it's *real* REAL*16)( under testing)\n# This option should not be used - it is a holdover from unfinished code present\n# in the original GotoBLAS2 library that may be usable as a starting point but\n# is not even expected to compile in its present form.\n# QUAD_PRECISION = 1\n\n# Theads are still working for a while after finishing BLAS operation\n# to reduce thread activate/deactivate overhead. You can determine\n# time out to improve performance. This number should be from 4 to 30\n# which corresponds to (1 << n) cycles. For example, if you set to 26,\n# thread will be running for (1 << 26) cycles(about 25ms on 3.0GHz\n# system). Also you can control this number by THREAD_TIMEOUT\n# CCOMMON_OPT\t+= -DTHREAD_TIMEOUT=26\n\n# Using special device driver for mapping physically contiguous memory\n# to the user space. If bigphysarea is enabled, it will use it.\n# DEVICEDRIVER_ALLOCATION = 1\n\n# Use large page allocation (called hugepage support in Linux context)\n# for the thread buffers (with access by shared memory operations)\n# HUGETLB_ALLOCATION = 1\n\n# Use large page allocation called hugepages in Linux) based on mmap accessing\n# a memory-backed pseudofile (requires hugetlbfs to be mounted in the system,\n# the example below has it mounted on /hugepages. OpenBLAS will create the backing\n# file as gotoblas.processid in that path)\n# HUGETLBFILE_ALLOCATION = /hugepages\n\n# If you need to synchronize FP CSR between threads (for x86/x86_64 and aarch64 only).\n# CONSISTENT_FPCSR = 1\n\n# If any gemm argument m, n or k is less or equal this threshold, gemm will be execute\n# with single thread. (Actually in recent versions this is a factor proportional to the\n# number of floating point operations necessary for the given problem size, no longer\n# an individual dimension). You can use this setting to avoid the overhead of multi-\n# threading in small matrix sizes. The default value is 4, but values as high as 50 have \n# been reported to be optimal for certain workloads (50 is the recommended value for Julia).\n# GEMM_MULTITHREAD_THRESHOLD = 4\n\n# If you need sanity check by comparing results to reference BLAS. It'll be very\n# slow (Not implemented yet).\n# SANITY_CHECK = 1\n\n# The installation directory.\n# PREFIX = /opt/OpenBLAS\n\n# Common Optimization Flag;\n# The default -O2 is enough.\n# Flags for POWER8 are defined in Makefile.power. Don't modify COMMON_OPT\n# COMMON_OPT = -O2\n\n# gfortran option for LAPACK to improve thread-safety\n# It is enabled by default in Makefile.system for gfortran\n# Flags for POWER8 are defined in Makefile.power. Don't modify FCOMMON_OPT\n# FCOMMON_OPT = -frecursive\n\n# Profiling flags\nCOMMON_PROF = -pg\n\n# Build Debug version\n# DEBUG = 1\n\n# Set maximum stack allocation.\n# The default value is 2048. 0 disable stack allocation a may reduce GER and GEMV\n# performance. For details, https://github.com/xianyi/OpenBLAS/pull/482\n#\n# MAX_STACK_ALLOC = 0\n\n# Add a prefix or suffix to all exported symbol names in the shared library.\n# Avoid conflicts with other BLAS libraries, especially when using\n# 64 bit integer interfaces in OpenBLAS.\n# For details, https://github.com/xianyi/OpenBLAS/pull/459\n#\n# The same prefix and suffix are also added to the library name,\n# i.e. you get lib$(SYMBOLPREFIX)openblas$(SYMBOLSUFFIX) rather than libopenblas\n#\n# SYMBOLPREFIX=\n# SYMBOLSUFFIX=\n\n# Run a C++ based thread safety tester after the build is done.\n# This is mostly intended as a developer feature to spot regressions, but users and\n# package maintainers can enable this if they have doubts about the thread safety of\n# the library, given the configuration in this file.\n# By default, the thread safety tester launches 52 concurrent calculations at the same\n# time.\n#\n# Please note that the test uses ~1300 MiB of RAM for the DGEMM test.\n#\n# The test requires CBLAS to be built, a C++11 capable compiler and the presence of\n# an OpenMP implementation. If you are cross-compiling this test will probably not\n# work at all.\n#\n# CPP_THREAD_SAFETY_TEST = 1\n#\n# use this to run only the less memory-hungry GEMV test\n# CPP_THREAD_SAFETY_GEMV = 1\n\n\n# If you want to enable the experimental BFLOAT16 support\n# BUILD_BFLOAT16 = 1\n\n\n# Set the thread number threshold beyond which the job array for the threaded level3 BLAS\n# will be allocated on the heap rather than the stack. (This array alone requires \n# NUM_THREADS*NUM_THREADS*128 bytes of memory so should not pose a problem at low cpu\n# counts, but obviously it is not the only item that ends up on the stack.\n# The default value of 32 ensures that the overall requirement is compatible\n# with the default 1MB stacksize imposed by having the Java VM loaded without use\n# of its -Xss parameter.\n# The value of 160 formerly used from about version 0.2.7 until 0.3.10 is easily compatible\n# with the common Linux stacksize of 8MB but will cause crashes with unwary use of the java\n# VM e.g. in Octave or with the java-based libhdfs in numpy or scipy code\n# BLAS3_MEM_ALLOC_THRESHOLD = 160\n\n\n\n# By default the library contains BLAS functions (and LAPACK if selected) for all input types.\n# To build a smaller library supporting e.g. only single precision real (SGEMM etc.) or only\n# the functions for complex numbers, uncomment the desired type(s) below\n# BUILD_SINGLE = 1\n# BUILD_DOUBLE = 1\n# BUILD_COMPLEX = 1\n# BUILD_COMPLEX16 = 1\n#\n#  End of user configuration\n#\n"
        },
        {
          "name": "Makefile.sparc",
          "type": "blob",
          "size": 0.9140625,
          "content": "CPP\t= $(CC) -E\nRANLIB  = ranlib\n\nifdef BINARY64\n\nifeq ($(C_COMPILER), GCC)\nCCOMMON_OPT += -mcpu=v9 -m64\nelse\nCCOMMON_OPT +=  -m64\nendif\nifeq ($(COMPILER_F77), g77)\nFCOMMON_OPT += -mcpu=v9 -m64\nendif\nifeq ($(COMPILER_F77), f95)\nFCOMMON_OPT += -m64\nendif\nelse\n\nifeq ($(C_COMPILER), GCC)\nCCOMMON_OPT += -mcpu=v9\nelse\nCCOMMON_OPT +=  -xarch=v9\nendif\n\nifeq ($(COMPILER_F77), g77)\nFCOMMON_OPT += -mcpu=v9\nendif\nifeq ($(COMPILER_F77), f95)\nFCOMMON_OPT += -xarch=v8plusb\nendif\n\nendif\n\nLIBNAME\t\t= $(LIBPREFIX).a\n\nifndef SMP\nLIBCXML\t\t= -L/opt/SUNWspro/lib/v9\nLIBATLAS\t= -L$(HOME)/misc/lib -lf77blas -latlas -lm\nelse\nLIBCXML\t\t= -lcxmlp -lots -lm\nendif\nifdef BINARY64\nLIBSUNPERF\t= -L/opt/SUNWspro/lib/v9 -L/opt/SUNWspro/prod/lib/v9 \\\n\t\t-Wl,-R,/opt/SUNWspro/lib/v9 -lsunperf -lompstubs -lfui -lfsu -lsunmath\nelse\nLIBSUNPERF\t= -L/opt/SUNWspro/lib -L/opt/SUNWspro/prod/lib \\\n\t\t-Wl,-R,/opt/SUNWspro/lib -lsunperf -lompstubs -lfui -lfsu -lsunmath\nendif\n"
        },
        {
          "name": "Makefile.system",
          "type": "blob",
          "size": 39.654296875,
          "content": "#\n# Include user definition\n#\n\n# TO suppress recursive includes\nINCLUDED = 1\n\nifndef TOPDIR\nTOPDIR = . \nendif\n\nifndef RELAPACK_REPLACE\nRELAPACK_REPLACE=0\nendif\n\n# we need to use the host system's architecture for getarch compile options even especially when cross-compiling\nHOSTARCH := $(shell uname -m)\nifeq ($(HOSTARCH), amd64)\nHOSTARCH=x86_64\nendif\n\n# Catch conflicting usage of ARCH in some BSD environments\nifeq ($(ARCH), amd64)\noverride ARCH=x86_64\nelse ifeq ($(ARCH), powerpc64)\noverride ARCH=power\nelse ifeq ($(ARCH), powerpc64le)\noverride ARCH=power\nelse ifeq ($(ARCH), powerpc)\noverride ARCH=power\nelse ifeq ($(ARCH), i386)\noverride ARCH=x86\nelse ifeq ($(ARCH), armv6)\noverride ARCH=arm\nelse ifeq ($(ARCH), armv7)\noverride ARCH=arm\nelse ifeq ($(ARCH), aarch64)\noverride ARCH=arm64\nelse ifeq ($(ARCH), mipsel)\noverride ARCH=mips\nelse ifeq ($(ARCH), mips64el)\noverride ARCH=mips64\nelse ifeq ($(ARCH), zarch)\noverride ARCH=zarch\nendif\n\nNETLIB_LAPACK_DIR = $(TOPDIR)/lapack-netlib\n\n# Default C compiler\n# - Only set if not specified on the command line or inherited from the environment.\n# - CC is an implicit variable so neither '?=' or 'ifndef' can be used.\n#   http://stackoverflow.com/questions/4029274/mingw-and-make-variables\n# - Default value is 'cc' which is not always a valid command (e.g. MinGW).\nifeq ($(origin CC),default)\n\n# Check if $(CC) refers to a valid command and set the value to gcc if not\nifneq ($(findstring cmd.exe,$(SHELL)),)\nifeq ($(shell where $(CC) 2>NUL),)\nCC = gcc\nendif\nelse # POSIX-ish\nifeq ($(shell command -v $(CC) 2>/dev/null),)\nifeq ($(shell uname -s),Darwin)\nCC = clang\n# EXTRALIB += -Wl,-no_compact_unwind\nelse\nCC = gcc\nendif # Darwin\nendif # CC exists\nendif # Shell is sane\n\nendif # CC is set to default\n\n# Default Fortran compiler (FC) is selected by f_check.\n\nifndef MAKEFILE_RULE\ninclude $(TOPDIR)/Makefile.rule\nelse\ninclude $(TOPDIR)/$(MAKEFILE_RULE)\nendif\n\n#\n#  Beginning of system configuration\n#\nifneq ($(BUILD_SINGLE),1)\nifneq ($(BUILD_DOUBLE),1)\nifneq ($(BUILD_COMPLEX),1)\nifneq ($(BUILD_COMPLEX16),1)\noverride BUILD_SINGLE=1\noverride BUILD_DOUBLE=1\noverride BUILD_COMPLEX=1\noverride BUILD_COMPLEX16=1\nendif\nendif\nendif\nendif\n\nifndef HOSTCC\nHOSTCC\t = $(CC)\nendif\n\nifdef TARGET\nGETARCH_FLAGS := -DFORCE_$(TARGET)\nGETARCH_FLAGS += -DUSER_TARGET\nifeq ($(TARGET), GENERIC)\nifeq ($(DYNAMIC_ARCH), 1)\noverride NO_EXPRECISION=1\nexport NO_EXPRECISION\nendif\nendif\nendif\n\n# Force fallbacks for 32bit\n\nifeq ($(BINARY), 32)\nifeq ($(TARGET), HASWELL)\nGETARCH_FLAGS := -DFORCE_NEHALEM\nendif\nifeq ($(TARGET), SKYLAKEX)\nGETARCH_FLAGS := -DFORCE_NEHALEM\nendif\nifeq ($(TARGET), COOPERLAKE)\nGETARCH_FLAGS := -DFORCE_NEHALEM\nendif\nifeq ($(TARGET), SAPPHIRERAPIDS)\nGETARCH_FLAGS := -DFORCE_NEHALEM\nendif\nifeq ($(TARGET), SANDYBRIDGE)\nGETARCH_FLAGS := -DFORCE_NEHALEM\nendif\nifeq ($(TARGET), BULLDOZER)\nGETARCH_FLAGS := -DFORCE_BARCELONA\nendif\nifeq ($(TARGET), PILEDRIVER)\nGETARCH_FLAGS := -DFORCE_BARCELONA\nendif\nifeq ($(TARGET), STEAMROLLER)\nGETARCH_FLAGS := -DFORCE_BARCELONA\nendif\nifeq ($(TARGET), EXCAVATOR)\nGETARCH_FLAGS := -DFORCE_BARCELONA\nendif\nifeq ($(TARGET), ZEN)\nGETARCH_FLAGS := -DFORCE_BARCELONA\nendif\nifeq ($(TARGET), ARMV8)\nGETARCH_FLAGS := -DFORCE_ARMV7\nendif\nifeq ($(TARGET), POWER8)\nGETARCH_FLAGS := -DFORCE_POWER6\nendif\nifeq ($(TARGET), POWER9)\nGETARCH_FLAGS := -DFORCE_POWER6\nendif\nifeq ($(TARGET), POWER10)\nGETARCH_FLAGS := -DFORCE_POWER6\nendif\nendif\n\n#TARGET_CORE will override TARGET which is used in DYNAMIC_ARCH=1.\n#\nifdef TARGET_CORE\nGETARCH_FLAGS := -DFORCE_$(TARGET_CORE)\nendif\n\n# Force fallbacks for 32bit\n\nifeq ($(BINARY), 32)\nifeq ($(TARGET_CORE), HASWELL)\nGETARCH_FLAGS := -DFORCE_NEHALEM\nendif\nifeq ($(TARGET_CORE), SKYLAKEX)\nGETARCH_FLAGS := -DFORCE_NEHALEM\nendif\nifeq ($(TARGET_CORE), COOPERLAKE)\nGETARCH_FLAGS := -DFORCE_NEHALEM\nendif\nifeq ($(TARGET_CORE), SAPPHIRERAPIDS)\nGETARCH_FLAGS := -DFORCE_NEHALEM\nendif\nifeq ($(TARGET_CORE), SANDYBRIDGE)\nGETARCH_FLAGS := -DFORCE_NEHALEM\nendif\nifeq ($(TARGET_CORE), BULLDOZER)\nGETARCH_FLAGS := -DFORCE_BARCELONA\nendif\nifeq ($(TARGET_CORE), PILEDRIVER)\nGETARCH_FLAGS := -DFORCE_BARCELONA\nendif\nifeq ($(TARGET_CORE), STEAMROLLER)\nGETARCH_FLAGS := -DFORCE_BARCELONA\nendif\nifeq ($(TARGET_CORE), EXCAVATOR)\nGETARCH_FLAGS := -DFORCE_BARCELONA\nendif\nifeq ($(TARGET_CORE), ZEN)\nGETARCH_FLAGS := -DFORCE_BARCELONA\nendif\nendif\n\n\n# On x86_64 build getarch with march=native unless the compiler is PGI. This is required to detect AVX512 support in getarch.\nifeq ($(HOSTARCH), x86_64)\nifeq ($(findstring pgcc,$(HOSTCC))$(findstring nvc,$(HOSTCC)),)\nGETARCH_FLAGS += -march=native\nendif\nendif\n\nifdef INTERFACE64\nifneq ($(INTERFACE64), 0)\nGETARCH_FLAGS\t+= -DUSE64BITINT\nendif\nendif\n\nifndef GEMM_MULTITHREAD_THRESHOLD\nGEMM_MULTITHREAD_THRESHOLD=4\nendif\nGETARCH_FLAGS\t+= -DGEMM_MULTITHREAD_THRESHOLD=$(GEMM_MULTITHREAD_THRESHOLD)\n\nifeq ($(NO_AVX), 1)\nGETARCH_FLAGS\t+= -DNO_AVX\nendif\n\nifeq ($(BINARY), 32)\nGETARCH_FLAGS\t+= -DNO_AVX -DNO_AVX2 -DNO_AVX512\nNO_AVX512 = 1\nendif\n\nifeq ($(NO_AVX2), 1)\nGETARCH_FLAGS\t+= -DNO_AVX2\nendif\n\nifeq ($(NO_AVX512), 1)\nGETARCH_FLAGS\t+= -DNO_AVX512\nendif\n\nifeq ($(DEBUG), 1)\nGETARCH_FLAGS\t+= -g\nendif\n\nifeq ($(QUIET_MAKE), 1)\nMAKE += -s\nendif\n\nifndef NO_PARALLEL_MAKE\nNO_PARALLEL_MAKE=0\nendif\nGETARCH_FLAGS\t+= -DNO_PARALLEL_MAKE=$(NO_PARALLEL_MAKE)\n\nifdef MAKE_NB_JOBS\nGETARCH_FLAGS += -DMAKE_NB_JOBS=$(MAKE_NB_JOBS)\nendif\n\nifeq ($(HOSTCC), loongcc)\nGETARCH_FLAGS  += -static\nendif\n\n#if don't use Fortran, it will only compile CBLAS.\nifeq ($(ONLY_CBLAS), 1)\nNO_LAPACK = 1\nelse\nONLY_CBLAS = 0\nendif\n\n#For small matrix optimization\nifeq ($(ARCH), x86_64)\nSMALL_MATRIX_OPT = 1\nelse ifeq ($(ARCH), power)\nSMALL_MATRIX_OPT = 1\nBUILD_BFLOAT16 = 1\nelse ifeq ($(ARCH), arm64)\nSMALL_MATRIX_OPT = 1\nendif\nifeq ($(ARCH), loongarch64)\nSMALL_MATRIX_OPT = 1\nendif\nifeq ($(ARCH), arm64)\nGEMM_GEMV_FORWARD = 1\nendif\nifeq ($(ARCH), riscv)\nGEMM_GEMV_FORWARD = 1\nendif\nifeq ($(ARCH), power)\nGEMM_GEMV_FORWARD = 1\nGEMM_GEMV_FORWARD_BF16 = 1\nendif\n\nifeq ($(SMALL_MATRIX_OPT), 1)\nCCOMMON_OPT += -DSMALL_MATRIX_OPT\nendif\nifneq ($(ONLY_CBLAS), 1)\nifeq ($(GEMM_GEMV_FORWARD), 1)\nCCOMMON_OPT += -DGEMM_GEMV_FORWARD\nendif\nifeq ($(GEMM_GEMV_FORWARD_BF16), 1)\nCCOMMON_OPT += -DGEMM_GEMV_FORWARD_BF16\nendif\nendif\n\n# This operation is expensive, so execution should be once.\nifndef GOTOBLAS_MAKEFILE\nexport GOTOBLAS_MAKEFILE = 1\n\n# Generating Makefile.conf and config.h\nDUMMY := $(shell $(MAKE) -C $(TOPDIR) -f Makefile.prebuild CC=\"$(CC)\" FC=\"$(FC)\" HOSTCC=\"$(HOSTCC)\" HOST_CFLAGS=\"$(GETARCH_FLAGS)\" CFLAGS=\"$(CFLAGS)\" BINARY=$(BINARY) USE_OPENMP=$(USE_OPENMP) DYNAMIC_ARCH=$(DYNAMIC_ARCH) TARGET_CORE=$(TARGET_CORE) ONLY_CBLAS=$(ONLY_CBLAS) TARGET=$(TARGET) all)\n\nendif\n\nifndef TARGET_CORE\n-include $(TOPDIR)/Makefile.conf\nelse\nHAVE_NEON=\nHAVE_VFP=\nHAVE_VFPV3=\nHAVE_VFPV4=\nHAVE_MMX=\nHAVE_SSE=\nHAVE_SSE2=\nHAVE_SSE3=\nHAVE_SSSE3=\nHAVE_SSE4_1=\nHAVE_SSE4_2=\nHAVE_SSE4A=\nHAVE_SSE5=\nHAVE_AVX=\nHAVE_AVX2=\nHAVE_FMA3=\ninclude $(TOPDIR)/Makefile_kernel.conf\nendif\n\n\nifndef NUM_PARALLEL\nNUM_PARALLEL = 1\nendif\n\nifndef NUM_THREADS\nNUM_THREADS = $(NUM_CORES)\nendif\n\nifeq ($(NUM_THREADS), 1)\noverride USE_THREAD = 0\noverride USE_OPENMP = 0\nendif\n\nifdef USE_THREAD\nifeq ($(USE_THREAD), 0)\nSMP =\nelse\nSMP = 1\nendif\nelse\nifeq ($(NUM_THREADS), 1)\nSMP =\nelse\nSMP = 1\nendif\nendif\n\nifeq ($(SMP), 1)\nUSE_LOCKING = \nendif\n\nifndef NEED_PIC\nNEED_PIC = 1\nendif\n\nARFLAGS\t=\nCPP\t= $(COMPILER) -E\nAR\t?= $(CROSS_SUFFIX)ar\nAS\t?= $(CROSS_SUFFIX)as\nLD\t?= $(CROSS_SUFFIX)ld\nRANLIB\t?= $(CROSS_SUFFIX)ranlib\nNM\t= $(CROSS_SUFFIX)nm\nDLLWRAP = $(CROSS_SUFFIX)dllwrap\nOBJCOPY = $(CROSS_SUFFIX)objcopy\nOBJCONV = $(CROSS_SUFFIX)objconv\n\n\n# When fortran support was either not detected or actively deselected, only build BLAS.\nifeq ($(NOFORTRAN), 1)\nC_LAPACK = 1\noverride FEXTRALIB = \nendif\n\nifeq ($(C_COMPILER), GCC)\nGCCVERSIONGTEQ4 := $(shell expr `$(CC) -dumpversion | cut -f1 -d.` \\>= 4)\nGCCVERSIONGT4 := $(shell expr `$(CC) -dumpversion | cut -f1 -d.` \\> 4)\nGCCVERSIONGT5 := $(shell expr `$(CC) -dumpversion | cut -f1 -d.` \\> 5)\nGCCVERSIONGTEQ7 := $(shell expr `$(CC) -dumpversion | cut -f1 -d.` \\>= 7)\nGCCVERSIONGTEQ8 := $(shell expr `$(CC) -dumpversion | cut -f1 -d.` \\>= 8)\nGCCVERSIONGTEQ9 := $(shell expr `$(CC) -dumpversion | cut -f1 -d.` \\>= 9)\nGCCVERSIONGTEQ10 := $(shell expr `$(CC) -dumpversion | cut -f1 -d.` \\>= 10)\nGCCVERSIONGTEQ11 := $(shell expr `$(CC) -dumpversion | cut -f1 -d.` \\>= 11)\nGCCVERSIONGTEQ12 := $(shell expr `$(CC) -dumpversion | cut -f1 -d.` \\>= 12)\n# Note that the behavior of -dumpversion is compile-time-configurable for\n# gcc-7.x and newer. Use -dumpfullversion there\nifeq ($(GCCVERSIONGTEQ7),1)\n\tGCCDUMPVERSION_PARAM := -dumpfullversion\nelse\n\tGCCDUMPVERSION_PARAM := -dumpversion\nendif\nGCCMINORVERSIONGTEQ1 := $(shell expr `$(CC) $(GCCDUMPVERSION_PARAM) | cut -f2 -d.` \\>= 1)\nGCCMINORVERSIONGTEQ2 := $(shell expr `$(CC) $(GCCDUMPVERSION_PARAM) | cut -f2 -d.` \\>= 2)\nGCCMINORVERSIONGTEQ4 := $(shell expr `$(CC) $(GCCDUMPVERSION_PARAM) | cut -f2 -d.` \\>= 4)\nGCCMINORVERSIONGTEQ7 := $(shell expr `$(CC) $(GCCDUMPVERSION_PARAM) | cut -f2 -d.` \\>= 7)\nendif\n\nifeq ($(C_COMPILER), CLANG)\nCLANGVERSIONGTEQ9 := $(shell expr `$(CC) -dumpversion | cut -f1 -d.` \\>= 9)\nCLANGVERSIONGTEQ12 := $(shell expr `$(CC) -dumpversion | cut -f1 -d.` \\>= 12)\nendif\n\n#\n#  OS dependent settings\n#\n\nifeq ($(OSNAME), Darwin)\nifndef MACOSX_DEPLOYMENT_TARGET\nifeq ($(ARCH), arm64)\nexport MACOSX_DEPLOYMENT_TARGET=11.0\nifeq ($(C_COMPILER), GCC)\nexport NO_SVE = 1\nendif\nelse\nexport MACOSX_DEPLOYMENT_TARGET=10.8\nendif\nendif\nMD5SUM = md5 -r\nXCVER = $(shell pkgutil --pkg-info=com.apple.pkg.Xcode |awk '/version:/ {print $2}'|cut -d: -f2|cut -f1 -d.)\nifeq (x$(XCVER)x,xx)\nXCVER = $(shell pkgutil --pkg-info=com.apple.pkg.CLTools_Executables |awk '/version:/ {print $2}'|cut -d: -f2|cut -f1 -d.)\nendif\nifeq (x$(XCVER), x 15)\nCCOMMON_OPT += -Wl,-ld_classic\nFCOMMON_OPT += -Wl,-ld_classic\nendif\nendif\n\nifneq (,$(findstring $(OSNAME), FreeBSD OpenBSD DragonFly))\nMD5SUM = md5 -r\nendif\n\nifeq ($(OSNAME), NetBSD)\nMD5SUM = md5 -n\nendif\n\nifeq ($(OSNAME), Linux)\nEXTRALIB\t+= -lm\n#NO_EXPRECISION = 1\nendif\n\nifeq ($(OSNAME), Android)\nEXTRALIB\t+= -lm\nendif\n\nifeq ($(OSNAME), AIX)\nEXTRALIB\t+= -lm\nendif\n\nifeq ($(OSNAME), $(filter $(OSNAME),FreeBSD OpenBSD NetBSD DragonFly))\nifeq ($(ARCH), $(filter $(ARCH),arm arm64))\nEXTRALIB\t+= -lm\nendif\nendif\n\nifeq ($(OSNAME), WINNT)\nNEED_PIC = 0\nNO_EXPRECISION = 1\n\nEXTRALIB        += -defaultlib:advapi32\n\nSUFFIX  = obj\nPSUFFIX = pobj\nLIBSUFFIX = a\n\nifeq ($(C_COMPILER), CLANG)\nCCOMMON_OPT\t+= -DMS_ABI\nendif\n\n#Version tests for supporting specific features (MS_ABI, POWER9 intrinsics)\nifeq ($(GCCVERSIONGT4), 1)\n# GCC Major version > 4\n# It is compatible with MSVC ABI.\nCCOMMON_OPT\t+= -DMS_ABI\nendif\n\nifeq ($(GCCVERSIONGTEQ4), 1)\nifeq ($(GCCMINORVERSIONGTEQ7), 1)\n# GCC Version >=4.7\n# It is compatible with MSVC ABI.\nCCOMMON_OPT\t+= -DMS_ABI\nendif\nendif\n\n# Ensure the correct stack alignment on Win32\n# http://permalink.gmane.org/gmane.comp.lib.openblas.general/97\nifeq ($(ARCH), x86)\nCCOMMON_OPT += -mincoming-stack-boundary=2\nFCOMMON_OPT += -mincoming-stack-boundary=2\nendif\n\nendif\n\nifeq ($(OSNAME), Interix)\nNEED_PIC = 0\nNO_EXPRECISION = 1\n\nINTERIX_TOOL_DIR = /opt/gcc.3.3/i586-pc-interix3/bin\nendif\n\nifeq ($(OSNAME), CYGWIN_NT)\nNEED_PIC = 0\nNO_EXPRECISION = 1\nOS_CYGWIN_NT = 1\nendif\n\nifneq ($(OSNAME), WINNT)\nifneq ($(OSNAME), CYGWIN_NT)\nifneq ($(OSNAME), Interix)\nifneq ($(OSNAME), Android)\nifdef SMP\nEXTRALIB   += -lpthread\nendif\nendif\nendif\nendif\nendif\n\n# ifeq logical or\nifeq ($(OSNAME), $(filter $(OSNAME),WINNT CYGWIN_NT Interix))\nOS_WINDOWS=1\nendif\n\nifdef QUAD_PRECISION\nCCOMMON_OPT\t+= -DQUAD_PRECISION\nNO_EXPRECISION = 1\nendif\n\nifneq ($(ARCH), x86)\nifneq ($(ARCH), x86_64)\nNO_EXPRECISION = 1\nendif\nendif\n\nifdef UTEST_CHECK\nCCOMMON_OPT\t+= -DUTEST_CHECK\nSANITY_CHECK = 1\nendif\n\nifdef SANITY_CHECK\nCCOMMON_OPT\t+= -DSANITY_CHECK -DREFNAME=$(*F)f$(BU)\nendif\n\nMAX_STACK_ALLOC ?= 2048\nifneq ($(MAX_STACK_ALLOC), 0)\nCCOMMON_OPT\t+= -DMAX_STACK_ALLOC=$(MAX_STACK_ALLOC)\nendif\n\nifdef USE_LOCKING\nifneq ($(USE_LOCKING), 0)\nCCOMMON_OPT\t+= -DUSE_LOCKING\nendif\nendif\n\n#\n#  Architecture dependent settings\n#\n\nifeq ($(ARCH), x86)\nifndef BINARY\nNO_BINARY_MODE\t= 1\nendif\n\nifeq ($(CORE), generic)\n#NO_EXPRECISION = 1\nendif\n\nifndef NO_EXPRECISION\nifeq ($(F_COMPILER), GFORTRAN)\n# ifeq logical or. GCC or LSB\nifeq ($(C_COMPILER), $(filter $(C_COMPILER),GCC LSB))\nEXPRECISION\t= 1\nCCOMMON_OPT\t+= -DEXPRECISION -m128bit-long-double\nFCOMMON_OPT\t+= -m128bit-long-double\nendif\nifeq ($(C_COMPILER), CLANG)\nEXPRECISION\t= 1\nCCOMMON_OPT\t+= -DEXPRECISION\nFCOMMON_OPT\t+= -m128bit-long-double\nendif\nendif\nendif\nendif\n\nifeq ($(ARCH), x86_64)\n\nifeq ($(CORE), generic)\n#NO_EXPRECISION = 1\nendif\n\nifndef NO_EXPRECISION\nifeq ($(F_COMPILER), GFORTRAN)\n# ifeq logical or. GCC or LSB\nifeq ($(C_COMPILER), $(filter $(C_COMPILER),GCC LSB))\nEXPRECISION\t= 1\nCCOMMON_OPT\t+= -DEXPRECISION -m128bit-long-double\nFCOMMON_OPT\t+= -m128bit-long-double\nendif\nifeq ($(C_COMPILER), CLANG)\nEXPRECISION\t= 1\nCCOMMON_OPT\t+= -DEXPRECISION\nFCOMMON_OPT\t+= -m128bit-long-double\nendif\nendif\nendif\nendif\n\nifeq ($(C_COMPILER), INTEL)\nCCOMMON_OPT    += -wd981\nendif\n\n\nifeq ($(USE_OPENMP), 1)\n\n#check\nifeq ($(USE_THREAD), 0)\n$(error OpenBLAS: Cannot set both USE_OPENMP=1 and USE_THREAD=0. The USE_THREAD=0 is only for building single thread version.)\nendif\n\n# ifeq logical or. GCC or LSB\nifeq ($(C_COMPILER), $(filter $(C_COMPILER),GCC LSB))\nCCOMMON_OPT    += -fopenmp\nendif\n\nifeq ($(C_COMPILER), CLANG)\nCCOMMON_OPT    += -fopenmp\nifeq ($(F_COMPILER), GFORTRAN)\nFEXTRALIB := $(subst -lgomp,-lomp,$(FEXTRALIB))\nendif\nendif\n\nifeq ($(C_COMPILER), INTEL)\nCCOMMON_OPT    += -fopenmp\nendif\n\nifeq ($(C_COMPILER), PGI)\nCCOMMON_OPT    += -mp\nendif\n\nifeq ($(C_COMPILER), OPEN64)\nCCOMMON_OPT    += -mp\nCEXTRALIB   += -lstdc++\nendif\n\nifeq ($(C_COMPILER), PATHSCALE)\nCCOMMON_OPT    += -mp\nendif\nendif\n\n\nifeq ($(DYNAMIC_ARCH), 1)\nifeq ($(ARCH), x86)\nDYNAMIC_CORE = KATMAI COPPERMINE NORTHWOOD PRESCOTT BANIAS \\\n\t       CORE2 PENRYN DUNNINGTON NEHALEM ATHLON OPTERON OPTERON_SSE3 BARCELONA BOBCAT ATOM NANO\nendif\n\nifeq ($(ARCH), x86_64)\nDYNAMIC_CORE = PRESCOTT CORE2 \nifeq ($(DYNAMIC_OLDER), 1)\nDYNAMIC_CORE += PENRYN DUNNINGTON \nendif\nDYNAMIC_CORE += NEHALEM \nifeq ($(DYNAMIC_OLDER), 1)\nDYNAMIC_CORE += OPTERON OPTERON_SSE3 \nendif\nDYNAMIC_CORE += BARCELONA \nifeq ($(DYNAMIC_OLDER), 1)\nDYNAMIC_CORE += BOBCAT ATOM NANO\nendif\nifneq ($(NO_AVX), 1)\nDYNAMIC_CORE += SANDYBRIDGE BULLDOZER PILEDRIVER STEAMROLLER EXCAVATOR\nendif\nifneq ($(NO_AVX2), 1)\nDYNAMIC_CORE += HASWELL ZEN\nendif\nifneq ($(NO_AVX512), 1)\nifneq ($(NO_AVX2), 1)\nDYNAMIC_CORE += SKYLAKEX COOPERLAKE SAPPHIRERAPIDS\nendif\nendif\nendif\n\nifdef DYNAMIC_LIST\noverride DYNAMIC_CORE = PRESCOTT $(DYNAMIC_LIST)\nXCCOMMON_OPT = -DDYNAMIC_LIST -DDYN_PRESCOTT\nXCCOMMON_OPT += $(foreach dcore,$(DYNAMIC_LIST),-DDYN_$(dcore))\nCCOMMON_OPT += $(XCCOMMON_OPT)\n#CCOMMON_OPT\t+= -DDYNAMIC_LIST='$(DYNAMIC_LIST)'\nendif\n\nifeq ($(ARCH), arm64)\nDYNAMIC_CORE =  ARMV8\nDYNAMIC_CORE += CORTEXA53\nDYNAMIC_CORE += CORTEXA57\nDYNAMIC_CORE += NEOVERSEN1\nifneq ($(NO_SVE), 1)\nDYNAMIC_CORE += NEOVERSEV1\nDYNAMIC_CORE += NEOVERSEN2\nDYNAMIC_CORE += ARMV8SVE\nDYNAMIC_CORE += A64FX\nendif\nDYNAMIC_CORE += THUNDERX\nDYNAMIC_CORE += THUNDERX2T99\nDYNAMIC_CORE += TSV110\nDYNAMIC_CORE += EMAG8180\nDYNAMIC_CORE += THUNDERX3T110\nifdef DYNAMIC_LIST\noverride DYNAMIC_CORE = ARMV8 $(DYNAMIC_LIST)\nXCCOMMON_OPT = -DDYNAMIC_LIST -DDYN_ARMV8\nXCCOMMON_OPT += $(foreach dcore,$(DYNAMIC_LIST),-DDYN_$(dcore))\nendif\nendif\n\nifeq ($(ARCH), mips64)\nDYNAMIC_CORE = LOONGSON3R3 LOONGSON3R4 MIPS64_GENERIC\nifdef DYNAMIC_LIST\noverride DYNAMIC_CORE = MIPS64_GENERIC $(DYNAMIC_LIST)\nXCCOMMON_OPT = -DDYNAMIC_LIST -DDYN_MIPS64_GENERIC\nXCCOMMON_OPT += $(foreach dcore,$(DYNAMIC_LIST),-DDYN_$(dcore))\nendif\nendif\n\nifeq ($(ARCH), loongarch64)\nDYNAMIC_CORE = LA64_GENERIC LA264 LA464\nendif\n\nifeq ($(ARCH), riscv64)\nDYNAMIC_CORE = RISCV64_GENERIC\nDYNAMIC_CORE += RISCV64_ZVL128B\nDYNAMIC_CORE += RISCV64_ZVL256B\nifdef DYNAMIC_LIST\noverride DYNAMIC_CORE = RISCV64_GENERIC $(DYNAMIC_LIST)\nXCCOMMON_OPT = -DDYNAMIC_LIST -DDYN_RISCV64_GENERIC\nXCCOMMON_OPT += $(foreach dcore,$(DYNAMIC_LIST),-DDYN_$(dcore))\nendif\nendif\n\nifeq ($(ARCH), zarch)\nDYNAMIC_CORE = ZARCH_GENERIC\n\n# if the compiler accepts -march=arch11 or -march=z13 and can compile a file\n# with z13-specific inline assembly, then we can include support for Z13.\n# note: -march=z13 is equivalent to -march=arch11 yet some compiler releases\n# only support one or the other.\n# note: LLVM version 6.x supported -march=z13 yet could not handle vector\n# registers in inline assembly, so the check for supporting the -march flag is\n# not enough.\nZARCH_TEST_COMPILE=-c $(TOPDIR)/kernel/zarch/damin_z13.c -I$(TOPDIR) -o /dev/null > /dev/null 2> /dev/null\nZARCH_CC_SUPPORTS_ARCH11=$(shell $(CC) -march=arch11 $(ZARCH_TEST_COMPILE) && echo 1)\nZARCH_CC_SUPPORTS_Z13=$(shell $(CC) -march=z13 $(ZARCH_TEST_COMPILE) && echo 1)\n\nifeq ($(or $(ZARCH_CC_SUPPORTS_ARCH11), $(ZARCH_CC_SUPPORTS_Z13)), 1)\nDYNAMIC_CORE += Z13\nCCOMMON_OPT += -DDYN_Z13\nelse\n$(info OpenBLAS: Not building Z13 kernels because the compiler $(CC) does not support it)\nendif\n\n# as above for z13, check for -march=arch12 and z14 support in the compiler.\nZARCH_CC_SUPPORTS_ARCH12=$(shell $(CC) -march=arch12 $(ZARCH_TEST_COMPILE) && echo 1)\nZARCH_CC_SUPPORTS_Z14=$(shell $(CC) -march=z14 $(ZARCH_TEST_COMPILE) && echo 1)\nifeq ($(or $(ZARCH_CC_SUPPORTS_ARCH12), $(ZARCH_CC_SUPPORTS_Z14)), 1)\nDYNAMIC_CORE += Z14\nCCOMMON_OPT += -DDYN_Z14\nelse\n$(info OpenBLAS: Not building Z14 kernels because the compiler $(CC) does not support it)\nendif\n\nendif # ARCH zarch\n\nifeq ($(ARCH), power)\nifneq ($(C_COMPILER), PGI)\nDYNAMIC_CORE = POWER6\nDYNAMIC_CORE += POWER8\nifneq ($(C_COMPILER), GCC)\nDYNAMIC_CORE += POWER9\nDYNAMIC_CORE += POWER10\nCCOMMON_OPT += -DHAVE_P10_SUPPORT\nendif\nifeq ($(C_COMPILER), GCC)\nifeq ($(GCCVERSIONGT5), 1)\nDYNAMIC_CORE += POWER9\nelse\n$(info, OpenBLAS: Your gcc version is too old to build the POWER9 kernels.)\nendif\nifeq ($(OSNAME), AIX)\nLDVERSIONGTEQ35 := 1\nelse\nLDVERSIONGTEQ35 := $(shell expr `$(CC) -Wl,--version 2> /dev/null | head -1 | cut -f2 -d \".\" | cut -f1 -d \"-\"` \\>= 35)\nendif\nifeq ($(GCCVERSIONGTEQ11)$(LDVERSIONGTEQ35), 11)\nDYNAMIC_CORE += POWER10\nCCOMMON_OPT += -DHAVE_P10_SUPPORT\nelse ifeq ($(GCCVERSIONGTEQ10), 1)\nifeq ($(GCCMINORVERSIONGTEQ2)$(LDVERSIONGTEQ35), 11)\nDYNAMIC_CORE += POWER10\nCCOMMON_OPT += -DHAVE_P10_SUPPORT\nendif\nelse\n$(info, OpenBLAS: Your gcc version is too old to build the POWER10 kernels.)\nendif\nendif\nelse\nDYNAMIC_CORE = POWER8\nDYNAMIC_CORE += POWER9\nendif\nendif\n\n# If DYNAMIC_CORE is not set, DYNAMIC_ARCH cannot do anything, so force it to empty\nifndef DYNAMIC_CORE\noverride DYNAMIC_ARCH=\nendif\nendif\n\nifeq ($(ARCH), ia64)\nNO_BINARY_MODE\t= 1\nBINARY_DEFINED\t= 1\n\nifeq ($(F_COMPILER), GFORTRAN)\nifeq ($(C_COMPILER), GCC)\nEXPRECISION\t= 1\nCCOMMON_OPT\t+= -DEXPRECISION\nendif\nendif\nendif\n\nifeq ($(ARCH), $(filter $(ARCH),mips64 mips))\nNO_BINARY_MODE\t= 1\nendif\n\nifeq ($(ARCH), alpha)\nNO_BINARY_MODE\t= 1\nBINARY_DEFINED\t= 1\nendif\n\nifeq ($(ARCH), arm)\nNO_BINARY_MODE  = 1\nBINARY_DEFINED  = 1\n\nifneq ($(EMBEDDED), 1)\nCCOMMON_OPT += -marm\nFCOMMON_OPT += -marm\nelse\nCCOMMON_OPT += -DOS_EMBEDDED -mthumb -mcpu=cortex-m4 -mfloat-abi=hard -mfpu=fpv4-sp-d16\nendif\n\n# If softfp abi is mentioned on the command line, force it.\nifeq ($(ARM_SOFTFP_ABI), 1)\nCCOMMON_OPT += -mfloat-abi=softfp\nFCOMMON_OPT += -mfloat-abi=softfp\nendif\n\nifeq ($(OSNAME), Android)\nifeq ($(ARM_SOFTFP_ABI), 1)\nEXTRALIB\t+= -lm\nelse\nEXTRALIB\t+= -Wl,-lm_hard\nendif\nendif\nendif\n\nifeq ($(ARCH), arm64)\nNO_BINARY_MODE  = 1\nBINARY_DEFINED  = 1\nifdef INTERFACE64\nifneq ($(INTERFACE64), 0)\nifeq ($(F_COMPILER), GFORTRAN)\nFCOMMON_OPT +=  -fdefault-integer-8\nendif\nifeq ($(F_COMPILER), FLANG)\nFCOMMON_OPT += -i8\nendif\nendif\nendif\nendif\n\nifeq ($(ARCH), riscv64)\nNO_BINARY_MODE  = 1\nBINARY_DEFINED  = 1\nifdef INTERFACE64\nifneq ($(INTERFACE64), 0)\nifeq ($(F_COMPILER), GFORTRAN)\nFCOMMON_OPT +=  -fdefault-integer-8\nendif\nifeq ($(F_COMPILER), FLANG)\nFCOMMON_OPT += -i8\nendif\nendif\nendif\nendif\n\nifeq ($(ARCH), loongarch64)\nNO_BINARY_MODE  = 1\nBINARY_DEFINED  = 1\nifdef INTERFACE64\nifneq ($(INTERFACE64), 0)\nifeq ($(F_COMPILER), GFORTRAN)\nFCOMMON_OPT +=  -fdefault-integer-8\nendif\nifeq ($(F_COMPILER), FLANG)\nFCOMMON_OPT += -i8\nendif\nendif\nendif\nendif\n\nifeq ($(ARCH), csky)\nNO_BINARY_MODE\t= 1\nBINARY_DEFINED\t= 1\nendif\n\n#\n#  C Compiler dependent settings\n#\n\n\n# ifeq logical or. GCC or CLANG or LSB\n# http://stackoverflow.com/questions/7656425/makefile-ifeq-logical-or\nifeq ($(C_COMPILER), $(filter $(C_COMPILER),GCC CLANG LSB))\nCCOMMON_OPT += -Wall\nCOMMON_PROF += -fno-inline\nNO_UNINITIALIZED_WARN =  -Wno-uninitialized\n\nifeq ($(QUIET_MAKE), 1)\nCCOMMON_OPT += $(NO_UNINITIALIZED_WARN) -Wno-unused\nendif\n\nifdef NO_BINARY_MODE\n\nifeq ($(ARCH), $(filter $(ARCH),mips64))\nifdef BINARY64\nCCOMMON_OPT += -mabi=64\nelse\nCCOMMON_OPT += -mabi=n32\nendif\nBINARY_DEFINED = 1\nelse ifeq ($(ARCH), $(filter $(ARCH),mips))\nCCOMMON_OPT += -mabi=32\nBINARY_DEFINED = 1\nendif\n\nifneq (, $(filter $(CORE), MIPS64_GENERIC))\nCCOMMON_OPT += -DNO_MSA\nFCOMMON_OPT += -DNO_MSA\nendif\n\nifneq (, $(filter $(CORE),LOONGSON3R3 LOONGSON3R4))\nCCOMMON_OPT += -march=loongson3a\nFCOMMON_OPT += -march=loongson3a\nendif\n\nifeq ($(CORE), MIPS24K)\nCCOMMON_OPT += -mips32r2 -mtune=24kc  $(MSA_FLAGS)\nFCOMMON_OPT += -mips32r2 -mtune=24kc  $(MSA_FLAGS)\nendif\n\nifeq ($(CORE), MIPS1004K)\nCCOMMON_OPT += -mips32r2   $(MSA_FLAGS)\nFCOMMON_OPT += -mips32r2   $(MSA_FLAGS)\nendif\n\nifeq ($(CORE), P5600)\nCCOMMON_OPT += -mips32r5 -mnan=2008 -mtune=p5600  $(MSA_FLAGS)\nFCOMMON_OPT += -mips32r5 -mnan=2008 -mtune=p5600  $(MSA_FLAGS)\nendif\n\nifeq ($(CORE), I6400)\nCCOMMON_OPT += -mips64r6 -mnan=2008 -mtune=i6400 $(MSA_FLAGS)\nFCOMMON_OPT += -mips64r6 -mnan=2008 -mtune=i6400 $(MSA_FLAGS)\nendif\n\nifeq ($(CORE), P6600)\nCCOMMON_OPT += -mips64r6 -mnan=2008 -mtune=p6600 $(MSA_FLAGS)\nFCOMMON_OPT += -mips64r6 -mnan=2008 -mtune=p6600 $(MSA_FLAGS)\nendif\n\nifeq ($(CORE), I6500)\nCCOMMON_OPT += -mips64r6 -mnan=2008 -mtune=i6400 $(MSA_FLAGS)\nFCOMMON_OPT += -mips64r6 -mnan=2008 -mtune=i6400 $(MSA_FLAGS)\nendif\n\nifeq ($(OSNAME), AIX)\nBINARY_DEFINED = 1\nendif\n\nifeq ($(ARCH), loongarch64)\nLA64_ABI=$(shell $(CC) -mabi=lp64d -c $(TOPDIR)/cpuid_loongarch64.c -o /dev/null > /dev/null 2> /dev/null && echo lp64d)\nLA64_ARCH=$(shell $(CC) -march=loongarch64 -c $(TOPDIR)/cpuid_loongarch64.c -o /dev/null > /dev/null 2> /dev/null && echo loongarch64)\nifneq ($(LA64_ABI), lp64d)\nLA64_ABI=lp64\nendif\nifneq ($(LA64_ARCH), loongarch64)\nCCOMMON_OPT += -mabi=$(LA64_ABI)\nFCOMMON_OPT += -mabi=$(LA64_ABI)\nelse\nCCOMMON_OPT += -march=loongarch64 -mabi=$(LA64_ABI)\nFCOMMON_OPT += -march=loongarch64 -mabi=$(LA64_ABI)\nendif\nendif\n\nendif\n\nifndef BINARY_DEFINED\nifneq ($(OSNAME), AIX)\nifdef BINARY64\nifneq ($(ARCH), riscv64)\nCCOMMON_OPT += -m64\nendif\nelse\nCCOMMON_OPT += -m32\nendif\nendif\nendif\n\nendif\n\nifeq ($(C_COMPILER), PGI)\nPGCVERSIONGT20 := $(shell expr `$(CC) --version|sed -n \"2p\" |sed -e \"s/[^0-9.]//g\" |cut -d \".\" -f 1` \\> 20)\nPGCVERSIONEQ20 := $(shell expr `$(CC) --version|sed -n \"2p\" |sed -e \"s/[^0-9.]//g\" |cut -d \".\" -f 1` == 20)\nPGCMINORVERSIONGE11 := $(shell expr `$(CC) --version|sed -n \"2p\" |cut -d \"-\" -f 1 |sed -e \"s/[^0-9.]//g\" |cut -c 4-5` \\>= 11)\nPGCVERSIONCHECK := $(PGCVERSIONGT20)$(PGCVERSIONEQ20)$(PGCMINORVERSIONGE11)\nifeq ($(PGCVERSIONCHECK), $(filter $(PGCVERSIONCHECK), 100 101 011))\nNEWPGI := 1\nPGCVERSIONGT21 := $(shell expr `$(CC) --version|sed -n \"2p\" |sed -e \"s/[^0-9.]//g\" |cut -d \".\" -f 1` \\> 21)\nPGCVERSIONEQ21 := $(shell expr `$(CC) --version|sed -n \"2p\" |sed -e \"s/[^0-9.]//g\" |cut -d \".\" -f 1` == 21)\nPGCVERSIONCHECK2 := $(PGCVERSIONGT21)$(PGCVERSIONEQ21)$(PGCMINORVERSIONGE11)\nifeq ($(PGCVERSIONCHECK2), $(filter $(PGCVERSIONCHECK2), 100 101 011))\nNEWPGI2 := 1\nendif\nendif\nifdef BINARY64\nifeq ($(ARCH), x86_64)\nifeq (,$(findstring tp,$(CFLAGS)))\nifneq ($(NEWPGI2),1)\nCCOMMON_OPT += -tp p7-64\nelse\nCCOMMON_OPT += -tp px\nendif\nendif\nifneq ($(NEWPGI),1)\nCCOMMON_OPT +=  -D__MMX__ -Mnollvm\nendif\nelse\nifeq ($(ARCH), power)\nifeq (,$(findstring tp,$(CFLAGS)))\nifeq ($(CORE), POWER8)\nCCOMMON_OPT += -tp pwr8\nendif\nifeq ($(CORE), POWER9)\nCCOMMON_OPT += -tp pwr9\nendif\nendif\nendif\nendif\nelse\nifneq ($(NEWPGI2),1)\nifeq (,$(findstring tp,$(CFLAGS)))\nCCOMMON_OPT += -tp p7\nelse\nCCOMMON_OPT += -tp px\nendif\nendif\nendif\nendif\n\nifeq ($(C_COMPILER), PATHSCALE)\nifdef BINARY64\nCCOMMON_OPT += -m64\nelse\nCCOMMON_OPT += -m32\nendif\nendif\n\n#\n#  Fortran Compiler dependent settings\n#\n\nifeq ($(F_COMPILER), NAG)\nFCOMMON_OPT += -dcfuns -recursive -ieee=full -w=obs -thread_safe\nifdef INTERFACE64\nifneq ($(INTERFACE64), 0)\nFCOMMON_OPT += -i8\nendif\nendif\nifeq ($(USE_OPENMP), 1)\nFCOMMON_OPT += -openmp\nendif\nendif\n\nifeq ($(F_COMPILER), FLANG)\nCCOMMON_OPT += -DF_INTERFACE_FLANG\nFCOMMON_OPT += -Mrecursive -Kieee\nifeq ($(OSNAME), Linux)\nifeq ($(ARCH), x86_64)\nFLANG_VENDOR := $(shell $(FC) --version|head -1 |cut -f 1 -d \" \")\nifeq ($(FLANG_VENDOR), AMD)\nFCOMMON_OPT += -fno-unroll-loops\nendif\nendif\nendif\nifdef BINARY64\nifdef INTERFACE64\nifneq ($(INTERFACE64), 0)\nFCOMMON_OPT += -i8\nendif\nendif\nFCOMMON_OPT += -Wall\nelse\nFCOMMON_OPT += -Wall\nendif\nifeq ($(USE_OPENMP), 1)\nFCOMMON_OPT += -fopenmp\nendif\nendif\n\nifeq ($(F_COMPILER), G77)\nCCOMMON_OPT += -DF_INTERFACE_G77\nFCOMMON_OPT += -Wall\nifndef NO_BINARY_MODE\nifneq ($(OSNAME), AIX)\nifdef BINARY64\nFCOMMON_OPT += -m64\nelse\nFCOMMON_OPT += -m32\nendif\nendif\nendif\nendif\n\nifeq ($(F_COMPILER), G95)\nCCOMMON_OPT += -DF_INTERFACE_G95\nFCOMMON_OPT += -Wall\nifneq ($(OSNAME), AIX)\nifndef NO_BINARY_MODE\nifdef BINARY64\nFCOMMON_OPT += -m64\nelse\nFCOMMON_OPT += -m32\nendif\nendif\nifneq ($(NO_LAPACKE), 1)\nFCOMMON_OPT += -fno-second-underscore\nendif\nendif\nendif\n\nifeq ($(F_COMPILER), $(filter $(F_COMPILER),GFORTRAN FLANGNEW))\nCCOMMON_OPT += -DF_INTERFACE_GFORT\nifeq ($(F_COMPILER), GFORTRAN)\nFCOMMON_OPT += -Wall\n# make single-threaded LAPACK calls thread-safe #1847\nFCOMMON_OPT += -frecursive\n# work around ABI problem with passing single-character arguments\nFCOMMON_OPT += -fno-optimize-sibling-calls\n#Don't include -lgfortran, when NO_LAPACK=1 or lsbcc\nifneq ($(NOFORTRAN), 1)\nifneq ($(NOFORTRAN), 2)\nifneq ($(NO_LAPACK), 1)\nEXTRALIB += -lgfortran\nendif\nendif\nendif\nendif\nifdef NO_BINARY_MODE\nifeq ($(ARCH), $(filter $(ARCH),mips64))\nifdef BINARY64\nFCOMMON_OPT += -mabi=64\nelse\nFCOMMON_OPT += -mabi=n32\nendif\nelse ifeq ($(ARCH), $(filter $(ARCH),mips))\nFCOMMON_OPT += -mabi=32\nendif\nelse\nifdef BINARY64\nifneq ($(OSNAME), AIX)\nifneq ($(ARCH), riscv64)\nFCOMMON_OPT += -m64\nendif\nendif\nifdef INTERFACE64\nifneq ($(INTERFACE64), 0)\nFCOMMON_OPT +=  -fdefault-integer-8\nendif\nendif\nelse\nifneq ($(OSNAME), AIX)\nFCOMMON_OPT += -m32\nendif\nendif\nendif\nifeq ($(USE_OPENMP), 1)\nFCOMMON_OPT += -fopenmp\nendif\nendif\n\nifeq ($(F_COMPILER), INTEL)\nCCOMMON_OPT += -DF_INTERFACE_INTEL\nifdef INTERFACE64\nifneq ($(INTERFACE64), 0)\nFCOMMON_OPT += -i8\nendif\nendif\nFCOMMON_OPT += -recursive -fp-model strict -assume protect-parens\nifeq ($(USE_OPENMP), 1)\nFCOMMON_OPT += -fopenmp\nendif\nendif\n\nifeq ($(F_COMPILER), FUJITSU)\nCCOMMON_OPT += -DF_INTERFACE_FUJITSU\nifeq ($(USE_OPENMP), 1)\nFCOMMON_OPT += -openmp\nendif\nendif\n\nifeq ($(F_COMPILER), IBM)\nCCOMMON_OPT += -DF_INTERFACE_IBM\nFEXTRALIB += -lxlf90\nifeq ($(C_COMPILER), $(filter $(C_COMPILER),GCC CLANG))\nFCOMMON_OPT += -qextname -qzerosize\nendif\n# FCOMMON_OPT\t+= -qarch=440\nifdef BINARY64\nFCOMMON_OPT += -q64\nifdef INTERFACE64\nifneq ($(INTERFACE64), 0)\nFCOMMON_OPT += -qintsize=8\nendif\nendif\nelse\nFCOMMON_OPT += -q32\nendif\nendif\n\nifeq ($(F_COMPILER), PGI)\nCCOMMON_OPT  += -DF_INTERFACE_PGI\nCOMMON_PROF +=  -DPGICOMPILER\nifdef BINARY64\nifdef INTERFACE64\nifneq ($(INTERFACE64), 0)\nFCOMMON_OPT += -i8\nendif\nendif\nifeq ($(ARCH), x86_64)\nifneq ($(NEWPGI2),1)\nFCOMMON_OPT += -tp p7-64\nelse\nFCOMMON_OPT += -tp px\nendif\nelse\nifeq ($(ARCH), power)\nifeq ($(CORE), POWER6)\n$(warning NVIDIA HPC compilers do not support POWER6.)\nendif\nifeq ($(CORE), POWER8)\nFCOMMON_OPT += -tp pwr8\nendif\nifeq ($(CORE), POWER9)\nFCOMMON_OPT += -tp pwr9\nendif\nifeq ($(CORE), POWER10)\n$(warning NVIDIA HPC compilers do not support POWER10.)\nendif\nendif\nendif\nelse\nFCOMMON_OPT += -tp p7\nendif\nFCOMMON_OPT += -Mrecursive -Kieee\nifeq ($(USE_OPENMP), 1)\nFCOMMON_OPT += -mp\nendif\nendif\n\nifeq ($(F_COMPILER), PATHSCALE)\nCCOMMON_OPT  += -DF_INTERFACE_PATHSCALE\nifdef BINARY64\nifdef INTERFACE64\nifneq ($(INTERFACE64), 0)\nFCOMMON_OPT += -i8\nendif\nendif\nendif\n \nifeq ($(USE_OPENMP), 1)\nFCOMMON_OPT += -mp\nendif\nendif\n\nifeq ($(F_COMPILER), OPEN64)\nCCOMMON_OPT  += -DF_INTERFACE_OPEN64\nifdef BINARY64\nifdef INTERFACE64\nifneq ($(INTERFACE64), 0)\nFCOMMON_OPT += -i8\nendif\nendif\nendif\nifeq ($(ARCH), $(filter $(ARCH),mips64 mips))\nifndef BINARY64\nFCOMMON_OPT += -n32\nelse\nFCOMMON_OPT += -n64\nendif\nifeq ($(CORE), LOONGSON3R3)\nFCOMMON_OPT += -loongson3 -static\nendif\nifeq ($(CORE), LOONGSON3R4)\nFCOMMON_OPT += -loongson3 -static\nendif\nelse\nifndef BINARY64\nFCOMMON_OPT += -m32\nelse\nFCOMMON_OPT += -m64\nendif\nendif\nifeq ($(USE_OPENMP), 1)\nFEXTRALIB   += -lstdc++\nFCOMMON_OPT += -mp\nendif\nendif\n\nifeq ($(C_COMPILER), OPEN64)\nifeq ($(ARCH), $(filter $(ARCH),mips64 mips))\nifndef BINARY64\nCCOMMON_OPT += -n32\nelse\nCCOMMON_OPT += -n64\nendif\nifeq ($(CORE), LOONGSON3R3)\nCCOMMON_OPT += -loongson3 -static\nendif\nifeq ($(CORE), LOONGSON3R4)\nCCOMMON_OPT += -loongson3 -static\nendif\nelse\nifndef BINARY64\nCCOMMON_OPT += -m32\nelse\nCCOMMON_OPT += -m64\nendif\nendif\nendif\n\nifeq ($(C_COMPILER), SUN)\nCCOMMON_OPT  += -w\nifeq ($(ARCH), x86)\nCCOMMON_OPT  += -m32\nelse\nifdef BINARY64\nCCOMMON_OPT  += -m64\nelse\nCCOMMON_OPT  += -m32\nendif\nendif\nendif\n\nifeq ($(F_COMPILER), SUN)\nCCOMMON_OPT  += -DF_INTERFACE_SUN\nFCOMMON_OPT  += -ftrap=%none -xrecursive\nifeq ($(ARCH), x86)\nFCOMMON_OPT  += -m32\nelse\nifdef BINARY64\nFCOMMON_OPT  += -m64\nelse\nFCOMMON_OPT  += -m32\nendif\nendif\nifeq ($(USE_OPENMP), 1)\nFCOMMON_OPT += -xopenmp=parallel\nendif\nendif\n\nifeq ($(F_COMPILER), COMPAQ)\nCCOMMON_OPT  += -DF_INTERFACE_COMPAQ\nifeq ($(USE_OPENMP), 1)\nFCOMMON_OPT += -openmp\nendif\nendif\n\nifeq ($(F_COMPILER), CRAY)\nCCOMMON_OPT += -DF_INTERFACE_INTEL\nFCOMMON_OPT += -hnopattern\nifdef INTERFACE64\nifneq ($(INTERFACE64), 0)\nFCOMMON_OPT += -s integer64\nendif\nendif\nifneq ($(USE_OPENMP), 1)\nFCOMMON_OPT += -O noomp\nendif\nendif\n\nifdef BINARY64\nifdef INTERFACE64\nifneq ($(INTERFACE64), 0)\nCCOMMON_OPT\t+=\n#-DUSE64BITINT\nendif\nendif\nendif\n\nifeq ($(NEED_PIC), 1)\nifeq ($(C_COMPILER), IBM)\nCCOMMON_OPT += -qpic=large\nelse\nCCOMMON_OPT += -fPIC\nendif\nifeq ($(F_COMPILER), SUN)\nFCOMMON_OPT  += -pic\nelse ifeq ($(F_COMPILER), NAG)\nFCOMMON_OPT += -PIC\nelse ifeq ($(F_COMPILER), IBM)\nFCOMMON_OPT += -qpic=large\nelse\nFCOMMON_OPT += -fPIC\nendif\nendif\n\nifeq ($(DYNAMIC_ARCH), 1)\nCCOMMON_OPT\t+= -DDYNAMIC_ARCH\nendif\n\nifeq ($(DYNAMIC_OLDER), 1)\nCCOMMON_OPT\t+= -DDYNAMIC_OLDER\nendif\n\nifeq ($(C_LAPACK), 1)\nCCOMMON_OPT\t+= -DC_LAPACK\nendif\n\nifeq ($(NO_LAPACK), 1)\nCCOMMON_OPT\t+= -DNO_LAPACK\n#Disable LAPACK C interface\nNO_LAPACKE = 1\nendif\n\nifeq ($(NO_LAPACKE), 1)\nCCOMMON_OPT\t+= -DNO_LAPACKE\nendif\n\nifeq ($(NO_AVX), 1)\nCCOMMON_OPT\t+= -DNO_AVX\nendif\n\nifeq ($(ARCH), x86)\nCCOMMON_OPT\t+= -DNO_AVX\nendif\n\nifeq ($(NO_AVX2), 1)\nCCOMMON_OPT\t+= -DNO_AVX2\nendif\n\nifeq ($(NO_AVX512), 1)\nCCOMMON_OPT\t+= -DNO_AVX512\nendif\n\nifeq ($(NO_SVE), 1)\nCCOMMON_OPT     += -DNO_SVE\nendif\n\nifdef SMP\nCCOMMON_OPT\t+= -DSMP_SERVER\n\nifeq ($(ARCH), mips64)\nUSE_SIMPLE_THREADED_LEVEL3 = 1\nendif\n\nifeq ($(USE_OPENMP), 1)\n# USE_SIMPLE_THREADED_LEVEL3 = 1\n# NO_AFFINITY = 1\nCCOMMON_OPT\t+= -DUSE_OPENMP\nendif\n\nifeq ($(BIGNUMA), 1)\nCCOMMON_OPT\t+= -DBIGNUMA\nendif\n\nendif\n\nifeq ($(NO_WARMUP), 1)\nCCOMMON_OPT\t+= -DNO_WARMUP\nendif\n\nifeq ($(CONSISTENT_FPCSR), 1)\nCCOMMON_OPT\t+= -DCONSISTENT_FPCSR\nendif\n\n# Only for development\n# CCOMMON_OPT\t += -DPARAMTEST\n# CCOMMON_OPT\t += -DPREFETCHTEST\n# CCOMMON_OPT\t += -DNO_SWITCHING\n# USE_PAPI = 1\n\nifdef USE_PAPI\nCCOMMON_OPT\t += -DUSE_PAPI\nEXTRALIB\t += -lpapi -lperfctr\nendif\n\nifdef BUFFERSIZE\nCCOMMON_OPT\t += -DBUFFERSIZE=$(BUFFERSIZE)\nendif\n\nifdef DYNAMIC_THREADS\nCCOMMON_OPT\t += -DDYNAMIC_THREADS\nendif\n\nCCOMMON_OPT\t+= -DMAX_CPU_NUMBER=$(NUM_THREADS)\n\nCCOMMON_OPT\t+= -DMAX_PARALLEL_NUMBER=$(NUM_PARALLEL)\n\nifdef USE_SIMPLE_THREADED_LEVEL3\nCCOMMON_OPT\t+= -DUSE_SIMPLE_THREADED_LEVEL3\nendif\n\nifeq ($(USE_TLS), 1)\nCCOMMON_OPT += -DUSE_TLS\nendif\n\nifeq ($(BUILD_BFLOAT16), 1)\nCCOMMON_OPT += -DBUILD_BFLOAT16\nendif\nifeq ($(BUILD_SINGLE), 1)\nCCOMMON_OPT += -DBUILD_SINGLE=1\nendif\nifeq ($(BUILD_DOUBLE), 1)\nCCOMMON_OPT += -DBUILD_DOUBLE=1\nendif\nifeq ($(BUILD_COMPLEX), 1)\nCCOMMON_OPT += -DBUILD_COMPLEX=1\nendif\nifeq ($(BUILD_COMPLEX16), 1)\nCCOMMON_OPT += -DBUILD_COMPLEX16=1\nendif\n\nCCOMMON_OPT += -DVERSION=\\\"$(VERSION)\\\"\n\nifndef SYMBOLPREFIX\nSYMBOLPREFIX =\nendif\n\nifndef SYMBOLSUFFIX\nSYMBOLSUFFIX =\nendif\n\nifndef LIBSONAMEBASE\nLIBSONAMEBASE = openblas\nendif\n\nifndef LIBNAMEPREFIX\nLIBNAMEPREFIX =\nendif\n\nSYMPREFIX=$(SYMBOLPREFIX)\nifeq ($(SYMBOLPREFIX),$(LIBNAMEPREFIX))\nSYMPREFIX=\nendif\nSYMSUFFIX=$(SYMBOLSUFFIX)\nifeq ($(SYMBOLSUFFIX),$(LIBNAMESUFFIX))\nSYMSUFFIX=\nendif\nifndef LIBNAMESUFFIX\nLIBNAMEBASE = $(SYMPREFIX)$(LIBSONAMEBASE)$(SYMSUFFIX)\nelse\nLIBNAMEBASE = $(SYMPREFIX)$(LIBSONAMEBASE)$(SYMSUFFIX)$(LIBNAMESUFFIX)\nendif\n\nifeq ($(OSNAME), CYGWIN_NT)\nLIBPREFIX = cyg$(LIBNAMEPREFIX)$(LIBNAMEBASE)\nelse\nLIBPREFIX = lib$(LIBNAMEPREFIX)$(LIBNAMEBASE)\nendif\n\nKERNELDIR\t= $(TOPDIR)/kernel/$(ARCH)\n\ninclude $(TOPDIR)/Makefile.$(ARCH)\n\nifneq ($(C_COMPILER), PGI)\nifneq ($(C_COMPILER), SUN)\nCCOMMON_OPT     += -UASMNAME -UASMFNAME -UNAME -UCNAME -UCHAR_NAME -UCHAR_CNAME\nendif\nendif\nCCOMMON_OPT\t+= -DASMNAME=$(FU)$(*F) -DASMFNAME=$(FU)$(*F)$(BU) -DNAME=$(*F)$(BU) -DCNAME=$(*F) -DCHAR_NAME=\\\"$(*F)$(BU)\\\" -DCHAR_CNAME=\\\"$(*F)\\\"\n\nifeq ($(CORE), PPC440)\nCCOMMON_OPT\t+= -DALLOC_QALLOC\nendif\n\nifeq ($(CORE), PPC440FP2)\nSTATIC_ALLOCATION = 1\nendif\n\nifneq ($(OSNAME), Linux)\nNO_AFFINITY = 1\nendif\n\nifneq ($(ARCH), x86_64)\nifneq ($(ARCH), x86)\nNO_AFFINITY = 1\nendif\nendif\n\nifeq ($(ARCH), POWER)\nifeq ($(DEBUG), 1)\nCCOMMON_OPT := $(filter-out -O%, $(CCOMMON_OPT)) -O0\nFCOMMON_OPT := $(filter-out -O%, $(FCOMMON_OPT)) -O0\nendif\nendif\n\nifdef NO_AFFINITY\nifeq ($(NO_AFFINITY), 0)\noverride undefine NO_AFFINITY\nelse\nCCOMMON_OPT\t+= -DNO_AFFINITY\nendif\nendif\n\nifdef FUNCTION_PROFILE\nCCOMMON_OPT\t+= -DFUNCTION_PROFILE\nendif\n\nifdef SHMEM_ALLOCATION\nifneq ($(SHMEM_ALLOCATION), 0)\nCCOMMON_OPT\t+= -DALLOC_SHM\nendif\nendif\n\nifdef HUGETLB_ALLOCATION\nifneq ($(HUGETLB_ALLOCATION), 0)\nCCOMMON_OPT\t+= -DALLOC_HUGETLB\nendif\nendif\n\nifdef HUGETLBFILE_ALLOCATION\nifneq ($(HUGETLBFILE_ALLOCATION), 0)\nCCOMMON_OPT\t+= -DALLOC_HUGETLBFILE -DHUGETLB_FILE_NAME=$(HUGETLBFILE_ALLOCATION)\nendif\nendif\n\nifdef STATIC_ALLOCATION\nCCOMMON_OPT\t+= -DALLOC_STATIC\nendif\n\nifdef DEVICEDRIVER_ALLOCATION\nCCOMMON_OPT\t+= -DALLOC_DEVICEDRIVER -DDEVICEDRIVER_NAME=\\\"/dev/mapper\\\"\nendif\n\nifdef MIXED_MEMORY_ALLOCATION\nCCOMMON_OPT\t+= -DMIXED_MEMORY_ALLOCATION\nendif\n\nifeq ($(OSNAME), SunOS)\nTAR\t= gtar\nPATCH\t= gpatch\nGREP\t= ggrep\nAWK\t= nawk\nelse\nTAR\t= tar\nPATCH\t= patch\nGREP\t= grep\nAWK\t= awk\nendif\n\nifndef MD5SUM\nMD5SUM\t= md5sum\nendif\n\n\nREVISION = -r$(VERSION)\nMAJOR_VERSION = $(word 1,$(subst ., ,$(VERSION)))\n\nifeq ($(DEBUG), 1)\nCOMMON_OPT += -g\nendif\n\nifeq ($(DEBUG), 1)\nFCOMMON_OPT += -g\nendif\n\nifndef COMMON_OPT\nCOMMON_OPT = -O2\nendif\n\nifndef FCOMMON_OPT\nFCOMMON_OPT = -O2 -frecursive\nendif\n\noverride CFLAGS     += $(COMMON_OPT) $(CCOMMON_OPT) -I$(TOPDIR)\noverride PFLAGS     += $(COMMON_OPT) $(CCOMMON_OPT) -I$(TOPDIR) -DPROFILE $(COMMON_PROF)\noverride FFLAGS     += $(COMMON_OPT) $(FCOMMON_OPT)\noverride FPFLAGS    += $(FCOMMON_OPT) $(COMMON_PROF)\n#MAKEOVERRIDES =\n\nifeq ($(NEED_PIC), 1)\nifeq (,$(findstring PIC,$(FFLAGS)))\nifneq ($(F_COMPILER),IBM)\noverride FFLAGS += -fPIC\nendif\nendif\nendif\n\n#For LAPACK Fortran codes.\n#Disable -fopenmp for LAPACK Fortran codes on Windows.\nifdef OS_WINDOWS\nLAPACK_FFLAGS := $(filter-out -fopenmp -mp -openmp -xopenmp=parallel,$(FFLAGS))\nLAPACK_FPFLAGS := $(filter-out -fopenmp -mp -openmp -xopenmp=parallel,$(FPFLAGS))\nelse\nLAPACK_FFLAGS := $(FFLAGS)\nLAPACK_FPFLAGS := $(FPFLAGS)\nendif\n\nifeq ($(F_COMPILER),NAG)\nLAPACK_FFLAGS := $(filter-out -msse3 -mssse3 -msse4.1 -mavx -mavx2 -mskylake-avx512 ,$(FFLAGS))\noverride FFLAGS := $(filter-out -msse3 -mssse3 -msse4.1 -mavx -mavx2 -mskylake-avx512 ,$(FFLAGS))\nendif\nifeq ($(F_COMPILER),CRAY)\nLAPACK_FFLAGS := $(filter-out -msse3 -mssse3 -msse4.1 -mavx -mavx2 -mskylake-avx512 ,$(FFLAGS))\noverride FFLAGS := $(filter-out -msse3 -mssse3 -msse4.1 -mavx -mavx2 -mskylake-avx512 ,$(FFLAGS))\nendif\nifeq ($(F_COMPILER),FLANGNEW)\nLAPACK_FFLAGS := $(filter-out -m32 -m64 -msse3 -mssse3 -msse4.1 -mavx -mavx2 -mskylake-avx512 -mtune=% -mabi=% ,$(FFLAGS))\noverride FFLAGS := $(filter-out -m32 -m64 -msse3 -mssse3 -msse4.1 -mavx -mavx2 -mskylake-avx512 -mtune=% -mabi=% ,$(FFLAGS))\nendif\n\nLAPACK_CFLAGS = $(CFLAGS)\nLAPACK_CFLAGS += -DHAVE_LAPACK_CONFIG_H\nifdef INTERFACE64\nifneq ($(INTERFACE64), 0)\nLAPACK_CFLAGS +=  -DLAPACK_ILP64\nendif\nendif\n\nifdef OS_WINDOWS\nLAPACK_CFLAGS +=  -DOPENBLAS_OS_WINDOWS\nLAPACK_CFLAGS +=  -DLAPACK_COMPLEX_STRUCTURE\nendif\nifeq ($(C_COMPILER), LSB)\nLAPACK_CFLAGS +=  -DLAPACK_COMPLEX_STRUCTURE\nendif\n\nifndef SUFFIX\nSUFFIX  = o\nendif\n\nifndef PSUFFIX\nPSUFFIX = po\nendif\n\nifndef LIBSUFFIX\nLIBSUFFIX = a\nendif\n\nifneq ($(DYNAMIC_ARCH), 1)\nifndef SMP\nLIBNAME\t\t= $(LIBPREFIX)_$(LIBCORE)$(REVISION).$(LIBSUFFIX)\nLIBNAME_P\t= $(LIBPREFIX)_$(LIBCORE)$(REVISION)_p.$(LIBSUFFIX)\nelse\nLIBNAME\t\t= $(LIBPREFIX)_$(LIBCORE)p$(REVISION).$(LIBSUFFIX)\nLIBNAME_P\t= $(LIBPREFIX)_$(LIBCORE)p$(REVISION)_p.$(LIBSUFFIX)\nendif\nelse\nifndef SMP\nLIBNAME\t\t= $(LIBPREFIX)$(REVISION).$(LIBSUFFIX)\nLIBNAME_P\t= $(LIBPREFIX)$(REVISION)_p.$(LIBSUFFIX)\nelse\nLIBNAME\t\t= $(LIBPREFIX)p$(REVISION).$(LIBSUFFIX)\nLIBNAME_P\t= $(LIBPREFIX)p$(REVISION)_p.$(LIBSUFFIX)\nendif\nendif\n\nifeq ($(FIXED_LIBNAME),1)\n\tLIBNAME = lib$(LIBNAMEPREFIX)$(LIBSONAMEBASE)$(LIBNAMESUFFIX).$(LIBSUFFIX)\n\tLIBNAME_P = lib$(LIBNAMEPREFIX)$(LISOBNAMEBASE)$(LIBNAMESUFFIX)_p.$(LIBSUFFIX)\nendif\n\nLIBDLLNAME   = $(LIBPREFIX).dll\nIMPLIBNAME   = lib$(LIBNAMEBASE).dll.a\nLIBSONAME    = $(LIBNAME:.$(LIBSUFFIX)=.so)\nLIBDYNNAME   = $(LIBNAME:.$(LIBSUFFIX)=.dylib)\nLIBDEFNAME   = $(LIBNAME:.$(LIBSUFFIX)=.def)\nLIBEXPNAME   = $(LIBNAME:.$(LIBSUFFIX)=.exp)\nLIBZIPNAME   = $(LIBNAME:.$(LIBSUFFIX)=.zip)\n\nLIBS\t\t= $(TOPDIR)/$(LIBNAME)\nLIBS_P\t\t= $(TOPDIR)/$(LIBNAME_P)\n\n\nLIB_COMPONENTS = BLAS\nifneq ($(NO_CBLAS), 1)\nLIB_COMPONENTS += CBLAS\nendif\n\nifneq ($(NO_LAPACK), 1)\nLIB_COMPONENTS += LAPACK\nifneq ($(NO_LAPACKE), 1)\nLIB_COMPONENTS += LAPACKE\nendif\nifeq ($(BUILD_RELAPACK), 1)\nLIB_COMPONENTS += ReLAPACK\nendif\nendif\n\nifeq ($(ONLY_CBLAS), 1)\nLIB_COMPONENTS = CBLAS\nendif\n\nexport OSNAME\nexport ARCH\nexport CORE\nexport LIBCORE\nexport __BYTE_ORDER__\nexport ELF_VERSION\nexport PGCPATH\nexport CONFIG\nexport CC\nexport FC\nexport BU\nexport FU\nexport NEED2UNDERSCORES\nexport USE_THREAD\nexport NUM_THREADS\nexport NUM_CORES\nexport SMP\nexport MAKEFILE_RULE\nexport NEED_PIC\nexport BINARY\nexport BINARY32\nexport BINARY64\nexport F_COMPILER\nexport C_COMPILER\nexport USE_OPENMP\nexport CROSS\nexport CROSS_SUFFIX\nexport NOFORTRAN\nexport C_LAPACK\nexport NO_FBLAS\nexport EXTRALIB\nexport CEXTRALIB\nexport FEXTRALIB\nexport HAVE_SSE\nexport HAVE_SSE2\nexport HAVE_SSE3\nexport HAVE_SSSE3\nexport HAVE_SSE4_1\nexport HAVE_SSE4_2\nexport HAVE_SSE4A\nexport HAVE_SSE5\nexport HAVE_AVX\nexport HAVE_AVX2\nexport HAVE_FMA3\nexport HAVE_VFP\nexport HAVE_VFPV3\nexport HAVE_VFPV4\nexport HAVE_NEON\nifndef NO_MSA\n  export HAVE_MSA\n  export MSA_FLAGS\nendif\nexport KERNELDIR\nexport FUNCTION_PROFILE\nexport TARGET_CORE\nexport NO_AVX512\nexport NO_AVX2\nexport BUILD_BFLOAT16\nexport NO_LSX\nexport NO_LASX\n\nexport SBGEMM_UNROLL_M\nexport SBGEMM_UNROLL_N\nexport SGEMM_UNROLL_M\nexport SGEMM_UNROLL_N\nexport DGEMM_UNROLL_M\nexport DGEMM_UNROLL_N\nexport QGEMM_UNROLL_M\nexport QGEMM_UNROLL_N\nexport CGEMM_UNROLL_M\nexport CGEMM_UNROLL_N\nexport ZGEMM_UNROLL_M\nexport ZGEMM_UNROLL_N\nexport XGEMM_UNROLL_M\nexport XGEMM_UNROLL_N\nexport CGEMM3M_UNROLL_M\nexport CGEMM3M_UNROLL_N\nexport ZGEMM3M_UNROLL_M\nexport ZGEMM3M_UNROLL_N\nexport XGEMM3M_UNROLL_M\nexport XGEMM3M_UNROLL_N\n\n\nifdef USE_CUDA\nexport CUDADIR\nexport CUCC\nexport CUFLAGS\nexport CULIB\nendif\n\n.SUFFIXES: .$(PSUFFIX) .$(SUFFIX) .f\n\n.f.$(SUFFIX):\n\t$(FC) $(FFLAGS) -c $<  -o $(@F)\n\n.f.$(PSUFFIX):\n\t$(FC) $(FPFLAGS) -pg -c $<  -o $(@F)\n\n\nifdef BINARY64\nPATHSCALEPATH\t= /opt/pathscale/lib/3.1\nPGIPATH\t\t= /opt/pgi/linux86-64/7.1-5/lib\nelse\nPATHSCALEPATH\t= /opt/pathscale/lib/3.1/32\nPGIPATH\t\t= /opt/pgi/linux86/7.1-5/lib\nendif\n\nACMLPATH\t= /opt/acml/4.3.0\nifneq ($(OSNAME), Darwin)\nMKLPATH         = /opt/intel/mkl/10.2.2.025/lib\nelse\nMKLPATH         = /Library/Frameworks/Intel_MKL.framework/Versions/10.0.1.014/lib\nendif\nATLASPATH\t= /opt/atlas/3.9.17/opteron\nFLAMEPATH\t= $(HOME)/flame/lib\nifneq ($(OSNAME), SunOS)\nSUNPATH\t\t= /opt/sunstudio12.1\nelse\nSUNPATH\t\t= /opt/SUNWspro\nendif\n"
        },
        {
          "name": "Makefile.tail",
          "type": "blob",
          "size": 21.44140625,
          "content": "SBBLASOBJS_P = $(SBBLASOBJS:.$(SUFFIX)=.$(PSUFFIX))\nSBLASOBJS_P = $(SBLASOBJS:.$(SUFFIX)=.$(PSUFFIX))\nDBLASOBJS_P = $(DBLASOBJS:.$(SUFFIX)=.$(PSUFFIX))\nQBLASOBJS_P = $(QBLASOBJS:.$(SUFFIX)=.$(PSUFFIX))\nCBLASOBJS_P = $(CBLASOBJS:.$(SUFFIX)=.$(PSUFFIX))\nZBLASOBJS_P = $(ZBLASOBJS:.$(SUFFIX)=.$(PSUFFIX))\nXBLASOBJS_P = $(XBLASOBJS:.$(SUFFIX)=.$(PSUFFIX))\nSBEXTOBJS_P = $(SBEXTOBJS:.$(SUFFIX)=.$(PSUFFIX))\n\nCOMMONOBJS_P = $(COMMONOBJS:.$(SUFFIX)=.$(PSUFFIX))\n\nHPLOBJS_P   = $(HPLOBJS:.$(SUFFIX)=.$(PSUFFIX))\n\nBLASOBJS    = $(SBEXTOBJS) $(SBBLASOBJS)  $(SBLASOBJS)   $(DBLASOBJS)   $(CBLASOBJS)   $(ZBLASOBJS) $(CBAUXOBJS)\nBLASOBJS_P  = $(SBEXTOBJS_P) $(SBBLASOBJS_P) $(SBLASOBJS_P) $(DBLASOBJS_P) $(CBLASOBJS_P) $(ZBLASOBJS_P) $(CBAUXOBJS_P)\n\nifdef EXPRECISION\nBLASOBJS   += $(QBLASOBJS)   $(XBLASOBJS)\nBLASOBJS_P += $(QBLASOBJS_P) $(XBLASOBJS_P)\nendif\n\nifdef QUAD_PRECISION\nBLASOBJS   += $(QBLASOBJS)   $(XBLASOBJS)\nBLASOBJS_P += $(QBLASOBJS_P) $(XBLASOBJS_P)\nendif\n\n$(SBBLASOBJS) $(SBBLASOBJS_P) : override CFLAGS += -DBFLOAT16 -UDOUBLE  -UCOMPLEX\n$(SBLASOBJS) $(SBLASOBJS_P) : override CFLAGS += -UDOUBLE  -UCOMPLEX\n$(DBLASOBJS) $(DBLASOBJS_P) : override CFLAGS += -DDOUBLE  -UCOMPLEX\n$(QBLASOBJS) $(QBLASOBJS_P) : override CFLAGS += -DXDOUBLE -UCOMPLEX\n$(CBLASOBJS) $(CBLASOBJS_P) : override CFLAGS += -UDOUBLE  -DCOMPLEX\n$(ZBLASOBJS) $(ZBLASOBJS_P) : override CFLAGS += -DDOUBLE  -DCOMPLEX\n$(XBLASOBJS) $(XBLASOBJS_P) : override CFLAGS += -DXDOUBLE -DCOMPLEX\n$(SBEXTOBJS) $(SBEXTOBJS_P) : override CFLAGS += -DBFLOAT16 -UDOUBLE  -UCOMPLEX\n\n$(SBBLASOBJS_P) : override CFLAGS += -DPROFILE $(COMMON_PROF)\n$(SBLASOBJS_P) : override CFLAGS += -DPROFILE $(COMMON_PROF)\n$(DBLASOBJS_P) : override CFLAGS += -DPROFILE $(COMMON_PROF)\n$(QBLASOBJS_P) : override CFLAGS += -DPROFILE $(COMMON_PROF)\n$(CBLASOBJS_P) : override CFLAGS += -DPROFILE $(COMMON_PROF)\n$(ZBLASOBJS_P) : override CFLAGS += -DPROFILE $(COMMON_PROF)\n$(XBLASOBJS_P) : override CFLAGS += -DPROFILE $(COMMON_PROF)\n$(SBEXTOBJS_P) : override CFLAGS += -DPROFILE $(COMMON_PROF)\n\nlibs    :: $(BLASOBJS) $(COMMONOBJS)\n\t$(AR) $(ARFLAGS) -ru $(TOPDIR)/$(LIBNAME) $^\n\nprof    :: $(BLASOBJS_P) $(COMMONOBJS_P)\n\t$(AR) $(ARFLAGS) -ru $(TOPDIR)/$(LIBNAME_P) $^\n\nhpl\t:: $(HPLOBJS) $(COMMONOBJS)\n\t$(AR) $(ARFLAGS) -ru $(TOPDIR)/$(LIBNAME) $^\n\nhpl_p\t:: $(HPLOBJS_P) $(COMMONOBJS_P)\n\t$(AR) $(ARFLAGS) -ru $(TOPDIR)/$(LIBNAME_P) $^\n\nkernel :: $(BLASOBJS)\n\t$(AR) $(ARFLAGS) -ru $(TOPDIR)/$(LIBNAME) $^\n\ncommonlibs :: $(COMMONOBJS)\n\t$(AR) $(ARFLAGS) -ru $(TOPDIR)/$(LIBNAME) $^\n\ncommonprof :: $(COMMONOBJS_P)\n\t$(AR) $(ARFLAGS) -ru $(TOPDIR)/$(LIBNAME_P) $^\n\nquick :\n\t  $(MAKE) -C $(TOPDIR) libs\n\nbms.$(SUFFIX):bm.c $(TOPDIR)/../bench/bmcommon.h\n\t$(CC) $(CFLAGS) -UDOUBLE -UCOMPLEX -c $< -o $(@F)\n\nbmd.$(SUFFIX):bm.c $(TOPDIR)/../bench/bmcommon.h\n\t$(CC) $(CFLAGS) -DDOUBLE -UCOMPLEX -c $< -o $(@F)\n\nbmd-k.$(SUFFIX):bm-k.c $(TOPDIR)/../bench/bmcommon.h\n\t$(CC) $(CFLAGS) -DDOUBLE -UCOMPLEX -c $< -o $(@F)\n\nifdef QUAD_PRECISION\nbmq.$(SUFFIX):bmq.c $(TOPDIR)/../bench/bmcommon.h\n\t$(CC) $(CFLAGS) -DXDOUBLE -UCOMPLEX -c $< -o $(@F)\n\nbmx.$(SUFFIX):bmx.c $(TOPDIR)/../bench/bmcommon.h\n\t$(CC) $(CFLAGS) -DXDOUBLE -DCOMPLEX -c $< -o $(@F)\nelse\nbmq.$(SUFFIX):bm.c $(TOPDIR)/../bench/bmcommon.h\n\t$(CC) $(CFLAGS) -DXDOUBLE -UCOMPLEX -c $< -o $(@F)\n\nbmx.$(SUFFIX):bmz.c $(TOPDIR)/../bench/bmcommon.h\n\t$(CC) $(CFLAGS) -DXDOUBLE -DCOMPLEX -c $< -o $(@F)\nendif\n\nbmc.$(SUFFIX):bmz.c $(TOPDIR)/../bench/bmcommon.h\n\t$(CC) $(CFLAGS) -UDOUBLE -DCOMPLEX -c $< -o $(@F)\n\nbmz.$(SUFFIX):bmz.c $(TOPDIR)/../bench/bmcommon.h\n\t$(CC) $(CFLAGS) -DDOUBLE -DCOMPLEX -c $< -o $(@F)\n\nbmd_nn.$(SUFFIX):bm_special.c $(TOPDIR)/../bench/bmcommon.h\n\t$(CC) $(CFLAGS) -DDOUBLE -UCOMPLEX -DNN -c $< -o $(@F)\n\nbmd_nt.$(SUFFIX):bm_special.c $(TOPDIR)/../bench/bmcommon.h\n\t$(CC) $(CFLAGS) -DDOUBLE -UCOMPLEX -DNT -c $< -o $(@F)\n\nbmd_tn.$(SUFFIX):bm_special.c $(TOPDIR)/../bench/bmcommon.h\n\t$(CC) $(CFLAGS) -DDOUBLE -UCOMPLEX -DTN -c $< -o $(@F)\n\nbmd_tt.$(SUFFIX):bm_special.c $(TOPDIR)/../bench/bmcommon.h\n\t$(CC) $(CFLAGS) -DDOUBLE -UCOMPLEX -DTT -c $< -o $(@F)\n\nbm-phy.$(SUFFIX):bm-phy.c $(TOPDIR)/../bench/bmcommon.h\n\t$(CC) $(CFLAGS) -DDOUBLE -UCOMPLEX -c $< -o $(@F)\n\nbms.$(PSUFFIX):bm.c $(TOPDIR)/../bench/bmcommon.h\n\t$(CC) $(PFLAGS) -UDOUBLE -UCOMPLEX -c $< -o $(@F)\n\nbmd.$(PSUFFIX):bm.c $(TOPDIR)/../bench/bmcommon.h\n\t$(CC) $(PFLAGS) -DDOUBLE -UCOMPLEX -c $< -o $(@F)\n\nifdef QUAD_PRECISION\nbmq.$(PSUFFIX):bmq.c $(TOPDIR)/../bench/bmcommon.h\n\t$(CC) $(PFLAGS) -DXDOUBLE -UCOMPLEX -c $< -o $(@F)\n\nbmx.$(PSUFFIX):bmx.c $(TOPDIR)/../bench/bmcommon.h\n\t$(CC) $(PFLAGS) -DXDOUBLE -DCOMPLEX -c $< -o $(@F)\nelse\nbmq.$(PSUFFIX):bm.c $(TOPDIR)/../bench/bmcommon.h\n\t$(CC) $(PFLAGS) -DXDOUBLE -UCOMPLEX -c $< -o $(@F)\n\nbmx.$(PSUFFIX):bmz.c $(TOPDIR)/../bench/bmcommon.h\n\t$(CC) $(PFLAGS) -DXDOUBLE -DCOMPLEX -c $< -o $(@F)\nendif\n\nbmc.$(PSUFFIX):bmz.c $(TOPDIR)/../bench/bmcommon.h\n\t$(CC) $(PFLAGS) -UDOUBLE -DCOMPLEX -c $< -o $(@F)\n\nbmz.$(PSUFFIX):bmz.c $(TOPDIR)/../bench/bmcommon.h\n\t$(CC) $(PFLAGS) -DDOUBLE -DCOMPLEX -c $< -o $(@F)\n\nbms : bms.$(SUFFIX) $(SBLASOBJS) $(COMMONOBJS) $(SOBJS) $(OBJS) $(LIBS)\n\t$(CC) -o $(@F) $(CFLAGS) $^ $(EXTRALIB) $(CEXTRALIB)\n\nbmd : bmd.$(SUFFIX) $(DBLASOBJS) $(COMMONOBJS) $(DOBJS) $(OBJS) $(LIBS)\n\t$(CC) -o $(@F) $(CFLAGS) $^ $(EXTRALIB) $(CEXTRALIB) -lm\n\nbmd-k : bmd-k.$(SUFFIX) $(DBLASOBJS) $(COMMONOBJS) $(DOBJS) $(OBJS) $(LIBS)\n\t$(CC) -o $(@F) $(CFLAGS) $^ $(EXTRALIB) $(CEXTRALIB) -lm\n\nbmq : bmq.$(SUFFIX) $(QBLASOBJS) $(COMMONOBJS) $(QOBJS) $(OBJS) $(LIBS)\n\t$(CC) -o $(@F) $(CFLAGS) $^ $(EXTRALIB) $(CEXTRALIB)\n\nbmc : bmc.$(SUFFIX) $(CBLASOBJS) $(COMMONOBJS) $(COBJS) $(OBJS) $(LIBS)\n\t$(CC) -o $(@F) $(CFLAGS) $^ $(EXTRALIB) $(CEXTRALIB) $(FEXTRALIB)\n\nbmz : bmz.$(SUFFIX) $(ZBLASOBJS) $(COMMONOBJS) $(ZOBJS) $(OBJS) $(LIBS)\n\t$(CC) -o $(@F) $(CFLAGS) $^ $(EXTRALIB) $(CEXTRALIB)\n\nbmx : bmx.$(SUFFIX) $(XBLASOBJS) $(COMMONOBJS) $(XOBJS) $(OBJS) $(LIBS)\n\t$(CC) -o $(@F) $(CFLAGS) $^ $(EXTRALIB) $(CEXTRALIB)\n\nbmd_nn : bmd_nn.$(SUFFIX) $(DBLASOBJS) $(COMMONOBJS) $(DOBJS) $(OBJS) $(LIBS)\n\t$(CC) -o $(@F) $(CFLAGS) $^ $(EXTRALIB) $(CEXTRALIB)\n\nbmd_nt : bmd_nt.$(SUFFIX) $(DBLASOBJS) $(COMMONOBJS) $(DOBJS) $(OBJS) $(LIBS)\n\t$(CC) -o $(@F) $(CFLAGS) $^ $(EXTRALIB) $(CEXTRALIB)\n\nbmd_tn : bmd_tn.$(SUFFIX) $(DBLASOBJS) $(COMMONOBJS) $(DOBJS) $(OBJS) $(LIBS)\n\t$(CC) -o $(@F) $(CFLAGS) $^ $(EXTRALIB) $(CEXTRALIB)\n\nbmd_tt : bmd_tt.$(SUFFIX) $(DBLASOBJS) $(COMMONOBJS) $(DOBJS) $(OBJS) $(LIBS)\n\t$(CC) -o $(@F) $(CFLAGS) $^ $(EXTRALIB) $(CEXTRALIB)\n\nbm-phy:bm-phy.$(SUFFIX) $(DBLASOBJS) $(COMMONOBJS) $(DOBJS) $(OBJS) $(LIBS)\n\t$(CC) -o $(@F) $(CFLAGS) $^ $(EXTRALIB) $(CEXTRALIB)\n\nbmcc\t: bmcc.$(SUFFIX) $(CBLASOBJS) $(COMMONOBJS) $(COBJS) $(OBJS) $(LIBS)\n\t$(CC) -o $(@F) $(CFLAGS) $^ $(EXTRALIB) $(CEXTRALIB)\n\nbmzc\t: bmzc.$(SUFFIX) $(ZBLASOBJS) $(COMMONOBJS) $(ZOBJS) $(OBJS) $(LIBS)\n\t$(CC) -o $(@F) $(CFLAGS) $^ $(EXTRALIB) $(CEXTRALIB)\n\nbms.prof : bms.$(PSUFFIX) $(SBLASOBJS_P) $(COMMONOBJS_P) $(SOBJS) $(OBJS) $(LIBS_P)\n\t$(CC) -o $(@F) $(PFLAGS) $^ $(EXTRALIB) $(CEXTRALIB)\n\nbmd.prof : bmd.$(PSUFFIX) $(DBLASOBJS_P) $(COMMONOBJS_P) $(DOBJS) $(OBJS) $(LIBS_P)\n\t$(CC) -o $(@F) $(PFLAGS) $^ $(EXTRALIB) $(CEXTRALIB)\n\nbmq.prof : bmq.$(PSUFFIX) $(QBLASOBJS_P) $(COMMONOBJS_P) $(QOBJS) $(OBJS) $(LIBS_P)\n\t$(CC) -o $(@F) $(PFLAGS) $^ $(EXTRALIB) $(CEXTRALIB)\n\nbmc.prof : bmc.$(PSUFFIX) $(CBLASOBJS_P) $(COMMONOBJS) $(COBJS) $(OBJS) $(LIBS_P)\n\t$(CC) -o $(@F) $(PFLAGS) $^ $(EXTRALIB) $(CEXTRALIB)\n\nbmz.prof : bmz.$(PSUFFIX) $(ZBLASOBJS_P) $(COMMONOBJS) $(ZOBJS) $(OBJS) $(LIBS_P)\n\t$(CC) -o $(@F) $(PFLAGS) $^ $(EXTRALIB) $(CEXTRALIB)\n\nbmx.prof : bmz.$(PSUFFIX) $(XBLASOBJS_P) $(COMMONOBJS) $(XOBJS) $(OBJS) $(LIBS_P)\n\t$(CC) -o $(@F) $(PFLAGS) $^ $(EXTRALIB) $(CEXTRALIB)\n\nbms.cxml : bms.$(SUFFIX) $(SOBJS) $(OBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^  $(LIBCXML)\n\nbmd.cxml : bmd.$(SUFFIX) $(DOBJS) $(OBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^  $(LIBCXML)\n\nbmc.cxml : bmc.$(SUFFIX) $(COBJS) $(OBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^  $(LIBCXML)\n\nbmz.cxml : bmz.$(SUFFIX) $(ZOBJS) $(OBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^  $(LIBCXML)\n\nbms.scsl : bms.$(SUFFIX) $(SOBJS) $(OBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^  $(LIBSCSL)\n\nbmd.scsl : bmd.$(SUFFIX) $(DOBJS) $(OBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^  $(LIBSCSL)\n\nbmc.scsl : bmc.$(SUFFIX) $(COBJS) $(OBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^  $(LIBSCSL)\n\nbmz.scsl : bmz.$(SUFFIX) $(ZOBJS) $(OBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^  $(LIBSCSL)\n\nbms.acml : bms.$(SUFFIX) $(SOBJS) $(OBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^  $(LIBACML)\n\nbmd.acml : bmd.$(SUFFIX) $(DOBJS) $(OBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^  $(LIBACML)\n\nbmc.acml : bmc.$(SUFFIX) $(COBJS) $(OBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^  $(LIBACML)\n\nbmz.acml : bmz.$(SUFFIX) $(ZOBJS) $(OBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^  $(LIBACML)\n\nbms.sun : bms.$(SUFFIX) $(SOBJS) $(OBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^  $(LIBSUNPERF) $(EXTRALIB) $(CEXTRALIB)\n\nbmd.sun : bmd.$(SUFFIX) $(DOBJS) $(OBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^  $(LIBSUNPERF) $(EXTRALIB) $(CEXTRALIB)\n\nbmc.sun : bmc.$(SUFFIX) $(COBJS) $(OBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^  $(LIBSUNPERF) $(EXTRALIB) $(CEXTRALIB)\n\nbmz.sun : bmz.$(SUFFIX) $(ZOBJS) $(OBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^  $(LIBSUNPERF) $(EXTRALIB) $(CEXTRALIB)\n\nbms.atlas : bms.$(SUFFIX) $(SOBJS) $(OBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^  $(LIBATLAS)\n\nbmd.atlas : bmd.$(SUFFIX) $(DOBJS) $(OBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^  $(LIBATLAS)\n\nbmc.atlas : bmc.$(SUFFIX) $(COBJS) $(OBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^  $(LIBATLAS)\n\nbmz.atlas : bmz.$(SUFFIX) $(ZOBJS) $(OBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^  $(LIBATLAS)\n\nbms.essl : bms.$(SUFFIX) $(SOBJS) $(OBJS)\n\t$(CC) $(FCOMMON_OPT) -o $(@F) $^  $(LIBESSL)\n\nbmd.essl : bmd.$(SUFFIX) $(DOBJS) $(OBJS)\n\t$(CC) $(CCOMMON_OPT) -o $(@F) $^  $(LIBESSL)\n\nbmc.essl : bmc.$(SUFFIX) $(COBJS) $(OBJS)\n\t$(F77) $(CCOMMON_OPT) -o $(@F) $^  $(LIBESSL)\n\nbmz.essl : bmz.$(SUFFIX) $(ZOBJS) $(OBJS)\n\t$(CC) $(CCOMMON_OPT) -o $(@F) $^  $(LIBESSL)\n\nbms.flame : bms.$(SUFFIX) $(SOBJS) $(OBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^  $(LIBFLAME)\n\nbmd.flame : bmd.$(SUFFIX) $(DOBJS) $(OBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^  $(LIBFLAME)\n\nbmc.flame : bmc.$(SUFFIX) $(COBJS) $(OBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^  $(LIBFLAME)\n\nbmz.flame : bmz.$(SUFFIX) $(ZOBJS) $(OBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^  $(LIBFLAME)\n\nbms.flame.prof : bms.$(SUFFIX) $(SOBJS) $(OBJS_P)\n\t$(F77) -o $(@F) $(PFLAGS) $^  $(LIBFLAME)\n\nbmd.flame.prof : bmd.$(SUFFIX) $(DOBJS) $(OBJS_P)\n\t$(F77) -o $(@F) $(PFLAGS) $^  $(LIBFLAME)\n\nbmc.flame.prof : bmc.$(SUFFIX) $(COBJS) $(OBJS_P)\n\t$(F77) -o $(@F) $(PFLAGS) $^  $(LIBFLAME)\n\nbmz.flame.prof : bmz.$(SUFFIX) $(ZOBJS) $(OBJS_P)\n\t$(F77) -o $(@F) $(PFLAGS) $^  $(LIBFLAME)\n\nbms.mkl : bms.$(SUFFIX) $(SOBJS) $(OBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^  $(LIBMKL) $(EXTRALIB) $(CEXTRALIB)\n\nbmd.mkl : bmd.$(SUFFIX) $(DOBJS) $(OBJS)\n\t$(CC) -static -o $(@F) $(CFLAGS) $^  $(LIBMKL) $(EXTRALIB) $(CEXTRALIB)\n\nbmc.mkl : bmc.$(SUFFIX) $(COBJS) $(OBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^  $(LIBMKL) $(EXTRALIB) $(CEXTRALIB)\n\nbmz.mkl : bmz.$(SUFFIX) $(ZOBJS) $(OBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^  $(LIBMKL) $(EXTRALIB) $(CEXTRALIB)\n\nbmq.mkl : bmq.$(SUFFIX) $(QOBJS) $(OBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^  $(LIBMKL)  $(EXTRALIB) $(CEXTRALIB)\n\nbms.mkl.prof : bms.$(PSUFFIX) $(SOBJS) $(OBJS)\n\t$(CC) -o $(@F) $(PFLAGS) $^  $(LIBMKL)\n\nbmd.mkl.prof : bmd.$(PSUFFIX) $(DOBJS) $(OBJS)\n\t$(CC) -o $(@F) $(PFLAGS) $^  $(LIBMKL)\n\nbmc.mkl.prof : bmc.$(PSUFFIX) $(COBJS) $(OBJS)\n\t$(CC) -o $(@F) $(PFLAGS) $^  $(LIBMKL)\n\nbmz.mkl.prof : bmz.$(PSUFFIX) $(ZOBJS) $(OBJS)\n\t$(CC) -o $(@F) $(PFLAGS) $^  $(LIBMKL)\n\nbms.mlib : bms.$(SUFFIX) $(SOBJS) $(OBJS)\n\t$(F77) -o $(@F) $(CFLAGS) $^  $(LIBMLIB)\n\nbmd.mlib : bmd.$(SUFFIX) $(DOBJS) $(OBJS)\n\t$(F77) -o $(@F) $(CFLAGS) $^  $(LIBMLIB)\n\nbmc.mlib : bmc.$(SUFFIX) $(COBJS) $(OBJS)\n\t$(F77) -o $(@F) $(CFLAGS) $^  $(LIBMLIB)\n\nbmz.mlib : bmz.$(SUFFIX) $(ZOBJS) $(OBJS)\n\t$(F77) -o $(@F) $(CFLAGS) $^  $(LIBMLIB)\n\nbms.veclib : bms.$(SUFFIX) $(SOBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^  $(LIBVECLIB)\n\nbmd.veclib : bmd.$(SUFFIX) $(DOBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^  $(LIBVECLIB)\n\nbmc.veclib : bmc.$(SUFFIX) $(COBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^  $(LIBVECLIB)\n\nbmz.veclib : bmz.$(SUFFIX) $(ZOBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^  $(LIBVECLIB)\n\nbms.fuji : bms.$(SUFFIX) $(SOBJS)\nifndef SMP\n\tfcc -KV9FMADD -SSL2 -o $(@F) $^\nelse\n\tfcc -KV9FMADD -SSL2BLAMP -o $(@F) $^\nendif\n\nbmd.fuji : bmd.$(SUFFIX) $(DOBJS)\nifndef SMP\n\tfcc -KV9FMADD -SSL2 -o $(@F) $^\nelse\n\tfcc -KV9FMADD -SSL2BLAMP -o $(@F) $^\nendif\n\nbmc.fuji : bmc.$(SUFFIX) $(COBJS)\nifndef SMP\n\tfcc -KV9FMADD -SSL2 -o $(@F) $^\nelse\n\tfcc -KV9FMADD -SSL2BLAMP -o $(@F) $^\nendif\n\nbmz.fuji : bmz.$(SUFFIX) $(ZOBJS)\nifndef SMP\n\tfcc -KV9FMADD -SSL2 -o $(@F) $^\nelse\n\tfcc -KV9FMADD -SSL2BLAMP -o $(@F) $^\nendif\n\nbench: bench.$(SUFFIX)  $(BLASOBJS) $(COMMONOBJS) $(OBJS) $(LIBS)\n\t$(CC) -o $(@F) $(CFLAGS) $^  $(EXTRALIB) $(CEXTRALIB)\n\nbench.$(SUFFIX): bench.c\n\t$(CC) -c -o $(@F) $(CFLAGS) $^\n\nbench_old: bench_old.$(SUFFIX) $(DBLASOBJS) $(COMMONOBJS) $(OBJS) $(LIBS)\n\t$(CC) -o $(@F) $(CFLAGS) $^  $(EXTRALIB) $(CEXTRALIB)\n\nkbench: kbench.$(SUFFIX) $(DBLASOBJS) $(COMMONOBJS) $(OBJS) $(LIBS)\n\t$(CC) -o $(@F) $(CFLAGS) $^  $(EXTRALIB) $(CEXTRALIB)\n\nprebench: prebench.$(SUFFIX) $(DBLASOBJS) $(COMMONOBJS) $(OBJS) $(LIBS)\n\t$(CC) -o $(@F) $(CFLAGS) $^  $(EXTRALIB) $(CEXTRALIB)\n\nkbench_rank_k: kbench_rank_k.$(SUFFIX) $(DBLASOBJS) $(COMMONOBJS) $(OBJS) $(LIBS)\n\t$(CC) -o $(@F) $(CFLAGS) $^  $(EXTRALIB) $(CEXTRALIB)\n\nsmallbench: smallbench.$(SUFFIX)  $(BLASOBJS) $(COMMONOBJS) $(OBJS) $(LIBS)\n\t$(CC) -o $(@F) $(CFLAGS) $^  $(EXTRALIB) $(CEXTRALIB)\n\nsmallbench.mkl: smallbench.$(SUFFIX)\n\t$(CC) -o $(@F) $(CFLAGS) $^  $(LIBMKL) $(EXTRALIB) $(CEXTRALIB)\n\nbench.sun: bench.$(SUFFIX) $(OBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^  $(LIBSUNPERF) $(EXTRALIB) $(CEXTRALIB)\n\nbench.cxml: bench.$(SUFFIX) $(OBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^  $(LIBCXML)\n\nbench.atlas: bench.$(SUFFIX) $(OBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^  $(LIBATLAS)\n\nbench.essl: bench.$(SUFFIX) $(OBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^  $(LIBESSL) ../../level1/others/libmisc.$(LIBSUFFIX)\n\nbench.scsl: bench.$(SUFFIX) $(OBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^  $(LIBSCSL)  $(EXTRALIB) $(CEXTRALIB)\n\nbench.acml: bench.$(SUFFIX) $(OBJS)\n\t$(CC) -static -o $(@F) $(CFLAGS) $^  $(LIBACML)  $(EXTRALIB) $(CEXTRALIB)\n\nbench.flame: bench.$(SUFFIX) $(OBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^  $(LIBFLAME)  $(EXTRALIB) $(CEXTRALIB)\n\nkbench.mkl: kbench.$(SUFFIX) $(OBJS)\n\t$(CC) -static -o $(@F) $(CFLAGS) $^  $(LIBMKL) $(EXTRALIB) $(CEXTRALIB)\n\nbench.mkl: bench.$(SUFFIX) $(OBJS)\n\t$(CC) -static -o $(@F) $(CFLAGS) $^  $(LIBMKL) $(EXTRALIB) $(CEXTRALIB)\n\nbench_old.mkl: bench_old.$(SUFFIX) $(OBJS)\n\t$(CC) -static -o $(@F) $(CFLAGS) $^  $(LIBMKL) $(EXTRALIB) $(CEXTRALIB)\n\nbench.mlib: bench.$(SUFFIX) $(OBJS)\n\t$(F77) -o $(@F) $(CFLAGS) $^  $(LIBMLIB)\n\nbench.veclib: bench.$(SUFFIX) $(OBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^  $(LIBVECLIB)\n\nparams : params.$(SUFFIX) $(SBLASOBJS) $(COMMONOBJS) $(SOBJS) $(OBJS) $(LIBS)\n\t$(CC) -o $(@F) $(CFLAGS) $^ $(EXTRALIB) $(CEXTRALIB)\n\nparamd : paramd.$(SUFFIX) $(DBLASOBJS) $(COMMONOBJS) $(DOBJS) $(OBJS) $(LIBS)\n\t$(CC) -o $(@F) $(CFLAGS) $^ $(EXTRALIB) $(CEXTRALIB)\n\nparamq : paramq.$(SUFFIX) $(QBLASOBJS) $(COMMONOBJS) $(QOBJS) $(OBJS) $(LIBS)\n\t$(CC) -o $(@F) $(CFLAGS) $^ $(EXTRALIB) $(CEXTRALIB)\n\nparamc : paramc.$(SUFFIX) $(CBLASOBJS) $(COMMONOBJS) $(COBJS) $(OBJS) $(LIBS)\n\t$(CC) -o $(@F) $(CFLAGS) $^ $(EXTRALIB) $(CEXTRALIB)\n\nparamz : paramz.$(SUFFIX) $(ZBLASOBJS) $(COMMONOBJS) $(ZOBJS) $(OBJS) $(LIBS)\n\t$(CC) -o $(@F) $(CFLAGS) $^ $(EXTRALIB) $(CEXTRALIB)\n\nparamx : paramx.$(SUFFIX) $(XBLASOBJS) $(COMMONOBJS) $(XOBJS) $(OBJS) $(LIBS)\n\t$(CC) -o $(@F) $(CFLAGS) $^ $(EXTRALIB) $(CEXTRALIB)\n\nparams-ex : params-ex.$(SUFFIX) $(SBLASOBJS) $(COMMONOBJS) $(SOBJS) $(OBJS) $(LIBS)\n\t$(CC) -o $(@F) $(CFLAGS) $^ $(EXTRALIB) $(CEXTRALIB)\n\nparamd-ex : paramd-ex.$(SUFFIX) $(DBLASOBJS) $(COMMONOBJS) $(DOBJS) $(OBJS) $(LIBS)\n\t$(CC) -o $(@F) $(CFLAGS) $^ $(EXTRALIB) $(CEXTRALIB)\n\nparamq-ex : paramq-ex.$(SUFFIX) $(QBLASOBJS) $(COMMONOBJS) $(QOBJS) $(OBJS) $(LIBS)\n\t$(CC) -o $(@F) $(CFLAGS) $^ $(EXTRALIB) $(CEXTRALIB)\n\nparamc-ex : paramc-ex.$(SUFFIX) $(CBLASOBJS) $(COMMONOBJS) $(COBJS) $(OBJS) $(LIBS)\n\t$(CC) -o $(@F) $(CFLAGS) $^ $(EXTRALIB) $(CEXTRALIB)\n\nparamz-ex : paramz-ex.$(SUFFIX) $(ZBLASOBJS) $(COMMONOBJS) $(ZOBJS) $(OBJS) $(LIBS)\n\t$(CC) -o $(@F) $(CFLAGS) $^ $(EXTRALIB) $(CEXTRALIB)\n\nparamx-ex : paramx-ex.$(SUFFIX) $(XBLASOBJS) $(COMMONOBJS) $(XOBJS) $(OBJS) $(LIBS)\n\t$(CC) -o $(@F) $(CFLAGS) $^ $(EXTRALIB) $(CEXTRALIB)\n\nparams.atlas : params.$(SUFFIX) $(OBJS) $(SOBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^ $(LIBATLAS)\n\nparamd.atlas : paramd.$(SUFFIX) $(OBJS) $(DOBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^ $(LIBATLAS)\n\nparamc.atlas : paramc.$(SUFFIX) $(OBJS) $(COBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^ $(LIBATLAS)\n\nparamz.atlas : paramz.$(SUFFIX) $(OBJS) $(ZOBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^ $(LIBATLAS)\n\nparams.sun : params.$(SUFFIX) $(OBJS) $(SOBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^ $(LIBSUNPERF)\n\nparamd.sun : paramd.$(SUFFIX) $(OBJS) $(DOBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^ $(LIBSUNPERF)\n\nparamc.sun : paramc.$(SUFFIX) $(OBJS) $(COBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^ $(LIBSUNPERF)\n\nparamz.sun : paramz.$(SUFFIX) $(OBJS) $(ZOBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^ $(LIBSUNPERF)\n\nparams.essl : params.$(SUFFIX) $(OBJS) $(SOBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^ $(LIBESSL)\n\nparamd.essl : paramd.$(SUFFIX) $(OBJS) $(DOBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^ $(LIBESSL)\n\nparamc.essl : paramc.$(SUFFIX) $(OBJS) $(COBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^ $(LIBESSL)\n\nparamz.essl : paramz.$(SUFFIX) $(OBJS) $(ZOBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^ $(LIBESSL)\n\nparams.mkl : params.$(SUFFIX) $(OBJS) $(SOBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^ $(LIBMKL)\n\nparamd.mkl : paramd.$(SUFFIX) $(OBJS) $(DOBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^ $(LIBMKL)\n\nparamc.mkl : paramc.$(SUFFIX) $(OBJS) $(COBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^ $(LIBMKL)\n\nparamz.mkl : paramz.$(SUFFIX) $(OBJS) $(ZOBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^ $(LIBMKL)\n\nparams.acml : params.$(SUFFIX) $(OBJS) $(SOBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^ $(LIBACML)\n\nparamd.acml : paramd.$(SUFFIX) $(OBJS) $(DOBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^ $(LIBACML)\n\nparamc.acml : paramc.$(SUFFIX) $(OBJS) $(COBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^ $(LIBACML)\n\nparamz.acml : paramz.$(SUFFIX) $(OBJS) $(ZOBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^ $(LIBACML)\n\nparams.flame : params.$(SUFFIX) $(OBJS) $(SOBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^ $(LIBFLAME) $(EXTRALIB) $(CEXTRALIB)\n\nparamd.flame : paramd.$(SUFFIX) $(OBJS) $(DOBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^ $(LIBFLAME) $(EXTRALIB) $(CEXTRALIB)\n\nparamc.flame : paramc.$(SUFFIX) $(OBJS) $(COBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^ $(LIBFLAME) $(EXTRALIB) $(CEXTRALIB)\n\nparamz.flame : paramz.$(SUFFIX) $(OBJS) $(ZOBJS)\n\t$(CC) -o $(@F) $(CFLAGS) $^ $(LIBFLAME) $(EXTRALIB) $(CEXTRALIB)\n\nparams.$(SUFFIX):param.c $(TOPDIR)/../bench/bmcommon.h\n\t$(CC) $(CFLAGS) -UDOUBLE -UCOMPLEX -c $< -o $(@F)\n\nparamd.$(SUFFIX):param.c $(TOPDIR)/../bench/bmcommon.h\n\t$(CC) $(CFLAGS) -DDOUBLE -UCOMPLEX -c $< -o $(@F)\n\nparamq.$(SUFFIX):param.c $(TOPDIR)/../bench/bmcommon.h\n\t$(CC) $(CFLAGS) -DXDOUBLE -UCOMPLEX -c $< -o $(@F)\n\nparamc.$(SUFFIX):paramz.c $(TOPDIR)/../bench/bmcommon.h\n\t$(CC) $(CFLAGS) -UDOUBLE -DCOMPLEX -c $< -o $(@F)\n\nparamz.$(SUFFIX):paramz.c $(TOPDIR)/../bench/bmcommon.h\n\t$(CC) $(CFLAGS) -DDOUBLE -DCOMPLEX -c $< -o $(@F)\n\nparamx.$(SUFFIX):paramz.c $(TOPDIR)/../bench/bmcommon.h\n\t$(CC) $(CFLAGS) -DXDOUBLE -DCOMPLEX -c $< -o $(@F)\n\nparams-ex.$(SUFFIX):param-ex.c $(TOPDIR)/../bench/bmcommon.h\n\t$(CC) $(CFLAGS) -UDOUBLE -UCOMPLEX -c $< -o $(@F)\n\nparamd-ex.$(SUFFIX):param-ex.c $(TOPDIR)/../bench/bmcommon.h\n\t$(CC) $(CFLAGS) -DDOUBLE -UCOMPLEX -c $< -o $(@F)\n\nparamq-ex.$(SUFFIX):param-ex.c $(TOPDIR)/../bench/bmcommon.h\n\t$(CC) $(CFLAGS) -DXDOUBLE -UCOMPLEX -c $< -o $(@F)\n\nparamc-ex.$(SUFFIX):paramz-ex.c $(TOPDIR)/../bench/bmcommon.h\n\t$(CC) $(CFLAGS) -UDOUBLE -DCOMPLEX -c $< -o $(@F)\n\nparamz-ex.$(SUFFIX):paramz-ex.c $(TOPDIR)/../bench/bmcommon.h\n\t$(CC) $(CFLAGS) -DDOUBLE -DCOMPLEX -c $< -o $(@F)\n\nparamx-ex.$(SUFFIX):paramz-ex.c $(TOPDIR)/../bench/bmcommon.h\n\t$(CC) $(CFLAGS) -DXDOUBLE -DCOMPLEX -c $< -o $(@F)\n\ngen_insn_flash.c :\n\techo '#include <stdio.h>'\t\t\t>  gen_insn_flash.c\n\techo '#include <stdlib.h>'\t\t\t>> gen_insn_flash.c\n\techo '#define ICACHE_SIZE ( 256 << 10)'\t\t>> gen_insn_flash.c\n\techo 'int main(void){'\t\t\t\t>> gen_insn_flash.c\n\techo 'int i;'\t\t\t\t\t>> gen_insn_flash.c\n\techo '#ifdef __alpha'\t\t\t\t>> gen_insn_flash.c\n\techo 'printf(\".set noat;.set noreorder;\\n\");'\t>> gen_insn_flash.c\n\techo 'printf(\".arch ev6;.text;.align 5\\n\");'\t>> gen_insn_flash.c\n\techo 'printf(\".globl insn_flash\\n\");'\t\t>> gen_insn_flash.c\n\techo 'printf(\".ent insn_flash\\n\");'\t\t>> gen_insn_flash.c\n\techo 'printf(\"insn_flash:\\n\");'\t\t\t>> gen_insn_flash.c\n\techo 'for (i = 0; i < ICACHE_SIZE / 4; i++)'\t>> gen_insn_flash.c\n\techo 'printf(\"br 1f\\n 1:\\n\");'\t\t\t>> gen_insn_flash.c\n\techo 'printf(\".align 5;ret;.end insn_flash\\n\");'>> gen_insn_flash.c\n\techo '#else'\t\t\t\t\t>> gen_insn_flash.c\n\techo 'printf(\".text;.align 32\\n\");'\t\t>> gen_insn_flash.c\n\techo 'printf(\".globl insn_flash\\n\");'\t\t>> gen_insn_flash.c\n\techo 'printf(\"insn_flash:\\n\");'\t\t\t>> gen_insn_flash.c\n\techo 'for (i = 0; i < ICACHE_SIZE / 2; i++)'\t>> gen_insn_flash.c\n\techo 'printf(\"jmp 1f\\n 1:\\n\");'\t\t\t>> gen_insn_flash.c\n\techo 'printf(\".align 32;ret\\n\");'\t\t>> gen_insn_flash.c\n\techo '#endif'\t\t\t\t\t>> gen_insn_flash.c\n\techo 'return 0;'\t\t\t\t>> gen_insn_flash.c\n\techo '}'\t\t\t\t\t>> gen_insn_flash.c\n\ninsn_flash.$(SUFFIX) : gen_insn_flash\n\t./gen_insn_flash > temp.s\n\t$(AS) -o $(@F) temp.s\n\trm -f temp.s\n\ndummy :\n\nclean ::\n\t@if test -d $(ARCH); then \\\n\t(cd $(ARCH) && $(MAKE) clean) \\\n\tfi\n\t@find . -name '*.o' | xargs rm -rf\n\t@rm -rf *.a *.s *.po *.obj *.i *.so core core.* gmon.out *.cso \\\n\t*.csx *.is *~ *.exe *.flame *.pdb *.dwf \\\n\tgen_insn_flash.c gen_insn_flash *.stackdump *.dll *.exp *.lib \\\n\t*.pc *.pcl *.def *.i *.prof linktest.c \\\n\tbms bmd bmc bmz bmq bmx \\\n\tparams paramd paramc paramz paramq paramx \\\n\tparams-ex paramd-ex paramc-ex paramz-ex paramq-ex paramx-ex \\\n\tbench tpp kbench kbench2 \\\n\t*.mkl *.sun *.acml *.cxml *.essl *.atlas *.scsl *.mlib *.veclib *.fuji\n"
        },
        {
          "name": "Makefile.x86",
          "type": "blob",
          "size": 2.2724609375,
          "content": "# COMPILER_PREFIX = mingw32-\n\nifneq ($(DYNAMIC_ARCH),1)\nADD_CPUFLAGS = 1\nelse\nifdef TARGET_CORE\nADD_CPUFLAGS = 1\nendif\nendif\n\nifdef ADD_CPUFLAGS\nifdef HAVE_SSE\nCCOMMON_OPT += -msse\nifneq ($(F_COMPILER), NAG)\nFCOMMON_OPT += -msse\nendif\nendif\nendif\n\nifeq ($(OSNAME), Interix)\nARFLAGS\t\t= -m x86\nendif\n\nifndef SMP\nLIBMKL\t\t= -L$(MKLPATH)/32 -Wl,-rpath,$(MKLPATH)/32 -lmkl_intel -lmkl_sequential -lmkl_core -lguide -lpthread -lm\nelse\nLIBMKL\t\t= -L$(MKLPATH)/32 -Wl,-rpath,$(MKLPATH)/32 -lmkl_intel -lmkl_intel_thread -lmkl_core -lguide -lpthread -lm\nendif\n\n# LIBMKL\t\t= -L$(MKLPATH)/32 -lmkl_lapack -lmkl_ia32 -lguide -lpthread -lm\n\nifndef SMP\nLIBATLAS\t= -L$(ATLAS) -lf77blas -latlas -lg2c -lm\nelse\nLIBATLAS\t= -L$(ATLAS) -lptf77blas -latlas -lpthread -lg2c -lm\nendif\n\nifeq ($(COMPILER_F77), g77)\nLIBACML\t\t= -L$(ACMLPATH)/gnu32/lib -Wl,-rpath,$(ACMLPATH)/gnu32/lib -lacml -lg2c\nendif\n\nLIBFLAME\t= -L$(FLAMEPATH) -llapack2flame -lflame-lapack -lflame-base $(LIBS)\n\nifeq ($(F_COMPILER), GFORTRAN)\nifndef SMP\nLIBACML\t\t= -L$(ACMLPATH)/gfortran32/lib -Wl,-rpath,$(ACMLPATH)/gfortran32/lib -lacml -lgfortran -lm\nelse\nLIBACML\t\t= -L$(ACMLPATH)/gfortran32_mp/lib -Wl,-rpath,$(ACMLPATH)/gfortran32_mp/lib -lacml_mp -lgfortran -lgomp -lm\nendif\nendif\n\nifeq ($(COMPILER_F77), pgf77)\nLIBACML\t\t= -L$(ACMLPATH)/pgi32/lib -lacml -L/opt/pgi/linux86-64/5.2/lib -lpgftnrtl -lnspgc -lpgc\nendif\n\nifeq ($(F_COMPILER), PATHSCALE)\nifndef SMP\nLIBACML\t\t= -L$(ACMLPATH)/pathscale32/lib -Wl,-rpath,$(ACMLPATH)/pathscale32/lib -lacml -Wl,-rpath,$(PATHSCALEPATH) -L$(PATHSCALEPATH) -lpathfortran -lm\nelse\nLIBACML\t\t= -L$(ACMLPATH)/pathscale32_mp/lib -Wl,-rpath,$(ACMLPATH)/pathscale32_mp/lib -lacml_mp -Wl,-rpath,$(PATHSCALEPATH) -L$(PATHSCALEPATH) -lopenmp -lpathfortran -lm\nendif\nendif\n\nLIBSUNPERF\t= -L/opt/SUNWspro/lib/sse2 -Wl,-R,/opt/SUNWspro/lib/sse2 -lsunperf\n\nLIBVECLIB\t= /System/Library/Frameworks/vecLib.framework/Versions/Current/vecLib\n\nifndef SMP\nLIBATLAS\t= -L$(ATLASPATH)/32 -lcblas -lf77blas -latlas -lm\nelse\nLIBATLAS\t= -L$(ATLASPATH)/32 -lptf77blas -lptatlas -lpthread -lm\nendif\nifdef HAVE_SSE2\nCCOMMON_OPT += -msse2\nFCOMMON_OPT += -msse2\nendif\nifdef HAVE_SSE3\nCCOMMON_OPT += -msse3\nFCOMMON_OPT += -msse3\nifdef HAVE_SSSE3\nCCOMMON_OPT += -mssse3\nFCOMMON_OPT += -mssse3\nendif\nifdef HAVE_SSE4_1\nCCOMMON_OPT += -msse4.1\nFCOMMON_OPT += -msse4.1\nendif\nendif\n\n"
        },
        {
          "name": "Makefile.x86_64",
          "type": "blob",
          "size": 8.0048828125,
          "content": "# CCOMMON_OPT\t+= -DFASTCPU\n\nifeq ($(OSNAME), SunOS)\nifdef BINARY64\nifeq ($(F_COMPILER), SUN)\nFCOMMON_OPT += -m64\nendif\nendif\nendif\n\nifeq ($(C_COMPILER), CLANG)\nifeq ($(findstring icx,$(CC)),icx)\nCCOMMON_OPT += -fp-model=consistent\nendif\nendif\n\nifneq ($(DYNAMIC_ARCH),1)\nADD_CPUFLAGS = 1\nelse\nifdef TARGET_CORE\nADD_CPUFLAGS = 1\nendif\nendif\n\nifdef ADD_CPUFLAGS\nifdef HAVE_SSE3\nCCOMMON_OPT += -msse3\nifneq ($(F_COMPILER), NAG)\nFCOMMON_OPT += -msse3\nendif\nendif\nifdef HAVE_SSSE3\nCCOMMON_OPT += -mssse3\nifneq ($(F_COMPILER), NAG)\nFCOMMON_OPT += -mssse3\nendif\nendif\nifdef HAVE_SSE4_1\nCCOMMON_OPT += -msse4.1\nifneq ($(F_COMPILER), NAG)\nFCOMMON_OPT += -msse4.1\nendif\nendif\nifndef OLDGCC\nifdef HAVE_AVX\nCCOMMON_OPT += -mavx\nifneq ($(F_COMPILER), NAG)\nFCOMMON_OPT += -mavx\nendif\nendif\nendif\nifndef NO_AVX2\nifdef HAVE_AVX2\nCCOMMON_OPT += -mavx2\nifneq ($(F_COMPILER), NAG)\nFCOMMON_OPT += -mavx2\nendif\nendif\nendif\n\nifeq ($(CORE), SKYLAKEX)\nifndef NO_AVX512\nCCOMMON_OPT += -march=skylake-avx512\nifneq ($(F_COMPILER), NAG)\nFCOMMON_OPT += -march=skylake-avx512\nendif\nifeq ($(OSNAME), CYGWIN_NT)\nCCOMMON_OPT += -fno-asynchronous-unwind-tables\nFCOMMON_OPT += -fno-asynchronous-unwind-tables\nendif\nifeq ($(OSNAME), WINNT)\nifeq ($(C_COMPILER), GCC)\nCCOMMON_OPT += -fno-asynchronous-unwind-tables\nFCOMMON_OPT += -fno-asynchronous-unwind-tables\nendif\nendif\nendif\nendif\n\nifeq ($(CORE), COOPERLAKE)\nifndef NO_AVX512\nifeq ($(C_COMPILER), GCC)\n # cooperlake support was added in 10.1\n ifeq ($(GCCVERSIONGTEQ10)$(GCCMINORVERSIONGTEQ1), 11)\n  CCOMMON_OPT += -march=cooperlake\n  ifneq ($(F_COMPILER), NAG)\n   FCOMMON_OPT += -march=cooperlake\n  endif\n else  # gcc not support, fallback to avx512\n  CCOMMON_OPT += -march=skylake-avx512\n  ifneq ($(F_COMPILER), NAG)\n   FCOMMON_OPT += -march=skylake-avx512\n  endif\n endif\nelse ifeq ($(C_COMPILER), CLANG)\n # cooperlake support was added in clang 9\n ifeq ($(CLANGVERSIONGTEQ9), 1)\n  CCOMMON_OPT += -march=cooperlake\n  ifneq ($(F_COMPILER), NAG)\n   FCOMMON_OPT += -march=cooperlake\n  endif\n else  # not supported in clang, fallback to avx512\n  CCOMMON_OPT += -march=skylake-avx512\n  ifneq ($(F_COMPILER), NAG)\n   FCOMMON_OPT += -march=skylake-avx512\n  endif\n endif\nendif\nifeq ($(OSNAME), CYGWIN_NT)\nCCOMMON_OPT += -fno-asynchronous-unwind-tables\nFCOMMON_OPT += -fno-asynchronous-unwind-tables\nendif\nifeq ($(OSNAME), WINNT)\nifeq ($(C_COMPILER), GCC)\nCCOMMON_OPT += -fno-asynchronous-unwind-tables\nFCOMMON_OPT += -fno-asynchronous-unwind-tables\nendif\nendif\nendif\nendif\n\nifeq ($(CORE), SAPPHIRERAPIDS)\nifndef NO_AVX512\nifeq ($(C_COMPILER), GCC)\n # sapphire rapids support was added in 11\n ifeq ($(GCCVERSIONGTEQ11), 1)\n  CCOMMON_OPT += -march=sapphirerapids\n  ifneq ($(F_COMPILER), NAG)\n   FCOMMON_OPT += -march=sapphirerapids\n  endif\n else  # gcc not support, fallback to avx512\n  CCOMMON_OPT += -march=skylake-avx512\n  ifneq ($(F_COMPILER), NAG)\n   FCOMMON_OPT += -march=skylake-avx512\n  endif\n endif\nelse ifeq ($(C_COMPILER), CLANG)\n # sapphire rapids support was added in clang 12\n ifeq ($(CLANGVERSIONGTEQ12), 1)\n  CCOMMON_OPT += -march=sapphirerapids\n  ifneq ($(F_COMPILER), NAG)\n   FCOMMON_OPT += -march=sapphirerapids\n  endif\n else  # not supported in clang, fallback to avx512\n  CCOMMON_OPT += -march=skylake-avx512\n  ifneq ($(F_COMPILER), NAG)\n   FCOMMON_OPT += -march=skylake-avx512\n  endif\n endif\nendif\nifeq ($(OSNAME), CYGWIN_NT)\nCCOMMON_OPT += -fno-asynchronous-unwind-tables\nFCOMMON_OPT += -fno-asynchronous-unwind-tables\nendif\nifeq ($(OSNAME), WINNT)\nifeq ($(C_COMPILER), GCC)\nCCOMMON_OPT += -fno-asynchronous-unwind-tables\nFCOMMON_OPT += -fno-asynchronous-unwind-tables\nendif\nendif\nendif\nendif\n\nifeq ($(CORE), ZEN)\nifdef HAVE_AVX512VL\t\nifndef NO_AVX512\nCCOMMON_OPT += -march=skylake-avx512\nifneq ($(F_COMPILER), NAG)\nFCOMMON_OPT += -march=skylake-avx512\nendif\nifeq ($(OSNAME), CYGWIN_NT)\nCCOMMON_OPT += -fno-asynchronous-unwind-tables\nFCOMMON_OPT += -fno-asynchronous-unwind-tables\nendif\nifeq ($(OSNAME), WINNT)\nifeq ($(C_COMPILER), GCC)\nCCOMMON_OPT += -fno-asynchronous-unwind-tables\nFCOMMON_OPT += -fno-asynchronous-unwind-tables\nendif\nendif\nendif\nendif\nendif\n\n\nifdef HAVE_AVX2\nifndef NO_AVX2\nifeq ($(C_COMPILER), GCC)\n# AVX2 support was added in 4.7.0\nGCCVERSIONCHECK := $(GCCVERSIONGT4)$(GCCVERSIONGTEQ4)$(GCCMINORVERSIONGTEQ7)\nifeq ($(GCCVERSIONCHECK), $(filter $(GCCVERSIONCHECK), 011 110 111))\nCCOMMON_OPT += -mavx2\nendif\nelse \nifeq ($(C_COMPILER), CLANG)\nCCOMMON_OPT += -mavx2\nendif\nendif\nifeq ($(NOFORTRAN), $(filter 0,$(NOFORTRAN)))\nifeq ($(F_COMPILER), GFORTRAN)\n# AVX2 support was added in 4.7.0\nGCCVERSIONGTEQ4 := $(shell expr `$(FC) -dumpversion | cut -f1 -d.` \\>= 4)\nGCCVERSIONGTEQ5 := $(shell expr `$(FC) -dumpversion | cut -f1 -d.` \\>= 5)\nGCCMINORVERSIONGTEQ7 := $(shell expr `$(FC) -dumpversion | cut -f2 -d.` \\>= 7)\nGCCVERSIONCHECK := $(GCCVERSIONGTEQ5)$(GCCVERSIONGTEQ4)$(GCCMINORVERSIONGTEQ7)\nifeq ($(GCCVERSIONCHECK), $(filter $(GCCVERSIONCHECK), 011 110 111))\nFCOMMON_OPT += -mavx2\nendif\nelse\nifeq ($(F_COMPILER), FLANG)\nFCOMMON_OPT += -mavx2\nendif\nendif\nendif\nendif\nendif\n\nendif\n\n\nifeq ($(OSNAME), Interix)\nARFLAGS\t\t= -m x64\nendif\n\nifeq ($(OSNAME), Darwin)\nifndef SMP\nLIBMKL\t\t= -L$(MKLPATH)/em64t -Wl,-rpath,$(MKLPATH)/em64t -lmkl_intel_lp64 -lmkl_sequential -lmkl_core -lguide -lpthread -lm\nelse\nLIBMKL\t\t= -L$(MKLPATH)/em64t -Wl,-rpath,$(MKLPATH)/em64t -lmkl_intel_lp64 -lmkl_intel_thread -lmkl_core -lguide -lpthread -lm\nendif\nelse\nifndef SMP\nLIBMKL\t\t= -L$(MKLPATH)/em64t -Wl,-rpath,$(MKLPATH)/em64t -Wl,--start-group -lmkl_intel_lp64 -lmkl_sequential -lmkl_core -Wl,--end-group -lguide -lpthread -lm\nelse\nLIBMKL\t\t= -L$(MKLPATH)/em64t -Wl,-rpath,$(MKLPATH)/em64t -Wl,--start-group -lmkl_intel_lp64 -lmkl_intel_thread -lmkl_core -Wl,--end-group -lguide -lpthread -lm\nendif\nendif\n\n\nifndef SMP\nLIBATLAS\t= -L$(ATLASPATH)64 -llapack -lcblas -lf77blas -latlas -lm\nelse\nLIBATLAS\t= -L$(ATLASPATH)64 -llapack -lptcblas -lptf77blas -latlas -lpthread -lm\nendif\n\nLIBFLAME\t= -L$(FLAMEPATH) -llapack2flame -lflame $(TOPDIR)/$(LIBNAME) -lgfortran -lpthread -lm\n\n\nifeq ($(F_COMPILER), g77)\nLIBACML\t\t= -L$(ACMLPATH)/gnu64/lib -Wl,-rpath,$(ACMLPATH)/gnu64/lib -lacml -lacml_mv -lg2c -lm\nendif\n\nifeq ($(F_COMPILER), GFORTRAN)\nifndef SMP\nLIBACML\t\t= -L$(ACMLPATH)/gfortran64/lib -Wl,-rpath,$(ACMLPATH)/gfortran64/lib -lacml -lacml_mv -lgfortran -lm\nelse\nLIBACML\t\t= -L$(ACMLPATH)/gfortran64_mp/lib -Wl,-rpath,$(ACMLPATH)/gfortran64_mp/lib -lacml_mp -lacml_mv -lgfortran -lgomp -lm\nendif\nendif\n\nifeq ($(F_COMPILER), INTEL)\nifndef SMP\nLIBACML\t\t= -L$(ACMLPATH)/ifort64/lib -Wl,-rpath,$(ACMLPATH)/ifort64/lib -lacml -lacml_mv -lifcoremt_pic -lirc -lm -lpthread -ldl\nelse\nLIBACML\t\t= -L$(ACMLPATH)/ifort64_mp/lib -Wl,-rpath,$(ACMLPATH)/ifort64_mp/lib -lacml_mp -lacml_mv -lifcoremt_pic -liomp5 -lirc -lm -lpthread -ldl\nendif\nendif\n\nifeq ($(F_COMPILER), OPEN64)\nifndef SMP\nLIBACML\t\t= -L$(ACMLPATH)/open64/lib -Wl,-rpath,$(ACMLPATH)/open64/lib -lacml -lacml_mv -lm\nelse\nLIBACML\t\t= -L$(ACMLPATH)/open64_mp/lib -Wl,-rpath,$(ACMLPATH)/open64_mp/lib -lacml_mp -lacml_mv -lm -lpthread\nendif\nendif\n\nifeq ($(F_COMPILER), pgf77)\nifndef SMP\nLIBACML\t\t= -L$(ACMLPATH)/pgi64/lib    -Wl,-rpath,$(ACMLPATH)/pgi64/lib    -lacml -lacml_mv -L$(PGIPATH) -Wl,-rpath,$(PGIPATH) -lpgftnrtl -lnspgc -lpgmp -lpgc\nelse\nLIBACML\t\t= -L$(ACMLPATH)/pgi64_mp/lib -Wl,-rpath,$(ACMLPATH)/pgi64_mp/lib -lacml -lacml_mv -L$(PGIPATH) -Wl,-rpath,$(PGIPATH) -lpgftnrtl -lnspgc -lpgmp -lpgc\nendif\nendif\n\nifeq ($(F_COMPILER), PATHSCALE)\nifndef SMP\nLIBACML\t\t= -L$(ACMLPATH)/pathscale64/lib -Wl,-rpath,$(ACMLPATH)/pathscale64/lib -lacml -lacml_mv -Wl,-rpath,$(PATHSCALEPATH) -L$(PATHSCALEPATH) -lpathfortran -lm\nelse\nLIBACML\t\t= -L$(ACMLPATH)/pathscale64_mp/lib -Wl,-rpath,$(ACMLPATH)/pathscale64_mp/lib -lacml_mp -lacml_mv -Wl,-rpath,$(PATHSCALEPATH) -L$(PATHSCALEPATH) -lopenmp -lpathfortran -lm\nendif\nendif\n\nifeq ($(F_COMPILER), f90)\nLIBACML\t\t= -L$(ACMLPATH)/sun64/lib -Wl,-R,$(ACMLPATH)/sun64/lib -L$(SUNPATH)/lib/amd64 -Wl,-R,$(SUNPATH)/lib/amd64 -lacml -lacml_mv -lfsu\nendif\n\nLIBSUNPERF\t= -L$(SUNPATH)/lib/amd64 -L$(SUNPATH)/rtlibs/amd64 -Wl,-R,$(SUNPATH)/lib/amd64  -Wl,-R,$(SUNPATH)/rtlibs/amd64 -lsunperf -lfui -lfsu -lmtsk\n\nLIBVECLIB\t= /System/Library/Frameworks/vecLib.framework/Versions/Current/vecLib\n"
        },
        {
          "name": "Makefile.zarch",
          "type": "blob",
          "size": 0.3525390625,
          "content": "\nifeq ($(CORE), Z13)\nCCOMMON_OPT += -march=z13 -mzvector\nFCOMMON_OPT += -march=z13 -mzvector\nendif\n\nifeq ($(CORE), Z14)\nCCOMMON_OPT += -march=z14 -mzvector -O3\nFCOMMON_OPT += -march=z14 -mzvector\nendif\n\n# Enable floating-point expression contraction for clang, since it is the\n# default for gcc\nifeq ($(C_COMPILER), CLANG)\nCCOMMON_OPT += -ffp-contract=on\nendif\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 19.2177734375,
          "content": "# OpenBLAS\n\n[![Join the chat at https://gitter.im/xianyi/OpenBLAS](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/xianyi/OpenBLAS?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\nCirrus CI: [![Build Status](https://api.cirrus-ci.com/github/xianyi/OpenBLAS.svg?branch=develop)](https://cirrus-ci.com/github/xianyi/OpenBLAS)\n\n\n\n[![Build Status](https://dev.azure.com/xianyi/OpenBLAS/_apis/build/status/xianyi.OpenBLAS?branchName=develop)](https://dev.azure.com/xianyi/OpenBLAS/_build/latest?definitionId=1&branchName=develop)\n\nOSUOSL POWERCI [![Build Status](https://powerci.osuosl.org/buildStatus/icon?job=OpenBLAS_gh%2Fdevelop)](http://powerci.osuosl.org/job/OpenBLAS_gh/job/develop/)\n\nOSUOSL IBMZ-CI [![Build Status](http://ibmz-ci.osuosl.org/buildStatus/icon?job=OpenBLAS-Z%2Fdevelop)](http://ibmz-ci.osuosl.org/job/OpenBLAS-Z/job/develop/)\n## Introduction\n\nOpenBLAS is an optimized BLAS (Basic Linear Algebra Subprograms) library based on GotoBLAS2 1.13 BSD version.\n\nFor more information about OpenBLAS, please see:\n\n- The documentation at [openmathlib.org/OpenBLAS/docs/](http://www.openmathlib.org/OpenBLAS/docs),\n- The home page at [openmathlib.org/OpenBLAS/](http://www.openmathlib.org/OpenBLAS).\n\nFor a general introduction to the BLAS routines, please refer to the extensive documentation of their reference implementation hosted at netlib:\n<https://www.netlib.org/blas>. On that site you will likewise find documentation for the reference implementation of the higher-level library LAPACK - the **L**inear **A**lgebra **Pack**age that comes included with OpenBLAS. If you are looking for a general primer or refresher on Linear Algebra, the set of six\n20-minute lecture videos by Prof. Gilbert Strang on either MIT OpenCourseWare [here](https://ocw.mit.edu/resources/res-18-010-a-2020-vision-of-linear-algebra-spring-2020/) or YouTube [here](https://www.youtube.com/playlist?list=PLUl4u3cNGP61iQEFiWLE21EJCxwmWvvek) may be helpful.\n\n## Binary Packages\n\nWe provide official binary packages for the following platform:\n\n  * Windows x86/x86_64\n\nYou can download them from [file hosting on sourceforge.net](https://sourceforge.net/projects/openblas/files/) or from the [Releases section of the GitHub project page](https://github.com/OpenMathLib/OpenBLAS/releases).\n\nOpenBLAS is also packaged for many package managers - see [the installation section of the docs](http://www.openmathlib.org/OpenBLAS/docs/install/) for details.\n\n## Installation from Source\n\nObtain the source code from https://github.com/OpenMathLib/OpenBLAS/. Note that the default branch\nis `develop` (a `master` branch is still present, but far out of date).\n\nBuild-time parameters can be chosen in `Makefile.rule`, see there for a short description of each option.\nMost options can also be given directly on the command line as parameters to your `make` or `cmake` invocation.\n\n### Dependencies\n\nBuilding OpenBLAS requires the following to be installed:\n\n* GNU Make or CMake\n* A C compiler, e.g. GCC or Clang \n* A Fortran compiler (optional, for LAPACK)\n\nIn general, using a recent version of the compiler is strongly recommended.\nIf a Fortran compiler is not available, it is possible to compile an older version of the included LAPACK\nthat has been machine-translated to C.\n\n### Normal compile\n\nSimply invoking `make` (or `gmake` on BSD) will detect the CPU automatically.\nTo set a specific target CPU, use `make TARGET=xxx`, e.g. `make TARGET=NEHALEM`.\nThe full target list is in the file `TargetList.txt`, other build optionss are documented in Makefile.rule and\ncan either be set there (typically by removing the comment character from the respective line), or used on the\n`make` command line. \nNote that when you run `make install` after building, you need to repeat all command line options you provided to `make`\nin the build step, as some settings like the supported maximum number of threads are automatically derived from the\nbuild host by default, which might not be what you want.\nFor building with `cmake`, the usual conventions apply, i.e. create a build directory either underneath the toplevel\nOpenBLAS source directory or separate from it, and invoke `cmake` there with the path to the source tree and any \nbuild options you plan to set.\n\nFor more details, see the [Building from source](http://www.openmathlib.org/OpenBLAS/docs/install/#building-from-source)\nsection in the docs.\n\n### Cross compile\n\nSet `CC` and `FC` to point to the cross toolchains, and if you use `make`, also set `HOSTCC` to your host C compiler.\nThe target must be specified explicitly when cross compiling.\n\nExamples:\n\n* On a Linux system, cross-compiling to an older MIPS64 router board:\n  ```sh\n  make BINARY=64 CC=mipsisa64r6el-linux-gnuabi64-gcc FC=mipsisa64r6el-linux-gnuabi64-gfortran HOSTCC=gcc TARGET=P6600\n  ```\n*  or to a Windows x64 host: \n  ```sh\n  make CC=\"i686-w64-mingw32-gcc -Bstatic\" FC=\"i686-w64-mingw32-gfortran -static-libgfortran\" TARGET=HASWELL BINARY=32 CROSS=1 NUM_THREADS=20 CONSISTENT_FPCSR=1 HOSTCC=gcc\n  ```\n\nYou can find instructions for other cases both in the \"Supported Systems\" section below and in\nthe [Building from source docs](http://www.openmathlib.org/OpenBLAS/docs/install).\nThe `.yml` scripts included with the sources (which contain the\nbuild scripts for the \"continuous integration\" (CI) build tests automatically run on every proposed change to the sources) may also provide additional hints.\n\nWhen compiling for a more modern CPU target of the same architecture, e.g. `TARGET=SKYLAKEX` on a `HASWELL` host, option `CROSS=1` can be used to suppress the automatic invocation of the tests at the end of the build.\n\n### Debug version\n\nA debug version can be built using `make DEBUG=1`.\n\n### Compile with MASS support on Power CPU (optional)\n\nThe [IBM MASS](https://www.ibm.com/support/home/product/W511326D80541V01/other_software/mathematical_acceleration_subsystem) library consists of a set of mathematical functions for C, C++, and Fortran applications that are tuned for optimum performance on POWER architectures.\nOpenBLAS with MASS requires a 64-bit, little-endian OS on POWER.\nThe library can be installed as shown:\n\n* On Ubuntu:\n  ```sh\n  wget -q http://public.dhe.ibm.com/software/server/POWER/Linux/xl-compiler/eval/ppc64le/ubuntu/public.gpg -O- | sudo apt-key add -\n  echo \"deb http://public.dhe.ibm.com/software/server/POWER/Linux/xl-compiler/eval/ppc64le/ubuntu/ trusty main\" | sudo tee /etc/apt/sources.list.d/ibm-xl-compiler-eval.list\n  sudo apt-get update\n  sudo apt-get install libxlmass-devel.8.1.5\n  ```\n\n* On RHEL/CentOS:\n  ```sh\n  wget http://public.dhe.ibm.com/software/server/POWER/Linux/xl-compiler/eval/ppc64le/rhel7/repodata/repomd.xml.key\n  sudo rpm --import repomd.xml.key\n  wget http://public.dhe.ibm.com/software/server/POWER/Linux/xl-compiler/eval/ppc64le/rhel7/ibm-xl-compiler-eval.repo\n  sudo cp ibm-xl-compiler-eval.repo /etc/yum.repos.d/\n  sudo yum install libxlmass-devel.8.1.5\n  ```\n\nAfter installing the MASS library, compile OpenBLAS with `USE_MASS=1`.\nFor example, to compile on Power8 with MASS support: `make USE_MASS=1 TARGET=POWER8`.\n\n### Install to a specific directory (optional)\n\nUse `PREFIX=` when invoking `make`, for example\n\n```sh\nmake install PREFIX=your_installation_directory\n```\n(along with all options you added on the `make` command line in the preceding build step)\nThe default installation directory is `/opt/OpenBLAS`.\n\n## Supported CPUs and Operating Systems\n\nPlease read `GotoBLAS_01Readme.txt` for older CPU models already supported by the 2010 GotoBLAS.\n\n### Additional supported CPUs\n\n#### x86/x86-64\n\n- **Intel Xeon 56xx (Westmere)**: Used GotoBLAS2 Nehalem codes.\n- **Intel Sandy Bridge**: Optimized Level-3 and Level-2 BLAS with AVX on x86-64.\n- **Intel Haswell**: Optimized Level-3 and Level-2 BLAS with AVX2 and FMA on x86-64.\n- **Intel Skylake-X**: Optimized Level-3 and Level-2 BLAS with AVX512 and FMA on x86-64.\n- **Intel Cooper Lake**: as Skylake-X with improved BFLOAT16 support.\n- **AMD Bobcat**: Used GotoBLAS2 Barcelona codes.\n- **AMD Bulldozer**: x86-64 ?GEMM FMA4 kernels. (Thanks to Werner Saar)\n- **AMD PILEDRIVER**: Uses Bulldozer codes with some optimizations.\n- **AMD STEAMROLLER**: Uses Bulldozer codes with some optimizations.\n- **AMD ZEN**: Uses Haswell codes with some optimizations for Zen 2/3 (use SkylakeX for Zen4)\n\n#### MIPS32\n\n- **MIPS 1004K**: uses P5600 codes\n- **MIPS 24K**: uses P5600 codes\n\n#### MIPS64\n\n- **ICT Loongson 3A**: Optimized Level-3 BLAS and the part of Level-1,2.\n- **ICT Loongson 3B**: Experimental\n\n#### ARM\n\n- **ARMv6**: Optimized BLAS for vfpv2 and vfpv3-d16 (e.g. BCM2835, Cortex M0+)\n- **ARMv7**: Optimized BLAS for vfpv3-d32 (e.g. Cortex A8, A9 and A15)\n\n#### ARM64\n\n- **ARMv8**: Basic ARMV8 with small caches, optimized Level-3 and Level-2 BLAS\n- **Cortex-A53**: same as ARMV8 (different cpu specifications)\n- **Cortex-A55**: same as ARMV8 (different cpu specifications)\n- **Cortex A57**: Optimized Level-3 and Level-2 functions\n- **Cortex A72**: same as A57 ( different cpu specifications)\n- **Cortex A73**: same as A57 (different cpu specifications)\n- **Cortex A76**: same as A57 (different cpu specifications)\n- **Falkor**: same as A57 (different cpu specifications)\n- **ThunderX**: Optimized some Level-1 functions\n- **ThunderX2T99**: Optimized Level-3 BLAS and parts of Levels 1 and 2\n- **ThunderX3T110**\n- **TSV110**: Optimized some Level-3 helper functions\n- **EMAG 8180**: preliminary support based on A57\n- **Neoverse N1**: (AWS Graviton2) preliminary support\n- **Neoverse V1**: (AWS Graviton3) optimized Level-3 BLAS\n- **Apple Vortex**: preliminary support based on ThunderX2/3\n- **A64FX**:  preliminary support, optimized Level-3 BLAS\n- **ARMV8SVE**: any ARMV8 cpu with SVE extensions \n\n#### PPC/PPC64\n\n- **POWER8**: Optimized BLAS, only for PPC64LE (Little Endian), only with `USE_OPENMP=1`\n- **POWER9**: Optimized Level-3 BLAS (real) and some Level-1,2. PPC64LE with OpenMP only. \n- **POWER10**: Optimized Level-3 BLAS including SBGEMM and some Level-1,2.\n\n- **AIX**: Dynamic architecture with OpenXL and OpenMP.\n  ```sh\n  make CC=ibm-clang_r FC=xlf_r TARGET=POWER7 BINARY=64 USE_OPENMP=1 INTERFACE64=1 DYNAMIC_ARCH=1 USE_THREAD=1\n  ```\n\n#### IBM zEnterprise System\n\n- **Z13**: Optimized Level-3 BLAS and Level-1,2\n- **Z14**: Optimized Level-3 BLAS and (single precision) Level-1,2\n\n#### RISC-V\n\n- **C910V**: Optimized Level-3 BLAS (real) and Level-1,2 by RISC-V Vector extension 0.7.1.\n  ```sh\n  make HOSTCC=gcc TARGET=C910V CC=riscv64-unknown-linux-gnu-gcc FC=riscv64-unknown-linux-gnu-gfortran\n  ```\n  (also known to work on C906 as long as you use only single-precision functions - its instruction set support appears to be incomplete in double precision)\n\n- **x280**: Level-3 BLAS and Level-1,2 are optimized by RISC-V Vector extension 1.0.\n  ```sh\n  make HOSTCC=gcc TARGET=x280 NUM_THREADS=8 CC=riscv64-unknown-linux-gnu-clang FC=riscv64-unknown-linux-gnu-gfortran\n  ```\n\n- **ZVL???B**: Level-3 BLAS and Level-1,2 including vectorised kernels targeting generic RISCV cores with vector support with registers of at least the corresponding width; ZVL128B and ZVL256B are available.\ne.g.:\n  ```sh\n    make TARGET=RISCV64_ZVL256B CFLAGS=\"-DTARGET=RISCV64_ZVL256B\" \\\n    BINARY=64 ARCH=riscv64 CC='clang -target riscv64-unknown-linux-gnu' \\\n    AR=riscv64-unknown-linux-gnu-ar AS=riscv64-unknown-linux-gnu-gcc \\\n    LD=riscv64-unknown-linux-gnu-gcc FC=riscv64-unknown-linux-gnu-gfortran \\\n    HOSTCC=gcc HOSTFC=gfortran -j\n  ```\n\n#### LOONGARCH64\n\n- **LA64_GENERIC**: Optimized Level-3, Level-2 and Level-1 BLAS with scalar instruction\n  ```sh\n  make HOSTCC=gcc TARGET=LA64_GENERIC CC=loongarch64-unknown-linux-gnu-gcc FC=loongarch64-unknown-linux-gnu-gfortran USE_SIMPLE_THREADED_LEVEL3=1\n  ```\n  The old-style TARGET=LOONGSONGENERIC is still supported\n\n- **LA264**: Optimized Level-3, Level-2 and Level-1 BLAS with LSX instruction\n  ```sh\n  make HOSTCC=gcc TARGET=LA264 CC=loongarch64-unknown-linux-gnu-gcc FC=loongarch64-unknown-linux-gnu-gfortran USE_SIMPLE_THREADED_LEVEL3=1\n  ```\n  The old-style TARGET=LOONGSON2K1000 is still supported\n\n- **LA464**: Optimized Level-3, Level-2 and Level-1 BLAS with LASX instruction\n  ```sh\n  make HOSTCC=gcc TARGET=LA464 CC=loongarch64-unknown-linux-gnu-gcc FC=loongarch64-unknown-linux-gnu-gfortran USE_SIMPLE_THREADED_LEVEL3=1\n  ```\n  The old-style TARGET=LOONGSON3R5 is still supported\n\n### Support for multiple targets in a single library\n\nOpenBLAS can be built for multiple targets with runtime detection of the target cpu by specifiying `DYNAMIC_ARCH=1` in Makefile.rule, on the gmake command line or as `-DDYNAMIC_ARCH=TRUE` in cmake.\n\nFor **x86_64**, the list of targets this activates contains Prescott, Core2, Nehalem, Barcelona, Sandybridge, Bulldozer, Piledriver, Steamroller, Excavator, Haswell, Zen, SkylakeX, Cooper Lake, Sapphire Rapids. For cpu generations not included in this list, the corresponding older model is used. If you also specify `DYNAMIC_OLDER=1`, specific support for Penryn, Dunnington, Opteron, Opteron/SSE3, Bobcat, Atom and Nano is added. Finally there is an option `DYNAMIC_LIST` that allows to specify an individual list of targets to include instead of the default.\n\n`DYNAMIC_ARCH` is also supported on **x86**, where it translates to Katmai, Coppermine, Northwood, Prescott, Banias,\nCore2, Penryn, Dunnington, Nehalem, Athlon, Opteron, Opteron_SSE3, Barcelona, Bobcat, Atom and Nano.\n\nOn **ARMV8**, it enables support for CortexA53, CortexA57, CortexA72, CortexA73, Falkor, ThunderX, ThunderX2T99, TSV110 as well as generic ARMV8 cpus. If compiler support for SVE is available at build time, support for NeoverseN2, NeoverseV1 as well as generic ArmV8SVE targets is also enabled.\n\nFor **POWER**, the list encompasses POWER6, POWER8 and POWER9. POWER10 is additionally available if a sufficiently recent compiler is used for the build.\n\non **ZARCH** it comprises Z13 and Z14 as well as generic zarch support.\n\nOn **riscv64**, DYNAMIC_ARCH enables support for riscv64_zvl128b and riscv64_zvl256b in addition to generic riscv64 support.  A compiler that supports RVV 1.0 is required to build OpenBLAS for riscv64 when DYNAMIC_ARCH is enabled.\n\nOn **LoongArch64**, it comprises LA264 and LA464 as well as generic LoongArch64 support.\n\nThe `TARGET` option can - and usually **should** - be used in conjunction with `DYNAMIC_ARCH=1` to specify which cpu model should be assumed for all the common code in the library, usually you will want to set this to the oldest model you expect to encounter.\nFailure to specify this may lead to advanced instructions being used by the compiler, just because the build host happens to support them. This is most likely to happen when aggressive optimization options are in effect, and the resulting library may then crash with an\nillegal instruction error on weaker hardware, before it even reaches the BLAS routines specifically included for that cpu.\n\nPlease note that it is not possible to combine support for different architectures, so no combined 32 and 64 bit or x86_64 and arm64 in the same library.\n\n### Supported OS\n\n- **GNU/Linux**\n- **MinGW or Visual Studio (CMake)/Windows**: Please read <https://github.com/xianyi/OpenBLAS/wiki/How-to-use-OpenBLAS-in-Microsoft-Visual-Studio>.\n- **Darwin/macOS/OSX/iOS**: Experimental. Although GotoBLAS2 already supports Darwin, we are not OSX/iOS experts.\n- **FreeBSD**: Supported by the community. We don't actively test the library on this OS.\n- **OpenBSD**: Supported by the community. We don't actively test the library on this OS.\n- **NetBSD**: Supported by the community. We don't actively test the library on this OS.\n- **DragonFly BSD**: Supported by the community. We don't actively test the library on this OS.\n- **Android**: Supported by the community. Please read <https://github.com/xianyi/OpenBLAS/wiki/How-to-build-OpenBLAS-for-Android>.\n- **AIX**: Supported on PPC up to POWER10\n- **Haiku**: Supported by the community. We don't actively test the library on this OS.\n- **SunOS**: Supported by the community. We don't actively test the library on this OS.\n- **Cortex-M**: Supported by the community. Please read <https://github.com/xianyi/OpenBLAS/wiki/How-to-use-OpenBLAS-on-Cortex-M>.\n\n## Usage\n\nStatically link with `libopenblas.a` or dynamically link with `-lopenblas` if OpenBLAS was\ncompiled as a shared library.\n\n### Setting the number of threads using environment variables\n\nEnvironment variables are used to specify a maximum number of threads.\nFor example,\n\n```sh\nexport OPENBLAS_NUM_THREADS=4\nexport GOTO_NUM_THREADS=4\nexport OMP_NUM_THREADS=4\n```\n\nThe priorities are `OPENBLAS_NUM_THREADS` > `GOTO_NUM_THREADS` > `OMP_NUM_THREADS`.\n\nIf you compile this library with `USE_OPENMP=1`, you should set the `OMP_NUM_THREADS`\nenvironment variable; OpenBLAS ignores `OPENBLAS_NUM_THREADS` and `GOTO_NUM_THREADS` when\ncompiled with `USE_OPENMP=1`.\n\n### Setting the number of threads at runtime\n\nWe provide the following functions to control the number of threads at runtime:\n\n```c\nvoid goto_set_num_threads(int num_threads);\nvoid openblas_set_num_threads(int num_threads);\n```\nNote that these are only used once at library initialization, and are not available for\nfine-tuning thread numbers in individual BLAS calls. \nIf you compile this library with `USE_OPENMP=1`, you should use the above functions too.\n\n## Reporting bugs\n\nPlease submit an issue in https://github.com/OpenMathLib/OpenBLAS/issues.\n\n## Contact\n\n+ Use github discussions: https://github.com/OpenMathLib/OpenBLAS/discussions\n* OpenBLAS users mailing list: https://groups.google.com/forum/#!forum/openblas-users\n* OpenBLAS developers mailing list: https://groups.google.com/forum/#!forum/openblas-dev\n\n## Change log\n\nPlease see Changelog.txt.\n\n## Troubleshooting\n\n* Please read the [FAQ](http://www.openmathlib.org/OpenBLAS/docs/faq) section of the docs first.\n* Please use GCC version 4.6 and above to compile Sandy Bridge AVX kernels on Linux/MinGW/BSD.\n* Please use Clang version 3.1 and above to compile the library on Sandy Bridge microarchitecture.\n  Clang 3.0 will generate the wrong AVX binary code.\n* Please use GCC version 6 or LLVM version 6 and above to compile Skylake/CooperLake AVX512 kernels\n* Please use LLVM version 18 and above (version 19 and above on Windows) if you plan to use\n  its new flang compiler for Fortran\n* Please use GCC version 11 and above to compile OpenBLAS on the POWER architecture\n* The number of CPUs/cores should be less than or equal to 256. On Linux `x86_64` (`amd64`),\n  there is experimental support for up to 1024 CPUs/cores and 128 numa nodes if you build\n  the library with `BIGNUMA=1`.\n* OpenBLAS does not set processor affinity by default.\n  On Linux, you can enable processor affinity by commenting out the line `NO_AFFINITY=1` in\n  Makefile.rule. However, note that this may cause\n  [a conflict with R parallel](https://stat.ethz.ch/pipermail/r-sig-hpc/2012-April/001348.html).\n* On Loongson 3A, `make test` may fail with a `pthread_create` error (`EAGAIN`).\n  However, it will be okay when you run the same test case on the shell.\n\n## Contributing\n\n1. [Check for open issues](https://github.com/OpenMathLib/OpenBLAS/issues) or open a fresh issue\n   to start a discussion around a feature idea or a bug.\n2. Fork the [OpenBLAS](https://github.com/OpenMathLib/OpenBLAS) repository to start making your changes.\n3. Write a test which shows that the bug was fixed or that the feature works as expected.\n4. Send a pull request. Make sure to add yourself to `CONTRIBUTORS.md`.\n\n## Donation\n\nPlease see [the donations section](http://www.openmathlib.org/OpenBLAS/docs/about/#donations) in the docs.\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 0.9365234375,
          "content": "# Security Policy\n\n## Supported Versions\n\nIt is generally recommended to use the latest release as this project\ndoes not maintain multiple stable branches and providing packages e.g.\nfor Linux distributions is outside our scope. In particular, versions\nbefore 0.3.18 can be assumed to carry the out-of-bounds-read error in\nthe LAPACK ?LARRV family of functions that was the subject of \nCVE-2021-4048\n\n## Reporting a Vulnerability\n\nIf you suspect that you have found a vulnerability - a defect that could\nbe abused to compromise the security of a user's code or systems - please\ndo not use the normal github issue tracker (except perhaps to post a general\nwarning if you deem that necessary). Instead, please contact the project \nmaintainers through the email addresses given in their github user profiles.\nDefects found in the \"lapack-netlib\" subtree should ideally be reported to\nthe maintainers of the reference implementation of LAPACK, lapack@icl.itk.edu\n"
        },
        {
          "name": "TargetList.txt",
          "type": "blob",
          "size": 1.6123046875,
          "content": "Force Target Examples:\n\nmake TARGET=NEHALEM\nmake TARGET=LOONGSON3A BINARY=64\nmake TARGET=ISTANBUL\n\nSupported List:\n1.X86/X86_64\na)Intel CPU:\nP2\nKATMAI\nCOPPERMINE\nNORTHWOOD\nPRESCOTT\nBANIAS\nYONAH\nCORE2\nPENRYN\nDUNNINGTON\nNEHALEM\nSANDYBRIDGE\nHASWELL\nSKYLAKEX\nATOM\nCOOPERLAKE\nSAPPHIRERAPIDS\n\nb)AMD CPU:\nATHLON\nOPTERON\nOPTERON_SSE3\nBARCELONA\nSHANGHAI\nISTANBUL\nBOBCAT\nBULLDOZER\nPILEDRIVER\nSTEAMROLLER\nEXCAVATOR\nZEN\n\nc)VIA CPU:\nSSE_GENERIC\nVIAC3\nNANO\n\n2.Power CPU:\nPOWER4\nPOWER5\nPOWER6\nPOWER7\nPOWER8\nPOWER9\nPOWER10\nPPCG4\nPPC970\nPPC970MP\nPPC440\nPPC440FP2\nCELL\n\n3.MIPS CPU:\nP5600\nMIPS1004K\nMIPS24K\n\n4.MIPS64 CPU:\nMIPS64_GENERIC\nSICORTEX\nLOONGSON3A\nLOONGSON3B\nI6400\nP6600\nI6500\n\n5.IA64 CPU:\nITANIUM2\n\n6.SPARC CPU:\nSPARC\nSPARCV7\n\n7.ARM CPU:\nCORTEXA15\nCORTEXA9\nARMV7\nARMV6\nARMV5\n\n8.ARM 64-bit CPU:\nARMV8\nCORTEXA53\nCORTEXA57\nCORTEXA72\nCORTEXA73\nCORTEXA76\nCORTEXA510\nCORTEXA710\nCORTEXX1\nCORTEXX2\nNEOVERSEN1\nNEOVERSEV1\nNEOVERSEN2\nCORTEXA55\nEMAG8180\nFALKOR\nTHUNDERX\nTHUNDERX2T99\nTSV110\nTHUNDERX3T110\nVORTEX\nA64FX\nARMV8SVE\nFT2000\n\n9.System Z:\nZARCH_GENERIC\nZ13\nZ14\n\n10.RISC-V 64:\nRISCV64_GENERIC (e.g. PolarFire Soc/SiFive U54)\nRISCV64_ZVL128B\nC910V\nx280\nRISCV64_ZVL256B\n\n11.LOONGARCH64:\n// LOONGSONGENERIC/LOONGSON2K1000/LOONGSON3R5 are legacy names,\n// and it is recommended to use the more standardized naming conventions\n// LA64_GENERIC/LA264/LA464. You can still specify TARGET as\n// LOONGSONGENERIC/LOONGSON2K1000/LOONGSON3R5 during compilation or runtime,\n// and they will be internally relocated to LA64_GENERIC/LA264/LA464.\nLOONGSONGENERIC\nLOONGSON2K1000\nLOONGSON3R5\nLA64_GENERIC\nLA264\nLA464\n\n12. Elbrus E2000:\nE2K\n\n13. Alpha\nEV4\nEV5\nEV6\n\n14.CSKY\nCSKY\nCK860FV\n"
        },
        {
          "name": "USAGE.md",
          "type": "blob",
          "size": 7.40234375,
          "content": "# Notes on OpenBLAS usage\n## Usage\n\n#### Program is Terminated. Because you tried to allocate too many memory regions\n\nIn OpenBLAS, we mange a pool of memory buffers and allocate the number of\nbuffers as the following.\n```\n#define NUM_BUFFERS (MAX_CPU_NUMBER * 2)\n```\nThis error indicates that the program exceeded the number of buffers.\n\nPlease build OpenBLAS with larger `NUM_THREADS`. For example, `make\nNUM_THREADS=32` or `make NUM_THREADS=64`.  In `Makefile.system`, we will set\n`MAX_CPU_NUMBER=NUM_THREADS`.\n\nDespite its name, and due to the use of memory buffers in functions like SGEMM,\nthe setting of NUM_THREADS can be relevant even for a single-threaded build \nof OpenBLAS, if such functions get called by multiple threads of a program\nthat uses OpenBLAS. In some cases, the affected code may simply crash or throw \na segmentation fault without displaying the above warning first.\n\nNote that the number of threads used at runtime can be altered to differ from the\nvalue NUM_THREADS was set to at build time. At runtime, the actual number of\nthreads can be set anywhere from 1 to the build's NUM_THREADS (note however,\nthat this does not change the number of memory buffers that will be allocated,\nwhich is set at build time). The number of threads for a process can be set by\nusing the mechanisms described below.\n\n\n#### How can I use OpenBLAS in multi-threaded applications?\n\nIf your application is already multi-threaded, it will conflict with OpenBLAS\nmulti-threading. Thus, you must set OpenBLAS to use single thread in any of the\nfollowing ways:\n\n* `export OPENBLAS_NUM_THREADS=1` in the environment variables.\n* Call `openblas_set_num_threads(1)` in the application on runtime.\n* Build OpenBLAS single thread version, e.g. `make USE_THREAD=0`\n\nIf the application is parallelized by OpenMP, please use OpenBLAS built with\n`USE_OPENMP=1`\n\n#### How to choose TARGET manually at runtime when compiled with DYNAMIC_ARCH\n\nThe environment variable which control the kernel selection is\n`OPENBLAS_CORETYPE` (see `driver/others/dynamic.c`) e.g. `export\nOPENBLAS_CORETYPE=Haswell` and the function `char* openblas_get_corename()`\nreturns the used target.\n\n#### How could I disable OpenBLAS threading affinity on runtime?\n\nYou can define the `OPENBLAS_MAIN_FREE` or `GOTOBLAS_MAIN_FREE` environment\nvariable to disable threading affinity on runtime. For example, before the\nrunning,\n```\nexport OPENBLAS_MAIN_FREE=1\n```\n\nAlternatively, you can disable affinity feature with enabling `NO_AFFINITY=1`\nin `Makefile.rule`.\n\n## Linking with the library\n\n* Link with shared library\n\n`gcc -o test test.c -I /your_path/OpenBLAS/include/ -L/your_path/OpenBLAS/lib -lopenblas`\n\nIf the library is multithreaded, please add `-lpthread`. If the library\ncontains LAPACK functions, please add `-lgfortran` or other Fortran libs.\n\n* Link with static library\n\n`gcc -o test test.c /your/path/libopenblas.a`\n\nYou can download `test.c` from https://gist.github.com/xianyi/5780018\n\nOn Linux, if OpenBLAS was compiled with threading support (`USE_THREAD=1` by\ndefault), custom programs statically linked against `libopenblas.a` should also\nlink with the pthread library e.g.:\n\n```\ngcc -static -I/opt/OpenBLAS/include -L/opt/OpenBLAS/lib -o my_program my_program.c -lopenblas -lpthread\n```\n\nFailing to add the `-lpthread` flag will cause errors such as:\n\n```\n/opt/OpenBLAS/libopenblas.a(memory.o): In function `_touch_memory':\nmemory.c:(.text+0x15): undefined reference to `pthread_mutex_lock'\nmemory.c:(.text+0x41): undefined reference to `pthread_mutex_unlock'\n...\n```\n\n## Code examples\n\n#### Call CBLAS interface\nThis example shows calling cblas_dgemm in C. https://gist.github.com/xianyi/6930656\n```\n#include <cblas.h>\n#include <stdio.h>\n\nvoid main()\n{\n  int i=0;\n  double A[6] = {1.0,2.0,1.0,-3.0,4.0,-1.0};\n  double B[6] = {1.0,2.0,1.0,-3.0,4.0,-1.0};\n  double C[9] = {.5,.5,.5,.5,.5,.5,.5,.5,.5};\n  cblas_dgemm(CblasColMajor, CblasNoTrans, CblasTrans,3,3,2,1,A, 3, B, 3,2,C,3);\n\n  for(i=0; i<9; i++)\n    printf(\"%lf \", C[i]);\n  printf(\"\\n\");\n}\n```\n`gcc -o test_cblas_open test_cblas_dgemm.c -I /your_path/OpenBLAS/include/ -L/your_path/OpenBLAS/lib -lopenblas -lpthread -lgfortran`\n\n#### Call BLAS Fortran interface\n\nThis example shows calling dgemm Fortran interface in C. https://gist.github.com/xianyi/5780018\n\n```\n#include \"stdio.h\"\n#include \"stdlib.h\"\n#include \"sys/time.h\"\n#include \"time.h\"\n\nextern void dgemm_(char*, char*, int*, int*,int*, double*, double*, int*, double*, int*, double*, double*, int*);\n\nint main(int argc, char* argv[])\n{\n  int i;\n  printf(\"test!\\n\");\n  if(argc<4){\n    printf(\"Input Error\\n\");\n    return 1;\n  }\n\n  int m = atoi(argv[1]);\n  int n = atoi(argv[2]);\n  int k = atoi(argv[3]);\n  int sizeofa = m * k;\n  int sizeofb = k * n;\n  int sizeofc = m * n;\n  char ta = 'N';\n  char tb = 'N';\n  double alpha = 1.2;\n  double beta = 0.001;\n\n  struct timeval start,finish;\n  double duration;\n\n  double* A = (double*)malloc(sizeof(double) * sizeofa);\n  double* B = (double*)malloc(sizeof(double) * sizeofb);\n  double* C = (double*)malloc(sizeof(double) * sizeofc);\n\n  srand((unsigned)time(NULL));\n\n  for (i=0; i<sizeofa; i++)\n    A[i] = i%3+1;//(rand()%100)/10.0;\n\n  for (i=0; i<sizeofb; i++)\n    B[i] = i%3+1;//(rand()%100)/10.0;\n\n  for (i=0; i<sizeofc; i++)\n    C[i] = i%3+1;//(rand()%100)/10.0;\n  //#if 0\n  printf(\"m=%d,n=%d,k=%d,alpha=%lf,beta=%lf,sizeofc=%d\\n\",m,n,k,alpha,beta,sizeofc);\n  gettimeofday(&start, NULL);\n  dgemm_(&ta, &tb, &m, &n, &k, &alpha, A, &m, B, &k, &beta, C, &m);\n  gettimeofday(&finish, NULL);\n\n  duration = ((double)(finish.tv_sec-start.tv_sec)*1000000 + (double)(finish.tv_usec-start.tv_usec)) / 1000000;\n  double gflops = 2.0 * m *n*k;\n  gflops = gflops/duration*1.0e-6;\n\n  FILE *fp;\n  fp = fopen(\"timeDGEMM.txt\", \"a\");\n  fprintf(fp, \"%dx%dx%d\\t%lf s\\t%lf MFLOPS\\n\", m, n, k, duration, gflops);\n  fclose(fp);\n\n  free(A);\n  free(B);\n  free(C);\n  return 0;\n}\n```\n\n` gcc -o time_dgemm time_dgemm.c /your/path/libopenblas.a`\n\n` ./time_dgemm <m> <n> <k> `\n\n## Troubleshooting\n* Please read [Faq](https://github.com/xianyi/OpenBLAS/wiki/Faq) at first.\n* Please use gcc version 4.6 and above to compile Sandy Bridge AVX kernels on Linux/MingW/BSD.\n* Please use Clang version 3.1 and above to compile the library on Sandy Bridge microarchitecture. The Clang 3.0 will generate the wrong AVX binary code.\n* The number of CPUs/Cores should less than or equal to 256. On Linux x86_64(amd64), there is experimental support for up to 1024 CPUs/Cores and 128 numa nodes if you build the library with BIGNUMA=1.\n* OpenBLAS does not set processor affinity by default. On Linux, you can enable processor affinity by commenting the line NO_AFFINITY=1 in Makefile.rule. But this may cause [the conflict with R parallel](https://stat.ethz.ch/pipermail/r-sig-hpc/2012-April/001348.html).\n* On Loongson 3A. make test would be failed because of pthread_create error. The error code is EAGAIN. However, it will be OK when you run the same testcase on shell.\n\n## BLAS reference manual\nIf you want to understand every BLAS function and definition, please read\n[Intel MKL reference manual](https://software.intel.com/sites/products/documentation/doclib/iss/2013/mkl/mklman/GUID-F7ED9FB8-6663-4F44-A62B-61B63C4F0491.htm)\nor [netlib.org](http://netlib.org/blas/)\n\nHere are [OpenBLAS extension functions](https://github.com/xianyi/OpenBLAS/wiki/OpenBLAS-Extensions)\n\n## How to reference OpenBLAS.\n\nYou can reference our [papers](https://github.com/xianyi/OpenBLAS/wiki/publications).\n\nAlternatively, you can cite the OpenBLAS homepage http://www.openblas.net directly.\n\n"
        },
        {
          "name": "appveyor.yml",
          "type": "blob",
          "size": 2.9462890625,
          "content": "version: 0.2.19.{build}\n\n#environment:\n\nplatform: \n  - x64\n\nos: Visual Studio 2017\n\nconfiguration: Release\n\nclone_folder: c:\\projects\\OpenBLAS\n\ninit:\n  - git config --global core.autocrlf input\n\nclone_depth: 5\n\nskip_tags: true\n\nmatrix:\n  fast_finish: false\n\nskip_commits:\n# Add [av skip] to commit messages\n  message: /\\[av skip\\]/\n\nenvironment:\n  global:\n    CONDA_INSTALL_LOCN: C:\\\\Miniconda36-x64\n  matrix:\n#    - COMPILER: clang-cl\n#      WITH_FORTRAN: ON\n#    - COMPILER: clang-cl\n#      DYNAMIC_ARCH: ON\n#      WITH_FORTRAN: OFF\n#    - COMPILER: cl\n#    - COMPILER: MinGW64-gcc-7.2.0-mingw\n#      DYNAMIC_ARCH: OFF\n#      WITH_FORTRAN: ignore\n    - APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2015\n      COMPILER: MinGW-gcc-6.3.0-32   \n    - APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2015\n      COMPILER: MinGW-gcc-5.3.0\n      WITH_FORTRAN: ignore\n    \ninstall:\n  - if [%COMPILER%]==[clang-cl] call %CONDA_INSTALL_LOCN%\\Scripts\\activate.bat\n  - if [%COMPILER%]==[clang-cl] conda update --yes -n base conda\n  - if [%COMPILER%]==[clang-cl] conda config --add channels conda-forge --force\n  - if [%COMPILER%]==[clang-cl] conda config --set auto_update_conda false\n  - if [%COMPILER%]==[clang-cl] conda install --yes --quiet clangdev cmake ninja flang=11.0.1\n  - if [%COMPILER%]==[clang-cl] call \"C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Auxiliary\\Build\\vcvarsall.bat\" x64\n  - if [%COMPILER%]==[clang-cl] set \"LIB=%CONDA_INSTALL_LOCN%\\Library\\lib;%LIB%\"\n  - if [%COMPILER%]==[clang-cl] set \"CPATH=%CONDA_INSTALL_LOCN%\\Library\\include;%CPATH%\"\n\nbefore_build:\n  - ps: if (-Not (Test-Path .\\build)) { mkdir build }\n  - cd build\n  - set PATH=%PATH:C:\\Program Files\\Git\\usr\\bin;=%\n  - if [%COMPILER%]==[MinGW-gcc-5.3.0] set PATH=C:\\MinGW\\bin;C:\\msys64\\usr\\bin;C:\\mingw-w64\\x86_64-7.2.0-posix-seh-rt_v5-rev1\\mingw64\\bin;%PATH%\n  - if [%COMPILER%]==[MinGW64-gcc-7.2.0-mingw] set PATH=C:\\MinGW\\bin;C:\\mingw-w64\\x86_64-7.2.0-posix-seh-rt_v5-rev1\\mingw64\\bin;%PATH%\n  - if [%COMPILER%]==[MinGW-gcc-6.3.0-32] set PATH=C:\\msys64\\usr\\bin;C:\\mingw-w64\\i686-6.3.0-posix-dwarf-rt_v5-rev1\\mingw64\\bin;%PATH%\n  - if [%COMPILER%]==[cl] cmake -G \"Visual Studio 15 2017 Win64\" ..\n  - if [%COMPILER%]==[MinGW64-gcc-7.2.0-mingw] cmake -G \"MinGW Makefiles\" -DNOFORTRAN=1 ..\n  - if [%COMPILER%]==[MinGW-gcc-6.3.0-32] cmake -G \"MSYS Makefiles\" -DNOFORTRAN=1 ..\n  - if [%COMPILER%]==[MinGW-gcc-5.3.0] cmake -G \"MSYS Makefiles\" -DNOFORTRAN=1 ..\n  - if [%WITH_FORTRAN%]==[OFF] cmake -G \"Ninja\" -DCMAKE_CXX_COMPILER=clang-cl -DCMAKE_C_COMPILER=clang-cl -DCMAKE_MT=mt -DMSVC_STATIC_CRT=ON ..\n  - if [%WITH_FORTRAN%]==[ON] cmake -G \"Ninja\" -DCMAKE_CXX_COMPILER=clang-cl -DCMAKE_C_COMPILER=clang-cl -DCMAKE_Fortran_COMPILER=flang -DCMAKE_MT=mt -DBUILD_WITHOUT_LAPACK=no -DNOFORTRAN=0 ..\n  - if [%USE_OPENMP%]==[ON] cmake -DUSE_OPENMP=ON ..\n  - if [%DYNAMIC_ARCH%]==[ON] cmake -DDYNAMIC_ARCH=ON -DDYNAMIC_LIST='CORE2;NEHALEM;SANDYBRIDGE;BULLDOZER;HASWELL' ..\n\nbuild_script:\n  - cmake --build .\n\ntest_script:\n  - ctest -j2\n  \n"
        },
        {
          "name": "azure-pipelines.yml",
          "type": "blob",
          "size": 12.0419921875,
          "content": "trigger:\n  # start a new build for every push\n  batch: False\n  branches:\n    include:\n      - develop\nresources:\n  containers:\n      - container: oneapi-hpckit\n        image: intel/oneapi-hpckit:latest\n        options: '-v /usr/bin/sudo:/usr/bin/sudo -v /usr/lib/sudo/libsudo_util.so.0:/usr/lib/sudo/libsudo_util.so.0 -v /usr/lib/sudo/sudoers.so:/usr/lib/sudo/sudoers.so'\n      - container: oneapi-basekit\n        image: intel/oneapi-basekit:latest\n        options: '-v /usr/bin/sudo:/usr/bin/sudo -v /usr/lib/sudo/libsudo_util.so.0:/usr/lib/sudo/libsudo_util.so.0 -v /usr/lib/sudo/sudoers.so:/usr/lib/sudo/sudoers.so'\n \njobs:\n# manylinux1 is useful to test because the\n# standard Docker container uses an old version\n# of gcc / glibc\n- job: manylinux1_gcc\n  pool:\n    vmImage: 'ubuntu-latest'\n  steps:\n  - script: |\n      echo \"FROM quay.io/pypa/manylinux1_x86_64\n        COPY . /tmp/openblas\n        RUN cd /tmp/openblas                                      &&  \\\n            COMMON_FLAGS='DYNAMIC_ARCH=1 TARGET=NEHALEM NUM_THREADS=32' && \\\n            BTYPE='BINARY=64' CC=gcc && \\\n            make QUIET_MAKE=1 $COMMON_FLAGS $BTYPE && \\\n            make -C test $COMMON_FLAGS $BTYPE && \\\n            make -C ctest $COMMON_FLAGS $BTYPE && \\\n            make -C utest $COMMON_FLAGS $BTYPE\" > Dockerfile\n      docker build .\n    displayName: Run manylinux1 docker build\n- job: Intel_SDE_skx\n  pool:\n    vmImage: 'ubuntu-latest'\n  steps:\n  - script: |\n      # at the time of writing the available Azure Ubuntu vm image\n      # does not support AVX512VL, so use more recent LTS version\n      echo \"FROM ubuntu:bionic\n      COPY . /tmp/openblas\n      RUN apt-get -y update && apt-get -y install \\\\\n          cmake \\\\\n          gfortran \\\\\n          make \\\\\n          wget\n      RUN mkdir /tmp/SDE && cd /tmp/SDE && \\\\\n          mkdir sde-external-8.35.0-2019-03-11-lin && \\\\\n          wget --quiet -O sde-external-8.35.0-2019-03-11-lin.tar.bz2 https://www.dropbox.com/s/fopsnzj67572sj5/sde-external-8.35.0-2019-03-11-lin.tar.bz2?dl=0 && \\\\\n          tar -xjvf sde-external-8.35.0-2019-03-11-lin.tar.bz2 -C /tmp/SDE/sde-external-8.35.0-2019-03-11-lin --strip-components=1\n      RUN cd /tmp/openblas && CC=gcc make QUIET_MAKE=1 DYNAMIC_ARCH=1 NUM_THREADS=32 BINARY=64\n      CMD cd /tmp/openblas && echo 0 > /proc/sys/kernel/yama/ptrace_scope && CC=gcc OPENBLAS_VERBOSE=2 /tmp/SDE/sde-external-8.35.0-2019-03-11-lin/sde64 -cpuid_in /tmp/SDE/sde-external-8.35.0-2019-03-11-lin/misc/cpuid/skx/cpuid.def -- make -C utest DYNAMIC_ARCH=1 NUM_THREADS=32 BINARY=64\" > Dockerfile\n      docker build -t intel_sde .\n      # we need a privileged docker run for sde process attachment\n      docker run --privileged intel_sde\n    displayName: 'Run AVX512 SkylakeX docker build / test'\n\n- job: Windows_cl\n  pool:\n     vmImage: 'windows-latest'\n  steps:   \n  - task: CMake@1\n    inputs:\n      workingDirectory: 'build' # Optional\n      cmakeArgs: '-G \"Visual Studio 17 2022\" ..'\n  - task: CMake@1\n    inputs:\n      cmakeArgs: '--build . --config Release'\n      workingDirectory: 'build'\n  - script: |\n      cd build\n      cd utest\n      dir\n      openblas_utest.exe\n\n- job: Windows_mingw_gmake\n  pool:\n     vmImage: 'windows-latest'\n  steps:   \n  - script: |\n      mingw32-make CC=gcc FC=gfortran DYNAMIC_ARCH=1 DYNAMIC_LIST=\"SANDYBRIDGE\"\n\n- job: Windows_clang_cmake\n  pool:\n     vmImage: 'windows-latest'\n  steps:\n  - script: |\n      set \"PATH=C:\\Miniconda\\Scripts;C:\\Miniconda\\Library\\bin;C:\\Miniconda\\Library\\usr\\bin;C:\\Miniconda\\condabin;%PATH%\"\n      set \"LIB=C:\\Miniconda\\Library\\lib;%LIB%\"\n      set \"CPATH=C:\\Miniconda\\Library\\include;%CPATH%\n      conda config --add channels conda-forge --force\n      conda config --set auto_update_conda false\n      conda install --yes ninja\n      call \"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Auxiliary\\Build\\vcvars64.bat\"\n      mkdir build \n      cd build\n      cmake -G \"Ninja\" -DCMAKE_C_COMPILER=clang-cl -DCMAKE_CXX_COMPILER=clang-cl -DCMAKE_MT=mt -DCMAKE_BUILD_TYPE=Release -DNOFORTRAN=1 -DMSVC_STATIC_CRT=ON ..\n      cmake --build . --config Release\n      ctest\n\n- job: Windows_flang_clang\n  pool:\n     vmImage: 'windows-2022'\n  steps:\n  - script: |\n      set \"PATH=C:\\Miniconda\\Scripts;C:\\Miniconda\\Library\\bin;C:\\Miniconda\\Library\\usr\\bin;C:\\Miniconda\\condabin;%PATH%\"\n      set \"LIB=C:\\Miniconda\\Library\\lib;%LIB%\"\n      set \"CPATH=C:\\Miniconda\\Library\\include;%CPATH%\"\n      conda config --add channels conda-forge --force\n      conda config --set auto_update_conda false\n      conda install --yes --quiet ninja flang\n      mkdir build \n      cd build\n      call \"C:\\Program Files\\Microsoft Visual Studio\\2022\\Enterprise\\VC\\Auxiliary\\Build\\vcvars64.bat\"\n      cmake -G \"Ninja\" -DCMAKE_C_COMPILER=clang-cl -DCMAKE_CXX_COMPILER=clang-cl -DCMAKE_Fortran_COMPILER=\"flang -I C:\\Miniconda\\Library\\include\\flang\" -DBUILD_TESTING=OFF -DCMAKE_MT=mt -DCMAKE_BUILD_TYPE=Release -DMSVC_STATIC_CRT=ON ..\n      cmake --build . --config Release\n      ctest\n\n- job: Windows_cl_flang\n  pool:\n     vmImage: 'windows-2022'\n  steps:\n  - script: |\n      set \"PATH=C:\\Miniconda\\Scripts;C:\\Miniconda\\Library\\bin;C:\\Miniconda\\Library\\usr\\bin;C:\\Miniconda\\condabin;%PATH%\"\n      set \"LIB=C:\\Miniconda\\Library\\lib;%LIB%\"\n      set \"CPATH=C:\\Miniconda\\Library\\include;%CPATH%\"\n      conda config --add channels conda-forge --force\n      conda config --set auto_update_conda false\n      conda install --yes --quiet ninja flang\n      mkdir build \n      cd build\n      call \"C:\\Program Files\\Microsoft Visual Studio\\2022\\Enterprise\\VC\\Auxiliary\\Build\\vcvars64.bat\"\n      cmake -G \"Ninja\" -DCMAKE_C_COMPILER=cl -DCMAKE_Fortran_COMPILER=flang-new -DC_LAPACK=1 -DCMAKE_MT=mt -DCMAKE_BUILD_TYPE=Release -DMSVC_STATIC_CRT=ON ..\n      cmake --build . --config Release\n      ctest\n      ctest --rerun-failed --output-on-failure\n\n\n- job: OSX_OpenMP\n  pool:\n     vmImage: 'macOS-12'\n  steps:   \n  - script: |\n      brew update\n      make TARGET=CORE2 DYNAMIC_ARCH=1 USE_OPENMP=1 INTERFACE64=1 CC=gcc-13 FC=gfortran-13\n      make TARGET=CORE2 DYNAMIC_ARCH=1 USE_OPENMP=1 INTERFACE64=1 CC=gcc-13 FC=gfortran-13 PREFIX=../blasinst install\n      ls -lR ../blasinst\n     \n- job: OSX_GCC_Nothreads\n  pool:\n     vmImage: 'macOS-12'\n  steps:   \n  - script: |\n      brew update\n      make USE_THREADS=0 CC=gcc-13 FC=gfortran-13\n     \n- job: OSX_GCC12\n  pool:\n     vmImage: 'macOS-latest'\n  steps:   \n  - script: |\n      brew update\n      make CC=gcc-12 FC=gfortran-12\n     \n- job: OSX_OpenMP_Clang\n  pool:\n     vmImage: 'macOS-latest'\n  variables:\n     LD_LIBRARY_PATH: /usr/local/opt/llvm/lib\n     LIBRARY_PATH: /usr/local/opt/llvm/lib\n  steps:   \n  - script: |\n      brew update\n      brew install llvm libomp\n      make TARGET=CORE2 USE_OPENMP=1 DYNAMIC_ARCH=1 CC=/usr/local/opt/llvm/bin/clang NOFORTRAN=1\n\n- job: OSX_OpenMP_Clang_cmake\n  pool:\n     vmImage: 'macOS-latest'\n  variables:\n     LD_LIBRARY_PATH: /usr/local/opt/llvm/lib\n     LIBRARY_PATH: /usr/local/opt/llvm/lib\n  steps:   \n  - script: |\n      brew update\n      brew install llvm libomp\n      mkdir build\n      cd build\n      cmake -DTARGET=CORE2 -DUSE_OPENMP=1 -DINTERFACE64=1 -DDYNAMIC_ARCH=1 -DCMAKE_C_COMPILER=/usr/local/opt/llvm/bin/clang -DNOFORTRAN=1 -DNO_AVX512=1 ..\n      make\n      ctest\n      \n- job: OSX_dynarch_cmake\n  pool:\n     vmImage: 'macOS-12'\n  variables:\n     LD_LIBRARY_PATH: /usr/local/opt/llvm/lib\n     LIBRARY_PATH: /usr/local/opt/llvm/lib\n  steps:   \n  - script: |\n      mkdir build\n      cd build\n      cmake -DTARGET=CORE2 -DDYNAMIC_ARCH=1 -DDYNAMIC_LIST='NEHALEM HASWELL SKYLAKEX' -DCMAKE_C_COMPILER=gcc-13 -DCMAKE_Fortran_COMPILER=gfortran-13 -DBUILD_SHARED_LIBS=ON ..\n      cmake --build .\n      ctest\n\n- job: OSX_Ifort_Clang\n  pool:\n     vmImage: 'macOS-latest'\n  variables:\n     LD_LIBRARY_PATH: /usr/local/opt/llvm/lib\n     MACOS_HPCKIT_URL: https://registrationcenter-download.intel.com/akdlm/IRC_NAS/edb4dc2f-266f-47f2-8d56-21bc7764e119/m_HPCKit_p_2023.2.0.49443.dmg\n     LIBRARY_PATH: /usr/local/opt/llvm/lib\n     MACOS_FORTRAN_COMPONENTS: intel.oneapi.mac.ifort-compiler\n  steps:   \n  - script: |\n      brew update\n      brew install llvm libomp\n      sudo mkdir -p /opt/intel\n      sudo chown $USER /opt/intel\n    displayName: prepare for cache restore\n  - task: Cache@2\n    inputs:\n      path: /opt/intel/oneapi\n      key: '\"install\" | \"$(MACOS_HPCKIT_URL)\" | \"$(MACOS_FORTRAN_COMPONENTS)\"'\n      cacheHitVar: CACHE_RESTORED\n  - script: | \n      curl --output webimage.dmg --url $(MACOS_HPCKIT_URL) --retry 5 --retry-delay 5\n      hdiutil attach webimage.dmg\n      sudo /Volumes/\"$(basename \"$(MACOS_HPCKIT_URL)\" .dmg)\"/bootstrapper.app/Contents/MacOS/bootstrapper -s --action install --components=\"$(MACOS_FORTRAN_COMPONENTS)\" --eula=accept --continue-with-optional-error=yes --log-dir=.\n      installer_exit_code=$?\n      hdiutil detach /Volumes/\"$(basename \"$URL\" .dmg)\" -quiet\n      exit $installer_exit_code\n    displayName: install\n    condition: ne(variables.CACHE_RESTORED, 'true')\n  - script: | \n      source /opt/intel/oneapi/setvars.sh\n      make CC=/usr/local/opt/llvm/bin/clang FC=ifort\n \n- job: OSX_NDK_ARMV7\n  pool:\n     vmImage: 'macOS-12'\n  steps:   \n  - script: | \n      brew update\n      brew install --cask android-ndk\n      export ANDROID_NDK_HOME=/usr/local/share/android-ndk\n      make TARGET=ARMV7 ONLY_CBLAS=1 CC=$ANDROID_NDK_HOME/toolchains/llvm/prebuilt/darwin-x86_64/bin/armv7a-linux-androideabi21-clang AR=$ANDROID_NDK_HOME/toolchains/llvm/prebuilt/darwin-x86_64/bin/llvm-ar HOSTCC=gcc ARM_SOFTFP_ABI=1 -j4\n\n- job: OSX_IOS_ARMV8\n  pool:\n     vmImage: 'macOS-12'\n  variables:\n     CC: /Applications/Xcode_14.2.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang\n     CFLAGS: -O2 -Wno-macro-redefined -isysroot /Applications/Xcode_14.2.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS16.2.sdk -arch arm64 -miphoneos-version-min=10.0\n  steps:\n  - script: |\n     make TARGET=ARMV8 DYNAMIC_ARCH=1 NUM_THREADS=32 HOSTCC=clang NOFORTRAN=1\n\n- job: OSX_IOS_ARMV7\n  pool:\n     vmImage: 'macOS-12'\n  variables:\n     CC: /Applications/Xcode_14.2.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang\n     CFLAGS: -O2 -mno-thumb -Wno-macro-redefined -isysroot /Applications/Xcode_14.2.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS16.2.sdk -arch armv7 -miphoneos-version-min=5.1\n  steps:\n  - script: |\n     make TARGET=ARMV7 DYNAMIC_ARCH=1 NUM_THREADS=32 HOSTCC=clang NOFORTRAN=1\n\n- job: OSX_xbuild_DYNAMIC_ARM64\n  pool:\n     vmImage: 'macOS-12'\n  variables:\n     CC: /Applications/Xcode_14.2.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang\n     CFLAGS: -O2 -Wno-macro-redefined -isysroot /Applications/Xcode_14.2.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX13.1.sdk -arch arm64\n  steps:\n  - script: |\n     ls /Applications/Xcode_14.2.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs\n     /Applications/Xcode_12.2.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang -arch arm64 --print-supported-cpus\n     /Applications/Xcode_14.2.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang --version\n     make TARGET=ARMV8 DYNAMIC_ARCH=1 NUM_THREADS=32 HOSTCC=clang NOFORTRAN=1\n\n- job: ALPINE_MUSL\n  pool:\n     vmImage: 'ubuntu-latest'\n  steps:\n  - script: |\n        wget https://raw.githubusercontent.com/alpinelinux/alpine-chroot-install/v0.14.0/alpine-chroot-install \\\n        && echo 'ccbf65f85cdc351851f8ad025bb3e65bae4d5b06  alpine-chroot-install' | sha1sum -c \\\n        || exit 1\n        alpine() { /alpine/enter-chroot -u \"$USER\" \"$@\"; }\n        sudo sh alpine-chroot-install -p 'build-base gfortran perl linux-headers sudo'\n        alpine make DYNAMIC_ARCH=1 BINARY=64\n        alpine make DYNAMIC_ARCH=1 BINARY=64 PREFIX=mytestdir install\n        alpine ls -l mytestdir/include\n        alpine echo \"// tests that inclusion of openblas_config.h works with musl\" >test_install.c\n        alpine echo \"#include <openblas_config.h>\" >>test_install.c\n        alpine echo \"int main(){\" >> test_install.c\n        alpine echo \"cpu_set_t* cpu_set = NULL;}\" >>test_install.c\n        alpine gcc -Imytestdir/include test_install.c -Lmytestdir/lib -lopenblas -lpthread -lgfortran -o test_install\n        \n"
        },
        {
          "name": "benchmark",
          "type": "tree",
          "content": null
        },
        {
          "name": "c_check",
          "type": "blob",
          "size": 13.837890625,
          "content": "#!/bin/sh\n\n# Checking cross compile\nhostos=`uname -s | sed -e 's/\\-.*//'`\nhostarch=`uname -m | sed -e 's/i.86/x86/'`\nif [ \"$hostos\" = \"AIX\" ] || [ \"$hostos\" = \"SunOS\" ]; then\n    hostarch=`uname -p`\nfi\nif [ \"$hostarch\" = \"evbarm\" ]; then\n    hostarch=`uname -p`\nfi\ncase \"$hostarch\" in\n    amd64) hostarch=x86_64 ;;\n    arm*) [ \"$hostarch\" = \"arm64\" ] || hostarch='arm' ;;\n    aarch64) hostarch=arm64 ;;\n    powerpc*|ppc*) hostarch=power ;;\n    s390x) hostarch=zarch ;;\nesac\n\nmakefile=\"$1\"\nconfig=\"$2\"\n\ncompiler_name=\"$3\"\nshift 3\nflags=\"$*\"\n\n# First, we need to know the target OS and compiler name\n{\n    data=`$compiler_name $flags -E ctest.c`\n} || {\n    printf '%s\\n' \"C Compiler ($compiler_name) is something wrong.\" >&2\n    exit 1\n}\n\ncross_suffix=\"\"\n\nif [ \"`dirname \"$compiler_name\"`\" != '.' ]; then\n    cross_suffix=\"$cross_suffix`dirname \"$compiler_name\"`/\"\nfi\n\ncn=`echo $compiler_name | sed -e 's/ -.*//'`\nbn=`basename \"$cn\"`\n\ncase \"$bn\" in\n    *-*) if [ \"$bn\" != '-' ]; then\n           cross_suffix=\"$cross_suffix${bn%-*}-\"\n         fi\nesac\n\ncompiler=\"\"\ncase \"$data\" in\n    *COMPILER_LSB*) compiler=LSB ;;\n    *COMPILER_CLANG*) compiler=CLANG ;;\n    *COMPILER_PGI*) compiler=PGI ;;\n    *COMPILER_PATHSCALE*) compiler=PATHSCALE ;;\n    *COMPILER_INTEL*) compiler=INTEL ;;\n    *COMPILER_OPEN64*) compiler=OPEN64 ;;\n    *COMPILER_SUN*) compiler=SUN ;;\n    *COMPILER_IBM*) compiler=IBM ;;\n    *COMPILER_DEC*) compiler=DEC ;;\n    *COMPILER_FUJITSU*) compiler=FUJITSU ;;\nesac\nif [ -z \"$compiler\" ]; then\n    compiler=GCC\nfi\n\ncase \"$data\" in *OS_LINUX*) os=Linux ;; esac\ncase \"$data\" in *OS_FREEBSD*) os=FreeBSD ;; esac\ncase \"$data\" in *OS_NETBSD*) os=NetBSD ;; esac\ncase \"$data\" in *OS_OPENBSD*) os=OpenBSD ;; esac\ncase \"$data\" in *OS_DRAGONFLY*) os=DragonFly ;; esac\ncase \"$data\" in *OS_DARWIN*) os=Darwin ;; esac\ncase \"$data\" in *OS_SUNOS*) os=SunOS ;; esac\ncase \"$data\" in *OS_AIX*) os=AIX ;; esac\ncase \"$data\" in *OS_OSF*) os=osf ;; esac\ncase \"$data\" in *OS_WINNT*) os=WINNT ;; esac\ncase \"$data\" in *OS_CYGWIN_NT*) os=CYGWIN_NT ;; esac\ncase \"$data\" in *OS_INTERIX*) os=Interix ;; esac\ncase \"$data\" in *OS_ANDROID*) os=Android ;; esac\ncase \"$data\" in *OS_HAIKU*) os=Haiku ;; esac\n\ncase \"$data\" in\n    *ARCH_X86_64*) architecture=x86_64 ;;\n    *ARCH_X86*) architecture=x86 ;;\n    *ARCH_E2K*) architecture=e2k ;;\n    *ARCH_POWER*) architecture=power ;;\n    *ARCH_MIPS64*) architecture=mips64 ;;\n    *ARCH_MIPS*) architecture=mips ;;\n    *ARCH_ALPHA*) architecture=alpha ;;\n    *ARCH_SPARC*) architecture=sparc ;;\n    *ARCH_IA64*) architecture=ia64 ;;\n    *ARCH_ARM64*) architecture=arm64 ;;\n    *ARCH_ARM*) architecture=arm ;;\n    *ARCH_ZARCH*) architecture=zarch ;;\n    *ARCH_RISCV64*) architecture=riscv64 ;;\n    *ARCH_LOONGARCH64*) architecture=loongarch64 ;;\n    *ARCH_CSKY*) architecture=csky ;;\nesac\n\ndefined=0\n\nif [ \"$os\" = \"AIX\" ]; then\n    if [ \"$compiler\" = \"GCC\" ]; then\n        case \"$BINARY\" in\n            32) compiler_name=\"$compiler_name -maix32\" ;;\n            64) compiler_name=\"$compiler_name -maix64\" ;;\n        esac\n        defined=1\n    else\n        case \"$BINARY\" in\n            32) compiler_name=\"$compiler_name -m32\" ;;\n            64) compiler_name=\"$compiler_name -m64\" ;;\n        esac\n        defined=1\n    fi\nfi\n\ncase \"$architecture\" in\n    mips)\n    \tcompiler_name=\"$compiler_name -mabi=32\"\n    \tdefined=1\n    \t;;\n    mips64)\n    \tcase \"$BINARY\" in\n    \t    32) compiler_name=\"$compiler_name -mabi=n32\" ;;\n    \t    64) compiler_name=\"$compiler_name -mabi=64\" ;;\n    \tesac\n    \tdefined=1\n    \t;;\n    arm|arm64) defined=1 ;;\n    zarch|e2k|alpha|ia64|riscv64|loonarch64)\n    \tdefined=1\n    \tBINARY=64\n    \t;;\n    x86)\n    \t[ \"$os\" != \"Darwin\" ] && [ \"$os\" != \"SunOS\" ] && {\n    \t    defined=1\n    \t    BINARY=32\n    \t}\n    \t;;\nesac\n\ncase \"$compiler\" in\n    PGI)\n    \tcase \"$BINARY\" in\n    \t    32) compiler_name=\"$compiler_name -tp p7\" ;;\n    \t    64) compiler_name=\"$compiler_name -tp p7-64\" ;;\n    \tesac\n    \topenmp='-mp'\n    \tdefined=1\n    \t;;\n    IBM)\n    \tcase \"$BINARY\" in\n    \t    32) compiler_name=\"$compiler_name -q32\" ;;\n    \t    64) compiler_name=\"$compiler_name -q64\" ;;\n    \tesac\n    \topenmp='-qsmp=omp'\n    \tdefined=1\n    \t;;\n    INTEL) openmp='-openmp' ;;\n    PATHSCALE|OPEN64) openmp='-mp' ;;\n    CLANG|GCC|LSB) openmp='-fopenmp' ;;\n    FUJITSU) openmp='-Kopenmp' ;;\nesac\n\nif [ \"$defined\" -eq 0 ]; then\n    case \"$BINARY\" in\n    \t32) compiler_name=\"$compiler_name -m32\" ;;\n    \t64) compiler_name=\"$compiler_name -m64\" ;;\n    esac\nfi\n\n# Do again\n{\n    data=\"$($compiler_name $flags -E ctest.c)\"\n} || {\n    printf '%s\\n' \"C Compiler ($compiler_name) is something wrong.\" >&2\n    exit 1\n}\n\nno_msa=0\nif [ \"$architecture\" = \"mips\" ] || [ \"$architecture\" = \"mips64\" ]; then\n    tmpd=$(mktemp -d 2>/dev/null || mktemp -d -t 'OBC')\n    tmpf=\"$tmpd/a.c\"\n    code='\"addvi.b $w0, $w1, 1\"'\n    msa_flags='-mmsa -mfp64 -mload-store-pairs'\n    printf \"#include <msa.h>\\n\\n\" >> \"$tmpf\"\n    printf \"void main(void){ __asm__ volatile(%s); }\\n\" \"$code\" >> \"$tmpf\"\n\n    args=\"$msa_flags -o $tmpf.o $tmpf\"\n    {\n    \t$compiler_name $flags $args >/dev/null 2>&1\n    } || {\n    \tno_msa=1\n    }\n\n    rm -rf \"$tmpd\"\nfi\n\nno_lsx=0\nno_lasx=0\nif [ \"$architecture\" = \"loongarch64\" ]; then\n    lasx_flags='-march=loongarch64'\n    lsx_flags='-march=loongarch64'\n\n    tmpd=\"$(mktemp -d)\"\n    tmparch=\"$tmpd/arch.c\"\n    printf \"void main(void){ }\\n\" >> \"$tmparch\"\n    args=\"-march=loongarch64 -o $tmparch.o $tmparch\"\n    {\n        $compiler_name $flags $args >/dev/null 2>&1\n    } || {\n        lasx_flags=''\n        lsx_flags=''\n    }\n\n    tmplsx=\"$tmpd/lsx.c\"\n    codelsx='\"vadd.b $vr0, $vr0, $vr0\"'\n    printf \"void main(void){ __asm__ volatile(%s);}\\n\" \"$codelsx\" >> \"$tmplsx\"\n    args=\"$lsx_flags -o $tmplsx.o $tmplsx\"\n    {\n        $compiler_name $flags $args >/dev/null 2>&1\n    } || {\n        no_lsx=1\n    }\n\n    tmplasx=\"$tmpd/lasx.c\"\n    codelasx='\"xvadd.b $xr0, $xr0, $xr0\"'\n    printf \"void main(void){ __asm__ volatile(%s);}\\n\" \"$codelasx\" >> \"$tmplasx\"\n    args=\"$lasx_flags -o $tmplasx.o $tmplasx\"\n    {\n        $compiler_name $flags $args >/dev/null 2>&1\n    } || {\n        no_lasx=1\n    }\n\n    rm -rf \"$tmpd\"\nfi\n\ncase \"$data\" in\n    *ARCH_X86_64*) architecture=x86_64 ;;\n    *ARCH_X86*) architecture=x86 ;;\n    *ARCH_E2K*) architecture=e2k ;;\n    *ARCH_POWER*) architecture=power ;;\n    *ARCH_MIPS64*) architecture=mips64 ;;\n    *ARCH_MIPS*) architecture=mips ;;\n    *ARCH_ALPHA*) architecture=alpha ;;\n    *ARCH_SPARC*) architecture=sparc ;;\n    *ARCH_IA64*) architecture=ia64 ;;\n    *ARCH_ARM64*) architecture=arm64 ;;\n    *ARCH_ARM*) architecture=arm ;;\n    *ARCH_ZARCH*) architecture=zarch ;;\n    *ARCH_LOONGARCH64*) architecture=loongarch64 ;;\n    *ARCH_CSKY*) architecture=csky ;;\nesac\n\nbinformat='bin32'\ncase \"$data\" in\n    *BINARY_64*) binformat='bin64' ;;\nesac\n\nno_avx512=0\nno_avx512bf=0\nif [ \"$architecture\" = \"x86\" ] || [ \"$architecture\" = \"x86_64\" ]; then\n    tmpd=$(mktemp -d 2>/dev/null || mktemp -d -t 'OBC')\n    tmpf=\"$tmpd/a.c\"\n    code='\"vbroadcastss -4 * 4(%rsi), %zmm2\"'\n    printf \"#include <immintrin.h>\\n\\nint main(void){ __asm__ volatile(%s); }\\n\" \"$code\" >> \"$tmpf\"\n    if [ \"$compiler\" = \"PGI\" ]; then\n        args=\" -tp skylake -c -o $tmpf.o $tmpf\"\n    else\n        args=\" -march=skylake-avx512 -c -o $tmpf.o $tmpf\"\n    fi\n    no_avx512=0\n    {\n    \t$compiler_name $flags $args >/dev/null 2>&1\n    } || {\n    \tno_avx512=1\n    }\n\n    rm -rf \"$tmpd\"\n    if [ \"$no_avx512\" -eq 0 ]; then\n    tmpd=$(mktemp -d 2>/dev/null || mktemp -d -t 'OBC')\n    tmpf=\"$tmpd/a.c\"\n    code='\"__m512 a= _mm512_dpbf16_ps(a, (__m512bh) _mm512_loadu_si512(%1]), (__m512bh) _mm512_loadu_si512(%2]));\"'\n    printf \"#include <immintrin.h>\\n\\nint main(void){ %s; }\\n\" \"$code\" >> \"$tmpf\"\n    if [ \"$compiler\" = \"PGI\" ]; then\n        args=\" -tp cooperlake -c -o $tmpf.o $tmpf\"\n    else\n        args=\" -march=cooperlake -c -o $tmpf.o $tmpf\"\n    fi\n    no_avx512bf=0\n    {\n        $compiler_name $flags $args >/dev/null 2>&1\n    } || {\n        no_avx512bf=1\n    }\n\n    rm -rf \"$tmpd\"\n  fi\nfi\n\nno_rv64gv=0\nif [ \"$architecture\" = \"riscv64\" ]; then\n    tmpd=$(mktemp -d 2>/dev/null || mktemp -d -t 'OBC')\n    tmpf=\"$tmpd/a.c\"\n    code='\"vsetvli    zero, zero, e8, m1\\n\"'\n    printf \"int main(void){ __asm__ volatile(%s); }\\n\" \"$code\" >> \"$tmpf\"\n    args=\" -march=rv64gv -c -o $tmpf.o $tmpf\"\n    no_rv64gv=0\n    {\n        $compiler_name $flags $args >/dev/null 2>&1\n    } || {\n        no_rv64gv=1\n    }\n    rm -rf \"$tmpd\"\nfi\n\nno_sve=0\nif [ \"$architecture\" = \"arm64\" ]; then\n    tmpd=$(mktemp -d 2>/dev/null || mktemp -d -t 'OBC')\n    tmpf=\"$tmpd/a.c\"\n    printf \"#include <arm_sve.h>\\n\\n int main(void){}\\n\">> \"$tmpf\"\n    args=\" -march=armv8-a+sve -c -o $tmpf.o $tmpf\"\n    no_sve=0\n    {\n        $compiler_name $flags $args >/dev/null 2>&1\n    } || {\n        args=\" -Msve_intrinsics -c -o $tmpf.o $tmpf\"\n        $compiler_name $flags $args >/dev/null 2>&1\n    } || {\n        no_sve=1\n    }\n    rm -rf \"$tmpd\"\nfi\n\nc11_atomics=0\ncase \"$data\" in\n    *HAVE_C11*)\n        tmpd=$(mktemp -d 2>/dev/null || mktemp -d -t 'OBC')\n        tmpf=\"$tmpd/a.c\"\n        printf \"#include <stdatomic.h>\\nint main(void){}\\n\" >> \"$tmpf\"\n        args=\" -c -o $tmpf.o $tmpf\"\n        c11_atomics=1\n        {\n            $compiler_name $flags $args >/dev/null 2>&1\n        } || {\n            c11_atomics=0\n        }\n\n        rm -rf \"$tmpd\"\n        ;;\nesac\n\noldgcc=0\nno_avx2=0\nif [ \"$compiler\" = \"GCC\" ]; then\n    case \"$architecture\" in x86|x86_64)\n        no_avx2=0\n        oldgcc=0\n        data=`$compiler_name -dumpversion`\n        case \"$data\" in *-*)\n            data=\"${data%-*}\"\n        esac\n        case \"$data\" in *.*.*)\n            data=\"${data%.*}\"\n        esac\n        if awk -v n1=$data -v n2=4.6 'BEGIN { exit !(n1 <= n2) }'; then\n            no_avx2=1\n            oldgcc=1\n        fi\n    esac\nfi\n\ndata=`$compiler_name $flags -S ctest1.c && grep globl ctest1.s | head -n 1 && rm -f ctest1.s`\n\nneed_fu=''\nif echo \"$data\" | grep 'globl[[:space:]][_\\.]'; then\n    need_fu=\"${data##*globl[[:space:]]}\"\n    need_fu=\"${need_fu%%[!_\\.]*}\"\nfi\n\ncross=0\n\nif [ \"$architecture\" != \"$hostarch\" ]; then\n    cross=1\n    [ \"$hostarch\" = \"x86_64\" ] && [ \"$architecture\" = \"x86\" ] && cross=0\n    [ \"$hostarch\" = \"mips64\" ] && [ \"$architecture\" = \"mips\" ] && cross=0\nfi\n\n[ \"$os\" != \"$hostos\" ] && cross=1\n[ \"$os\" = \"Android\" ] && [ \"$hostos\" = \"Linux\" ] && [ -n \"$TERMUX_APP_PID\" ] \\\n    && cross=0\n\n[ \"$USE_OPENMP\" != 1 ] && openmp=''\n\nlinker_L=\"\"\nlinker_l=\"\"\nlinker_a=\"\"\n\nlink=`$compiler_name $flags -c ctest2.c -o ctest2.o 2>&1 && $compiler_name $flags $openmp -v ctest2.o -o ctest2 2>&1 && rm -f ctest2.o ctest2 ctest2.exe`\n\nlink=`echo \"$link\" | sed 's/\\-Y[[:space:]]P\\,/\\-Y/g'`\n\n\nflags=`echo $link | tr \"'[[:space:]],\\n\" \" \"`\n\n# Strip trailing quotes\nold_flags=\"$flags\"\nflags=''\n\n\nfor flag in $old_flags; do\n    f=`echo \"$flag\" | tr '\"' ' '`\n    flags=\"$flags $f\"\ndone\n\nfor flag in $flags; do\n    case \"$flag\" in -L*)\n        case \"$flag\" in\n            -LIST:*|-LANG:*) ;;\n            *) linker_L=\"$linker_L $flag\" ;;\n        esac\n    esac\n\n    case \"$flag\" in -Y*)\n        linker_L=\"$linker_L -Wl,$flag\" ;;\n    esac\n\n    case \"$flag\" in --exclude-libs*)\n        linker_L=\"$linker_L -Wl,$flag\"\n        flags=\"\"\n        ;;\n    esac\n\n    case \"$flag\" in -l*)\n        case \"$flag\" in\n            *gfortranbegin*|*frtbegin*|*pathfstart*|*numa*|*crt[0-9]*|\\\n                *gcc*|*user32*|*kernel32*|*advapi32*|*shell32*|*omp*|\\\n                *[0-9]*) ;;\n            *) linker_l=\"$linker_l $flag\" ;;\n        esac\n    esac\n\n    case \"$flag\" in *.a) linker_a=\"$linker_a $flag\" ;; esac\ndone\n\n [ \"$makefile\" = \"-\" ] && {\n    [ \"$no_rv64gv\" -eq 1 ] && printf \"NO_RV64GV=1\\n\"\n    [ \"$no_avx512\" -eq 1 ] && printf \"NO_AVX512=1\\n\"\n    [ \"$no_avx512bf\" -eq 1 ] && printf \"NO_AVX512BF16=1\\n\"\n    [ \"$no_avx2\" -eq 1 ] && printf \"NO_AVX2=1\\n\"\n    [ \"$oldgcc\" -eq 1 ] && printf \"OLDGCC=1\\n\"\n    exit 0\n}\n\n:> \"$makefile\" || exit 1\n:> \"$config\" || exit 1\n\n\n# print $data, \"\\n\";\n\n{\n    printf \"OSNAME=%s\\n\" \"$os\"\n    printf \"ARCH=%s\\n\" \"$architecture\"\n    printf \"C_COMPILER=%s\\n\" \"$compiler\"\n    [ $binformat != 'bin32' ] && printf \"BINARY32=\\n\"\n    [ $binformat != 'bin64' ] && printf \"BINARY64=\\n\"\n    [ \"$binformat\" = \"bin32\" ] && printf \"BINARY32=1\\n\"\n    [ \"$binformat\" = \"bin64\" ] && printf \"BINARY64=1\\n\"\n    [ -n \"$need_fu\" ] && printf 'FU=%s\\n' \"$need_fu\"\n    [ \"$cross\" -ne 0 ] && [ -n \"$cross_suffix\" ] && \\\n        printf \"CROSS_SUFFIX=%s\\n\" \"$cross_suffix\"\n    [ \"$cross\" -ne 0 ] && printf \"CROSS=1\\n\"\n    printf \"CEXTRALIB=%s %s %s\\n\" \"$linker_L\" \"$linker_l\" \"$linker_a\"\n    [ \"$no_msa\" -eq 1 ] &&  printf \"NO_MSA=1\\n\"\n    [ \"$no_sve\" -eq 1 ] && printf \"NO_SVE=1\\n\"\n    [ \"$no_rv64gv\" -eq 1 ] && printf \"NO_RV64GV=1\\n\"\n    [ \"$no_avx512\" -eq 1 ] && printf \"NO_AVX512=1\\n\"\n    [ \"$no_avx512bf\" -eq 1 ] && printf \"NO_AVX512BF16=1\\n\"\n    [ \"$no_avx2\" -eq 1 ] && printf \"NO_AVX2=1\\n\"\n    [ \"$oldgcc\" -eq 1 ] && printf \"OLDGCC=1\\n\"\n    [ \"$no_lsx\" -eq 1 ] && printf \"NO_LSX=1\\n\"\n    [ \"$no_lasx\" -eq 1 ] && printf \"NO_LASX=1\\n\"\n} >> \"$makefile\"\n\nos=`echo \"$os\" | tr '[[:lower:]]' '[[:upper:]]'/ `\narchitecture=`echo \"$architecture\" | tr '[[:lower:]]' '[[:upper:]]' `\ncompiler=`echo \"$compiler\" | tr '[[:lower:]]' '[[:upper:]]' `\n\n{\n    printf \"#define OS_%s\\t1\\n\" \"$os\"\n    printf \"#define ARCH_%s\\t1\\n\" \"$architecture\"\n    printf \"#define C_%s\\t1\\n\" \"$compiler\"\n    [ \"$binformat\" = \"bin32\" ] && printf \"#define __32BIT__\\t1\\n\"\n    [ \"$binformat\" = \"bin64\" ] && printf \"#define __64BIT__\\t1\\n\"\n    [ -n \"$need_fu\" ] && printf \"#define FUNDERSCORE\\t%s\\n\" \"$need_fu\"\n    [ \"$no_msa\" -eq 1 ] && printf \"#define NO_MSA\\t1\\n\"\n    [ \"$c11_atomics\" -eq 1 ] && printf \"#define HAVE_C11\\t1\\n\"\n    [ \"$no_lsx\" -eq 1 ] && printf \"#define NO_LSX\\t1\\n\"\n    [ \"$no_lasx\" -eq 1 ] && printf \"#define NO_LASX\\t1\\n\"\n} >> \"$config\"\n\n\nif [ \"$os\" = \"LINUX\" ]; then\n\n#    @pthread = split(/\\s+/, `nm /lib/libpthread.so* | grep _pthread_create`);\n\n#    if ($pthread[2] ne \"\") {\n#\tprint CONFFILE \"#define PTHREAD_CREATE_FUNC\t$pthread[2]\\n\";\n#    } else {\n\tprintf \"#define PTHREAD_CREATE_FUNC\tpthread_create\\n\" >> \"$config\"\n#    }\nelse\n    printf \"#define PTHREAD_CREATE_FUNC\tpthread_create\\n\" >> \"$config\"\nfi\n"
        },
        {
          "name": "c_check.pl",
          "type": "blob",
          "size": 14.451171875,
          "content": "#!/usr/bin/env perl\n\n#use File::Basename;\n# use File::Temp qw(tempfile);\n\n# Checking cross compile\n$hostos   = `uname -s | sed -e s/\\-.*//`;    chop($hostos);\n$hostarch = `uname -m | sed -e s/i.86/x86/`;\n$hostarch = `uname -p` if ($hostos eq \"AIX\" || $hostos eq \"SunOS\");\nchop($hostarch);\n$hostarch = \"x86_64\" if ($hostarch eq \"amd64\");\n$hostarch = \"arm\" if ($hostarch ne \"arm64\" && $hostarch =~ /^arm.*/);\n$hostarch = \"arm64\" if ($hostarch eq \"aarch64\");\n$hostarch = \"power\" if ($hostarch =~ /^(powerpc|ppc).*/);\n$hostarch = \"zarch\" if ($hostarch eq \"s390x\");\n\n#$tmpf = new File::Temp( UNLINK => 1 );\n$binary = $ENV{\"BINARY\"};\n\n$makefile = shift(@ARGV);\n$config   = shift(@ARGV);\n\n$compiler_name = shift(@ARGV);\n$flags = join(\" \", @ARGV);\n\n# First, we need to know the target OS and compiler name\n\n$data = `$compiler_name $flags -E ctest.c`;\n\nif ($?) {\n    printf STDERR \"C Compiler ($compiler_name) is something wrong.\\n\";\n    die 1;\n}\n\n$cross_suffix = \"\";\n\neval \"use File::Basename\";\nif ($@){ \n    warn \"could not load PERL module File::Basename, emulating its functionality\";\n    my $dirnam = substr($compiler_name, 0, rindex($compiler_name, \"/\")-1 );\n    if ($dirnam ne \".\") {\n\t$cross_suffix .= $dirnam . \"/\";\n    }\n    my $basnam = substr($compiler_name, rindex($compiler_name,\"/\")+1, length($compiler_name)-rindex($compiler_name,\"/\")-1);\n\tif ($basnam =~ /([^\\s]*-)(.*)/) {\n\t$cross_suffix .= $1;\n    }\n} else {\n    if (dirname($compiler_name) ne \".\") {\n\t$cross_suffix .= dirname($compiler_name) . \"/\";\n    }\n\n    if (basename($compiler_name) =~ /([^\\s]*-)(.*)/) {\n\t$cross_suffix .= $1;\n    }\n}\n\n$compiler = \"\";\n$compiler = LSB       if ($data =~ /COMPILER_LSB/);\n$compiler = CLANG     if ($data =~ /COMPILER_CLANG/);\n$compiler = PGI       if ($data =~ /COMPILER_PGI/);\n$compiler = PATHSCALE if ($data =~ /COMPILER_PATHSCALE/);\n$compiler = INTEL     if ($data =~ /COMPILER_INTEL/);\n$compiler = OPEN64    if ($data =~ /COMPILER_OPEN64/);\n$compiler = SUN       if ($data =~ /COMPILER_SUN/);\n$compiler = IBM       if ($data =~ /COMPILER_IBM/);\n$compiler = DEC       if ($data =~ /COMPILER_DEC/);\n$compiler = FUJITSU   if ($data =~ /COMPILER_FUJITSU/);\n$compiler = GCC       if ($compiler eq \"\");\n\n$os = Linux           if ($data =~ /OS_LINUX/);\n$os = FreeBSD         if ($data =~ /OS_FREEBSD/);\n$os = NetBSD          if ($data =~ /OS_NETBSD/);\n$os = OpenBSD         if ($data =~ /OS_OPENBSD/);\n$os = DragonFly       if ($data =~ /OS_DRAGONFLY/);\n$os = Darwin          if ($data =~ /OS_DARWIN/);\n$os = SunOS           if ($data =~ /OS_SUNOS/);\n$os = AIX             if ($data =~ /OS_AIX/);\n$os = osf             if ($data =~ /OS_OSF/);\n$os = WINNT           if ($data =~ /OS_WINNT/);\n$os = CYGWIN_NT       if ($data =~ /OS_CYGWIN_NT/);\n$os = Interix         if ($data =~ /OS_INTERIX/);\n$os = Android         if ($data =~ /OS_ANDROID/);\n$os = Haiku           if ($data =~ /OS_HAIKU/);\n\n$architecture = x86          if ($data =~ /ARCH_X86/);\n$architecture = x86_64       if ($data =~ /ARCH_X86_64/);\n$architecture = e2k          if ($data =~ /ARCH_E2K/);\n$architecture = power        if ($data =~ /ARCH_POWER/);\n$architecture = mips         if ($data =~ /ARCH_MIPS/);\n$architecture = mips64       if ($data =~ /ARCH_MIPS64/);\n$architecture = alpha        if ($data =~ /ARCH_ALPHA/);\n$architecture = sparc        if ($data =~ /ARCH_SPARC/);\n$architecture = ia64         if ($data =~ /ARCH_IA64/);\n$architecture = arm          if ($data =~ /ARCH_ARM/);\n$architecture = arm64        if ($data =~ /ARCH_ARM64/);\n$architecture = zarch        if ($data =~ /ARCH_ZARCH/);\n$architecture = riscv64      if ($data =~ /ARCH_RISCV64/);\n$architecture = loongarch64  if ($data =~ /ARCH_LOONGARCH64/);\n$architecture = csky         if ($data =~ /ARCH_CSKY/);\n\n$defined = 0;\n\nif ($os eq \"AIX\") {\n    $compiler_name .= \" -maix32\" if ($binary eq \"32\");\n    $compiler_name .= \" -maix64\" if ($binary eq \"64\");\n    $defined = 1;\n}\n\nif ($architecture eq \"mips\") {\n    $compiler_name .= \" -mabi=32\";\n    $defined = 1;\n}\n\nif ($architecture eq \"mips64\") {\n    $compiler_name .= \" -mabi=n32\" if ($binary eq \"32\");\n    $compiler_name .= \" -mabi=64\" if ($binary eq \"64\");\n    $defined = 1;\n}\n\nif (($architecture eq \"arm\") || ($architecture eq \"arm64\")) {\n    $defined = 1;\n}\n\nif ($architecture eq \"zarch\") {\n    $defined = 1;\n    $binary = 64;\n}\n\nif ($architecture eq \"e2k\") {\n    $defined = 1;\n    $binary = 64;\n}\n\nif ($architecture eq \"alpha\") {\n    $defined = 1;\n    $binary = 64;\n}\n\nif ($architecture eq \"ia64\") {\n    $defined = 1;\n    $binary = 64;\n}\n\nif (($architecture eq \"x86\") && ($os ne Darwin) && ($os ne SunOS)) {\n    $defined = 1;\n    $binary =32;\n}\n\nif ($architecture eq \"riscv64\") {\n    $defined = 1;\n    $binary = 64;\n}\n\nif ($architecture eq \"loongarch64\") {\n    $defined = 1;\n    $binary = 64;\n}\n\nif ($architecture eq \"csky\") {\n    $defined = 1;\n    $binary = 32;\n}\n\nif ($compiler eq \"PGI\") {\n    $compiler_name .= \" -tp p7\"    if ($binary eq \"32\");\n    $compiler_name .= \" -tp p7-64\" if ($binary eq \"64\");\n    $openmp = \"-mp\";\n    $defined = 1;\n}\n\nif ($compiler eq \"IBM\") {\n    $compiler_name .= \" -q32\"  if ($binary eq \"32\");\n    $compiler_name .= \" -q64\"  if ($binary eq \"64\");\n    $openmp = \"-qsmp=omp\";\n    $defined = 1;\n}\n\nif ($compiler eq \"INTEL\") {\n    $openmp = \"-openmp\";\n}\n\nif ($compiler eq \"PATHSCALE\") {\n    $openmp = \"-mp\";\n}\n\nif ($compiler eq \"OPEN64\") {\n    $openmp = \"-mp\";\n}\n\nif ($compiler eq \"CLANG\") {\n    $openmp = \"-fopenmp\";\n}\n\nif ($compiler eq \"GCC\" || $compiler eq \"LSB\") {\n    $openmp = \"-fopenmp\";\n}\n\nif ($compiler eq \"FUJITSU\") {\n    $openmp = \"-Kopenmp\";\n}\n\nif ($defined == 0) {\n    $compiler_name .= \" -m32\" if ($binary eq \"32\");\n    $compiler_name .= \" -m64\" if ($binary eq \"64\");\n}\n\n# Do again\n\n$data = `$compiler_name $flags -E ctest.c`;\n\nif ($?) {\n    printf STDERR \"C Compiler ($compiler_name) is something wrong.\\n\";\n    die 1;\n}\n\n$have_msa = 0;\nif (($architecture eq \"mips\") || ($architecture eq \"mips64\")) {\n    eval \"use File::Temp qw(tempfile)\";\n    if ($@){ \n\twarn \"could not load PERL module File::Temp, so could not check MSA capatibility\";\n    } else {\n\t$tmpf = new File::Temp( SUFFIX => '.c' , UNLINK => 1 );\n\t$code = '\"addvi.b $w0, $w1, 1\"';\n\t$msa_flags = \"-mmsa -mfp64 -mload-store-pairs\";\n\tprint $tmpf \"#include <msa.h>\\n\\n\";\n\tprint $tmpf \"void main(void){ __asm__ volatile($code); }\\n\";\n\n\t$args = \"$msa_flags -o $tmpf.o $tmpf\";\n\tmy @cmd = (\"$compiler_name $flags $args >/dev/null 2>/dev/null\");\n\tsystem(@cmd) == 0;\n\tif ($? != 0) {\n\t    $have_msa = 0;\n\t} else {\n\t    $have_msa = 1;\n\t}\n\tunlink(\"$tmpf.o\");\n    }\n}\n\n$no_lsx = 0;\n$no_lasx = 0;\nif (($architecture eq \"loongarch64\")) {\n    eval \"use File::Temp qw(tempfile)\";\n    if ($@){\n\twarn \"could not load PERL module File::Temp, so could not check LSX and LASX capatibility\";\n    } else {\n\t$tmplsx = new File::Temp( SUFFIX => '.c' , UNLINK => 1 );\n\t$codelsx = '\"vadd.b $vr0, $vr0, $vr0\"';\n\t$lsx_flags = \"-march=loongarch64\";\n\tprint $tmplsx \"void main(void){ __asm__ volatile($codelsx); }\\n\";\n\n\t$args = \"$lsx_flags -o $tmplsx.o $tmplsx\";\n\tmy @cmd = (\"$compiler_name $flags $args >/dev/null 2>/dev/null\");\n\tsystem(@cmd) == 0;\n\tif ($? != 0) {\n\t    $no_lsx = 1;\n\t} else {\n\t    $no_lsx = 0;\n\t}\n\tunlink(\"$tmplsx.o\");\n\n\t$tmplasx = new File::Temp( SUFFIX => '.c' , UNLINK => 1 );\n\t$codelasx = '\"xvadd.b $xr0, $xr0, $xr0\"';\n\t$lasx_flags = \"-march=loongarch64\";\n\tprint $tmplasx \"void main(void){ __asm__ volatile($codelasx); }\\n\";\n\n\t$args = \"$lasx_flags -o $tmplasx.o $tmplasx\";\n\tmy @cmd = (\"$compiler_name $flags $args >/dev/null 2>/dev/null\");\n\tsystem(@cmd) == 0;\n\tif ($? != 0) {\n\t    $no_lasx = 1;\n\t} else {\n\t    $no_lasx = 0;\n\t}\n\tunlink(\"$tmplasx.o\");\n    }\n}\n\n$architecture = x86          if ($data =~ /ARCH_X86/);\n$architecture = x86_64       if ($data =~ /ARCH_X86_64/);\n$architecture = e2k          if ($data =~ /ARCH_E2K/);\n$architecture = power        if ($data =~ /ARCH_POWER/);\n$architecture = mips         if ($data =~ /ARCH_MIPS/);\n$architecture = mips64       if ($data =~ /ARCH_MIPS64/);\n$architecture = alpha        if ($data =~ /ARCH_ALPHA/);\n$architecture = sparc        if ($data =~ /ARCH_SPARC/);\n$architecture = ia64         if ($data =~ /ARCH_IA64/);\n$architecture = arm          if ($data =~ /ARCH_ARM/);\n$architecture = arm64        if ($data =~ /ARCH_ARM64/);\n$architecture = zarch        if ($data =~ /ARCH_ZARCH/);\n$architecture = loongarch64  if ($data =~ /ARCH_LOONGARCH64/);\n$architecture = csky         if ($data =~ /ARCH_CSKY/);\n\n$binformat    = bin32;\n$binformat    = bin64  if ($data =~ /BINARY_64/);\n\n$no_avx512= 0;\nif (($architecture eq \"x86\") || ($architecture eq \"x86_64\")) {\n    eval \"use File::Temp qw(tempfile)\";\n    if ($@){ \n\twarn \"could not load PERL module File::Temp, so could not check compiler compatibility with AVX512\";\n\t$no_avx512 = 0;\n    } else {\n#\t$tmpf = new File::Temp( UNLINK => 1 );\n\t($fh,$tmpf) = tempfile( SUFFIX => '.c' , UNLINK => 1 );\n\t$code = '\"vbroadcastss -4 * 4(%rsi), %zmm2\"';\n\tprint $fh \"#include <immintrin.h>\\n\\nint main(void){ __asm__ volatile($code); }\\n\";\n\t$args = \" -march=skylake-avx512 -c -o $tmpf.o $tmpf\";\n\tif ($compiler eq \"PGI\") {\n\t    $args = \" -tp skylake -c -o $tmpf.o $tmpf\";\n\t}\n\tmy @cmd = (\"$compiler_name $flags $args >/dev/null 2>/dev/null\");\n\tsystem(@cmd) == 0;\n\tif ($? != 0) {\n\t    $no_avx512 = 1;\n\t} else {\n\t    $no_avx512 = 0;\n\t}\n\tunlink(\"$tmpf.o\");\n    }\n}\n\n$no_rv64gv= 0;\nif (($architecture eq \"riscv64\")) {\n    eval \"use File::Temp qw(tempfile)\";\n    if ($@){ \n\twarn \"could not load PERL module File::Temp, so could not check compiler compatibility with the RISCV vector extension\";\n\t$no_rv64gv = 0;\n    } else {\n#\t$tmpf = new File::Temp( UNLINK => 1 );\n\t($fh,$tmpf) = tempfile( SUFFIX => '.c' , UNLINK => 1 );\n\t$code = '\"vsetvli    zero, zero, e8, m1\\n\"';\n\tprint $fh \"int main(void){ __asm__ volatile($code); }\\n\";\n\t$args = \" -march=rv64gv -c -o $tmpf.o $tmpf\";\n\tmy @cmd = (\"$compiler_name $flags $args >/dev/null 2>/dev/null\");\n\tsystem(@cmd) == 0;\n\tif ($? != 0) {\n\t    $no_rv64gv = 1;\n\t} else {\n\t    $no_rv64gv = 0;\n\t}\n\tunlink(\"$tmpf.o\");\n    }\n}\n\n$c11_atomics = 0;\nif ($data =~ /HAVE_C11/) {\n    eval \"use File::Temp qw(tempfile)\";\n    if ($@){ \n       warn \"could not load PERL module File::Temp, so could not check compiler compatibility with C11\";\n       $c11_atomics = 0;\n    } else {\n       ($fh,$tmpf) = tempfile( SUFFIX => '.c' , UNLINK => 1 );\n       print $fh \"#include <stdatomic.h>\\nint main(void){}\\n\";\n       $args = \" -c -o $tmpf.o $tmpf\";\n       my @cmd = (\"$compiler_name $flags $args >/dev/null 2>/dev/null\");\n       system(@cmd) == 0;\n       if ($? != 0) {\n           $c11_atomics = 0;\n       } else {\n           $c11_atomics = 1;\n       }\n       unlink(\"$tmpf.o\");\n    }\n}\n\nif ($compiler eq \"GCC\" &&( ($architecture eq \"x86\") || ($architecture eq \"x86_64\"))) {\n\t$no_avx2 = 0;\n\t$oldgcc = 0;\n\t$data = `$compiler_name -dumpversion`;\n\tif ($data <= 4.6) {\n\t\t$no_avx2 = 1;\n\t\t$oldgcc = 1;\n\t}\n}\n\n$data = `$compiler_name $flags -S ctest1.c && grep globl ctest1.s | head -n 1 && rm -f ctest1.s`;\n\n$data =~ /globl\\s([_\\.]*)(.*)/;\n\n$need_fu      = $1;\n\n$cross = 0;\n\nif ($architecture ne $hostarch) {\n    $cross = 1;\n    $cross = 0 if (($hostarch eq \"x86_64\") && ($architecture eq \"x86\"));\n    $cross = 0 if (($hostarch eq \"mips64\") && ($architecture eq \"mips\"));\n}\n\n$cross = 1 if ($os ne $hostos);\n$cross = 0 if (($os eq \"Android\") && ($hostos eq \"Linux\") && ($ENV{TERMUX_APP_PID} != \"\"));\n\n$openmp = \"\" if $ENV{USE_OPENMP} != 1;\n\n$linker_L = \"\";\n$linker_l = \"\";\n$linker_a = \"\";\n\n{\n    $link = `$compiler_name $flags -c ctest2.c -o ctest2.o 2>&1 && $compiler_name $flags $openmp -v ctest2.o -o ctest2 2>&1 && rm -f ctest2.o ctest2 ctest2.exe`;\n\n    $link =~ s/\\-Y\\sP\\,/\\-Y/g;\n\n    @flags = split(/[\\s\\,\\n]/, $link);\n    # remove leading and trailing quotes from each flag.\n    @flags = map {s/^['\"]|['\"]$//g; $_} @flags;\n\n    foreach $flags (@flags) {\n\tif (\n\t    ($flags =~ /^\\-L/)\n\t    && ($flags !~ /^-LIST:/)\n\t    && ($flags !~ /^-LANG:/)\n\t    ) {\n\t    $linker_L .= $flags . \" \"\n\t    }\n\n\tif ($flags =~ /^\\-Y/) {\n\t    $linker_L .= \"-Wl,\". $flags . \" \"\n\t    }\n\n\tif ($flags =~ /^\\--exclude-libs/) {\n\t    $linker_L .= \"-Wl,\". $flags . \" \";\n\t    $flags=\"\";\n\t   }\n\n\tif (\n\t    ($flags =~ /^\\-l/)\n\t    && ($flags !~ /gfortranbegin/)\n\t    && ($flags !~ /frtbegin/)\n\t    && ($flags !~ /pathfstart/)\n\t    && ($flags !~ /numa/)\n\t    && ($flags !~ /crt[0-9]/)\n\t    && ($flags !~ /gcc/)\n\t    && ($flags !~ /user32/)\n\t    && ($flags !~ /kernel32/)\n\t    && ($flags !~ /advapi32/)\n\t    && ($flags !~ /shell32/)\n\t    && ($flags !~ /omp/)\n\t    && ($flags !~ /[0-9]+/)\n\t    ) {\n\t    $linker_l .= $flags . \" \"\n\t}\n\n\t$linker_a .= $flags . \" \" if $flags =~ /\\.a$/;\n    }\n\n}\n\nopen(MAKEFILE, \"> $makefile\") || die \"Can't create $makefile\";\nopen(CONFFILE, \"> $config\"  ) || die \"Can't create $config\";\n\n# print $data, \"\\n\";\n\nprint MAKEFILE \"OSNAME=$os\\n\";\nprint MAKEFILE \"ARCH=$architecture\\n\";\nprint MAKEFILE \"C_COMPILER=$compiler\\n\";\nprint MAKEFILE \"BINARY32=\\n\" if $binformat ne bin32;\nprint MAKEFILE \"BINARY64=\\n\" if $binformat ne bin64;\nprint MAKEFILE \"BINARY32=1\\n\" if $binformat eq bin32;\nprint MAKEFILE \"BINARY64=1\\n\" if $binformat eq bin64;\nprint MAKEFILE \"FU=$need_fu\\n\" if $need_fu ne \"\";\nprint MAKEFILE \"CROSS_SUFFIX=$cross_suffix\\n\" if $cross != 0 && $cross_suffix ne \"\";\nprint MAKEFILE \"CROSS=1\\n\" if $cross != 0;\nprint MAKEFILE \"CEXTRALIB=$linker_L $linker_l $linker_a\\n\";\nprint MAKEFILE \"HAVE_MSA=1\\n\" if $have_msa eq 1;\nprint MAKEFILE \"MSA_FLAGS=$msa_flags\\n\" if $have_msa eq 1;\nprint MAKEFILE \"NO_RV64GV=1\\n\" if $no_rv64gv eq 1;\nprint MAKEFILE \"NO_AVX512=1\\n\" if $no_avx512 eq 1;\nprint MAKEFILE \"NO_AVX2=1\\n\" if $no_avx2 eq 1;\nprint MAKEFILE \"OLDGCC=1\\n\" if $oldgcc eq 1;\nprint MAKEFILE \"NO_LSX=1\\n\" if $no_lsx eq 1;\nprint MAKEFILE \"NO_LASX=1\\n\" if $no_lasx eq 1;\n\n$os           =~ tr/[a-z]/[A-Z]/;\n$architecture =~ tr/[a-z]/[A-Z]/;\n$compiler     =~ tr/[a-z]/[A-Z]/;\n\nprint CONFFILE \"#define OS_$os\\t1\\n\";\nprint CONFFILE \"#define ARCH_$architecture\\t1\\n\";\nprint CONFFILE \"#define C_$compiler\\t1\\n\";\nprint CONFFILE \"#define __32BIT__\\t1\\n\"  if $binformat eq bin32;\nprint CONFFILE \"#define __64BIT__\\t1\\n\"  if $binformat eq bin64;\nprint CONFFILE \"#define FUNDERSCORE\\t$need_fu\\n\" if $need_fu ne \"\";\nprint CONFFILE \"#define HAVE_MSA\\t1\\n\"  if $have_msa eq 1;\nprint CONFFILE \"#define HAVE_C11\\t1\\n\" if $c11_atomics eq 1;\nprint CONFFILE \"#define NO_LSX\\t1\\n\" if $no_lsx eq 1;\nprint CONFFILE \"#define NO_LASX\\t1\\n\" if $no_lasx eq 1;\n\n\nif ($os eq \"LINUX\") {\n\n#    @pthread = split(/\\s+/, `nm /lib/libpthread.so* | grep _pthread_create`);\n\n#    if ($pthread[2] ne \"\") {\n#\tprint CONFFILE \"#define PTHREAD_CREATE_FUNC\t$pthread[2]\\n\";\n#    } else {\n\tprint CONFFILE \"#define PTHREAD_CREATE_FUNC\tpthread_create\\n\";\n#    }\n} else {\n    print CONFFILE \"#define PTHREAD_CREATE_FUNC\tpthread_create\\n\";\n}\n\nclose(MAKEFILE);\nclose(CONFFILE);\n"
        },
        {
          "name": "cblas.h",
          "type": "blob",
          "size": 54.8232421875,
          "content": "#ifndef CBLAS_H\n#define CBLAS_H\n\n#include <stddef.h>\n#include \"common.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n\t/* Assume C declarations for C++ */\n#endif  /* __cplusplus */\n\n/*Set the number of threads on runtime.*/\nvoid openblas_set_num_threads(int num_threads);\nvoid goto_set_num_threads(int num_threads);\nint openblas_set_num_threads_local(int num_threads);\n\n/*Get the number of threads on runtime.*/\nint openblas_get_num_threads(void);\n\n/*Get the number of physical processors (cores).*/\nint openblas_get_num_procs(void);\n\n/*Get the build configure on runtime.*/\nchar* openblas_get_config(void);\n\n/*Get the CPU corename on runtime.*/\nchar* openblas_get_corename(void);\n\n/*Set the threading backend to a custom callback.*/\ntypedef void (*openblas_dojob_callback)(int thread_num, void *jobdata, int dojob_data);\ntypedef void (*openblas_threads_callback)(int sync, openblas_dojob_callback dojob, int numjobs, size_t jobdata_elsize, void *jobdata, int dojob_data);\nvoid openblas_set_threads_callback_function(openblas_threads_callback callback);\n\n#ifdef OPENBLAS_OS_LINUX\n/* Sets thread affinity for OpenBLAS threads. `thread_idx` is in [0, openblas_get_num_threads()-1]. */\nint openblas_setaffinity(int thread_idx, size_t cpusetsize, cpu_set_t* cpu_set);\n/* Queries thread affinity for OpenBLAS threads. `thread_idx` is in [0, openblas_get_num_threads()-1]. */\nint openblas_getaffinity(int thread_idx, size_t cpusetsize, cpu_set_t* cpu_set);\n#endif\n\n/* Get the parallelization type which is used by OpenBLAS */\nint openblas_get_parallel(void);\n/* OpenBLAS is compiled for sequential use  */\n#define OPENBLAS_SEQUENTIAL  0\n/* OpenBLAS is compiled using normal threading model */\n#define OPENBLAS_THREAD  1\n/* OpenBLAS is compiled using OpenMP threading model */\n#define OPENBLAS_OPENMP 2\n\n\n/*\n * Since all of GotoBlas was written without const,\n * we disable it at build time.\n */\n#ifndef OPENBLAS_CONST\n# define OPENBLAS_CONST const\n#endif\n\n\n#define CBLAS_INDEX size_t\n\ntypedef enum CBLAS_ORDER     {CblasRowMajor=101, CblasColMajor=102} CBLAS_ORDER;\ntypedef enum CBLAS_TRANSPOSE {CblasNoTrans=111, CblasTrans=112, CblasConjTrans=113, CblasConjNoTrans=114} CBLAS_TRANSPOSE;\ntypedef enum CBLAS_UPLO      {CblasUpper=121, CblasLower=122} CBLAS_UPLO;\ntypedef enum CBLAS_DIAG      {CblasNonUnit=131, CblasUnit=132} CBLAS_DIAG;\ntypedef enum CBLAS_SIDE      {CblasLeft=141, CblasRight=142} CBLAS_SIDE;\ntypedef CBLAS_ORDER CBLAS_LAYOUT;\n\t\nfloat  cblas_sdsdot(OPENBLAS_CONST blasint n, OPENBLAS_CONST float alpha, OPENBLAS_CONST float *x, OPENBLAS_CONST blasint incx, OPENBLAS_CONST float *y, OPENBLAS_CONST blasint incy);\ndouble cblas_dsdot (OPENBLAS_CONST blasint n, OPENBLAS_CONST float *x, OPENBLAS_CONST blasint incx, OPENBLAS_CONST float *y, OPENBLAS_CONST blasint incy);\nfloat  cblas_sdot(OPENBLAS_CONST blasint n, OPENBLAS_CONST float  *x, OPENBLAS_CONST blasint incx, OPENBLAS_CONST float  *y, OPENBLAS_CONST blasint incy);\ndouble cblas_ddot(OPENBLAS_CONST blasint n, OPENBLAS_CONST double *x, OPENBLAS_CONST blasint incx, OPENBLAS_CONST double *y, OPENBLAS_CONST blasint incy);\n\nopenblas_complex_float  cblas_cdotu(OPENBLAS_CONST blasint n, OPENBLAS_CONST void  *x, OPENBLAS_CONST blasint incx, OPENBLAS_CONST void  *y, OPENBLAS_CONST blasint incy);\nopenblas_complex_float  cblas_cdotc(OPENBLAS_CONST blasint n, OPENBLAS_CONST void  *x, OPENBLAS_CONST blasint incx, OPENBLAS_CONST void  *y, OPENBLAS_CONST blasint incy);\nopenblas_complex_double cblas_zdotu(OPENBLAS_CONST blasint n, OPENBLAS_CONST void *x, OPENBLAS_CONST blasint incx, OPENBLAS_CONST void *y, OPENBLAS_CONST blasint incy);\nopenblas_complex_double cblas_zdotc(OPENBLAS_CONST blasint n, OPENBLAS_CONST void *x, OPENBLAS_CONST blasint incx, OPENBLAS_CONST void *y, OPENBLAS_CONST blasint incy);\n\nvoid  cblas_cdotu_sub(OPENBLAS_CONST blasint n, OPENBLAS_CONST void  *x, OPENBLAS_CONST blasint incx, OPENBLAS_CONST void  *y, OPENBLAS_CONST blasint incy, void  *ret);\nvoid  cblas_cdotc_sub(OPENBLAS_CONST blasint n, OPENBLAS_CONST void  *x, OPENBLAS_CONST blasint incx, OPENBLAS_CONST void  *y, OPENBLAS_CONST blasint incy, void  *ret);\nvoid  cblas_zdotu_sub(OPENBLAS_CONST blasint n, OPENBLAS_CONST void *x, OPENBLAS_CONST blasint incx, OPENBLAS_CONST void *y, OPENBLAS_CONST blasint incy, void *ret);\nvoid  cblas_zdotc_sub(OPENBLAS_CONST blasint n, OPENBLAS_CONST void *x, OPENBLAS_CONST blasint incx, OPENBLAS_CONST void *y, OPENBLAS_CONST blasint incy, void *ret);\n\nfloat  cblas_sasum (OPENBLAS_CONST blasint n, OPENBLAS_CONST float  *x, OPENBLAS_CONST blasint incx);\ndouble cblas_dasum (OPENBLAS_CONST blasint n, OPENBLAS_CONST double *x, OPENBLAS_CONST blasint incx);\nfloat  cblas_scasum(OPENBLAS_CONST blasint n, OPENBLAS_CONST void  *x, OPENBLAS_CONST blasint incx);\ndouble cblas_dzasum(OPENBLAS_CONST blasint n, OPENBLAS_CONST void *x, OPENBLAS_CONST blasint incx);\n\nfloat  cblas_ssum (OPENBLAS_CONST blasint n, OPENBLAS_CONST float  *x, OPENBLAS_CONST blasint incx);\ndouble cblas_dsum (OPENBLAS_CONST blasint n, OPENBLAS_CONST double *x, OPENBLAS_CONST blasint incx);\nfloat  cblas_scsum(OPENBLAS_CONST blasint n, OPENBLAS_CONST void  *x, OPENBLAS_CONST blasint incx);\ndouble cblas_dzsum(OPENBLAS_CONST blasint n, OPENBLAS_CONST void *x, OPENBLAS_CONST blasint incx);\n\nfloat  cblas_snrm2 (OPENBLAS_CONST blasint N, OPENBLAS_CONST float  *X, OPENBLAS_CONST blasint incX);\ndouble cblas_dnrm2 (OPENBLAS_CONST blasint N, OPENBLAS_CONST double *X, OPENBLAS_CONST blasint incX);\nfloat  cblas_scnrm2(OPENBLAS_CONST blasint N, OPENBLAS_CONST void  *X, OPENBLAS_CONST blasint incX);\ndouble cblas_dznrm2(OPENBLAS_CONST blasint N, OPENBLAS_CONST void *X, OPENBLAS_CONST blasint incX);\n\nCBLAS_INDEX cblas_isamax(OPENBLAS_CONST blasint n, OPENBLAS_CONST float  *x, OPENBLAS_CONST blasint incx);\nCBLAS_INDEX cblas_idamax(OPENBLAS_CONST blasint n, OPENBLAS_CONST double *x, OPENBLAS_CONST blasint incx);\nCBLAS_INDEX cblas_icamax(OPENBLAS_CONST blasint n, OPENBLAS_CONST void  *x, OPENBLAS_CONST blasint incx);\nCBLAS_INDEX cblas_izamax(OPENBLAS_CONST blasint n, OPENBLAS_CONST void *x, OPENBLAS_CONST blasint incx);\n\nCBLAS_INDEX cblas_isamin(OPENBLAS_CONST blasint n, OPENBLAS_CONST float  *x, OPENBLAS_CONST blasint incx);\nCBLAS_INDEX cblas_idamin(OPENBLAS_CONST blasint n, OPENBLAS_CONST double *x, OPENBLAS_CONST blasint incx);\nCBLAS_INDEX cblas_icamin(OPENBLAS_CONST blasint n, OPENBLAS_CONST void  *x, OPENBLAS_CONST blasint incx);\nCBLAS_INDEX cblas_izamin(OPENBLAS_CONST blasint n, OPENBLAS_CONST void *x, OPENBLAS_CONST blasint incx);\n\nfloat cblas_samax(OPENBLAS_CONST blasint n, OPENBLAS_CONST float  *x, OPENBLAS_CONST blasint incx);\ndouble cblas_damax(OPENBLAS_CONST blasint n, OPENBLAS_CONST double *x, OPENBLAS_CONST blasint incx);\nfloat cblas_scamax(OPENBLAS_CONST blasint n, OPENBLAS_CONST void  *x, OPENBLAS_CONST blasint incx);\ndouble cblas_dzamax(OPENBLAS_CONST blasint n, OPENBLAS_CONST void *x, OPENBLAS_CONST blasint incx);\n\nfloat cblas_samin(OPENBLAS_CONST blasint n, OPENBLAS_CONST float  *x, OPENBLAS_CONST blasint incx);\ndouble cblas_damin(OPENBLAS_CONST blasint n, OPENBLAS_CONST double *x, OPENBLAS_CONST blasint incx);\nfloat cblas_scamin(OPENBLAS_CONST blasint n, OPENBLAS_CONST void  *x, OPENBLAS_CONST blasint incx);\ndouble cblas_dzamin(OPENBLAS_CONST blasint n, OPENBLAS_CONST void *x, OPENBLAS_CONST blasint incx);\n\nCBLAS_INDEX cblas_ismax(OPENBLAS_CONST blasint n, OPENBLAS_CONST float  *x, OPENBLAS_CONST blasint incx);\nCBLAS_INDEX cblas_idmax(OPENBLAS_CONST blasint n, OPENBLAS_CONST double *x, OPENBLAS_CONST blasint incx);\nCBLAS_INDEX cblas_icmax(OPENBLAS_CONST blasint n, OPENBLAS_CONST void  *x, OPENBLAS_CONST blasint incx);\nCBLAS_INDEX cblas_izmax(OPENBLAS_CONST blasint n, OPENBLAS_CONST void *x, OPENBLAS_CONST blasint incx);\n\nCBLAS_INDEX cblas_ismin(OPENBLAS_CONST blasint n, OPENBLAS_CONST float  *x, OPENBLAS_CONST blasint incx);\nCBLAS_INDEX cblas_idmin(OPENBLAS_CONST blasint n, OPENBLAS_CONST double *x, OPENBLAS_CONST blasint incx);\nCBLAS_INDEX cblas_icmin(OPENBLAS_CONST blasint n, OPENBLAS_CONST void  *x, OPENBLAS_CONST blasint incx);\nCBLAS_INDEX cblas_izmin(OPENBLAS_CONST blasint n, OPENBLAS_CONST void *x, OPENBLAS_CONST blasint incx);\n\nvoid cblas_saxpy(OPENBLAS_CONST blasint n, OPENBLAS_CONST float alpha, OPENBLAS_CONST float *x, OPENBLAS_CONST blasint incx, float *y, OPENBLAS_CONST blasint incy);\nvoid cblas_daxpy(OPENBLAS_CONST blasint n, OPENBLAS_CONST double alpha, OPENBLAS_CONST double *x, OPENBLAS_CONST blasint incx, double *y, OPENBLAS_CONST blasint incy);\nvoid cblas_caxpy(OPENBLAS_CONST blasint n, OPENBLAS_CONST void *alpha, OPENBLAS_CONST void *x, OPENBLAS_CONST blasint incx, void *y, OPENBLAS_CONST blasint incy);\nvoid cblas_zaxpy(OPENBLAS_CONST blasint n, OPENBLAS_CONST void *alpha, OPENBLAS_CONST void *x, OPENBLAS_CONST blasint incx, void *y, OPENBLAS_CONST blasint incy);\n\nvoid cblas_caxpyc(OPENBLAS_CONST blasint n, OPENBLAS_CONST void *alpha, OPENBLAS_CONST void *x, OPENBLAS_CONST blasint incx, void *y, OPENBLAS_CONST blasint incy);\nvoid cblas_zaxpyc(OPENBLAS_CONST blasint n, OPENBLAS_CONST void *alpha, OPENBLAS_CONST void *x, OPENBLAS_CONST blasint incx, void *y, OPENBLAS_CONST blasint incy);\n\nvoid cblas_scopy(OPENBLAS_CONST blasint n, OPENBLAS_CONST float *x, OPENBLAS_CONST blasint incx, float *y, OPENBLAS_CONST blasint incy);\nvoid cblas_dcopy(OPENBLAS_CONST blasint n, OPENBLAS_CONST double *x, OPENBLAS_CONST blasint incx, double *y, OPENBLAS_CONST blasint incy);\nvoid cblas_ccopy(OPENBLAS_CONST blasint n, OPENBLAS_CONST void *x, OPENBLAS_CONST blasint incx, void *y, OPENBLAS_CONST blasint incy);\nvoid cblas_zcopy(OPENBLAS_CONST blasint n, OPENBLAS_CONST void *x, OPENBLAS_CONST blasint incx, void *y, OPENBLAS_CONST blasint incy);\n\nvoid cblas_sswap(OPENBLAS_CONST blasint n, float *x, OPENBLAS_CONST blasint incx, float *y, OPENBLAS_CONST blasint incy);\nvoid cblas_dswap(OPENBLAS_CONST blasint n, double *x, OPENBLAS_CONST blasint incx, double *y, OPENBLAS_CONST blasint incy);\nvoid cblas_cswap(OPENBLAS_CONST blasint n, void *x, OPENBLAS_CONST blasint incx, void *y, OPENBLAS_CONST blasint incy);\nvoid cblas_zswap(OPENBLAS_CONST blasint n, void *x, OPENBLAS_CONST blasint incx, void *y, OPENBLAS_CONST blasint incy);\n\nvoid cblas_srot(OPENBLAS_CONST blasint N, float *X, OPENBLAS_CONST blasint incX, float *Y, OPENBLAS_CONST blasint incY, OPENBLAS_CONST float c, OPENBLAS_CONST float s);\nvoid cblas_drot(OPENBLAS_CONST blasint N, double *X, OPENBLAS_CONST blasint incX, double *Y, OPENBLAS_CONST blasint incY, OPENBLAS_CONST double c, OPENBLAS_CONST double  s);\nvoid cblas_csrot(OPENBLAS_CONST blasint n, OPENBLAS_CONST void *x, OPENBLAS_CONST blasint incx, void *y, OPENBLAS_CONST blasint incY, OPENBLAS_CONST float c, OPENBLAS_CONST float s);\nvoid cblas_zdrot(OPENBLAS_CONST blasint n, OPENBLAS_CONST void *x, OPENBLAS_CONST blasint incx, void *y, OPENBLAS_CONST blasint incY, OPENBLAS_CONST double c, OPENBLAS_CONST double s);\n\nvoid cblas_srotg(float *a, float *b, float *c, float *s);\nvoid cblas_drotg(double *a, double *b, double *c, double *s);\nvoid cblas_crotg(void *a, void *b, float *c, void *s);\nvoid cblas_zrotg(void *a, void *b, double *c, void *s);\n\n\nvoid cblas_srotm(OPENBLAS_CONST blasint N, float *X, OPENBLAS_CONST blasint incX, float *Y, OPENBLAS_CONST blasint incY, OPENBLAS_CONST float *P);\nvoid cblas_drotm(OPENBLAS_CONST blasint N, double *X, OPENBLAS_CONST blasint incX, double *Y, OPENBLAS_CONST blasint incY, OPENBLAS_CONST double *P);\n\nvoid cblas_srotmg(float *d1, float *d2, float *b1, OPENBLAS_CONST float b2, float *P);\nvoid cblas_drotmg(double *d1, double *d2, double *b1, OPENBLAS_CONST double b2, double *P);\n\nvoid cblas_sscal(OPENBLAS_CONST blasint N, OPENBLAS_CONST float alpha, float *X, OPENBLAS_CONST blasint incX);\nvoid cblas_dscal(OPENBLAS_CONST blasint N, OPENBLAS_CONST double alpha, double *X, OPENBLAS_CONST blasint incX);\nvoid cblas_cscal(OPENBLAS_CONST blasint N, OPENBLAS_CONST void *alpha, void *X, OPENBLAS_CONST blasint incX);\nvoid cblas_zscal(OPENBLAS_CONST blasint N, OPENBLAS_CONST void *alpha, void *X, OPENBLAS_CONST blasint incX);\nvoid cblas_csscal(OPENBLAS_CONST blasint N, OPENBLAS_CONST float alpha, void *X, OPENBLAS_CONST blasint incX);\nvoid cblas_zdscal(OPENBLAS_CONST blasint N, OPENBLAS_CONST double alpha, void *X, OPENBLAS_CONST blasint incX);\n\nvoid cblas_sgemv(OPENBLAS_CONST enum CBLAS_ORDER order,  OPENBLAS_CONST enum CBLAS_TRANSPOSE trans,  OPENBLAS_CONST blasint m, OPENBLAS_CONST blasint n,\n\t\t OPENBLAS_CONST float alpha, OPENBLAS_CONST float  *a, OPENBLAS_CONST blasint lda,  OPENBLAS_CONST float  *x, OPENBLAS_CONST blasint incx,  OPENBLAS_CONST float beta,  float  *y, OPENBLAS_CONST blasint incy);\nvoid cblas_dgemv(OPENBLAS_CONST enum CBLAS_ORDER order,  OPENBLAS_CONST enum CBLAS_TRANSPOSE trans,  OPENBLAS_CONST blasint m, OPENBLAS_CONST blasint n,\n\t\t OPENBLAS_CONST double alpha, OPENBLAS_CONST double  *a, OPENBLAS_CONST blasint lda,  OPENBLAS_CONST double  *x, OPENBLAS_CONST blasint incx,  OPENBLAS_CONST double beta,  double  *y, OPENBLAS_CONST blasint incy);\nvoid cblas_cgemv(OPENBLAS_CONST enum CBLAS_ORDER order,  OPENBLAS_CONST enum CBLAS_TRANSPOSE trans,  OPENBLAS_CONST blasint m, OPENBLAS_CONST blasint n,\n\t\t OPENBLAS_CONST void *alpha, OPENBLAS_CONST void  *a, OPENBLAS_CONST blasint lda,  OPENBLAS_CONST void  *x, OPENBLAS_CONST blasint incx,  OPENBLAS_CONST void *beta,  void  *y, OPENBLAS_CONST blasint incy);\nvoid cblas_zgemv(OPENBLAS_CONST enum CBLAS_ORDER order,  OPENBLAS_CONST enum CBLAS_TRANSPOSE trans,  OPENBLAS_CONST blasint m, OPENBLAS_CONST blasint n,\n\t\t OPENBLAS_CONST void *alpha, OPENBLAS_CONST void  *a, OPENBLAS_CONST blasint lda,  OPENBLAS_CONST void  *x, OPENBLAS_CONST blasint incx,  OPENBLAS_CONST void *beta,  void  *y, OPENBLAS_CONST blasint incy);\n\nvoid cblas_sger (OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST blasint M, OPENBLAS_CONST blasint N, OPENBLAS_CONST float   alpha, OPENBLAS_CONST float  *X, OPENBLAS_CONST blasint incX, OPENBLAS_CONST float  *Y, OPENBLAS_CONST blasint incY, float  *A, OPENBLAS_CONST blasint lda);\nvoid cblas_dger (OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST blasint M, OPENBLAS_CONST blasint N, OPENBLAS_CONST double  alpha, OPENBLAS_CONST double *X, OPENBLAS_CONST blasint incX, OPENBLAS_CONST double *Y, OPENBLAS_CONST blasint incY, double *A, OPENBLAS_CONST blasint lda);\nvoid cblas_cgeru(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST blasint M, OPENBLAS_CONST blasint N, OPENBLAS_CONST void  *alpha, OPENBLAS_CONST void  *X, OPENBLAS_CONST blasint incX, OPENBLAS_CONST void  *Y, OPENBLAS_CONST blasint incY, void  *A, OPENBLAS_CONST blasint lda);\nvoid cblas_cgerc(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST blasint M, OPENBLAS_CONST blasint N, OPENBLAS_CONST void  *alpha, OPENBLAS_CONST void  *X, OPENBLAS_CONST blasint incX, OPENBLAS_CONST void  *Y, OPENBLAS_CONST blasint incY, void  *A, OPENBLAS_CONST blasint lda);\nvoid cblas_zgeru(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST blasint M, OPENBLAS_CONST blasint N, OPENBLAS_CONST void *alpha, OPENBLAS_CONST void *X, OPENBLAS_CONST blasint incX, OPENBLAS_CONST void *Y, OPENBLAS_CONST blasint incY, void *A, OPENBLAS_CONST blasint lda);\nvoid cblas_zgerc(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST blasint M, OPENBLAS_CONST blasint N, OPENBLAS_CONST void *alpha, OPENBLAS_CONST void *X, OPENBLAS_CONST blasint incX, OPENBLAS_CONST void *Y, OPENBLAS_CONST blasint incY, void *A, OPENBLAS_CONST blasint lda);\n\nvoid cblas_strsv(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST enum CBLAS_TRANSPOSE TransA, OPENBLAS_CONST enum CBLAS_DIAG Diag, OPENBLAS_CONST blasint N, OPENBLAS_CONST float *A, OPENBLAS_CONST blasint lda, float *X, OPENBLAS_CONST blasint incX);\nvoid cblas_dtrsv(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST enum CBLAS_TRANSPOSE TransA, OPENBLAS_CONST enum CBLAS_DIAG Diag, OPENBLAS_CONST blasint N, OPENBLAS_CONST double *A, OPENBLAS_CONST blasint lda, double *X, OPENBLAS_CONST blasint incX);\nvoid cblas_ctrsv(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST enum CBLAS_TRANSPOSE TransA, OPENBLAS_CONST enum CBLAS_DIAG Diag, OPENBLAS_CONST blasint N, OPENBLAS_CONST void *A, OPENBLAS_CONST blasint lda, void *X, OPENBLAS_CONST blasint incX);\nvoid cblas_ztrsv(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST enum CBLAS_TRANSPOSE TransA, OPENBLAS_CONST enum CBLAS_DIAG Diag, OPENBLAS_CONST blasint N, OPENBLAS_CONST void *A, OPENBLAS_CONST blasint lda, void *X, OPENBLAS_CONST blasint incX);\n\nvoid cblas_strmv(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST enum CBLAS_TRANSPOSE TransA, OPENBLAS_CONST enum CBLAS_DIAG Diag, OPENBLAS_CONST blasint N, OPENBLAS_CONST float *A, OPENBLAS_CONST blasint lda, float *X, OPENBLAS_CONST blasint incX);\nvoid cblas_dtrmv(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST enum CBLAS_TRANSPOSE TransA, OPENBLAS_CONST enum CBLAS_DIAG Diag, OPENBLAS_CONST blasint N, OPENBLAS_CONST double *A, OPENBLAS_CONST blasint lda, double *X, OPENBLAS_CONST blasint incX);\nvoid cblas_ctrmv(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST enum CBLAS_TRANSPOSE TransA, OPENBLAS_CONST enum CBLAS_DIAG Diag, OPENBLAS_CONST blasint N, OPENBLAS_CONST void *A, OPENBLAS_CONST blasint lda, void *X, OPENBLAS_CONST blasint incX);\nvoid cblas_ztrmv(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST enum CBLAS_TRANSPOSE TransA, OPENBLAS_CONST enum CBLAS_DIAG Diag, OPENBLAS_CONST blasint N, OPENBLAS_CONST void *A, OPENBLAS_CONST blasint lda, void *X, OPENBLAS_CONST blasint incX);\n\nvoid cblas_ssyr(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST blasint N, OPENBLAS_CONST float alpha, OPENBLAS_CONST float *X, OPENBLAS_CONST blasint incX, float *A, OPENBLAS_CONST blasint lda);\nvoid cblas_dsyr(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST blasint N, OPENBLAS_CONST double alpha, OPENBLAS_CONST double *X, OPENBLAS_CONST blasint incX, double *A, OPENBLAS_CONST blasint lda);\nvoid cblas_cher(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST blasint N, OPENBLAS_CONST float alpha, OPENBLAS_CONST void *X, OPENBLAS_CONST blasint incX, void *A, OPENBLAS_CONST blasint lda);\nvoid cblas_zher(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST blasint N, OPENBLAS_CONST double alpha, OPENBLAS_CONST void *X, OPENBLAS_CONST blasint incX, void *A, OPENBLAS_CONST blasint lda);\n\nvoid cblas_ssyr2(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST enum CBLAS_UPLO Uplo,OPENBLAS_CONST blasint N, OPENBLAS_CONST float alpha, OPENBLAS_CONST float *X,\n                OPENBLAS_CONST blasint incX, OPENBLAS_CONST float *Y, OPENBLAS_CONST blasint incY, float *A, OPENBLAS_CONST blasint lda);\nvoid cblas_dsyr2(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST blasint N, OPENBLAS_CONST double alpha, OPENBLAS_CONST double *X,\n                OPENBLAS_CONST blasint incX, OPENBLAS_CONST double *Y, OPENBLAS_CONST blasint incY, double *A, OPENBLAS_CONST blasint lda);\nvoid cblas_cher2(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST blasint N, OPENBLAS_CONST void *alpha, OPENBLAS_CONST void *X, OPENBLAS_CONST blasint incX,\n                OPENBLAS_CONST void *Y, OPENBLAS_CONST blasint incY, void *A, OPENBLAS_CONST blasint lda);\nvoid cblas_zher2(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST blasint N, OPENBLAS_CONST void *alpha, OPENBLAS_CONST void *X, OPENBLAS_CONST blasint incX,\n                OPENBLAS_CONST void *Y, OPENBLAS_CONST blasint incY, void *A, OPENBLAS_CONST blasint lda);\n\nvoid cblas_sgbmv(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST enum CBLAS_TRANSPOSE TransA, OPENBLAS_CONST blasint M, OPENBLAS_CONST blasint N,\n                 OPENBLAS_CONST blasint KL, OPENBLAS_CONST blasint KU, OPENBLAS_CONST float alpha, OPENBLAS_CONST float *A, OPENBLAS_CONST blasint lda, OPENBLAS_CONST float *X, OPENBLAS_CONST blasint incX, OPENBLAS_CONST float beta, float *Y, OPENBLAS_CONST blasint incY);\nvoid cblas_dgbmv(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST enum CBLAS_TRANSPOSE TransA, OPENBLAS_CONST blasint M, OPENBLAS_CONST blasint N,\n                 OPENBLAS_CONST blasint KL, OPENBLAS_CONST blasint KU, OPENBLAS_CONST double alpha, OPENBLAS_CONST double *A, OPENBLAS_CONST blasint lda, OPENBLAS_CONST double *X, OPENBLAS_CONST blasint incX, OPENBLAS_CONST double beta, double *Y, OPENBLAS_CONST blasint incY);\nvoid cblas_cgbmv(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST enum CBLAS_TRANSPOSE TransA, OPENBLAS_CONST blasint M, OPENBLAS_CONST blasint N,\n                 OPENBLAS_CONST blasint KL, OPENBLAS_CONST blasint KU, OPENBLAS_CONST void *alpha, OPENBLAS_CONST void *A, OPENBLAS_CONST blasint lda, OPENBLAS_CONST void *X, OPENBLAS_CONST blasint incX, OPENBLAS_CONST void *beta, void *Y, OPENBLAS_CONST blasint incY);\nvoid cblas_zgbmv(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST enum CBLAS_TRANSPOSE TransA, OPENBLAS_CONST blasint M, OPENBLAS_CONST blasint N,\n                 OPENBLAS_CONST blasint KL, OPENBLAS_CONST blasint KU, OPENBLAS_CONST void *alpha, OPENBLAS_CONST void *A, OPENBLAS_CONST blasint lda, OPENBLAS_CONST void *X, OPENBLAS_CONST blasint incX, OPENBLAS_CONST void *beta, void *Y, OPENBLAS_CONST blasint incY);\n\nvoid cblas_ssbmv(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST blasint N, OPENBLAS_CONST blasint K, OPENBLAS_CONST float alpha, OPENBLAS_CONST float *A,\n                 OPENBLAS_CONST blasint lda, OPENBLAS_CONST float *X, OPENBLAS_CONST blasint incX, OPENBLAS_CONST float beta, float *Y, OPENBLAS_CONST blasint incY);\nvoid cblas_dsbmv(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST blasint N, OPENBLAS_CONST blasint K, OPENBLAS_CONST double alpha, OPENBLAS_CONST double *A,\n                 OPENBLAS_CONST blasint lda, OPENBLAS_CONST double *X, OPENBLAS_CONST blasint incX, OPENBLAS_CONST double beta, double *Y, OPENBLAS_CONST blasint incY);\n\n\nvoid cblas_stbmv(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST enum CBLAS_TRANSPOSE TransA, OPENBLAS_CONST enum CBLAS_DIAG Diag,\n                 OPENBLAS_CONST blasint N, OPENBLAS_CONST blasint K, OPENBLAS_CONST float *A, OPENBLAS_CONST blasint lda, float *X, OPENBLAS_CONST blasint incX);\nvoid cblas_dtbmv(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST enum CBLAS_TRANSPOSE TransA, OPENBLAS_CONST enum CBLAS_DIAG Diag,\n                 OPENBLAS_CONST blasint N, OPENBLAS_CONST blasint K, OPENBLAS_CONST double *A, OPENBLAS_CONST blasint lda, double *X, OPENBLAS_CONST blasint incX);\nvoid cblas_ctbmv(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST enum CBLAS_TRANSPOSE TransA, OPENBLAS_CONST enum CBLAS_DIAG Diag,\n                 OPENBLAS_CONST blasint N, OPENBLAS_CONST blasint K, OPENBLAS_CONST void *A, OPENBLAS_CONST blasint lda, void *X, OPENBLAS_CONST blasint incX);\nvoid cblas_ztbmv(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST enum CBLAS_TRANSPOSE TransA, OPENBLAS_CONST enum CBLAS_DIAG Diag,\n                 OPENBLAS_CONST blasint N, OPENBLAS_CONST blasint K, OPENBLAS_CONST void *A, OPENBLAS_CONST blasint lda, void *X, OPENBLAS_CONST blasint incX);\n\nvoid cblas_stbsv(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST enum CBLAS_TRANSPOSE TransA, OPENBLAS_CONST enum CBLAS_DIAG Diag,\n                 OPENBLAS_CONST blasint N, OPENBLAS_CONST blasint K, OPENBLAS_CONST float *A, OPENBLAS_CONST blasint lda, float *X, OPENBLAS_CONST blasint incX);\nvoid cblas_dtbsv(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST enum CBLAS_TRANSPOSE TransA, OPENBLAS_CONST enum CBLAS_DIAG Diag,\n                 OPENBLAS_CONST blasint N, OPENBLAS_CONST blasint K, OPENBLAS_CONST double *A, OPENBLAS_CONST blasint lda, double *X, OPENBLAS_CONST blasint incX);\nvoid cblas_ctbsv(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST enum CBLAS_TRANSPOSE TransA, OPENBLAS_CONST enum CBLAS_DIAG Diag,\n                 OPENBLAS_CONST blasint N, OPENBLAS_CONST blasint K, OPENBLAS_CONST void *A, OPENBLAS_CONST blasint lda, void *X, OPENBLAS_CONST blasint incX);\nvoid cblas_ztbsv(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST enum CBLAS_TRANSPOSE TransA, OPENBLAS_CONST enum CBLAS_DIAG Diag,\n                 OPENBLAS_CONST blasint N, OPENBLAS_CONST blasint K, OPENBLAS_CONST void *A, OPENBLAS_CONST blasint lda, void *X, OPENBLAS_CONST blasint incX);\n\nvoid cblas_stpmv(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST enum CBLAS_TRANSPOSE TransA, OPENBLAS_CONST enum CBLAS_DIAG Diag,\n                 OPENBLAS_CONST blasint N, OPENBLAS_CONST float *Ap, float *X, OPENBLAS_CONST blasint incX);\nvoid cblas_dtpmv(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST enum CBLAS_TRANSPOSE TransA, OPENBLAS_CONST enum CBLAS_DIAG Diag,\n                 OPENBLAS_CONST blasint N, OPENBLAS_CONST double *Ap, double *X, OPENBLAS_CONST blasint incX);\nvoid cblas_ctpmv(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST enum CBLAS_TRANSPOSE TransA, OPENBLAS_CONST enum CBLAS_DIAG Diag,\n                 OPENBLAS_CONST blasint N, OPENBLAS_CONST void *Ap, void *X, OPENBLAS_CONST blasint incX);\nvoid cblas_ztpmv(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST enum CBLAS_TRANSPOSE TransA, OPENBLAS_CONST enum CBLAS_DIAG Diag,\n                 OPENBLAS_CONST blasint N, OPENBLAS_CONST void *Ap, void *X, OPENBLAS_CONST blasint incX);\n\nvoid cblas_stpsv(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST enum CBLAS_TRANSPOSE TransA, OPENBLAS_CONST enum CBLAS_DIAG Diag,\n                 OPENBLAS_CONST blasint N, OPENBLAS_CONST float *Ap, float *X, OPENBLAS_CONST blasint incX);\nvoid cblas_dtpsv(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST enum CBLAS_TRANSPOSE TransA, OPENBLAS_CONST enum CBLAS_DIAG Diag,\n                 OPENBLAS_CONST blasint N, OPENBLAS_CONST double *Ap, double *X, OPENBLAS_CONST blasint incX);\nvoid cblas_ctpsv(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST enum CBLAS_TRANSPOSE TransA, OPENBLAS_CONST enum CBLAS_DIAG Diag,\n                 OPENBLAS_CONST blasint N, OPENBLAS_CONST void *Ap, void *X, OPENBLAS_CONST blasint incX);\nvoid cblas_ztpsv(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST enum CBLAS_TRANSPOSE TransA, OPENBLAS_CONST enum CBLAS_DIAG Diag,\n                 OPENBLAS_CONST blasint N, OPENBLAS_CONST void *Ap, void *X, OPENBLAS_CONST blasint incX);\n\nvoid cblas_ssymv(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST blasint N, OPENBLAS_CONST float alpha, OPENBLAS_CONST float *A,\n                 OPENBLAS_CONST blasint lda, OPENBLAS_CONST float *X, OPENBLAS_CONST blasint incX, OPENBLAS_CONST float beta, float *Y, OPENBLAS_CONST blasint incY);\nvoid cblas_dsymv(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST blasint N, OPENBLAS_CONST double alpha, OPENBLAS_CONST double *A,\n                 OPENBLAS_CONST blasint lda, OPENBLAS_CONST double *X, OPENBLAS_CONST blasint incX, OPENBLAS_CONST double beta, double *Y, OPENBLAS_CONST blasint incY);\nvoid cblas_chemv(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST blasint N, OPENBLAS_CONST void *alpha, OPENBLAS_CONST void *A,\n                 OPENBLAS_CONST blasint lda, OPENBLAS_CONST void *X, OPENBLAS_CONST blasint incX, OPENBLAS_CONST void *beta, void *Y, OPENBLAS_CONST blasint incY);\nvoid cblas_zhemv(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST blasint N, OPENBLAS_CONST void *alpha, OPENBLAS_CONST void *A,\n                 OPENBLAS_CONST blasint lda, OPENBLAS_CONST void *X, OPENBLAS_CONST blasint incX, OPENBLAS_CONST void *beta, void *Y, OPENBLAS_CONST blasint incY);\n\n\nvoid cblas_sspmv(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST blasint N, OPENBLAS_CONST float alpha, OPENBLAS_CONST float *Ap,\n                 OPENBLAS_CONST float *X, OPENBLAS_CONST blasint incX, OPENBLAS_CONST float beta, float *Y, OPENBLAS_CONST blasint incY);\nvoid cblas_dspmv(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST blasint N, OPENBLAS_CONST double alpha, OPENBLAS_CONST double *Ap,\n                 OPENBLAS_CONST double *X, OPENBLAS_CONST blasint incX, OPENBLAS_CONST double beta, double *Y, OPENBLAS_CONST blasint incY);\n\nvoid cblas_sspr(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST blasint N, OPENBLAS_CONST float alpha, OPENBLAS_CONST float *X, OPENBLAS_CONST blasint incX, float *Ap);\nvoid cblas_dspr(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST blasint N, OPENBLAS_CONST double alpha, OPENBLAS_CONST double *X, OPENBLAS_CONST blasint incX, double *Ap);\n\nvoid cblas_chpr(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST blasint N, OPENBLAS_CONST float alpha, OPENBLAS_CONST void *X, OPENBLAS_CONST blasint incX, void *A);\nvoid cblas_zhpr(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST blasint N, OPENBLAS_CONST double alpha, OPENBLAS_CONST void *X,OPENBLAS_CONST blasint incX, void *A);\n\nvoid cblas_sspr2(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST blasint N, OPENBLAS_CONST float alpha, OPENBLAS_CONST float *X, OPENBLAS_CONST blasint incX, OPENBLAS_CONST float *Y, OPENBLAS_CONST blasint incY, float *A);\nvoid cblas_dspr2(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST blasint N, OPENBLAS_CONST double alpha, OPENBLAS_CONST double *X, OPENBLAS_CONST blasint incX, OPENBLAS_CONST double *Y, OPENBLAS_CONST blasint incY, double *A);\nvoid cblas_chpr2(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST blasint N, OPENBLAS_CONST void *alpha, OPENBLAS_CONST void *X, OPENBLAS_CONST blasint incX, OPENBLAS_CONST void *Y, OPENBLAS_CONST blasint incY, void *Ap);\nvoid cblas_zhpr2(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST blasint N, OPENBLAS_CONST void *alpha, OPENBLAS_CONST void *X, OPENBLAS_CONST blasint incX, OPENBLAS_CONST void *Y, OPENBLAS_CONST blasint incY, void *Ap);\n\nvoid cblas_chbmv(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST blasint N, OPENBLAS_CONST blasint K,\n\t\t OPENBLAS_CONST void *alpha, OPENBLAS_CONST void *A, OPENBLAS_CONST blasint lda, OPENBLAS_CONST void *X, OPENBLAS_CONST blasint incX, OPENBLAS_CONST void *beta, void *Y, OPENBLAS_CONST blasint incY);\nvoid cblas_zhbmv(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST blasint N, OPENBLAS_CONST blasint K,\n\t\t OPENBLAS_CONST void *alpha, OPENBLAS_CONST void *A, OPENBLAS_CONST blasint lda, OPENBLAS_CONST void *X, OPENBLAS_CONST blasint incX, OPENBLAS_CONST void *beta, void *Y, OPENBLAS_CONST blasint incY);\n\nvoid cblas_chpmv(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST blasint N,\n\t\t OPENBLAS_CONST void *alpha, OPENBLAS_CONST void *Ap, OPENBLAS_CONST void *X, OPENBLAS_CONST blasint incX, OPENBLAS_CONST void *beta, void *Y, OPENBLAS_CONST blasint incY);\nvoid cblas_zhpmv(OPENBLAS_CONST enum CBLAS_ORDER order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST blasint N,\n\t\t OPENBLAS_CONST void *alpha, OPENBLAS_CONST void *Ap, OPENBLAS_CONST void *X, OPENBLAS_CONST blasint incX, OPENBLAS_CONST void *beta, void *Y, OPENBLAS_CONST blasint incY);\n\nvoid cblas_sgemm(OPENBLAS_CONST enum CBLAS_ORDER Order, OPENBLAS_CONST enum CBLAS_TRANSPOSE TransA, OPENBLAS_CONST enum CBLAS_TRANSPOSE TransB, OPENBLAS_CONST blasint M, OPENBLAS_CONST blasint N, OPENBLAS_CONST blasint K,\n\t\t OPENBLAS_CONST float alpha, OPENBLAS_CONST float *A, OPENBLAS_CONST blasint lda, OPENBLAS_CONST float *B, OPENBLAS_CONST blasint ldb, OPENBLAS_CONST float beta, float *C, OPENBLAS_CONST blasint ldc);\nvoid cblas_dgemm(OPENBLAS_CONST enum CBLAS_ORDER Order, OPENBLAS_CONST enum CBLAS_TRANSPOSE TransA, OPENBLAS_CONST enum CBLAS_TRANSPOSE TransB, OPENBLAS_CONST blasint M, OPENBLAS_CONST blasint N, OPENBLAS_CONST blasint K,\n\t\t OPENBLAS_CONST double alpha, OPENBLAS_CONST double *A, OPENBLAS_CONST blasint lda, OPENBLAS_CONST double *B, OPENBLAS_CONST blasint ldb, OPENBLAS_CONST double beta, double *C, OPENBLAS_CONST blasint ldc);\nvoid cblas_cgemm(OPENBLAS_CONST enum CBLAS_ORDER Order, OPENBLAS_CONST enum CBLAS_TRANSPOSE TransA, OPENBLAS_CONST enum CBLAS_TRANSPOSE TransB, OPENBLAS_CONST blasint M, OPENBLAS_CONST blasint N, OPENBLAS_CONST blasint K,\n\t\t OPENBLAS_CONST void *alpha, OPENBLAS_CONST void *A, OPENBLAS_CONST blasint lda, OPENBLAS_CONST void *B, OPENBLAS_CONST blasint ldb, OPENBLAS_CONST void *beta, void *C, OPENBLAS_CONST blasint ldc);\nvoid cblas_cgemm3m(OPENBLAS_CONST enum CBLAS_ORDER Order, OPENBLAS_CONST enum CBLAS_TRANSPOSE TransA, OPENBLAS_CONST enum CBLAS_TRANSPOSE TransB, OPENBLAS_CONST blasint M, OPENBLAS_CONST blasint N, OPENBLAS_CONST blasint K,\n\t\t OPENBLAS_CONST void *alpha, OPENBLAS_CONST void *A, OPENBLAS_CONST blasint lda, OPENBLAS_CONST void *B, OPENBLAS_CONST blasint ldb, OPENBLAS_CONST void *beta, void *C, OPENBLAS_CONST blasint ldc);\nvoid cblas_zgemm(OPENBLAS_CONST enum CBLAS_ORDER Order, OPENBLAS_CONST enum CBLAS_TRANSPOSE TransA, OPENBLAS_CONST enum CBLAS_TRANSPOSE TransB, OPENBLAS_CONST blasint M, OPENBLAS_CONST blasint N, OPENBLAS_CONST blasint K,\n\t\t OPENBLAS_CONST void *alpha, OPENBLAS_CONST void *A, OPENBLAS_CONST blasint lda, OPENBLAS_CONST void *B, OPENBLAS_CONST blasint ldb, OPENBLAS_CONST void *beta, void *C, OPENBLAS_CONST blasint ldc);\nvoid cblas_zgemm3m(OPENBLAS_CONST enum CBLAS_ORDER Order, OPENBLAS_CONST enum CBLAS_TRANSPOSE TransA, OPENBLAS_CONST enum CBLAS_TRANSPOSE TransB, OPENBLAS_CONST blasint M, OPENBLAS_CONST blasint N, OPENBLAS_CONST blasint K,\n\t\t OPENBLAS_CONST void *alpha, OPENBLAS_CONST void *A, OPENBLAS_CONST blasint lda, OPENBLAS_CONST void *B, OPENBLAS_CONST blasint ldb, OPENBLAS_CONST void *beta, void *C, OPENBLAS_CONST blasint ldc);\n\nvoid cblas_sgemmt(OPENBLAS_CONST enum CBLAS_ORDER Order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST enum CBLAS_TRANSPOSE TransA, OPENBLAS_CONST enum CBLAS_TRANSPOSE TransB, OPENBLAS_CONST blasint M, OPENBLAS_CONST blasint K,\n\t\t OPENBLAS_CONST float alpha, OPENBLAS_CONST float *A, OPENBLAS_CONST blasint lda, OPENBLAS_CONST float *B, OPENBLAS_CONST blasint ldb, OPENBLAS_CONST float beta, float *C, OPENBLAS_CONST blasint ldc);\nvoid cblas_dgemmt(OPENBLAS_CONST enum CBLAS_ORDER Order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST enum CBLAS_TRANSPOSE TransA, OPENBLAS_CONST enum CBLAS_TRANSPOSE TransB, OPENBLAS_CONST blasint M, OPENBLAS_CONST blasint K,\n\t\t OPENBLAS_CONST double alpha, OPENBLAS_CONST double *A, OPENBLAS_CONST blasint lda, OPENBLAS_CONST double *B, OPENBLAS_CONST blasint ldb, OPENBLAS_CONST double beta, double *C, OPENBLAS_CONST blasint ldc);\nvoid cblas_cgemmt(OPENBLAS_CONST enum CBLAS_ORDER Order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST enum CBLAS_TRANSPOSE TransA, OPENBLAS_CONST enum CBLAS_TRANSPOSE TransB, OPENBLAS_CONST blasint M, OPENBLAS_CONST blasint K,\n\t\t OPENBLAS_CONST void *alpha, OPENBLAS_CONST void *A, OPENBLAS_CONST blasint lda, OPENBLAS_CONST void *B, OPENBLAS_CONST blasint ldb, OPENBLAS_CONST void *beta, void *C, OPENBLAS_CONST blasint ldc);\nvoid cblas_zgemmt(OPENBLAS_CONST enum CBLAS_ORDER Order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST enum CBLAS_TRANSPOSE TransA, OPENBLAS_CONST enum CBLAS_TRANSPOSE TransB, OPENBLAS_CONST blasint M, OPENBLAS_CONST blasint K,\n\t\t OPENBLAS_CONST void *alpha, OPENBLAS_CONST void *A, OPENBLAS_CONST blasint lda, OPENBLAS_CONST void *B, OPENBLAS_CONST blasint ldb, OPENBLAS_CONST void *beta, void *C, OPENBLAS_CONST blasint ldc);\n\nvoid cblas_ssymm(OPENBLAS_CONST enum CBLAS_ORDER Order, OPENBLAS_CONST enum CBLAS_SIDE Side, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST blasint M, OPENBLAS_CONST blasint N,\n                 OPENBLAS_CONST float alpha, OPENBLAS_CONST float *A, OPENBLAS_CONST blasint lda, OPENBLAS_CONST float *B, OPENBLAS_CONST blasint ldb, OPENBLAS_CONST float beta, float *C, OPENBLAS_CONST blasint ldc);\nvoid cblas_dsymm(OPENBLAS_CONST enum CBLAS_ORDER Order, OPENBLAS_CONST enum CBLAS_SIDE Side, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST blasint M, OPENBLAS_CONST blasint N,\n                 OPENBLAS_CONST double alpha, OPENBLAS_CONST double *A, OPENBLAS_CONST blasint lda, OPENBLAS_CONST double *B, OPENBLAS_CONST blasint ldb, OPENBLAS_CONST double beta, double *C, OPENBLAS_CONST blasint ldc);\nvoid cblas_csymm(OPENBLAS_CONST enum CBLAS_ORDER Order, OPENBLAS_CONST enum CBLAS_SIDE Side, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST blasint M, OPENBLAS_CONST blasint N,\n                 OPENBLAS_CONST void *alpha, OPENBLAS_CONST void *A, OPENBLAS_CONST blasint lda, OPENBLAS_CONST void *B, OPENBLAS_CONST blasint ldb, OPENBLAS_CONST void *beta, void *C, OPENBLAS_CONST blasint ldc);\nvoid cblas_zsymm(OPENBLAS_CONST enum CBLAS_ORDER Order, OPENBLAS_CONST enum CBLAS_SIDE Side, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST blasint M, OPENBLAS_CONST blasint N,\n                 OPENBLAS_CONST void *alpha, OPENBLAS_CONST void *A, OPENBLAS_CONST blasint lda, OPENBLAS_CONST void *B, OPENBLAS_CONST blasint ldb, OPENBLAS_CONST void *beta, void *C, OPENBLAS_CONST blasint ldc);\n\nvoid cblas_ssyrk(OPENBLAS_CONST enum CBLAS_ORDER Order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST enum CBLAS_TRANSPOSE Trans,\n\t\t OPENBLAS_CONST blasint N, OPENBLAS_CONST blasint K, OPENBLAS_CONST float alpha, OPENBLAS_CONST float *A, OPENBLAS_CONST blasint lda, OPENBLAS_CONST float beta, float *C, OPENBLAS_CONST blasint ldc);\nvoid cblas_dsyrk(OPENBLAS_CONST enum CBLAS_ORDER Order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST enum CBLAS_TRANSPOSE Trans,\n\t\t OPENBLAS_CONST blasint N, OPENBLAS_CONST blasint K, OPENBLAS_CONST double alpha, OPENBLAS_CONST double *A, OPENBLAS_CONST blasint lda, OPENBLAS_CONST double beta, double *C, OPENBLAS_CONST blasint ldc);\nvoid cblas_csyrk(OPENBLAS_CONST enum CBLAS_ORDER Order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST enum CBLAS_TRANSPOSE Trans,\n\t\t OPENBLAS_CONST blasint N, OPENBLAS_CONST blasint K, OPENBLAS_CONST void *alpha, OPENBLAS_CONST void *A, OPENBLAS_CONST blasint lda, OPENBLAS_CONST void *beta, void *C, OPENBLAS_CONST blasint ldc);\nvoid cblas_zsyrk(OPENBLAS_CONST enum CBLAS_ORDER Order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST enum CBLAS_TRANSPOSE Trans,\n\t\t OPENBLAS_CONST blasint N, OPENBLAS_CONST blasint K, OPENBLAS_CONST void *alpha, OPENBLAS_CONST void *A, OPENBLAS_CONST blasint lda, OPENBLAS_CONST void *beta, void *C, OPENBLAS_CONST blasint ldc);\n\nvoid cblas_ssyr2k(OPENBLAS_CONST enum CBLAS_ORDER Order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST enum CBLAS_TRANSPOSE Trans,\n\t\t  OPENBLAS_CONST blasint N, OPENBLAS_CONST blasint K, OPENBLAS_CONST float alpha, OPENBLAS_CONST float *A, OPENBLAS_CONST blasint lda, OPENBLAS_CONST float *B, OPENBLAS_CONST blasint ldb, OPENBLAS_CONST float beta, float *C, OPENBLAS_CONST blasint ldc);\nvoid cblas_dsyr2k(OPENBLAS_CONST enum CBLAS_ORDER Order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST enum CBLAS_TRANSPOSE Trans,\n\t\t  OPENBLAS_CONST blasint N, OPENBLAS_CONST blasint K, OPENBLAS_CONST double alpha, OPENBLAS_CONST double *A, OPENBLAS_CONST blasint lda, OPENBLAS_CONST double *B, OPENBLAS_CONST blasint ldb, OPENBLAS_CONST double beta, double *C, OPENBLAS_CONST blasint ldc);\nvoid cblas_csyr2k(OPENBLAS_CONST enum CBLAS_ORDER Order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST enum CBLAS_TRANSPOSE Trans,\n\t\t  OPENBLAS_CONST blasint N, OPENBLAS_CONST blasint K, OPENBLAS_CONST void *alpha, OPENBLAS_CONST void *A, OPENBLAS_CONST blasint lda, OPENBLAS_CONST void *B, OPENBLAS_CONST blasint ldb, OPENBLAS_CONST void *beta, void *C, OPENBLAS_CONST blasint ldc);\nvoid cblas_zsyr2k(OPENBLAS_CONST enum CBLAS_ORDER Order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST enum CBLAS_TRANSPOSE Trans,\n\t\t  OPENBLAS_CONST blasint N, OPENBLAS_CONST blasint K, OPENBLAS_CONST void *alpha, OPENBLAS_CONST void *A, OPENBLAS_CONST blasint lda, OPENBLAS_CONST void *B, OPENBLAS_CONST blasint ldb, OPENBLAS_CONST void *beta, void *C, OPENBLAS_CONST blasint ldc);\n\nvoid cblas_strmm(OPENBLAS_CONST enum CBLAS_ORDER Order, OPENBLAS_CONST enum CBLAS_SIDE Side, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST enum CBLAS_TRANSPOSE TransA,\n                 OPENBLAS_CONST enum CBLAS_DIAG Diag, OPENBLAS_CONST blasint M, OPENBLAS_CONST blasint N, OPENBLAS_CONST float alpha, OPENBLAS_CONST float *A, OPENBLAS_CONST blasint lda, float *B, OPENBLAS_CONST blasint ldb);\nvoid cblas_dtrmm(OPENBLAS_CONST enum CBLAS_ORDER Order, OPENBLAS_CONST enum CBLAS_SIDE Side, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST enum CBLAS_TRANSPOSE TransA,\n                 OPENBLAS_CONST enum CBLAS_DIAG Diag, OPENBLAS_CONST blasint M, OPENBLAS_CONST blasint N, OPENBLAS_CONST double alpha, OPENBLAS_CONST double *A, OPENBLAS_CONST blasint lda, double *B, OPENBLAS_CONST blasint ldb);\nvoid cblas_ctrmm(OPENBLAS_CONST enum CBLAS_ORDER Order, OPENBLAS_CONST enum CBLAS_SIDE Side, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST enum CBLAS_TRANSPOSE TransA,\n                 OPENBLAS_CONST enum CBLAS_DIAG Diag, OPENBLAS_CONST blasint M, OPENBLAS_CONST blasint N, OPENBLAS_CONST void *alpha, OPENBLAS_CONST void *A, OPENBLAS_CONST blasint lda, void *B, OPENBLAS_CONST blasint ldb);\nvoid cblas_ztrmm(OPENBLAS_CONST enum CBLAS_ORDER Order, OPENBLAS_CONST enum CBLAS_SIDE Side, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST enum CBLAS_TRANSPOSE TransA,\n                 OPENBLAS_CONST enum CBLAS_DIAG Diag, OPENBLAS_CONST blasint M, OPENBLAS_CONST blasint N, OPENBLAS_CONST void *alpha, OPENBLAS_CONST void *A, OPENBLAS_CONST blasint lda, void *B, OPENBLAS_CONST blasint ldb);\n\nvoid cblas_strsm(OPENBLAS_CONST enum CBLAS_ORDER Order, OPENBLAS_CONST enum CBLAS_SIDE Side, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST enum CBLAS_TRANSPOSE TransA,\n                 OPENBLAS_CONST enum CBLAS_DIAG Diag, OPENBLAS_CONST blasint M, OPENBLAS_CONST blasint N, OPENBLAS_CONST float alpha, OPENBLAS_CONST float *A, OPENBLAS_CONST blasint lda, float *B, OPENBLAS_CONST blasint ldb);\nvoid cblas_dtrsm(OPENBLAS_CONST enum CBLAS_ORDER Order, OPENBLAS_CONST enum CBLAS_SIDE Side, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST enum CBLAS_TRANSPOSE TransA,\n                 OPENBLAS_CONST enum CBLAS_DIAG Diag, OPENBLAS_CONST blasint M, OPENBLAS_CONST blasint N, OPENBLAS_CONST double alpha, OPENBLAS_CONST double *A, OPENBLAS_CONST blasint lda, double *B, OPENBLAS_CONST blasint ldb);\nvoid cblas_ctrsm(OPENBLAS_CONST enum CBLAS_ORDER Order, OPENBLAS_CONST enum CBLAS_SIDE Side, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST enum CBLAS_TRANSPOSE TransA,\n                 OPENBLAS_CONST enum CBLAS_DIAG Diag, OPENBLAS_CONST blasint M, OPENBLAS_CONST blasint N, OPENBLAS_CONST void *alpha, OPENBLAS_CONST void *A, OPENBLAS_CONST blasint lda, void *B, OPENBLAS_CONST blasint ldb);\nvoid cblas_ztrsm(OPENBLAS_CONST enum CBLAS_ORDER Order, OPENBLAS_CONST enum CBLAS_SIDE Side, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST enum CBLAS_TRANSPOSE TransA,\n                 OPENBLAS_CONST enum CBLAS_DIAG Diag, OPENBLAS_CONST blasint M, OPENBLAS_CONST blasint N, OPENBLAS_CONST void *alpha, OPENBLAS_CONST void *A, OPENBLAS_CONST blasint lda, void *B, OPENBLAS_CONST blasint ldb);\n\nvoid cblas_chemm(OPENBLAS_CONST enum CBLAS_ORDER Order, OPENBLAS_CONST enum CBLAS_SIDE Side, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST blasint M, OPENBLAS_CONST blasint N,\n                 OPENBLAS_CONST void *alpha, OPENBLAS_CONST void *A, OPENBLAS_CONST blasint lda, OPENBLAS_CONST void *B, OPENBLAS_CONST blasint ldb, OPENBLAS_CONST void *beta, void *C, OPENBLAS_CONST blasint ldc);\nvoid cblas_zhemm(OPENBLAS_CONST enum CBLAS_ORDER Order, OPENBLAS_CONST enum CBLAS_SIDE Side, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST blasint M, OPENBLAS_CONST blasint N,\n                 OPENBLAS_CONST void *alpha, OPENBLAS_CONST void *A, OPENBLAS_CONST blasint lda, OPENBLAS_CONST void *B, OPENBLAS_CONST blasint ldb, OPENBLAS_CONST void *beta, void *C, OPENBLAS_CONST blasint ldc);\n\nvoid cblas_cherk(OPENBLAS_CONST enum CBLAS_ORDER Order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST enum CBLAS_TRANSPOSE Trans, OPENBLAS_CONST blasint N, OPENBLAS_CONST blasint K,\n                 OPENBLAS_CONST float alpha, OPENBLAS_CONST void *A, OPENBLAS_CONST blasint lda, OPENBLAS_CONST float beta, void *C, OPENBLAS_CONST blasint ldc);\nvoid cblas_zherk(OPENBLAS_CONST enum CBLAS_ORDER Order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST enum CBLAS_TRANSPOSE Trans, OPENBLAS_CONST blasint N, OPENBLAS_CONST blasint K,\n                 OPENBLAS_CONST double alpha, OPENBLAS_CONST void *A, OPENBLAS_CONST blasint lda, OPENBLAS_CONST double beta, void *C, OPENBLAS_CONST blasint ldc);\n\nvoid cblas_cher2k(OPENBLAS_CONST enum CBLAS_ORDER Order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST enum CBLAS_TRANSPOSE Trans, OPENBLAS_CONST blasint N, OPENBLAS_CONST blasint K,\n                  OPENBLAS_CONST void *alpha, OPENBLAS_CONST void *A, OPENBLAS_CONST blasint lda, OPENBLAS_CONST void *B, OPENBLAS_CONST blasint ldb, OPENBLAS_CONST float beta, void *C, OPENBLAS_CONST blasint ldc);\nvoid cblas_zher2k(OPENBLAS_CONST enum CBLAS_ORDER Order, OPENBLAS_CONST enum CBLAS_UPLO Uplo, OPENBLAS_CONST enum CBLAS_TRANSPOSE Trans, OPENBLAS_CONST blasint N, OPENBLAS_CONST blasint K,\n                  OPENBLAS_CONST void *alpha, OPENBLAS_CONST void *A, OPENBLAS_CONST blasint lda, OPENBLAS_CONST void *B, OPENBLAS_CONST blasint ldb, OPENBLAS_CONST double beta, void *C, OPENBLAS_CONST blasint ldc);\n\nvoid cblas_xerbla(blasint p, OPENBLAS_CONST char *rout, OPENBLAS_CONST char *form, ...);\n\n/*** BLAS extensions ***/\n\nvoid cblas_saxpby(OPENBLAS_CONST blasint n, OPENBLAS_CONST float alpha, OPENBLAS_CONST float *x, OPENBLAS_CONST blasint incx,OPENBLAS_CONST float beta, float *y, OPENBLAS_CONST blasint incy);\n\nvoid cblas_daxpby(OPENBLAS_CONST blasint n, OPENBLAS_CONST double alpha, OPENBLAS_CONST double *x, OPENBLAS_CONST blasint incx,OPENBLAS_CONST double beta, double *y, OPENBLAS_CONST blasint incy);\n\nvoid cblas_caxpby(OPENBLAS_CONST blasint n, OPENBLAS_CONST void *alpha, OPENBLAS_CONST void *x, OPENBLAS_CONST blasint incx,OPENBLAS_CONST void *beta, void *y, OPENBLAS_CONST blasint incy);\n\nvoid cblas_zaxpby(OPENBLAS_CONST blasint n, OPENBLAS_CONST void *alpha, OPENBLAS_CONST void *x, OPENBLAS_CONST blasint incx,OPENBLAS_CONST void *beta, void *y, OPENBLAS_CONST blasint incy);\n\nvoid cblas_somatcopy(OPENBLAS_CONST enum CBLAS_ORDER CORDER, OPENBLAS_CONST enum CBLAS_TRANSPOSE CTRANS, OPENBLAS_CONST blasint crows, OPENBLAS_CONST blasint ccols, OPENBLAS_CONST float calpha, OPENBLAS_CONST float *a, \n\t\t     OPENBLAS_CONST blasint clda, float *b, OPENBLAS_CONST blasint cldb); \nvoid cblas_domatcopy(OPENBLAS_CONST enum CBLAS_ORDER CORDER, OPENBLAS_CONST enum CBLAS_TRANSPOSE CTRANS, OPENBLAS_CONST blasint crows, OPENBLAS_CONST blasint ccols, OPENBLAS_CONST double calpha, OPENBLAS_CONST double *a,\n\t\t     OPENBLAS_CONST blasint clda, double *b, OPENBLAS_CONST blasint cldb); \nvoid cblas_comatcopy(OPENBLAS_CONST enum CBLAS_ORDER CORDER, OPENBLAS_CONST enum CBLAS_TRANSPOSE CTRANS, OPENBLAS_CONST blasint crows, OPENBLAS_CONST blasint ccols, OPENBLAS_CONST float* calpha, OPENBLAS_CONST float* a, \n\t\t     OPENBLAS_CONST blasint clda, float*b, OPENBLAS_CONST blasint cldb); \nvoid cblas_zomatcopy(OPENBLAS_CONST enum CBLAS_ORDER CORDER, OPENBLAS_CONST enum CBLAS_TRANSPOSE CTRANS, OPENBLAS_CONST blasint crows, OPENBLAS_CONST blasint ccols, OPENBLAS_CONST double* calpha, OPENBLAS_CONST double* a, \n\t\t     OPENBLAS_CONST blasint clda,  double *b, OPENBLAS_CONST blasint cldb); \n\nvoid cblas_simatcopy(OPENBLAS_CONST enum CBLAS_ORDER CORDER, OPENBLAS_CONST enum CBLAS_TRANSPOSE CTRANS, OPENBLAS_CONST blasint crows, OPENBLAS_CONST blasint ccols, OPENBLAS_CONST float calpha, float *a, \n\t\t     OPENBLAS_CONST blasint clda, OPENBLAS_CONST blasint cldb); \nvoid cblas_dimatcopy(OPENBLAS_CONST enum CBLAS_ORDER CORDER, OPENBLAS_CONST enum CBLAS_TRANSPOSE CTRANS, OPENBLAS_CONST blasint crows, OPENBLAS_CONST blasint ccols, OPENBLAS_CONST double calpha, double *a,\n\t\t     OPENBLAS_CONST blasint clda, OPENBLAS_CONST blasint cldb); \nvoid cblas_cimatcopy(OPENBLAS_CONST enum CBLAS_ORDER CORDER, OPENBLAS_CONST enum CBLAS_TRANSPOSE CTRANS, OPENBLAS_CONST blasint crows, OPENBLAS_CONST blasint ccols, OPENBLAS_CONST float* calpha, float* a, \n\t\t     OPENBLAS_CONST blasint clda, OPENBLAS_CONST blasint cldb); \nvoid cblas_zimatcopy(OPENBLAS_CONST enum CBLAS_ORDER CORDER, OPENBLAS_CONST enum CBLAS_TRANSPOSE CTRANS, OPENBLAS_CONST blasint crows, OPENBLAS_CONST blasint ccols, OPENBLAS_CONST double* calpha, double* a, \n\t\t     OPENBLAS_CONST blasint clda, OPENBLAS_CONST blasint cldb); \n\nvoid cblas_sgeadd(OPENBLAS_CONST enum CBLAS_ORDER CORDER,OPENBLAS_CONST blasint crows, OPENBLAS_CONST blasint ccols, OPENBLAS_CONST float calpha, OPENBLAS_CONST float *a, OPENBLAS_CONST blasint clda, OPENBLAS_CONST float cbeta, \n\t\t  float *c, OPENBLAS_CONST blasint cldc); \nvoid cblas_dgeadd(OPENBLAS_CONST enum CBLAS_ORDER CORDER,OPENBLAS_CONST blasint crows, OPENBLAS_CONST blasint ccols, OPENBLAS_CONST double calpha, OPENBLAS_CONST double *a, OPENBLAS_CONST blasint clda, OPENBLAS_CONST double cbeta, \n\t\t  double *c, OPENBLAS_CONST blasint cldc); \nvoid cblas_cgeadd(OPENBLAS_CONST enum CBLAS_ORDER CORDER,OPENBLAS_CONST blasint crows, OPENBLAS_CONST blasint ccols, OPENBLAS_CONST float *calpha, OPENBLAS_CONST float *a, OPENBLAS_CONST blasint clda, OPENBLAS_CONST float *cbeta, \n\t\t  float *c, OPENBLAS_CONST blasint cldc); \nvoid cblas_zgeadd(OPENBLAS_CONST enum CBLAS_ORDER CORDER,OPENBLAS_CONST blasint crows, OPENBLAS_CONST blasint ccols, OPENBLAS_CONST double *calpha, OPENBLAS_CONST double *a, OPENBLAS_CONST blasint clda, OPENBLAS_CONST double *cbeta, \n\t\t  double *c, OPENBLAS_CONST blasint cldc); \n\nvoid cblas_sgemm_batch(OPENBLAS_CONST enum CBLAS_ORDER Order, OPENBLAS_CONST enum CBLAS_TRANSPOSE * TransA_array, OPENBLAS_CONST enum CBLAS_TRANSPOSE * TransB_array, OPENBLAS_CONST blasint * M_array, OPENBLAS_CONST blasint * N_array, OPENBLAS_CONST blasint * K_array,\n\t\t       OPENBLAS_CONST float * alpha_array, OPENBLAS_CONST float ** A_array, OPENBLAS_CONST blasint * lda_array, OPENBLAS_CONST float ** B_array, OPENBLAS_CONST blasint * ldb_array, OPENBLAS_CONST float * beta_array, float ** C_array, OPENBLAS_CONST blasint * ldc_array, OPENBLAS_CONST blasint group_count, OPENBLAS_CONST blasint * group_size);\n\nvoid cblas_dgemm_batch(OPENBLAS_CONST enum CBLAS_ORDER Order, OPENBLAS_CONST enum CBLAS_TRANSPOSE * TransA_array, OPENBLAS_CONST enum CBLAS_TRANSPOSE * TransB_array, OPENBLAS_CONST blasint * M_array, OPENBLAS_CONST blasint * N_array, OPENBLAS_CONST blasint * K_array,\n\t\t       OPENBLAS_CONST double * alpha_array, OPENBLAS_CONST double ** A_array, OPENBLAS_CONST blasint * lda_array, OPENBLAS_CONST double ** B_array, OPENBLAS_CONST blasint * ldb_array, OPENBLAS_CONST double * beta_array, double ** C_array, OPENBLAS_CONST blasint * ldc_array, OPENBLAS_CONST blasint group_count, OPENBLAS_CONST blasint * group_size);\n\nvoid cblas_cgemm_batch(OPENBLAS_CONST enum CBLAS_ORDER Order, OPENBLAS_CONST enum CBLAS_TRANSPOSE * TransA_array, OPENBLAS_CONST enum CBLAS_TRANSPOSE * TransB_array, OPENBLAS_CONST blasint * M_array, OPENBLAS_CONST blasint * N_array, OPENBLAS_CONST blasint * K_array,\n\t\t       OPENBLAS_CONST void * alpha_array, OPENBLAS_CONST void ** A_array, OPENBLAS_CONST blasint * lda_array, OPENBLAS_CONST void ** B_array, OPENBLAS_CONST blasint * ldb_array, OPENBLAS_CONST void * beta_array, void ** C_array, OPENBLAS_CONST blasint * ldc_array, OPENBLAS_CONST blasint group_count, OPENBLAS_CONST blasint * group_size);\n\nvoid cblas_zgemm_batch(OPENBLAS_CONST enum CBLAS_ORDER Order, OPENBLAS_CONST enum CBLAS_TRANSPOSE * TransA_array, OPENBLAS_CONST enum CBLAS_TRANSPOSE * TransB_array, OPENBLAS_CONST blasint * M_array, OPENBLAS_CONST blasint * N_array, OPENBLAS_CONST blasint * K_array,\n\t\t       OPENBLAS_CONST void * alpha_array, OPENBLAS_CONST void ** A_array, OPENBLAS_CONST blasint * lda_array, OPENBLAS_CONST void ** B_array, OPENBLAS_CONST blasint * ldb_array, OPENBLAS_CONST void * beta_array, void ** C_array, OPENBLAS_CONST blasint * ldc_array, OPENBLAS_CONST blasint group_count, OPENBLAS_CONST blasint * group_size);\n\n/*** BFLOAT16 and INT8 extensions ***/\n/* convert float array to BFLOAT16 array by rounding */\nvoid   cblas_sbstobf16(OPENBLAS_CONST blasint n, OPENBLAS_CONST float  *in, OPENBLAS_CONST blasint incin, bfloat16 *out, OPENBLAS_CONST blasint incout);\n/* convert double array to BFLOAT16 array by rounding */\nvoid   cblas_sbdtobf16(OPENBLAS_CONST blasint n, OPENBLAS_CONST double *in, OPENBLAS_CONST blasint incin, bfloat16 *out, OPENBLAS_CONST blasint incout);\n/* convert BFLOAT16 array to float array */\nvoid   cblas_sbf16tos(OPENBLAS_CONST blasint n, OPENBLAS_CONST bfloat16 *in, OPENBLAS_CONST blasint incin, float  *out, OPENBLAS_CONST blasint incout);\n/* convert BFLOAT16 array to double array */\nvoid   cblas_dbf16tod(OPENBLAS_CONST blasint n, OPENBLAS_CONST bfloat16 *in, OPENBLAS_CONST blasint incin, double *out, OPENBLAS_CONST blasint incout);\n/* dot production of BFLOAT16 input arrays, and output as float */\nfloat  cblas_sbdot(OPENBLAS_CONST blasint n, OPENBLAS_CONST bfloat16 *x, OPENBLAS_CONST blasint incx, OPENBLAS_CONST bfloat16 *y, OPENBLAS_CONST blasint incy);\nvoid   cblas_sbgemv(OPENBLAS_CONST enum CBLAS_ORDER order,  OPENBLAS_CONST enum CBLAS_TRANSPOSE trans,  OPENBLAS_CONST blasint m, OPENBLAS_CONST blasint n, OPENBLAS_CONST float alpha, OPENBLAS_CONST bfloat16 *a, OPENBLAS_CONST blasint lda, OPENBLAS_CONST bfloat16 *x, OPENBLAS_CONST blasint incx, OPENBLAS_CONST float beta, float *y, OPENBLAS_CONST blasint incy);\n\nvoid   cblas_sbgemm(OPENBLAS_CONST enum CBLAS_ORDER Order, OPENBLAS_CONST enum CBLAS_TRANSPOSE TransA, OPENBLAS_CONST enum CBLAS_TRANSPOSE TransB, OPENBLAS_CONST blasint M, OPENBLAS_CONST blasint N, OPENBLAS_CONST blasint K,\n\t\t    OPENBLAS_CONST float alpha, OPENBLAS_CONST bfloat16 *A, OPENBLAS_CONST blasint lda, OPENBLAS_CONST bfloat16 *B, OPENBLAS_CONST blasint ldb, OPENBLAS_CONST float beta, float *C, OPENBLAS_CONST blasint ldc);\nvoid cblas_sbgemm_batch(OPENBLAS_CONST enum CBLAS_ORDER Order, OPENBLAS_CONST enum CBLAS_TRANSPOSE * TransA_array, OPENBLAS_CONST enum CBLAS_TRANSPOSE * TransB_array, OPENBLAS_CONST blasint * M_array, OPENBLAS_CONST blasint * N_array, OPENBLAS_CONST blasint * K_array,\n\t\t       OPENBLAS_CONST float * alpha_array, OPENBLAS_CONST bfloat16 ** A_array, OPENBLAS_CONST blasint * lda_array, OPENBLAS_CONST bfloat16 ** B_array, OPENBLAS_CONST blasint * ldb_array, OPENBLAS_CONST float * beta_array, float ** C_array, OPENBLAS_CONST blasint * ldc_array, OPENBLAS_CONST blasint group_count, OPENBLAS_CONST blasint * group_size);\n\n#ifdef __cplusplus\n}\n#endif  /* __cplusplus */\n\n#endif\n"
        },
        {
          "name": "cmake",
          "type": "tree",
          "content": null
        },
        {
          "name": "common.h",
          "type": "blob",
          "size": 20.9267578125,
          "content": "/*********************************************************************/\n/* Copyright 2009, 2010 The University of Texas at Austin.           */\n/* All rights reserved.                                              */\n/*                                                                   */\n/* Redistribution and use in source and binary forms, with or        */\n/* without modification, are permitted provided that the following   */\n/* conditions are met:                                               */\n/*                                                                   */\n/*   1. Redistributions of source code must retain the above         */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer.                                                  */\n/*                                                                   */\n/*   2. Redistributions in binary form must reproduce the above      */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer in the documentation and/or other materials       */\n/*      provided with the distribution.                              */\n/*                                                                   */\n/*    THIS  SOFTWARE IS PROVIDED  BY THE  UNIVERSITY OF  TEXAS AT    */\n/*    AUSTIN  ``AS IS''  AND ANY  EXPRESS OR  IMPLIED WARRANTIES,    */\n/*    INCLUDING, BUT  NOT LIMITED  TO, THE IMPLIED  WARRANTIES OF    */\n/*    MERCHANTABILITY  AND FITNESS FOR  A PARTICULAR  PURPOSE ARE    */\n/*    DISCLAIMED.  IN  NO EVENT SHALL THE UNIVERSITY  OF TEXAS AT    */\n/*    AUSTIN OR CONTRIBUTORS BE  LIABLE FOR ANY DIRECT, INDIRECT,    */\n/*    INCIDENTAL,  SPECIAL, EXEMPLARY,  OR  CONSEQUENTIAL DAMAGES    */\n/*    (INCLUDING, BUT  NOT LIMITED TO,  PROCUREMENT OF SUBSTITUTE    */\n/*    GOODS  OR  SERVICES; LOSS  OF  USE,  DATA,  OR PROFITS;  OR    */\n/*    BUSINESS INTERRUPTION) HOWEVER CAUSED  AND ON ANY THEORY OF    */\n/*    LIABILITY, WHETHER  IN CONTRACT, STRICT  LIABILITY, OR TORT    */\n/*    (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY WAY OUT    */\n/*    OF  THE  USE OF  THIS  SOFTWARE,  EVEN  IF ADVISED  OF  THE    */\n/*    POSSIBILITY OF SUCH DAMAGE.                                    */\n/*                                                                   */\n/* The views and conclusions contained in the software and           */\n/* documentation are those of the authors and should not be          */\n/* interpreted as representing official policies, either expressed   */\n/* or implied, of The University of Texas at Austin.                 */\n/*********************************************************************/\n\n#ifndef COMMON_H\n#define COMMON_H\n\n#ifdef __cplusplus\nextern \"C\" {\n\t/* Assume C declarations for C++ */\n#endif  /* __cplusplus */\n\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE\n#endif\n\n#ifndef __USE_XOPEN\n#define __USE_XOPEN\n#endif\n\n#ifndef __USE_SVID\n#define __USE_SVID\n#endif\n\n#ifdef BUILD_KERNEL\n#include \"config_kernel.h\"\n#else\n#include \"config.h\"\n#endif\n\n#undef ENABLE_SSE_EXCEPTION\n\n#if defined(SMP_SERVER) || defined(SMP_ONDEMAND)\n#define SMP\n#endif\n\n#if defined(OS_WINNT) || defined(OS_CYGWIN_NT) || defined(OS_INTERIX)\n#define WINDOWS_ABI\n#define OS_WINDOWS\n\n#ifdef DOUBLE\n#define DOUBLE_DEFINED DOUBLE\n#undef  DOUBLE\n#endif\n#endif\n\n#if !defined(NOINCLUDE) && !defined(ASSEMBLER)\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#if !defined(_MSC_VER)\n#include <unistd.h>\n#elif _MSC_VER < 1900\n#define snprintf _snprintf\n#endif\n#include <time.h>\n\n#if defined(OS_LINUX) || defined(OS_QNX)\n#include <malloc.h>\n#include <sched.h>\n#endif\n\n#if defined(OS_DARWIN) || defined(OS_FREEBSD) || defined(OS_NETBSD) || defined(OS_OPENBSD) || defined(OS_DRAGONFLY) || defined(OS_ANDROID)\n#include <sched.h>\n#endif\n\n#ifdef OS_ANDROID\n#define NO_SYSV_IPC\n//Android NDK only supports complex.h since Android 5.0\n#if __ANDROID_API__ < 21\n#define FORCE_OPENBLAS_COMPLEX_STRUCT\n#endif\n#endif\n\n#if defined(OS_HAIKU) || defined(OS_QNX)\n#define NO_SYSV_IPC\n#endif\n\n#ifdef OS_WINDOWS\n#ifdef  ATOM\n#define GOTO_ATOM ATOM\n#undef  ATOM\n#endif\n#include <windows.h>\n#include <math.h>\n#ifdef  GOTO_ATOM\n#define ATOM GOTO_ATOM\n#undef  GOTO_ATOM\n#endif\n#elif !defined(OS_EMBEDDED)\n#include <sys/mman.h>\n#ifndef NO_SYSV_IPC\n#include <sys/shm.h>\n#endif\n#include <sys/time.h>\n#include <time.h>\n#include <unistd.h>\n#include <math.h>\n#if defined(SMP) || defined(USE_LOCKING)\n#include <pthread.h>\n#endif\n#else\n#include <time.h>\n#include <math.h>\n#endif\n\n#if defined(OS_SUNOS)\n#include <thread.h>\n#endif\n\n#ifdef __DECC\n#include <c_asm.h>\n#include <machine/builtins.h>\n#endif\n\n#if defined(ARCH_IA64) && defined(ENABLE_SSE_EXCEPTION)\n#include <fenv.h>\n#endif\n\n#endif\n\n#if defined(OS_WINDOWS) && defined(DOUBLE_DEFINED)\n#define DOUBLE DOUBLE_DEFINED\n#undef DOUBLE_DEFINED\n#endif\n\n#undef DEBUG_INFO\n#define SMP_DEBUG\n#undef MALLOC_DEBUG\n#undef SMP_ALLOC_DEBUG\n\n#ifndef ZERO\n#ifdef XDOUBLE\n#define ZERO  0.e0L\n#elif defined DOUBLE\n#define ZERO  0.e0\n#else\n#define ZERO  0.e0f\n#endif\n#endif\n\n#ifndef ONE\n#ifdef XDOUBLE\n#define ONE  1.e0L\n#elif defined DOUBLE\n#define ONE  1.e0\n#else\n#define ONE  1.e0f\n#endif\n#endif\n\n#define BITMASK(a, b, c) ((((a) >> (b)) & (c)))\n\n#define ALLOCA_ALIGN 63UL\n\n#define NUM_BUFFERS MAX(50,(MAX_CPU_NUMBER * 2 * MAX_PARALLEL_NUMBER))\n\n#ifdef NEEDBUNDERSCORE\n#define BLASFUNC(FUNC) FUNC##_\n#else\n#define BLASFUNC(FUNC) FUNC\n#endif\n\n#undef\tUSE_PTHREAD_LOCK\n#undef\tUSE_PTHREAD_SPINLOCK\n\n#if defined(USE_PTHREAD_LOCK) && defined(USE_PTHREAD_SPINLOCK)\n#error \"You can't specify both LOCK operation!\"\n#endif\n\n#if defined(SMP) || defined(USE_LOCKING)\n#define USE_PTHREAD_LOCK\n#undef\tUSE_PTHREAD_SPINLOCK\n#endif\n\n#ifdef OS_WINDOWS\n#undef\tUSE_PTHREAD_LOCK\n#undef\tUSE_PTHREAD_SPINLOCK\n#endif\n\n#if   defined(USE_PTHREAD_LOCK)\n#define   LOCK_COMMAND(x)   pthread_mutex_lock(x)\n#define UNLOCK_COMMAND(x)   pthread_mutex_unlock(x)\n#elif defined(USE_PTHREAD_SPINLOCK)\n#ifndef ASSEMBLER\ntypedef volatile int pthread_spinlock_t;\nint pthread_spin_lock (pthread_spinlock_t *__lock);\nint pthread_spin_unlock (pthread_spinlock_t *__lock);\n#endif\n#define   LOCK_COMMAND(x)   pthread_spin_lock(x)\n#define UNLOCK_COMMAND(x)   pthread_spin_unlock(x)\n#else\n#define   LOCK_COMMAND(x)   blas_lock(x)\n#define UNLOCK_COMMAND(x)   blas_unlock(x)\n#endif\n\n#define GOTO_SHMID\t0x510510\n\n#if 0\n#ifndef __CUDACC__\n#define __global__\n#define __device__\n#define __host__\n#define __shared__\n#endif\n#endif\n\n#ifndef ASSEMBLER\n\n#ifdef QUAD_PRECISION\ntypedef struct {\n  unsigned long x[2];\n}  xdouble;\n#elif defined EXPRECISION\n#define xdouble long double\n#else\n#define xdouble double\n#endif\n\n#if defined(OS_WINDOWS) && defined(__64BIT__)\ntypedef long long BLASLONG;\ntypedef unsigned long long BLASULONG;\n#else\ntypedef long BLASLONG;\ntypedef unsigned long BLASULONG;\n#endif\n\n#ifndef bfloat16\n#include <stdint.h>\ntypedef uint16_t bfloat16;\n#define BFLOAT16CONVERSION 1\n#endif\n\n#ifdef USE64BITINT\ntypedef BLASLONG blasint;\n#if defined(OS_WINDOWS) && defined(__64BIT__)\n#define blasabs(x) llabs(x)\n#else\n#define blasabs(x) labs(x)\n#endif\n#else\ntypedef int blasint;\n#define blasabs(x) abs(x)\n#endif\n#else\n#ifdef USE64BITINT\n#define INTSHIFT\t3\n#define INTSIZE\t\t8\n#else\n#define INTSHIFT\t2\n#define INTSIZE\t\t4\n#endif\n#endif\n\n#ifdef XDOUBLE\n#define FLOAT\txdouble\n#ifdef QUAD_PRECISION\n#define XFLOAT\txidouble\n#endif\n#ifdef QUAD_PRECISION\n#define SIZE\t32\n#define  BASE_SHIFT 5\n#define ZBASE_SHIFT 6\n#else\n#define SIZE\t16\n#define  BASE_SHIFT 4\n#define ZBASE_SHIFT 5\n#endif\n#elif defined(DOUBLE)\n#define FLOAT\tdouble\n#define SIZE\t8\n#define  BASE_SHIFT 3\n#define ZBASE_SHIFT 4\n#elif defined(BFLOAT16)\n#define IFLOAT\tbfloat16\n#define XFLOAT IFLOAT\n#define FLOAT\tfloat\n#define SIZE   2\n#define BASE_SHIFT 1\n#define ZBASE_SHIFT 2\n#else\n#define FLOAT\tfloat\n#define SIZE    4\n#define  BASE_SHIFT 2\n#define ZBASE_SHIFT 3\n#endif\n\n#ifndef XFLOAT\n#define XFLOAT\tFLOAT\n#endif\n\n#ifndef IFLOAT\n#define IFLOAT\tFLOAT\n#endif\n\n#ifndef COMPLEX\n#define COMPSIZE  1\n#else\n#define COMPSIZE  2\n#endif\n\n\n#define Address_H(x) (((x)+(1<<15))>>16)\n#define Address_L(x) ((x)-((Address_H(x))<<16))\n\n#ifndef MAX_CPU_NUMBER\n#define MAX_CPU_NUMBER 2\n#endif\n\n#if defined(OS_SUNOS)\n#define YIELDING\tthr_yield()\n#endif\n\n#if defined(OS_WINDOWS)\n#if defined(_MSC_VER) && !defined(__clang__)\n#define YIELDING    YieldProcessor()\n#else\n#define YIELDING\tSwitchToThread()\n#endif\n#endif\n\n#if defined(ARMV7) || defined(ARMV6) || defined(ARMV8) || defined(ARMV5)\n#define YIELDING        __asm__ __volatile__ (\"nop;nop;nop;nop;nop;nop;nop;nop; \\n\");\n#endif\n\n\n#if defined(POWER8) || defined(POWER9) || defined(POWER10)\n#ifndef YIELDING\n#define YIELDING        __asm__ __volatile__ (\"nop;nop;nop;nop;nop;nop;nop;nop;\\n\");\n#endif\n#endif\n\n\n#if defined(ARCH_X86_64)\n#ifndef YIELDING\n#define YIELDING        __asm__ __volatile__ (\"nop;nop;nop;nop;nop;nop;nop;nop;\\n\");\n#endif\n#endif\n\n#if defined(ARCH_RISCV64)\n#ifndef YIELDING\n#define YIELDING        __asm__ __volatile__ (\"nop;nop;nop;nop;nop;nop;nop;nop;\\n\");\n#endif\n#endif\n\n\n#ifdef __EMSCRIPTEN__\n#define YIELDING\n#endif\n\n#ifndef YIELDING\n#define YIELDING\tsched_yield()\n#endif\n\n/***\nTo alloc job_t on heap or stack.\nplease https://github.com/xianyi/OpenBLAS/issues/246\n***/\n#if defined(OS_WINDOWS)\n#define GETRF_MEM_ALLOC_THRESHOLD 32\n#define BLAS3_MEM_ALLOC_THRESHOLD 32\n#endif\n\n#ifndef GETRF_MEM_ALLOC_THRESHOLD\n#define GETRF_MEM_ALLOC_THRESHOLD 80\n#endif\n\n#ifndef BLAS3_MEM_ALLOC_THRESHOLD\n#define BLAS3_MEM_ALLOC_THRESHOLD 32 \n#endif\n\n#ifdef QUAD_PRECISION\n#include \"common_quad.h\"\n#endif\n\n#ifdef ARCH_ALPHA\n#include \"common_alpha.h\"\n#endif\n\n#if (defined(ARCH_X86) || defined(ARCH_X86_64)) && defined(__CET__) && defined(__has_include)\n#if __has_include(<cet.h>)\n#include <cet.h>\n#endif\n#endif\n#ifndef _CET_ENDBR\n#define _CET_ENDBR\n#endif\n\n#ifdef ARCH_X86\n#include \"common_x86.h\"\n#endif\n\n#ifdef ARCH_X86_64\n#include \"common_x86_64.h\"\n#endif\n\n#ifdef ARCH_IA64\n#include \"common_ia64.h\"\n#endif\n\n#ifdef ARCH_POWER\n#include \"common_power.h\"\n#endif\n\n#ifdef sparc\n#include \"common_sparc.h\"\n#endif\n\n#ifdef ARCH_MIPS\n#include \"common_mips.h\"\n#endif\n\n\n#ifdef ARCH_RISCV64\n#include \"common_riscv64.h\"\n#endif\n\n#ifdef ARCH_MIPS64\n#include \"common_mips64.h\"\n#endif\n\n#ifdef ARCH_ARM\n#include \"common_arm.h\"\n#endif\n\n#ifdef ARCH_ARM64\n#include \"common_arm64.h\"\n#endif\n\n#ifdef ARCH_ZARCH\n#include \"common_zarch.h\"\n#endif\n\n#ifdef ARCH_LOONGARCH64\n#include \"common_loongarch64.h\"\n#endif\n\n#ifdef ARCH_E2K\n#include \"common_e2k.h\"\n#endif\n\n#ifdef ARCH_CSKY\n#include \"common_csky.h\"\n#endif\n\n#ifndef ASSEMBLER\n#ifdef OS_WINDOWSSTORE\ntypedef char env_var_t[MAX_PATH];\n#define readenv(p, n) 0\n#else\n#if defined(OS_WINDOWS) && !defined(OS_CYGWIN_NT)\ntypedef char env_var_t[MAX_PATH];\n#define readenv(p, n) GetEnvironmentVariable((LPCTSTR)(n), (LPTSTR)(p), sizeof(p))\n#else\ntypedef char* env_var_t;\n#define readenv(p, n) ((p)=getenv(n))\n#endif\n#endif\n\n#if !defined(RPCC_DEFINED) && !defined(OS_WINDOWS)\n#ifdef _POSIX_MONOTONIC_CLOCK\n#if defined(__GLIBC_PREREQ) // cut the if condition if two lines, otherwise will fail at __GLIBC_PREREQ(2, 17)\n#if __GLIBC_PREREQ(2, 17) // don't require -lrt\n#define USE_MONOTONIC\n#endif\n#elif defined(OS_ANDROID)\n#define USE_MONOTONIC\n#endif\n#endif\n/* use similar scale as x86 rdtsc for timeouts to work correctly */\nstatic inline unsigned long long rpcc(void){\n#ifdef USE_MONOTONIC\n  struct timespec ts;\n  clock_gettime(CLOCK_MONOTONIC, &ts);\n  return (unsigned long long)ts.tv_sec * 1000000000ull + ts.tv_nsec;\n#elif !defined(OS_EMBEDDED)\n  struct timeval tv;\n  gettimeofday(&tv,NULL);\n  return (unsigned long long)tv.tv_sec * 1000000000ull + tv.tv_usec * 1000;\n#else\n  return 0;\n#endif\n}\n#define RPCC_DEFINED\n#define RPCC64BIT\n#endif // !RPCC_DEFINED\n\n#if !defined(BLAS_LOCK_DEFINED) && defined(__GNUC__)\nstatic __inline void blas_lock(volatile BLASULONG *address){\n\n  do {\n    while (*address) {YIELDING;};\n\n  } while (!__sync_bool_compare_and_swap(address, 0, 1));\n}\n#define BLAS_LOCK_DEFINED\n#endif\n\n#ifndef RPCC_DEFINED\n#error \"rpcc() implementation is missing for your platform\"\n#endif\n#ifndef BLAS_LOCK_DEFINED\n#error \"blas_lock() implementation is missing for your platform\"\n#endif\n#endif // !ASSEMBLER\n\n#ifdef OS_LINUX\n#include \"common_linux.h\"\n#endif\n\n#ifdef OS_EMBEDDED\n#define DTB_DEFAULT_ENTRIES 64\n#endif\n\n#define MMAP_ACCESS (PROT_READ | PROT_WRITE)\n\n#ifdef __NetBSD__\n#define MMAP_POLICY (MAP_PRIVATE | MAP_ANON)\n#else\n#define MMAP_POLICY (MAP_PRIVATE | MAP_ANONYMOUS)\n#endif\n\n#ifndef ASSEMBLER\n/* C99 supports complex floating numbers natively, which GCC also offers as an\n   extension since version 3.0.  If neither are available, use a compatible\n   structure as fallback (see Clause 6.2.5.13 of the C99 standard). */\n#if ((defined(__STDC_IEC_559_COMPLEX__) || __STDC_VERSION__ >= 199901L || \\\n      (__GNUC__ >= 3 && !defined(__cplusplus))) && !(defined(FORCE_OPENBLAS_COMPLEX_STRUCT))) && !defined(_MSC_VER)\n  #define OPENBLAS_COMPLEX_C99\n  #ifndef __cplusplus\n    #include <complex.h>\n  #endif\n  typedef float _Complex openblas_complex_float;\n  typedef double _Complex openblas_complex_double;\n  typedef xdouble _Complex openblas_complex_xdouble;\n  #define openblas_make_complex_float(real, imag)    ((real) + ((imag) * _Complex_I))\n  #define openblas_make_complex_double(real, imag)   ((real) + ((imag) * _Complex_I))\n  #define openblas_make_complex_xdouble(real, imag)  ((real) + ((imag) * _Complex_I))\n#else\n  #define OPENBLAS_COMPLEX_STRUCT\n  typedef struct { float real, imag; } openblas_complex_float;\n  typedef struct { double real, imag; } openblas_complex_double;\n  typedef struct { xdouble real, imag; } openblas_complex_xdouble;\n  #define openblas_make_complex_float(real, imag)    {(real), (imag)}\n  #define openblas_make_complex_double(real, imag)   {(real), (imag)}\n  #define openblas_make_complex_xdouble(real, imag)  {(real), (imag)}\n#endif\n#endif\n\n#include \"param.h\"\n#include \"common_param.h\"\n\n#ifndef STDERR\n#define STDERR stderr\n#endif\n\n#ifndef MASK\n#define MASK(a, b) (((a) + ((b) - 1)) & ~((b) - 1))\n#endif\n\n#if defined(XDOUBLE) || defined(DOUBLE)\n#define FLOATRET\tFLOAT\n#else\n#ifdef NEED_F2CCONV\n#define FLOATRET\tdouble\n#else\n#define FLOATRET\tfloat\n#endif\n#endif\n\n#ifndef ASSEMBLER\n#ifndef NOINCLUDE\n/* Inclusion of a standard header file is needed for definition of __STDC_*\n   predefined macros with some compilers (e.g. GCC 4.7 on Linux).  This occurs\n   as a side effect of including either <features.h> or <stdc-predef.h>. */\n#include <stdio.h>\n#endif  // NOINCLUDE\n\n#ifdef XDOUBLE\n#define OPENBLAS_COMPLEX_FLOAT openblas_complex_xdouble\n#define OPENBLAS_MAKE_COMPLEX_FLOAT(r,i) openblas_make_complex_xdouble(r,i)\n#elif defined(DOUBLE)\n#define OPENBLAS_COMPLEX_FLOAT openblas_complex_double\n#define OPENBLAS_MAKE_COMPLEX_FLOAT(r,i) openblas_make_complex_double(r,i)\n#else\n#define OPENBLAS_COMPLEX_FLOAT openblas_complex_float\n#define OPENBLAS_MAKE_COMPLEX_FLOAT(r,i) openblas_make_complex_float(r,i)\n#endif\n\n#if defined(C_PGI) || defined(C_SUN)\n  #if defined(__STDC_IEC_559_COMPLEX__)\n     #define CREAL(X)   creal(X)\n     #define CIMAG(X)   cimag(X)\n  #else\n     #define CREAL(X)\t(*((FLOAT *)&X + 0))\n     #define CIMAG(X)\t(*((FLOAT *)&X + 1))\n  #endif\n#else\n#ifdef OPENBLAS_COMPLEX_STRUCT\n#define CREAL(Z)\t((Z).real)\n#define CIMAG(Z)\t((Z).imag)\n#else\n#define CREAL\t__real__\n#define CIMAG\t__imag__\n#endif\n#endif\n\n#endif  // ASSEMBLER\n\n#ifndef IFLUSH\n#define IFLUSH\n#endif\n\n#ifndef IFLUSH_HALF\n#define IFLUSH_HALF\n#endif\n\n#if defined(C_GCC) && (( __GNUC__ <= 3) || ((__GNUC__ == 4) && (__GNUC_MINOR__ < 2)))\n#ifdef USE_OPENMP\n#undef USE_OPENMP\n#endif\n#endif\n\n#if defined(C_MSVC)\n#define inline __inline\n#endif\n\n#ifndef ASSEMBLER\n\n#ifndef MIN\n#define MIN(a,b)   (a>b? b:a)\n#endif\n\n#ifndef MAX\n#define MAX(a,b)   (a<b? b:a)\n#endif\n\n#define TOUPPER(a) {if ((a) > 0x60) (a) -= 0x20;}\n\n#if defined(__FreeBSD__) || defined(__APPLE__)\n#define MAP_ANONYMOUS MAP_ANON\n#endif\n\n/* Common Memory Management Routine */\nvoid  blas_set_parameter(void);\nint   blas_get_cpu_number(void);\nvoid *blas_memory_alloc  (int);\nvoid  blas_memory_free   (void *);\nvoid *blas_memory_alloc_nolock  (int); //use malloc without blas_lock\nvoid  blas_memory_free_nolock   (void *);\n\nint  get_num_procs (void);\n\n#if defined(OS_LINUX) && defined(SMP) && !defined(NO_AFFINITY)\nint  get_num_nodes (void);\nint get_num_proc   (int);\nint get_node_equal (void);\n#endif\n\nvoid goto_set_num_threads(int);\n\nvoid gotoblas_affinity_init(void);\nvoid gotoblas_affinity_quit(void);\nvoid gotoblas_dynamic_init(void);\nvoid gotoblas_dynamic_quit(void);\nvoid gotoblas_profile_init(void);\nvoid gotoblas_profile_quit(void);\n\t\nint support_avx512(void);\t\n\n#ifdef USE_OPENMP\n\n#ifndef C_MSVC\nint omp_in_parallel(void);\nint omp_get_num_procs(void);\n#else\n__declspec(dllimport) int __cdecl omp_in_parallel(void);\n__declspec(dllimport) int __cdecl omp_get_num_procs(void);\n#endif\n\n#ifdef HAVE_C11\n#if defined(C_GCC) && ( __GNUC__ < 7) \n// workaround for GCC bug 65467\n#ifndef _Atomic\n#define _Atomic volatile\n#endif\n#endif\n#include <stdatomic.h>\n#else\n#ifndef _Atomic\n#define _Atomic volatile\n#endif\n#endif\n\n#else\n#ifdef __ELF__\nint omp_in_parallel  (void) __attribute__ ((weak));\nint omp_get_num_procs(void) __attribute__ ((weak));\n#endif\n#endif\n\nstatic __inline void blas_unlock(volatile BLASULONG *address){\n  MB;\n  *address = 0;\n}\n\n#ifdef OS_WINDOWSSTORE\nstatic __inline int readenv_atoi(char *env) {\n\treturn 0;\n}\n#else\n#ifdef OS_WINDOWS\nstatic __inline int readenv_atoi(char *env) {\n  env_var_t p;\n  return readenv(p,env) ? 0 : atoi(p);\n}\n#else\nstatic __inline int readenv_atoi(char *env) {\n  char *p;\n  if (( p = getenv(env) ))\n  \treturn (atoi(p));\n  else\n\treturn(0);\n}\n#endif\n#endif\n\n#if !defined(XDOUBLE) || !defined(QUAD_PRECISION)\n\nstatic __inline void compinv(FLOAT *b, FLOAT ar, FLOAT ai){\n\n#ifndef UNIT\n  FLOAT ratio, den;\n\n  if (\n#ifdef XDOUBLE\n      (fabsl(ar)) >= (fabsl(ai))\n#elif defined DOUBLE\n      (fabs (ar)) >= (fabs (ai))\n#else\n      (fabsf(ar)) >= (fabsf(ai))\n#endif\n      ) {\n    ratio = ai / ar;\n    den   = (FLOAT)(ONE / (ar * (ONE + ratio * ratio)));\n    ar =  den;\n    ai = -ratio * den;\n  } else {\n    ratio = ar / ai;\n    den   = (FLOAT)(ONE /(ai * (ONE + ratio * ratio)));\n    ar =  ratio * den;\n    ai = -den;\n  }\n  b[0] = ar;\n  b[1] = ai;\n#else\n  b[0] = ONE;\n  b[1] = ZERO;\n#endif\n\n}\n#endif\n\n#ifdef MALLOC_DEBUG\nvoid *blas_debug_alloc(int);\nvoid *blas_debug_free(void *);\n#undef malloc\n#undef free\n#define malloc(a) blas_debug_alloc(a)\n#define free(a)   blas_debug_free (a)\n#endif\n\n#ifndef COPYOVERHEAD\n#define GEMMRETTYPE  int\n#else\n\ntypedef struct {\n  double outercopy;\n  double innercopy;\n  double kernel;\n  double mflops;\n} copyoverhead_t;\n\n#define GEMMRETTYPE  copyoverhead_t\n#endif\n#endif\n\n#ifndef BUILD_KERNEL\n#define KNAME(A, B) A\n#else\n#define KNAME(A, B) A##B\n#endif\n\n#include \"common_interface.h\"\n#ifdef SANITY_CHECK\n#include \"common_reference.h\"\n#endif\n#include \"common_macro.h\"\n#include \"common_level1.h\"\n#include \"common_level2.h\"\n#include \"common_level3.h\"\n#include \"common_lapack.h\"\n\n#ifdef CBLAS\n# define OPENBLAS_CONST     /* see comment in cblas.h */\n# include \"cblas.h\"\n#endif\n\n#ifndef ASSEMBLER\n#include \"common_stackalloc.h\"\n#if 0\n#include \"symcopy.h\"\n#endif\n\n#if defined(SMP_SERVER) && defined(SMP_ONDEMAND)\n#error Both SMP_SERVER and SMP_ONDEMAND are specified.\n#endif\n\n#if defined(SMP_SERVER) || defined(SMP_ONDEMAND)\n#include \"common_thread.h\"\n#endif\n\n#endif\n\n#define INFO_NUM 99\n\n#ifndef DEFAULT_CPU_NUMBER\n#define DEFAULT_CPU_NUMBER 4\n#endif\n\n#ifndef IDEBUG_START\n#define IDEBUG_START\n#endif\n\n#ifndef IDEBUG_END\n#define IDEBUG_END\n#endif\n\n#if !defined(ASSEMBLER) && defined(FUNCTION_PROFILE)\n\ntypedef struct {\n  int func;\n  unsigned long long calls, fops, area, cycles, tcycles;\n} func_profile_t;\n\nextern func_profile_t function_profile_table[];\nextern int gotoblas_profile;\n\n#ifdef XDOUBLE\n#define NUMOPT\tQNUMOPT\n#elif defined DOUBLE\n#define NUMOPT\tDNUMOPT\n#else\n#define NUMOPT\tSNUMOPT\n#endif\n\n#define FUNCTION_PROFILE_START() { unsigned long long profile_start = rpcc(), profile_end;\n#ifdef SMP\n#define FUNCTION_PROFILE_END(COMP, AREA, OPS) \\\n\tif (gotoblas_profile) { \\\n\tprofile_end = rpcc(); \\\n\tfunction_profile_table[PROFILE_FUNC_NAME].calls ++; \\\n\tfunction_profile_table[PROFILE_FUNC_NAME].area    += SIZE * COMPSIZE * (AREA); \\\n\tfunction_profile_table[PROFILE_FUNC_NAME].fops    += (COMP) * (OPS) / NUMOPT; \\\n\tfunction_profile_table[PROFILE_FUNC_NAME].cycles  += (profile_end - profile_start); \\\n\tfunction_profile_table[PROFILE_FUNC_NAME].tcycles += blas_cpu_number * (profile_end - profile_start); \\\n\t} \\\n\t}\n#else\n#define FUNCTION_PROFILE_END(COMP, AREA, OPS) \\\n\tif (gotoblas_profile) { \\\n\tprofile_end = rpcc(); \\\n\tfunction_profile_table[PROFILE_FUNC_NAME].calls ++; \\\n\tfunction_profile_table[PROFILE_FUNC_NAME].area    += SIZE * COMPSIZE * (AREA); \\\n\tfunction_profile_table[PROFILE_FUNC_NAME].fops    += (COMP) * (OPS) / NUMOPT; \\\n\tfunction_profile_table[PROFILE_FUNC_NAME].cycles  += (profile_end - profile_start); \\\n\tfunction_profile_table[PROFILE_FUNC_NAME].tcycles += (profile_end - profile_start); \\\n\t} \\\n\t}\n#endif\n\n#else\n#define FUNCTION_PROFILE_START()\n#define FUNCTION_PROFILE_END(COMP, AREA, OPS)\n#endif\n\n#if 1\n#define PRINT_DEBUG_CNAME\n#define PRINT_DEBUG_NAME\n#else\n#define PRINT_DEBUG_CNAME if (readenv_atoi(\"GOTO_DEBUG\")) fprintf(stderr, \"GotoBLAS : %s\\n\", CHAR_CNAME)\n#define PRINT_DEBUG_NAME  if (readenv_atoi(\"GOTO_DEBUG\")) fprintf(stderr, \"GotoBLAS : %s\\n\", CHAR_NAME)\n#endif\n\n#ifdef __cplusplus\n}\n\n#endif  /* __cplusplus */\n\n#endif\n"
        },
        {
          "name": "common_alpha.h",
          "type": "blob",
          "size": 5.3798828125,
          "content": "/*********************************************************************/\n/* Copyright 2009, 2010 The University of Texas at Austin.           */\n/* All rights reserved.                                              */\n/*                                                                   */\n/* Redistribution and use in source and binary forms, with or        */\n/* without modification, are permitted provided that the following   */\n/* conditions are met:                                               */\n/*                                                                   */\n/*   1. Redistributions of source code must retain the above         */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer.                                                  */\n/*                                                                   */\n/*   2. Redistributions in binary form must reproduce the above      */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer in the documentation and/or other materials       */\n/*      provided with the distribution.                              */\n/*                                                                   */\n/*    THIS  SOFTWARE IS PROVIDED  BY THE  UNIVERSITY OF  TEXAS AT    */\n/*    AUSTIN  ``AS IS''  AND ANY  EXPRESS OR  IMPLIED WARRANTIES,    */\n/*    INCLUDING, BUT  NOT LIMITED  TO, THE IMPLIED  WARRANTIES OF    */\n/*    MERCHANTABILITY  AND FITNESS FOR  A PARTICULAR  PURPOSE ARE    */\n/*    DISCLAIMED.  IN  NO EVENT SHALL THE UNIVERSITY  OF TEXAS AT    */\n/*    AUSTIN OR CONTRIBUTORS BE  LIABLE FOR ANY DIRECT, INDIRECT,    */\n/*    INCIDENTAL,  SPECIAL, EXEMPLARY,  OR  CONSEQUENTIAL DAMAGES    */\n/*    (INCLUDING, BUT  NOT LIMITED TO,  PROCUREMENT OF SUBSTITUTE    */\n/*    GOODS  OR  SERVICES; LOSS  OF  USE,  DATA,  OR PROFITS;  OR    */\n/*    BUSINESS INTERRUPTION) HOWEVER CAUSED  AND ON ANY THEORY OF    */\n/*    LIABILITY, WHETHER  IN CONTRACT, STRICT  LIABILITY, OR TORT    */\n/*    (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY WAY OUT    */\n/*    OF  THE  USE OF  THIS  SOFTWARE,  EVEN  IF ADVISED  OF  THE    */\n/*    POSSIBILITY OF SUCH DAMAGE.                                    */\n/*                                                                   */\n/* The views and conclusions contained in the software and           */\n/* documentation are those of the authors and should not be          */\n/* interpreted as representing official policies, either expressed   */\n/* or implied, of The University of Texas at Austin.                 */\n/*********************************************************************/\n\n#ifndef COMMON_ALPHA\n#define COMMON_ALPHA\n\n#ifndef ASSEMBLER\n\n#define MB  asm(\"mb\")\n#define WMB asm(\"wmb\")\n#define RMB asm(\"mb\")\n\nstatic __inline void blas_lock(unsigned long *address){\n#ifndef __DECC\n  unsigned long tmp1, tmp2;\n  asm volatile(\n    \"1: ldq\t%1,  %0\\n\"\n    \"\tbne\t%1,  2f\\n\"\n    \"\tldq_l\t%1,  %0\\n\"\n    \"\tbne\t%1,  2f\\n\"\n    \"\tor\t%1,  1, %2\\n\"\n    \"\tstq_c\t%2,  %0\\n\"\n    \"\tbeq\t%2,  2f\\n\"\n    \"\tmb\\n              \"\n    \"\tbr      $31, 3f\\n\"\n    \"2: br      $31, 1b\\n\"\n    \"3:\\n\" : \"=m\"(*address), \"=&r\"(tmp1), \"=&r\"(tmp2) : :  \"memory\");\n#else\n  asm (\n    \"10:\"\n    \"   ldq\t%t0,  0(%a0); \"\n    \"\tbne\t%t0, 20f;     \"\n    \"\tldq_l\t%t0,  0(%a0); \"\n    \"\tbne\t%t0, 20f;     \"\n    \"\tor\t%t0, 1, %t1;\"\n    \"\tstq_c\t%t1,  0(%a0); \"\n    \"\tbeq\t%t1, 20f;     \"\n    \"\tmb;                   \"\n    \"\tbr      %r31,30f;     \"\n    \"20:                      \"\n    \"\tbr      %r31,10b;     \"\n    \"30:\", address);\n#endif\n}\n#define BLAS_LOCK_DEFINED\n\nstatic __inline unsigned int rpcc(void){\n\n  unsigned int r0;\n\n#ifndef __DECC\n  asm __volatile__(\"rpcc %0\" : \"=r\"(r0)  : : \"memory\");\n#else\n  r0 = asm(\"rpcc %v0\");\n#endif\n\n  return r0;\n}\n#define RPCC_DEFINED\n\n\n#define HALT \tldq\t$0, 0($0)\n\n#ifndef __DECC\n#define GET_IMAGE(res)  asm __volatile__(\"fmov $f1, %0\" : \"=f\"(res)  : : \"memory\")\n#else\n#define GET_IMAGE(res) res = dasm(\"fmov $f1, %f0\")\n#endif\n\n#ifdef SMP\n#ifdef USE64BITINT\nstatic __inline long blas_quickdivide(long x, long y){\n  return x/y;\n}\n#else\nextern unsigned int blas_quick_divide_table[];\n\nstatic __inline int blas_quickdivide(unsigned int x, unsigned int y){\n  if (y <= 1) return x;\n  return (int)((x * (unsigned long)blas_quick_divide_table[y]) >> 32);\n}\n#endif\n#endif\n\n#define BASE_ADDRESS ((0x1b0UL << 33) | (0x1c0UL << 23) | (0x000UL << 13))\n\n#ifndef PAGESIZE\n#define PAGESIZE\t( 8UL << 10)\n#define HUGE_PAGESIZE\t( 4 << 20)\n#endif\n#define BUFFER_SIZE\t(32UL << 20)\n\n#else\n\n#ifndef F_INTERFACE\n#define REALNAME ASMNAME\n#else\n#define REALNAME ASMFNAME\n#endif\n\n#define PROLOGUE \\\n\t.arch ev6; \\\n\t.set noat; \\\n\t.set noreorder; \\\n.text; \\\n\t.align 5; \\\n\t.globl REALNAME; \\\n\t.ent REALNAME; \\\nREALNAME:\n\n#ifdef PROFILE\n#define PROFCODE \\\n\tldgp\t$gp, 0($27); \\\n\tlda\t$28, _mcount; \\\n\tjsr\t$28, ($28), _mcount; \\\n\t.prologue 1\n#else\n#define PROFCODE .prologue 0\n#endif\n\n#if defined(__linux__) && defined(__ELF__)\n#define GNUSTACK .section .note.GNU-stack,\"\",@progbits\n#else\n#define GNUSTACK\n#endif\n\n#define EPILOGUE \\\n\t.end REALNAME; \\\n\t.ident VERSION; \\\n\tGNUSTACK\n\n#endif\n\n#ifdef DOUBLE\n#define SXADDQ\ts8addq\n#define SXSUBL\ts8subl\n#define LD\tldt\n#define ST\tstt\n#define STQ\tstq\n#define ADD\taddt/su\n#define SUB\tsubt/su\n#define MUL\tmult/su\n#define DIV\tdivt/su\n#else\n#define SXADDQ  s4addq\n#define SXSUBL\ts4subl\n#define LD      lds\n#define ST\tsts\n#define STQ\tstl\n#define ADD\tadds/su\n#define SUB\tsubs/su\n#define MUL\tmuls/su\n#define DIV\tdivs/su\n#endif\n#endif\n"
        },
        {
          "name": "common_arm.h",
          "type": "blob",
          "size": 3.794921875,
          "content": "/*****************************************************************************\nCopyright (c) 2011-2015, The OpenBLAS Project\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   1. Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n\n   2. Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in\n      the documentation and/or other materials provided with the\n      distribution.\n   3. Neither the name of the OpenBLAS project nor the names of \n      its contributors may be used to endorse or promote products \n      derived from this software without specific prior written \n      permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\nUSE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n**********************************************************************************/\n\n#ifndef COMMON_ARM\n#define COMMON_ARM\n\n#if defined(ARMV5) || defined(ARMV6)\n\n#define MB\n#define WMB\n#define RMB\n\n#else\n\n#define MB   __asm__ __volatile__ (\"dmb  ish\" : : : \"memory\")\n#define WMB  __asm__ __volatile__ (\"dmb  ishst\" : : : \"memory\")\n#define RMB  __asm__ __volatile__ (\"dmb  ish\" : : : \"memory\")\n\n#endif\n\n#define RETURN_BY_COMPLEX\n\n#ifndef ASSEMBLER\n\n#if defined(ARMV6) || defined(ARMV7) || defined(ARMV8)\n\nstatic __inline void blas_lock(volatile BLASULONG *address){\n\n  int register ret;\n\n  do {\n    while (*address) {YIELDING;};\n\n    __asm__ __volatile__(\n                         \"ldrex r2, [%1]      \\n\\t\"\n                         \"strex %0, %2, [%1]  \\n\\t\"\n                         \"orr   %0, r2        \\n\\t\"\n                         : \"=&r\"(ret)\n                         : \"r\"(address), \"r\"(1)\n                         : \"memory\", \"r2\"\n    );\n\n  } while (ret);\n  MB;\n}\n\n#define BLAS_LOCK_DEFINED\n#endif\n\nstatic inline int blas_quickdivide(blasint x, blasint y){\n  return x / y;\n}\n\n#if !defined(HAVE_VFP)\n/* no FPU, soft float */\n#define GET_IMAGE(res)\n#elif defined(DOUBLE)\n#define GET_IMAGE(res)  __asm__ __volatile__(\"vstr.f64 d1, %0\" : \"=m\"(res) : : \"memory\")\n#else\n#define GET_IMAGE(res)  __asm__ __volatile__(\"vstr.f32 s1, %0\" : \"=m\"(res) : : \"memory\")\n#endif\n\n#define GET_IMAGE_CANCEL\n\n#endif\n\n\n#ifndef F_INTERFACE\n#define REALNAME ASMNAME\n#else\n#define REALNAME ASMFNAME\n#endif\n\n#if defined(ASSEMBLER) && !defined(NEEDPARAM)\n\n#if !defined(__APPLE__) && !defined(_WIN32)\n#define OPENBLAS_ARM_TYPE_FUNCTION .type\tREALNAME, %function ;\n#else\n#define OPENBLAS_ARM_TYPE_FUNCTION\n#endif\n\n#define PROLOGUE \\\n\t.arm\t\t ;\\\n\t.global\tREALNAME ;\\\n\tOPENBLAS_ARM_TYPE_FUNCTION \\\nREALNAME:\n\n#define EPILOGUE\n\n#define PROFCODE\n\n#endif\n\n\n#define SEEK_ADDRESS\n\n#ifndef PAGESIZE\n#define PAGESIZE        ( 4 << 10)\n#endif\n#define HUGE_PAGESIZE   ( 4 << 20)\n\n#define BUFFER_SIZE     (32 << 20)\n\n\n#define BASE_ADDRESS (START_ADDRESS - BUFFER_SIZE * MAX_CPU_NUMBER)\n\n#ifndef MAP_ANONYMOUS\n#define MAP_ANONYMOUS MAP_ANON\n#endif\n\n#if !defined(ARMV5) && !defined(ARMV6) && !defined(ARMV7) && !defined(ARMV8)\n#error \"you must define ARMV5, ARMV6, ARMV7 or ARMV8\"\n#endif\n\n#endif\n"
        },
        {
          "name": "common_arm64.h",
          "type": "blob",
          "size": 5.517578125,
          "content": "/*****************************************************************************\nCopyright (c) 2011-2015, The OpenBLAS Project\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   1. Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n\n   2. Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in\n      the documentation and/or other materials provided with the\n      distribution.\n   3. Neither the name of the OpenBLAS project nor the names of \n      its contributors may be used to endorse or promote products \n      derived from this software without specific prior written \n      permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\nUSE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n**********************************************************************************/\n\n#ifndef COMMON_ARM64\n#define COMMON_ARM64\n\n#ifdef C_MSVC\n#include <intrin.h>\n#define MB __dmb(_ARM64_BARRIER_ISH)\n#define WMB __dmb(_ARM64_BARRIER_ISHST)\n#define RMB __dmb(_ARM64_BARRIER_ISHLD)\n#else\n#define MB   __asm__ __volatile__ (\"dmb  ish\" : : : \"memory\")\n#define WMB  __asm__ __volatile__ (\"dmb  ishst\" : : : \"memory\")\n#define RMB  __asm__ __volatile__ (\"dmb  ishld\" : : : \"memory\")\n#endif\n\n#if defined( F_INTERFACE_FLANG) || (defined(F_INTERFACE_PGI) && (defined(__NVCOMPILER) && (__NVCOMPILER_MAJOR__ < 23 || (__NVCOMPILER_MAJOR__ == 23 && __NVCOMPILER_MINOR__ < 9))))\n#define RETURN_BY_STACK\n#else\n#define RETURN_BY_COMPLEX\n#endif\n\n#ifndef ASSEMBLER\n\n\n#ifndef NO_AFFINITY\nstatic __inline int WhereAmI(void){\n  uint64_t ret;\n  __asm__ volatile (\n       \"         mrs x0, mpidr_el1 \\n\"\n       \"         and x0, x0, 0xff  \\n\"\n                 :\"=r\" (ret)\n                 :: \"memory\"\n               );\n  ret +=1;\n  if ((int)ret <0) ret = 0;\n  return (int)ret;\n}\n#endif\n\nstatic __inline void blas_lock(volatile BLASULONG *address){\n\n  BLASULONG ret;\n\n  do {\n    #ifndef C_MSVC\n    __asm__ __volatile__(\n\t\t\t \"mov\tx4, #1\t\t\t\t\t\t\t\\n\\t\"\n\t\t\t \"sevl\t\t\t\t\t\t\t\t\\n\\t\"\n                         \"1:                                                            \\n\\t\"\n                         \"wfe                                                           \\n\\t\"\n\t\t\t \"2:\t\t\t\t\t\t\t\t\\n\\t\"\n                         \"ldaxr x2, [%1]                                                \\n\\t\"\n                         \"cbnz  x2, 1b                                                  \\n\\t\"\n                         \"stxr  w3, x4, [%1]                                            \\n\\t\"\n                         \"cbnz  w3, 2b                                                  \\n\\t\"\n                         \"mov   %0, #0                                                  \\n\\t\"\n                         : \"=r\"(ret), \"=r\"(address)\n                         : \"1\"(address)\n                         : \"memory\", \"x2\" , \"x3\", \"x4\"\n\n\n    );\n    #else\n      while (*address) {YIELDING;}\n      ret=InterlockedExchange64((volatile LONG64 *)(address), 1);\n    #endif\n\n  } while (ret);\n\n}\n\n#define BLAS_LOCK_DEFINED\n\n#if !defined(OS_DARWIN) && !defined (OS_ANDROID)\nstatic __inline BLASULONG rpcc(void){\n  #ifdef C_MSVC\n    const int64_t pmccntr_el0 = (((3 & 1) << 14) |  // op0\n        ((3 & 7) << 11) |  // op1\n        ((9 & 15) << 7) |  // crn\n        ((13 & 15) << 3) | // crm\n        ((0 & 7) << 0));   // op2\n    return _ReadStatusReg(pmccntr_el0);\n  #else\n  BLASULONG ret = 0;\n  blasint shift;\n \n  __asm__ __volatile__ (\"isb; mrs %0,cntvct_el0\":\"=r\"(ret));\n  __asm__ __volatile__ (\"mrs %0,cntfrq_el0; clz %w0, %w0\":\"=&r\"(shift));\n\n  return ret << shift;\n  #endif\n}\n\n#define RPCC_DEFINED\n#define RPCC64BIT\n#endif \n\nstatic inline int blas_quickdivide(blasint x, blasint y){\n  return x / y;\n}\n\n#if defined(DOUBLE)\n#define GET_IMAGE(res)  __asm__ __volatile__(\"str d1, %0\" : \"=m\"(res) : : \"memory\")\n#else\n#define GET_IMAGE(res)  __asm__ __volatile__(\"str s1, %0\" : \"=m\"(res) : : \"memory\")\n#endif\n\n#define GET_IMAGE_CANCEL\n\n#endif\n\n\n#ifndef F_INTERFACE\n#define REALNAME ASMNAME\n#else\n#define REALNAME ASMFNAME\n#endif\n\n#if defined(ASSEMBLER) && !defined(NEEDPARAM)\n\n.macro PROLOGUE \n\t.text ;\n\t.p2align 2 ;\n\t.global\tREALNAME ;\n#if !defined(__APPLE__) && !defined(_WIN32)\n\t.type\tREALNAME, %function ;\n#endif\nREALNAME:\n.endm\n\n\n#define EPILOGUE\n\n#define PROFCODE\n\n#endif\n\n\n#define SEEK_ADDRESS\n\n#ifndef PAGESIZE\n#define PAGESIZE        ( 4 << 10)\n#endif\n#define HUGE_PAGESIZE   ( 4 << 20)\n\n#ifndef BUFFERSIZE\n#if defined(NEOVERSEN1) || defined(NEOVERSEN2) || defined(NEOVERSEV1) || defined(A64FX) || defined(ARMV8SVE)\n#define BUFFER_SIZE     (32 << 22)\n#else\n#define BUFFER_SIZE     (32 << 20)\n#endif\n#else\n#define BUFFER_SIZE\t(32 << BUFFERSIZE)\n#endif\n\n#define BASE_ADDRESS (START_ADDRESS - BUFFER_SIZE * MAX_CPU_NUMBER)\n\n#ifndef MAP_ANONYMOUS\n#define MAP_ANONYMOUS MAP_ANON\n#endif\n\n#endif\n\n"
        },
        {
          "name": "common_c.h",
          "type": "blob",
          "size": 24.1220703125,
          "content": "#ifndef COMMON_C_H\n#define COMMON_C_H\n\n#ifndef DYNAMIC_ARCH\n\n#define\tCAMAX_K\t\t\tcamax_k\n#define\tCAMIN_K\t\t\tcamin_k\n#define\tCMAX_K\t\t\tcmax_k\n#define\tCMIN_K\t\t\tcmin_k\n#define\tICAMAX_K\t\ticamax_k\n#define\tICAMIN_K\t\ticamin_k\n#define\tICMAX_K\t\t\ticmax_k\n#define\tICMIN_K\t\t\ticmin_k\n#define\tCASUM_K\t\t\tcasum_k\n#define\tCAXPYU_K\t\tcaxpy_k\n#define\tCAXPYC_K\t\tcaxpyc_k\n#define\tCCOPY_K\t\t\tccopy_k\n#define\tCDOTU_K\t\t\tcdotu_k\n#define\tCDOTC_K\t\t\tcdotc_k\n#define\tCNRM2_K\t\t\tcnrm2_k\n#define\tCSCAL_K\t\t\tcscal_k\n#define\tCSUM_K\t\t\tcsum_k\n#define\tCSWAP_K\t\t\tcswap_k\n#define\tCROT_K\t\t\tcsrot_k\n\n#define\tCGEMV_N\t\t\tcgemv_n\n#define\tCGEMV_T\t\t\tcgemv_t\n#define\tCGEMV_R\t\t\tcgemv_r\n#define\tCGEMV_C\t\t\tcgemv_c\n#define\tCGEMV_O\t\t\tcgemv_o\n#define\tCGEMV_U\t\t\tcgemv_u\n#define\tCGEMV_S\t\t\tcgemv_s\n#define\tCGEMV_D\t\t\tcgemv_d\n\n#define\tCGERU_K\t\t\tcgeru_k\n#define\tCGERC_K\t\t\tcgerc_k\n#define\tCGERV_K\t\t\tcgerv_k\n#define\tCGERD_K\t\t\tcgerd_k\n\n#define CSYMV_U\t\t\tcsymv_U\n#define CSYMV_L\t\t\tcsymv_L\n#define CHEMV_U\t\t\tchemv_U\n#define CHEMV_L\t\t\tchemv_L\n#define CHEMV_V\t\t\tchemv_V\n#define CHEMV_M\t\t\tchemv_M\n\n#define CSYMV_THREAD_U\t\tcsymv_thread_U\n#define CSYMV_THREAD_L\t\tcsymv_thread_L\n#define CHEMV_THREAD_U\t\tchemv_thread_U\n#define CHEMV_THREAD_L\t\tchemv_thread_L\n#define CHEMV_THREAD_V\t\tchemv_thread_V\n#define CHEMV_THREAD_M\t\tchemv_thread_M\n\n#define\tCGEMM_ONCOPY\t\tcgemm_oncopy\n#define\tCGEMM_OTCOPY\t\tcgemm_otcopy\n\n#if CGEMM_DEFAULT_UNROLL_M == CGEMM_DEFAULT_UNROLL_N\n#define\tCGEMM_INCOPY\t\tcgemm_oncopy\n#define\tCGEMM_ITCOPY\t\tcgemm_otcopy\n#else\n#define\tCGEMM_INCOPY\t\tcgemm_incopy\n#define\tCGEMM_ITCOPY\t\tcgemm_itcopy\n#endif\n\n#define\tCTRMM_OUNUCOPY\t\tctrmm_ounucopy\n#define\tCTRMM_OUNNCOPY\t\tctrmm_ounncopy\n#define\tCTRMM_OUTUCOPY\t\tctrmm_outucopy\n#define\tCTRMM_OUTNCOPY\t\tctrmm_outncopy\n#define\tCTRMM_OLNUCOPY\t\tctrmm_olnucopy\n#define\tCTRMM_OLNNCOPY\t\tctrmm_olnncopy\n#define\tCTRMM_OLTUCOPY\t\tctrmm_oltucopy\n#define\tCTRMM_OLTNCOPY\t\tctrmm_oltncopy\n\n#define\tCTRSM_OUNUCOPY\t\tctrsm_ounucopy\n#define\tCTRSM_OUNNCOPY\t\tctrsm_ounncopy\n#define\tCTRSM_OUTUCOPY\t\tctrsm_outucopy\n#define\tCTRSM_OUTNCOPY\t\tctrsm_outncopy\n#define\tCTRSM_OLNUCOPY\t\tctrsm_olnucopy\n#define\tCTRSM_OLNNCOPY\t\tctrsm_olnncopy\n#define\tCTRSM_OLTUCOPY\t\tctrsm_oltucopy\n#define\tCTRSM_OLTNCOPY\t\tctrsm_oltncopy\n\n#if CGEMM_DEFAULT_UNROLL_M == CGEMM_DEFAULT_UNROLL_N\n#define\tCTRMM_IUNUCOPY\t\tctrmm_ounucopy\n#define\tCTRMM_IUNNCOPY\t\tctrmm_ounncopy\n#define\tCTRMM_IUTUCOPY\t\tctrmm_outucopy\n#define\tCTRMM_IUTNCOPY\t\tctrmm_outncopy\n#define\tCTRMM_ILNUCOPY\t\tctrmm_olnucopy\n#define\tCTRMM_ILNNCOPY\t\tctrmm_olnncopy\n#define\tCTRMM_ILTUCOPY\t\tctrmm_oltucopy\n#define\tCTRMM_ILTNCOPY\t\tctrmm_oltncopy\n\n#define\tCTRSM_IUNUCOPY\t\tctrsm_ounucopy\n#define\tCTRSM_IUNNCOPY\t\tctrsm_ounncopy\n#define\tCTRSM_IUTUCOPY\t\tctrsm_outucopy\n#define\tCTRSM_IUTNCOPY\t\tctrsm_outncopy\n#define\tCTRSM_ILNUCOPY\t\tctrsm_olnucopy\n#define\tCTRSM_ILNNCOPY\t\tctrsm_olnncopy\n#define\tCTRSM_ILTUCOPY\t\tctrsm_oltucopy\n#define\tCTRSM_ILTNCOPY\t\tctrsm_oltncopy\n#else\n#define\tCTRMM_IUNUCOPY\t\tctrmm_iunucopy\n#define\tCTRMM_IUNNCOPY\t\tctrmm_iunncopy\n#define\tCTRMM_IUTUCOPY\t\tctrmm_iutucopy\n#define\tCTRMM_IUTNCOPY\t\tctrmm_iutncopy\n#define\tCTRMM_ILNUCOPY\t\tctrmm_ilnucopy\n#define\tCTRMM_ILNNCOPY\t\tctrmm_ilnncopy\n#define\tCTRMM_ILTUCOPY\t\tctrmm_iltucopy\n#define\tCTRMM_ILTNCOPY\t\tctrmm_iltncopy\n\n#define\tCTRSM_IUNUCOPY\t\tctrsm_iunucopy\n#define\tCTRSM_IUNNCOPY\t\tctrsm_iunncopy\n#define\tCTRSM_IUTUCOPY\t\tctrsm_iutucopy\n#define\tCTRSM_IUTNCOPY\t\tctrsm_iutncopy\n#define\tCTRSM_ILNUCOPY\t\tctrsm_ilnucopy\n#define\tCTRSM_ILNNCOPY\t\tctrsm_ilnncopy\n#define\tCTRSM_ILTUCOPY\t\tctrsm_iltucopy\n#define\tCTRSM_ILTNCOPY\t\tctrsm_iltncopy\n#endif\n\n#define\tCGEMM_BETA\t\tcgemm_beta\n\n#define\tCGEMM_KERNEL_N\t\tcgemm_kernel_n\n#define\tCGEMM_KERNEL_L\t\tcgemm_kernel_l\n#define\tCGEMM_KERNEL_R\t\tcgemm_kernel_r\n#define\tCGEMM_KERNEL_B\t\tcgemm_kernel_b\n\n#define\tCTRMM_KERNEL_LN\t\tctrmm_kernel_LN\n#define\tCTRMM_KERNEL_LT\t\tctrmm_kernel_LT\n#define\tCTRMM_KERNEL_LR\t\tctrmm_kernel_LR\n#define\tCTRMM_KERNEL_LC\t\tctrmm_kernel_LC\n#define\tCTRMM_KERNEL_RN\t\tctrmm_kernel_RN\n#define\tCTRMM_KERNEL_RT\t\tctrmm_kernel_RT\n#define\tCTRMM_KERNEL_RR\t\tctrmm_kernel_RR\n#define\tCTRMM_KERNEL_RC\t\tctrmm_kernel_RC\n\n#define\tCTRSM_KERNEL_LN\t\tctrsm_kernel_LN\n#define\tCTRSM_KERNEL_LT\t\tctrsm_kernel_LT\n#define\tCTRSM_KERNEL_LR\t\tctrsm_kernel_LR\n#define\tCTRSM_KERNEL_LC\t\tctrsm_kernel_LC\n#define\tCTRSM_KERNEL_RN\t\tctrsm_kernel_RN\n#define\tCTRSM_KERNEL_RT\t\tctrsm_kernel_RT\n#define\tCTRSM_KERNEL_RR\t\tctrsm_kernel_RR\n#define\tCTRSM_KERNEL_RC\t\tctrsm_kernel_RC\n\n#define\tCSYMM_OUTCOPY\t\tcsymm_outcopy\n#define\tCSYMM_OLTCOPY\t\tcsymm_oltcopy\n#if CGEMM_DEFAULT_UNROLL_M == CGEMM_DEFAULT_UNROLL_N\n#define\tCSYMM_IUTCOPY\t\tcsymm_outcopy\n#define\tCSYMM_ILTCOPY\t\tcsymm_oltcopy\n#else\n#define\tCSYMM_IUTCOPY\t\tcsymm_iutcopy\n#define\tCSYMM_ILTCOPY\t\tcsymm_iltcopy\n#endif\n\n#define\tCHEMM_OUTCOPY\t\tchemm_outcopy\n#define\tCHEMM_OLTCOPY\t\tchemm_oltcopy\n#if CGEMM_DEFAULT_UNROLL_M == CGEMM_DEFAULT_UNROLL_N\n#define\tCHEMM_IUTCOPY\t\tchemm_outcopy\n#define\tCHEMM_ILTCOPY\t\tchemm_oltcopy\n#else\n#define\tCHEMM_IUTCOPY\t\tchemm_iutcopy\n#define\tCHEMM_ILTCOPY\t\tchemm_iltcopy\n#endif\n\n#define\tCGEMM3M_ONCOPYB\t\tcgemm3m_oncopyb\n#define\tCGEMM3M_ONCOPYR\t\tcgemm3m_oncopyr\n#define\tCGEMM3M_ONCOPYI\t\tcgemm3m_oncopyi\n#define\tCGEMM3M_OTCOPYB\t\tcgemm3m_otcopyb\n#define\tCGEMM3M_OTCOPYR\t\tcgemm3m_otcopyr\n#define\tCGEMM3M_OTCOPYI\t\tcgemm3m_otcopyi\n\n#define\tCGEMM3M_INCOPYB\t\tcgemm3m_incopyb\n#define\tCGEMM3M_INCOPYR\t\tcgemm3m_incopyr\n#define\tCGEMM3M_INCOPYI\t\tcgemm3m_incopyi\n#define\tCGEMM3M_ITCOPYB\t\tcgemm3m_itcopyb\n#define\tCGEMM3M_ITCOPYR\t\tcgemm3m_itcopyr\n#define\tCGEMM3M_ITCOPYI\t\tcgemm3m_itcopyi\n\n#define\tCSYMM3M_ILCOPYB\t\tcsymm3m_ilcopyb\n#define\tCSYMM3M_IUCOPYB\t\tcsymm3m_iucopyb\n#define\tCSYMM3M_ILCOPYR\t\tcsymm3m_ilcopyr\n#define\tCSYMM3M_IUCOPYR\t\tcsymm3m_iucopyr\n#define\tCSYMM3M_ILCOPYI\t\tcsymm3m_ilcopyi\n#define\tCSYMM3M_IUCOPYI\t\tcsymm3m_iucopyi\n\n#define\tCSYMM3M_OLCOPYB\t\tcsymm3m_olcopyb\n#define\tCSYMM3M_OUCOPYB\t\tcsymm3m_oucopyb\n#define\tCSYMM3M_OLCOPYR\t\tcsymm3m_olcopyr\n#define\tCSYMM3M_OUCOPYR\t\tcsymm3m_oucopyr\n#define\tCSYMM3M_OLCOPYI\t\tcsymm3m_olcopyi\n#define\tCSYMM3M_OUCOPYI\t\tcsymm3m_oucopyi\n\n#define\tCHEMM3M_ILCOPYB\t\tchemm3m_ilcopyb\n#define\tCHEMM3M_IUCOPYB\t\tchemm3m_iucopyb\n#define\tCHEMM3M_ILCOPYR\t\tchemm3m_ilcopyr\n#define\tCHEMM3M_IUCOPYR\t\tchemm3m_iucopyr\n#define\tCHEMM3M_ILCOPYI\t\tchemm3m_ilcopyi\n#define\tCHEMM3M_IUCOPYI\t\tchemm3m_iucopyi\n\n#define\tCHEMM3M_OLCOPYB\t\tchemm3m_olcopyb\n#define\tCHEMM3M_OUCOPYB\t\tchemm3m_oucopyb\n#define\tCHEMM3M_OLCOPYR\t\tchemm3m_olcopyr\n#define\tCHEMM3M_OUCOPYR\t\tchemm3m_oucopyr\n#define\tCHEMM3M_OLCOPYI\t\tchemm3m_olcopyi\n#define\tCHEMM3M_OUCOPYI\t\tchemm3m_oucopyi\n\n#define\tCGEMM3M_KERNEL\t\tcgemm3m_kernel\n\n#define CNEG_TCOPY\t\tcneg_tcopy\n#define CLASWP_NCOPY\t\tclaswp_ncopy\n\n#define CAXPBY_K                caxpby_k\n\n#define COMATCOPY_K_CN          comatcopy_k_cn\n#define COMATCOPY_K_RN          comatcopy_k_rn\n#define COMATCOPY_K_CT          comatcopy_k_ct\n#define COMATCOPY_K_RT          comatcopy_k_rt\n#define COMATCOPY_K_CNC         comatcopy_k_cnc\n#define COMATCOPY_K_RNC         comatcopy_k_rnc\n#define COMATCOPY_K_CTC         comatcopy_k_ctc\n#define COMATCOPY_K_RTC         comatcopy_k_rtc\n\n#define CIMATCOPY_K_CN          cimatcopy_k_cn\n#define CIMATCOPY_K_RN          cimatcopy_k_rn\n#define CIMATCOPY_K_CT          cimatcopy_k_ct\n#define CIMATCOPY_K_RT          cimatcopy_k_rt\n#define CIMATCOPY_K_CNC         cimatcopy_k_cnc\n#define CIMATCOPY_K_RNC         cimatcopy_k_rnc\n#define CIMATCOPY_K_CTC         cimatcopy_k_ctc\n#define CIMATCOPY_K_RTC         cimatcopy_k_rtc\n\n#define CGEADD_K                cgeadd_k \n\n#define CGEMM_SMALL_MATRIX_PERMIT\tcgemm_small_matrix_permit\n\n#else\n\n#define\tCAMAX_K\t\t\tgotoblas -> camax_k\n#define\tCAMIN_K\t\t\tgotoblas -> camin_k\n#define\tCMAX_K\t\t\tgotoblas -> cmax_k\n#define\tCMIN_K\t\t\tgotoblas -> cmin_k\n#define\tICAMAX_K\t\tgotoblas -> icamax_k\n#define\tICAMIN_K\t\tgotoblas -> icamin_k\n#define\tICMAX_K\t\t\tgotoblas -> icmax_k\n#define\tICMIN_K\t\t\tgotoblas -> icmin_k\n#define\tCASUM_K\t\t\tgotoblas -> casum_k\n#define\tCAXPYU_K\t\tgotoblas -> caxpy_k\n#define\tCAXPYC_K\t\tgotoblas -> caxpyc_k\n#define\tCCOPY_K\t\t\tgotoblas -> ccopy_k\n#define\tCDOTU_K\t\t\tgotoblas -> cdotu_k\n#define\tCDOTC_K\t\t\tgotoblas -> cdotc_k\n#define\tCNRM2_K\t\t\tgotoblas -> cnrm2_k\n#define\tCSCAL_K\t\t\tgotoblas -> cscal_k\n#define\tCSUM_K\t\t\tgotoblas -> csum_k\n#define\tCSWAP_K\t\t\tgotoblas -> cswap_k\n#define\tCROT_K\t\t\tgotoblas -> csrot_k\n\n#define\tCGEMV_N\t\t\tgotoblas -> cgemv_n\n#define\tCGEMV_T\t\t\tgotoblas -> cgemv_t\n#define\tCGEMV_R\t\t\tgotoblas -> cgemv_r\n#define\tCGEMV_C\t\t\tgotoblas -> cgemv_c\n#define\tCGEMV_O\t\t\tgotoblas -> cgemv_o\n#define\tCGEMV_U\t\t\tgotoblas -> cgemv_u\n#define\tCGEMV_S\t\t\tgotoblas -> cgemv_s\n#define\tCGEMV_D\t\t\tgotoblas -> cgemv_d\n\n#define\tCGERU_K\t\t\tgotoblas -> cgeru_k\n#define\tCGERC_K\t\t\tgotoblas -> cgerc_k\n#define\tCGERV_K\t\t\tgotoblas -> cgerv_k\n#define\tCGERD_K\t\t\tgotoblas -> cgerd_k\n\n#define CSYMV_U\t\t\tgotoblas -> csymv_U\n#define CSYMV_L\t\t\tgotoblas -> csymv_L\n#define CHEMV_U\t\t\tgotoblas -> chemv_U\n#define CHEMV_L\t\t\tgotoblas -> chemv_L\n#define CHEMV_V\t\t\tgotoblas -> chemv_V\n#define CHEMV_M\t\t\tgotoblas -> chemv_M\n\n#define CSYMV_THREAD_U\t\tcsymv_thread_U\n#define CSYMV_THREAD_L\t\tcsymv_thread_L\n#define CHEMV_THREAD_U\t\tchemv_thread_U\n#define CHEMV_THREAD_L\t\tchemv_thread_L\n#define CHEMV_THREAD_V\t\tchemv_thread_V\n#define CHEMV_THREAD_M\t\tchemv_thread_M\n\n#define\tCGEMM_ONCOPY\t\tgotoblas -> cgemm_oncopy\n#define\tCGEMM_OTCOPY\t\tgotoblas -> cgemm_otcopy\n#define\tCGEMM_INCOPY\t\tgotoblas -> cgemm_incopy\n#define\tCGEMM_ITCOPY\t\tgotoblas -> cgemm_itcopy\n\n#define\tCTRMM_OUNUCOPY\t\tgotoblas -> ctrmm_ounucopy\n#define\tCTRMM_OUTUCOPY\t\tgotoblas -> ctrmm_outucopy\n#define\tCTRMM_OLNUCOPY\t\tgotoblas -> ctrmm_olnucopy\n#define\tCTRMM_OLTUCOPY\t\tgotoblas -> ctrmm_oltucopy\n#define\tCTRSM_OUNUCOPY\t\tgotoblas -> ctrsm_ounucopy\n#define\tCTRSM_OUTUCOPY\t\tgotoblas -> ctrsm_outucopy\n#define\tCTRSM_OLNUCOPY\t\tgotoblas -> ctrsm_olnucopy\n#define\tCTRSM_OLTUCOPY\t\tgotoblas -> ctrsm_oltucopy\n\n#define\tCTRMM_IUNUCOPY\t\tgotoblas -> ctrmm_iunucopy\n#define\tCTRMM_IUTUCOPY\t\tgotoblas -> ctrmm_iutucopy\n#define\tCTRMM_ILNUCOPY\t\tgotoblas -> ctrmm_ilnucopy\n#define\tCTRMM_ILTUCOPY\t\tgotoblas -> ctrmm_iltucopy\n#define\tCTRSM_IUNUCOPY\t\tgotoblas -> ctrsm_iunucopy\n#define\tCTRSM_IUTUCOPY\t\tgotoblas -> ctrsm_iutucopy\n#define\tCTRSM_ILNUCOPY\t\tgotoblas -> ctrsm_ilnucopy\n#define\tCTRSM_ILTUCOPY\t\tgotoblas -> ctrsm_iltucopy\n\n#define\tCTRMM_OUNNCOPY\t\tgotoblas -> ctrmm_ounncopy\n#define\tCTRMM_OUTNCOPY\t\tgotoblas -> ctrmm_outncopy\n#define\tCTRMM_OLNNCOPY\t\tgotoblas -> ctrmm_olnncopy\n#define\tCTRMM_OLTNCOPY\t\tgotoblas -> ctrmm_oltncopy\n#define\tCTRSM_OUNNCOPY\t\tgotoblas -> ctrsm_ounncopy\n#define\tCTRSM_OUTNCOPY\t\tgotoblas -> ctrsm_outncopy\n#define\tCTRSM_OLNNCOPY\t\tgotoblas -> ctrsm_olnncopy\n#define\tCTRSM_OLTNCOPY\t\tgotoblas -> ctrsm_oltncopy\n\n#define\tCTRMM_IUNNCOPY\t\tgotoblas -> ctrmm_iunncopy\n#define\tCTRMM_IUTNCOPY\t\tgotoblas -> ctrmm_iutncopy\n#define\tCTRMM_ILNNCOPY\t\tgotoblas -> ctrmm_ilnncopy\n#define\tCTRMM_ILTNCOPY\t\tgotoblas -> ctrmm_iltncopy\n#define\tCTRSM_IUNNCOPY\t\tgotoblas -> ctrsm_iunncopy\n#define\tCTRSM_IUTNCOPY\t\tgotoblas -> ctrsm_iutncopy\n#define\tCTRSM_ILNNCOPY\t\tgotoblas -> ctrsm_ilnncopy\n#define\tCTRSM_ILTNCOPY\t\tgotoblas -> ctrsm_iltncopy\n\n#define\tCGEMM_BETA\t\tgotoblas -> cgemm_beta\n#define\tCGEMM_KERNEL_N\t\tgotoblas -> cgemm_kernel_n\n#define\tCGEMM_KERNEL_L\t\tgotoblas -> cgemm_kernel_l\n#define\tCGEMM_KERNEL_R\t\tgotoblas -> cgemm_kernel_r\n#define\tCGEMM_KERNEL_B\t\tgotoblas -> cgemm_kernel_b\n\n#define\tCTRMM_KERNEL_LN\t\tgotoblas -> ctrmm_kernel_LN\n#define\tCTRMM_KERNEL_LT\t\tgotoblas -> ctrmm_kernel_LT\n#define\tCTRMM_KERNEL_LR\t\tgotoblas -> ctrmm_kernel_LR\n#define\tCTRMM_KERNEL_LC\t\tgotoblas -> ctrmm_kernel_LC\n#define\tCTRMM_KERNEL_RN\t\tgotoblas -> ctrmm_kernel_RN\n#define\tCTRMM_KERNEL_RT\t\tgotoblas -> ctrmm_kernel_RT\n#define\tCTRMM_KERNEL_RR\t\tgotoblas -> ctrmm_kernel_RR\n#define\tCTRMM_KERNEL_RC\t\tgotoblas -> ctrmm_kernel_RC\n\n#define\tCTRSM_KERNEL_LN\t\tgotoblas -> ctrsm_kernel_LN\n#define\tCTRSM_KERNEL_LT\t\tgotoblas -> ctrsm_kernel_LT\n#define\tCTRSM_KERNEL_LR\t\tgotoblas -> ctrsm_kernel_LR\n#define\tCTRSM_KERNEL_LC\t\tgotoblas -> ctrsm_kernel_LC\n#define\tCTRSM_KERNEL_RN\t\tgotoblas -> ctrsm_kernel_RN\n#define\tCTRSM_KERNEL_RT\t\tgotoblas -> ctrsm_kernel_RT\n#define\tCTRSM_KERNEL_RR\t\tgotoblas -> ctrsm_kernel_RR\n#define\tCTRSM_KERNEL_RC\t\tgotoblas -> ctrsm_kernel_RC\n\n#define\tCSYMM_IUTCOPY\t\tgotoblas -> csymm_iutcopy\n#define\tCSYMM_ILTCOPY\t\tgotoblas -> csymm_iltcopy\n#define\tCSYMM_OUTCOPY\t\tgotoblas -> csymm_outcopy\n#define\tCSYMM_OLTCOPY\t\tgotoblas -> csymm_oltcopy\n\n#define\tCHEMM_OUTCOPY\t\tgotoblas -> chemm_outcopy\n#define\tCHEMM_OLTCOPY\t\tgotoblas -> chemm_oltcopy\n#define\tCHEMM_IUTCOPY\t\tgotoblas -> chemm_iutcopy\n#define\tCHEMM_ILTCOPY\t\tgotoblas -> chemm_iltcopy\n\n#define\tCGEMM3M_ONCOPYB\t\tgotoblas -> cgemm3m_oncopyb\n#define\tCGEMM3M_ONCOPYR\t\tgotoblas -> cgemm3m_oncopyr\n#define\tCGEMM3M_ONCOPYI\t\tgotoblas -> cgemm3m_oncopyi\n#define\tCGEMM3M_OTCOPYB\t\tgotoblas -> cgemm3m_otcopyb\n#define\tCGEMM3M_OTCOPYR\t\tgotoblas -> cgemm3m_otcopyr\n#define\tCGEMM3M_OTCOPYI\t\tgotoblas -> cgemm3m_otcopyi\n\n#define\tCGEMM3M_INCOPYB\t\tgotoblas -> cgemm3m_incopyb\n#define\tCGEMM3M_INCOPYR\t\tgotoblas -> cgemm3m_incopyr\n#define\tCGEMM3M_INCOPYI\t\tgotoblas -> cgemm3m_incopyi\n#define\tCGEMM3M_ITCOPYB\t\tgotoblas -> cgemm3m_itcopyb\n#define\tCGEMM3M_ITCOPYR\t\tgotoblas -> cgemm3m_itcopyr\n#define\tCGEMM3M_ITCOPYI\t\tgotoblas -> cgemm3m_itcopyi\n\n#define\tCSYMM3M_ILCOPYB\t\tgotoblas -> csymm3m_ilcopyb\n#define\tCSYMM3M_IUCOPYB\t\tgotoblas -> csymm3m_iucopyb\n#define\tCSYMM3M_ILCOPYR\t\tgotoblas -> csymm3m_ilcopyr\n#define\tCSYMM3M_IUCOPYR\t\tgotoblas -> csymm3m_iucopyr\n#define\tCSYMM3M_ILCOPYI\t\tgotoblas -> csymm3m_ilcopyi\n#define\tCSYMM3M_IUCOPYI\t\tgotoblas -> csymm3m_iucopyi\n\n#define\tCSYMM3M_OLCOPYB\t\tgotoblas -> csymm3m_olcopyb\n#define\tCSYMM3M_OUCOPYB\t\tgotoblas -> csymm3m_oucopyb\n#define\tCSYMM3M_OLCOPYR\t\tgotoblas -> csymm3m_olcopyr\n#define\tCSYMM3M_OUCOPYR\t\tgotoblas -> csymm3m_oucopyr\n#define\tCSYMM3M_OLCOPYI\t\tgotoblas -> csymm3m_olcopyi\n#define\tCSYMM3M_OUCOPYI\t\tgotoblas -> csymm3m_oucopyi\n\n#define\tCHEMM3M_ILCOPYB\t\tgotoblas -> chemm3m_ilcopyb\n#define\tCHEMM3M_IUCOPYB\t\tgotoblas -> chemm3m_iucopyb\n#define\tCHEMM3M_ILCOPYR\t\tgotoblas -> chemm3m_ilcopyr\n#define\tCHEMM3M_IUCOPYR\t\tgotoblas -> chemm3m_iucopyr\n#define\tCHEMM3M_ILCOPYI\t\tgotoblas -> chemm3m_ilcopyi\n#define\tCHEMM3M_IUCOPYI\t\tgotoblas -> chemm3m_iucopyi\n\n#define\tCHEMM3M_OLCOPYB\t\tgotoblas -> chemm3m_olcopyb\n#define\tCHEMM3M_OUCOPYB\t\tgotoblas -> chemm3m_oucopyb\n#define\tCHEMM3M_OLCOPYR\t\tgotoblas -> chemm3m_olcopyr\n#define\tCHEMM3M_OUCOPYR\t\tgotoblas -> chemm3m_oucopyr\n#define\tCHEMM3M_OLCOPYI\t\tgotoblas -> chemm3m_olcopyi\n#define\tCHEMM3M_OUCOPYI\t\tgotoblas -> chemm3m_oucopyi\n\n#define\tCGEMM3M_KERNEL\t\tgotoblas -> cgemm3m_kernel\n\n#define CNEG_TCOPY\t\tgotoblas -> cneg_tcopy\n#define CLASWP_NCOPY\t\tgotoblas -> claswp_ncopy\n\n#define CAXPBY_K                gotoblas -> caxpby_k\n\n#define COMATCOPY_K_CN          gotoblas -> comatcopy_k_cn\n#define COMATCOPY_K_RN          gotoblas -> comatcopy_k_rn\n#define COMATCOPY_K_CT          gotoblas -> comatcopy_k_ct\n#define COMATCOPY_K_RT          gotoblas -> comatcopy_k_rt\n#define COMATCOPY_K_CNC         gotoblas -> comatcopy_k_cnc\n#define COMATCOPY_K_RNC         gotoblas -> comatcopy_k_rnc\n#define COMATCOPY_K_CTC         gotoblas -> comatcopy_k_ctc\n#define COMATCOPY_K_RTC         gotoblas -> comatcopy_k_rtc\n\n#define CIMATCOPY_K_CN          gotoblas -> cimatcopy_k_cn\n#define CIMATCOPY_K_RN          gotoblas -> cimatcopy_k_rn\n#define CIMATCOPY_K_CT          gotoblas -> cimatcopy_k_ct\n#define CIMATCOPY_K_RT          gotoblas -> cimatcopy_k_rt\n#define CIMATCOPY_K_CNC         gotoblas -> cimatcopy_k_cnc\n#define CIMATCOPY_K_RNC         gotoblas -> cimatcopy_k_rnc\n#define CIMATCOPY_K_CTC         gotoblas -> cimatcopy_k_ctc\n#define CIMATCOPY_K_RTC         gotoblas -> cimatcopy_k_rtc\n\n#define CGEADD_K                gotoblas -> cgeadd_k \n\n#define CGEMM_SMALL_MATRIX_PERMIT\tgotoblas -> cgemm_small_matrix_permit\n\n#endif\n\n#define CGEMM_SMALL_KERNEL_NN\t\tFUNC_OFFSET(cgemm_small_kernel_nn)\n#define CGEMM_SMALL_KERNEL_NT\t\tFUNC_OFFSET(cgemm_small_kernel_nt)\n#define CGEMM_SMALL_KERNEL_NR\t\tFUNC_OFFSET(cgemm_small_kernel_nr)\n#define CGEMM_SMALL_KERNEL_NC\t\tFUNC_OFFSET(cgemm_small_kernel_nc)\n\n#define CGEMM_SMALL_KERNEL_TN\t\tFUNC_OFFSET(cgemm_small_kernel_tn)\n#define CGEMM_SMALL_KERNEL_TT\t\tFUNC_OFFSET(cgemm_small_kernel_tt)\n#define CGEMM_SMALL_KERNEL_TR\t\tFUNC_OFFSET(cgemm_small_kernel_tr)\n#define CGEMM_SMALL_KERNEL_TC\t\tFUNC_OFFSET(cgemm_small_kernel_tc)\n\n#define CGEMM_SMALL_KERNEL_RN\t\tFUNC_OFFSET(cgemm_small_kernel_rn)\n#define CGEMM_SMALL_KERNEL_RT\t\tFUNC_OFFSET(cgemm_small_kernel_rt)\n#define CGEMM_SMALL_KERNEL_RR\t\tFUNC_OFFSET(cgemm_small_kernel_rr)\n#define CGEMM_SMALL_KERNEL_RC\t\tFUNC_OFFSET(cgemm_small_kernel_rc)\n\n#define CGEMM_SMALL_KERNEL_CN\t\tFUNC_OFFSET(cgemm_small_kernel_cn)\n#define CGEMM_SMALL_KERNEL_CT\t\tFUNC_OFFSET(cgemm_small_kernel_ct)\n#define CGEMM_SMALL_KERNEL_CR\t\tFUNC_OFFSET(cgemm_small_kernel_cr)\n#define CGEMM_SMALL_KERNEL_CC\t\tFUNC_OFFSET(cgemm_small_kernel_cc)\n\n#define CGEMM_SMALL_KERNEL_B0_NN\tFUNC_OFFSET(cgemm_small_kernel_b0_nn)\n#define CGEMM_SMALL_KERNEL_B0_NT\tFUNC_OFFSET(cgemm_small_kernel_b0_nt)\n#define CGEMM_SMALL_KERNEL_B0_NR\tFUNC_OFFSET(cgemm_small_kernel_b0_nr)\n#define CGEMM_SMALL_KERNEL_B0_NC\tFUNC_OFFSET(cgemm_small_kernel_b0_nc)\n\n#define CGEMM_SMALL_KERNEL_B0_TN\tFUNC_OFFSET(cgemm_small_kernel_b0_tn)\n#define CGEMM_SMALL_KERNEL_B0_TT\tFUNC_OFFSET(cgemm_small_kernel_b0_tt)\n#define CGEMM_SMALL_KERNEL_B0_TR\tFUNC_OFFSET(cgemm_small_kernel_b0_tr)\n#define CGEMM_SMALL_KERNEL_B0_TC\tFUNC_OFFSET(cgemm_small_kernel_b0_tc)\n\n#define CGEMM_SMALL_KERNEL_B0_RN\tFUNC_OFFSET(cgemm_small_kernel_b0_rn)\n#define CGEMM_SMALL_KERNEL_B0_RT\tFUNC_OFFSET(cgemm_small_kernel_b0_rt)\n#define CGEMM_SMALL_KERNEL_B0_RR\tFUNC_OFFSET(cgemm_small_kernel_b0_rr)\n#define CGEMM_SMALL_KERNEL_B0_RC\tFUNC_OFFSET(cgemm_small_kernel_b0_rc)\n\n#define CGEMM_SMALL_KERNEL_B0_CN\tFUNC_OFFSET(cgemm_small_kernel_b0_cn)\n#define CGEMM_SMALL_KERNEL_B0_CT\tFUNC_OFFSET(cgemm_small_kernel_b0_ct)\n#define CGEMM_SMALL_KERNEL_B0_CR\tFUNC_OFFSET(cgemm_small_kernel_b0_cr)\n#define CGEMM_SMALL_KERNEL_B0_CC\tFUNC_OFFSET(cgemm_small_kernel_b0_cc)\n\n\n#define\tCGEMM_NN\t\tcgemm_nn\n#define\tCGEMM_CN\t\tcgemm_cn\n#define\tCGEMM_TN\t\tcgemm_tn\n#define\tCGEMM_NC\t\tcgemm_nc\n#define\tCGEMM_NT\t\tcgemm_nt\n#define\tCGEMM_CC\t\tcgemm_cc\n#define\tCGEMM_CT\t\tcgemm_ct\n#define\tCGEMM_TC\t\tcgemm_tc\n#define\tCGEMM_TT\t\tcgemm_tt\n#define\tCGEMM_NR\t\tcgemm_nr\n#define\tCGEMM_TR\t\tcgemm_tr\n#define\tCGEMM_CR\t\tcgemm_cr\n#define\tCGEMM_RN\t\tcgemm_rn\n#define\tCGEMM_RT\t\tcgemm_rt\n#define\tCGEMM_RC\t\tcgemm_rc\n#define\tCGEMM_RR\t\tcgemm_rr\n\n#define\tCSYMM_LU\t\tcsymm_LU\n#define\tCSYMM_LL\t\tcsymm_LL\n#define\tCSYMM_RU\t\tcsymm_RU\n#define\tCSYMM_RL\t\tcsymm_RL\n\n#define\tCHEMM_LU\t\tchemm_LU\n#define\tCHEMM_LL\t\tchemm_LL\n#define\tCHEMM_RU\t\tchemm_RU\n#define\tCHEMM_RL\t\tchemm_RL\n\n#define\tCSYRK_UN\t\tcsyrk_UN\n#define\tCSYRK_UT\t\tcsyrk_UT\n#define\tCSYRK_LN\t\tcsyrk_LN\n#define\tCSYRK_LT\t\tcsyrk_LT\n#define\tCSYRK_UR\t\tcsyrk_UN\n#define\tCSYRK_UC\t\tcsyrk_UT\n#define\tCSYRK_LR\t\tcsyrk_LN\n#define\tCSYRK_LC\t\tcsyrk_LT\n\n#define\tCSYRK_KERNEL_U\t\tcsyrk_kernel_U\n#define\tCSYRK_KERNEL_L\t\tcsyrk_kernel_L\n\n#define\tCHERK_UN\t\tcherk_UN\n#define\tCHERK_LN\t\tcherk_LN\n#define\tCHERK_UC\t\tcherk_UC\n#define\tCHERK_LC\t\tcherk_LC\n\n#define\tCHER2K_UN\t\tcher2k_UN\n#define\tCHER2K_LN\t\tcher2k_LN\n#define\tCHER2K_UC\t\tcher2k_UC\n#define\tCHER2K_LC\t\tcher2k_LC\n\n#define\tCSYR2K_UN\t\tcsyr2k_UN\n#define\tCSYR2K_UT\t\tcsyr2k_UT\n#define\tCSYR2K_LN\t\tcsyr2k_LN\n#define\tCSYR2K_LT\t\tcsyr2k_LT\n#define\tCSYR2K_UR\t\tcsyr2k_UN\n#define\tCSYR2K_UC\t\tcsyr2k_UT\n#define\tCSYR2K_LR\t\tcsyr2k_LN\n#define\tCSYR2K_LC\t\tcsyr2k_LT\n\n#define\tCSYR2K_KERNEL_U\t\tcsyr2k_kernel_U\n#define\tCSYR2K_KERNEL_L\t\tcsyr2k_kernel_L\n\n#define\tCTRMM_LNUU\t\tctrmm_LNUU\n#define\tCTRMM_LNUN\t\tctrmm_LNUN\n#define\tCTRMM_LNLU\t\tctrmm_LNLU\n#define\tCTRMM_LNLN\t\tctrmm_LNLN\n#define\tCTRMM_LTUU\t\tctrmm_LTUU\n#define\tCTRMM_LTUN\t\tctrmm_LTUN\n#define\tCTRMM_LTLU\t\tctrmm_LTLU\n#define\tCTRMM_LTLN\t\tctrmm_LTLN\n#define\tCTRMM_LRUU\t\tctrmm_LRUU\n#define\tCTRMM_LRUN\t\tctrmm_LRUN\n#define\tCTRMM_LRLU\t\tctrmm_LRLU\n#define\tCTRMM_LRLN\t\tctrmm_LRLN\n#define\tCTRMM_LCUU\t\tctrmm_LCUU\n#define\tCTRMM_LCUN\t\tctrmm_LCUN\n#define\tCTRMM_LCLU\t\tctrmm_LCLU\n#define\tCTRMM_LCLN\t\tctrmm_LCLN\n#define\tCTRMM_RNUU\t\tctrmm_RNUU\n#define\tCTRMM_RNUN\t\tctrmm_RNUN\n#define\tCTRMM_RNLU\t\tctrmm_RNLU\n#define\tCTRMM_RNLN\t\tctrmm_RNLN\n#define\tCTRMM_RTUU\t\tctrmm_RTUU\n#define\tCTRMM_RTUN\t\tctrmm_RTUN\n#define\tCTRMM_RTLU\t\tctrmm_RTLU\n#define\tCTRMM_RTLN\t\tctrmm_RTLN\n#define\tCTRMM_RRUU\t\tctrmm_RRUU\n#define\tCTRMM_RRUN\t\tctrmm_RRUN\n#define\tCTRMM_RRLU\t\tctrmm_RRLU\n#define\tCTRMM_RRLN\t\tctrmm_RRLN\n#define\tCTRMM_RCUU\t\tctrmm_RCUU\n#define\tCTRMM_RCUN\t\tctrmm_RCUN\n#define\tCTRMM_RCLU\t\tctrmm_RCLU\n#define\tCTRMM_RCLN\t\tctrmm_RCLN\n\n#define\tCTRSM_LNUU\t\tctrsm_LNUU\n#define\tCTRSM_LNUN\t\tctrsm_LNUN\n#define\tCTRSM_LNLU\t\tctrsm_LNLU\n#define\tCTRSM_LNLN\t\tctrsm_LNLN\n#define\tCTRSM_LTUU\t\tctrsm_LTUU\n#define\tCTRSM_LTUN\t\tctrsm_LTUN\n#define\tCTRSM_LTLU\t\tctrsm_LTLU\n#define\tCTRSM_LTLN\t\tctrsm_LTLN\n#define\tCTRSM_LRUU\t\tctrsm_LRUU\n#define\tCTRSM_LRUN\t\tctrsm_LRUN\n#define\tCTRSM_LRLU\t\tctrsm_LRLU\n#define\tCTRSM_LRLN\t\tctrsm_LRLN\n#define\tCTRSM_LCUU\t\tctrsm_LCUU\n#define\tCTRSM_LCUN\t\tctrsm_LCUN\n#define\tCTRSM_LCLU\t\tctrsm_LCLU\n#define\tCTRSM_LCLN\t\tctrsm_LCLN\n#define\tCTRSM_RNUU\t\tctrsm_RNUU\n#define\tCTRSM_RNUN\t\tctrsm_RNUN\n#define\tCTRSM_RNLU\t\tctrsm_RNLU\n#define\tCTRSM_RNLN\t\tctrsm_RNLN\n#define\tCTRSM_RTUU\t\tctrsm_RTUU\n#define\tCTRSM_RTUN\t\tctrsm_RTUN\n#define\tCTRSM_RTLU\t\tctrsm_RTLU\n#define\tCTRSM_RTLN\t\tctrsm_RTLN\n#define\tCTRSM_RRUU\t\tctrsm_RRUU\n#define\tCTRSM_RRUN\t\tctrsm_RRUN\n#define\tCTRSM_RRLU\t\tctrsm_RRLU\n#define\tCTRSM_RRLN\t\tctrsm_RRLN\n#define\tCTRSM_RCUU\t\tctrsm_RCUU\n#define\tCTRSM_RCUN\t\tctrsm_RCUN\n#define\tCTRSM_RCLU\t\tctrsm_RCLU\n#define\tCTRSM_RCLN\t\tctrsm_RCLN\n\n#define\tCGEMM_THREAD_NN\t\tcgemm_thread_nn\n#define\tCGEMM_THREAD_CN\t\tcgemm_thread_cn\n#define\tCGEMM_THREAD_TN\t\tcgemm_thread_tn\n#define\tCGEMM_THREAD_NC\t\tcgemm_thread_nc\n#define\tCGEMM_THREAD_NT\t\tcgemm_thread_nt\n#define\tCGEMM_THREAD_CC\t\tcgemm_thread_cc\n#define\tCGEMM_THREAD_CT\t\tcgemm_thread_ct\n#define\tCGEMM_THREAD_TC\t\tcgemm_thread_tc\n#define\tCGEMM_THREAD_TT\t\tcgemm_thread_tt\n#define\tCGEMM_THREAD_NR\t\tcgemm_thread_nr\n#define\tCGEMM_THREAD_TR\t\tcgemm_thread_tr\n#define\tCGEMM_THREAD_CR\t\tcgemm_thread_cr\n#define\tCGEMM_THREAD_RN\t\tcgemm_thread_rn\n#define\tCGEMM_THREAD_RT\t\tcgemm_thread_rt\n#define\tCGEMM_THREAD_RC\t\tcgemm_thread_rc\n#define\tCGEMM_THREAD_RR\t\tcgemm_thread_rr\n\n#define\tCSYMM_THREAD_LU\t\tcsymm_thread_LU\n#define\tCSYMM_THREAD_LL\t\tcsymm_thread_LL\n#define\tCSYMM_THREAD_RU\t\tcsymm_thread_RU\n#define\tCSYMM_THREAD_RL\t\tcsymm_thread_RL\n\n#define\tCHEMM_THREAD_LU\t\tchemm_thread_LU\n#define\tCHEMM_THREAD_LL\t\tchemm_thread_LL\n#define\tCHEMM_THREAD_RU\t\tchemm_thread_RU\n#define\tCHEMM_THREAD_RL\t\tchemm_thread_RL\n\n#define\tCSYRK_THREAD_UN\t\tcsyrk_thread_UN\n#define\tCSYRK_THREAD_UT\t\tcsyrk_thread_UT\n#define\tCSYRK_THREAD_LN\t\tcsyrk_thread_LN\n#define\tCSYRK_THREAD_LT\t\tcsyrk_thread_LT\n#define\tCSYRK_THREAD_UR\t\tcsyrk_thread_UN\n#define\tCSYRK_THREAD_UC\t\tcsyrk_thread_UT\n#define\tCSYRK_THREAD_LR\t\tcsyrk_thread_LN\n#define\tCSYRK_THREAD_LC\t\tcsyrk_thread_LT\n\n#define\tCHERK_THREAD_UN\t\tcherk_thread_UN\n#define\tCHERK_THREAD_UT\t\tcherk_thread_UT\n#define\tCHERK_THREAD_LN\t\tcherk_thread_LN\n#define\tCHERK_THREAD_LT\t\tcherk_thread_LT\n#define\tCHERK_THREAD_UR\t\tcherk_thread_UR\n#define\tCHERK_THREAD_UC\t\tcherk_thread_UC\n#define\tCHERK_THREAD_LR\t\tcherk_thread_LR\n#define\tCHERK_THREAD_LC\t\tcherk_thread_LC\n\n#define\tCGEMM3M_NN\t\tcgemm3m_nn\n#define\tCGEMM3M_CN\t\tcgemm3m_cn\n#define\tCGEMM3M_TN\t\tcgemm3m_tn\n#define\tCGEMM3M_NC\t\tcgemm3m_nc\n#define\tCGEMM3M_NT\t\tcgemm3m_nt\n#define\tCGEMM3M_CC\t\tcgemm3m_cc\n#define\tCGEMM3M_CT\t\tcgemm3m_ct\n#define\tCGEMM3M_TC\t\tcgemm3m_tc\n#define\tCGEMM3M_TT\t\tcgemm3m_tt\n#define\tCGEMM3M_NR\t\tcgemm3m_nr\n#define\tCGEMM3M_TR\t\tcgemm3m_tr\n#define\tCGEMM3M_CR\t\tcgemm3m_cr\n#define\tCGEMM3M_RN\t\tcgemm3m_rn\n#define\tCGEMM3M_RT\t\tcgemm3m_rt\n#define\tCGEMM3M_RC\t\tcgemm3m_rc\n#define\tCGEMM3M_RR\t\tcgemm3m_rr\n\n#define\tCGEMM3M_THREAD_NN\tcgemm3m_thread_nn\n#define\tCGEMM3M_THREAD_CN\tcgemm3m_thread_cn\n#define\tCGEMM3M_THREAD_TN\tcgemm3m_thread_tn\n#define\tCGEMM3M_THREAD_NC\tcgemm3m_thread_nc\n#define\tCGEMM3M_THREAD_NT\tcgemm3m_thread_nt\n#define\tCGEMM3M_THREAD_CC\tcgemm3m_thread_cc\n#define\tCGEMM3M_THREAD_CT\tcgemm3m_thread_ct\n#define\tCGEMM3M_THREAD_TC\tcgemm3m_thread_tc\n#define\tCGEMM3M_THREAD_TT\tcgemm3m_thread_tt\n#define\tCGEMM3M_THREAD_NR\tcgemm3m_thread_nr\n#define\tCGEMM3M_THREAD_TR\tcgemm3m_thread_tr\n#define\tCGEMM3M_THREAD_CR\tcgemm3m_thread_cr\n#define\tCGEMM3M_THREAD_RN\tcgemm3m_thread_rn\n#define\tCGEMM3M_THREAD_RT\tcgemm3m_thread_rt\n#define\tCGEMM3M_THREAD_RC\tcgemm3m_thread_rc\n#define\tCGEMM3M_THREAD_RR\tcgemm3m_thread_rr\n\n#define\tCSYMM3M_LU\t\tcsymm3m_LU\n#define\tCSYMM3M_LL\t\tcsymm3m_LL\n#define\tCSYMM3M_RU\t\tcsymm3m_RU\n#define\tCSYMM3M_RL\t\tcsymm3m_RL\n\n#define\tCSYMM3M_THREAD_LU\tcsymm3m_thread_LU\n#define\tCSYMM3M_THREAD_LL\tcsymm3m_thread_LL\n#define\tCSYMM3M_THREAD_RU\tcsymm3m_thread_RU\n#define\tCSYMM3M_THREAD_RL\tcsymm3m_thread_RL\n\n#define\tCHEMM3M_LU\t\tchemm3m_LU\n#define\tCHEMM3M_LL\t\tchemm3m_LL\n#define\tCHEMM3M_RU\t\tchemm3m_RU\n#define\tCHEMM3M_RL\t\tchemm3m_RL\n\n#define\tCHEMM3M_THREAD_LU\tchemm3m_thread_LU\n#define\tCHEMM3M_THREAD_LL\tchemm3m_thread_LL\n#define\tCHEMM3M_THREAD_RU\tchemm3m_thread_RU\n#define\tCHEMM3M_THREAD_RL\tchemm3m_thread_RL\n\n#endif\n"
        },
        {
          "name": "common_csky.h",
          "type": "blob",
          "size": 1.9990234375,
          "content": "/*****************************************************************************\nCopyright (c) 2011-2015, The OpenBLAS Project\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   1. Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n\n   2. Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in\n      the documentation and/or other materials provided with the\n      distribution.\n   3. Neither the name of the OpenBLAS project nor the names of \n      its contributors may be used to endorse or promote products \n      derived from this software without specific prior written \n      permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\nUSE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n**********************************************************************************/\n\n#ifndef COMMON_CSKY\n#define COMMON_CSKY\n\n#define MB  __sync_synchronize()\n#define WMB __sync_synchronize()\n#define RMB __sync_synchronize()\n\n#define INLINE inline\n\n#ifndef ASSEMBLER\n\n\nstatic inline int blas_quickdivide(blasint x, blasint y){\n  return x / y;\n}\n\n#endif\n\n\n\n#define BUFFER_SIZE     ( 32 << 20)\n#define SEEK_ADDRESS\n\n#endif"
        },
        {
          "name": "common_d.h",
          "type": "blob",
          "size": 15.0322265625,
          "content": "#ifndef COMMON_D_H\n#define COMMON_D_H\n\n#ifndef DYNAMIC_ARCH\n\n#define\tDAMAX_K\t\t\tdamax_k\n#define\tDAMIN_K\t\t\tdamin_k\n#define\tDMAX_K\t\t\tdmax_k\n#define\tDMIN_K\t\t\tdmin_k\n#define\tIDAMAX_K\t\tidamax_k\n#define\tIDAMIN_K\t\tidamin_k\n#define\tIDMAX_K\t\t\tidmax_k\n#define\tIDMIN_K\t\t\tidmin_k\n#define\tDASUM_K\t\t\tdasum_k\n#define\tDAXPYU_K\t\tdaxpy_k\n#define\tDAXPYC_K\t\tdaxpy_k\n#define\tDCOPY_K\t\t\tdcopy_k\n#define\tDDOTU_K\t\t\tddot_k\n#define\tDDOTC_K\t\t\tddot_k\n#define\tDNRM2_K\t\t\tdnrm2_k\n#define\tDSCAL_K\t\t\tdscal_k\n#define\tDSUM_K\t\t\tdsum_k\n#define\tDSWAP_K\t\t\tdswap_k\n#define\tDROT_K\t\t\tdrot_k\n\n#define\tDGEMV_N\t\t\tdgemv_n\n#define\tDGEMV_T\t\t\tdgemv_t\n#define\tDGEMV_R\t\t\tdgemv_n\n#define\tDGEMV_C\t\t\tdgemv_t\n#define\tDGEMV_O\t\t\tdgemv_n\n#define\tDGEMV_U\t\t\tdgemv_t\n#define\tDGEMV_S\t\t\tdgemv_n\n#define\tDGEMV_D\t\t\tdgemv_t\n\n#define\tDGERU_K\t\t\tdger_k\n#define\tDGERC_K\t\t\tdger_k\n#define\tDGERV_K\t\t\tdger_k\n#define\tDGERD_K\t\t\tdger_k\n\n#define DSYMV_U\t\t\tdsymv_U\n#define DSYMV_L\t\t\tdsymv_L\n\n#define DSYMV_THREAD_U\t\tdsymv_thread_U\n#define DSYMV_THREAD_L\t\tdsymv_thread_L\n\n#define\tDGEMM_ONCOPY\t\tdgemm_oncopy\n#define\tDGEMM_OTCOPY\t\tdgemm_otcopy\n\n#if DGEMM_DEFAULT_UNROLL_M == DGEMM_DEFAULT_UNROLL_N\n#define\tDGEMM_INCOPY\t\tdgemm_oncopy\n#define\tDGEMM_ITCOPY\t\tdgemm_otcopy\n#else\n#define\tDGEMM_INCOPY\t\tdgemm_incopy\n#define\tDGEMM_ITCOPY\t\tdgemm_itcopy\n#endif\n\n#define\tDTRMM_OUNUCOPY\t\tdtrmm_ounucopy\n#define\tDTRMM_OUNNCOPY\t\tdtrmm_ounncopy\n#define\tDTRMM_OUTUCOPY\t\tdtrmm_outucopy\n#define\tDTRMM_OUTNCOPY\t\tdtrmm_outncopy\n#define\tDTRMM_OLNUCOPY\t\tdtrmm_olnucopy\n#define\tDTRMM_OLNNCOPY\t\tdtrmm_olnncopy\n#define\tDTRMM_OLTUCOPY\t\tdtrmm_oltucopy\n#define\tDTRMM_OLTNCOPY\t\tdtrmm_oltncopy\n\n#define\tDTRSM_OUNUCOPY\t\tdtrsm_ounucopy\n#define\tDTRSM_OUNNCOPY\t\tdtrsm_ounncopy\n#define\tDTRSM_OUTUCOPY\t\tdtrsm_outucopy\n#define\tDTRSM_OUTNCOPY\t\tdtrsm_outncopy\n#define\tDTRSM_OLNUCOPY\t\tdtrsm_olnucopy\n#define\tDTRSM_OLNNCOPY\t\tdtrsm_olnncopy\n#define\tDTRSM_OLTUCOPY\t\tdtrsm_oltucopy\n#define\tDTRSM_OLTNCOPY\t\tdtrsm_oltncopy\n\n#if DGEMM_DEFAULT_UNROLL_M == DGEMM_DEFAULT_UNROLL_N\n#define\tDTRMM_IUNUCOPY\t\tdtrmm_ounucopy\n#define\tDTRMM_IUNNCOPY\t\tdtrmm_ounncopy\n#define\tDTRMM_IUTUCOPY\t\tdtrmm_outucopy\n#define\tDTRMM_IUTNCOPY\t\tdtrmm_outncopy\n#define\tDTRMM_ILNUCOPY\t\tdtrmm_olnucopy\n#define\tDTRMM_ILNNCOPY\t\tdtrmm_olnncopy\n#define\tDTRMM_ILTUCOPY\t\tdtrmm_oltucopy\n#define\tDTRMM_ILTNCOPY\t\tdtrmm_oltncopy\n\n#define\tDTRSM_IUNUCOPY\t\tdtrsm_ounucopy\n#define\tDTRSM_IUNNCOPY\t\tdtrsm_ounncopy\n#define\tDTRSM_IUTUCOPY\t\tdtrsm_outucopy\n#define\tDTRSM_IUTNCOPY\t\tdtrsm_outncopy\n#define\tDTRSM_ILNUCOPY\t\tdtrsm_olnucopy\n#define\tDTRSM_ILNNCOPY\t\tdtrsm_olnncopy\n#define\tDTRSM_ILTUCOPY\t\tdtrsm_oltucopy\n#define\tDTRSM_ILTNCOPY\t\tdtrsm_oltncopy\n#else\n#define\tDTRMM_IUNUCOPY\t\tdtrmm_iunucopy\n#define\tDTRMM_IUNNCOPY\t\tdtrmm_iunncopy\n#define\tDTRMM_IUTUCOPY\t\tdtrmm_iutucopy\n#define\tDTRMM_IUTNCOPY\t\tdtrmm_iutncopy\n#define\tDTRMM_ILNUCOPY\t\tdtrmm_ilnucopy\n#define\tDTRMM_ILNNCOPY\t\tdtrmm_ilnncopy\n#define\tDTRMM_ILTUCOPY\t\tdtrmm_iltucopy\n#define\tDTRMM_ILTNCOPY\t\tdtrmm_iltncopy\n\n#define\tDTRSM_IUNUCOPY\t\tdtrsm_iunucopy\n#define\tDTRSM_IUNNCOPY\t\tdtrsm_iunncopy\n#define\tDTRSM_IUTUCOPY\t\tdtrsm_iutucopy\n#define\tDTRSM_IUTNCOPY\t\tdtrsm_iutncopy\n#define\tDTRSM_ILNUCOPY\t\tdtrsm_ilnucopy\n#define\tDTRSM_ILNNCOPY\t\tdtrsm_ilnncopy\n#define\tDTRSM_ILTUCOPY\t\tdtrsm_iltucopy\n#define\tDTRSM_ILTNCOPY\t\tdtrsm_iltncopy\n#endif\n\n#define\tDGEMM_BETA\t\tdgemm_beta\n\n#define\tDGEMM_KERNEL\t\tdgemm_kernel\n\n#define\tDTRMM_KERNEL_LN\t\tdtrmm_kernel_LN\n#define\tDTRMM_KERNEL_LT\t\tdtrmm_kernel_LT\n#define\tDTRMM_KERNEL_LR\t\tdtrmm_kernel_LN\n#define\tDTRMM_KERNEL_LC\t\tdtrmm_kernel_LT\n#define\tDTRMM_KERNEL_RN\t\tdtrmm_kernel_RN\n#define\tDTRMM_KERNEL_RT\t\tdtrmm_kernel_RT\n#define\tDTRMM_KERNEL_RR\t\tdtrmm_kernel_RN\n#define\tDTRMM_KERNEL_RC\t\tdtrmm_kernel_RT\n\n#define\tDTRSM_KERNEL_LN\t\tdtrsm_kernel_LN\n#define\tDTRSM_KERNEL_LT\t\tdtrsm_kernel_LT\n#define\tDTRSM_KERNEL_LR\t\tdtrsm_kernel_LN\n#define\tDTRSM_KERNEL_LC\t\tdtrsm_kernel_LT\n#define\tDTRSM_KERNEL_RN\t\tdtrsm_kernel_RN\n#define\tDTRSM_KERNEL_RT\t\tdtrsm_kernel_RT\n#define\tDTRSM_KERNEL_RR\t\tdtrsm_kernel_RN\n#define\tDTRSM_KERNEL_RC\t\tdtrsm_kernel_RT\n\n#define\tDSYMM_OUTCOPY\t\tdsymm_outcopy\n#define\tDSYMM_OLTCOPY\t\tdsymm_oltcopy\n#if DGEMM_DEFAULT_UNROLL_M == DGEMM_DEFAULT_UNROLL_N\n#define\tDSYMM_IUTCOPY\t\tdsymm_outcopy\n#define\tDSYMM_ILTCOPY\t\tdsymm_oltcopy\n#else\n#define\tDSYMM_IUTCOPY\t\tdsymm_iutcopy\n#define\tDSYMM_ILTCOPY\t\tdsymm_iltcopy\n#endif\n\n#define DNEG_TCOPY\t\tdneg_tcopy\n#define DLASWP_NCOPY\t\tdlaswp_ncopy\n\n#define\tDAXPBY_K\t\tdaxpby_k\n#define DOMATCOPY_K_CN\t\tdomatcopy_k_cn\n#define DOMATCOPY_K_RN\t\tdomatcopy_k_rn\n#define DOMATCOPY_K_CT\t\tdomatcopy_k_ct\n#define DOMATCOPY_K_RT\t\tdomatcopy_k_rt\n\n#define DIMATCOPY_K_CN\t\tdimatcopy_k_cn\n#define DIMATCOPY_K_RN\t\tdimatcopy_k_rn\n#define DIMATCOPY_K_CT      dimatcopy_k_ct\n#define DIMATCOPY_K_RT      dimatcopy_k_rt\n#define DGEADD_K                dgeadd_k \n\n#define DGEMM_SMALL_MATRIX_PERMIT\tdgemm_small_matrix_permit\n\n#else\n\n#define\tDAMAX_K\t\t\tgotoblas -> damax_k\n#define\tDAMIN_K\t\t\tgotoblas -> damin_k\n#define\tDMAX_K\t\t\tgotoblas -> dmax_k\n#define\tDMIN_K\t\t\tgotoblas -> dmin_k\n#define\tIDAMAX_K\t\tgotoblas -> idamax_k\n#define\tIDAMIN_K\t\tgotoblas -> idamin_k\n#define\tIDMAX_K\t\t\tgotoblas -> idmax_k\n#define\tIDMIN_K\t\t\tgotoblas -> idmin_k\n#define\tDASUM_K\t\t\tgotoblas -> dasum_k\n#define\tDAXPYU_K\t\tgotoblas -> daxpy_k\n#define\tDAXPYC_K\t\tgotoblas -> daxpy_k\n#define\tDCOPY_K\t\t\tgotoblas -> dcopy_k\n#define\tDDOTU_K\t\t\tgotoblas -> ddot_k\n#define\tDDOTC_K\t\t\tgotoblas -> ddot_k\n#define\tDNRM2_K\t\t\tgotoblas -> dnrm2_k\n#define\tDSCAL_K\t\t\tgotoblas -> dscal_k\n#define\tDSUM_K\t\t\tgotoblas -> dsum_k\n#define\tDSWAP_K\t\t\tgotoblas -> dswap_k\n#define\tDROT_K\t\t\tgotoblas -> drot_k\n\n#define\tDGEMV_N\t\t\tgotoblas -> dgemv_n\n#define\tDGEMV_T\t\t\tgotoblas -> dgemv_t\n#define\tDGEMV_R\t\t\tgotoblas -> dgemv_n\n#define\tDGEMV_C\t\t\tgotoblas -> dgemv_t\n#define\tDGEMV_O\t\t\tgotoblas -> dgemv_n\n#define\tDGEMV_U\t\t\tgotoblas -> dgemv_t\n#define\tDGEMV_S\t\t\tgotoblas -> dgemv_n\n#define\tDGEMV_D\t\t\tgotoblas -> dgemv_t\n\n#define\tDGERU_K\t\t\tgotoblas -> dger_k\n#define\tDGERC_K\t\t\tgotoblas -> dger_k\n#define\tDGERV_K\t\t\tgotoblas -> dger_k\n#define\tDGERD_K\t\t\tgotoblas -> dger_k\n\n#define DSYMV_U\t\t\tgotoblas -> dsymv_U\n#define DSYMV_L\t\t\tgotoblas -> dsymv_L\n\n#define DSYMV_THREAD_U\t\tdsymv_thread_U\n#define DSYMV_THREAD_L\t\tdsymv_thread_L\n\n#define\tDGEMM_ONCOPY\t\tgotoblas -> dgemm_oncopy\n#define\tDGEMM_OTCOPY\t\tgotoblas -> dgemm_otcopy\n#define\tDGEMM_INCOPY\t\tgotoblas -> dgemm_incopy\n#define\tDGEMM_ITCOPY\t\tgotoblas -> dgemm_itcopy\n\n#define\tDTRMM_OUNUCOPY\t\tgotoblas -> dtrmm_ounucopy\n#define\tDTRMM_OUTUCOPY\t\tgotoblas -> dtrmm_outucopy\n#define\tDTRMM_OLNUCOPY\t\tgotoblas -> dtrmm_olnucopy\n#define\tDTRMM_OLTUCOPY\t\tgotoblas -> dtrmm_oltucopy\n#define\tDTRSM_OUNUCOPY\t\tgotoblas -> dtrsm_ounucopy\n#define\tDTRSM_OUTUCOPY\t\tgotoblas -> dtrsm_outucopy\n#define\tDTRSM_OLNUCOPY\t\tgotoblas -> dtrsm_olnucopy\n#define\tDTRSM_OLTUCOPY\t\tgotoblas -> dtrsm_oltucopy\n\n#define\tDTRMM_IUNUCOPY\t\tgotoblas -> dtrmm_iunucopy\n#define\tDTRMM_IUTUCOPY\t\tgotoblas -> dtrmm_iutucopy\n#define\tDTRMM_ILNUCOPY\t\tgotoblas -> dtrmm_ilnucopy\n#define\tDTRMM_ILTUCOPY\t\tgotoblas -> dtrmm_iltucopy\n#define\tDTRSM_IUNUCOPY\t\tgotoblas -> dtrsm_iunucopy\n#define\tDTRSM_IUTUCOPY\t\tgotoblas -> dtrsm_iutucopy\n#define\tDTRSM_ILNUCOPY\t\tgotoblas -> dtrsm_ilnucopy\n#define\tDTRSM_ILTUCOPY\t\tgotoblas -> dtrsm_iltucopy\n\n#define\tDTRMM_OUNNCOPY\t\tgotoblas -> dtrmm_ounncopy\n#define\tDTRMM_OUTNCOPY\t\tgotoblas -> dtrmm_outncopy\n#define\tDTRMM_OLNNCOPY\t\tgotoblas -> dtrmm_olnncopy\n#define\tDTRMM_OLTNCOPY\t\tgotoblas -> dtrmm_oltncopy\n#define\tDTRSM_OUNNCOPY\t\tgotoblas -> dtrsm_ounncopy\n#define\tDTRSM_OUTNCOPY\t\tgotoblas -> dtrsm_outncopy\n#define\tDTRSM_OLNNCOPY\t\tgotoblas -> dtrsm_olnncopy\n#define\tDTRSM_OLTNCOPY\t\tgotoblas -> dtrsm_oltncopy\n\n#define\tDTRMM_IUNNCOPY\t\tgotoblas -> dtrmm_iunncopy\n#define\tDTRMM_IUTNCOPY\t\tgotoblas -> dtrmm_iutncopy\n#define\tDTRMM_ILNNCOPY\t\tgotoblas -> dtrmm_ilnncopy\n#define\tDTRMM_ILTNCOPY\t\tgotoblas -> dtrmm_iltncopy\n#define\tDTRSM_IUNNCOPY\t\tgotoblas -> dtrsm_iunncopy\n#define\tDTRSM_IUTNCOPY\t\tgotoblas -> dtrsm_iutncopy\n#define\tDTRSM_ILNNCOPY\t\tgotoblas -> dtrsm_ilnncopy\n#define\tDTRSM_ILTNCOPY\t\tgotoblas -> dtrsm_iltncopy\n\n#define\tDGEMM_BETA\t\tgotoblas -> dgemm_beta\n#define\tDGEMM_KERNEL\t\tgotoblas -> dgemm_kernel\n\n#define\tDTRMM_KERNEL_LN\t\tgotoblas -> dtrmm_kernel_LN\n#define\tDTRMM_KERNEL_LT\t\tgotoblas -> dtrmm_kernel_LT\n#define\tDTRMM_KERNEL_LR\t\tgotoblas -> dtrmm_kernel_LN\n#define\tDTRMM_KERNEL_LC\t\tgotoblas -> dtrmm_kernel_LT\n#define\tDTRMM_KERNEL_RN\t\tgotoblas -> dtrmm_kernel_RN\n#define\tDTRMM_KERNEL_RT\t\tgotoblas -> dtrmm_kernel_RT\n#define\tDTRMM_KERNEL_RR\t\tgotoblas -> dtrmm_kernel_RN\n#define\tDTRMM_KERNEL_RC\t\tgotoblas -> dtrmm_kernel_RT\n\n#define\tDTRSM_KERNEL_LN\t\tgotoblas -> dtrsm_kernel_LN\n#define\tDTRSM_KERNEL_LT\t\tgotoblas -> dtrsm_kernel_LT\n#define\tDTRSM_KERNEL_LR\t\tgotoblas -> dtrsm_kernel_LN\n#define\tDTRSM_KERNEL_LC\t\tgotoblas -> dtrsm_kernel_LT\n#define\tDTRSM_KERNEL_RN\t\tgotoblas -> dtrsm_kernel_RN\n#define\tDTRSM_KERNEL_RT\t\tgotoblas -> dtrsm_kernel_RT\n#define\tDTRSM_KERNEL_RR\t\tgotoblas -> dtrsm_kernel_RN\n#define\tDTRSM_KERNEL_RC\t\tgotoblas -> dtrsm_kernel_RT\n\n#define\tDSYMM_IUTCOPY\t\tgotoblas -> dsymm_iutcopy\n#define\tDSYMM_ILTCOPY\t\tgotoblas -> dsymm_iltcopy\n#define\tDSYMM_OUTCOPY\t\tgotoblas -> dsymm_outcopy\n#define\tDSYMM_OLTCOPY\t\tgotoblas -> dsymm_oltcopy\n\n#define DNEG_TCOPY\t\tgotoblas -> dneg_tcopy\n#define DLASWP_NCOPY\t\tgotoblas -> dlaswp_ncopy\n\n#define\tDAXPBY_K\t\tgotoblas -> daxpby_k\n#define DOMATCOPY_K_CN\t\tgotoblas -> domatcopy_k_cn\n#define DOMATCOPY_K_RN\t\tgotoblas -> domatcopy_k_rn\n#define DOMATCOPY_K_CT\t\tgotoblas -> domatcopy_k_ct\n#define DOMATCOPY_K_RT\t\tgotoblas -> domatcopy_k_rt\n#define DIMATCOPY_K_CN\t\tgotoblas -> dimatcopy_k_cn\n#define DIMATCOPY_K_RN\t\tgotoblas -> dimatcopy_k_rn\n#define DIMATCOPY_K_CT\t\tgotoblas -> dimatcopy_k_ct\n#define DIMATCOPY_K_RT\t\tgotoblas -> dimatcopy_k_rt\n\n#define DGEADD_K                gotoblas -> dgeadd_k \n\n#define DGEMM_SMALL_MATRIX_PERMIT\tgotoblas -> dgemm_small_matrix_permit\n\n#endif\n\n#define DGEMM_SMALL_KERNEL_NN\t\tFUNC_OFFSET(dgemm_small_kernel_nn)\n#define DGEMM_SMALL_KERNEL_NT\t\tFUNC_OFFSET(dgemm_small_kernel_nt)\n#define DGEMM_SMALL_KERNEL_TN\t\tFUNC_OFFSET(dgemm_small_kernel_tn)\n#define DGEMM_SMALL_KERNEL_TT\t\tFUNC_OFFSET(dgemm_small_kernel_tt)\n\n#define DGEMM_SMALL_KERNEL_B0_NN\tFUNC_OFFSET(dgemm_small_kernel_b0_nn)\n#define DGEMM_SMALL_KERNEL_B0_NT\tFUNC_OFFSET(dgemm_small_kernel_b0_nt)\n#define DGEMM_SMALL_KERNEL_B0_TN\tFUNC_OFFSET(dgemm_small_kernel_b0_tn)\n#define DGEMM_SMALL_KERNEL_B0_TT\tFUNC_OFFSET(dgemm_small_kernel_b0_tt)\n\n\n#define\tDGEMM_NN\t\tdgemm_nn\n#define\tDGEMM_CN\t\tdgemm_tn\n#define\tDGEMM_TN\t\tdgemm_tn\n#define\tDGEMM_NC\t\tdgemm_nt\n#define\tDGEMM_NT\t\tdgemm_nt\n#define\tDGEMM_CC\t\tdgemm_tt\n#define\tDGEMM_CT\t\tdgemm_tt\n#define\tDGEMM_TC\t\tdgemm_tt\n#define\tDGEMM_TT\t\tdgemm_tt\n#define\tDGEMM_NR\t\tdgemm_nn\n#define\tDGEMM_TR\t\tdgemm_tn\n#define\tDGEMM_CR\t\tdgemm_tn\n#define\tDGEMM_RN\t\tdgemm_nn\n#define\tDGEMM_RT\t\tdgemm_nt\n#define\tDGEMM_RC\t\tdgemm_nt\n#define\tDGEMM_RR\t\tdgemm_nn\n\n#define\tDSYMM_LU\t\tdsymm_LU\n#define\tDSYMM_LL\t\tdsymm_LL\n#define\tDSYMM_RU\t\tdsymm_RU\n#define\tDSYMM_RL\t\tdsymm_RL\n\n#define\tDHEMM_LU\t\tdhemm_LU\n#define\tDHEMM_LL\t\tdhemm_LL\n#define\tDHEMM_RU\t\tdhemm_RU\n#define\tDHEMM_RL\t\tdhemm_RL\n\n#define\tDSYRK_UN\t\tdsyrk_UN\n#define\tDSYRK_UT\t\tdsyrk_UT\n#define\tDSYRK_LN\t\tdsyrk_LN\n#define\tDSYRK_LT\t\tdsyrk_LT\n#define\tDSYRK_UR\t\tdsyrk_UN\n#define\tDSYRK_UC\t\tdsyrk_UT\n#define\tDSYRK_LR\t\tdsyrk_LN\n#define\tDSYRK_LC\t\tdsyrk_LT\n\n#define\tDSYRK_KERNEL_U\t\tdsyrk_kernel_U\n#define\tDSYRK_KERNEL_L\t\tdsyrk_kernel_L\n\n#define\tDHERK_UN\t\tdsyrk_UN\n#define\tDHERK_LN\t\tdsyrk_LN\n#define\tDHERK_UC\t\tdsyrk_UT\n#define\tDHERK_LC\t\tdsyrk_LT\n\n#define\tDHER2K_UN\t\tdsyr2k_UN\n#define\tDHER2K_LN\t\tdsyr2k_LN\n#define\tDHER2K_UC\t\tdsyr2k_UT\n#define\tDHER2K_LC\t\tdsyr2k_LT\n\n#define\tDSYR2K_UN\t\tdsyr2k_UN\n#define\tDSYR2K_UT\t\tdsyr2k_UT\n#define\tDSYR2K_LN\t\tdsyr2k_LN\n#define\tDSYR2K_LT\t\tdsyr2k_LT\n#define\tDSYR2K_UR\t\tdsyr2k_UN\n#define\tDSYR2K_UC\t\tdsyr2k_UT\n#define\tDSYR2K_LR\t\tdsyr2k_LN\n#define\tDSYR2K_LC\t\tdsyr2k_LT\n\n#define\tDSYR2K_KERNEL_U\t\tdsyr2k_kernel_U\n#define\tDSYR2K_KERNEL_L\t\tdsyr2k_kernel_L\n\n#define\tDTRMM_LNUU\t\tdtrmm_LNUU\n#define\tDTRMM_LNUN\t\tdtrmm_LNUN\n#define\tDTRMM_LNLU\t\tdtrmm_LNLU\n#define\tDTRMM_LNLN\t\tdtrmm_LNLN\n#define\tDTRMM_LTUU\t\tdtrmm_LTUU\n#define\tDTRMM_LTUN\t\tdtrmm_LTUN\n#define\tDTRMM_LTLU\t\tdtrmm_LTLU\n#define\tDTRMM_LTLN\t\tdtrmm_LTLN\n#define\tDTRMM_LRUU\t\tdtrmm_LNUU\n#define\tDTRMM_LRUN\t\tdtrmm_LNUN\n#define\tDTRMM_LRLU\t\tdtrmm_LNLU\n#define\tDTRMM_LRLN\t\tdtrmm_LNLN\n#define\tDTRMM_LCUU\t\tdtrmm_LTUU\n#define\tDTRMM_LCUN\t\tdtrmm_LTUN\n#define\tDTRMM_LCLU\t\tdtrmm_LTLU\n#define\tDTRMM_LCLN\t\tdtrmm_LTLN\n#define\tDTRMM_RNUU\t\tdtrmm_RNUU\n#define\tDTRMM_RNUN\t\tdtrmm_RNUN\n#define\tDTRMM_RNLU\t\tdtrmm_RNLU\n#define\tDTRMM_RNLN\t\tdtrmm_RNLN\n#define\tDTRMM_RTUU\t\tdtrmm_RTUU\n#define\tDTRMM_RTUN\t\tdtrmm_RTUN\n#define\tDTRMM_RTLU\t\tdtrmm_RTLU\n#define\tDTRMM_RTLN\t\tdtrmm_RTLN\n#define\tDTRMM_RRUU\t\tdtrmm_RNUU\n#define\tDTRMM_RRUN\t\tdtrmm_RNUN\n#define\tDTRMM_RRLU\t\tdtrmm_RNLU\n#define\tDTRMM_RRLN\t\tdtrmm_RNLN\n#define\tDTRMM_RCUU\t\tdtrmm_RTUU\n#define\tDTRMM_RCUN\t\tdtrmm_RTUN\n#define\tDTRMM_RCLU\t\tdtrmm_RTLU\n#define\tDTRMM_RCLN\t\tdtrmm_RTLN\n\n#define\tDTRSM_LNUU\t\tdtrsm_LNUU\n#define\tDTRSM_LNUN\t\tdtrsm_LNUN\n#define\tDTRSM_LNLU\t\tdtrsm_LNLU\n#define\tDTRSM_LNLN\t\tdtrsm_LNLN\n#define\tDTRSM_LTUU\t\tdtrsm_LTUU\n#define\tDTRSM_LTUN\t\tdtrsm_LTUN\n#define\tDTRSM_LTLU\t\tdtrsm_LTLU\n#define\tDTRSM_LTLN\t\tdtrsm_LTLN\n#define\tDTRSM_LRUU\t\tdtrsm_LNUU\n#define\tDTRSM_LRUN\t\tdtrsm_LNUN\n#define\tDTRSM_LRLU\t\tdtrsm_LNLU\n#define\tDTRSM_LRLN\t\tdtrsm_LNLN\n#define\tDTRSM_LCUU\t\tdtrsm_LTUU\n#define\tDTRSM_LCUN\t\tdtrsm_LTUN\n#define\tDTRSM_LCLU\t\tdtrsm_LTLU\n#define\tDTRSM_LCLN\t\tdtrsm_LTLN\n#define\tDTRSM_RNUU\t\tdtrsm_RNUU\n#define\tDTRSM_RNUN\t\tdtrsm_RNUN\n#define\tDTRSM_RNLU\t\tdtrsm_RNLU\n#define\tDTRSM_RNLN\t\tdtrsm_RNLN\n#define\tDTRSM_RTUU\t\tdtrsm_RTUU\n#define\tDTRSM_RTUN\t\tdtrsm_RTUN\n#define\tDTRSM_RTLU\t\tdtrsm_RTLU\n#define\tDTRSM_RTLN\t\tdtrsm_RTLN\n#define\tDTRSM_RRUU\t\tdtrsm_RNUU\n#define\tDTRSM_RRUN\t\tdtrsm_RNUN\n#define\tDTRSM_RRLU\t\tdtrsm_RNLU\n#define\tDTRSM_RRLN\t\tdtrsm_RNLN\n#define\tDTRSM_RCUU\t\tdtrsm_RTUU\n#define\tDTRSM_RCUN\t\tdtrsm_RTUN\n#define\tDTRSM_RCLU\t\tdtrsm_RTLU\n#define\tDTRSM_RCLN\t\tdtrsm_RTLN\n\n#define\tDGEMM_THREAD_NN\t\tdgemm_thread_nn\n#define\tDGEMM_THREAD_CN\t\tdgemm_thread_tn\n#define\tDGEMM_THREAD_TN\t\tdgemm_thread_tn\n#define\tDGEMM_THREAD_NC\t\tdgemm_thread_nt\n#define\tDGEMM_THREAD_NT\t\tdgemm_thread_nt\n#define\tDGEMM_THREAD_CC\t\tdgemm_thread_tt\n#define\tDGEMM_THREAD_CT\t\tdgemm_thread_tt\n#define\tDGEMM_THREAD_TC\t\tdgemm_thread_tt\n#define\tDGEMM_THREAD_TT\t\tdgemm_thread_tt\n#define\tDGEMM_THREAD_NR\t\tdgemm_thread_nn\n#define\tDGEMM_THREAD_TR\t\tdgemm_thread_tn\n#define\tDGEMM_THREAD_CR\t\tdgemm_thread_tn\n#define\tDGEMM_THREAD_RN\t\tdgemm_thread_nn\n#define\tDGEMM_THREAD_RT\t\tdgemm_thread_nt\n#define\tDGEMM_THREAD_RC\t\tdgemm_thread_nt\n#define\tDGEMM_THREAD_RR\t\tdgemm_thread_nn\n\n#define\tDSYMM_THREAD_LU\t\tdsymm_thread_LU\n#define\tDSYMM_THREAD_LL\t\tdsymm_thread_LL\n#define\tDSYMM_THREAD_RU\t\tdsymm_thread_RU\n#define\tDSYMM_THREAD_RL\t\tdsymm_thread_RL\n\n#define\tDHEMM_THREAD_LU\t\tdhemm_thread_LU\n#define\tDHEMM_THREAD_LL\t\tdhemm_thread_LL\n#define\tDHEMM_THREAD_RU\t\tdhemm_thread_RU\n#define\tDHEMM_THREAD_RL\t\tdhemm_thread_RL\n\n#define\tDSYRK_THREAD_UN\t\tdsyrk_thread_UN\n#define\tDSYRK_THREAD_UT\t\tdsyrk_thread_UT\n#define\tDSYRK_THREAD_LN\t\tdsyrk_thread_LN\n#define\tDSYRK_THREAD_LT\t\tdsyrk_thread_LT\n#define\tDSYRK_THREAD_UR\t\tdsyrk_thread_UN\n#define\tDSYRK_THREAD_UC\t\tdsyrk_thread_UT\n#define\tDSYRK_THREAD_LR\t\tdsyrk_thread_LN\n#define\tDSYRK_THREAD_LC\t\tdsyrk_thread_LT\n\n#define\tDHERK_THREAD_UN\t\tdsyrk_thread_UN\n#define\tDHERK_THREAD_UT\t\tdsyrk_thread_UT\n#define\tDHERK_THREAD_LN\t\tdsyrk_thread_LN\n#define\tDHERK_THREAD_LT\t\tdsyrk_thread_LT\n#define\tDHERK_THREAD_UR\t\tdsyrk_thread_UN\n#define\tDHERK_THREAD_UC\t\tdsyrk_thread_UT\n#define\tDHERK_THREAD_LR\t\tdsyrk_thread_LN\n#define\tDHERK_THREAD_LC\t\tdsyrk_thread_LT\n\n#endif\n"
        },
        {
          "name": "common_e2k.h",
          "type": "blob",
          "size": 2.17578125,
          "content": "/*****************************************************************************\nCopyright (c) 2011-2016, The OpenBLAS Project\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   1. Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n\n   2. Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in\n      the documentation and/or other materials provided with the\n      distribution.\n   3. Neither the name of the OpenBLAS project nor the names of \n      its contributors may be used to endorse or promote products \n      derived from this software without specific prior written \n      permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\nUSE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n**********************************************************************************/\n\n#ifndef COMMON_E2K\n#define COMMON_E2K\n\n#ifdef ASSEMBLER\n#error\n#endif\n\n#define MB do { __asm__ __volatile__(\"\": : :\"memory\"); } while (0)\n#define WMB do { __asm__ __volatile__(\"\": : :\"memory\"); } while (0)\n#define RMB\n\nstatic inline int blas_quickdivide(blasint x, blasint y) {\n  return x / y;\n}\n\n#ifndef PAGESIZE\n#define PAGESIZE\t( 4 << 10)\n#endif\n#define HUGE_PAGESIZE\t( 2 << 20)\n\n#ifndef BUFFERSIZE\n#define BUFFER_SIZE\t(32 << 20)\n#else\n#define BUFFER_SIZE\t(32 << BUFFERSIZE)\n#endif\n\n#define SEEK_ADDRESS\n\n#endif\n\n"
        },
        {
          "name": "common_ia64.h",
          "type": "blob",
          "size": 9.9853515625,
          "content": "/*********************************************************************/\n/* Copyright 2009, 2010 The University of Texas at Austin.           */\n/* All rights reserved.                                              */\n/*                                                                   */\n/* Redistribution and use in source and binary forms, with or        */\n/* without modification, are permitted provided that the following   */\n/* conditions are met:                                               */\n/*                                                                   */\n/*   1. Redistributions of source code must retain the above         */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer.                                                  */\n/*                                                                   */\n/*   2. Redistributions in binary form must reproduce the above      */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer in the documentation and/or other materials       */\n/*      provided with the distribution.                              */\n/*                                                                   */\n/*    THIS  SOFTWARE IS PROVIDED  BY THE  UNIVERSITY OF  TEXAS AT    */\n/*    AUSTIN  ``AS IS''  AND ANY  EXPRESS OR  IMPLIED WARRANTIES,    */\n/*    INCLUDING, BUT  NOT LIMITED  TO, THE IMPLIED  WARRANTIES OF    */\n/*    MERCHANTABILITY  AND FITNESS FOR  A PARTICULAR  PURPOSE ARE    */\n/*    DISCLAIMED.  IN  NO EVENT SHALL THE UNIVERSITY  OF TEXAS AT    */\n/*    AUSTIN OR CONTRIBUTORS BE  LIABLE FOR ANY DIRECT, INDIRECT,    */\n/*    INCIDENTAL,  SPECIAL, EXEMPLARY,  OR  CONSEQUENTIAL DAMAGES    */\n/*    (INCLUDING, BUT  NOT LIMITED TO,  PROCUREMENT OF SUBSTITUTE    */\n/*    GOODS  OR  SERVICES; LOSS  OF  USE,  DATA,  OR PROFITS;  OR    */\n/*    BUSINESS INTERRUPTION) HOWEVER CAUSED  AND ON ANY THEORY OF    */\n/*    LIABILITY, WHETHER  IN CONTRACT, STRICT  LIABILITY, OR TORT    */\n/*    (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY WAY OUT    */\n/*    OF  THE  USE OF  THIS  SOFTWARE,  EVEN  IF ADVISED  OF  THE    */\n/*    POSSIBILITY OF SUCH DAMAGE.                                    */\n/*                                                                   */\n/* The views and conclusions contained in the software and           */\n/* documentation are those of the authors and should not be          */\n/* interpreted as representing official policies, either expressed   */\n/* or implied, of The University of Texas at Austin.                 */\n/*********************************************************************/\n\n#ifndef COMMON_IA64\n#define COMMON_IA64\n\n#ifndef ASSEMBLER\n\n#ifndef MAP_WRITECOMBINED\n#define MAP_WRITECOMBINED 0x10000\n#endif\n\n#define MB\n#define WMB\n#define RMB\n\n#ifdef __ECC\n#include <ia64intrin.h>\n#endif\n\n#define RPCC64BIT\n\n#ifndef __ECC\nstatic __inline void blas_lock(volatile unsigned long *address){\n\n  unsigned long ret;\n\n  do {\n    while (*address) {YIELDING;};\n\n    __asm__ __volatile__ (\"mov ar.ccv=r0\\n;;\\n\"\n\t\t\t  \"cmpxchg4.acq %0=[%2],%1,ar.ccv\\n\"\n\t\t\t  : \"=r\"(ret) : \"r\"(1), \"r\"(address)\n\t\t\t  : \"ar.ccv\", \"memory\");\n  } while (ret);\n}\n#define BLAS_LOCK_DEFINED\n\nstatic __inline unsigned long rpcc(void) {\n  unsigned long clocks;\n\n  __asm__ __volatile__ (\"mov %0=ar.itc\" : \"=r\"(clocks));\n  return clocks;\n}\n#define RPCC_DEFINED\n\n\nstatic __inline unsigned long stmxcsr(void){\n  unsigned long fp;\n\n   __asm__ __volatile__ (\"mov.m %0=ar.fpsr\" : \"=r\" (fp));\n\n   return fp;\n}\n\nstatic __inline void ldmxcsr(unsigned long fp) {\n\n   __asm__ __volatile__ (\"mov.m ar.fpsr=%0\" :: \"r\" (fp));\n\n}\n\n#define GET_IMAGE(res) asm __volatile__(\"mov %0 = f9\" : \"=f\"(res)  : : \"memory\")\n\n#else\n\nstatic __inline void blas_lock(volatile unsigned long *address){\n  while (*address || _InterlockedCompareExchange((volatile int *) address,1,0))\n    ;\n}\n#define BLAS_LOCK_DEFINED\n\nstatic __inline unsigned int rpcc(void) {\n  return __getReg(_IA64_REG_AR_ITC);\n}\n#define RPCC_DEFINED\n\nstatic __inline unsigned int stmxcsr(void) {\n  return __getReg(_IA64_REG_AR_FPSR);\n}\n\nstatic __inline void ldmxcsr(unsigned long fp) {\n\n  return __setReg(_IA64_REG_AR_FPSR, fp);\n\n}\n\n#ifdef DOUBLE\n#define GET_IMAGE(res) __stfd(&res, 9)\n#else\n#define GET_IMAGE(res) __stfs(&res, 9)\n#endif\n\n#endif\n\n#define GET_IMAGE_CANCEL\n\n#ifdef ENABLE_SSE_EXCEPTION\n\n#define IDEBUG_START \\\n  { \\\n    unsigned long fp_sse_mode, new_fp_mode; \\\n\tfp_sse_mode = stmxcsr();\\\n\tnew_fp_mode = (fp_sse_mode & ~(FE_UNDERFLOW | FE_OVERFLOW | FE_UNNORMAL | FE_INVALID));\\\n\tldmxcsr(new_fp_mode);\n\n#define IDEBUG_END \\\n\tldmxcsr(fp_sse_mode); \\\n\t}\n\n#endif\n\n#ifdef SMP\n\n#ifdef USE64BITINT\n\n/* 64bit version */\n\nextern unsigned long blas_quick_divide_table[];\n\n#ifndef __ECC\nstatic __inline long blas_quickdivide(unsigned long int x, unsigned long int y){\n  unsigned long ret;\n\n  if (y <= 1) return x;\n\n  __asm__ __volatile__(\"setf.sig f6 = %1\\n\\t\"\n\t       \"ldf8     f7 = [%2];;\\n\\t\"\n\t       \"xmpy.hu f6= f6, f7;;\\n\\t\"\n\t       \"getf.sig %0 = f6;;\\n\"\n\t       : \"=r\"(ret)\n\t       : \"r\"(x), \"r\"(&blas_quick_divide_table[y]) : \"f6\", \"f7\"\n\t       );\n\n  return ret;\n}\n#else\n/* Using Intel Compiler */\nstatic __inline long blas_quickdivide(unsigned long int x, unsigned long int y){\n  if (y <= 1) return x;\n  return _m64_xmahu(x, blas_quick_divide_table[y], 0);\n}\n#endif\n\n#else\n /* 32bit version */\nextern unsigned int  blas_quick_divide_table[];\n\nstatic __inline int blas_quickdivide(unsigned int x, unsigned int y){\n  if (y <= 1) return x;\n  return (int)((x * (unsigned long)blas_quick_divide_table[y]) >> 32);\n}\n#endif\n#endif\n\n#endif\n\n#if 0\n#ifdef DOUBLE\n#define   GEMM_NCOPY\tdgemm_ncopy\n#define   GEMM_TCOPY\tdgemm_tcopy\n#define  ZGEMM_NCOPY\tzgemm_ncopy\n#define  ZGEMM_TCOPY\tzgemm_tcopy\n#define   GEMM_KERNEL\tdgemm_kernel\n\n#if defined(NN) || defined(NT) || defined(TN) || defined(TT)\n#define ZGEMM_KERNEL zgemm_kernel_n\n#endif\n#if defined(CN) || defined(CT) || defined(RN) || defined(RT)\n#define ZGEMM_KERNEL zgemm_kernel_l\n#endif\n#if defined(NC) || defined(TC) || defined(NR) || defined(TR)\n#define ZGEMM_KERNEL zgemm_kernel_r\n#endif\n#if defined(CC) || defined(CR) || defined(RC) || defined(RR)\n#define ZGEMM_KERNEL zgemm_kernel_b\n#endif\n\n#else\n#define   GEMM_NCOPY\tsgemm_ncopy\n#define   GEMM_TCOPY\tsgemm_tcopy\n#define  ZGEMM_NCOPY\tcgemm_ncopy\n#define  ZGEMM_TCOPY\tcgemm_tcopy\n#define   GEMM_KERNEL\tsgemm_kernel\n\n#if defined(NN) || defined(NT) || defined(TN) || defined(TT)\n#define ZGEMM_KERNEL cgemm_kernel_n\n#endif\n#if defined(CN) || defined(CT) || defined(RN) || defined(RT)\n#define ZGEMM_KERNEL cgemm_kernel_l\n#endif\n#if defined(NC) || defined(TC) || defined(NR) || defined(TR)\n#define ZGEMM_KERNEL cgemm_kernel_r\n#endif\n#if defined(CC) || defined(CR) || defined(RC) || defined(RR)\n#define ZGEMM_KERNEL cgemm_kernel_b\n#endif\n\n#endif\n#endif\n\n#ifdef USE64BITINT\n#define LDINT\t\tld8\n#define INTSIZE\t\t8\n#define CMP4GE\t\tcmp.ge\n#define CMP4NE\t\tcmp.ge\n#define CMP4EQ\t\tcmp.eq\n#else\n#define LDINT\t\tld4\n#define INTSIZE\t\t4\n#define CMP4GE\t\tcmp4.ge\n#define CMP4NE\t\tcmp4.ne\n#define CMP4EQ\t\tcmp4.eq\n#endif\n\n#define HALT\t\tmov r0 = 0\n\n#ifdef XDOUBLE\n#define LD8\t\tld8\n#define ST8\t\tst8\n#define LDFD\t\tldfe\n#define LDFPD\t\tldfpe\n#define LDFD_T1\t\tldfe.t1\n#define LDFD_NT1\tldfe.nt1\n#define LDFD_NT2\tldfe.nt2\n#define LDFD_NTA\tldfe.nta\n#define LDFPD_NT1\tldfpe.nt1\n#define LDFPD_NT2\tldfpe.nt2\n#define LDFPD_NTA\tldfpe.nta\n#define STFD\t\tstfe\n#define STFD_NTA\tstfe.nta\n#define FADD\t\tfadd\n#define FSUB\t\tfsub\n#define FMPY\t\tfmpy\n#define FMA\t\tfma\n#define FMS\t\tfms\n#define FNMA\t\tfnma\n#define FPMA\t\tfpma\n#define SETF\t\tsetf.d\n#elif defined(DOUBLE)\n#define LD8\t\tld8\n#define ST8\t\tst8\n#define LDF8\t\tldf8\n#define LDF8_NT1\tldf8.nt1\n#define LDF8_NTA\tldf8.nta\n#define STF8\t\tstf8\n#define STF8_NTA\tstf8.nta\n#define LDFD\t\tldfd\n#define LDFPD\t\tldfpd\n#define LDFD_T1\t\tldfd.t1\n#define LDFD_NT1\tldfd.nt1\n#define LDFD_NT2\tldfd.nt2\n#define LDFD_NTA\tldfd.nta\n#define LDFPD_NT1\tldfpd.nt1\n#define LDFPD_NT2\tldfpd.nt2\n#define LDFPD_NTA\tldfpd.nta\n#define STFD\t\tstfd\n#define STFD_NTA\tstfd.nta\n#define FADD\t\tfadd.d\n#define FSUB\t\tfsub.d\n#define FMPY\t\tfmpy.d\n#define FMA\t\tfma.d\n#define FMS\t\tfms.d\n#define FNMA\t\tfnma.d\n#define FPMA\t\tfpma.d\n#define SETF\t\tsetf.d\n#else\n#define LD8\t\tld4\n#define ST8\t\tst4\n#define LDF8\t\tldfs\n#define LDF8_NT1\tldfs.nt1\n#define LDF8_NTA\tldfs.nta\n#define STF8\t\tstfs\n#define STF8_NTA\tstfs.nta\n#define LDFD\t\tldfs\n#define LDFPD\t\tldfps\n#define LDFD_T1\t\tldfs.t1\n#define LDFD_NT1\tldfs.nt1\n#define LDFD_NT2\tldfs.nt2\n#define LDFD_NTA\tldfs.nta\n#define LDFPD_NT1\tldfps.nt1\n#define LDFPD_NT2\tldfps.nt2\n#define LDFPD_NTA\tldfps.nta\n#define STFD\t\tstfs\n#define STFD_NTA\tstfs.nta\n#if 0\n#define FADD\t\tfadd.s\n#define FSUB\t\tfsub.s\n#define FMPY\t\tfmpy.s\n#define FMA\t\tfma.s\n#define FMS\t\tfms.s\n#define FNMA\t\tfnma.s\n#define FPMA\t\tfpma.s\n#else\n#define FADD\t\tfadd\n#define FSUB\t\tfsub\n#define FMPY\t\tfmpy\n#define FMA\t\tfma\n#define FMS\t\tfms\n#define FNMA\t\tfnma\n#define FPMA\t\tfpma\n#endif\n#define SETF\t\tsetf.s\n#endif\n\n#ifndef F_INTERFACE\n#define REALNAME ASMNAME\n#else\n#define REALNAME ASMFNAME\n#endif\n\n#ifdef F_INTERFACE_G77\n#define RETURN_BY_STACK\n#endif\n\n#ifdef F_INTERFACE_G95\n#define RETURN_BY_STACK\n#endif\n\n#ifdef F_INTERFACE_GFORT\n#define RETURN_BY_REGS\n#endif\n\n#ifdef F_INTERFACE_INTEL\n#define RETURN_BY_STACK\n#endif\n\n#define PROLOGUE \\\n\t.explicit; \\\n\t.text; \\\n\t.align 128; \\\n\t.global REALNAME; \\\n\t.proc REALNAME; \\\nREALNAME:\n\n\n#ifdef PROFILE\n#define PROFCODE \\\n\t.data; \\\n\t.align 8; \\\n.LP0:; \\\n\tdata8\t0; \\\n\t.text; \\\n\talloc\tout0 = ar.pfs, 8, 0, 4, 0; \\\n\tmov\tout1 = r1; \\\n\tmov\tout2 = b0; \\\n\taddl\tout3 = @ltoff(.LP0), r1;;; \\\n\tbr.call.sptk.many b0 = _mcount;;\n#else\n#define PROFCODE\n#endif\n\n#if defined(__linux__) && defined(__ELF__)\n#define GNUSTACK .section .note.GNU-stack,\"\",@progbits\n#else\n#define GNUSTACK\n#endif\n\n#define EPILOGUE \\\n        .endp REALNAME ; \\\n        GNUSTACK\n\n#define START_ADDRESS 0x20000fc800000000UL\n\n#undef SEEK_ADDRESS\n\n#if 0\n#ifdef CONFIG_IA64_PAGE_SIZE_4KB\n#define SEEK_ADDRESS\n#endif\n\n#ifdef CONFIG_IA64_PAGE_SIZE_8KB\n#define SEEK_ADDRESS\n#endif\n#endif\n\n#define BUFFER_SIZE\t(128 << 20)\n\n#ifndef PAGESIZE\n#define PAGESIZE\t(16UL << 10)\n#endif\n#define HUGE_PAGESIZE\t(  4 << 20)\n\n#define BASE_ADDRESS (START_ADDRESS - (BLASULONG)BUFFER_SIZE * MAX_CPU_NUMBER)\n\n#endif\n"
        },
        {
          "name": "common_interface.h",
          "type": "blob",
          "size": 48.595703125,
          "content": "/*********************************************************************/\n/* Copyright 2009, 2010 The University of Texas at Austin.           */\n/* All rights reserved.                                              */\n/*                                                                   */\n/* Redistribution and use in source and binary forms, with or        */\n/* without modification, are permitted provided that the following   */\n/* conditions are met:                                               */\n/*                                                                   */\n/*   1. Redistributions of source code must retain the above         */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer.                                                  */\n/*                                                                   */\n/*   2. Redistributions in binary form must reproduce the above      */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer in the documentation and/or other materials       */\n/*      provided with the distribution.                              */\n/*                                                                   */\n/*    THIS  SOFTWARE IS PROVIDED  BY THE  UNIVERSITY OF  TEXAS AT    */\n/*    AUSTIN  ``AS IS''  AND ANY  EXPRESS OR  IMPLIED WARRANTIES,    */\n/*    INCLUDING, BUT  NOT LIMITED  TO, THE IMPLIED  WARRANTIES OF    */\n/*    MERCHANTABILITY  AND FITNESS FOR  A PARTICULAR  PURPOSE ARE    */\n/*    DISCLAIMED.  IN  NO EVENT SHALL THE UNIVERSITY  OF TEXAS AT    */\n/*    AUSTIN OR CONTRIBUTORS BE  LIABLE FOR ANY DIRECT, INDIRECT,    */\n/*    INCIDENTAL,  SPECIAL, EXEMPLARY,  OR  CONSEQUENTIAL DAMAGES    */\n/*    (INCLUDING, BUT  NOT LIMITED TO,  PROCUREMENT OF SUBSTITUTE    */\n/*    GOODS  OR  SERVICES; LOSS  OF  USE,  DATA,  OR PROFITS;  OR    */\n/*    BUSINESS INTERRUPTION) HOWEVER CAUSED  AND ON ANY THEORY OF    */\n/*    LIABILITY, WHETHER  IN CONTRACT, STRICT  LIABILITY, OR TORT    */\n/*    (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY WAY OUT    */\n/*    OF  THE  USE OF  THIS  SOFTWARE,  EVEN  IF ADVISED  OF  THE    */\n/*    POSSIBILITY OF SUCH DAMAGE.                                    */\n/*                                                                   */\n/* The views and conclusions contained in the software and           */\n/* documentation are those of the authors and should not be          */\n/* interpreted as representing official policies, either expressed   */\n/* or implied, of The University of Texas at Austin.                 */\n/*********************************************************************/\n\n#ifndef ASSEMBLER\n\n#ifdef __cplusplus\nextern \"C\" {\n\t/* Assume C declarations for C++ */\n#endif  /* __cplusplus */\n\nint    BLASFUNC(xerbla)(char *, blasint *info, blasint);\n\nvoid    openblas_set_num_threads_(int *);\n\n/*Set the threading backend to a custom callback.*/\ntypedef void (*openblas_dojob_callback)(int thread_num, void *jobdata, int dojob_data);\ntypedef void (*openblas_threads_callback)(int sync, openblas_dojob_callback dojob, int numjobs, size_t jobdata_elsize, void *jobdata, int dojob_data);\nextern openblas_threads_callback openblas_threads_callback_;\n\nFLOATRET  BLASFUNC(sdot)  (blasint *, float  *, blasint *, float  *, blasint *);\nFLOATRET  BLASFUNC(sdsdot)(blasint *, float  *,        float  *, blasint *, float  *, blasint *);\n\ndouble BLASFUNC(dsdot) (blasint *, float  *, blasint *, float  *, blasint *);\ndouble BLASFUNC(ddot)  (blasint *, double *, blasint *, double *, blasint *);\nxdouble BLASFUNC(qdot)  (blasint *, xdouble *, blasint *, xdouble *, blasint *);\n\nfloat  BLASFUNC(sbdot)     (blasint *, bfloat16 *, blasint *, bfloat16 *, blasint *);\nvoid   BLASFUNC(sbstobf16) (blasint *, float *,    blasint *, bfloat16 *, blasint *);\nvoid   BLASFUNC(sbdtobf16) (blasint *, double *,   blasint *, bfloat16 *, blasint *);\nvoid   BLASFUNC(sbf16tos)  (blasint *, bfloat16 *, blasint *, float *,    blasint *);\nvoid   BLASFUNC(dbf16tod)  (blasint *, bfloat16 *, blasint *, double *,   blasint *);\n\n#ifdef RETURN_BY_STRUCT\ntypedef struct {\n  float r, i;\n} myccomplex_t;\n\ntypedef struct {\n  double r, i;\n} myzcomplex_t;\n\ntypedef struct {\n  xdouble r, i;\n} myxcomplex_t;\n\nmyccomplex_t    BLASFUNC(cdotu)  (blasint *, float  *, blasint *, float  *, blasint *);\nmyccomplex_t    BLASFUNC(cdotc)  (blasint *, float  *, blasint *, float  *, blasint *);\nmyzcomplex_t    BLASFUNC(zdotu)  (blasint *, double  *, blasint *, double  *, blasint *);\nmyzcomplex_t    BLASFUNC(zdotc)  (blasint *, double  *, blasint *, double  *, blasint *);\nmyxcomplex_t    BLASFUNC(xdotu)  (blasint *, xdouble  *, blasint *, xdouble  *, blasint *);\nmyxcomplex_t    BLASFUNC(xdotc)  (blasint *, xdouble  *, blasint *, xdouble  *, blasint *);\n\n#elif defined RETURN_BY_STACK\nvoid  BLASFUNC(cdotu)  (openblas_complex_float   *,  blasint *, float  * , blasint *, float  *,  blasint *);\nvoid  BLASFUNC(cdotc)  (openblas_complex_float   *,  blasint *, float  *,  blasint *, float  *,  blasint *);\nvoid  BLASFUNC(zdotu)  (openblas_complex_double  *, blasint *, double  *, blasint *, double  *, blasint *);\nvoid  BLASFUNC(zdotc)  (openblas_complex_double  *, blasint *, double  *, blasint *, double  *, blasint *);\nvoid  BLASFUNC(xdotu)  (openblas_complex_xdouble *, blasint *, xdouble  *, blasint *, xdouble  *, blasint *);\nvoid  BLASFUNC(xdotc)  (openblas_complex_xdouble *, blasint *, xdouble  *, blasint *, xdouble  *, blasint *);\n#else\nopenblas_complex_float   BLASFUNC(cdotu)  (blasint *, float  *, blasint *, float  *, blasint *);\nopenblas_complex_float   BLASFUNC(cdotc)  (blasint *, float  *, blasint *, float  *, blasint *);\nopenblas_complex_double  BLASFUNC(zdotu)  (blasint *, double  *, blasint *, double  *, blasint *);\nopenblas_complex_double  BLASFUNC(zdotc)  (blasint *, double  *, blasint *, double  *, blasint *);\nopenblas_complex_xdouble BLASFUNC(xdotu)  (blasint *, xdouble  *, blasint *, xdouble  *, blasint *);\nopenblas_complex_xdouble BLASFUNC(xdotc)  (blasint *, xdouble  *, blasint *, xdouble  *, blasint *);\n#endif\n\nvoid    BLASFUNC(saxpy) (blasint *, float  *, float  *, blasint *, float  *, blasint *);\nvoid    BLASFUNC(daxpy) (blasint *, double *, double *, blasint *, double *, blasint *);\nvoid    BLASFUNC(qaxpy) (blasint *, xdouble *, xdouble *, blasint *, xdouble *, blasint *);\nvoid    BLASFUNC(caxpy) (blasint *, float  *, float  *, blasint *, float  *, blasint *);\nvoid    BLASFUNC(zaxpy) (blasint *, double *, double *, blasint *, double *, blasint *);\nvoid    BLASFUNC(xaxpy) (blasint *, xdouble *, xdouble *, blasint *, xdouble *, blasint *);\nvoid    BLASFUNC(caxpyc)(blasint *, float  *, float  *, blasint *, float  *, blasint *);\nvoid    BLASFUNC(zaxpyc)(blasint *, double *, double *, blasint *, double *, blasint *);\nvoid    BLASFUNC(xaxpyc)(blasint *, xdouble *, xdouble *, blasint *, xdouble *, blasint *);\n\nvoid    BLASFUNC(scopy) (blasint *, float  *, blasint *, float  *, blasint *);\nvoid    BLASFUNC(dcopy) (blasint *, double *, blasint *, double *, blasint *);\nvoid    BLASFUNC(qcopy) (blasint *, xdouble *, blasint *, xdouble *, blasint *);\nvoid    BLASFUNC(ccopy) (blasint *, float  *, blasint *, float  *, blasint *);\nvoid    BLASFUNC(zcopy) (blasint *, double *, blasint *, double *, blasint *);\nvoid    BLASFUNC(xcopy) (blasint *, xdouble *, blasint *, xdouble *, blasint *);\n\nvoid    BLASFUNC(sswap) (blasint *, float  *, blasint *, float  *, blasint *);\nvoid    BLASFUNC(dswap) (blasint *, double *, blasint *, double *, blasint *);\nvoid    BLASFUNC(qswap) (blasint *, xdouble *, blasint *, xdouble *, blasint *);\nvoid    BLASFUNC(cswap) (blasint *, float  *, blasint *, float  *, blasint *);\nvoid    BLASFUNC(zswap) (blasint *, double *, blasint *, double *, blasint *);\nvoid    BLASFUNC(xswap) (blasint *, xdouble *, blasint *, xdouble *, blasint *);\n\nFLOATRET  BLASFUNC(sasum) (blasint *, float  *, blasint *);\nFLOATRET  BLASFUNC(scasum)(blasint *, float  *, blasint *);\ndouble BLASFUNC(dasum) (blasint *, double *, blasint *);\nxdouble BLASFUNC(qasum) (blasint *, xdouble *, blasint *);\ndouble BLASFUNC(dzasum)(blasint *, double *, blasint *);\nxdouble BLASFUNC(qxasum)(blasint *, xdouble *, blasint *);\n\nFLOATRET  BLASFUNC(ssum) (blasint *, float  *, blasint *);\nFLOATRET  BLASFUNC(scsum)(blasint *, float  *, blasint *);\ndouble BLASFUNC(dsum) (blasint *, double *, blasint *);\nxdouble BLASFUNC(qsum) (blasint *, xdouble *, blasint *);\ndouble BLASFUNC(dzsum)(blasint *, double *, blasint *);\nxdouble BLASFUNC(qxsum)(blasint *, xdouble *, blasint *);\n\nblasint    BLASFUNC(isamax)(blasint *, float  *, blasint *);\nblasint    BLASFUNC(idamax)(blasint *, double *, blasint *);\nblasint    BLASFUNC(iqamax)(blasint *, xdouble *, blasint *);\nblasint    BLASFUNC(icamax)(blasint *, float  *, blasint *);\nblasint    BLASFUNC(izamax)(blasint *, double *, blasint *);\nblasint    BLASFUNC(ixamax)(blasint *, xdouble *, blasint *);\n\nblasint    BLASFUNC(ismax) (blasint *, float  *, blasint *);\nblasint    BLASFUNC(idmax) (blasint *, double *, blasint *);\nblasint    BLASFUNC(iqmax) (blasint *, xdouble *, blasint *);\nblasint    BLASFUNC(icmax) (blasint *, float  *, blasint *);\nblasint    BLASFUNC(izmax) (blasint *, double *, blasint *);\nblasint    BLASFUNC(ixmax) (blasint *, xdouble *, blasint *);\n\nblasint    BLASFUNC(isamin)(blasint *, float  *, blasint *);\nblasint    BLASFUNC(idamin)(blasint *, double *, blasint *);\nblasint    BLASFUNC(iqamin)(blasint *, xdouble *, blasint *);\nblasint    BLASFUNC(icamin)(blasint *, float  *, blasint *);\nblasint    BLASFUNC(izamin)(blasint *, double *, blasint *);\nblasint    BLASFUNC(ixamin)(blasint *, xdouble *, blasint *);\n\nblasint    BLASFUNC(ismin)(blasint *, float  *, blasint *);\nblasint    BLASFUNC(idmin)(blasint *, double *, blasint *);\nblasint    BLASFUNC(iqmin)(blasint *, xdouble *, blasint *);\nblasint    BLASFUNC(icmin)(blasint *, float  *, blasint *);\nblasint    BLASFUNC(izmin)(blasint *, double *, blasint *);\nblasint    BLASFUNC(ixmin)(blasint *, xdouble *, blasint *);\n\nFLOATRET  BLASFUNC(samax) (blasint *, float  *, blasint *);\ndouble BLASFUNC(damax) (blasint *, double *, blasint *);\nxdouble BLASFUNC(qamax) (blasint *, xdouble *, blasint *);\nFLOATRET  BLASFUNC(scamax)(blasint *, float  *, blasint *);\ndouble BLASFUNC(dzamax)(blasint *, double *, blasint *);\nxdouble BLASFUNC(qxamax)(blasint *, xdouble *, blasint *);\n\nFLOATRET  BLASFUNC(samin) (blasint *, float  *, blasint *);\ndouble BLASFUNC(damin) (blasint *, double *, blasint *);\nxdouble BLASFUNC(qamin) (blasint *, xdouble *, blasint *);\nFLOATRET  BLASFUNC(scamin)(blasint *, float  *, blasint *);\ndouble BLASFUNC(dzamin)(blasint *, double *, blasint *);\nxdouble BLASFUNC(qxamin)(blasint *, xdouble *, blasint *);\n\nFLOATRET  BLASFUNC(smax)  (blasint *, float  *, blasint *);\ndouble BLASFUNC(dmax)  (blasint *, double *, blasint *);\nxdouble BLASFUNC(qmax)  (blasint *, xdouble *, blasint *);\nFLOATRET  BLASFUNC(scmax) (blasint *, float  *, blasint *);\ndouble BLASFUNC(dzmax) (blasint *, double *, blasint *);\nxdouble BLASFUNC(qxmax) (blasint *, xdouble *, blasint *);\n\nFLOATRET  BLASFUNC(smin)  (blasint *, float  *, blasint *);\ndouble BLASFUNC(dmin)  (blasint *, double *, blasint *);\nxdouble BLASFUNC(qmin)  (blasint *, xdouble *, blasint *);\nFLOATRET  BLASFUNC(scmin) (blasint *, float  *, blasint *);\ndouble BLASFUNC(dzmin) (blasint *, double *, blasint *);\nxdouble BLASFUNC(qxmin) (blasint *, xdouble *, blasint *);\n\nvoid    BLASFUNC(sscal) (blasint *,  float  *, float  *, blasint *);\nvoid    BLASFUNC(dscal) (blasint *,  double *, double *, blasint *);\nvoid    BLASFUNC(qscal) (blasint *,  xdouble *, xdouble *, blasint *);\nvoid    BLASFUNC(cscal) (blasint *,  float  *, float  *, blasint *);\nvoid    BLASFUNC(zscal) (blasint *,  double *, double *, blasint *);\nvoid    BLASFUNC(xscal) (blasint *,  xdouble *, xdouble *, blasint *);\nvoid    BLASFUNC(csscal)(blasint *,  float  *, float  *, blasint *);\nvoid    BLASFUNC(zdscal)(blasint *,  double *, double *, blasint *);\nvoid    BLASFUNC(xqscal)(blasint *,  xdouble *, xdouble *, blasint *);\n\nFLOATRET  BLASFUNC(snrm2) (blasint *, float  *, blasint *);\nFLOATRET  BLASFUNC(scnrm2)(blasint *, float  *, blasint *);\n\ndouble BLASFUNC(dnrm2) (blasint *, double *, blasint *);\nxdouble BLASFUNC(qnrm2) (blasint *, xdouble *, blasint *);\ndouble BLASFUNC(dznrm2)(blasint *, double *, blasint *);\nxdouble BLASFUNC(qxnrm2)(blasint *, xdouble *, blasint *);\n\nvoid  BLASFUNC(srot)  (blasint *, float  *, blasint *, float  *, blasint *, float  *, float  *);\nvoid  BLASFUNC(drot)  (blasint *, double *, blasint *, double *, blasint *, double *, double *);\nvoid  BLASFUNC(qrot)  (blasint *, xdouble *, blasint *, xdouble *, blasint *, xdouble *, xdouble *);\nvoid  BLASFUNC(csrot) (blasint *, float  *, blasint *, float  *, blasint *, float  *, float  *);\nvoid  BLASFUNC(zdrot) (blasint *, double *, blasint *, double *, blasint *, double *, double *);\nvoid  BLASFUNC(xqrot) (blasint *, xdouble *, blasint *, xdouble *, blasint *, xdouble *, xdouble *);\n\nvoid  BLASFUNC(srotg) (float  *, float  *, float  *, float  *);\nvoid  BLASFUNC(drotg) (double *, double *, double *, double *);\nvoid  BLASFUNC(qrotg) (xdouble *, xdouble *, xdouble *, xdouble *);\nvoid  BLASFUNC(crotg) (float  *, float  *, float  *, float  *);\nvoid  BLASFUNC(zrotg) (double *, double *, double *, double *);\nvoid  BLASFUNC(xrotg) (xdouble *, xdouble *, xdouble *, xdouble *);\n\nvoid  BLASFUNC(srotmg)(float  *, float  *, float  *, float  *, float  *);\nvoid  BLASFUNC(drotmg)(double *, double *, double *, double *, double *);\n\nvoid  BLASFUNC(srotm) (blasint *, float  *, blasint *, float  *, blasint *, float  *);\nvoid  BLASFUNC(drotm) (blasint *, double *, blasint *, double *, blasint *, double *);\nvoid  BLASFUNC(qrotm) (blasint *, xdouble *, blasint *, xdouble *, blasint *, xdouble *);\n\n/* Level 2 routines */\n\nvoid BLASFUNC(sger)(blasint *,    blasint *, float *,  float *, blasint *,\n\t\t   float *,  blasint *, float *,  blasint *);\nvoid BLASFUNC(dger)(blasint *,    blasint *, double *, double *, blasint *,\n\t\t   double *, blasint *, double *, blasint *);\nvoid BLASFUNC(qger)(blasint *,    blasint *, xdouble *, xdouble *, blasint *,\n\t\t   xdouble *, blasint *, xdouble *, blasint *);\nvoid BLASFUNC(cgeru)(blasint *,    blasint *, float *,  float *, blasint *,\n\t\t    float *,  blasint *, float *,  blasint *);\nvoid BLASFUNC(cgerc)(blasint *,    blasint *, float *,  float *, blasint *,\n\t\t    float *,  blasint *, float *,  blasint *);\nvoid BLASFUNC(zgeru)(blasint *,    blasint *, double *, double *, blasint *,\n\t\t    double *, blasint *, double *, blasint *);\nvoid BLASFUNC(zgerc)(blasint *,    blasint *, double *, double *, blasint *,\n\t\t    double *, blasint *, double *, blasint *);\nvoid BLASFUNC(xgeru)(blasint *,    blasint *, xdouble *, xdouble *, blasint *,\n\t\t    xdouble *, blasint *, xdouble *, blasint *);\nvoid BLASFUNC(xgerc)(blasint *,    blasint *, xdouble *, xdouble *, blasint *,\n\t\t    xdouble *, blasint *, xdouble *, blasint *);\n\nvoid BLASFUNC(sbgemv)(char *, blasint *, blasint *, float  *, bfloat16 *, blasint *,\n            bfloat16  *, blasint *, float  *, float  *, blasint *);\nvoid BLASFUNC(sgemv)(char *, blasint *, blasint *, float  *, float  *, blasint *,\n\t\t    float  *, blasint *, float  *, float  *, blasint *);\nvoid BLASFUNC(dgemv)(char *, blasint *, blasint *, double *, double *, blasint *,\n\t\t    double *, blasint *, double *, double *, blasint *);\nvoid BLASFUNC(qgemv)(char *, blasint *, blasint *, xdouble *, xdouble *, blasint *,\n\t\t    xdouble *, blasint *, xdouble *, xdouble *, blasint *);\nvoid BLASFUNC(cgemv)(char *, blasint *, blasint *, float  *, float  *, blasint *,\n\t\t    float  *, blasint *, float  *, float  *, blasint *);\nvoid BLASFUNC(zgemv)(char *, blasint *, blasint *, double *, double *, blasint *,\n\t\t    double *, blasint *, double *, double *, blasint *);\nvoid BLASFUNC(xgemv)(char *, blasint *, blasint *, xdouble *, xdouble *, blasint *,\n\t\t    xdouble *, blasint *, xdouble *, xdouble *, blasint *);\n\nvoid BLASFUNC(strsv) (char *, char *, char *, blasint *, float  *, blasint *,\n\t\t     float  *, blasint *);\nvoid BLASFUNC(dtrsv) (char *, char *, char *, blasint *, double *, blasint *,\n\t\t     double *, blasint *);\nvoid BLASFUNC(qtrsv) (char *, char *, char *, blasint *, xdouble *, blasint *,\n\t\t     xdouble *, blasint *);\nvoid BLASFUNC(ctrsv) (char *, char *, char *, blasint *, float  *, blasint *,\n\t\t     float  *, blasint *);\nvoid BLASFUNC(ztrsv) (char *, char *, char *, blasint *, double *, blasint *,\n\t\t     double *, blasint *);\nvoid BLASFUNC(xtrsv) (char *, char *, char *, blasint *, xdouble *, blasint *,\n\t\t     xdouble *, blasint *);\n\nvoid BLASFUNC(strmv) (char *, char *, char *, blasint *, float  *, blasint *,\n\t\t     float  *, blasint *);\nvoid BLASFUNC(dtrmv) (char *, char *, char *, blasint *, double *, blasint *,\n\t\t     double *, blasint *);\nvoid BLASFUNC(qtrmv) (char *, char *, char *, blasint *, xdouble *, blasint *,\n\t\t     xdouble *, blasint *);\nvoid BLASFUNC(ctrmv) (char *, char *, char *, blasint *, float  *, blasint *,\n\t\t     float  *, blasint *);\nvoid BLASFUNC(ztrmv) (char *, char *, char *, blasint *, double *, blasint *,\n\t\t     double *, blasint *);\nvoid BLASFUNC(xtrmv) (char *, char *, char *, blasint *, xdouble *, blasint *,\n\t\t     xdouble *, blasint *);\n\nvoid BLASFUNC(stpsv) (char *, char *, char *, blasint *, float  *, float  *, blasint *);\nvoid BLASFUNC(dtpsv) (char *, char *, char *, blasint *, double *, double *, blasint *);\nvoid BLASFUNC(qtpsv) (char *, char *, char *, blasint *, xdouble *, xdouble *, blasint *);\nvoid BLASFUNC(ctpsv) (char *, char *, char *, blasint *, float  *, float  *, blasint *);\nvoid BLASFUNC(ztpsv) (char *, char *, char *, blasint *, double *, double *, blasint *);\nvoid BLASFUNC(xtpsv) (char *, char *, char *, blasint *, xdouble *, xdouble *, blasint *);\n\nvoid BLASFUNC(stpmv) (char *, char *, char *, blasint *, float  *, float  *, blasint *);\nvoid BLASFUNC(dtpmv) (char *, char *, char *, blasint *, double *, double *, blasint *);\nvoid BLASFUNC(qtpmv) (char *, char *, char *, blasint *, xdouble *, xdouble *, blasint *);\nvoid BLASFUNC(ctpmv) (char *, char *, char *, blasint *, float  *, float  *, blasint *);\nvoid BLASFUNC(ztpmv) (char *, char *, char *, blasint *, double *, double *, blasint *);\nvoid BLASFUNC(xtpmv) (char *, char *, char *, blasint *, xdouble *, xdouble *, blasint *);\n\nvoid BLASFUNC(stbmv) (char *, char *, char *, blasint *, blasint *, float  *, blasint *, float  *, blasint *);\nvoid BLASFUNC(dtbmv) (char *, char *, char *, blasint *, blasint *, double *, blasint *, double *, blasint *);\nvoid BLASFUNC(qtbmv) (char *, char *, char *, blasint *, blasint *, xdouble *, blasint *, xdouble *, blasint *);\nvoid BLASFUNC(ctbmv) (char *, char *, char *, blasint *, blasint *, float  *, blasint *, float  *, blasint *);\nvoid BLASFUNC(ztbmv) (char *, char *, char *, blasint *, blasint *, double *, blasint *, double *, blasint *);\nvoid BLASFUNC(xtbmv) (char *, char *, char *, blasint *, blasint *, xdouble *, blasint *, xdouble *, blasint *);\n\nvoid BLASFUNC(stbsv) (char *, char *, char *, blasint *, blasint *, float  *, blasint *, float  *, blasint *);\nvoid BLASFUNC(dtbsv) (char *, char *, char *, blasint *, blasint *, double *, blasint *, double *, blasint *);\nvoid BLASFUNC(qtbsv) (char *, char *, char *, blasint *, blasint *, xdouble *, blasint *, xdouble *, blasint *);\nvoid BLASFUNC(ctbsv) (char *, char *, char *, blasint *, blasint *, float  *, blasint *, float  *, blasint *);\nvoid BLASFUNC(ztbsv) (char *, char *, char *, blasint *, blasint *, double *, blasint *, double *, blasint *);\nvoid BLASFUNC(xtbsv) (char *, char *, char *, blasint *, blasint *, xdouble *, blasint *, xdouble *, blasint *);\n\nvoid BLASFUNC(ssymv) (char *, blasint *, float  *, float *, blasint *,\n\t\t     float  *, blasint *, float *, float *, blasint *);\nvoid BLASFUNC(dsymv) (char *, blasint *, double  *, double *, blasint *,\n\t\t     double  *, blasint *, double *, double *, blasint *);\nvoid BLASFUNC(qsymv) (char *, blasint *, xdouble  *, xdouble *, blasint *,\n\t\t     xdouble  *, blasint *, xdouble *, xdouble *, blasint *);\nvoid BLASFUNC(csymv) (char *, blasint *, float  *, float *, blasint *,\n\t\t     float  *, blasint *, float *, float *, blasint *);\nvoid BLASFUNC(zsymv) (char *, blasint *, double  *, double *, blasint *,\n\t\t     double  *, blasint *, double *, double *, blasint *);\nvoid BLASFUNC(xsymv) (char *, blasint *, xdouble  *, xdouble *, blasint *,\n\t\t     xdouble  *, blasint *, xdouble *, xdouble *, blasint *);\n\nvoid BLASFUNC(sspmv) (char *, blasint *, float  *, float *,\n\t\t     float  *, blasint *, float *, float *, blasint *);\nvoid BLASFUNC(dspmv) (char *, blasint *, double  *, double *,\n\t\t     double  *, blasint *, double *, double *, blasint *);\nvoid BLASFUNC(qspmv) (char *, blasint *, xdouble  *, xdouble *,\n\t\t     xdouble  *, blasint *, xdouble *, xdouble *, blasint *);\nvoid BLASFUNC(cspmv) (char *, blasint *, float  *, float *,\n\t\t     float  *, blasint *, float *, float *, blasint *);\nvoid BLASFUNC(zspmv) (char *, blasint *, double  *, double *,\n\t\t     double  *, blasint *, double *, double *, blasint *);\nvoid BLASFUNC(xspmv) (char *, blasint *, xdouble  *, xdouble *,\n\t\t     xdouble  *, blasint *, xdouble *, xdouble *, blasint *);\n\nvoid BLASFUNC(ssyr) (char *, blasint *, float   *, float  *, blasint *,\n\t\t    float  *, blasint *);\nvoid BLASFUNC(dsyr) (char *, blasint *, double  *, double *, blasint *,\n\t\t    double *, blasint *);\nvoid BLASFUNC(qsyr) (char *, blasint *, xdouble  *, xdouble *, blasint *,\n\t\t    xdouble *, blasint *);\nvoid BLASFUNC(csyr) (char *, blasint *, float   *, float  *, blasint *,\n\t\t    float  *, blasint *);\nvoid BLASFUNC(zsyr) (char *, blasint *, double  *, double *, blasint *,\n\t\t    double *, blasint *);\nvoid BLASFUNC(xsyr) (char *, blasint *, xdouble  *, xdouble *, blasint *,\n\t\t    xdouble *, blasint *);\n\nvoid BLASFUNC(ssyr2) (char *, blasint *, float   *,\n\t\t     float  *, blasint *, float  *, blasint *, float  *, blasint *);\nvoid BLASFUNC(dsyr2) (char *, blasint *, double  *,\n\t\t     double *, blasint *, double *, blasint *, double *, blasint *);\nvoid BLASFUNC(qsyr2) (char *, blasint *, xdouble  *,\n\t\t     xdouble *, blasint *, xdouble *, blasint *, xdouble *, blasint *);\nvoid BLASFUNC(csyr2) (char *, blasint *, float   *,\n\t\t     float  *, blasint *, float  *, blasint *, float  *, blasint *);\nvoid BLASFUNC(zsyr2) (char *, blasint *, double  *,\n\t\t     double *, blasint *, double *, blasint *, double *, blasint *);\nvoid BLASFUNC(xsyr2) (char *, blasint *, xdouble  *,\n\t\t     xdouble *, blasint *, xdouble *, blasint *, xdouble *, blasint *);\n\nvoid BLASFUNC(sspr) (char *, blasint *, float   *, float  *, blasint *,\n\t\t    float  *);\nvoid BLASFUNC(dspr) (char *, blasint *, double  *, double *, blasint *,\n\t\t    double *);\nvoid BLASFUNC(qspr) (char *, blasint *, xdouble  *, xdouble *, blasint *,\n\t\t    xdouble *);\nvoid BLASFUNC(cspr) (char *, blasint *, float   *, float  *, blasint *,\n\t\t    float  *);\nvoid BLASFUNC(zspr) (char *, blasint *, double  *, double *, blasint *,\n\t\t    double *);\nvoid BLASFUNC(xspr) (char *, blasint *, xdouble  *, xdouble *, blasint *,\n\t\t    xdouble *);\n\nvoid BLASFUNC(sspr2) (char *, blasint *, float   *,\n\t\t     float  *, blasint *, float  *, blasint *, float  *);\nvoid BLASFUNC(dspr2) (char *, blasint *, double  *,\n\t\t     double *, blasint *, double *, blasint *, double *);\nvoid BLASFUNC(qspr2) (char *, blasint *, xdouble  *,\n\t\t     xdouble *, blasint *, xdouble *, blasint *, xdouble *);\nvoid BLASFUNC(cspr2) (char *, blasint *, float   *,\n\t\t     float  *, blasint *, float  *, blasint *, float  *);\nvoid BLASFUNC(zspr2) (char *, blasint *, double  *,\n\t\t     double *, blasint *, double *, blasint *, double *);\nvoid BLASFUNC(xspr2) (char *, blasint *, xdouble  *,\n\t\t     xdouble *, blasint *, xdouble *, blasint *, xdouble *);\n\nvoid BLASFUNC(cher) (char *, blasint *, float   *, float  *, blasint *,\n\t\t    float  *, blasint *);\nvoid BLASFUNC(zher) (char *, blasint *, double  *, double *, blasint *,\n\t\t    double *, blasint *);\nvoid BLASFUNC(xher) (char *, blasint *, xdouble  *, xdouble *, blasint *,\n\t\t    xdouble *, blasint *);\n\nvoid BLASFUNC(chpr) (char *, blasint *, float   *, float  *, blasint *, float  *);\nvoid BLASFUNC(zhpr) (char *, blasint *, double  *, double *, blasint *, double *);\nvoid BLASFUNC(xhpr) (char *, blasint *, xdouble  *, xdouble *, blasint *, xdouble *);\n\nvoid BLASFUNC(cher2) (char *, blasint *, float   *,\n\t\t     float  *, blasint *, float  *, blasint *, float  *, blasint *);\nvoid BLASFUNC(zher2) (char *, blasint *, double  *,\n\t\t     double *, blasint *, double *, blasint *, double *, blasint *);\nvoid BLASFUNC(xher2) (char *, blasint *, xdouble  *,\n\t\t     xdouble *, blasint *, xdouble *, blasint *, xdouble *, blasint *);\n\nvoid BLASFUNC(chpr2) (char *, blasint *, float   *,\n\t\t     float  *, blasint *, float  *, blasint *, float  *);\nvoid BLASFUNC(zhpr2) (char *, blasint *, double  *,\n\t\t     double *, blasint *, double *, blasint *, double *);\nvoid BLASFUNC(xhpr2) (char *, blasint *, xdouble  *,\n\t\t     xdouble *, blasint *, xdouble *, blasint *, xdouble *);\n\nvoid BLASFUNC(chemv) (char *, blasint *, float  *, float *, blasint *,\n\t\t     float  *, blasint *, float *, float *, blasint *);\nvoid BLASFUNC(zhemv) (char *, blasint *, double  *, double *, blasint *,\n\t\t     double  *, blasint *, double *, double *, blasint *);\nvoid BLASFUNC(xhemv) (char *, blasint *, xdouble  *, xdouble *, blasint *,\n\t\t     xdouble  *, blasint *, xdouble *, xdouble *, blasint *);\n\nvoid BLASFUNC(chpmv) (char *, blasint *, float  *, float *,\n\t\t     float  *, blasint *, float *, float *, blasint *);\nvoid BLASFUNC(zhpmv) (char *, blasint *, double  *, double *,\n\t\t     double  *, blasint *, double *, double *, blasint *);\nvoid BLASFUNC(xhpmv) (char *, blasint *, xdouble  *, xdouble *,\n\t\t     xdouble  *, blasint *, xdouble *, xdouble *, blasint *);\n\nint BLASFUNC(snorm)(char *, blasint *, blasint *, float  *, blasint *);\nint BLASFUNC(dnorm)(char *, blasint *, blasint *, double *, blasint *);\nint BLASFUNC(cnorm)(char *, blasint *, blasint *, float  *, blasint *);\nint BLASFUNC(znorm)(char *, blasint *, blasint *, double *, blasint *);\n\nvoid BLASFUNC(sgbmv)(char *, blasint *, blasint *, blasint *, blasint *, float  *, float  *, blasint *,\n\t\t    float  *, blasint *, float  *, float  *, blasint *);\nvoid BLASFUNC(dgbmv)(char *, blasint *, blasint *, blasint *, blasint *, double *, double *, blasint *,\n\t\t    double *, blasint *, double *, double *, blasint *);\nvoid BLASFUNC(qgbmv)(char *, blasint *, blasint *, blasint *, blasint *, xdouble *, xdouble *, blasint *,\n\t\t    xdouble *, blasint *, xdouble *, xdouble *, blasint *);\nvoid BLASFUNC(cgbmv)(char *, blasint *, blasint *, blasint *, blasint *, float  *, float  *, blasint *,\n\t\t    float  *, blasint *, float  *, float  *, blasint *);\nvoid BLASFUNC(zgbmv)(char *, blasint *, blasint *, blasint *, blasint *, double *, double *, blasint *,\n\t\t    double *, blasint *, double *, double *, blasint *);\nvoid BLASFUNC(xgbmv)(char *, blasint *, blasint *, blasint *, blasint *, xdouble *, xdouble *, blasint *,\n\t\t    xdouble *, blasint *, xdouble *, xdouble *, blasint *);\n\nvoid BLASFUNC(ssbmv)(char *, blasint *, blasint *, float  *, float  *, blasint *,\n\t\t    float  *, blasint *, float  *, float  *, blasint *);\nvoid BLASFUNC(dsbmv)(char *, blasint *, blasint *, double *, double *, blasint *,\n\t\t    double *, blasint *, double *, double *, blasint *);\nvoid BLASFUNC(qsbmv)(char *, blasint *, blasint *, xdouble *, xdouble *, blasint *,\n\t\t    xdouble *, blasint *, xdouble *, xdouble *, blasint *);\nvoid BLASFUNC(csbmv)(char *, blasint *, blasint *, float  *, float  *, blasint *,\n\t\t    float  *, blasint *, float  *, float  *, blasint *);\nvoid BLASFUNC(zsbmv)(char *, blasint *, blasint *, double *, double *, blasint *,\n\t\t    double *, blasint *, double *, double *, blasint *);\nvoid BLASFUNC(xsbmv)(char *, blasint *, blasint *, xdouble *, xdouble *, blasint *,\n\t\t    xdouble *, blasint *, xdouble *, xdouble *, blasint *);\n\nvoid BLASFUNC(chbmv)(char *, blasint *, blasint *, float  *, float  *, blasint *,\n\t\t    float  *, blasint *, float  *, float  *, blasint *);\nvoid BLASFUNC(zhbmv)(char *, blasint *, blasint *, double *, double *, blasint *,\n\t\t    double *, blasint *, double *, double *, blasint *);\nvoid BLASFUNC(xhbmv)(char *, blasint *, blasint *, xdouble *, xdouble *, blasint *,\n\t\t    xdouble *, blasint *, xdouble *, xdouble *, blasint *);\n\n/* Level 3 routines */\n\nvoid BLASFUNC(sbgemm)(char *, char *, blasint *, blasint *, blasint *, float *,\n\t   bfloat16 *, blasint *, bfloat16 *, blasint *, float *, float *, blasint *);\nvoid BLASFUNC(sgemm)(char *, char *, blasint *, blasint *, blasint *, float *,\n\t   float  *, blasint *, float  *, blasint *, float  *, float  *, blasint *);\nvoid BLASFUNC(dgemm)(char *, char *, blasint *, blasint *, blasint *, double *,\n\t   double *, blasint *, double *, blasint *, double *, double *, blasint *);\nvoid BLASFUNC(qgemm)(char *, char *, blasint *, blasint *, blasint *, xdouble *,\n\t   xdouble *, blasint *, xdouble *, blasint *, xdouble *, xdouble *, blasint *);\nvoid BLASFUNC(cgemm)(char *, char *, blasint *, blasint *, blasint *, float *,\n\t   float  *, blasint *, float  *, blasint *, float  *, float  *, blasint *);\nvoid BLASFUNC(zgemm)(char *, char *, blasint *, blasint *, blasint *, double *,\n\t   double *, blasint *, double *, blasint *, double *, double *, blasint *);\nvoid BLASFUNC(xgemm)(char *, char *, blasint *, blasint *, blasint *, xdouble *,\n\t   xdouble *, blasint *, xdouble *, blasint *, xdouble *, xdouble *, blasint *);\n\nvoid BLASFUNC(cgemm3m)(char *, char *, blasint *, blasint *, blasint *, float *,\n\t   float  *, blasint *, float  *, blasint *, float  *, float  *, blasint *);\nvoid BLASFUNC(zgemm3m)(char *, char *, blasint *, blasint *, blasint *, double *,\n\t   double *, blasint *, double *, blasint *, double *, double *, blasint *);\nvoid BLASFUNC(xgemm3m)(char *, char *, blasint *, blasint *, blasint *, xdouble *,\n\t   xdouble *, blasint *, xdouble *, blasint *, xdouble *, xdouble *, blasint *);\n\nvoid BLASFUNC(sgemmt)(char*, char *, char *, blasint *, blasint *, float *,\n\t   float  *, blasint *, float  *, blasint *, float  *, float  *, blasint *);\nvoid BLASFUNC(dgemmt)(char*, char *, char *, blasint *, blasint *, double *,\n\t   double *, blasint *, double *, blasint *, double *, double *, blasint *);\nvoid BLASFUNC(cgemmt)(char*, char *, char *, blasint *, blasint *, float *,\n\t   float  *, blasint *, float  *, blasint *, float  *, float  *, blasint *);\nvoid BLASFUNC(zgemmt)(char*, char *, char *, blasint *, blasint *, double *,\n\t   double *, blasint *, double *, blasint *, double *, double *, blasint *);\n\nint BLASFUNC(sge2mm)(char *, char *, char *, blasint *, blasint *,\n\t\t     float *, float  *, blasint *, float  *, blasint *,\n\t\t     float *, float  *, blasint *);\nint BLASFUNC(dge2mm)(char *, char *, char *, blasint *, blasint *,\n\t\t     double *, double  *, blasint *, double  *, blasint *,\n\t\t     double *, double  *, blasint *);\nint BLASFUNC(cge2mm)(char *, char *, char *, blasint *, blasint *,\n\t\t     float *, float  *, blasint *, float  *, blasint *,\n\t\t     float *, float  *, blasint *);\nint BLASFUNC(zge2mm)(char *, char *, char *, blasint *, blasint *,\n\t\t     double *, double  *, blasint *, double  *, blasint *,\n\t\t     double *, double  *, blasint *);\n\nvoid BLASFUNC(strsm)(char *, char *, char *, char *, blasint *, blasint *,\n\t   float *,  float *, blasint *, float *, blasint *);\nvoid BLASFUNC(dtrsm)(char *, char *, char *, char *, blasint *, blasint *,\n\t   double *,  double *, blasint *, double *, blasint *);\nvoid BLASFUNC(qtrsm)(char *, char *, char *, char *, blasint *, blasint *,\n\t   xdouble *,  xdouble *, blasint *, xdouble *, blasint *);\nvoid BLASFUNC(ctrsm)(char *, char *, char *, char *, blasint *, blasint *,\n\t   float *,  float *, blasint *, float *, blasint *);\nvoid BLASFUNC(ztrsm)(char *, char *, char *, char *, blasint *, blasint *,\n\t   double *,  double *, blasint *, double *, blasint *);\nvoid BLASFUNC(xtrsm)(char *, char *, char *, char *, blasint *, blasint *,\n\t   xdouble *,  xdouble *, blasint *, xdouble *, blasint *);\n\nvoid BLASFUNC(strmm)(char *, char *, char *, char *, blasint *, blasint *,\n\t   float *,  float *, blasint *, float *, blasint *);\nvoid BLASFUNC(dtrmm)(char *, char *, char *, char *, blasint *, blasint *,\n\t   double *,  double *, blasint *, double *, blasint *);\nvoid BLASFUNC(qtrmm)(char *, char *, char *, char *, blasint *, blasint *,\n\t   xdouble *,  xdouble *, blasint *, xdouble *, blasint *);\nvoid BLASFUNC(ctrmm)(char *, char *, char *, char *, blasint *, blasint *,\n\t   float *,  float *, blasint *, float *, blasint *);\nvoid BLASFUNC(ztrmm)(char *, char *, char *, char *, blasint *, blasint *,\n\t   double *,  double *, blasint *, double *, blasint *);\nvoid BLASFUNC(xtrmm)(char *, char *, char *, char *, blasint *, blasint *,\n\t   xdouble *,  xdouble *, blasint *, xdouble *, blasint *);\n\nvoid BLASFUNC(ssymm)(char *, char *, blasint *, blasint *, float  *, float  *, blasint *,\n\t   float  *, blasint *, float  *, float  *, blasint *);\nvoid BLASFUNC(dsymm)(char *, char *, blasint *, blasint *, double *, double *, blasint *,\n\t   double *, blasint *, double *, double *, blasint *);\nvoid BLASFUNC(qsymm)(char *, char *, blasint *, blasint *, xdouble *, xdouble *, blasint *,\n\t   xdouble *, blasint *, xdouble *, xdouble *, blasint *);\nvoid BLASFUNC(csymm)(char *, char *, blasint *, blasint *, float  *, float  *, blasint *,\n\t   float  *, blasint *, float  *, float  *, blasint *);\nvoid BLASFUNC(zsymm)(char *, char *, blasint *, blasint *, double *, double *, blasint *,\n\t   double *, blasint *, double *, double *, blasint *);\nvoid BLASFUNC(xsymm)(char *, char *, blasint *, blasint *, xdouble *, xdouble *, blasint *,\n\t   xdouble *, blasint *, xdouble *, xdouble *, blasint *);\n\nvoid BLASFUNC(csymm3m)(char *, char *, blasint *, blasint *, float  *, float  *, blasint *,\n\t   float  *, blasint *, float  *, float  *, blasint *);\nvoid BLASFUNC(zsymm3m)(char *, char *, blasint *, blasint *, double *, double *, blasint *,\n\t   double *, blasint *, double *, double *, blasint *);\nvoid BLASFUNC(xsymm3m)(char *, char *, blasint *, blasint *, xdouble *, xdouble *, blasint *,\n\t   xdouble *, blasint *, xdouble *, xdouble *, blasint *);\n\nvoid BLASFUNC(ssyrk)(char *, char *, blasint *, blasint *, float  *, float  *, blasint *,\n\t   float  *, float  *, blasint *);\nvoid BLASFUNC(dsyrk)(char *, char *, blasint *, blasint *, double *, double *, blasint *,\n\t   double *, double *, blasint *);\nvoid BLASFUNC(qsyrk)(char *, char *, blasint *, blasint *, xdouble *, xdouble *, blasint *,\n\t   xdouble *, xdouble *, blasint *);\nvoid BLASFUNC(csyrk)(char *, char *, blasint *, blasint *, float  *, float  *, blasint *,\n\t   float  *, float  *, blasint *);\nvoid BLASFUNC(zsyrk)(char *, char *, blasint *, blasint *, double *, double *, blasint *,\n\t   double *, double *, blasint *);\nvoid BLASFUNC(xsyrk)(char *, char *, blasint *, blasint *, xdouble *, xdouble *, blasint *,\n\t   xdouble *, xdouble *, blasint *);\n\nvoid BLASFUNC(ssyr2k)(char *, char *, blasint *, blasint *, float  *, float  *, blasint *,\n\t   float *, blasint *, float  *, float  *, blasint *);\nvoid BLASFUNC(dsyr2k)(char *, char *, blasint *, blasint *, double *, double *, blasint *,\n\t   double*, blasint *, double *, double *, blasint *);\nvoid BLASFUNC(qsyr2k)(char *, char *, blasint *, blasint *, xdouble *, xdouble *, blasint *,\n\t   xdouble*, blasint *, xdouble *, xdouble *, blasint *);\nvoid BLASFUNC(csyr2k)(char *, char *, blasint *, blasint *, float  *, float  *, blasint *,\n\t   float *, blasint *, float  *, float  *, blasint *);\nvoid BLASFUNC(zsyr2k)(char *, char *, blasint *, blasint *, double *, double *, blasint *,\n\t   double*, blasint *, double *, double *, blasint *);\nvoid BLASFUNC(xsyr2k)(char *, char *, blasint *, blasint *, xdouble *, xdouble *, blasint *,\n\t   xdouble*, blasint *, xdouble *, xdouble *, blasint *);\n\nvoid BLASFUNC(chemm)(char *, char *, blasint *, blasint *, float  *, float  *, blasint *,\n\t   float  *, blasint *, float  *, float  *, blasint *);\nvoid BLASFUNC(zhemm)(char *, char *, blasint *, blasint *, double *, double *, blasint *,\n\t   double *, blasint *, double *, double *, blasint *);\nvoid BLASFUNC(xhemm)(char *, char *, blasint *, blasint *, xdouble *, xdouble *, blasint *,\n\t   xdouble *, blasint *, xdouble *, xdouble *, blasint *);\n\nvoid BLASFUNC(chemm3m)(char *, char *, blasint *, blasint *, float  *, float  *, blasint *,\n\t   float  *, blasint *, float  *, float  *, blasint *);\nvoid BLASFUNC(zhemm3m)(char *, char *, blasint *, blasint *, double *, double *, blasint *,\n\t   double *, blasint *, double *, double *, blasint *);\nvoid BLASFUNC(xhemm3m)(char *, char *, blasint *, blasint *, xdouble *, xdouble *, blasint *,\n\t   xdouble *, blasint *, xdouble *, xdouble *, blasint *);\n\nvoid BLASFUNC(cherk)(char *, char *, blasint *, blasint *, float  *, float  *, blasint *,\n\t   float  *, float  *, blasint *);\nvoid BLASFUNC(zherk)(char *, char *, blasint *, blasint *, double *, double *, blasint *,\n\t   double *, double *, blasint *);\nvoid BLASFUNC(xherk)(char *, char *, blasint *, blasint *, xdouble *, xdouble *, blasint *,\n\t   xdouble *, xdouble *, blasint *);\n\nvoid BLASFUNC(cher2k)(char *, char *, blasint *, blasint *, float  *, float  *, blasint *,\n\t   float *, blasint *, float  *, float  *, blasint *);\nvoid BLASFUNC(zher2k)(char *, char *, blasint *, blasint *, double *, double *, blasint *,\n\t   double*, blasint *, double *, double *, blasint *);\nvoid BLASFUNC(xher2k)(char *, char *, blasint *, blasint *, xdouble *, xdouble *, blasint *,\n\t   xdouble*, blasint *, xdouble *, xdouble *, blasint *);\n\nint BLASFUNC(cher2m)(char *, char *, char *, blasint *, blasint *, float  *, float  *, blasint *,\n\t   float *, blasint *, float  *, float  *, blasint *);\nint BLASFUNC(zher2m)(char *, char *, char *, blasint *, blasint *, double *, double *, blasint *,\n\t   double*, blasint *, double *, double *, blasint *);\nint BLASFUNC(xher2m)(char *, char *, char *, blasint *, blasint *, xdouble *, xdouble *, blasint *,\n\t   xdouble*, blasint *, xdouble *, xdouble *, blasint *);\n\nint BLASFUNC(sgemt)(char *, blasint *, blasint *, float  *, float  *, blasint *,\n\t\t    float  *, blasint *);\nint BLASFUNC(dgemt)(char *, blasint *, blasint *, double *, double *, blasint *,\n\t\t    double *, blasint *);\nint BLASFUNC(cgemt)(char *, blasint *, blasint *, float  *, float  *, blasint *,\n\t\t    float  *, blasint *);\nint BLASFUNC(zgemt)(char *, blasint *, blasint *, double *, double *, blasint *,\n\t\t    double *, blasint *);\n\nint BLASFUNC(sgema)(char *, char *, blasint *, blasint *, float  *,\n\t\t    float  *, blasint *, float *, float  *, blasint *, float *, blasint *);\nint BLASFUNC(dgema)(char *, char *, blasint *, blasint *, double *,\n\t\t    double *, blasint *, double*, double *, blasint *, double*, blasint *);\nint BLASFUNC(cgema)(char *, char *, blasint *, blasint *, float  *,\n\t\t    float  *, blasint *, float *, float  *, blasint *, float *, blasint *);\nint BLASFUNC(zgema)(char *, char *, blasint *, blasint *, double *,\n\t\t    double *, blasint *, double*, double *, blasint *, double*, blasint *);\n\nint BLASFUNC(sgems)(char *, char *, blasint *, blasint *, float  *,\n\t\t    float  *, blasint *, float *, float  *, blasint *, float *, blasint *);\nint BLASFUNC(dgems)(char *, char *, blasint *, blasint *, double *,\n\t\t    double *, blasint *, double*, double *, blasint *, double*, blasint *);\nint BLASFUNC(cgems)(char *, char *, blasint *, blasint *, float  *,\n\t\t    float  *, blasint *, float *, float  *, blasint *, float *, blasint *);\nint BLASFUNC(zgems)(char *, char *, blasint *, blasint *, double *,\n\t\t    double *, blasint *, double*, double *, blasint *, double*, blasint *);\n\nint BLASFUNC(sgemc)(char *, char *, blasint *, blasint *, blasint *, float *,\n\t   float  *, blasint *, float  *, blasint *, float  *, blasint *, float  *, float  *, blasint *);\nint BLASFUNC(dgemc)(char *, char *, blasint *, blasint *, blasint *, double *,\n\t   double *, blasint *, double *, blasint *, double *, blasint *, double *, double *, blasint *);\nint BLASFUNC(qgemc)(char *, char *, blasint *, blasint *, blasint *, xdouble *,\n\t   xdouble *, blasint *, xdouble *, blasint *, xdouble *, blasint *,  xdouble *, xdouble *, blasint *);\nint BLASFUNC(cgemc)(char *, char *, blasint *, blasint *, blasint *, float *,\n\t   float  *, blasint *, float  *, blasint *, float  *, blasint *, float  *, float  *, blasint *);\nint BLASFUNC(zgemc)(char *, char *, blasint *, blasint *, blasint *, double *,\n\t   double *, blasint *, double *, blasint *, double *, blasint *, double *, double *, blasint *);\nint BLASFUNC(xgemc)(char *, char *, blasint *, blasint *, blasint *, xdouble *,\n\t   xdouble *, blasint *, xdouble *, blasint *, xdouble *, blasint *, xdouble *, xdouble *, blasint *);\n\n/* Lapack routines */\n\nint BLASFUNC(sgetf2)(blasint *, blasint *, float  *, blasint *, blasint *, blasint *);\nint BLASFUNC(dgetf2)(blasint *, blasint *, double *, blasint *, blasint *, blasint *);\nint BLASFUNC(qgetf2)(blasint *, blasint *, xdouble *, blasint *, blasint *, blasint *);\nint BLASFUNC(cgetf2)(blasint *, blasint *, float  *, blasint *, blasint *, blasint *);\nint BLASFUNC(zgetf2)(blasint *, blasint *, double *, blasint *, blasint *, blasint *);\nint BLASFUNC(xgetf2)(blasint *, blasint *, xdouble *, blasint *, blasint *, blasint *);\n\nint BLASFUNC(sgetrf)(blasint *, blasint *, float  *, blasint *, blasint *, blasint *);\nint BLASFUNC(dgetrf)(blasint *, blasint *, double *, blasint *, blasint *, blasint *);\nint BLASFUNC(qgetrf)(blasint *, blasint *, xdouble *, blasint *, blasint *, blasint *);\nint BLASFUNC(cgetrf)(blasint *, blasint *, float  *, blasint *, blasint *, blasint *);\nint BLASFUNC(zgetrf)(blasint *, blasint *, double *, blasint *, blasint *, blasint *);\nint BLASFUNC(xgetrf)(blasint *, blasint *, xdouble *, blasint *, blasint *, blasint *);\n\nint BLASFUNC(slaswp)(blasint *, float  *, blasint *, blasint *, blasint *, blasint *, blasint *);\nint BLASFUNC(dlaswp)(blasint *, double *, blasint *, blasint *, blasint *, blasint *, blasint *);\nint BLASFUNC(qlaswp)(blasint *, xdouble *, blasint *, blasint *, blasint *, blasint *, blasint *);\nint BLASFUNC(claswp)(blasint *, float  *, blasint *, blasint *, blasint *, blasint *, blasint *);\nint BLASFUNC(zlaswp)(blasint *, double *, blasint *, blasint *, blasint *, blasint *, blasint *);\nint BLASFUNC(xlaswp)(blasint *, xdouble *, blasint *, blasint *, blasint *, blasint *, blasint *);\n\nint BLASFUNC(sgetrs)(char *, blasint *, blasint *, float  *, blasint *, blasint *, float  *, blasint *, blasint *);\nint BLASFUNC(dgetrs)(char *, blasint *, blasint *, double *, blasint *, blasint *, double *, blasint *, blasint *);\nint BLASFUNC(qgetrs)(char *, blasint *, blasint *, xdouble *, blasint *, blasint *, xdouble *, blasint *, blasint *);\nint BLASFUNC(cgetrs)(char *, blasint *, blasint *, float  *, blasint *, blasint *, float  *, blasint *, blasint *);\nint BLASFUNC(zgetrs)(char *, blasint *, blasint *, double *, blasint *, blasint *, double *, blasint *, blasint *);\nint BLASFUNC(xgetrs)(char *, blasint *, blasint *, xdouble *, blasint *, blasint *, xdouble *, blasint *, blasint *);\n\nint BLASFUNC(sgesv)(blasint *, blasint *, float  *, blasint *, blasint *, float *, blasint *, blasint *);\nint BLASFUNC(dgesv)(blasint *, blasint *, double *, blasint *, blasint *, double*, blasint *, blasint *);\nint BLASFUNC(qgesv)(blasint *, blasint *, xdouble *, blasint *, blasint *, xdouble*, blasint *, blasint *);\nint BLASFUNC(cgesv)(blasint *, blasint *, float  *, blasint *, blasint *, float *, blasint *, blasint *);\nint BLASFUNC(zgesv)(blasint *, blasint *, double *, blasint *, blasint *, double*, blasint *, blasint *);\nint BLASFUNC(xgesv)(blasint *, blasint *, xdouble *, blasint *, blasint *, xdouble*, blasint *, blasint *);\n\nint BLASFUNC(spotf2)(char *, blasint *, float  *, blasint *, blasint *);\nint BLASFUNC(dpotf2)(char *, blasint *, double *, blasint *, blasint *);\nint BLASFUNC(qpotf2)(char *, blasint *, xdouble *, blasint *, blasint *);\nint BLASFUNC(cpotf2)(char *, blasint *, float  *, blasint *, blasint *);\nint BLASFUNC(zpotf2)(char *, blasint *, double *, blasint *, blasint *);\nint BLASFUNC(xpotf2)(char *, blasint *, xdouble *, blasint *, blasint *);\n\nint BLASFUNC(spotrf)(char *, blasint *, float  *, blasint *, blasint *);\nint BLASFUNC(dpotrf)(char *, blasint *, double *, blasint *, blasint *);\nint BLASFUNC(qpotrf)(char *, blasint *, xdouble *, blasint *, blasint *);\nint BLASFUNC(cpotrf)(char *, blasint *, float  *, blasint *, blasint *);\nint BLASFUNC(zpotrf)(char *, blasint *, double *, blasint *, blasint *);\nint BLASFUNC(xpotrf)(char *, blasint *, xdouble *, blasint *, blasint *);\n\nint BLASFUNC(spotri)(char *, blasint *, float  *, blasint *, blasint *);\nint BLASFUNC(dpotri)(char *, blasint *, double *, blasint *, blasint *);\nint BLASFUNC(qpotri)(char *, blasint *, xdouble *, blasint *, blasint *);\nint BLASFUNC(cpotri)(char *, blasint *, float  *, blasint *, blasint *);\nint BLASFUNC(zpotri)(char *, blasint *, double *, blasint *, blasint *);\nint BLASFUNC(xpotri)(char *, blasint *, xdouble *, blasint *, blasint *);\n\nint BLASFUNC(spotrs)(char *, blasint *, blasint *, float   *, blasint *, float   *, blasint *, blasint *);\nint BLASFUNC(dpotrs)(char *, blasint *, blasint *, double  *, blasint *, double  *, blasint *, blasint *);\nint BLASFUNC(qpotrs)(char *, blasint *, blasint *, xdouble *, blasint *, xdouble *, blasint *, blasint *);\nint BLASFUNC(cpotrs)(char *, blasint *, blasint *, float   *, blasint *, float   *, blasint *, blasint *);\nint BLASFUNC(zpotrs)(char *, blasint *, blasint *, double  *, blasint *, double  *, blasint *, blasint *);\nint BLASFUNC(xpotrs)(char *, blasint *, blasint *, xdouble *, blasint *, xdouble *, blasint *, blasint *);\n\nint BLASFUNC(slauu2)(char *, blasint *, float  *, blasint *, blasint *);\nint BLASFUNC(dlauu2)(char *, blasint *, double *, blasint *, blasint *);\nint BLASFUNC(qlauu2)(char *, blasint *, xdouble *, blasint *, blasint *);\nint BLASFUNC(clauu2)(char *, blasint *, float  *, blasint *, blasint *);\nint BLASFUNC(zlauu2)(char *, blasint *, double *, blasint *, blasint *);\nint BLASFUNC(xlauu2)(char *, blasint *, xdouble *, blasint *, blasint *);\n\nint BLASFUNC(slauum)(char *, blasint *, float  *, blasint *, blasint *);\nint BLASFUNC(dlauum)(char *, blasint *, double *, blasint *, blasint *);\nint BLASFUNC(qlauum)(char *, blasint *, xdouble *, blasint *, blasint *);\nint BLASFUNC(clauum)(char *, blasint *, float  *, blasint *, blasint *);\nint BLASFUNC(zlauum)(char *, blasint *, double *, blasint *, blasint *);\nint BLASFUNC(xlauum)(char *, blasint *, xdouble *, blasint *, blasint *);\n\nint BLASFUNC(strti2)(char *, char *, blasint *, float  *, blasint *, blasint *);\nint BLASFUNC(dtrti2)(char *, char *, blasint *, double *, blasint *, blasint *);\nint BLASFUNC(qtrti2)(char *, char *, blasint *, xdouble *, blasint *, blasint *);\nint BLASFUNC(ctrti2)(char *, char *, blasint *, float  *, blasint *, blasint *);\nint BLASFUNC(ztrti2)(char *, char *, blasint *, double *, blasint *, blasint *);\nint BLASFUNC(xtrti2)(char *, char *, blasint *, xdouble *, blasint *, blasint *);\n\nint BLASFUNC(strtri)(char *, char *, blasint *, float  *, blasint *, blasint *);\nint BLASFUNC(dtrtri)(char *, char *, blasint *, double *, blasint *, blasint *);\nint BLASFUNC(qtrtri)(char *, char *, blasint *, xdouble *, blasint *, blasint *);\nint BLASFUNC(ctrtri)(char *, char *, blasint *, float  *, blasint *, blasint *);\nint BLASFUNC(ztrtri)(char *, char *, blasint *, double *, blasint *, blasint *);\nint BLASFUNC(xtrtri)(char *, char *, blasint *, xdouble *, blasint *, blasint *);\n\n\nFLOATRET  BLASFUNC(slamch)(char *);\ndouble    BLASFUNC(dlamch)(char *);\nxdouble   BLASFUNC(qlamch)(char *);\n\nFLOATRET  BLASFUNC(slamc3)(float *, float *);\ndouble    BLASFUNC(dlamc3)(double *, double *);\nxdouble   BLASFUNC(qlamc3)(xdouble *, xdouble *);\n\n/* BLAS extensions */\n\nvoid    BLASFUNC(saxpby) (blasint *, float  *, float  *, blasint *, float *, float  *, blasint *);\nvoid    BLASFUNC(daxpby) (blasint *, double  *, double  *, blasint *, double *, double  *, blasint *);\nvoid    BLASFUNC(caxpby) (blasint *, void  *, float  *, blasint *, void *, float  *, blasint *);\nvoid    BLASFUNC(zaxpby) (blasint *, void  *, double *, blasint *, void *, double  *, blasint *);\n\nvoid    BLASFUNC(somatcopy) (char *, char *, blasint *, blasint *, float  *, float  *, blasint *, float  *, blasint *);\nvoid    BLASFUNC(domatcopy) (char *, char *, blasint *, blasint *, double  *, double  *, blasint *, double  *, blasint *);\nvoid    BLASFUNC(comatcopy) (char *, char *, blasint *, blasint *, float  *, float  *, blasint *, float  *, blasint *);\nvoid    BLASFUNC(zomatcopy) (char *, char *, blasint *, blasint *, double  *, double  *, blasint *, double  *, blasint *);\n\nvoid    BLASFUNC(simatcopy) (char *, char *, blasint *, blasint *, float  *, float  *, blasint *, blasint *);\nvoid    BLASFUNC(dimatcopy) (char *, char *, blasint *, blasint *, double  *, double  *, blasint *, blasint *);\nvoid    BLASFUNC(cimatcopy) (char *, char *, blasint *, blasint *, float  *, float  *, blasint *, blasint *);\nvoid    BLASFUNC(zimatcopy) (char *, char *, blasint *, blasint *, double  *, double  *, blasint *, blasint *);\n\nvoid    BLASFUNC(sgeadd) (blasint *, blasint *, float *, float *, blasint *, float *, float *, blasint*); \nvoid    BLASFUNC(dgeadd) (blasint *, blasint *, double *, double *, blasint *, double *, double *, blasint*); \nvoid    BLASFUNC(cgeadd) (blasint *, blasint *, float *, float *, blasint *, float *, float *, blasint*); \nvoid    BLASFUNC(zgeadd) (blasint *, blasint *, double *, double *, blasint *, double *, double *, blasint*); \n\n\n#ifdef __cplusplus\n}\n\n#endif  /* __cplusplus */\n\n#endif\n"
        },
        {
          "name": "common_lapack.h",
          "type": "blob",
          "size": 37.353515625,
          "content": "/*********************************************************************/\n/* Copyright 2009, 2010 The University of Texas at Austin.           */\n/* All rights reserved.                                              */\n/*                                                                   */\n/* Redistribution and use in source and binary forms, with or        */\n/* without modification, are permitted provided that the following   */\n/* conditions are met:                                               */\n/*                                                                   */\n/*   1. Redistributions of source code must retain the above         */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer.                                                  */\n/*                                                                   */\n/*   2. Redistributions in binary form must reproduce the above      */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer in the documentation and/or other materials       */\n/*      provided with the distribution.                              */\n/*                                                                   */\n/*    THIS  SOFTWARE IS PROVIDED  BY THE  UNIVERSITY OF  TEXAS AT    */\n/*    AUSTIN  ``AS IS''  AND ANY  EXPRESS OR  IMPLIED WARRANTIES,    */\n/*    INCLUDING, BUT  NOT LIMITED  TO, THE IMPLIED  WARRANTIES OF    */\n/*    MERCHANTABILITY  AND FITNESS FOR  A PARTICULAR  PURPOSE ARE    */\n/*    DISCLAIMED.  IN  NO EVENT SHALL THE UNIVERSITY  OF TEXAS AT    */\n/*    AUSTIN OR CONTRIBUTORS BE  LIABLE FOR ANY DIRECT, INDIRECT,    */\n/*    INCIDENTAL,  SPECIAL, EXEMPLARY,  OR  CONSEQUENTIAL DAMAGES    */\n/*    (INCLUDING, BUT  NOT LIMITED TO,  PROCUREMENT OF SUBSTITUTE    */\n/*    GOODS  OR  SERVICES; LOSS  OF  USE,  DATA,  OR PROFITS;  OR    */\n/*    BUSINESS INTERRUPTION) HOWEVER CAUSED  AND ON ANY THEORY OF    */\n/*    LIABILITY, WHETHER  IN CONTRACT, STRICT  LIABILITY, OR TORT    */\n/*    (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY WAY OUT    */\n/*    OF  THE  USE OF  THIS  SOFTWARE,  EVEN  IF ADVISED  OF  THE    */\n/*    POSSIBILITY OF SUCH DAMAGE.                                    */\n/*                                                                   */\n/* The views and conclusions contained in the software and           */\n/* documentation are those of the authors and should not be          */\n/* interpreted as representing official policies, either expressed   */\n/* or implied, of The University of Texas at Austin.                 */\n/*********************************************************************/\n\n#ifndef ASSEMBLER\n\n/* Lapack Library */\n\nblasint sgetf2_k(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint dgetf2_k(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint qgetf2_k(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint cgetf2_k(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint zgetf2_k(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint xgetf2_k(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\n\nblasint sgetrf_single(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint dgetrf_single(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint qgetrf_single(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint cgetrf_single(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint zgetrf_single(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint xgetrf_single(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\n\nblasint sgetrf_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint dgetrf_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint qgetrf_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint cgetrf_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint zgetrf_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint xgetrf_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\n\nint slaswp_plus (BLASLONG, BLASLONG, BLASLONG, float,   float   *, BLASLONG, float  *, BLASLONG, blasint *, BLASLONG);\nint slaswp_minus(BLASLONG, BLASLONG, BLASLONG, float,   float   *, BLASLONG, float  *, BLASLONG, blasint *, BLASLONG);\nint dlaswp_plus (BLASLONG, BLASLONG, BLASLONG, double,  double  *, BLASLONG, double *, BLASLONG, blasint *, BLASLONG);\nint dlaswp_minus(BLASLONG, BLASLONG, BLASLONG, double,  double  *, BLASLONG, double *, BLASLONG, blasint *, BLASLONG);\nint qlaswp_plus (BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, blasint *, BLASLONG);\nint qlaswp_minus(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, blasint *, BLASLONG);\n\nint claswp_plus (BLASLONG, BLASLONG, BLASLONG, float,   float,   float   *, BLASLONG, float   *, BLASLONG, blasint *, BLASLONG);\nint claswp_minus(BLASLONG, BLASLONG, BLASLONG, float,   float,   float   *, BLASLONG, float   *, BLASLONG, blasint *, BLASLONG);\nint zlaswp_plus (BLASLONG, BLASLONG, BLASLONG, double,  double,  double  *, BLASLONG, double  *, BLASLONG, blasint *, BLASLONG);\nint zlaswp_minus(BLASLONG, BLASLONG, BLASLONG, double,  double,  double  *, BLASLONG, double  *, BLASLONG, blasint *, BLASLONG);\nint xlaswp_plus (BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, blasint *, BLASLONG);\nint xlaswp_minus(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, blasint *, BLASLONG);\n\nint slaswp_ncopy(BLASLONG, BLASLONG, BLASLONG, float   *, BLASLONG, blasint *, float   *);\nint dlaswp_ncopy(BLASLONG, BLASLONG, BLASLONG, double  *, BLASLONG, blasint *, double  *);\nint qlaswp_ncopy(BLASLONG, BLASLONG, BLASLONG, xdouble *, BLASLONG, blasint *, xdouble *);\nint claswp_ncopy(BLASLONG, BLASLONG, BLASLONG, float   *, BLASLONG, blasint *, float   *);\nint zlaswp_ncopy(BLASLONG, BLASLONG, BLASLONG, double  *, BLASLONG, blasint *, double  *);\nint xlaswp_ncopy(BLASLONG, BLASLONG, BLASLONG, xdouble *, BLASLONG, blasint *, xdouble *);\n\nblasint sgetrs_N_single(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint sgetrs_T_single(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint dgetrs_N_single(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint dgetrs_T_single(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint qgetrs_N_single(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint qgetrs_T_single(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint cgetrs_N_single(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint cgetrs_T_single(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint cgetrs_R_single(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint cgetrs_C_single(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint zgetrs_N_single(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint zgetrs_T_single(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint zgetrs_R_single(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint zgetrs_C_single(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint xgetrs_N_single(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint xgetrs_T_single(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint xgetrs_R_single(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint xgetrs_C_single(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\n\nblasint sgetrs_N_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint sgetrs_T_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint dgetrs_N_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint dgetrs_T_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint qgetrs_N_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint qgetrs_T_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint cgetrs_N_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint cgetrs_T_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint cgetrs_R_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint cgetrs_C_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint zgetrs_N_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint zgetrs_T_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint zgetrs_R_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint zgetrs_C_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint xgetrs_N_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint xgetrs_T_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint xgetrs_R_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint xgetrs_C_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\n\nblasint spotf2_U(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint spotf2_L(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint dpotf2_U(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint dpotf2_L(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint qpotf2_U(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint qpotf2_L(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint cpotf2_U(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint cpotf2_L(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint zpotf2_U(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint zpotf2_L(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint xpotf2_U(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint xpotf2_L(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\n\nblasint spotrf_U_single(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint spotrf_L_single(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint dpotrf_U_single(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint dpotrf_L_single(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint qpotrf_U_single(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint qpotrf_L_single(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint cpotrf_U_single(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint cpotrf_L_single(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint zpotrf_U_single(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint zpotrf_L_single(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint xpotrf_U_single(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint xpotrf_L_single(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\n\nblasint spotrf_U_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint spotrf_L_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint dpotrf_U_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint dpotrf_L_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint qpotrf_U_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint qpotrf_L_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint cpotrf_U_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint cpotrf_L_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint zpotrf_U_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint zpotrf_L_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint xpotrf_U_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint xpotrf_L_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\n\nblasint slauu2_U(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint slauu2_L(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint dlauu2_U(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint dlauu2_L(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint qlauu2_U(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint qlauu2_L(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint clauu2_U(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint clauu2_L(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint zlauu2_U(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint zlauu2_L(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint xlauu2_U(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint xlauu2_L(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\n\nblasint slauum_U_single(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint slauum_L_single(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint dlauum_U_single(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint dlauum_L_single(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint qlauum_U_single(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint qlauum_L_single(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint clauum_U_single(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint clauum_L_single(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint zlauum_U_single(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint zlauum_L_single(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint xlauum_U_single(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint xlauum_L_single(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\n\nblasint slauum_U_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint slauum_L_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint dlauum_U_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint dlauum_L_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint qlauum_U_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint qlauum_L_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint clauum_U_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint clauum_L_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint zlauum_U_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint zlauum_L_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint xlauum_U_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint xlauum_L_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\n\nblasint strti2_UU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint strti2_UN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint strti2_LU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint strti2_LN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint dtrti2_UU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint dtrti2_UN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint dtrti2_LU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint dtrti2_LN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint qtrti2_UU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint qtrti2_UN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint qtrti2_LU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint qtrti2_LN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint ctrti2_UU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint ctrti2_UN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint ctrti2_LU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint ctrti2_LN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint ztrti2_UU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint ztrti2_UN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint ztrti2_LU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint ztrti2_LN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint xtrti2_UU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint xtrti2_UN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint xtrti2_LU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint xtrti2_LN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\n\nblasint strtri_UU_single(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint strtri_UN_single(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint strtri_LU_single(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint strtri_LN_single(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint dtrtri_UU_single(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint dtrtri_UN_single(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint dtrtri_LU_single(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint dtrtri_LN_single(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint qtrtri_UU_single(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint qtrtri_UN_single(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint qtrtri_LU_single(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint qtrtri_LN_single(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint ctrtri_UU_single(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint ctrtri_UN_single(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint ctrtri_LU_single(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint ctrtri_LN_single(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint ztrtri_UU_single(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint ztrtri_UN_single(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint ztrtri_LU_single(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint ztrtri_LN_single(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint xtrtri_UU_single(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint xtrtri_UN_single(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint xtrtri_LU_single(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint xtrtri_LN_single(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\n\nblasint strtri_UU_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint strtri_UN_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint strtri_LU_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint strtri_LN_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint dtrtri_UU_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint dtrtri_UN_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint dtrtri_LU_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint dtrtri_LN_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint qtrtri_UU_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint qtrtri_UN_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint qtrtri_LU_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint qtrtri_LN_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint ctrtri_UU_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint ctrtri_UN_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint ctrtri_LU_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint ctrtri_LN_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint ztrtri_UU_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint ztrtri_UN_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint ztrtri_LU_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint ztrtri_LN_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint xtrtri_UU_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint xtrtri_UN_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint xtrtri_LU_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint xtrtri_LN_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\n\nint sneg_tcopy(BLASLONG, BLASLONG, float   *, BLASLONG, float   *);\nint dneg_tcopy(BLASLONG, BLASLONG, double  *, BLASLONG, double  *);\nint qneg_tcopy(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *);\nint cneg_tcopy(BLASLONG, BLASLONG, float   *, BLASLONG, float   *);\nint zneg_tcopy(BLASLONG, BLASLONG, double  *, BLASLONG, double  *);\nint xneg_tcopy(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *);\n\nblasint slarf_L(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint slarf_R(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint dlarf_L(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint dlarf_R(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint qlarf_L(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint qlarf_R(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint clarf_L(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint clarf_R(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint zlarf_L(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint zlarf_R(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint xlarf_L(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint xlarf_R(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\n\nblasint strtrs_UNU_single(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint strtrs_UNN_single(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint strtrs_UTU_single(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint strtrs_UTN_single(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint strtrs_LNU_single(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint strtrs_LNN_single(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint strtrs_LTU_single(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint strtrs_LTN_single(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint dtrtrs_UNU_single(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint dtrtrs_UNN_single(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint dtrtrs_UTU_single(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint dtrtrs_UTN_single(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint dtrtrs_LNU_single(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint dtrtrs_LNN_single(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint dtrtrs_LTU_single(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint dtrtrs_LTN_single(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint qtrtrs_UNU_single(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint qtrtrs_UNN_single(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint qtrtrs_UTU_single(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint qtrtrs_UTN_single(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint qtrtrs_LNU_single(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint qtrtrs_LNN_single(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint qtrtrs_LTU_single(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint qtrtrs_LTN_single(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint ctrtrs_UNU_single(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint ctrtrs_UNN_single(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint ctrtrs_UTU_single(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint ctrtrs_UTN_single(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint ctrtrs_URU_single(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint ctrtrs_URN_single(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint ctrtrs_UCU_single(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint ctrtrs_UCN_single(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint ctrtrs_LNU_single(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint ctrtrs_LNN_single(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint ctrtrs_LTU_single(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint ctrtrs_LTN_single(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint ctrtrs_LRU_single(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint ctrtrs_LRN_single(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint ctrtrs_LCU_single(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint ctrtrs_LCN_single(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint ztrtrs_UNU_single(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint ztrtrs_UNN_single(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint ztrtrs_UTU_single(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint ztrtrs_UTN_single(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint ztrtrs_URU_single(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint ztrtrs_URN_single(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint ztrtrs_UCU_single(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint ztrtrs_UCN_single(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint ztrtrs_LNU_single(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint ztrtrs_LNN_single(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint ztrtrs_LTU_single(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint ztrtrs_LTN_single(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint ztrtrs_LRU_single(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint ztrtrs_LRN_single(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint ztrtrs_LCU_single(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint ztrtrs_LCN_single(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint xtrtrs_UNU_single(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint xtrtrs_UNN_single(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint xtrtrs_UTU_single(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint xtrtrs_UTN_single(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint xtrtrs_URU_single(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint xtrtrs_URN_single(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint xtrtrs_UCU_single(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint xtrtrs_UCN_single(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint xtrtrs_LNU_single(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint xtrtrs_LNN_single(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint xtrtrs_LTU_single(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint xtrtrs_LTN_single(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint xtrtrs_LRU_single(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint xtrtrs_LRN_single(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint xtrtrs_LCU_single(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint xtrtrs_LCN_single(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\n\nblasint strtrs_UNU_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint strtrs_UNN_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint strtrs_UTU_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint strtrs_UTN_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint strtrs_LNU_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint strtrs_LNN_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint strtrs_LTU_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint strtrs_LTN_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint dtrtrs_UNU_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint dtrtrs_UNN_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint dtrtrs_UTU_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint dtrtrs_UTN_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint dtrtrs_LNU_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint dtrtrs_LNN_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint dtrtrs_LTU_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint dtrtrs_LTN_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint qtrtrs_UNU_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint qtrtrs_UNN_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint qtrtrs_UTU_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint qtrtrs_UTN_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint qtrtrs_LNU_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint qtrtrs_LNN_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint qtrtrs_LTU_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint qtrtrs_LTN_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint ctrtrs_UNU_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint ctrtrs_UNN_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint ctrtrs_UTU_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint ctrtrs_UTN_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint ctrtrs_URU_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint ctrtrs_URN_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint ctrtrs_UCU_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint ctrtrs_UCN_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint ctrtrs_LNU_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint ctrtrs_LNN_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint ctrtrs_LTU_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint ctrtrs_LTN_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint ctrtrs_LRU_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint ctrtrs_LRN_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint ctrtrs_LCU_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint ctrtrs_LCN_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nblasint ztrtrs_UNU_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint ztrtrs_UNN_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint ztrtrs_UTU_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint ztrtrs_UTN_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint ztrtrs_URU_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint ztrtrs_URN_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint ztrtrs_UCU_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint ztrtrs_UCN_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint ztrtrs_LNU_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint ztrtrs_LNN_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint ztrtrs_LTU_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint ztrtrs_LTN_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint ztrtrs_LRU_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint ztrtrs_LRN_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint ztrtrs_LCU_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint ztrtrs_LCN_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nblasint xtrtrs_UNU_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint xtrtrs_UNN_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint xtrtrs_UTU_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint xtrtrs_UTN_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint xtrtrs_URU_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint xtrtrs_URN_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint xtrtrs_UCU_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint xtrtrs_UCN_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint xtrtrs_LNU_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint xtrtrs_LNN_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint xtrtrs_LTU_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint xtrtrs_LTN_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint xtrtrs_LRU_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint xtrtrs_LRN_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint xtrtrs_LCU_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nblasint xtrtrs_LCN_parallel(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\n\n#endif\n"
        },
        {
          "name": "common_level1.h",
          "type": "blob",
          "size": 11.9990234375,
          "content": "/*********************************************************************/\n/* Copyright 2009, 2010 The University of Texas at Austin.           */\n/* All rights reserved.                                              */\n/*                                                                   */\n/* Redistribution and use in source and binary forms, with or        */\n/* without modification, are permitted provided that the following   */\n/* conditions are met:                                               */\n/*                                                                   */\n/*   1. Redistributions of source code must retain the above         */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer.                                                  */\n/*                                                                   */\n/*   2. Redistributions in binary form must reproduce the above      */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer in the documentation and/or other materials       */\n/*      provided with the distribution.                              */\n/*                                                                   */\n/*    THIS  SOFTWARE IS PROVIDED  BY THE  UNIVERSITY OF  TEXAS AT    */\n/*    AUSTIN  ``AS IS''  AND ANY  EXPRESS OR  IMPLIED WARRANTIES,    */\n/*    INCLUDING, BUT  NOT LIMITED  TO, THE IMPLIED  WARRANTIES OF    */\n/*    MERCHANTABILITY  AND FITNESS FOR  A PARTICULAR  PURPOSE ARE    */\n/*    DISCLAIMED.  IN  NO EVENT SHALL THE UNIVERSITY  OF TEXAS AT    */\n/*    AUSTIN OR CONTRIBUTORS BE  LIABLE FOR ANY DIRECT, INDIRECT,    */\n/*    INCIDENTAL,  SPECIAL, EXEMPLARY,  OR  CONSEQUENTIAL DAMAGES    */\n/*    (INCLUDING, BUT  NOT LIMITED TO,  PROCUREMENT OF SUBSTITUTE    */\n/*    GOODS  OR  SERVICES; LOSS  OF  USE,  DATA,  OR PROFITS;  OR    */\n/*    BUSINESS INTERRUPTION) HOWEVER CAUSED  AND ON ANY THEORY OF    */\n/*    LIABILITY, WHETHER  IN CONTRACT, STRICT  LIABILITY, OR TORT    */\n/*    (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY WAY OUT    */\n/*    OF  THE  USE OF  THIS  SOFTWARE,  EVEN  IF ADVISED  OF  THE    */\n/*    POSSIBILITY OF SUCH DAMAGE.                                    */\n/*                                                                   */\n/* The views and conclusions contained in the software and           */\n/* documentation are those of the authors and should not be          */\n/* interpreted as representing official policies, either expressed   */\n/* or implied, of The University of Texas at Austin.                 */\n/*********************************************************************/\n\n#ifndef ASSEMBLER\n\n#ifdef __CUDACC__\nextern \"C\" {\n#endif\n\nfloat   sdot_k(BLASLONG, float   *, BLASLONG, float   *, BLASLONG);\ndouble dsdot_k(BLASLONG, float   *, BLASLONG, float *, BLASLONG);\ndouble  ddot_k(BLASLONG, double  *, BLASLONG, double  *, BLASLONG);\nxdouble qdot_k(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG);\nfloat  sbdot_k(BLASLONG, bfloat16 *, BLASLONG, bfloat16 *, BLASLONG);\n\nvoid   sbstobf16_k(BLASLONG, float    *, BLASLONG, bfloat16 *, BLASLONG);\nvoid   sbdtobf16_k(BLASLONG, double   *, BLASLONG, bfloat16 *, BLASLONG);\nvoid   sbf16tos_k (BLASLONG, bfloat16 *, BLASLONG, float    *, BLASLONG);\nvoid   dbf16tod_k (BLASLONG, bfloat16 *, BLASLONG, double   *, BLASLONG);\n\nopenblas_complex_float cdotc_k (BLASLONG, float  *, BLASLONG, float  *, BLASLONG);\nopenblas_complex_float cdotu_k (BLASLONG, float  *, BLASLONG, float  *, BLASLONG);\nopenblas_complex_double zdotc_k (BLASLONG, double *, BLASLONG, double *, BLASLONG);\nopenblas_complex_double zdotu_k (BLASLONG, double *, BLASLONG, double *, BLASLONG);\nopenblas_complex_xdouble xdotc_k (BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG);\nopenblas_complex_xdouble xdotu_k (BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG);\n\nint    saxpy_k (BLASLONG, BLASLONG, BLASLONG, float,\n\t       float  *, BLASLONG, float  *, BLASLONG, float  *, BLASLONG);\nint    daxpy_k (BLASLONG, BLASLONG, BLASLONG, double,\n\t       double *, BLASLONG, double *, BLASLONG, double *, BLASLONG);\nint    qaxpy_k (BLASLONG, BLASLONG, BLASLONG, xdouble,\n\t       xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG);\nint    caxpy_k (BLASLONG, BLASLONG, BLASLONG, float,  float,\n\t       float  *, BLASLONG, float  *, BLASLONG, float  *, BLASLONG);\nint    zaxpy_k (BLASLONG, BLASLONG, BLASLONG, double, double,\n\t       double *, BLASLONG, double *, BLASLONG, double *, BLASLONG);\nint    xaxpy_k (BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble,\n\t       xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG);\nint    caxpyc_k (BLASLONG, BLASLONG, BLASLONG, float,  float,\n\t       float  *, BLASLONG, float  *, BLASLONG, float  *, BLASLONG);\nint    zaxpyc_k (BLASLONG, BLASLONG, BLASLONG, double, double,\n\t       double *, BLASLONG, double *, BLASLONG, double *, BLASLONG);\nint    xaxpyc_k (BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble,\n\t       xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG);\n\nint    scopy_k(BLASLONG, float  *, BLASLONG, float  *, BLASLONG);\nint    dcopy_k(BLASLONG, double *, BLASLONG, double *, BLASLONG);\nint    qcopy_k(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG);\nint    ccopy_k(BLASLONG, float  *, BLASLONG, float  *, BLASLONG);\nint    zcopy_k(BLASLONG, double *, BLASLONG, double *, BLASLONG);\nint    xcopy_k(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG);\n\nint    sswap_k (BLASLONG, BLASLONG, BLASLONG, float,\n\t       float  *, BLASLONG, float  *, BLASLONG, float *, BLASLONG);\nint    dswap_k (BLASLONG, BLASLONG, BLASLONG, double,\n\t       double *, BLASLONG, double *, BLASLONG, double*, BLASLONG);\nint    qswap_k (BLASLONG, BLASLONG, BLASLONG, xdouble,\n\t       xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble*, BLASLONG);\nint    cswap_k (BLASLONG, BLASLONG, BLASLONG, float,  float,\n\t       float  *, BLASLONG, float  *, BLASLONG, float *, BLASLONG);\nint    zswap_k (BLASLONG, BLASLONG, BLASLONG, double, double,\n\t       double *, BLASLONG, double *, BLASLONG, double*, BLASLONG);\nint    xswap_k (BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble,\n\t       xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble*, BLASLONG);\n\nfloat   sasum_k (BLASLONG, float  *, BLASLONG);\ndouble  dasum_k (BLASLONG, double *, BLASLONG);\nxdouble qasum_k (BLASLONG, xdouble *, BLASLONG);\nfloat   casum_k (BLASLONG, float  *, BLASLONG);\ndouble  zasum_k (BLASLONG, double *, BLASLONG);\nxdouble xasum_k (BLASLONG, xdouble *, BLASLONG);\n\nfloat   ssum_k (BLASLONG, float  *, BLASLONG);\ndouble  dsum_k (BLASLONG, double *, BLASLONG);\nxdouble qsum_k (BLASLONG, xdouble *, BLASLONG);\nfloat   csum_k (BLASLONG, float  *, BLASLONG);\ndouble  zsum_k (BLASLONG, double *, BLASLONG);\nxdouble xsum_k (BLASLONG, xdouble *, BLASLONG);\n\nfloat   samax_k (BLASLONG, float  *, BLASLONG);\ndouble  damax_k (BLASLONG, double *, BLASLONG);\nxdouble qamax_k (BLASLONG, xdouble *, BLASLONG);\nfloat   camax_k (BLASLONG, float  *, BLASLONG);\ndouble  zamax_k (BLASLONG, double *, BLASLONG);\nxdouble xamax_k (BLASLONG, xdouble *, BLASLONG);\n\nfloat   samin_k (BLASLONG, float  *, BLASLONG);\ndouble  damin_k (BLASLONG, double *, BLASLONG);\nxdouble qamin_k (BLASLONG, xdouble *, BLASLONG);\nfloat   camin_k (BLASLONG, float  *, BLASLONG);\ndouble  zamin_k (BLASLONG, double *, BLASLONG);\nxdouble xamin_k (BLASLONG, xdouble *, BLASLONG);\n\nBLASLONG   isamax_k(BLASLONG, float  *, BLASLONG);\nBLASLONG   idamax_k(BLASLONG, double *, BLASLONG);\nBLASLONG   iqamax_k(BLASLONG, xdouble *, BLASLONG);\nBLASLONG   icamax_k(BLASLONG, float  *, BLASLONG);\nBLASLONG   izamax_k(BLASLONG, double *, BLASLONG);\nBLASLONG   ixamax_k(BLASLONG, xdouble *, BLASLONG);\n\nBLASLONG   isamin_k(BLASLONG, float  *, BLASLONG);\nBLASLONG   idamin_k(BLASLONG, double *, BLASLONG);\nBLASLONG   iqamin_k(BLASLONG, xdouble *, BLASLONG);\nBLASLONG   icamin_k(BLASLONG, float  *, BLASLONG);\nBLASLONG   izamin_k(BLASLONG, double *, BLASLONG);\nBLASLONG   ixamin_k(BLASLONG, xdouble *, BLASLONG);\n\nfloat   smax_k (BLASLONG, float  *, BLASLONG);\ndouble  dmax_k (BLASLONG, double *, BLASLONG);\nxdouble qmax_k (BLASLONG, xdouble *, BLASLONG);\nfloat   cmax_k (BLASLONG, float  *, BLASLONG);\ndouble  zmax_k (BLASLONG, double *, BLASLONG);\nxdouble xmax_k (BLASLONG, xdouble *, BLASLONG);\n\nfloat   smin_k (BLASLONG, float  *, BLASLONG);\ndouble  dmin_k (BLASLONG, double *, BLASLONG);\nxdouble qmin_k (BLASLONG, xdouble *, BLASLONG);\nfloat   cmin_k (BLASLONG, float  *, BLASLONG);\ndouble  zmin_k (BLASLONG, double *, BLASLONG);\nxdouble xmin_k (BLASLONG, xdouble *, BLASLONG);\n\nBLASLONG   ismax_k(BLASLONG, float  *, BLASLONG);\nBLASLONG   idmax_k(BLASLONG, double *, BLASLONG);\nBLASLONG   iqmax_k(BLASLONG, xdouble *, BLASLONG);\nBLASLONG   icmax_k(BLASLONG, float  *, BLASLONG);\nBLASLONG   izmax_k(BLASLONG, double *, BLASLONG);\nBLASLONG   ixmax_k(BLASLONG, xdouble *, BLASLONG);\n\nBLASLONG   ismin_k(BLASLONG, float  *, BLASLONG);\nBLASLONG   idmin_k(BLASLONG, double *, BLASLONG);\nBLASLONG   iqmin_k(BLASLONG, xdouble *, BLASLONG);\nBLASLONG   icmin_k(BLASLONG, float  *, BLASLONG);\nBLASLONG   izmin_k(BLASLONG, double *, BLASLONG);\nBLASLONG   ixmin_k(BLASLONG, xdouble *, BLASLONG);\n\nint    sscal_k(BLASLONG, BLASLONG, BLASLONG, float,\n\t      float *, BLASLONG, float *, BLASLONG,  float  *, BLASLONG);\nint    dscal_k(BLASLONG, BLASLONG, BLASLONG, double,\n\t      double *, BLASLONG, double *, BLASLONG,  double  *, BLASLONG);\nint    qscal_k(BLASLONG, BLASLONG, BLASLONG, xdouble,\n\t      xdouble *, BLASLONG, xdouble *, BLASLONG,  xdouble  *, BLASLONG);\nint    cscal_k(BLASLONG, BLASLONG, BLASLONG, float, float,\n\t      float *, BLASLONG, float *, BLASLONG,  float  *, BLASLONG);\nint    zscal_k(BLASLONG, BLASLONG, BLASLONG, double, double,\n\t      double *, BLASLONG, double *, BLASLONG,  double  *, BLASLONG);\nint    xscal_k(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble,\n\t      xdouble *, BLASLONG, xdouble *, BLASLONG,  xdouble  *, BLASLONG);\nint    csscal_k(BLASLONG, BLASLONG, BLASLONG, float, float,\n\t       float *, BLASLONG, float *, BLASLONG,  float  *, BLASLONG);\nint    zdscal_k(BLASLONG, BLASLONG, BLASLONG, double, double,\n\t       double *, BLASLONG, double *, BLASLONG,  double  *, BLASLONG);\nint    xqscal_k(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble,\n\t       xdouble *, BLASLONG, xdouble *, BLASLONG,  xdouble  *, BLASLONG);\n\nfloat   snrm2_k(BLASLONG, float   *, BLASLONG);\ndouble  dnrm2_k(BLASLONG, double  *, BLASLONG);\nxdouble qnrm2_k(BLASLONG, xdouble *, BLASLONG);\nfloat   cnrm2_k(BLASLONG, float   *, BLASLONG);\ndouble  znrm2_k(BLASLONG, double  *, BLASLONG);\nxdouble xnrm2_k(BLASLONG, xdouble *, BLASLONG);\n\nint    srot_k (BLASLONG, float  *, BLASLONG, float  *, BLASLONG, float , float );\nint    drot_k (BLASLONG, double *, BLASLONG, double *, BLASLONG, double, double);\nint    qrot_k (BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble, xdouble);\nint    csrot_k(BLASLONG, float  *, BLASLONG, float  *, BLASLONG, float , float );\nint    zdrot_k(BLASLONG, double *, BLASLONG, double *, BLASLONG, double, double);\nint    xqrot_k(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble, xdouble);\n\nint    srotg_k(float  *, float  *, float  *, float  *);\nint    drotg_k(double *, double *, double *, double *);\nint    qrotg_k(xdouble *, xdouble *, xdouble *, xdouble *);\nint    csrotg_k(float  *, float  *, float  *, float  *);\nint    zdrotg_k(double *, double *, double *, double *);\nint    xqrotg_k(xdouble *, xdouble *, xdouble *, xdouble *);\n\nint    srotmg_k(float  *, float  *, float  *, float  *, float  *);\nint    drotmg_k(double *, double *, double *, double *, double *);\nint    qrotmg_k(xdouble *, xdouble *, xdouble *, xdouble *, xdouble *);\n\nint    srotm_k (BLASLONG, float,  BLASLONG, float,  BLASLONG, float);\nint    drotm_k (BLASLONG, double, BLASLONG, double, BLASLONG, double);\nint    qrotm_k (BLASLONG, xdouble, BLASLONG, xdouble, BLASLONG, xdouble);\n\n\nint    saxpby_k (BLASLONG, float,  float  *, BLASLONG, float,  float  *, BLASLONG);\nint    daxpby_k (BLASLONG, double, double *, BLASLONG, double, double *, BLASLONG);\nint    caxpby_k (BLASLONG, float,  float,  float  *, BLASLONG, float,  float,  float  *, BLASLONG);\nint    zaxpby_k (BLASLONG, double, double, double *, BLASLONG, double, double, double *, BLASLONG);\n\n\n#ifdef __CUDACC__\n}\n#endif\n\n#endif\n\n"
        },
        {
          "name": "common_level2.h",
          "type": "blob",
          "size": 106.5,
          "content": "/*********************************************************************/\n/* Copyright 2009, 2010 The University of Texas at Austin.           */\n/* All rights reserved.                                              */\n/*                                                                   */\n/* Redistribution and use in source and binary forms, with or        */\n/* without modification, are permitted provided that the following   */\n/* conditions are met:                                               */\n/*                                                                   */\n/*   1. Redistributions of source code must retain the above         */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer.                                                  */\n/*                                                                   */\n/*   2. Redistributions in binary form must reproduce the above      */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer in the documentation and/or other materials       */\n/*      provided with the distribution.                              */\n/*                                                                   */\n/*    THIS  SOFTWARE IS PROVIDED  BY THE  UNIVERSITY OF  TEXAS AT    */\n/*    AUSTIN  ``AS IS''  AND ANY  EXPRESS OR  IMPLIED WARRANTIES,    */\n/*    INCLUDING, BUT  NOT LIMITED  TO, THE IMPLIED  WARRANTIES OF    */\n/*    MERCHANTABILITY  AND FITNESS FOR  A PARTICULAR  PURPOSE ARE    */\n/*    DISCLAIMED.  IN  NO EVENT SHALL THE UNIVERSITY  OF TEXAS AT    */\n/*    AUSTIN OR CONTRIBUTORS BE  LIABLE FOR ANY DIRECT, INDIRECT,    */\n/*    INCIDENTAL,  SPECIAL, EXEMPLARY,  OR  CONSEQUENTIAL DAMAGES    */\n/*    (INCLUDING, BUT  NOT LIMITED TO,  PROCUREMENT OF SUBSTITUTE    */\n/*    GOODS  OR  SERVICES; LOSS  OF  USE,  DATA,  OR PROFITS;  OR    */\n/*    BUSINESS INTERRUPTION) HOWEVER CAUSED  AND ON ANY THEORY OF    */\n/*    LIABILITY, WHETHER  IN CONTRACT, STRICT  LIABILITY, OR TORT    */\n/*    (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY WAY OUT    */\n/*    OF  THE  USE OF  THIS  SOFTWARE,  EVEN  IF ADVISED  OF  THE    */\n/*    POSSIBILITY OF SUCH DAMAGE.                                    */\n/*                                                                   */\n/* The views and conclusions contained in the software and           */\n/* documentation are those of the authors and should not be          */\n/* interpreted as representing official policies, either expressed   */\n/* or implied, of The University of Texas at Austin.                 */\n/*********************************************************************/\n\n#ifndef ASSEMBLER\n\n/* Level 2 Blas routines */\n\n#ifdef __CUDACC__\nextern \"C\" {\n#endif\n\nint sbgemv_n(BLASLONG, BLASLONG, float, bfloat16 *, BLASLONG, bfloat16 *, BLASLONG, float, float *, BLASLONG);\nint sbgemv_t(BLASLONG, BLASLONG, float, bfloat16 *, BLASLONG, bfloat16 *, BLASLONG, float, float *, BLASLONG);\nint sbgemv_thread_n(BLASLONG, BLASLONG, float, bfloat16 *, BLASLONG, bfloat16 *, BLASLONG, float, float *, BLASLONG, int);\nint sbgemv_thread_t(BLASLONG, BLASLONG, float, bfloat16 *, BLASLONG, bfloat16 *, BLASLONG, float, float *, BLASLONG, int);\nint sger_k (BLASLONG, BLASLONG, BLASLONG, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\nint dger_k (BLASLONG, BLASLONG, BLASLONG, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\nint qger_k (BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\nint cgeru_k(BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\nint cgerc_k(BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\nint cgerv_k(BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\nint cgerd_k(BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\nint zgeru_k(BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\nint zgerc_k(BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\nint zgerv_k(BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\nint zgerd_k(BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\nint xgeru_k(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\nint xgerc_k(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\nint xgerv_k(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\nint xgerd_k(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\n\nint sger_thread  (BLASLONG, BLASLONG, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint dger_thread  (BLASLONG, BLASLONG, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint qger_thread  (BLASLONG, BLASLONG, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint cger_thread_U(BLASLONG, BLASLONG, float *, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint cger_thread_C(BLASLONG, BLASLONG, float *, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint cger_thread_V(BLASLONG, BLASLONG, float *, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint cger_thread_D(BLASLONG, BLASLONG, float *, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint zger_thread_U(BLASLONG, BLASLONG, double *, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint zger_thread_C(BLASLONG, BLASLONG, double *, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint zger_thread_V(BLASLONG, BLASLONG, double *, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint zger_thread_D(BLASLONG, BLASLONG, double *, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint xger_thread_U(BLASLONG, BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint xger_thread_C(BLASLONG, BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint xger_thread_V(BLASLONG, BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint xger_thread_D(BLASLONG, BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\n\nint sgemv_n(BLASLONG, BLASLONG, BLASLONG, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *buffer);\nint sgemv_t(BLASLONG, BLASLONG, BLASLONG, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *buffer);\nint dgemv_n(BLASLONG, BLASLONG, BLASLONG, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *buffer);\nint dgemv_t(BLASLONG, BLASLONG, BLASLONG, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *buffer);\nint qgemv_n(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *buffer);\nint qgemv_t(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *buffer);\n\nint cgemv_n(BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *buffer);\nint cgemv_t(BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *buffer);\nint cgemv_r(BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *buffer);\nint cgemv_c(BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *buffer);\nint cgemv_o(BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *buffer);\nint cgemv_u(BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *buffer);\nint cgemv_s(BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *buffer);\nint cgemv_d(BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *buffer);\n\nint zgemv_n(BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *buffer);\nint zgemv_t(BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *buffer);\nint zgemv_r(BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *buffer);\nint zgemv_c(BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *buffer);\nint zgemv_o(BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *buffer);\nint zgemv_u(BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *buffer);\nint zgemv_s(BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *buffer);\nint zgemv_d(BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *buffer);\n\nint xgemv_n(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *buffer);\nint xgemv_t(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *buffer);\nint xgemv_r(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *buffer);\nint xgemv_c(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *buffer);\nint xgemv_o(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *buffer);\nint xgemv_u(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *buffer);\nint xgemv_s(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *buffer);\nint xgemv_d(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *buffer);\n\nint sgemv_thread_n(BLASLONG, BLASLONG, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *buffer, int);\nint sgemv_thread_t(BLASLONG, BLASLONG, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *buffer, int);\nint dgemv_thread_n(BLASLONG, BLASLONG, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *buffer, int);\nint dgemv_thread_t(BLASLONG, BLASLONG, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *buffer, int);\nint qgemv_thread_n(BLASLONG, BLASLONG, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *buffer, int);\nint qgemv_thread_t(BLASLONG, BLASLONG, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *buffer, int);\n\nint cgemv_thread_n(BLASLONG, BLASLONG, float *, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *buffer, int);\nint cgemv_thread_t(BLASLONG, BLASLONG, float *, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *buffer, int);\nint cgemv_thread_r(BLASLONG, BLASLONG, float *, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *buffer, int);\nint cgemv_thread_c(BLASLONG, BLASLONG, float *, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *buffer, int);\nint cgemv_thread_o(BLASLONG, BLASLONG, float *, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *buffer, int);\nint cgemv_thread_u(BLASLONG, BLASLONG, float *, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *buffer, int);\nint cgemv_thread_s(BLASLONG, BLASLONG, float *, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *buffer, int);\nint cgemv_thread_d(BLASLONG, BLASLONG, float *, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *buffer, int);\n\nint zgemv_thread_n(BLASLONG, BLASLONG, double *, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *buffer, int);\nint zgemv_thread_t(BLASLONG, BLASLONG, double *, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *buffer, int);\nint zgemv_thread_r(BLASLONG, BLASLONG, double *, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *buffer, int);\nint zgemv_thread_c(BLASLONG, BLASLONG, double *, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *buffer, int);\nint zgemv_thread_o(BLASLONG, BLASLONG, double *, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *buffer, int);\nint zgemv_thread_u(BLASLONG, BLASLONG, double *, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *buffer, int);\nint zgemv_thread_s(BLASLONG, BLASLONG, double *, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *buffer, int);\nint zgemv_thread_d(BLASLONG, BLASLONG, double *, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *buffer, int);\n\nint xgemv_thread_n(BLASLONG, BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *buffer, int);\nint xgemv_thread_t(BLASLONG, BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *buffer, int);\nint xgemv_thread_r(BLASLONG, BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *buffer, int);\nint xgemv_thread_c(BLASLONG, BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *buffer, int);\nint xgemv_thread_o(BLASLONG, BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *buffer, int);\nint xgemv_thread_u(BLASLONG, BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *buffer, int);\nint xgemv_thread_s(BLASLONG, BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *buffer, int);\nint xgemv_thread_d(BLASLONG, BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *buffer, int);\n\nint strsv_NUU(BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint strsv_NUN(BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint strsv_NLU(BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint strsv_NLN(BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint strsv_TUU(BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint strsv_TUN(BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint strsv_TLU(BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint strsv_TLN(BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\n\nint dtrsv_NUU(BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint dtrsv_NUN(BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint dtrsv_NLU(BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint dtrsv_NLN(BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint dtrsv_TUU(BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint dtrsv_TUN(BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint dtrsv_TLU(BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint dtrsv_TLN(BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\n\nint qtrsv_NUU(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint qtrsv_NUN(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint qtrsv_NLU(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint qtrsv_NLN(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint qtrsv_TUU(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint qtrsv_TUN(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint qtrsv_TLU(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint qtrsv_TLN(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\n\nint ctrsv_NUU(BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint ctrsv_NUN(BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint ctrsv_NLU(BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint ctrsv_NLN(BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint ctrsv_TUU(BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint ctrsv_TUN(BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint ctrsv_TLU(BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint ctrsv_TLN(BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint ctrsv_RUU(BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint ctrsv_RUN(BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint ctrsv_RLU(BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint ctrsv_RLN(BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint ctrsv_CUU(BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint ctrsv_CUN(BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint ctrsv_CLU(BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint ctrsv_CLN(BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\n\nint ztrsv_NUU(BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint ztrsv_NUN(BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint ztrsv_NLU(BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint ztrsv_NLN(BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint ztrsv_TUU(BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint ztrsv_TUN(BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint ztrsv_TLU(BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint ztrsv_TLN(BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint ztrsv_RUU(BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint ztrsv_RUN(BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint ztrsv_RLU(BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint ztrsv_RLN(BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint ztrsv_CUU(BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint ztrsv_CUN(BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint ztrsv_CLU(BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint ztrsv_CLN(BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\n\nint xtrsv_NUU(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint xtrsv_NUN(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint xtrsv_NLU(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint xtrsv_NLN(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint xtrsv_TUU(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint xtrsv_TUN(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint xtrsv_TLU(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint xtrsv_TLN(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint xtrsv_RUU(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint xtrsv_RUN(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint xtrsv_RLU(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint xtrsv_RLN(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint xtrsv_CUU(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint xtrsv_CUN(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint xtrsv_CLU(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint xtrsv_CLN(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\n\nint strmv_NUU(BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\nint strmv_NUN(BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\nint strmv_NLU(BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\nint strmv_NLN(BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\nint strmv_TUU(BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\nint strmv_TUN(BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\nint strmv_TLU(BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\nint strmv_TLN(BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\n\nint dtrmv_NUU(BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\nint dtrmv_NUN(BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\nint dtrmv_NLU(BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\nint dtrmv_NLN(BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\nint dtrmv_TUU(BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\nint dtrmv_TUN(BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\nint dtrmv_TLU(BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\nint dtrmv_TLN(BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\n\nint qtrmv_NUU(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\nint qtrmv_NUN(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\nint qtrmv_NLU(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\nint qtrmv_NLN(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\nint qtrmv_TUU(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\nint qtrmv_TUN(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\nint qtrmv_TLU(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\nint qtrmv_TLN(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\n\nint ctrmv_NUU(BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\nint ctrmv_NUN(BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\nint ctrmv_NLU(BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\nint ctrmv_NLN(BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\nint ctrmv_TUU(BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\nint ctrmv_TUN(BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\nint ctrmv_TLU(BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\nint ctrmv_TLN(BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\nint ctrmv_RUU(BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\nint ctrmv_RUN(BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\nint ctrmv_RLU(BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\nint ctrmv_RLN(BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\nint ctrmv_CUU(BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\nint ctrmv_CUN(BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\nint ctrmv_CLU(BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\nint ctrmv_CLN(BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\n\nint ztrmv_NUU(BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\nint ztrmv_NUN(BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\nint ztrmv_NLU(BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\nint ztrmv_NLN(BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\nint ztrmv_TUU(BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\nint ztrmv_TUN(BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\nint ztrmv_TLU(BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\nint ztrmv_TLN(BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\nint ztrmv_RUU(BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\nint ztrmv_RUN(BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\nint ztrmv_RLU(BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\nint ztrmv_RLN(BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\nint ztrmv_CUU(BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\nint ztrmv_CUN(BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\nint ztrmv_CLU(BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\nint ztrmv_CLN(BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\n\nint xtrmv_NUU(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\nint xtrmv_NUN(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\nint xtrmv_NLU(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\nint xtrmv_NLN(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\nint xtrmv_TUU(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\nint xtrmv_TUN(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\nint xtrmv_TLU(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\nint xtrmv_TLN(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\nint xtrmv_RUU(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\nint xtrmv_RUN(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\nint xtrmv_RLU(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\nint xtrmv_RLN(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\nint xtrmv_CUU(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\nint xtrmv_CUN(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\nint xtrmv_CLU(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\nint xtrmv_CLN(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\n\nint strmv_thread_NUU(BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint strmv_thread_NUN(BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint strmv_thread_NLU(BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint strmv_thread_NLN(BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint strmv_thread_TUU(BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint strmv_thread_TUN(BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint strmv_thread_TLU(BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint strmv_thread_TLN(BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\n\nint dtrmv_thread_NUU(BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint dtrmv_thread_NUN(BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint dtrmv_thread_NLU(BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint dtrmv_thread_NLN(BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint dtrmv_thread_TUU(BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint dtrmv_thread_TUN(BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint dtrmv_thread_TLU(BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint dtrmv_thread_TLN(BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\n\nint qtrmv_thread_NUU(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint qtrmv_thread_NUN(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint qtrmv_thread_NLU(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint qtrmv_thread_NLN(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint qtrmv_thread_TUU(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint qtrmv_thread_TUN(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint qtrmv_thread_TLU(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint qtrmv_thread_TLN(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\n\nint ctrmv_thread_NUU(BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint ctrmv_thread_NUN(BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint ctrmv_thread_NLU(BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint ctrmv_thread_NLN(BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint ctrmv_thread_TUU(BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint ctrmv_thread_TUN(BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint ctrmv_thread_TLU(BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint ctrmv_thread_TLN(BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint ctrmv_thread_RUU(BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint ctrmv_thread_RUN(BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint ctrmv_thread_RLU(BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint ctrmv_thread_RLN(BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint ctrmv_thread_CUU(BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint ctrmv_thread_CUN(BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint ctrmv_thread_CLU(BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint ctrmv_thread_CLN(BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\n\nint ztrmv_thread_NUU(BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint ztrmv_thread_NUN(BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint ztrmv_thread_NLU(BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint ztrmv_thread_NLN(BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint ztrmv_thread_TUU(BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint ztrmv_thread_TUN(BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint ztrmv_thread_TLU(BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint ztrmv_thread_TLN(BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint ztrmv_thread_RUU(BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint ztrmv_thread_RUN(BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint ztrmv_thread_RLU(BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint ztrmv_thread_RLN(BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint ztrmv_thread_CUU(BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint ztrmv_thread_CUN(BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint ztrmv_thread_CLU(BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint ztrmv_thread_CLN(BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\n\nint xtrmv_thread_NUU(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint xtrmv_thread_NUN(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint xtrmv_thread_NLU(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint xtrmv_thread_NLN(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint xtrmv_thread_TUU(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint xtrmv_thread_TUN(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint xtrmv_thread_TLU(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint xtrmv_thread_TLN(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint xtrmv_thread_RUU(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint xtrmv_thread_RUN(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint xtrmv_thread_RLU(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint xtrmv_thread_RLN(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint xtrmv_thread_CUU(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint xtrmv_thread_CUN(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint xtrmv_thread_CLU(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint xtrmv_thread_CLN(BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\n\nint stpsv_NUU(BLASLONG, float *, float *, BLASLONG, void *);\nint stpsv_NUN(BLASLONG, float *, float *, BLASLONG, void *);\nint stpsv_NLU(BLASLONG, float *, float *, BLASLONG, void *);\nint stpsv_NLN(BLASLONG, float *, float *, BLASLONG, void *);\nint stpsv_TUU(BLASLONG, float *, float *, BLASLONG, void *);\nint stpsv_TUN(BLASLONG, float *, float *, BLASLONG, void *);\nint stpsv_TLU(BLASLONG, float *, float *, BLASLONG, void *);\nint stpsv_TLN(BLASLONG, float *, float *, BLASLONG, void *);\n\nint dtpsv_NUU(BLASLONG, double *, double *, BLASLONG, void *);\nint dtpsv_NUN(BLASLONG, double *, double *, BLASLONG, void *);\nint dtpsv_NLU(BLASLONG, double *, double *, BLASLONG, void *);\nint dtpsv_NLN(BLASLONG, double *, double *, BLASLONG, void *);\nint dtpsv_TUU(BLASLONG, double *, double *, BLASLONG, void *);\nint dtpsv_TUN(BLASLONG, double *, double *, BLASLONG, void *);\nint dtpsv_TLU(BLASLONG, double *, double *, BLASLONG, void *);\nint dtpsv_TLN(BLASLONG, double *, double *, BLASLONG, void *);\n\nint qtpsv_NUU(BLASLONG, xdouble *, xdouble *, BLASLONG, void *);\nint qtpsv_NUN(BLASLONG, xdouble *, xdouble *, BLASLONG, void *);\nint qtpsv_NLU(BLASLONG, xdouble *, xdouble *, BLASLONG, void *);\nint qtpsv_NLN(BLASLONG, xdouble *, xdouble *, BLASLONG, void *);\nint qtpsv_TUU(BLASLONG, xdouble *, xdouble *, BLASLONG, void *);\nint qtpsv_TUN(BLASLONG, xdouble *, xdouble *, BLASLONG, void *);\nint qtpsv_TLU(BLASLONG, xdouble *, xdouble *, BLASLONG, void *);\nint qtpsv_TLN(BLASLONG, xdouble *, xdouble *, BLASLONG, void *);\n\nint ctpsv_NUU(BLASLONG, float *, float *, BLASLONG, void *);\nint ctpsv_NUN(BLASLONG, float *, float *, BLASLONG, void *);\nint ctpsv_NLU(BLASLONG, float *, float *, BLASLONG, void *);\nint ctpsv_NLN(BLASLONG, float *, float *, BLASLONG, void *);\nint ctpsv_TUU(BLASLONG, float *, float *, BLASLONG, void *);\nint ctpsv_TUN(BLASLONG, float *, float *, BLASLONG, void *);\nint ctpsv_TLU(BLASLONG, float *, float *, BLASLONG, void *);\nint ctpsv_TLN(BLASLONG, float *, float *, BLASLONG, void *);\nint ctpsv_RUU(BLASLONG, float *, float *, BLASLONG, void *);\nint ctpsv_RUN(BLASLONG, float *, float *, BLASLONG, void *);\nint ctpsv_RLU(BLASLONG, float *, float *, BLASLONG, void *);\nint ctpsv_RLN(BLASLONG, float *, float *, BLASLONG, void *);\nint ctpsv_CUU(BLASLONG, float *, float *, BLASLONG, void *);\nint ctpsv_CUN(BLASLONG, float *, float *, BLASLONG, void *);\nint ctpsv_CLU(BLASLONG, float *, float *, BLASLONG, void *);\nint ctpsv_CLN(BLASLONG, float *, float *, BLASLONG, void *);\n\nint ztpsv_NUU(BLASLONG, double *, double *, BLASLONG, void *);\nint ztpsv_NUN(BLASLONG, double *, double *, BLASLONG, void *);\nint ztpsv_NLU(BLASLONG, double *, double *, BLASLONG, void *);\nint ztpsv_NLN(BLASLONG, double *, double *, BLASLONG, void *);\nint ztpsv_TUU(BLASLONG, double *, double *, BLASLONG, void *);\nint ztpsv_TUN(BLASLONG, double *, double *, BLASLONG, void *);\nint ztpsv_TLU(BLASLONG, double *, double *, BLASLONG, void *);\nint ztpsv_TLN(BLASLONG, double *, double *, BLASLONG, void *);\nint ztpsv_RUU(BLASLONG, double *, double *, BLASLONG, void *);\nint ztpsv_RUN(BLASLONG, double *, double *, BLASLONG, void *);\nint ztpsv_RLU(BLASLONG, double *, double *, BLASLONG, void *);\nint ztpsv_RLN(BLASLONG, double *, double *, BLASLONG, void *);\nint ztpsv_CUU(BLASLONG, double *, double *, BLASLONG, void *);\nint ztpsv_CUN(BLASLONG, double *, double *, BLASLONG, void *);\nint ztpsv_CLU(BLASLONG, double *, double *, BLASLONG, void *);\nint ztpsv_CLN(BLASLONG, double *, double *, BLASLONG, void *);\n\nint xtpsv_NUU(BLASLONG, xdouble *, xdouble *, BLASLONG, void *);\nint xtpsv_NUN(BLASLONG, xdouble *, xdouble *, BLASLONG, void *);\nint xtpsv_NLU(BLASLONG, xdouble *, xdouble *, BLASLONG, void *);\nint xtpsv_NLN(BLASLONG, xdouble *, xdouble *, BLASLONG, void *);\nint xtpsv_TUU(BLASLONG, xdouble *, xdouble *, BLASLONG, void *);\nint xtpsv_TUN(BLASLONG, xdouble *, xdouble *, BLASLONG, void *);\nint xtpsv_TLU(BLASLONG, xdouble *, xdouble *, BLASLONG, void *);\nint xtpsv_TLN(BLASLONG, xdouble *, xdouble *, BLASLONG, void *);\nint xtpsv_RUU(BLASLONG, xdouble *, xdouble *, BLASLONG, void *);\nint xtpsv_RUN(BLASLONG, xdouble *, xdouble *, BLASLONG, void *);\nint xtpsv_RLU(BLASLONG, xdouble *, xdouble *, BLASLONG, void *);\nint xtpsv_RLN(BLASLONG, xdouble *, xdouble *, BLASLONG, void *);\nint xtpsv_CUU(BLASLONG, xdouble *, xdouble *, BLASLONG, void *);\nint xtpsv_CUN(BLASLONG, xdouble *, xdouble *, BLASLONG, void *);\nint xtpsv_CLU(BLASLONG, xdouble *, xdouble *, BLASLONG, void *);\nint xtpsv_CLN(BLASLONG, xdouble *, xdouble *, BLASLONG, void *);\n\nint stpmv_NUU(BLASLONG, float *, float *, BLASLONG, void *);\nint stpmv_NUN(BLASLONG, float *, float *, BLASLONG, void *);\nint stpmv_NLU(BLASLONG, float *, float *, BLASLONG, void *);\nint stpmv_NLN(BLASLONG, float *, float *, BLASLONG, void *);\nint stpmv_TUU(BLASLONG, float *, float *, BLASLONG, void *);\nint stpmv_TUN(BLASLONG, float *, float *, BLASLONG, void *);\nint stpmv_TLU(BLASLONG, float *, float *, BLASLONG, void *);\nint stpmv_TLN(BLASLONG, float *, float *, BLASLONG, void *);\n\nint dtpmv_NUU(BLASLONG, double *, double *, BLASLONG, void *);\nint dtpmv_NUN(BLASLONG, double *, double *, BLASLONG, void *);\nint dtpmv_NLU(BLASLONG, double *, double *, BLASLONG, void *);\nint dtpmv_NLN(BLASLONG, double *, double *, BLASLONG, void *);\nint dtpmv_TUU(BLASLONG, double *, double *, BLASLONG, void *);\nint dtpmv_TUN(BLASLONG, double *, double *, BLASLONG, void *);\nint dtpmv_TLU(BLASLONG, double *, double *, BLASLONG, void *);\nint dtpmv_TLN(BLASLONG, double *, double *, BLASLONG, void *);\n\nint qtpmv_NUU(BLASLONG, xdouble *, xdouble *, BLASLONG, void *);\nint qtpmv_NUN(BLASLONG, xdouble *, xdouble *, BLASLONG, void *);\nint qtpmv_NLU(BLASLONG, xdouble *, xdouble *, BLASLONG, void *);\nint qtpmv_NLN(BLASLONG, xdouble *, xdouble *, BLASLONG, void *);\nint qtpmv_TUU(BLASLONG, xdouble *, xdouble *, BLASLONG, void *);\nint qtpmv_TUN(BLASLONG, xdouble *, xdouble *, BLASLONG, void *);\nint qtpmv_TLU(BLASLONG, xdouble *, xdouble *, BLASLONG, void *);\nint qtpmv_TLN(BLASLONG, xdouble *, xdouble *, BLASLONG, void *);\n\nint ctpmv_NUU(BLASLONG, float *, float *, BLASLONG, void *);\nint ctpmv_NUN(BLASLONG, float *, float *, BLASLONG, void *);\nint ctpmv_NLU(BLASLONG, float *, float *, BLASLONG, void *);\nint ctpmv_NLN(BLASLONG, float *, float *, BLASLONG, void *);\nint ctpmv_TUU(BLASLONG, float *, float *, BLASLONG, void *);\nint ctpmv_TUN(BLASLONG, float *, float *, BLASLONG, void *);\nint ctpmv_TLU(BLASLONG, float *, float *, BLASLONG, void *);\nint ctpmv_TLN(BLASLONG, float *, float *, BLASLONG, void *);\nint ctpmv_RUU(BLASLONG, float *, float *, BLASLONG, void *);\nint ctpmv_RUN(BLASLONG, float *, float *, BLASLONG, void *);\nint ctpmv_RLU(BLASLONG, float *, float *, BLASLONG, void *);\nint ctpmv_RLN(BLASLONG, float *, float *, BLASLONG, void *);\nint ctpmv_CUU(BLASLONG, float *, float *, BLASLONG, void *);\nint ctpmv_CUN(BLASLONG, float *, float *, BLASLONG, void *);\nint ctpmv_CLU(BLASLONG, float *, float *, BLASLONG, void *);\nint ctpmv_CLN(BLASLONG, float *, float *, BLASLONG, void *);\n\nint ztpmv_NUU(BLASLONG, double *, double *, BLASLONG, void *);\nint ztpmv_NUN(BLASLONG, double *, double *, BLASLONG, void *);\nint ztpmv_NLU(BLASLONG, double *, double *, BLASLONG, void *);\nint ztpmv_NLN(BLASLONG, double *, double *, BLASLONG, void *);\nint ztpmv_TUU(BLASLONG, double *, double *, BLASLONG, void *);\nint ztpmv_TUN(BLASLONG, double *, double *, BLASLONG, void *);\nint ztpmv_TLU(BLASLONG, double *, double *, BLASLONG, void *);\nint ztpmv_TLN(BLASLONG, double *, double *, BLASLONG, void *);\nint ztpmv_RUU(BLASLONG, double *, double *, BLASLONG, void *);\nint ztpmv_RUN(BLASLONG, double *, double *, BLASLONG, void *);\nint ztpmv_RLU(BLASLONG, double *, double *, BLASLONG, void *);\nint ztpmv_RLN(BLASLONG, double *, double *, BLASLONG, void *);\nint ztpmv_CUU(BLASLONG, double *, double *, BLASLONG, void *);\nint ztpmv_CUN(BLASLONG, double *, double *, BLASLONG, void *);\nint ztpmv_CLU(BLASLONG, double *, double *, BLASLONG, void *);\nint ztpmv_CLN(BLASLONG, double *, double *, BLASLONG, void *);\n\nint xtpmv_NUU(BLASLONG, xdouble *, xdouble *, BLASLONG, void *);\nint xtpmv_NUN(BLASLONG, xdouble *, xdouble *, BLASLONG, void *);\nint xtpmv_NLU(BLASLONG, xdouble *, xdouble *, BLASLONG, void *);\nint xtpmv_NLN(BLASLONG, xdouble *, xdouble *, BLASLONG, void *);\nint xtpmv_TUU(BLASLONG, xdouble *, xdouble *, BLASLONG, void *);\nint xtpmv_TUN(BLASLONG, xdouble *, xdouble *, BLASLONG, void *);\nint xtpmv_TLU(BLASLONG, xdouble *, xdouble *, BLASLONG, void *);\nint xtpmv_TLN(BLASLONG, xdouble *, xdouble *, BLASLONG, void *);\nint xtpmv_RUU(BLASLONG, xdouble *, xdouble *, BLASLONG, void *);\nint xtpmv_RUN(BLASLONG, xdouble *, xdouble *, BLASLONG, void *);\nint xtpmv_RLU(BLASLONG, xdouble *, xdouble *, BLASLONG, void *);\nint xtpmv_RLN(BLASLONG, xdouble *, xdouble *, BLASLONG, void *);\nint xtpmv_CUU(BLASLONG, xdouble *, xdouble *, BLASLONG, void *);\nint xtpmv_CUN(BLASLONG, xdouble *, xdouble *, BLASLONG, void *);\nint xtpmv_CLU(BLASLONG, xdouble *, xdouble *, BLASLONG, void *);\nint xtpmv_CLN(BLASLONG, xdouble *, xdouble *, BLASLONG, void *);\n\nint stpmv_thread_NUU(BLASLONG, float *, float *, BLASLONG, float *, int);\nint stpmv_thread_NUN(BLASLONG, float *, float *, BLASLONG, float *, int);\nint stpmv_thread_NLU(BLASLONG, float *, float *, BLASLONG, float *, int);\nint stpmv_thread_NLN(BLASLONG, float *, float *, BLASLONG, float *, int);\nint stpmv_thread_TUU(BLASLONG, float *, float *, BLASLONG, float *, int);\nint stpmv_thread_TUN(BLASLONG, float *, float *, BLASLONG, float *, int);\nint stpmv_thread_TLU(BLASLONG, float *, float *, BLASLONG, float *, int);\nint stpmv_thread_TLN(BLASLONG, float *, float *, BLASLONG, float *, int);\n\nint dtpmv_thread_NUU(BLASLONG, double *, double *, BLASLONG, double *, int);\nint dtpmv_thread_NUN(BLASLONG, double *, double *, BLASLONG, double *, int);\nint dtpmv_thread_NLU(BLASLONG, double *, double *, BLASLONG, double *, int);\nint dtpmv_thread_NLN(BLASLONG, double *, double *, BLASLONG, double *, int);\nint dtpmv_thread_TUU(BLASLONG, double *, double *, BLASLONG, double *, int);\nint dtpmv_thread_TUN(BLASLONG, double *, double *, BLASLONG, double *, int);\nint dtpmv_thread_TLU(BLASLONG, double *, double *, BLASLONG, double *, int);\nint dtpmv_thread_TLN(BLASLONG, double *, double *, BLASLONG, double *, int);\n\nint qtpmv_thread_NUU(BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, int);\nint qtpmv_thread_NUN(BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, int);\nint qtpmv_thread_NLU(BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, int);\nint qtpmv_thread_NLN(BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, int);\nint qtpmv_thread_TUU(BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, int);\nint qtpmv_thread_TUN(BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, int);\nint qtpmv_thread_TLU(BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, int);\nint qtpmv_thread_TLN(BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, int);\n\nint ctpmv_thread_NUU(BLASLONG, float *, float *, BLASLONG, float *, int);\nint ctpmv_thread_NUN(BLASLONG, float *, float *, BLASLONG, float *, int);\nint ctpmv_thread_NLU(BLASLONG, float *, float *, BLASLONG, float *, int);\nint ctpmv_thread_NLN(BLASLONG, float *, float *, BLASLONG, float *, int);\nint ctpmv_thread_TUU(BLASLONG, float *, float *, BLASLONG, float *, int);\nint ctpmv_thread_TUN(BLASLONG, float *, float *, BLASLONG, float *, int);\nint ctpmv_thread_TLU(BLASLONG, float *, float *, BLASLONG, float *, int);\nint ctpmv_thread_TLN(BLASLONG, float *, float *, BLASLONG, float *, int);\nint ctpmv_thread_RUU(BLASLONG, float *, float *, BLASLONG, float *, int);\nint ctpmv_thread_RUN(BLASLONG, float *, float *, BLASLONG, float *, int);\nint ctpmv_thread_RLU(BLASLONG, float *, float *, BLASLONG, float *, int);\nint ctpmv_thread_RLN(BLASLONG, float *, float *, BLASLONG, float *, int);\nint ctpmv_thread_CUU(BLASLONG, float *, float *, BLASLONG, float *, int);\nint ctpmv_thread_CUN(BLASLONG, float *, float *, BLASLONG, float *, int);\nint ctpmv_thread_CLU(BLASLONG, float *, float *, BLASLONG, float *, int);\nint ctpmv_thread_CLN(BLASLONG, float *, float *, BLASLONG, float *, int);\n\nint ztpmv_thread_NUU(BLASLONG, double *, double *, BLASLONG, double *, int);\nint ztpmv_thread_NUN(BLASLONG, double *, double *, BLASLONG, double *, int);\nint ztpmv_thread_NLU(BLASLONG, double *, double *, BLASLONG, double *, int);\nint ztpmv_thread_NLN(BLASLONG, double *, double *, BLASLONG, double *, int);\nint ztpmv_thread_TUU(BLASLONG, double *, double *, BLASLONG, double *, int);\nint ztpmv_thread_TUN(BLASLONG, double *, double *, BLASLONG, double *, int);\nint ztpmv_thread_TLU(BLASLONG, double *, double *, BLASLONG, double *, int);\nint ztpmv_thread_TLN(BLASLONG, double *, double *, BLASLONG, double *, int);\nint ztpmv_thread_RUU(BLASLONG, double *, double *, BLASLONG, double *, int);\nint ztpmv_thread_RUN(BLASLONG, double *, double *, BLASLONG, double *, int);\nint ztpmv_thread_RLU(BLASLONG, double *, double *, BLASLONG, double *, int);\nint ztpmv_thread_RLN(BLASLONG, double *, double *, BLASLONG, double *, int);\nint ztpmv_thread_CUU(BLASLONG, double *, double *, BLASLONG, double *, int);\nint ztpmv_thread_CUN(BLASLONG, double *, double *, BLASLONG, double *, int);\nint ztpmv_thread_CLU(BLASLONG, double *, double *, BLASLONG, double *, int);\nint ztpmv_thread_CLN(BLASLONG, double *, double *, BLASLONG, double *, int);\n\nint xtpmv_thread_NUU(BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, int);\nint xtpmv_thread_NUN(BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, int);\nint xtpmv_thread_NLU(BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, int);\nint xtpmv_thread_NLN(BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, int);\nint xtpmv_thread_TUU(BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, int);\nint xtpmv_thread_TUN(BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, int);\nint xtpmv_thread_TLU(BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, int);\nint xtpmv_thread_TLN(BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, int);\nint xtpmv_thread_RUU(BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, int);\nint xtpmv_thread_RUN(BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, int);\nint xtpmv_thread_RLU(BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, int);\nint xtpmv_thread_RLN(BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, int);\nint xtpmv_thread_CUU(BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, int);\nint xtpmv_thread_CUN(BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, int);\nint xtpmv_thread_CLU(BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, int);\nint xtpmv_thread_CLN(BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, int);\n\nint ssymv_L(BLASLONG, BLASLONG, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\nint ssymv_U(BLASLONG, BLASLONG, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\nint dsymv_L(BLASLONG, BLASLONG, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\nint dsymv_U(BLASLONG, BLASLONG, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\nint qsymv_L(BLASLONG, BLASLONG, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\nint qsymv_U(BLASLONG, BLASLONG, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\nint csymv_L(BLASLONG, BLASLONG, float, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\nint csymv_U(BLASLONG, BLASLONG, float, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\nint zsymv_L(BLASLONG, BLASLONG, double, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\nint zsymv_U(BLASLONG, BLASLONG, double, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\nint xsymv_L(BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\nint xsymv_U(BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\n\nint ssymv_thread_L(BLASLONG, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint ssymv_thread_U(BLASLONG, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint dsymv_thread_L(BLASLONG, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint dsymv_thread_U(BLASLONG, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint qsymv_thread_L(BLASLONG, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint qsymv_thread_U(BLASLONG, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint csymv_thread_L(BLASLONG, float *, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint csymv_thread_U(BLASLONG, float *, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint zsymv_thread_L(BLASLONG, double *, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint zsymv_thread_U(BLASLONG, double *, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint xsymv_thread_L(BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint xsymv_thread_U(BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\n\nint chemv_thread_L(BLASLONG, float *, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint chemv_thread_U(BLASLONG, float *, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint chemv_thread_M(BLASLONG, float *, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint chemv_thread_V(BLASLONG, float *, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint zhemv_thread_L(BLASLONG, double *, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint zhemv_thread_U(BLASLONG, double *, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint zhemv_thread_M(BLASLONG, double *, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint zhemv_thread_V(BLASLONG, double *, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint xhemv_thread_L(BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint xhemv_thread_U(BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint xhemv_thread_M(BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint xhemv_thread_V(BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\n\nint sspmv_L(BLASLONG, float, float *, float *, BLASLONG, float *, BLASLONG, void *);\nint sspmv_U(BLASLONG, float, float *, float *, BLASLONG, float *, BLASLONG, void *);\nint dspmv_L(BLASLONG, double, double *, double *, BLASLONG, double *, BLASLONG, void *);\nint dspmv_U(BLASLONG, double, double *, double *, BLASLONG, double *, BLASLONG, void *);\nint qspmv_L(BLASLONG, xdouble, xdouble *, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint qspmv_U(BLASLONG, xdouble, xdouble *, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint cspmv_L(BLASLONG, float, float, float *, float *, BLASLONG, float *, BLASLONG, void *);\nint cspmv_U(BLASLONG, float, float, float *, float *, BLASLONG, float *, BLASLONG, void *);\nint zspmv_L(BLASLONG, double, double, double *, double *, BLASLONG, double *, BLASLONG, void *);\nint zspmv_U(BLASLONG, double, double, double *, double *, BLASLONG, double *, BLASLONG, void *);\nint xspmv_L(BLASLONG, xdouble, xdouble, xdouble *, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint xspmv_U(BLASLONG, xdouble, xdouble, xdouble *, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\n\nint sspmv_thread_L(BLASLONG, float, float *, float *, BLASLONG, float *, BLASLONG, float *, int);\nint sspmv_thread_U(BLASLONG, float, float *, float *, BLASLONG, float *, BLASLONG, float *, int);\nint dspmv_thread_L(BLASLONG, double, double *, double *, BLASLONG, double *, BLASLONG, double *, int);\nint dspmv_thread_U(BLASLONG, double, double *, double *, BLASLONG, double *, BLASLONG, double *, int);\nint qspmv_thread_L(BLASLONG, xdouble, xdouble *, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint qspmv_thread_U(BLASLONG, xdouble, xdouble *, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint cspmv_thread_L(BLASLONG, float *, float *, float *, BLASLONG, float *, BLASLONG, float *, int);\nint cspmv_thread_U(BLASLONG, float *, float *, float *, BLASLONG, float *, BLASLONG, float *, int);\nint zspmv_thread_L(BLASLONG, double *, double *, double *, BLASLONG, double *, BLASLONG, double *, int);\nint zspmv_thread_U(BLASLONG, double *, double *, double *, BLASLONG, double *, BLASLONG, double *, int);\nint xspmv_thread_L(BLASLONG, xdouble *, xdouble *, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint xspmv_thread_U(BLASLONG, xdouble *, xdouble *, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\n\nint ssyr_L(BLASLONG, float, float *, BLASLONG, float *, BLASLONG, float *);\nint ssyr_U(BLASLONG, float, float *, BLASLONG, float *, BLASLONG, float *);\nint dsyr_L(BLASLONG, double, double *, BLASLONG, double *, BLASLONG, double *);\nint dsyr_U(BLASLONG, double, double *, BLASLONG, double *, BLASLONG, double *);\nint qsyr_L(BLASLONG, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\nint qsyr_U(BLASLONG, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\nint csyr_L(BLASLONG, float, float, float *, BLASLONG, float *, BLASLONG, float *);\nint csyr_U(BLASLONG, float, float, float *, BLASLONG, float *, BLASLONG, float *);\nint zsyr_L(BLASLONG, double, double, double *, BLASLONG, double *, BLASLONG, double *);\nint zsyr_U(BLASLONG, double, double, double *, BLASLONG, double *, BLASLONG, double *);\nint xsyr_L(BLASLONG, xdouble, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\nint xsyr_U(BLASLONG, xdouble, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\n\nint ssyr_thread_L(BLASLONG, float, float *, BLASLONG, float *, BLASLONG, float *, int);\nint ssyr_thread_U(BLASLONG, float, float *, BLASLONG, float *, BLASLONG, float *, int);\nint dsyr_thread_L(BLASLONG, double, double *, BLASLONG, double *, BLASLONG, double *, int);\nint dsyr_thread_U(BLASLONG, double, double *, BLASLONG, double *, BLASLONG, double *, int);\nint qsyr_thread_L(BLASLONG, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint qsyr_thread_U(BLASLONG, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint csyr_thread_L(BLASLONG, float *, float *, BLASLONG, float *, BLASLONG, float *, int);\nint csyr_thread_U(BLASLONG, float *, float *, BLASLONG, float *, BLASLONG, float *, int);\nint zsyr_thread_L(BLASLONG, double *, double *, BLASLONG, double *, BLASLONG, double *, int);\nint zsyr_thread_U(BLASLONG, double *, double *, BLASLONG, double *, BLASLONG, double *, int);\nint xsyr_thread_L(BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint xsyr_thread_U(BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\n\nint ssyr2_L(BLASLONG, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\nint ssyr2_U(BLASLONG, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\nint dsyr2_L(BLASLONG, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\nint dsyr2_U(BLASLONG, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\nint qsyr2_L(BLASLONG, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\nint qsyr2_U(BLASLONG, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\nint csyr2_L(BLASLONG, float, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\nint csyr2_U(BLASLONG, float, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\nint zsyr2_L(BLASLONG, double, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\nint zsyr2_U(BLASLONG, double, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\nint xsyr2_L(BLASLONG, xdouble, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\nint xsyr2_U(BLASLONG, xdouble, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\n\nint ssyr2_thread_L(BLASLONG, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint ssyr2_thread_U(BLASLONG, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint dsyr2_thread_L(BLASLONG, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint dsyr2_thread_U(BLASLONG, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint qsyr2_thread_L(BLASLONG, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint qsyr2_thread_U(BLASLONG, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint csyr2_thread_L(BLASLONG, float *, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint csyr2_thread_U(BLASLONG, float *, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint zsyr2_thread_L(BLASLONG, double *, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint zsyr2_thread_U(BLASLONG, double *, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint xsyr2_thread_L(BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint xsyr2_thread_U(BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\n\nint sspr_L(BLASLONG, float, float *, BLASLONG, float *, float *);\nint sspr_U(BLASLONG, float, float *, BLASLONG, float *, float *);\nint dspr_L(BLASLONG, double, double *, BLASLONG, double *, double *);\nint dspr_U(BLASLONG, double, double *, BLASLONG, double *, double *);\nint qspr_L(BLASLONG, xdouble, xdouble *, BLASLONG, xdouble *, xdouble *);\nint qspr_U(BLASLONG, xdouble, xdouble *, BLASLONG, xdouble *, xdouble *);\nint cspr_L(BLASLONG, float, float, float *, BLASLONG, float *, float *);\nint cspr_U(BLASLONG, float, float, float *, BLASLONG, float *, float *);\nint zspr_L(BLASLONG, double, double, double *, BLASLONG, double *, double *);\nint zspr_U(BLASLONG, double, double, double *, BLASLONG, double *, double *);\nint xspr_L(BLASLONG, xdouble, xdouble, xdouble *, BLASLONG, xdouble *, xdouble *);\nint xspr_U(BLASLONG, xdouble, xdouble, xdouble *, BLASLONG, xdouble *, xdouble *);\n\nint sspr_thread_L(BLASLONG, float, float *, BLASLONG, float *, float *, int);\nint sspr_thread_U(BLASLONG, float, float *, BLASLONG, float *, float *, int);\nint dspr_thread_L(BLASLONG, double, double *, BLASLONG, double *, double *, int);\nint dspr_thread_U(BLASLONG, double, double *, BLASLONG, double *, double *, int);\nint qspr_thread_L(BLASLONG, xdouble, xdouble *, BLASLONG, xdouble *, xdouble *, int);\nint qspr_thread_U(BLASLONG, xdouble, xdouble *, BLASLONG, xdouble *, xdouble *, int);\nint cspr_thread_L(BLASLONG, float *, float *, BLASLONG, float *, float *, int);\nint cspr_thread_U(BLASLONG, float *, float *, BLASLONG, float *, float *, int);\nint zspr_thread_L(BLASLONG, double *, double *, BLASLONG, double *, double *, int);\nint zspr_thread_U(BLASLONG, double *, double *, BLASLONG, double *, double *, int);\nint xspr_thread_L(BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, xdouble *, int);\nint xspr_thread_U(BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, xdouble *, int);\n\nint sspr2_L(BLASLONG, float, float *, BLASLONG, float *, BLASLONG, float *, float *);\nint sspr2_U(BLASLONG, float, float *, BLASLONG, float *, BLASLONG, float *, float *);\nint dspr2_L(BLASLONG, double, double *, BLASLONG, double *, BLASLONG, double *, double *);\nint dspr2_U(BLASLONG, double, double *, BLASLONG, double *, BLASLONG, double *, double *);\nint qspr2_L(BLASLONG, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, xdouble *);\nint qspr2_U(BLASLONG, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, xdouble *);\nint cspr2_L(BLASLONG, float, float, float *, BLASLONG, float *, BLASLONG, float *, float *);\nint cspr2_U(BLASLONG, float, float, float *, BLASLONG, float *, BLASLONG, float *, float *);\nint zspr2_L(BLASLONG, double, double, double *, BLASLONG, double *, BLASLONG, double *, double *);\nint zspr2_U(BLASLONG, double, double, double *, BLASLONG, double *, BLASLONG, double *, double *);\nint xspr2_L(BLASLONG, xdouble, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, xdouble *);\nint xspr2_U(BLASLONG, xdouble, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, xdouble *);\n\nint sspr2_thread_L(BLASLONG, float, float *, BLASLONG, float *, BLASLONG, float *, float *, int);\nint sspr2_thread_U(BLASLONG, float, float *, BLASLONG, float *, BLASLONG, float *, float *, int);\nint dspr2_thread_L(BLASLONG, double, double *, BLASLONG, double *, BLASLONG, double *, double *, int);\nint dspr2_thread_U(BLASLONG, double, double *, BLASLONG, double *, BLASLONG, double *, double *, int);\nint qspr2_thread_L(BLASLONG, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, xdouble *, int);\nint qspr2_thread_U(BLASLONG, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, xdouble *, int);\nint cspr2_thread_L(BLASLONG, float *, float *, BLASLONG, float *, BLASLONG, float *, float *, int);\nint cspr2_thread_U(BLASLONG, float *, float *, BLASLONG, float *, BLASLONG, float *, float *, int);\nint zspr2_thread_L(BLASLONG, double *, double *, BLASLONG, double *, BLASLONG, double *, double *, int);\nint zspr2_thread_U(BLASLONG, double *, double *, BLASLONG, double *, BLASLONG, double *, double *, int);\nint xspr2_thread_L(BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, xdouble *, int);\nint xspr2_thread_U(BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, xdouble *, int);\n\nint cher_L(BLASLONG, float, float *, BLASLONG, float *, BLASLONG, float *);\nint cher_U(BLASLONG, float, float *, BLASLONG, float *, BLASLONG, float *);\nint cher_V(BLASLONG, float, float *, BLASLONG, float *, BLASLONG, float *);\nint cher_M(BLASLONG, float, float *, BLASLONG, float *, BLASLONG, float *);\nint zher_L(BLASLONG, double, double *, BLASLONG, double *, BLASLONG, double *);\nint zher_U(BLASLONG, double, double *, BLASLONG, double *, BLASLONG, double *);\nint zher_V(BLASLONG, double, double *, BLASLONG, double *, BLASLONG, double *);\nint zher_M(BLASLONG, double, double *, BLASLONG, double *, BLASLONG, double *);\nint xher_L(BLASLONG, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\nint xher_U(BLASLONG, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\nint xher_V(BLASLONG, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\nint xher_M(BLASLONG, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\n\nint cher_thread_L(BLASLONG, float, float *, BLASLONG, float *, BLASLONG, float *, int);\nint cher_thread_U(BLASLONG, float, float *, BLASLONG, float *, BLASLONG, float *, int);\nint cher_thread_V(BLASLONG, float, float *, BLASLONG, float *, BLASLONG, float *, int);\nint cher_thread_M(BLASLONG, float, float *, BLASLONG, float *, BLASLONG, float *, int);\nint zher_thread_L(BLASLONG, double, double *, BLASLONG, double *, BLASLONG, double *, int);\nint zher_thread_U(BLASLONG, double, double *, BLASLONG, double *, BLASLONG, double *, int);\nint zher_thread_V(BLASLONG, double, double *, BLASLONG, double *, BLASLONG, double *, int);\nint zher_thread_M(BLASLONG, double, double *, BLASLONG, double *, BLASLONG, double *, int);\nint xher_thread_L(BLASLONG, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint xher_thread_U(BLASLONG, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint xher_thread_V(BLASLONG, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint xher_thread_M(BLASLONG, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\n\nint cher2_L(BLASLONG, float, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\nint cher2_U(BLASLONG, float, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\nint cher2_M(BLASLONG, float, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\nint cher2_V(BLASLONG, float, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\nint zher2_L(BLASLONG, double, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\nint zher2_U(BLASLONG, double, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\nint zher2_M(BLASLONG, double, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\nint zher2_V(BLASLONG, double, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\nint xher2_L(BLASLONG, xdouble, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\nint xher2_U(BLASLONG, xdouble, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\nint xher2_M(BLASLONG, xdouble, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\nint xher2_V(BLASLONG, xdouble, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\n\nint cher2_thread_L(BLASLONG, float *, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint cher2_thread_U(BLASLONG, float *, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint cher2_thread_M(BLASLONG, float *, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint cher2_thread_V(BLASLONG, float *, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint zher2_thread_L(BLASLONG, double *, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint zher2_thread_U(BLASLONG, double *, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint zher2_thread_M(BLASLONG, double *, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint zher2_thread_V(BLASLONG, double *, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint xher2_thread_L(BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint xher2_thread_U(BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint xher2_thread_M(BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint xher2_thread_V(BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\n\nint chpr_L(BLASLONG, float, float *, BLASLONG, float *, float *);\nint chpr_U(BLASLONG, float, float *, BLASLONG, float *, float *);\nint chpr_M(BLASLONG, float, float *, BLASLONG, float *, float *);\nint chpr_V(BLASLONG, float, float *, BLASLONG, float *, float *);\nint zhpr_L(BLASLONG, double, double *, BLASLONG, double *, double *);\nint zhpr_U(BLASLONG, double, double *, BLASLONG, double *, double *);\nint zhpr_M(BLASLONG, double, double *, BLASLONG, double *, double *);\nint zhpr_V(BLASLONG, double, double *, BLASLONG, double *, double *);\nint xhpr_L(BLASLONG, xdouble, xdouble *, BLASLONG, xdouble *, xdouble *);\nint xhpr_U(BLASLONG, xdouble, xdouble *, BLASLONG, xdouble *, xdouble *);\nint xhpr_M(BLASLONG, xdouble, xdouble *, BLASLONG, xdouble *, xdouble *);\nint xhpr_V(BLASLONG, xdouble, xdouble *, BLASLONG, xdouble *, xdouble *);\n\nint chpr_thread_L(BLASLONG, float, float *, BLASLONG, float *, float *, int);\nint chpr_thread_U(BLASLONG, float, float *, BLASLONG, float *, float *, int);\nint chpr_thread_M(BLASLONG, float, float *, BLASLONG, float *, float *, int);\nint chpr_thread_V(BLASLONG, float, float *, BLASLONG, float *, float *, int);\nint zhpr_thread_L(BLASLONG, double, double *, BLASLONG, double *, double *, int);\nint zhpr_thread_U(BLASLONG, double, double *, BLASLONG, double *, double *, int);\nint zhpr_thread_M(BLASLONG, double, double *, BLASLONG, double *, double *, int);\nint zhpr_thread_V(BLASLONG, double, double *, BLASLONG, double *, double *, int);\nint xhpr_thread_L(BLASLONG, xdouble, xdouble *, BLASLONG, xdouble *, xdouble *, int);\nint xhpr_thread_U(BLASLONG, xdouble, xdouble *, BLASLONG, xdouble *, xdouble *, int);\nint xhpr_thread_M(BLASLONG, xdouble, xdouble *, BLASLONG, xdouble *, xdouble *, int);\nint xhpr_thread_V(BLASLONG, xdouble, xdouble *, BLASLONG, xdouble *, xdouble *, int);\n\nint chpr2_L(BLASLONG, float, float, float *, BLASLONG, float *, BLASLONG, float *, float *);\nint chpr2_U(BLASLONG, float, float, float *, BLASLONG, float *, BLASLONG, float *, float *);\nint chpr2_M(BLASLONG, float, float, float *, BLASLONG, float *, BLASLONG, float *, float *);\nint chpr2_V(BLASLONG, float, float, float *, BLASLONG, float *, BLASLONG, float *, float *);\nint zhpr2_L(BLASLONG, double, double, double *, BLASLONG, double *, BLASLONG, double *, double *);\nint zhpr2_U(BLASLONG, double, double, double *, BLASLONG, double *, BLASLONG, double *, double *);\nint zhpr2_M(BLASLONG, double, double, double *, BLASLONG, double *, BLASLONG, double *, double *);\nint zhpr2_V(BLASLONG, double, double, double *, BLASLONG, double *, BLASLONG, double *, double *);\nint xhpr2_L(BLASLONG, xdouble, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, xdouble *);\nint xhpr2_U(BLASLONG, xdouble, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, xdouble *);\nint xhpr2_M(BLASLONG, xdouble, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, xdouble *);\nint xhpr2_V(BLASLONG, xdouble, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, xdouble *);\n\nint chpr2_thread_L(BLASLONG, float *, float *, BLASLONG, float *, BLASLONG, float *, float *, int);\nint chpr2_thread_U(BLASLONG, float *, float *, BLASLONG, float *, BLASLONG, float *, float *, int);\nint chpr2_thread_M(BLASLONG, float *, float *, BLASLONG, float *, BLASLONG, float *, float *, int);\nint chpr2_thread_V(BLASLONG, float *, float *, BLASLONG, float *, BLASLONG, float *, float *, int);\nint zhpr2_thread_L(BLASLONG, double *, double *, BLASLONG, double *, BLASLONG, double *, double *, int);\nint zhpr2_thread_U(BLASLONG, double *, double *, BLASLONG, double *, BLASLONG, double *, double *, int);\nint zhpr2_thread_M(BLASLONG, double *, double *, BLASLONG, double *, BLASLONG, double *, double *, int);\nint zhpr2_thread_V(BLASLONG, double *, double *, BLASLONG, double *, BLASLONG, double *, double *, int);\nint xhpr2_thread_L(BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, xdouble *, int);\nint xhpr2_thread_U(BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, xdouble *, int);\nint xhpr2_thread_M(BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, xdouble *, int);\nint xhpr2_thread_V(BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, xdouble *, int);\n\nint chemv_L(BLASLONG, BLASLONG, float, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\nint chemv_U(BLASLONG, BLASLONG, float, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\nint chemv_M(BLASLONG, BLASLONG, float, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\nint chemv_V(BLASLONG, BLASLONG, float, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\nint zhemv_L(BLASLONG, BLASLONG, double, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\nint zhemv_U(BLASLONG, BLASLONG, double, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\nint zhemv_M(BLASLONG, BLASLONG, double, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\nint zhemv_V(BLASLONG, BLASLONG, double, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\nint xhemv_L(BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\nint xhemv_U(BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\nint xhemv_M(BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\nint xhemv_V(BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\n\nint chpmv_L(BLASLONG, float, float, float *, float *, BLASLONG, float *, BLASLONG, void *);\nint chpmv_U(BLASLONG, float, float, float *, float *, BLASLONG, float *, BLASLONG, void *);\nint chpmv_M(BLASLONG, float, float, float *, float *, BLASLONG, float *, BLASLONG, void *);\nint chpmv_V(BLASLONG, float, float, float *, float *, BLASLONG, float *, BLASLONG, void *);\nint zhpmv_L(BLASLONG, double, double, double *, double *, BLASLONG, double *, BLASLONG, void *);\nint zhpmv_U(BLASLONG, double, double, double *, double *, BLASLONG, double *, BLASLONG, void *);\nint zhpmv_M(BLASLONG, double, double, double *, double *, BLASLONG, double *, BLASLONG, void *);\nint zhpmv_V(BLASLONG, double, double, double *, double *, BLASLONG, double *, BLASLONG, void *);\nint xhpmv_L(BLASLONG, xdouble, xdouble, xdouble *, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint xhpmv_U(BLASLONG, xdouble, xdouble, xdouble *, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint xhpmv_M(BLASLONG, xdouble, xdouble, xdouble *, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint xhpmv_V(BLASLONG, xdouble, xdouble, xdouble *, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\n\nint chpmv_thread_L(BLASLONG, float *, float *, float *, BLASLONG, float *, BLASLONG, float *, int);\nint chpmv_thread_U(BLASLONG, float *, float *, float *, BLASLONG, float *, BLASLONG, float *, int);\nint chpmv_thread_M(BLASLONG, float *, float *, float *, BLASLONG, float *, BLASLONG, float *, int);\nint chpmv_thread_V(BLASLONG, float *, float *, float *, BLASLONG, float *, BLASLONG, float *, int);\nint zhpmv_thread_L(BLASLONG, double *, double *, double *, BLASLONG, double *, BLASLONG, double *, int);\nint zhpmv_thread_U(BLASLONG, double *, double *, double *, BLASLONG, double *, BLASLONG, double *, int);\nint zhpmv_thread_M(BLASLONG, double *, double *, double *, BLASLONG, double *, BLASLONG, double *, int);\nint zhpmv_thread_V(BLASLONG, double *, double *, double *, BLASLONG, double *, BLASLONG, double *, int);\nint xhpmv_thread_L(BLASLONG, xdouble *, xdouble *, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint xhpmv_thread_U(BLASLONG, xdouble *, xdouble *, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint xhpmv_thread_M(BLASLONG, xdouble *, xdouble *, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint xhpmv_thread_V(BLASLONG, xdouble *, xdouble *, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\n\nint ssbmv_L(BLASLONG, BLASLONG, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint ssbmv_U(BLASLONG, BLASLONG, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint dsbmv_L(BLASLONG, BLASLONG, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint dsbmv_U(BLASLONG, BLASLONG, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint qsbmv_L(BLASLONG, BLASLONG, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint qsbmv_U(BLASLONG, BLASLONG, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint csbmv_L(BLASLONG, BLASLONG, float, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint csbmv_U(BLASLONG, BLASLONG, float, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint zsbmv_L(BLASLONG, BLASLONG, double, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint zsbmv_U(BLASLONG, BLASLONG, double, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint xsbmv_L(BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint xsbmv_U(BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\n\nint chbmv_L(BLASLONG, BLASLONG, float, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint chbmv_U(BLASLONG, BLASLONG, float, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint chbmv_M(BLASLONG, BLASLONG, float, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint chbmv_V(BLASLONG, BLASLONG, float, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint zhbmv_L(BLASLONG, BLASLONG, double, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint zhbmv_U(BLASLONG, BLASLONG, double, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint zhbmv_M(BLASLONG, BLASLONG, double, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint zhbmv_V(BLASLONG, BLASLONG, double, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint xhbmv_L(BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint xhbmv_U(BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint xhbmv_M(BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint xhbmv_V(BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\n\n\nint ssbmv_thread_L(BLASLONG, BLASLONG, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint ssbmv_thread_U(BLASLONG, BLASLONG, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint dsbmv_thread_L(BLASLONG, BLASLONG, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint dsbmv_thread_U(BLASLONG, BLASLONG, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint qsbmv_thread_L(BLASLONG, BLASLONG, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint qsbmv_thread_U(BLASLONG, BLASLONG, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint csbmv_thread_L(BLASLONG, BLASLONG, float *, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint csbmv_thread_U(BLASLONG, BLASLONG, float *, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint zsbmv_thread_L(BLASLONG, BLASLONG, double *, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint zsbmv_thread_U(BLASLONG, BLASLONG, double *, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint xsbmv_thread_L(BLASLONG, BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint xsbmv_thread_U(BLASLONG, BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\n\nint chbmv_thread_L(BLASLONG, BLASLONG, float *, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint chbmv_thread_U(BLASLONG, BLASLONG, float *, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint chbmv_thread_M(BLASLONG, BLASLONG, float *, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint chbmv_thread_V(BLASLONG, BLASLONG, float *, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint zhbmv_thread_L(BLASLONG, BLASLONG, double *, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint zhbmv_thread_U(BLASLONG, BLASLONG, double *, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint zhbmv_thread_M(BLASLONG, BLASLONG, double *, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint zhbmv_thread_V(BLASLONG, BLASLONG, double *, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint xhbmv_thread_L(BLASLONG, BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint xhbmv_thread_U(BLASLONG, BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint xhbmv_thread_M(BLASLONG, BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint xhbmv_thread_V(BLASLONG, BLASLONG, xdouble *, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\n\nint snorm_n(BLASLONG, BLASLONG, float *a, BLASLONG);\nint snorm_t(BLASLONG, BLASLONG, float *a, BLASLONG);\nint dnorm_n(BLASLONG, BLASLONG, double *a, BLASLONG);\nint dnorm_t(BLASLONG, BLASLONG, double *a, BLASLONG);\nint cnorm_n(BLASLONG, BLASLONG, float *a, BLASLONG);\nint cnorm_t(BLASLONG, BLASLONG, float *a, BLASLONG);\nint znorm_n(BLASLONG, BLASLONG, double *a, BLASLONG);\nint znorm_t(BLASLONG, BLASLONG, double *a, BLASLONG);\n\nvoid sgbmv_n(BLASLONG, BLASLONG, BLASLONG, BLASLONG, float,\n\t\t float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *buffer);\nvoid sgbmv_t(BLASLONG, BLASLONG, BLASLONG, BLASLONG, float,\n\t\t float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *buffer);\n\nvoid dgbmv_n(BLASLONG, BLASLONG, BLASLONG, BLASLONG, double,\n\t\t double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *buffer);\nvoid dgbmv_t(BLASLONG, BLASLONG, BLASLONG, BLASLONG, double,\n\t\t double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *buffer);\n\nvoid qgbmv_n(BLASLONG, BLASLONG, BLASLONG, BLASLONG, xdouble,\n\t\t xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *buffer);\nvoid qgbmv_t(BLASLONG, BLASLONG, BLASLONG, BLASLONG, xdouble,\n\t\t xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *buffer);\n\nvoid cgbmv_n(BLASLONG, BLASLONG, BLASLONG, BLASLONG, float, float,\n\t\t float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *buffer);\nvoid cgbmv_t(BLASLONG, BLASLONG, BLASLONG, BLASLONG, float, float,\n\t\t float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *buffer);\nvoid cgbmv_r(BLASLONG, BLASLONG, BLASLONG, BLASLONG, float, float,\n\t\t float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *buffer);\nvoid cgbmv_c(BLASLONG, BLASLONG, BLASLONG, BLASLONG, float, float,\n\t\t float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *buffer);\nvoid cgbmv_o(BLASLONG, BLASLONG, BLASLONG, BLASLONG, float, float,\n\t\t float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *buffer);\nvoid cgbmv_u(BLASLONG, BLASLONG, BLASLONG, BLASLONG, float, float,\n\t\t float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *buffer);\nvoid cgbmv_s(BLASLONG, BLASLONG, BLASLONG, BLASLONG, float, float,\n\t\t float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *buffer);\nvoid cgbmv_d(BLASLONG, BLASLONG, BLASLONG, BLASLONG, float, float,\n\t\t float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *buffer);\n\nvoid zgbmv_n(BLASLONG, BLASLONG, BLASLONG, BLASLONG, double, double,\n\t\t double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *buffer);\nvoid zgbmv_t(BLASLONG, BLASLONG, BLASLONG, BLASLONG, double, double,\n\t\t double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *buffer);\nvoid zgbmv_r(BLASLONG, BLASLONG, BLASLONG, BLASLONG, double, double,\n\t\t double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *buffer);\nvoid zgbmv_c(BLASLONG, BLASLONG, BLASLONG, BLASLONG, double, double,\n\t\t double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *buffer);\nvoid zgbmv_o(BLASLONG, BLASLONG, BLASLONG, BLASLONG, double, double,\n\t\t double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *buffer);\nvoid zgbmv_u(BLASLONG, BLASLONG, BLASLONG, BLASLONG, double, double,\n\t\t double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *buffer);\nvoid zgbmv_s(BLASLONG, BLASLONG, BLASLONG, BLASLONG, double, double,\n\t\t double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *buffer);\nvoid zgbmv_d(BLASLONG, BLASLONG, BLASLONG, BLASLONG, double, double,\n\t\t double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *buffer);\n\nvoid xgbmv_n(BLASLONG, BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble,\n\t\t xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *buffer);\nvoid xgbmv_t(BLASLONG, BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble,\n\t\t xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *buffer);\nvoid xgbmv_r(BLASLONG, BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble,\n\t\t xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *buffer);\nvoid xgbmv_c(BLASLONG, BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble,\n\t\t xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *buffer);\nvoid xgbmv_o(BLASLONG, BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble,\n\t\t xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *buffer);\nvoid xgbmv_u(BLASLONG, BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble,\n\t\t xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *buffer);\nvoid xgbmv_s(BLASLONG, BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble,\n\t\t xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *buffer);\nvoid xgbmv_d(BLASLONG, BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble,\n\t\t xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *buffer);\n\nint sgbmv_thread_n(BLASLONG, BLASLONG, BLASLONG, BLASLONG, float,\n\t\t float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *buffer, int);\nint sgbmv_thread_t(BLASLONG, BLASLONG, BLASLONG, BLASLONG, float,\n\t\t float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *buffer, int);\n\nint dgbmv_thread_n(BLASLONG, BLASLONG, BLASLONG, BLASLONG, double,\n\t\t double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *buffer, int);\nint dgbmv_thread_t(BLASLONG, BLASLONG, BLASLONG, BLASLONG, double,\n\t\t double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *buffer, int);\n\nint qgbmv_thread_n(BLASLONG, BLASLONG, BLASLONG, BLASLONG, xdouble,\n\t\t xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *buffer, int);\nint qgbmv_thread_t(BLASLONG, BLASLONG, BLASLONG, BLASLONG, xdouble,\n\t\t xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *buffer, int);\n\nint cgbmv_thread_n(BLASLONG, BLASLONG, BLASLONG, BLASLONG, float *,\n\t\t float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *buffer, int);\nint cgbmv_thread_t(BLASLONG, BLASLONG, BLASLONG, BLASLONG, float *,\n\t\t float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *buffer, int);\nint cgbmv_thread_r(BLASLONG, BLASLONG, BLASLONG, BLASLONG, float *,\n\t\t float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *buffer, int);\nint cgbmv_thread_c(BLASLONG, BLASLONG, BLASLONG, BLASLONG, float *,\n\t\t float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *buffer, int);\nint cgbmv_thread_o(BLASLONG, BLASLONG, BLASLONG, BLASLONG, float *,\n\t\t float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *buffer, int);\nint cgbmv_thread_u(BLASLONG, BLASLONG, BLASLONG, BLASLONG, float *,\n\t\t float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *buffer, int);\nint cgbmv_thread_s(BLASLONG, BLASLONG, BLASLONG, BLASLONG, float *,\n\t\t float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *buffer, int);\nint cgbmv_thread_d(BLASLONG, BLASLONG, BLASLONG, BLASLONG, float *,\n\t\t float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *buffer, int);\n\nint zgbmv_thread_n(BLASLONG, BLASLONG, BLASLONG, BLASLONG, double *,\n\t\t double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *buffer, int);\nint zgbmv_thread_t(BLASLONG, BLASLONG, BLASLONG, BLASLONG, double *,\n\t\t double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *buffer, int);\nint zgbmv_thread_r(BLASLONG, BLASLONG, BLASLONG, BLASLONG, double *,\n\t\t double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *buffer, int);\nint zgbmv_thread_c(BLASLONG, BLASLONG, BLASLONG, BLASLONG, double *,\n\t\t double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *buffer, int);\nint zgbmv_thread_o(BLASLONG, BLASLONG, BLASLONG, BLASLONG, double *,\n\t\t double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *buffer, int);\nint zgbmv_thread_u(BLASLONG, BLASLONG, BLASLONG, BLASLONG, double *,\n\t\t double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *buffer, int);\nint zgbmv_thread_s(BLASLONG, BLASLONG, BLASLONG, BLASLONG, double *,\n\t\t double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *buffer, int);\nint zgbmv_thread_d(BLASLONG, BLASLONG, BLASLONG, BLASLONG, double *,\n\t\t double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *buffer, int);\n\nint xgbmv_thread_n(BLASLONG, BLASLONG, BLASLONG, BLASLONG, xdouble *,\n\t\t xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *buffer, int);\nint xgbmv_thread_t(BLASLONG, BLASLONG, BLASLONG, BLASLONG, xdouble *,\n\t\t xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *buffer, int);\nint xgbmv_thread_r(BLASLONG, BLASLONG, BLASLONG, BLASLONG, xdouble *,\n\t\t xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *buffer, int);\nint xgbmv_thread_c(BLASLONG, BLASLONG, BLASLONG, BLASLONG, xdouble *,\n\t\t xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *buffer, int);\nint xgbmv_thread_o(BLASLONG, BLASLONG, BLASLONG, BLASLONG, xdouble *,\n\t\t xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *buffer, int);\nint xgbmv_thread_u(BLASLONG, BLASLONG, BLASLONG, BLASLONG, xdouble *,\n\t\t xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *buffer, int);\nint xgbmv_thread_s(BLASLONG, BLASLONG, BLASLONG, BLASLONG, xdouble *,\n\t\t xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *buffer, int);\nint xgbmv_thread_d(BLASLONG, BLASLONG, BLASLONG, BLASLONG, xdouble *,\n\t\t xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *buffer, int);\n\nint stbmv_NUU(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint stbmv_NUN(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint stbmv_NLU(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint stbmv_NLN(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint stbmv_TUU(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint stbmv_TUN(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint stbmv_TLU(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint stbmv_TLN(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\n\nint dtbmv_NUU(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint dtbmv_NUN(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint dtbmv_NLU(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint dtbmv_NLN(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint dtbmv_TUU(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint dtbmv_TUN(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint dtbmv_TLU(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint dtbmv_TLN(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\n\nint qtbmv_NUU(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint qtbmv_NUN(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint qtbmv_NLU(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint qtbmv_NLN(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint qtbmv_TUU(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint qtbmv_TUN(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint qtbmv_TLU(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint qtbmv_TLN(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\n\nint ctbmv_NUU(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint ctbmv_NUN(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint ctbmv_NLU(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint ctbmv_NLN(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint ctbmv_TUU(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint ctbmv_TUN(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint ctbmv_TLU(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint ctbmv_TLN(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint ctbmv_RUU(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint ctbmv_RUN(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint ctbmv_RLU(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint ctbmv_RLN(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint ctbmv_CUU(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint ctbmv_CUN(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint ctbmv_CLU(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint ctbmv_CLN(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\n\nint ztbmv_NUU(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint ztbmv_NUN(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint ztbmv_NLU(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint ztbmv_NLN(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint ztbmv_TUU(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint ztbmv_TUN(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint ztbmv_TLU(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint ztbmv_TLN(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint ztbmv_RUU(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint ztbmv_RUN(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint ztbmv_RLU(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint ztbmv_RLN(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint ztbmv_CUU(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint ztbmv_CUN(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint ztbmv_CLU(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint ztbmv_CLN(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\n\nint xtbmv_NUU(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint xtbmv_NUN(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint xtbmv_NLU(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint xtbmv_NLN(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint xtbmv_TUU(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint xtbmv_TUN(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint xtbmv_TLU(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint xtbmv_TLN(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint xtbmv_RUU(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint xtbmv_RUN(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint xtbmv_RLU(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint xtbmv_RLN(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint xtbmv_CUU(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint xtbmv_CUN(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint xtbmv_CLU(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint xtbmv_CLN(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\n\nint stbmv_thread_NUU(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint stbmv_thread_NUN(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint stbmv_thread_NLU(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint stbmv_thread_NLN(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint stbmv_thread_TUU(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint stbmv_thread_TUN(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint stbmv_thread_TLU(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint stbmv_thread_TLN(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\n\nint dtbmv_thread_NUU(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint dtbmv_thread_NUN(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint dtbmv_thread_NLU(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint dtbmv_thread_NLN(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint dtbmv_thread_TUU(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint dtbmv_thread_TUN(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint dtbmv_thread_TLU(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint dtbmv_thread_TLN(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\n\nint qtbmv_thread_NUU(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint qtbmv_thread_NUN(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint qtbmv_thread_NLU(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint qtbmv_thread_NLN(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint qtbmv_thread_TUU(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint qtbmv_thread_TUN(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint qtbmv_thread_TLU(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint qtbmv_thread_TLN(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\n\nint ctbmv_thread_NUU(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint ctbmv_thread_NUN(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint ctbmv_thread_NLU(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint ctbmv_thread_NLN(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint ctbmv_thread_TUU(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint ctbmv_thread_TUN(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint ctbmv_thread_TLU(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint ctbmv_thread_TLN(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint ctbmv_thread_RUU(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint ctbmv_thread_RUN(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint ctbmv_thread_RLU(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint ctbmv_thread_RLN(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint ctbmv_thread_CUU(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint ctbmv_thread_CUN(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint ctbmv_thread_CLU(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\nint ctbmv_thread_CLN(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *, int);\n\nint ztbmv_thread_NUU(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint ztbmv_thread_NUN(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint ztbmv_thread_NLU(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint ztbmv_thread_NLN(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint ztbmv_thread_TUU(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint ztbmv_thread_TUN(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint ztbmv_thread_TLU(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint ztbmv_thread_TLN(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint ztbmv_thread_RUU(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint ztbmv_thread_RUN(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint ztbmv_thread_RLU(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint ztbmv_thread_RLN(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint ztbmv_thread_CUU(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint ztbmv_thread_CUN(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint ztbmv_thread_CLU(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\nint ztbmv_thread_CLN(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *, int);\n\nint xtbmv_thread_NUU(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint xtbmv_thread_NUN(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint xtbmv_thread_NLU(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint xtbmv_thread_NLN(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint xtbmv_thread_TUU(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint xtbmv_thread_TUN(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint xtbmv_thread_TLU(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint xtbmv_thread_TLN(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint xtbmv_thread_RUU(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint xtbmv_thread_RUN(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint xtbmv_thread_RLU(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint xtbmv_thread_RLN(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint xtbmv_thread_CUU(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint xtbmv_thread_CUN(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint xtbmv_thread_CLU(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\nint xtbmv_thread_CLN(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, int);\n\nint stbsv_NUU(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint stbsv_NUN(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint stbsv_NLU(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint stbsv_NLN(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint stbsv_TUU(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint stbsv_TUN(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint stbsv_TLU(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint stbsv_TLN(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\n\nint dtbsv_NUU(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint dtbsv_NUN(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint dtbsv_NLU(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint dtbsv_NLN(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint dtbsv_TUU(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint dtbsv_TUN(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint dtbsv_TLU(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint dtbsv_TLN(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\n\nint qtbsv_NUU(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint qtbsv_NUN(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint qtbsv_NLU(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint qtbsv_NLN(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint qtbsv_TUU(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint qtbsv_TUN(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint qtbsv_TLU(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint qtbsv_TLN(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\n\nint ctbsv_NUU(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint ctbsv_NUN(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint ctbsv_NLU(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint ctbsv_NLN(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint ctbsv_TUU(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint ctbsv_TUN(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint ctbsv_TLU(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint ctbsv_TLN(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint ctbsv_RUU(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint ctbsv_RUN(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint ctbsv_RLU(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint ctbsv_RLN(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint ctbsv_CUU(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint ctbsv_CUN(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint ctbsv_CLU(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\nint ctbsv_CLN(BLASLONG, BLASLONG, float *, BLASLONG, float *, BLASLONG, void *);\n\nint ztbsv_NUU(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint ztbsv_NUN(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint ztbsv_NLU(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint ztbsv_NLN(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint ztbsv_TUU(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint ztbsv_TUN(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint ztbsv_TLU(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint ztbsv_TLN(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint ztbsv_RUU(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint ztbsv_RUN(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint ztbsv_RLU(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint ztbsv_RLN(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint ztbsv_CUU(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint ztbsv_CUN(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint ztbsv_CLU(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\nint ztbsv_CLN(BLASLONG, BLASLONG, double *, BLASLONG, double *, BLASLONG, void *);\n\nint xtbsv_NUU(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint xtbsv_NUN(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint xtbsv_NLU(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint xtbsv_NLN(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint xtbsv_TUU(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint xtbsv_TUN(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint xtbsv_TLU(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint xtbsv_TLN(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint xtbsv_RUU(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint xtbsv_RUN(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint xtbsv_RLU(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint xtbsv_RLN(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint xtbsv_CUU(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint xtbsv_CUN(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint xtbsv_CLU(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\nint xtbsv_CLN(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, void *);\n\n#ifdef __CUDACC__\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "common_level3.h",
          "type": "blob",
          "size": 161.7041015625,
          "content": "/*********************************************************************/\n/* Copyright 2009, 2010 The University of Texas at Austin.           */\n/* All rights reserved.                                              */\n/*                                                                   */\n/* Redistribution and use in source and binary forms, with or        */\n/* without modification, are permitted provided that the following   */\n/* conditions are met:                                               */\n/*                                                                   */\n/*   1. Redistributions of source code must retain the above         */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer.                                                  */\n/*                                                                   */\n/*   2. Redistributions in binary form must reproduce the above      */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer in the documentation and/or other materials       */\n/*      provided with the distribution.                              */\n/*                                                                   */\n/*    THIS  SOFTWARE IS PROVIDED  BY THE  UNIVERSITY OF  TEXAS AT    */\n/*    AUSTIN  ``AS IS''  AND ANY  EXPRESS OR  IMPLIED WARRANTIES,    */\n/*    INCLUDING, BUT  NOT LIMITED  TO, THE IMPLIED  WARRANTIES OF    */\n/*    MERCHANTABILITY  AND FITNESS FOR  A PARTICULAR  PURPOSE ARE    */\n/*    DISCLAIMED.  IN  NO EVENT SHALL THE UNIVERSITY  OF TEXAS AT    */\n/*    AUSTIN OR CONTRIBUTORS BE  LIABLE FOR ANY DIRECT, INDIRECT,    */\n/*    INCIDENTAL,  SPECIAL, EXEMPLARY,  OR  CONSEQUENTIAL DAMAGES    */\n/*    (INCLUDING, BUT  NOT LIMITED TO,  PROCUREMENT OF SUBSTITUTE    */\n/*    GOODS  OR  SERVICES; LOSS  OF  USE,  DATA,  OR PROFITS;  OR    */\n/*    BUSINESS INTERRUPTION) HOWEVER CAUSED  AND ON ANY THEORY OF    */\n/*    LIABILITY, WHETHER  IN CONTRACT, STRICT  LIABILITY, OR TORT    */\n/*    (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY WAY OUT    */\n/*    OF  THE  USE OF  THIS  SOFTWARE,  EVEN  IF ADVISED  OF  THE    */\n/*    POSSIBILITY OF SUCH DAMAGE.                                    */\n/*                                                                   */\n/* The views and conclusions contained in the software and           */\n/* documentation are those of the authors and should not be          */\n/* interpreted as representing official policies, either expressed   */\n/* or implied, of The University of Texas at Austin.                 */\n/*********************************************************************/\n\n#ifndef ASSEMBLER\n\n#ifdef __CUDACC__\n__global__ void cuda_sgemm_kernel(int, int, int, float *, float *, float *);\n__global__ void cuda_dgemm_kernel(int, int, int, double *, double *, double *);\n#endif\n\n#ifdef __CUDACC__\nextern \"C\" {\n#endif\n\nvoid sgemm_direct(BLASLONG M, BLASLONG N, BLASLONG K,\n\tfloat * A, BLASLONG strideA,\n\tfloat * B, BLASLONG strideB,\n\tfloat * R, BLASLONG strideR);\n\nint sgemm_direct_performant(BLASLONG M, BLASLONG N, BLASLONG K);\n\n\nint sbgemm_beta(BLASLONG, BLASLONG, BLASLONG, float,\n\t       bfloat16 *, BLASLONG, bfloat16 *, BLASLONG, float *, BLASLONG);\nint sgemm_beta(BLASLONG, BLASLONG, BLASLONG, float,\n\t       float  *, BLASLONG, float   *, BLASLONG, float  *, BLASLONG);\nint dgemm_beta(BLASLONG, BLASLONG, BLASLONG, double,\n\t       double *, BLASLONG, double  *, BLASLONG, double *, BLASLONG);\nint cgemm_beta(BLASLONG, BLASLONG, BLASLONG, float,  float,\n\t       float  *, BLASLONG, float   *, BLASLONG, float  *, BLASLONG);\nint zgemm_beta(BLASLONG, BLASLONG, BLASLONG, double, double,\n\t       double *, BLASLONG, double  *, BLASLONG, double *, BLASLONG);\n\n#ifdef EXPRECISION\nint qgemm_beta(BLASLONG, BLASLONG, BLASLONG, xdouble,\n\t       xdouble *, BLASLONG, xdouble  *, BLASLONG, xdouble *, BLASLONG);\nint xgemm_beta(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble,\n\t       xdouble *, BLASLONG, xdouble  *, BLASLONG, xdouble *, BLASLONG);\n#else\nint qgemm_beta(BLASLONG, BLASLONG, BLASLONG, xdouble *,\n\t       xdouble *, BLASLONG, xdouble  *, BLASLONG, xdouble *, BLASLONG);\nint xgemm_beta(BLASLONG, BLASLONG, BLASLONG, xdouble *,\n\t       xdouble *, BLASLONG, xdouble  *, BLASLONG, xdouble *, BLASLONG);\n#endif\n\nint sbgemm_incopy(BLASLONG m, BLASLONG n, bfloat16 *a, BLASLONG lda, bfloat16 *b);\nint sbgemm_itcopy(BLASLONG m, BLASLONG n, bfloat16 *a, BLASLONG lda, bfloat16 *b);\nint sbgemm_oncopy(BLASLONG m, BLASLONG n, bfloat16 *a, BLASLONG lda, bfloat16 *b);\nint sbgemm_otcopy(BLASLONG m, BLASLONG n, bfloat16 *a, BLASLONG lda, bfloat16 *b);\nint sgemm_incopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, float *b);\nint sgemm_itcopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, float *b);\nint sgemm_oncopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, float *b);\nint sgemm_otcopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, float *b);\nint dgemm_incopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, double *b);\nint dgemm_itcopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, double *b);\nint dgemm_oncopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, double *b);\nint dgemm_otcopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, double *b);\nint cgemm_incopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, float *b);\nint cgemm_itcopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, float *b);\nint cgemm_oncopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, float *b);\nint cgemm_otcopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, float *b);\nint zgemm_incopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, double *b);\nint zgemm_itcopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, double *b);\nint zgemm_oncopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, double *b);\nint zgemm_otcopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, double *b);\n\n#ifdef QUAD_PRECISION\nint qgemm_incopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, xidouble *b);\nint qgemm_itcopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, xidouble *b);\nint qgemm_oncopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, xidouble *b);\nint qgemm_otcopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, xidouble *b);\nint xgemm_incopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, xidouble *b);\nint xgemm_itcopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, xidouble *b);\nint xgemm_oncopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, xidouble *b);\nint xgemm_otcopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, xidouble *b);\n#else\nint qgemm_incopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, xdouble *b);\nint qgemm_itcopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, xdouble *b);\nint qgemm_oncopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, xdouble *b);\nint qgemm_otcopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, xdouble *b);\nint xgemm_incopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, xdouble *b);\nint xgemm_itcopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, xdouble *b);\nint xgemm_oncopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, xdouble *b);\nint xgemm_otcopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, xdouble *b);\n#endif\n\n\nint strsm_kernel_LN(BLASLONG, BLASLONG, BLASLONG, float, float *, float *, float *, BLASLONG, BLASLONG);\nint strsm_kernel_LT(BLASLONG, BLASLONG, BLASLONG, float, float *, float *, float *, BLASLONG, BLASLONG);\nint strsm_kernel_RN(BLASLONG, BLASLONG, BLASLONG, float, float *, float *, float *, BLASLONG, BLASLONG);\nint strsm_kernel_RT(BLASLONG, BLASLONG, BLASLONG, float, float *, float *, float *, BLASLONG, BLASLONG);\nint dtrsm_kernel_LN(BLASLONG, BLASLONG, BLASLONG, double, double *, double *, double *, BLASLONG, BLASLONG);\nint dtrsm_kernel_LT(BLASLONG, BLASLONG, BLASLONG, double, double *, double *, double *, BLASLONG, BLASLONG);\nint dtrsm_kernel_RN(BLASLONG, BLASLONG, BLASLONG, double, double *, double *, double *, BLASLONG, BLASLONG);\nint dtrsm_kernel_RT(BLASLONG, BLASLONG, BLASLONG, double, double *, double *, double *, BLASLONG, BLASLONG);\n\nint qtrsm_kernel_LN(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG, BLASLONG);\nint qtrsm_kernel_LT(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG, BLASLONG);\nint qtrsm_kernel_RN(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG, BLASLONG);\nint qtrsm_kernel_RT(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG, BLASLONG);\n\nint ctrsm_kernel_LN(BLASLONG, BLASLONG, BLASLONG, float, float, float *, float *, float *, BLASLONG, BLASLONG);\nint ctrsm_kernel_LT(BLASLONG, BLASLONG, BLASLONG, float, float, float *, float *, float *, BLASLONG, BLASLONG);\nint ctrsm_kernel_LR(BLASLONG, BLASLONG, BLASLONG, float, float, float *, float *, float *, BLASLONG, BLASLONG);\nint ctrsm_kernel_LC(BLASLONG, BLASLONG, BLASLONG, float, float, float *, float *, float *, BLASLONG, BLASLONG);\nint ctrsm_kernel_RN(BLASLONG, BLASLONG, BLASLONG, float, float, float *, float *, float *, BLASLONG, BLASLONG);\nint ctrsm_kernel_RT(BLASLONG, BLASLONG, BLASLONG, float, float, float *, float *, float *, BLASLONG, BLASLONG);\nint ctrsm_kernel_RR(BLASLONG, BLASLONG, BLASLONG, float, float, float *, float *, float *, BLASLONG, BLASLONG);\nint ctrsm_kernel_RC(BLASLONG, BLASLONG, BLASLONG, float, float, float *, float *, float *, BLASLONG, BLASLONG);\n\nint ztrsm_kernel_LN(BLASLONG, BLASLONG, BLASLONG, double, double, double *, double *, double *, BLASLONG, BLASLONG);\nint ztrsm_kernel_LT(BLASLONG, BLASLONG, BLASLONG, double, double, double *, double *, double *, BLASLONG, BLASLONG);\nint ztrsm_kernel_LR(BLASLONG, BLASLONG, BLASLONG, double, double, double *, double *, double *, BLASLONG, BLASLONG);\nint ztrsm_kernel_LC(BLASLONG, BLASLONG, BLASLONG, double, double, double *, double *, double *, BLASLONG, BLASLONG);\nint ztrsm_kernel_RN(BLASLONG, BLASLONG, BLASLONG, double, double, double *, double *, double *, BLASLONG, BLASLONG);\nint ztrsm_kernel_RT(BLASLONG, BLASLONG, BLASLONG, double, double, double *, double *, double *, BLASLONG, BLASLONG);\nint ztrsm_kernel_RR(BLASLONG, BLASLONG, BLASLONG, double, double, double *, double *, double *, BLASLONG, BLASLONG);\nint ztrsm_kernel_RC(BLASLONG, BLASLONG, BLASLONG, double, double, double *, double *, double *, BLASLONG, BLASLONG);\n\nint xtrsm_kernel_LN(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG, BLASLONG);\nint xtrsm_kernel_LT(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG, BLASLONG);\nint xtrsm_kernel_LR(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG, BLASLONG);\nint xtrsm_kernel_LC(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG, BLASLONG);\nint xtrsm_kernel_RN(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG, BLASLONG);\nint xtrsm_kernel_RT(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG, BLASLONG);\nint xtrsm_kernel_RR(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG, BLASLONG);\nint xtrsm_kernel_RC(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG, BLASLONG);\n\nint strmm_kernel_RN(BLASLONG, BLASLONG, BLASLONG, float, float *, float *, float *, BLASLONG, BLASLONG);\nint strmm_kernel_RT(BLASLONG, BLASLONG, BLASLONG, float, float *, float *, float *, BLASLONG, BLASLONG);\nint strmm_kernel_LN(BLASLONG, BLASLONG, BLASLONG, float, float *, float *, float *, BLASLONG, BLASLONG);\nint strmm_kernel_LT(BLASLONG, BLASLONG, BLASLONG, float, float *, float *, float *, BLASLONG, BLASLONG);\n\nint dtrmm_kernel_RN(BLASLONG, BLASLONG, BLASLONG, double, double *, double *, double *, BLASLONG, BLASLONG);\nint dtrmm_kernel_RT(BLASLONG, BLASLONG, BLASLONG, double, double *, double *, double *, BLASLONG, BLASLONG);\nint dtrmm_kernel_LN(BLASLONG, BLASLONG, BLASLONG, double, double *, double *, double *, BLASLONG, BLASLONG);\nint dtrmm_kernel_LT(BLASLONG, BLASLONG, BLASLONG, double, double *, double *, double *, BLASLONG, BLASLONG);\n\nint qtrmm_kernel_RN(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG, BLASLONG);\nint qtrmm_kernel_RT(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG, BLASLONG);\nint qtrmm_kernel_LN(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG, BLASLONG);\nint qtrmm_kernel_LT(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG, BLASLONG);\n\nint ctrmm_kernel_RN(BLASLONG, BLASLONG, BLASLONG, float, float, float *, float *, float *, BLASLONG, BLASLONG);\nint ctrmm_kernel_RT(BLASLONG, BLASLONG, BLASLONG, float, float, float *, float *, float *, BLASLONG, BLASLONG);\nint ctrmm_kernel_RR(BLASLONG, BLASLONG, BLASLONG, float, float, float *, float *, float *, BLASLONG, BLASLONG);\nint ctrmm_kernel_RC(BLASLONG, BLASLONG, BLASLONG, float, float, float *, float *, float *, BLASLONG, BLASLONG);\nint ctrmm_kernel_LN(BLASLONG, BLASLONG, BLASLONG, float, float, float *, float *, float *, BLASLONG, BLASLONG);\nint ctrmm_kernel_LT(BLASLONG, BLASLONG, BLASLONG, float, float, float *, float *, float *, BLASLONG, BLASLONG);\nint ctrmm_kernel_LR(BLASLONG, BLASLONG, BLASLONG, float, float, float *, float *, float *, BLASLONG, BLASLONG);\nint ctrmm_kernel_LC(BLASLONG, BLASLONG, BLASLONG, float, float, float *, float *, float *, BLASLONG, BLASLONG);\n\nint ztrmm_kernel_RN(BLASLONG, BLASLONG, BLASLONG, double, double, double *, double *, double *, BLASLONG, BLASLONG);\nint ztrmm_kernel_RT(BLASLONG, BLASLONG, BLASLONG, double, double, double *, double *, double *, BLASLONG, BLASLONG);\nint ztrmm_kernel_RR(BLASLONG, BLASLONG, BLASLONG, double, double, double *, double *, double *, BLASLONG, BLASLONG);\nint ztrmm_kernel_RC(BLASLONG, BLASLONG, BLASLONG, double, double, double *, double *, double *, BLASLONG, BLASLONG);\nint ztrmm_kernel_LN(BLASLONG, BLASLONG, BLASLONG, double, double, double *, double *, double *, BLASLONG, BLASLONG);\nint ztrmm_kernel_LT(BLASLONG, BLASLONG, BLASLONG, double, double, double *, double *, double *, BLASLONG, BLASLONG);\nint ztrmm_kernel_LR(BLASLONG, BLASLONG, BLASLONG, double, double, double *, double *, double *, BLASLONG, BLASLONG);\nint ztrmm_kernel_LC(BLASLONG, BLASLONG, BLASLONG, double, double, double *, double *, double *, BLASLONG, BLASLONG);\n\nint xtrmm_kernel_RN(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG, BLASLONG);\nint xtrmm_kernel_RT(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG, BLASLONG);\nint xtrmm_kernel_RR(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG, BLASLONG);\nint xtrmm_kernel_RC(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG, BLASLONG);\nint xtrmm_kernel_LN(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG, BLASLONG);\nint xtrmm_kernel_LT(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG, BLASLONG);\nint xtrmm_kernel_LR(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG, BLASLONG);\nint xtrmm_kernel_LC(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG, BLASLONG);\n\nint strmm_iunucopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, float *b);\nint strmm_iunncopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, float *b);\nint strmm_iutucopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, float *b);\nint strmm_iutncopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, float *b);\nint strmm_ounucopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, float *b);\nint strmm_ounncopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, float *b);\nint strmm_outucopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, float *b);\nint strmm_outncopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, float *b);\nint strmm_ilnucopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, float *b);\nint strmm_ilnncopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, float *b);\nint strmm_iltucopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, float *b);\nint strmm_iltncopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, float *b);\nint strmm_olnucopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, float *b);\nint strmm_olnncopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, float *b);\nint strmm_oltucopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, float *b);\nint strmm_oltncopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, float *b);\n\nint dtrmm_iunucopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, double *b);\nint dtrmm_iunncopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, double *b);\nint dtrmm_iutucopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, double *b);\nint dtrmm_iutncopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, double *b);\nint dtrmm_ounucopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, double *b);\nint dtrmm_ounncopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, double *b);\nint dtrmm_outucopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, double *b);\nint dtrmm_outncopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, double *b);\nint dtrmm_ilnucopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, double *b);\nint dtrmm_ilnncopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, double *b);\nint dtrmm_iltucopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, double *b);\nint dtrmm_iltncopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, double *b);\nint dtrmm_olnucopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, double *b);\nint dtrmm_olnncopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, double *b);\nint dtrmm_oltucopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, double *b);\nint dtrmm_oltncopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, double *b);\n\nint qtrmm_iunucopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, xdouble *b);\nint qtrmm_iunncopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, xdouble *b);\nint qtrmm_iutucopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, xdouble *b);\nint qtrmm_iutncopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, xdouble *b);\nint qtrmm_ounucopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, xdouble *b);\nint qtrmm_ounncopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, xdouble *b);\nint qtrmm_outucopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, xdouble *b);\nint qtrmm_outncopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, xdouble *b);\nint qtrmm_ilnucopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, xdouble *b);\nint qtrmm_ilnncopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, xdouble *b);\nint qtrmm_iltucopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, xdouble *b);\nint qtrmm_iltncopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, xdouble *b);\nint qtrmm_olnucopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, xdouble *b);\nint qtrmm_olnncopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, xdouble *b);\nint qtrmm_oltucopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, xdouble *b);\nint qtrmm_oltncopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, xdouble *b);\n\nint ctrmm_iunucopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, float *b);\nint ctrmm_iunncopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, float *b);\nint ctrmm_iutucopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, float *b);\nint ctrmm_iutncopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, float *b);\nint ctrmm_ounucopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, float *b);\nint ctrmm_ounncopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, float *b);\nint ctrmm_outucopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, float *b);\nint ctrmm_outncopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, float *b);\nint ctrmm_ilnucopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, float *b);\nint ctrmm_ilnncopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, float *b);\nint ctrmm_iltucopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, float *b);\nint ctrmm_iltncopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, float *b);\nint ctrmm_olnucopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, float *b);\nint ctrmm_olnncopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, float *b);\nint ctrmm_oltucopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, float *b);\nint ctrmm_oltncopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, float *b);\n\nint ztrmm_iunucopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, double *b);\nint ztrmm_iunncopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, double *b);\nint ztrmm_iutucopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, double *b);\nint ztrmm_iutncopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, double *b);\nint ztrmm_ounucopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, double *b);\nint ztrmm_ounncopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, double *b);\nint ztrmm_outucopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, double *b);\nint ztrmm_outncopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, double *b);\nint ztrmm_ilnucopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, double *b);\nint ztrmm_ilnncopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, double *b);\nint ztrmm_iltucopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, double *b);\nint ztrmm_iltncopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, double *b);\nint ztrmm_olnucopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, double *b);\nint ztrmm_olnncopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, double *b);\nint ztrmm_oltucopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, double *b);\nint ztrmm_oltncopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, double *b);\n\nint xtrmm_iunucopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, xdouble *b);\nint xtrmm_iunncopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, xdouble *b);\nint xtrmm_iutucopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, xdouble *b);\nint xtrmm_iutncopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, xdouble *b);\nint xtrmm_ounucopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, xdouble *b);\nint xtrmm_ounncopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, xdouble *b);\nint xtrmm_outucopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, xdouble *b);\nint xtrmm_outncopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, xdouble *b);\nint xtrmm_ilnucopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, xdouble *b);\nint xtrmm_ilnncopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, xdouble *b);\nint xtrmm_iltucopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, xdouble *b);\nint xtrmm_iltncopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, xdouble *b);\nint xtrmm_olnucopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, xdouble *b);\nint xtrmm_olnncopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, xdouble *b);\nint xtrmm_oltucopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, xdouble *b);\nint xtrmm_oltncopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, xdouble *b);\n\nint strsm_iunucopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG offset, float *b);\nint strsm_iunncopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG offset, float *b);\nint strsm_iutucopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG offset, float *b);\nint strsm_iutncopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG offset, float *b);\nint strsm_ounucopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG offset, float *b);\nint strsm_ounncopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG offset, float *b);\nint strsm_outucopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG offset, float *b);\nint strsm_outncopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG offset, float *b);\nint strsm_ilnucopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG offset, float *b);\nint strsm_ilnncopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG offset, float *b);\nint strsm_iltucopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG offset, float *b);\nint strsm_iltncopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG offset, float *b);\nint strsm_olnucopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG offset, float *b);\nint strsm_olnncopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG offset, float *b);\nint strsm_oltucopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG offset, float *b);\nint strsm_oltncopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG offset, float *b);\n\nint dtrsm_iunucopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG offset, double *b);\nint dtrsm_iunncopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG offset, double *b);\nint dtrsm_iutucopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG offset, double *b);\nint dtrsm_iutncopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG offset, double *b);\nint dtrsm_ounucopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG offset, double *b);\nint dtrsm_ounncopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG offset, double *b);\nint dtrsm_outucopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG offset, double *b);\nint dtrsm_outncopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG offset, double *b);\nint dtrsm_ilnucopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG offset, double *b);\nint dtrsm_ilnncopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG offset, double *b);\nint dtrsm_iltucopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG offset, double *b);\nint dtrsm_iltncopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG offset, double *b);\nint dtrsm_olnucopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG offset, double *b);\nint dtrsm_olnncopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG offset, double *b);\nint dtrsm_oltucopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG offset, double *b);\nint dtrsm_oltncopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG offset, double *b);\n\nint qtrsm_iunucopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG offset, xdouble *b);\nint qtrsm_iunncopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG offset, xdouble *b);\nint qtrsm_iutucopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG offset, xdouble *b);\nint qtrsm_iutncopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG offset, xdouble *b);\nint qtrsm_ounucopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG offset, xdouble *b);\nint qtrsm_ounncopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG offset, xdouble *b);\nint qtrsm_outucopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG offset, xdouble *b);\nint qtrsm_outncopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG offset, xdouble *b);\nint qtrsm_ilnucopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG offset, xdouble *b);\nint qtrsm_ilnncopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG offset, xdouble *b);\nint qtrsm_iltucopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG offset, xdouble *b);\nint qtrsm_iltncopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG offset, xdouble *b);\nint qtrsm_olnucopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG offset, xdouble *b);\nint qtrsm_olnncopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG offset, xdouble *b);\nint qtrsm_oltucopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG offset, xdouble *b);\nint qtrsm_oltncopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG offset, xdouble *b);\n\nint ctrsm_iunucopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG offset, float *b);\nint ctrsm_iunncopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG offset, float *b);\nint ctrsm_iutucopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG offset, float *b);\nint ctrsm_iutncopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG offset, float *b);\nint ctrsm_ounucopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG offset, float *b);\nint ctrsm_ounncopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG offset, float *b);\nint ctrsm_outucopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG offset, float *b);\nint ctrsm_outncopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG offset, float *b);\nint ctrsm_ilnucopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG offset, float *b);\nint ctrsm_ilnncopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG offset, float *b);\nint ctrsm_iltucopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG offset, float *b);\nint ctrsm_iltncopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG offset, float *b);\nint ctrsm_olnucopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG offset, float *b);\nint ctrsm_olnncopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG offset, float *b);\nint ctrsm_oltucopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG offset, float *b);\nint ctrsm_oltncopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG offset, float *b);\n\nint ztrsm_iunucopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG offset, double *b);\nint ztrsm_iunncopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG offset, double *b);\nint ztrsm_iutucopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG offset, double *b);\nint ztrsm_iutncopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG offset, double *b);\nint ztrsm_ounucopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG offset, double *b);\nint ztrsm_ounncopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG offset, double *b);\nint ztrsm_outucopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG offset, double *b);\nint ztrsm_outncopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG offset, double *b);\nint ztrsm_ilnucopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG offset, double *b);\nint ztrsm_ilnncopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG offset, double *b);\nint ztrsm_iltucopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG offset, double *b);\nint ztrsm_iltncopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG offset, double *b);\nint ztrsm_olnucopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG offset, double *b);\nint ztrsm_olnncopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG offset, double *b);\nint ztrsm_oltucopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG offset, double *b);\nint ztrsm_oltncopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG offset, double *b);\n\nint xtrsm_iunucopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG offset, xdouble *b);\nint xtrsm_iunncopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG offset, xdouble *b);\nint xtrsm_iutucopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG offset, xdouble *b);\nint xtrsm_iutncopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG offset, xdouble *b);\nint xtrsm_ounucopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG offset, xdouble *b);\nint xtrsm_ounncopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG offset, xdouble *b);\nint xtrsm_outucopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG offset, xdouble *b);\nint xtrsm_outncopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG offset, xdouble *b);\nint xtrsm_ilnucopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG offset, xdouble *b);\nint xtrsm_ilnncopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG offset, xdouble *b);\nint xtrsm_iltucopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG offset, xdouble *b);\nint xtrsm_iltncopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG offset, xdouble *b);\nint xtrsm_olnucopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG offset, xdouble *b);\nint xtrsm_olnncopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG offset, xdouble *b);\nint xtrsm_oltucopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG offset, xdouble *b);\nint xtrsm_oltncopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG offset, xdouble *b);\n\nint ssymm_iutcopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, float *b);\nint ssymm_outcopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, float *b);\nint ssymm_iltcopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, float *b);\nint ssymm_oltcopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, float *b);\nint dsymm_iutcopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, double *b);\nint dsymm_outcopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, double *b);\nint dsymm_iltcopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, double *b);\nint dsymm_oltcopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, double *b);\nint qsymm_iutcopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, xdouble *b);\nint qsymm_outcopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, xdouble *b);\nint qsymm_iltcopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, xdouble *b);\nint qsymm_oltcopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, xdouble *b);\nint csymm_iutcopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, float *b);\nint csymm_outcopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, float *b);\nint csymm_iltcopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, float *b);\nint csymm_oltcopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, float *b);\nint zsymm_iutcopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, double *b);\nint zsymm_outcopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, double *b);\nint zsymm_iltcopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, double *b);\nint zsymm_oltcopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, double *b);\nint xsymm_iutcopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, xdouble *b);\nint xsymm_outcopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, xdouble *b);\nint xsymm_iltcopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, xdouble *b);\nint xsymm_oltcopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, xdouble *b);\n\nint chemm_iutcopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, float *b);\nint chemm_outcopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, float *b);\nint chemm_iltcopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, float *b);\nint chemm_oltcopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, float *b);\nint zhemm_iutcopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, double *b);\nint zhemm_outcopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, double *b);\nint zhemm_iltcopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, double *b);\nint zhemm_oltcopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, double *b);\nint xhemm_iutcopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, xdouble *b);\nint xhemm_outcopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, xdouble *b);\nint xhemm_iltcopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, xdouble *b);\nint xhemm_oltcopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG posX, BLASLONG posY, xdouble *b);\n\nint ssyrk_kernel_U(BLASLONG m, BLASLONG n, BLASLONG k, float alpha, float *a, float *b, float *c, BLASLONG ldc, BLASLONG offset);\nint ssyrk_kernel_L(BLASLONG m, BLASLONG n, BLASLONG k, float alpha, float *a, float *b, float *c, BLASLONG ldc, BLASLONG offset);\n\nint dsyrk_kernel_U(BLASLONG m, BLASLONG n, BLASLONG k, double alpha, double *a, double *b, double *c, BLASLONG ldc, BLASLONG offset);\nint dsyrk_kernel_L(BLASLONG m, BLASLONG n, BLASLONG k, double alpha, double *a, double *b, double *c, BLASLONG ldc, BLASLONG offset);\n\nint qsyrk_kernel_U(BLASLONG m, BLASLONG n, BLASLONG k, xdouble alpha, xdouble *a, xdouble *b, xdouble *c, BLASLONG ldc, BLASLONG offset);\nint qsyrk_kernel_L(BLASLONG m, BLASLONG n, BLASLONG k, xdouble alpha, xdouble *a, xdouble *b, xdouble *c, BLASLONG ldc, BLASLONG offset);\n\nint csyrk_kernel_U(BLASLONG m, BLASLONG n, BLASLONG k, float alpha_r, float alpha_i, float *a, float *b, float *c, BLASLONG ldc, BLASLONG offset);\nint csyrk_kernel_L(BLASLONG m, BLASLONG n, BLASLONG k, float alpha_r, float alpha_i, float *a, float *b, float *c, BLASLONG ldc, BLASLONG offset);\nint zsyrk_kernel_U(BLASLONG m, BLASLONG n, BLASLONG k, double alpha_r, double alpha_i, double *a, double *b, double *c, BLASLONG ldc, BLASLONG offset);\nint zsyrk_kernel_L(BLASLONG m, BLASLONG n, BLASLONG k, double alpha_r, double alpha_i, double *a, double *b, double *c, BLASLONG ldc, BLASLONG offset);\nint xsyrk_kernel_U(BLASLONG m, BLASLONG n, BLASLONG k, xdouble alpha_r, xdouble alpha_i, xdouble *a, xdouble *b, xdouble *c, BLASLONG ldc, BLASLONG offset);\nint xsyrk_kernel_L(BLASLONG m, BLASLONG n, BLASLONG k, xdouble alpha_r, xdouble alpha_i, xdouble *a, xdouble *b, xdouble *c, BLASLONG ldc, BLASLONG offset);\n\nint ssyr2k_kernel_U(BLASLONG m, BLASLONG n, BLASLONG k, float alpha, float *a, float *b, float *c, BLASLONG ldc, BLASLONG offset, int flag);\nint ssyr2k_kernel_L(BLASLONG m, BLASLONG n, BLASLONG k, float alpha, float *a, float *b, float *c, BLASLONG ldc, BLASLONG offset, int flag);\nint dsyr2k_kernel_U(BLASLONG m, BLASLONG n, BLASLONG k, double alpha, double *a, double *b, double *c, BLASLONG ldc, BLASLONG offset, int flag);\nint dsyr2k_kernel_L(BLASLONG m, BLASLONG n, BLASLONG k, double alpha, double *a, double *b, double *c, BLASLONG ldc, BLASLONG offset, int flag);\nint qsyr2k_kernel_U(BLASLONG m, BLASLONG n, BLASLONG k, xdouble alpha, xdouble *a, xdouble *b, xdouble *c, BLASLONG ldc, BLASLONG offset, int flag);\nint qsyr2k_kernel_L(BLASLONG m, BLASLONG n, BLASLONG k, xdouble alpha, xdouble *a, xdouble *b, xdouble *c, BLASLONG ldc, BLASLONG offset, int flag);\n\nint csyr2k_kernel_U(BLASLONG m, BLASLONG n, BLASLONG k, float alpha_r, float alpha_i, float *a, float *b, float *c, BLASLONG ldc, BLASLONG offset, int flag);\nint csyr2k_kernel_L(BLASLONG m, BLASLONG n, BLASLONG k, float alpha_r, float alpha_i, float *a, float *b, float *c, BLASLONG ldc, BLASLONG offset, int flag);\nint zsyr2k_kernel_U(BLASLONG m, BLASLONG n, BLASLONG k, double alpha_r, double alpha_i, double *a, double *b, double *c, BLASLONG ldc, BLASLONG offset, int flag);\nint zsyr2k_kernel_L(BLASLONG m, BLASLONG n, BLASLONG k, double alpha_r, double alpha_i, double *a, double *b, double *c, BLASLONG ldc, BLASLONG offset, int flag);\nint xsyr2k_kernel_U(BLASLONG m, BLASLONG n, BLASLONG k, xdouble alpha_r, xdouble alpha_i, xdouble *a, xdouble *b, xdouble *c, BLASLONG ldc, BLASLONG offset, int flag);\nint xsyr2k_kernel_L(BLASLONG m, BLASLONG n, BLASLONG k, xdouble alpha_r, xdouble alpha_i, xdouble *a, xdouble *b, xdouble *c, BLASLONG ldc, BLASLONG offset, int flag);\n\nint cherk_kernel_UN(BLASLONG m, BLASLONG n, BLASLONG k, float alpha_r, float *a, float *b, float *c, BLASLONG ldc, BLASLONG offset);\nint cherk_kernel_UC(BLASLONG m, BLASLONG n, BLASLONG k, float alpha_r, float *a, float *b, float *c, BLASLONG ldc, BLASLONG offset);\nint cherk_kernel_LN(BLASLONG m, BLASLONG n, BLASLONG k, float alpha_r, float *a, float *b, float *c, BLASLONG ldc, BLASLONG offset);\nint cherk_kernel_LC(BLASLONG m, BLASLONG n, BLASLONG k, float alpha_r, float *a, float *b, float *c, BLASLONG ldc, BLASLONG offset);\n\nint zherk_kernel_UN(BLASLONG m, BLASLONG n, BLASLONG k, double alpha_r, double *a, double *b, double *c, BLASLONG ldc, BLASLONG offset);\nint zherk_kernel_UC(BLASLONG m, BLASLONG n, BLASLONG k, double alpha_r, double *a, double *b, double *c, BLASLONG ldc, BLASLONG offset);\nint zherk_kernel_LN(BLASLONG m, BLASLONG n, BLASLONG k, double alpha_r, double *a, double *b, double *c, BLASLONG ldc, BLASLONG offset);\nint zherk_kernel_LC(BLASLONG m, BLASLONG n, BLASLONG k, double alpha_r, double *a, double *b, double *c, BLASLONG ldc, BLASLONG offset);\n\nint xherk_kernel_UN(BLASLONG m, BLASLONG n, BLASLONG k, xdouble alpha_r, xdouble *a, xdouble *b, xdouble *c, BLASLONG ldc, BLASLONG offset);\nint xherk_kernel_UC(BLASLONG m, BLASLONG n, BLASLONG k, xdouble alpha_r, xdouble *a, xdouble *b, xdouble *c, BLASLONG ldc, BLASLONG offset);\nint xherk_kernel_LN(BLASLONG m, BLASLONG n, BLASLONG k, xdouble alpha_r, xdouble *a, xdouble *b, xdouble *c, BLASLONG ldc, BLASLONG offset);\nint xherk_kernel_LC(BLASLONG m, BLASLONG n, BLASLONG k, xdouble alpha_r, xdouble *a, xdouble *b, xdouble *c, BLASLONG ldc, BLASLONG offset);\n\nint cher2k_kernel_UN(BLASLONG m, BLASLONG n, BLASLONG k, float alpha_r, float alpha_i, float *a, float *b, float *c, BLASLONG ldc, BLASLONG offset, int flag);\nint cher2k_kernel_UC(BLASLONG m, BLASLONG n, BLASLONG k, float alpha_r, float alpha_i, float *a, float *b, float *c, BLASLONG ldc, BLASLONG offset, int flag);\nint cher2k_kernel_LN(BLASLONG m, BLASLONG n, BLASLONG k, float alpha_r, float alpha_i, float *a, float *b, float *c, BLASLONG ldc, BLASLONG offset, int flag);\nint cher2k_kernel_LC(BLASLONG m, BLASLONG n, BLASLONG k, float alpha_r, float alpha_i, float *a, float *b, float *c, BLASLONG ldc, BLASLONG offset, int flag);\n\nint zher2k_kernel_UN(BLASLONG m, BLASLONG n, BLASLONG k, double alpha_r, double alpha_i, double *a, double *b, double *c, BLASLONG ldc, BLASLONG offset, int flag);\nint zher2k_kernel_UC(BLASLONG m, BLASLONG n, BLASLONG k, double alpha_r, double alpha_i, double *a, double *b, double *c, BLASLONG ldc, BLASLONG offset, int flag);\nint zher2k_kernel_LN(BLASLONG m, BLASLONG n, BLASLONG k, double alpha_r, double alpha_i, double *a, double *b, double *c, BLASLONG ldc, BLASLONG offset, int flag);\nint zher2k_kernel_LC(BLASLONG m, BLASLONG n, BLASLONG k, double alpha_r, double alpha_i, double *a, double *b, double *c, BLASLONG ldc, BLASLONG offset, int flag);\n\nint xher2k_kernel_UN(BLASLONG m, BLASLONG n, BLASLONG k, xdouble alpha_r, xdouble alpha_i, xdouble *a, xdouble *b, xdouble *c, BLASLONG ldc, BLASLONG offset, int flag);\nint xher2k_kernel_UC(BLASLONG m, BLASLONG n, BLASLONG k, xdouble alpha_r, xdouble alpha_i, xdouble *a, xdouble *b, xdouble *c, BLASLONG ldc, BLASLONG offset, int flag);\nint xher2k_kernel_LN(BLASLONG m, BLASLONG n, BLASLONG k, xdouble alpha_r, xdouble alpha_i, xdouble *a, xdouble *b, xdouble *c, BLASLONG ldc, BLASLONG offset, int flag);\nint xher2k_kernel_LC(BLASLONG m, BLASLONG n, BLASLONG k, xdouble alpha_r, xdouble alpha_i, xdouble *a, xdouble *b, xdouble *c, BLASLONG ldc, BLASLONG offset, int flag);\n\nint sbgemm_kernel(BLASLONG, BLASLONG, BLASLONG, float,  bfloat16 *, bfloat16 *, float *, BLASLONG);\nint sgemm_kernel(BLASLONG, BLASLONG, BLASLONG, float,  float  *, float  *, float  *, BLASLONG);\nint dgemm_kernel(BLASLONG, BLASLONG, BLASLONG, double, double *, double *, double *, BLASLONG);\n\n#ifdef QUAD_PRECISION\nint qgemm_kernel(BLASLONG, BLASLONG, BLASLONG, xidouble *, xidouble *, xidouble *, xdouble *, BLASLONG);\n#else\nint qgemm_kernel(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG);\n#endif\n\n#ifdef SMALL_MATRIX_OPT\nint sbgemm_small_matrix_permit(int transa, int transb, BLASLONG m, BLASLONG n, BLASLONG k, float alpha, float beta);\n\nint sbgemm_small_kernel_nn(BLASLONG m, BLASLONG n, BLASLONG k, bfloat16 * A, BLASLONG lda, float alpha, bfloat16 * B, BLASLONG ldb, float beta, float * C, BLASLONG ldc);\nint sbgemm_small_kernel_nt(BLASLONG m, BLASLONG n, BLASLONG k, bfloat16 * A, BLASLONG lda, float alpha, bfloat16 * B, BLASLONG ldb, float beta, float * C, BLASLONG ldc);\nint sbgemm_small_kernel_tn(BLASLONG m, BLASLONG n, BLASLONG k, bfloat16 * A, BLASLONG lda, float alpha, bfloat16 * B, BLASLONG ldb, float beta, float * C, BLASLONG ldc);\nint sbgemm_small_kernel_tt(BLASLONG m, BLASLONG n, BLASLONG k, bfloat16 * A, BLASLONG lda, float alpha, bfloat16 * B, BLASLONG ldb, float beta, float * C, BLASLONG ldc);\n\nint sgemm_small_matrix_permit(int transa, int transb, BLASLONG m, BLASLONG n, BLASLONG k, float alpha, float beta);\n\nint sgemm_small_kernel_nn(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha, float * B, BLASLONG ldb, float beta, float * C, BLASLONG ldc);\nint sgemm_small_kernel_nt(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha, float * B, BLASLONG ldb, float beta, float * C, BLASLONG ldc);\nint sgemm_small_kernel_tn(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha, float * B, BLASLONG ldb, float beta, float * C, BLASLONG ldc);\nint sgemm_small_kernel_tt(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha, float * B, BLASLONG ldb, float beta, float * C, BLASLONG ldc);\n\nint dgemm_small_matrix_permit(int transa, int transb, BLASLONG m, BLASLONG n, BLASLONG k, double alpha, double beta);\n\nint dgemm_small_kernel_nn(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha, double * B, BLASLONG ldb, double beta, double * C, BLASLONG ldc);\nint dgemm_small_kernel_nt(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha, double * B, BLASLONG ldb, double beta, double * C, BLASLONG ldc);\nint dgemm_small_kernel_tn(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha, double * B, BLASLONG ldb, double beta, double * C, BLASLONG ldc);\nint dgemm_small_kernel_tt(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha, double * B, BLASLONG ldb, double beta, double * C, BLASLONG ldc);\n\nint sbgemm_small_kernel_b0_nn(BLASLONG m, BLASLONG n, BLASLONG k, bfloat16 * A, BLASLONG lda, float alpha, bfloat16 * B, BLASLONG ldb, float * C, BLASLONG ldc);\nint sbgemm_small_kernel_b0_nt(BLASLONG m, BLASLONG n, BLASLONG k, bfloat16 * A, BLASLONG lda, float alpha, bfloat16 * B, BLASLONG ldb, float * C, BLASLONG ldc);\nint sbgemm_small_kernel_b0_tn(BLASLONG m, BLASLONG n, BLASLONG k, bfloat16 * A, BLASLONG lda, float alpha, bfloat16 * B, BLASLONG ldb, float * C, BLASLONG ldc);\nint sbgemm_small_kernel_b0_tt(BLASLONG m, BLASLONG n, BLASLONG k, bfloat16 * A, BLASLONG lda, float alpha, bfloat16 * B, BLASLONG ldb, float * C, BLASLONG ldc);\n\nint sgemm_small_kernel_b0_nn(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha, float * B, BLASLONG ldb, float * C, BLASLONG ldc);\nint sgemm_small_kernel_b0_nt(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha, float * B, BLASLONG ldb, float * C, BLASLONG ldc);\nint sgemm_small_kernel_b0_tn(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha, float * B, BLASLONG ldb, float * C, BLASLONG ldc);\nint sgemm_small_kernel_b0_tt(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha, float * B, BLASLONG ldb, float * C, BLASLONG ldc);\n\nint dgemm_small_kernel_b0_nn(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha, double * B, BLASLONG ldb, double * C, BLASLONG ldc);\nint dgemm_small_kernel_b0_nt(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha, double * B, BLASLONG ldb, double * C, BLASLONG ldc);\nint dgemm_small_kernel_b0_tn(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha, double * B, BLASLONG ldb, double * C, BLASLONG ldc);\nint dgemm_small_kernel_b0_tt(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha, double * B, BLASLONG ldb, double * C, BLASLONG ldc);\n\nint cgemm_small_matrix_permit(int transa, int transb, BLASLONG m, BLASLONG n, BLASLONG k, float alpha0, float alpha1, float beta0, float beta1);\n\nint cgemm_small_kernel_nn(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb, float beta0, float beta1, float * C, BLASLONG ldc);\nint cgemm_small_kernel_nt(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb, float beta0, float beta1, float * C, BLASLONG ldc);\nint cgemm_small_kernel_nr(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb, float beta0, float beta1, float * C, BLASLONG ldc);\nint cgemm_small_kernel_nc(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb, float beta0, float beta1, float * C, BLASLONG ldc);\n\t\nint cgemm_small_kernel_tn(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb, float beta0, float beta1, float * C, BLASLONG ldc);\nint cgemm_small_kernel_tt(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb, float beta0, float beta1, float * C, BLASLONG ldc);\nint cgemm_small_kernel_tr(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb, float beta0, float beta1, float * C, BLASLONG ldc);\nint cgemm_small_kernel_tc(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb, float beta0, float beta1, float * C, BLASLONG ldc);\n\nint cgemm_small_kernel_rn(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb, float beta0, float beta1, float * C, BLASLONG ldc);\nint cgemm_small_kernel_rt(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb, float beta0, float beta1, float * C, BLASLONG ldc);\nint cgemm_small_kernel_rr(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb, float beta0, float beta1, float * C, BLASLONG ldc);\nint cgemm_small_kernel_rc(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb, float beta0, float beta1, float * C, BLASLONG ldc);\n\nint cgemm_small_kernel_cn(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb, float beta0, float beta1, float * C, BLASLONG ldc);\nint cgemm_small_kernel_ct(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb, float beta0, float beta1, float * C, BLASLONG ldc);\nint cgemm_small_kernel_cr(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb, float beta0, float beta1, float * C, BLASLONG ldc);\nint cgemm_small_kernel_cc(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb, float beta0, float beta1, float * C, BLASLONG ldc);\n\nint zgemm_small_matrix_permit(int transa, int transb, BLASLONG m, BLASLONG n, BLASLONG k, double alpha0, double alpha1, double beta0, double beta1);\n\nint zgemm_small_kernel_nn(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb, double beta0, double beta1, double * C, BLASLONG ldc);\nint zgemm_small_kernel_nt(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb, double beta0, double beta1, double * C, BLASLONG ldc);\nint zgemm_small_kernel_nr(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb, double beta0, double beta1, double * C, BLASLONG ldc);\nint zgemm_small_kernel_nc(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb, double beta0, double beta1, double * C, BLASLONG ldc);\n\t\nint zgemm_small_kernel_tn(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb, double beta0, double beta1, double * C, BLASLONG ldc);\nint zgemm_small_kernel_tt(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb, double beta0, double beta1, double * C, BLASLONG ldc);\nint zgemm_small_kernel_tr(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb, double beta0, double beta1, double * C, BLASLONG ldc);\nint zgemm_small_kernel_tc(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb, double beta0, double beta1, double * C, BLASLONG ldc);\n\nint zgemm_small_kernel_rn(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb, double beta0, double beta1, double * C, BLASLONG ldc);\nint zgemm_small_kernel_rt(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb, double beta0, double beta1, double * C, BLASLONG ldc);\nint zgemm_small_kernel_rr(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb, double beta0, double beta1, double * C, BLASLONG ldc);\nint zgemm_small_kernel_rc(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb, double beta0, double beta1, double * C, BLASLONG ldc);\n\nint zgemm_small_kernel_cn(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb, double beta0, double beta1, double * C, BLASLONG ldc);\nint zgemm_small_kernel_ct(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb, double beta0, double beta1, double * C, BLASLONG ldc);\nint zgemm_small_kernel_cr(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb, double beta0, double beta1, double * C, BLASLONG ldc);\nint zgemm_small_kernel_cc(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb, double beta0, double beta1, double * C, BLASLONG ldc);\n\nint cgemm_small_kernel_b0_nn(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb,  float * C, BLASLONG ldc);\t\nint cgemm_small_kernel_b0_nt(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb,  float * C, BLASLONG ldc);\nint cgemm_small_kernel_b0_nr(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb,  float * C, BLASLONG ldc);\nint cgemm_small_kernel_b0_nc(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb,  float * C, BLASLONG ldc);\n\t\nint cgemm_small_kernel_b0_tn(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb,  float * C, BLASLONG ldc);\nint cgemm_small_kernel_b0_tt(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb,  float * C, BLASLONG ldc);\nint cgemm_small_kernel_b0_tr(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb,  float * C, BLASLONG ldc);\nint cgemm_small_kernel_b0_tc(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb,  float * C, BLASLONG ldc);\n\nint cgemm_small_kernel_b0_rn(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb,  float * C, BLASLONG ldc);\nint cgemm_small_kernel_b0_rt(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb,  float * C, BLASLONG ldc);\nint cgemm_small_kernel_b0_rr(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb,  float * C, BLASLONG ldc);\nint cgemm_small_kernel_b0_rc(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb,  float * C, BLASLONG ldc);\n\nint cgemm_small_kernel_b0_cn(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb,  float * C, BLASLONG ldc);\nint cgemm_small_kernel_b0_ct(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb,  float * C, BLASLONG ldc);\nint cgemm_small_kernel_b0_cr(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb,  float * C, BLASLONG ldc);\nint cgemm_small_kernel_b0_cc(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb,  float * C, BLASLONG ldc);\n\nint zgemm_small_kernel_b0_nn(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb,  double * C, BLASLONG ldc);\t\nint zgemm_small_kernel_b0_nt(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb,  double * C, BLASLONG ldc);\nint zgemm_small_kernel_b0_nr(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb,  double * C, BLASLONG ldc);\nint zgemm_small_kernel_b0_nc(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb,  double * C, BLASLONG ldc);\n\t\nint zgemm_small_kernel_b0_tn(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb,  double * C, BLASLONG ldc);\nint zgemm_small_kernel_b0_tt(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb,  double * C, BLASLONG ldc);\nint zgemm_small_kernel_b0_tr(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb,  double * C, BLASLONG ldc);\nint zgemm_small_kernel_b0_tc(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb,  double * C, BLASLONG ldc);\n\nint zgemm_small_kernel_b0_rn(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb,  double * C, BLASLONG ldc);\nint zgemm_small_kernel_b0_rt(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb,  double * C, BLASLONG ldc);\nint zgemm_small_kernel_b0_rr(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb,  double * C, BLASLONG ldc);\nint zgemm_small_kernel_b0_rc(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb,  double * C, BLASLONG ldc);\n\nint zgemm_small_kernel_b0_cn(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb,  double * C, BLASLONG ldc);\nint zgemm_small_kernel_b0_ct(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb,  double * C, BLASLONG ldc);\nint zgemm_small_kernel_b0_cr(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb,  double * C, BLASLONG ldc);\nint zgemm_small_kernel_b0_cc(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb,  double * C, BLASLONG ldc);\n\n#endif\n\nint cgemm_kernel_n(BLASLONG, BLASLONG, BLASLONG, float,  float,  float  *, float  *, float  *, BLASLONG);\nint cgemm_kernel_l(BLASLONG, BLASLONG, BLASLONG, float,  float,  float  *, float  *, float  *, BLASLONG);\nint cgemm_kernel_r(BLASLONG, BLASLONG, BLASLONG, float,  float,  float  *, float  *, float  *, BLASLONG);\nint cgemm_kernel_b(BLASLONG, BLASLONG, BLASLONG, float,  float,  float  *, float  *, float  *, BLASLONG);\n\nint zgemm_kernel_n(BLASLONG, BLASLONG, BLASLONG, double, double, double *, double *, double *, BLASLONG);\nint zgemm_kernel_l(BLASLONG, BLASLONG, BLASLONG, double, double, double *, double *, double *, BLASLONG);\nint zgemm_kernel_r(BLASLONG, BLASLONG, BLASLONG, double, double, double *, double *, double *, BLASLONG);\nint zgemm_kernel_b(BLASLONG, BLASLONG, BLASLONG, double, double, double *, double *, double *, BLASLONG);\n\nint xgemm_kernel_n(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG);\nint xgemm_kernel_l(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG);\nint xgemm_kernel_r(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG);\nint xgemm_kernel_b(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG);\n\nint cgemm3m_kernel(BLASLONG, BLASLONG, BLASLONG, float,  float,  float  *, float  *, float  *, BLASLONG);\nint zgemm3m_kernel(BLASLONG, BLASLONG, BLASLONG, double, double, double *, double *, double *, BLASLONG);\nint xgemm3m_kernel(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG);\n\nint sbgemm_nn(blas_arg_t *, BLASLONG *, BLASLONG *, bfloat16 *, bfloat16 *, BLASLONG);\nint sbgemm_nt(blas_arg_t *, BLASLONG *, BLASLONG *, bfloat16 *, bfloat16 *, BLASLONG);\nint sbgemm_tn(blas_arg_t *, BLASLONG *, BLASLONG *, bfloat16 *, bfloat16 *, BLASLONG);\nint sbgemm_tt(blas_arg_t *, BLASLONG *, BLASLONG *, bfloat16 *, bfloat16 *, BLASLONG);\n\nint sgemm_nn(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint sgemm_nt(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint sgemm_tn(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint sgemm_tt(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\n\nint dgemm_nn(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint dgemm_nt(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint dgemm_tn(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint dgemm_tt(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\n\n#ifdef QUAD_PRECISION\nint qgemm_nn(blas_arg_t *, BLASLONG *, BLASLONG *, xidouble *, xidouble *, BLASLONG);\nint qgemm_nt(blas_arg_t *, BLASLONG *, BLASLONG *, xidouble *, xidouble *, BLASLONG);\nint qgemm_tn(blas_arg_t *, BLASLONG *, BLASLONG *, xidouble *, xidouble *, BLASLONG);\nint qgemm_tt(blas_arg_t *, BLASLONG *, BLASLONG *, xidouble *, xidouble *, BLASLONG);\n#else\nint qgemm_nn(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint qgemm_nt(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint qgemm_tn(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint qgemm_tt(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\n#endif\n\nint cgemm_nn(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm_nt(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm_nr(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm_nc(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm_tn(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm_tt(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm_tr(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm_tc(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm_rn(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm_rt(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm_rr(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm_rc(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm_cn(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm_ct(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm_cr(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm_cc(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\n\nint zgemm_nn(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm_nt(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm_nr(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm_nc(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm_tn(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm_tt(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm_tr(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm_tc(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm_rn(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm_rt(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm_rr(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm_rc(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm_cn(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm_ct(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm_cr(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm_cc(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\n\n#ifdef QUAD_PRECISION\nint xgemm_nn(blas_arg_t *, BLASLONG *, BLASLONG *, xidouble *, xidouble *, BLASLONG);\nint xgemm_nt(blas_arg_t *, BLASLONG *, BLASLONG *, xidouble *, xidouble *, BLASLONG);\nint xgemm_nr(blas_arg_t *, BLASLONG *, BLASLONG *, xidouble *, xidouble *, BLASLONG);\nint xgemm_nc(blas_arg_t *, BLASLONG *, BLASLONG *, xidouble *, xidouble *, BLASLONG);\nint xgemm_tn(blas_arg_t *, BLASLONG *, BLASLONG *, xidouble *, xidouble *, BLASLONG);\nint xgemm_tt(blas_arg_t *, BLASLONG *, BLASLONG *, xidouble *, xidouble *, BLASLONG);\nint xgemm_tr(blas_arg_t *, BLASLONG *, BLASLONG *, xidouble *, xidouble *, BLASLONG);\nint xgemm_tc(blas_arg_t *, BLASLONG *, BLASLONG *, xidouble *, xidouble *, BLASLONG);\nint xgemm_rn(blas_arg_t *, BLASLONG *, BLASLONG *, xidouble *, xidouble *, BLASLONG);\nint xgemm_rt(blas_arg_t *, BLASLONG *, BLASLONG *, xidouble *, xidouble *, BLASLONG);\nint xgemm_rr(blas_arg_t *, BLASLONG *, BLASLONG *, xidouble *, xidouble *, BLASLONG);\nint xgemm_rc(blas_arg_t *, BLASLONG *, BLASLONG *, xidouble *, xidouble *, BLASLONG);\nint xgemm_cn(blas_arg_t *, BLASLONG *, BLASLONG *, xidouble *, xidouble *, BLASLONG);\nint xgemm_ct(blas_arg_t *, BLASLONG *, BLASLONG *, xidouble *, xidouble *, BLASLONG);\nint xgemm_cr(blas_arg_t *, BLASLONG *, BLASLONG *, xidouble *, xidouble *, BLASLONG);\nint xgemm_cc(blas_arg_t *, BLASLONG *, BLASLONG *, xidouble *, xidouble *, BLASLONG);\n#else\nint xgemm_nn(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm_nt(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm_nr(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm_nc(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm_tn(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm_tt(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm_tr(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm_tc(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm_rn(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm_rt(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm_rr(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm_rc(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm_cn(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm_ct(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm_cr(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm_cc(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\n#endif\n\nint sbgemm_thread_nn(blas_arg_t *, BLASLONG *, BLASLONG *, bfloat16 *, bfloat16 *, BLASLONG);\nint sbgemm_thread_nt(blas_arg_t *, BLASLONG *, BLASLONG *, bfloat16 *, bfloat16 *, BLASLONG);\nint sbgemm_thread_tn(blas_arg_t *, BLASLONG *, BLASLONG *, bfloat16 *, bfloat16 *, BLASLONG);\nint sbgemm_thread_tt(blas_arg_t *, BLASLONG *, BLASLONG *, bfloat16 *, bfloat16 *, BLASLONG);\n\nint sgemm_thread_nn(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint sgemm_thread_nt(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint sgemm_thread_tn(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint sgemm_thread_tt(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\n\nint dgemm_thread_nn(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint dgemm_thread_nt(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint dgemm_thread_tn(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint dgemm_thread_tt(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\n\n#ifdef QUAD_PRECISION\nint qgemm_thread_nn(blas_arg_t *, BLASLONG *, BLASLONG *, xidouble *, xidouble *, BLASLONG);\nint qgemm_thread_nt(blas_arg_t *, BLASLONG *, BLASLONG *, xidouble *, xidouble *, BLASLONG);\nint qgemm_thread_tn(blas_arg_t *, BLASLONG *, BLASLONG *, xidouble *, xidouble *, BLASLONG);\nint qgemm_thread_tt(blas_arg_t *, BLASLONG *, BLASLONG *, xidouble *, xidouble *, BLASLONG);\n#else\nint qgemm_thread_nn(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint qgemm_thread_nt(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint qgemm_thread_tn(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint qgemm_thread_tt(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\n#endif\n\nint cgemm_thread_nn(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm_thread_nt(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm_thread_nr(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm_thread_nc(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm_thread_tn(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm_thread_tt(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm_thread_tr(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm_thread_tc(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm_thread_rn(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm_thread_rt(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm_thread_rr(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm_thread_rc(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm_thread_cn(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm_thread_ct(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm_thread_cr(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm_thread_cc(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\n\nint zgemm_thread_nn(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm_thread_nt(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm_thread_nr(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm_thread_nc(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm_thread_tn(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm_thread_tt(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm_thread_tr(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm_thread_tc(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm_thread_rn(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm_thread_rt(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm_thread_rr(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm_thread_rc(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm_thread_cn(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm_thread_ct(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm_thread_cr(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm_thread_cc(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\n\nint xgemm_thread_nn(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm_thread_nt(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm_thread_nr(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm_thread_nc(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm_thread_tn(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm_thread_tt(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm_thread_tr(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm_thread_tc(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm_thread_rn(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm_thread_rt(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm_thread_rr(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm_thread_rc(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm_thread_cn(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm_thread_ct(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm_thread_cr(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm_thread_cc(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\n\nint cgemm3m_nn(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm3m_nt(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm3m_nr(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm3m_nc(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm3m_tn(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm3m_tt(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm3m_tr(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm3m_tc(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm3m_rn(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm3m_rt(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm3m_rr(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm3m_rc(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm3m_cn(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm3m_ct(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm3m_cr(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm3m_cc(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint zgemm3m_nn(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm3m_nt(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm3m_nr(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm3m_nc(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm3m_tn(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm3m_tt(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm3m_tr(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm3m_tc(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm3m_rn(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm3m_rt(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm3m_rr(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm3m_rc(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm3m_cn(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm3m_ct(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm3m_cr(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm3m_cc(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint xgemm3m_nn(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm3m_nt(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm3m_nr(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm3m_nc(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm3m_tn(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm3m_tt(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm3m_tr(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm3m_tc(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm3m_rn(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm3m_rt(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm3m_rr(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm3m_rc(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm3m_cn(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm3m_ct(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm3m_cr(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm3m_cc(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\n\nint cgemm3m_thread_nn(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm3m_thread_nt(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm3m_thread_nr(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm3m_thread_nc(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm3m_thread_tn(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm3m_thread_tt(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm3m_thread_tr(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm3m_thread_tc(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm3m_thread_rn(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm3m_thread_rt(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm3m_thread_rr(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm3m_thread_rc(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm3m_thread_cn(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm3m_thread_ct(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm3m_thread_cr(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemm3m_thread_cc(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\n\nint zgemm3m_thread_nn(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm3m_thread_nt(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm3m_thread_nr(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm3m_thread_nc(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm3m_thread_tn(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm3m_thread_tt(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm3m_thread_tr(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm3m_thread_tc(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm3m_thread_rn(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm3m_thread_rt(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm3m_thread_rr(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm3m_thread_rc(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm3m_thread_cn(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm3m_thread_ct(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm3m_thread_cr(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemm3m_thread_cc(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\n\nint xgemm3m_thread_nn(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm3m_thread_nt(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm3m_thread_nr(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm3m_thread_nc(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm3m_thread_tn(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm3m_thread_tt(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm3m_thread_tr(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm3m_thread_tc(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm3m_thread_rn(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm3m_thread_rt(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm3m_thread_rr(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm3m_thread_rc(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm3m_thread_cn(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm3m_thread_ct(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm3m_thread_cr(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemm3m_thread_cc(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\n\nint cher2m_LNN(BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG,\n\t       float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, BLASLONG);\nint cher2m_LNT(BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG,\n\t       float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, BLASLONG);\nint cher2m_LNR(BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG,\n\t       float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, BLASLONG);\nint cher2m_LNC(BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG,\n\t       float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, BLASLONG);\nint cher2m_LTN(BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG,\n\t       float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, BLASLONG);\nint cher2m_LTT(BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG,\n\t       float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, BLASLONG);\nint cher2m_LTR(BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG,\n\t       float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, BLASLONG);\nint cher2m_LTC(BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG,\n\t       float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, BLASLONG);\nint cher2m_LRN(BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG,\n\t       float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, BLASLONG);\nint cher2m_LRT(BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG,\n\t       float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, BLASLONG);\nint cher2m_LRR(BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG,\n\t       float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, BLASLONG);\nint cher2m_LRC(BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG,\n\t       float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, BLASLONG);\nint cher2m_LCN(BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG,\n\t       float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, BLASLONG);\nint cher2m_LCT(BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG,\n\t       float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, BLASLONG);\nint cher2m_LCR(BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG,\n\t       float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, BLASLONG);\nint cher2m_LCC(BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG,\n\t       float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, BLASLONG);\nint cher2m_UNN(BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG,\n\t       float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, BLASLONG);\nint cher2m_UNT(BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG,\n\t       float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, BLASLONG);\nint cher2m_UNR(BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG,\n\t       float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, BLASLONG);\nint cher2m_UNC(BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG,\n\t       float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, BLASLONG);\nint cher2m_UTN(BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG,\n\t       float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, BLASLONG);\nint cher2m_UTT(BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG,\n\t       float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, BLASLONG);\nint cher2m_UTR(BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG,\n\t       float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, BLASLONG);\nint cher2m_UTC(BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG,\n\t       float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, BLASLONG);\nint cher2m_URN(BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG,\n\t       float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, BLASLONG);\nint cher2m_URT(BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG,\n\t       float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, BLASLONG);\nint cher2m_URR(BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG,\n\t       float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, BLASLONG);\nint cher2m_URC(BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG,\n\t       float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, BLASLONG);\nint cher2m_UCN(BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG,\n\t       float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, BLASLONG);\nint cher2m_UCT(BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG,\n\t       float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, BLASLONG);\nint cher2m_UCR(BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG,\n\t       float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, BLASLONG);\nint cher2m_UCC(BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG,\n\t       float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, BLASLONG);\n\nint zher2m_LNN(BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG,\n\t       double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, BLASLONG);\nint zher2m_LNT(BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG,\n\t       double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, BLASLONG);\nint zher2m_LNR(BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG,\n\t       double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, BLASLONG);\nint zher2m_LNC(BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG,\n\t       double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, BLASLONG);\nint zher2m_LTN(BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG,\n\t       double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, BLASLONG);\nint zher2m_LTT(BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG,\n\t       double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, BLASLONG);\nint zher2m_LTR(BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG,\n\t       double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, BLASLONG);\nint zher2m_LTC(BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG,\n\t       double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, BLASLONG);\nint zher2m_LRN(BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG,\n\t       double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, BLASLONG);\nint zher2m_LRT(BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG,\n\t       double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, BLASLONG);\nint zher2m_LRR(BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG,\n\t       double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, BLASLONG);\nint zher2m_LRC(BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG,\n\t       double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, BLASLONG);\nint zher2m_LCN(BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG,\n\t       double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, BLASLONG);\nint zher2m_LCT(BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG,\n\t       double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, BLASLONG);\nint zher2m_LCR(BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG,\n\t       double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, BLASLONG);\nint zher2m_LCC(BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG,\n\t       double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, BLASLONG);\nint zher2m_UNN(BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG,\n\t       double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, BLASLONG);\nint zher2m_UNT(BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG,\n\t       double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, BLASLONG);\nint zher2m_UNR(BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG,\n\t       double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, BLASLONG);\nint zher2m_UNC(BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG,\n\t       double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, BLASLONG);\nint zher2m_UTN(BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG,\n\t       double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, BLASLONG);\nint zher2m_UTT(BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG,\n\t       double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, BLASLONG);\nint zher2m_UTR(BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG,\n\t       double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, BLASLONG);\nint zher2m_UTC(BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG,\n\t       double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, BLASLONG);\nint zher2m_URN(BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG,\n\t       double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, BLASLONG);\nint zher2m_URT(BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG,\n\t       double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, BLASLONG);\nint zher2m_URR(BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG,\n\t       double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, BLASLONG);\nint zher2m_URC(BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG,\n\t       double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, BLASLONG);\nint zher2m_UCN(BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG,\n\t       double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, BLASLONG);\nint zher2m_UCT(BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG,\n\t       double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, BLASLONG);\nint zher2m_UCR(BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG,\n\t       double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, BLASLONG);\nint zher2m_UCC(BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG,\n\t       double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, BLASLONG);\n\nint strsm_LNUU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint strsm_LNUN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint strsm_LNLU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint strsm_LNLN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint strsm_LTUU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint strsm_LTUN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint strsm_LTLU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint strsm_LTLN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint strsm_RNUU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint strsm_RNUN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint strsm_RNLU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint strsm_RNLN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint strsm_RTUU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint strsm_RTUN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint strsm_RTLU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint strsm_RTLN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\n\nint dtrsm_LNUU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint dtrsm_LNUN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint dtrsm_LNLU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint dtrsm_LNLN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint dtrsm_LTUU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint dtrsm_LTUN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint dtrsm_LTLU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint dtrsm_LTLN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint dtrsm_RNUU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint dtrsm_RNUN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint dtrsm_RNLU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint dtrsm_RNLN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint dtrsm_RTUU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint dtrsm_RTUN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint dtrsm_RTLU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint dtrsm_RTLN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\n\nint qtrsm_LNUU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint qtrsm_LNUN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint qtrsm_LNLU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint qtrsm_LNLN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint qtrsm_LTUU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint qtrsm_LTUN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint qtrsm_LTLU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint qtrsm_LTLN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint qtrsm_RNUU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint qtrsm_RNUN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint qtrsm_RNLU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint qtrsm_RNLN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint qtrsm_RTUU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint qtrsm_RTUN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint qtrsm_RTLU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint qtrsm_RTLN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\n\nint ctrsm_LNUU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrsm_LNUN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrsm_LNLU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrsm_LNLN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrsm_LTUU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrsm_LTUN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrsm_LTLU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrsm_LTLN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrsm_LRUU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrsm_LRUN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrsm_LRLU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrsm_LRLN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrsm_LCUU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrsm_LCUN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrsm_LCLU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrsm_LCLN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrsm_RNUU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrsm_RNUN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrsm_RNLU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrsm_RNLN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrsm_RTUU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrsm_RTUN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrsm_RTLU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrsm_RTLN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrsm_RRUU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrsm_RRUN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrsm_RRLU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrsm_RRLN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrsm_RCUU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrsm_RCUN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrsm_RCLU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrsm_RCLN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\n\nint ztrsm_LNUU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrsm_LNUN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrsm_LNLU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrsm_LNLN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrsm_LTUU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrsm_LTUN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrsm_LTLU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrsm_LTLN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrsm_LRUU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrsm_LRUN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrsm_LRLU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrsm_LRLN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrsm_LCUU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrsm_LCUN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrsm_LCLU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrsm_LCLN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrsm_RNUU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrsm_RNUN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrsm_RNLU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrsm_RNLN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrsm_RTUU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrsm_RTUN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrsm_RTLU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrsm_RTLN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrsm_RRUU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrsm_RRUN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrsm_RRLU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrsm_RRLN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrsm_RCUU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrsm_RCUN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrsm_RCLU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrsm_RCLN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\n\nint xtrsm_LNUU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrsm_LNUN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrsm_LNLU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrsm_LNLN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrsm_LTUU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrsm_LTUN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrsm_LTLU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrsm_LTLN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrsm_LRUU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrsm_LRUN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrsm_LRLU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrsm_LRLN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrsm_LCUU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrsm_LCUN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrsm_LCLU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrsm_LCLN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrsm_RNUU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrsm_RNUN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrsm_RNLU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrsm_RNLN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrsm_RTUU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrsm_RTUN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrsm_RTLU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrsm_RTLN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrsm_RRUU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrsm_RRUN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrsm_RRLU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrsm_RRLN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrsm_RCUU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrsm_RCUN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrsm_RCLU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrsm_RCLN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\n\nint strmm_LNUU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint strmm_LNUN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint strmm_LNLU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint strmm_LNLN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint strmm_LTUU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint strmm_LTUN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint strmm_LTLU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint strmm_LTLN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint strmm_RNUU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint strmm_RNUN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint strmm_RNLU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint strmm_RNLN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint strmm_RTUU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint strmm_RTUN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint strmm_RTLU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint strmm_RTLN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\n\nint dtrmm_LNUU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint dtrmm_LNUN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint dtrmm_LNLU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint dtrmm_LNLN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint dtrmm_LTUU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint dtrmm_LTUN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint dtrmm_LTLU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint dtrmm_LTLN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint dtrmm_RNUU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint dtrmm_RNUN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint dtrmm_RNLU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint dtrmm_RNLN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint dtrmm_RTUU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint dtrmm_RTUN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint dtrmm_RTLU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint dtrmm_RTLN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\n\nint qtrmm_LNUU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint qtrmm_LNUN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint qtrmm_LNLU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint qtrmm_LNLN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint qtrmm_LTUU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint qtrmm_LTUN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint qtrmm_LTLU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint qtrmm_LTLN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint qtrmm_RNUU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint qtrmm_RNUN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint qtrmm_RNLU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint qtrmm_RNLN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint qtrmm_RTUU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint qtrmm_RTUN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint qtrmm_RTLU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint qtrmm_RTLN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\n\nint ctrmm_LNUU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrmm_LNUN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrmm_LNLU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrmm_LNLN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrmm_LTUU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrmm_LTUN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrmm_LTLU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrmm_LTLN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrmm_LRUU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrmm_LRUN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrmm_LRLU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrmm_LRLN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrmm_LCUU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrmm_LCUN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrmm_LCLU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrmm_LCLN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrmm_RNUU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrmm_RNUN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrmm_RNLU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrmm_RNLN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrmm_RTUU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrmm_RTUN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrmm_RTLU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrmm_RTLN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrmm_RRUU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrmm_RRUN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrmm_RRLU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrmm_RRLN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrmm_RCUU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrmm_RCUN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrmm_RCLU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ctrmm_RCLN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\n\nint ztrmm_LNUU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrmm_LNUN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrmm_LNLU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrmm_LNLN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrmm_LTUU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrmm_LTUN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrmm_LTLU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrmm_LTLN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrmm_LRUU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrmm_LRUN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrmm_LRLU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrmm_LRLN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrmm_LCUU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrmm_LCUN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrmm_LCLU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrmm_LCLN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrmm_RNUU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrmm_RNUN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrmm_RNLU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrmm_RNLN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrmm_RTUU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrmm_RTUN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrmm_RTLU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrmm_RTLN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrmm_RRUU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrmm_RRUN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrmm_RRLU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrmm_RRLN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrmm_RCUU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrmm_RCUN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrmm_RCLU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint ztrmm_RCLN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\n\nint xtrmm_LNUU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrmm_LNUN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrmm_LNLU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrmm_LNLN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrmm_LTUU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrmm_LTUN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrmm_LTLU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrmm_LTLN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrmm_LRUU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrmm_LRUN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrmm_LRLU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrmm_LRLN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrmm_LCUU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrmm_LCUN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrmm_LCLU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrmm_LCLN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrmm_RNUU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrmm_RNUN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrmm_RNLU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrmm_RNLN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrmm_RTUU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrmm_RTUN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrmm_RTLU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrmm_RTLN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrmm_RRUU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrmm_RRUN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrmm_RRLU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrmm_RRLN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrmm_RCUU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrmm_RCUN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrmm_RCLU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xtrmm_RCLN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\n\nint ssymm_LU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ssymm_LL(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ssymm_RU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ssymm_RL(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\n\nint dsymm_LU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint dsymm_LL(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint dsymm_RU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint dsymm_RL(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\n\nint qsymm_LU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint qsymm_LL(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint qsymm_RU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint qsymm_RL(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\n\nint csymm_LU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint csymm_LL(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint csymm_RU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint csymm_RL(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\n\nint zsymm_LU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zsymm_LL(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zsymm_RU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zsymm_RL(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\n\nint xsymm_LU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xsymm_LL(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xsymm_RU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xsymm_RL(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\n\nint csymm3m_LU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint csymm3m_LL(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint csymm3m_RU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint csymm3m_RL(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\n\nint zsymm3m_LU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zsymm3m_LL(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zsymm3m_RU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zsymm3m_RL(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\n\nint xsymm3m_LU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xsymm3m_LL(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xsymm3m_RU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xsymm3m_RL(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\n\nint csymm3m_thread_LU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint csymm3m_thread_LL(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint csymm3m_thread_RU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint csymm3m_thread_RL(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\n\nint zsymm3m_thread_LU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zsymm3m_thread_LL(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zsymm3m_thread_RU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zsymm3m_thread_RL(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\n\nint xsymm3m_thread_LU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xsymm3m_thread_LL(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xsymm3m_thread_RU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xsymm3m_thread_RL(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\n\nint chemm_LU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint chemm_LL(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint chemm_RU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint chemm_RL(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\n\nint zhemm_LU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zhemm_LL(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zhemm_RU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zhemm_RL(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\n\nint xhemm_LU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xhemm_LL(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xhemm_RU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xhemm_RL(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\n\nint chemm3m_LU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint chemm3m_LL(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint chemm3m_RU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint chemm3m_RL(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\n\nint zhemm3m_LU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zhemm3m_LL(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zhemm3m_RU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zhemm3m_RL(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\n\nint xhemm3m_LU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xhemm3m_LL(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xhemm3m_RU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xhemm3m_RL(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\n\nint chemm3m_thread_LU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint chemm3m_thread_LL(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint chemm3m_thread_RU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint chemm3m_thread_RL(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\n\nint zhemm3m_thread_LU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zhemm3m_thread_LL(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zhemm3m_thread_RU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zhemm3m_thread_RL(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\n\nint xhemm3m_thread_LU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xhemm3m_thread_LL(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xhemm3m_thread_RU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xhemm3m_thread_RL(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\n\nint ssymm_thread_LU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ssymm_thread_LL(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ssymm_thread_RU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ssymm_thread_RL(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\n\nint dsymm_thread_LU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint dsymm_thread_LL(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint dsymm_thread_RU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint dsymm_thread_RL(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\n\nint qsymm_thread_LU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint qsymm_thread_LL(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint qsymm_thread_RU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint qsymm_thread_RL(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\n\nint csymm_thread_LU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint csymm_thread_LL(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint csymm_thread_RU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint csymm_thread_RL(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\n\nint zsymm_thread_LU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zsymm_thread_LL(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zsymm_thread_RU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zsymm_thread_RL(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\n\nint xsymm_thread_LU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xsymm_thread_LL(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xsymm_thread_RU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xsymm_thread_RL(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\n\nint chemm_thread_LU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint chemm_thread_LL(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint chemm_thread_RU(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint chemm_thread_RL(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\n\nint zhemm_thread_LU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zhemm_thread_LL(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zhemm_thread_RU(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zhemm_thread_RL(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\n\nint xhemm_thread_LU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xhemm_thread_LL(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xhemm_thread_RU(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xhemm_thread_RL(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\n\nint ssyrk_UN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ssyrk_UT(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ssyrk_LN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ssyrk_LT(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\n\nint dsyrk_UN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint dsyrk_UT(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint dsyrk_LN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint dsyrk_LT(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\n\nint qsyrk_UN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint qsyrk_UT(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint qsyrk_LN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint qsyrk_LT(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\n\nint csyrk_UN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint csyrk_UT(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint csyrk_LN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint csyrk_LT(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\n\nint zsyrk_UN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zsyrk_UT(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zsyrk_LN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zsyrk_LT(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\n\nint xsyrk_UN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xsyrk_UT(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xsyrk_LN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xsyrk_LT(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\n\nint ssyrk_thread_UN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ssyrk_thread_UT(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ssyrk_thread_LN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ssyrk_thread_LT(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\n\nint dsyrk_thread_UN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint dsyrk_thread_UT(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint dsyrk_thread_LN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint dsyrk_thread_LT(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\n\nint qsyrk_thread_UN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint qsyrk_thread_UT(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint qsyrk_thread_LN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint qsyrk_thread_LT(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\n\nint csyrk_thread_UN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint csyrk_thread_UT(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint csyrk_thread_LN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint csyrk_thread_LT(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\n\nint zsyrk_thread_UN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zsyrk_thread_UT(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zsyrk_thread_LN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zsyrk_thread_LT(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\n\nint xsyrk_thread_UN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xsyrk_thread_UT(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xsyrk_thread_LN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xsyrk_thread_LT(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\n\nint ssyr2k_UN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ssyr2k_UT(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ssyr2k_LN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint ssyr2k_LT(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\n\nint dsyr2k_UN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint dsyr2k_UT(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint dsyr2k_LN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint dsyr2k_LT(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\n\nint qsyr2k_UN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint qsyr2k_UT(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint qsyr2k_LN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint qsyr2k_LT(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\n\nint csyr2k_UN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint csyr2k_UT(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint csyr2k_LN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint csyr2k_LT(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\n\nint zsyr2k_UN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zsyr2k_UT(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zsyr2k_LN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zsyr2k_LT(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\n\nint xsyr2k_UN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xsyr2k_UT(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xsyr2k_LN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xsyr2k_LT(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\n\nint cherk_UN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cherk_UC(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cherk_LN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cherk_LC(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\n\nint zherk_UN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zherk_UC(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zherk_LN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zherk_LC(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\n\nint xherk_UN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xherk_UC(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xherk_LN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xherk_LC(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\n\nint cherk_thread_UN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cherk_thread_UC(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cherk_thread_LN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cherk_thread_LC(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\n\nint zherk_thread_UN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zherk_thread_UC(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zherk_thread_LN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zherk_thread_LC(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\n\nint xherk_thread_UN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xherk_thread_UC(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xherk_thread_LN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xherk_thread_LC(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\n\nint cher2k_UN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cher2k_UC(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cher2k_LN(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cher2k_LC(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\n\nint zher2k_UN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zher2k_UC(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zher2k_LN(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zher2k_LC(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\n\nint xher2k_UN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xher2k_UC(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xher2k_LN(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xher2k_LC(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\n\nint sgemt_n(BLASLONG, BLASLONG, float,  float   *, BLASLONG, float    *, int);\nint sgemt_t(BLASLONG, BLASLONG, float,  float   *, BLASLONG, float    *, int);\nint dgemt_n(BLASLONG, BLASLONG, double, double  *, BLASLONG, double   *, int);\nint dgemt_t(BLASLONG, BLASLONG, double, double  *, BLASLONG, double   *, int);\n\nint cgemt_n(BLASLONG, BLASLONG, float,  float,  float   *, BLASLONG, float    *, int);\nint cgemt_t(BLASLONG, BLASLONG, float,  float,  float   *, BLASLONG, float    *, int);\nint cgemt_r(BLASLONG, BLASLONG, float,  float,  float   *, BLASLONG, float    *, int);\nint cgemt_c(BLASLONG, BLASLONG, float,  float,  float   *, BLASLONG, float    *, int);\nint zgemt_n(BLASLONG, BLASLONG, double, double, double  *, BLASLONG, double   *, int);\nint zgemt_t(BLASLONG, BLASLONG, double, double, double  *, BLASLONG, double   *, int);\nint zgemt_r(BLASLONG, BLASLONG, double, double, double  *, BLASLONG, double   *, int);\nint zgemt_c(BLASLONG, BLASLONG, double, double, double  *, BLASLONG, double   *, int);\n\nint sgema_n(BLASLONG, BLASLONG, float,  float   *, BLASLONG, float    *, BLASLONG);\nint sgema_t(BLASLONG, BLASLONG, float,  float   *, BLASLONG, float    *, BLASLONG);\nint dgema_n(BLASLONG, BLASLONG, double, double  *, BLASLONG, double   *, BLASLONG);\nint dgema_t(BLASLONG, BLASLONG, double, double  *, BLASLONG, double   *, BLASLONG);\n\nint cgema_n(BLASLONG, BLASLONG, float,  float,  float   *, BLASLONG, float    *, BLASLONG);\nint cgema_t(BLASLONG, BLASLONG, float,  float,  float   *, BLASLONG, float    *, BLASLONG);\nint cgema_r(BLASLONG, BLASLONG, float,  float,  float   *, BLASLONG, float    *, BLASLONG);\nint cgema_c(BLASLONG, BLASLONG, float,  float,  float   *, BLASLONG, float    *, BLASLONG);\nint zgema_n(BLASLONG, BLASLONG, double, double, double  *, BLASLONG, double   *, BLASLONG);\nint zgema_t(BLASLONG, BLASLONG, double, double, double  *, BLASLONG, double   *, BLASLONG);\nint zgema_r(BLASLONG, BLASLONG, double, double, double  *, BLASLONG, double   *, BLASLONG);\nint zgema_c(BLASLONG, BLASLONG, double, double, double  *, BLASLONG, double   *, BLASLONG);\n\nint cgemm3m_incopyb(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, float *b);\nint cgemm3m_incopyr(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, float *b);\nint cgemm3m_incopyi(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, float *b);\nint cgemm3m_itcopyb(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, float *b);\nint cgemm3m_itcopyr(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, float *b);\nint cgemm3m_itcopyi(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, float *b);\n\nint cgemm3m_oncopyb(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, float alpha_r, float alpha_i, float *b);\nint cgemm3m_oncopyr(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, float alpha_r, float alpha_i, float *b);\nint cgemm3m_oncopyi(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, float alpha_r, float alpha_i, float *b);\nint cgemm3m_otcopyb(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, float alpha_r, float alpha_i, float *b);\nint cgemm3m_otcopyr(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, float alpha_r, float alpha_i, float *b);\nint cgemm3m_otcopyi(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, float alpha_r, float alpha_i, float *b);\n\nint zgemm3m_incopyb(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, double *b);\nint zgemm3m_incopyr(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, double *b);\nint zgemm3m_incopyi(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, double *b);\nint zgemm3m_itcopyb(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, double *b);\nint zgemm3m_itcopyr(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, double *b);\nint zgemm3m_itcopyi(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, double *b);\n\nint zgemm3m_oncopyb(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, double alpha_r, double alpha_i, double *b);\nint zgemm3m_oncopyr(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, double alpha_r, double alpha_i, double *b);\nint zgemm3m_oncopyi(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, double alpha_r, double alpha_i, double *b);\nint zgemm3m_otcopyb(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, double alpha_r, double alpha_i, double *b);\nint zgemm3m_otcopyr(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, double alpha_r, double alpha_i, double *b);\nint zgemm3m_otcopyi(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, double alpha_r, double alpha_i, double *b);\n\nint xgemm3m_incopyb(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, xdouble *b);\nint xgemm3m_incopyr(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, xdouble *b);\nint xgemm3m_incopyi(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, xdouble *b);\nint xgemm3m_itcopyb(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, xdouble *b);\nint xgemm3m_itcopyr(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, xdouble *b);\nint xgemm3m_itcopyi(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, xdouble *b);\n\nint xgemm3m_oncopyb(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, xdouble alpha_r, xdouble alpha_i, xdouble *b);\nint xgemm3m_oncopyr(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, xdouble alpha_r, xdouble alpha_i, xdouble *b);\nint xgemm3m_oncopyi(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, xdouble alpha_r, xdouble alpha_i, xdouble *b);\nint xgemm3m_otcopyb(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, xdouble alpha_r, xdouble alpha_i, xdouble *b);\nint xgemm3m_otcopyr(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, xdouble alpha_r, xdouble alpha_i, xdouble *b);\nint xgemm3m_otcopyi(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, xdouble alpha_r, xdouble alpha_i, xdouble *b);\n\nint csymm3m_iucopyb(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG x, BLASLONG y, float *b);\nint csymm3m_ilcopyb(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG x, BLASLONG y, float *b);\nint csymm3m_iucopyr(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG x, BLASLONG y, float *b);\nint csymm3m_ilcopyr(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG x, BLASLONG y, float *b);\nint csymm3m_iucopyi(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG x, BLASLONG y, float *b);\nint csymm3m_ilcopyi(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG x, BLASLONG y, float *b);\n\nint csymm3m_oucopyb(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG x, BLASLONG y, float alpha_r, float alpha_i, float *b);\nint csymm3m_olcopyb(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG x, BLASLONG y, float alpha_r, float alpha_i, float *b);\nint csymm3m_oucopyr(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG x, BLASLONG y, float alpha_r, float alpha_i, float *b);\nint csymm3m_olcopyr(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG x, BLASLONG y, float alpha_r, float alpha_i, float *b);\nint csymm3m_oucopyi(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG x, BLASLONG y, float alpha_r, float alpha_i, float *b);\nint csymm3m_olcopyi(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG x, BLASLONG y, float alpha_r, float alpha_i, float *b);\n\nint zsymm3m_iucopyb(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG x, BLASLONG y, double *b);\nint zsymm3m_ilcopyb(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG x, BLASLONG y, double *b);\nint zsymm3m_iucopyr(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG x, BLASLONG y, double *b);\nint zsymm3m_ilcopyr(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG x, BLASLONG y, double *b);\nint zsymm3m_iucopyi(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG x, BLASLONG y, double *b);\nint zsymm3m_ilcopyi(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG x, BLASLONG y, double *b);\n\nint zsymm3m_oucopyb(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG x, BLASLONG y, double alpha_r, double alpha_i, double *b);\nint zsymm3m_olcopyb(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG x, BLASLONG y, double alpha_r, double alpha_i, double *b);\nint zsymm3m_oucopyr(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG x, BLASLONG y, double alpha_r, double alpha_i, double *b);\nint zsymm3m_olcopyr(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG x, BLASLONG y, double alpha_r, double alpha_i, double *b);\nint zsymm3m_oucopyi(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG x, BLASLONG y, double alpha_r, double alpha_i, double *b);\nint zsymm3m_olcopyi(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG x, BLASLONG y, double alpha_r, double alpha_i, double *b);\n\nint xsymm3m_iucopyb(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG x, BLASLONG y, xdouble *b);\nint xsymm3m_ilcopyb(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG x, BLASLONG y, xdouble *b);\nint xsymm3m_iucopyr(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG x, BLASLONG y, xdouble *b);\nint xsymm3m_ilcopyr(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG x, BLASLONG y, xdouble *b);\nint xsymm3m_iucopyi(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG x, BLASLONG y, xdouble *b);\nint xsymm3m_ilcopyi(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG x, BLASLONG y, xdouble *b);\n\nint xsymm3m_oucopyb(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG x, BLASLONG y, xdouble alpha_r, xdouble alpha_i, xdouble *b);\nint xsymm3m_olcopyb(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG x, BLASLONG y, xdouble alpha_r, xdouble alpha_i, xdouble *b);\nint xsymm3m_oucopyr(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG x, BLASLONG y, xdouble alpha_r, xdouble alpha_i, xdouble *b);\nint xsymm3m_olcopyr(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG x, BLASLONG y, xdouble alpha_r, xdouble alpha_i, xdouble *b);\nint xsymm3m_oucopyi(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG x, BLASLONG y, xdouble alpha_r, xdouble alpha_i, xdouble *b);\nint xsymm3m_olcopyi(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG x, BLASLONG y, xdouble alpha_r, xdouble alpha_i, xdouble *b);\n\nint chemm3m_iucopyb(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG x, BLASLONG y, float *b);\nint chemm3m_ilcopyb(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG x, BLASLONG y, float *b);\nint chemm3m_iucopyr(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG x, BLASLONG y, float *b);\nint chemm3m_ilcopyr(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG x, BLASLONG y, float *b);\nint chemm3m_iucopyi(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG x, BLASLONG y, float *b);\nint chemm3m_ilcopyi(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG x, BLASLONG y, float *b);\n\nint chemm3m_oucopyb(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG x, BLASLONG y, float alpha_r, float alpha_i, float *b);\nint chemm3m_olcopyb(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG x, BLASLONG y, float alpha_r, float alpha_i, float *b);\nint chemm3m_oucopyr(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG x, BLASLONG y, float alpha_r, float alpha_i, float *b);\nint chemm3m_olcopyr(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG x, BLASLONG y, float alpha_r, float alpha_i, float *b);\nint chemm3m_oucopyi(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG x, BLASLONG y, float alpha_r, float alpha_i, float *b);\nint chemm3m_olcopyi(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, BLASLONG x, BLASLONG y, float alpha_r, float alpha_i, float *b);\n\nint zhemm3m_iucopyb(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG x, BLASLONG y, double *b);\nint zhemm3m_ilcopyb(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG x, BLASLONG y, double *b);\nint zhemm3m_iucopyr(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG x, BLASLONG y, double *b);\nint zhemm3m_ilcopyr(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG x, BLASLONG y, double *b);\nint zhemm3m_iucopyi(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG x, BLASLONG y, double *b);\nint zhemm3m_ilcopyi(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG x, BLASLONG y, double *b);\n\nint zhemm3m_oucopyb(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG x, BLASLONG y, double alpha_r, double alpha_i, double *b);\nint zhemm3m_olcopyb(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG x, BLASLONG y, double alpha_r, double alpha_i, double *b);\nint zhemm3m_oucopyr(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG x, BLASLONG y, double alpha_r, double alpha_i, double *b);\nint zhemm3m_olcopyr(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG x, BLASLONG y, double alpha_r, double alpha_i, double *b);\nint zhemm3m_oucopyi(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG x, BLASLONG y, double alpha_r, double alpha_i, double *b);\nint zhemm3m_olcopyi(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, BLASLONG x, BLASLONG y, double alpha_r, double alpha_i, double *b);\n\nint xhemm3m_iucopyb(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG x, BLASLONG y, xdouble *b);\nint xhemm3m_ilcopyb(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG x, BLASLONG y, xdouble *b);\nint xhemm3m_iucopyr(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG x, BLASLONG y, xdouble *b);\nint xhemm3m_ilcopyr(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG x, BLASLONG y, xdouble *b);\nint xhemm3m_iucopyi(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG x, BLASLONG y, xdouble *b);\nint xhemm3m_ilcopyi(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG x, BLASLONG y, xdouble *b);\n\nint xhemm3m_oucopyb(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG x, BLASLONG y, xdouble alpha_r, xdouble alpha_i, xdouble *b);\nint xhemm3m_olcopyb(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG x, BLASLONG y, xdouble alpha_r, xdouble alpha_i, xdouble *b);\nint xhemm3m_oucopyr(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG x, BLASLONG y, xdouble alpha_r, xdouble alpha_i, xdouble *b);\nint xhemm3m_olcopyr(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG x, BLASLONG y, xdouble alpha_r, xdouble alpha_i, xdouble *b);\nint xhemm3m_oucopyi(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG x, BLASLONG y, xdouble alpha_r, xdouble alpha_i, xdouble *b);\nint xhemm3m_olcopyi(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, BLASLONG x, BLASLONG y, xdouble alpha_r, xdouble alpha_i, xdouble *b);\n\nint sgemc_nn(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint sgemc_nt(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint sgemc_tn(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint sgemc_tt(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\n\nint dgemc_nn(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint dgemc_nt(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint dgemc_tn(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint dgemc_tt(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\n\nint qgemc_nn(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint qgemc_nt(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint qgemc_tn(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint qgemc_tt(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\n\nint cgemc_nn(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemc_nt(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemc_nr(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemc_nc(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemc_tn(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemc_tt(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemc_tr(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemc_tc(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemc_rn(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemc_rt(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemc_rr(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemc_rc(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemc_cn(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemc_ct(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemc_cr(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\nint cgemc_cc(blas_arg_t *, BLASLONG *, BLASLONG *, float *, float *, BLASLONG);\n\nint zgemc_nn(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemc_nt(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemc_nr(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemc_nc(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemc_tn(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemc_tt(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemc_tr(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemc_tc(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemc_rn(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemc_rt(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemc_rr(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemc_rc(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemc_cn(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemc_ct(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemc_cr(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\nint zgemc_cc(blas_arg_t *, BLASLONG *, BLASLONG *, double *, double *, BLASLONG);\n\nint xgemc_nn(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemc_nt(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemc_nr(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemc_nc(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemc_tn(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemc_tt(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemc_tr(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemc_tc(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemc_rn(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemc_rt(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemc_rr(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemc_rc(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemc_cn(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemc_ct(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemc_cr(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\nint xgemc_cc(blas_arg_t *, BLASLONG *, BLASLONG *, xdouble *, xdouble *, BLASLONG);\n\nint sgemc_oncopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, float *b, BLASLONG ldb, float *c);\nint sgemc_otcopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, float *b, BLASLONG ldb, float *c);\nint dgemc_oncopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, double *b, BLASLONG ldb, double *c);\nint dgemc_otcopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, double *b, BLASLONG ldb, double *c);\nint qgemc_oncopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, xdouble *b, BLASLONG ldb, xdouble *c);\nint qgemc_otcopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, xdouble *b, BLASLONG ldb, xdouble *c);\nint cgemc_oncopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, float *b, BLASLONG ldb, float *c);\nint cgemc_otcopy(BLASLONG m, BLASLONG n, float *a, BLASLONG lda, float *b, BLASLONG ldb, float *c);\nint zgemc_oncopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, double *b, BLASLONG ldb, double *c);\nint zgemc_otcopy(BLASLONG m, BLASLONG n, double *a, BLASLONG lda, double *b, BLASLONG ldb, double *c);\nint xgemc_oncopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, xdouble *b, BLASLONG ldb, xdouble *c);\nint xgemc_otcopy(BLASLONG m, BLASLONG n, xdouble *a, BLASLONG lda, xdouble *b, BLASLONG ldb, xdouble *c);\n\nint somatcopy_k_cn(BLASLONG, BLASLONG,  float, float *, BLASLONG, float  *, BLASLONG);\nint somatcopy_k_rn(BLASLONG, BLASLONG,  float, float *, BLASLONG, float  *, BLASLONG);\nint somatcopy_k_ct(BLASLONG, BLASLONG,  float, float *, BLASLONG, float  *, BLASLONG);\nint somatcopy_k_rt(BLASLONG, BLASLONG,  float, float *, BLASLONG, float  *, BLASLONG);\nint simatcopy_k_cn(BLASLONG, BLASLONG,  float, float *, BLASLONG);\nint simatcopy_k_rn(BLASLONG, BLASLONG,  float, float *, BLASLONG);\nint simatcopy_k_ct(BLASLONG, BLASLONG,  float, float *, BLASLONG);\nint simatcopy_k_rt(BLASLONG, BLASLONG,  float, float *, BLASLONG);\n\nint domatcopy_k_cn(BLASLONG, BLASLONG,  double, double *, BLASLONG, double  *, BLASLONG);\nint domatcopy_k_rn(BLASLONG, BLASLONG,  double, double *, BLASLONG, double  *, BLASLONG);\nint domatcopy_k_ct(BLASLONG, BLASLONG,  double, double *, BLASLONG, double  *, BLASLONG);\nint domatcopy_k_rt(BLASLONG, BLASLONG,  double, double *, BLASLONG, double  *, BLASLONG);\nint dimatcopy_k_cn(BLASLONG, BLASLONG,  double, double *, BLASLONG);\nint dimatcopy_k_rn(BLASLONG, BLASLONG,  double, double *, BLASLONG);\nint dimatcopy_k_ct(BLASLONG, BLASLONG,  double, double *, BLASLONG);\nint dimatcopy_k_rt(BLASLONG, BLASLONG,  double, double *, BLASLONG);\n\nint comatcopy_k_cn(BLASLONG, BLASLONG,  float, float, float *, BLASLONG, float  *, BLASLONG);\nint comatcopy_k_rn(BLASLONG, BLASLONG,  float, float, float *, BLASLONG, float  *, BLASLONG);\nint comatcopy_k_ct(BLASLONG, BLASLONG,  float, float, float *, BLASLONG, float  *, BLASLONG);\nint comatcopy_k_rt(BLASLONG, BLASLONG,  float, float, float *, BLASLONG, float  *, BLASLONG);\nint cimatcopy_k_cn(BLASLONG, BLASLONG,  float, float, float *, BLASLONG);\nint cimatcopy_k_rn(BLASLONG, BLASLONG,  float, float, float *, BLASLONG);\nint cimatcopy_k_ct(BLASLONG, BLASLONG,  float, float, float *, BLASLONG);\nint cimatcopy_k_rt(BLASLONG, BLASLONG,  float, float, float *, BLASLONG);\n\nint comatcopy_k_cnc(BLASLONG, BLASLONG,  float, float, float *, BLASLONG, float  *, BLASLONG);\nint comatcopy_k_rnc(BLASLONG, BLASLONG,  float, float, float *, BLASLONG, float  *, BLASLONG);\nint comatcopy_k_ctc(BLASLONG, BLASLONG,  float, float, float *, BLASLONG, float  *, BLASLONG);\nint comatcopy_k_rtc(BLASLONG, BLASLONG,  float, float, float *, BLASLONG, float  *, BLASLONG);\nint cimatcopy_k_cnc(BLASLONG, BLASLONG,  float, float, float *, BLASLONG);\nint cimatcopy_k_rnc(BLASLONG, BLASLONG,  float, float, float *, BLASLONG);\nint cimatcopy_k_ctc(BLASLONG, BLASLONG,  float, float, float *, BLASLONG);\nint cimatcopy_k_rtc(BLASLONG, BLASLONG,  float, float, float *, BLASLONG);\n\nint zomatcopy_k_cn(BLASLONG, BLASLONG,  double, double, double *, BLASLONG, double  *, BLASLONG);\nint zomatcopy_k_rn(BLASLONG, BLASLONG,  double, double, double *, BLASLONG, double  *, BLASLONG);\nint zomatcopy_k_ct(BLASLONG, BLASLONG,  double, double, double *, BLASLONG, double  *, BLASLONG);\nint zomatcopy_k_rt(BLASLONG, BLASLONG,  double, double, double *, BLASLONG, double  *, BLASLONG);\nint zimatcopy_k_cn(BLASLONG, BLASLONG,  double, double, double *, BLASLONG);\nint zimatcopy_k_rn(BLASLONG, BLASLONG,  double, double, double *, BLASLONG);\nint zimatcopy_k_ct(BLASLONG, BLASLONG,  double, double, double *, BLASLONG);\nint zimatcopy_k_rt(BLASLONG, BLASLONG,  double, double, double *, BLASLONG);\n\nint zomatcopy_k_cnc(BLASLONG, BLASLONG,  double, double, double *, BLASLONG, double  *, BLASLONG);\nint zomatcopy_k_rnc(BLASLONG, BLASLONG,  double, double, double *, BLASLONG, double  *, BLASLONG);\nint zomatcopy_k_ctc(BLASLONG, BLASLONG,  double, double, double *, BLASLONG, double  *, BLASLONG);\nint zomatcopy_k_rtc(BLASLONG, BLASLONG,  double, double, double *, BLASLONG, double  *, BLASLONG);\nint zimatcopy_k_cnc(BLASLONG, BLASLONG,  double, double, double *, BLASLONG);\nint zimatcopy_k_rnc(BLASLONG, BLASLONG,  double, double, double *, BLASLONG);\nint zimatcopy_k_ctc(BLASLONG, BLASLONG,  double, double, double *, BLASLONG);\nint zimatcopy_k_rtc(BLASLONG, BLASLONG,  double, double, double *, BLASLONG);\n\nint sgeadd_k(BLASLONG, BLASLONG, float, float*, BLASLONG, float, float *, BLASLONG); \nint dgeadd_k(BLASLONG, BLASLONG, double, double*, BLASLONG, double, double *, BLASLONG); \nint cgeadd_k(BLASLONG, BLASLONG, float, float, float*, BLASLONG, float, float, float *, BLASLONG); \nint zgeadd_k(BLASLONG, BLASLONG, double,double, double*, BLASLONG, double, double, double *, BLASLONG);\n\nint sgemm_batch_thread(blas_arg_t * queue, BLASLONG nums);\nint dgemm_batch_thread(blas_arg_t * queue, BLASLONG nums);\nint cgemm_batch_thread(blas_arg_t * queue, BLASLONG nums);\nint zgemm_batch_thread(blas_arg_t * queue, BLASLONG nums);\nint sbgemm_batch_thread(blas_arg_t * queue, BLASLONG nums);\n\n#ifdef __CUDACC__\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "common_linux.h",
          "type": "blob",
          "size": 4.0693359375,
          "content": "/*********************************************************************/\n/* Copyright 2009, 2010 The University of Texas at Austin.           */\n/* All rights reserved.                                              */\n/*                                                                   */\n/* Redistribution and use in source and binary forms, with or        */\n/* without modification, are permitted provided that the following   */\n/* conditions are met:                                               */\n/*                                                                   */\n/*   1. Redistributions of source code must retain the above         */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer.                                                  */\n/*                                                                   */\n/*   2. Redistributions in binary form must reproduce the above      */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer in the documentation and/or other materials       */\n/*      provided with the distribution.                              */\n/*                                                                   */\n/*    THIS  SOFTWARE IS PROVIDED  BY THE  UNIVERSITY OF  TEXAS AT    */\n/*    AUSTIN  ``AS IS''  AND ANY  EXPRESS OR  IMPLIED WARRANTIES,    */\n/*    INCLUDING, BUT  NOT LIMITED  TO, THE IMPLIED  WARRANTIES OF    */\n/*    MERCHANTABILITY  AND FITNESS FOR  A PARTICULAR  PURPOSE ARE    */\n/*    DISCLAIMED.  IN  NO EVENT SHALL THE UNIVERSITY  OF TEXAS AT    */\n/*    AUSTIN OR CONTRIBUTORS BE  LIABLE FOR ANY DIRECT, INDIRECT,    */\n/*    INCIDENTAL,  SPECIAL, EXEMPLARY,  OR  CONSEQUENTIAL DAMAGES    */\n/*    (INCLUDING, BUT  NOT LIMITED TO,  PROCUREMENT OF SUBSTITUTE    */\n/*    GOODS  OR  SERVICES; LOSS  OF  USE,  DATA,  OR PROFITS;  OR    */\n/*    BUSINESS INTERRUPTION) HOWEVER CAUSED  AND ON ANY THEORY OF    */\n/*    LIABILITY, WHETHER  IN CONTRACT, STRICT  LIABILITY, OR TORT    */\n/*    (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY WAY OUT    */\n/*    OF  THE  USE OF  THIS  SOFTWARE,  EVEN  IF ADVISED  OF  THE    */\n/*    POSSIBILITY OF SUCH DAMAGE.                                    */\n/*                                                                   */\n/* The views and conclusions contained in the software and           */\n/* documentation are those of the authors and should not be          */\n/* interpreted as representing official policies, either expressed   */\n/* or implied, of The University of Texas at Austin.                 */\n/*********************************************************************/\n\n#ifndef COMMON_LINUX_H\n#define COMMON_LINUX_H\n\n#ifndef ASSEMBLER\n\n#include <syscall.h>\n\nextern long int syscall (long int __sysno, ...);\n\n#ifndef MPOL_PREFERRED\n#define MPOL_PREFERRED 1\n#endif\n\n#ifndef MPOL_INTERLEAVE\n#define MPOL_INTERLEAVE 3\n#endif\n\n#if defined(ARCH_IA64) && defined(__ECC)\n#ifndef __NR_mbind\n#define __NR_mbind\t\t\t1259\n#endif\n#ifndef __NR_get_mempolicy\n#define __NR_get_mempolicy\t\t1260\n#endif\n#ifndef __NR_set_mempolicy\n#define __NR_set_mempolicy\t\t1261\n#endif\n#endif\n\n\n\nstatic inline int my_mbind(void *addr, unsigned long len, int mode,\n\t\t\t   unsigned long *nodemask, unsigned long maxnode,\n\t\t\t   unsigned flags) {\n#if defined (__LSB_VERSION__) || defined(ARCH_ZARCH)\n// So far,  LSB (Linux Standard Base) don't support syscall().\n// https://lsbbugs.linuxfoundation.org/show_bug.cgi?id=3482\n        return 0;\n#else\n//Fixed randomly SEGFAULT when nodemask==NULL with above Linux 2.6.34\n//\tunsigned long null_nodemask=0;\n\treturn syscall(SYS_mbind, addr, len, mode, nodemask, maxnode, flags);\n#endif\n}\n\nstatic inline int my_set_mempolicy(int mode, const unsigned long *addr, unsigned long flag) {\n#if defined (__LSB_VERSION__) || defined(ARCH_ZARCH)\n// So far,  LSB (Linux Standard Base) don't support syscall().\n// https://lsbbugs.linuxfoundation.org/show_bug.cgi?id=3482\n  return 0;\n#else\n  return syscall(SYS_set_mempolicy, mode, addr, flag);\n#endif\n}\n\nstatic inline int my_gettid(void) {\n#ifdef SYS_gettid\nreturn syscall(SYS_gettid);\n#else\nreturn getpid();\n#endif\n}\n\n#endif\n#endif\n"
        },
        {
          "name": "common_loongarch64.h",
          "type": "blob",
          "size": 9.4833984375,
          "content": "/*****************************************************************************\nCopyright (c) 2011-2020, The OpenBLAS Project\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   1. Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n\n   2. Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in\n      the documentation and/or other materials provided with the\n      distribution.\n   3. Neither the name of the OpenBLAS project nor the names of\n      its contributors may be used to endorse or promote products\n      derived from this software without specific prior written\n      permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\nUSE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n**********************************************************************************/\n\n/*********************************************************************/\n/* Copyright 2009, 2010 The University of Texas at Austin.           */\n/* All rights reserved.                                              */\n/*                                                                   */\n/* Redistribution and use in source and binary forms, with or        */\n/* without modification, are permitted provided that the following   */\n/* conditions are met:                                               */\n/*                                                                   */\n/*   1. Redistributions of source code must retain the above         */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer.                                                  */\n/*                                                                   */\n/*   2. Redistributions in binary form must reproduce the above      */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer in the documentation and/or other materials       */\n/*      provided with the distribution.                              */\n/*                                                                   */\n/*    THIS  SOFTWARE IS PROVIDED  BY THE  UNIVERSITY OF  TEXAS AT    */\n/*    AUSTIN  ``AS IS''  AND ANY  EXPRESS OR  IMPLIED WARRANTIES,    */\n/*    INCLUDING, BUT  NOT LIMITED  TO, THE IMPLIED  WARRANTIES OF    */\n/*    MERCHANTABILITY  AND FITNESS FOR  A PARTICULAR  PURPOSE ARE    */\n/*    DISCLAIMED.  IN  NO EVENT SHALL THE UNIVERSITY  OF TEXAS AT    */\n/*    AUSTIN OR CONTRIBUTORS BE  LIABLE FOR ANY DIRECT, INDIRECT,    */\n/*    INCIDENTAL,  SPECIAL, EXEMPLARY,  OR  CONSEQUENTIAL DAMAGES    */\n/*    (INCLUDING, BUT  NOT LIMITED TO,  PROCUREMENT OF SUBSTITUTE    */\n/*    GOODS  OR  SERVICES; LOSS  OF  USE,  DATA,  OR PROFITS;  OR    */\n/*    BUSINESS INTERRUPTION) HOWEVER CAUSED  AND ON ANY THEORY OF    */\n/*    LIABILITY, WHETHER  IN CONTRACT, STRICT  LIABILITY, OR TORT    */\n/*    (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY WAY OUT    */\n/*    OF  THE  USE OF  THIS  SOFTWARE,  EVEN  IF ADVISED  OF  THE    */\n/*    POSSIBILITY OF SUCH DAMAGE.                                    */\n/*                                                                   */\n/* The views and conclusions contained in the software and           */\n/* documentation are those of the authors and should not be          */\n/* interpreted as representing official policies, either expressed   */\n/* or implied, of The University of Texas at Austin.                 */\n/*********************************************************************/\n\n#ifndef COMMON_LOONGARCH64\n#define COMMON_LOONGARCH64\n\n#define MB  __sync_synchronize()\n#define WMB __sync_synchronize()\n#define RMB __sync_synchronize()\n\n#ifndef ASSEMBLER\n\nstatic inline int blas_quickdivide(blasint x, blasint y){\n  return x / y;\n}\n\n#ifndef NO_AFFINITY\nstatic inline int WhereAmI(void){\n  int ret = 0, counter = 0;\n  __asm__ volatile (\n    \"rdtimel.w  %[counter],   %[id]\"\n    : [id]\"=r\"(ret), [counter]\"=r\"(counter)\n    :\n    : \"memory\"\n  );\n  return ret;\n}\n#endif\n\nstatic inline int get_cpu_model(char *model_name) {\n  FILE *cpuinfo_file = fopen(\"/proc/cpuinfo\", \"r\");\n  if (!cpuinfo_file) {\n    return 0;\n  }\n  char line[1024];\n  while (fgets(line, sizeof(line), cpuinfo_file)) {\n    if (strstr(line, \"model name\")) {\n      char *token = strtok(line, \":\");\n      token = strtok(NULL, \":\");\n      while (*token == ' ')\n        token++;\n      char *end = token + strlen(token) - 1;\n      while (end > token && (*end == '\\n' || *end == '\\r')) {\n        *end = '\\0';\n        end--;\n      }\n      strcpy(model_name, token);\n      fclose(cpuinfo_file);\n      return 1;\n    }\n  }\n  fclose(cpuinfo_file);\n  return 0;\n}\n\n#ifdef DOUBLE\n#define GET_IMAGE(res)  __asm__ __volatile__(\"fmov.d %0, $f2\" : \"=f\"(res)  : : \"memory\")\n#else\n#define GET_IMAGE(res)  __asm__ __volatile__(\"fmov.s %0, $f2\" : \"=f\"(res)  : : \"memory\")\n#endif\n\n#define GET_IMAGE_CANCEL\n\n#else\n\n#ifdef DOUBLE\n#define LD      fld.d\n#define ST      fst.d\n#define MADD    fmadd.d\n#define NMADD   fnmadd.d\n#define MSUB    fmsub.d\n#define NMSUB   fnmsub.d\n#define ADD     fadd.d\n#define SUB     fsub.d\n#define MUL     fmul.d\n#define MOV     fmov.d\n#define CMOVT   fsel\n#define MTC     movgr2fr.d\n#define MTG     movfr2gr.d\n#define FABS    fabs.d\n#define FMIN    fmin.d\n#define FMINA   fmina.d\n#define FMAX    fmax.d\n#define FMAXA   fmaxa.d\n#define CMPEQ   fcmp.ceq.d\n#define CMPLE   fcmp.cle.d\n#define CMPLT   fcmp.clt.d\n#define NEG     fneg.d\n#define FFINT   ffint.d.l\n\n#define XVFSUB  xvfsub.d\n#define XVFADD  xvfadd.d\n#define XVFMUL  xvfmul.d\n#define XVFMADD xvfmadd.d\n#define XVFMIN  xvfmin.d\n#define XVFMINA xvfmina.d\n#define XVFMAX  xvfmax.d\n#define XVFMAXA xvfmaxa.d\n#define XVCMPEQ xvfcmp.ceq.d\n#define XVCMPLE xvfcmp.cle.d\n#define XVCMPLT xvfcmp.clt.d\n#define XVMUL   xvfmul.d\n#define XVMSUB  xvfmsub.d\n#define XVNMSUB xvfnmsub.d\n\n#define VFSUB  vfsub.d\n#define VFADD  vfadd.d\n#define VFMUL  vfmul.d\n#define VFMADD vfmadd.d\n#define VFMIN  vfmin.d\n#define VFMINA vfmina.d\n#define VFMAX  vfmax.d\n#define VFMAXA vfmaxa.d\n#define VCMPEQ vfcmp.ceq.d\n#define VCMPLE vfcmp.cle.d\n#define VCMPLT vfcmp.clt.d\n#define VMUL   vfmul.d\n#define VMSUB  vfmsub.d\n#define VNMSUB vfnmsub.d\n\n#else\n\n#define LD      fld.s\n#define ST      fst.s\n#define MADD    fmadd.s\n#define NMADD   fnmadd.s\n#define MSUB    fmsub.s\n#define NMSUB   fnmsub.s\n#define ADD     fadd.s\n#define SUB     fsub.s\n#define MUL     fmul.s\n#define MOV     fmov.s\n#define CMOVT   fsel\n#define MTC     movgr2fr.w\n#define MTG     movfr2gr.s\n#define FABS    fabs.s\n#define FMIN    fmin.s\n#define FMINA   fmina.s\n#define FMAX    fmax.s\n#define FMAXA   fmaxa.s\n#define CMPEQ   fcmp.ceq.s\n#define CMPLE   fcmp.cle.s\n#define CMPLT   fcmp.clt.s\n#define NEG     fneg.s\n#define FFINT   ffint.s.l\n\n#define XVFSUB  xvfsub.s\n#define XVFADD  xvfadd.s\n#define XVFMUL  xvfmul.s\n#define XVFMADD xvfmadd.s\n#define XVFMIN  xvfmin.s\n#define XVFMINA xvfmina.s\n#define XVFMAX  xvfmax.s\n#define XVFMAXA xvfmaxa.s\n#define XVCMPEQ xvfcmp.ceq.s\n#define XVCMPLE xvfcmp.cle.s\n#define XVCMPLT xvfcmp.clt.s\n#define XVMUL   xvfmul.s\n#define XVMSUB  xvfmsub.s\n#define XVNMSUB xvfnmsub.s\n\n#define VFSUB  vfsub.s\n#define VFADD  vfadd.s\n#define VFMUL  vfmul.s\n#define VFMADD vfmadd.s\n#define VFMIN  vfmin.s\n#define VFMINA vfmina.s\n#define VFMAX  vfmax.s\n#define VFMAXA vfmaxa.s\n#define VCMPEQ vfcmp.ceq.s\n#define VCMPLE vfcmp.cle.s\n#define VCMPLT vfcmp.clt.s\n#define VMUL   vfmul.s\n#define VMSUB  vfmsub.s\n#define VNMSUB vfnmsub.s\n\n#endif /* defined(DOUBLE) */\n\n#if defined(__64BIT__) && defined(USE64BITINT)\n#define LDINT   ld.d\n#define LDARG   ld.d\n#define SDARG   st.d\n#elif defined(__64BIT__) && !defined(USE64BITINT)\n#define LDINT   ld.w\n#define LDARG   ld.d\n#define SDARG   st.d\n#else\n#define LDINT   ld.w\n#define LDARG   ld.w\n#define SDARG   st.w\n#endif\n\n\n#ifndef F_INTERFACE\n#define REALNAME ASMNAME\n#else\n#define REALNAME ASMFNAME\n#endif /* defined(F_INTERFACE) */\n\n#if defined(ASSEMBLER) && !defined(NEEDPARAM)\n\n#define PROLOGUE \\\n    .text ;\\\n    .align 5 ;\\\n    .globl  REALNAME ;\\\n    .type   REALNAME, @function ;\\\nREALNAME: ;\\\n\n#if defined(__linux__) && defined(__ELF__)\n#define GNUSTACK .section .note.GNU-stack,\"\",@progbits\n#else\n#define GNUSTACK\n#endif /* defined(__linux__) && defined(__ELF__) */\n\n#ifdef __clang__\n#define EPILOGUE .end\n#else\n#define EPILOGUE      \\\n    .end    REALNAME ;\\\n    GNUSTACK\n#endif\n\n#define PROFCODE\n\n#define MOVT(dst, src, cc)  \\\n    bceqz  cc,   1f;        \\\n    add.d dst,  src,  $r0;  \\\n    1:\n\n#endif /* defined(ASSEMBLER) && !defined(NEEDPARAM) */\n\n#endif /* defined(ASSEMBLER) */\n\n#define SEEK_ADDRESS\n\n#define BUFFER_SIZE     ( 32 << 20)\n\n#define PAGESIZE        (16UL << 10)\n#define FIXED_PAGESIZE  (16UL << 10)\n#define HUGE_PAGESIZE   ( 2 << 20)\n\n#define BASE_ADDRESS (START_ADDRESS - BUFFER_SIZE * MAX_CPU_NUMBER)\n\n#ifndef MAP_ANONYMOUS\n#define MAP_ANONYMOUS MAP_ANON\n#endif\n\n#endif\n"
        },
        {
          "name": "common_macro.h",
          "type": "blob",
          "size": 102.90234375,
          "content": "/*********************************************************************/\n/* Copyright 2009, 2010 The University of Texas at Austin.           */\n/* All rights reserved.                                              */\n/*                                                                   */\n/* Redistribution and use in source and binary forms, with or        */\n/* without modification, are permitted provided that the following   */\n/* conditions are met:                                               */\n/*                                                                   */\n/*   1. Redistributions of source code must retain the above         */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer.                                                  */\n/*                                                                   */\n/*   2. Redistributions in binary form must reproduce the above      */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer in the documentation and/or other materials       */\n/*      provided with the distribution.                              */\n/*                                                                   */\n/*    THIS  SOFTWARE IS PROVIDED  BY THE  UNIVERSITY OF  TEXAS AT    */\n/*    AUSTIN  ``AS IS''  AND ANY  EXPRESS OR  IMPLIED WARRANTIES,    */\n/*    INCLUDING, BUT  NOT LIMITED  TO, THE IMPLIED  WARRANTIES OF    */\n/*    MERCHANTABILITY  AND FITNESS FOR  A PARTICULAR  PURPOSE ARE    */\n/*    DISCLAIMED.  IN  NO EVENT SHALL THE UNIVERSITY  OF TEXAS AT    */\n/*    AUSTIN OR CONTRIBUTORS BE  LIABLE FOR ANY DIRECT, INDIRECT,    */\n/*    INCIDENTAL,  SPECIAL, EXEMPLARY,  OR  CONSEQUENTIAL DAMAGES    */\n/*    (INCLUDING, BUT  NOT LIMITED TO,  PROCUREMENT OF SUBSTITUTE    */\n/*    GOODS  OR  SERVICES; LOSS  OF  USE,  DATA,  OR PROFITS;  OR    */\n/*    BUSINESS INTERRUPTION) HOWEVER CAUSED  AND ON ANY THEORY OF    */\n/*    LIABILITY, WHETHER  IN CONTRACT, STRICT  LIABILITY, OR TORT    */\n/*    (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY WAY OUT    */\n/*    OF  THE  USE OF  THIS  SOFTWARE,  EVEN  IF ADVISED  OF  THE    */\n/*    POSSIBILITY OF SUCH DAMAGE.                                    */\n/*                                                                   */\n/* The views and conclusions contained in the software and           */\n/* documentation are those of the authors and should not be          */\n/* interpreted as representing official policies, either expressed   */\n/* or implied, of The University of Texas at Austin.                 */\n/*********************************************************************/\n\n#ifndef COMMON_MACRO\n#define COMMON_MACRO\n\n#include \"common_sb.h\"\n#include \"common_s.h\"\n#include \"common_d.h\"\n#include \"common_q.h\"\n\n#include \"common_c.h\"\n#include \"common_z.h\"\n#include \"common_x.h\"\n\n#ifndef COMPLEX\n#ifdef XDOUBLE\n\n#define\tAMAX_K\t\t\tQAMAX_K\n#define\tAMIN_K\t\t\tQAMIN_K\n#define\tMAX_K\t\t\tQMAX_K\n#define\tMIN_K\t\t\tQMIN_K\n#define\tIAMAX_K\t\t\tIQAMAX_K\n#define\tIAMIN_K\t\t\tIQAMIN_K\n#define\tIMAX_K\t\t\tIQMAX_K\n#define\tIMIN_K\t\t\tIQMIN_K\n#define\tASUM_K\t\t\tQASUM_K\n#define\tAXPYU_K\t\t\tQAXPYU_K\n#define\tAXPYC_K\t\t\tQAXPYC_K\n#define\tCOPY_K\t\t\tQCOPY_K\n#define\tDOTU_K\t\t\tQDOTU_K\n#define\tDOTC_K\t\t\tQDOTC_K\n#define\tNRM2_K\t\t\tQNRM2_K\n#define\tSCAL_K\t\t\tQSCAL_K\n#define\tSUM_K\t\t\tQSUM_K\n#define\tSWAP_K\t\t\tQSWAP_K\n#define\tROT_K\t\t\tQROT_K\n\n#define\tGEMV_N\t\t\tQGEMV_N\n#define\tGEMV_T\t\t\tQGEMV_T\n#define\tGEMV_R\t\t\tQGEMV_R\n#define\tGEMV_C\t\t\tQGEMV_C\n#define\tGEMV_O\t\t\tQGEMV_O\n#define\tGEMV_U\t\t\tQGEMV_U\n#define\tGEMV_S\t\t\tQGEMV_S\n#define\tGEMV_D\t\t\tQGEMV_D\n\n#define\tGERU_K\t\t\tQGERU_K\n#define\tGERC_K\t\t\tQGERC_K\n#define\tGERV_K\t\t\tQGERV_K\n#define\tGERD_K\t\t\tQGERD_K\n\n#define\tSYMV_U\t\t\tQSYMV_U\n#define\tSYMV_L\t\t\tQSYMV_L\n\n#define\tSYMV_THREAD_U\t\tQSYMV_THREAD_U\n#define\tSYMV_THREAD_L\t\tQSYMV_THREAD_L\n\n#define\tGEMM_ONCOPY\t\tQGEMM_ONCOPY\n#define\tGEMM_OTCOPY\t\tQGEMM_OTCOPY\n#define\tGEMM_INCOPY\t\tQGEMM_INCOPY\n#define\tGEMM_ITCOPY\t\tQGEMM_ITCOPY\n\n#ifdef UNIT\n\n#define\tTRMM_OUNCOPY\t\tQTRMM_OUNUCOPY\n#define\tTRMM_OUTCOPY\t\tQTRMM_OUTUCOPY\n#define\tTRMM_OLNCOPY\t\tQTRMM_OLNUCOPY\n#define\tTRMM_OLTCOPY\t\tQTRMM_OLTUCOPY\n#define\tTRSM_OUNCOPY\t\tQTRSM_OUNUCOPY\n#define\tTRSM_OUTCOPY\t\tQTRSM_OUTUCOPY\n#define\tTRSM_OLNCOPY\t\tQTRSM_OLNUCOPY\n#define\tTRSM_OLTCOPY\t\tQTRSM_OLTUCOPY\n\n#define\tTRMM_IUNCOPY\t\tQTRMM_IUNUCOPY\n#define\tTRMM_IUTCOPY\t\tQTRMM_IUTUCOPY\n#define\tTRMM_ILNCOPY\t\tQTRMM_ILNUCOPY\n#define\tTRMM_ILTCOPY\t\tQTRMM_ILTUCOPY\n#define\tTRSM_IUNCOPY\t\tQTRSM_IUNUCOPY\n#define\tTRSM_IUTCOPY\t\tQTRSM_IUTUCOPY\n#define\tTRSM_ILNCOPY\t\tQTRSM_ILNUCOPY\n#define\tTRSM_ILTCOPY\t\tQTRSM_ILTUCOPY\n\n#else\n\n#define\tTRMM_OUNCOPY\t\tQTRMM_OUNNCOPY\n#define\tTRMM_OUTCOPY\t\tQTRMM_OUTNCOPY\n#define\tTRMM_OLNCOPY\t\tQTRMM_OLNNCOPY\n#define\tTRMM_OLTCOPY\t\tQTRMM_OLTNCOPY\n#define\tTRSM_OUNCOPY\t\tQTRSM_OUNNCOPY\n#define\tTRSM_OUTCOPY\t\tQTRSM_OUTNCOPY\n#define\tTRSM_OLNCOPY\t\tQTRSM_OLNNCOPY\n#define\tTRSM_OLTCOPY\t\tQTRSM_OLTNCOPY\n\n#define\tTRMM_IUNCOPY\t\tQTRMM_IUNNCOPY\n#define\tTRMM_IUTCOPY\t\tQTRMM_IUTNCOPY\n#define\tTRMM_ILNCOPY\t\tQTRMM_ILNNCOPY\n#define\tTRMM_ILTCOPY\t\tQTRMM_ILTNCOPY\n#define\tTRSM_IUNCOPY\t\tQTRSM_IUNNCOPY\n#define\tTRSM_IUTCOPY\t\tQTRSM_IUTNCOPY\n#define\tTRSM_ILNCOPY\t\tQTRSM_ILNNCOPY\n#define\tTRSM_ILTCOPY\t\tQTRSM_ILTNCOPY\n\n#endif\n\n#define\tGEMM_BETA\t\tQGEMM_BETA\n\n#define\tGEMM_KERNEL_N\t\tQGEMM_KERNEL\n#define\tGEMM_KERNEL_L\t\tQGEMM_KERNEL\n#define\tGEMM_KERNEL_R\t\tQGEMM_KERNEL\n#define\tGEMM_KERNEL_B\t\tQGEMM_KERNEL\n\n#define\tTRMM_KERNEL_LN\t\tQTRMM_KERNEL_LN\n#define\tTRMM_KERNEL_LT\t\tQTRMM_KERNEL_LT\n#define\tTRMM_KERNEL_LR\t\tQTRMM_KERNEL_LN\n#define\tTRMM_KERNEL_LC\t\tQTRMM_KERNEL_LT\n#define\tTRMM_KERNEL_RN\t\tQTRMM_KERNEL_RN\n#define\tTRMM_KERNEL_RT\t\tQTRMM_KERNEL_RT\n#define\tTRMM_KERNEL_RR\t\tQTRMM_KERNEL_RN\n#define\tTRMM_KERNEL_RC\t\tQTRMM_KERNEL_RT\n\n#define\tTRSM_KERNEL_LN\t\tQTRSM_KERNEL_LN\n#define\tTRSM_KERNEL_LT\t\tQTRSM_KERNEL_LT\n#define\tTRSM_KERNEL_LR\t\tQTRSM_KERNEL_LN\n#define\tTRSM_KERNEL_LC\t\tQTRSM_KERNEL_LT\n#define\tTRSM_KERNEL_RN\t\tQTRSM_KERNEL_RN\n#define\tTRSM_KERNEL_RT\t\tQTRSM_KERNEL_RT\n#define\tTRSM_KERNEL_RR\t\tQTRSM_KERNEL_RN\n#define\tTRSM_KERNEL_RC\t\tQTRSM_KERNEL_RT\n\n#define SYMM_IUTCOPY\t\tQSYMM_IUTCOPY\n#define SYMM_ILTCOPY\t\tQSYMM_ILTCOPY\n#define SYMM_OUTCOPY\t\tQSYMM_OUTCOPY\n#define SYMM_OLTCOPY\t\tQSYMM_OLTCOPY\n\n#define\tGEMM_NN\t\t\tQGEMM_NN\n#define\tGEMM_CN\t\t\tQGEMM_TN\n#define\tGEMM_TN\t\t\tQGEMM_TN\n#define\tGEMM_NC\t\t\tQGEMM_NT\n#define\tGEMM_NT\t\t\tQGEMM_NT\n#define\tGEMM_CC\t\t\tQGEMM_TT\n#define\tGEMM_CT\t\t\tQGEMM_TT\n#define\tGEMM_TC\t\t\tQGEMM_TT\n#define\tGEMM_TT\t\t\tQGEMM_TT\n#define\tGEMM_NR\t\t\tQGEMM_NN\n#define\tGEMM_TR\t\t\tQGEMM_TN\n#define\tGEMM_CR\t\t\tQGEMM_TN\n#define\tGEMM_RN\t\t\tQGEMM_NN\n#define\tGEMM_RT\t\t\tQGEMM_NT\n#define\tGEMM_RC\t\t\tQGEMM_NT\n#define\tGEMM_RR\t\t\tQGEMM_NN\n\n#define\tSYMM_LU\t\t\tQSYMM_LU\n#define\tSYMM_LL\t\t\tQSYMM_LL\n#define\tSYMM_RU\t\t\tQSYMM_RU\n#define\tSYMM_RL\t\t\tQSYMM_RL\n\n#define\tHEMM_LU\t\t\tQHEMM_LU\n#define\tHEMM_LL\t\t\tQHEMM_LL\n#define\tHEMM_RU\t\t\tQHEMM_RU\n#define\tHEMM_RL\t\t\tQHEMM_RL\n\n#define\tSYRK_UN\t\t\tQSYRK_UN\n#define\tSYRK_UT\t\t\tQSYRK_UT\n#define\tSYRK_LN\t\t\tQSYRK_LN\n#define\tSYRK_LT\t\t\tQSYRK_LT\n#define\tSYRK_UR\t\t\tQSYRK_UN\n#define\tSYRK_UC\t\t\tQSYRK_UT\n#define\tSYRK_LR\t\t\tQSYRK_LN\n#define\tSYRK_LC\t\t\tQSYRK_LT\n\n#define\tSYRK_KERNEL_U\t\tQSYRK_KERNEL_U\n#define\tSYRK_KERNEL_L\t\tQSYRK_KERNEL_L\n\n#define\tHERK_UN\t\t\tQSYRK_UN\n#define\tHERK_LN\t\t\tQSYRK_LN\n#define\tHERK_UC\t\t\tQSYRK_UT\n#define\tHERK_LC\t\t\tQSYRK_LT\n\n#define\tHER2K_UN\t\tQSYR2K_UN\n#define\tHER2K_LN\t\tQSYR2K_LN\n#define\tHER2K_UC\t\tQSYR2K_UT\n#define\tHER2K_LC\t\tQSYR2K_LT\n\n#define\tSYR2K_UN\t\tQSYR2K_UN\n#define\tSYR2K_UT\t\tQSYR2K_UT\n#define\tSYR2K_LN\t\tQSYR2K_LN\n#define\tSYR2K_LT\t\tQSYR2K_LT\n#define\tSYR2K_UR\t\tQSYR2K_UN\n#define\tSYR2K_UC\t\tQSYR2K_UT\n#define\tSYR2K_LR\t\tQSYR2K_LN\n#define\tSYR2K_LC\t\tQSYR2K_LT\n\n#define\tSYR2K_KERNEL_U\t\tQSYR2K_KERNEL_U\n#define\tSYR2K_KERNEL_L\t\tQSYR2K_KERNEL_L\n\n#define\tTRMM_LNUU\t\tQTRMM_LNUU\n#define\tTRMM_LNUN\t\tQTRMM_LNUN\n#define\tTRMM_LNLU\t\tQTRMM_LNLU\n#define\tTRMM_LNLN\t\tQTRMM_LNLN\n#define\tTRMM_LTUU\t\tQTRMM_LTUU\n#define\tTRMM_LTUN\t\tQTRMM_LTUN\n#define\tTRMM_LTLU\t\tQTRMM_LTLU\n#define\tTRMM_LTLN\t\tQTRMM_LTLN\n#define\tTRMM_LRUU\t\tQTRMM_LNUU\n#define\tTRMM_LRUN\t\tQTRMM_LNUN\n#define\tTRMM_LRLU\t\tQTRMM_LNLU\n#define\tTRMM_LRLN\t\tQTRMM_LNLN\n#define\tTRMM_LCUU\t\tQTRMM_LTUU\n#define\tTRMM_LCUN\t\tQTRMM_LTUN\n#define\tTRMM_LCLU\t\tQTRMM_LTLU\n#define\tTRMM_LCLN\t\tQTRMM_LTLN\n#define\tTRMM_RNUU\t\tQTRMM_RNUU\n#define\tTRMM_RNUN\t\tQTRMM_RNUN\n#define\tTRMM_RNLU\t\tQTRMM_RNLU\n#define\tTRMM_RNLN\t\tQTRMM_RNLN\n#define\tTRMM_RTUU\t\tQTRMM_RTUU\n#define\tTRMM_RTUN\t\tQTRMM_RTUN\n#define\tTRMM_RTLU\t\tQTRMM_RTLU\n#define\tTRMM_RTLN\t\tQTRMM_RTLN\n#define\tTRMM_RRUU\t\tQTRMM_RNUU\n#define\tTRMM_RRUN\t\tQTRMM_RNUN\n#define\tTRMM_RRLU\t\tQTRMM_RNLU\n#define\tTRMM_RRLN\t\tQTRMM_RNLN\n#define\tTRMM_RCUU\t\tQTRMM_RTUU\n#define\tTRMM_RCUN\t\tQTRMM_RTUN\n#define\tTRMM_RCLU\t\tQTRMM_RTLU\n#define\tTRMM_RCLN\t\tQTRMM_RTLN\n\n#define\tTRSM_LNUU\t\tQTRSM_LNUU\n#define\tTRSM_LNUN\t\tQTRSM_LNUN\n#define\tTRSM_LNLU\t\tQTRSM_LNLU\n#define\tTRSM_LNLN\t\tQTRSM_LNLN\n#define\tTRSM_LTUU\t\tQTRSM_LTUU\n#define\tTRSM_LTUN\t\tQTRSM_LTUN\n#define\tTRSM_LTLU\t\tQTRSM_LTLU\n#define\tTRSM_LTLN\t\tQTRSM_LTLN\n#define\tTRSM_LRUU\t\tQTRSM_LNUU\n#define\tTRSM_LRUN\t\tQTRSM_LNUN\n#define\tTRSM_LRLU\t\tQTRSM_LNLU\n#define\tTRSM_LRLN\t\tQTRSM_LNLN\n#define\tTRSM_LCUU\t\tQTRSM_LTUU\n#define\tTRSM_LCUN\t\tQTRSM_LTUN\n#define\tTRSM_LCLU\t\tQTRSM_LTLU\n#define\tTRSM_LCLN\t\tQTRSM_LTLN\n#define\tTRSM_RNUU\t\tQTRSM_RNUU\n#define\tTRSM_RNUN\t\tQTRSM_RNUN\n#define\tTRSM_RNLU\t\tQTRSM_RNLU\n#define\tTRSM_RNLN\t\tQTRSM_RNLN\n#define\tTRSM_RTUU\t\tQTRSM_RTUU\n#define\tTRSM_RTUN\t\tQTRSM_RTUN\n#define\tTRSM_RTLU\t\tQTRSM_RTLU\n#define\tTRSM_RTLN\t\tQTRSM_RTLN\n#define\tTRSM_RRUU\t\tQTRSM_RNUU\n#define\tTRSM_RRUN\t\tQTRSM_RNUN\n#define\tTRSM_RRLU\t\tQTRSM_RNLU\n#define\tTRSM_RRLN\t\tQTRSM_RNLN\n#define\tTRSM_RCUU\t\tQTRSM_RTUU\n#define\tTRSM_RCUN\t\tQTRSM_RTUN\n#define\tTRSM_RCLU\t\tQTRSM_RTLU\n#define\tTRSM_RCLN\t\tQTRSM_RTLN\n\n#define\tGEMM_THREAD_NN\t\tQGEMM_THREAD_NN\n#define\tGEMM_THREAD_CN\t\tQGEMM_THREAD_TN\n#define\tGEMM_THREAD_TN\t\tQGEMM_THREAD_TN\n#define\tGEMM_THREAD_NC\t\tQGEMM_THREAD_NT\n#define\tGEMM_THREAD_NT\t\tQGEMM_THREAD_NT\n#define\tGEMM_THREAD_CC\t\tQGEMM_THREAD_TT\n#define\tGEMM_THREAD_CT\t\tQGEMM_THREAD_TT\n#define\tGEMM_THREAD_TC\t\tQGEMM_THREAD_TT\n#define\tGEMM_THREAD_TT\t\tQGEMM_THREAD_TT\n#define\tGEMM_THREAD_NR\t\tQGEMM_THREAD_NN\n#define\tGEMM_THREAD_TR\t\tQGEMM_THREAD_TN\n#define\tGEMM_THREAD_CR\t\tQGEMM_THREAD_TN\n#define\tGEMM_THREAD_RN\t\tQGEMM_THREAD_NN\n#define\tGEMM_THREAD_RT\t\tQGEMM_THREAD_NT\n#define\tGEMM_THREAD_RC\t\tQGEMM_THREAD_NT\n#define\tGEMM_THREAD_RR\t\tQGEMM_THREAD_NN\n\n#define\tSYMM_THREAD_LU\t\tQSYMM_THREAD_LU\n#define\tSYMM_THREAD_LL\t\tQSYMM_THREAD_LL\n#define\tSYMM_THREAD_RU\t\tQSYMM_THREAD_RU\n#define\tSYMM_THREAD_RL\t\tQSYMM_THREAD_RL\n\n#define\tHEMM_THREAD_LU\t\tQHEMM_THREAD_LU\n#define\tHEMM_THREAD_LL\t\tQHEMM_THREAD_LL\n#define\tHEMM_THREAD_RU\t\tQHEMM_THREAD_RU\n#define\tHEMM_THREAD_RL\t\tQHEMM_THREAD_RL\n\n#define\tSYRK_THREAD_UN\t\tQSYRK_THREAD_UN\n#define\tSYRK_THREAD_UT\t\tQSYRK_THREAD_UT\n#define\tSYRK_THREAD_LN\t\tQSYRK_THREAD_LN\n#define\tSYRK_THREAD_LT\t\tQSYRK_THREAD_LT\n#define\tSYRK_THREAD_UR\t\tQSYRK_THREAD_UR\n#define\tSYRK_THREAD_UC\t\tQSYRK_THREAD_UC\n#define\tSYRK_THREAD_LR\t\tQSYRK_THREAD_LN\n#define\tSYRK_THREAD_LC\t\tQSYRK_THREAD_LT\n\n#define\tHERK_THREAD_UN\t\tQSYRK_THREAD_UN\n#define\tHERK_THREAD_UT\t\tQSYRK_THREAD_UT\n#define\tHERK_THREAD_LN\t\tQSYRK_THREAD_LN\n#define\tHERK_THREAD_LT\t\tQSYRK_THREAD_LT\n#define\tHERK_THREAD_UR\t\tQSYRK_THREAD_UR\n#define\tHERK_THREAD_UC\t\tQSYRK_THREAD_UC\n#define\tHERK_THREAD_LR\t\tQSYRK_THREAD_LN\n#define\tHERK_THREAD_LC\t\tQSYRK_THREAD_LT\n\n#elif defined(DOUBLE)\n\n#define\tAMAX_K\t\t\tDAMAX_K\n#define\tAMIN_K\t\t\tDAMIN_K\n#define\tMAX_K\t\t\tDMAX_K\n#define\tMIN_K\t\t\tDMIN_K\n#define\tIAMAX_K\t\t\tIDAMAX_K\n#define\tIAMIN_K\t\t\tIDAMIN_K\n#define\tIMAX_K\t\t\tIDMAX_K\n#define\tIMIN_K\t\t\tIDMIN_K\n#define\tASUM_K\t\t\tDASUM_K\n#define\tAXPYU_K\t\t\tDAXPYU_K\n#define\tAXPYC_K\t\t\tDAXPYC_K\n#define\tCOPY_K\t\t\tDCOPY_K\n#define\tDOTU_K\t\t\tDDOTU_K\n#define\tDOTC_K\t\t\tDDOTC_K\n#define\tNRM2_K\t\t\tDNRM2_K\n#define\tSCAL_K\t\t\tDSCAL_K\n#define\tSUM_K\t\t\tDSUM_K\n#define\tSWAP_K\t\t\tDSWAP_K\n#define\tROT_K\t\t\tDROT_K\n\n#define\tGEMV_N\t\t\tDGEMV_N\n#define\tGEMV_T\t\t\tDGEMV_T\n#define\tGEMV_R\t\t\tDGEMV_R\n#define\tGEMV_C\t\t\tDGEMV_C\n#define\tGEMV_O\t\t\tDGEMV_O\n#define\tGEMV_U\t\t\tDGEMV_U\n#define\tGEMV_S\t\t\tDGEMV_S\n#define\tGEMV_D\t\t\tDGEMV_D\n\n#define\tGERU_K\t\t\tDGERU_K\n#define\tGERC_K\t\t\tDGERC_K\n#define\tGERV_K\t\t\tDGERV_K\n#define\tGERD_K\t\t\tDGERD_K\n\n#define\tSYMV_U\t\t\tDSYMV_U\n#define\tSYMV_L\t\t\tDSYMV_L\n\n#define\tSYMV_THREAD_U\t\tDSYMV_THREAD_U\n#define\tSYMV_THREAD_L\t\tDSYMV_THREAD_L\n\n#define\tGEMM_ONCOPY\t\tDGEMM_ONCOPY\n#define\tGEMM_OTCOPY\t\tDGEMM_OTCOPY\n#define\tGEMM_INCOPY\t\tDGEMM_INCOPY\n#define\tGEMM_ITCOPY\t\tDGEMM_ITCOPY\n\n#ifdef UNIT\n\n#define\tTRMM_OUNCOPY\t\tDTRMM_OUNUCOPY\n#define\tTRMM_OUTCOPY\t\tDTRMM_OUTUCOPY\n#define\tTRMM_OLNCOPY\t\tDTRMM_OLNUCOPY\n#define\tTRMM_OLTCOPY\t\tDTRMM_OLTUCOPY\n#define\tTRSM_OUNCOPY\t\tDTRSM_OUNUCOPY\n#define\tTRSM_OUTCOPY\t\tDTRSM_OUTUCOPY\n#define\tTRSM_OLNCOPY\t\tDTRSM_OLNUCOPY\n#define\tTRSM_OLTCOPY\t\tDTRSM_OLTUCOPY\n\n#define\tTRMM_IUNCOPY\t\tDTRMM_IUNUCOPY\n#define\tTRMM_IUTCOPY\t\tDTRMM_IUTUCOPY\n#define\tTRMM_ILNCOPY\t\tDTRMM_ILNUCOPY\n#define\tTRMM_ILTCOPY\t\tDTRMM_ILTUCOPY\n#define\tTRSM_IUNCOPY\t\tDTRSM_IUNUCOPY\n#define\tTRSM_IUTCOPY\t\tDTRSM_IUTUCOPY\n#define\tTRSM_ILNCOPY\t\tDTRSM_ILNUCOPY\n#define\tTRSM_ILTCOPY\t\tDTRSM_ILTUCOPY\n\n#else\n\n#define\tTRMM_OUNCOPY\t\tDTRMM_OUNNCOPY\n#define\tTRMM_OUTCOPY\t\tDTRMM_OUTNCOPY\n#define\tTRMM_OLNCOPY\t\tDTRMM_OLNNCOPY\n#define\tTRMM_OLTCOPY\t\tDTRMM_OLTNCOPY\n#define\tTRSM_OUNCOPY\t\tDTRSM_OUNNCOPY\n#define\tTRSM_OUTCOPY\t\tDTRSM_OUTNCOPY\n#define\tTRSM_OLNCOPY\t\tDTRSM_OLNNCOPY\n#define\tTRSM_OLTCOPY\t\tDTRSM_OLTNCOPY\n\n#define\tTRMM_IUNCOPY\t\tDTRMM_IUNNCOPY\n#define\tTRMM_IUTCOPY\t\tDTRMM_IUTNCOPY\n#define\tTRMM_ILNCOPY\t\tDTRMM_ILNNCOPY\n#define\tTRMM_ILTCOPY\t\tDTRMM_ILTNCOPY\n#define\tTRSM_IUNCOPY\t\tDTRSM_IUNNCOPY\n#define\tTRSM_IUTCOPY\t\tDTRSM_IUTNCOPY\n#define\tTRSM_ILNCOPY\t\tDTRSM_ILNNCOPY\n#define\tTRSM_ILTCOPY\t\tDTRSM_ILTNCOPY\n\n#endif\n\n#define\tGEMM_BETA\t\tDGEMM_BETA\n\n#define\tGEMM_KERNEL_N\t\tDGEMM_KERNEL\n#define\tGEMM_KERNEL_L\t\tDGEMM_KERNEL\n#define\tGEMM_KERNEL_R\t\tDGEMM_KERNEL\n#define\tGEMM_KERNEL_B\t\tDGEMM_KERNEL\n\n#define\tTRMM_KERNEL_LN\t\tDTRMM_KERNEL_LN\n#define\tTRMM_KERNEL_LT\t\tDTRMM_KERNEL_LT\n#define\tTRMM_KERNEL_LR\t\tDTRMM_KERNEL_LN\n#define\tTRMM_KERNEL_LC\t\tDTRMM_KERNEL_LT\n#define\tTRMM_KERNEL_RN\t\tDTRMM_KERNEL_RN\n#define\tTRMM_KERNEL_RT\t\tDTRMM_KERNEL_RT\n#define\tTRMM_KERNEL_RR\t\tDTRMM_KERNEL_RN\n#define\tTRMM_KERNEL_RC\t\tDTRMM_KERNEL_RT\n\n#define\tTRSM_KERNEL_LN\t\tDTRSM_KERNEL_LN\n#define\tTRSM_KERNEL_LT\t\tDTRSM_KERNEL_LT\n#define\tTRSM_KERNEL_LR\t\tDTRSM_KERNEL_LN\n#define\tTRSM_KERNEL_LC\t\tDTRSM_KERNEL_LT\n#define\tTRSM_KERNEL_RN\t\tDTRSM_KERNEL_RN\n#define\tTRSM_KERNEL_RT\t\tDTRSM_KERNEL_RT\n#define\tTRSM_KERNEL_RR\t\tDTRSM_KERNEL_RN\n#define\tTRSM_KERNEL_RC\t\tDTRSM_KERNEL_RT\n\n#define SYMM_IUTCOPY\t\tDSYMM_IUTCOPY\n#define SYMM_ILTCOPY\t\tDSYMM_ILTCOPY\n#define SYMM_OUTCOPY\t\tDSYMM_OUTCOPY\n#define SYMM_OLTCOPY\t\tDSYMM_OLTCOPY\n\n#define\tGEMM_NN\t\t\tDGEMM_NN\n#define\tGEMM_CN\t\t\tDGEMM_TN\n#define\tGEMM_TN\t\t\tDGEMM_TN\n#define\tGEMM_NC\t\t\tDGEMM_NT\n#define\tGEMM_NT\t\t\tDGEMM_NT\n#define\tGEMM_CC\t\t\tDGEMM_TT\n#define\tGEMM_CT\t\t\tDGEMM_TT\n#define\tGEMM_TC\t\t\tDGEMM_TT\n#define\tGEMM_TT\t\t\tDGEMM_TT\n#define\tGEMM_NR\t\t\tDGEMM_NN\n#define\tGEMM_TR\t\t\tDGEMM_TN\n#define\tGEMM_CR\t\t\tDGEMM_TN\n#define\tGEMM_RN\t\t\tDGEMM_NN\n#define\tGEMM_RT\t\t\tDGEMM_NT\n#define\tGEMM_RC\t\t\tDGEMM_NT\n#define\tGEMM_RR\t\t\tDGEMM_NN\n\n#define\tSYMM_LU\t\t\tDSYMM_LU\n#define\tSYMM_LL\t\t\tDSYMM_LL\n#define\tSYMM_RU\t\t\tDSYMM_RU\n#define\tSYMM_RL\t\t\tDSYMM_RL\n\n#define\tHEMM_LU\t\t\tDHEMM_LU\n#define\tHEMM_LL\t\t\tDHEMM_LL\n#define\tHEMM_RU\t\t\tDHEMM_RU\n#define\tHEMM_RL\t\t\tDHEMM_RL\n\n#define\tSYRK_UN\t\t\tDSYRK_UN\n#define\tSYRK_UT\t\t\tDSYRK_UT\n#define\tSYRK_LN\t\t\tDSYRK_LN\n#define\tSYRK_LT\t\t\tDSYRK_LT\n#define\tSYRK_UR\t\t\tDSYRK_UN\n#define\tSYRK_UC\t\t\tDSYRK_UT\n#define\tSYRK_LR\t\t\tDSYRK_LN\n#define\tSYRK_LC\t\t\tDSYRK_LT\n\n#define\tSYRK_KERNEL_U\t\tDSYRK_KERNEL_U\n#define\tSYRK_KERNEL_L\t\tDSYRK_KERNEL_L\n\n#define\tHERK_UN\t\t\tDSYRK_UN\n#define\tHERK_LN\t\t\tDSYRK_LN\n#define\tHERK_UC\t\t\tDSYRK_UT\n#define\tHERK_LC\t\t\tDSYRK_LT\n\n#define\tHER2K_UN\t\tDSYR2K_UN\n#define\tHER2K_LN\t\tDSYR2K_LN\n#define\tHER2K_UC\t\tDSYR2K_UT\n#define\tHER2K_LC\t\tDSYR2K_LT\n\n#define\tSYR2K_UN\t\tDSYR2K_UN\n#define\tSYR2K_UT\t\tDSYR2K_UT\n#define\tSYR2K_LN\t\tDSYR2K_LN\n#define\tSYR2K_LT\t\tDSYR2K_LT\n#define\tSYR2K_UR\t\tDSYR2K_UN\n#define\tSYR2K_UC\t\tDSYR2K_UT\n#define\tSYR2K_LR\t\tDSYR2K_LN\n#define\tSYR2K_LC\t\tDSYR2K_LT\n\n#define\tSYR2K_KERNEL_U\t\tDSYR2K_KERNEL_U\n#define\tSYR2K_KERNEL_L\t\tDSYR2K_KERNEL_L\n\n#define\tTRMM_LNUU\t\tDTRMM_LNUU\n#define\tTRMM_LNUN\t\tDTRMM_LNUN\n#define\tTRMM_LNLU\t\tDTRMM_LNLU\n#define\tTRMM_LNLN\t\tDTRMM_LNLN\n#define\tTRMM_LTUU\t\tDTRMM_LTUU\n#define\tTRMM_LTUN\t\tDTRMM_LTUN\n#define\tTRMM_LTLU\t\tDTRMM_LTLU\n#define\tTRMM_LTLN\t\tDTRMM_LTLN\n#define\tTRMM_LRUU\t\tDTRMM_LNUU\n#define\tTRMM_LRUN\t\tDTRMM_LNUN\n#define\tTRMM_LRLU\t\tDTRMM_LNLU\n#define\tTRMM_LRLN\t\tDTRMM_LNLN\n#define\tTRMM_LCUU\t\tDTRMM_LTUU\n#define\tTRMM_LCUN\t\tDTRMM_LTUN\n#define\tTRMM_LCLU\t\tDTRMM_LTLU\n#define\tTRMM_LCLN\t\tDTRMM_LTLN\n#define\tTRMM_RNUU\t\tDTRMM_RNUU\n#define\tTRMM_RNUN\t\tDTRMM_RNUN\n#define\tTRMM_RNLU\t\tDTRMM_RNLU\n#define\tTRMM_RNLN\t\tDTRMM_RNLN\n#define\tTRMM_RTUU\t\tDTRMM_RTUU\n#define\tTRMM_RTUN\t\tDTRMM_RTUN\n#define\tTRMM_RTLU\t\tDTRMM_RTLU\n#define\tTRMM_RTLN\t\tDTRMM_RTLN\n#define\tTRMM_RRUU\t\tDTRMM_RNUU\n#define\tTRMM_RRUN\t\tDTRMM_RNUN\n#define\tTRMM_RRLU\t\tDTRMM_RNLU\n#define\tTRMM_RRLN\t\tDTRMM_RNLN\n#define\tTRMM_RCUU\t\tDTRMM_RTUU\n#define\tTRMM_RCUN\t\tDTRMM_RTUN\n#define\tTRMM_RCLU\t\tDTRMM_RTLU\n#define\tTRMM_RCLN\t\tDTRMM_RTLN\n\n#define\tTRSM_LNUU\t\tDTRSM_LNUU\n#define\tTRSM_LNUN\t\tDTRSM_LNUN\n#define\tTRSM_LNLU\t\tDTRSM_LNLU\n#define\tTRSM_LNLN\t\tDTRSM_LNLN\n#define\tTRSM_LTUU\t\tDTRSM_LTUU\n#define\tTRSM_LTUN\t\tDTRSM_LTUN\n#define\tTRSM_LTLU\t\tDTRSM_LTLU\n#define\tTRSM_LTLN\t\tDTRSM_LTLN\n#define\tTRSM_LRUU\t\tDTRSM_LNUU\n#define\tTRSM_LRUN\t\tDTRSM_LNUN\n#define\tTRSM_LRLU\t\tDTRSM_LNLU\n#define\tTRSM_LRLN\t\tDTRSM_LNLN\n#define\tTRSM_LCUU\t\tDTRSM_LTUU\n#define\tTRSM_LCUN\t\tDTRSM_LTUN\n#define\tTRSM_LCLU\t\tDTRSM_LTLU\n#define\tTRSM_LCLN\t\tDTRSM_LTLN\n#define\tTRSM_RNUU\t\tDTRSM_RNUU\n#define\tTRSM_RNUN\t\tDTRSM_RNUN\n#define\tTRSM_RNLU\t\tDTRSM_RNLU\n#define\tTRSM_RNLN\t\tDTRSM_RNLN\n#define\tTRSM_RTUU\t\tDTRSM_RTUU\n#define\tTRSM_RTUN\t\tDTRSM_RTUN\n#define\tTRSM_RTLU\t\tDTRSM_RTLU\n#define\tTRSM_RTLN\t\tDTRSM_RTLN\n#define\tTRSM_RRUU\t\tDTRSM_RNUU\n#define\tTRSM_RRUN\t\tDTRSM_RNUN\n#define\tTRSM_RRLU\t\tDTRSM_RNLU\n#define\tTRSM_RRLN\t\tDTRSM_RNLN\n#define\tTRSM_RCUU\t\tDTRSM_RTUU\n#define\tTRSM_RCUN\t\tDTRSM_RTUN\n#define\tTRSM_RCLU\t\tDTRSM_RTLU\n#define\tTRSM_RCLN\t\tDTRSM_RTLN\n\n#define\tGEMM_THREAD_NN\t\tDGEMM_THREAD_NN\n#define\tGEMM_THREAD_CN\t\tDGEMM_THREAD_TN\n#define\tGEMM_THREAD_TN\t\tDGEMM_THREAD_TN\n#define\tGEMM_THREAD_NC\t\tDGEMM_THREAD_NT\n#define\tGEMM_THREAD_NT\t\tDGEMM_THREAD_NT\n#define\tGEMM_THREAD_CC\t\tDGEMM_THREAD_TT\n#define\tGEMM_THREAD_CT\t\tDGEMM_THREAD_TT\n#define\tGEMM_THREAD_TC\t\tDGEMM_THREAD_TT\n#define\tGEMM_THREAD_TT\t\tDGEMM_THREAD_TT\n#define\tGEMM_THREAD_NR\t\tDGEMM_THREAD_NN\n#define\tGEMM_THREAD_TR\t\tDGEMM_THREAD_TN\n#define\tGEMM_THREAD_CR\t\tDGEMM_THREAD_TN\n#define\tGEMM_THREAD_RN\t\tDGEMM_THREAD_NN\n#define\tGEMM_THREAD_RT\t\tDGEMM_THREAD_NT\n#define\tGEMM_THREAD_RC\t\tDGEMM_THREAD_NT\n#define\tGEMM_THREAD_RR\t\tDGEMM_THREAD_NN\n\n#define\tSYMM_THREAD_LU\t\tDSYMM_THREAD_LU\n#define\tSYMM_THREAD_LL\t\tDSYMM_THREAD_LL\n#define\tSYMM_THREAD_RU\t\tDSYMM_THREAD_RU\n#define\tSYMM_THREAD_RL\t\tDSYMM_THREAD_RL\n\n#define\tHEMM_THREAD_LU\t\tDHEMM_THREAD_LU\n#define\tHEMM_THREAD_LL\t\tDHEMM_THREAD_LL\n#define\tHEMM_THREAD_RU\t\tDHEMM_THREAD_RU\n#define\tHEMM_THREAD_RL\t\tDHEMM_THREAD_RL\n\n#define\tSYRK_THREAD_UN\t\tDSYRK_THREAD_UN\n#define\tSYRK_THREAD_UT\t\tDSYRK_THREAD_UT\n#define\tSYRK_THREAD_LN\t\tDSYRK_THREAD_LN\n#define\tSYRK_THREAD_LT\t\tDSYRK_THREAD_LT\n#define\tSYRK_THREAD_UR\t\tDSYRK_THREAD_UR\n#define\tSYRK_THREAD_UC\t\tDSYRK_THREAD_UC\n#define\tSYRK_THREAD_LR\t\tDSYRK_THREAD_LN\n#define\tSYRK_THREAD_LC\t\tDSYRK_THREAD_LT\n\n#define\tHERK_THREAD_UN\t\tDSYRK_THREAD_UN\n#define\tHERK_THREAD_UT\t\tDSYRK_THREAD_UT\n#define\tHERK_THREAD_LN\t\tDSYRK_THREAD_LN\n#define\tHERK_THREAD_LT\t\tDSYRK_THREAD_LT\n#define\tHERK_THREAD_UR\t\tDSYRK_THREAD_UR\n#define\tHERK_THREAD_UC\t\tDSYRK_THREAD_UC\n#define\tHERK_THREAD_LR\t\tDSYRK_THREAD_LN\n#define\tHERK_THREAD_LC\t\tDSYRK_THREAD_LT\n\n#define\tAXPBY_K\t\t\tDAXPBY_K\n\n#define OMATCOPY_K_CN\t\tDOMATCOPY_K_CN\n#define OMATCOPY_K_RN\t\tDOMATCOPY_K_RN\n#define OMATCOPY_K_CT\t\tDOMATCOPY_K_CT\n#define OMATCOPY_K_RT\t\tDOMATCOPY_K_RT\n#define IMATCOPY_K_CN\t\tDIMATCOPY_K_CN\n#define IMATCOPY_K_RN\t\tDIMATCOPY_K_RN\n#define IMATCOPY_K_CT\t\tDIMATCOPY_K_CT\n#define IMATCOPY_K_RT\t\tDIMATCOPY_K_RT\n\n#define GEADD_K                 DGEADD_K\n\n#define GEMM_SMALL_MATRIX_PERMIT\tDGEMM_SMALL_MATRIX_PERMIT\n\n#define GEMM_SMALL_KERNEL_NN    DGEMM_SMALL_KERNEL_NN\n#define GEMM_SMALL_KERNEL_NT    DGEMM_SMALL_KERNEL_NT\n#define GEMM_SMALL_KERNEL_TN    DGEMM_SMALL_KERNEL_TN\n#define GEMM_SMALL_KERNEL_TT    DGEMM_SMALL_KERNEL_TT\n#define GEMM_SMALL_KERNEL_B0_NN    DGEMM_SMALL_KERNEL_B0_NN\n#define GEMM_SMALL_KERNEL_B0_NT    DGEMM_SMALL_KERNEL_B0_NT\n#define GEMM_SMALL_KERNEL_B0_TN    DGEMM_SMALL_KERNEL_B0_TN\n#define GEMM_SMALL_KERNEL_B0_TT    DGEMM_SMALL_KERNEL_B0_TT\n\n#elif defined(BFLOAT16)\n\n#define D_TO_BF16_K     SBDTOBF16_K\n#define D_BF16_TO_K     DBF16TOD_K\n#define S_TO_BF16_K     SBSTOBF16_K\n#define S_BF16_TO_K     SBF16TOS_K\n#define SBGEMV_N        SBGEMV_N_K\n#define SBGEMV_T        SBGEMV_T_K\n\n#define\tAMAX_K\t\t\tSAMAX_K\n#define\tAMIN_K\t\t\tSAMIN_K\n#define\tMAX_K\t\t\tSMAX_K\n#define\tMIN_K\t\t\tSMIN_K\n#define\tIAMAX_K\t\t\tISAMAX_K\n#define\tIAMIN_K\t\t\tISAMIN_K\n#define\tIMAX_K\t\t\tISMAX_K\n#define\tIMIN_K\t\t\tISMIN_K\n#define\tASUM_K\t\t\tSASUM_K\n#define\tDOTU_K\t\t\tSDOTU_K\n#define\tDOTC_K\t\t\tSDOTC_K\n#define BF16_DOT_K      SBDOT_K\n#define\tAXPYU_K\t\t\tSAXPYU_K\n#define\tAXPYC_K\t\t\tSAXPYC_K\n#define AXPBY_K     SAXPBY_K\n#define SCAL_K\t\t\tSSCAL_K\n#define GEMV_N\t\t\tSGEMV_N\n#define GEMV_T\t\t\tSGEMV_T\n#define SYMV_U\t\t\tSSYMV_U\n#define SYMV_L\t\t\tSSYMV_L\n#define\tGERU_K\t\t\tSGERU_K\n#define\tGERC_K\t\t\tSGERC_K\n#define\tGERV_K\t\t\tSGERV_K\n#define\tGERD_K\t\t\tSGERD_K\n#define\tSUM_K\t\t\tSSUM_K\n#define\tSWAP_K\t\t\tSSWAP_K\n#define\tROT_K\t\t\tSROT_K\n#define COPY_K    SCOPY_K\n#define NRM2_K    SNRM2_K\n#define SYMV_THREAD_U\t\tSSYMV_THREAD_U\n#define SYMV_THREAD_L\t\tSSYMV_THREAD_L\n#define GEMM_BETA               SBGEMM_BETA\n#define\tGEMM_KERNEL_N\t\tSBGEMM_KERNEL\n#define\tGEMM_KERNEL_L\t\tSBGEMM_KERNEL\n#define\tGEMM_KERNEL_R\t\tSBGEMM_KERNEL\n#define\tGEMM_KERNEL_B\t\tSBGEMM_KERNEL\n\n#define\tGEMM_NN\t\t\tSBGEMM_NN\n#define\tGEMM_CN\t\t\tSBGEMM_TN\n#define\tGEMM_TN\t\t\tSBGEMM_TN\n#define\tGEMM_NC\t\t\tSBGEMM_NT\n#define\tGEMM_NT\t\t\tSBGEMM_NT\n#define\tGEMM_CC\t\t\tSBGEMM_TT\n#define\tGEMM_CT\t\t\tSBGEMM_TT\n#define\tGEMM_TC\t\t\tSBGEMM_TT\n#define\tGEMM_TT\t\t\tSBGEMM_TT\n#define\tGEMM_NR\t\t\tSBGEMM_NN\n#define\tGEMM_TR\t\t\tSBGEMM_TN\n#define\tGEMM_CR\t\t\tSBGEMM_TN\n#define\tGEMM_RN\t\t\tSBGEMM_NN\n#define\tGEMM_RT\t\t\tSBGEMM_NT\n#define\tGEMM_RC\t\t\tSBGEMM_NT\n#define\tGEMM_RR\t\t\tSBGEMM_NN\n#define\tGEMM_ONCOPY\t\tSBGEMM_ONCOPY\n#define\tGEMM_OTCOPY\t\tSBGEMM_OTCOPY\n#define\tGEMM_INCOPY\t\tSBGEMM_INCOPY\n#define\tGEMM_ITCOPY\t\tSBGEMM_ITCOPY\n#define SYMM_THREAD_LU          SSYMM_THREAD_LU\n#define SYMM_THREAD_LL          SSYMM_THREAD_LL\n#define SYMM_THREAD_RU          SSYMM_THREAD_RU\n#define SYMM_THREAD_RL          SSYMM_THREAD_RL\n#define SYMM_LU                 SSYMM_LU\n#define SYMM_LL                 SSYMM_LL\n#define SYMM_RU                 SSYMM_RU\n#define SYMM_RL                 SSYMM_RL\n\n\n#define HEMM_THREAD_LU          SHEMM_THREAD_LU\n#define HEMM_THREAD_LL          SHEMM_THREAD_LL\n#define HEMM_THREAD_RU          SHEMM_THREAD_RU\n#define HEMM_THREAD_RL          SHEMM_THREAD_RL\n\n#define\tGEMM_THREAD_NN\t\tSBGEMM_THREAD_NN\n#define\tGEMM_THREAD_CN\t\tSBGEMM_THREAD_TN\n#define\tGEMM_THREAD_TN\t\tSBGEMM_THREAD_TN\n#define\tGEMM_THREAD_NC\t\tSBGEMM_THREAD_NT\n#define\tGEMM_THREAD_NT\t\tSBGEMM_THREAD_NT\n#define\tGEMM_THREAD_CC\t\tSBGEMM_THREAD_TT\n#define\tGEMM_THREAD_CT\t\tSBGEMM_THREAD_TT\n#define\tGEMM_THREAD_TC\t\tSBGEMM_THREAD_TT\n#define\tGEMM_THREAD_TT\t\tSBGEMM_THREAD_TT\n#define\tGEMM_THREAD_NR\t\tSBGEMM_THREAD_NN\n#define\tGEMM_THREAD_TR\t\tSBGEMM_THREAD_TN\n#define\tGEMM_THREAD_CR\t\tSBGEMM_THREAD_TN\n#define\tGEMM_THREAD_RN\t\tSBGEMM_THREAD_NN\n#define\tGEMM_THREAD_RT\t\tSBGEMM_THREAD_NT\n#define\tGEMM_THREAD_RC\t\tSBGEMM_THREAD_NT\n#define\tGEMM_THREAD_RR\t\tSBGEMM_THREAD_NN\n\n#ifdef UNIT\n\n#define\tTRMM_OUNCOPY\t\tSTRMM_OUNUCOPY\n#define\tTRMM_OUTCOPY\t\tSTRMM_OUTUCOPY\n#define\tTRMM_OLNCOPY\t\tSTRMM_OLNUCOPY\n#define\tTRMM_OLTCOPY\t\tSTRMM_OLTUCOPY\n#define\tTRSM_OUNCOPY\t\tSTRSM_OUNUCOPY\n#define\tTRSM_OUTCOPY\t\tSTRSM_OUTUCOPY\n#define\tTRSM_OLNCOPY\t\tSTRSM_OLNUCOPY\n#define\tTRSM_OLTCOPY\t\tSTRSM_OLTUCOPY\n\n#define\tTRMM_IUNCOPY\t\tSTRMM_IUNUCOPY\n#define\tTRMM_IUTCOPY\t\tSTRMM_IUTUCOPY\n#define\tTRMM_ILNCOPY\t\tSTRMM_ILNUCOPY\n#define\tTRMM_ILTCOPY\t\tSTRMM_ILTUCOPY\n#define\tTRSM_IUNCOPY\t\tSTRSM_IUNUCOPY\n#define\tTRSM_IUTCOPY\t\tSTRSM_IUTUCOPY\n#define\tTRSM_ILNCOPY\t\tSTRSM_ILNUCOPY\n#define\tTRSM_ILTCOPY\t\tSTRSM_ILTUCOPY\n\n#else\n\n#define\tTRMM_OUNCOPY\t\tSTRMM_OUNNCOPY\n#define\tTRMM_OUTCOPY\t\tSTRMM_OUTNCOPY\n#define\tTRMM_OLNCOPY\t\tSTRMM_OLNNCOPY\n#define\tTRMM_OLTCOPY\t\tSTRMM_OLTNCOPY\n#define\tTRSM_OUNCOPY\t\tSTRSM_OUNNCOPY\n#define\tTRSM_OUTCOPY\t\tSTRSM_OUTNCOPY\n#define\tTRSM_OLNCOPY\t\tSTRSM_OLNNCOPY\n#define\tTRSM_OLTCOPY\t\tSTRSM_OLTNCOPY\n\n#define\tTRMM_IUNCOPY\t\tSTRMM_IUNNCOPY\n#define\tTRMM_IUTCOPY\t\tSTRMM_IUTNCOPY\n#define\tTRMM_ILNCOPY\t\tSTRMM_ILNNCOPY\n#define\tTRMM_ILTCOPY\t\tSTRMM_ILTNCOPY\n#define\tTRSM_IUNCOPY\t\tSTRSM_IUNNCOPY\n#define\tTRSM_IUTCOPY\t\tSTRSM_IUTNCOPY\n#define\tTRSM_ILNCOPY\t\tSTRSM_ILNNCOPY\n#define\tTRSM_ILTCOPY\t\tSTRSM_ILTNCOPY\n\n#define\tTRMM_KERNEL_LN\t\tSTRMM_KERNEL_LN\n#define\tTRMM_KERNEL_LT\t\tSTRMM_KERNEL_LT\n#define\tTRMM_KERNEL_LR\t\tSTRMM_KERNEL_LN\n#define\tTRMM_KERNEL_LC\t\tSTRMM_KERNEL_LT\n#define\tTRMM_KERNEL_RN\t\tSTRMM_KERNEL_RN\n#define\tTRMM_KERNEL_RT\t\tSTRMM_KERNEL_RT\n#define\tTRMM_KERNEL_RR\t\tSTRMM_KERNEL_RN\n#define\tTRMM_KERNEL_RC\t\tSTRMM_KERNEL_RT\n\n#define\tTRSM_KERNEL_LN\t\tSTRSM_KERNEL_LN\n#define\tTRSM_KERNEL_LT\t\tSTRSM_KERNEL_LT\n#define\tTRSM_KERNEL_LR\t\tSTRSM_KERNEL_LN\n#define\tTRSM_KERNEL_LC\t\tSTRSM_KERNEL_LT\n#define\tTRSM_KERNEL_RN\t\tSTRSM_KERNEL_RN\n#define\tTRSM_KERNEL_RT\t\tSTRSM_KERNEL_RT\n#define\tTRSM_KERNEL_RR\t\tSTRSM_KERNEL_RN\n#define\tTRSM_KERNEL_RC\t\tSTRSM_KERNEL_RT\n\n#define SYMM_IUTCOPY\t\tSSYMM_IUTCOPY\n#define SYMM_ILTCOPY\t\tSSYMM_ILTCOPY\n#define SYMM_OUTCOPY\t\tSSYMM_OUTCOPY\n#define SYMM_OLTCOPY\t\tSSYMM_OLTCOPY\n#define\tTRMM_LNUU\t\tSTRMM_LNUU\n#define\tTRMM_LNUN\t\tSTRMM_LNUN\n#define\tTRMM_LNLU\t\tSTRMM_LNLU\n#define\tTRMM_LNLN\t\tSTRMM_LNLN\n#define\tTRMM_LTUU\t\tSTRMM_LTUU\n#define\tTRMM_LTUN\t\tSTRMM_LTUN\n#define\tTRMM_LTLU\t\tSTRMM_LTLU\n#define\tTRMM_LTLN\t\tSTRMM_LTLN\n#define\tTRMM_LRUU\t\tSTRMM_LNUU\n#define\tTRMM_LRUN\t\tSTRMM_LNUN\n#define\tTRMM_LRLU\t\tSTRMM_LNLU\n#define\tTRMM_LRLN\t\tSTRMM_LNLN\n#define\tTRMM_LCUU\t\tSTRMM_LTUU\n#define\tTRMM_LCUN\t\tSTRMM_LTUN\n#define\tTRMM_LCLU\t\tSTRMM_LTLU\n#define\tTRMM_LCLN\t\tSTRMM_LTLN\n#define\tTRMM_RNUU\t\tSTRMM_RNUU\n#define\tTRMM_RNUN\t\tSTRMM_RNUN\n#define\tTRMM_RNLU\t\tSTRMM_RNLU\n#define\tTRMM_RNLN\t\tSTRMM_RNLN\n#define\tTRMM_RTUU\t\tSTRMM_RTUU\n#define\tTRMM_RTUN\t\tSTRMM_RTUN\n#define\tTRMM_RTLU\t\tSTRMM_RTLU\n#define\tTRMM_RTLN\t\tSTRMM_RTLN\n#define\tTRMM_RRUU\t\tSTRMM_RNUU\n#define\tTRMM_RRUN\t\tSTRMM_RNUN\n#define\tTRMM_RRLU\t\tSTRMM_RNLU\n#define\tTRMM_RRLN\t\tSTRMM_RNLN\n#define\tTRMM_RCUU\t\tSTRMM_RTUU\n#define\tTRMM_RCUN\t\tSTRMM_RTUN\n#define\tTRMM_RCLU\t\tSTRMM_RTLU\n#define\tTRMM_RCLN\t\tSTRMM_RTLN\n\n#define\tTRSM_LNUU\t\tSTRSM_LNUU\n#define\tTRSM_LNUN\t\tSTRSM_LNUN\n#define\tTRSM_LNLU\t\tSTRSM_LNLU\n#define\tTRSM_LNLN\t\tSTRSM_LNLN\n#define\tTRSM_LTUU\t\tSTRSM_LTUU\n#define\tTRSM_LTUN\t\tSTRSM_LTUN\n#define\tTRSM_LTLU\t\tSTRSM_LTLU\n#define\tTRSM_LTLN\t\tSTRSM_LTLN\n#define\tTRSM_LRUU\t\tSTRSM_LNUU\n#define\tTRSM_LRUN\t\tSTRSM_LNUN\n#define\tTRSM_LRLU\t\tSTRSM_LNLU\n#define\tTRSM_LRLN\t\tSTRSM_LNLN\n#define\tTRSM_LCUU\t\tSTRSM_LTUU\n#define\tTRSM_LCUN\t\tSTRSM_LTUN\n#define\tTRSM_LCLU\t\tSTRSM_LTLU\n#define\tTRSM_LCLN\t\tSTRSM_LTLN\n#define\tTRSM_RNUU\t\tSTRSM_RNUU\n#define\tTRSM_RNUN\t\tSTRSM_RNUN\n#define\tTRSM_RNLU\t\tSTRSM_RNLU\n#define\tTRSM_RNLN\t\tSTRSM_RNLN\n#define\tTRSM_RTUU\t\tSTRSM_RTUU\n#define\tTRSM_RTUN\t\tSTRSM_RTUN\n#define\tTRSM_RTLU\t\tSTRSM_RTLU\n#define\tTRSM_RTLN\t\tSTRSM_RTLN\n#define\tTRSM_RRUU\t\tSTRSM_RNUU\n#define\tTRSM_RRUN\t\tSTRSM_RNUN\n#define\tTRSM_RRLU\t\tSTRSM_RNLU\n#define\tTRSM_RRLN\t\tSTRSM_RNLN\n#define\tTRSM_RCUU\t\tSTRSM_RTUU\n#define\tTRSM_RCUN\t\tSTRSM_RTUN\n#define\tTRSM_RCLU\t\tSTRSM_RTLU\n#define\tTRSM_RCLN\t\tSTRSM_RTLN\n#define\tSYRK_UN\t\t\tSSYRK_UN\n#define\tSYRK_UT\t\t\tSSYRK_UT\n#define\tSYRK_LN\t\t\tSSYRK_LN\n#define\tSYRK_LT\t\t\tSSYRK_LT\n#define\tSYRK_UR\t\t\tSSYRK_UN\n#define\tSYRK_UC\t\t\tSSYRK_UT\n#define\tSYRK_LR\t\t\tSSYRK_LN\n#define\tSYRK_LC\t\t\tSSYRK_LT\n\n#define\tSYRK_KERNEL_U\t\tSSYRK_KERNEL_U\n#define\tSYRK_KERNEL_L\t\tSSYRK_KERNEL_L\n\n#define\tHERK_UN\t\t\tSSYRK_UN\n#define\tHERK_LN\t\t\tSSYRK_LN\n#define\tHERK_UC\t\t\tSSYRK_UT\n#define\tHERK_LC\t\t\tSSYRK_LT\n\n#define\tHER2K_UN\t\tSSYR2K_UN\n#define\tHER2K_LN\t\tSSYR2K_LN\n#define\tHER2K_UC\t\tSSYR2K_UT\n#define\tHER2K_LC\t\tSSYR2K_LT\n\n#define\tSYR2K_UN\t\tSSYR2K_UN\n#define\tSYR2K_UT\t\tSSYR2K_UT\n#define\tSYR2K_LN\t\tSSYR2K_LN\n#define\tSYR2K_LT\t\tSSYR2K_LT\n#define\tSYR2K_UR\t\tSSYR2K_UN\n#define\tSYR2K_UC\t\tSSYR2K_UT\n#define\tSYR2K_LR\t\tSSYR2K_LN\n#define\tSYR2K_LC\t\tSSYR2K_LT\n\n#define\tSYR2K_KERNEL_U\t\tSSYR2K_KERNEL_U\n#define\tSYR2K_KERNEL_L\t\tSSYR2K_KERNEL_L\n#define\tSYRK_THREAD_UN\t\tSSYRK_THREAD_UN\n#define\tSYRK_THREAD_UT\t\tSSYRK_THREAD_UT\n#define\tSYRK_THREAD_LN\t\tSSYRK_THREAD_LN\n#define\tSYRK_THREAD_LT\t\tSSYRK_THREAD_LT\n#define\tSYRK_THREAD_UR\t\tSSYRK_THREAD_UR\n#define\tSYRK_THREAD_UC\t\tSSYRK_THREAD_UC\n#define\tSYRK_THREAD_LR\t\tSSYRK_THREAD_LN\n#define\tSYRK_THREAD_LC\t\tSSYRK_THREAD_LT\n\n#define\tHERK_THREAD_UN\t\tSSYRK_THREAD_UN\n#define\tHERK_THREAD_UT\t\tSSYRK_THREAD_UT\n#define\tHERK_THREAD_LN\t\tSSYRK_THREAD_LN\n#define\tHERK_THREAD_LT\t\tSSYRK_THREAD_LT\n#define\tHERK_THREAD_UR\t\tSSYRK_THREAD_UR\n#define\tHERK_THREAD_UC\t\tSSYRK_THREAD_UC\n#define\tHERK_THREAD_LR\t\tSSYRK_THREAD_LN\n#define\tHERK_THREAD_LC\t\tSSYRK_THREAD_LT\n\n#define OMATCOPY_K_CN\t\tSOMATCOPY_K_CN\n#define OMATCOPY_K_RN\t\tSOMATCOPY_K_RN\n#define OMATCOPY_K_CT\t\tSOMATCOPY_K_CT\n#define OMATCOPY_K_RT\t\tSOMATCOPY_K_RT\n#define IMATCOPY_K_CN\t\tSIMATCOPY_K_CN\n#define IMATCOPY_K_RN\t\tSIMATCOPY_K_RN\n#define IMATCOPY_K_CT\t\tSIMATCOPY_K_CT\n#define IMATCOPY_K_RT\t\tSIMATCOPY_K_RT\n\n#define GEADD_K \t\tSGEADD_K\n\n#define GEMM_SMALL_MATRIX_PERMIT\tSBGEMM_SMALL_MATRIX_PERMIT\n\n#define GEMM_SMALL_KERNEL_NN    SBGEMM_SMALL_KERNEL_NN\n#define GEMM_SMALL_KERNEL_NT    SBGEMM_SMALL_KERNEL_NT\n#define GEMM_SMALL_KERNEL_TN    SBGEMM_SMALL_KERNEL_TN\n#define GEMM_SMALL_KERNEL_TT    SBGEMM_SMALL_KERNEL_TT\n\n#define GEMM_SMALL_KERNEL_B0_NN    SBGEMM_SMALL_KERNEL_B0_NN\n#define GEMM_SMALL_KERNEL_B0_NT    SBGEMM_SMALL_KERNEL_B0_NT\n#define GEMM_SMALL_KERNEL_B0_TN    SBGEMM_SMALL_KERNEL_B0_TN\n#define GEMM_SMALL_KERNEL_B0_TT    SBGEMM_SMALL_KERNEL_B0_TT\n\n#endif\n\n#else\n\n#define\tAMAX_K\t\t\tSAMAX_K\n#define\tAMIN_K\t\t\tSAMIN_K\n#define\tMAX_K\t\t\tSMAX_K\n#define\tMIN_K\t\t\tSMIN_K\n#define\tIAMAX_K\t\t\tISAMAX_K\n#define\tIAMIN_K\t\t\tISAMIN_K\n#define\tIMAX_K\t\t\tISMAX_K\n#define\tIMIN_K\t\t\tISMIN_K\n#define\tASUM_K\t\t\tSASUM_K\n#define\tAXPYU_K\t\t\tSAXPYU_K\n#define\tAXPYC_K\t\t\tSAXPYU_K\n#define\tCOPY_K\t\t\tSCOPY_K\n#define\tDOTU_K\t\t\tSDOTU_K\n#define\tDOTC_K\t\t\tSDOTC_K\n#define\tNRM2_K\t\t\tSNRM2_K\n#define\tSCAL_K\t\t\tSSCAL_K\n#define\tSUM_K\t\t\tSSUM_K\n#define\tSWAP_K\t\t\tSSWAP_K\n#define\tROT_K\t\t\tSROT_K\n\n#define\tGEMV_N\t\t\tSGEMV_N\n#define\tGEMV_T\t\t\tSGEMV_T\n#define\tGEMV_R\t\t\tSGEMV_R\n#define\tGEMV_C\t\t\tSGEMV_C\n#define\tGEMV_O\t\t\tSGEMV_O\n#define\tGEMV_U\t\t\tSGEMV_U\n#define\tGEMV_S\t\t\tSGEMV_S\n#define\tGEMV_D\t\t\tSGEMV_D\n\n\n#define\tSYMV_U\t\t\tSSYMV_U\n#define\tSYMV_L\t\t\tSSYMV_L\n#define\tGERU_K\t\t\tSGERU_K\n#define\tGERC_K\t\t\tSGERC_K\n#define\tGERV_K\t\t\tSGERV_K\n#define\tGERD_K\t\t\tSGERD_K\n\n#define\tSYMV_THREAD_U\t\tSSYMV_THREAD_U\n#define\tSYMV_THREAD_L\t\tSSYMV_THREAD_L\n\n#define\tGEMM_ONCOPY\t\tSGEMM_ONCOPY\n#define\tGEMM_OTCOPY\t\tSGEMM_OTCOPY\n#define\tGEMM_INCOPY\t\tSGEMM_INCOPY\n#define\tGEMM_ITCOPY\t\tSGEMM_ITCOPY\n\n#ifdef UNIT\n\n#define\tTRMM_OUNCOPY\t\tSTRMM_OUNUCOPY\n#define\tTRMM_OUTCOPY\t\tSTRMM_OUTUCOPY\n#define\tTRMM_OLNCOPY\t\tSTRMM_OLNUCOPY\n#define\tTRMM_OLTCOPY\t\tSTRMM_OLTUCOPY\n#define\tTRSM_OUNCOPY\t\tSTRSM_OUNUCOPY\n#define\tTRSM_OUTCOPY\t\tSTRSM_OUTUCOPY\n#define\tTRSM_OLNCOPY\t\tSTRSM_OLNUCOPY\n#define\tTRSM_OLTCOPY\t\tSTRSM_OLTUCOPY\n\n#define\tTRMM_IUNCOPY\t\tSTRMM_IUNUCOPY\n#define\tTRMM_IUTCOPY\t\tSTRMM_IUTUCOPY\n#define\tTRMM_ILNCOPY\t\tSTRMM_ILNUCOPY\n#define\tTRMM_ILTCOPY\t\tSTRMM_ILTUCOPY\n#define\tTRSM_IUNCOPY\t\tSTRSM_IUNUCOPY\n#define\tTRSM_IUTCOPY\t\tSTRSM_IUTUCOPY\n#define\tTRSM_ILNCOPY\t\tSTRSM_ILNUCOPY\n#define\tTRSM_ILTCOPY\t\tSTRSM_ILTUCOPY\n\n#else\n\n#define\tTRMM_OUNCOPY\t\tSTRMM_OUNNCOPY\n#define\tTRMM_OUTCOPY\t\tSTRMM_OUTNCOPY\n#define\tTRMM_OLNCOPY\t\tSTRMM_OLNNCOPY\n#define\tTRMM_OLTCOPY\t\tSTRMM_OLTNCOPY\n#define\tTRSM_OUNCOPY\t\tSTRSM_OUNNCOPY\n#define\tTRSM_OUTCOPY\t\tSTRSM_OUTNCOPY\n#define\tTRSM_OLNCOPY\t\tSTRSM_OLNNCOPY\n#define\tTRSM_OLTCOPY\t\tSTRSM_OLTNCOPY\n\n#define\tTRMM_IUNCOPY\t\tSTRMM_IUNNCOPY\n#define\tTRMM_IUTCOPY\t\tSTRMM_IUTNCOPY\n#define\tTRMM_ILNCOPY\t\tSTRMM_ILNNCOPY\n#define\tTRMM_ILTCOPY\t\tSTRMM_ILTNCOPY\n#define\tTRSM_IUNCOPY\t\tSTRSM_IUNNCOPY\n#define\tTRSM_IUTCOPY\t\tSTRSM_IUTNCOPY\n#define\tTRSM_ILNCOPY\t\tSTRSM_ILNNCOPY\n#define\tTRSM_ILTCOPY\t\tSTRSM_ILTNCOPY\n\n#endif\n\n#define\tGEMM_BETA\t\tSGEMM_BETA\n\n#define\tGEMM_KERNEL_N\t\tSGEMM_KERNEL\n#define\tGEMM_KERNEL_L\t\tSGEMM_KERNEL\n#define\tGEMM_KERNEL_R\t\tSGEMM_KERNEL\n#define\tGEMM_KERNEL_B\t\tSGEMM_KERNEL\n\n#define\tTRMM_KERNEL_LN\t\tSTRMM_KERNEL_LN\n#define\tTRMM_KERNEL_LT\t\tSTRMM_KERNEL_LT\n#define\tTRMM_KERNEL_LR\t\tSTRMM_KERNEL_LN\n#define\tTRMM_KERNEL_LC\t\tSTRMM_KERNEL_LT\n#define\tTRMM_KERNEL_RN\t\tSTRMM_KERNEL_RN\n#define\tTRMM_KERNEL_RT\t\tSTRMM_KERNEL_RT\n#define\tTRMM_KERNEL_RR\t\tSTRMM_KERNEL_RN\n#define\tTRMM_KERNEL_RC\t\tSTRMM_KERNEL_RT\n\n#define\tTRSM_KERNEL_LN\t\tSTRSM_KERNEL_LN\n#define\tTRSM_KERNEL_LT\t\tSTRSM_KERNEL_LT\n#define\tTRSM_KERNEL_LR\t\tSTRSM_KERNEL_LN\n#define\tTRSM_KERNEL_LC\t\tSTRSM_KERNEL_LT\n#define\tTRSM_KERNEL_RN\t\tSTRSM_KERNEL_RN\n#define\tTRSM_KERNEL_RT\t\tSTRSM_KERNEL_RT\n#define\tTRSM_KERNEL_RR\t\tSTRSM_KERNEL_RN\n#define\tTRSM_KERNEL_RC\t\tSTRSM_KERNEL_RT\n\n#define SYMM_IUTCOPY\t\tSSYMM_IUTCOPY\n#define SYMM_ILTCOPY\t\tSSYMM_ILTCOPY\n#define SYMM_OUTCOPY\t\tSSYMM_OUTCOPY\n#define SYMM_OLTCOPY\t\tSSYMM_OLTCOPY\n\n#define\tGEMM_NN\t\t\tSGEMM_NN\n#define\tGEMM_CN\t\t\tSGEMM_TN\n#define\tGEMM_TN\t\t\tSGEMM_TN\n#define\tGEMM_NC\t\t\tSGEMM_NT\n#define\tGEMM_NT\t\t\tSGEMM_NT\n#define\tGEMM_CC\t\t\tSGEMM_TT\n#define\tGEMM_CT\t\t\tSGEMM_TT\n#define\tGEMM_TC\t\t\tSGEMM_TT\n#define\tGEMM_TT\t\t\tSGEMM_TT\n#define\tGEMM_NR\t\t\tSGEMM_NN\n#define\tGEMM_TR\t\t\tSGEMM_TN\n#define\tGEMM_CR\t\t\tSGEMM_TN\n#define\tGEMM_RN\t\t\tSGEMM_NN\n#define\tGEMM_RT\t\t\tSGEMM_NT\n#define\tGEMM_RC\t\t\tSGEMM_NT\n#define\tGEMM_RR\t\t\tSGEMM_NN\n\n#define\tSYMM_LU\t\t\tSSYMM_LU\n#define\tSYMM_LL\t\t\tSSYMM_LL\n#define\tSYMM_RU\t\t\tSSYMM_RU\n#define\tSYMM_RL\t\t\tSSYMM_RL\n\n#define\tHEMM_LU\t\t\tSHEMM_LU\n#define\tHEMM_LL\t\t\tSHEMM_LL\n#define\tHEMM_RU\t\t\tSHEMM_RU\n#define\tHEMM_RL\t\t\tSHEMM_RL\n\n#define\tSYRK_UN\t\t\tSSYRK_UN\n#define\tSYRK_UT\t\t\tSSYRK_UT\n#define\tSYRK_LN\t\t\tSSYRK_LN\n#define\tSYRK_LT\t\t\tSSYRK_LT\n#define\tSYRK_UR\t\t\tSSYRK_UN\n#define\tSYRK_UC\t\t\tSSYRK_UT\n#define\tSYRK_LR\t\t\tSSYRK_LN\n#define\tSYRK_LC\t\t\tSSYRK_LT\n\n#define\tSYRK_KERNEL_U\t\tSSYRK_KERNEL_U\n#define\tSYRK_KERNEL_L\t\tSSYRK_KERNEL_L\n\n#define\tHERK_UN\t\t\tSSYRK_UN\n#define\tHERK_LN\t\t\tSSYRK_LN\n#define\tHERK_UC\t\t\tSSYRK_UT\n#define\tHERK_LC\t\t\tSSYRK_LT\n\n#define\tHER2K_UN\t\tSSYR2K_UN\n#define\tHER2K_LN\t\tSSYR2K_LN\n#define\tHER2K_UC\t\tSSYR2K_UT\n#define\tHER2K_LC\t\tSSYR2K_LT\n\n#define\tSYR2K_UN\t\tSSYR2K_UN\n#define\tSYR2K_UT\t\tSSYR2K_UT\n#define\tSYR2K_LN\t\tSSYR2K_LN\n#define\tSYR2K_LT\t\tSSYR2K_LT\n#define\tSYR2K_UR\t\tSSYR2K_UN\n#define\tSYR2K_UC\t\tSSYR2K_UT\n#define\tSYR2K_LR\t\tSSYR2K_LN\n#define\tSYR2K_LC\t\tSSYR2K_LT\n\n#define\tSYR2K_KERNEL_U\t\tSSYR2K_KERNEL_U\n#define\tSYR2K_KERNEL_L\t\tSSYR2K_KERNEL_L\n\n#define\tTRMM_LNUU\t\tSTRMM_LNUU\n#define\tTRMM_LNUN\t\tSTRMM_LNUN\n#define\tTRMM_LNLU\t\tSTRMM_LNLU\n#define\tTRMM_LNLN\t\tSTRMM_LNLN\n#define\tTRMM_LTUU\t\tSTRMM_LTUU\n#define\tTRMM_LTUN\t\tSTRMM_LTUN\n#define\tTRMM_LTLU\t\tSTRMM_LTLU\n#define\tTRMM_LTLN\t\tSTRMM_LTLN\n#define\tTRMM_LRUU\t\tSTRMM_LNUU\n#define\tTRMM_LRUN\t\tSTRMM_LNUN\n#define\tTRMM_LRLU\t\tSTRMM_LNLU\n#define\tTRMM_LRLN\t\tSTRMM_LNLN\n#define\tTRMM_LCUU\t\tSTRMM_LTUU\n#define\tTRMM_LCUN\t\tSTRMM_LTUN\n#define\tTRMM_LCLU\t\tSTRMM_LTLU\n#define\tTRMM_LCLN\t\tSTRMM_LTLN\n#define\tTRMM_RNUU\t\tSTRMM_RNUU\n#define\tTRMM_RNUN\t\tSTRMM_RNUN\n#define\tTRMM_RNLU\t\tSTRMM_RNLU\n#define\tTRMM_RNLN\t\tSTRMM_RNLN\n#define\tTRMM_RTUU\t\tSTRMM_RTUU\n#define\tTRMM_RTUN\t\tSTRMM_RTUN\n#define\tTRMM_RTLU\t\tSTRMM_RTLU\n#define\tTRMM_RTLN\t\tSTRMM_RTLN\n#define\tTRMM_RRUU\t\tSTRMM_RNUU\n#define\tTRMM_RRUN\t\tSTRMM_RNUN\n#define\tTRMM_RRLU\t\tSTRMM_RNLU\n#define\tTRMM_RRLN\t\tSTRMM_RNLN\n#define\tTRMM_RCUU\t\tSTRMM_RTUU\n#define\tTRMM_RCUN\t\tSTRMM_RTUN\n#define\tTRMM_RCLU\t\tSTRMM_RTLU\n#define\tTRMM_RCLN\t\tSTRMM_RTLN\n\n#define\tTRSM_LNUU\t\tSTRSM_LNUU\n#define\tTRSM_LNUN\t\tSTRSM_LNUN\n#define\tTRSM_LNLU\t\tSTRSM_LNLU\n#define\tTRSM_LNLN\t\tSTRSM_LNLN\n#define\tTRSM_LTUU\t\tSTRSM_LTUU\n#define\tTRSM_LTUN\t\tSTRSM_LTUN\n#define\tTRSM_LTLU\t\tSTRSM_LTLU\n#define\tTRSM_LTLN\t\tSTRSM_LTLN\n#define\tTRSM_LRUU\t\tSTRSM_LNUU\n#define\tTRSM_LRUN\t\tSTRSM_LNUN\n#define\tTRSM_LRLU\t\tSTRSM_LNLU\n#define\tTRSM_LRLN\t\tSTRSM_LNLN\n#define\tTRSM_LCUU\t\tSTRSM_LTUU\n#define\tTRSM_LCUN\t\tSTRSM_LTUN\n#define\tTRSM_LCLU\t\tSTRSM_LTLU\n#define\tTRSM_LCLN\t\tSTRSM_LTLN\n#define\tTRSM_RNUU\t\tSTRSM_RNUU\n#define\tTRSM_RNUN\t\tSTRSM_RNUN\n#define\tTRSM_RNLU\t\tSTRSM_RNLU\n#define\tTRSM_RNLN\t\tSTRSM_RNLN\n#define\tTRSM_RTUU\t\tSTRSM_RTUU\n#define\tTRSM_RTUN\t\tSTRSM_RTUN\n#define\tTRSM_RTLU\t\tSTRSM_RTLU\n#define\tTRSM_RTLN\t\tSTRSM_RTLN\n#define\tTRSM_RRUU\t\tSTRSM_RNUU\n#define\tTRSM_RRUN\t\tSTRSM_RNUN\n#define\tTRSM_RRLU\t\tSTRSM_RNLU\n#define\tTRSM_RRLN\t\tSTRSM_RNLN\n#define\tTRSM_RCUU\t\tSTRSM_RTUU\n#define\tTRSM_RCUN\t\tSTRSM_RTUN\n#define\tTRSM_RCLU\t\tSTRSM_RTLU\n#define\tTRSM_RCLN\t\tSTRSM_RTLN\n\n#define\tGEMM_THREAD_NN\t\tSGEMM_THREAD_NN\n#define\tGEMM_THREAD_CN\t\tSGEMM_THREAD_TN\n#define\tGEMM_THREAD_TN\t\tSGEMM_THREAD_TN\n#define\tGEMM_THREAD_NC\t\tSGEMM_THREAD_NT\n#define\tGEMM_THREAD_NT\t\tSGEMM_THREAD_NT\n#define\tGEMM_THREAD_CC\t\tSGEMM_THREAD_TT\n#define\tGEMM_THREAD_CT\t\tSGEMM_THREAD_TT\n#define\tGEMM_THREAD_TC\t\tSGEMM_THREAD_TT\n#define\tGEMM_THREAD_TT\t\tSGEMM_THREAD_TT\n#define\tGEMM_THREAD_NR\t\tSGEMM_THREAD_NN\n#define\tGEMM_THREAD_TR\t\tSGEMM_THREAD_TN\n#define\tGEMM_THREAD_CR\t\tSGEMM_THREAD_TN\n#define\tGEMM_THREAD_RN\t\tSGEMM_THREAD_NN\n#define\tGEMM_THREAD_RT\t\tSGEMM_THREAD_NT\n#define\tGEMM_THREAD_RC\t\tSGEMM_THREAD_NT\n#define\tGEMM_THREAD_RR\t\tSGEMM_THREAD_NN\n\n#define\tSYMM_THREAD_LU\t\tSSYMM_THREAD_LU\n#define\tSYMM_THREAD_LL\t\tSSYMM_THREAD_LL\n#define\tSYMM_THREAD_RU\t\tSSYMM_THREAD_RU\n#define\tSYMM_THREAD_RL\t\tSSYMM_THREAD_RL\n\n#define\tHEMM_THREAD_LU\t\tSHEMM_THREAD_LU\n#define\tHEMM_THREAD_LL\t\tSHEMM_THREAD_LL\n#define\tHEMM_THREAD_RU\t\tSHEMM_THREAD_RU\n#define\tHEMM_THREAD_RL\t\tSHEMM_THREAD_RL\n\n#define\tSYRK_THREAD_UN\t\tSSYRK_THREAD_UN\n#define\tSYRK_THREAD_UT\t\tSSYRK_THREAD_UT\n#define\tSYRK_THREAD_LN\t\tSSYRK_THREAD_LN\n#define\tSYRK_THREAD_LT\t\tSSYRK_THREAD_LT\n#define\tSYRK_THREAD_UR\t\tSSYRK_THREAD_UR\n#define\tSYRK_THREAD_UC\t\tSSYRK_THREAD_UC\n#define\tSYRK_THREAD_LR\t\tSSYRK_THREAD_LN\n#define\tSYRK_THREAD_LC\t\tSSYRK_THREAD_LT\n\n#define\tHERK_THREAD_UN\t\tSSYRK_THREAD_UN\n#define\tHERK_THREAD_UT\t\tSSYRK_THREAD_UT\n#define\tHERK_THREAD_LN\t\tSSYRK_THREAD_LN\n#define\tHERK_THREAD_LT\t\tSSYRK_THREAD_LT\n#define\tHERK_THREAD_UR\t\tSSYRK_THREAD_UR\n#define\tHERK_THREAD_UC\t\tSSYRK_THREAD_UC\n#define\tHERK_THREAD_LR\t\tSSYRK_THREAD_LN\n#define\tHERK_THREAD_LC\t\tSSYRK_THREAD_LT\n\n#define\tAXPBY_K\t\t\tSAXPBY_K\n\n#define OMATCOPY_K_CN\t\tSOMATCOPY_K_CN\n#define OMATCOPY_K_RN\t\tSOMATCOPY_K_RN\n#define OMATCOPY_K_CT\t\tSOMATCOPY_K_CT\n#define OMATCOPY_K_RT\t\tSOMATCOPY_K_RT\n#define IMATCOPY_K_CN\t\tSIMATCOPY_K_CN\n#define IMATCOPY_K_RN\t\tSIMATCOPY_K_RN\n#define IMATCOPY_K_CT\t\tSIMATCOPY_K_CT\n#define IMATCOPY_K_RT\t\tSIMATCOPY_K_RT\n\n#define GEADD_K \t\tSGEADD_K\n\n#define GEMM_SMALL_MATRIX_PERMIT\tSGEMM_SMALL_MATRIX_PERMIT\n\n#define GEMM_SMALL_KERNEL_NN    SGEMM_SMALL_KERNEL_NN\n#define GEMM_SMALL_KERNEL_NT    SGEMM_SMALL_KERNEL_NT\n#define GEMM_SMALL_KERNEL_TN    SGEMM_SMALL_KERNEL_TN\n#define GEMM_SMALL_KERNEL_TT    SGEMM_SMALL_KERNEL_TT\n\n#define GEMM_SMALL_KERNEL_B0_NN    SGEMM_SMALL_KERNEL_B0_NN\n#define GEMM_SMALL_KERNEL_B0_NT    SGEMM_SMALL_KERNEL_B0_NT\n#define GEMM_SMALL_KERNEL_B0_TN    SGEMM_SMALL_KERNEL_B0_TN\n#define GEMM_SMALL_KERNEL_B0_TT    SGEMM_SMALL_KERNEL_B0_TT\n\n#endif\n#else\n#ifdef XDOUBLE\n\n#define\tAMAX_K\t\t\tXAMAX_K\n#define\tAMIN_K\t\t\tXAMIN_K\n#define\tMAX_K\t\t\tXMAX_K\n#define\tMIN_K\t\t\tXMIN_K\n#define\tIAMAX_K\t\t\tIXAMAX_K\n#define\tIAMIN_K\t\t\tIXAMIN_K\n#define\tIMAX_K\t\t\tIXMAX_K\n#define\tIMIN_K\t\t\tIXMIN_K\n#define\tASUM_K\t\t\tXASUM_K\n#define\tAXPYU_K\t\t\tXAXPYU_K\n#define\tAXPYC_K\t\t\tXAXPYC_K\n#define\tCOPY_K\t\t\tXCOPY_K\n#define\tDOTU_K\t\t\tXDOTU_K\n#define\tDOTC_K\t\t\tXDOTC_K\n#define\tNRM2_K\t\t\tXNRM2_K\n#define\tSCAL_K\t\t\tXSCAL_K\n#define\tSUM_K\t\t\tXSUM_K\n#define\tSWAP_K\t\t\tXSWAP_K\n#define\tROT_K\t\t\tXROT_K\n\n#define\tGEMV_N\t\t\tXGEMV_N\n#define\tGEMV_T\t\t\tXGEMV_T\n#define\tGEMV_R\t\t\tXGEMV_R\n#define\tGEMV_C\t\t\tXGEMV_C\n#define\tGEMV_O\t\t\tXGEMV_O\n#define\tGEMV_U\t\t\tXGEMV_U\n#define\tGEMV_S\t\t\tXGEMV_S\n#define\tGEMV_D\t\t\tXGEMV_D\n\n#define\tGERU_K\t\t\tXGERU_K\n#define\tGERC_K\t\t\tXGERC_K\n#define\tGERV_K\t\t\tXGERV_K\n#define\tGERD_K\t\t\tXGERD_K\n\n#define\tSYMV_U\t\t\tXSYMV_U\n#define\tSYMV_L\t\t\tXSYMV_L\n#define\tHEMV_U\t\t\tXHEMV_U\n#define\tHEMV_L\t\t\tXHEMV_L\n#define\tHEMV_V\t\t\tXHEMV_V\n#define\tHEMV_M\t\t\tXHEMV_M\n\n#define\tSYMV_THREAD_U\t\tXSYMV_THREAD_U\n#define\tSYMV_THREAD_L\t\tXSYMV_THREAD_L\n#define\tHEMV_THREAD_U\t\tXHEMV_THREAD_U\n#define\tHEMV_THREAD_L\t\tXHEMV_THREAD_L\n#define\tHEMV_THREAD_V\t\tXHEMV_THREAD_V\n#define\tHEMV_THREAD_M\t\tXHEMV_THREAD_M\n\n#define\tGEMM_ONCOPY\t\tXGEMM_ONCOPY\n#define\tGEMM_OTCOPY\t\tXGEMM_OTCOPY\n#define\tGEMM_INCOPY\t\tXGEMM_INCOPY\n#define\tGEMM_ITCOPY\t\tXGEMM_ITCOPY\n\n#define\tGEMM3M_ONCOPYB\t\tXGEMM3M_ONCOPYB\n#define\tGEMM3M_ONCOPYR\t\tXGEMM3M_ONCOPYR\n#define\tGEMM3M_ONCOPYI\t\tXGEMM3M_ONCOPYI\n#define\tGEMM3M_OTCOPYB\t\tXGEMM3M_OTCOPYB\n#define\tGEMM3M_OTCOPYR\t\tXGEMM3M_OTCOPYR\n#define\tGEMM3M_OTCOPYI\t\tXGEMM3M_OTCOPYI\n#define\tGEMM3M_INCOPYB\t\tXGEMM3M_INCOPYB\n#define\tGEMM3M_INCOPYR\t\tXGEMM3M_INCOPYR\n#define\tGEMM3M_INCOPYI\t\tXGEMM3M_INCOPYI\n#define\tGEMM3M_ITCOPYB\t\tXGEMM3M_ITCOPYB\n#define\tGEMM3M_ITCOPYR\t\tXGEMM3M_ITCOPYR\n#define\tGEMM3M_ITCOPYI\t\tXGEMM3M_ITCOPYI\n\n#ifdef UNIT\n\n#define\tTRMM_OUNCOPY\t\tXTRMM_OUNUCOPY\n#define\tTRMM_OUTCOPY\t\tXTRMM_OUTUCOPY\n#define\tTRMM_OLNCOPY\t\tXTRMM_OLNUCOPY\n#define\tTRMM_OLTCOPY\t\tXTRMM_OLTUCOPY\n#define\tTRSM_OUNCOPY\t\tXTRSM_OUNUCOPY\n#define\tTRSM_OUTCOPY\t\tXTRSM_OUTUCOPY\n#define\tTRSM_OLNCOPY\t\tXTRSM_OLNUCOPY\n#define\tTRSM_OLTCOPY\t\tXTRSM_OLTUCOPY\n\n#define\tTRMM_IUNCOPY\t\tXTRMM_IUNUCOPY\n#define\tTRMM_IUTCOPY\t\tXTRMM_IUTUCOPY\n#define\tTRMM_ILNCOPY\t\tXTRMM_ILNUCOPY\n#define\tTRMM_ILTCOPY\t\tXTRMM_ILTUCOPY\n#define\tTRSM_IUNCOPY\t\tXTRSM_IUNUCOPY\n#define\tTRSM_IUTCOPY\t\tXTRSM_IUTUCOPY\n#define\tTRSM_ILNCOPY\t\tXTRSM_ILNUCOPY\n#define\tTRSM_ILTCOPY\t\tXTRSM_ILTUCOPY\n\n#else\n\n#define\tTRMM_OUNCOPY\t\tXTRMM_OUNNCOPY\n#define\tTRMM_OUTCOPY\t\tXTRMM_OUTNCOPY\n#define\tTRMM_OLNCOPY\t\tXTRMM_OLNNCOPY\n#define\tTRMM_OLTCOPY\t\tXTRMM_OLTNCOPY\n#define\tTRSM_OUNCOPY\t\tXTRSM_OUNNCOPY\n#define\tTRSM_OUTCOPY\t\tXTRSM_OUTNCOPY\n#define\tTRSM_OLNCOPY\t\tXTRSM_OLNNCOPY\n#define\tTRSM_OLTCOPY\t\tXTRSM_OLTNCOPY\n\n#define\tTRMM_IUNCOPY\t\tXTRMM_IUNNCOPY\n#define\tTRMM_IUTCOPY\t\tXTRMM_IUTNCOPY\n#define\tTRMM_ILNCOPY\t\tXTRMM_ILNNCOPY\n#define\tTRMM_ILTCOPY\t\tXTRMM_ILTNCOPY\n#define\tTRSM_IUNCOPY\t\tXTRSM_IUNNCOPY\n#define\tTRSM_IUTCOPY\t\tXTRSM_IUTNCOPY\n#define\tTRSM_ILNCOPY\t\tXTRSM_ILNNCOPY\n#define\tTRSM_ILTCOPY\t\tXTRSM_ILTNCOPY\n\n#endif\n\n#define\tSYMM3M_ILCOPYB\t\tXSYMM3M_ILCOPYB\n#define\tSYMM3M_IUCOPYB\t\tXSYMM3M_IUCOPYB\n#define\tSYMM3M_ILCOPYR\t\tXSYMM3M_ILCOPYR\n#define\tSYMM3M_IUCOPYR\t\tXSYMM3M_IUCOPYR\n#define\tSYMM3M_ILCOPYI\t\tXSYMM3M_ILCOPYI\n#define\tSYMM3M_IUCOPYI\t\tXSYMM3M_IUCOPYI\n\n#define\tSYMM3M_OLCOPYB\t\tXSYMM3M_OLCOPYB\n#define\tSYMM3M_OUCOPYB\t\tXSYMM3M_OUCOPYB\n#define\tSYMM3M_OLCOPYR\t\tXSYMM3M_OLCOPYR\n#define\tSYMM3M_OUCOPYR\t\tXSYMM3M_OUCOPYR\n#define\tSYMM3M_OLCOPYI\t\tXSYMM3M_OLCOPYI\n#define\tSYMM3M_OUCOPYI\t\tXSYMM3M_OUCOPYI\n\n#define\tHEMM3M_ILCOPYB\t\tXHEMM3M_ILCOPYB\n#define\tHEMM3M_IUCOPYB\t\tXHEMM3M_IUCOPYB\n#define\tHEMM3M_ILCOPYR\t\tXHEMM3M_ILCOPYR\n#define\tHEMM3M_IUCOPYR\t\tXHEMM3M_IUCOPYR\n#define\tHEMM3M_ILCOPYI\t\tXHEMM3M_ILCOPYI\n#define\tHEMM3M_IUCOPYI\t\tXHEMM3M_IUCOPYI\n\n#define\tHEMM3M_OLCOPYB\t\tXHEMM3M_OLCOPYB\n#define\tHEMM3M_OUCOPYB\t\tXHEMM3M_OUCOPYB\n#define\tHEMM3M_OLCOPYR\t\tXHEMM3M_OLCOPYR\n#define\tHEMM3M_OUCOPYR\t\tXHEMM3M_OUCOPYR\n#define\tHEMM3M_OLCOPYI\t\tXHEMM3M_OLCOPYI\n#define\tHEMM3M_OUCOPYI\t\tXHEMM3M_OUCOPYI\n\n#define\tGEMM_BETA\t\tXGEMM_BETA\n\n#define\tGEMM_KERNEL_N\t\tXGEMM_KERNEL_N\n#define\tGEMM_KERNEL_L\t\tXGEMM_KERNEL_L\n#define\tGEMM_KERNEL_R\t\tXGEMM_KERNEL_R\n#define\tGEMM_KERNEL_B\t\tXGEMM_KERNEL_B\n\n#define\tGEMM3M_KERNEL\t\tXGEMM3M_KERNEL\n\n#define\tTRMM_KERNEL_LN\t\tXTRMM_KERNEL_LN\n#define\tTRMM_KERNEL_LT\t\tXTRMM_KERNEL_LT\n#define\tTRMM_KERNEL_LR\t\tXTRMM_KERNEL_LR\n#define\tTRMM_KERNEL_LC\t\tXTRMM_KERNEL_LC\n#define\tTRMM_KERNEL_RN\t\tXTRMM_KERNEL_RN\n#define\tTRMM_KERNEL_RT\t\tXTRMM_KERNEL_RT\n#define\tTRMM_KERNEL_RR\t\tXTRMM_KERNEL_RR\n#define\tTRMM_KERNEL_RC\t\tXTRMM_KERNEL_RC\n\n#define\tTRSM_KERNEL_LN\t\tXTRSM_KERNEL_LN\n#define\tTRSM_KERNEL_LT\t\tXTRSM_KERNEL_LT\n#define\tTRSM_KERNEL_LR\t\tXTRSM_KERNEL_LR\n#define\tTRSM_KERNEL_LC\t\tXTRSM_KERNEL_LC\n#define\tTRSM_KERNEL_RN\t\tXTRSM_KERNEL_RN\n#define\tTRSM_KERNEL_RT\t\tXTRSM_KERNEL_RT\n#define\tTRSM_KERNEL_RR\t\tXTRSM_KERNEL_RR\n#define\tTRSM_KERNEL_RC\t\tXTRSM_KERNEL_RC\n\n#define\tGEMM_NN\t\t\tXGEMM_NN\n#define\tGEMM_CN\t\t\tXGEMM_CN\n#define\tGEMM_TN\t\t\tXGEMM_TN\n#define\tGEMM_NC\t\t\tXGEMM_NC\n#define\tGEMM_NT\t\t\tXGEMM_NT\n#define\tGEMM_CC\t\t\tXGEMM_CC\n#define\tGEMM_CT\t\t\tXGEMM_CT\n#define\tGEMM_TC\t\t\tXGEMM_TC\n#define\tGEMM_TT\t\t\tXGEMM_TT\n#define\tGEMM_NR\t\t\tXGEMM_NR\n#define\tGEMM_TR\t\t\tXGEMM_TR\n#define\tGEMM_CR\t\t\tXGEMM_CR\n#define\tGEMM_RN\t\t\tXGEMM_RN\n#define\tGEMM_RT\t\t\tXGEMM_RT\n#define\tGEMM_RC\t\t\tXGEMM_RC\n#define\tGEMM_RR\t\t\tXGEMM_RR\n\n#define\tSYMM_LU\t\t\tXSYMM_LU\n#define\tSYMM_LL\t\t\tXSYMM_LL\n#define\tSYMM_RU\t\t\tXSYMM_RU\n#define\tSYMM_RL\t\t\tXSYMM_RL\n\n#define\tHEMM_LU\t\t\tXHEMM_LU\n#define\tHEMM_LL\t\t\tXHEMM_LL\n#define\tHEMM_RU\t\t\tXHEMM_RU\n#define\tHEMM_RL\t\t\tXHEMM_RL\n\n#define HEMM_IUTCOPY\t\tXHEMM_IUTCOPY\n#define HEMM_ILTCOPY\t\tXHEMM_ILTCOPY\n#define HEMM_OUTCOPY\t\tXHEMM_OUTCOPY\n#define HEMM_OLTCOPY\t\tXHEMM_OLTCOPY\n\n#define\tSYRK_UN\t\t\tXSYRK_UN\n#define\tSYRK_UT\t\t\tXSYRK_UT\n#define\tSYRK_LN\t\t\tXSYRK_LN\n#define\tSYRK_LT\t\t\tXSYRK_LT\n#define\tSYRK_UR\t\t\tXSYRK_UN\n#define\tSYRK_UC\t\t\tXSYRK_UT\n#define\tSYRK_LR\t\t\tXSYRK_LN\n#define\tSYRK_LC\t\t\tXSYRK_LT\n\n#define\tSYRK_KERNEL_U\t\tXSYRK_KERNEL_U\n#define\tSYRK_KERNEL_L\t\tXSYRK_KERNEL_L\n\n#define\tHERK_UN\t\t\tXHERK_UN\n#define\tHERK_LN\t\t\tXHERK_LN\n#define\tHERK_UC\t\t\tXHERK_UC\n#define\tHERK_LC\t\t\tXHERK_LC\n\n#define\tHER2K_UN\t\tXHER2K_UN\n#define\tHER2K_LN\t\tXHER2K_LN\n#define\tHER2K_UC\t\tXHER2K_UC\n#define\tHER2K_LC\t\tXHER2K_LC\n\n#define\tSYR2K_UN\t\tXSYR2K_UN\n#define\tSYR2K_UT\t\tXSYR2K_UT\n#define\tSYR2K_LN\t\tXSYR2K_LN\n#define\tSYR2K_LT\t\tXSYR2K_LT\n#define\tSYR2K_UR\t\tXSYR2K_UN\n#define\tSYR2K_UC\t\tXSYR2K_UT\n#define\tSYR2K_LR\t\tXSYR2K_LN\n#define\tSYR2K_LC\t\tXSYR2K_LT\n\n#define\tSYR2K_KERNEL_U\t\tXSYR2K_KERNEL_U\n#define\tSYR2K_KERNEL_L\t\tXSYR2K_KERNEL_L\n\n#define\tTRMM_LNUU\t\tXTRMM_LNUU\n#define\tTRMM_LNUN\t\tXTRMM_LNUN\n#define\tTRMM_LNLU\t\tXTRMM_LNLU\n#define\tTRMM_LNLN\t\tXTRMM_LNLN\n#define\tTRMM_LTUU\t\tXTRMM_LTUU\n#define\tTRMM_LTUN\t\tXTRMM_LTUN\n#define\tTRMM_LTLU\t\tXTRMM_LTLU\n#define\tTRMM_LTLN\t\tXTRMM_LTLN\n#define\tTRMM_LRUU\t\tXTRMM_LRUU\n#define\tTRMM_LRUN\t\tXTRMM_LRUN\n#define\tTRMM_LRLU\t\tXTRMM_LRLU\n#define\tTRMM_LRLN\t\tXTRMM_LRLN\n#define\tTRMM_LCUU\t\tXTRMM_LCUU\n#define\tTRMM_LCUN\t\tXTRMM_LCUN\n#define\tTRMM_LCLU\t\tXTRMM_LCLU\n#define\tTRMM_LCLN\t\tXTRMM_LCLN\n#define\tTRMM_RNUU\t\tXTRMM_RNUU\n#define\tTRMM_RNUN\t\tXTRMM_RNUN\n#define\tTRMM_RNLU\t\tXTRMM_RNLU\n#define\tTRMM_RNLN\t\tXTRMM_RNLN\n#define\tTRMM_RTUU\t\tXTRMM_RTUU\n#define\tTRMM_RTUN\t\tXTRMM_RTUN\n#define\tTRMM_RTLU\t\tXTRMM_RTLU\n#define\tTRMM_RTLN\t\tXTRMM_RTLN\n#define\tTRMM_RRUU\t\tXTRMM_RRUU\n#define\tTRMM_RRUN\t\tXTRMM_RRUN\n#define\tTRMM_RRLU\t\tXTRMM_RRLU\n#define\tTRMM_RRLN\t\tXTRMM_RRLN\n#define\tTRMM_RCUU\t\tXTRMM_RCUU\n#define\tTRMM_RCUN\t\tXTRMM_RCUN\n#define\tTRMM_RCLU\t\tXTRMM_RCLU\n#define\tTRMM_RCLN\t\tXTRMM_RCLN\n\n#define\tTRSM_LNUU\t\tXTRSM_LNUU\n#define\tTRSM_LNUN\t\tXTRSM_LNUN\n#define\tTRSM_LNLU\t\tXTRSM_LNLU\n#define\tTRSM_LNLN\t\tXTRSM_LNLN\n#define\tTRSM_LTUU\t\tXTRSM_LTUU\n#define\tTRSM_LTUN\t\tXTRSM_LTUN\n#define\tTRSM_LTLU\t\tXTRSM_LTLU\n#define\tTRSM_LTLN\t\tXTRSM_LTLN\n#define\tTRSM_LRUU\t\tXTRSM_LRUU\n#define\tTRSM_LRUN\t\tXTRSM_LRUN\n#define\tTRSM_LRLU\t\tXTRSM_LRLU\n#define\tTRSM_LRLN\t\tXTRSM_LRLN\n#define\tTRSM_LCUU\t\tXTRSM_LCUU\n#define\tTRSM_LCUN\t\tXTRSM_LCUN\n#define\tTRSM_LCLU\t\tXTRSM_LCLU\n#define\tTRSM_LCLN\t\tXTRSM_LCLN\n#define\tTRSM_RNUU\t\tXTRSM_RNUU\n#define\tTRSM_RNUN\t\tXTRSM_RNUN\n#define\tTRSM_RNLU\t\tXTRSM_RNLU\n#define\tTRSM_RNLN\t\tXTRSM_RNLN\n#define\tTRSM_RTUU\t\tXTRSM_RTUU\n#define\tTRSM_RTUN\t\tXTRSM_RTUN\n#define\tTRSM_RTLU\t\tXTRSM_RTLU\n#define\tTRSM_RTLN\t\tXTRSM_RTLN\n#define\tTRSM_RRUU\t\tXTRSM_RRUU\n#define\tTRSM_RRUN\t\tXTRSM_RRUN\n#define\tTRSM_RRLU\t\tXTRSM_RRLU\n#define\tTRSM_RRLN\t\tXTRSM_RRLN\n#define\tTRSM_RCUU\t\tXTRSM_RCUU\n#define\tTRSM_RCUN\t\tXTRSM_RCUN\n#define\tTRSM_RCLU\t\tXTRSM_RCLU\n#define\tTRSM_RCLN\t\tXTRSM_RCLN\n\n\n#define\tGEMM_THREAD_NN\t\tXGEMM_THREAD_NN\n#define\tGEMM_THREAD_CN\t\tXGEMM_THREAD_CN\n#define\tGEMM_THREAD_TN\t\tXGEMM_THREAD_TN\n#define\tGEMM_THREAD_NC\t\tXGEMM_THREAD_NC\n#define\tGEMM_THREAD_NT\t\tXGEMM_THREAD_NT\n#define\tGEMM_THREAD_CC\t\tXGEMM_THREAD_CC\n#define\tGEMM_THREAD_CT\t\tXGEMM_THREAD_CT\n#define\tGEMM_THREAD_TC\t\tXGEMM_THREAD_TC\n#define\tGEMM_THREAD_TT\t\tXGEMM_THREAD_TT\n#define\tGEMM_THREAD_NR\t\tXGEMM_THREAD_NR\n#define\tGEMM_THREAD_TR\t\tXGEMM_THREAD_TR\n#define\tGEMM_THREAD_CR\t\tXGEMM_THREAD_CR\n#define\tGEMM_THREAD_RN\t\tXGEMM_THREAD_RN\n#define\tGEMM_THREAD_RT\t\tXGEMM_THREAD_RT\n#define\tGEMM_THREAD_RC\t\tXGEMM_THREAD_RC\n#define\tGEMM_THREAD_RR\t\tXGEMM_THREAD_RR\n\n#define\tSYMM_THREAD_LU\t\tXSYMM_THREAD_LU\n#define\tSYMM_THREAD_LL\t\tXSYMM_THREAD_LL\n#define\tSYMM_THREAD_RU\t\tXSYMM_THREAD_RU\n#define\tSYMM_THREAD_RL\t\tXSYMM_THREAD_RL\n\n#define\tHEMM_THREAD_LU\t\tXHEMM_THREAD_LU\n#define\tHEMM_THREAD_LL\t\tXHEMM_THREAD_LL\n#define\tHEMM_THREAD_RU\t\tXHEMM_THREAD_RU\n#define\tHEMM_THREAD_RL\t\tXHEMM_THREAD_RL\n\n#define\tSYRK_THREAD_UN\t\tXSYRK_THREAD_UN\n#define\tSYRK_THREAD_UT\t\tXSYRK_THREAD_UT\n#define\tSYRK_THREAD_LN\t\tXSYRK_THREAD_LN\n#define\tSYRK_THREAD_LT\t\tXSYRK_THREAD_LT\n#define\tSYRK_THREAD_UR\t\tXSYRK_THREAD_UR\n#define\tSYRK_THREAD_UC\t\tXSYRK_THREAD_UC\n#define\tSYRK_THREAD_LR\t\tXSYRK_THREAD_LR\n#define\tSYRK_THREAD_LC\t\tXSYRK_THREAD_LC\n\n#define\tHERK_THREAD_UN\t\tXHERK_THREAD_UN\n#define\tHERK_THREAD_UT\t\tXHERK_THREAD_UT\n#define\tHERK_THREAD_LN\t\tXHERK_THREAD_LN\n#define\tHERK_THREAD_LT\t\tXHERK_THREAD_LT\n#define\tHERK_THREAD_UR\t\tXHERK_THREAD_UR\n#define\tHERK_THREAD_UC\t\tXHERK_THREAD_UC\n#define\tHERK_THREAD_LR\t\tXHERK_THREAD_LR\n#define\tHERK_THREAD_LC\t\tXHERK_THREAD_LC\n\n#define\tGEMM3M_NN\t\tXGEMM3M_NN\n#define\tGEMM3M_CN\t\tXGEMM3M_CN\n#define\tGEMM3M_TN\t\tXGEMM3M_TN\n#define\tGEMM3M_NC\t\tXGEMM3M_NC\n#define\tGEMM3M_NT\t\tXGEMM3M_NT\n#define\tGEMM3M_CC\t\tXGEMM3M_CC\n#define\tGEMM3M_CT\t\tXGEMM3M_CT\n#define\tGEMM3M_TC\t\tXGEMM3M_TC\n#define\tGEMM3M_TT\t\tXGEMM3M_TT\n#define\tGEMM3M_NR\t\tXGEMM3M_NR\n#define\tGEMM3M_TR\t\tXGEMM3M_TR\n#define\tGEMM3M_CR\t\tXGEMM3M_CR\n#define\tGEMM3M_RN\t\tXGEMM3M_RN\n#define\tGEMM3M_RT\t\tXGEMM3M_RT\n#define\tGEMM3M_RC\t\tXGEMM3M_RC\n#define\tGEMM3M_RR\t\tXGEMM3M_RR\n\n#define\tGEMM3M_THREAD_NN\tXGEMM3M_THREAD_NN\n#define\tGEMM3M_THREAD_CN\tXGEMM3M_THREAD_CN\n#define\tGEMM3M_THREAD_TN\tXGEMM3M_THREAD_TN\n#define\tGEMM3M_THREAD_NC\tXGEMM3M_THREAD_NC\n#define\tGEMM3M_THREAD_NT\tXGEMM3M_THREAD_NT\n#define\tGEMM3M_THREAD_CC\tXGEMM3M_THREAD_CC\n#define\tGEMM3M_THREAD_CT\tXGEMM3M_THREAD_CT\n#define\tGEMM3M_THREAD_TC\tXGEMM3M_THREAD_TC\n#define\tGEMM3M_THREAD_TT\tXGEMM3M_THREAD_TT\n#define\tGEMM3M_THREAD_NR\tXGEMM3M_THREAD_NR\n#define\tGEMM3M_THREAD_TR\tXGEMM3M_THREAD_TR\n#define\tGEMM3M_THREAD_CR\tXGEMM3M_THREAD_CR\n#define\tGEMM3M_THREAD_RN\tXGEMM3M_THREAD_RN\n#define\tGEMM3M_THREAD_RT\tXGEMM3M_THREAD_RT\n#define\tGEMM3M_THREAD_RC\tXGEMM3M_THREAD_RC\n#define\tGEMM3M_THREAD_RR\tXGEMM3M_THREAD_RR\n\n#define\tSYMM3M_LU\t\tXSYMM3M_LU\n#define\tSYMM3M_LL\t\tXSYMM3M_LL\n#define\tSYMM3M_RU\t\tXSYMM3M_RU\n#define\tSYMM3M_RL\t\tXSYMM3M_RL\n\n#define\tSYMM3M_THREAD_LU\tXSYMM3M_THREAD_LU\n#define\tSYMM3M_THREAD_LL\tXSYMM3M_THREAD_LL\n#define\tSYMM3M_THREAD_RU\tXSYMM3M_THREAD_RU\n#define\tSYMM3M_THREAD_RL\tXSYMM3M_THREAD_RL\n\n#define\tHEMM3M_LU\t\tXHEMM3M_LU\n#define\tHEMM3M_LL\t\tXHEMM3M_LL\n#define\tHEMM3M_RU\t\tXHEMM3M_RU\n#define\tHEMM3M_RL\t\tXHEMM3M_RL\n\n#define\tHEMM3M_THREAD_LU\tXHEMM3M_THREAD_LU\n#define\tHEMM3M_THREAD_LL\tXHEMM3M_THREAD_LL\n#define\tHEMM3M_THREAD_RU\tXHEMM3M_THREAD_RU\n#define\tHEMM3M_THREAD_RL\tXHEMM3M_THREAD_RL\n\n#define SYMM_IUTCOPY\t\tXSYMM_IUTCOPY\n#define SYMM_ILTCOPY\t\tXSYMM_ILTCOPY\n#define SYMM_OUTCOPY\t\tXSYMM_OUTCOPY\n#define SYMM_OLTCOPY\t\tXSYMM_OLTCOPY\n\n#elif defined(DOUBLE)\n\n#define\tAMAX_K\t\t\tZAMAX_K\n#define\tAMIN_K\t\t\tZAMIN_K\n#define\tMAX_K\t\t\tZMAX_K\n#define\tMIN_K\t\t\tZMIN_K\n#define\tIAMAX_K\t\t\tIZAMAX_K\n#define\tIAMIN_K\t\t\tIZAMIN_K\n#define\tIMAX_K\t\t\tIZMAX_K\n#define\tIMIN_K\t\t\tIZMIN_K\n#define\tASUM_K\t\t\tZASUM_K\n#define\tAXPYU_K\t\t\tZAXPYU_K\n#define\tAXPYC_K\t\t\tZAXPYC_K\n#define\tCOPY_K\t\t\tZCOPY_K\n#define\tDOTU_K\t\t\tZDOTU_K\n#define\tDOTC_K\t\t\tZDOTC_K\n#define\tNRM2_K\t\t\tZNRM2_K\n#define\tSCAL_K\t\t\tZSCAL_K\n#define\tSUM_K\t\t\tZSUM_K\n#define\tSWAP_K\t\t\tZSWAP_K\n#define\tROT_K\t\t\tZROT_K\n\n#define\tGEMV_N\t\t\tZGEMV_N\n#define\tGEMV_T\t\t\tZGEMV_T\n#define\tGEMV_R\t\t\tZGEMV_R\n#define\tGEMV_C\t\t\tZGEMV_C\n#define\tGEMV_O\t\t\tZGEMV_O\n#define\tGEMV_U\t\t\tZGEMV_U\n#define\tGEMV_S\t\t\tZGEMV_S\n#define\tGEMV_D\t\t\tZGEMV_D\n\n#define\tGERU_K\t\t\tZGERU_K\n#define\tGERC_K\t\t\tZGERC_K\n#define\tGERV_K\t\t\tZGERV_K\n#define\tGERD_K\t\t\tZGERD_K\n\n#define\tSYMV_U\t\t\tZSYMV_U\n#define\tSYMV_L\t\t\tZSYMV_L\n#define\tHEMV_U\t\t\tZHEMV_U\n#define\tHEMV_L\t\t\tZHEMV_L\n#define\tHEMV_V\t\t\tZHEMV_V\n#define\tHEMV_M\t\t\tZHEMV_M\n\n#define\tSYMV_THREAD_U\t\tZSYMV_THREAD_U\n#define\tSYMV_THREAD_L\t\tZSYMV_THREAD_L\n#define\tHEMV_THREAD_U\t\tZHEMV_THREAD_U\n#define\tHEMV_THREAD_L\t\tZHEMV_THREAD_L\n#define\tHEMV_THREAD_V\t\tZHEMV_THREAD_V\n#define\tHEMV_THREAD_M\t\tZHEMV_THREAD_M\n\n#define\tGEMM_ONCOPY\t\tZGEMM_ONCOPY\n#define\tGEMM_OTCOPY\t\tZGEMM_OTCOPY\n#define\tGEMM_INCOPY\t\tZGEMM_INCOPY\n#define\tGEMM_ITCOPY\t\tZGEMM_ITCOPY\n\n#define\tGEMM3M_ONCOPYB\t\tZGEMM3M_ONCOPYB\n#define\tGEMM3M_ONCOPYR\t\tZGEMM3M_ONCOPYR\n#define\tGEMM3M_ONCOPYI\t\tZGEMM3M_ONCOPYI\n#define\tGEMM3M_OTCOPYB\t\tZGEMM3M_OTCOPYB\n#define\tGEMM3M_OTCOPYR\t\tZGEMM3M_OTCOPYR\n#define\tGEMM3M_OTCOPYI\t\tZGEMM3M_OTCOPYI\n#define\tGEMM3M_INCOPYB\t\tZGEMM3M_INCOPYB\n#define\tGEMM3M_INCOPYR\t\tZGEMM3M_INCOPYR\n#define\tGEMM3M_INCOPYI\t\tZGEMM3M_INCOPYI\n#define\tGEMM3M_ITCOPYB\t\tZGEMM3M_ITCOPYB\n#define\tGEMM3M_ITCOPYR\t\tZGEMM3M_ITCOPYR\n#define\tGEMM3M_ITCOPYI\t\tZGEMM3M_ITCOPYI\n\n#ifdef UNIT\n\n#define\tTRMM_OUNCOPY\t\tZTRMM_OUNUCOPY\n#define\tTRMM_OUTCOPY\t\tZTRMM_OUTUCOPY\n#define\tTRMM_OLNCOPY\t\tZTRMM_OLNUCOPY\n#define\tTRMM_OLTCOPY\t\tZTRMM_OLTUCOPY\n#define\tTRSM_OUNCOPY\t\tZTRSM_OUNUCOPY\n#define\tTRSM_OUTCOPY\t\tZTRSM_OUTUCOPY\n#define\tTRSM_OLNCOPY\t\tZTRSM_OLNUCOPY\n#define\tTRSM_OLTCOPY\t\tZTRSM_OLTUCOPY\n\n#define\tTRMM_IUNCOPY\t\tZTRMM_IUNUCOPY\n#define\tTRMM_IUTCOPY\t\tZTRMM_IUTUCOPY\n#define\tTRMM_ILNCOPY\t\tZTRMM_ILNUCOPY\n#define\tTRMM_ILTCOPY\t\tZTRMM_ILTUCOPY\n#define\tTRSM_IUNCOPY\t\tZTRSM_IUNUCOPY\n#define\tTRSM_IUTCOPY\t\tZTRSM_IUTUCOPY\n#define\tTRSM_ILNCOPY\t\tZTRSM_ILNUCOPY\n#define\tTRSM_ILTCOPY\t\tZTRSM_ILTUCOPY\n\n#else\n\n#define\tTRMM_OUNCOPY\t\tZTRMM_OUNNCOPY\n#define\tTRMM_OUTCOPY\t\tZTRMM_OUTNCOPY\n#define\tTRMM_OLNCOPY\t\tZTRMM_OLNNCOPY\n#define\tTRMM_OLTCOPY\t\tZTRMM_OLTNCOPY\n#define\tTRSM_OUNCOPY\t\tZTRSM_OUNNCOPY\n#define\tTRSM_OUTCOPY\t\tZTRSM_OUTNCOPY\n#define\tTRSM_OLNCOPY\t\tZTRSM_OLNNCOPY\n#define\tTRSM_OLTCOPY\t\tZTRSM_OLTNCOPY\n\n#define\tTRMM_IUNCOPY\t\tZTRMM_IUNNCOPY\n#define\tTRMM_IUTCOPY\t\tZTRMM_IUTNCOPY\n#define\tTRMM_ILNCOPY\t\tZTRMM_ILNNCOPY\n#define\tTRMM_ILTCOPY\t\tZTRMM_ILTNCOPY\n#define\tTRSM_IUNCOPY\t\tZTRSM_IUNNCOPY\n#define\tTRSM_IUTCOPY\t\tZTRSM_IUTNCOPY\n#define\tTRSM_ILNCOPY\t\tZTRSM_ILNNCOPY\n#define\tTRSM_ILTCOPY\t\tZTRSM_ILTNCOPY\n\n#endif\n\n#define\tSYMM3M_ILCOPYB\t\tZSYMM3M_ILCOPYB\n#define\tSYMM3M_IUCOPYB\t\tZSYMM3M_IUCOPYB\n#define\tSYMM3M_ILCOPYR\t\tZSYMM3M_ILCOPYR\n#define\tSYMM3M_IUCOPYR\t\tZSYMM3M_IUCOPYR\n#define\tSYMM3M_ILCOPYI\t\tZSYMM3M_ILCOPYI\n#define\tSYMM3M_IUCOPYI\t\tZSYMM3M_IUCOPYI\n\n#define\tSYMM3M_OLCOPYB\t\tZSYMM3M_OLCOPYB\n#define\tSYMM3M_OUCOPYB\t\tZSYMM3M_OUCOPYB\n#define\tSYMM3M_OLCOPYR\t\tZSYMM3M_OLCOPYR\n#define\tSYMM3M_OUCOPYR\t\tZSYMM3M_OUCOPYR\n#define\tSYMM3M_OLCOPYI\t\tZSYMM3M_OLCOPYI\n#define\tSYMM3M_OUCOPYI\t\tZSYMM3M_OUCOPYI\n\n#define\tHEMM3M_ILCOPYB\t\tZHEMM3M_ILCOPYB\n#define\tHEMM3M_IUCOPYB\t\tZHEMM3M_IUCOPYB\n#define\tHEMM3M_ILCOPYR\t\tZHEMM3M_ILCOPYR\n#define\tHEMM3M_IUCOPYR\t\tZHEMM3M_IUCOPYR\n#define\tHEMM3M_ILCOPYI\t\tZHEMM3M_ILCOPYI\n#define\tHEMM3M_IUCOPYI\t\tZHEMM3M_IUCOPYI\n\n#define\tHEMM3M_OLCOPYB\t\tZHEMM3M_OLCOPYB\n#define\tHEMM3M_OUCOPYB\t\tZHEMM3M_OUCOPYB\n#define\tHEMM3M_OLCOPYR\t\tZHEMM3M_OLCOPYR\n#define\tHEMM3M_OUCOPYR\t\tZHEMM3M_OUCOPYR\n#define\tHEMM3M_OLCOPYI\t\tZHEMM3M_OLCOPYI\n#define\tHEMM3M_OUCOPYI\t\tZHEMM3M_OUCOPYI\n\n#define\tGEMM_BETA\t\tZGEMM_BETA\n\n#define\tGEMM_KERNEL_N\t\tZGEMM_KERNEL_N\n#define\tGEMM_KERNEL_L\t\tZGEMM_KERNEL_L\n#define\tGEMM_KERNEL_R\t\tZGEMM_KERNEL_R\n#define\tGEMM_KERNEL_B\t\tZGEMM_KERNEL_B\n\n#define\tGEMM3M_KERNEL\t\tZGEMM3M_KERNEL\n\n#define\tTRMM_KERNEL_LN\t\tZTRMM_KERNEL_LN\n#define\tTRMM_KERNEL_LT\t\tZTRMM_KERNEL_LT\n#define\tTRMM_KERNEL_LR\t\tZTRMM_KERNEL_LR\n#define\tTRMM_KERNEL_LC\t\tZTRMM_KERNEL_LC\n#define\tTRMM_KERNEL_RN\t\tZTRMM_KERNEL_RN\n#define\tTRMM_KERNEL_RT\t\tZTRMM_KERNEL_RT\n#define\tTRMM_KERNEL_RR\t\tZTRMM_KERNEL_RR\n#define\tTRMM_KERNEL_RC\t\tZTRMM_KERNEL_RC\n\n#define\tTRSM_KERNEL_LN\t\tZTRSM_KERNEL_LN\n#define\tTRSM_KERNEL_LT\t\tZTRSM_KERNEL_LT\n#define\tTRSM_KERNEL_LR\t\tZTRSM_KERNEL_LR\n#define\tTRSM_KERNEL_LC\t\tZTRSM_KERNEL_LC\n#define\tTRSM_KERNEL_RN\t\tZTRSM_KERNEL_RN\n#define\tTRSM_KERNEL_RT\t\tZTRSM_KERNEL_RT\n#define\tTRSM_KERNEL_RR\t\tZTRSM_KERNEL_RR\n#define\tTRSM_KERNEL_RC\t\tZTRSM_KERNEL_RC\n\n#define\tGEMM_NN\t\t\tZGEMM_NN\n#define\tGEMM_CN\t\t\tZGEMM_CN\n#define\tGEMM_TN\t\t\tZGEMM_TN\n#define\tGEMM_NC\t\t\tZGEMM_NC\n#define\tGEMM_NT\t\t\tZGEMM_NT\n#define\tGEMM_CC\t\t\tZGEMM_CC\n#define\tGEMM_CT\t\t\tZGEMM_CT\n#define\tGEMM_TC\t\t\tZGEMM_TC\n#define\tGEMM_TT\t\t\tZGEMM_TT\n#define\tGEMM_NR\t\t\tZGEMM_NR\n#define\tGEMM_TR\t\t\tZGEMM_TR\n#define\tGEMM_CR\t\t\tZGEMM_CR\n#define\tGEMM_RN\t\t\tZGEMM_RN\n#define\tGEMM_RT\t\t\tZGEMM_RT\n#define\tGEMM_RC\t\t\tZGEMM_RC\n#define\tGEMM_RR\t\t\tZGEMM_RR\n\n#define\tSYMM_LU\t\t\tZSYMM_LU\n#define\tSYMM_LL\t\t\tZSYMM_LL\n#define\tSYMM_RU\t\t\tZSYMM_RU\n#define\tSYMM_RL\t\t\tZSYMM_RL\n\n#define\tHEMM_LU\t\t\tZHEMM_LU\n#define\tHEMM_LL\t\t\tZHEMM_LL\n#define\tHEMM_RU\t\t\tZHEMM_RU\n#define\tHEMM_RL\t\t\tZHEMM_RL\n\n#define HEMM_IUTCOPY\t\tZHEMM_IUTCOPY\n#define HEMM_ILTCOPY\t\tZHEMM_ILTCOPY\n#define HEMM_OUTCOPY\t\tZHEMM_OUTCOPY\n#define HEMM_OLTCOPY\t\tZHEMM_OLTCOPY\n\n#define\tSYRK_UN\t\t\tZSYRK_UN\n#define\tSYRK_UT\t\t\tZSYRK_UT\n#define\tSYRK_LN\t\t\tZSYRK_LN\n#define\tSYRK_LT\t\t\tZSYRK_LT\n#define\tSYRK_UR\t\t\tZSYRK_UN\n#define\tSYRK_UC\t\t\tZSYRK_UT\n#define\tSYRK_LR\t\t\tZSYRK_LN\n#define\tSYRK_LC\t\t\tZSYRK_LT\n\n#define\tSYRK_KERNEL_U\t\tZSYRK_KERNEL_U\n#define\tSYRK_KERNEL_L\t\tZSYRK_KERNEL_L\n\n#define\tHERK_UN\t\t\tZHERK_UN\n#define\tHERK_LN\t\t\tZHERK_LN\n#define\tHERK_UC\t\t\tZHERK_UC\n#define\tHERK_LC\t\t\tZHERK_LC\n\n#define\tHER2K_UN\t\tZHER2K_UN\n#define\tHER2K_LN\t\tZHER2K_LN\n#define\tHER2K_UC\t\tZHER2K_UC\n#define\tHER2K_LC\t\tZHER2K_LC\n\n#define\tSYR2K_UN\t\tZSYR2K_UN\n#define\tSYR2K_UT\t\tZSYR2K_UT\n#define\tSYR2K_LN\t\tZSYR2K_LN\n#define\tSYR2K_LT\t\tZSYR2K_LT\n#define\tSYR2K_UR\t\tZSYR2K_UN\n#define\tSYR2K_UC\t\tZSYR2K_UT\n#define\tSYR2K_LR\t\tZSYR2K_LN\n#define\tSYR2K_LC\t\tZSYR2K_LT\n\n#define\tSYR2K_KERNEL_U\t\tZSYR2K_KERNEL_U\n#define\tSYR2K_KERNEL_L\t\tZSYR2K_KERNEL_L\n\n#define\tTRMM_LNUU\t\tZTRMM_LNUU\n#define\tTRMM_LNUN\t\tZTRMM_LNUN\n#define\tTRMM_LNLU\t\tZTRMM_LNLU\n#define\tTRMM_LNLN\t\tZTRMM_LNLN\n#define\tTRMM_LTUU\t\tZTRMM_LTUU\n#define\tTRMM_LTUN\t\tZTRMM_LTUN\n#define\tTRMM_LTLU\t\tZTRMM_LTLU\n#define\tTRMM_LTLN\t\tZTRMM_LTLN\n#define\tTRMM_LRUU\t\tZTRMM_LRUU\n#define\tTRMM_LRUN\t\tZTRMM_LRUN\n#define\tTRMM_LRLU\t\tZTRMM_LRLU\n#define\tTRMM_LRLN\t\tZTRMM_LRLN\n#define\tTRMM_LCUU\t\tZTRMM_LCUU\n#define\tTRMM_LCUN\t\tZTRMM_LCUN\n#define\tTRMM_LCLU\t\tZTRMM_LCLU\n#define\tTRMM_LCLN\t\tZTRMM_LCLN\n#define\tTRMM_RNUU\t\tZTRMM_RNUU\n#define\tTRMM_RNUN\t\tZTRMM_RNUN\n#define\tTRMM_RNLU\t\tZTRMM_RNLU\n#define\tTRMM_RNLN\t\tZTRMM_RNLN\n#define\tTRMM_RTUU\t\tZTRMM_RTUU\n#define\tTRMM_RTUN\t\tZTRMM_RTUN\n#define\tTRMM_RTLU\t\tZTRMM_RTLU\n#define\tTRMM_RTLN\t\tZTRMM_RTLN\n#define\tTRMM_RRUU\t\tZTRMM_RRUU\n#define\tTRMM_RRUN\t\tZTRMM_RRUN\n#define\tTRMM_RRLU\t\tZTRMM_RRLU\n#define\tTRMM_RRLN\t\tZTRMM_RRLN\n#define\tTRMM_RCUU\t\tZTRMM_RCUU\n#define\tTRMM_RCUN\t\tZTRMM_RCUN\n#define\tTRMM_RCLU\t\tZTRMM_RCLU\n#define\tTRMM_RCLN\t\tZTRMM_RCLN\n\n#define\tTRSM_LNUU\t\tZTRSM_LNUU\n#define\tTRSM_LNUN\t\tZTRSM_LNUN\n#define\tTRSM_LNLU\t\tZTRSM_LNLU\n#define\tTRSM_LNLN\t\tZTRSM_LNLN\n#define\tTRSM_LTUU\t\tZTRSM_LTUU\n#define\tTRSM_LTUN\t\tZTRSM_LTUN\n#define\tTRSM_LTLU\t\tZTRSM_LTLU\n#define\tTRSM_LTLN\t\tZTRSM_LTLN\n#define\tTRSM_LRUU\t\tZTRSM_LRUU\n#define\tTRSM_LRUN\t\tZTRSM_LRUN\n#define\tTRSM_LRLU\t\tZTRSM_LRLU\n#define\tTRSM_LRLN\t\tZTRSM_LRLN\n#define\tTRSM_LCUU\t\tZTRSM_LCUU\n#define\tTRSM_LCUN\t\tZTRSM_LCUN\n#define\tTRSM_LCLU\t\tZTRSM_LCLU\n#define\tTRSM_LCLN\t\tZTRSM_LCLN\n#define\tTRSM_RNUU\t\tZTRSM_RNUU\n#define\tTRSM_RNUN\t\tZTRSM_RNUN\n#define\tTRSM_RNLU\t\tZTRSM_RNLU\n#define\tTRSM_RNLN\t\tZTRSM_RNLN\n#define\tTRSM_RTUU\t\tZTRSM_RTUU\n#define\tTRSM_RTUN\t\tZTRSM_RTUN\n#define\tTRSM_RTLU\t\tZTRSM_RTLU\n#define\tTRSM_RTLN\t\tZTRSM_RTLN\n#define\tTRSM_RRUU\t\tZTRSM_RRUU\n#define\tTRSM_RRUN\t\tZTRSM_RRUN\n#define\tTRSM_RRLU\t\tZTRSM_RRLU\n#define\tTRSM_RRLN\t\tZTRSM_RRLN\n#define\tTRSM_RCUU\t\tZTRSM_RCUU\n#define\tTRSM_RCUN\t\tZTRSM_RCUN\n#define\tTRSM_RCLU\t\tZTRSM_RCLU\n#define\tTRSM_RCLN\t\tZTRSM_RCLN\n\n\n#define\tGEMM_THREAD_NN\t\tZGEMM_THREAD_NN\n#define\tGEMM_THREAD_CN\t\tZGEMM_THREAD_CN\n#define\tGEMM_THREAD_TN\t\tZGEMM_THREAD_TN\n#define\tGEMM_THREAD_NC\t\tZGEMM_THREAD_NC\n#define\tGEMM_THREAD_NT\t\tZGEMM_THREAD_NT\n#define\tGEMM_THREAD_CC\t\tZGEMM_THREAD_CC\n#define\tGEMM_THREAD_CT\t\tZGEMM_THREAD_CT\n#define\tGEMM_THREAD_TC\t\tZGEMM_THREAD_TC\n#define\tGEMM_THREAD_TT\t\tZGEMM_THREAD_TT\n#define\tGEMM_THREAD_NR\t\tZGEMM_THREAD_NR\n#define\tGEMM_THREAD_TR\t\tZGEMM_THREAD_TR\n#define\tGEMM_THREAD_CR\t\tZGEMM_THREAD_CR\n#define\tGEMM_THREAD_RN\t\tZGEMM_THREAD_RN\n#define\tGEMM_THREAD_RT\t\tZGEMM_THREAD_RT\n#define\tGEMM_THREAD_RC\t\tZGEMM_THREAD_RC\n#define\tGEMM_THREAD_RR\t\tZGEMM_THREAD_RR\n\n#define\tSYMM_THREAD_LU\t\tZSYMM_THREAD_LU\n#define\tSYMM_THREAD_LL\t\tZSYMM_THREAD_LL\n#define\tSYMM_THREAD_RU\t\tZSYMM_THREAD_RU\n#define\tSYMM_THREAD_RL\t\tZSYMM_THREAD_RL\n\n#define\tHEMM_THREAD_LU\t\tZHEMM_THREAD_LU\n#define\tHEMM_THREAD_LL\t\tZHEMM_THREAD_LL\n#define\tHEMM_THREAD_RU\t\tZHEMM_THREAD_RU\n#define\tHEMM_THREAD_RL\t\tZHEMM_THREAD_RL\n\n#define\tSYRK_THREAD_UN\t\tZSYRK_THREAD_UN\n#define\tSYRK_THREAD_UT\t\tZSYRK_THREAD_UT\n#define\tSYRK_THREAD_LN\t\tZSYRK_THREAD_LN\n#define\tSYRK_THREAD_LT\t\tZSYRK_THREAD_LT\n#define\tSYRK_THREAD_UR\t\tZSYRK_THREAD_UR\n#define\tSYRK_THREAD_UC\t\tZSYRK_THREAD_UC\n#define\tSYRK_THREAD_LR\t\tZSYRK_THREAD_LR\n#define\tSYRK_THREAD_LC\t\tZSYRK_THREAD_LC\n\n#define\tHERK_THREAD_UN\t\tZHERK_THREAD_UN\n#define\tHERK_THREAD_UT\t\tZHERK_THREAD_UT\n#define\tHERK_THREAD_LN\t\tZHERK_THREAD_LN\n#define\tHERK_THREAD_LT\t\tZHERK_THREAD_LT\n#define\tHERK_THREAD_UR\t\tZHERK_THREAD_UR\n#define\tHERK_THREAD_UC\t\tZHERK_THREAD_UC\n#define\tHERK_THREAD_LR\t\tZHERK_THREAD_LR\n#define\tHERK_THREAD_LC\t\tZHERK_THREAD_LC\n\n#define\tGEMM3M_NN\t\tZGEMM3M_NN\n#define\tGEMM3M_CN\t\tZGEMM3M_CN\n#define\tGEMM3M_TN\t\tZGEMM3M_TN\n#define\tGEMM3M_NC\t\tZGEMM3M_NC\n#define\tGEMM3M_NT\t\tZGEMM3M_NT\n#define\tGEMM3M_CC\t\tZGEMM3M_CC\n#define\tGEMM3M_CT\t\tZGEMM3M_CT\n#define\tGEMM3M_TC\t\tZGEMM3M_TC\n#define\tGEMM3M_TT\t\tZGEMM3M_TT\n#define\tGEMM3M_NR\t\tZGEMM3M_NR\n#define\tGEMM3M_TR\t\tZGEMM3M_TR\n#define\tGEMM3M_CR\t\tZGEMM3M_CR\n#define\tGEMM3M_RN\t\tZGEMM3M_RN\n#define\tGEMM3M_RT\t\tZGEMM3M_RT\n#define\tGEMM3M_RC\t\tZGEMM3M_RC\n#define\tGEMM3M_RR\t\tZGEMM3M_RR\n\n#define\tGEMM3M_THREAD_NN\tZGEMM3M_THREAD_NN\n#define\tGEMM3M_THREAD_CN\tZGEMM3M_THREAD_CN\n#define\tGEMM3M_THREAD_TN\tZGEMM3M_THREAD_TN\n#define\tGEMM3M_THREAD_NC\tZGEMM3M_THREAD_NC\n#define\tGEMM3M_THREAD_NT\tZGEMM3M_THREAD_NT\n#define\tGEMM3M_THREAD_CC\tZGEMM3M_THREAD_CC\n#define\tGEMM3M_THREAD_CT\tZGEMM3M_THREAD_CT\n#define\tGEMM3M_THREAD_TC\tZGEMM3M_THREAD_TC\n#define\tGEMM3M_THREAD_TT\tZGEMM3M_THREAD_TT\n#define\tGEMM3M_THREAD_NR\tZGEMM3M_THREAD_NR\n#define\tGEMM3M_THREAD_TR\tZGEMM3M_THREAD_TR\n#define\tGEMM3M_THREAD_CR\tZGEMM3M_THREAD_CR\n#define\tGEMM3M_THREAD_RN\tZGEMM3M_THREAD_RN\n#define\tGEMM3M_THREAD_RT\tZGEMM3M_THREAD_RT\n#define\tGEMM3M_THREAD_RC\tZGEMM3M_THREAD_RC\n#define\tGEMM3M_THREAD_RR\tZGEMM3M_THREAD_RR\n\n#define\tSYMM3M_LU\t\tZSYMM3M_LU\n#define\tSYMM3M_LL\t\tZSYMM3M_LL\n#define\tSYMM3M_RU\t\tZSYMM3M_RU\n#define\tSYMM3M_RL\t\tZSYMM3M_RL\n\n#define\tSYMM3M_THREAD_LU\tZSYMM3M_THREAD_LU\n#define\tSYMM3M_THREAD_LL\tZSYMM3M_THREAD_LL\n#define\tSYMM3M_THREAD_RU\tZSYMM3M_THREAD_RU\n#define\tSYMM3M_THREAD_RL\tZSYMM3M_THREAD_RL\n\n#define\tHEMM3M_LU\t\tZHEMM3M_LU\n#define\tHEMM3M_LL\t\tZHEMM3M_LL\n#define\tHEMM3M_RU\t\tZHEMM3M_RU\n#define\tHEMM3M_RL\t\tZHEMM3M_RL\n\n#define\tHEMM3M_THREAD_LU\tZHEMM3M_THREAD_LU\n#define\tHEMM3M_THREAD_LL\tZHEMM3M_THREAD_LL\n#define\tHEMM3M_THREAD_RU\tZHEMM3M_THREAD_RU\n#define\tHEMM3M_THREAD_RL\tZHEMM3M_THREAD_RL\n\n#define SYMM_IUTCOPY\t\tZSYMM_IUTCOPY\n#define SYMM_ILTCOPY\t\tZSYMM_ILTCOPY\n#define SYMM_OUTCOPY\t\tZSYMM_OUTCOPY\n#define SYMM_OLTCOPY\t\tZSYMM_OLTCOPY\n\n#define AXPBY_K                 ZAXPBY_K\n\n#define OMATCOPY_K_CN\t\tZOMATCOPY_K_CN\n#define OMATCOPY_K_RN\t\tZOMATCOPY_K_RN\n#define OMATCOPY_K_CT\t\tZOMATCOPY_K_CT\n#define OMATCOPY_K_RT\t\tZOMATCOPY_K_RT\n#define OMATCOPY_K_CNC\t\tZOMATCOPY_K_CNC\n#define OMATCOPY_K_RNC\t\tZOMATCOPY_K_RNC\n#define OMATCOPY_K_CTC\t\tZOMATCOPY_K_CTC\n#define OMATCOPY_K_RTC\t\tZOMATCOPY_K_RTC\n#define IMATCOPY_K_CN\t\tZIMATCOPY_K_CN\n#define IMATCOPY_K_RN\t\tZIMATCOPY_K_RN\n#define IMATCOPY_K_CT\t\tZIMATCOPY_K_CT\n#define IMATCOPY_K_RT\t\tZIMATCOPY_K_RT\n#define IMATCOPY_K_CNC\t\tZIMATCOPY_K_CNC\n#define IMATCOPY_K_RNC\t\tZIMATCOPY_K_RNC\n#define IMATCOPY_K_CTC\t\tZIMATCOPY_K_CTC\n#define IMATCOPY_K_RTC\t\tZIMATCOPY_K_RTC\n\n#define GEADD_K                 ZGEADD_K\n\n#define GEMM_SMALL_MATRIX_PERMIT\tZGEMM_SMALL_MATRIX_PERMIT\n\n#define GEMM_SMALL_KERNEL_NN    ZGEMM_SMALL_KERNEL_NN\n#define GEMM_SMALL_KERNEL_NT    ZGEMM_SMALL_KERNEL_NT\n#define GEMM_SMALL_KERNEL_NR    ZGEMM_SMALL_KERNEL_NR\n#define GEMM_SMALL_KERNEL_NC    ZGEMM_SMALL_KERNEL_NC\n\n#define GEMM_SMALL_KERNEL_TN    ZGEMM_SMALL_KERNEL_TN\n#define GEMM_SMALL_KERNEL_TT    ZGEMM_SMALL_KERNEL_TT\n#define GEMM_SMALL_KERNEL_TR    ZGEMM_SMALL_KERNEL_TR\n#define GEMM_SMALL_KERNEL_TC    ZGEMM_SMALL_KERNEL_TC\n\n#define GEMM_SMALL_KERNEL_RN    ZGEMM_SMALL_KERNEL_RN\n#define GEMM_SMALL_KERNEL_RT    ZGEMM_SMALL_KERNEL_RT\n#define GEMM_SMALL_KERNEL_RR    ZGEMM_SMALL_KERNEL_RR\n#define GEMM_SMALL_KERNEL_RC    ZGEMM_SMALL_KERNEL_RC\n\n#define GEMM_SMALL_KERNEL_CN    ZGEMM_SMALL_KERNEL_CN\n#define GEMM_SMALL_KERNEL_CT    ZGEMM_SMALL_KERNEL_CT\n#define GEMM_SMALL_KERNEL_CR    ZGEMM_SMALL_KERNEL_CR\n#define GEMM_SMALL_KERNEL_CC    ZGEMM_SMALL_KERNEL_CC\n\n#define GEMM_SMALL_KERNEL_B0_NN    ZGEMM_SMALL_KERNEL_B0_NN\n#define GEMM_SMALL_KERNEL_B0_NT    ZGEMM_SMALL_KERNEL_B0_NT\n#define GEMM_SMALL_KERNEL_B0_NR    ZGEMM_SMALL_KERNEL_B0_NR\n#define GEMM_SMALL_KERNEL_B0_NC    ZGEMM_SMALL_KERNEL_B0_NC\n\n#define GEMM_SMALL_KERNEL_B0_TN    ZGEMM_SMALL_KERNEL_B0_TN\n#define GEMM_SMALL_KERNEL_B0_TT    ZGEMM_SMALL_KERNEL_B0_TT\n#define GEMM_SMALL_KERNEL_B0_TR    ZGEMM_SMALL_KERNEL_B0_TR\n#define GEMM_SMALL_KERNEL_B0_TC    ZGEMM_SMALL_KERNEL_B0_TC\n\n#define GEMM_SMALL_KERNEL_B0_RN    ZGEMM_SMALL_KERNEL_B0_RN\n#define GEMM_SMALL_KERNEL_B0_RT    ZGEMM_SMALL_KERNEL_B0_RT\n#define GEMM_SMALL_KERNEL_B0_RR    ZGEMM_SMALL_KERNEL_B0_RR\n#define GEMM_SMALL_KERNEL_B0_RC    ZGEMM_SMALL_KERNEL_B0_RC\n\n#define GEMM_SMALL_KERNEL_B0_CN    ZGEMM_SMALL_KERNEL_B0_CN\n#define GEMM_SMALL_KERNEL_B0_CT    ZGEMM_SMALL_KERNEL_B0_CT\n#define GEMM_SMALL_KERNEL_B0_CR    ZGEMM_SMALL_KERNEL_B0_CR\n#define GEMM_SMALL_KERNEL_B0_CC    ZGEMM_SMALL_KERNEL_B0_CC\n\n#else\n\n#define\tAMAX_K\t\t\tCAMAX_K\n#define\tAMIN_K\t\t\tCAMIN_K\n#define\tMAX_K\t\t\tCMAX_K\n#define\tMIN_K\t\t\tCMIN_K\n#define\tIAMAX_K\t\t\tICAMAX_K\n#define\tIAMIN_K\t\t\tICAMIN_K\n#define\tIMAX_K\t\t\tICMAX_K\n#define\tIMIN_K\t\t\tICMIN_K\n#define\tASUM_K\t\t\tCASUM_K\n#define\tAXPYU_K\t\t\tCAXPYU_K\n#define\tAXPYC_K\t\t\tCAXPYC_K\n#define\tCOPY_K\t\t\tCCOPY_K\n#define\tDOTU_K\t\t\tCDOTU_K\n#define\tDOTC_K\t\t\tCDOTC_K\n#define\tNRM2_K\t\t\tCNRM2_K\n#define\tSCAL_K\t\t\tCSCAL_K\n#define\tSUM_K\t\t\tCSUM_K\n#define\tSWAP_K\t\t\tCSWAP_K\n#define\tROT_K\t\t\tCROT_K\n\n#define\tGEMV_N\t\t\tCGEMV_N\n#define\tGEMV_T\t\t\tCGEMV_T\n#define\tGEMV_R\t\t\tCGEMV_R\n#define\tGEMV_C\t\t\tCGEMV_C\n#define\tGEMV_O\t\t\tCGEMV_O\n#define\tGEMV_U\t\t\tCGEMV_U\n#define\tGEMV_S\t\t\tCGEMV_S\n#define\tGEMV_D\t\t\tCGEMV_D\n\n#define\tGERU_K\t\t\tCGERU_K\n#define\tGERC_K\t\t\tCGERC_K\n#define\tGERV_K\t\t\tCGERV_K\n#define\tGERD_K\t\t\tCGERD_K\n\n#define\tSYMV_U\t\t\tCSYMV_U\n#define\tSYMV_L\t\t\tCSYMV_L\n#define\tHEMV_U\t\t\tCHEMV_U\n#define\tHEMV_L\t\t\tCHEMV_L\n#define\tHEMV_V\t\t\tCHEMV_V\n#define\tHEMV_M\t\t\tCHEMV_M\n\n#define\tSYMV_THREAD_U\t\tCSYMV_THREAD_U\n#define\tSYMV_THREAD_L\t\tCSYMV_THREAD_L\n#define\tHEMV_THREAD_U\t\tCHEMV_THREAD_U\n#define\tHEMV_THREAD_L\t\tCHEMV_THREAD_L\n#define\tHEMV_THREAD_V\t\tCHEMV_THREAD_V\n#define\tHEMV_THREAD_M\t\tCHEMV_THREAD_M\n\n#define\tGEMM_ONCOPY\t\tCGEMM_ONCOPY\n#define\tGEMM_OTCOPY\t\tCGEMM_OTCOPY\n#define\tGEMM_INCOPY\t\tCGEMM_INCOPY\n#define\tGEMM_ITCOPY\t\tCGEMM_ITCOPY\n\n#define\tGEMM3M_ONCOPYB\t\tCGEMM3M_ONCOPYB\n#define\tGEMM3M_ONCOPYR\t\tCGEMM3M_ONCOPYR\n#define\tGEMM3M_ONCOPYI\t\tCGEMM3M_ONCOPYI\n#define\tGEMM3M_OTCOPYB\t\tCGEMM3M_OTCOPYB\n#define\tGEMM3M_OTCOPYR\t\tCGEMM3M_OTCOPYR\n#define\tGEMM3M_OTCOPYI\t\tCGEMM3M_OTCOPYI\n#define\tGEMM3M_INCOPYB\t\tCGEMM3M_INCOPYB\n#define\tGEMM3M_INCOPYR\t\tCGEMM3M_INCOPYR\n#define\tGEMM3M_INCOPYI\t\tCGEMM3M_INCOPYI\n#define\tGEMM3M_ITCOPYB\t\tCGEMM3M_ITCOPYB\n#define\tGEMM3M_ITCOPYR\t\tCGEMM3M_ITCOPYR\n#define\tGEMM3M_ITCOPYI\t\tCGEMM3M_ITCOPYI\n\n#ifdef UNIT\n\n#define\tTRMM_OUNCOPY\t\tCTRMM_OUNUCOPY\n#define\tTRMM_OUTCOPY\t\tCTRMM_OUTUCOPY\n#define\tTRMM_OLNCOPY\t\tCTRMM_OLNUCOPY\n#define\tTRMM_OLTCOPY\t\tCTRMM_OLTUCOPY\n#define\tTRSM_OUNCOPY\t\tCTRSM_OUNUCOPY\n#define\tTRSM_OUTCOPY\t\tCTRSM_OUTUCOPY\n#define\tTRSM_OLNCOPY\t\tCTRSM_OLNUCOPY\n#define\tTRSM_OLTCOPY\t\tCTRSM_OLTUCOPY\n\n#define\tTRMM_IUNCOPY\t\tCTRMM_IUNUCOPY\n#define\tTRMM_IUTCOPY\t\tCTRMM_IUTUCOPY\n#define\tTRMM_ILNCOPY\t\tCTRMM_ILNUCOPY\n#define\tTRMM_ILTCOPY\t\tCTRMM_ILTUCOPY\n#define\tTRSM_IUNCOPY\t\tCTRSM_IUNUCOPY\n#define\tTRSM_IUTCOPY\t\tCTRSM_IUTUCOPY\n#define\tTRSM_ILNCOPY\t\tCTRSM_ILNUCOPY\n#define\tTRSM_ILTCOPY\t\tCTRSM_ILTUCOPY\n\n#else\n\n#define\tTRMM_OUNCOPY\t\tCTRMM_OUNNCOPY\n#define\tTRMM_OUTCOPY\t\tCTRMM_OUTNCOPY\n#define\tTRMM_OLNCOPY\t\tCTRMM_OLNNCOPY\n#define\tTRMM_OLTCOPY\t\tCTRMM_OLTNCOPY\n#define\tTRSM_OUNCOPY\t\tCTRSM_OUNNCOPY\n#define\tTRSM_OUTCOPY\t\tCTRSM_OUTNCOPY\n#define\tTRSM_OLNCOPY\t\tCTRSM_OLNNCOPY\n#define\tTRSM_OLTCOPY\t\tCTRSM_OLTNCOPY\n\n#define\tTRMM_IUNCOPY\t\tCTRMM_IUNNCOPY\n#define\tTRMM_IUTCOPY\t\tCTRMM_IUTNCOPY\n#define\tTRMM_ILNCOPY\t\tCTRMM_ILNNCOPY\n#define\tTRMM_ILTCOPY\t\tCTRMM_ILTNCOPY\n#define\tTRSM_IUNCOPY\t\tCTRSM_IUNNCOPY\n#define\tTRSM_IUTCOPY\t\tCTRSM_IUTNCOPY\n#define\tTRSM_ILNCOPY\t\tCTRSM_ILNNCOPY\n#define\tTRSM_ILTCOPY\t\tCTRSM_ILTNCOPY\n\n#endif\n\n#define\tSYMM3M_ILCOPYB\t\tCSYMM3M_ILCOPYB\n#define\tSYMM3M_IUCOPYB\t\tCSYMM3M_IUCOPYB\n#define\tSYMM3M_ILCOPYR\t\tCSYMM3M_ILCOPYR\n#define\tSYMM3M_IUCOPYR\t\tCSYMM3M_IUCOPYR\n#define\tSYMM3M_ILCOPYI\t\tCSYMM3M_ILCOPYI\n#define\tSYMM3M_IUCOPYI\t\tCSYMM3M_IUCOPYI\n\n#define\tSYMM3M_OLCOPYB\t\tCSYMM3M_OLCOPYB\n#define\tSYMM3M_OUCOPYB\t\tCSYMM3M_OUCOPYB\n#define\tSYMM3M_OLCOPYR\t\tCSYMM3M_OLCOPYR\n#define\tSYMM3M_OUCOPYR\t\tCSYMM3M_OUCOPYR\n#define\tSYMM3M_OLCOPYI\t\tCSYMM3M_OLCOPYI\n#define\tSYMM3M_OUCOPYI\t\tCSYMM3M_OUCOPYI\n\n#define\tHEMM3M_ILCOPYB\t\tCHEMM3M_ILCOPYB\n#define\tHEMM3M_IUCOPYB\t\tCHEMM3M_IUCOPYB\n#define\tHEMM3M_ILCOPYR\t\tCHEMM3M_ILCOPYR\n#define\tHEMM3M_IUCOPYR\t\tCHEMM3M_IUCOPYR\n#define\tHEMM3M_ILCOPYI\t\tCHEMM3M_ILCOPYI\n#define\tHEMM3M_IUCOPYI\t\tCHEMM3M_IUCOPYI\n\n#define\tHEMM3M_OLCOPYB\t\tCHEMM3M_OLCOPYB\n#define\tHEMM3M_OUCOPYB\t\tCHEMM3M_OUCOPYB\n#define\tHEMM3M_OLCOPYR\t\tCHEMM3M_OLCOPYR\n#define\tHEMM3M_OUCOPYR\t\tCHEMM3M_OUCOPYR\n#define\tHEMM3M_OLCOPYI\t\tCHEMM3M_OLCOPYI\n#define\tHEMM3M_OUCOPYI\t\tCHEMM3M_OUCOPYI\n\n#define\tGEMM_BETA\t\tCGEMM_BETA\n\n#define\tGEMM_KERNEL_N\t\tCGEMM_KERNEL_N\n#define\tGEMM_KERNEL_L\t\tCGEMM_KERNEL_L\n#define\tGEMM_KERNEL_R\t\tCGEMM_KERNEL_R\n#define\tGEMM_KERNEL_B\t\tCGEMM_KERNEL_B\n\n#define\tGEMM3M_KERNEL\t\tCGEMM3M_KERNEL\n\n#define\tTRMM_KERNEL_LN\t\tCTRMM_KERNEL_LN\n#define\tTRMM_KERNEL_LT\t\tCTRMM_KERNEL_LT\n#define\tTRMM_KERNEL_LR\t\tCTRMM_KERNEL_LR\n#define\tTRMM_KERNEL_LC\t\tCTRMM_KERNEL_LC\n#define\tTRMM_KERNEL_RN\t\tCTRMM_KERNEL_RN\n#define\tTRMM_KERNEL_RT\t\tCTRMM_KERNEL_RT\n#define\tTRMM_KERNEL_RR\t\tCTRMM_KERNEL_RR\n#define\tTRMM_KERNEL_RC\t\tCTRMM_KERNEL_RC\n\n#define\tTRSM_KERNEL_LN\t\tCTRSM_KERNEL_LN\n#define\tTRSM_KERNEL_LT\t\tCTRSM_KERNEL_LT\n#define\tTRSM_KERNEL_LR\t\tCTRSM_KERNEL_LR\n#define\tTRSM_KERNEL_LC\t\tCTRSM_KERNEL_LC\n#define\tTRSM_KERNEL_RN\t\tCTRSM_KERNEL_RN\n#define\tTRSM_KERNEL_RT\t\tCTRSM_KERNEL_RT\n#define\tTRSM_KERNEL_RR\t\tCTRSM_KERNEL_RR\n#define\tTRSM_KERNEL_RC\t\tCTRSM_KERNEL_RC\n\n#define\tGEMM_NN\t\t\tCGEMM_NN\n#define\tGEMM_CN\t\t\tCGEMM_CN\n#define\tGEMM_TN\t\t\tCGEMM_TN\n#define\tGEMM_NC\t\t\tCGEMM_NC\n#define\tGEMM_NT\t\t\tCGEMM_NT\n#define\tGEMM_CC\t\t\tCGEMM_CC\n#define\tGEMM_CT\t\t\tCGEMM_CT\n#define\tGEMM_TC\t\t\tCGEMM_TC\n#define\tGEMM_TT\t\t\tCGEMM_TT\n#define\tGEMM_NR\t\t\tCGEMM_NR\n#define\tGEMM_TR\t\t\tCGEMM_TR\n#define\tGEMM_CR\t\t\tCGEMM_CR\n#define\tGEMM_RN\t\t\tCGEMM_RN\n#define\tGEMM_RT\t\t\tCGEMM_RT\n#define\tGEMM_RC\t\t\tCGEMM_RC\n#define\tGEMM_RR\t\t\tCGEMM_RR\n\n#define\tSYMM_LU\t\t\tCSYMM_LU\n#define\tSYMM_LL\t\t\tCSYMM_LL\n#define\tSYMM_RU\t\t\tCSYMM_RU\n#define\tSYMM_RL\t\t\tCSYMM_RL\n\n#define\tHEMM_LU\t\t\tCHEMM_LU\n#define\tHEMM_LL\t\t\tCHEMM_LL\n#define\tHEMM_RU\t\t\tCHEMM_RU\n#define\tHEMM_RL\t\t\tCHEMM_RL\n\n#define HEMM_IUTCOPY\t\tCHEMM_IUTCOPY\n#define HEMM_ILTCOPY\t\tCHEMM_ILTCOPY\n#define HEMM_OUTCOPY\t\tCHEMM_OUTCOPY\n#define HEMM_OLTCOPY\t\tCHEMM_OLTCOPY\n\n#define\tSYRK_UN\t\t\tCSYRK_UN\n#define\tSYRK_UT\t\t\tCSYRK_UT\n#define\tSYRK_LN\t\t\tCSYRK_LN\n#define\tSYRK_LT\t\t\tCSYRK_LT\n#define\tSYRK_UR\t\t\tCSYRK_UN\n#define\tSYRK_UC\t\t\tCSYRK_UT\n#define\tSYRK_LR\t\t\tCSYRK_LN\n#define\tSYRK_LC\t\t\tCSYRK_LT\n\n#define\tSYRK_KERNEL_U\t\tCSYRK_KERNEL_U\n#define\tSYRK_KERNEL_L\t\tCSYRK_KERNEL_L\n\n#define\tHERK_UN\t\t\tCHERK_UN\n#define\tHERK_LN\t\t\tCHERK_LN\n#define\tHERK_UC\t\t\tCHERK_UC\n#define\tHERK_LC\t\t\tCHERK_LC\n\n#define\tHER2K_UN\t\tCHER2K_UN\n#define\tHER2K_LN\t\tCHER2K_LN\n#define\tHER2K_UC\t\tCHER2K_UC\n#define\tHER2K_LC\t\tCHER2K_LC\n\n#define\tSYR2K_UN\t\tCSYR2K_UN\n#define\tSYR2K_UT\t\tCSYR2K_UT\n#define\tSYR2K_LN\t\tCSYR2K_LN\n#define\tSYR2K_LT\t\tCSYR2K_LT\n#define\tSYR2K_UR\t\tCSYR2K_UN\n#define\tSYR2K_UC\t\tCSYR2K_UT\n#define\tSYR2K_LR\t\tCSYR2K_LN\n#define\tSYR2K_LC\t\tCSYR2K_LT\n\n#define\tSYR2K_KERNEL_U\t\tCSYR2K_KERNEL_U\n#define\tSYR2K_KERNEL_L\t\tCSYR2K_KERNEL_L\n\n#define\tTRMM_LNUU\t\tCTRMM_LNUU\n#define\tTRMM_LNUN\t\tCTRMM_LNUN\n#define\tTRMM_LNLU\t\tCTRMM_LNLU\n#define\tTRMM_LNLN\t\tCTRMM_LNLN\n#define\tTRMM_LTUU\t\tCTRMM_LTUU\n#define\tTRMM_LTUN\t\tCTRMM_LTUN\n#define\tTRMM_LTLU\t\tCTRMM_LTLU\n#define\tTRMM_LTLN\t\tCTRMM_LTLN\n#define\tTRMM_LRUU\t\tCTRMM_LRUU\n#define\tTRMM_LRUN\t\tCTRMM_LRUN\n#define\tTRMM_LRLU\t\tCTRMM_LRLU\n#define\tTRMM_LRLN\t\tCTRMM_LRLN\n#define\tTRMM_LCUU\t\tCTRMM_LCUU\n#define\tTRMM_LCUN\t\tCTRMM_LCUN\n#define\tTRMM_LCLU\t\tCTRMM_LCLU\n#define\tTRMM_LCLN\t\tCTRMM_LCLN\n#define\tTRMM_RNUU\t\tCTRMM_RNUU\n#define\tTRMM_RNUN\t\tCTRMM_RNUN\n#define\tTRMM_RNLU\t\tCTRMM_RNLU\n#define\tTRMM_RNLN\t\tCTRMM_RNLN\n#define\tTRMM_RTUU\t\tCTRMM_RTUU\n#define\tTRMM_RTUN\t\tCTRMM_RTUN\n#define\tTRMM_RTLU\t\tCTRMM_RTLU\n#define\tTRMM_RTLN\t\tCTRMM_RTLN\n#define\tTRMM_RRUU\t\tCTRMM_RRUU\n#define\tTRMM_RRUN\t\tCTRMM_RRUN\n#define\tTRMM_RRLU\t\tCTRMM_RRLU\n#define\tTRMM_RRLN\t\tCTRMM_RRLN\n#define\tTRMM_RCUU\t\tCTRMM_RCUU\n#define\tTRMM_RCUN\t\tCTRMM_RCUN\n#define\tTRMM_RCLU\t\tCTRMM_RCLU\n#define\tTRMM_RCLN\t\tCTRMM_RCLN\n\n#define\tTRSM_LNUU\t\tCTRSM_LNUU\n#define\tTRSM_LNUN\t\tCTRSM_LNUN\n#define\tTRSM_LNLU\t\tCTRSM_LNLU\n#define\tTRSM_LNLN\t\tCTRSM_LNLN\n#define\tTRSM_LTUU\t\tCTRSM_LTUU\n#define\tTRSM_LTUN\t\tCTRSM_LTUN\n#define\tTRSM_LTLU\t\tCTRSM_LTLU\n#define\tTRSM_LTLN\t\tCTRSM_LTLN\n#define\tTRSM_LRUU\t\tCTRSM_LRUU\n#define\tTRSM_LRUN\t\tCTRSM_LRUN\n#define\tTRSM_LRLU\t\tCTRSM_LRLU\n#define\tTRSM_LRLN\t\tCTRSM_LRLN\n#define\tTRSM_LCUU\t\tCTRSM_LCUU\n#define\tTRSM_LCUN\t\tCTRSM_LCUN\n#define\tTRSM_LCLU\t\tCTRSM_LCLU\n#define\tTRSM_LCLN\t\tCTRSM_LCLN\n#define\tTRSM_RNUU\t\tCTRSM_RNUU\n#define\tTRSM_RNUN\t\tCTRSM_RNUN\n#define\tTRSM_RNLU\t\tCTRSM_RNLU\n#define\tTRSM_RNLN\t\tCTRSM_RNLN\n#define\tTRSM_RTUU\t\tCTRSM_RTUU\n#define\tTRSM_RTUN\t\tCTRSM_RTUN\n#define\tTRSM_RTLU\t\tCTRSM_RTLU\n#define\tTRSM_RTLN\t\tCTRSM_RTLN\n#define\tTRSM_RRUU\t\tCTRSM_RRUU\n#define\tTRSM_RRUN\t\tCTRSM_RRUN\n#define\tTRSM_RRLU\t\tCTRSM_RRLU\n#define\tTRSM_RRLN\t\tCTRSM_RRLN\n#define\tTRSM_RCUU\t\tCTRSM_RCUU\n#define\tTRSM_RCUN\t\tCTRSM_RCUN\n#define\tTRSM_RCLU\t\tCTRSM_RCLU\n#define\tTRSM_RCLN\t\tCTRSM_RCLN\n\n\n#define\tGEMM_THREAD_NN\t\tCGEMM_THREAD_NN\n#define\tGEMM_THREAD_CN\t\tCGEMM_THREAD_CN\n#define\tGEMM_THREAD_TN\t\tCGEMM_THREAD_TN\n#define\tGEMM_THREAD_NC\t\tCGEMM_THREAD_NC\n#define\tGEMM_THREAD_NT\t\tCGEMM_THREAD_NT\n#define\tGEMM_THREAD_CC\t\tCGEMM_THREAD_CC\n#define\tGEMM_THREAD_CT\t\tCGEMM_THREAD_CT\n#define\tGEMM_THREAD_TC\t\tCGEMM_THREAD_TC\n#define\tGEMM_THREAD_TT\t\tCGEMM_THREAD_TT\n#define\tGEMM_THREAD_NR\t\tCGEMM_THREAD_NR\n#define\tGEMM_THREAD_TR\t\tCGEMM_THREAD_TR\n#define\tGEMM_THREAD_CR\t\tCGEMM_THREAD_CR\n#define\tGEMM_THREAD_RN\t\tCGEMM_THREAD_RN\n#define\tGEMM_THREAD_RT\t\tCGEMM_THREAD_RT\n#define\tGEMM_THREAD_RC\t\tCGEMM_THREAD_RC\n#define\tGEMM_THREAD_RR\t\tCGEMM_THREAD_RR\n\n#define\tSYMM_THREAD_LU\t\tCSYMM_THREAD_LU\n#define\tSYMM_THREAD_LL\t\tCSYMM_THREAD_LL\n#define\tSYMM_THREAD_RU\t\tCSYMM_THREAD_RU\n#define\tSYMM_THREAD_RL\t\tCSYMM_THREAD_RL\n\n#define\tHEMM_THREAD_LU\t\tCHEMM_THREAD_LU\n#define\tHEMM_THREAD_LL\t\tCHEMM_THREAD_LL\n#define\tHEMM_THREAD_RU\t\tCHEMM_THREAD_RU\n#define\tHEMM_THREAD_RL\t\tCHEMM_THREAD_RL\n\n#define\tSYRK_THREAD_UN\t\tCSYRK_THREAD_UN\n#define\tSYRK_THREAD_UT\t\tCSYRK_THREAD_UT\n#define\tSYRK_THREAD_LN\t\tCSYRK_THREAD_LN\n#define\tSYRK_THREAD_LT\t\tCSYRK_THREAD_LT\n#define\tSYRK_THREAD_UR\t\tCSYRK_THREAD_UR\n#define\tSYRK_THREAD_UC\t\tCSYRK_THREAD_UC\n#define\tSYRK_THREAD_LR\t\tCSYRK_THREAD_LR\n#define\tSYRK_THREAD_LC\t\tCSYRK_THREAD_LC\n\n#define\tHERK_THREAD_UN\t\tCHERK_THREAD_UN\n#define\tHERK_THREAD_UT\t\tCHERK_THREAD_UT\n#define\tHERK_THREAD_LN\t\tCHERK_THREAD_LN\n#define\tHERK_THREAD_LT\t\tCHERK_THREAD_LT\n#define\tHERK_THREAD_UR\t\tCHERK_THREAD_UR\n#define\tHERK_THREAD_UC\t\tCHERK_THREAD_UC\n#define\tHERK_THREAD_LR\t\tCHERK_THREAD_LR\n#define\tHERK_THREAD_LC\t\tCHERK_THREAD_LC\n\n#define\tGEMM3M_NN\t\tCGEMM3M_NN\n#define\tGEMM3M_CN\t\tCGEMM3M_CN\n#define\tGEMM3M_TN\t\tCGEMM3M_TN\n#define\tGEMM3M_NC\t\tCGEMM3M_NC\n#define\tGEMM3M_NT\t\tCGEMM3M_NT\n#define\tGEMM3M_CC\t\tCGEMM3M_CC\n#define\tGEMM3M_CT\t\tCGEMM3M_CT\n#define\tGEMM3M_TC\t\tCGEMM3M_TC\n#define\tGEMM3M_TT\t\tCGEMM3M_TT\n#define\tGEMM3M_NR\t\tCGEMM3M_NR\n#define\tGEMM3M_TR\t\tCGEMM3M_TR\n#define\tGEMM3M_CR\t\tCGEMM3M_CR\n#define\tGEMM3M_RN\t\tCGEMM3M_RN\n#define\tGEMM3M_RT\t\tCGEMM3M_RT\n#define\tGEMM3M_RC\t\tCGEMM3M_RC\n#define\tGEMM3M_RR\t\tCGEMM3M_RR\n\n#define\tGEMM3M_THREAD_NN\tCGEMM3M_THREAD_NN\n#define\tGEMM3M_THREAD_CN\tCGEMM3M_THREAD_CN\n#define\tGEMM3M_THREAD_TN\tCGEMM3M_THREAD_TN\n#define\tGEMM3M_THREAD_NC\tCGEMM3M_THREAD_NC\n#define\tGEMM3M_THREAD_NT\tCGEMM3M_THREAD_NT\n#define\tGEMM3M_THREAD_CC\tCGEMM3M_THREAD_CC\n#define\tGEMM3M_THREAD_CT\tCGEMM3M_THREAD_CT\n#define\tGEMM3M_THREAD_TC\tCGEMM3M_THREAD_TC\n#define\tGEMM3M_THREAD_TT\tCGEMM3M_THREAD_TT\n#define\tGEMM3M_THREAD_NR\tCGEMM3M_THREAD_NR\n#define\tGEMM3M_THREAD_TR\tCGEMM3M_THREAD_TR\n#define\tGEMM3M_THREAD_CR\tCGEMM3M_THREAD_CR\n#define\tGEMM3M_THREAD_RN\tCGEMM3M_THREAD_RN\n#define\tGEMM3M_THREAD_RT\tCGEMM3M_THREAD_RT\n#define\tGEMM3M_THREAD_RC\tCGEMM3M_THREAD_RC\n#define\tGEMM3M_THREAD_RR\tCGEMM3M_THREAD_RR\n\n#define\tSYMM3M_LU\t\tCSYMM3M_LU\n#define\tSYMM3M_LL\t\tCSYMM3M_LL\n#define\tSYMM3M_RU\t\tCSYMM3M_RU\n#define\tSYMM3M_RL\t\tCSYMM3M_RL\n\n#define\tSYMM3M_THREAD_LU\tCSYMM3M_THREAD_LU\n#define\tSYMM3M_THREAD_LL\tCSYMM3M_THREAD_LL\n#define\tSYMM3M_THREAD_RU\tCSYMM3M_THREAD_RU\n#define\tSYMM3M_THREAD_RL\tCSYMM3M_THREAD_RL\n\n#define\tHEMM3M_LU\t\tCHEMM3M_LU\n#define\tHEMM3M_LL\t\tCHEMM3M_LL\n#define\tHEMM3M_RU\t\tCHEMM3M_RU\n#define\tHEMM3M_RL\t\tCHEMM3M_RL\n\n#define\tHEMM3M_THREAD_LU\tCHEMM3M_THREAD_LU\n#define\tHEMM3M_THREAD_LL\tCHEMM3M_THREAD_LL\n#define\tHEMM3M_THREAD_RU\tCHEMM3M_THREAD_RU\n#define\tHEMM3M_THREAD_RL\tCHEMM3M_THREAD_RL\n\n#define SYMM_IUTCOPY\t\tCSYMM_IUTCOPY\n#define SYMM_ILTCOPY\t\tCSYMM_ILTCOPY\n#define SYMM_OUTCOPY\t\tCSYMM_OUTCOPY\n#define SYMM_OLTCOPY\t\tCSYMM_OLTCOPY\n\n#define AXPBY_K                 CAXPBY_K\n\n#define OMATCOPY_K_CN\t\tCOMATCOPY_K_CN\n#define OMATCOPY_K_RN\t\tCOMATCOPY_K_RN\n#define OMATCOPY_K_CT\t\tCOMATCOPY_K_CT\n#define OMATCOPY_K_RT\t\tCOMATCOPY_K_RT\n#define OMATCOPY_K_CNC\t\tCOMATCOPY_K_CNC\n#define OMATCOPY_K_RNC\t\tCOMATCOPY_K_RNC\n#define OMATCOPY_K_CTC\t\tCOMATCOPY_K_CTC\n#define OMATCOPY_K_RTC\t\tCOMATCOPY_K_RTC\n#define IMATCOPY_K_CN\t\tCIMATCOPY_K_CN\n#define IMATCOPY_K_RN\t\tCIMATCOPY_K_RN\n#define IMATCOPY_K_CT\t\tCIMATCOPY_K_CT\n#define IMATCOPY_K_RT\t\tCIMATCOPY_K_RT\n#define IMATCOPY_K_CNC\t\tCIMATCOPY_K_CNC\n#define IMATCOPY_K_RNC\t\tCIMATCOPY_K_RNC\n#define IMATCOPY_K_CTC\t\tCIMATCOPY_K_CTC\n#define IMATCOPY_K_RTC\t\tCIMATCOPY_K_RTC\n\n#define GEADD_K                 CGEADD_K\n\n#define GEMM_SMALL_MATRIX_PERMIT\tCGEMM_SMALL_MATRIX_PERMIT\n\n#define GEMM_SMALL_KERNEL_NN    CGEMM_SMALL_KERNEL_NN\n#define GEMM_SMALL_KERNEL_NT    CGEMM_SMALL_KERNEL_NT\n#define GEMM_SMALL_KERNEL_NR    CGEMM_SMALL_KERNEL_NR\n#define GEMM_SMALL_KERNEL_NC    CGEMM_SMALL_KERNEL_NC\n\n#define GEMM_SMALL_KERNEL_TN    CGEMM_SMALL_KERNEL_TN\n#define GEMM_SMALL_KERNEL_TT    CGEMM_SMALL_KERNEL_TT\n#define GEMM_SMALL_KERNEL_TR    CGEMM_SMALL_KERNEL_TR\n#define GEMM_SMALL_KERNEL_TC    CGEMM_SMALL_KERNEL_TC\n\n#define GEMM_SMALL_KERNEL_RN    CGEMM_SMALL_KERNEL_RN\n#define GEMM_SMALL_KERNEL_RT    CGEMM_SMALL_KERNEL_RT\n#define GEMM_SMALL_KERNEL_RR    CGEMM_SMALL_KERNEL_RR\n#define GEMM_SMALL_KERNEL_RC    CGEMM_SMALL_KERNEL_RC\n\n#define GEMM_SMALL_KERNEL_CN    CGEMM_SMALL_KERNEL_CN\n#define GEMM_SMALL_KERNEL_CT    CGEMM_SMALL_KERNEL_CT\n#define GEMM_SMALL_KERNEL_CR    CGEMM_SMALL_KERNEL_CR\n#define GEMM_SMALL_KERNEL_CC    CGEMM_SMALL_KERNEL_CC\n\n#define GEMM_SMALL_KERNEL_B0_NN    CGEMM_SMALL_KERNEL_B0_NN\n#define GEMM_SMALL_KERNEL_B0_NT    CGEMM_SMALL_KERNEL_B0_NT\n#define GEMM_SMALL_KERNEL_B0_NR    CGEMM_SMALL_KERNEL_B0_NR\n#define GEMM_SMALL_KERNEL_B0_NC    CGEMM_SMALL_KERNEL_B0_NC\n\n#define GEMM_SMALL_KERNEL_B0_TN    CGEMM_SMALL_KERNEL_B0_TN\n#define GEMM_SMALL_KERNEL_B0_TT    CGEMM_SMALL_KERNEL_B0_TT\n#define GEMM_SMALL_KERNEL_B0_TR    CGEMM_SMALL_KERNEL_B0_TR\n#define GEMM_SMALL_KERNEL_B0_TC    CGEMM_SMALL_KERNEL_B0_TC\n\n#define GEMM_SMALL_KERNEL_B0_RN    CGEMM_SMALL_KERNEL_B0_RN\n#define GEMM_SMALL_KERNEL_B0_RT    CGEMM_SMALL_KERNEL_B0_RT\n#define GEMM_SMALL_KERNEL_B0_RR    CGEMM_SMALL_KERNEL_B0_RR\n#define GEMM_SMALL_KERNEL_B0_RC    CGEMM_SMALL_KERNEL_B0_RC\n\n#define GEMM_SMALL_KERNEL_B0_CN    CGEMM_SMALL_KERNEL_B0_CN\n#define GEMM_SMALL_KERNEL_B0_CT    CGEMM_SMALL_KERNEL_B0_CT\n#define GEMM_SMALL_KERNEL_B0_CR    CGEMM_SMALL_KERNEL_B0_CR\n#define GEMM_SMALL_KERNEL_B0_CC    CGEMM_SMALL_KERNEL_B0_CC\n\n#endif\n#endif\n\n#ifndef ASSEMBLER\n#if !defined(DYNAMIC_ARCH) \\\n  && (defined(ARCH_X86) || defined(ARCH_X86_64) || defined(ARCH_IA64) || defined(ARCH_MIPS64) || defined(ARCH_ARM64) \\\n      || defined(ARCH_LOONGARCH64) || defined(ARCH_E2K) || defined(ARCH_ALPHA))\nextern BLASLONG gemm_offset_a;\nextern BLASLONG gemm_offset_b;\nextern BLASLONG sbgemm_p;\nextern BLASLONG sbgemm_q;\nextern BLASLONG sbgemm_r;\nextern BLASLONG sgemm_p;\nextern BLASLONG sgemm_q;\nextern BLASLONG sgemm_r;\nextern BLASLONG dgemm_p;\nextern BLASLONG dgemm_q;\nextern BLASLONG dgemm_r;\nextern BLASLONG qgemm_p;\nextern BLASLONG qgemm_q;\nextern BLASLONG qgemm_r;\nextern BLASLONG cgemm_p;\nextern BLASLONG cgemm_q;\nextern BLASLONG cgemm_r;\nextern BLASLONG zgemm_p;\nextern BLASLONG zgemm_q;\nextern BLASLONG zgemm_r;\nextern BLASLONG xgemm_p;\nextern BLASLONG xgemm_q;\nextern BLASLONG xgemm_r;\n#endif\n\ntypedef struct {\n  void *a, *b, *c, *d, *alpha, *beta;\n  BLASLONG\tm, n, k, lda, ldb, ldc, ldd;\n\n#ifdef SMP\n  void *common;\n  BLASLONG nthreads;\n#endif\n\n#ifdef PARAMTEST\n  BLASLONG gemm_p, gemm_q, gemm_r;\n#endif\n\n#ifdef PREFETCHTEST\n  BLASLONG prea, preb, prec, pred;\n#endif\n\n\n  //for gemm_batch\n  void * routine;\n  int routine_mode;\n\n} blas_arg_t;\n#endif\n\n#ifdef SMALL_MATRIX_OPT\n#define BLAS_SMALL_OPT  0x10000U\n#define BLAS_SMALL_B0_OPT  0x30000U\n#endif\n\n\n#ifdef XDOUBLE\n\n#define TRSV_NUU qtrsv_NUU\n#define TRSV_NUN qtrsv_NUN\n#define TRSV_NLU qtrsv_NLU\n#define TRSV_NLN qtrsv_NLN\n#define TRSV_TUU qtrsv_TUU\n#define TRSV_TUN qtrsv_TUN\n#define TRSV_TLU qtrsv_TLU\n#define TRSV_TLN qtrsv_TLN\n\n#define ZTRSV_NUU xtrsv_NUU\n#define ZTRSV_NUN xtrsv_NUN\n#define ZTRSV_NLU xtrsv_NLU\n#define ZTRSV_NLN xtrsv_NLN\n#define ZTRSV_TUU xtrsv_TUU\n#define ZTRSV_TUN xtrsv_TUN\n#define ZTRSV_TLU xtrsv_TLU\n#define ZTRSV_TLN xtrsv_TLN\n#define ZTRSV_RUU xtrsv_RUU\n#define ZTRSV_RUN xtrsv_RUN\n#define ZTRSV_RLU xtrsv_RLU\n#define ZTRSV_RLN xtrsv_RLN\n#define ZTRSV_CUU xtrsv_CUU\n#define ZTRSV_CUN xtrsv_CUN\n#define ZTRSV_CLU xtrsv_CLU\n#define ZTRSV_CLN xtrsv_CLN\n\n#define TRMV_NUU qtrmv_NUU\n#define TRMV_NUN qtrmv_NUN\n#define TRMV_NLU qtrmv_NLU\n#define TRMV_NLN qtrmv_NLN\n#define TRMV_TUU qtrmv_TUU\n#define TRMV_TUN qtrmv_TUN\n#define TRMV_TLU qtrmv_TLU\n#define TRMV_TLN qtrmv_TLN\n\n#define TRMV_THREAD_NUU qtrmv_thread_NUU\n#define TRMV_THREAD_NUN qtrmv_thread_NUN\n#define TRMV_THREAD_NLU qtrmv_thread_NLU\n#define TRMV_THREAD_NLN qtrmv_thread_NLN\n#define TRMV_THREAD_TUU qtrmv_thread_TUU\n#define TRMV_THREAD_TUN qtrmv_thread_TUN\n#define TRMV_THREAD_TLU qtrmv_thread_TLU\n#define TRMV_THREAD_TLN qtrmv_thread_TLN\n\n#define ZTRMV_NUU xtrmv_NUU\n#define ZTRMV_NUN xtrmv_NUN\n#define ZTRMV_NLU xtrmv_NLU\n#define ZTRMV_NLN xtrmv_NLN\n#define ZTRMV_TUU xtrmv_TUU\n#define ZTRMV_TUN xtrmv_TUN\n#define ZTRMV_TLU xtrmv_TLU\n#define ZTRMV_TLN xtrmv_TLN\n#define ZTRMV_RUU xtrmv_RUU\n#define ZTRMV_RUN xtrmv_RUN\n#define ZTRMV_RLU xtrmv_RLU\n#define ZTRMV_RLN xtrmv_RLN\n#define ZTRMV_CUU xtrmv_CUU\n#define ZTRMV_CUN xtrmv_CUN\n#define ZTRMV_CLU xtrmv_CLU\n#define ZTRMV_CLN xtrmv_CLN\n\n#define ZTRMV_THREAD_NUU xtrmv_thread_NUU\n#define ZTRMV_THREAD_NUN xtrmv_thread_NUN\n#define ZTRMV_THREAD_NLU xtrmv_thread_NLU\n#define ZTRMV_THREAD_NLN xtrmv_thread_NLN\n#define ZTRMV_THREAD_TUU xtrmv_thread_TUU\n#define ZTRMV_THREAD_TUN xtrmv_thread_TUN\n#define ZTRMV_THREAD_TLU xtrmv_thread_TLU\n#define ZTRMV_THREAD_TLN xtrmv_thread_TLN\n#define ZTRMV_THREAD_RUU xtrmv_thread_RUU\n#define ZTRMV_THREAD_RUN xtrmv_thread_RUN\n#define ZTRMV_THREAD_RLU xtrmv_thread_RLU\n#define ZTRMV_THREAD_RLN xtrmv_thread_RLN\n#define ZTRMV_THREAD_CUU xtrmv_thread_CUU\n#define ZTRMV_THREAD_CUN xtrmv_thread_CUN\n#define ZTRMV_THREAD_CLU xtrmv_thread_CLU\n#define ZTRMV_THREAD_CLN xtrmv_thread_CLN\n\n#elif defined(DOUBLE)\n\n#define TRSV_NUU dtrsv_NUU\n#define TRSV_NUN dtrsv_NUN\n#define TRSV_NLU dtrsv_NLU\n#define TRSV_NLN dtrsv_NLN\n#define TRSV_TUU dtrsv_TUU\n#define TRSV_TUN dtrsv_TUN\n#define TRSV_TLU dtrsv_TLU\n#define TRSV_TLN dtrsv_TLN\n\n#define ZTRSV_NUU ztrsv_NUU\n#define ZTRSV_NUN ztrsv_NUN\n#define ZTRSV_NLU ztrsv_NLU\n#define ZTRSV_NLN ztrsv_NLN\n#define ZTRSV_TUU ztrsv_TUU\n#define ZTRSV_TUN ztrsv_TUN\n#define ZTRSV_TLU ztrsv_TLU\n#define ZTRSV_TLN ztrsv_TLN\n#define ZTRSV_RUU ztrsv_RUU\n#define ZTRSV_RUN ztrsv_RUN\n#define ZTRSV_RLU ztrsv_RLU\n#define ZTRSV_RLN ztrsv_RLN\n#define ZTRSV_CUU ztrsv_CUU\n#define ZTRSV_CUN ztrsv_CUN\n#define ZTRSV_CLU ztrsv_CLU\n#define ZTRSV_CLN ztrsv_CLN\n\n#define TRMV_NUU dtrmv_NUU\n#define TRMV_NUN dtrmv_NUN\n#define TRMV_NLU dtrmv_NLU\n#define TRMV_NLN dtrmv_NLN\n#define TRMV_TUU dtrmv_TUU\n#define TRMV_TUN dtrmv_TUN\n#define TRMV_TLU dtrmv_TLU\n#define TRMV_TLN dtrmv_TLN\n\n#define TRMV_THREAD_NUU dtrmv_thread_NUU\n#define TRMV_THREAD_NUN dtrmv_thread_NUN\n#define TRMV_THREAD_NLU dtrmv_thread_NLU\n#define TRMV_THREAD_NLN dtrmv_thread_NLN\n#define TRMV_THREAD_TUU dtrmv_thread_TUU\n#define TRMV_THREAD_TUN dtrmv_thread_TUN\n#define TRMV_THREAD_TLU dtrmv_thread_TLU\n#define TRMV_THREAD_TLN dtrmv_thread_TLN\n\n#define ZTRMV_NUU ztrmv_NUU\n#define ZTRMV_NUN ztrmv_NUN\n#define ZTRMV_NLU ztrmv_NLU\n#define ZTRMV_NLN ztrmv_NLN\n#define ZTRMV_TUU ztrmv_TUU\n#define ZTRMV_TUN ztrmv_TUN\n#define ZTRMV_TLU ztrmv_TLU\n#define ZTRMV_TLN ztrmv_TLN\n#define ZTRMV_RUU ztrmv_RUU\n#define ZTRMV_RUN ztrmv_RUN\n#define ZTRMV_RLU ztrmv_RLU\n#define ZTRMV_RLN ztrmv_RLN\n#define ZTRMV_CUU ztrmv_CUU\n#define ZTRMV_CUN ztrmv_CUN\n#define ZTRMV_CLU ztrmv_CLU\n#define ZTRMV_CLN ztrmv_CLN\n\n#define ZTRMV_THREAD_NUU ztrmv_thread_NUU\n#define ZTRMV_THREAD_NUN ztrmv_thread_NUN\n#define ZTRMV_THREAD_NLU ztrmv_thread_NLU\n#define ZTRMV_THREAD_NLN ztrmv_thread_NLN\n#define ZTRMV_THREAD_TUU ztrmv_thread_TUU\n#define ZTRMV_THREAD_TUN ztrmv_thread_TUN\n#define ZTRMV_THREAD_TLU ztrmv_thread_TLU\n#define ZTRMV_THREAD_TLN ztrmv_thread_TLN\n#define ZTRMV_THREAD_RUU ztrmv_thread_RUU\n#define ZTRMV_THREAD_RUN ztrmv_thread_RUN\n#define ZTRMV_THREAD_RLU ztrmv_thread_RLU\n#define ZTRMV_THREAD_RLN ztrmv_thread_RLN\n#define ZTRMV_THREAD_CUU ztrmv_thread_CUU\n#define ZTRMV_THREAD_CUN ztrmv_thread_CUN\n#define ZTRMV_THREAD_CLU ztrmv_thread_CLU\n#define ZTRMV_THREAD_CLN ztrmv_thread_CLN\n\n#else\n\n#define TRSV_NUU strsv_NUU\n#define TRSV_NUN strsv_NUN\n#define TRSV_NLU strsv_NLU\n#define TRSV_NLN strsv_NLN\n#define TRSV_TUU strsv_TUU\n#define TRSV_TUN strsv_TUN\n#define TRSV_TLU strsv_TLU\n#define TRSV_TLN strsv_TLN\n\n#define ZTRSV_NUU ctrsv_NUU\n#define ZTRSV_NUN ctrsv_NUN\n#define ZTRSV_NLU ctrsv_NLU\n#define ZTRSV_NLN ctrsv_NLN\n#define ZTRSV_TUU ctrsv_TUU\n#define ZTRSV_TUN ctrsv_TUN\n#define ZTRSV_TLU ctrsv_TLU\n#define ZTRSV_TLN ctrsv_TLN\n#define ZTRSV_RUU ctrsv_RUU\n#define ZTRSV_RUN ctrsv_RUN\n#define ZTRSV_RLU ctrsv_RLU\n#define ZTRSV_RLN ctrsv_RLN\n#define ZTRSV_CUU ctrsv_CUU\n#define ZTRSV_CUN ctrsv_CUN\n#define ZTRSV_CLU ctrsv_CLU\n#define ZTRSV_CLN ctrsv_CLN\n\n#define TRMV_NUU strmv_NUU\n#define TRMV_NUN strmv_NUN\n#define TRMV_NLU strmv_NLU\n#define TRMV_NLN strmv_NLN\n#define TRMV_TUU strmv_TUU\n#define TRMV_TUN strmv_TUN\n#define TRMV_TLU strmv_TLU\n#define TRMV_TLN strmv_TLN\n\n#define TRMV_THREAD_NUU strmv_thread_NUU\n#define TRMV_THREAD_NUN strmv_thread_NUN\n#define TRMV_THREAD_NLU strmv_thread_NLU\n#define TRMV_THREAD_NLN strmv_thread_NLN\n#define TRMV_THREAD_TUU strmv_thread_TUU\n#define TRMV_THREAD_TUN strmv_thread_TUN\n#define TRMV_THREAD_TLU strmv_thread_TLU\n#define TRMV_THREAD_TLN strmv_thread_TLN\n\n#define ZTRMV_NUU ctrmv_NUU\n#define ZTRMV_NUN ctrmv_NUN\n#define ZTRMV_NLU ctrmv_NLU\n#define ZTRMV_NLN ctrmv_NLN\n#define ZTRMV_TUU ctrmv_TUU\n#define ZTRMV_TUN ctrmv_TUN\n#define ZTRMV_TLU ctrmv_TLU\n#define ZTRMV_TLN ctrmv_TLN\n#define ZTRMV_RUU ctrmv_RUU\n#define ZTRMV_RUN ctrmv_RUN\n#define ZTRMV_RLU ctrmv_RLU\n#define ZTRMV_RLN ctrmv_RLN\n#define ZTRMV_CUU ctrmv_CUU\n#define ZTRMV_CUN ctrmv_CUN\n#define ZTRMV_CLU ctrmv_CLU\n#define ZTRMV_CLN ctrmv_CLN\n\n#define ZTRMV_THREAD_NUU ctrmv_thread_NUU\n#define ZTRMV_THREAD_NUN ctrmv_thread_NUN\n#define ZTRMV_THREAD_NLU ctrmv_thread_NLU\n#define ZTRMV_THREAD_NLN ctrmv_thread_NLN\n#define ZTRMV_THREAD_TUU ctrmv_thread_TUU\n#define ZTRMV_THREAD_TUN ctrmv_thread_TUN\n#define ZTRMV_THREAD_TLU ctrmv_thread_TLU\n#define ZTRMV_THREAD_TLN ctrmv_thread_TLN\n#define ZTRMV_THREAD_RUU ctrmv_thread_RUU\n#define ZTRMV_THREAD_RUN ctrmv_thread_RUN\n#define ZTRMV_THREAD_RLU ctrmv_thread_RLU\n#define ZTRMV_THREAD_RLN ctrmv_thread_RLN\n#define ZTRMV_THREAD_CUU ctrmv_thread_CUU\n#define ZTRMV_THREAD_CUN ctrmv_thread_CUN\n#define ZTRMV_THREAD_CLU ctrmv_thread_CLU\n#define ZTRMV_THREAD_CLN ctrmv_thread_CLN\n\n#endif\n\n#define SGETF2\tsgetf2_k\n#define DGETF2\tdgetf2_k\n#define QGETF2\tqgetf2_k\n#define CGETF2\tcgetf2_k\n#define ZGETF2\tzgetf2_k\n#define XGETF2\txgetf2_k\n\n#define SLASWP_PLUS\tslaswp_plus\n#define SLASWP_MINUS\tslaswp_minus\n#define DLASWP_PLUS\tdlaswp_plus\n#define DLASWP_MINUS\tdlaswp_minus\n#define QLASWP_PLUS\tqlaswp_plus\n#define QLASWP_MINUS\tqlaswp_minus\n#define CLASWP_PLUS\tclaswp_plus\n#define CLASWP_MINUS\tclaswp_minus\n#define ZLASWP_PLUS\tzlaswp_plus\n#define ZLASWP_MINUS\tzlaswp_minus\n#define XLASWP_PLUS\txlaswp_plus\n#define XLASWP_MINUS\txlaswp_minus\n\n#define\tSLARF_L\t\tslarf_L\n#define\tSLARF_R\t\tslarf_R\n#define\tDLARF_L\t\tdlarf_L\n#define\tDLARF_R\t\tdlarf_R\n#define\tQLARF_L\t\tqlarf_L\n#define\tQLARF_R\t\tqlarf_R\n#define\tCLARF_L\t\tclarf_L\n#define\tCLARF_R\t\tclarf_R\n#define\tZLARF_L\t\tzlarf_L\n#define\tZLARF_R\t\tzlarf_R\n#define\tXLARF_L\t\txlarf_L\n#define\tXLARF_R\t\txlarf_R\n\n#ifndef COMPLEX\n#ifdef XDOUBLE\n#define GETF2\tQGETF2\n#define GETRF\tQGETRF\n#define GETRS_N_SINGLE\tqgetrs_N_single\n#define GETRS_T_SINGLE\tqgetrs_T_single\n#define GETRS_R_SINGLE\tqgetrs_N_single\n#define GETRS_C_SINGLE\tqgetrs_T_single\n#define GETRS_N_PARALLEL\tqgetrs_N_parallel\n#define GETRS_T_PARALLEL\tqgetrs_T_parallel\n#define GETRS_R_PARALLEL\tqgetrs_N_parallel\n#define GETRS_C_PARALLEL\tqgetrs_T_parallel\n#define LASWP_PLUS\tQLASWP_PLUS\n#define LASWP_MINUS\tQLASWP_MINUS\n#define LASWP_NCOPY\tQLASWP_NCOPY\n#define GETRS_N\t\tQGETRS_N\n#define GETRS_T\t\tQGETRS_T\n#define GETRF_SINGLE\tqgetrf_single\n#define GETRF_PARALLEL\tqgetrf_parallel\n#define NEG_TCOPY\tQNEG_TCOPY\n#define\tLARF_L\t\tQLARF_L\n#define\tLARF_R\t\tQLARF_R\n#elif defined(DOUBLE)\n#define GETF2\tDGETF2\n#define GETRF\tDGETRF\n#define GETRS_N_SINGLE\tdgetrs_N_single\n#define GETRS_T_SINGLE\tdgetrs_T_single\n#define GETRS_R_SINGLE\tdgetrs_N_single\n#define GETRS_C_SINGLE\tdgetrs_T_single\n#define GETRS_N_PARALLEL\tdgetrs_N_parallel\n#define GETRS_T_PARALLEL\tdgetrs_T_parallel\n#define GETRS_R_PARALLEL\tdgetrs_N_parallel\n#define GETRS_C_PARALLEL\tdgetrs_T_parallel\n#define LASWP_PLUS\tDLASWP_PLUS\n#define LASWP_MINUS\tDLASWP_MINUS\n#define LASWP_NCOPY\tDLASWP_NCOPY\n#define GETRS_N\t\tDGETRS_N\n#define GETRS_T\t\tDGETRS_T\n#define GETRF_SINGLE\tdgetrf_single\n#define GETRF_PARALLEL\tdgetrf_parallel\n#define NEG_TCOPY\tDNEG_TCOPY\n#define\tLARF_L\t\tDLARF_L\n#define\tLARF_R\t\tDLARF_R\n#else\n#define GETF2\tSGETF2\n#define GETRF\tSGETRF\n#define GETRS_N_SINGLE\tsgetrs_N_single\n#define GETRS_T_SINGLE\tsgetrs_T_single\n#define GETRS_R_SINGLE\tsgetrs_N_single\n#define GETRS_C_SINGLE\tsgetrs_T_single\n#define GETRS_N_PARALLEL\tsgetrs_N_parallel\n#define GETRS_T_PARALLEL\tsgetrs_T_parallel\n#define GETRS_R_PARALLEL\tsgetrs_N_parallel\n#define GETRS_C_PARALLEL\tsgetrs_T_parallel\n#define LASWP_PLUS\tSLASWP_PLUS\n#define LASWP_MINUS\tSLASWP_MINUS\n#define LASWP_NCOPY\tSLASWP_NCOPY\n#define GETRS_N\t\tSGETRS_N\n#define GETRS_T\t\tSGETRS_T\n#define GETRF_SINGLE\tsgetrf_single\n#define GETRF_PARALLEL\tsgetrf_parallel\n#define NEG_TCOPY\tSNEG_TCOPY\n#define\tLARF_L\t\tSLARF_L\n#define\tLARF_R\t\tSLARF_R\n#endif\n#else\n#ifdef XDOUBLE\n#define GETF2\tXGETF2\n#define GETRF\tXGETRF\n#define GETRS_N_SINGLE\txgetrs_N_single\n#define GETRS_T_SINGLE\txgetrs_T_single\n#define GETRS_R_SINGLE\txgetrs_R_single\n#define GETRS_C_SINGLE\txgetrs_C_single\n#define GETRS_N_PARALLEL\txgetrs_N_parallel\n#define GETRS_T_PARALLEL\txgetrs_T_parallel\n#define GETRS_R_PARALLEL\txgetrs_R_parallel\n#define GETRS_C_PARALLEL\txgetrs_C_parallel\n#define LASWP_PLUS\tXLASWP_PLUS\n#define LASWP_MINUS\tXLASWP_MINUS\n#define LASWP_NCOPY\tXLASWP_NCOPY\n#define GETRS_N\t\tXGETRS_N\n#define GETRS_T\t\tXGETRS_T\n#define GETRF_SINGLE\txgetrf_single\n#define GETRF_PARALLEL\txgetrf_parallel\n#define NEG_TCOPY\tXNEG_TCOPY\n#define\tLARF_L\t\tXLARF_L\n#define\tLARF_R\t\tXLARF_R\n#elif defined(DOUBLE)\n#define GETF2\tZGETF2\n#define GETRF\tZGETRF\n#define GETRS_N_SINGLE\tzgetrs_N_single\n#define GETRS_T_SINGLE\tzgetrs_T_single\n#define GETRS_R_SINGLE\tzgetrs_R_single\n#define GETRS_C_SINGLE\tzgetrs_C_single\n#define GETRS_N_PARALLEL\tzgetrs_N_parallel\n#define GETRS_T_PARALLEL\tzgetrs_T_parallel\n#define GETRS_R_PARALLEL\tzgetrs_R_parallel\n#define GETRS_C_PARALLEL\tzgetrs_C_parallel\n#define LASWP_PLUS\tZLASWP_PLUS\n#define LASWP_MINUS\tZLASWP_MINUS\n#define LASWP_NCOPY\tZLASWP_NCOPY\n#define GETRS_N\t\tZGETRS_N\n#define GETRS_T\t\tZGETRS_T\n#define GETRF_SINGLE\tzgetrf_single\n#define GETRF_PARALLEL\tzgetrf_parallel\n#define NEG_TCOPY\tZNEG_TCOPY\n#define\tLARF_L\t\tZLARF_L\n#define\tLARF_R\t\tZLARF_R\n#else\n#define GETF2\tCGETF2\n#define GETRF\tCGETRF\n#define GETRS_N_SINGLE\tcgetrs_N_single\n#define GETRS_T_SINGLE\tcgetrs_T_single\n#define GETRS_R_SINGLE\tcgetrs_R_single\n#define GETRS_C_SINGLE\tcgetrs_C_single\n#define GETRS_N_PARALLEL\tcgetrs_N_parallel\n#define GETRS_T_PARALLEL\tcgetrs_T_parallel\n#define GETRS_R_PARALLEL\tcgetrs_R_parallel\n#define GETRS_C_PARALLEL\tcgetrs_C_parallel\n#define LASWP_PLUS\tCLASWP_PLUS\n#define LASWP_MINUS\tCLASWP_MINUS\n#define LASWP_NCOPY\tCLASWP_NCOPY\n#define GETRS_N\t\tCGETRS_N\n#define GETRS_T\t\tCGETRS_T\n#define GETRF_SINGLE\tcgetrf_single\n#define GETRF_PARALLEL\tcgetrf_parallel\n#define NEG_TCOPY\tCNEG_TCOPY\n#define\tLARF_L\t\tCLARF_L\n#define\tLARF_R\t\tCLARF_R\n#endif\n#endif\n\n#ifndef COMPLEX\n#ifdef XDOUBLE\n#define  POTF2_U  qpotf2_U\n#define  POTF2_L  qpotf2_L\n#define  LAUU2_U  qlauu2_U\n#define  LAUU2_L  qlauu2_L\n#define  POTRF_U_SINGLE qpotrf_U_single\n#define  POTRF_L_SINGLE qpotrf_L_single\n#define  POTRF_U_PARALLEL qpotrf_U_parallel\n#define  POTRF_L_PARALLEL qpotrf_L_parallel\n#define  LAUUM_U_SINGLE qlauum_U_single\n#define  LAUUM_L_SINGLE qlauum_L_single\n#define  LAUUM_U_PARALLEL qlauum_U_parallel\n#define  LAUUM_L_PARALLEL qlauum_L_parallel\n#define  TRTI2_UU qtrti2_UU\n#define  TRTI2_UN qtrti2_UN\n#define  TRTI2_LU qtrti2_LU\n#define  TRTI2_LN qtrti2_LN\n#define  TRTRI_UU_SINGLE qtrtri_UU_single\n#define  TRTRI_UN_SINGLE qtrtri_UN_single\n#define  TRTRI_LU_SINGLE qtrtri_LU_single\n#define  TRTRI_LN_SINGLE qtrtri_LN_single\n#define  TRTRI_UU_PARALLEL qtrtri_UU_parallel\n#define  TRTRI_UN_PARALLEL qtrtri_UN_parallel\n#define  TRTRI_LU_PARALLEL qtrtri_LU_parallel\n#define  TRTRI_LN_PARALLEL qtrtri_LN_parallel\n#elif defined(DOUBLE)\n#define  POTF2_U  dpotf2_U\n#define  POTF2_L  dpotf2_L\n#define  LAUU2_U  dlauu2_U\n#define  LAUU2_L  dlauu2_L\n#define  POTRF_U_SINGLE dpotrf_U_single\n#define  POTRF_L_SINGLE dpotrf_L_single\n#define  POTRF_U_PARALLEL dpotrf_U_parallel\n#define  POTRF_L_PARALLEL dpotrf_L_parallel\n#define  LAUUM_U_SINGLE dlauum_U_single\n#define  LAUUM_L_SINGLE dlauum_L_single\n#define  LAUUM_U_PARALLEL dlauum_U_parallel\n#define  LAUUM_L_PARALLEL dlauum_L_parallel\n#define  TRTI2_UU dtrti2_UU\n#define  TRTI2_UN dtrti2_UN\n#define  TRTI2_LU dtrti2_LU\n#define  TRTI2_LN dtrti2_LN\n#define  TRTRI_UU_SINGLE dtrtri_UU_single\n#define  TRTRI_UN_SINGLE dtrtri_UN_single\n#define  TRTRI_LU_SINGLE dtrtri_LU_single\n#define  TRTRI_LN_SINGLE dtrtri_LN_single\n#define  TRTRI_UU_PARALLEL dtrtri_UU_parallel\n#define  TRTRI_UN_PARALLEL dtrtri_UN_parallel\n#define  TRTRI_LU_PARALLEL dtrtri_LU_parallel\n#define  TRTRI_LN_PARALLEL dtrtri_LN_parallel\n#else\n#define  POTF2_U  spotf2_U\n#define  POTF2_L  spotf2_L\n#define  LAUU2_U  slauu2_U\n#define  LAUU2_L  slauu2_L\n#define  POTRF_U_SINGLE spotrf_U_single\n#define  POTRF_L_SINGLE spotrf_L_single\n#define  POTRF_U_PARALLEL spotrf_U_parallel\n#define  POTRF_L_PARALLEL spotrf_L_parallel\n#define  LAUUM_U_SINGLE slauum_U_single\n#define  LAUUM_L_SINGLE slauum_L_single\n#define  LAUUM_U_PARALLEL slauum_U_parallel\n#define  LAUUM_L_PARALLEL slauum_L_parallel\n#define  TRTI2_UU strti2_UU\n#define  TRTI2_UN strti2_UN\n#define  TRTI2_LU strti2_LU\n#define  TRTI2_LN strti2_LN\n#define  TRTRI_UU_SINGLE strtri_UU_single\n#define  TRTRI_UN_SINGLE strtri_UN_single\n#define  TRTRI_LU_SINGLE strtri_LU_single\n#define  TRTRI_LN_SINGLE strtri_LN_single\n#define  TRTRI_UU_PARALLEL strtri_UU_parallel\n#define  TRTRI_UN_PARALLEL strtri_UN_parallel\n#define  TRTRI_LU_PARALLEL strtri_LU_parallel\n#define  TRTRI_LN_PARALLEL strtri_LN_parallel\n#endif\n#else\n#ifdef XDOUBLE\n#define  POTF2_U  xpotf2_U\n#define  POTF2_L  xpotf2_L\n#define  LAUU2_U  xlauu2_U\n#define  LAUU2_L  xlauu2_L\n#define  POTRF_U_SINGLE xpotrf_U_single\n#define  POTRF_L_SINGLE xpotrf_L_single\n#define  POTRF_U_PARALLEL xpotrf_U_parallel\n#define  POTRF_L_PARALLEL xpotrf_L_parallel\n#define  LAUUM_U_SINGLE xlauum_U_single\n#define  LAUUM_L_SINGLE xlauum_L_single\n#define  LAUUM_U_PARALLEL xlauum_U_parallel\n#define  LAUUM_L_PARALLEL xlauum_L_parallel\n#define  TRTI2_UU xtrti2_UU\n#define  TRTI2_UN xtrti2_UN\n#define  TRTI2_LU xtrti2_LU\n#define  TRTI2_LN xtrti2_LN\n#define  TRTRI_UU_SINGLE xtrtri_UU_single\n#define  TRTRI_UN_SINGLE xtrtri_UN_single\n#define  TRTRI_LU_SINGLE xtrtri_LU_single\n#define  TRTRI_LN_SINGLE xtrtri_LN_single\n#define  TRTRI_UU_PARALLEL xtrtri_UU_parallel\n#define  TRTRI_UN_PARALLEL xtrtri_UN_parallel\n#define  TRTRI_LU_PARALLEL xtrtri_LU_parallel\n#define  TRTRI_LN_PARALLEL xtrtri_LN_parallel\n#elif defined(DOUBLE)\n#define  POTF2_U  zpotf2_U\n#define  POTF2_L  zpotf2_L\n#define  LAUU2_U  zlauu2_U\n#define  LAUU2_L  zlauu2_L\n#define  POTRF_U_SINGLE zpotrf_U_single\n#define  POTRF_L_SINGLE zpotrf_L_single\n#define  POTRF_U_PARALLEL zpotrf_U_parallel\n#define  POTRF_L_PARALLEL zpotrf_L_parallel\n#define  LAUUM_U_SINGLE zlauum_U_single\n#define  LAUUM_L_SINGLE zlauum_L_single\n#define  LAUUM_U_PARALLEL zlauum_U_parallel\n#define  LAUUM_L_PARALLEL zlauum_L_parallel\n#define  TRTI2_UU ztrti2_UU\n#define  TRTI2_UN ztrti2_UN\n#define  TRTI2_LU ztrti2_LU\n#define  TRTI2_LN ztrti2_LN\n#define  TRTRI_UU_SINGLE ztrtri_UU_single\n#define  TRTRI_UN_SINGLE ztrtri_UN_single\n#define  TRTRI_LU_SINGLE ztrtri_LU_single\n#define  TRTRI_LN_SINGLE ztrtri_LN_single\n#define  TRTRI_UU_PARALLEL ztrtri_UU_parallel\n#define  TRTRI_UN_PARALLEL ztrtri_UN_parallel\n#define  TRTRI_LU_PARALLEL ztrtri_LU_parallel\n#define  TRTRI_LN_PARALLEL ztrtri_LN_parallel\n#else\n#define  POTF2_U  cpotf2_U\n#define  POTF2_L  cpotf2_L\n#define  LAUU2_U  clauu2_U\n#define  LAUU2_L  clauu2_L\n#define  POTRF_U_SINGLE cpotrf_U_single\n#define  POTRF_L_SINGLE cpotrf_L_single\n#define  POTRF_U_PARALLEL cpotrf_U_parallel\n#define  POTRF_L_PARALLEL cpotrf_L_parallel\n#define  LAUUM_U_SINGLE clauum_U_single\n#define  LAUUM_L_SINGLE clauum_L_single\n#define  LAUUM_U_PARALLEL clauum_U_parallel\n#define  LAUUM_L_PARALLEL clauum_L_parallel\n#define  TRTI2_UU ctrti2_UU\n#define  TRTI2_UN ctrti2_UN\n#define  TRTI2_LU ctrti2_LU\n#define  TRTI2_LN ctrti2_LN\n#define  TRTRI_UU_SINGLE ctrtri_UU_single\n#define  TRTRI_UN_SINGLE ctrtri_UN_single\n#define  TRTRI_LU_SINGLE ctrtri_LU_single\n#define  TRTRI_LN_SINGLE ctrtri_LN_single\n#define  TRTRI_UU_PARALLEL ctrtri_UU_parallel\n#define  TRTRI_UN_PARALLEL ctrtri_UN_parallel\n#define  TRTRI_LU_PARALLEL ctrtri_LU_parallel\n#define  TRTRI_LN_PARALLEL ctrtri_LN_parallel\n#endif\n#endif\n\n#endif\n\n#ifndef COMPLEX\n#ifdef XDOUBLE\n#define  TRTRS_UNU_SINGLE  qtrtrs_UNU_single\n#define  TRTRS_UNN_SINGLE  qtrtrs_UNN_single\n#define  TRTRS_UTU_SINGLE  qtrtrs_UTU_single\n#define  TRTRS_UTN_SINGLE  qtrtrs_UTN_single\n#define  TRTRS_LNU_SINGLE  qtrtrs_LNU_single\n#define  TRTRS_LNN_SINGLE  qtrtrs_LNN_single\n#define  TRTRS_LTU_SINGLE  qtrtrs_LTU_single\n#define  TRTRS_LTN_SINGLE  qtrtrs_LTN_single\n#define  TRTRS_UNU_PARALLEL  qtrtrs_UNU_parallel\n#define  TRTRS_UNN_PARALLEL  qtrtrs_UNN_parallel\n#define  TRTRS_UTU_PARALLEL  qtrtrs_UTU_parallel\n#define  TRTRS_UTN_PARALLEL  qtrtrs_UTN_parallel\n#define  TRTRS_LNU_PARALLEL  qtrtrs_LNU_parallel\n#define  TRTRS_LNN_PARALLEL  qtrtrs_LNN_parallel\n#define  TRTRS_LTU_PARALLEL  qtrtrs_LTU_parallel\n#define  TRTRS_LTN_PARALLEL  qtrtrs_LTN_parallel\n\n#elif defined(DOUBLE)\n#define  TRTRS_UNU_SINGLE  dtrtrs_UNU_single\n#define  TRTRS_UNN_SINGLE  dtrtrs_UNN_single\n#define  TRTRS_UTU_SINGLE  dtrtrs_UTU_single\n#define  TRTRS_UTN_SINGLE  dtrtrs_UTN_single\n#define  TRTRS_LNU_SINGLE  dtrtrs_LNU_single\n#define  TRTRS_LNN_SINGLE  dtrtrs_LNN_single\n#define  TRTRS_LTU_SINGLE  dtrtrs_LTU_single\n#define  TRTRS_LTN_SINGLE  dtrtrs_LTN_single\n#define  TRTRS_UNU_PARALLEL  dtrtrs_UNU_parallel\n#define  TRTRS_UNN_PARALLEL  dtrtrs_UNN_parallel\n#define  TRTRS_UTU_PARALLEL  dtrtrs_UTU_parallel\n#define  TRTRS_UTN_PARALLEL  dtrtrs_UTN_parallel\n#define  TRTRS_LNU_PARALLEL  dtrtrs_LNU_parallel\n#define  TRTRS_LNN_PARALLEL  dtrtrs_LNN_parallel\n#define  TRTRS_LTU_PARALLEL  dtrtrs_LTU_parallel\n#define  TRTRS_LTN_PARALLEL  dtrtrs_LTN_parallel\n#else\n#define  TRTRS_UNU_SINGLE  strtrs_UNU_single\n#define  TRTRS_UNN_SINGLE  strtrs_UNN_single\n#define  TRTRS_UTU_SINGLE  strtrs_UTU_single\n#define  TRTRS_UTN_SINGLE  strtrs_UTN_single\n#define  TRTRS_LNU_SINGLE  strtrs_LNU_single\n#define  TRTRS_LNN_SINGLE  strtrs_LNN_single\n#define  TRTRS_LTU_SINGLE  strtrs_LTU_single\n#define  TRTRS_LTN_SINGLE  strtrs_LTN_single\n#define  TRTRS_UNU_PARALLEL  strtrs_UNU_parallel\n#define  TRTRS_UNN_PARALLEL  strtrs_UNN_parallel\n#define  TRTRS_UTU_PARALLEL  strtrs_UTU_parallel\n#define  TRTRS_UTN_PARALLEL  strtrs_UTN_parallel\n#define  TRTRS_LNU_PARALLEL  strtrs_LNU_parallel\n#define  TRTRS_LNN_PARALLEL  strtrs_LNN_parallel\n#define  TRTRS_LTU_PARALLEL  strtrs_LTU_parallel\n#define  TRTRS_LTN_PARALLEL  strtrs_LTN_parallel\n#endif\n#else\n#ifdef XDOUBLE\n#define  TRTRS_UNU_SINGLE  xtrtrs_UNU_single\n#define  TRTRS_UNN_SINGLE  xtrtrs_UNN_single\n#define  TRTRS_UTU_SINGLE  xtrtrs_UTU_single\n#define  TRTRS_UTN_SINGLE  xtrtrs_UTN_single\n#define  TRTRS_URU_SINGLE  xtrtrs_URU_single\n#define  TRTRS_URN_SINGLE  xtrtrs_URN_single\n#define  TRTRS_UCU_SINGLE  xtrtrs_UCU_single\n#define  TRTRS_UCN_SINGLE  xtrtrs_UCN_single\n#define  TRTRS_LNU_SINGLE  xtrtrs_LNU_single\n#define  TRTRS_LNN_SINGLE  xtrtrs_LNN_single\n#define  TRTRS_LTU_SINGLE  xtrtrs_LTU_single\n#define  TRTRS_LTN_SINGLE  xtrtrs_LTN_single\n#define  TRTRS_LRU_SINGLE  xtrtrs_LRU_single\n#define  TRTRS_LRN_SINGLE  xtrtrs_LRN_single\n#define  TRTRS_LCU_SINGLE  xtrtrs_LCU_single\n#define  TRTRS_LCN_SINGLE  xtrtrs_LCN_single\n#define  TRTRS_UNU_PARALLEL  xtrtrs_UNU_parallel\n#define  TRTRS_UNN_PARALLEL  xtrtrs_UNN_parallel\n#define  TRTRS_UTU_PARALLEL  xtrtrs_UTU_parallel\n#define  TRTRS_UTN_PARALLEL  xtrtrs_UTN_parallel\n#define  TRTRS_URU_PARALLEL  xtrtrs_URU_parallel\n#define  TRTRS_URN_PARALLEL  xtrtrs_URN_parallel\n#define  TRTRS_UCU_PARALLEL  xtrtrs_UCU_parallel\n#define  TRTRS_UCN_PARALLEL  xtrtrs_UCN_parallel\n#define  TRTRS_LNU_PARALLEL  xtrtrs_LNU_parallel\n#define  TRTRS_LNN_PARALLEL  xtrtrs_LNN_parallel\n#define  TRTRS_LTU_PARALLEL  xtrtrs_LTU_parallel\n#define  TRTRS_LTN_PARALLEL  xtrtrs_LTN_parallel\n#define  TRTRS_LRU_PARALLEL  xtrtrs_LRU_parallel\n#define  TRTRS_LRN_PARALLEL  xtrtrs_LRN_parallel\n#define  TRTRS_LCU_PARALLEL  xtrtrs_LCU_parallel\n#define  TRTRS_LCN_PARALLEL  xtrtrs_LCN_parallel\n#elif defined(DOUBLE)\n#define  TRTRS_UNU_SINGLE  ztrtrs_UNU_single\n#define  TRTRS_UNN_SINGLE  ztrtrs_UNN_single\n#define  TRTRS_UTU_SINGLE  ztrtrs_UTU_single\n#define  TRTRS_UTN_SINGLE  ztrtrs_UTN_single\n#define  TRTRS_URU_SINGLE  ztrtrs_URU_single\n#define  TRTRS_URN_SINGLE  ztrtrs_URN_single\n#define  TRTRS_UCU_SINGLE  ztrtrs_UCU_single\n#define  TRTRS_UCN_SINGLE  ztrtrs_UCN_single\n#define  TRTRS_LNU_SINGLE  ztrtrs_LNU_single\n#define  TRTRS_LNN_SINGLE  ztrtrs_LNN_single\n#define  TRTRS_LTU_SINGLE  ztrtrs_LTU_single\n#define  TRTRS_LTN_SINGLE  ztrtrs_LTN_single\n#define  TRTRS_LRU_SINGLE  ztrtrs_LRU_single\n#define  TRTRS_LRN_SINGLE  ztrtrs_LRN_single\n#define  TRTRS_LCU_SINGLE  ztrtrs_LCU_single\n#define  TRTRS_LCN_SINGLE  ztrtrs_LCN_single\n#define  TRTRS_UNU_PARALLEL  ztrtrs_UNU_parallel\n#define  TRTRS_UNN_PARALLEL  ztrtrs_UNN_parallel\n#define  TRTRS_UTU_PARALLEL  ztrtrs_UTU_parallel\n#define  TRTRS_UTN_PARALLEL  ztrtrs_UTN_parallel\n#define  TRTRS_URU_PARALLEL  ztrtrs_URU_parallel\n#define  TRTRS_URN_PARALLEL  ztrtrs_URN_parallel\n#define  TRTRS_UCU_PARALLEL  ztrtrs_UCU_parallel\n#define  TRTRS_UCN_PARALLEL  ztrtrs_UCN_parallel\n#define  TRTRS_LNU_PARALLEL  ztrtrs_LNU_parallel\n#define  TRTRS_LNN_PARALLEL  ztrtrs_LNN_parallel\n#define  TRTRS_LTU_PARALLEL  ztrtrs_LTU_parallel\n#define  TRTRS_LTN_PARALLEL  ztrtrs_LTN_parallel\n#define  TRTRS_LRU_PARALLEL  ztrtrs_LRU_parallel\n#define  TRTRS_LRN_PARALLEL  ztrtrs_LRN_parallel\n#define  TRTRS_LCU_PARALLEL  ztrtrs_LCU_parallel\n#define  TRTRS_LCN_PARALLEL  ztrtrs_LCN_parallel\n#else\n#define  TRTRS_UNU_SINGLE  ctrtrs_UNU_single\n#define  TRTRS_UNN_SINGLE  ctrtrs_UNN_single\n#define  TRTRS_UTU_SINGLE  ctrtrs_UTU_single\n#define  TRTRS_UTN_SINGLE  ctrtrs_UTN_single\n#define  TRTRS_URU_SINGLE  ctrtrs_URU_single\n#define  TRTRS_URN_SINGLE  ctrtrs_URN_single\n#define  TRTRS_UCU_SINGLE  ctrtrs_UCU_single\n#define  TRTRS_UCN_SINGLE  ctrtrs_UCN_single\n#define  TRTRS_LNU_SINGLE  ctrtrs_LNU_single\n#define  TRTRS_LNN_SINGLE  ctrtrs_LNN_single\n#define  TRTRS_LTU_SINGLE  ctrtrs_LTU_single\n#define  TRTRS_LTN_SINGLE  ctrtrs_LTN_single\n#define  TRTRS_LRU_SINGLE  ctrtrs_LRU_single\n#define  TRTRS_LRN_SINGLE  ctrtrs_LRN_single\n#define  TRTRS_LCU_SINGLE  ctrtrs_LCU_single\n#define  TRTRS_LCN_SINGLE  ctrtrs_LCN_single\n#define  TRTRS_UNU_PARALLEL  ctrtrs_UNU_parallel\n#define  TRTRS_UNN_PARALLEL  ctrtrs_UNN_parallel\n#define  TRTRS_UTU_PARALLEL  ctrtrs_UTU_parallel\n#define  TRTRS_UTN_PARALLEL  ctrtrs_UTN_parallel\n#define  TRTRS_URU_PARALLEL  ctrtrs_URU_parallel\n#define  TRTRS_URN_PARALLEL  ctrtrs_URN_parallel\n#define  TRTRS_UCU_PARALLEL  ctrtrs_UCU_parallel\n#define  TRTRS_UCN_PARALLEL  ctrtrs_UCN_parallel\n#define  TRTRS_LNU_PARALLEL  ctrtrs_LNU_parallel\n#define  TRTRS_LNN_PARALLEL  ctrtrs_LNN_parallel\n#define  TRTRS_LTU_PARALLEL  ctrtrs_LTU_parallel\n#define  TRTRS_LTN_PARALLEL  ctrtrs_LTN_parallel\n#define  TRTRS_LRU_PARALLEL  ctrtrs_LRU_parallel\n#define  TRTRS_LRN_PARALLEL  ctrtrs_LRN_parallel\n#define  TRTRS_LCU_PARALLEL  ctrtrs_LCU_parallel\n#define  TRTRS_LCN_PARALLEL  ctrtrs_LCN_parallel\n#endif\n#endif\n"
        },
        {
          "name": "common_mips.h",
          "type": "blob",
          "size": 2.744140625,
          "content": "/*****************************************************************************\nCopyright (c) 2016, The OpenBLAS Project\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   1. Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n\n   2. Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in\n      the documentation and/or other materials provided with the\n      distribution.\n   3. Neither the name of the OpenBLAS project nor the names of \n      its contributors may be used to endorse or promote products \n      derived from this software without specific prior written \n      permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\nUSE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n**********************************************************************************/\n\n#ifndef COMMON_MIPS\n#define COMMON_MIPS\n\n#define MB  __sync_synchronize()\n#define WMB __sync_synchronize()\n#define RMB __sync_synchronize()\n\n#define RETURN_BY_COMPLEX\n\n#ifndef ASSEMBLER\n\n#if !defined(MIPS24K)\nstatic inline unsigned int rpcc(void){\n  unsigned long ret;\n\n  __asm__ __volatile__(\".set   push    \\n\"\n          \"rdhwr %0, $30  \\n\"\n          \".set pop\" : \"=r\"(ret) : : \"memory\");\n\n  return ret;\n}\n#define RPCC_DEFINED\n#endif\n\nstatic inline int blas_quickdivide(blasint x, blasint y){\n  return x / y;\n}\n\n#define GET_IMAGE(res)\n\n#define GET_IMAGE_CANCEL\n\n#endif\n\n\n#ifndef F_INTERFACE\n#define REALNAME ASMNAME\n#else\n#define REALNAME ASMFNAME\n#endif\n\n#if defined(ASSEMBLER) && !defined(NEEDPARAM)\n\n#define PROLOGUE \\\n\t.arm\t\t ;\\\n\t.global\tREALNAME ;\\\nREALNAME:\n\n#define EPILOGUE\n\n#define PROFCODE\n\n#endif\n\n\n#define SEEK_ADDRESS\n\n#ifndef PAGESIZE\n#define PAGESIZE        ( 4 << 10)\n#endif\n#define HUGE_PAGESIZE   ( 4 << 20)\n\n#define BUFFER_SIZE     (16 << 21)\n\n\n#define BASE_ADDRESS (START_ADDRESS - BUFFER_SIZE * MAX_CPU_NUMBER)\n\n#ifndef MAP_ANONYMOUS\n#define MAP_ANONYMOUS MAP_ANON\n#endif\n\n#endif\n"
        },
        {
          "name": "common_mips64.h",
          "type": "blob",
          "size": 7.9248046875,
          "content": "/*****************************************************************************\nCopyright (c) 2011-2014, The OpenBLAS Project\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   1. Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n\n   2. Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in\n      the documentation and/or other materials provided with the\n      distribution.\n   3. Neither the name of the OpenBLAS project nor the names of \n      its contributors may be used to endorse or promote products \n      derived from this software without specific prior written \n      permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\nUSE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n**********************************************************************************/\n\n/*********************************************************************/\n/* Copyright 2009, 2010 The University of Texas at Austin.           */\n/* All rights reserved.                                              */\n/*                                                                   */\n/* Redistribution and use in source and binary forms, with or        */\n/* without modification, are permitted provided that the following   */\n/* conditions are met:                                               */\n/*                                                                   */\n/*   1. Redistributions of source code must retain the above         */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer.                                                  */\n/*                                                                   */\n/*   2. Redistributions in binary form must reproduce the above      */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer in the documentation and/or other materials       */\n/*      provided with the distribution.                              */\n/*                                                                   */\n/*    THIS  SOFTWARE IS PROVIDED  BY THE  UNIVERSITY OF  TEXAS AT    */\n/*    AUSTIN  ``AS IS''  AND ANY  EXPRESS OR  IMPLIED WARRANTIES,    */\n/*    INCLUDING, BUT  NOT LIMITED  TO, THE IMPLIED  WARRANTIES OF    */\n/*    MERCHANTABILITY  AND FITNESS FOR  A PARTICULAR  PURPOSE ARE    */\n/*    DISCLAIMED.  IN  NO EVENT SHALL THE UNIVERSITY  OF TEXAS AT    */\n/*    AUSTIN OR CONTRIBUTORS BE  LIABLE FOR ANY DIRECT, INDIRECT,    */\n/*    INCIDENTAL,  SPECIAL, EXEMPLARY,  OR  CONSEQUENTIAL DAMAGES    */\n/*    (INCLUDING, BUT  NOT LIMITED TO,  PROCUREMENT OF SUBSTITUTE    */\n/*    GOODS  OR  SERVICES; LOSS  OF  USE,  DATA,  OR PROFITS;  OR    */\n/*    BUSINESS INTERRUPTION) HOWEVER CAUSED  AND ON ANY THEORY OF    */\n/*    LIABILITY, WHETHER  IN CONTRACT, STRICT  LIABILITY, OR TORT    */\n/*    (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY WAY OUT    */\n/*    OF  THE  USE OF  THIS  SOFTWARE,  EVEN  IF ADVISED  OF  THE    */\n/*    POSSIBILITY OF SUCH DAMAGE.                                    */\n/*                                                                   */\n/* The views and conclusions contained in the software and           */\n/* documentation are those of the authors and should not be          */\n/* interpreted as representing official policies, either expressed   */\n/* or implied, of The University of Texas at Austin.                 */\n/*********************************************************************/\n\n#ifndef COMMON_MIPS64\n#define COMMON_MIPS64\n\n#define MB  __sync_synchronize()\n#define WMB __sync_synchronize()\n#define RMB __sync_synchronize()\n\n#ifndef ASSEMBLER\n\nstatic inline unsigned int rpcc(void){\n  unsigned long ret;\n\n  //  unsigned long long tmp;\n  //__asm__ __volatile__(\"dmfc0 %0, $25, 1\": \"=r\"(tmp):: \"memory\");\n  //ret=tmp;\n  __asm__ __volatile__(\".set push \\n\"\n#if !defined(__mips_isa_rev) || __mips_isa_rev < 2\n                       \".set mips32r2\\n\"\n#endif\n                       \"rdhwr %0, $2\\n\"\n                       \".set pop\": \"=r\"(ret):: \"memory\");\n\n  return ret;\n}\n#define RPCC_DEFINED\n\n#ifndef NO_AFFINITY\n//#define WHEREAMI\nstatic inline int WhereAmI(void){\n  int ret=0;\n  __asm__ __volatile__(\".set push \\n\"\n#if !defined(__mips_isa_rev) || __mips_isa_rev < 2\n                       \".set mips32r2\\n\"\n#endif\n                       \"rdhwr %0, $0\\n\"\n                       \".set pop\": \"=r\"(ret):: \"memory\");\n  return ret;\n\n}\n#endif\n\nstatic inline int blas_quickdivide(blasint x, blasint y){\n  return x / y;\n}\n\n#ifdef DOUBLE\n#define GET_IMAGE(res)  __asm__ __volatile__(\"mov.d %0, $f2\" : \"=f\"(res)  : : \"memory\")\n#else\n#define GET_IMAGE(res)  __asm__ __volatile__(\"mov.s %0, $f2\" : \"=f\"(res)  : : \"memory\")\n#endif\n\n#define GET_IMAGE_CANCEL\n\n#endif\n\n\n#ifdef ASSEMBLER\n\n#define HALT\tteq\t$0, $0\n#define NOP\tmove\t$0, $0\n\n#ifdef DOUBLE\n#define LD\tldc1\n#define ST\tsdc1\n#define MADD\tmadd.d\n#define NMADD\tnmadd.d\n#define MSUB\tmsub.d\n#define NMSUB\tnmsub.d\n#define ADD\tadd.d\n#define SUB\tsub.d\n#define MUL\tmul.d\n#define MOV\tmov.d\n#define CMOVF\tmovf.d\n#define CMOVT\tmovt.d\n#define MTC\tdmtc1\n#define FABS\tabs.d\n#define CMPEQ\tc.eq.d\n#define CMPLE\tc.le.d\n#define CMPLT\tc.lt.d\n#define\tNEG\tneg.d\n#else\n#define LD\tlwc1\n#define ST\tswc1\n#define MADD\tmadd.s\n#define NMADD\tnmadd.s\n#define MSUB\tmsub.s\n#define NMSUB\tnmsub.s\n#define ADD\tadd.s\n#define SUB\tsub.s\n#define MUL\tmul.s\n#define MOV\tmov.s\n#define CMOVF\tmovf.s\n#define CMOVT\tmovt.s\n#define MTC\tmtc1\n#define FABS\tabs.s\n#define CMPEQ\tc.eq.s\n#define CMPLE\tc.le.s\n#define CMPLT\tc.lt.s\n#define PLU     plu.ps\n#define PLL     pll.ps\n#define PUU     puu.ps\n#define PUL     pul.ps\n#define MADPS   madd.ps\n#define CVTU    cvt.s.pu\n#define CVTL    cvt.s.pl\n#define\tNEG\tneg.s\n#endif\n\n#if   defined(__64BIT__) &&  defined(USE64BITINT)\n#define LDINT\tld\n#define LDARG\tld\n#define SDARG\tsd\n#elif defined(__64BIT__) && !defined(USE64BITINT)\n#define LDINT\tlw\n#define LDARG\tld\n#define SDARG\tsd\n#else\n#define LDINT\tlw\n#define LDARG\tlw\n#define SDARG\tsw\n#endif\n\n\n#ifndef F_INTERFACE\n#define REALNAME ASMNAME\n#else\n#define REALNAME ASMFNAME\n#endif\n\n#if defined(ASSEMBLER) && !defined(NEEDPARAM)\n\n#if defined(__mips_isa_rev) && __mips_isa_rev >= 6\n#define ASSEMBLER_ARCH mips64r6\n#else\n#define ASSEMBLER_ARCH mips64\n#endif\n\n#define PROLOGUE \\\n\t.text ;\\\n\t.set\tASSEMBLER_ARCH ;\\\n\t.align 5 ;\\\n\t.globl\tREALNAME ;\\\n\t.ent\tREALNAME ;\\\n\t.type\tREALNAME, @function ;\\\nREALNAME: ;\\\n\t.set\tnoreorder ;\\\n\t.set\tnomacro\n\n#if defined(__linux__) && defined(__ELF__)\n#define GNUSTACK .section .note.GNU-stack,\"\",@progbits\n#else\n#define GNUSTACK\n#endif\n\n#define EPILOGUE \\\n\t.set\tmacro ;\\\n\t.set\treorder ;\\\n\t.end\tREALNAME ;\\\n\tGNUSTACK\n\n#define PROFCODE\n#endif\n\n#endif\n\n#define SEEK_ADDRESS\n\n#define BUFFER_SIZE     ( 32 << 21)\n\n#if defined(LOONGSON3R3) || defined(LOONGSON3R4)\n#define PAGESIZE\t(16UL << 10)\n#define FIXED_PAGESIZE\t(16UL << 10)\n#endif\n\n#ifndef PAGESIZE\n#define PAGESIZE\t(64UL << 10)\n#endif\n#define HUGE_PAGESIZE   ( 2 << 20)\n\n#define BASE_ADDRESS (START_ADDRESS - BUFFER_SIZE * MAX_CPU_NUMBER)\n\n#ifndef MAP_ANONYMOUS\n#define MAP_ANONYMOUS MAP_ANON\n#endif\n\n#if defined(LOONGSON3R3) || defined(LOONGSON3R4)\n#define PREFETCHD_(x) ld $0, x\n#define PREFETCHD(x)  PREFETCHD_(x)\n#else\n#define PREFETCHD(x)\n#endif\n\n#endif\n"
        },
        {
          "name": "common_param.h",
          "type": "blob",
          "size": 110.9638671875,
          "content": "/*********************************************************************/\n/* Copyright 2009, 2010 The University of Texas at Austin.           */\n/* Copyright 2023 The OpenBLAS Project.                              */\n/* All rights reserved.                                              */\n/*                                                                   */\n/* Redistribution and use in source and binary forms, with or        */\n/* without modification, are permitted provided that the following   */\n/* conditions are met:                                               */\n/*                                                                   */\n/*   1. Redistributions of source code must retain the above         */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer.                                                  */\n/*                                                                   */\n/*   2. Redistributions in binary form must reproduce the above      */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer in the documentation and/or other materials       */\n/*      provided with the distribution.                              */\n/*                                                                   */\n/*    THIS  SOFTWARE IS PROVIDED  BY THE  UNIVERSITY OF  TEXAS AT    */\n/*    AUSTIN  ``AS IS''  AND ANY  EXPRESS OR  IMPLIED WARRANTIES,    */\n/*    INCLUDING, BUT  NOT LIMITED  TO, THE IMPLIED  WARRANTIES OF    */\n/*    MERCHANTABILITY  AND FITNESS FOR  A PARTICULAR  PURPOSE ARE    */\n/*    DISCLAIMED.  IN  NO EVENT SHALL THE UNIVERSITY  OF TEXAS AT    */\n/*    AUSTIN OR CONTRIBUTORS BE  LIABLE FOR ANY DIRECT, INDIRECT,    */\n/*    INCIDENTAL,  SPECIAL, EXEMPLARY,  OR  CONSEQUENTIAL DAMAGES    */\n/*    (INCLUDING, BUT  NOT LIMITED TO,  PROCUREMENT OF SUBSTITUTE    */\n/*    GOODS  OR  SERVICES; LOSS  OF  USE,  DATA,  OR PROFITS;  OR    */\n/*    BUSINESS INTERRUPTION) HOWEVER CAUSED  AND ON ANY THEORY OF    */\n/*    LIABILITY, WHETHER  IN CONTRACT, STRICT  LIABILITY, OR TORT    */\n/*    (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY WAY OUT    */\n/*    OF  THE  USE OF  THIS  SOFTWARE,  EVEN  IF ADVISED  OF  THE    */\n/*    POSSIBILITY OF SUCH DAMAGE.                                    */\n/*                                                                   */\n/* The views and conclusions contained in the software and           */\n/* documentation are those of the authors and should not be          */\n/* interpreted as representing official policies, either expressed   */\n/* or implied, of The University of Texas at Austin.                 */\n/*********************************************************************/\n\n#ifndef COMMON_PARAM_H\n#define COMMON_PARAM_H\n\n#ifndef ASSEMBLER\n\n#ifdef DYNAMIC_ARCH\n\ntypedef struct {\n  int dtb_entries;\n  int switch_ratio;\n  int offsetA, offsetB, align;\n\n#if BUILD_BFLOAT16 == 1\n  int sbgemm_p, sbgemm_q, sbgemm_r;\n  int sbgemm_unroll_m, sbgemm_unroll_n, sbgemm_unroll_mn;\n  int sbgemm_align_k;\n  int need_amxtile_permission;  // 0 default, 1 for device support amx.\n\n  void   (*sbstobf16_k) (BLASLONG, float    *, BLASLONG, bfloat16 *, BLASLONG);\n  void   (*sbdtobf16_k) (BLASLONG, double   *, BLASLONG, bfloat16 *, BLASLONG);\n  void   (*sbf16tos_k)  (BLASLONG, bfloat16 *, BLASLONG, float    *, BLASLONG);\n  void   (*dbf16tod_k)  (BLASLONG, bfloat16 *, BLASLONG, double   *, BLASLONG);\n\n  float  (*sbamax_k) (BLASLONG, float *, BLASLONG);\n  float  (*sbamin_k) (BLASLONG, float *, BLASLONG);\n  float  (*sbmax_k)  (BLASLONG, float *, BLASLONG);\n  float  (*sbmin_k)  (BLASLONG, float *, BLASLONG);\nBLASLONG (*isbamax_k)(BLASLONG, float *, BLASLONG);\nBLASLONG (*isbamin_k)(BLASLONG, float *, BLASLONG);\nBLASLONG (*isbmax_k) (BLASLONG, float *, BLASLONG);\nBLASLONG (*isbmin_k) (BLASLONG, float *, BLASLONG);\n\n  float  (*sbnrm2_k) (BLASLONG, float *, BLASLONG);\n  float  (*sbasum_k) (BLASLONG, float *, BLASLONG);\n  float  (*sbsum_k)  (BLASLONG, float *, BLASLONG);\n  int    (*sbcopy_k) (BLASLONG, float *, BLASLONG, float *, BLASLONG);\n  float  (*sbdot_k)  (BLASLONG, bfloat16 *, BLASLONG, bfloat16 *, BLASLONG);\n  double (*dsbdot_k) (BLASLONG, float *, BLASLONG, float *, BLASLONG);\n\n  int    (*sbrot_k)  (BLASLONG, float *, BLASLONG, float *, BLASLONG, float, float);\n\n  int    (*sbaxpy_k) (BLASLONG, BLASLONG, BLASLONG, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG);\n  int    (*sbscal_k) (BLASLONG, BLASLONG, BLASLONG, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG);\n  int    (*sbswap_k) (BLASLONG, BLASLONG, BLASLONG, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG);\n\n  int    (*sbgemv_n) (BLASLONG, BLASLONG, float, bfloat16 *, BLASLONG, bfloat16 *, BLASLONG, float, float *, BLASLONG);\n  int    (*sbgemv_t) (BLASLONG, BLASLONG, float, bfloat16 *, BLASLONG, bfloat16 *, BLASLONG, float, float *, BLASLONG);\n  int    (*sbger_k)  (BLASLONG, BLASLONG, BLASLONG, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\n\n  int    (*sbsymv_L) (BLASLONG, BLASLONG, float,  float  *, BLASLONG, float  *, BLASLONG, float  *, BLASLONG, float *);\n  int    (*sbsymv_U) (BLASLONG, BLASLONG, float,  float  *, BLASLONG, float  *, BLASLONG, float  *, BLASLONG, float *);\n\n  int    (*sbgemm_kernel   )(BLASLONG, BLASLONG, BLASLONG, float, bfloat16 *, bfloat16 *, float *, BLASLONG);\n  int    (*sbgemm_beta     )(BLASLONG, BLASLONG, BLASLONG, float, bfloat16 *, BLASLONG, bfloat16 *, BLASLONG, float *, BLASLONG);\n\n  int    (*sbgemm_incopy   )(BLASLONG, BLASLONG, bfloat16 *, BLASLONG, bfloat16 *);\n  int    (*sbgemm_itcopy   )(BLASLONG, BLASLONG, bfloat16 *, BLASLONG, bfloat16 *);\n  int    (*sbgemm_oncopy   )(BLASLONG, BLASLONG, bfloat16 *, BLASLONG, bfloat16 *);\n  int    (*sbgemm_otcopy   )(BLASLONG, BLASLONG, bfloat16 *, BLASLONG, bfloat16 *);\n\n  int    (*sbtrsm_kernel_LN)(BLASLONG, BLASLONG, BLASLONG, float, float *, float *, float *, BLASLONG, BLASLONG);\n  int    (*sbtrsm_kernel_LT)(BLASLONG, BLASLONG, BLASLONG, float, float *, float *, float *, BLASLONG, BLASLONG);\n  int    (*sbtrsm_kernel_RN)(BLASLONG, BLASLONG, BLASLONG, float, float *, float *, float *, BLASLONG, BLASLONG);\n  int    (*sbtrsm_kernel_RT)(BLASLONG, BLASLONG, BLASLONG, float, float *, float *, float *, BLASLONG, BLASLONG);\n\n  int    (*sbtrsm_iunucopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, float *);\n  int    (*sbtrsm_iunncopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, float *);\n  int    (*sbtrsm_iutucopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, float *);\n  int    (*sbtrsm_iutncopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, float *);\n  int    (*sbtrsm_ilnucopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, float *);\n  int    (*sbtrsm_ilnncopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, float *);\n  int    (*sbtrsm_iltucopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, float *);\n  int    (*sbtrsm_iltncopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, float *);\n  int    (*sbtrsm_ounucopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, float *);\n  int    (*sbtrsm_ounncopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, float *);\n  int    (*sbtrsm_outucopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, float *);\n  int    (*sbtrsm_outncopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, float *);\n  int    (*sbtrsm_olnucopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, float *);\n  int    (*sbtrsm_olnncopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, float *);\n  int    (*sbtrsm_oltucopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, float *);\n  int    (*sbtrsm_oltncopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, float *);\n\n  int    (*sbtrmm_kernel_RN)(BLASLONG, BLASLONG, BLASLONG, float, float *, float *, float *, BLASLONG, BLASLONG);\n  int    (*sbtrmm_kernel_RT)(BLASLONG, BLASLONG, BLASLONG, float, float *, float *, float *, BLASLONG, BLASLONG);\n  int    (*sbtrmm_kernel_LN)(BLASLONG, BLASLONG, BLASLONG, float, float *, float *, float *, BLASLONG, BLASLONG);\n  int    (*sbtrmm_kernel_LT)(BLASLONG, BLASLONG, BLASLONG, float, float *, float *, float *, BLASLONG, BLASLONG);\n\n  int    (*sbtrmm_iunucopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*sbtrmm_iunncopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*sbtrmm_iutucopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*sbtrmm_iutncopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*sbtrmm_ilnucopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*sbtrmm_ilnncopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*sbtrmm_iltucopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*sbtrmm_iltncopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*sbtrmm_ounucopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*sbtrmm_ounncopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*sbtrmm_outucopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*sbtrmm_outncopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*sbtrmm_olnucopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*sbtrmm_olnncopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*sbtrmm_oltucopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*sbtrmm_oltncopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n\n  int    (*sbsymm_iutcopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*sbsymm_iltcopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*sbsymm_outcopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*sbsymm_oltcopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n\n  int\t (*sbneg_tcopy)   (BLASLONG, BLASLONG, float *, BLASLONG, float *);\n  int    (*sblaswp_ncopy) (BLASLONG, BLASLONG, BLASLONG, float *, BLASLONG, blasint *, float *);\n\n#ifdef SMALL_MATRIX_OPT\n  int    (*sbgemm_small_matrix_permit)(int transa, int transb, BLASLONG m, BLASLONG n, BLASLONG k, float alpha, float beta);\n\n  int    (*sbgemm_small_kernel_nn    )(BLASLONG m, BLASLONG n, BLASLONG k, bfloat16 * A, BLASLONG lda, float alpha, bfloat16 * B, BLASLONG ldb, float beta, float * C, BLASLONG ldc);\n  int    (*sbgemm_small_kernel_nt    )(BLASLONG m, BLASLONG n, BLASLONG k, bfloat16 * A, BLASLONG lda, float alpha, bfloat16 * B, BLASLONG ldb, float beta, float * C, BLASLONG ldc);\n  int    (*sbgemm_small_kernel_tn    )(BLASLONG m, BLASLONG n, BLASLONG k, bfloat16 * A, BLASLONG lda, float alpha, bfloat16 * B, BLASLONG ldb, float beta, float * C, BLASLONG ldc);\n  int    (*sbgemm_small_kernel_tt    )(BLASLONG m, BLASLONG n, BLASLONG k, bfloat16 * A, BLASLONG lda, float alpha, bfloat16 * B, BLASLONG ldb, float beta, float * C, BLASLONG ldc);\n\n  int    (*sbgemm_small_kernel_b0_nn )(BLASLONG m, BLASLONG n, BLASLONG k, bfloat16 * A, BLASLONG lda, float alpha, bfloat16 * B, BLASLONG ldb, float * C, BLASLONG ldc);\n  int    (*sbgemm_small_kernel_b0_nt )(BLASLONG m, BLASLONG n, BLASLONG k, bfloat16 * A, BLASLONG lda, float alpha, bfloat16 * B, BLASLONG ldb, float * C, BLASLONG ldc);\n  int    (*sbgemm_small_kernel_b0_tn )(BLASLONG m, BLASLONG n, BLASLONG k, bfloat16 * A, BLASLONG lda, float alpha, bfloat16 * B, BLASLONG ldb, float * C, BLASLONG ldc);\n  int    (*sbgemm_small_kernel_b0_tt )(BLASLONG m, BLASLONG n, BLASLONG k, bfloat16 * A, BLASLONG lda, float alpha, bfloat16 * B, BLASLONG ldb, float * C, BLASLONG ldc);\n#endif\n#endif\n\n#if (BUILD_SINGLE == 1) || (BUILD_DOUBLE == 1) || (BUILD_COMPLEX == 1) || (BUILD_COMPLEX16 == 1)\n  int sgemm_p, sgemm_q, sgemm_r;\n  int sgemm_unroll_m, sgemm_unroll_n, sgemm_unroll_mn;\n#endif\n\n  int exclusive_cache;\n\n#if (BUILD_SINGLE == 1) || (BUILD_COMPLEX == 1)\n  float  (*samax_k) (BLASLONG, float *, BLASLONG);\n  float  (*samin_k) (BLASLONG, float *, BLASLONG);\n  float  (*smax_k)  (BLASLONG, float *, BLASLONG);\n  float  (*smin_k)  (BLASLONG, float *, BLASLONG);\n#endif\n\n#if (BUILD_SINGLE==1) || (BUILD_DOUBLE ==1) || (BUILD_COMPLEX==1)\nBLASLONG (*isamax_k)(BLASLONG, float *, BLASLONG);\n#endif\n#if (BUILD_SINGLE==1) || (BUILD_COMPLEX==1)\nBLASLONG (*isamin_k)(BLASLONG, float *, BLASLONG);\nBLASLONG (*ismax_k) (BLASLONG, float *, BLASLONG);\nBLASLONG (*ismin_k) (BLASLONG, float *, BLASLONG);\n  float  (*snrm2_k) (BLASLONG, float *, BLASLONG);\n  float  (*sasum_k) (BLASLONG, float *, BLASLONG);\n#endif\n#if (BUILD_SINGLE==1)\n  float  (*ssum_k)  (BLASLONG, float *, BLASLONG);\n#endif  \n#if (BUILD_SINGLE==1) || (BUILD_DOUBLE==1) || (BUILD_COMPLEX==1)\n  int    (*scopy_k) (BLASLONG, float *, BLASLONG, float *, BLASLONG);\n  float  (*sdot_k)  (BLASLONG, float *, BLASLONG, float *, BLASLONG);\n  //double (*dsdot_k) (BLASLONG, float *, BLASLONG, float *, BLASLONG);\n\n  int    (*srot_k)  (BLASLONG, float *, BLASLONG, float *, BLASLONG, float, float);\n#endif\n#if (BUILD_SINGLE==1) || (BUILD_DOUBLE==1) || (BUILD_COMPLEX==1)\n  int    (*saxpy_k) (BLASLONG, BLASLONG, BLASLONG, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG);\n#endif\n#if (BUILD_SINGLE==1) || (BUILD_DOUBLE==1) || (BUILD_COMPLEX==1) || (BUILD_COMPLEX16==1)\n  int    (*sscal_k) (BLASLONG, BLASLONG, BLASLONG, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG);\n#endif\n#if (BUILD_SINGLE==1) || (BUILD_DOUBLE==1) || (BUILD_COMPLEX==1)\n  int    (*sswap_k) (BLASLONG, BLASLONG, BLASLONG, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG);\n\n  int    (*sgemv_n) (BLASLONG, BLASLONG, BLASLONG, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\n  int    (*sgemv_t) (BLASLONG, BLASLONG, BLASLONG, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\n#endif\n#if (BUILD_SINGLE==1)\n  int    (*sger_k)  (BLASLONG, BLASLONG, BLASLONG, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\n  int    (*ssymv_L) (BLASLONG, BLASLONG, float,  float  *, BLASLONG, float  *, BLASLONG, float  *, BLASLONG, float *);\n  int    (*ssymv_U) (BLASLONG, BLASLONG, float,  float  *, BLASLONG, float  *, BLASLONG, float  *, BLASLONG, float *);\n#endif\n\n#if (BUILD_SINGLE==1) || (BUILD_DOUBLE==1) || (BUILD_COMPLEX==1)\n#ifdef ARCH_X86_64\n  void (*sgemm_direct) (BLASLONG, BLASLONG, BLASLONG, float *, BLASLONG , float *, BLASLONG , float * , BLASLONG);\n  int  (*sgemm_direct_performant) (BLASLONG M, BLASLONG N, BLASLONG K);\n#endif\n  \n  int    (*sgemm_kernel   )(BLASLONG, BLASLONG, BLASLONG, float, float *, float *, float *, BLASLONG);\n  int    (*sgemm_beta     )(BLASLONG, BLASLONG, BLASLONG, float, float *, BLASLONG, float *, BLASLONG, float  *, BLASLONG);\n\n\n  int    (*sgemm_incopy   )(BLASLONG, BLASLONG, float *, BLASLONG, float *);\n  int    (*sgemm_itcopy   )(BLASLONG, BLASLONG, float *, BLASLONG, float *);\n  int    (*sgemm_oncopy   )(BLASLONG, BLASLONG, float *, BLASLONG, float *);\n  int    (*sgemm_otcopy   )(BLASLONG, BLASLONG, float *, BLASLONG, float *);\n#endif\n#if (BUILD_SINGLE==1) || (BUILD_DOUBLE==1) || (BUILD_COMPLEX==1)\n#ifdef SMALL_MATRIX_OPT\n  int    (*sgemm_small_matrix_permit)(int transa, int transb, BLASLONG m, BLASLONG n, BLASLONG k, float alpha, float beta);\n\n  int    (*sgemm_small_kernel_nn    )(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha, float * B, BLASLONG ldb, float beta, float * C, BLASLONG ldc);\n  int    (*sgemm_small_kernel_nt    )(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha, float * B, BLASLONG ldb, float beta, float * C, BLASLONG ldc);\n  int    (*sgemm_small_kernel_tn    )(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha, float * B, BLASLONG ldb, float beta, float * C, BLASLONG ldc);\n  int    (*sgemm_small_kernel_tt    )(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha, float * B, BLASLONG ldb, float beta, float * C, BLASLONG ldc);\n\n  int    (*sgemm_small_kernel_b0_nn )(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha, float * B, BLASLONG ldb, float * C, BLASLONG ldc);\n  int    (*sgemm_small_kernel_b0_nt )(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha, float * B, BLASLONG ldb, float * C, BLASLONG ldc);\n  int    (*sgemm_small_kernel_b0_tn )(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha, float * B, BLASLONG ldb, float * C, BLASLONG ldc);\n  int    (*sgemm_small_kernel_b0_tt )(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha, float * B, BLASLONG ldb, float * C, BLASLONG ldc);\n#endif\n\n  int    (*strsm_kernel_LN)(BLASLONG, BLASLONG, BLASLONG, float, float *, float *, float *, BLASLONG, BLASLONG);\n  int    (*strsm_kernel_LT)(BLASLONG, BLASLONG, BLASLONG, float, float *, float *, float *, BLASLONG, BLASLONG);\n  int    (*strsm_kernel_RN)(BLASLONG, BLASLONG, BLASLONG, float, float *, float *, float *, BLASLONG, BLASLONG);\n  int    (*strsm_kernel_RT)(BLASLONG, BLASLONG, BLASLONG, float, float *, float *, float *, BLASLONG, BLASLONG);\n\n  int    (*strsm_iunucopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, float *);\n  int    (*strsm_iunncopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, float *);\n  int    (*strsm_iutucopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, float *);\n  int    (*strsm_iutncopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, float *);\n  int    (*strsm_ilnucopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, float *);\n  int    (*strsm_ilnncopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, float *);\n  int    (*strsm_iltucopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, float *);\n  int    (*strsm_iltncopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, float *);\n  int    (*strsm_ounucopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, float *);\n  int    (*strsm_ounncopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, float *);\n  int    (*strsm_outucopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, float *);\n  int    (*strsm_outncopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, float *);\n  int    (*strsm_olnucopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, float *);\n  int    (*strsm_olnncopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, float *);\n  int    (*strsm_oltucopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, float *);\n  int    (*strsm_oltncopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, float *);\n#endif\n#if (BUILD_SINGLE==1)\n  int    (*strmm_kernel_RN)(BLASLONG, BLASLONG, BLASLONG, float, float *, float *, float *, BLASLONG, BLASLONG);\n  int    (*strmm_kernel_RT)(BLASLONG, BLASLONG, BLASLONG, float, float *, float *, float *, BLASLONG, BLASLONG);\n  int    (*strmm_kernel_LN)(BLASLONG, BLASLONG, BLASLONG, float, float *, float *, float *, BLASLONG, BLASLONG);\n  int    (*strmm_kernel_LT)(BLASLONG, BLASLONG, BLASLONG, float, float *, float *, float *, BLASLONG, BLASLONG);\n\n  int    (*strmm_iunucopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*strmm_iunncopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*strmm_iutucopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*strmm_iutncopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*strmm_ilnucopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*strmm_ilnncopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*strmm_iltucopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*strmm_iltncopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*strmm_ounucopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*strmm_ounncopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*strmm_outucopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*strmm_outncopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*strmm_olnucopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*strmm_olnncopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*strmm_oltucopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*strmm_oltncopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n\n  int    (*ssymm_iutcopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*ssymm_iltcopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*ssymm_outcopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*ssymm_oltcopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n\n  int\t (*sneg_tcopy)   (BLASLONG, BLASLONG, float *, BLASLONG, float *);\n  int    (*slaswp_ncopy) (BLASLONG, BLASLONG, BLASLONG, float *, BLASLONG, blasint *, float *);\n#endif\n\n#if (BUILD_DOUBLE==1) || (BUILD_COMPLEX16==1)\n  int dgemm_p, dgemm_q, dgemm_r;\n  int dgemm_unroll_m, dgemm_unroll_n, dgemm_unroll_mn;\n#endif\n\n#if (BUILD_DOUBLE==1) || (BUILD_COMPLEX16==1)\n  double (*damax_k) (BLASLONG, double *, BLASLONG);\n  double (*damin_k) (BLASLONG, double *, BLASLONG);\n  double (*dmax_k)  (BLASLONG, double *, BLASLONG);\n  double (*dmin_k)  (BLASLONG, double *, BLASLONG);\nBLASLONG (*idamax_k)(BLASLONG, double *, BLASLONG);\nBLASLONG (*idamin_k)(BLASLONG, double *, BLASLONG);\nBLASLONG (*idmax_k) (BLASLONG, double *, BLASLONG);\nBLASLONG (*idmin_k) (BLASLONG, double *, BLASLONG);\n\n  double (*dnrm2_k) (BLASLONG, double *, BLASLONG);\n  double (*dasum_k) (BLASLONG, double *, BLASLONG);\n#endif\n#if (BUILD_DOUBLE==1)\n  double (*dsum_k)  (BLASLONG, double *, BLASLONG);\n#endif\n#if (BUILD_DOUBLE==1) || (BUILD_COMPLEX16==1)\n  int    (*dcopy_k) (BLASLONG, double *, BLASLONG, double *, BLASLONG);\n  double (*ddot_k)  (BLASLONG, double *, BLASLONG, double *, BLASLONG);\n#endif\n#if (BUILD_SINGLE==1) || (BUILD_DOUBLE==1)\n  double (*dsdot_k) (BLASLONG, float *, BLASLONG, float *, BLASLONG);\n#endif\n#if (BUILD_DOUBLE==1) || (BUILD_COMPLEX16==1)\n  int    (*drot_k)  (BLASLONG, double *, BLASLONG, double *, BLASLONG, double, double);\n  int    (*daxpy_k) (BLASLONG, BLASLONG, BLASLONG, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG);\n  int    (*dscal_k) (BLASLONG, BLASLONG, BLASLONG, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG);\n  int    (*dswap_k) (BLASLONG, BLASLONG, BLASLONG, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG);\n  int    (*dgemv_n) (BLASLONG, BLASLONG, BLASLONG, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\n  int    (*dgemv_t) (BLASLONG, BLASLONG, BLASLONG, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\n#endif\n#if (BUILD_DOUBLE==1)\n  int    (*dger_k)  (BLASLONG, BLASLONG, BLASLONG, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\n\n  int    (*dsymv_L) (BLASLONG, BLASLONG, double,  double  *, BLASLONG, double  *, BLASLONG, double  *, BLASLONG, double *);\n  int    (*dsymv_U) (BLASLONG, BLASLONG, double,  double  *, BLASLONG, double  *, BLASLONG, double  *, BLASLONG, double *);\n#endif\n#if (BUILD_DOUBLE==1) || (BUILD_COMPLEX16==1)\n  int    (*dgemm_kernel   )(BLASLONG, BLASLONG, BLASLONG, double, double *, double *, double *, BLASLONG);\n  int    (*dgemm_beta     )(BLASLONG, BLASLONG, BLASLONG, double, double *, BLASLONG, double *, BLASLONG, double  *, BLASLONG);\n\n  int    (*dgemm_incopy   )(BLASLONG, BLASLONG, double *, BLASLONG, double *);\n  int    (*dgemm_itcopy   )(BLASLONG, BLASLONG, double *, BLASLONG, double *);\n  int    (*dgemm_oncopy   )(BLASLONG, BLASLONG, double *, BLASLONG, double *);\n  int    (*dgemm_otcopy   )(BLASLONG, BLASLONG, double *, BLASLONG, double *);\n#endif\n#if (BUILD_DOUBLE==1) || (BUILD_COMPLEX16==1)\n#ifdef SMALL_MATRIX_OPT\n  int    (*dgemm_small_matrix_permit)(int transa, int transb, BLASLONG m, BLASLONG n, BLASLONG k, double alpha, double beta);\n\n  int    (*dgemm_small_kernel_nn    )(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha, double * B, BLASLONG ldb, double beta, double * C, BLASLONG ldc);\n  int    (*dgemm_small_kernel_nt    )(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha, double * B, BLASLONG ldb, double beta, double * C, BLASLONG ldc);\n  int    (*dgemm_small_kernel_tn    )(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha, double * B, BLASLONG ldb, double beta, double * C, BLASLONG ldc);\n  int    (*dgemm_small_kernel_tt    )(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha, double * B, BLASLONG ldb, double beta, double * C, BLASLONG ldc);\n\n  int    (*dgemm_small_kernel_b0_nn )(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha, double * B, BLASLONG ldb, double * C, BLASLONG ldc);\n  int    (*dgemm_small_kernel_b0_nt )(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha, double * B, BLASLONG ldb, double * C, BLASLONG ldc);\n  int    (*dgemm_small_kernel_b0_tn )(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha, double * B, BLASLONG ldb, double * C, BLASLONG ldc);\n  int    (*dgemm_small_kernel_b0_tt )(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha, double * B, BLASLONG ldb, double * C, BLASLONG ldc);\n#endif\n#endif\n#if (BUILD_DOUBLE==1)\n  int    (*dtrsm_kernel_LN)(BLASLONG, BLASLONG, BLASLONG, double, double *, double *, double *, BLASLONG, BLASLONG);\n  int    (*dtrsm_kernel_LT)(BLASLONG, BLASLONG, BLASLONG, double, double *, double *, double *, BLASLONG, BLASLONG);\n  int    (*dtrsm_kernel_RN)(BLASLONG, BLASLONG, BLASLONG, double, double *, double *, double *, BLASLONG, BLASLONG);\n  int    (*dtrsm_kernel_RT)(BLASLONG, BLASLONG, BLASLONG, double, double *, double *, double *, BLASLONG, BLASLONG);\n\n  int    (*dtrsm_iunucopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, double *);\n  int    (*dtrsm_iunncopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, double *);\n  int    (*dtrsm_iutucopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, double *);\n  int    (*dtrsm_iutncopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, double *);\n  int    (*dtrsm_ilnucopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, double *);\n  int    (*dtrsm_ilnncopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, double *);\n  int    (*dtrsm_iltucopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, double *);\n  int    (*dtrsm_iltncopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, double *);\n  int    (*dtrsm_ounucopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, double *);\n  int    (*dtrsm_ounncopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, double *);\n  int    (*dtrsm_outucopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, double *);\n  int    (*dtrsm_outncopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, double *);\n  int    (*dtrsm_olnucopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, double *);\n  int    (*dtrsm_olnncopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, double *);\n  int    (*dtrsm_oltucopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, double *);\n  int    (*dtrsm_oltncopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, double *);\n\n  int    (*dtrmm_kernel_RN)(BLASLONG, BLASLONG, BLASLONG, double, double *, double *, double *, BLASLONG, BLASLONG);\n  int    (*dtrmm_kernel_RT)(BLASLONG, BLASLONG, BLASLONG, double, double *, double *, double *, BLASLONG, BLASLONG);\n  int    (*dtrmm_kernel_LN)(BLASLONG, BLASLONG, BLASLONG, double, double *, double *, double *, BLASLONG, BLASLONG);\n  int    (*dtrmm_kernel_LT)(BLASLONG, BLASLONG, BLASLONG, double, double *, double *, double *, BLASLONG, BLASLONG);\n\n  int    (*dtrmm_iunucopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double *);\n  int    (*dtrmm_iunncopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double *);\n  int    (*dtrmm_iutucopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double *);\n  int    (*dtrmm_iutncopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double *);\n  int    (*dtrmm_ilnucopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double *);\n  int    (*dtrmm_ilnncopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double *);\n  int    (*dtrmm_iltucopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double *);\n  int    (*dtrmm_iltncopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double *);\n  int    (*dtrmm_ounucopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double *);\n  int    (*dtrmm_ounncopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double *);\n  int    (*dtrmm_outucopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double *);\n  int    (*dtrmm_outncopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double *);\n  int    (*dtrmm_olnucopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double *);\n  int    (*dtrmm_olnncopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double *);\n  int    (*dtrmm_oltucopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double *);\n  int    (*dtrmm_oltncopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double *);\n\n  int    (*dsymm_iutcopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double *);\n  int    (*dsymm_iltcopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double *);\n  int    (*dsymm_outcopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double *);\n  int    (*dsymm_oltcopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double *);\n\n  int\t (*dneg_tcopy)   (BLASLONG, BLASLONG, double *, BLASLONG, double *);\n  int    (*dlaswp_ncopy) (BLASLONG, BLASLONG, BLASLONG, double *, BLASLONG, blasint *, double *);\n#endif\n#ifdef EXPRECISION\n\n  int qgemm_p, qgemm_q, qgemm_r;\n  int qgemm_unroll_m, qgemm_unroll_n, qgemm_unroll_mn;\n\n xdouble (*qamax_k) (BLASLONG, xdouble *, BLASLONG);\n xdouble (*qamin_k) (BLASLONG, xdouble *, BLASLONG);\n xdouble (*qmax_k)  (BLASLONG, xdouble *, BLASLONG);\n xdouble (*qmin_k)  (BLASLONG, xdouble *, BLASLONG);\nBLASLONG (*iqamax_k)(BLASLONG, xdouble *, BLASLONG);\nBLASLONG (*iqamin_k)(BLASLONG, xdouble *, BLASLONG);\nBLASLONG (*iqmax_k) (BLASLONG, xdouble *, BLASLONG);\nBLASLONG (*iqmin_k) (BLASLONG, xdouble *, BLASLONG);\n\n xdouble (*qnrm2_k) (BLASLONG, xdouble *, BLASLONG);\n xdouble (*qasum_k) (BLASLONG, xdouble *, BLASLONG);\n xdouble (*qsum_k)  (BLASLONG, xdouble *, BLASLONG);\n  int    (*qcopy_k) (BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG);\n xdouble (*qdot_k)  (BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG);\n  int    (*qrot_k)  (BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble, xdouble);\n\n  int    (*qaxpy_k) (BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG);\n  int    (*qscal_k) (BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG);\n  int    (*qswap_k) (BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG);\n\n  int    (*qgemv_n) (BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\n  int    (*qgemv_t) (BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\n  int    (*qger_k)  (BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\n\n  int    (*qsymv_L) (BLASLONG, BLASLONG, xdouble,  xdouble  *, BLASLONG, xdouble  *, BLASLONG, xdouble  *, BLASLONG, xdouble *);\n  int    (*qsymv_U) (BLASLONG, BLASLONG, xdouble,  xdouble  *, BLASLONG, xdouble  *, BLASLONG, xdouble  *, BLASLONG, xdouble *);\n\n  int    (*qgemm_kernel   )(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG);\n  int    (*qgemm_beta     )(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble  *, BLASLONG);\n\n  int    (*qgemm_incopy   )(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *);\n  int    (*qgemm_itcopy   )(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *);\n  int    (*qgemm_oncopy   )(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *);\n  int    (*qgemm_otcopy   )(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *);\n\n  int    (*qtrsm_kernel_LN)(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG, BLASLONG);\n  int    (*qtrsm_kernel_LT)(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG, BLASLONG);\n  int    (*qtrsm_kernel_RN)(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG, BLASLONG);\n  int    (*qtrsm_kernel_RT)(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG, BLASLONG);\n\n  int    (*qtrsm_iunucopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, xdouble *);\n  int    (*qtrsm_iunncopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, xdouble *);\n  int    (*qtrsm_iutucopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, xdouble *);\n  int    (*qtrsm_iutncopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, xdouble *);\n  int    (*qtrsm_ilnucopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, xdouble *);\n  int    (*qtrsm_ilnncopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, xdouble *);\n  int    (*qtrsm_iltucopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, xdouble *);\n  int    (*qtrsm_iltncopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, xdouble *);\n  int    (*qtrsm_ounucopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, xdouble *);\n  int    (*qtrsm_ounncopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, xdouble *);\n  int    (*qtrsm_outucopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, xdouble *);\n  int    (*qtrsm_outncopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, xdouble *);\n  int    (*qtrsm_olnucopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, xdouble *);\n  int    (*qtrsm_olnncopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, xdouble *);\n  int    (*qtrsm_oltucopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, xdouble *);\n  int    (*qtrsm_oltncopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, xdouble *);\n\n  int    (*qtrmm_kernel_RN)(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG, BLASLONG);\n  int    (*qtrmm_kernel_RT)(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG, BLASLONG);\n  int    (*qtrmm_kernel_LN)(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG, BLASLONG);\n  int    (*qtrmm_kernel_LT)(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG, BLASLONG);\n\n  int    (*qtrmm_iunucopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble *);\n  int    (*qtrmm_iunncopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble *);\n  int    (*qtrmm_iutucopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble *);\n  int    (*qtrmm_iutncopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble *);\n  int    (*qtrmm_ilnucopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble *);\n  int    (*qtrmm_ilnncopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble *);\n  int    (*qtrmm_iltucopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble *);\n  int    (*qtrmm_iltncopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble *);\n  int    (*qtrmm_ounucopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble *);\n  int    (*qtrmm_ounncopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble *);\n  int    (*qtrmm_outucopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble *);\n  int    (*qtrmm_outncopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble *);\n  int    (*qtrmm_olnucopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble *);\n  int    (*qtrmm_olnncopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble *);\n  int    (*qtrmm_oltucopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble *);\n  int    (*qtrmm_oltncopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble *);\n\n  int    (*qsymm_iutcopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble *);\n  int    (*qsymm_iltcopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble *);\n  int    (*qsymm_outcopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble *);\n  int    (*qsymm_oltcopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble *);\n\n  int\t (*qneg_tcopy)   (BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *);\n  int    (*qlaswp_ncopy) (BLASLONG, BLASLONG, BLASLONG, xdouble *, BLASLONG, blasint *, xdouble *);\n\n#endif\n\n#if (BUILD_COMPLEX==1) \n  int cgemm_p, cgemm_q, cgemm_r;\n  int cgemm_unroll_m, cgemm_unroll_n, cgemm_unroll_mn;\n\t\n  float (*camax_k) (BLASLONG, float *, BLASLONG);\n  float (*camin_k) (BLASLONG, float *, BLASLONG);\n \nBLASLONG (*icamax_k)(BLASLONG, float *, BLASLONG);\t\nBLASLONG (*icamin_k)(BLASLONG, float *, BLASLONG);\n\n  float (*cnrm2_k) (BLASLONG, float *, BLASLONG);\n  float (*casum_k) (BLASLONG, float *, BLASLONG);\n  float (*csum_k)  (BLASLONG, float *, BLASLONG);\n\n  int    (*ccopy_k) (BLASLONG, float *, BLASLONG, float *, BLASLONG);\n  openblas_complex_float (*cdotu_k) (BLASLONG, float *, BLASLONG, float *, BLASLONG);\n  openblas_complex_float (*cdotc_k) (BLASLONG, float *, BLASLONG, float *, BLASLONG);\n\n  int    (*csrot_k) (BLASLONG, float *, BLASLONG, float *, BLASLONG, float, float);\n  int    (*caxpy_k) (BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG);\n  int    (*caxpyc_k)(BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG);\n  int    (*cscal_k) (BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG);\n  int    (*cswap_k) (BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG);\n\n  int    (*cgemv_n) (BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\n  int    (*cgemv_t) (BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\n  int    (*cgemv_r) (BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\n  int    (*cgemv_c) (BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\n  int    (*cgemv_o) (BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\n  int    (*cgemv_u) (BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\n  int    (*cgemv_s) (BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\n  int    (*cgemv_d) (BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\n  int    (*cgeru_k) (BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\n  int    (*cgerc_k) (BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\n  int    (*cgerv_k) (BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\n  int    (*cgerd_k) (BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG, float *, BLASLONG, float *, BLASLONG, float *);\n\n  int    (*csymv_L) (BLASLONG, BLASLONG, float,  float, float  *, BLASLONG, float  *, BLASLONG, float  *, BLASLONG, float *);\n  int    (*csymv_U) (BLASLONG, BLASLONG, float,  float, float  *, BLASLONG, float  *, BLASLONG, float  *, BLASLONG, float *);\n  int    (*chemv_L) (BLASLONG, BLASLONG, float,  float, float  *, BLASLONG, float  *, BLASLONG, float  *, BLASLONG, float *);\n  int    (*chemv_U) (BLASLONG, BLASLONG, float,  float, float  *, BLASLONG, float  *, BLASLONG, float  *, BLASLONG, float *);\n  int    (*chemv_M) (BLASLONG, BLASLONG, float,  float, float  *, BLASLONG, float  *, BLASLONG, float  *, BLASLONG, float *);\n  int    (*chemv_V) (BLASLONG, BLASLONG, float,  float, float  *, BLASLONG, float  *, BLASLONG, float  *, BLASLONG, float *);\n\n  int    (*cgemm_kernel_n )(BLASLONG, BLASLONG, BLASLONG, float, float, float *, float *, float *, BLASLONG);\n  int    (*cgemm_kernel_l )(BLASLONG, BLASLONG, BLASLONG, float, float, float *, float *, float *, BLASLONG);\n  int    (*cgemm_kernel_r )(BLASLONG, BLASLONG, BLASLONG, float, float, float *, float *, float *, BLASLONG);\n  int    (*cgemm_kernel_b )(BLASLONG, BLASLONG, BLASLONG, float, float, float *, float *, float *, BLASLONG);\n  int    (*cgemm_beta     )(BLASLONG, BLASLONG, BLASLONG, float, float, float *, BLASLONG, float *, BLASLONG, float  *, BLASLONG);\n\n  int    (*cgemm_incopy   )(BLASLONG, BLASLONG, float *, BLASLONG, float *);\n  int    (*cgemm_itcopy   )(BLASLONG, BLASLONG, float *, BLASLONG, float *);\n  int    (*cgemm_oncopy   )(BLASLONG, BLASLONG, float *, BLASLONG, float *);\n  int    (*cgemm_otcopy   )(BLASLONG, BLASLONG, float *, BLASLONG, float *);\n\n#ifdef SMALL_MATRIX_OPT\n  int    (*cgemm_small_matrix_permit)(int transa, int transb, BLASLONG m, BLASLONG n, BLASLONG k, float alpha0, float alpha1, float beta0, float beta1);\n\n  int    (*cgemm_small_kernel_nn    )(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb, float beta0, float beta1, float * C, BLASLONG ldc);\n  int    (*cgemm_small_kernel_nt    )(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb, float beta0, float beta1, float * C, BLASLONG ldc);\n  int    (*cgemm_small_kernel_nr    )(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb, float beta0, float beta1, float * C, BLASLONG ldc);\n  int    (*cgemm_small_kernel_nc    )(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb, float beta0, float beta1, float * C, BLASLONG ldc);\n\n  int    (*cgemm_small_kernel_tn    )(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb, float beta0, float beta1, float * C, BLASLONG ldc);\n  int    (*cgemm_small_kernel_tt    )(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb, float beta0, float beta1, float * C, BLASLONG ldc);\n  int    (*cgemm_small_kernel_tr    )(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb, float beta0, float beta1, float * C, BLASLONG ldc);\n  int    (*cgemm_small_kernel_tc    )(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb, float beta0, float beta1, float * C, BLASLONG ldc);\n\n  int    (*cgemm_small_kernel_rn    )(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb, float beta0, float beta1, float * C, BLASLONG ldc);\n  int    (*cgemm_small_kernel_rt    )(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb, float beta0, float beta1, float * C, BLASLONG ldc);\n  int    (*cgemm_small_kernel_rr    )(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb, float beta0, float beta1, float * C, BLASLONG ldc);\n  int    (*cgemm_small_kernel_rc    )(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb, float beta0, float beta1, float * C, BLASLONG ldc);\n\n  int    (*cgemm_small_kernel_cn    )(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb, float beta0, float beta1, float * C, BLASLONG ldc);\n  int    (*cgemm_small_kernel_ct    )(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb, float beta0, float beta1, float * C, BLASLONG ldc);\n  int    (*cgemm_small_kernel_cr    )(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb, float beta0, float beta1, float * C, BLASLONG ldc);\n  int    (*cgemm_small_kernel_cc    )(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb, float beta0, float beta1, float * C, BLASLONG ldc);\n\n  int    (*cgemm_small_kernel_b0_nn )(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb,  float * C, BLASLONG ldc);\n  int    (*cgemm_small_kernel_b0_nt )(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb,  float * C, BLASLONG ldc);\n  int    (*cgemm_small_kernel_b0_nr )(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb,  float * C, BLASLONG ldc);\n  int    (*cgemm_small_kernel_b0_nc )(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb,  float * C, BLASLONG ldc);\n\n  int    (*cgemm_small_kernel_b0_tn )(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb,  float * C, BLASLONG ldc);\n  int    (*cgemm_small_kernel_b0_tt )(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb,  float * C, BLASLONG ldc);\n  int    (*cgemm_small_kernel_b0_tr )(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb,  float * C, BLASLONG ldc);\n  int    (*cgemm_small_kernel_b0_tc )(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb,  float * C, BLASLONG ldc);\n\n  int    (*cgemm_small_kernel_b0_rn )(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb,  float * C, BLASLONG ldc);\n  int    (*cgemm_small_kernel_b0_rt )(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb,  float * C, BLASLONG ldc);\n  int    (*cgemm_small_kernel_b0_rr )(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb,  float * C, BLASLONG ldc);\n  int    (*cgemm_small_kernel_b0_rc )(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb,  float * C, BLASLONG ldc);\n\n  int    (*cgemm_small_kernel_b0_cn )(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb,  float * C, BLASLONG ldc);\n  int    (*cgemm_small_kernel_b0_ct )(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb,  float * C, BLASLONG ldc);\n  int    (*cgemm_small_kernel_b0_cr )(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb,  float * C, BLASLONG ldc);\n  int    (*cgemm_small_kernel_b0_cc )(BLASLONG m, BLASLONG n, BLASLONG k, float * A, BLASLONG lda, float alpha0, float alpha1, float * B, BLASLONG ldb,  float * C, BLASLONG ldc);\n#endif\n\n  int    (*ctrsm_kernel_LN)(BLASLONG, BLASLONG, BLASLONG, float, float, float *, float *, float *, BLASLONG, BLASLONG);\n  int    (*ctrsm_kernel_LT)(BLASLONG, BLASLONG, BLASLONG, float, float, float *, float *, float *, BLASLONG, BLASLONG);\n  int    (*ctrsm_kernel_LR)(BLASLONG, BLASLONG, BLASLONG, float, float, float *, float *, float *, BLASLONG, BLASLONG);\n  int    (*ctrsm_kernel_LC)(BLASLONG, BLASLONG, BLASLONG, float, float, float *, float *, float *, BLASLONG, BLASLONG);\n  int    (*ctrsm_kernel_RN)(BLASLONG, BLASLONG, BLASLONG, float, float, float *, float *, float *, BLASLONG, BLASLONG);\n  int    (*ctrsm_kernel_RT)(BLASLONG, BLASLONG, BLASLONG, float, float, float *, float *, float *, BLASLONG, BLASLONG);\n  int    (*ctrsm_kernel_RR)(BLASLONG, BLASLONG, BLASLONG, float, float, float *, float *, float *, BLASLONG, BLASLONG);\n  int    (*ctrsm_kernel_RC)(BLASLONG, BLASLONG, BLASLONG, float, float, float *, float *, float *, BLASLONG, BLASLONG);\n\n  int    (*ctrsm_iunucopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, float *);\n  int    (*ctrsm_iunncopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, float *);\n  int    (*ctrsm_iutucopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, float *);\n  int    (*ctrsm_iutncopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, float *);\n  int    (*ctrsm_ilnucopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, float *);\n  int    (*ctrsm_ilnncopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, float *);\n  int    (*ctrsm_iltucopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, float *);\n  int    (*ctrsm_iltncopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, float *);\n  int    (*ctrsm_ounucopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, float *);\n  int    (*ctrsm_ounncopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, float *);\n  int    (*ctrsm_outucopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, float *);\n  int    (*ctrsm_outncopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, float *);\n  int    (*ctrsm_olnucopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, float *);\n  int    (*ctrsm_olnncopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, float *);\n  int    (*ctrsm_oltucopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, float *);\n  int    (*ctrsm_oltncopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, float *);\n\n  int    (*ctrmm_kernel_RN)(BLASLONG, BLASLONG, BLASLONG, float, float, float *, float *, float *, BLASLONG, BLASLONG);\n  int    (*ctrmm_kernel_RT)(BLASLONG, BLASLONG, BLASLONG, float, float, float *, float *, float *, BLASLONG, BLASLONG);\n  int    (*ctrmm_kernel_RR)(BLASLONG, BLASLONG, BLASLONG, float, float, float *, float *, float *, BLASLONG, BLASLONG);\n  int    (*ctrmm_kernel_RC)(BLASLONG, BLASLONG, BLASLONG, float, float, float *, float *, float *, BLASLONG, BLASLONG);\n  int    (*ctrmm_kernel_LN)(BLASLONG, BLASLONG, BLASLONG, float, float, float *, float *, float *, BLASLONG, BLASLONG);\n  int    (*ctrmm_kernel_LT)(BLASLONG, BLASLONG, BLASLONG, float, float, float *, float *, float *, BLASLONG, BLASLONG);\n  int    (*ctrmm_kernel_LR)(BLASLONG, BLASLONG, BLASLONG, float, float, float *, float *, float *, BLASLONG, BLASLONG);\n  int    (*ctrmm_kernel_LC)(BLASLONG, BLASLONG, BLASLONG, float, float, float *, float *, float *, BLASLONG, BLASLONG);\n\n  int    (*ctrmm_iunucopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*ctrmm_iunncopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*ctrmm_iutucopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*ctrmm_iutncopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*ctrmm_ilnucopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*ctrmm_ilnncopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*ctrmm_iltucopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*ctrmm_iltncopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*ctrmm_ounucopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*ctrmm_ounncopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*ctrmm_outucopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*ctrmm_outncopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*ctrmm_olnucopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*ctrmm_olnncopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*ctrmm_oltucopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*ctrmm_oltncopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n\n  int    (*csymm_iutcopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*csymm_iltcopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*csymm_outcopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*csymm_oltcopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n\n  int    (*chemm_iutcopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*chemm_iltcopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*chemm_outcopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*chemm_oltcopy)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n\n  int cgemm3m_p, cgemm3m_q, cgemm3m_r;\n  int cgemm3m_unroll_m, cgemm3m_unroll_n, cgemm3m_unroll_mn;\n\n  int    (*cgemm3m_kernel)(BLASLONG, BLASLONG, BLASLONG, float, float, float *, float *, float *, BLASLONG);\n\n  int    (*cgemm3m_incopyb)(BLASLONG, BLASLONG, float *, BLASLONG, float *);\n  int    (*cgemm3m_incopyr)(BLASLONG, BLASLONG, float *, BLASLONG, float *);\n  int    (*cgemm3m_incopyi)(BLASLONG, BLASLONG, float *, BLASLONG, float *);\n  int    (*cgemm3m_itcopyb)(BLASLONG, BLASLONG, float *, BLASLONG, float *);\n  int    (*cgemm3m_itcopyr)(BLASLONG, BLASLONG, float *, BLASLONG, float *);\n  int    (*cgemm3m_itcopyi)(BLASLONG, BLASLONG, float *, BLASLONG, float *);\n\n  int    (*cgemm3m_oncopyb)(BLASLONG, BLASLONG, float *, BLASLONG, float, float, float *);\n  int    (*cgemm3m_oncopyr)(BLASLONG, BLASLONG, float *, BLASLONG, float, float, float *);\n  int    (*cgemm3m_oncopyi)(BLASLONG, BLASLONG, float *, BLASLONG, float, float, float *);\n  int    (*cgemm3m_otcopyb)(BLASLONG, BLASLONG, float *, BLASLONG, float, float, float *);\n  int    (*cgemm3m_otcopyr)(BLASLONG, BLASLONG, float *, BLASLONG, float, float, float *);\n  int    (*cgemm3m_otcopyi)(BLASLONG, BLASLONG, float *, BLASLONG, float, float, float *);\n\n  int    (*csymm3m_iucopyb)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*csymm3m_ilcopyb)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*csymm3m_iucopyr)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*csymm3m_ilcopyr)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*csymm3m_iucopyi)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*csymm3m_ilcopyi)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n\n  int    (*csymm3m_oucopyb)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float, float, float *);\n  int    (*csymm3m_olcopyb)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float, float, float *);\n  int    (*csymm3m_oucopyr)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float, float, float *);\n  int    (*csymm3m_olcopyr)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float, float, float *);\n  int    (*csymm3m_oucopyi)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float, float, float *);\n  int    (*csymm3m_olcopyi)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float, float, float *);\n\n  int    (*chemm3m_iucopyb)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*chemm3m_ilcopyb)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*chemm3m_iucopyr)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*chemm3m_ilcopyr)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*chemm3m_iucopyi)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n  int    (*chemm3m_ilcopyi)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float *);\n\n  int    (*chemm3m_oucopyb)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float, float, float *);\n  int    (*chemm3m_olcopyb)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float, float, float *);\n  int    (*chemm3m_oucopyr)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float, float, float *);\n  int    (*chemm3m_olcopyr)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float, float, float *);\n  int    (*chemm3m_oucopyi)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float, float, float *);\n  int    (*chemm3m_olcopyi)(BLASLONG, BLASLONG, float *, BLASLONG, BLASLONG, BLASLONG, float, float, float *);\n\n  int\t (*cneg_tcopy)   (BLASLONG, BLASLONG, float *, BLASLONG, float *);\n  int    (*claswp_ncopy) (BLASLONG, BLASLONG, BLASLONG, float *, BLASLONG, blasint *, float *);\n#endif\n\n#if (BUILD_COMPLEX16 == 1)\n  int zgemm_p, zgemm_q, zgemm_r;\n  int zgemm_unroll_m, zgemm_unroll_n, zgemm_unroll_mn;\n\n  double (*zamax_k) (BLASLONG, double *, BLASLONG);\n  double (*zamin_k) (BLASLONG, double *, BLASLONG);\nBLASLONG (*izamax_k)(BLASLONG, double *, BLASLONG);\nBLASLONG (*izamin_k)(BLASLONG, double *, BLASLONG);\n\n  double (*znrm2_k) (BLASLONG, double *, BLASLONG);\n  double (*zasum_k) (BLASLONG, double *, BLASLONG);\n  double (*zsum_k)  (BLASLONG, double *, BLASLONG);\n  int    (*zcopy_k) (BLASLONG, double *, BLASLONG, double *, BLASLONG);\n  openblas_complex_double (*zdotu_k) (BLASLONG, double *, BLASLONG, double *, BLASLONG);\n  openblas_complex_double (*zdotc_k) (BLASLONG, double *, BLASLONG, double *, BLASLONG);\n  int    (*zdrot_k) (BLASLONG, double *, BLASLONG, double *, BLASLONG, double, double);\n\n  int    (*zaxpy_k) (BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG);\n  int    (*zaxpyc_k)(BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG);\n  int    (*zscal_k) (BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG);\n  int    (*zswap_k) (BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG);\n\n  int    (*zgemv_n) (BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\n  int    (*zgemv_t) (BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\n  int    (*zgemv_r) (BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\n  int    (*zgemv_c) (BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\n  int    (*zgemv_o) (BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\n  int    (*zgemv_u) (BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\n  int    (*zgemv_s) (BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\n  int    (*zgemv_d) (BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\n  int    (*zgeru_k) (BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\n  int    (*zgerc_k) (BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\n  int    (*zgerv_k) (BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\n  int    (*zgerd_k) (BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG, double *, BLASLONG, double *, BLASLONG, double *);\n\n  int    (*zsymv_L) (BLASLONG, BLASLONG, double,  double, double  *, BLASLONG, double  *, BLASLONG, double  *, BLASLONG, double *);\n  int    (*zsymv_U) (BLASLONG, BLASLONG, double,  double, double  *, BLASLONG, double  *, BLASLONG, double  *, BLASLONG, double *);\n  int    (*zhemv_L) (BLASLONG, BLASLONG, double,  double, double  *, BLASLONG, double  *, BLASLONG, double  *, BLASLONG, double *);\n  int    (*zhemv_U) (BLASLONG, BLASLONG, double,  double, double  *, BLASLONG, double  *, BLASLONG, double  *, BLASLONG, double *);\n  int    (*zhemv_M) (BLASLONG, BLASLONG, double,  double, double  *, BLASLONG, double  *, BLASLONG, double  *, BLASLONG, double *);\n  int    (*zhemv_V) (BLASLONG, BLASLONG, double,  double, double  *, BLASLONG, double  *, BLASLONG, double  *, BLASLONG, double *);\n\n  int    (*zgemm_kernel_n )(BLASLONG, BLASLONG, BLASLONG, double, double, double *, double *, double *, BLASLONG);\n  int    (*zgemm_kernel_l )(BLASLONG, BLASLONG, BLASLONG, double, double, double *, double *, double *, BLASLONG);\n  int    (*zgemm_kernel_r )(BLASLONG, BLASLONG, BLASLONG, double, double, double *, double *, double *, BLASLONG);\n  int    (*zgemm_kernel_b )(BLASLONG, BLASLONG, BLASLONG, double, double, double *, double *, double *, BLASLONG);\n  int    (*zgemm_beta     )(BLASLONG, BLASLONG, BLASLONG, double, double, double *, BLASLONG, double *, BLASLONG, double  *, BLASLONG);\n\n  int    (*zgemm_incopy   )(BLASLONG, BLASLONG, double *, BLASLONG, double *);\n  int    (*zgemm_itcopy   )(BLASLONG, BLASLONG, double *, BLASLONG, double *);\n  int    (*zgemm_oncopy   )(BLASLONG, BLASLONG, double *, BLASLONG, double *);\n  int    (*zgemm_otcopy   )(BLASLONG, BLASLONG, double *, BLASLONG, double *);\n\n#ifdef SMALL_MATRIX_OPT\n  int    (*zgemm_small_matrix_permit)(int transa, int transb, BLASLONG m, BLASLONG n, BLASLONG k, double alpha0, double alpha1, double beta0, double beta1);\n\n  int    (*zgemm_small_kernel_nn    )(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb, double beta0, double beta1, double * C, BLASLONG ldc);\n  int    (*zgemm_small_kernel_nt    )(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb, double beta0, double beta1, double * C, BLASLONG ldc);\n  int    (*zgemm_small_kernel_nr    )(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb, double beta0, double beta1, double * C, BLASLONG ldc);\n  int    (*zgemm_small_kernel_nc    )(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb, double beta0, double beta1, double * C, BLASLONG ldc);\n\n  int    (*zgemm_small_kernel_tn    )(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb, double beta0, double beta1, double * C, BLASLONG ldc);\n  int    (*zgemm_small_kernel_tt    )(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb, double beta0, double beta1, double * C, BLASLONG ldc);\n  int    (*zgemm_small_kernel_tr    )(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb, double beta0, double beta1, double * C, BLASLONG ldc);\n  int    (*zgemm_small_kernel_tc    )(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb, double beta0, double beta1, double * C, BLASLONG ldc);\n\n  int    (*zgemm_small_kernel_rn    )(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb, double beta0, double beta1, double * C, BLASLONG ldc);\n  int    (*zgemm_small_kernel_rt    )(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb, double beta0, double beta1, double * C, BLASLONG ldc);\n  int    (*zgemm_small_kernel_rr    )(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb, double beta0, double beta1, double * C, BLASLONG ldc);\n  int    (*zgemm_small_kernel_rc    )(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb, double beta0, double beta1, double * C, BLASLONG ldc);\n\n  int    (*zgemm_small_kernel_cn    )(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb, double beta0, double beta1, double * C, BLASLONG ldc);\n  int    (*zgemm_small_kernel_ct    )(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb, double beta0, double beta1, double * C, BLASLONG ldc);\n  int    (*zgemm_small_kernel_cr    )(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb, double beta0, double beta1, double * C, BLASLONG ldc);\n  int    (*zgemm_small_kernel_cc    )(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb, double beta0, double beta1, double * C, BLASLONG ldc);\n\n  int    (*zgemm_small_kernel_b0_nn )(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb,  double * C, BLASLONG ldc);\n  int    (*zgemm_small_kernel_b0_nt )(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb,  double * C, BLASLONG ldc);\n  int    (*zgemm_small_kernel_b0_nr )(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb,  double * C, BLASLONG ldc);\n  int    (*zgemm_small_kernel_b0_nc )(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb,  double * C, BLASLONG ldc);\n\n  int    (*zgemm_small_kernel_b0_tn )(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb,  double * C, BLASLONG ldc);\n  int    (*zgemm_small_kernel_b0_tt )(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb,  double * C, BLASLONG ldc);\n  int    (*zgemm_small_kernel_b0_tr )(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb,  double * C, BLASLONG ldc);\n  int    (*zgemm_small_kernel_b0_tc )(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb,  double * C, BLASLONG ldc);\n\n  int    (*zgemm_small_kernel_b0_rn )(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb,  double * C, BLASLONG ldc);\n  int    (*zgemm_small_kernel_b0_rt )(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb,  double * C, BLASLONG ldc);\n  int    (*zgemm_small_kernel_b0_rr )(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb,  double * C, BLASLONG ldc);\n  int    (*zgemm_small_kernel_b0_rc )(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb,  double * C, BLASLONG ldc);\n\n  int    (*zgemm_small_kernel_b0_cn )(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb,  double * C, BLASLONG ldc);\n  int    (*zgemm_small_kernel_b0_ct )(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb,  double * C, BLASLONG ldc);\n  int    (*zgemm_small_kernel_b0_cr )(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb,  double * C, BLASLONG ldc);\n  int    (*zgemm_small_kernel_b0_cc )(BLASLONG m, BLASLONG n, BLASLONG k, double * A, BLASLONG lda, double alpha0, double alpha1, double * B, BLASLONG ldb,  double * C, BLASLONG ldc);\n#endif\n\n  int    (*ztrsm_kernel_LN)(BLASLONG, BLASLONG, BLASLONG, double, double, double *, double *, double *, BLASLONG, BLASLONG);\n  int    (*ztrsm_kernel_LT)(BLASLONG, BLASLONG, BLASLONG, double, double, double *, double *, double *, BLASLONG, BLASLONG);\n  int    (*ztrsm_kernel_LR)(BLASLONG, BLASLONG, BLASLONG, double, double, double *, double *, double *, BLASLONG, BLASLONG);\n  int    (*ztrsm_kernel_LC)(BLASLONG, BLASLONG, BLASLONG, double, double, double *, double *, double *, BLASLONG, BLASLONG);\n  int    (*ztrsm_kernel_RN)(BLASLONG, BLASLONG, BLASLONG, double, double, double *, double *, double *, BLASLONG, BLASLONG);\n  int    (*ztrsm_kernel_RT)(BLASLONG, BLASLONG, BLASLONG, double, double, double *, double *, double *, BLASLONG, BLASLONG);\n  int    (*ztrsm_kernel_RR)(BLASLONG, BLASLONG, BLASLONG, double, double, double *, double *, double *, BLASLONG, BLASLONG);\n  int    (*ztrsm_kernel_RC)(BLASLONG, BLASLONG, BLASLONG, double, double, double *, double *, double *, BLASLONG, BLASLONG);\n\n  int    (*ztrsm_iunucopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, double *);\n  int    (*ztrsm_iunncopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, double *);\n  int    (*ztrsm_iutucopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, double *);\n  int    (*ztrsm_iutncopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, double *);\n  int    (*ztrsm_ilnucopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, double *);\n  int    (*ztrsm_ilnncopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, double *);\n  int    (*ztrsm_iltucopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, double *);\n  int    (*ztrsm_iltncopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, double *);\n  int    (*ztrsm_ounucopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, double *);\n  int    (*ztrsm_ounncopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, double *);\n  int    (*ztrsm_outucopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, double *);\n  int    (*ztrsm_outncopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, double *);\n  int    (*ztrsm_olnucopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, double *);\n  int    (*ztrsm_olnncopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, double *);\n  int    (*ztrsm_oltucopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, double *);\n  int    (*ztrsm_oltncopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, double *);\n\n  int    (*ztrmm_kernel_RN)(BLASLONG, BLASLONG, BLASLONG, double, double, double *, double *, double *, BLASLONG, BLASLONG);\n  int    (*ztrmm_kernel_RT)(BLASLONG, BLASLONG, BLASLONG, double, double, double *, double *, double *, BLASLONG, BLASLONG);\n  int    (*ztrmm_kernel_RR)(BLASLONG, BLASLONG, BLASLONG, double, double, double *, double *, double *, BLASLONG, BLASLONG);\n  int    (*ztrmm_kernel_RC)(BLASLONG, BLASLONG, BLASLONG, double, double, double *, double *, double *, BLASLONG, BLASLONG);\n  int    (*ztrmm_kernel_LN)(BLASLONG, BLASLONG, BLASLONG, double, double, double *, double *, double *, BLASLONG, BLASLONG);\n  int    (*ztrmm_kernel_LT)(BLASLONG, BLASLONG, BLASLONG, double, double, double *, double *, double *, BLASLONG, BLASLONG);\n  int    (*ztrmm_kernel_LR)(BLASLONG, BLASLONG, BLASLONG, double, double, double *, double *, double *, BLASLONG, BLASLONG);\n  int    (*ztrmm_kernel_LC)(BLASLONG, BLASLONG, BLASLONG, double, double, double *, double *, double *, BLASLONG, BLASLONG);\n\n  int    (*ztrmm_iunucopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double *);\n  int    (*ztrmm_iunncopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double *);\n  int    (*ztrmm_iutucopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double *);\n  int    (*ztrmm_iutncopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double *);\n  int    (*ztrmm_ilnucopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double *);\n  int    (*ztrmm_ilnncopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double *);\n  int    (*ztrmm_iltucopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double *);\n  int    (*ztrmm_iltncopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double *);\n  int    (*ztrmm_ounucopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double *);\n  int    (*ztrmm_ounncopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double *);\n  int    (*ztrmm_outucopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double *);\n  int    (*ztrmm_outncopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double *);\n  int    (*ztrmm_olnucopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double *);\n  int    (*ztrmm_olnncopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double *);\n  int    (*ztrmm_oltucopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double *);\n  int    (*ztrmm_oltncopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double *);\n\n  int    (*zsymm_iutcopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double *);\n  int    (*zsymm_iltcopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double *);\n  int    (*zsymm_outcopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double *);\n  int    (*zsymm_oltcopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double *);\n\n  int    (*zhemm_iutcopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double *);\n  int    (*zhemm_iltcopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double *);\n  int    (*zhemm_outcopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double *);\n  int    (*zhemm_oltcopy)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double *);\n\n  int zgemm3m_p, zgemm3m_q, zgemm3m_r;\n  int zgemm3m_unroll_m, zgemm3m_unroll_n, zgemm3m_unroll_mn;\n\n  int    (*zgemm3m_kernel)(BLASLONG, BLASLONG, BLASLONG, double, double, double *, double *, double *, BLASLONG);\n\n  int    (*zgemm3m_incopyb)(BLASLONG, BLASLONG, double *, BLASLONG, double *);\n  int    (*zgemm3m_incopyr)(BLASLONG, BLASLONG, double *, BLASLONG, double *);\n  int    (*zgemm3m_incopyi)(BLASLONG, BLASLONG, double *, BLASLONG, double *);\n  int    (*zgemm3m_itcopyb)(BLASLONG, BLASLONG, double *, BLASLONG, double *);\n  int    (*zgemm3m_itcopyr)(BLASLONG, BLASLONG, double *, BLASLONG, double *);\n  int    (*zgemm3m_itcopyi)(BLASLONG, BLASLONG, double *, BLASLONG, double *);\n\n  int    (*zgemm3m_oncopyb)(BLASLONG, BLASLONG, double *, BLASLONG, double, double, double *);\n  int    (*zgemm3m_oncopyr)(BLASLONG, BLASLONG, double *, BLASLONG, double, double, double *);\n  int    (*zgemm3m_oncopyi)(BLASLONG, BLASLONG, double *, BLASLONG, double, double, double *);\n  int    (*zgemm3m_otcopyb)(BLASLONG, BLASLONG, double *, BLASLONG, double, double, double *);\n  int    (*zgemm3m_otcopyr)(BLASLONG, BLASLONG, double *, BLASLONG, double, double, double *);\n  int    (*zgemm3m_otcopyi)(BLASLONG, BLASLONG, double *, BLASLONG, double, double, double *);\n\n  int    (*zsymm3m_iucopyb)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double *);\n  int    (*zsymm3m_ilcopyb)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double *);\n  int    (*zsymm3m_iucopyr)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double *);\n  int    (*zsymm3m_ilcopyr)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double *);\n  int    (*zsymm3m_iucopyi)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double *);\n  int    (*zsymm3m_ilcopyi)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double *);\n\n  int    (*zsymm3m_oucopyb)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double, double, double *);\n  int    (*zsymm3m_olcopyb)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double, double, double *);\n  int    (*zsymm3m_oucopyr)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double, double, double *);\n  int    (*zsymm3m_olcopyr)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double, double, double *);\n  int    (*zsymm3m_oucopyi)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double, double, double *);\n  int    (*zsymm3m_olcopyi)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double, double, double *);\n\n  int    (*zhemm3m_iucopyb)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double *);\n  int    (*zhemm3m_ilcopyb)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double *);\n  int    (*zhemm3m_iucopyr)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double *);\n  int    (*zhemm3m_ilcopyr)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double *);\n  int    (*zhemm3m_iucopyi)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double *);\n  int    (*zhemm3m_ilcopyi)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double *);\n\n  int    (*zhemm3m_oucopyb)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double, double, double *);\n  int    (*zhemm3m_olcopyb)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double, double, double *);\n  int    (*zhemm3m_oucopyr)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double, double, double *);\n  int    (*zhemm3m_olcopyr)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double, double, double *);\n  int    (*zhemm3m_oucopyi)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double, double, double *);\n  int    (*zhemm3m_olcopyi)(BLASLONG, BLASLONG, double *, BLASLONG, BLASLONG, BLASLONG, double, double, double *);\n\n  int\t (*zneg_tcopy)   (BLASLONG, BLASLONG, double *, BLASLONG, double *);\n  int    (*zlaswp_ncopy) (BLASLONG, BLASLONG, BLASLONG, double *, BLASLONG, blasint *, double *);\n#endif\n\n#ifdef EXPRECISION\n\n  int xgemm_p, xgemm_q, xgemm_r;\n  int xgemm_unroll_m, xgemm_unroll_n, xgemm_unroll_mn;\n\n  xdouble (*xamax_k) (BLASLONG, xdouble *, BLASLONG);\n  xdouble (*xamin_k) (BLASLONG, xdouble *, BLASLONG);\nBLASLONG (*ixamax_k)(BLASLONG, xdouble *, BLASLONG);\nBLASLONG (*ixamin_k)(BLASLONG, xdouble *, BLASLONG);\n\n  xdouble (*xnrm2_k) (BLASLONG, xdouble *, BLASLONG);\n  xdouble (*xasum_k) (BLASLONG, xdouble *, BLASLONG);\n  xdouble (*xsum_k) (BLASLONG, xdouble *, BLASLONG);\n  int    (*xcopy_k) (BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG);\n  openblas_complex_xdouble (*xdotu_k) (BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG);\n  openblas_complex_xdouble (*xdotc_k) (BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG);\n  int    (*xqrot_k) (BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble, xdouble);\n\n  int    (*xaxpy_k) (BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG);\n  int    (*xaxpyc_k)(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG);\n  int    (*xscal_k) (BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG);\n  int    (*xswap_k) (BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG);\n\n  int    (*xgemv_n) (BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\n  int    (*xgemv_t) (BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\n  int    (*xgemv_r) (BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\n  int    (*xgemv_c) (BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\n  int    (*xgemv_o) (BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\n  int    (*xgemv_u) (BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\n  int    (*xgemv_s) (BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\n  int    (*xgemv_d) (BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\n  int    (*xgeru_k) (BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\n  int    (*xgerc_k) (BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\n  int    (*xgerv_k) (BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\n  int    (*xgerd_k) (BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble *);\n\n  int    (*xsymv_L) (BLASLONG, BLASLONG, xdouble,  xdouble, xdouble  *, BLASLONG, xdouble  *, BLASLONG, xdouble  *, BLASLONG, xdouble *);\n  int    (*xsymv_U) (BLASLONG, BLASLONG, xdouble,  xdouble, xdouble  *, BLASLONG, xdouble  *, BLASLONG, xdouble  *, BLASLONG, xdouble *);\n  int    (*xhemv_L) (BLASLONG, BLASLONG, xdouble,  xdouble, xdouble  *, BLASLONG, xdouble  *, BLASLONG, xdouble  *, BLASLONG, xdouble *);\n  int    (*xhemv_U) (BLASLONG, BLASLONG, xdouble,  xdouble, xdouble  *, BLASLONG, xdouble  *, BLASLONG, xdouble  *, BLASLONG, xdouble *);\n  int    (*xhemv_M) (BLASLONG, BLASLONG, xdouble,  xdouble, xdouble  *, BLASLONG, xdouble  *, BLASLONG, xdouble  *, BLASLONG, xdouble *);\n  int    (*xhemv_V) (BLASLONG, BLASLONG, xdouble,  xdouble, xdouble  *, BLASLONG, xdouble  *, BLASLONG, xdouble  *, BLASLONG, xdouble *);\n\n  int    (*xgemm_kernel_n )(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG);\n  int    (*xgemm_kernel_l )(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG);\n  int    (*xgemm_kernel_r )(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG);\n  int    (*xgemm_kernel_b )(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG);\n  int    (*xgemm_beta     )(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, BLASLONG, xdouble *, BLASLONG, xdouble  *, BLASLONG);\n\n  int    (*xgemm_incopy   )(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *);\n  int    (*xgemm_itcopy   )(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *);\n  int    (*xgemm_oncopy   )(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *);\n  int    (*xgemm_otcopy   )(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *);\n\n  int    (*xtrsm_kernel_LN)(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG, BLASLONG);\n  int    (*xtrsm_kernel_LT)(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG, BLASLONG);\n  int    (*xtrsm_kernel_LR)(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG, BLASLONG);\n  int    (*xtrsm_kernel_LC)(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG, BLASLONG);\n  int    (*xtrsm_kernel_RN)(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG, BLASLONG);\n  int    (*xtrsm_kernel_RT)(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG, BLASLONG);\n  int    (*xtrsm_kernel_RR)(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG, BLASLONG);\n  int    (*xtrsm_kernel_RC)(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG, BLASLONG);\n\n  int    (*xtrsm_iunucopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, xdouble *);\n  int    (*xtrsm_iunncopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, xdouble *);\n  int    (*xtrsm_iutucopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, xdouble *);\n  int    (*xtrsm_iutncopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, xdouble *);\n  int    (*xtrsm_ilnucopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, xdouble *);\n  int    (*xtrsm_ilnncopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, xdouble *);\n  int    (*xtrsm_iltucopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, xdouble *);\n  int    (*xtrsm_iltncopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, xdouble *);\n  int    (*xtrsm_ounucopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, xdouble *);\n  int    (*xtrsm_ounncopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, xdouble *);\n  int    (*xtrsm_outucopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, xdouble *);\n  int    (*xtrsm_outncopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, xdouble *);\n  int    (*xtrsm_olnucopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, xdouble *);\n  int    (*xtrsm_olnncopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, xdouble *);\n  int    (*xtrsm_oltucopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, xdouble *);\n  int    (*xtrsm_oltncopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, xdouble *);\n\n  int    (*xtrmm_kernel_RN)(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG, BLASLONG);\n  int    (*xtrmm_kernel_RT)(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG, BLASLONG);\n  int    (*xtrmm_kernel_RR)(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG, BLASLONG);\n  int    (*xtrmm_kernel_RC)(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG, BLASLONG);\n  int    (*xtrmm_kernel_LN)(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG, BLASLONG);\n  int    (*xtrmm_kernel_LT)(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG, BLASLONG);\n  int    (*xtrmm_kernel_LR)(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG, BLASLONG);\n  int    (*xtrmm_kernel_LC)(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG, BLASLONG);\n\n  int    (*xtrmm_iunucopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble *);\n  int    (*xtrmm_iunncopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble *);\n  int    (*xtrmm_iutucopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble *);\n  int    (*xtrmm_iutncopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble *);\n  int    (*xtrmm_ilnucopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble *);\n  int    (*xtrmm_ilnncopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble *);\n  int    (*xtrmm_iltucopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble *);\n  int    (*xtrmm_iltncopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble *);\n  int    (*xtrmm_ounucopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble *);\n  int    (*xtrmm_ounncopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble *);\n  int    (*xtrmm_outucopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble *);\n  int    (*xtrmm_outncopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble *);\n  int    (*xtrmm_olnucopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble *);\n  int    (*xtrmm_olnncopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble *);\n  int    (*xtrmm_oltucopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble *);\n  int    (*xtrmm_oltncopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble *);\n\n  int    (*xsymm_iutcopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble *);\n  int    (*xsymm_iltcopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble *);\n  int    (*xsymm_outcopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble *);\n  int    (*xsymm_oltcopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble *);\n\n  int    (*xhemm_iutcopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble *);\n  int    (*xhemm_iltcopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble *);\n  int    (*xhemm_outcopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble *);\n  int    (*xhemm_oltcopy)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble *);\n\n  int xgemm3m_p, xgemm3m_q, xgemm3m_r;\n  int xgemm3m_unroll_m, xgemm3m_unroll_n, xgemm3m_unroll_mn;\n\n  int    (*xgemm3m_kernel)(BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *, xdouble *, xdouble *, BLASLONG);\n\n  int    (*xgemm3m_incopyb)(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *);\n  int    (*xgemm3m_incopyr)(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *);\n  int    (*xgemm3m_incopyi)(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *);\n  int    (*xgemm3m_itcopyb)(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *);\n  int    (*xgemm3m_itcopyr)(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *);\n  int    (*xgemm3m_itcopyi)(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *);\n\n  int    (*xgemm3m_oncopyb)(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble, xdouble, xdouble *);\n  int    (*xgemm3m_oncopyr)(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble, xdouble, xdouble *);\n  int    (*xgemm3m_oncopyi)(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble, xdouble, xdouble *);\n  int    (*xgemm3m_otcopyb)(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble, xdouble, xdouble *);\n  int    (*xgemm3m_otcopyr)(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble, xdouble, xdouble *);\n  int    (*xgemm3m_otcopyi)(BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble, xdouble, xdouble *);\n\n  int    (*xsymm3m_iucopyb)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble *);\n  int    (*xsymm3m_ilcopyb)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble *);\n  int    (*xsymm3m_iucopyr)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble *);\n  int    (*xsymm3m_ilcopyr)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble *);\n  int    (*xsymm3m_iucopyi)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble *);\n  int    (*xsymm3m_ilcopyi)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble *);\n\n  int    (*xsymm3m_oucopyb)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *);\n  int    (*xsymm3m_olcopyb)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *);\n  int    (*xsymm3m_oucopyr)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *);\n  int    (*xsymm3m_olcopyr)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *);\n  int    (*xsymm3m_oucopyi)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *);\n  int    (*xsymm3m_olcopyi)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *);\n\n  int    (*xhemm3m_iucopyb)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble *);\n  int    (*xhemm3m_ilcopyb)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble *);\n  int    (*xhemm3m_iucopyr)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble *);\n  int    (*xhemm3m_ilcopyr)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble *);\n  int    (*xhemm3m_iucopyi)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble *);\n  int    (*xhemm3m_ilcopyi)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble *);\n\n  int    (*xhemm3m_oucopyb)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *);\n  int    (*xhemm3m_olcopyb)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *);\n  int    (*xhemm3m_oucopyr)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *);\n  int    (*xhemm3m_olcopyr)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *);\n  int    (*xhemm3m_oucopyi)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *);\n  int    (*xhemm3m_olcopyi)(BLASLONG, BLASLONG, xdouble *, BLASLONG, BLASLONG, BLASLONG, xdouble, xdouble, xdouble *);\n\n  int\t (*xneg_tcopy)   (BLASLONG, BLASLONG, xdouble *, BLASLONG, xdouble *);\n  int    (*xlaswp_ncopy) (BLASLONG, BLASLONG, BLASLONG, xdouble *, BLASLONG, blasint *, xdouble *);\n\n#endif\n\n\n  void (*init)(void);\n\n  int snum_opt, dnum_opt, qnum_opt;\n#if (BUILD_SINGLE==1)\n  int    (*saxpby_k)     (BLASLONG, float, float*, BLASLONG,float, float*, BLASLONG);\n#endif\n#if (BUILD_DOUBLE==1)\n  int    (*daxpby_k)     (BLASLONG, double, double*, BLASLONG,double, double*, BLASLONG);\n#endif\n#if (BUILD_COMPLEX==1)\n  int    (*caxpby_k)     (BLASLONG, float, float,  float*, BLASLONG,float,float, float*, BLASLONG);\n#endif\n#if (BUILD_COMPLEX16==1)\n  int    (*zaxpby_k)     (BLASLONG, double, double,  double*, BLASLONG,double,double, double*, BLASLONG);\n#endif\n\n#if (BUILD_SINGLE==1)\n  int    (*somatcopy_k_cn)\t(BLASLONG, BLASLONG, float, float*, BLASLONG, float*, BLASLONG);\n  int    (*somatcopy_k_ct)\t(BLASLONG, BLASLONG, float, float*, BLASLONG, float*, BLASLONG);\n  int    (*somatcopy_k_rn)\t(BLASLONG, BLASLONG, float, float*, BLASLONG, float*, BLASLONG);\n  int    (*somatcopy_k_rt)\t(BLASLONG, BLASLONG, float, float*, BLASLONG, float*, BLASLONG);\n#endif\n\n#if (BUILD_DOUBLE==1) \n  int    (*domatcopy_k_cn)\t(BLASLONG, BLASLONG, double, double*, BLASLONG, double*, BLASLONG);\n  int    (*domatcopy_k_ct)\t(BLASLONG, BLASLONG, double, double*, BLASLONG, double*, BLASLONG);\n  int    (*domatcopy_k_rn)\t(BLASLONG, BLASLONG, double, double*, BLASLONG, double*, BLASLONG);\n  int    (*domatcopy_k_rt)\t(BLASLONG, BLASLONG, double, double*, BLASLONG, double*, BLASLONG);\n#endif\n\n#if (BUILD_COMPLEX==1)\n  int    (*comatcopy_k_cn)\t(BLASLONG, BLASLONG, float, float, float*, BLASLONG, float*, BLASLONG);\n  int    (*comatcopy_k_ct)\t(BLASLONG, BLASLONG, float, float, float*, BLASLONG, float*, BLASLONG);\n  int    (*comatcopy_k_rn)\t(BLASLONG, BLASLONG, float, float, float*, BLASLONG, float*, BLASLONG);\n  int    (*comatcopy_k_rt)\t(BLASLONG, BLASLONG, float, float, float*, BLASLONG, float*, BLASLONG);\n\n  int    (*comatcopy_k_cnc)\t(BLASLONG, BLASLONG, float, float, float*, BLASLONG, float*, BLASLONG);\n  int    (*comatcopy_k_ctc)\t(BLASLONG, BLASLONG, float, float, float*, BLASLONG, float*, BLASLONG);\n  int    (*comatcopy_k_rnc)\t(BLASLONG, BLASLONG, float, float, float*, BLASLONG, float*, BLASLONG);\n  int    (*comatcopy_k_rtc)\t(BLASLONG, BLASLONG, float, float, float*, BLASLONG, float*, BLASLONG);\n#endif\n\n#if (BUILD_COMPLEX16==1)\n  int    (*zomatcopy_k_cn)\t(BLASLONG, BLASLONG, double, double, double*, BLASLONG, double*, BLASLONG);\n  int    (*zomatcopy_k_ct)\t(BLASLONG, BLASLONG, double, double, double*, BLASLONG, double*, BLASLONG);\n  int    (*zomatcopy_k_rn)\t(BLASLONG, BLASLONG, double, double, double*, BLASLONG, double*, BLASLONG);\n  int    (*zomatcopy_k_rt)\t(BLASLONG, BLASLONG, double, double, double*, BLASLONG, double*, BLASLONG);\n\n  int    (*zomatcopy_k_cnc)\t(BLASLONG, BLASLONG, double, double, double*, BLASLONG, double*, BLASLONG);\n  int    (*zomatcopy_k_ctc)\t(BLASLONG, BLASLONG, double, double, double*, BLASLONG, double*, BLASLONG);\n  int    (*zomatcopy_k_rnc)\t(BLASLONG, BLASLONG, double, double, double*, BLASLONG, double*, BLASLONG);\n  int    (*zomatcopy_k_rtc)\t(BLASLONG, BLASLONG, double, double, double*, BLASLONG, double*, BLASLONG);\n#endif\n\n#if (BUILD_SINGLE==1)\n  int    (*simatcopy_k_cn)\t(BLASLONG, BLASLONG, float, float*, BLASLONG);\n  int    (*simatcopy_k_ct)\t(BLASLONG, BLASLONG, float, float*, BLASLONG);\n  int    (*simatcopy_k_rn)\t(BLASLONG, BLASLONG, float, float*, BLASLONG);\n  int    (*simatcopy_k_rt)\t(BLASLONG, BLASLONG, float, float*, BLASLONG);\n#endif\n\n#if (BUILD_DOUBLE==1)\n  int    (*dimatcopy_k_cn)\t(BLASLONG, BLASLONG, double, double*, BLASLONG);\n  int    (*dimatcopy_k_ct)\t(BLASLONG, BLASLONG, double, double*, BLASLONG);\n  int    (*dimatcopy_k_rn)\t(BLASLONG, BLASLONG, double, double*, BLASLONG);\n  int    (*dimatcopy_k_rt)\t(BLASLONG, BLASLONG, double, double*, BLASLONG);\n#endif\n\n#if (BUILD_COMPLEX==1)\n  int    (*cimatcopy_k_cn)\t(BLASLONG, BLASLONG, float, float, float*, BLASLONG);\n  int    (*cimatcopy_k_ct)\t(BLASLONG, BLASLONG, float, float, float*, BLASLONG);\n  int    (*cimatcopy_k_rn)\t(BLASLONG, BLASLONG, float, float, float*, BLASLONG);\n  int    (*cimatcopy_k_rt)\t(BLASLONG, BLASLONG, float, float, float*, BLASLONG);\n\n  int    (*cimatcopy_k_cnc)\t(BLASLONG, BLASLONG, float, float, float*, BLASLONG);\n  int    (*cimatcopy_k_ctc)\t(BLASLONG, BLASLONG, float, float, float*, BLASLONG);\n  int    (*cimatcopy_k_rnc)\t(BLASLONG, BLASLONG, float, float, float*, BLASLONG);\n  int    (*cimatcopy_k_rtc)\t(BLASLONG, BLASLONG, float, float, float*, BLASLONG);\n#endif\n\n#if (BUILD_COMPLEX16==1)\n  int    (*zimatcopy_k_cn)\t(BLASLONG, BLASLONG, double, double, double*, BLASLONG);\n  int    (*zimatcopy_k_ct)\t(BLASLONG, BLASLONG, double, double, double*, BLASLONG);\n  int    (*zimatcopy_k_rn)\t(BLASLONG, BLASLONG, double, double, double*, BLASLONG);\n  int    (*zimatcopy_k_rt)\t(BLASLONG, BLASLONG, double, double, double*, BLASLONG);\n\n  int    (*zimatcopy_k_cnc)\t(BLASLONG, BLASLONG, double, double, double*, BLASLONG);\n  int    (*zimatcopy_k_ctc)\t(BLASLONG, BLASLONG, double, double, double*, BLASLONG);\n  int    (*zimatcopy_k_rnc)\t(BLASLONG, BLASLONG, double, double, double*, BLASLONG);\n  int    (*zimatcopy_k_rtc)\t(BLASLONG, BLASLONG, double, double, double*, BLASLONG);\n#endif\n\n#if (BUILD_SINGLE==1)\n  int    (*sgeadd_k) (BLASLONG, BLASLONG, float, float *, BLASLONG, float, float *, BLASLONG); \n#endif\n#if (BUILD_DOUBLE==1)\n  int    (*dgeadd_k) (BLASLONG, BLASLONG, double, double *, BLASLONG, double, double *, BLASLONG); \n#endif\n#if (BUILD_COMPLEX==1)\n  int    (*cgeadd_k) (BLASLONG, BLASLONG, float, float,  float *,  BLASLONG, float, float, float *, BLASLONG); \n#endif\n#if (BUILD_COMPLEX16==1)\n  int    (*zgeadd_k) (BLASLONG, BLASLONG, double, double, double *, BLASLONG, double, double, double *, BLASLONG); \n#endif\n} gotoblas_t;\n\nextern gotoblas_t *gotoblas;\n\n#define FUNC_OFFSET(func)\t(size_t)(&((gotoblas_t *)NULL)->func)\n\n#define DTB_ENTRIES  gotoblas -> dtb_entries\n#define GEMM_OFFSET_A\tgotoblas -> offsetA\n#define GEMM_OFFSET_B\tgotoblas -> offsetB\n#define GEMM_ALIGN\tgotoblas -> align\n\n#define HAVE_EX_L2\tgotoblas -> exclusive_cache\n\n#if (BUILD_BFLOAT16==1)\n#define\tSBGEMM_P\t\tgotoblas -> sbgemm_p\n#define\tSBGEMM_Q\t\tgotoblas -> sbgemm_q\n#define\tSBGEMM_R\t\tgotoblas -> sbgemm_r\n#define\tSBGEMM_UNROLL_M\tgotoblas -> sbgemm_unroll_m\n#define\tSBGEMM_UNROLL_N\tgotoblas -> sbgemm_unroll_n\n#define\tSBGEMM_UNROLL_MN\tgotoblas -> sbgemm_unroll_mn\n#endif\n\n#if (BUILD_SINGLE==1)\n#define\tSGEMM_P\t\tgotoblas -> sgemm_p\n#define\tSGEMM_Q\t\tgotoblas -> sgemm_q\n#define\tSGEMM_R\t\tgotoblas -> sgemm_r\n#define\tSGEMM_UNROLL_M\tgotoblas -> sgemm_unroll_m\n#define\tSGEMM_UNROLL_N\tgotoblas -> sgemm_unroll_n\n#define SGEMM_UNROLL_MN\tgotoblas -> sgemm_unroll_mn\n#endif\n\n#if (BUILD_DOUBLE==1)\n#define\tDGEMM_P\t\tgotoblas -> dgemm_p\n#define\tDGEMM_Q\t\tgotoblas -> dgemm_q\n#define\tDGEMM_R\t\tgotoblas -> dgemm_r\n#define\tDGEMM_UNROLL_M\tgotoblas -> dgemm_unroll_m\n#define\tDGEMM_UNROLL_N\tgotoblas -> dgemm_unroll_n\n#define DGEMM_UNROLL_MN\tgotoblas -> dgemm_unroll_mn\n#if (BUILD_SINGLE != 1)\n#define\tSGEMM_P\t\tgotoblas -> sgemm_p\n#define\tSGEMM_Q\t\tgotoblas -> sgemm_q\n#define\tSGEMM_R\t\t1024\n#define\tSGEMM_UNROLL_M\tgotoblas -> sgemm_unroll_m\n#define\tSGEMM_UNROLL_N\tgotoblas -> sgemm_unroll_n\n#define SGEMM_UNROLL_MN\tgotoblas -> sgemm_unroll_mn\n#endif\n#endif\n\n#define\tQGEMM_P\t\tgotoblas -> qgemm_p\n#define\tQGEMM_Q\t\tgotoblas -> qgemm_q\n#define\tQGEMM_R\t\tgotoblas -> qgemm_r\n#define\tQGEMM_UNROLL_M\tgotoblas -> qgemm_unroll_m\n#define\tQGEMM_UNROLL_N\tgotoblas -> qgemm_unroll_n\n#define QGEMM_UNROLL_MN\tgotoblas -> qgemm_unroll_mn\n\n#if (BUILD_COMPLEX==1)\n#define\tCGEMM_P\t\tgotoblas -> cgemm_p\n#define\tCGEMM_Q\t\tgotoblas -> cgemm_q\n#define\tCGEMM_R\t\tgotoblas -> cgemm_r\n#define\tCGEMM_UNROLL_M\tgotoblas -> cgemm_unroll_m\n#define\tCGEMM_UNROLL_N\tgotoblas -> cgemm_unroll_n\n#define CGEMM_UNROLL_MN\tgotoblas -> cgemm_unroll_mn\n#if (BUILD_SINGLE != 1)\n#define\tSGEMM_P\t\tgotoblas -> sgemm_p\n#define\tSGEMM_Q\t\tgotoblas -> sgemm_q\n#define\tSGEMM_R\t\t1024\n#define\tSGEMM_UNROLL_M\tgotoblas -> sgemm_unroll_m\n#define\tSGEMM_UNROLL_N\tgotoblas -> sgemm_unroll_n\n#define SGEMM_UNROLL_MN\tgotoblas -> sgemm_unroll_mn\n#endif\n#endif\n\n#if (BUILD_COMPLEX16==1)\n#define\tZGEMM_P\t\tgotoblas -> zgemm_p\n#define\tZGEMM_Q\t\tgotoblas -> zgemm_q\n#define\tZGEMM_R\t\tgotoblas -> zgemm_r\n#define\tZGEMM_UNROLL_M\tgotoblas -> zgemm_unroll_m\n#define\tZGEMM_UNROLL_N\tgotoblas -> zgemm_unroll_n\n#define ZGEMM_UNROLL_MN\tgotoblas -> zgemm_unroll_mn\n#if (BUILD_DOUBLE != 1)\n#define\tDGEMM_P\t\tgotoblas -> dgemm_p\n#define\tDGEMM_Q\t\tgotoblas -> dgemm_q\n#define\tDGEMM_R\t\t1024\n#define\tDGEMM_UNROLL_M\tgotoblas -> dgemm_unroll_m\n#define\tDGEMM_UNROLL_N\tgotoblas -> dgemm_unroll_n\n#define DGEMM_UNROLL_MN\tgotoblas -> dgemm_unroll_mn\n#endif\n#if (BUILD_COMPLEX != 1)\n#define\tCGEMM_P\t\tgotoblas -> cgemm_p\n#define\tCGEMM_Q\t\tgotoblas -> cgemm_q\n#define\tCGEMM_R\t\tgotoblas -> cgemm_r\n#define\tCGEMM_UNROLL_M\tgotoblas -> cgemm_unroll_m\n#define\tCGEMM_UNROLL_N\tgotoblas -> cgemm_unroll_n\n#define CGEMM_UNROLL_MN\tgotoblas -> cgemm_unroll_mn\n#endif\n#endif\n\n#define\tXGEMM_P\t\tgotoblas -> xgemm_p\n#define\tXGEMM_Q\t\tgotoblas -> xgemm_q\n#define\tXGEMM_R\t\tgotoblas -> xgemm_r\n#define\tXGEMM_UNROLL_M\tgotoblas -> xgemm_unroll_m\n#define\tXGEMM_UNROLL_N\tgotoblas -> xgemm_unroll_n\n#define XGEMM_UNROLL_MN\tgotoblas -> xgemm_unroll_mn\n\n#define\tCGEMM3M_P\t\tgotoblas -> cgemm3m_p\n#define\tCGEMM3M_Q\t\tgotoblas -> cgemm3m_q\n#define\tCGEMM3M_R\t\tgotoblas -> cgemm3m_r\n#define\tCGEMM3M_UNROLL_M\tgotoblas -> cgemm3m_unroll_m\n#define\tCGEMM3M_UNROLL_N\tgotoblas -> cgemm3m_unroll_n\n#define CGEMM3M_UNROLL_MN\tgotoblas -> cgemm3m_unroll_mn\n\n#define\tZGEMM3M_P\t\tgotoblas -> zgemm3m_p\n#define\tZGEMM3M_Q\t\tgotoblas -> zgemm3m_q\n#define\tZGEMM3M_R\t\tgotoblas -> zgemm3m_r\n#define\tZGEMM3M_UNROLL_M\tgotoblas -> zgemm3m_unroll_m\n#define\tZGEMM3M_UNROLL_N\tgotoblas -> zgemm3m_unroll_n\n#define ZGEMM3M_UNROLL_MN\tgotoblas -> zgemm3m_unroll_mn\n\n#define\tXGEMM3M_P\t\tgotoblas -> xgemm3m_p\n#define\tXGEMM3M_Q\t\tgotoblas -> xgemm3m_q\n#define\tXGEMM3M_R\t\tgotoblas -> xgemm3m_r\n#define\tXGEMM3M_UNROLL_M\tgotoblas -> xgemm3m_unroll_m\n#define\tXGEMM3M_UNROLL_N\tgotoblas -> xgemm3m_unroll_n\n#define XGEMM3M_UNROLL_MN\tgotoblas -> xgemm3m_unroll_mn\n\n#else\n\n#define FUNC_OFFSET(func)\t(size_t)(func)\n\n#define DTB_ENTRIES  DTB_DEFAULT_ENTRIES\n\n#define GEMM_OFFSET_A\tGEMM_DEFAULT_OFFSET_A\n#define GEMM_OFFSET_B\tGEMM_DEFAULT_OFFSET_B\n#define GEMM_ALIGN\tGEMM_DEFAULT_ALIGN\n\n#ifdef HAVE_EXCLUSIVE_CACHE\n#define HAVE_EX_L2\t1\n#else\n#define HAVE_EX_L2\t0\n#endif\n\n#if (BUILD_BFLOAT16 == 1)\n#define\tSBGEMM_P\t\tSBGEMM_DEFAULT_P\n#define\tSBGEMM_Q\t\tSBGEMM_DEFAULT_Q\n#define\tSBGEMM_R\t\tSBGEMM_DEFAULT_R\n#define SBGEMM_UNROLL_M\tSBGEMM_DEFAULT_UNROLL_M\n#define SBGEMM_UNROLL_N\tSBGEMM_DEFAULT_UNROLL_N\n#ifdef  SBGEMM_DEFAULT_UNROLL_MN\n#define SBGEMM_UNROLL_MN\tSBGEMM_DEFAULT_UNROLL_MN\n#else\n#define SBGEMM_UNROLL_MN\tMAX((SBGEMM_UNROLL_M), (SBGEMM_UNROLL_N))\n#endif\n#endif\n\n#define\tSGEMM_P\t\tSGEMM_DEFAULT_P\n#define\tSGEMM_Q\t\tSGEMM_DEFAULT_Q\n#define\tSGEMM_R\t\tSGEMM_DEFAULT_R\n#define SGEMM_UNROLL_M\tSGEMM_DEFAULT_UNROLL_M\n#define SGEMM_UNROLL_N\tSGEMM_DEFAULT_UNROLL_N\n#ifdef  SGEMM_DEFAULT_UNROLL_MN\n#define SGEMM_UNROLL_MN\tSGEMM_DEFAULT_UNROLL_MN\n#else\n#define SGEMM_UNROLL_MN\tMAX((SGEMM_UNROLL_M), (SGEMM_UNROLL_N))\n#endif\n\n#define\tDGEMM_P\t\tDGEMM_DEFAULT_P\n#define\tDGEMM_Q\t\tDGEMM_DEFAULT_Q\n#define\tDGEMM_R\t\tDGEMM_DEFAULT_R\n#define DGEMM_UNROLL_M\tDGEMM_DEFAULT_UNROLL_M\n#define DGEMM_UNROLL_N\tDGEMM_DEFAULT_UNROLL_N\n#ifdef  DGEMM_DEFAULT_UNROLL_MN\n#define DGEMM_UNROLL_MN\tDGEMM_DEFAULT_UNROLL_MN\n#else\n#define DGEMM_UNROLL_MN\tMAX((DGEMM_UNROLL_M), (DGEMM_UNROLL_N))\n#endif\n\n#define\tQGEMM_P\t\tQGEMM_DEFAULT_P\n#define\tQGEMM_Q\t\tQGEMM_DEFAULT_Q\n#define\tQGEMM_R\t\tQGEMM_DEFAULT_R\n#define QGEMM_UNROLL_M\tQGEMM_DEFAULT_UNROLL_M\n#define QGEMM_UNROLL_N\tQGEMM_DEFAULT_UNROLL_N\n#define QGEMM_UNROLL_MN\tMAX((QGEMM_UNROLL_M), (QGEMM_UNROLL_N))\n\n#define\tCGEMM_P\t\tCGEMM_DEFAULT_P\n#define\tCGEMM_Q\t\tCGEMM_DEFAULT_Q\n#define\tCGEMM_R\t\tCGEMM_DEFAULT_R\n#define CGEMM_UNROLL_M\tCGEMM_DEFAULT_UNROLL_M\n#define CGEMM_UNROLL_N\tCGEMM_DEFAULT_UNROLL_N\n#ifdef  CGEMM_DEFAULT_UNROLL_MN\n#define CGEMM_UNROLL_MN\tCGEMM_DEFAULT_UNROLL_MN\n#else\n#define CGEMM_UNROLL_MN\tMAX((CGEMM_UNROLL_M), (CGEMM_UNROLL_N))\n#endif\n\n#define\tZGEMM_P\t\tZGEMM_DEFAULT_P\n#define\tZGEMM_Q\t\tZGEMM_DEFAULT_Q\n#define\tZGEMM_R\t\tZGEMM_DEFAULT_R\n#define ZGEMM_UNROLL_M\tZGEMM_DEFAULT_UNROLL_M\n#define ZGEMM_UNROLL_N\tZGEMM_DEFAULT_UNROLL_N\n#ifdef  ZGEMM_DEFAULT_UNROLL_MN\n#define ZGEMM_UNROLL_MN\tZGEMM_DEFAULT_UNROLL_MN\n#else\n#define ZGEMM_UNROLL_MN\tMAX((ZGEMM_UNROLL_M), (ZGEMM_UNROLL_N))\n#endif\n\n#define\tXGEMM_P\t\tXGEMM_DEFAULT_P\n#define\tXGEMM_Q\t\tXGEMM_DEFAULT_Q\n#define\tXGEMM_R\t\tXGEMM_DEFAULT_R\n#define XGEMM_UNROLL_M\tXGEMM_DEFAULT_UNROLL_M\n#define XGEMM_UNROLL_N\tXGEMM_DEFAULT_UNROLL_N\n#define XGEMM_UNROLL_MN\tMAX((XGEMM_UNROLL_M), (XGEMM_UNROLL_N))\n\n#ifdef CGEMM3M_DEFAULT_UNROLL_N\n\n#define\tCGEMM3M_P\t\tCGEMM3M_DEFAULT_P\n#define\tCGEMM3M_Q\t\tCGEMM3M_DEFAULT_Q\n#define\tCGEMM3M_R\t\tCGEMM3M_DEFAULT_R\n#define CGEMM3M_UNROLL_M\tCGEMM3M_DEFAULT_UNROLL_M\n#define CGEMM3M_UNROLL_N\tCGEMM3M_DEFAULT_UNROLL_N\n#define CGEMM3M_UNROLL_MN\tMAX((CGEMM3M_UNROLL_M), (CGEMM3M_UNROLL_N))\n\n#else\n\n#define\tCGEMM3M_P\t\tSGEMM_DEFAULT_P\n#define\tCGEMM3M_Q\t\tSGEMM_DEFAULT_Q\n#define\tCGEMM3M_R\t\tSGEMM_DEFAULT_R\n#define CGEMM3M_UNROLL_M\tSGEMM_DEFAULT_UNROLL_M\n#define CGEMM3M_UNROLL_N\tSGEMM_DEFAULT_UNROLL_N\n#define CGEMM3M_UNROLL_MN\tMAX((CGEMM_UNROLL_M), (CGEMM_UNROLL_N))\n\n#endif\n\n\n#ifdef ZGEMM3M_DEFAULT_UNROLL_N\n\n#define\tZGEMM3M_P\t\tZGEMM3M_DEFAULT_P\n#define\tZGEMM3M_Q\t\tZGEMM3M_DEFAULT_Q\n#define\tZGEMM3M_R\t\tZGEMM3M_DEFAULT_R\n#define ZGEMM3M_UNROLL_M\tZGEMM3M_DEFAULT_UNROLL_M\n#define ZGEMM3M_UNROLL_N\tZGEMM3M_DEFAULT_UNROLL_N\n#define ZGEMM3M_UNROLL_MN\tMAX((ZGEMM_UNROLL_M), (ZGEMM_UNROLL_N))\n\n#else\n\n#define\tZGEMM3M_P\t\tDGEMM_DEFAULT_P\n#define\tZGEMM3M_Q\t\tDGEMM_DEFAULT_Q\n#define\tZGEMM3M_R\t\tDGEMM_DEFAULT_R\n#define ZGEMM3M_UNROLL_M\tDGEMM_DEFAULT_UNROLL_M\n#define ZGEMM3M_UNROLL_N\tDGEMM_DEFAULT_UNROLL_N\n#define ZGEMM3M_UNROLL_MN\tMAX((ZGEMM_UNROLL_M), (ZGEMM_UNROLL_N))\n\n#endif\n\n#define\tXGEMM3M_P\t\tQGEMM_DEFAULT_P\n#define\tXGEMM3M_Q\t\tQGEMM_DEFAULT_Q\n#define\tXGEMM3M_R\t\tQGEMM_DEFAULT_R\n#define XGEMM3M_UNROLL_M\tQGEMM_DEFAULT_UNROLL_M\n#define XGEMM3M_UNROLL_N\tQGEMM_DEFAULT_UNROLL_N\n#define XGEMM3M_UNROLL_MN\tMAX((QGEMM_UNROLL_M), (QGEMM_UNROLL_N))\n\n\n#endif\n#endif\n\n#ifndef COMPLEX\n#if   defined(XDOUBLE)\n#define GEMM_P\t\t\tQGEMM_P\n#define GEMM_Q\t\t\tQGEMM_Q\n#define GEMM_R\t\t\tQGEMM_R\n#define GEMM_UNROLL_M\t\tQGEMM_UNROLL_M\n#define GEMM_UNROLL_N\t\tQGEMM_UNROLL_N\n#define GEMM_UNROLL_MN\t\tQGEMM_UNROLL_MN\n#define GEMM_DEFAULT_P\t\tQGEMM_DEFAULT_P\n#define GEMM_DEFAULT_Q\t\tQGEMM_DEFAULT_Q\n#define GEMM_DEFAULT_R\t\tQGEMM_DEFAULT_R\n#define GEMM_DEFAULT_UNROLL_M\tQGEMM_DEFAULT_UNROLL_M\n#define GEMM_DEFAULT_UNROLL_N\tQGEMM_DEFAULT_UNROLL_N\n#elif defined(DOUBLE)\n#define GEMM_P\t\t\tDGEMM_P\n#define GEMM_Q\t\t\tDGEMM_Q\n#define GEMM_R\t\t\tDGEMM_R\n#define GEMM_UNROLL_M\t\tDGEMM_UNROLL_M\n#define GEMM_UNROLL_N\t\tDGEMM_UNROLL_N\n#define GEMM_UNROLL_MN\t\tDGEMM_UNROLL_MN\n#define GEMM_DEFAULT_P\t\tDGEMM_DEFAULT_P\n#define GEMM_DEFAULT_Q\t\tDGEMM_DEFAULT_Q\n#define GEMM_DEFAULT_R\t\tDGEMM_DEFAULT_R\n#define GEMM_DEFAULT_UNROLL_M\tDGEMM_DEFAULT_UNROLL_M\n#define GEMM_DEFAULT_UNROLL_N\tDGEMM_DEFAULT_UNROLL_N\n#elif defined(BFLOAT16)\n#define GEMM_P\t\t\tSBGEMM_P\n#define GEMM_Q\t\t\tSBGEMM_Q\n#define GEMM_R\t\t\tSBGEMM_R\n#define GEMM_UNROLL_M\t\tSBGEMM_UNROLL_M\n#define GEMM_UNROLL_N\t\tSBGEMM_UNROLL_N\n#define GEMM_UNROLL_MN\t\tSBGEMM_UNROLL_MN\n#define GEMM_DEFAULT_P\t\tSBGEMM_DEFAULT_P\n#define GEMM_DEFAULT_Q\t\tSBGEMM_DEFAULT_Q\n#define GEMM_DEFAULT_R\t\tSBGEMM_DEFAULT_R\n#define GEMM_DEFAULT_UNROLL_M\tSBGEMM_DEFAULT_UNROLL_M\n#define GEMM_DEFAULT_UNROLL_N\tSBGEMM_DEFAULT_UNROLL_N\n#else\n#define GEMM_P\t\t\tSGEMM_P\n#define GEMM_Q\t\t\tSGEMM_Q\n#define GEMM_R\t\t\tSGEMM_R\n#define GEMM_UNROLL_M\t\tSGEMM_UNROLL_M\n#define GEMM_UNROLL_N\t\tSGEMM_UNROLL_N\n#define GEMM_UNROLL_MN\t\tSGEMM_UNROLL_MN\n#define GEMM_DEFAULT_P\t\tSGEMM_DEFAULT_P\n#define GEMM_DEFAULT_Q\t\tSGEMM_DEFAULT_Q\n#define GEMM_DEFAULT_R\t\tSGEMM_DEFAULT_R\n#define GEMM_DEFAULT_UNROLL_M\tSGEMM_DEFAULT_UNROLL_M\n#define GEMM_DEFAULT_UNROLL_N\tSGEMM_DEFAULT_UNROLL_N\n#endif\n#else\n#if   defined(XDOUBLE)\n#define GEMM_P\t\t\tXGEMM_P\n#define GEMM_Q\t\t\tXGEMM_Q\n#define GEMM_R\t\t\tXGEMM_R\n#define GEMM_UNROLL_M\t\tXGEMM_UNROLL_M\n#define GEMM_UNROLL_N\t\tXGEMM_UNROLL_N\n#define GEMM_UNROLL_MN\t\tXGEMM_UNROLL_MN\n#define GEMM_DEFAULT_P\t\tXGEMM_DEFAULT_P\n#define GEMM_DEFAULT_Q\t\tXGEMM_DEFAULT_Q\n#define GEMM_DEFAULT_R\t\tXGEMM_DEFAULT_R\n#define GEMM_DEFAULT_UNROLL_M\tXGEMM_DEFAULT_UNROLL_M\n#define GEMM_DEFAULT_UNROLL_N\tXGEMM_DEFAULT_UNROLL_N\n#elif defined(DOUBLE)\n#define GEMM_P\t\t\tZGEMM_P\n#define GEMM_Q\t\t\tZGEMM_Q\n#define GEMM_R\t\t\tZGEMM_R\n#define GEMM_UNROLL_M\t\tZGEMM_UNROLL_M\n#define GEMM_UNROLL_N\t\tZGEMM_UNROLL_N\n#define GEMM_UNROLL_MN\t\tZGEMM_UNROLL_MN\n#define GEMM_DEFAULT_P\t\tZGEMM_DEFAULT_P\n#define GEMM_DEFAULT_Q\t\tZGEMM_DEFAULT_Q\n#define GEMM_DEFAULT_R\t\tZGEMM_DEFAULT_R\n#define GEMM_DEFAULT_UNROLL_M\tZGEMM_DEFAULT_UNROLL_M\n#define GEMM_DEFAULT_UNROLL_N\tZGEMM_DEFAULT_UNROLL_N\n#else\n#define GEMM_P\t\t\tCGEMM_P\n#define GEMM_Q\t\t\tCGEMM_Q\n#define GEMM_R\t\t\tCGEMM_R\n#define GEMM_UNROLL_M\t\tCGEMM_UNROLL_M\n#define GEMM_UNROLL_N\t\tCGEMM_UNROLL_N\n#define GEMM_UNROLL_MN\t\tCGEMM_UNROLL_MN\n#define GEMM_DEFAULT_P\t\tCGEMM_DEFAULT_P\n#define GEMM_DEFAULT_Q\t\tCGEMM_DEFAULT_Q\n#define GEMM_DEFAULT_R\t\tCGEMM_DEFAULT_R\n#define GEMM_DEFAULT_UNROLL_M\tCGEMM_DEFAULT_UNROLL_M\n#define GEMM_DEFAULT_UNROLL_N\tCGEMM_DEFAULT_UNROLL_N\n#endif\n#endif\n\n#ifdef XDOUBLE\n#define GEMM3M_UNROLL_M\tXGEMM3M_UNROLL_M\n#define GEMM3M_UNROLL_N\tXGEMM3M_UNROLL_N\n#elif defined(DOUBLE)\n#define GEMM3M_UNROLL_M\tZGEMM3M_UNROLL_M\n#define GEMM3M_UNROLL_N\tZGEMM3M_UNROLL_N\n#else\n#define GEMM3M_UNROLL_M\tCGEMM3M_UNROLL_M\n#define GEMM3M_UNROLL_N\tCGEMM3M_UNROLL_N\n#endif\n\n\n#ifndef QGEMM_DEFAULT_UNROLL_M\n#define QGEMM_DEFAULT_UNROLL_M 2\n#endif\n\n#ifndef QGEMM_DEFAULT_UNROLL_N\n#define QGEMM_DEFAULT_UNROLL_N 2\n#endif\n\n#ifndef XGEMM_DEFAULT_UNROLL_M\n#define XGEMM_DEFAULT_UNROLL_M 2\n#endif\n\n#ifndef XGEMM_DEFAULT_UNROLL_N\n#define XGEMM_DEFAULT_UNROLL_N 2\n#endif\n\n#ifndef GEMM_THREAD\n#define GEMM_THREAD gemm_thread_n\n#endif\n\n#ifndef SBGEMM_DEFAULT_R\n#define SBGEMM_DEFAULT_R (((BUFFER_SIZE - ((SBGEMM_DEFAULT_P * SBGEMM_DEFAULT_Q *  4 + GEMM_DEFAULT_OFFSET_A + GEMM_DEFAULT_ALIGN) & ~GEMM_DEFAULT_ALIGN)) / (SBGEMM_DEFAULT_Q *  4) - 15) & ~15UL)\n#endif\n\n#ifndef SGEMM_DEFAULT_R\n#define SGEMM_DEFAULT_R (((BUFFER_SIZE - ((SGEMM_DEFAULT_P * SGEMM_DEFAULT_Q *  4 + GEMM_DEFAULT_OFFSET_A + GEMM_DEFAULT_ALIGN) & ~GEMM_DEFAULT_ALIGN)) / (SGEMM_DEFAULT_Q *  4) - 15) & ~15UL)\n#endif\n\n#ifndef DGEMM_DEFAULT_R\n#define DGEMM_DEFAULT_R (((BUFFER_SIZE - ((DGEMM_DEFAULT_P * DGEMM_DEFAULT_Q *  8 + GEMM_DEFAULT_OFFSET_A + GEMM_DEFAULT_ALIGN) & ~GEMM_DEFAULT_ALIGN)) / (DGEMM_DEFAULT_Q *  8) - 15) & ~15UL)\n#endif\n\n#ifndef QGEMM_DEFAULT_R\n#define QGEMM_DEFAULT_R (((BUFFER_SIZE - ((QGEMM_DEFAULT_P * QGEMM_DEFAULT_Q * 16 + GEMM_DEFAULT_OFFSET_A + GEMM_DEFAULT_ALIGN) & ~GEMM_DEFAULT_ALIGN)) / (QGEMM_DEFAULT_Q * 16) - 15) & ~15UL)\n#endif\n\n#ifndef CGEMM_DEFAULT_R\n#define CGEMM_DEFAULT_R (((BUFFER_SIZE - ((CGEMM_DEFAULT_P * CGEMM_DEFAULT_Q *  8 + GEMM_DEFAULT_OFFSET_A + GEMM_DEFAULT_ALIGN) & ~GEMM_DEFAULT_ALIGN)) / (CGEMM_DEFAULT_Q *  8) - 15) & ~15UL)\n#endif\n\n#ifndef ZGEMM_DEFAULT_R\n#define ZGEMM_DEFAULT_R (((BUFFER_SIZE - ((ZGEMM_DEFAULT_P * ZGEMM_DEFAULT_Q * 16 + GEMM_DEFAULT_OFFSET_A + GEMM_DEFAULT_ALIGN) & ~GEMM_DEFAULT_ALIGN)) / (ZGEMM_DEFAULT_Q * 16) - 15) & ~15UL)\n#endif\n\n#ifndef XGEMM_DEFAULT_R\n#define XGEMM_DEFAULT_R (((BUFFER_SIZE - ((XGEMM_DEFAULT_P * XGEMM_DEFAULT_Q * 32 + GEMM_DEFAULT_OFFSET_A + GEMM_DEFAULT_ALIGN) & ~GEMM_DEFAULT_ALIGN)) / (XGEMM_DEFAULT_Q * 32) - 15) & ~15UL)\n#endif\n\n#ifndef SNUMOPT\n#define SNUMOPT\t\t2\n#endif\n\n#ifndef DNUMOPT\n#define DNUMOPT\t\t2\n#endif\n\n#ifndef QNUMOPT\n#define QNUMOPT\t\t1\n#endif\n\n#ifndef GEMM3M_P\n#ifdef XDOUBLE\n#define GEMM3M_P\tXGEMM3M_P\n#elif defined(DOUBLE)\n#define GEMM3M_P\tZGEMM3M_P\n#else\n#define GEMM3M_P\tCGEMM3M_P\n#endif\n#endif\n\n#ifndef GEMM3M_Q\n#ifdef XDOUBLE\n#define GEMM3M_Q\tXGEMM3M_Q\n#elif defined(DOUBLE)\n#define GEMM3M_Q\tZGEMM3M_Q\n#else\n#define GEMM3M_Q\tCGEMM3M_Q\n#endif\n#endif\n\n#ifndef GEMM3M_R\n#ifdef XDOUBLE\n#define GEMM3M_R\tXGEMM3M_R\n#elif defined(DOUBLE)\n#define GEMM3M_R\tZGEMM3M_R\n#else\n#define GEMM3M_R\tCGEMM3M_R\n#endif\n#endif\n\n\n#endif\n"
        },
        {
          "name": "common_power.h",
          "type": "blob",
          "size": 18.369140625,
          "content": "/*********************************************************************/\n/* Copyright 2009, 2010 The University of Texas at Austin.           */\n/* All rights reserved.                                              */\n/*                                                                   */\n/* Redistribution and use in source and binary forms, with or        */\n/* without modification, are permitted provided that the following   */\n/* conditions are met:                                               */\n/*                                                                   */\n/*   1. Redistributions of source code must retain the above         */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer.                                                  */\n/*                                                                   */\n/*   2. Redistributions in binary form must reproduce the above      */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer in the documentation and/or other materials       */\n/*      provided with the distribution.                              */\n/*                                                                   */\n/*    THIS  SOFTWARE IS PROVIDED  BY THE  UNIVERSITY OF  TEXAS AT    */\n/*    AUSTIN  ``AS IS''  AND ANY  EXPRESS OR  IMPLIED WARRANTIES,    */\n/*    INCLUDING, BUT  NOT LIMITED  TO, THE IMPLIED  WARRANTIES OF    */\n/*    MERCHANTABILITY  AND FITNESS FOR  A PARTICULAR  PURPOSE ARE    */\n/*    DISCLAIMED.  IN  NO EVENT SHALL THE UNIVERSITY  OF TEXAS AT    */\n/*    AUSTIN OR CONTRIBUTORS BE  LIABLE FOR ANY DIRECT, INDIRECT,    */\n/*    INCIDENTAL,  SPECIAL, EXEMPLARY,  OR  CONSEQUENTIAL DAMAGES    */\n/*    (INCLUDING, BUT  NOT LIMITED TO,  PROCUREMENT OF SUBSTITUTE    */\n/*    GOODS  OR  SERVICES; LOSS  OF  USE,  DATA,  OR PROFITS;  OR    */\n/*    BUSINESS INTERRUPTION) HOWEVER CAUSED  AND ON ANY THEORY OF    */\n/*    LIABILITY, WHETHER  IN CONTRACT, STRICT  LIABILITY, OR TORT    */\n/*    (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY WAY OUT    */\n/*    OF  THE  USE OF  THIS  SOFTWARE,  EVEN  IF ADVISED  OF  THE    */\n/*    POSSIBILITY OF SUCH DAMAGE.                                    */\n/*                                                                   */\n/* The views and conclusions contained in the software and           */\n/* documentation are those of the authors and should not be          */\n/* interpreted as representing official policies, either expressed   */\n/* or implied, of The University of Texas at Austin.                 */\n/*********************************************************************/\n\n#ifndef COMMON_POWER\n#define COMMON_POWER\n\n#define str(x)\t#x\n\n#ifdef OS_AIX\n#define XXSPLTD(T,A,z)\txxpermdi\tT, A, A, 0b##z##z\n#define XXMRGHD(T,A,B)\txxpermdi\tT, A, B, 0b00\n#define XXMRGLD(T,A,B)\txxpermdi\tT, A, B, 0b11\n#define XXSWAPD(T,A)\txxpermdi\tT, A, A, 0b10\n#define XVMOVDP(T,A)\txvcpsgndp\tT, A, A\n\n#define XXSPLTD_S(T,A,z)\t\"xxpermdi\t\" str(T) \", \" str(A) \", \" str(A) \", 0b\" str(z ## z) \"\t\\n\\t\"\n#define XXMRGHD_S(T,A,B)\t\"xxpermdi\t\" str(T) \", \" str(A) \", \" str(B) \", 0b00\t\\n\\t\"\n#define XXMRGLD_S(T,A,B)\t\"xxpermdi\t\" str(T) \", \" str(A) \", \" str(B) \", 0b11\t\\n\\t\"\n#define XXSWAPD_S(T,A)\t\"xxpermdi\t\" str(T) \", \" str(A) \", \" str(A) \", 0b10\t\\n\\t\"\n\n#else\n#define XXSPLTD(T,A,z)\txxspltd\tT, A, z\n#define XXMRGHD(T,A,B)\txxmrghd\tT, A, B\n#define XXMRGLD(T,A,B)\txxmrgld\tT, A, B\n#define XXSWAPD(T,A)\txxswapd\tT, A\n#define XVMOVDP(T,A)\txvmovdp\tT, A\n\n#define XXSPLTD_S(T,A,z)\t\"xxspltd\t\" str(T) \", \" str(A) \", \" str(z)\"\t\\n\\t\"\n#define XXMRGHD_S(T,A,B)\t\"xxmrghd\t\" str(T) \", \" str(A) \", \" str(B)\"\t\\n\\t\"\n#define XXMRGLD_S(T,A,B)\t\"xxmrgld\t\" str(T) \", \" str(A) \", \" str(B)\"\t\\n\\t\"\n#define XXSWAPD_S(T,A)\t\"xxswapd\t\" str(T) \", \" str(A) \"\t\\n\\t\"\n\n#endif\n\n\n#if defined(POWER8) || defined(POWER9) || defined(POWER10)\n#define MB\t\t__asm__ __volatile__ (\"eieio\":::\"memory\")\n#define WMB\t\t__asm__ __volatile__ (\"eieio\":::\"memory\")\n#define RMB\t\t__asm__ __volatile__ (\"eieio\":::\"memory\")\n#else\n#define MB\t\t__asm__ __volatile__ (\"sync\")\n#define WMB\t\t__asm__ __volatile__ (\"sync\")\n#define RMB\t\t__asm__ __volatile__ (\"sync\")\n#endif\n\n#ifdef PPC440\n#define STDERR stdout\n#define QNONCACHE 0x1\n#define QCOMMS    0x2\n#define QFAST     0x4\n#endif\n\n#ifndef ASSEMBLER\n\nvoid *qalloc(int flags, size_t bytes);\n\nstatic inline void blas_lock(volatile unsigned long *address){\n\n  long int ret, val = 1;\n\n  do {\n    while (*address) {YIELDING;};\n\n#if defined(OS_LINUX) || defined(OS_DARWIN)\n  __asm__ __volatile__ (\n\t   \"0:\tlwarx %0, 0, %1\\n\"\n\t   \"\tcmpwi %0, 0\\n\"\n\t   \"\tbne- 1f\\n\"\n\t   \"\tstwcx. %2,0, %1\\n\"\n\t   \"\tbne- 0b\\n\"\n\t   \"    isync\\n\"\n\t   \"1:    \"\n\t: \"=&r\"(ret)\n\t: \"r\"(address), \"r\" (val)\n\t: \"cr0\", \"memory\");\n#else\n  __asm__ __volatile__ (\n\t   \".machine \\\"any\\\"\\n\"\n\t   \"\tlwarx %0, 0, %1\\n\"\n\t   \"\tcmpwi  %0, 0\\n\"\n\t   \"\tbne-  $+12\\n\"\n\t   \"\tstwcx. %2,0, %1\\n\"\n\t   \"\tbne-  $-16\\n\"\n\t: \"=&r\"(ret)\n\t: \"r\"(address), \"r\" (val)\n\t: \"cr0\", \"memory\");\n#endif\n  } while (ret);\n}\n#define BLAS_LOCK_DEFINED\n\nstatic inline unsigned long rpcc(void){\n  unsigned long ret;\n\n#ifdef OS_AIX\n  __asm__ __volatile__(\".machine \\\"any\\\" ;\");\n#endif\n  __asm__ __volatile__ (\"mftb %0\" : \"=r\" (ret) : );\n\n#if defined(POWER5) || defined(PPC970)\n  return (ret << 6);\n#else\n  return (ret << 3);\n#endif\n\n}\n#define RPCC_DEFINED\n\n#ifdef __64BIT__\n#define RPCC64BIT\n#endif\n\nstatic inline unsigned long getstackaddr(void){\n  unsigned long addr;\n\n  __asm__ __volatile__ (\"mr %0, 1\"\n\t\t\t : \"=r\"(addr) : : \"memory\");\n\n  return addr;\n};\n\n#if defined(OS_LINUX) || defined(OS_AIX)\n#define GET_IMAGE(res)  __asm__ __volatile__(\"fmr %0, 2\" : \"=f\"(res)  : : \"memory\")\n#else\n#define GET_IMAGE(res)  __asm__ __volatile__(\"fmr %0, f2\" : \"=f\"(res)  : : \"memory\")\n\n#define GET_IMAGE_CANCEL\n\n#endif\n\n#ifdef SMP\nstatic inline int blas_quickdivide(blasint x, blasint y){\n  return x / y;\n}\n#endif\n\n#endif\n\n\n#ifdef ASSEMBLER\n\n#ifdef DOUBLE\n#define LFD\tlfd\n#define LFDX\tlfdx\n#define LFPDX\tlfpdx\n#define LFSDX\tlfsdx\n#define LFXDX\tlfxdx\n#define LFDU\tlfdu\n#define LFDUX\tlfdux\n#define LFPDUX\tlfpdux\n#define LFSDUX\tlfsdux\n#define LFXDUX\tlfxdux\n#define STFD\tstfd\n#define STFDX\tstfdx\n#define STFPDX\tstfpdx\n#define STFSDX\tstfsdx\n#define STFXDX\tstfxdx\n#define STFDU\tstfdu\n#define STFDUX\tstfdux\n#define STFPDUX\tstfpdux\n#define STFSDUX\tstfsdux\n#define STFXDUX\tstfxdux\n#define FMADD\tfmadd\n#define FMSUB\tfmsub\n#define FNMADD\tfnmadd\n#define FNMSUB\tfnmsub\n#define FMUL\tfmul\n#define FADD\tfadd\n#define FSUB\tfsub\n#else\n#define LFD\tlfs\n#define LFDX\tlfsx\n#define LFPDX\tlfpsx\n#define LFSDX\tlfssx\n#define LFXDX\tlfxsx\n#define LFDU\tlfsu\n#define LFDUX\tlfsux\n#define LFPDUX\tlfpsux\n#define LFSDUX\tlfssux\n#define LFXDUX\tlfxsux\n#define STFD\tstfs\n#define STFDX\tstfsx\n#define STFPDX\tstfpsx\n#define STFSDX\tstfssx\n#define STFXDX\tstfxsx\n#define STFDU\tstfsu\n#define STFDUX\tstfsux\n#define STFPDUX\tstfpsux\n#define STFSDUX\tstfssux\n#define STFXDUX\tstfxsux\n#define FMADD\tfmadds\n#define FMSUB\tfmsubs\n#define FNMADD\tfnmadds\n#define FNMSUB\tfnmsubs\n#define FMUL\tfmuls\n#define FADD\tfadds\n#define FSUB\tfsubs\n#endif\n\n#ifdef __64BIT__\n#define LDLONG\tld\n#else\n#define LDLONG\tlwz\n#endif\n\n#ifdef OS_DARWIN\n#define LL(x)\tL##x\n#endif\n\n#ifdef OS_LINUX\n#define LL(x)\t.L##x\n#endif\n\n#ifndef LL\n#define LL(x)\t__L##x\n#endif\n\n\n#if   defined(__64BIT__) &&  defined(USE64BITINT)\n#define LDINT\tld\n#elif defined(__64BIT__) && !defined(USE64BITINT)\n#define LDINT\tlwa\n#else\n#define LDINT\tlwz\n#endif\n\n/*\n#define DCBT(REGA, REGB, NUM) .long (0x7c00022c | (REGA << 16) | (REGB << 11) | ((NUM) << 21))\n#define DCBTST(REGA, REGB, NUM) .long (0x7c0001ec | (REGA << 16) | (REGB << 11) | ((NUM) << 21))\n*/\n\n#define DSTATTR_H(SIZE, COUNT, STRIDE) ((SIZE << 8) | (COUNT))\n#define DSTATTR_L(SIZE, COUNT, STRIDE) (STRIDE)\n\n#if defined(PPC970) || defined(POWER3) || defined(POWER4) || defined(POWER5) || defined(PPCG4)\n#define HAVE_PREFETCH\n#endif\n\n#if defined(POWER3) || defined(POWER6) || defined(PPCG4) || defined(CELL) || defined(POWER8) || defined(POWER9) || defined(POWER10) || defined(PPC970)\n#define DCBT_ARG\t0\n#else\n#define DCBT_ARG\t8\n#endif\n\n#ifdef CELL\n#define L1_DUALFETCH\n#define L1_PREFETCHSIZE (64 + 128 * 13)\n#endif\n\n#if defined(POWER3) || defined(POWER4) || defined(POWER5)\n#define L1_DUALFETCH\n#define L1_PREFETCHSIZE (96 + 128 * 12)\n#endif\n\n#if defined(POWER6)\n#define L1_DUALFETCH\n#define L1_PREFETCHSIZE (16 + 128 * 100)\n#define L1_PREFETCH\tdcbtst\n#endif\n\n#if defined(POWER8) || defined(POWER9) || defined(POWER10)\n#define L1_DUALFETCH\n#define L1_PREFETCHSIZE (16 + 128 * 100)\n#define L1_PREFETCH\tdcbtst\n#endif\n\n#\n#ifndef L1_PREFETCH\n#define L1_PREFETCH\tdcbt\n#endif\n\n#ifndef L1_PREFETCHW\n#define L1_PREFETCHW\tdcbtst\n#endif\n\n#if DCBT_ARG == 0\n#define DCBT(REGA, REGB)\tL1_PREFETCH\tREGB, REGA\n#define DCBTST(REGA, REGB)\tL1_PREFETCHW\tREGB, REGA\n#else\n#define DCBT(REGA, REGB)\tL1_PREFETCH\tDCBT_ARG, REGB, REGA\n#define DCBTST(REGA, REGB)\tL1_PREFETCHW\tDCBT_ARG, REGB, REGA\n#endif\n\n\n#ifndef L1_PREFETCHSIZE\n#define L1_PREFETCHSIZE (96 + 128 * 12)\n#endif\n\n#if !defined(OS_DARWIN) || defined(NEEDPARAM)\n#define f0\t0\n#define f1\t1\n#define f2\t2\n#define f3\t3\n#define f4\t4\n#define f5\t5\n#define f6\t6\n#define f7\t7\n#define f8\t8\n#define f9\t9\n#define f10\t10\n#define f11\t11\n#define f12\t12\n#define f13\t13\n#define f14\t14\n#define f15\t15\n#define f16\t16\n#define f17\t17\n#define f18\t18\n#define f19\t19\n#define f20\t20\n#define f21\t21\n#define f22\t22\n#define f23\t23\n#define f24\t24\n#define f25\t25\n#define f26\t26\n#define f27\t27\n#define f28\t28\n#define f29\t29\n#define f30\t30\n#define f31\t31\n\n#define r0\t0\n#define r1\t1\n#define r2\t2\n#define r3\t3\n#define r4\t4\n#define r5\t5\n#define r6\t6\n#define r7\t7\n#define r8\t8\n#define r9\t9\n#define r10\t10\n#define r11\t11\n#define r12\t12\n#define r13\t13\n#define r14\t14\n#define r15\t15\n#define r16\t16\n#define r17\t17\n#define r18\t18\n#define r19\t19\n#define r20\t20\n#define r21\t21\n#define r22\t22\n#define r23\t23\n#define r24\t24\n#define r25\t25\n#define r26\t26\n#define r27\t27\n#define r28\t28\n#define r29\t29\n#define r30\t30\n#define r31\t31\n\n#define v0\t0\n#define v1\t1\n#define v2\t2\n#define v3\t3\n#define v4\t4\n#define v5\t5\n#define v6\t6\n#define v7\t7\n#define v8\t8\n#define v9\t9\n#define v10\t10\n#define v11\t11\n#define v12\t12\n#define v13\t13\n#define v14\t14\n#define v15\t15\n#define v16\t16\n#define v17\t17\n#define v18\t18\n#define v19\t19\n#define v20\t20\n#define v21\t21\n#define v22\t22\n#define v23\t23\n#define v24\t24\n#define v25\t25\n#define v26\t26\n#define v27\t27\n#define v28\t28\n#define v29\t29\n#define v30\t30\n#define v31\t31\n\n#define BO_dCTR_NZERO_AND_NOT\t0\n#define BO_dCTR_NZERO_AND_NOT_1\t1\n#define BO_dCTR_ZERO_AND_NOT\t2\n#define BO_dCTR_ZERO_AND_NOT_1\t3\n#define BO_IF_NOT\t4\n#define BO_IF_NOT_1\t5\n#define BO_IF_NOT_2\t6\n#define BO_IF_NOT_3\t7\n#define BO_dCTR_NZERO_AND\t8\n#define BO_dCTR_NZERO_AND_1\t9\n#define BO_dCTR_ZERO_AND\t10\n#define BO_dCTR_ZERO_AND_1\t11\n#define BO_IF\t12\n#define BO_IF_1\t13\n#define BO_IF_2\t14\n#define BO_IF_3\t15\n#define BO_dCTR_NZERO\t16\n#define BO_dCTR_NZERO_1\t17\n#define BO_dCTR_ZERO\t18\n#define BO_dCTR_ZERO_1\t19\n#define BO_ALWAYS\t20\n#define BO_ALWAYS_1\t21\n#define BO_ALWAYS_2\t22\n#define BO_ALWAYS_3\t23\n#define BO_dCTR_NZERO_8\t24\n#define BO_dCTR_NZERO_9\t25\n#define BO_dCTR_ZERO_8\t26\n#define BO_dCTR_ZERO_9\t27\n#define BO_ALWAYS_8\t28\n#define BO_ALWAYS_9\t29\n#define BO_ALWAYS_10\t30\n#define BO_ALWAYS_11\t31\n\n#define CR0_LT\t0\n#define CR0_GT\t1\n#define CR0_EQ\t2\n#define CR0_SO\t3\n#define CR1_FX\t4\n#define CR1_FEX\t5\n#define CR1_VX\t6\n#define CR1_OX\t7\n#define CR2_LT\t8\n#define CR2_GT\t9\n#define CR2_EQ\t10\n#define CR2_SO\t11\n#define CR3_LT\t12\n#define CR3_GT\t13\n#define CR3_EQ\t14\n#define CR3_SO\t15\n#define CR4_LT\t16\n#define CR4_GT\t17\n#define CR4_EQ\t18\n#define CR4_SO\t19\n#define CR5_LT\t20\n#define CR5_GT\t21\n#define CR5_EQ\t22\n#define CR5_SO\t23\n#define CR6_LT\t24\n#define CR6_GT\t25\n#define CR6_EQ\t26\n#define CR6_SO\t27\n#define CR7_LT\t28\n#define CR7_GT\t29\n#define CR7_EQ\t30\n#define CR7_SO\t31\n#define TO_LT\t16\n#define TO_GT\t8\n#define TO_EQ\t4\n#define TO_LLT\t2\n#define TO_LGT\t1\n#define CR0\t 0\n#define CR1\t 1\n#define CR2\t 2\n#define CR3\t 3\n#define CR4\t 4\n#define CR5\t 5\n#define CR6\t 6\n#define CR7\t 7\n#define cr0\t 0\n#define cr1\t 1\n#define cr2\t 2\n#define cr3\t 3\n#define cr4\t 4\n#define cr5\t 5\n#define cr6\t 6\n#define cr7\t 7\n#define VRsave\t256\n\n#endif\n\n#define CTR 9\n#define SP r1\n\n#ifdef __64BIT__\n#define\tslwi\tsldi\n#define cmpwi\tcmpdi\n#define srawi\tsradi\n#define mullw\tmulld\n#endif\n\n#ifndef F_INTERFACE\n#define REALNAME ASMNAME\n#else\n#define REALNAME ASMFNAME\n#endif\n\n#if defined(ASSEMBLER) && !defined(NEEDPARAM)\n\n#if defined(OS_LINUX) || defined(OS_FREEBSD)\n#ifndef __64BIT__\n#define PROLOGUE \\\n\t.section .text;\\\n\t.align 6;\\\n\t.globl\tREALNAME;\\\n\t.type\tREALNAME, @function;\\\nREALNAME:\n#define EPILOGUE\t.size\tREALNAME, .-REALNAME\n#else\n#if _CALL_ELF == 2\n#define PROLOGUE \\\n\t.section .text;\\\n\t.align 6;\\\n\t.globl\tREALNAME;\\\n\t.type\tREALNAME, @function;\\\nREALNAME:\n#define EPILOGUE\t.size\tREALNAME, .-REALNAME\n#else\n#define PROLOGUE \\\n\t.section .text;\\\n\t.align 5;\\\n\t.globl REALNAME;\\\n\t.section\t\".opd\",\"aw\";\\\n\t.align 3;\\\nREALNAME:;\\\n\t.quad\t.REALNAME, .TOC.@tocbase, 0;\\\n\t.previous;\\\n\t.size\tREALNAME, 24;\\\n\t.type\t.REALNAME, @function;\\\n\t.globl\t.REALNAME;\\\n.REALNAME:\n#define EPILOGUE \\\n\t.long 0 ; \\\n\t.byte 0,0,0,1,128,0,0,0 ; \\\n\t.size\t.REALNAME, .-.REALNAME; \\\n\t.section\t.note.GNU-stack,\"\",@progbits\n#endif\n#endif\n\n#ifdef PROFILE\n#ifndef __64BIT__\n#define PROFCODE ;\\\n\t.section\t\".data\";\\\n\t.align 2;\\\n.LP3:;\\\n\t.long\t0;\\\n\t.section\t\".text\";\\\n\tmflr\tr0;\\\n\tstw\tr0,   4(SP);\\\n\tlis\tr12, .LP3@ha;\\\n\tla\tr0, .LP3@l(r12);\\\n\tbl\t_mcount;\\\n\tlwz\tr0,   4(SP);\\\n\tmtlr\tr0\n#else\n#define PROFCODE \\\n\t.globl\t _mcount; \\\n\tmflr\tr0; \\\n\tstd\tr0,    16(SP); \\\n\tmr\tr11, SP; \\\n\taddi\tSP, SP, -256; \\\n\tstd\tr11,    0(SP); \\\n\tstd\tr3,   128(SP); \\\n\tstd\tr4,   136(SP); \\\n\tstd\tr5,   144(SP); \\\n\tstd\tr6,   152(SP); \\\n\tstd\tr7,   160(SP); \\\n\tstd\tr8,   168(SP); \\\n\tstd\tr9,   176(SP); \\\n\tstd\tr10,  184(SP); \\\n\tstfd\tf3,   192(SP); \\\n\tstfd\tf4,   200(SP); \\\n\tbl\t._mcount; \\\n\tnop; \\\n\tld\tr3,   128(SP);\\\n\tld\tr4,   136(SP);\\\n\tld\tr5,   144(SP);\\\n\tld\tr6,   152(SP);\\\n\tld\tr7,   160(SP);\\\n\tld\tr8,   168(SP);\\\n\tld\tr9,   176(SP);\\\n\tld\tr10,  184(SP);\\\n\tlfd\tf3,   192(SP);\\\n\tlfd\tf4,   200(SP);\\\n\taddi\tSP, SP,  256;\\\n\tld\tr0,    16(SP);\\\n\tmtlr\tr0\n#endif\n#else\n#define PROFCODE\n#endif\n\n#endif\n\n#if OS_AIX\n#ifndef __64BIT__\n#define PROLOGUE \\\n\t.machine \"any\";\\\n\t.toc;\\\n\t.globl .REALNAME;\\\n\t.globl REALNAME;\\\n\t.csect REALNAME[DS],3;\\\nREALNAME:;\\\n\t.long .REALNAME, TOC[tc0], 0;\\\n\t.csect .text[PR],5;\\\n.REALNAME:\n\n#define EPILOGUE \\\n_section_.text:;\\\n\t.csect .data[RW],4;\\\n\t.long _section_.text;\n\n#else\n\n#define PROLOGUE \\\n\t.machine \"any\";\\\n\t.toc;\\\n\t.globl .REALNAME;\\\n\t.globl REALNAME;\\\n\t.csect REALNAME[DS],3;\\\nREALNAME:;\\\n\t.llong .REALNAME, TOC[tc0], 0;\\\n\t.csect .text[PR], 5;\\\n.REALNAME:\n\n#define EPILOGUE \\\n_section_.text:;\\\n\t.csect .data[RW],4;\\\n\t.llong _section_.text;\n#endif\n\n#define PROFCODE\n\n#endif\n\n#ifdef OS_DARWIN\n#ifndef __64BIT__\n\t.macro PROLOGUE\n\t.section __TEXT,__text,regular,pure_instructions\n\t.section __TEXT,__picsymbolstub1,symbol_stubs,pure_instructions,32\n\t.machine ppc\n\t.text\n\t.align 4\n\t.globl REALNAME\nREALNAME:\n\t.endmacro\n#else\n\t.macro PROLOGUE\n\t.section __TEXT,__text,regular,pure_instructions\n\t.section __TEXT,__picsymbolstub1,symbol_stubs,pure_instructions,32\n\t.machine ppc64\n\t.text\n\t.align 4\n\t.globl REALNAME\nREALNAME:\n\t.endmacro\n#endif\n\n#ifndef PROFILE\n#define PROFCODE\n#define EPILOGUE\t.subsections_via_symbols\n#else\n#ifndef __64BIT__\n\n\t.macro PROFCODE\n\tmflr\tr0\n\tstw\tr0,     8(SP)\n\taddi\tSP, SP, -64\n\tstw\tSP,     0(SP)\n\tstw\tr3,    12(SP)\n\tstw\tr4,    16(SP)\n\tstw\tr5,    20(SP)\n\tstw\tr6,    24(SP)\n\tstw\tr7,    28(SP)\n\tstw\tr8,    32(SP)\n\tstw\tr9,    36(SP)\n\tstw\tr10,   40(SP)\n\tstfd\tf1,    48(SP)\n\tstfd\tf2,    56(SP)\n\tmr\tr3, r0\n\tbl\tLmcount$stub\n\tnop\n\tlwz\tr3,    12(SP)\n\tlwz\tr4,    16(SP)\n\tlwz\tr5,    20(SP)\n\tlwz\tr6,    24(SP)\n\tlwz\tr7,    28(SP)\n\tlwz\tr8,    32(SP)\n\tlwz\tr9,    36(SP)\n\tlwz\tr10,   40(SP)\n\tlfd\tf1,    48(SP)\n\tlfd\tf2,    56(SP)\n\taddi\tSP, SP,  64\n\tlwz\tr0,     8(SP)\n\tmtlr\tr0\n\t.endmacro\n\n\t.macro EPILOGUE\n\t.section __TEXT,__picsymbolstub1,symbol_stubs,pure_instructions,32\n\t.align 5\nLmcount$stub:\n\t.indirect_symbol mcount\n\tmflr r0\n\tbcl 20,31,L00000000001$spb\nL00000000001$spb:\n\tmflr r11\n\taddis r11,r11,ha16(Lmcount$lazy_ptr-L00000000001$spb)\n\tmtlr r0\n\tlwzu r12,lo16(Lmcount$lazy_ptr-L00000000001$spb)(r11)\n\tmtctr r12\n\tbctr\n\t.lazy_symbol_pointer\nLmcount$lazy_ptr:\n\t.indirect_symbol mcount\n\t.long\tdyld_stub_binding_helper\n\t.subsections_via_symbols\n\t.endmacro\n\n#else\n\t.macro PROFCODE\n\tmflr\tr0\n\tstd\tr0,    16(SP)\n\taddi\tSP, SP, -128\n\tstd\tSP,     0(SP)\n\tstd\tr3,    24(SP)\n\tstd\tr4,    32(SP)\n\tstd\tr5,    40(SP)\n\tstd\tr6,    48(SP)\n\tstd\tr7,    56(SP)\n\tstd\tr8,    64(SP)\n\tstd\tr9,    72(SP)\n\tstd\tr10,   80(SP)\n\tstfd\tf1,    88(SP)\n\tstfd\tf2,    96(SP)\n\tmr\tr3, r0\n\tbl\tLmcount$stub\n\tnop\n\tld\tr3,    24(SP)\n\tld\tr4,    32(SP)\n\tld\tr5,    40(SP)\n\tld\tr6,    48(SP)\n\tld\tr7,    56(SP)\n\tld\tr8,    64(SP)\n\tld\tr9,    72(SP)\n\tld\tr10,   80(SP)\n\tlfd\tf1,    88(SP)\n\tlfd\tf2,    86(SP)\n\taddi\tSP, SP,  128\n\tld\tr0,    16(SP)\n\tmtlr\tr0\n\t.endmacro\n\n\t.macro EPILOGUE\n\t.data\n\t.section __TEXT,__picsymbolstub1,symbol_stubs,pure_instructions,32\n\t.align 5\nLmcount$stub:\n\t.indirect_symbol mcount\n\tmflr r0\n\tbcl 20,31,L00000000001$spb\nL00000000001$spb:\n\tmflr r11\n\taddis r11,r11,ha16(Lmcount$lazy_ptr-L00000000001$spb)\n\tmtlr r0\n\tld r12,lo16(Lmcount$lazy_ptr-L00000000001$spb)(r11)\n\tmtctr r12\n\tbctr\n\t.lazy_symbol_pointer\nLmcount$lazy_ptr:\n\t.indirect_symbol mcount\n\t.quad\tdyld_stub_binding_helper\n\t.subsections_via_symbols\n\t.endmacro\n#endif\n\n#endif\n\n#endif\n#endif\n\n#endif\n\n#define HALT\t\tmfspr\tr0, 1023\n\n#if defined(OS_LINUX) || defined(OS_FREEBSD)\n#if defined(PPC440) || defined(PPC440FP2)\n#undef  MAX_CPU_NUMBER\n#define MAX_CPU_NUMBER 1\n#endif\n#if !defined(__64BIT__) && !defined(PROFILE) && !defined(PPC440) && !defined(PPC440FP2)\n#define START_ADDRESS (0x0b000000UL)\n#else\n#define SEEK_ADDRESS\n#endif\n#endif\n\n#ifdef OS_AIX\n#ifndef __64BIT__\n#define START_ADDRESS (0xf0000000UL)\n#else\n#define SEEK_ADDRESS\n#endif\n#endif\n\n#ifdef OS_DARWIN\n#define SEEK_ADDRESS\n#endif\n\n#if defined(PPC440)\n#define BUFFER_SIZE     (  2UL << 20)\n#elif defined(PPC440FP2)\n#define BUFFER_SIZE     ( 16UL << 20)\n#elif defined(POWER6) || defined(POWER8) || defined(POWER9) || defined(POWER10)\n#define BUFFER_SIZE     ( 64UL << 22)\n#else\n#define BUFFER_SIZE     ( 16UL << 20)\n#endif\n#ifdef DYNAMIC_ARCH\n#undef BUFFER_SIZE\n#define BUFFER_SIZE (64UL << 22)\n#endif\n\n#ifndef PAGESIZE\n#define PAGESIZE\t( 4 << 10)\n#endif\n#define HUGE_PAGESIZE\t(16 << 20)\n\n#define BASE_ADDRESS (START_ADDRESS - BUFFER_SIZE * MAX_CPU_NUMBER)\n\n#ifndef MAP_ANONYMOUS\n#define MAP_ANONYMOUS MAP_ANON\n#endif\n\n#if defined(OS_LINUX) || defined(OS_FREEBSD)\n#ifndef __64BIT__\n#define FRAMESLOT(X) (((X) * 4) + 8)\n#else\n#if _CALL_ELF == 2\n#define FRAMESLOT(X) (((X) * 8) + 96)\n#else\n#define FRAMESLOT(X) (((X) * 8) + 112)\n#endif\n#endif\n#endif\n\n#if defined(OS_AIX) || defined(OS_DARWIN)\n#ifndef __64BIT__\n#define FRAMESLOT(X) (((X) * 4) + 56)\n#else\n#define FRAMESLOT(X) (((X) * 8) + 112)\n#endif\n#endif\n\n#endif\n"
        },
        {
          "name": "common_q.h",
          "type": "blob",
          "size": 13.4892578125,
          "content": "#ifndef COMMON_Q_H\n#define COMMON_Q_H\n\n#ifndef DYNAMIC_ARCH\n\n#define\tQAMAX_K\t\t\tqamax_k\n#define\tQAMIN_K\t\t\tqamin_k\n#define\tQMAX_K\t\t\tqmax_k\n#define\tQMIN_K\t\t\tqmin_k\n#define\tIQAMAX_K\t\tiqamax_k\n#define\tIQAMIN_K\t\tiqamin_k\n#define\tIQMAX_K\t\t\tiqmax_k\n#define\tIQMIN_K\t\t\tiqmin_k\n#define\tQASUM_K\t\t\tqasum_k\n#define\tQAXPYU_K\t\tqaxpy_k\n#define\tQAXPYC_K\t\tqaxpy_k\n#define\tQCOPY_K\t\t\tqcopy_k\n#define\tQDOTU_K\t\t\tqdot_k\n#define\tQDOTC_K\t\t\tqdot_k\n#define\tQNRM2_K\t\t\tqnrm2_k\n#define\tQSCAL_K\t\t\tqscal_k\n#define\tQSUM_K\t\t\tqsum_k\n#define\tQSWAP_K\t\t\tqswap_k\n#define\tQROT_K\t\t\tqrot_k\n\n#define\tQGEMV_N\t\t\tqgemv_n\n#define\tQGEMV_T\t\t\tqgemv_t\n#define\tQGEMV_R\t\t\tqgemv_n\n#define\tQGEMV_C\t\t\tqgemv_t\n#define\tQGEMV_O\t\t\tqgemv_n\n#define\tQGEMV_U\t\t\tqgemv_t\n#define\tQGEMV_S\t\t\tqgemv_n\n#define\tQGEMV_D\t\t\tqgemv_t\n\n#define\tQGERU_K\t\t\tqger_k\n#define\tQGERC_K\t\t\tqger_k\n#define\tQGERV_K\t\t\tqger_k\n#define\tQGERD_K\t\t\tqger_k\n\n#define QSYMV_U\t\t\tqsymv_U\n#define QSYMV_L\t\t\tqsymv_L\n#define QSYMV_THREAD_U\t\tqsymv_thread_U\n#define QSYMV_THREAD_L\t\tqsymv_thread_L\n\n#define\tQGEMM_ONCOPY\t\tqgemm_oncopy\n#define\tQGEMM_OTCOPY\t\tqgemm_otcopy\n\n#if QGEMM_DEFAULT_UNROLL_M == QGEMM_DEFAULT_UNROLL_N\n#define\tQGEMM_INCOPY\t\tqgemm_oncopy\n#define\tQGEMM_ITCOPY\t\tqgemm_otcopy\n#else\n#define\tQGEMM_INCOPY\t\tqgemm_incopy\n#define\tQGEMM_ITCOPY\t\tqgemm_itcopy\n#endif\n\n#define\tQTRMM_OUNUCOPY\t\tqtrmm_ounucopy\n#define\tQTRMM_OUNNCOPY\t\tqtrmm_ounncopy\n#define\tQTRMM_OUTUCOPY\t\tqtrmm_outucopy\n#define\tQTRMM_OUTNCOPY\t\tqtrmm_outncopy\n#define\tQTRMM_OLNUCOPY\t\tqtrmm_olnucopy\n#define\tQTRMM_OLNNCOPY\t\tqtrmm_olnncopy\n#define\tQTRMM_OLTUCOPY\t\tqtrmm_oltucopy\n#define\tQTRMM_OLTNCOPY\t\tqtrmm_oltncopy\n\n#define\tQTRSM_OUNUCOPY\t\tqtrsm_ounucopy\n#define\tQTRSM_OUNNCOPY\t\tqtrsm_ounncopy\n#define\tQTRSM_OUTUCOPY\t\tqtrsm_outucopy\n#define\tQTRSM_OUTNCOPY\t\tqtrsm_outncopy\n#define\tQTRSM_OLNUCOPY\t\tqtrsm_olnucopy\n#define\tQTRSM_OLNNCOPY\t\tqtrsm_olnncopy\n#define\tQTRSM_OLTUCOPY\t\tqtrsm_oltucopy\n#define\tQTRSM_OLTNCOPY\t\tqtrsm_oltncopy\n\n#if QGEMM_DEFAULT_UNROLL_M == QGEMM_DEFAULT_UNROLL_N\n#define\tQTRMM_IUNUCOPY\t\tqtrmm_ounucopy\n#define\tQTRMM_IUNNCOPY\t\tqtrmm_ounncopy\n#define\tQTRMM_IUTUCOPY\t\tqtrmm_outucopy\n#define\tQTRMM_IUTNCOPY\t\tqtrmm_outncopy\n#define\tQTRMM_ILNUCOPY\t\tqtrmm_olnucopy\n#define\tQTRMM_ILNNCOPY\t\tqtrmm_olnncopy\n#define\tQTRMM_ILTUCOPY\t\tqtrmm_oltucopy\n#define\tQTRMM_ILTNCOPY\t\tqtrmm_oltncopy\n\n#define\tQTRSM_IUNUCOPY\t\tqtrsm_ounucopy\n#define\tQTRSM_IUNNCOPY\t\tqtrsm_ounncopy\n#define\tQTRSM_IUTUCOPY\t\tqtrsm_outucopy\n#define\tQTRSM_IUTNCOPY\t\tqtrsm_outncopy\n#define\tQTRSM_ILNUCOPY\t\tqtrsm_olnucopy\n#define\tQTRSM_ILNNCOPY\t\tqtrsm_olnncopy\n#define\tQTRSM_ILTUCOPY\t\tqtrsm_oltucopy\n#define\tQTRSM_ILTNCOPY\t\tqtrsm_oltncopy\n#else\n#define\tQTRMM_IUNUCOPY\t\tqtrmm_iunucopy\n#define\tQTRMM_IUNNCOPY\t\tqtrmm_iunncopy\n#define\tQTRMM_IUTUCOPY\t\tqtrmm_iutucopy\n#define\tQTRMM_IUTNCOPY\t\tqtrmm_iutncopy\n#define\tQTRMM_ILNUCOPY\t\tqtrmm_ilnucopy\n#define\tQTRMM_ILNNCOPY\t\tqtrmm_ilnncopy\n#define\tQTRMM_ILTUCOPY\t\tqtrmm_iltucopy\n#define\tQTRMM_ILTNCOPY\t\tqtrmm_iltncopy\n\n#define\tQTRSM_IUNUCOPY\t\tqtrsm_iunucopy\n#define\tQTRSM_IUNNCOPY\t\tqtrsm_iunncopy\n#define\tQTRSM_IUTUCOPY\t\tqtrsm_iutucopy\n#define\tQTRSM_IUTNCOPY\t\tqtrsm_iutncopy\n#define\tQTRSM_ILNUCOPY\t\tqtrsm_ilnucopy\n#define\tQTRSM_ILNNCOPY\t\tqtrsm_ilnncopy\n#define\tQTRSM_ILTUCOPY\t\tqtrsm_iltucopy\n#define\tQTRSM_ILTNCOPY\t\tqtrsm_iltncopy\n#endif\n\n#define\tQGEMM_BETA\t\tqgemm_beta\n\n#define\tQGEMM_KERNEL\t\tqgemm_kernel\n\n#define\tQTRMM_KERNEL_LN\t\tqtrmm_kernel_LN\n#define\tQTRMM_KERNEL_LT\t\tqtrmm_kernel_LT\n#define\tQTRMM_KERNEL_LR\t\tqtrmm_kernel_LN\n#define\tQTRMM_KERNEL_LC\t\tqtrmm_kernel_LT\n#define\tQTRMM_KERNEL_RN\t\tqtrmm_kernel_RN\n#define\tQTRMM_KERNEL_RT\t\tqtrmm_kernel_RT\n#define\tQTRMM_KERNEL_RR\t\tqtrmm_kernel_RN\n#define\tQTRMM_KERNEL_RC\t\tqtrmm_kernel_RT\n\n#define\tQTRSM_KERNEL_LN\t\tqtrsm_kernel_LN\n#define\tQTRSM_KERNEL_LT\t\tqtrsm_kernel_LT\n#define\tQTRSM_KERNEL_LR\t\tqtrsm_kernel_LN\n#define\tQTRSM_KERNEL_LC\t\tqtrsm_kernel_LT\n#define\tQTRSM_KERNEL_RN\t\tqtrsm_kernel_RN\n#define\tQTRSM_KERNEL_RT\t\tqtrsm_kernel_RT\n#define\tQTRSM_KERNEL_RR\t\tqtrsm_kernel_RN\n#define\tQTRSM_KERNEL_RC\t\tqtrsm_kernel_RT\n\n#define\tQSYMM_OUTCOPY\t\tqsymm_outcopy\n#define\tQSYMM_OLTCOPY\t\tqsymm_oltcopy\n#if QGEMM_DEFAULT_UNROLL_M == QGEMM_DEFAULT_UNROLL_N\n#define\tQSYMM_IUTCOPY\t\tqsymm_outcopy\n#define\tQSYMM_ILTCOPY\t\tqsymm_oltcopy\n#else\n#define\tQSYMM_IUTCOPY\t\tqsymm_iutcopy\n#define\tQSYMM_ILTCOPY\t\tqsymm_iltcopy\n#endif\n\n#define QNEG_TCOPY\t\tqneg_tcopy\n#define QLASWP_NCOPY\t\tqlaswp_ncopy\n\n#else\n\n#define\tQAMAX_K\t\t\tgotoblas -> qamax_k\n#define\tQAMIN_K\t\t\tgotoblas -> qamin_k\n#define\tQMAX_K\t\t\tgotoblas -> qmax_k\n#define\tQMIN_K\t\t\tgotoblas -> qmin_k\n#define\tIQAMAX_K\t\tgotoblas -> iqamax_k\n#define\tIQAMIN_K\t\tgotoblas -> iqamin_k\n#define\tIQMAX_K\t\t\tgotoblas -> iqmax_k\n#define\tIQMIN_K\t\t\tgotoblas -> iqmin_k\n#define\tQASUM_K\t\t\tgotoblas -> qasum_k\n#define\tQAXPYU_K\t\tgotoblas -> qaxpy_k\n#define\tQAXPYC_K\t\tgotoblas -> qaxpy_k\n#define\tQCOPY_K\t\t\tgotoblas -> qcopy_k\n#define\tQDOTU_K\t\t\tgotoblas -> qdot_k\n#define\tQDOTC_K\t\t\tgotoblas -> qdot_k\n#define\tQNRM2_K\t\t\tgotoblas -> qnrm2_k\n#define\tQSCAL_K\t\t\tgotoblas -> qscal_k\n#define\tQSUM_K\t\t\tgotoblas -> qsum_k\n#define\tQSWAP_K\t\t\tgotoblas -> qswap_k\n#define\tQROT_K\t\t\tgotoblas -> qrot_k\n\n#define\tQGEMV_N\t\t\tgotoblas -> qgemv_n\n#define\tQGEMV_T\t\t\tgotoblas -> qgemv_t\n#define\tQGEMV_R\t\t\tgotoblas -> qgemv_n\n#define\tQGEMV_C\t\t\tgotoblas -> qgemv_t\n#define\tQGEMV_O\t\t\tgotoblas -> qgemv_n\n#define\tQGEMV_U\t\t\tgotoblas -> qgemv_t\n#define\tQGEMV_S\t\t\tgotoblas -> qgemv_n\n#define\tQGEMV_D\t\t\tgotoblas -> qgemv_t\n\n#define\tQGERU_K\t\t\tgotoblas -> qger_k\n#define\tQGERC_K\t\t\tgotoblas -> qger_k\n#define\tQGERV_K\t\t\tgotoblas -> qger_k\n#define\tQGERD_K\t\t\tgotoblas -> qger_k\n\n#define QSYMV_U\t\t\tgotoblas -> qsymv_U\n#define QSYMV_L\t\t\tgotoblas -> qsymv_L\n\n#define QSYMV_THREAD_U\t\tqsymv_thread_U\n#define QSYMV_THREAD_L\t\tqsymv_thread_L\n\n#define\tQGEMM_ONCOPY\t\tgotoblas -> qgemm_oncopy\n#define\tQGEMM_OTCOPY\t\tgotoblas -> qgemm_otcopy\n#define\tQGEMM_INCOPY\t\tgotoblas -> qgemm_incopy\n#define\tQGEMM_ITCOPY\t\tgotoblas -> qgemm_itcopy\n\n#define\tQTRMM_OUNUCOPY\t\tgotoblas -> qtrmm_ounucopy\n#define\tQTRMM_OUTUCOPY\t\tgotoblas -> qtrmm_outucopy\n#define\tQTRMM_OLNUCOPY\t\tgotoblas -> qtrmm_olnucopy\n#define\tQTRMM_OLTUCOPY\t\tgotoblas -> qtrmm_oltucopy\n#define\tQTRSM_OUNUCOPY\t\tgotoblas -> qtrsm_ounucopy\n#define\tQTRSM_OUTUCOPY\t\tgotoblas -> qtrsm_outucopy\n#define\tQTRSM_OLNUCOPY\t\tgotoblas -> qtrsm_olnucopy\n#define\tQTRSM_OLTUCOPY\t\tgotoblas -> qtrsm_oltucopy\n\n#define\tQTRMM_IUNUCOPY\t\tgotoblas -> qtrmm_iunucopy\n#define\tQTRMM_IUTUCOPY\t\tgotoblas -> qtrmm_iutucopy\n#define\tQTRMM_ILNUCOPY\t\tgotoblas -> qtrmm_ilnucopy\n#define\tQTRMM_ILTUCOPY\t\tgotoblas -> qtrmm_iltucopy\n#define\tQTRSM_IUNUCOPY\t\tgotoblas -> qtrsm_iunucopy\n#define\tQTRSM_IUTUCOPY\t\tgotoblas -> qtrsm_iutucopy\n#define\tQTRSM_ILNUCOPY\t\tgotoblas -> qtrsm_ilnucopy\n#define\tQTRSM_ILTUCOPY\t\tgotoblas -> qtrsm_iltucopy\n\n#define\tQTRMM_OUNNCOPY\t\tgotoblas -> qtrmm_ounncopy\n#define\tQTRMM_OUTNCOPY\t\tgotoblas -> qtrmm_outncopy\n#define\tQTRMM_OLNNCOPY\t\tgotoblas -> qtrmm_olnncopy\n#define\tQTRMM_OLTNCOPY\t\tgotoblas -> qtrmm_oltncopy\n#define\tQTRSM_OUNNCOPY\t\tgotoblas -> qtrsm_ounncopy\n#define\tQTRSM_OUTNCOPY\t\tgotoblas -> qtrsm_outncopy\n#define\tQTRSM_OLNNCOPY\t\tgotoblas -> qtrsm_olnncopy\n#define\tQTRSM_OLTNCOPY\t\tgotoblas -> qtrsm_oltncopy\n\n#define\tQTRMM_IUNNCOPY\t\tgotoblas -> qtrmm_iunncopy\n#define\tQTRMM_IUTNCOPY\t\tgotoblas -> qtrmm_iutncopy\n#define\tQTRMM_ILNNCOPY\t\tgotoblas -> qtrmm_ilnncopy\n#define\tQTRMM_ILTNCOPY\t\tgotoblas -> qtrmm_iltncopy\n#define\tQTRSM_IUNNCOPY\t\tgotoblas -> qtrsm_iunncopy\n#define\tQTRSM_IUTNCOPY\t\tgotoblas -> qtrsm_iutncopy\n#define\tQTRSM_ILNNCOPY\t\tgotoblas -> qtrsm_ilnncopy\n#define\tQTRSM_ILTNCOPY\t\tgotoblas -> qtrsm_iltncopy\n\n#define\tQGEMM_BETA\t\tgotoblas -> qgemm_beta\n#define\tQGEMM_KERNEL\t\tgotoblas -> qgemm_kernel\n\n#define\tQTRMM_KERNEL_LN\t\tgotoblas -> qtrmm_kernel_LN\n#define\tQTRMM_KERNEL_LT\t\tgotoblas -> qtrmm_kernel_LT\n#define\tQTRMM_KERNEL_LR\t\tgotoblas -> qtrmm_kernel_LN\n#define\tQTRMM_KERNEL_LC\t\tgotoblas -> qtrmm_kernel_LT\n#define\tQTRMM_KERNEL_RN\t\tgotoblas -> qtrmm_kernel_RN\n#define\tQTRMM_KERNEL_RT\t\tgotoblas -> qtrmm_kernel_RT\n#define\tQTRMM_KERNEL_RR\t\tgotoblas -> qtrmm_kernel_RN\n#define\tQTRMM_KERNEL_RC\t\tgotoblas -> qtrmm_kernel_RT\n\n#define\tQTRSM_KERNEL_LN\t\tgotoblas -> qtrsm_kernel_LN\n#define\tQTRSM_KERNEL_LT\t\tgotoblas -> qtrsm_kernel_LT\n#define\tQTRSM_KERNEL_LR\t\tgotoblas -> qtrsm_kernel_LN\n#define\tQTRSM_KERNEL_LC\t\tgotoblas -> qtrsm_kernel_LT\n#define\tQTRSM_KERNEL_RN\t\tgotoblas -> qtrsm_kernel_RN\n#define\tQTRSM_KERNEL_RT\t\tgotoblas -> qtrsm_kernel_RT\n#define\tQTRSM_KERNEL_RR\t\tgotoblas -> qtrsm_kernel_RN\n#define\tQTRSM_KERNEL_RC\t\tgotoblas -> qtrsm_kernel_RT\n\n#define\tQSYMM_IUTCOPY\t\tgotoblas -> qsymm_iutcopy\n#define\tQSYMM_ILTCOPY\t\tgotoblas -> qsymm_iltcopy\n#define\tQSYMM_OUTCOPY\t\tgotoblas -> qsymm_outcopy\n#define\tQSYMM_OLTCOPY\t\tgotoblas -> qsymm_oltcopy\n\n#define QNEG_TCOPY\t\tgotoblas -> qneg_tcopy\n#define QLASWP_NCOPY\t\tgotoblas -> qlaswp_ncopy\n\n#endif\n\n#define\tQGEMM_NN\t\tqgemm_nn\n#define\tQGEMM_CN\t\tqgemm_tn\n#define\tQGEMM_TN\t\tqgemm_tn\n#define\tQGEMM_NC\t\tqgemm_nt\n#define\tQGEMM_NT\t\tqgemm_nt\n#define\tQGEMM_CC\t\tqgemm_tt\n#define\tQGEMM_CT\t\tqgemm_tt\n#define\tQGEMM_TC\t\tqgemm_tt\n#define\tQGEMM_TT\t\tqgemm_tt\n#define\tQGEMM_NR\t\tqgemm_nn\n#define\tQGEMM_TR\t\tqgemm_tn\n#define\tQGEMM_CR\t\tqgemm_tn\n#define\tQGEMM_RN\t\tqgemm_nn\n#define\tQGEMM_RT\t\tqgemm_nt\n#define\tQGEMM_RC\t\tqgemm_nt\n#define\tQGEMM_RR\t\tqgemm_nn\n\n#define\tQSYMM_LU\t\tqsymm_LU\n#define\tQSYMM_LL\t\tqsymm_LL\n#define\tQSYMM_RU\t\tqsymm_RU\n#define\tQSYMM_RL\t\tqsymm_RL\n\n#define\tQHEMM_LU\t\tqhemm_LU\n#define\tQHEMM_LL\t\tqhemm_LL\n#define\tQHEMM_RU\t\tqhemm_RU\n#define\tQHEMM_RL\t\tqhemm_RL\n\n#define\tQSYRK_UN\t\tqsyrk_UN\n#define\tQSYRK_UT\t\tqsyrk_UT\n#define\tQSYRK_LN\t\tqsyrk_LN\n#define\tQSYRK_LT\t\tqsyrk_LT\n#define\tQSYRK_UR\t\tqsyrk_UN\n#define\tQSYRK_UC\t\tqsyrk_UT\n#define\tQSYRK_LR\t\tqsyrk_LN\n#define\tQSYRK_LC\t\tqsyrk_LT\n\n#define\tQSYRK_KERNEL_U\t\tqsyrk_kernel_U\n#define\tQSYRK_KERNEL_L\t\tqsyrk_kernel_L\n\n#define\tQHERK_UN\t\tqsyrk_UN\n#define\tQHERK_LN\t\tqsyrk_LN\n#define\tQHERK_UC\t\tqsyrk_UT\n#define\tQHERK_LC\t\tqsyrk_LT\n\n#define\tQHER2K_UN\t\tqsyr2k_UN\n#define\tQHER2K_LN\t\tqsyr2k_LN\n#define\tQHER2K_UC\t\tqsyr2k_UT\n#define\tQHER2K_LC\t\tqsyr2k_LT\n\n#define\tQSYR2K_UN\t\tqsyr2k_UN\n#define\tQSYR2K_UT\t\tqsyr2k_UT\n#define\tQSYR2K_LN\t\tqsyr2k_LN\n#define\tQSYR2K_LT\t\tqsyr2k_LT\n#define\tQSYR2K_UR\t\tqsyr2k_UN\n#define\tQSYR2K_UC\t\tqsyr2k_UT\n#define\tQSYR2K_LR\t\tqsyr2k_LN\n#define\tQSYR2K_LC\t\tqsyr2k_LT\n\n#define\tQSYR2K_KERNEL_U\t\tqsyr2k_kernel_U\n#define\tQSYR2K_KERNEL_L\t\tqsyr2k_kernel_L\n\n#define\tQTRMM_LNUU\t\tqtrmm_LNUU\n#define\tQTRMM_LNUN\t\tqtrmm_LNUN\n#define\tQTRMM_LNLU\t\tqtrmm_LNLU\n#define\tQTRMM_LNLN\t\tqtrmm_LNLN\n#define\tQTRMM_LTUU\t\tqtrmm_LTUU\n#define\tQTRMM_LTUN\t\tqtrmm_LTUN\n#define\tQTRMM_LTLU\t\tqtrmm_LTLU\n#define\tQTRMM_LTLN\t\tqtrmm_LTLN\n#define\tQTRMM_LRUU\t\tqtrmm_LNUU\n#define\tQTRMM_LRUN\t\tqtrmm_LNUN\n#define\tQTRMM_LRLU\t\tqtrmm_LNLU\n#define\tQTRMM_LRLN\t\tqtrmm_LNLN\n#define\tQTRMM_LCUU\t\tqtrmm_LTUU\n#define\tQTRMM_LCUN\t\tqtrmm_LTUN\n#define\tQTRMM_LCLU\t\tqtrmm_LTLU\n#define\tQTRMM_LCLN\t\tqtrmm_LTLN\n#define\tQTRMM_RNUU\t\tqtrmm_RNUU\n#define\tQTRMM_RNUN\t\tqtrmm_RNUN\n#define\tQTRMM_RNLU\t\tqtrmm_RNLU\n#define\tQTRMM_RNLN\t\tqtrmm_RNLN\n#define\tQTRMM_RTUU\t\tqtrmm_RTUU\n#define\tQTRMM_RTUN\t\tqtrmm_RTUN\n#define\tQTRMM_RTLU\t\tqtrmm_RTLU\n#define\tQTRMM_RTLN\t\tqtrmm_RTLN\n#define\tQTRMM_RRUU\t\tqtrmm_RNUU\n#define\tQTRMM_RRUN\t\tqtrmm_RNUN\n#define\tQTRMM_RRLU\t\tqtrmm_RNLU\n#define\tQTRMM_RRLN\t\tqtrmm_RNLN\n#define\tQTRMM_RCUU\t\tqtrmm_RTUU\n#define\tQTRMM_RCUN\t\tqtrmm_RTUN\n#define\tQTRMM_RCLU\t\tqtrmm_RTLU\n#define\tQTRMM_RCLN\t\tqtrmm_RTLN\n\n#define\tQTRSM_LNUU\t\tqtrsm_LNUU\n#define\tQTRSM_LNUN\t\tqtrsm_LNUN\n#define\tQTRSM_LNLU\t\tqtrsm_LNLU\n#define\tQTRSM_LNLN\t\tqtrsm_LNLN\n#define\tQTRSM_LTUU\t\tqtrsm_LTUU\n#define\tQTRSM_LTUN\t\tqtrsm_LTUN\n#define\tQTRSM_LTLU\t\tqtrsm_LTLU\n#define\tQTRSM_LTLN\t\tqtrsm_LTLN\n#define\tQTRSM_LRUU\t\tqtrsm_LNUU\n#define\tQTRSM_LRUN\t\tqtrsm_LNUN\n#define\tQTRSM_LRLU\t\tqtrsm_LNLU\n#define\tQTRSM_LRLN\t\tqtrsm_LNLN\n#define\tQTRSM_LCUU\t\tqtrsm_LTUU\n#define\tQTRSM_LCUN\t\tqtrsm_LTUN\n#define\tQTRSM_LCLU\t\tqtrsm_LTLU\n#define\tQTRSM_LCLN\t\tqtrsm_LTLN\n#define\tQTRSM_RNUU\t\tqtrsm_RNUU\n#define\tQTRSM_RNUN\t\tqtrsm_RNUN\n#define\tQTRSM_RNLU\t\tqtrsm_RNLU\n#define\tQTRSM_RNLN\t\tqtrsm_RNLN\n#define\tQTRSM_RTUU\t\tqtrsm_RTUU\n#define\tQTRSM_RTUN\t\tqtrsm_RTUN\n#define\tQTRSM_RTLU\t\tqtrsm_RTLU\n#define\tQTRSM_RTLN\t\tqtrsm_RTLN\n#define\tQTRSM_RRUU\t\tqtrsm_RNUU\n#define\tQTRSM_RRUN\t\tqtrsm_RNUN\n#define\tQTRSM_RRLU\t\tqtrsm_RNLU\n#define\tQTRSM_RRLN\t\tqtrsm_RNLN\n#define\tQTRSM_RCUU\t\tqtrsm_RTUU\n#define\tQTRSM_RCUN\t\tqtrsm_RTUN\n#define\tQTRSM_RCLU\t\tqtrsm_RTLU\n#define\tQTRSM_RCLN\t\tqtrsm_RTLN\n\n#define\tQGEMM_THREAD_NN\t\tqgemm_thread_nn\n#define\tQGEMM_THREAD_CN\t\tqgemm_thread_tn\n#define\tQGEMM_THREAD_TN\t\tqgemm_thread_tn\n#define\tQGEMM_THREAD_NC\t\tqgemm_thread_nt\n#define\tQGEMM_THREAD_NT\t\tqgemm_thread_nt\n#define\tQGEMM_THREAD_CC\t\tqgemm_thread_tt\n#define\tQGEMM_THREAD_CT\t\tqgemm_thread_tt\n#define\tQGEMM_THREAD_TC\t\tqgemm_thread_tt\n#define\tQGEMM_THREAD_TT\t\tqgemm_thread_tt\n#define\tQGEMM_THREAD_NR\t\tqgemm_thread_nn\n#define\tQGEMM_THREAD_TR\t\tqgemm_thread_tn\n#define\tQGEMM_THREAD_CR\t\tqgemm_thread_tn\n#define\tQGEMM_THREAD_RN\t\tqgemm_thread_nn\n#define\tQGEMM_THREAD_RT\t\tqgemm_thread_nt\n#define\tQGEMM_THREAD_RC\t\tqgemm_thread_nt\n#define\tQGEMM_THREAD_RR\t\tqgemm_thread_nn\n\n#define\tQSYMM_THREAD_LU\t\tqsymm_thread_LU\n#define\tQSYMM_THREAD_LL\t\tqsymm_thread_LL\n#define\tQSYMM_THREAD_RU\t\tqsymm_thread_RU\n#define\tQSYMM_THREAD_RL\t\tqsymm_thread_RL\n\n#define\tQHEMM_THREAD_LU\t\tqhemm_thread_LU\n#define\tQHEMM_THREAD_LL\t\tqhemm_thread_LL\n#define\tQHEMM_THREAD_RU\t\tqhemm_thread_RU\n#define\tQHEMM_THREAD_RL\t\tqhemm_thread_RL\n\n#define\tQSYRK_THREAD_UN\t\tqsyrk_thread_UN\n#define\tQSYRK_THREAD_UT\t\tqsyrk_thread_UT\n#define\tQSYRK_THREAD_LN\t\tqsyrk_thread_LN\n#define\tQSYRK_THREAD_LT\t\tqsyrk_thread_LT\n#define\tQSYRK_THREAD_UR\t\tqsyrk_thread_UN\n#define\tQSYRK_THREAD_UC\t\tqsyrk_thread_UT\n#define\tQSYRK_THREAD_LR\t\tqsyrk_thread_LN\n#define\tQSYRK_THREAD_LC\t\tqsyrk_thread_LT\n\n#define\tQHERK_THREAD_UN\t\tqsyrk_thread_UN\n#define\tQHERK_THREAD_UT\t\tqsyrk_thread_UT\n#define\tQHERK_THREAD_LN\t\tqsyrk_thread_LN\n#define\tQHERK_THREAD_LT\t\tqsyrk_thread_LT\n#define\tQHERK_THREAD_UR\t\tqsyrk_thread_UN\n#define\tQHERK_THREAD_UC\t\tqsyrk_thread_UT\n#define\tQHERK_THREAD_LR\t\tqsyrk_thread_LN\n#define\tQHERK_THREAD_LC\t\tqsyrk_thread_LT\n\n#endif\n"
        },
        {
          "name": "common_reference.h",
          "type": "blob",
          "size": 3.8642578125,
          "content": "/*****************************************************************************\nCopyright (c) 2011-2014, The OpenBLAS Project\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   1. Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n\n   2. Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in\n      the documentation and/or other materials provided with the\n      distribution.\n   3. Neither the name of the OpenBLAS project nor the names of \n      its contributors may be used to endorse or promote products \n      derived from this software without specific prior written \n      permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\nUSE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n**********************************************************************************/\n#ifndef ASSEMBLER\n\n#define REF_BU f\n#define BLASFUNC_REF_2(x,y) BLASFUNC(x## y)\n#define BLASFUNC_REF_1(x,y) BLASFUNC_REF_2(x,y)\n#define BLASFUNC_REF(x) BLASFUNC_REF_1(x,REF_BU)\n\nvoid  BLASFUNC_REF(srot)  (blasint *, float  *, blasint *, float  *, blasint *, float  *, float  *);\nvoid  BLASFUNC_REF(drot)  (blasint *, double *, blasint *, double *, blasint *, double *, double *);\nvoid  BLASFUNC_REF(qrot)  (blasint *, xdouble *, blasint *, xdouble *, blasint *, xdouble *, xdouble *);\nvoid  BLASFUNC_REF(csrot) (blasint *, float  *, blasint *, float  *, blasint *, float  *, float  *);\nvoid  BLASFUNC_REF(zdrot) (blasint *, double *, blasint *, double *, blasint *, double *, double *);\nvoid  BLASFUNC_REF(xqrot) (blasint *, xdouble *, blasint *, xdouble *, blasint *, xdouble *, xdouble *);\n\nvoid BLASFUNC_REF(sswap) (blasint *, float  *, blasint *, float  *, blasint *);\nvoid BLASFUNC_REF(dswap) (blasint *, double *, blasint *, double *, blasint *);\nvoid BLASFUNC_REF(qswap) (blasint *, xdouble *, blasint *, xdouble *, blasint *);\nvoid BLASFUNC_REF(cswap) (blasint *, float  *, blasint *, float  *, blasint *);\nvoid BLASFUNC_REF(zswap) (blasint *, double *, blasint *, double *, blasint *);\nvoid BLASFUNC_REF(xswap) (blasint *, xdouble *, blasint *, xdouble *, blasint *);\n\nvoid BLASFUNC_REF(saxpy) (blasint *, float  *, float  *, blasint *, float  *, blasint *);\nvoid BLASFUNC_REF(daxpy) (blasint *, double *, double *, blasint *, double *, blasint *);\nvoid BLASFUNC_REF(caxpy) (blasint *, float  *, float  *, blasint *, float  *, blasint *);\nvoid BLASFUNC_REF(zaxpy) (blasint *, double *, double *, blasint *, double *, blasint *);\n\nfloat   _Complex BLASFUNC_REF(cdotu)  (blasint *, float  *, blasint *, float  *, blasint *);\nfloat   _Complex BLASFUNC_REF(cdotc)  (blasint *, float  *, blasint *, float  *, blasint *);\ndouble  _Complex BLASFUNC_REF(zdotu)  (blasint *, double  *, blasint *, double  *, blasint *);\ndouble  _Complex BLASFUNC_REF(zdotc)  (blasint *, double  *, blasint *, double  *, blasint *);\n\nvoid BLASFUNC_REF(drotmg)(double *, double *, double *, double *, double *);\n\ndouble BLASFUNC_REF(dsdot)(blasint *, float *, blasint *, float *, blasint*);\n\nFLOATRET  BLASFUNC_REF(samax) (blasint *, float  *, blasint *);\n\n#endif\n"
        },
        {
          "name": "common_riscv64.h",
          "type": "blob",
          "size": 5.2158203125,
          "content": "/*****************************************************************************\nCopyright (c) 2011-2014, The OpenBLAS Project\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   1. Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n\n   2. Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in\n      the documentation and/or other materials provided with the\n      distribution.\n   3. Neither the name of the OpenBLAS project nor the names of \n      its contributors may be used to endorse or promote products \n      derived from this software without specific prior written \n      permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\nUSE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n**********************************************************************************/\n\n/*********************************************************************/\n/* Copyright 2009, 2010 The University of Texas at Austin.           */\n/* All rights reserved.                                              */\n/*                                                                   */\n/* Redistribution and use in source and binary forms, with or        */\n/* without modification, are permitted provided that the following   */\n/* conditions are met:                                               */\n/*                                                                   */\n/*   1. Redistributions of source code must retain the above         */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer.                                                  */\n/*                                                                   */\n/*   2. Redistributions in binary form must reproduce the above      */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer in the documentation and/or other materials       */\n/*      provided with the distribution.                              */\n/*                                                                   */\n/*    THIS  SOFTWARE IS PROVIDED  BY THE  UNIVERSITY OF  TEXAS AT    */\n/*    AUSTIN  ``AS IS''  AND ANY  EXPRESS OR  IMPLIED WARRANTIES,    */\n/*    INCLUDING, BUT  NOT LIMITED  TO, THE IMPLIED  WARRANTIES OF    */\n/*    MERCHANTABILITY  AND FITNESS FOR  A PARTICULAR  PURPOSE ARE    */\n/*    DISCLAIMED.  IN  NO EVENT SHALL THE UNIVERSITY  OF TEXAS AT    */\n/*    AUSTIN OR CONTRIBUTORS BE  LIABLE FOR ANY DIRECT, INDIRECT,    */\n/*    INCIDENTAL,  SPECIAL, EXEMPLARY,  OR  CONSEQUENTIAL DAMAGES    */\n/*    (INCLUDING, BUT  NOT LIMITED TO,  PROCUREMENT OF SUBSTITUTE    */\n/*    GOODS  OR  SERVICES; LOSS  OF  USE,  DATA,  OR PROFITS;  OR    */\n/*    BUSINESS INTERRUPTION) HOWEVER CAUSED  AND ON ANY THEORY OF    */\n/*    LIABILITY, WHETHER  IN CONTRACT, STRICT  LIABILITY, OR TORT    */\n/*    (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY WAY OUT    */\n/*    OF  THE  USE OF  THIS  SOFTWARE,  EVEN  IF ADVISED  OF  THE    */\n/*    POSSIBILITY OF SUCH DAMAGE.                                    */\n/*                                                                   */\n/* The views and conclusions contained in the software and           */\n/* documentation are those of the authors and should not be          */\n/* interpreted as representing official policies, either expressed   */\n/* or implied, of The University of Texas at Austin.                 */\n/*********************************************************************/\n\n#ifndef COMMON_RISCV64\n#define COMMON_RISCV64\n\n#define MB  __sync_synchronize()\n#define WMB __sync_synchronize()\n#define RMB __sync_synchronize()\n\n#ifndef ASSEMBLER\n\n\nstatic inline int blas_quickdivide(blasint x, blasint y){\n  return x / y;\n}\n\n#endif\n\n\n\n#define BUFFER_SIZE     ( 32 << 20)\n#define SEEK_ADDRESS\n\n#if defined(C910V) || defined(RISCV64_ZVL256B) || defined(RISCV64_ZVL128B) || defined(x280)\n# include <riscv_vector.h>\n#endif\n\n#if defined( __riscv_xtheadc ) && defined( __riscv_v ) && ( __riscv_v <= 7000 )\n// t-head toolchain uses obsolete rvv intrinsics, can't build for C910V without this\n#define RISCV_0p10_INTRINSICS\n#define RISCV_RVV(x) x\n#else\n#define RISCV_RVV(x) __riscv_ ## x\n#endif\n\n#if defined(C910V) || defined(RISCV64_ZVL256B)\n# if !defined(DOUBLE)\n#  define EXTRACT_FLOAT(v) RISCV_RVV(vfmv_f_s_f32m1_f32)(v)\n# else\n#  define EXTRACT_FLOAT(v) RISCV_RVV(vfmv_f_s_f64m1_f64)(v)\n# endif\n#else\n# define EXTRACT_FLOAT(v) (v[0])\n#endif\n\n#endif\n"
        },
        {
          "name": "common_s.h",
          "type": "blob",
          "size": 15.6357421875,
          "content": "#ifndef COMMON_S_H\n#define COMMON_S_H\n\n#ifndef DYNAMIC_ARCH\n\n#define\tSAMAX_K\t\t\tsamax_k\n#define\tSAMIN_K\t\t\tsamin_k\n#define\tSMAX_K\t\t\tsmax_k\n#define\tSMIN_K\t\t\tsmin_k\n#define\tISAMAX_K\t\tisamax_k\n#define\tISAMIN_K\t\tisamin_k\n#define\tISMAX_K\t\t\tismax_k\n#define\tISMIN_K\t\t\tismin_k\n#define\tSASUM_K\t\t\tsasum_k\n#define\tSSUM_K\t\t\tssum_k\n#define\tSAXPYU_K\t\tsaxpy_k\n#define\tSAXPYC_K\t\tsaxpy_k\n#define\tSCOPY_K\t\t\tscopy_k\n#define\tSDOTU_K\t\t\tsdot_k\n#define\tSDOTC_K\t\t\tsdot_k\n#define\tSDSDOT_K\t\tdsdot_k\n#define\tDSDOT_K\t\t\tdsdot_k\n#define\tSNRM2_K\t\t\tsnrm2_k\n#define\tSSCAL_K\t\t\tsscal_k\n#define\tSSWAP_K\t\t\tsswap_k\n#define\tSROT_K\t\t\tsrot_k\n\n#define\tSGEMV_N\t\t\tsgemv_n\n#define\tSGEMV_T\t\t\tsgemv_t\n#define\tSGEMV_R\t\t\tsgemv_n\n#define\tSGEMV_C\t\t\tsgemv_t\n#define\tSGEMV_O\t\t\tsgemv_n\n#define\tSGEMV_U\t\t\tsgemv_t\n#define\tSGEMV_S\t\t\tsgemv_n\n#define\tSGEMV_D\t\t\tsgemv_t\n\n#define\tSGERU_K\t\t\tsger_k\n#define\tSGERC_K\t\t\tsger_k\n#define\tSGERV_K\t\t\tsger_k\n#define\tSGERD_K\t\t\tsger_k\n\n#define SSYMV_U\t\t\tssymv_U\n#define SSYMV_L\t\t\tssymv_L\n\n#define SSYMV_THREAD_U\t\tssymv_thread_U\n#define SSYMV_THREAD_L\t\tssymv_thread_L\n\n\n#define SGEMM_DIRECT_PERFORMANT    sgemm_direct_performant\n#define SGEMM_DIRECT\t\tsgemm_direct\n\n#define\tSGEMM_ONCOPY\t\tsgemm_oncopy\n#define\tSGEMM_OTCOPY\t\tsgemm_otcopy\n\n#if SGEMM_DEFAULT_UNROLL_M == SGEMM_DEFAULT_UNROLL_N\n#define\tSGEMM_INCOPY\t\tsgemm_oncopy\n#define\tSGEMM_ITCOPY\t\tsgemm_otcopy\n#else\n#define\tSGEMM_INCOPY\t\tsgemm_incopy\n#define\tSGEMM_ITCOPY\t\tsgemm_itcopy\n#endif\n\n#define\tSTRMM_OUNUCOPY\t\tstrmm_ounucopy\n#define\tSTRMM_OUNNCOPY\t\tstrmm_ounncopy\n#define\tSTRMM_OUTUCOPY\t\tstrmm_outucopy\n#define\tSTRMM_OUTNCOPY\t\tstrmm_outncopy\n#define\tSTRMM_OLNUCOPY\t\tstrmm_olnucopy\n#define\tSTRMM_OLNNCOPY\t\tstrmm_olnncopy\n#define\tSTRMM_OLTUCOPY\t\tstrmm_oltucopy\n#define\tSTRMM_OLTNCOPY\t\tstrmm_oltncopy\n\n#define\tSTRSM_OUNUCOPY\t\tstrsm_ounucopy\n#define\tSTRSM_OUNNCOPY\t\tstrsm_ounncopy\n#define\tSTRSM_OUTUCOPY\t\tstrsm_outucopy\n#define\tSTRSM_OUTNCOPY\t\tstrsm_outncopy\n#define\tSTRSM_OLNUCOPY\t\tstrsm_olnucopy\n#define\tSTRSM_OLNNCOPY\t\tstrsm_olnncopy\n#define\tSTRSM_OLTUCOPY\t\tstrsm_oltucopy\n#define\tSTRSM_OLTNCOPY\t\tstrsm_oltncopy\n\n#if SGEMM_DEFAULT_UNROLL_M == SGEMM_DEFAULT_UNROLL_N\n#define\tSTRMM_IUNUCOPY\t\tstrmm_ounucopy\n#define\tSTRMM_IUNNCOPY\t\tstrmm_ounncopy\n#define\tSTRMM_IUTUCOPY\t\tstrmm_outucopy\n#define\tSTRMM_IUTNCOPY\t\tstrmm_outncopy\n#define\tSTRMM_ILNUCOPY\t\tstrmm_olnucopy\n#define\tSTRMM_ILNNCOPY\t\tstrmm_olnncopy\n#define\tSTRMM_ILTUCOPY\t\tstrmm_oltucopy\n#define\tSTRMM_ILTNCOPY\t\tstrmm_oltncopy\n\n#define\tSTRSM_IUNUCOPY\t\tstrsm_ounucopy\n#define\tSTRSM_IUNNCOPY\t\tstrsm_ounncopy\n#define\tSTRSM_IUTUCOPY\t\tstrsm_outucopy\n#define\tSTRSM_IUTNCOPY\t\tstrsm_outncopy\n#define\tSTRSM_ILNUCOPY\t\tstrsm_olnucopy\n#define\tSTRSM_ILNNCOPY\t\tstrsm_olnncopy\n#define\tSTRSM_ILTUCOPY\t\tstrsm_oltucopy\n#define\tSTRSM_ILTNCOPY\t\tstrsm_oltncopy\n#else\n#define\tSTRMM_IUNUCOPY\t\tstrmm_iunucopy\n#define\tSTRMM_IUNNCOPY\t\tstrmm_iunncopy\n#define\tSTRMM_IUTUCOPY\t\tstrmm_iutucopy\n#define\tSTRMM_IUTNCOPY\t\tstrmm_iutncopy\n#define\tSTRMM_ILNUCOPY\t\tstrmm_ilnucopy\n#define\tSTRMM_ILNNCOPY\t\tstrmm_ilnncopy\n#define\tSTRMM_ILTUCOPY\t\tstrmm_iltucopy\n#define\tSTRMM_ILTNCOPY\t\tstrmm_iltncopy\n\n#define\tSTRSM_IUNUCOPY\t\tstrsm_iunucopy\n#define\tSTRSM_IUNNCOPY\t\tstrsm_iunncopy\n#define\tSTRSM_IUTUCOPY\t\tstrsm_iutucopy\n#define\tSTRSM_IUTNCOPY\t\tstrsm_iutncopy\n#define\tSTRSM_ILNUCOPY\t\tstrsm_ilnucopy\n#define\tSTRSM_ILNNCOPY\t\tstrsm_ilnncopy\n#define\tSTRSM_ILTUCOPY\t\tstrsm_iltucopy\n#define\tSTRSM_ILTNCOPY\t\tstrsm_iltncopy\n#endif\n\n#define\tSGEMM_BETA\t\tsgemm_beta\n\n#define\tSGEMM_KERNEL\t\tsgemm_kernel\n\n#define\tSTRMM_KERNEL_LN\t\tstrmm_kernel_LN\n#define\tSTRMM_KERNEL_LT\t\tstrmm_kernel_LT\n#define\tSTRMM_KERNEL_LR\t\tstrmm_kernel_LN\n#define\tSTRMM_KERNEL_LC\t\tstrmm_kernel_LT\n#define\tSTRMM_KERNEL_RN\t\tstrmm_kernel_RN\n#define\tSTRMM_KERNEL_RT\t\tstrmm_kernel_RT\n#define\tSTRMM_KERNEL_RR\t\tstrmm_kernel_RN\n#define\tSTRMM_KERNEL_RC\t\tstrmm_kernel_RT\n\n#define\tSTRSM_KERNEL_LN\t\tstrsm_kernel_LN\n#define\tSTRSM_KERNEL_LT\t\tstrsm_kernel_LT\n#define\tSTRSM_KERNEL_LR\t\tstrsm_kernel_LN\n#define\tSTRSM_KERNEL_LC\t\tstrsm_kernel_LT\n#define\tSTRSM_KERNEL_RN\t\tstrsm_kernel_RN\n#define\tSTRSM_KERNEL_RT\t\tstrsm_kernel_RT\n#define\tSTRSM_KERNEL_RR\t\tstrsm_kernel_RN\n#define\tSTRSM_KERNEL_RC\t\tstrsm_kernel_RT\n\n#define\tSSYMM_OUTCOPY\t\tssymm_outcopy\n#define\tSSYMM_OLTCOPY\t\tssymm_oltcopy\n#if SGEMM_DEFAULT_UNROLL_M == SGEMM_DEFAULT_UNROLL_N\n#define\tSSYMM_IUTCOPY\t\tssymm_outcopy\n#define\tSSYMM_ILTCOPY\t\tssymm_oltcopy\n#else\n#define\tSSYMM_IUTCOPY\t\tssymm_iutcopy\n#define\tSSYMM_ILTCOPY\t\tssymm_iltcopy\n#endif\n\n#define SNEG_TCOPY\t\tsneg_tcopy\n#define SLASWP_NCOPY\t\tslaswp_ncopy\n\n#define SAXPBY_K                saxpby_k\n\n#define SOMATCOPY_K_CN          somatcopy_k_cn\n#define SOMATCOPY_K_RN          somatcopy_k_rn\n#define SOMATCOPY_K_CT          somatcopy_k_ct\n#define SOMATCOPY_K_RT          somatcopy_k_rt\n#define SIMATCOPY_K_CN          simatcopy_k_cn\n#define SIMATCOPY_K_RN          simatcopy_k_rn\n#define SIMATCOPY_K_CT          simatcopy_k_ct\n#define SIMATCOPY_K_RT          simatcopy_k_rt\n\n#define SGEADD_K                sgeadd_k \n\n#define SGEMM_SMALL_MATRIX_PERMIT\tsgemm_small_matrix_permit\n\n#else\n\n#define\tSAMAX_K\t\t\tgotoblas -> samax_k\n#define\tSAMIN_K\t\t\tgotoblas -> samin_k\n#define\tSMAX_K\t\t\tgotoblas -> smax_k\n#define\tSMIN_K\t\t\tgotoblas -> smin_k\n#define\tISAMAX_K\t\tgotoblas -> isamax_k\n#define\tISAMIN_K\t\tgotoblas -> isamin_k\n#define\tISMAX_K\t\t\tgotoblas -> ismax_k\n#define\tISMIN_K\t\t\tgotoblas -> ismin_k\n#define\tSASUM_K\t\t\tgotoblas -> sasum_k\n#define\tSSUM_K\t\t\tgotoblas -> ssum_k\n#define\tSAXPYU_K\t\tgotoblas -> saxpy_k\n#define\tSAXPYC_K\t\tgotoblas -> saxpy_k\n#define\tSCOPY_K\t\t\tgotoblas -> scopy_k\n#define\tSDOTU_K\t\t\tgotoblas -> sdot_k\n#define\tSDOTC_K\t\t\tgotoblas -> sdot_k\n#define\tSDSDOT_K\t\tgotoblas -> dsdot_k\n#define\tDSDOT_K\t\t\tgotoblas -> dsdot_k\n#define\tSNRM2_K\t\t\tgotoblas -> snrm2_k\n#define\tSSCAL_K\t\t\tgotoblas -> sscal_k\n#define\tSSWAP_K\t\t\tgotoblas -> sswap_k\n#define\tSROT_K\t\t\tgotoblas -> srot_k\n\n#define\tSGEMV_N\t\t\tgotoblas -> sgemv_n\n#define\tSGEMV_T\t\t\tgotoblas -> sgemv_t\n#define\tSGEMV_R\t\t\tgotoblas -> sgemv_n\n#define\tSGEMV_C\t\t\tgotoblas -> sgemv_t\n#define\tSGEMV_O\t\t\tgotoblas -> sgemv_n\n#define\tSGEMV_U\t\t\tgotoblas -> sgemv_t\n#define\tSGEMV_S\t\t\tgotoblas -> sgemv_n\n#define\tSGEMV_D\t\t\tgotoblas -> sgemv_t\n\n#define\tSGERU_K\t\t\tgotoblas -> sger_k\n#define\tSGERC_K\t\t\tgotoblas -> sger_k\n#define\tSGERV_K\t\t\tgotoblas -> sger_k\n#define\tSGERD_K\t\t\tgotoblas -> sger_k\n\n#define SSYMV_U\t\t\tgotoblas -> ssymv_U\n#define SSYMV_L\t\t\tgotoblas -> ssymv_L\n\n#define SSYMV_THREAD_U\t\tssymv_thread_U\n#define SSYMV_THREAD_L\t\tssymv_thread_L\n\n#ifdef ARCH_X86_64\n#define SGEMM_DIRECT_PERFORMANT gotoblas -> sgemm_direct_performant\n#define  SGEMM_DIRECT\t\tgotoblas -> sgemm_direct\n#else\n#define SGEMM_DIRECT_PERFORMANT    sgemm_direct_performant\n#define  SGEMM_DIRECT\t\tsgemm_direct\n#endif\n\n#define\tSGEMM_ONCOPY\t\tgotoblas -> sgemm_oncopy\n#define\tSGEMM_OTCOPY\t\tgotoblas -> sgemm_otcopy\n#define\tSGEMM_INCOPY\t\tgotoblas -> sgemm_incopy\n#define\tSGEMM_ITCOPY\t\tgotoblas -> sgemm_itcopy\n\n#define\tSTRMM_OUNUCOPY\t\tgotoblas -> strmm_ounucopy\n#define\tSTRMM_OUTUCOPY\t\tgotoblas -> strmm_outucopy\n#define\tSTRMM_OLNUCOPY\t\tgotoblas -> strmm_olnucopy\n#define\tSTRMM_OLTUCOPY\t\tgotoblas -> strmm_oltucopy\n#define\tSTRSM_OUNUCOPY\t\tgotoblas -> strsm_ounucopy\n#define\tSTRSM_OUTUCOPY\t\tgotoblas -> strsm_outucopy\n#define\tSTRSM_OLNUCOPY\t\tgotoblas -> strsm_olnucopy\n#define\tSTRSM_OLTUCOPY\t\tgotoblas -> strsm_oltucopy\n\n#define\tSTRMM_IUNUCOPY\t\tgotoblas -> strmm_iunucopy\n#define\tSTRMM_IUTUCOPY\t\tgotoblas -> strmm_iutucopy\n#define\tSTRMM_ILNUCOPY\t\tgotoblas -> strmm_ilnucopy\n#define\tSTRMM_ILTUCOPY\t\tgotoblas -> strmm_iltucopy\n#define\tSTRSM_IUNUCOPY\t\tgotoblas -> strsm_iunucopy\n#define\tSTRSM_IUTUCOPY\t\tgotoblas -> strsm_iutucopy\n#define\tSTRSM_ILNUCOPY\t\tgotoblas -> strsm_ilnucopy\n#define\tSTRSM_ILTUCOPY\t\tgotoblas -> strsm_iltucopy\n\n#define\tSTRMM_OUNNCOPY\t\tgotoblas -> strmm_ounncopy\n#define\tSTRMM_OUTNCOPY\t\tgotoblas -> strmm_outncopy\n#define\tSTRMM_OLNNCOPY\t\tgotoblas -> strmm_olnncopy\n#define\tSTRMM_OLTNCOPY\t\tgotoblas -> strmm_oltncopy\n#define\tSTRSM_OUNNCOPY\t\tgotoblas -> strsm_ounncopy\n#define\tSTRSM_OUTNCOPY\t\tgotoblas -> strsm_outncopy\n#define\tSTRSM_OLNNCOPY\t\tgotoblas -> strsm_olnncopy\n#define\tSTRSM_OLTNCOPY\t\tgotoblas -> strsm_oltncopy\n\n#define\tSTRMM_IUNNCOPY\t\tgotoblas -> strmm_iunncopy\n#define\tSTRMM_IUTNCOPY\t\tgotoblas -> strmm_iutncopy\n#define\tSTRMM_ILNNCOPY\t\tgotoblas -> strmm_ilnncopy\n#define\tSTRMM_ILTNCOPY\t\tgotoblas -> strmm_iltncopy\n#define\tSTRSM_IUNNCOPY\t\tgotoblas -> strsm_iunncopy\n#define\tSTRSM_IUTNCOPY\t\tgotoblas -> strsm_iutncopy\n#define\tSTRSM_ILNNCOPY\t\tgotoblas -> strsm_ilnncopy\n#define\tSTRSM_ILTNCOPY\t\tgotoblas -> strsm_iltncopy\n\n#define\tSGEMM_BETA\t\tgotoblas -> sgemm_beta\n#define\tSGEMM_KERNEL\t\tgotoblas -> sgemm_kernel\n\n#define\tSTRMM_KERNEL_LN\t\tgotoblas -> strmm_kernel_LN\n#define\tSTRMM_KERNEL_LT\t\tgotoblas -> strmm_kernel_LT\n#define\tSTRMM_KERNEL_LR\t\tgotoblas -> strmm_kernel_LN\n#define\tSTRMM_KERNEL_LC\t\tgotoblas -> strmm_kernel_LT\n#define\tSTRMM_KERNEL_RN\t\tgotoblas -> strmm_kernel_RN\n#define\tSTRMM_KERNEL_RT\t\tgotoblas -> strmm_kernel_RT\n#define\tSTRMM_KERNEL_RR\t\tgotoblas -> strmm_kernel_RN\n#define\tSTRMM_KERNEL_RC\t\tgotoblas -> strmm_kernel_RT\n\n#define\tSTRSM_KERNEL_LN\t\tgotoblas -> strsm_kernel_LN\n#define\tSTRSM_KERNEL_LT\t\tgotoblas -> strsm_kernel_LT\n#define\tSTRSM_KERNEL_LR\t\tgotoblas -> strsm_kernel_LN\n#define\tSTRSM_KERNEL_LC\t\tgotoblas -> strsm_kernel_LT\n#define\tSTRSM_KERNEL_RN\t\tgotoblas -> strsm_kernel_RN\n#define\tSTRSM_KERNEL_RT\t\tgotoblas -> strsm_kernel_RT\n#define\tSTRSM_KERNEL_RR\t\tgotoblas -> strsm_kernel_RN\n#define\tSTRSM_KERNEL_RC\t\tgotoblas -> strsm_kernel_RT\n\n#define\tSSYMM_IUTCOPY\t\tgotoblas -> ssymm_iutcopy\n#define\tSSYMM_ILTCOPY\t\tgotoblas -> ssymm_iltcopy\n#define\tSSYMM_OUTCOPY\t\tgotoblas -> ssymm_outcopy\n#define\tSSYMM_OLTCOPY\t\tgotoblas -> ssymm_oltcopy\n\n#define SNEG_TCOPY\t\tgotoblas -> sneg_tcopy\n#define SLASWP_NCOPY\t\tgotoblas -> slaswp_ncopy\n\n#define SAXPBY_K                gotoblas -> saxpby_k\n\n#define SOMATCOPY_K_CN          gotoblas -> somatcopy_k_cn\n#define SOMATCOPY_K_RN          gotoblas -> somatcopy_k_rn\n#define SOMATCOPY_K_CT          gotoblas -> somatcopy_k_ct\n#define SOMATCOPY_K_RT          gotoblas -> somatcopy_k_rt\n#define SIMATCOPY_K_CN          gotoblas -> simatcopy_k_cn\n#define SIMATCOPY_K_RN          gotoblas -> simatcopy_k_rn\n#define SIMATCOPY_K_CT          gotoblas -> simatcopy_k_ct\n#define SIMATCOPY_K_RT          gotoblas -> simatcopy_k_rt\n\n#define SGEADD_K                gotoblas -> sgeadd_k \n\n#define SGEMM_SMALL_MATRIX_PERMIT\tgotoblas -> sgemm_small_matrix_permit\n\n#endif\n\n#define SGEMM_SMALL_KERNEL_NN\t\tFUNC_OFFSET(sgemm_small_kernel_nn)\n#define SGEMM_SMALL_KERNEL_NT\t\tFUNC_OFFSET(sgemm_small_kernel_nt)\n#define SGEMM_SMALL_KERNEL_TN\t\tFUNC_OFFSET(sgemm_small_kernel_tn)\n#define SGEMM_SMALL_KERNEL_TT\t\tFUNC_OFFSET(sgemm_small_kernel_tt)\n\n#define SGEMM_SMALL_KERNEL_B0_NN\tFUNC_OFFSET(sgemm_small_kernel_b0_nn)\n#define SGEMM_SMALL_KERNEL_B0_NT\tFUNC_OFFSET(sgemm_small_kernel_b0_nt)\n#define SGEMM_SMALL_KERNEL_B0_TN\tFUNC_OFFSET(sgemm_small_kernel_b0_tn)\n#define SGEMM_SMALL_KERNEL_B0_TT\tFUNC_OFFSET(sgemm_small_kernel_b0_tt)\n\n\n#define\tSGEMM_NN\t\tsgemm_nn\n#define\tSGEMM_CN\t\tsgemm_tn\n#define\tSGEMM_TN\t\tsgemm_tn\n#define\tSGEMM_NC\t\tsgemm_nt\n#define\tSGEMM_NT\t\tsgemm_nt\n#define\tSGEMM_CC\t\tsgemm_tt\n#define\tSGEMM_CT\t\tsgemm_tt\n#define\tSGEMM_TC\t\tsgemm_tt\n#define\tSGEMM_TT\t\tsgemm_tt\n#define\tSGEMM_NR\t\tsgemm_nn\n#define\tSGEMM_TR\t\tsgemm_tn\n#define\tSGEMM_CR\t\tsgemm_tn\n#define\tSGEMM_RN\t\tsgemm_nn\n#define\tSGEMM_RT\t\tsgemm_nt\n#define\tSGEMM_RC\t\tsgemm_nt\n#define\tSGEMM_RR\t\tsgemm_nn\n\n#define\tSSYMM_LU\t\tssymm_LU\n#define\tSSYMM_LL\t\tssymm_LL\n#define\tSSYMM_RU\t\tssymm_RU\n#define\tSSYMM_RL\t\tssymm_RL\n\n#define\tSHEMM_LU\t\tshemm_LU\n#define\tSHEMM_LL\t\tshemm_LL\n#define\tSHEMM_RU\t\tshemm_RU\n#define\tSHEMM_RL\t\tshemm_RL\n\n#define\tSSYRK_UN\t\tssyrk_UN\n#define\tSSYRK_UT\t\tssyrk_UT\n#define\tSSYRK_LN\t\tssyrk_LN\n#define\tSSYRK_LT\t\tssyrk_LT\n#define\tSSYRK_UR\t\tssyrk_UN\n#define\tSSYRK_UC\t\tssyrk_UT\n#define\tSSYRK_LR\t\tssyrk_LN\n#define\tSSYRK_LC\t\tssyrk_LT\n\n#define\tSSYRK_KERNEL_U\t\tssyrk_kernel_U\n#define\tSSYRK_KERNEL_L\t\tssyrk_kernel_L\n\n#define\tSHERK_UN\t\tssyrk_UN\n#define\tSHERK_LN\t\tssyrk_LN\n#define\tSHERK_UC\t\tssyrk_UT\n#define\tSHERK_LC\t\tssyrk_LT\n\n#define\tSHER2K_UN\t\tssyr2k_UN\n#define\tSHER2K_LN\t\tssyr2k_LN\n#define\tSHER2K_UC\t\tssyr2k_UT\n#define\tSHER2K_LC\t\tssyr2k_LT\n\n#define\tSSYR2K_UN\t\tssyr2k_UN\n#define\tSSYR2K_UT\t\tssyr2k_UT\n#define\tSSYR2K_LN\t\tssyr2k_LN\n#define\tSSYR2K_LT\t\tssyr2k_LT\n#define\tSSYR2K_UR\t\tssyr2k_UN\n#define\tSSYR2K_UC\t\tssyr2k_UT\n#define\tSSYR2K_LR\t\tssyr2k_LN\n#define\tSSYR2K_LC\t\tssyr2k_LT\n\n#define\tSSYR2K_KERNEL_U\t\tssyr2k_kernel_U\n#define\tSSYR2K_KERNEL_L\t\tssyr2k_kernel_L\n\n#define\tSTRMM_LNUU\t\tstrmm_LNUU\n#define\tSTRMM_LNUN\t\tstrmm_LNUN\n#define\tSTRMM_LNLU\t\tstrmm_LNLU\n#define\tSTRMM_LNLN\t\tstrmm_LNLN\n#define\tSTRMM_LTUU\t\tstrmm_LTUU\n#define\tSTRMM_LTUN\t\tstrmm_LTUN\n#define\tSTRMM_LTLU\t\tstrmm_LTLU\n#define\tSTRMM_LTLN\t\tstrmm_LTLN\n#define\tSTRMM_LRUU\t\tstrmm_LNUU\n#define\tSTRMM_LRUN\t\tstrmm_LNUN\n#define\tSTRMM_LRLU\t\tstrmm_LNLU\n#define\tSTRMM_LRLN\t\tstrmm_LNLN\n#define\tSTRMM_LCUU\t\tstrmm_LTUU\n#define\tSTRMM_LCUN\t\tstrmm_LTUN\n#define\tSTRMM_LCLU\t\tstrmm_LTLU\n#define\tSTRMM_LCLN\t\tstrmm_LTLN\n#define\tSTRMM_RNUU\t\tstrmm_RNUU\n#define\tSTRMM_RNUN\t\tstrmm_RNUN\n#define\tSTRMM_RNLU\t\tstrmm_RNLU\n#define\tSTRMM_RNLN\t\tstrmm_RNLN\n#define\tSTRMM_RTUU\t\tstrmm_RTUU\n#define\tSTRMM_RTUN\t\tstrmm_RTUN\n#define\tSTRMM_RTLU\t\tstrmm_RTLU\n#define\tSTRMM_RTLN\t\tstrmm_RTLN\n#define\tSTRMM_RRUU\t\tstrmm_RNUU\n#define\tSTRMM_RRUN\t\tstrmm_RNUN\n#define\tSTRMM_RRLU\t\tstrmm_RNLU\n#define\tSTRMM_RRLN\t\tstrmm_RNLN\n#define\tSTRMM_RCUU\t\tstrmm_RTUU\n#define\tSTRMM_RCUN\t\tstrmm_RTUN\n#define\tSTRMM_RCLU\t\tstrmm_RTLU\n#define\tSTRMM_RCLN\t\tstrmm_RTLN\n\n#define\tSTRSM_LNUU\t\tstrsm_LNUU\n#define\tSTRSM_LNUN\t\tstrsm_LNUN\n#define\tSTRSM_LNLU\t\tstrsm_LNLU\n#define\tSTRSM_LNLN\t\tstrsm_LNLN\n#define\tSTRSM_LTUU\t\tstrsm_LTUU\n#define\tSTRSM_LTUN\t\tstrsm_LTUN\n#define\tSTRSM_LTLU\t\tstrsm_LTLU\n#define\tSTRSM_LTLN\t\tstrsm_LTLN\n#define\tSTRSM_LRUU\t\tstrsm_LNUU\n#define\tSTRSM_LRUN\t\tstrsm_LNUN\n#define\tSTRSM_LRLU\t\tstrsm_LNLU\n#define\tSTRSM_LRLN\t\tstrsm_LNLN\n#define\tSTRSM_LCUU\t\tstrsm_LTUU\n#define\tSTRSM_LCUN\t\tstrsm_LTUN\n#define\tSTRSM_LCLU\t\tstrsm_LTLU\n#define\tSTRSM_LCLN\t\tstrsm_LTLN\n#define\tSTRSM_RNUU\t\tstrsm_RNUU\n#define\tSTRSM_RNUN\t\tstrsm_RNUN\n#define\tSTRSM_RNLU\t\tstrsm_RNLU\n#define\tSTRSM_RNLN\t\tstrsm_RNLN\n#define\tSTRSM_RTUU\t\tstrsm_RTUU\n#define\tSTRSM_RTUN\t\tstrsm_RTUN\n#define\tSTRSM_RTLU\t\tstrsm_RTLU\n#define\tSTRSM_RTLN\t\tstrsm_RTLN\n#define\tSTRSM_RRUU\t\tstrsm_RNUU\n#define\tSTRSM_RRUN\t\tstrsm_RNUN\n#define\tSTRSM_RRLU\t\tstrsm_RNLU\n#define\tSTRSM_RRLN\t\tstrsm_RNLN\n#define\tSTRSM_RCUU\t\tstrsm_RTUU\n#define\tSTRSM_RCUN\t\tstrsm_RTUN\n#define\tSTRSM_RCLU\t\tstrsm_RTLU\n#define\tSTRSM_RCLN\t\tstrsm_RTLN\n\n#define\tSGEMM_THREAD_NN\t\tsgemm_thread_nn\n#define\tSGEMM_THREAD_CN\t\tsgemm_thread_tn\n#define\tSGEMM_THREAD_TN\t\tsgemm_thread_tn\n#define\tSGEMM_THREAD_NC\t\tsgemm_thread_nt\n#define\tSGEMM_THREAD_NT\t\tsgemm_thread_nt\n#define\tSGEMM_THREAD_CC\t\tsgemm_thread_tt\n#define\tSGEMM_THREAD_CT\t\tsgemm_thread_tt\n#define\tSGEMM_THREAD_TC\t\tsgemm_thread_tt\n#define\tSGEMM_THREAD_TT\t\tsgemm_thread_tt\n#define\tSGEMM_THREAD_NR\t\tsgemm_thread_nn\n#define\tSGEMM_THREAD_TR\t\tsgemm_thread_tn\n#define\tSGEMM_THREAD_CR\t\tsgemm_thread_tn\n#define\tSGEMM_THREAD_RN\t\tsgemm_thread_nn\n#define\tSGEMM_THREAD_RT\t\tsgemm_thread_nt\n#define\tSGEMM_THREAD_RC\t\tsgemm_thread_nt\n#define\tSGEMM_THREAD_RR\t\tsgemm_thread_nn\n\n#define\tSSYMM_THREAD_LU\t\tssymm_thread_LU\n#define\tSSYMM_THREAD_LL\t\tssymm_thread_LL\n#define\tSSYMM_THREAD_RU\t\tssymm_thread_RU\n#define\tSSYMM_THREAD_RL\t\tssymm_thread_RL\n\n#define\tSHEMM_THREAD_LU\t\tshemm_thread_LU\n#define\tSHEMM_THREAD_LL\t\tshemm_thread_LL\n#define\tSHEMM_THREAD_RU\t\tshemm_thread_RU\n#define\tSHEMM_THREAD_RL\t\tshemm_thread_RL\n\n#define\tSSYRK_THREAD_UN\t\tssyrk_thread_UN\n#define\tSSYRK_THREAD_UT\t\tssyrk_thread_UT\n#define\tSSYRK_THREAD_LN\t\tssyrk_thread_LN\n#define\tSSYRK_THREAD_LT\t\tssyrk_thread_LT\n#define\tSSYRK_THREAD_UR\t\tssyrk_thread_UN\n#define\tSSYRK_THREAD_UC\t\tssyrk_thread_UT\n#define\tSSYRK_THREAD_LR\t\tssyrk_thread_LN\n#define\tSSYRK_THREAD_LC\t\tssyrk_thread_LT\n\n#define\tSHERK_THREAD_UN\t\tssyrk_thread_UN\n#define\tSHERK_THREAD_UT\t\tssyrk_thread_UT\n#define\tSHERK_THREAD_LN\t\tssyrk_thread_LN\n#define\tSHERK_THREAD_LT\t\tssyrk_thread_LT\n#define\tSHERK_THREAD_UR\t\tssyrk_thread_UN\n#define\tSHERK_THREAD_UC\t\tssyrk_thread_UT\n#define\tSHERK_THREAD_LR\t\tssyrk_thread_LN\n#define\tSHERK_THREAD_LC\t\tssyrk_thread_LT\n\n#endif\n"
        },
        {
          "name": "common_sb.h",
          "type": "blob",
          "size": 3.1513671875,
          "content": "#ifndef COMMON_SB_H\n#define COMMON_SB_H\n\n#ifndef DYNAMIC_ARCH\n\n#define SBDOT_K             sbdot_k\n#define SBSTOBF16_K         sbstobf16_k\n#define SBDTOBF16_K         sbdtobf16_k\n#define SBF16TOS_K          sbf16tos_k\n#define DBF16TOD_K          dbf16tod_k\n#define SBGEMV_N_K          sbgemv_n\n#define SBGEMV_T_K          sbgemv_t\n\n#define\tSBGEMM_ONCOPY\t\tsbgemm_oncopy\n#define\tSBGEMM_OTCOPY\t\tsbgemm_otcopy\n\n#if SBGEMM_DEFAULT_UNROLL_M == SBGEMM_DEFAULT_UNROLL_N\n#define\tSBGEMM_INCOPY\t\tsbgemm_oncopy\n#define\tSBGEMM_ITCOPY\t\tsbgemm_otcopy\n#else\n#define\tSBGEMM_INCOPY\t\tsbgemm_incopy\n#define\tSBGEMM_ITCOPY\t\tsbgemm_itcopy\n#endif\n#define\tSBGEMM_BETA\t\tsbgemm_beta\n#define SBGEMM_KERNEL            sbgemm_kernel\n\n#define SBGEMM_SMALL_MATRIX_PERMIT\tsbgemm_small_matrix_permit\n#else\n\n#define SBDOT_K             gotoblas -> sbdot_k\n#define SBSTOBF16_K         gotoblas -> sbstobf16_k\n#define SBDTOBF16_K         gotoblas -> sbdtobf16_k\n#define SBF16TOS_K          gotoblas -> sbf16tos_k\n#define DBF16TOD_K          gotoblas -> dbf16tod_k\n#define SBGEMV_N_K          gotoblas -> sbgemv_n\n#define SBGEMV_T_K          gotoblas -> sbgemv_t\n\n#define\tSBGEMM_ONCOPY\t\tgotoblas -> sbgemm_oncopy\n#define\tSBGEMM_OTCOPY\t\tgotoblas -> sbgemm_otcopy\n#define\tSBGEMM_INCOPY\t\tgotoblas -> sbgemm_incopy\n#define\tSBGEMM_ITCOPY\t\tgotoblas -> sbgemm_itcopy\n#define\tSBGEMM_BETA\t\tgotoblas -> sbgemm_beta\n#define\tSBGEMM_KERNEL\t\tgotoblas -> sbgemm_kernel\n\n#define SBGEMM_SMALL_MATRIX_PERMIT\tgotoblas -> sbgemm_small_matrix_permit\n#endif\n\n#define SBGEMM_SMALL_KERNEL_NN\t\tFUNC_OFFSET(sbgemm_small_kernel_nn)\n#define SBGEMM_SMALL_KERNEL_NT\t\tFUNC_OFFSET(sbgemm_small_kernel_nt)\n#define SBGEMM_SMALL_KERNEL_TN\t\tFUNC_OFFSET(sbgemm_small_kernel_tn)\n#define SBGEMM_SMALL_KERNEL_TT\t\tFUNC_OFFSET(sbgemm_small_kernel_tt)\n\n#define SBGEMM_SMALL_KERNEL_B0_NN\tFUNC_OFFSET(sbgemm_small_kernel_b0_nn)\n#define SBGEMM_SMALL_KERNEL_B0_NT\tFUNC_OFFSET(sbgemm_small_kernel_b0_nt)\n#define SBGEMM_SMALL_KERNEL_B0_TN\tFUNC_OFFSET(sbgemm_small_kernel_b0_tn)\n#define SBGEMM_SMALL_KERNEL_B0_TT\tFUNC_OFFSET(sbgemm_small_kernel_b0_tt)\n\n#define\tSBGEMM_NN\t\tsbgemm_nn\n#define\tSBGEMM_CN\t\tsbgemm_tn\n#define\tSBGEMM_TN\t\tsbgemm_tn\n#define\tSBGEMM_NC\t\tsbgemm_nt\n#define\tSBGEMM_NT\t\tsbgemm_nt\n#define\tSBGEMM_CC\t\tsbgemm_tt\n#define\tSBGEMM_CT\t\tsbgemm_tt\n#define\tSBGEMM_TC\t\tsbgemm_tt\n#define\tSBGEMM_TT\t\tsbgemm_tt\n#define\tSBGEMM_NR\t\tsbgemm_nn\n#define\tSBGEMM_TR\t\tsbgemm_tn\n#define\tSBGEMM_CR\t\tsbgemm_tn\n#define\tSBGEMM_RN\t\tsbgemm_nn\n#define\tSBGEMM_RT\t\tsbgemm_nt\n#define\tSBGEMM_RC\t\tsbgemm_nt\n#define\tSBGEMM_RR\t\tsbgemm_nn\n\n#define\tSBGEMM_THREAD_NN\t\tsbgemm_thread_nn\n#define\tSBGEMM_THREAD_CN\t\tsbgemm_thread_tn\n#define\tSBGEMM_THREAD_TN\t\tsbgemm_thread_tn\n#define\tSBGEMM_THREAD_NC\t\tsbgemm_thread_nt\n#define\tSBGEMM_THREAD_NT\t\tsbgemm_thread_nt\n#define\tSBGEMM_THREAD_CC\t\tsbgemm_thread_tt\n#define\tSBGEMM_THREAD_CT\t\tsbgemm_thread_tt\n#define\tSBGEMM_THREAD_TC\t\tsbgemm_thread_tt\n#define\tSBGEMM_THREAD_TT\t\tsbgemm_thread_tt\n#define\tSBGEMM_THREAD_NR\t\tsbgemm_thread_nn\n#define\tSBGEMM_THREAD_TR\t\tsbgemm_thread_tn\n#define\tSBGEMM_THREAD_CR\t\tsbgemm_thread_tn\n#define\tSBGEMM_THREAD_RN\t\tsbgemm_thread_nn\n#define\tSBGEMM_THREAD_RT\t\tsbgemm_thread_nt\n#define\tSBGEMM_THREAD_RC\t\tsbgemm_thread_nt\n#define\tSBGEMM_THREAD_RR\t\tsbgemm_thread_nn\n\n#endif\n\n"
        },
        {
          "name": "common_sparc.h",
          "type": "blob",
          "size": 7.1259765625,
          "content": "/*********************************************************************/\n/* Copyright 2009, 2010 The University of Texas at Austin.           */\n/* All rights reserved.                                              */\n/*                                                                   */\n/* Redistribution and use in source and binary forms, with or        */\n/* without modification, are permitted provided that the following   */\n/* conditions are met:                                               */\n/*                                                                   */\n/*   1. Redistributions of source code must retain the above         */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer.                                                  */\n/*                                                                   */\n/*   2. Redistributions in binary form must reproduce the above      */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer in the documentation and/or other materials       */\n/*      provided with the distribution.                              */\n/*                                                                   */\n/*    THIS  SOFTWARE IS PROVIDED  BY THE  UNIVERSITY OF  TEXAS AT    */\n/*    AUSTIN  ``AS IS''  AND ANY  EXPRESS OR  IMPLIED WARRANTIES,    */\n/*    INCLUDING, BUT  NOT LIMITED  TO, THE IMPLIED  WARRANTIES OF    */\n/*    MERCHANTABILITY  AND FITNESS FOR  A PARTICULAR  PURPOSE ARE    */\n/*    DISCLAIMED.  IN  NO EVENT SHALL THE UNIVERSITY  OF TEXAS AT    */\n/*    AUSTIN OR CONTRIBUTORS BE  LIABLE FOR ANY DIRECT, INDIRECT,    */\n/*    INCIDENTAL,  SPECIAL, EXEMPLARY,  OR  CONSEQUENTIAL DAMAGES    */\n/*    (INCLUDING, BUT  NOT LIMITED TO,  PROCUREMENT OF SUBSTITUTE    */\n/*    GOODS  OR  SERVICES; LOSS  OF  USE,  DATA,  OR PROFITS;  OR    */\n/*    BUSINESS INTERRUPTION) HOWEVER CAUSED  AND ON ANY THEORY OF    */\n/*    LIABILITY, WHETHER  IN CONTRACT, STRICT  LIABILITY, OR TORT    */\n/*    (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY WAY OUT    */\n/*    OF  THE  USE OF  THIS  SOFTWARE,  EVEN  IF ADVISED  OF  THE    */\n/*    POSSIBILITY OF SUCH DAMAGE.                                    */\n/*                                                                   */\n/* The views and conclusions contained in the software and           */\n/* documentation are those of the authors and should not be          */\n/* interpreted as representing official policies, either expressed   */\n/* or implied, of The University of Texas at Austin.                 */\n/*********************************************************************/\n\n#ifndef COMMON_POWER\n#define COMMON_POWER\n\n#define MB\t__asm__ __volatile__ (\"nop\")\n#define WMB\t__asm__ __volatile__ (\"nop\")\n#define RMB\t__asm__ __volatile__ (\"nop\")\n\n#ifndef ASSEMBLER\n\nstatic __inline void blas_lock(volatile unsigned long *address){\n\n  long int ret = 1;\n\n  do {\n    while (*address) {YIELDING;};\n\n    __asm__ __volatile__(\n\t\t\t \"ldstub [%1], %0\"\n\t\t\t : \"=&r\"(ret)\n\t\t\t : \"r\" (address)\n\t\t\t : \"memory\");\n  } while (ret);\n}\n#define BLAS_LOCK_DEFINED\n\nstatic __inline unsigned long rpcc(void){\n  unsigned long clocks;\n\n  __asm__ __volatile__ (\"rd %%tick, %0\" : \"=r\" (clocks));\n\n  return clocks;\n};\n#define RPCC_DEFINED\n\n#ifdef __64BIT__\n#define RPCC64BIT\n#endif\n\n#ifndef __BIG_ENDIAN__\n#define __BIG_ENDIAN__\n#endif\n\n#ifdef C_SUN\n#ifndef __64BIT\n#define RETURN_BY_STACK\n#endif\n#endif\n\n#ifdef DOUBLE\n#define GET_IMAGE(res)  __asm__ __volatile__(\"fmovd %%f2, %0\" : \"=f\"(res)  : : \"memory\")\n#else\n#define GET_IMAGE(res)  __asm__ __volatile__(\"fmovs %%f1, %0\" : \"=f\"(res)  : : \"memory\")\n#endif\n\n#define GET_IMAGE_CANCEL\n\n#ifdef SMP\nstatic __inline int blas_quickdivide(blasint x, blasint y){\n  return x / y;\n}\n#endif\n#endif\n\n\n#ifdef ASSEMBLER\n\n#ifndef __64BIT__\n#define STACK_START 128\n#define SAVESP\t\tsave\t%sp,  -64, %sp\n#else\n#define STACK_START 2423\n#define SAVESP\t\tsave\t%sp, -256, %sp\n#endif\n\n#define NOP\tor %g1, %g1, %g1\n\n#ifdef DOUBLE\n#define LDF\tldd\n#define STF\tstd\n#define FADD\tfaddd\n#define FMUL\tfmuld\n#define FMOV\tfmovd\n#define FABS\tfabsd\n#define FSUB\tfsubd\n#define FCMP\tfcmpd\n#define FMOVG\tfmovdg\n#define FMOVL\tfmovdl\n#define FSQRT\tfsqrtd\n#define FDIV\tfdivd\n#else\n#define LDF\tld\n#define STF\tst\n#define FADD\tfadds\n#define FMUL\tfmuls\n#define FMOV\tfmovs\n#define FABS\tfabss\n#define FSUB\tfsubs\n#define FCMP\tfcmps\n#define FMOVG\tfmovsg\n#define FMOVL\tfmovsl\n#define FSQRT\tfsqrts\n#define FDIV\tfdivs\n#endif\n\n#define HALT prefetch [%g0], 5\n\n#define FMADDS(rs1, rs2, rs3, rd) \\\n        .word\t((2 << 30) | ((rd) << 25) | ( 0x37 << 19) | ((rs1) << 14) | ((rs3) << 9) | ( 1 << 5) | (rs2))\n\n#define FMADDD(rs1, rs2, rs3, rd) \\\n        .word\t((2 << 30) | ((rd) << 25) | ( 0x37 << 19) | ((rs1) << 14) | ((rs3) << 9) | ( 2 << 5) | (rs2))\n\n#define FMSUBS(rs1, rs2, rs3, rd) \\\n        .word\t((2 << 30) | ((rd) << 25) | ( 0x37 << 19) | ((rs1) << 14) | ((rs3) << 9) | ( 5 << 5) | (rs2))\n\n#define FMSUBD(rs1, rs2, rs3, rd) \\\n        .word\t((2 << 30) | ((rd) << 25) | ( 0x37 << 19) | ((rs1) << 14) | ((rs3) << 9) | ( 6 << 5) | (rs2))\n\n#define FNMSUBS(rs1, rs2, rs3, rd) \\\n        .word\t((2 << 30) | ((rd) << 25) | ( 0x37 << 19) | ((rs1) << 14) | ((rs3) << 9) | ( 9 << 5) | (rs2))\n\n#define FNMSUBD(rs1, rs2, rs3, rd) \\\n        .word\t((2 << 30) | ((rd) << 25) | ( 0x37 << 19) | ((rs1) << 14) | ((rs3) << 9) | (10 << 5) | (rs2))\n\n#define FNMADDS(rs1, rs2, rs3, rd) \\\n        .word\t((2 << 30) | ((rd) << 25) | ( 0x37 << 19) | ((rs1) << 14) | ((rs3) << 9) | (13 << 5) | (rs2))\n\n#define FNMADDD(rs1, rs2, rs3, rd) \\\n        .word\t((2 << 30) | ((rd) << 25) | ( 0x37 << 19) | ((rs1) << 14) | ((rs3) << 9) | (14 << 5) | (rs2))\n\n#define FCLRS(rd) \\\n        .word\t((2 << 30) | ((rd) << 25) | ( 0x36 << 19) | ( 0x61 << 5))\n\n#define FCLRD(rd) \\\n        .word\t((2 << 30) | ((rd) << 25) | ( 0x36 << 19) | ( 0x60 << 5))\n\n#define FONES(rd) \\\n        .word\t((2 << 30) | ((rd) << 25) | ( 0x36 << 19) | ( 0x7f << 5))\n\n#define FONED(rd) \\\n        .word\t((2 << 30) | ((rd) << 25) | ( 0x36 << 19) | ( 0x7e << 5))\n\n#ifndef DOUBLE\n#define\tFCLR(a)\t\t\tFCLRS(a)\n#define\tFONE(a)\t\t\tFONES(a)\n#define\tFMADD(a, b, c, d)\tFMADDS(a, b, c, d)\n#define\tFMSUB(a, b, c, d)\tFMSUBS(a, b, c, d)\n#define\tFNMADD(a, b, c, d)\tFNMADDS(a, b, c, d)\n#define\tFNMSUB(a, b, c, d)\tFNMSUBS(a, b, c, d)\n#else\n#define\tFCLR(a)\t\t\tFCLRD(a)\n#define\tFONE(a)\t\t\tFONED(a)\n#define\tFMADD(a, b, c, d)\tFMADDD(a, b, c, d)\n#define\tFMSUB(a, b, c, d)\tFMSUBD(a, b, c, d)\n#define\tFNMADD(a, b, c, d)\tFNMADDD(a, b, c, d)\n#define\tFNMSUB(a, b, c, d)\tFNMSUBD(a, b, c, d)\n#endif\n\n#ifndef F_INTERFACE\n#define REALNAME ASMNAME\n#else\n#define REALNAME ASMFNAME\n#endif\n\n#ifdef sparc\n#define PROLOGUE \\\n\t.section\t\".text\"; \\\n\t.align 32; \\\n\t.global REALNAME;\\\n\t.type\tREALNAME, #function; \\\n\t.proc\t07; \\\nREALNAME:;\n\n#if defined(__linux__) && defined(__ELF__)\n#define GNUSTACK .section .note.GNU-stack,\"\",@progbits\n#else\n#define GNUSTACK\n#endif\n\n#define EPILOGUE \\\n        .size\t REALNAME, .-REALNAME; \\\n        GNUSTACK\n\n#endif\n\n#endif\n\n#ifdef sparc\n#define SEEK_ADDRESS\n#endif\n\n#define BUFFER_SIZE\t(32 << 20)\n\n#ifndef PAGESIZE\n#define PAGESIZE\t( 8 << 10)\n#endif\n#define HUGE_PAGESIZE\t( 4 << 20)\n\n#define BASE_ADDRESS (START_ADDRESS - BUFFER_SIZE * MAX_CPU_NUMBER)\n\n#ifndef MAP_ANONYMOUS\n#define MAP_ANONYMOUS MAP_ANON\n#endif\n#endif\n"
        },
        {
          "name": "common_stackalloc.h",
          "type": "blob",
          "size": 3.5791015625,
          "content": "/*******************************************************************************\nCopyright (c) 2016, The OpenBLAS Project\nAll rights reserved.\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n1. Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright\nnotice, this list of conditions and the following disclaimer in\nthe documentation and/or other materials provided with the\ndistribution.\n3. Neither the name of the OpenBLAS project nor the names of\nits contributors may be used to endorse or promote products\nderived from this software without specific prior written permission.\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE OPENBLAS PROJECT OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\nUSE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*******************************************************************************/\n\n#define STACK_ALLOC_PROTECT\n#ifdef STACK_ALLOC_PROTECT\n// Try to detect stack smashing\n#include <assert.h>\n#define STACK_ALLOC_PROTECT_SET volatile int stack_check = 0x7fc01234;\n#define STACK_ALLOC_PROTECT_CHECK assert(stack_check == 0x7fc01234);\n#else\n#define STACK_ALLOC_PROTECT_SET\n#define STACK_ALLOC_PROTECT_CHECK\n#endif\n\n#if defined(MAX_STACK_ALLOC) && MAX_STACK_ALLOC > 0\n\n/*\n * Allocate a buffer on the stack if the size is smaller than MAX_STACK_ALLOC.\n * Stack allocation is much faster than blas_memory_alloc or malloc, particularly\n * when OpenBLAS is used from a multi-threaded application.\n * SIZE must be carefully chosen to be:\n * - as small as possible to maximize the number of stack allocation\n * - large enough to support all architectures and kernel\n * Choosing a SIZE too small will lead to a stack smashing.\n */\n#define STACK_ALLOC(SIZE, TYPE, BUFFER)                                        \\\n  /* make it volatile because some function (ex: dgemv_n.S) */                 \\\n  /* do not restore all register */                                            \\\n  volatile int stack_alloc_size = SIZE;                                        \\\n  if (stack_alloc_size > MAX_STACK_ALLOC / sizeof(TYPE)) stack_alloc_size = 0; \\\n  STACK_ALLOC_PROTECT_SET                                                      \\\n  /* Avoid declaring an array of length 0 */                                   \\\n  TYPE stack_buffer[stack_alloc_size ? stack_alloc_size : 1]                   \\\n      __attribute__((aligned(0x20)));                                          \\\n  BUFFER = stack_alloc_size ? stack_buffer : (TYPE *)blas_memory_alloc(1);\n#else\n  //Original OpenBLAS/GotoBLAS codes.\n  #define STACK_ALLOC(SIZE, TYPE, BUFFER) BUFFER = (TYPE *)blas_memory_alloc(1)\n#endif\n\n\n#if defined(MAX_STACK_ALLOC) && MAX_STACK_ALLOC > 0\n#define STACK_FREE(BUFFER)    \\\n  STACK_ALLOC_PROTECT_CHECK   \\\n  if(!stack_alloc_size)       \\\n    blas_memory_free(BUFFER);\n#else\n#define STACK_FREE(BUFFER) blas_memory_free(BUFFER)\n#endif\n\n"
        },
        {
          "name": "common_thread.h",
          "type": "blob",
          "size": 7.46875,
          "content": "/*********************************************************************/\n/* Copyright 2009, 2010 The University of Texas at Austin.           */\n/* All rights reserved.                                              */\n/*                                                                   */\n/* Redistribution and use in source and binary forms, with or        */\n/* without modification, are permitted provided that the following   */\n/* conditions are met:                                               */\n/*                                                                   */\n/*   1. Redistributions of source code must retain the above         */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer.                                                  */\n/*                                                                   */\n/*   2. Redistributions in binary form must reproduce the above      */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer in the documentation and/or other materials       */\n/*      provided with the distribution.                              */\n/*                                                                   */\n/*    THIS  SOFTWARE IS PROVIDED  BY THE  UNIVERSITY OF  TEXAS AT    */\n/*    AUSTIN  ``AS IS''  AND ANY  EXPRESS OR  IMPLIED WARRANTIES,    */\n/*    INCLUDING, BUT  NOT LIMITED  TO, THE IMPLIED  WARRANTIES OF    */\n/*    MERCHANTABILITY  AND FITNESS FOR  A PARTICULAR  PURPOSE ARE    */\n/*    DISCLAIMED.  IN  NO EVENT SHALL THE UNIVERSITY  OF TEXAS AT    */\n/*    AUSTIN OR CONTRIBUTORS BE  LIABLE FOR ANY DIRECT, INDIRECT,    */\n/*    INCIDENTAL,  SPECIAL, EXEMPLARY,  OR  CONSEQUENTIAL DAMAGES    */\n/*    (INCLUDING, BUT  NOT LIMITED TO,  PROCUREMENT OF SUBSTITUTE    */\n/*    GOODS  OR  SERVICES; LOSS  OF  USE,  DATA,  OR PROFITS;  OR    */\n/*    BUSINESS INTERRUPTION) HOWEVER CAUSED  AND ON ANY THEORY OF    */\n/*    LIABILITY, WHETHER  IN CONTRACT, STRICT  LIABILITY, OR TORT    */\n/*    (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY WAY OUT    */\n/*    OF  THE  USE OF  THIS  SOFTWARE,  EVEN  IF ADVISED  OF  THE    */\n/*    POSSIBILITY OF SUCH DAMAGE.                                    */\n/*                                                                   */\n/* The views and conclusions contained in the software and           */\n/* documentation are those of the authors and should not be          */\n/* interpreted as representing official policies, either expressed   */\n/* or implied, of The University of Texas at Austin.                 */\n/*********************************************************************/\n\n#ifndef COMMON_THREAD\n#define COMMON_THREAD\n\n#ifdef USE_OPENMP\n#include <omp.h>\nextern void goto_set_num_threads(int nthreads);\n#endif\n\n/* Basic Thread Debugging */\n#undef SMP_DEBUG\n\n/* Thread Timing Debugging */\n#undef TIMING_DEBUG\n\n/* Global Parameter */\nextern int blas_cpu_number;\nextern int blas_num_threads;\nextern int blas_omp_linked;\n\n#define BLAS_LEGACY\t0x8000U\n#define BLAS_PTHREAD\t0x4000U\n#define BLAS_NODE\t0x2000U\n\n#define BLAS_PREC       0x000FU\n#define BLAS_INT8       0x0000U\n#define BLAS_BFLOAT16   0x0001U\n#define BLAS_SINGLE     0x0002U\n#define BLAS_DOUBLE     0x0003U\n#define BLAS_XDOUBLE    0x0004U\n#define BLAS_STOBF16    0x0008U\n#define BLAS_DTOBF16    0x0009U\n#define BLAS_BF16TOS    0x000AU\n#define BLAS_BF16TOD    0x000BU\n\n#define BLAS_REAL       0x0000U\n#define BLAS_COMPLEX    0x1000U\n\n#define BLAS_TRANSA\t0x0030U\t/* 2bit */\n#define BLAS_TRANSA_N\t0x0000U\n#define BLAS_TRANSA_T\t0x0010U\n#define BLAS_TRANSA_R\t0x0020U\n#define BLAS_TRANSA_C\t0x0030U\n#define BLAS_TRANSA_SHIFT     4\n\n#define BLAS_TRANSB\t0x0300U\t/* 2bit */\n#define BLAS_TRANSB_N\t0x0000U\n#define BLAS_TRANSB_T\t0x0100U\n#define BLAS_TRANSB_R\t0x0200U\n#define BLAS_TRANSB_C\t0x0300U\n#define BLAS_TRANSB_SHIFT     8\n\n#define BLAS_RSIDE      0x0400U\n#define BLAS_RSIDE_SHIFT     10\n#define BLAS_UPLO       0x0800U\n#define BLAS_UPLO_SHIFT      11\n\n#define BLAS_STATUS_NOTYET\t0\n#define BLAS_STATUS_QUEUED\t1\n#define BLAS_STATUS_RUNNING\t2\n#define BLAS_STATUS_FINISHED\t4\n\ntypedef struct blas_queue {\n\n  void *routine;\n  BLASLONG position;\n  BLASLONG assigned;\n\n  blas_arg_t *args;\n  void *range_m;\n  void *range_n;\n  void *sa, *sb;\n\n  struct blas_queue *next;\n\n#if defined( __WIN32__) || defined(__CYGWIN32__) || defined(_WIN32) || defined(__CYGWIN__)\n   CRITICAL_SECTION lock;\n   HANDLE finish;\n  volatile int finished;\n#else\n  pthread_mutex_t\t lock;\n  pthread_cond_t\t finished;\n#endif\n\n  int mode, status;\n\n#ifdef CONSISTENT_FPCSR\n  unsigned int sse_mode, x87_mode;\n#endif\n\n#ifdef SMP_DEBUG\n  int    num;\n#endif\n#ifdef TIMING_DEBUG\n  unsigned int clocks;\n#endif\n} blas_queue_t;\n\n#ifdef SMP_SERVER\n\nextern int blas_server_avail;\nextern int blas_omp_number_max;\nextern int blas_omp_threads_local;\n\nstatic __inline int num_cpu_avail(int level) {\n\n#ifdef USE_OPENMP\nint openmp_nthreads;\n\topenmp_nthreads=omp_get_max_threads();\n\tif (omp_in_parallel()) openmp_nthreads = blas_omp_threads_local;\n#endif\n\n#ifndef USE_OPENMP \n  if (blas_cpu_number == 1\n#else\n     if (openmp_nthreads == 1 \n#endif\n      ) return 1;        \n\n#ifdef USE_OPENMP\n     if (openmp_nthreads > blas_omp_number_max){\n#ifdef DEBUG\n     fprintf(stderr,\"WARNING - more OpenMP threads requested (%d) than available (%d)\\n\",openmp_nthreads,blas_omp_number_max);\n#endif\n     openmp_nthreads = blas_omp_number_max;\n     }\n     if (blas_cpu_number != openmp_nthreads) {\n\t  goto_set_num_threads(openmp_nthreads);\n  }\n#endif\n\n  return blas_cpu_number;\n\n}\n\nstatic __inline void blas_queue_init(blas_queue_t *queue){\n\n  queue -> sa    = NULL;\n  queue -> sb    = NULL;\n  queue-> next  = NULL;\n}\n\nint blas_thread_init(void);\nint BLASFUNC(blas_thread_shutdown)(void);\nint exec_blas(BLASLONG, blas_queue_t *);\nint exec_blas_async(BLASLONG, blas_queue_t *);\nint exec_blas_async_wait(BLASLONG, blas_queue_t *);\n\n#else\nint exec_blas_async(BLASLONG num_cpu, blas_param_t *param, pthread_t *);\nint exec_blas_async_wait(BLASLONG num_cpu, pthread_t *blas_threads);\nint exec_blas(BLASLONG num_cpu, blas_param_t *param, void *buffer);\n#endif\n\n#ifndef ASSEMBLER\n\nint blas_level1_thread(int mode, BLASLONG m, BLASLONG n, BLASLONG k, void *alpha,\n\t\t       void *a, BLASLONG lda,\n\t\t       void *b, BLASLONG ldb,\n\t\t       void *c, BLASLONG ldc, int (*function)(void), int threads);\n\nint gemm_thread_m (int mode, blas_arg_t *, BLASLONG *, BLASLONG *, int (*function)(blas_arg_t*, BLASLONG*, BLASLONG*,FLOAT *, FLOAT *, BLASLONG ), void *, void *, BLASLONG);\n\nint gemm_thread_n (int mode, blas_arg_t *, BLASLONG *, BLASLONG *, int (*function)(blas_arg_t*, BLASLONG*, BLASLONG*,FLOAT*, FLOAT*, BLASLONG), void *, void *, BLASLONG);\n\nint gemm_thread_mn(int mode, blas_arg_t *, BLASLONG *, BLASLONG *, int (*function)(blas_arg_t*, BLASLONG*, BLASLONG*,FLOAT *, FLOAT *, BLASLONG), void *, void *, BLASLONG);\n\nint gemm_thread_variable(int mode, blas_arg_t *, BLASLONG *, BLASLONG *, int (*function)(blas_arg_t*, BLASLONG*, BLASLONG*,FLOAT *, FLOAT *, BLASLONG), void *, void *, BLASLONG, BLASLONG);\n\nint trsm_thread(int mode, BLASLONG m, BLASLONG n,\n\t\tdouble alpha_r, double alpha_i,\n\t\tvoid *a, BLASLONG lda,\n\t\tvoid *c, BLASLONG ldc, int (*function)(void), void *buffer);\n\nint syrk_thread(int mode, blas_arg_t *, BLASLONG *, BLASLONG *, int (*function)(blas_arg_t*, BLASLONG*, BLASLONG*, FLOAT *, FLOAT *, BLASLONG), void*, void*, BLASLONG);\n\nint getrf_thread(int mode, BLASLONG m, BLASLONG n, BLASLONG k,\n\t\t void *offsetA, BLASLONG lda,\n\t\t void *offsetB, BLASLONG jb,\n\t\t void *ipiv, BLASLONG offset, int (*function)(void), void *buffer);\n\n#endif  /* ENDIF ASSEMBLER */\n\n#endif\n"
        },
        {
          "name": "common_x.h",
          "type": "blob",
          "size": 19.9765625,
          "content": "#ifndef COMMON_X_H\n#define COMMON_X_H\n\n#ifndef DYNAMIC_ARCH\n\n#define\tXAMAX_K\t\t\txamax_k\n#define\tXAMIN_K\t\t\txamin_k\n#define\tXMAX_K\t\t\txmax_k\n#define\tXMIN_K\t\t\txmin_k\n#define\tIXAMAX_K\t\tixamax_k\n#define\tIXAMIN_K\t\tixamin_k\n#define\tIXMAX_K\t\t\tixmax_k\n#define\tIXMIN_K\t\t\tixmin_k\n#define\tXASUM_K\t\t\txasum_k\n#define\tXAXPYU_K\t\txaxpy_k\n#define\tXAXPYC_K\t\txaxpyc_k\n#define\tXCOPY_K\t\t\txcopy_k\n#define\tXDOTU_K\t\t\txdotu_k\n#define\tXDOTC_K\t\t\txdotc_k\n#define\tXNRM2_K\t\t\txnrm2_k\n#define\tXSCAL_K\t\t\txscal_k\n#define\tXSUM_K\t\t\txsum_k\n#define\tXSWAP_K\t\t\txswap_k\n#define\tXROT_K\t\t\txqrot_k\n\n#define\tXGEMV_N\t\t\txgemv_n\n#define\tXGEMV_T\t\t\txgemv_t\n#define\tXGEMV_R\t\t\txgemv_r\n#define\tXGEMV_C\t\t\txgemv_c\n#define\tXGEMV_O\t\t\txgemv_o\n#define\tXGEMV_U\t\t\txgemv_u\n#define\tXGEMV_S\t\t\txgemv_s\n#define\tXGEMV_D\t\t\txgemv_d\n\n#define\tXGERU_K\t\t\txgeru_k\n#define\tXGERC_K\t\t\txgerc_k\n#define\tXGERV_K\t\t\txgerv_k\n#define\tXGERD_K\t\t\txgerd_k\n\n#define XSYMV_U\t\t\txsymv_U\n#define XSYMV_L\t\t\txsymv_L\n#define XHEMV_U\t\t\txhemv_U\n#define XHEMV_L\t\t\txhemv_L\n#define XHEMV_V\t\t\txhemv_V\n#define XHEMV_M\t\t\txhemv_M\n\n#define XSYMV_THREAD_U\t\txsymv_thread_U\n#define XSYMV_THREAD_L\t\txsymv_thread_L\n#define XHEMV_THREAD_U\t\txhemv_thread_U\n#define XHEMV_THREAD_L\t\txhemv_thread_L\n#define XHEMV_THREAD_V\t\txhemv_thread_V\n#define XHEMV_THREAD_M\t\txhemv_thread_M\n\n#define\tXGEMM_ONCOPY\t\txgemm_oncopy\n#define\tXGEMM_OTCOPY\t\txgemm_otcopy\n\n#if XGEMM_DEFAULT_UNROLL_M == XGEMM_DEFAULT_UNROLL_N\n#define\tXGEMM_INCOPY\t\txgemm_oncopy\n#define\tXGEMM_ITCOPY\t\txgemm_otcopy\n#else\n#define\tXGEMM_INCOPY\t\txgemm_incopy\n#define\tXGEMM_ITCOPY\t\txgemm_itcopy\n#endif\n\n#define\tXTRMM_OUNUCOPY\t\txtrmm_ounucopy\n#define\tXTRMM_OUNNCOPY\t\txtrmm_ounncopy\n#define\tXTRMM_OUTUCOPY\t\txtrmm_outucopy\n#define\tXTRMM_OUTNCOPY\t\txtrmm_outncopy\n#define\tXTRMM_OLNUCOPY\t\txtrmm_olnucopy\n#define\tXTRMM_OLNNCOPY\t\txtrmm_olnncopy\n#define\tXTRMM_OLTUCOPY\t\txtrmm_oltucopy\n#define\tXTRMM_OLTNCOPY\t\txtrmm_oltncopy\n\n#define\tXTRSM_OUNUCOPY\t\txtrsm_ounucopy\n#define\tXTRSM_OUNNCOPY\t\txtrsm_ounncopy\n#define\tXTRSM_OUTUCOPY\t\txtrsm_outucopy\n#define\tXTRSM_OUTNCOPY\t\txtrsm_outncopy\n#define\tXTRSM_OLNUCOPY\t\txtrsm_olnucopy\n#define\tXTRSM_OLNNCOPY\t\txtrsm_olnncopy\n#define\tXTRSM_OLTUCOPY\t\txtrsm_oltucopy\n#define\tXTRSM_OLTNCOPY\t\txtrsm_oltncopy\n\n#if XGEMM_DEFAULT_UNROLL_M == XGEMM_DEFAULT_UNROLL_N\n#define\tXTRMM_IUNUCOPY\t\txtrmm_ounucopy\n#define\tXTRMM_IUNNCOPY\t\txtrmm_ounncopy\n#define\tXTRMM_IUTUCOPY\t\txtrmm_outucopy\n#define\tXTRMM_IUTNCOPY\t\txtrmm_outncopy\n#define\tXTRMM_ILNUCOPY\t\txtrmm_olnucopy\n#define\tXTRMM_ILNNCOPY\t\txtrmm_olnncopy\n#define\tXTRMM_ILTUCOPY\t\txtrmm_oltucopy\n#define\tXTRMM_ILTNCOPY\t\txtrmm_oltncopy\n\n#define\tXTRSM_IUNUCOPY\t\txtrsm_ounucopy\n#define\tXTRSM_IUNNCOPY\t\txtrsm_ounncopy\n#define\tXTRSM_IUTUCOPY\t\txtrsm_outucopy\n#define\tXTRSM_IUTNCOPY\t\txtrsm_outncopy\n#define\tXTRSM_ILNUCOPY\t\txtrsm_olnucopy\n#define\tXTRSM_ILNNCOPY\t\txtrsm_olnncopy\n#define\tXTRSM_ILTUCOPY\t\txtrsm_oltucopy\n#define\tXTRSM_ILTNCOPY\t\txtrsm_oltncopy\n#else\n#define\tXTRMM_IUNUCOPY\t\txtrmm_iunucopy\n#define\tXTRMM_IUNNCOPY\t\txtrmm_iunncopy\n#define\tXTRMM_IUTUCOPY\t\txtrmm_iutucopy\n#define\tXTRMM_IUTNCOPY\t\txtrmm_iutncopy\n#define\tXTRMM_ILNUCOPY\t\txtrmm_ilnucopy\n#define\tXTRMM_ILNNCOPY\t\txtrmm_ilnncopy\n#define\tXTRMM_ILTUCOPY\t\txtrmm_iltucopy\n#define\tXTRMM_ILTNCOPY\t\txtrmm_iltncopy\n\n#define\tXTRSM_IUNUCOPY\t\txtrsm_iunucopy\n#define\tXTRSM_IUNNCOPY\t\txtrsm_iunncopy\n#define\tXTRSM_IUTUCOPY\t\txtrsm_iutucopy\n#define\tXTRSM_IUTNCOPY\t\txtrsm_iutncopy\n#define\tXTRSM_ILNUCOPY\t\txtrsm_ilnucopy\n#define\tXTRSM_ILNNCOPY\t\txtrsm_ilnncopy\n#define\tXTRSM_ILTUCOPY\t\txtrsm_iltucopy\n#define\tXTRSM_ILTNCOPY\t\txtrsm_iltncopy\n#endif\n\n#define\tXGEMM_BETA\t\txgemm_beta\n\n#define\tXGEMM_KERNEL_N\t\txgemm_kernel_n\n#define\tXGEMM_KERNEL_L\t\txgemm_kernel_l\n#define\tXGEMM_KERNEL_R\t\txgemm_kernel_r\n#define\tXGEMM_KERNEL_B\t\txgemm_kernel_b\n\n#define\tXTRMM_KERNEL_LN\t\txtrmm_kernel_LN\n#define\tXTRMM_KERNEL_LT\t\txtrmm_kernel_LT\n#define\tXTRMM_KERNEL_LR\t\txtrmm_kernel_LR\n#define\tXTRMM_KERNEL_LC\t\txtrmm_kernel_LC\n#define\tXTRMM_KERNEL_RN\t\txtrmm_kernel_RN\n#define\tXTRMM_KERNEL_RT\t\txtrmm_kernel_RT\n#define\tXTRMM_KERNEL_RR\t\txtrmm_kernel_RR\n#define\tXTRMM_KERNEL_RC\t\txtrmm_kernel_RC\n\n#define\tXTRSM_KERNEL_LN\t\txtrsm_kernel_LN\n#define\tXTRSM_KERNEL_LT\t\txtrsm_kernel_LT\n#define\tXTRSM_KERNEL_LR\t\txtrsm_kernel_LR\n#define\tXTRSM_KERNEL_LC\t\txtrsm_kernel_LC\n#define\tXTRSM_KERNEL_RN\t\txtrsm_kernel_RN\n#define\tXTRSM_KERNEL_RT\t\txtrsm_kernel_RT\n#define\tXTRSM_KERNEL_RR\t\txtrsm_kernel_RR\n#define\tXTRSM_KERNEL_RC\t\txtrsm_kernel_RC\n\n#define\tXSYMM_OUTCOPY\t\txsymm_outcopy\n#define\tXSYMM_OLTCOPY\t\txsymm_oltcopy\n#if XGEMM_DEFAULT_UNROLL_M == XGEMM_DEFAULT_UNROLL_N\n#define\tXSYMM_IUTCOPY\t\txsymm_outcopy\n#define\tXSYMM_ILTCOPY\t\txsymm_oltcopy\n#else\n#define\tXSYMM_IUTCOPY\t\txsymm_iutcopy\n#define\tXSYMM_ILTCOPY\t\txsymm_iltcopy\n#endif\n\n#define\tXHEMM_OUTCOPY\t\txhemm_outcopy\n#define\tXHEMM_OLTCOPY\t\txhemm_oltcopy\n#if XGEMM_DEFAULT_UNROLL_M == XGEMM_DEFAULT_UNROLL_N\n#define\tXHEMM_IUTCOPY\t\txhemm_outcopy\n#define\tXHEMM_ILTCOPY\t\txhemm_oltcopy\n#else\n#define\tXHEMM_IUTCOPY\t\txhemm_iutcopy\n#define\tXHEMM_ILTCOPY\t\txhemm_iltcopy\n#endif\n\n#define\tXGEMM3M_ONCOPYB\t\txgemm3m_oncopyb\n#define\tXGEMM3M_ONCOPYR\t\txgemm3m_oncopyr\n#define\tXGEMM3M_ONCOPYI\t\txgemm3m_oncopyi\n#define\tXGEMM3M_OTCOPYB\t\txgemm3m_otcopyb\n#define\tXGEMM3M_OTCOPYR\t\txgemm3m_otcopyr\n#define\tXGEMM3M_OTCOPYI\t\txgemm3m_otcopyi\n\n#define\tXGEMM3M_INCOPYB\t\txgemm3m_incopyb\n#define\tXGEMM3M_INCOPYR\t\txgemm3m_incopyr\n#define\tXGEMM3M_INCOPYI\t\txgemm3m_incopyi\n#define\tXGEMM3M_ITCOPYB\t\txgemm3m_itcopyb\n#define\tXGEMM3M_ITCOPYR\t\txgemm3m_itcopyr\n#define\tXGEMM3M_ITCOPYI\t\txgemm3m_itcopyi\n\n#define\tXSYMM3M_ILCOPYB\t\txsymm3m_ilcopyb\n#define\tXSYMM3M_IUCOPYB\t\txsymm3m_iucopyb\n#define\tXSYMM3M_ILCOPYR\t\txsymm3m_ilcopyr\n#define\tXSYMM3M_IUCOPYR\t\txsymm3m_iucopyr\n#define\tXSYMM3M_ILCOPYI\t\txsymm3m_ilcopyi\n#define\tXSYMM3M_IUCOPYI\t\txsymm3m_iucopyi\n\n#define\tXSYMM3M_OLCOPYB\t\txsymm3m_olcopyb\n#define\tXSYMM3M_OUCOPYB\t\txsymm3m_oucopyb\n#define\tXSYMM3M_OLCOPYR\t\txsymm3m_olcopyr\n#define\tXSYMM3M_OUCOPYR\t\txsymm3m_oucopyr\n#define\tXSYMM3M_OLCOPYI\t\txsymm3m_olcopyi\n#define\tXSYMM3M_OUCOPYI\t\txsymm3m_oucopyi\n\n#define\tXHEMM3M_ILCOPYB\t\txhemm3m_ilcopyb\n#define\tXHEMM3M_IUCOPYB\t\txhemm3m_iucopyb\n#define\tXHEMM3M_ILCOPYR\t\txhemm3m_ilcopyr\n#define\tXHEMM3M_IUCOPYR\t\txhemm3m_iucopyr\n#define\tXHEMM3M_ILCOPYI\t\txhemm3m_ilcopyi\n#define\tXHEMM3M_IUCOPYI\t\txhemm3m_iucopyi\n\n#define\tXHEMM3M_OLCOPYB\t\txhemm3m_olcopyb\n#define\tXHEMM3M_OUCOPYB\t\txhemm3m_oucopyb\n#define\tXHEMM3M_OLCOPYR\t\txhemm3m_olcopyr\n#define\tXHEMM3M_OUCOPYR\t\txhemm3m_oucopyr\n#define\tXHEMM3M_OLCOPYI\t\txhemm3m_olcopyi\n#define\tXHEMM3M_OUCOPYI\t\txhemm3m_oucopyi\n\n#define\tXGEMM3M_KERNEL\t\txgemm3m_kernel\n\n#define XNEG_TCOPY\t\txneg_tcopy\n#define XLASWP_NCOPY\t\txlaswp_ncopy\n\n#else\n\n#define\tXAMAX_K\t\t\tgotoblas -> xamax_k\n#define\tXAMIN_K\t\t\tgotoblas -> xamin_k\n#define\tXMAX_K\t\t\tgotoblas -> xmax_k\n#define\tXMIN_K\t\t\tgotoblas -> xmin_k\n#define\tIXAMAX_K\t\tgotoblas -> ixamax_k\n#define\tIXAMIN_K\t\tgotoblas -> ixamin_k\n#define\tIXMAX_K\t\t\tgotoblas -> ixmax_k\n#define\tIXMIN_K\t\t\tgotoblas -> ixmin_k\n#define\tXASUM_K\t\t\tgotoblas -> xasum_k\n#define\tXAXPYU_K\t\tgotoblas -> xaxpy_k\n#define\tXAXPYC_K\t\tgotoblas -> xaxpyc_k\n#define\tXCOPY_K\t\t\tgotoblas -> xcopy_k\n#define\tXDOTU_K\t\t\tgotoblas -> xdotu_k\n#define\tXDOTC_K\t\t\tgotoblas -> xdotc_k\n#define\tXNRM2_K\t\t\tgotoblas -> xnrm2_k\n#define\tXSCAL_K\t\t\tgotoblas -> xscal_k\n#define\tXSUM_K\t\t\tgotoblas -> xsum_k\n#define\tXSWAP_K\t\t\tgotoblas -> xswap_k\n#define\tXROT_K\t\t\tgotoblas -> xqrot_k\n\n#define\tXGEMV_N\t\t\tgotoblas -> xgemv_n\n#define\tXGEMV_T\t\t\tgotoblas -> xgemv_t\n#define\tXGEMV_R\t\t\tgotoblas -> xgemv_r\n#define\tXGEMV_C\t\t\tgotoblas -> xgemv_c\n#define\tXGEMV_O\t\t\tgotoblas -> xgemv_o\n#define\tXGEMV_U\t\t\tgotoblas -> xgemv_u\n#define\tXGEMV_S\t\t\tgotoblas -> xgemv_s\n#define\tXGEMV_D\t\t\tgotoblas -> xgemv_d\n\n#define\tXGERU_K\t\t\tgotoblas -> xgeru_k\n#define\tXGERC_K\t\t\tgotoblas -> xgerc_k\n#define\tXGERV_K\t\t\tgotoblas -> xgerv_k\n#define\tXGERD_K\t\t\tgotoblas -> xgerd_k\n\n#define XSYMV_U\t\t\tgotoblas -> xsymv_U\n#define XSYMV_L\t\t\tgotoblas -> xsymv_L\n#define XHEMV_U\t\t\tgotoblas -> xhemv_U\n#define XHEMV_L\t\t\tgotoblas -> xhemv_L\n#define XHEMV_V\t\t\tgotoblas -> xhemv_V\n#define XHEMV_M\t\t\tgotoblas -> xhemv_M\n\n#define XSYMV_THREAD_U\t\txsymv_thread_U\n#define XSYMV_THREAD_L\t\txsymv_thread_L\n#define XHEMV_THREAD_U\t\txhemv_thread_U\n#define XHEMV_THREAD_L\t\txhemv_thread_L\n#define XHEMV_THREAD_V\t\txhemv_thread_V\n#define XHEMV_THREAD_M\t\txhemv_thread_M\n\n#define\tXGEMM_ONCOPY\t\tgotoblas -> xgemm_oncopy\n#define\tXGEMM_OTCOPY\t\tgotoblas -> xgemm_otcopy\n#define\tXGEMM_INCOPY\t\tgotoblas -> xgemm_incopy\n#define\tXGEMM_ITCOPY\t\tgotoblas -> xgemm_itcopy\n\n#define\tXTRMM_OUNUCOPY\t\tgotoblas -> xtrmm_ounucopy\n#define\tXTRMM_OUTUCOPY\t\tgotoblas -> xtrmm_outucopy\n#define\tXTRMM_OLNUCOPY\t\tgotoblas -> xtrmm_olnucopy\n#define\tXTRMM_OLTUCOPY\t\tgotoblas -> xtrmm_oltucopy\n#define\tXTRSM_OUNUCOPY\t\tgotoblas -> xtrsm_ounucopy\n#define\tXTRSM_OUTUCOPY\t\tgotoblas -> xtrsm_outucopy\n#define\tXTRSM_OLNUCOPY\t\tgotoblas -> xtrsm_olnucopy\n#define\tXTRSM_OLTUCOPY\t\tgotoblas -> xtrsm_oltucopy\n\n#define\tXTRMM_IUNUCOPY\t\tgotoblas -> xtrmm_iunucopy\n#define\tXTRMM_IUTUCOPY\t\tgotoblas -> xtrmm_iutucopy\n#define\tXTRMM_ILNUCOPY\t\tgotoblas -> xtrmm_ilnucopy\n#define\tXTRMM_ILTUCOPY\t\tgotoblas -> xtrmm_iltucopy\n#define\tXTRSM_IUNUCOPY\t\tgotoblas -> xtrsm_iunucopy\n#define\tXTRSM_IUTUCOPY\t\tgotoblas -> xtrsm_iutucopy\n#define\tXTRSM_ILNUCOPY\t\tgotoblas -> xtrsm_ilnucopy\n#define\tXTRSM_ILTUCOPY\t\tgotoblas -> xtrsm_iltucopy\n\n#define\tXTRMM_OUNNCOPY\t\tgotoblas -> xtrmm_ounncopy\n#define\tXTRMM_OUTNCOPY\t\tgotoblas -> xtrmm_outncopy\n#define\tXTRMM_OLNNCOPY\t\tgotoblas -> xtrmm_olnncopy\n#define\tXTRMM_OLTNCOPY\t\tgotoblas -> xtrmm_oltncopy\n#define\tXTRSM_OUNNCOPY\t\tgotoblas -> xtrsm_ounncopy\n#define\tXTRSM_OUTNCOPY\t\tgotoblas -> xtrsm_outncopy\n#define\tXTRSM_OLNNCOPY\t\tgotoblas -> xtrsm_olnncopy\n#define\tXTRSM_OLTNCOPY\t\tgotoblas -> xtrsm_oltncopy\n\n#define\tXTRMM_IUNNCOPY\t\tgotoblas -> xtrmm_iunncopy\n#define\tXTRMM_IUTNCOPY\t\tgotoblas -> xtrmm_iutncopy\n#define\tXTRMM_ILNNCOPY\t\tgotoblas -> xtrmm_ilnncopy\n#define\tXTRMM_ILTNCOPY\t\tgotoblas -> xtrmm_iltncopy\n#define\tXTRSM_IUNNCOPY\t\tgotoblas -> xtrsm_iunncopy\n#define\tXTRSM_IUTNCOPY\t\tgotoblas -> xtrsm_iutncopy\n#define\tXTRSM_ILNNCOPY\t\tgotoblas -> xtrsm_ilnncopy\n#define\tXTRSM_ILTNCOPY\t\tgotoblas -> xtrsm_iltncopy\n\n#define\tXGEMM_BETA\t\tgotoblas -> xgemm_beta\n#define\tXGEMM_KERNEL_N\t\tgotoblas -> xgemm_kernel_n\n#define\tXGEMM_KERNEL_L\t\tgotoblas -> xgemm_kernel_l\n#define\tXGEMM_KERNEL_R\t\tgotoblas -> xgemm_kernel_r\n#define\tXGEMM_KERNEL_B\t\tgotoblas -> xgemm_kernel_b\n\n#define\tXTRMM_KERNEL_LN\t\tgotoblas -> xtrmm_kernel_LN\n#define\tXTRMM_KERNEL_LT\t\tgotoblas -> xtrmm_kernel_LT\n#define\tXTRMM_KERNEL_LR\t\tgotoblas -> xtrmm_kernel_LR\n#define\tXTRMM_KERNEL_LC\t\tgotoblas -> xtrmm_kernel_LC\n#define\tXTRMM_KERNEL_RN\t\tgotoblas -> xtrmm_kernel_RN\n#define\tXTRMM_KERNEL_RT\t\tgotoblas -> xtrmm_kernel_RT\n#define\tXTRMM_KERNEL_RR\t\tgotoblas -> xtrmm_kernel_RR\n#define\tXTRMM_KERNEL_RC\t\tgotoblas -> xtrmm_kernel_RC\n\n#define\tXTRSM_KERNEL_LN\t\tgotoblas -> xtrsm_kernel_LN\n#define\tXTRSM_KERNEL_LT\t\tgotoblas -> xtrsm_kernel_LT\n#define\tXTRSM_KERNEL_LR\t\tgotoblas -> xtrsm_kernel_LR\n#define\tXTRSM_KERNEL_LC\t\tgotoblas -> xtrsm_kernel_LC\n#define\tXTRSM_KERNEL_RN\t\tgotoblas -> xtrsm_kernel_RN\n#define\tXTRSM_KERNEL_RT\t\tgotoblas -> xtrsm_kernel_RT\n#define\tXTRSM_KERNEL_RR\t\tgotoblas -> xtrsm_kernel_RR\n#define\tXTRSM_KERNEL_RC\t\tgotoblas -> xtrsm_kernel_RC\n\n#define\tXSYMM_IUTCOPY\t\tgotoblas -> xsymm_iutcopy\n#define\tXSYMM_ILTCOPY\t\tgotoblas -> xsymm_iltcopy\n#define\tXSYMM_OUTCOPY\t\tgotoblas -> xsymm_outcopy\n#define\tXSYMM_OLTCOPY\t\tgotoblas -> xsymm_oltcopy\n\n#define\tXHEMM_OUTCOPY\t\tgotoblas -> xhemm_outcopy\n#define\tXHEMM_OLTCOPY\t\tgotoblas -> xhemm_oltcopy\n#define\tXHEMM_IUTCOPY\t\tgotoblas -> xhemm_iutcopy\n#define\tXHEMM_ILTCOPY\t\tgotoblas -> xhemm_iltcopy\n\n#define\tXGEMM3M_ONCOPYB\t\tgotoblas -> xgemm3m_oncopyb\n#define\tXGEMM3M_ONCOPYR\t\tgotoblas -> xgemm3m_oncopyr\n#define\tXGEMM3M_ONCOPYI\t\tgotoblas -> xgemm3m_oncopyi\n#define\tXGEMM3M_OTCOPYB\t\tgotoblas -> xgemm3m_otcopyb\n#define\tXGEMM3M_OTCOPYR\t\tgotoblas -> xgemm3m_otcopyr\n#define\tXGEMM3M_OTCOPYI\t\tgotoblas -> xgemm3m_otcopyi\n\n#define\tXGEMM3M_INCOPYB\t\tgotoblas -> xgemm3m_incopyb\n#define\tXGEMM3M_INCOPYR\t\tgotoblas -> xgemm3m_incopyr\n#define\tXGEMM3M_INCOPYI\t\tgotoblas -> xgemm3m_incopyi\n#define\tXGEMM3M_ITCOPYB\t\tgotoblas -> xgemm3m_itcopyb\n#define\tXGEMM3M_ITCOPYR\t\tgotoblas -> xgemm3m_itcopyr\n#define\tXGEMM3M_ITCOPYI\t\tgotoblas -> xgemm3m_itcopyi\n\n#define\tXSYMM3M_ILCOPYB\t\tgotoblas -> xsymm3m_ilcopyb\n#define\tXSYMM3M_IUCOPYB\t\tgotoblas -> xsymm3m_iucopyb\n#define\tXSYMM3M_ILCOPYR\t\tgotoblas -> xsymm3m_ilcopyr\n#define\tXSYMM3M_IUCOPYR\t\tgotoblas -> xsymm3m_iucopyr\n#define\tXSYMM3M_ILCOPYI\t\tgotoblas -> xsymm3m_ilcopyi\n#define\tXSYMM3M_IUCOPYI\t\tgotoblas -> xsymm3m_iucopyi\n\n#define\tXSYMM3M_OLCOPYB\t\tgotoblas -> xsymm3m_olcopyb\n#define\tXSYMM3M_OUCOPYB\t\tgotoblas -> xsymm3m_oucopyb\n#define\tXSYMM3M_OLCOPYR\t\tgotoblas -> xsymm3m_olcopyr\n#define\tXSYMM3M_OUCOPYR\t\tgotoblas -> xsymm3m_oucopyr\n#define\tXSYMM3M_OLCOPYI\t\tgotoblas -> xsymm3m_olcopyi\n#define\tXSYMM3M_OUCOPYI\t\tgotoblas -> xsymm3m_oucopyi\n\n#define\tXHEMM3M_ILCOPYB\t\tgotoblas -> xhemm3m_ilcopyb\n#define\tXHEMM3M_IUCOPYB\t\tgotoblas -> xhemm3m_iucopyb\n#define\tXHEMM3M_ILCOPYR\t\tgotoblas -> xhemm3m_ilcopyr\n#define\tXHEMM3M_IUCOPYR\t\tgotoblas -> xhemm3m_iucopyr\n#define\tXHEMM3M_ILCOPYI\t\tgotoblas -> xhemm3m_ilcopyi\n#define\tXHEMM3M_IUCOPYI\t\tgotoblas -> xhemm3m_iucopyi\n\n#define\tXHEMM3M_OLCOPYB\t\tgotoblas -> xhemm3m_olcopyb\n#define\tXHEMM3M_OUCOPYB\t\tgotoblas -> xhemm3m_oucopyb\n#define\tXHEMM3M_OLCOPYR\t\tgotoblas -> xhemm3m_olcopyr\n#define\tXHEMM3M_OUCOPYR\t\tgotoblas -> xhemm3m_oucopyr\n#define\tXHEMM3M_OLCOPYI\t\tgotoblas -> xhemm3m_olcopyi\n#define\tXHEMM3M_OUCOPYI\t\tgotoblas -> xhemm3m_oucopyi\n\n#define\tXGEMM3M_KERNEL\t\tgotoblas -> xgemm3m_kernel\n\n#define XNEG_TCOPY\t\tgotoblas -> xneg_tcopy\n#define XLASWP_NCOPY\t\tgotoblas -> xlaswp_ncopy\n\n#endif\n\n#define\tXGEMM_NN\t\txgemm_nn\n#define\tXGEMM_CN\t\txgemm_cn\n#define\tXGEMM_TN\t\txgemm_tn\n#define\tXGEMM_NC\t\txgemm_nc\n#define\tXGEMM_NT\t\txgemm_nt\n#define\tXGEMM_CC\t\txgemm_cc\n#define\tXGEMM_CT\t\txgemm_ct\n#define\tXGEMM_TC\t\txgemm_tc\n#define\tXGEMM_TT\t\txgemm_tt\n#define\tXGEMM_NR\t\txgemm_nr\n#define\tXGEMM_TR\t\txgemm_tr\n#define\tXGEMM_CR\t\txgemm_cr\n#define\tXGEMM_RN\t\txgemm_rn\n#define\tXGEMM_RT\t\txgemm_rt\n#define\tXGEMM_RC\t\txgemm_rc\n#define\tXGEMM_RR\t\txgemm_rr\n\n#define\tXSYMM_LU\t\txsymm_LU\n#define\tXSYMM_LL\t\txsymm_LL\n#define\tXSYMM_RU\t\txsymm_RU\n#define\tXSYMM_RL\t\txsymm_RL\n\n#define\tXHEMM_LU\t\txhemm_LU\n#define\tXHEMM_LL\t\txhemm_LL\n#define\tXHEMM_RU\t\txhemm_RU\n#define\tXHEMM_RL\t\txhemm_RL\n\n#define\tXSYRK_UN\t\txsyrk_UN\n#define\tXSYRK_UT\t\txsyrk_UT\n#define\tXSYRK_LN\t\txsyrk_LN\n#define\tXSYRK_LT\t\txsyrk_LT\n#define\tXSYRK_UR\t\txsyrk_UN\n#define\tXSYRK_UC\t\txsyrk_UT\n#define\tXSYRK_LR\t\txsyrk_LN\n#define\tXSYRK_LC\t\txsyrk_LT\n\n#define\tXSYRK_KERNEL_U\t\txsyrk_kernel_U\n#define\tXSYRK_KERNEL_L\t\txsyrk_kernel_L\n\n#define\tXHERK_UN\t\txherk_UN\n#define\tXHERK_LN\t\txherk_LN\n#define\tXHERK_UC\t\txherk_UC\n#define\tXHERK_LC\t\txherk_LC\n\n#define\tXHER2K_UN\t\txher2k_UN\n#define\tXHER2K_LN\t\txher2k_LN\n#define\tXHER2K_UC\t\txher2k_UC\n#define\tXHER2K_LC\t\txher2k_LC\n\n#define\tXSYR2K_UN\t\txsyr2k_UN\n#define\tXSYR2K_UT\t\txsyr2k_UT\n#define\tXSYR2K_LN\t\txsyr2k_LN\n#define\tXSYR2K_LT\t\txsyr2k_LT\n#define\tXSYR2K_UR\t\txsyr2k_UN\n#define\tXSYR2K_UC\t\txsyr2k_UT\n#define\tXSYR2K_LR\t\txsyr2k_LN\n#define\tXSYR2K_LC\t\txsyr2k_LT\n\n#define\tXSYR2K_KERNEL_U\t\txsyr2k_kernel_U\n#define\tXSYR2K_KERNEL_L\t\txsyr2k_kernel_L\n\n#define\tXTRMM_LNUU\t\txtrmm_LNUU\n#define\tXTRMM_LNUN\t\txtrmm_LNUN\n#define\tXTRMM_LNLU\t\txtrmm_LNLU\n#define\tXTRMM_LNLN\t\txtrmm_LNLN\n#define\tXTRMM_LTUU\t\txtrmm_LTUU\n#define\tXTRMM_LTUN\t\txtrmm_LTUN\n#define\tXTRMM_LTLU\t\txtrmm_LTLU\n#define\tXTRMM_LTLN\t\txtrmm_LTLN\n#define\tXTRMM_LRUU\t\txtrmm_LRUU\n#define\tXTRMM_LRUN\t\txtrmm_LRUN\n#define\tXTRMM_LRLU\t\txtrmm_LRLU\n#define\tXTRMM_LRLN\t\txtrmm_LRLN\n#define\tXTRMM_LCUU\t\txtrmm_LCUU\n#define\tXTRMM_LCUN\t\txtrmm_LCUN\n#define\tXTRMM_LCLU\t\txtrmm_LCLU\n#define\tXTRMM_LCLN\t\txtrmm_LCLN\n#define\tXTRMM_RNUU\t\txtrmm_RNUU\n#define\tXTRMM_RNUN\t\txtrmm_RNUN\n#define\tXTRMM_RNLU\t\txtrmm_RNLU\n#define\tXTRMM_RNLN\t\txtrmm_RNLN\n#define\tXTRMM_RTUU\t\txtrmm_RTUU\n#define\tXTRMM_RTUN\t\txtrmm_RTUN\n#define\tXTRMM_RTLU\t\txtrmm_RTLU\n#define\tXTRMM_RTLN\t\txtrmm_RTLN\n#define\tXTRMM_RRUU\t\txtrmm_RRUU\n#define\tXTRMM_RRUN\t\txtrmm_RRUN\n#define\tXTRMM_RRLU\t\txtrmm_RRLU\n#define\tXTRMM_RRLN\t\txtrmm_RRLN\n#define\tXTRMM_RCUU\t\txtrmm_RCUU\n#define\tXTRMM_RCUN\t\txtrmm_RCUN\n#define\tXTRMM_RCLU\t\txtrmm_RCLU\n#define\tXTRMM_RCLN\t\txtrmm_RCLN\n\n#define\tXTRSM_LNUU\t\txtrsm_LNUU\n#define\tXTRSM_LNUN\t\txtrsm_LNUN\n#define\tXTRSM_LNLU\t\txtrsm_LNLU\n#define\tXTRSM_LNLN\t\txtrsm_LNLN\n#define\tXTRSM_LTUU\t\txtrsm_LTUU\n#define\tXTRSM_LTUN\t\txtrsm_LTUN\n#define\tXTRSM_LTLU\t\txtrsm_LTLU\n#define\tXTRSM_LTLN\t\txtrsm_LTLN\n#define\tXTRSM_LRUU\t\txtrsm_LRUU\n#define\tXTRSM_LRUN\t\txtrsm_LRUN\n#define\tXTRSM_LRLU\t\txtrsm_LRLU\n#define\tXTRSM_LRLN\t\txtrsm_LRLN\n#define\tXTRSM_LCUU\t\txtrsm_LCUU\n#define\tXTRSM_LCUN\t\txtrsm_LCUN\n#define\tXTRSM_LCLU\t\txtrsm_LCLU\n#define\tXTRSM_LCLN\t\txtrsm_LCLN\n#define\tXTRSM_RNUU\t\txtrsm_RNUU\n#define\tXTRSM_RNUN\t\txtrsm_RNUN\n#define\tXTRSM_RNLU\t\txtrsm_RNLU\n#define\tXTRSM_RNLN\t\txtrsm_RNLN\n#define\tXTRSM_RTUU\t\txtrsm_RTUU\n#define\tXTRSM_RTUN\t\txtrsm_RTUN\n#define\tXTRSM_RTLU\t\txtrsm_RTLU\n#define\tXTRSM_RTLN\t\txtrsm_RTLN\n#define\tXTRSM_RRUU\t\txtrsm_RRUU\n#define\tXTRSM_RRUN\t\txtrsm_RRUN\n#define\tXTRSM_RRLU\t\txtrsm_RRLU\n#define\tXTRSM_RRLN\t\txtrsm_RRLN\n#define\tXTRSM_RCUU\t\txtrsm_RCUU\n#define\tXTRSM_RCUN\t\txtrsm_RCUN\n#define\tXTRSM_RCLU\t\txtrsm_RCLU\n#define\tXTRSM_RCLN\t\txtrsm_RCLN\n\n#define\tXGEMM_THREAD_NN\t\txgemm_thread_nn\n#define\tXGEMM_THREAD_CN\t\txgemm_thread_cn\n#define\tXGEMM_THREAD_TN\t\txgemm_thread_tn\n#define\tXGEMM_THREAD_NC\t\txgemm_thread_nc\n#define\tXGEMM_THREAD_NT\t\txgemm_thread_nt\n#define\tXGEMM_THREAD_CC\t\txgemm_thread_cc\n#define\tXGEMM_THREAD_CT\t\txgemm_thread_ct\n#define\tXGEMM_THREAD_TC\t\txgemm_thread_tc\n#define\tXGEMM_THREAD_TT\t\txgemm_thread_tt\n#define\tXGEMM_THREAD_NR\t\txgemm_thread_nr\n#define\tXGEMM_THREAD_TR\t\txgemm_thread_tr\n#define\tXGEMM_THREAD_CR\t\txgemm_thread_cr\n#define\tXGEMM_THREAD_RN\t\txgemm_thread_rn\n#define\tXGEMM_THREAD_RT\t\txgemm_thread_rt\n#define\tXGEMM_THREAD_RC\t\txgemm_thread_rc\n#define\tXGEMM_THREAD_RR\t\txgemm_thread_rr\n\n#define\tXSYMM_THREAD_LU\t\txsymm_thread_LU\n#define\tXSYMM_THREAD_LL\t\txsymm_thread_LL\n#define\tXSYMM_THREAD_RU\t\txsymm_thread_RU\n#define\tXSYMM_THREAD_RL\t\txsymm_thread_RL\n\n#define\tXHEMM_THREAD_LU\t\txhemm_thread_LU\n#define\tXHEMM_THREAD_LL\t\txhemm_thread_LL\n#define\tXHEMM_THREAD_RU\t\txhemm_thread_RU\n#define\tXHEMM_THREAD_RL\t\txhemm_thread_RL\n\n#define\tXSYRK_THREAD_UN\t\txsyrk_thread_UN\n#define\tXSYRK_THREAD_UT\t\txsyrk_thread_UT\n#define\tXSYRK_THREAD_LN\t\txsyrk_thread_LN\n#define\tXSYRK_THREAD_LT\t\txsyrk_thread_LT\n#define\tXSYRK_THREAD_UR\t\txsyrk_thread_UN\n#define\tXSYRK_THREAD_UC\t\txsyrk_thread_UT\n#define\tXSYRK_THREAD_LR\t\txsyrk_thread_LN\n#define\tXSYRK_THREAD_LC\t\txsyrk_thread_LT\n\n#define\tXHERK_THREAD_UN\t\txherk_thread_UN\n#define\tXHERK_THREAD_UT\t\txherk_thread_UT\n#define\tXHERK_THREAD_LN\t\txherk_thread_LN\n#define\tXHERK_THREAD_LT\t\txherk_thread_LT\n#define\tXHERK_THREAD_UR\t\txherk_thread_UR\n#define\tXHERK_THREAD_UC\t\txherk_thread_UC\n#define\tXHERK_THREAD_LR\t\txherk_thread_LR\n#define\tXHERK_THREAD_LC\t\txherk_thread_LC\n\n#define\tXGEMM3M_NN\t\txgemm3m_nn\n#define\tXGEMM3M_CN\t\txgemm3m_cn\n#define\tXGEMM3M_TN\t\txgemm3m_tn\n#define\tXGEMM3M_NC\t\txgemm3m_nc\n#define\tXGEMM3M_NT\t\txgemm3m_nt\n#define\tXGEMM3M_CC\t\txgemm3m_cc\n#define\tXGEMM3M_CT\t\txgemm3m_ct\n#define\tXGEMM3M_TC\t\txgemm3m_tc\n#define\tXGEMM3M_TT\t\txgemm3m_tt\n#define\tXGEMM3M_NR\t\txgemm3m_nr\n#define\tXGEMM3M_TR\t\txgemm3m_tr\n#define\tXGEMM3M_CR\t\txgemm3m_cr\n#define\tXGEMM3M_RN\t\txgemm3m_rn\n#define\tXGEMM3M_RT\t\txgemm3m_rt\n#define\tXGEMM3M_RC\t\txgemm3m_rc\n#define\tXGEMM3M_RR\t\txgemm3m_rr\n\n#define\tXGEMM3M_THREAD_NN\txgemm3m_thread_nn\n#define\tXGEMM3M_THREAD_CN\txgemm3m_thread_cn\n#define\tXGEMM3M_THREAD_TN\txgemm3m_thread_tn\n#define\tXGEMM3M_THREAD_NC\txgemm3m_thread_nc\n#define\tXGEMM3M_THREAD_NT\txgemm3m_thread_nt\n#define\tXGEMM3M_THREAD_CC\txgemm3m_thread_cc\n#define\tXGEMM3M_THREAD_CT\txgemm3m_thread_ct\n#define\tXGEMM3M_THREAD_TC\txgemm3m_thread_tc\n#define\tXGEMM3M_THREAD_TT\txgemm3m_thread_tt\n#define\tXGEMM3M_THREAD_NR\txgemm3m_thread_nr\n#define\tXGEMM3M_THREAD_TR\txgemm3m_thread_tr\n#define\tXGEMM3M_THREAD_CR\txgemm3m_thread_cr\n#define\tXGEMM3M_THREAD_RN\txgemm3m_thread_rn\n#define\tXGEMM3M_THREAD_RT\txgemm3m_thread_rt\n#define\tXGEMM3M_THREAD_RC\txgemm3m_thread_rc\n#define\tXGEMM3M_THREAD_RR\txgemm3m_thread_rr\n\n#define\tXSYMM3M_LU\t\txsymm3m_LU\n#define\tXSYMM3M_LL\t\txsymm3m_LL\n#define\tXSYMM3M_RU\t\txsymm3m_RU\n#define\tXSYMM3M_RL\t\txsymm3m_RL\n\n#define\tXSYMM3M_THREAD_LU\txsymm3m_thread_LU\n#define\tXSYMM3M_THREAD_LL\txsymm3m_thread_LL\n#define\tXSYMM3M_THREAD_RU\txsymm3m_thread_RU\n#define\tXSYMM3M_THREAD_RL\txsymm3m_thread_RL\n\n#define\tXHEMM3M_LU\t\txhemm3m_LU\n#define\tXHEMM3M_LL\t\txhemm3m_LL\n#define\tXHEMM3M_RU\t\txhemm3m_RU\n#define\tXHEMM3M_RL\t\txhemm3m_RL\n\n#define\tXHEMM3M_THREAD_LU\txhemm3m_thread_LU\n#define\tXHEMM3M_THREAD_LL\txhemm3m_thread_LL\n#define\tXHEMM3M_THREAD_RU\txhemm3m_thread_RU\n#define\tXHEMM3M_THREAD_RL\txhemm3m_thread_RL\n\n#endif\n"
        },
        {
          "name": "common_x86.h",
          "type": "blob",
          "size": 9.9609375,
          "content": "/*********************************************************************/\n/* Copyright 2009, 2010 The University of Texas at Austin.           */\n/* All rights reserved.                                              */\n/*                                                                   */\n/* Redistribution and use in source and binary forms, with or        */\n/* without modification, are permitted provided that the following   */\n/* conditions are met:                                               */\n/*                                                                   */\n/*   1. Redistributions of source code must retain the above         */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer.                                                  */\n/*                                                                   */\n/*   2. Redistributions in binary form must reproduce the above      */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer in the documentation and/or other materials       */\n/*      provided with the distribution.                              */\n/*                                                                   */\n/*    THIS  SOFTWARE IS PROVIDED  BY THE  UNIVERSITY OF  TEXAS AT    */\n/*    AUSTIN  ``AS IS''  AND ANY  EXPRESS OR  IMPLIED WARRANTIES,    */\n/*    INCLUDING, BUT  NOT LIMITED  TO, THE IMPLIED  WARRANTIES OF    */\n/*    MERCHANTABILITY  AND FITNESS FOR  A PARTICULAR  PURPOSE ARE    */\n/*    DISCLAIMED.  IN  NO EVENT SHALL THE UNIVERSITY  OF TEXAS AT    */\n/*    AUSTIN OR CONTRIBUTORS BE  LIABLE FOR ANY DIRECT, INDIRECT,    */\n/*    INCIDENTAL,  SPECIAL, EXEMPLARY,  OR  CONSEQUENTIAL DAMAGES    */\n/*    (INCLUDING, BUT  NOT LIMITED TO,  PROCUREMENT OF SUBSTITUTE    */\n/*    GOODS  OR  SERVICES; LOSS  OF  USE,  DATA,  OR PROFITS;  OR    */\n/*    BUSINESS INTERRUPTION) HOWEVER CAUSED  AND ON ANY THEORY OF    */\n/*    LIABILITY, WHETHER  IN CONTRACT, STRICT  LIABILITY, OR TORT    */\n/*    (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY WAY OUT    */\n/*    OF  THE  USE OF  THIS  SOFTWARE,  EVEN  IF ADVISED  OF  THE    */\n/*    POSSIBILITY OF SUCH DAMAGE.                                    */\n/*                                                                   */\n/* The views and conclusions contained in the software and           */\n/* documentation are those of the authors and should not be          */\n/* interpreted as representing official policies, either expressed   */\n/* or implied, of The University of Texas at Austin.                 */\n/*********************************************************************/\n\n#ifndef COMMON_X86\n#define COMMON_X86\n\n#ifndef ASSEMBLER\n\n#ifdef C_MSVC\n#include <intrin.h>\n#endif\n\n#define MB\n#define WMB\n#define RMB\n\n#ifdef C_SUN\n#define\t__asm__ __asm\n#define\t__volatile__\n#endif\n\nstatic __inline void blas_lock(volatile BLASULONG *address){\n\n  int ret;\n\n  do {\n    while (*address) {YIELDING;};\n\n#if defined(_MSC_VER) && !defined(__clang__)\n\t// use intrinsic instead of inline assembly\n\tret = _InterlockedExchange((volatile LONG *)address, 1);\n\t// inline assembly\n\t/*__asm {\n\t\tmov eax, address\n\t\tmov ebx, 1\n\t\txchg [eax], ebx\n\t\tmov ret, ebx\n\t}*/\n#else\n    __asm__ __volatile__(\n\t\t\t \"xchgl %0, %1\\n\"\n\t\t\t : \"=r\"(ret), \"=m\"(*address)\n\t\t\t : \"0\"(1), \"m\"(*address)\n\t\t\t : \"memory\");\n#endif\n\n  } while (ret);\n\n}\n#define BLAS_LOCK_DEFINED\n\nstatic __inline unsigned long long rpcc(void){\n#if defined(_MSC_VER) && !defined(__clang__)\n  return __rdtsc(); // use MSVC intrinsic\n#else\n  unsigned int a, d;\n\n  __asm__ __volatile__ (\"rdtsc\" : \"=a\" (a), \"=d\" (d));\n\n  return ((unsigned long long)a + ((unsigned long long)d << 32));\n#endif\n};\n#define RPCC_DEFINED\n\nstatic __inline unsigned long getstackaddr(void){\n#if defined(_MSC_VER) && !defined(__clang__)\n  return (unsigned long)_ReturnAddress(); // use MSVC intrinsic\n#else\n  unsigned long addr;\n\n  __asm__ __volatile__ (\"mov %%esp, %0\"\n\t\t\t : \"=r\"(addr) : : \"memory\");\n\n  return addr;\n#endif\n};\n\n\nstatic __inline long double sqrt_long(long double val) {\n#if defined(_MSC_VER) && !defined(__clang__)\n  return sqrt(val); // not sure if this will use fsqrt\n#else\n  long double result;\n\n  __asm__ __volatile__ (\"fldt %1\\n\"\n\t\t    \"fsqrt\\n\"\n\t\t    \"fstpt %0\\n\" : \"=m\" (result) : \"m\"(val));\n  return result;\n#endif\n}\n\n#define SQRT(a)  sqrt_long(a)\n\n/* This is due to gcc's bug */\nvoid cpuid(int op, int *eax, int *ebx, int *ecx, int *edx);\n\n#define WHEREAMI\n\nstatic __inline int WhereAmI(void){\n  int eax, ebx, ecx, edx;\n  int apicid;\n\n  cpuid(1, &eax, &ebx, &ecx, &edx);\n  apicid  = BITMASK(ebx, 24, 0xff);\n\n  return apicid;\n}\n\n#ifdef ENABLE_SSE_EXCEPTION\n\n#define IDEBUG_START \\\n{ \\\n  unsigned int fp_sse_mode, new_fp_mode; \\\n  __asm__ __volatile__ (\"stmxcsr %0\" : \"=m\" (fp_sse_mode) : ); \\\n  new_fp_mode = fp_sse_mode & ~0xd00; \\\n  __asm__ __volatile__ (\"ldmxcsr %0\" : : \"m\" (new_fp_mode) );\n\n#define IDEBUG_END \\\n  __asm__ __volatile__ (\"ldmxcsr %0\" : : \"m\" (fp_sse_mode) ); \\\n}\n\n#endif\n\n#ifdef XDOUBLE\n#define GET_IMAGE(res)  __asm__ __volatile__(\"fstpt %0\" : \"=m\"(res) : : \"memory\")\n#elif defined(DOUBLE)\n#define GET_IMAGE(res)  __asm__ __volatile__(\"fstpl %0\" : \"=m\"(res) : : \"memory\")\n#else\n#define GET_IMAGE(res)  __asm__ __volatile__(\"fstps %0\" : \"=m\"(res) : : \"memory\");\n#endif\n\n#define GET_IMAGE_CANCEL\t__asm__ __volatile__ (\"ffree %st\")\n\n#ifdef SMP\nextern unsigned int blas_quick_divide_table[];\n\nstatic __inline int blas_quickdivide(unsigned int x, unsigned int y){\n\n  unsigned int result;\n\n  if (y <= 1) return x;\n\n#if defined(_MSC_VER) && !defined(__clang__)\n  result = x/y;\n  return result;\n#else\n#if (MAX_CPU_NUMBER > 64)\n  if ( y > 64) {\n\t  result = x/y;\n\t  return result;\n  }\n#endif\n\t\n  y = blas_quick_divide_table[y];\n\n  __asm__ __volatile__  (\"mull %0\" :\"=d\" (result), \"+a\"(x): \"0\" (y));\n\n  return result;\n#endif\n}\n#endif\n\n#endif\n\n#ifndef PAGESIZE\n#define PAGESIZE\t( 4 << 10)\n#endif\n#define HUGE_PAGESIZE\t( 4 << 20)\n\n#define BUFFER_SIZE\t(16 << 20)\n\n#define SEEK_ADDRESS\n\n#if defined(DOUBLE) || defined(XDOUBLE)\n#define\tMMXLOAD\t\tmovq\n#define MMXSTORE\tmovq\n#else\n#define MMXLOAD\t\tmovd\n#define MMXSTORE\tmovd\n#endif\n\n#if defined(PILEDRIVER) || defined(BULLDOZER) || defined(STEAMROLLER) || defined(EXCAVATOR)\n//Enable some optimization for barcelona.\n#define BARCELONA_OPTIMIZATION\n#endif\n\n#if defined(HAVE_3DNOW)\n#define EMMS\tfemms\n#elif defined(HAVE_MMX)\n#define EMMS\temms\n#endif\n\n#ifndef EMMS\n#define EMMS\n#endif\n\n#if defined(CORE2) || defined(PENTIUM4)\n#define movapd\tmovaps\n#endif\n\n#define BRANCH\t\t.byte 0x3e\n#define NOBRANCH\t.byte 0x2e\n#define PADDING\t\t.byte 0x66;\n#define HALT\t\thlt\n\n#ifndef COMPLEX\n#ifdef XDOUBLE\n#define LOCAL_BUFFER_SIZE  QLOCAL_BUFFER_SIZE\n#elif defined DOUBLE\n#define LOCAL_BUFFER_SIZE  DLOCAL_BUFFER_SIZE\n#else\n#define LOCAL_BUFFER_SIZE  SLOCAL_BUFFER_SIZE\n#endif\n#else\n#ifdef XDOUBLE\n#define LOCAL_BUFFER_SIZE  XLOCAL_BUFFER_SIZE\n#elif defined DOUBLE\n#define LOCAL_BUFFER_SIZE  ZLOCAL_BUFFER_SIZE\n#else\n#define LOCAL_BUFFER_SIZE  CLOCAL_BUFFER_SIZE\n#endif\n#endif\n\n#if defined(OS_WINDOWS)\n#if   LOCAL_BUFFER_SIZE > 16384\n#define STACK_TOUCHING \\\n\tmovl\t$0,  4096 * 4(%esp);\\\n\tmovl\t$0,  4096 * 3(%esp);\\\n\tmovl\t$0,  4096 * 2(%esp);\\\n\tmovl\t$0,  4096 * 1(%esp);\n#elif LOCAL_BUFFER_SIZE > 12288\n#define STACK_TOUCHING \\\n\tmovl\t$0,  4096 * 3(%esp);\\\n\tmovl\t$0,  4096 * 2(%esp);\\\n\tmovl\t$0,  4096 * 1(%esp);\n#elif LOCAL_BUFFER_SIZE > 8192\n#define STACK_TOUCHING \\\n\tmovl\t$0,  4096 * 2(%esp);\\\n\tmovl\t$0,  4096 * 1(%esp);\n#elif LOCAL_BUFFER_SIZE > 4096\n#define STACK_TOUCHING \\\n\tmovl\t$0,  4096 * 1(%esp);\n#else\n#define STACK_TOUCHING\n#endif\n#else\n#define STACK_TOUCHING\n#endif\n\n#ifndef F_INTERFACE\n#define REALNAME ASMNAME\n#else\n#define REALNAME ASMFNAME\n#endif\n\n#if defined(F_INTERFACE_PATHSCALE) || defined(F_INTERFACE_OPEN64)\n#define RETURN_BY_STRUCT\n#elif defined(F_INTERFACE_GFORT) || defined(F_INTERFACE_G95)\n#define RETURN_BY_COMPLEX\n#else\n#define RETURN_BY_STACK\n#endif\n\n#ifdef OS_DARWIN\n#define PROLOGUE .text;.align 5; .globl REALNAME; REALNAME:\n#define EPILOGUE\t.subsections_via_symbols\n#define PROFCODE\n#endif\n\n#if defined(OS_WINNT) || defined(OS_CYGWIN_NT) || defined(OS_INTERIX)\n#define SAVEREGISTERS \\\n\tsubl\t$32, %esp;\\\n\tmovups\t%xmm6,    0(%esp);\\\n\tmovups\t%xmm7,   16(%esp)\n\n#define RESTOREREGISTERS \\\n\tmovups\t   0(%esp), %xmm6;\\\n\tmovups\t  16(%esp), %xmm7;\\\n\taddl\t$32, %esp\n#else\n#define SAVEREGISTERS\n#define RESTOREREGISTERS\n#endif\n\n#if defined(OS_WINNT) || defined(OS_CYGWIN_NT) || defined(OS_INTERIX)\n#define PROLOGUE \\\n\t.text; \\\n\t.align 16; \\\n\t.globl REALNAME ;\\\n\t.def REALNAME;.scl\t2;.type\t32;.endef; \\\nREALNAME:\n\n#define PROFCODE\n\n#ifdef __clang__\n#define EPILOGUE .end\n#else\n#define EPILOGUE .end\t REALNAME\n#endif\n#endif\n\n#if defined(OS_LINUX) || defined(OS_FREEBSD) || defined(OS_NETBSD) || defined(OS_OPENBSD) || defined(__ELF__)\n#define PROLOGUE \\\n\t.text; \\\n\t.align 16; \\\n\t.globl REALNAME ;\\\n       .type REALNAME, @function; \\\nREALNAME: \\\n\t_CET_ENDBR\n\n#ifdef PROFILE\n#define PROFCODE call mcount\n#else\n#define PROFCODE\n#endif\n\n#define EPILOGUE \\\n        .size\t REALNAME, .-REALNAME; \\\n        .section .note.GNU-stack,\"\",@progbits\n\n#endif\n\n#ifdef XDOUBLE\n#define FLD\tfldt\n#define FST\tfstpt\n#define FSTU\tfstt\n#define FMUL\tfmult\n#define FADD\tfaddt\n#define FSUB\tfsubt\n#define FSUBR\tfsubrt\n#elif defined(DOUBLE)\n#define FLD\tfldl\n#define FST\tfstpl\n#define FSTU\tfstl\n#define FMUL\tfmull\n#define FADD\tfaddl\n#define FSUB\tfsubl\n#define FSUBR\tfsubrl\n#else\n#define FLD\tflds\n#define FST\tfstps\n#define FSTU\tfsts\n#define FMUL\tfmuls\n#define FADD\tfadds\n#define FSUB\tfsubs\n#define FSUBR\tfsubrs\n#endif\n#endif\n\n#ifdef C_SUN\n#define\tffreep\tfstp\n#endif\n\n#ifdef __APPLE__\n#define ALIGN_2 .align 2\n#define ALIGN_3 .align 3\n#define ALIGN_4 .align 4\n#define ALIGN_5 .align 5\n#define ffreep\tfstp\n#endif\n\n#ifndef ALIGN_2\n#define ALIGN_2 .align 4\n#endif\n\n#ifndef ALIGN_3\n#define ALIGN_3 .align 8\n#endif\n\n#ifndef ALIGN_4\n#define ALIGN_4 .align 16\n#endif\n\n#ifndef ALIGN_5\n#define ALIGN_5 .align 32\n#endif\n\n#ifndef ALIGN_6\n#define ALIGN_6 .align 64\n#endif\n// ffreep %st(0).\n// Because Clang didn't support ffreep, we directly use the opcode.\n// Please check out http://www.sandpile.org/x86/opc_fpu.htm\n#ifndef ffreep\n#define ffreep .byte 0xdf, 0xc0 #\n#endif\n"
        },
        {
          "name": "common_x86_64.h",
          "type": "blob",
          "size": 12.244140625,
          "content": "/*********************************************************************/\n/* Copyright 2009, 2010 The University of Texas at Austin.           */\n/* All rights reserved.                                              */\n/*                                                                   */\n/* Redistribution and use in source and binary forms, with or        */\n/* without modification, are permitted provided that the following   */\n/* conditions are met:                                               */\n/*                                                                   */\n/*   1. Redistributions of source code must retain the above         */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer.                                                  */\n/*                                                                   */\n/*   2. Redistributions in binary form must reproduce the above      */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer in the documentation and/or other materials       */\n/*      provided with the distribution.                              */\n/*                                                                   */\n/*    THIS  SOFTWARE IS PROVIDED  BY THE  UNIVERSITY OF  TEXAS AT    */\n/*    AUSTIN  ``AS IS''  AND ANY  EXPRESS OR  IMPLIED WARRANTIES,    */\n/*    INCLUDING, BUT  NOT LIMITED  TO, THE IMPLIED  WARRANTIES OF    */\n/*    MERCHANTABILITY  AND FITNESS FOR  A PARTICULAR  PURPOSE ARE    */\n/*    DISCLAIMED.  IN  NO EVENT SHALL THE UNIVERSITY  OF TEXAS AT    */\n/*    AUSTIN OR CONTRIBUTORS BE  LIABLE FOR ANY DIRECT, INDIRECT,    */\n/*    INCIDENTAL,  SPECIAL, EXEMPLARY,  OR  CONSEQUENTIAL DAMAGES    */\n/*    (INCLUDING, BUT  NOT LIMITED TO,  PROCUREMENT OF SUBSTITUTE    */\n/*    GOODS  OR  SERVICES; LOSS  OF  USE,  DATA,  OR PROFITS;  OR    */\n/*    BUSINESS INTERRUPTION) HOWEVER CAUSED  AND ON ANY THEORY OF    */\n/*    LIABILITY, WHETHER  IN CONTRACT, STRICT  LIABILITY, OR TORT    */\n/*    (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY WAY OUT    */\n/*    OF  THE  USE OF  THIS  SOFTWARE,  EVEN  IF ADVISED  OF  THE    */\n/*    POSSIBILITY OF SUCH DAMAGE.                                    */\n/*                                                                   */\n/* The views and conclusions contained in the software and           */\n/* documentation are those of the authors and should not be          */\n/* interpreted as representing official policies, either expressed   */\n/* or implied, of The University of Texas at Austin.                 */\n/*********************************************************************/\n\n#ifndef COMMON_X86\n#define COMMON_X86\n\n#ifndef ASSEMBLER\n\n#ifdef C_MSVC\n#include <intrin.h>\n#endif\n\n#ifdef C_SUN\n#define\t__asm__ __asm\n#define\t__volatile__\n#endif\n\n/*\n#ifdef HAVE_SSE2\n#define MB   __asm__ __volatile__ (\"mfence\");\n#define WMB  __asm__ __volatile__ (\"sfence\");\n#else\n#define MB\n#define WMB\n#endif\n*/\n\n#ifdef __GNUC__\n#define MB do { __asm__ __volatile__(\"\": : :\"memory\"); } while (0)\n#define WMB do { __asm__ __volatile__(\"\": : :\"memory\"); } while (0)\n#define RMB\n#else\n#define MB do {} while (0)\n#define WMB do {} while (0)\n#define RMB\n#endif\n\nstatic __inline void blas_lock(volatile BLASULONG *address){\n\n\t\n#ifndef C_MSVC\n  int ret;\n#else\n  BLASULONG ret;\n#endif\n\n  do {\n    while (*address) {YIELDING;}\n\n#ifndef C_MSVC\n    __asm__ __volatile__(\n\t\t\t \"xchgl %0, %1\\n\"\n\t\t\t : \"=r\"(ret), \"=m\"(*address)\n\t\t\t : \"0\"(1), \"m\"(*address)\n\t\t\t : \"memory\");\n#else\n    ret=InterlockedExchange64((volatile LONG64 *)(address), 1);\n#endif\n  } while (ret);\n\n}\n#define BLAS_LOCK_DEFINED\n\nstatic __inline BLASULONG rpcc(void){\n#ifdef C_MSVC\n  return __rdtsc();\n#else\n  BLASULONG a, d;\n\n  __asm__ __volatile__ (\"rdtsc\" : \"=a\" (a), \"=d\" (d));\n\n  return ((BLASULONG)a + ((BLASULONG)d << 32));\n#endif\n}\n#define RPCC_DEFINED\n\n#define RPCC64BIT\n\n#ifndef C_MSVC\nstatic __inline BLASULONG getstackaddr(void){\n  BLASULONG addr;\n\n  __asm__ __volatile__ (\"movq %%rsp, %0\"\n\t\t\t : \"=r\"(addr) : : \"memory\");\n\n  return addr;\n}\n#endif\n\nstatic __inline void cpuid(int op, int *eax, int *ebx, int *ecx, int *edx){\n\n#ifdef C_MSVC\n  int cpuinfo[4];\n  __cpuid(cpuinfo, op);\n  *eax=cpuinfo[0];\n  *ebx=cpuinfo[1];\n  *ecx=cpuinfo[2];\n  *edx=cpuinfo[3];\n#else\n        __asm__ __volatile__(\"mov $0, %%ecx;\"\n\t\t\t     \"cpuid\"\n\t\t\t     : \"=a\" (*eax),\n\t\t\t     \"=b\" (*ebx),\n\t\t\t     \"=c\" (*ecx),\n\t\t\t     \"=d\" (*edx)\n\t\t\t     : \"0\" (op));\n#endif\n}\n\nstatic __inline void cpuid_count(int op, int count, int *eax, int *ebx, int *ecx, int *edx)\n{\n#ifdef C_MSVC\n  int cpuInfo[4] = {-1};\n  __cpuidex(cpuInfo, op, count);\n  *eax = cpuInfo[0];\n  *ebx = cpuInfo[1];\n  *ecx = cpuInfo[2];\n  *edx = cpuInfo[3];\n#else\n#if defined(__i386__) && defined(__PIC__)\n  __asm__ __volatile__\n    (\"mov %%ebx, %%edi;\"\n      \"cpuid;\"\n      \"xchgl %%ebx, %%edi;\"\n      : \"=a\" (*eax), \"=D\" (*ebx), \"=c\" (*ecx), \"=d\" (*edx) : \"0\" (op), \"2\" (count) : \"cc\");\n#else\n  __asm__ __volatile__\n    (\"cpuid\": \"=a\" (*eax), \"=b\" (*ebx), \"=c\" (*ecx), \"=d\" (*edx) : \"0\" (op), \"2\" (count) : \"cc\");\n#endif\n#endif\n}\n\n/*\n#define WHEREAMI\n*/\n\nstatic __inline int WhereAmI(void){\n  int eax, ebx, ecx, edx;\n  int apicid;\n\n  cpuid(1, &eax, &ebx, &ecx, &edx);\n  apicid  = BITMASK(ebx, 24, 0xff);\n\n  return apicid;\n}\n\n\n#ifdef CORE_BARCELONA\n#define IFLUSH\t\tgotoblas_iflush()\n#define IFLUSH_HALF\tgotoblas_iflush_half()\n#endif\n\n#ifdef ENABLE_SSE_EXCEPTION\n\n#define IDEBUG_START \\\n{ \\\n  unsigned int fp_sse_mode, new_fp_mode; \\\n  __asm__ __volatile__ (\"stmxcsr %0\" : \"=m\" (fp_sse_mode) : ); \\\n  new_fp_mode = fp_sse_mode & ~0xd00; \\\n  __asm__ __volatile__ (\"ldmxcsr %0\" : : \"m\" (new_fp_mode) );\n\n#define IDEBUG_END \\\n  __asm__ __volatile__ (\"ldmxcsr %0\" : : \"m\" (fp_sse_mode) ); \\\n}\n\n#endif\n\n#ifdef XDOUBLE\n#define GET_IMAGE(res)  __asm__ __volatile__(\"fstpt %0\" : \"=m\"(res) : : \"memory\")\n#elif defined(DOUBLE)\n#define GET_IMAGE(res)  __asm__ __volatile__(\"movsd %%xmm1, %0\" : \"=m\"(res) : : \"memory\")\n#else\n#define GET_IMAGE(res)  __asm__ __volatile__(\"movss %%xmm1, %0\" : \"=m\"(res) : : \"memory\")\n#endif\n\n#define GET_IMAGE_CANCEL\n\n#ifdef SMP\n#if defined(USE64BITINT)\nstatic __inline blasint blas_quickdivide(blasint x, blasint y){\n  return x / y;\n}\n#elif defined (C_MSVC)\nstatic __inline BLASLONG blas_quickdivide(BLASLONG x, BLASLONG y){\n  return x / y;\n}\n#else\nextern unsigned int blas_quick_divide_table[];\n\nstatic __inline unsigned int blas_quickdivide(unsigned int x, unsigned int y){\n\n  volatile unsigned int result;\n\n  if (y <= 1) return x;\n\n#if (MAX_CPU_NUMBER > 64)  \n  if (y > 64) { \n\t  result = x / y;\n\t  return result;\n  }\n#endif\n\t\n  y = blas_quick_divide_table[y];\n\n  __asm__ __volatile__  (\"mull %0\" :\"=d\" (result), \"+a\"(x) : \"0\" (y));\n  return result;\n}\n#endif\n#endif\n\n#endif\n\n#ifndef PAGESIZE\n#define PAGESIZE\t( 4 << 10)\n#endif\n#define HUGE_PAGESIZE\t( 2 << 20)\n\n#ifndef BUFFERSIZE\n#define BUFFER_SIZE\t(32 << 22)\n#else\n#define BUFFER_SIZE\t(32UL << BUFFERSIZE)\n#endif\n\n#define SEEK_ADDRESS\n\n#ifdef F_INTERFACE_G77\n#define RETURN_BY_STACK\n#define NEED_F2CCONV\n#endif\n\n#ifdef F_INTERFACE_G95\n#define RETURN_BY_PACKED\n#endif\n\n#ifdef F_INTERFACE_GFORT\n#ifdef OS_WINDOWS\n#ifndef DOUBLE\n#define RETURN_BY_REGS\n#else\n#define RETURN_BY_STACK\n#endif\n#else\n#define RETURN_BY_PACKED\n#endif\n#endif\n\n#ifdef F_INTERFACE_INTEL\n#define RETURN_BY_STACK\n#endif\n\n#ifdef F_INTERFACE_CRAYFC\n#define RETURN_BY_PACKED\n#endif\n\n#ifdef F_INTERFACE_FUJITSU\n#define RETURN_BY_STACK\n#endif\n\n#ifdef F_INTERFACE_FLANG\n#define RETURN_BY_STACK\n#endif\n\n#ifdef F_INTERFACE_PGI\n#define RETURN_BY_STACK\n#endif\n\n#ifdef F_INTERFACE_PATHSCALE\n#define RETURN_BY_PACKED\n#endif\n\n#ifdef F_INTERFACE_SUN\n#define RETURN_BY_PACKED\n#endif\n\n#ifdef ASSEMBLER\n\n#if defined(PILEDRIVER) || defined(BULLDOZER) || defined(STEAMROLLER) || defined(EXCAVATOR)\n//Enable some optimization for barcelona.\n#define BARCELONA_OPTIMIZATION\n#endif\n\n#if defined(HAVE_3DNOW)\n#define EMMS\tfemms\n#elif defined(HAVE_MMX)\n#define EMMS\temms\n#endif\n\n#ifndef EMMS\n#define EMMS\n#endif\n\n#define BRANCH\t\t.byte 0x3e\n#define NOBRANCH\t.byte 0x2e\n#define PADDING\t\t.byte 0x66\n\n#ifdef OS_WINDOWS\n#define ARG1\t%rcx\n#define ARG2\t%rdx\n#define ARG3\t%r8\n#define ARG4\t%r9\n#else\n#define ARG1\t%rdi\n#define ARG2\t%rsi\n#define ARG3\t%rdx\n#define ARG4\t%rcx\n#define ARG5\t%r8\n#define ARG6\t%r9\n#endif\n\n#ifndef COMPLEX\n#ifdef XDOUBLE\n#define LOCAL_BUFFER_SIZE  QLOCAL_BUFFER_SIZE\n#elif defined DOUBLE\n#define LOCAL_BUFFER_SIZE  DLOCAL_BUFFER_SIZE\n#else\n#define LOCAL_BUFFER_SIZE  SLOCAL_BUFFER_SIZE\n#endif\n#else\n#ifdef XDOUBLE\n#define LOCAL_BUFFER_SIZE  XLOCAL_BUFFER_SIZE\n#elif defined DOUBLE\n#define LOCAL_BUFFER_SIZE  ZLOCAL_BUFFER_SIZE\n#else\n#define LOCAL_BUFFER_SIZE  CLOCAL_BUFFER_SIZE\n#endif\n#endif\n\n#if defined(OS_WINDOWS)\n#if   LOCAL_BUFFER_SIZE > 16384\n#define STACK_TOUCHING \\\n\tmovl\t$0,  4096 * 4(%rsp);\\\n\tmovl\t$0,  4096 * 3(%rsp);\\\n\tmovl\t$0,  4096 * 2(%rsp);\\\n\tmovl\t$0,  4096 * 1(%rsp);\n#elif LOCAL_BUFFER_SIZE > 12288\n#define STACK_TOUCHING \\\n\tmovl\t$0,  4096 * 3(%rsp);\\\n\tmovl\t$0,  4096 * 2(%rsp);\\\n\tmovl\t$0,  4096 * 1(%rsp);\n#elif LOCAL_BUFFER_SIZE > 8192\n#define STACK_TOUCHING \\\n\tmovl\t$0,  4096 * 2(%rsp);\\\n\tmovl\t$0,  4096 * 1(%rsp);\n#elif LOCAL_BUFFER_SIZE > 4096\n#define STACK_TOUCHING \\\n\tmovl\t$0,  4096 * 1(%rsp);\n#else\n#define STACK_TOUCHING\n#endif\n#else\n#define STACK_TOUCHING\n#endif\n\n#if defined(CORE2)\n#define movapd\tmovaps\n#define andpd\tandps\n#define movlpd\tmovlps\n#define movhpd\tmovhps\n#endif\n\n#ifndef F_INTERFACE\n#define REALNAME ASMNAME\n#else\n#define REALNAME ASMFNAME\n#endif\n\n#ifdef OS_DARWIN\n#define PROLOGUE .text;.align 5; .globl REALNAME; REALNAME:\n#define EPILOGUE\t.subsections_via_symbols\n#define PROFCODE\n#endif\n\n#ifdef OS_WINDOWS\n#define SAVEREGISTERS \\\n\tsubq\t$256, %rsp;\\\n\tmovups\t%xmm6,    0(%rsp);\\\n\tmovups\t%xmm7,   16(%rsp);\\\n\tmovups\t%xmm8,   32(%rsp);\\\n\tmovups\t%xmm9,   48(%rsp);\\\n\tmovups\t%xmm10,  64(%rsp);\\\n\tmovups\t%xmm11,  80(%rsp);\\\n\tmovups\t%xmm12,  96(%rsp);\\\n\tmovups\t%xmm13, 112(%rsp);\\\n\tmovups\t%xmm14, 128(%rsp);\\\n\tmovups\t%xmm15, 144(%rsp)\n\n#define RESTOREREGISTERS \\\n\tmovups\t   0(%rsp), %xmm6;\\\n\tmovups\t  16(%rsp), %xmm7;\\\n\tmovups\t  32(%rsp), %xmm8;\\\n\tmovups\t  48(%rsp), %xmm9;\\\n\tmovups\t  64(%rsp), %xmm10;\\\n\tmovups\t  80(%rsp), %xmm11;\\\n\tmovups\t  96(%rsp), %xmm12;\\\n\tmovups\t 112(%rsp), %xmm13;\\\n\tmovups\t 128(%rsp), %xmm14;\\\n\tmovups\t 144(%rsp), %xmm15;\\\n\taddq\t$256, %rsp\n#else\n#define SAVEREGISTERS\n#define RESTOREREGISTERS\n#endif\n\n#if defined(OS_WINDOWS) && !defined(C_PGI)\n#define PROLOGUE \\\n\t.text; \\\n\t.align 16; \\\n\t.globl REALNAME ;\\\n\t.def REALNAME;.scl\t2;.type\t32;.endef; \\\nREALNAME:\n\n#define PROFCODE\n\n#define EPILOGUE .end\n#endif\n\n#if defined(OS_LINUX) || defined(OS_FREEBSD) || defined(OS_NETBSD) || defined(OS_OPENBSD) || defined(OS_DRAGONFLY) || defined(__ELF__) || defined(C_PGI)\n#define PROLOGUE \\\n\t.text; \\\n\t.align 512; \\\n\t.globl REALNAME ;\\\n       .type REALNAME, @function; \\\nREALNAME: \\\n\t_CET_ENDBR\n\n#ifdef PROFILE\n#define PROFCODE call *mcount@GOTPCREL(%rip)\n#else\n#define PROFCODE\n#endif\n\n#define EPILOGUE \\\n        .size\t REALNAME, .-REALNAME; \\\n        .section .note.GNU-stack,\"\",@progbits\n\n\n#endif\n\n#endif\n\n#ifdef XDOUBLE\n#define FLD\tfldt\n#define FST\tfstpt\n#define MOVQ\tmovq\n#elif defined(DOUBLE)\n#define FLD\tfldl\n#define FST\tfstpl\n#define FSTU\tfstl\n#define FMUL\tfmull\n#define FADD\tfaddl\n#define MOVSD\tmovsd\n#define MULSD\tmulsd\n#define MULPD\tmulpd\n#define CMPEQPD\tcmpeqpd\n#define COMISD\tcomisd\n#define PSRLQ\tpsrlq\n#define ANDPD\tandpd\n#define ADDPD\taddpd\n#define ADDSD\taddsd\n#define SUBPD\tsubpd\n#define SUBSD\tsubsd\n#define MOVQ\tmovq\n#define MOVUPD\tmovupd\n#define XORPD\txorpd\n#else\n#define FLD\tflds\n#define FST\tfstps\n#define FSTU\tfsts\n#define FMUL\tfmuls\n#define FADD\tfadds\n#define MOVSD\tmovss\n#define MULSD\tmulss\n#define MULPD\tmulps\n#define CMPEQPD\tcmpeqps\n#define COMISD\tcomiss\n#define PSRLQ\tpsrld\n#define ANDPD\tandps\n#define ADDPD\taddps\n#define ADDSD\taddss\n#define SUBPD\tsubps\n#define SUBSD\tsubss\n#define MOVQ\tmovd\n#define MOVUPD\tmovups\n#define XORPD\txorps\n#endif\n\n#define HALT\thlt\n\n#ifdef OS_DARWIN\n#define ALIGN_2 .align 2\n#define ALIGN_3 .align 3\n#define ALIGN_4 .align 4\n#define ALIGN_5 .align 5\n#define ffreep\tfstp\n#endif\n\n#ifndef ALIGN_2\n#define ALIGN_2 .align 4\n#endif\n\n#ifndef ALIGN_3\n#define ALIGN_3 .align 8\n#endif\n\n#ifndef ALIGN_4\n#define ALIGN_4 .align 16\n#endif\n\n#ifndef ALIGN_5\n#define ALIGN_5 .align 32\n#endif\n\n#ifndef ALIGN_6\n#define ALIGN_6 .align 64\n#endif\n\n// ffreep %st(0).\n// Because Clang didn't support ffreep, we directly use the opcode.\n// Please check out http://www.sandpile.org/x86/opc_fpu.htm\n#ifndef ffreep\n#define ffreep .byte 0xdf, 0xc0 #\n#endif\n#endif\n"
        },
        {
          "name": "common_z.h",
          "type": "blob",
          "size": 24.12109375,
          "content": "#ifndef COMMON_Z_H\n#define COMMON_Z_H\n\n#ifndef DYNAMIC_ARCH\n\n#define\tZAMAX_K\t\t\tzamax_k\n#define\tZAMIN_K\t\t\tzamin_k\n#define\tZMAX_K\t\t\tzmax_k\n#define\tZMIN_K\t\t\tzmin_k\n#define\tIZAMAX_K\t\tizamax_k\n#define\tIZAMIN_K\t\tizamin_k\n#define\tIZMAX_K\t\t\tizmax_k\n#define\tIZMIN_K\t\t\tizmin_k\n#define\tZASUM_K\t\t\tzasum_k\n#define\tZAXPYU_K\t\tzaxpy_k\n#define\tZAXPYC_K\t\tzaxpyc_k\n#define\tZCOPY_K\t\t\tzcopy_k\n#define\tZDOTU_K\t\t\tzdotu_k\n#define\tZDOTC_K\t\t\tzdotc_k\n#define\tZNRM2_K\t\t\tznrm2_k\n#define\tZSCAL_K\t\t\tzscal_k\n#define\tZSUM_K\t\t\tzsum_k\n#define\tZSWAP_K\t\t\tzswap_k\n#define\tZROT_K\t\t\tzdrot_k\n\n#define\tZGEMV_N\t\t\tzgemv_n\n#define\tZGEMV_T\t\t\tzgemv_t\n#define\tZGEMV_R\t\t\tzgemv_r\n#define\tZGEMV_C\t\t\tzgemv_c\n#define\tZGEMV_O\t\t\tzgemv_o\n#define\tZGEMV_U\t\t\tzgemv_u\n#define\tZGEMV_S\t\t\tzgemv_s\n#define\tZGEMV_D\t\t\tzgemv_d\n\n#define\tZGERU_K\t\t\tzgeru_k\n#define\tZGERC_K\t\t\tzgerc_k\n#define\tZGERV_K\t\t\tzgerv_k\n#define\tZGERD_K\t\t\tzgerd_k\n\n#define ZSYMV_U\t\t\tzsymv_U\n#define ZSYMV_L\t\t\tzsymv_L\n#define ZHEMV_U\t\t\tzhemv_U\n#define ZHEMV_L\t\t\tzhemv_L\n#define ZHEMV_V\t\t\tzhemv_V\n#define ZHEMV_M\t\t\tzhemv_M\n\n#define ZSYMV_THREAD_U\t\tzsymv_thread_U\n#define ZSYMV_THREAD_L\t\tzsymv_thread_L\n#define ZHEMV_THREAD_U\t\tzhemv_thread_U\n#define ZHEMV_THREAD_L\t\tzhemv_thread_L\n#define ZHEMV_THREAD_V\t\tzhemv_thread_V\n#define ZHEMV_THREAD_M\t\tzhemv_thread_M\n\n#define\tZGEMM_ONCOPY\t\tzgemm_oncopy\n#define\tZGEMM_OTCOPY\t\tzgemm_otcopy\n\n#if ZGEMM_DEFAULT_UNROLL_M == ZGEMM_DEFAULT_UNROLL_N\n#define\tZGEMM_INCOPY\t\tzgemm_oncopy\n#define\tZGEMM_ITCOPY\t\tzgemm_otcopy\n#else\n#define\tZGEMM_INCOPY\t\tzgemm_incopy\n#define\tZGEMM_ITCOPY\t\tzgemm_itcopy\n#endif\n\n#define\tZTRMM_OUNUCOPY\t\tztrmm_ounucopy\n#define\tZTRMM_OUNNCOPY\t\tztrmm_ounncopy\n#define\tZTRMM_OUTUCOPY\t\tztrmm_outucopy\n#define\tZTRMM_OUTNCOPY\t\tztrmm_outncopy\n#define\tZTRMM_OLNUCOPY\t\tztrmm_olnucopy\n#define\tZTRMM_OLNNCOPY\t\tztrmm_olnncopy\n#define\tZTRMM_OLTUCOPY\t\tztrmm_oltucopy\n#define\tZTRMM_OLTNCOPY\t\tztrmm_oltncopy\n\n#define\tZTRSM_OUNUCOPY\t\tztrsm_ounucopy\n#define\tZTRSM_OUNNCOPY\t\tztrsm_ounncopy\n#define\tZTRSM_OUTUCOPY\t\tztrsm_outucopy\n#define\tZTRSM_OUTNCOPY\t\tztrsm_outncopy\n#define\tZTRSM_OLNUCOPY\t\tztrsm_olnucopy\n#define\tZTRSM_OLNNCOPY\t\tztrsm_olnncopy\n#define\tZTRSM_OLTUCOPY\t\tztrsm_oltucopy\n#define\tZTRSM_OLTNCOPY\t\tztrsm_oltncopy\n\n#if ZGEMM_DEFAULT_UNROLL_M == ZGEMM_DEFAULT_UNROLL_N\n#define\tZTRMM_IUNUCOPY\t\tztrmm_ounucopy\n#define\tZTRMM_IUNNCOPY\t\tztrmm_ounncopy\n#define\tZTRMM_IUTUCOPY\t\tztrmm_outucopy\n#define\tZTRMM_IUTNCOPY\t\tztrmm_outncopy\n#define\tZTRMM_ILNUCOPY\t\tztrmm_olnucopy\n#define\tZTRMM_ILNNCOPY\t\tztrmm_olnncopy\n#define\tZTRMM_ILTUCOPY\t\tztrmm_oltucopy\n#define\tZTRMM_ILTNCOPY\t\tztrmm_oltncopy\n\n#define\tZTRSM_IUNUCOPY\t\tztrsm_ounucopy\n#define\tZTRSM_IUNNCOPY\t\tztrsm_ounncopy\n#define\tZTRSM_IUTUCOPY\t\tztrsm_outucopy\n#define\tZTRSM_IUTNCOPY\t\tztrsm_outncopy\n#define\tZTRSM_ILNUCOPY\t\tztrsm_olnucopy\n#define\tZTRSM_ILNNCOPY\t\tztrsm_olnncopy\n#define\tZTRSM_ILTUCOPY\t\tztrsm_oltucopy\n#define\tZTRSM_ILTNCOPY\t\tztrsm_oltncopy\n#else\n#define\tZTRMM_IUNUCOPY\t\tztrmm_iunucopy\n#define\tZTRMM_IUNNCOPY\t\tztrmm_iunncopy\n#define\tZTRMM_IUTUCOPY\t\tztrmm_iutucopy\n#define\tZTRMM_IUTNCOPY\t\tztrmm_iutncopy\n#define\tZTRMM_ILNUCOPY\t\tztrmm_ilnucopy\n#define\tZTRMM_ILNNCOPY\t\tztrmm_ilnncopy\n#define\tZTRMM_ILTUCOPY\t\tztrmm_iltucopy\n#define\tZTRMM_ILTNCOPY\t\tztrmm_iltncopy\n\n#define\tZTRSM_IUNUCOPY\t\tztrsm_iunucopy\n#define\tZTRSM_IUNNCOPY\t\tztrsm_iunncopy\n#define\tZTRSM_IUTUCOPY\t\tztrsm_iutucopy\n#define\tZTRSM_IUTNCOPY\t\tztrsm_iutncopy\n#define\tZTRSM_ILNUCOPY\t\tztrsm_ilnucopy\n#define\tZTRSM_ILNNCOPY\t\tztrsm_ilnncopy\n#define\tZTRSM_ILTUCOPY\t\tztrsm_iltucopy\n#define\tZTRSM_ILTNCOPY\t\tztrsm_iltncopy\n#endif\n\n#define\tZGEMM_BETA\t\tzgemm_beta\n\n#define\tZGEMM_KERNEL_N\t\tzgemm_kernel_n\n#define\tZGEMM_KERNEL_L\t\tzgemm_kernel_l\n#define\tZGEMM_KERNEL_R\t\tzgemm_kernel_r\n#define\tZGEMM_KERNEL_B\t\tzgemm_kernel_b\n\n#define\tZTRMM_KERNEL_LN\t\tztrmm_kernel_LN\n#define\tZTRMM_KERNEL_LT\t\tztrmm_kernel_LT\n#define\tZTRMM_KERNEL_LR\t\tztrmm_kernel_LR\n#define\tZTRMM_KERNEL_LC\t\tztrmm_kernel_LC\n#define\tZTRMM_KERNEL_RN\t\tztrmm_kernel_RN\n#define\tZTRMM_KERNEL_RT\t\tztrmm_kernel_RT\n#define\tZTRMM_KERNEL_RR\t\tztrmm_kernel_RR\n#define\tZTRMM_KERNEL_RC\t\tztrmm_kernel_RC\n\n#define\tZTRSM_KERNEL_LN\t\tztrsm_kernel_LN\n#define\tZTRSM_KERNEL_LT\t\tztrsm_kernel_LT\n#define\tZTRSM_KERNEL_LR\t\tztrsm_kernel_LR\n#define\tZTRSM_KERNEL_LC\t\tztrsm_kernel_LC\n#define\tZTRSM_KERNEL_RN\t\tztrsm_kernel_RN\n#define\tZTRSM_KERNEL_RT\t\tztrsm_kernel_RT\n#define\tZTRSM_KERNEL_RR\t\tztrsm_kernel_RR\n#define\tZTRSM_KERNEL_RC\t\tztrsm_kernel_RC\n\n#define\tZSYMM_OUTCOPY\t\tzsymm_outcopy\n#define\tZSYMM_OLTCOPY\t\tzsymm_oltcopy\n#if ZGEMM_DEFAULT_UNROLL_M == ZGEMM_DEFAULT_UNROLL_N\n#define\tZSYMM_IUTCOPY\t\tzsymm_outcopy\n#define\tZSYMM_ILTCOPY\t\tzsymm_oltcopy\n#else\n#define\tZSYMM_IUTCOPY\t\tzsymm_iutcopy\n#define\tZSYMM_ILTCOPY\t\tzsymm_iltcopy\n#endif\n\n#define\tZHEMM_OUTCOPY\t\tzhemm_outcopy\n#define\tZHEMM_OLTCOPY\t\tzhemm_oltcopy\n#if ZGEMM_DEFAULT_UNROLL_M == ZGEMM_DEFAULT_UNROLL_N\n#define\tZHEMM_IUTCOPY\t\tzhemm_outcopy\n#define\tZHEMM_ILTCOPY\t\tzhemm_oltcopy\n#else\n#define\tZHEMM_IUTCOPY\t\tzhemm_iutcopy\n#define\tZHEMM_ILTCOPY\t\tzhemm_iltcopy\n#endif\n\n#define\tZGEMM3M_ONCOPYB\t\tzgemm3m_oncopyb\n#define\tZGEMM3M_ONCOPYR\t\tzgemm3m_oncopyr\n#define\tZGEMM3M_ONCOPYI\t\tzgemm3m_oncopyi\n#define\tZGEMM3M_OTCOPYB\t\tzgemm3m_otcopyb\n#define\tZGEMM3M_OTCOPYR\t\tzgemm3m_otcopyr\n#define\tZGEMM3M_OTCOPYI\t\tzgemm3m_otcopyi\n\n#define\tZGEMM3M_INCOPYB\t\tzgemm3m_incopyb\n#define\tZGEMM3M_INCOPYR\t\tzgemm3m_incopyr\n#define\tZGEMM3M_INCOPYI\t\tzgemm3m_incopyi\n#define\tZGEMM3M_ITCOPYB\t\tzgemm3m_itcopyb\n#define\tZGEMM3M_ITCOPYR\t\tzgemm3m_itcopyr\n#define\tZGEMM3M_ITCOPYI\t\tzgemm3m_itcopyi\n\n#define\tZSYMM3M_ILCOPYB\t\tzsymm3m_ilcopyb\n#define\tZSYMM3M_IUCOPYB\t\tzsymm3m_iucopyb\n#define\tZSYMM3M_ILCOPYR\t\tzsymm3m_ilcopyr\n#define\tZSYMM3M_IUCOPYR\t\tzsymm3m_iucopyr\n#define\tZSYMM3M_ILCOPYI\t\tzsymm3m_ilcopyi\n#define\tZSYMM3M_IUCOPYI\t\tzsymm3m_iucopyi\n\n#define\tZSYMM3M_OLCOPYB\t\tzsymm3m_olcopyb\n#define\tZSYMM3M_OUCOPYB\t\tzsymm3m_oucopyb\n#define\tZSYMM3M_OLCOPYR\t\tzsymm3m_olcopyr\n#define\tZSYMM3M_OUCOPYR\t\tzsymm3m_oucopyr\n#define\tZSYMM3M_OLCOPYI\t\tzsymm3m_olcopyi\n#define\tZSYMM3M_OUCOPYI\t\tzsymm3m_oucopyi\n\n#define\tZHEMM3M_ILCOPYB\t\tzhemm3m_ilcopyb\n#define\tZHEMM3M_IUCOPYB\t\tzhemm3m_iucopyb\n#define\tZHEMM3M_ILCOPYR\t\tzhemm3m_ilcopyr\n#define\tZHEMM3M_IUCOPYR\t\tzhemm3m_iucopyr\n#define\tZHEMM3M_ILCOPYI\t\tzhemm3m_ilcopyi\n#define\tZHEMM3M_IUCOPYI\t\tzhemm3m_iucopyi\n\n#define\tZHEMM3M_OLCOPYB\t\tzhemm3m_olcopyb\n#define\tZHEMM3M_OUCOPYB\t\tzhemm3m_oucopyb\n#define\tZHEMM3M_OLCOPYR\t\tzhemm3m_olcopyr\n#define\tZHEMM3M_OUCOPYR\t\tzhemm3m_oucopyr\n#define\tZHEMM3M_OLCOPYI\t\tzhemm3m_olcopyi\n#define\tZHEMM3M_OUCOPYI\t\tzhemm3m_oucopyi\n\n#define\tZGEMM3M_KERNEL\t\tzgemm3m_kernel\n\n#define ZNEG_TCOPY\t\tzneg_tcopy\n#define ZLASWP_NCOPY\t\tzlaswp_ncopy\n\n#define ZAXPBY_K                zaxpby_k\n\n#define ZOMATCOPY_K_CN          zomatcopy_k_cn\n#define ZOMATCOPY_K_RN          zomatcopy_k_rn\n#define ZOMATCOPY_K_CT          zomatcopy_k_ct\n#define ZOMATCOPY_K_RT          zomatcopy_k_rt\n#define ZOMATCOPY_K_CNC         zomatcopy_k_cnc\n#define ZOMATCOPY_K_RNC         zomatcopy_k_rnc\n#define ZOMATCOPY_K_CTC         zomatcopy_k_ctc\n#define ZOMATCOPY_K_RTC         zomatcopy_k_rtc\n\n#define ZIMATCOPY_K_CN          zimatcopy_k_cn\n#define ZIMATCOPY_K_RN          zimatcopy_k_rn\n#define ZIMATCOPY_K_CT          zimatcopy_k_ct\n#define ZIMATCOPY_K_RT          zimatcopy_k_rt\n#define ZIMATCOPY_K_CNC         zimatcopy_k_cnc\n#define ZIMATCOPY_K_RNC         zimatcopy_k_rnc\n#define ZIMATCOPY_K_CTC         zimatcopy_k_ctc\n#define ZIMATCOPY_K_RTC         zimatcopy_k_rtc\n\n#define ZGEADD_K                zgeadd_k \n\n#define ZGEMM_SMALL_MATRIX_PERMIT\tzgemm_small_matrix_permit\n\n#else\n\n#define\tZAMAX_K\t\t\tgotoblas -> zamax_k\n#define\tZAMIN_K\t\t\tgotoblas -> zamin_k\n#define\tZMAX_K\t\t\tgotoblas -> zmax_k\n#define\tZMIN_K\t\t\tgotoblas -> zmin_k\n#define\tIZAMAX_K\t\tgotoblas -> izamax_k\n#define\tIZAMIN_K\t\tgotoblas -> izamin_k\n#define\tIZMAX_K\t\t\tgotoblas -> izmax_k\n#define\tIZMIN_K\t\t\tgotoblas -> izmin_k\n#define\tZASUM_K\t\t\tgotoblas -> zasum_k\n#define\tZAXPYU_K\t\tgotoblas -> zaxpy_k\n#define\tZAXPYC_K\t\tgotoblas -> zaxpyc_k\n#define\tZCOPY_K\t\t\tgotoblas -> zcopy_k\n#define\tZDOTU_K\t\t\tgotoblas -> zdotu_k\n#define\tZDOTC_K\t\t\tgotoblas -> zdotc_k\n#define\tZNRM2_K\t\t\tgotoblas -> znrm2_k\n#define\tZSCAL_K\t\t\tgotoblas -> zscal_k\n#define\tZSUM_K\t\t\tgotoblas -> zsum_k\n#define\tZSWAP_K\t\t\tgotoblas -> zswap_k\n#define\tZROT_K\t\t\tgotoblas -> zdrot_k\n\n#define\tZGEMV_N\t\t\tgotoblas -> zgemv_n\n#define\tZGEMV_T\t\t\tgotoblas -> zgemv_t\n#define\tZGEMV_R\t\t\tgotoblas -> zgemv_r\n#define\tZGEMV_C\t\t\tgotoblas -> zgemv_c\n#define\tZGEMV_O\t\t\tgotoblas -> zgemv_o\n#define\tZGEMV_U\t\t\tgotoblas -> zgemv_u\n#define\tZGEMV_S\t\t\tgotoblas -> zgemv_s\n#define\tZGEMV_D\t\t\tgotoblas -> zgemv_d\n\n#define\tZGERU_K\t\t\tgotoblas -> zgeru_k\n#define\tZGERC_K\t\t\tgotoblas -> zgerc_k\n#define\tZGERV_K\t\t\tgotoblas -> zgerv_k\n#define\tZGERD_K\t\t\tgotoblas -> zgerd_k\n\n#define ZSYMV_U\t\t\tgotoblas -> zsymv_U\n#define ZSYMV_L\t\t\tgotoblas -> zsymv_L\n#define ZHEMV_U\t\t\tgotoblas -> zhemv_U\n#define ZHEMV_L\t\t\tgotoblas -> zhemv_L\n#define ZHEMV_V\t\t\tgotoblas -> zhemv_V\n#define ZHEMV_M\t\t\tgotoblas -> zhemv_M\n\n#define ZSYMV_THREAD_U\t\tzsymv_thread_U\n#define ZSYMV_THREAD_L\t\tzsymv_thread_L\n#define ZHEMV_THREAD_U\t\tzhemv_thread_U\n#define ZHEMV_THREAD_L\t\tzhemv_thread_L\n#define ZHEMV_THREAD_V\t\tzhemv_thread_V\n#define ZHEMV_THREAD_M\t\tzhemv_thread_M\n\n#define\tZGEMM_ONCOPY\t\tgotoblas -> zgemm_oncopy\n#define\tZGEMM_OTCOPY\t\tgotoblas -> zgemm_otcopy\n#define\tZGEMM_INCOPY\t\tgotoblas -> zgemm_incopy\n#define\tZGEMM_ITCOPY\t\tgotoblas -> zgemm_itcopy\n\n#define\tZTRMM_OUNUCOPY\t\tgotoblas -> ztrmm_ounucopy\n#define\tZTRMM_OUTUCOPY\t\tgotoblas -> ztrmm_outucopy\n#define\tZTRMM_OLNUCOPY\t\tgotoblas -> ztrmm_olnucopy\n#define\tZTRMM_OLTUCOPY\t\tgotoblas -> ztrmm_oltucopy\n#define\tZTRSM_OUNUCOPY\t\tgotoblas -> ztrsm_ounucopy\n#define\tZTRSM_OUTUCOPY\t\tgotoblas -> ztrsm_outucopy\n#define\tZTRSM_OLNUCOPY\t\tgotoblas -> ztrsm_olnucopy\n#define\tZTRSM_OLTUCOPY\t\tgotoblas -> ztrsm_oltucopy\n\n#define\tZTRMM_IUNUCOPY\t\tgotoblas -> ztrmm_iunucopy\n#define\tZTRMM_IUTUCOPY\t\tgotoblas -> ztrmm_iutucopy\n#define\tZTRMM_ILNUCOPY\t\tgotoblas -> ztrmm_ilnucopy\n#define\tZTRMM_ILTUCOPY\t\tgotoblas -> ztrmm_iltucopy\n#define\tZTRSM_IUNUCOPY\t\tgotoblas -> ztrsm_iunucopy\n#define\tZTRSM_IUTUCOPY\t\tgotoblas -> ztrsm_iutucopy\n#define\tZTRSM_ILNUCOPY\t\tgotoblas -> ztrsm_ilnucopy\n#define\tZTRSM_ILTUCOPY\t\tgotoblas -> ztrsm_iltucopy\n\n#define\tZTRMM_OUNNCOPY\t\tgotoblas -> ztrmm_ounncopy\n#define\tZTRMM_OUTNCOPY\t\tgotoblas -> ztrmm_outncopy\n#define\tZTRMM_OLNNCOPY\t\tgotoblas -> ztrmm_olnncopy\n#define\tZTRMM_OLTNCOPY\t\tgotoblas -> ztrmm_oltncopy\n#define\tZTRSM_OUNNCOPY\t\tgotoblas -> ztrsm_ounncopy\n#define\tZTRSM_OUTNCOPY\t\tgotoblas -> ztrsm_outncopy\n#define\tZTRSM_OLNNCOPY\t\tgotoblas -> ztrsm_olnncopy\n#define\tZTRSM_OLTNCOPY\t\tgotoblas -> ztrsm_oltncopy\n\n#define\tZTRMM_IUNNCOPY\t\tgotoblas -> ztrmm_iunncopy\n#define\tZTRMM_IUTNCOPY\t\tgotoblas -> ztrmm_iutncopy\n#define\tZTRMM_ILNNCOPY\t\tgotoblas -> ztrmm_ilnncopy\n#define\tZTRMM_ILTNCOPY\t\tgotoblas -> ztrmm_iltncopy\n#define\tZTRSM_IUNNCOPY\t\tgotoblas -> ztrsm_iunncopy\n#define\tZTRSM_IUTNCOPY\t\tgotoblas -> ztrsm_iutncopy\n#define\tZTRSM_ILNNCOPY\t\tgotoblas -> ztrsm_ilnncopy\n#define\tZTRSM_ILTNCOPY\t\tgotoblas -> ztrsm_iltncopy\n\n#define\tZGEMM_BETA\t\tgotoblas -> zgemm_beta\n#define\tZGEMM_KERNEL_N\t\tgotoblas -> zgemm_kernel_n\n#define\tZGEMM_KERNEL_L\t\tgotoblas -> zgemm_kernel_l\n#define\tZGEMM_KERNEL_R\t\tgotoblas -> zgemm_kernel_r\n#define\tZGEMM_KERNEL_B\t\tgotoblas -> zgemm_kernel_b\n\n#define\tZTRMM_KERNEL_LN\t\tgotoblas -> ztrmm_kernel_LN\n#define\tZTRMM_KERNEL_LT\t\tgotoblas -> ztrmm_kernel_LT\n#define\tZTRMM_KERNEL_LR\t\tgotoblas -> ztrmm_kernel_LR\n#define\tZTRMM_KERNEL_LC\t\tgotoblas -> ztrmm_kernel_LC\n#define\tZTRMM_KERNEL_RN\t\tgotoblas -> ztrmm_kernel_RN\n#define\tZTRMM_KERNEL_RT\t\tgotoblas -> ztrmm_kernel_RT\n#define\tZTRMM_KERNEL_RR\t\tgotoblas -> ztrmm_kernel_RR\n#define\tZTRMM_KERNEL_RC\t\tgotoblas -> ztrmm_kernel_RC\n\n#define\tZTRSM_KERNEL_LN\t\tgotoblas -> ztrsm_kernel_LN\n#define\tZTRSM_KERNEL_LT\t\tgotoblas -> ztrsm_kernel_LT\n#define\tZTRSM_KERNEL_LR\t\tgotoblas -> ztrsm_kernel_LR\n#define\tZTRSM_KERNEL_LC\t\tgotoblas -> ztrsm_kernel_LC\n#define\tZTRSM_KERNEL_RN\t\tgotoblas -> ztrsm_kernel_RN\n#define\tZTRSM_KERNEL_RT\t\tgotoblas -> ztrsm_kernel_RT\n#define\tZTRSM_KERNEL_RR\t\tgotoblas -> ztrsm_kernel_RR\n#define\tZTRSM_KERNEL_RC\t\tgotoblas -> ztrsm_kernel_RC\n\n#define\tZSYMM_IUTCOPY\t\tgotoblas -> zsymm_iutcopy\n#define\tZSYMM_ILTCOPY\t\tgotoblas -> zsymm_iltcopy\n#define\tZSYMM_OUTCOPY\t\tgotoblas -> zsymm_outcopy\n#define\tZSYMM_OLTCOPY\t\tgotoblas -> zsymm_oltcopy\n\n#define\tZHEMM_OUTCOPY\t\tgotoblas -> zhemm_outcopy\n#define\tZHEMM_OLTCOPY\t\tgotoblas -> zhemm_oltcopy\n#define\tZHEMM_IUTCOPY\t\tgotoblas -> zhemm_iutcopy\n#define\tZHEMM_ILTCOPY\t\tgotoblas -> zhemm_iltcopy\n\n#define\tZGEMM3M_ONCOPYB\t\tgotoblas -> zgemm3m_oncopyb\n#define\tZGEMM3M_ONCOPYR\t\tgotoblas -> zgemm3m_oncopyr\n#define\tZGEMM3M_ONCOPYI\t\tgotoblas -> zgemm3m_oncopyi\n#define\tZGEMM3M_OTCOPYB\t\tgotoblas -> zgemm3m_otcopyb\n#define\tZGEMM3M_OTCOPYR\t\tgotoblas -> zgemm3m_otcopyr\n#define\tZGEMM3M_OTCOPYI\t\tgotoblas -> zgemm3m_otcopyi\n\n#define\tZGEMM3M_INCOPYB\t\tgotoblas -> zgemm3m_incopyb\n#define\tZGEMM3M_INCOPYR\t\tgotoblas -> zgemm3m_incopyr\n#define\tZGEMM3M_INCOPYI\t\tgotoblas -> zgemm3m_incopyi\n#define\tZGEMM3M_ITCOPYB\t\tgotoblas -> zgemm3m_itcopyb\n#define\tZGEMM3M_ITCOPYR\t\tgotoblas -> zgemm3m_itcopyr\n#define\tZGEMM3M_ITCOPYI\t\tgotoblas -> zgemm3m_itcopyi\n\n#define\tZSYMM3M_ILCOPYB\t\tgotoblas -> zsymm3m_ilcopyb\n#define\tZSYMM3M_IUCOPYB\t\tgotoblas -> zsymm3m_iucopyb\n#define\tZSYMM3M_ILCOPYR\t\tgotoblas -> zsymm3m_ilcopyr\n#define\tZSYMM3M_IUCOPYR\t\tgotoblas -> zsymm3m_iucopyr\n#define\tZSYMM3M_ILCOPYI\t\tgotoblas -> zsymm3m_ilcopyi\n#define\tZSYMM3M_IUCOPYI\t\tgotoblas -> zsymm3m_iucopyi\n\n#define\tZSYMM3M_OLCOPYB\t\tgotoblas -> zsymm3m_olcopyb\n#define\tZSYMM3M_OUCOPYB\t\tgotoblas -> zsymm3m_oucopyb\n#define\tZSYMM3M_OLCOPYR\t\tgotoblas -> zsymm3m_olcopyr\n#define\tZSYMM3M_OUCOPYR\t\tgotoblas -> zsymm3m_oucopyr\n#define\tZSYMM3M_OLCOPYI\t\tgotoblas -> zsymm3m_olcopyi\n#define\tZSYMM3M_OUCOPYI\t\tgotoblas -> zsymm3m_oucopyi\n\n#define\tZHEMM3M_ILCOPYB\t\tgotoblas -> zhemm3m_ilcopyb\n#define\tZHEMM3M_IUCOPYB\t\tgotoblas -> zhemm3m_iucopyb\n#define\tZHEMM3M_ILCOPYR\t\tgotoblas -> zhemm3m_ilcopyr\n#define\tZHEMM3M_IUCOPYR\t\tgotoblas -> zhemm3m_iucopyr\n#define\tZHEMM3M_ILCOPYI\t\tgotoblas -> zhemm3m_ilcopyi\n#define\tZHEMM3M_IUCOPYI\t\tgotoblas -> zhemm3m_iucopyi\n\n#define\tZHEMM3M_OLCOPYB\t\tgotoblas -> zhemm3m_olcopyb\n#define\tZHEMM3M_OUCOPYB\t\tgotoblas -> zhemm3m_oucopyb\n#define\tZHEMM3M_OLCOPYR\t\tgotoblas -> zhemm3m_olcopyr\n#define\tZHEMM3M_OUCOPYR\t\tgotoblas -> zhemm3m_oucopyr\n#define\tZHEMM3M_OLCOPYI\t\tgotoblas -> zhemm3m_olcopyi\n#define\tZHEMM3M_OUCOPYI\t\tgotoblas -> zhemm3m_oucopyi\n\n#define\tZGEMM3M_KERNEL\t\tgotoblas -> zgemm3m_kernel\n\n#define ZNEG_TCOPY\t\tgotoblas -> zneg_tcopy\n#define ZLASWP_NCOPY\t\tgotoblas -> zlaswp_ncopy\n\n#define ZAXPBY_K                gotoblas -> zaxpby_k\n\n#define ZOMATCOPY_K_CN          gotoblas -> zomatcopy_k_cn\n#define ZOMATCOPY_K_RN          gotoblas -> zomatcopy_k_rn\n#define ZOMATCOPY_K_CT          gotoblas -> zomatcopy_k_ct\n#define ZOMATCOPY_K_RT          gotoblas -> zomatcopy_k_rt\n#define ZOMATCOPY_K_CNC         gotoblas -> zomatcopy_k_cnc\n#define ZOMATCOPY_K_RNC         gotoblas -> zomatcopy_k_rnc\n#define ZOMATCOPY_K_CTC         gotoblas -> zomatcopy_k_ctc\n#define ZOMATCOPY_K_RTC         gotoblas -> zomatcopy_k_rtc\n\n#define ZIMATCOPY_K_CN          gotoblas -> zimatcopy_k_cn\n#define ZIMATCOPY_K_RN          gotoblas -> zimatcopy_k_rn\n#define ZIMATCOPY_K_CT          gotoblas -> zimatcopy_k_ct\n#define ZIMATCOPY_K_RT          gotoblas -> zimatcopy_k_rt\n#define ZIMATCOPY_K_CNC         gotoblas -> zimatcopy_k_cnc\n#define ZIMATCOPY_K_RNC         gotoblas -> zimatcopy_k_rnc\n#define ZIMATCOPY_K_CTC         gotoblas -> zimatcopy_k_ctc\n#define ZIMATCOPY_K_RTC         gotoblas -> zimatcopy_k_rtc\n\n#define ZGEADD_K                gotoblas -> zgeadd_k\n\n#define ZGEMM_SMALL_MATRIX_PERMIT\tgotoblas -> zgemm_small_matrix_permit\n\n#endif\n\n#define ZGEMM_SMALL_KERNEL_NN\t\tFUNC_OFFSET(zgemm_small_kernel_nn)\n#define ZGEMM_SMALL_KERNEL_NT\t\tFUNC_OFFSET(zgemm_small_kernel_nt)\n#define ZGEMM_SMALL_KERNEL_NR\t\tFUNC_OFFSET(zgemm_small_kernel_nr)\n#define ZGEMM_SMALL_KERNEL_NC\t\tFUNC_OFFSET(zgemm_small_kernel_nc)\n\n#define ZGEMM_SMALL_KERNEL_TN\t\tFUNC_OFFSET(zgemm_small_kernel_tn)\n#define ZGEMM_SMALL_KERNEL_TT\t\tFUNC_OFFSET(zgemm_small_kernel_tt)\n#define ZGEMM_SMALL_KERNEL_TR\t\tFUNC_OFFSET(zgemm_small_kernel_tr)\n#define ZGEMM_SMALL_KERNEL_TC\t\tFUNC_OFFSET(zgemm_small_kernel_tc)\n\n#define ZGEMM_SMALL_KERNEL_RN\t\tFUNC_OFFSET(zgemm_small_kernel_rn)\n#define ZGEMM_SMALL_KERNEL_RT\t\tFUNC_OFFSET(zgemm_small_kernel_rt)\n#define ZGEMM_SMALL_KERNEL_RR\t\tFUNC_OFFSET(zgemm_small_kernel_rr)\n#define ZGEMM_SMALL_KERNEL_RC\t\tFUNC_OFFSET(zgemm_small_kernel_rc)\n\n#define ZGEMM_SMALL_KERNEL_CN\t\tFUNC_OFFSET(zgemm_small_kernel_cn)\n#define ZGEMM_SMALL_KERNEL_CT\t\tFUNC_OFFSET(zgemm_small_kernel_ct)\n#define ZGEMM_SMALL_KERNEL_CR\t\tFUNC_OFFSET(zgemm_small_kernel_cr)\n#define ZGEMM_SMALL_KERNEL_CC\t\tFUNC_OFFSET(zgemm_small_kernel_cc)\n\n#define ZGEMM_SMALL_KERNEL_B0_NN\tFUNC_OFFSET(zgemm_small_kernel_b0_nn)\n#define ZGEMM_SMALL_KERNEL_B0_NT\tFUNC_OFFSET(zgemm_small_kernel_b0_nt)\n#define ZGEMM_SMALL_KERNEL_B0_NR\tFUNC_OFFSET(zgemm_small_kernel_b0_nr)\n#define ZGEMM_SMALL_KERNEL_B0_NC\tFUNC_OFFSET(zgemm_small_kernel_b0_nc)\n\n#define ZGEMM_SMALL_KERNEL_B0_TN\tFUNC_OFFSET(zgemm_small_kernel_b0_tn)\n#define ZGEMM_SMALL_KERNEL_B0_TT\tFUNC_OFFSET(zgemm_small_kernel_b0_tt)\n#define ZGEMM_SMALL_KERNEL_B0_TR\tFUNC_OFFSET(zgemm_small_kernel_b0_tr)\n#define ZGEMM_SMALL_KERNEL_B0_TC\tFUNC_OFFSET(zgemm_small_kernel_b0_tc)\n\n#define ZGEMM_SMALL_KERNEL_B0_RN\tFUNC_OFFSET(zgemm_small_kernel_b0_rn)\n#define ZGEMM_SMALL_KERNEL_B0_RT\tFUNC_OFFSET(zgemm_small_kernel_b0_rt)\n#define ZGEMM_SMALL_KERNEL_B0_RR\tFUNC_OFFSET(zgemm_small_kernel_b0_rr)\n#define ZGEMM_SMALL_KERNEL_B0_RC\tFUNC_OFFSET(zgemm_small_kernel_b0_rc)\n\n#define ZGEMM_SMALL_KERNEL_B0_CN\tFUNC_OFFSET(zgemm_small_kernel_b0_cn)\n#define ZGEMM_SMALL_KERNEL_B0_CT\tFUNC_OFFSET(zgemm_small_kernel_b0_ct)\n#define ZGEMM_SMALL_KERNEL_B0_CR\tFUNC_OFFSET(zgemm_small_kernel_b0_cr)\n#define ZGEMM_SMALL_KERNEL_B0_CC\tFUNC_OFFSET(zgemm_small_kernel_b0_cc)\n\n\n#define\tZGEMM_NN\t\tzgemm_nn\n#define\tZGEMM_CN\t\tzgemm_cn\n#define\tZGEMM_TN\t\tzgemm_tn\n#define\tZGEMM_NC\t\tzgemm_nc\n#define\tZGEMM_NT\t\tzgemm_nt\n#define\tZGEMM_CC\t\tzgemm_cc\n#define\tZGEMM_CT\t\tzgemm_ct\n#define\tZGEMM_TC\t\tzgemm_tc\n#define\tZGEMM_TT\t\tzgemm_tt\n#define\tZGEMM_NR\t\tzgemm_nr\n#define\tZGEMM_TR\t\tzgemm_tr\n#define\tZGEMM_CR\t\tzgemm_cr\n#define\tZGEMM_RN\t\tzgemm_rn\n#define\tZGEMM_RT\t\tzgemm_rt\n#define\tZGEMM_RC\t\tzgemm_rc\n#define\tZGEMM_RR\t\tzgemm_rr\n\n#define\tZSYMM_LU\t\tzsymm_LU\n#define\tZSYMM_LL\t\tzsymm_LL\n#define\tZSYMM_RU\t\tzsymm_RU\n#define\tZSYMM_RL\t\tzsymm_RL\n\n#define\tZHEMM_LU\t\tzhemm_LU\n#define\tZHEMM_LL\t\tzhemm_LL\n#define\tZHEMM_RU\t\tzhemm_RU\n#define\tZHEMM_RL\t\tzhemm_RL\n\n#define\tZSYRK_UN\t\tzsyrk_UN\n#define\tZSYRK_UT\t\tzsyrk_UT\n#define\tZSYRK_LN\t\tzsyrk_LN\n#define\tZSYRK_LT\t\tzsyrk_LT\n#define\tZSYRK_UR\t\tzsyrk_UN\n#define\tZSYRK_UC\t\tzsyrk_UT\n#define\tZSYRK_LR\t\tzsyrk_LN\n#define\tZSYRK_LC\t\tzsyrk_LT\n\n#define\tZSYRK_KERNEL_U\t\tzsyrk_kernel_U\n#define\tZSYRK_KERNEL_L\t\tzsyrk_kernel_L\n\n#define\tZHERK_UN\t\tzherk_UN\n#define\tZHERK_LN\t\tzherk_LN\n#define\tZHERK_UC\t\tzherk_UC\n#define\tZHERK_LC\t\tzherk_LC\n\n#define\tZHER2K_UN\t\tzher2k_UN\n#define\tZHER2K_LN\t\tzher2k_LN\n#define\tZHER2K_UC\t\tzher2k_UC\n#define\tZHER2K_LC\t\tzher2k_LC\n\n#define\tZSYR2K_UN\t\tzsyr2k_UN\n#define\tZSYR2K_UT\t\tzsyr2k_UT\n#define\tZSYR2K_LN\t\tzsyr2k_LN\n#define\tZSYR2K_LT\t\tzsyr2k_LT\n#define\tZSYR2K_UR\t\tzsyr2k_UN\n#define\tZSYR2K_UC\t\tzsyr2k_UT\n#define\tZSYR2K_LR\t\tzsyr2k_LN\n#define\tZSYR2K_LC\t\tzsyr2k_LT\n\n#define\tZSYR2K_KERNEL_U\t\tzsyr2k_kernel_U\n#define\tZSYR2K_KERNEL_L\t\tzsyr2k_kernel_L\n\n#define\tZTRMM_LNUU\t\tztrmm_LNUU\n#define\tZTRMM_LNUN\t\tztrmm_LNUN\n#define\tZTRMM_LNLU\t\tztrmm_LNLU\n#define\tZTRMM_LNLN\t\tztrmm_LNLN\n#define\tZTRMM_LTUU\t\tztrmm_LTUU\n#define\tZTRMM_LTUN\t\tztrmm_LTUN\n#define\tZTRMM_LTLU\t\tztrmm_LTLU\n#define\tZTRMM_LTLN\t\tztrmm_LTLN\n#define\tZTRMM_LRUU\t\tztrmm_LRUU\n#define\tZTRMM_LRUN\t\tztrmm_LRUN\n#define\tZTRMM_LRLU\t\tztrmm_LRLU\n#define\tZTRMM_LRLN\t\tztrmm_LRLN\n#define\tZTRMM_LCUU\t\tztrmm_LCUU\n#define\tZTRMM_LCUN\t\tztrmm_LCUN\n#define\tZTRMM_LCLU\t\tztrmm_LCLU\n#define\tZTRMM_LCLN\t\tztrmm_LCLN\n#define\tZTRMM_RNUU\t\tztrmm_RNUU\n#define\tZTRMM_RNUN\t\tztrmm_RNUN\n#define\tZTRMM_RNLU\t\tztrmm_RNLU\n#define\tZTRMM_RNLN\t\tztrmm_RNLN\n#define\tZTRMM_RTUU\t\tztrmm_RTUU\n#define\tZTRMM_RTUN\t\tztrmm_RTUN\n#define\tZTRMM_RTLU\t\tztrmm_RTLU\n#define\tZTRMM_RTLN\t\tztrmm_RTLN\n#define\tZTRMM_RRUU\t\tztrmm_RRUU\n#define\tZTRMM_RRUN\t\tztrmm_RRUN\n#define\tZTRMM_RRLU\t\tztrmm_RRLU\n#define\tZTRMM_RRLN\t\tztrmm_RRLN\n#define\tZTRMM_RCUU\t\tztrmm_RCUU\n#define\tZTRMM_RCUN\t\tztrmm_RCUN\n#define\tZTRMM_RCLU\t\tztrmm_RCLU\n#define\tZTRMM_RCLN\t\tztrmm_RCLN\n\n#define\tZTRSM_LNUU\t\tztrsm_LNUU\n#define\tZTRSM_LNUN\t\tztrsm_LNUN\n#define\tZTRSM_LNLU\t\tztrsm_LNLU\n#define\tZTRSM_LNLN\t\tztrsm_LNLN\n#define\tZTRSM_LTUU\t\tztrsm_LTUU\n#define\tZTRSM_LTUN\t\tztrsm_LTUN\n#define\tZTRSM_LTLU\t\tztrsm_LTLU\n#define\tZTRSM_LTLN\t\tztrsm_LTLN\n#define\tZTRSM_LRUU\t\tztrsm_LRUU\n#define\tZTRSM_LRUN\t\tztrsm_LRUN\n#define\tZTRSM_LRLU\t\tztrsm_LRLU\n#define\tZTRSM_LRLN\t\tztrsm_LRLN\n#define\tZTRSM_LCUU\t\tztrsm_LCUU\n#define\tZTRSM_LCUN\t\tztrsm_LCUN\n#define\tZTRSM_LCLU\t\tztrsm_LCLU\n#define\tZTRSM_LCLN\t\tztrsm_LCLN\n#define\tZTRSM_RNUU\t\tztrsm_RNUU\n#define\tZTRSM_RNUN\t\tztrsm_RNUN\n#define\tZTRSM_RNLU\t\tztrsm_RNLU\n#define\tZTRSM_RNLN\t\tztrsm_RNLN\n#define\tZTRSM_RTUU\t\tztrsm_RTUU\n#define\tZTRSM_RTUN\t\tztrsm_RTUN\n#define\tZTRSM_RTLU\t\tztrsm_RTLU\n#define\tZTRSM_RTLN\t\tztrsm_RTLN\n#define\tZTRSM_RRUU\t\tztrsm_RRUU\n#define\tZTRSM_RRUN\t\tztrsm_RRUN\n#define\tZTRSM_RRLU\t\tztrsm_RRLU\n#define\tZTRSM_RRLN\t\tztrsm_RRLN\n#define\tZTRSM_RCUU\t\tztrsm_RCUU\n#define\tZTRSM_RCUN\t\tztrsm_RCUN\n#define\tZTRSM_RCLU\t\tztrsm_RCLU\n#define\tZTRSM_RCLN\t\tztrsm_RCLN\n\n#define\tZGEMM_THREAD_NN\t\tzgemm_thread_nn\n#define\tZGEMM_THREAD_CN\t\tzgemm_thread_cn\n#define\tZGEMM_THREAD_TN\t\tzgemm_thread_tn\n#define\tZGEMM_THREAD_NC\t\tzgemm_thread_nc\n#define\tZGEMM_THREAD_NT\t\tzgemm_thread_nt\n#define\tZGEMM_THREAD_CC\t\tzgemm_thread_cc\n#define\tZGEMM_THREAD_CT\t\tzgemm_thread_ct\n#define\tZGEMM_THREAD_TC\t\tzgemm_thread_tc\n#define\tZGEMM_THREAD_TT\t\tzgemm_thread_tt\n#define\tZGEMM_THREAD_NR\t\tzgemm_thread_nr\n#define\tZGEMM_THREAD_TR\t\tzgemm_thread_tr\n#define\tZGEMM_THREAD_CR\t\tzgemm_thread_cr\n#define\tZGEMM_THREAD_RN\t\tzgemm_thread_rn\n#define\tZGEMM_THREAD_RT\t\tzgemm_thread_rt\n#define\tZGEMM_THREAD_RC\t\tzgemm_thread_rc\n#define\tZGEMM_THREAD_RR\t\tzgemm_thread_rr\n\n#define\tZSYMM_THREAD_LU\t\tzsymm_thread_LU\n#define\tZSYMM_THREAD_LL\t\tzsymm_thread_LL\n#define\tZSYMM_THREAD_RU\t\tzsymm_thread_RU\n#define\tZSYMM_THREAD_RL\t\tzsymm_thread_RL\n\n#define\tZHEMM_THREAD_LU\t\tzhemm_thread_LU\n#define\tZHEMM_THREAD_LL\t\tzhemm_thread_LL\n#define\tZHEMM_THREAD_RU\t\tzhemm_thread_RU\n#define\tZHEMM_THREAD_RL\t\tzhemm_thread_RL\n\n#define\tZSYRK_THREAD_UN\t\tzsyrk_thread_UN\n#define\tZSYRK_THREAD_UT\t\tzsyrk_thread_UT\n#define\tZSYRK_THREAD_LN\t\tzsyrk_thread_LN\n#define\tZSYRK_THREAD_LT\t\tzsyrk_thread_LT\n#define\tZSYRK_THREAD_UR\t\tzsyrk_thread_UN\n#define\tZSYRK_THREAD_UC\t\tzsyrk_thread_UT\n#define\tZSYRK_THREAD_LR\t\tzsyrk_thread_LN\n#define\tZSYRK_THREAD_LC\t\tzsyrk_thread_LT\n\n#define\tZHERK_THREAD_UN\t\tzherk_thread_UN\n#define\tZHERK_THREAD_UT\t\tzherk_thread_UT\n#define\tZHERK_THREAD_LN\t\tzherk_thread_LN\n#define\tZHERK_THREAD_LT\t\tzherk_thread_LT\n#define\tZHERK_THREAD_UR\t\tzherk_thread_UR\n#define\tZHERK_THREAD_UC\t\tzherk_thread_UC\n#define\tZHERK_THREAD_LR\t\tzherk_thread_LR\n#define\tZHERK_THREAD_LC\t\tzherk_thread_LC\n\n#define\tZGEMM3M_NN\t\tzgemm3m_nn\n#define\tZGEMM3M_CN\t\tzgemm3m_cn\n#define\tZGEMM3M_TN\t\tzgemm3m_tn\n#define\tZGEMM3M_NC\t\tzgemm3m_nc\n#define\tZGEMM3M_NT\t\tzgemm3m_nt\n#define\tZGEMM3M_CC\t\tzgemm3m_cc\n#define\tZGEMM3M_CT\t\tzgemm3m_ct\n#define\tZGEMM3M_TC\t\tzgemm3m_tc\n#define\tZGEMM3M_TT\t\tzgemm3m_tt\n#define\tZGEMM3M_NR\t\tzgemm3m_nr\n#define\tZGEMM3M_TR\t\tzgemm3m_tr\n#define\tZGEMM3M_CR\t\tzgemm3m_cr\n#define\tZGEMM3M_RN\t\tzgemm3m_rn\n#define\tZGEMM3M_RT\t\tzgemm3m_rt\n#define\tZGEMM3M_RC\t\tzgemm3m_rc\n#define\tZGEMM3M_RR\t\tzgemm3m_rr\n\n#define\tZGEMM3M_THREAD_NN\tzgemm3m_thread_nn\n#define\tZGEMM3M_THREAD_CN\tzgemm3m_thread_cn\n#define\tZGEMM3M_THREAD_TN\tzgemm3m_thread_tn\n#define\tZGEMM3M_THREAD_NC\tzgemm3m_thread_nc\n#define\tZGEMM3M_THREAD_NT\tzgemm3m_thread_nt\n#define\tZGEMM3M_THREAD_CC\tzgemm3m_thread_cc\n#define\tZGEMM3M_THREAD_CT\tzgemm3m_thread_ct\n#define\tZGEMM3M_THREAD_TC\tzgemm3m_thread_tc\n#define\tZGEMM3M_THREAD_TT\tzgemm3m_thread_tt\n#define\tZGEMM3M_THREAD_NR\tzgemm3m_thread_nr\n#define\tZGEMM3M_THREAD_TR\tzgemm3m_thread_tr\n#define\tZGEMM3M_THREAD_CR\tzgemm3m_thread_cr\n#define\tZGEMM3M_THREAD_RN\tzgemm3m_thread_rn\n#define\tZGEMM3M_THREAD_RT\tzgemm3m_thread_rt\n#define\tZGEMM3M_THREAD_RC\tzgemm3m_thread_rc\n#define\tZGEMM3M_THREAD_RR\tzgemm3m_thread_rr\n\n#define\tZSYMM3M_LU\t\tzsymm3m_LU\n#define\tZSYMM3M_LL\t\tzsymm3m_LL\n#define\tZSYMM3M_RU\t\tzsymm3m_RU\n#define\tZSYMM3M_RL\t\tzsymm3m_RL\n\n#define\tZSYMM3M_THREAD_LU\tzsymm3m_thread_LU\n#define\tZSYMM3M_THREAD_LL\tzsymm3m_thread_LL\n#define\tZSYMM3M_THREAD_RU\tzsymm3m_thread_RU\n#define\tZSYMM3M_THREAD_RL\tzsymm3m_thread_RL\n\n#define\tZHEMM3M_LU\t\tzhemm3m_LU\n#define\tZHEMM3M_LL\t\tzhemm3m_LL\n#define\tZHEMM3M_RU\t\tzhemm3m_RU\n#define\tZHEMM3M_RL\t\tzhemm3m_RL\n\n#define\tZHEMM3M_THREAD_LU\tzhemm3m_thread_LU\n#define\tZHEMM3M_THREAD_LL\tzhemm3m_thread_LL\n#define\tZHEMM3M_THREAD_RU\tzhemm3m_thread_RU\n#define\tZHEMM3M_THREAD_RL\tzhemm3m_thread_RL\n\n#endif\n"
        },
        {
          "name": "common_zarch.h",
          "type": "blob",
          "size": 3.6259765625,
          "content": "/*****************************************************************************\nCopyright (c) 2011-2016, The OpenBLAS Project\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   1. Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n\n   2. Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in\n      the documentation and/or other materials provided with the\n      distribution.\n   3. Neither the name of the OpenBLAS project nor the names of \n      its contributors may be used to endorse or promote products \n      derived from this software without specific prior written \n      permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\nUSE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n**********************************************************************************/\n\n#ifndef COMMON_ZARCH\n#define COMMON_ZARCH\n\n#define MB   \n#define WMB  \n#define RMB\n\n#define RETURN_BY_COMPLEX\n\n#ifndef ASSEMBLER\n\n  /*\nstatic __inline void blas_lock(volatile BLASULONG *address){\n\n  BLASULONG ret;\n\n  do {\n    while (*address) {YIELDING;};\n\n    __asm__ __volatile__(\n\t\t\t \"mov\tx4, #1\t\t\t\t\t\t\t\\n\\t\"\n                         \"1:                                                            \\n\\t\"\n                         \"ldaxr x2, [%1]                                                \\n\\t\"\n                         \"cbnz  x2, 1b                                                  \\n\\t\"\n\t\t\t \"2:\t\t\t\t\t\t\t\t\\n\\t\"\n                         \"stxr  w3, x4, [%1]                                            \\n\\t\"\n                         \"cbnz  w3, 1b                                                  \\n\\t\"\n                         \"mov   %0, #0                                                  \\n\\t\"\n                         : \"=r\"(ret), \"=r\"(address)\n                         : \"1\"(address)\n                         : \"memory\", \"x2\" , \"x3\", \"x4\"\n\n\n    );\n\n\n  } while (ret);\n\n}\n  */\n//#define BLAS_LOCK_DEFINED\n\n\n\nstatic inline int blas_quickdivide(blasint x, blasint y){\n  return x / y;\n}\n\n#if defined(DOUBLE)\n#define GET_IMAGE(res)  __asm__ __volatile__(\"str d1, %0\" : \"=m\"(res) : : \"memory\")\n#else\n#define GET_IMAGE(res)  __asm__ __volatile__(\"str s1, %0\" : \"=m\"(res) : : \"memory\")\n#endif\n\n#define GET_IMAGE_CANCEL\n\n#endif\n\n\n#ifndef F_INTERFACE\n#define REALNAME ASMNAME\n#else\n#define REALNAME ASMFNAME\n#endif\n\n#if defined(ASSEMBLER) && !defined(NEEDPARAM)\n\n#define PROLOGUE \\\n\t.text ;\\\n\t.align\t256 ;\\\n\t.global\tREALNAME ;\\\n\t.type\tREALNAME, %function ;\\\nREALNAME:\n \n\n#define EPILOGUE\n\n#define PROFCODE\n\n#endif\n\n\n#define SEEK_ADDRESS\n\n#ifndef PAGESIZE\n#define PAGESIZE        ( 4 << 10)\n#endif\n#define HUGE_PAGESIZE   ( 4 << 20)\n\n#define BUFFER_SIZE     (32 << 22)\n\n\n#define BASE_ADDRESS (START_ADDRESS - BUFFER_SIZE * MAX_CPU_NUMBER)\n\n#ifndef MAP_ANONYMOUS\n#define MAP_ANONYMOUS MAP_ANON\n#endif\n\n#endif\n\n"
        },
        {
          "name": "cpp_thread_test",
          "type": "tree",
          "content": null
        },
        {
          "name": "cpuid.S",
          "type": "blob",
          "size": 2.978515625,
          "content": "/*********************************************************************/\n/* Copyright 2009, 2010 The University of Texas at Austin.           */\n/* All rights reserved.                                              */\n/*                                                                   */\n/* Redistribution and use in source and binary forms, with or        */\n/* without modification, are permitted provided that the following   */\n/* conditions are met:                                               */\n/*                                                                   */\n/*   1. Redistributions of source code must retain the above         */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer.                                                  */\n/*                                                                   */\n/*   2. Redistributions in binary form must reproduce the above      */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer in the documentation and/or other materials       */\n/*      provided with the distribution.                              */\n/*                                                                   */\n/*    THIS  SOFTWARE IS PROVIDED  BY THE  UNIVERSITY OF  TEXAS AT    */\n/*    AUSTIN  ``AS IS''  AND ANY  EXPRESS OR  IMPLIED WARRANTIES,    */\n/*    INCLUDING, BUT  NOT LIMITED  TO, THE IMPLIED  WARRANTIES OF    */\n/*    MERCHANTABILITY  AND FITNESS FOR  A PARTICULAR  PURPOSE ARE    */\n/*    DISCLAIMED.  IN  NO EVENT SHALL THE UNIVERSITY  OF TEXAS AT    */\n/*    AUSTIN OR CONTRIBUTORS BE  LIABLE FOR ANY DIRECT, INDIRECT,    */\n/*    INCIDENTAL,  SPECIAL, EXEMPLARY,  OR  CONSEQUENTIAL DAMAGES    */\n/*    (INCLUDING, BUT  NOT LIMITED TO,  PROCUREMENT OF SUBSTITUTE    */\n/*    GOODS  OR  SERVICES; LOSS  OF  USE,  DATA,  OR PROFITS;  OR    */\n/*    BUSINESS INTERRUPTION) HOWEVER CAUSED  AND ON ANY THEORY OF    */\n/*    LIABILITY, WHETHER  IN CONTRACT, STRICT  LIABILITY, OR TORT    */\n/*    (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY WAY OUT    */\n/*    OF  THE  USE OF  THIS  SOFTWARE,  EVEN  IF ADVISED  OF  THE    */\n/*    POSSIBILITY OF SUCH DAMAGE.                                    */\n/*                                                                   */\n/* The views and conclusions contained in the software and           */\n/* documentation are those of the authors and should not be          */\n/* interpreted as representing official policies, either expressed   */\n/* or implied, of The University of Texas at Austin.                 */\n/*********************************************************************/\n\n#if defined(__APPLE__) && defined(__i386__)\n\n/* Quick hack for Darwin/x86 */\n\n\t.text\n\t.globl _cpuid\n_cpuid:\n\tpushl\t%esi\n\tpushl\t%ebx\n\n\tmovl\t12(%esp), %eax\n\tcpuid\n\n\tmovl\t16(%esp), %esi\n\tmovl\t%eax, (%esi)\n\tmovl\t20(%esp), %esi\n\tmovl\t%ebx, (%esi)\n\tmovl\t24(%esp), %esi\n\tmovl\t%ecx, (%esi)\n\tmovl\t28(%esp), %esi\n\tmovl\t%edx, (%esi)\n\n\tpopl\t%ebx\n\tpopl\t%esi\n\tret\n\n\t.subsections_via_symbols\n\n#endif\n"
        },
        {
          "name": "cpuid.h",
          "type": "blob",
          "size": 7.517578125,
          "content": "/*********************************************************************/\n/* Copyright 2009, 2010 The University of Texas at Austin.           */\n/* All rights reserved.                                              */\n/*                                                                   */\n/* Redistribution and use in source and binary forms, with or        */\n/* without modification, are permitted provided that the following   */\n/* conditions are met:                                               */\n/*                                                                   */\n/*   1. Redistributions of source code must retain the above         */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer.                                                  */\n/*                                                                   */\n/*   2. Redistributions in binary form must reproduce the above      */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer in the documentation and/or other materials       */\n/*      provided with the distribution.                              */\n/*                                                                   */\n/*    THIS  SOFTWARE IS PROVIDED  BY THE  UNIVERSITY OF  TEXAS AT    */\n/*    AUSTIN  ``AS IS''  AND ANY  EXPRESS OR  IMPLIED WARRANTIES,    */\n/*    INCLUDING, BUT  NOT LIMITED  TO, THE IMPLIED  WARRANTIES OF    */\n/*    MERCHANTABILITY  AND FITNESS FOR  A PARTICULAR  PURPOSE ARE    */\n/*    DISCLAIMED.  IN  NO EVENT SHALL THE UNIVERSITY  OF TEXAS AT    */\n/*    AUSTIN OR CONTRIBUTORS BE  LIABLE FOR ANY DIRECT, INDIRECT,    */\n/*    INCIDENTAL,  SPECIAL, EXEMPLARY,  OR  CONSEQUENTIAL DAMAGES    */\n/*    (INCLUDING, BUT  NOT LIMITED TO,  PROCUREMENT OF SUBSTITUTE    */\n/*    GOODS  OR  SERVICES; LOSS  OF  USE,  DATA,  OR PROFITS;  OR    */\n/*    BUSINESS INTERRUPTION) HOWEVER CAUSED  AND ON ANY THEORY OF    */\n/*    LIABILITY, WHETHER  IN CONTRACT, STRICT  LIABILITY, OR TORT    */\n/*    (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY WAY OUT    */\n/*    OF  THE  USE OF  THIS  SOFTWARE,  EVEN  IF ADVISED  OF  THE    */\n/*    POSSIBILITY OF SUCH DAMAGE.                                    */\n/*                                                                   */\n/* The views and conclusions contained in the software and           */\n/* documentation are those of the authors and should not be          */\n/* interpreted as representing official policies, either expressed   */\n/* or implied, of The University of Texas at Austin.                 */\n/*********************************************************************/\n\n#ifndef CPUID_H\n#define CPUID_H\n\n#if defined(__i386__) || defined(__x86_64__) || defined(_M_IX86) || defined(_M_X64)\n#define INTEL_AMD\n#endif\n\n#define VENDOR_INTEL      1\n#define VENDOR_UMC        2\n#define VENDOR_AMD        3\n#define VENDOR_CYRIX      4\n#define VENDOR_NEXGEN     5\n#define VENDOR_CENTAUR    6\n#define VENDOR_RISE       7\n#define VENDOR_SIS\t  8\n#define VENDOR_TRANSMETA  9\n#define VENDOR_NSC\t 10\n#define VENDOR_HYGON\t 11\n#define VENDOR_ZHAOXIN   12\n#define VENDOR_UNKNOWN   99\n\n#define BITMASK(a, b, c) ((((a) >> (b)) & (c)))\n\n#define FAMILY_80486  4\n#define FAMILY_P5     5\n#define FAMILY_P6     6\n#define FAMILY_PM     7\n#define FAMILY_IA64   8\n\n#ifdef INTEL_AMD\n#define GET_EXFAMILY  1\n#define GET_EXMODEL   2\n#define GET_TYPE      3\n#define GET_FAMILY    4\n#define GET_MODEL     5\n#define GET_APICID    6\n#define GET_LCOUNT    7\n#define GET_CHUNKS    8\n#define GET_STEPPING  9\n#define GET_BLANDID  10\n#define GET_FEATURE  11\n#define GET_NUMSHARE 12\n#define GET_NUMCORES 13\n#endif\n\n#ifdef __ia64__\n#define GET_ARCHREV   1\n#define GET_FAMILY    2\n#define GET_MODEL     3\n#define GET_REVISION  4\n#define GET_NUMBER    5\n#endif\n\n#define CORE_UNKNOWN     0\n#define CORE_80486       1\n#define CORE_P5          2\n#define CORE_P6          3\n#define CORE_KATMAI      4\n#define CORE_COPPERMINE  5\n#define CORE_NORTHWOOD   6\n#define CORE_PRESCOTT    7\n#define CORE_BANIAS      8\n#define CORE_ATHLON      9\n#define CORE_OPTERON    10\n#define CORE_BARCELONA  11\n#define CORE_VIAC3      12\n#define CORE_YONAH\t13\n#define CORE_CORE2\t14\n#define CORE_PENRYN\t15\n#define CORE_DUNNINGTON\t16\n#define CORE_NEHALEM\t17\n#define CORE_ATOM\t18\n#define CORE_NANO\t19\n#define CORE_SANDYBRIDGE 20\n#define CORE_BOBCAT      21\n#define CORE_BULLDOZER   22\n#define CORE_PILEDRIVER  23\n#define CORE_HASWELL     24\n#define CORE_STEAMROLLER 25\n#define CORE_EXCAVATOR   26\n#define CORE_ZEN         27\n#define CORE_SKYLAKEX    28\n#define CORE_DHYANA\t 29\n#define CORE_COOPERLAKE  30\n#define CORE_SAPPHIRERAPIDS  31\n\n#define HAVE_SSE      (1 <<  0)\n#define HAVE_SSE2     (1 <<  1)\n#define HAVE_SSE3     (1 <<  2)\n#define HAVE_SSSE3    (1 <<  3)\n#define HAVE_SSE4_1   (1 <<  4)\n#define HAVE_SSE4_2   (1 <<  5)\n#define HAVE_SSE4A    (1 <<  6)\n#define HAVE_SSE5     (1 <<  7)\n#define HAVE_MMX      (1 <<  8)\n#define HAVE_3DNOW    (1 <<  9)\n#define HAVE_3DNOWEX  (1 << 10)\n#define HAVE_CMOV     (1 << 11)\n#define HAVE_PSE      (1 << 12)\n#define HAVE_CFLUSH   (1 << 13)\n#define HAVE_HIT      (1 << 14)\n#define HAVE_MISALIGNSSE (1 << 15)\n#define HAVE_128BITFPU   (1 << 16)\n#define HAVE_FASTMOVU    (1 << 17)\n#define HAVE_AVX      (1 << 18)\n#define HAVE_FMA4     (1 << 19)\n#define HAVE_FMA3     (1 << 20)\n#define HAVE_AVX512VL (1 << 21)\n#define HAVE_AVX2     (1 << 22)\n#define HAVE_AVX512BF16  (1 << 23)\n#define HAVE_AMXBF16  (1 << 24)\n\n#define CACHE_INFO_L1_I     1\n#define CACHE_INFO_L1_D     2\n#define CACHE_INFO_L2       3\n#define CACHE_INFO_L3       4\n#define CACHE_INFO_L1_ITB   5\n#define CACHE_INFO_L1_DTB   6\n#define CACHE_INFO_L1_LITB  7\n#define CACHE_INFO_L1_LDTB  8\n#define CACHE_INFO_L2_ITB   9\n#define CACHE_INFO_L2_DTB  10\n#define CACHE_INFO_L2_LITB 11\n#define CACHE_INFO_L2_LDTB 12\n\ntypedef struct {\n  int size;\n  int associative;\n  int linesize;\n  int shared;\n} cache_info_t;\n\n#define CPUTYPE_UNKNOWN\t\t\t 0\n#define CPUTYPE_INTEL_UNKNOWN\t\t 1\n#define CPUTYPE_UMC_UNKNOWN\t\t 2\n#define CPUTYPE_AMD_UNKNOWN\t\t 3\n#define CPUTYPE_CYRIX_UNKNOWN\t\t 4\n#define CPUTYPE_NEXGEN_UNKNOWN\t\t 5\n#define CPUTYPE_CENTAUR_UNKNOWN\t\t 6\n#define CPUTYPE_RISE_UNKNOWN\t\t 7\n#define CPUTYPE_SIS_UNKNOWN\t\t 8\n#define CPUTYPE_TRANSMETA_UNKNOWN\t 9\n#define CPUTYPE_NSC_UNKNOWN\t\t10\n\n#define CPUTYPE_80386\t\t\t11\n#define CPUTYPE_80486\t\t\t12\n#define CPUTYPE_PENTIUM\t\t\t13\n#define CPUTYPE_PENTIUM2\t\t14\n#define CPUTYPE_PENTIUM3\t\t15\n#define CPUTYPE_PENTIUMM\t\t16\n#define CPUTYPE_PENTIUM4\t\t17\n#define CPUTYPE_CORE2\t\t\t18\n#define CPUTYPE_PENRYN\t\t\t19\n#define CPUTYPE_DUNNINGTON\t\t20\n#define CPUTYPE_NEHALEM\t\t\t21\n#define CPUTYPE_ATOM\t\t\t22\n#define CPUTYPE_ITANIUM\t\t\t23\n#define CPUTYPE_ITANIUM2\t\t24\n#define CPUTYPE_AMD5X86\t\t\t25\n#define CPUTYPE_AMDK6\t\t\t26\n#define CPUTYPE_ATHLON\t\t\t27\n#define CPUTYPE_DURON\t\t\t28\n#define CPUTYPE_OPTERON\t\t\t29\n#define CPUTYPE_BARCELONA\t\t30\n#define CPUTYPE_SHANGHAI\t\t31\n#define CPUTYPE_ISTANBUL\t\t32\n#define CPUTYPE_CYRIX5X86\t\t33\n#define CPUTYPE_CYRIXM1\t\t\t34\n#define CPUTYPE_CYRIXM2\t\t\t35\n#define CPUTYPE_NEXGENNX586\t\t36\n#define CPUTYPE_CENTAURC6\t\t37\n#define CPUTYPE_RISEMP6\t\t\t38\n#define CPUTYPE_SYS55X\t\t\t39\n#define CPUTYPE_CRUSOETM3X\t\t40\n#define CPUTYPE_NSGEODE\t\t\t41\n#define CPUTYPE_VIAC3\t\t\t42\n#define CPUTYPE_NANO\t\t\t43\n#define CPUTYPE_SANDYBRIDGE             44\n#define CPUTYPE_BOBCAT                  45\n#define CPUTYPE_BULLDOZER               46\n#define CPUTYPE_PILEDRIVER              47\n#define CPUTYPE_HASWELL \t\t48\n#define CPUTYPE_STEAMROLLER \t\t49\n#define CPUTYPE_EXCAVATOR \t\t50\n#define CPUTYPE_ZEN \t\t\t51\n#define CPUTYPE_SKYLAKEX\t\t52\n#define CPUTYPE_DHYANA\t\t\t53\n#define CPUTYPE_COOPERLAKE\t\t54\n#define CPUTYPE_SAPPHIRERAPIDS\t\t55\n\n#define CPUTYPE_HYGON_UNKNOWN\t\t99\n\n#endif\n"
        },
        {
          "name": "cpuid_alpha.c",
          "type": "blob",
          "size": 4.029296875,
          "content": "/*********************************************************************/\n/* Copyright 2009, 2010 The University of Texas at Austin.           */\n/* All rights reserved.                                              */\n/*                                                                   */\n/* Redistribution and use in source and binary forms, with or        */\n/* without modification, are permitted provided that the following   */\n/* conditions are met:                                               */\n/*                                                                   */\n/*   1. Redistributions of source code must retain the above         */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer.                                                  */\n/*                                                                   */\n/*   2. Redistributions in binary form must reproduce the above      */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer in the documentation and/or other materials       */\n/*      provided with the distribution.                              */\n/*                                                                   */\n/*    THIS  SOFTWARE IS PROVIDED  BY THE  UNIVERSITY OF  TEXAS AT    */\n/*    AUSTIN  ``AS IS''  AND ANY  EXPRESS OR  IMPLIED WARRANTIES,    */\n/*    INCLUDING, BUT  NOT LIMITED  TO, THE IMPLIED  WARRANTIES OF    */\n/*    MERCHANTABILITY  AND FITNESS FOR  A PARTICULAR  PURPOSE ARE    */\n/*    DISCLAIMED.  IN  NO EVENT SHALL THE UNIVERSITY  OF TEXAS AT    */\n/*    AUSTIN OR CONTRIBUTORS BE  LIABLE FOR ANY DIRECT, INDIRECT,    */\n/*    INCIDENTAL,  SPECIAL, EXEMPLARY,  OR  CONSEQUENTIAL DAMAGES    */\n/*    (INCLUDING, BUT  NOT LIMITED TO,  PROCUREMENT OF SUBSTITUTE    */\n/*    GOODS  OR  SERVICES; LOSS  OF  USE,  DATA,  OR PROFITS;  OR    */\n/*    BUSINESS INTERRUPTION) HOWEVER CAUSED  AND ON ANY THEORY OF    */\n/*    LIABILITY, WHETHER  IN CONTRACT, STRICT  LIABILITY, OR TORT    */\n/*    (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY WAY OUT    */\n/*    OF  THE  USE OF  THIS  SOFTWARE,  EVEN  IF ADVISED  OF  THE    */\n/*    POSSIBILITY OF SUCH DAMAGE.                                    */\n/*                                                                   */\n/* The views and conclusions contained in the software and           */\n/* documentation are those of the authors and should not be          */\n/* interpreted as representing official policies, either expressed   */\n/* or implied, of The University of Texas at Austin.                 */\n/*********************************************************************/\n\n#if defined(__alpha) && defined(__DECC)\n#include <c_asm.h>\n#endif\n\nint implver(void){\n  int arch;\n\n#ifndef __DECC\n  asm __volatile__(\"implver %0\" : \"=r\"(arch)  : : \"memory\");\n#else\n  arch = asm(\"implver %v0\");\n#endif\n  return arch;\n}\n\nvoid get_architecture(void){\n  printf(\"ALPHA\");\n}\n\nvoid get_subarchitecture(void){\n  printf(\"ev%d\", implver() + 4);\n}\n\n\nvoid get_corename(void){\n  printf(\"EV%d\", implver() + 4);\n}\n\nvoid get_subdirname(void){\n  printf(\"alpha\");\n}\n\nvoid get_cpuconfig(void){\n  printf(\"#define EV%d\\n\", implver() + 4);\n\n  switch (implver()){\n  case 0:\n    printf(\"#define L1_DATA_SIZE 16384\\n\");\n    printf(\"#define L1_DATA_LINESIZE 32\\n\");\n    printf(\"#define L2_SIZE 2097152\\n\");\n    printf(\"#define L2_LINESIZE 32\\n\");\n    printf(\"#define DTB_DEFAULT_ENTRIES 32\\n\");\n    printf(\"#define DTB_SIZE 8192\\n\");\n    break;\n\n  case 1:\n    printf(\"#define L1_DATA_SIZE 16384\\n\");\n    printf(\"#define L1_DATA_LINESIZE 32\\n\");\n    printf(\"#define L2_SIZE 2097152\\n\");\n    printf(\"#define L2_LINESIZE 64\\n\");\n    printf(\"#define DTB_DEFAULT_ENTRIES 64\\n\");\n    printf(\"#define DTB_SIZE 8192\\n\");\n    break;\n\n  case 2:\n    printf(\"#define L1_DATA_SIZE 32768\\n\");\n    printf(\"#define L1_DATA_LINESIZE 64\\n\");\n    printf(\"#define L2_SIZE 4194304\\n\");\n    printf(\"#define L2_LINESIZE 64\\n\");\n    printf(\"#define DTB_DEFAULT_ENTRIES 64\\n\");\n    printf(\"#define DTB_SIZE 8192\\n\");\n    break;\n  }\n}\n\nvoid get_libname(void){\n  printf(\"ev%d\\n\", implver() + 4);\n}\n"
        },
        {
          "name": "cpuid_arm.c",
          "type": "blob",
          "size": 7.197265625,
          "content": "/**************************************************************************\n  Copyright (c) 2013, The OpenBLAS Project\n  All rights reserved.\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are\n  met:\n  1. Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the following disclaimer.\n  2. Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the following disclaimer in\n  the documentation and/or other materials provided with the\n  distribution.\n  3. Neither the name of the OpenBLAS project nor the names of\n  its contributors may be used to endorse or promote products\n  derived from this software without specific prior written permission.\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL THE OPENBLAS PROJECT OR CONTRIBUTORS BE\n  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\n  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n  *****************************************************************************/\n\n#include <string.h>\n\n#define CPU_UNKNOWN     \t0\n#define CPU_ARMV6       \t1\n#define CPU_ARMV7       \t2\n#define CPU_CORTEXA9       \t3\n#define CPU_CORTEXA15       \t4\n\nstatic char *cpuname[] = {\n  \"UNKNOWN\",\n  \"ARMV6\",\n  \"ARMV7\",\n  \"CORTEXA9\",\n  \"CORTEXA15\"\n};\n\n\nstatic char *cpuname_lower[] = {\n  \"unknown\",\n  \"armv6\",\n  \"armv7\",\n  \"cortexa9\",\n  \"cortexa15\"\n};\n\n\nint get_feature(char *search)\n{\n\n#ifdef __linux\n\tFILE *infile;\n  \tchar buffer[2048], *p,*t;\n  \tp = (char *) NULL ;\n\n  \tinfile = fopen(\"/proc/cpuinfo\", \"r\");\n\n\twhile (fgets(buffer, sizeof(buffer), infile))\n\t{\n\n\t\tif (!strncmp(\"Features\", buffer, 8))\n\t\t{\n\t\t\tp = strchr(buffer, ':') + 2;\n\t\t\tbreak;\n      \t\t}\n  \t}\n\n  \tfclose(infile);\n\n\n\tif( p == NULL ) return 0;\n\n\tt = strtok(p,\" \");\n\twhile( t = strtok(NULL,\" \"))\n\t{\n\t\tif (!strcmp(t, search))   { return(1); }\n\t}\n\n#endif\n\treturn(0);\n}\n\n\nint detect(void)\n{\n\n#ifdef __linux\n\n\tFILE *infile;\n  \tchar buffer[512], *p;\n  \tp = (char *) NULL ;\n\n  \tinfile = fopen(\"/proc/cpuinfo\", \"r\");\n\twhile (fgets(buffer, sizeof(buffer), infile))\n\t{\n\n\t\tif (!strncmp(\"CPU part\", buffer, 8))\n\t\t{\n\t\t\tp = strchr(buffer, ':') + 2;\n\t\t\tbreak;\n      \t\t}\n  \t}\n\n  \tfclose(infile);\n  \tif(p != NULL) {\n\t  if (strstr(p, \"0xc09\")) {\n\t    return CPU_CORTEXA9;\n\t  }\n\t  if (strstr(p, \"0xc0f\")) {\n\t    return CPU_CORTEXA15;\n\t  }\n\t  if (strstr(p, \"0xd07\")) {\n\t    return CPU_ARMV7;  //ARMV8 on 32-bit\n\t  }\n\n\t}\n\n  \tp = (char *) NULL ;\n  \tinfile = fopen(\"/proc/cpuinfo\", \"r\");\n\n\twhile (fgets(buffer, sizeof(buffer), infile))\n\t{\n\n\t\tif ((!strncmp(\"model name\", buffer, 10)) || (!strncmp(\"Processor\", buffer, 9)))\n\t\t{\n\t\t\tp = strchr(buffer, ':') + 2;\n\t\t\tbreak;\n      \t\t}\n  \t}\n\n  \tfclose(infile);\n\n  \tif(p != NULL)\n\t{\n\n\t\tif (strstr(p, \"ARMv7\"))\n\t\t{\n\t\t\t if ( get_feature(\"vfpv4\"))\n\t\t\t \treturn CPU_ARMV7;\n\n\t\t\t if ( get_feature(\"vfpv3\"))\n\t\t\t \treturn CPU_ARMV7;\n\n\t\t\t if ( get_feature(\"vfp\"))\n\t\t\t \treturn CPU_ARMV6;\n\n\n\t\t}\n\n\t\tif (strstr(p, \"ARMv6\"))\n\t\t{\n\t\t\t if ( get_feature(\"vfp\"))\n\t\t\t \treturn CPU_ARMV6;\n\t\t}\n\n\n\t}\n\n  \tp = (char *) NULL ;\n  \tinfile = fopen(\"/proc/cpuinfo\", \"r\");\n\n\twhile (fgets(buffer, sizeof(buffer), infile))\n\t{\n\n\t\tif ((!strncmp(\"CPU architecture\", buffer, 16)))\n\t\t{\n\t\t\tp = strchr(buffer, ':') + 2;\n\t\t\tbreak;\n      \t\t}\n  \t}\n  \tfclose(infile);\n  \tif(p != NULL) {\n\t  if (strstr(p, \"8\")) {\n\t    return CPU_ARMV7;  //ARMV8 on 32-bit\n\t  }\n\n\t}\n\n#endif\n\n\treturn CPU_UNKNOWN;\n}\n\nchar *get_corename(void)\n{\n\treturn cpuname[detect()];\n}\n\nvoid get_architecture(void)\n{\n\tprintf(\"ARM\");\n}\n\nvoid get_subarchitecture(void)\n{\n\tint d = detect();\n\tprintf(\"%s\", cpuname[d]);\n}\n\nvoid get_subdirname(void)\n{\n\tprintf(\"arm\");\n}\n\nvoid get_cpuconfig(void)\n{\n\n\tint d = detect();\n\tswitch (d)\n\t{\n\t       case CPU_CORTEXA9:\n    \t\t\tprintf(\"#define CORTEXA9\\n\");\n    \t\t\tprintf(\"#define ARMV7\\n\");\n    \t\t\tprintf(\"#define HAVE_VFP\\n\");\n    \t\t\tprintf(\"#define HAVE_VFPV3\\n\");\n\t\t\tif ( get_feature(\"neon\"))\tprintf(\"#define HAVE_NEON\\n\");\n\t\t\tif ( get_feature(\"vfpv4\"))\tprintf(\"#define HAVE_VFPV4\\n\");\n    \t\t\tprintf(\"#define L1_DATA_SIZE 32768\\n\");\n    \t\t\tprintf(\"#define L1_DATA_LINESIZE 32\\n\");\n    \t\t\tprintf(\"#define L2_SIZE 1048576\\n\");\n    \t\t\tprintf(\"#define L2_LINESIZE 32\\n\");\n    \t\t\tprintf(\"#define DTB_DEFAULT_ENTRIES 128\\n\");\n    \t\t\tprintf(\"#define DTB_SIZE 4096\\n\");\n    \t\t\tprintf(\"#define L2_ASSOCIATIVE 4\\n\");\n\t\t\tbreak;\n\n\t       case CPU_CORTEXA15:\n    \t\t\tprintf(\"#define CORTEXA15\\n\");\n    \t\t\tprintf(\"#define ARMV7\\n\");\n    \t\t\tprintf(\"#define HAVE_VFP\\n\");\n    \t\t\tprintf(\"#define HAVE_VFPV3\\n\");\n\t\t\tif ( get_feature(\"neon\"))\tprintf(\"#define HAVE_NEON\\n\");\n\t\t\tif ( get_feature(\"vfpv4\"))\tprintf(\"#define HAVE_VFPV4\\n\");\n    \t\t\tprintf(\"#define L1_DATA_SIZE 32768\\n\");\n    \t\t\tprintf(\"#define L1_DATA_LINESIZE 32\\n\");\n    \t\t\tprintf(\"#define L2_SIZE 1048576\\n\");\n    \t\t\tprintf(\"#define L2_LINESIZE 32\\n\");\n    \t\t\tprintf(\"#define DTB_DEFAULT_ENTRIES 128\\n\");\n    \t\t\tprintf(\"#define DTB_SIZE 4096\\n\");\n    \t\t\tprintf(\"#define L2_ASSOCIATIVE 4\\n\");\n\t\t\tbreak;\n\n\n\t\tcase CPU_ARMV7:\n    \t\t\tprintf(\"#define ARMV7\\n\");\n    \t\t\tprintf(\"#define HAVE_VFP\\n\");\n    \t\t\tprintf(\"#define HAVE_VFPV3\\n\");\n\t\t\tif ( get_feature(\"neon\"))\tprintf(\"#define HAVE_NEON\\n\");\n\t\t\tif ( get_feature(\"vfpv4\"))\tprintf(\"#define HAVE_VFPV4\\n\");\n    \t\t\tprintf(\"#define L1_DATA_SIZE 65536\\n\");\n    \t\t\tprintf(\"#define L1_DATA_LINESIZE 32\\n\");\n    \t\t\tprintf(\"#define L2_SIZE 512488\\n\");\n    \t\t\tprintf(\"#define L2_LINESIZE 32\\n\");\n    \t\t\tprintf(\"#define DTB_DEFAULT_ENTRIES 64\\n\");\n    \t\t\tprintf(\"#define DTB_SIZE 4096\\n\");\n    \t\t\tprintf(\"#define L2_ASSOCIATIVE 4\\n\");\n\t\t\tbreak;\n\n\t\tcase CPU_ARMV6:\n    \t\t\tprintf(\"#define ARMV6\\n\");\n    \t\t\tprintf(\"#define HAVE_VFP\\n\");\n    \t\t\tprintf(\"#define L1_DATA_SIZE 65536\\n\");\n    \t\t\tprintf(\"#define L1_DATA_LINESIZE 32\\n\");\n    \t\t\tprintf(\"#define L2_SIZE 512488\\n\");\n    \t\t\tprintf(\"#define L2_LINESIZE 32\\n\");\n    \t\t\tprintf(\"#define DTB_DEFAULT_ENTRIES 64\\n\");\n    \t\t\tprintf(\"#define DTB_SIZE 4096\\n\");\n    \t\t\tprintf(\"#define L2_ASSOCIATIVE 4\\n\");\n\t\t\tbreak;\n\n\t}\n}\n\n\nvoid get_libname(void)\n{\n\n\tint d = detect();\n\tprintf(\"%s\", cpuname_lower[d]);\n}\n\n\nvoid get_features(void)\n{\n\n#ifdef __linux\n\tFILE *infile;\n  \tchar buffer[2048], *p,*t;\n  \tp = (char *) NULL ;\n\n  \tinfile = fopen(\"/proc/cpuinfo\", \"r\");\n\n\twhile (fgets(buffer, sizeof(buffer), infile))\n\t{\n\n\t\tif (!strncmp(\"Features\", buffer, 8))\n\t\t{\n\t\t\tp = strchr(buffer, ':') + 2;\n\t\t\tbreak;\n      \t\t}\n  \t}\n\n  \tfclose(infile);\n\n\n\tif( p == NULL ) return;\n\n\tt = strtok(p,\" \");\n\twhile( t = strtok(NULL,\" \"))\n\t{\n\t\tif (!strcmp(t, \"vfp\"))   { printf(\"HAVE_VFP=1\\n\"); continue; }\n\t\tif (!strcmp(t, \"vfpv3\")) { printf(\"HAVE_VFPV3=1\\n\"); continue; }\n\t\tif (!strcmp(t, \"vfpv4\")) { printf(\"HAVE_VFPV4=1\\n\"); continue; }\n\t\tif (!strcmp(t, \"neon\"))  { printf(\"HAVE_NEON=1\\n\"); continue; }\n\t}\n\n#endif\n\treturn;\n}\n\n\n"
        },
        {
          "name": "cpuid_arm64.c",
          "type": "blob",
          "size": 22.5625,
          "content": "/**************************************************************************\n  Copyright (c) 2013, The OpenBLAS Project\n  All rights reserved.\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are\n  met:\n  1. Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the following disclaimer.\n  2. Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the following disclaimer in\n  the documentation and/or other materials provided with the\n  distribution.\n  3. Neither the name of the OpenBLAS project nor the names of\n  its contributors may be used to endorse or promote products\n  derived from this software without specific prior written permission.\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL THE OPENBLAS PROJECT OR CONTRIBUTORS BE\n  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\n  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n  *****************************************************************************/\n\n#include <stdlib.h>\n#include <string.h>\n#ifdef __APPLE__\n#include <sys/sysctl.h>\nint32_t value;\nsize_t length=sizeof(value);\nint64_t value64;\nsize_t length64=sizeof(value64);\n#endif\n#if (defined OS_LINUX || defined OS_ANDROID)\n#include <asm/hwcap.h>\n#include <sys/auxv.h>\n#ifndef HWCAP_CPUID\n#define HWCAP_CPUID (1 << 11)\n#endif\n#ifndef HWCAP_SVE\n#define HWCAP_SVE (1 << 22)\n#endif\n\n#define get_cpu_ftr(id, var) ({                                 \\\n                __asm__ __volatile__ (\"mrs %0, \"#id : \"=r\" (var));              \\\n        })\n#endif\n\n#define CPU_UNKNOWN     \t0\n#define CPU_ARMV8       \t1\n// Arm\n#define CPU_CORTEXA53     2\n#define CPU_CORTEXA55     14\n#define CPU_CORTEXA57     3\n#define CPU_CORTEXA72     4\n#define CPU_CORTEXA73     5\n#define CPU_CORTEXA76    23\n#define CPU_NEOVERSEN1    11\n#define CPU_NEOVERSEV1    16\n#define CPU_NEOVERSEN2    17\n#define CPU_NEOVERSEV2    24\n#define CPU_CORTEXX1      18\n#define CPU_CORTEXX2\t  19\n#define CPU_CORTEXA510\t  20\n#define CPU_CORTEXA710    21\n// Qualcomm\n#define CPU_FALKOR        6\n// Cavium\n#define CPU_THUNDERX      7\n#define CPU_THUNDERX2T99  8\n#define CPU_THUNDERX3T110 12\n//Hisilicon\n#define CPU_TSV110        9\n// Ampere\n#define CPU_EMAG8180\t 10\n// Apple\n#define CPU_VORTEX       13\n// Fujitsu\n#define CPU_A64FX\t 15\n// Phytium\n#define CPU_FT2000       22\n\nstatic char *cpuname[] = {\n  \"UNKNOWN\",\n  \"ARMV8\" ,\n  \"CORTEXA53\",\n  \"CORTEXA57\",\n  \"CORTEXA72\",\n  \"CORTEXA73\",\n  \"FALKOR\",\n  \"THUNDERX\",\n  \"THUNDERX2T99\",\n  \"TSV110\",\n  \"EMAG8180\",\n  \"NEOVERSEN1\",\n  \"THUNDERX3T110\",\n  \"VORTEX\",\n  \"CORTEXA55\",\n  \"A64FX\",\n  \"NEOVERSEV1\",\n  \"NEOVERSEN2\",\n  \"CORTEXX1\",\n  \"CORTEXX2\",\n  \"CORTEXA510\",\n  \"CORTEXA710\",\n  \"FT2000\",\n  \"CORTEXA76\",\n  \"NEOVERSEV2\"\n};\n\nstatic char *cpuname_lower[] = {\n  \"unknown\",\n  \"armv8\",\n  \"cortexa53\",\n  \"cortexa57\",\n  \"cortexa72\",\n  \"cortexa73\",\n  \"falkor\",\n  \"thunderx\",\n  \"thunderx2t99\",\n  \"tsv110\",\n  \"emag8180\",\n  \"neoversen1\",\n  \"thunderx3t110\",\n  \"vortex\",\n  \"cortexa55\",\n  \"a64fx\",\n  \"neoversev1\",\n  \"neoversen2\",\n  \"cortexx1\",\n  \"cortexx2\",\n  \"cortexa510\",\n  \"cortexa710\",\n  \"ft2000\",\n  \"cortexa76\",\n  \"neoversev2\"\n};\n\nstatic int cpulowperf=0;\nstatic int cpumidperf=0;\nstatic int cpuhiperf=0;\n\nint get_feature(char *search)\n{\n\n#if defined( __linux ) || defined( __NetBSD__ )\n\tFILE *infile;\n  \tchar buffer[2048], *p,*t;\n  \tp = (char *) NULL ;\n\n  \tinfile = fopen(\"/proc/cpuinfo\", \"r\");\n\n\twhile (fgets(buffer, sizeof(buffer), infile))\n\t{\n\n\t\tif (!strncmp(\"Features\", buffer, 8))\n\t\t{\n\t\t\tp = strchr(buffer, ':') + 2;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfclose(infile);\n\n\n\tif( p == NULL ) return 0;\n\n\tt = strtok(p,\" \");\n\twhile( (t = strtok(NULL,\" \")))\n\t{\n\t\tif (!strcmp(t, search))   { return(1); }\n\t}\n\n#endif\n\treturn(0);\n}\nstatic int cpusort(const void *model1, const void *model2)\n{\n\treturn (*(int*)model2-*(int*)model1);\n}\n\nint detect(void)\n{\n\n#if defined( __linux ) || defined( __NetBSD__ )\n\tint n,i,ii;\n\tint midr_el1;\n\tint implementer;\n\tint cpucap[1024];\n\tint cpucores[1024];\n\tFILE *infile;\n\tchar cpupart[6],cpuimpl[6];\n\tchar *cpu_impl=NULL,*cpu_pt=NULL;\n\tchar buffer[2048], *p, *cpu_part = NULL, *cpu_implementer = NULL;\n\tp = (char *) NULL ;\n\tcpulowperf=cpumidperf=cpuhiperf=0;\n\tfor (i=0;i<1024;i++)cpucores[i]=0;\n\tn=0;\n\tinfile = fopen(\"/sys/devices/system/cpu/possible\", \"r\");\n\tif (!infile) {\n\t\tinfile = fopen(\"/proc/cpuinfo\", \"r\");\n\t\twhile (fgets(buffer, sizeof(buffer), infile)) {\n\t\t\tif (!strncmp(\"processor\", buffer, 9))\n \t\t\tn++;\n\t\t}\n\t} else {\n\t\tfgets(buffer, sizeof(buffer), infile);\n\t\tsscanf(buffer,\"0-%d\",&n);\n \t\tn++;\n\t}\n        fclose(infile);\n\n\tcpu_implementer=NULL;\n\tfor (i=0;i<n;i++){\n\t\tsprintf(buffer,\"/sys/devices/system/cpu/cpu%d/regs/identification/midr_el1\",i);\n\t\tinfile= fopen(buffer,\"r\");\n\t\tif (!infile) {\n\t\t\tinfile = fopen(\"/proc/cpuinfo\", \"r\");\n\t\t\tfor (ii=0;ii<n;ii++){\n\t\t\t\tcpu_part=NULL;cpu_implementer=NULL;\n\t\t\t\twhile (fgets(buffer, sizeof(buffer), infile)) {\n\t\t\t\t\tif ((cpu_part != NULL) && (cpu_implementer != NULL)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ((cpu_part == NULL) && !strncmp(\"CPU part\", buffer, 8)) {\n\t\t\t\t\tcpu_pt = strchr(buffer, ':') + 2;\n\t\t\t\t\tcpu_part = strdup(cpu_pt);\n\t\t\t\t\tcpucores[i]=strtol(cpu_part,NULL,0);\n\n\t\t\t\t\t} else if ((cpu_implementer == NULL) && !strncmp(\"CPU implementer\", buffer, 15)) {\n\t\t\t\t\tcpu_impl = strchr(buffer, ':') + 2;\n\t\t\t\t\tcpu_implementer = strdup(cpu_impl);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tif (strstr(cpu_implementer, \"0x41\")) {\n\t\t\t\t\tif (cpucores[ii] >= 0xd4b) cpuhiperf++;\n\t\t\t\telse\n\t\t\t\t\tif (cpucores[ii] >= 0xd07) cpumidperf++;\n\t\t\t\telse cpulowperf++;\n\t\t\t\t}\n\t\t\t\telse cpulowperf++;\n\t\t\t}\n\t\t\tfclose(infile);\n\t\t\tbreak;\n\t\t} else {\n\t\t        (void)fgets(buffer, sizeof(buffer), infile);\n\t\t\tmidr_el1=strtoul(buffer,NULL,16);\n\t\t\tfclose(infile);\n\t\t\timplementer = (midr_el1 >> 24) & 0xFF;\n\t\t\tcpucores[i] = (midr_el1 >> 4)  & 0xFFF;\n\t\tsprintf(buffer,\"/sys/devices/system/cpu/cpu%d/cpu_capacity\",i);\n\t\tinfile= fopen(buffer,\"r\");\n\t\tif (!infile) {\n\t\t\t\tif (implementer== 65) {\n\t\t\t\t\tif (cpucores[i] >= 0xd4b) cpuhiperf++;\n\t\t\t\telse\n\t\t\t\t\tif (cpucores[i] >= 0xd07) cpumidperf++;\n\t\t\t\telse cpulowperf++;\n\t\t\t\t}\n\t\t\t\telse cpulowperf++;\n\t\t\t} else {\n\t\t        (void)fgets(buffer, sizeof(buffer), infile);\n\t\t\t\tsscanf(buffer,\"%d\",&cpucap[i]);\n\t\t\t\t\tif (cpucap[i] >= 1000) cpuhiperf++;\n\t\t\t\telse\n\t\t\t\t\tif (cpucap[i] >= 500) cpumidperf++;\n\t\t\t\telse cpulowperf++;\n        \t\tfclose(infile);\n\t\t\t}\n\t\t}\n\t\tsprintf(cpuimpl,\"0x%2x\",implementer);\n\t\tcpu_implementer=strdup(cpuimpl);\n\t}\n\tqsort(cpucores,1024,sizeof(int),cpusort);\n\tsprintf(cpupart,\"0x%3x\",cpucores[0]);\n\tcpu_part=strdup(cpupart);\n\tif(cpu_part != NULL && cpu_implementer != NULL) {\n    // Arm\n    if (strstr(cpu_implementer, \"0x41\")) {\n      if (strstr(cpu_part, \"0xd03\"))\n        return CPU_CORTEXA53;\n      else if (strstr(cpu_part, \"0xd07\"))\n        return CPU_CORTEXA57;\n      else if (strstr(cpu_part, \"0xd08\"))\n        return CPU_CORTEXA72;\n      else if (strstr(cpu_part, \"0xd09\"))\n        return CPU_CORTEXA73;\n      else if (strstr(cpu_part, \"0xd0c\"))\n        return CPU_NEOVERSEN1;\n      else if (strstr(cpu_part, \"0xd40\"))\n        return CPU_NEOVERSEV1;\n      else if (strstr(cpu_part, \"0xd49\"))\n        return CPU_NEOVERSEN2;\n      else if (strstr(cpu_part, \"0xd05\"))\n\treturn CPU_CORTEXA55;\n      else if (strstr(cpu_part, \"0xd46\"))\n        return CPU_CORTEXA510;\n      else if (strstr(cpu_part, \"0xd47\"))\n\treturn CPU_CORTEXA710;\n      else if (strstr(cpu_part, \"0xd4d\")) //A715\n\treturn CPU_CORTEXA710;\n      else if (strstr(cpu_part, \"0xd44\"))\n        return CPU_CORTEXX1;\n      else if (strstr(cpu_part, \"0xd4c\"))\n\treturn CPU_CORTEXX2;\n      else if (strstr(cpu_part, \"0xd4e\")) //X3\n\treturn CPU_CORTEXX2;\n      else if (strstr(cpu_part, \"0xd4f\")) //NVIDIA Grace et al.\n        return CPU_NEOVERSEV2;\n      else if (strstr(cpu_part, \"0xd0b\")) \n       return CPU_CORTEXA76;\n    }\n    // Qualcomm\n    else if (strstr(cpu_implementer, \"0x51\") && strstr(cpu_part, \"0xc00\"))\n      return CPU_FALKOR;\n    // Cavium\n    else if (strstr(cpu_implementer, \"0x43\") && strstr(cpu_part, \"0x0a1\"))\n\t\t\treturn CPU_THUNDERX;\n    else if (strstr(cpu_implementer, \"0x43\") && strstr(cpu_part, \"0x0af\"))\n\t\t\treturn CPU_THUNDERX2T99;\n    else if (strstr(cpu_implementer, \"0x43\") && strstr(cpu_part, \"0x0b8\"))\n\t\t\treturn CPU_THUNDERX3T110;\n    // HiSilicon\n    else if (strstr(cpu_implementer, \"0x48\") && strstr(cpu_part, \"0xd01\"))\n                        return CPU_TSV110;\n    // Ampere\n    else if (strstr(cpu_implementer, \"0x50\") && strstr(cpu_part, \"0x000\"))\n                        return CPU_EMAG8180;\n    // Fujitsu\n    else if (strstr(cpu_implementer, \"0x46\") && strstr(cpu_part, \"0x001\"))\n                        return CPU_A64FX;\n    // Apple\n    else if (strstr(cpu_implementer, \"0x61\") && strstr(cpu_part, \"0x022\"))\n\t    \t\treturn CPU_VORTEX;\n   // Phytium\n   else if (strstr(cpu_implementer, \"0x70\") && (strstr(cpu_part, \"0x660\") || strstr(cpu_part, \"0x661\") \n   \t\t\t|| strstr(cpu_part, \"0x662\") || strstr(cpu_part, \"0x663\")))\n\t    \t\treturn CPU_FT2000;\n\t}\n\n\tp = (char *) NULL ;\n\tinfile = fopen(\"/proc/cpuinfo\", \"r\");\n\twhile (fgets(buffer, sizeof(buffer), infile))\n\t{\n\n\t\tif ((!strncmp(\"model name\", buffer, 10)) || (!strncmp(\"Processor\", buffer, 9)) ||\n\t\t    (!strncmp(\"CPU architecture\", buffer, 16)))\n\t\t{\n\t\t\tp = strchr(buffer, ':') + 2;\n\t\t\tbreak;\n      \t\t}\n  \t}\n\n  \tfclose(infile);\n\n  \tif(p != NULL)\n\t{\n\n\t\tif ((strstr(p, \"AArch64\")) || (strstr(p, \"8\")))\n\t\t{\n\t\t\treturn CPU_ARMV8;\n\n\t\t}\n\n\n\t}\n#else\n#ifdef __APPLE__\n\tsysctlbyname(\"hw.ncpu\",&value64,&length64,NULL,0);\n\tcpulowperf=value64;\n\tsysctlbyname(\"hw.nperflevels\",&value64,&length64,NULL,0);\n\tif (value64 > 1) {\n\tsysctlbyname(\"hw.perflevel0.cpusperl\",&value64,&length64,NULL,0);\n\tcpuhiperf=value64;\n\tsysctlbyname(\"hw.perflevel1.cpusperl\",&value64,&length64,NULL,0);\n\tcpulowperf=value64;\n\t}\n\tsysctlbyname(\"hw.cpufamily\",&value64,&length64,NULL,0);\n\tif (value64 ==131287967|| value64 == 458787763 ) return CPU_VORTEX; //A12/M1\n\tif (value64 == 3660830781) return CPU_VORTEX; //A15/M2\n        if (value64 == 2271604202) return CPU_VORTEX; //A16/M3\n        if (value64 == 1867590060) return CPU_VORTEX; //M4\n#endif\n\treturn CPU_ARMV8;\t\n#endif\n\n\treturn CPU_UNKNOWN;\n}\n\nchar *get_corename(void)\n{\n\treturn cpuname[detect()];\n}\n\nvoid get_architecture(void)\n{\n\tprintf(\"ARM64\");\n}\n\nvoid get_subarchitecture(void)\n{\n\tint d = detect();\n\tprintf(\"%s\", cpuname[d]);\n}\n\nvoid get_subdirname(void)\n{\n\tprintf(\"arm64\");\n}\n\nvoid get_cpucount(void)\n{\nint n=0;\n\n#if defined( __linux ) || defined( __NetBSD__ )\n\tFILE *infile;\n  \tchar buffer[2048], *p,*t;\n  \tp = (char *) NULL ;\n\n  \tinfile = fopen(\"/proc/cpuinfo\", \"r\");\n\n\twhile (fgets(buffer, sizeof(buffer), infile))\n\t{\n\n\t\tif (!strncmp(\"processor\", buffer, 9))\n\t\tn++;\n  \t}\n\n  \tfclose(infile);\n\n\tprintf(\"#define NUM_CORES %d\\n\",n);\n\tif (cpulowperf >0)\n\tprintf(\"#define NUM_CORES_LP %d\\n\",cpulowperf);\n\tif (cpumidperf >0)\n\tprintf(\"#define NUM_CORES_MP %d\\n\",cpumidperf);\n\tif (cpuhiperf >0)\n\tprintf(\"#define NUM_CORES_HP %d\\n\",cpuhiperf);\n#endif\n#ifdef __APPLE__\n\tsysctlbyname(\"hw.physicalcpu_max\",&value,&length,NULL,0);\n\tprintf(\"#define NUM_CORES %d\\n\",value);\n\tif (cpulowperf >0)\n\tprintf(\"#define NUM_CORES_LP %d\\n\",cpulowperf);\n\tif (cpumidperf >0)\n\tprintf(\"#define NUM_CORES_MP %d\\n\",cpumidperf);\n\tif (cpuhiperf >0)\n\tprintf(\"#define NUM_CORES_HP %d\\n\",cpuhiperf);\n#endif\t\n}\n\n\n\nvoid get_cpuconfig(void)\n{\n\n  // All arches should define ARMv8\n  printf(\"#define ARMV8\\n\");\n  printf(\"#define HAVE_NEON\\n\"); // This shouldn't be necessary\n  printf(\"#define HAVE_VFPV4\\n\"); // This shouldn't be necessary\n\tint d = detect();\n\tswitch (d)\n\t{\n\n\t    case CPU_CORTEXA53:\n\t    case CPU_CORTEXA55:\n\t        printf(\"#define %s\\n\", cpuname[d]);\n\t      // Fall-through\n\t    case CPU_ARMV8:\n\t      // Minimum parameters for ARMv8 (based on A53)\n\t    \tprintf(\"#define L1_DATA_SIZE 32768\\n\");\n\t    \tprintf(\"#define L1_DATA_LINESIZE 64\\n\");\n \t   \tprintf(\"#define L2_SIZE 262144\\n\");\n\t    \tprintf(\"#define L2_LINESIZE 64\\n\");\n\t    \tprintf(\"#define DTB_DEFAULT_ENTRIES 64\\n\");\n \t   \tprintf(\"#define DTB_SIZE 4096\\n\");\n \t   \tprintf(\"#define L2_ASSOCIATIVE 4\\n\");\n\t\t\tbreak;\n\n\t    case CPU_CORTEXA57:\n\t    case CPU_CORTEXA72:\n\t    case CPU_CORTEXA73:\n      // Common minimum settings for these Arm cores\n      // Can change a lot, but we need to be conservative\n      // TODO: detect info from /sys if possible\n      \t\tprintf(\"#define %s\\n\", cpuname[d]);\n\t\tprintf(\"#define L1_CODE_SIZE 49152\\n\");\n\t\tprintf(\"#define L1_CODE_LINESIZE 64\\n\");\n\t\tprintf(\"#define L1_CODE_ASSOCIATIVE 3\\n\");\n\t\tprintf(\"#define L1_DATA_SIZE 32768\\n\");\n\t\tprintf(\"#define L1_DATA_LINESIZE 64\\n\");\n\t\tprintf(\"#define L1_DATA_ASSOCIATIVE 2\\n\");\n\t\tprintf(\"#define L2_SIZE 524288\\n\");\n\t\tprintf(\"#define L2_LINESIZE 64\\n\");\n\t\tprintf(\"#define L2_ASSOCIATIVE 16\\n\");\n\t\tprintf(\"#define DTB_DEFAULT_ENTRIES 64\\n\");\n\t\tprintf(\"#define DTB_SIZE 4096\\n\");\n\t\tbreak;\n\t    case CPU_NEOVERSEN1:\n\t\tprintf(\"#define %s\\n\", cpuname[d]);\n\t\tprintf(\"#define L1_CODE_SIZE 65536\\n\");\n\t\tprintf(\"#define L1_CODE_LINESIZE 64\\n\");\n\t\tprintf(\"#define L1_CODE_ASSOCIATIVE 4\\n\");\n\t\tprintf(\"#define L1_DATA_SIZE 65536\\n\");\n\t\tprintf(\"#define L1_DATA_LINESIZE 64\\n\");\n\t\tprintf(\"#define L1_DATA_ASSOCIATIVE 4\\n\");\n\t\tprintf(\"#define L2_SIZE 1048576\\n\");\n\t\tprintf(\"#define L2_LINESIZE 64\\n\");\n\t\tprintf(\"#define L2_ASSOCIATIVE 8\\n\");\n\t\tprintf(\"#define DTB_DEFAULT_ENTRIES 48\\n\");\n\t\tprintf(\"#define DTB_SIZE 4096\\n\");\n\t\tbreak;\n\n\t    case CPU_NEOVERSEV1:\n                printf(\"#define HAVE_SVE 1\\n\");\n            case CPU_CORTEXA76:\n                printf(\"#define %s\\n\", cpuname[d]);\n                printf(\"#define L1_CODE_SIZE 65536\\n\");\n                printf(\"#define L1_CODE_LINESIZE 64\\n\");\n                printf(\"#define L1_CODE_ASSOCIATIVE 4\\n\");\n                printf(\"#define L1_DATA_SIZE 65536\\n\");\n                printf(\"#define L1_DATA_LINESIZE 64\\n\");\n                printf(\"#define L1_DATA_ASSOCIATIVE 4\\n\");\n                printf(\"#define L2_SIZE 1048576\\n\");\n                printf(\"#define L2_LINESIZE 64\\n\");\n                printf(\"#define L2_ASSOCIATIVE 8\\n\");\n                printf(\"#define DTB_DEFAULT_ENTRIES 48\\n\");\n                printf(\"#define DTB_SIZE 4096\\n\");\n                break;\n\n\t    case CPU_NEOVERSEN2:\n                printf(\"#define %s\\n\", cpuname[d]);\n                printf(\"#define L1_CODE_SIZE 65536\\n\");\n                printf(\"#define L1_CODE_LINESIZE 64\\n\");\n                printf(\"#define L1_CODE_ASSOCIATIVE 4\\n\");\n                printf(\"#define L1_DATA_SIZE 65536\\n\");\n                printf(\"#define L1_DATA_LINESIZE 64\\n\");\n                printf(\"#define L1_DATA_ASSOCIATIVE 4\\n\");\n                printf(\"#define L2_SIZE 1048576\\n\");\n                printf(\"#define L2_LINESIZE 64\\n\");\n                printf(\"#define L2_ASSOCIATIVE 8\\n\");\n                printf(\"#define DTB_DEFAULT_ENTRIES 48\\n\");\n                printf(\"#define DTB_SIZE 4096\\n\");\n                printf(\"#define HAVE_SVE 1\\n\");\n                break;\n       case CPU_NEOVERSEV2:\n                printf(\"#define ARMV9\\n\");\n                printf(\"#define HAVE_SVE 1\\n\");\n                 printf(\"#define %s\\n\", cpuname[d]);\n                 printf(\"#define L1_CODE_SIZE 65536\\n\");\n                 printf(\"#define L1_CODE_LINESIZE 64\\n\");\n                 printf(\"#define L1_CODE_ASSOCIATIVE 4\\n\");\n                 printf(\"#define L1_DATA_SIZE 65536\\n\");\n                 printf(\"#define L1_DATA_LINESIZE 64\\n\");\n                 printf(\"#define L1_DATA_ASSOCIATIVE 4\\n\");\n                 printf(\"#define L2_SIZE 1048576\\n\");\n                 printf(\"#define L2_LINESIZE 64\\n\");\n                 printf(\"#define L2_ASSOCIATIVE 8\\n\");\n                                                                // L1 Data TLB = 48 entries\n                                                                // L2 Data TLB = 2048 entries\n                 printf(\"#define DTB_DEFAULT_ENTRIES 48\\n\");\n                 printf(\"#define DTB_SIZE 4096\\n\");  // Set to 4096 for symmetry with other configs.\n\t\tbreak;\n\t    case CPU_CORTEXA510:\n\t    case CPU_CORTEXA710:\n\t    case CPU_CORTEXX1:\n\t    case CPU_CORTEXX2:\n\t\tprintf(\"#define ARMV9\\n\");\n                printf(\"#define HAVE_SVE 1\\n\");\n                printf(\"#define %s\\n\", cpuname[d]);\n                printf(\"#define L1_CODE_SIZE 65536\\n\");\n                printf(\"#define L1_CODE_LINESIZE 64\\n\");\n                printf(\"#define L1_CODE_ASSOCIATIVE 4\\n\");\n                printf(\"#define L1_DATA_SIZE 65536\\n\");\n                printf(\"#define L1_DATA_LINESIZE 64\\n\");\n                printf(\"#define L1_DATA_ASSOCIATIVE 4\\n\");\n                printf(\"#define L2_SIZE 1048576\\n\");\n                printf(\"#define L2_LINESIZE 64\\n\");\n                printf(\"#define L2_ASSOCIATIVE 8\\n\");\n\t\tprintf(\"#define DTB_DEFAULT_ENTRIES 64\\n\");\n\t\tprintf(\"#define DTB_SIZE 4096\\n\");\n\t\tbreak;\n\t    case CPU_FALKOR:\n\t        printf(\"#define FALKOR\\n\");\n\t        printf(\"#define L1_CODE_SIZE 65536\\n\");\n\t        printf(\"#define L1_CODE_LINESIZE 64\\n\");\n\t        printf(\"#define L1_DATA_SIZE 32768\\n\");\n\t        printf(\"#define L1_DATA_LINESIZE 128\\n\");\n\t        printf(\"#define L2_SIZE 524288\\n\");\n\t        printf(\"#define L2_LINESIZE 64\\n\");\n\t        printf(\"#define DTB_DEFAULT_ENTRIES 64\\n\");\n\t        printf(\"#define DTB_SIZE 4096\\n\");\n\t        printf(\"#define L2_ASSOCIATIVE 16\\n\");\n\t        break;\n\n\t    case CPU_THUNDERX:\n\t\tprintf(\"#define THUNDERX\\n\");\n\t\tprintf(\"#define L1_DATA_SIZE 32768\\n\");\n\t\tprintf(\"#define L1_DATA_LINESIZE 128\\n\");\n\t\tprintf(\"#define L2_SIZE 16777216\\n\");\n\t\tprintf(\"#define L2_LINESIZE 128\\n\");\n\t\tprintf(\"#define DTB_DEFAULT_ENTRIES 64\\n\");\n\t\tprintf(\"#define DTB_SIZE 4096\\n\");\n\t\tprintf(\"#define L2_ASSOCIATIVE 16\\n\");\n\t\tbreak;\n\n\t    case CPU_THUNDERX2T99:\n\t\tprintf(\"#define THUNDERX2T99                  \\n\");\n\t\tprintf(\"#define L1_CODE_SIZE         32768    \\n\");\n\t\tprintf(\"#define L1_CODE_LINESIZE     64       \\n\");\n\t\tprintf(\"#define L1_CODE_ASSOCIATIVE  8        \\n\");\n\t\tprintf(\"#define L1_DATA_SIZE         32768    \\n\");\n\t\tprintf(\"#define L1_DATA_LINESIZE     64       \\n\");\n\t\tprintf(\"#define L1_DATA_ASSOCIATIVE  8        \\n\");\n\t\tprintf(\"#define L2_SIZE              262144   \\n\");\n\t\tprintf(\"#define L2_LINESIZE          64       \\n\");\n\t\tprintf(\"#define L2_ASSOCIATIVE       8        \\n\");\n\t\tprintf(\"#define L3_SIZE              33554432 \\n\");\n\t\tprintf(\"#define L3_LINESIZE          64       \\n\");\n\t\tprintf(\"#define L3_ASSOCIATIVE       32       \\n\");\n\t\tprintf(\"#define DTB_DEFAULT_ENTRIES  64       \\n\");\n\t\tprintf(\"#define DTB_SIZE             4096     \\n\");\n\t\tbreak;\n\t\t\t\n\t    case CPU_TSV110:\n\t\tprintf(\"#define TSV110                        \\n\");\n\t\tprintf(\"#define L1_CODE_SIZE         65536    \\n\");\n\t\tprintf(\"#define L1_CODE_LINESIZE     64       \\n\");\n\t\tprintf(\"#define L1_CODE_ASSOCIATIVE  4        \\n\");\n\t\tprintf(\"#define L1_DATA_SIZE         65536    \\n\");\n\t\tprintf(\"#define L1_DATA_LINESIZE     64       \\n\");\n\t\tprintf(\"#define L1_DATA_ASSOCIATIVE  4        \\n\");\n\t\tprintf(\"#define L2_SIZE              524228   \\n\");\n\t\tprintf(\"#define L2_LINESIZE          64       \\n\");\n\t\tprintf(\"#define L2_ASSOCIATIVE       8        \\n\");\n\t\tprintf(\"#define DTB_DEFAULT_ENTRIES  64       \\n\");\n\t\tprintf(\"#define DTB_SIZE             4096     \\n\");\n\t\tbreak;\t\n\n\t    case CPU_EMAG8180:\n     \t\t // Minimum parameters for ARMv8 (based on A53)\n\t\tprintf(\"#define EMAG8180\\n\");\n    \t\tprintf(\"#define L1_CODE_SIZE 32768\\n\");\n    \t\tprintf(\"#define L1_DATA_SIZE 32768\\n\");\n    \t\tprintf(\"#define L1_DATA_LINESIZE 64\\n\");\n    \t\tprintf(\"#define L2_SIZE 262144\\n\");\n    \t\tprintf(\"#define L2_LINESIZE 64\\n\");\n\t    \tprintf(\"#define DTB_DEFAULT_ENTRIES 64\\n\");\n\t    \tprintf(\"#define DTB_SIZE 4096\\n\");\n\t\tbreak;\n\n\t    case CPU_THUNDERX3T110:\n\t\tprintf(\"#define THUNDERX3T110                 \\n\");\n\t\tprintf(\"#define L1_CODE_SIZE         65536    \\n\");\n\t\tprintf(\"#define L1_CODE_LINESIZE     64       \\n\");\n\t\tprintf(\"#define L1_CODE_ASSOCIATIVE  8        \\n\");\n\t\tprintf(\"#define L1_DATA_SIZE         32768    \\n\");\n\t\tprintf(\"#define L1_DATA_LINESIZE     64       \\n\");\n\t\tprintf(\"#define L1_DATA_ASSOCIATIVE  8        \\n\");\n\t\tprintf(\"#define L2_SIZE              524288   \\n\");\n\t\tprintf(\"#define L2_LINESIZE          64       \\n\");\n\t\tprintf(\"#define L2_ASSOCIATIVE       8        \\n\");\n\t\tprintf(\"#define L3_SIZE              94371840 \\n\");\n\t\tprintf(\"#define L3_LINESIZE          64       \\n\");\n\t\tprintf(\"#define L3_ASSOCIATIVE       32       \\n\");\n\t\tprintf(\"#define DTB_DEFAULT_ENTRIES  64       \\n\");\n\t\tprintf(\"#define DTB_SIZE             4096     \\n\");\n\t\tbreak;\n\t    case CPU_VORTEX:\n\t\tprintf(\"#define VORTEX\t\t\t      \\n\");\n#ifdef __APPLE__\n\t\tsysctlbyname(\"hw.l1icachesize\",&value64,&length64,NULL,0);\n\t\tprintf(\"#define L1_CODE_SIZE\t     %lld       \\n\",value64);\n\t\tsysctlbyname(\"hw.cachelinesize\",&value64,&length64,NULL,0);\n\t\tprintf(\"#define L1_CODE_LINESIZE     %lld       \\n\",value64);\n\t\tsysctlbyname(\"hw.l1dcachesize\",&value64,&length64,NULL,0);\n\t\tprintf(\"#define L1_DATA_SIZE\t     %lld       \\n\",value64);\n\t\tsysctlbyname(\"hw.l2cachesize\",&value64,&length64,NULL,0);\n\t\tprintf(\"#define L2_SIZE\t     %lld       \\n\",value64);\n#endif\t\n\t\tprintf(\"#define DTB_DEFAULT_ENTRIES  64       \\n\");\n\t\tprintf(\"#define DTB_SIZE             4096     \\n\");\n\t\tbreak;\n\t    case CPU_A64FX:\n\t\tprintf(\"#define A64FX\\n\");\n                printf(\"#define HAVE_SVE 1\\n\");\n    \t\tprintf(\"#define L1_CODE_SIZE 65535\\n\");\n    \t\tprintf(\"#define L1_DATA_SIZE 65535\\n\");\n    \t\tprintf(\"#define L1_DATA_LINESIZE 256\\n\");\n    \t\tprintf(\"#define L2_SIZE 8388608\\n\");\n    \t\tprintf(\"#define L2_LINESIZE 256\\n\");\n\t    \tprintf(\"#define DTB_DEFAULT_ENTRIES 64\\n\");\n\t    \tprintf(\"#define DTB_SIZE 4096\\n\");\n\t\tbreak;\n\t    case CPU_FT2000:\n\t\tprintf(\"#define FT2000\\n\");\n    \t\tprintf(\"#define L1_CODE_SIZE 32768\\n\");\n    \t\tprintf(\"#define L1_DATA_SIZE 32768\\n\");\n    \t\tprintf(\"#define L1_DATA_LINESIZE 64\\n\");\n    \t\tprintf(\"#define L2_SIZE 33554432\\n\");\n    \t\tprintf(\"#define L2_LINESIZE 64\\n\");\n\t    \tprintf(\"#define DTB_DEFAULT_ENTRIES 64\\n\");\n\t    \tprintf(\"#define DTB_SIZE 4096\\n\");\n\t\tbreak;\n\t}\n\tget_cpucount();\n}\n\n\nvoid get_libname(void)\n{\n\tint d = detect();\n\tprintf(\"%s\", cpuname_lower[d]);\n}\n\nvoid get_features(void)\n{\n\n#if defined( __linux ) || defined( __NetBSD__ )\n\tFILE *infile;\n  \tchar buffer[2048], *p,*t;\n  \tp = (char *) NULL ;\n\n  \tinfile = fopen(\"/proc/cpuinfo\", \"r\");\n\n\twhile (fgets(buffer, sizeof(buffer), infile))\n\t{\n\n\t\tif (!strncmp(\"Features\", buffer, 8))\n\t\t{\n\t\t\tp = strchr(buffer, ':') + 2;\n\t\t\tbreak;\n      \t\t}\n  \t}\n\n  \tfclose(infile);\n\n\n\tif( p == NULL ) return;\n\n\tt = strtok(p,\" \");\n\twhile( (t = strtok(NULL,\" \")))\n\t{\n\t}\n\n#endif\n\treturn;\n}\n"
        },
        {
          "name": "cpuid_ia64.c",
          "type": "blob",
          "size": 4.6923828125,
          "content": "/*********************************************************************/\n/* Copyright 2009, 2010 The University of Texas at Austin.           */\n/* All rights reserved.                                              */\n/*                                                                   */\n/* Redistribution and use in source and binary forms, with or        */\n/* without modification, are permitted provided that the following   */\n/* conditions are met:                                               */\n/*                                                                   */\n/*   1. Redistributions of source code must retain the above         */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer.                                                  */\n/*                                                                   */\n/*   2. Redistributions in binary form must reproduce the above      */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer in the documentation and/or other materials       */\n/*      provided with the distribution.                              */\n/*                                                                   */\n/*    THIS  SOFTWARE IS PROVIDED  BY THE  UNIVERSITY OF  TEXAS AT    */\n/*    AUSTIN  ``AS IS''  AND ANY  EXPRESS OR  IMPLIED WARRANTIES,    */\n/*    INCLUDING, BUT  NOT LIMITED  TO, THE IMPLIED  WARRANTIES OF    */\n/*    MERCHANTABILITY  AND FITNESS FOR  A PARTICULAR  PURPOSE ARE    */\n/*    DISCLAIMED.  IN  NO EVENT SHALL THE UNIVERSITY  OF TEXAS AT    */\n/*    AUSTIN OR CONTRIBUTORS BE  LIABLE FOR ANY DIRECT, INDIRECT,    */\n/*    INCIDENTAL,  SPECIAL, EXEMPLARY,  OR  CONSEQUENTIAL DAMAGES    */\n/*    (INCLUDING, BUT  NOT LIMITED TO,  PROCUREMENT OF SUBSTITUTE    */\n/*    GOODS  OR  SERVICES; LOSS  OF  USE,  DATA,  OR PROFITS;  OR    */\n/*    BUSINESS INTERRUPTION) HOWEVER CAUSED  AND ON ANY THEORY OF    */\n/*    LIABILITY, WHETHER  IN CONTRACT, STRICT  LIABILITY, OR TORT    */\n/*    (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY WAY OUT    */\n/*    OF  THE  USE OF  THIS  SOFTWARE,  EVEN  IF ADVISED  OF  THE    */\n/*    POSSIBILITY OF SUCH DAMAGE.                                    */\n/*                                                                   */\n/* The views and conclusions contained in the software and           */\n/* documentation are those of the authors and should not be          */\n/* interpreted as representing official policies, either expressed   */\n/* or implied, of The University of Texas at Austin.                 */\n/*********************************************************************/\n\n#include <stdio.h>\n#include <string.h>\n#include <sys/sysinfo.h>\n#include \"cpuid.h\"\n\n#ifdef __ECC\n#include <ia64intrin.h>\n#endif\n\nstatic inline unsigned long cpuid(unsigned long regnum){\n  unsigned long value;\n\n#ifdef __ECC\n  value = __getIndReg(_IA64_REG_INDR_CPUID, regnum);\n#else\n  asm (\"mov %0=cpuid[%r1]\" : \"=r\"(value) : \"rO\"(regnum));\n#endif\n\n  return value;\n}\n\nint have_cpuid(void){ return 1;}\n\nint get_vendor(void){\n  unsigned long cpuid0, cpuid1;\n  char vendor[18];\n\n  cpuid0 = cpuid(0);\n  cpuid1 = cpuid(1);\n\n  *(unsigned long *)(&vendor[0]) = cpuid0;\n  *(unsigned long *)(&vendor[8]) = cpuid1;\n  vendor[17] = (char)0;\n\n  if (!strcmp(vendor, \"GenuineIntel\")) return VENDOR_INTEL;\n\n  return VENDOR_UNKNOWN;\n}\n\nint get_cputype(int gettype){\n  unsigned long cpuid3;\n\n  cpuid3 = cpuid(3);\n\n  switch (gettype) {\n  case GET_ARCHREV :\n    return BITMASK(cpuid3, 32, 0xff);\n  case GET_FAMILY :\n    return BITMASK(cpuid3, 24, 0xff);\n  case GET_MODEL :\n    return BITMASK(cpuid3, 16, 0xff);\n  case GET_REVISION :\n    return BITMASK(cpuid3,  8, 0xff);\n  case GET_NUMBER :\n    return BITMASK(cpuid3,  0, 0xff);\n  }\n\n  return 0;\n}\n\nchar *get_cpunamechar(void){\n  if (get_cputype(GET_FAMILY) == 0x07) return \"ITANIUM\";\n  if (get_cputype(GET_FAMILY) == 0x1f) return \"ITANIUM2\";\n  if (get_cputype(GET_FAMILY) == 0x20) return \"ITANIUM2\";\n\n  return \"UNKNOWN\";\n}\n\nchar *get_libname(void){\n  if (get_cputype(GET_FAMILY) == 0x07) { printf(\"itanium\"); return NULL;}\n  if (get_cputype(GET_FAMILY) == 0x1f) { printf(\"itanium2\"); return NULL;}\n  if (get_cputype(GET_FAMILY) == 0x20) { printf(\"itanium2\"); return NULL;}\n\n  printf(\"UNKNOWN\");\n\n  return NULL;\n}\n\nvoid get_architecture(void){\n  printf(\"IA64\");\n}\n\nvoid get_subarchitecture(void){\n    printf(\"%s\", get_cpunamechar());\n}\n\nvoid get_subdirname(void){\n    printf(\"ia64\");\n}\n\nvoid get_cpuconfig(void){\n  printf(\"#define %s\\n\", get_cpunamechar());\n  printf(\"#define L1_DATA_SIZE 262144\\n\");\n  printf(\"#define L1_DATA_LINESIZE 128\\n\");\n  printf(\"#define L2_SIZE 1572864\\n\");\n  printf(\"#define L2_LINESIZE 128\\n\");\n  printf(\"#define DTB_SIZE 16384\\n\");\n  printf(\"#define DTB_DEFAULT_ENTRIES 128\\n\");\n}\n\n"
        },
        {
          "name": "cpuid_loongarch64.c",
          "type": "blob",
          "size": 11.6845703125,
          "content": "/*****************************************************************************\nCopyright (c) 2011-2024, The OpenBLAS Project\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   1. Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n\n   2. Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in\n      the documentation and/or other materials provided with the\n      distribution.\n   3. Neither the name of the OpenBLAS project nor the names of\n      its contributors may be used to endorse or promote products\n      derived from this software without specific prior written\n      permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\nUSE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n**********************************************************************************/\n\n#include <stdint.h>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <sys/auxv.h>\n\n#define CPU_LA64_GENERIC     0\n#define CPU_LA264            1\n#define CPU_LA364            2\n#define CPU_LA464            3\n#define CPU_LA664            4\n\n#define CORE_LA64_GENERIC    0\n#define CORE_LA264           1\n#define CORE_LA464           2\n\n#define LA_HWCAP_LSX    (1U << 4)\n#define LA_HWCAP_LASX   (1U << 5)\n\n#define LOONGARCH_CFG0      0x00\n#define LOONGARCH_CFG2      0x02\n#define LOONGARCH_CFG10     0x10\n#define LOONGARCH_CFG11     0x11\n#define LOONGARCH_CFG12     0x12\n#define LOONGARCH_CFG13     0x13\n#define LOONGARCH_CFG14     0x14\n#define LASX_MASK           1<<7\n#define LSX_MASK            1<<6\n#define PRID_SERIES_MASK    0xf000\n#define PRID_SERIES_LA264   0xa000\n#define PRID_SERIES_LA364   0xb000\n#define PRID_SERIES_LA464   0xc000\n#define PRID_SERIES_LA664   0xd000\n\n#define CACHE_INFO_L1_IU    0\n#define CACHE_INFO_L1_D     1\n#define CACHE_INFO_L2_IU    2\n#define CACHE_INFO_L2_D     3\n#define CACHE_INFO_L3_IU    4\n#define CACHE_INFO_L3_D     5\n#define L1_IU_PRESENT_MASK  0x0001\n#define L1_IU_UNITY_MASK    0x0002\n#define L1_D_PRESENT_MASK   0x0004\n#define L2_IU_PRESENT_MASK  0x0008\n#define L2_IU_UNITY_MASK    0x0010\n#define L2_D_PRESENT_MASK   0x0080\n#define L3_IU_PRESENT_MASK  0x0400\n#define L3_IU_UNITY_MASK    0x0800\n#define L3_D_PRESENT_MASK   0x4000\n#define CACHE_WAY_MINUS_1_MASK      0x0000ffff\n#define CACHE_INDEX_LOG2_MASK       0x00ff0000\n#define CACHE_LINESIZE_LOG2_MASK    0x7f000000\n\ntypedef struct {\n  int size;\n  int associative;\n  int linesize;\n  int unify;\n  int present;\n} cache_info_t;\n\n/* Using microarchitecture representation */\nstatic char *cpuname[] = {\n  \"LA64_GENERIC\",\n  \"LA264\", /* Loongson 64bit, 2-issue, Like 2K1000LA */\n  \"LA364\", /* Loongson 64bit, 3-issue, Like 2K2000 */\n  \"LA464\", /* Loongson 64bit, 4-issue, Like 3A5000, 3C5000L, 3C5000 and 3D5000 */\n  \"LA664\"  /* Loongson 64bit, 6-issue, Like 3A6000, 3C6000 and 3D6000 */\n};\n\nstatic char *cpuname_lower[] = {\n  \"la64_generic\",\n  \"la264\",\n  \"la364\",\n  \"la464\",\n  \"la664\"\n};\n\nstatic char *corename[] = {\n  \"LA64_GENERIC\", /* Implies using scalar instructions for optimization */\n  \"LA264\", /* Implies using LSX  instructions for optimization */\n  \"LA464\", /* Implies using LASX instructions for optimization */\n};\n\nstatic char *corename_lower[] = {\n  \"la64_generic\",\n  \"la264\",\n  \"la464\",\n};\n\n/*\n * Obtain cache and processor identification\n * through the cpucfg command.\n */\nstatic void get_cacheinfo(int type, cache_info_t *cacheinfo) {\n  cache_info_t cache_info;\n  memset(&cache_info, 0, sizeof(cache_info));\n  uint32_t reg_10 = 0;\n  __asm__ volatile (\n    \"cpucfg %0, %1 \\n\\t\"\n    : \"+&r\"(reg_10)\n    : \"r\"(LOONGARCH_CFG10)\n  );\n\n  switch (type) {\n    case CACHE_INFO_L1_IU:\n      if (reg_10 & L1_IU_PRESENT_MASK) {\n        uint32_t reg_11 = 0;\n        cache_info.present = reg_10 & L1_IU_PRESENT_MASK;\n        cache_info.unify   = reg_10 & L1_IU_UNITY_MASK;\n        __asm__ volatile (\n          \"cpucfg %0, %1 \\n\\t\"\n          : \"+&r\"(reg_11)\n          : \"r\"(LOONGARCH_CFG11)\n        );\n        cache_info.associative  = (reg_11 & CACHE_WAY_MINUS_1_MASK) + 1;\n        cache_info.linesize = 1 << ((reg_11 & CACHE_LINESIZE_LOG2_MASK) >> 24);\n        cache_info.size = cache_info.associative * cache_info.linesize *\n                          (1 << ((reg_11 & CACHE_INDEX_LOG2_MASK) >> 16));\n      }\n    break;\n\n    case CACHE_INFO_L1_D:\n      if (reg_10 & L1_D_PRESENT_MASK) {\n        uint32_t reg_12 = 0;\n        cache_info.present = reg_10 & L1_D_PRESENT_MASK;\n        __asm__ volatile (\n          \"cpucfg %0, %1 \\n\\t\"\n          : \"+&r\"(reg_12)\n          : \"r\"(LOONGARCH_CFG12)\n        );\n        cache_info.associative  = (reg_12 & CACHE_WAY_MINUS_1_MASK) + 1;\n        cache_info.linesize = 1 << ((reg_12 & CACHE_LINESIZE_LOG2_MASK) >> 24);\n        cache_info.size = cache_info.associative * cache_info.linesize *\n                          (1 << ((reg_12 & CACHE_INDEX_LOG2_MASK) >> 16));\n      }\n    break;\n\n    case CACHE_INFO_L2_IU:\n      if (reg_10 & L2_IU_PRESENT_MASK) {\n        uint32_t reg_13 = 0;\n        cache_info.present = reg_10 & L2_IU_PRESENT_MASK;\n        cache_info.unify   = reg_10 & L2_IU_UNITY_MASK;\n        __asm__ volatile (\n          \"cpucfg %0, %1 \\n\\t\"\n          : \"+&r\"(reg_13)\n          : \"r\"(LOONGARCH_CFG13)\n        );\n        cache_info.associative  = (reg_13 & CACHE_WAY_MINUS_1_MASK) + 1;\n        cache_info.linesize = 1 << ((reg_13 & CACHE_LINESIZE_LOG2_MASK) >> 24);\n        cache_info.size = cache_info.associative * cache_info.linesize *\n                          (1 << ((reg_13 & CACHE_INDEX_LOG2_MASK) >> 16));\n      }\n    break;\n\n    case CACHE_INFO_L2_D:\n      if (reg_10 & L2_D_PRESENT_MASK) {\n        cache_info.present = reg_10 & L2_D_PRESENT_MASK;\n        // No date fetch\n      }\n    break;\n\n    case CACHE_INFO_L3_IU:\n      if (reg_10 & L3_IU_PRESENT_MASK) {\n        uint32_t reg_14 = 0;\n        cache_info.present = reg_10 & L3_IU_PRESENT_MASK;\n        cache_info.unify   = reg_10 & L3_IU_UNITY_MASK;\n        __asm__ volatile (\n          \"cpucfg %0, %1 \\n\\t\"\n          : \"+&r\"(reg_14)\n          : \"r\"(LOONGARCH_CFG14)\n        );\n        cache_info.associative  = (reg_14 & CACHE_WAY_MINUS_1_MASK) + 1;\n        cache_info.linesize = 1 << ((reg_14 & CACHE_LINESIZE_LOG2_MASK) >> 24);\n        cache_info.size = cache_info.associative * cache_info.linesize *\n                          (1 << ((reg_14 & CACHE_INDEX_LOG2_MASK) >> 16));\n      }\n    break;\n\n    case CACHE_INFO_L3_D:\n      if (reg_10 & L3_D_PRESENT_MASK) {\n        cache_info.present = reg_10 & L3_D_PRESENT_MASK;\n        // No data fetch\n      }\n    break;\n\n    default:\n    break;\n  }\n  *cacheinfo = cache_info;\n}\n\nstatic uint32_t get_prid() {\n  uint32_t reg = 0;\n  __asm__ volatile (\n    \"cpucfg %0, %1 \\n\\t\"\n    : \"+&r\"(reg)\n    : \"r\"(LOONGARCH_CFG0)\n  );\n  return reg;\n}\n\nstatic void get_cpucount(uint32_t *count) {\n  uint32_t num = 0;\n  FILE *f = fopen(\"/proc/cpuinfo\", \"r\");\n  if (!f) return;\n  char buf[200];\n  while (fgets(buf, sizeof(buf), f))\n  {\n    if (!strncmp(\"processor\", buf, 9))\n      num ++;\n  }\n  fclose(f);\n  *count = num;\n}\n\n/* Detect whether the OS supports the LASX instruction set */\nstatic int os_support_lasx() {\n  int hwcap  = (int)getauxval(AT_HWCAP);\n\n  if (hwcap & LA_HWCAP_LASX)\n    return 1;\n  else\n    return 0;\n}\n\n/* Detect whether the OS supports the LSX instruction set */\nstatic int os_support_lsx() {\n  int hwcap  = (int)getauxval(AT_HWCAP);\n\n  if (hwcap & LA_HWCAP_LSX)\n    return 1;\n  else\n    return 0;\n}\n\nint get_coretype(void) {\n  uint32_t prid = get_prid();\n  switch (prid & PRID_SERIES_MASK) {\n    case (PRID_SERIES_LA464):\n    case (PRID_SERIES_LA664):\n      if (os_support_lasx())\n        return CORE_LA464;\n      else if (os_support_lsx())\n        return CORE_LA264;\n      else\n        return CORE_LA64_GENERIC;\n    break;\n\n    case (PRID_SERIES_LA264):\n    case (PRID_SERIES_LA364):\n      if (os_support_lsx())\n        return CORE_LA264;\n      else\n        return CORE_LA64_GENERIC;\n    break;\n\n    default:\n      return CORE_LA64_GENERIC;\n    break;\n  }\n}\n\nint get_cputype(void) {\n  uint32_t prid = get_prid();\n  switch (prid & PRID_SERIES_MASK) {\n    case (PRID_SERIES_LA264):\n      return CPU_LA264;\n    break;\n\n    case (PRID_SERIES_LA364):\n      return CPU_LA364;\n    break;\n\n    case (PRID_SERIES_LA464):\n      return CPU_LA464;\n    break;\n\n    case (PRID_SERIES_LA664):\n      return CPU_LA664;\n    break;\n\n    default:\n      return CPU_LA64_GENERIC;\n    break;\n  }\n}\n\nchar *get_corename(void) {\n  return corename[get_coretype()];\n}\n\nvoid get_libname(void){\n  printf(\"%s\", corename_lower[get_coretype()]);\n}\n\nvoid get_architecture(void) {\n  printf(\"LOONGARCH64\");\n}\n\nvoid get_subarchitecture(void) {\n  printf(\"%s\", cpuname[get_cputype()]);\n}\n\nvoid get_subdirname(void) {\n  printf(\"loongarch64\");\n}\n\nvoid get_cpuconfig(void) {\n  cache_info_t info;\n  uint32_t num_cores = 0;\n\n  printf(\"#define %s\\n\", corename[get_coretype()]); // Core name\n\n  printf(\"#define CPU_NAME %s\\n\", cpuname[get_cputype()]); // Cpu microarchitecture name\n\n  get_cacheinfo(CACHE_INFO_L1_IU, &info);\n  if (info.present) {\n    if (info.unify) { // Unified cache, without distinguishing between instructions and data\n      printf(\"#define L1_SIZE %d\\n\", info.size);\n      printf(\"#define L1_ASSOCIATIVE %d\\n\", info.associative);\n      printf(\"#define L1_LINESIZE %d\\n\", info.linesize);\n    } else {\n      printf(\"#define L1_CODE_SIZE %d\\n\", info.size);\n      printf(\"#define L1_CODE_ASSOCIATIVE %d\\n\", info.associative);\n      printf(\"#define L1_CODE_LINESIZE %d\\n\", info.linesize);\n    }\n  }\n\n  if (!info.unify) {\n    get_cacheinfo(CACHE_INFO_L1_D, &info);\n    if (info.present) {\n      printf(\"#define L1_DATA_SIZE %d\\n\", info.size);\n      printf(\"#define L1_DATA_ASSOCIATIVE %d\\n\", info.associative);\n      printf(\"#define L1_DATA_LINESIZE %d\\n\", info.linesize);\n    }\n  }\n\n  get_cacheinfo(CACHE_INFO_L2_IU, &info);\n  if (info.present > 0) {\n    if (info.unify) {\n      printf(\"#define L2_SIZE %d\\n\", info.size);\n      printf(\"#define L2_ASSOCIATIVE %d\\n\", info.associative);\n      printf(\"#define L2_LINESIZE %d\\n\", info.linesize);\n    } else {\n      printf(\"#define L2_CODE_SIZE %d\\n\", info.size);\n      printf(\"#define L2_CODE_ASSOCIATIVE %d\\n\", info.associative);\n      printf(\"#define L2_CODE_LINESIZE %d\\n\", info.linesize);\n    }\n  }\n\n  get_cacheinfo(CACHE_INFO_L3_IU, &info);\n  if (info.present > 0) {\n    if (info.unify) {\n      printf(\"#define L3_SIZE %d\\n\", info.size);\n      printf(\"#define L3_ASSOCIATIVE %d\\n\", info.associative);\n      printf(\"#define L3_LINESIZE %d\\n\", info.linesize);\n    } else {\n      printf(\"#define L3_CODE_SIZE %d\\n\", info.size);\n      printf(\"#define L3_CODE_ASSOCIATIVE %d\\n\", info.associative);\n      printf(\"#define L3_CODE_LINESIZE %d\\n\", info.linesize);\n    }\n  }\n\n  if(os_support_lsx)  printf(\"#define HAVE_LSX\\n\");\n  if(os_support_lasx) printf(\"#define HAVE_LASX\\n\");\n\n  get_cpucount(&num_cores);\n  if (num_cores)\n    printf(\"#define NUM_CORES %d\\n\", num_cores);\n\n  //TODO: It’s unclear what this entry represents, but it is indeed necessary.\n  //It has been set based on reference to other platforms.\n  printf(\"#define DTB_DEFAULT_ENTRIES 64\\n\");\n}\n"
        },
        {
          "name": "cpuid_mips.c",
          "type": "blob",
          "size": 7.376953125,
          "content": "/*****************************************************************************\nCopyright (c) 2011-2014, The OpenBLAS Project\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   1. Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n\n   2. Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in\n      the documentation and/or other materials provided with the\n      distribution.\n   3. Neither the name of the OpenBLAS project nor the names of \n      its contributors may be used to endorse or promote products \n      derived from this software without specific prior written \n      permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\nUSE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n**********************************************************************************/\n\n\n/*********************************************************************/\n/* Copyright 2009, 2010 The University of Texas at Austin.           */\n/* All rights reserved.                                              */\n/*                                                                   */\n/* Redistribution and use in source and binary forms, with or        */\n/* without modification, are permitted provided that the following   */\n/* conditions are met:                                               */\n/*                                                                   */\n/*   1. Redistributions of source code must retain the above         */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer.                                                  */\n/*                                                                   */\n/*   2. Redistributions in binary form must reproduce the above      */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer in the documentation and/or other materials       */\n/*      provided with the distribution.                              */\n/*                                                                   */\n/*    THIS  SOFTWARE IS PROVIDED  BY THE  UNIVERSITY OF  TEXAS AT    */\n/*    AUSTIN  ``AS IS''  AND ANY  EXPRESS OR  IMPLIED WARRANTIES,    */\n/*    INCLUDING, BUT  NOT LIMITED  TO, THE IMPLIED  WARRANTIES OF    */\n/*    MERCHANTABILITY  AND FITNESS FOR  A PARTICULAR  PURPOSE ARE    */\n/*    DISCLAIMED.  IN  NO EVENT SHALL THE UNIVERSITY  OF TEXAS AT    */\n/*    AUSTIN OR CONTRIBUTORS BE  LIABLE FOR ANY DIRECT, INDIRECT,    */\n/*    INCIDENTAL,  SPECIAL, EXEMPLARY,  OR  CONSEQUENTIAL DAMAGES    */\n/*    (INCLUDING, BUT  NOT LIMITED TO,  PROCUREMENT OF SUBSTITUTE    */\n/*    GOODS  OR  SERVICES; LOSS  OF  USE,  DATA,  OR PROFITS;  OR    */\n/*    BUSINESS INTERRUPTION) HOWEVER CAUSED  AND ON ANY THEORY OF    */\n/*    LIABILITY, WHETHER  IN CONTRACT, STRICT  LIABILITY, OR TORT    */\n/*    (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY WAY OUT    */\n/*    OF  THE  USE OF  THIS  SOFTWARE,  EVEN  IF ADVISED  OF  THE    */\n/*    POSSIBILITY OF SUCH DAMAGE.                                    */\n/*                                                                   */\n/* The views and conclusions contained in the software and           */\n/* documentation are those of the authors and should not be          */\n/* interpreted as representing official policies, either expressed   */\n/* or implied, of The University of Texas at Austin.                 */\n/*********************************************************************/\n\n#define CPU_UNKNOWN     0\n#define CPU_P5600       1\n#define CPU_1004K\t2\n#define CPU_24K\t\t3\n\nstatic char *cpuname[] = {\n  \"UNKNOWN\",\n  \"P5600\",\n  \"MIPS1004K\",\n  \"MIPS24K\"\n};\n\nint detect(void){\n\n#ifdef __linux\n  FILE *infile;\n  char buffer[512], *p;\n\n  p = (char *)NULL;\n  infile = fopen(\"/proc/cpuinfo\", \"r\");\n  while (fgets(buffer, sizeof(buffer), infile)){\n    if (!strncmp(\"cpu\", buffer, 3)){\n\tp = strchr(buffer, ':') + 2;\n#if 0\n\tfprintf(stderr, \"%s \\n\", p);\n#endif\n\tbreak;\n      }\n  }\n\n  fclose(infile);\n\n  if(p != NULL){\n  if (strstr(p, \"5600\")) {\n    return CPU_P5600;\n  } else if (strstr(p, \"1004K\")) {\n    return CPU_1004K;\n  } else if (strstr(p, \" 24K\")) {\n    return CPU_24K;\n  } else  \n    return CPU_UNKNOWN;\n  }\n#endif\n    return CPU_UNKNOWN;\n}\n\nchar *get_corename(void){\n  return cpuname[detect()];\n}\n\nvoid get_architecture(void){\n  printf(\"MIPS\");\n}\n\nvoid get_subarchitecture(void){\n  if(detect()==CPU_P5600|| detect()==CPU_1004K|| detect()==CPU_24K){\n    printf(\"P5600\");\n  }else{\n    printf(\"UNKNOWN\");\n  }\n}\n\nvoid get_subdirname(void){\n  printf(\"mips\");\n}\n\nvoid get_cpuconfig(void){\n  if(detect()==CPU_P5600){\n    printf(\"#define P5600\\n\");\n    printf(\"#define L1_DATA_SIZE 65536\\n\");\n    printf(\"#define L1_DATA_LINESIZE 32\\n\");\n    printf(\"#define L2_SIZE 1048576\\n\");\n    printf(\"#define L2_LINESIZE 32\\n\");\n    printf(\"#define DTB_DEFAULT_ENTRIES 64\\n\");\n    printf(\"#define DTB_SIZE 4096\\n\");\n    printf(\"#define L2_ASSOCIATIVE 8\\n\");\n  } else if (detect()==CPU_1004K) {\n    printf(\"#define MIPS1004K\\n\");\n    printf(\"#define L1_DATA_SIZE 32768\\n\");\n    printf(\"#define L1_DATA_LINESIZE 32\\n\");\n    printf(\"#define L2_SIZE 262144\\n\");\n    printf(\"#define DTB_DEFAULT_ENTRIES 8\\n\");\n    printf(\"#define DTB_SIZE 4096\\n\");\n    printf(\"#define L2_ASSOCIATIVE 4\\n\");\n  } else if (detect()==CPU_24K) {\n    printf(\"#define MIPS24K\\n\");\n    printf(\"#define L1_DATA_SIZE 32768\\n\");\n    printf(\"#define L1_DATA_LINESIZE 32\\n\");\n    printf(\"#define L2_SIZE 32768\\n\");\n    printf(\"#define DTB_DEFAULT_ENTRIES 8\\n\");\n    printf(\"#define DTB_SIZE 4096\\n\");\n    printf(\"#define L2_ASSOCIATIVE 4\\n\");\n  }else{\n    printf(\"#define UNKNOWN\\n\");\n  }\n#ifndef NO_MSA  \n  if (get_feature(\"msa\")) printf(\"#define HAVE_MSA\\n\");\n#endif\n}\n\nvoid get_libname(void){\n  if(detect()==CPU_P5600) {\n    printf(\"p5600\\n\");\n  } else if (detect()==CPU_1004K) {\n    printf(\"mips1004K\\n\");\n  } else if (detect()==CPU_24K) {\n    printf(\"mips24K\\n\");\n  }else{\n    printf(\"mips\\n\");\n  }\n}\n\nint get_feature(char *search)\n{\n\n#ifdef __linux\n        FILE *infile;\n        char buffer[2048], *p,*t;\n        p = (char *) NULL ;\n\n        infile = fopen(\"/proc/cpuinfo\", \"r\");\n\n        while (fgets(buffer, sizeof(buffer), infile))\n        {\n\n                if (!strncmp(\"Features\", buffer, 8) || !strncmp(\"ASEs implemented\", buffer, 16))\n                {\n                        p = strchr(buffer, ':') + 2;\n                        break;\n                }\n        }\n\n        fclose(infile);\n\n        if( p == NULL ) return 0;\n\n        t = strtok(p,\" \");\n        while( t = strtok(NULL,\" \"))\n        {\n                if (strstr(t, search))   { return(1); }\n        }\n\n#endif\n        return(0);\n}\n\n"
        },
        {
          "name": "cpuid_mips64.c",
          "type": "blob",
          "size": 9.1748046875,
          "content": "/*****************************************************************************\nCopyright (c) 2011-2014, The OpenBLAS Project\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   1. Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n\n   2. Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in\n      the documentation and/or other materials provided with the\n      distribution.\n   3. Neither the name of the OpenBLAS project nor the names of \n      its contributors may be used to endorse or promote products \n      derived from this software without specific prior written \n      permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\nUSE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n**********************************************************************************/\n\n\n/*********************************************************************/\n/* Copyright 2009, 2010 The University of Texas at Austin.           */\n/* All rights reserved.                                              */\n/*                                                                   */\n/* Redistribution and use in source and binary forms, with or        */\n/* without modification, are permitted provided that the following   */\n/* conditions are met:                                               */\n/*                                                                   */\n/*   1. Redistributions of source code must retain the above         */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer.                                                  */\n/*                                                                   */\n/*   2. Redistributions in binary form must reproduce the above      */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer in the documentation and/or other materials       */\n/*      provided with the distribution.                              */\n/*                                                                   */\n/*    THIS  SOFTWARE IS PROVIDED  BY THE  UNIVERSITY OF  TEXAS AT    */\n/*    AUSTIN  ``AS IS''  AND ANY  EXPRESS OR  IMPLIED WARRANTIES,    */\n/*    INCLUDING, BUT  NOT LIMITED  TO, THE IMPLIED  WARRANTIES OF    */\n/*    MERCHANTABILITY  AND FITNESS FOR  A PARTICULAR  PURPOSE ARE    */\n/*    DISCLAIMED.  IN  NO EVENT SHALL THE UNIVERSITY  OF TEXAS AT    */\n/*    AUSTIN OR CONTRIBUTORS BE  LIABLE FOR ANY DIRECT, INDIRECT,    */\n/*    INCIDENTAL,  SPECIAL, EXEMPLARY,  OR  CONSEQUENTIAL DAMAGES    */\n/*    (INCLUDING, BUT  NOT LIMITED TO,  PROCUREMENT OF SUBSTITUTE    */\n/*    GOODS  OR  SERVICES; LOSS  OF  USE,  DATA,  OR PROFITS;  OR    */\n/*    BUSINESS INTERRUPTION) HOWEVER CAUSED  AND ON ANY THEORY OF    */\n/*    LIABILITY, WHETHER  IN CONTRACT, STRICT  LIABILITY, OR TORT    */\n/*    (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY WAY OUT    */\n/*    OF  THE  USE OF  THIS  SOFTWARE,  EVEN  IF ADVISED  OF  THE    */\n/*    POSSIBILITY OF SUCH DAMAGE.                                    */\n/*                                                                   */\n/* The views and conclusions contained in the software and           */\n/* documentation are those of the authors and should not be          */\n/* interpreted as representing official policies, either expressed   */\n/* or implied, of The University of Texas at Austin.                 */\n/*********************************************************************/\n\n#define CPU_UNKNOWN         0\n#define CPU_MIPS64_GENERIC  1\n#define CPU_SICORTEX        2\n#define CPU_LOONGSON3R3     3\n#define CPU_LOONGSON3R4     4\n#define CPU_I6400           5\n#define CPU_P6600           6\n#define CPU_I6500           7\n\nstatic char *cpuname[] = {\n  \"UNKNOWN\",\n  \"MIPS64_GENERIC\"\n  \"SICORTEX\",\n  \"LOONGSON3R3\",\n  \"LOONGSON3R4\",\n  \"I6400\",\n  \"P6600\",\n  \"I6500\"\n};\n\nint detect(void){\n\n#ifdef linux\n  FILE *infile;\n  char buffer[512], *p;\n\n  p = (char *)NULL;\n  //Check model name for Loongson3\n  infile = fopen(\"/proc/cpuinfo\", \"r\");\n  while (fgets(buffer, sizeof(buffer), infile)){\n    if (!strncmp(\"model name\", buffer, 10)){\n      p = strchr(buffer, ':') + 2;\n      break;\n    }\n  }\n  fclose(infile);\n  if (p != NULL){\n    if (strstr(p, \"Loongson-3A3000\") || strstr(p, \"Loongson-3B3000\")){\n      return CPU_LOONGSON3R3;\n    } else if (strstr(p, \"Loongson-3A4000\") || strstr(p, \"Loongson-3B4000\")){\n      return CPU_LOONGSON3R4;\n    } else{\n      return CPU_SICORTEX;\n    }\n  }\n\n  return CPU_MIPS64_GENERIC;\n#else\n  return CPU_UNKNOWN;\n#endif\n}\n\nchar *get_corename(void){\n  return cpuname[detect()];\n}\n\nvoid get_architecture(void){\n  printf(\"MIPS64\");\n}\n\nvoid get_subarchitecture(void){\n  if(detect()==CPU_LOONGSON3R3) {\n    printf(\"LOONGSON3R3\");\n  }else if(detect()==CPU_LOONGSON3R4){\n    printf(\"LOONGSON3R4\");\n  }else if(detect()==CPU_I6400){\n    printf(\"I6400\");\n  }else if(detect()==CPU_P6600){\n    printf(\"P6600\");\n  }else if(detect()==CPU_I6500){\n    printf(\"I6500\");\n  }else if(detect()==CPU_SICORTEX){\n    printf(\"SICORTEX\");\n  }else{\n    printf(\"MIPS64_GENERIC\");\n  } \n}\n\nvoid get_subdirname(void){\n  printf(\"mips64\");\n}\n\nvoid get_cpuconfig(void){\n  if(detect()==CPU_LOONGSON3R3) {\n    printf(\"#define LOONGSON3R3\\n\");\n    printf(\"#define L1_DATA_SIZE 65536\\n\");\n    printf(\"#define L1_DATA_LINESIZE 32\\n\");\n    printf(\"#define L2_SIZE 512488\\n\");\n    printf(\"#define L2_LINESIZE 32\\n\");\n    printf(\"#define DTB_DEFAULT_ENTRIES 64\\n\");\n    printf(\"#define DTB_SIZE 4096\\n\");\n    printf(\"#define L2_ASSOCIATIVE 4\\n\");\n  }else if(detect()==CPU_LOONGSON3R4){\n    printf(\"#define LOONGSON3R4\\n\");\n    printf(\"#define L1_DATA_SIZE 65536\\n\");\n    printf(\"#define L1_DATA_LINESIZE 32\\n\");\n    printf(\"#define L2_SIZE 512488\\n\");\n    printf(\"#define L2_LINESIZE 32\\n\");\n    printf(\"#define DTB_DEFAULT_ENTRIES 64\\n\");\n    printf(\"#define DTB_SIZE 4096\\n\");\n    printf(\"#define L2_ASSOCIATIVE 4\\n\");\n  }else if(detect()==CPU_I6400){\n    printf(\"#define I6400\\n\");\n    printf(\"#define L1_DATA_SIZE 65536\\n\");\n    printf(\"#define L1_DATA_LINESIZE 32\\n\");\n    printf(\"#define L2_SIZE 1048576\\n\");\n    printf(\"#define L2_LINESIZE 32\\n\");\n    printf(\"#define DTB_DEFAULT_ENTRIES 64\\n\");\n    printf(\"#define DTB_SIZE 4096\\n\");\n    printf(\"#define L2_ASSOCIATIVE 8\\n\");\n  }else if(detect()==CPU_P6600){\n    printf(\"#define P6600\\n\");\n    printf(\"#define L1_DATA_SIZE 65536\\n\");\n    printf(\"#define L1_DATA_LINESIZE 32\\n\");\n    printf(\"#define L2_SIZE 1048576\\n\");\n    printf(\"#define L2_LINESIZE 32\\n\");\n    printf(\"#define DTB_DEFAULT_ENTRIES 64\\n\");\n    printf(\"#define DTB_SIZE 4096\\n\");\n    printf(\"#define L2_ASSOCIATIVE 8\\n\");\n  }else if(detect()==CPU_I6500){\n    printf(\"#define I6500\\n\");\n    printf(\"#define L1_DATA_SIZE 65536\\n\");\n    printf(\"#define L1_DATA_LINESIZE 32\\n\");\n    printf(\"#define L2_SIZE 1048576\\n\");\n    printf(\"#define L2_LINESIZE 32\\n\");\n    printf(\"#define DTB_DEFAULT_ENTRIES 64\\n\");\n    printf(\"#define DTB_SIZE 4096\\n\");\n    printf(\"#define L2_ASSOCIATIVE 8\\n\");\n  }else{\n    printf(\"#define SICORTEX\\n\");\n    printf(\"#define L1_DATA_SIZE 32768\\n\");\n    printf(\"#define L1_DATA_LINESIZE 32\\n\");\n    printf(\"#define L2_SIZE 512488\\n\");\n    printf(\"#define L2_LINESIZE 32\\n\");\n    printf(\"#define DTB_DEFAULT_ENTRIES 32\\n\");\n    printf(\"#define DTB_SIZE 4096\\n\");\n    printf(\"#define L2_ASSOCIATIVE 8\\n\");\n  }\n#ifndef NO_MSA\n  if (get_feature(\"msa\")) printf(\"#define HAVE_MSA\\n\");\n#endif\n}\n\nvoid get_libname(void){\n  if(detect()==CPU_LOONGSON3R3) {\n    printf(\"loongson3r3\\n\");\n  }else if(detect()==CPU_LOONGSON3R4) {\n    printf(\"loongson3r4\\n\");\n  }else if(detect()==CPU_I6400) {\n    printf(\"i6400\\n\");\n  }else if(detect()==CPU_P6600) {\n    printf(\"p6600\\n\");\n  }else if(detect()==CPU_I6500) {\n    printf(\"i6500\\n\");\n  }else {\n    printf(\"mips64_generic\\n\");\n  }\n}\n\nint get_feature(char *search)\n{\n\n#ifdef __linux\n        FILE *infile;\n        char buffer[2048], *p,*t;\n        p = (char *) NULL ;\n\n        infile = fopen(\"/proc/cpuinfo\", \"r\");\n\n        while (fgets(buffer, sizeof(buffer), infile))\n        {\n\n                if (!strncmp(\"Features\", buffer, 8) || !strncmp(\"ASEs implemented\", buffer, 16))\n                {\n                        p = strchr(buffer, ':') + 2;\n                        break;\n                }\n        }\n\n        fclose(infile);\n\n        if( p == NULL ) return 0;\n\n        t = strtok(p,\" \");\n        while( t = strtok(NULL,\" \"))\n        {\n                if (strstr(t, search))   { return(1); }\n        }\n\n#endif\n        return(0);\n}\n\n"
        },
        {
          "name": "cpuid_power.c",
          "type": "blob",
          "size": 7.6357421875,
          "content": "/*********************************************************************/\n/* Copyright 2009, 2010 The University of Texas at Austin.           */\n/* All rights reserved.                                              */\n/*                                                                   */\n/* Redistribution and use in source and binary forms, with or        */\n/* without modification, are permitted provided that the following   */\n/* conditions are met:                                               */\n/*                                                                   */\n/*   1. Redistributions of source code must retain the above         */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer.                                                  */\n/*                                                                   */\n/*   2. Redistributions in binary form must reproduce the above      */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer in the documentation and/or other materials       */\n/*      provided with the distribution.                              */\n/*                                                                   */\n/*    THIS  SOFTWARE IS PROVIDED  BY THE  UNIVERSITY OF  TEXAS AT    */\n/*    AUSTIN  ``AS IS''  AND ANY  EXPRESS OR  IMPLIED WARRANTIES,    */\n/*    INCLUDING, BUT  NOT LIMITED  TO, THE IMPLIED  WARRANTIES OF    */\n/*    MERCHANTABILITY  AND FITNESS FOR  A PARTICULAR  PURPOSE ARE    */\n/*    DISCLAIMED.  IN  NO EVENT SHALL THE UNIVERSITY  OF TEXAS AT    */\n/*    AUSTIN OR CONTRIBUTORS BE  LIABLE FOR ANY DIRECT, INDIRECT,    */\n/*    INCIDENTAL,  SPECIAL, EXEMPLARY,  OR  CONSEQUENTIAL DAMAGES    */\n/*    (INCLUDING, BUT  NOT LIMITED TO,  PROCUREMENT OF SUBSTITUTE    */\n/*    GOODS  OR  SERVICES; LOSS  OF  USE,  DATA,  OR PROFITS;  OR    */\n/*    BUSINESS INTERRUPTION) HOWEVER CAUSED  AND ON ANY THEORY OF    */\n/*    LIABILITY, WHETHER  IN CONTRACT, STRICT  LIABILITY, OR TORT    */\n/*    (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY WAY OUT    */\n/*    OF  THE  USE OF  THIS  SOFTWARE,  EVEN  IF ADVISED  OF  THE    */\n/*    POSSIBILITY OF SUCH DAMAGE.                                    */\n/*                                                                   */\n/* The views and conclusions contained in the software and           */\n/* documentation are those of the authors and should not be          */\n/* interpreted as representing official policies, either expressed   */\n/* or implied, of The University of Texas at Austin.                 */\n/*********************************************************************/\n\n#include  <sys/utsname.h>\n#ifdef _AIX\n#include <sys/systemcfg.h>\n#include <sys/vminfo.h>\n#endif\n#ifdef __APPLE__\n#include <mach/mach.h>\n#include <mach/mach_host.h>\n#include <mach/host_info.h>\n#include <mach/machine.h>\n#endif\n\n#define CPUTYPE_UNKNOWN    0\n#define CPUTYPE_POWER3     1\n#define CPUTYPE_POWER4     2\n#define CPUTYPE_PPC970     3\n#define CPUTYPE_POWER5     4\n#define CPUTYPE_POWER6     5\n#define CPUTYPE_CELL       6\n#define CPUTYPE_PPCG4\t   7\n#define CPUTYPE_POWER8     8\n#define CPUTYPE_POWER9     9\n#define CPUTYPE_POWER10   10\n\nchar *cpuname[] = {\n  \"UNKNOWN\",\n  \"POWER3\",\n  \"POWER4\",\n  \"PPC970\",\n  \"POWER5\",\n  \"POWER6\",\n  \"CELL\",\n  \"PPCG4\",\n  \"POWER8\",\n  \"POWER9\",\n  \"POWER10\"\n};\n\nchar *lowercpuname[] = {\n  \"unknown\",\n  \"power3\",\n  \"power4\",\n  \"ppc970\",\n  \"power5\",\n  \"power6\",\n  \"cell\",\n  \"ppcg4\",\n  \"power8\",\n  \"power9\",\t\n  \"power10\"\t\n};\n\nchar *corename[] = {\n  \"UNKNOWN\",\n  \"POWER3\",\n  \"POWER4\",\n  \"POWER4\",\n  \"POWER4\",\n  \"POWER6\",\n  \"CELL\",\n  \"PPCG4\",\n  \"POWER8\",\n  \"POWER9\",  \t\n  \"POWER10\"   \t\n};\n\nint detect(void){\n\n#ifdef __linux\n  FILE *infile;\n  char buffer[512], *p;\n\n  p = (char *)NULL;\n  infile = fopen(\"/proc/cpuinfo\", \"r\");\n  while (fgets(buffer, sizeof(buffer), infile)){\n    if (!strncmp(\"cpu\", buffer, 3)){\n\tp = strchr(buffer, ':') + 2;\n#if 0\n\tfprintf(stderr, \"%s\\n\", p);\n#endif\n\tbreak;\n      }\n  }\n\n  fclose(infile);\n\n  if (!strncasecmp(p, \"POWER3\", 6)) return CPUTYPE_POWER3;\n  if (!strncasecmp(p, \"POWER4\", 6)) return CPUTYPE_POWER4;\n  if (!strncasecmp(p, \"PPC970\", 6)) return CPUTYPE_PPC970;\n  if (!strncasecmp(p, \"POWER5\", 6)) return CPUTYPE_POWER5;\n  if (!strncasecmp(p, \"POWER6\", 6)) return CPUTYPE_POWER6;\n  if (!strncasecmp(p, \"POWER7\", 6)) return CPUTYPE_POWER6;\n  if (!strncasecmp(p, \"POWER8\", 6)) return CPUTYPE_POWER8;\n  if (!strncasecmp(p, \"POWER9\", 6)) return CPUTYPE_POWER9;\n  if (!strncasecmp(p, \"POWER10\", 7)) return CPUTYPE_POWER10;\n  if (!strncasecmp(p, \"Cell\",   4)) return CPUTYPE_CELL;\n  if (!strncasecmp(p, \"7447\",   4)) return CPUTYPE_PPCG4;\n\n  return CPUTYPE_UNKNOWN;\n#endif\n\n#ifdef _AIX\n  // Cast from int to unsigned to ensure comparisons work for all bits in\n  // the bit mask, even the top bit\n  unsigned implementation = (unsigned) _system_configuration.implementation;\n\n  if (implementation >= 0x40000u) return CPUTYPE_POWER10;\n  else if (implementation & 0x20000) return CPUTYPE_POWER9;\n  else if (implementation & 0x10000) return CPUTYPE_POWER8;\n  else if (implementation & 0x08000) return CPUTYPE_POWER6; // POWER 7\n  else if (implementation & 0x04000) return CPUTYPE_POWER6;\n  else if (implementation & 0x02000) return CPUTYPE_POWER5;\n  else if (implementation & 0x01000) return CPUTYPE_POWER4; // MPC7450\n  else if (implementation & 0x00800) return CPUTYPE_POWER4;\n  else return CPUTYPE_POWER3;\n#endif\n\n#ifdef __APPLE__\n  host_basic_info_data_t   hostInfo;\n  mach_msg_type_number_t  infoCount;\n\n  infoCount = HOST_BASIC_INFO_COUNT;\n  host_info(mach_host_self(), HOST_BASIC_INFO, (host_info_t)&hostInfo, &infoCount);\n\n  if (hostInfo.cpu_subtype == CPU_SUBTYPE_POWERPC_7400) return CPUTYPE_PPCG4;\n  if (hostInfo.cpu_subtype == CPU_SUBTYPE_POWERPC_7450) return CPUTYPE_PPCG4;\n  if (hostInfo.cpu_subtype == CPU_SUBTYPE_POWERPC_970)  return CPUTYPE_PPC970;\n\n  return  CPUTYPE_PPC970;\n#endif\n\n#if defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__NetBSD__)\nint id;\n__asm __volatile(\"mfpvr %0\" : \"=r\"(id));\nswitch ( id >> 16 ) {\n  case 0x80: // POWER10\n    return CPUTYPE_POWER10;\n    break;\n  case 0x4e: // POWER9\n    return CPUTYPE_POWER9;\n    break;\n  case 0x4d:\n  case 0x4b: // POWER8/8E \n    return CPUTYPE_POWER8;\n    break;\n  case 0x4a:\n  case 0x3f:  // POWER7/7E\n    return CPUTYPE_POWER6; \n    break;\n  case 0x3e:\n    return CPUTYPE_POWER6;\n    break;\n  case 0x3a:\n    return CPUTYPE_POWER5;\n    break;\n  case 0x35:\n  case 0x38: // POWER4 /4+ \n    return CPUTYPE_POWER4;\n    break;\n  case 0x40:\n  case 0x41: // POWER3 /3+ \n    return CPUTYPE_POWER3;\n    break;\n  case 0x39:\n  case 0x3c:\n  case 0x44:\n  case 0x45:\n    return CPUTYPE_PPC970;\n    break;\n  case 0x70: \n    return CPUTYPE_CELL;\n    break;\n  case 0x8003: \n    return CPUTYPE_PPCG4;\n    break;\n  default:  \n    return  CPUTYPE_UNKNOWN;\n  }\n#endif\n\t\n return CPUTYPE_UNKNOWN;\t\n}\n\nvoid get_architecture(void){\n  printf(\"POWER\");\n}\n\nvoid get_subdirname(void){\n    printf(\"power\");\n}\n\n\nvoid get_subarchitecture(void){\n  printf(\"%s\", cpuname[detect()]);\n}\n\nvoid get_cpuconfig(void){\n#if 0\n#ifdef _AIX\n  struct vminfo info;\n#endif\n#endif\n\n  printf(\"#define %s\\n\", cpuname[detect()]);\n  printf(\"#define CORE_%s\\n\", corename[detect()]);\n\n  printf(\"#define L1_DATA_SIZE 32768\\n\");\n  printf(\"#define L1_DATA_LINESIZE 128\\n\");\n  printf(\"#define L2_SIZE 524288\\n\");\n  printf(\"#define L2_LINESIZE 128 \\n\");\n  printf(\"#define DTB_DEFAULT_ENTRIES 128\\n\");\n  printf(\"#define DTB_SIZE 4096\\n\");\n  printf(\"#define L2_ASSOCIATIVE 8\\n\");\n\n#if 0\n#ifdef _AIX\n  if (vmgetinfo(&info, VMINFO, 0) == 0) {\n    if ((info.lgpg_size >> 20) >= 1024) {\n      printf(\"#define ALLOC_HUGETLB\\n\");\n    }\n  }\n#endif\n#endif\n\n}\n\nvoid get_libname(void){\n  printf(\"%s\", lowercpuname[detect()]);\n}\n\nchar *get_corename(void){\n  return cpuname[detect()];\n}\n"
        },
        {
          "name": "cpuid_riscv64.c",
          "type": "blob",
          "size": 6.11328125,
          "content": "/*****************************************************************************\nCopyright (c) 2011-2022, The OpenBLAS Project\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   1. Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n\n   2. Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in\n      the documentation and/or other materials provided with the\n      distribution.\n   3. Neither the name of the OpenBLAS project nor the names of\n      its contributors may be used to endorse or promote products\n      derived from this software without specific prior written\n      permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\nUSE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n**********************************************************************************/\n\n\n/*********************************************************************/\n/* Copyright 2009, 2010 The University of Texas at Austin.           */\n/* All rights reserved.                                              */\n/*                                                                   */\n/* Redistribution and use in source and binary forms, with or        */\n/* without modification, are permitted provided that the following   */\n/* conditions are met:                                               */\n/*                                                                   */\n/*   1. Redistributions of source code must retain the above         */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer.                                                  */\n/*                                                                   */\n/*   2. Redistributions in binary form must reproduce the above      */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer in the documentation and/or other materials       */\n/*      provided with the distribution.                              */\n/*                                                                   */\n/*    THIS  SOFTWARE IS PROVIDED  BY THE  UNIVERSITY OF  TEXAS AT    */\n/*    AUSTIN  ``AS IS''  AND ANY  EXPRESS OR  IMPLIED WARRANTIES,    */\n/*    INCLUDING, BUT  NOT LIMITED  TO, THE IMPLIED  WARRANTIES OF    */\n/*    MERCHANTABILITY  AND FITNESS FOR  A PARTICULAR  PURPOSE ARE    */\n/*    DISCLAIMED.  IN  NO EVENT SHALL THE UNIVERSITY  OF TEXAS AT    */\n/*    AUSTIN OR CONTRIBUTORS BE  LIABLE FOR ANY DIRECT, INDIRECT,    */\n/*    INCIDENTAL,  SPECIAL, EXEMPLARY,  OR  CONSEQUENTIAL DAMAGES    */\n/*    (INCLUDING, BUT  NOT LIMITED TO,  PROCUREMENT OF SUBSTITUTE    */\n/*    GOODS  OR  SERVICES; LOSS  OF  USE,  DATA,  OR PROFITS;  OR    */\n/*    BUSINESS INTERRUPTION) HOWEVER CAUSED  AND ON ANY THEORY OF    */\n/*    LIABILITY, WHETHER  IN CONTRACT, STRICT  LIABILITY, OR TORT    */\n/*    (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY WAY OUT    */\n/*    OF  THE  USE OF  THIS  SOFTWARE,  EVEN  IF ADVISED  OF  THE    */\n/*    POSSIBILITY OF SUCH DAMAGE.                                    */\n/*                                                                   */\n/* The views and conclusions contained in the software and           */\n/* documentation are those of the authors and should not be          */\n/* interpreted as representing official policies, either expressed   */\n/* or implied, of The University of Texas at Austin.                 */\n/*********************************************************************/\n\n#define CPU_GENERIC         0\n#define CPU_C910V           1\n#define CPU_x280            2\n#define CPU_RISCV64_ZVL256B 3\n#define CPU_RISCV64_ZVL128B 4\n\nstatic char *cpuname[] = {\n  \"RISCV64_GENERIC\",\n  \"C910V\",\n  \"x280\",\n  \"CPU_RISCV64_ZVL256B\",\n  \"CPU_RISCV64_ZVL128B\"\n};\n\nstatic char *cpuname_lower[] = {\n  \"riscv64_generic\",\n  \"c910v\",\n  \"x280\",\n  \"riscv64_zvl256b\",\n  \"riscv64_zvl128b\"\n};\n\nint detect(void){\n#ifdef __linux\n  FILE *infile;\n  char buffer[512],isa_buffer[512],model_buffer[512];\n  const char* check_c910_str = \"T-HEAD C910\";\n  char *pmodel = NULL, *pisa = NULL;\n\n  infile = fopen(\"/proc/cpuinfo\", \"r\");\n  if (!infile)\n    return CPU_GENERIC;\n  while (fgets(buffer, sizeof(buffer), infile)){\n    if(!strncmp(buffer, \"model name\", 10)){\n      strcpy(model_buffer, buffer);\n      pmodel = strchr(model_buffer, ':');\n      if (pmodel)\n        pmodel++;\n    }\n\n    if(!strncmp(buffer, \"isa\", 3)){\n      strcpy(isa_buffer, buffer);\n      pisa = strchr(isa_buffer, '4');\n      if (pisa)\n        pisa++;\n    }\n  }\n\n  fclose(infile);\n\n  if (!pmodel || !pisa)\n   return(CPU_GENERIC);\n\n  if (strstr(pmodel, check_c910_str) && strchr(pisa, 'v'))\n    return CPU_C910V;\n\n  return CPU_GENERIC;\n#endif\n\n  return CPU_GENERIC;\n}\n\nchar *get_corename(void){\n  return cpuname[detect()];\n}\n\nvoid get_architecture(void){\n  printf(\"RISCV64\");\n}\n\nvoid get_subarchitecture(void){\n  printf(\"%s\",cpuname[detect()]);\n}\n\nvoid get_subdirname(void){\n  printf(\"riscv64\");\n}\n\nvoid get_cpuconfig(void){\n  printf(\"#define %s\\n\", cpuname[detect()]);\n  printf(\"#define L1_DATA_SIZE 65536\\n\");\n  printf(\"#define L1_DATA_LINESIZE 32\\n\");\n  printf(\"#define L2_SIZE 512488\\n\");\n  printf(\"#define L2_LINESIZE 32\\n\");\n  printf(\"#define DTB_DEFAULT_ENTRIES 64\\n\");\n  printf(\"#define DTB_SIZE 4096\\n\");\n  printf(\"#define L2_ASSOCIATIVE 4\\n\");\n}\n\nvoid get_libname(void){\n  printf(\"%s\", cpuname_lower[detect()]);\n}\n"
        },
        {
          "name": "cpuid_sparc.c",
          "type": "blob",
          "size": 2.966796875,
          "content": "/*********************************************************************/\n/* Copyright 2009, 2010 The University of Texas at Austin.           */\n/* All rights reserved.                                              */\n/*                                                                   */\n/* Redistribution and use in source and binary forms, with or        */\n/* without modification, are permitted provided that the following   */\n/* conditions are met:                                               */\n/*                                                                   */\n/*   1. Redistributions of source code must retain the above         */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer.                                                  */\n/*                                                                   */\n/*   2. Redistributions in binary form must reproduce the above      */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer in the documentation and/or other materials       */\n/*      provided with the distribution.                              */\n/*                                                                   */\n/*    THIS  SOFTWARE IS PROVIDED  BY THE  UNIVERSITY OF  TEXAS AT    */\n/*    AUSTIN  ``AS IS''  AND ANY  EXPRESS OR  IMPLIED WARRANTIES,    */\n/*    INCLUDING, BUT  NOT LIMITED  TO, THE IMPLIED  WARRANTIES OF    */\n/*    MERCHANTABILITY  AND FITNESS FOR  A PARTICULAR  PURPOSE ARE    */\n/*    DISCLAIMED.  IN  NO EVENT SHALL THE UNIVERSITY  OF TEXAS AT    */\n/*    AUSTIN OR CONTRIBUTORS BE  LIABLE FOR ANY DIRECT, INDIRECT,    */\n/*    INCIDENTAL,  SPECIAL, EXEMPLARY,  OR  CONSEQUENTIAL DAMAGES    */\n/*    (INCLUDING, BUT  NOT LIMITED TO,  PROCUREMENT OF SUBSTITUTE    */\n/*    GOODS  OR  SERVICES; LOSS  OF  USE,  DATA,  OR PROFITS;  OR    */\n/*    BUSINESS INTERRUPTION) HOWEVER CAUSED  AND ON ANY THEORY OF    */\n/*    LIABILITY, WHETHER  IN CONTRACT, STRICT  LIABILITY, OR TORT    */\n/*    (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY WAY OUT    */\n/*    OF  THE  USE OF  THIS  SOFTWARE,  EVEN  IF ADVISED  OF  THE    */\n/*    POSSIBILITY OF SUCH DAMAGE.                                    */\n/*                                                                   */\n/* The views and conclusions contained in the software and           */\n/* documentation are those of the authors and should not be          */\n/* interpreted as representing official policies, either expressed   */\n/* or implied, of The University of Texas at Austin.                 */\n/*********************************************************************/\n\nvoid get_architecture(void){\n  printf(\"SPARC\");\n}\n\nvoid get_subarchitecture(void){\n  printf(\"v9\");\n}\n\nvoid get_subdirname(void){\n  printf(\"sparc\");\n}\n\nvoid get_cpuconfig(void){\n  printf(\"#define SPARC\\n\");\n  printf(\"#define V9\\n\");\n  printf(\"#define DTB_DEFAULT_ENTRIES 32\\n\");\n}\n\nvoid get_libname(void){\n  printf(\"v9\\n\");\n}\n\nchar *get_corename(void){\n  return \"sparc\";\n}\n\n"
        },
        {
          "name": "cpuid_x86.c",
          "type": "blob",
          "size": 62.853515625,
          "content": "//{\n/*********************************************************************/\n/* Copyright 2009, 2010 The University of Texas at Austin.           */\n/* All rights reserved.                                              */\n/*                                                                   */\n/* Redistribution and use in source and binary forms, with or        */\n/* without modification, are permitted provided that the following   */\n/* conditions are met:                                               */\n/*                                                                   */\n/*   1. Redistributions of source code must retain the above         */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer.                                                  */\n/*                                                                   */\n/*   2. Redistributions in binary form must reproduce the above      */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer in the documentation and/or other materials       */\n/*      provided with the distribution.                              */\n/*                                                                   */\n/*    THIS  SOFTWARE IS PROVIDED  BY THE  UNIVERSITY OF  TEXAS AT    */\n/*    AUSTIN  ``AS IS''  AND ANY  EXPRESS OR  IMPLIED WARRANTIES,    */\n/*    INCLUDING, BUT  NOT LIMITED  TO, THE IMPLIED  WARRANTIES OF    */\n/*    MERCHANTABILITY  AND FITNESS FOR  A PARTICULAR  PURPOSE ARE    */\n/*    DISCLAIMED.  IN  NO EVENT SHALL THE UNIVERSITY  OF TEXAS AT    */\n/*    AUSTIN OR CONTRIBUTORS BE  LIABLE FOR ANY DIRECT, INDIRECT,    */\n/*    INCIDENTAL,  SPECIAL, EXEMPLARY,  OR  CONSEQUENTIAL DAMAGES    */\n/*    (INCLUDING, BUT  NOT LIMITED TO,  PROCUREMENT OF SUBSTITUTE    */\n/*    GOODS  OR  SERVICES; LOSS  OF  USE,  DATA,  OR PROFITS;  OR    */\n/*    BUSINESS INTERRUPTION) HOWEVER CAUSED  AND ON ANY THEORY OF    */\n/*    LIABILITY, WHETHER  IN CONTRACT, STRICT  LIABILITY, OR TORT    */\n/*    (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY WAY OUT    */\n/*    OF  THE  USE OF  THIS  SOFTWARE,  EVEN  IF ADVISED  OF  THE    */\n/*    POSSIBILITY OF SUCH DAMAGE.                                    */\n/*                                                                   */\n/* The views and conclusions contained in the software and           */\n/* documentation are those of the authors and should not be          */\n/* interpreted as representing official policies, either expressed   */\n/* or implied, of The University of Texas at Austin.                 */\n/*********************************************************************/\n\n#include <stdio.h>\n#include <string.h>\n#include \"cpuid.h\"\n\n#if defined(_MSC_VER) && !defined(__clang__)\n#define C_INLINE __inline\n#else\n#define C_INLINE inline\n#endif\n\n/*\n#ifdef NO_AVX\n#define CPUTYPE_HASWELL CPUTYPE_NEHALEM\n#define CORE_HASWELL CORE_NEHALEM\n#define CPUTYPE_SKYLAKEX CPUTYPE_NEHALEM\n#define CORE_SKYLAKEX CORE_NEHALEM\n#define CPUTYPE_SANDYBRIDGE CPUTYPE_NEHALEM\n#define CORE_SANDYBRIDGE CORE_NEHALEM\n#define CPUTYPE_BULLDOZER CPUTYPE_BARCELONA\n#define CORE_BULLDOZER CORE_BARCELONA\n#define CPUTYPE_PILEDRIVER CPUTYPE_BARCELONA\n#define CORE_PILEDRIVER CORE_BARCELONA\n#endif\n*/\n\n#if defined(_MSC_VER) && !defined(__clang__)\n\nvoid cpuid(int op, int *eax, int *ebx, int *ecx, int *edx)\n{\n  int cpuInfo[4] = {-1};\n  __cpuid(cpuInfo, op);\n  *eax = cpuInfo[0];\n  *ebx = cpuInfo[1];\n  *ecx = cpuInfo[2];\n  *edx = cpuInfo[3];\n}\n\nvoid cpuid_count(int op, int count, int *eax, int *ebx, int *ecx, int *edx)\n{\n  int cpuInfo[4] = {-1};\n  __cpuidex(cpuInfo, op, count);\n  *eax = cpuInfo[0];\n  *ebx = cpuInfo[1];\n  *ecx = cpuInfo[2];\n  *edx = cpuInfo[3];\n}\n\n#else\n\n#ifndef CPUIDEMU\n\n#if defined(__APPLE__) && defined(__i386__)\nvoid cpuid(int op, int *eax, int *ebx, int *ecx, int *edx);\nvoid cpuid_count(int op, int count, int *eax, int *ebx, int *ecx, int *edx);\n#else\nstatic C_INLINE void cpuid(int op, int *eax, int *ebx, int *ecx, int *edx){\n#if defined(__i386__) && defined(__PIC__)\n  __asm__ __volatile__\n    (\"mov %%ebx, %%edi;\"\n     \"cpuid;\"\n     \"xchgl %%ebx, %%edi;\"\n     : \"=a\" (*eax), \"=D\" (*ebx), \"=c\" (*ecx), \"=d\" (*edx) : \"a\" (op), \"c\" (0) : \"cc\");\n#else\n  __asm__ __volatile__\n    (\"cpuid\": \"=a\" (*eax), \"=b\" (*ebx), \"=c\" (*ecx), \"=d\" (*edx) : \"a\" (op) , \"c\" (0) : \"cc\");\n#endif\n}\n\nstatic C_INLINE void cpuid_count(int op, int count ,int *eax, int *ebx, int *ecx, int *edx){\n#if defined(__i386__) && defined(__PIC__)\n  __asm__ __volatile__\n    (\"mov %%ebx, %%edi;\"\n     \"cpuid;\"\n     \"xchgl %%ebx, %%edi;\"\n     : \"=a\" (*eax), \"=D\" (*ebx), \"=c\" (*ecx), \"=d\" (*edx) : \"0\" (op), \"2\" (count) : \"cc\");\n#else\n  __asm__ __volatile__\n    (\"cpuid\": \"=a\" (*eax), \"=b\" (*ebx), \"=c\" (*ecx), \"=d\" (*edx) : \"0\" (op), \"2\" (count) : \"cc\");\n#endif\n}\n#endif\n\n#else\n\ntypedef struct {\n  unsigned int id, a, b, c, d;\n} idlist_t;\n\ntypedef struct {\n  char *vendor;\n  char *name;\n  int start, stop;\n} vendor_t;\n\nextern idlist_t idlist[];\nextern vendor_t vendor[];\n\nstatic int cv = VENDOR;\n\nvoid cpuid(unsigned int op, unsigned int *eax, unsigned int *ebx, unsigned int *ecx, unsigned int *edx){\n\n  static int current = 0;\n\n  int start = vendor[cv].start;\n  int stop  = vendor[cv].stop;\n  int count = stop - start;\n\n  if ((current < start) || (current > stop)) current = start;\n\n  while ((count > 0) && (idlist[current].id != op)) {\n\n    current ++;\n    if (current > stop) current = start;\n    count --;\n\n  }\n\n  *eax = idlist[current].a;\n  *ebx = idlist[current].b;\n  *ecx = idlist[current].c;\n  *edx = idlist[current].d;\n}\n\nvoid cpuid_count (unsigned int op, unsigned int count, unsigned int *eax, unsigned int *ebx, unsigned int *ecx, unsigned int *edx) {\n  return cpuid (op, eax, ebx, ecx, edx);\n}\n\n#endif\n\n#endif // _MSC_VER\n\nstatic C_INLINE int have_cpuid(void){\n  int eax, ebx, ecx, edx;\n\n  cpuid(0, &eax, &ebx, &ecx, &edx);\n  return eax;\n}\n\nstatic C_INLINE int have_excpuid(void){\n  int eax, ebx, ecx, edx;\n\n  cpuid(0x80000000, &eax, &ebx, &ecx, &edx);\n  return eax & 0xffff;\n}\n\n#ifndef NO_AVX\nstatic C_INLINE void xgetbv(int op, int * eax, int * edx){\n  //Use binary code for xgetbv\n#if defined(_MSC_VER) && !defined(__clang__)\n  *eax = __xgetbv(op);\n#else\n  __asm__ __volatile__\n    (\".byte 0x0f, 0x01, 0xd0\": \"=a\" (*eax), \"=d\" (*edx) : \"c\" (op) : \"cc\");\n#endif\n}\n#endif\n\nint support_avx(void){\n#ifndef NO_AVX\n  int eax, ebx, ecx, edx;\n  int ret=0;\n\n  cpuid(1, &eax, &ebx, &ecx, &edx);\n  if ((ecx & (1 << 28)) != 0 && (ecx & (1 << 27)) != 0 && (ecx & (1 << 26)) != 0){\n    xgetbv(0, &eax, &edx);\n    if((eax & 6) == 6){\n      ret=1;  //OS supports saving xmm and ymm registers (6 = (1<<1) | (1<<2))\n    }\n  }\n  return ret;\n#else\n  return 0;\n#endif\n}\n\nint support_avx2(void){\n#ifndef NO_AVX2\n  int eax, ebx, ecx=0, edx;\n  int ret=0;\n\n  if (!support_avx()) \n    return 0;\n  cpuid(7, &eax, &ebx, &ecx, &edx);\n  if((ebx & (1<<5)) != 0)\n      ret=1;  //CPU supports AVX2\n  return ret;\n#else\n  return 0;\n#endif\n}\n\nint support_avx512(void){\n#if !defined(NO_AVX) && !defined(NO_AVX512)\n  int eax, ebx, ecx, edx;\n  int ret=0;\n\n  if (!support_avx()) \n    return 0;\n  cpuid(7, &eax, &ebx, &ecx, &edx);\n  if((ebx & (1<<5)) == 0){\n      ret=0;  //cpu does not have avx2 flag\n  }\n  if((ebx & (1<<31)) != 0){ //AVX512VL flag\n    xgetbv(0, &eax, &edx); \n    if((eax & 0xe0) == 0xe0)\n      ret=1;  //OS supports saving zmm registers\n }\n  return ret;\n#else\n  return 0;\n#endif\n}\n\nint support_avx512_bf16(void){\n#if !defined(NO_AVX) && !defined(NO_AVX512)\n  int eax, ebx, ecx, edx;\n  int ret=0;\n\n  if (!support_avx512())\n    return 0;\n  cpuid_count(7, 1, &eax, &ebx, &ecx, &edx);\n  if((eax & 32) == 32){\n      ret=1;  // CPUID.7.1:EAX[bit 5] indicates whether avx512_bf16 supported or not\n  }\n  return ret;\n#else\n  return 0;\n#endif\n}\n\n#define BIT_AMX_TILE\t0x01000000\n#define BIT_AMX_BF16\t0x00400000\n#define BIT_AMX_ENBD\t0x00060000\n\nint support_amx_bf16(void) {\n#if !defined(NO_AVX) && !defined(NO_AVX512)\n  int eax, ebx, ecx, edx;\n  int ret=0;\n\n  if (!support_avx512())\n    return 0;\n  // CPUID.7.0:EDX indicates AMX support\n  cpuid_count(7, 0, &eax, &ebx, &ecx, &edx);\n  if ((edx & BIT_AMX_TILE) && (edx & BIT_AMX_BF16)) {\n    // CPUID.D.0:EAX[17:18] indicates AMX enabled\n    cpuid_count(0xd, 0, &eax, &ebx, &ecx, &edx);\n    if ((eax & BIT_AMX_ENBD) == BIT_AMX_ENBD)\n      ret = 1;\n  }\n  return ret;\n#else\n  return 0;\n#endif\n}\n\nint get_vendor(void){\n  int eax, ebx, ecx, edx;\n  char vendor[13];\n\n  cpuid(0, &eax, &ebx, &ecx, &edx);\n\n  *(int *)(&vendor[0]) = ebx;\n  *(int *)(&vendor[4]) = edx;\n  *(int *)(&vendor[8]) = ecx;\n  vendor[12] = (char)0;\n\n  if (!strcmp(vendor, \"GenuineIntel\")) return VENDOR_INTEL;\n  if (!strcmp(vendor, \" UMC UMC UMC\")) return VENDOR_UMC;\n  if (!strcmp(vendor, \"AuthenticAMD\")) return VENDOR_AMD;\n  if (!strcmp(vendor, \"CyrixInstead\")) return VENDOR_CYRIX;\n  if (!strcmp(vendor, \"NexGenDriven\")) return VENDOR_NEXGEN;\n  if (!strcmp(vendor, \"CentaurHauls\")) return VENDOR_CENTAUR;\n  if (!strcmp(vendor, \"  Shanghai  \")) return VENDOR_ZHAOXIN;\n  if (!strcmp(vendor, \"RiseRiseRise\")) return VENDOR_RISE;\n  if (!strcmp(vendor, \" SiS SiS SiS\")) return VENDOR_SIS;\n  if (!strcmp(vendor, \"GenuineTMx86\")) return VENDOR_TRANSMETA;\n  if (!strcmp(vendor, \"Geode by NSC\")) return VENDOR_NSC;\n  if (!strcmp(vendor, \"HygonGenuine\")) return VENDOR_HYGON;\n\n  if ((eax == 0) || ((eax & 0x500) != 0)) return VENDOR_INTEL;\n\n  return VENDOR_UNKNOWN;\n}\n\nint get_cputype(int gettype){\n  int eax, ebx, ecx, edx;\n/*\n  int extend_family, family;\n  int extend_model, model;\n  int type, stepping;\n*/\n  int feature = 0;\n\n  cpuid(1, &eax, &ebx, &ecx, &edx);\n\n  switch (gettype) {\n  case GET_EXFAMILY :\n    return BITMASK(eax, 20, 0xff);\n  case GET_EXMODEL :\n    return BITMASK(eax, 16, 0x0f);\n  case GET_TYPE :\n    return BITMASK(eax, 12, 0x03);\n  case GET_FAMILY :\n    return BITMASK(eax,  8, 0x0f);\n  case GET_MODEL :\n    return BITMASK(eax,  4, 0x0f);\n  case GET_APICID :\n    return BITMASK(ebx, 24, 0x0f);\n  case GET_LCOUNT :\n    return BITMASK(ebx, 16, 0x0f);\n  case GET_CHUNKS :\n    return BITMASK(ebx,  8, 0x0f);\n  case GET_STEPPING :\n    return BITMASK(eax,  0, 0x0f);\n  case GET_BLANDID :\n    return BITMASK(ebx,  0, 0xff);\n  case GET_NUMSHARE :\n    if (have_cpuid() < 4) return 0;\n    cpuid(4, &eax, &ebx, &ecx, &edx);\n    return BITMASK(eax, 14, 0xfff);\n  case GET_NUMCORES :\n    if (have_cpuid() < 4) return 0;\n    cpuid(4, &eax, &ebx, &ecx, &edx);\n    return BITMASK(eax, 26, 0x3f);\n\n  case GET_FEATURE :\n    if ((edx & (1 <<  3)) != 0) feature |= HAVE_PSE;\n    if ((edx & (1 << 15)) != 0) feature |= HAVE_CMOV;\n    if ((edx & (1 << 19)) != 0) feature |= HAVE_CFLUSH;\n    if ((edx & (1 << 23)) != 0) feature |= HAVE_MMX;\n    if ((edx & (1 << 25)) != 0) feature |= HAVE_SSE;\n    if ((edx & (1 << 26)) != 0) feature |= HAVE_SSE2;\n    if ((edx & (1 << 27)) != 0) {\n      if (BITMASK(ebx, 16, 0x0f) > 0) feature |= HAVE_HIT;\n    }\n    if ((ecx & (1 <<  0)) != 0) feature |= HAVE_SSE3;\n    if ((ecx & (1 <<  9)) != 0) feature |= HAVE_SSSE3;\n    if ((ecx & (1 << 19)) != 0) feature |= HAVE_SSE4_1;\n    if ((ecx & (1 << 20)) != 0) feature |= HAVE_SSE4_2;\n#ifndef NO_AVX\n    if (support_avx()) feature |= HAVE_AVX;\n    if (support_avx2()) feature |= HAVE_AVX2;\n    if (support_avx512()) feature |= HAVE_AVX512VL;\n    if (support_avx512_bf16()) feature |= HAVE_AVX512BF16;\n    if (support_amx_bf16()) feature |= HAVE_AMXBF16;\n    if ((ecx & (1 << 12)) != 0) feature |= HAVE_FMA3;\n#endif\n\n    if (have_excpuid() >= 0x01) {\n      cpuid(0x80000001, &eax, &ebx, &ecx, &edx);\n      if ((ecx & (1 <<  6)) != 0) feature |= HAVE_SSE4A;\n      if ((ecx & (1 <<  7)) != 0) feature |= HAVE_MISALIGNSSE;\n#ifndef NO_AVX\n      if ((ecx & (1 <<  16)) != 0) feature |= HAVE_FMA4;\n#endif\n      if ((edx & (1 << 30)) != 0) feature |= HAVE_3DNOWEX;\n      if ((edx & (1 << 31)) != 0) feature |= HAVE_3DNOW;\n    }\n\n    if (have_excpuid() >= 0x1a) {\n      cpuid(0x8000001a, &eax, &ebx, &ecx, &edx);\n      if ((eax & (1 <<  0)) != 0) feature |= HAVE_128BITFPU;\n      if ((eax & (1 <<  1)) != 0) feature |= HAVE_FASTMOVU;\n    }\n\n  }\n  return feature;\n}\n\nint get_cacheinfo(int type, cache_info_t *cacheinfo){\n  int eax, ebx, ecx, edx, cpuid_level;\n  int info[15];\n  int i;\n  cache_info_t LC1, LD1, L2, L3,\n    ITB, DTB, LITB, LDTB,\n    L2ITB, L2DTB, L2LITB, L2LDTB;\n\n  LC1.size    = 0; LC1.associative = 0; LC1.linesize = 0; LC1.shared = 0;\n  LD1.size    = 0; LD1.associative    = 0; LD1.linesize    = 0; LD1.shared    = 0;\n  L2.size     = 0; L2.associative     = 0; L2.linesize     = 0; L2.shared     = 0;\n  L3.size     = 0; L3.associative     = 0; L3.linesize     = 0; L3.shared     = 0;\n  ITB.size    = 0; ITB.associative    = 0; ITB.linesize    = 0; ITB.shared    = 0;\n  DTB.size    = 0; DTB.associative    = 0; DTB.linesize    = 0; DTB.shared    = 0;\n  LITB.size   = 0; LITB.associative   = 0; LITB.linesize   = 0; LITB.shared   = 0;\n  LDTB.size   = 0; LDTB.associative   = 0; LDTB.linesize   = 0; LDTB.shared   = 0;\n  L2ITB.size  = 0; L2ITB.associative  = 0; L2ITB.linesize  = 0; L2ITB.shared  = 0;\n  L2DTB.size  = 0; L2DTB.associative  = 0; L2DTB.linesize  = 0; L2DTB.shared  = 0;\n  L2LITB.size = 0; L2LITB.associative = 0; L2LITB.linesize = 0; L2LITB.shared = 0;\n  L2LDTB.size = 0; L2LDTB.associative = 0; L2LDTB.linesize = 0; L2LDTB.shared = 0;\n\n  cpuid(0, &cpuid_level, &ebx, &ecx, &edx);\n\n  if (cpuid_level > 1) {\n    int numcalls;\n    \n    cpuid(2, &eax, &ebx, &ecx, &edx);\n    numcalls = BITMASK(eax, 0, 0xff); //FIXME some systems may require repeated calls to read all entries\n    info[ 0] = BITMASK(eax,  8, 0xff);\n    info[ 1] = BITMASK(eax, 16, 0xff);\n    info[ 2] = BITMASK(eax, 24, 0xff);\n\n    info[ 3] = BITMASK(ebx,  0, 0xff);\n    info[ 4] = BITMASK(ebx,  8, 0xff);\n    info[ 5] = BITMASK(ebx, 16, 0xff);\n    info[ 6] = BITMASK(ebx, 24, 0xff);\n\n    info[ 7] = BITMASK(ecx,  0, 0xff);\n    info[ 8] = BITMASK(ecx,  8, 0xff);\n    info[ 9] = BITMASK(ecx, 16, 0xff);\n    info[10] = BITMASK(ecx, 24, 0xff);\n\n    info[11] = BITMASK(edx,  0, 0xff);\n    info[12] = BITMASK(edx,  8, 0xff);\n    info[13] = BITMASK(edx, 16, 0xff);\n    info[14] = BITMASK(edx, 24, 0xff);\n\n    for (i = 0; i < 15; i++){\n      switch (info[i]){\n\n\t/* This table is from http://www.sandpile.org/ia32/cpuid.htm */\n\n      case 0x01 :\n\tITB.size        =     4;\n\tITB.associative =     4;\n\tITB.linesize     =   32;\n\tbreak;\n      case 0x02 :\n\tLITB.size        = 4096;\n\tLITB.associative =    0;\n\tLITB.linesize    =    2;\n\tbreak;\n      case 0x03 :\n\tDTB.size        =     4;\n\tDTB.associative =     4;\n\tDTB.linesize     =   64;\n\tbreak;\n      case 0x04 :\n\tLDTB.size        = 4096;\n\tLDTB.associative =    4;\n\tLDTB.linesize    =    8;\n\tbreak;\n      case 0x05 :\n\tLDTB.size        = 4096;\n\tLDTB.associative =    4;\n\tLDTB.linesize    =   32;\n\tbreak;\n      case 0x06 :\n\tLC1.size        = 8;\n\tLC1.associative = 4;\n\tLC1.linesize    = 32;\n\tbreak;\n      case 0x08 :\n\tLC1.size        = 16;\n\tLC1.associative = 4;\n\tLC1.linesize    = 32;\n\tbreak;\n      case 0x09 :\n\tLC1.size        = 32;\n\tLC1.associative = 4;\n\tLC1.linesize    = 64;\n\tbreak;\n      case 0x0a :\n\tLD1.size        = 8;\n\tLD1.associative = 2;\n\tLD1.linesize    = 32;\n\tbreak;\n      case 0x0c :\n\tLD1.size        = 16;\n\tLD1.associative = 4;\n\tLD1.linesize    = 32;\n\tbreak;\n      case 0x0d :\n\tLD1.size        = 16;\n\tLD1.associative = 4;\n\tLD1.linesize    = 64;\n\tbreak;\n      case 0x0e :\n\tLD1.size        = 24;\n\tLD1.associative = 6;\n\tLD1.linesize    = 64;\n\tbreak;\n      case 0x10 :\n\tLD1.size        = 16;\n\tLD1.associative = 4;\n\tLD1.linesize    = 32;\n\tbreak;\n      case 0x15 :\n\tLC1.size        = 16;\n\tLC1.associative = 4;\n\tLC1.linesize    = 32;\n\tbreak;\n      case 0x1a :\n\tL2.size         = 96;\n\tL2.associative  = 6;\n\tL2.linesize     = 64;\n\tbreak;\n      case 0x21 :\n\tL2.size         = 256;\n\tL2.associative  = 8;\n\tL2.linesize     = 64;\n\tbreak;\n      case 0x22 :\n\tL3.size         = 512;\n\tL3.associative  = 4;\n\tL3.linesize     = 64;\n\tbreak;\n      case 0x23 :\n\tL3.size         = 1024;\n\tL3.associative  = 8;\n\tL3.linesize     = 64;\n\tbreak;\n      case 0x25 :\n\tL3.size         = 2048;\n\tL3.associative  = 8;\n\tL3.linesize     = 64;\n\tbreak;\n      case 0x29 :\n\tL3.size         = 4096;\n\tL3.associative  = 8;\n\tL3.linesize     = 64;\n\tbreak;\n      case 0x2c :\n\tLD1.size        = 32;\n\tLD1.associative = 8;\n\tLD1.linesize    = 64;\n\tbreak;\n      case 0x30 :\n\tLC1.size        = 32;\n\tLC1.associative = 8;\n\tLC1.linesize    = 64;\n\tbreak;\n      case 0x39 :\n\tL2.size         = 128;\n\tL2.associative  = 4;\n\tL2.linesize     = 64;\n\tbreak;\n      case 0x3a :\n\tL2.size         = 192;\n\tL2.associative  = 6;\n\tL2.linesize     = 64;\n\tbreak;\n      case 0x3b :\n\tL2.size         = 128;\n\tL2.associative  = 2;\n\tL2.linesize     = 64;\n\tbreak;\n      case 0x3c :\n\tL2.size         = 256;\n\tL2.associative  = 4;\n\tL2.linesize     = 64;\n\tbreak;\n      case 0x3d :\n\tL2.size         = 384;\n\tL2.associative  = 6;\n\tL2.linesize     = 64;\n\tbreak;\n      case 0x3e :\n\tL2.size         = 512;\n\tL2.associative  = 4;\n\tL2.linesize     = 64;\n\tbreak;\n      case 0x41 :\n\tL2.size         = 128;\n\tL2.associative  = 4;\n\tL2.linesize     = 32;\n\tbreak;\n      case 0x42 :\n\tL2.size         = 256;\n\tL2.associative  = 4;\n\tL2.linesize     = 32;\n\tbreak;\n      case 0x43 :\n\tL2.size         = 512;\n\tL2.associative  = 4;\n\tL2.linesize     = 32;\n\tbreak;\n      case 0x44 :\n\tL2.size         = 1024;\n\tL2.associative  = 4;\n\tL2.linesize     = 32;\n\tbreak;\n      case 0x45 :\n\tL2.size         = 2048;\n\tL2.associative  = 4;\n\tL2.linesize     = 32;\n\tbreak;\n      case 0x46 :\n\tL3.size         = 4096;\n\tL3.associative  = 4;\n\tL3.linesize     = 64;\n\tbreak;\n      case 0x47 :\n\tL3.size         = 8192;\n\tL3.associative  = 8;\n\tL3.linesize     = 64;\n\tbreak;\n      case 0x48 :\n\tL2.size         = 3184;\n\tL2.associative  = 12;\n\tL2.linesize     = 64;\n\tbreak;\n      case 0x49 :\n\tif ((get_cputype(GET_FAMILY) == 0x0f) && (get_cputype(GET_MODEL) == 0x06)) {\n\t  L3.size         = 4096;\n\t  L3.associative  = 16;\n\t  L3.linesize     = 64;\n\t} else {\n\t  L2.size         = 4096;\n\t  L2.associative  = 16;\n\t  L2.linesize     = 64;\n\t}\n\tbreak;\n      case 0x4a :\n\tL3.size         = 6144;\n\tL3.associative  = 12;\n\tL3.linesize     = 64;\n\tbreak;\n      case 0x4b :\n\tL3.size         = 8192;\n\tL3.associative  = 16;\n\tL3.linesize     = 64;\n\tbreak;\n      case 0x4c :\n\tL3.size         = 12280;\n\tL3.associative  = 12;\n\tL3.linesize     = 64;\n\tbreak;\n      case 0x4d :\n\tL3.size         = 16384;\n\tL3.associative  = 16;\n\tL3.linesize     = 64;\n\tbreak;\n      case 0x4e :\n\tL2.size         = 6144;\n\tL2.associative  = 24;\n\tL2.linesize     = 64;\n\tbreak;\n      case 0x4f :\n\tITB.size         = 4;\n\tITB.associative  = 0;\n\tITB.linesize     = 32;\n\tbreak;\n      case 0x50 :\n\tITB.size         = 4;\n\tITB.associative  = 0;\n\tITB.linesize     = 64;\n\tLITB.size        = 4096;\n\tLITB.associative = 0;\n\tLITB.linesize    = 64;\n\tLITB.shared      = 1;\n\tbreak;\n      case 0x51 :\n\tITB.size        = 4;\n\tITB.associative = 0;\n\tITB.linesize     = 128;\n\tLITB.size        = 4096;\n\tLITB.associative = 0;\n\tLITB.linesize    = 128;\n\tLITB.shared      = 1;\n\tbreak;\n      case 0x52 :\n\tITB.size         = 4;\n\tITB.associative  = 0;\n\tITB.linesize     = 256;\n\tLITB.size        = 4096;\n\tLITB.associative = 0;\n\tLITB.linesize    = 256;\n\tLITB.shared      = 1;\n\tbreak;\n      case 0x55 :\n\tLITB.size        = 4096;\n\tLITB.associative = 0;\n\tLITB.linesize    = 7;\n\tLITB.shared      = 1;\n\tbreak;\n      case 0x56 :\n\tLDTB.size        = 4096;\n\tLDTB.associative = 4;\n\tLDTB.linesize    = 16;\n\tbreak;\n      case 0x57 :\n\tLDTB.size        = 4096;\n\tLDTB.associative = 4;\n\tLDTB.linesize    = 16;\n\tbreak;\n      case 0x5b :\n\tDTB.size         = 4;\n\tDTB.associative  = 0;\n\tDTB.linesize     = 64;\n\tLDTB.size        = 4096;\n\tLDTB.associative = 0;\n\tLDTB.linesize    = 64;\n\tLDTB.shared      = 1;\n\tbreak;\n      case 0x5c :\n\tDTB.size         = 4;\n\tDTB.associative  = 0;\n\tDTB.linesize     = 128;\n\tLDTB.size        = 4096;\n\tLDTB.associative = 0;\n\tLDTB.linesize    = 128;\n\tLDTB.shared      = 1;\n\tbreak;\n      case 0x5d :\n\tDTB.size         = 4;\n\tDTB.associative  = 0;\n\tDTB.linesize     = 256;\n\tLDTB.size        = 4096;\n\tLDTB.associative = 0;\n\tLDTB.linesize    = 256;\n\tLDTB.shared      = 1;\n\tbreak;\n      case 0x60 :\n\tLD1.size        = 16;\n\tLD1.associative = 8;\n\tLD1.linesize    = 64;\n\tbreak;\n      case 0x63 :\n  \tDTB.size        = 2048;\n  \tDTB.associative = 4;\n  \tDTB.linesize    = 32;\n  \tLDTB.size       = 4096;\n  \tLDTB.associative= 4;\n  \tLDTB.linesize   = 32;\n\tbreak;\n      case 0x66 :\n\tLD1.size        = 8;\n\tLD1.associative = 4;\n\tLD1.linesize    = 64;\n\tbreak;\n      case 0x67 :\n\tLD1.size        = 16;\n\tLD1.associative = 4;\n\tLD1.linesize    = 64;\n\tbreak;\n      case 0x68 :\n\tLD1.size        = 32;\n\tLD1.associative = 4;\n\tLD1.linesize    = 64;\n\tbreak;\n      case 0x70 :\n\tLC1.size        = 12;\n\tLC1.associative = 8;\n\tbreak;\n      case 0x71 :\n\tLC1.size        = 16;\n\tLC1.associative = 8;\n\tbreak;\n      case 0x72 :\n\tLC1.size        = 32;\n\tLC1.associative = 8;\n\tbreak;\n      case 0x73 :\n\tLC1.size        = 64;\n\tLC1.associative = 8;\n\tbreak;\n      case 0x76 :\n  \tITB.size        = 2048;\n  \tITB.associative = 0;\n  \tITB.linesize    = 8;\n  \tLITB.size       = 4096;\n  \tLITB.associative= 0;\n  \tLITB.linesize   = 8;\n\tbreak;\n      case 0x77 :\n\tLC1.size        = 16;\n\tLC1.associative = 4;\n\tLC1.linesize    = 64;\n\tbreak;\n      case 0x78 :\n\tL2.size        = 1024;\n\tL2.associative = 4;\n\tL2.linesize    = 64;\n\tbreak;\n      case 0x79 :\n\tL2.size         = 128;\n\tL2.associative  = 8;\n\tL2.linesize     = 64;\n\tbreak;\n      case 0x7a :\n\tL2.size         = 256;\n\tL2.associative  = 8;\n\tL2.linesize     = 64;\n\tbreak;\n      case 0x7b :\n\tL2.size         = 512;\n\tL2.associative  = 8;\n\tL2.linesize     = 64;\n\tbreak;\n      case 0x7c :\n\tL2.size         = 1024;\n\tL2.associative  = 8;\n\tL2.linesize     = 64;\n\tbreak;\n      case 0x7d :\n\tL2.size         = 2048;\n\tL2.associative  = 8;\n\tL2.linesize     = 64;\n\tbreak;\n      case 0x7e :\n\tL2.size         = 256;\n\tL2.associative  = 8;\n\tL2.linesize     = 128;\n\tbreak;\n      case 0x7f :\n\tL2.size         = 512;\n\tL2.associative  = 2;\n\tL2.linesize     = 64;\n\tbreak;\n      case 0x81 :\n\tL2.size         = 128;\n\tL2.associative  = 8;\n\tL2.linesize     = 32;\n\tbreak;\n      case 0x82 :\n\tL2.size         = 256;\n\tL2.associative  = 8;\n\tL2.linesize     = 32;\n\tbreak;\n      case 0x83 :\n\tL2.size         = 512;\n\tL2.associative  = 8;\n\tL2.linesize     = 32;\n\tbreak;\n      case 0x84 :\n\tL2.size         = 1024;\n\tL2.associative  = 8;\n\tL2.linesize     = 32;\n\tbreak;\n      case 0x85 :\n\tL2.size         = 2048;\n\tL2.associative  = 8;\n\tL2.linesize     = 32;\n\tbreak;\n      case 0x86 :\n\tL2.size         = 512;\n\tL2.associative  = 4;\n\tL2.linesize     = 64;\n\tbreak;\n      case 0x87 :\n\tL2.size         = 1024;\n\tL2.associative  = 8;\n\tL2.linesize     = 64;\n\tbreak;\n      case 0x88 :\n\tL3.size         = 2048;\n\tL3.associative  = 4;\n\tL3.linesize     = 64;\n\tbreak;\n      case 0x89 :\n\tL3.size         = 4096;\n\tL3.associative  = 4;\n\tL3.linesize     = 64;\n\tbreak;\n      case 0x8a :\n\tL3.size         = 8192;\n\tL3.associative  = 4;\n\tL3.linesize     = 64;\n\tbreak;\n      case 0x8d :\n\tL3.size         = 3096;\n\tL3.associative  = 12;\n\tL3.linesize     = 128;\n\tbreak;\n      case 0x90 :\n\tITB.size        = 4;\n\tITB.associative = 0;\n\tITB.linesize    = 64;\n\tbreak;\n      case 0x96 :\n\tDTB.size        = 4;\n\tDTB.associative = 0;\n\tDTB.linesize    = 32;\n\tbreak;\n      case 0x9b :\n\tL2DTB.size        = 4;\n\tL2DTB.associative = 0;\n\tL2DTB.linesize    = 96;\n\tbreak;\n      case 0xb0 :\n\tITB.size        = 4;\n\tITB.associative = 4;\n\tITB.linesize    = 128;\n\tbreak;\n      case 0xb1 :\n\tLITB.size        = 4096;\n\tLITB.associative = 4;\n\tLITB.linesize    = 4;\n\tbreak;\n      case 0xb2 :\n\tITB.size        = 4;\n\tITB.associative = 4;\n\tITB.linesize    = 64;\n\tbreak;\n      case 0xb3 :\n\tDTB.size        = 4;\n\tDTB.associative = 4;\n\tDTB.linesize    = 128;\n\tbreak;\n      case 0xb4 :\n\tDTB.size        = 4;\n\tDTB.associative = 4;\n\tDTB.linesize    = 256;\n\tbreak;\n      case 0xba :\n\tDTB.size        = 4;\n\tDTB.associative = 4;\n\tDTB.linesize    = 64;\n\tbreak;\n      case 0xd0 :\n\tL3.size         = 512;\n\tL3.associative  = 4;\n\tL3.linesize     = 64;\n\tbreak;\n      case 0xd1 :\n\tL3.size         = 1024;\n\tL3.associative  = 4;\n\tL3.linesize     = 64;\n\tbreak;\n      case 0xd2 :\n\tL3.size         = 2048;\n\tL3.associative  = 4;\n\tL3.linesize     = 64;\n\tbreak;\n      case 0xd6 :\n\tL3.size         = 1024;\n\tL3.associative  = 8;\n\tL3.linesize     = 64;\n\tbreak;\n      case 0xd7 :\n\tL3.size         = 2048;\n\tL3.associative  = 8;\n\tL3.linesize     = 64;\n\tbreak;\n      case 0xd8 :\n\tL3.size         = 4096;\n\tL3.associative  = 8;\n\tL3.linesize     = 64;\n\tbreak;\n      case 0xdc :\n\tL3.size         = 2048;\n\tL3.associative  = 12;\n\tL3.linesize     = 64;\n\tbreak;\n      case 0xdd :\n\tL3.size         = 4096;\n\tL3.associative  = 12;\n\tL3.linesize     = 64;\n\tbreak;\n      case 0xde :\n\tL3.size         = 8192;\n\tL3.associative  = 12;\n\tL3.linesize     = 64;\n\tbreak;\n      case 0xe2 :\n\tL3.size         = 2048;\n\tL3.associative  = 16;\n\tL3.linesize     = 64;\n\tbreak;\n      case 0xe3 :\n\tL3.size         = 4096;\n\tL3.associative  = 16;\n\tL3.linesize     = 64;\n\tbreak;\n      case 0xe4 :\n\tL3.size         = 8192;\n\tL3.associative  = 16;\n\tL3.linesize     = 64;\n\tbreak;\n      }\n    }\n  }\n\n  if (get_vendor() == VENDOR_INTEL) {\n      if(LD1.size<=0 || LC1.size<=0){\n\t//If we didn't detect L1 correctly before,\n\tint count;\n\tfor (count=0;count <4;count++) {\n\tcpuid_count(4, count, &eax, &ebx, &ecx, &edx);\n        switch (eax &0x1f) {\n        case 0:\n          continue;\n          case 1:\n          case 3:\n          {\n            switch ((eax >>5) &0x07)\n            {\n            case 1:\n            {\n//            fprintf(stderr,\"L1 data cache...\\n\");\n            int sets = ecx+1;\n            int lines = (ebx & 0x0fff) +1;\n            ebx>>=12;\n            int part = (ebx&0x03ff)+1;\n            ebx >>=10;\n            int assoc = (ebx&0x03ff)+1;\n            LD1.size = (assoc*part*lines*sets)/1024;\n            LD1.associative = assoc;\n            LD1.linesize= lines;\n            break;\n            }\n            default: \n              break;\n           }\n          break;\n          }\n         case 2:\n          {\n            switch ((eax >>5) &0x07)\n            {\n            case 1:\n            {\n//            fprintf(stderr,\"L1 instruction cache...\\n\");\n            int sets = ecx+1;\n            int lines = (ebx & 0x0fff) +1;\n            ebx>>=12;\n            int part = (ebx&0x03ff)+1;\n            ebx >>=10;\n            int assoc = (ebx&0x03ff)+1;\n            LC1.size = (assoc*part*lines*sets)/1024;\n            LC1.associative = assoc;\n            LC1.linesize= lines;\n            break;\n            }\n            default: \n              break;\n           }\n          break;\n          \n          }\n          default:\n          break;\n        }\n      }\n    }\n    cpuid(0x80000000, &cpuid_level, &ebx, &ecx, &edx);\n    if (cpuid_level >= 0x80000006) {\n      if(L2.size<=0){\n\t//If we didn't detect L2 correctly before,\n\tcpuid(0x80000006, &eax, &ebx, &ecx, &edx);\n\n\tL2.size         = BITMASK(ecx, 16, 0xffff);\n\tL2.associative  = BITMASK(ecx, 12, 0x0f);\n\n\tswitch (L2.associative){\n\tcase 0x06:\n\t  L2.associative = 8;\n\t  break;\n\tcase 0x08:\n\t  L2.associative = 16;\n\t  break;\n\t}\n\n\tL2.linesize     = BITMASK(ecx,  0, 0xff);\n      }\n    }\n  }\n\n  if ((get_vendor() == VENDOR_AMD) ||\n      (get_vendor() == VENDOR_HYGON) ||\n      (get_vendor() == VENDOR_CENTAUR) ||\n      (get_vendor() == VENDOR_ZHAOXIN)) {\n    cpuid(0x80000005, &eax, &ebx, &ecx, &edx);\n\n    LDTB.size        = 4096;\n    LDTB.associative = BITMASK(eax, 24, 0xff);\n    if (LDTB.associative == 0xff) LDTB.associative = 0;\n    LDTB.linesize    = BITMASK(eax, 16, 0xff);\n\n    LITB.size        = 4096;\n    LITB.associative = BITMASK(eax,  8, 0xff);\n    if (LITB.associative == 0xff) LITB.associative = 0;\n    LITB.linesize    = BITMASK(eax,  0, 0xff);\n\n    DTB.size        = 4;\n    DTB.associative = BITMASK(ebx, 24, 0xff);\n    if (DTB.associative == 0xff) DTB.associative = 0;\n    DTB.linesize    = BITMASK(ebx, 16, 0xff);\n\n    ITB.size        = 4;\n    ITB.associative = BITMASK(ebx,  8, 0xff);\n    if (ITB.associative == 0xff) ITB.associative = 0;\n    ITB.linesize    = BITMASK(ebx,  0, 0xff);\n\n    LD1.size        = BITMASK(ecx, 24, 0xff);\n    LD1.associative = BITMASK(ecx, 16, 0xff);\n    if (LD1.associative == 0xff) LD1.associative = 0;\n    LD1.linesize    = BITMASK(ecx,  0, 0xff);\n\n    LC1.size        = BITMASK(ecx, 24, 0xff);\n    LC1.associative = BITMASK(ecx, 16, 0xff);\n    if (LC1.associative == 0xff) LC1.associative = 0;\n    LC1.linesize    = BITMASK(ecx,  0, 0xff);\n\n    cpuid(0x80000006, &eax, &ebx, &ecx, &edx);\n\n    L2LDTB.size        = 4096;\n    L2LDTB.associative = BITMASK(eax, 24, 0xff);\n    if (L2LDTB.associative == 0xff) L2LDTB.associative = 0;\n    L2LDTB.linesize    = BITMASK(eax, 16, 0xff);\n\n    L2LITB.size        = 4096;\n    L2LITB.associative = BITMASK(eax,  8, 0xff);\n    if (L2LITB.associative == 0xff) L2LITB.associative = 0;\n    L2LITB.linesize    = BITMASK(eax,  0, 0xff);\n\n    L2DTB.size        = 4;\n    L2DTB.associative = BITMASK(ebx, 24, 0xff);\n    if (L2DTB.associative == 0xff) L2DTB.associative = 0;\n    L2DTB.linesize    = BITMASK(ebx, 16, 0xff);\n\n    L2ITB.size        = 4;\n    L2ITB.associative = BITMASK(ebx,  8, 0xff);\n    if (L2ITB.associative == 0xff) L2ITB.associative = 0;\n    L2ITB.linesize    = BITMASK(ebx,  0, 0xff);\n\n    if(L2.size <= 0){\n      //If we didn't detect L2 correctly before,\n      L2.size        = BITMASK(ecx, 16, 0xffff);\n      L2.associative = BITMASK(ecx, 12, 0xf);\n      switch (L2.associative){\n      case 0x06:\n\tL2.associative = 8;\n\tbreak;\n      case 0x08:\n\tL2.associative = 16;\n\tbreak;\n      }\n\n      if (L2.associative == 0xff) L2.associative = 0;\n      L2.linesize    = BITMASK(ecx,  0, 0xff);\n    }\n\n    L3.size        = BITMASK(edx, 18, 0x3fff) * 512;\n    L3.associative = BITMASK(edx, 12, 0xf);\n    if (L3.associative == 0xff) L2.associative = 0;\n    L3.linesize    = BITMASK(edx,  0, 0xff);\n\n  }\n\n    switch (type) {\n\n    case CACHE_INFO_L1_I :\n      *cacheinfo = LC1;\n      break;\n    case CACHE_INFO_L1_D :\n      *cacheinfo = LD1;\n      break;\n    case CACHE_INFO_L2 :\n      *cacheinfo = L2;\n      break;\n    case CACHE_INFO_L3 :\n      *cacheinfo = L3;\n      break;\n    case CACHE_INFO_L1_DTB :\n      *cacheinfo = DTB;\n      break;\n    case CACHE_INFO_L1_ITB :\n      *cacheinfo = ITB;\n      break;\n    case CACHE_INFO_L1_LDTB :\n      *cacheinfo = LDTB;\n      break;\n    case CACHE_INFO_L1_LITB :\n      *cacheinfo = LITB;\n      break;\n    case CACHE_INFO_L2_DTB :\n      *cacheinfo = L2DTB;\n      break;\n    case CACHE_INFO_L2_ITB :\n      *cacheinfo = L2ITB;\n      break;\n    case CACHE_INFO_L2_LDTB :\n      *cacheinfo = L2LDTB;\n      break;\n    case CACHE_INFO_L2_LITB :\n      *cacheinfo = L2LITB;\n      break;\n    }\n  return 0;\n}\n\nint get_cpuname(void){\n\n  int family, exfamily, model, vendor, exmodel, stepping;\n\n  if (!have_cpuid()) return CPUTYPE_80386;\n\n  family   = get_cputype(GET_FAMILY);\n  exfamily = get_cputype(GET_EXFAMILY);\n  model    = get_cputype(GET_MODEL);\n  exmodel  = get_cputype(GET_EXMODEL);\n  stepping = get_cputype(GET_STEPPING);\n\n  vendor = get_vendor();\n\n  if (vendor == VENDOR_INTEL){\n    switch (family) {\n    case 0x4:\n      return CPUTYPE_80486;\n    case 0x5:\n      return CPUTYPE_PENTIUM;\n    case 0x6:\n      switch (exmodel) {\n      case 0:\n\tswitch (model) {\n\tcase  1:\n\tcase  3:\n\tcase  5:\n\tcase  6:\n#if defined(__x86_64__) || defined(__amd64__)\n\t  return CPUTYPE_CORE2;\n#else\n\t  return CPUTYPE_PENTIUM2;\n#endif\n\tcase  7:\n\tcase  8:\n\tcase 10:\n\tcase 11:\n\t  return CPUTYPE_PENTIUM3;\n\tcase  9:\n\tcase 13:\n\tcase 14:\n\t  return CPUTYPE_PENTIUMM;\n\tcase 15:\n\t  return CPUTYPE_CORE2;\n\t}\n\tbreak;\n      case 1:  // family 6 exmodel 1\n\tswitch (model) {\n\tcase  6:\n\t  return CPUTYPE_CORE2;\n\tcase  7:\n\t  return CPUTYPE_PENRYN;\n\tcase 10:\n\tcase 11:\n\tcase 14:\n\tcase 15:\n\t  return CPUTYPE_NEHALEM;\n\tcase 12:\n\t  return CPUTYPE_ATOM;\n\tcase 13:\n\t  return CPUTYPE_DUNNINGTON;\n\t}\n\tbreak;\n      case  2: // family 6 exmodel 2\n\tswitch (model) {\n\tcase 5:\n\t  //Intel Core (Clarkdale) / Core (Arrandale)\n\t  // Pentium (Clarkdale) / Pentium Mobile (Arrandale)\n\t  // Xeon (Clarkdale), 32nm\n\t  return CPUTYPE_NEHALEM;\n\tcase 10:\n\t  //Intel Core i5-2000 /i7-2000 (Sandy Bridge)\n\t  if(support_avx())\n\t    return CPUTYPE_SANDYBRIDGE;\n\t  else\n\t    return CPUTYPE_NEHALEM; //OS doesn't support AVX\n\tcase 12:\n\t  //Xeon Processor 5600 (Westmere-EP)\n\t  return CPUTYPE_NEHALEM;\n\tcase 13:\n\t  //Intel Core i7-3000 / Xeon E5 (Sandy Bridge)\n\t  if(support_avx())\n\t    return CPUTYPE_SANDYBRIDGE;\n\t  else\n\t    return CPUTYPE_NEHALEM;\n\tcase 14:\n\t  // Xeon E7540\n\tcase 15:\n\t  //Xeon Processor E7 (Westmere-EX)\n\t  return CPUTYPE_NEHALEM;\n\t}\n\tbreak;\n      case 3: // family 6 exmodel 3\n\tswitch (model) {\n\tcase  7:\n\t    // Bay Trail\t\n\t    return CPUTYPE_ATOM;\t\n\tcase 10:\n        case 14:\n\t  // Ivy Bridge\n\t  if(support_avx())\n\t    return CPUTYPE_SANDYBRIDGE;\n\t  else\n\t    return CPUTYPE_NEHALEM;\n        case 12:\n\tcase 15:\n          if(support_avx2())\n            return CPUTYPE_HASWELL;\n          if(support_avx())\n\t    return CPUTYPE_SANDYBRIDGE;\n          else\n\t    return CPUTYPE_NEHALEM;\n\tcase 13:\n\t  //Broadwell\n          if(support_avx2())\n            return CPUTYPE_HASWELL;\n          if(support_avx())\n\t    return CPUTYPE_SANDYBRIDGE;\n          else\n\t    return CPUTYPE_NEHALEM;\n\t}\n\tbreak;\n      case 4: // family 6 exmodel 4\n        switch (model) {\n        case 5:\n\tcase 6:\n          if(support_avx2())\n            return CPUTYPE_HASWELL;\n          if(support_avx())\n\t    return CPUTYPE_SANDYBRIDGE;\n          else\n\t    return CPUTYPE_NEHALEM;\n\tcase 7:\n\tcase 15:\n\t  //Broadwell\n          if(support_avx2())\n            return CPUTYPE_HASWELL;\n          if(support_avx())\n\t    return CPUTYPE_SANDYBRIDGE;\n          else\n\t    return CPUTYPE_NEHALEM;\n\tcase 14:\n\t  //Skylake\n          if(support_avx2())\n            return CPUTYPE_HASWELL;\n          if(support_avx())\n\t    return CPUTYPE_SANDYBRIDGE;\n          else\n\t    return CPUTYPE_NEHALEM;\n\tcase 12:\n\t  // Braswell\n\tcase 13:\n\t  // Avoton\n\t    return CPUTYPE_NEHALEM;\n        }\n        break;\n      case 5:  // family 6 exmodel 5\n        switch (model) {\n\tcase 6:\n\t  //Broadwell\n          if(support_avx2())\n            return CPUTYPE_HASWELL;\n          if(support_avx())\n\t    return CPUTYPE_SANDYBRIDGE;\n          else\n\t    return CPUTYPE_NEHALEM;\n\tcase 5:\n\t  // Skylake X\n          if(support_avx512_bf16())\n            return CPUTYPE_COOPERLAKE;\n          if(support_avx512())\n            return CPUTYPE_SKYLAKEX;\n          if(support_avx2())\n            return CPUTYPE_HASWELL;\n          if(support_avx())\n\t    return CPUTYPE_SANDYBRIDGE;\n\t  else\n\t  return CPUTYPE_NEHALEM;\n        case 14:\n\t  // Skylake\n          if(support_avx2())\n            return CPUTYPE_HASWELL;\n          if(support_avx())\n\t    return CPUTYPE_SANDYBRIDGE;\n          else\n\t    return CPUTYPE_NEHALEM;\n\tcase 7:\n\t    // Xeon Phi Knights Landing\n          if(support_avx2())\n            return CPUTYPE_HASWELL;\n          if(support_avx())\n\t    return CPUTYPE_SANDYBRIDGE;\n          else\n\t    return CPUTYPE_NEHALEM;\n\tcase 12:\n\t    // Apollo Lake\n\tcase 15:\n\t    // Denverton\t\t\n\t    return CPUTYPE_NEHALEM;\n\t}\n\tbreak;\n      case 6:  // family 6 exmodel 6\n        switch (model) {\n        case 6: // Cannon Lake\n          if(support_avx512())\n            return CPUTYPE_SKYLAKEX;\n          if(support_avx2())\n            return CPUTYPE_HASWELL;\n          if(support_avx())\n\t    return CPUTYPE_SANDYBRIDGE;\n\t  else\n\t  return CPUTYPE_NEHALEM;\n\tcase 10: // Ice Lake SP\n\t  if(support_avx512_bf16())\n            return CPUTYPE_COOPERLAKE;\t\n          if(support_avx512())\n            return CPUTYPE_SKYLAKEX;\n          if(support_avx2())\n            return CPUTYPE_HASWELL;\n          if(support_avx())\n\t    return CPUTYPE_SANDYBRIDGE;\n\t  else\n\t  return CPUTYPE_NEHALEM;\t\n        }\n      break;\n      case 7: // family 6 exmodel 7\n        switch (model) {\n\tcase 10: // Goldmont Plus\n\t    return CPUTYPE_NEHALEM;\n        case 14: // Ice Lake\n          if(support_avx512())\n            return CPUTYPE_SKYLAKEX;\n          if(support_avx2())\n            return CPUTYPE_HASWELL;\n          if(support_avx())\n\t    return CPUTYPE_SANDYBRIDGE;\n\t  else\n\t  return CPUTYPE_NEHALEM;\n        }\n      break;\n      case 8:      \n        switch (model) {\n        case 12: // Tiger Lake\n        case 13: // Tiger Lake (11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz)\n          if(support_avx512())\n            return CPUTYPE_SKYLAKEX;\n          if(support_avx2())\n            return CPUTYPE_HASWELL;\n          if(support_avx())\n            return CPUTYPE_SANDYBRIDGE;\n          else\n          return CPUTYPE_NEHALEM;\n\tcase 14: // Kaby Lake and refreshes\n          if(support_avx2())\n            return CPUTYPE_HASWELL;\n          if(support_avx())\n\t    return CPUTYPE_SANDYBRIDGE;\n          else\n\t    return CPUTYPE_NEHALEM;\n\tcase 15: // Sapphire Rapids\n\t  if(support_amx_bf16())\n\t    return CPUTYPE_SAPPHIRERAPIDS;\n\t  if(support_avx512_bf16())\n            return CPUTYPE_COOPERLAKE;\t\n          if(support_avx512())\n            return CPUTYPE_SKYLAKEX;\n          if(support_avx2())\n            return CPUTYPE_HASWELL;\n          if(support_avx())\n\t    return CPUTYPE_SANDYBRIDGE;\n\t  else\n\t  return CPUTYPE_NEHALEM;\t\n        }\n      break;\n      case 9:\n        switch (model) {\n        case 7: // Alder Lake desktop\n        case 10: // Alder Lake mobile\n\t  if(support_avx512_bf16())\n            return CPUTYPE_COOPERLAKE;\t\n          if(support_avx512())\n            return CPUTYPE_SKYLAKEX;\n          if(support_avx2())\n            return CPUTYPE_HASWELL;\n          if(support_avx())\n            return CPUTYPE_SANDYBRIDGE;\n          else\n          return CPUTYPE_NEHALEM;\n        case 13: // Ice Lake NNPI\n          if(support_avx512())\n            return CPUTYPE_SKYLAKEX;\n          if(support_avx2())\n            return CPUTYPE_HASWELL;\n          if(support_avx())\n            return CPUTYPE_SANDYBRIDGE;\n          else\n          return CPUTYPE_NEHALEM;\n\tcase 14: // Kaby Lake and refreshes\n          if(support_avx2())\n            return CPUTYPE_HASWELL;\n          if(support_avx())\n\t    return CPUTYPE_SANDYBRIDGE;\n          else\n\t    return CPUTYPE_NEHALEM;\n        }\n      break;\n      case 10: //family 6 exmodel 10\n        switch (model) {\n\t  case 13: // Granite Rapids\n\t  if(support_amx_bf16())\n\t    return CPUTYPE_SAPPHIRERAPIDS;\n\t  if(support_avx512_bf16())\n            return CPUTYPE_COOPERLAKE;\t\n          if(support_avx512())\n            return CPUTYPE_SKYLAKEX;\n          if(support_avx2())\n            return CPUTYPE_HASWELL;\n          if(support_avx())\n            return CPUTYPE_SANDYBRIDGE;\n          else\n          return CPUTYPE_NEHALEM;\n          case 5: // Comet Lake H and S\n          case 6: // Comet Lake U\n\t  case 10: // Meteor Lake\n            if(support_avx2())\n              return CPUTYPE_HASWELL;\n            if(support_avx())\n              return CPUTYPE_SANDYBRIDGE;\n            else\n              return CPUTYPE_NEHALEM;\n\t  case 0: // Meteor Lake\n          case 7: // Rocket Lake           \n\t    if(support_avx512())\n              return CPUTYPE_SKYLAKEX;\n            if(support_avx2())\n              return CPUTYPE_HASWELL;\n            if(support_avx())\n\t      return CPUTYPE_SANDYBRIDGE;\n\t    else\n\t    return CPUTYPE_NEHALEM;\n        }\n        break;\n      case 11: //family 6 exmodel 11\n        switch (model) {\n          case 7: // Raptor Lake\n          case 10:\n          case 15:\n\t  case 14: // Alder Lake N\n            if(support_avx2())\n              return CPUTYPE_HASWELL;\n\t    if(support_avx())\n\t      return CPUTYPE_SANDYBRIDGE;\n            else\n\t      return CPUTYPE_NEHALEM;\n        }\n        break;\n      case 12: //family 6 exmodel 12\n\tswitch (model) {\n\t  case 15:\n\t    if(support_avx512())\n              return CPUTYPE_SAPPHIRERAPIDS;\n            if(support_avx2())\n              return CPUTYPE_HASWELL;\n            if(support_avx())\n\t      return CPUTYPE_SANDYBRIDGE;\n\t    else\n\t    return CPUTYPE_NEHALEM;\n\t  }\n\tbreak;\n      }\n      break;    \n    case 0x7:\n      return CPUTYPE_ITANIUM;\n    case 0xf:\n      switch (exfamily) {\n      case 0 :\n\treturn CPUTYPE_PENTIUM4;\n      case 1 :\n\treturn CPUTYPE_ITANIUM;\n      }\n      break;\n    }\n    return CPUTYPE_INTEL_UNKNOWN;\n  }\n\n  if (vendor == VENDOR_AMD){\n    switch (family) {\n    case 0x4:\n      return CPUTYPE_AMD5X86;\n    case 0x5:\n      return CPUTYPE_AMDK6;\n    case 0x6:\n#if defined(__x86_64__) || defined(__amd64__)\n      return CPUTYPE_BARCELONA;\n#else\n      return CPUTYPE_ATHLON;\n#endif\n    case 0xf:\n      switch (exfamily) {\n      case  0:\n      case  2:\n\treturn CPUTYPE_OPTERON;\n      case  1:\n      case  3:\n//      case  7:\n//      case 10:\n\treturn CPUTYPE_BARCELONA;\n      case  5:\n      case  7:\t\t      \n\treturn CPUTYPE_BOBCAT;\n      case  6:\n\tswitch (model) {\n\tcase 1:\n\t  //AMD Bulldozer Opteron 6200 / Opteron 4200 / AMD FX-Series\n\t  if(support_avx())\n\t    return CPUTYPE_BULLDOZER;\n\t  else\n\t    return CPUTYPE_BARCELONA; //OS don't support AVX.\n\tcase 2: //AMD Piledriver\n\tcase 3: //AMD Richland\n\t  if(support_avx())\n\t    return CPUTYPE_PILEDRIVER;\n\t  else\n\t    return CPUTYPE_BARCELONA; //OS don't support AVX.\n\tcase 5: // New EXCAVATOR CPUS\n\t  if(support_avx())\n\t    return CPUTYPE_EXCAVATOR;\n\t  else\n\t    return CPUTYPE_BARCELONA; //OS don't support AVX.\n\tcase 0:\n        case 8:\n\t  switch(exmodel){\n\t  case 1: //AMD Trinity\n\t    if(support_avx())\n\t      return CPUTYPE_PILEDRIVER;\n\t    else\n\t      return CPUTYPE_BARCELONA; //OS don't support AVX.\n\t  case 3:\n\t    if(support_avx())\n\t      return CPUTYPE_STEAMROLLER;\n\t    else\n\t      return CPUTYPE_BARCELONA; //OS don't support AVX.\n\n\t  case 6:\n\t    if(support_avx())\n\t      return CPUTYPE_EXCAVATOR;\n\t    else\n\t      return CPUTYPE_BARCELONA; //OS don't support AVX.\n\t  }\n\t  break;\n\t}\n\tbreak;\n      case 8:\n\tswitch (model) {\n\tcase 1:\n\t  // AMD Ryzen\n\tcase 8:\n\t  // AMD Ryzen2\n\tdefault:\n\t  // Matisse/Renoir and other recent Ryzen2\t\t\n\t  if(support_avx())\n#ifndef NO_AVX2\n\t    return CPUTYPE_ZEN;\n#else\n\t    return CPUTYPE_SANDYBRIDGE; // Zen is closer in architecture to Sandy Bridge than to Excavator\n#endif\n\t  else\n\t    return CPUTYPE_BARCELONA;\n        }\n      case 10: // Zen3/4\n      case 11: // Zen5\n#ifndef NO_AVX512\n          if(support_avx512_bf16())\n            return CPUTYPE_COOPERLAKE;\n          if(support_avx512())\n            return CPUTYPE_SKYLAKEX;\n#endif\n\tif(support_avx())\n#ifndef NO_AVX2\n\t    return CPUTYPE_ZEN;\n#else\n\t    return CPUTYPE_SANDYBRIDGE; // Zen is closer in architecture to Sandy Bridge than to Excavator\n#endif\n\t  else\n\t    return CPUTYPE_BARCELONA;\t      \n      }\n      break;\n    }\n    return CPUTYPE_AMD_UNKNOWN;\n  }\n\n  if (vendor == VENDOR_HYGON){\n    switch (family) {\n    case 0xf:\n      switch (exfamily) {\n      case 9:\n          //Hygon Dhyana\n\t  if(support_avx())\n#ifndef NO_AVX2\n\t    return CPUTYPE_ZEN;\n#else\n\t    return CPUTYPE_SANDYBRIDGE; // closer in architecture to Sandy Bridge than to Excavator\n#endif\n\t  else\n\t    return CPUTYPE_BARCELONA;\n        }\n      break;\n    }\n    return CPUTYPE_HYGON_UNKNOWN;\n  }\n\n  if (vendor == VENDOR_CYRIX){\n    switch (family) {\n    case 0x4:\n      return CPUTYPE_CYRIX5X86;\n    case 0x5:\n      return CPUTYPE_CYRIXM1;\n    case 0x6:\n      return CPUTYPE_CYRIXM2;\n    }\n    return CPUTYPE_CYRIX_UNKNOWN;\n  }\n\n  if (vendor == VENDOR_NEXGEN){\n    switch (family) {\n    case 0x5:\n      return CPUTYPE_NEXGENNX586;\n    }\n    return CPUTYPE_NEXGEN_UNKNOWN;\n  }\n\n  if (vendor == VENDOR_CENTAUR){\n    switch (family) {\n    case 0x5:\n      return CPUTYPE_CENTAURC6;\n    case 0x6:\n      if (model == 0xf && stepping < 0xe)\n        return CPUTYPE_NANO;\n      return CPUTYPE_NEHALEM;\n    case 0x7:\n      switch (exmodel) {\n      case 5:\n        if (support_avx2())\n          return CPUTYPE_ZEN;\n        else\n          return CPUTYPE_DUNNINGTON;\n      default:\n        return CPUTYPE_NEHALEM;\n      }\n    default:\n      if (family >= 0x8)\n        return CPUTYPE_NEHALEM;\n      else\n        return CPUTYPE_VIAC3;\n    }\n  }\n\n  if (vendor == VENDOR_ZHAOXIN){\n    switch (family) {\n      case 0x7:\n        switch (exmodel) {\n        case 5:\n          if (support_avx2())\n            return CPUTYPE_ZEN;\n          else\n            return CPUTYPE_DUNNINGTON;\n        default:\n          return CPUTYPE_NEHALEM;\n        }\n      default:\n        return CPUTYPE_NEHALEM;\n    }\n  }\n\n  if (vendor == VENDOR_RISE){\n    switch (family) {\n    case 0x5:\n      return CPUTYPE_RISEMP6;\n    }\n    return CPUTYPE_RISE_UNKNOWN;\n  }\n\n  if (vendor == VENDOR_SIS){\n    switch (family) {\n    case 0x5:\n      return CPUTYPE_SYS55X;\n    }\n    return CPUTYPE_SIS_UNKNOWN;\n  }\n\n  if (vendor == VENDOR_TRANSMETA){\n    switch (family) {\n    case 0x5:\n      return CPUTYPE_CRUSOETM3X;\n    }\n    return CPUTYPE_TRANSMETA_UNKNOWN;\n  }\n\n  if (vendor == VENDOR_NSC){\n    switch (family) {\n    case 0x5:\n      return CPUTYPE_NSGEODE;\n    }\n    return CPUTYPE_NSC_UNKNOWN;\n  }\n\n  return CPUTYPE_UNKNOWN;\n}\n\nstatic char *cpuname[] = {\n  \"UNKNOWN\",\n  \"INTEL_UNKNOWN\",\n  \"UMC_UNKNOWN\",\n  \"AMD_UNKNOWN\",\n  \"CYRIX_UNKNOWN\",\n  \"NEXGEN_UNKNOWN\",\n  \"CENTAUR_UNKNOWN\",\n  \"RISE_UNKNOWN\",\n  \"SIS_UNKNOWN\",\n  \"TRANSMETA_UNKNOWN\",\n  \"NSC_UNKNOWN\",\n  \"80386\",\n  \"80486\",\n  \"PENTIUM\",\n  \"PENTIUM2\",\n  \"PENTIUM3\",\n  \"PENTIUMM\",\n  \"PENTIUM4\",\n  \"CORE2\",\n  \"PENRYN\",\n  \"DUNNINGTON\",\n  \"NEHALEM\",\n  \"ATOM\",\n  \"ITANIUM\",\n  \"ITANIUM2\",\n  \"5X86\",\n  \"K6\",\n  \"ATHLON\",\n  \"DURON\",\n  \"OPTERON\",\n  \"BARCELONA\",\n  \"SHANGHAI\",\n  \"ISTANBUL\",\n  \"CYRIX5X86\",\n  \"CYRIXM1\",\n  \"CYRIXM2\",\n  \"NEXGENNX586\",\n  \"CENTAURC6\",\n  \"RISEMP6\",\n  \"SYS55X\",\n  \"TM3X00\",\n  \"NSGEODE\",\n  \"VIAC3\",\n  \"NANO\",\n  \"SANDYBRIDGE\",\n  \"BOBCAT\",\n  \"BULLDOZER\",\n  \"PILEDRIVER\",\n  \"HASWELL\",\n  \"STEAMROLLER\",\n  \"EXCAVATOR\",\n  \"ZEN\",\n  \"SKYLAKEX\",\n  \"DHYANA\",\n  \"COOPERLAKE\",\n  \"SAPPHIRERAPIDS\",\n};\n\nstatic char *lowercpuname[] = {\n  \"unknown\",\n  \"intel_unknown\",\n  \"umc_unknown\",\n  \"amd_unknown\",\n  \"cyrix_unknown\",\n  \"nexgen_unknown\",\n  \"centaur_unknown\",\n  \"rise_unknown\",\n  \"sis_unknown\",\n  \"transmeta_unknown\",\n  \"nsc_unknown\",\n  \"80386\",\n  \"80486\",\n  \"pentium\",\n  \"pentium2\",\n  \"pentium3\",\n  \"pentiumm\",\n  \"pentium4\",\n  \"core2\",\n  \"penryn\",\n  \"dunnington\",\n  \"nehalem\",\n  \"atom\",\n  \"itanium\",\n  \"itanium2\",\n  \"5x86\",\n  \"k6\",\n  \"athlon\",\n  \"duron\",\n  \"opteron\",\n  \"barcelona\",\n  \"shanghai\",\n  \"istanbul\",\n  \"cyrix5x86\",\n  \"cyrixm1\",\n  \"cyrixm2\",\n  \"nexgennx586\",\n  \"centaurc6\",\n  \"risemp6\",\n  \"sys55x\",\n  \"tms3x00\",\n  \"nsgeode\",\n  \"nano\",\n  \"sandybridge\",\n  \"bobcat\",\n  \"bulldozer\",\n  \"piledriver\",\n  \"haswell\",\n  \"steamroller\",\n  \"excavator\",\n  \"zen\",\n  \"skylakex\",\n  \"dhyana\",\n  \"cooperlake\",\n  \"sapphirerapids\",\n};\n\nstatic char *corename[] = {\n  \"UNKNOWN\",\n  \"80486\",\n  \"P5\",\n  \"P6\",\n  \"KATMAI\",\n  \"COPPERMINE\",\n  \"NORTHWOOD\",\n  \"PRESCOTT\",\n  \"BANIAS\",\n  \"ATHLON\",\n  \"OPTERON\",\n  \"BARCELONA\",\n  \"VIAC3\",\n  \"YONAH\",\n  \"CORE2\",\n  \"PENRYN\",\n  \"DUNNINGTON\",\n  \"NEHALEM\",\n  \"ATOM\",\n  \"NANO\",\n  \"SANDYBRIDGE\",\n  \"BOBCAT\",\n  \"BULLDOZER\",\n  \"PILEDRIVER\",\n  \"HASWELL\",\n  \"STEAMROLLER\",\n  \"EXCAVATOR\",\n  \"ZEN\",\n  \"SKYLAKEX\",\n  \"DHYANA\",\n  \"COOPERLAKE\",\n  \"SAPPHIRERAPIDS\",\n};\n\nstatic char *corename_lower[] = {\n  \"unknown\",\n  \"80486\",\n  \"p5\",\n  \"p6\",\n  \"katmai\",\n  \"coppermine\",\n  \"northwood\",\n  \"prescott\",\n  \"banias\",\n  \"athlon\",\n  \"opteron\",\n  \"barcelona\",\n  \"viac3\",\n  \"yonah\",\n  \"core2\",\n  \"penryn\",\n  \"dunnington\",\n  \"nehalem\",\n  \"atom\",\n  \"nano\",\n  \"sandybridge\",\n  \"bobcat\",\n  \"bulldozer\",\n  \"piledriver\",\n  \"haswell\",\n  \"steamroller\",\n  \"excavator\",\n  \"zen\",\n  \"skylakex\",\n  \"dhyana\",\n  \"cooperlake\",\n  \"sapphirerapids\",\n};\n\n\nchar *get_cpunamechar(void){\n  return cpuname[get_cpuname()];\n}\n\nchar *get_lower_cpunamechar(void){\n  return lowercpuname[get_cpuname()];\n}\n\n\nint get_coretype(void){\n\n  int family, exfamily, model, exmodel, vendor, stepping;\n\n  if (!have_cpuid()) return CORE_80486;\n\n  family   = get_cputype(GET_FAMILY);\n  exfamily = get_cputype(GET_EXFAMILY);\n  model    = get_cputype(GET_MODEL);\n  exmodel  = get_cputype(GET_EXMODEL);\n  stepping = get_cputype(GET_STEPPING);\n\n  vendor = get_vendor();\n\n  if (vendor == VENDOR_INTEL){\n    switch (family) {\n    case  4:\n      return CORE_80486;\n    case  5:\n      return CORE_P5;\n    case  6:\n      switch (exmodel) {\n      case  0:\n\tswitch (model) {\n\tcase  0:\n\tcase  1:\n\tcase  2:\n\tcase  3:\n\tcase  4:\n\tcase  5:\n\tcase  6:\n#if defined(__x86_64__) || defined(__amd64__)\n\t  return CORE_CORE2;\n#else\n\t  return CORE_P6;\n#endif\n\tcase  7:\n\t  return CORE_KATMAI;\n\tcase  8:\n\tcase 10:\n\tcase 11:\n\t  return CORE_COPPERMINE;\n\tcase  9:\n\tcase 13:\n\tcase 14:\n\t  return CORE_BANIAS;\n\tcase 15:\n\t  return CORE_CORE2;\n\t}\n\tbreak;\n      case  1:\n\tswitch (model) {\n\tcase  6:\n\t  return CORE_CORE2;\n\tcase  7:\n\t  return CORE_PENRYN;\n\tcase 10:\n\tcase 11:\n\tcase 14:\n\tcase 15:\n\t  return CORE_NEHALEM;\n\tcase 12:\n\t  return CORE_ATOM;\n\tcase 13:\n\t  return CORE_DUNNINGTON;\n\t}\n\tbreak;\n      case  2:\n\tswitch (model) {\n\tcase 5:\n\t  //Intel Core (Clarkdale) / Core (Arrandale)\n\t  // Pentium (Clarkdale) / Pentium Mobile (Arrandale)\n\t  // Xeon (Clarkdale), 32nm\n\t  return CORE_NEHALEM;\n\tcase 10:\n          //Intel Core i5-2000 /i7-2000 (Sandy Bridge)\n\t  if(support_avx())\n\t    return CORE_SANDYBRIDGE;\n\t  else\n\t    return CORE_NEHALEM; //OS doesn't support AVX\n\tcase 12:\n\t  //Xeon Processor 5600 (Westmere-EP)\n\t  return CORE_NEHALEM;\n\tcase 13:\n          //Intel Core i7-3000 / Xeon E5 (Sandy Bridge)\n\t  if(support_avx())\n\t    return CORE_SANDYBRIDGE;\n\t  else\n\t    return CORE_NEHALEM; //OS doesn't support AVX\n\tcase 14:\n\t  //Xeon E7540\n\tcase 15:\n\t  //Xeon Processor E7 (Westmere-EX)\n\t  return CORE_NEHALEM;\n\t}\n\tbreak;\n      case 3:\n\tswitch (model) {\n\tcase 7:\n\t  return CORE_ATOM;\t\t\n\tcase 10:\n\tcase 14:\n\t  if(support_avx())\n\t    return CORE_SANDYBRIDGE;\n\t  else\n\t    return CORE_NEHALEM; //OS doesn't support AVX\n        case 12:\n\tcase 15:\n          if(support_avx())\n#ifndef NO_AVX2\n            return CORE_HASWELL;\n#else\n\t    return CORE_SANDYBRIDGE;\n#endif\n          else\n\t    return CORE_NEHALEM;\n\tcase 13:\n\t  //broadwell\n          if(support_avx())\n#ifndef NO_AVX2\n            return CORE_HASWELL;\n#else\n\t    return CORE_SANDYBRIDGE;\n#endif\n          else\n\t    return CORE_NEHALEM;\n\t}\n\tbreak;\n      case 4:\n        switch (model) {\n        case 5:\n\tcase 6:\n          if(support_avx())\n#ifndef NO_AVX2\n            return CORE_HASWELL;\n#else\n\t    return CORE_SANDYBRIDGE;\n#endif\n          else\n\t    return CORE_NEHALEM;\n\tcase 7:\n\tcase 15:\n\t  //broadwell\n          if(support_avx())\n#ifndef NO_AVX2\n            return CORE_HASWELL;\n#else\n\t    return CORE_SANDYBRIDGE;\n#endif\n          else\n\t    return CORE_NEHALEM;\n\tcase 14:\n\t  //Skylake\n          if(support_avx())\n#ifndef NO_AVX2\n            return CORE_HASWELL;\n#else\n\t    return CORE_SANDYBRIDGE;\n#endif\n          else\n\t    return CORE_NEHALEM;\n\tcase 12:\n\t  // Braswell\n\tcase 13:\n\t  // Avoton\n\t    return CORE_NEHALEM;\n        }\n        break;\n\n      case 5:\n        switch (model) {\n\tcase 6:\n\t  //broadwell\n          if(support_avx())\n#ifndef NO_AVX2\n            return CORE_HASWELL;\n#else\n\t    return CORE_SANDYBRIDGE;\n#endif\n          else\n\t    return CORE_NEHALEM;\n\tcase 5:\n\t // Skylake X\n#ifndef NO_AVX512\n          if(support_avx512_bf16())\n            return CORE_COOPERLAKE;\n\t  return CORE_SKYLAKEX;\n#else\n\t  if(support_avx())\n#ifndef NO_AVX2\n\t    return CORE_HASWELL;\n#else\n\t    return CORE_SANDYBRIDGE;\n#endif\n\t  else\n\t    return CORE_NEHALEM;\n#endif\t\t\t\n\tcase 14:\n\t  // Skylake\n          if(support_avx())\n#ifndef NO_AVX2\n            return CORE_HASWELL;\n#else\n\t    return CORE_SANDYBRIDGE;\n#endif\n          else\n\t    return CORE_NEHALEM;\n\tcase 7:\n\t  // Phi Knights Landing\n          if(support_avx())\n#ifndef NO_AVX2\n            return CORE_HASWELL;\n#else\n\t    return CORE_SANDYBRIDGE;\n#endif\n          else\n\t    return CORE_NEHALEM;\n\tcase 12:\n\t  // Apollo Lake\n\t    return CORE_NEHALEM;\n        }\n\tbreak;\n\n      case 6:\n        if (model == 6)\n#ifndef NO_AVX512\n\t    return CORE_SKYLAKEX;\n#else\n\t  if(support_avx())\n#ifndef NO_AVX2\n\t    return CORE_HASWELL;\n#else\n\t    return CORE_SANDYBRIDGE;\n#endif\n\t  else\n\t    return CORE_NEHALEM;\n#endif\n\tif (model == 10 || model == 12)\n#ifndef NO_AVX512\n\t  if(support_avx512_bf16())\n            return CORE_COOPERLAKE;\n\t  return CORE_SKYLAKEX;\n#else\n\t  if(support_avx())\n#ifndef NO_AVX2\n\t    return CORE_HASWELL;\n#else\n\t    return CORE_SANDYBRIDGE;\n#endif\n\t  else\n\t    return CORE_NEHALEM;\n#endif\t\n\n      case 7:\n        if (model == 10) \n            return CORE_NEHALEM;\n        if (model == 13 || model == 14) // Ice Lake\n#ifndef NO_AVX512\n\t    return CORE_SKYLAKEX;\n#else\n\t  if(support_avx())\n#ifndef NO_AVX2\n\t    return CORE_HASWELL;\n#else\n\t    return CORE_SANDYBRIDGE;\n#endif\n\t  else\n\t    return CORE_NEHALEM;\n#endif\t\t\t\n        break;    \t\n\n      case 8:\n        if (model == 12 || model == 13) { // Tiger Lake\n          if(support_avx512())\n            return CORE_SKYLAKEX;\n          if(support_avx2())\n            return CORE_HASWELL;\n          if(support_avx())\n            return CORE_SANDYBRIDGE;\n          else\n          return CORE_NEHALEM;\n        }\n        if (model == 14) { // Kaby Lake mobile\n\t  if(support_avx())\n#ifndef NO_AVX2\n\t    return CORE_HASWELL;\n#else\n\t    return CORE_SANDYBRIDGE;\n#endif\n\t  else\n            return CORE_NEHALEM;\n\t}\n        if (model == 15) { // Sapphire Rapids\n\t  if(support_amx_bf16())\n\t    return CORE_SAPPHIRERAPIDS;\n\t  if(support_avx512_bf16())\n            return CORE_COOPERLAKE;\t\n          if(support_avx512())\n            return CORE_SKYLAKEX;\n          if(support_avx2())\n            return CORE_HASWELL;\n          if(support_avx())\n\t    return CORE_SANDYBRIDGE;\n\t  else\n\t  return CORE_NEHALEM;\n        }\n      break;\n\n      case 9:\n        if (model == 7 || model == 10) { // Alder Lake\n          if(support_avx2())\n            return CORE_HASWELL;\n          if(support_avx())\n            return CORE_SANDYBRIDGE;\n          else\n          return CORE_NEHALEM;\n        }\n        if (model == 13) { // Ice Lake NNPI\n          if(support_avx512())\n            return CORE_SKYLAKEX;\n          if(support_avx2())\n            return CORE_HASWELL;\n          if(support_avx())\n            return CORE_SANDYBRIDGE;\n          else\n          return CORE_NEHALEM;\n        }\n        if (model == 14) { // Kaby Lake desktop\n\t  if(support_avx())\n#ifndef NO_AVX2\n\t    return CORE_HASWELL;\n#else\n\t    return CORE_SANDYBRIDGE;\n#endif\n\t  else\n            return CORE_NEHALEM;\n\t}\n      break;\n\n      case 10:\n        switch (model) {\n\t  case 13: // Granite Rapids\n\t  if(support_amx_bf16())\n\t    return CORE_SAPPHIRERAPIDS;\n\t  if(support_avx512_bf16())\n            return CORE_COOPERLAKE;\t\n          if(support_avx512())\n            return CORE_SKYLAKEX;\n          if(support_avx2())\n            return CORE_HASWELL;\n          if(support_avx())\n\t    return CORE_SANDYBRIDGE;\n\t  else\n\t    return CORE_NEHALEM;\n\t  case 5: // Comet Lake H and S\n    \t  case 6: // Comet Lake U\n\t  case 10: // Meteor Lake\n            if(support_avx())\n  #ifndef NO_AVX2\n              return CORE_HASWELL;\n  #else\n              return CORE_SANDYBRIDGE;\n  #endif\n            else\n              return CORE_NEHALEM;\n\t  case 0: // Meteor Lake\n\t  case 7:// Rocket Lake\n#ifndef NO_AVX512\n\t  if(support_avx512())\n            return CORE_SKYLAKEX;\n#endif\n#ifndef NO_AVX2\n\t  if(support_avx2())\n            return CORE_HASWELL;\n#endif\n\t  if(support_avx())\n\t    return CORE_SANDYBRIDGE;\n\t  else\n\t  return CORE_NEHALEM;\n        }\n\n      case 11:\n\tswitch (model) {\n\t  case 7: // Raptor Lake\n          case 10:\n          case 15:\n\t  case 14: // Alder Lake N\t  \n#ifndef NO_AVX2\n\t  if(support_avx2())\n            return CORE_HASWELL;\n#endif\n\t  if(support_avx())\n\t    return CORE_SANDYBRIDGE;\n\t  else\n\t  return CORE_NEHALEM;\n\t}\n      }\n    case 15:\n      if (model <= 0x2) return CORE_NORTHWOOD;\n      else return CORE_PRESCOTT;\n    }\n  }\n\n  if (vendor == VENDOR_AMD){\n    if (family <= 0x5) return CORE_80486;\n#if defined(__x86_64__) || defined(__amd64__)\n    if (family <= 0xe) return CORE_BARCELONA;\n#else\n    if (family <= 0xe) return CORE_ATHLON;\n#endif\n    if (family == 0xf){\n      if ((exfamily == 0) || (exfamily == 2)) return CORE_OPTERON;\n      else if (exfamily == 5) return CORE_BOBCAT;\n      else if (exfamily == 6) {\n\tswitch (model) {\n\tcase 1:\n\t  //AMD Bulldozer Opteron 6200 / Opteron 4200 / AMD FX-Series\n\t  if(support_avx())\n\t    return CORE_BULLDOZER;\n\t  else\n\t    return CORE_BARCELONA; //OS don't support AVX.\n\tcase 2: //AMD Piledriver\n\tcase 3: //AMD Richland\n\t  if(support_avx())\n\t    return CORE_PILEDRIVER;\n\t  else\n\t    return CORE_BARCELONA; //OS don't support AVX.\n        case 5: // New EXCAVATOR\n\t  if(support_avx())\n\t    return CORE_EXCAVATOR;\n\t  else\n\t    return CORE_BARCELONA; //OS don't support AVX.\n\tcase 0:\n        case 8:\n\t  switch(exmodel){\n\t  case 1: //AMD Trinity\n\t    if(support_avx())\n\t      return CORE_PILEDRIVER;\n\t    else\n\t      return CORE_BARCELONA; //OS don't support AVX.\n\n\t  case 3:\n\t    if(support_avx())\n\t      return CORE_STEAMROLLER;\n\t    else\n\t      return CORE_BARCELONA; //OS don't support AVX.\n\n\t  case 6:\n\t    if(support_avx())\n\t      return CORE_EXCAVATOR;\n\t    else\n\t      return CORE_BARCELONA; //OS don't support AVX.\n\t  }\n\t  break;\n\t}\n      } else if (exfamily == 8 || exfamily == 10 || exfamily == 11) {\n\tswitch (model) {\n\tcase 1:\n\t  // AMD Ryzen\n\tcase 8:\n\t  // Ryzen 2\n\tdefault:\n\t  // Matisse,Renoir Ryzen2 models\t\t\n#ifndef NO_AVX512\n          if(support_avx512_bf16())\n            return CORE_COOPERLAKE;\n          if(support_avx512())\n            return CORE_SKYLAKEX;\n#endif\n\t  if(support_avx())\n#ifndef NO_AVX2\n\t    return CORE_ZEN;\n#else\n\t    return CORE_SANDYBRIDGE; // Zen is closer in architecture to Sandy Bridge than to Excavator\n#endif\n\t  else\n\t    return CORE_BARCELONA;\n\t}\n      } else {\n\treturn CORE_BARCELONA;\n      }\n    }\n  }\n\n  if (vendor == VENDOR_HYGON){\n    if (family == 0xf){\n        if (exfamily == 9) {\n\t  if(support_avx())\n#ifndef NO_AVX2\n\t    return CORE_ZEN;\n#else\n\t    return CORE_SANDYBRIDGE; // closer in architecture to Sandy Bridge than to Excavator\n#endif\n\t  else\n\t    return CORE_BARCELONA;\n\t} else {\n\t\treturn CORE_BARCELONA;\n\t}\n    }\n  }\n\n  if (vendor == VENDOR_CENTAUR) {\n    switch (family) {\n    case 0x6:\n      if (model == 0xf && stepping < 0xe)\n        return CORE_NANO;\n      return CORE_NEHALEM;\n    case 0x7:\n      switch (exmodel) {\n      case 5:\n        if (support_avx2())\n          return CORE_ZEN;\n        else\n          return CORE_DUNNINGTON;\n      default:\n        return CORE_NEHALEM;\n      }\n    default:\n      if (family >= 0x8)\n        return CORE_NEHALEM;\n      else\n        return CORE_VIAC3;\n    }\n  }\n\n  if (vendor == VENDOR_ZHAOXIN) {\n    switch (family) {\n      case 0x7:\n        switch (exmodel) {\n        case 5:\n\tcase 6:\n          if (support_avx2())\n            return CORE_ZEN;\n          else\n            return CORE_DUNNINGTON;\n        default:\n          return CORE_NEHALEM;\n        }\n      default:\n        return CORE_NEHALEM;\n    }\n  }\n\n  return CORE_UNKNOWN;\n}\n\nvoid get_cpuconfig(void){\n\n  cache_info_t info;\n  int features;\n\n  printf(\"#define %s\\n\", cpuname[get_cpuname()]);\n\n\n  if (get_coretype() != CORE_P5) {\n\n    get_cacheinfo(CACHE_INFO_L1_I, &info);\n    if (info.size > 0) {\n      printf(\"#define L1_CODE_SIZE %d\\n\", info.size * 1024);\n      printf(\"#define L1_CODE_ASSOCIATIVE %d\\n\", info.associative);\n      printf(\"#define L1_CODE_LINESIZE %d\\n\", info.linesize);\n    }\n\n    get_cacheinfo(CACHE_INFO_L1_D, &info);\n    if (info.size > 0) {\n      printf(\"#define L1_DATA_SIZE %d\\n\", info.size * 1024);\n      printf(\"#define L1_DATA_ASSOCIATIVE %d\\n\", info.associative);\n      printf(\"#define L1_DATA_LINESIZE %d\\n\", info.linesize);\n    }\n\n    get_cacheinfo(CACHE_INFO_L2, &info);\n    if (info.size > 0) {\n      printf(\"#define L2_SIZE %d\\n\", info.size * 1024);\n      printf(\"#define L2_ASSOCIATIVE %d\\n\", info.associative);\n      printf(\"#define L2_LINESIZE %d\\n\", info.linesize);\n    } else {\n      //fall back for some virtual machines.\n      printf(\"#define L2_SIZE 1048576\\n\");\n      printf(\"#define L2_ASSOCIATIVE 6\\n\");\n      printf(\"#define L2_LINESIZE 64\\n\");\n    }\n\n\n    get_cacheinfo(CACHE_INFO_L3, &info);\n    if (info.size > 0) {\n      printf(\"#define L3_SIZE %d\\n\", info.size * 1024);\n      printf(\"#define L3_ASSOCIATIVE %d\\n\", info.associative);\n      printf(\"#define L3_LINESIZE %d\\n\", info.linesize);\n    }\n\n    get_cacheinfo(CACHE_INFO_L1_ITB, &info);\n    if (info.size > 0) {\n      printf(\"#define ITB_SIZE %d\\n\", info.size * 1024);\n      printf(\"#define ITB_ASSOCIATIVE %d\\n\", info.associative);\n      printf(\"#define ITB_ENTRIES %d\\n\", info.linesize);\n    }\n\n    get_cacheinfo(CACHE_INFO_L1_DTB, &info);\n    if (info.size > 0) {\n      printf(\"#define DTB_SIZE %d\\n\", info.size * 1024);\n      printf(\"#define DTB_ASSOCIATIVE %d\\n\", info.associative);\n      printf(\"#define DTB_DEFAULT_ENTRIES %d\\n\", info.linesize);\n    } else {\n      //fall back for some virtual machines.\n      printf(\"#define DTB_DEFAULT_ENTRIES 32\\n\");\n    }\n\n    features = get_cputype(GET_FEATURE);\n\n    if (features & HAVE_CMOV )   printf(\"#define HAVE_CMOV\\n\");\n    if (features & HAVE_MMX  )   printf(\"#define HAVE_MMX\\n\");\n    if (features & HAVE_SSE  )   printf(\"#define HAVE_SSE\\n\");\n    if (features & HAVE_SSE2 )   printf(\"#define HAVE_SSE2\\n\");\n    if (features & HAVE_SSE3 )   printf(\"#define HAVE_SSE3\\n\");\n    if (features & HAVE_SSSE3)   printf(\"#define HAVE_SSSE3\\n\");\n    if (features & HAVE_SSE4_1)   printf(\"#define HAVE_SSE4_1\\n\");\n    if (features & HAVE_SSE4_2)   printf(\"#define HAVE_SSE4_2\\n\");\n    if (features & HAVE_SSE4A)   printf(\"#define HAVE_SSE4A\\n\");\n    if (features & HAVE_SSE5 )   printf(\"#define HAVE_SSSE5\\n\");\n    if (features & HAVE_AVX )    printf(\"#define HAVE_AVX\\n\");\n    if (features & HAVE_AVX2 )    printf(\"#define HAVE_AVX2\\n\");\n    if (features & HAVE_AVX512VL )    printf(\"#define HAVE_AVX512VL\\n\");\n    if (features & HAVE_AVX512BF16 )    printf(\"#define HAVE_AVX512BF16\\n\");\n    if (features & HAVE_AMXBF16 )    printf(\"#define HAVE_AMXBF16\\n\");\n    if (features & HAVE_3DNOWEX) printf(\"#define HAVE_3DNOWEX\\n\");\n    if (features & HAVE_3DNOW)   printf(\"#define HAVE_3DNOW\\n\");\n    if (features & HAVE_FMA4 )    printf(\"#define HAVE_FMA4\\n\");\n    if (features & HAVE_FMA3 )    printf(\"#define HAVE_FMA3\\n\");\n    if (features & HAVE_CFLUSH)  printf(\"#define HAVE_CFLUSH\\n\");\n    if (features & HAVE_HIT)     printf(\"#define HAVE_HIT 1\\n\");\n    if (features & HAVE_MISALIGNSSE) printf(\"#define HAVE_MISALIGNSSE\\n\");\n    if (features & HAVE_128BITFPU)   printf(\"#define HAVE_128BITFPU\\n\");\n    if (features & HAVE_FASTMOVU)    printf(\"#define HAVE_FASTMOVU\\n\");\n\n    printf(\"#define NUM_SHAREDCACHE %d\\n\", get_cputype(GET_NUMSHARE) + 1);\n    printf(\"#define NUM_CORES %d\\n\", get_cputype(GET_NUMCORES) + 1);\n\n    features = get_coretype();\n    if (features > 0) printf(\"#define CORE_%s\\n\", corename[features]);\n  } else {\n    printf(\"#define DTB_DEFAULT_ENTRIES 16\\n\");\n    printf(\"#define L1_CODE_SIZE 8192\\n\");\n    printf(\"#define L1_DATA_SIZE 8192\\n\");\n    printf(\"#define L2_SIZE 0\\n\");\n  }\n}\n\nvoid get_architecture(void){\n#ifndef __64BIT__\n    printf(\"X86\");\n#else\n    printf(\"X86_64\");\n#endif\n}\n\nvoid get_subarchitecture(void){\n    printf(\"%s\", get_cpunamechar());\n}\n\nvoid get_subdirname(void){\n#ifndef __64BIT__\n    printf(\"x86\");\n#else\n    printf(\"x86_64\");\n#endif\n}\n\nchar *get_corename(void){\n  return corename[get_coretype()];\n}\n\nvoid get_libname(void){\n  printf(\"%s\",   corename_lower[get_coretype()]);\n}\n\n/* This if for Makefile */\nvoid get_sse(void){\n\n  int features;\n\n  features = get_cputype(GET_FEATURE);\n\n  if (features & HAVE_MMX  )   printf(\"HAVE_MMX=1\\n\");\n  if (features & HAVE_SSE  )   printf(\"HAVE_SSE=1\\n\");\n  if (features & HAVE_SSE2 )   printf(\"HAVE_SSE2=1\\n\");\n  if (features & HAVE_SSE3 )   printf(\"HAVE_SSE3=1\\n\");\n  if (features & HAVE_SSSE3)   printf(\"HAVE_SSSE3=1\\n\");\n  if (features & HAVE_SSE4_1)   printf(\"HAVE_SSE4_1=1\\n\");\n  if (features & HAVE_SSE4_2)   printf(\"HAVE_SSE4_2=1\\n\");\n  if (features & HAVE_SSE4A)   printf(\"HAVE_SSE4A=1\\n\");\n  if (features & HAVE_SSE5 )   printf(\"HAVE_SSSE5=1\\n\");\n  if (features & HAVE_AVX )    printf(\"HAVE_AVX=1\\n\");\n  if (features & HAVE_AVX2 )    printf(\"HAVE_AVX2=1\\n\");\n  if (features & HAVE_AVX512VL )    printf(\"HAVE_AVX512VL=1\\n\");\n  if (features & HAVE_AVX512BF16 )    printf(\"HAVE_AVX512BF16=1\\n\");\n  if (features & HAVE_AMXBF16 )    printf(\"HAVE_AMXBF16=1\\n\");\n  if (features & HAVE_3DNOWEX) printf(\"HAVE_3DNOWEX=1\\n\");\n  if (features & HAVE_3DNOW)   printf(\"HAVE_3DNOW=1\\n\");\n  if (features & HAVE_FMA4 )    printf(\"HAVE_FMA4=1\\n\");\n  if (features & HAVE_FMA3 )    printf(\"HAVE_FMA3=1\\n\");\n\n}\n//}\n"
        },
        {
          "name": "cpuid_zarch.c",
          "type": "blob",
          "size": 2.669921875,
          "content": "/**************************************************************************\n  Copyright (c) 2016, The OpenBLAS Project\n  All rights reserved.\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are\n  met:\n  1. Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the following disclaimer.\n  2. Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the following disclaimer in\n  the documentation and/or other materials provided with the\n  distribution.\n  3. Neither the name of the OpenBLAS project nor the names of\n  its contributors may be used to endorse or promote products\n  derived from this software without specific prior written permission.\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL THE OPENBLAS PROJECT OR CONTRIBUTORS BE\n  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\n  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n  *****************************************************************************/\n\n#include <string.h>\n\n#include \"cpuid_zarch.h\"\n\n\nvoid get_libname(void)\n{\n\tint d = detect();\n\tprintf(\"%s\", cpuname_lower[d]);\n}\n\nchar *get_corename(void)\n{\n\treturn cpuname[detect()];\n}\n\nvoid get_architecture(void)\n{\n\tprintf(\"ZARCH\");\n}\n\nvoid get_subarchitecture(void)\n{\n\tint d = detect();\n\tprintf(\"%s\", cpuname[d]);\n}\n\nvoid get_subdirname(void)\n{\n\tprintf(\"zarch\");\n}\n\n\nvoid get_cpuconfig(void)\n{\n\n\tint d = detect();\n\tswitch (d){\n\tcase CPU_GENERIC:\n\t  printf(\"#define ZARCH_GENERIC\\n\");\n \t  printf(\"#define DTB_DEFAULT_ENTRIES 64\\n\");\n\t  break;\n\tcase CPU_Z13:\n\t  printf(\"#define Z13\\n\");\n\t  printf(\"#define DTB_DEFAULT_ENTRIES 64\\n\");\n\t  break;\n\tcase CPU_Z14:\n\t  printf(\"#define Z14\\n\");\n\t  printf(\"#define L1_DATA_SIZE 131072\\n\");\n\t  printf(\"#define L1_DATA_LINESIZE 256\\n\");\n\t  printf(\"#define L1_DATA_ASSOCIATIVE 8\\n\");\n\t  printf(\"#define L2_SIZE 4194304\\n\");\n\t  printf(\"#define L2_LINESIZE 256\\n\");\n\t  printf(\"#define L2_ASSOCIATIVE 8\\n\");\n\t  printf(\"#define DTB_DEFAULT_ENTRIES 64\\n\");\n\t  printf(\"#define DTB_SIZE 4096\\n\");\n\t  break;\n\t}\n}\n"
        },
        {
          "name": "cpuid_zarch.h",
          "type": "blob",
          "size": 3.1650390625,
          "content": "#include <stdlib.h>\n\n#define CPU_GENERIC     0\n#define CPU_Z13         1\n#define CPU_Z14         2\n#define CPU_Z15         3\n\nstatic char *cpuname[] = {\n  \"ZARCH_GENERIC\",\n  \"Z13\",\n  \"Z14\",\n  \"Z15\"\n};\n\nstatic char *cpuname_lower[] = {\n  \"zarch_generic\",\n  \"z13\",\n  \"z14\",\n  \"z15\"\n};\n\n// Guard the use of getauxval() on glibc version >= 2.16\n#ifdef __GLIBC__\n#include <features.h>\n#if __GLIBC_PREREQ(2, 16)\n#include <sys/auxv.h>\n#define HAVE_GETAUXVAL 1\n\nstatic unsigned long get_hwcap(void)\n{\n\tunsigned long hwcap = getauxval(AT_HWCAP);\n\tchar *maskenv;\n\n\t// honor requests for not using specific CPU features in LD_HWCAP_MASK\n\tmaskenv = getenv(\"LD_HWCAP_MASK\");\n\tif (maskenv)\n\t\thwcap &= strtoul(maskenv, NULL, 0);\n\n\treturn hwcap;\n\t// note that a missing auxval is interpreted as no capabilities\n\t// available, which is safe.\n}\n\n#else // __GLIBC_PREREQ(2, 16)\n#warn \"Cannot detect SIMD support in Z13 or newer architectures since glibc is older than 2.16\"\n\nstatic unsigned long get_hwcap(void) {\n\t// treat missing support for getauxval() as no capabilities available,\n\t// which is safe.\n\treturn 0;\n}\n#endif // __GLIBC_PREREQ(2, 16)\n#endif // __GLIBC\n\nstatic int detect(void)\n{\n\tunsigned long hwcap = get_hwcap();\n\n\t// Choose the architecture level for optimized kernels based on hardware\n\t// capability bits (just like glibc chooses optimized implementations).\n\t//\n\t// The hardware capability bits that are used here indicate both\n\t// hardware support for a particular ISA extension and the presence of\n\t// software support to enable its use. For example, when HWCAP_S390_VX\n\t// is set then both the CPU can execute SIMD instructions and the Linux\n\t// kernel can manage applications using the vector registers and SIMD\n\t// instructions.\n\t//\n\t// See glibc's sysdeps/s390/dl-procinfo.h for an overview (also in\n\t// sysdeps/unix/sysv/linux/s390/bits/hwcap.h) of the defined hardware\n\t// capability bits. They are derived from the information that the\n\t// \"store facility list (extended)\" instructions provide.\n\t// (https://sourceware.org/git/?p=glibc.git;a=blob_plain;f=sysdeps/s390/dl-procinfo.h;hb=HEAD)\n\t//\n\t// currently used:\n\t// HWCAP_S390_VX - vector facility for z/Architecture (introduced with\n\t//                 IBM z13), enables level CPU_Z13 (SIMD)\n\t// HWCAP_S390_VXE - vector enhancements facility 1 (introduced with IBM\n\t//                  z14), together with VX enables level CPU_Z14\n\t//                  (single-precision SIMD instructions)\n\t//\n\t// When you add optimized kernels that make use of other ISA extensions\n\t// (e.g., for exploiting the vector-enhancements facility 2 that was introduced\n\t// with IBM z15), then add a new architecture level (e.g., CPU_Z15) and gate\n\t// it on the hwcap that represents it here (e.g., HWCAP_S390_VXRS_EXT2\n\t// for the z15 vector enhancements).\n\t//\n\t// To learn the value of hwcaps on a given system, set the environment\n\t// variable LD_SHOW_AUXV and let ld.so dump it (e.g., by running\n\t// LD_SHOW_AUXV=1 /bin/true).\n\t// Also, the init function for dynamic arch support will print hwcaps\n\t// when OPENBLAS_VERBOSE is set to 2 or higher.\n\tif ((hwcap & HWCAP_S390_VX) && (hwcap & HWCAP_S390_VXE))\n\t\treturn CPU_Z14;\n\n\tif (hwcap & HWCAP_S390_VX)\n\t\treturn CPU_Z13;\n\n\treturn CPU_GENERIC;\n}\n\n"
        },
        {
          "name": "ctest.c",
          "type": "blob",
          "size": 2.66796875,
          "content": "//LSB (Linux Standard Base) compiler\n//only support lsbc++\n#if defined (__LSB_VERSION__)\n#if !defined (__cplusplus)\nCOMPILER_LSB\n#else\n#error \"OpenBLAS only supports lsbcc.\"\n#endif\n#endif\n\n#if defined(__clang__)\nCOMPILER_CLANG\n#endif\n\n#if defined(__PGI) || defined(__PGIC__)\nCOMPILER_PGI\n#endif\n\n#if defined(__PATHSCALE__) || defined(__PATHCC__)\nCOMPILER_PATHSCALE\n#endif\n\n#if defined(__INTEL_COMPILER) || defined(__ICC) || defined(__ECC)\nCOMPILER_INTEL\n#endif\n\n#if defined(__OPENCC__)\nCOMPILER_OPEN64\n#endif\n\n#if defined(__SUNPRO_C)\nCOMPILER_SUN\n#endif\n\n#if defined(__IBMC__) || defined(__xlc__)\nCOMPILER_IBM\n#endif\n\n#if defined(__DECCC__)\nCOMPILER_DEC\n#endif\n\n#if defined(__GNUC__)\nCOMPILER_GNU\n#endif\n\n#if defined(__fcc_version__) || defined(__FCC_version__)\nCOMPILER_FUJITSU\n#endif\n\n#if defined(__ANDROID__)\nOS_ANDROID\n#endif\n\n#if defined(__linux__)\nOS_LINUX\n#endif\n\n#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)\nOS_FREEBSD\n#endif\n\n#if defined(__NetBSD__)\nOS_NETBSD\n#endif\n\n#if defined(__OpenBSD__)\nOS_OPENBSD\n#endif\n\n#if defined(__DragonFly__)\nOS_DRAGONFLY\n#endif\n\n#if defined(__sun)\nOS_SUNOS\n#endif\n\n#if defined(__APPLE__)\nOS_DARWIN\n#endif\n\n#if defined(_AIX)\nOS_AIX\n#endif\n\n#if defined(__OSF)\nOS_OSF\n#endif\n\n#if defined(__WIN32) || defined(__WIN64) || defined(_WIN32) || defined(_WIN64) || defined(__WINNT)\nOS_WINNT\n#endif\n\n#if defined(__CYGWIN__)\nOS_CYGWIN_NT\n#endif\n\n#if defined(__INTERIX)\nOS_INTERIX\n#endif\n\n#if defined(__gnu_hurd__)\n/* Hurd is very similar to GNU/Linux, it should work out of the box */\nOS_LINUX\n#endif\n\n#if defined(__HAIKU__)\nOS_HAIKU\n#endif\n\n#if defined(__i386) || defined(_X86)\nARCH_X86\n#endif\n\n#if defined(__x86_64__) || defined(__amd64__)\nARCH_X86_64\n#endif\n\n#if defined(__powerpc___) || defined(__PPC__) || defined(_POWER) || defined(__POWERPC__)\nARCH_POWER\n#endif\n\n#if defined(__s390x__) || defined(__zarch__)\nARCH_ZARCH\n#endif\n\n#ifdef __mips64\nARCH_MIPS64\n#endif\n\n#if defined(__mips32) || defined(__mips)\nARCH_MIPS\n#endif\n\n#ifdef __alpha\nARCH_ALPHA\n#endif\n\n#if defined(__sparc) || defined(__sparc__)\nARCH_SPARC\n#endif\n\n#if defined(__ia64__) || defined(__ia64)\nARCH_IA64\n#endif\n\n#if defined(__LP64) || defined(__LP64__) || defined(__ptr64) || defined(__x86_64__) || defined(__amd64__) || defined(__64BIT__) || defined(__aarch64__)\nBINARY_64\n#endif\n\n#if defined(__ARM_ARCH) || defined(__ARM_ARCH_7A__) || defined(__arm__)\nARCH_ARM\n#endif\n\n#if defined(__aarch64__)\nARCH_ARM64\n#endif\n\n#if defined(__riscv)\nARCH_RISCV64\n#endif\n\n#ifdef __loongarch64\nARCH_LOONGARCH64\n#endif\n\n#if (defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L)\nHAVE_C11\n#endif\n\n#if defined(__e2k__)\nARCH_E2K\n#endif\n\n#if defined(__csky__)\nARCH_CSKY\n#endif\n\n#if defined(__EMSCRIPTEN__)\nARCH_RISCV64\nOS_WINDOWS\n#endif\n\n"
        },
        {
          "name": "ctest",
          "type": "tree",
          "content": null
        },
        {
          "name": "ctest1.c",
          "type": "blob",
          "size": 0.029296875,
          "content": "int hogehoge(void){return 0;}\n"
        },
        {
          "name": "ctest2.c",
          "type": "blob",
          "size": 0.025390625,
          "content": "int main(void){return 0;}\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "driver",
          "type": "tree",
          "content": null
        },
        {
          "name": "exports",
          "type": "tree",
          "content": null
        },
        {
          "name": "f_check",
          "type": "blob",
          "size": 11.52734375,
          "content": "#!/bin/sh\n\nsplit() {\n    set -f\n    old_ifs=$IFS\n    IFS=$2\n    set -- $1\n    printf '%s ' \"$@\"\n    IFS=$old_ifs\n    set +f\n}\n\nhostos=\"$(uname -s | sed 's/\\-.*//')\"\n\n#\n# 1. Not specified\n#   1.1 Automatically detect, then check compiler\n#   1.2 If no fortran compiler is detected, gfortran is default with NOFORTRAN definition\n# 2. Specified\n#   2.1 If path is correct, check compiler\n#   2.2 If path is not correct, but still valid compiler name, force setting\n#     2.2.2 Path is not correct, invalid compiler name, then gfortran is default with NOFORTRAN definition\n#\n\nmakefile=\"$1\"\nconfig=\"$2\"\n\nnofortran=0\n\nshift 2\ncompiler=\"$*\"\ncompiler_bin=\"$1\"\n\n# f77 is too ambiguous\n[ \"$compiler\" = \"f77\" ] && compiler=''\n\npath=`split \"$PATH\" ':'`\n\nif [ -z \"$compiler\" ]; then\n\n    lists=\"gfortran g95 frt fort openf90 openf95\n\t      sunf77 sunf90 sunf95\n              xlf95 xlf90 xlf\n              ppuf77 ppuf95 ppuf90 ppuxlf\n\t      pathf90 pathf95\n\t      pgf95 pgf90 pgf77 pgfortran nvfortran\n\t      flang egfortran\n              ifort nagfor ifx ftn crayftn armflang\"\n\n    for list in $lists; do\n        for p in $path; do\n            if [ -x \"$p/$list\" ]; then\n                compiler=$list\n                compiler_bin=$list\n                break 2\n            fi\n        done\n    done\nfi\n\nif [ -z \"$compiler\" ]; then\n\n    nofortran=1\n    compiler=gfortran\n    vendor=GFORTRAN\n    bu=\"_\"\n\nelse\n    {\n        data=\"$(command -v \"$compiler_bin\" >/dev/null 2>&1)\"\n        vendor=\"\"\n    } && {\n    \tdata=`$compiler -O2 -S ftest.f > /dev/null 2>&1 && cat ftest.s && rm -f ftest.s`\n    \tif [ -z \"$data\" ]; then\n    \t\tdata=`$compiler -O2 -S ftest.f > /dev/null 2>&1 && cat ftest.c && rm -f ftest.c`\n    \tfi\n\n        case \"$data\" in *zhoge_*) bu=_ ;; esac\n\n        case \"$data\" in\n            *Fujitsu*)\n                vendor=FUJITSU\n                openmp='-Kopenmp'\n                ;;\n\t    *Hewlett*)\n\t\tvendor=CRAY\n\t\topenmp='-fopenmp'\n\t\t;;\n   \t    *Arm\\ F90*|*F90\\ Flang*)\n\t\tvendor=FLANG\n\t\topenmp='-fopenmp'\n\t\t;;\t\n            *GNU*|*GCC*)\n\n                v=\"${data#*GCC: *\\) }\"\n                v=\"${v%%\\\"*}\"\n\n                major=\"${v%%.*}\"\n\n                if [ \"$major\" -ge 4 ]; then\n                    vendor=GFORTRAN\n                    openmp='-fopenmp'\n                else\n                    case \"$compiler\" in\n                        *flang*)\n                            vendor=FLANG\n                            openmp='-fopenmp'\n\t\t\t    data=`$compiler -v 2>&1 > /dev/null `\n                \t    v=\"${data#*version *}\"\n                \t    v=\"${v%%*.}\"\n                \t    major=\"${v%%.*}\"\n                \t    if [ \"$major\" -ge 17 ]; then\n                        \tvendor=FLANGNEW\n\t\t\t    fi\t\n\t\t\t    ;;\n                        *ifort*|*ifx*)\n                            vendor=INTEL\n                            openmp='-fopenmp'\n                            ;;\n                        *pgf*|*nvf*)\n                            vendor=PGI\n                            openmp='-mp'\n                            ;;\n                        *xlf*)\n                            vendor=IBM\n                            ;;\n                        *)\n                            vendor=G77\n                            openmp=''\n                            ;;\n                    esac\n                fi\n                ;;\n\t    *Cray*)\n\t\tvendor=CRAY\n\t\topenmp='-fopenmp'\n\t\t;;\t\t\n            *g95*)\n                vendor=G95\n                openmp=''\n                ;;\n            *Intel*)\n                vendor=INTEL\n                openmp='-fopenmp'\n                ;;\n            *'Sun Fortran'*)\n                vendor=SUN\n                openmp='-xopenmp=parallel'\n                ;;\n            *PathScale*)\n                vendor=PATHSCALE\n                openmp='-openmp'\n                ;;\n            *Open64*)\n                vendor=OPEN64\n                openmp='-mp'\n                ;;\n            *PGF*|*NVF*)\n                vendor=PGI\n                openmp='-mp'\n                ;;\n            *'IBM XL'*)\n                vendor=IBM\n                openmp='-openmp'\n\t\tcase \"$CC\" in *gcc*)\n\t\tbu=_\n\t\t;;\n\t\tesac\n                ;;\n            *NAG*)\n                vendor=NAG\n                openmp='-openmp'\n                ;;\n        esac\n\n    \t# for embedded underscore name, e.g. zho_ge, it may append 2 underscores.\n    \tdata=`$compiler -O2 -S ftest3.f >/dev/null 2>&1 && cat ftest3.s && rm -f ftest3.s`\n\n    \t[ -z \"$data\" ] && {\n    \t\tdata=`$compiler -O2 -S ftest3.f >/dev/null 2>&1 && cat ftest3.c && rm -f ftest3.c`\n    \t}\n\n    \tcase \"$data\" in *' zho_ge__'*) need2bu=1 ;; esac\n    \tcase \"$vendor\" in *G95*) [ \"$NO_LAPACKE\" != 1 ] && need2bu='' ;; esac\n\t}\n\n    if [ -z \"$vendor\" ]; then\n        case \"$compiler\" in\n            *g77*)\n                vendor=G77\n                bu=_\n                openmp=''\n                ;;\n            *g95*)\n                vendor=G95\n                bu=_\n                openmp=''\n                ;;\n            *gfortran*)\n                vendor=GFORTRAN\n                bu=_\n                openmp='-fopenmp'\n                ;;\n            *ifort*|*ifx*)\n                vendor=INTEL\n                bu=_\n                openmp='-fopenmp'\n                ;;\n            *pathf*)\n            \tvendor=PATHSCALE\n            \tbu=_\n            \topenmp='-mp'\n            \t;;\n            *pgf*|*nvf*)\n                vendor=PGI\n                bu=_\n                openmp='-mp'\n                ;;\n            *ftn*)\n            \tvendor=PGI\n            \tbu=_\n            \topenmp=-openmp\n            \t;;\n            *frt*)\n                vendor=FUJITSU\n                bu=_\n                openmp='-openmp'\n                ;;\n            *sunf77*|*sunf90*|*sunf95*)\n                vendor=SUN\n                bu=_\n                openmp='-xopenmp=parallel'\n                ;;\n            *ppuf*|*xlf*)\n                vendor=IBM\n                openmp='-openmp'\n\t\tcase \"$CC\" in *gcc*)\n\t\tbu=_\n\t\t;;\n\t\tesac\n                ;;\n            *open64*)\n                vendor=OPEN64\n                openmp='-mp'\n                ;;\n            *flang*)\n                vendor=FLANG\n                bu=_\n                openmp='-fopenmp'\n                ;;\n            *nagfor*)\n                vendor=NAG\n                bu=_\n                openmp='-openmp'\n                ;;\n        esac\n\n    \tif [ -z \"$vendor\" ]; then\n    \t    nofortran=1\n    \t    compiler=\"gfortran\"\n    \t    vendor=GFORTRAN\n    \t    bu=_\n    \t    openmp=''\n    \tfi\n    fi\nfi\n\n{\n    data=`command -v $compiler_bin >/dev/null 2>&1`\n} && {\n\n    binary=$BINARY\n\n    [ \"$USE_OPENMP\" != 1 ] && openmp=''\n\n    case \"$binary\" in\n        32)\n            {\n                link=`$compiler $openmp -m32 -v ftest2.f 2>&1 && rm -f a.out a.exe`\n            } || {\n                link=`$compiler $openmp -q32 -v ftest2.f 2>&1 && rm -f a.out a.exe`\n            } || {\n                # for AIX\n                link=`$compiler $openmp -maix32 -v ftest2.f 2>&1 && rm -f a.out a.exe`\n            } || {\n                # for gfortran MIPS\n                mips_data=`$compiler_bin -E -dM - < /dev/null`\n                case \"$mips_data\" in\n                    *_MIPS_ISA_MIPS64*)\n                        link=`$compiler $openmp -mabi=n32 -v ftest2.f 2>&1 && rm -f a.out a.exe`\n                        ;;\n                    *)\n                        link=`$compiler $openmp -mabi=32 -v ftest2.f 2>&1 && rm -f a.out a.exe`\n                        ;;\n                esac\n            } || {\n                binary=''\n            }\n            ;;\n        64)\n            {\n                link=`$compiler $openmp -m64 -v ftest2.f 2>&1 && rm -f a.out a.exe`\n            } || {\n                link=`$compiler $openmp -q64 -v ftest2.f 2>&1 && rm -f a.out a.exe`\n            } || {\n                # for AIX\n                link=`$compiler $openmp -maix64 -v ftest2.f 2>&1 && rm -f a.out a.exe`\n            } || {\n                # for gfortran MIPS\n                link=`$compiler $openmp -mabi=64 -v ftest2.f 2>&1 && rm -f a.out a.exe`\n            } || {\n                # for nagfor\n                link=`$compiler $openmp -dryrun ftest2.f 2>&1 && rm -f a.out a.exe`\n            } || {\n                binary=''\n            }\n            ;;\n    esac\n\n    if [ -z \"$binary\" ]; then\n        link=`$compiler $openmp -v ftest2.f 2>&1 && rm -f a.out a.exe`\n    fi\n}\n\nif [ \"$vendor\" = \"NAG\" ]; then\n    link=`$compiler $openmp -dryrun ftest2.f 2>&1 && rm -f a.out a.exe`\nfi\nif [ \"$vendor\" = \"CRAY\" ]; then\n    link=`$compiler $openmp -hnopattern ftest2.f 2>&1 && rm -f a.out a.exe`\nfi\nlinker_L=\"\"\nlinker_l=\"\"\nlinker_a=\"\"\n\nif [ -n \"$link\" ]; then\n\n    link=`echo \"$link\" | sed 's/\\-Y[[:space:]]P\\,/\\-Y/g'`\n\n    link=`echo \"$link\" | sed 's/\\-R[[:space:]]*/\\-rpath\\%/g'`\n\n    link=`echo \"$link\" | sed 's/\\-rpath[[:space:]]+/\\-rpath\\%/g'`\n\n    link=`echo \"$link\" | sed 's/\\-rpath-link[[:space:]]+/\\-rpath-link\\%/g'`\n\n    flags=`echo \"$link\" | tr \"',\\n\" \" \"`\n    # remove leading and trailing quotes from each flag.\n    #@flags = map {s/^['\"]|['\"]$//g; $_} @flags;\n\n    for flag in $flags; do\n        case \"$flag\" in -L*)\n            case \"$flag\" in\n                -LIST:*|-LANG:*) ;;\n                *) linker_L=\"$linker_L $flag\" ;;\n            esac\n        esac\n\n    \tcase \"$flag\" in -Y*)\n    \t    [ \"$hostos\" = \"SunOS\" ] && continue\n    \t    linker_L=\"$linker_L -Wl,$flag\"\n    \t    ;;\n        esac\n\n    \tcase \"$flag\" in --exclude-libs*)\n            linker_L=\"$linker_L -Wl,$flag\"\n            flag=\"\"\n            ;;\n        esac\n\n    \tcase \"$flag\" in -rpath%*)\n    \t    flag=`echo \"$flag\" | sed 's/\\%/\\,/g'`\n    \t    linker_L=\"$linker_L -Wl,$flag\"\n        esac\n\n    \tcase \"$flag\" in -rpath-link%*)\n    \t    flag=`echo \"$flag\" | sed 's/\\%/\\,/g'`\n    \t    linker_L=\"$linker_L -Wl,$flag\"\n    \t    ;;\n    \tesac\n\n        case \"$flag\" in -l*)\n            case \"$flag\" in\n                *ibrary*|*gfortranbegin*|*flangmain*|*frtbegin*|*pathfstart*|\\\n                    *crt[0-9]*|*gcc*|*user32*|*kernel32*|*advapi32*|*shell32*|\\\n                    -l) ;;\n                *omp*)\n                    case \"$vendor\" in\n                        *PGI*|*FUJITSU*) ;;\n                        *) linker_l=\"$linker_l $flag\" ;;\n                    esac\n                    ;;\n                *[0-9]*)\n                    if [ \"$vendor\" = \"FUJITSU\" ]; then\n                        case \"$flag\" in\n                            -lfj90*) linker_l=\"$linker_l $flag\" ;;\n                            *) ;;\n                        esac\n                    fi\n                    ;;\n                *) linker_l=\"$linker_l $flag\" ;;\n            esac\n    \tesac\n\n        case \"$flag\" in *quickfit.o*)\n            [ \"$vendor\" = \"NAG\" ] && linker_l=\"$linker_l $flag\" ;;\n        esac\n\n        case \"$flag\" in *safefit.o*)\n            [ \"$vendor\" = \"NAG\" ] && linker_l=\"$linker_l $flag\" ;;\n        esac\n\n        case \"$flag\" in *thsafe.o*)\n            [ \"$vendor\" = \"NAG\" ] && linker_l=\"$linker_l $flag\" ;;\n        esac\n\n    \tcase \"$flag\" in *.a) linker_a=\"$linker_a $flag\" ;; esac\n    done\nfi\n\nif [ \"$vendor\" = \"FLANG\" ]; then\n    linker_a=\"$linker_a -lflang\"\nfi\n\nprintf \"F_COMPILER=%s\\n\" \"$vendor\"               >> \"$makefile\"\nprintf \"FC=%s\\n\" \"$compiler\"                     >> \"$makefile\"\n[ -n \"$bu\" ] && printf 'BU=%s\\n' \"$bu\"           >> \"$makefile\"\n[ \"$nofortran\" -eq 1 ] && printf 'NOFORTRAN=1\\n' >> \"$makefile\"\n\n[ -n \"$bu\" ] && printf '#define BUNDERSCORE\\t%s\\n' \"$bu\"    >> \"$config\"\n[ -n \"$bu\" ] && printf '#define NEEDBUNDERSCORE\\t1\\n'       >> \"$config\"\n[ -n \"$need2bu\" ] && printf \"#define NEED2UNDERSCORES\\t1\\n\" >> \"$config\"\n\n[ -n \"$need2bu\" ] && printf \"#define NEED2UNDERSCORES=1\\n\"  >> \"$config\"\n\nif [ -n \"$linker_l\" ] || [ -n \"$linker_a\" ]; then\n    printf \"FEXTRALIB=%s %s %s\\n\" \"$linker_L\" \"$linker_l\" \"$linker_a\" >> \"$makefile\"\nfi\n\n"
        },
        {
          "name": "f_check.pl",
          "type": "blob",
          "size": 9.4189453125,
          "content": "#!/usr/bin/env perl\n\n$hostos   = `uname -s | sed -e s/\\-.*//`;    chop($hostos);\n\n#\n# 1. Not specified\n#   1.1 Automatically detect, then check compiler\n#   1.2 If no fortran compiler is detected, gfortran is default with NOFORTRAN definition\n# 2. Specified\n#   2.1 If path is correct, check compiler\n#   2.2 If path is not correct, but still valid compiler name, force setting\n#     2.2.2 Path is not correct, invalid compiler name, then gfortran is default with NOFORTRAN definition\n#\n\n$makefile = shift(@ARGV);\n$config   = shift(@ARGV);\n\n$nofortran = 0;\n\n$compiler = join(\" \", @ARGV);\n$compiler_bin = shift(@ARGV);\n \n# f77 is too ambiguous\n$compiler = \"\" if $compiler eq \"f77\";\n\n@path = split(/:/, $ENV{\"PATH\"});\n\nif ($compiler eq \"\") {\n\n    @lists = (\"gfortran\", \"g95\", \"frt\", \"fort\", \"openf90\", \"openf95\",\n\t      \"sunf77\", \"sunf90\", \"sunf95\",\n              \"xlf95\", \"xlf90\", \"xlf\",\n              \"ppuf77\", \"ppuf95\", \"ppuf90\", \"ppuxlf\",\n\t      \"pathf90\", \"pathf95\",\n\t      \"pgf95\", \"pgf90\", \"pgf77\", \"pgfortran\", \"nvfortran\",\n\t      \"flang\", \"egfortran\",\n              \"ifort\", \"nagfor\", \"ifx\", \"ftn\", \"crayftn\");\n\nOUTER:\n    foreach $lists (@lists) {\n        foreach $path (@path) {\n            if (-x $path . \"/\" . $lists) {\n                $compiler = $lists;\n                $compiler_bin = $lists;\n                last OUTER;\n            }\n        }\n    }\n\n}\n\nif ($compiler eq \"\") {\n\n    $nofortran = 1;\n    $compiler = \"gfortran\";\n    $vendor = GFORTRAN;\n    $bu       = \"_\";\n\n} else {\n\n    $data = `which $compiler_bin > /dev/null 2> /dev/null`;\n    $vendor = \"\";\n\n    if (!$?) {\n\n\t$data = `$compiler -O2 -S ftest.f > /dev/null 2>&1 && cat ftest.s && rm -f ftest.s`;\n\tif ($data eq \"\") {\n\t\t$data = `$compiler -O2 -S ftest.f > /dev/null 2>&1 && cat ftest.c && rm -f ftest.c`;\n\t}\n\tif ($data =~ /zhoge_/) {\n\t    $bu       = \"_\";\n\t}\n\n\tif ($data =~ /Fujitsu/) {\n\n\t    $vendor = FUJITSU;\n\t    $openmp = \"-Kopenmp\";\n\n\t} elsif ($data =~ /GNU/ || $data =~ /GCC/ ) {\n\n            $data =~ s/\\(+.*?\\)+//g;\n\t    $data =~ /(\\d+)\\.(\\d+).(\\d+)/;\n\t    $major = $1;\n\t    $minor = $2;\n\n\t    if ($major >= 4) {\n\t\t$vendor = GFORTRAN;\n\t\t$openmp = \"-fopenmp\";\n\t    } else {\n\t\tif ($compiler =~ /flang/) {\n\t\t    $vendor = FLANG;\n\t\t    $openmp = \"-fopenmp\";\n\t    } elsif ($compiler =~ /ifort/ || $compiler =~ /ifx/) {\n\t\t    $vendor = INTEL;\n\t\t    $openmp = \"-fopenmp\";\n\t    } elsif ($compiler =~ /pgf/ || $compiler =~ /nvf/) {\n\t\t    $vendor = PGI;\n\t\t    $openmp = \"-mp\";\n\t\t} else {\n\t\t    $vendor = G77;\n\t\t    $openmp = \"\";\n\t\t}\n\t    }\n\t} elsif ($data =~ /Cray/) {\n\n\t    $vendor = CRAY;\n\t    $openmp = \"-fopenmp\";\n\n\t}\n\n\tif ($data =~ /g95/) {\n\t    $vendor = G95;\n\t    $openmp = \"\";\n\t}\n\n\tif ($data =~ /Intel/) {\n\t    $vendor = INTEL;\n\t    $openmp = \"-fopenmp\";\n\t}\n\n        if ($data =~ /Sun Fortran/) {\n            $vendor = SUN;\n\t    $openmp = \"-xopenmp=parallel\";\n        }\n\n\tif ($data =~ /PathScale/) {\n\t    $vendor = PATHSCALE;\n\t    $openmp = \"-openmp\";\n\t}\n\n\tif ($data =~ /Open64/) {\n\t    $vendor = OPEN64;\n\t    $openmp = \"-mp\";\n\t}\n\n\tif ($data =~ /PGF/ || $data =~ /NVF/) {\n\t    $vendor = PGI;\n\t    $openmp = \"-mp\";\n\t}\n\n\tif ($data =~ /IBM XL/) {\n\t    $vendor = IBM;\n\t    $openmp = \"-openmp\";\n\t}\n\n\tif ($data =~ /NAG/) {\n\t    $vendor = NAG;\n\t    $openmp = \"-openmp\";\n\t}\n\n\t# for embedded underscore name, e.g. zho_ge, it may append 2 underscores.\n\t$data = `$compiler -O2 -S ftest3.f > /dev/null 2>&1 && cat ftest3.s && rm -f ftest3.s`;\n\tif ($data eq \"\") {\n\t\t$data = `$compiler -O2 -S ftest3.f > /dev/null 2>&1 && cat ftest3.c && rm -f ftest3.c`;\n\t}\n\tif ($data =~ / zho_ge__/) {\n\t    $need2bu       = 1;\n\t}\n\tif ($vendor =~ /G95/) {\n    \t  if ($ENV{NO_LAPACKE} != 1) {\n\t\t$need2bu = \"\";\n\t  }\n\t}\n    }\n\n    if ($vendor eq \"\") {\n\n\tif ($compiler =~ /g77/) {\n\t    $vendor = G77;\n\t    $bu       = \"_\";\n\t    $openmp = \"\";\n\t}\n\n\tif ($compiler =~ /g95/) {\n\t    $vendor = G95;\n\t    $bu       = \"_\";\n\t    $openmp = \"\";\n\t}\n\n\tif ($compiler =~ /gfortran/) {\n\t    $vendor = GFORTRAN;\n\t    $bu       = \"_\";\n\t    $openmp = \"-fopenmp\";\n\t}\n\n\tif ($compiler =~ /ifort/ || $compiler =~ /ifx/) {\n\t    $vendor = INTEL;\n\t    $bu       = \"_\";\n\t    $openmp = \"-fopenmp\";\n\t}\n\n\tif ($compiler =~ /pathf/) {\n\t    $vendor = PATHSCALE;\n\t    $bu       = \"_\";\n\t    $openmp = \"-mp\";\n\t}\n\n\tif ($compiler =~ /pgf/ || $compiler =~ /nvf/) {\n\t    $vendor = PGI;\n\t    $bu       = \"_\";\n\t    $openmp = \"-mp\";\n\t}\n\n\tif ($compiler =~ /ftn/) {\n\t    $vendor = PGI;\n\t    $bu       = \"_\";\n\t    $openmp = \"-openmp\";\n\t}\n\n\tif ($compiler =~ /frt/) {\n\t    $vendor = FUJITSU;\n\t    $bu       = \"_\";\n\t    $openmp = \"-openmp\";\n\t}\n\n\tif ($compiler =~ /sunf77|sunf90|sunf95/) {\n\t    $vendor = SUN;\n\t    $bu       = \"_\";\n\t    $openmp = \"-xopenmp=parallel\";\n\t}\n\n\tif ($compiler =~ /ppuf/) {\n\t    $vendor = IBM;\n\t    $openmp = \"-openmp\";\n\t}\n\n\tif ($compiler =~ /xlf/) {\n\t    $vendor = IBM;\n\t    $openmp = \"-openmp\";\n\t}\n\n\tif ($compiler =~ /open64/) {\n\t    $vendor = OPEN64;\n\t    $openmp = \"-mp\";\n\t}\n\n\tif ($compiler =~ /flang/) {\n\t    $vendor = FLANG;\n\t    $bu     = \"_\";\n\t    $openmp = \"-fopenmp\";\n\t}\n\n\tif ($compiler =~ /nagfor/) {\n\t    $vendor = NAG;\n\t    $bu     = \"_\";\n\t    $openmp = \"-openmp\";\n\t}\n\n\tif ($vendor eq \"\") {\n\t    $nofortran = 1;\n\t    $compiler = \"gfortran\";\n\t    $vendor = GFORTRAN;\n\t    $bu       = \"_\";\n\t    $openmp = \"\";\n\t}\n\n    }\n}\n\n$data = `which $compiler_bin > /dev/null 2> /dev/null`;\n\nif (!$?) {\n\n    $binary = $ENV{\"BINARY\"};\n\n    $openmp = \"\" if $ENV{USE_OPENMP} != 1;\n\n    if ($binary == 32) {\n\t$link = `$compiler $openmp -m32 -v ftest2.f 2>&1 && rm -f a.out a.exe`;\n\tif ($?) {\n\t    $link = `$compiler $openmp -q32 -v ftest2.f 2>&1 && rm -f a.out a.exe`;\n\t}\n        # for AIX\n\tif ($?) {\n\t    $link = `$compiler $openmp -maix32 -v ftest2.f 2>&1 && rm -f a.out a.exe`;\n\t}\n       #For gfortran MIPS\n\tif ($?) {\n    $mips_data = `$compiler_bin -E -dM - < /dev/null`;\n    if ($mips_data =~ /_MIPS_ISA_MIPS64/) {\n        $link = `$compiler $openmp -mabi=n32 -v ftest2.f 2>&1 && rm -f a.out a.exe`;\n    } else {\n        $link = `$compiler $openmp -mabi=32 -v ftest2.f 2>&1 && rm -f a.out a.exe`;\n    }\n\t}\n\t$binary = \"\" if ($?);\n    }\n\n    if ($binary == 64) {\n\t$link = `$compiler $openmp -m64 -v ftest2.f 2>&1 && rm -f a.out a.exe`;\n\tif ($?) {\n\t    $link = `$compiler $openmp -q64 -v ftest2.f 2>&1 && rm -f a.out a.exe`;\n\t}\n        # for AIX\n\tif ($?) {\n\t    $link = `$compiler $openmp -maix64 -v ftest2.f 2>&1 && rm -f a.out a.exe`;\n\t}\n       #For gfortran MIPS\n\tif ($?) {\n\t    $link = `$compiler $openmp -mabi=64 -v ftest2.f 2>&1 && rm -f a.out a.exe`;\n\t}\n       #For nagfor\n\tif ($?) {\n\t    $link = `$compiler $openmp -dryrun ftest2.f 2>&1 && rm -f a.out a.exe`;\n        }\n\t$binary = \"\" if ($?);\n    }\n    if ($binary eq \"\") {\n\t$link = `$compiler $openmp -v ftest2.f 2>&1 && rm -f a.out a.exe`;\n    }\n}\n\nif ( $vendor eq \"NAG\") {\n\t    $link = `$compiler $openmp -dryrun ftest2.f 2>&1 && rm -f a.out a.exe`;\n    }\nif ( $vendor eq \"CRAY\") {\n\t    $link = `$compiler $openmp -hnopattern ftest2.f 2>&1 && rm -f a.out a.exe`;\n    }\n$linker_L = \"\";\n$linker_l = \"\";\n$linker_a = \"\";\n\nif ($link ne \"\") {\n\n    $link =~ s/\\-Y\\sP\\,/\\-Y/g;\n    \n    $link =~ s/\\-R\\s*/\\-rpath\\%/g;\n\n    $link =~ s/\\-rpath\\s+/\\-rpath\\%/g;\n\n    $link =~ s/\\-rpath-link\\s+/\\-rpath-link\\%/g;\n\n    @flags = split(/[\\s\\,\\n]/, $link);\n    # remove leading and trailing quotes from each flag.\n    @flags = map {s/^['\"]|['\"]$//g; $_} @flags;\n\n    foreach $flags (@flags) {\n\tif (\n\t    ($flags =~ /^\\-L/)\n\t    && ($flags !~ /^-LIST:/)\n\t    && ($flags !~ /^-LANG:/)\n\t    ) {\n\t    $linker_L .= $flags . \" \";\n\t}\n\n\tif ($flags =~ /^\\-Y/) {\n\t    next if ($hostos eq 'SunOS');\n\t    $linker_L .= \"-Wl,\". $flags . \" \";\n        }\n\n\tif ($flags =~ /^\\--exclude-libs/) {\n\t    $linker_L .= \"-Wl,\". $flags . \" \";\n\t    $flags=\"\";\n\t}\n\n\n\tif ($flags =~ /^\\-rpath\\%/) {\n\t    $flags =~ s/\\%/\\,/g;\n\t    $linker_L .= \"-Wl,\". $flags . \" \" ;\n\t}\n\n\tif ($flags =~ /^\\-rpath-link\\%/) {\n\t    $flags =~ s/\\%/\\,/g;\n\t    $linker_L .= \"-Wl,\". $flags . \" \" ;\n\t}\n\tif ($flags =~ /-lgomp/ && $ENV{\"CC\"} =~ /clang/) {\n\t    $flags = \"-lomp\";\n\t}\n\n\tif (\n\t    ($flags =~ /^\\-l/)\n\t    && ($flags !~ /ibrary/)\n\t    && ($flags !~ /gfortranbegin/)\n\t    && ($flags !~ /flangmain/)\n\t    && ($flags !~ /frtbegin/)\n\t    && ($flags !~ /pathfstart/)\n\t    && ($flags !~ /crt[0-9]/)\n\t    && ($flags !~ /gcc/)\n\t    && ($flags !~ /user32/)\n\t    && ($flags !~ /kernel32/)\n\t    && ($flags !~ /advapi32/)\n\t    && ($flags !~ /shell32/)\n\t    && ($flags !~ /omp/ || ($vendor !~ /PGI/ && $vendor !~ /FUJITSU/ && $flags =~ /omp/))\n\t    && ($flags !~ /[0-9]+/ || ($vendor == FUJITSU && $flags =~ /^-lfj90/))\n\t\t&& ($flags !~ /^\\-l$/)\n\t    ) {\n\t    $linker_l .= $flags . \" \";\n\t}\n\n\tif ( $flags =~ /quickfit.o/ && $vendor == NAG) {\n\t    $linker_l .= $flags . \" \";\n\t}\n\tif ( $flags =~ /safefit.o/ && $vendor == NAG) {\n\t    $linker_l .= $flags . \" \";\n\t}\n\tif ( $flags =~ /thsafe.o/ && $vendor == NAG) {\n\t    $linker_l .= $flags . \" \";\n\t}\n\n\t$linker_a .= $flags . \" \" if $flags =~ /\\.a$/;\n    }\n\n}\n\nif ($vendor eq \"FLANG\"){\n    $linker_a .= \"-lflang\"\n}\n\nopen(MAKEFILE, \">> $makefile\") || die \"Can't append $makefile\";\nopen(CONFFILE, \">> $config\"  ) || die \"Can't append $config\";\n\nprint MAKEFILE \"F_COMPILER=$vendor\\n\";\nprint MAKEFILE \"FC=$compiler\\n\";\nprint MAKEFILE \"BU=$bu\\n\" if $bu ne \"\";\nprint MAKEFILE \"NOFORTRAN=1\\n\" if $nofortran == 1;\n\nprint CONFFILE \"#define BUNDERSCORE\\t$bu\\n\" if $bu ne \"\";\nprint CONFFILE \"#define NEEDBUNDERSCORE\\t1\\n\" if $bu ne \"\";\nprint CONFFILE \"#define NEED2UNDERSCORES\\t1\\n\" if $need2bu ne \"\";\n\nprint MAKEFILE \"NEED2UNDERSCORES=1\\n\" if $need2bu ne \"\";\n\nif (($linker_l ne \"\") || ($linker_a ne \"\")) {\n    print MAKEFILE \"FEXTRALIB=$linker_L $linker_l $linker_a\\n\";\n}\n\nclose(MAKEFILE);\nclose(CONFFILE);\n"
        },
        {
          "name": "ftest.f",
          "type": "blob",
          "size": 0.0888671875,
          "content": "      double complex function zhoge()\n\n      zhoge = (0.0d0,0.0d0)\n\n      return\n      end\n"
        },
        {
          "name": "ftest2.f",
          "type": "blob",
          "size": 0.029296875,
          "content": "      program main\n\n      end\n"
        },
        {
          "name": "ftest3.f",
          "type": "blob",
          "size": 0.0908203125,
          "content": "      double complex function zho_ge()\n\n      zho_ge = (0.0d0,0.0d0)\n\n      return\n      end\n"
        },
        {
          "name": "gen_config_h.c",
          "type": "blob",
          "size": 0.7255859375,
          "content": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\nint main(int argc, char**argv) {\nFILE *fp;\nchar line[100];\nchar line2[80];\nchar *s;\nint i;\n\nfprintf(stdout,\"#ifndef OPENBLAS_CONFIG_H\\n\");\nfprintf(stdout,\"#define OPENBLAS_CONFIG_H\\n\");\nfp=fopen(argv[1],\"r\");\ndo{\ns=fgets(line,80,fp);\nif (s== NULL) break;\nmemset(line2,0,80);\ni=sscanf(line,\"#define %70c\",line2);\nif (i!=0) {\n\tfprintf(stdout,\"#define OPENBLAS_%s\",line2);\n} else {\n\tfprintf(stdout,\"\\n\");\n}\n} while (1);\nfclose(fp);\nfprintf(stdout,\"#define OPENBLAS_VERSION \\\"OpenBLAS %s\\\"\\n\", VERSION);\nfp=fopen(argv[2],\"r\");\ndo{\ns=fgets(line,100,fp);\nif (s== NULL) break;\nfprintf(stdout,\"%s\",line);\n} while(1);\nfclose(fp);\nfprintf(stdout,\"#endif /* OPENBLAS_CONFIG_H */\\n\");\nexit(0);\n}\n"
        },
        {
          "name": "getarch.c",
          "type": "blob",
          "size": 67.859375,
          "content": "/*****************************************************************************\nCopyright (c) 2011-2014, The OpenBLAS Project\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   1. Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n\n   2. Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in\n      the documentation and/or other materials provided with the\n      distribution.\n   3. Neither the name of the OpenBLAS project nor the names of \n      its contributors may be used to endorse or promote products \n      derived from this software without specific prior written \n      permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\nUSE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n**********************************************************************************/\n\n/*********************************************************************/\n/* Copyright 2009, 2010 The University of Texas at Austin.           */\n/* All rights reserved.                                              */\n/*                                                                   */\n/* Redistribution and use in source and binary forms, with or        */\n/* without modification, are permitted provided that the following   */\n/* conditions are met:                                               */\n/*                                                                   */\n/*   1. Redistributions of source code must retain the above         */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer.                                                  */\n/*                                                                   */\n/*   2. Redistributions in binary form must reproduce the above      */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer in the documentation and/or other materials       */\n/*      provided with the distribution.                              */\n/*                                                                   */\n/*    THIS  SOFTWARE IS PROVIDED  BY THE  UNIVERSITY OF  TEXAS AT    */\n/*    AUSTIN  ``AS IS''  AND ANY  EXPRESS OR  IMPLIED WARRANTIES,    */\n/*    INCLUDING, BUT  NOT LIMITED  TO, THE IMPLIED  WARRANTIES OF    */\n/*    MERCHANTABILITY  AND FITNESS FOR  A PARTICULAR  PURPOSE ARE    */\n/*    DISCLAIMED.  IN  NO EVENT SHALL THE UNIVERSITY  OF TEXAS AT    */\n/*    AUSTIN OR CONTRIBUTORS BE  LIABLE FOR ANY DIRECT, INDIRECT,    */\n/*    INCIDENTAL,  SPECIAL, EXEMPLARY,  OR  CONSEQUENTIAL DAMAGES    */\n/*    (INCLUDING, BUT  NOT LIMITED TO,  PROCUREMENT OF SUBSTITUTE    */\n/*    GOODS  OR  SERVICES; LOSS  OF  USE,  DATA,  OR PROFITS;  OR    */\n/*    BUSINESS INTERRUPTION) HOWEVER CAUSED  AND ON ANY THEORY OF    */\n/*    LIABILITY, WHETHER  IN CONTRACT, STRICT  LIABILITY, OR TORT    */\n/*    (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY WAY OUT    */\n/*    OF  THE  USE OF  THIS  SOFTWARE,  EVEN  IF ADVISED  OF  THE    */\n/*    POSSIBILITY OF SUCH DAMAGE.                                    */\n/*                                                                   */\n/* The views and conclusions contained in the software and           */\n/* documentation are those of the authors and should not be          */\n/* interpreted as representing official policies, either expressed   */\n/* or implied, of The University of Texas at Austin.                 */\n/*********************************************************************/\n\n#if defined(__WIN32__) || defined(__WIN64__) || defined(__CYGWIN32__) || defined(__CYGWIN64__) || defined(_WIN32) || defined(_WIN64)\n#define OS_WINDOWS\n#endif\n\n#if defined(__i386__) || defined(__x86_64__) || defined(_M_IX86) || defined(_M_X64)\n#define INTEL_AMD\n#endif\n\n#include <stdio.h>\n#include <string.h>\n#ifdef OS_WINDOWS\n#include <windows.h>\n#endif\n#if defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__NetBSD__) || defined(__DragonFly__) || defined(__APPLE__)\n#include <sys/types.h>\n#include <sys/sysctl.h>\n#endif\n#if defined(linux) || defined(__sun__)\n#include <sys/sysinfo.h>\n#include <unistd.h>\n#endif\n#if defined(_AIX)\n#include <unistd.h>\n#include <sys/systemcfg.h>\n#include <sys/sysinfo.h>\n#endif\n\n/* #define FORCE_P2\t\t*/\n/* #define FORCE_KATMAI\t\t*/\n/* #define FORCE_COPPERMINE\t*/\n/* #define FORCE_NORTHWOOD\t*/\n/* #define FORCE_PRESCOTT\t*/\n/* #define FORCE_BANIAS\t\t*/\n/* #define FORCE_YONAH\t\t*/\n/* #define FORCE_CORE2\t\t*/\n/* #define FORCE_PENRYN\t\t*/\n/* #define FORCE_DUNNINGTON\t*/\n/* #define FORCE_NEHALEM\t*/\n/* #define FORCE_SANDYBRIDGE\t*/\n/* #define FORCE_ATOM\t\t*/\n/* #define FORCE_ATHLON\t\t*/\n/* #define FORCE_OPTERON\t*/\n/* #define FORCE_OPTERON_SSE3\t*/\n/* #define FORCE_BARCELONA\t*/\n/* #define FORCE_SHANGHAI\t*/\n/* #define FORCE_ISTANBUL\t*/\n/* #define FORCE_BOBCAT\t\t*/\n/* #define FORCE_BULLDOZER\t*/\n/* #define FORCE_PILEDRIVER     */\n/* #define FORCE_SSE_GENERIC\t*/\n/* #define FORCE_VIAC3\t\t*/\n/* #define FORCE_NANO\t\t*/\n/* #define FORCE_POWER3\t\t*/\n/* #define FORCE_POWER4\t\t*/\n/* #define FORCE_POWER5\t\t*/\n/* #define FORCE_POWER6\t\t*/\n/* #define FORCE_POWER7\t\t*/\n/* #define FORCE_POWER8\t\t*/\n/* #define FORCE_PPCG4\t\t*/\n/* #define FORCE_PPC970\t\t*/\n/* #define FORCE_PPC970MP\t*/\n/* #define FORCE_PPC440\t\t*/\n/* #define FORCE_PPC440FP2\t*/\n/* #define FORCE_CELL\t\t*/\n/* #define FORCE_MIPS64_GENERIC\t*/\n/* #define FORCE_SICORTEX\t*/\n/* #define FORCE_LOONGSON3R3    */\n/* #define FORCE_LOONGSON3R4    */\n/* #define FORCE_LOONGSON3R5     */\n/* #define FORCE_LOONGSON2K1000  */\n/* #define FORCE_LOONGSONGENERIC */\n/* #define FORCE_LA64_GENERIC   */\n/* #define FORCE_LA264          */\n/* #define FORCE_LA464          */\n/* #define FORCE_I6400\t\t*/\n/* #define FORCE_P6600\t\t*/\n/* #define FORCE_P5600\t\t*/\n/* #define FORCE_I6500\t\t*/\n/* #define FORCE_ITANIUM2\t*/\n/* #define FORCE_SPARC\t\t*/\n/* #define FORCE_SPARCV7\t*/\n/* #define FORCE_ZARCH_GENERIC\t*/\n/* #define FORCE_Z13\t\t*/\n/* #define FORCE_EV4\t\t*/\n/* #define FORCE_EV5\t\t*/\n/* #define FORCE_EV6\t\t*/\n/* #define FORCE_CSKY\t\t*/\n/* #define FORCE_CK860FV        */\n/* #define FORCE_GENERIC\t*/\n\n#ifdef FORCE_P2\n#define FORCE\n#define FORCE_INTEL\n#define ARCHITECTURE    \"X86\"\n#define SUBARCHITECTURE \"PENTIUM2\"\n#define ARCHCONFIG   \"-DPENTIUM2 \" \\\n\t\t     \"-DL1_DATA_SIZE=16384 -DL1_DATA_LINESIZE=32 \" \\\n\t\t     \"-DL2_SIZE=512488 -DL2_LINESIZE=32 \" \\\n\t\t     \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 \" \\\n\t\t     \"-DHAVE_CMOV -DHAVE_MMX\"\n#define LIBNAME   \"p2\"\n#define CORENAME  \"P5\"\n#endif\n\n#ifdef FORCE_KATMAI\n#define FORCE\n#define FORCE_INTEL\n#define ARCHITECTURE    \"X86\"\n#define SUBARCHITECTURE \"PENTIUM3\"\n#define ARCHCONFIG   \"-DPENTIUM3 \" \\\n\t\t     \"-DL1_DATA_SIZE=16384 -DL1_DATA_LINESIZE=32 \" \\\n\t\t     \"-DL2_SIZE=524288 -DL2_LINESIZE=32 \" \\\n\t\t     \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 \" \\\n\t\t     \"-DHAVE_CMOV -DHAVE_MMX -DHAVE_SSE \"\n#define LIBNAME   \"katmai\"\n#define CORENAME  \"KATMAI\"\n#endif\n\n#ifdef FORCE_COPPERMINE\n#define FORCE\n#define FORCE_INTEL\n#define ARCHITECTURE    \"X86\"\n#define SUBARCHITECTURE \"PENTIUM3\"\n#define ARCHCONFIG   \"-DPENTIUM3 \" \\\n\t\t     \"-DL1_DATA_SIZE=16384 -DL1_DATA_LINESIZE=32 \" \\\n\t\t     \"-DL2_SIZE=262144 -DL2_LINESIZE=32 \" \\\n\t\t     \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 \" \\\n\t\t     \"-DHAVE_CMOV -DHAVE_MMX -DHAVE_SSE \"\n#define LIBNAME   \"coppermine\"\n#define CORENAME  \"COPPERMINE\"\n#endif\n\n#ifdef FORCE_NORTHWOOD\n#define FORCE\n#define FORCE_INTEL\n#define ARCHITECTURE    \"X86\"\n#define SUBARCHITECTURE \"PENTIUM4\"\n#define ARCHCONFIG   \"-DPENTIUM4 \" \\\n\t\t     \"-DL1_DATA_SIZE=8192 -DL1_DATA_LINESIZE=64 \" \\\n\t\t     \"-DL2_SIZE=524288 -DL2_LINESIZE=64 \" \\\n\t\t     \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 -DL2_ASSOCIATIVE=8 \" \\\n\t\t     \"-DHAVE_CMOV -DHAVE_MMX -DHAVE_SSE -DHAVE_SSE2 \"\n#define LIBNAME   \"northwood\"\n#define CORENAME  \"NORTHWOOD\"\n#endif\n\n#ifdef FORCE_PRESCOTT\n#define FORCE\n#define FORCE_INTEL\n#define ARCHITECTURE    \"X86\"\n#define SUBARCHITECTURE \"PENTIUM4\"\n#define ARCHCONFIG   \"-DPENTIUM4 \" \\\n\t\t     \"-DL1_DATA_SIZE=16384 -DL1_DATA_LINESIZE=64 \" \\\n\t\t     \"-DL2_SIZE=1048576 -DL2_LINESIZE=64 \" \\\n\t\t     \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 -DL2_ASSOCIATIVE=8 \" \\\n\t\t     \"-DHAVE_CMOV -DHAVE_MMX -DHAVE_SSE -DHAVE_SSE2 -DHAVE_SSE3\"\n#define LIBNAME   \"prescott\"\n#define CORENAME  \"PRESCOTT\"\n#endif\n\n#ifdef FORCE_BANIAS\n#define FORCE\n#define FORCE_INTEL\n#define ARCHITECTURE    \"X86\"\n#define SUBARCHITECTURE \"BANIAS\"\n#define ARCHCONFIG   \"-DPENTIUMM \" \\\n\t\t     \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=64 \" \\\n\t\t     \"-DL2_SIZE=1048576 -DL2_LINESIZE=64 \" \\\n\t\t     \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 \" \\\n\t\t     \"-DHAVE_CMOV -DHAVE_MMX -DHAVE_SSE -DHAVE_SSE2 \"\n#define LIBNAME   \"banias\"\n#define CORENAME  \"BANIAS\"\n#endif\n\n#ifdef FORCE_YONAH\n#define FORCE\n#define FORCE_INTEL\n#define ARCHITECTURE    \"X86\"\n#define SUBARCHITECTURE \"YONAH\"\n#define ARCHCONFIG   \"-DPENTIUMM \" \\\n\t\t     \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=64 \" \\\n\t\t     \"-DL2_SIZE=1048576 -DL2_LINESIZE=64 \" \\\n\t\t     \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 \" \\\n\t\t     \"-DHAVE_CMOV -DHAVE_MMX -DHAVE_SSE -DHAVE_SSE2 \"\n#define LIBNAME   \"yonah\"\n#define CORENAME  \"YONAH\"\n#endif\n\n#ifdef FORCE_CORE2\n#define FORCE\n#define FORCE_INTEL\n#define ARCHITECTURE    \"X86\"\n#define SUBARCHITECTURE \"CONRORE\"\n#define ARCHCONFIG   \"-DCORE2 \" \\\n\t\t     \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=64 \" \\\n\t\t     \"-DL2_SIZE=1048576 -DL2_LINESIZE=64 \" \\\n\t\t     \"-DDTB_DEFAULT_ENTRIES=256 -DDTB_SIZE=4096 \" \\\n\t\t     \"-DHAVE_CMOV -DHAVE_MMX -DHAVE_SSE -DHAVE_SSE2 -DHAVE_SSE3 -DHAVE_SSSE3\"\n#define LIBNAME   \"core2\"\n#define CORENAME  \"CORE2\"\n#endif\n\n#ifdef FORCE_PENRYN\n#define FORCE\n#define FORCE_INTEL\n#define ARCHITECTURE    \"X86\"\n#define SUBARCHITECTURE \"PENRYN\"\n#define ARCHCONFIG   \"-DPENRYN \" \\\n\t\t     \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=64 \" \\\n\t\t     \"-DL2_SIZE=1048576 -DL2_LINESIZE=64 \" \\\n\t\t     \"-DDTB_DEFAULT_ENTRIES=256 -DDTB_SIZE=4096 \" \\\n\t\t     \"-DHAVE_CMOV -DHAVE_MMX -DHAVE_SSE -DHAVE_SSE2 -DHAVE_SSE3 -DHAVE_SSSE3 -DHAVE_SSE4_1\"\n#define LIBNAME   \"penryn\"\n#define CORENAME  \"PENRYN\"\n#endif\n\n#ifdef FORCE_DUNNINGTON\n#define FORCE\n#define FORCE_INTEL\n#define ARCHITECTURE    \"X86\"\n#define SUBARCHITECTURE \"DUNNINGTON\"\n#define ARCHCONFIG   \"-DDUNNINGTON \" \\\n\t\t     \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=64 \" \\\n\t\t     \"-DL2_SIZE=1048576 -DL2_LINESIZE=64 \" \\\n\t\t     \"-DL3_SIZE=16777216 -DL3_LINESIZE=64 \" \\\n\t\t     \"-DDTB_DEFAULT_ENTRIES=256 -DDTB_SIZE=4096 \" \\\n\t\t     \"-DHAVE_CMOV -DHAVE_MMX -DHAVE_SSE -DHAVE_SSE2 -DHAVE_SSE3 -DHAVE_SSSE3 -DHAVE_SSE4_1\"\n#define LIBNAME   \"dunnington\"\n#define CORENAME  \"DUNNINGTON\"\n#endif\n\n#ifdef FORCE_NEHALEM\n#define FORCE\n#define FORCE_INTEL\n#define ARCHITECTURE    \"X86\"\n#define SUBARCHITECTURE \"NEHALEM\"\n#define ARCHCONFIG   \"-DNEHALEM \" \\\n\t\t     \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=64 \" \\\n\t\t     \"-DL2_SIZE=262144 -DL2_LINESIZE=64 \" \\\n\t\t     \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 \" \\\n\t\t     \"-DHAVE_CMOV -DHAVE_MMX -DHAVE_SSE -DHAVE_SSE2 -DHAVE_SSE3 -DHAVE_SSSE3 -DHAVE_SSE4_1 -DHAVE_SSE4_2\"\n#define LIBNAME   \"nehalem\"\n#define CORENAME  \"NEHALEM\"\n#endif\n\n#ifdef FORCE_SANDYBRIDGE\n#define FORCE\n#define FORCE_INTEL\n#define ARCHITECTURE    \"X86\"\n#ifdef NO_AVX \n#define SUBARCHITECTURE \"NEHALEM\"\n#define ARCHCONFIG   \"-DNEHALEM \" \\\n\t\t     \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=64 \" \\\n\t\t     \"-DL2_SIZE=262144 -DL2_LINESIZE=64 \" \\\n\t\t     \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 \" \\\n\t\t     \"-DHAVE_CMOV -DHAVE_MMX -DHAVE_SSE -DHAVE_SSE2 -DHAVE_SSE3 -DHAVE_SSSE3 -DHAVE_SSE4_1 -DHAVE_SSE4_2\"\n#define LIBNAME   \"nehalem\"\n#define CORENAME  \"NEHALEM\"\n#else\n#define SUBARCHITECTURE \"SANDYBRIDGE\"\n#define ARCHCONFIG   \"-DSANDYBRIDGE \" \\\n\t\t     \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=64 \" \\\n\t\t     \"-DL2_SIZE=262144 -DL2_LINESIZE=64 \" \\\n\t\t     \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 \" \\\n\t\t     \"-DHAVE_CMOV -DHAVE_MMX -DHAVE_SSE -DHAVE_SSE2 -DHAVE_SSE3 -DHAVE_SSSE3 -DHAVE_SSE4_1 -DHAVE_SSE4_2 -DHAVE_AVX\"\n#define LIBNAME   \"sandybridge\"\n#define CORENAME  \"SANDYBRIDGE\"\n#endif\n#endif\n\n#ifdef FORCE_HASWELL\n#define FORCE\n#define FORCE_INTEL\n#define ARCHITECTURE    \"X86\"\n#ifdef NO_AVX2\n#ifdef NO_AVX\n#define SUBARCHITECTURE \"NEHALEM\"\n#define ARCHCONFIG   \"-DNEHALEM \" \\\n\t\t     \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=64 \" \\\n\t\t     \"-DL2_SIZE=262144 -DL2_LINESIZE=64 \" \\\n\t\t     \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 \" \\\n\t\t     \"-DHAVE_CMOV -DHAVE_MMX -DHAVE_SSE -DHAVE_SSE2 -DHAVE_SSE3 -DHAVE_SSSE3 -DHAVE_SSE4_1 -DHAVE_SSE4_2\"\n#define LIBNAME   \"nehalem\"\n#define CORENAME  \"NEHALEM\"\n#else\n#define SUBARCHITECTURE \"SANDYBRIDGE\"\n#define ARCHCONFIG   \"-DSANDYBRIDGE \" \\\n\t\t     \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=64 \" \\\n\t\t     \"-DL2_SIZE=262144 -DL2_LINESIZE=64 \" \\\n\t\t     \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 \" \\\n\t\t     \"-DHAVE_CMOV -DHAVE_MMX -DHAVE_SSE -DHAVE_SSE2 -DHAVE_SSE3 -DHAVE_SSSE3 -DHAVE_SSE4_1 -DHAVE_SSE4_2 -DHAVE_AVX\"\n#define LIBNAME   \"sandybridge\"\n#define CORENAME  \"SANDYBRIDGE\"\n#endif\n#else\n#define SUBARCHITECTURE \"HASWELL\"\n#define ARCHCONFIG   \"-DHASWELL \" \\\n\t\t     \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=64 \" \\\n\t\t     \"-DL2_SIZE=262144 -DL2_LINESIZE=64 \" \\\n\t\t     \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 \" \\\n\t\t     \"-DHAVE_CMOV -DHAVE_MMX -DHAVE_SSE -DHAVE_SSE2 -DHAVE_SSE3 -DHAVE_SSSE3 -DHAVE_SSE4_1 -DHAVE_SSE4_2 -DHAVE_AVX \" \\\n                     \"-DHAVE_AVX2 -DHAVE_FMA3 -DFMA3\"\n#define LIBNAME   \"haswell\"\n#define CORENAME  \"HASWELL\"\n#endif\n#endif\n\n#ifdef FORCE_SKYLAKEX\n#define FORCE\n#define FORCE_INTEL\n#define ARCHITECTURE    \"X86\"\n#ifdef NO_AVX512\n#ifdef NO_AVX2\n#ifdef NO_AVX\n#define SUBARCHITECTURE \"NEHALEM\"\n#define ARCHCONFIG   \"-DNEHALEM \" \\\n\t\t     \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=64 \" \\\n\t\t     \"-DL2_SIZE=262144 -DL2_LINESIZE=64 \" \\\n\t\t     \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 \" \\\n\t\t     \"-DHAVE_CMOV -DHAVE_MMX -DHAVE_SSE -DHAVE_SSE2 -DHAVE_SSE3 -DHAVE_SSSE3 -DHAVE_SSE4_1 -DHAVE_SSE4_2\"\n#define LIBNAME   \"nehalem\"\n#define CORENAME  \"NEHALEM\"\n#else\n#define SUBARCHITECTURE \"SANDYBRIDGE\"\n#define ARCHCONFIG   \"-DSANDYBRIDGE \" \\\n\t\t     \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=64 \" \\\n\t\t     \"-DL2_SIZE=262144 -DL2_LINESIZE=64 \" \\\n\t\t     \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 \" \\\n\t\t     \"-DHAVE_CMOV -DHAVE_MMX -DHAVE_SSE -DHAVE_SSE2 -DHAVE_SSE3 -DHAVE_SSSE3 -DHAVE_SSE4_1 -DHAVE_SSE4_2 -DHAVE_AVX\"\n#define LIBNAME   \"sandybridge\"\n#define CORENAME  \"SANDYBRIDGE\"\n#endif\n#else\n#define SUBARCHITECTURE \"HASWELL\"\n#define ARCHCONFIG   \"-DHASWELL \" \\\n\t\t     \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=64 \" \\\n\t\t     \"-DL2_SIZE=262144 -DL2_LINESIZE=64 \" \\\n\t\t     \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 \" \\\n\t\t     \"-DHAVE_CMOV -DHAVE_MMX -DHAVE_SSE -DHAVE_SSE2 -DHAVE_SSE3 -DHAVE_SSSE3 -DHAVE_SSE4_1 -DHAVE_SSE4_2 -DHAVE_AVX \" \\\n                     \"-DHAVE_AVX2 -DHAVE_FMA3 -DFMA3\"\n#define LIBNAME   \"haswell\"\n#define CORENAME  \"HASWELL\"\n#endif\n#else\n#define SUBARCHITECTURE \"SKYLAKEX\"\n#define ARCHCONFIG   \"-DSKYLAKEX \" \\\n\t\t     \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=64 \" \\\n\t\t     \"-DL2_SIZE=262144 -DL2_LINESIZE=64 \" \\\n\t\t     \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 \" \\\n\t\t     \"-DHAVE_CMOV -DHAVE_MMX -DHAVE_SSE -DHAVE_SSE2 -DHAVE_SSE3 -DHAVE_SSSE3 -DHAVE_SSE4_1 -DHAVE_SSE4_2 -DHAVE_AVX \" \\\n                     \"-DHAVE_AVX2 -DHAVE_FMA3 -DFMA3 -DHAVE_AVX512VL -march=skylake-avx512\"\n#define LIBNAME   \"skylakex\"\n#define CORENAME  \"SKYLAKEX\"\n#endif\n#endif\n\n#ifdef FORCE_COOPERLAKE\n#define FORCE\n#define FORCE_INTEL\n#define ARCHITECTURE    \"X86\"\n#ifdef NO_AVX512\n#ifdef NO_AVX2\n#ifdef NO_AVX\n#define SUBARCHITECTURE \"NEHALEM\"\n#define ARCHCONFIG   \"-DNEHALEM \" \\\n\t\t     \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=64 \" \\\n\t\t     \"-DL2_SIZE=262144 -DL2_LINESIZE=64 \" \\\n\t\t     \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 \" \\\n\t\t     \"-DHAVE_CMOV -DHAVE_MMX -DHAVE_SSE -DHAVE_SSE2 -DHAVE_SSE3 -DHAVE_SSSE3 -DHAVE_SSE4_1 -DHAVE_SSE4_2\"\n#define LIBNAME   \"nehalem\"\n#define CORENAME  \"NEHALEM\"\n#else\n#define SUBARCHITECTURE \"SANDYBRIDGE\"\n#define ARCHCONFIG   \"-DSANDYBRIDGE \" \\\n\t\t     \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=64 \" \\\n\t\t     \"-DL2_SIZE=262144 -DL2_LINESIZE=64 \" \\\n\t\t     \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 \" \\\n\t\t     \"-DHAVE_CMOV -DHAVE_MMX -DHAVE_SSE -DHAVE_SSE2 -DHAVE_SSE3 -DHAVE_SSSE3 -DHAVE_SSE4_1 -DHAVE_SSE4_2 -DHAVE_AVX\"\n#define LIBNAME   \"sandybridge\"\n#define CORENAME  \"SANDYBRIDGE\"\n#endif\n#else\n#define SUBARCHITECTURE \"HASWELL\"\n#define ARCHCONFIG   \"-DHASWELL \" \\\n                     \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=64 \" \\\n                     \"-DL2_SIZE=262144 -DL2_LINESIZE=64 \" \\\n                     \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 \" \\\n                     \"-DHAVE_CMOV -DHAVE_MMX -DHAVE_SSE -DHAVE_SSE2 -DHAVE_SSE3 -DHAVE_SSSE3 -DHAVE_SSE4_1 -DHAVE_SSE4_2 -DHAVE_AVX \" \\\n                     \"-DHAVE_AVX2 -DHAVE_FMA3 -DFMA3\"\n#define LIBNAME   \"haswell\"\n#define CORENAME  \"HASWELL\"\n#endif\n#else\n#define SUBARCHITECTURE \"COOPERLAKE\"\n#define ARCHCONFIG   \"-DCOOPERLAKE \" \\\n                     \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=64 \" \\\n                     \"-DL2_SIZE=262144 -DL2_LINESIZE=64 \" \\\n                     \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 \" \\\n                     \"-DHAVE_CMOV -DHAVE_MMX -DHAVE_SSE -DHAVE_SSE2 -DHAVE_SSE3 -DHAVE_SSSE3 -DHAVE_SSE4_1 -DHAVE_SSE4_2 -DHAVE_AVX \" \\\n                     \"-DHAVE_AVX2 -DHAVE_FMA3 -DFMA3 -DHAVE_AVX512VL -DHAVE_AVX512BF16 -march=cooperlake\"\n#define LIBNAME   \"cooperlake\"\n#define CORENAME  \"COOPERLAKE\"\n#endif\n#endif\n\n#ifdef FORCE_SAPPHIRERAPIDS\n#define FORCE\n#define FORCE_INTEL\n#define ARCHITECTURE    \"X86\"\n#ifdef NO_AVX512\n#ifdef NO_AVX2\n#ifdef NO_AVX\n#define SUBARCHITECTURE \"NEHALEM\"\n#define ARCHCONFIG   \"-DNEHALEM \" \\\n\t\t     \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=64 \" \\\n\t\t     \"-DL2_SIZE=262144 -DL2_LINESIZE=64 \" \\\n\t\t     \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 \" \\\n\t\t     \"-DHAVE_CMOV -DHAVE_MMX -DHAVE_SSE -DHAVE_SSE2 -DHAVE_SSE3 -DHAVE_SSSE3 -DHAVE_SSE4_1 -DHAVE_SSE4_2\"\n#define LIBNAME   \"nehalem\"\n#define CORENAME  \"NEHALEM\"\n#else\n#define SUBARCHITECTURE \"SANDYBRIDGE\"\n#define ARCHCONFIG   \"-DSANDYBRIDGE \" \\\n\t\t     \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=64 \" \\\n\t\t     \"-DL2_SIZE=262144 -DL2_LINESIZE=64 \" \\\n\t\t     \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 \" \\\n\t\t     \"-DHAVE_CMOV -DHAVE_MMX -DHAVE_SSE -DHAVE_SSE2 -DHAVE_SSE3 -DHAVE_SSSE3 -DHAVE_SSE4_1 -DHAVE_SSE4_2 -DHAVE_AVX\"\n#define LIBNAME   \"sandybridge\"\n#define CORENAME  \"SANDYBRIDGE\"\n#endif\n#else\n#define SUBARCHITECTURE \"HASWELL\"\n#define ARCHCONFIG   \"-DHASWELL \" \\\n                     \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=64 \" \\\n                     \"-DL2_SIZE=262144 -DL2_LINESIZE=64 \" \\\n                     \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 \" \\\n                     \"-DHAVE_CMOV -DHAVE_MMX -DHAVE_SSE -DHAVE_SSE2 -DHAVE_SSE3 -DHAVE_SSSE3 -DHAVE_SSE4_1 -DHAVE_SSE4_2 -DHAVE_AVX \" \\\n                     \"-DHAVE_AVX2 -DHAVE_FMA3 -DFMA3\"\n#define LIBNAME   \"haswell\"\n#define CORENAME  \"HASWELL\"\n#endif\n#else\n#define SUBARCHITECTURE \"SAPPHIRERAPIDS\"\n#define ARCHCONFIG   \"-DSAPPHIRERAPIDS \" \\\n                     \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=64 \" \\\n                     \"-DL2_SIZE=262144 -DL2_LINESIZE=64 \" \\\n                     \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 \" \\\n                     \"-DHAVE_CMOV -DHAVE_MMX -DHAVE_SSE -DHAVE_SSE2 -DHAVE_SSE3 -DHAVE_SSSE3 -DHAVE_SSE4_1 -DHAVE_SSE4_2 -DHAVE_AVX \" \\\n                     \"-DHAVE_AVX2 -DHAVE_FMA3 -DFMA3 -DHAVE_AVX512VL -DHAVE_AVX512BF16 -march=sapphirerapids\"\n#define LIBNAME   \"sapphirerapids\"\n#define CORENAME  \"SAPPHIRERAPIDS\"\n#endif\n#endif\n\n#ifdef FORCE_ATOM\n#define FORCE\n#define FORCE_INTEL\n#define ARCHITECTURE    \"X86\"\n#define SUBARCHITECTURE \"ATOM\"\n#define ARCHCONFIG   \"-DATOM \" \\\n\t\t     \"-DL1_DATA_SIZE=24576 -DL1_DATA_LINESIZE=64 \" \\\n\t\t     \"-DL2_SIZE=524288 -DL2_LINESIZE=64 \" \\\n\t\t     \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 -DL2_ASSOCIATIVE=4 \" \\\n\t\t     \"-DHAVE_CMOV -DHAVE_MMX -DHAVE_SSE -DHAVE_SSE2 -DHAVE_SSE3 -DHAVE_SSSE3\"\n#define LIBNAME   \"atom\"\n#define CORENAME  \"ATOM\"\n#endif\n\n#ifdef FORCE_ATHLON\n#define FORCE\n#define FORCE_INTEL\n#define ARCHITECTURE    \"X86\"\n#define SUBARCHITECTURE \"ATHLON\"\n#define ARCHCONFIG   \"-DATHLON \" \\\n\t\t     \"-DL1_DATA_SIZE=65536 -DL1_DATA_LINESIZE=64 \" \\\n\t\t     \"-DL2_SIZE=1048576 -DL2_LINESIZE=64 \" \\\n\t\t     \"-DDTB_DEFAULT_ENTRIES=32 -DDTB_SIZE=4096 -DHAVE_3DNOW  \" \\\n\t\t     \"-DHAVE_3DNOWEX -DHAVE_MMX -DHAVE_SSE \"\n#define LIBNAME   \"athlon\"\n#define CORENAME  \"ATHLON\"\n#endif\n\n#ifdef FORCE_OPTERON\n#define FORCE\n#define FORCE_INTEL\n#define ARCHITECTURE    \"X86\"\n#define SUBARCHITECTURE \"OPTERON\"\n#define ARCHCONFIG   \"-DOPTERON \" \\\n\t\t     \"-DL1_DATA_SIZE=65536 -DL1_DATA_LINESIZE=64 \" \\\n\t\t     \"-DL2_SIZE=1048576 -DL2_LINESIZE=64 \" \\\n\t\t     \"-DDTB_DEFAULT_ENTRIES=32 -DDTB_SIZE=4096 -DHAVE_3DNOW \" \\\n\t\t     \"-DHAVE_3DNOWEX -DHAVE_MMX -DHAVE_SSE -DHAVE_SSE2 \"\n#define LIBNAME   \"opteron\"\n#define CORENAME  \"OPTERON\"\n#endif\n\n#ifdef FORCE_OPTERON_SSE3\n#define FORCE\n#define FORCE_INTEL\n#define ARCHITECTURE    \"X86\"\n#define SUBARCHITECTURE \"OPTERON\"\n#define ARCHCONFIG   \"-DOPTERON \" \\\n\t\t     \"-DL1_DATA_SIZE=65536 -DL1_DATA_LINESIZE=64 \" \\\n\t\t     \"-DL2_SIZE=1048576 -DL2_LINESIZE=64 \" \\\n\t\t     \"-DDTB_DEFAULT_ENTRIES=32 -DDTB_SIZE=4096 -DHAVE_3DNOW \" \\\n\t\t     \"-DHAVE_3DNOWEX -DHAVE_MMX -DHAVE_SSE -DHAVE_SSE2 -DHAVE_SSE3\"\n#define LIBNAME   \"opteron\"\n#define CORENAME  \"OPTERON\"\n#endif\n\n#if defined(FORCE_BARCELONA) || defined(FORCE_SHANGHAI) || defined(FORCE_ISTANBUL)\n#define FORCE\n#define FORCE_INTEL\n#define ARCHITECTURE    \"X86\"\n#define SUBARCHITECTURE \"BARCELONA\"\n#define ARCHCONFIG   \"-DBARCELONA \" \\\n\t\t     \"-DL1_DATA_SIZE=65536 -DL1_DATA_LINESIZE=64 \" \\\n\t\t     \"-DL2_SIZE=524288 -DL2_LINESIZE=64  -DL3_SIZE=2097152 \" \\\n\t\t     \"-DDTB_DEFAULT_ENTRIES=48 -DDTB_SIZE=4096 \" \\\n\t\t     \"-DHAVE_MMX -DHAVE_SSE -DHAVE_SSE2 -DHAVE_SSE3 \" \\\n\t\t     \"-DHAVE_SSE4A -DHAVE_MISALIGNSSE -DHAVE_128BITFPU -DHAVE_FASTMOVU\"\n#define LIBNAME   \"barcelona\"\n#define CORENAME  \"BARCELONA\"\n#endif\n\n#if defined(FORCE_BOBCAT)\n#define FORCE\n#define FORCE_INTEL\n#define ARCHITECTURE    \"X86\"\n#define SUBARCHITECTURE \"BOBCAT\"\n#define ARCHCONFIG   \"-DBOBCAT \" \\\n\t\t     \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=64 \" \\\n\t\t     \"-DL2_SIZE=524288 -DL2_LINESIZE=64 \" \\\n\t\t     \"-DDTB_DEFAULT_ENTRIES=40 -DDTB_SIZE=4096 \" \\\n\t\t     \"-DHAVE_MMX -DHAVE_SSE -DHAVE_SSE2 -DHAVE_SSE3 -DHAVE_SSSE3 \" \\\n\t\t     \"-DHAVE_SSE4A -DHAVE_MISALIGNSSE -DHAVE_CFLUSH -DHAVE_CMOV\"\n#define LIBNAME   \"bobcat\"\n#define CORENAME  \"BOBCAT\"\n#endif\n\n#if defined (FORCE_BULLDOZER)\n#define FORCE\n#define FORCE_INTEL\n#define ARCHITECTURE    \"X86\"\n#define SUBARCHITECTURE \"BULLDOZER\"\n#define ARCHCONFIG   \"-DBULLDOZER \" \\\n\t\t     \"-DL1_DATA_SIZE=49152 -DL1_DATA_LINESIZE=64 \" \\\n\t\t     \"-DL2_SIZE=1024000 -DL2_LINESIZE=64  -DL3_SIZE=16777216 \" \\\n\t\t     \"-DDTB_DEFAULT_ENTRIES=32 -DDTB_SIZE=4096 \" \\\n\t\t     \"-DHAVE_MMX -DHAVE_SSE -DHAVE_SSE2 -DHAVE_SSE3 \" \\\n\t\t     \"-DHAVE_SSE4A -DHAVE_MISALIGNSSE -DHAVE_128BITFPU -DHAVE_FASTMOVU \" \\\n                     \"-DHAVE_AVX\"\n#define LIBNAME   \"bulldozer\"\n#define CORENAME  \"BULLDOZER\"\n#endif\n\n#if defined (FORCE_PILEDRIVER)\n#define FORCE\n#define FORCE_INTEL\n#define ARCHITECTURE    \"X86\"\n#define SUBARCHITECTURE \"PILEDRIVER\"\n#define ARCHCONFIG   \"-DPILEDRIVER \" \\\n\t\t     \"-DL1_DATA_SIZE=16384 -DL1_DATA_LINESIZE=64 \" \\\n\t\t     \"-DL2_SIZE=2097152 -DL2_LINESIZE=64  -DL3_SIZE=12582912 \" \\\n\t\t     \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 \" \\\n\t\t     \"-DHAVE_MMX -DHAVE_SSE -DHAVE_SSE2 -DHAVE_SSE3 -DHAVE_SSE4_1 -DHAVE_SSE4_2 \" \\\n\t\t     \"-DHAVE_SSE4A -DHAVE_MISALIGNSSE -DHAVE_128BITFPU -DHAVE_FASTMOVU -DHAVE_CFLUSH \" \\\n                     \"-DHAVE_AVX -DHAVE_FMA3\"\n#define LIBNAME   \"piledriver\"\n#define CORENAME  \"PILEDRIVER\"\n#endif\n\n#if defined (FORCE_STEAMROLLER)\n#define FORCE\n#define FORCE_INTEL\n#define ARCHITECTURE    \"X86\"\n#define SUBARCHITECTURE \"STEAMROLLER\"\n#define ARCHCONFIG   \"-DSTEAMROLLER \" \\\n\t\t     \"-DL1_DATA_SIZE=16384 -DL1_DATA_LINESIZE=64 \" \\\n\t\t     \"-DL2_SIZE=2097152 -DL2_LINESIZE=64  -DL3_SIZE=12582912 \" \\\n\t\t     \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 \" \\\n\t\t     \"-DHAVE_MMX -DHAVE_SSE -DHAVE_SSE2 -DHAVE_SSE3 -DHAVE_SSE4_1 -DHAVE_SSE4_2 \" \\\n\t\t     \"-DHAVE_SSE4A -DHAVE_MISALIGNSSE -DHAVE_128BITFPU -DHAVE_FASTMOVU -DHAVE_CFLUSH \" \\\n                     \"-DHAVE_AVX -DHAVE_FMA3\"\n#define LIBNAME   \"steamroller\"\n#define CORENAME  \"STEAMROLLER\"\n#endif\n\n#if defined (FORCE_EXCAVATOR)\n#define FORCE\n#define FORCE_INTEL\n#define ARCHITECTURE    \"X86\"\n#define SUBARCHITECTURE \"EXCAVATOR\"\n#define ARCHCONFIG   \"-DEXCAVATOR \" \\\n\t\t     \"-DL1_DATA_SIZE=16384 -DL1_DATA_LINESIZE=64 \" \\\n\t\t     \"-DL2_SIZE=2097152 -DL2_LINESIZE=64  -DL3_SIZE=12582912 \" \\\n\t\t     \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 \" \\\n\t\t     \"-DHAVE_MMX -DHAVE_SSE -DHAVE_SSE2 -DHAVE_SSE3 -DHAVE_SSE4_1 -DHAVE_SSE4_2 \" \\\n\t\t     \"-DHAVE_SSE4A -DHAVE_MISALIGNSSE -DHAVE_128BITFPU -DHAVE_FASTMOVU -DHAVE_CFLUSH \" \\\n                     \"-DHAVE_AVX -DHAVE_FMA3\"\n#define LIBNAME   \"excavator\"\n#define CORENAME  \"EXCAVATOR\"\n#endif\n\n#if defined (FORCE_ZEN)\n#define FORCE\n#define FORCE_INTEL\n#define ARCHITECTURE    \"X86\"\n#ifdef NO_AVX2\n#ifdef NO_AVX\n#define SUBARCHITECTURE \"NEHALEM\"\n#define ARCHCONFIG   \"-DNEHALEM \" \\\n\t\t     \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=64 \" \\\n\t\t     \"-DL2_SIZE=262144 -DL2_LINESIZE=64 \" \\\n\t\t     \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 \" \\\n\t\t     \"-DHAVE_CMOV -DHAVE_MMX -DHAVE_SSE -DHAVE_SSE2 -DHAVE_SSE3 -DHAVE_SSSE3 -DHAVE_SSE4_1 -DHAVE_SSE4_2\"\n#define LIBNAME   \"nehalem\"\n#define CORENAME  \"NEHALEM\"\n#else\n#define SUBARCHITECTURE \"SANDYBRIDGE\"\n#define ARCHCONFIG   \"-DSANDYBRIDGE \" \\\n\t\t     \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=64 \" \\\n\t\t     \"-DL2_SIZE=262144 -DL2_LINESIZE=64 \" \\\n\t\t     \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 \" \\\n\t\t     \"-DHAVE_CMOV -DHAVE_MMX -DHAVE_SSE -DHAVE_SSE2 -DHAVE_SSE3 -DHAVE_SSSE3 -DHAVE_SSE4_1 -DHAVE_SSE4_2 -DHAVE_AVX\"\n#define LIBNAME   \"sandybridge\"\n#define CORENAME  \"SANDYBRIDGE\"\n#endif\n#else\n#define SUBARCHITECTURE \"ZEN\"\n#define ARCHCONFIG   \"-DZEN \" \\\n\t\t     \"-DL1_CODE_SIZE=32768 -DL1_CODE_LINESIZE=64 -DL1_CODE_ASSOCIATIVE=8 \" \\\n\t\t     \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=64 -DL2_CODE_ASSOCIATIVE=8 \" \\\n\t\t     \"-DL2_SIZE=524288 -DL2_LINESIZE=64 -DL2_ASSOCIATIVE=8 \" \\\n\t\t     \"-DL3_SIZE=16777216 -DL3_LINESIZE=64 -DL3_ASSOCIATIVE=8 \" \\\n\t\t     \"-DITB_DEFAULT_ENTRIES=64 -DITB_SIZE=4096 \" \\\n\t\t     \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 \" \\\n\t\t     \"-DHAVE_MMX -DHAVE_SSE -DHAVE_SSE2 -DHAVE_SSE3 -DHAVE_SSE4_1 -DHAVE_SSE4_2 \" \\\n\t\t     \"-DHAVE_SSE4A -DHAVE_MISALIGNSSE -DHAVE_128BITFPU -DHAVE_FASTMOVU -DHAVE_CFLUSH \" \\\n\t\t     \"-DHAVE_AVX -DHAVE_AVX2 -DHAVE_FMA3 -DFMA3\"\n#define LIBNAME   \"zen\"\n#define CORENAME  \"ZEN\"\n#endif\n#endif\n\n\n#ifdef FORCE_SSE_GENERIC\n#define FORCE\n#define FORCE_INTEL\n#define ARCHITECTURE    \"X86\"\n#define SUBARCHITECTURE \"GENERIC\"\n#define ARCHCONFIG   \"-DGENERIC \" \\\n\t\t     \"-DL1_DATA_SIZE=16384 -DL1_DATA_LINESIZE=64 \" \\\n\t\t     \"-DL2_SIZE=524288 -DL2_LINESIZE=64 \" \\\n\t\t     \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 -DL2_ASSOCIATIVE=8 \" \\\n\t\t     \"-DHAVE_CMOV -DHAVE_MMX -DHAVE_SSE -DHAVE_SSE2\"\n#define LIBNAME   \"generic\"\n#define CORENAME  \"GENERIC\"\n#endif\n\n#ifdef FORCE_VIAC3\n#define FORCE\n#define FORCE_INTEL\n#define ARCHITECTURE    \"X86\"\n#define SUBARCHITECTURE \"VIAC3\"\n#define ARCHCONFIG   \"-DVIAC3 \" \\\n\t\t     \"-DL1_DATA_SIZE=65536 -DL1_DATA_LINESIZE=32 \" \\\n\t\t     \"-DL2_SIZE=65536 -DL2_LINESIZE=32 \" \\\n\t\t     \"-DDTB_DEFAULT_ENTRIES=128 -DDTB_SIZE=4096 \" \\\n\t\t     \"-DHAVE_MMX -DHAVE_SSE \"\n#define LIBNAME   \"viac3\"\n#define CORENAME  \"VIAC3\"\n#endif\n\n#ifdef FORCE_NANO\n#define FORCE\n#define FORCE_INTEL\n#define ARCHITECTURE    \"X86\"\n#define SUBARCHITECTURE \"NANO\"\n#define ARCHCONFIG   \"-DNANO \" \\\n\t\t     \"-DL1_DATA_SIZE=65536 -DL1_DATA_LINESIZE=64 \" \\\n\t\t     \"-DL2_SIZE=1048576 -DL2_LINESIZE=64 \" \\\n\t\t     \"-DDTB_DEFAULT_ENTRIES=128 -DDTB_SIZE=4096 -DL2_ASSOCIATIVE=8 \" \\\n\t\t     \"-DHAVE_CMOV -DHAVE_MMX -DHAVE_SSE -DHAVE_SSE2 -DHAVE_SSE3 -DHAVE_SSSE3\"\n#define LIBNAME   \"nano\"\n#define CORENAME  \"NANO\"\n#endif\n\n#ifdef FORCE_POWER3\n#define FORCE\n#define ARCHITECTURE    \"POWER\"\n#define SUBARCHITECTURE \"POWER3\"\n#define SUBDIRNAME      \"power\"\n#define ARCHCONFIG   \"-DPOWER3 \" \\\n\t\t     \"-DL1_DATA_SIZE=65536 -DL1_DATA_LINESIZE=128 \" \\\n\t\t     \"-DL2_SIZE=2097152 -DL2_LINESIZE=128 \" \\\n\t\t     \"-DDTB_DEFAULT_ENTRIES=256 -DDTB_SIZE=4096 -DL2_ASSOCIATIVE=8 \"\n#define LIBNAME   \"power3\"\n#define CORENAME  \"POWER3\"\n#endif\n\n#ifdef FORCE_POWER4\n#define FORCE\n#define ARCHITECTURE    \"POWER\"\n#define SUBARCHITECTURE \"POWER4\"\n#define SUBDIRNAME      \"power\"\n#define ARCHCONFIG   \"-DPOWER4 \" \\\n\t\t     \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=128 \" \\\n\t\t     \"-DL2_SIZE=1509949 -DL2_LINESIZE=128 \" \\\n\t\t     \"-DDTB_DEFAULT_ENTRIES=128 -DDTB_SIZE=4096 -DL2_ASSOCIATIVE=6 \"\n#define LIBNAME   \"power4\"\n#define CORENAME  \"POWER4\"\n#endif\n\n#ifdef FORCE_POWER5\n#define FORCE\n#define ARCHITECTURE    \"POWER\"\n#define SUBARCHITECTURE \"POWER5\"\n#define SUBDIRNAME      \"power\"\n#define ARCHCONFIG   \"-DPOWER5 \" \\\n\t\t     \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=128 \" \\\n\t\t     \"-DL2_SIZE=1509949 -DL2_LINESIZE=128 \" \\\n\t\t     \"-DDTB_DEFAULT_ENTRIES=128 -DDTB_SIZE=4096 -DL2_ASSOCIATIVE=6 \"\n#define LIBNAME   \"power5\"\n#define CORENAME  \"POWER5\"\n#endif\n\n#if defined(FORCE_POWER6) || defined(FORCE_POWER7)\n#define FORCE\n#define ARCHITECTURE    \"POWER\"\n#define SUBARCHITECTURE \"POWER6\"\n#define SUBDIRNAME      \"power\"\n#define ARCHCONFIG   \"-DPOWER6 \" \\\n\t\t     \"-DL1_DATA_SIZE=65536 -DL1_DATA_LINESIZE=128 \" \\\n\t\t     \"-DL2_SIZE=4194304 -DL2_LINESIZE=128 \" \\\n\t\t     \"-DDTB_DEFAULT_ENTRIES=128 -DDTB_SIZE=4096 -DL2_ASSOCIATIVE=8 \"\n#define LIBNAME   \"power6\"\n#define CORENAME  \"POWER6\"\n#endif\n\n#if defined(FORCE_POWER8) \n#define FORCE\n#define ARCHITECTURE    \"POWER\"\n#define SUBARCHITECTURE \"POWER8\"\n#define SUBDIRNAME      \"power\"\n#define ARCHCONFIG   \"-DPOWER8 \" \\\n\t\t     \"-DL1_DATA_SIZE=65536 -DL1_DATA_LINESIZE=128 \" \\\n\t\t     \"-DL2_SIZE=4194304 -DL2_LINESIZE=128 \" \\\n\t\t     \"-DDTB_DEFAULT_ENTRIES=128 -DDTB_SIZE=4096 -DL2_ASSOCIATIVE=8 \"\n#define LIBNAME   \"power8\"\n#define CORENAME  \"POWER8\"\n#endif\n\n#if defined(FORCE_POWER9) \n#define FORCE\n#define ARCHITECTURE    \"POWER\"\n#define SUBARCHITECTURE \"POWER9\"\n#define SUBDIRNAME      \"power\"\n#define ARCHCONFIG   \"-DPOWER9 \" \\\n\t\t     \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=128 \" \\\n\t\t     \"-DL2_SIZE=4194304 -DL2_LINESIZE=128 \" \\\n\t\t     \"-DDTB_DEFAULT_ENTRIES=128 -DDTB_SIZE=4096 -DL2_ASSOCIATIVE=8 \"\n#define LIBNAME   \"power9\"\n#define CORENAME  \"POWER9\"\n#endif\n\n#if defined(FORCE_POWER10)\n#define FORCE\n#define ARCHITECTURE    \"POWER\"\n#define SUBARCHITECTURE \"POWER10\"\n#define SUBDIRNAME      \"power\"\n#define ARCHCONFIG   \"-DPOWER10 \" \\\n\t\t     \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=128 \" \\\n\t\t     \"-DL2_SIZE=4194304 -DL2_LINESIZE=128 \" \\\n\t\t     \"-DDTB_DEFAULT_ENTRIES=128 -DDTB_SIZE=4096 -DL2_ASSOCIATIVE=8 \"\n#define LIBNAME   \"power10\"\n#define CORENAME  \"POWER10\"\n#endif\n\n#ifdef FORCE_PPCG4\n#define FORCE\n#define ARCHITECTURE    \"POWER\"\n#define SUBARCHITECTURE \"PPCG4\"\n#define SUBDIRNAME      \"power\"\n#define ARCHCONFIG   \"-DPPCG4 \" \\\n\t\t     \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=32 \" \\\n\t\t     \"-DL2_SIZE=262144 -DL2_LINESIZE=32 \" \\\n\t\t     \"-DDTB_DEFAULT_ENTRIES=128 -DDTB_SIZE=4096 -DL2_ASSOCIATIVE=8 \"\n#define LIBNAME   \"ppcg4\"\n#define CORENAME  \"PPCG4\"\n#endif\n\n#ifdef FORCE_PPC970\n#define FORCE\n#define ARCHITECTURE    \"POWER\"\n#define SUBARCHITECTURE \"PPC970\"\n#define SUBDIRNAME      \"power\"\n#define ARCHCONFIG   \"-DPPC970 \" \\\n\t\t     \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=128 \" \\\n\t\t     \"-DL2_SIZE=512488 -DL2_LINESIZE=128 \" \\\n\t\t     \"-DDTB_DEFAULT_ENTRIES=128 -DDTB_SIZE=4096 -DL2_ASSOCIATIVE=8 \"\n#define LIBNAME   \"ppc970\"\n#define CORENAME  \"PPC970\"\n#endif\n\n#ifdef FORCE_PPC970MP\n#define FORCE\n#define ARCHITECTURE    \"POWER\"\n#define SUBARCHITECTURE \"PPC970\"\n#define SUBDIRNAME      \"power\"\n#define ARCHCONFIG   \"-DPPC970 \" \\\n\t\t     \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=128 \" \\\n\t\t     \"-DL2_SIZE=1024976 -DL2_LINESIZE=128 \" \\\n\t\t     \"-DDTB_DEFAULT_ENTRIES=128 -DDTB_SIZE=4096 -DL2_ASSOCIATIVE=8 \"\n#define LIBNAME   \"ppc970mp\"\n#define CORENAME  \"PPC970\"\n#endif\n\n#ifdef FORCE_PPC440\n#define FORCE\n#define ARCHITECTURE    \"POWER\"\n#define SUBARCHITECTURE \"PPC440\"\n#define SUBDIRNAME      \"power\"\n#define ARCHCONFIG   \"-DPPC440 \" \\\n\t\t     \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=32 \" \\\n\t\t     \"-DL2_SIZE=16384 -DL2_LINESIZE=128 \" \\\n\t\t     \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 -DL2_ASSOCIATIVE=16 \"\n#define LIBNAME   \"ppc440\"\n#define CORENAME  \"PPC440\"\n#endif\n\n#ifdef FORCE_PPC440FP2\n#define FORCE\n#define ARCHITECTURE    \"POWER\"\n#define SUBARCHITECTURE \"PPC440FP2\"\n#define SUBDIRNAME      \"power\"\n#define ARCHCONFIG   \"-DPPC440FP2 \" \\\n\t\t     \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=32 \" \\\n\t\t     \"-DL2_SIZE=16384 -DL2_LINESIZE=128 \" \\\n\t\t     \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 -DL2_ASSOCIATIVE=16 \"\n#define LIBNAME   \"ppc440FP2\"\n#define CORENAME  \"PPC440FP2\"\n#endif\n\n#ifdef FORCE_CELL\n#define FORCE\n#define ARCHITECTURE    \"POWER\"\n#define SUBARCHITECTURE \"CELL\"\n#define SUBDIRNAME      \"power\"\n#define ARCHCONFIG   \"-DCELL \" \\\n\t\t     \"-DL1_DATA_SIZE=262144 -DL1_DATA_LINESIZE=128 \" \\\n\t\t     \"-DL2_SIZE=512488 -DL2_LINESIZE=128 \" \\\n\t\t     \"-DDTB_DEFAULT_ENTRIES=128 -DDTB_SIZE=4096 -DL2_ASSOCIATIVE=8 \"\n#define LIBNAME   \"cell\"\n#define CORENAME  \"CELL\"\n#endif\n\n#ifdef FORCE_MIPS64_GENERIC\n#define FORCE\n#define ARCHITECTURE    \"MIPS\"\n#define SUBARCHITECTURE \"MIPS64_GENERIC\"\n#define SUBDIRNAME      \"mips64\"\n#define ARCHCONFIG   \"-DMIPS64_GENERIC \" \\\n       \"-DL1_DATA_SIZE=65536 -DL1_DATA_LINESIZE=32 \" \\\n       \"-DL2_SIZE=1048576 -DL2_LINESIZE=32 \" \\\n       \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 -DL2_ASSOCIATIVE=8 \"\n#define LIBNAME   \"mips64_generic\"\n#define CORENAME  \"MIPS64_GENERIC\"\n#else\n#endif\n\n#ifdef FORCE_SICORTEX\n#define FORCE\n#define ARCHITECTURE    \"MIPS\"\n#define SUBARCHITECTURE \"SICORTEX\"\n#define SUBDIRNAME      \"mips\"\n#define ARCHCONFIG   \"-DSICORTEX \" \\\n\t\t     \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=32 \" \\\n\t\t     \"-DL2_SIZE=512488 -DL2_LINESIZE=32 \" \\\n\t\t     \"-DDTB_DEFAULT_ENTRIES=32 -DDTB_SIZE=4096 -DL2_ASSOCIATIVE=8 \"\n#define LIBNAME   \"mips\"\n#define CORENAME  \"sicortex\"\n#endif\n\n\n#if defined FORCE_LOONGSON3R3 || defined FORCE_LOONGSON3A || defined FORCE_LOONGSON3B\n#define FORCE\n#define ARCHITECTURE    \"MIPS\"\n#define SUBARCHITECTURE \"LOONGSON3R3\"\n#define SUBDIRNAME      \"mips64\"\n#define ARCHCONFIG   \"-DLOONGSON3R3 \" \\\n       \"-DL1_DATA_SIZE=65536 -DL1_DATA_LINESIZE=32 \" \\\n       \"-DL2_SIZE=512488 -DL2_LINESIZE=32 \" \\\n       \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 -DL2_ASSOCIATIVE=4 \"\n#define LIBNAME   \"loongson3r3\"\n#define CORENAME  \"LOONGSON3R3\"\n#else\n#endif\n\n#ifdef FORCE_LOONGSON3R4\n#define FORCE\n#define ARCHITECTURE    \"MIPS\"\n#define SUBARCHITECTURE \"LOONGSON3R4\"\n#define SUBDIRNAME      \"mips64\"\n#define ARCHCONFIG   \"-DLOONGSON3R4 \" \\\n       \"-DL1_DATA_SIZE=65536 -DL1_DATA_LINESIZE=32 \" \\\n       \"-DL2_SIZE=512488 -DL2_LINESIZE=32 \" \\\n       \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 -DL2_ASSOCIATIVE=4 -DHAVE_MSA\"\n#define LIBNAME   \"loongson3r4\"\n#define CORENAME  \"LOONGSON3R4\"\n#else\n#endif\n\n#if defined(FORCE_LA464) || defined(FORCE_LOONGSON3R5)\n#define FORCE\n#define ARCHITECTURE    \"LOONGARCH\"\n#ifdef NO_LASX\n#ifdef NO_LSX\n#define SUBARCHITECTURE \"LA64_GENERIC\"\n#define SUBDIRNAME      \"loongarch64\"\n#define ARCHCONFIG   \"-DLA64_GENERIC \" \\\n       \"-DL1_DATA_SIZE=65536 -DL1_DATA_LINESIZE=64 \" \\\n       \"-DL2_SIZE=262144 -DL2_LINESIZE=64 \" \\\n       \"-DDTB_DEFAULT_ENTRIES=64 \"\n#define LIBNAME   \"la64_generic\"\n#define CORENAME  \"LA64_GENERIC\"\n#else\n#define SUBARCHITECTURE \"LA264\"\n#define SUBDIRNAME      \"loongarch64\"\n#define ARCHCONFIG   \"-DLA264 \" \\\n       \"-DL1_DATA_SIZE=65536 -DL1_DATA_LINESIZE=64 \" \\\n       \"-DL2_SIZE=262144 -DL2_LINESIZE=64 \" \\\n       \"-DDTB_DEFAULT_ENTRIES=64 \"\n#define LIBNAME   \"la264\"\n#define CORENAME  \"LA264\"\n#endif\n#else\n#define SUBARCHITECTURE \"LA464\"\n#define SUBDIRNAME      \"loongarch64\"\n#define ARCHCONFIG   \"-DLA464 \" \\\n       \"-DL1_DATA_SIZE=65536 -DL1_DATA_LINESIZE=64 \" \\\n       \"-DL2_SIZE=262144 -DL2_LINESIZE=64 \" \\\n       \"-DDTB_DEFAULT_ENTRIES=64 \"\n#define LIBNAME   \"la464\"\n#define CORENAME  \"LA464\"\n#endif\n#endif\n\n#if defined(FORCE_LA264) || defined(FORCE_LOONGSON2K1000)\n#define FORCE\n#define ARCHITECTURE    \"LOONGARCH\"\n#ifdef NO_LSX\n#define SUBARCHITECTURE \"LA64_GENERIC\"\n#define SUBDIRNAME      \"loongarch64\"\n#define ARCHCONFIG   \"-DLA64_GENERIC \" \\\n       \"-DL1_DATA_SIZE=65536 -DL1_DATA_LINESIZE=64 \" \\\n       \"-DL2_SIZE=262144 -DL2_LINESIZE=64 \" \\\n       \"-DDTB_DEFAULT_ENTRIES=64 \"\n#define LIBNAME   \"la64_generic\"\n#define CORENAME  \"LA64_GENERIC\"\n#else\n#define SUBARCHITECTURE \"LA264\"\n#define SUBDIRNAME      \"loongarch64\"\n#define ARCHCONFIG   \"-DLA264 \" \\\n       \"-DL1_DATA_SIZE=65536 -DL1_DATA_LINESIZE=64 \" \\\n       \"-DL2_SIZE=262144 -DL2_LINESIZE=64 \" \\\n       \"-DDTB_DEFAULT_ENTRIES=64 \"\n#define LIBNAME   \"la264\"\n#define CORENAME  \"LA264\"\n#endif\n#endif\n\n#if defined(FORCE_LA64_GENERIC) || defined(FORCE_LOONGSONGENERIC)\n#define FORCE\n#define ARCHITECTURE    \"LOONGARCH\"\n#define SUBARCHITECTURE \"LA64_GENERIC\"\n#define SUBDIRNAME      \"loongarch64\"\n#define ARCHCONFIG   \"-DLA64_GENERIC \" \\\n       \"-DL1_DATA_SIZE=65536 -DL1_DATA_LINESIZE=64 \" \\\n       \"-DL2_SIZE=262144 -DL2_LINESIZE=64 \" \\\n       \"-DDTB_DEFAULT_ENTRIES=64 \"\n#define LIBNAME   \"la64_generic\"\n#define CORENAME  \"LA64_GENERIC\"\n#endif\n\n#ifdef FORCE_I6400\n#define FORCE\n#define ARCHITECTURE    \"MIPS\"\n#define SUBARCHITECTURE \"I6400\"\n#define SUBDIRNAME      \"mips64\"\n#define ARCHCONFIG   \"-DI6400 \" \\\n       \"-DL1_DATA_SIZE=65536 -DL1_DATA_LINESIZE=32 \" \\\n       \"-DL2_SIZE=1048576 -DL2_LINESIZE=32 \" \\\n       \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 -DL2_ASSOCIATIVE=8 -DHAVE_MSA \" \n#define LIBNAME   \"i6400\"\n#define CORENAME  \"I6400\"\n#else\n#endif\n\n#ifdef FORCE_P6600\n#define FORCE\n#define ARCHITECTURE    \"MIPS\"\n#define SUBARCHITECTURE \"P6600\"\n#define SUBDIRNAME      \"mips64\"\n#define ARCHCONFIG   \"-DP6600 \" \\\n       \"-DL1_DATA_SIZE=65536 -DL1_DATA_LINESIZE=32 \" \\\n       \"-DL2_SIZE=1048576 -DL2_LINESIZE=32 \" \\\n       \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 -DL2_ASSOCIATIVE=8 \"\n#define LIBNAME   \"p6600\"\n#define CORENAME  \"P6600\"\n#else\n#endif\n\n#ifdef FORCE_P5600\n#define FORCE\n#define ARCHITECTURE    \"MIPS\"\n#define SUBARCHITECTURE \"P5600\"\n#define SUBDIRNAME      \"mips\"\n#define ARCHCONFIG   \"-DP5600 \" \\\n       \"-DL1_DATA_SIZE=65536 -DL1_DATA_LINESIZE=32 \" \\\n       \"-DL2_SIZE=1048576 -DL2_LINESIZE=32 \" \\\n       \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 -DL2_ASSOCIATIVE=8\"\n#define LIBNAME   \"p5600\"\n#define CORENAME  \"P5600\"\n#else\n#endif\n\n#ifdef FORCE_MIPS1004K\n#define FORCE\n#define ARCHITECTURE    \"MIPS\"\n#define SUBARCHITECTURE \"MIPS1004K\"\n#define SUBDIRNAME      \"mips\"\n#define ARCHCONFIG   \"-DMIPS1004K \" \\\n       \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=32 \" \\\n       \"-DL2_SIZE=262144 -DL2_LINESIZE=32 \" \\\n       \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 -DL2_ASSOCIATIVE=8\"\n#define LIBNAME   \"mips1004K\"\n#define CORENAME  \"MIPS1004K\"\n#else\n#endif\n\n#ifdef FORCE_MIPS24K\n#define FORCE\n#define ARCHITECTURE    \"MIPS\"\n#define SUBARCHITECTURE \"MIPS24K\"\n#define SUBDIRNAME      \"mips\"\n#define ARCHCONFIG   \"-DMIPS24K \" \\\n       \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=32 \" \\\n       \"-DL2_SIZE=32768 -DL2_LINESIZE=32 \" \\\n       \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 -DL2_ASSOCIATIVE=8\"\n#define LIBNAME   \"mips24K\"\n#define CORENAME  \"MIPS24K\"\n#else\n#endif\n\n#ifdef FORCE_I6500\n#define FORCE\n#define ARCHITECTURE    \"MIPS\"\n#define SUBARCHITECTURE \"I6500\"\n#define SUBDIRNAME      \"mips64\"\n#define ARCHCONFIG   \"-DI6500 \" \\\n       \"-DL1_DATA_SIZE=65536 -DL1_DATA_LINESIZE=32 \" \\\n       \"-DL2_SIZE=1048576 -DL2_LINESIZE=32 \" \\\n       \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 -DL2_ASSOCIATIVE=8 -DHAVE_MSA\"\n#define LIBNAME   \"i6500\"\n#define CORENAME  \"I6500\"\n#else\n#endif\n\n#ifdef FORCE_ITANIUM2\n#define FORCE\n#define ARCHITECTURE    \"IA64\"\n#define SUBARCHITECTURE \"ITANIUM2\"\n#define SUBDIRNAME      \"ia64\"\n#define ARCHCONFIG   \"-DITANIUM2 \" \\\n\t\t     \"-DL1_DATA_SIZE=262144 -DL1_DATA_LINESIZE=128 \" \\\n\t\t     \"-DL2_SIZE=1572864 -DL2_LINESIZE=128 -DDTB_SIZE=16384 -DDTB_DEFAULT_ENTRIES=128 \"\n#define LIBNAME   \"itanium2\"\n#define CORENAME  \"itanium2\"\n#endif\n\n#ifdef FORCE_SPARC\n#define FORCE\n#define ARCHITECTURE    \"SPARC\"\n#define SUBARCHITECTURE \"SPARC\"\n#define SUBDIRNAME      \"sparc\"\n#define ARCHCONFIG   \"-DSPARC -DV9 \" \\\n\t\t     \"-DL1_DATA_SIZE=65536 -DL1_DATA_LINESIZE=64 \" \\\n\t\t     \"-DL2_SIZE=1572864 -DL2_LINESIZE=64 -DDTB_SIZE=8192 -DDTB_DEFAULT_ENTRIES=64 \"\n#define LIBNAME   \"sparc\"\n#define CORENAME  \"sparc\"\n#endif\n\n#ifdef FORCE_SPARCV7\n#define FORCE\n#define ARCHITECTURE    \"SPARC\"\n#define SUBARCHITECTURE \"SPARC\"\n#define SUBDIRNAME      \"sparc\"\n#define ARCHCONFIG   \"-DSPARC -DV7 \" \\\n\t\t     \"-DL1_DATA_SIZE=65536 -DL1_DATA_LINESIZE=64 \" \\\n\t\t     \"-DL2_SIZE=1572864 -DL2_LINESIZE=64 -DDTB_SIZE=8192 -DDTB_DEFAULT_ENTRIES=64 \"\n#define LIBNAME   \"sparcv7\"\n#define CORENAME  \"sparcv7\"\n#endif\n\n#ifdef FORCE_GENERIC\n#define FORCE\n#define ARCHITECTURE    \"GENERIC\"\n#define SUBARCHITECTURE \"GENERIC\"\n#define SUBDIRNAME      \"generic\"\n#define ARCHCONFIG   \"-DGENERIC \" \\\n\t\t     \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=128 \" \\\n\t\t     \"-DL2_SIZE=512488 -DL2_LINESIZE=128 \" \\\n\t\t     \"-DDTB_DEFAULT_ENTRIES=128 -DDTB_SIZE=4096 -DL2_ASSOCIATIVE=8 \"\n#define LIBNAME   \"generic\"\n#define CORENAME  \"generic\"\n#endif\n\n#ifdef FORCE_ARMV7\n#define FORCE\n#define ARCHITECTURE    \"ARM\"\n#define SUBARCHITECTURE \"ARMV7\"\n#define SUBDIRNAME      \"arm\"\n#define ARCHCONFIG   \"-DARMV7 \" \\\n       \"-DL1_DATA_SIZE=65536 -DL1_DATA_LINESIZE=32 \" \\\n       \"-DL2_SIZE=512488 -DL2_LINESIZE=32 \" \\\n       \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 -DL2_ASSOCIATIVE=4 \" \\\n       \"-DHAVE_VFPV3 -DHAVE_VFP\"\n#define LIBNAME   \"armv7\"\n#define CORENAME  \"ARMV7\"\n#else\n#endif\n\n#ifdef FORCE_CORTEXA9\n#define FORCE\n#define ARCHITECTURE    \"ARM\"\n#define SUBARCHITECTURE \"CORTEXA9\"\n#define SUBDIRNAME      \"arm\"\n#define ARCHCONFIG   \"-DCORTEXA9 -DARMV7 \" \\\n       \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=32 \" \\\n       \"-DL2_SIZE=1048576 -DL2_LINESIZE=32 \" \\\n       \"-DDTB_DEFAULT_ENTRIES=128 -DDTB_SIZE=4096 -DL2_ASSOCIATIVE=4 \" \\\n       \"-DHAVE_VFPV3 -DHAVE_VFP -DHAVE_NEON\"\n#define LIBNAME   \"cortexa9\"\n#define CORENAME  \"CORTEXA9\"\n#else\n#endif\n\n#ifdef FORCE_RISCV64_GENERIC\n#define FORCE\n#define ARCHITECTURE    \"RISCV64\"\n#define SUBARCHITECTURE \"RISCV64_GENERIC\"\n#define SUBDIRNAME      \"riscv64\"\n#define ARCHCONFIG   \"-DRISCV64_GENERIC \" \\\n       \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=32 \" \\\n       \"-DL2_SIZE=1048576 -DL2_LINESIZE=32 \" \\\n       \"-DDTB_DEFAULT_ENTRIES=128 -DDTB_SIZE=4096 -DL2_ASSOCIATIVE=4 \"\n#define LIBNAME   \"riscv64_generic\"\n#define CORENAME  \"RISCV64_GENERIC\"\n#else\n#endif\n\n#ifdef FORCE_CORTEXA15\n#define FORCE\n#define ARCHITECTURE    \"ARM\"\n#define SUBARCHITECTURE \"CORTEXA15\"\n#define SUBDIRNAME      \"arm\"\n#define ARCHCONFIG   \"-DCORTEXA15 -DARMV7 \" \\\n       \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=32 \" \\\n       \"-DL2_SIZE=1048576 -DL2_LINESIZE=32 \" \\\n       \"-DDTB_DEFAULT_ENTRIES=128 -DDTB_SIZE=4096 -DL2_ASSOCIATIVE=4 \" \\\n       \"-DHAVE_VFPV3 -DHAVE_VFP -DHAVE_NEON\"\n#define LIBNAME   \"cortexa15\"\n#define CORENAME  \"CORTEXA15\"\n#else\n#endif\n\n#ifdef FORCE_ARMV6\n#define FORCE\n#define ARCHITECTURE    \"ARM\"\n#define SUBARCHITECTURE \"ARMV6\"\n#define SUBDIRNAME      \"arm\"\n#define ARCHCONFIG   \"-DARMV6 \" \\\n       \"-DL1_DATA_SIZE=65536 -DL1_DATA_LINESIZE=32 \" \\\n       \"-DL2_SIZE=512488 -DL2_LINESIZE=32 \" \\\n       \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 -DL2_ASSOCIATIVE=4 \" \\\n       \"-DHAVE_VFP\"\n#define LIBNAME   \"armv6\"\n#define CORENAME  \"ARMV6\"\n#else\n#endif\n\n#ifdef FORCE_ARMV5\n#define FORCE\n#define ARCHITECTURE    \"ARM\"\n#define SUBARCHITECTURE \"ARMV5\"\n#define SUBDIRNAME      \"arm\"\n#define ARCHCONFIG   \"-DARMV5 \" \\\n       \"-DL1_DATA_SIZE=65536 -DL1_DATA_LINESIZE=32 \" \\\n       \"-DL2_SIZE=512488 -DL2_LINESIZE=32 \" \\\n       \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 -DL2_ASSOCIATIVE=4 \"\n#define LIBNAME   \"armv5\"\n#define CORENAME  \"ARMV5\"\n#else\n#endif\n\n#ifdef FORCE_ARMV8SVE\n#define FORCE\n#define ARCHITECTURE    \"ARM64\"\n#define SUBARCHITECTURE \"ARMV8SVE\"\n#define SUBDIRNAME      \"arm64\"\n#define ARCHCONFIG   \"-DARMV8SVE \" \\\n       \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=64 \" \\\n       \"-DL2_SIZE=262144 -DL2_LINESIZE=64 \" \\\n       \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 -DL2_ASSOCIATIVE=32 \" \\\n       \"-DHAVE_VFPV4 -DHAVE_VFPV3 -DHAVE_VFP -DHAVE_NEON -DHAVE_SVE -DARMV8\"\n#define LIBNAME   \"armv8sve\"\n#define CORENAME  \"ARMV8SVE\"\n#endif\n\n\n#ifdef FORCE_ARMV8\n#define FORCE\n#define ARCHITECTURE    \"ARM64\"\n#define SUBARCHITECTURE \"ARMV8\"\n#define SUBDIRNAME      \"arm64\"\n#define ARCHCONFIG   \"-DARMV8 \" \\\n       \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=64 \" \\\n       \"-DL2_SIZE=262144 -DL2_LINESIZE=64 \" \\\n       \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 -DL2_ASSOCIATIVE=32 \" \\\n       \"-DHAVE_VFPV4 -DHAVE_VFPV3 -DHAVE_VFP -DHAVE_NEON -DARMV8\"\n#define LIBNAME   \"armv8\"\n#define CORENAME  \"ARMV8\"\n#endif\n\n#ifdef FORCE_CORTEXA53\n#define FORCE\n#define ARCHITECTURE    \"ARM64\"\n#define SUBARCHITECTURE \"CORTEXA53\"\n#define SUBDIRNAME      \"arm64\"\n#define ARCHCONFIG   \"-DCORTEXA53 \" \\\n       \"-DL1_CODE_SIZE=32768 -DL1_CODE_LINESIZE=64 -DL1_CODE_ASSOCIATIVE=3 \" \\\n       \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=64 -DL1_DATA_ASSOCIATIVE=2 \" \\\n       \"-DL2_SIZE=262144 -DL2_LINESIZE=64 -DL2_ASSOCIATIVE=16 \" \\\n       \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 \" \\\n       \"-DHAVE_VFPV4 -DHAVE_VFPV3 -DHAVE_VFP -DHAVE_NEON -DARMV8\"\n#define LIBNAME   \"cortexa53\"\n#define CORENAME  \"CORTEXA53\"\n#endif\n\n#ifdef FORCE_CORTEXA57\n#define FORCE\n#define ARCHITECTURE    \"ARM64\"\n#define SUBARCHITECTURE \"CORTEXA57\"\n#define SUBDIRNAME      \"arm64\"\n#define ARCHCONFIG   \"-DCORTEXA57 \" \\\n       \"-DL1_CODE_SIZE=49152 -DL1_CODE_LINESIZE=64 -DL1_CODE_ASSOCIATIVE=3 \" \\\n       \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=64 -DL1_DATA_ASSOCIATIVE=2 \" \\\n       \"-DL2_SIZE=2097152 -DL2_LINESIZE=64 -DL2_ASSOCIATIVE=16 \" \\\n       \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 \" \\\n       \"-DHAVE_VFPV4 -DHAVE_VFPV3 -DHAVE_VFP -DHAVE_NEON -DARMV8\"\n#define LIBNAME   \"cortexa57\"\n#define CORENAME  \"CORTEXA57\"\n#endif\n\n#ifdef FORCE_CORTEXA72\n#define FORCE\n#define ARCHITECTURE    \"ARM64\"\n#define SUBARCHITECTURE \"CORTEXA72\"\n#define SUBDIRNAME      \"arm64\"\n#define ARCHCONFIG   \"-DCORTEXA72 \" \\\n       \"-DL1_CODE_SIZE=49152 -DL1_CODE_LINESIZE=64 -DL1_CODE_ASSOCIATIVE=3 \" \\\n       \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=64 -DL1_DATA_ASSOCIATIVE=2 \" \\\n       \"-DL2_SIZE=2097152 -DL2_LINESIZE=64 -DL2_ASSOCIATIVE=16 \" \\\n       \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 \" \\\n       \"-DHAVE_VFPV4 -DHAVE_VFPV3 -DHAVE_VFP -DHAVE_NEON -DARMV8\"\n#define LIBNAME   \"cortexa72\"\n#define CORENAME  \"CORTEXA72\"\n#endif\n\n#ifdef FORCE_CORTEXA73\n#define FORCE\n#define ARCHITECTURE    \"ARM64\"\n#define SUBARCHITECTURE \"CORTEXA73\"\n#define SUBDIRNAME      \"arm64\"\n#define ARCHCONFIG   \"-DCORTEXA73 \" \\\n       \"-DL1_CODE_SIZE=49152 -DL1_CODE_LINESIZE=64 -DL1_CODE_ASSOCIATIVE=3 \" \\\n       \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=64 -DL1_DATA_ASSOCIATIVE=2 \" \\\n       \"-DL2_SIZE=2097152 -DL2_LINESIZE=64 -DL2_ASSOCIATIVE=16 \" \\\n       \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 \" \\\n       \"-DHAVE_VFPV4 -DHAVE_VFPV3 -DHAVE_VFP -DHAVE_NEON -DARMV8\"\n#define LIBNAME   \"cortexa73\"\n#define CORENAME  \"CORTEXA73\"\n#endif\n\n#ifdef FORCE_CORTEXA76\n#define FORCE\n#define ARCHITECTURE    \"ARM64\"\n#define SUBARCHITECTURE \"CORTEXA76\"\n#define SUBDIRNAME      \"arm64\"\n#define ARCHCONFIG   \"-DCORTEXA76 \" \\\n       \"-DL1_CODE_SIZE=49152 -DL1_CODE_LINESIZE=64 -DL1_CODE_ASSOCIATIVE=3 \" \\\n       \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=64 -DL1_DATA_ASSOCIATIVE=2 \" \\\n       \"-DL2_SIZE=2097152 -DL2_LINESIZE=64 -DL2_ASSOCIATIVE=16 \" \\\n       \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 \" \\\n       \"-DHAVE_VFPV4 -DHAVE_VFPV3 -DHAVE_VFP -DHAVE_NEON -DARMV8\"\n#define LIBNAME   \"cortexa76\"\n#define CORENAME  \"CORTEXA76\"\n#endif\n\n#ifdef FORCE_CORTEXX1\n#define FORCE\n#define ARCHITECTURE    \"ARM64\"\n#define SUBARCHITECTURE \"CORTEXX1\"\n#define SUBDIRNAME      \"arm64\"\n#define ARCHCONFIG   \"-DCORTEXX1 \" \\\n       \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=64 \" \\\n       \"-DL2_SIZE=262144 -DL2_LINESIZE=64 \" \\\n       \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 -DL2_ASSOCIATIVE=32 \" \\\n       \"-DHAVE_VFPV4 -DHAVE_VFPV3 -DHAVE_VFP -DHAVE_NEON -DARMV8\"\n#define LIBNAME   \"cortexx1\"\n#define CORENAME  \"CORTEXX1\"\n#endif\n\n#ifdef FORCE_CORTEXX2\n#define FORCE\n#define ARCHITECTURE    \"ARM64\"\n#define SUBARCHITECTURE \"CORTEXX2\"\n#define SUBDIRNAME      \"arm64\"\n#define ARCHCONFIG   \"-DCORTEXX2 \" \\\n       \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=64 \" \\\n       \"-DL2_SIZE=262144 -DL2_LINESIZE=64 \" \\\n       \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 -DL2_ASSOCIATIVE=32 \" \\\n       \"-DHAVE_VFPV4 -DHAVE_VFPV3 -DHAVE_VFP -DHAVE_NEON -DHAVE_SVE -DARMV8 -DARMV9\"\n#define LIBNAME   \"cortexx2\"\n#define CORENAME  \"CORTEXX2\"\n#endif\n\n#ifdef FORCE_CORTEXA510\n#define FORCE\n#define ARCHITECTURE    \"ARM64\"\n#define SUBARCHITECTURE \"CORTEXA510\"\n#define SUBDIRNAME      \"arm64\"\n#define ARCHCONFIG   \"-DCORTEXA510 \" \\\n       \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=64 \" \\\n       \"-DL2_SIZE=262144 -DL2_LINESIZE=64 \" \\\n       \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 -DL2_ASSOCIATIVE=32 \" \\\n       \"-DHAVE_VFPV4 -DHAVE_VFPV3 -DHAVE_VFP -DHAVE_NEON -DHAVE_SVE -DARMV8 -DARMV9\"\n#define LIBNAME   \"cortexa510\"\n#define CORENAME  \"CORTEXA510\"\n#endif\n\n#ifdef FORCE_CORTEXA710\n#define FORCE\n#define ARCHITECTURE    \"ARM64\"\n#define SUBARCHITECTURE \"CORTEXA710\"\n#define SUBDIRNAME      \"arm64\"\n#define ARCHCONFIG   \"-DCORTEXA710 \" \\\n       \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=64 \" \\\n       \"-DL2_SIZE=262144 -DL2_LINESIZE=64 \" \\\n       \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 -DL2_ASSOCIATIVE=32 \" \\\n       \"-DHAVE_VFPV4 -DHAVE_VFPV3 -DHAVE_VFP -DHAVE_NEON -DHAVE_SVE -DARMV8 -DARMV9\"\n#define LIBNAME   \"cortexa710\"\n#define CORENAME  \"CORTEXA710\"\n#endif\n\n#ifdef FORCE_NEOVERSEN1\n#define FORCE\n#define ARCHITECTURE    \"ARM64\"\n#define SUBARCHITECTURE \"NEOVERSEN1\"\n#define SUBDIRNAME      \"arm64\"\n#define ARCHCONFIG   \"-DNEOVERSEN1 \" \\\n       \"-DL1_CODE_SIZE=65536 -DL1_CODE_LINESIZE=64 -DL1_CODE_ASSOCIATIVE=4 \" \\\n       \"-DL1_DATA_SIZE=65536 -DL1_DATA_LINESIZE=64 -DL1_DATA_ASSOCIATIVE=4 \" \\\n       \"-DL2_SIZE=1048576 -DL2_LINESIZE=64 -DL2_ASSOCIATIVE=16 \" \\\n       \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 \" \\\n       \"-DHAVE_VFPV4 -DHAVE_VFPV3 -DHAVE_VFP -DHAVE_NEON -DARMV8 \" \\\n       \"-march=armv8.2-a -mtune=neoverse-n1\"\n#define LIBNAME   \"neoversen1\"\n#define CORENAME  \"NEOVERSEN1\"\n#endif\n\n#ifdef FORCE_NEOVERSEV1\n#define FORCE\n#define ARCHITECTURE    \"ARM64\"\n#define SUBARCHITECTURE \"NEOVERSEV1\"\n#define SUBDIRNAME      \"arm64\"\n#define ARCHCONFIG   \"-DNEOVERSEV1 \" \\\n       \"-DL1_CODE_SIZE=65536 -DL1_CODE_LINESIZE=64 -DL1_CODE_ASSOCIATIVE=4 \" \\\n       \"-DL1_DATA_SIZE=65536 -DL1_DATA_LINESIZE=64 -DL1_DATA_ASSOCIATIVE=4 \" \\\n       \"-DL2_SIZE=1048576 -DL2_LINESIZE=64 -DL2_ASSOCIATIVE=16 \" \\\n       \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 \" \\\n       \"-DHAVE_VFPV4 -DHAVE_VFPV3 -DHAVE_VFP -DHAVE_NEON -DHAVE_SVE -DARMV8 \" \\\n       \"-march=armv8.4-a+sve -mtune=neoverse-v1\"\n#define LIBNAME   \"neoversev1\"\n#define CORENAME  \"NEOVERSEV1\"\n#endif\n\n\n#ifdef FORCE_NEOVERSEN2\n#define FORCE\n#define ARCHITECTURE    \"ARM64\"\n#define SUBARCHITECTURE \"NEOVERSEN2\"\n#define SUBDIRNAME      \"arm64\"\n#define ARCHCONFIG   \"-DNEOVERSEN2 \" \\\n       \"-DL1_CODE_SIZE=65536 -DL1_CODE_LINESIZE=64 -DL1_CODE_ASSOCIATIVE=4 \" \\\n       \"-DL1_DATA_SIZE=65536 -DL1_DATA_LINESIZE=64 -DL1_DATA_ASSOCIATIVE=4 \" \\\n       \"-DL2_SIZE=1048576 -DL2_LINESIZE=64 -DL2_ASSOCIATIVE=16 \" \\\n       \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 \" \\\n       \"-DHAVE_VFPV4 -DHAVE_VFPV3 -DHAVE_VFP -DHAVE_NEON -DHAVE_SVE -DARMV8 \" \\\n       \"-march=armv8.5-a -mtune=neoverse-n2\"\n#define LIBNAME   \"neoversen2\"\n#define CORENAME  \"NEOVERSEN2\"\n#endif\n\n#ifdef FORCE_CORTEXA55\n#define FORCE\n#define ARCHITECTURE    \"ARM64\"\n#define SUBARCHITECTURE \"CORTEXA55\"\n#define SUBDIRNAME      \"arm64\"\n#define ARCHCONFIG   \"-DCORTEXA55 \" \\\n       \"-DL1_CODE_SIZE=16384 -DL1_CODE_LINESIZE=64 -DL1_CODE_ASSOCIATIVE=3 \" \\\n       \"-DL1_DATA_SIZE=16384 -DL1_DATA_LINESIZE=64 -DL1_DATA_ASSOCIATIVE=2 \" \\\n       \"-DL2_SIZE=65536 -DL2_LINESIZE=64 -DL2_ASSOCIATIVE=16 \" \\\n       \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 \" \\\n       \"-DHAVE_VFPV4 -DHAVE_VFPV3 -DHAVE_VFP -DHAVE_NEON -DARMV8\"\n#define LIBNAME   \"cortexa55\"\n#define CORENAME  \"CORTEXA55\"\n#endif\n\n#ifdef FORCE_FALKOR\n#define FORCE\n#define ARCHITECTURE    \"ARM64\"\n#define SUBARCHITECTURE \"FALKOR\"\n#define SUBDIRNAME      \"arm64\"\n#define ARCHCONFIG   \"-DFALKOR \" \\\n       \"-DL1_CODE_SIZE=49152 -DL1_CODE_LINESIZE=64 -DL1_CODE_ASSOCIATIVE=3 \" \\\n       \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=64 -DL1_DATA_ASSOCIATIVE=2 \" \\\n       \"-DL2_SIZE=2097152 -DL2_LINESIZE=64 -DL2_ASSOCIATIVE=16 \" \\\n       \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 \" \\\n       \"-DHAVE_VFPV4 -DHAVE_VFPV3 -DHAVE_VFP -DHAVE_NEON -DARMV8\"\n#define LIBNAME   \"falkor\"\n#define CORENAME  \"FALKOR\"\n#endif\n\n#ifdef FORCE_THUNDERX\n#define FORCE\n#define ARCHITECTURE    \"ARM64\"\n#define SUBARCHITECTURE \"THUNDERX\"\n#define SUBDIRNAME      \"arm64\"\n#define ARCHCONFIG   \"-DTHUNDERX \" \\\n       \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=128 \" \\\n       \"-DL2_SIZE=16777216 -DL2_LINESIZE=128 -DL2_ASSOCIATIVE=16 \" \\\n       \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 \" \\\n       \"-DHAVE_VFPV4 -DHAVE_VFPV3 -DHAVE_VFP -DHAVE_NEON -DARMV8\"\n#define LIBNAME   \"thunderx\"\n#define CORENAME  \"THUNDERX\"\n#endif\n\n#ifdef FORCE_THUNDERX2T99\n#define ARMV8\n#define FORCE\n#define ARCHITECTURE    \"ARM64\"\n#define SUBARCHITECTURE \"THUNDERX2T99\"\n#define SUBDIRNAME      \"arm64\"\n#define ARCHCONFIG   \"-DTHUNDERX2T99 \" \\\n       \"-DL1_CODE_SIZE=32768 -DL1_CODE_LINESIZE=64 -DL1_CODE_ASSOCIATIVE=8 \" \\\n       \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=64 -DL1_DATA_ASSOCIATIVE=8 \" \\\n       \"-DL2_SIZE=262144 -DL2_LINESIZE=64 -DL2_ASSOCIATIVE=8 \" \\\n       \"-DL3_SIZE=33554432 -DL3_LINESIZE=64 -DL3_ASSOCIATIVE=32 \" \\\n       \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 \" \\\n       \"-DHAVE_VFPV4 -DHAVE_VFPV3 -DHAVE_VFP -DHAVE_NEON -DARMV8\"\n#define LIBNAME   \"thunderx2t99\"\n#define CORENAME  \"THUNDERX2T99\"\n#endif\n\n#ifdef FORCE_TSV110\n#define FORCE\n#define ARCHITECTURE    \"ARM64\"\n#define SUBARCHITECTURE \"TSV110\"\n#define SUBDIRNAME      \"arm64\"\n#define ARCHCONFIG   \"-DTSV110 \" \\\n       \"-DL1_CODE_SIZE=65536  -DL1_CODE_LINESIZE=64 -DL1_CODE_ASSOCIATIVE=4 \" \\\n       \"-DL1_DATA_SIZE=65536  -DL1_DATA_LINESIZE=64 -DL1_DATA_ASSOCIATIVE=4 \" \\\n       \"-DL2_SIZE=524288 -DL2_LINESIZE=64 -DL2_ASSOCIATIVE=8 \" \\\n       \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 \" \\\n       \"-DHAVE_VFPV4 -DHAVE_VFPV3 -DHAVE_VFP -DHAVE_NEON -DARMV8\"\n#define LIBNAME   \"tsv110\"\n#define CORENAME  \"TSV110\"\n#endif\n\n#ifdef FORCE_EMAG8180\n#define ARMV8\n#define FORCE\n#define ARCHITECTURE    \"ARM64\"\n#define SUBARCHITECTURE \"EMAG8180\"\n#define SUBDIRNAME      \"arm64\"\n#define ARCHCONFIG   \"-DEMAG8180 \" \\\n       \"-DL1_CODE_SIZE=32768 -DL1_CODE_LINESIZE=64 -DL1_CODE_ASSOCIATIVE=8 \" \\\n       \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=64 -DL1_DATA_ASSOCIATIVE=8 \" \\\n       \"-DL2_SIZE=262144 -DL2_LINESIZE=64 -DL2_ASSOCIATIVE=8 \" \\\n       \"-DL3_SIZE=33554432 -DL3_LINESIZE=64 -DL3_ASSOCIATIVE=32 \" \\\n       \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 \" \\\n       \"-DHAVE_VFPV4 -DHAVE_VFPV3 -DHAVE_VFP -DHAVE_NEON -DARMV8\"\n#define LIBNAME   \"emag8180\"\n#define CORENAME  \"EMAG8180\"\n#endif\n\n#ifdef FORCE_THUNDERX3T110\n#define ARMV8\n#define FORCE\n#define ARCHITECTURE    \"ARM64\"\n#define SUBARCHITECTURE \"THUNDERX3T110\"\n#define SUBDIRNAME      \"arm64\"\n#define ARCHCONFIG   \"-DTHUNDERX3T110 \" \\\n       \"-DL1_CODE_SIZE=65536 -DL1_CODE_LINESIZE=64 -DL1_CODE_ASSOCIATIVE=8 \" \\\n       \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=64 -DL1_DATA_ASSOCIATIVE=8 \" \\\n       \"-DL2_SIZE=524288 -DL2_LINESIZE=64 -DL2_ASSOCIATIVE=8 \" \\\n       \"-DL3_SIZE=94371840 -DL3_LINESIZE=64 -DL3_ASSOCIATIVE=32 \" \\\n       \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 \" \\\n       \"-DHAVE_VFPV4 -DHAVE_VFPV3 -DHAVE_VFP -DHAVE_NEON -DARMV8\"\n#define LIBNAME   \"thunderx3t110\"\n#define CORENAME  \"THUNDERX3T110\"\n#endif\n\n#ifdef FORCE_VORTEX\n#define FORCE\n#define ARCHITECTURE    \"ARM64\"\n#define SUBARCHITECTURE \"VORTEX\"\n#define SUBDIRNAME      \"arm64\"\n#define ARCHCONFIG   \"-DVORTEX \" \\\n       \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=64 \" \\\n       \"-DL2_SIZE=262144 -DL2_LINESIZE=64 \" \\\n       \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 -DL2_ASSOCIATIVE=32 \" \\\n       \"-DHAVE_VFPV4 -DHAVE_VFPV3 -DHAVE_VFP -DHAVE_NEON -DARMV8\"\n#define LIBNAME   \"vortex\"\n#define CORENAME  \"VORTEX\"\n#endif\n\n#ifdef FORCE_A64FX\n#define ARMV8\n#define FORCE\n#define ARCHITECTURE    \"ARM64\"\n#define SUBARCHITECTURE \"A64FX\"\n#define SUBDIRNAME      \"arm64\"\n#define ARCHCONFIG   \"-DA64FX \" \\\n       \"-DL1_CODE_SIZE=65536 -DL1_CODE_LINESIZE=256 -DL1_CODE_ASSOCIATIVE=8 \" \\\n       \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=256 -DL1_DATA_ASSOCIATIVE=8 \" \\\n       \"-DL2_SIZE=8388608 -DL2_LINESIZE=256 -DL2_ASSOCIATIVE=8 \" \\\n       \"-DL3_SIZE=0 -DL3_LINESIZE=0 -DL3_ASSOCIATIVE=0 \" \\\n       \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 \" \\\n       \"-DHAVE_VFPV4 -DHAVE_VFPV3 -DHAVE_VFP -DHAVE_NEON -DHAVE_SVE -DARMV8\"\n#define LIBNAME   \"a64fx\"\n#define CORENAME  \"A64FX\"\n#endif\n\n#ifdef FORCE_FT2000\n#define ARMV8\n#define FORCE\n#define ARCHITECTURE    \"ARM64\"\n#define SUBARCHITECTURE \"FT2000\"\n#define SUBDIRNAME      \"arm64\"\n#define ARCHCONFIG   \"-DFT2000 \" \\\n       \"-DL1_CODE_SIZE=32768 -DL1_CODE_LINESIZE=64 -DL1_CODE_ASSOCIATIVE=8 \" \\\n       \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=64 -DL1_DATA_ASSOCIATIVE=8 \" \\\n       \"-DL2_SIZE=33554426-DL2_LINESIZE=64 -DL2_ASSOCIATIVE=8 \" \\\n       \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 \" \\\n       \"-DHAVE_VFPV4 -DHAVE_VFPV3 -DHAVE_VFP -DHAVE_NEON -DARMV8\"\n#define LIBNAME   \"ft2000\"\n#define CORENAME  \"FT2000\"\n#endif\n\n#ifdef FORCE_ZARCH_GENERIC\n#define FORCE\n#define ARCHITECTURE    \"ZARCH\"\n#define SUBARCHITECTURE \"ZARCH_GENERIC\"\n#define ARCHCONFIG   \"-DZARCH_GENERIC \" \\\n       \"-DDTB_DEFAULT_ENTRIES=64\"\n#define LIBNAME   \"zarch_generic\"\n#define CORENAME  \"ZARCH_GENERIC\"\n#endif\n\n#ifdef FORCE_Z13\n#define FORCE\n#define ARCHITECTURE    \"ZARCH\"\n#define SUBARCHITECTURE \"Z13\"\n#define ARCHCONFIG   \"-DZ13 \" \\\n       \"-DDTB_DEFAULT_ENTRIES=64\"\n#define LIBNAME   \"z13\"\n#define CORENAME  \"Z13\"\n#endif\n\n#ifdef FORCE_Z14\n#define FORCE\n#define ARCHITECTURE    \"ZARCH\"\n#define SUBARCHITECTURE \"Z14\"\n#define ARCHCONFIG   \"-DZ14 \" \\\n       \"-DDTB_DEFAULT_ENTRIES=64\"\n#define LIBNAME   \"z14\"\n#define CORENAME  \"Z14\"\n#endif\n\n#ifdef FORCE_EV4\n#define FORCE\n#define ARCHITECTURE    \"ALPHA\"\n#define SUBARCHITECTURE \"ev4\"\n#define ARCHCONFIG   \"-DEV4 \" \\\n\t\t     \"-DL1_DATA_SIZE=16384 -DL1_DATA_LINESIZE=32 \" \\\n\t\t     \"-DL2_SIZE=2097152 -DL2_LINESIZE=32 \" \\\n\t\t     \"-DDTB_DEFAULT_ENTRIES=32 -DDTB_SIZE=8192 \"\n#define LIBNAME   \"ev4\"\n#define CORENAME  \"EV4\"\n#endif\n\n#ifdef FORCE_EV5\n#define FORCE\n#define ARCHITECTURE    \"ALPHA\"\n#define SUBARCHITECTURE \"ev5\"\n#define ARCHCONFIG   \"-DEV5 \" \\\n\t\t     \"-DL1_DATA_SIZE=16384 -DL1_DATA_LINESIZE=32 \" \\\n\t\t     \"-DL2_SIZE=2097152 -DL2_LINESIZE=64 \" \\\n\t\t     \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=8192 \"\n#define LIBNAME   \"ev5\"\n#define CORENAME  \"EV5\"\n#endif\n\n#ifdef FORCE_EV6\n#define FORCE\n#define ARCHITECTURE    \"ALPHA\"\n#define SUBARCHITECTURE \"ev6\"\n#define ARCHCONFIG   \"-DEV6 \" \\\n\t\t     \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=64 \" \\\n\t\t     \"-DL2_SIZE=4194304 -DL2_LINESIZE=64 \" \\\n\t\t     \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=8192 \"\n#define LIBNAME   \"ev6\"\n#define CORENAME  \"EV6\"\n#endif\n\n#ifdef FORCE_C910V\n#define FORCE\n#define ARCHITECTURE    \"RISCV64\"\n#ifdef NO_RV64GV\n#define SUBARCHITECTURE \"RISCV64_GENERIC\"\n#define SUBDIRNAME      \"riscv64\"\n#define ARCHCONFIG   \"-DRISCV64_GENERIC \" \\\n       \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=32 \" \\\n       \"-DL2_SIZE=1048576 -DL2_LINESIZE=32 \" \\\n       \"-DDTB_DEFAULT_ENTRIES=128 -DDTB_SIZE=4096 -DL2_ASSOCIATIVE=4 \"\n#define LIBNAME   \"riscv64_generic\"\n#define CORENAME  \"RISCV64_GENERIC\"\n#else\n#define SUBARCHITECTURE \"C910V\"\n#define SUBDIRNAME      \"riscv64\"\n#define ARCHCONFIG   \"-DC910V \" \\\n       \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=32 \" \\\n       \"-DL2_SIZE=1048576 -DL2_LINESIZE=32 \" \\\n       \"-DDTB_DEFAULT_ENTRIES=128 -DDTB_SIZE=4096 -DL2_ASSOCIATIVE=4 \"\n#define LIBNAME   \"c910v\"\n#define CORENAME  \"C910V\"\n#endif\n#endif\n#ifdef FORCE_x280\n#define FORCE\n#define ARCHITECTURE    \"RISCV64\"\n#define SUBARCHITECTURE \"x280\"\n#define SUBDIRNAME      \"riscv64\"\n#define ARCHCONFIG   \"-Dx280 \" \\\n       \"-DL1_DATA_SIZE=64536 -DL1_DATA_LINESIZE=32 \" \\\n       \"-DL2_SIZE=262144 -DL2_LINESIZE=32 \" \\\n       \"-DDTB_DEFAULT_ENTRIES=128 -DDTB_SIZE=4096 -DL2_ASSOCIATIVE=4 \"\n#define LIBNAME   \"x280\"\n#define CORENAME  \"x280\"\n#else\n#endif\n\n#ifdef FORCE_RISCV64_ZVL256B\n#define FORCE\n#define ARCHITECTURE    \"RISCV64\"\n#define SUBARCHITECTURE \"RISCV64_ZVL256B\"\n#define SUBDIRNAME      \"riscv64\"\n#define ARCHCONFIG   \"-DRISCV64_ZVL256B \" \\\n       \"-DL1_DATA_SIZE=64536 -DL1_DATA_LINESIZE=32 \" \\\n       \"-DL2_SIZE=262144 -DL2_LINESIZE=32 \" \\\n       \"-DDTB_DEFAULT_ENTRIES=128 -DDTB_SIZE=4096 -DL2_ASSOCIATIVE=4 \"\n#define LIBNAME   \"riscv64_zvl256b\"\n#define CORENAME  \"RISCV64_ZVL256B\"\n#endif\n\n#ifdef FORCE_RISCV64_ZVL128B\n#define FORCE\n#define ARCHITECTURE    \"RISCV64\"\n#define SUBARCHITECTURE \"RISCV64_ZVL128B\"\n#define SUBDIRNAME      \"riscv64\"\n#define ARCHCONFIG \"-DRISCV64_ZVL128B \"                          \\\n                   \"-DL1_DATA_SIZE=32768 -DL1_DATA_LINESIZE=32 \" \\\n                   \"-DL2_SIZE=1048576 -DL2_LINESIZE=32 \"         \\\n                   \"-DDTB_DEFAULT_ENTRIES=128 -DDTB_SIZE=4096 -DL2_ASSOCIATIVE=4 \"\n#define LIBNAME  \"riscv64_zvl128b\"\n#define CORENAME \"RISCV64_ZVL128B\"\n#endif\n\n#if defined(FORCE_E2K) || defined(__e2k__)\n#define FORCE\n#define ARCHITECTURE \"E2K\"\n#define ARCHCONFIG   \"-DGENERIC \" \\\n\t\t     \"-DL1_DATA_SIZE=16384 -DL1_DATA_LINESIZE=64 \" \\\n\t\t     \"-DL2_SIZE=524288 -DL2_LINESIZE=64 \" \\\n\t\t     \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 -DL2_ASSOCIATIVE=8 \"\n#define LIBNAME   \"generic\"\n#define CORENAME  \"generic\"\n#endif\n\n#ifdef FORCE_CSKY\n#define FORCE\n#define ARCHITECTURE    \"CSKY\"\n#define SUBARCHITECTURE \"CSKY\"\n#define SUBDIRNAME      \"csky\"\n#define ARCHCONFIG   \"-DCSKY\" \\\n       \"-DL1_DATA_SIZE=65536 -DL1_DATA_LINESIZE=32 \" \\\n       \"-DL2_SIZE=524288 -DL2_LINESIZE=32 \" \\\n       \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 -DL2_ASSOCIATIVE=8 \"\n#define LIBNAME   \"csky\"\n#define CORENAME  \"CSKY\"\n#endif\n\n#ifdef FORCE_CK860FV\n#define FORCE\n#define ARCHITECTURE    \"CSKY\"\n#define SUBARCHITECTURE \"CK860V\"\n#define SUBDIRNAME      \"csky\"\n#define ARCHCONFIG   \"-DCK860FV \" \\\n       \"-DL1_DATA_SIZE=65536 -DL1_DATA_LINESIZE=32 \" \\\n       \"-DL2_SIZE=524288 -DL2_LINESIZE=32 \" \\\n       \"-DDTB_DEFAULT_ENTRIES=64 -DDTB_SIZE=4096 -DL2_ASSOCIATIVE=8 \"\n#define LIBNAME   \"ck860fv\"\n#define CORENAME  \"CK860FV\"\n#endif\n\n\n#ifndef FORCE\n\n#ifdef USER_TARGET\n#error \"The TARGET specified on the command line or in Makefile.rule is not supported. Please choose a target from TargetList.txt\"\n#endif\n\n#if defined(__powerpc__) || defined(__powerpc) || defined(powerpc) || \\\n    defined(__PPC__) || defined(PPC) || defined(_POWER) || defined(__POWERPC__)\n#ifndef POWER\n#define POWER\n#endif\n#define OPENBLAS_SUPPORTED\n#endif\n\n#if defined(__zarch__) || defined(__s390x__)\n#define ZARCH\n#include \"cpuid_zarch.c\"\n#define OPENBLAS_SUPPORTED\n#endif\n\n#ifdef INTEL_AMD\n#include \"cpuid_x86.c\"\n#define OPENBLAS_SUPPORTED\n#endif\n\n#ifdef __ia64__\n#include \"cpuid_ia64.c\"\n#define OPENBLAS_SUPPORTED\n#endif\n\n#ifdef __alpha\n#include \"cpuid_alpha.c\"\n#define OPENBLAS_SUPPORTED\n#endif\n\n#ifdef POWER\n#include \"cpuid_power.c\"\n#define OPENBLAS_SUPPORTED\n#endif\n\n#ifdef sparc\n#include \"cpuid_sparc.c\"\n#define OPENBLAS_SUPPORTED\n#endif\n\n#ifdef __mips__\n#ifdef __mips64\n#include \"cpuid_mips64.c\"\n#else\n#include \"cpuid_mips.c\"\n#endif\n#define OPENBLAS_SUPPORTED\n#endif\n\n#ifdef __loongarch64\n#include \"cpuid_loongarch64.c\"\n#define OPENBLAS_SUPPORTED\n#endif\n\n#ifdef __riscv\n#include \"cpuid_riscv64.c\"\n#define OPENBLAS_SUPPORTED\n#endif\n\n#ifdef __arm__\n#include \"cpuid_arm.c\"\n#define OPENBLAS_SUPPORTED\n#endif\n\n#ifdef __aarch64__\n#include \"cpuid_arm64.c\"\n#define OPENBLAS_SUPPORTED\n#endif\n\n#ifndef OPENBLAS_SUPPORTED\n#error \"This arch/CPU is not supported by OpenBLAS.\"\n#endif\n\n#else\n\n#endif\n\nstatic int get_num_cores(void) {\n\n  int count;\n#ifdef OS_WINDOWS\n  SYSTEM_INFO sysinfo;\n#elif defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__NetBSD__) || defined(__DragonFly__) || defined(__APPLE__)\n  int m[2];\n  size_t len;\n#endif\n\n#if defined(linux) || defined(__sun__)\n  //returns the number of processors which are currently online\n  count = sysconf(_SC_NPROCESSORS_CONF);\n  if (count <= 0) count = 2;\n  return count;\n  \n#elif defined(OS_WINDOWS)\n\n  GetSystemInfo(&sysinfo);\n  return sysinfo.dwNumberOfProcessors;\n\n#elif defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__NetBSD__) || defined(__DragonFly__) || defined(__APPLE__)\n  m[0] = CTL_HW;\n  m[1] = HW_NCPU;\n  len = sizeof(int);\n  sysctl(m, 2, &count, &len, NULL, 0);\n  if (count <= 0) count = 2;\n  \n  return count;\n\n#elif defined(_AIX)\n  //returns the number of processors which are currently online\n  count = sysconf(_SC_NPROCESSORS_ONLN);\n  if (count <= 0) count = 2;\n\n  return count;\n\n#else\n  return 2;\n#endif\n}\n\nint main(int argc, char *argv[]){\n\n#ifdef FORCE\n  char buffer[8192], *p, *q;\n  int length;\n#endif\n\n  if (argc == 1) return 0;\n\n  switch (argv[1][0]) {\n\n  case '0' : /* for Makefile */\n\n#ifdef FORCE\n    printf(\"CORE=%s\\n\", CORENAME);\n#else\n#if defined(INTEL_AMD) || defined(POWER) || defined(__mips__) || defined(__arm__) || defined(__aarch64__) || defined(ZARCH) || defined(sparc) || defined(__loongarch__) || defined(__riscv) || defined(__alpha__) || defined(__csky__)\n    printf(\"CORE=%s\\n\", get_corename());\n#endif\n#endif\n\n#ifdef FORCE\n    printf(\"LIBCORE=%s\\n\", LIBNAME);\n#else\n    printf(\"LIBCORE=\");\n    get_libname();\n    printf(\"\\n\");\n#endif\n\n    printf(\"NUM_CORES=%d\\n\", get_num_cores());\n\n#if defined(__arm__) \n#if !defined(FORCE)\n    fprintf(stderr,\"get features!\\n\");\n        get_features();\n#else\n    fprintf(stderr,\"split archconfig!\\n\");\n    sprintf(buffer, \"%s\", ARCHCONFIG);\n\n    p = &buffer[0];\n\n    while (*p) {\n      if ((*p == '-') && (*(p + 1) == 'D')) {\n\tp += 2;\n        if (*p != 'H') {\n\t\twhile( (*p != ' ') && (*p != '-') && (*p != '\\0') && (*p != '\\n')) {p++; }\n\t\tif (*p == '-') continue;\n\t}\n\twhile ((*p != ' ') && (*p != '\\0')) {\n\n\t  if (*p == '=') {\n\t    printf(\"=\");\n\t    p ++;\n\t    while ((*p != ' ') && (*p != '\\0')) {\n\t      printf(\"%c\", *p);\n\t      p ++;\n\t    }\n\t  } else {\n\t    printf(\"%c\", *p);\n\t    p ++;\n\t    if ((*p == ' ') || (*p =='\\0')) printf(\"=1\\n\");\n\t  }\n\t}\n      } else p ++;\n    }\n#endif\n#endif\n\n\n#ifdef INTEL_AMD\n#ifndef FORCE\n    get_sse();\n#else\n\n    sprintf(buffer, \"%s\", ARCHCONFIG);\n\n    p = &buffer[0];\n\n    while (*p) {\n      if ((*p == '-') && (*(p + 1) == 'D')) {\n\tp += 2;\n\n\twhile ((*p != ' ') && (*p != '\\0')) {\n\n\t  if (*p == '=') {\n\t    printf(\"=\");\n\t    p ++;\n\t    while ((*p != ' ') && (*p != '\\0')) {\n\t      printf(\"%c\", *p);\n\t      p ++;\n\t    }\n\t  } else {\n\t    printf(\"%c\", *p);\n\t    p ++;\n\t    if ((*p == ' ') || (*p =='\\0')) printf(\"=1\");\n\t  }\n\t}\n\n\tprintf(\"\\n\");\n      } else p ++;\n    }\n#endif\n#endif\n\n#if defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\nprintf(\"__BYTE_ORDER__=__ORDER_BIG_ENDIAN__\\n\");\n#elif defined(__BIG_ENDIAN__) && __BIG_ENDIAN__ > 0\nprintf(\"__BYTE_ORDER__=__ORDER_BIG_ENDIAN__\\n\");\n#endif\n#if defined(_CALL_ELF) && (_CALL_ELF == 2)\nprintf(\"ELF_VERSION=2\\n\");\n#endif\n\n#ifdef MAKE_NB_JOBS\n  #if MAKE_NB_JOBS > 0\n    printf(\"MAKEFLAGS += -j %d\\n\", MAKE_NB_JOBS);\n  #else\n    // Let make use parent -j argument or -j1 if there\n    // is no make parent\n  #endif\n#elif NO_PARALLEL_MAKE==1\n    printf(\"MAKEFLAGS += -j 1\\n\");\n#else\n    printf(\"MAKEFLAGS += -j %d\\n\", get_num_cores());\n#endif\n\n    break;\n\n  case '1' : /* For config.h */\n#ifdef FORCE\n    sprintf(buffer, \"%s -DCORE_%s\\n\", ARCHCONFIG, CORENAME);\n\n    p = &buffer[0];\n    while (*p) {\n      if ((*p == '-') && (*(p + 1) == 'D')) {\n\tp += 2;\n\tprintf(\"#define \");\n\n\twhile ((*p != ' ') && (*p != '\\0')) {\n\n\t  if (*p == '=') {\n\t    printf(\" \");\n\t    p ++;\n\t    while ((*p != ' ') && (*p != '\\0')) {\n\t      printf(\"%c\", *p);\n\t      p ++;\n\t    }\n\t  } else {\n\t    if (*p != '\\n')\n\t    printf(\"%c\", *p);\n\t    p ++;\n\t  }\n\t}\n\n\tprintf(\"\\n\");\n      } else p ++;\n    }\n#else\n    get_cpuconfig();\n#endif\n\n#ifdef FORCE\n    printf(\"#define CHAR_CORENAME \\\"%s\\\"\\n\", CORENAME);\n#else\n#if defined(INTEL_AMD) || defined(POWER) || defined(__mips__) || defined(__arm__) || defined(__aarch64__) || defined(ZARCH) || defined(sparc) || defined(__loongarch__) || defined(__riscv) || defined(__csky__)\n    printf(\"#define CHAR_CORENAME \\\"%s\\\"\\n\", get_corename());\n#endif\n#endif\n\n break;\n\n  case '2' : /* SMP */\n    if (get_num_cores() > 1) printf(\"SMP=1\\n\");\n    break;\n  }\n\n  fflush(stdout);\n\n  return 0;\n}\n\n"
        },
        {
          "name": "getarch_2nd.c",
          "type": "blob",
          "size": 3.0361328125,
          "content": "#include <stdio.h>\n#ifndef BUILD_KERNEL\n#include \"config.h\"\n#else\n#include \"config_kernel.h\"\n#endif\n#if (defined(__WIN32__) || defined(__WIN64__) || defined(__CYGWIN32__) || defined(__CYGWIN64__) || defined(_WIN32) || defined(_WIN64)) && defined(__64BIT__)\ntypedef long long BLASLONG;\ntypedef unsigned long long BLASULONG;\n#else\ntypedef long BLASLONG;\ntypedef unsigned long BLASULONG;\n#endif\n\n#include \"param.h\"\n\nint main(int argc, char **argv) {\n\n  if ( (argc <= 1) || ((argc >= 2) && (*argv[1] == '0'))) {\n    printf(\"SBGEMM_UNROLL_M=%d\\n\", SBGEMM_DEFAULT_UNROLL_M);\n    printf(\"SBGEMM_UNROLL_N=%d\\n\", SBGEMM_DEFAULT_UNROLL_N);\n    printf(\"SGEMM_UNROLL_M=%d\\n\", SGEMM_DEFAULT_UNROLL_M);\n    printf(\"SGEMM_UNROLL_N=%d\\n\", SGEMM_DEFAULT_UNROLL_N);\n    printf(\"DGEMM_UNROLL_M=%d\\n\", DGEMM_DEFAULT_UNROLL_M);\n    printf(\"DGEMM_UNROLL_N=%d\\n\", DGEMM_DEFAULT_UNROLL_N);\n    printf(\"QGEMM_UNROLL_M=%d\\n\", QGEMM_DEFAULT_UNROLL_M);\n    printf(\"QGEMM_UNROLL_N=%d\\n\", QGEMM_DEFAULT_UNROLL_N);\n\n    printf(\"CGEMM_UNROLL_M=%d\\n\", CGEMM_DEFAULT_UNROLL_M);\n    printf(\"CGEMM_UNROLL_N=%d\\n\", CGEMM_DEFAULT_UNROLL_N);\n    printf(\"ZGEMM_UNROLL_M=%d\\n\", ZGEMM_DEFAULT_UNROLL_M);\n    printf(\"ZGEMM_UNROLL_N=%d\\n\", ZGEMM_DEFAULT_UNROLL_N);\n    printf(\"XGEMM_UNROLL_M=%d\\n\", XGEMM_DEFAULT_UNROLL_M);\n    printf(\"XGEMM_UNROLL_N=%d\\n\", XGEMM_DEFAULT_UNROLL_N);\n\n#ifdef CGEMM3M_DEFAULT_UNROLL_M\n    printf(\"CGEMM3M_UNROLL_M=%d\\n\", CGEMM3M_DEFAULT_UNROLL_M);\n#else\n    printf(\"CGEMM3M_UNROLL_M=%d\\n\", SGEMM_DEFAULT_UNROLL_M);\n#endif\n\n#ifdef CGEMM3M_DEFAULT_UNROLL_N\n    printf(\"CGEMM3M_UNROLL_N=%d\\n\", CGEMM3M_DEFAULT_UNROLL_N);\n#else\n    printf(\"CGEMM3M_UNROLL_N=%d\\n\", SGEMM_DEFAULT_UNROLL_N);\n#endif\n\n#ifdef ZGEMM3M_DEFAULT_UNROLL_M\n    printf(\"ZGEMM3M_UNROLL_M=%d\\n\", ZGEMM3M_DEFAULT_UNROLL_M);\n#else\n    printf(\"ZGEMM3M_UNROLL_M=%d\\n\", DGEMM_DEFAULT_UNROLL_M);\n#endif\n\n#ifdef ZGEMM3M_DEFAULT_UNROLL_N\n    printf(\"ZGEMM3M_UNROLL_N=%d\\n\", ZGEMM3M_DEFAULT_UNROLL_N);\n#else\n    printf(\"ZGEMM3M_UNROLL_N=%d\\n\", DGEMM_DEFAULT_UNROLL_N);\n#endif\n\n#ifdef XGEMM3M_DEFAULT_UNROLL_M\n    printf(\"XGEMM3M_UNROLL_M=%d\\n\", ZGEMM3M_DEFAULT_UNROLL_M);\n#else\n    printf(\"XGEMM3M_UNROLL_M=%d\\n\", QGEMM_DEFAULT_UNROLL_M);\n#endif\n\n#ifdef XGEMM3M_DEFAULT_UNROLL_N\n    printf(\"XGEMM3M_UNROLL_N=%d\\n\", ZGEMM3M_DEFAULT_UNROLL_N);\n#else\n    printf(\"XGEMM3M_UNROLL_N=%d\\n\", QGEMM_DEFAULT_UNROLL_N);\n#endif\n\n\n  }\n\n\n  if ((argc >= 2) && (*argv[1] == '1')) {\n\n#if defined(ARCH_X86) || defined(ARCH_X86_64)\n    printf(\"#define SLOCAL_BUFFER_SIZE\\t%ld\\n\", (SGEMM_DEFAULT_Q * SGEMM_DEFAULT_UNROLL_N * 4 * 1 *  sizeof(float)));\n    printf(\"#define DLOCAL_BUFFER_SIZE\\t%ld\\n\", (DGEMM_DEFAULT_Q * DGEMM_DEFAULT_UNROLL_N * 2 * 1 *  sizeof(double)));\n    printf(\"#define CLOCAL_BUFFER_SIZE\\t%ld\\n\", (CGEMM_DEFAULT_Q * CGEMM_DEFAULT_UNROLL_N * 4 * 2 *  sizeof(float)));\n    printf(\"#define ZLOCAL_BUFFER_SIZE\\t%ld\\n\", (ZGEMM_DEFAULT_Q * ZGEMM_DEFAULT_UNROLL_N * 2 * 2 *  sizeof(double)));\n#endif\n\n#ifdef USE64BITINT\n\tprintf(\"#define USE64BITINT\\n\");\n#endif\n\tprintf(\"#define GEMM_MULTITHREAD_THRESHOLD\\t%ld\\n\", (long int)GEMM_MULTITHREAD_THRESHOLD);\n  }\n\n  return 0;\n}\n"
        },
        {
          "name": "interface",
          "type": "tree",
          "content": null
        },
        {
          "name": "kernel",
          "type": "tree",
          "content": null
        },
        {
          "name": "l1param.h",
          "type": "blob",
          "size": 2.046875,
          "content": "#if defined(CORE2) || defined(PENRYN)\n#define ALIGNED_ACCESS\n#endif\n\n#ifdef NEHALEM\n#define PREFETCH\tprefetcht0\n#define PREFETCHW\tprefetcht0\n#define PREFETCHSIZE (128 *  12)\n#define ALIGNED_ACCESS\n#endif\n\n#ifdef SANDYBRIDGE\n#define PREFETCH\tprefetcht0\n#define PREFETCHW\tprefetcht0\n#define PREFETCHSIZE (128 *  12)\n#define ALIGNED_ACCESS\n#endif\n\n#ifdef ATHLON\n#define PREFETCH\tprefetch\n#define PREFETCHW\tprefetchw\n#define PREFETCHSIZE (128 *  10)\n#define ALIGNED_ACCESS\n#define movsd\tmovlps\n#endif\n\n#ifdef PENTIUM3\n#define PREFETCH\tprefetcht0\n#define PREFETCHSIZE (128 *  10)\n#define ALIGNED_ACCESS\n#define movsd\tmovlps\n#endif\n\n#ifdef PENTIUM4\n#define PREFETCH\tprefetcht0\n#define PREFETCHSIZE (128 *  10)\n#define FETCH128\n#define ALIGNED_ACCESS\n#define xorps\tpxor\n#define xorpd\tpxor\n#endif\n\n#ifdef ATOM\n#define ALIGNED_ACCESS\n#define PREFETCH\tprefetcht0\n#define PREFETCHSIZE ( 64 * 12 + 32)\n#endif\n\n#ifdef OPTERON\n#define PREFETCH\tprefetch\n#define PREFETCHW\tprefetchw\n#define PREFETCHSIZE (128 *   3)\n#define movsd\tmovlps\n#endif\n\n#ifdef BARCELONA\n#define PREFETCH\tprefetch\n#define PREFETCHW\tprefetchw\n#define PREFETCHSIZE (128 *   5)\n#define ALIGNED_ACCESS\n#endif\n\n#ifdef SHANGHAI\n#define PREFETCH\tprefetch\n#define PREFETCHW\tprefetchw\n#define PREFETCHSIZE (128 *   5)\n#define ALIGNED_ACCESS\n#endif\n\n#ifdef BOBCAT\n#define PREFETCH\tprefetch\n#define PREFETCHW\tprefetchw\n#define PREFETCHSIZE (128 *   5)\n#define ALIGNED_ACCESS\n#endif\n\n#ifdef BULLDOZER\n#define PREFETCH\tprefetch\n#define PREFETCHW\tprefetchw\n#define PREFETCHSIZE (128 *   5)\n#define ALIGNED_ACCESS\n#endif\n\n#ifdef NANO\n#define PREFETCH        prefetcht0\n#define PREFETCHW       prefetcht0\n#define PREFETCHSIZE (128 *   4)\n#define ALIGNED_ACCESS\n#endif\n\n#define PREOFFSET 128\n\n\n#ifdef HAVE_SSE2\n#define PSHUFD1(A, B)\t\tpshufd\tA, B, B\n#define PSHUFD2(A, B, C)\tpshufd\tA, B, C\n#else\n#define PSHUFD1(A, B)\t\tshufps\tA, B, B\n#define PSHUFD2(A, B, C)\tmovaps\tB, C; shufps\tA, C, C\n#endif\n\n#define MOVDDUP1(OFFSET, BASE, REGS)\tmovddup\tOFFSET(BASE), REGS\n\n#define MOVAPS(OFFSET, BASE, REGS)\tmovlps\tREGS, OFFSET(BASE); movhps REGS, OFFSET + SIZE(BASE)\n\n"
        },
        {
          "name": "l2param.h",
          "type": "blob",
          "size": 3.9609375,
          "content": "#ifndef GEMV_PARAM_H\n#define GEMV_PARAM_H\n\n#ifdef movsd\n#undef movsd\n#endif\n\n#undef  movapd\n#define movapd movaps\n\n#ifdef ATHLON\n#define ALIGNED_ACCESS\n#define MOVUPS_A\tmovaps\n#define MOVUPS_XL\tmovaps\n#define MOVUPS_XS\tmovaps\n#define MOVUPS_YL\tmovaps\n#define MOVUPS_YS\tmovaps\n#define PREFETCH\tprefetcht0\n#define PREFETCHSIZE\t64 * 3\n#endif\n\n#ifdef PENTIUM4\n#define ALIGNED_ACCESS\n#define MOVUPS_A\tmovaps\n#define MOVUPS_XL\tmovaps\n#define MOVUPS_XS\tmovaps\n#define MOVUPS_YL\tmovaps\n#define MOVUPS_YS\tmovaps\n#define PREFETCH\tprefetcht0\n#define PREFETCHSIZE\t64 * 2\n#endif\n\n#ifdef CORE2\n#define ALIGNED_ACCESS\n#define MOVUPS_A\tmovaps\n#define MOVUPS_XL\tmovaps\n#define MOVUPS_XS\tmovaps\n#define MOVUPS_YL\tmovaps\n#define MOVUPS_YS\tmovaps\n#define PREFETCH\tprefetcht0\n#define PREFETCHSIZE\t64 * 4\n#endif\n\n#ifdef PENRYN\n#define ALIGNED_ACCESS\n#define MOVUPS_A\tmovaps\n#define MOVUPS_XL\tmovaps\n#define MOVUPS_XS\tmovaps\n#define MOVUPS_YL\tmovaps\n#define MOVUPS_YS\tmovaps\n#define PREFETCH\tprefetcht0\n#define PREFETCHSIZE\t64 * 4\n#endif\n\n#ifdef NEHALEM\n#define MOVUPS_A\tmovups\n#define MOVUPS_XL\tmovups\n#define MOVUPS_XS\tmovups\n#define MOVUPS_YL\tmovups\n#define MOVUPS_YS\tmovups\n#define PREFETCH\tprefetcht0\n#define PREFETCHW\tprefetcht0\n#define PREFETCHSIZE\t64 * 3\n#endif\n\n#ifdef SANDYBRIDGE\n#define MOVUPS_A\tmovups\n#define MOVUPS_XL\tmovups\n#define MOVUPS_XS\tmovups\n#define MOVUPS_YL\tmovups\n#define MOVUPS_YS\tmovups\n#define PREFETCH\tprefetcht0\n#define PREFETCHW\tprefetcht0\n#define PREFETCHSIZE\t64 * 3\n#endif\n\n#ifdef OPTERON\n#define PREFETCH\tprefetch\n#define PREFETCHW\tprefetchw\n#ifndef COMPLEX\n#define PREFETCHSIZE\t64 * 1\n#else\n#define PREFETCHSIZE\t64 * 1\n#endif\n#define movsd\t\tmovlps\n#endif\n\n#if defined(BARCELONA) || defined(SHANGHAI) || defined(BOBCAT) || defined(BARCELONA_OPTIMIZATION)\n#define ALIGNED_ACCESS\n#define MOVUPS_A\tmovaps\n#define MOVUPS_XL\tmovaps\n#define MOVUPS_XS\tmovaps\n#define MOVUPS_YL\tmovaps\n#define MOVUPS_YS\tmovaps\n\n#define PREFETCH\tprefetch\n#define PREFETCHW\tprefetchw\n#ifndef COMPLEX\n#define PREFETCHSIZE\t64 * 2\n#else\n#define PREFETCHSIZE\t64 * 4\n#endif\n#endif\n\n#ifdef NANO\n#define ALIGNED_ACCESS\n#define MOVUPS_A\tmovaps\n#define MOVUPS_XL\tmovaps\n#define MOVUPS_XS\tmovaps\n#define MOVUPS_YL\tmovaps\n#define MOVUPS_YS\tmovaps\n#define PREFETCH\tprefetcht0\n#ifndef COMPLEX\n#define PREFETCHSIZE\t64 * 1\n#else\n#define PREFETCHSIZE\t64 * 2\n#endif\n#endif\n\n#ifndef PREOFFSET\n#ifdef L1_DATA_LINESIZE\n#define PREOFFSET\t(L1_DATA_LINESIZE >> 1)\n#else\n#define PREOFFSET\t32\n#endif\n#endif\n\n#ifndef  GEMV_UNROLL\n#define  GEMV_UNROLL 4\n#endif\n\n#ifndef ZGEMV_UNROLL\n#define ZGEMV_UNROLL 4\n#endif\n\n/* #define COPY_FORCE       */   /* Always copy X or Y to the buffer */\n/* #define NOCOPY_UNALIGNED */   /* Not copy if X or Y is not aligned */\n\n#ifdef MOVUPS_A\n#define MOVUPS_A1(OFF, ADDR, REGS)\t\tMOVUPS_A\tOFF(ADDR), REGS\n#define MOVUPS_A2(OFF, ADDR, BASE, SCALE, REGS)\tMOVUPS_A\tOFF(ADDR, BASE, SCALE), REGS\n#else\n#define MOVUPS_A1(OFF, ADDR, REGS)\t\tmovsd\tOFF(ADDR), REGS; movhps\tOFF + 8(ADDR), REGS\n#define MOVUPS_A2(OFF, ADDR, BASE, SCALE, REGS)\tmovsd\tOFF(ADDR, BASE, SCALE), REGS; movhps\tOFF + 8(ADDR, BASE, SCALE), REGS\n#endif\n\n#define MOVRPS_A1(OFF, ADDR, REGS)\t\tmovsd\tOFF + 8(ADDR), REGS; movhps\tOFF(ADDR), REGS\n#define MOVRPS_A2(OFF, ADDR, BASE, SCALE, REGS)\tmovsd\tOFF + 8(ADDR, BASE, SCALE), REGS; movhps\tOFF(ADDR, BASE, SCALE), REGS\n\n#ifdef MOVUPS_XL\n#define MOVUPS_XL1(OFF, ADDR, REGS)\t\t\tMOVUPS_XL\tOFF(ADDR), REGS\n#else\n#define MOVUPS_XL1(OFF, ADDR, REGS)\t\t\tmovsd\tOFF(ADDR), REGS; movhps\tOFF + 8(ADDR), REGS\n#endif\n\n#ifdef MOVUPS_XS\n#define MOVUPS_XS1(OFF, ADDR, REGS)\t\t\tMOVUPS_XS\tREGS, OFF(ADDR)\n#else\n#define MOVUPS_XS1(OFF, ADDR, REGS)\t\t\tmovsd\tREGS, OFF(ADDR); movhps\tREGS, OFF + 8(ADDR)\n#endif\n\n#ifdef MOVUPS_YL\n#define MOVUPS_YL1(OFF, ADDR, REGS)\t\t\tMOVUPS_YL\tOFF(ADDR), REGS\n#else\n#define MOVUPS_YL1(OFF, ADDR, REGS)\t\t\tmovsd\tOFF(ADDR), REGS; movhps\tOFF + 8(ADDR), REGS\n#endif\n\n#ifdef MOVUPS_YS\n#define MOVUPS_YS1(OFF, ADDR, REGS)\t\t\tMOVUPS_YS\tREGS, OFF(ADDR)\n#else\n#define MOVUPS_YS1(OFF, ADDR, REGS)\t\t\tmovsd\tREGS, OFF(ADDR); movhps\tREGS, OFF + 8(ADDR)\n#endif\n\n\n\n#endif\n"
        },
        {
          "name": "lapack-netlib",
          "type": "tree",
          "content": null
        },
        {
          "name": "lapack",
          "type": "tree",
          "content": null
        },
        {
          "name": "make.inc",
          "type": "blob",
          "size": 0.0947265625,
          "content": "SHELL = /bin/sh\nPLAT = _LINUX\nDRVOPTS  = $(NOOPT)\n#ARCHFLAGS= $(ARFLAGS) -ru\n#RANLIB   = ranlib\n\n"
        },
        {
          "name": "mkdocs.yml",
          "type": "blob",
          "size": 1.3623046875,
          "content": "site_name: OpenBLAS\nsite_url: https://openblas.net/docs/\nrepo_url: https://github.com/OpenMathLib/OpenBLAS\ncopyright: Copyright &copy; 2012- OpenBLAS contributors\n\ntheme:\n  name: material\n  logo: logo.svg\n  favicon: logo.svg\n  features:\n    - header.autohide\n  palette:\n    # Palette toggle for dark mode\n    - scheme: slate\n      primary: blue grey\n      toggle:\n        icon: material/brightness-4\n        name: Switch to light mode\n\n    # Palette toggle for light mode\n    - scheme: default\n      primary: blue grey\n      toggle:\n        icon: material/brightness-7\n        name: Switch to dark mode\n\nplugins:\n  - search\n  - mermaid2\n  - git-revision-date-localized:\n      enable_creation_date: true\n\nmarkdown_extensions:\n  - admonition\n  - pymdownx.details\n  - pymdownx.superfences:\n      custom_fences:\n        - name: mermaid\n          class: mermaid\n          format: !!python/name:mermaid2.fence_mermaid_custom\n  - footnotes\n  - pymdownx.tabbed:\n      alternate_style: true\n  - toc:\n      toc_depth: 4\n\nnav:\n  - index.md\n  - install.md\n  - user_manual.md\n  - extensions.md\n  - developers.md\n  - build_system.md\n  - runtime_variables.md\n  - distributing.md\n  - ci.md\n  - about.md\n  - faq.md\n\nextra:\n  social:\n    - icon: fontawesome/brands/github\n      link: https://github.com/OpenMathLib/OpenBLAS\n    - icon: material/license\n      link: https://github.com/OpenMathLib/OpenBLAS/LICENSE\n"
        },
        {
          "name": "openblas.pc.in",
          "type": "blob",
          "size": 0.28515625,
          "content": "Name: openblas\nDescription: OpenBLAS is an optimized BLAS library based on GotoBLAS2 1.13 BSD version\nVersion: ${version}\nURL: https://github.com/xianyi/OpenBLAS\nLibs: -L${libdir} -l${libprefix}openblas${libsuffix}${libnamesuffix}\nLibs.private: ${extralib}\nCflags: -I${includedir} ${omp_opt}\n"
        },
        {
          "name": "openblas_config_template.h",
          "type": "blob",
          "size": 3.5546875,
          "content": "/*This is only for \"make install\" target.*/\n\n#if defined(OPENBLAS_OS_WINNT) || defined(OPENBLAS_OS_CYGWIN_NT) || defined(OPENBLAS_OS_INTERIX)\n#define OPENBLAS_WINDOWS_ABI\n#define OPENBLAS_OS_WINDOWS\n\n#ifdef DOUBLE\n#define DOUBLE_DEFINED DOUBLE\n#undef  DOUBLE\n#endif\n#endif\n\n#ifdef OPENBLAS_NEEDBUNDERSCORE\n#define BLASFUNC(FUNC) FUNC##_\n#else\n#define BLASFUNC(FUNC) FUNC\n#endif\n\n#ifdef OPENBLAS_QUAD_PRECISION\ntypedef struct {\n  unsigned long x[2];\n}  xdouble;\n#elif defined OPENBLAS_EXPRECISION\n#define xdouble long double\n#else\n#define xdouble double\n#endif\n\n#if defined(OPENBLAS_OS_WINDOWS) && defined(OPENBLAS___64BIT__)\ntypedef long long BLASLONG;\ntypedef unsigned long long BLASULONG;\n#else\ntypedef long BLASLONG;\ntypedef unsigned long BLASULONG;\n#endif\n\n#ifndef BFLOAT16\n#include <stdint.h>\ntypedef uint16_t bfloat16;\n#endif\n\n#ifdef OPENBLAS_USE64BITINT\ntypedef BLASLONG blasint;\n#else\ntypedef int blasint;\n#endif\n\n#if defined(XDOUBLE) || defined(DOUBLE)\n#define FLOATRET\tFLOAT\n#else\n#ifdef NEED_F2CCONV\n#define FLOATRET\tdouble\n#else\n#define FLOATRET\tfloat\n#endif\n#endif\n\n/* Inclusion of a standard header file is needed for definition of __STDC_*\n   predefined macros with some compilers (e.g. GCC 4.7 on Linux).  This occurs\n   as a side effect of including either <features.h> or <stdc-predef.h>. */\n#include <stdio.h>\n\n/* C99 supports complex floating numbers natively, which GCC also offers as an\n   extension since version 3.0.  If neither are available, use a compatible\n   structure as fallback (see Clause 6.2.5.13 of the C99 standard). */\n#if ((defined(__STDC_IEC_559_COMPLEX__) || __STDC_VERSION__ >= 199901L || \\\n      (__GNUC__ >= 3 && !defined(__cplusplus))) && !(defined(FORCE_OPENBLAS_COMPLEX_STRUCT))) && !defined(_MSC_VER)\n  #define OPENBLAS_COMPLEX_C99\n#ifndef __cplusplus\n  #include <complex.h>\n#endif\n  typedef float _Complex openblas_complex_float;\n  typedef double _Complex openblas_complex_double;\n  typedef xdouble _Complex openblas_complex_xdouble;\n  #define openblas_make_complex_float(real, imag)    ((real) + ((imag) * _Complex_I))\n  #define openblas_make_complex_double(real, imag)   ((real) + ((imag) * _Complex_I))\n  #define openblas_make_complex_xdouble(real, imag)  ((real) + ((imag) * _Complex_I))\n  #define openblas_complex_float_real(z)             (creal(z))\n  #define openblas_complex_float_imag(z)             (cimag(z))\n  #define openblas_complex_double_real(z)            (creal(z))\n  #define openblas_complex_double_imag(z)            (cimag(z))\n  #define openblas_complex_xdouble_real(z)           (creal(z))\n  #define openblas_complex_xdouble_imag(z)           (cimag(z))\n#else\n  #define OPENBLAS_COMPLEX_STRUCT\n  typedef struct { float real, imag; } openblas_complex_float;\n  typedef struct { double real, imag; } openblas_complex_double;\n  typedef struct { xdouble real, imag; } openblas_complex_xdouble;\n  #define openblas_make_complex_float(real, imag)    {(real), (imag)}\n  #define openblas_make_complex_double(real, imag)   {(real), (imag)}\n  #define openblas_make_complex_xdouble(real, imag)  {(real), (imag)}\n  #define openblas_complex_float_real(z)             ((z).real)\n  #define openblas_complex_float_imag(z)             ((z).imag)\n  #define openblas_complex_double_real(z)            ((z).real)\n  #define openblas_complex_double_imag(z)            ((z).imag)\n  #define openblas_complex_xdouble_real(z)           ((z).real)\n  #define openblas_complex_xdouble_imag(z)           ((z).imag)\n#endif\n\n/* Inclusion of Linux-specific header is needed for definition of cpu_set_t. */\n#ifdef OPENBLAS_OS_LINUX\n#ifndef _GNU_SOURCE\n #define _GNU_SOURCE\n#endif\n#include <sched.h>\n#endif\n"
        },
        {
          "name": "param.h",
          "type": "blob",
          "size": 96.7236328125,
          "content": "/*****************************************************************************\nCopyright (c) 2011-2023, The OpenBLAS Project\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   1. Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n\n   2. Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in\n      the documentation and/or other materials provided with the\n      distribution.\n   3. Neither the name of the OpenBLAS project nor the names of \n      its contributors may be used to endorse or promote products \n      derived from this software without specific prior written \n      permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\nUSE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n**********************************************************************************/\n\n/*********************************************************************/\n/* Copyright 2009, 2010 The University of Texas at Austin.           */\n/* All rights reserved.                                              */\n/*                                                                   */\n/* Redistribution and use in source and binary forms, with or        */\n/* without modification, are permitted provided that the following   */\n/* conditions are met:                                               */\n/*                                                                   */\n/*   1. Redistributions of source code must retain the above         */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer.                                                  */\n/*                                                                   */\n/*   2. Redistributions in binary form must reproduce the above      */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer in the documentation and/or other materials       */\n/*      provided with the distribution.                              */\n/*                                                                   */\n/*    THIS  SOFTWARE IS PROVIDED  BY THE  UNIVERSITY OF  TEXAS AT    */\n/*    AUSTIN  ``AS IS''  AND ANY  EXPRESS OR  IMPLIED WARRANTIES,    */\n/*    INCLUDING, BUT  NOT LIMITED  TO, THE IMPLIED  WARRANTIES OF    */\n/*    MERCHANTABILITY  AND FITNESS FOR  A PARTICULAR  PURPOSE ARE    */\n/*    DISCLAIMED.  IN  NO EVENT SHALL THE UNIVERSITY  OF TEXAS AT    */\n/*    AUSTIN OR CONTRIBUTORS BE  LIABLE FOR ANY DIRECT, INDIRECT,    */\n/*    INCIDENTAL,  SPECIAL, EXEMPLARY,  OR  CONSEQUENTIAL DAMAGES    */\n/*    (INCLUDING, BUT  NOT LIMITED TO,  PROCUREMENT OF SUBSTITUTE    */\n/*    GOODS  OR  SERVICES; LOSS  OF  USE,  DATA,  OR PROFITS;  OR    */\n/*    BUSINESS INTERRUPTION) HOWEVER CAUSED  AND ON ANY THEORY OF    */\n/*    LIABILITY, WHETHER  IN CONTRACT, STRICT  LIABILITY, OR TORT    */\n/*    (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY WAY OUT    */\n/*    OF  THE  USE OF  THIS  SOFTWARE,  EVEN  IF ADVISED  OF  THE    */\n/*    POSSIBILITY OF SUCH DAMAGE.                                    */\n/*                                                                   */\n/* The views and conclusions contained in the software and           */\n/* documentation are those of the authors and should not be          */\n/* interpreted as representing official policies, either expressed   */\n/* or implied, of The University of Texas at Austin.                 */\n/*********************************************************************/\n\n#ifndef PARAM_H\n#define PARAM_H\n\n\n#define SBGEMM_DEFAULT_UNROLL_N 4\n#define SBGEMM_DEFAULT_UNROLL_M 8\n#define SBGEMM_DEFAULT_UNROLL_MN 32\n#define SBGEMM_DEFAULT_P 256\n#define SBGEMM_DEFAULT_R 256\n#define SBGEMM_DEFAULT_Q 256\n#define SBGEMM_ALIGN_K 1  // must be 2^x\n\n#ifdef OPTERON\n\n#define SNUMOPT\t\t4\n#define DNUMOPT\t\t2\n\n#define GEMM_DEFAULT_OFFSET_A  64\n#define GEMM_DEFAULT_OFFSET_B 256\n#define GEMM_DEFAULT_ALIGN (BLASLONG)0x01ffffUL\n\n#define SGEMM_DEFAULT_UNROLL_N 4\n#define DGEMM_DEFAULT_UNROLL_N 4\n#define QGEMM_DEFAULT_UNROLL_N 2\n#define CGEMM_DEFAULT_UNROLL_N 2\n#define ZGEMM_DEFAULT_UNROLL_N 2\n#define XGEMM_DEFAULT_UNROLL_N 1\n\n#ifdef ARCH_X86\n#define SGEMM_DEFAULT_UNROLL_M 4\n#define DGEMM_DEFAULT_UNROLL_M 2\n#define QGEMM_DEFAULT_UNROLL_M 2\n#define CGEMM_DEFAULT_UNROLL_M 2\n#define ZGEMM_DEFAULT_UNROLL_M 1\n#define XGEMM_DEFAULT_UNROLL_M 1\n#else\n#define SGEMM_DEFAULT_UNROLL_M 8\n#define DGEMM_DEFAULT_UNROLL_M 4\n#define QGEMM_DEFAULT_UNROLL_M 2\n#define CGEMM_DEFAULT_UNROLL_M 4\n#define ZGEMM_DEFAULT_UNROLL_M 2\n#define XGEMM_DEFAULT_UNROLL_M 1\n#endif\n\n#define SGEMM_DEFAULT_P sgemm_p\n#define DGEMM_DEFAULT_P dgemm_p\n#define QGEMM_DEFAULT_P qgemm_p\n#define CGEMM_DEFAULT_P cgemm_p\n#define ZGEMM_DEFAULT_P zgemm_p\n#define XGEMM_DEFAULT_P xgemm_p\n\n#define SGEMM_DEFAULT_R sgemm_r\n#define DGEMM_DEFAULT_R dgemm_r\n#define QGEMM_DEFAULT_R qgemm_r\n#define CGEMM_DEFAULT_R cgemm_r\n#define ZGEMM_DEFAULT_R zgemm_r\n#define XGEMM_DEFAULT_R xgemm_r\n\n#ifdef ALLOC_HUGETLB\n\n#define SGEMM_DEFAULT_Q 248\n#define DGEMM_DEFAULT_Q 248\n#define QGEMM_DEFAULT_Q 248\n#define CGEMM_DEFAULT_Q 248\n#define ZGEMM_DEFAULT_Q 248\n#define XGEMM_DEFAULT_Q 248\n\n#else\n\n#define SGEMM_DEFAULT_Q 240\n#define DGEMM_DEFAULT_Q 240\n#define QGEMM_DEFAULT_Q 240\n#define CGEMM_DEFAULT_Q 240\n#define ZGEMM_DEFAULT_Q 240\n#define XGEMM_DEFAULT_Q 240\n\n#endif\n\n\n#define SYMV_P\t16\n#define HAVE_EXCLUSIVE_CACHE\n\n#endif\n\n#if defined(BARCELONA) || defined(SHANGHAI) || defined(BOBCAT)\n\n#define SNUMOPT\t\t8\n#define DNUMOPT\t\t4\n\n#define GEMM_DEFAULT_OFFSET_A  64\n#define GEMM_DEFAULT_OFFSET_B 832\n#define GEMM_DEFAULT_ALIGN (BLASLONG)0x0fffUL\n\n#define SGEMM_DEFAULT_UNROLL_N 4\n#define DGEMM_DEFAULT_UNROLL_N 4\n#define QGEMM_DEFAULT_UNROLL_N 2\n#define CGEMM_DEFAULT_UNROLL_N 2\n#define ZGEMM_DEFAULT_UNROLL_N 2\n#define XGEMM_DEFAULT_UNROLL_N 1\n\n#ifdef ARCH_X86\n#define SGEMM_DEFAULT_UNROLL_M 4\n#define DGEMM_DEFAULT_UNROLL_M 2\n#define QGEMM_DEFAULT_UNROLL_M 2\n#define CGEMM_DEFAULT_UNROLL_M 2\n#define ZGEMM_DEFAULT_UNROLL_M 1\n#define XGEMM_DEFAULT_UNROLL_M 1\n#else\n#define SGEMM_DEFAULT_UNROLL_M 8\n#define DGEMM_DEFAULT_UNROLL_M 4\n#define QGEMM_DEFAULT_UNROLL_M 2\n#define CGEMM_DEFAULT_UNROLL_M 4\n#define ZGEMM_DEFAULT_UNROLL_M 2\n#define XGEMM_DEFAULT_UNROLL_M 1\n#endif\n\n#if 0\n#define SGEMM_DEFAULT_P 496\n#define DGEMM_DEFAULT_P 248\n#define QGEMM_DEFAULT_P 124\n#define CGEMM_DEFAULT_P 248\n#define ZGEMM_DEFAULT_P 124\n#define XGEMM_DEFAULT_P  62\n\n#define SGEMM_DEFAULT_Q 248\n#define DGEMM_DEFAULT_Q 248\n#define QGEMM_DEFAULT_Q 248\n#define CGEMM_DEFAULT_Q 248\n#define ZGEMM_DEFAULT_Q 248\n#define XGEMM_DEFAULT_Q 248\n\n#else\n\n#define SGEMM_DEFAULT_P 448\n#define DGEMM_DEFAULT_P 224\n#define QGEMM_DEFAULT_P 112\n#define CGEMM_DEFAULT_P 224\n#define ZGEMM_DEFAULT_P 112\n#define XGEMM_DEFAULT_P  56\n\n#define SGEMM_DEFAULT_Q 224\n#define DGEMM_DEFAULT_Q 224\n#define QGEMM_DEFAULT_Q 224\n#define CGEMM_DEFAULT_Q 224\n#define ZGEMM_DEFAULT_Q 224\n#define XGEMM_DEFAULT_Q 224\n\n#endif\n\n#define SGEMM_DEFAULT_R sgemm_r\n#define QGEMM_DEFAULT_R qgemm_r\n#define DGEMM_DEFAULT_R dgemm_r\n#define CGEMM_DEFAULT_R cgemm_r\n#define ZGEMM_DEFAULT_R zgemm_r\n#define XGEMM_DEFAULT_R xgemm_r\n\n#define SYMV_P\t16\n#define HAVE_EXCLUSIVE_CACHE\n\n#define GEMM_THREAD gemm_thread_mn\n\n#endif\n\n\n#ifdef BULLDOZER\n\n#define SNUMOPT\t\t8\n#define DNUMOPT\t\t4\n\n#define GEMM_DEFAULT_OFFSET_A  64\n#define GEMM_DEFAULT_OFFSET_B 832\n#define GEMM_DEFAULT_ALIGN (BLASLONG)0x0fffUL\n\n\n\n#define QGEMM_DEFAULT_UNROLL_N 2\n#define CGEMM_DEFAULT_UNROLL_N 2\n#define ZGEMM_DEFAULT_UNROLL_N 2\n#define XGEMM_DEFAULT_UNROLL_N 1\n\n#ifdef ARCH_X86\n#define SGEMM_DEFAULT_UNROLL_N 4\n#define DGEMM_DEFAULT_UNROLL_N 4\n#define SGEMM_DEFAULT_UNROLL_M 4\n#define DGEMM_DEFAULT_UNROLL_M 2\n#define QGEMM_DEFAULT_UNROLL_M 2\n#define CGEMM_DEFAULT_UNROLL_M 2\n#define ZGEMM_DEFAULT_UNROLL_M 1\n#define XGEMM_DEFAULT_UNROLL_M 1\n#else\n#define SGEMM_DEFAULT_UNROLL_N 2\n#define DGEMM_DEFAULT_UNROLL_N 2\n#define SGEMM_DEFAULT_UNROLL_M 16\n#define DGEMM_DEFAULT_UNROLL_M 8\n#define QGEMM_DEFAULT_UNROLL_M 2\n#define CGEMM_DEFAULT_UNROLL_M 4\n#define ZGEMM_DEFAULT_UNROLL_M 2\n#define XGEMM_DEFAULT_UNROLL_M 1\n#define CGEMM3M_DEFAULT_UNROLL_N 4\n#define CGEMM3M_DEFAULT_UNROLL_M 8\n#define ZGEMM3M_DEFAULT_UNROLL_N 4\n#define ZGEMM3M_DEFAULT_UNROLL_M 4\n\n#define DGEMM_DEFAULT_UNROLL_MN 16\n#define GEMV_UNROLL 8\n#endif\n\n\n#if defined(ARCH_X86_64)\n#define SGEMM_DEFAULT_P 768\n#define DGEMM_DEFAULT_P 384\n#else\n#define SGEMM_DEFAULT_P 448\n#define DGEMM_DEFAULT_P 224\n#endif\n\n#define QGEMM_DEFAULT_P 112\n#define CGEMM_DEFAULT_P 224\n#define ZGEMM_DEFAULT_P 112\n#define XGEMM_DEFAULT_P  56\n\n#if defined(ARCH_X86_64)\n#define SGEMM_DEFAULT_Q 168\n#define DGEMM_DEFAULT_Q 168\n#else\n#define SGEMM_DEFAULT_Q 224\n#define DGEMM_DEFAULT_Q 224\n#endif\n\n#define QGEMM_DEFAULT_Q 224\n#define CGEMM_DEFAULT_Q 224\n#define ZGEMM_DEFAULT_Q 224\n#define XGEMM_DEFAULT_Q 224\n\n#define CGEMM3M_DEFAULT_P 448\n#define ZGEMM3M_DEFAULT_P 224\n#define XGEMM3M_DEFAULT_P 112\n#define CGEMM3M_DEFAULT_Q 224\n#define ZGEMM3M_DEFAULT_Q 224\n#define XGEMM3M_DEFAULT_Q 224\n#define CGEMM3M_DEFAULT_R 12288\n#define ZGEMM3M_DEFAULT_R 12288\n#define XGEMM3M_DEFAULT_R 12288\n\n#define SGEMM_DEFAULT_R sgemm_r\n#define QGEMM_DEFAULT_R qgemm_r\n#define DGEMM_DEFAULT_R dgemm_r\n#define CGEMM_DEFAULT_R cgemm_r\n#define ZGEMM_DEFAULT_R zgemm_r\n#define XGEMM_DEFAULT_R xgemm_r\n\n#define SYMV_P\t16\n#define HAVE_EXCLUSIVE_CACHE\n\n#define GEMM_THREAD gemm_thread_mn\n\n#endif\n\n#ifdef PILEDRIVER\n#define SNUMOPT         8\n#define DNUMOPT         4\n\n#define GEMM_DEFAULT_OFFSET_A  64\n#define GEMM_DEFAULT_OFFSET_B 832\n#define GEMM_DEFAULT_ALIGN (BLASLONG)0x0fffUL\n\n\n\n#define QGEMM_DEFAULT_UNROLL_N 2\n#define CGEMM_DEFAULT_UNROLL_N 2\n#define ZGEMM_DEFAULT_UNROLL_N 2\n#define XGEMM_DEFAULT_UNROLL_N 1\n\n#ifdef ARCH_X86\n#define SGEMM_DEFAULT_UNROLL_N 4\n#define DGEMM_DEFAULT_UNROLL_N 4\n#define SGEMM_DEFAULT_UNROLL_M 4\n#define DGEMM_DEFAULT_UNROLL_M 2\n#define QGEMM_DEFAULT_UNROLL_M 2\n#define CGEMM_DEFAULT_UNROLL_M 2\n#define ZGEMM_DEFAULT_UNROLL_M 1\n#define XGEMM_DEFAULT_UNROLL_M 1\n#else\n#define SGEMM_DEFAULT_UNROLL_N 2\n#define DGEMM_DEFAULT_UNROLL_N 2\n#define SGEMM_DEFAULT_UNROLL_M 16\n#define DGEMM_DEFAULT_UNROLL_M 8\n#define QGEMM_DEFAULT_UNROLL_M 2\n#define CGEMM_DEFAULT_UNROLL_M 4\n#define ZGEMM_DEFAULT_UNROLL_M 2\n#define XGEMM_DEFAULT_UNROLL_M 1\n#define CGEMM3M_DEFAULT_UNROLL_N 4\n#define CGEMM3M_DEFAULT_UNROLL_M 8\n#define ZGEMM3M_DEFAULT_UNROLL_N 4\n#define ZGEMM3M_DEFAULT_UNROLL_M 4\n#define GEMV_UNROLL 8\n#endif\n\n#if defined(ARCH_X86_64)\n#define SGEMM_DEFAULT_P 768\n#define DGEMM_DEFAULT_P 768\n#define ZGEMM_DEFAULT_P 384\n#define CGEMM_DEFAULT_P 768\n#else\n#define SGEMM_DEFAULT_P 448\n#define DGEMM_DEFAULT_P 480\n#define ZGEMM_DEFAULT_P 112\n#define CGEMM_DEFAULT_P 224\n#endif\n#define QGEMM_DEFAULT_P 112\n#define XGEMM_DEFAULT_P  56\n\n#if defined(ARCH_X86_64)\n#define SGEMM_DEFAULT_Q 192\n#define DGEMM_DEFAULT_Q 168\n#define ZGEMM_DEFAULT_Q 168\n#define CGEMM_DEFAULT_Q 168\n#else\n#define SGEMM_DEFAULT_Q 224\n#define DGEMM_DEFAULT_Q 224\n#define ZGEMM_DEFAULT_Q 224\n#define CGEMM_DEFAULT_Q 224\n#endif\n#define QGEMM_DEFAULT_Q 224\n#define XGEMM_DEFAULT_Q 224\n\n#define CGEMM3M_DEFAULT_P 448\n#define ZGEMM3M_DEFAULT_P 224\n#define XGEMM3M_DEFAULT_P 112\n#define CGEMM3M_DEFAULT_Q 224\n#define ZGEMM3M_DEFAULT_Q 224\n#define XGEMM3M_DEFAULT_Q 224\n#define CGEMM3M_DEFAULT_R 12288\n#define ZGEMM3M_DEFAULT_R 12288\n#define XGEMM3M_DEFAULT_R 12288\n\n#define SGEMM_DEFAULT_R 12288\n#define QGEMM_DEFAULT_R qgemm_r\n#define DGEMM_DEFAULT_R 12288\n#define CGEMM_DEFAULT_R cgemm_r\n#define ZGEMM_DEFAULT_R zgemm_r\n#define XGEMM_DEFAULT_R xgemm_r\n\n#define SYMV_P  16\n#define HAVE_EXCLUSIVE_CACHE\n\n#define GEMM_THREAD gemm_thread_mn\n\n#endif\n\n#ifdef STEAMROLLER\n#define SNUMOPT         8\n#define DNUMOPT         4\n\n#define GEMM_DEFAULT_OFFSET_A  64\n#define GEMM_DEFAULT_OFFSET_B 832\n#define GEMM_DEFAULT_ALIGN (BLASLONG)0x0fffUL\n\n\n\n#define QGEMM_DEFAULT_UNROLL_N 2\n#define CGEMM_DEFAULT_UNROLL_N 2\n#define ZGEMM_DEFAULT_UNROLL_N 2\n#define XGEMM_DEFAULT_UNROLL_N 1\n\n#ifdef ARCH_X86\n#define SGEMM_DEFAULT_UNROLL_N 4\n#define DGEMM_DEFAULT_UNROLL_N 4\n#define SGEMM_DEFAULT_UNROLL_M 4\n#define DGEMM_DEFAULT_UNROLL_M 2\n#define QGEMM_DEFAULT_UNROLL_M 2\n#define CGEMM_DEFAULT_UNROLL_M 2\n#define ZGEMM_DEFAULT_UNROLL_M 1\n#define XGEMM_DEFAULT_UNROLL_M 1\n#else\n#define SGEMM_DEFAULT_UNROLL_N 2\n#define DGEMM_DEFAULT_UNROLL_N 2\n#define SGEMM_DEFAULT_UNROLL_M 16\n#define DGEMM_DEFAULT_UNROLL_M 8\n#define QGEMM_DEFAULT_UNROLL_M 2\n#define CGEMM_DEFAULT_UNROLL_M 4\n#define ZGEMM_DEFAULT_UNROLL_M 2\n#define XGEMM_DEFAULT_UNROLL_M 1\n#define CGEMM3M_DEFAULT_UNROLL_N 4\n#define CGEMM3M_DEFAULT_UNROLL_M 8\n#define ZGEMM3M_DEFAULT_UNROLL_N 4\n#define ZGEMM3M_DEFAULT_UNROLL_M 4\n#define GEMV_UNROLL 8\n#endif\n\n#if defined(ARCH_X86_64)\n#define SGEMM_DEFAULT_P 768\n#define DGEMM_DEFAULT_P 576\n#define ZGEMM_DEFAULT_P 288\n#define CGEMM_DEFAULT_P 576\n#else\n#define SGEMM_DEFAULT_P 448\n#define DGEMM_DEFAULT_P 480\n#define ZGEMM_DEFAULT_P 112\n#define CGEMM_DEFAULT_P 224\n#endif\n#define QGEMM_DEFAULT_P 112\n#define XGEMM_DEFAULT_P  56\n\n#if defined(ARCH_X86_64)\n#define SGEMM_DEFAULT_Q 192\n#define DGEMM_DEFAULT_Q 160\n#define ZGEMM_DEFAULT_Q 160\n#define CGEMM_DEFAULT_Q 160\n#else\n#define SGEMM_DEFAULT_Q 224\n#define DGEMM_DEFAULT_Q 224\n#define ZGEMM_DEFAULT_Q 224\n#define CGEMM_DEFAULT_Q 224\n#endif\n#define QGEMM_DEFAULT_Q 224\n#define XGEMM_DEFAULT_Q 224\n\n#define CGEMM3M_DEFAULT_P 448\n#define ZGEMM3M_DEFAULT_P 224\n#define XGEMM3M_DEFAULT_P 112\n#define CGEMM3M_DEFAULT_Q 224\n#define ZGEMM3M_DEFAULT_Q 224\n#define XGEMM3M_DEFAULT_Q 224\n#define CGEMM3M_DEFAULT_R 12288\n#define ZGEMM3M_DEFAULT_R 12288\n#define XGEMM3M_DEFAULT_R 12288\n\n#define SGEMM_DEFAULT_R 12288\n#define QGEMM_DEFAULT_R qgemm_r\n#define DGEMM_DEFAULT_R 12288\n#define CGEMM_DEFAULT_R cgemm_r\n#define ZGEMM_DEFAULT_R zgemm_r\n#define XGEMM_DEFAULT_R xgemm_r\n\n#define SYMV_P  16\n#define HAVE_EXCLUSIVE_CACHE\n\n#define GEMM_THREAD gemm_thread_mn\n\n#endif\n\n\n#ifdef EXCAVATOR\n#define SNUMOPT         8\n#define DNUMOPT         4\n\n#define GEMM_DEFAULT_OFFSET_A  64\n#define GEMM_DEFAULT_OFFSET_B 832\n#define GEMM_DEFAULT_ALIGN (BLASLONG)0x0fffUL\n\n\n\n#define QGEMM_DEFAULT_UNROLL_N 2\n#define CGEMM_DEFAULT_UNROLL_N 2\n#define ZGEMM_DEFAULT_UNROLL_N 2\n#define XGEMM_DEFAULT_UNROLL_N 1\n\n#ifdef ARCH_X86\n#define SGEMM_DEFAULT_UNROLL_N 4\n#define DGEMM_DEFAULT_UNROLL_N 4\n#define SGEMM_DEFAULT_UNROLL_M 4\n#define DGEMM_DEFAULT_UNROLL_M 2\n#define QGEMM_DEFAULT_UNROLL_M 2\n#define CGEMM_DEFAULT_UNROLL_M 2\n#define ZGEMM_DEFAULT_UNROLL_M 1\n#define XGEMM_DEFAULT_UNROLL_M 1\n#else\n#define SGEMM_DEFAULT_UNROLL_N 2\n#define DGEMM_DEFAULT_UNROLL_N 2\n#define SGEMM_DEFAULT_UNROLL_M 16\n#define DGEMM_DEFAULT_UNROLL_M 8\n#define QGEMM_DEFAULT_UNROLL_M 2\n#define CGEMM_DEFAULT_UNROLL_M 4\n#define ZGEMM_DEFAULT_UNROLL_M 2\n#define XGEMM_DEFAULT_UNROLL_M 1\n#define CGEMM3M_DEFAULT_UNROLL_N 4\n#define CGEMM3M_DEFAULT_UNROLL_M 8\n#define ZGEMM3M_DEFAULT_UNROLL_N 4\n#define ZGEMM3M_DEFAULT_UNROLL_M 4\n#define GEMV_UNROLL 8\n#endif\n\n#if defined(ARCH_X86_64)\n#define SGEMM_DEFAULT_P 768\n#define DGEMM_DEFAULT_P 576\n#define ZGEMM_DEFAULT_P 288\n#define CGEMM_DEFAULT_P 576\n#else\n#define SGEMM_DEFAULT_P 448\n#define DGEMM_DEFAULT_P 480\n#define ZGEMM_DEFAULT_P 112\n#define CGEMM_DEFAULT_P 224\n#endif\n#define QGEMM_DEFAULT_P 112\n#define XGEMM_DEFAULT_P  56\n\n#if defined(ARCH_X86_64)\n#define SGEMM_DEFAULT_Q 192\n#define DGEMM_DEFAULT_Q 160\n#define ZGEMM_DEFAULT_Q 160\n#define CGEMM_DEFAULT_Q 160\n#else\n#define SGEMM_DEFAULT_Q 224\n#define DGEMM_DEFAULT_Q 224\n#define ZGEMM_DEFAULT_Q 224\n#define CGEMM_DEFAULT_Q 224\n#endif\n#define QGEMM_DEFAULT_Q 224\n#define XGEMM_DEFAULT_Q 224\n\n#define CGEMM3M_DEFAULT_P 448\n#define ZGEMM3M_DEFAULT_P 224\n#define XGEMM3M_DEFAULT_P 112\n#define CGEMM3M_DEFAULT_Q 224\n#define ZGEMM3M_DEFAULT_Q 224\n#define XGEMM3M_DEFAULT_Q 224\n#define CGEMM3M_DEFAULT_R 12288\n#define ZGEMM3M_DEFAULT_R 12288\n#define XGEMM3M_DEFAULT_R 12288\n\n#define SGEMM_DEFAULT_R 12288\n#define QGEMM_DEFAULT_R qgemm_r\n#define DGEMM_DEFAULT_R 12288\n#define CGEMM_DEFAULT_R cgemm_r\n#define ZGEMM_DEFAULT_R zgemm_r\n#define XGEMM_DEFAULT_R xgemm_r\n\n#define SYMV_P  16\n#define HAVE_EXCLUSIVE_CACHE\n\n#define GEMM_THREAD gemm_thread_mn\n\n#endif\n\n#ifdef ZEN\n#define SNUMOPT         16\n#define DNUMOPT         8\n\n#define GEMM_DEFAULT_OFFSET_A     0\n#define GEMM_DEFAULT_OFFSET_B     0\n#define GEMM_DEFAULT_ALIGN (BLASLONG)0x03fffUL\n\n#define SYMV_P  8\n\n#if defined(XDOUBLE) || defined(DOUBLE)\n#define SWITCH_RATIO            4\n#define GEMM_PREFERED_SIZE      4\n#else\n#define SWITCH_RATIO            8\n#define GEMM_PREFERED_SIZE      8\n#endif\n\n#ifdef ARCH_X86\n\n#define SGEMM_DEFAULT_UNROLL_M 4\n#define DGEMM_DEFAULT_UNROLL_M 2\n#define QGEMM_DEFAULT_UNROLL_M 2\n#define CGEMM_DEFAULT_UNROLL_M 2\n#define ZGEMM_DEFAULT_UNROLL_M 1\n#define XGEMM_DEFAULT_UNROLL_M 1\n\n#define SGEMM_DEFAULT_UNROLL_N 4\n#define DGEMM_DEFAULT_UNROLL_N 4\n#define QGEMM_DEFAULT_UNROLL_N 2\n#define CGEMM_DEFAULT_UNROLL_N 2\n#define ZGEMM_DEFAULT_UNROLL_N 2\n#define XGEMM_DEFAULT_UNROLL_N 1\n\n#else\n\n#define SGEMM_DEFAULT_UNROLL_M 8\n#define DGEMM_DEFAULT_UNROLL_M 4\n#define QGEMM_DEFAULT_UNROLL_M 2\n#define CGEMM_DEFAULT_UNROLL_M 8\n#define ZGEMM_DEFAULT_UNROLL_M 4\n#define XGEMM_DEFAULT_UNROLL_M 1\n\n#define SGEMM_DEFAULT_UNROLL_N 4\n#define DGEMM_DEFAULT_UNROLL_N 8\n#define QGEMM_DEFAULT_UNROLL_N 2\n#define CGEMM_DEFAULT_UNROLL_N 2\n#define ZGEMM_DEFAULT_UNROLL_N 2\n#define XGEMM_DEFAULT_UNROLL_N 1\n/*\n#define SGEMM_DEFAULT_UNROLL_MN 32\n#define DGEMM_DEFAULT_UNROLL_MN 32\n*/\n#endif\n\n#ifdef ARCH_X86\n\n#define SGEMM_DEFAULT_P 512\n#define SGEMM_DEFAULT_R sgemm_r\n#define DGEMM_DEFAULT_P 512\n#define DGEMM_DEFAULT_R dgemm_r\n#define QGEMM_DEFAULT_P 504\n#define QGEMM_DEFAULT_R qgemm_r\n#define CGEMM_DEFAULT_P 128\n#define CGEMM_DEFAULT_R 1024\n#define ZGEMM_DEFAULT_P 512\n#define ZGEMM_DEFAULT_R zgemm_r\n#define XGEMM_DEFAULT_P 252\n#define XGEMM_DEFAULT_R xgemm_r\n#define SGEMM_DEFAULT_Q 256\n#define DGEMM_DEFAULT_Q 256\n#define QGEMM_DEFAULT_Q 128\n#define CGEMM_DEFAULT_Q 256\n#define ZGEMM_DEFAULT_Q 192\n#define XGEMM_DEFAULT_Q 128\n\n#else\n\n#define SGEMM_DEFAULT_P 320\n#define DGEMM_DEFAULT_P 512\n#define CGEMM_DEFAULT_P 256\n#define ZGEMM_DEFAULT_P 192\n\n#ifdef WINDOWS_ABI\n#define SGEMM_DEFAULT_Q 320\n#define DGEMM_DEFAULT_Q 128\n#else\n#define SGEMM_DEFAULT_Q 320\n#define DGEMM_DEFAULT_Q 256\n#endif\n#define CGEMM_DEFAULT_Q 256\n#define ZGEMM_DEFAULT_Q 192\n\n#define SGEMM_DEFAULT_R sgemm_r\n#define DGEMM_DEFAULT_R 13824\n#define CGEMM_DEFAULT_R cgemm_r\n#define ZGEMM_DEFAULT_R zgemm_r\n\n#define QGEMM_DEFAULT_Q 128\n#define QGEMM_DEFAULT_P 504\n#define QGEMM_DEFAULT_R qgemm_r\n#define XGEMM_DEFAULT_P 252\n#define XGEMM_DEFAULT_R xgemm_r\n#define XGEMM_DEFAULT_Q 128\n\n#define CGEMM3M_DEFAULT_UNROLL_N 4\n#define CGEMM3M_DEFAULT_UNROLL_M 8\n#define ZGEMM3M_DEFAULT_UNROLL_N 4\n#define ZGEMM3M_DEFAULT_UNROLL_M 4\n\n#define CGEMM3M_DEFAULT_P 320\n#define ZGEMM3M_DEFAULT_P 256\n#define XGEMM3M_DEFAULT_P 112\n#define CGEMM3M_DEFAULT_Q 320\n#define ZGEMM3M_DEFAULT_Q 256\n#define XGEMM3M_DEFAULT_Q 224\n#define CGEMM3M_DEFAULT_R 12288\n#define ZGEMM3M_DEFAULT_R 12288\n#define XGEMM3M_DEFAULT_R 12288\n\n#endif\n\n#endif\n\n#ifdef ATHLON\n\n#define SNUMOPT\t\t4\n#define DNUMOPT\t\t2\n\n#define GEMM_DEFAULT_OFFSET_A   0\n#define GEMM_DEFAULT_OFFSET_B 384\n#define GEMM_DEFAULT_ALIGN (BLASLONG)0x0ffffUL\n\n#define SGEMM_DEFAULT_UNROLL_N 4\n#define DGEMM_DEFAULT_UNROLL_N 4\n#define QGEMM_DEFAULT_UNROLL_N 2\n#define CGEMM_DEFAULT_UNROLL_N 2\n#define ZGEMM_DEFAULT_UNROLL_N 2\n#define XGEMM_DEFAULT_UNROLL_N 1\n\n#define SGEMM_DEFAULT_UNROLL_M 2\n#define DGEMM_DEFAULT_UNROLL_M 1\n#define QGEMM_DEFAULT_UNROLL_M 2\n#define CGEMM_DEFAULT_UNROLL_M 1\n#define ZGEMM_DEFAULT_UNROLL_M 1\n#define XGEMM_DEFAULT_UNROLL_M 1\n\n#define SGEMM_DEFAULT_R sgemm_r\n#define DGEMM_DEFAULT_R dgemm_r\n#define QGEMM_DEFAULT_R qgemm_r\n#define CGEMM_DEFAULT_R cgemm_r\n#define ZGEMM_DEFAULT_R zgemm_r\n#define XGEMM_DEFAULT_R xgemm_r\n\n#define SGEMM_DEFAULT_P 208\n#define DGEMM_DEFAULT_P 104\n#define QGEMM_DEFAULT_P  56\n#define CGEMM_DEFAULT_P 104\n#define ZGEMM_DEFAULT_P  56\n#define XGEMM_DEFAULT_P  28\n\n#define SGEMM_DEFAULT_Q 208\n#define DGEMM_DEFAULT_Q 208\n#define QGEMM_DEFAULT_Q 208\n#define CGEMM_DEFAULT_Q 208\n#define ZGEMM_DEFAULT_Q 208\n#define XGEMM_DEFAULT_Q 208\n\n#define SYMV_P\t16\n#define HAVE_EXCLUSIVE_CACHE\n#endif\n\n#ifdef VIAC3\n\n#define SNUMOPT\t\t2\n#define DNUMOPT\t\t1\n\n#define GEMM_DEFAULT_OFFSET_A   0\n#define GEMM_DEFAULT_OFFSET_B 256\n#define GEMM_DEFAULT_ALIGN (BLASLONG)0x0ffffUL\n\n#define SGEMM_DEFAULT_UNROLL_N 4\n#define DGEMM_DEFAULT_UNROLL_N 4\n#define QGEMM_DEFAULT_UNROLL_N 2\n#define CGEMM_DEFAULT_UNROLL_N 2\n#define ZGEMM_DEFAULT_UNROLL_N 2\n#define XGEMM_DEFAULT_UNROLL_N 1\n\n#define SGEMM_DEFAULT_UNROLL_M 2\n#define DGEMM_DEFAULT_UNROLL_M 1\n#define QGEMM_DEFAULT_UNROLL_M 2\n#define CGEMM_DEFAULT_UNROLL_M 1\n#define ZGEMM_DEFAULT_UNROLL_M 1\n#define XGEMM_DEFAULT_UNROLL_M 1\n\n#define SGEMM_DEFAULT_R sgemm_r\n#define DGEMM_DEFAULT_R dgemm_r\n#define QGEMM_DEFAULT_R qgemm_r\n#define CGEMM_DEFAULT_R cgemm_r\n#define ZGEMM_DEFAULT_R zgemm_r\n#define XGEMM_DEFAULT_R xgemm_r\n\n#define SGEMM_DEFAULT_P 128\n#define DGEMM_DEFAULT_P 128\n#define QGEMM_DEFAULT_P 128\n#define CGEMM_DEFAULT_P 128\n#define ZGEMM_DEFAULT_P 128\n#define XGEMM_DEFAULT_P 128\n\n#define SGEMM_DEFAULT_Q 512\n#define DGEMM_DEFAULT_Q 256\n#define QGEMM_DEFAULT_Q 256\n#define CGEMM_DEFAULT_Q 256\n#define ZGEMM_DEFAULT_Q 128\n#define XGEMM_DEFAULT_Q 128\n\n#define SYMV_P\t16\n#endif\n\n#ifdef NANO\n\n#define SNUMOPT\t\t4\n#define DNUMOPT\t\t2\n\n#define GEMM_DEFAULT_OFFSET_A  64\n#define GEMM_DEFAULT_OFFSET_B 256\n#define GEMM_DEFAULT_ALIGN (BLASLONG)0x01ffffUL\n\n#ifdef ARCH_X86\n#define SGEMM_DEFAULT_UNROLL_N 4\n#define DGEMM_DEFAULT_UNROLL_N 4\n#define QGEMM_DEFAULT_UNROLL_N 2\n#define CGEMM_DEFAULT_UNROLL_N 2\n#define ZGEMM_DEFAULT_UNROLL_N 2\n#define XGEMM_DEFAULT_UNROLL_N 1\n\n#define SGEMM_DEFAULT_UNROLL_M 4\n#define DGEMM_DEFAULT_UNROLL_M 2\n#define QGEMM_DEFAULT_UNROLL_M 2\n#define CGEMM_DEFAULT_UNROLL_M 2\n#define ZGEMM_DEFAULT_UNROLL_M 1\n#define XGEMM_DEFAULT_UNROLL_M 1\n#else\n#define SGEMM_DEFAULT_UNROLL_N 8\n#define DGEMM_DEFAULT_UNROLL_N 4\n#define QGEMM_DEFAULT_UNROLL_N 2\n#define CGEMM_DEFAULT_UNROLL_N 4\n#define ZGEMM_DEFAULT_UNROLL_N 2\n#define XGEMM_DEFAULT_UNROLL_N 1\n\n#define SGEMM_DEFAULT_UNROLL_M 4\n#define DGEMM_DEFAULT_UNROLL_M 4\n#define QGEMM_DEFAULT_UNROLL_M 2\n#define CGEMM_DEFAULT_UNROLL_M 2\n#define ZGEMM_DEFAULT_UNROLL_M 2\n#define XGEMM_DEFAULT_UNROLL_M 1\n#endif\n\n#define SGEMM_DEFAULT_P 288\n#define DGEMM_DEFAULT_P 288\n#define QGEMM_DEFAULT_P 288\n#define CGEMM_DEFAULT_P 288\n#define ZGEMM_DEFAULT_P 288\n#define XGEMM_DEFAULT_P 288\n\n#define SGEMM_DEFAULT_R sgemm_r\n#define DGEMM_DEFAULT_R dgemm_r\n#define QGEMM_DEFAULT_R qgemm_r\n#define CGEMM_DEFAULT_R cgemm_r\n#define ZGEMM_DEFAULT_R zgemm_r\n#define XGEMM_DEFAULT_R xgemm_r\n\n#define SGEMM_DEFAULT_Q 256\n#define DGEMM_DEFAULT_Q 128\n#define QGEMM_DEFAULT_Q  64\n#define CGEMM_DEFAULT_Q 128\n#define ZGEMM_DEFAULT_Q  64\n#define XGEMM_DEFAULT_Q  32\n\n#define SYMV_P\t16\n#define HAVE_EXCLUSIVE_CACHE\n\n#endif\n\n#if defined(PENTIUM) || defined(PENTIUM2) || defined(PENTIUM3)\n\n#ifdef HAVE_SSE\n#define SNUMOPT\t\t2\n#else\n#define SNUMOPT\t\t1\n#endif\n#define DNUMOPT\t\t1\n\n#define GEMM_DEFAULT_OFFSET_A 0\n#define GEMM_DEFAULT_OFFSET_B 0\n#define GEMM_DEFAULT_ALIGN (BLASLONG)0x0ffffUL\n\n#ifdef HAVE_SSE\n#define SGEMM_DEFAULT_UNROLL_M 8\n#define CGEMM_DEFAULT_UNROLL_M 4\n#else\n#define SGEMM_DEFAULT_UNROLL_M 4\n#define CGEMM_DEFAULT_UNROLL_M 2\n#endif\n#define DGEMM_DEFAULT_UNROLL_M 2\n#define SGEMM_DEFAULT_UNROLL_N 2\n#define DGEMM_DEFAULT_UNROLL_N 2\n#define QGEMM_DEFAULT_UNROLL_M 2\n#define QGEMM_DEFAULT_UNROLL_N 2\n#define CGEMM_DEFAULT_UNROLL_N 1\n#define ZGEMM_DEFAULT_UNROLL_M 1\n#define ZGEMM_DEFAULT_UNROLL_N 1\n#define XGEMM_DEFAULT_UNROLL_M 1\n#define XGEMM_DEFAULT_UNROLL_N 1\n\n#define SGEMM_DEFAULT_P sgemm_p\n#define SGEMM_DEFAULT_Q 256\n#define SGEMM_DEFAULT_R sgemm_r\n\n#define DGEMM_DEFAULT_P dgemm_p\n#define DGEMM_DEFAULT_Q 256\n#define DGEMM_DEFAULT_R dgemm_r\n\n#define QGEMM_DEFAULT_P qgemm_p\n#define QGEMM_DEFAULT_Q 256\n#define QGEMM_DEFAULT_R qgemm_r\n\n#define CGEMM_DEFAULT_P cgemm_p\n#define CGEMM_DEFAULT_Q 256\n#define CGEMM_DEFAULT_R cgemm_r\n\n#define ZGEMM_DEFAULT_P zgemm_p\n#define ZGEMM_DEFAULT_Q 256\n#define ZGEMM_DEFAULT_R zgemm_r\n\n#define XGEMM_DEFAULT_P xgemm_p\n#define XGEMM_DEFAULT_Q 256\n#define XGEMM_DEFAULT_R xgemm_r\n\n#define SYMV_P\t4\n\n#endif\n\n#ifdef PENTIUMM\n\n#define SNUMOPT\t\t2\n#define DNUMOPT\t\t1\n\n#define GEMM_DEFAULT_OFFSET_A 0\n#define GEMM_DEFAULT_OFFSET_B 0\n#define GEMM_DEFAULT_ALIGN (BLASLONG)0x0ffffUL\n\n#ifdef CORE_YONAH\n#define SGEMM_DEFAULT_UNROLL_M 4\n#define SGEMM_DEFAULT_UNROLL_N 4\n#define DGEMM_DEFAULT_UNROLL_M 2\n#define DGEMM_DEFAULT_UNROLL_N 4\n#define QGEMM_DEFAULT_UNROLL_M 2\n#define QGEMM_DEFAULT_UNROLL_N 2\n#define CGEMM_DEFAULT_UNROLL_M 2\n#define CGEMM_DEFAULT_UNROLL_N 2\n#define ZGEMM_DEFAULT_UNROLL_M 1\n#define ZGEMM_DEFAULT_UNROLL_N 2\n#define XGEMM_DEFAULT_UNROLL_M 1\n#define XGEMM_DEFAULT_UNROLL_N 1\n#else\n#define SGEMM_DEFAULT_UNROLL_M 8\n#define SGEMM_DEFAULT_UNROLL_N 2\n#define DGEMM_DEFAULT_UNROLL_M 2\n#define DGEMM_DEFAULT_UNROLL_N 2\n#define QGEMM_DEFAULT_UNROLL_M 2\n#define QGEMM_DEFAULT_UNROLL_N 2\n#define CGEMM_DEFAULT_UNROLL_M 4\n#define CGEMM_DEFAULT_UNROLL_N 1\n#define ZGEMM_DEFAULT_UNROLL_M 1\n#define ZGEMM_DEFAULT_UNROLL_N 1\n#define XGEMM_DEFAULT_UNROLL_M 1\n#define XGEMM_DEFAULT_UNROLL_N 1\n\n#endif\n\n#define SGEMM_DEFAULT_P sgemm_p\n#define SGEMM_DEFAULT_Q 256\n#define SGEMM_DEFAULT_R sgemm_r\n\n#define DGEMM_DEFAULT_P dgemm_p\n#define DGEMM_DEFAULT_Q 256\n#define DGEMM_DEFAULT_R dgemm_r\n\n#define QGEMM_DEFAULT_P qgemm_p\n#define QGEMM_DEFAULT_Q 256\n#define QGEMM_DEFAULT_R qgemm_r\n\n#define CGEMM_DEFAULT_P cgemm_p\n#define CGEMM_DEFAULT_Q 256\n#define CGEMM_DEFAULT_R cgemm_r\n\n#define ZGEMM_DEFAULT_P zgemm_p\n#define ZGEMM_DEFAULT_Q 256\n#define ZGEMM_DEFAULT_R zgemm_r\n\n#define XGEMM_DEFAULT_P xgemm_p\n#define XGEMM_DEFAULT_Q 256\n#define XGEMM_DEFAULT_R xgemm_r\n\n#define SYMV_P\t4\n#endif\n\n#ifdef CORE_NORTHWOOD\n\n#define SNUMOPT\t\t4\n#define DNUMOPT\t\t2\n\n#define GEMM_DEFAULT_OFFSET_A      0\n#define GEMM_DEFAULT_OFFSET_B     32\n\n#define GEMM_DEFAULT_ALIGN (BLASLONG)0x0ffffUL\n\n#define SYMV_P\t8\n\n#define SGEMM_DEFAULT_UNROLL_M 8\n#define DGEMM_DEFAULT_UNROLL_M 4\n#define QGEMM_DEFAULT_UNROLL_M 2\n#define CGEMM_DEFAULT_UNROLL_M 4\n#define ZGEMM_DEFAULT_UNROLL_M 2\n#define XGEMM_DEFAULT_UNROLL_M 1\n\n#define SGEMM_DEFAULT_UNROLL_N 2\n#define DGEMM_DEFAULT_UNROLL_N 2\n#define QGEMM_DEFAULT_UNROLL_N 2\n#define CGEMM_DEFAULT_UNROLL_N 1\n#define ZGEMM_DEFAULT_UNROLL_N 1\n#define XGEMM_DEFAULT_UNROLL_N 1\n\n#define SGEMM_DEFAULT_P sgemm_p\n#define SGEMM_DEFAULT_R sgemm_r\n\n#define DGEMM_DEFAULT_P dgemm_p\n#define DGEMM_DEFAULT_R dgemm_r\n\n#define QGEMM_DEFAULT_P qgemm_p\n#define QGEMM_DEFAULT_R qgemm_r\n\n#define CGEMM_DEFAULT_P cgemm_p\n#define CGEMM_DEFAULT_R cgemm_r\n\n#define ZGEMM_DEFAULT_P zgemm_p\n#define ZGEMM_DEFAULT_R zgemm_r\n\n#define XGEMM_DEFAULT_P xgemm_p\n#define XGEMM_DEFAULT_R xgemm_r\n\n#define SGEMM_DEFAULT_Q 128\n#define DGEMM_DEFAULT_Q 128\n#define QGEMM_DEFAULT_Q 128\n#define CGEMM_DEFAULT_Q 128\n#define ZGEMM_DEFAULT_Q 128\n#define XGEMM_DEFAULT_Q 128\n#endif\n\n#ifdef CORE_PRESCOTT\n\n#define SNUMOPT\t\t4\n#define DNUMOPT\t\t2\n\n#ifndef __64BIT__\n#define GEMM_DEFAULT_OFFSET_A    128\n#define GEMM_DEFAULT_OFFSET_B    192\n#else\n#define GEMM_DEFAULT_OFFSET_A      0\n#define GEMM_DEFAULT_OFFSET_B    256\n#endif\n\n#define GEMM_DEFAULT_ALIGN (BLASLONG)0x0ffffUL\n\n#define SYMV_P\t8\n\n#ifdef ARCH_X86\n#define SGEMM_DEFAULT_UNROLL_M 4\n#define DGEMM_DEFAULT_UNROLL_M 2\n#define QGEMM_DEFAULT_UNROLL_M 2\n#define CGEMM_DEFAULT_UNROLL_M 2\n#define ZGEMM_DEFAULT_UNROLL_M 1\n#define XGEMM_DEFAULT_UNROLL_M 1\n#else\n#define SGEMM_DEFAULT_UNROLL_M 8\n#define DGEMM_DEFAULT_UNROLL_M 4\n#define QGEMM_DEFAULT_UNROLL_M 2\n#define CGEMM_DEFAULT_UNROLL_M 4\n#define ZGEMM_DEFAULT_UNROLL_M 2\n#define XGEMM_DEFAULT_UNROLL_M 1\n#endif\n\n#define SGEMM_DEFAULT_UNROLL_N 4\n#define DGEMM_DEFAULT_UNROLL_N 4\n#define QGEMM_DEFAULT_UNROLL_N 2\n#define CGEMM_DEFAULT_UNROLL_N 2\n#define ZGEMM_DEFAULT_UNROLL_N 2\n#define XGEMM_DEFAULT_UNROLL_N 1\n\n#define SGEMM_DEFAULT_P sgemm_p\n#define SGEMM_DEFAULT_R sgemm_r\n\n#define DGEMM_DEFAULT_P dgemm_p\n#define DGEMM_DEFAULT_R dgemm_r\n\n#define QGEMM_DEFAULT_P qgemm_p\n#define QGEMM_DEFAULT_R qgemm_r\n\n#define CGEMM_DEFAULT_P cgemm_p\n#define CGEMM_DEFAULT_R cgemm_r\n\n#define ZGEMM_DEFAULT_P zgemm_p\n#define ZGEMM_DEFAULT_R zgemm_r\n\n#define XGEMM_DEFAULT_P xgemm_p\n#define XGEMM_DEFAULT_R xgemm_r\n\n#define SGEMM_DEFAULT_Q 128\n#define DGEMM_DEFAULT_Q 128\n#define QGEMM_DEFAULT_Q 128\n#define CGEMM_DEFAULT_Q 128\n#define ZGEMM_DEFAULT_Q 128\n#define XGEMM_DEFAULT_Q 128\n#endif\n\n#ifdef CORE2\n\n#define SNUMOPT\t\t8\n#define DNUMOPT\t\t4\n\n#define GEMM_DEFAULT_OFFSET_A    448\n#define GEMM_DEFAULT_OFFSET_B    128\n#define GEMM_DEFAULT_ALIGN (BLASLONG)0x03fffUL\n\n#define SYMV_P\t8\n\n#define SWITCH_RATIO\t4\n\n#ifdef ARCH_X86\n#define SGEMM_DEFAULT_UNROLL_M 8\n#define DGEMM_DEFAULT_UNROLL_M 4\n#define QGEMM_DEFAULT_UNROLL_M 2\n#define CGEMM_DEFAULT_UNROLL_M 4\n#define ZGEMM_DEFAULT_UNROLL_M 2\n#define XGEMM_DEFAULT_UNROLL_M 1\n\n#define SGEMM_DEFAULT_UNROLL_N 2\n#define DGEMM_DEFAULT_UNROLL_N 2\n#define QGEMM_DEFAULT_UNROLL_N 2\n#define CGEMM_DEFAULT_UNROLL_N 1\n#define ZGEMM_DEFAULT_UNROLL_N 1\n#define XGEMM_DEFAULT_UNROLL_N 1\n\n#define MASK(a, b) ((((a) + (b) - 1) / (b)) * (b))\n\n#else\n#define SGEMM_DEFAULT_UNROLL_M 8\n#define DGEMM_DEFAULT_UNROLL_M 4\n#define QGEMM_DEFAULT_UNROLL_M 2\n#define CGEMM_DEFAULT_UNROLL_M 4\n#define ZGEMM_DEFAULT_UNROLL_M 2\n#define XGEMM_DEFAULT_UNROLL_M 1\n\n#define SGEMM_DEFAULT_UNROLL_N 4\n#define DGEMM_DEFAULT_UNROLL_N 4\n#define QGEMM_DEFAULT_UNROLL_N 2\n#define CGEMM_DEFAULT_UNROLL_N 2\n#define ZGEMM_DEFAULT_UNROLL_N 2\n#define XGEMM_DEFAULT_UNROLL_N 1\n#endif\n\n#define SGEMM_DEFAULT_P sgemm_p\n#define SGEMM_DEFAULT_R sgemm_r\n\n#define DGEMM_DEFAULT_P dgemm_p\n#define DGEMM_DEFAULT_R dgemm_r\n\n#define QGEMM_DEFAULT_P qgemm_p\n#define QGEMM_DEFAULT_R qgemm_r\n\n#define CGEMM_DEFAULT_P cgemm_p\n#define CGEMM_DEFAULT_R cgemm_r\n\n#define ZGEMM_DEFAULT_P zgemm_p\n#define ZGEMM_DEFAULT_R zgemm_r\n\n#define XGEMM_DEFAULT_P xgemm_p\n#define XGEMM_DEFAULT_R xgemm_r\n\n#define SGEMM_DEFAULT_Q 256\n#define DGEMM_DEFAULT_Q 256\n#define QGEMM_DEFAULT_Q 256\n#define CGEMM_DEFAULT_Q 256\n#define ZGEMM_DEFAULT_Q 256\n#define XGEMM_DEFAULT_Q 256\n\n#endif\n\n#ifdef PENRYN\n\n#define SNUMOPT\t\t8\n#define DNUMOPT\t\t4\n\n#define GEMM_DEFAULT_OFFSET_A   128\n#define GEMM_DEFAULT_OFFSET_B     0\n#define GEMM_DEFAULT_ALIGN (BLASLONG)0x03fffUL\n\n#define SYMV_P\t8\n\n#define SWITCH_RATIO\t4\n\n#ifdef ARCH_X86\n#define SGEMM_DEFAULT_UNROLL_M 4\n#define DGEMM_DEFAULT_UNROLL_M 2\n#define QGEMM_DEFAULT_UNROLL_M 2\n#define CGEMM_DEFAULT_UNROLL_M 2\n#define ZGEMM_DEFAULT_UNROLL_M 1\n#define XGEMM_DEFAULT_UNROLL_M 1\n\n#define SGEMM_DEFAULT_UNROLL_N 4\n#define DGEMM_DEFAULT_UNROLL_N 4\n#define QGEMM_DEFAULT_UNROLL_N 2\n#define CGEMM_DEFAULT_UNROLL_N 2\n#define ZGEMM_DEFAULT_UNROLL_N 2\n#define XGEMM_DEFAULT_UNROLL_N 1\n#else\n#define SGEMM_DEFAULT_UNROLL_M 8\n#define DGEMM_DEFAULT_UNROLL_M 4\n#define QGEMM_DEFAULT_UNROLL_M 2\n#define CGEMM_DEFAULT_UNROLL_M 4\n#define ZGEMM_DEFAULT_UNROLL_M 2\n#define XGEMM_DEFAULT_UNROLL_M 1\n\n#define SGEMM_DEFAULT_UNROLL_N 4\n#define DGEMM_DEFAULT_UNROLL_N 4\n#define QGEMM_DEFAULT_UNROLL_N 2\n#define CGEMM_DEFAULT_UNROLL_N 2\n#define ZGEMM_DEFAULT_UNROLL_N 2\n#define XGEMM_DEFAULT_UNROLL_N 1\n#endif\n\n#define SGEMM_DEFAULT_P sgemm_p\n#define SGEMM_DEFAULT_R sgemm_r\n\n#define DGEMM_DEFAULT_P dgemm_p\n#define DGEMM_DEFAULT_R dgemm_r\n\n#define QGEMM_DEFAULT_P qgemm_p\n#define QGEMM_DEFAULT_R qgemm_r\n\n#define CGEMM_DEFAULT_P cgemm_p\n#define CGEMM_DEFAULT_R cgemm_r\n\n#define ZGEMM_DEFAULT_P zgemm_p\n#define ZGEMM_DEFAULT_R zgemm_r\n\n#define XGEMM_DEFAULT_P xgemm_p\n#define XGEMM_DEFAULT_R xgemm_r\n\n#define SGEMM_DEFAULT_Q 512\n#define DGEMM_DEFAULT_Q 256\n#define QGEMM_DEFAULT_Q 128\n#define CGEMM_DEFAULT_Q 512\n#define ZGEMM_DEFAULT_Q 256\n#define XGEMM_DEFAULT_Q 128\n\n#define GETRF_FACTOR 0.75\n#endif\n\n#ifdef DUNNINGTON\n\n#define SNUMOPT\t\t8\n#define DNUMOPT\t\t4\n\n#define GEMM_DEFAULT_OFFSET_A   128\n#define GEMM_DEFAULT_OFFSET_B     0\n#define GEMM_DEFAULT_ALIGN (BLASLONG)0x03fffUL\n\n#define SYMV_P\t8\n\n#define SWITCH_RATIO\t4\n\n#ifdef ARCH_X86\n#define SGEMM_DEFAULT_UNROLL_M 4\n#define DGEMM_DEFAULT_UNROLL_M 2\n#define QGEMM_DEFAULT_UNROLL_M 2\n#define CGEMM_DEFAULT_UNROLL_M 2\n#define ZGEMM_DEFAULT_UNROLL_M 1\n#define XGEMM_DEFAULT_UNROLL_M 1\n\n#define SGEMM_DEFAULT_UNROLL_N 4\n#define DGEMM_DEFAULT_UNROLL_N 4\n#define QGEMM_DEFAULT_UNROLL_N 2\n#define CGEMM_DEFAULT_UNROLL_N 2\n#define ZGEMM_DEFAULT_UNROLL_N 2\n#define XGEMM_DEFAULT_UNROLL_N 1\n#else\n#define SGEMM_DEFAULT_UNROLL_M 8\n#define DGEMM_DEFAULT_UNROLL_M 4\n#define QGEMM_DEFAULT_UNROLL_M 2\n#define CGEMM_DEFAULT_UNROLL_M 4\n#define ZGEMM_DEFAULT_UNROLL_M 2\n#define XGEMM_DEFAULT_UNROLL_M 1\n\n#define SGEMM_DEFAULT_UNROLL_N 4\n#define DGEMM_DEFAULT_UNROLL_N 4\n#define QGEMM_DEFAULT_UNROLL_N 2\n#define CGEMM_DEFAULT_UNROLL_N 2\n#define ZGEMM_DEFAULT_UNROLL_N 2\n#define XGEMM_DEFAULT_UNROLL_N 1\n#endif\n\n#define SGEMM_DEFAULT_P sgemm_p\n#define SGEMM_DEFAULT_R sgemm_r\n\n#define DGEMM_DEFAULT_P dgemm_p\n#define DGEMM_DEFAULT_R dgemm_r\n\n#define QGEMM_DEFAULT_P qgemm_p\n#define QGEMM_DEFAULT_R qgemm_r\n\n#define CGEMM_DEFAULT_P cgemm_p\n#define CGEMM_DEFAULT_R cgemm_r\n\n#define ZGEMM_DEFAULT_P zgemm_p\n#define ZGEMM_DEFAULT_R zgemm_r\n\n#define XGEMM_DEFAULT_P xgemm_p\n#define XGEMM_DEFAULT_R xgemm_r\n\n#define SGEMM_DEFAULT_Q 768\n#define DGEMM_DEFAULT_Q 384\n#define QGEMM_DEFAULT_Q 192\n#define CGEMM_DEFAULT_Q 768\n#define ZGEMM_DEFAULT_Q 384\n#define XGEMM_DEFAULT_Q 192\n\n#define GETRF_FACTOR 0.75\n#define GEMM_THREAD gemm_thread_mn\n#endif\n\n#ifdef NEHALEM\n\n#define SNUMOPT\t\t8\n#define DNUMOPT\t\t4\n\n#define GEMM_DEFAULT_OFFSET_A    32\n#define GEMM_DEFAULT_OFFSET_B     0\n#define GEMM_DEFAULT_ALIGN (BLASLONG)0x03fffUL\n\n#define SYMV_P\t8\n\n#define SWITCH_RATIO\t4\n\n#ifdef ARCH_X86\n#define SGEMM_DEFAULT_UNROLL_M 4\n#define DGEMM_DEFAULT_UNROLL_M 2\n#define QGEMM_DEFAULT_UNROLL_M 2\n#define CGEMM_DEFAULT_UNROLL_M 2\n#define ZGEMM_DEFAULT_UNROLL_M 1\n#define XGEMM_DEFAULT_UNROLL_M 1\n\n#define SGEMM_DEFAULT_UNROLL_N 4\n#define DGEMM_DEFAULT_UNROLL_N 4\n#define QGEMM_DEFAULT_UNROLL_N 2\n#define CGEMM_DEFAULT_UNROLL_N 2\n#define ZGEMM_DEFAULT_UNROLL_N 2\n#define XGEMM_DEFAULT_UNROLL_N 1\n#else\n#define SGEMM_DEFAULT_UNROLL_M 4\n#define DGEMM_DEFAULT_UNROLL_M 2\n#define QGEMM_DEFAULT_UNROLL_M 2\n#define CGEMM_DEFAULT_UNROLL_M 2\n#define ZGEMM_DEFAULT_UNROLL_M 1\n#define XGEMM_DEFAULT_UNROLL_M 1\n\n#define SGEMM_DEFAULT_UNROLL_N 8\n#define DGEMM_DEFAULT_UNROLL_N 8\n#define QGEMM_DEFAULT_UNROLL_N 2\n#define CGEMM_DEFAULT_UNROLL_N 4\n#define ZGEMM_DEFAULT_UNROLL_N 4\n#define XGEMM_DEFAULT_UNROLL_N 1\n#endif\n\n#define SGEMM_DEFAULT_P 504\n#define SGEMM_DEFAULT_R sgemm_r\n\n#define DGEMM_DEFAULT_P 504\n#define DGEMM_DEFAULT_R dgemm_r\n\n#define QGEMM_DEFAULT_P 504\n#define QGEMM_DEFAULT_R qgemm_r\n\n#define CGEMM_DEFAULT_P 252\n#define CGEMM_DEFAULT_R cgemm_r\n\n#define ZGEMM_DEFAULT_P 252\n#define ZGEMM_DEFAULT_R zgemm_r\n\n#define XGEMM_DEFAULT_P 252\n#define XGEMM_DEFAULT_R xgemm_r\n\n#define SGEMM_DEFAULT_Q 512\n#define DGEMM_DEFAULT_Q 256\n#define QGEMM_DEFAULT_Q 128\n#define CGEMM_DEFAULT_Q 512\n#define ZGEMM_DEFAULT_Q 256\n#define XGEMM_DEFAULT_Q 128\n\n#define GETRF_FACTOR 0.72\n\n#endif\n\n\n#ifdef SANDYBRIDGE\n\n#define SNUMOPT\t\t8\n#define DNUMOPT\t\t4\n\n#define GEMM_DEFAULT_OFFSET_A\t  0\n#define GEMM_DEFAULT_OFFSET_B     0\n#define GEMM_DEFAULT_ALIGN (BLASLONG)0x03fffUL\n\n#define SYMV_P\t8\n\n#define SWITCH_RATIO\t4\n\n#ifdef ARCH_X86\n#define SGEMM_DEFAULT_UNROLL_M 4\n#define DGEMM_DEFAULT_UNROLL_M 2\n#define QGEMM_DEFAULT_UNROLL_M 2\n#define CGEMM_DEFAULT_UNROLL_M 2\n#define ZGEMM_DEFAULT_UNROLL_M 1\n#define XGEMM_DEFAULT_UNROLL_M 1\n\n#define SGEMM_DEFAULT_UNROLL_N 4\n#define DGEMM_DEFAULT_UNROLL_N 4\n#define QGEMM_DEFAULT_UNROLL_N 2\n#define CGEMM_DEFAULT_UNROLL_N 2\n#define ZGEMM_DEFAULT_UNROLL_N 2\n#define XGEMM_DEFAULT_UNROLL_N 1\n#else\n#define SGEMM_DEFAULT_UNROLL_M 16\n#define DGEMM_DEFAULT_UNROLL_M 8\n#define QGEMM_DEFAULT_UNROLL_M 2\n#define CGEMM_DEFAULT_UNROLL_M 8\n#define ZGEMM_DEFAULT_UNROLL_M 1\n#define XGEMM_DEFAULT_UNROLL_M 1\n\n#define SGEMM_DEFAULT_UNROLL_N 4\n#define DGEMM_DEFAULT_UNROLL_N 4\n#define QGEMM_DEFAULT_UNROLL_N 2\n#define CGEMM_DEFAULT_UNROLL_N 2\n#define ZGEMM_DEFAULT_UNROLL_N 4\n#define XGEMM_DEFAULT_UNROLL_N 1\n#endif\n\n#define SGEMM_DEFAULT_P 768\n#define SGEMM_DEFAULT_R sgemm_r\n/*#define SGEMM_DEFAULT_R 1024*/\n\n#define DGEMM_DEFAULT_P 512\n#define DGEMM_DEFAULT_R dgemm_r\n/*#define DGEMM_DEFAULT_R 1024*/\n\n#define QGEMM_DEFAULT_P 504\n#define QGEMM_DEFAULT_R qgemm_r\n\n#define CGEMM_DEFAULT_P 768\n#define CGEMM_DEFAULT_R cgemm_r\n/*#define CGEMM_DEFAULT_R 1024*/\n\n#define ZGEMM_DEFAULT_P 512\n#define ZGEMM_DEFAULT_R zgemm_r\n/*#define ZGEMM_DEFAULT_R 1024*/\n\n#define XGEMM_DEFAULT_P 252\n#define XGEMM_DEFAULT_R xgemm_r\n\n#define SGEMM_DEFAULT_Q 384\n#define DGEMM_DEFAULT_Q 256\n#define QGEMM_DEFAULT_Q 128\n#define CGEMM_DEFAULT_Q 512\n#define ZGEMM_DEFAULT_Q 192\n#define XGEMM_DEFAULT_Q 128\n\n#define CGEMM3M_DEFAULT_UNROLL_N 8\n#define CGEMM3M_DEFAULT_UNROLL_M 4\n#define ZGEMM3M_DEFAULT_UNROLL_N 8\n#define ZGEMM3M_DEFAULT_UNROLL_M 2\n\n#define CGEMM3M_DEFAULT_P 448\n#define ZGEMM3M_DEFAULT_P 224\n#define XGEMM3M_DEFAULT_P 112\n#define CGEMM3M_DEFAULT_Q 224\n#define ZGEMM3M_DEFAULT_Q 224\n#define XGEMM3M_DEFAULT_Q 224\n#define CGEMM3M_DEFAULT_R 12288\n#define ZGEMM3M_DEFAULT_R 12288\n#define XGEMM3M_DEFAULT_R 12288\n\n\n\n#define GETRF_FACTOR 0.72\n\n#endif\n\n#ifdef HASWELL\n\n#define SNUMOPT         16\n#define DNUMOPT         8\n\n#define GEMM_DEFAULT_OFFSET_A     0\n#define GEMM_DEFAULT_OFFSET_B     0\n#define GEMM_DEFAULT_ALIGN (BLASLONG)0x03fffUL\n\n#define SYMV_P  8\n\n#if defined(XDOUBLE) || defined(DOUBLE)\n#define SWITCH_RATIO            4\n#define GEMM_PREFERED_SIZE      4\n#else\n#define SWITCH_RATIO            8\n#define GEMM_PREFERED_SIZE      8\n#endif\n\n#ifdef ARCH_X86\n\n#define SGEMM_DEFAULT_UNROLL_M 4\n#define DGEMM_DEFAULT_UNROLL_M 2\n#define QGEMM_DEFAULT_UNROLL_M 2\n#define CGEMM_DEFAULT_UNROLL_M 2\n#define ZGEMM_DEFAULT_UNROLL_M 1\n#define XGEMM_DEFAULT_UNROLL_M 1\n\n#define SGEMM_DEFAULT_UNROLL_N 4\n#define DGEMM_DEFAULT_UNROLL_N 4\n#define QGEMM_DEFAULT_UNROLL_N 2\n#define CGEMM_DEFAULT_UNROLL_N 2\n#define ZGEMM_DEFAULT_UNROLL_N 2\n#define XGEMM_DEFAULT_UNROLL_N 1\n\n#else\n\n#define SGEMM_DEFAULT_UNROLL_M 8\n#define DGEMM_DEFAULT_UNROLL_M 4\n#define QGEMM_DEFAULT_UNROLL_M 2\n#define CGEMM_DEFAULT_UNROLL_M 8\n#define ZGEMM_DEFAULT_UNROLL_M 4\n#define XGEMM_DEFAULT_UNROLL_M 1\n\n#define SGEMM_DEFAULT_UNROLL_N 4\n#define DGEMM_DEFAULT_UNROLL_N 8\n#define QGEMM_DEFAULT_UNROLL_N 2\n#define CGEMM_DEFAULT_UNROLL_N 2\n#define ZGEMM_DEFAULT_UNROLL_N 2\n#define XGEMM_DEFAULT_UNROLL_N 1\n/*\n#define SGEMM_DEFAULT_UNROLL_MN 32\n#define DGEMM_DEFAULT_UNROLL_MN 32\n*/\n#endif\n\n#ifdef ARCH_X86\n\n#define SGEMM_DEFAULT_P 512\n#define SGEMM_DEFAULT_R sgemm_r\n#define DGEMM_DEFAULT_P 512\n#define DGEMM_DEFAULT_R dgemm_r\n#define QGEMM_DEFAULT_P 504\n#define QGEMM_DEFAULT_R qgemm_r\n#define CGEMM_DEFAULT_P 128\n#define CGEMM_DEFAULT_R 1024\n#define ZGEMM_DEFAULT_P 512\n#define ZGEMM_DEFAULT_R zgemm_r\n#define XGEMM_DEFAULT_P 252\n#define XGEMM_DEFAULT_R xgemm_r\n#define SGEMM_DEFAULT_Q 256\n#define DGEMM_DEFAULT_Q 256\n#define QGEMM_DEFAULT_Q 128\n#define CGEMM_DEFAULT_Q 256\n#define ZGEMM_DEFAULT_Q 192\n#define XGEMM_DEFAULT_Q 128\n\n#else\n\n#define SGEMM_DEFAULT_P 320\n#define DGEMM_DEFAULT_P 512\n#define CGEMM_DEFAULT_P 256\n#define ZGEMM_DEFAULT_P 192\n\n#ifdef WINDOWS_ABI\n#define SGEMM_DEFAULT_Q 320\n#define DGEMM_DEFAULT_Q 128\n#else\n#define SGEMM_DEFAULT_Q 320\n#define DGEMM_DEFAULT_Q 256\n#endif\n#define CGEMM_DEFAULT_Q 256\n#define ZGEMM_DEFAULT_Q 192\n\n#define SGEMM_DEFAULT_R sgemm_r\n#define DGEMM_DEFAULT_R 13824\n#define CGEMM_DEFAULT_R cgemm_r\n#define ZGEMM_DEFAULT_R zgemm_r\n\n#define QGEMM_DEFAULT_Q 128\n#define QGEMM_DEFAULT_P 504\n#define QGEMM_DEFAULT_R qgemm_r\n#define XGEMM_DEFAULT_P 252\n#define XGEMM_DEFAULT_R xgemm_r\n#define XGEMM_DEFAULT_Q 128\n\n#define CGEMM3M_DEFAULT_UNROLL_N 4\n#define CGEMM3M_DEFAULT_UNROLL_M 8\n#define ZGEMM3M_DEFAULT_UNROLL_N 4\n#define ZGEMM3M_DEFAULT_UNROLL_M 4\n\n#define CGEMM3M_DEFAULT_P 320\n#define ZGEMM3M_DEFAULT_P 256\n#define XGEMM3M_DEFAULT_P 112\n#define CGEMM3M_DEFAULT_Q 320\n#define ZGEMM3M_DEFAULT_Q 256\n#define XGEMM3M_DEFAULT_Q 224\n#define CGEMM3M_DEFAULT_R 12288\n#define ZGEMM3M_DEFAULT_R 12288\n#define XGEMM3M_DEFAULT_R 12288\n\n#endif\n\n\n#endif\n\n#ifdef SKYLAKEX\n\n#define SNUMOPT         16\n#define DNUMOPT         8\n\n#define GEMM_DEFAULT_OFFSET_A     0\n#define GEMM_DEFAULT_OFFSET_B     0\n#define GEMM_DEFAULT_ALIGN (BLASLONG)0x03fffUL\n\n#define SYMV_P  8\n\n#if defined(XDOUBLE) || defined(DOUBLE)\n#define SWITCH_RATIO           8\n#define GEMM_PREFERED_SIZE     8\n#else\n#define SWITCH_RATIO           16\n#define GEMM_PREFERED_SIZE     16\n#endif\n#define USE_SGEMM_KERNEL_DIRECT 1\n\n#ifdef ARCH_X86\n\n#define SGEMM_DEFAULT_UNROLL_M 4\n#define DGEMM_DEFAULT_UNROLL_M 2\n#define QGEMM_DEFAULT_UNROLL_M 2\n#define CGEMM_DEFAULT_UNROLL_M 2\n#define ZGEMM_DEFAULT_UNROLL_M 1\n#define XGEMM_DEFAULT_UNROLL_M 1\n\n#define SGEMM_DEFAULT_UNROLL_N 4\n#define DGEMM_DEFAULT_UNROLL_N 4\n#define QGEMM_DEFAULT_UNROLL_N 2\n#define CGEMM_DEFAULT_UNROLL_N 2\n#define ZGEMM_DEFAULT_UNROLL_N 2\n#define XGEMM_DEFAULT_UNROLL_N 1\n\n#else\n\n#define SGEMM_DEFAULT_UNROLL_M 16\n#define DGEMM_DEFAULT_UNROLL_M 16\n#define QGEMM_DEFAULT_UNROLL_M 2\n#define CGEMM_DEFAULT_UNROLL_M 8\n#define ZGEMM_DEFAULT_UNROLL_M 4\n#define XGEMM_DEFAULT_UNROLL_M 1\n\n#define SGEMM_DEFAULT_UNROLL_N 4\n#define DGEMM_DEFAULT_UNROLL_N 2\n#define QGEMM_DEFAULT_UNROLL_N 2\n#define CGEMM_DEFAULT_UNROLL_N 2\n#define ZGEMM_DEFAULT_UNROLL_N 2\n#define XGEMM_DEFAULT_UNROLL_N 1\n\n#define SGEMM_DEFAULT_UNROLL_MN 32\n#define DGEMM_DEFAULT_UNROLL_MN 32\n#endif\n\n#ifdef ARCH_X86\n\n#define SGEMM_DEFAULT_P 512\n#define SGEMM_DEFAULT_R sgemm_r\n#define DGEMM_DEFAULT_P 512\n#define DGEMM_DEFAULT_R dgemm_r\n#define QGEMM_DEFAULT_P 504\n#define QGEMM_DEFAULT_R qgemm_r\n#define CGEMM_DEFAULT_P 128\n#define CGEMM_DEFAULT_R 1024\n#define ZGEMM_DEFAULT_P 512\n#define ZGEMM_DEFAULT_R zgemm_r\n#define XGEMM_DEFAULT_P 252\n#define XGEMM_DEFAULT_R xgemm_r\n#define SGEMM_DEFAULT_Q 256\n#define DGEMM_DEFAULT_Q 256\n#define QGEMM_DEFAULT_Q 128\n#define CGEMM_DEFAULT_Q 256\n#define ZGEMM_DEFAULT_Q 192\n#define XGEMM_DEFAULT_Q 128\n\n#else\n\n#define SGEMM_DEFAULT_P 448\n#define DGEMM_DEFAULT_P 192\n#define CGEMM_DEFAULT_P 384\n#define ZGEMM_DEFAULT_P 256\n\n#define SGEMM_DEFAULT_Q 448\n#define DGEMM_DEFAULT_Q 384\n#define CGEMM_DEFAULT_Q 192\n#define ZGEMM_DEFAULT_Q 128\n\n#define SGEMM_DEFAULT_R sgemm_r\n#define DGEMM_DEFAULT_R 8640\n#define CGEMM_DEFAULT_R cgemm_r\n#define ZGEMM_DEFAULT_R zgemm_r\n\n#define QGEMM_DEFAULT_Q 128\n#define QGEMM_DEFAULT_P 504\n#define QGEMM_DEFAULT_R qgemm_r\n#define XGEMM_DEFAULT_P 252\n#define XGEMM_DEFAULT_R xgemm_r\n#define XGEMM_DEFAULT_Q 128\n\n#define CGEMM3M_DEFAULT_UNROLL_N 4\n#define CGEMM3M_DEFAULT_UNROLL_M 8\n#define ZGEMM3M_DEFAULT_UNROLL_N 4\n#define ZGEMM3M_DEFAULT_UNROLL_M 4\n\n#define CGEMM3M_DEFAULT_P 320\n#define ZGEMM3M_DEFAULT_P 256\n#define XGEMM3M_DEFAULT_P 112\n#define CGEMM3M_DEFAULT_Q 320\n#define ZGEMM3M_DEFAULT_Q 256\n#define XGEMM3M_DEFAULT_Q 224\n#define CGEMM3M_DEFAULT_R 12288\n#define ZGEMM3M_DEFAULT_R 12288\n#define XGEMM3M_DEFAULT_R 12288\n\n#endif\n\n\n#endif\n\n#ifdef SAPPHIRERAPIDS\n\n#define SNUMOPT         16\n#define DNUMOPT         8\n\n#define GEMM_DEFAULT_OFFSET_A     0\n#define GEMM_DEFAULT_OFFSET_B     0\n#define GEMM_DEFAULT_ALIGN 0x03fffUL\n\n#define SYMV_P  8\n\n#if defined(XDOUBLE) || defined(DOUBLE)\n#define SWITCH_RATIO           8\n#define GEMM_PREFERED_SIZE     8\n#else\n#define SWITCH_RATIO           16\n#define GEMM_PREFERED_SIZE     16\n#endif\n#define USE_SGEMM_KERNEL_DIRECT 1\n\n#undef SBGEMM_DEFAULT_UNROLL_N\n#undef SBGEMM_DEFAULT_UNROLL_M\n#undef SBGEMM_DEFAULT_P\n#undef SBGEMM_DEFAULT_R\n#undef SBGEMM_DEFAULT_Q\n// FIXME: actually UNROLL_M = UNROLL_N = 16\n// If M and N is equal, OpenBLAS will reuse OCOPY as ICOPY.\n// But for AMX, they are not the same, set UNROLL_M = 32 to workaround\n#define SBGEMM_DEFAULT_UNROLL_N 16\n#define SBGEMM_DEFAULT_UNROLL_M 32\n#define SBGEMM_DEFAULT_P 256\n#define SBGEMM_DEFAULT_Q 1024\n#define SBGEMM_DEFAULT_R sbgemm_r\n\n#ifdef ARCH_X86\n\n#define SGEMM_DEFAULT_UNROLL_M 4\n#define DGEMM_DEFAULT_UNROLL_M 2\n#define QGEMM_DEFAULT_UNROLL_M 2\n#define CGEMM_DEFAULT_UNROLL_M 2\n#define ZGEMM_DEFAULT_UNROLL_M 1\n#define XGEMM_DEFAULT_UNROLL_M 1\n\n#define SGEMM_DEFAULT_UNROLL_N 4\n#define DGEMM_DEFAULT_UNROLL_N 4\n#define QGEMM_DEFAULT_UNROLL_N 2\n#define CGEMM_DEFAULT_UNROLL_N 2\n#define ZGEMM_DEFAULT_UNROLL_N 2\n#define XGEMM_DEFAULT_UNROLL_N 1\n\n#else\n\n#define SGEMM_DEFAULT_UNROLL_M 16\n#define DGEMM_DEFAULT_UNROLL_M 16\n#define QGEMM_DEFAULT_UNROLL_M 2\n#define CGEMM_DEFAULT_UNROLL_M 8\n#define ZGEMM_DEFAULT_UNROLL_M 4\n#define XGEMM_DEFAULT_UNROLL_M 1\n\n#define SGEMM_DEFAULT_UNROLL_N 4\n#define DGEMM_DEFAULT_UNROLL_N 2\n#define QGEMM_DEFAULT_UNROLL_N 2\n#define CGEMM_DEFAULT_UNROLL_N 2\n#define ZGEMM_DEFAULT_UNROLL_N 2\n#define XGEMM_DEFAULT_UNROLL_N 1\n\n#define SGEMM_DEFAULT_UNROLL_MN 32\n#define DGEMM_DEFAULT_UNROLL_MN 32\n#endif\n\n#ifdef ARCH_X86\n\n#define SGEMM_DEFAULT_P 512\n#define SGEMM_DEFAULT_R sgemm_r\n#define DGEMM_DEFAULT_P 512\n#define DGEMM_DEFAULT_R dgemm_r\n#define QGEMM_DEFAULT_P 504\n#define QGEMM_DEFAULT_R qgemm_r\n#define CGEMM_DEFAULT_P 128\n#define CGEMM_DEFAULT_R 1024\n#define ZGEMM_DEFAULT_P 512\n#define ZGEMM_DEFAULT_R zgemm_r\n#define XGEMM_DEFAULT_P 252\n#define XGEMM_DEFAULT_R xgemm_r\n#define SGEMM_DEFAULT_Q 256\n#define DGEMM_DEFAULT_Q 256\n#define QGEMM_DEFAULT_Q 128\n#define CGEMM_DEFAULT_Q 256\n#define ZGEMM_DEFAULT_Q 192\n#define XGEMM_DEFAULT_Q 128\n\n#else\n\n#define SGEMM_DEFAULT_P 640\n#define DGEMM_DEFAULT_P 192\n#define CGEMM_DEFAULT_P 384\n#define ZGEMM_DEFAULT_P 256\n\n#define SGEMM_DEFAULT_Q 320\n#define DGEMM_DEFAULT_Q 384\n#define CGEMM_DEFAULT_Q 192\n#define ZGEMM_DEFAULT_Q 128\n\n#define SGEMM_DEFAULT_R sgemm_r\n#define DGEMM_DEFAULT_R 8640\n#define CGEMM_DEFAULT_R cgemm_r\n#define ZGEMM_DEFAULT_R zgemm_r\n\n#define QGEMM_DEFAULT_Q 128\n#define QGEMM_DEFAULT_P 504\n#define QGEMM_DEFAULT_R qgemm_r\n#define XGEMM_DEFAULT_P 252\n#define XGEMM_DEFAULT_R xgemm_r\n#define XGEMM_DEFAULT_Q 128\n\n#define CGEMM3M_DEFAULT_UNROLL_N 4\n#define CGEMM3M_DEFAULT_UNROLL_M 8\n#define ZGEMM3M_DEFAULT_UNROLL_N 4\n#define ZGEMM3M_DEFAULT_UNROLL_M 4\n\n#define CGEMM3M_DEFAULT_P 320\n#define ZGEMM3M_DEFAULT_P 256\n#define XGEMM3M_DEFAULT_P 112\n#define CGEMM3M_DEFAULT_Q 320\n#define ZGEMM3M_DEFAULT_Q 256\n#define XGEMM3M_DEFAULT_Q 224\n#define CGEMM3M_DEFAULT_R 12288\n#define ZGEMM3M_DEFAULT_R 12288\n#define XGEMM3M_DEFAULT_R 12288\n\n#endif\n#endif\n\n#ifdef COOPERLAKE\n\n#define SNUMOPT         16\n#define DNUMOPT         8\n\n#define GEMM_DEFAULT_OFFSET_A     0\n#define GEMM_DEFAULT_OFFSET_B     0\n#define GEMM_DEFAULT_ALIGN 0x03fffUL\n\n#define SYMV_P  8\n\n#if defined(XDOUBLE) || defined(DOUBLE)\n#define SWITCH_RATIO           8\n#define GEMM_PREFERED_SIZE     8\n#else\n#define SWITCH_RATIO           16\n#define GEMM_PREFERED_SIZE     16\n#endif\n#define USE_SGEMM_KERNEL_DIRECT 1\n\n#undef SBGEMM_DEFAULT_UNROLL_N\n#undef SBGEMM_DEFAULT_UNROLL_M\n#undef SBGEMM_DEFAULT_P\n#undef SBGEMM_DEFAULT_R\n#undef SBGEMM_DEFAULT_Q\n#define SBGEMM_DEFAULT_UNROLL_N 4\n#define SBGEMM_DEFAULT_UNROLL_M 16\n#define SBGEMM_DEFAULT_P 384\n#define SBGEMM_DEFAULT_Q 768\n#define SBGEMM_DEFAULT_R sbgemm_r\n\n#ifdef ARCH_X86\n\n#define SGEMM_DEFAULT_UNROLL_M 4\n#define DGEMM_DEFAULT_UNROLL_M 2\n#define QGEMM_DEFAULT_UNROLL_M 2\n#define CGEMM_DEFAULT_UNROLL_M 2\n#define ZGEMM_DEFAULT_UNROLL_M 1\n#define XGEMM_DEFAULT_UNROLL_M 1\n\n#define SGEMM_DEFAULT_UNROLL_N 4\n#define DGEMM_DEFAULT_UNROLL_N 4\n#define QGEMM_DEFAULT_UNROLL_N 2\n#define CGEMM_DEFAULT_UNROLL_N 2\n#define ZGEMM_DEFAULT_UNROLL_N 2\n#define XGEMM_DEFAULT_UNROLL_N 1\n\n#else\n\n#define SGEMM_DEFAULT_UNROLL_M 16\n#define DGEMM_DEFAULT_UNROLL_M 16\n#define QGEMM_DEFAULT_UNROLL_M 2\n#define CGEMM_DEFAULT_UNROLL_M 8\n#define ZGEMM_DEFAULT_UNROLL_M 4\n#define XGEMM_DEFAULT_UNROLL_M 1\n\n#define SGEMM_DEFAULT_UNROLL_N 4\n#define DGEMM_DEFAULT_UNROLL_N 2\n#define QGEMM_DEFAULT_UNROLL_N 2\n#define CGEMM_DEFAULT_UNROLL_N 2\n#define ZGEMM_DEFAULT_UNROLL_N 2\n#define XGEMM_DEFAULT_UNROLL_N 1\n\n#define SGEMM_DEFAULT_UNROLL_MN 32\n#define DGEMM_DEFAULT_UNROLL_MN 32\n#endif\n\n#ifdef ARCH_X86\n\n#define SGEMM_DEFAULT_P 512\n#define SGEMM_DEFAULT_R sgemm_r\n#define DGEMM_DEFAULT_P 512\n#define DGEMM_DEFAULT_R dgemm_r\n#define QGEMM_DEFAULT_P 504\n#define QGEMM_DEFAULT_R qgemm_r\n#define CGEMM_DEFAULT_P 128\n#define CGEMM_DEFAULT_R 1024\n#define ZGEMM_DEFAULT_P 512\n#define ZGEMM_DEFAULT_R zgemm_r\n#define XGEMM_DEFAULT_P 252\n#define XGEMM_DEFAULT_R xgemm_r\n#define SGEMM_DEFAULT_Q 256\n#define DGEMM_DEFAULT_Q 256\n#define QGEMM_DEFAULT_Q 128\n#define CGEMM_DEFAULT_Q 256\n#define ZGEMM_DEFAULT_Q 192\n#define XGEMM_DEFAULT_Q 128\n\n#else\n\n#define SGEMM_DEFAULT_P 640\n#define DGEMM_DEFAULT_P 192\n#define CGEMM_DEFAULT_P 384\n#define ZGEMM_DEFAULT_P 256\n\n#define SGEMM_DEFAULT_Q 320\n#define DGEMM_DEFAULT_Q 384\n#define CGEMM_DEFAULT_Q 192\n#define ZGEMM_DEFAULT_Q 128\n\n#define SGEMM_DEFAULT_R sgemm_r\n#define DGEMM_DEFAULT_R 8640\n#define CGEMM_DEFAULT_R cgemm_r\n#define ZGEMM_DEFAULT_R zgemm_r\n\n#define QGEMM_DEFAULT_Q 128\n#define QGEMM_DEFAULT_P 504\n#define QGEMM_DEFAULT_R qgemm_r\n#define XGEMM_DEFAULT_P 252\n#define XGEMM_DEFAULT_R xgemm_r\n#define XGEMM_DEFAULT_Q 128\n\n#define CGEMM3M_DEFAULT_UNROLL_N 4\n#define CGEMM3M_DEFAULT_UNROLL_M 8\n#define ZGEMM3M_DEFAULT_UNROLL_N 4\n#define ZGEMM3M_DEFAULT_UNROLL_M 4\n\n#define CGEMM3M_DEFAULT_P 320\n#define ZGEMM3M_DEFAULT_P 256\n#define XGEMM3M_DEFAULT_P 112\n#define CGEMM3M_DEFAULT_Q 320\n#define ZGEMM3M_DEFAULT_Q 256\n#define XGEMM3M_DEFAULT_Q 224\n#define CGEMM3M_DEFAULT_R 12288\n#define ZGEMM3M_DEFAULT_R 12288\n#define XGEMM3M_DEFAULT_R 12288\n\n#endif\n#endif\n\n\n#ifdef ATOM\n\n#define SNUMOPT\t\t2\n#define DNUMOPT\t\t1\n\n#define GEMM_DEFAULT_OFFSET_A     64\n#define GEMM_DEFAULT_OFFSET_B      0\n#define GEMM_DEFAULT_ALIGN (BLASLONG)0x0ffffUL\n\n#define SYMV_P\t8\n\n#ifdef ARCH_X86\n#define SGEMM_DEFAULT_UNROLL_M 4\n#define DGEMM_DEFAULT_UNROLL_M 2\n#define QGEMM_DEFAULT_UNROLL_M 2\n#define CGEMM_DEFAULT_UNROLL_M 2\n#define ZGEMM_DEFAULT_UNROLL_M 1\n#define XGEMM_DEFAULT_UNROLL_M 1\n#else\n#define SGEMM_DEFAULT_UNROLL_M 8\n#define DGEMM_DEFAULT_UNROLL_M 4\n#define QGEMM_DEFAULT_UNROLL_M 2\n#define CGEMM_DEFAULT_UNROLL_M 4\n#define ZGEMM_DEFAULT_UNROLL_M 2\n#define XGEMM_DEFAULT_UNROLL_M 1\n#endif\n\n#define SGEMM_DEFAULT_UNROLL_N 4\n#define DGEMM_DEFAULT_UNROLL_N 2\n#define QGEMM_DEFAULT_UNROLL_N 2\n#define CGEMM_DEFAULT_UNROLL_N 2\n#define ZGEMM_DEFAULT_UNROLL_N 1\n#define XGEMM_DEFAULT_UNROLL_N 1\n\n#define SGEMM_DEFAULT_P sgemm_p\n#define SGEMM_DEFAULT_R sgemm_r\n\n#define DGEMM_DEFAULT_P dgemm_p\n#define DGEMM_DEFAULT_R dgemm_r\n\n#define QGEMM_DEFAULT_P qgemm_p\n#define QGEMM_DEFAULT_R qgemm_r\n\n#define CGEMM_DEFAULT_P cgemm_p\n#define CGEMM_DEFAULT_R cgemm_r\n\n#define ZGEMM_DEFAULT_P zgemm_p\n#define ZGEMM_DEFAULT_R zgemm_r\n\n#define XGEMM_DEFAULT_P xgemm_p\n#define XGEMM_DEFAULT_R xgemm_r\n\n#define SGEMM_DEFAULT_Q 256\n#define DGEMM_DEFAULT_Q 256\n#define QGEMM_DEFAULT_Q 256\n#define CGEMM_DEFAULT_Q 256\n#define ZGEMM_DEFAULT_Q 256\n#define XGEMM_DEFAULT_Q 256\n\n#endif\n\n\n#ifdef ITANIUM2\n\n#define SNUMOPT\t\t4\n#define DNUMOPT\t\t4\n\n#define GEMM_DEFAULT_OFFSET_A 0\n#define GEMM_DEFAULT_OFFSET_B 128\n#define GEMM_DEFAULT_ALIGN (BLASLONG)0x03fffUL\n\n#define SGEMM_DEFAULT_UNROLL_M 8\n#define SGEMM_DEFAULT_UNROLL_N 8\n#define DGEMM_DEFAULT_UNROLL_M 8\n#define DGEMM_DEFAULT_UNROLL_N 8\n#define QGEMM_DEFAULT_UNROLL_M 8\n#define QGEMM_DEFAULT_UNROLL_N 8\n#define CGEMM_DEFAULT_UNROLL_M 4\n#define CGEMM_DEFAULT_UNROLL_N 4\n#define ZGEMM_DEFAULT_UNROLL_M 4\n#define ZGEMM_DEFAULT_UNROLL_N 4\n#define XGEMM_DEFAULT_UNROLL_M 4\n#define XGEMM_DEFAULT_UNROLL_N 4\n\n#define SGEMM_DEFAULT_P sgemm_p\n#define DGEMM_DEFAULT_P dgemm_p\n#define QGEMM_DEFAULT_P qgemm_p\n#define CGEMM_DEFAULT_P cgemm_p\n#define ZGEMM_DEFAULT_P zgemm_p\n#define XGEMM_DEFAULT_P xgemm_p\n\n#define SGEMM_DEFAULT_Q 1024\n#define DGEMM_DEFAULT_Q 1024\n#define QGEMM_DEFAULT_Q 1024\n#define CGEMM_DEFAULT_Q 1024\n#define ZGEMM_DEFAULT_Q 1024\n#define XGEMM_DEFAULT_Q 1024\n\n#define SGEMM_DEFAULT_R sgemm_r\n#define DGEMM_DEFAULT_R dgemm_r\n#define QGEMM_DEFAULT_R qgemm_r\n#define CGEMM_DEFAULT_R cgemm_r\n#define ZGEMM_DEFAULT_R zgemm_r\n#define XGEMM_DEFAULT_R xgemm_r\n\n#define SYMV_P\t 16\n\n#define GETRF_FACTOR 0.65\n\n#endif\n\n#if defined(EV4) || defined(EV5) || defined(EV6)\n\n#ifdef EV4\n#define SNUMOPT\t\t1\n#define DNUMOPT\t\t1\n#else\n#define SNUMOPT\t\t2\n#define DNUMOPT\t\t2\n#endif\n\n#define GEMM_DEFAULT_OFFSET_A 512\n#define GEMM_DEFAULT_OFFSET_B 512\n#define GEMM_DEFAULT_ALIGN (BLASLONG)0x0ffffUL\n\n#define SGEMM_DEFAULT_UNROLL_M 4\n#define SGEMM_DEFAULT_UNROLL_N 4\n#define DGEMM_DEFAULT_UNROLL_M 4\n#define DGEMM_DEFAULT_UNROLL_N 4\n#define CGEMM_DEFAULT_UNROLL_M 2\n#define CGEMM_DEFAULT_UNROLL_N 2\n#define ZGEMM_DEFAULT_UNROLL_M 2\n#define ZGEMM_DEFAULT_UNROLL_N 2\n\n#define SYMV_P\t 8\n\n#ifdef EV4\n#define SGEMM_DEFAULT_P\t 32\n#define SGEMM_DEFAULT_Q\t112\n#define SGEMM_DEFAULT_R\t256\n\n#define DGEMM_DEFAULT_P\t 32\n#define DGEMM_DEFAULT_Q\t 56\n#define DGEMM_DEFAULT_R\t256\n\n#define CGEMM_DEFAULT_P\t 32\n#define CGEMM_DEFAULT_Q\t 64\n#define CGEMM_DEFAULT_R\t240\n\n#define ZGEMM_DEFAULT_P\t 32\n#define ZGEMM_DEFAULT_Q\t 32\n#define ZGEMM_DEFAULT_R\t240\n#endif\n\n#ifdef EV5\n#define SGEMM_DEFAULT_P\t 64\n#define SGEMM_DEFAULT_Q\t256\n\n#define DGEMM_DEFAULT_P\t 64\n#define DGEMM_DEFAULT_Q\t128\n\n#define CGEMM_DEFAULT_P\t 64\n#define CGEMM_DEFAULT_Q\t128\n\n#define ZGEMM_DEFAULT_P\t 64\n#define ZGEMM_DEFAULT_Q\t 64\n#endif\n\n#ifdef EV6\n#define SGEMM_DEFAULT_P\t256\n#define SGEMM_DEFAULT_Q\t512\n\n#define DGEMM_DEFAULT_P\t256\n#define DGEMM_DEFAULT_Q\t256\n\n#define CGEMM_DEFAULT_P\t256\n#define CGEMM_DEFAULT_Q\t256\n\n#define ZGEMM_DEFAULT_P\t128\n#define ZGEMM_DEFAULT_Q\t256\n#endif\n\n#endif\n\n#ifdef CELL\n\n#define SNUMOPT\t\t2\n#define DNUMOPT\t\t2\n\n#define GEMM_DEFAULT_OFFSET_A 0\n#define GEMM_DEFAULT_OFFSET_B 8192\n#define GEMM_DEFAULT_ALIGN (BLASLONG)0x0ffffUL\n\n#define SGEMM_DEFAULT_UNROLL_M 16\n#define SGEMM_DEFAULT_UNROLL_N 4\n#define DGEMM_DEFAULT_UNROLL_M 4\n#define DGEMM_DEFAULT_UNROLL_N 4\n#define CGEMM_DEFAULT_UNROLL_M 8\n#define CGEMM_DEFAULT_UNROLL_N 2\n#define ZGEMM_DEFAULT_UNROLL_M 2\n#define ZGEMM_DEFAULT_UNROLL_N 2\n\n#define SGEMM_DEFAULT_P 128\n#define DGEMM_DEFAULT_P 128\n#define CGEMM_DEFAULT_P 128\n#define ZGEMM_DEFAULT_P 128\n\n#define SGEMM_DEFAULT_Q  512\n#define DGEMM_DEFAULT_Q  256\n#define CGEMM_DEFAULT_Q  256\n#define ZGEMM_DEFAULT_Q  128\n\n#define SYMV_P\t 4\n#endif\n\n#ifdef PPCG4\n#define GEMM_DEFAULT_OFFSET_A    0\n#define GEMM_DEFAULT_OFFSET_B 1024\n#define GEMM_DEFAULT_ALIGN 0x0ffffUL\n\n#define SGEMM_DEFAULT_UNROLL_M 4\n#define SGEMM_DEFAULT_UNROLL_N 4\n#define DGEMM_DEFAULT_UNROLL_M 4\n#define DGEMM_DEFAULT_UNROLL_N 4\n#define CGEMM_DEFAULT_UNROLL_M 2\n#define CGEMM_DEFAULT_UNROLL_N 2\n#define ZGEMM_DEFAULT_UNROLL_M 2\n#define ZGEMM_DEFAULT_UNROLL_N 2\n\n#define SGEMM_DEFAULT_P 256\n#define DGEMM_DEFAULT_P 128\n#define CGEMM_DEFAULT_P 128\n#define ZGEMM_DEFAULT_P  64\n\n#define SGEMM_DEFAULT_Q 256\n#define DGEMM_DEFAULT_Q 256\n#define CGEMM_DEFAULT_Q 256\n#define ZGEMM_DEFAULT_Q 256\n\n#define SYMV_P\t 4\n#endif\n\n#ifdef PPC970\n\n#define SNUMOPT\t\t4\n#define DNUMOPT\t\t4\n\n#define GEMM_DEFAULT_OFFSET_A 2688\n#define GEMM_DEFAULT_OFFSET_B 3072\n#define GEMM_DEFAULT_ALIGN 0x03fffUL\n\n#if defined(__BYTE_ORDER__)&&(__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)\n#define SGEMM_DEFAULT_UNROLL_M 4\n#else\n#define SGEMM_DEFAULT_UNROLL_M 16\n#endif\n#define SGEMM_DEFAULT_UNROLL_N 4\n#define DGEMM_DEFAULT_UNROLL_M 4\n#define DGEMM_DEFAULT_UNROLL_N 4\n#if defined(__BYTE_ORDER__)&&(__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)\n#define CGEMM_DEFAULT_UNROLL_M 2\n#else\n#define CGEMM_DEFAULT_UNROLL_M 8\n#endif\n#define CGEMM_DEFAULT_UNROLL_N 2\n#define ZGEMM_DEFAULT_UNROLL_M 2\n#define ZGEMM_DEFAULT_UNROLL_N 2\n\n#if defined(OS_LINUX) || defined(OS_DARWIN) || defined(OS_FREEBSD)\n#if L2_SIZE == 1024976\n#define SGEMM_DEFAULT_P 320\n#define DGEMM_DEFAULT_P 256\n#define CGEMM_DEFAULT_P 256\n#define ZGEMM_DEFAULT_P 256\n#else\n#define SGEMM_DEFAULT_P 176\n#define DGEMM_DEFAULT_P 176\n#define CGEMM_DEFAULT_P 176\n#define ZGEMM_DEFAULT_P 176\n#endif\n#endif\n\n#define SGEMM_DEFAULT_Q 512\n#define DGEMM_DEFAULT_Q 256\n#define CGEMM_DEFAULT_Q 256\n#define ZGEMM_DEFAULT_Q 128\n\n#define SYMV_P\t 4\n\n#endif\n\n#ifdef PPC440\n\n#define SNUMOPT\t\t2\n#define DNUMOPT\t\t2\n\n#define GEMM_DEFAULT_OFFSET_A (32 * 0)\n#define GEMM_DEFAULT_OFFSET_B (32 * 0)\n#define GEMM_DEFAULT_ALIGN 0x0ffffUL\n\n#define SGEMM_DEFAULT_UNROLL_M 4\n#define SGEMM_DEFAULT_UNROLL_N 4\n#define DGEMM_DEFAULT_UNROLL_M 4\n#define DGEMM_DEFAULT_UNROLL_N 4\n#define CGEMM_DEFAULT_UNROLL_M 2\n#define CGEMM_DEFAULT_UNROLL_N 2\n#define ZGEMM_DEFAULT_UNROLL_M 2\n#define ZGEMM_DEFAULT_UNROLL_N 2\n\n#define SGEMM_DEFAULT_P 512\n#define DGEMM_DEFAULT_P 512\n#define CGEMM_DEFAULT_P 512\n#define ZGEMM_DEFAULT_P 512\n\n#define SGEMM_DEFAULT_Q 1024\n#define DGEMM_DEFAULT_Q  512\n#define CGEMM_DEFAULT_Q  512\n#define ZGEMM_DEFAULT_Q  256\n\n#define SGEMM_DEFAULT_R SGEMM_DEFAULT_P\n#define DGEMM_DEFAULT_R DGEMM_DEFAULT_P\n#define CGEMM_DEFAULT_R CGEMM_DEFAULT_P\n#define ZGEMM_DEFAULT_R ZGEMM_DEFAULT_P\n\n#define SYMV_P\t 4\n#endif\n\n#ifdef PPC440FP2\n\n#define SNUMOPT\t\t4\n#define DNUMOPT\t\t4\n\n#define GEMM_DEFAULT_OFFSET_A (32 * 0)\n#define GEMM_DEFAULT_OFFSET_B (32 * 0)\n#define GEMM_DEFAULT_ALIGN 0x0ffffUL\n\n#define SGEMM_DEFAULT_UNROLL_M 8\n#define SGEMM_DEFAULT_UNROLL_N 4\n#define DGEMM_DEFAULT_UNROLL_M 8\n#define DGEMM_DEFAULT_UNROLL_N 4\n#define CGEMM_DEFAULT_UNROLL_M 4\n#define CGEMM_DEFAULT_UNROLL_N 2\n#define ZGEMM_DEFAULT_UNROLL_M 4\n#define ZGEMM_DEFAULT_UNROLL_N 2\n\n#define SGEMM_DEFAULT_P 128\n#define DGEMM_DEFAULT_P 128\n#define CGEMM_DEFAULT_P 128\n#define ZGEMM_DEFAULT_P 128\n#if 1\n#define SGEMM_DEFAULT_Q 4096\n#define DGEMM_DEFAULT_Q 3072\n#define CGEMM_DEFAULT_Q 2048\n#define ZGEMM_DEFAULT_Q 1024\n#else\n#define SGEMM_DEFAULT_Q  512\n#define DGEMM_DEFAULT_Q  256\n#define CGEMM_DEFAULT_Q  256\n#define ZGEMM_DEFAULT_Q  128\n#endif\n\n#define SYMV_P\t 4\n#endif\n\n\n\n#if defined(POWER3) || defined(POWER4) || defined(POWER5)\n#define GEMM_DEFAULT_OFFSET_A 0\n#define GEMM_DEFAULT_OFFSET_B 2048\n#define GEMM_DEFAULT_ALIGN 0x0ffffUL\n\n#define SGEMM_DEFAULT_UNROLL_M 4\n#define SGEMM_DEFAULT_UNROLL_N 4\n#define DGEMM_DEFAULT_UNROLL_M 4\n#define DGEMM_DEFAULT_UNROLL_N 4\n#define CGEMM_DEFAULT_UNROLL_M 2\n#define CGEMM_DEFAULT_UNROLL_N 2\n#define ZGEMM_DEFAULT_UNROLL_M 2\n#define ZGEMM_DEFAULT_UNROLL_N 2\n\n#ifdef POWER3\n\n#define SNUMOPT\t\t4\n#define DNUMOPT\t\t4\n\n#define SGEMM_DEFAULT_P 256\n#define SGEMM_DEFAULT_Q 432\n#define SGEMM_DEFAULT_R 1012\n\n#define DGEMM_DEFAULT_P 256\n#define DGEMM_DEFAULT_Q 216\n#define DGEMM_DEFAULT_R 1012\n\n#define CGEMM_DEFAULT_P 256\n#define CGEMM_DEFAULT_Q 104\n#define CGEMM_DEFAULT_R 1012\n   \n#define ZGEMM_DEFAULT_P 256\n#define ZGEMM_DEFAULT_Q 104\n#define ZGEMM_DEFAULT_R 1012\n#endif\n\n#if defined(POWER4)\n#ifdef ALLOC_HUGETLB\n#define SGEMM_DEFAULT_P 184\n#define DGEMM_DEFAULT_P 184\n#define CGEMM_DEFAULT_P 184\n#define ZGEMM_DEFAULT_P 184\n#else\n#define SGEMM_DEFAULT_P 144\n#define DGEMM_DEFAULT_P 144\n#define CGEMM_DEFAULT_P 144\n#define ZGEMM_DEFAULT_P 144\n#endif\n\n#define SGEMM_DEFAULT_Q 256\n#define CGEMM_DEFAULT_Q 256\n#define DGEMM_DEFAULT_Q 256\n#define ZGEMM_DEFAULT_Q 256\n#endif\n\n#if defined(POWER5)\n#ifdef ALLOC_HUGETLB\n#define SGEMM_DEFAULT_P 512\n#define DGEMM_DEFAULT_P 256\n#define CGEMM_DEFAULT_P 256\n#define ZGEMM_DEFAULT_P 128\n#else\n#define SGEMM_DEFAULT_P 320\n#define DGEMM_DEFAULT_P 160\n#define CGEMM_DEFAULT_P 160\n#define ZGEMM_DEFAULT_P  80\n#endif\n\n#define SGEMM_DEFAULT_Q 256\n#define CGEMM_DEFAULT_Q 256\n#define DGEMM_DEFAULT_Q 256\n#define ZGEMM_DEFAULT_Q 256\n#endif\n\n#define SYMV_P\t 8\n\n#endif\n\n#if defined(POWER6)\n\n#define SNUMOPT\t\t4\n#define DNUMOPT\t\t4\n\n#define GEMM_DEFAULT_OFFSET_A  384\n#define GEMM_DEFAULT_OFFSET_B 1024\n#define GEMM_DEFAULT_ALIGN 0x03fffUL\n\n#define SGEMM_DEFAULT_UNROLL_M 4\n#define SGEMM_DEFAULT_UNROLL_N 4\n#define DGEMM_DEFAULT_UNROLL_M 4\n#define DGEMM_DEFAULT_UNROLL_N 4\n#define CGEMM_DEFAULT_UNROLL_M 2\n#define CGEMM_DEFAULT_UNROLL_N 4\n#define ZGEMM_DEFAULT_UNROLL_M 2\n#define ZGEMM_DEFAULT_UNROLL_N 4\n\n#define SGEMM_DEFAULT_P  992\n#define DGEMM_DEFAULT_P  480\n#define CGEMM_DEFAULT_P  488\n#define ZGEMM_DEFAULT_P  248\n\n#define SGEMM_DEFAULT_Q  504\n#define DGEMM_DEFAULT_Q  504\n#define CGEMM_DEFAULT_Q  400\n#define ZGEMM_DEFAULT_Q  400\n\n#define SYMV_P\t 8\n\n#endif\n\n#if defined(POWER8) || (defined(POWER9) && defined(OS_AIX))\n\n#define SNUMOPT\t\t16\n#define DNUMOPT\t\t8\n\n#define GEMM_DEFAULT_OFFSET_A 0 \n#define GEMM_DEFAULT_OFFSET_B 65536\n\n#define GEMM_DEFAULT_ALIGN 0x0ffffUL\n#if defined(__32BIT__)\n#warning using BINARY32==POWER6\n#define SGEMM_DEFAULT_UNROLL_M 4\n#define SGEMM_DEFAULT_UNROLL_N 4\n#define DGEMM_DEFAULT_UNROLL_M 4\n#define DGEMM_DEFAULT_UNROLL_N 4\n#define CGEMM_DEFAULT_UNROLL_M 2\n#define CGEMM_DEFAULT_UNROLL_N 4\n#define ZGEMM_DEFAULT_UNROLL_M 2\n#define ZGEMM_DEFAULT_UNROLL_N 4\n#else\n#define SGEMM_DEFAULT_UNROLL_M 16\n#define SGEMM_DEFAULT_UNROLL_N 8\n#define DGEMM_DEFAULT_UNROLL_M 16\n#define DGEMM_DEFAULT_UNROLL_N 4\n#define CGEMM_DEFAULT_UNROLL_M 8\n#define CGEMM_DEFAULT_UNROLL_N 4\n#define ZGEMM_DEFAULT_UNROLL_M 8\n#define ZGEMM_DEFAULT_UNROLL_N 2\n#endif\n#define SGEMM_DEFAULT_P  1280UL\n#define DGEMM_DEFAULT_P  640UL\n#define CGEMM_DEFAULT_P  640UL\n#define ZGEMM_DEFAULT_P  320UL\n\n#define SGEMM_DEFAULT_Q  640UL\n#define DGEMM_DEFAULT_Q  720UL\n#define CGEMM_DEFAULT_Q  640UL\n#define ZGEMM_DEFAULT_Q  640UL\n\n#if 0\n#define SGEMM_DEFAULT_R SGEMM_DEFAULT_P\n#define DGEMM_DEFAULT_R DGEMM_DEFAULT_P\n#define CGEMM_DEFAULT_R CGEMM_DEFAULT_P\n#define ZGEMM_DEFAULT_R ZGEMM_DEFAULT_P\n#endif\n#define SGEMM_DEFAULT_R 4096\n#define DGEMM_DEFAULT_R 4096\n#define CGEMM_DEFAULT_R 4096\n#define ZGEMM_DEFAULT_R 4096\n\n#define SYMV_P\t 8\n\n#endif\n\n#if defined(POWER9) && (defined(OS_LINUX) || defined(OS_FREEBSD))\n\n#define SNUMOPT\t\t16\n#define DNUMOPT\t\t8\n\n#define GEMM_DEFAULT_OFFSET_A 0 \n#define GEMM_DEFAULT_OFFSET_B 65536\n#define GEMM_DEFAULT_ALIGN 0x0ffffUL\n\n#define SWITCH_RATIO            16\n#define GEMM_PREFERED_SIZE      16\n\n#define SGEMM_DEFAULT_UNROLL_M 16\n#define SGEMM_DEFAULT_UNROLL_N 8\n#define DGEMM_DEFAULT_UNROLL_M 16\n#define DGEMM_DEFAULT_UNROLL_N 4\n#define CGEMM_DEFAULT_UNROLL_M 8\n#define CGEMM_DEFAULT_UNROLL_N 4\n#define ZGEMM_DEFAULT_UNROLL_M 8\n#define ZGEMM_DEFAULT_UNROLL_N 2\n\n#define SGEMM_DEFAULT_P 832\n#define DGEMM_DEFAULT_P  128\n#define CGEMM_DEFAULT_P  512\n#define ZGEMM_DEFAULT_P 256\n\n#define SGEMM_DEFAULT_Q 1026\n#define DGEMM_DEFAULT_Q  384\n#define CGEMM_DEFAULT_Q  1026\n#define ZGEMM_DEFAULT_Q 1026\n\n#define SGEMM_DEFAULT_R 4096\n#define DGEMM_DEFAULT_R 4096\n#define CGEMM_DEFAULT_R 4096\n#define ZGEMM_DEFAULT_R 4096\n\n#define SYMV_P\t 8\n\n#endif\n\n#if defined(POWER10)\n#define SNUMOPT\t\t16\n#define DNUMOPT\t\t8\n\n#define GEMM_DEFAULT_OFFSET_A 0\n#define GEMM_DEFAULT_OFFSET_B 65536\n#define GEMM_DEFAULT_ALIGN 0x0ffffUL\n\n#define SWITCH_RATIO            16\n#define GEMM_PREFERED_SIZE      16\n\n#define SGEMM_DEFAULT_UNROLL_M 16\n#define SGEMM_DEFAULT_UNROLL_N 8\n#define DGEMM_DEFAULT_UNROLL_M 8\n#define DGEMM_DEFAULT_UNROLL_N 8\n#define CGEMM_DEFAULT_UNROLL_M 8\n#define CGEMM_DEFAULT_UNROLL_N 4\n#define ZGEMM_DEFAULT_UNROLL_M 8\n#define ZGEMM_DEFAULT_UNROLL_N 2\n\n#define SGEMM_DEFAULT_P 512\n#define DGEMM_DEFAULT_P 384\n#define CGEMM_DEFAULT_P 512\n#define ZGEMM_DEFAULT_P 256\n\n#define SGEMM_DEFAULT_Q 512\n#define DGEMM_DEFAULT_Q 512\n#define CGEMM_DEFAULT_Q 384\n#define ZGEMM_DEFAULT_Q 384 \n\n#define SGEMM_DEFAULT_R 4096\n#define DGEMM_DEFAULT_R 4096\n#define CGEMM_DEFAULT_R 4096\n#define ZGEMM_DEFAULT_R 4096\n\n#define SYMV_P\t 8\n\n#undef SBGEMM_DEFAULT_UNROLL_N\n#undef SBGEMM_DEFAULT_UNROLL_M\n#undef SBGEMM_DEFAULT_P\n#undef SBGEMM_DEFAULT_R\n#undef SBGEMM_DEFAULT_Q\n#define SBGEMM_DEFAULT_UNROLL_M 16\n#define SBGEMM_DEFAULT_UNROLL_N 8\n#define SBGEMM_DEFAULT_P 512\n#define SBGEMM_DEFAULT_Q 1024\n#define SBGEMM_DEFAULT_R 4096\n#endif\n\n#if defined(SPARC) && defined(V7)\n\n#define SNUMOPT\t\t4\n#define DNUMOPT\t\t4\n\n#define GEMM_DEFAULT_OFFSET_A 0\n#define GEMM_DEFAULT_OFFSET_B 2048\n#define GEMM_DEFAULT_ALIGN 0x03fffUL\n\n#define SGEMM_DEFAULT_UNROLL_M 2\n#define SGEMM_DEFAULT_UNROLL_N 8\n#define DGEMM_DEFAULT_UNROLL_M 2\n#define DGEMM_DEFAULT_UNROLL_N 8\n#define CGEMM_DEFAULT_UNROLL_M 1\n#define CGEMM_DEFAULT_UNROLL_N 4\n#define ZGEMM_DEFAULT_UNROLL_M 1\n#define ZGEMM_DEFAULT_UNROLL_N 4\n\n#define SGEMM_DEFAULT_P  256\n#define DGEMM_DEFAULT_P  256\n#define CGEMM_DEFAULT_P  256\n#define ZGEMM_DEFAULT_P  256\n\n#define SGEMM_DEFAULT_Q  512\n#define DGEMM_DEFAULT_Q  256\n#define CGEMM_DEFAULT_Q  256\n#define ZGEMM_DEFAULT_Q  128\n\n#define SYMV_P\t 8\n#define GEMM_THREAD gemm_thread_mn\n#endif\n\n#if (defined(SPARC) && defined(V9)) || defined(__sparc_v9__)\n\n#define SNUMOPT\t\t2\n#define DNUMOPT\t\t2\n\n#define GEMM_DEFAULT_OFFSET_A 0\n#define GEMM_DEFAULT_OFFSET_B 2048\n#define GEMM_DEFAULT_ALIGN 0x03fffUL\n\n#define SGEMM_DEFAULT_UNROLL_M 4\n#define SGEMM_DEFAULT_UNROLL_N 4\n#define DGEMM_DEFAULT_UNROLL_M 4\n#define DGEMM_DEFAULT_UNROLL_N 4\n#define CGEMM_DEFAULT_UNROLL_M 2\n#define CGEMM_DEFAULT_UNROLL_N 2\n#define ZGEMM_DEFAULT_UNROLL_M 2\n#define ZGEMM_DEFAULT_UNROLL_N 2\n\n#define SGEMM_DEFAULT_P  512\n#define DGEMM_DEFAULT_P  512\n#define CGEMM_DEFAULT_P  512\n#define ZGEMM_DEFAULT_P  512\n\n#define SGEMM_DEFAULT_Q 1024\n#define DGEMM_DEFAULT_Q  512\n#define CGEMM_DEFAULT_Q  512\n#define ZGEMM_DEFAULT_Q  256\n\n#define SYMV_P\t 8\n#endif\n\n#ifdef SICORTEX\n\n#define SNUMOPT\t\t2\n#define DNUMOPT\t\t2\n\n#define GEMM_DEFAULT_OFFSET_A 0\n#define GEMM_DEFAULT_OFFSET_B 0\n#define GEMM_DEFAULT_ALIGN (BLASLONG)0x03fffUL\n\n#define SGEMM_DEFAULT_UNROLL_M  2\n#define SGEMM_DEFAULT_UNROLL_N  8\n#define DGEMM_DEFAULT_UNROLL_M  2\n#define DGEMM_DEFAULT_UNROLL_N  8\n#define CGEMM_DEFAULT_UNROLL_M  1\n#define CGEMM_DEFAULT_UNROLL_N  4\n#define ZGEMM_DEFAULT_UNROLL_M  1\n#define ZGEMM_DEFAULT_UNROLL_N  4\n\n#define SGEMM_DEFAULT_P 108\n#define DGEMM_DEFAULT_P 112\n#define CGEMM_DEFAULT_P 108\n#define ZGEMM_DEFAULT_P 112\n\n#define SGEMM_DEFAULT_Q 288\n#define DGEMM_DEFAULT_Q 144\n#define CGEMM_DEFAULT_Q 144\n#define ZGEMM_DEFAULT_Q  72\n\n#define SGEMM_DEFAULT_R 2000\n#define DGEMM_DEFAULT_R 2000\n#define CGEMM_DEFAULT_R 2000\n#define ZGEMM_DEFAULT_R 2000\n\n#define SYMV_P\t16\n#endif\n\n#if defined(LOONGSON3R4)\n#define SNUMOPT\t\t2\n#define DNUMOPT\t\t2\n\n#define GEMM_DEFAULT_OFFSET_A 0\n#define GEMM_DEFAULT_OFFSET_B 0\n#define GEMM_DEFAULT_ALIGN (BLASLONG)0x03fffUL\n\n#if defined(NO_MSA)\n#define SGEMM_DEFAULT_UNROLL_M  8\n#define SGEMM_DEFAULT_UNROLL_N  4\n\n#define DGEMM_DEFAULT_UNROLL_M  4\n#define DGEMM_DEFAULT_UNROLL_N  4\n\n#define CGEMM_DEFAULT_UNROLL_M  4\n#define CGEMM_DEFAULT_UNROLL_N  2\n\n#define ZGEMM_DEFAULT_UNROLL_M  2\n#define ZGEMM_DEFAULT_UNROLL_N  2\n#else\n#define SGEMM_DEFAULT_UNROLL_M  8\n#define SGEMM_DEFAULT_UNROLL_N  8\n\n#define DGEMM_DEFAULT_UNROLL_M  8\n#define DGEMM_DEFAULT_UNROLL_N  4\n\n#define CGEMM_DEFAULT_UNROLL_M  8\n#define CGEMM_DEFAULT_UNROLL_N  4\n\n#define ZGEMM_DEFAULT_UNROLL_M  4\n#define ZGEMM_DEFAULT_UNROLL_N  4\n#endif\n\n#define SGEMM_DEFAULT_P\t64\n#define DGEMM_DEFAULT_P\t44\n#define CGEMM_DEFAULT_P 64\n#define ZGEMM_DEFAULT_P 32\n\n#define SGEMM_DEFAULT_Q 192\n#define DGEMM_DEFAULT_Q 92\n#define CGEMM_DEFAULT_Q 128\n#define ZGEMM_DEFAULT_Q 80\n\n#define SGEMM_DEFAULT_R 640\n#define DGEMM_DEFAULT_R dgemm_r\n#define CGEMM_DEFAULT_R 640\n#define ZGEMM_DEFAULT_R 640\n\n#define GEMM_OFFSET_A1\t0x10000\n#define\tGEMM_OFFSET_B1\t0x100000\n\n#define SYMV_P\t16\n#endif\n\n#if defined(LOONGSON3R3)\n////Copy from SICORTEX\n#define SNUMOPT\t\t2\n#define DNUMOPT\t\t2\n\n#define GEMM_DEFAULT_OFFSET_A 0\n#define GEMM_DEFAULT_OFFSET_B 0\n#define GEMM_DEFAULT_ALIGN (BLASLONG)0x03fffUL\n\n#define SGEMM_DEFAULT_UNROLL_M  8\n#define SGEMM_DEFAULT_UNROLL_N  4\n\n#define DGEMM_DEFAULT_UNROLL_M  4\n#define DGEMM_DEFAULT_UNROLL_N  4\n\n#define CGEMM_DEFAULT_UNROLL_M  4\n#define CGEMM_DEFAULT_UNROLL_N  2\n\n#define ZGEMM_DEFAULT_UNROLL_M  2\n#define ZGEMM_DEFAULT_UNROLL_N  2\n\n#define SGEMM_DEFAULT_P\t64\n#define DGEMM_DEFAULT_P\t44\n#define CGEMM_DEFAULT_P 64\n#define ZGEMM_DEFAULT_P 32\n\n#define SGEMM_DEFAULT_Q 192\n#define DGEMM_DEFAULT_Q 92\n#define CGEMM_DEFAULT_Q 128\n#define ZGEMM_DEFAULT_Q 80\n\n#define SGEMM_DEFAULT_R 640\n#define DGEMM_DEFAULT_R dgemm_r\n#define CGEMM_DEFAULT_R 640\n#define ZGEMM_DEFAULT_R 640\n\n#define GEMM_OFFSET_A1\t0x10000\n#define\tGEMM_OFFSET_B1\t0x100000\n\n#define SYMV_P\t16\n#endif\n\n#if defined (LA464)\n#define SNUMOPT         2\n#define DNUMOPT         2\n\n#define GEMM_DEFAULT_OFFSET_A 0x20000\n#define GEMM_DEFAULT_OFFSET_B 0\n#define GEMM_DEFAULT_ALIGN 0x0ffffUL\n\n#if defined(NO_LASX)\n#define DGEMM_DEFAULT_UNROLL_N 8\n#define DGEMM_DEFAULT_UNROLL_M 2\n#define SGEMM_DEFAULT_UNROLL_N 8\n#define SGEMM_DEFAULT_UNROLL_M 2\n#define CGEMM_DEFAULT_UNROLL_N 4\n#define CGEMM_DEFAULT_UNROLL_M 1\n#define ZGEMM_DEFAULT_UNROLL_N 4\n#define ZGEMM_DEFAULT_UNROLL_M 1\n#else\n#define DGEMM_DEFAULT_UNROLL_N 6\n#define DGEMM_DEFAULT_UNROLL_M 16\n#define SGEMM_DEFAULT_UNROLL_N 8\n#define SGEMM_DEFAULT_UNROLL_M 16\n#define CGEMM_DEFAULT_UNROLL_N 4\n#define CGEMM_DEFAULT_UNROLL_M 16\n#define ZGEMM_DEFAULT_UNROLL_N 4\n#define ZGEMM_DEFAULT_UNROLL_M 8\n#define DGEMM_DEFAULT_UNROLL_MN 96\n#endif\n\n#define QGEMM_DEFAULT_UNROLL_N 2\n#define XGEMM_DEFAULT_UNROLL_N 1\n\n#define QGEMM_DEFAULT_UNROLL_M 2\n#define XGEMM_DEFAULT_UNROLL_M 1\n\n#define SGEMM_DEFAULT_P sgemm_p\n#define DGEMM_DEFAULT_P dgemm_p\n#define CGEMM_DEFAULT_P 128\n#define ZGEMM_DEFAULT_P zgemm_p\n\n#define SGEMM_DEFAULT_R sgemm_r\n#define DGEMM_DEFAULT_R dgemm_r\n#define CGEMM_DEFAULT_R 4096\n#define ZGEMM_DEFAULT_R zgemm_r\n\n#define SGEMM_DEFAULT_Q sgemm_q\n#define DGEMM_DEFAULT_Q dgemm_q\n#define CGEMM_DEFAULT_Q 128\n#define ZGEMM_DEFAULT_Q zgemm_q\n\n#define SYMV_P  16\n#endif\n\n#ifdef LA264\n#define GEMM_DEFAULT_OFFSET_A 0\n#define GEMM_DEFAULT_OFFSET_B 0\n#define GEMM_DEFAULT_ALIGN (BLASLONG)0x03fffUL\n\n#define SGEMM_DEFAULT_UNROLL_M  2\n#define SGEMM_DEFAULT_UNROLL_N  8\n\n#define DGEMM_DEFAULT_UNROLL_M  8\n#define DGEMM_DEFAULT_UNROLL_N  4\n\n#define CGEMM_DEFAULT_UNROLL_M  8\n#define CGEMM_DEFAULT_UNROLL_N  4\n\n#define ZGEMM_DEFAULT_UNROLL_M  4\n#define ZGEMM_DEFAULT_UNROLL_N  4\n\n#define SGEMM_DEFAULT_P\t128\n#define DGEMM_DEFAULT_P\t128\n#define CGEMM_DEFAULT_P 96\n#define ZGEMM_DEFAULT_P 64\n\n#define SGEMM_DEFAULT_Q 240\n#define DGEMM_DEFAULT_Q 120\n#define CGEMM_DEFAULT_Q 120\n#define ZGEMM_DEFAULT_Q 120\n\n#define SGEMM_DEFAULT_R 12288\n#define DGEMM_DEFAULT_R 8192\n#define CGEMM_DEFAULT_R 4096\n#define ZGEMM_DEFAULT_R 4096\n\n#define SYMV_P\t16\n#endif\n\n#ifdef LA64_GENERIC\n#define GEMM_DEFAULT_OFFSET_A 0\n#define GEMM_DEFAULT_OFFSET_B 0\n#define GEMM_DEFAULT_ALIGN (BLASLONG)0x03fffUL\n\n#define SGEMM_DEFAULT_UNROLL_M  2\n#define SGEMM_DEFAULT_UNROLL_N  8\n\n#define DGEMM_DEFAULT_UNROLL_M  2\n#define DGEMM_DEFAULT_UNROLL_N  8\n\n#define CGEMM_DEFAULT_UNROLL_M  1\n#define CGEMM_DEFAULT_UNROLL_N  4\n\n#define ZGEMM_DEFAULT_UNROLL_M  1\n#define ZGEMM_DEFAULT_UNROLL_N  4\n\n#define SGEMM_DEFAULT_P\t128\n#define DGEMM_DEFAULT_P\t128\n#define CGEMM_DEFAULT_P 96\n#define ZGEMM_DEFAULT_P 64\n\n#define SGEMM_DEFAULT_Q 240\n#define DGEMM_DEFAULT_Q 120\n#define CGEMM_DEFAULT_Q 120\n#define ZGEMM_DEFAULT_Q 120\n\n#define SGEMM_DEFAULT_R 12288\n#define DGEMM_DEFAULT_R 8192\n#define CGEMM_DEFAULT_R 4096\n#define ZGEMM_DEFAULT_R 4096\n\n#define SYMV_P\t16\n#endif\n\n#if defined(MIPS64_GENERIC) || defined(P5600) || defined(MIPS1004K) || defined(MIPS24K) || defined(I6400) || defined(P6600) || defined(I6500)\n#define SNUMOPT  2\n#define DNUMOPT  2\n\n#define GEMM_DEFAULT_OFFSET_A  0\n#define GEMM_DEFAULT_OFFSET_B  0\n#define GEMM_DEFAULT_ALIGN (BLASLONG) 0x03fffUL\n\n#if defined(NO_MSA) || defined(MIPS64_GENERIC)\n#define SGEMM_DEFAULT_UNROLL_M  2\n#define SGEMM_DEFAULT_UNROLL_N  2\n\n#define DGEMM_DEFAULT_UNROLL_M  2\n#define DGEMM_DEFAULT_UNROLL_N  2\n\n#define CGEMM_DEFAULT_UNROLL_M  2\n#define CGEMM_DEFAULT_UNROLL_N  2\n\n#define ZGEMM_DEFAULT_UNROLL_M  2\n#define ZGEMM_DEFAULT_UNROLL_N  2\n#else\n#define SGEMM_DEFAULT_UNROLL_M  8\n#define SGEMM_DEFAULT_UNROLL_N  8\n\n#define DGEMM_DEFAULT_UNROLL_M  8\n#define DGEMM_DEFAULT_UNROLL_N  4\n\n#define CGEMM_DEFAULT_UNROLL_M  8\n#define CGEMM_DEFAULT_UNROLL_N  4\n\n#define ZGEMM_DEFAULT_UNROLL_M  4\n#define ZGEMM_DEFAULT_UNROLL_N  4\n#endif\n\n#define SGEMM_DEFAULT_P  128\n#define DGEMM_DEFAULT_P  128\n#define CGEMM_DEFAULT_P  96\n#define ZGEMM_DEFAULT_P  64\n\n#define SGEMM_DEFAULT_Q  240\n#define DGEMM_DEFAULT_Q  120\n#define CGEMM_DEFAULT_Q  120\n#define ZGEMM_DEFAULT_Q  120\n\n#define SGEMM_DEFAULT_R  12288\n#define DGEMM_DEFAULT_R  8192\n#define CGEMM_DEFAULT_R  4096\n#define ZGEMM_DEFAULT_R  4096\n\n#define SYMV_P  16\n#endif\n\n#ifdef RISCV64_GENERIC\n#define GEMM_DEFAULT_OFFSET_A 0\n#define GEMM_DEFAULT_OFFSET_B 0\n#define GEMM_DEFAULT_ALIGN (BLASLONG)0x03fffUL\n\n#define SGEMM_DEFAULT_UNROLL_M  2\n#define SGEMM_DEFAULT_UNROLL_N  2\n\n#define DGEMM_DEFAULT_UNROLL_M  2\n#define DGEMM_DEFAULT_UNROLL_N  2\n\n#define CGEMM_DEFAULT_UNROLL_M  2\n#define CGEMM_DEFAULT_UNROLL_N  2\n\n#define ZGEMM_DEFAULT_UNROLL_M  2\n#define ZGEMM_DEFAULT_UNROLL_N  2\n\n#define SGEMM_DEFAULT_P\t128\n#define DGEMM_DEFAULT_P\t128\n#define CGEMM_DEFAULT_P 96\n#define ZGEMM_DEFAULT_P 64\n\n#define SGEMM_DEFAULT_Q 240\n#define DGEMM_DEFAULT_Q 120\n#define CGEMM_DEFAULT_Q 120\n#define ZGEMM_DEFAULT_Q 120\n\n#define SGEMM_DEFAULT_R 12288\n#define DGEMM_DEFAULT_R 8192\n#define CGEMM_DEFAULT_R 4096\n#define ZGEMM_DEFAULT_R 4096\n\n#define SYMV_P\t16\n\n#define GEMM_DEFAULT_OFFSET_A 0\n#define GEMM_DEFAULT_OFFSET_B 0\n\n#endif\n\n#if defined(x280)\n#define GEMM_DEFAULT_OFFSET_A 0\n#define GEMM_DEFAULT_OFFSET_B 0\n#define GEMM_DEFAULT_ALIGN 0x03fffUL\n\n#define SGEMM_DEFAULT_UNROLL_M  16 // 4 // 16 // 2\n#define SGEMM_DEFAULT_UNROLL_N  8// 4 // 4 // 2\n\n/* SGEMM_UNROLL_MN is calculated as max(SGEMM_UNROLL_M, SGEMM_UNROLL_N)\n * Since we don't define SGEMM_UNROLL_M correctly we have to manually set this macro.\n * If VLMAX size is ever more than 1024, this should be increased also. */\n#define SGEMM_DEFAULT_UNROLL_MN  32\n\n#define DGEMM_DEFAULT_UNROLL_M  16 //2 // 8\n#define DGEMM_DEFAULT_UNROLL_N  8 //2 // 4\n#define DGEMM_DEFAULT_UNROLL_MN  32\n\n#define CGEMM_DEFAULT_UNROLL_M  8\n#define CGEMM_DEFAULT_UNROLL_N  4\n#define CGEMM_DEFAULT_UNROLL_MN 32\n\n#define ZGEMM_DEFAULT_UNROLL_M  8\n#define ZGEMM_DEFAULT_UNROLL_N  4\n#define ZGEMM_DEFAULT_UNROLL_MN 16\n\n#define SGEMM_DEFAULT_P\t160\n#define DGEMM_DEFAULT_P\t160\n#define CGEMM_DEFAULT_P 96\n#define ZGEMM_DEFAULT_P 64\n\n#define SGEMM_DEFAULT_Q 240\n#define DGEMM_DEFAULT_Q 128\n#define CGEMM_DEFAULT_Q 120\n#define ZGEMM_DEFAULT_Q 120\n\n#define SGEMM_DEFAULT_R 12288\n#define DGEMM_DEFAULT_R 8192\n#define CGEMM_DEFAULT_R 4096\n#define ZGEMM_DEFAULT_R 4096\n\n#define SYMV_P\t16\n\n#define GEMM_DEFAULT_OFFSET_A 0\n#define GEMM_DEFAULT_OFFSET_B 0\n\n#endif\n#ifdef C910V\n#define GEMM_DEFAULT_OFFSET_A 0\n#define GEMM_DEFAULT_OFFSET_B 0\n#define GEMM_DEFAULT_ALIGN 0x03fffUL\n\n#define SGEMM_DEFAULT_UNROLL_M  16\n#define SGEMM_DEFAULT_UNROLL_N  4\n\n#define DGEMM_DEFAULT_UNROLL_M  8\n#define DGEMM_DEFAULT_UNROLL_N  4\n\n#define CGEMM_DEFAULT_UNROLL_M  2\n#define CGEMM_DEFAULT_UNROLL_N  2\n\n#define ZGEMM_DEFAULT_UNROLL_M  2\n#define ZGEMM_DEFAULT_UNROLL_N  2\n\n#define SGEMM_DEFAULT_P\t160\n#define DGEMM_DEFAULT_P\t160\n#define CGEMM_DEFAULT_P 96\n#define ZGEMM_DEFAULT_P 64\n\n#define SGEMM_DEFAULT_Q 240\n#define DGEMM_DEFAULT_Q 128\n#define CGEMM_DEFAULT_Q 120\n#define ZGEMM_DEFAULT_Q 120\n\n#define SGEMM_DEFAULT_R 12288\n#define DGEMM_DEFAULT_R 8192\n#define CGEMM_DEFAULT_R 4096\n#define ZGEMM_DEFAULT_R 4096\n\n#define SYMV_P\t16\n\n#define GEMM_DEFAULT_OFFSET_A 0\n#define GEMM_DEFAULT_OFFSET_B 0\n\n#endif\n\n#ifdef RISCV64_ZVL128B\n#define GEMM_DEFAULT_OFFSET_A 0\n#define GEMM_DEFAULT_OFFSET_B 0\n#define GEMM_DEFAULT_ALIGN (BLASLONG)0x03fffUL\n\n#define SGEMM_DEFAULT_UNROLL_M 8\n#define SGEMM_DEFAULT_UNROLL_N 8\n\n#define DGEMM_DEFAULT_UNROLL_M 8\n#define DGEMM_DEFAULT_UNROLL_N 4\n\n#define CGEMM_DEFAULT_UNROLL_M 8\n#define CGEMM_DEFAULT_UNROLL_N 4\n\n#define ZGEMM_DEFAULT_UNROLL_M 4\n#define ZGEMM_DEFAULT_UNROLL_N 4\n\n#define SGEMM_DEFAULT_P 128\n#define DGEMM_DEFAULT_P 128\n#define CGEMM_DEFAULT_P 96\n#define ZGEMM_DEFAULT_P 64\n\n#define SGEMM_DEFAULT_Q 240\n#define DGEMM_DEFAULT_Q 120\n#define CGEMM_DEFAULT_Q 120\n#define ZGEMM_DEFAULT_Q 120\n\n#define SGEMM_DEFAULT_R 12288\n#define DGEMM_DEFAULT_R 8192\n#define CGEMM_DEFAULT_R 4096\n#define ZGEMM_DEFAULT_R 4096\n\n#define SYMV_P 16\n\n#define GEMM_DEFAULT_OFFSET_A 0\n#define GEMM_DEFAULT_OFFSET_B 0\n\n#endif\n\n#ifdef RISCV64_ZVL256B\n#define GEMM_DEFAULT_OFFSET_A 0\n#define GEMM_DEFAULT_OFFSET_B 0\n#define GEMM_DEFAULT_ALIGN 0x03fffUL\n\n#define SGEMM_DEFAULT_UNROLL_M  16\n#define SGEMM_DEFAULT_UNROLL_N  8\n\n#define DGEMM_DEFAULT_UNROLL_M  8\n#define DGEMM_DEFAULT_UNROLL_N  8\n\n#define CGEMM_DEFAULT_UNROLL_M  8\n#define CGEMM_DEFAULT_UNROLL_N  8\n\n#define ZGEMM_DEFAULT_UNROLL_M  8\n#define ZGEMM_DEFAULT_UNROLL_N  4\n\n#define SGEMM_DEFAULT_P 128\n#define DGEMM_DEFAULT_P 64\n#define CGEMM_DEFAULT_P 64\n#define ZGEMM_DEFAULT_P 64\n\n#define SGEMM_DEFAULT_Q 128\n#define DGEMM_DEFAULT_Q 128\n#define CGEMM_DEFAULT_Q 128\n#define ZGEMM_DEFAULT_Q 64\n\n#define SGEMM_DEFAULT_R 16384\n#define DGEMM_DEFAULT_R 8192\n#define CGEMM_DEFAULT_R 8192\n#define ZGEMM_DEFAULT_R 4096\n\n#define SYMV_P 16\n\n#define GEMM_DEFAULT_OFFSET_A 0\n#define GEMM_DEFAULT_OFFSET_B 0\n\n#endif\n\n#ifdef ARMV7\n#define SNUMOPT\t\t2\n#define DNUMOPT\t\t2\n\n#define GEMM_DEFAULT_OFFSET_A 0\n#define GEMM_DEFAULT_OFFSET_B 0\n#define GEMM_DEFAULT_ALIGN (BLASLONG)0x03fffUL\n\n#define SGEMM_DEFAULT_UNROLL_M  4\n#define SGEMM_DEFAULT_UNROLL_N  4\n\n#define DGEMM_DEFAULT_UNROLL_M  4\n#define DGEMM_DEFAULT_UNROLL_N  4\n\n#define CGEMM_DEFAULT_UNROLL_M  2\n#define CGEMM_DEFAULT_UNROLL_N  2\n\n#define ZGEMM_DEFAULT_UNROLL_M  2\n#define ZGEMM_DEFAULT_UNROLL_N  2\n\n#define SGEMM_DEFAULT_P\t128\n#define DGEMM_DEFAULT_P\t128\n#define CGEMM_DEFAULT_P 96\n#define ZGEMM_DEFAULT_P 64\n\n#define SGEMM_DEFAULT_Q 240\n#define DGEMM_DEFAULT_Q 120\n#define CGEMM_DEFAULT_Q 120\n#define ZGEMM_DEFAULT_Q 120\n\n#define SGEMM_DEFAULT_R 12288\n#define DGEMM_DEFAULT_R 8192\n#define CGEMM_DEFAULT_R 4096\n#define ZGEMM_DEFAULT_R 4096\n\n\n\n#define SYMV_P\t16\n#endif\n\n\n#if defined(ARMV6)\n#define SNUMOPT\t\t2\n#define DNUMOPT\t\t2\n\n#define GEMM_DEFAULT_OFFSET_A 0\n#define GEMM_DEFAULT_OFFSET_B 0\n#define GEMM_DEFAULT_ALIGN (BLASLONG)0x03fffUL\n\n#define SGEMM_DEFAULT_UNROLL_M  4\n#define SGEMM_DEFAULT_UNROLL_N  2\n\n#define DGEMM_DEFAULT_UNROLL_M  4\n#define DGEMM_DEFAULT_UNROLL_N  2\n\n#define CGEMM_DEFAULT_UNROLL_M  2\n#define CGEMM_DEFAULT_UNROLL_N  2\n\n#define ZGEMM_DEFAULT_UNROLL_M  2\n#define ZGEMM_DEFAULT_UNROLL_N  2\n\n#define SGEMM_DEFAULT_P\t128\n#define DGEMM_DEFAULT_P\t128\n#define CGEMM_DEFAULT_P 96\n#define ZGEMM_DEFAULT_P 64\n\n#define SGEMM_DEFAULT_Q 240\n#define DGEMM_DEFAULT_Q 120\n#define CGEMM_DEFAULT_Q 120\n#define ZGEMM_DEFAULT_Q 120\n\n#define SGEMM_DEFAULT_R 12288\n#define DGEMM_DEFAULT_R 8192\n#define CGEMM_DEFAULT_R 4096\n#define ZGEMM_DEFAULT_R 4096\n\n\n#define SYMV_P\t16\n#endif\n\n/* Common ARMv8 parameters */\n#if defined(ARMV8)\n\n#define SNUMOPT\t\t2\n#define DNUMOPT\t\t2\n\n#define GEMM_DEFAULT_OFFSET_A 0\n#define GEMM_DEFAULT_OFFSET_B 0\n#ifdef _WIN64\n/* Use explicit casting for win64 as LLP64 datamodel is used */\n#define GEMM_DEFAULT_ALIGN (BLASULONG)0x03fffUL\n#else\n#define GEMM_DEFAULT_ALIGN 0x03fffUL\n#endif\n\n#define SYMV_P\t16\n\n#if defined(CORTEXA57) || defined(CORTEXX1) || \\\n    defined(CORTEXA72) || defined(CORTEXA73) || \\\n    defined(FALKOR)    || defined(TSV110) || defined(EMAG8180) || defined(VORTEX) || defined(FT2000)\n\n#define SGEMM_DEFAULT_UNROLL_M  16\n#define SGEMM_DEFAULT_UNROLL_N  4\n\n#define DGEMM_DEFAULT_UNROLL_M  8\n#define DGEMM_DEFAULT_UNROLL_N  4\n\n#define CGEMM_DEFAULT_UNROLL_M  8\n#define CGEMM_DEFAULT_UNROLL_N  4\n\n#define ZGEMM_DEFAULT_UNROLL_M  4\n#define ZGEMM_DEFAULT_UNROLL_N  4\n\n/*FIXME: this should be using the cache size, but there is currently no easy way to\nquery that on ARM. So if getarch counted more than 8 cores we simply assume the host\nis a big desktop or server with abundant cache rather than a phone or embedded device */ \n#if NUM_CORES > 8 || defined(TSV110) || defined(EMAG8180) || defined(VORTEX)|| defined(CORTEXX1)\n  #define SGEMM_DEFAULT_P 512\n  #define DGEMM_DEFAULT_P 256\n  #define CGEMM_DEFAULT_P 256\n  #define ZGEMM_DEFAULT_P 128\n\n  #define SGEMM_DEFAULT_Q 1024\n  #define DGEMM_DEFAULT_Q 512\n  #define CGEMM_DEFAULT_Q 512\n  #define ZGEMM_DEFAULT_Q 512\n#else\n  #define SGEMM_DEFAULT_P 128\n  #define DGEMM_DEFAULT_P 160\n  #define CGEMM_DEFAULT_P 128\n  #define ZGEMM_DEFAULT_P 128\n\n  #define SGEMM_DEFAULT_Q 352\n  #define DGEMM_DEFAULT_Q 128\n  #define CGEMM_DEFAULT_Q 224\n  #define ZGEMM_DEFAULT_Q 112\n#endif\n\n#define SGEMM_DEFAULT_R 4096\n#define DGEMM_DEFAULT_R 4096\n#define CGEMM_DEFAULT_R 4096\n#define ZGEMM_DEFAULT_R 2048\n\n#elif defined(CORTEXA76)\n\n#define SGEMM_DEFAULT_UNROLL_M  16\n#define SGEMM_DEFAULT_UNROLL_N  4\n\n#define DGEMM_DEFAULT_UNROLL_M  8\n#define DGEMM_DEFAULT_UNROLL_N  4\n\n#define CGEMM_DEFAULT_UNROLL_M  8\n#define CGEMM_DEFAULT_UNROLL_N  4\n\n#define ZGEMM_DEFAULT_UNROLL_M  4\n#define ZGEMM_DEFAULT_UNROLL_N  4\n\n#if defined(XDOUBLE) || defined(DOUBLE)\n#define SWITCH_RATIO            8\n#else\n#define SWITCH_RATIO            16\n#endif\n\n  #define SGEMM_DEFAULT_P 256\n  #define DGEMM_DEFAULT_P 128\n  #define CGEMM_DEFAULT_P 128\n  #define ZGEMM_DEFAULT_P 64\n\n  #define SGEMM_DEFAULT_Q 512\n  #define DGEMM_DEFAULT_Q 256\n  #define CGEMM_DEFAULT_Q 256\n  #define ZGEMM_DEFAULT_Q 256\n\n#define SGEMM_DEFAULT_R 4096\n#define DGEMM_DEFAULT_R 4096\n#define CGEMM_DEFAULT_R 4096\n#define ZGEMM_DEFAULT_R 4096\n\n#elif defined(CORTEXA53) || defined(CORTEXA55)\n\n#define SGEMM_DEFAULT_UNROLL_M  8\n#define SGEMM_DEFAULT_UNROLL_N  8\n\n#define DGEMM_DEFAULT_UNROLL_M  4\n#define DGEMM_DEFAULT_UNROLL_N  4\n\n#define CGEMM_DEFAULT_UNROLL_M  8\n#define CGEMM_DEFAULT_UNROLL_N  4\n\n#define ZGEMM_DEFAULT_UNROLL_M  4\n#define ZGEMM_DEFAULT_UNROLL_N  4\n\n#define SGEMM_DEFAULT_P 256\n#define DGEMM_DEFAULT_P 160\n#define CGEMM_DEFAULT_P 128\n#define ZGEMM_DEFAULT_P 128\n\n#define SGEMM_DEFAULT_Q 256\n#define DGEMM_DEFAULT_Q 128\n#define CGEMM_DEFAULT_Q 224\n#define ZGEMM_DEFAULT_Q 112\n\n#define SGEMM_DEFAULT_R 4096\n#define DGEMM_DEFAULT_R 4096\n#define CGEMM_DEFAULT_R 4096\n#define ZGEMM_DEFAULT_R 2048\n\n#elif defined(THUNDERX)\n\n#define SGEMM_DEFAULT_UNROLL_M  4\n#define SGEMM_DEFAULT_UNROLL_N  4\n\n#define DGEMM_DEFAULT_UNROLL_M  2\n#define DGEMM_DEFAULT_UNROLL_N  2\n\n#define CGEMM_DEFAULT_UNROLL_M  2\n#define CGEMM_DEFAULT_UNROLL_N  2\n\n#define ZGEMM_DEFAULT_UNROLL_M  2\n#define ZGEMM_DEFAULT_UNROLL_N  2\n\n#define SGEMM_DEFAULT_P\t128\n#define DGEMM_DEFAULT_P\t128\n#define CGEMM_DEFAULT_P 96\n#define ZGEMM_DEFAULT_P 64\n\n#define SGEMM_DEFAULT_Q 240\n#define DGEMM_DEFAULT_Q 120\n#define CGEMM_DEFAULT_Q 120\n#define ZGEMM_DEFAULT_Q 120\n\n#define SGEMM_DEFAULT_R 12288\n#define DGEMM_DEFAULT_R 8192\n#define CGEMM_DEFAULT_R 4096\n#define ZGEMM_DEFAULT_R 4096\n\n#elif defined(THUNDERX2T99)\n\n#define SGEMM_DEFAULT_UNROLL_M  16\n#define SGEMM_DEFAULT_UNROLL_N  4\n\n#define DGEMM_DEFAULT_UNROLL_M  8\n#define DGEMM_DEFAULT_UNROLL_N  4\n\n#define CGEMM_DEFAULT_UNROLL_M  8\n#define CGEMM_DEFAULT_UNROLL_N  4\n\n#define ZGEMM_DEFAULT_UNROLL_M  4\n#define ZGEMM_DEFAULT_UNROLL_N  4\n\n#define SGEMM_DEFAULT_P\t128\n#define DGEMM_DEFAULT_P\t160\n#define CGEMM_DEFAULT_P 128\n#define ZGEMM_DEFAULT_P 128\n\n#define SGEMM_DEFAULT_Q 352\n#define DGEMM_DEFAULT_Q 128\n#define CGEMM_DEFAULT_Q 224\n#define ZGEMM_DEFAULT_Q 112\n\n#define SGEMM_DEFAULT_R 4096\n#define DGEMM_DEFAULT_R 4096\n#define CGEMM_DEFAULT_R 4096\n#define ZGEMM_DEFAULT_R 4096\n\n#elif defined(THUNDERX3T110)\n\n#define SGEMM_DEFAULT_UNROLL_M  16\n#define SGEMM_DEFAULT_UNROLL_N  4\n\n#define DGEMM_DEFAULT_UNROLL_M  8\n#define DGEMM_DEFAULT_UNROLL_N  4\n\n#define CGEMM_DEFAULT_UNROLL_M  8\n#define CGEMM_DEFAULT_UNROLL_N  4\n\n#define ZGEMM_DEFAULT_UNROLL_M  4\n#define ZGEMM_DEFAULT_UNROLL_N  4\n\n#define SGEMM_DEFAULT_P\t128\n#define DGEMM_DEFAULT_P\t320\n#define CGEMM_DEFAULT_P 128\n#define ZGEMM_DEFAULT_P 128\n\n#define SGEMM_DEFAULT_Q 352\n#define DGEMM_DEFAULT_Q 128\n#define CGEMM_DEFAULT_Q 224\n#define ZGEMM_DEFAULT_Q 112\n\n#define SGEMM_DEFAULT_R 4096\n#define DGEMM_DEFAULT_R 4096\n#define CGEMM_DEFAULT_R 4096\n#define ZGEMM_DEFAULT_R 4096\n\n#elif defined(NEOVERSEN1)\n\n#if defined(XDOUBLE) || defined(DOUBLE)\n#define SWITCH_RATIO            8\n#else\n#define SWITCH_RATIO            16\n#endif\n\n#define SGEMM_DEFAULT_UNROLL_M  16\n#define SGEMM_DEFAULT_UNROLL_N  4\n\n#define DGEMM_DEFAULT_UNROLL_M  8\n#define DGEMM_DEFAULT_UNROLL_N  4\n\n#define CGEMM_DEFAULT_UNROLL_M  8\n#define CGEMM_DEFAULT_UNROLL_N  4\n\n#define ZGEMM_DEFAULT_UNROLL_M  4\n#define ZGEMM_DEFAULT_UNROLL_N  4\n\n#define SGEMM_DEFAULT_P\t240\n#define DGEMM_DEFAULT_P\t240\n#define CGEMM_DEFAULT_P 128\n#define ZGEMM_DEFAULT_P 128\n\n#define SGEMM_DEFAULT_Q 640\n#define DGEMM_DEFAULT_Q 320\n#define CGEMM_DEFAULT_Q 224\n#define ZGEMM_DEFAULT_Q 112\n\n#define SGEMM_DEFAULT_R 4096\n#define DGEMM_DEFAULT_R 4096\n#define CGEMM_DEFAULT_R 4096\n#define ZGEMM_DEFAULT_R 4096\n\n#elif defined(NEOVERSEV1) // 256-bit SVE\n\n#if defined(XDOUBLE) || defined(DOUBLE)\n#define SWITCH_RATIO            8\n#define GEMM_PREFERED_SIZE      4\n#else\n#define SWITCH_RATIO            16\n#define GEMM_PREFERED_SIZE      8\n#endif\n\n#define SGEMM_DEFAULT_UNROLL_M  16\n#define SGEMM_DEFAULT_UNROLL_N  8\n\n#define DGEMM_DEFAULT_UNROLL_M  4 // Actually 2VL (8) but kept separate to keep copies separate\n#define DGEMM_DEFAULT_UNROLL_N  8\n\n#define CGEMM_DEFAULT_UNROLL_M  2\n#define CGEMM_DEFAULT_UNROLL_N  4\n#define CGEMM_DEFAULT_UNROLL_MN 16\n\n#define ZGEMM_DEFAULT_UNROLL_M  2\n#define ZGEMM_DEFAULT_UNROLL_N  4\n#define ZGEMM_DEFAULT_UNROLL_MN 16\n\n#define SGEMM_DEFAULT_P 240\n#define DGEMM_DEFAULT_P 240\n#define CGEMM_DEFAULT_P 128\n#define ZGEMM_DEFAULT_P 128\n\n#define SGEMM_DEFAULT_Q 640\n#define DGEMM_DEFAULT_Q 320\n#define CGEMM_DEFAULT_Q 224\n#define ZGEMM_DEFAULT_Q 112\n\n#define SGEMM_DEFAULT_R 4096\n#define DGEMM_DEFAULT_R 4096\n#define CGEMM_DEFAULT_R 4096\n#define ZGEMM_DEFAULT_R 4096\n\n#elif defined(NEOVERSEN2)\n\n#if defined(XDOUBLE) || defined(DOUBLE)\n#define SWITCH_RATIO            8\n#else\n#define SWITCH_RATIO            16\n#endif\n\n#undef SBGEMM_ALIGN_K\n#define SBGEMM_ALIGN_K 4\n\n#undef SBGEMM_DEFAULT_UNROLL_M\n#undef SBGEMM_DEFAULT_UNROLL_N\n#define SBGEMM_DEFAULT_UNROLL_M 8\n#define SBGEMM_DEFAULT_UNROLL_N 4\n\n#define SGEMM_DEFAULT_UNROLL_M  16\n#define SGEMM_DEFAULT_UNROLL_N  4\n\n#define DGEMM_DEFAULT_UNROLL_M  8\n#define DGEMM_DEFAULT_UNROLL_N  4\n\n#define CGEMM_DEFAULT_UNROLL_M  8\n#define CGEMM_DEFAULT_UNROLL_N  4\n\n#define ZGEMM_DEFAULT_UNROLL_M  4\n#define ZGEMM_DEFAULT_UNROLL_N  4\n\n#define SGEMM_DEFAULT_P 128\n#define DGEMM_DEFAULT_P 160\n#define CGEMM_DEFAULT_P 128\n#define ZGEMM_DEFAULT_P 128\n\n#define SGEMM_DEFAULT_Q 352\n#define DGEMM_DEFAULT_Q 128\n#define CGEMM_DEFAULT_Q 224\n#define ZGEMM_DEFAULT_Q 112\n\n#define SGEMM_DEFAULT_R 4096\n#define DGEMM_DEFAULT_R 4096\n#define CGEMM_DEFAULT_R 4096\n#define ZGEMM_DEFAULT_R 4096\n\n#elif defined(A64FX) // 512-bit SVE\n\n/* When all BLAS3 routines are implemeted with SVE, SGEMM_DEFAULT_UNROLL_M should be \"sve_vl\".\nUntil then, just keep it different than DGEMM_DEFAULT_UNROLL_N to keep copy routines in both directions seperated. */\n#define SGEMM_DEFAULT_UNROLL_M  4\n#define SGEMM_DEFAULT_UNROLL_N  8\n/* SGEMM_UNROLL_MN is calculated as max(SGEMM_UNROLL_M, SGEMM_UNROLL_N)\n * Since we don't define SGEMM_UNROLL_M correctly we have to manually set this macro.\n * If SVE size is ever more than 1024, this should be increased also. */\n#define SGEMM_DEFAULT_UNROLL_MN  32\n\n/* When all BLAS3 routines are implemeted with SVE, DGEMM_DEFAULT_UNROLL_M should be \"sve_vl\".\nUntil then, just keep it different than DGEMM_DEFAULT_UNROLL_N to keep copy routines in both directions seperated. */\n#define DGEMM_DEFAULT_UNROLL_M  2 \n#define DGEMM_DEFAULT_UNROLL_N  8\n\n#define DGEMM_DEFAULT_UNROLL_MN  32\n\n#define CGEMM_DEFAULT_UNROLL_M  2\n#define CGEMM_DEFAULT_UNROLL_N  4\n#define CGEMM_DEFAULT_UNROLL_MN  16\n\n#define ZGEMM_DEFAULT_UNROLL_M  2\n#define ZGEMM_DEFAULT_UNROLL_N  4\n#define ZGEMM_DEFAULT_UNROLL_MN  16\n\n#define SGEMM_DEFAULT_P\t128\n#define DGEMM_DEFAULT_P\t160\n#define CGEMM_DEFAULT_P 128\n#define ZGEMM_DEFAULT_P 128\n\n#define SGEMM_DEFAULT_Q 352\n#define DGEMM_DEFAULT_Q 128\n#define CGEMM_DEFAULT_Q 224\n#define ZGEMM_DEFAULT_Q 112\n\n#define SGEMM_DEFAULT_R 4096\n#define DGEMM_DEFAULT_R 4096\n#define CGEMM_DEFAULT_R 4096\n#define ZGEMM_DEFAULT_R 4096\n\n#elif defined(ARMV8SVE) || defined(ARMV9) || defined(CORTEXA510)|| defined(CORTEXA710) || defined(CORTEXX2) // 128-bit SVE\n\n#if defined(XDOUBLE) || defined(DOUBLE)\n#define SWITCH_RATIO            8\n#else\n#define SWITCH_RATIO            16\n#endif\n\n#define SGEMM_DEFAULT_UNROLL_M  4 // Actually 1VL (8) but kept seperate to keep copies seperate\n#define SGEMM_DEFAULT_UNROLL_N  8\n\n#define DGEMM_DEFAULT_UNROLL_M  4\n#define DGEMM_DEFAULT_UNROLL_N  8\n\n#define CGEMM_DEFAULT_UNROLL_M  2\n#define CGEMM_DEFAULT_UNROLL_N  4\n#define CGEMM_DEFAULT_UNROLL_MN  16\n\n#define ZGEMM_DEFAULT_UNROLL_M  2\n#define ZGEMM_DEFAULT_UNROLL_N  4\n#define ZGEMM_DEFAULT_UNROLL_MN  16\n\n#define SGEMM_DEFAULT_P 128\n#define DGEMM_DEFAULT_P 160\n#define CGEMM_DEFAULT_P 128\n#define ZGEMM_DEFAULT_P 128\n\n#define SGEMM_DEFAULT_Q 352\n#define DGEMM_DEFAULT_Q 128\n#define CGEMM_DEFAULT_Q 224\n#define ZGEMM_DEFAULT_Q 112\n\n#define SGEMM_DEFAULT_R 4096\n#define DGEMM_DEFAULT_R 4096\n#define CGEMM_DEFAULT_R 4096\n#define ZGEMM_DEFAULT_R 4096\n\n#else /* Other/undetected ARMv8 cores */\n\n#define SGEMM_DEFAULT_UNROLL_M  16\n#define SGEMM_DEFAULT_UNROLL_N  4\n\n#define DGEMM_DEFAULT_UNROLL_M  8\n#define DGEMM_DEFAULT_UNROLL_N  4\n\n#define CGEMM_DEFAULT_UNROLL_M  8\n#define CGEMM_DEFAULT_UNROLL_N  4\n\n#define ZGEMM_DEFAULT_UNROLL_M  4\n#define ZGEMM_DEFAULT_UNROLL_N  4\n\n#define SGEMM_DEFAULT_P\t128\n#define DGEMM_DEFAULT_P\t160\n#define CGEMM_DEFAULT_P 128\n#define ZGEMM_DEFAULT_P 128\n\n#define SGEMM_DEFAULT_Q 352\n#define DGEMM_DEFAULT_Q 128\n#define CGEMM_DEFAULT_Q 224\n#define ZGEMM_DEFAULT_Q 112\n\n#define SGEMM_DEFAULT_R 4096\n#define DGEMM_DEFAULT_R 4096\n#define CGEMM_DEFAULT_R 4096\n#define ZGEMM_DEFAULT_R 4096\n\n#endif /* Cores */\n\n\n#endif /* ARMv8 */\n\n#if defined(ARMV5)\n#define SNUMOPT\t\t2\n#define DNUMOPT\t\t2\n\n#define GEMM_DEFAULT_OFFSET_A 0\n#define GEMM_DEFAULT_OFFSET_B 0\n#define GEMM_DEFAULT_ALIGN (BLASLONG)0x03fffUL\n\n#define SGEMM_DEFAULT_UNROLL_M  2\n#define SGEMM_DEFAULT_UNROLL_N  2\n\n#define DGEMM_DEFAULT_UNROLL_M  2\n#define DGEMM_DEFAULT_UNROLL_N  2\n\n#define CGEMM_DEFAULT_UNROLL_M  2\n#define CGEMM_DEFAULT_UNROLL_N  2\n\n#define ZGEMM_DEFAULT_UNROLL_M  2\n#define ZGEMM_DEFAULT_UNROLL_N  2\n\n#define SGEMM_DEFAULT_P\t128\n#define DGEMM_DEFAULT_P\t128\n#define CGEMM_DEFAULT_P 96\n#define ZGEMM_DEFAULT_P 64\n\n#define SGEMM_DEFAULT_Q 240\n#define DGEMM_DEFAULT_Q 120\n#define CGEMM_DEFAULT_Q 120\n#define ZGEMM_DEFAULT_Q 120\n\n#define SGEMM_DEFAULT_R 12288\n#define DGEMM_DEFAULT_R 8192\n#define CGEMM_DEFAULT_R 4096\n#define ZGEMM_DEFAULT_R 4096\n\n\n#define SYMV_P\t16\n#endif\n\n\n\n#ifdef CORTEXA9\n#define SNUMOPT\t\t2\n#define DNUMOPT\t\t2\n\n#define GEMM_DEFAULT_OFFSET_A 0\n#define GEMM_DEFAULT_OFFSET_B 0\n#define GEMM_DEFAULT_ALIGN (BLASLONG)0x03fffUL\n\n#define SGEMM_DEFAULT_UNROLL_M  4\n#define SGEMM_DEFAULT_UNROLL_N  4\n\n#define DGEMM_DEFAULT_UNROLL_M  4\n#define DGEMM_DEFAULT_UNROLL_N  4\n\n#define CGEMM_DEFAULT_UNROLL_M  2\n#define CGEMM_DEFAULT_UNROLL_N  2\n\n#define ZGEMM_DEFAULT_UNROLL_M  2\n#define ZGEMM_DEFAULT_UNROLL_N  2\n\n#define SGEMM_DEFAULT_P\t128\n#define DGEMM_DEFAULT_P\t128\n#define CGEMM_DEFAULT_P 96\n#define ZGEMM_DEFAULT_P 64\n\n#define SGEMM_DEFAULT_Q 240\n#define DGEMM_DEFAULT_Q 120\n#define CGEMM_DEFAULT_Q 120\n#define ZGEMM_DEFAULT_Q 120\n\n#define SGEMM_DEFAULT_R 12288\n#define DGEMM_DEFAULT_R 8192\n#define CGEMM_DEFAULT_R 4096\n#define ZGEMM_DEFAULT_R 4096\n\n\n\n#define SYMV_P\t16\n#endif\n\n\n#ifdef CORTEXA15\n#define SNUMOPT\t\t2\n#define DNUMOPT\t\t2\n\n#define GEMM_DEFAULT_OFFSET_A 0\n#define GEMM_DEFAULT_OFFSET_B 0\n#define GEMM_DEFAULT_ALIGN (BLASLONG)0x03fffUL\n\n#define SGEMM_DEFAULT_UNROLL_M  4\n#define SGEMM_DEFAULT_UNROLL_N  4\n\n#define DGEMM_DEFAULT_UNROLL_M  4\n#define DGEMM_DEFAULT_UNROLL_N  4\n\n#define CGEMM_DEFAULT_UNROLL_M  2\n#define CGEMM_DEFAULT_UNROLL_N  2\n\n#define ZGEMM_DEFAULT_UNROLL_M  2\n#define ZGEMM_DEFAULT_UNROLL_N  2\n\n#define SGEMM_DEFAULT_P\t128\n#define DGEMM_DEFAULT_P\t128\n#define CGEMM_DEFAULT_P 96\n#define ZGEMM_DEFAULT_P 64\n\n#define SGEMM_DEFAULT_Q 240\n#define DGEMM_DEFAULT_Q 120\n#define CGEMM_DEFAULT_Q 120\n#define ZGEMM_DEFAULT_Q 120\n\n#define SGEMM_DEFAULT_R 12288\n#define DGEMM_DEFAULT_R 8192\n#define CGEMM_DEFAULT_R 4096\n#define ZGEMM_DEFAULT_R 4096\n\n\n\n#define SYMV_P\t16\n#endif\n\n\n#if defined(ZARCH_GENERIC)\n#define SNUMOPT\t\t2\n#define DNUMOPT\t\t2\n\n#define GEMM_DEFAULT_OFFSET_A 0\n#define GEMM_DEFAULT_OFFSET_B 0\n#define GEMM_DEFAULT_ALIGN (BLASLONG)0x03fffUL\n\n#define SGEMM_DEFAULT_UNROLL_M  2\n#define SGEMM_DEFAULT_UNROLL_N  2\n\n#define DGEMM_DEFAULT_UNROLL_M  2\n#define DGEMM_DEFAULT_UNROLL_N  2\n\n#define CGEMM_DEFAULT_UNROLL_M  2\n#define CGEMM_DEFAULT_UNROLL_N  2\n\n#define ZGEMM_DEFAULT_UNROLL_M  2\n#define ZGEMM_DEFAULT_UNROLL_N  2\n\n#define SGEMM_DEFAULT_P\t128\n#define DGEMM_DEFAULT_P\t128\n#define CGEMM_DEFAULT_P 96\n#define ZGEMM_DEFAULT_P 64\n\n#define SGEMM_DEFAULT_Q 240\n#define DGEMM_DEFAULT_Q 120\n#define CGEMM_DEFAULT_Q 120\n#define ZGEMM_DEFAULT_Q 120\n\n#define SGEMM_DEFAULT_R 12288\n#define DGEMM_DEFAULT_R 8192\n#define CGEMM_DEFAULT_R 4096\n#define ZGEMM_DEFAULT_R 4096\n\n\n#define SYMV_P\t16\n#endif\n\n#if defined(Z13)\n#define SNUMOPT\t\t2\n#define DNUMOPT\t\t2\n\n#define GEMM_DEFAULT_OFFSET_A 0\n#define GEMM_DEFAULT_OFFSET_B 0\n#define GEMM_DEFAULT_ALIGN (BLASLONG)0x03fffUL\n\n#define SGEMM_DEFAULT_UNROLL_M  8\n#define SGEMM_DEFAULT_UNROLL_N  4\n\n#define DGEMM_DEFAULT_UNROLL_M  8\n#define DGEMM_DEFAULT_UNROLL_N  4\n\n#define CGEMM_DEFAULT_UNROLL_M  4\n#define CGEMM_DEFAULT_UNROLL_N  4\n\n#define ZGEMM_DEFAULT_UNROLL_M  4\n#define ZGEMM_DEFAULT_UNROLL_N  4\n\n#define SGEMM_DEFAULT_P\t456\n#define DGEMM_DEFAULT_P\t320\n#define CGEMM_DEFAULT_P 480\n#define ZGEMM_DEFAULT_P 224\n\n#define SGEMM_DEFAULT_Q 488\n#define DGEMM_DEFAULT_Q 384\n#define CGEMM_DEFAULT_Q 128\n#define ZGEMM_DEFAULT_Q 352\n\n#define SGEMM_DEFAULT_R 8192\n#define DGEMM_DEFAULT_R 4096\n#define CGEMM_DEFAULT_R 4096\n#define ZGEMM_DEFAULT_R 2048\n\n\n#define SYMV_P\t16\n#endif\n\n\n#if defined(Z14)\n#define SNUMOPT\t\t2\n#define DNUMOPT\t\t2\n\n#define GEMM_DEFAULT_OFFSET_A 0\n#define GEMM_DEFAULT_OFFSET_B 0\n#define GEMM_DEFAULT_ALIGN 0x03fffUL\n\n#define SGEMM_DEFAULT_UNROLL_M  16\n#define SGEMM_DEFAULT_UNROLL_N  4\n\n#define DGEMM_DEFAULT_UNROLL_M  8\n#define DGEMM_DEFAULT_UNROLL_N  4\n\n#define CGEMM_DEFAULT_UNROLL_M  4\n#define CGEMM_DEFAULT_UNROLL_N  4\n\n#define ZGEMM_DEFAULT_UNROLL_M  4\n#define ZGEMM_DEFAULT_UNROLL_N  4\n\n#define SGEMM_DEFAULT_P\t480\n#define DGEMM_DEFAULT_P\t320\n#define CGEMM_DEFAULT_P 480\n#define ZGEMM_DEFAULT_P 224\n\n#define SGEMM_DEFAULT_Q 512\n#define DGEMM_DEFAULT_Q 384\n#define CGEMM_DEFAULT_Q 128\n#define ZGEMM_DEFAULT_Q 352\n\n#define SGEMM_DEFAULT_R 8192\n#define DGEMM_DEFAULT_R 4096\n#define CGEMM_DEFAULT_R 4096\n#define ZGEMM_DEFAULT_R 2048\n\n\n#define SYMV_P\t16\n#endif\n\n#if defined(CSKY) || defined(CK860FV)\n#define GEMM_DEFAULT_OFFSET_A 0\n#define GEMM_DEFAULT_OFFSET_B 0\n#define GEMM_DEFAULT_ALIGN (BLASLONG)0x03fffUL\n\n#define SGEMM_DEFAULT_UNROLL_M  2\n#define SGEMM_DEFAULT_UNROLL_N  2\n\n#define DGEMM_DEFAULT_UNROLL_M  2\n#define DGEMM_DEFAULT_UNROLL_N  2\n\n#define CGEMM_DEFAULT_UNROLL_M  2\n#define CGEMM_DEFAULT_UNROLL_N  2\n\n#define ZGEMM_DEFAULT_UNROLL_M  2\n#define ZGEMM_DEFAULT_UNROLL_N  2\n\n#define SGEMM_DEFAULT_P\t128\n#define DGEMM_DEFAULT_P\t128\n#define CGEMM_DEFAULT_P 96\n#define ZGEMM_DEFAULT_P 64\n\n#define SGEMM_DEFAULT_Q 240\n#define DGEMM_DEFAULT_Q 120\n#define CGEMM_DEFAULT_Q 120\n#define ZGEMM_DEFAULT_Q 120\n\n#define SGEMM_DEFAULT_R 12288\n#define DGEMM_DEFAULT_R 8192\n#define CGEMM_DEFAULT_R 4096\n#define ZGEMM_DEFAULT_R 4096\n\n#define SYMV_P\t16\n\n#define GEMM_DEFAULT_OFFSET_A 0\n#define GEMM_DEFAULT_OFFSET_B 0\n\n#endif\n\n#ifdef GENERIC\n\n#define SNUMOPT\t\t2\n#define DNUMOPT\t\t2\n\n#define GEMM_DEFAULT_OFFSET_A 0\n#define GEMM_DEFAULT_OFFSET_B 0\n#define GEMM_DEFAULT_ALIGN (BLASLONG)0x0ffffUL\n\n#define SGEMM_DEFAULT_UNROLL_N 2\n#define DGEMM_DEFAULT_UNROLL_N 2\n#define QGEMM_DEFAULT_UNROLL_N 2\n#define CGEMM_DEFAULT_UNROLL_N 2\n#define ZGEMM_DEFAULT_UNROLL_N 2\n#define XGEMM_DEFAULT_UNROLL_N 1\n#define CGEMM3M_DEFAULT_UNROLL_N 2\n#define ZGEMM3M_DEFAULT_UNROLL_N 2\n\n#ifdef ARCH_X86\n#define SGEMM_DEFAULT_UNROLL_M 2\n#define DGEMM_DEFAULT_UNROLL_M 2\n#define QGEMM_DEFAULT_UNROLL_M 2\n#define CGEMM_DEFAULT_UNROLL_M 2\n#define ZGEMM_DEFAULT_UNROLL_M 2\n#define XGEMM_DEFAULT_UNROLL_M 1\n#else\n#define SGEMM_DEFAULT_UNROLL_M 2\n#define DGEMM_DEFAULT_UNROLL_M 2\n#define QGEMM_DEFAULT_UNROLL_M 2\n#define CGEMM_DEFAULT_UNROLL_M 2\n#define ZGEMM_DEFAULT_UNROLL_M 2\n#define XGEMM_DEFAULT_UNROLL_M 1\n#define CGEMM3M_DEFAULT_UNROLL_M 2\n#define ZGEMM3M_DEFAULT_UNROLL_M 2\n#define CGEMM3M_DEFAULT_P 448\n#define ZGEMM3M_DEFAULT_P 224\n#define XGEMM3M_DEFAULT_P 112\n#define CGEMM3M_DEFAULT_Q 224\n#define ZGEMM3M_DEFAULT_Q 224\n#define XGEMM3M_DEFAULT_Q 224\n#define CGEMM3M_DEFAULT_R 12288\n#define ZGEMM3M_DEFAULT_R 12288\n#define XGEMM3M_DEFAULT_R 12288\n\n#endif\n\n#ifdef ARCH_MIPS\n#define SGEMM_DEFAULT_P  128\n#define DGEMM_DEFAULT_P  128\n#define CGEMM_DEFAULT_P  96\n#define ZGEMM_DEFAULT_P  64\n#define SGEMM_DEFAULT_Q  240\n#define DGEMM_DEFAULT_Q  120\n#define CGEMM_DEFAULT_Q  120\n#define ZGEMM_DEFAULT_Q  120\n#define SGEMM_DEFAULT_R  12288\n#define DGEMM_DEFAULT_R  8192\n#define CGEMM_DEFAULT_R  4096\n#define ZGEMM_DEFAULT_R  4096\n#elif defined(ARCH_LOONGARCH64)\n#define SGEMM_DEFAULT_P 128\n#define DGEMM_DEFAULT_P 128\n#define CGEMM_DEFAULT_P 96\n#define ZGEMM_DEFAULT_P 64\n\n#define SGEMM_DEFAULT_Q 240\n#define DGEMM_DEFAULT_Q 120\n#define CGEMM_DEFAULT_Q 120\n#define ZGEMM_DEFAULT_Q 120\n\n#define SGEMM_DEFAULT_R 12288\n#define DGEMM_DEFAULT_R 8192\n#define CGEMM_DEFAULT_R 4096\n#define ZGEMM_DEFAULT_R 4096\n#else\n#define SGEMM_DEFAULT_P sgemm_p\n#define DGEMM_DEFAULT_P dgemm_p\n#define QGEMM_DEFAULT_P qgemm_p\n#define CGEMM_DEFAULT_P cgemm_p\n#define ZGEMM_DEFAULT_P zgemm_p\n#define XGEMM_DEFAULT_P xgemm_p\n\n#define SGEMM_DEFAULT_R sgemm_r\n#define DGEMM_DEFAULT_R dgemm_r\n#define QGEMM_DEFAULT_R qgemm_r\n#define CGEMM_DEFAULT_R cgemm_r\n#define ZGEMM_DEFAULT_R zgemm_r\n#define XGEMM_DEFAULT_R xgemm_r\n\n#define SGEMM_DEFAULT_Q 128\n#define DGEMM_DEFAULT_Q 128\n#define QGEMM_DEFAULT_Q 128\n#define CGEMM_DEFAULT_Q 128\n#define ZGEMM_DEFAULT_Q 128\n#define XGEMM_DEFAULT_Q 128\n#endif\n\n#define SYMV_P\t16\n\n#endif\n\n#ifndef SWITCH_RATIO\n#define SWITCH_RATIO 2\n#endif\n\n#ifndef QGEMM_DEFAULT_UNROLL_M\n#define QGEMM_DEFAULT_UNROLL_M 2\n#endif\n\n#ifndef QGEMM_DEFAULT_UNROLL_N\n#define QGEMM_DEFAULT_UNROLL_N 2\n#endif\n\n#ifndef XGEMM_DEFAULT_UNROLL_M\n#define XGEMM_DEFAULT_UNROLL_M 2\n#endif\n\n#ifndef XGEMM_DEFAULT_UNROLL_N\n#define XGEMM_DEFAULT_UNROLL_N 2\n#endif\n\n#ifndef HAVE_SSE2\n#define SHUFPD_0\tshufps\t$0x44,\n#define SHUFPD_1\tshufps\t$0x4e,\n#define SHUFPD_2\tshufps\t$0xe4,\n#define SHUFPD_3\tshufps\t$0xee,\n#endif\n\n#ifndef SHUFPD_0\n#define SHUFPD_0\tshufpd\t$0,\n#endif\n\n#ifndef SHUFPD_1\n#define SHUFPD_1\tshufpd\t$1,\n#endif\n\n#ifndef SHUFPD_2\n#define SHUFPD_2\tshufpd\t$2,\n#endif\n\n#ifndef SHUFPD_3\n#define SHUFPD_3\tshufpd\t$3,\n#endif\n\n#ifndef SHUFPS_39\n#define SHUFPS_39\tshufps\t$0x39,\n#endif\n\n\n#endif\n"
        },
        {
          "name": "quickbuild.32bit",
          "type": "blob",
          "size": 0.0322265625,
          "content": "#!/bin/bash\n\nmake -j 2 BINARY=32\n"
        },
        {
          "name": "quickbuild.64bit",
          "type": "blob",
          "size": 0.02734375,
          "content": "#!/bin/bash\n\nmake BINARY=64\n"
        },
        {
          "name": "quickbuild.win32",
          "type": "blob",
          "size": 0.1513671875,
          "content": "#!/bin/bash\n\necho \" Please read https://github.com/xianyi/OpenBLAS/wiki/How-to-use-OpenBLAS-in-Microsoft-Visual-Studio \"\nmake BINARY=32 CC=gcc FC=gfortran\n"
        },
        {
          "name": "quickbuild.win64",
          "type": "blob",
          "size": 0.1513671875,
          "content": "#!/bin/bash\n\necho \" Please read https://github.com/xianyi/OpenBLAS/wiki/How-to-use-OpenBLAS-in-Microsoft-Visual-Studio \"\nmake BINARY=64 CC=gcc FC=gfortran\n"
        },
        {
          "name": "reference",
          "type": "tree",
          "content": null
        },
        {
          "name": "relapack",
          "type": "tree",
          "content": null
        },
        {
          "name": "segfaults.patch",
          "type": "blob",
          "size": 0.3779296875,
          "content": "diff -ruN common_linux.h.orig common_linux.h\n--- common_linux.h.orig\t2012-04-23 11:27:55.000000000 +0800\n+++ common_linux.h\t2012-05-08 23:43:00.000000000 +0800\n@@ -77,7 +77,7 @@\n #else\n //Fixed randomly SEGFAULT when nodemask==NULL with above Linux 2.6.34\n //\tunsigned long null_nodemask=0;\n-\treturn syscall(SYS_mbind, addr, len, mode, nodemask, maxnode, flags);\n+\treturn 0;\n #endif\n }\n\n"
        },
        {
          "name": "symcopy.h",
          "type": "blob",
          "size": 29.4580078125,
          "content": "/*********************************************************************/\n/* Copyright 2009, 2010 The University of Texas at Austin.           */\n/* All rights reserved.                                              */\n/*                                                                   */\n/* Redistribution and use in source and binary forms, with or        */\n/* without modification, are permitted provided that the following   */\n/* conditions are met:                                               */\n/*                                                                   */\n/*   1. Redistributions of source code must retain the above         */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer.                                                  */\n/*                                                                   */\n/*   2. Redistributions in binary form must reproduce the above      */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer in the documentation and/or other materials       */\n/*      provided with the distribution.                              */\n/*                                                                   */\n/*    THIS  SOFTWARE IS PROVIDED  BY THE  UNIVERSITY OF  TEXAS AT    */\n/*    AUSTIN  ``AS IS''  AND ANY  EXPRESS OR  IMPLIED WARRANTIES,    */\n/*    INCLUDING, BUT  NOT LIMITED  TO, THE IMPLIED  WARRANTIES OF    */\n/*    MERCHANTABILITY  AND FITNESS FOR  A PARTICULAR  PURPOSE ARE    */\n/*    DISCLAIMED.  IN  NO EVENT SHALL THE UNIVERSITY  OF TEXAS AT    */\n/*    AUSTIN OR CONTRIBUTORS BE  LIABLE FOR ANY DIRECT, INDIRECT,    */\n/*    INCIDENTAL,  SPECIAL, EXEMPLARY,  OR  CONSEQUENTIAL DAMAGES    */\n/*    (INCLUDING, BUT  NOT LIMITED TO,  PROCUREMENT OF SUBSTITUTE    */\n/*    GOODS  OR  SERVICES; LOSS  OF  USE,  DATA,  OR PROFITS;  OR    */\n/*    BUSINESS INTERRUPTION) HOWEVER CAUSED  AND ON ANY THEORY OF    */\n/*    LIABILITY, WHETHER  IN CONTRACT, STRICT  LIABILITY, OR TORT    */\n/*    (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY WAY OUT    */\n/*    OF  THE  USE OF  THIS  SOFTWARE,  EVEN  IF ADVISED  OF  THE    */\n/*    POSSIBILITY OF SUCH DAMAGE.                                    */\n/*                                                                   */\n/* The views and conclusions contained in the software and           */\n/* documentation are those of the authors and should not be          */\n/* interpreted as representing official policies, either expressed   */\n/* or implied, of The University of Texas at Austin.                 */\n/*********************************************************************/\n\n/* This implementation is completely wrong. I'll rewrite this */\n\n#ifndef SYMCOPY_H\n#define SYMCOPY_H\n\n#if !defined(XDOUBLE) || !defined(QUAD_PRECISION)\n\nstatic __inline void SYMCOPY_L(BLASLONG m, FLOAT *a, BLASLONG lda, FLOAT *b){\n  BLASLONG is, js;\n\n  FLOAT *aa1, *aa2;\n  FLOAT *b1, *b2;\n  FLOAT *bb1, *bb2;\n  FLOAT *cc1, *cc2;\n  FLOAT a11, a12;\n  FLOAT a21, a22;\n\n  b1 = b;\n  b2 = b;\n\n  for (js = 0; js < m; js += 2){\n\n    aa1 = a + 0 * lda;\n    aa2 = a + 1 * lda;\n    a  += 2 * lda + 2;\n\n    bb1 = b1 + 0 * m;\n    bb2 = b1 + 1 * m;\n    b1 += 2 * m + 2;\n\n    cc1 = b2 + 0 * m;\n    cc2 = b2 + 1 * m;\n    b2 += 2 * m + 2;\n\n    if (m - js >= 2){\n\n      a11 = *(aa1 + 0);\n      a21 = *(aa1 + 1);\n\n      a22 = *(aa2 + 1);\n\n      *(bb1 + 0) = a11;\n      *(bb1 + 1) = a21;\n      *(bb2 + 0) = a21;\n      *(bb2 + 1) = a22;\n      aa1 += 2;\n      aa2 += 2;\n      bb1 += 2;\n      bb2 += 2;\n\n      cc1 += 2 * m;\n      cc2 += 2 * m;\n\n      is = ((m - js - 2) >> 1);\n\n      while (is > 0){\n\ta11 = *(aa1 + 0);\n\ta21 = *(aa1 + 1);\n\ta12 = *(aa2 + 0);\n\ta22 = *(aa2 + 1);\n\n\taa1 += 2;\n\taa2 += 2;\n\n\t*(bb1 + 0) = a11;\n\t*(bb1 + 1) = a21;\n\t*(bb2 + 0) = a12;\n\t*(bb2 + 1) = a22;\n\n\t*(cc1 + 0) = a11;\n\t*(cc1 + 1) = a12;\n\t*(cc2 + 0) = a21;\n\t*(cc2 + 1) = a22;\n\n\tbb1 += 2;\n\tbb2 += 2;\n\n\tcc1 += 2 * m;\n\tcc2 += 2 * m;\n\n\tis --;\n      }\n\n      is = ((m - js - 2) & 1);\n\n      if (is == 1){\n\ta11 = *(aa1 + 0);\n\ta12 = *(aa2 + 0);\n\n\t*(bb1 + 0) = a11;\n\t*(bb2 + 0) = a12;\n\n\t*(cc1 + 0) = a11;\n\t*(cc1 + 1) = a12;\n      }\n    }\n\n    if (m - js == 1){\n      a11 = *(aa1 + 0);\n      *(bb1 + 0) = a11;\n    }\n\n  }\n}\n\nstatic __inline void SYMCOPY_U(BLASLONG m, FLOAT *a, BLASLONG lda, FLOAT *b){\n  BLASLONG is, js;\n\n  FLOAT *aa1, *aa2;\n  FLOAT *b1, *b2;\n  FLOAT *bb1, *bb2;\n  FLOAT *cc1, *cc2;\n  FLOAT a11, a12;\n  FLOAT a21, a22;\n\n  b1 = b;\n  b2 = b;\n\n  for (js = 0; js < m; js += 2){\n\n    aa1 = a + 0 * lda;\n    aa2 = a + 1 * lda;\n    a  += 2 * lda;\n\n    bb1 = b1 + 0 * m;\n    bb2 = b1 + 1 * m;\n    b1 += 2 * m;\n\n    cc1 = b2 + 0 * m;\n    cc2 = b2 + 1 * m;\n    b2 += 2;\n\n    if (m - js >= 2){\n\n      for (is = 0; is < js; is += 2){\n\n\ta11 = *(aa1 + 0);\n\ta21 = *(aa1 + 1);\n\ta12 = *(aa2 + 0);\n\ta22 = *(aa2 + 1);\n\n\taa1 += 2;\n\taa2 += 2;\n\n\t*(bb1 + 0) = a11;\n\t*(bb1 + 1) = a21;\n\t*(bb2 + 0) = a12;\n\t*(bb2 + 1) = a22;\n\n\t*(cc1 + 0) = a11;\n\t*(cc1 + 1) = a12;\n\t*(cc2 + 0) = a21;\n\t*(cc2 + 1) = a22;\n\n\tbb1 += 2;\n\tbb2 += 2;\n\n\tcc1 += 2 * m;\n\tcc2 += 2 * m;\n      }\n\n      a11 = *(aa1 + 0);\n\n      a12 = *(aa2 + 0);\n      a22 = *(aa2 + 1);\n\n      *(bb1 + 0) = a11;\n      *(bb1 + 1) = a12;\n      *(bb2 + 0) = a12;\n      *(bb2 + 1) = a22;\n    }\n\n    if (m - js == 1){\n      for (is = 0; is < js; is += 2){\n\n\ta11 = *(aa1 + 0);\n\ta21 = *(aa1 + 1);\n\taa1 += 2;\n\n\t*(bb1 + 0) = a11;\n\t*(bb1 + 1) = a21;\n\t*(cc1 + 0) = a11;\n\t*(cc2 + 0) = a21;\n\tbb1 += 2;\n\n\tcc1 += 2 * m;\n\tcc2 += 2 * m;\n      }\n\n      a11 = *(aa1 + 0);\n      *(bb1 + 0) = a11;\n    }\n  }\n}\n\n\nstatic __inline void ZSYMCOPY_L(BLASLONG m, FLOAT *a, BLASLONG lda, FLOAT *b){\n  BLASLONG is, js;\n\n  FLOAT *aa1, *aa2;\n  FLOAT *b1, *b2;\n  FLOAT *bb1, *bb2;\n  FLOAT *cc1, *cc2;\n  FLOAT a11, a21, a31, a41;\n  FLOAT a12, a22, a32, a42;\n\n  b1 = b;\n  b2 = b;\n\n  lda *= 2;\n\n  for (js = 0; js < m; js += 2){\n\n    aa1 = a + 0 * lda;\n    aa2 = a + 1 * lda;\n    a  += 2 * lda + 4;\n\n    bb1 = b1 + 0 * m;\n    bb2 = b1 + 2 * m;\n    b1 += 4 * m + 4;\n\n    cc1 = b2 + 0 * m;\n    cc2 = b2 + 2 * m;\n    b2 += 4 * m + 4;\n\n    if (m - js >= 2){\n\n      a11 = *(aa1 + 0);\n      a21 = *(aa1 + 1);\n      a31 = *(aa1 + 2);\n      a41 = *(aa1 + 3);\n\n      a12 = *(aa2 + 2);\n      a22 = *(aa2 + 3);\n\n      *(bb1 + 0) = a11;\n      *(bb1 + 1) = a21;\n      *(bb1 + 2) = a31;\n      *(bb1 + 3) = a41;\n\n      *(bb2 + 0) = a31;\n      *(bb2 + 1) = a41;\n      *(bb2 + 2) = a12;\n      *(bb2 + 3) = a22;\n\n      aa1 += 4;\n      aa2 += 4;\n      bb1 += 4;\n      bb2 += 4;\n\n      cc1 += 4 * m;\n      cc2 += 4 * m;\n\n      is = ((m - js - 2) >> 1);\n\n      while (is > 0){\n\ta11 = *(aa1 + 0);\n\ta21 = *(aa1 + 1);\n\ta31 = *(aa1 + 2);\n\ta41 = *(aa1 + 3);\n\n\ta12 = *(aa2 + 0);\n\ta22 = *(aa2 + 1);\n\ta32 = *(aa2 + 2);\n\ta42 = *(aa2 + 3);\n\n\taa1 += 4;\n\taa2 += 4;\n\n\t*(bb1 + 0) = a11;\n\t*(bb1 + 1) = a21;\n\t*(bb1 + 2) = a31;\n\t*(bb1 + 3) = a41;\n\n\t*(bb2 + 0) = a12;\n\t*(bb2 + 1) = a22;\n\t*(bb2 + 2) = a32;\n\t*(bb2 + 3) = a42;\n\n\t*(cc1 + 0) = a11;\n\t*(cc1 + 1) = a21;\n\t*(cc1 + 2) = a12;\n\t*(cc1 + 3) = a22;\n\n\t*(cc2 + 0) = a31;\n\t*(cc2 + 1) = a41;\n\t*(cc2 + 2) = a32;\n\t*(cc2 + 3) = a42;\n\n\tbb1 += 4;\n\tbb2 += 4;\n\n\tcc1 += 4 * m;\n\tcc2 += 4 * m;\n\n\tis --;\n      }\n\n      if (m & 1){\n\ta11 = *(aa1 + 0);\n\ta21 = *(aa1 + 1);\n\ta12 = *(aa2 + 0);\n\ta22 = *(aa2 + 1);\n\n\t*(bb1 + 0) = a11;\n\t*(bb1 + 1) = a21;\n\t*(bb2 + 0) = a12;\n\t*(bb2 + 1) = a22;\n\n\t*(cc1 + 0) = a11;\n\t*(cc1 + 1) = a21;\n\t*(cc1 + 2) = a12;\n\t*(cc1 + 3) = a22;\n      }\n    }\n\n    if (m - js == 1){\n      a11 = *(aa1 + 0);\n      a21 = *(aa1 + 1);\n      *(bb1 + 0) = a11;\n      *(bb1 + 1) = a21;\n    }\n\n  }\n}\n\nstatic __inline void ZSYMCOPY_U(BLASLONG m, FLOAT *a, BLASLONG lda, FLOAT *b){\n  BLASLONG is, js;\n\n  FLOAT *aa1, *aa2;\n  FLOAT *b1, *b2;\n  FLOAT *bb1, *bb2;\n  FLOAT *cc1, *cc2;\n  FLOAT a11, a21, a31, a41;\n  FLOAT a12, a22, a32, a42;\n\n  b1 = b;\n  b2 = b;\n\n  lda *= 2;\n\n  for (js = 0; js < m; js += 2){\n\n    aa1 = a + 0 * lda;\n    aa2 = a + 1 * lda;\n    a  += 2 * lda;\n\n    bb1 = b1 + 0 * m;\n    bb2 = b1 + 2 * m;\n    b1 += 4 * m;\n\n    cc1 = b2 + 0 * m;\n    cc2 = b2 + 2 * m;\n    b2 += 4;\n\n    if (m - js >= 2){\n\n      for (is = 0; is < js; is += 2){\n\n\ta11 = *(aa1 + 0);\n\ta21 = *(aa1 + 1);\n\ta31 = *(aa1 + 2);\n\ta41 = *(aa1 + 3);\n\n\ta12 = *(aa2 + 0);\n\ta22 = *(aa2 + 1);\n\ta32 = *(aa2 + 2);\n\ta42 = *(aa2 + 3);\n\n\taa1 += 4;\n\taa2 += 4;\n\n\t*(bb1 + 0) = a11;\n\t*(bb1 + 1) = a21;\n\t*(bb1 + 2) = a31;\n\t*(bb1 + 3) = a41;\n\n\t*(bb2 + 0) = a12;\n\t*(bb2 + 1) = a22;\n\t*(bb2 + 2) = a32;\n\t*(bb2 + 3) = a42;\n\n\t*(cc1 + 0) = a11;\n\t*(cc1 + 1) = a21;\n\t*(cc1 + 2) = a12;\n\t*(cc1 + 3) = a22;\n\n\t*(cc2 + 0) = a31;\n\t*(cc2 + 1) = a41;\n\t*(cc2 + 2) = a32;\n\t*(cc2 + 3) = a42;\n\n\tbb1 += 4;\n\tbb2 += 4;\n\n\tcc1 += 4 * m;\n\tcc2 += 4 * m;\n      }\n\n      a11 = *(aa1 + 0);\n      a21 = *(aa1 + 1);\n\n      a12 = *(aa2 + 0);\n      a22 = *(aa2 + 1);\n      a32 = *(aa2 + 2);\n      a42 = *(aa2 + 3);\n\n      *(bb1 + 0) = a11;\n      *(bb1 + 1) = a21;\n      *(bb1 + 2) = a12;\n      *(bb1 + 3) = a22;\n\n      *(bb2 + 0) = a12;\n      *(bb2 + 1) = a22;\n      *(bb2 + 2) = a32;\n      *(bb2 + 3) = a42;\n    }\n\n    if (m - js == 1){\n      for (is = 0; is < js; is += 2){\n\n\ta11 = *(aa1 + 0);\n\ta21 = *(aa1 + 1);\n\ta31 = *(aa1 + 2);\n\ta41 = *(aa1 + 3);\n\taa1 += 4;\n\n\t*(bb1 + 0) = a11;\n\t*(bb1 + 1) = a21;\n\t*(bb1 + 2) = a31;\n\t*(bb1 + 3) = a41;\n\n\t*(cc1 + 0) = a11;\n\t*(cc1 + 1) = a21;\n\t*(cc2 + 0) = a31;\n\t*(cc2 + 1) = a41;\n\tbb1 += 4;\n\n\tcc1 += 4 * m;\n\tcc2 += 4 * m;\n      }\n\n      a11 = *(aa1 + 0);\n      a21 = *(aa1 + 1);\n      *(bb1 + 0) = a11;\n      *(bb1 + 1) = a21;\n    }\n  }\n}\n\nstatic __inline void ZHEMCOPY_L(BLASLONG m, FLOAT *a, BLASLONG lda, FLOAT *b){\n  BLASLONG is, js;\n\n  FLOAT *aa1, *aa2;\n  FLOAT *b1, *b2;\n  FLOAT *bb1, *bb2;\n  FLOAT *cc1, *cc2;\n  FLOAT a11, a21, a31, a41;\n  FLOAT a12, a22, a32, a42;\n\n  b1 = b;\n  b2 = b;\n\n  lda *= 2;\n\n  for (js = 0; js < m; js += 2){\n\n    aa1 = a + 0 * lda;\n    aa2 = a + 1 * lda;\n    a  += 2 * lda + 4;\n\n    bb1 = b1 + 0 * m;\n    bb2 = b1 + 2 * m;\n    b1 += 4 * m + 4;\n\n    cc1 = b2 + 0 * m;\n    cc2 = b2 + 2 * m;\n    b2 += 4 * m + 4;\n\n    if (m - js >= 2){\n\n      a11 = *(aa1 + 0);\n      a31 = *(aa1 + 2);\n      a41 = *(aa1 + 3);\n\n      a12 = *(aa2 + 2);\n\n      *(bb1 + 0) = a11;\n      *(bb1 + 1) = 0.;\n      *(bb1 + 2) = a31;\n      *(bb1 + 3) = a41;\n\n      *(bb2 + 0) = a31;\n      *(bb2 + 1) = -a41;\n      *(bb2 + 2) = a12;\n      *(bb2 + 3) = 0.;\n\n      aa1 += 4;\n      aa2 += 4;\n      bb1 += 4;\n      bb2 += 4;\n\n      cc1 += 4 * m;\n      cc2 += 4 * m;\n\n      is = ((m - js - 2) >> 1);\n\n      while (is > 0){\n\ta11 = *(aa1 + 0);\n\ta21 = *(aa1 + 1);\n\ta31 = *(aa1 + 2);\n\ta41 = *(aa1 + 3);\n\n\ta12 = *(aa2 + 0);\n\ta22 = *(aa2 + 1);\n\ta32 = *(aa2 + 2);\n\ta42 = *(aa2 + 3);\n\n\taa1 += 4;\n\taa2 += 4;\n\n\t*(bb1 + 0) = a11;\n\t*(bb1 + 1) = a21;\n\t*(bb1 + 2) = a31;\n\t*(bb1 + 3) = a41;\n\n\t*(bb2 + 0) = a12;\n\t*(bb2 + 1) = a22;\n\t*(bb2 + 2) = a32;\n\t*(bb2 + 3) = a42;\n\n\t*(cc1 + 0) = a11;\n\t*(cc1 + 1) = -a21;\n\t*(cc1 + 2) = a12;\n\t*(cc1 + 3) = -a22;\n\n\t*(cc2 + 0) = a31;\n\t*(cc2 + 1) = -a41;\n\t*(cc2 + 2) = a32;\n\t*(cc2 + 3) = -a42;\n\n\tbb1 += 4;\n\tbb2 += 4;\n\n\tcc1 += 4 * m;\n\tcc2 += 4 * m;\n\n\tis --;\n      }\n\n      if (m & 1){\n\ta11 = *(aa1 + 0);\n\ta21 = *(aa1 + 1);\n\ta12 = *(aa2 + 0);\n\ta22 = *(aa2 + 1);\n\n\t*(bb1 + 0) = a11;\n\t*(bb1 + 1) = a21;\n\t*(bb2 + 0) = a12;\n\t*(bb2 + 1) = a22;\n\n\t*(cc1 + 0) = a11;\n\t*(cc1 + 1) = -a21;\n\t*(cc1 + 2) = a12;\n\t*(cc1 + 3) = -a22;\n      }\n    }\n\n    if (m - js == 1){\n      a11 = *(aa1 + 0);\n      *(bb1 + 0) = a11;\n      *(bb1 + 1) = 0.;\n    }\n\n  }\n}\n\nstatic __inline void ZHEMCOPY_U(BLASLONG m, FLOAT *a, BLASLONG lda, FLOAT *b){\n  BLASLONG is, js;\n\n  FLOAT *aa1, *aa2;\n  FLOAT *b1, *b2;\n  FLOAT *bb1, *bb2;\n  FLOAT *cc1, *cc2;\n  FLOAT a11, a21, a31, a41;\n  FLOAT a12, a22, a32, a42;\n\n  b1 = b;\n  b2 = b;\n\n  lda *= 2;\n\n  for (js = 0; js < m; js += 2){\n\n    aa1 = a + 0 * lda;\n    aa2 = a + 1 * lda;\n    a  += 2 * lda;\n\n    bb1 = b1 + 0 * m;\n    bb2 = b1 + 2 * m;\n    b1 += 4 * m;\n\n    cc1 = b2 + 0 * m;\n    cc2 = b2 + 2 * m;\n    b2 += 4;\n\n    if (m - js >= 2){\n\n      for (is = 0; is < js; is += 2){\n\n\ta11 = *(aa1 + 0);\n\ta21 = *(aa1 + 1);\n\ta31 = *(aa1 + 2);\n\ta41 = *(aa1 + 3);\n\n\ta12 = *(aa2 + 0);\n\ta22 = *(aa2 + 1);\n\ta32 = *(aa2 + 2);\n\ta42 = *(aa2 + 3);\n\n\taa1 += 4;\n\taa2 += 4;\n\n\t*(bb1 + 0) = a11;\n\t*(bb1 + 1) = a21;\n\t*(bb1 + 2) = a31;\n\t*(bb1 + 3) = a41;\n\n\t*(bb2 + 0) = a12;\n\t*(bb2 + 1) = a22;\n\t*(bb2 + 2) = a32;\n\t*(bb2 + 3) = a42;\n\n\t*(cc1 + 0) = a11;\n\t*(cc1 + 1) = -a21;\n\t*(cc1 + 2) = a12;\n\t*(cc1 + 3) = -a22;\n\n\t*(cc2 + 0) = a31;\n\t*(cc2 + 1) = -a41;\n\t*(cc2 + 2) = a32;\n\t*(cc2 + 3) = -a42;\n\n\tbb1 += 4;\n\tbb2 += 4;\n\n\tcc1 += 4 * m;\n\tcc2 += 4 * m;\n      }\n\n      a11 = *(aa1 + 0);\n\n      a12 = *(aa2 + 0);\n      a22 = *(aa2 + 1);\n      a32 = *(aa2 + 2);\n\n      *(bb1 + 0) = a11;\n      *(bb1 + 1) = 0.;\n      *(bb1 + 2) = a12;\n      *(bb1 + 3) = -a22;\n\n      *(bb2 + 0) = a12;\n      *(bb2 + 1) = a22;\n      *(bb2 + 2) = a32;\n      *(bb2 + 3) = 0.;\n    }\n\n    if (m - js == 1){\n      for (is = 0; is < js; is += 2){\n\n\ta11 = *(aa1 + 0);\n\ta21 = *(aa1 + 1);\n\ta31 = *(aa1 + 2);\n\ta41 = *(aa1 + 3);\n\taa1 += 4;\n\n\t*(bb1 + 0) = a11;\n\t*(bb1 + 1) = a21;\n\t*(bb1 + 2) = a31;\n\t*(bb1 + 3) = a41;\n\n\t*(cc1 + 0) = a11;\n\t*(cc1 + 1) = -a21;\n\t*(cc2 + 0) = a31;\n\t*(cc2 + 1) = -a41;\n\tbb1 += 4;\n\n\tcc1 += 4 * m;\n\tcc2 += 4 * m;\n      }\n\n      a11 = *(aa1 + 0);\n      *(bb1 + 0) = a11;\n      *(bb1 + 1) = 0.;\n    }\n  }\n}\n\n\nstatic __inline void ZHEMCOPY_M(BLASLONG m, FLOAT *a, BLASLONG lda, FLOAT *b){\n  BLASLONG is, js;\n\n  FLOAT *aa1, *aa2;\n  FLOAT *b1, *b2;\n  FLOAT *bb1, *bb2;\n  FLOAT *cc1, *cc2;\n  FLOAT a11, a21, a31, a41;\n  FLOAT a12, a22, a32, a42;\n\n  b1 = b;\n  b2 = b;\n\n  lda *= 2;\n\n  for (js = 0; js < m; js += 2){\n\n    aa1 = a + 0 * lda;\n    aa2 = a + 1 * lda;\n    a  += 2 * lda + 4;\n\n    bb1 = b1 + 0 * m;\n    bb2 = b1 + 2 * m;\n    b1 += 4 * m + 4;\n\n    cc1 = b2 + 0 * m;\n    cc2 = b2 + 2 * m;\n    b2 += 4 * m + 4;\n\n    if (m - js >= 2){\n\n      a11 = *(aa1 + 0);\n      a31 = *(aa1 + 2);\n      a41 = *(aa1 + 3);\n\n      a12 = *(aa2 + 2);\n\n      *(bb1 + 0) = a11;\n      *(bb1 + 1) = 0.;\n      *(bb1 + 2) = a31;\n      *(bb1 + 3) = -a41;\n\n      *(bb2 + 0) = a31;\n      *(bb2 + 1) = a41;\n      *(bb2 + 2) = a12;\n      *(bb2 + 3) = 0.;\n\n      aa1 += 4;\n      aa2 += 4;\n      bb1 += 4;\n      bb2 += 4;\n\n      cc1 += 4 * m;\n      cc2 += 4 * m;\n\n      is = ((m - js - 2) >> 1);\n\n      while (is > 0){\n\ta11 = *(aa1 + 0);\n\ta21 = *(aa1 + 1);\n\ta31 = *(aa1 + 2);\n\ta41 = *(aa1 + 3);\n\n\ta12 = *(aa2 + 0);\n\ta22 = *(aa2 + 1);\n\ta32 = *(aa2 + 2);\n\ta42 = *(aa2 + 3);\n\n\taa1 += 4;\n\taa2 += 4;\n\n\t*(bb1 + 0) = a11;\n\t*(bb1 + 1) = -a21;\n\t*(bb1 + 2) = a31;\n\t*(bb1 + 3) = -a41;\n\n\t*(bb2 + 0) = a12;\n\t*(bb2 + 1) = -a22;\n\t*(bb2 + 2) = a32;\n\t*(bb2 + 3) = -a42;\n\n\t*(cc1 + 0) = a11;\n\t*(cc1 + 1) = a21;\n\t*(cc1 + 2) = a12;\n\t*(cc1 + 3) = a22;\n\n\t*(cc2 + 0) = a31;\n\t*(cc2 + 1) = a41;\n\t*(cc2 + 2) = a32;\n\t*(cc2 + 3) = a42;\n\n\tbb1 += 4;\n\tbb2 += 4;\n\n\tcc1 += 4 * m;\n\tcc2 += 4 * m;\n\n\tis --;\n      }\n\n      if (m & 1){\n\ta11 = *(aa1 + 0);\n\ta21 = *(aa1 + 1);\n\ta12 = *(aa2 + 0);\n\ta22 = *(aa2 + 1);\n\n\t*(bb1 + 0) = a11;\n\t*(bb1 + 1) = -a21;\n\t*(bb2 + 0) = a12;\n\t*(bb2 + 1) = -a22;\n\n\t*(cc1 + 0) = a11;\n\t*(cc1 + 1) = a21;\n\t*(cc1 + 2) = a12;\n\t*(cc1 + 3) = a22;\n      }\n    }\n\n    if (m - js == 1){\n      a11 = *(aa1 + 0);\n      *(bb1 + 0) = a11;\n      *(bb1 + 1) = 0.;\n    }\n\n  }\n}\n\nstatic __inline void ZHEMCOPY_V(BLASLONG m, FLOAT *a, BLASLONG lda, FLOAT *b){\n  BLASLONG is, js;\n\n  FLOAT *aa1, *aa2;\n  FLOAT *b1, *b2;\n  FLOAT *bb1, *bb2;\n  FLOAT *cc1, *cc2;\n  FLOAT a11, a21, a31, a41;\n  FLOAT a12, a22, a32, a42;\n\n  b1 = b;\n  b2 = b;\n\n  lda *= 2;\n\n  for (js = 0; js < m; js += 2){\n\n    aa1 = a + 0 * lda;\n    aa2 = a + 1 * lda;\n    a  += 2 * lda;\n\n    bb1 = b1 + 0 * m;\n    bb2 = b1 + 2 * m;\n    b1 += 4 * m;\n\n    cc1 = b2 + 0 * m;\n    cc2 = b2 + 2 * m;\n    b2 += 4;\n\n    if (m - js >= 2){\n\n      for (is = 0; is < js; is += 2){\n\n\ta11 = *(aa1 + 0);\n\ta21 = *(aa1 + 1);\n\ta31 = *(aa1 + 2);\n\ta41 = *(aa1 + 3);\n\n\ta12 = *(aa2 + 0);\n\ta22 = *(aa2 + 1);\n\ta32 = *(aa2 + 2);\n\ta42 = *(aa2 + 3);\n\n\taa1 += 4;\n\taa2 += 4;\n\n\t*(bb1 + 0) = a11;\n\t*(bb1 + 1) = -a21;\n\t*(bb1 + 2) = a31;\n\t*(bb1 + 3) = -a41;\n\n\t*(bb2 + 0) = a12;\n\t*(bb2 + 1) = -a22;\n\t*(bb2 + 2) = a32;\n\t*(bb2 + 3) = -a42;\n\n\t*(cc1 + 0) = a11;\n\t*(cc1 + 1) = a21;\n\t*(cc1 + 2) = a12;\n\t*(cc1 + 3) = a22;\n\n\t*(cc2 + 0) = a31;\n\t*(cc2 + 1) = a41;\n\t*(cc2 + 2) = a32;\n\t*(cc2 + 3) = a42;\n\n\tbb1 += 4;\n\tbb2 += 4;\n\n\tcc1 += 4 * m;\n\tcc2 += 4 * m;\n      }\n\n      a11 = *(aa1 + 0);\n\n      a12 = *(aa2 + 0);\n      a22 = *(aa2 + 1);\n      a32 = *(aa2 + 2);\n\n      *(bb1 + 0) = a11;\n      *(bb1 + 1) = 0.;\n      *(bb1 + 2) = a12;\n      *(bb1 + 3) = a22;\n\n      *(bb2 + 0) = a12;\n      *(bb2 + 1) = -a22;\n      *(bb2 + 2) = a32;\n      *(bb2 + 3) = 0.;\n    }\n\n    if (m - js == 1){\n      for (is = 0; is < js; is += 2){\n\n\ta11 = *(aa1 + 0);\n\ta21 = *(aa1 + 1);\n\ta31 = *(aa1 + 2);\n\ta41 = *(aa1 + 3);\n\taa1 += 4;\n\n\t*(bb1 + 0) = a11;\n\t*(bb1 + 1) = -a21;\n\t*(bb1 + 2) = a31;\n\t*(bb1 + 3) = -a41;\n\n\t*(cc1 + 0) = a11;\n\t*(cc1 + 1) = a21;\n\t*(cc2 + 0) = a31;\n\t*(cc2 + 1) = a41;\n\tbb1 += 4;\n\n\tcc1 += 4 * m;\n\tcc2 += 4 * m;\n      }\n\n      a11 = *(aa1 + 0);\n      *(bb1 + 0) = a11;\n      *(bb1 + 1) = 0.;\n    }\n  }\n}\n\n\nstatic __inline void TRMCOPY_NL(BLASLONG m, FLOAT *a, BLASLONG lda, FLOAT *b){\n  BLASLONG is, js;\n\n  FLOAT *aa1, *aa2;\n  FLOAT *b1, *b2;\n  FLOAT *bb1, *bb2;\n  FLOAT *cc1, *cc2;\n  FLOAT a11, a12;\n  FLOAT a21, a22;\n\n  b1 = b;\n  b2 = b;\n\n  for (js = 0; js < m; js += 2){\n\n    aa1 = a + 0 * lda;\n    aa2 = a + 1 * lda;\n    a  += 2 * lda + 2;\n\n    bb1 = b1 + 0 * m;\n    bb2 = b1 + 1 * m;\n    b1 += 2 * m + 2;\n\n    cc1 = b2 + 0 * m;\n    cc2 = b2 + 1 * m;\n    b2 += 2 * m + 2;\n\n    if (m - js >= 2){\n\n      a11 = *(aa1 + 0);\n      a21 = *(aa1 + 1);\n\n      a22 = *(aa2 + 1);\n\n      *(bb1 + 0) = a11;\n      *(bb1 + 1) = a21;\n      *(bb2 + 0) = a21;\n      *(bb2 + 1) = a22;\n      aa1 += 2;\n      aa2 += 2;\n      bb1 += 2;\n      bb2 += 2;\n\n      cc1 += 2 * m;\n      cc2 += 2 * m;\n\n      is = ((m - js - 2) >> 1);\n\n      while (is > 0){\n\ta11 = *(aa1 + 0);\n\ta21 = *(aa1 + 1);\n\ta12 = *(aa2 + 0);\n\ta22 = *(aa2 + 1);\n\n\taa1 += 2;\n\taa2 += 2;\n\n\t*(bb1 + 0) = a11;\n\t*(bb1 + 1) = a21;\n\t*(bb2 + 0) = a12;\n\t*(bb2 + 1) = a22;\n\n\t*(cc1 + 0) = a11;\n\t*(cc1 + 1) = a12;\n\t*(cc2 + 0) = a21;\n\t*(cc2 + 1) = a22;\n\n\tbb1 += 2;\n\tbb2 += 2;\n\n\tcc1 += 2 * m;\n\tcc2 += 2 * m;\n\n\tis --;\n      }\n\n      is = ((m - js - 2) & 1);\n\n      if (is == 1){\n\ta11 = *(aa1 + 0);\n\ta12 = *(aa2 + 0);\n\n\t*(bb1 + 0) = a11;\n\t*(bb2 + 0) = a12;\n\n\t*(cc1 + 0) = a11;\n\t*(cc1 + 1) = a12;\n      }\n    }\n\n    if (m - js == 1){\n      a11 = *(aa1 + 0);\n      *(bb1 + 0) = a11;\n    }\n\n  }\n}\n\nstatic __inline void TRMCOPY_TL(BLASLONG m, FLOAT *a, BLASLONG lda, FLOAT *b){\n  BLASLONG is, js;\n\n  FLOAT *aa1, *aa2;\n  FLOAT *b1, *b2;\n  FLOAT *bb1, *bb2;\n  FLOAT *cc1, *cc2;\n  FLOAT a11, a12;\n  FLOAT a21, a22;\n\n  b1 = b;\n  b2 = b;\n\n  for (js = 0; js < m; js += 2){\n\n    aa1 = a + 0 * lda;\n    aa2 = a + 1 * lda;\n    a  += 2 * lda + 2;\n\n    bb1 = b1 + 0 * m;\n    bb2 = b1 + 1 * m;\n    b1 += 2 * m + 2;\n\n    cc1 = b2 + 0 * m;\n    cc2 = b2 + 1 * m;\n    b2 += 2 * m + 2;\n\n    if (m - js >= 2){\n\n      a11 = *(aa1 + 0);\n      a21 = *(aa1 + 1);\n\n      a22 = *(aa2 + 1);\n\n      *(bb1 + 0) = a11;\n      *(bb1 + 1) = a21;\n      *(bb2 + 0) = a21;\n      *(bb2 + 1) = a22;\n      aa1 += 2;\n      aa2 += 2;\n      bb1 += 2;\n      bb2 += 2;\n\n      cc1 += 2 * m;\n      cc2 += 2 * m;\n\n      is = ((m - js - 2) >> 1);\n\n      while (is > 0){\n\ta11 = *(aa1 + 0);\n\ta21 = *(aa1 + 1);\n\ta12 = *(aa2 + 0);\n\ta22 = *(aa2 + 1);\n\n\taa1 += 2;\n\taa2 += 2;\n\n\t*(bb1 + 0) = a11;\n\t*(bb1 + 1) = a21;\n\t*(bb2 + 0) = a12;\n\t*(bb2 + 1) = a22;\n\n\t*(cc1 + 0) = a11;\n\t*(cc1 + 1) = a12;\n\t*(cc2 + 0) = a21;\n\t*(cc2 + 1) = a22;\n\n\tbb1 += 2;\n\tbb2 += 2;\n\n\tcc1 += 2 * m;\n\tcc2 += 2 * m;\n\n\tis --;\n      }\n\n      is = ((m - js - 2) & 1);\n\n      if (is == 1){\n\ta11 = *(aa1 + 0);\n\ta12 = *(aa2 + 0);\n\n\t*(bb1 + 0) = a11;\n\t*(bb2 + 0) = a12;\n\n\t*(cc1 + 0) = a11;\n\t*(cc1 + 1) = a12;\n      }\n    }\n\n    if (m - js == 1){\n      a11 = *(aa1 + 0);\n      *(bb1 + 0) = a11;\n    }\n\n  }\n}\n\nstatic __inline void TRMCOPY_NU(BLASLONG m, FLOAT *a, BLASLONG lda, FLOAT *b){\n  BLASLONG is, js;\n\n  FLOAT *aa1, *aa2;\n  FLOAT *b1, *b2;\n  FLOAT *bb1, *bb2;\n  FLOAT *cc1, *cc2;\n  FLOAT a11, a12;\n  FLOAT a21, a22;\n\n  b1 = b;\n  b2 = b;\n\n  for (js = 0; js < m; js += 2){\n\n    aa1 = a + 0 * lda;\n    aa2 = a + 1 * lda;\n    a  += 2 * lda;\n\n    bb1 = b1 + 0 * m;\n    bb2 = b1 + 1 * m;\n    b1 += 2 * m;\n\n    cc1 = b2 + 0 * m;\n    cc2 = b2 + 1 * m;\n    b2 += 2;\n\n    if (m - js >= 2){\n\n      for (is = 0; is < js; is += 2){\n\n\ta11 = *(aa1 + 0);\n\ta21 = *(aa1 + 1);\n\ta12 = *(aa2 + 0);\n\ta22 = *(aa2 + 1);\n\n\taa1 += 2;\n\taa2 += 2;\n\n\t*(bb1 + 0) = a11;\n\t*(bb1 + 1) = a21;\n\t*(bb2 + 0) = a12;\n\t*(bb2 + 1) = a22;\n\n\t*(cc1 + 0) = a11;\n\t*(cc1 + 1) = a12;\n\t*(cc2 + 0) = a21;\n\t*(cc2 + 1) = a22;\n\n\tbb1 += 2;\n\tbb2 += 2;\n\n\tcc1 += 2 * m;\n\tcc2 += 2 * m;\n      }\n\n      a11 = *(aa1 + 0);\n\n      a12 = *(aa2 + 0);\n      a22 = *(aa2 + 1);\n\n      *(bb1 + 0) = a11;\n      *(bb1 + 1) = a12;\n      *(bb2 + 0) = a12;\n      *(bb2 + 1) = a22;\n    }\n\n    if (m - js == 1){\n      for (is = 0; is < js; is += 2){\n\n\ta11 = *(aa1 + 0);\n\ta21 = *(aa1 + 1);\n\taa1 += 2;\n\n\t*(bb1 + 0) = a11;\n\t*(bb1 + 1) = a21;\n\t*(cc1 + 0) = a11;\n\t*(cc2 + 0) = a21;\n\tbb1 += 2;\n\n\tcc1 += 2 * m;\n\tcc2 += 2 * m;\n      }\n\n      a11 = *(aa1 + 0);\n      *(bb1 + 0) = a11;\n    }\n  }\n}\n\nstatic __inline void TRMCOPY_TU(BLASLONG m, FLOAT *a, BLASLONG lda, FLOAT *b){\n  BLASLONG is, js;\n\n  FLOAT *aa1, *aa2;\n  FLOAT *b1, *b2;\n  FLOAT *bb1, *bb2;\n  FLOAT *cc1, *cc2;\n  FLOAT a11, a12;\n  FLOAT a21, a22;\n\n  b1 = b;\n  b2 = b;\n\n  for (js = 0; js < m; js += 2){\n\n    aa1 = a + 0 * lda;\n    aa2 = a + 1 * lda;\n    a  += 2 * lda;\n\n    bb1 = b1 + 0 * m;\n    bb2 = b1 + 1 * m;\n    b1 += 2 * m;\n\n    cc1 = b2 + 0 * m;\n    cc2 = b2 + 1 * m;\n    b2 += 2;\n\n    if (m - js >= 2){\n\n      for (is = 0; is < js; is += 2){\n\n\ta11 = *(aa1 + 0);\n\ta21 = *(aa1 + 1);\n\ta12 = *(aa2 + 0);\n\ta22 = *(aa2 + 1);\n\n\taa1 += 2;\n\taa2 += 2;\n\n\t*(bb1 + 0) = a11;\n\t*(bb1 + 1) = a21;\n\t*(bb2 + 0) = a12;\n\t*(bb2 + 1) = a22;\n\n\t*(cc1 + 0) = a11;\n\t*(cc1 + 1) = a12;\n\t*(cc2 + 0) = a21;\n\t*(cc2 + 1) = a22;\n\n\tbb1 += 2;\n\tbb2 += 2;\n\n\tcc1 += 2 * m;\n\tcc2 += 2 * m;\n      }\n\n      a11 = *(aa1 + 0);\n\n      a12 = *(aa2 + 0);\n      a22 = *(aa2 + 1);\n\n      *(bb1 + 0) = a11;\n      *(bb1 + 1) = a12;\n      *(bb2 + 0) = a12;\n      *(bb2 + 1) = a22;\n    }\n\n    if (m - js == 1){\n      for (is = 0; is < js; is += 2){\n\n\ta11 = *(aa1 + 0);\n\ta21 = *(aa1 + 1);\n\taa1 += 2;\n\n\t*(bb1 + 0) = a11;\n\t*(bb1 + 1) = a21;\n\t*(cc1 + 0) = a11;\n\t*(cc2 + 0) = a21;\n\tbb1 += 2;\n\n\tcc1 += 2 * m;\n\tcc2 += 2 * m;\n      }\n\n      a11 = *(aa1 + 0);\n      *(bb1 + 0) = a11;\n    }\n  }\n}\n\nstatic __inline void ZTRMCOPY_NL(BLASLONG m, FLOAT *a, BLASLONG lda, FLOAT *b){\n  BLASLONG is, js;\n\n  FLOAT *aa1, *aa2;\n  FLOAT *b1, *b2;\n  FLOAT *bb1, *bb2;\n  FLOAT *cc1, *cc2;\n  FLOAT a11, a21, a31, a41;\n  FLOAT a12, a22, a32, a42;\n\n  b1 = b;\n  b2 = b;\n\n  lda *= 2;\n\n  for (js = 0; js < m; js += 2){\n\n    aa1 = a + 0 * lda;\n    aa2 = a + 1 * lda;\n    a  += 2 * lda + 4;\n\n    bb1 = b1 + 0 * m;\n    bb2 = b1 + 2 * m;\n    b1 += 4 * m + 4;\n\n    cc1 = b2 + 0 * m;\n    cc2 = b2 + 2 * m;\n    b2 += 4 * m + 4;\n\n    if (m - js >= 2){\n\n      a11 = *(aa1 + 0);\n      a21 = *(aa1 + 1);\n      a31 = *(aa1 + 2);\n      a41 = *(aa1 + 3);\n\n      a12 = *(aa2 + 2);\n      a22 = *(aa2 + 3);\n\n      *(bb1 + 0) = a11;\n      *(bb1 + 1) = a21;\n      *(bb1 + 2) = a31;\n      *(bb1 + 3) = a41;\n\n      *(bb2 + 0) = a31;\n      *(bb2 + 1) = a41;\n      *(bb2 + 2) = a12;\n      *(bb2 + 3) = a22;\n\n      aa1 += 4;\n      aa2 += 4;\n      bb1 += 4;\n      bb2 += 4;\n\n      cc1 += 4 * m;\n      cc2 += 4 * m;\n\n      is = ((m - js - 2) >> 1);\n\n      while (is > 0){\n\ta11 = *(aa1 + 0);\n\ta21 = *(aa1 + 1);\n\ta31 = *(aa1 + 2);\n\ta41 = *(aa1 + 3);\n\n\ta12 = *(aa2 + 0);\n\ta22 = *(aa2 + 1);\n\ta32 = *(aa2 + 2);\n\ta42 = *(aa2 + 3);\n\n\taa1 += 4;\n\taa2 += 4;\n\n\t*(bb1 + 0) = a11;\n\t*(bb1 + 1) = a21;\n\t*(bb1 + 2) = a31;\n\t*(bb1 + 3) = a41;\n\n\t*(bb2 + 0) = a12;\n\t*(bb2 + 1) = a22;\n\t*(bb2 + 2) = a32;\n\t*(bb2 + 3) = a42;\n\n\t*(cc1 + 0) = a11;\n\t*(cc1 + 1) = a21;\n\t*(cc1 + 2) = a12;\n\t*(cc1 + 3) = a22;\n\n\t*(cc2 + 0) = a31;\n\t*(cc2 + 1) = a41;\n\t*(cc2 + 2) = a32;\n\t*(cc2 + 3) = a42;\n\n\tbb1 += 4;\n\tbb2 += 4;\n\n\tcc1 += 4 * m;\n\tcc2 += 4 * m;\n\n\tis --;\n      }\n\n      if (m & 1){\n\ta11 = *(aa1 + 0);\n\ta21 = *(aa1 + 1);\n\ta12 = *(aa2 + 0);\n\ta22 = *(aa2 + 1);\n\n\t*(bb1 + 0) = a11;\n\t*(bb1 + 1) = a21;\n\t*(bb2 + 0) = a12;\n\t*(bb2 + 1) = a22;\n\n\t*(cc1 + 0) = a11;\n\t*(cc1 + 1) = a21;\n\t*(cc1 + 2) = a12;\n\t*(cc1 + 3) = a22;\n      }\n    }\n\n    if (m - js == 1){\n      a11 = *(aa1 + 0);\n      a21 = *(aa1 + 1);\n      *(bb1 + 0) = a11;\n      *(bb1 + 1) = a21;\n    }\n\n  }\n}\n\nstatic __inline void ZTRMCOPY_TL(BLASLONG m, FLOAT *a, BLASLONG lda, FLOAT *b){\n  BLASLONG is, js;\n\n  FLOAT *aa1, *aa2;\n  FLOAT *b1, *b2;\n  FLOAT *bb1, *bb2;\n  FLOAT *cc1, *cc2;\n  FLOAT a11, a21, a31, a41;\n  FLOAT a12, a22, a32, a42;\n\n  b1 = b;\n  b2 = b;\n\n  lda *= 2;\n\n  for (js = 0; js < m; js += 2){\n\n    aa1 = a + 0 * lda;\n    aa2 = a + 1 * lda;\n    a  += 2 * lda + 4;\n\n    bb1 = b1 + 0 * m;\n    bb2 = b1 + 2 * m;\n    b1 += 4 * m + 4;\n\n    cc1 = b2 + 0 * m;\n    cc2 = b2 + 2 * m;\n    b2 += 4 * m + 4;\n\n    if (m - js >= 2){\n\n      a11 = *(aa1 + 0);\n      a21 = *(aa1 + 1);\n      a31 = *(aa1 + 2);\n      a41 = *(aa1 + 3);\n\n      a12 = *(aa2 + 2);\n      a22 = *(aa2 + 3);\n\n      *(bb1 + 0) = a11;\n      *(bb1 + 1) = a21;\n      *(bb1 + 2) = a31;\n      *(bb1 + 3) = a41;\n\n      *(bb2 + 0) = a31;\n      *(bb2 + 1) = a41;\n      *(bb2 + 2) = a12;\n      *(bb2 + 3) = a22;\n\n      aa1 += 4;\n      aa2 += 4;\n      bb1 += 4;\n      bb2 += 4;\n\n      cc1 += 4 * m;\n      cc2 += 4 * m;\n\n      is = ((m - js - 2) >> 1);\n\n      while (is > 0){\n\ta11 = *(aa1 + 0);\n\ta21 = *(aa1 + 1);\n\ta31 = *(aa1 + 2);\n\ta41 = *(aa1 + 3);\n\n\ta12 = *(aa2 + 0);\n\ta22 = *(aa2 + 1);\n\ta32 = *(aa2 + 2);\n\ta42 = *(aa2 + 3);\n\n\taa1 += 4;\n\taa2 += 4;\n\n\t*(bb1 + 0) = a11;\n\t*(bb1 + 1) = a21;\n\t*(bb1 + 2) = a31;\n\t*(bb1 + 3) = a41;\n\n\t*(bb2 + 0) = a12;\n\t*(bb2 + 1) = a22;\n\t*(bb2 + 2) = a32;\n\t*(bb2 + 3) = a42;\n\n\t*(cc1 + 0) = a11;\n\t*(cc1 + 1) = a21;\n\t*(cc1 + 2) = a12;\n\t*(cc1 + 3) = a22;\n\n\t*(cc2 + 0) = a31;\n\t*(cc2 + 1) = a41;\n\t*(cc2 + 2) = a32;\n\t*(cc2 + 3) = a42;\n\n\tbb1 += 4;\n\tbb2 += 4;\n\n\tcc1 += 4 * m;\n\tcc2 += 4 * m;\n\n\tis --;\n      }\n\n      if (m & 1){\n\ta11 = *(aa1 + 0);\n\ta21 = *(aa1 + 1);\n\ta12 = *(aa2 + 0);\n\ta22 = *(aa2 + 1);\n\n\t*(bb1 + 0) = a11;\n\t*(bb1 + 1) = a21;\n\t*(bb2 + 0) = a12;\n\t*(bb2 + 1) = a22;\n\n\t*(cc1 + 0) = a11;\n\t*(cc1 + 1) = a21;\n\t*(cc1 + 2) = a12;\n\t*(cc1 + 3) = a22;\n      }\n    }\n\n    if (m - js == 1){\n      a11 = *(aa1 + 0);\n      a21 = *(aa1 + 1);\n      *(bb1 + 0) = a11;\n      *(bb1 + 1) = a21;\n    }\n\n  }\n}\n\nstatic __inline void ZTRMCOPY_NU(BLASLONG m, FLOAT *a, BLASLONG lda, FLOAT *b){\n  BLASLONG is, js;\n\n  FLOAT *aa1, *aa2;\n  FLOAT *b1, *b2;\n  FLOAT *bb1, *bb2;\n  FLOAT *cc1, *cc2;\n  FLOAT a11, a21, a31, a41;\n  FLOAT a12, a22, a32, a42;\n\n  b1 = b;\n  b2 = b;\n\n  lda *= 2;\n\n  for (js = 0; js < m; js += 2){\n\n    aa1 = a + 0 * lda;\n    aa2 = a + 1 * lda;\n    a  += 2 * lda;\n\n    bb1 = b1 + 0 * m;\n    bb2 = b1 + 2 * m;\n    b1 += 4 * m;\n\n    cc1 = b2 + 0 * m;\n    cc2 = b2 + 2 * m;\n    b2 += 4;\n\n    if (m - js >= 2){\n\n      for (is = 0; is < js; is += 2){\n\n\ta11 = *(aa1 + 0);\n\ta21 = *(aa1 + 1);\n\ta31 = *(aa1 + 2);\n\ta41 = *(aa1 + 3);\n\n\ta12 = *(aa2 + 0);\n\ta22 = *(aa2 + 1);\n\ta32 = *(aa2 + 2);\n\ta42 = *(aa2 + 3);\n\n\taa1 += 4;\n\taa2 += 4;\n\n\t*(bb1 + 0) = a11;\n\t*(bb1 + 1) = a21;\n\t*(bb1 + 2) = a31;\n\t*(bb1 + 3) = a41;\n\n\t*(bb2 + 0) = a12;\n\t*(bb2 + 1) = a22;\n\t*(bb2 + 2) = a32;\n\t*(bb2 + 3) = a42;\n\n\t*(cc1 + 0) = a11;\n\t*(cc1 + 1) = a21;\n\t*(cc1 + 2) = a12;\n\t*(cc1 + 3) = a22;\n\n\t*(cc2 + 0) = a31;\n\t*(cc2 + 1) = a41;\n\t*(cc2 + 2) = a32;\n\t*(cc2 + 3) = a42;\n\n\tbb1 += 4;\n\tbb2 += 4;\n\n\tcc1 += 4 * m;\n\tcc2 += 4 * m;\n      }\n\n      a11 = *(aa1 + 0);\n      a21 = *(aa1 + 1);\n\n      a12 = *(aa2 + 0);\n      a22 = *(aa2 + 1);\n      a32 = *(aa2 + 2);\n      a42 = *(aa2 + 3);\n\n      *(bb1 + 0) = a11;\n      *(bb1 + 1) = a21;\n      *(bb1 + 2) = a12;\n      *(bb1 + 3) = a22;\n\n      *(bb2 + 0) = a12;\n      *(bb2 + 1) = a22;\n      *(bb2 + 2) = a32;\n      *(bb2 + 3) = a42;\n    }\n\n    if (m - js == 1){\n      for (is = 0; is < js; is += 2){\n\n\ta11 = *(aa1 + 0);\n\ta21 = *(aa1 + 1);\n\ta31 = *(aa1 + 2);\n\ta41 = *(aa1 + 3);\n\taa1 += 4;\n\n\t*(bb1 + 0) = a11;\n\t*(bb1 + 1) = a21;\n\t*(bb1 + 2) = a31;\n\t*(bb1 + 3) = a41;\n\n\t*(cc1 + 0) = a11;\n\t*(cc1 + 1) = a21;\n\t*(cc2 + 0) = a31;\n\t*(cc2 + 1) = a41;\n\tbb1 += 4;\n\n\tcc1 += 4 * m;\n\tcc2 += 4 * m;\n      }\n\n      a11 = *(aa1 + 0);\n      a21 = *(aa1 + 1);\n      *(bb1 + 0) = a11;\n      *(bb1 + 1) = a21;\n    }\n  }\n}\n\nstatic __inline void ZTRMCOPY_TU(BLASLONG m, FLOAT *a, BLASLONG lda, FLOAT *b){\n  BLASLONG is, js;\n\n  FLOAT *aa1, *aa2;\n  FLOAT *b1, *b2;\n  FLOAT *bb1, *bb2;\n  FLOAT *cc1, *cc2;\n  FLOAT a11, a21, a31, a41;\n  FLOAT a12, a22, a32, a42;\n\n  b1 = b;\n  b2 = b;\n\n  lda *= 2;\n\n  for (js = 0; js < m; js += 2){\n\n    aa1 = a + 0 * lda;\n    aa2 = a + 1 * lda;\n    a  += 2 * lda;\n\n    bb1 = b1 + 0 * m;\n    bb2 = b1 + 2 * m;\n    b1 += 4 * m;\n\n    cc1 = b2 + 0 * m;\n    cc2 = b2 + 2 * m;\n    b2 += 4;\n\n    if (m - js >= 2){\n\n      for (is = 0; is < js; is += 2){\n\n\ta11 = *(aa1 + 0);\n\ta21 = *(aa1 + 1);\n\ta31 = *(aa1 + 2);\n\ta41 = *(aa1 + 3);\n\n\ta12 = *(aa2 + 0);\n\ta22 = *(aa2 + 1);\n\ta32 = *(aa2 + 2);\n\ta42 = *(aa2 + 3);\n\n\taa1 += 4;\n\taa2 += 4;\n\n\t*(bb1 + 0) = a11;\n\t*(bb1 + 1) = a21;\n\t*(bb1 + 2) = a31;\n\t*(bb1 + 3) = a41;\n\n\t*(bb2 + 0) = a12;\n\t*(bb2 + 1) = a22;\n\t*(bb2 + 2) = a32;\n\t*(bb2 + 3) = a42;\n\n\t*(cc1 + 0) = a11;\n\t*(cc1 + 1) = a21;\n\t*(cc1 + 2) = a12;\n\t*(cc1 + 3) = a22;\n\n\t*(cc2 + 0) = a31;\n\t*(cc2 + 1) = a41;\n\t*(cc2 + 2) = a32;\n\t*(cc2 + 3) = a42;\n\n\tbb1 += 4;\n\tbb2 += 4;\n\n\tcc1 += 4 * m;\n\tcc2 += 4 * m;\n      }\n\n      a11 = *(aa1 + 0);\n      a21 = *(aa1 + 1);\n\n      a12 = *(aa2 + 0);\n      a22 = *(aa2 + 1);\n      a32 = *(aa2 + 2);\n      a42 = *(aa2 + 3);\n\n      *(bb1 + 0) = a11;\n      *(bb1 + 1) = a21;\n      *(bb1 + 2) = a12;\n      *(bb1 + 3) = a22;\n\n      *(bb2 + 0) = a12;\n      *(bb2 + 1) = a22;\n      *(bb2 + 2) = a32;\n      *(bb2 + 3) = a42;\n    }\n\n    if (m - js == 1){\n      for (is = 0; is < js; is += 2){\n\n\ta11 = *(aa1 + 0);\n\ta21 = *(aa1 + 1);\n\ta31 = *(aa1 + 2);\n\ta41 = *(aa1 + 3);\n\taa1 += 4;\n\n\t*(bb1 + 0) = a11;\n\t*(bb1 + 1) = a21;\n\t*(bb1 + 2) = a31;\n\t*(bb1 + 3) = a41;\n\n\t*(cc1 + 0) = a11;\n\t*(cc1 + 1) = a21;\n\t*(cc2 + 0) = a31;\n\t*(cc2 + 1) = a41;\n\tbb1 += 4;\n\n\tcc1 += 4 * m;\n\tcc2 += 4 * m;\n      }\n\n      a11 = *(aa1 + 0);\n      a21 = *(aa1 + 1);\n      *(bb1 + 0) = a11;\n      *(bb1 + 1) = a21;\n    }\n  }\n}\n\n#endif\n#endif\n\n"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "utest",
          "type": "tree",
          "content": null
        },
        {
          "name": "version.h",
          "type": "blob",
          "size": 4.34765625,
          "content": "/*****************************************************************************\nCopyright (c) 2011-2014, The OpenBLAS Project\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   1. Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n\n   2. Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in\n      the documentation and/or other materials provided with the\n      distribution.\n   3. Neither the name of the OpenBLAS project nor the names of \n      its contributors may be used to endorse or promote products \n      derived from this software without specific prior written \n      permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\nUSE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n**********************************************************************************/\n\n/*********************************************************************/\n/* Copyright 2009, 2010 The University of Texas at Austin.           */\n/* All rights reserved.                                              */\n/*                                                                   */\n/* Redistribution and use in source and binary forms, with or        */\n/* without modification, are permitted provided that the following   */\n/* conditions are met:                                               */\n/*                                                                   */\n/*   1. Redistributions of source code must retain the above         */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer.                                                  */\n/*                                                                   */\n/*   2. Redistributions in binary form must reproduce the above      */\n/*      copyright notice, this list of conditions and the following  */\n/*      disclaimer in the documentation and/or other materials       */\n/*      provided with the distribution.                              */\n/*                                                                   */\n/*    THIS  SOFTWARE IS PROVIDED  BY THE  UNIVERSITY OF  TEXAS AT    */\n/*    AUSTIN  ``AS IS''  AND ANY  EXPRESS OR  IMPLIED WARRANTIES,    */\n/*    INCLUDING, BUT  NOT LIMITED  TO, THE IMPLIED  WARRANTIES OF    */\n/*    MERCHANTABILITY  AND FITNESS FOR  A PARTICULAR  PURPOSE ARE    */\n/*    DISCLAIMED.  IN  NO EVENT SHALL THE UNIVERSITY  OF TEXAS AT    */\n/*    AUSTIN OR CONTRIBUTORS BE  LIABLE FOR ANY DIRECT, INDIRECT,    */\n/*    INCIDENTAL,  SPECIAL, EXEMPLARY,  OR  CONSEQUENTIAL DAMAGES    */\n/*    (INCLUDING, BUT  NOT LIMITED TO,  PROCUREMENT OF SUBSTITUTE    */\n/*    GOODS  OR  SERVICES; LOSS  OF  USE,  DATA,  OR PROFITS;  OR    */\n/*    BUSINESS INTERRUPTION) HOWEVER CAUSED  AND ON ANY THEORY OF    */\n/*    LIABILITY, WHETHER  IN CONTRACT, STRICT  LIABILITY, OR TORT    */\n/*    (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY WAY OUT    */\n/*    OF  THE  USE OF  THIS  SOFTWARE,  EVEN  IF ADVISED  OF  THE    */\n/*    POSSIBILITY OF SUCH DAMAGE.                                    */\n/*                                                                   */\n/* The views and conclusions contained in the software and           */\n/* documentation are those of the authors and should not be          */\n/* interpreted as representing official policies, either expressed   */\n/* or implied, of The University of Texas at Austin.                 */\n/*********************************************************************/\n\n#ifndef VERSION_H\n#define VERSION_H\n\n#define VERSION \"   OpenBLAS\"\n#endif\n"
        }
      ]
    }
  ]
}