{
  "metadata": {
    "timestamp": 1736710255542,
    "page": 9,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "cstack/db_tutorial",
      "stars": 9704,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.01953125,
          "content": "db\n*.db\n_site/\nTODO\n"
        },
        {
          "name": "Gemfile",
          "type": "blob",
          "size": 0.123046875,
          "content": "source 'https://rubygems.org'\ngem 'github-pages', group: :jekyll_plugins\ngem 'webrick'\ngem \"jekyll-theme-minimal\"\ngem \"rspec\"\n"
        },
        {
          "name": "Gemfile.lock",
          "type": "blob",
          "size": 7.8720703125,
          "content": "GEM\n  remote: https://rubygems.org/\n  specs:\n    activesupport (7.0.4.3)\n      concurrent-ruby (~> 1.0, >= 1.0.2)\n      i18n (>= 1.6, < 2)\n      minitest (>= 5.1)\n      tzinfo (~> 2.0)\n    addressable (2.8.4)\n      public_suffix (>= 2.0.2, < 6.0)\n    coffee-script (2.4.1)\n      coffee-script-source\n      execjs\n    coffee-script-source (1.11.1)\n    colorator (1.1.0)\n    commonmarker (0.23.9)\n    concurrent-ruby (1.2.2)\n    diff-lcs (1.5.0)\n    dnsruby (1.70.0)\n      simpleidn (~> 0.2.1)\n    em-websocket (0.5.3)\n      eventmachine (>= 0.12.9)\n      http_parser.rb (~> 0)\n    ethon (0.16.0)\n      ffi (>= 1.15.0)\n    eventmachine (1.2.7)\n    eventmachine (1.2.7-x86-mingw32)\n    execjs (2.8.1)\n    faraday (2.7.4)\n      faraday-net_http (>= 2.0, < 3.1)\n      ruby2_keywords (>= 0.0.4)\n    faraday-net_http (3.0.2)\n    ffi (1.15.5)\n    ffi (1.15.5-x86-mingw32)\n    forwardable-extended (2.6.0)\n    gemoji (3.0.1)\n    github-pages (228)\n      github-pages-health-check (= 1.17.9)\n      jekyll (= 3.9.3)\n      jekyll-avatar (= 0.7.0)\n      jekyll-coffeescript (= 1.1.1)\n      jekyll-commonmark-ghpages (= 0.4.0)\n      jekyll-default-layout (= 0.1.4)\n      jekyll-feed (= 0.15.1)\n      jekyll-gist (= 1.5.0)\n      jekyll-github-metadata (= 2.13.0)\n      jekyll-include-cache (= 0.2.1)\n      jekyll-mentions (= 1.6.0)\n      jekyll-optional-front-matter (= 0.3.2)\n      jekyll-paginate (= 1.1.0)\n      jekyll-readme-index (= 0.3.0)\n      jekyll-redirect-from (= 0.16.0)\n      jekyll-relative-links (= 0.6.1)\n      jekyll-remote-theme (= 0.4.3)\n      jekyll-sass-converter (= 1.5.2)\n      jekyll-seo-tag (= 2.8.0)\n      jekyll-sitemap (= 1.4.0)\n      jekyll-swiss (= 1.0.0)\n      jekyll-theme-architect (= 0.2.0)\n      jekyll-theme-cayman (= 0.2.0)\n      jekyll-theme-dinky (= 0.2.0)\n      jekyll-theme-hacker (= 0.2.0)\n      jekyll-theme-leap-day (= 0.2.0)\n      jekyll-theme-merlot (= 0.2.0)\n      jekyll-theme-midnight (= 0.2.0)\n      jekyll-theme-minimal (= 0.2.0)\n      jekyll-theme-modernist (= 0.2.0)\n      jekyll-theme-primer (= 0.6.0)\n      jekyll-theme-slate (= 0.2.0)\n      jekyll-theme-tactile (= 0.2.0)\n      jekyll-theme-time-machine (= 0.2.0)\n      jekyll-titles-from-headings (= 0.5.3)\n      jemoji (= 0.12.0)\n      kramdown (= 2.3.2)\n      kramdown-parser-gfm (= 1.1.0)\n      liquid (= 4.0.4)\n      mercenary (~> 0.3)\n      minima (= 2.5.1)\n      nokogiri (>= 1.13.6, < 2.0)\n      rouge (= 3.26.0)\n      terminal-table (~> 1.4)\n    github-pages-health-check (1.17.9)\n      addressable (~> 2.3)\n      dnsruby (~> 1.60)\n      octokit (~> 4.0)\n      public_suffix (>= 3.0, < 5.0)\n      typhoeus (~> 1.3)\n    html-pipeline (2.14.3)\n      activesupport (>= 2)\n      nokogiri (>= 1.4)\n    http_parser.rb (0.8.0)\n    i18n (1.13.0)\n      concurrent-ruby (~> 1.0)\n    jekyll (3.9.3)\n      addressable (~> 2.4)\n      colorator (~> 1.0)\n      em-websocket (~> 0.5)\n      i18n (>= 0.7, < 2)\n      jekyll-sass-converter (~> 1.0)\n      jekyll-watch (~> 2.0)\n      kramdown (>= 1.17, < 3)\n      liquid (~> 4.0)\n      mercenary (~> 0.3.3)\n      pathutil (~> 0.9)\n      rouge (>= 1.7, < 4)\n      safe_yaml (~> 1.0)\n    jekyll-avatar (0.7.0)\n      jekyll (>= 3.0, < 5.0)\n    jekyll-coffeescript (1.1.1)\n      coffee-script (~> 2.2)\n      coffee-script-source (~> 1.11.1)\n    jekyll-commonmark (1.4.0)\n      commonmarker (~> 0.22)\n    jekyll-commonmark-ghpages (0.4.0)\n      commonmarker (~> 0.23.7)\n      jekyll (~> 3.9.0)\n      jekyll-commonmark (~> 1.4.0)\n      rouge (>= 2.0, < 5.0)\n    jekyll-default-layout (0.1.4)\n      jekyll (~> 3.0)\n    jekyll-feed (0.15.1)\n      jekyll (>= 3.7, < 5.0)\n    jekyll-gist (1.5.0)\n      octokit (~> 4.2)\n    jekyll-github-metadata (2.13.0)\n      jekyll (>= 3.4, < 5.0)\n      octokit (~> 4.0, != 4.4.0)\n    jekyll-include-cache (0.2.1)\n      jekyll (>= 3.7, < 5.0)\n    jekyll-mentions (1.6.0)\n      html-pipeline (~> 2.3)\n      jekyll (>= 3.7, < 5.0)\n    jekyll-optional-front-matter (0.3.2)\n      jekyll (>= 3.0, < 5.0)\n    jekyll-paginate (1.1.0)\n    jekyll-readme-index (0.3.0)\n      jekyll (>= 3.0, < 5.0)\n    jekyll-redirect-from (0.16.0)\n      jekyll (>= 3.3, < 5.0)\n    jekyll-relative-links (0.6.1)\n      jekyll (>= 3.3, < 5.0)\n    jekyll-remote-theme (0.4.3)\n      addressable (~> 2.0)\n      jekyll (>= 3.5, < 5.0)\n      jekyll-sass-converter (>= 1.0, <= 3.0.0, != 2.0.0)\n      rubyzip (>= 1.3.0, < 3.0)\n    jekyll-sass-converter (1.5.2)\n      sass (~> 3.4)\n    jekyll-seo-tag (2.8.0)\n      jekyll (>= 3.8, < 5.0)\n    jekyll-sitemap (1.4.0)\n      jekyll (>= 3.7, < 5.0)\n    jekyll-swiss (1.0.0)\n    jekyll-theme-architect (0.2.0)\n      jekyll (> 3.5, < 5.0)\n      jekyll-seo-tag (~> 2.0)\n    jekyll-theme-cayman (0.2.0)\n      jekyll (> 3.5, < 5.0)\n      jekyll-seo-tag (~> 2.0)\n    jekyll-theme-dinky (0.2.0)\n      jekyll (> 3.5, < 5.0)\n      jekyll-seo-tag (~> 2.0)\n    jekyll-theme-hacker (0.2.0)\n      jekyll (> 3.5, < 5.0)\n      jekyll-seo-tag (~> 2.0)\n    jekyll-theme-leap-day (0.2.0)\n      jekyll (> 3.5, < 5.0)\n      jekyll-seo-tag (~> 2.0)\n    jekyll-theme-merlot (0.2.0)\n      jekyll (> 3.5, < 5.0)\n      jekyll-seo-tag (~> 2.0)\n    jekyll-theme-midnight (0.2.0)\n      jekyll (> 3.5, < 5.0)\n      jekyll-seo-tag (~> 2.0)\n    jekyll-theme-minimal (0.2.0)\n      jekyll (> 3.5, < 5.0)\n      jekyll-seo-tag (~> 2.0)\n    jekyll-theme-modernist (0.2.0)\n      jekyll (> 3.5, < 5.0)\n      jekyll-seo-tag (~> 2.0)\n    jekyll-theme-primer (0.6.0)\n      jekyll (> 3.5, < 5.0)\n      jekyll-github-metadata (~> 2.9)\n      jekyll-seo-tag (~> 2.0)\n    jekyll-theme-slate (0.2.0)\n      jekyll (> 3.5, < 5.0)\n      jekyll-seo-tag (~> 2.0)\n    jekyll-theme-tactile (0.2.0)\n      jekyll (> 3.5, < 5.0)\n      jekyll-seo-tag (~> 2.0)\n    jekyll-theme-time-machine (0.2.0)\n      jekyll (> 3.5, < 5.0)\n      jekyll-seo-tag (~> 2.0)\n    jekyll-titles-from-headings (0.5.3)\n      jekyll (>= 3.3, < 5.0)\n    jekyll-watch (2.2.1)\n      listen (~> 3.0)\n    jemoji (0.12.0)\n      gemoji (~> 3.0)\n      html-pipeline (~> 2.2)\n      jekyll (>= 3.0, < 5.0)\n    kramdown (2.3.2)\n      rexml\n    kramdown-parser-gfm (1.1.0)\n      kramdown (~> 2.0)\n    liquid (4.0.4)\n    listen (3.8.0)\n      rb-fsevent (~> 0.10, >= 0.10.3)\n      rb-inotify (~> 0.9, >= 0.9.10)\n    mercenary (0.3.6)\n    mini_portile2 (2.8.2)\n    minima (2.5.1)\n      jekyll (>= 3.5, < 5.0)\n      jekyll-feed (~> 0.9)\n      jekyll-seo-tag (~> 2.1)\n    minitest (5.18.0)\n    nokogiri (1.15.1)\n      mini_portile2 (~> 2.8.2)\n      racc (~> 1.4)\n    nokogiri (1.15.1-arm64-darwin)\n      racc (~> 1.4)\n    nokogiri (1.15.1-x86-mingw32)\n      racc (~> 1.4)\n    nokogiri (1.15.1-x86_64-linux)\n      racc (~> 1.4)\n    octokit (4.25.1)\n      faraday (>= 1, < 3)\n      sawyer (~> 0.9)\n    pathutil (0.16.2)\n      forwardable-extended (~> 2.6)\n    public_suffix (4.0.7)\n    racc (1.6.2)\n    rb-fsevent (0.11.2)\n    rb-inotify (0.10.1)\n      ffi (~> 1.0)\n    rexml (3.2.5)\n    rouge (3.26.0)\n    rspec (3.12.0)\n      rspec-core (~> 3.12.0)\n      rspec-expectations (~> 3.12.0)\n      rspec-mocks (~> 3.12.0)\n    rspec-core (3.12.2)\n      rspec-support (~> 3.12.0)\n    rspec-expectations (3.12.3)\n      diff-lcs (>= 1.2.0, < 2.0)\n      rspec-support (~> 3.12.0)\n    rspec-mocks (3.12.5)\n      diff-lcs (>= 1.2.0, < 2.0)\n      rspec-support (~> 3.12.0)\n    rspec-support (3.12.0)\n    ruby2_keywords (0.0.5)\n    rubyzip (2.3.2)\n    safe_yaml (1.0.5)\n    sass (3.7.4)\n      sass-listen (~> 4.0.0)\n    sass-listen (4.0.0)\n      rb-fsevent (~> 0.9, >= 0.9.4)\n      rb-inotify (~> 0.9, >= 0.9.7)\n    sawyer (0.9.2)\n      addressable (>= 2.3.5)\n      faraday (>= 0.17.3, < 3)\n    simpleidn (0.2.1)\n      unf (~> 0.1.4)\n    terminal-table (1.8.0)\n      unicode-display_width (~> 1.1, >= 1.1.1)\n    typhoeus (1.4.0)\n      ethon (>= 0.9.0)\n    tzinfo (2.0.6)\n      concurrent-ruby (~> 1.0)\n    unf (0.1.4)\n      unf_ext\n    unf_ext (0.0.8.2)\n    unf_ext (0.0.8.2-x86-mingw32)\n    unicode-display_width (1.8.0)\n    webrick (1.8.1)\n\nPLATFORMS\n  arm64-darwin-21\n  x86-mingw32\n  x86-mswin32-60\n  x86_64-linux\n\nDEPENDENCIES\n  github-pages\n  jekyll-theme-minimal\n  rspec\n  webrick\n\nBUNDLED WITH\n   2.2.33\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0439453125,
          "content": "MIT License\n\nCopyright (c) 2019 Connor Stack\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.1435546875,
          "content": "db: db.c\n\tgcc db.c -o db\n\nrun: db\n\t./db mydb.db\n\nclean:\n\trm -f db *.db\n\ntest: db\n\tbundle exec rspec\n\nformat: *.c\n\tclang-format -style=Google -i *.c"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.2001953125,
          "content": "# Let's Build a Simple Database\n\n[View rendered tutorial](https://cstack.github.io/db_tutorial/) (with more details on what this is.)\n\n## Notes to myself\n\nRun site locally:\n```\nbundle exec jekyll serve\n```"
        },
        {
          "name": "_config.yml",
          "type": "blob",
          "size": 0.2724609375,
          "content": "theme: jekyll-theme-minimal\ntitle: Let's Build a Simple Database\ndescription: Writing a sqlite clone from scratch in C\ngoogle_analytics: UA-105767942-1\ncollections:\n  parts:\n    output: true\ndefaults:\n  - scope:\n      path: \"\"\n      type: parts\n    values:\n      layout: default\n"
        },
        {
          "name": "_includes",
          "type": "tree",
          "content": null
        },
        {
          "name": "_layouts",
          "type": "tree",
          "content": null
        },
        {
          "name": "_parts",
          "type": "tree",
          "content": null
        },
        {
          "name": "assets",
          "type": "tree",
          "content": null
        },
        {
          "name": "db.c",
          "type": "blob",
          "size": 31.990234375,
          "content": "#include <errno.h>\n#include <fcntl.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\ntypedef struct {\n  char* buffer;\n  size_t buffer_length;\n  ssize_t input_length;\n} InputBuffer;\n\ntypedef enum {\n  EXECUTE_SUCCESS,\n  EXECUTE_DUPLICATE_KEY,\n} ExecuteResult;\n\ntypedef enum {\n  META_COMMAND_SUCCESS,\n  META_COMMAND_UNRECOGNIZED_COMMAND\n} MetaCommandResult;\n\ntypedef enum {\n  PREPARE_SUCCESS,\n  PREPARE_NEGATIVE_ID,\n  PREPARE_STRING_TOO_LONG,\n  PREPARE_SYNTAX_ERROR,\n  PREPARE_UNRECOGNIZED_STATEMENT\n} PrepareResult;\n\ntypedef enum { STATEMENT_INSERT, STATEMENT_SELECT } StatementType;\n\n#define COLUMN_USERNAME_SIZE 32\n#define COLUMN_EMAIL_SIZE 255\ntypedef struct {\n  uint32_t id;\n  char username[COLUMN_USERNAME_SIZE + 1];\n  char email[COLUMN_EMAIL_SIZE + 1];\n} Row;\n\ntypedef struct {\n  StatementType type;\n  Row row_to_insert;  // only used by insert statement\n} Statement;\n\n#define size_of_attribute(Struct, Attribute) sizeof(((Struct*)0)->Attribute)\n\nconst uint32_t ID_SIZE = size_of_attribute(Row, id);\nconst uint32_t USERNAME_SIZE = size_of_attribute(Row, username);\nconst uint32_t EMAIL_SIZE = size_of_attribute(Row, email);\nconst uint32_t ID_OFFSET = 0;\nconst uint32_t USERNAME_OFFSET = ID_OFFSET + ID_SIZE;\nconst uint32_t EMAIL_OFFSET = USERNAME_OFFSET + USERNAME_SIZE;\nconst uint32_t ROW_SIZE = ID_SIZE + USERNAME_SIZE + EMAIL_SIZE;\n\nconst uint32_t PAGE_SIZE = 4096;\n#define TABLE_MAX_PAGES 400\n\n#define INVALID_PAGE_NUM UINT32_MAX\n\ntypedef struct {\n  int file_descriptor;\n  uint32_t file_length;\n  uint32_t num_pages;\n  void* pages[TABLE_MAX_PAGES];\n} Pager;\n\ntypedef struct {\n  Pager* pager;\n  uint32_t root_page_num;\n} Table;\n\ntypedef struct {\n  Table* table;\n  uint32_t page_num;\n  uint32_t cell_num;\n  bool end_of_table;  // Indicates a position one past the last element\n} Cursor;\n\nvoid print_row(Row* row) {\n  printf(\"(%d, %s, %s)\\n\", row->id, row->username, row->email);\n}\n\ntypedef enum { NODE_INTERNAL, NODE_LEAF } NodeType;\n\n/*\n * Common Node Header Layout\n */\nconst uint32_t NODE_TYPE_SIZE = sizeof(uint8_t);\nconst uint32_t NODE_TYPE_OFFSET = 0;\nconst uint32_t IS_ROOT_SIZE = sizeof(uint8_t);\nconst uint32_t IS_ROOT_OFFSET = NODE_TYPE_SIZE;\nconst uint32_t PARENT_POINTER_SIZE = sizeof(uint32_t);\nconst uint32_t PARENT_POINTER_OFFSET = IS_ROOT_OFFSET + IS_ROOT_SIZE;\nconst uint8_t COMMON_NODE_HEADER_SIZE =\n    NODE_TYPE_SIZE + IS_ROOT_SIZE + PARENT_POINTER_SIZE;\n\n/*\n * Internal Node Header Layout\n */\nconst uint32_t INTERNAL_NODE_NUM_KEYS_SIZE = sizeof(uint32_t);\nconst uint32_t INTERNAL_NODE_NUM_KEYS_OFFSET = COMMON_NODE_HEADER_SIZE;\nconst uint32_t INTERNAL_NODE_RIGHT_CHILD_SIZE = sizeof(uint32_t);\nconst uint32_t INTERNAL_NODE_RIGHT_CHILD_OFFSET =\n    INTERNAL_NODE_NUM_KEYS_OFFSET + INTERNAL_NODE_NUM_KEYS_SIZE;\nconst uint32_t INTERNAL_NODE_HEADER_SIZE = COMMON_NODE_HEADER_SIZE +\n                                           INTERNAL_NODE_NUM_KEYS_SIZE +\n                                           INTERNAL_NODE_RIGHT_CHILD_SIZE;\n\n/*\n * Internal Node Body Layout\n */\nconst uint32_t INTERNAL_NODE_KEY_SIZE = sizeof(uint32_t);\nconst uint32_t INTERNAL_NODE_CHILD_SIZE = sizeof(uint32_t);\nconst uint32_t INTERNAL_NODE_CELL_SIZE =\n    INTERNAL_NODE_CHILD_SIZE + INTERNAL_NODE_KEY_SIZE;\n/* Keep this small for testing */\nconst uint32_t INTERNAL_NODE_MAX_KEYS = 3;\n\n/*\n * Leaf Node Header Layout\n */\nconst uint32_t LEAF_NODE_NUM_CELLS_SIZE = sizeof(uint32_t);\nconst uint32_t LEAF_NODE_NUM_CELLS_OFFSET = COMMON_NODE_HEADER_SIZE;\nconst uint32_t LEAF_NODE_NEXT_LEAF_SIZE = sizeof(uint32_t);\nconst uint32_t LEAF_NODE_NEXT_LEAF_OFFSET =\n    LEAF_NODE_NUM_CELLS_OFFSET + LEAF_NODE_NUM_CELLS_SIZE;\nconst uint32_t LEAF_NODE_HEADER_SIZE = COMMON_NODE_HEADER_SIZE +\n                                       LEAF_NODE_NUM_CELLS_SIZE +\n                                       LEAF_NODE_NEXT_LEAF_SIZE;\n\n/*\n * Leaf Node Body Layout\n */\nconst uint32_t LEAF_NODE_KEY_SIZE = sizeof(uint32_t);\nconst uint32_t LEAF_NODE_KEY_OFFSET = 0;\nconst uint32_t LEAF_NODE_VALUE_SIZE = ROW_SIZE;\nconst uint32_t LEAF_NODE_VALUE_OFFSET =\n    LEAF_NODE_KEY_OFFSET + LEAF_NODE_KEY_SIZE;\nconst uint32_t LEAF_NODE_CELL_SIZE = LEAF_NODE_KEY_SIZE + LEAF_NODE_VALUE_SIZE;\nconst uint32_t LEAF_NODE_SPACE_FOR_CELLS = PAGE_SIZE - LEAF_NODE_HEADER_SIZE;\nconst uint32_t LEAF_NODE_MAX_CELLS =\n    LEAF_NODE_SPACE_FOR_CELLS / LEAF_NODE_CELL_SIZE;\nconst uint32_t LEAF_NODE_RIGHT_SPLIT_COUNT = (LEAF_NODE_MAX_CELLS + 1) / 2;\nconst uint32_t LEAF_NODE_LEFT_SPLIT_COUNT =\n    (LEAF_NODE_MAX_CELLS + 1) - LEAF_NODE_RIGHT_SPLIT_COUNT;\n\nNodeType get_node_type(void* node) {\n  uint8_t value = *((uint8_t*)(node + NODE_TYPE_OFFSET));\n  return (NodeType)value;\n}\n\nvoid set_node_type(void* node, NodeType type) {\n  uint8_t value = type;\n  *((uint8_t*)(node + NODE_TYPE_OFFSET)) = value;\n}\n\nbool is_node_root(void* node) {\n  uint8_t value = *((uint8_t*)(node + IS_ROOT_OFFSET));\n  return (bool)value;\n}\n\nvoid set_node_root(void* node, bool is_root) {\n  uint8_t value = is_root;\n  *((uint8_t*)(node + IS_ROOT_OFFSET)) = value;\n}\n\nuint32_t* node_parent(void* node) { return node + PARENT_POINTER_OFFSET; }\n\nuint32_t* internal_node_num_keys(void* node) {\n  return node + INTERNAL_NODE_NUM_KEYS_OFFSET;\n}\n\nuint32_t* internal_node_right_child(void* node) {\n  return node + INTERNAL_NODE_RIGHT_CHILD_OFFSET;\n}\n\nuint32_t* internal_node_cell(void* node, uint32_t cell_num) {\n  return node + INTERNAL_NODE_HEADER_SIZE + cell_num * INTERNAL_NODE_CELL_SIZE;\n}\n\nuint32_t* internal_node_child(void* node, uint32_t child_num) {\n  uint32_t num_keys = *internal_node_num_keys(node);\n  if (child_num > num_keys) {\n    printf(\"Tried to access child_num %d > num_keys %d\\n\", child_num, num_keys);\n    exit(EXIT_FAILURE);\n  } else if (child_num == num_keys) {\n    uint32_t* right_child = internal_node_right_child(node);\n    if (*right_child == INVALID_PAGE_NUM) {\n      printf(\"Tried to access right child of node, but was invalid page\\n\");\n      exit(EXIT_FAILURE);\n    }\n    return right_child;\n  } else {\n    uint32_t* child = internal_node_cell(node, child_num);\n    if (*child == INVALID_PAGE_NUM) {\n      printf(\"Tried to access child %d of node, but was invalid page\\n\", child_num);\n      exit(EXIT_FAILURE);\n    }\n    return child;\n  }\n}\n\nuint32_t* internal_node_key(void* node, uint32_t key_num) {\n  return (void*)internal_node_cell(node, key_num) + INTERNAL_NODE_CHILD_SIZE;\n}\n\nuint32_t* leaf_node_num_cells(void* node) {\n  return node + LEAF_NODE_NUM_CELLS_OFFSET;\n}\n\nuint32_t* leaf_node_next_leaf(void* node) {\n  return node + LEAF_NODE_NEXT_LEAF_OFFSET;\n}\n\nvoid* leaf_node_cell(void* node, uint32_t cell_num) {\n  return node + LEAF_NODE_HEADER_SIZE + cell_num * LEAF_NODE_CELL_SIZE;\n}\n\nuint32_t* leaf_node_key(void* node, uint32_t cell_num) {\n  return leaf_node_cell(node, cell_num);\n}\n\nvoid* leaf_node_value(void* node, uint32_t cell_num) {\n  return leaf_node_cell(node, cell_num) + LEAF_NODE_KEY_SIZE;\n}\n\nvoid* get_page(Pager* pager, uint32_t page_num) {\n  if (page_num > TABLE_MAX_PAGES) {\n    printf(\"Tried to fetch page number out of bounds. %d > %d\\n\", page_num,\n           TABLE_MAX_PAGES);\n    exit(EXIT_FAILURE);\n  }\n\n  if (pager->pages[page_num] == NULL) {\n    // Cache miss. Allocate memory and load from file.\n    void* page = malloc(PAGE_SIZE);\n    uint32_t num_pages = pager->file_length / PAGE_SIZE;\n\n    // We might save a partial page at the end of the file\n    if (pager->file_length % PAGE_SIZE) {\n      num_pages += 1;\n    }\n\n    if (page_num <= num_pages) {\n      lseek(pager->file_descriptor, page_num * PAGE_SIZE, SEEK_SET);\n      ssize_t bytes_read = read(pager->file_descriptor, page, PAGE_SIZE);\n      if (bytes_read == -1) {\n        printf(\"Error reading file: %d\\n\", errno);\n        exit(EXIT_FAILURE);\n      }\n    }\n\n    pager->pages[page_num] = page;\n\n    if (page_num >= pager->num_pages) {\n      pager->num_pages = page_num + 1;\n    }\n  }\n\n  return pager->pages[page_num];\n}\n\nuint32_t get_node_max_key(Pager* pager, void* node) {\n  if (get_node_type(node) == NODE_LEAF) {\n    return *leaf_node_key(node, *leaf_node_num_cells(node) - 1);\n  }\n  void* right_child = get_page(pager,*internal_node_right_child(node));\n  return get_node_max_key(pager, right_child);\n}\n\nvoid print_constants() {\n  printf(\"ROW_SIZE: %d\\n\", ROW_SIZE);\n  printf(\"COMMON_NODE_HEADER_SIZE: %d\\n\", COMMON_NODE_HEADER_SIZE);\n  printf(\"LEAF_NODE_HEADER_SIZE: %d\\n\", LEAF_NODE_HEADER_SIZE);\n  printf(\"LEAF_NODE_CELL_SIZE: %d\\n\", LEAF_NODE_CELL_SIZE);\n  printf(\"LEAF_NODE_SPACE_FOR_CELLS: %d\\n\", LEAF_NODE_SPACE_FOR_CELLS);\n  printf(\"LEAF_NODE_MAX_CELLS: %d\\n\", LEAF_NODE_MAX_CELLS);\n}\n\nvoid indent(uint32_t level) {\n  for (uint32_t i = 0; i < level; i++) {\n    printf(\"  \");\n  }\n}\n\nvoid print_tree(Pager* pager, uint32_t page_num, uint32_t indentation_level) {\n  void* node = get_page(pager, page_num);\n  uint32_t num_keys, child;\n\n  switch (get_node_type(node)) {\n    case (NODE_LEAF):\n      num_keys = *leaf_node_num_cells(node);\n      indent(indentation_level);\n      printf(\"- leaf (size %d)\\n\", num_keys);\n      for (uint32_t i = 0; i < num_keys; i++) {\n        indent(indentation_level + 1);\n        printf(\"- %d\\n\", *leaf_node_key(node, i));\n      }\n      break;\n    case (NODE_INTERNAL):\n      num_keys = *internal_node_num_keys(node);\n      indent(indentation_level);\n      printf(\"- internal (size %d)\\n\", num_keys);\n      if (num_keys > 0) {\n        for (uint32_t i = 0; i < num_keys; i++) {\n          child = *internal_node_child(node, i);\n          print_tree(pager, child, indentation_level + 1);\n\n          indent(indentation_level + 1);\n          printf(\"- key %d\\n\", *internal_node_key(node, i));\n        }\n        child = *internal_node_right_child(node);\n        print_tree(pager, child, indentation_level + 1);\n      }\n      break;\n  }\n}\n\nvoid serialize_row(Row* source, void* destination) {\n  memcpy(destination + ID_OFFSET, &(source->id), ID_SIZE);\n  memcpy(destination + USERNAME_OFFSET, &(source->username), USERNAME_SIZE);\n  memcpy(destination + EMAIL_OFFSET, &(source->email), EMAIL_SIZE);\n}\n\nvoid deserialize_row(void* source, Row* destination) {\n  memcpy(&(destination->id), source + ID_OFFSET, ID_SIZE);\n  memcpy(&(destination->username), source + USERNAME_OFFSET, USERNAME_SIZE);\n  memcpy(&(destination->email), source + EMAIL_OFFSET, EMAIL_SIZE);\n}\n\nvoid initialize_leaf_node(void* node) {\n  set_node_type(node, NODE_LEAF);\n  set_node_root(node, false);\n  *leaf_node_num_cells(node) = 0;\n  *leaf_node_next_leaf(node) = 0;  // 0 represents no sibling\n}\n\nvoid initialize_internal_node(void* node) {\n  set_node_type(node, NODE_INTERNAL);\n  set_node_root(node, false);\n  *internal_node_num_keys(node) = 0;\n  /*\n  Necessary because the root page number is 0; by not initializing an internal \n  node's right child to an invalid page number when initializing the node, we may\n  end up with 0 as the node's right child, which makes the node a parent of the root\n  */\n  *internal_node_right_child(node) = INVALID_PAGE_NUM;\n}\n\nCursor* leaf_node_find(Table* table, uint32_t page_num, uint32_t key) {\n  void* node = get_page(table->pager, page_num);\n  uint32_t num_cells = *leaf_node_num_cells(node);\n\n  Cursor* cursor = malloc(sizeof(Cursor));\n  cursor->table = table;\n  cursor->page_num = page_num;\n  cursor->end_of_table = false;\n\n  // Binary search\n  uint32_t min_index = 0;\n  uint32_t one_past_max_index = num_cells;\n  while (one_past_max_index != min_index) {\n    uint32_t index = (min_index + one_past_max_index) / 2;\n    uint32_t key_at_index = *leaf_node_key(node, index);\n    if (key == key_at_index) {\n      cursor->cell_num = index;\n      return cursor;\n    }\n    if (key < key_at_index) {\n      one_past_max_index = index;\n    } else {\n      min_index = index + 1;\n    }\n  }\n\n  cursor->cell_num = min_index;\n  return cursor;\n}\n\nuint32_t internal_node_find_child(void* node, uint32_t key) {\n  /*\n  Return the index of the child which should contain\n  the given key.\n  */\n\n  uint32_t num_keys = *internal_node_num_keys(node);\n\n  /* Binary search */\n  uint32_t min_index = 0;\n  uint32_t max_index = num_keys; /* there is one more child than key */\n\n  while (min_index != max_index) {\n    uint32_t index = (min_index + max_index) / 2;\n    uint32_t key_to_right = *internal_node_key(node, index);\n    if (key_to_right >= key) {\n      max_index = index;\n    } else {\n      min_index = index + 1;\n    }\n  }\n\n  return min_index;\n}\n\nCursor* internal_node_find(Table* table, uint32_t page_num, uint32_t key) {\n  void* node = get_page(table->pager, page_num);\n\n  uint32_t child_index = internal_node_find_child(node, key);\n  uint32_t child_num = *internal_node_child(node, child_index);\n  void* child = get_page(table->pager, child_num);\n  switch (get_node_type(child)) {\n    case NODE_LEAF:\n      return leaf_node_find(table, child_num, key);\n    case NODE_INTERNAL:\n      return internal_node_find(table, child_num, key);\n  }\n}\n\n/*\nReturn the position of the given key.\nIf the key is not present, return the position\nwhere it should be inserted\n*/\nCursor* table_find(Table* table, uint32_t key) {\n  uint32_t root_page_num = table->root_page_num;\n  void* root_node = get_page(table->pager, root_page_num);\n\n  if (get_node_type(root_node) == NODE_LEAF) {\n    return leaf_node_find(table, root_page_num, key);\n  } else {\n    return internal_node_find(table, root_page_num, key);\n  }\n}\n\nCursor* table_start(Table* table) {\n  Cursor* cursor = table_find(table, 0);\n\n  void* node = get_page(table->pager, cursor->page_num);\n  uint32_t num_cells = *leaf_node_num_cells(node);\n  cursor->end_of_table = (num_cells == 0);\n\n  return cursor;\n}\n\nvoid* cursor_value(Cursor* cursor) {\n  uint32_t page_num = cursor->page_num;\n  void* page = get_page(cursor->table->pager, page_num);\n  return leaf_node_value(page, cursor->cell_num);\n}\n\nvoid cursor_advance(Cursor* cursor) {\n  uint32_t page_num = cursor->page_num;\n  void* node = get_page(cursor->table->pager, page_num);\n\n  cursor->cell_num += 1;\n  if (cursor->cell_num >= (*leaf_node_num_cells(node))) {\n    /* Advance to next leaf node */\n    uint32_t next_page_num = *leaf_node_next_leaf(node);\n    if (next_page_num == 0) {\n      /* This was rightmost leaf */\n      cursor->end_of_table = true;\n    } else {\n      cursor->page_num = next_page_num;\n      cursor->cell_num = 0;\n    }\n  }\n}\n\nPager* pager_open(const char* filename) {\n  int fd = open(filename,\n                O_RDWR |      // Read/Write mode\n                    O_CREAT,  // Create file if it does not exist\n                S_IWUSR |     // User write permission\n                    S_IRUSR   // User read permission\n                );\n\n  if (fd == -1) {\n    printf(\"Unable to open file\\n\");\n    exit(EXIT_FAILURE);\n  }\n\n  off_t file_length = lseek(fd, 0, SEEK_END);\n\n  Pager* pager = malloc(sizeof(Pager));\n  pager->file_descriptor = fd;\n  pager->file_length = file_length;\n  pager->num_pages = (file_length / PAGE_SIZE);\n\n  if (file_length % PAGE_SIZE != 0) {\n    printf(\"Db file is not a whole number of pages. Corrupt file.\\n\");\n    exit(EXIT_FAILURE);\n  }\n\n  for (uint32_t i = 0; i < TABLE_MAX_PAGES; i++) {\n    pager->pages[i] = NULL;\n  }\n\n  return pager;\n}\n\nTable* db_open(const char* filename) {\n  Pager* pager = pager_open(filename);\n\n  Table* table = malloc(sizeof(Table));\n  table->pager = pager;\n  table->root_page_num = 0;\n\n  if (pager->num_pages == 0) {\n    // New database file. Initialize page 0 as leaf node.\n    void* root_node = get_page(pager, 0);\n    initialize_leaf_node(root_node);\n    set_node_root(root_node, true);\n  }\n\n  return table;\n}\n\nInputBuffer* new_input_buffer() {\n  InputBuffer* input_buffer = malloc(sizeof(InputBuffer));\n  input_buffer->buffer = NULL;\n  input_buffer->buffer_length = 0;\n  input_buffer->input_length = 0;\n\n  return input_buffer;\n}\n\nvoid print_prompt() { printf(\"db > \"); }\n\nvoid read_input(InputBuffer* input_buffer) {\n  ssize_t bytes_read =\n      getline(&(input_buffer->buffer), &(input_buffer->buffer_length), stdin);\n\n  if (bytes_read <= 0) {\n    printf(\"Error reading input\\n\");\n    exit(EXIT_FAILURE);\n  }\n\n  // Ignore trailing newline\n  input_buffer->input_length = bytes_read - 1;\n  input_buffer->buffer[bytes_read - 1] = 0;\n}\n\nvoid close_input_buffer(InputBuffer* input_buffer) {\n  free(input_buffer->buffer);\n  free(input_buffer);\n}\n\nvoid pager_flush(Pager* pager, uint32_t page_num) {\n  if (pager->pages[page_num] == NULL) {\n    printf(\"Tried to flush null page\\n\");\n    exit(EXIT_FAILURE);\n  }\n\n  off_t offset = lseek(pager->file_descriptor, page_num * PAGE_SIZE, SEEK_SET);\n\n  if (offset == -1) {\n    printf(\"Error seeking: %d\\n\", errno);\n    exit(EXIT_FAILURE);\n  }\n\n  ssize_t bytes_written =\n      write(pager->file_descriptor, pager->pages[page_num], PAGE_SIZE);\n\n  if (bytes_written == -1) {\n    printf(\"Error writing: %d\\n\", errno);\n    exit(EXIT_FAILURE);\n  }\n}\n\nvoid db_close(Table* table) {\n  Pager* pager = table->pager;\n\n  for (uint32_t i = 0; i < pager->num_pages; i++) {\n    if (pager->pages[i] == NULL) {\n      continue;\n    }\n    pager_flush(pager, i);\n    free(pager->pages[i]);\n    pager->pages[i] = NULL;\n  }\n\n  int result = close(pager->file_descriptor);\n  if (result == -1) {\n    printf(\"Error closing db file.\\n\");\n    exit(EXIT_FAILURE);\n  }\n  for (uint32_t i = 0; i < TABLE_MAX_PAGES; i++) {\n    void* page = pager->pages[i];\n    if (page) {\n      free(page);\n      pager->pages[i] = NULL;\n    }\n  }\n  free(pager);\n  free(table);\n}\n\nMetaCommandResult do_meta_command(InputBuffer* input_buffer, Table* table) {\n  if (strcmp(input_buffer->buffer, \".exit\") == 0) {\n    close_input_buffer(input_buffer);\n    db_close(table);\n    exit(EXIT_SUCCESS);\n  } else if (strcmp(input_buffer->buffer, \".btree\") == 0) {\n    printf(\"Tree:\\n\");\n    print_tree(table->pager, 0, 0);\n    return META_COMMAND_SUCCESS;\n  } else if (strcmp(input_buffer->buffer, \".constants\") == 0) {\n    printf(\"Constants:\\n\");\n    print_constants();\n    return META_COMMAND_SUCCESS;\n  } else {\n    return META_COMMAND_UNRECOGNIZED_COMMAND;\n  }\n}\n\nPrepareResult prepare_insert(InputBuffer* input_buffer, Statement* statement) {\n  statement->type = STATEMENT_INSERT;\n\n  char* keyword = strtok(input_buffer->buffer, \" \");\n  char* id_string = strtok(NULL, \" \");\n  char* username = strtok(NULL, \" \");\n  char* email = strtok(NULL, \" \");\n\n  if (id_string == NULL || username == NULL || email == NULL) {\n    return PREPARE_SYNTAX_ERROR;\n  }\n\n  int id = atoi(id_string);\n  if (id < 0) {\n    return PREPARE_NEGATIVE_ID;\n  }\n  if (strlen(username) > COLUMN_USERNAME_SIZE) {\n    return PREPARE_STRING_TOO_LONG;\n  }\n  if (strlen(email) > COLUMN_EMAIL_SIZE) {\n    return PREPARE_STRING_TOO_LONG;\n  }\n\n  statement->row_to_insert.id = id;\n  strcpy(statement->row_to_insert.username, username);\n  strcpy(statement->row_to_insert.email, email);\n\n  return PREPARE_SUCCESS;\n}\n\nPrepareResult prepare_statement(InputBuffer* input_buffer,\n                                Statement* statement) {\n  if (strncmp(input_buffer->buffer, \"insert\", 6) == 0) {\n    return prepare_insert(input_buffer, statement);\n  }\n  if (strcmp(input_buffer->buffer, \"select\") == 0) {\n    statement->type = STATEMENT_SELECT;\n    return PREPARE_SUCCESS;\n  }\n\n  return PREPARE_UNRECOGNIZED_STATEMENT;\n}\n\n/*\nUntil we start recycling free pages, new pages will always\ngo onto the end of the database file\n*/\nuint32_t get_unused_page_num(Pager* pager) { return pager->num_pages; }\n\nvoid create_new_root(Table* table, uint32_t right_child_page_num) {\n  /*\n  Handle splitting the root.\n  Old root copied to new page, becomes left child.\n  Address of right child passed in.\n  Re-initialize root page to contain the new root node.\n  New root node points to two children.\n  */\n\n  void* root = get_page(table->pager, table->root_page_num);\n  void* right_child = get_page(table->pager, right_child_page_num);\n  uint32_t left_child_page_num = get_unused_page_num(table->pager);\n  void* left_child = get_page(table->pager, left_child_page_num);\n\n  if (get_node_type(root) == NODE_INTERNAL) {\n    initialize_internal_node(right_child);\n    initialize_internal_node(left_child);\n  }\n\n  /* Left child has data copied from old root */\n  memcpy(left_child, root, PAGE_SIZE);\n  set_node_root(left_child, false);\n\n  if (get_node_type(left_child) == NODE_INTERNAL) {\n    void* child;\n    for (int i = 0; i < *internal_node_num_keys(left_child); i++) {\n      child = get_page(table->pager, *internal_node_child(left_child,i));\n      *node_parent(child) = left_child_page_num;\n    }\n    child = get_page(table->pager, *internal_node_right_child(left_child));\n    *node_parent(child) = left_child_page_num;\n  }\n\n  /* Root node is a new internal node with one key and two children */\n  initialize_internal_node(root);\n  set_node_root(root, true);\n  *internal_node_num_keys(root) = 1;\n  *internal_node_child(root, 0) = left_child_page_num;\n  uint32_t left_child_max_key = get_node_max_key(table->pager, left_child);\n  *internal_node_key(root, 0) = left_child_max_key;\n  *internal_node_right_child(root) = right_child_page_num;\n  *node_parent(left_child) = table->root_page_num;\n  *node_parent(right_child) = table->root_page_num;\n}\n\nvoid internal_node_split_and_insert(Table* table, uint32_t parent_page_num,\n                          uint32_t child_page_num);\n\nvoid internal_node_insert(Table* table, uint32_t parent_page_num,\n                          uint32_t child_page_num) {\n  /*\n  Add a new child/key pair to parent that corresponds to child\n  */\n\n  void* parent = get_page(table->pager, parent_page_num);\n  void* child = get_page(table->pager, child_page_num);\n  uint32_t child_max_key = get_node_max_key(table->pager, child);\n  uint32_t index = internal_node_find_child(parent, child_max_key);\n\n  uint32_t original_num_keys = *internal_node_num_keys(parent);\n\n  if (original_num_keys >= INTERNAL_NODE_MAX_KEYS) {\n    internal_node_split_and_insert(table, parent_page_num, child_page_num);\n    return;\n  }\n\n  uint32_t right_child_page_num = *internal_node_right_child(parent);\n  /*\n  An internal node with a right child of INVALID_PAGE_NUM is empty\n  */\n  if (right_child_page_num == INVALID_PAGE_NUM) {\n    *internal_node_right_child(parent) = child_page_num;\n    return;\n  }\n\n  void* right_child = get_page(table->pager, right_child_page_num);\n  /*\n  If we are already at the max number of cells for a node, we cannot increment\n  before splitting. Incrementing without inserting a new key/child pair\n  and immediately calling internal_node_split_and_insert has the effect\n  of creating a new key at (max_cells + 1) with an uninitialized value\n  */\n  *internal_node_num_keys(parent) = original_num_keys + 1;\n\n  if (child_max_key > get_node_max_key(table->pager, right_child)) {\n    /* Replace right child */\n    *internal_node_child(parent, original_num_keys) = right_child_page_num;\n    *internal_node_key(parent, original_num_keys) =\n        get_node_max_key(table->pager, right_child);\n    *internal_node_right_child(parent) = child_page_num;\n  } else {\n    /* Make room for the new cell */\n    for (uint32_t i = original_num_keys; i > index; i--) {\n      void* destination = internal_node_cell(parent, i);\n      void* source = internal_node_cell(parent, i - 1);\n      memcpy(destination, source, INTERNAL_NODE_CELL_SIZE);\n    }\n    *internal_node_child(parent, index) = child_page_num;\n    *internal_node_key(parent, index) = child_max_key;\n  }\n}\n\nvoid update_internal_node_key(void* node, uint32_t old_key, uint32_t new_key) {\n  uint32_t old_child_index = internal_node_find_child(node, old_key);\n  *internal_node_key(node, old_child_index) = new_key;\n}\n\nvoid internal_node_split_and_insert(Table* table, uint32_t parent_page_num,\n                          uint32_t child_page_num) {\n  uint32_t old_page_num = parent_page_num;\n  void* old_node = get_page(table->pager,parent_page_num);\n  uint32_t old_max = get_node_max_key(table->pager, old_node);\n\n  void* child = get_page(table->pager, child_page_num); \n  uint32_t child_max = get_node_max_key(table->pager, child);\n\n  uint32_t new_page_num = get_unused_page_num(table->pager);\n\n  /*\n  Declaring a flag before updating pointers which\n  records whether this operation involves splitting the root -\n  if it does, we will insert our newly created node during\n  the step where the table's new root is created. If it does\n  not, we have to insert the newly created node into its parent\n  after the old node's keys have been transferred over. We are not\n  able to do this if the newly created node's parent is not a newly\n  initialized root node, because in that case its parent may have existing\n  keys aside from our old node which we are splitting. If that is true, we\n  need to find a place for our newly created node in its parent, and we\n  cannot insert it at the correct index if it does not yet have any keys\n  */\n  uint32_t splitting_root = is_node_root(old_node);\n\n  void* parent;\n  void* new_node;\n  if (splitting_root) {\n    create_new_root(table, new_page_num);\n    parent = get_page(table->pager,table->root_page_num);\n    /*\n    If we are splitting the root, we need to update old_node to point\n    to the new root's left child, new_page_num will already point to\n    the new root's right child\n    */\n    old_page_num = *internal_node_child(parent,0);\n    old_node = get_page(table->pager, old_page_num);\n  } else {\n    parent = get_page(table->pager,*node_parent(old_node));\n    new_node = get_page(table->pager, new_page_num);\n    initialize_internal_node(new_node);\n  }\n  \n  uint32_t* old_num_keys = internal_node_num_keys(old_node);\n\n  uint32_t cur_page_num = *internal_node_right_child(old_node);\n  void* cur = get_page(table->pager, cur_page_num);\n\n  /*\n  First put right child into new node and set right child of old node to invalid page number\n  */\n  internal_node_insert(table, new_page_num, cur_page_num);\n  *node_parent(cur) = new_page_num;\n  *internal_node_right_child(old_node) = INVALID_PAGE_NUM;\n  /*\n  For each key until you get to the middle key, move the key and the child to the new node\n  */\n  for (int i = INTERNAL_NODE_MAX_KEYS - 1; i > INTERNAL_NODE_MAX_KEYS / 2; i--) {\n    cur_page_num = *internal_node_child(old_node, i);\n    cur = get_page(table->pager, cur_page_num);\n\n    internal_node_insert(table, new_page_num, cur_page_num);\n    *node_parent(cur) = new_page_num;\n\n    (*old_num_keys)--;\n  }\n\n  /*\n  Set child before middle key, which is now the highest key, to be node's right child,\n  and decrement number of keys\n  */\n  *internal_node_right_child(old_node) = *internal_node_child(old_node,*old_num_keys - 1);\n  (*old_num_keys)--;\n\n  /*\n  Determine which of the two nodes after the split should contain the child to be inserted,\n  and insert the child\n  */\n  uint32_t max_after_split = get_node_max_key(table->pager, old_node);\n\n  uint32_t destination_page_num = child_max < max_after_split ? old_page_num : new_page_num;\n\n  internal_node_insert(table, destination_page_num, child_page_num);\n  *node_parent(child) = destination_page_num;\n\n  update_internal_node_key(parent, old_max, get_node_max_key(table->pager, old_node));\n\n  if (!splitting_root) {\n    internal_node_insert(table,*node_parent(old_node),new_page_num);\n    *node_parent(new_node) = *node_parent(old_node);\n  }\n}\n\nvoid leaf_node_split_and_insert(Cursor* cursor, uint32_t key, Row* value) {\n  /*\n  Create a new node and move half the cells over.\n  Insert the new value in one of the two nodes.\n  Update parent or create a new parent.\n  */\n\n  void* old_node = get_page(cursor->table->pager, cursor->page_num);\n  uint32_t old_max = get_node_max_key(cursor->table->pager, old_node);\n  uint32_t new_page_num = get_unused_page_num(cursor->table->pager);\n  void* new_node = get_page(cursor->table->pager, new_page_num);\n  initialize_leaf_node(new_node);\n  *node_parent(new_node) = *node_parent(old_node);\n  *leaf_node_next_leaf(new_node) = *leaf_node_next_leaf(old_node);\n  *leaf_node_next_leaf(old_node) = new_page_num;\n\n  /*\n  All existing keys plus new key should should be divided\n  evenly between old (left) and new (right) nodes.\n  Starting from the right, move each key to correct position.\n  */\n  for (int32_t i = LEAF_NODE_MAX_CELLS; i >= 0; i--) {\n    void* destination_node;\n    if (i >= LEAF_NODE_LEFT_SPLIT_COUNT) {\n      destination_node = new_node;\n    } else {\n      destination_node = old_node;\n    }\n    uint32_t index_within_node = i % LEAF_NODE_LEFT_SPLIT_COUNT;\n    void* destination = leaf_node_cell(destination_node, index_within_node);\n\n    if (i == cursor->cell_num) {\n      serialize_row(value,\n                    leaf_node_value(destination_node, index_within_node));\n      *leaf_node_key(destination_node, index_within_node) = key;\n    } else if (i > cursor->cell_num) {\n      memcpy(destination, leaf_node_cell(old_node, i - 1), LEAF_NODE_CELL_SIZE);\n    } else {\n      memcpy(destination, leaf_node_cell(old_node, i), LEAF_NODE_CELL_SIZE);\n    }\n  }\n\n  /* Update cell count on both leaf nodes */\n  *(leaf_node_num_cells(old_node)) = LEAF_NODE_LEFT_SPLIT_COUNT;\n  *(leaf_node_num_cells(new_node)) = LEAF_NODE_RIGHT_SPLIT_COUNT;\n\n  if (is_node_root(old_node)) {\n    return create_new_root(cursor->table, new_page_num);\n  } else {\n    uint32_t parent_page_num = *node_parent(old_node);\n    uint32_t new_max = get_node_max_key(cursor->table->pager, old_node);\n    void* parent = get_page(cursor->table->pager, parent_page_num);\n\n    update_internal_node_key(parent, old_max, new_max);\n    internal_node_insert(cursor->table, parent_page_num, new_page_num);\n    return;\n  }\n}\n\nvoid leaf_node_insert(Cursor* cursor, uint32_t key, Row* value) {\n  void* node = get_page(cursor->table->pager, cursor->page_num);\n\n  uint32_t num_cells = *leaf_node_num_cells(node);\n  if (num_cells >= LEAF_NODE_MAX_CELLS) {\n    // Node full\n    leaf_node_split_and_insert(cursor, key, value);\n    return;\n  }\n\n  if (cursor->cell_num < num_cells) {\n    // Make room for new cell\n    for (uint32_t i = num_cells; i > cursor->cell_num; i--) {\n      memcpy(leaf_node_cell(node, i), leaf_node_cell(node, i - 1),\n             LEAF_NODE_CELL_SIZE);\n    }\n  }\n\n  *(leaf_node_num_cells(node)) += 1;\n  *(leaf_node_key(node, cursor->cell_num)) = key;\n  serialize_row(value, leaf_node_value(node, cursor->cell_num));\n}\n\nExecuteResult execute_insert(Statement* statement, Table* table) {\n  Row* row_to_insert = &(statement->row_to_insert);\n  uint32_t key_to_insert = row_to_insert->id;\n  Cursor* cursor = table_find(table, key_to_insert);\n\n  void* node = get_page(table->pager, cursor->page_num);\n  uint32_t num_cells = *leaf_node_num_cells(node);\n\n  if (cursor->cell_num < num_cells) {\n    uint32_t key_at_index = *leaf_node_key(node, cursor->cell_num);\n    if (key_at_index == key_to_insert) {\n      return EXECUTE_DUPLICATE_KEY;\n    }\n  }\n\n  leaf_node_insert(cursor, row_to_insert->id, row_to_insert);\n\n  free(cursor);\n\n  return EXECUTE_SUCCESS;\n}\n\nExecuteResult execute_select(Statement* statement, Table* table) {\n  Cursor* cursor = table_start(table);\n\n  Row row;\n  while (!(cursor->end_of_table)) {\n    deserialize_row(cursor_value(cursor), &row);\n    print_row(&row);\n    cursor_advance(cursor);\n  }\n\n  free(cursor);\n\n  return EXECUTE_SUCCESS;\n}\n\nExecuteResult execute_statement(Statement* statement, Table* table) {\n  switch (statement->type) {\n    case (STATEMENT_INSERT):\n      return execute_insert(statement, table);\n    case (STATEMENT_SELECT):\n      return execute_select(statement, table);\n  }\n}\n\nint main(int argc, char* argv[]) {\n  if (argc < 2) {\n    printf(\"Must supply a database filename.\\n\");\n    exit(EXIT_FAILURE);\n  }\n\n  char* filename = argv[1];\n  Table* table = db_open(filename);\n\n  InputBuffer* input_buffer = new_input_buffer();\n  while (true) {\n    print_prompt();\n    read_input(input_buffer);\n\n    if (input_buffer->buffer[0] == '.') {\n      switch (do_meta_command(input_buffer, table)) {\n        case (META_COMMAND_SUCCESS):\n          continue;\n        case (META_COMMAND_UNRECOGNIZED_COMMAND):\n          printf(\"Unrecognized command '%s'\\n\", input_buffer->buffer);\n          continue;\n      }\n    }\n\n    Statement statement;\n    switch (prepare_statement(input_buffer, &statement)) {\n      case (PREPARE_SUCCESS):\n        break;\n      case (PREPARE_NEGATIVE_ID):\n        printf(\"ID must be positive.\\n\");\n        continue;\n      case (PREPARE_STRING_TOO_LONG):\n        printf(\"String is too long.\\n\");\n        continue;\n      case (PREPARE_SYNTAX_ERROR):\n        printf(\"Syntax error. Could not parse statement.\\n\");\n        continue;\n      case (PREPARE_UNRECOGNIZED_STATEMENT):\n        printf(\"Unrecognized keyword at start of '%s'.\\n\",\n               input_buffer->buffer);\n        continue;\n    }\n\n    switch (execute_statement(&statement, table)) {\n      case (EXECUTE_SUCCESS):\n        printf(\"Executed.\\n\");\n        break;\n      case (EXECUTE_DUPLICATE_KEY):\n        printf(\"Error: Duplicate key.\\n\");\n        break;\n    }\n  }\n}\n"
        },
        {
          "name": "feed.xml",
          "type": "blob",
          "size": 0.9248046875,
          "content": "---\nlayout: none\n---\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<rss version=\"2.0\" xmlns:atom=\"http://www.w3.org/2005/Atom\">\n  <channel>\n    <title>{{ site.title | xml_escape }}</title>\n    <description>{{ site.description | xml_escape }}</description>\n    <link>{{site.url}}{{site.baseurl}}</link>\n    <atom:link href=\"{{site.url}}{{site.baseurl}}/feed.xml\" rel=\"self\" type=\"application/rss+xml\" />\n    {% assign limit = 10 %}\n    {% assign offset = (site.parts.size | minus: limit) %}\n    {% for part in site.parts offset:offset limit:limit %}\n      <item>\n        <title>{{ part.title | xml_escape }}</title>\n        <description>{{ part.content | xml_escape }}</description>\n        <pubDate>{{ part.date | date: \"%a, %d %b %Y %H:%M:%S %z\" }}</pubDate>\n        <link>{{site.url}}{{site.baseurl}}{{part.url}}</link>\n        <guid isPermaLink=\"true\">{{site.url}}{{site.baseurl}}{{part.url}}</guid>\n      </item>\n    {% endfor %}\n  </channel>\n</rss>\n"
        },
        {
          "name": "index.md",
          "type": "blob",
          "size": 0.8857421875,
          "content": "---\ntitle: How Does a Database Work?\n---\n\n- What format is data saved in? (in memory and on disk)\n- When does it move from memory to disk?\n- Why can there only be one primary key per table?\n- How does rolling back a transaction work?\n- How are indexes formatted?\n- When and how does a full table scan happen?\n- What format is a prepared statement saved in?\n\nIn short, how does a database **work**?\n\nI'm building a clone of [sqlite](https://www.sqlite.org/arch.html) from scratch in C in order to understand, and I'm going to document my process as I go.\n\n# Table of Contents\n{% for part in site.parts %}- [{{part.title}}]({{site.baseurl}}{{part.url}})\n{% endfor %}\n\n> \"What I cannot create, I do not understand.\" -- [Richard Feynman](https://en.m.wikiquote.org/wiki/Richard_Feynman)\n\n{% include image.html url=\"assets/images/arch2.gif\" description=\"sqlite architecture (https://www.sqlite.org/arch.html)\" %}"
        },
        {
          "name": "spec",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}