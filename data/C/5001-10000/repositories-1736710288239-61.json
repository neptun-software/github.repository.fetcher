{
  "metadata": {
    "timestamp": 1736710288239,
    "page": 61,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjcw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "antirez/kilo",
      "stars": 7523,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0048828125,
          "content": "kilo\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.298828125,
          "content": "Copyright (c) 2016, Salvatore Sanfilippo <antirez at gmail dot com>\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice,\n  this list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.0888671875,
          "content": "all: kilo\n\nkilo: kilo.c\n\t$(CC) -o kilo kilo.c -Wall -W -pedantic -std=c99\n\nclean:\n\trm kilo\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.80859375,
          "content": "Kilo\n===\n\nKilo is a small text editor in less than 1K lines of code (counted with cloc).\n\nA screencast is available here: https://asciinema.org/a/90r2i9bq8po03nazhqtsifksb\n\nUsage: kilo `<filename>`\n\nKeys:\n\n    CTRL-S: Save\n    CTRL-Q: Quit\n    CTRL-F: Find string in file (ESC to exit search, arrows to navigate)\n\nKilo does not depend on any library (not even curses). It uses fairly standard\nVT100 (and similar terminals) escape sequences. The project is in alpha\nstage and was written in just a few hours taking code from my other two\nprojects, load81 and linenoise.\n\nPeople are encouraged to use it as a starting point to write other editors\nor command line interfaces that are more advanced than the usual REPL\nstyle CLI.\n\nKilo was written by Salvatore Sanfilippo aka antirez and is released\nunder the BSD 2 clause license.\n"
        },
        {
          "name": "TODO",
          "type": "blob",
          "size": 0.19921875,
          "content": "IMPORTANT\n===\n\n* Testing and stability to reach \"usable\" level.\n\nMAYBE\n===\n\n* Send alternate screen sequences if TERM=xterm: \"\\033[?1049h\" and \"\\033[?1049l\"\n* Improve internals to be more understandable.\n"
        },
        {
          "name": "kilo.c",
          "type": "blob",
          "size": 40.626953125,
          "content": "/* Kilo -- A very simple editor in less than 1-kilo lines of code (as counted\n *         by \"cloc\"). Does not depend on libcurses, directly emits VT100\n *         escapes on the terminal.\n *\n * -----------------------------------------------------------------------\n *\n * Copyright (C) 2016 Salvatore Sanfilippo <antirez at gmail dot com>\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *  *  Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n *\n *  *  Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#define KILO_VERSION \"0.0.1\"\n\n#ifdef __linux__\n#define _POSIX_C_SOURCE 200809L\n#endif\n\n#include <termios.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <errno.h>\n#include <string.h>\n#include <ctype.h>\n#include <time.h>\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <sys/time.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <signal.h>\n\n/* Syntax highlight types */\n#define HL_NORMAL 0\n#define HL_NONPRINT 1\n#define HL_COMMENT 2   /* Single line comment. */\n#define HL_MLCOMMENT 3 /* Multi-line comment. */\n#define HL_KEYWORD1 4\n#define HL_KEYWORD2 5\n#define HL_STRING 6\n#define HL_NUMBER 7\n#define HL_MATCH 8      /* Search match. */\n\n#define HL_HIGHLIGHT_STRINGS (1<<0)\n#define HL_HIGHLIGHT_NUMBERS (1<<1)\n\nstruct editorSyntax {\n    char **filematch;\n    char **keywords;\n    char singleline_comment_start[2];\n    char multiline_comment_start[3];\n    char multiline_comment_end[3];\n    int flags;\n};\n\n/* This structure represents a single line of the file we are editing. */\ntypedef struct erow {\n    int idx;            /* Row index in the file, zero-based. */\n    int size;           /* Size of the row, excluding the null term. */\n    int rsize;          /* Size of the rendered row. */\n    char *chars;        /* Row content. */\n    char *render;       /* Row content \"rendered\" for screen (for TABs). */\n    unsigned char *hl;  /* Syntax highlight type for each character in render.*/\n    int hl_oc;          /* Row had open comment at end in last syntax highlight\n                           check. */\n} erow;\n\ntypedef struct hlcolor {\n    int r,g,b;\n} hlcolor;\n\nstruct editorConfig {\n    int cx,cy;  /* Cursor x and y position in characters */\n    int rowoff;     /* Offset of row displayed. */\n    int coloff;     /* Offset of column displayed. */\n    int screenrows; /* Number of rows that we can show */\n    int screencols; /* Number of cols that we can show */\n    int numrows;    /* Number of rows */\n    int rawmode;    /* Is terminal raw mode enabled? */\n    erow *row;      /* Rows */\n    int dirty;      /* File modified but not saved. */\n    char *filename; /* Currently open filename */\n    char statusmsg[80];\n    time_t statusmsg_time;\n    struct editorSyntax *syntax;    /* Current syntax highlight, or NULL. */\n};\n\nstatic struct editorConfig E;\n\nenum KEY_ACTION{\n        KEY_NULL = 0,       /* NULL */\n        CTRL_C = 3,         /* Ctrl-c */\n        CTRL_D = 4,         /* Ctrl-d */\n        CTRL_F = 6,         /* Ctrl-f */\n        CTRL_H = 8,         /* Ctrl-h */\n        TAB = 9,            /* Tab */\n        CTRL_L = 12,        /* Ctrl+l */\n        ENTER = 13,         /* Enter */\n        CTRL_Q = 17,        /* Ctrl-q */\n        CTRL_S = 19,        /* Ctrl-s */\n        CTRL_U = 21,        /* Ctrl-u */\n        ESC = 27,           /* Escape */\n        BACKSPACE =  127,   /* Backspace */\n        /* The following are just soft codes, not really reported by the\n         * terminal directly. */\n        ARROW_LEFT = 1000,\n        ARROW_RIGHT,\n        ARROW_UP,\n        ARROW_DOWN,\n        DEL_KEY,\n        HOME_KEY,\n        END_KEY,\n        PAGE_UP,\n        PAGE_DOWN\n};\n\nvoid editorSetStatusMessage(const char *fmt, ...);\n\n/* =========================== Syntax highlights DB =========================\n *\n * In order to add a new syntax, define two arrays with a list of file name\n * matches and keywords. The file name matches are used in order to match\n * a given syntax with a given file name: if a match pattern starts with a\n * dot, it is matched as the last past of the filename, for example \".c\".\n * Otherwise the pattern is just searched inside the filenme, like \"Makefile\").\n *\n * The list of keywords to highlight is just a list of words, however if they\n * a trailing '|' character is added at the end, they are highlighted in\n * a different color, so that you can have two different sets of keywords.\n *\n * Finally add a stanza in the HLDB global variable with two two arrays\n * of strings, and a set of flags in order to enable highlighting of\n * comments and numbers.\n *\n * The characters for single and multi line comments must be exactly two\n * and must be provided as well (see the C language example).\n *\n * There is no support to highlight patterns currently. */\n\n/* C / C++ */\nchar *C_HL_extensions[] = {\".c\",\".h\",\".cpp\",\".hpp\",\".cc\",NULL};\nchar *C_HL_keywords[] = {\n\t/* C Keywords */\n\t\"auto\",\"break\",\"case\",\"continue\",\"default\",\"do\",\"else\",\"enum\",\n\t\"extern\",\"for\",\"goto\",\"if\",\"register\",\"return\",\"sizeof\",\"static\",\n\t\"struct\",\"switch\",\"typedef\",\"union\",\"volatile\",\"while\",\"NULL\",\n\n\t/* C++ Keywords */\n\t\"alignas\",\"alignof\",\"and\",\"and_eq\",\"asm\",\"bitand\",\"bitor\",\"class\",\n\t\"compl\",\"constexpr\",\"const_cast\",\"deltype\",\"delete\",\"dynamic_cast\",\n\t\"explicit\",\"export\",\"false\",\"friend\",\"inline\",\"mutable\",\"namespace\",\n\t\"new\",\"noexcept\",\"not\",\"not_eq\",\"nullptr\",\"operator\",\"or\",\"or_eq\",\n\t\"private\",\"protected\",\"public\",\"reinterpret_cast\",\"static_assert\",\n\t\"static_cast\",\"template\",\"this\",\"thread_local\",\"throw\",\"true\",\"try\",\n\t\"typeid\",\"typename\",\"virtual\",\"xor\",\"xor_eq\",\n\n\t/* C types */\n        \"int|\",\"long|\",\"double|\",\"float|\",\"char|\",\"unsigned|\",\"signed|\",\n        \"void|\",\"short|\",\"auto|\",\"const|\",\"bool|\",NULL\n};\n\n/* Here we define an array of syntax highlights by extensions, keywords,\n * comments delimiters and flags. */\nstruct editorSyntax HLDB[] = {\n    {\n        /* C / C++ */\n        C_HL_extensions,\n        C_HL_keywords,\n        \"//\",\"/*\",\"*/\",\n        HL_HIGHLIGHT_STRINGS | HL_HIGHLIGHT_NUMBERS\n    }\n};\n\n#define HLDB_ENTRIES (sizeof(HLDB)/sizeof(HLDB[0]))\n\n/* ======================= Low level terminal handling ====================== */\n\nstatic struct termios orig_termios; /* In order to restore at exit.*/\n\nvoid disableRawMode(int fd) {\n    /* Don't even check the return value as it's too late. */\n    if (E.rawmode) {\n        tcsetattr(fd,TCSAFLUSH,&orig_termios);\n        E.rawmode = 0;\n    }\n}\n\n/* Called at exit to avoid remaining in raw mode. */\nvoid editorAtExit(void) {\n    disableRawMode(STDIN_FILENO);\n}\n\n/* Raw mode: 1960 magic shit. */\nint enableRawMode(int fd) {\n    struct termios raw;\n\n    if (E.rawmode) return 0; /* Already enabled. */\n    if (!isatty(STDIN_FILENO)) goto fatal;\n    atexit(editorAtExit);\n    if (tcgetattr(fd,&orig_termios) == -1) goto fatal;\n\n    raw = orig_termios;  /* modify the original mode */\n    /* input modes: no break, no CR to NL, no parity check, no strip char,\n     * no start/stop output control. */\n    raw.c_iflag &= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);\n    /* output modes - disable post processing */\n    raw.c_oflag &= ~(OPOST);\n    /* control modes - set 8 bit chars */\n    raw.c_cflag |= (CS8);\n    /* local modes - choing off, canonical off, no extended functions,\n     * no signal chars (^Z,^C) */\n    raw.c_lflag &= ~(ECHO | ICANON | IEXTEN | ISIG);\n    /* control chars - set return condition: min number of bytes and timer. */\n    raw.c_cc[VMIN] = 0; /* Return each byte, or zero for timeout. */\n    raw.c_cc[VTIME] = 1; /* 100 ms timeout (unit is tens of second). */\n\n    /* put terminal in raw mode after flushing */\n    if (tcsetattr(fd,TCSAFLUSH,&raw) < 0) goto fatal;\n    E.rawmode = 1;\n    return 0;\n\nfatal:\n    errno = ENOTTY;\n    return -1;\n}\n\n/* Read a key from the terminal put in raw mode, trying to handle\n * escape sequences. */\nint editorReadKey(int fd) {\n    int nread;\n    char c, seq[3];\n    while ((nread = read(fd,&c,1)) == 0);\n    if (nread == -1) exit(1);\n\n    while(1) {\n        switch(c) {\n        case ESC:    /* escape sequence */\n            /* If this is just an ESC, we'll timeout here. */\n            if (read(fd,seq,1) == 0) return ESC;\n            if (read(fd,seq+1,1) == 0) return ESC;\n\n            /* ESC [ sequences. */\n            if (seq[0] == '[') {\n                if (seq[1] >= '0' && seq[1] <= '9') {\n                    /* Extended escape, read additional byte. */\n                    if (read(fd,seq+2,1) == 0) return ESC;\n                    if (seq[2] == '~') {\n                        switch(seq[1]) {\n                        case '3': return DEL_KEY;\n                        case '5': return PAGE_UP;\n                        case '6': return PAGE_DOWN;\n                        }\n                    }\n                } else {\n                    switch(seq[1]) {\n                    case 'A': return ARROW_UP;\n                    case 'B': return ARROW_DOWN;\n                    case 'C': return ARROW_RIGHT;\n                    case 'D': return ARROW_LEFT;\n                    case 'H': return HOME_KEY;\n                    case 'F': return END_KEY;\n                    }\n                }\n            }\n\n            /* ESC O sequences. */\n            else if (seq[0] == 'O') {\n                switch(seq[1]) {\n                case 'H': return HOME_KEY;\n                case 'F': return END_KEY;\n                }\n            }\n            break;\n        default:\n            return c;\n        }\n    }\n}\n\n/* Use the ESC [6n escape sequence to query the horizontal cursor position\n * and return it. On error -1 is returned, on success the position of the\n * cursor is stored at *rows and *cols and 0 is returned. */\nint getCursorPosition(int ifd, int ofd, int *rows, int *cols) {\n    char buf[32];\n    unsigned int i = 0;\n\n    /* Report cursor location */\n    if (write(ofd, \"\\x1b[6n\", 4) != 4) return -1;\n\n    /* Read the response: ESC [ rows ; cols R */\n    while (i < sizeof(buf)-1) {\n        if (read(ifd,buf+i,1) != 1) break;\n        if (buf[i] == 'R') break;\n        i++;\n    }\n    buf[i] = '\\0';\n\n    /* Parse it. */\n    if (buf[0] != ESC || buf[1] != '[') return -1;\n    if (sscanf(buf+2,\"%d;%d\",rows,cols) != 2) return -1;\n    return 0;\n}\n\n/* Try to get the number of columns in the current terminal. If the ioctl()\n * call fails the function will try to query the terminal itself.\n * Returns 0 on success, -1 on error. */\nint getWindowSize(int ifd, int ofd, int *rows, int *cols) {\n    struct winsize ws;\n\n    if (ioctl(1, TIOCGWINSZ, &ws) == -1 || ws.ws_col == 0) {\n        /* ioctl() failed. Try to query the terminal itself. */\n        int orig_row, orig_col, retval;\n\n        /* Get the initial position so we can restore it later. */\n        retval = getCursorPosition(ifd,ofd,&orig_row,&orig_col);\n        if (retval == -1) goto failed;\n\n        /* Go to right/bottom margin and get position. */\n        if (write(ofd,\"\\x1b[999C\\x1b[999B\",12) != 12) goto failed;\n        retval = getCursorPosition(ifd,ofd,rows,cols);\n        if (retval == -1) goto failed;\n\n        /* Restore position. */\n        char seq[32];\n        snprintf(seq,32,\"\\x1b[%d;%dH\",orig_row,orig_col);\n        if (write(ofd,seq,strlen(seq)) == -1) {\n            /* Can't recover... */\n        }\n        return 0;\n    } else {\n        *cols = ws.ws_col;\n        *rows = ws.ws_row;\n        return 0;\n    }\n\nfailed:\n    return -1;\n}\n\n/* ====================== Syntax highlight color scheme  ==================== */\n\nint is_separator(int c) {\n    return c == '\\0' || isspace(c) || strchr(\",.()+-/*=~%[];\",c) != NULL;\n}\n\n/* Return true if the specified row last char is part of a multi line comment\n * that starts at this row or at one before, and does not end at the end\n * of the row but spawns to the next row. */\nint editorRowHasOpenComment(erow *row) {\n    if (row->hl && row->rsize && row->hl[row->rsize-1] == HL_MLCOMMENT &&\n        (row->rsize < 2 || (row->render[row->rsize-2] != '*' ||\n                            row->render[row->rsize-1] != '/'))) return 1;\n    return 0;\n}\n\n/* Set every byte of row->hl (that corresponds to every character in the line)\n * to the right syntax highlight type (HL_* defines). */\nvoid editorUpdateSyntax(erow *row) {\n    row->hl = realloc(row->hl,row->rsize);\n    memset(row->hl,HL_NORMAL,row->rsize);\n\n    if (E.syntax == NULL) return; /* No syntax, everything is HL_NORMAL. */\n\n    int i, prev_sep, in_string, in_comment;\n    char *p;\n    char **keywords = E.syntax->keywords;\n    char *scs = E.syntax->singleline_comment_start;\n    char *mcs = E.syntax->multiline_comment_start;\n    char *mce = E.syntax->multiline_comment_end;\n\n    /* Point to the first non-space char. */\n    p = row->render;\n    i = 0; /* Current char offset */\n    while(*p && isspace(*p)) {\n        p++;\n        i++;\n    }\n    prev_sep = 1; /* Tell the parser if 'i' points to start of word. */\n    in_string = 0; /* Are we inside \"\" or '' ? */\n    in_comment = 0; /* Are we inside multi-line comment? */\n\n    /* If the previous line has an open comment, this line starts\n     * with an open comment state. */\n    if (row->idx > 0 && editorRowHasOpenComment(&E.row[row->idx-1]))\n        in_comment = 1;\n\n    while(*p) {\n        /* Handle // comments. */\n        if (prev_sep && *p == scs[0] && *(p+1) == scs[1]) {\n            /* From here to end is a comment */\n            memset(row->hl+i,HL_COMMENT,row->size-i);\n            return;\n        }\n\n        /* Handle multi line comments. */\n        if (in_comment) {\n            row->hl[i] = HL_MLCOMMENT;\n            if (*p == mce[0] && *(p+1) == mce[1]) {\n                row->hl[i+1] = HL_MLCOMMENT;\n                p += 2; i += 2;\n                in_comment = 0;\n                prev_sep = 1;\n                continue;\n            } else {\n                prev_sep = 0;\n                p++; i++;\n                continue;\n            }\n        } else if (*p == mcs[0] && *(p+1) == mcs[1]) {\n            row->hl[i] = HL_MLCOMMENT;\n            row->hl[i+1] = HL_MLCOMMENT;\n            p += 2; i += 2;\n            in_comment = 1;\n            prev_sep = 0;\n            continue;\n        }\n\n        /* Handle \"\" and '' */\n        if (in_string) {\n            row->hl[i] = HL_STRING;\n            if (*p == '\\\\') {\n                row->hl[i+1] = HL_STRING;\n                p += 2; i += 2;\n                prev_sep = 0;\n                continue;\n            }\n            if (*p == in_string) in_string = 0;\n            p++; i++;\n            continue;\n        } else {\n            if (*p == '\"' || *p == '\\'') {\n                in_string = *p;\n                row->hl[i] = HL_STRING;\n                p++; i++;\n                prev_sep = 0;\n                continue;\n            }\n        }\n\n        /* Handle non printable chars. */\n        if (!isprint(*p)) {\n            row->hl[i] = HL_NONPRINT;\n            p++; i++;\n            prev_sep = 0;\n            continue;\n        }\n\n        /* Handle numbers */\n        if ((isdigit(*p) && (prev_sep || row->hl[i-1] == HL_NUMBER)) ||\n            (*p == '.' && i >0 && row->hl[i-1] == HL_NUMBER)) {\n            row->hl[i] = HL_NUMBER;\n            p++; i++;\n            prev_sep = 0;\n            continue;\n        }\n\n        /* Handle keywords and lib calls */\n        if (prev_sep) {\n            int j;\n            for (j = 0; keywords[j]; j++) {\n                int klen = strlen(keywords[j]);\n                int kw2 = keywords[j][klen-1] == '|';\n                if (kw2) klen--;\n\n                if (!memcmp(p,keywords[j],klen) &&\n                    is_separator(*(p+klen)))\n                {\n                    /* Keyword */\n                    memset(row->hl+i,kw2 ? HL_KEYWORD2 : HL_KEYWORD1,klen);\n                    p += klen;\n                    i += klen;\n                    break;\n                }\n            }\n            if (keywords[j] != NULL) {\n                prev_sep = 0;\n                continue; /* We had a keyword match */\n            }\n        }\n\n        /* Not special chars */\n        prev_sep = is_separator(*p);\n        p++; i++;\n    }\n\n    /* Propagate syntax change to the next row if the open commen\n     * state changed. This may recursively affect all the following rows\n     * in the file. */\n    int oc = editorRowHasOpenComment(row);\n    if (row->hl_oc != oc && row->idx+1 < E.numrows)\n        editorUpdateSyntax(&E.row[row->idx+1]);\n    row->hl_oc = oc;\n}\n\n/* Maps syntax highlight token types to terminal colors. */\nint editorSyntaxToColor(int hl) {\n    switch(hl) {\n    case HL_COMMENT:\n    case HL_MLCOMMENT: return 36;     /* cyan */\n    case HL_KEYWORD1: return 33;    /* yellow */\n    case HL_KEYWORD2: return 32;    /* green */\n    case HL_STRING: return 35;      /* magenta */\n    case HL_NUMBER: return 31;      /* red */\n    case HL_MATCH: return 34;      /* blu */\n    default: return 37;             /* white */\n    }\n}\n\n/* Select the syntax highlight scheme depending on the filename,\n * setting it in the global state E.syntax. */\nvoid editorSelectSyntaxHighlight(char *filename) {\n    for (unsigned int j = 0; j < HLDB_ENTRIES; j++) {\n        struct editorSyntax *s = HLDB+j;\n        unsigned int i = 0;\n        while(s->filematch[i]) {\n            char *p;\n            int patlen = strlen(s->filematch[i]);\n            if ((p = strstr(filename,s->filematch[i])) != NULL) {\n                if (s->filematch[i][0] != '.' || p[patlen] == '\\0') {\n                    E.syntax = s;\n                    return;\n                }\n            }\n            i++;\n        }\n    }\n}\n\n/* ======================= Editor rows implementation ======================= */\n\n/* Update the rendered version and the syntax highlight of a row. */\nvoid editorUpdateRow(erow *row) {\n    unsigned int tabs = 0, nonprint = 0;\n    int j, idx;\n\n   /* Create a version of the row we can directly print on the screen,\n     * respecting tabs, substituting non printable characters with '?'. */\n    free(row->render);\n    for (j = 0; j < row->size; j++)\n        if (row->chars[j] == TAB) tabs++;\n\n    unsigned long long allocsize =\n        (unsigned long long) row->size + tabs*8 + nonprint*9 + 1;\n    if (allocsize > UINT32_MAX) {\n        printf(\"Some line of the edited file is too long for kilo\\n\");\n        exit(1);\n    }\n\n    row->render = malloc(row->size + tabs*8 + nonprint*9 + 1);\n    idx = 0;\n    for (j = 0; j < row->size; j++) {\n        if (row->chars[j] == TAB) {\n            row->render[idx++] = ' ';\n            while((idx+1) % 8 != 0) row->render[idx++] = ' ';\n        } else {\n            row->render[idx++] = row->chars[j];\n        }\n    }\n    row->rsize = idx;\n    row->render[idx] = '\\0';\n\n    /* Update the syntax highlighting attributes of the row. */\n    editorUpdateSyntax(row);\n}\n\n/* Insert a row at the specified position, shifting the other rows on the bottom\n * if required. */\nvoid editorInsertRow(int at, char *s, size_t len) {\n    if (at > E.numrows) return;\n    E.row = realloc(E.row,sizeof(erow)*(E.numrows+1));\n    if (at != E.numrows) {\n        memmove(E.row+at+1,E.row+at,sizeof(E.row[0])*(E.numrows-at));\n        for (int j = at+1; j <= E.numrows; j++) E.row[j].idx++;\n    }\n    E.row[at].size = len;\n    E.row[at].chars = malloc(len+1);\n    memcpy(E.row[at].chars,s,len+1);\n    E.row[at].hl = NULL;\n    E.row[at].hl_oc = 0;\n    E.row[at].render = NULL;\n    E.row[at].rsize = 0;\n    E.row[at].idx = at;\n    editorUpdateRow(E.row+at);\n    E.numrows++;\n    E.dirty++;\n}\n\n/* Free row's heap allocated stuff. */\nvoid editorFreeRow(erow *row) {\n    free(row->render);\n    free(row->chars);\n    free(row->hl);\n}\n\n/* Remove the row at the specified position, shifting the remainign on the\n * top. */\nvoid editorDelRow(int at) {\n    erow *row;\n\n    if (at >= E.numrows) return;\n    row = E.row+at;\n    editorFreeRow(row);\n    memmove(E.row+at,E.row+at+1,sizeof(E.row[0])*(E.numrows-at-1));\n    for (int j = at; j < E.numrows-1; j++) E.row[j].idx++;\n    E.numrows--;\n    E.dirty++;\n}\n\n/* Turn the editor rows into a single heap-allocated string.\n * Returns the pointer to the heap-allocated string and populate the\n * integer pointed by 'buflen' with the size of the string, escluding\n * the final nulterm. */\nchar *editorRowsToString(int *buflen) {\n    char *buf = NULL, *p;\n    int totlen = 0;\n    int j;\n\n    /* Compute count of bytes */\n    for (j = 0; j < E.numrows; j++)\n        totlen += E.row[j].size+1; /* +1 is for \"\\n\" at end of every row */\n    *buflen = totlen;\n    totlen++; /* Also make space for nulterm */\n\n    p = buf = malloc(totlen);\n    for (j = 0; j < E.numrows; j++) {\n        memcpy(p,E.row[j].chars,E.row[j].size);\n        p += E.row[j].size;\n        *p = '\\n';\n        p++;\n    }\n    *p = '\\0';\n    return buf;\n}\n\n/* Insert a character at the specified position in a row, moving the remaining\n * chars on the right if needed. */\nvoid editorRowInsertChar(erow *row, int at, int c) {\n    if (at > row->size) {\n        /* Pad the string with spaces if the insert location is outside the\n         * current length by more than a single character. */\n        int padlen = at-row->size;\n        /* In the next line +2 means: new char and null term. */\n        row->chars = realloc(row->chars,row->size+padlen+2);\n        memset(row->chars+row->size,' ',padlen);\n        row->chars[row->size+padlen+1] = '\\0';\n        row->size += padlen+1;\n    } else {\n        /* If we are in the middle of the string just make space for 1 new\n         * char plus the (already existing) null term. */\n        row->chars = realloc(row->chars,row->size+2);\n        memmove(row->chars+at+1,row->chars+at,row->size-at+1);\n        row->size++;\n    }\n    row->chars[at] = c;\n    editorUpdateRow(row);\n    E.dirty++;\n}\n\n/* Append the string 's' at the end of a row */\nvoid editorRowAppendString(erow *row, char *s, size_t len) {\n    row->chars = realloc(row->chars,row->size+len+1);\n    memcpy(row->chars+row->size,s,len);\n    row->size += len;\n    row->chars[row->size] = '\\0';\n    editorUpdateRow(row);\n    E.dirty++;\n}\n\n/* Delete the character at offset 'at' from the specified row. */\nvoid editorRowDelChar(erow *row, int at) {\n    if (row->size <= at) return;\n    memmove(row->chars+at,row->chars+at+1,row->size-at);\n    editorUpdateRow(row);\n    row->size--;\n    E.dirty++;\n}\n\n/* Insert the specified char at the current prompt position. */\nvoid editorInsertChar(int c) {\n    int filerow = E.rowoff+E.cy;\n    int filecol = E.coloff+E.cx;\n    erow *row = (filerow >= E.numrows) ? NULL : &E.row[filerow];\n\n    /* If the row where the cursor is currently located does not exist in our\n     * logical representaion of the file, add enough empty rows as needed. */\n    if (!row) {\n        while(E.numrows <= filerow)\n            editorInsertRow(E.numrows,\"\",0);\n    }\n    row = &E.row[filerow];\n    editorRowInsertChar(row,filecol,c);\n    if (E.cx == E.screencols-1)\n        E.coloff++;\n    else\n        E.cx++;\n    E.dirty++;\n}\n\n/* Inserting a newline is slightly complex as we have to handle inserting a\n * newline in the middle of a line, splitting the line as needed. */\nvoid editorInsertNewline(void) {\n    int filerow = E.rowoff+E.cy;\n    int filecol = E.coloff+E.cx;\n    erow *row = (filerow >= E.numrows) ? NULL : &E.row[filerow];\n\n    if (!row) {\n        if (filerow == E.numrows) {\n            editorInsertRow(filerow,\"\",0);\n            goto fixcursor;\n        }\n        return;\n    }\n    /* If the cursor is over the current line size, we want to conceptually\n     * think it's just over the last character. */\n    if (filecol >= row->size) filecol = row->size;\n    if (filecol == 0) {\n        editorInsertRow(filerow,\"\",0);\n    } else {\n        /* We are in the middle of a line. Split it between two rows. */\n        editorInsertRow(filerow+1,row->chars+filecol,row->size-filecol);\n        row = &E.row[filerow];\n        row->chars[filecol] = '\\0';\n        row->size = filecol;\n        editorUpdateRow(row);\n    }\nfixcursor:\n    if (E.cy == E.screenrows-1) {\n        E.rowoff++;\n    } else {\n        E.cy++;\n    }\n    E.cx = 0;\n    E.coloff = 0;\n}\n\n/* Delete the char at the current prompt position. */\nvoid editorDelChar(void) {\n    int filerow = E.rowoff+E.cy;\n    int filecol = E.coloff+E.cx;\n    erow *row = (filerow >= E.numrows) ? NULL : &E.row[filerow];\n\n    if (!row || (filecol == 0 && filerow == 0)) return;\n    if (filecol == 0) {\n        /* Handle the case of column 0, we need to move the current line\n         * on the right of the previous one. */\n        filecol = E.row[filerow-1].size;\n        editorRowAppendString(&E.row[filerow-1],row->chars,row->size);\n        editorDelRow(filerow);\n        row = NULL;\n        if (E.cy == 0)\n            E.rowoff--;\n        else\n            E.cy--;\n        E.cx = filecol;\n        if (E.cx >= E.screencols) {\n            int shift = (E.screencols-E.cx)+1;\n            E.cx -= shift;\n            E.coloff += shift;\n        }\n    } else {\n        editorRowDelChar(row,filecol-1);\n        if (E.cx == 0 && E.coloff)\n            E.coloff--;\n        else\n            E.cx--;\n    }\n    if (row) editorUpdateRow(row);\n    E.dirty++;\n}\n\n/* Load the specified program in the editor memory and returns 0 on success\n * or 1 on error. */\nint editorOpen(char *filename) {\n    FILE *fp;\n\n    E.dirty = 0;\n    free(E.filename);\n    size_t fnlen = strlen(filename)+1;\n    E.filename = malloc(fnlen);\n    memcpy(E.filename,filename,fnlen);\n\n    fp = fopen(filename,\"r\");\n    if (!fp) {\n        if (errno != ENOENT) {\n            perror(\"Opening file\");\n            exit(1);\n        }\n        return 1;\n    }\n\n    char *line = NULL;\n    size_t linecap = 0;\n    ssize_t linelen;\n    while((linelen = getline(&line,&linecap,fp)) != -1) {\n        if (linelen && (line[linelen-1] == '\\n' || line[linelen-1] == '\\r'))\n            line[--linelen] = '\\0';\n        editorInsertRow(E.numrows,line,linelen);\n    }\n    free(line);\n    fclose(fp);\n    E.dirty = 0;\n    return 0;\n}\n\n/* Save the current file on disk. Return 0 on success, 1 on error. */\nint editorSave(void) {\n    int len;\n    char *buf = editorRowsToString(&len);\n    int fd = open(E.filename,O_RDWR|O_CREAT,0644);\n    if (fd == -1) goto writeerr;\n\n    /* Use truncate + a single write(2) call in order to make saving\n     * a bit safer, under the limits of what we can do in a small editor. */\n    if (ftruncate(fd,len) == -1) goto writeerr;\n    if (write(fd,buf,len) != len) goto writeerr;\n\n    close(fd);\n    free(buf);\n    E.dirty = 0;\n    editorSetStatusMessage(\"%d bytes written on disk\", len);\n    return 0;\n\nwriteerr:\n    free(buf);\n    if (fd != -1) close(fd);\n    editorSetStatusMessage(\"Can't save! I/O error: %s\",strerror(errno));\n    return 1;\n}\n\n/* ============================= Terminal update ============================ */\n\n/* We define a very simple \"append buffer\" structure, that is an heap\n * allocated string where we can append to. This is useful in order to\n * write all the escape sequences in a buffer and flush them to the standard\n * output in a single call, to avoid flickering effects. */\nstruct abuf {\n    char *b;\n    int len;\n};\n\n#define ABUF_INIT {NULL,0}\n\nvoid abAppend(struct abuf *ab, const char *s, int len) {\n    char *new = realloc(ab->b,ab->len+len);\n\n    if (new == NULL) return;\n    memcpy(new+ab->len,s,len);\n    ab->b = new;\n    ab->len += len;\n}\n\nvoid abFree(struct abuf *ab) {\n    free(ab->b);\n}\n\n/* This function writes the whole screen using VT100 escape characters\n * starting from the logical state of the editor in the global state 'E'. */\nvoid editorRefreshScreen(void) {\n    int y;\n    erow *r;\n    char buf[32];\n    struct abuf ab = ABUF_INIT;\n\n    abAppend(&ab,\"\\x1b[?25l\",6); /* Hide cursor. */\n    abAppend(&ab,\"\\x1b[H\",3); /* Go home. */\n    for (y = 0; y < E.screenrows; y++) {\n        int filerow = E.rowoff+y;\n\n        if (filerow >= E.numrows) {\n            if (E.numrows == 0 && y == E.screenrows/3) {\n                char welcome[80];\n                int welcomelen = snprintf(welcome,sizeof(welcome),\n                    \"Kilo editor -- verison %s\\x1b[0K\\r\\n\", KILO_VERSION);\n                int padding = (E.screencols-welcomelen)/2;\n                if (padding) {\n                    abAppend(&ab,\"~\",1);\n                    padding--;\n                }\n                while(padding--) abAppend(&ab,\" \",1);\n                abAppend(&ab,welcome,welcomelen);\n            } else {\n                abAppend(&ab,\"~\\x1b[0K\\r\\n\",7);\n            }\n            continue;\n        }\n\n        r = &E.row[filerow];\n\n        int len = r->rsize - E.coloff;\n        int current_color = -1;\n        if (len > 0) {\n            if (len > E.screencols) len = E.screencols;\n            char *c = r->render+E.coloff;\n            unsigned char *hl = r->hl+E.coloff;\n            int j;\n            for (j = 0; j < len; j++) {\n                if (hl[j] == HL_NONPRINT) {\n                    char sym;\n                    abAppend(&ab,\"\\x1b[7m\",4);\n                    if (c[j] <= 26)\n                        sym = '@'+c[j];\n                    else\n                        sym = '?';\n                    abAppend(&ab,&sym,1);\n                    abAppend(&ab,\"\\x1b[0m\",4);\n                } else if (hl[j] == HL_NORMAL) {\n                    if (current_color != -1) {\n                        abAppend(&ab,\"\\x1b[39m\",5);\n                        current_color = -1;\n                    }\n                    abAppend(&ab,c+j,1);\n                } else {\n                    int color = editorSyntaxToColor(hl[j]);\n                    if (color != current_color) {\n                        char buf[16];\n                        int clen = snprintf(buf,sizeof(buf),\"\\x1b[%dm\",color);\n                        current_color = color;\n                        abAppend(&ab,buf,clen);\n                    }\n                    abAppend(&ab,c+j,1);\n                }\n            }\n        }\n        abAppend(&ab,\"\\x1b[39m\",5);\n        abAppend(&ab,\"\\x1b[0K\",4);\n        abAppend(&ab,\"\\r\\n\",2);\n    }\n\n    /* Create a two rows status. First row: */\n    abAppend(&ab,\"\\x1b[0K\",4);\n    abAppend(&ab,\"\\x1b[7m\",4);\n    char status[80], rstatus[80];\n    int len = snprintf(status, sizeof(status), \"%.20s - %d lines %s\",\n        E.filename, E.numrows, E.dirty ? \"(modified)\" : \"\");\n    int rlen = snprintf(rstatus, sizeof(rstatus),\n        \"%d/%d\",E.rowoff+E.cy+1,E.numrows);\n    if (len > E.screencols) len = E.screencols;\n    abAppend(&ab,status,len);\n    while(len < E.screencols) {\n        if (E.screencols - len == rlen) {\n            abAppend(&ab,rstatus,rlen);\n            break;\n        } else {\n            abAppend(&ab,\" \",1);\n            len++;\n        }\n    }\n    abAppend(&ab,\"\\x1b[0m\\r\\n\",6);\n\n    /* Second row depends on E.statusmsg and the status message update time. */\n    abAppend(&ab,\"\\x1b[0K\",4);\n    int msglen = strlen(E.statusmsg);\n    if (msglen && time(NULL)-E.statusmsg_time < 5)\n        abAppend(&ab,E.statusmsg,msglen <= E.screencols ? msglen : E.screencols);\n\n    /* Put cursor at its current position. Note that the horizontal position\n     * at which the cursor is displayed may be different compared to 'E.cx'\n     * because of TABs. */\n    int j;\n    int cx = 1;\n    int filerow = E.rowoff+E.cy;\n    erow *row = (filerow >= E.numrows) ? NULL : &E.row[filerow];\n    if (row) {\n        for (j = E.coloff; j < (E.cx+E.coloff); j++) {\n            if (j < row->size && row->chars[j] == TAB) cx += 7-((cx)%8);\n            cx++;\n        }\n    }\n    snprintf(buf,sizeof(buf),\"\\x1b[%d;%dH\",E.cy+1,cx);\n    abAppend(&ab,buf,strlen(buf));\n    abAppend(&ab,\"\\x1b[?25h\",6); /* Show cursor. */\n    write(STDOUT_FILENO,ab.b,ab.len);\n    abFree(&ab);\n}\n\n/* Set an editor status message for the second line of the status, at the\n * end of the screen. */\nvoid editorSetStatusMessage(const char *fmt, ...) {\n    va_list ap;\n    va_start(ap,fmt);\n    vsnprintf(E.statusmsg,sizeof(E.statusmsg),fmt,ap);\n    va_end(ap);\n    E.statusmsg_time = time(NULL);\n}\n\n/* =============================== Find mode ================================ */\n\n#define KILO_QUERY_LEN 256\n\nvoid editorFind(int fd) {\n    char query[KILO_QUERY_LEN+1] = {0};\n    int qlen = 0;\n    int last_match = -1; /* Last line where a match was found. -1 for none. */\n    int find_next = 0; /* if 1 search next, if -1 search prev. */\n    int saved_hl_line = -1;  /* No saved HL */\n    char *saved_hl = NULL;\n\n#define FIND_RESTORE_HL do { \\\n    if (saved_hl) { \\\n        memcpy(E.row[saved_hl_line].hl,saved_hl, E.row[saved_hl_line].rsize); \\\n        free(saved_hl); \\\n        saved_hl = NULL; \\\n    } \\\n} while (0)\n\n    /* Save the cursor position in order to restore it later. */\n    int saved_cx = E.cx, saved_cy = E.cy;\n    int saved_coloff = E.coloff, saved_rowoff = E.rowoff;\n\n    while(1) {\n        editorSetStatusMessage(\n            \"Search: %s (Use ESC/Arrows/Enter)\", query);\n        editorRefreshScreen();\n\n        int c = editorReadKey(fd);\n        if (c == DEL_KEY || c == CTRL_H || c == BACKSPACE) {\n            if (qlen != 0) query[--qlen] = '\\0';\n            last_match = -1;\n        } else if (c == ESC || c == ENTER) {\n            if (c == ESC) {\n                E.cx = saved_cx; E.cy = saved_cy;\n                E.coloff = saved_coloff; E.rowoff = saved_rowoff;\n            }\n            FIND_RESTORE_HL;\n            editorSetStatusMessage(\"\");\n            return;\n        } else if (c == ARROW_RIGHT || c == ARROW_DOWN) {\n            find_next = 1;\n        } else if (c == ARROW_LEFT || c == ARROW_UP) {\n            find_next = -1;\n        } else if (isprint(c)) {\n            if (qlen < KILO_QUERY_LEN) {\n                query[qlen++] = c;\n                query[qlen] = '\\0';\n                last_match = -1;\n            }\n        }\n\n        /* Search occurrence. */\n        if (last_match == -1) find_next = 1;\n        if (find_next) {\n            char *match = NULL;\n            int match_offset = 0;\n            int i, current = last_match;\n\n            for (i = 0; i < E.numrows; i++) {\n                current += find_next;\n                if (current == -1) current = E.numrows-1;\n                else if (current == E.numrows) current = 0;\n                match = strstr(E.row[current].render,query);\n                if (match) {\n                    match_offset = match-E.row[current].render;\n                    break;\n                }\n            }\n            find_next = 0;\n\n            /* Highlight */\n            FIND_RESTORE_HL;\n\n            if (match) {\n                erow *row = &E.row[current];\n                last_match = current;\n                if (row->hl) {\n                    saved_hl_line = current;\n                    saved_hl = malloc(row->rsize);\n                    memcpy(saved_hl,row->hl,row->rsize);\n                    memset(row->hl+match_offset,HL_MATCH,qlen);\n                }\n                E.cy = 0;\n                E.cx = match_offset;\n                E.rowoff = current;\n                E.coloff = 0;\n                /* Scroll horizontally as needed. */\n                if (E.cx > E.screencols) {\n                    int diff = E.cx - E.screencols;\n                    E.cx -= diff;\n                    E.coloff += diff;\n                }\n            }\n        }\n    }\n}\n\n/* ========================= Editor events handling  ======================== */\n\n/* Handle cursor position change because arrow keys were pressed. */\nvoid editorMoveCursor(int key) {\n    int filerow = E.rowoff+E.cy;\n    int filecol = E.coloff+E.cx;\n    int rowlen;\n    erow *row = (filerow >= E.numrows) ? NULL : &E.row[filerow];\n\n    switch(key) {\n    case ARROW_LEFT:\n        if (E.cx == 0) {\n            if (E.coloff) {\n                E.coloff--;\n            } else {\n                if (filerow > 0) {\n                    E.cy--;\n                    E.cx = E.row[filerow-1].size;\n                    if (E.cx > E.screencols-1) {\n                        E.coloff = E.cx-E.screencols+1;\n                        E.cx = E.screencols-1;\n                    }\n                }\n            }\n        } else {\n            E.cx -= 1;\n        }\n        break;\n    case ARROW_RIGHT:\n        if (row && filecol < row->size) {\n            if (E.cx == E.screencols-1) {\n                E.coloff++;\n            } else {\n                E.cx += 1;\n            }\n        } else if (row && filecol == row->size) {\n            E.cx = 0;\n            E.coloff = 0;\n            if (E.cy == E.screenrows-1) {\n                E.rowoff++;\n            } else {\n                E.cy += 1;\n            }\n        }\n        break;\n    case ARROW_UP:\n        if (E.cy == 0) {\n            if (E.rowoff) E.rowoff--;\n        } else {\n            E.cy -= 1;\n        }\n        break;\n    case ARROW_DOWN:\n        if (filerow < E.numrows) {\n            if (E.cy == E.screenrows-1) {\n                E.rowoff++;\n            } else {\n                E.cy += 1;\n            }\n        }\n        break;\n    }\n    /* Fix cx if the current line has not enough chars. */\n    filerow = E.rowoff+E.cy;\n    filecol = E.coloff+E.cx;\n    row = (filerow >= E.numrows) ? NULL : &E.row[filerow];\n    rowlen = row ? row->size : 0;\n    if (filecol > rowlen) {\n        E.cx -= filecol-rowlen;\n        if (E.cx < 0) {\n            E.coloff += E.cx;\n            E.cx = 0;\n        }\n    }\n}\n\n/* Process events arriving from the standard input, which is, the user\n * is typing stuff on the terminal. */\n#define KILO_QUIT_TIMES 3\nvoid editorProcessKeypress(int fd) {\n    /* When the file is modified, requires Ctrl-q to be pressed N times\n     * before actually quitting. */\n    static int quit_times = KILO_QUIT_TIMES;\n\n    int c = editorReadKey(fd);\n    switch(c) {\n    case ENTER:         /* Enter */\n        editorInsertNewline();\n        break;\n    case CTRL_C:        /* Ctrl-c */\n        /* We ignore ctrl-c, it can't be so simple to lose the changes\n         * to the edited file. */\n        break;\n    case CTRL_Q:        /* Ctrl-q */\n        /* Quit if the file was already saved. */\n        if (E.dirty && quit_times) {\n            editorSetStatusMessage(\"WARNING!!! File has unsaved changes. \"\n                \"Press Ctrl-Q %d more times to quit.\", quit_times);\n            quit_times--;\n            return;\n        }\n        exit(0);\n        break;\n    case CTRL_S:        /* Ctrl-s */\n        editorSave();\n        break;\n    case CTRL_F:\n        editorFind(fd);\n        break;\n    case BACKSPACE:     /* Backspace */\n    case CTRL_H:        /* Ctrl-h */\n    case DEL_KEY:\n        editorDelChar();\n        break;\n    case PAGE_UP:\n    case PAGE_DOWN:\n        if (c == PAGE_UP && E.cy != 0)\n            E.cy = 0;\n        else if (c == PAGE_DOWN && E.cy != E.screenrows-1)\n            E.cy = E.screenrows-1;\n        {\n        int times = E.screenrows;\n        while(times--)\n            editorMoveCursor(c == PAGE_UP ? ARROW_UP:\n                                            ARROW_DOWN);\n        }\n        break;\n\n    case ARROW_UP:\n    case ARROW_DOWN:\n    case ARROW_LEFT:\n    case ARROW_RIGHT:\n        editorMoveCursor(c);\n        break;\n    case CTRL_L: /* ctrl+l, clear screen */\n        /* Just refresht the line as side effect. */\n        break;\n    case ESC:\n        /* Nothing to do for ESC in this mode. */\n        break;\n    default:\n        editorInsertChar(c);\n        break;\n    }\n\n    quit_times = KILO_QUIT_TIMES; /* Reset it to the original value. */\n}\n\nint editorFileWasModified(void) {\n    return E.dirty;\n}\n\nvoid updateWindowSize(void) {\n    if (getWindowSize(STDIN_FILENO,STDOUT_FILENO,\n                      &E.screenrows,&E.screencols) == -1) {\n        perror(\"Unable to query the screen for size (columns / rows)\");\n        exit(1);\n    }\n    E.screenrows -= 2; /* Get room for status bar. */\n}\n\nvoid handleSigWinCh(int unused __attribute__((unused))) {\n    updateWindowSize();\n    if (E.cy > E.screenrows) E.cy = E.screenrows - 1;\n    if (E.cx > E.screencols) E.cx = E.screencols - 1;\n    editorRefreshScreen();\n}\n\nvoid initEditor(void) {\n    E.cx = 0;\n    E.cy = 0;\n    E.rowoff = 0;\n    E.coloff = 0;\n    E.numrows = 0;\n    E.row = NULL;\n    E.dirty = 0;\n    E.filename = NULL;\n    E.syntax = NULL;\n    updateWindowSize();\n    signal(SIGWINCH, handleSigWinCh);\n}\n\nint main(int argc, char **argv) {\n    if (argc != 2) {\n        fprintf(stderr,\"Usage: kilo <filename>\\n\");\n        exit(1);\n    }\n\n    initEditor();\n    editorSelectSyntaxHighlight(argv[1]);\n    editorOpen(argv[1]);\n    enableRawMode(STDIN_FILENO);\n    editorSetStatusMessage(\n        \"HELP: Ctrl-S = save | Ctrl-Q = quit | Ctrl-F = find\");\n    while(1) {\n        editorRefreshScreen();\n        editorProcessKeypress(STDIN_FILENO);\n    }\n    return 0;\n}\n"
        }
      ]
    }
  ]
}