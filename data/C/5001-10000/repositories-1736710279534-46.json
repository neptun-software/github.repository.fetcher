{
  "metadata": {
    "timestamp": 1736710279534,
    "page": 46,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjUw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "mattn/go-sqlite3",
      "stars": 8154,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".codecov.yml",
          "type": "blob",
          "size": 0.05078125,
          "content": "coverage:\n  status:\n    project: off\n    patch: off\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1259765625,
          "content": "*.db\n*.exe\n*.dll\n*.o\n\n# VSCode\n.vscode\n\n# Exclude from upgrade\nupgrade/*.c\nupgrade/*.h\n\n# Exclude upgrade binary\nupgrade/upgrade\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0595703125,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2014 Yasuhiro Matsumoto\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 29.4189453125,
          "content": "go-sqlite3\n==========\n\n[![Go Reference](https://pkg.go.dev/badge/github.com/mattn/go-sqlite3.svg)](https://pkg.go.dev/github.com/mattn/go-sqlite3)\n[![GitHub Actions](https://github.com/mattn/go-sqlite3/workflows/Go/badge.svg)](https://github.com/mattn/go-sqlite3/actions?query=workflow%3AGo)\n[![Financial Contributors on Open Collective](https://opencollective.com/mattn-go-sqlite3/all/badge.svg?label=financial+contributors)](https://opencollective.com/mattn-go-sqlite3) \n[![codecov](https://codecov.io/gh/mattn/go-sqlite3/branch/master/graph/badge.svg)](https://codecov.io/gh/mattn/go-sqlite3)\n[![Go Report Card](https://goreportcard.com/badge/github.com/mattn/go-sqlite3)](https://goreportcard.com/report/github.com/mattn/go-sqlite3)\n\nLatest stable version is v1.14 or later, not v2.\n\n~~**NOTE:** The increase to v2 was an accident. There were no major changes or features.~~\n\n# Description\n\nA sqlite3 driver that conforms to the built-in database/sql interface.\n\nSupported Golang version: See [.github/workflows/go.yaml](./.github/workflows/go.yaml).\n\nThis package follows the official [Golang Release Policy](https://golang.org/doc/devel/release.html#policy).\n\n### Overview\n\n- [go-sqlite3](#go-sqlite3)\n- [Description](#description)\n    - [Overview](#overview)\n- [Installation](#installation)\n- [API Reference](#api-reference)\n- [Connection String](#connection-string)\n  - [DSN Examples](#dsn-examples)\n- [Features](#features)\n    - [Usage](#usage)\n    - [Feature / Extension List](#feature--extension-list)\n- [Compilation](#compilation)\n  - [Android](#android)\n- [ARM](#arm)\n- [Cross Compile](#cross-compile)\n- [Google Cloud Platform](#google-cloud-platform)\n  - [Linux](#linux)\n    - [Alpine](#alpine)\n    - [Fedora](#fedora)\n    - [Ubuntu](#ubuntu)\n  - [macOS](#mac-osx)\n  - [Windows](#windows)\n  - [Errors](#errors)\n- [User Authentication](#user-authentication)\n  - [Compile](#compile)\n  - [Usage](#usage-1)\n    - [Create protected database](#create-protected-database)\n    - [Password Encoding](#password-encoding)\n      - [Available Encoders](#available-encoders)\n    - [Restrictions](#restrictions)\n    - [Support](#support)\n    - [User Management](#user-management)\n      - [SQL](#sql)\n        - [Examples](#examples)\n      - [*SQLiteConn](#sqliteconn)\n    - [Attached database](#attached-database)\n- [Extensions](#extensions)\n  - [Spatialite](#spatialite)\n- [FAQ](#faq)\n- [License](#license)\n- [Author](#author)\n\n# Installation\n\nThis package can be installed with the `go get` command:\n\n    go get github.com/mattn/go-sqlite3\n\n_go-sqlite3_ is *cgo* package.\nIf you want to build your app using go-sqlite3, you need gcc.\n\n***Important: because this is a `CGO` enabled package, you are required to set the environment variable `CGO_ENABLED=1` and have a `gcc` compiler present within your path.***\n\n# API Reference\n\nAPI documentation can be found [here](http://godoc.org/github.com/mattn/go-sqlite3).\n\nExamples can be found under the [examples](./_example) directory.\n\n# Connection String\n\nWhen creating a new SQLite database or connection to an existing one, with the file name additional options can be given.\nThis is also known as a DSN (Data Source Name) string.\n\nOptions are append after the filename of the SQLite database.\nThe database filename and options are separated by an `?` (Question Mark).\nOptions should be URL-encoded (see [url.QueryEscape](https://golang.org/pkg/net/url/#QueryEscape)).\n\nThis also applies when using an in-memory database instead of a file.\n\nOptions can be given using the following format: `KEYWORD=VALUE` and multiple options can be combined with the `&` ampersand.\n\nThis library supports DSN options of SQLite itself and provides additional options.\n\nBoolean values can be one of:\n* `0` `no` `false` `off`\n* `1` `yes` `true` `on`\n\n| Name | Key | Value(s) | Description |\n|------|-----|----------|-------------|\n| UA - Create | `_auth` | - | Create User Authentication, for more information see [User Authentication](#user-authentication) |\n| UA - Username | `_auth_user` | `string` | Username for User Authentication, for more information see [User Authentication](#user-authentication) |\n| UA - Password | `_auth_pass` | `string` | Password for User Authentication, for more information see [User Authentication](#user-authentication) |\n| UA - Crypt | `_auth_crypt` | <ul><li>SHA1</li><li>SSHA1</li><li>SHA256</li><li>SSHA256</li><li>SHA384</li><li>SSHA384</li><li>SHA512</li><li>SSHA512</li></ul> | Password encoder to use for User Authentication, for more information see [User Authentication](#user-authentication) |\n| UA - Salt | `_auth_salt` | `string` | Salt to use if the configure password encoder requires a salt, for User Authentication, for more information see [User Authentication](#user-authentication) |\n| Auto Vacuum | `_auto_vacuum` \\| `_vacuum` | <ul><li>`0` \\| `none`</li><li>`1` \\| `full`</li><li>`2` \\| `incremental`</li></ul> | For more information see [PRAGMA auto_vacuum](https://www.sqlite.org/pragma.html#pragma_auto_vacuum) |\n| Busy Timeout | `_busy_timeout` \\| `_timeout` | `int` | Specify value for sqlite3_busy_timeout. For more information see [PRAGMA busy_timeout](https://www.sqlite.org/pragma.html#pragma_busy_timeout) |\n| Case Sensitive LIKE | `_case_sensitive_like` \\| `_cslike` | `boolean` | For more information see [PRAGMA case_sensitive_like](https://www.sqlite.org/pragma.html#pragma_case_sensitive_like) |\n| Defer Foreign Keys | `_defer_foreign_keys` \\| `_defer_fk` | `boolean` | For more information see [PRAGMA defer_foreign_keys](https://www.sqlite.org/pragma.html#pragma_defer_foreign_keys) |\n| Foreign Keys | `_foreign_keys` \\| `_fk` | `boolean` | For more information see [PRAGMA foreign_keys](https://www.sqlite.org/pragma.html#pragma_foreign_keys) |\n| Ignore CHECK Constraints | `_ignore_check_constraints` | `boolean` | For more information see [PRAGMA ignore_check_constraints](https://www.sqlite.org/pragma.html#pragma_ignore_check_constraints) |\n| Immutable | `immutable` | `boolean` | For more information see [Immutable](https://www.sqlite.org/c3ref/open.html) |\n| Journal Mode | `_journal_mode` \\| `_journal` | <ul><li>DELETE</li><li>TRUNCATE</li><li>PERSIST</li><li>MEMORY</li><li>WAL</li><li>OFF</li></ul> | For more information see [PRAGMA journal_mode](https://www.sqlite.org/pragma.html#pragma_journal_mode) |\n| Locking Mode | `_locking_mode` \\| `_locking` | <ul><li>NORMAL</li><li>EXCLUSIVE</li></ul> | For more information see [PRAGMA locking_mode](https://www.sqlite.org/pragma.html#pragma_locking_mode) |\n| Mode | `mode` | <ul><li>ro</li><li>rw</li><li>rwc</li><li>memory</li></ul> | Access Mode of the database. For more information see [SQLite Open](https://www.sqlite.org/c3ref/open.html) |\n| Mutex Locking | `_mutex` | <ul><li>no</li><li>full</li></ul> | Specify mutex mode. |\n| Query Only | `_query_only` | `boolean` | For more information see [PRAGMA query_only](https://www.sqlite.org/pragma.html#pragma_query_only) |\n| Recursive Triggers | `_recursive_triggers` \\| `_rt` | `boolean` | For more information see [PRAGMA recursive_triggers](https://www.sqlite.org/pragma.html#pragma_recursive_triggers) |\n| Secure Delete | `_secure_delete` | `boolean` \\| `FAST` | For more information see [PRAGMA secure_delete](https://www.sqlite.org/pragma.html#pragma_secure_delete) |\n| Shared-Cache Mode | `cache` | <ul><li>shared</li><li>private</li></ul> | Set cache mode for more information see [sqlite.org](https://www.sqlite.org/sharedcache.html) |\n| Synchronous | `_synchronous` \\| `_sync` | <ul><li>0 \\| OFF</li><li>1 \\| NORMAL</li><li>2 \\| FULL</li><li>3 \\| EXTRA</li></ul> | For more information see [PRAGMA synchronous](https://www.sqlite.org/pragma.html#pragma_synchronous) |\n| Time Zone Location | `_loc` | auto | Specify location of time format. |\n| Transaction Lock | `_txlock` | <ul><li>immediate</li><li>deferred</li><li>exclusive</li></ul> | Specify locking behavior for transactions. |\n| Writable Schema | `_writable_schema` | `Boolean` | When this pragma is on, the SQLITE_MASTER tables in which database can be changed using ordinary UPDATE, INSERT, and DELETE statements. Warning: misuse of this pragma can easily result in a corrupt database file. |\n| Cache Size | `_cache_size` | `int` | Maximum cache size; default is 2000K (2M). See [PRAGMA cache_size](https://sqlite.org/pragma.html#pragma_cache_size) |\n\n\n## DSN Examples\n\n```\nfile:test.db?cache=shared&mode=memory\n```\n\n# Features\n\nThis package allows additional configuration of features available within SQLite3 to be enabled or disabled by golang build constraints also known as build `tags`.\n\nClick [here](https://golang.org/pkg/go/build/#hdr-Build_Constraints) for more information about build tags / constraints.\n\n### Usage\n\nIf you wish to build this library with additional extensions / features, use the following command:\n\n```bash\ngo build -tags \"<FEATURE>\"\n```\n\nFor available features, see the extension list.\nWhen using multiple build tags, all the different tags should be space delimited.\n\nExample:\n\n```bash\ngo build -tags \"icu json1 fts5 secure_delete\"\n```\n\n### Feature / Extension List\n\n| Extension | Build Tag | Description |\n|-----------|-----------|-------------|\n| Additional Statistics | sqlite_stat4 | This option adds additional logic to the ANALYZE command and to the query planner that can help SQLite to chose a better query plan under certain situations. The ANALYZE command is enhanced to collect histogram data from all columns of every index and store that data in the sqlite_stat4 table.<br><br>The query planner will then use the histogram data to help it make better index choices. The downside of this compile-time option is that it violates the query planner stability guarantee making it more difficult to ensure consistent performance in mass-produced applications.<br><br>SQLITE_ENABLE_STAT4 is an enhancement of SQLITE_ENABLE_STAT3. STAT3 only recorded histogram data for the left-most column of each index whereas the STAT4 enhancement records histogram data from all columns of each index.<br><br>The SQLITE_ENABLE_STAT3 compile-time option is a no-op and is ignored if the SQLITE_ENABLE_STAT4 compile-time option is used |\n| Allow URI Authority | sqlite_allow_uri_authority | URI filenames normally throws an error if the authority section is not either empty or \"localhost\".<br><br>However, if SQLite is compiled with the SQLITE_ALLOW_URI_AUTHORITY compile-time option, then the URI is converted into a Uniform Naming Convention (UNC) filename and passed down to the underlying operating system that way |\n| App Armor | sqlite_app_armor | When defined, this C-preprocessor macro activates extra code that attempts to detect misuse of the SQLite API, such as passing in NULL pointers to required parameters or using objects after they have been destroyed. <br><br>App Armor is not available under `Windows`. |\n| Disable Load Extensions | sqlite_omit_load_extension | Loading of external extensions is enabled by default.<br><br>To disable extension loading add the build tag `sqlite_omit_load_extension`. |\n| Enable Serialization with `libsqlite3` | sqlite_serialize | Serialization and deserialization of a SQLite database is available by default, unless the build tag `libsqlite3` is set.<br><br>To enable this functionality even if `libsqlite3` is set, add the build tag `sqlite_serialize`. |\n| Foreign Keys | sqlite_foreign_keys | This macro determines whether enforcement of foreign key constraints is enabled or disabled by default for new database connections.<br><br>Each database connection can always turn enforcement of foreign key constraints on and off and run-time using the foreign_keys pragma.<br><br>Enforcement of foreign key constraints is normally off by default, but if this compile-time parameter is set to 1, enforcement of foreign key constraints will be on by default | \n| Full Auto Vacuum | sqlite_vacuum_full | Set the default auto vacuum to full |\n| Incremental Auto Vacuum | sqlite_vacuum_incr | Set the default auto vacuum to incremental |\n| Full Text Search Engine | sqlite_fts5 | When this option is defined in the amalgamation, versions 5 of the full-text search engine (fts5) is added to the build automatically |\n|  International Components for Unicode | sqlite_icu | This option causes the International Components for Unicode or \"ICU\" extension to SQLite to be added to the build |\n| Introspect PRAGMAS | sqlite_introspect | This option adds some extra PRAGMA statements. <ul><li>PRAGMA function_list</li><li>PRAGMA module_list</li><li>PRAGMA pragma_list</li></ul> |\n| JSON SQL Functions | sqlite_json | When this option is defined in the amalgamation, the JSON SQL functions are added to the build automatically |\n| Math Functions | sqlite_math_functions | This compile-time option enables built-in scalar math functions. For more information see [Built-In Mathematical SQL Functions](https://www.sqlite.org/lang_mathfunc.html) |\n| OS Trace | sqlite_os_trace | This option enables OSTRACE() debug logging. This can be verbose and should not be used in production. |\n| Pre Update Hook | sqlite_preupdate_hook | Registers a callback function that is invoked prior to each INSERT, UPDATE, and DELETE operation on a database table. |\n| Secure Delete | sqlite_secure_delete | This compile-time option changes the default setting of the secure_delete pragma.<br><br>When this option is not used, secure_delete defaults to off. When this option is present, secure_delete defaults to on.<br><br>The secure_delete setting causes deleted content to be overwritten with zeros. There is a small performance penalty since additional I/O must occur.<br><br>On the other hand, secure_delete can prevent fragments of sensitive information from lingering in unused parts of the database file after it has been deleted. See the documentation on the secure_delete pragma for additional information |\n| Secure Delete (FAST) | sqlite_secure_delete_fast | For more information see [PRAGMA secure_delete](https://www.sqlite.org/pragma.html#pragma_secure_delete) |\n| Tracing / Debug | sqlite_trace | Activate trace functions |\n| User Authentication | sqlite_userauth | SQLite User Authentication see [User Authentication](#user-authentication) for more information. |\n| Virtual Tables | sqlite_vtable | SQLite Virtual Tables see [SQLite Official VTABLE Documentation](https://www.sqlite.org/vtab.html) for more information, and a [full example here](https://github.com/mattn/go-sqlite3/tree/master/_example/vtable) |\n\n# Compilation\n\nThis package requires the `CGO_ENABLED=1` environment variable if not set by default, and the presence of the `gcc` compiler.\n\nIf you need to add additional CFLAGS or LDFLAGS to the build command, and do not want to modify this package, then this can be achieved by using the `CGO_CFLAGS` and `CGO_LDFLAGS` environment variables.\n\n## Android\n\nThis package can be compiled for android.\nCompile with:\n\n```bash\ngo build -tags \"android\"\n```\n\nFor more information see [#201](https://github.com/mattn/go-sqlite3/issues/201)\n\n# ARM\n\nTo compile for `ARM` use the following environment:\n\n```bash\nenv CC=arm-linux-gnueabihf-gcc CXX=arm-linux-gnueabihf-g++ \\\n    CGO_ENABLED=1 GOOS=linux GOARCH=arm GOARM=7 \\\n    go build -v \n```\n\nAdditional information:\n- [#242](https://github.com/mattn/go-sqlite3/issues/242)\n- [#504](https://github.com/mattn/go-sqlite3/issues/504)\n\n# Cross Compile\n\nThis library can be cross-compiled.\n\nIn some cases you are required to the `CC` environment variable with the cross compiler.\n\n## Cross Compiling from macOS\nThe simplest way to cross compile from macOS is to use [xgo](https://github.com/karalabe/xgo).\n\nSteps:\n- Install [musl-cross](https://github.com/FiloSottile/homebrew-musl-cross) (`brew install FiloSottile/musl-cross/musl-cross`).\n- Run `CC=x86_64-linux-musl-gcc CXX=x86_64-linux-musl-g++ GOARCH=amd64 GOOS=linux CGO_ENABLED=1 go build -ldflags \"-linkmode external -extldflags -static\"`.\n\nPlease refer to the project's [README](https://github.com/FiloSottile/homebrew-musl-cross#readme) for further information.\n\n# Google Cloud Platform\n\nBuilding on GCP is not possible because Google Cloud Platform does not allow `gcc` to be executed.\n\nPlease work only with compiled final binaries.\n\n## Linux\n\nTo compile this package on Linux, you must install the development tools for your linux distribution.\n\nTo compile under linux use the build tag `linux`.\n\n```bash\ngo build -tags \"linux\"\n```\n\nIf you wish to link directly to libsqlite3 then you can use the `libsqlite3` build tag.\n\n```\ngo build -tags \"libsqlite3 linux\"\n```\n\n### Alpine\n\nWhen building in an `alpine` container  run the following command before building:\n\n```\napk add --update gcc musl-dev\n```\n\n### Fedora\n\n```bash\nsudo yum groupinstall \"Development Tools\" \"Development Libraries\"\n```\n\n### Ubuntu\n\n```bash\nsudo apt-get install build-essential\n```\n\n## macOS\n\nmacOS should have all the tools present to compile this package. If not, install XCode to add all the developers tools.\n\nRequired dependency:\n\n```bash\nbrew install sqlite3\n```\n\nFor macOS, there is an additional package to install which is required if you wish to build the `icu` extension.\n\nThis additional package can be installed with `homebrew`:\n\n```bash\nbrew upgrade icu4c\n```\n\nTo compile for macOS on x86:\n\n```bash\ngo build -tags \"darwin amd64\"\n```\n\nTo compile for macOS on ARM chips:\n\n```bash\ngo build -tags \"darwin arm64\"\n```\n\nIf you wish to link directly to libsqlite3, use the `libsqlite3` build tag:\n\n```\n# x86 \ngo build -tags \"libsqlite3 darwin amd64\"\n# ARM\ngo build -tags \"libsqlite3 darwin arm64\"\n```\n\nAdditional information:\n- [#206](https://github.com/mattn/go-sqlite3/issues/206)\n- [#404](https://github.com/mattn/go-sqlite3/issues/404)\n\n## Windows\n\nTo compile this package on Windows, you must have the `gcc` compiler installed.\n\n1) Install a Windows `gcc` toolchain.\n2) Add the `bin` folder to the Windows path, if the installer did not do this by default.\n3) Open a terminal for the TDM-GCC toolchain, which can be found in the Windows Start menu.\n4) Navigate to your project folder and run the `go build ...` command for this package.\n\nFor example the TDM-GCC Toolchain can be found [here](https://jmeubank.github.io/tdm-gcc/).\n\n## Errors\n\n- Compile error: `can not be used when making a shared object; recompile with -fPIC`\n\n    When receiving a compile time error referencing recompile with `-FPIC` then you\n    are probably using a hardend system.\n\n    You can compile the library on a hardend system with the following command.\n\n    ```bash\n    go build -ldflags '-extldflags=-fno-PIC'\n    ```\n\n    More details see [#120](https://github.com/mattn/go-sqlite3/issues/120)\n\n- Can't build go-sqlite3 on windows 64bit.\n\n    > Probably, you are using go 1.0, go1.0 has a problem when it comes to compiling/linking on windows 64bit.\n    > See: [#27](https://github.com/mattn/go-sqlite3/issues/27)\n\n- `go get github.com/mattn/go-sqlite3` throws compilation error.\n\n    `gcc` throws: `internal compiler error`\n\n    Remove the download repository from your disk and try re-install with:\n\n    ```bash\n    go install github.com/mattn/go-sqlite3\n    ```\n\n# User Authentication\n\nThis package supports the SQLite User Authentication module.\n\n## Compile\n\nTo use the User authentication module, the package has to be compiled with the tag `sqlite_userauth`. See [Features](#features).\n\n## Usage\n\n### Create protected database\n\nTo create a database protected by user authentication, provide the following argument to the connection string `_auth`.\nThis will enable user authentication within the database. This option however requires two additional arguments:\n\n- `_auth_user`\n- `_auth_pass`\n\nWhen `_auth` is present in the connection string user authentication will be enabled and the provided user will be created\nas an `admin` user. After initial creation, the parameter `_auth` has no effect anymore and can be omitted from the connection string.\n\nExample connection strings:\n\nCreate an user authentication database with user `admin` and password `admin`:\n\n`file:test.s3db?_auth&_auth_user=admin&_auth_pass=admin`\n\nCreate an user authentication database with user `admin` and password `admin` and use `SHA1` for the password encoding:\n\n`file:test.s3db?_auth&_auth_user=admin&_auth_pass=admin&_auth_crypt=sha1`\n\n### Password Encoding\n\nThe passwords within the user authentication module of SQLite are encoded with the SQLite function `sqlite_cryp`.\nThis function uses a ceasar-cypher which is quite insecure.\nThis library provides several additional password encoders which can be configured through the connection string.\n\nThe password cypher can be configured with the key `_auth_crypt`. And if the configured password encoder also requires an\nsalt this can be configured with `_auth_salt`.\n\n#### Available Encoders\n\n- SHA1\n- SSHA1 (Salted SHA1)\n- SHA256\n- SSHA256 (salted SHA256)\n- SHA384\n- SSHA384 (salted SHA384)\n- SHA512\n- SSHA512 (salted SHA512)\n\n### Restrictions\n\nOperations on the database regarding user management can only be preformed by an administrator user.\n\n### Support\n\nThe user authentication supports two kinds of users:\n\n- administrators\n- regular users\n\n### User Management\n\nUser management can be done by directly using the `*SQLiteConn` or by SQL.\n\n#### SQL\n\nThe following sql functions are available for user management:\n\n| Function | Arguments | Description |\n|----------|-----------|-------------|\n| `authenticate` | username `string`, password `string` | Will authenticate an user, this is done by the connection; and should not be used manually. |\n| `auth_user_add` | username `string`, password `string`, admin `int` | This function will add an user to the database.<br>if the database is not protected by user authentication it will enable it. Argument `admin` is an integer identifying if the added user should be an administrator. Only Administrators can add administrators. |\n| `auth_user_change` | username `string`, password `string`, admin `int` | Function to modify an user. Users can change their own password, but only an administrator can change the administrator flag. |\n| `authUserDelete` | username `string` | Delete an user from the database. Can only be used by an administrator. The current logged in administrator cannot be deleted. This is to make sure their is always an administrator remaining. |\n\nThese functions will return an integer:\n\n- 0 (SQLITE_OK)\n- 23 (SQLITE_AUTH) Failed to perform due to authentication or insufficient privileges\n\n##### Examples\n\n```sql\n// Autheticate user\n// Create Admin User\nSELECT auth_user_add('admin2', 'admin2', 1);\n\n// Change password for user\nSELECT auth_user_change('user', 'userpassword', 0);\n\n// Delete user\nSELECT user_delete('user');\n```\n\n#### *SQLiteConn\n\nThe following functions are available for User authentication from the `*SQLiteConn`:\n\n| Function | Description |\n|----------|-------------|\n| `Authenticate(username, password string) error` | Authenticate user |\n| `AuthUserAdd(username, password string, admin bool) error` | Add user |\n| `AuthUserChange(username, password string, admin bool) error` | Modify user |\n| `AuthUserDelete(username string) error` | Delete user |\n\n### Attached database\n\nWhen using attached databases, SQLite will use the authentication from the `main` database for the attached database(s).\n\n# Extensions\n\nIf you want your own extension to be listed here, or you want to add a reference to an extension; please submit an Issue for this.\n\n## Spatialite\n\nSpatialite is available as an extension to SQLite, and can be used in combination with this repository.\nFor an example, see [shaxbee/go-spatialite](https://github.com/shaxbee/go-spatialite).\n\n## extension-functions.c from SQLite3 Contrib\n\nextension-functions.c is available as an extension to SQLite, and provides the following functions:\n\n- Math: acos, asin, atan, atn2, atan2, acosh, asinh, atanh, difference, degrees, radians, cos, sin, tan, cot, cosh, sinh, tanh, coth, exp, log, log10, power, sign, sqrt, square, ceil, floor, pi.\n- String: replicate, charindex, leftstr, rightstr, ltrim, rtrim, trim, replace, reverse, proper, padl, padr, padc, strfilter.\n- Aggregate: stdev, variance, mode, median, lower_quartile, upper_quartile\n\nFor an example, see [dinedal/go-sqlite3-extension-functions](https://github.com/dinedal/go-sqlite3-extension-functions).\n\n# FAQ\n\n- Getting insert error while query is opened.\n\n    > You can pass some arguments into the connection string, for example, a URI.\n    > See: [#39](https://github.com/mattn/go-sqlite3/issues/39)\n\n- Do you want to cross compile? mingw on Linux or Mac?\n\n    > See: [#106](https://github.com/mattn/go-sqlite3/issues/106)\n    > See also: http://www.limitlessfx.com/cross-compile-golang-app-for-windows-from-linux.html\n\n- Want to get time.Time with current locale\n\n    Use `_loc=auto` in SQLite3 filename schema like `file:foo.db?_loc=auto`.\n\n- Can I use this in multiple routines concurrently?\n\n    Yes for readonly. But not for writable. See [#50](https://github.com/mattn/go-sqlite3/issues/50), [#51](https://github.com/mattn/go-sqlite3/issues/51), [#209](https://github.com/mattn/go-sqlite3/issues/209), [#274](https://github.com/mattn/go-sqlite3/issues/274).\n\n- Why I'm getting `no such table` error?\n\n    Why is it racy if I use a `sql.Open(\"sqlite3\", \":memory:\")` database?\n\n    Each connection to `\":memory:\"` opens a brand new in-memory sql database, so if\n    the stdlib's sql engine happens to open another connection and you've only\n    specified `\":memory:\"`, that connection will see a brand new database. A\n    workaround is to use `\"file::memory:?cache=shared\"` (or `\"file:foobar?mode=memory&cache=shared\"`). Every\n    connection to this string will point to the same in-memory database.\n    \n    Note that if the last database connection in the pool closes, the in-memory database is deleted. Make sure the [max idle connection limit](https://golang.org/pkg/database/sql/#DB.SetMaxIdleConns) is > 0, and the [connection lifetime](https://golang.org/pkg/database/sql/#DB.SetConnMaxLifetime) is infinite.\n    \n    For more information see:\n    * [#204](https://github.com/mattn/go-sqlite3/issues/204)\n    * [#511](https://github.com/mattn/go-sqlite3/issues/511)\n    * https://www.sqlite.org/sharedcache.html#shared_cache_and_in_memory_databases\n    * https://www.sqlite.org/inmemorydb.html#sharedmemdb\n\n- Reading from database with large amount of goroutines fails on OSX.\n\n    OS X limits OS-wide to not have more than 1000 files open simultaneously by default.\n\n    For more information, see [#289](https://github.com/mattn/go-sqlite3/issues/289)\n\n- Trying to execute a `.` (dot) command throws an error.\n\n    Error: `Error: near \".\": syntax error`\n    Dot command are part of SQLite3 CLI, not of this library.\n\n    You need to implement the feature or call the sqlite3 cli.\n\n    More information see [#305](https://github.com/mattn/go-sqlite3/issues/305).\n\n- Error: `database is locked`\n\n    When you get a database is locked, please use the following options.\n\n    Add to DSN: `cache=shared`\n\n    Example:\n    ```go\n    db, err := sql.Open(\"sqlite3\", \"file:locked.sqlite?cache=shared\")\n    ```\n\n    Next, please set the database connections of the SQL package to 1:\n    \n    ```go\n    db.SetMaxOpenConns(1)\n    ```\n\n    For more information, see [#209](https://github.com/mattn/go-sqlite3/issues/209).\n\n## Contributors\n\n### Code Contributors\n\nThis project exists thanks to all the people who [[contribute](CONTRIBUTING.md)].\n<a href=\"https://github.com/mattn/go-sqlite3/graphs/contributors\"><img src=\"https://opencollective.com/mattn-go-sqlite3/contributors.svg?width=890&button=false\" /></a>\n\n### Financial Contributors\n\nBecome a financial contributor and help us sustain our community. [[Contribute here](https://opencollective.com/mattn-go-sqlite3/contribute)].\n\n#### Individuals\n\n<a href=\"https://opencollective.com/mattn-go-sqlite3\"><img src=\"https://opencollective.com/mattn-go-sqlite3/individuals.svg?width=890\"></a>\n\n#### Organizations\n\nSupport this project with your organization. Your logo will show up here with a link to your website. [[Contribute](https://opencollective.com/mattn-go-sqlite3/contribute)]\n\n<a href=\"https://opencollective.com/mattn-go-sqlite3/organization/0/website\"><img src=\"https://opencollective.com/mattn-go-sqlite3/organization/0/avatar.svg\"></a>\n<a href=\"https://opencollective.com/mattn-go-sqlite3/organization/1/website\"><img src=\"https://opencollective.com/mattn-go-sqlite3/organization/1/avatar.svg\"></a>\n<a href=\"https://opencollective.com/mattn-go-sqlite3/organization/2/website\"><img src=\"https://opencollective.com/mattn-go-sqlite3/organization/2/avatar.svg\"></a>\n<a href=\"https://opencollective.com/mattn-go-sqlite3/organization/3/website\"><img src=\"https://opencollective.com/mattn-go-sqlite3/organization/3/avatar.svg\"></a>\n<a href=\"https://opencollective.com/mattn-go-sqlite3/organization/4/website\"><img src=\"https://opencollective.com/mattn-go-sqlite3/organization/4/avatar.svg\"></a>\n<a href=\"https://opencollective.com/mattn-go-sqlite3/organization/5/website\"><img src=\"https://opencollective.com/mattn-go-sqlite3/organization/5/avatar.svg\"></a>\n<a href=\"https://opencollective.com/mattn-go-sqlite3/organization/6/website\"><img src=\"https://opencollective.com/mattn-go-sqlite3/organization/6/avatar.svg\"></a>\n<a href=\"https://opencollective.com/mattn-go-sqlite3/organization/7/website\"><img src=\"https://opencollective.com/mattn-go-sqlite3/organization/7/avatar.svg\"></a>\n<a href=\"https://opencollective.com/mattn-go-sqlite3/organization/8/website\"><img src=\"https://opencollective.com/mattn-go-sqlite3/organization/8/avatar.svg\"></a>\n<a href=\"https://opencollective.com/mattn-go-sqlite3/organization/9/website\"><img src=\"https://opencollective.com/mattn-go-sqlite3/organization/9/avatar.svg\"></a>\n\n# License\n\nMIT: http://mattn.mit-license.org/2018\n\nsqlite3-binding.c, sqlite3-binding.h, sqlite3ext.h\n\nThe -binding suffix was added to avoid build failures under gccgo.\n\nIn this repository, those files are an amalgamation of code that was copied from SQLite3. The license of that code is the same as the license of SQLite3.\n\n# Author\n\nYasuhiro Matsumoto (a.k.a mattn)\n\nG.J.R. Timmer\n"
        },
        {
          "name": "_example",
          "type": "tree",
          "content": null
        },
        {
          "name": "backup.go",
          "type": "blob",
          "size": 2.166015625,
          "content": "// Copyright (C) 2019 Yasuhiro Matsumoto <mattn.jp@gmail.com>.\n//\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\npackage sqlite3\n\n/*\n#ifndef USE_LIBSQLITE3\n#include \"sqlite3-binding.h\"\n#else\n#include <sqlite3.h>\n#endif\n#include <stdlib.h>\n*/\nimport \"C\"\nimport (\n\t\"runtime\"\n\t\"unsafe\"\n)\n\n// SQLiteBackup implement interface of Backup.\ntype SQLiteBackup struct {\n\tb *C.sqlite3_backup\n}\n\n// Backup make backup from src to dest.\nfunc (destConn *SQLiteConn) Backup(dest string, srcConn *SQLiteConn, src string) (*SQLiteBackup, error) {\n\tdestptr := C.CString(dest)\n\tdefer C.free(unsafe.Pointer(destptr))\n\tsrcptr := C.CString(src)\n\tdefer C.free(unsafe.Pointer(srcptr))\n\n\tif b := C.sqlite3_backup_init(destConn.db, destptr, srcConn.db, srcptr); b != nil {\n\t\tbb := &SQLiteBackup{b: b}\n\t\truntime.SetFinalizer(bb, (*SQLiteBackup).Finish)\n\t\treturn bb, nil\n\t}\n\treturn nil, destConn.lastError()\n}\n\n// Step to backs up for one step. Calls the underlying `sqlite3_backup_step`\n// function.  This function returns a boolean indicating if the backup is done\n// and an error signalling any other error. Done is returned if the underlying\n// C function returns SQLITE_DONE (Code 101)\nfunc (b *SQLiteBackup) Step(p int) (bool, error) {\n\tret := C.sqlite3_backup_step(b.b, C.int(p))\n\tif ret == C.SQLITE_DONE {\n\t\treturn true, nil\n\t} else if ret != 0 && ret != C.SQLITE_LOCKED && ret != C.SQLITE_BUSY {\n\t\treturn false, Error{Code: ErrNo(ret)}\n\t}\n\treturn false, nil\n}\n\n// Remaining return whether have the rest for backup.\nfunc (b *SQLiteBackup) Remaining() int {\n\treturn int(C.sqlite3_backup_remaining(b.b))\n}\n\n// PageCount return count of pages.\nfunc (b *SQLiteBackup) PageCount() int {\n\treturn int(C.sqlite3_backup_pagecount(b.b))\n}\n\n// Finish close backup.\nfunc (b *SQLiteBackup) Finish() error {\n\treturn b.Close()\n}\n\n// Close close backup.\nfunc (b *SQLiteBackup) Close() error {\n\tret := C.sqlite3_backup_finish(b.b)\n\n\t// sqlite3_backup_finish() never fails, it just returns the\n\t// error code from previous operations, so clean up before\n\t// checking and returning an error\n\tb.b = nil\n\truntime.SetFinalizer(b, nil)\n\n\tif ret != 0 {\n\t\treturn Error{Code: ErrNo(ret)}\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "backup_test.go",
          "type": "blob",
          "size": 9.7607421875,
          "content": "// Copyright (C) 2019 Yasuhiro Matsumoto <mattn.jp@gmail.com>.\n//\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n//go:build cgo\n// +build cgo\n\npackage sqlite3\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"os\"\n\t\"testing\"\n\t\"time\"\n)\n\n// The number of rows of test data to create in the source database.\n// Can be used to control how many pages are available to be backed up.\nconst testRowCount = 100\n\n// The maximum number of seconds after which the page-by-page backup is considered to have taken too long.\nconst usePagePerStepsTimeoutSeconds = 30\n\n// Test the backup functionality.\nfunc testBackup(t *testing.T, testRowCount int, usePerPageSteps bool) {\n\t// This function will be called multiple times.\n\t// It uses sql.Register(), which requires the name parameter value to be unique.\n\t// There does not currently appear to be a way to unregister a registered driver, however.\n\t// So generate a database driver name that will likely be unique.\n\tvar driverName = fmt.Sprintf(\"sqlite3_testBackup_%v_%v_%v\", testRowCount, usePerPageSteps, time.Now().UnixNano())\n\n\t// The driver's connection will be needed in order to perform the backup.\n\tdriverConns := []*SQLiteConn{}\n\tsql.Register(driverName, &SQLiteDriver{\n\t\tConnectHook: func(conn *SQLiteConn) error {\n\t\t\tdriverConns = append(driverConns, conn)\n\t\t\treturn nil\n\t\t},\n\t})\n\n\t// Connect to the source database.\n\tsrcTempFilename := TempFilename(t)\n\tdefer os.Remove(srcTempFilename)\n\tsrcDb, err := sql.Open(driverName, srcTempFilename)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to open the source database:\", err)\n\t}\n\tdefer srcDb.Close()\n\terr = srcDb.Ping()\n\tif err != nil {\n\t\tt.Fatal(\"Failed to connect to the source database:\", err)\n\t}\n\n\t// Connect to the destination database.\n\tdestTempFilename := TempFilename(t)\n\tdefer os.Remove(destTempFilename)\n\tdestDb, err := sql.Open(driverName, destTempFilename)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to open the destination database:\", err)\n\t}\n\tdefer destDb.Close()\n\terr = destDb.Ping()\n\tif err != nil {\n\t\tt.Fatal(\"Failed to connect to the destination database:\", err)\n\t}\n\n\t// Check the driver connections.\n\tif len(driverConns) != 2 {\n\t\tt.Fatalf(\"Expected 2 driver connections, but found %v.\", len(driverConns))\n\t}\n\tsrcDbDriverConn := driverConns[0]\n\tif srcDbDriverConn == nil {\n\t\tt.Fatal(\"The source database driver connection is nil.\")\n\t}\n\tdestDbDriverConn := driverConns[1]\n\tif destDbDriverConn == nil {\n\t\tt.Fatal(\"The destination database driver connection is nil.\")\n\t}\n\n\t// Generate some test data for the given ID.\n\tvar generateTestData = func(id int) string {\n\t\treturn fmt.Sprintf(\"test-%v\", id)\n\t}\n\n\t// Populate the source database with a test table containing some test data.\n\ttx, err := srcDb.Begin()\n\tif err != nil {\n\t\tt.Fatal(\"Failed to begin a transaction when populating the source database:\", err)\n\t}\n\t_, err = srcDb.Exec(\"CREATE TABLE test (id INTEGER PRIMARY KEY, value TEXT)\")\n\tif err != nil {\n\t\ttx.Rollback()\n\t\tt.Fatal(\"Failed to create the source database \\\"test\\\" table:\", err)\n\t}\n\tfor id := 0; id < testRowCount; id++ {\n\t\t_, err = srcDb.Exec(\"INSERT INTO test (id, value) VALUES (?, ?)\", id, generateTestData(id))\n\t\tif err != nil {\n\t\t\ttx.Rollback()\n\t\t\tt.Fatal(\"Failed to insert a row into the source database \\\"test\\\" table:\", err)\n\t\t}\n\t}\n\terr = tx.Commit()\n\tif err != nil {\n\t\tt.Fatal(\"Failed to populate the source database:\", err)\n\t}\n\n\t// Confirm that the destination database is initially empty.\n\tvar destTableCount int\n\terr = destDb.QueryRow(\"SELECT COUNT(*) FROM sqlite_master WHERE type = 'table'\").Scan(&destTableCount)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to check the destination table count:\", err)\n\t}\n\tif destTableCount != 0 {\n\t\tt.Fatalf(\"The destination database is not empty; %v table(s) found.\", destTableCount)\n\t}\n\n\t// Prepare to perform the backup.\n\tbackup, err := destDbDriverConn.Backup(\"main\", srcDbDriverConn, \"main\")\n\tif err != nil {\n\t\tt.Fatal(\"Failed to initialize the backup:\", err)\n\t}\n\n\t// Allow the initial page count and remaining values to be retrieved.\n\t// According to <https://www.sqlite.org/c3ref/backup_finish.html>, the page count and remaining values are \"... only updated by sqlite3_backup_step().\"\n\tisDone, err := backup.Step(0)\n\tif err != nil {\n\t\tt.Fatal(\"Unable to perform an initial 0-page backup step:\", err)\n\t}\n\tif isDone {\n\t\tt.Fatal(\"Backup is unexpectedly done.\")\n\t}\n\n\t// Check that the page count and remaining values are reasonable.\n\tinitialPageCount := backup.PageCount()\n\tif initialPageCount <= 0 {\n\t\tt.Fatalf(\"Unexpected initial page count value: %v\", initialPageCount)\n\t}\n\tinitialRemaining := backup.Remaining()\n\tif initialRemaining <= 0 {\n\t\tt.Fatalf(\"Unexpected initial remaining value: %v\", initialRemaining)\n\t}\n\tif initialRemaining != initialPageCount {\n\t\tt.Fatalf(\"Initial remaining value differs from the initial page count value; remaining: %v; page count: %v\", initialRemaining, initialPageCount)\n\t}\n\n\t// Perform the backup.\n\tif usePerPageSteps {\n\t\tvar startTime = time.Now().Unix()\n\n\t\t// Test backing-up using a page-by-page approach.\n\t\tvar latestRemaining = initialRemaining\n\t\tfor {\n\t\t\t// Perform the backup step.\n\t\t\tisDone, err = backup.Step(1)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(\"Failed to perform a backup step:\", err)\n\t\t\t}\n\n\t\t\t// The page count should remain unchanged from its initial value.\n\t\t\tcurrentPageCount := backup.PageCount()\n\t\t\tif currentPageCount != initialPageCount {\n\t\t\t\tt.Fatalf(\"Current page count differs from the initial page count; initial page count: %v; current page count: %v\", initialPageCount, currentPageCount)\n\t\t\t}\n\n\t\t\t// There should now be one less page remaining.\n\t\t\tcurrentRemaining := backup.Remaining()\n\t\t\texpectedRemaining := latestRemaining - 1\n\t\t\tif currentRemaining != expectedRemaining {\n\t\t\t\tt.Fatalf(\"Unexpected remaining value; expected remaining value: %v; actual remaining value: %v\", expectedRemaining, currentRemaining)\n\t\t\t}\n\t\t\tlatestRemaining = currentRemaining\n\n\t\t\tif isDone {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\t// Limit the runtime of the backup attempt.\n\t\t\tif (time.Now().Unix() - startTime) > usePagePerStepsTimeoutSeconds {\n\t\t\t\tt.Fatal(\"Backup is taking longer than expected.\")\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Test the copying of all remaining pages.\n\t\tisDone, err = backup.Step(-1)\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Failed to perform a backup step:\", err)\n\t\t}\n\t\tif !isDone {\n\t\t\tt.Fatal(\"Backup is unexpectedly not done.\")\n\t\t}\n\t}\n\n\t// Check that the page count and remaining values are reasonable.\n\tfinalPageCount := backup.PageCount()\n\tif finalPageCount != initialPageCount {\n\t\tt.Fatalf(\"Final page count differs from the initial page count; initial page count: %v; final page count: %v\", initialPageCount, finalPageCount)\n\t}\n\tfinalRemaining := backup.Remaining()\n\tif finalRemaining != 0 {\n\t\tt.Fatalf(\"Unexpected remaining value: %v\", finalRemaining)\n\t}\n\n\t// Finish the backup.\n\terr = backup.Finish()\n\tif err != nil {\n\t\tt.Fatal(\"Failed to finish backup:\", err)\n\t}\n\n\t// Confirm that the \"test\" table now exists in the destination database.\n\tvar doesTestTableExist bool\n\terr = destDb.QueryRow(\"SELECT EXISTS (SELECT 1 FROM sqlite_master WHERE type = 'table' AND name = 'test' LIMIT 1) AS test_table_exists\").Scan(&doesTestTableExist)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to check if the \\\"test\\\" table exists in the destination database:\", err)\n\t}\n\tif !doesTestTableExist {\n\t\tt.Fatal(\"The \\\"test\\\" table could not be found in the destination database.\")\n\t}\n\n\t// Confirm that the number of rows in the destination database's \"test\" table matches that of the source table.\n\tvar actualTestTableRowCount int\n\terr = destDb.QueryRow(\"SELECT COUNT(*) FROM test\").Scan(&actualTestTableRowCount)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to determine the rowcount of the \\\"test\\\" table in the destination database:\", err)\n\t}\n\tif testRowCount != actualTestTableRowCount {\n\t\tt.Fatalf(\"Unexpected destination \\\"test\\\" table row count; expected: %v; found: %v\", testRowCount, actualTestTableRowCount)\n\t}\n\n\t// Check each of the rows in the destination database.\n\tfor id := 0; id < testRowCount; id++ {\n\t\tvar checkedValue string\n\t\terr = destDb.QueryRow(\"SELECT value FROM test WHERE id = ?\", id).Scan(&checkedValue)\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Failed to query the \\\"test\\\" table in the destination database:\", err)\n\t\t}\n\n\t\tvar expectedValue = generateTestData(id)\n\t\tif checkedValue != expectedValue {\n\t\t\tt.Fatalf(\"Unexpected value in the \\\"test\\\" table in the destination database; expected value: %v; actual value: %v\", expectedValue, checkedValue)\n\t\t}\n\t}\n}\n\nfunc TestBackupStepByStep(t *testing.T) {\n\ttestBackup(t, testRowCount, true)\n}\n\nfunc TestBackupAllRemainingPages(t *testing.T) {\n\ttestBackup(t, testRowCount, false)\n}\n\n// Test the error reporting when preparing to perform a backup.\nfunc TestBackupError(t *testing.T) {\n\tconst driverName = \"sqlite3_TestBackupError\"\n\n\t// The driver's connection will be needed in order to perform the backup.\n\tvar dbDriverConn *SQLiteConn\n\tsql.Register(driverName, &SQLiteDriver{\n\t\tConnectHook: func(conn *SQLiteConn) error {\n\t\t\tdbDriverConn = conn\n\t\t\treturn nil\n\t\t},\n\t})\n\n\t// Connect to the database.\n\tdbTempFilename := TempFilename(t)\n\tdefer os.Remove(dbTempFilename)\n\tdb, err := sql.Open(driverName, dbTempFilename)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to open the database:\", err)\n\t}\n\tdefer db.Close()\n\tdb.Ping()\n\n\t// Need the driver connection in order to perform the backup.\n\tif dbDriverConn == nil {\n\t\tt.Fatal(\"Failed to get the driver connection.\")\n\t}\n\n\t// Prepare to perform the backup.\n\t// Intentionally using the same connection for both the source and destination databases, to trigger an error result.\n\tbackup, err := dbDriverConn.Backup(\"main\", dbDriverConn, \"main\")\n\tif err == nil {\n\t\tt.Fatal(\"Failed to get the expected error result.\")\n\t}\n\tconst expectedError = \"source and destination must be distinct\"\n\tif err.Error() != expectedError {\n\t\tt.Fatalf(\"Unexpected error message; expected value: \\\"%v\\\"; actual value: \\\"%v\\\"\", expectedError, err.Error())\n\t}\n\tif backup != nil {\n\t\tt.Fatal(\"Failed to get the expected nil backup result.\")\n\t}\n}\n"
        },
        {
          "name": "callback.go",
          "type": "blob",
          "size": 11.4814453125,
          "content": "// Copyright (C) 2019 Yasuhiro Matsumoto <mattn.jp@gmail.com>.\n//\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\npackage sqlite3\n\n// You can't export a Go function to C and have definitions in the C\n// preamble in the same file, so we have to have callbackTrampoline in\n// its own file. Because we need a separate file anyway, the support\n// code for SQLite custom functions is in here.\n\n/*\n#ifndef USE_LIBSQLITE3\n#include \"sqlite3-binding.h\"\n#else\n#include <sqlite3.h>\n#endif\n#include <stdlib.h>\n\nvoid _sqlite3_result_text(sqlite3_context* ctx, const char* s);\nvoid _sqlite3_result_blob(sqlite3_context* ctx, const void* b, int l);\n*/\nimport \"C\"\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"math\"\n\t\"reflect\"\n\t\"sync\"\n\t\"unsafe\"\n)\n\n//export callbackTrampoline\nfunc callbackTrampoline(ctx *C.sqlite3_context, argc int, argv **C.sqlite3_value) {\n\targs := (*[(math.MaxInt32 - 1) / unsafe.Sizeof((*C.sqlite3_value)(nil))]*C.sqlite3_value)(unsafe.Pointer(argv))[:argc:argc]\n\tfi := lookupHandle(C.sqlite3_user_data(ctx)).(*functionInfo)\n\tfi.Call(ctx, args)\n}\n\n//export stepTrampoline\nfunc stepTrampoline(ctx *C.sqlite3_context, argc C.int, argv **C.sqlite3_value) {\n\targs := (*[(math.MaxInt32 - 1) / unsafe.Sizeof((*C.sqlite3_value)(nil))]*C.sqlite3_value)(unsafe.Pointer(argv))[:int(argc):int(argc)]\n\tai := lookupHandle(C.sqlite3_user_data(ctx)).(*aggInfo)\n\tai.Step(ctx, args)\n}\n\n//export doneTrampoline\nfunc doneTrampoline(ctx *C.sqlite3_context) {\n\tai := lookupHandle(C.sqlite3_user_data(ctx)).(*aggInfo)\n\tai.Done(ctx)\n}\n\n//export compareTrampoline\nfunc compareTrampoline(handlePtr unsafe.Pointer, la C.int, a *C.char, lb C.int, b *C.char) C.int {\n\tcmp := lookupHandle(handlePtr).(func(string, string) int)\n\treturn C.int(cmp(C.GoStringN(a, la), C.GoStringN(b, lb)))\n}\n\n//export commitHookTrampoline\nfunc commitHookTrampoline(handle unsafe.Pointer) int {\n\tcallback := lookupHandle(handle).(func() int)\n\treturn callback()\n}\n\n//export rollbackHookTrampoline\nfunc rollbackHookTrampoline(handle unsafe.Pointer) {\n\tcallback := lookupHandle(handle).(func())\n\tcallback()\n}\n\n//export updateHookTrampoline\nfunc updateHookTrampoline(handle unsafe.Pointer, op int, db *C.char, table *C.char, rowid int64) {\n\tcallback := lookupHandle(handle).(func(int, string, string, int64))\n\tcallback(op, C.GoString(db), C.GoString(table), rowid)\n}\n\n//export authorizerTrampoline\nfunc authorizerTrampoline(handle unsafe.Pointer, op int, arg1 *C.char, arg2 *C.char, arg3 *C.char) int {\n\tcallback := lookupHandle(handle).(func(int, string, string, string) int)\n\treturn callback(op, C.GoString(arg1), C.GoString(arg2), C.GoString(arg3))\n}\n\n//export preUpdateHookTrampoline\nfunc preUpdateHookTrampoline(handle unsafe.Pointer, dbHandle uintptr, op int, db *C.char, table *C.char, oldrowid int64, newrowid int64) {\n\thval := lookupHandleVal(handle)\n\tdata := SQLitePreUpdateData{\n\t\tConn:         hval.db,\n\t\tOp:           op,\n\t\tDatabaseName: C.GoString(db),\n\t\tTableName:    C.GoString(table),\n\t\tOldRowID:     oldrowid,\n\t\tNewRowID:     newrowid,\n\t}\n\tcallback := hval.val.(func(SQLitePreUpdateData))\n\tcallback(data)\n}\n\n// Use handles to avoid passing Go pointers to C.\ntype handleVal struct {\n\tdb  *SQLiteConn\n\tval any\n}\n\nvar handleLock sync.Mutex\nvar handleVals = make(map[unsafe.Pointer]handleVal)\n\nfunc newHandle(db *SQLiteConn, v any) unsafe.Pointer {\n\thandleLock.Lock()\n\tdefer handleLock.Unlock()\n\tval := handleVal{db: db, val: v}\n\tvar p unsafe.Pointer = C.malloc(C.size_t(1))\n\tif p == nil {\n\t\tpanic(\"can't allocate 'cgo-pointer hack index pointer': ptr == nil\")\n\t}\n\thandleVals[p] = val\n\treturn p\n}\n\nfunc lookupHandleVal(handle unsafe.Pointer) handleVal {\n\thandleLock.Lock()\n\tdefer handleLock.Unlock()\n\treturn handleVals[handle]\n}\n\nfunc lookupHandle(handle unsafe.Pointer) any {\n\treturn lookupHandleVal(handle).val\n}\n\nfunc deleteHandles(db *SQLiteConn) {\n\thandleLock.Lock()\n\tdefer handleLock.Unlock()\n\tfor handle, val := range handleVals {\n\t\tif val.db == db {\n\t\t\tdelete(handleVals, handle)\n\t\t\tC.free(handle)\n\t\t}\n\t}\n}\n\n// This is only here so that tests can refer to it.\ntype callbackArgRaw C.sqlite3_value\n\ntype callbackArgConverter func(*C.sqlite3_value) (reflect.Value, error)\n\ntype callbackArgCast struct {\n\tf   callbackArgConverter\n\ttyp reflect.Type\n}\n\nfunc (c callbackArgCast) Run(v *C.sqlite3_value) (reflect.Value, error) {\n\tval, err := c.f(v)\n\tif err != nil {\n\t\treturn reflect.Value{}, err\n\t}\n\tif !val.Type().ConvertibleTo(c.typ) {\n\t\treturn reflect.Value{}, fmt.Errorf(\"cannot convert %s to %s\", val.Type(), c.typ)\n\t}\n\treturn val.Convert(c.typ), nil\n}\n\nfunc callbackArgInt64(v *C.sqlite3_value) (reflect.Value, error) {\n\tif C.sqlite3_value_type(v) != C.SQLITE_INTEGER {\n\t\treturn reflect.Value{}, fmt.Errorf(\"argument must be an INTEGER\")\n\t}\n\treturn reflect.ValueOf(int64(C.sqlite3_value_int64(v))), nil\n}\n\nfunc callbackArgBool(v *C.sqlite3_value) (reflect.Value, error) {\n\tif C.sqlite3_value_type(v) != C.SQLITE_INTEGER {\n\t\treturn reflect.Value{}, fmt.Errorf(\"argument must be an INTEGER\")\n\t}\n\ti := int64(C.sqlite3_value_int64(v))\n\tval := false\n\tif i != 0 {\n\t\tval = true\n\t}\n\treturn reflect.ValueOf(val), nil\n}\n\nfunc callbackArgFloat64(v *C.sqlite3_value) (reflect.Value, error) {\n\tif C.sqlite3_value_type(v) != C.SQLITE_FLOAT {\n\t\treturn reflect.Value{}, fmt.Errorf(\"argument must be a FLOAT\")\n\t}\n\treturn reflect.ValueOf(float64(C.sqlite3_value_double(v))), nil\n}\n\nfunc callbackArgBytes(v *C.sqlite3_value) (reflect.Value, error) {\n\tswitch C.sqlite3_value_type(v) {\n\tcase C.SQLITE_BLOB:\n\t\tl := C.sqlite3_value_bytes(v)\n\t\tp := C.sqlite3_value_blob(v)\n\t\treturn reflect.ValueOf(C.GoBytes(p, l)), nil\n\tcase C.SQLITE_TEXT:\n\t\tl := C.sqlite3_value_bytes(v)\n\t\tc := unsafe.Pointer(C.sqlite3_value_text(v))\n\t\treturn reflect.ValueOf(C.GoBytes(c, l)), nil\n\tdefault:\n\t\treturn reflect.Value{}, fmt.Errorf(\"argument must be BLOB or TEXT\")\n\t}\n}\n\nfunc callbackArgString(v *C.sqlite3_value) (reflect.Value, error) {\n\tswitch C.sqlite3_value_type(v) {\n\tcase C.SQLITE_BLOB:\n\t\tl := C.sqlite3_value_bytes(v)\n\t\tp := (*C.char)(C.sqlite3_value_blob(v))\n\t\treturn reflect.ValueOf(C.GoStringN(p, l)), nil\n\tcase C.SQLITE_TEXT:\n\t\tc := (*C.char)(unsafe.Pointer(C.sqlite3_value_text(v)))\n\t\treturn reflect.ValueOf(C.GoString(c)), nil\n\tdefault:\n\t\treturn reflect.Value{}, fmt.Errorf(\"argument must be BLOB or TEXT\")\n\t}\n}\n\nfunc callbackArgGeneric(v *C.sqlite3_value) (reflect.Value, error) {\n\tswitch C.sqlite3_value_type(v) {\n\tcase C.SQLITE_INTEGER:\n\t\treturn callbackArgInt64(v)\n\tcase C.SQLITE_FLOAT:\n\t\treturn callbackArgFloat64(v)\n\tcase C.SQLITE_TEXT:\n\t\treturn callbackArgString(v)\n\tcase C.SQLITE_BLOB:\n\t\treturn callbackArgBytes(v)\n\tcase C.SQLITE_NULL:\n\t\t// Interpret NULL as a nil byte slice.\n\t\tvar ret []byte\n\t\treturn reflect.ValueOf(ret), nil\n\tdefault:\n\t\tpanic(\"unreachable\")\n\t}\n}\n\nfunc callbackArg(typ reflect.Type) (callbackArgConverter, error) {\n\tswitch typ.Kind() {\n\tcase reflect.Interface:\n\t\tif typ.NumMethod() != 0 {\n\t\t\treturn nil, errors.New(\"the only supported interface type is any\")\n\t\t}\n\t\treturn callbackArgGeneric, nil\n\tcase reflect.Slice:\n\t\tif typ.Elem().Kind() != reflect.Uint8 {\n\t\t\treturn nil, errors.New(\"the only supported slice type is []byte\")\n\t\t}\n\t\treturn callbackArgBytes, nil\n\tcase reflect.String:\n\t\treturn callbackArgString, nil\n\tcase reflect.Bool:\n\t\treturn callbackArgBool, nil\n\tcase reflect.Int64:\n\t\treturn callbackArgInt64, nil\n\tcase reflect.Int8, reflect.Int16, reflect.Int32, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Int, reflect.Uint:\n\t\tc := callbackArgCast{callbackArgInt64, typ}\n\t\treturn c.Run, nil\n\tcase reflect.Float64:\n\t\treturn callbackArgFloat64, nil\n\tcase reflect.Float32:\n\t\tc := callbackArgCast{callbackArgFloat64, typ}\n\t\treturn c.Run, nil\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"don't know how to convert to %s\", typ)\n\t}\n}\n\nfunc callbackConvertArgs(argv []*C.sqlite3_value, converters []callbackArgConverter, variadic callbackArgConverter) ([]reflect.Value, error) {\n\tvar args []reflect.Value\n\n\tif len(argv) < len(converters) {\n\t\treturn nil, fmt.Errorf(\"function requires at least %d arguments\", len(converters))\n\t}\n\n\tfor i, arg := range argv[:len(converters)] {\n\t\tv, err := converters[i](arg)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\targs = append(args, v)\n\t}\n\n\tif variadic != nil {\n\t\tfor _, arg := range argv[len(converters):] {\n\t\t\tv, err := variadic(arg)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\targs = append(args, v)\n\t\t}\n\t}\n\treturn args, nil\n}\n\ntype callbackRetConverter func(*C.sqlite3_context, reflect.Value) error\n\nfunc callbackRetInteger(ctx *C.sqlite3_context, v reflect.Value) error {\n\tswitch v.Type().Kind() {\n\tcase reflect.Int64:\n\tcase reflect.Int8, reflect.Int16, reflect.Int32, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Int, reflect.Uint:\n\t\tv = v.Convert(reflect.TypeOf(int64(0)))\n\tcase reflect.Bool:\n\t\tb := v.Interface().(bool)\n\t\tif b {\n\t\t\tv = reflect.ValueOf(int64(1))\n\t\t} else {\n\t\t\tv = reflect.ValueOf(int64(0))\n\t\t}\n\tdefault:\n\t\treturn fmt.Errorf(\"cannot convert %s to INTEGER\", v.Type())\n\t}\n\n\tC.sqlite3_result_int64(ctx, C.sqlite3_int64(v.Interface().(int64)))\n\treturn nil\n}\n\nfunc callbackRetFloat(ctx *C.sqlite3_context, v reflect.Value) error {\n\tswitch v.Type().Kind() {\n\tcase reflect.Float64:\n\tcase reflect.Float32:\n\t\tv = v.Convert(reflect.TypeOf(float64(0)))\n\tdefault:\n\t\treturn fmt.Errorf(\"cannot convert %s to FLOAT\", v.Type())\n\t}\n\n\tC.sqlite3_result_double(ctx, C.double(v.Interface().(float64)))\n\treturn nil\n}\n\nfunc callbackRetBlob(ctx *C.sqlite3_context, v reflect.Value) error {\n\tif v.Type().Kind() != reflect.Slice || v.Type().Elem().Kind() != reflect.Uint8 {\n\t\treturn fmt.Errorf(\"cannot convert %s to BLOB\", v.Type())\n\t}\n\ti := v.Interface()\n\tif i == nil || len(i.([]byte)) == 0 {\n\t\tC.sqlite3_result_null(ctx)\n\t} else {\n\t\tbs := i.([]byte)\n\t\tC._sqlite3_result_blob(ctx, unsafe.Pointer(&bs[0]), C.int(len(bs)))\n\t}\n\treturn nil\n}\n\nfunc callbackRetText(ctx *C.sqlite3_context, v reflect.Value) error {\n\tif v.Type().Kind() != reflect.String {\n\t\treturn fmt.Errorf(\"cannot convert %s to TEXT\", v.Type())\n\t}\n\tC._sqlite3_result_text(ctx, C.CString(v.Interface().(string)))\n\treturn nil\n}\n\nfunc callbackRetNil(ctx *C.sqlite3_context, v reflect.Value) error {\n\treturn nil\n}\n\nfunc callbackRetGeneric(ctx *C.sqlite3_context, v reflect.Value) error {\n\tif v.IsNil() {\n\t\tC.sqlite3_result_null(ctx)\n\t\treturn nil\n\t}\n\n\tcb, err := callbackRet(v.Elem().Type())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn cb(ctx, v.Elem())\n}\n\nfunc callbackRet(typ reflect.Type) (callbackRetConverter, error) {\n\tswitch typ.Kind() {\n\tcase reflect.Interface:\n\t\terrorInterface := reflect.TypeOf((*error)(nil)).Elem()\n\t\tif typ.Implements(errorInterface) {\n\t\t\treturn callbackRetNil, nil\n\t\t}\n\n\t\tif typ.NumMethod() == 0 {\n\t\t\treturn callbackRetGeneric, nil\n\t\t}\n\n\t\tfallthrough\n\tcase reflect.Slice:\n\t\tif typ.Elem().Kind() != reflect.Uint8 {\n\t\t\treturn nil, errors.New(\"the only supported slice type is []byte\")\n\t\t}\n\t\treturn callbackRetBlob, nil\n\tcase reflect.String:\n\t\treturn callbackRetText, nil\n\tcase reflect.Bool, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Int, reflect.Uint:\n\t\treturn callbackRetInteger, nil\n\tcase reflect.Float32, reflect.Float64:\n\t\treturn callbackRetFloat, nil\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"don't know how to convert to %s\", typ)\n\t}\n}\n\nfunc callbackError(ctx *C.sqlite3_context, err error) {\n\tcstr := C.CString(err.Error())\n\tdefer C.free(unsafe.Pointer(cstr))\n\tC.sqlite3_result_error(ctx, cstr, C.int(-1))\n}\n\n// Test support code. Tests are not allowed to import \"C\", so we can't\n// declare any functions that use C.sqlite3_value.\nfunc callbackSyntheticForTests(v reflect.Value, err error) callbackArgConverter {\n\treturn func(*C.sqlite3_value) (reflect.Value, error) {\n\t\treturn v, err\n\t}\n}\n"
        },
        {
          "name": "callback_test.go",
          "type": "blob",
          "size": 3.2412109375,
          "content": "// Copyright (C) 2019 Yasuhiro Matsumoto <mattn.jp@gmail.com>.\n//\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n//go:build cgo\n// +build cgo\n\npackage sqlite3\n\nimport (\n\t\"errors\"\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestCallbackArgCast(t *testing.T) {\n\tintConv := callbackSyntheticForTests(reflect.ValueOf(int64(math.MaxInt64)), nil)\n\tfloatConv := callbackSyntheticForTests(reflect.ValueOf(float64(math.MaxFloat64)), nil)\n\terrConv := callbackSyntheticForTests(reflect.Value{}, errors.New(\"test\"))\n\n\ttests := []struct {\n\t\tf callbackArgConverter\n\t\to reflect.Value\n\t}{\n\t\t{intConv, reflect.ValueOf(int8(-1))},\n\t\t{intConv, reflect.ValueOf(int16(-1))},\n\t\t{intConv, reflect.ValueOf(int32(-1))},\n\t\t{intConv, reflect.ValueOf(uint8(math.MaxUint8))},\n\t\t{intConv, reflect.ValueOf(uint16(math.MaxUint16))},\n\t\t{intConv, reflect.ValueOf(uint32(math.MaxUint32))},\n\t\t// Special case, int64->uint64 is only 1<<63 - 1, not 1<<64 - 1\n\t\t{intConv, reflect.ValueOf(uint64(math.MaxInt64))},\n\t\t{floatConv, reflect.ValueOf(float32(math.Inf(1)))},\n\t}\n\n\tfor _, test := range tests {\n\t\tconv := callbackArgCast{test.f, test.o.Type()}\n\t\tval, err := conv.Run(nil)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Couldn't convert to %s: %s\", test.o.Type(), err)\n\t\t} else if !reflect.DeepEqual(val.Interface(), test.o.Interface()) {\n\t\t\tt.Errorf(\"Unexpected result from converting to %s: got %v, want %v\", test.o.Type(), val.Interface(), test.o.Interface())\n\t\t}\n\t}\n\n\tconv := callbackArgCast{errConv, reflect.TypeOf(int8(0))}\n\t_, err := conv.Run(nil)\n\tif err == nil {\n\t\tt.Errorf(\"Expected error during callbackArgCast, but got none\")\n\t}\n}\n\nfunc TestCallbackConverters(t *testing.T) {\n\ttests := []struct {\n\t\tv   any\n\t\terr bool\n\t}{\n\t\t// Unfortunately, we can't tell which converter was returned,\n\t\t// but we can at least check which types can be converted.\n\t\t{[]byte{0}, false},\n\t\t{\"text\", false},\n\t\t{true, false},\n\t\t{int8(0), false},\n\t\t{int16(0), false},\n\t\t{int32(0), false},\n\t\t{int64(0), false},\n\t\t{uint8(0), false},\n\t\t{uint16(0), false},\n\t\t{uint32(0), false},\n\t\t{uint64(0), false},\n\t\t{int(0), false},\n\t\t{uint(0), false},\n\t\t{float64(0), false},\n\t\t{float32(0), false},\n\n\t\t{func() {}, true},\n\t\t{complex64(complex(0, 0)), true},\n\t\t{complex128(complex(0, 0)), true},\n\t\t{struct{}{}, true},\n\t\t{map[string]string{}, true},\n\t\t{[]string{}, true},\n\t\t{(*int8)(nil), true},\n\t\t{make(chan int), true},\n\t}\n\n\tfor _, test := range tests {\n\t\t_, err := callbackArg(reflect.TypeOf(test.v))\n\t\tif test.err && err == nil {\n\t\t\tt.Errorf(\"Expected an error when converting %s, got no error\", reflect.TypeOf(test.v))\n\t\t} else if !test.err && err != nil {\n\t\t\tt.Errorf(\"Expected converter when converting %s, got error: %s\", reflect.TypeOf(test.v), err)\n\t\t}\n\t}\n\n\tfor _, test := range tests {\n\t\t_, err := callbackRet(reflect.TypeOf(test.v))\n\t\tif test.err && err == nil {\n\t\t\tt.Errorf(\"Expected an error when converting %s, got no error\", reflect.TypeOf(test.v))\n\t\t} else if !test.err && err != nil {\n\t\t\tt.Errorf(\"Expected converter when converting %s, got error: %s\", reflect.TypeOf(test.v), err)\n\t\t}\n\t}\n}\n\nfunc TestCallbackReturnAny(t *testing.T) {\n\tudf := func() any {\n\t\treturn 1\n\t}\n\n\ttyp := reflect.TypeOf(udf)\n\t_, err := callbackRet(typ.Out(0))\n\tif err != nil {\n\t\tt.Errorf(\"Expected valid callback for any return type, got: %s\", err)\n\t}\n}\n"
        },
        {
          "name": "convert.go",
          "type": "blob",
          "size": 6.6552734375,
          "content": "// Extracted from Go database/sql source code\n\n// Copyright 2011 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// Type conversions for Scan.\n\npackage sqlite3\n\nimport (\n\t\"database/sql\"\n\t\"database/sql/driver\"\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"time\"\n)\n\nvar errNilPtr = errors.New(\"destination pointer is nil\") // embedded in descriptive error\n\n// convertAssign copies to dest the value in src, converting it if possible.\n// An error is returned if the copy would result in loss of information.\n// dest should be a pointer type.\nfunc convertAssign(dest, src any) error {\n\t// Common cases, without reflect.\n\tswitch s := src.(type) {\n\tcase string:\n\t\tswitch d := dest.(type) {\n\t\tcase *string:\n\t\t\tif d == nil {\n\t\t\t\treturn errNilPtr\n\t\t\t}\n\t\t\t*d = s\n\t\t\treturn nil\n\t\tcase *[]byte:\n\t\t\tif d == nil {\n\t\t\t\treturn errNilPtr\n\t\t\t}\n\t\t\t*d = []byte(s)\n\t\t\treturn nil\n\t\tcase *sql.RawBytes:\n\t\t\tif d == nil {\n\t\t\t\treturn errNilPtr\n\t\t\t}\n\t\t\t*d = append((*d)[:0], s...)\n\t\t\treturn nil\n\t\t}\n\tcase []byte:\n\t\tswitch d := dest.(type) {\n\t\tcase *string:\n\t\t\tif d == nil {\n\t\t\t\treturn errNilPtr\n\t\t\t}\n\t\t\t*d = string(s)\n\t\t\treturn nil\n\t\tcase *any:\n\t\t\tif d == nil {\n\t\t\t\treturn errNilPtr\n\t\t\t}\n\t\t\t*d = cloneBytes(s)\n\t\t\treturn nil\n\t\tcase *[]byte:\n\t\t\tif d == nil {\n\t\t\t\treturn errNilPtr\n\t\t\t}\n\t\t\t*d = cloneBytes(s)\n\t\t\treturn nil\n\t\tcase *sql.RawBytes:\n\t\t\tif d == nil {\n\t\t\t\treturn errNilPtr\n\t\t\t}\n\t\t\t*d = s\n\t\t\treturn nil\n\t\t}\n\tcase time.Time:\n\t\tswitch d := dest.(type) {\n\t\tcase *time.Time:\n\t\t\t*d = s\n\t\t\treturn nil\n\t\tcase *string:\n\t\t\t*d = s.Format(time.RFC3339Nano)\n\t\t\treturn nil\n\t\tcase *[]byte:\n\t\t\tif d == nil {\n\t\t\t\treturn errNilPtr\n\t\t\t}\n\t\t\t*d = []byte(s.Format(time.RFC3339Nano))\n\t\t\treturn nil\n\t\tcase *sql.RawBytes:\n\t\t\tif d == nil {\n\t\t\t\treturn errNilPtr\n\t\t\t}\n\t\t\t*d = s.AppendFormat((*d)[:0], time.RFC3339Nano)\n\t\t\treturn nil\n\t\t}\n\tcase nil:\n\t\tswitch d := dest.(type) {\n\t\tcase *any:\n\t\t\tif d == nil {\n\t\t\t\treturn errNilPtr\n\t\t\t}\n\t\t\t*d = nil\n\t\t\treturn nil\n\t\tcase *[]byte:\n\t\t\tif d == nil {\n\t\t\t\treturn errNilPtr\n\t\t\t}\n\t\t\t*d = nil\n\t\t\treturn nil\n\t\tcase *sql.RawBytes:\n\t\t\tif d == nil {\n\t\t\t\treturn errNilPtr\n\t\t\t}\n\t\t\t*d = nil\n\t\t\treturn nil\n\t\t}\n\t}\n\n\tvar sv reflect.Value\n\n\tswitch d := dest.(type) {\n\tcase *string:\n\t\tsv = reflect.ValueOf(src)\n\t\tswitch sv.Kind() {\n\t\tcase reflect.Bool,\n\t\t\treflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,\n\t\t\treflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64,\n\t\t\treflect.Float32, reflect.Float64:\n\t\t\t*d = asString(src)\n\t\t\treturn nil\n\t\t}\n\tcase *[]byte:\n\t\tsv = reflect.ValueOf(src)\n\t\tif b, ok := asBytes(nil, sv); ok {\n\t\t\t*d = b\n\t\t\treturn nil\n\t\t}\n\tcase *sql.RawBytes:\n\t\tsv = reflect.ValueOf(src)\n\t\tif b, ok := asBytes([]byte(*d)[:0], sv); ok {\n\t\t\t*d = sql.RawBytes(b)\n\t\t\treturn nil\n\t\t}\n\tcase *bool:\n\t\tbv, err := driver.Bool.ConvertValue(src)\n\t\tif err == nil {\n\t\t\t*d = bv.(bool)\n\t\t}\n\t\treturn err\n\tcase *any:\n\t\t*d = src\n\t\treturn nil\n\t}\n\n\tif scanner, ok := dest.(sql.Scanner); ok {\n\t\treturn scanner.Scan(src)\n\t}\n\n\tdpv := reflect.ValueOf(dest)\n\tif dpv.Kind() != reflect.Ptr {\n\t\treturn errors.New(\"destination not a pointer\")\n\t}\n\tif dpv.IsNil() {\n\t\treturn errNilPtr\n\t}\n\n\tif !sv.IsValid() {\n\t\tsv = reflect.ValueOf(src)\n\t}\n\n\tdv := reflect.Indirect(dpv)\n\tif sv.IsValid() && sv.Type().AssignableTo(dv.Type()) {\n\t\tswitch b := src.(type) {\n\t\tcase []byte:\n\t\t\tdv.Set(reflect.ValueOf(cloneBytes(b)))\n\t\tdefault:\n\t\t\tdv.Set(sv)\n\t\t}\n\t\treturn nil\n\t}\n\n\tif dv.Kind() == sv.Kind() && sv.Type().ConvertibleTo(dv.Type()) {\n\t\tdv.Set(sv.Convert(dv.Type()))\n\t\treturn nil\n\t}\n\n\t// The following conversions use a string value as an intermediate representation\n\t// to convert between various numeric types.\n\t//\n\t// This also allows scanning into user defined types such as \"type Int int64\".\n\t// For symmetry, also check for string destination types.\n\tswitch dv.Kind() {\n\tcase reflect.Ptr:\n\t\tif src == nil {\n\t\t\tdv.Set(reflect.Zero(dv.Type()))\n\t\t\treturn nil\n\t\t}\n\t\tdv.Set(reflect.New(dv.Type().Elem()))\n\t\treturn convertAssign(dv.Interface(), src)\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\ts := asString(src)\n\t\ti64, err := strconv.ParseInt(s, 10, dv.Type().Bits())\n\t\tif err != nil {\n\t\t\terr = strconvErr(err)\n\t\t\treturn fmt.Errorf(\"converting driver.Value type %T (%q) to a %s: %v\", src, s, dv.Kind(), err)\n\t\t}\n\t\tdv.SetInt(i64)\n\t\treturn nil\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:\n\t\ts := asString(src)\n\t\tu64, err := strconv.ParseUint(s, 10, dv.Type().Bits())\n\t\tif err != nil {\n\t\t\terr = strconvErr(err)\n\t\t\treturn fmt.Errorf(\"converting driver.Value type %T (%q) to a %s: %v\", src, s, dv.Kind(), err)\n\t\t}\n\t\tdv.SetUint(u64)\n\t\treturn nil\n\tcase reflect.Float32, reflect.Float64:\n\t\ts := asString(src)\n\t\tf64, err := strconv.ParseFloat(s, dv.Type().Bits())\n\t\tif err != nil {\n\t\t\terr = strconvErr(err)\n\t\t\treturn fmt.Errorf(\"converting driver.Value type %T (%q) to a %s: %v\", src, s, dv.Kind(), err)\n\t\t}\n\t\tdv.SetFloat(f64)\n\t\treturn nil\n\tcase reflect.String:\n\t\tswitch v := src.(type) {\n\t\tcase string:\n\t\t\tdv.SetString(v)\n\t\t\treturn nil\n\t\tcase []byte:\n\t\t\tdv.SetString(string(v))\n\t\t\treturn nil\n\t\t}\n\t}\n\n\treturn fmt.Errorf(\"unsupported Scan, storing driver.Value type %T into type %T\", src, dest)\n}\n\nfunc strconvErr(err error) error {\n\tif ne, ok := err.(*strconv.NumError); ok {\n\t\treturn ne.Err\n\t}\n\treturn err\n}\n\nfunc cloneBytes(b []byte) []byte {\n\tif b == nil {\n\t\treturn nil\n\t}\n\tc := make([]byte, len(b))\n\tcopy(c, b)\n\treturn c\n}\n\nfunc asString(src any) string {\n\tswitch v := src.(type) {\n\tcase string:\n\t\treturn v\n\tcase []byte:\n\t\treturn string(v)\n\t}\n\trv := reflect.ValueOf(src)\n\tswitch rv.Kind() {\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\treturn strconv.FormatInt(rv.Int(), 10)\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:\n\t\treturn strconv.FormatUint(rv.Uint(), 10)\n\tcase reflect.Float64:\n\t\treturn strconv.FormatFloat(rv.Float(), 'g', -1, 64)\n\tcase reflect.Float32:\n\t\treturn strconv.FormatFloat(rv.Float(), 'g', -1, 32)\n\tcase reflect.Bool:\n\t\treturn strconv.FormatBool(rv.Bool())\n\t}\n\treturn fmt.Sprintf(\"%v\", src)\n}\n\nfunc asBytes(buf []byte, rv reflect.Value) (b []byte, ok bool) {\n\tswitch rv.Kind() {\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\treturn strconv.AppendInt(buf, rv.Int(), 10), true\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:\n\t\treturn strconv.AppendUint(buf, rv.Uint(), 10), true\n\tcase reflect.Float32:\n\t\treturn strconv.AppendFloat(buf, rv.Float(), 'g', -1, 32), true\n\tcase reflect.Float64:\n\t\treturn strconv.AppendFloat(buf, rv.Float(), 'g', -1, 64), true\n\tcase reflect.Bool:\n\t\treturn strconv.AppendBool(buf, rv.Bool()), true\n\tcase reflect.String:\n\t\ts := rv.String()\n\t\treturn append(buf, s...), true\n\t}\n\treturn\n}\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 3.466796875,
          "content": "/*\nPackage sqlite3 provides interface to SQLite3 databases.\n\nThis works as a driver for database/sql.\n\nInstallation\n\n\tgo get github.com/mattn/go-sqlite3\n\n# Supported Types\n\nCurrently, go-sqlite3 supports the following data types.\n\n\t+------------------------------+\n\t|go        | sqlite3           |\n\t|----------|-------------------|\n\t|nil       | null              |\n\t|int       | integer           |\n\t|int64     | integer           |\n\t|float64   | float             |\n\t|bool      | integer           |\n\t|[]byte    | blob              |\n\t|string    | text              |\n\t|time.Time | timestamp/datetime|\n\t+------------------------------+\n\n# SQLite3 Extension\n\nYou can write your own extension module for sqlite3. For example, below is an\nextension for a Regexp matcher operation.\n\n\t#include <pcre.h>\n\t#include <string.h>\n\t#include <stdio.h>\n\t#include <sqlite3ext.h>\n\n\tSQLITE_EXTENSION_INIT1\n\tstatic void regexp_func(sqlite3_context *context, int argc, sqlite3_value **argv) {\n\t  if (argc >= 2) {\n\t    const char *target  = (const char *)sqlite3_value_text(argv[1]);\n\t    const char *pattern = (const char *)sqlite3_value_text(argv[0]);\n\t    const char* errstr = NULL;\n\t    int erroff = 0;\n\t    int vec[500];\n\t    int n, rc;\n\t    pcre* re = pcre_compile(pattern, 0, &errstr, &erroff, NULL);\n\t    rc = pcre_exec(re, NULL, target, strlen(target), 0, 0, vec, 500);\n\t    if (rc <= 0) {\n\t      sqlite3_result_error(context, errstr, 0);\n\t      return;\n\t    }\n\t    sqlite3_result_int(context, 1);\n\t  }\n\t}\n\n\t#ifdef _WIN32\n\t__declspec(dllexport)\n\t#endif\n\tint sqlite3_extension_init(sqlite3 *db, char **errmsg,\n\t      const sqlite3_api_routines *api) {\n\t  SQLITE_EXTENSION_INIT2(api);\n\t  return sqlite3_create_function(db, \"regexp\", 2, SQLITE_UTF8,\n\t      (void*)db, regexp_func, NULL, NULL);\n\t}\n\nIt needs to be built as a so/dll shared library. And you need to register\nthe extension module like below.\n\n\tsql.Register(\"sqlite3_with_extensions\",\n\t\t&sqlite3.SQLiteDriver{\n\t\t\tExtensions: []string{\n\t\t\t\t\"sqlite3_mod_regexp\",\n\t\t\t},\n\t\t})\n\nThen, you can use this extension.\n\n\trows, err := db.Query(\"select text from mytable where name regexp '^golang'\")\n\n# Connection Hook\n\nYou can hook and inject your code when the connection is established by setting\nConnectHook to get the SQLiteConn.\n\n\tsql.Register(\"sqlite3_with_hook_example\",\n\t\t\t&sqlite3.SQLiteDriver{\n\t\t\t\t\tConnectHook: func(conn *sqlite3.SQLiteConn) error {\n\t\t\t\t\t\tsqlite3conn = append(sqlite3conn, conn)\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t},\n\t\t\t})\n\nYou can also use database/sql.Conn.Raw (Go >= 1.13):\n\n\tconn, err := db.Conn(context.Background())\n\t// if err != nil { ... }\n\tdefer conn.Close()\n\terr = conn.Raw(func (driverConn any) error {\n\t\tsqliteConn := driverConn.(*sqlite3.SQLiteConn)\n\t\t// ... use sqliteConn\n\t})\n\t// if err != nil { ... }\n\n# Go SQlite3 Extensions\n\nIf you want to register Go functions as SQLite extension functions\nyou can make a custom driver by calling RegisterFunction from\nConnectHook.\n\n\tregex = func(re, s string) (bool, error) {\n\t\treturn regexp.MatchString(re, s)\n\t}\n\tsql.Register(\"sqlite3_extended\",\n\t\t\t&sqlite3.SQLiteDriver{\n\t\t\t\t\tConnectHook: func(conn *sqlite3.SQLiteConn) error {\n\t\t\t\t\t\treturn conn.RegisterFunc(\"regexp\", regex, true)\n\t\t\t\t\t},\n\t\t\t})\n\nYou can then use the custom driver by passing its name to sql.Open.\n\n\tvar i int\n\tconn, err := sql.Open(\"sqlite3_extended\", \"./foo.db\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\terr = db.QueryRow(`SELECT regexp(\"foo.*\", \"seafood\")`).Scan(&i)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\nSee the documentation of RegisterFunc for more details.\n*/\npackage sqlite3\n"
        },
        {
          "name": "error.go",
          "type": "blob",
          "size": 5.9736328125,
          "content": "// Copyright (C) 2019 Yasuhiro Matsumoto <mattn.jp@gmail.com>.\n//\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\npackage sqlite3\n\n/*\n#ifndef USE_LIBSQLITE3\n#include \"sqlite3-binding.h\"\n#else\n#include <sqlite3.h>\n#endif\n*/\nimport \"C\"\nimport \"syscall\"\n\n// ErrNo inherit errno.\ntype ErrNo int\n\n// ErrNoMask is mask code.\nconst ErrNoMask C.int = 0xff\n\n// ErrNoExtended is extended errno.\ntype ErrNoExtended int\n\n// Error implement sqlite error code.\ntype Error struct {\n\tCode         ErrNo         /* The error code returned by SQLite */\n\tExtendedCode ErrNoExtended /* The extended error code returned by SQLite */\n\tSystemErrno  syscall.Errno /* The system errno returned by the OS through SQLite, if applicable */\n\terr          string        /* The error string returned by sqlite3_errmsg(),\n\tthis usually contains more specific details. */\n}\n\n// result codes from http://www.sqlite.org/c3ref/c_abort.html\nvar (\n\tErrError      = ErrNo(1)  /* SQL error or missing database */\n\tErrInternal   = ErrNo(2)  /* Internal logic error in SQLite */\n\tErrPerm       = ErrNo(3)  /* Access permission denied */\n\tErrAbort      = ErrNo(4)  /* Callback routine requested an abort */\n\tErrBusy       = ErrNo(5)  /* The database file is locked */\n\tErrLocked     = ErrNo(6)  /* A table in the database is locked */\n\tErrNomem      = ErrNo(7)  /* A malloc() failed */\n\tErrReadonly   = ErrNo(8)  /* Attempt to write a readonly database */\n\tErrInterrupt  = ErrNo(9)  /* Operation terminated by sqlite3_interrupt() */\n\tErrIoErr      = ErrNo(10) /* Some kind of disk I/O error occurred */\n\tErrCorrupt    = ErrNo(11) /* The database disk image is malformed */\n\tErrNotFound   = ErrNo(12) /* Unknown opcode in sqlite3_file_control() */\n\tErrFull       = ErrNo(13) /* Insertion failed because database is full */\n\tErrCantOpen   = ErrNo(14) /* Unable to open the database file */\n\tErrProtocol   = ErrNo(15) /* Database lock protocol error */\n\tErrEmpty      = ErrNo(16) /* Database is empty */\n\tErrSchema     = ErrNo(17) /* The database schema changed */\n\tErrTooBig     = ErrNo(18) /* String or BLOB exceeds size limit */\n\tErrConstraint = ErrNo(19) /* Abort due to constraint violation */\n\tErrMismatch   = ErrNo(20) /* Data type mismatch */\n\tErrMisuse     = ErrNo(21) /* Library used incorrectly */\n\tErrNoLFS      = ErrNo(22) /* Uses OS features not supported on host */\n\tErrAuth       = ErrNo(23) /* Authorization denied */\n\tErrFormat     = ErrNo(24) /* Auxiliary database format error */\n\tErrRange      = ErrNo(25) /* 2nd parameter to sqlite3_bind out of range */\n\tErrNotADB     = ErrNo(26) /* File opened that is not a database file */\n\tErrNotice     = ErrNo(27) /* Notifications from sqlite3_log() */\n\tErrWarning    = ErrNo(28) /* Warnings from sqlite3_log() */\n)\n\n// Error return error message from errno.\nfunc (err ErrNo) Error() string {\n\treturn Error{Code: err}.Error()\n}\n\n// Extend return extended errno.\nfunc (err ErrNo) Extend(by int) ErrNoExtended {\n\treturn ErrNoExtended(int(err) | (by << 8))\n}\n\n// Error return error message that is extended code.\nfunc (err ErrNoExtended) Error() string {\n\treturn Error{Code: ErrNo(C.int(err) & ErrNoMask), ExtendedCode: err}.Error()\n}\n\nfunc (err Error) Error() string {\n\tvar str string\n\tif err.err != \"\" {\n\t\tstr = err.err\n\t} else {\n\t\tstr = C.GoString(C.sqlite3_errstr(C.int(err.Code)))\n\t}\n\tif err.SystemErrno != 0 {\n\t\tstr += \": \" + err.SystemErrno.Error()\n\t}\n\treturn str\n}\n\n// result codes from http://www.sqlite.org/c3ref/c_abort_rollback.html\nvar (\n\tErrIoErrRead              = ErrIoErr.Extend(1)\n\tErrIoErrShortRead         = ErrIoErr.Extend(2)\n\tErrIoErrWrite             = ErrIoErr.Extend(3)\n\tErrIoErrFsync             = ErrIoErr.Extend(4)\n\tErrIoErrDirFsync          = ErrIoErr.Extend(5)\n\tErrIoErrTruncate          = ErrIoErr.Extend(6)\n\tErrIoErrFstat             = ErrIoErr.Extend(7)\n\tErrIoErrUnlock            = ErrIoErr.Extend(8)\n\tErrIoErrRDlock            = ErrIoErr.Extend(9)\n\tErrIoErrDelete            = ErrIoErr.Extend(10)\n\tErrIoErrBlocked           = ErrIoErr.Extend(11)\n\tErrIoErrNoMem             = ErrIoErr.Extend(12)\n\tErrIoErrAccess            = ErrIoErr.Extend(13)\n\tErrIoErrCheckReservedLock = ErrIoErr.Extend(14)\n\tErrIoErrLock              = ErrIoErr.Extend(15)\n\tErrIoErrClose             = ErrIoErr.Extend(16)\n\tErrIoErrDirClose          = ErrIoErr.Extend(17)\n\tErrIoErrSHMOpen           = ErrIoErr.Extend(18)\n\tErrIoErrSHMSize           = ErrIoErr.Extend(19)\n\tErrIoErrSHMLock           = ErrIoErr.Extend(20)\n\tErrIoErrSHMMap            = ErrIoErr.Extend(21)\n\tErrIoErrSeek              = ErrIoErr.Extend(22)\n\tErrIoErrDeleteNoent       = ErrIoErr.Extend(23)\n\tErrIoErrMMap              = ErrIoErr.Extend(24)\n\tErrIoErrGetTempPath       = ErrIoErr.Extend(25)\n\tErrIoErrConvPath          = ErrIoErr.Extend(26)\n\tErrLockedSharedCache      = ErrLocked.Extend(1)\n\tErrBusyRecovery           = ErrBusy.Extend(1)\n\tErrBusySnapshot           = ErrBusy.Extend(2)\n\tErrCantOpenNoTempDir      = ErrCantOpen.Extend(1)\n\tErrCantOpenIsDir          = ErrCantOpen.Extend(2)\n\tErrCantOpenFullPath       = ErrCantOpen.Extend(3)\n\tErrCantOpenConvPath       = ErrCantOpen.Extend(4)\n\tErrCorruptVTab            = ErrCorrupt.Extend(1)\n\tErrReadonlyRecovery       = ErrReadonly.Extend(1)\n\tErrReadonlyCantLock       = ErrReadonly.Extend(2)\n\tErrReadonlyRollback       = ErrReadonly.Extend(3)\n\tErrReadonlyDbMoved        = ErrReadonly.Extend(4)\n\tErrAbortRollback          = ErrAbort.Extend(2)\n\tErrConstraintCheck        = ErrConstraint.Extend(1)\n\tErrConstraintCommitHook   = ErrConstraint.Extend(2)\n\tErrConstraintForeignKey   = ErrConstraint.Extend(3)\n\tErrConstraintFunction     = ErrConstraint.Extend(4)\n\tErrConstraintNotNull      = ErrConstraint.Extend(5)\n\tErrConstraintPrimaryKey   = ErrConstraint.Extend(6)\n\tErrConstraintTrigger      = ErrConstraint.Extend(7)\n\tErrConstraintUnique       = ErrConstraint.Extend(8)\n\tErrConstraintVTab         = ErrConstraint.Extend(9)\n\tErrConstraintRowID        = ErrConstraint.Extend(10)\n\tErrNoticeRecoverWAL       = ErrNotice.Extend(1)\n\tErrNoticeRecoverRollback  = ErrNotice.Extend(2)\n\tErrWarningAutoIndex       = ErrWarning.Extend(1)\n)\n"
        },
        {
          "name": "error_test.go",
          "type": "blob",
          "size": 6.150390625,
          "content": "// Copyright (C) 2019 Yasuhiro Matsumoto <mattn.jp@gmail.com>.\n//\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n//go:build cgo\n// +build cgo\n\npackage sqlite3\n\nimport (\n\t\"database/sql\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path\"\n\t\"testing\"\n)\n\nfunc TestSimpleError(t *testing.T) {\n\te := ErrError.Error()\n\tif e != \"SQL logic error or missing database\" && e != \"SQL logic error\" {\n\t\tt.Error(\"wrong error code: \" + e)\n\t}\n}\n\nfunc TestCorruptDbErrors(t *testing.T) {\n\tdirName, err := ioutil.TempDir(\"\", \"sqlite3\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.RemoveAll(dirName)\n\n\tdbFileName := path.Join(dirName, \"test.db\")\n\tf, err := os.Create(dbFileName)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tf.Write([]byte{1, 2, 3, 4, 5})\n\tf.Close()\n\n\tdb, err := sql.Open(\"sqlite3\", dbFileName)\n\tif err == nil {\n\t\t_, err = db.Exec(\"drop table foo\")\n\t}\n\n\tsqliteErr := err.(Error)\n\tif sqliteErr.Code != ErrNotADB {\n\t\tt.Error(\"wrong error code for corrupted DB\")\n\t}\n\tif err.Error() == \"\" {\n\t\tt.Error(\"wrong error string for corrupted DB\")\n\t}\n\tdb.Close()\n}\n\nfunc TestSqlLogicErrors(t *testing.T) {\n\tdirName, err := ioutil.TempDir(\"\", \"sqlite3\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.RemoveAll(dirName)\n\n\tdbFileName := path.Join(dirName, \"test.db\")\n\tdb, err := sql.Open(\"sqlite3\", dbFileName)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tdefer db.Close()\n\n\t_, err = db.Exec(\"CREATE TABLE Foo (id INTEGER PRIMARY KEY)\")\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tconst expectedErr = \"table Foo already exists\"\n\t_, err = db.Exec(\"CREATE TABLE Foo (id INTEGER PRIMARY KEY)\")\n\tif err.Error() != expectedErr {\n\t\tt.Errorf(\"Unexpected error: %s, expected %s\", err.Error(), expectedErr)\n\t}\n\n}\n\nfunc TestExtendedErrorCodes_ForeignKey(t *testing.T) {\n\tdirName, err := ioutil.TempDir(\"\", \"sqlite3-err\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.RemoveAll(dirName)\n\n\tdbFileName := path.Join(dirName, \"test.db\")\n\tdb, err := sql.Open(\"sqlite3\", dbFileName)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tdefer db.Close()\n\n\t_, err = db.Exec(\"PRAGMA foreign_keys=ON;\")\n\tif err != nil {\n\t\tt.Errorf(\"PRAGMA foreign_keys=ON: %v\", err)\n\t}\n\n\t_, err = db.Exec(`CREATE TABLE Foo (\n\t\tid INTEGER PRIMARY KEY AUTOINCREMENT,\n\t\tvalue INTEGER NOT NULL,\n\t\tref INTEGER NULL REFERENCES Foo (id),\n\t\tUNIQUE(value)\n\t);`)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\t_, err = db.Exec(\"INSERT INTO Foo (ref, value) VALUES (100, 100);\")\n\tif err == nil {\n\t\tt.Error(\"No error!\")\n\t} else {\n\t\tsqliteErr := err.(Error)\n\t\tif sqliteErr.Code != ErrConstraint {\n\t\t\tt.Errorf(\"Wrong basic error code: %d != %d\",\n\t\t\t\tsqliteErr.Code, ErrConstraint)\n\t\t}\n\t\tif sqliteErr.ExtendedCode != ErrConstraintForeignKey {\n\t\t\tt.Errorf(\"Wrong extended error code: %d != %d\",\n\t\t\t\tsqliteErr.ExtendedCode, ErrConstraintForeignKey)\n\t\t}\n\t}\n\n}\n\nfunc TestExtendedErrorCodes_NotNull(t *testing.T) {\n\tdirName, err := ioutil.TempDir(\"\", \"sqlite3-err\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.RemoveAll(dirName)\n\n\tdbFileName := path.Join(dirName, \"test.db\")\n\tdb, err := sql.Open(\"sqlite3\", dbFileName)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tdefer db.Close()\n\n\t_, err = db.Exec(\"PRAGMA foreign_keys=ON;\")\n\tif err != nil {\n\t\tt.Errorf(\"PRAGMA foreign_keys=ON: %v\", err)\n\t}\n\n\t_, err = db.Exec(`CREATE TABLE Foo (\n\t\tid INTEGER PRIMARY KEY AUTOINCREMENT,\n\t\tvalue INTEGER NOT NULL,\n\t\tref INTEGER NULL REFERENCES Foo (id),\n\t\tUNIQUE(value)\n\t);`)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tres, err := db.Exec(\"INSERT INTO Foo (value) VALUES (100);\")\n\tif err != nil {\n\t\tt.Fatalf(\"Creating first row: %v\", err)\n\t}\n\n\tid, err := res.LastInsertId()\n\tif err != nil {\n\t\tt.Fatalf(\"Retrieving last insert id: %v\", err)\n\t}\n\n\t_, err = db.Exec(\"INSERT INTO Foo (ref) VALUES (?);\", id)\n\tif err == nil {\n\t\tt.Error(\"No error!\")\n\t} else {\n\t\tsqliteErr := err.(Error)\n\t\tif sqliteErr.Code != ErrConstraint {\n\t\t\tt.Errorf(\"Wrong basic error code: %d != %d\",\n\t\t\t\tsqliteErr.Code, ErrConstraint)\n\t\t}\n\t\tif sqliteErr.ExtendedCode != ErrConstraintNotNull {\n\t\t\tt.Errorf(\"Wrong extended error code: %d != %d\",\n\t\t\t\tsqliteErr.ExtendedCode, ErrConstraintNotNull)\n\t\t}\n\t}\n\n}\n\nfunc TestExtendedErrorCodes_Unique(t *testing.T) {\n\tdirName, err := ioutil.TempDir(\"\", \"sqlite3-err\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.RemoveAll(dirName)\n\n\tdbFileName := path.Join(dirName, \"test.db\")\n\tdb, err := sql.Open(\"sqlite3\", dbFileName)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tdefer db.Close()\n\n\t_, err = db.Exec(\"PRAGMA foreign_keys=ON;\")\n\tif err != nil {\n\t\tt.Errorf(\"PRAGMA foreign_keys=ON: %v\", err)\n\t}\n\n\t_, err = db.Exec(`CREATE TABLE Foo (\n\t\tid INTEGER PRIMARY KEY AUTOINCREMENT,\n\t\tvalue INTEGER NOT NULL,\n\t\tref INTEGER NULL REFERENCES Foo (id),\n\t\tUNIQUE(value)\n\t);`)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tres, err := db.Exec(\"INSERT INTO Foo (value) VALUES (100);\")\n\tif err != nil {\n\t\tt.Fatalf(\"Creating first row: %v\", err)\n\t}\n\n\tid, err := res.LastInsertId()\n\tif err != nil {\n\t\tt.Fatalf(\"Retrieving last insert id: %v\", err)\n\t}\n\n\t_, err = db.Exec(\"INSERT INTO Foo (ref, value) VALUES (?, 100);\", id)\n\tif err == nil {\n\t\tt.Error(\"No error!\")\n\t} else {\n\t\tsqliteErr := err.(Error)\n\t\tif sqliteErr.Code != ErrConstraint {\n\t\t\tt.Errorf(\"Wrong basic error code: %d != %d\",\n\t\t\t\tsqliteErr.Code, ErrConstraint)\n\t\t}\n\t\tif sqliteErr.ExtendedCode != ErrConstraintUnique {\n\t\t\tt.Errorf(\"Wrong extended error code: %d != %d\",\n\t\t\t\tsqliteErr.ExtendedCode, ErrConstraintUnique)\n\t\t}\n\t\textended := sqliteErr.Code.Extend(3).Error()\n\t\texpected := \"constraint failed\"\n\t\tif extended != expected {\n\t\t\tt.Errorf(\"Wrong basic error code: %q != %q\",\n\t\t\t\textended, expected)\n\t\t}\n\t}\n}\n\nfunc TestError_SystemErrno(t *testing.T) {\n\t_, n, _ := Version()\n\tif n < 3012000 {\n\t\tt.Skip(\"sqlite3_system_errno requires sqlite3 >= 3.12.0\")\n\t}\n\n\t// open a non-existent database in read-only mode so we get an IO error.\n\tdb, err := sql.Open(\"sqlite3\", \"file:nonexistent.db?mode=ro\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\terr = db.Ping()\n\tif err == nil {\n\t\tt.Fatal(\"expected error pinging read-only non-existent database, but got nil\")\n\t}\n\n\tserr, ok := err.(Error)\n\tif !ok {\n\t\tt.Fatalf(\"expected error to be of type Error, but got %[1]T %[1]v\", err)\n\t}\n\n\tif serr.SystemErrno == 0 {\n\t\tt.Fatal(\"expected SystemErrno to be set\")\n\t}\n\n\tif !os.IsNotExist(serr.SystemErrno) {\n\t\tt.Errorf(\"expected SystemErrno to be a not exists error, but got %v\", serr.SystemErrno)\n\t}\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.142578125,
          "content": "module github.com/mattn/go-sqlite3\n\ngo 1.19\n\nretract (\n [v2.0.0+incompatible, v2.0.6+incompatible] // Accidental; no major changes or features.\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0,
          "content": ""
        },
        {
          "name": "sqlite3-binding.c",
          "type": "blob",
          "size": 8888.0263671875,
          "content": ""
        },
        {
          "name": "sqlite3-binding.h",
          "type": "blob",
          "size": 632.62890625,
          "content": "#ifndef USE_LIBSQLITE3\n/*\n** 2001-09-15\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This header file defines the interface that the SQLite library\n** presents to client programs.  If a C-function, structure, datatype,\n** or constant definition does not appear in this file, then it is\n** not a published API of SQLite, is subject to change without\n** notice, and should not be referenced by programs that use SQLite.\n**\n** Some of the definitions that are in this file are marked as\n** \"experimental\".  Experimental interfaces are normally new\n** features recently added to SQLite.  We do not anticipate changes\n** to experimental interfaces but reserve the right to make minor changes\n** if experience from use \"in the wild\" suggest such changes are prudent.\n**\n** The official C-language API documentation for SQLite is derived\n** from comments in this file.  This file is the authoritative source\n** on how SQLite interfaces are supposed to operate.\n**\n** The name of this file under configuration management is \"sqlite.h.in\".\n** The makefile makes some minor changes to this file (such as inserting\n** the version number) and changes its name to \"sqlite3.h\" as\n** part of the build process.\n*/\n#ifndef SQLITE3_H\n#define SQLITE3_H\n#include <stdarg.h>     /* Needed for the definition of va_list */\n\n/*\n** Make sure we can call this stuff from C++.\n*/\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/*\n** Facilitate override of interface linkage and calling conventions.\n** Be aware that these macros may not be used within this particular\n** translation of the amalgamation and its associated header file.\n**\n** The SQLITE_EXTERN and SQLITE_API macros are used to instruct the\n** compiler that the target identifier should have external linkage.\n**\n** The SQLITE_CDECL macro is used to set the calling convention for\n** public functions that accept a variable number of arguments.\n**\n** The SQLITE_APICALL macro is used to set the calling convention for\n** public functions that accept a fixed number of arguments.\n**\n** The SQLITE_STDCALL macro is no longer used and is now deprecated.\n**\n** The SQLITE_CALLBACK macro is used to set the calling convention for\n** function pointers.\n**\n** The SQLITE_SYSAPI macro is used to set the calling convention for\n** functions provided by the operating system.\n**\n** Currently, the SQLITE_CDECL, SQLITE_APICALL, SQLITE_CALLBACK, and\n** SQLITE_SYSAPI macros are used only when building for environments\n** that require non-default calling conventions.\n*/\n#ifndef SQLITE_EXTERN\n# define SQLITE_EXTERN extern\n#endif\n#ifndef SQLITE_API\n# define SQLITE_API\n#endif\n#ifndef SQLITE_CDECL\n# define SQLITE_CDECL\n#endif\n#ifndef SQLITE_APICALL\n# define SQLITE_APICALL\n#endif\n#ifndef SQLITE_STDCALL\n# define SQLITE_STDCALL SQLITE_APICALL\n#endif\n#ifndef SQLITE_CALLBACK\n# define SQLITE_CALLBACK\n#endif\n#ifndef SQLITE_SYSAPI\n# define SQLITE_SYSAPI\n#endif\n\n/*\n** These no-op macros are used in front of interfaces to mark those\n** interfaces as either deprecated or experimental.  New applications\n** should not use deprecated interfaces - they are supported for backwards\n** compatibility only.  Application writers should be aware that\n** experimental interfaces are subject to change in point releases.\n**\n** These macros used to resolve to various kinds of compiler magic that\n** would generate warning messages when they were used.  But that\n** compiler magic ended up generating such a flurry of bug reports\n** that we have taken it all out and gone back to using simple\n** noop macros.\n*/\n#define SQLITE_DEPRECATED\n#define SQLITE_EXPERIMENTAL\n\n/*\n** Ensure these symbols were not defined by some previous header file.\n*/\n#ifdef SQLITE_VERSION\n# undef SQLITE_VERSION\n#endif\n#ifdef SQLITE_VERSION_NUMBER\n# undef SQLITE_VERSION_NUMBER\n#endif\n\n/*\n** CAPI3REF: Compile-Time Library Version Numbers\n**\n** ^(The [SQLITE_VERSION] C preprocessor macro in the sqlite3.h header\n** evaluates to a string literal that is the SQLite version in the\n** format \"X.Y.Z\" where X is the major version number (always 3 for\n** SQLite3) and Y is the minor version number and Z is the release number.)^\n** ^(The [SQLITE_VERSION_NUMBER] C preprocessor macro resolves to an integer\n** with the value (X*1000000 + Y*1000 + Z) where X, Y, and Z are the same\n** numbers used in [SQLITE_VERSION].)^\n** The SQLITE_VERSION_NUMBER for any given release of SQLite will also\n** be larger than the release from which it is derived.  Either Y will\n** be held constant and Z will be incremented or else Y will be incremented\n** and Z will be reset to zero.\n**\n** Since [version 3.6.18] ([dateof:3.6.18]),\n** SQLite source code has been stored in the\n** <a href=\"http://www.fossil-scm.org/\">Fossil configuration management\n** system</a>.  ^The SQLITE_SOURCE_ID macro evaluates to\n** a string which identifies a particular check-in of SQLite\n** within its configuration management system.  ^The SQLITE_SOURCE_ID\n** string contains the date and time of the check-in (UTC) and a SHA1\n** or SHA3-256 hash of the entire source tree.  If the source code has\n** been edited in any way since it was last checked in, then the last\n** four hexadecimal digits of the hash may be modified.\n**\n** See also: [sqlite3_libversion()],\n** [sqlite3_libversion_number()], [sqlite3_sourceid()],\n** [sqlite_version()] and [sqlite_source_id()].\n*/\n#define SQLITE_VERSION        \"3.46.1\"\n#define SQLITE_VERSION_NUMBER 3046001\n#define SQLITE_SOURCE_ID      \"2024-08-13 09:16:08 c9c2ab54ba1f5f46360f1b4f35d849cd3f080e6fc2b6c60e91b16c63f69a1e33\"\n\n/*\n** CAPI3REF: Run-Time Library Version Numbers\n** KEYWORDS: sqlite3_version sqlite3_sourceid\n**\n** These interfaces provide the same information as the [SQLITE_VERSION],\n** [SQLITE_VERSION_NUMBER], and [SQLITE_SOURCE_ID] C preprocessor macros\n** but are associated with the library instead of the header file.  ^(Cautious\n** programmers might include assert() statements in their application to\n** verify that values returned by these interfaces match the macros in\n** the header, and thus ensure that the application is\n** compiled with matching library and header files.\n**\n** <blockquote><pre>\n** assert( sqlite3_libversion_number()==SQLITE_VERSION_NUMBER );\n** assert( strncmp(sqlite3_sourceid(),SQLITE_SOURCE_ID,80)==0 );\n** assert( strcmp(sqlite3_libversion(),SQLITE_VERSION)==0 );\n** </pre></blockquote>)^\n**\n** ^The sqlite3_version[] string constant contains the text of [SQLITE_VERSION]\n** macro.  ^The sqlite3_libversion() function returns a pointer to the\n** to the sqlite3_version[] string constant.  The sqlite3_libversion()\n** function is provided for use in DLLs since DLL users usually do not have\n** direct access to string constants within the DLL.  ^The\n** sqlite3_libversion_number() function returns an integer equal to\n** [SQLITE_VERSION_NUMBER].  ^(The sqlite3_sourceid() function returns\n** a pointer to a string constant whose value is the same as the\n** [SQLITE_SOURCE_ID] C preprocessor macro.  Except if SQLite is built\n** using an edited copy of [the amalgamation], then the last four characters\n** of the hash might be different from [SQLITE_SOURCE_ID].)^\n**\n** See also: [sqlite_version()] and [sqlite_source_id()].\n*/\nSQLITE_API SQLITE_EXTERN const char sqlite3_version[];\nSQLITE_API const char *sqlite3_libversion(void);\nSQLITE_API const char *sqlite3_sourceid(void);\nSQLITE_API int sqlite3_libversion_number(void);\n\n/*\n** CAPI3REF: Run-Time Library Compilation Options Diagnostics\n**\n** ^The sqlite3_compileoption_used() function returns 0 or 1\n** indicating whether the specified option was defined at\n** compile time.  ^The SQLITE_ prefix may be omitted from the\n** option name passed to sqlite3_compileoption_used().\n**\n** ^The sqlite3_compileoption_get() function allows iterating\n** over the list of options that were defined at compile time by\n** returning the N-th compile time option string.  ^If N is out of range,\n** sqlite3_compileoption_get() returns a NULL pointer.  ^The SQLITE_\n** prefix is omitted from any strings returned by\n** sqlite3_compileoption_get().\n**\n** ^Support for the diagnostic functions sqlite3_compileoption_used()\n** and sqlite3_compileoption_get() may be omitted by specifying the\n** [SQLITE_OMIT_COMPILEOPTION_DIAGS] option at compile time.\n**\n** See also: SQL functions [sqlite_compileoption_used()] and\n** [sqlite_compileoption_get()] and the [compile_options pragma].\n*/\n#ifndef SQLITE_OMIT_COMPILEOPTION_DIAGS\nSQLITE_API int sqlite3_compileoption_used(const char *zOptName);\nSQLITE_API const char *sqlite3_compileoption_get(int N);\n#else\n# define sqlite3_compileoption_used(X) 0\n# define sqlite3_compileoption_get(X)  ((void*)0)\n#endif\n\n/*\n** CAPI3REF: Test To See If The Library Is Threadsafe\n**\n** ^The sqlite3_threadsafe() function returns zero if and only if\n** SQLite was compiled with mutexing code omitted due to the\n** [SQLITE_THREADSAFE] compile-time option being set to 0.\n**\n** SQLite can be compiled with or without mutexes.  When\n** the [SQLITE_THREADSAFE] C preprocessor macro is 1 or 2, mutexes\n** are enabled and SQLite is threadsafe.  When the\n** [SQLITE_THREADSAFE] macro is 0,\n** the mutexes are omitted.  Without the mutexes, it is not safe\n** to use SQLite concurrently from more than one thread.\n**\n** Enabling mutexes incurs a measurable performance penalty.\n** So if speed is of utmost importance, it makes sense to disable\n** the mutexes.  But for maximum safety, mutexes should be enabled.\n** ^The default behavior is for mutexes to be enabled.\n**\n** This interface can be used by an application to make sure that the\n** version of SQLite that it is linking against was compiled with\n** the desired setting of the [SQLITE_THREADSAFE] macro.\n**\n** This interface only reports on the compile-time mutex setting\n** of the [SQLITE_THREADSAFE] flag.  If SQLite is compiled with\n** SQLITE_THREADSAFE=1 or =2 then mutexes are enabled by default but\n** can be fully or partially disabled using a call to [sqlite3_config()]\n** with the verbs [SQLITE_CONFIG_SINGLETHREAD], [SQLITE_CONFIG_MULTITHREAD],\n** or [SQLITE_CONFIG_SERIALIZED].  ^(The return value of the\n** sqlite3_threadsafe() function shows only the compile-time setting of\n** thread safety, not any run-time changes to that setting made by\n** sqlite3_config(). In other words, the return value from sqlite3_threadsafe()\n** is unchanged by calls to sqlite3_config().)^\n**\n** See the [threading mode] documentation for additional information.\n*/\nSQLITE_API int sqlite3_threadsafe(void);\n\n/*\n** CAPI3REF: Database Connection Handle\n** KEYWORDS: {database connection} {database connections}\n**\n** Each open SQLite database is represented by a pointer to an instance of\n** the opaque structure named \"sqlite3\".  It is useful to think of an sqlite3\n** pointer as an object.  The [sqlite3_open()], [sqlite3_open16()], and\n** [sqlite3_open_v2()] interfaces are its constructors, and [sqlite3_close()]\n** and [sqlite3_close_v2()] are its destructors.  There are many other\n** interfaces (such as\n** [sqlite3_prepare_v2()], [sqlite3_create_function()], and\n** [sqlite3_busy_timeout()] to name but three) that are methods on an\n** sqlite3 object.\n*/\ntypedef struct sqlite3 sqlite3;\n\n/*\n** CAPI3REF: 64-Bit Integer Types\n** KEYWORDS: sqlite_int64 sqlite_uint64\n**\n** Because there is no cross-platform way to specify 64-bit integer types\n** SQLite includes typedefs for 64-bit signed and unsigned integers.\n**\n** The sqlite3_int64 and sqlite3_uint64 are the preferred type definitions.\n** The sqlite_int64 and sqlite_uint64 types are supported for backwards\n** compatibility only.\n**\n** ^The sqlite3_int64 and sqlite_int64 types can store integer values\n** between -9223372036854775808 and +9223372036854775807 inclusive.  ^The\n** sqlite3_uint64 and sqlite_uint64 types can store integer values\n** between 0 and +18446744073709551615 inclusive.\n*/\n#ifdef SQLITE_INT64_TYPE\n  typedef SQLITE_INT64_TYPE sqlite_int64;\n# ifdef SQLITE_UINT64_TYPE\n    typedef SQLITE_UINT64_TYPE sqlite_uint64;\n# else\n    typedef unsigned SQLITE_INT64_TYPE sqlite_uint64;\n# endif\n#elif defined(_MSC_VER) || defined(__BORLANDC__)\n  typedef __int64 sqlite_int64;\n  typedef unsigned __int64 sqlite_uint64;\n#else\n  typedef long long int sqlite_int64;\n  typedef unsigned long long int sqlite_uint64;\n#endif\ntypedef sqlite_int64 sqlite3_int64;\ntypedef sqlite_uint64 sqlite3_uint64;\n\n/*\n** If compiling for a processor that lacks floating point support,\n** substitute integer for floating-point.\n*/\n#ifdef SQLITE_OMIT_FLOATING_POINT\n# define double sqlite3_int64\n#endif\n\n/*\n** CAPI3REF: Closing A Database Connection\n** DESTRUCTOR: sqlite3\n**\n** ^The sqlite3_close() and sqlite3_close_v2() routines are destructors\n** for the [sqlite3] object.\n** ^Calls to sqlite3_close() and sqlite3_close_v2() return [SQLITE_OK] if\n** the [sqlite3] object is successfully destroyed and all associated\n** resources are deallocated.\n**\n** Ideally, applications should [sqlite3_finalize | finalize] all\n** [prepared statements], [sqlite3_blob_close | close] all [BLOB handles], and\n** [sqlite3_backup_finish | finish] all [sqlite3_backup] objects associated\n** with the [sqlite3] object prior to attempting to close the object.\n** ^If the database connection is associated with unfinalized prepared\n** statements, BLOB handlers, and/or unfinished sqlite3_backup objects then\n** sqlite3_close() will leave the database connection open and return\n** [SQLITE_BUSY]. ^If sqlite3_close_v2() is called with unfinalized prepared\n** statements, unclosed BLOB handlers, and/or unfinished sqlite3_backups,\n** it returns [SQLITE_OK] regardless, but instead of deallocating the database\n** connection immediately, it marks the database connection as an unusable\n** \"zombie\" and makes arrangements to automatically deallocate the database\n** connection after all prepared statements are finalized, all BLOB handles\n** are closed, and all backups have finished. The sqlite3_close_v2() interface\n** is intended for use with host languages that are garbage collected, and\n** where the order in which destructors are called is arbitrary.\n**\n** ^If an [sqlite3] object is destroyed while a transaction is open,\n** the transaction is automatically rolled back.\n**\n** The C parameter to [sqlite3_close(C)] and [sqlite3_close_v2(C)]\n** must be either a NULL\n** pointer or an [sqlite3] object pointer obtained\n** from [sqlite3_open()], [sqlite3_open16()], or\n** [sqlite3_open_v2()], and not previously closed.\n** ^Calling sqlite3_close() or sqlite3_close_v2() with a NULL pointer\n** argument is a harmless no-op.\n*/\nSQLITE_API int sqlite3_close(sqlite3*);\nSQLITE_API int sqlite3_close_v2(sqlite3*);\n\n/*\n** The type for a callback function.\n** This is legacy and deprecated.  It is included for historical\n** compatibility and is not documented.\n*/\ntypedef int (*sqlite3_callback)(void*,int,char**, char**);\n\n/*\n** CAPI3REF: One-Step Query Execution Interface\n** METHOD: sqlite3\n**\n** The sqlite3_exec() interface is a convenience wrapper around\n** [sqlite3_prepare_v2()], [sqlite3_step()], and [sqlite3_finalize()],\n** that allows an application to run multiple statements of SQL\n** without having to use a lot of C code.\n**\n** ^The sqlite3_exec() interface runs zero or more UTF-8 encoded,\n** semicolon-separate SQL statements passed into its 2nd argument,\n** in the context of the [database connection] passed in as its 1st\n** argument.  ^If the callback function of the 3rd argument to\n** sqlite3_exec() is not NULL, then it is invoked for each result row\n** coming out of the evaluated SQL statements.  ^The 4th argument to\n** sqlite3_exec() is relayed through to the 1st argument of each\n** callback invocation.  ^If the callback pointer to sqlite3_exec()\n** is NULL, then no callback is ever invoked and result rows are\n** ignored.\n**\n** ^If an error occurs while evaluating the SQL statements passed into\n** sqlite3_exec(), then execution of the current statement stops and\n** subsequent statements are skipped.  ^If the 5th parameter to sqlite3_exec()\n** is not NULL then any error message is written into memory obtained\n** from [sqlite3_malloc()] and passed back through the 5th parameter.\n** To avoid memory leaks, the application should invoke [sqlite3_free()]\n** on error message strings returned through the 5th parameter of\n** sqlite3_exec() after the error message string is no longer needed.\n** ^If the 5th parameter to sqlite3_exec() is not NULL and no errors\n** occur, then sqlite3_exec() sets the pointer in its 5th parameter to\n** NULL before returning.\n**\n** ^If an sqlite3_exec() callback returns non-zero, the sqlite3_exec()\n** routine returns SQLITE_ABORT without invoking the callback again and\n** without running any subsequent SQL statements.\n**\n** ^The 2nd argument to the sqlite3_exec() callback function is the\n** number of columns in the result.  ^The 3rd argument to the sqlite3_exec()\n** callback is an array of pointers to strings obtained as if from\n** [sqlite3_column_text()], one for each column.  ^If an element of a\n** result row is NULL then the corresponding string pointer for the\n** sqlite3_exec() callback is a NULL pointer.  ^The 4th argument to the\n** sqlite3_exec() callback is an array of pointers to strings where each\n** entry represents the name of corresponding result column as obtained\n** from [sqlite3_column_name()].\n**\n** ^If the 2nd parameter to sqlite3_exec() is a NULL pointer, a pointer\n** to an empty string, or a pointer that contains only whitespace and/or\n** SQL comments, then no SQL statements are evaluated and the database\n** is not changed.\n**\n** Restrictions:\n**\n** <ul>\n** <li> The application must ensure that the 1st parameter to sqlite3_exec()\n**      is a valid and open [database connection].\n** <li> The application must not close the [database connection] specified by\n**      the 1st parameter to sqlite3_exec() while sqlite3_exec() is running.\n** <li> The application must not modify the SQL statement text passed into\n**      the 2nd parameter of sqlite3_exec() while sqlite3_exec() is running.\n** <li> The application must not dereference the arrays or string pointers\n**       passed as the 3rd and 4th callback parameters after it returns.\n** </ul>\n*/\nSQLITE_API int sqlite3_exec(\n  sqlite3*,                                  /* An open database */\n  const char *sql,                           /* SQL to be evaluated */\n  int (*callback)(void*,int,char**,char**),  /* Callback function */\n  void *,                                    /* 1st argument to callback */\n  char **errmsg                              /* Error msg written here */\n);\n\n/*\n** CAPI3REF: Result Codes\n** KEYWORDS: {result code definitions}\n**\n** Many SQLite functions return an integer result code from the set shown\n** here in order to indicate success or failure.\n**\n** New error codes may be added in future versions of SQLite.\n**\n** See also: [extended result code definitions]\n*/\n#define SQLITE_OK           0   /* Successful result */\n/* beginning-of-error-codes */\n#define SQLITE_ERROR        1   /* Generic error */\n#define SQLITE_INTERNAL     2   /* Internal logic error in SQLite */\n#define SQLITE_PERM         3   /* Access permission denied */\n#define SQLITE_ABORT        4   /* Callback routine requested an abort */\n#define SQLITE_BUSY         5   /* The database file is locked */\n#define SQLITE_LOCKED       6   /* A table in the database is locked */\n#define SQLITE_NOMEM        7   /* A malloc() failed */\n#define SQLITE_READONLY     8   /* Attempt to write a readonly database */\n#define SQLITE_INTERRUPT    9   /* Operation terminated by sqlite3_interrupt()*/\n#define SQLITE_IOERR       10   /* Some kind of disk I/O error occurred */\n#define SQLITE_CORRUPT     11   /* The database disk image is malformed */\n#define SQLITE_NOTFOUND    12   /* Unknown opcode in sqlite3_file_control() */\n#define SQLITE_FULL        13   /* Insertion failed because database is full */\n#define SQLITE_CANTOPEN    14   /* Unable to open the database file */\n#define SQLITE_PROTOCOL    15   /* Database lock protocol error */\n#define SQLITE_EMPTY       16   /* Internal use only */\n#define SQLITE_SCHEMA      17   /* The database schema changed */\n#define SQLITE_TOOBIG      18   /* String or BLOB exceeds size limit */\n#define SQLITE_CONSTRAINT  19   /* Abort due to constraint violation */\n#define SQLITE_MISMATCH    20   /* Data type mismatch */\n#define SQLITE_MISUSE      21   /* Library used incorrectly */\n#define SQLITE_NOLFS       22   /* Uses OS features not supported on host */\n#define SQLITE_AUTH        23   /* Authorization denied */\n#define SQLITE_FORMAT      24   /* Not used */\n#define SQLITE_RANGE       25   /* 2nd parameter to sqlite3_bind out of range */\n#define SQLITE_NOTADB      26   /* File opened that is not a database file */\n#define SQLITE_NOTICE      27   /* Notifications from sqlite3_log() */\n#define SQLITE_WARNING     28   /* Warnings from sqlite3_log() */\n#define SQLITE_ROW         100  /* sqlite3_step() has another row ready */\n#define SQLITE_DONE        101  /* sqlite3_step() has finished executing */\n/* end-of-error-codes */\n\n/*\n** CAPI3REF: Extended Result Codes\n** KEYWORDS: {extended result code definitions}\n**\n** In its default configuration, SQLite API routines return one of 30 integer\n** [result codes].  However, experience has shown that many of\n** these result codes are too coarse-grained.  They do not provide as\n** much information about problems as programmers might like.  In an effort to\n** address this, newer versions of SQLite (version 3.3.8 [dateof:3.3.8]\n** and later) include\n** support for additional result codes that provide more detailed information\n** about errors. These [extended result codes] are enabled or disabled\n** on a per database connection basis using the\n** [sqlite3_extended_result_codes()] API.  Or, the extended code for\n** the most recent error can be obtained using\n** [sqlite3_extended_errcode()].\n*/\n#define SQLITE_ERROR_MISSING_COLLSEQ   (SQLITE_ERROR | (1<<8))\n#define SQLITE_ERROR_RETRY             (SQLITE_ERROR | (2<<8))\n#define SQLITE_ERROR_SNAPSHOT          (SQLITE_ERROR | (3<<8))\n#define SQLITE_IOERR_READ              (SQLITE_IOERR | (1<<8))\n#define SQLITE_IOERR_SHORT_READ        (SQLITE_IOERR | (2<<8))\n#define SQLITE_IOERR_WRITE             (SQLITE_IOERR | (3<<8))\n#define SQLITE_IOERR_FSYNC             (SQLITE_IOERR | (4<<8))\n#define SQLITE_IOERR_DIR_FSYNC         (SQLITE_IOERR | (5<<8))\n#define SQLITE_IOERR_TRUNCATE          (SQLITE_IOERR | (6<<8))\n#define SQLITE_IOERR_FSTAT             (SQLITE_IOERR | (7<<8))\n#define SQLITE_IOERR_UNLOCK            (SQLITE_IOERR | (8<<8))\n#define SQLITE_IOERR_RDLOCK            (SQLITE_IOERR | (9<<8))\n#define SQLITE_IOERR_DELETE            (SQLITE_IOERR | (10<<8))\n#define SQLITE_IOERR_BLOCKED           (SQLITE_IOERR | (11<<8))\n#define SQLITE_IOERR_NOMEM             (SQLITE_IOERR | (12<<8))\n#define SQLITE_IOERR_ACCESS            (SQLITE_IOERR | (13<<8))\n#define SQLITE_IOERR_CHECKRESERVEDLOCK (SQLITE_IOERR | (14<<8))\n#define SQLITE_IOERR_LOCK              (SQLITE_IOERR | (15<<8))\n#define SQLITE_IOERR_CLOSE             (SQLITE_IOERR | (16<<8))\n#define SQLITE_IOERR_DIR_CLOSE         (SQLITE_IOERR | (17<<8))\n#define SQLITE_IOERR_SHMOPEN           (SQLITE_IOERR | (18<<8))\n#define SQLITE_IOERR_SHMSIZE           (SQLITE_IOERR | (19<<8))\n#define SQLITE_IOERR_SHMLOCK           (SQLITE_IOERR | (20<<8))\n#define SQLITE_IOERR_SHMMAP            (SQLITE_IOERR | (21<<8))\n#define SQLITE_IOERR_SEEK              (SQLITE_IOERR | (22<<8))\n#define SQLITE_IOERR_DELETE_NOENT      (SQLITE_IOERR | (23<<8))\n#define SQLITE_IOERR_MMAP              (SQLITE_IOERR | (24<<8))\n#define SQLITE_IOERR_GETTEMPPATH       (SQLITE_IOERR | (25<<8))\n#define SQLITE_IOERR_CONVPATH          (SQLITE_IOERR | (26<<8))\n#define SQLITE_IOERR_VNODE             (SQLITE_IOERR | (27<<8))\n#define SQLITE_IOERR_AUTH              (SQLITE_IOERR | (28<<8))\n#define SQLITE_IOERR_BEGIN_ATOMIC      (SQLITE_IOERR | (29<<8))\n#define SQLITE_IOERR_COMMIT_ATOMIC     (SQLITE_IOERR | (30<<8))\n#define SQLITE_IOERR_ROLLBACK_ATOMIC   (SQLITE_IOERR | (31<<8))\n#define SQLITE_IOERR_DATA              (SQLITE_IOERR | (32<<8))\n#define SQLITE_IOERR_CORRUPTFS         (SQLITE_IOERR | (33<<8))\n#define SQLITE_IOERR_IN_PAGE           (SQLITE_IOERR | (34<<8))\n#define SQLITE_LOCKED_SHAREDCACHE      (SQLITE_LOCKED |  (1<<8))\n#define SQLITE_LOCKED_VTAB             (SQLITE_LOCKED |  (2<<8))\n#define SQLITE_BUSY_RECOVERY           (SQLITE_BUSY   |  (1<<8))\n#define SQLITE_BUSY_SNAPSHOT           (SQLITE_BUSY   |  (2<<8))\n#define SQLITE_BUSY_TIMEOUT            (SQLITE_BUSY   |  (3<<8))\n#define SQLITE_CANTOPEN_NOTEMPDIR      (SQLITE_CANTOPEN | (1<<8))\n#define SQLITE_CANTOPEN_ISDIR          (SQLITE_CANTOPEN | (2<<8))\n#define SQLITE_CANTOPEN_FULLPATH       (SQLITE_CANTOPEN | (3<<8))\n#define SQLITE_CANTOPEN_CONVPATH       (SQLITE_CANTOPEN | (4<<8))\n#define SQLITE_CANTOPEN_DIRTYWAL       (SQLITE_CANTOPEN | (5<<8)) /* Not Used */\n#define SQLITE_CANTOPEN_SYMLINK        (SQLITE_CANTOPEN | (6<<8))\n#define SQLITE_CORRUPT_VTAB            (SQLITE_CORRUPT | (1<<8))\n#define SQLITE_CORRUPT_SEQUENCE        (SQLITE_CORRUPT | (2<<8))\n#define SQLITE_CORRUPT_INDEX           (SQLITE_CORRUPT | (3<<8))\n#define SQLITE_READONLY_RECOVERY       (SQLITE_READONLY | (1<<8))\n#define SQLITE_READONLY_CANTLOCK       (SQLITE_READONLY | (2<<8))\n#define SQLITE_READONLY_ROLLBACK       (SQLITE_READONLY | (3<<8))\n#define SQLITE_READONLY_DBMOVED        (SQLITE_READONLY | (4<<8))\n#define SQLITE_READONLY_CANTINIT       (SQLITE_READONLY | (5<<8))\n#define SQLITE_READONLY_DIRECTORY      (SQLITE_READONLY | (6<<8))\n#define SQLITE_ABORT_ROLLBACK          (SQLITE_ABORT | (2<<8))\n#define SQLITE_CONSTRAINT_CHECK        (SQLITE_CONSTRAINT | (1<<8))\n#define SQLITE_CONSTRAINT_COMMITHOOK   (SQLITE_CONSTRAINT | (2<<8))\n#define SQLITE_CONSTRAINT_FOREIGNKEY   (SQLITE_CONSTRAINT | (3<<8))\n#define SQLITE_CONSTRAINT_FUNCTION     (SQLITE_CONSTRAINT | (4<<8))\n#define SQLITE_CONSTRAINT_NOTNULL      (SQLITE_CONSTRAINT | (5<<8))\n#define SQLITE_CONSTRAINT_PRIMARYKEY   (SQLITE_CONSTRAINT | (6<<8))\n#define SQLITE_CONSTRAINT_TRIGGER      (SQLITE_CONSTRAINT | (7<<8))\n#define SQLITE_CONSTRAINT_UNIQUE       (SQLITE_CONSTRAINT | (8<<8))\n#define SQLITE_CONSTRAINT_VTAB         (SQLITE_CONSTRAINT | (9<<8))\n#define SQLITE_CONSTRAINT_ROWID        (SQLITE_CONSTRAINT |(10<<8))\n#define SQLITE_CONSTRAINT_PINNED       (SQLITE_CONSTRAINT |(11<<8))\n#define SQLITE_CONSTRAINT_DATATYPE     (SQLITE_CONSTRAINT |(12<<8))\n#define SQLITE_NOTICE_RECOVER_WAL      (SQLITE_NOTICE | (1<<8))\n#define SQLITE_NOTICE_RECOVER_ROLLBACK (SQLITE_NOTICE | (2<<8))\n#define SQLITE_NOTICE_RBU              (SQLITE_NOTICE | (3<<8))\n#define SQLITE_WARNING_AUTOINDEX       (SQLITE_WARNING | (1<<8))\n#define SQLITE_AUTH_USER               (SQLITE_AUTH | (1<<8))\n#define SQLITE_OK_LOAD_PERMANENTLY     (SQLITE_OK | (1<<8))\n#define SQLITE_OK_SYMLINK              (SQLITE_OK | (2<<8)) /* internal use only */\n\n/*\n** CAPI3REF: Flags For File Open Operations\n**\n** These bit values are intended for use in the\n** 3rd parameter to the [sqlite3_open_v2()] interface and\n** in the 4th parameter to the [sqlite3_vfs.xOpen] method.\n**\n** Only those flags marked as \"Ok for sqlite3_open_v2()\" may be\n** used as the third argument to the [sqlite3_open_v2()] interface.\n** The other flags have historically been ignored by sqlite3_open_v2(),\n** though future versions of SQLite might change so that an error is\n** raised if any of the disallowed bits are passed into sqlite3_open_v2().\n** Applications should not depend on the historical behavior.\n**\n** Note in particular that passing the SQLITE_OPEN_EXCLUSIVE flag into\n** [sqlite3_open_v2()] does *not* cause the underlying database file\n** to be opened using O_EXCL.  Passing SQLITE_OPEN_EXCLUSIVE into\n** [sqlite3_open_v2()] has historically be a no-op and might become an\n** error in future versions of SQLite.\n*/\n#define SQLITE_OPEN_READONLY         0x00000001  /* Ok for sqlite3_open_v2() */\n#define SQLITE_OPEN_READWRITE        0x00000002  /* Ok for sqlite3_open_v2() */\n#define SQLITE_OPEN_CREATE           0x00000004  /* Ok for sqlite3_open_v2() */\n#define SQLITE_OPEN_DELETEONCLOSE    0x00000008  /* VFS only */\n#define SQLITE_OPEN_EXCLUSIVE        0x00000010  /* VFS only */\n#define SQLITE_OPEN_AUTOPROXY        0x00000020  /* VFS only */\n#define SQLITE_OPEN_URI              0x00000040  /* Ok for sqlite3_open_v2() */\n#define SQLITE_OPEN_MEMORY           0x00000080  /* Ok for sqlite3_open_v2() */\n#define SQLITE_OPEN_MAIN_DB          0x00000100  /* VFS only */\n#define SQLITE_OPEN_TEMP_DB          0x00000200  /* VFS only */\n#define SQLITE_OPEN_TRANSIENT_DB     0x00000400  /* VFS only */\n#define SQLITE_OPEN_MAIN_JOURNAL     0x00000800  /* VFS only */\n#define SQLITE_OPEN_TEMP_JOURNAL     0x00001000  /* VFS only */\n#define SQLITE_OPEN_SUBJOURNAL       0x00002000  /* VFS only */\n#define SQLITE_OPEN_SUPER_JOURNAL    0x00004000  /* VFS only */\n#define SQLITE_OPEN_NOMUTEX          0x00008000  /* Ok for sqlite3_open_v2() */\n#define SQLITE_OPEN_FULLMUTEX        0x00010000  /* Ok for sqlite3_open_v2() */\n#define SQLITE_OPEN_SHAREDCACHE      0x00020000  /* Ok for sqlite3_open_v2() */\n#define SQLITE_OPEN_PRIVATECACHE     0x00040000  /* Ok for sqlite3_open_v2() */\n#define SQLITE_OPEN_WAL              0x00080000  /* VFS only */\n#define SQLITE_OPEN_NOFOLLOW         0x01000000  /* Ok for sqlite3_open_v2() */\n#define SQLITE_OPEN_EXRESCODE        0x02000000  /* Extended result codes */\n\n/* Reserved:                         0x00F00000 */\n/* Legacy compatibility: */\n#define SQLITE_OPEN_MASTER_JOURNAL   0x00004000  /* VFS only */\n\n\n/*\n** CAPI3REF: Device Characteristics\n**\n** The xDeviceCharacteristics method of the [sqlite3_io_methods]\n** object returns an integer which is a vector of these\n** bit values expressing I/O characteristics of the mass storage\n** device that holds the file that the [sqlite3_io_methods]\n** refers to.\n**\n** The SQLITE_IOCAP_ATOMIC property means that all writes of\n** any size are atomic.  The SQLITE_IOCAP_ATOMICnnn values\n** mean that writes of blocks that are nnn bytes in size and\n** are aligned to an address which is an integer multiple of\n** nnn are atomic.  The SQLITE_IOCAP_SAFE_APPEND value means\n** that when data is appended to a file, the data is appended\n** first then the size of the file is extended, never the other\n** way around.  The SQLITE_IOCAP_SEQUENTIAL property means that\n** information is written to disk in the same order as calls\n** to xWrite().  The SQLITE_IOCAP_POWERSAFE_OVERWRITE property means that\n** after reboot following a crash or power loss, the only bytes in a\n** file that were written at the application level might have changed\n** and that adjacent bytes, even bytes within the same sector are\n** guaranteed to be unchanged.  The SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN\n** flag indicates that a file cannot be deleted when open.  The\n** SQLITE_IOCAP_IMMUTABLE flag indicates that the file is on\n** read-only media and cannot be changed even by processes with\n** elevated privileges.\n**\n** The SQLITE_IOCAP_BATCH_ATOMIC property means that the underlying\n** filesystem supports doing multiple write operations atomically when those\n** write operations are bracketed by [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE] and\n** [SQLITE_FCNTL_COMMIT_ATOMIC_WRITE].\n*/\n#define SQLITE_IOCAP_ATOMIC                 0x00000001\n#define SQLITE_IOCAP_ATOMIC512              0x00000002\n#define SQLITE_IOCAP_ATOMIC1K               0x00000004\n#define SQLITE_IOCAP_ATOMIC2K               0x00000008\n#define SQLITE_IOCAP_ATOMIC4K               0x00000010\n#define SQLITE_IOCAP_ATOMIC8K               0x00000020\n#define SQLITE_IOCAP_ATOMIC16K              0x00000040\n#define SQLITE_IOCAP_ATOMIC32K              0x00000080\n#define SQLITE_IOCAP_ATOMIC64K              0x00000100\n#define SQLITE_IOCAP_SAFE_APPEND            0x00000200\n#define SQLITE_IOCAP_SEQUENTIAL             0x00000400\n#define SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN  0x00000800\n#define SQLITE_IOCAP_POWERSAFE_OVERWRITE    0x00001000\n#define SQLITE_IOCAP_IMMUTABLE              0x00002000\n#define SQLITE_IOCAP_BATCH_ATOMIC           0x00004000\n\n/*\n** CAPI3REF: File Locking Levels\n**\n** SQLite uses one of these integer values as the second\n** argument to calls it makes to the xLock() and xUnlock() methods\n** of an [sqlite3_io_methods] object.  These values are ordered from\n** lest restrictive to most restrictive.\n**\n** The argument to xLock() is always SHARED or higher.  The argument to\n** xUnlock is either SHARED or NONE.\n*/\n#define SQLITE_LOCK_NONE          0       /* xUnlock() only */\n#define SQLITE_LOCK_SHARED        1       /* xLock() or xUnlock() */\n#define SQLITE_LOCK_RESERVED      2       /* xLock() only */\n#define SQLITE_LOCK_PENDING       3       /* xLock() only */\n#define SQLITE_LOCK_EXCLUSIVE     4       /* xLock() only */\n\n/*\n** CAPI3REF: Synchronization Type Flags\n**\n** When SQLite invokes the xSync() method of an\n** [sqlite3_io_methods] object it uses a combination of\n** these integer values as the second argument.\n**\n** When the SQLITE_SYNC_DATAONLY flag is used, it means that the\n** sync operation only needs to flush data to mass storage.  Inode\n** information need not be flushed. If the lower four bits of the flag\n** equal SQLITE_SYNC_NORMAL, that means to use normal fsync() semantics.\n** If the lower four bits equal SQLITE_SYNC_FULL, that means\n** to use Mac OS X style fullsync instead of fsync().\n**\n** Do not confuse the SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL flags\n** with the [PRAGMA synchronous]=NORMAL and [PRAGMA synchronous]=FULL\n** settings.  The [synchronous pragma] determines when calls to the\n** xSync VFS method occur and applies uniformly across all platforms.\n** The SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL flags determine how\n** energetic or rigorous or forceful the sync operations are and\n** only make a difference on Mac OSX for the default SQLite code.\n** (Third-party VFS implementations might also make the distinction\n** between SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL, but among the\n** operating systems natively supported by SQLite, only Mac OSX\n** cares about the difference.)\n*/\n#define SQLITE_SYNC_NORMAL        0x00002\n#define SQLITE_SYNC_FULL          0x00003\n#define SQLITE_SYNC_DATAONLY      0x00010\n\n/*\n** CAPI3REF: OS Interface Open File Handle\n**\n** An [sqlite3_file] object represents an open file in the\n** [sqlite3_vfs | OS interface layer].  Individual OS interface\n** implementations will\n** want to subclass this object by appending additional fields\n** for their own use.  The pMethods entry is a pointer to an\n** [sqlite3_io_methods] object that defines methods for performing\n** I/O operations on the open file.\n*/\ntypedef struct sqlite3_file sqlite3_file;\nstruct sqlite3_file {\n  const struct sqlite3_io_methods *pMethods;  /* Methods for an open file */\n};\n\n/*\n** CAPI3REF: OS Interface File Virtual Methods Object\n**\n** Every file opened by the [sqlite3_vfs.xOpen] method populates an\n** [sqlite3_file] object (or, more commonly, a subclass of the\n** [sqlite3_file] object) with a pointer to an instance of this object.\n** This object defines the methods used to perform various operations\n** against the open file represented by the [sqlite3_file] object.\n**\n** If the [sqlite3_vfs.xOpen] method sets the sqlite3_file.pMethods element\n** to a non-NULL pointer, then the sqlite3_io_methods.xClose method\n** may be invoked even if the [sqlite3_vfs.xOpen] reported that it failed.  The\n** only way to prevent a call to xClose following a failed [sqlite3_vfs.xOpen]\n** is for the [sqlite3_vfs.xOpen] to set the sqlite3_file.pMethods element\n** to NULL.\n**\n** The flags argument to xSync may be one of [SQLITE_SYNC_NORMAL] or\n** [SQLITE_SYNC_FULL].  The first choice is the normal fsync().\n** The second choice is a Mac OS X style fullsync.  The [SQLITE_SYNC_DATAONLY]\n** flag may be ORed in to indicate that only the data of the file\n** and not its inode needs to be synced.\n**\n** The integer values to xLock() and xUnlock() are one of\n** <ul>\n** <li> [SQLITE_LOCK_NONE],\n** <li> [SQLITE_LOCK_SHARED],\n** <li> [SQLITE_LOCK_RESERVED],\n** <li> [SQLITE_LOCK_PENDING], or\n** <li> [SQLITE_LOCK_EXCLUSIVE].\n** </ul>\n** xLock() upgrades the database file lock.  In other words, xLock() moves the\n** database file lock in the direction NONE toward EXCLUSIVE. The argument to\n** xLock() is always one of SHARED, RESERVED, PENDING, or EXCLUSIVE, never\n** SQLITE_LOCK_NONE.  If the database file lock is already at or above the\n** requested lock, then the call to xLock() is a no-op.\n** xUnlock() downgrades the database file lock to either SHARED or NONE.\n** If the lock is already at or below the requested lock state, then the call\n** to xUnlock() is a no-op.\n** The xCheckReservedLock() method checks whether any database connection,\n** either in this process or in some other process, is holding a RESERVED,\n** PENDING, or EXCLUSIVE lock on the file.  It returns true\n** if such a lock exists and false otherwise.\n**\n** The xFileControl() method is a generic interface that allows custom\n** VFS implementations to directly control an open file using the\n** [sqlite3_file_control()] interface.  The second \"op\" argument is an\n** integer opcode.  The third argument is a generic pointer intended to\n** point to a structure that may contain arguments or space in which to\n** write return values.  Potential uses for xFileControl() might be\n** functions to enable blocking locks with timeouts, to change the\n** locking strategy (for example to use dot-file locks), to inquire\n** about the status of a lock, or to break stale locks.  The SQLite\n** core reserves all opcodes less than 100 for its own use.\n** A [file control opcodes | list of opcodes] less than 100 is available.\n** Applications that define a custom xFileControl method should use opcodes\n** greater than 100 to avoid conflicts.  VFS implementations should\n** return [SQLITE_NOTFOUND] for file control opcodes that they do not\n** recognize.\n**\n** The xSectorSize() method returns the sector size of the\n** device that underlies the file.  The sector size is the\n** minimum write that can be performed without disturbing\n** other bytes in the file.  The xDeviceCharacteristics()\n** method returns a bit vector describing behaviors of the\n** underlying device:\n**\n** <ul>\n** <li> [SQLITE_IOCAP_ATOMIC]\n** <li> [SQLITE_IOCAP_ATOMIC512]\n** <li> [SQLITE_IOCAP_ATOMIC1K]\n** <li> [SQLITE_IOCAP_ATOMIC2K]\n** <li> [SQLITE_IOCAP_ATOMIC4K]\n** <li> [SQLITE_IOCAP_ATOMIC8K]\n** <li> [SQLITE_IOCAP_ATOMIC16K]\n** <li> [SQLITE_IOCAP_ATOMIC32K]\n** <li> [SQLITE_IOCAP_ATOMIC64K]\n** <li> [SQLITE_IOCAP_SAFE_APPEND]\n** <li> [SQLITE_IOCAP_SEQUENTIAL]\n** <li> [SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN]\n** <li> [SQLITE_IOCAP_POWERSAFE_OVERWRITE]\n** <li> [SQLITE_IOCAP_IMMUTABLE]\n** <li> [SQLITE_IOCAP_BATCH_ATOMIC]\n** </ul>\n**\n** The SQLITE_IOCAP_ATOMIC property means that all writes of\n** any size are atomic.  The SQLITE_IOCAP_ATOMICnnn values\n** mean that writes of blocks that are nnn bytes in size and\n** are aligned to an address which is an integer multiple of\n** nnn are atomic.  The SQLITE_IOCAP_SAFE_APPEND value means\n** that when data is appended to a file, the data is appended\n** first then the size of the file is extended, never the other\n** way around.  The SQLITE_IOCAP_SEQUENTIAL property means that\n** information is written to disk in the same order as calls\n** to xWrite().\n**\n** If xRead() returns SQLITE_IOERR_SHORT_READ it must also fill\n** in the unread portions of the buffer with zeros.  A VFS that\n** fails to zero-fill short reads might seem to work.  However,\n** failure to zero-fill short reads will eventually lead to\n** database corruption.\n*/\ntypedef struct sqlite3_io_methods sqlite3_io_methods;\nstruct sqlite3_io_methods {\n  int iVersion;\n  int (*xClose)(sqlite3_file*);\n  int (*xRead)(sqlite3_file*, void*, int iAmt, sqlite3_int64 iOfst);\n  int (*xWrite)(sqlite3_file*, const void*, int iAmt, sqlite3_int64 iOfst);\n  int (*xTruncate)(sqlite3_file*, sqlite3_int64 size);\n  int (*xSync)(sqlite3_file*, int flags);\n  int (*xFileSize)(sqlite3_file*, sqlite3_int64 *pSize);\n  int (*xLock)(sqlite3_file*, int);\n  int (*xUnlock)(sqlite3_file*, int);\n  int (*xCheckReservedLock)(sqlite3_file*, int *pResOut);\n  int (*xFileControl)(sqlite3_file*, int op, void *pArg);\n  int (*xSectorSize)(sqlite3_file*);\n  int (*xDeviceCharacteristics)(sqlite3_file*);\n  /* Methods above are valid for version 1 */\n  int (*xShmMap)(sqlite3_file*, int iPg, int pgsz, int, void volatile**);\n  int (*xShmLock)(sqlite3_file*, int offset, int n, int flags);\n  void (*xShmBarrier)(sqlite3_file*);\n  int (*xShmUnmap)(sqlite3_file*, int deleteFlag);\n  /* Methods above are valid for version 2 */\n  int (*xFetch)(sqlite3_file*, sqlite3_int64 iOfst, int iAmt, void **pp);\n  int (*xUnfetch)(sqlite3_file*, sqlite3_int64 iOfst, void *p);\n  /* Methods above are valid for version 3 */\n  /* Additional methods may be added in future releases */\n};\n\n/*\n** CAPI3REF: Standard File Control Opcodes\n** KEYWORDS: {file control opcodes} {file control opcode}\n**\n** These integer constants are opcodes for the xFileControl method\n** of the [sqlite3_io_methods] object and for the [sqlite3_file_control()]\n** interface.\n**\n** <ul>\n** <li>[[SQLITE_FCNTL_LOCKSTATE]]\n** The [SQLITE_FCNTL_LOCKSTATE] opcode is used for debugging.  This\n** opcode causes the xFileControl method to write the current state of\n** the lock (one of [SQLITE_LOCK_NONE], [SQLITE_LOCK_SHARED],\n** [SQLITE_LOCK_RESERVED], [SQLITE_LOCK_PENDING], or [SQLITE_LOCK_EXCLUSIVE])\n** into an integer that the pArg argument points to.\n** This capability is only available if SQLite is compiled with [SQLITE_DEBUG].\n**\n** <li>[[SQLITE_FCNTL_SIZE_HINT]]\n** The [SQLITE_FCNTL_SIZE_HINT] opcode is used by SQLite to give the VFS\n** layer a hint of how large the database file will grow to be during the\n** current transaction.  This hint is not guaranteed to be accurate but it\n** is often close.  The underlying VFS might choose to preallocate database\n** file space based on this hint in order to help writes to the database\n** file run faster.\n**\n** <li>[[SQLITE_FCNTL_SIZE_LIMIT]]\n** The [SQLITE_FCNTL_SIZE_LIMIT] opcode is used by in-memory VFS that\n** implements [sqlite3_deserialize()] to set an upper bound on the size\n** of the in-memory database.  The argument is a pointer to a [sqlite3_int64].\n** If the integer pointed to is negative, then it is filled in with the\n** current limit.  Otherwise the limit is set to the larger of the value\n** of the integer pointed to and the current database size.  The integer\n** pointed to is set to the new limit.\n**\n** <li>[[SQLITE_FCNTL_CHUNK_SIZE]]\n** The [SQLITE_FCNTL_CHUNK_SIZE] opcode is used to request that the VFS\n** extends and truncates the database file in chunks of a size specified\n** by the user. The fourth argument to [sqlite3_file_control()] should\n** point to an integer (type int) containing the new chunk-size to use\n** for the nominated database. Allocating database file space in large\n** chunks (say 1MB at a time), may reduce file-system fragmentation and\n** improve performance on some systems.\n**\n** <li>[[SQLITE_FCNTL_FILE_POINTER]]\n** The [SQLITE_FCNTL_FILE_POINTER] opcode is used to obtain a pointer\n** to the [sqlite3_file] object associated with a particular database\n** connection.  See also [SQLITE_FCNTL_JOURNAL_POINTER].\n**\n** <li>[[SQLITE_FCNTL_JOURNAL_POINTER]]\n** The [SQLITE_FCNTL_JOURNAL_POINTER] opcode is used to obtain a pointer\n** to the [sqlite3_file] object associated with the journal file (either\n** the [rollback journal] or the [write-ahead log]) for a particular database\n** connection.  See also [SQLITE_FCNTL_FILE_POINTER].\n**\n** <li>[[SQLITE_FCNTL_SYNC_OMITTED]]\n** No longer in use.\n**\n** <li>[[SQLITE_FCNTL_SYNC]]\n** The [SQLITE_FCNTL_SYNC] opcode is generated internally by SQLite and\n** sent to the VFS immediately before the xSync method is invoked on a\n** database file descriptor. Or, if the xSync method is not invoked\n** because the user has configured SQLite with\n** [PRAGMA synchronous | PRAGMA synchronous=OFF] it is invoked in place\n** of the xSync method. In most cases, the pointer argument passed with\n** this file-control is NULL. However, if the database file is being synced\n** as part of a multi-database commit, the argument points to a nul-terminated\n** string containing the transactions super-journal file name. VFSes that\n** do not need this signal should silently ignore this opcode. Applications\n** should not call [sqlite3_file_control()] with this opcode as doing so may\n** disrupt the operation of the specialized VFSes that do require it.\n**\n** <li>[[SQLITE_FCNTL_COMMIT_PHASETWO]]\n** The [SQLITE_FCNTL_COMMIT_PHASETWO] opcode is generated internally by SQLite\n** and sent to the VFS after a transaction has been committed immediately\n** but before the database is unlocked. VFSes that do not need this signal\n** should silently ignore this opcode. Applications should not call\n** [sqlite3_file_control()] with this opcode as doing so may disrupt the\n** operation of the specialized VFSes that do require it.\n**\n** <li>[[SQLITE_FCNTL_WIN32_AV_RETRY]]\n** ^The [SQLITE_FCNTL_WIN32_AV_RETRY] opcode is used to configure automatic\n** retry counts and intervals for certain disk I/O operations for the\n** windows [VFS] in order to provide robustness in the presence of\n** anti-virus programs.  By default, the windows VFS will retry file read,\n** file write, and file delete operations up to 10 times, with a delay\n** of 25 milliseconds before the first retry and with the delay increasing\n** by an additional 25 milliseconds with each subsequent retry.  This\n** opcode allows these two values (10 retries and 25 milliseconds of delay)\n** to be adjusted.  The values are changed for all database connections\n** within the same process.  The argument is a pointer to an array of two\n** integers where the first integer is the new retry count and the second\n** integer is the delay.  If either integer is negative, then the setting\n** is not changed but instead the prior value of that setting is written\n** into the array entry, allowing the current retry settings to be\n** interrogated.  The zDbName parameter is ignored.\n**\n** <li>[[SQLITE_FCNTL_PERSIST_WAL]]\n** ^The [SQLITE_FCNTL_PERSIST_WAL] opcode is used to set or query the\n** persistent [WAL | Write Ahead Log] setting.  By default, the auxiliary\n** write ahead log ([WAL file]) and shared memory\n** files used for transaction control\n** are automatically deleted when the latest connection to the database\n** closes.  Setting persistent WAL mode causes those files to persist after\n** close.  Persisting the files is useful when other processes that do not\n** have write permission on the directory containing the database file want\n** to read the database file, as the WAL and shared memory files must exist\n** in order for the database to be readable.  The fourth parameter to\n** [sqlite3_file_control()] for this opcode should be a pointer to an integer.\n** That integer is 0 to disable persistent WAL mode or 1 to enable persistent\n** WAL mode.  If the integer is -1, then it is overwritten with the current\n** WAL persistence setting.\n**\n** <li>[[SQLITE_FCNTL_POWERSAFE_OVERWRITE]]\n** ^The [SQLITE_FCNTL_POWERSAFE_OVERWRITE] opcode is used to set or query the\n** persistent \"powersafe-overwrite\" or \"PSOW\" setting.  The PSOW setting\n** determines the [SQLITE_IOCAP_POWERSAFE_OVERWRITE] bit of the\n** xDeviceCharacteristics methods. The fourth parameter to\n** [sqlite3_file_control()] for this opcode should be a pointer to an integer.\n** That integer is 0 to disable zero-damage mode or 1 to enable zero-damage\n** mode.  If the integer is -1, then it is overwritten with the current\n** zero-damage mode setting.\n**\n** <li>[[SQLITE_FCNTL_OVERWRITE]]\n** ^The [SQLITE_FCNTL_OVERWRITE] opcode is invoked by SQLite after opening\n** a write transaction to indicate that, unless it is rolled back for some\n** reason, the entire database file will be overwritten by the current\n** transaction. This is used by VACUUM operations.\n**\n** <li>[[SQLITE_FCNTL_VFSNAME]]\n** ^The [SQLITE_FCNTL_VFSNAME] opcode can be used to obtain the names of\n** all [VFSes] in the VFS stack.  The names are of all VFS shims and the\n** final bottom-level VFS are written into memory obtained from\n** [sqlite3_malloc()] and the result is stored in the char* variable\n** that the fourth parameter of [sqlite3_file_control()] points to.\n** The caller is responsible for freeing the memory when done.  As with\n** all file-control actions, there is no guarantee that this will actually\n** do anything.  Callers should initialize the char* variable to a NULL\n** pointer in case this file-control is not implemented.  This file-control\n** is intended for diagnostic use only.\n**\n** <li>[[SQLITE_FCNTL_VFS_POINTER]]\n** ^The [SQLITE_FCNTL_VFS_POINTER] opcode finds a pointer to the top-level\n** [VFSes] currently in use.  ^(The argument X in\n** sqlite3_file_control(db,SQLITE_FCNTL_VFS_POINTER,X) must be\n** of type \"[sqlite3_vfs] **\".  This opcodes will set *X\n** to a pointer to the top-level VFS.)^\n** ^When there are multiple VFS shims in the stack, this opcode finds the\n** upper-most shim only.\n**\n** <li>[[SQLITE_FCNTL_PRAGMA]]\n** ^Whenever a [PRAGMA] statement is parsed, an [SQLITE_FCNTL_PRAGMA]\n** file control is sent to the open [sqlite3_file] object corresponding\n** to the database file to which the pragma statement refers. ^The argument\n** to the [SQLITE_FCNTL_PRAGMA] file control is an array of\n** pointers to strings (char**) in which the second element of the array\n** is the name of the pragma and the third element is the argument to the\n** pragma or NULL if the pragma has no argument.  ^The handler for an\n** [SQLITE_FCNTL_PRAGMA] file control can optionally make the first element\n** of the char** argument point to a string obtained from [sqlite3_mprintf()]\n** or the equivalent and that string will become the result of the pragma or\n** the error message if the pragma fails. ^If the\n** [SQLITE_FCNTL_PRAGMA] file control returns [SQLITE_NOTFOUND], then normal\n** [PRAGMA] processing continues.  ^If the [SQLITE_FCNTL_PRAGMA]\n** file control returns [SQLITE_OK], then the parser assumes that the\n** VFS has handled the PRAGMA itself and the parser generates a no-op\n** prepared statement if result string is NULL, or that returns a copy\n** of the result string if the string is non-NULL.\n** ^If the [SQLITE_FCNTL_PRAGMA] file control returns\n** any result code other than [SQLITE_OK] or [SQLITE_NOTFOUND], that means\n** that the VFS encountered an error while handling the [PRAGMA] and the\n** compilation of the PRAGMA fails with an error.  ^The [SQLITE_FCNTL_PRAGMA]\n** file control occurs at the beginning of pragma statement analysis and so\n** it is able to override built-in [PRAGMA] statements.\n**\n** <li>[[SQLITE_FCNTL_BUSYHANDLER]]\n** ^The [SQLITE_FCNTL_BUSYHANDLER]\n** file-control may be invoked by SQLite on the database file handle\n** shortly after it is opened in order to provide a custom VFS with access\n** to the connection's busy-handler callback. The argument is of type (void**)\n** - an array of two (void *) values. The first (void *) actually points\n** to a function of type (int (*)(void *)). In order to invoke the connection's\n** busy-handler, this function should be invoked with the second (void *) in\n** the array as the only argument. If it returns non-zero, then the operation\n** should be retried. If it returns zero, the custom VFS should abandon the\n** current operation.\n**\n** <li>[[SQLITE_FCNTL_TEMPFILENAME]]\n** ^Applications can invoke the [SQLITE_FCNTL_TEMPFILENAME] file-control\n** to have SQLite generate a\n** temporary filename using the same algorithm that is followed to generate\n** temporary filenames for TEMP tables and other internal uses.  The\n** argument should be a char** which will be filled with the filename\n** written into memory obtained from [sqlite3_malloc()].  The caller should\n** invoke [sqlite3_free()] on the result to avoid a memory leak.\n**\n** <li>[[SQLITE_FCNTL_MMAP_SIZE]]\n** The [SQLITE_FCNTL_MMAP_SIZE] file control is used to query or set the\n** maximum number of bytes that will be used for memory-mapped I/O.\n** The argument is a pointer to a value of type sqlite3_int64 that\n** is an advisory maximum number of bytes in the file to memory map.  The\n** pointer is overwritten with the old value.  The limit is not changed if\n** the value originally pointed to is negative, and so the current limit\n** can be queried by passing in a pointer to a negative number.  This\n** file-control is used internally to implement [PRAGMA mmap_size].\n**\n** <li>[[SQLITE_FCNTL_TRACE]]\n** The [SQLITE_FCNTL_TRACE] file control provides advisory information\n** to the VFS about what the higher layers of the SQLite stack are doing.\n** This file control is used by some VFS activity tracing [shims].\n** The argument is a zero-terminated string.  Higher layers in the\n** SQLite stack may generate instances of this file control if\n** the [SQLITE_USE_FCNTL_TRACE] compile-time option is enabled.\n**\n** <li>[[SQLITE_FCNTL_HAS_MOVED]]\n** The [SQLITE_FCNTL_HAS_MOVED] file control interprets its argument as a\n** pointer to an integer and it writes a boolean into that integer depending\n** on whether or not the file has been renamed, moved, or deleted since it\n** was first opened.\n**\n** <li>[[SQLITE_FCNTL_WIN32_GET_HANDLE]]\n** The [SQLITE_FCNTL_WIN32_GET_HANDLE] opcode can be used to obtain the\n** underlying native file handle associated with a file handle.  This file\n** control interprets its argument as a pointer to a native file handle and\n** writes the resulting value there.\n**\n** <li>[[SQLITE_FCNTL_WIN32_SET_HANDLE]]\n** The [SQLITE_FCNTL_WIN32_SET_HANDLE] opcode is used for debugging.  This\n** opcode causes the xFileControl method to swap the file handle with the one\n** pointed to by the pArg argument.  This capability is used during testing\n** and only needs to be supported when SQLITE_TEST is defined.\n**\n** <li>[[SQLITE_FCNTL_WAL_BLOCK]]\n** The [SQLITE_FCNTL_WAL_BLOCK] is a signal to the VFS layer that it might\n** be advantageous to block on the next WAL lock if the lock is not immediately\n** available.  The WAL subsystem issues this signal during rare\n** circumstances in order to fix a problem with priority inversion.\n** Applications should <em>not</em> use this file-control.\n**\n** <li>[[SQLITE_FCNTL_ZIPVFS]]\n** The [SQLITE_FCNTL_ZIPVFS] opcode is implemented by zipvfs only. All other\n** VFS should return SQLITE_NOTFOUND for this opcode.\n**\n** <li>[[SQLITE_FCNTL_RBU]]\n** The [SQLITE_FCNTL_RBU] opcode is implemented by the special VFS used by\n** the RBU extension only.  All other VFS should return SQLITE_NOTFOUND for\n** this opcode.\n**\n** <li>[[SQLITE_FCNTL_BEGIN_ATOMIC_WRITE]]\n** If the [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE] opcode returns SQLITE_OK, then\n** the file descriptor is placed in \"batch write mode\", which\n** means all subsequent write operations will be deferred and done\n** atomically at the next [SQLITE_FCNTL_COMMIT_ATOMIC_WRITE].  Systems\n** that do not support batch atomic writes will return SQLITE_NOTFOUND.\n** ^Following a successful SQLITE_FCNTL_BEGIN_ATOMIC_WRITE and prior to\n** the closing [SQLITE_FCNTL_COMMIT_ATOMIC_WRITE] or\n** [SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE], SQLite will make\n** no VFS interface calls on the same [sqlite3_file] file descriptor\n** except for calls to the xWrite method and the xFileControl method\n** with [SQLITE_FCNTL_SIZE_HINT].\n**\n** <li>[[SQLITE_FCNTL_COMMIT_ATOMIC_WRITE]]\n** The [SQLITE_FCNTL_COMMIT_ATOMIC_WRITE] opcode causes all write\n** operations since the previous successful call to\n** [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE] to be performed atomically.\n** This file control returns [SQLITE_OK] if and only if the writes were\n** all performed successfully and have been committed to persistent storage.\n** ^Regardless of whether or not it is successful, this file control takes\n** the file descriptor out of batch write mode so that all subsequent\n** write operations are independent.\n** ^SQLite will never invoke SQLITE_FCNTL_COMMIT_ATOMIC_WRITE without\n** a prior successful call to [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE].\n**\n** <li>[[SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE]]\n** The [SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE] opcode causes all write\n** operations since the previous successful call to\n** [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE] to be rolled back.\n** ^This file control takes the file descriptor out of batch write mode\n** so that all subsequent write operations are independent.\n** ^SQLite will never invoke SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE without\n** a prior successful call to [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE].\n**\n** <li>[[SQLITE_FCNTL_LOCK_TIMEOUT]]\n** The [SQLITE_FCNTL_LOCK_TIMEOUT] opcode is used to configure a VFS\n** to block for up to M milliseconds before failing when attempting to\n** obtain a file lock using the xLock or xShmLock methods of the VFS.\n** The parameter is a pointer to a 32-bit signed integer that contains\n** the value that M is to be set to. Before returning, the 32-bit signed\n** integer is overwritten with the previous value of M.\n**\n** <li>[[SQLITE_FCNTL_DATA_VERSION]]\n** The [SQLITE_FCNTL_DATA_VERSION] opcode is used to detect changes to\n** a database file.  The argument is a pointer to a 32-bit unsigned integer.\n** The \"data version\" for the pager is written into the pointer.  The\n** \"data version\" changes whenever any change occurs to the corresponding\n** database file, either through SQL statements on the same database\n** connection or through transactions committed by separate database\n** connections possibly in other processes. The [sqlite3_total_changes()]\n** interface can be used to find if any database on the connection has changed,\n** but that interface responds to changes on TEMP as well as MAIN and does\n** not provide a mechanism to detect changes to MAIN only.  Also, the\n** [sqlite3_total_changes()] interface responds to internal changes only and\n** omits changes made by other database connections.  The\n** [PRAGMA data_version] command provides a mechanism to detect changes to\n** a single attached database that occur due to other database connections,\n** but omits changes implemented by the database connection on which it is\n** called.  This file control is the only mechanism to detect changes that\n** happen either internally or externally and that are associated with\n** a particular attached database.\n**\n** <li>[[SQLITE_FCNTL_CKPT_START]]\n** The [SQLITE_FCNTL_CKPT_START] opcode is invoked from within a checkpoint\n** in wal mode before the client starts to copy pages from the wal\n** file to the database file.\n**\n** <li>[[SQLITE_FCNTL_CKPT_DONE]]\n** The [SQLITE_FCNTL_CKPT_DONE] opcode is invoked from within a checkpoint\n** in wal mode after the client has finished copying pages from the wal\n** file to the database file, but before the *-shm file is updated to\n** record the fact that the pages have been checkpointed.\n**\n** <li>[[SQLITE_FCNTL_EXTERNAL_READER]]\n** The EXPERIMENTAL [SQLITE_FCNTL_EXTERNAL_READER] opcode is used to detect\n** whether or not there is a database client in another process with a wal-mode\n** transaction open on the database or not. It is only available on unix.The\n** (void*) argument passed with this file-control should be a pointer to a\n** value of type (int). The integer value is set to 1 if the database is a wal\n** mode database and there exists at least one client in another process that\n** currently has an SQL transaction open on the database. It is set to 0 if\n** the database is not a wal-mode db, or if there is no such connection in any\n** other process. This opcode cannot be used to detect transactions opened\n** by clients within the current process, only within other processes.\n**\n** <li>[[SQLITE_FCNTL_CKSM_FILE]]\n** The [SQLITE_FCNTL_CKSM_FILE] opcode is for use internally by the\n** [checksum VFS shim] only.\n**\n** <li>[[SQLITE_FCNTL_RESET_CACHE]]\n** If there is currently no transaction open on the database, and the\n** database is not a temp db, then the [SQLITE_FCNTL_RESET_CACHE] file-control\n** purges the contents of the in-memory page cache. If there is an open\n** transaction, or if the db is a temp-db, this opcode is a no-op, not an error.\n** </ul>\n*/\n#define SQLITE_FCNTL_LOCKSTATE               1\n#define SQLITE_FCNTL_GET_LOCKPROXYFILE       2\n#define SQLITE_FCNTL_SET_LOCKPROXYFILE       3\n#define SQLITE_FCNTL_LAST_ERRNO              4\n#define SQLITE_FCNTL_SIZE_HINT               5\n#define SQLITE_FCNTL_CHUNK_SIZE              6\n#define SQLITE_FCNTL_FILE_POINTER            7\n#define SQLITE_FCNTL_SYNC_OMITTED            8\n#define SQLITE_FCNTL_WIN32_AV_RETRY          9\n#define SQLITE_FCNTL_PERSIST_WAL            10\n#define SQLITE_FCNTL_OVERWRITE              11\n#define SQLITE_FCNTL_VFSNAME                12\n#define SQLITE_FCNTL_POWERSAFE_OVERWRITE    13\n#define SQLITE_FCNTL_PRAGMA                 14\n#define SQLITE_FCNTL_BUSYHANDLER            15\n#define SQLITE_FCNTL_TEMPFILENAME           16\n#define SQLITE_FCNTL_MMAP_SIZE              18\n#define SQLITE_FCNTL_TRACE                  19\n#define SQLITE_FCNTL_HAS_MOVED              20\n#define SQLITE_FCNTL_SYNC                   21\n#define SQLITE_FCNTL_COMMIT_PHASETWO        22\n#define SQLITE_FCNTL_WIN32_SET_HANDLE       23\n#define SQLITE_FCNTL_WAL_BLOCK              24\n#define SQLITE_FCNTL_ZIPVFS                 25\n#define SQLITE_FCNTL_RBU                    26\n#define SQLITE_FCNTL_VFS_POINTER            27\n#define SQLITE_FCNTL_JOURNAL_POINTER        28\n#define SQLITE_FCNTL_WIN32_GET_HANDLE       29\n#define SQLITE_FCNTL_PDB                    30\n#define SQLITE_FCNTL_BEGIN_ATOMIC_WRITE     31\n#define SQLITE_FCNTL_COMMIT_ATOMIC_WRITE    32\n#define SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE  33\n#define SQLITE_FCNTL_LOCK_TIMEOUT           34\n#define SQLITE_FCNTL_DATA_VERSION           35\n#define SQLITE_FCNTL_SIZE_LIMIT             36\n#define SQLITE_FCNTL_CKPT_DONE              37\n#define SQLITE_FCNTL_RESERVE_BYTES          38\n#define SQLITE_FCNTL_CKPT_START             39\n#define SQLITE_FCNTL_EXTERNAL_READER        40\n#define SQLITE_FCNTL_CKSM_FILE              41\n#define SQLITE_FCNTL_RESET_CACHE            42\n\n/* deprecated names */\n#define SQLITE_GET_LOCKPROXYFILE      SQLITE_FCNTL_GET_LOCKPROXYFILE\n#define SQLITE_SET_LOCKPROXYFILE      SQLITE_FCNTL_SET_LOCKPROXYFILE\n#define SQLITE_LAST_ERRNO             SQLITE_FCNTL_LAST_ERRNO\n\n\n/*\n** CAPI3REF: Mutex Handle\n**\n** The mutex module within SQLite defines [sqlite3_mutex] to be an\n** abstract type for a mutex object.  The SQLite core never looks\n** at the internal representation of an [sqlite3_mutex].  It only\n** deals with pointers to the [sqlite3_mutex] object.\n**\n** Mutexes are created using [sqlite3_mutex_alloc()].\n*/\ntypedef struct sqlite3_mutex sqlite3_mutex;\n\n/*\n** CAPI3REF: Loadable Extension Thunk\n**\n** A pointer to the opaque sqlite3_api_routines structure is passed as\n** the third parameter to entry points of [loadable extensions].  This\n** structure must be typedefed in order to work around compiler warnings\n** on some platforms.\n*/\ntypedef struct sqlite3_api_routines sqlite3_api_routines;\n\n/*\n** CAPI3REF: File Name\n**\n** Type [sqlite3_filename] is used by SQLite to pass filenames to the\n** xOpen method of a [VFS]. It may be cast to (const char*) and treated\n** as a normal, nul-terminated, UTF-8 buffer containing the filename, but\n** may also be passed to special APIs such as:\n**\n** <ul>\n** <li>  sqlite3_filename_database()\n** <li>  sqlite3_filename_journal()\n** <li>  sqlite3_filename_wal()\n** <li>  sqlite3_uri_parameter()\n** <li>  sqlite3_uri_boolean()\n** <li>  sqlite3_uri_int64()\n** <li>  sqlite3_uri_key()\n** </ul>\n*/\ntypedef const char *sqlite3_filename;\n\n/*\n** CAPI3REF: OS Interface Object\n**\n** An instance of the sqlite3_vfs object defines the interface between\n** the SQLite core and the underlying operating system.  The \"vfs\"\n** in the name of the object stands for \"virtual file system\".  See\n** the [VFS | VFS documentation] for further information.\n**\n** The VFS interface is sometimes extended by adding new methods onto\n** the end.  Each time such an extension occurs, the iVersion field\n** is incremented.  The iVersion value started out as 1 in\n** SQLite [version 3.5.0] on [dateof:3.5.0], then increased to 2\n** with SQLite [version 3.7.0] on [dateof:3.7.0], and then increased\n** to 3 with SQLite [version 3.7.6] on [dateof:3.7.6].  Additional fields\n** may be appended to the sqlite3_vfs object and the iVersion value\n** may increase again in future versions of SQLite.\n** Note that due to an oversight, the structure\n** of the sqlite3_vfs object changed in the transition from\n** SQLite [version 3.5.9] to [version 3.6.0] on [dateof:3.6.0]\n** and yet the iVersion field was not increased.\n**\n** The szOsFile field is the size of the subclassed [sqlite3_file]\n** structure used by this VFS.  mxPathname is the maximum length of\n** a pathname in this VFS.\n**\n** Registered sqlite3_vfs objects are kept on a linked list formed by\n** the pNext pointer.  The [sqlite3_vfs_register()]\n** and [sqlite3_vfs_unregister()] interfaces manage this list\n** in a thread-safe way.  The [sqlite3_vfs_find()] interface\n** searches the list.  Neither the application code nor the VFS\n** implementation should use the pNext pointer.\n**\n** The pNext field is the only field in the sqlite3_vfs\n** structure that SQLite will ever modify.  SQLite will only access\n** or modify this field while holding a particular static mutex.\n** The application should never modify anything within the sqlite3_vfs\n** object once the object has been registered.\n**\n** The zName field holds the name of the VFS module.  The name must\n** be unique across all VFS modules.\n**\n** [[sqlite3_vfs.xOpen]]\n** ^SQLite guarantees that the zFilename parameter to xOpen\n** is either a NULL pointer or string obtained\n** from xFullPathname() with an optional suffix added.\n** ^If a suffix is added to the zFilename parameter, it will\n** consist of a single \"-\" character followed by no more than\n** 11 alphanumeric and/or \"-\" characters.\n** ^SQLite further guarantees that\n** the string will be valid and unchanged until xClose() is\n** called. Because of the previous sentence,\n** the [sqlite3_file] can safely store a pointer to the\n** filename if it needs to remember the filename for some reason.\n** If the zFilename parameter to xOpen is a NULL pointer then xOpen\n** must invent its own temporary name for the file.  ^Whenever the\n** xFilename parameter is NULL it will also be the case that the\n** flags parameter will include [SQLITE_OPEN_DELETEONCLOSE].\n**\n** The flags argument to xOpen() includes all bits set in\n** the flags argument to [sqlite3_open_v2()].  Or if [sqlite3_open()]\n** or [sqlite3_open16()] is used, then flags includes at least\n** [SQLITE_OPEN_READWRITE] | [SQLITE_OPEN_CREATE].\n** If xOpen() opens a file read-only then it sets *pOutFlags to\n** include [SQLITE_OPEN_READONLY].  Other bits in *pOutFlags may be set.\n**\n** ^(SQLite will also add one of the following flags to the xOpen()\n** call, depending on the object being opened:\n**\n** <ul>\n** <li>  [SQLITE_OPEN_MAIN_DB]\n** <li>  [SQLITE_OPEN_MAIN_JOURNAL]\n** <li>  [SQLITE_OPEN_TEMP_DB]\n** <li>  [SQLITE_OPEN_TEMP_JOURNAL]\n** <li>  [SQLITE_OPEN_TRANSIENT_DB]\n** <li>  [SQLITE_OPEN_SUBJOURNAL]\n** <li>  [SQLITE_OPEN_SUPER_JOURNAL]\n** <li>  [SQLITE_OPEN_WAL]\n** </ul>)^\n**\n** The file I/O implementation can use the object type flags to\n** change the way it deals with files.  For example, an application\n** that does not care about crash recovery or rollback might make\n** the open of a journal file a no-op.  Writes to this journal would\n** also be no-ops, and any attempt to read the journal would return\n** SQLITE_IOERR.  Or the implementation might recognize that a database\n** file will be doing page-aligned sector reads and writes in a random\n** order and set up its I/O subsystem accordingly.\n**\n** SQLite might also add one of the following flags to the xOpen method:\n**\n** <ul>\n** <li> [SQLITE_OPEN_DELETEONCLOSE]\n** <li> [SQLITE_OPEN_EXCLUSIVE]\n** </ul>\n**\n** The [SQLITE_OPEN_DELETEONCLOSE] flag means the file should be\n** deleted when it is closed.  ^The [SQLITE_OPEN_DELETEONCLOSE]\n** will be set for TEMP databases and their journals, transient\n** databases, and subjournals.\n**\n** ^The [SQLITE_OPEN_EXCLUSIVE] flag is always used in conjunction\n** with the [SQLITE_OPEN_CREATE] flag, which are both directly\n** analogous to the O_EXCL and O_CREAT flags of the POSIX open()\n** API.  The SQLITE_OPEN_EXCLUSIVE flag, when paired with the\n** SQLITE_OPEN_CREATE, is used to indicate that file should always\n** be created, and that it is an error if it already exists.\n** It is <i>not</i> used to indicate the file should be opened\n** for exclusive access.\n**\n** ^At least szOsFile bytes of memory are allocated by SQLite\n** to hold the [sqlite3_file] structure passed as the third\n** argument to xOpen.  The xOpen method does not have to\n** allocate the structure; it should just fill it in.  Note that\n** the xOpen method must set the sqlite3_file.pMethods to either\n** a valid [sqlite3_io_methods] object or to NULL.  xOpen must do\n** this even if the open fails.  SQLite expects that the sqlite3_file.pMethods\n** element will be valid after xOpen returns regardless of the success\n** or failure of the xOpen call.\n**\n** [[sqlite3_vfs.xAccess]]\n** ^The flags argument to xAccess() may be [SQLITE_ACCESS_EXISTS]\n** to test for the existence of a file, or [SQLITE_ACCESS_READWRITE] to\n** test whether a file is readable and writable, or [SQLITE_ACCESS_READ]\n** to test whether a file is at least readable.  The SQLITE_ACCESS_READ\n** flag is never actually used and is not implemented in the built-in\n** VFSes of SQLite.  The file is named by the second argument and can be a\n** directory. The xAccess method returns [SQLITE_OK] on success or some\n** non-zero error code if there is an I/O error or if the name of\n** the file given in the second argument is illegal.  If SQLITE_OK\n** is returned, then non-zero or zero is written into *pResOut to indicate\n** whether or not the file is accessible.\n**\n** ^SQLite will always allocate at least mxPathname+1 bytes for the\n** output buffer xFullPathname.  The exact size of the output buffer\n** is also passed as a parameter to both  methods. If the output buffer\n** is not large enough, [SQLITE_CANTOPEN] should be returned. Since this is\n** handled as a fatal error by SQLite, vfs implementations should endeavor\n** to prevent this by setting mxPathname to a sufficiently large value.\n**\n** The xRandomness(), xSleep(), xCurrentTime(), and xCurrentTimeInt64()\n** interfaces are not strictly a part of the filesystem, but they are\n** included in the VFS structure for completeness.\n** The xRandomness() function attempts to return nBytes bytes\n** of good-quality randomness into zOut.  The return value is\n** the actual number of bytes of randomness obtained.\n** The xSleep() method causes the calling thread to sleep for at\n** least the number of microseconds given.  ^The xCurrentTime()\n** method returns a Julian Day Number for the current date and time as\n** a floating point value.\n** ^The xCurrentTimeInt64() method returns, as an integer, the Julian\n** Day Number multiplied by 86400000 (the number of milliseconds in\n** a 24-hour day).\n** ^SQLite will use the xCurrentTimeInt64() method to get the current\n** date and time if that method is available (if iVersion is 2 or\n** greater and the function pointer is not NULL) and will fall back\n** to xCurrentTime() if xCurrentTimeInt64() is unavailable.\n**\n** ^The xSetSystemCall(), xGetSystemCall(), and xNestSystemCall() interfaces\n** are not used by the SQLite core.  These optional interfaces are provided\n** by some VFSes to facilitate testing of the VFS code. By overriding\n** system calls with functions under its control, a test program can\n** simulate faults and error conditions that would otherwise be difficult\n** or impossible to induce.  The set of system calls that can be overridden\n** varies from one VFS to another, and from one version of the same VFS to the\n** next.  Applications that use these interfaces must be prepared for any\n** or all of these interfaces to be NULL or for their behavior to change\n** from one release to the next.  Applications must not attempt to access\n** any of these methods if the iVersion of the VFS is less than 3.\n*/\ntypedef struct sqlite3_vfs sqlite3_vfs;\ntypedef void (*sqlite3_syscall_ptr)(void);\nstruct sqlite3_vfs {\n  int iVersion;            /* Structure version number (currently 3) */\n  int szOsFile;            /* Size of subclassed sqlite3_file */\n  int mxPathname;          /* Maximum file pathname length */\n  sqlite3_vfs *pNext;      /* Next registered VFS */\n  const char *zName;       /* Name of this virtual file system */\n  void *pAppData;          /* Pointer to application-specific data */\n  int (*xOpen)(sqlite3_vfs*, sqlite3_filename zName, sqlite3_file*,\n               int flags, int *pOutFlags);\n  int (*xDelete)(sqlite3_vfs*, const char *zName, int syncDir);\n  int (*xAccess)(sqlite3_vfs*, const char *zName, int flags, int *pResOut);\n  int (*xFullPathname)(sqlite3_vfs*, const char *zName, int nOut, char *zOut);\n  void *(*xDlOpen)(sqlite3_vfs*, const char *zFilename);\n  void (*xDlError)(sqlite3_vfs*, int nByte, char *zErrMsg);\n  void (*(*xDlSym)(sqlite3_vfs*,void*, const char *zSymbol))(void);\n  void (*xDlClose)(sqlite3_vfs*, void*);\n  int (*xRandomness)(sqlite3_vfs*, int nByte, char *zOut);\n  int (*xSleep)(sqlite3_vfs*, int microseconds);\n  int (*xCurrentTime)(sqlite3_vfs*, double*);\n  int (*xGetLastError)(sqlite3_vfs*, int, char *);\n  /*\n  ** The methods above are in version 1 of the sqlite_vfs object\n  ** definition.  Those that follow are added in version 2 or later\n  */\n  int (*xCurrentTimeInt64)(sqlite3_vfs*, sqlite3_int64*);\n  /*\n  ** The methods above are in versions 1 and 2 of the sqlite_vfs object.\n  ** Those below are for version 3 and greater.\n  */\n  int (*xSetSystemCall)(sqlite3_vfs*, const char *zName, sqlite3_syscall_ptr);\n  sqlite3_syscall_ptr (*xGetSystemCall)(sqlite3_vfs*, const char *zName);\n  const char *(*xNextSystemCall)(sqlite3_vfs*, const char *zName);\n  /*\n  ** The methods above are in versions 1 through 3 of the sqlite_vfs object.\n  ** New fields may be appended in future versions.  The iVersion\n  ** value will increment whenever this happens.\n  */\n};\n\n/*\n** CAPI3REF: Flags for the xAccess VFS method\n**\n** These integer constants can be used as the third parameter to\n** the xAccess method of an [sqlite3_vfs] object.  They determine\n** what kind of permissions the xAccess method is looking for.\n** With SQLITE_ACCESS_EXISTS, the xAccess method\n** simply checks whether the file exists.\n** With SQLITE_ACCESS_READWRITE, the xAccess method\n** checks whether the named directory is both readable and writable\n** (in other words, if files can be added, removed, and renamed within\n** the directory).\n** The SQLITE_ACCESS_READWRITE constant is currently used only by the\n** [temp_store_directory pragma], though this could change in a future\n** release of SQLite.\n** With SQLITE_ACCESS_READ, the xAccess method\n** checks whether the file is readable.  The SQLITE_ACCESS_READ constant is\n** currently unused, though it might be used in a future release of\n** SQLite.\n*/\n#define SQLITE_ACCESS_EXISTS    0\n#define SQLITE_ACCESS_READWRITE 1   /* Used by PRAGMA temp_store_directory */\n#define SQLITE_ACCESS_READ      2   /* Unused */\n\n/*\n** CAPI3REF: Flags for the xShmLock VFS method\n**\n** These integer constants define the various locking operations\n** allowed by the xShmLock method of [sqlite3_io_methods].  The\n** following are the only legal combinations of flags to the\n** xShmLock method:\n**\n** <ul>\n** <li>  SQLITE_SHM_LOCK | SQLITE_SHM_SHARED\n** <li>  SQLITE_SHM_LOCK | SQLITE_SHM_EXCLUSIVE\n** <li>  SQLITE_SHM_UNLOCK | SQLITE_SHM_SHARED\n** <li>  SQLITE_SHM_UNLOCK | SQLITE_SHM_EXCLUSIVE\n** </ul>\n**\n** When unlocking, the same SHARED or EXCLUSIVE flag must be supplied as\n** was given on the corresponding lock.\n**\n** The xShmLock method can transition between unlocked and SHARED or\n** between unlocked and EXCLUSIVE.  It cannot transition between SHARED\n** and EXCLUSIVE.\n*/\n#define SQLITE_SHM_UNLOCK       1\n#define SQLITE_SHM_LOCK         2\n#define SQLITE_SHM_SHARED       4\n#define SQLITE_SHM_EXCLUSIVE    8\n\n/*\n** CAPI3REF: Maximum xShmLock index\n**\n** The xShmLock method on [sqlite3_io_methods] may use values\n** between 0 and this upper bound as its \"offset\" argument.\n** The SQLite core will never attempt to acquire or release a\n** lock outside of this range\n*/\n#define SQLITE_SHM_NLOCK        8\n\n\n/*\n** CAPI3REF: Initialize The SQLite Library\n**\n** ^The sqlite3_initialize() routine initializes the\n** SQLite library.  ^The sqlite3_shutdown() routine\n** deallocates any resources that were allocated by sqlite3_initialize().\n** These routines are designed to aid in process initialization and\n** shutdown on embedded systems.  Workstation applications using\n** SQLite normally do not need to invoke either of these routines.\n**\n** A call to sqlite3_initialize() is an \"effective\" call if it is\n** the first time sqlite3_initialize() is invoked during the lifetime of\n** the process, or if it is the first time sqlite3_initialize() is invoked\n** following a call to sqlite3_shutdown().  ^(Only an effective call\n** of sqlite3_initialize() does any initialization.  All other calls\n** are harmless no-ops.)^\n**\n** A call to sqlite3_shutdown() is an \"effective\" call if it is the first\n** call to sqlite3_shutdown() since the last sqlite3_initialize().  ^(Only\n** an effective call to sqlite3_shutdown() does any deinitialization.\n** All other valid calls to sqlite3_shutdown() are harmless no-ops.)^\n**\n** The sqlite3_initialize() interface is threadsafe, but sqlite3_shutdown()\n** is not.  The sqlite3_shutdown() interface must only be called from a\n** single thread.  All open [database connections] must be closed and all\n** other SQLite resources must be deallocated prior to invoking\n** sqlite3_shutdown().\n**\n** Among other things, ^sqlite3_initialize() will invoke\n** sqlite3_os_init().  Similarly, ^sqlite3_shutdown()\n** will invoke sqlite3_os_end().\n**\n** ^The sqlite3_initialize() routine returns [SQLITE_OK] on success.\n** ^If for some reason, sqlite3_initialize() is unable to initialize\n** the library (perhaps it is unable to allocate a needed resource such\n** as a mutex) it returns an [error code] other than [SQLITE_OK].\n**\n** ^The sqlite3_initialize() routine is called internally by many other\n** SQLite interfaces so that an application usually does not need to\n** invoke sqlite3_initialize() directly.  For example, [sqlite3_open()]\n** calls sqlite3_initialize() so the SQLite library will be automatically\n** initialized when [sqlite3_open()] is called if it has not be initialized\n** already.  ^However, if SQLite is compiled with the [SQLITE_OMIT_AUTOINIT]\n** compile-time option, then the automatic calls to sqlite3_initialize()\n** are omitted and the application must call sqlite3_initialize() directly\n** prior to using any other SQLite interface.  For maximum portability,\n** it is recommended that applications always invoke sqlite3_initialize()\n** directly prior to using any other SQLite interface.  Future releases\n** of SQLite may require this.  In other words, the behavior exhibited\n** when SQLite is compiled with [SQLITE_OMIT_AUTOINIT] might become the\n** default behavior in some future release of SQLite.\n**\n** The sqlite3_os_init() routine does operating-system specific\n** initialization of the SQLite library.  The sqlite3_os_end()\n** routine undoes the effect of sqlite3_os_init().  Typical tasks\n** performed by these routines include allocation or deallocation\n** of static resources, initialization of global variables,\n** setting up a default [sqlite3_vfs] module, or setting up\n** a default configuration using [sqlite3_config()].\n**\n** The application should never invoke either sqlite3_os_init()\n** or sqlite3_os_end() directly.  The application should only invoke\n** sqlite3_initialize() and sqlite3_shutdown().  The sqlite3_os_init()\n** interface is called automatically by sqlite3_initialize() and\n** sqlite3_os_end() is called by sqlite3_shutdown().  Appropriate\n** implementations for sqlite3_os_init() and sqlite3_os_end()\n** are built into SQLite when it is compiled for Unix, Windows, or OS/2.\n** When [custom builds | built for other platforms]\n** (using the [SQLITE_OS_OTHER=1] compile-time\n** option) the application must supply a suitable implementation for\n** sqlite3_os_init() and sqlite3_os_end().  An application-supplied\n** implementation of sqlite3_os_init() or sqlite3_os_end()\n** must return [SQLITE_OK] on success and some other [error code] upon\n** failure.\n*/\nSQLITE_API int sqlite3_initialize(void);\nSQLITE_API int sqlite3_shutdown(void);\nSQLITE_API int sqlite3_os_init(void);\nSQLITE_API int sqlite3_os_end(void);\n\n/*\n** CAPI3REF: Configuring The SQLite Library\n**\n** The sqlite3_config() interface is used to make global configuration\n** changes to SQLite in order to tune SQLite to the specific needs of\n** the application.  The default configuration is recommended for most\n** applications and so this routine is usually not necessary.  It is\n** provided to support rare applications with unusual needs.\n**\n** <b>The sqlite3_config() interface is not threadsafe. The application\n** must ensure that no other SQLite interfaces are invoked by other\n** threads while sqlite3_config() is running.</b>\n**\n** The first argument to sqlite3_config() is an integer\n** [configuration option] that determines\n** what property of SQLite is to be configured.  Subsequent arguments\n** vary depending on the [configuration option]\n** in the first argument.\n**\n** For most configuration options, the sqlite3_config() interface\n** may only be invoked prior to library initialization using\n** [sqlite3_initialize()] or after shutdown by [sqlite3_shutdown()].\n** The exceptional configuration options that may be invoked at any time\n** are called \"anytime configuration options\".\n** ^If sqlite3_config() is called after [sqlite3_initialize()] and before\n** [sqlite3_shutdown()] with a first argument that is not an anytime\n** configuration option, then the sqlite3_config() call will return SQLITE_MISUSE.\n** Note, however, that ^sqlite3_config() can be called as part of the\n** implementation of an application-defined [sqlite3_os_init()].\n**\n** ^When a configuration option is set, sqlite3_config() returns [SQLITE_OK].\n** ^If the option is unknown or SQLite is unable to set the option\n** then this routine returns a non-zero [error code].\n*/\nSQLITE_API int sqlite3_config(int, ...);\n\n/*\n** CAPI3REF: Configure database connections\n** METHOD: sqlite3\n**\n** The sqlite3_db_config() interface is used to make configuration\n** changes to a [database connection].  The interface is similar to\n** [sqlite3_config()] except that the changes apply to a single\n** [database connection] (specified in the first argument).\n**\n** The second argument to sqlite3_db_config(D,V,...)  is the\n** [SQLITE_DBCONFIG_LOOKASIDE | configuration verb] - an integer code\n** that indicates what aspect of the [database connection] is being configured.\n** Subsequent arguments vary depending on the configuration verb.\n**\n** ^Calls to sqlite3_db_config() return SQLITE_OK if and only if\n** the call is considered successful.\n*/\nSQLITE_API int sqlite3_db_config(sqlite3*, int op, ...);\n\n/*\n** CAPI3REF: Memory Allocation Routines\n**\n** An instance of this object defines the interface between SQLite\n** and low-level memory allocation routines.\n**\n** This object is used in only one place in the SQLite interface.\n** A pointer to an instance of this object is the argument to\n** [sqlite3_config()] when the configuration option is\n** [SQLITE_CONFIG_MALLOC] or [SQLITE_CONFIG_GETMALLOC].\n** By creating an instance of this object\n** and passing it to [sqlite3_config]([SQLITE_CONFIG_MALLOC])\n** during configuration, an application can specify an alternative\n** memory allocation subsystem for SQLite to use for all of its\n** dynamic memory needs.\n**\n** Note that SQLite comes with several [built-in memory allocators]\n** that are perfectly adequate for the overwhelming majority of applications\n** and that this object is only useful to a tiny minority of applications\n** with specialized memory allocation requirements.  This object is\n** also used during testing of SQLite in order to specify an alternative\n** memory allocator that simulates memory out-of-memory conditions in\n** order to verify that SQLite recovers gracefully from such\n** conditions.\n**\n** The xMalloc, xRealloc, and xFree methods must work like the\n** malloc(), realloc() and free() functions from the standard C library.\n** ^SQLite guarantees that the second argument to\n** xRealloc is always a value returned by a prior call to xRoundup.\n**\n** xSize should return the allocated size of a memory allocation\n** previously obtained from xMalloc or xRealloc.  The allocated size\n** is always at least as big as the requested size but may be larger.\n**\n** The xRoundup method returns what would be the allocated size of\n** a memory allocation given a particular requested size.  Most memory\n** allocators round up memory allocations at least to the next multiple\n** of 8.  Some allocators round up to a larger multiple or to a power of 2.\n** Every memory allocation request coming in through [sqlite3_malloc()]\n** or [sqlite3_realloc()] first calls xRoundup.  If xRoundup returns 0,\n** that causes the corresponding memory allocation to fail.\n**\n** The xInit method initializes the memory allocator.  For example,\n** it might allocate any required mutexes or initialize internal data\n** structures.  The xShutdown method is invoked (indirectly) by\n** [sqlite3_shutdown()] and should deallocate any resources acquired\n** by xInit.  The pAppData pointer is used as the only parameter to\n** xInit and xShutdown.\n**\n** SQLite holds the [SQLITE_MUTEX_STATIC_MAIN] mutex when it invokes\n** the xInit method, so the xInit method need not be threadsafe.  The\n** xShutdown method is only called from [sqlite3_shutdown()] so it does\n** not need to be threadsafe either.  For all other methods, SQLite\n** holds the [SQLITE_MUTEX_STATIC_MEM] mutex as long as the\n** [SQLITE_CONFIG_MEMSTATUS] configuration option is turned on (which\n** it is by default) and so the methods are automatically serialized.\n** However, if [SQLITE_CONFIG_MEMSTATUS] is disabled, then the other\n** methods must be threadsafe or else make their own arrangements for\n** serialization.\n**\n** SQLite will never invoke xInit() more than once without an intervening\n** call to xShutdown().\n*/\ntypedef struct sqlite3_mem_methods sqlite3_mem_methods;\nstruct sqlite3_mem_methods {\n  void *(*xMalloc)(int);         /* Memory allocation function */\n  void (*xFree)(void*);          /* Free a prior allocation */\n  void *(*xRealloc)(void*,int);  /* Resize an allocation */\n  int (*xSize)(void*);           /* Return the size of an allocation */\n  int (*xRoundup)(int);          /* Round up request size to allocation size */\n  int (*xInit)(void*);           /* Initialize the memory allocator */\n  void (*xShutdown)(void*);      /* Deinitialize the memory allocator */\n  void *pAppData;                /* Argument to xInit() and xShutdown() */\n};\n\n/*\n** CAPI3REF: Configuration Options\n** KEYWORDS: {configuration option}\n**\n** These constants are the available integer configuration options that\n** can be passed as the first argument to the [sqlite3_config()] interface.\n**\n** Most of the configuration options for sqlite3_config()\n** will only work if invoked prior to [sqlite3_initialize()] or after\n** [sqlite3_shutdown()].  The few exceptions to this rule are called\n** \"anytime configuration options\".\n** ^Calling [sqlite3_config()] with a first argument that is not an\n** anytime configuration option in between calls to [sqlite3_initialize()] and\n** [sqlite3_shutdown()] is a no-op that returns SQLITE_MISUSE.\n**\n** The set of anytime configuration options can change (by insertions\n** and/or deletions) from one release of SQLite to the next.\n** As of SQLite version 3.42.0, the complete set of anytime configuration\n** options is:\n** <ul>\n** <li> SQLITE_CONFIG_LOG\n** <li> SQLITE_CONFIG_PCACHE_HDRSZ\n** </ul>\n**\n** New configuration options may be added in future releases of SQLite.\n** Existing configuration options might be discontinued.  Applications\n** should check the return code from [sqlite3_config()] to make sure that\n** the call worked.  The [sqlite3_config()] interface will return a\n** non-zero [error code] if a discontinued or unsupported configuration option\n** is invoked.\n**\n** <dl>\n** [[SQLITE_CONFIG_SINGLETHREAD]] <dt>SQLITE_CONFIG_SINGLETHREAD</dt>\n** <dd>There are no arguments to this option.  ^This option sets the\n** [threading mode] to Single-thread.  In other words, it disables\n** all mutexing and puts SQLite into a mode where it can only be used\n** by a single thread.   ^If SQLite is compiled with\n** the [SQLITE_THREADSAFE | SQLITE_THREADSAFE=0] compile-time option then\n** it is not possible to change the [threading mode] from its default\n** value of Single-thread and so [sqlite3_config()] will return\n** [SQLITE_ERROR] if called with the SQLITE_CONFIG_SINGLETHREAD\n** configuration option.</dd>\n**\n** [[SQLITE_CONFIG_MULTITHREAD]] <dt>SQLITE_CONFIG_MULTITHREAD</dt>\n** <dd>There are no arguments to this option.  ^This option sets the\n** [threading mode] to Multi-thread.  In other words, it disables\n** mutexing on [database connection] and [prepared statement] objects.\n** The application is responsible for serializing access to\n** [database connections] and [prepared statements].  But other mutexes\n** are enabled so that SQLite will be safe to use in a multi-threaded\n** environment as long as no two threads attempt to use the same\n** [database connection] at the same time.  ^If SQLite is compiled with\n** the [SQLITE_THREADSAFE | SQLITE_THREADSAFE=0] compile-time option then\n** it is not possible to set the Multi-thread [threading mode] and\n** [sqlite3_config()] will return [SQLITE_ERROR] if called with the\n** SQLITE_CONFIG_MULTITHREAD configuration option.</dd>\n**\n** [[SQLITE_CONFIG_SERIALIZED]] <dt>SQLITE_CONFIG_SERIALIZED</dt>\n** <dd>There are no arguments to this option.  ^This option sets the\n** [threading mode] to Serialized. In other words, this option enables\n** all mutexes including the recursive\n** mutexes on [database connection] and [prepared statement] objects.\n** In this mode (which is the default when SQLite is compiled with\n** [SQLITE_THREADSAFE=1]) the SQLite library will itself serialize access\n** to [database connections] and [prepared statements] so that the\n** application is free to use the same [database connection] or the\n** same [prepared statement] in different threads at the same time.\n** ^If SQLite is compiled with\n** the [SQLITE_THREADSAFE | SQLITE_THREADSAFE=0] compile-time option then\n** it is not possible to set the Serialized [threading mode] and\n** [sqlite3_config()] will return [SQLITE_ERROR] if called with the\n** SQLITE_CONFIG_SERIALIZED configuration option.</dd>\n**\n** [[SQLITE_CONFIG_MALLOC]] <dt>SQLITE_CONFIG_MALLOC</dt>\n** <dd> ^(The SQLITE_CONFIG_MALLOC option takes a single argument which is\n** a pointer to an instance of the [sqlite3_mem_methods] structure.\n** The argument specifies\n** alternative low-level memory allocation routines to be used in place of\n** the memory allocation routines built into SQLite.)^ ^SQLite makes\n** its own private copy of the content of the [sqlite3_mem_methods] structure\n** before the [sqlite3_config()] call returns.</dd>\n**\n** [[SQLITE_CONFIG_GETMALLOC]] <dt>SQLITE_CONFIG_GETMALLOC</dt>\n** <dd> ^(The SQLITE_CONFIG_GETMALLOC option takes a single argument which\n** is a pointer to an instance of the [sqlite3_mem_methods] structure.\n** The [sqlite3_mem_methods]\n** structure is filled with the currently defined memory allocation routines.)^\n** This option can be used to overload the default memory allocation\n** routines with a wrapper that simulations memory allocation failure or\n** tracks memory usage, for example. </dd>\n**\n** [[SQLITE_CONFIG_SMALL_MALLOC]] <dt>SQLITE_CONFIG_SMALL_MALLOC</dt>\n** <dd> ^The SQLITE_CONFIG_SMALL_MALLOC option takes single argument of\n** type int, interpreted as a boolean, which if true provides a hint to\n** SQLite that it should avoid large memory allocations if possible.\n** SQLite will run faster if it is free to make large memory allocations,\n** but some application might prefer to run slower in exchange for\n** guarantees about memory fragmentation that are possible if large\n** allocations are avoided.  This hint is normally off.\n** </dd>\n**\n** [[SQLITE_CONFIG_MEMSTATUS]] <dt>SQLITE_CONFIG_MEMSTATUS</dt>\n** <dd> ^The SQLITE_CONFIG_MEMSTATUS option takes single argument of type int,\n** interpreted as a boolean, which enables or disables the collection of\n** memory allocation statistics. ^(When memory allocation statistics are\n** disabled, the following SQLite interfaces become non-operational:\n**   <ul>\n**   <li> [sqlite3_hard_heap_limit64()]\n**   <li> [sqlite3_memory_used()]\n**   <li> [sqlite3_memory_highwater()]\n**   <li> [sqlite3_soft_heap_limit64()]\n**   <li> [sqlite3_status64()]\n**   </ul>)^\n** ^Memory allocation statistics are enabled by default unless SQLite is\n** compiled with [SQLITE_DEFAULT_MEMSTATUS]=0 in which case memory\n** allocation statistics are disabled by default.\n** </dd>\n**\n** [[SQLITE_CONFIG_SCRATCH]] <dt>SQLITE_CONFIG_SCRATCH</dt>\n** <dd> The SQLITE_CONFIG_SCRATCH option is no longer used.\n** </dd>\n**\n** [[SQLITE_CONFIG_PAGECACHE]] <dt>SQLITE_CONFIG_PAGECACHE</dt>\n** <dd> ^The SQLITE_CONFIG_PAGECACHE option specifies a memory pool\n** that SQLite can use for the database page cache with the default page\n** cache implementation.\n** This configuration option is a no-op if an application-defined page\n** cache implementation is loaded using the [SQLITE_CONFIG_PCACHE2].\n** ^There are three arguments to SQLITE_CONFIG_PAGECACHE: A pointer to\n** 8-byte aligned memory (pMem), the size of each page cache line (sz),\n** and the number of cache lines (N).\n** The sz argument should be the size of the largest database page\n** (a power of two between 512 and 65536) plus some extra bytes for each\n** page header.  ^The number of extra bytes needed by the page header\n** can be determined using [SQLITE_CONFIG_PCACHE_HDRSZ].\n** ^It is harmless, apart from the wasted memory,\n** for the sz parameter to be larger than necessary.  The pMem\n** argument must be either a NULL pointer or a pointer to an 8-byte\n** aligned block of memory of at least sz*N bytes, otherwise\n** subsequent behavior is undefined.\n** ^When pMem is not NULL, SQLite will strive to use the memory provided\n** to satisfy page cache needs, falling back to [sqlite3_malloc()] if\n** a page cache line is larger than sz bytes or if all of the pMem buffer\n** is exhausted.\n** ^If pMem is NULL and N is non-zero, then each database connection\n** does an initial bulk allocation for page cache memory\n** from [sqlite3_malloc()] sufficient for N cache lines if N is positive or\n** of -1024*N bytes if N is negative, . ^If additional\n** page cache memory is needed beyond what is provided by the initial\n** allocation, then SQLite goes to [sqlite3_malloc()] separately for each\n** additional cache line. </dd>\n**\n** [[SQLITE_CONFIG_HEAP]] <dt>SQLITE_CONFIG_HEAP</dt>\n** <dd> ^The SQLITE_CONFIG_HEAP option specifies a static memory buffer\n** that SQLite will use for all of its dynamic memory allocation needs\n** beyond those provided for by [SQLITE_CONFIG_PAGECACHE].\n** ^The SQLITE_CONFIG_HEAP option is only available if SQLite is compiled\n** with either [SQLITE_ENABLE_MEMSYS3] or [SQLITE_ENABLE_MEMSYS5] and returns\n** [SQLITE_ERROR] if invoked otherwise.\n** ^There are three arguments to SQLITE_CONFIG_HEAP:\n** An 8-byte aligned pointer to the memory,\n** the number of bytes in the memory buffer, and the minimum allocation size.\n** ^If the first pointer (the memory pointer) is NULL, then SQLite reverts\n** to using its default memory allocator (the system malloc() implementation),\n** undoing any prior invocation of [SQLITE_CONFIG_MALLOC].  ^If the\n** memory pointer is not NULL then the alternative memory\n** allocator is engaged to handle all of SQLites memory allocation needs.\n** The first pointer (the memory pointer) must be aligned to an 8-byte\n** boundary or subsequent behavior of SQLite will be undefined.\n** The minimum allocation size is capped at 2**12. Reasonable values\n** for the minimum allocation size are 2**5 through 2**8.</dd>\n**\n** [[SQLITE_CONFIG_MUTEX]] <dt>SQLITE_CONFIG_MUTEX</dt>\n** <dd> ^(The SQLITE_CONFIG_MUTEX option takes a single argument which is a\n** pointer to an instance of the [sqlite3_mutex_methods] structure.\n** The argument specifies alternative low-level mutex routines to be used\n** in place the mutex routines built into SQLite.)^  ^SQLite makes a copy of\n** the content of the [sqlite3_mutex_methods] structure before the call to\n** [sqlite3_config()] returns. ^If SQLite is compiled with\n** the [SQLITE_THREADSAFE | SQLITE_THREADSAFE=0] compile-time option then\n** the entire mutexing subsystem is omitted from the build and hence calls to\n** [sqlite3_config()] with the SQLITE_CONFIG_MUTEX configuration option will\n** return [SQLITE_ERROR].</dd>\n**\n** [[SQLITE_CONFIG_GETMUTEX]] <dt>SQLITE_CONFIG_GETMUTEX</dt>\n** <dd> ^(The SQLITE_CONFIG_GETMUTEX option takes a single argument which\n** is a pointer to an instance of the [sqlite3_mutex_methods] structure.  The\n** [sqlite3_mutex_methods]\n** structure is filled with the currently defined mutex routines.)^\n** This option can be used to overload the default mutex allocation\n** routines with a wrapper used to track mutex usage for performance\n** profiling or testing, for example.   ^If SQLite is compiled with\n** the [SQLITE_THREADSAFE | SQLITE_THREADSAFE=0] compile-time option then\n** the entire mutexing subsystem is omitted from the build and hence calls to\n** [sqlite3_config()] with the SQLITE_CONFIG_GETMUTEX configuration option will\n** return [SQLITE_ERROR].</dd>\n**\n** [[SQLITE_CONFIG_LOOKASIDE]] <dt>SQLITE_CONFIG_LOOKASIDE</dt>\n** <dd> ^(The SQLITE_CONFIG_LOOKASIDE option takes two arguments that determine\n** the default size of lookaside memory on each [database connection].\n** The first argument is the\n** size of each lookaside buffer slot and the second is the number of\n** slots allocated to each database connection.)^  ^(SQLITE_CONFIG_LOOKASIDE\n** sets the <i>default</i> lookaside size. The [SQLITE_DBCONFIG_LOOKASIDE]\n** option to [sqlite3_db_config()] can be used to change the lookaside\n** configuration on individual connections.)^ </dd>\n**\n** [[SQLITE_CONFIG_PCACHE2]] <dt>SQLITE_CONFIG_PCACHE2</dt>\n** <dd> ^(The SQLITE_CONFIG_PCACHE2 option takes a single argument which is\n** a pointer to an [sqlite3_pcache_methods2] object.  This object specifies\n** the interface to a custom page cache implementation.)^\n** ^SQLite makes a copy of the [sqlite3_pcache_methods2] object.</dd>\n**\n** [[SQLITE_CONFIG_GETPCACHE2]] <dt>SQLITE_CONFIG_GETPCACHE2</dt>\n** <dd> ^(The SQLITE_CONFIG_GETPCACHE2 option takes a single argument which\n** is a pointer to an [sqlite3_pcache_methods2] object.  SQLite copies of\n** the current page cache implementation into that object.)^ </dd>\n**\n** [[SQLITE_CONFIG_LOG]] <dt>SQLITE_CONFIG_LOG</dt>\n** <dd> The SQLITE_CONFIG_LOG option is used to configure the SQLite\n** global [error log].\n** (^The SQLITE_CONFIG_LOG option takes two arguments: a pointer to a\n** function with a call signature of void(*)(void*,int,const char*),\n** and a pointer to void. ^If the function pointer is not NULL, it is\n** invoked by [sqlite3_log()] to process each logging event.  ^If the\n** function pointer is NULL, the [sqlite3_log()] interface becomes a no-op.\n** ^The void pointer that is the second argument to SQLITE_CONFIG_LOG is\n** passed through as the first parameter to the application-defined logger\n** function whenever that function is invoked.  ^The second parameter to\n** the logger function is a copy of the first parameter to the corresponding\n** [sqlite3_log()] call and is intended to be a [result code] or an\n** [extended result code].  ^The third parameter passed to the logger is\n** log message after formatting via [sqlite3_snprintf()].\n** The SQLite logging interface is not reentrant; the logger function\n** supplied by the application must not invoke any SQLite interface.\n** In a multi-threaded application, the application-defined logger\n** function must be threadsafe. </dd>\n**\n** [[SQLITE_CONFIG_URI]] <dt>SQLITE_CONFIG_URI\n** <dd>^(The SQLITE_CONFIG_URI option takes a single argument of type int.\n** If non-zero, then URI handling is globally enabled. If the parameter is zero,\n** then URI handling is globally disabled.)^ ^If URI handling is globally\n** enabled, all filenames passed to [sqlite3_open()], [sqlite3_open_v2()],\n** [sqlite3_open16()] or\n** specified as part of [ATTACH] commands are interpreted as URIs, regardless\n** of whether or not the [SQLITE_OPEN_URI] flag is set when the database\n** connection is opened. ^If it is globally disabled, filenames are\n** only interpreted as URIs if the SQLITE_OPEN_URI flag is set when the\n** database connection is opened. ^(By default, URI handling is globally\n** disabled. The default value may be changed by compiling with the\n** [SQLITE_USE_URI] symbol defined.)^\n**\n** [[SQLITE_CONFIG_COVERING_INDEX_SCAN]] <dt>SQLITE_CONFIG_COVERING_INDEX_SCAN\n** <dd>^The SQLITE_CONFIG_COVERING_INDEX_SCAN option takes a single integer\n** argument which is interpreted as a boolean in order to enable or disable\n** the use of covering indices for full table scans in the query optimizer.\n** ^The default setting is determined\n** by the [SQLITE_ALLOW_COVERING_INDEX_SCAN] compile-time option, or is \"on\"\n** if that compile-time option is omitted.\n** The ability to disable the use of covering indices for full table scans\n** is because some incorrectly coded legacy applications might malfunction\n** when the optimization is enabled.  Providing the ability to\n** disable the optimization allows the older, buggy application code to work\n** without change even with newer versions of SQLite.\n**\n** [[SQLITE_CONFIG_PCACHE]] [[SQLITE_CONFIG_GETPCACHE]]\n** <dt>SQLITE_CONFIG_PCACHE and SQLITE_CONFIG_GETPCACHE\n** <dd> These options are obsolete and should not be used by new code.\n** They are retained for backwards compatibility but are now no-ops.\n** </dd>\n**\n** [[SQLITE_CONFIG_SQLLOG]]\n** <dt>SQLITE_CONFIG_SQLLOG\n** <dd>This option is only available if sqlite is compiled with the\n** [SQLITE_ENABLE_SQLLOG] pre-processor macro defined. The first argument should\n** be a pointer to a function of type void(*)(void*,sqlite3*,const char*, int).\n** The second should be of type (void*). The callback is invoked by the library\n** in three separate circumstances, identified by the value passed as the\n** fourth parameter. If the fourth parameter is 0, then the database connection\n** passed as the second argument has just been opened. The third argument\n** points to a buffer containing the name of the main database file. If the\n** fourth parameter is 1, then the SQL statement that the third parameter\n** points to has just been executed. Or, if the fourth parameter is 2, then\n** the connection being passed as the second parameter is being closed. The\n** third parameter is passed NULL In this case.  An example of using this\n** configuration option can be seen in the \"test_sqllog.c\" source file in\n** the canonical SQLite source tree.</dd>\n**\n** [[SQLITE_CONFIG_MMAP_SIZE]]\n** <dt>SQLITE_CONFIG_MMAP_SIZE\n** <dd>^SQLITE_CONFIG_MMAP_SIZE takes two 64-bit integer (sqlite3_int64) values\n** that are the default mmap size limit (the default setting for\n** [PRAGMA mmap_size]) and the maximum allowed mmap size limit.\n** ^The default setting can be overridden by each database connection using\n** either the [PRAGMA mmap_size] command, or by using the\n** [SQLITE_FCNTL_MMAP_SIZE] file control.  ^(The maximum allowed mmap size\n** will be silently truncated if necessary so that it does not exceed the\n** compile-time maximum mmap size set by the\n** [SQLITE_MAX_MMAP_SIZE] compile-time option.)^\n** ^If either argument to this option is negative, then that argument is\n** changed to its compile-time default.\n**\n** [[SQLITE_CONFIG_WIN32_HEAPSIZE]]\n** <dt>SQLITE_CONFIG_WIN32_HEAPSIZE\n** <dd>^The SQLITE_CONFIG_WIN32_HEAPSIZE option is only available if SQLite is\n** compiled for Windows with the [SQLITE_WIN32_MALLOC] pre-processor macro\n** defined. ^SQLITE_CONFIG_WIN32_HEAPSIZE takes a 32-bit unsigned integer value\n** that specifies the maximum size of the created heap.\n**\n** [[SQLITE_CONFIG_PCACHE_HDRSZ]]\n** <dt>SQLITE_CONFIG_PCACHE_HDRSZ\n** <dd>^The SQLITE_CONFIG_PCACHE_HDRSZ option takes a single parameter which\n** is a pointer to an integer and writes into that integer the number of extra\n** bytes per page required for each page in [SQLITE_CONFIG_PAGECACHE].\n** The amount of extra space required can change depending on the compiler,\n** target platform, and SQLite version.\n**\n** [[SQLITE_CONFIG_PMASZ]]\n** <dt>SQLITE_CONFIG_PMASZ\n** <dd>^The SQLITE_CONFIG_PMASZ option takes a single parameter which\n** is an unsigned integer and sets the \"Minimum PMA Size\" for the multithreaded\n** sorter to that integer.  The default minimum PMA Size is set by the\n** [SQLITE_SORTER_PMASZ] compile-time option.  New threads are launched\n** to help with sort operations when multithreaded sorting\n** is enabled (using the [PRAGMA threads] command) and the amount of content\n** to be sorted exceeds the page size times the minimum of the\n** [PRAGMA cache_size] setting and this value.\n**\n** [[SQLITE_CONFIG_STMTJRNL_SPILL]]\n** <dt>SQLITE_CONFIG_STMTJRNL_SPILL\n** <dd>^The SQLITE_CONFIG_STMTJRNL_SPILL option takes a single parameter which\n** becomes the [statement journal] spill-to-disk threshold.\n** [Statement journals] are held in memory until their size (in bytes)\n** exceeds this threshold, at which point they are written to disk.\n** Or if the threshold is -1, statement journals are always held\n** exclusively in memory.\n** Since many statement journals never become large, setting the spill\n** threshold to a value such as 64KiB can greatly reduce the amount of\n** I/O required to support statement rollback.\n** The default value for this setting is controlled by the\n** [SQLITE_STMTJRNL_SPILL] compile-time option.\n**\n** [[SQLITE_CONFIG_SORTERREF_SIZE]]\n** <dt>SQLITE_CONFIG_SORTERREF_SIZE\n** <dd>The SQLITE_CONFIG_SORTERREF_SIZE option accepts a single parameter\n** of type (int) - the new value of the sorter-reference size threshold.\n** Usually, when SQLite uses an external sort to order records according\n** to an ORDER BY clause, all fields required by the caller are present in the\n** sorted records. However, if SQLite determines based on the declared type\n** of a table column that its values are likely to be very large - larger\n** than the configured sorter-reference size threshold - then a reference\n** is stored in each sorted record and the required column values loaded\n** from the database as records are returned in sorted order. The default\n** value for this option is to never use this optimization. Specifying a\n** negative value for this option restores the default behavior.\n** This option is only available if SQLite is compiled with the\n** [SQLITE_ENABLE_SORTER_REFERENCES] compile-time option.\n**\n** [[SQLITE_CONFIG_MEMDB_MAXSIZE]]\n** <dt>SQLITE_CONFIG_MEMDB_MAXSIZE\n** <dd>The SQLITE_CONFIG_MEMDB_MAXSIZE option accepts a single parameter\n** [sqlite3_int64] parameter which is the default maximum size for an in-memory\n** database created using [sqlite3_deserialize()].  This default maximum\n** size can be adjusted up or down for individual databases using the\n** [SQLITE_FCNTL_SIZE_LIMIT] [sqlite3_file_control|file-control].  If this\n** configuration setting is never used, then the default maximum is determined\n** by the [SQLITE_MEMDB_DEFAULT_MAXSIZE] compile-time option.  If that\n** compile-time option is not set, then the default maximum is 1073741824.\n**\n** [[SQLITE_CONFIG_ROWID_IN_VIEW]]\n** <dt>SQLITE_CONFIG_ROWID_IN_VIEW\n** <dd>The SQLITE_CONFIG_ROWID_IN_VIEW option enables or disables the ability\n** for VIEWs to have a ROWID.  The capability can only be enabled if SQLite is\n** compiled with -DSQLITE_ALLOW_ROWID_IN_VIEW, in which case the capability\n** defaults to on.  This configuration option queries the current setting or\n** changes the setting to off or on.  The argument is a pointer to an integer.\n** If that integer initially holds a value of 1, then the ability for VIEWs to\n** have ROWIDs is activated.  If the integer initially holds zero, then the\n** ability is deactivated.  Any other initial value for the integer leaves the\n** setting unchanged.  After changes, if any, the integer is written with\n** a 1 or 0, if the ability for VIEWs to have ROWIDs is on or off.  If SQLite\n** is compiled without -DSQLITE_ALLOW_ROWID_IN_VIEW (which is the usual and\n** recommended case) then the integer is always filled with zero, regardless\n** if its initial value.\n** </dl>\n*/\n#define SQLITE_CONFIG_SINGLETHREAD         1  /* nil */\n#define SQLITE_CONFIG_MULTITHREAD          2  /* nil */\n#define SQLITE_CONFIG_SERIALIZED           3  /* nil */\n#define SQLITE_CONFIG_MALLOC               4  /* sqlite3_mem_methods* */\n#define SQLITE_CONFIG_GETMALLOC            5  /* sqlite3_mem_methods* */\n#define SQLITE_CONFIG_SCRATCH              6  /* No longer used */\n#define SQLITE_CONFIG_PAGECACHE            7  /* void*, int sz, int N */\n#define SQLITE_CONFIG_HEAP                 8  /* void*, int nByte, int min */\n#define SQLITE_CONFIG_MEMSTATUS            9  /* boolean */\n#define SQLITE_CONFIG_MUTEX               10  /* sqlite3_mutex_methods* */\n#define SQLITE_CONFIG_GETMUTEX            11  /* sqlite3_mutex_methods* */\n/* previously SQLITE_CONFIG_CHUNKALLOC    12 which is now unused. */\n#define SQLITE_CONFIG_LOOKASIDE           13  /* int int */\n#define SQLITE_CONFIG_PCACHE              14  /* no-op */\n#define SQLITE_CONFIG_GETPCACHE           15  /* no-op */\n#define SQLITE_CONFIG_LOG                 16  /* xFunc, void* */\n#define SQLITE_CONFIG_URI                 17  /* int */\n#define SQLITE_CONFIG_PCACHE2             18  /* sqlite3_pcache_methods2* */\n#define SQLITE_CONFIG_GETPCACHE2          19  /* sqlite3_pcache_methods2* */\n#define SQLITE_CONFIG_COVERING_INDEX_SCAN 20  /* int */\n#define SQLITE_CONFIG_SQLLOG              21  /* xSqllog, void* */\n#define SQLITE_CONFIG_MMAP_SIZE           22  /* sqlite3_int64, sqlite3_int64 */\n#define SQLITE_CONFIG_WIN32_HEAPSIZE      23  /* int nByte */\n#define SQLITE_CONFIG_PCACHE_HDRSZ        24  /* int *psz */\n#define SQLITE_CONFIG_PMASZ               25  /* unsigned int szPma */\n#define SQLITE_CONFIG_STMTJRNL_SPILL      26  /* int nByte */\n#define SQLITE_CONFIG_SMALL_MALLOC        27  /* boolean */\n#define SQLITE_CONFIG_SORTERREF_SIZE      28  /* int nByte */\n#define SQLITE_CONFIG_MEMDB_MAXSIZE       29  /* sqlite3_int64 */\n#define SQLITE_CONFIG_ROWID_IN_VIEW       30  /* int* */\n\n/*\n** CAPI3REF: Database Connection Configuration Options\n**\n** These constants are the available integer configuration options that\n** can be passed as the second argument to the [sqlite3_db_config()] interface.\n**\n** New configuration options may be added in future releases of SQLite.\n** Existing configuration options might be discontinued.  Applications\n** should check the return code from [sqlite3_db_config()] to make sure that\n** the call worked.  ^The [sqlite3_db_config()] interface will return a\n** non-zero [error code] if a discontinued or unsupported configuration option\n** is invoked.\n**\n** <dl>\n** [[SQLITE_DBCONFIG_LOOKASIDE]]\n** <dt>SQLITE_DBCONFIG_LOOKASIDE</dt>\n** <dd> ^This option takes three additional arguments that determine the\n** [lookaside memory allocator] configuration for the [database connection].\n** ^The first argument (the third parameter to [sqlite3_db_config()] is a\n** pointer to a memory buffer to use for lookaside memory.\n** ^The first argument after the SQLITE_DBCONFIG_LOOKASIDE verb\n** may be NULL in which case SQLite will allocate the\n** lookaside buffer itself using [sqlite3_malloc()]. ^The second argument is the\n** size of each lookaside buffer slot.  ^The third argument is the number of\n** slots.  The size of the buffer in the first argument must be greater than\n** or equal to the product of the second and third arguments.  The buffer\n** must be aligned to an 8-byte boundary.  ^If the second argument to\n** SQLITE_DBCONFIG_LOOKASIDE is not a multiple of 8, it is internally\n** rounded down to the next smaller multiple of 8.  ^(The lookaside memory\n** configuration for a database connection can only be changed when that\n** connection is not currently using lookaside memory, or in other words\n** when the \"current value\" returned by\n** [sqlite3_db_status](D,[SQLITE_DBSTATUS_LOOKASIDE_USED],...) is zero.\n** Any attempt to change the lookaside memory configuration when lookaside\n** memory is in use leaves the configuration unchanged and returns\n** [SQLITE_BUSY].)^</dd>\n**\n** [[SQLITE_DBCONFIG_ENABLE_FKEY]]\n** <dt>SQLITE_DBCONFIG_ENABLE_FKEY</dt>\n** <dd> ^This option is used to enable or disable the enforcement of\n** [foreign key constraints].  There should be two additional arguments.\n** The first argument is an integer which is 0 to disable FK enforcement,\n** positive to enable FK enforcement or negative to leave FK enforcement\n** unchanged.  The second parameter is a pointer to an integer into which\n** is written 0 or 1 to indicate whether FK enforcement is off or on\n** following this call.  The second parameter may be a NULL pointer, in\n** which case the FK enforcement setting is not reported back. </dd>\n**\n** [[SQLITE_DBCONFIG_ENABLE_TRIGGER]]\n** <dt>SQLITE_DBCONFIG_ENABLE_TRIGGER</dt>\n** <dd> ^This option is used to enable or disable [CREATE TRIGGER | triggers].\n** There should be two additional arguments.\n** The first argument is an integer which is 0 to disable triggers,\n** positive to enable triggers or negative to leave the setting unchanged.\n** The second parameter is a pointer to an integer into which\n** is written 0 or 1 to indicate whether triggers are disabled or enabled\n** following this call.  The second parameter may be a NULL pointer, in\n** which case the trigger setting is not reported back.\n**\n** <p>Originally this option disabled all triggers.  ^(However, since\n** SQLite version 3.35.0, TEMP triggers are still allowed even if\n** this option is off.  So, in other words, this option now only disables\n** triggers in the main database schema or in the schemas of ATTACH-ed\n** databases.)^ </dd>\n**\n** [[SQLITE_DBCONFIG_ENABLE_VIEW]]\n** <dt>SQLITE_DBCONFIG_ENABLE_VIEW</dt>\n** <dd> ^This option is used to enable or disable [CREATE VIEW | views].\n** There should be two additional arguments.\n** The first argument is an integer which is 0 to disable views,\n** positive to enable views or negative to leave the setting unchanged.\n** The second parameter is a pointer to an integer into which\n** is written 0 or 1 to indicate whether views are disabled or enabled\n** following this call.  The second parameter may be a NULL pointer, in\n** which case the view setting is not reported back.\n**\n** <p>Originally this option disabled all views.  ^(However, since\n** SQLite version 3.35.0, TEMP views are still allowed even if\n** this option is off.  So, in other words, this option now only disables\n** views in the main database schema or in the schemas of ATTACH-ed\n** databases.)^ </dd>\n**\n** [[SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER]]\n** <dt>SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER</dt>\n** <dd> ^This option is used to enable or disable the\n** [fts3_tokenizer()] function which is part of the\n** [FTS3] full-text search engine extension.\n** There should be two additional arguments.\n** The first argument is an integer which is 0 to disable fts3_tokenizer() or\n** positive to enable fts3_tokenizer() or negative to leave the setting\n** unchanged.\n** The second parameter is a pointer to an integer into which\n** is written 0 or 1 to indicate whether fts3_tokenizer is disabled or enabled\n** following this call.  The second parameter may be a NULL pointer, in\n** which case the new setting is not reported back. </dd>\n**\n** [[SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION]]\n** <dt>SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION</dt>\n** <dd> ^This option is used to enable or disable the [sqlite3_load_extension()]\n** interface independently of the [load_extension()] SQL function.\n** The [sqlite3_enable_load_extension()] API enables or disables both the\n** C-API [sqlite3_load_extension()] and the SQL function [load_extension()].\n** There should be two additional arguments.\n** When the first argument to this interface is 1, then only the C-API is\n** enabled and the SQL function remains disabled.  If the first argument to\n** this interface is 0, then both the C-API and the SQL function are disabled.\n** If the first argument is -1, then no changes are made to state of either the\n** C-API or the SQL function.\n** The second parameter is a pointer to an integer into which\n** is written 0 or 1 to indicate whether [sqlite3_load_extension()] interface\n** is disabled or enabled following this call.  The second parameter may\n** be a NULL pointer, in which case the new setting is not reported back.\n** </dd>\n**\n** [[SQLITE_DBCONFIG_MAINDBNAME]] <dt>SQLITE_DBCONFIG_MAINDBNAME</dt>\n** <dd> ^This option is used to change the name of the \"main\" database\n** schema.  ^The sole argument is a pointer to a constant UTF8 string\n** which will become the new schema name in place of \"main\".  ^SQLite\n** does not make a copy of the new main schema name string, so the application\n** must ensure that the argument passed into this DBCONFIG option is unchanged\n** until after the database connection closes.\n** </dd>\n**\n** [[SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE]]\n** <dt>SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE</dt>\n** <dd> Usually, when a database in wal mode is closed or detached from a\n** database handle, SQLite checks if this will mean that there are now no\n** connections at all to the database. If so, it performs a checkpoint\n** operation before closing the connection. This option may be used to\n** override this behavior. The first parameter passed to this operation\n** is an integer - positive to disable checkpoints-on-close, or zero (the\n** default) to enable them, and negative to leave the setting unchanged.\n** The second parameter is a pointer to an integer\n** into which is written 0 or 1 to indicate whether checkpoints-on-close\n** have been disabled - 0 if they are not disabled, 1 if they are.\n** </dd>\n**\n** [[SQLITE_DBCONFIG_ENABLE_QPSG]] <dt>SQLITE_DBCONFIG_ENABLE_QPSG</dt>\n** <dd>^(The SQLITE_DBCONFIG_ENABLE_QPSG option activates or deactivates\n** the [query planner stability guarantee] (QPSG).  When the QPSG is active,\n** a single SQL query statement will always use the same algorithm regardless\n** of values of [bound parameters].)^ The QPSG disables some query optimizations\n** that look at the values of bound parameters, which can make some queries\n** slower.  But the QPSG has the advantage of more predictable behavior.  With\n** the QPSG active, SQLite will always use the same query plan in the field as\n** was used during testing in the lab.\n** The first argument to this setting is an integer which is 0 to disable\n** the QPSG, positive to enable QPSG, or negative to leave the setting\n** unchanged. The second parameter is a pointer to an integer into which\n** is written 0 or 1 to indicate whether the QPSG is disabled or enabled\n** following this call.\n** </dd>\n**\n** [[SQLITE_DBCONFIG_TRIGGER_EQP]] <dt>SQLITE_DBCONFIG_TRIGGER_EQP</dt>\n** <dd> By default, the output of EXPLAIN QUERY PLAN commands does not\n** include output for any operations performed by trigger programs. This\n** option is used to set or clear (the default) a flag that governs this\n** behavior. The first parameter passed to this operation is an integer -\n** positive to enable output for trigger programs, or zero to disable it,\n** or negative to leave the setting unchanged.\n** The second parameter is a pointer to an integer into which is written\n** 0 or 1 to indicate whether output-for-triggers has been disabled - 0 if\n** it is not disabled, 1 if it is.\n** </dd>\n**\n** [[SQLITE_DBCONFIG_RESET_DATABASE]] <dt>SQLITE_DBCONFIG_RESET_DATABASE</dt>\n** <dd> Set the SQLITE_DBCONFIG_RESET_DATABASE flag and then run\n** [VACUUM] in order to reset a database back to an empty database\n** with no schema and no content. The following process works even for\n** a badly corrupted database file:\n** <ol>\n** <li> If the database connection is newly opened, make sure it has read the\n**      database schema by preparing then discarding some query against the\n**      database, or calling sqlite3_table_column_metadata(), ignoring any\n**      errors.  This step is only necessary if the application desires to keep\n**      the database in WAL mode after the reset if it was in WAL mode before\n**      the reset.\n** <li> sqlite3_db_config(db, SQLITE_DBCONFIG_RESET_DATABASE, 1, 0);\n** <li> [sqlite3_exec](db, \"[VACUUM]\", 0, 0, 0);\n** <li> sqlite3_db_config(db, SQLITE_DBCONFIG_RESET_DATABASE, 0, 0);\n** </ol>\n** Because resetting a database is destructive and irreversible, the\n** process requires the use of this obscure API and multiple steps to\n** help ensure that it does not happen by accident. Because this\n** feature must be capable of resetting corrupt databases, and\n** shutting down virtual tables may require access to that corrupt\n** storage, the library must abandon any installed virtual tables\n** without calling their xDestroy() methods.\n**\n** [[SQLITE_DBCONFIG_DEFENSIVE]] <dt>SQLITE_DBCONFIG_DEFENSIVE</dt>\n** <dd>The SQLITE_DBCONFIG_DEFENSIVE option activates or deactivates the\n** \"defensive\" flag for a database connection.  When the defensive\n** flag is enabled, language features that allow ordinary SQL to\n** deliberately corrupt the database file are disabled.  The disabled\n** features include but are not limited to the following:\n** <ul>\n** <li> The [PRAGMA writable_schema=ON] statement.\n** <li> The [PRAGMA journal_mode=OFF] statement.\n** <li> The [PRAGMA schema_version=N] statement.\n** <li> Writes to the [sqlite_dbpage] virtual table.\n** <li> Direct writes to [shadow tables].\n** </ul>\n** </dd>\n**\n** [[SQLITE_DBCONFIG_WRITABLE_SCHEMA]] <dt>SQLITE_DBCONFIG_WRITABLE_SCHEMA</dt>\n** <dd>The SQLITE_DBCONFIG_WRITABLE_SCHEMA option activates or deactivates the\n** \"writable_schema\" flag. This has the same effect and is logically equivalent\n** to setting [PRAGMA writable_schema=ON] or [PRAGMA writable_schema=OFF].\n** The first argument to this setting is an integer which is 0 to disable\n** the writable_schema, positive to enable writable_schema, or negative to\n** leave the setting unchanged. The second parameter is a pointer to an\n** integer into which is written 0 or 1 to indicate whether the writable_schema\n** is enabled or disabled following this call.\n** </dd>\n**\n** [[SQLITE_DBCONFIG_LEGACY_ALTER_TABLE]]\n** <dt>SQLITE_DBCONFIG_LEGACY_ALTER_TABLE</dt>\n** <dd>The SQLITE_DBCONFIG_LEGACY_ALTER_TABLE option activates or deactivates\n** the legacy behavior of the [ALTER TABLE RENAME] command such it\n** behaves as it did prior to [version 3.24.0] (2018-06-04).  See the\n** \"Compatibility Notice\" on the [ALTER TABLE RENAME documentation] for\n** additional information. This feature can also be turned on and off\n** using the [PRAGMA legacy_alter_table] statement.\n** </dd>\n**\n** [[SQLITE_DBCONFIG_DQS_DML]]\n** <dt>SQLITE_DBCONFIG_DQS_DML</dt>\n** <dd>The SQLITE_DBCONFIG_DQS_DML option activates or deactivates\n** the legacy [double-quoted string literal] misfeature for DML statements\n** only, that is DELETE, INSERT, SELECT, and UPDATE statements. The\n** default value of this setting is determined by the [-DSQLITE_DQS]\n** compile-time option.\n** </dd>\n**\n** [[SQLITE_DBCONFIG_DQS_DDL]]\n** <dt>SQLITE_DBCONFIG_DQS_DDL</dt>\n** <dd>The SQLITE_DBCONFIG_DQS option activates or deactivates\n** the legacy [double-quoted string literal] misfeature for DDL statements,\n** such as CREATE TABLE and CREATE INDEX. The\n** default value of this setting is determined by the [-DSQLITE_DQS]\n** compile-time option.\n** </dd>\n**\n** [[SQLITE_DBCONFIG_TRUSTED_SCHEMA]]\n** <dt>SQLITE_DBCONFIG_TRUSTED_SCHEMA</dt>\n** <dd>The SQLITE_DBCONFIG_TRUSTED_SCHEMA option tells SQLite to\n** assume that database schemas are untainted by malicious content.\n** When the SQLITE_DBCONFIG_TRUSTED_SCHEMA option is disabled, SQLite\n** takes additional defensive steps to protect the application from harm\n** including:\n** <ul>\n** <li> Prohibit the use of SQL functions inside triggers, views,\n** CHECK constraints, DEFAULT clauses, expression indexes,\n** partial indexes, or generated columns\n** unless those functions are tagged with [SQLITE_INNOCUOUS].\n** <li> Prohibit the use of virtual tables inside of triggers or views\n** unless those virtual tables are tagged with [SQLITE_VTAB_INNOCUOUS].\n** </ul>\n** This setting defaults to \"on\" for legacy compatibility, however\n** all applications are advised to turn it off if possible. This setting\n** can also be controlled using the [PRAGMA trusted_schema] statement.\n** </dd>\n**\n** [[SQLITE_DBCONFIG_LEGACY_FILE_FORMAT]]\n** <dt>SQLITE_DBCONFIG_LEGACY_FILE_FORMAT</dt>\n** <dd>The SQLITE_DBCONFIG_LEGACY_FILE_FORMAT option activates or deactivates\n** the legacy file format flag.  When activated, this flag causes all newly\n** created database file to have a schema format version number (the 4-byte\n** integer found at offset 44 into the database header) of 1.  This in turn\n** means that the resulting database file will be readable and writable by\n** any SQLite version back to 3.0.0 ([dateof:3.0.0]).  Without this setting,\n** newly created databases are generally not understandable by SQLite versions\n** prior to 3.3.0 ([dateof:3.3.0]).  As these words are written, there\n** is now scarcely any need to generate database files that are compatible\n** all the way back to version 3.0.0, and so this setting is of little\n** practical use, but is provided so that SQLite can continue to claim the\n** ability to generate new database files that are compatible with  version\n** 3.0.0.\n** <p>Note that when the SQLITE_DBCONFIG_LEGACY_FILE_FORMAT setting is on,\n** the [VACUUM] command will fail with an obscure error when attempting to\n** process a table with generated columns and a descending index.  This is\n** not considered a bug since SQLite versions 3.3.0 and earlier do not support\n** either generated columns or descending indexes.\n** </dd>\n**\n** [[SQLITE_DBCONFIG_STMT_SCANSTATUS]]\n** <dt>SQLITE_DBCONFIG_STMT_SCANSTATUS</dt>\n** <dd>The SQLITE_DBCONFIG_STMT_SCANSTATUS option is only useful in\n** SQLITE_ENABLE_STMT_SCANSTATUS builds. In this case, it sets or clears\n** a flag that enables collection of the sqlite3_stmt_scanstatus_v2()\n** statistics. For statistics to be collected, the flag must be set on\n** the database handle both when the SQL statement is prepared and when it\n** is stepped. The flag is set (collection of statistics is enabled)\n** by default.  This option takes two arguments: an integer and a pointer to\n** an integer..  The first argument is 1, 0, or -1 to enable, disable, or\n** leave unchanged the statement scanstatus option.  If the second argument\n** is not NULL, then the value of the statement scanstatus setting after\n** processing the first argument is written into the integer that the second\n** argument points to.\n** </dd>\n**\n** [[SQLITE_DBCONFIG_REVERSE_SCANORDER]]\n** <dt>SQLITE_DBCONFIG_REVERSE_SCANORDER</dt>\n** <dd>The SQLITE_DBCONFIG_REVERSE_SCANORDER option changes the default order\n** in which tables and indexes are scanned so that the scans start at the end\n** and work toward the beginning rather than starting at the beginning and\n** working toward the end. Setting SQLITE_DBCONFIG_REVERSE_SCANORDER is the\n** same as setting [PRAGMA reverse_unordered_selects].  This option takes\n** two arguments which are an integer and a pointer to an integer.  The first\n** argument is 1, 0, or -1 to enable, disable, or leave unchanged the\n** reverse scan order flag, respectively.  If the second argument is not NULL,\n** then 0 or 1 is written into the integer that the second argument points to\n** depending on if the reverse scan order flag is set after processing the\n** first argument.\n** </dd>\n**\n** </dl>\n*/\n#define SQLITE_DBCONFIG_MAINDBNAME            1000 /* const char* */\n#define SQLITE_DBCONFIG_LOOKASIDE             1001 /* void* int int */\n#define SQLITE_DBCONFIG_ENABLE_FKEY           1002 /* int int* */\n#define SQLITE_DBCONFIG_ENABLE_TRIGGER        1003 /* int int* */\n#define SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER 1004 /* int int* */\n#define SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION 1005 /* int int* */\n#define SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE      1006 /* int int* */\n#define SQLITE_DBCONFIG_ENABLE_QPSG           1007 /* int int* */\n#define SQLITE_DBCONFIG_TRIGGER_EQP           1008 /* int int* */\n#define SQLITE_DBCONFIG_RESET_DATABASE        1009 /* int int* */\n#define SQLITE_DBCONFIG_DEFENSIVE             1010 /* int int* */\n#define SQLITE_DBCONFIG_WRITABLE_SCHEMA       1011 /* int int* */\n#define SQLITE_DBCONFIG_LEGACY_ALTER_TABLE    1012 /* int int* */\n#define SQLITE_DBCONFIG_DQS_DML               1013 /* int int* */\n#define SQLITE_DBCONFIG_DQS_DDL               1014 /* int int* */\n#define SQLITE_DBCONFIG_ENABLE_VIEW           1015 /* int int* */\n#define SQLITE_DBCONFIG_LEGACY_FILE_FORMAT    1016 /* int int* */\n#define SQLITE_DBCONFIG_TRUSTED_SCHEMA        1017 /* int int* */\n#define SQLITE_DBCONFIG_STMT_SCANSTATUS       1018 /* int int* */\n#define SQLITE_DBCONFIG_REVERSE_SCANORDER     1019 /* int int* */\n#define SQLITE_DBCONFIG_MAX                   1019 /* Largest DBCONFIG */\n\n/*\n** CAPI3REF: Enable Or Disable Extended Result Codes\n** METHOD: sqlite3\n**\n** ^The sqlite3_extended_result_codes() routine enables or disables the\n** [extended result codes] feature of SQLite. ^The extended result\n** codes are disabled by default for historical compatibility.\n*/\nSQLITE_API int sqlite3_extended_result_codes(sqlite3*, int onoff);\n\n/*\n** CAPI3REF: Last Insert Rowid\n** METHOD: sqlite3\n**\n** ^Each entry in most SQLite tables (except for [WITHOUT ROWID] tables)\n** has a unique 64-bit signed\n** integer key called the [ROWID | \"rowid\"]. ^The rowid is always available\n** as an undeclared column named ROWID, OID, or _ROWID_ as long as those\n** names are not also used by explicitly declared columns. ^If\n** the table has a column of type [INTEGER PRIMARY KEY] then that column\n** is another alias for the rowid.\n**\n** ^The sqlite3_last_insert_rowid(D) interface usually returns the [rowid] of\n** the most recent successful [INSERT] into a rowid table or [virtual table]\n** on database connection D. ^Inserts into [WITHOUT ROWID] tables are not\n** recorded. ^If no successful [INSERT]s into rowid tables have ever occurred\n** on the database connection D, then sqlite3_last_insert_rowid(D) returns\n** zero.\n**\n** As well as being set automatically as rows are inserted into database\n** tables, the value returned by this function may be set explicitly by\n** [sqlite3_set_last_insert_rowid()]\n**\n** Some virtual table implementations may INSERT rows into rowid tables as\n** part of committing a transaction (e.g. to flush data accumulated in memory\n** to disk). In this case subsequent calls to this function return the rowid\n** associated with these internal INSERT operations, which leads to\n** unintuitive results. Virtual table implementations that do write to rowid\n** tables in this way can avoid this problem by restoring the original\n** rowid value using [sqlite3_set_last_insert_rowid()] before returning\n** control to the user.\n**\n** ^(If an [INSERT] occurs within a trigger then this routine will\n** return the [rowid] of the inserted row as long as the trigger is\n** running. Once the trigger program ends, the value returned\n** by this routine reverts to what it was before the trigger was fired.)^\n**\n** ^An [INSERT] that fails due to a constraint violation is not a\n** successful [INSERT] and does not change the value returned by this\n** routine.  ^Thus INSERT OR FAIL, INSERT OR IGNORE, INSERT OR ROLLBACK,\n** and INSERT OR ABORT make no changes to the return value of this\n** routine when their insertion fails.  ^(When INSERT OR REPLACE\n** encounters a constraint violation, it does not fail.  The\n** INSERT continues to completion after deleting rows that caused\n** the constraint problem so INSERT OR REPLACE will always change\n** the return value of this interface.)^\n**\n** ^For the purposes of this routine, an [INSERT] is considered to\n** be successful even if it is subsequently rolled back.\n**\n** This function is accessible to SQL statements via the\n** [last_insert_rowid() SQL function].\n**\n** If a separate thread performs a new [INSERT] on the same\n** database connection while the [sqlite3_last_insert_rowid()]\n** function is running and thus changes the last insert [rowid],\n** then the value returned by [sqlite3_last_insert_rowid()] is\n** unpredictable and might not equal either the old or the new\n** last insert [rowid].\n*/\nSQLITE_API sqlite3_int64 sqlite3_last_insert_rowid(sqlite3*);\n\n/*\n** CAPI3REF: Set the Last Insert Rowid value.\n** METHOD: sqlite3\n**\n** The sqlite3_set_last_insert_rowid(D, R) method allows the application to\n** set the value returned by calling sqlite3_last_insert_rowid(D) to R\n** without inserting a row into the database.\n*/\nSQLITE_API void sqlite3_set_last_insert_rowid(sqlite3*,sqlite3_int64);\n\n/*\n** CAPI3REF: Count The Number Of Rows Modified\n** METHOD: sqlite3\n**\n** ^These functions return the number of rows modified, inserted or\n** deleted by the most recently completed INSERT, UPDATE or DELETE\n** statement on the database connection specified by the only parameter.\n** The two functions are identical except for the type of the return value\n** and that if the number of rows modified by the most recent INSERT, UPDATE\n** or DELETE is greater than the maximum value supported by type \"int\", then\n** the return value of sqlite3_changes() is undefined. ^Executing any other\n** type of SQL statement does not modify the value returned by these functions.\n**\n** ^Only changes made directly by the INSERT, UPDATE or DELETE statement are\n** considered - auxiliary changes caused by [CREATE TRIGGER | triggers],\n** [foreign key actions] or [REPLACE] constraint resolution are not counted.\n**\n** Changes to a view that are intercepted by\n** [INSTEAD OF trigger | INSTEAD OF triggers] are not counted. ^The value\n** returned by sqlite3_changes() immediately after an INSERT, UPDATE or\n** DELETE statement run on a view is always zero. Only changes made to real\n** tables are counted.\n**\n** Things are more complicated if the sqlite3_changes() function is\n** executed while a trigger program is running. This may happen if the\n** program uses the [changes() SQL function], or if some other callback\n** function invokes sqlite3_changes() directly. Essentially:\n**\n** <ul>\n**   <li> ^(Before entering a trigger program the value returned by\n**        sqlite3_changes() function is saved. After the trigger program\n**        has finished, the original value is restored.)^\n**\n**   <li> ^(Within a trigger program each INSERT, UPDATE and DELETE\n**        statement sets the value returned by sqlite3_changes()\n**        upon completion as normal. Of course, this value will not include\n**        any changes performed by sub-triggers, as the sqlite3_changes()\n**        value will be saved and restored after each sub-trigger has run.)^\n** </ul>\n**\n** ^This means that if the changes() SQL function (or similar) is used\n** by the first INSERT, UPDATE or DELETE statement within a trigger, it\n** returns the value as set when the calling statement began executing.\n** ^If it is used by the second or subsequent such statement within a trigger\n** program, the value returned reflects the number of rows modified by the\n** previous INSERT, UPDATE or DELETE statement within the same trigger.\n**\n** If a separate thread makes changes on the same database connection\n** while [sqlite3_changes()] is running then the value returned\n** is unpredictable and not meaningful.\n**\n** See also:\n** <ul>\n** <li> the [sqlite3_total_changes()] interface\n** <li> the [count_changes pragma]\n** <li> the [changes() SQL function]\n** <li> the [data_version pragma]\n** </ul>\n*/\nSQLITE_API int sqlite3_changes(sqlite3*);\nSQLITE_API sqlite3_int64 sqlite3_changes64(sqlite3*);\n\n/*\n** CAPI3REF: Total Number Of Rows Modified\n** METHOD: sqlite3\n**\n** ^These functions return the total number of rows inserted, modified or\n** deleted by all [INSERT], [UPDATE] or [DELETE] statements completed\n** since the database connection was opened, including those executed as\n** part of trigger programs. The two functions are identical except for the\n** type of the return value and that if the number of rows modified by the\n** connection exceeds the maximum value supported by type \"int\", then\n** the return value of sqlite3_total_changes() is undefined. ^Executing\n** any other type of SQL statement does not affect the value returned by\n** sqlite3_total_changes().\n**\n** ^Changes made as part of [foreign key actions] are included in the\n** count, but those made as part of REPLACE constraint resolution are\n** not. ^Changes to a view that are intercepted by INSTEAD OF triggers\n** are not counted.\n**\n** The [sqlite3_total_changes(D)] interface only reports the number\n** of rows that changed due to SQL statement run against database\n** connection D.  Any changes by other database connections are ignored.\n** To detect changes against a database file from other database\n** connections use the [PRAGMA data_version] command or the\n** [SQLITE_FCNTL_DATA_VERSION] [file control].\n**\n** If a separate thread makes changes on the same database connection\n** while [sqlite3_total_changes()] is running then the value\n** returned is unpredictable and not meaningful.\n**\n** See also:\n** <ul>\n** <li> the [sqlite3_changes()] interface\n** <li> the [count_changes pragma]\n** <li> the [changes() SQL function]\n** <li> the [data_version pragma]\n** <li> the [SQLITE_FCNTL_DATA_VERSION] [file control]\n** </ul>\n*/\nSQLITE_API int sqlite3_total_changes(sqlite3*);\nSQLITE_API sqlite3_int64 sqlite3_total_changes64(sqlite3*);\n\n/*\n** CAPI3REF: Interrupt A Long-Running Query\n** METHOD: sqlite3\n**\n** ^This function causes any pending database operation to abort and\n** return at its earliest opportunity. This routine is typically\n** called in response to a user action such as pressing \"Cancel\"\n** or Ctrl-C where the user wants a long query operation to halt\n** immediately.\n**\n** ^It is safe to call this routine from a thread different from the\n** thread that is currently running the database operation.  But it\n** is not safe to call this routine with a [database connection] that\n** is closed or might close before sqlite3_interrupt() returns.\n**\n** ^If an SQL operation is very nearly finished at the time when\n** sqlite3_interrupt() is called, then it might not have an opportunity\n** to be interrupted and might continue to completion.\n**\n** ^An SQL operation that is interrupted will return [SQLITE_INTERRUPT].\n** ^If the interrupted SQL operation is an INSERT, UPDATE, or DELETE\n** that is inside an explicit transaction, then the entire transaction\n** will be rolled back automatically.\n**\n** ^The sqlite3_interrupt(D) call is in effect until all currently running\n** SQL statements on [database connection] D complete.  ^Any new SQL statements\n** that are started after the sqlite3_interrupt() call and before the\n** running statement count reaches zero are interrupted as if they had been\n** running prior to the sqlite3_interrupt() call.  ^New SQL statements\n** that are started after the running statement count reaches zero are\n** not effected by the sqlite3_interrupt().\n** ^A call to sqlite3_interrupt(D) that occurs when there are no running\n** SQL statements is a no-op and has no effect on SQL statements\n** that are started after the sqlite3_interrupt() call returns.\n**\n** ^The [sqlite3_is_interrupted(D)] interface can be used to determine whether\n** or not an interrupt is currently in effect for [database connection] D.\n** It returns 1 if an interrupt is currently in effect, or 0 otherwise.\n*/\nSQLITE_API void sqlite3_interrupt(sqlite3*);\nSQLITE_API int sqlite3_is_interrupted(sqlite3*);\n\n/*\n** CAPI3REF: Determine If An SQL Statement Is Complete\n**\n** These routines are useful during command-line input to determine if the\n** currently entered text seems to form a complete SQL statement or\n** if additional input is needed before sending the text into\n** SQLite for parsing.  ^These routines return 1 if the input string\n** appears to be a complete SQL statement.  ^A statement is judged to be\n** complete if it ends with a semicolon token and is not a prefix of a\n** well-formed CREATE TRIGGER statement.  ^Semicolons that are embedded within\n** string literals or quoted identifier names or comments are not\n** independent tokens (they are part of the token in which they are\n** embedded) and thus do not count as a statement terminator.  ^Whitespace\n** and comments that follow the final semicolon are ignored.\n**\n** ^These routines return 0 if the statement is incomplete.  ^If a\n** memory allocation fails, then SQLITE_NOMEM is returned.\n**\n** ^These routines do not parse the SQL statements thus\n** will not detect syntactically incorrect SQL.\n**\n** ^(If SQLite has not been initialized using [sqlite3_initialize()] prior\n** to invoking sqlite3_complete16() then sqlite3_initialize() is invoked\n** automatically by sqlite3_complete16().  If that initialization fails,\n** then the return value from sqlite3_complete16() will be non-zero\n** regardless of whether or not the input SQL is complete.)^\n**\n** The input to [sqlite3_complete()] must be a zero-terminated\n** UTF-8 string.\n**\n** The input to [sqlite3_complete16()] must be a zero-terminated\n** UTF-16 string in native byte order.\n*/\nSQLITE_API int sqlite3_complete(const char *sql);\nSQLITE_API int sqlite3_complete16(const void *sql);\n\n/*\n** CAPI3REF: Register A Callback To Handle SQLITE_BUSY Errors\n** KEYWORDS: {busy-handler callback} {busy handler}\n** METHOD: sqlite3\n**\n** ^The sqlite3_busy_handler(D,X,P) routine sets a callback function X\n** that might be invoked with argument P whenever\n** an attempt is made to access a database table associated with\n** [database connection] D when another thread\n** or process has the table locked.\n** The sqlite3_busy_handler() interface is used to implement\n** [sqlite3_busy_timeout()] and [PRAGMA busy_timeout].\n**\n** ^If the busy callback is NULL, then [SQLITE_BUSY]\n** is returned immediately upon encountering the lock.  ^If the busy callback\n** is not NULL, then the callback might be invoked with two arguments.\n**\n** ^The first argument to the busy handler is a copy of the void* pointer which\n** is the third argument to sqlite3_busy_handler().  ^The second argument to\n** the busy handler callback is the number of times that the busy handler has\n** been invoked previously for the same locking event.  ^If the\n** busy callback returns 0, then no additional attempts are made to\n** access the database and [SQLITE_BUSY] is returned\n** to the application.\n** ^If the callback returns non-zero, then another attempt\n** is made to access the database and the cycle repeats.\n**\n** The presence of a busy handler does not guarantee that it will be invoked\n** when there is lock contention. ^If SQLite determines that invoking the busy\n** handler could result in a deadlock, it will go ahead and return [SQLITE_BUSY]\n** to the application instead of invoking the\n** busy handler.\n** Consider a scenario where one process is holding a read lock that\n** it is trying to promote to a reserved lock and\n** a second process is holding a reserved lock that it is trying\n** to promote to an exclusive lock.  The first process cannot proceed\n** because it is blocked by the second and the second process cannot\n** proceed because it is blocked by the first.  If both processes\n** invoke the busy handlers, neither will make any progress.  Therefore,\n** SQLite returns [SQLITE_BUSY] for the first process, hoping that this\n** will induce the first process to release its read lock and allow\n** the second process to proceed.\n**\n** ^The default busy callback is NULL.\n**\n** ^(There can only be a single busy handler defined for each\n** [database connection].  Setting a new busy handler clears any\n** previously set handler.)^  ^Note that calling [sqlite3_busy_timeout()]\n** or evaluating [PRAGMA busy_timeout=N] will change the\n** busy handler and thus clear any previously set busy handler.\n**\n** The busy callback should not take any actions which modify the\n** database connection that invoked the busy handler.  In other words,\n** the busy handler is not reentrant.  Any such actions\n** result in undefined behavior.\n**\n** A busy handler must not close the database connection\n** or [prepared statement] that invoked the busy handler.\n*/\nSQLITE_API int sqlite3_busy_handler(sqlite3*,int(*)(void*,int),void*);\n\n/*\n** CAPI3REF: Set A Busy Timeout\n** METHOD: sqlite3\n**\n** ^This routine sets a [sqlite3_busy_handler | busy handler] that sleeps\n** for a specified amount of time when a table is locked.  ^The handler\n** will sleep multiple times until at least \"ms\" milliseconds of sleeping\n** have accumulated.  ^After at least \"ms\" milliseconds of sleeping,\n** the handler returns 0 which causes [sqlite3_step()] to return\n** [SQLITE_BUSY].\n**\n** ^Calling this routine with an argument less than or equal to zero\n** turns off all busy handlers.\n**\n** ^(There can only be a single busy handler for a particular\n** [database connection] at any given moment.  If another busy handler\n** was defined  (using [sqlite3_busy_handler()]) prior to calling\n** this routine, that other busy handler is cleared.)^\n**\n** See also:  [PRAGMA busy_timeout]\n*/\nSQLITE_API int sqlite3_busy_timeout(sqlite3*, int ms);\n\n/*\n** CAPI3REF: Convenience Routines For Running Queries\n** METHOD: sqlite3\n**\n** This is a legacy interface that is preserved for backwards compatibility.\n** Use of this interface is not recommended.\n**\n** Definition: A <b>result table</b> is memory data structure created by the\n** [sqlite3_get_table()] interface.  A result table records the\n** complete query results from one or more queries.\n**\n** The table conceptually has a number of rows and columns.  But\n** these numbers are not part of the result table itself.  These\n** numbers are obtained separately.  Let N be the number of rows\n** and M be the number of columns.\n**\n** A result table is an array of pointers to zero-terminated UTF-8 strings.\n** There are (N+1)*M elements in the array.  The first M pointers point\n** to zero-terminated strings that  contain the names of the columns.\n** The remaining entries all point to query results.  NULL values result\n** in NULL pointers.  All other values are in their UTF-8 zero-terminated\n** string representation as returned by [sqlite3_column_text()].\n**\n** A result table might consist of one or more memory allocations.\n** It is not safe to pass a result table directly to [sqlite3_free()].\n** A result table should be deallocated using [sqlite3_free_table()].\n**\n** ^(As an example of the result table format, suppose a query result\n** is as follows:\n**\n** <blockquote><pre>\n**        Name        | Age\n**        -----------------------\n**        Alice       | 43\n**        Bob         | 28\n**        Cindy       | 21\n** </pre></blockquote>\n**\n** There are two columns (M==2) and three rows (N==3).  Thus the\n** result table has 8 entries.  Suppose the result table is stored\n** in an array named azResult.  Then azResult holds this content:\n**\n** <blockquote><pre>\n**        azResult&#91;0] = \"Name\";\n**        azResult&#91;1] = \"Age\";\n**        azResult&#91;2] = \"Alice\";\n**        azResult&#91;3] = \"43\";\n**        azResult&#91;4] = \"Bob\";\n**        azResult&#91;5] = \"28\";\n**        azResult&#91;6] = \"Cindy\";\n**        azResult&#91;7] = \"21\";\n** </pre></blockquote>)^\n**\n** ^The sqlite3_get_table() function evaluates one or more\n** semicolon-separated SQL statements in the zero-terminated UTF-8\n** string of its 2nd parameter and returns a result table to the\n** pointer given in its 3rd parameter.\n**\n** After the application has finished with the result from sqlite3_get_table(),\n** it must pass the result table pointer to sqlite3_free_table() in order to\n** release the memory that was malloced.  Because of the way the\n** [sqlite3_malloc()] happens within sqlite3_get_table(), the calling\n** function must not try to call [sqlite3_free()] directly.  Only\n** [sqlite3_free_table()] is able to release the memory properly and safely.\n**\n** The sqlite3_get_table() interface is implemented as a wrapper around\n** [sqlite3_exec()].  The sqlite3_get_table() routine does not have access\n** to any internal data structures of SQLite.  It uses only the public\n** interface defined here.  As a consequence, errors that occur in the\n** wrapper layer outside of the internal [sqlite3_exec()] call are not\n** reflected in subsequent calls to [sqlite3_errcode()] or\n** [sqlite3_errmsg()].\n*/\nSQLITE_API int sqlite3_get_table(\n  sqlite3 *db,          /* An open database */\n  const char *zSql,     /* SQL to be evaluated */\n  char ***pazResult,    /* Results of the query */\n  int *pnRow,           /* Number of result rows written here */\n  int *pnColumn,        /* Number of result columns written here */\n  char **pzErrmsg       /* Error msg written here */\n);\nSQLITE_API void sqlite3_free_table(char **result);\n\n/*\n** CAPI3REF: Formatted String Printing Functions\n**\n** These routines are work-alikes of the \"printf()\" family of functions\n** from the standard C library.\n** These routines understand most of the common formatting options from\n** the standard library printf()\n** plus some additional non-standard formats ([%q], [%Q], [%w], and [%z]).\n** See the [built-in printf()] documentation for details.\n**\n** ^The sqlite3_mprintf() and sqlite3_vmprintf() routines write their\n** results into memory obtained from [sqlite3_malloc64()].\n** The strings returned by these two routines should be\n** released by [sqlite3_free()].  ^Both routines return a\n** NULL pointer if [sqlite3_malloc64()] is unable to allocate enough\n** memory to hold the resulting string.\n**\n** ^(The sqlite3_snprintf() routine is similar to \"snprintf()\" from\n** the standard C library.  The result is written into the\n** buffer supplied as the second parameter whose size is given by\n** the first parameter. Note that the order of the\n** first two parameters is reversed from snprintf().)^  This is an\n** historical accident that cannot be fixed without breaking\n** backwards compatibility.  ^(Note also that sqlite3_snprintf()\n** returns a pointer to its buffer instead of the number of\n** characters actually written into the buffer.)^  We admit that\n** the number of characters written would be a more useful return\n** value but we cannot change the implementation of sqlite3_snprintf()\n** now without breaking compatibility.\n**\n** ^As long as the buffer size is greater than zero, sqlite3_snprintf()\n** guarantees that the buffer is always zero-terminated.  ^The first\n** parameter \"n\" is the total size of the buffer, including space for\n** the zero terminator.  So the longest string that can be completely\n** written will be n-1 characters.\n**\n** ^The sqlite3_vsnprintf() routine is a varargs version of sqlite3_snprintf().\n**\n** See also:  [built-in printf()], [printf() SQL function]\n*/\nSQLITE_API char *sqlite3_mprintf(const char*,...);\nSQLITE_API char *sqlite3_vmprintf(const char*, va_list);\nSQLITE_API char *sqlite3_snprintf(int,char*,const char*, ...);\nSQLITE_API char *sqlite3_vsnprintf(int,char*,const char*, va_list);\n\n/*\n** CAPI3REF: Memory Allocation Subsystem\n**\n** The SQLite core uses these three routines for all of its own\n** internal memory allocation needs. \"Core\" in the previous sentence\n** does not include operating-system specific [VFS] implementation.  The\n** Windows VFS uses native malloc() and free() for some operations.\n**\n** ^The sqlite3_malloc() routine returns a pointer to a block\n** of memory at least N bytes in length, where N is the parameter.\n** ^If sqlite3_malloc() is unable to obtain sufficient free\n** memory, it returns a NULL pointer.  ^If the parameter N to\n** sqlite3_malloc() is zero or negative then sqlite3_malloc() returns\n** a NULL pointer.\n**\n** ^The sqlite3_malloc64(N) routine works just like\n** sqlite3_malloc(N) except that N is an unsigned 64-bit integer instead\n** of a signed 32-bit integer.\n**\n** ^Calling sqlite3_free() with a pointer previously returned\n** by sqlite3_malloc() or sqlite3_realloc() releases that memory so\n** that it might be reused.  ^The sqlite3_free() routine is\n** a no-op if is called with a NULL pointer.  Passing a NULL pointer\n** to sqlite3_free() is harmless.  After being freed, memory\n** should neither be read nor written.  Even reading previously freed\n** memory might result in a segmentation fault or other severe error.\n** Memory corruption, a segmentation fault, or other severe error\n** might result if sqlite3_free() is called with a non-NULL pointer that\n** was not obtained from sqlite3_malloc() or sqlite3_realloc().\n**\n** ^The sqlite3_realloc(X,N) interface attempts to resize a\n** prior memory allocation X to be at least N bytes.\n** ^If the X parameter to sqlite3_realloc(X,N)\n** is a NULL pointer then its behavior is identical to calling\n** sqlite3_malloc(N).\n** ^If the N parameter to sqlite3_realloc(X,N) is zero or\n** negative then the behavior is exactly the same as calling\n** sqlite3_free(X).\n** ^sqlite3_realloc(X,N) returns a pointer to a memory allocation\n** of at least N bytes in size or NULL if insufficient memory is available.\n** ^If M is the size of the prior allocation, then min(N,M) bytes\n** of the prior allocation are copied into the beginning of buffer returned\n** by sqlite3_realloc(X,N) and the prior allocation is freed.\n** ^If sqlite3_realloc(X,N) returns NULL and N is positive, then the\n** prior allocation is not freed.\n**\n** ^The sqlite3_realloc64(X,N) interfaces works the same as\n** sqlite3_realloc(X,N) except that N is a 64-bit unsigned integer instead\n** of a 32-bit signed integer.\n**\n** ^If X is a memory allocation previously obtained from sqlite3_malloc(),\n** sqlite3_malloc64(), sqlite3_realloc(), or sqlite3_realloc64(), then\n** sqlite3_msize(X) returns the size of that memory allocation in bytes.\n** ^The value returned by sqlite3_msize(X) might be larger than the number\n** of bytes requested when X was allocated.  ^If X is a NULL pointer then\n** sqlite3_msize(X) returns zero.  If X points to something that is not\n** the beginning of memory allocation, or if it points to a formerly\n** valid memory allocation that has now been freed, then the behavior\n** of sqlite3_msize(X) is undefined and possibly harmful.\n**\n** ^The memory returned by sqlite3_malloc(), sqlite3_realloc(),\n** sqlite3_malloc64(), and sqlite3_realloc64()\n** is always aligned to at least an 8 byte boundary, or to a\n** 4 byte boundary if the [SQLITE_4_BYTE_ALIGNED_MALLOC] compile-time\n** option is used.\n**\n** The pointer arguments to [sqlite3_free()] and [sqlite3_realloc()]\n** must be either NULL or else pointers obtained from a prior\n** invocation of [sqlite3_malloc()] or [sqlite3_realloc()] that have\n** not yet been released.\n**\n** The application must not read or write any part of\n** a block of memory after it has been released using\n** [sqlite3_free()] or [sqlite3_realloc()].\n*/\nSQLITE_API void *sqlite3_malloc(int);\nSQLITE_API void *sqlite3_malloc64(sqlite3_uint64);\nSQLITE_API void *sqlite3_realloc(void*, int);\nSQLITE_API void *sqlite3_realloc64(void*, sqlite3_uint64);\nSQLITE_API void sqlite3_free(void*);\nSQLITE_API sqlite3_uint64 sqlite3_msize(void*);\n\n/*\n** CAPI3REF: Memory Allocator Statistics\n**\n** SQLite provides these two interfaces for reporting on the status\n** of the [sqlite3_malloc()], [sqlite3_free()], and [sqlite3_realloc()]\n** routines, which form the built-in memory allocation subsystem.\n**\n** ^The [sqlite3_memory_used()] routine returns the number of bytes\n** of memory currently outstanding (malloced but not freed).\n** ^The [sqlite3_memory_highwater()] routine returns the maximum\n** value of [sqlite3_memory_used()] since the high-water mark\n** was last reset.  ^The values returned by [sqlite3_memory_used()] and\n** [sqlite3_memory_highwater()] include any overhead\n** added by SQLite in its implementation of [sqlite3_malloc()],\n** but not overhead added by the any underlying system library\n** routines that [sqlite3_malloc()] may call.\n**\n** ^The memory high-water mark is reset to the current value of\n** [sqlite3_memory_used()] if and only if the parameter to\n** [sqlite3_memory_highwater()] is true.  ^The value returned\n** by [sqlite3_memory_highwater(1)] is the high-water mark\n** prior to the reset.\n*/\nSQLITE_API sqlite3_int64 sqlite3_memory_used(void);\nSQLITE_API sqlite3_int64 sqlite3_memory_highwater(int resetFlag);\n\n/*\n** CAPI3REF: Pseudo-Random Number Generator\n**\n** SQLite contains a high-quality pseudo-random number generator (PRNG) used to\n** select random [ROWID | ROWIDs] when inserting new records into a table that\n** already uses the largest possible [ROWID].  The PRNG is also used for\n** the built-in random() and randomblob() SQL functions.  This interface allows\n** applications to access the same PRNG for other purposes.\n**\n** ^A call to this routine stores N bytes of randomness into buffer P.\n** ^The P parameter can be a NULL pointer.\n**\n** ^If this routine has not been previously called or if the previous\n** call had N less than one or a NULL pointer for P, then the PRNG is\n** seeded using randomness obtained from the xRandomness method of\n** the default [sqlite3_vfs] object.\n** ^If the previous call to this routine had an N of 1 or more and a\n** non-NULL P then the pseudo-randomness is generated\n** internally and without recourse to the [sqlite3_vfs] xRandomness\n** method.\n*/\nSQLITE_API void sqlite3_randomness(int N, void *P);\n\n/*\n** CAPI3REF: Compile-Time Authorization Callbacks\n** METHOD: sqlite3\n** KEYWORDS: {authorizer callback}\n**\n** ^This routine registers an authorizer callback with a particular\n** [database connection], supplied in the first argument.\n** ^The authorizer callback is invoked as SQL statements are being compiled\n** by [sqlite3_prepare()] or its variants [sqlite3_prepare_v2()],\n** [sqlite3_prepare_v3()], [sqlite3_prepare16()], [sqlite3_prepare16_v2()],\n** and [sqlite3_prepare16_v3()].  ^At various\n** points during the compilation process, as logic is being created\n** to perform various actions, the authorizer callback is invoked to\n** see if those actions are allowed.  ^The authorizer callback should\n** return [SQLITE_OK] to allow the action, [SQLITE_IGNORE] to disallow the\n** specific action but allow the SQL statement to continue to be\n** compiled, or [SQLITE_DENY] to cause the entire SQL statement to be\n** rejected with an error.  ^If the authorizer callback returns\n** any value other than [SQLITE_IGNORE], [SQLITE_OK], or [SQLITE_DENY]\n** then the [sqlite3_prepare_v2()] or equivalent call that triggered\n** the authorizer will fail with an error message.\n**\n** When the callback returns [SQLITE_OK], that means the operation\n** requested is ok.  ^When the callback returns [SQLITE_DENY], the\n** [sqlite3_prepare_v2()] or equivalent call that triggered the\n** authorizer will fail with an error message explaining that\n** access is denied.\n**\n** ^The first parameter to the authorizer callback is a copy of the third\n** parameter to the sqlite3_set_authorizer() interface. ^The second parameter\n** to the callback is an integer [SQLITE_COPY | action code] that specifies\n** the particular action to be authorized. ^The third through sixth parameters\n** to the callback are either NULL pointers or zero-terminated strings\n** that contain additional details about the action to be authorized.\n** Applications must always be prepared to encounter a NULL pointer in any\n** of the third through the sixth parameters of the authorization callback.\n**\n** ^If the action code is [SQLITE_READ]\n** and the callback returns [SQLITE_IGNORE] then the\n** [prepared statement] statement is constructed to substitute\n** a NULL value in place of the table column that would have\n** been read if [SQLITE_OK] had been returned.  The [SQLITE_IGNORE]\n** return can be used to deny an untrusted user access to individual\n** columns of a table.\n** ^When a table is referenced by a [SELECT] but no column values are\n** extracted from that table (for example in a query like\n** \"SELECT count(*) FROM tab\") then the [SQLITE_READ] authorizer callback\n** is invoked once for that table with a column name that is an empty string.\n** ^If the action code is [SQLITE_DELETE] and the callback returns\n** [SQLITE_IGNORE] then the [DELETE] operation proceeds but the\n** [truncate optimization] is disabled and all rows are deleted individually.\n**\n** An authorizer is used when [sqlite3_prepare | preparing]\n** SQL statements from an untrusted source, to ensure that the SQL statements\n** do not try to access data they are not allowed to see, or that they do not\n** try to execute malicious statements that damage the database.  For\n** example, an application may allow a user to enter arbitrary\n** SQL queries for evaluation by a database.  But the application does\n** not want the user to be able to make arbitrary changes to the\n** database.  An authorizer could then be put in place while the\n** user-entered SQL is being [sqlite3_prepare | prepared] that\n** disallows everything except [SELECT] statements.\n**\n** Applications that need to process SQL from untrusted sources\n** might also consider lowering resource limits using [sqlite3_limit()]\n** and limiting database size using the [max_page_count] [PRAGMA]\n** in addition to using an authorizer.\n**\n** ^(Only a single authorizer can be in place on a database connection\n** at a time.  Each call to sqlite3_set_authorizer overrides the\n** previous call.)^  ^Disable the authorizer by installing a NULL callback.\n** The authorizer is disabled by default.\n**\n** The authorizer callback must not do anything that will modify\n** the database connection that invoked the authorizer callback.\n** Note that [sqlite3_prepare_v2()] and [sqlite3_step()] both modify their\n** database connections for the meaning of \"modify\" in this paragraph.\n**\n** ^When [sqlite3_prepare_v2()] is used to prepare a statement, the\n** statement might be re-prepared during [sqlite3_step()] due to a\n** schema change.  Hence, the application should ensure that the\n** correct authorizer callback remains in place during the [sqlite3_step()].\n**\n** ^Note that the authorizer callback is invoked only during\n** [sqlite3_prepare()] or its variants.  Authorization is not\n** performed during statement evaluation in [sqlite3_step()], unless\n** as stated in the previous paragraph, sqlite3_step() invokes\n** sqlite3_prepare_v2() to reprepare a statement after a schema change.\n*/\nSQLITE_API int sqlite3_set_authorizer(\n  sqlite3*,\n  int (*xAuth)(void*,int,const char*,const char*,const char*,const char*),\n  void *pUserData\n);\n\n/*\n** CAPI3REF: Authorizer Return Codes\n**\n** The [sqlite3_set_authorizer | authorizer callback function] must\n** return either [SQLITE_OK] or one of these two constants in order\n** to signal SQLite whether or not the action is permitted.  See the\n** [sqlite3_set_authorizer | authorizer documentation] for additional\n** information.\n**\n** Note that SQLITE_IGNORE is also used as a [conflict resolution mode]\n** returned from the [sqlite3_vtab_on_conflict()] interface.\n*/\n#define SQLITE_DENY   1   /* Abort the SQL statement with an error */\n#define SQLITE_IGNORE 2   /* Don't allow access, but don't generate an error */\n\n/*\n** CAPI3REF: Authorizer Action Codes\n**\n** The [sqlite3_set_authorizer()] interface registers a callback function\n** that is invoked to authorize certain SQL statement actions.  The\n** second parameter to the callback is an integer code that specifies\n** what action is being authorized.  These are the integer action codes that\n** the authorizer callback may be passed.\n**\n** These action code values signify what kind of operation is to be\n** authorized.  The 3rd and 4th parameters to the authorization\n** callback function will be parameters or NULL depending on which of these\n** codes is used as the second parameter.  ^(The 5th parameter to the\n** authorizer callback is the name of the database (\"main\", \"temp\",\n** etc.) if applicable.)^  ^The 6th parameter to the authorizer callback\n** is the name of the inner-most trigger or view that is responsible for\n** the access attempt or NULL if this access attempt is directly from\n** top-level SQL code.\n*/\n/******************************************* 3rd ************ 4th ***********/\n#define SQLITE_CREATE_INDEX          1   /* Index Name      Table Name      */\n#define SQLITE_CREATE_TABLE          2   /* Table Name      NULL            */\n#define SQLITE_CREATE_TEMP_INDEX     3   /* Index Name      Table Name      */\n#define SQLITE_CREATE_TEMP_TABLE     4   /* Table Name      NULL            */\n#define SQLITE_CREATE_TEMP_TRIGGER   5   /* Trigger Name    Table Name      */\n#define SQLITE_CREATE_TEMP_VIEW      6   /* View Name       NULL            */\n#define SQLITE_CREATE_TRIGGER        7   /* Trigger Name    Table Name      */\n#define SQLITE_CREATE_VIEW           8   /* View Name       NULL            */\n#define SQLITE_DELETE                9   /* Table Name      NULL            */\n#define SQLITE_DROP_INDEX           10   /* Index Name      Table Name      */\n#define SQLITE_DROP_TABLE           11   /* Table Name      NULL            */\n#define SQLITE_DROP_TEMP_INDEX      12   /* Index Name      Table Name      */\n#define SQLITE_DROP_TEMP_TABLE      13   /* Table Name      NULL            */\n#define SQLITE_DROP_TEMP_TRIGGER    14   /* Trigger Name    Table Name      */\n#define SQLITE_DROP_TEMP_VIEW       15   /* View Name       NULL            */\n#define SQLITE_DROP_TRIGGER         16   /* Trigger Name    Table Name      */\n#define SQLITE_DROP_VIEW            17   /* View Name       NULL            */\n#define SQLITE_INSERT               18   /* Table Name      NULL            */\n#define SQLITE_PRAGMA               19   /* Pragma Name     1st arg or NULL */\n#define SQLITE_READ                 20   /* Table Name      Column Name     */\n#define SQLITE_SELECT               21   /* NULL            NULL            */\n#define SQLITE_TRANSACTION          22   /* Operation       NULL            */\n#define SQLITE_UPDATE               23   /* Table Name      Column Name     */\n#define SQLITE_ATTACH               24   /* Filename        NULL            */\n#define SQLITE_DETACH               25   /* Database Name   NULL            */\n#define SQLITE_ALTER_TABLE          26   /* Database Name   Table Name      */\n#define SQLITE_REINDEX              27   /* Index Name      NULL            */\n#define SQLITE_ANALYZE              28   /* Table Name      NULL            */\n#define SQLITE_CREATE_VTABLE        29   /* Table Name      Module Name     */\n#define SQLITE_DROP_VTABLE          30   /* Table Name      Module Name     */\n#define SQLITE_FUNCTION             31   /* NULL            Function Name   */\n#define SQLITE_SAVEPOINT            32   /* Operation       Savepoint Name  */\n#define SQLITE_COPY                  0   /* No longer used */\n#define SQLITE_RECURSIVE            33   /* NULL            NULL            */\n\n/*\n** CAPI3REF: Deprecated Tracing And Profiling Functions\n** DEPRECATED\n**\n** These routines are deprecated. Use the [sqlite3_trace_v2()] interface\n** instead of the routines described here.\n**\n** These routines register callback functions that can be used for\n** tracing and profiling the execution of SQL statements.\n**\n** ^The callback function registered by sqlite3_trace() is invoked at\n** various times when an SQL statement is being run by [sqlite3_step()].\n** ^The sqlite3_trace() callback is invoked with a UTF-8 rendering of the\n** SQL statement text as the statement first begins executing.\n** ^(Additional sqlite3_trace() callbacks might occur\n** as each triggered subprogram is entered.  The callbacks for triggers\n** contain a UTF-8 SQL comment that identifies the trigger.)^\n**\n** The [SQLITE_TRACE_SIZE_LIMIT] compile-time option can be used to limit\n** the length of [bound parameter] expansion in the output of sqlite3_trace().\n**\n** ^The callback function registered by sqlite3_profile() is invoked\n** as each SQL statement finishes.  ^The profile callback contains\n** the original statement text and an estimate of wall-clock time\n** of how long that statement took to run.  ^The profile callback\n** time is in units of nanoseconds, however the current implementation\n** is only capable of millisecond resolution so the six least significant\n** digits in the time are meaningless.  Future versions of SQLite\n** might provide greater resolution on the profiler callback.  Invoking\n** either [sqlite3_trace()] or [sqlite3_trace_v2()] will cancel the\n** profile callback.\n*/\nSQLITE_API SQLITE_DEPRECATED void *sqlite3_trace(sqlite3*,\n   void(*xTrace)(void*,const char*), void*);\nSQLITE_API SQLITE_DEPRECATED void *sqlite3_profile(sqlite3*,\n   void(*xProfile)(void*,const char*,sqlite3_uint64), void*);\n\n/*\n** CAPI3REF: SQL Trace Event Codes\n** KEYWORDS: SQLITE_TRACE\n**\n** These constants identify classes of events that can be monitored\n** using the [sqlite3_trace_v2()] tracing logic.  The M argument\n** to [sqlite3_trace_v2(D,M,X,P)] is an OR-ed combination of one or more of\n** the following constants.  ^The first argument to the trace callback\n** is one of the following constants.\n**\n** New tracing constants may be added in future releases.\n**\n** ^A trace callback has four arguments: xCallback(T,C,P,X).\n** ^The T argument is one of the integer type codes above.\n** ^The C argument is a copy of the context pointer passed in as the\n** fourth argument to [sqlite3_trace_v2()].\n** The P and X arguments are pointers whose meanings depend on T.\n**\n** <dl>\n** [[SQLITE_TRACE_STMT]] <dt>SQLITE_TRACE_STMT</dt>\n** <dd>^An SQLITE_TRACE_STMT callback is invoked when a prepared statement\n** first begins running and possibly at other times during the\n** execution of the prepared statement, such as at the start of each\n** trigger subprogram. ^The P argument is a pointer to the\n** [prepared statement]. ^The X argument is a pointer to a string which\n** is the unexpanded SQL text of the prepared statement or an SQL comment\n** that indicates the invocation of a trigger.  ^The callback can compute\n** the same text that would have been returned by the legacy [sqlite3_trace()]\n** interface by using the X argument when X begins with \"--\" and invoking\n** [sqlite3_expanded_sql(P)] otherwise.\n**\n** [[SQLITE_TRACE_PROFILE]] <dt>SQLITE_TRACE_PROFILE</dt>\n** <dd>^An SQLITE_TRACE_PROFILE callback provides approximately the same\n** information as is provided by the [sqlite3_profile()] callback.\n** ^The P argument is a pointer to the [prepared statement] and the\n** X argument points to a 64-bit integer which is approximately\n** the number of nanoseconds that the prepared statement took to run.\n** ^The SQLITE_TRACE_PROFILE callback is invoked when the statement finishes.\n**\n** [[SQLITE_TRACE_ROW]] <dt>SQLITE_TRACE_ROW</dt>\n** <dd>^An SQLITE_TRACE_ROW callback is invoked whenever a prepared\n** statement generates a single row of result.\n** ^The P argument is a pointer to the [prepared statement] and the\n** X argument is unused.\n**\n** [[SQLITE_TRACE_CLOSE]] <dt>SQLITE_TRACE_CLOSE</dt>\n** <dd>^An SQLITE_TRACE_CLOSE callback is invoked when a database\n** connection closes.\n** ^The P argument is a pointer to the [database connection] object\n** and the X argument is unused.\n** </dl>\n*/\n#define SQLITE_TRACE_STMT       0x01\n#define SQLITE_TRACE_PROFILE    0x02\n#define SQLITE_TRACE_ROW        0x04\n#define SQLITE_TRACE_CLOSE      0x08\n\n/*\n** CAPI3REF: SQL Trace Hook\n** METHOD: sqlite3\n**\n** ^The sqlite3_trace_v2(D,M,X,P) interface registers a trace callback\n** function X against [database connection] D, using property mask M\n** and context pointer P.  ^If the X callback is\n** NULL or if the M mask is zero, then tracing is disabled.  The\n** M argument should be the bitwise OR-ed combination of\n** zero or more [SQLITE_TRACE] constants.\n**\n** ^Each call to either sqlite3_trace(D,X,P) or sqlite3_trace_v2(D,M,X,P)\n** overrides (cancels) all prior calls to sqlite3_trace(D,X,P) or\n** sqlite3_trace_v2(D,M,X,P) for the [database connection] D.  Each\n** database connection may have at most one trace callback.\n**\n** ^The X callback is invoked whenever any of the events identified by\n** mask M occur.  ^The integer return value from the callback is currently\n** ignored, though this may change in future releases.  Callback\n** implementations should return zero to ensure future compatibility.\n**\n** ^A trace callback is invoked with four arguments: callback(T,C,P,X).\n** ^The T argument is one of the [SQLITE_TRACE]\n** constants to indicate why the callback was invoked.\n** ^The C argument is a copy of the context pointer.\n** The P and X arguments are pointers whose meanings depend on T.\n**\n** The sqlite3_trace_v2() interface is intended to replace the legacy\n** interfaces [sqlite3_trace()] and [sqlite3_profile()], both of which\n** are deprecated.\n*/\nSQLITE_API int sqlite3_trace_v2(\n  sqlite3*,\n  unsigned uMask,\n  int(*xCallback)(unsigned,void*,void*,void*),\n  void *pCtx\n);\n\n/*\n** CAPI3REF: Query Progress Callbacks\n** METHOD: sqlite3\n**\n** ^The sqlite3_progress_handler(D,N,X,P) interface causes the callback\n** function X to be invoked periodically during long running calls to\n** [sqlite3_step()] and [sqlite3_prepare()] and similar for\n** database connection D.  An example use for this\n** interface is to keep a GUI updated during a large query.\n**\n** ^The parameter P is passed through as the only parameter to the\n** callback function X.  ^The parameter N is the approximate number of\n** [virtual machine instructions] that are evaluated between successive\n** invocations of the callback X.  ^If N is less than one then the progress\n** handler is disabled.\n**\n** ^Only a single progress handler may be defined at one time per\n** [database connection]; setting a new progress handler cancels the\n** old one.  ^Setting parameter X to NULL disables the progress handler.\n** ^The progress handler is also disabled by setting N to a value less\n** than 1.\n**\n** ^If the progress callback returns non-zero, the operation is\n** interrupted.  This feature can be used to implement a\n** \"Cancel\" button on a GUI progress dialog box.\n**\n** The progress handler callback must not do anything that will modify\n** the database connection that invoked the progress handler.\n** Note that [sqlite3_prepare_v2()] and [sqlite3_step()] both modify their\n** database connections for the meaning of \"modify\" in this paragraph.\n**\n** The progress handler callback would originally only be invoked from the\n** bytecode engine.  It still might be invoked during [sqlite3_prepare()]\n** and similar because those routines might force a reparse of the schema\n** which involves running the bytecode engine.  However, beginning with\n** SQLite version 3.41.0, the progress handler callback might also be\n** invoked directly from [sqlite3_prepare()] while analyzing and generating\n** code for complex queries.\n*/\nSQLITE_API void sqlite3_progress_handler(sqlite3*, int, int(*)(void*), void*);\n\n/*\n** CAPI3REF: Opening A New Database Connection\n** CONSTRUCTOR: sqlite3\n**\n** ^These routines open an SQLite database file as specified by the\n** filename argument. ^The filename argument is interpreted as UTF-8 for\n** sqlite3_open() and sqlite3_open_v2() and as UTF-16 in the native byte\n** order for sqlite3_open16(). ^(A [database connection] handle is usually\n** returned in *ppDb, even if an error occurs.  The only exception is that\n** if SQLite is unable to allocate memory to hold the [sqlite3] object,\n** a NULL will be written into *ppDb instead of a pointer to the [sqlite3]\n** object.)^ ^(If the database is opened (and/or created) successfully, then\n** [SQLITE_OK] is returned.  Otherwise an [error code] is returned.)^ ^The\n** [sqlite3_errmsg()] or [sqlite3_errmsg16()] routines can be used to obtain\n** an English language description of the error following a failure of any\n** of the sqlite3_open() routines.\n**\n** ^The default encoding will be UTF-8 for databases created using\n** sqlite3_open() or sqlite3_open_v2().  ^The default encoding for databases\n** created using sqlite3_open16() will be UTF-16 in the native byte order.\n**\n** Whether or not an error occurs when it is opened, resources\n** associated with the [database connection] handle should be released by\n** passing it to [sqlite3_close()] when it is no longer required.\n**\n** The sqlite3_open_v2() interface works like sqlite3_open()\n** except that it accepts two additional parameters for additional control\n** over the new database connection.  ^(The flags parameter to\n** sqlite3_open_v2() must include, at a minimum, one of the following\n** three flag combinations:)^\n**\n** <dl>\n** ^(<dt>[SQLITE_OPEN_READONLY]</dt>\n** <dd>The database is opened in read-only mode.  If the database does\n** not already exist, an error is returned.</dd>)^\n**\n** ^(<dt>[SQLITE_OPEN_READWRITE]</dt>\n** <dd>The database is opened for reading and writing if possible, or\n** reading only if the file is write protected by the operating\n** system.  In either case the database must already exist, otherwise\n** an error is returned.  For historical reasons, if opening in\n** read-write mode fails due to OS-level permissions, an attempt is\n** made to open it in read-only mode. [sqlite3_db_readonly()] can be\n** used to determine whether the database is actually\n** read-write.</dd>)^\n**\n** ^(<dt>[SQLITE_OPEN_READWRITE] | [SQLITE_OPEN_CREATE]</dt>\n** <dd>The database is opened for reading and writing, and is created if\n** it does not already exist. This is the behavior that is always used for\n** sqlite3_open() and sqlite3_open16().</dd>)^\n** </dl>\n**\n** In addition to the required flags, the following optional flags are\n** also supported:\n**\n** <dl>\n** ^(<dt>[SQLITE_OPEN_URI]</dt>\n** <dd>The filename can be interpreted as a URI if this flag is set.</dd>)^\n**\n** ^(<dt>[SQLITE_OPEN_MEMORY]</dt>\n** <dd>The database will be opened as an in-memory database.  The database\n** is named by the \"filename\" argument for the purposes of cache-sharing,\n** if shared cache mode is enabled, but the \"filename\" is otherwise ignored.\n** </dd>)^\n**\n** ^(<dt>[SQLITE_OPEN_NOMUTEX]</dt>\n** <dd>The new database connection will use the \"multi-thread\"\n** [threading mode].)^  This means that separate threads are allowed\n** to use SQLite at the same time, as long as each thread is using\n** a different [database connection].\n**\n** ^(<dt>[SQLITE_OPEN_FULLMUTEX]</dt>\n** <dd>The new database connection will use the \"serialized\"\n** [threading mode].)^  This means the multiple threads can safely\n** attempt to use the same database connection at the same time.\n** (Mutexes will block any actual concurrency, but in this mode\n** there is no harm in trying.)\n**\n** ^(<dt>[SQLITE_OPEN_SHAREDCACHE]</dt>\n** <dd>The database is opened [shared cache] enabled, overriding\n** the default shared cache setting provided by\n** [sqlite3_enable_shared_cache()].)^\n** The [use of shared cache mode is discouraged] and hence shared cache\n** capabilities may be omitted from many builds of SQLite.  In such cases,\n** this option is a no-op.\n**\n** ^(<dt>[SQLITE_OPEN_PRIVATECACHE]</dt>\n** <dd>The database is opened [shared cache] disabled, overriding\n** the default shared cache setting provided by\n** [sqlite3_enable_shared_cache()].)^\n**\n** [[OPEN_EXRESCODE]] ^(<dt>[SQLITE_OPEN_EXRESCODE]</dt>\n** <dd>The database connection comes up in \"extended result code mode\".\n** In other words, the database behaves has if\n** [sqlite3_extended_result_codes(db,1)] where called on the database\n** connection as soon as the connection is created. In addition to setting\n** the extended result code mode, this flag also causes [sqlite3_open_v2()]\n** to return an extended result code.</dd>\n**\n** [[OPEN_NOFOLLOW]] ^(<dt>[SQLITE_OPEN_NOFOLLOW]</dt>\n** <dd>The database filename is not allowed to contain a symbolic link</dd>\n** </dl>)^\n**\n** If the 3rd parameter to sqlite3_open_v2() is not one of the\n** required combinations shown above optionally combined with other\n** [SQLITE_OPEN_READONLY | SQLITE_OPEN_* bits]\n** then the behavior is undefined.  Historic versions of SQLite\n** have silently ignored surplus bits in the flags parameter to\n** sqlite3_open_v2(), however that behavior might not be carried through\n** into future versions of SQLite and so applications should not rely\n** upon it.  Note in particular that the SQLITE_OPEN_EXCLUSIVE flag is a no-op\n** for sqlite3_open_v2().  The SQLITE_OPEN_EXCLUSIVE does *not* cause\n** the open to fail if the database already exists.  The SQLITE_OPEN_EXCLUSIVE\n** flag is intended for use by the [sqlite3_vfs|VFS interface] only, and not\n** by sqlite3_open_v2().\n**\n** ^The fourth parameter to sqlite3_open_v2() is the name of the\n** [sqlite3_vfs] object that defines the operating system interface that\n** the new database connection should use.  ^If the fourth parameter is\n** a NULL pointer then the default [sqlite3_vfs] object is used.\n**\n** ^If the filename is \":memory:\", then a private, temporary in-memory database\n** is created for the connection.  ^This in-memory database will vanish when\n** the database connection is closed.  Future versions of SQLite might\n** make use of additional special filenames that begin with the \":\" character.\n** It is recommended that when a database filename actually does begin with\n** a \":\" character you should prefix the filename with a pathname such as\n** \"./\" to avoid ambiguity.\n**\n** ^If the filename is an empty string, then a private, temporary\n** on-disk database will be created.  ^This private database will be\n** automatically deleted as soon as the database connection is closed.\n**\n** [[URI filenames in sqlite3_open()]] <h3>URI Filenames</h3>\n**\n** ^If [URI filename] interpretation is enabled, and the filename argument\n** begins with \"file:\", then the filename is interpreted as a URI. ^URI\n** filename interpretation is enabled if the [SQLITE_OPEN_URI] flag is\n** set in the third argument to sqlite3_open_v2(), or if it has\n** been enabled globally using the [SQLITE_CONFIG_URI] option with the\n** [sqlite3_config()] method or by the [SQLITE_USE_URI] compile-time option.\n** URI filename interpretation is turned off\n** by default, but future releases of SQLite might enable URI filename\n** interpretation by default.  See \"[URI filenames]\" for additional\n** information.\n**\n** URI filenames are parsed according to RFC 3986. ^If the URI contains an\n** authority, then it must be either an empty string or the string\n** \"localhost\". ^If the authority is not an empty string or \"localhost\", an\n** error is returned to the caller. ^The fragment component of a URI, if\n** present, is ignored.\n**\n** ^SQLite uses the path component of the URI as the name of the disk file\n** which contains the database. ^If the path begins with a '/' character,\n** then it is interpreted as an absolute path. ^If the path does not begin\n** with a '/' (meaning that the authority section is omitted from the URI)\n** then the path is interpreted as a relative path.\n** ^(On windows, the first component of an absolute path\n** is a drive specification (e.g. \"C:\").)^\n**\n** [[core URI query parameters]]\n** The query component of a URI may contain parameters that are interpreted\n** either by SQLite itself, or by a [VFS | custom VFS implementation].\n** SQLite and its built-in [VFSes] interpret the\n** following query parameters:\n**\n** <ul>\n**   <li> <b>vfs</b>: ^The \"vfs\" parameter may be used to specify the name of\n**     a VFS object that provides the operating system interface that should\n**     be used to access the database file on disk. ^If this option is set to\n**     an empty string the default VFS object is used. ^Specifying an unknown\n**     VFS is an error. ^If sqlite3_open_v2() is used and the vfs option is\n**     present, then the VFS specified by the option takes precedence over\n**     the value passed as the fourth parameter to sqlite3_open_v2().\n**\n**   <li> <b>mode</b>: ^(The mode parameter may be set to either \"ro\", \"rw\",\n**     \"rwc\", or \"memory\". Attempting to set it to any other value is\n**     an error)^.\n**     ^If \"ro\" is specified, then the database is opened for read-only\n**     access, just as if the [SQLITE_OPEN_READONLY] flag had been set in the\n**     third argument to sqlite3_open_v2(). ^If the mode option is set to\n**     \"rw\", then the database is opened for read-write (but not create)\n**     access, as if SQLITE_OPEN_READWRITE (but not SQLITE_OPEN_CREATE) had\n**     been set. ^Value \"rwc\" is equivalent to setting both\n**     SQLITE_OPEN_READWRITE and SQLITE_OPEN_CREATE.  ^If the mode option is\n**     set to \"memory\" then a pure [in-memory database] that never reads\n**     or writes from disk is used. ^It is an error to specify a value for\n**     the mode parameter that is less restrictive than that specified by\n**     the flags passed in the third parameter to sqlite3_open_v2().\n**\n**   <li> <b>cache</b>: ^The cache parameter may be set to either \"shared\" or\n**     \"private\". ^Setting it to \"shared\" is equivalent to setting the\n**     SQLITE_OPEN_SHAREDCACHE bit in the flags argument passed to\n**     sqlite3_open_v2(). ^Setting the cache parameter to \"private\" is\n**     equivalent to setting the SQLITE_OPEN_PRIVATECACHE bit.\n**     ^If sqlite3_open_v2() is used and the \"cache\" parameter is present in\n**     a URI filename, its value overrides any behavior requested by setting\n**     SQLITE_OPEN_PRIVATECACHE or SQLITE_OPEN_SHAREDCACHE flag.\n**\n**  <li> <b>psow</b>: ^The psow parameter indicates whether or not the\n**     [powersafe overwrite] property does or does not apply to the\n**     storage media on which the database file resides.\n**\n**  <li> <b>nolock</b>: ^The nolock parameter is a boolean query parameter\n**     which if set disables file locking in rollback journal modes.  This\n**     is useful for accessing a database on a filesystem that does not\n**     support locking.  Caution:  Database corruption might result if two\n**     or more processes write to the same database and any one of those\n**     processes uses nolock=1.\n**\n**  <li> <b>immutable</b>: ^The immutable parameter is a boolean query\n**     parameter that indicates that the database file is stored on\n**     read-only media.  ^When immutable is set, SQLite assumes that the\n**     database file cannot be changed, even by a process with higher\n**     privilege, and so the database is opened read-only and all locking\n**     and change detection is disabled.  Caution: Setting the immutable\n**     property on a database file that does in fact change can result\n**     in incorrect query results and/or [SQLITE_CORRUPT] errors.\n**     See also: [SQLITE_IOCAP_IMMUTABLE].\n**\n** </ul>\n**\n** ^Specifying an unknown parameter in the query component of a URI is not an\n** error.  Future versions of SQLite might understand additional query\n** parameters.  See \"[query parameters with special meaning to SQLite]\" for\n** additional information.\n**\n** [[URI filename examples]] <h3>URI filename examples</h3>\n**\n** <table border=\"1\" align=center cellpadding=5>\n** <tr><th> URI filenames <th> Results\n** <tr><td> file:data.db <td>\n**          Open the file \"data.db\" in the current directory.\n** <tr><td> file:/home/fred/data.db<br>\n**          file:///home/fred/data.db <br>\n**          file://localhost/home/fred/data.db <br> <td>\n**          Open the database file \"/home/fred/data.db\".\n** <tr><td> file://darkstar/home/fred/data.db <td>\n**          An error. \"darkstar\" is not a recognized authority.\n** <tr><td style=\"white-space:nowrap\">\n**          file:///C:/Documents%20and%20Settings/fred/Desktop/data.db\n**     <td> Windows only: Open the file \"data.db\" on fred's desktop on drive\n**          C:. Note that the %20 escaping in this example is not strictly\n**          necessary - space characters can be used literally\n**          in URI filenames.\n** <tr><td> file:data.db?mode=ro&cache=private <td>\n**          Open file \"data.db\" in the current directory for read-only access.\n**          Regardless of whether or not shared-cache mode is enabled by\n**          default, use a private cache.\n** <tr><td> file:/home/fred/data.db?vfs=unix-dotfile <td>\n**          Open file \"/home/fred/data.db\". Use the special VFS \"unix-dotfile\"\n**          that uses dot-files in place of posix advisory locking.\n** <tr><td> file:data.db?mode=readonly <td>\n**          An error. \"readonly\" is not a valid option for the \"mode\" parameter.\n**          Use \"ro\" instead:  \"file:data.db?mode=ro\".\n** </table>\n**\n** ^URI hexadecimal escape sequences (%HH) are supported within the path and\n** query components of a URI. A hexadecimal escape sequence consists of a\n** percent sign - \"%\" - followed by exactly two hexadecimal digits\n** specifying an octet value. ^Before the path or query components of a\n** URI filename are interpreted, they are encoded using UTF-8 and all\n** hexadecimal escape sequences replaced by a single byte containing the\n** corresponding octet. If this process generates an invalid UTF-8 encoding,\n** the results are undefined.\n**\n** <b>Note to Windows users:</b>  The encoding used for the filename argument\n** of sqlite3_open() and sqlite3_open_v2() must be UTF-8, not whatever\n** codepage is currently defined.  Filenames containing international\n** characters must be converted to UTF-8 prior to passing them into\n** sqlite3_open() or sqlite3_open_v2().\n**\n** <b>Note to Windows Runtime users:</b>  The temporary directory must be set\n** prior to calling sqlite3_open() or sqlite3_open_v2().  Otherwise, various\n** features that require the use of temporary files may fail.\n**\n** See also: [sqlite3_temp_directory]\n*/\nSQLITE_API int sqlite3_open(\n  const char *filename,   /* Database filename (UTF-8) */\n  sqlite3 **ppDb          /* OUT: SQLite db handle */\n);\nSQLITE_API int sqlite3_open16(\n  const void *filename,   /* Database filename (UTF-16) */\n  sqlite3 **ppDb          /* OUT: SQLite db handle */\n);\nSQLITE_API int sqlite3_open_v2(\n  const char *filename,   /* Database filename (UTF-8) */\n  sqlite3 **ppDb,         /* OUT: SQLite db handle */\n  int flags,              /* Flags */\n  const char *zVfs        /* Name of VFS module to use */\n);\n\n/*\n** CAPI3REF: Obtain Values For URI Parameters\n**\n** These are utility routines, useful to [VFS|custom VFS implementations],\n** that check if a database file was a URI that contained a specific query\n** parameter, and if so obtains the value of that query parameter.\n**\n** The first parameter to these interfaces (hereafter referred to\n** as F) must be one of:\n** <ul>\n** <li> A database filename pointer created by the SQLite core and\n** passed into the xOpen() method of a VFS implementation, or\n** <li> A filename obtained from [sqlite3_db_filename()], or\n** <li> A new filename constructed using [sqlite3_create_filename()].\n** </ul>\n** If the F parameter is not one of the above, then the behavior is\n** undefined and probably undesirable.  Older versions of SQLite were\n** more tolerant of invalid F parameters than newer versions.\n**\n** If F is a suitable filename (as described in the previous paragraph)\n** and if P is the name of the query parameter, then\n** sqlite3_uri_parameter(F,P) returns the value of the P\n** parameter if it exists or a NULL pointer if P does not appear as a\n** query parameter on F.  If P is a query parameter of F and it\n** has no explicit value, then sqlite3_uri_parameter(F,P) returns\n** a pointer to an empty string.\n**\n** The sqlite3_uri_boolean(F,P,B) routine assumes that P is a boolean\n** parameter and returns true (1) or false (0) according to the value\n** of P.  The sqlite3_uri_boolean(F,P,B) routine returns true (1) if the\n** value of query parameter P is one of \"yes\", \"true\", or \"on\" in any\n** case or if the value begins with a non-zero number.  The\n** sqlite3_uri_boolean(F,P,B) routines returns false (0) if the value of\n** query parameter P is one of \"no\", \"false\", or \"off\" in any case or\n** if the value begins with a numeric zero.  If P is not a query\n** parameter on F or if the value of P does not match any of the\n** above, then sqlite3_uri_boolean(F,P,B) returns (B!=0).\n**\n** The sqlite3_uri_int64(F,P,D) routine converts the value of P into a\n** 64-bit signed integer and returns that integer, or D if P does not\n** exist.  If the value of P is something other than an integer, then\n** zero is returned.\n**\n** The sqlite3_uri_key(F,N) returns a pointer to the name (not\n** the value) of the N-th query parameter for filename F, or a NULL\n** pointer if N is less than zero or greater than the number of query\n** parameters minus 1.  The N value is zero-based so N should be 0 to obtain\n** the name of the first query parameter, 1 for the second parameter, and\n** so forth.\n**\n** If F is a NULL pointer, then sqlite3_uri_parameter(F,P) returns NULL and\n** sqlite3_uri_boolean(F,P,B) returns B.  If F is not a NULL pointer and\n** is not a database file pathname pointer that the SQLite core passed\n** into the xOpen VFS method, then the behavior of this routine is undefined\n** and probably undesirable.\n**\n** Beginning with SQLite [version 3.31.0] ([dateof:3.31.0]) the input F\n** parameter can also be the name of a rollback journal file or WAL file\n** in addition to the main database file.  Prior to version 3.31.0, these\n** routines would only work if F was the name of the main database file.\n** When the F parameter is the name of the rollback journal or WAL file,\n** it has access to all the same query parameters as were found on the\n** main database file.\n**\n** See the [URI filename] documentation for additional information.\n*/\nSQLITE_API const char *sqlite3_uri_parameter(sqlite3_filename z, const char *zParam);\nSQLITE_API int sqlite3_uri_boolean(sqlite3_filename z, const char *zParam, int bDefault);\nSQLITE_API sqlite3_int64 sqlite3_uri_int64(sqlite3_filename, const char*, sqlite3_int64);\nSQLITE_API const char *sqlite3_uri_key(sqlite3_filename z, int N);\n\n/*\n** CAPI3REF:  Translate filenames\n**\n** These routines are available to [VFS|custom VFS implementations] for\n** translating filenames between the main database file, the journal file,\n** and the WAL file.\n**\n** If F is the name of an sqlite database file, journal file, or WAL file\n** passed by the SQLite core into the VFS, then sqlite3_filename_database(F)\n** returns the name of the corresponding database file.\n**\n** If F is the name of an sqlite database file, journal file, or WAL file\n** passed by the SQLite core into the VFS, or if F is a database filename\n** obtained from [sqlite3_db_filename()], then sqlite3_filename_journal(F)\n** returns the name of the corresponding rollback journal file.\n**\n** If F is the name of an sqlite database file, journal file, or WAL file\n** that was passed by the SQLite core into the VFS, or if F is a database\n** filename obtained from [sqlite3_db_filename()], then\n** sqlite3_filename_wal(F) returns the name of the corresponding\n** WAL file.\n**\n** In all of the above, if F is not the name of a database, journal or WAL\n** filename passed into the VFS from the SQLite core and F is not the\n** return value from [sqlite3_db_filename()], then the result is\n** undefined and is likely a memory access violation.\n*/\nSQLITE_API const char *sqlite3_filename_database(sqlite3_filename);\nSQLITE_API const char *sqlite3_filename_journal(sqlite3_filename);\nSQLITE_API const char *sqlite3_filename_wal(sqlite3_filename);\n\n/*\n** CAPI3REF:  Database File Corresponding To A Journal\n**\n** ^If X is the name of a rollback or WAL-mode journal file that is\n** passed into the xOpen method of [sqlite3_vfs], then\n** sqlite3_database_file_object(X) returns a pointer to the [sqlite3_file]\n** object that represents the main database file.\n**\n** This routine is intended for use in custom [VFS] implementations\n** only.  It is not a general-purpose interface.\n** The argument sqlite3_file_object(X) must be a filename pointer that\n** has been passed into [sqlite3_vfs].xOpen method where the\n** flags parameter to xOpen contains one of the bits\n** [SQLITE_OPEN_MAIN_JOURNAL] or [SQLITE_OPEN_WAL].  Any other use\n** of this routine results in undefined and probably undesirable\n** behavior.\n*/\nSQLITE_API sqlite3_file *sqlite3_database_file_object(const char*);\n\n/*\n** CAPI3REF: Create and Destroy VFS Filenames\n**\n** These interfaces are provided for use by [VFS shim] implementations and\n** are not useful outside of that context.\n**\n** The sqlite3_create_filename(D,J,W,N,P) allocates memory to hold a version of\n** database filename D with corresponding journal file J and WAL file W and\n** with N URI parameters key/values pairs in the array P.  The result from\n** sqlite3_create_filename(D,J,W,N,P) is a pointer to a database filename that\n** is safe to pass to routines like:\n** <ul>\n** <li> [sqlite3_uri_parameter()],\n** <li> [sqlite3_uri_boolean()],\n** <li> [sqlite3_uri_int64()],\n** <li> [sqlite3_uri_key()],\n** <li> [sqlite3_filename_database()],\n** <li> [sqlite3_filename_journal()], or\n** <li> [sqlite3_filename_wal()].\n** </ul>\n** If a memory allocation error occurs, sqlite3_create_filename() might\n** return a NULL pointer.  The memory obtained from sqlite3_create_filename(X)\n** must be released by a corresponding call to sqlite3_free_filename(Y).\n**\n** The P parameter in sqlite3_create_filename(D,J,W,N,P) should be an array\n** of 2*N pointers to strings.  Each pair of pointers in this array corresponds\n** to a key and value for a query parameter.  The P parameter may be a NULL\n** pointer if N is zero.  None of the 2*N pointers in the P array may be\n** NULL pointers and key pointers should not be empty strings.\n** None of the D, J, or W parameters to sqlite3_create_filename(D,J,W,N,P) may\n** be NULL pointers, though they can be empty strings.\n**\n** The sqlite3_free_filename(Y) routine releases a memory allocation\n** previously obtained from sqlite3_create_filename().  Invoking\n** sqlite3_free_filename(Y) where Y is a NULL pointer is a harmless no-op.\n**\n** If the Y parameter to sqlite3_free_filename(Y) is anything other\n** than a NULL pointer or a pointer previously acquired from\n** sqlite3_create_filename(), then bad things such as heap\n** corruption or segfaults may occur. The value Y should not be\n** used again after sqlite3_free_filename(Y) has been called.  This means\n** that if the [sqlite3_vfs.xOpen()] method of a VFS has been called using Y,\n** then the corresponding [sqlite3_module.xClose() method should also be\n** invoked prior to calling sqlite3_free_filename(Y).\n*/\nSQLITE_API sqlite3_filename sqlite3_create_filename(\n  const char *zDatabase,\n  const char *zJournal,\n  const char *zWal,\n  int nParam,\n  const char **azParam\n);\nSQLITE_API void sqlite3_free_filename(sqlite3_filename);\n\n/*\n** CAPI3REF: Error Codes And Messages\n** METHOD: sqlite3\n**\n** ^If the most recent sqlite3_* API call associated with\n** [database connection] D failed, then the sqlite3_errcode(D) interface\n** returns the numeric [result code] or [extended result code] for that\n** API call.\n** ^The sqlite3_extended_errcode()\n** interface is the same except that it always returns the\n** [extended result code] even when extended result codes are\n** disabled.\n**\n** The values returned by sqlite3_errcode() and/or\n** sqlite3_extended_errcode() might change with each API call.\n** Except, there are some interfaces that are guaranteed to never\n** change the value of the error code.  The error-code preserving\n** interfaces include the following:\n**\n** <ul>\n** <li> sqlite3_errcode()\n** <li> sqlite3_extended_errcode()\n** <li> sqlite3_errmsg()\n** <li> sqlite3_errmsg16()\n** <li> sqlite3_error_offset()\n** </ul>\n**\n** ^The sqlite3_errmsg() and sqlite3_errmsg16() return English-language\n** text that describes the error, as either UTF-8 or UTF-16 respectively,\n** or NULL if no error message is available.\n** (See how SQLite handles [invalid UTF] for exceptions to this rule.)\n** ^(Memory to hold the error message string is managed internally.\n** The application does not need to worry about freeing the result.\n** However, the error string might be overwritten or deallocated by\n** subsequent calls to other SQLite interface functions.)^\n**\n** ^The sqlite3_errstr(E) interface returns the English-language text\n** that describes the [result code] E, as UTF-8, or NULL if E is not an\n** result code for which a text error message is available.\n** ^(Memory to hold the error message string is managed internally\n** and must not be freed by the application)^.\n**\n** ^If the most recent error references a specific token in the input\n** SQL, the sqlite3_error_offset() interface returns the byte offset\n** of the start of that token.  ^The byte offset returned by\n** sqlite3_error_offset() assumes that the input SQL is UTF8.\n** ^If the most recent error does not reference a specific token in the input\n** SQL, then the sqlite3_error_offset() function returns -1.\n**\n** When the serialized [threading mode] is in use, it might be the\n** case that a second error occurs on a separate thread in between\n** the time of the first error and the call to these interfaces.\n** When that happens, the second error will be reported since these\n** interfaces always report the most recent result.  To avoid\n** this, each thread can obtain exclusive use of the [database connection] D\n** by invoking [sqlite3_mutex_enter]([sqlite3_db_mutex](D)) before beginning\n** to use D and invoking [sqlite3_mutex_leave]([sqlite3_db_mutex](D)) after\n** all calls to the interfaces listed here are completed.\n**\n** If an interface fails with SQLITE_MISUSE, that means the interface\n** was invoked incorrectly by the application.  In that case, the\n** error code and message may or may not be set.\n*/\nSQLITE_API int sqlite3_errcode(sqlite3 *db);\nSQLITE_API int sqlite3_extended_errcode(sqlite3 *db);\nSQLITE_API const char *sqlite3_errmsg(sqlite3*);\nSQLITE_API const void *sqlite3_errmsg16(sqlite3*);\nSQLITE_API const char *sqlite3_errstr(int);\nSQLITE_API int sqlite3_error_offset(sqlite3 *db);\n\n/*\n** CAPI3REF: Prepared Statement Object\n** KEYWORDS: {prepared statement} {prepared statements}\n**\n** An instance of this object represents a single SQL statement that\n** has been compiled into binary form and is ready to be evaluated.\n**\n** Think of each SQL statement as a separate computer program.  The\n** original SQL text is source code.  A prepared statement object\n** is the compiled object code.  All SQL must be converted into a\n** prepared statement before it can be run.\n**\n** The life-cycle of a prepared statement object usually goes like this:\n**\n** <ol>\n** <li> Create the prepared statement object using [sqlite3_prepare_v2()].\n** <li> Bind values to [parameters] using the sqlite3_bind_*()\n**      interfaces.\n** <li> Run the SQL by calling [sqlite3_step()] one or more times.\n** <li> Reset the prepared statement using [sqlite3_reset()] then go back\n**      to step 2.  Do this zero or more times.\n** <li> Destroy the object using [sqlite3_finalize()].\n** </ol>\n*/\ntypedef struct sqlite3_stmt sqlite3_stmt;\n\n/*\n** CAPI3REF: Run-time Limits\n** METHOD: sqlite3\n**\n** ^(This interface allows the size of various constructs to be limited\n** on a connection by connection basis.  The first parameter is the\n** [database connection] whose limit is to be set or queried.  The\n** second parameter is one of the [limit categories] that define a\n** class of constructs to be size limited.  The third parameter is the\n** new limit for that construct.)^\n**\n** ^If the new limit is a negative number, the limit is unchanged.\n** ^(For each limit category SQLITE_LIMIT_<i>NAME</i> there is a\n** [limits | hard upper bound]\n** set at compile-time by a C preprocessor macro called\n** [limits | SQLITE_MAX_<i>NAME</i>].\n** (The \"_LIMIT_\" in the name is changed to \"_MAX_\".))^\n** ^Attempts to increase a limit above its hard upper bound are\n** silently truncated to the hard upper bound.\n**\n** ^Regardless of whether or not the limit was changed, the\n** [sqlite3_limit()] interface returns the prior value of the limit.\n** ^Hence, to find the current value of a limit without changing it,\n** simply invoke this interface with the third parameter set to -1.\n**\n** Run-time limits are intended for use in applications that manage\n** both their own internal database and also databases that are controlled\n** by untrusted external sources.  An example application might be a\n** web browser that has its own databases for storing history and\n** separate databases controlled by JavaScript applications downloaded\n** off the Internet.  The internal databases can be given the\n** large, default limits.  Databases managed by external sources can\n** be given much smaller limits designed to prevent a denial of service\n** attack.  Developers might also want to use the [sqlite3_set_authorizer()]\n** interface to further control untrusted SQL.  The size of the database\n** created by an untrusted script can be contained using the\n** [max_page_count] [PRAGMA].\n**\n** New run-time limit categories may be added in future releases.\n*/\nSQLITE_API int sqlite3_limit(sqlite3*, int id, int newVal);\n\n/*\n** CAPI3REF: Run-Time Limit Categories\n** KEYWORDS: {limit category} {*limit categories}\n**\n** These constants define various performance limits\n** that can be lowered at run-time using [sqlite3_limit()].\n** The synopsis of the meanings of the various limits is shown below.\n** Additional information is available at [limits | Limits in SQLite].\n**\n** <dl>\n** [[SQLITE_LIMIT_LENGTH]] ^(<dt>SQLITE_LIMIT_LENGTH</dt>\n** <dd>The maximum size of any string or BLOB or table row, in bytes.<dd>)^\n**\n** [[SQLITE_LIMIT_SQL_LENGTH]] ^(<dt>SQLITE_LIMIT_SQL_LENGTH</dt>\n** <dd>The maximum length of an SQL statement, in bytes.</dd>)^\n**\n** [[SQLITE_LIMIT_COLUMN]] ^(<dt>SQLITE_LIMIT_COLUMN</dt>\n** <dd>The maximum number of columns in a table definition or in the\n** result set of a [SELECT] or the maximum number of columns in an index\n** or in an ORDER BY or GROUP BY clause.</dd>)^\n**\n** [[SQLITE_LIMIT_EXPR_DEPTH]] ^(<dt>SQLITE_LIMIT_EXPR_DEPTH</dt>\n** <dd>The maximum depth of the parse tree on any expression.</dd>)^\n**\n** [[SQLITE_LIMIT_COMPOUND_SELECT]] ^(<dt>SQLITE_LIMIT_COMPOUND_SELECT</dt>\n** <dd>The maximum number of terms in a compound SELECT statement.</dd>)^\n**\n** [[SQLITE_LIMIT_VDBE_OP]] ^(<dt>SQLITE_LIMIT_VDBE_OP</dt>\n** <dd>The maximum number of instructions in a virtual machine program\n** used to implement an SQL statement.  If [sqlite3_prepare_v2()] or\n** the equivalent tries to allocate space for more than this many opcodes\n** in a single prepared statement, an SQLITE_NOMEM error is returned.</dd>)^\n**\n** [[SQLITE_LIMIT_FUNCTION_ARG]] ^(<dt>SQLITE_LIMIT_FUNCTION_ARG</dt>\n** <dd>The maximum number of arguments on a function.</dd>)^\n**\n** [[SQLITE_LIMIT_ATTACHED]] ^(<dt>SQLITE_LIMIT_ATTACHED</dt>\n** <dd>The maximum number of [ATTACH | attached databases].)^</dd>\n**\n** [[SQLITE_LIMIT_LIKE_PATTERN_LENGTH]]\n** ^(<dt>SQLITE_LIMIT_LIKE_PATTERN_LENGTH</dt>\n** <dd>The maximum length of the pattern argument to the [LIKE] or\n** [GLOB] operators.</dd>)^\n**\n** [[SQLITE_LIMIT_VARIABLE_NUMBER]]\n** ^(<dt>SQLITE_LIMIT_VARIABLE_NUMBER</dt>\n** <dd>The maximum index number of any [parameter] in an SQL statement.)^\n**\n** [[SQLITE_LIMIT_TRIGGER_DEPTH]] ^(<dt>SQLITE_LIMIT_TRIGGER_DEPTH</dt>\n** <dd>The maximum depth of recursion for triggers.</dd>)^\n**\n** [[SQLITE_LIMIT_WORKER_THREADS]] ^(<dt>SQLITE_LIMIT_WORKER_THREADS</dt>\n** <dd>The maximum number of auxiliary worker threads that a single\n** [prepared statement] may start.</dd>)^\n** </dl>\n*/\n#define SQLITE_LIMIT_LENGTH                    0\n#define SQLITE_LIMIT_SQL_LENGTH                1\n#define SQLITE_LIMIT_COLUMN                    2\n#define SQLITE_LIMIT_EXPR_DEPTH                3\n#define SQLITE_LIMIT_COMPOUND_SELECT           4\n#define SQLITE_LIMIT_VDBE_OP                   5\n#define SQLITE_LIMIT_FUNCTION_ARG              6\n#define SQLITE_LIMIT_ATTACHED                  7\n#define SQLITE_LIMIT_LIKE_PATTERN_LENGTH       8\n#define SQLITE_LIMIT_VARIABLE_NUMBER           9\n#define SQLITE_LIMIT_TRIGGER_DEPTH            10\n#define SQLITE_LIMIT_WORKER_THREADS           11\n\n/*\n** CAPI3REF: Prepare Flags\n**\n** These constants define various flags that can be passed into\n** \"prepFlags\" parameter of the [sqlite3_prepare_v3()] and\n** [sqlite3_prepare16_v3()] interfaces.\n**\n** New flags may be added in future releases of SQLite.\n**\n** <dl>\n** [[SQLITE_PREPARE_PERSISTENT]] ^(<dt>SQLITE_PREPARE_PERSISTENT</dt>\n** <dd>The SQLITE_PREPARE_PERSISTENT flag is a hint to the query planner\n** that the prepared statement will be retained for a long time and\n** probably reused many times.)^ ^Without this flag, [sqlite3_prepare_v3()]\n** and [sqlite3_prepare16_v3()] assume that the prepared statement will\n** be used just once or at most a few times and then destroyed using\n** [sqlite3_finalize()] relatively soon. The current implementation acts\n** on this hint by avoiding the use of [lookaside memory] so as not to\n** deplete the limited store of lookaside memory. Future versions of\n** SQLite may act on this hint differently.\n**\n** [[SQLITE_PREPARE_NORMALIZE]] <dt>SQLITE_PREPARE_NORMALIZE</dt>\n** <dd>The SQLITE_PREPARE_NORMALIZE flag is a no-op. This flag used\n** to be required for any prepared statement that wanted to use the\n** [sqlite3_normalized_sql()] interface.  However, the\n** [sqlite3_normalized_sql()] interface is now available to all\n** prepared statements, regardless of whether or not they use this\n** flag.\n**\n** [[SQLITE_PREPARE_NO_VTAB]] <dt>SQLITE_PREPARE_NO_VTAB</dt>\n** <dd>The SQLITE_PREPARE_NO_VTAB flag causes the SQL compiler\n** to return an error (error code SQLITE_ERROR) if the statement uses\n** any virtual tables.\n** </dl>\n*/\n#define SQLITE_PREPARE_PERSISTENT              0x01\n#define SQLITE_PREPARE_NORMALIZE               0x02\n#define SQLITE_PREPARE_NO_VTAB                 0x04\n\n/*\n** CAPI3REF: Compiling An SQL Statement\n** KEYWORDS: {SQL statement compiler}\n** METHOD: sqlite3\n** CONSTRUCTOR: sqlite3_stmt\n**\n** To execute an SQL statement, it must first be compiled into a byte-code\n** program using one of these routines.  Or, in other words, these routines\n** are constructors for the [prepared statement] object.\n**\n** The preferred routine to use is [sqlite3_prepare_v2()].  The\n** [sqlite3_prepare()] interface is legacy and should be avoided.\n** [sqlite3_prepare_v3()] has an extra \"prepFlags\" option that is used\n** for special purposes.\n**\n** The use of the UTF-8 interfaces is preferred, as SQLite currently\n** does all parsing using UTF-8.  The UTF-16 interfaces are provided\n** as a convenience.  The UTF-16 interfaces work by converting the\n** input text into UTF-8, then invoking the corresponding UTF-8 interface.\n**\n** The first argument, \"db\", is a [database connection] obtained from a\n** prior successful call to [sqlite3_open()], [sqlite3_open_v2()] or\n** [sqlite3_open16()].  The database connection must not have been closed.\n**\n** The second argument, \"zSql\", is the statement to be compiled, encoded\n** as either UTF-8 or UTF-16.  The sqlite3_prepare(), sqlite3_prepare_v2(),\n** and sqlite3_prepare_v3()\n** interfaces use UTF-8, and sqlite3_prepare16(), sqlite3_prepare16_v2(),\n** and sqlite3_prepare16_v3() use UTF-16.\n**\n** ^If the nByte argument is negative, then zSql is read up to the\n** first zero terminator. ^If nByte is positive, then it is the\n** number of bytes read from zSql.  ^If nByte is zero, then no prepared\n** statement is generated.\n** If the caller knows that the supplied string is nul-terminated, then\n** there is a small performance advantage to passing an nByte parameter that\n** is the number of bytes in the input string <i>including</i>\n** the nul-terminator.\n**\n** ^If pzTail is not NULL then *pzTail is made to point to the first byte\n** past the end of the first SQL statement in zSql.  These routines only\n** compile the first statement in zSql, so *pzTail is left pointing to\n** what remains uncompiled.\n**\n** ^*ppStmt is left pointing to a compiled [prepared statement] that can be\n** executed using [sqlite3_step()].  ^If there is an error, *ppStmt is set\n** to NULL.  ^If the input text contains no SQL (if the input is an empty\n** string or a comment) then *ppStmt is set to NULL.\n** The calling procedure is responsible for deleting the compiled\n** SQL statement using [sqlite3_finalize()] after it has finished with it.\n** ppStmt may not be NULL.\n**\n** ^On success, the sqlite3_prepare() family of routines return [SQLITE_OK];\n** otherwise an [error code] is returned.\n**\n** The sqlite3_prepare_v2(), sqlite3_prepare_v3(), sqlite3_prepare16_v2(),\n** and sqlite3_prepare16_v3() interfaces are recommended for all new programs.\n** The older interfaces (sqlite3_prepare() and sqlite3_prepare16())\n** are retained for backwards compatibility, but their use is discouraged.\n** ^In the \"vX\" interfaces, the prepared statement\n** that is returned (the [sqlite3_stmt] object) contains a copy of the\n** original SQL text. This causes the [sqlite3_step()] interface to\n** behave differently in three ways:\n**\n** <ol>\n** <li>\n** ^If the database schema changes, instead of returning [SQLITE_SCHEMA] as it\n** always used to do, [sqlite3_step()] will automatically recompile the SQL\n** statement and try to run it again. As many as [SQLITE_MAX_SCHEMA_RETRY]\n** retries will occur before sqlite3_step() gives up and returns an error.\n** </li>\n**\n** <li>\n** ^When an error occurs, [sqlite3_step()] will return one of the detailed\n** [error codes] or [extended error codes].  ^The legacy behavior was that\n** [sqlite3_step()] would only return a generic [SQLITE_ERROR] result code\n** and the application would have to make a second call to [sqlite3_reset()]\n** in order to find the underlying cause of the problem. With the \"v2\" prepare\n** interfaces, the underlying reason for the error is returned immediately.\n** </li>\n**\n** <li>\n** ^If the specific value bound to a [parameter | host parameter] in the\n** WHERE clause might influence the choice of query plan for a statement,\n** then the statement will be automatically recompiled, as if there had been\n** a schema change, on the first [sqlite3_step()] call following any change\n** to the [sqlite3_bind_text | bindings] of that [parameter].\n** ^The specific value of a WHERE-clause [parameter] might influence the\n** choice of query plan if the parameter is the left-hand side of a [LIKE]\n** or [GLOB] operator or if the parameter is compared to an indexed column\n** and the [SQLITE_ENABLE_STAT4] compile-time option is enabled.\n** </li>\n** </ol>\n**\n** <p>^sqlite3_prepare_v3() differs from sqlite3_prepare_v2() only in having\n** the extra prepFlags parameter, which is a bit array consisting of zero or\n** more of the [SQLITE_PREPARE_PERSISTENT|SQLITE_PREPARE_*] flags.  ^The\n** sqlite3_prepare_v2() interface works exactly the same as\n** sqlite3_prepare_v3() with a zero prepFlags parameter.\n*/\nSQLITE_API int sqlite3_prepare(\n  sqlite3 *db,            /* Database handle */\n  const char *zSql,       /* SQL statement, UTF-8 encoded */\n  int nByte,              /* Maximum length of zSql in bytes. */\n  sqlite3_stmt **ppStmt,  /* OUT: Statement handle */\n  const char **pzTail     /* OUT: Pointer to unused portion of zSql */\n);\nSQLITE_API int sqlite3_prepare_v2(\n  sqlite3 *db,            /* Database handle */\n  const char *zSql,       /* SQL statement, UTF-8 encoded */\n  int nByte,              /* Maximum length of zSql in bytes. */\n  sqlite3_stmt **ppStmt,  /* OUT: Statement handle */\n  const char **pzTail     /* OUT: Pointer to unused portion of zSql */\n);\nSQLITE_API int sqlite3_prepare_v3(\n  sqlite3 *db,            /* Database handle */\n  const char *zSql,       /* SQL statement, UTF-8 encoded */\n  int nByte,              /* Maximum length of zSql in bytes. */\n  unsigned int prepFlags, /* Zero or more SQLITE_PREPARE_ flags */\n  sqlite3_stmt **ppStmt,  /* OUT: Statement handle */\n  const char **pzTail     /* OUT: Pointer to unused portion of zSql */\n);\nSQLITE_API int sqlite3_prepare16(\n  sqlite3 *db,            /* Database handle */\n  const void *zSql,       /* SQL statement, UTF-16 encoded */\n  int nByte,              /* Maximum length of zSql in bytes. */\n  sqlite3_stmt **ppStmt,  /* OUT: Statement handle */\n  const void **pzTail     /* OUT: Pointer to unused portion of zSql */\n);\nSQLITE_API int sqlite3_prepare16_v2(\n  sqlite3 *db,            /* Database handle */\n  const void *zSql,       /* SQL statement, UTF-16 encoded */\n  int nByte,              /* Maximum length of zSql in bytes. */\n  sqlite3_stmt **ppStmt,  /* OUT: Statement handle */\n  const void **pzTail     /* OUT: Pointer to unused portion of zSql */\n);\nSQLITE_API int sqlite3_prepare16_v3(\n  sqlite3 *db,            /* Database handle */\n  const void *zSql,       /* SQL statement, UTF-16 encoded */\n  int nByte,              /* Maximum length of zSql in bytes. */\n  unsigned int prepFlags, /* Zero or more SQLITE_PREPARE_ flags */\n  sqlite3_stmt **ppStmt,  /* OUT: Statement handle */\n  const void **pzTail     /* OUT: Pointer to unused portion of zSql */\n);\n\n/*\n** CAPI3REF: Retrieving Statement SQL\n** METHOD: sqlite3_stmt\n**\n** ^The sqlite3_sql(P) interface returns a pointer to a copy of the UTF-8\n** SQL text used to create [prepared statement] P if P was\n** created by [sqlite3_prepare_v2()], [sqlite3_prepare_v3()],\n** [sqlite3_prepare16_v2()], or [sqlite3_prepare16_v3()].\n** ^The sqlite3_expanded_sql(P) interface returns a pointer to a UTF-8\n** string containing the SQL text of prepared statement P with\n** [bound parameters] expanded.\n** ^The sqlite3_normalized_sql(P) interface returns a pointer to a UTF-8\n** string containing the normalized SQL text of prepared statement P.  The\n** semantics used to normalize a SQL statement are unspecified and subject\n** to change.  At a minimum, literal values will be replaced with suitable\n** placeholders.\n**\n** ^(For example, if a prepared statement is created using the SQL\n** text \"SELECT $abc,:xyz\" and if parameter $abc is bound to integer 2345\n** and parameter :xyz is unbound, then sqlite3_sql() will return\n** the original string, \"SELECT $abc,:xyz\" but sqlite3_expanded_sql()\n** will return \"SELECT 2345,NULL\".)^\n**\n** ^The sqlite3_expanded_sql() interface returns NULL if insufficient memory\n** is available to hold the result, or if the result would exceed the\n** the maximum string length determined by the [SQLITE_LIMIT_LENGTH].\n**\n** ^The [SQLITE_TRACE_SIZE_LIMIT] compile-time option limits the size of\n** bound parameter expansions.  ^The [SQLITE_OMIT_TRACE] compile-time\n** option causes sqlite3_expanded_sql() to always return NULL.\n**\n** ^The strings returned by sqlite3_sql(P) and sqlite3_normalized_sql(P)\n** are managed by SQLite and are automatically freed when the prepared\n** statement is finalized.\n** ^The string returned by sqlite3_expanded_sql(P), on the other hand,\n** is obtained from [sqlite3_malloc()] and must be freed by the application\n** by passing it to [sqlite3_free()].\n**\n** ^The sqlite3_normalized_sql() interface is only available if\n** the [SQLITE_ENABLE_NORMALIZE] compile-time option is defined.\n*/\nSQLITE_API const char *sqlite3_sql(sqlite3_stmt *pStmt);\nSQLITE_API char *sqlite3_expanded_sql(sqlite3_stmt *pStmt);\n#ifdef SQLITE_ENABLE_NORMALIZE\nSQLITE_API const char *sqlite3_normalized_sql(sqlite3_stmt *pStmt);\n#endif\n\n/*\n** CAPI3REF: Determine If An SQL Statement Writes The Database\n** METHOD: sqlite3_stmt\n**\n** ^The sqlite3_stmt_readonly(X) interface returns true (non-zero) if\n** and only if the [prepared statement] X makes no direct changes to\n** the content of the database file.\n**\n** Note that [application-defined SQL functions] or\n** [virtual tables] might change the database indirectly as a side effect.\n** ^(For example, if an application defines a function \"eval()\" that\n** calls [sqlite3_exec()], then the following SQL statement would\n** change the database file through side-effects:\n**\n** <blockquote><pre>\n**    SELECT eval('DELETE FROM t1') FROM t2;\n** </pre></blockquote>\n**\n** But because the [SELECT] statement does not change the database file\n** directly, sqlite3_stmt_readonly() would still return true.)^\n**\n** ^Transaction control statements such as [BEGIN], [COMMIT], [ROLLBACK],\n** [SAVEPOINT], and [RELEASE] cause sqlite3_stmt_readonly() to return true,\n** since the statements themselves do not actually modify the database but\n** rather they control the timing of when other statements modify the\n** database.  ^The [ATTACH] and [DETACH] statements also cause\n** sqlite3_stmt_readonly() to return true since, while those statements\n** change the configuration of a database connection, they do not make\n** changes to the content of the database files on disk.\n** ^The sqlite3_stmt_readonly() interface returns true for [BEGIN] since\n** [BEGIN] merely sets internal flags, but the [BEGIN|BEGIN IMMEDIATE] and\n** [BEGIN|BEGIN EXCLUSIVE] commands do touch the database and so\n** sqlite3_stmt_readonly() returns false for those commands.\n**\n** ^This routine returns false if there is any possibility that the\n** statement might change the database file.  ^A false return does\n** not guarantee that the statement will change the database file.\n** ^For example, an UPDATE statement might have a WHERE clause that\n** makes it a no-op, but the sqlite3_stmt_readonly() result would still\n** be false.  ^Similarly, a CREATE TABLE IF NOT EXISTS statement is a\n** read-only no-op if the table already exists, but\n** sqlite3_stmt_readonly() still returns false for such a statement.\n**\n** ^If prepared statement X is an [EXPLAIN] or [EXPLAIN QUERY PLAN]\n** statement, then sqlite3_stmt_readonly(X) returns the same value as\n** if the EXPLAIN or EXPLAIN QUERY PLAN prefix were omitted.\n*/\nSQLITE_API int sqlite3_stmt_readonly(sqlite3_stmt *pStmt);\n\n/*\n** CAPI3REF: Query The EXPLAIN Setting For A Prepared Statement\n** METHOD: sqlite3_stmt\n**\n** ^The sqlite3_stmt_isexplain(S) interface returns 1 if the\n** prepared statement S is an EXPLAIN statement, or 2 if the\n** statement S is an EXPLAIN QUERY PLAN.\n** ^The sqlite3_stmt_isexplain(S) interface returns 0 if S is\n** an ordinary statement or a NULL pointer.\n*/\nSQLITE_API int sqlite3_stmt_isexplain(sqlite3_stmt *pStmt);\n\n/*\n** CAPI3REF: Change The EXPLAIN Setting For A Prepared Statement\n** METHOD: sqlite3_stmt\n**\n** The sqlite3_stmt_explain(S,E) interface changes the EXPLAIN\n** setting for [prepared statement] S.  If E is zero, then S becomes\n** a normal prepared statement.  If E is 1, then S behaves as if\n** its SQL text began with \"[EXPLAIN]\".  If E is 2, then S behaves as if\n** its SQL text began with \"[EXPLAIN QUERY PLAN]\".\n**\n** Calling sqlite3_stmt_explain(S,E) might cause S to be reprepared.\n** SQLite tries to avoid a reprepare, but a reprepare might be necessary\n** on the first transition into EXPLAIN or EXPLAIN QUERY PLAN mode.\n**\n** Because of the potential need to reprepare, a call to\n** sqlite3_stmt_explain(S,E) will fail with SQLITE_ERROR if S cannot be\n** reprepared because it was created using [sqlite3_prepare()] instead of\n** the newer [sqlite3_prepare_v2()] or [sqlite3_prepare_v3()] interfaces and\n** hence has no saved SQL text with which to reprepare.\n**\n** Changing the explain setting for a prepared statement does not change\n** the original SQL text for the statement.  Hence, if the SQL text originally\n** began with EXPLAIN or EXPLAIN QUERY PLAN, but sqlite3_stmt_explain(S,0)\n** is called to convert the statement into an ordinary statement, the EXPLAIN\n** or EXPLAIN QUERY PLAN keywords will still appear in the sqlite3_sql(S)\n** output, even though the statement now acts like a normal SQL statement.\n**\n** This routine returns SQLITE_OK if the explain mode is successfully\n** changed, or an error code if the explain mode could not be changed.\n** The explain mode cannot be changed while a statement is active.\n** Hence, it is good practice to call [sqlite3_reset(S)]\n** immediately prior to calling sqlite3_stmt_explain(S,E).\n*/\nSQLITE_API int sqlite3_stmt_explain(sqlite3_stmt *pStmt, int eMode);\n\n/*\n** CAPI3REF: Determine If A Prepared Statement Has Been Reset\n** METHOD: sqlite3_stmt\n**\n** ^The sqlite3_stmt_busy(S) interface returns true (non-zero) if the\n** [prepared statement] S has been stepped at least once using\n** [sqlite3_step(S)] but has neither run to completion (returned\n** [SQLITE_DONE] from [sqlite3_step(S)]) nor\n** been reset using [sqlite3_reset(S)].  ^The sqlite3_stmt_busy(S)\n** interface returns false if S is a NULL pointer.  If S is not a\n** NULL pointer and is not a pointer to a valid [prepared statement]\n** object, then the behavior is undefined and probably undesirable.\n**\n** This interface can be used in combination [sqlite3_next_stmt()]\n** to locate all prepared statements associated with a database\n** connection that are in need of being reset.  This can be used,\n** for example, in diagnostic routines to search for prepared\n** statements that are holding a transaction open.\n*/\nSQLITE_API int sqlite3_stmt_busy(sqlite3_stmt*);\n\n/*\n** CAPI3REF: Dynamically Typed Value Object\n** KEYWORDS: {protected sqlite3_value} {unprotected sqlite3_value}\n**\n** SQLite uses the sqlite3_value object to represent all values\n** that can be stored in a database table. SQLite uses dynamic typing\n** for the values it stores.  ^Values stored in sqlite3_value objects\n** can be integers, floating point values, strings, BLOBs, or NULL.\n**\n** An sqlite3_value object may be either \"protected\" or \"unprotected\".\n** Some interfaces require a protected sqlite3_value.  Other interfaces\n** will accept either a protected or an unprotected sqlite3_value.\n** Every interface that accepts sqlite3_value arguments specifies\n** whether or not it requires a protected sqlite3_value.  The\n** [sqlite3_value_dup()] interface can be used to construct a new\n** protected sqlite3_value from an unprotected sqlite3_value.\n**\n** The terms \"protected\" and \"unprotected\" refer to whether or not\n** a mutex is held.  An internal mutex is held for a protected\n** sqlite3_value object but no mutex is held for an unprotected\n** sqlite3_value object.  If SQLite is compiled to be single-threaded\n** (with [SQLITE_THREADSAFE=0] and with [sqlite3_threadsafe()] returning 0)\n** or if SQLite is run in one of reduced mutex modes\n** [SQLITE_CONFIG_SINGLETHREAD] or [SQLITE_CONFIG_MULTITHREAD]\n** then there is no distinction between protected and unprotected\n** sqlite3_value objects and they can be used interchangeably.  However,\n** for maximum code portability it is recommended that applications\n** still make the distinction between protected and unprotected\n** sqlite3_value objects even when not strictly required.\n**\n** ^The sqlite3_value objects that are passed as parameters into the\n** implementation of [application-defined SQL functions] are protected.\n** ^The sqlite3_value objects returned by [sqlite3_vtab_rhs_value()]\n** are protected.\n** ^The sqlite3_value object returned by\n** [sqlite3_column_value()] is unprotected.\n** Unprotected sqlite3_value objects may only be used as arguments\n** to [sqlite3_result_value()], [sqlite3_bind_value()], and\n** [sqlite3_value_dup()].\n** The [sqlite3_value_blob | sqlite3_value_type()] family of\n** interfaces require protected sqlite3_value objects.\n*/\ntypedef struct sqlite3_value sqlite3_value;\n\n/*\n** CAPI3REF: SQL Function Context Object\n**\n** The context in which an SQL function executes is stored in an\n** sqlite3_context object.  ^A pointer to an sqlite3_context object\n** is always first parameter to [application-defined SQL functions].\n** The application-defined SQL function implementation will pass this\n** pointer through into calls to [sqlite3_result_int | sqlite3_result()],\n** [sqlite3_aggregate_context()], [sqlite3_user_data()],\n** [sqlite3_context_db_handle()], [sqlite3_get_auxdata()],\n** and/or [sqlite3_set_auxdata()].\n*/\ntypedef struct sqlite3_context sqlite3_context;\n\n/*\n** CAPI3REF: Binding Values To Prepared Statements\n** KEYWORDS: {host parameter} {host parameters} {host parameter name}\n** KEYWORDS: {SQL parameter} {SQL parameters} {parameter binding}\n** METHOD: sqlite3_stmt\n**\n** ^(In the SQL statement text input to [sqlite3_prepare_v2()] and its variants,\n** literals may be replaced by a [parameter] that matches one of following\n** templates:\n**\n** <ul>\n** <li>  ?\n** <li>  ?NNN\n** <li>  :VVV\n** <li>  @VVV\n** <li>  $VVV\n** </ul>\n**\n** In the templates above, NNN represents an integer literal,\n** and VVV represents an alphanumeric identifier.)^  ^The values of these\n** parameters (also called \"host parameter names\" or \"SQL parameters\")\n** can be set using the sqlite3_bind_*() routines defined here.\n**\n** ^The first argument to the sqlite3_bind_*() routines is always\n** a pointer to the [sqlite3_stmt] object returned from\n** [sqlite3_prepare_v2()] or its variants.\n**\n** ^The second argument is the index of the SQL parameter to be set.\n** ^The leftmost SQL parameter has an index of 1.  ^When the same named\n** SQL parameter is used more than once, second and subsequent\n** occurrences have the same index as the first occurrence.\n** ^The index for named parameters can be looked up using the\n** [sqlite3_bind_parameter_index()] API if desired.  ^The index\n** for \"?NNN\" parameters is the value of NNN.\n** ^The NNN value must be between 1 and the [sqlite3_limit()]\n** parameter [SQLITE_LIMIT_VARIABLE_NUMBER] (default value: 32766).\n**\n** ^The third argument is the value to bind to the parameter.\n** ^If the third parameter to sqlite3_bind_text() or sqlite3_bind_text16()\n** or sqlite3_bind_blob() is a NULL pointer then the fourth parameter\n** is ignored and the end result is the same as sqlite3_bind_null().\n** ^If the third parameter to sqlite3_bind_text() is not NULL, then\n** it should be a pointer to well-formed UTF8 text.\n** ^If the third parameter to sqlite3_bind_text16() is not NULL, then\n** it should be a pointer to well-formed UTF16 text.\n** ^If the third parameter to sqlite3_bind_text64() is not NULL, then\n** it should be a pointer to a well-formed unicode string that is\n** either UTF8 if the sixth parameter is SQLITE_UTF8, or UTF16\n** otherwise.\n**\n** [[byte-order determination rules]] ^The byte-order of\n** UTF16 input text is determined by the byte-order mark (BOM, U+FEFF)\n** found in first character, which is removed, or in the absence of a BOM\n** the byte order is the native byte order of the host\n** machine for sqlite3_bind_text16() or the byte order specified in\n** the 6th parameter for sqlite3_bind_text64().)^\n** ^If UTF16 input text contains invalid unicode\n** characters, then SQLite might change those invalid characters\n** into the unicode replacement character: U+FFFD.\n**\n** ^(In those routines that have a fourth argument, its value is the\n** number of bytes in the parameter.  To be clear: the value is the\n** number of <u>bytes</u> in the value, not the number of characters.)^\n** ^If the fourth parameter to sqlite3_bind_text() or sqlite3_bind_text16()\n** is negative, then the length of the string is\n** the number of bytes up to the first zero terminator.\n** If the fourth parameter to sqlite3_bind_blob() is negative, then\n** the behavior is undefined.\n** If a non-negative fourth parameter is provided to sqlite3_bind_text()\n** or sqlite3_bind_text16() or sqlite3_bind_text64() then\n** that parameter must be the byte offset\n** where the NUL terminator would occur assuming the string were NUL\n** terminated.  If any NUL characters occurs at byte offsets less than\n** the value of the fourth parameter then the resulting string value will\n** contain embedded NULs.  The result of expressions involving strings\n** with embedded NULs is undefined.\n**\n** ^The fifth argument to the BLOB and string binding interfaces controls\n** or indicates the lifetime of the object referenced by the third parameter.\n** These three options exist:\n** ^ (1) A destructor to dispose of the BLOB or string after SQLite has finished\n** with it may be passed. ^It is called to dispose of the BLOB or string even\n** if the call to the bind API fails, except the destructor is not called if\n** the third parameter is a NULL pointer or the fourth parameter is negative.\n** ^ (2) The special constant, [SQLITE_STATIC], may be passed to indicate that\n** the application remains responsible for disposing of the object. ^In this\n** case, the object and the provided pointer to it must remain valid until\n** either the prepared statement is finalized or the same SQL parameter is\n** bound to something else, whichever occurs sooner.\n** ^ (3) The constant, [SQLITE_TRANSIENT], may be passed to indicate that the\n** object is to be copied prior to the return from sqlite3_bind_*(). ^The\n** object and pointer to it must remain valid until then. ^SQLite will then\n** manage the lifetime of its private copy.\n**\n** ^The sixth argument to sqlite3_bind_text64() must be one of\n** [SQLITE_UTF8], [SQLITE_UTF16], [SQLITE_UTF16BE], or [SQLITE_UTF16LE]\n** to specify the encoding of the text in the third parameter.  If\n** the sixth argument to sqlite3_bind_text64() is not one of the\n** allowed values shown above, or if the text encoding is different\n** from the encoding specified by the sixth parameter, then the behavior\n** is undefined.\n**\n** ^The sqlite3_bind_zeroblob() routine binds a BLOB of length N that\n** is filled with zeroes.  ^A zeroblob uses a fixed amount of memory\n** (just an integer to hold its size) while it is being processed.\n** Zeroblobs are intended to serve as placeholders for BLOBs whose\n** content is later written using\n** [sqlite3_blob_open | incremental BLOB I/O] routines.\n** ^A negative value for the zeroblob results in a zero-length BLOB.\n**\n** ^The sqlite3_bind_pointer(S,I,P,T,D) routine causes the I-th parameter in\n** [prepared statement] S to have an SQL value of NULL, but to also be\n** associated with the pointer P of type T.  ^D is either a NULL pointer or\n** a pointer to a destructor function for P. ^SQLite will invoke the\n** destructor D with a single argument of P when it is finished using\n** P.  The T parameter should be a static string, preferably a string\n** literal. The sqlite3_bind_pointer() routine is part of the\n** [pointer passing interface] added for SQLite 3.20.0.\n**\n** ^If any of the sqlite3_bind_*() routines are called with a NULL pointer\n** for the [prepared statement] or with a prepared statement for which\n** [sqlite3_step()] has been called more recently than [sqlite3_reset()],\n** then the call will return [SQLITE_MISUSE].  If any sqlite3_bind_()\n** routine is passed a [prepared statement] that has been finalized, the\n** result is undefined and probably harmful.\n**\n** ^Bindings are not cleared by the [sqlite3_reset()] routine.\n** ^Unbound parameters are interpreted as NULL.\n**\n** ^The sqlite3_bind_* routines return [SQLITE_OK] on success or an\n** [error code] if anything goes wrong.\n** ^[SQLITE_TOOBIG] might be returned if the size of a string or BLOB\n** exceeds limits imposed by [sqlite3_limit]([SQLITE_LIMIT_LENGTH]) or\n** [SQLITE_MAX_LENGTH].\n** ^[SQLITE_RANGE] is returned if the parameter\n** index is out of range.  ^[SQLITE_NOMEM] is returned if malloc() fails.\n**\n** See also: [sqlite3_bind_parameter_count()],\n** [sqlite3_bind_parameter_name()], and [sqlite3_bind_parameter_index()].\n*/\nSQLITE_API int sqlite3_bind_blob(sqlite3_stmt*, int, const void*, int n, void(*)(void*));\nSQLITE_API int sqlite3_bind_blob64(sqlite3_stmt*, int, const void*, sqlite3_uint64,\n                        void(*)(void*));\nSQLITE_API int sqlite3_bind_double(sqlite3_stmt*, int, double);\nSQLITE_API int sqlite3_bind_int(sqlite3_stmt*, int, int);\nSQLITE_API int sqlite3_bind_int64(sqlite3_stmt*, int, sqlite3_int64);\nSQLITE_API int sqlite3_bind_null(sqlite3_stmt*, int);\nSQLITE_API int sqlite3_bind_text(sqlite3_stmt*,int,const char*,int,void(*)(void*));\nSQLITE_API int sqlite3_bind_text16(sqlite3_stmt*, int, const void*, int, void(*)(void*));\nSQLITE_API int sqlite3_bind_text64(sqlite3_stmt*, int, const char*, sqlite3_uint64,\n                         void(*)(void*), unsigned char encoding);\nSQLITE_API int sqlite3_bind_value(sqlite3_stmt*, int, const sqlite3_value*);\nSQLITE_API int sqlite3_bind_pointer(sqlite3_stmt*, int, void*, const char*,void(*)(void*));\nSQLITE_API int sqlite3_bind_zeroblob(sqlite3_stmt*, int, int n);\nSQLITE_API int sqlite3_bind_zeroblob64(sqlite3_stmt*, int, sqlite3_uint64);\n\n/*\n** CAPI3REF: Number Of SQL Parameters\n** METHOD: sqlite3_stmt\n**\n** ^This routine can be used to find the number of [SQL parameters]\n** in a [prepared statement].  SQL parameters are tokens of the\n** form \"?\", \"?NNN\", \":AAA\", \"$AAA\", or \"@AAA\" that serve as\n** placeholders for values that are [sqlite3_bind_blob | bound]\n** to the parameters at a later time.\n**\n** ^(This routine actually returns the index of the largest (rightmost)\n** parameter. For all forms except ?NNN, this will correspond to the\n** number of unique parameters.  If parameters of the ?NNN form are used,\n** there may be gaps in the list.)^\n**\n** See also: [sqlite3_bind_blob|sqlite3_bind()],\n** [sqlite3_bind_parameter_name()], and\n** [sqlite3_bind_parameter_index()].\n*/\nSQLITE_API int sqlite3_bind_parameter_count(sqlite3_stmt*);\n\n/*\n** CAPI3REF: Name Of A Host Parameter\n** METHOD: sqlite3_stmt\n**\n** ^The sqlite3_bind_parameter_name(P,N) interface returns\n** the name of the N-th [SQL parameter] in the [prepared statement] P.\n** ^(SQL parameters of the form \"?NNN\" or \":AAA\" or \"@AAA\" or \"$AAA\"\n** have a name which is the string \"?NNN\" or \":AAA\" or \"@AAA\" or \"$AAA\"\n** respectively.\n** In other words, the initial \":\" or \"$\" or \"@\" or \"?\"\n** is included as part of the name.)^\n** ^Parameters of the form \"?\" without a following integer have no name\n** and are referred to as \"nameless\" or \"anonymous parameters\".\n**\n** ^The first host parameter has an index of 1, not 0.\n**\n** ^If the value N is out of range or if the N-th parameter is\n** nameless, then NULL is returned.  ^The returned string is\n** always in UTF-8 encoding even if the named parameter was\n** originally specified as UTF-16 in [sqlite3_prepare16()],\n** [sqlite3_prepare16_v2()], or [sqlite3_prepare16_v3()].\n**\n** See also: [sqlite3_bind_blob|sqlite3_bind()],\n** [sqlite3_bind_parameter_count()], and\n** [sqlite3_bind_parameter_index()].\n*/\nSQLITE_API const char *sqlite3_bind_parameter_name(sqlite3_stmt*, int);\n\n/*\n** CAPI3REF: Index Of A Parameter With A Given Name\n** METHOD: sqlite3_stmt\n**\n** ^Return the index of an SQL parameter given its name.  ^The\n** index value returned is suitable for use as the second\n** parameter to [sqlite3_bind_blob|sqlite3_bind()].  ^A zero\n** is returned if no matching parameter is found.  ^The parameter\n** name must be given in UTF-8 even if the original statement\n** was prepared from UTF-16 text using [sqlite3_prepare16_v2()] or\n** [sqlite3_prepare16_v3()].\n**\n** See also: [sqlite3_bind_blob|sqlite3_bind()],\n** [sqlite3_bind_parameter_count()], and\n** [sqlite3_bind_parameter_name()].\n*/\nSQLITE_API int sqlite3_bind_parameter_index(sqlite3_stmt*, const char *zName);\n\n/*\n** CAPI3REF: Reset All Bindings On A Prepared Statement\n** METHOD: sqlite3_stmt\n**\n** ^Contrary to the intuition of many, [sqlite3_reset()] does not reset\n** the [sqlite3_bind_blob | bindings] on a [prepared statement].\n** ^Use this routine to reset all host parameters to NULL.\n*/\nSQLITE_API int sqlite3_clear_bindings(sqlite3_stmt*);\n\n/*\n** CAPI3REF: Number Of Columns In A Result Set\n** METHOD: sqlite3_stmt\n**\n** ^Return the number of columns in the result set returned by the\n** [prepared statement]. ^If this routine returns 0, that means the\n** [prepared statement] returns no data (for example an [UPDATE]).\n** ^However, just because this routine returns a positive number does not\n** mean that one or more rows of data will be returned.  ^A SELECT statement\n** will always have a positive sqlite3_column_count() but depending on the\n** WHERE clause constraints and the table content, it might return no rows.\n**\n** See also: [sqlite3_data_count()]\n*/\nSQLITE_API int sqlite3_column_count(sqlite3_stmt *pStmt);\n\n/*\n** CAPI3REF: Column Names In A Result Set\n** METHOD: sqlite3_stmt\n**\n** ^These routines return the name assigned to a particular column\n** in the result set of a [SELECT] statement.  ^The sqlite3_column_name()\n** interface returns a pointer to a zero-terminated UTF-8 string\n** and sqlite3_column_name16() returns a pointer to a zero-terminated\n** UTF-16 string.  ^The first parameter is the [prepared statement]\n** that implements the [SELECT] statement. ^The second parameter is the\n** column number.  ^The leftmost column is number 0.\n**\n** ^The returned string pointer is valid until either the [prepared statement]\n** is destroyed by [sqlite3_finalize()] or until the statement is automatically\n** reprepared by the first call to [sqlite3_step()] for a particular run\n** or until the next call to\n** sqlite3_column_name() or sqlite3_column_name16() on the same column.\n**\n** ^If sqlite3_malloc() fails during the processing of either routine\n** (for example during a conversion from UTF-8 to UTF-16) then a\n** NULL pointer is returned.\n**\n** ^The name of a result column is the value of the \"AS\" clause for\n** that column, if there is an AS clause.  If there is no AS clause\n** then the name of the column is unspecified and may change from\n** one release of SQLite to the next.\n*/\nSQLITE_API const char *sqlite3_column_name(sqlite3_stmt*, int N);\nSQLITE_API const void *sqlite3_column_name16(sqlite3_stmt*, int N);\n\n/*\n** CAPI3REF: Source Of Data In A Query Result\n** METHOD: sqlite3_stmt\n**\n** ^These routines provide a means to determine the database, table, and\n** table column that is the origin of a particular result column in\n** [SELECT] statement.\n** ^The name of the database or table or column can be returned as\n** either a UTF-8 or UTF-16 string.  ^The _database_ routines return\n** the database name, the _table_ routines return the table name, and\n** the origin_ routines return the column name.\n** ^The returned string is valid until the [prepared statement] is destroyed\n** using [sqlite3_finalize()] or until the statement is automatically\n** reprepared by the first call to [sqlite3_step()] for a particular run\n** or until the same information is requested\n** again in a different encoding.\n**\n** ^The names returned are the original un-aliased names of the\n** database, table, and column.\n**\n** ^The first argument to these interfaces is a [prepared statement].\n** ^These functions return information about the Nth result column returned by\n** the statement, where N is the second function argument.\n** ^The left-most column is column 0 for these routines.\n**\n** ^If the Nth column returned by the statement is an expression or\n** subquery and is not a column value, then all of these functions return\n** NULL.  ^These routines might also return NULL if a memory allocation error\n** occurs.  ^Otherwise, they return the name of the attached database, table,\n** or column that query result column was extracted from.\n**\n** ^As with all other SQLite APIs, those whose names end with \"16\" return\n** UTF-16 encoded strings and the other functions return UTF-8.\n**\n** ^These APIs are only available if the library was compiled with the\n** [SQLITE_ENABLE_COLUMN_METADATA] C-preprocessor symbol.\n**\n** If two or more threads call one or more\n** [sqlite3_column_database_name | column metadata interfaces]\n** for the same [prepared statement] and result column\n** at the same time then the results are undefined.\n*/\nSQLITE_API const char *sqlite3_column_database_name(sqlite3_stmt*,int);\nSQLITE_API const void *sqlite3_column_database_name16(sqlite3_stmt*,int);\nSQLITE_API const char *sqlite3_column_table_name(sqlite3_stmt*,int);\nSQLITE_API const void *sqlite3_column_table_name16(sqlite3_stmt*,int);\nSQLITE_API const char *sqlite3_column_origin_name(sqlite3_stmt*,int);\nSQLITE_API const void *sqlite3_column_origin_name16(sqlite3_stmt*,int);\n\n/*\n** CAPI3REF: Declared Datatype Of A Query Result\n** METHOD: sqlite3_stmt\n**\n** ^(The first parameter is a [prepared statement].\n** If this statement is a [SELECT] statement and the Nth column of the\n** returned result set of that [SELECT] is a table column (not an\n** expression or subquery) then the declared type of the table\n** column is returned.)^  ^If the Nth column of the result set is an\n** expression or subquery, then a NULL pointer is returned.\n** ^The returned string is always UTF-8 encoded.\n**\n** ^(For example, given the database schema:\n**\n** CREATE TABLE t1(c1 VARIANT);\n**\n** and the following statement to be compiled:\n**\n** SELECT c1 + 1, c1 FROM t1;\n**\n** this routine would return the string \"VARIANT\" for the second result\n** column (i==1), and a NULL pointer for the first result column (i==0).)^\n**\n** ^SQLite uses dynamic run-time typing.  ^So just because a column\n** is declared to contain a particular type does not mean that the\n** data stored in that column is of the declared type.  SQLite is\n** strongly typed, but the typing is dynamic not static.  ^Type\n** is associated with individual values, not with the containers\n** used to hold those values.\n*/\nSQLITE_API const char *sqlite3_column_decltype(sqlite3_stmt*,int);\nSQLITE_API const void *sqlite3_column_decltype16(sqlite3_stmt*,int);\n\n/*\n** CAPI3REF: Evaluate An SQL Statement\n** METHOD: sqlite3_stmt\n**\n** After a [prepared statement] has been prepared using any of\n** [sqlite3_prepare_v2()], [sqlite3_prepare_v3()], [sqlite3_prepare16_v2()],\n** or [sqlite3_prepare16_v3()] or one of the legacy\n** interfaces [sqlite3_prepare()] or [sqlite3_prepare16()], this function\n** must be called one or more times to evaluate the statement.\n**\n** The details of the behavior of the sqlite3_step() interface depend\n** on whether the statement was prepared using the newer \"vX\" interfaces\n** [sqlite3_prepare_v3()], [sqlite3_prepare_v2()], [sqlite3_prepare16_v3()],\n** [sqlite3_prepare16_v2()] or the older legacy\n** interfaces [sqlite3_prepare()] and [sqlite3_prepare16()].  The use of the\n** new \"vX\" interface is recommended for new applications but the legacy\n** interface will continue to be supported.\n**\n** ^In the legacy interface, the return value will be either [SQLITE_BUSY],\n** [SQLITE_DONE], [SQLITE_ROW], [SQLITE_ERROR], or [SQLITE_MISUSE].\n** ^With the \"v2\" interface, any of the other [result codes] or\n** [extended result codes] might be returned as well.\n**\n** ^[SQLITE_BUSY] means that the database engine was unable to acquire the\n** database locks it needs to do its job.  ^If the statement is a [COMMIT]\n** or occurs outside of an explicit transaction, then you can retry the\n** statement.  If the statement is not a [COMMIT] and occurs within an\n** explicit transaction then you should rollback the transaction before\n** continuing.\n**\n** ^[SQLITE_DONE] means that the statement has finished executing\n** successfully.  sqlite3_step() should not be called again on this virtual\n** machine without first calling [sqlite3_reset()] to reset the virtual\n** machine back to its initial state.\n**\n** ^If the SQL statement being executed returns any data, then [SQLITE_ROW]\n** is returned each time a new row of data is ready for processing by the\n** caller. The values may be accessed using the [column access functions].\n** sqlite3_step() is called again to retrieve the next row of data.\n**\n** ^[SQLITE_ERROR] means that a run-time error (such as a constraint\n** violation) has occurred.  sqlite3_step() should not be called again on\n** the VM. More information may be found by calling [sqlite3_errmsg()].\n** ^With the legacy interface, a more specific error code (for example,\n** [SQLITE_INTERRUPT], [SQLITE_SCHEMA], [SQLITE_CORRUPT], and so forth)\n** can be obtained by calling [sqlite3_reset()] on the\n** [prepared statement].  ^In the \"v2\" interface,\n** the more specific error code is returned directly by sqlite3_step().\n**\n** [SQLITE_MISUSE] means that the this routine was called inappropriately.\n** Perhaps it was called on a [prepared statement] that has\n** already been [sqlite3_finalize | finalized] or on one that had\n** previously returned [SQLITE_ERROR] or [SQLITE_DONE].  Or it could\n** be the case that the same database connection is being used by two or\n** more threads at the same moment in time.\n**\n** For all versions of SQLite up to and including 3.6.23.1, a call to\n** [sqlite3_reset()] was required after sqlite3_step() returned anything\n** other than [SQLITE_ROW] before any subsequent invocation of\n** sqlite3_step().  Failure to reset the prepared statement using\n** [sqlite3_reset()] would result in an [SQLITE_MISUSE] return from\n** sqlite3_step().  But after [version 3.6.23.1] ([dateof:3.6.23.1],\n** sqlite3_step() began\n** calling [sqlite3_reset()] automatically in this circumstance rather\n** than returning [SQLITE_MISUSE].  This is not considered a compatibility\n** break because any application that ever receives an SQLITE_MISUSE error\n** is broken by definition.  The [SQLITE_OMIT_AUTORESET] compile-time option\n** can be used to restore the legacy behavior.\n**\n** <b>Goofy Interface Alert:</b> In the legacy interface, the sqlite3_step()\n** API always returns a generic error code, [SQLITE_ERROR], following any\n** error other than [SQLITE_BUSY] and [SQLITE_MISUSE].  You must call\n** [sqlite3_reset()] or [sqlite3_finalize()] in order to find one of the\n** specific [error codes] that better describes the error.\n** We admit that this is a goofy design.  The problem has been fixed\n** with the \"v2\" interface.  If you prepare all of your SQL statements\n** using [sqlite3_prepare_v3()] or [sqlite3_prepare_v2()]\n** or [sqlite3_prepare16_v2()] or [sqlite3_prepare16_v3()] instead\n** of the legacy [sqlite3_prepare()] and [sqlite3_prepare16()] interfaces,\n** then the more specific [error codes] are returned directly\n** by sqlite3_step().  The use of the \"vX\" interfaces is recommended.\n*/\nSQLITE_API int sqlite3_step(sqlite3_stmt*);\n\n/*\n** CAPI3REF: Number of columns in a result set\n** METHOD: sqlite3_stmt\n**\n** ^The sqlite3_data_count(P) interface returns the number of columns in the\n** current row of the result set of [prepared statement] P.\n** ^If prepared statement P does not have results ready to return\n** (via calls to the [sqlite3_column_int | sqlite3_column()] family of\n** interfaces) then sqlite3_data_count(P) returns 0.\n** ^The sqlite3_data_count(P) routine also returns 0 if P is a NULL pointer.\n** ^The sqlite3_data_count(P) routine returns 0 if the previous call to\n** [sqlite3_step](P) returned [SQLITE_DONE].  ^The sqlite3_data_count(P)\n** will return non-zero if previous call to [sqlite3_step](P) returned\n** [SQLITE_ROW], except in the case of the [PRAGMA incremental_vacuum]\n** where it always returns zero since each step of that multi-step\n** pragma returns 0 columns of data.\n**\n** See also: [sqlite3_column_count()]\n*/\nSQLITE_API int sqlite3_data_count(sqlite3_stmt *pStmt);\n\n/*\n** CAPI3REF: Fundamental Datatypes\n** KEYWORDS: SQLITE_TEXT\n**\n** ^(Every value in SQLite has one of five fundamental datatypes:\n**\n** <ul>\n** <li> 64-bit signed integer\n** <li> 64-bit IEEE floating point number\n** <li> string\n** <li> BLOB\n** <li> NULL\n** </ul>)^\n**\n** These constants are codes for each of those types.\n**\n** Note that the SQLITE_TEXT constant was also used in SQLite version 2\n** for a completely different meaning.  Software that links against both\n** SQLite version 2 and SQLite version 3 should use SQLITE3_TEXT, not\n** SQLITE_TEXT.\n*/\n#define SQLITE_INTEGER  1\n#define SQLITE_FLOAT    2\n#define SQLITE_BLOB     4\n#define SQLITE_NULL     5\n#ifdef SQLITE_TEXT\n# undef SQLITE_TEXT\n#else\n# define SQLITE_TEXT     3\n#endif\n#define SQLITE3_TEXT     3\n\n/*\n** CAPI3REF: Result Values From A Query\n** KEYWORDS: {column access functions}\n** METHOD: sqlite3_stmt\n**\n** <b>Summary:</b>\n** <blockquote><table border=0 cellpadding=0 cellspacing=0>\n** <tr><td><b>sqlite3_column_blob</b><td>&rarr;<td>BLOB result\n** <tr><td><b>sqlite3_column_double</b><td>&rarr;<td>REAL result\n** <tr><td><b>sqlite3_column_int</b><td>&rarr;<td>32-bit INTEGER result\n** <tr><td><b>sqlite3_column_int64</b><td>&rarr;<td>64-bit INTEGER result\n** <tr><td><b>sqlite3_column_text</b><td>&rarr;<td>UTF-8 TEXT result\n** <tr><td><b>sqlite3_column_text16</b><td>&rarr;<td>UTF-16 TEXT result\n** <tr><td><b>sqlite3_column_value</b><td>&rarr;<td>The result as an\n** [sqlite3_value|unprotected sqlite3_value] object.\n** <tr><td>&nbsp;<td>&nbsp;<td>&nbsp;\n** <tr><td><b>sqlite3_column_bytes</b><td>&rarr;<td>Size of a BLOB\n** or a UTF-8 TEXT result in bytes\n** <tr><td><b>sqlite3_column_bytes16&nbsp;&nbsp;</b>\n** <td>&rarr;&nbsp;&nbsp;<td>Size of UTF-16\n** TEXT in bytes\n** <tr><td><b>sqlite3_column_type</b><td>&rarr;<td>Default\n** datatype of the result\n** </table></blockquote>\n**\n** <b>Details:</b>\n**\n** ^These routines return information about a single column of the current\n** result row of a query.  ^In every case the first argument is a pointer\n** to the [prepared statement] that is being evaluated (the [sqlite3_stmt*]\n** that was returned from [sqlite3_prepare_v2()] or one of its variants)\n** and the second argument is the index of the column for which information\n** should be returned. ^The leftmost column of the result set has the index 0.\n** ^The number of columns in the result can be determined using\n** [sqlite3_column_count()].\n**\n** If the SQL statement does not currently point to a valid row, or if the\n** column index is out of range, the result is undefined.\n** These routines may only be called when the most recent call to\n** [sqlite3_step()] has returned [SQLITE_ROW] and neither\n** [sqlite3_reset()] nor [sqlite3_finalize()] have been called subsequently.\n** If any of these routines are called after [sqlite3_reset()] or\n** [sqlite3_finalize()] or after [sqlite3_step()] has returned\n** something other than [SQLITE_ROW], the results are undefined.\n** If [sqlite3_step()] or [sqlite3_reset()] or [sqlite3_finalize()]\n** are called from a different thread while any of these routines\n** are pending, then the results are undefined.\n**\n** The first six interfaces (_blob, _double, _int, _int64, _text, and _text16)\n** each return the value of a result column in a specific data format.  If\n** the result column is not initially in the requested format (for example,\n** if the query returns an integer but the sqlite3_column_text() interface\n** is used to extract the value) then an automatic type conversion is performed.\n**\n** ^The sqlite3_column_type() routine returns the\n** [SQLITE_INTEGER | datatype code] for the initial data type\n** of the result column.  ^The returned value is one of [SQLITE_INTEGER],\n** [SQLITE_FLOAT], [SQLITE_TEXT], [SQLITE_BLOB], or [SQLITE_NULL].\n** The return value of sqlite3_column_type() can be used to decide which\n** of the first six interface should be used to extract the column value.\n** The value returned by sqlite3_column_type() is only meaningful if no\n** automatic type conversions have occurred for the value in question.\n** After a type conversion, the result of calling sqlite3_column_type()\n** is undefined, though harmless.  Future\n** versions of SQLite may change the behavior of sqlite3_column_type()\n** following a type conversion.\n**\n** If the result is a BLOB or a TEXT string, then the sqlite3_column_bytes()\n** or sqlite3_column_bytes16() interfaces can be used to determine the size\n** of that BLOB or string.\n**\n** ^If the result is a BLOB or UTF-8 string then the sqlite3_column_bytes()\n** routine returns the number of bytes in that BLOB or string.\n** ^If the result is a UTF-16 string, then sqlite3_column_bytes() converts\n** the string to UTF-8 and then returns the number of bytes.\n** ^If the result is a numeric value then sqlite3_column_bytes() uses\n** [sqlite3_snprintf()] to convert that value to a UTF-8 string and returns\n** the number of bytes in that string.\n** ^If the result is NULL, then sqlite3_column_bytes() returns zero.\n**\n** ^If the result is a BLOB or UTF-16 string then the sqlite3_column_bytes16()\n** routine returns the number of bytes in that BLOB or string.\n** ^If the result is a UTF-8 string, then sqlite3_column_bytes16() converts\n** the string to UTF-16 and then returns the number of bytes.\n** ^If the result is a numeric value then sqlite3_column_bytes16() uses\n** [sqlite3_snprintf()] to convert that value to a UTF-16 string and returns\n** the number of bytes in that string.\n** ^If the result is NULL, then sqlite3_column_bytes16() returns zero.\n**\n** ^The values returned by [sqlite3_column_bytes()] and\n** [sqlite3_column_bytes16()] do not include the zero terminators at the end\n** of the string.  ^For clarity: the values returned by\n** [sqlite3_column_bytes()] and [sqlite3_column_bytes16()] are the number of\n** bytes in the string, not the number of characters.\n**\n** ^Strings returned by sqlite3_column_text() and sqlite3_column_text16(),\n** even empty strings, are always zero-terminated.  ^The return\n** value from sqlite3_column_blob() for a zero-length BLOB is a NULL pointer.\n**\n** ^Strings returned by sqlite3_column_text16() always have the endianness\n** which is native to the platform, regardless of the text encoding set\n** for the database.\n**\n** <b>Warning:</b> ^The object returned by [sqlite3_column_value()] is an\n** [unprotected sqlite3_value] object.  In a multithreaded environment,\n** an unprotected sqlite3_value object may only be used safely with\n** [sqlite3_bind_value()] and [sqlite3_result_value()].\n** If the [unprotected sqlite3_value] object returned by\n** [sqlite3_column_value()] is used in any other way, including calls\n** to routines like [sqlite3_value_int()], [sqlite3_value_text()],\n** or [sqlite3_value_bytes()], the behavior is not threadsafe.\n** Hence, the sqlite3_column_value() interface\n** is normally only useful within the implementation of\n** [application-defined SQL functions] or [virtual tables], not within\n** top-level application code.\n**\n** These routines may attempt to convert the datatype of the result.\n** ^For example, if the internal representation is FLOAT and a text result\n** is requested, [sqlite3_snprintf()] is used internally to perform the\n** conversion automatically.  ^(The following table details the conversions\n** that are applied:\n**\n** <blockquote>\n** <table border=\"1\">\n** <tr><th> Internal<br>Type <th> Requested<br>Type <th>  Conversion\n**\n** <tr><td>  NULL    <td> INTEGER   <td> Result is 0\n** <tr><td>  NULL    <td>  FLOAT    <td> Result is 0.0\n** <tr><td>  NULL    <td>   TEXT    <td> Result is a NULL pointer\n** <tr><td>  NULL    <td>   BLOB    <td> Result is a NULL pointer\n** <tr><td> INTEGER  <td>  FLOAT    <td> Convert from integer to float\n** <tr><td> INTEGER  <td>   TEXT    <td> ASCII rendering of the integer\n** <tr><td> INTEGER  <td>   BLOB    <td> Same as INTEGER->TEXT\n** <tr><td>  FLOAT   <td> INTEGER   <td> [CAST] to INTEGER\n** <tr><td>  FLOAT   <td>   TEXT    <td> ASCII rendering of the float\n** <tr><td>  FLOAT   <td>   BLOB    <td> [CAST] to BLOB\n** <tr><td>  TEXT    <td> INTEGER   <td> [CAST] to INTEGER\n** <tr><td>  TEXT    <td>  FLOAT    <td> [CAST] to REAL\n** <tr><td>  TEXT    <td>   BLOB    <td> No change\n** <tr><td>  BLOB    <td> INTEGER   <td> [CAST] to INTEGER\n** <tr><td>  BLOB    <td>  FLOAT    <td> [CAST] to REAL\n** <tr><td>  BLOB    <td>   TEXT    <td> [CAST] to TEXT, ensure zero terminator\n** </table>\n** </blockquote>)^\n**\n** Note that when type conversions occur, pointers returned by prior\n** calls to sqlite3_column_blob(), sqlite3_column_text(), and/or\n** sqlite3_column_text16() may be invalidated.\n** Type conversions and pointer invalidations might occur\n** in the following cases:\n**\n** <ul>\n** <li> The initial content is a BLOB and sqlite3_column_text() or\n**      sqlite3_column_text16() is called.  A zero-terminator might\n**      need to be added to the string.</li>\n** <li> The initial content is UTF-8 text and sqlite3_column_bytes16() or\n**      sqlite3_column_text16() is called.  The content must be converted\n**      to UTF-16.</li>\n** <li> The initial content is UTF-16 text and sqlite3_column_bytes() or\n**      sqlite3_column_text() is called.  The content must be converted\n**      to UTF-8.</li>\n** </ul>\n**\n** ^Conversions between UTF-16be and UTF-16le are always done in place and do\n** not invalidate a prior pointer, though of course the content of the buffer\n** that the prior pointer references will have been modified.  Other kinds\n** of conversion are done in place when it is possible, but sometimes they\n** are not possible and in those cases prior pointers are invalidated.\n**\n** The safest policy is to invoke these routines\n** in one of the following ways:\n**\n** <ul>\n**  <li>sqlite3_column_text() followed by sqlite3_column_bytes()</li>\n**  <li>sqlite3_column_blob() followed by sqlite3_column_bytes()</li>\n**  <li>sqlite3_column_text16() followed by sqlite3_column_bytes16()</li>\n** </ul>\n**\n** In other words, you should call sqlite3_column_text(),\n** sqlite3_column_blob(), or sqlite3_column_text16() first to force the result\n** into the desired format, then invoke sqlite3_column_bytes() or\n** sqlite3_column_bytes16() to find the size of the result.  Do not mix calls\n** to sqlite3_column_text() or sqlite3_column_blob() with calls to\n** sqlite3_column_bytes16(), and do not mix calls to sqlite3_column_text16()\n** with calls to sqlite3_column_bytes().\n**\n** ^The pointers returned are valid until a type conversion occurs as\n** described above, or until [sqlite3_step()] or [sqlite3_reset()] or\n** [sqlite3_finalize()] is called.  ^The memory space used to hold strings\n** and BLOBs is freed automatically.  Do not pass the pointers returned\n** from [sqlite3_column_blob()], [sqlite3_column_text()], etc. into\n** [sqlite3_free()].\n**\n** As long as the input parameters are correct, these routines will only\n** fail if an out-of-memory error occurs during a format conversion.\n** Only the following subset of interfaces are subject to out-of-memory\n** errors:\n**\n** <ul>\n** <li> sqlite3_column_blob()\n** <li> sqlite3_column_text()\n** <li> sqlite3_column_text16()\n** <li> sqlite3_column_bytes()\n** <li> sqlite3_column_bytes16()\n** </ul>\n**\n** If an out-of-memory error occurs, then the return value from these\n** routines is the same as if the column had contained an SQL NULL value.\n** Valid SQL NULL returns can be distinguished from out-of-memory errors\n** by invoking the [sqlite3_errcode()] immediately after the suspect\n** return value is obtained and before any\n** other SQLite interface is called on the same [database connection].\n*/\nSQLITE_API const void *sqlite3_column_blob(sqlite3_stmt*, int iCol);\nSQLITE_API double sqlite3_column_double(sqlite3_stmt*, int iCol);\nSQLITE_API int sqlite3_column_int(sqlite3_stmt*, int iCol);\nSQLITE_API sqlite3_int64 sqlite3_column_int64(sqlite3_stmt*, int iCol);\nSQLITE_API const unsigned char *sqlite3_column_text(sqlite3_stmt*, int iCol);\nSQLITE_API const void *sqlite3_column_text16(sqlite3_stmt*, int iCol);\nSQLITE_API sqlite3_value *sqlite3_column_value(sqlite3_stmt*, int iCol);\nSQLITE_API int sqlite3_column_bytes(sqlite3_stmt*, int iCol);\nSQLITE_API int sqlite3_column_bytes16(sqlite3_stmt*, int iCol);\nSQLITE_API int sqlite3_column_type(sqlite3_stmt*, int iCol);\n\n/*\n** CAPI3REF: Destroy A Prepared Statement Object\n** DESTRUCTOR: sqlite3_stmt\n**\n** ^The sqlite3_finalize() function is called to delete a [prepared statement].\n** ^If the most recent evaluation of the statement encountered no errors\n** or if the statement is never been evaluated, then sqlite3_finalize() returns\n** SQLITE_OK.  ^If the most recent evaluation of statement S failed, then\n** sqlite3_finalize(S) returns the appropriate [error code] or\n** [extended error code].\n**\n** ^The sqlite3_finalize(S) routine can be called at any point during\n** the life cycle of [prepared statement] S:\n** before statement S is ever evaluated, after\n** one or more calls to [sqlite3_reset()], or after any call\n** to [sqlite3_step()] regardless of whether or not the statement has\n** completed execution.\n**\n** ^Invoking sqlite3_finalize() on a NULL pointer is a harmless no-op.\n**\n** The application must finalize every [prepared statement] in order to avoid\n** resource leaks.  It is a grievous error for the application to try to use\n** a prepared statement after it has been finalized.  Any use of a prepared\n** statement after it has been finalized can result in undefined and\n** undesirable behavior such as segfaults and heap corruption.\n*/\nSQLITE_API int sqlite3_finalize(sqlite3_stmt *pStmt);\n\n/*\n** CAPI3REF: Reset A Prepared Statement Object\n** METHOD: sqlite3_stmt\n**\n** The sqlite3_reset() function is called to reset a [prepared statement]\n** object back to its initial state, ready to be re-executed.\n** ^Any SQL statement variables that had values bound to them using\n** the [sqlite3_bind_blob | sqlite3_bind_*() API] retain their values.\n** Use [sqlite3_clear_bindings()] to reset the bindings.\n**\n** ^The [sqlite3_reset(S)] interface resets the [prepared statement] S\n** back to the beginning of its program.\n**\n** ^The return code from [sqlite3_reset(S)] indicates whether or not\n** the previous evaluation of prepared statement S completed successfully.\n** ^If [sqlite3_step(S)] has never before been called on S or if\n** [sqlite3_step(S)] has not been called since the previous call\n** to [sqlite3_reset(S)], then [sqlite3_reset(S)] will return\n** [SQLITE_OK].\n**\n** ^If the most recent call to [sqlite3_step(S)] for the\n** [prepared statement] S indicated an error, then\n** [sqlite3_reset(S)] returns an appropriate [error code].\n** ^The [sqlite3_reset(S)] interface might also return an [error code]\n** if there were no prior errors but the process of resetting\n** the prepared statement caused a new error. ^For example, if an\n** [INSERT] statement with a [RETURNING] clause is only stepped one time,\n** that one call to [sqlite3_step(S)] might return SQLITE_ROW but\n** the overall statement might still fail and the [sqlite3_reset(S)] call\n** might return SQLITE_BUSY if locking constraints prevent the\n** database change from committing.  Therefore, it is important that\n** applications check the return code from [sqlite3_reset(S)] even if\n** no prior call to [sqlite3_step(S)] indicated a problem.\n**\n** ^The [sqlite3_reset(S)] interface does not change the values\n** of any [sqlite3_bind_blob|bindings] on the [prepared statement] S.\n*/\nSQLITE_API int sqlite3_reset(sqlite3_stmt *pStmt);\n\n\n/*\n** CAPI3REF: Create Or Redefine SQL Functions\n** KEYWORDS: {function creation routines}\n** METHOD: sqlite3\n**\n** ^These functions (collectively known as \"function creation routines\")\n** are used to add SQL functions or aggregates or to redefine the behavior\n** of existing SQL functions or aggregates. The only differences between\n** the three \"sqlite3_create_function*\" routines are the text encoding\n** expected for the second parameter (the name of the function being\n** created) and the presence or absence of a destructor callback for\n** the application data pointer. Function sqlite3_create_window_function()\n** is similar, but allows the user to supply the extra callback functions\n** needed by [aggregate window functions].\n**\n** ^The first parameter is the [database connection] to which the SQL\n** function is to be added.  ^If an application uses more than one database\n** connection then application-defined SQL functions must be added\n** to each database connection separately.\n**\n** ^The second parameter is the name of the SQL function to be created or\n** redefined.  ^The length of the name is limited to 255 bytes in a UTF-8\n** representation, exclusive of the zero-terminator.  ^Note that the name\n** length limit is in UTF-8 bytes, not characters nor UTF-16 bytes.\n** ^Any attempt to create a function with a longer name\n** will result in [SQLITE_MISUSE] being returned.\n**\n** ^The third parameter (nArg)\n** is the number of arguments that the SQL function or\n** aggregate takes. ^If this parameter is -1, then the SQL function or\n** aggregate may take any number of arguments between 0 and the limit\n** set by [sqlite3_limit]([SQLITE_LIMIT_FUNCTION_ARG]).  If the third\n** parameter is less than -1 or greater than 127 then the behavior is\n** undefined.\n**\n** ^The fourth parameter, eTextRep, specifies what\n** [SQLITE_UTF8 | text encoding] this SQL function prefers for\n** its parameters.  The application should set this parameter to\n** [SQLITE_UTF16LE] if the function implementation invokes\n** [sqlite3_value_text16le()] on an input, or [SQLITE_UTF16BE] if the\n** implementation invokes [sqlite3_value_text16be()] on an input, or\n** [SQLITE_UTF16] if [sqlite3_value_text16()] is used, or [SQLITE_UTF8]\n** otherwise.  ^The same SQL function may be registered multiple times using\n** different preferred text encodings, with different implementations for\n** each encoding.\n** ^When multiple implementations of the same function are available, SQLite\n** will pick the one that involves the least amount of data conversion.\n**\n** ^The fourth parameter may optionally be ORed with [SQLITE_DETERMINISTIC]\n** to signal that the function will always return the same result given\n** the same inputs within a single SQL statement.  Most SQL functions are\n** deterministic.  The built-in [random()] SQL function is an example of a\n** function that is not deterministic.  The SQLite query planner is able to\n** perform additional optimizations on deterministic functions, so use\n** of the [SQLITE_DETERMINISTIC] flag is recommended where possible.\n**\n** ^The fourth parameter may also optionally include the [SQLITE_DIRECTONLY]\n** flag, which if present prevents the function from being invoked from\n** within VIEWs, TRIGGERs, CHECK constraints, generated column expressions,\n** index expressions, or the WHERE clause of partial indexes.\n**\n** For best security, the [SQLITE_DIRECTONLY] flag is recommended for\n** all application-defined SQL functions that do not need to be\n** used inside of triggers, view, CHECK constraints, or other elements of\n** the database schema.  This flags is especially recommended for SQL\n** functions that have side effects or reveal internal application state.\n** Without this flag, an attacker might be able to modify the schema of\n** a database file to include invocations of the function with parameters\n** chosen by the attacker, which the application will then execute when\n** the database file is opened and read.\n**\n** ^(The fifth parameter is an arbitrary pointer.  The implementation of the\n** function can gain access to this pointer using [sqlite3_user_data()].)^\n**\n** ^The sixth, seventh and eighth parameters passed to the three\n** \"sqlite3_create_function*\" functions, xFunc, xStep and xFinal, are\n** pointers to C-language functions that implement the SQL function or\n** aggregate. ^A scalar SQL function requires an implementation of the xFunc\n** callback only; NULL pointers must be passed as the xStep and xFinal\n** parameters. ^An aggregate SQL function requires an implementation of xStep\n** and xFinal and NULL pointer must be passed for xFunc. ^To delete an existing\n** SQL function or aggregate, pass NULL pointers for all three function\n** callbacks.\n**\n** ^The sixth, seventh, eighth and ninth parameters (xStep, xFinal, xValue\n** and xInverse) passed to sqlite3_create_window_function are pointers to\n** C-language callbacks that implement the new function. xStep and xFinal\n** must both be non-NULL. xValue and xInverse may either both be NULL, in\n** which case a regular aggregate function is created, or must both be\n** non-NULL, in which case the new function may be used as either an aggregate\n** or aggregate window function. More details regarding the implementation\n** of aggregate window functions are\n** [user-defined window functions|available here].\n**\n** ^(If the final parameter to sqlite3_create_function_v2() or\n** sqlite3_create_window_function() is not NULL, then it is destructor for\n** the application data pointer. The destructor is invoked when the function\n** is deleted, either by being overloaded or when the database connection\n** closes.)^ ^The destructor is also invoked if the call to\n** sqlite3_create_function_v2() fails.  ^When the destructor callback is\n** invoked, it is passed a single argument which is a copy of the application\n** data pointer which was the fifth parameter to sqlite3_create_function_v2().\n**\n** ^It is permitted to register multiple implementations of the same\n** functions with the same name but with either differing numbers of\n** arguments or differing preferred text encodings.  ^SQLite will use\n** the implementation that most closely matches the way in which the\n** SQL function is used.  ^A function implementation with a non-negative\n** nArg parameter is a better match than a function implementation with\n** a negative nArg.  ^A function where the preferred text encoding\n** matches the database encoding is a better\n** match than a function where the encoding is different.\n** ^A function where the encoding difference is between UTF16le and UTF16be\n** is a closer match than a function where the encoding difference is\n** between UTF8 and UTF16.\n**\n** ^Built-in functions may be overloaded by new application-defined functions.\n**\n** ^An application-defined function is permitted to call other\n** SQLite interfaces.  However, such calls must not\n** close the database connection nor finalize or reset the prepared\n** statement in which the function is running.\n*/\nSQLITE_API int sqlite3_create_function(\n  sqlite3 *db,\n  const char *zFunctionName,\n  int nArg,\n  int eTextRep,\n  void *pApp,\n  void (*xFunc)(sqlite3_context*,int,sqlite3_value**),\n  void (*xStep)(sqlite3_context*,int,sqlite3_value**),\n  void (*xFinal)(sqlite3_context*)\n);\nSQLITE_API int sqlite3_create_function16(\n  sqlite3 *db,\n  const void *zFunctionName,\n  int nArg,\n  int eTextRep,\n  void *pApp,\n  void (*xFunc)(sqlite3_context*,int,sqlite3_value**),\n  void (*xStep)(sqlite3_context*,int,sqlite3_value**),\n  void (*xFinal)(sqlite3_context*)\n);\nSQLITE_API int sqlite3_create_function_v2(\n  sqlite3 *db,\n  const char *zFunctionName,\n  int nArg,\n  int eTextRep,\n  void *pApp,\n  void (*xFunc)(sqlite3_context*,int,sqlite3_value**),\n  void (*xStep)(sqlite3_context*,int,sqlite3_value**),\n  void (*xFinal)(sqlite3_context*),\n  void(*xDestroy)(void*)\n);\nSQLITE_API int sqlite3_create_window_function(\n  sqlite3 *db,\n  const char *zFunctionName,\n  int nArg,\n  int eTextRep,\n  void *pApp,\n  void (*xStep)(sqlite3_context*,int,sqlite3_value**),\n  void (*xFinal)(sqlite3_context*),\n  void (*xValue)(sqlite3_context*),\n  void (*xInverse)(sqlite3_context*,int,sqlite3_value**),\n  void(*xDestroy)(void*)\n);\n\n/*\n** CAPI3REF: Text Encodings\n**\n** These constant define integer codes that represent the various\n** text encodings supported by SQLite.\n*/\n#define SQLITE_UTF8           1    /* IMP: R-37514-35566 */\n#define SQLITE_UTF16LE        2    /* IMP: R-03371-37637 */\n#define SQLITE_UTF16BE        3    /* IMP: R-51971-34154 */\n#define SQLITE_UTF16          4    /* Use native byte order */\n#define SQLITE_ANY            5    /* Deprecated */\n#define SQLITE_UTF16_ALIGNED  8    /* sqlite3_create_collation only */\n\n/*\n** CAPI3REF: Function Flags\n**\n** These constants may be ORed together with the\n** [SQLITE_UTF8 | preferred text encoding] as the fourth argument\n** to [sqlite3_create_function()], [sqlite3_create_function16()], or\n** [sqlite3_create_function_v2()].\n**\n** <dl>\n** [[SQLITE_DETERMINISTIC]] <dt>SQLITE_DETERMINISTIC</dt><dd>\n** The SQLITE_DETERMINISTIC flag means that the new function always gives\n** the same output when the input parameters are the same.\n** The [abs|abs() function] is deterministic, for example, but\n** [randomblob|randomblob()] is not.  Functions must\n** be deterministic in order to be used in certain contexts such as\n** with the WHERE clause of [partial indexes] or in [generated columns].\n** SQLite might also optimize deterministic functions by factoring them\n** out of inner loops.\n** </dd>\n**\n** [[SQLITE_DIRECTONLY]] <dt>SQLITE_DIRECTONLY</dt><dd>\n** The SQLITE_DIRECTONLY flag means that the function may only be invoked\n** from top-level SQL, and cannot be used in VIEWs or TRIGGERs nor in\n** schema structures such as [CHECK constraints], [DEFAULT clauses],\n** [expression indexes], [partial indexes], or [generated columns].\n** <p>\n** The SQLITE_DIRECTONLY flag is recommended for any\n** [application-defined SQL function]\n** that has side-effects or that could potentially leak sensitive information.\n** This will prevent attacks in which an application is tricked\n** into using a database file that has had its schema surreptitiously\n** modified to invoke the application-defined function in ways that are\n** harmful.\n** <p>\n** Some people say it is good practice to set SQLITE_DIRECTONLY on all\n** [application-defined SQL functions], regardless of whether or not they\n** are security sensitive, as doing so prevents those functions from being used\n** inside of the database schema, and thus ensures that the database\n** can be inspected and modified using generic tools (such as the [CLI])\n** that do not have access to the application-defined functions.\n** </dd>\n**\n** [[SQLITE_INNOCUOUS]] <dt>SQLITE_INNOCUOUS</dt><dd>\n** The SQLITE_INNOCUOUS flag means that the function is unlikely\n** to cause problems even if misused.  An innocuous function should have\n** no side effects and should not depend on any values other than its\n** input parameters. The [abs|abs() function] is an example of an\n** innocuous function.\n** The [load_extension() SQL function] is not innocuous because of its\n** side effects.\n** <p> SQLITE_INNOCUOUS is similar to SQLITE_DETERMINISTIC, but is not\n** exactly the same.  The [random|random() function] is an example of a\n** function that is innocuous but not deterministic.\n** <p>Some heightened security settings\n** ([SQLITE_DBCONFIG_TRUSTED_SCHEMA] and [PRAGMA trusted_schema=OFF])\n** disable the use of SQL functions inside views and triggers and in\n** schema structures such as [CHECK constraints], [DEFAULT clauses],\n** [expression indexes], [partial indexes], and [generated columns] unless\n** the function is tagged with SQLITE_INNOCUOUS.  Most built-in functions\n** are innocuous.  Developers are advised to avoid using the\n** SQLITE_INNOCUOUS flag for application-defined functions unless the\n** function has been carefully audited and found to be free of potentially\n** security-adverse side-effects and information-leaks.\n** </dd>\n**\n** [[SQLITE_SUBTYPE]] <dt>SQLITE_SUBTYPE</dt><dd>\n** The SQLITE_SUBTYPE flag indicates to SQLite that a function might call\n** [sqlite3_value_subtype()] to inspect the sub-types of its arguments.\n** This flag instructs SQLite to omit some corner-case optimizations that\n** might disrupt the operation of the [sqlite3_value_subtype()] function,\n** causing it to return zero rather than the correct subtype().\n** SQL functions that invokes [sqlite3_value_subtype()] should have this\n** property.  If the SQLITE_SUBTYPE property is omitted, then the return\n** value from [sqlite3_value_subtype()] might sometimes be zero even though\n** a non-zero subtype was specified by the function argument expression.\n**\n** [[SQLITE_RESULT_SUBTYPE]] <dt>SQLITE_RESULT_SUBTYPE</dt><dd>\n** The SQLITE_RESULT_SUBTYPE flag indicates to SQLite that a function might call\n** [sqlite3_result_subtype()] to cause a sub-type to be associated with its\n** result.\n** Every function that invokes [sqlite3_result_subtype()] should have this\n** property.  If it does not, then the call to [sqlite3_result_subtype()]\n** might become a no-op if the function is used as term in an\n** [expression index].  On the other hand, SQL functions that never invoke\n** [sqlite3_result_subtype()] should avoid setting this property, as the\n** purpose of this property is to disable certain optimizations that are\n** incompatible with subtypes.\n** </dd>\n** </dl>\n*/\n#define SQLITE_DETERMINISTIC    0x000000800\n#define SQLITE_DIRECTONLY       0x000080000\n#define SQLITE_SUBTYPE          0x000100000\n#define SQLITE_INNOCUOUS        0x000200000\n#define SQLITE_RESULT_SUBTYPE   0x001000000\n\n/*\n** CAPI3REF: Deprecated Functions\n** DEPRECATED\n**\n** These functions are [deprecated].  In order to maintain\n** backwards compatibility with older code, these functions continue\n** to be supported.  However, new applications should avoid\n** the use of these functions.  To encourage programmers to avoid\n** these functions, we will not explain what they do.\n*/\n#ifndef SQLITE_OMIT_DEPRECATED\nSQLITE_API SQLITE_DEPRECATED int sqlite3_aggregate_count(sqlite3_context*);\nSQLITE_API SQLITE_DEPRECATED int sqlite3_expired(sqlite3_stmt*);\nSQLITE_API SQLITE_DEPRECATED int sqlite3_transfer_bindings(sqlite3_stmt*, sqlite3_stmt*);\nSQLITE_API SQLITE_DEPRECATED int sqlite3_global_recover(void);\nSQLITE_API SQLITE_DEPRECATED void sqlite3_thread_cleanup(void);\nSQLITE_API SQLITE_DEPRECATED int sqlite3_memory_alarm(void(*)(void*,sqlite3_int64,int),\n                      void*,sqlite3_int64);\n#endif\n\n/*\n** CAPI3REF: Obtaining SQL Values\n** METHOD: sqlite3_value\n**\n** <b>Summary:</b>\n** <blockquote><table border=0 cellpadding=0 cellspacing=0>\n** <tr><td><b>sqlite3_value_blob</b><td>&rarr;<td>BLOB value\n** <tr><td><b>sqlite3_value_double</b><td>&rarr;<td>REAL value\n** <tr><td><b>sqlite3_value_int</b><td>&rarr;<td>32-bit INTEGER value\n** <tr><td><b>sqlite3_value_int64</b><td>&rarr;<td>64-bit INTEGER value\n** <tr><td><b>sqlite3_value_pointer</b><td>&rarr;<td>Pointer value\n** <tr><td><b>sqlite3_value_text</b><td>&rarr;<td>UTF-8 TEXT value\n** <tr><td><b>sqlite3_value_text16</b><td>&rarr;<td>UTF-16 TEXT value in\n** the native byteorder\n** <tr><td><b>sqlite3_value_text16be</b><td>&rarr;<td>UTF-16be TEXT value\n** <tr><td><b>sqlite3_value_text16le</b><td>&rarr;<td>UTF-16le TEXT value\n** <tr><td>&nbsp;<td>&nbsp;<td>&nbsp;\n** <tr><td><b>sqlite3_value_bytes</b><td>&rarr;<td>Size of a BLOB\n** or a UTF-8 TEXT in bytes\n** <tr><td><b>sqlite3_value_bytes16&nbsp;&nbsp;</b>\n** <td>&rarr;&nbsp;&nbsp;<td>Size of UTF-16\n** TEXT in bytes\n** <tr><td><b>sqlite3_value_type</b><td>&rarr;<td>Default\n** datatype of the value\n** <tr><td><b>sqlite3_value_numeric_type&nbsp;&nbsp;</b>\n** <td>&rarr;&nbsp;&nbsp;<td>Best numeric datatype of the value\n** <tr><td><b>sqlite3_value_nochange&nbsp;&nbsp;</b>\n** <td>&rarr;&nbsp;&nbsp;<td>True if the column is unchanged in an UPDATE\n** against a virtual table.\n** <tr><td><b>sqlite3_value_frombind&nbsp;&nbsp;</b>\n** <td>&rarr;&nbsp;&nbsp;<td>True if value originated from a [bound parameter]\n** </table></blockquote>\n**\n** <b>Details:</b>\n**\n** These routines extract type, size, and content information from\n** [protected sqlite3_value] objects.  Protected sqlite3_value objects\n** are used to pass parameter information into the functions that\n** implement [application-defined SQL functions] and [virtual tables].\n**\n** These routines work only with [protected sqlite3_value] objects.\n** Any attempt to use these routines on an [unprotected sqlite3_value]\n** is not threadsafe.\n**\n** ^These routines work just like the corresponding [column access functions]\n** except that these routines take a single [protected sqlite3_value] object\n** pointer instead of a [sqlite3_stmt*] pointer and an integer column number.\n**\n** ^The sqlite3_value_text16() interface extracts a UTF-16 string\n** in the native byte-order of the host machine.  ^The\n** sqlite3_value_text16be() and sqlite3_value_text16le() interfaces\n** extract UTF-16 strings as big-endian and little-endian respectively.\n**\n** ^If [sqlite3_value] object V was initialized\n** using [sqlite3_bind_pointer(S,I,P,X,D)] or [sqlite3_result_pointer(C,P,X,D)]\n** and if X and Y are strings that compare equal according to strcmp(X,Y),\n** then sqlite3_value_pointer(V,Y) will return the pointer P.  ^Otherwise,\n** sqlite3_value_pointer(V,Y) returns a NULL. The sqlite3_bind_pointer()\n** routine is part of the [pointer passing interface] added for SQLite 3.20.0.\n**\n** ^(The sqlite3_value_type(V) interface returns the\n** [SQLITE_INTEGER | datatype code] for the initial datatype of the\n** [sqlite3_value] object V. The returned value is one of [SQLITE_INTEGER],\n** [SQLITE_FLOAT], [SQLITE_TEXT], [SQLITE_BLOB], or [SQLITE_NULL].)^\n** Other interfaces might change the datatype for an sqlite3_value object.\n** For example, if the datatype is initially SQLITE_INTEGER and\n** sqlite3_value_text(V) is called to extract a text value for that\n** integer, then subsequent calls to sqlite3_value_type(V) might return\n** SQLITE_TEXT.  Whether or not a persistent internal datatype conversion\n** occurs is undefined and may change from one release of SQLite to the next.\n**\n** ^(The sqlite3_value_numeric_type() interface attempts to apply\n** numeric affinity to the value.  This means that an attempt is\n** made to convert the value to an integer or floating point.  If\n** such a conversion is possible without loss of information (in other\n** words, if the value is a string that looks like a number)\n** then the conversion is performed.  Otherwise no conversion occurs.\n** The [SQLITE_INTEGER | datatype] after conversion is returned.)^\n**\n** ^Within the [xUpdate] method of a [virtual table], the\n** sqlite3_value_nochange(X) interface returns true if and only if\n** the column corresponding to X is unchanged by the UPDATE operation\n** that the xUpdate method call was invoked to implement and if\n** and the prior [xColumn] method call that was invoked to extracted\n** the value for that column returned without setting a result (probably\n** because it queried [sqlite3_vtab_nochange()] and found that the column\n** was unchanging).  ^Within an [xUpdate] method, any value for which\n** sqlite3_value_nochange(X) is true will in all other respects appear\n** to be a NULL value.  If sqlite3_value_nochange(X) is invoked anywhere other\n** than within an [xUpdate] method call for an UPDATE statement, then\n** the return value is arbitrary and meaningless.\n**\n** ^The sqlite3_value_frombind(X) interface returns non-zero if the\n** value X originated from one of the [sqlite3_bind_int|sqlite3_bind()]\n** interfaces.  ^If X comes from an SQL literal value, or a table column,\n** or an expression, then sqlite3_value_frombind(X) returns zero.\n**\n** Please pay particular attention to the fact that the pointer returned\n** from [sqlite3_value_blob()], [sqlite3_value_text()], or\n** [sqlite3_value_text16()] can be invalidated by a subsequent call to\n** [sqlite3_value_bytes()], [sqlite3_value_bytes16()], [sqlite3_value_text()],\n** or [sqlite3_value_text16()].\n**\n** These routines must be called from the same thread as\n** the SQL function that supplied the [sqlite3_value*] parameters.\n**\n** As long as the input parameter is correct, these routines can only\n** fail if an out-of-memory error occurs during a format conversion.\n** Only the following subset of interfaces are subject to out-of-memory\n** errors:\n**\n** <ul>\n** <li> sqlite3_value_blob()\n** <li> sqlite3_value_text()\n** <li> sqlite3_value_text16()\n** <li> sqlite3_value_text16le()\n** <li> sqlite3_value_text16be()\n** <li> sqlite3_value_bytes()\n** <li> sqlite3_value_bytes16()\n** </ul>\n**\n** If an out-of-memory error occurs, then the return value from these\n** routines is the same as if the column had contained an SQL NULL value.\n** Valid SQL NULL returns can be distinguished from out-of-memory errors\n** by invoking the [sqlite3_errcode()] immediately after the suspect\n** return value is obtained and before any\n** other SQLite interface is called on the same [database connection].\n*/\nSQLITE_API const void *sqlite3_value_blob(sqlite3_value*);\nSQLITE_API double sqlite3_value_double(sqlite3_value*);\nSQLITE_API int sqlite3_value_int(sqlite3_value*);\nSQLITE_API sqlite3_int64 sqlite3_value_int64(sqlite3_value*);\nSQLITE_API void *sqlite3_value_pointer(sqlite3_value*, const char*);\nSQLITE_API const unsigned char *sqlite3_value_text(sqlite3_value*);\nSQLITE_API const void *sqlite3_value_text16(sqlite3_value*);\nSQLITE_API const void *sqlite3_value_text16le(sqlite3_value*);\nSQLITE_API const void *sqlite3_value_text16be(sqlite3_value*);\nSQLITE_API int sqlite3_value_bytes(sqlite3_value*);\nSQLITE_API int sqlite3_value_bytes16(sqlite3_value*);\nSQLITE_API int sqlite3_value_type(sqlite3_value*);\nSQLITE_API int sqlite3_value_numeric_type(sqlite3_value*);\nSQLITE_API int sqlite3_value_nochange(sqlite3_value*);\nSQLITE_API int sqlite3_value_frombind(sqlite3_value*);\n\n/*\n** CAPI3REF: Report the internal text encoding state of an sqlite3_value object\n** METHOD: sqlite3_value\n**\n** ^(The sqlite3_value_encoding(X) interface returns one of [SQLITE_UTF8],\n** [SQLITE_UTF16BE], or [SQLITE_UTF16LE] according to the current text encoding\n** of the value X, assuming that X has type TEXT.)^  If sqlite3_value_type(X)\n** returns something other than SQLITE_TEXT, then the return value from\n** sqlite3_value_encoding(X) is meaningless.  ^Calls to\n** [sqlite3_value_text(X)], [sqlite3_value_text16(X)], [sqlite3_value_text16be(X)],\n** [sqlite3_value_text16le(X)], [sqlite3_value_bytes(X)], or\n** [sqlite3_value_bytes16(X)] might change the encoding of the value X and\n** thus change the return from subsequent calls to sqlite3_value_encoding(X).\n**\n** This routine is intended for used by applications that test and validate\n** the SQLite implementation.  This routine is inquiring about the opaque\n** internal state of an [sqlite3_value] object.  Ordinary applications should\n** not need to know what the internal state of an sqlite3_value object is and\n** hence should not need to use this interface.\n*/\nSQLITE_API int sqlite3_value_encoding(sqlite3_value*);\n\n/*\n** CAPI3REF: Finding The Subtype Of SQL Values\n** METHOD: sqlite3_value\n**\n** The sqlite3_value_subtype(V) function returns the subtype for\n** an [application-defined SQL function] argument V.  The subtype\n** information can be used to pass a limited amount of context from\n** one SQL function to another.  Use the [sqlite3_result_subtype()]\n** routine to set the subtype for the return value of an SQL function.\n**\n** Every [application-defined SQL function] that invoke this interface\n** should include the [SQLITE_SUBTYPE] property in the text\n** encoding argument when the function is [sqlite3_create_function|registered].\n** If the [SQLITE_SUBTYPE] property is omitted, then sqlite3_value_subtype()\n** might return zero instead of the upstream subtype in some corner cases.\n*/\nSQLITE_API unsigned int sqlite3_value_subtype(sqlite3_value*);\n\n/*\n** CAPI3REF: Copy And Free SQL Values\n** METHOD: sqlite3_value\n**\n** ^The sqlite3_value_dup(V) interface makes a copy of the [sqlite3_value]\n** object D and returns a pointer to that copy.  ^The [sqlite3_value] returned\n** is a [protected sqlite3_value] object even if the input is not.\n** ^The sqlite3_value_dup(V) interface returns NULL if V is NULL or if a\n** memory allocation fails. ^If V is a [pointer value], then the result\n** of sqlite3_value_dup(V) is a NULL value.\n**\n** ^The sqlite3_value_free(V) interface frees an [sqlite3_value] object\n** previously obtained from [sqlite3_value_dup()].  ^If V is a NULL pointer\n** then sqlite3_value_free(V) is a harmless no-op.\n*/\nSQLITE_API sqlite3_value *sqlite3_value_dup(const sqlite3_value*);\nSQLITE_API void sqlite3_value_free(sqlite3_value*);\n\n/*\n** CAPI3REF: Obtain Aggregate Function Context\n** METHOD: sqlite3_context\n**\n** Implementations of aggregate SQL functions use this\n** routine to allocate memory for storing their state.\n**\n** ^The first time the sqlite3_aggregate_context(C,N) routine is called\n** for a particular aggregate function, SQLite allocates\n** N bytes of memory, zeroes out that memory, and returns a pointer\n** to the new memory. ^On second and subsequent calls to\n** sqlite3_aggregate_context() for the same aggregate function instance,\n** the same buffer is returned.  Sqlite3_aggregate_context() is normally\n** called once for each invocation of the xStep callback and then one\n** last time when the xFinal callback is invoked.  ^(When no rows match\n** an aggregate query, the xStep() callback of the aggregate function\n** implementation is never called and xFinal() is called exactly once.\n** In those cases, sqlite3_aggregate_context() might be called for the\n** first time from within xFinal().)^\n**\n** ^The sqlite3_aggregate_context(C,N) routine returns a NULL pointer\n** when first called if N is less than or equal to zero or if a memory\n** allocation error occurs.\n**\n** ^(The amount of space allocated by sqlite3_aggregate_context(C,N) is\n** determined by the N parameter on first successful call.  Changing the\n** value of N in any subsequent call to sqlite3_aggregate_context() within\n** the same aggregate function instance will not resize the memory\n** allocation.)^  Within the xFinal callback, it is customary to set\n** N=0 in calls to sqlite3_aggregate_context(C,N) so that no\n** pointless memory allocations occur.\n**\n** ^SQLite automatically frees the memory allocated by\n** sqlite3_aggregate_context() when the aggregate query concludes.\n**\n** The first parameter must be a copy of the\n** [sqlite3_context | SQL function context] that is the first parameter\n** to the xStep or xFinal callback routine that implements the aggregate\n** function.\n**\n** This routine must be called from the same thread in which\n** the aggregate SQL function is running.\n*/\nSQLITE_API void *sqlite3_aggregate_context(sqlite3_context*, int nBytes);\n\n/*\n** CAPI3REF: User Data For Functions\n** METHOD: sqlite3_context\n**\n** ^The sqlite3_user_data() interface returns a copy of\n** the pointer that was the pUserData parameter (the 5th parameter)\n** of the [sqlite3_create_function()]\n** and [sqlite3_create_function16()] routines that originally\n** registered the application defined function.\n**\n** This routine must be called from the same thread in which\n** the application-defined function is running.\n*/\nSQLITE_API void *sqlite3_user_data(sqlite3_context*);\n\n/*\n** CAPI3REF: Database Connection For Functions\n** METHOD: sqlite3_context\n**\n** ^The sqlite3_context_db_handle() interface returns a copy of\n** the pointer to the [database connection] (the 1st parameter)\n** of the [sqlite3_create_function()]\n** and [sqlite3_create_function16()] routines that originally\n** registered the application defined function.\n*/\nSQLITE_API sqlite3 *sqlite3_context_db_handle(sqlite3_context*);\n\n/*\n** CAPI3REF: Function Auxiliary Data\n** METHOD: sqlite3_context\n**\n** These functions may be used by (non-aggregate) SQL functions to\n** associate auxiliary data with argument values. If the same argument\n** value is passed to multiple invocations of the same SQL function during\n** query execution, under some circumstances the associated auxiliary data\n** might be preserved.  An example of where this might be useful is in a\n** regular-expression matching function. The compiled version of the regular\n** expression can be stored as auxiliary data associated with the pattern string.\n** Then as long as the pattern string remains the same,\n** the compiled regular expression can be reused on multiple\n** invocations of the same function.\n**\n** ^The sqlite3_get_auxdata(C,N) interface returns a pointer to the auxiliary data\n** associated by the sqlite3_set_auxdata(C,N,P,X) function with the Nth argument\n** value to the application-defined function.  ^N is zero for the left-most\n** function argument.  ^If there is no auxiliary data\n** associated with the function argument, the sqlite3_get_auxdata(C,N) interface\n** returns a NULL pointer.\n**\n** ^The sqlite3_set_auxdata(C,N,P,X) interface saves P as auxiliary data for the\n** N-th argument of the application-defined function.  ^Subsequent\n** calls to sqlite3_get_auxdata(C,N) return P from the most recent\n** sqlite3_set_auxdata(C,N,P,X) call if the auxiliary data is still valid or\n** NULL if the auxiliary data has been discarded.\n** ^After each call to sqlite3_set_auxdata(C,N,P,X) where X is not NULL,\n** SQLite will invoke the destructor function X with parameter P exactly\n** once, when the auxiliary data is discarded.\n** SQLite is free to discard the auxiliary data at any time, including: <ul>\n** <li> ^(when the corresponding function parameter changes)^, or\n** <li> ^(when [sqlite3_reset()] or [sqlite3_finalize()] is called for the\n**      SQL statement)^, or\n** <li> ^(when sqlite3_set_auxdata() is invoked again on the same\n**       parameter)^, or\n** <li> ^(during the original sqlite3_set_auxdata() call when a memory\n**      allocation error occurs.)^\n** <li> ^(during the original sqlite3_set_auxdata() call if the function\n**      is evaluated during query planning instead of during query execution,\n**      as sometimes happens with [SQLITE_ENABLE_STAT4].)^ </ul>\n**\n** Note the last two bullets in particular.  The destructor X in\n** sqlite3_set_auxdata(C,N,P,X) might be called immediately, before the\n** sqlite3_set_auxdata() interface even returns.  Hence sqlite3_set_auxdata()\n** should be called near the end of the function implementation and the\n** function implementation should not make any use of P after\n** sqlite3_set_auxdata() has been called.  Furthermore, a call to\n** sqlite3_get_auxdata() that occurs immediately after a corresponding call\n** to sqlite3_set_auxdata() might still return NULL if an out-of-memory\n** condition occurred during the sqlite3_set_auxdata() call or if the\n** function is being evaluated during query planning rather than during\n** query execution.\n**\n** ^(In practice, auxiliary data is preserved between function calls for\n** function parameters that are compile-time constants, including literal\n** values and [parameters] and expressions composed from the same.)^\n**\n** The value of the N parameter to these interfaces should be non-negative.\n** Future enhancements may make use of negative N values to define new\n** kinds of function caching behavior.\n**\n** These routines must be called from the same thread in which\n** the SQL function is running.\n**\n** See also: [sqlite3_get_clientdata()] and [sqlite3_set_clientdata()].\n*/\nSQLITE_API void *sqlite3_get_auxdata(sqlite3_context*, int N);\nSQLITE_API void sqlite3_set_auxdata(sqlite3_context*, int N, void*, void (*)(void*));\n\n/*\n** CAPI3REF: Database Connection Client Data\n** METHOD: sqlite3\n**\n** These functions are used to associate one or more named pointers\n** with a [database connection].\n** A call to sqlite3_set_clientdata(D,N,P,X) causes the pointer P\n** to be attached to [database connection] D using name N.  Subsequent\n** calls to sqlite3_get_clientdata(D,N) will return a copy of pointer P\n** or a NULL pointer if there were no prior calls to\n** sqlite3_set_clientdata() with the same values of D and N.\n** Names are compared using strcmp() and are thus case sensitive.\n**\n** If P and X are both non-NULL, then the destructor X is invoked with\n** argument P on the first of the following occurrences:\n** <ul>\n** <li> An out-of-memory error occurs during the call to\n**      sqlite3_set_clientdata() which attempts to register pointer P.\n** <li> A subsequent call to sqlite3_set_clientdata(D,N,P,X) is made\n**      with the same D and N parameters.\n** <li> The database connection closes.  SQLite does not make any guarantees\n**      about the order in which destructors are called, only that all\n**      destructors will be called exactly once at some point during the\n**      database connection closing process.\n** </ul>\n**\n** SQLite does not do anything with client data other than invoke\n** destructors on the client data at the appropriate time.  The intended\n** use for client data is to provide a mechanism for wrapper libraries\n** to store additional information about an SQLite database connection.\n**\n** There is no limit (other than available memory) on the number of different\n** client data pointers (with different names) that can be attached to a\n** single database connection.  However, the implementation is optimized\n** for the case of having only one or two different client data names.\n** Applications and wrapper libraries are discouraged from using more than\n** one client data name each.\n**\n** There is no way to enumerate the client data pointers\n** associated with a database connection.  The N parameter can be thought\n** of as a secret key such that only code that knows the secret key is able\n** to access the associated data.\n**\n** Security Warning:  These interfaces should not be exposed in scripting\n** languages or in other circumstances where it might be possible for an\n** an attacker to invoke them.  Any agent that can invoke these interfaces\n** can probably also take control of the process.\n**\n** Database connection client data is only available for SQLite\n** version 3.44.0 ([dateof:3.44.0]) and later.\n**\n** See also: [sqlite3_set_auxdata()] and [sqlite3_get_auxdata()].\n*/\nSQLITE_API void *sqlite3_get_clientdata(sqlite3*,const char*);\nSQLITE_API int sqlite3_set_clientdata(sqlite3*, const char*, void*, void(*)(void*));\n\n/*\n** CAPI3REF: Constants Defining Special Destructor Behavior\n**\n** These are special values for the destructor that is passed in as the\n** final argument to routines like [sqlite3_result_blob()].  ^If the destructor\n** argument is SQLITE_STATIC, it means that the content pointer is constant\n** and will never change.  It does not need to be destroyed.  ^The\n** SQLITE_TRANSIENT value means that the content will likely change in\n** the near future and that SQLite should make its own private copy of\n** the content before returning.\n**\n** The typedef is necessary to work around problems in certain\n** C++ compilers.\n*/\ntypedef void (*sqlite3_destructor_type)(void*);\n#define SQLITE_STATIC      ((sqlite3_destructor_type)0)\n#define SQLITE_TRANSIENT   ((sqlite3_destructor_type)-1)\n\n/*\n** CAPI3REF: Setting The Result Of An SQL Function\n** METHOD: sqlite3_context\n**\n** These routines are used by the xFunc or xFinal callbacks that\n** implement SQL functions and aggregates.  See\n** [sqlite3_create_function()] and [sqlite3_create_function16()]\n** for additional information.\n**\n** These functions work very much like the [parameter binding] family of\n** functions used to bind values to host parameters in prepared statements.\n** Refer to the [SQL parameter] documentation for additional information.\n**\n** ^The sqlite3_result_blob() interface sets the result from\n** an application-defined function to be the BLOB whose content is pointed\n** to by the second parameter and which is N bytes long where N is the\n** third parameter.\n**\n** ^The sqlite3_result_zeroblob(C,N) and sqlite3_result_zeroblob64(C,N)\n** interfaces set the result of the application-defined function to be\n** a BLOB containing all zero bytes and N bytes in size.\n**\n** ^The sqlite3_result_double() interface sets the result from\n** an application-defined function to be a floating point value specified\n** by its 2nd argument.\n**\n** ^The sqlite3_result_error() and sqlite3_result_error16() functions\n** cause the implemented SQL function to throw an exception.\n** ^SQLite uses the string pointed to by the\n** 2nd parameter of sqlite3_result_error() or sqlite3_result_error16()\n** as the text of an error message.  ^SQLite interprets the error\n** message string from sqlite3_result_error() as UTF-8. ^SQLite\n** interprets the string from sqlite3_result_error16() as UTF-16 using\n** the same [byte-order determination rules] as [sqlite3_bind_text16()].\n** ^If the third parameter to sqlite3_result_error()\n** or sqlite3_result_error16() is negative then SQLite takes as the error\n** message all text up through the first zero character.\n** ^If the third parameter to sqlite3_result_error() or\n** sqlite3_result_error16() is non-negative then SQLite takes that many\n** bytes (not characters) from the 2nd parameter as the error message.\n** ^The sqlite3_result_error() and sqlite3_result_error16()\n** routines make a private copy of the error message text before\n** they return.  Hence, the calling function can deallocate or\n** modify the text after they return without harm.\n** ^The sqlite3_result_error_code() function changes the error code\n** returned by SQLite as a result of an error in a function.  ^By default,\n** the error code is SQLITE_ERROR.  ^A subsequent call to sqlite3_result_error()\n** or sqlite3_result_error16() resets the error code to SQLITE_ERROR.\n**\n** ^The sqlite3_result_error_toobig() interface causes SQLite to throw an\n** error indicating that a string or BLOB is too long to represent.\n**\n** ^The sqlite3_result_error_nomem() interface causes SQLite to throw an\n** error indicating that a memory allocation failed.\n**\n** ^The sqlite3_result_int() interface sets the return value\n** of the application-defined function to be the 32-bit signed integer\n** value given in the 2nd argument.\n** ^The sqlite3_result_int64() interface sets the return value\n** of the application-defined function to be the 64-bit signed integer\n** value given in the 2nd argument.\n**\n** ^The sqlite3_result_null() interface sets the return value\n** of the application-defined function to be NULL.\n**\n** ^The sqlite3_result_text(), sqlite3_result_text16(),\n** sqlite3_result_text16le(), and sqlite3_result_text16be() interfaces\n** set the return value of the application-defined function to be\n** a text string which is represented as UTF-8, UTF-16 native byte order,\n** UTF-16 little endian, or UTF-16 big endian, respectively.\n** ^The sqlite3_result_text64() interface sets the return value of an\n** application-defined function to be a text string in an encoding\n** specified by the fifth (and last) parameter, which must be one\n** of [SQLITE_UTF8], [SQLITE_UTF16], [SQLITE_UTF16BE], or [SQLITE_UTF16LE].\n** ^SQLite takes the text result from the application from\n** the 2nd parameter of the sqlite3_result_text* interfaces.\n** ^If the 3rd parameter to any of the sqlite3_result_text* interfaces\n** other than sqlite3_result_text64() is negative, then SQLite computes\n** the string length itself by searching the 2nd parameter for the first\n** zero character.\n** ^If the 3rd parameter to the sqlite3_result_text* interfaces\n** is non-negative, then as many bytes (not characters) of the text\n** pointed to by the 2nd parameter are taken as the application-defined\n** function result.  If the 3rd parameter is non-negative, then it\n** must be the byte offset into the string where the NUL terminator would\n** appear if the string where NUL terminated.  If any NUL characters occur\n** in the string at a byte offset that is less than the value of the 3rd\n** parameter, then the resulting string will contain embedded NULs and the\n** result of expressions operating on strings with embedded NULs is undefined.\n** ^If the 4th parameter to the sqlite3_result_text* interfaces\n** or sqlite3_result_blob is a non-NULL pointer, then SQLite calls that\n** function as the destructor on the text or BLOB result when it has\n** finished using that result.\n** ^If the 4th parameter to the sqlite3_result_text* interfaces or to\n** sqlite3_result_blob is the special constant SQLITE_STATIC, then SQLite\n** assumes that the text or BLOB result is in constant space and does not\n** copy the content of the parameter nor call a destructor on the content\n** when it has finished using that result.\n** ^If the 4th parameter to the sqlite3_result_text* interfaces\n** or sqlite3_result_blob is the special constant SQLITE_TRANSIENT\n** then SQLite makes a copy of the result into space obtained\n** from [sqlite3_malloc()] before it returns.\n**\n** ^For the sqlite3_result_text16(), sqlite3_result_text16le(), and\n** sqlite3_result_text16be() routines, and for sqlite3_result_text64()\n** when the encoding is not UTF8, if the input UTF16 begins with a\n** byte-order mark (BOM, U+FEFF) then the BOM is removed from the\n** string and the rest of the string is interpreted according to the\n** byte-order specified by the BOM.  ^The byte-order specified by\n** the BOM at the beginning of the text overrides the byte-order\n** specified by the interface procedure.  ^So, for example, if\n** sqlite3_result_text16le() is invoked with text that begins\n** with bytes 0xfe, 0xff (a big-endian byte-order mark) then the\n** first two bytes of input are skipped and the remaining input\n** is interpreted as UTF16BE text.\n**\n** ^For UTF16 input text to the sqlite3_result_text16(),\n** sqlite3_result_text16be(), sqlite3_result_text16le(), and\n** sqlite3_result_text64() routines, if the text contains invalid\n** UTF16 characters, the invalid characters might be converted\n** into the unicode replacement character, U+FFFD.\n**\n** ^The sqlite3_result_value() interface sets the result of\n** the application-defined function to be a copy of the\n** [unprotected sqlite3_value] object specified by the 2nd parameter.  ^The\n** sqlite3_result_value() interface makes a copy of the [sqlite3_value]\n** so that the [sqlite3_value] specified in the parameter may change or\n** be deallocated after sqlite3_result_value() returns without harm.\n** ^A [protected sqlite3_value] object may always be used where an\n** [unprotected sqlite3_value] object is required, so either\n** kind of [sqlite3_value] object can be used with this interface.\n**\n** ^The sqlite3_result_pointer(C,P,T,D) interface sets the result to an\n** SQL NULL value, just like [sqlite3_result_null(C)], except that it\n** also associates the host-language pointer P or type T with that\n** NULL value such that the pointer can be retrieved within an\n** [application-defined SQL function] using [sqlite3_value_pointer()].\n** ^If the D parameter is not NULL, then it is a pointer to a destructor\n** for the P parameter.  ^SQLite invokes D with P as its only argument\n** when SQLite is finished with P.  The T parameter should be a static\n** string and preferably a string literal. The sqlite3_result_pointer()\n** routine is part of the [pointer passing interface] added for SQLite 3.20.0.\n**\n** If these routines are called from within the different thread\n** than the one containing the application-defined function that received\n** the [sqlite3_context] pointer, the results are undefined.\n*/\nSQLITE_API void sqlite3_result_blob(sqlite3_context*, const void*, int, void(*)(void*));\nSQLITE_API void sqlite3_result_blob64(sqlite3_context*,const void*,\n                           sqlite3_uint64,void(*)(void*));\nSQLITE_API void sqlite3_result_double(sqlite3_context*, double);\nSQLITE_API void sqlite3_result_error(sqlite3_context*, const char*, int);\nSQLITE_API void sqlite3_result_error16(sqlite3_context*, const void*, int);\nSQLITE_API void sqlite3_result_error_toobig(sqlite3_context*);\nSQLITE_API void sqlite3_result_error_nomem(sqlite3_context*);\nSQLITE_API void sqlite3_result_error_code(sqlite3_context*, int);\nSQLITE_API void sqlite3_result_int(sqlite3_context*, int);\nSQLITE_API void sqlite3_result_int64(sqlite3_context*, sqlite3_int64);\nSQLITE_API void sqlite3_result_null(sqlite3_context*);\nSQLITE_API void sqlite3_result_text(sqlite3_context*, const char*, int, void(*)(void*));\nSQLITE_API void sqlite3_result_text64(sqlite3_context*, const char*,sqlite3_uint64,\n                           void(*)(void*), unsigned char encoding);\nSQLITE_API void sqlite3_result_text16(sqlite3_context*, const void*, int, void(*)(void*));\nSQLITE_API void sqlite3_result_text16le(sqlite3_context*, const void*, int,void(*)(void*));\nSQLITE_API void sqlite3_result_text16be(sqlite3_context*, const void*, int,void(*)(void*));\nSQLITE_API void sqlite3_result_value(sqlite3_context*, sqlite3_value*);\nSQLITE_API void sqlite3_result_pointer(sqlite3_context*, void*,const char*,void(*)(void*));\nSQLITE_API void sqlite3_result_zeroblob(sqlite3_context*, int n);\nSQLITE_API int sqlite3_result_zeroblob64(sqlite3_context*, sqlite3_uint64 n);\n\n\n/*\n** CAPI3REF: Setting The Subtype Of An SQL Function\n** METHOD: sqlite3_context\n**\n** The sqlite3_result_subtype(C,T) function causes the subtype of\n** the result from the [application-defined SQL function] with\n** [sqlite3_context] C to be the value T.  Only the lower 8 bits\n** of the subtype T are preserved in current versions of SQLite;\n** higher order bits are discarded.\n** The number of subtype bytes preserved by SQLite might increase\n** in future releases of SQLite.\n**\n** Every [application-defined SQL function] that invokes this interface\n** should include the [SQLITE_RESULT_SUBTYPE] property in its\n** text encoding argument when the SQL function is\n** [sqlite3_create_function|registered].  If the [SQLITE_RESULT_SUBTYPE]\n** property is omitted from the function that invokes sqlite3_result_subtype(),\n** then in some cases the sqlite3_result_subtype() might fail to set\n** the result subtype.\n**\n** If SQLite is compiled with -DSQLITE_STRICT_SUBTYPE=1, then any\n** SQL function that invokes the sqlite3_result_subtype() interface\n** and that does not have the SQLITE_RESULT_SUBTYPE property will raise\n** an error.  Future versions of SQLite might enable -DSQLITE_STRICT_SUBTYPE=1\n** by default.\n*/\nSQLITE_API void sqlite3_result_subtype(sqlite3_context*,unsigned int);\n\n/*\n** CAPI3REF: Define New Collating Sequences\n** METHOD: sqlite3\n**\n** ^These functions add, remove, or modify a [collation] associated\n** with the [database connection] specified as the first argument.\n**\n** ^The name of the collation is a UTF-8 string\n** for sqlite3_create_collation() and sqlite3_create_collation_v2()\n** and a UTF-16 string in native byte order for sqlite3_create_collation16().\n** ^Collation names that compare equal according to [sqlite3_strnicmp()] are\n** considered to be the same name.\n**\n** ^(The third argument (eTextRep) must be one of the constants:\n** <ul>\n** <li> [SQLITE_UTF8],\n** <li> [SQLITE_UTF16LE],\n** <li> [SQLITE_UTF16BE],\n** <li> [SQLITE_UTF16], or\n** <li> [SQLITE_UTF16_ALIGNED].\n** </ul>)^\n** ^The eTextRep argument determines the encoding of strings passed\n** to the collating function callback, xCompare.\n** ^The [SQLITE_UTF16] and [SQLITE_UTF16_ALIGNED] values for eTextRep\n** force strings to be UTF16 with native byte order.\n** ^The [SQLITE_UTF16_ALIGNED] value for eTextRep forces strings to begin\n** on an even byte address.\n**\n** ^The fourth argument, pArg, is an application data pointer that is passed\n** through as the first argument to the collating function callback.\n**\n** ^The fifth argument, xCompare, is a pointer to the collating function.\n** ^Multiple collating functions can be registered using the same name but\n** with different eTextRep parameters and SQLite will use whichever\n** function requires the least amount of data transformation.\n** ^If the xCompare argument is NULL then the collating function is\n** deleted.  ^When all collating functions having the same name are deleted,\n** that collation is no longer usable.\n**\n** ^The collating function callback is invoked with a copy of the pArg\n** application data pointer and with two strings in the encoding specified\n** by the eTextRep argument.  The two integer parameters to the collating\n** function callback are the length of the two strings, in bytes. The collating\n** function must return an integer that is negative, zero, or positive\n** if the first string is less than, equal to, or greater than the second,\n** respectively.  A collating function must always return the same answer\n** given the same inputs.  If two or more collating functions are registered\n** to the same collation name (using different eTextRep values) then all\n** must give an equivalent answer when invoked with equivalent strings.\n** The collating function must obey the following properties for all\n** strings A, B, and C:\n**\n** <ol>\n** <li> If A==B then B==A.\n** <li> If A==B and B==C then A==C.\n** <li> If A&lt;B THEN B&gt;A.\n** <li> If A&lt;B and B&lt;C then A&lt;C.\n** </ol>\n**\n** If a collating function fails any of the above constraints and that\n** collating function is registered and used, then the behavior of SQLite\n** is undefined.\n**\n** ^The sqlite3_create_collation_v2() works like sqlite3_create_collation()\n** with the addition that the xDestroy callback is invoked on pArg when\n** the collating function is deleted.\n** ^Collating functions are deleted when they are overridden by later\n** calls to the collation creation functions or when the\n** [database connection] is closed using [sqlite3_close()].\n**\n** ^The xDestroy callback is <u>not</u> called if the\n** sqlite3_create_collation_v2() function fails.  Applications that invoke\n** sqlite3_create_collation_v2() with a non-NULL xDestroy argument should\n** check the return code and dispose of the application data pointer\n** themselves rather than expecting SQLite to deal with it for them.\n** This is different from every other SQLite interface.  The inconsistency\n** is unfortunate but cannot be changed without breaking backwards\n** compatibility.\n**\n** See also:  [sqlite3_collation_needed()] and [sqlite3_collation_needed16()].\n*/\nSQLITE_API int sqlite3_create_collation(\n  sqlite3*,\n  const char *zName,\n  int eTextRep,\n  void *pArg,\n  int(*xCompare)(void*,int,const void*,int,const void*)\n);\nSQLITE_API int sqlite3_create_collation_v2(\n  sqlite3*,\n  const char *zName,\n  int eTextRep,\n  void *pArg,\n  int(*xCompare)(void*,int,const void*,int,const void*),\n  void(*xDestroy)(void*)\n);\nSQLITE_API int sqlite3_create_collation16(\n  sqlite3*,\n  const void *zName,\n  int eTextRep,\n  void *pArg,\n  int(*xCompare)(void*,int,const void*,int,const void*)\n);\n\n/*\n** CAPI3REF: Collation Needed Callbacks\n** METHOD: sqlite3\n**\n** ^To avoid having to register all collation sequences before a database\n** can be used, a single callback function may be registered with the\n** [database connection] to be invoked whenever an undefined collation\n** sequence is required.\n**\n** ^If the function is registered using the sqlite3_collation_needed() API,\n** then it is passed the names of undefined collation sequences as strings\n** encoded in UTF-8. ^If sqlite3_collation_needed16() is used,\n** the names are passed as UTF-16 in machine native byte order.\n** ^A call to either function replaces the existing collation-needed callback.\n**\n** ^(When the callback is invoked, the first argument passed is a copy\n** of the second argument to sqlite3_collation_needed() or\n** sqlite3_collation_needed16().  The second argument is the database\n** connection.  The third argument is one of [SQLITE_UTF8], [SQLITE_UTF16BE],\n** or [SQLITE_UTF16LE], indicating the most desirable form of the collation\n** sequence function required.  The fourth parameter is the name of the\n** required collation sequence.)^\n**\n** The callback function should register the desired collation using\n** [sqlite3_create_collation()], [sqlite3_create_collation16()], or\n** [sqlite3_create_collation_v2()].\n*/\nSQLITE_API int sqlite3_collation_needed(\n  sqlite3*,\n  void*,\n  void(*)(void*,sqlite3*,int eTextRep,const char*)\n);\nSQLITE_API int sqlite3_collation_needed16(\n  sqlite3*,\n  void*,\n  void(*)(void*,sqlite3*,int eTextRep,const void*)\n);\n\n#ifdef SQLITE_ENABLE_CEROD\n/*\n** Specify the activation key for a CEROD database.  Unless\n** activated, none of the CEROD routines will work.\n*/\nSQLITE_API void sqlite3_activate_cerod(\n  const char *zPassPhrase        /* Activation phrase */\n);\n#endif\n\n/*\n** CAPI3REF: Suspend Execution For A Short Time\n**\n** The sqlite3_sleep() function causes the current thread to suspend execution\n** for at least a number of milliseconds specified in its parameter.\n**\n** If the operating system does not support sleep requests with\n** millisecond time resolution, then the time will be rounded up to\n** the nearest second. The number of milliseconds of sleep actually\n** requested from the operating system is returned.\n**\n** ^SQLite implements this interface by calling the xSleep()\n** method of the default [sqlite3_vfs] object.  If the xSleep() method\n** of the default VFS is not implemented correctly, or not implemented at\n** all, then the behavior of sqlite3_sleep() may deviate from the description\n** in the previous paragraphs.\n**\n** If a negative argument is passed to sqlite3_sleep() the results vary by\n** VFS and operating system.  Some system treat a negative argument as an\n** instruction to sleep forever.  Others understand it to mean do not sleep\n** at all. ^In SQLite version 3.42.0 and later, a negative\n** argument passed into sqlite3_sleep() is changed to zero before it is relayed\n** down into the xSleep method of the VFS.\n*/\nSQLITE_API int sqlite3_sleep(int);\n\n/*\n** CAPI3REF: Name Of The Folder Holding Temporary Files\n**\n** ^(If this global variable is made to point to a string which is\n** the name of a folder (a.k.a. directory), then all temporary files\n** created by SQLite when using a built-in [sqlite3_vfs | VFS]\n** will be placed in that directory.)^  ^If this variable\n** is a NULL pointer, then SQLite performs a search for an appropriate\n** temporary file directory.\n**\n** Applications are strongly discouraged from using this global variable.\n** It is required to set a temporary folder on Windows Runtime (WinRT).\n** But for all other platforms, it is highly recommended that applications\n** neither read nor write this variable.  This global variable is a relic\n** that exists for backwards compatibility of legacy applications and should\n** be avoided in new projects.\n**\n** It is not safe to read or modify this variable in more than one\n** thread at a time.  It is not safe to read or modify this variable\n** if a [database connection] is being used at the same time in a separate\n** thread.\n** It is intended that this variable be set once\n** as part of process initialization and before any SQLite interface\n** routines have been called and that this variable remain unchanged\n** thereafter.\n**\n** ^The [temp_store_directory pragma] may modify this variable and cause\n** it to point to memory obtained from [sqlite3_malloc].  ^Furthermore,\n** the [temp_store_directory pragma] always assumes that any string\n** that this variable points to is held in memory obtained from\n** [sqlite3_malloc] and the pragma may attempt to free that memory\n** using [sqlite3_free].\n** Hence, if this variable is modified directly, either it should be\n** made NULL or made to point to memory obtained from [sqlite3_malloc]\n** or else the use of the [temp_store_directory pragma] should be avoided.\n** Except when requested by the [temp_store_directory pragma], SQLite\n** does not free the memory that sqlite3_temp_directory points to.  If\n** the application wants that memory to be freed, it must do\n** so itself, taking care to only do so after all [database connection]\n** objects have been destroyed.\n**\n** <b>Note to Windows Runtime users:</b>  The temporary directory must be set\n** prior to calling [sqlite3_open] or [sqlite3_open_v2].  Otherwise, various\n** features that require the use of temporary files may fail.  Here is an\n** example of how to do this using C++ with the Windows Runtime:\n**\n** <blockquote><pre>\n** LPCWSTR zPath = Windows::Storage::ApplicationData::Current->\n** &nbsp;     TemporaryFolder->Path->Data();\n** char zPathBuf&#91;MAX_PATH + 1&#93;;\n** memset(zPathBuf, 0, sizeof(zPathBuf));\n** WideCharToMultiByte(CP_UTF8, 0, zPath, -1, zPathBuf, sizeof(zPathBuf),\n** &nbsp;     NULL, NULL);\n** sqlite3_temp_directory = sqlite3_mprintf(\"%s\", zPathBuf);\n** </pre></blockquote>\n*/\nSQLITE_API SQLITE_EXTERN char *sqlite3_temp_directory;\n\n/*\n** CAPI3REF: Name Of The Folder Holding Database Files\n**\n** ^(If this global variable is made to point to a string which is\n** the name of a folder (a.k.a. directory), then all database files\n** specified with a relative pathname and created or accessed by\n** SQLite when using a built-in windows [sqlite3_vfs | VFS] will be assumed\n** to be relative to that directory.)^ ^If this variable is a NULL\n** pointer, then SQLite assumes that all database files specified\n** with a relative pathname are relative to the current directory\n** for the process.  Only the windows VFS makes use of this global\n** variable; it is ignored by the unix VFS.\n**\n** Changing the value of this variable while a database connection is\n** open can result in a corrupt database.\n**\n** It is not safe to read or modify this variable in more than one\n** thread at a time.  It is not safe to read or modify this variable\n** if a [database connection] is being used at the same time in a separate\n** thread.\n** It is intended that this variable be set once\n** as part of process initialization and before any SQLite interface\n** routines have been called and that this variable remain unchanged\n** thereafter.\n**\n** ^The [data_store_directory pragma] may modify this variable and cause\n** it to point to memory obtained from [sqlite3_malloc].  ^Furthermore,\n** the [data_store_directory pragma] always assumes that any string\n** that this variable points to is held in memory obtained from\n** [sqlite3_malloc] and the pragma may attempt to free that memory\n** using [sqlite3_free].\n** Hence, if this variable is modified directly, either it should be\n** made NULL or made to point to memory obtained from [sqlite3_malloc]\n** or else the use of the [data_store_directory pragma] should be avoided.\n*/\nSQLITE_API SQLITE_EXTERN char *sqlite3_data_directory;\n\n/*\n** CAPI3REF: Win32 Specific Interface\n**\n** These interfaces are available only on Windows.  The\n** [sqlite3_win32_set_directory] interface is used to set the value associated\n** with the [sqlite3_temp_directory] or [sqlite3_data_directory] variable, to\n** zValue, depending on the value of the type parameter.  The zValue parameter\n** should be NULL to cause the previous value to be freed via [sqlite3_free];\n** a non-NULL value will be copied into memory obtained from [sqlite3_malloc]\n** prior to being used.  The [sqlite3_win32_set_directory] interface returns\n** [SQLITE_OK] to indicate success, [SQLITE_ERROR] if the type is unsupported,\n** or [SQLITE_NOMEM] if memory could not be allocated.  The value of the\n** [sqlite3_data_directory] variable is intended to act as a replacement for\n** the current directory on the sub-platforms of Win32 where that concept is\n** not present, e.g. WinRT and UWP.  The [sqlite3_win32_set_directory8] and\n** [sqlite3_win32_set_directory16] interfaces behave exactly the same as the\n** sqlite3_win32_set_directory interface except the string parameter must be\n** UTF-8 or UTF-16, respectively.\n*/\nSQLITE_API int sqlite3_win32_set_directory(\n  unsigned long type, /* Identifier for directory being set or reset */\n  void *zValue        /* New value for directory being set or reset */\n);\nSQLITE_API int sqlite3_win32_set_directory8(unsigned long type, const char *zValue);\nSQLITE_API int sqlite3_win32_set_directory16(unsigned long type, const void *zValue);\n\n/*\n** CAPI3REF: Win32 Directory Types\n**\n** These macros are only available on Windows.  They define the allowed values\n** for the type argument to the [sqlite3_win32_set_directory] interface.\n*/\n#define SQLITE_WIN32_DATA_DIRECTORY_TYPE  1\n#define SQLITE_WIN32_TEMP_DIRECTORY_TYPE  2\n\n/*\n** CAPI3REF: Test For Auto-Commit Mode\n** KEYWORDS: {autocommit mode}\n** METHOD: sqlite3\n**\n** ^The sqlite3_get_autocommit() interface returns non-zero or\n** zero if the given database connection is or is not in autocommit mode,\n** respectively.  ^Autocommit mode is on by default.\n** ^Autocommit mode is disabled by a [BEGIN] statement.\n** ^Autocommit mode is re-enabled by a [COMMIT] or [ROLLBACK].\n**\n** If certain kinds of errors occur on a statement within a multi-statement\n** transaction (errors including [SQLITE_FULL], [SQLITE_IOERR],\n** [SQLITE_NOMEM], [SQLITE_BUSY], and [SQLITE_INTERRUPT]) then the\n** transaction might be rolled back automatically.  The only way to\n** find out whether SQLite automatically rolled back the transaction after\n** an error is to use this function.\n**\n** If another thread changes the autocommit status of the database\n** connection while this routine is running, then the return value\n** is undefined.\n*/\nSQLITE_API int sqlite3_get_autocommit(sqlite3*);\n\n/*\n** CAPI3REF: Find The Database Handle Of A Prepared Statement\n** METHOD: sqlite3_stmt\n**\n** ^The sqlite3_db_handle interface returns the [database connection] handle\n** to which a [prepared statement] belongs.  ^The [database connection]\n** returned by sqlite3_db_handle is the same [database connection]\n** that was the first argument\n** to the [sqlite3_prepare_v2()] call (or its variants) that was used to\n** create the statement in the first place.\n*/\nSQLITE_API sqlite3 *sqlite3_db_handle(sqlite3_stmt*);\n\n/*\n** CAPI3REF: Return The Schema Name For A Database Connection\n** METHOD: sqlite3\n**\n** ^The sqlite3_db_name(D,N) interface returns a pointer to the schema name\n** for the N-th database on database connection D, or a NULL pointer of N is\n** out of range.  An N value of 0 means the main database file.  An N of 1 is\n** the \"temp\" schema.  Larger values of N correspond to various ATTACH-ed\n** databases.\n**\n** Space to hold the string that is returned by sqlite3_db_name() is managed\n** by SQLite itself.  The string might be deallocated by any operation that\n** changes the schema, including [ATTACH] or [DETACH] or calls to\n** [sqlite3_serialize()] or [sqlite3_deserialize()], even operations that\n** occur on a different thread.  Applications that need to\n** remember the string long-term should make their own copy.  Applications that\n** are accessing the same database connection simultaneously on multiple\n** threads should mutex-protect calls to this API and should make their own\n** private copy of the result prior to releasing the mutex.\n*/\nSQLITE_API const char *sqlite3_db_name(sqlite3 *db, int N);\n\n/*\n** CAPI3REF: Return The Filename For A Database Connection\n** METHOD: sqlite3\n**\n** ^The sqlite3_db_filename(D,N) interface returns a pointer to the filename\n** associated with database N of connection D.\n** ^If there is no attached database N on the database\n** connection D, or if database N is a temporary or in-memory database, then\n** this function will return either a NULL pointer or an empty string.\n**\n** ^The string value returned by this routine is owned and managed by\n** the database connection.  ^The value will be valid until the database N\n** is [DETACH]-ed or until the database connection closes.\n**\n** ^The filename returned by this function is the output of the\n** xFullPathname method of the [VFS].  ^In other words, the filename\n** will be an absolute pathname, even if the filename used\n** to open the database originally was a URI or relative pathname.\n**\n** If the filename pointer returned by this routine is not NULL, then it\n** can be used as the filename input parameter to these routines:\n** <ul>\n** <li> [sqlite3_uri_parameter()]\n** <li> [sqlite3_uri_boolean()]\n** <li> [sqlite3_uri_int64()]\n** <li> [sqlite3_filename_database()]\n** <li> [sqlite3_filename_journal()]\n** <li> [sqlite3_filename_wal()]\n** </ul>\n*/\nSQLITE_API sqlite3_filename sqlite3_db_filename(sqlite3 *db, const char *zDbName);\n\n/*\n** CAPI3REF: Determine if a database is read-only\n** METHOD: sqlite3\n**\n** ^The sqlite3_db_readonly(D,N) interface returns 1 if the database N\n** of connection D is read-only, 0 if it is read/write, or -1 if N is not\n** the name of a database on connection D.\n*/\nSQLITE_API int sqlite3_db_readonly(sqlite3 *db, const char *zDbName);\n\n/*\n** CAPI3REF: Determine the transaction state of a database\n** METHOD: sqlite3\n**\n** ^The sqlite3_txn_state(D,S) interface returns the current\n** [transaction state] of schema S in database connection D.  ^If S is NULL,\n** then the highest transaction state of any schema on database connection D\n** is returned.  Transaction states are (in order of lowest to highest):\n** <ol>\n** <li value=\"0\"> SQLITE_TXN_NONE\n** <li value=\"1\"> SQLITE_TXN_READ\n** <li value=\"2\"> SQLITE_TXN_WRITE\n** </ol>\n** ^If the S argument to sqlite3_txn_state(D,S) is not the name of\n** a valid schema, then -1 is returned.\n*/\nSQLITE_API int sqlite3_txn_state(sqlite3*,const char *zSchema);\n\n/*\n** CAPI3REF: Allowed return values from sqlite3_txn_state()\n** KEYWORDS: {transaction state}\n**\n** These constants define the current transaction state of a database file.\n** ^The [sqlite3_txn_state(D,S)] interface returns one of these\n** constants in order to describe the transaction state of schema S\n** in [database connection] D.\n**\n** <dl>\n** [[SQLITE_TXN_NONE]] <dt>SQLITE_TXN_NONE</dt>\n** <dd>The SQLITE_TXN_NONE state means that no transaction is currently\n** pending.</dd>\n**\n** [[SQLITE_TXN_READ]] <dt>SQLITE_TXN_READ</dt>\n** <dd>The SQLITE_TXN_READ state means that the database is currently\n** in a read transaction.  Content has been read from the database file\n** but nothing in the database file has changed.  The transaction state\n** will advanced to SQLITE_TXN_WRITE if any changes occur and there are\n** no other conflicting concurrent write transactions.  The transaction\n** state will revert to SQLITE_TXN_NONE following a [ROLLBACK] or\n** [COMMIT].</dd>\n**\n** [[SQLITE_TXN_WRITE]] <dt>SQLITE_TXN_WRITE</dt>\n** <dd>The SQLITE_TXN_WRITE state means that the database is currently\n** in a write transaction.  Content has been written to the database file\n** but has not yet committed.  The transaction state will change to\n** to SQLITE_TXN_NONE at the next [ROLLBACK] or [COMMIT].</dd>\n*/\n#define SQLITE_TXN_NONE  0\n#define SQLITE_TXN_READ  1\n#define SQLITE_TXN_WRITE 2\n\n/*\n** CAPI3REF: Find the next prepared statement\n** METHOD: sqlite3\n**\n** ^This interface returns a pointer to the next [prepared statement] after\n** pStmt associated with the [database connection] pDb.  ^If pStmt is NULL\n** then this interface returns a pointer to the first prepared statement\n** associated with the database connection pDb.  ^If no prepared statement\n** satisfies the conditions of this routine, it returns NULL.\n**\n** The [database connection] pointer D in a call to\n** [sqlite3_next_stmt(D,S)] must refer to an open database\n** connection and in particular must not be a NULL pointer.\n*/\nSQLITE_API sqlite3_stmt *sqlite3_next_stmt(sqlite3 *pDb, sqlite3_stmt *pStmt);\n\n/*\n** CAPI3REF: Commit And Rollback Notification Callbacks\n** METHOD: sqlite3\n**\n** ^The sqlite3_commit_hook() interface registers a callback\n** function to be invoked whenever a transaction is [COMMIT | committed].\n** ^Any callback set by a previous call to sqlite3_commit_hook()\n** for the same database connection is overridden.\n** ^The sqlite3_rollback_hook() interface registers a callback\n** function to be invoked whenever a transaction is [ROLLBACK | rolled back].\n** ^Any callback set by a previous call to sqlite3_rollback_hook()\n** for the same database connection is overridden.\n** ^The pArg argument is passed through to the callback.\n** ^If the callback on a commit hook function returns non-zero,\n** then the commit is converted into a rollback.\n**\n** ^The sqlite3_commit_hook(D,C,P) and sqlite3_rollback_hook(D,C,P) functions\n** return the P argument from the previous call of the same function\n** on the same [database connection] D, or NULL for\n** the first call for each function on D.\n**\n** The commit and rollback hook callbacks are not reentrant.\n** The callback implementation must not do anything that will modify\n** the database connection that invoked the callback.  Any actions\n** to modify the database connection must be deferred until after the\n** completion of the [sqlite3_step()] call that triggered the commit\n** or rollback hook in the first place.\n** Note that running any other SQL statements, including SELECT statements,\n** or merely calling [sqlite3_prepare_v2()] and [sqlite3_step()] will modify\n** the database connections for the meaning of \"modify\" in this paragraph.\n**\n** ^Registering a NULL function disables the callback.\n**\n** ^When the commit hook callback routine returns zero, the [COMMIT]\n** operation is allowed to continue normally.  ^If the commit hook\n** returns non-zero, then the [COMMIT] is converted into a [ROLLBACK].\n** ^The rollback hook is invoked on a rollback that results from a commit\n** hook returning non-zero, just as it would be with any other rollback.\n**\n** ^For the purposes of this API, a transaction is said to have been\n** rolled back if an explicit \"ROLLBACK\" statement is executed, or\n** an error or constraint causes an implicit rollback to occur.\n** ^The rollback callback is not invoked if a transaction is\n** automatically rolled back because the database connection is closed.\n**\n** See also the [sqlite3_update_hook()] interface.\n*/\nSQLITE_API void *sqlite3_commit_hook(sqlite3*, int(*)(void*), void*);\nSQLITE_API void *sqlite3_rollback_hook(sqlite3*, void(*)(void *), void*);\n\n/*\n** CAPI3REF: Autovacuum Compaction Amount Callback\n** METHOD: sqlite3\n**\n** ^The sqlite3_autovacuum_pages(D,C,P,X) interface registers a callback\n** function C that is invoked prior to each autovacuum of the database\n** file.  ^The callback is passed a copy of the generic data pointer (P),\n** the schema-name of the attached database that is being autovacuumed,\n** the size of the database file in pages, the number of free pages,\n** and the number of bytes per page, respectively.  The callback should\n** return the number of free pages that should be removed by the\n** autovacuum.  ^If the callback returns zero, then no autovacuum happens.\n** ^If the value returned is greater than or equal to the number of\n** free pages, then a complete autovacuum happens.\n**\n** <p>^If there are multiple ATTACH-ed database files that are being\n** modified as part of a transaction commit, then the autovacuum pages\n** callback is invoked separately for each file.\n**\n** <p><b>The callback is not reentrant.</b> The callback function should\n** not attempt to invoke any other SQLite interface.  If it does, bad\n** things may happen, including segmentation faults and corrupt database\n** files.  The callback function should be a simple function that\n** does some arithmetic on its input parameters and returns a result.\n**\n** ^The X parameter to sqlite3_autovacuum_pages(D,C,P,X) is an optional\n** destructor for the P parameter.  ^If X is not NULL, then X(P) is\n** invoked whenever the database connection closes or when the callback\n** is overwritten by another invocation of sqlite3_autovacuum_pages().\n**\n** <p>^There is only one autovacuum pages callback per database connection.\n** ^Each call to the sqlite3_autovacuum_pages() interface overrides all\n** previous invocations for that database connection.  ^If the callback\n** argument (C) to sqlite3_autovacuum_pages(D,C,P,X) is a NULL pointer,\n** then the autovacuum steps callback is canceled.  The return value\n** from sqlite3_autovacuum_pages() is normally SQLITE_OK, but might\n** be some other error code if something goes wrong.  The current\n** implementation will only return SQLITE_OK or SQLITE_MISUSE, but other\n** return codes might be added in future releases.\n**\n** <p>If no autovacuum pages callback is specified (the usual case) or\n** a NULL pointer is provided for the callback,\n** then the default behavior is to vacuum all free pages.  So, in other\n** words, the default behavior is the same as if the callback function\n** were something like this:\n**\n** <blockquote><pre>\n** &nbsp;   unsigned int demonstration_autovac_pages_callback(\n** &nbsp;     void *pClientData,\n** &nbsp;     const char *zSchema,\n** &nbsp;     unsigned int nDbPage,\n** &nbsp;     unsigned int nFreePage,\n** &nbsp;     unsigned int nBytePerPage\n** &nbsp;   ){\n** &nbsp;     return nFreePage;\n** &nbsp;   }\n** </pre></blockquote>\n*/\nSQLITE_API int sqlite3_autovacuum_pages(\n  sqlite3 *db,\n  unsigned int(*)(void*,const char*,unsigned int,unsigned int,unsigned int),\n  void*,\n  void(*)(void*)\n);\n\n\n/*\n** CAPI3REF: Data Change Notification Callbacks\n** METHOD: sqlite3\n**\n** ^The sqlite3_update_hook() interface registers a callback function\n** with the [database connection] identified by the first argument\n** to be invoked whenever a row is updated, inserted or deleted in\n** a [rowid table].\n** ^Any callback set by a previous call to this function\n** for the same database connection is overridden.\n**\n** ^The second argument is a pointer to the function to invoke when a\n** row is updated, inserted or deleted in a rowid table.\n** ^The first argument to the callback is a copy of the third argument\n** to sqlite3_update_hook().\n** ^The second callback argument is one of [SQLITE_INSERT], [SQLITE_DELETE],\n** or [SQLITE_UPDATE], depending on the operation that caused the callback\n** to be invoked.\n** ^The third and fourth arguments to the callback contain pointers to the\n** database and table name containing the affected row.\n** ^The final callback parameter is the [rowid] of the row.\n** ^In the case of an update, this is the [rowid] after the update takes place.\n**\n** ^(The update hook is not invoked when internal system tables are\n** modified (i.e. sqlite_sequence).)^\n** ^The update hook is not invoked when [WITHOUT ROWID] tables are modified.\n**\n** ^In the current implementation, the update hook\n** is not invoked when conflicting rows are deleted because of an\n** [ON CONFLICT | ON CONFLICT REPLACE] clause.  ^Nor is the update hook\n** invoked when rows are deleted using the [truncate optimization].\n** The exceptions defined in this paragraph might change in a future\n** release of SQLite.\n**\n** Whether the update hook is invoked before or after the\n** corresponding change is currently unspecified and may differ\n** depending on the type of change. Do not rely on the order of the\n** hook call with regards to the final result of the operation which\n** triggers the hook.\n**\n** The update hook implementation must not do anything that will modify\n** the database connection that invoked the update hook.  Any actions\n** to modify the database connection must be deferred until after the\n** completion of the [sqlite3_step()] call that triggered the update hook.\n** Note that [sqlite3_prepare_v2()] and [sqlite3_step()] both modify their\n** database connections for the meaning of \"modify\" in this paragraph.\n**\n** ^The sqlite3_update_hook(D,C,P) function\n** returns the P argument from the previous call\n** on the same [database connection] D, or NULL for\n** the first call on D.\n**\n** See also the [sqlite3_commit_hook()], [sqlite3_rollback_hook()],\n** and [sqlite3_preupdate_hook()] interfaces.\n*/\nSQLITE_API void *sqlite3_update_hook(\n  sqlite3*,\n  void(*)(void *,int ,char const *,char const *,sqlite3_int64),\n  void*\n);\n\n/*\n** CAPI3REF: Enable Or Disable Shared Pager Cache\n**\n** ^(This routine enables or disables the sharing of the database cache\n** and schema data structures between [database connection | connections]\n** to the same database. Sharing is enabled if the argument is true\n** and disabled if the argument is false.)^\n**\n** This interface is omitted if SQLite is compiled with\n** [-DSQLITE_OMIT_SHARED_CACHE].  The [-DSQLITE_OMIT_SHARED_CACHE]\n** compile-time option is recommended because the\n** [use of shared cache mode is discouraged].\n**\n** ^Cache sharing is enabled and disabled for an entire process.\n** This is a change as of SQLite [version 3.5.0] ([dateof:3.5.0]).\n** In prior versions of SQLite,\n** sharing was enabled or disabled for each thread separately.\n**\n** ^(The cache sharing mode set by this interface effects all subsequent\n** calls to [sqlite3_open()], [sqlite3_open_v2()], and [sqlite3_open16()].\n** Existing database connections continue to use the sharing mode\n** that was in effect at the time they were opened.)^\n**\n** ^(This routine returns [SQLITE_OK] if shared cache was enabled or disabled\n** successfully.  An [error code] is returned otherwise.)^\n**\n** ^Shared cache is disabled by default. It is recommended that it stay\n** that way.  In other words, do not use this routine.  This interface\n** continues to be provided for historical compatibility, but its use is\n** discouraged.  Any use of shared cache is discouraged.  If shared cache\n** must be used, it is recommended that shared cache only be enabled for\n** individual database connections using the [sqlite3_open_v2()] interface\n** with the [SQLITE_OPEN_SHAREDCACHE] flag.\n**\n** Note: This method is disabled on MacOS X 10.7 and iOS version 5.0\n** and will always return SQLITE_MISUSE. On those systems,\n** shared cache mode should be enabled per-database connection via\n** [sqlite3_open_v2()] with [SQLITE_OPEN_SHAREDCACHE].\n**\n** This interface is threadsafe on processors where writing a\n** 32-bit integer is atomic.\n**\n** See Also:  [SQLite Shared-Cache Mode]\n*/\nSQLITE_API int sqlite3_enable_shared_cache(int);\n\n/*\n** CAPI3REF: Attempt To Free Heap Memory\n**\n** ^The sqlite3_release_memory() interface attempts to free N bytes\n** of heap memory by deallocating non-essential memory allocations\n** held by the database library.   Memory used to cache database\n** pages to improve performance is an example of non-essential memory.\n** ^sqlite3_release_memory() returns the number of bytes actually freed,\n** which might be more or less than the amount requested.\n** ^The sqlite3_release_memory() routine is a no-op returning zero\n** if SQLite is not compiled with [SQLITE_ENABLE_MEMORY_MANAGEMENT].\n**\n** See also: [sqlite3_db_release_memory()]\n*/\nSQLITE_API int sqlite3_release_memory(int);\n\n/*\n** CAPI3REF: Free Memory Used By A Database Connection\n** METHOD: sqlite3\n**\n** ^The sqlite3_db_release_memory(D) interface attempts to free as much heap\n** memory as possible from database connection D. Unlike the\n** [sqlite3_release_memory()] interface, this interface is in effect even\n** when the [SQLITE_ENABLE_MEMORY_MANAGEMENT] compile-time option is\n** omitted.\n**\n** See also: [sqlite3_release_memory()]\n*/\nSQLITE_API int sqlite3_db_release_memory(sqlite3*);\n\n/*\n** CAPI3REF: Impose A Limit On Heap Size\n**\n** These interfaces impose limits on the amount of heap memory that will be\n** by all database connections within a single process.\n**\n** ^The sqlite3_soft_heap_limit64() interface sets and/or queries the\n** soft limit on the amount of heap memory that may be allocated by SQLite.\n** ^SQLite strives to keep heap memory utilization below the soft heap\n** limit by reducing the number of pages held in the page cache\n** as heap memory usages approaches the limit.\n** ^The soft heap limit is \"soft\" because even though SQLite strives to stay\n** below the limit, it will exceed the limit rather than generate\n** an [SQLITE_NOMEM] error.  In other words, the soft heap limit\n** is advisory only.\n**\n** ^The sqlite3_hard_heap_limit64(N) interface sets a hard upper bound of\n** N bytes on the amount of memory that will be allocated.  ^The\n** sqlite3_hard_heap_limit64(N) interface is similar to\n** sqlite3_soft_heap_limit64(N) except that memory allocations will fail\n** when the hard heap limit is reached.\n**\n** ^The return value from both sqlite3_soft_heap_limit64() and\n** sqlite3_hard_heap_limit64() is the size of\n** the heap limit prior to the call, or negative in the case of an\n** error.  ^If the argument N is negative\n** then no change is made to the heap limit.  Hence, the current\n** size of heap limits can be determined by invoking\n** sqlite3_soft_heap_limit64(-1) or sqlite3_hard_heap_limit(-1).\n**\n** ^Setting the heap limits to zero disables the heap limiter mechanism.\n**\n** ^The soft heap limit may not be greater than the hard heap limit.\n** ^If the hard heap limit is enabled and if sqlite3_soft_heap_limit(N)\n** is invoked with a value of N that is greater than the hard heap limit,\n** the soft heap limit is set to the value of the hard heap limit.\n** ^The soft heap limit is automatically enabled whenever the hard heap\n** limit is enabled. ^When sqlite3_hard_heap_limit64(N) is invoked and\n** the soft heap limit is outside the range of 1..N, then the soft heap\n** limit is set to N.  ^Invoking sqlite3_soft_heap_limit64(0) when the\n** hard heap limit is enabled makes the soft heap limit equal to the\n** hard heap limit.\n**\n** The memory allocation limits can also be adjusted using\n** [PRAGMA soft_heap_limit] and [PRAGMA hard_heap_limit].\n**\n** ^(The heap limits are not enforced in the current implementation\n** if one or more of following conditions are true:\n**\n** <ul>\n** <li> The limit value is set to zero.\n** <li> Memory accounting is disabled using a combination of the\n**      [sqlite3_config]([SQLITE_CONFIG_MEMSTATUS],...) start-time option and\n**      the [SQLITE_DEFAULT_MEMSTATUS] compile-time option.\n** <li> An alternative page cache implementation is specified using\n**      [sqlite3_config]([SQLITE_CONFIG_PCACHE2],...).\n** <li> The page cache allocates from its own memory pool supplied\n**      by [sqlite3_config]([SQLITE_CONFIG_PAGECACHE],...) rather than\n**      from the heap.\n** </ul>)^\n**\n** The circumstances under which SQLite will enforce the heap limits may\n** changes in future releases of SQLite.\n*/\nSQLITE_API sqlite3_int64 sqlite3_soft_heap_limit64(sqlite3_int64 N);\nSQLITE_API sqlite3_int64 sqlite3_hard_heap_limit64(sqlite3_int64 N);\n\n/*\n** CAPI3REF: Deprecated Soft Heap Limit Interface\n** DEPRECATED\n**\n** This is a deprecated version of the [sqlite3_soft_heap_limit64()]\n** interface.  This routine is provided for historical compatibility\n** only.  All new applications should use the\n** [sqlite3_soft_heap_limit64()] interface rather than this one.\n*/\nSQLITE_API SQLITE_DEPRECATED void sqlite3_soft_heap_limit(int N);\n\n\n/*\n** CAPI3REF: Extract Metadata About A Column Of A Table\n** METHOD: sqlite3\n**\n** ^(The sqlite3_table_column_metadata(X,D,T,C,....) routine returns\n** information about column C of table T in database D\n** on [database connection] X.)^  ^The sqlite3_table_column_metadata()\n** interface returns SQLITE_OK and fills in the non-NULL pointers in\n** the final five arguments with appropriate values if the specified\n** column exists.  ^The sqlite3_table_column_metadata() interface returns\n** SQLITE_ERROR if the specified column does not exist.\n** ^If the column-name parameter to sqlite3_table_column_metadata() is a\n** NULL pointer, then this routine simply checks for the existence of the\n** table and returns SQLITE_OK if the table exists and SQLITE_ERROR if it\n** does not.  If the table name parameter T in a call to\n** sqlite3_table_column_metadata(X,D,T,C,...) is NULL then the result is\n** undefined behavior.\n**\n** ^The column is identified by the second, third and fourth parameters to\n** this function. ^(The second parameter is either the name of the database\n** (i.e. \"main\", \"temp\", or an attached database) containing the specified\n** table or NULL.)^ ^If it is NULL, then all attached databases are searched\n** for the table using the same algorithm used by the database engine to\n** resolve unqualified table references.\n**\n** ^The third and fourth parameters to this function are the table and column\n** name of the desired column, respectively.\n**\n** ^Metadata is returned by writing to the memory locations passed as the 5th\n** and subsequent parameters to this function. ^Any of these arguments may be\n** NULL, in which case the corresponding element of metadata is omitted.\n**\n** ^(<blockquote>\n** <table border=\"1\">\n** <tr><th> Parameter <th> Output<br>Type <th>  Description\n**\n** <tr><td> 5th <td> const char* <td> Data type\n** <tr><td> 6th <td> const char* <td> Name of default collation sequence\n** <tr><td> 7th <td> int         <td> True if column has a NOT NULL constraint\n** <tr><td> 8th <td> int         <td> True if column is part of the PRIMARY KEY\n** <tr><td> 9th <td> int         <td> True if column is [AUTOINCREMENT]\n** </table>\n** </blockquote>)^\n**\n** ^The memory pointed to by the character pointers returned for the\n** declaration type and collation sequence is valid until the next\n** call to any SQLite API function.\n**\n** ^If the specified table is actually a view, an [error code] is returned.\n**\n** ^If the specified column is \"rowid\", \"oid\" or \"_rowid_\" and the table\n** is not a [WITHOUT ROWID] table and an\n** [INTEGER PRIMARY KEY] column has been explicitly declared, then the output\n** parameters are set for the explicitly declared column. ^(If there is no\n** [INTEGER PRIMARY KEY] column, then the outputs\n** for the [rowid] are set as follows:\n**\n** <pre>\n**     data type: \"INTEGER\"\n**     collation sequence: \"BINARY\"\n**     not null: 0\n**     primary key: 1\n**     auto increment: 0\n** </pre>)^\n**\n** ^This function causes all database schemas to be read from disk and\n** parsed, if that has not already been done, and returns an error if\n** any errors are encountered while loading the schema.\n*/\nSQLITE_API int sqlite3_table_column_metadata(\n  sqlite3 *db,                /* Connection handle */\n  const char *zDbName,        /* Database name or NULL */\n  const char *zTableName,     /* Table name */\n  const char *zColumnName,    /* Column name */\n  char const **pzDataType,    /* OUTPUT: Declared data type */\n  char const **pzCollSeq,     /* OUTPUT: Collation sequence name */\n  int *pNotNull,              /* OUTPUT: True if NOT NULL constraint exists */\n  int *pPrimaryKey,           /* OUTPUT: True if column part of PK */\n  int *pAutoinc               /* OUTPUT: True if column is auto-increment */\n);\n\n/*\n** CAPI3REF: Load An Extension\n** METHOD: sqlite3\n**\n** ^This interface loads an SQLite extension library from the named file.\n**\n** ^The sqlite3_load_extension() interface attempts to load an\n** [SQLite extension] library contained in the file zFile.  If\n** the file cannot be loaded directly, attempts are made to load\n** with various operating-system specific extensions added.\n** So for example, if \"samplelib\" cannot be loaded, then names like\n** \"samplelib.so\" or \"samplelib.dylib\" or \"samplelib.dll\" might\n** be tried also.\n**\n** ^The entry point is zProc.\n** ^(zProc may be 0, in which case SQLite will try to come up with an\n** entry point name on its own.  It first tries \"sqlite3_extension_init\".\n** If that does not work, it constructs a name \"sqlite3_X_init\" where the\n** X is consists of the lower-case equivalent of all ASCII alphabetic\n** characters in the filename from the last \"/\" to the first following\n** \".\" and omitting any initial \"lib\".)^\n** ^The sqlite3_load_extension() interface returns\n** [SQLITE_OK] on success and [SQLITE_ERROR] if something goes wrong.\n** ^If an error occurs and pzErrMsg is not 0, then the\n** [sqlite3_load_extension()] interface shall attempt to\n** fill *pzErrMsg with error message text stored in memory\n** obtained from [sqlite3_malloc()]. The calling function\n** should free this memory by calling [sqlite3_free()].\n**\n** ^Extension loading must be enabled using\n** [sqlite3_enable_load_extension()] or\n** [sqlite3_db_config](db,[SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION],1,NULL)\n** prior to calling this API,\n** otherwise an error will be returned.\n**\n** <b>Security warning:</b> It is recommended that the\n** [SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION] method be used to enable only this\n** interface.  The use of the [sqlite3_enable_load_extension()] interface\n** should be avoided.  This will keep the SQL function [load_extension()]\n** disabled and prevent SQL injections from giving attackers\n** access to extension loading capabilities.\n**\n** See also the [load_extension() SQL function].\n*/\nSQLITE_API int sqlite3_load_extension(\n  sqlite3 *db,          /* Load the extension into this database connection */\n  const char *zFile,    /* Name of the shared library containing extension */\n  const char *zProc,    /* Entry point.  Derived from zFile if 0 */\n  char **pzErrMsg       /* Put error message here if not 0 */\n);\n\n/*\n** CAPI3REF: Enable Or Disable Extension Loading\n** METHOD: sqlite3\n**\n** ^So as not to open security holes in older applications that are\n** unprepared to deal with [extension loading], and as a means of disabling\n** [extension loading] while evaluating user-entered SQL, the following API\n** is provided to turn the [sqlite3_load_extension()] mechanism on and off.\n**\n** ^Extension loading is off by default.\n** ^Call the sqlite3_enable_load_extension() routine with onoff==1\n** to turn extension loading on and call it with onoff==0 to turn\n** it back off again.\n**\n** ^This interface enables or disables both the C-API\n** [sqlite3_load_extension()] and the SQL function [load_extension()].\n** ^(Use [sqlite3_db_config](db,[SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION],..)\n** to enable or disable only the C-API.)^\n**\n** <b>Security warning:</b> It is recommended that extension loading\n** be enabled using the [SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION] method\n** rather than this interface, so the [load_extension()] SQL function\n** remains disabled. This will prevent SQL injections from giving attackers\n** access to extension loading capabilities.\n*/\nSQLITE_API int sqlite3_enable_load_extension(sqlite3 *db, int onoff);\n\n/*\n** CAPI3REF: Automatically Load Statically Linked Extensions\n**\n** ^This interface causes the xEntryPoint() function to be invoked for\n** each new [database connection] that is created.  The idea here is that\n** xEntryPoint() is the entry point for a statically linked [SQLite extension]\n** that is to be automatically loaded into all new database connections.\n**\n** ^(Even though the function prototype shows that xEntryPoint() takes\n** no arguments and returns void, SQLite invokes xEntryPoint() with three\n** arguments and expects an integer result as if the signature of the\n** entry point where as follows:\n**\n** <blockquote><pre>\n** &nbsp;  int xEntryPoint(\n** &nbsp;    sqlite3 *db,\n** &nbsp;    const char **pzErrMsg,\n** &nbsp;    const struct sqlite3_api_routines *pThunk\n** &nbsp;  );\n** </pre></blockquote>)^\n**\n** If the xEntryPoint routine encounters an error, it should make *pzErrMsg\n** point to an appropriate error message (obtained from [sqlite3_mprintf()])\n** and return an appropriate [error code].  ^SQLite ensures that *pzErrMsg\n** is NULL before calling the xEntryPoint().  ^SQLite will invoke\n** [sqlite3_free()] on *pzErrMsg after xEntryPoint() returns.  ^If any\n** xEntryPoint() returns an error, the [sqlite3_open()], [sqlite3_open16()],\n** or [sqlite3_open_v2()] call that provoked the xEntryPoint() will fail.\n**\n** ^Calling sqlite3_auto_extension(X) with an entry point X that is already\n** on the list of automatic extensions is a harmless no-op. ^No entry point\n** will be called more than once for each database connection that is opened.\n**\n** See also: [sqlite3_reset_auto_extension()]\n** and [sqlite3_cancel_auto_extension()]\n*/\nSQLITE_API int sqlite3_auto_extension(void(*xEntryPoint)(void));\n\n/*\n** CAPI3REF: Cancel Automatic Extension Loading\n**\n** ^The [sqlite3_cancel_auto_extension(X)] interface unregisters the\n** initialization routine X that was registered using a prior call to\n** [sqlite3_auto_extension(X)].  ^The [sqlite3_cancel_auto_extension(X)]\n** routine returns 1 if initialization routine X was successfully\n** unregistered and it returns 0 if X was not on the list of initialization\n** routines.\n*/\nSQLITE_API int sqlite3_cancel_auto_extension(void(*xEntryPoint)(void));\n\n/*\n** CAPI3REF: Reset Automatic Extension Loading\n**\n** ^This interface disables all automatic extensions previously\n** registered using [sqlite3_auto_extension()].\n*/\nSQLITE_API void sqlite3_reset_auto_extension(void);\n\n/*\n** Structures used by the virtual table interface\n*/\ntypedef struct sqlite3_vtab sqlite3_vtab;\ntypedef struct sqlite3_index_info sqlite3_index_info;\ntypedef struct sqlite3_vtab_cursor sqlite3_vtab_cursor;\ntypedef struct sqlite3_module sqlite3_module;\n\n/*\n** CAPI3REF: Virtual Table Object\n** KEYWORDS: sqlite3_module {virtual table module}\n**\n** This structure, sometimes called a \"virtual table module\",\n** defines the implementation of a [virtual table].\n** This structure consists mostly of methods for the module.\n**\n** ^A virtual table module is created by filling in a persistent\n** instance of this structure and passing a pointer to that instance\n** to [sqlite3_create_module()] or [sqlite3_create_module_v2()].\n** ^The registration remains valid until it is replaced by a different\n** module or until the [database connection] closes.  The content\n** of this structure must not change while it is registered with\n** any database connection.\n*/\nstruct sqlite3_module {\n  int iVersion;\n  int (*xCreate)(sqlite3*, void *pAux,\n               int argc, const char *const*argv,\n               sqlite3_vtab **ppVTab, char**);\n  int (*xConnect)(sqlite3*, void *pAux,\n               int argc, const char *const*argv,\n               sqlite3_vtab **ppVTab, char**);\n  int (*xBestIndex)(sqlite3_vtab *pVTab, sqlite3_index_info*);\n  int (*xDisconnect)(sqlite3_vtab *pVTab);\n  int (*xDestroy)(sqlite3_vtab *pVTab);\n  int (*xOpen)(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor);\n  int (*xClose)(sqlite3_vtab_cursor*);\n  int (*xFilter)(sqlite3_vtab_cursor*, int idxNum, const char *idxStr,\n                int argc, sqlite3_value **argv);\n  int (*xNext)(sqlite3_vtab_cursor*);\n  int (*xEof)(sqlite3_vtab_cursor*);\n  int (*xColumn)(sqlite3_vtab_cursor*, sqlite3_context*, int);\n  int (*xRowid)(sqlite3_vtab_cursor*, sqlite3_int64 *pRowid);\n  int (*xUpdate)(sqlite3_vtab *, int, sqlite3_value **, sqlite3_int64 *);\n  int (*xBegin)(sqlite3_vtab *pVTab);\n  int (*xSync)(sqlite3_vtab *pVTab);\n  int (*xCommit)(sqlite3_vtab *pVTab);\n  int (*xRollback)(sqlite3_vtab *pVTab);\n  int (*xFindFunction)(sqlite3_vtab *pVtab, int nArg, const char *zName,\n                       void (**pxFunc)(sqlite3_context*,int,sqlite3_value**),\n                       void **ppArg);\n  int (*xRename)(sqlite3_vtab *pVtab, const char *zNew);\n  /* The methods above are in version 1 of the sqlite_module object. Those\n  ** below are for version 2 and greater. */\n  int (*xSavepoint)(sqlite3_vtab *pVTab, int);\n  int (*xRelease)(sqlite3_vtab *pVTab, int);\n  int (*xRollbackTo)(sqlite3_vtab *pVTab, int);\n  /* The methods above are in versions 1 and 2 of the sqlite_module object.\n  ** Those below are for version 3 and greater. */\n  int (*xShadowName)(const char*);\n  /* The methods above are in versions 1 through 3 of the sqlite_module object.\n  ** Those below are for version 4 and greater. */\n  int (*xIntegrity)(sqlite3_vtab *pVTab, const char *zSchema,\n                    const char *zTabName, int mFlags, char **pzErr);\n};\n\n/*\n** CAPI3REF: Virtual Table Indexing Information\n** KEYWORDS: sqlite3_index_info\n**\n** The sqlite3_index_info structure and its substructures is used as part\n** of the [virtual table] interface to\n** pass information into and receive the reply from the [xBestIndex]\n** method of a [virtual table module].  The fields under **Inputs** are the\n** inputs to xBestIndex and are read-only.  xBestIndex inserts its\n** results into the **Outputs** fields.\n**\n** ^(The aConstraint[] array records WHERE clause constraints of the form:\n**\n** <blockquote>column OP expr</blockquote>\n**\n** where OP is =, &lt;, &lt;=, &gt;, or &gt;=.)^  ^(The particular operator is\n** stored in aConstraint[].op using one of the\n** [SQLITE_INDEX_CONSTRAINT_EQ | SQLITE_INDEX_CONSTRAINT_ values].)^\n** ^(The index of the column is stored in\n** aConstraint[].iColumn.)^  ^(aConstraint[].usable is TRUE if the\n** expr on the right-hand side can be evaluated (and thus the constraint\n** is usable) and false if it cannot.)^\n**\n** ^The optimizer automatically inverts terms of the form \"expr OP column\"\n** and makes other simplifications to the WHERE clause in an attempt to\n** get as many WHERE clause terms into the form shown above as possible.\n** ^The aConstraint[] array only reports WHERE clause terms that are\n** relevant to the particular virtual table being queried.\n**\n** ^Information about the ORDER BY clause is stored in aOrderBy[].\n** ^Each term of aOrderBy records a column of the ORDER BY clause.\n**\n** The colUsed field indicates which columns of the virtual table may be\n** required by the current scan. Virtual table columns are numbered from\n** zero in the order in which they appear within the CREATE TABLE statement\n** passed to sqlite3_declare_vtab(). For the first 63 columns (columns 0-62),\n** the corresponding bit is set within the colUsed mask if the column may be\n** required by SQLite. If the table has at least 64 columns and any column\n** to the right of the first 63 is required, then bit 63 of colUsed is also\n** set. In other words, column iCol may be required if the expression\n** (colUsed & ((sqlite3_uint64)1 << (iCol>=63 ? 63 : iCol))) evaluates to\n** non-zero.\n**\n** The [xBestIndex] method must fill aConstraintUsage[] with information\n** about what parameters to pass to xFilter.  ^If argvIndex>0 then\n** the right-hand side of the corresponding aConstraint[] is evaluated\n** and becomes the argvIndex-th entry in argv.  ^(If aConstraintUsage[].omit\n** is true, then the constraint is assumed to be fully handled by the\n** virtual table and might not be checked again by the byte code.)^ ^(The\n** aConstraintUsage[].omit flag is an optimization hint. When the omit flag\n** is left in its default setting of false, the constraint will always be\n** checked separately in byte code.  If the omit flag is change to true, then\n** the constraint may or may not be checked in byte code.  In other words,\n** when the omit flag is true there is no guarantee that the constraint will\n** not be checked again using byte code.)^\n**\n** ^The idxNum and idxStr values are recorded and passed into the\n** [xFilter] method.\n** ^[sqlite3_free()] is used to free idxStr if and only if\n** needToFreeIdxStr is true.\n**\n** ^The orderByConsumed means that output from [xFilter]/[xNext] will occur in\n** the correct order to satisfy the ORDER BY clause so that no separate\n** sorting step is required.\n**\n** ^The estimatedCost value is an estimate of the cost of a particular\n** strategy. A cost of N indicates that the cost of the strategy is similar\n** to a linear scan of an SQLite table with N rows. A cost of log(N)\n** indicates that the expense of the operation is similar to that of a\n** binary search on a unique indexed field of an SQLite table with N rows.\n**\n** ^The estimatedRows value is an estimate of the number of rows that\n** will be returned by the strategy.\n**\n** The xBestIndex method may optionally populate the idxFlags field with a\n** mask of SQLITE_INDEX_SCAN_* flags. Currently there is only one such flag -\n** SQLITE_INDEX_SCAN_UNIQUE. If the xBestIndex method sets this flag, SQLite\n** assumes that the strategy may visit at most one row.\n**\n** Additionally, if xBestIndex sets the SQLITE_INDEX_SCAN_UNIQUE flag, then\n** SQLite also assumes that if a call to the xUpdate() method is made as\n** part of the same statement to delete or update a virtual table row and the\n** implementation returns SQLITE_CONSTRAINT, then there is no need to rollback\n** any database changes. In other words, if the xUpdate() returns\n** SQLITE_CONSTRAINT, the database contents must be exactly as they were\n** before xUpdate was called. By contrast, if SQLITE_INDEX_SCAN_UNIQUE is not\n** set and xUpdate returns SQLITE_CONSTRAINT, any database changes made by\n** the xUpdate method are automatically rolled back by SQLite.\n**\n** IMPORTANT: The estimatedRows field was added to the sqlite3_index_info\n** structure for SQLite [version 3.8.2] ([dateof:3.8.2]).\n** If a virtual table extension is\n** used with an SQLite version earlier than 3.8.2, the results of attempting\n** to read or write the estimatedRows field are undefined (but are likely\n** to include crashing the application). The estimatedRows field should\n** therefore only be used if [sqlite3_libversion_number()] returns a\n** value greater than or equal to 3008002. Similarly, the idxFlags field\n** was added for [version 3.9.0] ([dateof:3.9.0]).\n** It may therefore only be used if\n** sqlite3_libversion_number() returns a value greater than or equal to\n** 3009000.\n*/\nstruct sqlite3_index_info {\n  /* Inputs */\n  int nConstraint;           /* Number of entries in aConstraint */\n  struct sqlite3_index_constraint {\n     int iColumn;              /* Column constrained.  -1 for ROWID */\n     unsigned char op;         /* Constraint operator */\n     unsigned char usable;     /* True if this constraint is usable */\n     int iTermOffset;          /* Used internally - xBestIndex should ignore */\n  } *aConstraint;            /* Table of WHERE clause constraints */\n  int nOrderBy;              /* Number of terms in the ORDER BY clause */\n  struct sqlite3_index_orderby {\n     int iColumn;              /* Column number */\n     unsigned char desc;       /* True for DESC.  False for ASC. */\n  } *aOrderBy;               /* The ORDER BY clause */\n  /* Outputs */\n  struct sqlite3_index_constraint_usage {\n    int argvIndex;           /* if >0, constraint is part of argv to xFilter */\n    unsigned char omit;      /* Do not code a test for this constraint */\n  } *aConstraintUsage;\n  int idxNum;                /* Number used to identify the index */\n  char *idxStr;              /* String, possibly obtained from sqlite3_malloc */\n  int needToFreeIdxStr;      /* Free idxStr using sqlite3_free() if true */\n  int orderByConsumed;       /* True if output is already ordered */\n  double estimatedCost;           /* Estimated cost of using this index */\n  /* Fields below are only available in SQLite 3.8.2 and later */\n  sqlite3_int64 estimatedRows;    /* Estimated number of rows returned */\n  /* Fields below are only available in SQLite 3.9.0 and later */\n  int idxFlags;              /* Mask of SQLITE_INDEX_SCAN_* flags */\n  /* Fields below are only available in SQLite 3.10.0 and later */\n  sqlite3_uint64 colUsed;    /* Input: Mask of columns used by statement */\n};\n\n/*\n** CAPI3REF: Virtual Table Scan Flags\n**\n** Virtual table implementations are allowed to set the\n** [sqlite3_index_info].idxFlags field to some combination of\n** these bits.\n*/\n#define SQLITE_INDEX_SCAN_UNIQUE      1     /* Scan visits at most 1 row */\n\n/*\n** CAPI3REF: Virtual Table Constraint Operator Codes\n**\n** These macros define the allowed values for the\n** [sqlite3_index_info].aConstraint[].op field.  Each value represents\n** an operator that is part of a constraint term in the WHERE clause of\n** a query that uses a [virtual table].\n**\n** ^The left-hand operand of the operator is given by the corresponding\n** aConstraint[].iColumn field.  ^An iColumn of -1 indicates the left-hand\n** operand is the rowid.\n** The SQLITE_INDEX_CONSTRAINT_LIMIT and SQLITE_INDEX_CONSTRAINT_OFFSET\n** operators have no left-hand operand, and so for those operators the\n** corresponding aConstraint[].iColumn is meaningless and should not be\n** used.\n**\n** All operator values from SQLITE_INDEX_CONSTRAINT_FUNCTION through\n** value 255 are reserved to represent functions that are overloaded\n** by the [xFindFunction|xFindFunction method] of the virtual table\n** implementation.\n**\n** The right-hand operands for each constraint might be accessible using\n** the [sqlite3_vtab_rhs_value()] interface.  Usually the right-hand\n** operand is only available if it appears as a single constant literal\n** in the input SQL.  If the right-hand operand is another column or an\n** expression (even a constant expression) or a parameter, then the\n** sqlite3_vtab_rhs_value() probably will not be able to extract it.\n** ^The SQLITE_INDEX_CONSTRAINT_ISNULL and\n** SQLITE_INDEX_CONSTRAINT_ISNOTNULL operators have no right-hand operand\n** and hence calls to sqlite3_vtab_rhs_value() for those operators will\n** always return SQLITE_NOTFOUND.\n**\n** The collating sequence to be used for comparison can be found using\n** the [sqlite3_vtab_collation()] interface.  For most real-world virtual\n** tables, the collating sequence of constraints does not matter (for example\n** because the constraints are numeric) and so the sqlite3_vtab_collation()\n** interface is not commonly needed.\n*/\n#define SQLITE_INDEX_CONSTRAINT_EQ          2\n#define SQLITE_INDEX_CONSTRAINT_GT          4\n#define SQLITE_INDEX_CONSTRAINT_LE          8\n#define SQLITE_INDEX_CONSTRAINT_LT         16\n#define SQLITE_INDEX_CONSTRAINT_GE         32\n#define SQLITE_INDEX_CONSTRAINT_MATCH      64\n#define SQLITE_INDEX_CONSTRAINT_LIKE       65\n#define SQLITE_INDEX_CONSTRAINT_GLOB       66\n#define SQLITE_INDEX_CONSTRAINT_REGEXP     67\n#define SQLITE_INDEX_CONSTRAINT_NE         68\n#define SQLITE_INDEX_CONSTRAINT_ISNOT      69\n#define SQLITE_INDEX_CONSTRAINT_ISNOTNULL  70\n#define SQLITE_INDEX_CONSTRAINT_ISNULL     71\n#define SQLITE_INDEX_CONSTRAINT_IS         72\n#define SQLITE_INDEX_CONSTRAINT_LIMIT      73\n#define SQLITE_INDEX_CONSTRAINT_OFFSET     74\n#define SQLITE_INDEX_CONSTRAINT_FUNCTION  150\n\n/*\n** CAPI3REF: Register A Virtual Table Implementation\n** METHOD: sqlite3\n**\n** ^These routines are used to register a new [virtual table module] name.\n** ^Module names must be registered before\n** creating a new [virtual table] using the module and before using a\n** preexisting [virtual table] for the module.\n**\n** ^The module name is registered on the [database connection] specified\n** by the first parameter.  ^The name of the module is given by the\n** second parameter.  ^The third parameter is a pointer to\n** the implementation of the [virtual table module].   ^The fourth\n** parameter is an arbitrary client data pointer that is passed through\n** into the [xCreate] and [xConnect] methods of the virtual table module\n** when a new virtual table is be being created or reinitialized.\n**\n** ^The sqlite3_create_module_v2() interface has a fifth parameter which\n** is a pointer to a destructor for the pClientData.  ^SQLite will\n** invoke the destructor function (if it is not NULL) when SQLite\n** no longer needs the pClientData pointer.  ^The destructor will also\n** be invoked if the call to sqlite3_create_module_v2() fails.\n** ^The sqlite3_create_module()\n** interface is equivalent to sqlite3_create_module_v2() with a NULL\n** destructor.\n**\n** ^If the third parameter (the pointer to the sqlite3_module object) is\n** NULL then no new module is created and any existing modules with the\n** same name are dropped.\n**\n** See also: [sqlite3_drop_modules()]\n*/\nSQLITE_API int sqlite3_create_module(\n  sqlite3 *db,               /* SQLite connection to register module with */\n  const char *zName,         /* Name of the module */\n  const sqlite3_module *p,   /* Methods for the module */\n  void *pClientData          /* Client data for xCreate/xConnect */\n);\nSQLITE_API int sqlite3_create_module_v2(\n  sqlite3 *db,               /* SQLite connection to register module with */\n  const char *zName,         /* Name of the module */\n  const sqlite3_module *p,   /* Methods for the module */\n  void *pClientData,         /* Client data for xCreate/xConnect */\n  void(*xDestroy)(void*)     /* Module destructor function */\n);\n\n/*\n** CAPI3REF: Remove Unnecessary Virtual Table Implementations\n** METHOD: sqlite3\n**\n** ^The sqlite3_drop_modules(D,L) interface removes all virtual\n** table modules from database connection D except those named on list L.\n** The L parameter must be either NULL or a pointer to an array of pointers\n** to strings where the array is terminated by a single NULL pointer.\n** ^If the L parameter is NULL, then all virtual table modules are removed.\n**\n** See also: [sqlite3_create_module()]\n*/\nSQLITE_API int sqlite3_drop_modules(\n  sqlite3 *db,                /* Remove modules from this connection */\n  const char **azKeep         /* Except, do not remove the ones named here */\n);\n\n/*\n** CAPI3REF: Virtual Table Instance Object\n** KEYWORDS: sqlite3_vtab\n**\n** Every [virtual table module] implementation uses a subclass\n** of this object to describe a particular instance\n** of the [virtual table].  Each subclass will\n** be tailored to the specific needs of the module implementation.\n** The purpose of this superclass is to define certain fields that are\n** common to all module implementations.\n**\n** ^Virtual tables methods can set an error message by assigning a\n** string obtained from [sqlite3_mprintf()] to zErrMsg.  The method should\n** take care that any prior string is freed by a call to [sqlite3_free()]\n** prior to assigning a new string to zErrMsg.  ^After the error message\n** is delivered up to the client application, the string will be automatically\n** freed by sqlite3_free() and the zErrMsg field will be zeroed.\n*/\nstruct sqlite3_vtab {\n  const sqlite3_module *pModule;  /* The module for this virtual table */\n  int nRef;                       /* Number of open cursors */\n  char *zErrMsg;                  /* Error message from sqlite3_mprintf() */\n  /* Virtual table implementations will typically add additional fields */\n};\n\n/*\n** CAPI3REF: Virtual Table Cursor Object\n** KEYWORDS: sqlite3_vtab_cursor {virtual table cursor}\n**\n** Every [virtual table module] implementation uses a subclass of the\n** following structure to describe cursors that point into the\n** [virtual table] and are used\n** to loop through the virtual table.  Cursors are created using the\n** [sqlite3_module.xOpen | xOpen] method of the module and are destroyed\n** by the [sqlite3_module.xClose | xClose] method.  Cursors are used\n** by the [xFilter], [xNext], [xEof], [xColumn], and [xRowid] methods\n** of the module.  Each module implementation will define\n** the content of a cursor structure to suit its own needs.\n**\n** This superclass exists in order to define fields of the cursor that\n** are common to all implementations.\n*/\nstruct sqlite3_vtab_cursor {\n  sqlite3_vtab *pVtab;      /* Virtual table of this cursor */\n  /* Virtual table implementations will typically add additional fields */\n};\n\n/*\n** CAPI3REF: Declare The Schema Of A Virtual Table\n**\n** ^The [xCreate] and [xConnect] methods of a\n** [virtual table module] call this interface\n** to declare the format (the names and datatypes of the columns) of\n** the virtual tables they implement.\n*/\nSQLITE_API int sqlite3_declare_vtab(sqlite3*, const char *zSQL);\n\n/*\n** CAPI3REF: Overload A Function For A Virtual Table\n** METHOD: sqlite3\n**\n** ^(Virtual tables can provide alternative implementations of functions\n** using the [xFindFunction] method of the [virtual table module].\n** But global versions of those functions\n** must exist in order to be overloaded.)^\n**\n** ^(This API makes sure a global version of a function with a particular\n** name and number of parameters exists.  If no such function exists\n** before this API is called, a new function is created.)^  ^The implementation\n** of the new function always causes an exception to be thrown.  So\n** the new function is not good for anything by itself.  Its only\n** purpose is to be a placeholder function that can be overloaded\n** by a [virtual table].\n*/\nSQLITE_API int sqlite3_overload_function(sqlite3*, const char *zFuncName, int nArg);\n\n/*\n** CAPI3REF: A Handle To An Open BLOB\n** KEYWORDS: {BLOB handle} {BLOB handles}\n**\n** An instance of this object represents an open BLOB on which\n** [sqlite3_blob_open | incremental BLOB I/O] can be performed.\n** ^Objects of this type are created by [sqlite3_blob_open()]\n** and destroyed by [sqlite3_blob_close()].\n** ^The [sqlite3_blob_read()] and [sqlite3_blob_write()] interfaces\n** can be used to read or write small subsections of the BLOB.\n** ^The [sqlite3_blob_bytes()] interface returns the size of the BLOB in bytes.\n*/\ntypedef struct sqlite3_blob sqlite3_blob;\n\n/*\n** CAPI3REF: Open A BLOB For Incremental I/O\n** METHOD: sqlite3\n** CONSTRUCTOR: sqlite3_blob\n**\n** ^(This interfaces opens a [BLOB handle | handle] to the BLOB located\n** in row iRow, column zColumn, table zTable in database zDb;\n** in other words, the same BLOB that would be selected by:\n**\n** <pre>\n**     SELECT zColumn FROM zDb.zTable WHERE [rowid] = iRow;\n** </pre>)^\n**\n** ^(Parameter zDb is not the filename that contains the database, but\n** rather the symbolic name of the database. For attached databases, this is\n** the name that appears after the AS keyword in the [ATTACH] statement.\n** For the main database file, the database name is \"main\". For TEMP\n** tables, the database name is \"temp\".)^\n**\n** ^If the flags parameter is non-zero, then the BLOB is opened for read\n** and write access. ^If the flags parameter is zero, the BLOB is opened for\n** read-only access.\n**\n** ^(On success, [SQLITE_OK] is returned and the new [BLOB handle] is stored\n** in *ppBlob. Otherwise an [error code] is returned and, unless the error\n** code is SQLITE_MISUSE, *ppBlob is set to NULL.)^ ^This means that, provided\n** the API is not misused, it is always safe to call [sqlite3_blob_close()]\n** on *ppBlob after this function it returns.\n**\n** This function fails with SQLITE_ERROR if any of the following are true:\n** <ul>\n**   <li> ^(Database zDb does not exist)^,\n**   <li> ^(Table zTable does not exist within database zDb)^,\n**   <li> ^(Table zTable is a WITHOUT ROWID table)^,\n**   <li> ^(Column zColumn does not exist)^,\n**   <li> ^(Row iRow is not present in the table)^,\n**   <li> ^(The specified column of row iRow contains a value that is not\n**         a TEXT or BLOB value)^,\n**   <li> ^(Column zColumn is part of an index, PRIMARY KEY or UNIQUE\n**         constraint and the blob is being opened for read/write access)^,\n**   <li> ^([foreign key constraints | Foreign key constraints] are enabled,\n**         column zColumn is part of a [child key] definition and the blob is\n**         being opened for read/write access)^.\n** </ul>\n**\n** ^Unless it returns SQLITE_MISUSE, this function sets the\n** [database connection] error code and message accessible via\n** [sqlite3_errcode()] and [sqlite3_errmsg()] and related functions.\n**\n** A BLOB referenced by sqlite3_blob_open() may be read using the\n** [sqlite3_blob_read()] interface and modified by using\n** [sqlite3_blob_write()].  The [BLOB handle] can be moved to a\n** different row of the same table using the [sqlite3_blob_reopen()]\n** interface.  However, the column, table, or database of a [BLOB handle]\n** cannot be changed after the [BLOB handle] is opened.\n**\n** ^(If the row that a BLOB handle points to is modified by an\n** [UPDATE], [DELETE], or by [ON CONFLICT] side-effects\n** then the BLOB handle is marked as \"expired\".\n** This is true if any column of the row is changed, even a column\n** other than the one the BLOB handle is open on.)^\n** ^Calls to [sqlite3_blob_read()] and [sqlite3_blob_write()] for\n** an expired BLOB handle fail with a return code of [SQLITE_ABORT].\n** ^(Changes written into a BLOB prior to the BLOB expiring are not\n** rolled back by the expiration of the BLOB.  Such changes will eventually\n** commit if the transaction continues to completion.)^\n**\n** ^Use the [sqlite3_blob_bytes()] interface to determine the size of\n** the opened blob.  ^The size of a blob may not be changed by this\n** interface.  Use the [UPDATE] SQL command to change the size of a\n** blob.\n**\n** ^The [sqlite3_bind_zeroblob()] and [sqlite3_result_zeroblob()] interfaces\n** and the built-in [zeroblob] SQL function may be used to create a\n** zero-filled blob to read or write using the incremental-blob interface.\n**\n** To avoid a resource leak, every open [BLOB handle] should eventually\n** be released by a call to [sqlite3_blob_close()].\n**\n** See also: [sqlite3_blob_close()],\n** [sqlite3_blob_reopen()], [sqlite3_blob_read()],\n** [sqlite3_blob_bytes()], [sqlite3_blob_write()].\n*/\nSQLITE_API int sqlite3_blob_open(\n  sqlite3*,\n  const char *zDb,\n  const char *zTable,\n  const char *zColumn,\n  sqlite3_int64 iRow,\n  int flags,\n  sqlite3_blob **ppBlob\n);\n\n/*\n** CAPI3REF: Move a BLOB Handle to a New Row\n** METHOD: sqlite3_blob\n**\n** ^This function is used to move an existing [BLOB handle] so that it points\n** to a different row of the same database table. ^The new row is identified\n** by the rowid value passed as the second argument. Only the row can be\n** changed. ^The database, table and column on which the blob handle is open\n** remain the same. Moving an existing [BLOB handle] to a new row is\n** faster than closing the existing handle and opening a new one.\n**\n** ^(The new row must meet the same criteria as for [sqlite3_blob_open()] -\n** it must exist and there must be either a blob or text value stored in\n** the nominated column.)^ ^If the new row is not present in the table, or if\n** it does not contain a blob or text value, or if another error occurs, an\n** SQLite error code is returned and the blob handle is considered aborted.\n** ^All subsequent calls to [sqlite3_blob_read()], [sqlite3_blob_write()] or\n** [sqlite3_blob_reopen()] on an aborted blob handle immediately return\n** SQLITE_ABORT. ^Calling [sqlite3_blob_bytes()] on an aborted blob handle\n** always returns zero.\n**\n** ^This function sets the database handle error code and message.\n*/\nSQLITE_API int sqlite3_blob_reopen(sqlite3_blob *, sqlite3_int64);\n\n/*\n** CAPI3REF: Close A BLOB Handle\n** DESTRUCTOR: sqlite3_blob\n**\n** ^This function closes an open [BLOB handle]. ^(The BLOB handle is closed\n** unconditionally.  Even if this routine returns an error code, the\n** handle is still closed.)^\n**\n** ^If the blob handle being closed was opened for read-write access, and if\n** the database is in auto-commit mode and there are no other open read-write\n** blob handles or active write statements, the current transaction is\n** committed. ^If an error occurs while committing the transaction, an error\n** code is returned and the transaction rolled back.\n**\n** Calling this function with an argument that is not a NULL pointer or an\n** open blob handle results in undefined behavior. ^Calling this routine\n** with a null pointer (such as would be returned by a failed call to\n** [sqlite3_blob_open()]) is a harmless no-op. ^Otherwise, if this function\n** is passed a valid open blob handle, the values returned by the\n** sqlite3_errcode() and sqlite3_errmsg() functions are set before returning.\n*/\nSQLITE_API int sqlite3_blob_close(sqlite3_blob *);\n\n/*\n** CAPI3REF: Return The Size Of An Open BLOB\n** METHOD: sqlite3_blob\n**\n** ^Returns the size in bytes of the BLOB accessible via the\n** successfully opened [BLOB handle] in its only argument.  ^The\n** incremental blob I/O routines can only read or overwriting existing\n** blob content; they cannot change the size of a blob.\n**\n** This routine only works on a [BLOB handle] which has been created\n** by a prior successful call to [sqlite3_blob_open()] and which has not\n** been closed by [sqlite3_blob_close()].  Passing any other pointer in\n** to this routine results in undefined and probably undesirable behavior.\n*/\nSQLITE_API int sqlite3_blob_bytes(sqlite3_blob *);\n\n/*\n** CAPI3REF: Read Data From A BLOB Incrementally\n** METHOD: sqlite3_blob\n**\n** ^(This function is used to read data from an open [BLOB handle] into a\n** caller-supplied buffer. N bytes of data are copied into buffer Z\n** from the open BLOB, starting at offset iOffset.)^\n**\n** ^If offset iOffset is less than N bytes from the end of the BLOB,\n** [SQLITE_ERROR] is returned and no data is read.  ^If N or iOffset is\n** less than zero, [SQLITE_ERROR] is returned and no data is read.\n** ^The size of the blob (and hence the maximum value of N+iOffset)\n** can be determined using the [sqlite3_blob_bytes()] interface.\n**\n** ^An attempt to read from an expired [BLOB handle] fails with an\n** error code of [SQLITE_ABORT].\n**\n** ^(On success, sqlite3_blob_read() returns SQLITE_OK.\n** Otherwise, an [error code] or an [extended error code] is returned.)^\n**\n** This routine only works on a [BLOB handle] which has been created\n** by a prior successful call to [sqlite3_blob_open()] and which has not\n** been closed by [sqlite3_blob_close()].  Passing any other pointer in\n** to this routine results in undefined and probably undesirable behavior.\n**\n** See also: [sqlite3_blob_write()].\n*/\nSQLITE_API int sqlite3_blob_read(sqlite3_blob *, void *Z, int N, int iOffset);\n\n/*\n** CAPI3REF: Write Data Into A BLOB Incrementally\n** METHOD: sqlite3_blob\n**\n** ^(This function is used to write data into an open [BLOB handle] from a\n** caller-supplied buffer. N bytes of data are copied from the buffer Z\n** into the open BLOB, starting at offset iOffset.)^\n**\n** ^(On success, sqlite3_blob_write() returns SQLITE_OK.\n** Otherwise, an  [error code] or an [extended error code] is returned.)^\n** ^Unless SQLITE_MISUSE is returned, this function sets the\n** [database connection] error code and message accessible via\n** [sqlite3_errcode()] and [sqlite3_errmsg()] and related functions.\n**\n** ^If the [BLOB handle] passed as the first argument was not opened for\n** writing (the flags parameter to [sqlite3_blob_open()] was zero),\n** this function returns [SQLITE_READONLY].\n**\n** This function may only modify the contents of the BLOB; it is\n** not possible to increase the size of a BLOB using this API.\n** ^If offset iOffset is less than N bytes from the end of the BLOB,\n** [SQLITE_ERROR] is returned and no data is written. The size of the\n** BLOB (and hence the maximum value of N+iOffset) can be determined\n** using the [sqlite3_blob_bytes()] interface. ^If N or iOffset are less\n** than zero [SQLITE_ERROR] is returned and no data is written.\n**\n** ^An attempt to write to an expired [BLOB handle] fails with an\n** error code of [SQLITE_ABORT].  ^Writes to the BLOB that occurred\n** before the [BLOB handle] expired are not rolled back by the\n** expiration of the handle, though of course those changes might\n** have been overwritten by the statement that expired the BLOB handle\n** or by other independent statements.\n**\n** This routine only works on a [BLOB handle] which has been created\n** by a prior successful call to [sqlite3_blob_open()] and which has not\n** been closed by [sqlite3_blob_close()].  Passing any other pointer in\n** to this routine results in undefined and probably undesirable behavior.\n**\n** See also: [sqlite3_blob_read()].\n*/\nSQLITE_API int sqlite3_blob_write(sqlite3_blob *, const void *z, int n, int iOffset);\n\n/*\n** CAPI3REF: Virtual File System Objects\n**\n** A virtual filesystem (VFS) is an [sqlite3_vfs] object\n** that SQLite uses to interact\n** with the underlying operating system.  Most SQLite builds come with a\n** single default VFS that is appropriate for the host computer.\n** New VFSes can be registered and existing VFSes can be unregistered.\n** The following interfaces are provided.\n**\n** ^The sqlite3_vfs_find() interface returns a pointer to a VFS given its name.\n** ^Names are case sensitive.\n** ^Names are zero-terminated UTF-8 strings.\n** ^If there is no match, a NULL pointer is returned.\n** ^If zVfsName is NULL then the default VFS is returned.\n**\n** ^New VFSes are registered with sqlite3_vfs_register().\n** ^Each new VFS becomes the default VFS if the makeDflt flag is set.\n** ^The same VFS can be registered multiple times without injury.\n** ^To make an existing VFS into the default VFS, register it again\n** with the makeDflt flag set.  If two different VFSes with the\n** same name are registered, the behavior is undefined.  If a\n** VFS is registered with a name that is NULL or an empty string,\n** then the behavior is undefined.\n**\n** ^Unregister a VFS with the sqlite3_vfs_unregister() interface.\n** ^(If the default VFS is unregistered, another VFS is chosen as\n** the default.  The choice for the new VFS is arbitrary.)^\n*/\nSQLITE_API sqlite3_vfs *sqlite3_vfs_find(const char *zVfsName);\nSQLITE_API int sqlite3_vfs_register(sqlite3_vfs*, int makeDflt);\nSQLITE_API int sqlite3_vfs_unregister(sqlite3_vfs*);\n\n/*\n** CAPI3REF: Mutexes\n**\n** The SQLite core uses these routines for thread\n** synchronization. Though they are intended for internal\n** use by SQLite, code that links against SQLite is\n** permitted to use any of these routines.\n**\n** The SQLite source code contains multiple implementations\n** of these mutex routines.  An appropriate implementation\n** is selected automatically at compile-time.  The following\n** implementations are available in the SQLite core:\n**\n** <ul>\n** <li>   SQLITE_MUTEX_PTHREADS\n** <li>   SQLITE_MUTEX_W32\n** <li>   SQLITE_MUTEX_NOOP\n** </ul>\n**\n** The SQLITE_MUTEX_NOOP implementation is a set of routines\n** that does no real locking and is appropriate for use in\n** a single-threaded application.  The SQLITE_MUTEX_PTHREADS and\n** SQLITE_MUTEX_W32 implementations are appropriate for use on Unix\n** and Windows.\n**\n** If SQLite is compiled with the SQLITE_MUTEX_APPDEF preprocessor\n** macro defined (with \"-DSQLITE_MUTEX_APPDEF=1\"), then no mutex\n** implementation is included with the library. In this case the\n** application must supply a custom mutex implementation using the\n** [SQLITE_CONFIG_MUTEX] option of the sqlite3_config() function\n** before calling sqlite3_initialize() or any other public sqlite3_\n** function that calls sqlite3_initialize().\n**\n** ^The sqlite3_mutex_alloc() routine allocates a new\n** mutex and returns a pointer to it. ^The sqlite3_mutex_alloc()\n** routine returns NULL if it is unable to allocate the requested\n** mutex.  The argument to sqlite3_mutex_alloc() must one of these\n** integer constants:\n**\n** <ul>\n** <li>  SQLITE_MUTEX_FAST\n** <li>  SQLITE_MUTEX_RECURSIVE\n** <li>  SQLITE_MUTEX_STATIC_MAIN\n** <li>  SQLITE_MUTEX_STATIC_MEM\n** <li>  SQLITE_MUTEX_STATIC_OPEN\n** <li>  SQLITE_MUTEX_STATIC_PRNG\n** <li>  SQLITE_MUTEX_STATIC_LRU\n** <li>  SQLITE_MUTEX_STATIC_PMEM\n** <li>  SQLITE_MUTEX_STATIC_APP1\n** <li>  SQLITE_MUTEX_STATIC_APP2\n** <li>  SQLITE_MUTEX_STATIC_APP3\n** <li>  SQLITE_MUTEX_STATIC_VFS1\n** <li>  SQLITE_MUTEX_STATIC_VFS2\n** <li>  SQLITE_MUTEX_STATIC_VFS3\n** </ul>\n**\n** ^The first two constants (SQLITE_MUTEX_FAST and SQLITE_MUTEX_RECURSIVE)\n** cause sqlite3_mutex_alloc() to create\n** a new mutex.  ^The new mutex is recursive when SQLITE_MUTEX_RECURSIVE\n** is used but not necessarily so when SQLITE_MUTEX_FAST is used.\n** The mutex implementation does not need to make a distinction\n** between SQLITE_MUTEX_RECURSIVE and SQLITE_MUTEX_FAST if it does\n** not want to.  SQLite will only request a recursive mutex in\n** cases where it really needs one.  If a faster non-recursive mutex\n** implementation is available on the host platform, the mutex subsystem\n** might return such a mutex in response to SQLITE_MUTEX_FAST.\n**\n** ^The other allowed parameters to sqlite3_mutex_alloc() (anything other\n** than SQLITE_MUTEX_FAST and SQLITE_MUTEX_RECURSIVE) each return\n** a pointer to a static preexisting mutex.  ^Nine static mutexes are\n** used by the current version of SQLite.  Future versions of SQLite\n** may add additional static mutexes.  Static mutexes are for internal\n** use by SQLite only.  Applications that use SQLite mutexes should\n** use only the dynamic mutexes returned by SQLITE_MUTEX_FAST or\n** SQLITE_MUTEX_RECURSIVE.\n**\n** ^Note that if one of the dynamic mutex parameters (SQLITE_MUTEX_FAST\n** or SQLITE_MUTEX_RECURSIVE) is used then sqlite3_mutex_alloc()\n** returns a different mutex on every call.  ^For the static\n** mutex types, the same mutex is returned on every call that has\n** the same type number.\n**\n** ^The sqlite3_mutex_free() routine deallocates a previously\n** allocated dynamic mutex.  Attempting to deallocate a static\n** mutex results in undefined behavior.\n**\n** ^The sqlite3_mutex_enter() and sqlite3_mutex_try() routines attempt\n** to enter a mutex.  ^If another thread is already within the mutex,\n** sqlite3_mutex_enter() will block and sqlite3_mutex_try() will return\n** SQLITE_BUSY.  ^The sqlite3_mutex_try() interface returns [SQLITE_OK]\n** upon successful entry.  ^(Mutexes created using\n** SQLITE_MUTEX_RECURSIVE can be entered multiple times by the same thread.\n** In such cases, the\n** mutex must be exited an equal number of times before another thread\n** can enter.)^  If the same thread tries to enter any mutex other\n** than an SQLITE_MUTEX_RECURSIVE more than once, the behavior is undefined.\n**\n** ^(Some systems (for example, Windows 95) do not support the operation\n** implemented by sqlite3_mutex_try().  On those systems, sqlite3_mutex_try()\n** will always return SQLITE_BUSY. In most cases the SQLite core only uses\n** sqlite3_mutex_try() as an optimization, so this is acceptable\n** behavior. The exceptions are unix builds that set the\n** SQLITE_ENABLE_SETLK_TIMEOUT build option. In that case a working\n** sqlite3_mutex_try() is required.)^\n**\n** ^The sqlite3_mutex_leave() routine exits a mutex that was\n** previously entered by the same thread.   The behavior\n** is undefined if the mutex is not currently entered by the\n** calling thread or is not currently allocated.\n**\n** ^If the argument to sqlite3_mutex_enter(), sqlite3_mutex_try(),\n** sqlite3_mutex_leave(), or sqlite3_mutex_free() is a NULL pointer,\n** then any of the four routines behaves as a no-op.\n**\n** See also: [sqlite3_mutex_held()] and [sqlite3_mutex_notheld()].\n*/\nSQLITE_API sqlite3_mutex *sqlite3_mutex_alloc(int);\nSQLITE_API void sqlite3_mutex_free(sqlite3_mutex*);\nSQLITE_API void sqlite3_mutex_enter(sqlite3_mutex*);\nSQLITE_API int sqlite3_mutex_try(sqlite3_mutex*);\nSQLITE_API void sqlite3_mutex_leave(sqlite3_mutex*);\n\n/*\n** CAPI3REF: Mutex Methods Object\n**\n** An instance of this structure defines the low-level routines\n** used to allocate and use mutexes.\n**\n** Usually, the default mutex implementations provided by SQLite are\n** sufficient, however the application has the option of substituting a custom\n** implementation for specialized deployments or systems for which SQLite\n** does not provide a suitable implementation. In this case, the application\n** creates and populates an instance of this structure to pass\n** to sqlite3_config() along with the [SQLITE_CONFIG_MUTEX] option.\n** Additionally, an instance of this structure can be used as an\n** output variable when querying the system for the current mutex\n** implementation, using the [SQLITE_CONFIG_GETMUTEX] option.\n**\n** ^The xMutexInit method defined by this structure is invoked as\n** part of system initialization by the sqlite3_initialize() function.\n** ^The xMutexInit routine is called by SQLite exactly once for each\n** effective call to [sqlite3_initialize()].\n**\n** ^The xMutexEnd method defined by this structure is invoked as\n** part of system shutdown by the sqlite3_shutdown() function. The\n** implementation of this method is expected to release all outstanding\n** resources obtained by the mutex methods implementation, especially\n** those obtained by the xMutexInit method.  ^The xMutexEnd()\n** interface is invoked exactly once for each call to [sqlite3_shutdown()].\n**\n** ^(The remaining seven methods defined by this structure (xMutexAlloc,\n** xMutexFree, xMutexEnter, xMutexTry, xMutexLeave, xMutexHeld and\n** xMutexNotheld) implement the following interfaces (respectively):\n**\n** <ul>\n**   <li>  [sqlite3_mutex_alloc()] </li>\n**   <li>  [sqlite3_mutex_free()] </li>\n**   <li>  [sqlite3_mutex_enter()] </li>\n**   <li>  [sqlite3_mutex_try()] </li>\n**   <li>  [sqlite3_mutex_leave()] </li>\n**   <li>  [sqlite3_mutex_held()] </li>\n**   <li>  [sqlite3_mutex_notheld()] </li>\n** </ul>)^\n**\n** The only difference is that the public sqlite3_XXX functions enumerated\n** above silently ignore any invocations that pass a NULL pointer instead\n** of a valid mutex handle. The implementations of the methods defined\n** by this structure are not required to handle this case. The results\n** of passing a NULL pointer instead of a valid mutex handle are undefined\n** (i.e. it is acceptable to provide an implementation that segfaults if\n** it is passed a NULL pointer).\n**\n** The xMutexInit() method must be threadsafe.  It must be harmless to\n** invoke xMutexInit() multiple times within the same process and without\n** intervening calls to xMutexEnd().  Second and subsequent calls to\n** xMutexInit() must be no-ops.\n**\n** xMutexInit() must not use SQLite memory allocation ([sqlite3_malloc()]\n** and its associates).  Similarly, xMutexAlloc() must not use SQLite memory\n** allocation for a static mutex.  ^However xMutexAlloc() may use SQLite\n** memory allocation for a fast or recursive mutex.\n**\n** ^SQLite will invoke the xMutexEnd() method when [sqlite3_shutdown()] is\n** called, but only if the prior call to xMutexInit returned SQLITE_OK.\n** If xMutexInit fails in any way, it is expected to clean up after itself\n** prior to returning.\n*/\ntypedef struct sqlite3_mutex_methods sqlite3_mutex_methods;\nstruct sqlite3_mutex_methods {\n  int (*xMutexInit)(void);\n  int (*xMutexEnd)(void);\n  sqlite3_mutex *(*xMutexAlloc)(int);\n  void (*xMutexFree)(sqlite3_mutex *);\n  void (*xMutexEnter)(sqlite3_mutex *);\n  int (*xMutexTry)(sqlite3_mutex *);\n  void (*xMutexLeave)(sqlite3_mutex *);\n  int (*xMutexHeld)(sqlite3_mutex *);\n  int (*xMutexNotheld)(sqlite3_mutex *);\n};\n\n/*\n** CAPI3REF: Mutex Verification Routines\n**\n** The sqlite3_mutex_held() and sqlite3_mutex_notheld() routines\n** are intended for use inside assert() statements.  The SQLite core\n** never uses these routines except inside an assert() and applications\n** are advised to follow the lead of the core.  The SQLite core only\n** provides implementations for these routines when it is compiled\n** with the SQLITE_DEBUG flag.  External mutex implementations\n** are only required to provide these routines if SQLITE_DEBUG is\n** defined and if NDEBUG is not defined.\n**\n** These routines should return true if the mutex in their argument\n** is held or not held, respectively, by the calling thread.\n**\n** The implementation is not required to provide versions of these\n** routines that actually work. If the implementation does not provide working\n** versions of these routines, it should at least provide stubs that always\n** return true so that one does not get spurious assertion failures.\n**\n** If the argument to sqlite3_mutex_held() is a NULL pointer then\n** the routine should return 1.   This seems counter-intuitive since\n** clearly the mutex cannot be held if it does not exist.  But\n** the reason the mutex does not exist is because the build is not\n** using mutexes.  And we do not want the assert() containing the\n** call to sqlite3_mutex_held() to fail, so a non-zero return is\n** the appropriate thing to do.  The sqlite3_mutex_notheld()\n** interface should also return 1 when given a NULL pointer.\n*/\n#ifndef NDEBUG\nSQLITE_API int sqlite3_mutex_held(sqlite3_mutex*);\nSQLITE_API int sqlite3_mutex_notheld(sqlite3_mutex*);\n#endif\n\n/*\n** CAPI3REF: Mutex Types\n**\n** The [sqlite3_mutex_alloc()] interface takes a single argument\n** which is one of these integer constants.\n**\n** The set of static mutexes may change from one SQLite release to the\n** next.  Applications that override the built-in mutex logic must be\n** prepared to accommodate additional static mutexes.\n*/\n#define SQLITE_MUTEX_FAST             0\n#define SQLITE_MUTEX_RECURSIVE        1\n#define SQLITE_MUTEX_STATIC_MAIN      2\n#define SQLITE_MUTEX_STATIC_MEM       3  /* sqlite3_malloc() */\n#define SQLITE_MUTEX_STATIC_MEM2      4  /* NOT USED */\n#define SQLITE_MUTEX_STATIC_OPEN      4  /* sqlite3BtreeOpen() */\n#define SQLITE_MUTEX_STATIC_PRNG      5  /* sqlite3_randomness() */\n#define SQLITE_MUTEX_STATIC_LRU       6  /* lru page list */\n#define SQLITE_MUTEX_STATIC_LRU2      7  /* NOT USED */\n#define SQLITE_MUTEX_STATIC_PMEM      7  /* sqlite3PageMalloc() */\n#define SQLITE_MUTEX_STATIC_APP1      8  /* For use by application */\n#define SQLITE_MUTEX_STATIC_APP2      9  /* For use by application */\n#define SQLITE_MUTEX_STATIC_APP3     10  /* For use by application */\n#define SQLITE_MUTEX_STATIC_VFS1     11  /* For use by built-in VFS */\n#define SQLITE_MUTEX_STATIC_VFS2     12  /* For use by extension VFS */\n#define SQLITE_MUTEX_STATIC_VFS3     13  /* For use by application VFS */\n\n/* Legacy compatibility: */\n#define SQLITE_MUTEX_STATIC_MASTER    2\n\n\n/*\n** CAPI3REF: Retrieve the mutex for a database connection\n** METHOD: sqlite3\n**\n** ^This interface returns a pointer the [sqlite3_mutex] object that\n** serializes access to the [database connection] given in the argument\n** when the [threading mode] is Serialized.\n** ^If the [threading mode] is Single-thread or Multi-thread then this\n** routine returns a NULL pointer.\n*/\nSQLITE_API sqlite3_mutex *sqlite3_db_mutex(sqlite3*);\n\n/*\n** CAPI3REF: Low-Level Control Of Database Files\n** METHOD: sqlite3\n** KEYWORDS: {file control}\n**\n** ^The [sqlite3_file_control()] interface makes a direct call to the\n** xFileControl method for the [sqlite3_io_methods] object associated\n** with a particular database identified by the second argument. ^The\n** name of the database is \"main\" for the main database or \"temp\" for the\n** TEMP database, or the name that appears after the AS keyword for\n** databases that are added using the [ATTACH] SQL command.\n** ^A NULL pointer can be used in place of \"main\" to refer to the\n** main database file.\n** ^The third and fourth parameters to this routine\n** are passed directly through to the second and third parameters of\n** the xFileControl method.  ^The return value of the xFileControl\n** method becomes the return value of this routine.\n**\n** A few opcodes for [sqlite3_file_control()] are handled directly\n** by the SQLite core and never invoke the\n** sqlite3_io_methods.xFileControl method.\n** ^The [SQLITE_FCNTL_FILE_POINTER] value for the op parameter causes\n** a pointer to the underlying [sqlite3_file] object to be written into\n** the space pointed to by the 4th parameter.  The\n** [SQLITE_FCNTL_JOURNAL_POINTER] works similarly except that it returns\n** the [sqlite3_file] object associated with the journal file instead of\n** the main database.  The [SQLITE_FCNTL_VFS_POINTER] opcode returns\n** a pointer to the underlying [sqlite3_vfs] object for the file.\n** The [SQLITE_FCNTL_DATA_VERSION] returns the data version counter\n** from the pager.\n**\n** ^If the second parameter (zDbName) does not match the name of any\n** open database file, then SQLITE_ERROR is returned.  ^This error\n** code is not remembered and will not be recalled by [sqlite3_errcode()]\n** or [sqlite3_errmsg()].  The underlying xFileControl method might\n** also return SQLITE_ERROR.  There is no way to distinguish between\n** an incorrect zDbName and an SQLITE_ERROR return from the underlying\n** xFileControl method.\n**\n** See also: [file control opcodes]\n*/\nSQLITE_API int sqlite3_file_control(sqlite3*, const char *zDbName, int op, void*);\n\n/*\n** CAPI3REF: Testing Interface\n**\n** ^The sqlite3_test_control() interface is used to read out internal\n** state of SQLite and to inject faults into SQLite for testing\n** purposes.  ^The first parameter is an operation code that determines\n** the number, meaning, and operation of all subsequent parameters.\n**\n** This interface is not for use by applications.  It exists solely\n** for verifying the correct operation of the SQLite library.  Depending\n** on how the SQLite library is compiled, this interface might not exist.\n**\n** The details of the operation codes, their meanings, the parameters\n** they take, and what they do are all subject to change without notice.\n** Unlike most of the SQLite API, this function is not guaranteed to\n** operate consistently from one release to the next.\n*/\nSQLITE_API int sqlite3_test_control(int op, ...);\n\n/*\n** CAPI3REF: Testing Interface Operation Codes\n**\n** These constants are the valid operation code parameters used\n** as the first argument to [sqlite3_test_control()].\n**\n** These parameters and their meanings are subject to change\n** without notice.  These values are for testing purposes only.\n** Applications should not use any of these parameters or the\n** [sqlite3_test_control()] interface.\n*/\n#define SQLITE_TESTCTRL_FIRST                    5\n#define SQLITE_TESTCTRL_PRNG_SAVE                5\n#define SQLITE_TESTCTRL_PRNG_RESTORE             6\n#define SQLITE_TESTCTRL_PRNG_RESET               7  /* NOT USED */\n#define SQLITE_TESTCTRL_FK_NO_ACTION             7\n#define SQLITE_TESTCTRL_BITVEC_TEST              8\n#define SQLITE_TESTCTRL_FAULT_INSTALL            9\n#define SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS     10\n#define SQLITE_TESTCTRL_PENDING_BYTE            11\n#define SQLITE_TESTCTRL_ASSERT                  12\n#define SQLITE_TESTCTRL_ALWAYS                  13\n#define SQLITE_TESTCTRL_RESERVE                 14  /* NOT USED */\n#define SQLITE_TESTCTRL_JSON_SELFCHECK          14\n#define SQLITE_TESTCTRL_OPTIMIZATIONS           15\n#define SQLITE_TESTCTRL_ISKEYWORD               16  /* NOT USED */\n#define SQLITE_TESTCTRL_SCRATCHMALLOC           17  /* NOT USED */\n#define SQLITE_TESTCTRL_INTERNAL_FUNCTIONS      17\n#define SQLITE_TESTCTRL_LOCALTIME_FAULT         18\n#define SQLITE_TESTCTRL_EXPLAIN_STMT            19  /* NOT USED */\n#define SQLITE_TESTCTRL_ONCE_RESET_THRESHOLD    19\n#define SQLITE_TESTCTRL_NEVER_CORRUPT           20\n#define SQLITE_TESTCTRL_VDBE_COVERAGE           21\n#define SQLITE_TESTCTRL_BYTEORDER               22\n#define SQLITE_TESTCTRL_ISINIT                  23\n#define SQLITE_TESTCTRL_SORTER_MMAP             24\n#define SQLITE_TESTCTRL_IMPOSTER                25\n#define SQLITE_TESTCTRL_PARSER_COVERAGE         26\n#define SQLITE_TESTCTRL_RESULT_INTREAL          27\n#define SQLITE_TESTCTRL_PRNG_SEED               28\n#define SQLITE_TESTCTRL_EXTRA_SCHEMA_CHECKS     29\n#define SQLITE_TESTCTRL_SEEK_COUNT              30\n#define SQLITE_TESTCTRL_TRACEFLAGS              31\n#define SQLITE_TESTCTRL_TUNE                    32\n#define SQLITE_TESTCTRL_LOGEST                  33\n#define SQLITE_TESTCTRL_USELONGDOUBLE           34\n#define SQLITE_TESTCTRL_LAST                    34  /* Largest TESTCTRL */\n\n/*\n** CAPI3REF: SQL Keyword Checking\n**\n** These routines provide access to the set of SQL language keywords\n** recognized by SQLite.  Applications can uses these routines to determine\n** whether or not a specific identifier needs to be escaped (for example,\n** by enclosing in double-quotes) so as not to confuse the parser.\n**\n** The sqlite3_keyword_count() interface returns the number of distinct\n** keywords understood by SQLite.\n**\n** The sqlite3_keyword_name(N,Z,L) interface finds the 0-based N-th keyword and\n** makes *Z point to that keyword expressed as UTF8 and writes the number\n** of bytes in the keyword into *L.  The string that *Z points to is not\n** zero-terminated.  The sqlite3_keyword_name(N,Z,L) routine returns\n** SQLITE_OK if N is within bounds and SQLITE_ERROR if not. If either Z\n** or L are NULL or invalid pointers then calls to\n** sqlite3_keyword_name(N,Z,L) result in undefined behavior.\n**\n** The sqlite3_keyword_check(Z,L) interface checks to see whether or not\n** the L-byte UTF8 identifier that Z points to is a keyword, returning non-zero\n** if it is and zero if not.\n**\n** The parser used by SQLite is forgiving.  It is often possible to use\n** a keyword as an identifier as long as such use does not result in a\n** parsing ambiguity.  For example, the statement\n** \"CREATE TABLE BEGIN(REPLACE,PRAGMA,END);\" is accepted by SQLite, and\n** creates a new table named \"BEGIN\" with three columns named\n** \"REPLACE\", \"PRAGMA\", and \"END\".  Nevertheless, best practice is to avoid\n** using keywords as identifiers.  Common techniques used to avoid keyword\n** name collisions include:\n** <ul>\n** <li> Put all identifier names inside double-quotes.  This is the official\n**      SQL way to escape identifier names.\n** <li> Put identifier names inside &#91;...&#93;.  This is not standard SQL,\n**      but it is what SQL Server does and so lots of programmers use this\n**      technique.\n** <li> Begin every identifier with the letter \"Z\" as no SQL keywords start\n**      with \"Z\".\n** <li> Include a digit somewhere in every identifier name.\n** </ul>\n**\n** Note that the number of keywords understood by SQLite can depend on\n** compile-time options.  For example, \"VACUUM\" is not a keyword if\n** SQLite is compiled with the [-DSQLITE_OMIT_VACUUM] option.  Also,\n** new keywords may be added to future releases of SQLite.\n*/\nSQLITE_API int sqlite3_keyword_count(void);\nSQLITE_API int sqlite3_keyword_name(int,const char**,int*);\nSQLITE_API int sqlite3_keyword_check(const char*,int);\n\n/*\n** CAPI3REF: Dynamic String Object\n** KEYWORDS: {dynamic string}\n**\n** An instance of the sqlite3_str object contains a dynamically-sized\n** string under construction.\n**\n** The lifecycle of an sqlite3_str object is as follows:\n** <ol>\n** <li> ^The sqlite3_str object is created using [sqlite3_str_new()].\n** <li> ^Text is appended to the sqlite3_str object using various\n** methods, such as [sqlite3_str_appendf()].\n** <li> ^The sqlite3_str object is destroyed and the string it created\n** is returned using the [sqlite3_str_finish()] interface.\n** </ol>\n*/\ntypedef struct sqlite3_str sqlite3_str;\n\n/*\n** CAPI3REF: Create A New Dynamic String Object\n** CONSTRUCTOR: sqlite3_str\n**\n** ^The [sqlite3_str_new(D)] interface allocates and initializes\n** a new [sqlite3_str] object.  To avoid memory leaks, the object returned by\n** [sqlite3_str_new()] must be freed by a subsequent call to\n** [sqlite3_str_finish(X)].\n**\n** ^The [sqlite3_str_new(D)] interface always returns a pointer to a\n** valid [sqlite3_str] object, though in the event of an out-of-memory\n** error the returned object might be a special singleton that will\n** silently reject new text, always return SQLITE_NOMEM from\n** [sqlite3_str_errcode()], always return 0 for\n** [sqlite3_str_length()], and always return NULL from\n** [sqlite3_str_finish(X)].  It is always safe to use the value\n** returned by [sqlite3_str_new(D)] as the sqlite3_str parameter\n** to any of the other [sqlite3_str] methods.\n**\n** The D parameter to [sqlite3_str_new(D)] may be NULL.  If the\n** D parameter in [sqlite3_str_new(D)] is not NULL, then the maximum\n** length of the string contained in the [sqlite3_str] object will be\n** the value set for [sqlite3_limit](D,[SQLITE_LIMIT_LENGTH]) instead\n** of [SQLITE_MAX_LENGTH].\n*/\nSQLITE_API sqlite3_str *sqlite3_str_new(sqlite3*);\n\n/*\n** CAPI3REF: Finalize A Dynamic String\n** DESTRUCTOR: sqlite3_str\n**\n** ^The [sqlite3_str_finish(X)] interface destroys the sqlite3_str object X\n** and returns a pointer to a memory buffer obtained from [sqlite3_malloc64()]\n** that contains the constructed string.  The calling application should\n** pass the returned value to [sqlite3_free()] to avoid a memory leak.\n** ^The [sqlite3_str_finish(X)] interface may return a NULL pointer if any\n** errors were encountered during construction of the string.  ^The\n** [sqlite3_str_finish(X)] interface will also return a NULL pointer if the\n** string in [sqlite3_str] object X is zero bytes long.\n*/\nSQLITE_API char *sqlite3_str_finish(sqlite3_str*);\n\n/*\n** CAPI3REF: Add Content To A Dynamic String\n** METHOD: sqlite3_str\n**\n** These interfaces add content to an sqlite3_str object previously obtained\n** from [sqlite3_str_new()].\n**\n** ^The [sqlite3_str_appendf(X,F,...)] and\n** [sqlite3_str_vappendf(X,F,V)] interfaces uses the [built-in printf]\n** functionality of SQLite to append formatted text onto the end of\n** [sqlite3_str] object X.\n**\n** ^The [sqlite3_str_append(X,S,N)] method appends exactly N bytes from string S\n** onto the end of the [sqlite3_str] object X.  N must be non-negative.\n** S must contain at least N non-zero bytes of content.  To append a\n** zero-terminated string in its entirety, use the [sqlite3_str_appendall()]\n** method instead.\n**\n** ^The [sqlite3_str_appendall(X,S)] method appends the complete content of\n** zero-terminated string S onto the end of [sqlite3_str] object X.\n**\n** ^The [sqlite3_str_appendchar(X,N,C)] method appends N copies of the\n** single-byte character C onto the end of [sqlite3_str] object X.\n** ^This method can be used, for example, to add whitespace indentation.\n**\n** ^The [sqlite3_str_reset(X)] method resets the string under construction\n** inside [sqlite3_str] object X back to zero bytes in length.\n**\n** These methods do not return a result code.  ^If an error occurs, that fact\n** is recorded in the [sqlite3_str] object and can be recovered by a\n** subsequent call to [sqlite3_str_errcode(X)].\n*/\nSQLITE_API void sqlite3_str_appendf(sqlite3_str*, const char *zFormat, ...);\nSQLITE_API void sqlite3_str_vappendf(sqlite3_str*, const char *zFormat, va_list);\nSQLITE_API void sqlite3_str_append(sqlite3_str*, const char *zIn, int N);\nSQLITE_API void sqlite3_str_appendall(sqlite3_str*, const char *zIn);\nSQLITE_API void sqlite3_str_appendchar(sqlite3_str*, int N, char C);\nSQLITE_API void sqlite3_str_reset(sqlite3_str*);\n\n/*\n** CAPI3REF: Status Of A Dynamic String\n** METHOD: sqlite3_str\n**\n** These interfaces return the current status of an [sqlite3_str] object.\n**\n** ^If any prior errors have occurred while constructing the dynamic string\n** in sqlite3_str X, then the [sqlite3_str_errcode(X)] method will return\n** an appropriate error code.  ^The [sqlite3_str_errcode(X)] method returns\n** [SQLITE_NOMEM] following any out-of-memory error, or\n** [SQLITE_TOOBIG] if the size of the dynamic string exceeds\n** [SQLITE_MAX_LENGTH], or [SQLITE_OK] if there have been no errors.\n**\n** ^The [sqlite3_str_length(X)] method returns the current length, in bytes,\n** of the dynamic string under construction in [sqlite3_str] object X.\n** ^The length returned by [sqlite3_str_length(X)] does not include the\n** zero-termination byte.\n**\n** ^The [sqlite3_str_value(X)] method returns a pointer to the current\n** content of the dynamic string under construction in X.  The value\n** returned by [sqlite3_str_value(X)] is managed by the sqlite3_str object X\n** and might be freed or altered by any subsequent method on the same\n** [sqlite3_str] object.  Applications must not used the pointer returned\n** [sqlite3_str_value(X)] after any subsequent method call on the same\n** object.  ^Applications may change the content of the string returned\n** by [sqlite3_str_value(X)] as long as they do not write into any bytes\n** outside the range of 0 to [sqlite3_str_length(X)] and do not read or\n** write any byte after any subsequent sqlite3_str method call.\n*/\nSQLITE_API int sqlite3_str_errcode(sqlite3_str*);\nSQLITE_API int sqlite3_str_length(sqlite3_str*);\nSQLITE_API char *sqlite3_str_value(sqlite3_str*);\n\n/*\n** CAPI3REF: SQLite Runtime Status\n**\n** ^These interfaces are used to retrieve runtime status information\n** about the performance of SQLite, and optionally to reset various\n** highwater marks.  ^The first argument is an integer code for\n** the specific parameter to measure.  ^(Recognized integer codes\n** are of the form [status parameters | SQLITE_STATUS_...].)^\n** ^The current value of the parameter is returned into *pCurrent.\n** ^The highest recorded value is returned in *pHighwater.  ^If the\n** resetFlag is true, then the highest record value is reset after\n** *pHighwater is written.  ^(Some parameters do not record the highest\n** value.  For those parameters\n** nothing is written into *pHighwater and the resetFlag is ignored.)^\n** ^(Other parameters record only the highwater mark and not the current\n** value.  For these latter parameters nothing is written into *pCurrent.)^\n**\n** ^The sqlite3_status() and sqlite3_status64() routines return\n** SQLITE_OK on success and a non-zero [error code] on failure.\n**\n** If either the current value or the highwater mark is too large to\n** be represented by a 32-bit integer, then the values returned by\n** sqlite3_status() are undefined.\n**\n** See also: [sqlite3_db_status()]\n*/\nSQLITE_API int sqlite3_status(int op, int *pCurrent, int *pHighwater, int resetFlag);\nSQLITE_API int sqlite3_status64(\n  int op,\n  sqlite3_int64 *pCurrent,\n  sqlite3_int64 *pHighwater,\n  int resetFlag\n);\n\n\n/*\n** CAPI3REF: Status Parameters\n** KEYWORDS: {status parameters}\n**\n** These integer constants designate various run-time status parameters\n** that can be returned by [sqlite3_status()].\n**\n** <dl>\n** [[SQLITE_STATUS_MEMORY_USED]] ^(<dt>SQLITE_STATUS_MEMORY_USED</dt>\n** <dd>This parameter is the current amount of memory checked out\n** using [sqlite3_malloc()], either directly or indirectly.  The\n** figure includes calls made to [sqlite3_malloc()] by the application\n** and internal memory usage by the SQLite library.  Auxiliary page-cache\n** memory controlled by [SQLITE_CONFIG_PAGECACHE] is not included in\n** this parameter.  The amount returned is the sum of the allocation\n** sizes as reported by the xSize method in [sqlite3_mem_methods].</dd>)^\n**\n** [[SQLITE_STATUS_MALLOC_SIZE]] ^(<dt>SQLITE_STATUS_MALLOC_SIZE</dt>\n** <dd>This parameter records the largest memory allocation request\n** handed to [sqlite3_malloc()] or [sqlite3_realloc()] (or their\n** internal equivalents).  Only the value returned in the\n** *pHighwater parameter to [sqlite3_status()] is of interest.\n** The value written into the *pCurrent parameter is undefined.</dd>)^\n**\n** [[SQLITE_STATUS_MALLOC_COUNT]] ^(<dt>SQLITE_STATUS_MALLOC_COUNT</dt>\n** <dd>This parameter records the number of separate memory allocations\n** currently checked out.</dd>)^\n**\n** [[SQLITE_STATUS_PAGECACHE_USED]] ^(<dt>SQLITE_STATUS_PAGECACHE_USED</dt>\n** <dd>This parameter returns the number of pages used out of the\n** [pagecache memory allocator] that was configured using\n** [SQLITE_CONFIG_PAGECACHE].  The\n** value returned is in pages, not in bytes.</dd>)^\n**\n** [[SQLITE_STATUS_PAGECACHE_OVERFLOW]]\n** ^(<dt>SQLITE_STATUS_PAGECACHE_OVERFLOW</dt>\n** <dd>This parameter returns the number of bytes of page cache\n** allocation which could not be satisfied by the [SQLITE_CONFIG_PAGECACHE]\n** buffer and where forced to overflow to [sqlite3_malloc()].  The\n** returned value includes allocations that overflowed because they\n** where too large (they were larger than the \"sz\" parameter to\n** [SQLITE_CONFIG_PAGECACHE]) and allocations that overflowed because\n** no space was left in the page cache.</dd>)^\n**\n** [[SQLITE_STATUS_PAGECACHE_SIZE]] ^(<dt>SQLITE_STATUS_PAGECACHE_SIZE</dt>\n** <dd>This parameter records the largest memory allocation request\n** handed to the [pagecache memory allocator].  Only the value returned in the\n** *pHighwater parameter to [sqlite3_status()] is of interest.\n** The value written into the *pCurrent parameter is undefined.</dd>)^\n**\n** [[SQLITE_STATUS_SCRATCH_USED]] <dt>SQLITE_STATUS_SCRATCH_USED</dt>\n** <dd>No longer used.</dd>\n**\n** [[SQLITE_STATUS_SCRATCH_OVERFLOW]] ^(<dt>SQLITE_STATUS_SCRATCH_OVERFLOW</dt>\n** <dd>No longer used.</dd>\n**\n** [[SQLITE_STATUS_SCRATCH_SIZE]] <dt>SQLITE_STATUS_SCRATCH_SIZE</dt>\n** <dd>No longer used.</dd>\n**\n** [[SQLITE_STATUS_PARSER_STACK]] ^(<dt>SQLITE_STATUS_PARSER_STACK</dt>\n** <dd>The *pHighwater parameter records the deepest parser stack.\n** The *pCurrent value is undefined.  The *pHighwater value is only\n** meaningful if SQLite is compiled with [YYTRACKMAXSTACKDEPTH].</dd>)^\n** </dl>\n**\n** New status parameters may be added from time to time.\n*/\n#define SQLITE_STATUS_MEMORY_USED          0\n#define SQLITE_STATUS_PAGECACHE_USED       1\n#define SQLITE_STATUS_PAGECACHE_OVERFLOW   2\n#define SQLITE_STATUS_SCRATCH_USED         3  /* NOT USED */\n#define SQLITE_STATUS_SCRATCH_OVERFLOW     4  /* NOT USED */\n#define SQLITE_STATUS_MALLOC_SIZE          5\n#define SQLITE_STATUS_PARSER_STACK         6\n#define SQLITE_STATUS_PAGECACHE_SIZE       7\n#define SQLITE_STATUS_SCRATCH_SIZE         8  /* NOT USED */\n#define SQLITE_STATUS_MALLOC_COUNT         9\n\n/*\n** CAPI3REF: Database Connection Status\n** METHOD: sqlite3\n**\n** ^This interface is used to retrieve runtime status information\n** about a single [database connection].  ^The first argument is the\n** database connection object to be interrogated.  ^The second argument\n** is an integer constant, taken from the set of\n** [SQLITE_DBSTATUS options], that\n** determines the parameter to interrogate.  The set of\n** [SQLITE_DBSTATUS options] is likely\n** to grow in future releases of SQLite.\n**\n** ^The current value of the requested parameter is written into *pCur\n** and the highest instantaneous value is written into *pHiwtr.  ^If\n** the resetFlg is true, then the highest instantaneous value is\n** reset back down to the current value.\n**\n** ^The sqlite3_db_status() routine returns SQLITE_OK on success and a\n** non-zero [error code] on failure.\n**\n** See also: [sqlite3_status()] and [sqlite3_stmt_status()].\n*/\nSQLITE_API int sqlite3_db_status(sqlite3*, int op, int *pCur, int *pHiwtr, int resetFlg);\n\n/*\n** CAPI3REF: Status Parameters for database connections\n** KEYWORDS: {SQLITE_DBSTATUS options}\n**\n** These constants are the available integer \"verbs\" that can be passed as\n** the second argument to the [sqlite3_db_status()] interface.\n**\n** New verbs may be added in future releases of SQLite. Existing verbs\n** might be discontinued. Applications should check the return code from\n** [sqlite3_db_status()] to make sure that the call worked.\n** The [sqlite3_db_status()] interface will return a non-zero error code\n** if a discontinued or unsupported verb is invoked.\n**\n** <dl>\n** [[SQLITE_DBSTATUS_LOOKASIDE_USED]] ^(<dt>SQLITE_DBSTATUS_LOOKASIDE_USED</dt>\n** <dd>This parameter returns the number of lookaside memory slots currently\n** checked out.</dd>)^\n**\n** [[SQLITE_DBSTATUS_LOOKASIDE_HIT]] ^(<dt>SQLITE_DBSTATUS_LOOKASIDE_HIT</dt>\n** <dd>This parameter returns the number of malloc attempts that were\n** satisfied using lookaside memory. Only the high-water value is meaningful;\n** the current value is always zero.)^\n**\n** [[SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE]]\n** ^(<dt>SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE</dt>\n** <dd>This parameter returns the number malloc attempts that might have\n** been satisfied using lookaside memory but failed due to the amount of\n** memory requested being larger than the lookaside slot size.\n** Only the high-water value is meaningful;\n** the current value is always zero.)^\n**\n** [[SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL]]\n** ^(<dt>SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL</dt>\n** <dd>This parameter returns the number malloc attempts that might have\n** been satisfied using lookaside memory but failed due to all lookaside\n** memory already being in use.\n** Only the high-water value is meaningful;\n** the current value is always zero.)^\n**\n** [[SQLITE_DBSTATUS_CACHE_USED]] ^(<dt>SQLITE_DBSTATUS_CACHE_USED</dt>\n** <dd>This parameter returns the approximate number of bytes of heap\n** memory used by all pager caches associated with the database connection.)^\n** ^The highwater mark associated with SQLITE_DBSTATUS_CACHE_USED is always 0.\n**\n** [[SQLITE_DBSTATUS_CACHE_USED_SHARED]]\n** ^(<dt>SQLITE_DBSTATUS_CACHE_USED_SHARED</dt>\n** <dd>This parameter is similar to DBSTATUS_CACHE_USED, except that if a\n** pager cache is shared between two or more connections the bytes of heap\n** memory used by that pager cache is divided evenly between the attached\n** connections.)^  In other words, if none of the pager caches associated\n** with the database connection are shared, this request returns the same\n** value as DBSTATUS_CACHE_USED. Or, if one or more or the pager caches are\n** shared, the value returned by this call will be smaller than that returned\n** by DBSTATUS_CACHE_USED. ^The highwater mark associated with\n** SQLITE_DBSTATUS_CACHE_USED_SHARED is always 0.\n**\n** [[SQLITE_DBSTATUS_SCHEMA_USED]] ^(<dt>SQLITE_DBSTATUS_SCHEMA_USED</dt>\n** <dd>This parameter returns the approximate number of bytes of heap\n** memory used to store the schema for all databases associated\n** with the connection - main, temp, and any [ATTACH]-ed databases.)^\n** ^The full amount of memory used by the schemas is reported, even if the\n** schema memory is shared with other database connections due to\n** [shared cache mode] being enabled.\n** ^The highwater mark associated with SQLITE_DBSTATUS_SCHEMA_USED is always 0.\n**\n** [[SQLITE_DBSTATUS_STMT_USED]] ^(<dt>SQLITE_DBSTATUS_STMT_USED</dt>\n** <dd>This parameter returns the approximate number of bytes of heap\n** and lookaside memory used by all prepared statements associated with\n** the database connection.)^\n** ^The highwater mark associated with SQLITE_DBSTATUS_STMT_USED is always 0.\n** </dd>\n**\n** [[SQLITE_DBSTATUS_CACHE_HIT]] ^(<dt>SQLITE_DBSTATUS_CACHE_HIT</dt>\n** <dd>This parameter returns the number of pager cache hits that have\n** occurred.)^ ^The highwater mark associated with SQLITE_DBSTATUS_CACHE_HIT\n** is always 0.\n** </dd>\n**\n** [[SQLITE_DBSTATUS_CACHE_MISS]] ^(<dt>SQLITE_DBSTATUS_CACHE_MISS</dt>\n** <dd>This parameter returns the number of pager cache misses that have\n** occurred.)^ ^The highwater mark associated with SQLITE_DBSTATUS_CACHE_MISS\n** is always 0.\n** </dd>\n**\n** [[SQLITE_DBSTATUS_CACHE_WRITE]] ^(<dt>SQLITE_DBSTATUS_CACHE_WRITE</dt>\n** <dd>This parameter returns the number of dirty cache entries that have\n** been written to disk. Specifically, the number of pages written to the\n** wal file in wal mode databases, or the number of pages written to the\n** database file in rollback mode databases. Any pages written as part of\n** transaction rollback or database recovery operations are not included.\n** If an IO or other error occurs while writing a page to disk, the effect\n** on subsequent SQLITE_DBSTATUS_CACHE_WRITE requests is undefined.)^ ^The\n** highwater mark associated with SQLITE_DBSTATUS_CACHE_WRITE is always 0.\n** </dd>\n**\n** [[SQLITE_DBSTATUS_CACHE_SPILL]] ^(<dt>SQLITE_DBSTATUS_CACHE_SPILL</dt>\n** <dd>This parameter returns the number of dirty cache entries that have\n** been written to disk in the middle of a transaction due to the page\n** cache overflowing. Transactions are more efficient if they are written\n** to disk all at once. When pages spill mid-transaction, that introduces\n** additional overhead. This parameter can be used help identify\n** inefficiencies that can be resolved by increasing the cache size.\n** </dd>\n**\n** [[SQLITE_DBSTATUS_DEFERRED_FKS]] ^(<dt>SQLITE_DBSTATUS_DEFERRED_FKS</dt>\n** <dd>This parameter returns zero for the current value if and only if\n** all foreign key constraints (deferred or immediate) have been\n** resolved.)^  ^The highwater mark is always 0.\n** </dd>\n** </dl>\n*/\n#define SQLITE_DBSTATUS_LOOKASIDE_USED       0\n#define SQLITE_DBSTATUS_CACHE_USED           1\n#define SQLITE_DBSTATUS_SCHEMA_USED          2\n#define SQLITE_DBSTATUS_STMT_USED            3\n#define SQLITE_DBSTATUS_LOOKASIDE_HIT        4\n#define SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE  5\n#define SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL  6\n#define SQLITE_DBSTATUS_CACHE_HIT            7\n#define SQLITE_DBSTATUS_CACHE_MISS           8\n#define SQLITE_DBSTATUS_CACHE_WRITE          9\n#define SQLITE_DBSTATUS_DEFERRED_FKS        10\n#define SQLITE_DBSTATUS_CACHE_USED_SHARED   11\n#define SQLITE_DBSTATUS_CACHE_SPILL         12\n#define SQLITE_DBSTATUS_MAX                 12   /* Largest defined DBSTATUS */\n\n\n/*\n** CAPI3REF: Prepared Statement Status\n** METHOD: sqlite3_stmt\n**\n** ^(Each prepared statement maintains various\n** [SQLITE_STMTSTATUS counters] that measure the number\n** of times it has performed specific operations.)^  These counters can\n** be used to monitor the performance characteristics of the prepared\n** statements.  For example, if the number of table steps greatly exceeds\n** the number of table searches or result rows, that would tend to indicate\n** that the prepared statement is using a full table scan rather than\n** an index.\n**\n** ^(This interface is used to retrieve and reset counter values from\n** a [prepared statement].  The first argument is the prepared statement\n** object to be interrogated.  The second argument\n** is an integer code for a specific [SQLITE_STMTSTATUS counter]\n** to be interrogated.)^\n** ^The current value of the requested counter is returned.\n** ^If the resetFlg is true, then the counter is reset to zero after this\n** interface call returns.\n**\n** See also: [sqlite3_status()] and [sqlite3_db_status()].\n*/\nSQLITE_API int sqlite3_stmt_status(sqlite3_stmt*, int op,int resetFlg);\n\n/*\n** CAPI3REF: Status Parameters for prepared statements\n** KEYWORDS: {SQLITE_STMTSTATUS counter} {SQLITE_STMTSTATUS counters}\n**\n** These preprocessor macros define integer codes that name counter\n** values associated with the [sqlite3_stmt_status()] interface.\n** The meanings of the various counters are as follows:\n**\n** <dl>\n** [[SQLITE_STMTSTATUS_FULLSCAN_STEP]] <dt>SQLITE_STMTSTATUS_FULLSCAN_STEP</dt>\n** <dd>^This is the number of times that SQLite has stepped forward in\n** a table as part of a full table scan.  Large numbers for this counter\n** may indicate opportunities for performance improvement through\n** careful use of indices.</dd>\n**\n** [[SQLITE_STMTSTATUS_SORT]] <dt>SQLITE_STMTSTATUS_SORT</dt>\n** <dd>^This is the number of sort operations that have occurred.\n** A non-zero value in this counter may indicate an opportunity to\n** improvement performance through careful use of indices.</dd>\n**\n** [[SQLITE_STMTSTATUS_AUTOINDEX]] <dt>SQLITE_STMTSTATUS_AUTOINDEX</dt>\n** <dd>^This is the number of rows inserted into transient indices that\n** were created automatically in order to help joins run faster.\n** A non-zero value in this counter may indicate an opportunity to\n** improvement performance by adding permanent indices that do not\n** need to be reinitialized each time the statement is run.</dd>\n**\n** [[SQLITE_STMTSTATUS_VM_STEP]] <dt>SQLITE_STMTSTATUS_VM_STEP</dt>\n** <dd>^This is the number of virtual machine operations executed\n** by the prepared statement if that number is less than or equal\n** to 2147483647.  The number of virtual machine operations can be\n** used as a proxy for the total work done by the prepared statement.\n** If the number of virtual machine operations exceeds 2147483647\n** then the value returned by this statement status code is undefined.\n**\n** [[SQLITE_STMTSTATUS_REPREPARE]] <dt>SQLITE_STMTSTATUS_REPREPARE</dt>\n** <dd>^This is the number of times that the prepare statement has been\n** automatically regenerated due to schema changes or changes to\n** [bound parameters] that might affect the query plan.\n**\n** [[SQLITE_STMTSTATUS_RUN]] <dt>SQLITE_STMTSTATUS_RUN</dt>\n** <dd>^This is the number of times that the prepared statement has\n** been run.  A single \"run\" for the purposes of this counter is one\n** or more calls to [sqlite3_step()] followed by a call to [sqlite3_reset()].\n** The counter is incremented on the first [sqlite3_step()] call of each\n** cycle.\n**\n** [[SQLITE_STMTSTATUS_FILTER_MISS]]\n** [[SQLITE_STMTSTATUS_FILTER HIT]]\n** <dt>SQLITE_STMTSTATUS_FILTER_HIT<br>\n** SQLITE_STMTSTATUS_FILTER_MISS</dt>\n** <dd>^SQLITE_STMTSTATUS_FILTER_HIT is the number of times that a join\n** step was bypassed because a Bloom filter returned not-found.  The\n** corresponding SQLITE_STMTSTATUS_FILTER_MISS value is the number of\n** times that the Bloom filter returned a find, and thus the join step\n** had to be processed as normal.\n**\n** [[SQLITE_STMTSTATUS_MEMUSED]] <dt>SQLITE_STMTSTATUS_MEMUSED</dt>\n** <dd>^This is the approximate number of bytes of heap memory\n** used to store the prepared statement.  ^This value is not actually\n** a counter, and so the resetFlg parameter to sqlite3_stmt_status()\n** is ignored when the opcode is SQLITE_STMTSTATUS_MEMUSED.\n** </dd>\n** </dl>\n*/\n#define SQLITE_STMTSTATUS_FULLSCAN_STEP     1\n#define SQLITE_STMTSTATUS_SORT              2\n#define SQLITE_STMTSTATUS_AUTOINDEX         3\n#define SQLITE_STMTSTATUS_VM_STEP           4\n#define SQLITE_STMTSTATUS_REPREPARE         5\n#define SQLITE_STMTSTATUS_RUN               6\n#define SQLITE_STMTSTATUS_FILTER_MISS       7\n#define SQLITE_STMTSTATUS_FILTER_HIT        8\n#define SQLITE_STMTSTATUS_MEMUSED           99\n\n/*\n** CAPI3REF: Custom Page Cache Object\n**\n** The sqlite3_pcache type is opaque.  It is implemented by\n** the pluggable module.  The SQLite core has no knowledge of\n** its size or internal structure and never deals with the\n** sqlite3_pcache object except by holding and passing pointers\n** to the object.\n**\n** See [sqlite3_pcache_methods2] for additional information.\n*/\ntypedef struct sqlite3_pcache sqlite3_pcache;\n\n/*\n** CAPI3REF: Custom Page Cache Object\n**\n** The sqlite3_pcache_page object represents a single page in the\n** page cache.  The page cache will allocate instances of this\n** object.  Various methods of the page cache use pointers to instances\n** of this object as parameters or as their return value.\n**\n** See [sqlite3_pcache_methods2] for additional information.\n*/\ntypedef struct sqlite3_pcache_page sqlite3_pcache_page;\nstruct sqlite3_pcache_page {\n  void *pBuf;        /* The content of the page */\n  void *pExtra;      /* Extra information associated with the page */\n};\n\n/*\n** CAPI3REF: Application Defined Page Cache.\n** KEYWORDS: {page cache}\n**\n** ^(The [sqlite3_config]([SQLITE_CONFIG_PCACHE2], ...) interface can\n** register an alternative page cache implementation by passing in an\n** instance of the sqlite3_pcache_methods2 structure.)^\n** In many applications, most of the heap memory allocated by\n** SQLite is used for the page cache.\n** By implementing a\n** custom page cache using this API, an application can better control\n** the amount of memory consumed by SQLite, the way in which\n** that memory is allocated and released, and the policies used to\n** determine exactly which parts of a database file are cached and for\n** how long.\n**\n** The alternative page cache mechanism is an\n** extreme measure that is only needed by the most demanding applications.\n** The built-in page cache is recommended for most uses.\n**\n** ^(The contents of the sqlite3_pcache_methods2 structure are copied to an\n** internal buffer by SQLite within the call to [sqlite3_config].  Hence\n** the application may discard the parameter after the call to\n** [sqlite3_config()] returns.)^\n**\n** [[the xInit() page cache method]]\n** ^(The xInit() method is called once for each effective\n** call to [sqlite3_initialize()])^\n** (usually only once during the lifetime of the process). ^(The xInit()\n** method is passed a copy of the sqlite3_pcache_methods2.pArg value.)^\n** The intent of the xInit() method is to set up global data structures\n** required by the custom page cache implementation.\n** ^(If the xInit() method is NULL, then the\n** built-in default page cache is used instead of the application defined\n** page cache.)^\n**\n** [[the xShutdown() page cache method]]\n** ^The xShutdown() method is called by [sqlite3_shutdown()].\n** It can be used to clean up\n** any outstanding resources before process shutdown, if required.\n** ^The xShutdown() method may be NULL.\n**\n** ^SQLite automatically serializes calls to the xInit method,\n** so the xInit method need not be threadsafe.  ^The\n** xShutdown method is only called from [sqlite3_shutdown()] so it does\n** not need to be threadsafe either.  All other methods must be threadsafe\n** in multithreaded applications.\n**\n** ^SQLite will never invoke xInit() more than once without an intervening\n** call to xShutdown().\n**\n** [[the xCreate() page cache methods]]\n** ^SQLite invokes the xCreate() method to construct a new cache instance.\n** SQLite will typically create one cache instance for each open database file,\n** though this is not guaranteed. ^The\n** first parameter, szPage, is the size in bytes of the pages that must\n** be allocated by the cache.  ^szPage will always a power of two.  ^The\n** second parameter szExtra is a number of bytes of extra storage\n** associated with each page cache entry.  ^The szExtra parameter will\n** a number less than 250.  SQLite will use the\n** extra szExtra bytes on each page to store metadata about the underlying\n** database page on disk.  The value passed into szExtra depends\n** on the SQLite version, the target platform, and how SQLite was compiled.\n** ^The third argument to xCreate(), bPurgeable, is true if the cache being\n** created will be used to cache database pages of a file stored on disk, or\n** false if it is used for an in-memory database. The cache implementation\n** does not have to do anything special based with the value of bPurgeable;\n** it is purely advisory.  ^On a cache where bPurgeable is false, SQLite will\n** never invoke xUnpin() except to deliberately delete a page.\n** ^In other words, calls to xUnpin() on a cache with bPurgeable set to\n** false will always have the \"discard\" flag set to true.\n** ^Hence, a cache created with bPurgeable false will\n** never contain any unpinned pages.\n**\n** [[the xCachesize() page cache method]]\n** ^(The xCachesize() method may be called at any time by SQLite to set the\n** suggested maximum cache-size (number of pages stored by) the cache\n** instance passed as the first argument. This is the value configured using\n** the SQLite \"[PRAGMA cache_size]\" command.)^  As with the bPurgeable\n** parameter, the implementation is not required to do anything with this\n** value; it is advisory only.\n**\n** [[the xPagecount() page cache methods]]\n** The xPagecount() method must return the number of pages currently\n** stored in the cache, both pinned and unpinned.\n**\n** [[the xFetch() page cache methods]]\n** The xFetch() method locates a page in the cache and returns a pointer to\n** an sqlite3_pcache_page object associated with that page, or a NULL pointer.\n** The pBuf element of the returned sqlite3_pcache_page object will be a\n** pointer to a buffer of szPage bytes used to store the content of a\n** single database page.  The pExtra element of sqlite3_pcache_page will be\n** a pointer to the szExtra bytes of extra storage that SQLite has requested\n** for each entry in the page cache.\n**\n** The page to be fetched is determined by the key. ^The minimum key value\n** is 1.  After it has been retrieved using xFetch, the page is considered\n** to be \"pinned\".\n**\n** If the requested page is already in the page cache, then the page cache\n** implementation must return a pointer to the page buffer with its content\n** intact.  If the requested page is not already in the cache, then the\n** cache implementation should use the value of the createFlag\n** parameter to help it determined what action to take:\n**\n** <table border=1 width=85% align=center>\n** <tr><th> createFlag <th> Behavior when page is not already in cache\n** <tr><td> 0 <td> Do not allocate a new page.  Return NULL.\n** <tr><td> 1 <td> Allocate a new page if it easy and convenient to do so.\n**                 Otherwise return NULL.\n** <tr><td> 2 <td> Make every effort to allocate a new page.  Only return\n**                 NULL if allocating a new page is effectively impossible.\n** </table>\n**\n** ^(SQLite will normally invoke xFetch() with a createFlag of 0 or 1.  SQLite\n** will only use a createFlag of 2 after a prior call with a createFlag of 1\n** failed.)^  In between the xFetch() calls, SQLite may\n** attempt to unpin one or more cache pages by spilling the content of\n** pinned pages to disk and synching the operating system disk cache.\n**\n** [[the xUnpin() page cache method]]\n** ^xUnpin() is called by SQLite with a pointer to a currently pinned page\n** as its second argument.  If the third parameter, discard, is non-zero,\n** then the page must be evicted from the cache.\n** ^If the discard parameter is\n** zero, then the page may be discarded or retained at the discretion of\n** page cache implementation. ^The page cache implementation\n** may choose to evict unpinned pages at any time.\n**\n** The cache must not perform any reference counting. A single\n** call to xUnpin() unpins the page regardless of the number of prior calls\n** to xFetch().\n**\n** [[the xRekey() page cache methods]]\n** The xRekey() method is used to change the key value associated with the\n** page passed as the second argument. If the cache\n** previously contains an entry associated with newKey, it must be\n** discarded. ^Any prior cache entry associated with newKey is guaranteed not\n** to be pinned.\n**\n** When SQLite calls the xTruncate() method, the cache must discard all\n** existing cache entries with page numbers (keys) greater than or equal\n** to the value of the iLimit parameter passed to xTruncate(). If any\n** of these pages are pinned, they are implicitly unpinned, meaning that\n** they can be safely discarded.\n**\n** [[the xDestroy() page cache method]]\n** ^The xDestroy() method is used to delete a cache allocated by xCreate().\n** All resources associated with the specified cache should be freed. ^After\n** calling the xDestroy() method, SQLite considers the [sqlite3_pcache*]\n** handle invalid, and will not use it with any other sqlite3_pcache_methods2\n** functions.\n**\n** [[the xShrink() page cache method]]\n** ^SQLite invokes the xShrink() method when it wants the page cache to\n** free up as much of heap memory as possible.  The page cache implementation\n** is not obligated to free any memory, but well-behaved implementations should\n** do their best.\n*/\ntypedef struct sqlite3_pcache_methods2 sqlite3_pcache_methods2;\nstruct sqlite3_pcache_methods2 {\n  int iVersion;\n  void *pArg;\n  int (*xInit)(void*);\n  void (*xShutdown)(void*);\n  sqlite3_pcache *(*xCreate)(int szPage, int szExtra, int bPurgeable);\n  void (*xCachesize)(sqlite3_pcache*, int nCachesize);\n  int (*xPagecount)(sqlite3_pcache*);\n  sqlite3_pcache_page *(*xFetch)(sqlite3_pcache*, unsigned key, int createFlag);\n  void (*xUnpin)(sqlite3_pcache*, sqlite3_pcache_page*, int discard);\n  void (*xRekey)(sqlite3_pcache*, sqlite3_pcache_page*,\n      unsigned oldKey, unsigned newKey);\n  void (*xTruncate)(sqlite3_pcache*, unsigned iLimit);\n  void (*xDestroy)(sqlite3_pcache*);\n  void (*xShrink)(sqlite3_pcache*);\n};\n\n/*\n** This is the obsolete pcache_methods object that has now been replaced\n** by sqlite3_pcache_methods2.  This object is not used by SQLite.  It is\n** retained in the header file for backwards compatibility only.\n*/\ntypedef struct sqlite3_pcache_methods sqlite3_pcache_methods;\nstruct sqlite3_pcache_methods {\n  void *pArg;\n  int (*xInit)(void*);\n  void (*xShutdown)(void*);\n  sqlite3_pcache *(*xCreate)(int szPage, int bPurgeable);\n  void (*xCachesize)(sqlite3_pcache*, int nCachesize);\n  int (*xPagecount)(sqlite3_pcache*);\n  void *(*xFetch)(sqlite3_pcache*, unsigned key, int createFlag);\n  void (*xUnpin)(sqlite3_pcache*, void*, int discard);\n  void (*xRekey)(sqlite3_pcache*, void*, unsigned oldKey, unsigned newKey);\n  void (*xTruncate)(sqlite3_pcache*, unsigned iLimit);\n  void (*xDestroy)(sqlite3_pcache*);\n};\n\n\n/*\n** CAPI3REF: Online Backup Object\n**\n** The sqlite3_backup object records state information about an ongoing\n** online backup operation.  ^The sqlite3_backup object is created by\n** a call to [sqlite3_backup_init()] and is destroyed by a call to\n** [sqlite3_backup_finish()].\n**\n** See Also: [Using the SQLite Online Backup API]\n*/\ntypedef struct sqlite3_backup sqlite3_backup;\n\n/*\n** CAPI3REF: Online Backup API.\n**\n** The backup API copies the content of one database into another.\n** It is useful either for creating backups of databases or\n** for copying in-memory databases to or from persistent files.\n**\n** See Also: [Using the SQLite Online Backup API]\n**\n** ^SQLite holds a write transaction open on the destination database file\n** for the duration of the backup operation.\n** ^The source database is read-locked only while it is being read;\n** it is not locked continuously for the entire backup operation.\n** ^Thus, the backup may be performed on a live source database without\n** preventing other database connections from\n** reading or writing to the source database while the backup is underway.\n**\n** ^(To perform a backup operation:\n**   <ol>\n**     <li><b>sqlite3_backup_init()</b> is called once to initialize the\n**         backup,\n**     <li><b>sqlite3_backup_step()</b> is called one or more times to transfer\n**         the data between the two databases, and finally\n**     <li><b>sqlite3_backup_finish()</b> is called to release all resources\n**         associated with the backup operation.\n**   </ol>)^\n** There should be exactly one call to sqlite3_backup_finish() for each\n** successful call to sqlite3_backup_init().\n**\n** [[sqlite3_backup_init()]] <b>sqlite3_backup_init()</b>\n**\n** ^The D and N arguments to sqlite3_backup_init(D,N,S,M) are the\n** [database connection] associated with the destination database\n** and the database name, respectively.\n** ^The database name is \"main\" for the main database, \"temp\" for the\n** temporary database, or the name specified after the AS keyword in\n** an [ATTACH] statement for an attached database.\n** ^The S and M arguments passed to\n** sqlite3_backup_init(D,N,S,M) identify the [database connection]\n** and database name of the source database, respectively.\n** ^The source and destination [database connections] (parameters S and D)\n** must be different or else sqlite3_backup_init(D,N,S,M) will fail with\n** an error.\n**\n** ^A call to sqlite3_backup_init() will fail, returning NULL, if\n** there is already a read or read-write transaction open on the\n** destination database.\n**\n** ^If an error occurs within sqlite3_backup_init(D,N,S,M), then NULL is\n** returned and an error code and error message are stored in the\n** destination [database connection] D.\n** ^The error code and message for the failed call to sqlite3_backup_init()\n** can be retrieved using the [sqlite3_errcode()], [sqlite3_errmsg()], and/or\n** [sqlite3_errmsg16()] functions.\n** ^A successful call to sqlite3_backup_init() returns a pointer to an\n** [sqlite3_backup] object.\n** ^The [sqlite3_backup] object may be used with the sqlite3_backup_step() and\n** sqlite3_backup_finish() functions to perform the specified backup\n** operation.\n**\n** [[sqlite3_backup_step()]] <b>sqlite3_backup_step()</b>\n**\n** ^Function sqlite3_backup_step(B,N) will copy up to N pages between\n** the source and destination databases specified by [sqlite3_backup] object B.\n** ^If N is negative, all remaining source pages are copied.\n** ^If sqlite3_backup_step(B,N) successfully copies N pages and there\n** are still more pages to be copied, then the function returns [SQLITE_OK].\n** ^If sqlite3_backup_step(B,N) successfully finishes copying all pages\n** from source to destination, then it returns [SQLITE_DONE].\n** ^If an error occurs while running sqlite3_backup_step(B,N),\n** then an [error code] is returned. ^As well as [SQLITE_OK] and\n** [SQLITE_DONE], a call to sqlite3_backup_step() may return [SQLITE_READONLY],\n** [SQLITE_NOMEM], [SQLITE_BUSY], [SQLITE_LOCKED], or an\n** [SQLITE_IOERR_ACCESS | SQLITE_IOERR_XXX] extended error code.\n**\n** ^(The sqlite3_backup_step() might return [SQLITE_READONLY] if\n** <ol>\n** <li> the destination database was opened read-only, or\n** <li> the destination database is using write-ahead-log journaling\n** and the destination and source page sizes differ, or\n** <li> the destination database is an in-memory database and the\n** destination and source page sizes differ.\n** </ol>)^\n**\n** ^If sqlite3_backup_step() cannot obtain a required file-system lock, then\n** the [sqlite3_busy_handler | busy-handler function]\n** is invoked (if one is specified). ^If the\n** busy-handler returns non-zero before the lock is available, then\n** [SQLITE_BUSY] is returned to the caller. ^In this case the call to\n** sqlite3_backup_step() can be retried later. ^If the source\n** [database connection]\n** is being used to write to the source database when sqlite3_backup_step()\n** is called, then [SQLITE_LOCKED] is returned immediately. ^Again, in this\n** case the call to sqlite3_backup_step() can be retried later on. ^(If\n** [SQLITE_IOERR_ACCESS | SQLITE_IOERR_XXX], [SQLITE_NOMEM], or\n** [SQLITE_READONLY] is returned, then\n** there is no point in retrying the call to sqlite3_backup_step(). These\n** errors are considered fatal.)^  The application must accept\n** that the backup operation has failed and pass the backup operation handle\n** to the sqlite3_backup_finish() to release associated resources.\n**\n** ^The first call to sqlite3_backup_step() obtains an exclusive lock\n** on the destination file. ^The exclusive lock is not released until either\n** sqlite3_backup_finish() is called or the backup operation is complete\n** and sqlite3_backup_step() returns [SQLITE_DONE].  ^Every call to\n** sqlite3_backup_step() obtains a [shared lock] on the source database that\n** lasts for the duration of the sqlite3_backup_step() call.\n** ^Because the source database is not locked between calls to\n** sqlite3_backup_step(), the source database may be modified mid-way\n** through the backup process.  ^If the source database is modified by an\n** external process or via a database connection other than the one being\n** used by the backup operation, then the backup will be automatically\n** restarted by the next call to sqlite3_backup_step(). ^If the source\n** database is modified by the using the same database connection as is used\n** by the backup operation, then the backup database is automatically\n** updated at the same time.\n**\n** [[sqlite3_backup_finish()]] <b>sqlite3_backup_finish()</b>\n**\n** When sqlite3_backup_step() has returned [SQLITE_DONE], or when the\n** application wishes to abandon the backup operation, the application\n** should destroy the [sqlite3_backup] by passing it to sqlite3_backup_finish().\n** ^The sqlite3_backup_finish() interfaces releases all\n** resources associated with the [sqlite3_backup] object.\n** ^If sqlite3_backup_step() has not yet returned [SQLITE_DONE], then any\n** active write-transaction on the destination database is rolled back.\n** The [sqlite3_backup] object is invalid\n** and may not be used following a call to sqlite3_backup_finish().\n**\n** ^The value returned by sqlite3_backup_finish is [SQLITE_OK] if no\n** sqlite3_backup_step() errors occurred, regardless or whether or not\n** sqlite3_backup_step() completed.\n** ^If an out-of-memory condition or IO error occurred during any prior\n** sqlite3_backup_step() call on the same [sqlite3_backup] object, then\n** sqlite3_backup_finish() returns the corresponding [error code].\n**\n** ^A return of [SQLITE_BUSY] or [SQLITE_LOCKED] from sqlite3_backup_step()\n** is not a permanent error and does not affect the return value of\n** sqlite3_backup_finish().\n**\n** [[sqlite3_backup_remaining()]] [[sqlite3_backup_pagecount()]]\n** <b>sqlite3_backup_remaining() and sqlite3_backup_pagecount()</b>\n**\n** ^The sqlite3_backup_remaining() routine returns the number of pages still\n** to be backed up at the conclusion of the most recent sqlite3_backup_step().\n** ^The sqlite3_backup_pagecount() routine returns the total number of pages\n** in the source database at the conclusion of the most recent\n** sqlite3_backup_step().\n** ^(The values returned by these functions are only updated by\n** sqlite3_backup_step(). If the source database is modified in a way that\n** changes the size of the source database or the number of pages remaining,\n** those changes are not reflected in the output of sqlite3_backup_pagecount()\n** and sqlite3_backup_remaining() until after the next\n** sqlite3_backup_step().)^\n**\n** <b>Concurrent Usage of Database Handles</b>\n**\n** ^The source [database connection] may be used by the application for other\n** purposes while a backup operation is underway or being initialized.\n** ^If SQLite is compiled and configured to support threadsafe database\n** connections, then the source database connection may be used concurrently\n** from within other threads.\n**\n** However, the application must guarantee that the destination\n** [database connection] is not passed to any other API (by any thread) after\n** sqlite3_backup_init() is called and before the corresponding call to\n** sqlite3_backup_finish().  SQLite does not currently check to see\n** if the application incorrectly accesses the destination [database connection]\n** and so no error code is reported, but the operations may malfunction\n** nevertheless.  Use of the destination database connection while a\n** backup is in progress might also cause a mutex deadlock.\n**\n** If running in [shared cache mode], the application must\n** guarantee that the shared cache used by the destination database\n** is not accessed while the backup is running. In practice this means\n** that the application must guarantee that the disk file being\n** backed up to is not accessed by any connection within the process,\n** not just the specific connection that was passed to sqlite3_backup_init().\n**\n** The [sqlite3_backup] object itself is partially threadsafe. Multiple\n** threads may safely make multiple concurrent calls to sqlite3_backup_step().\n** However, the sqlite3_backup_remaining() and sqlite3_backup_pagecount()\n** APIs are not strictly speaking threadsafe. If they are invoked at the\n** same time as another thread is invoking sqlite3_backup_step() it is\n** possible that they return invalid values.\n*/\nSQLITE_API sqlite3_backup *sqlite3_backup_init(\n  sqlite3 *pDest,                        /* Destination database handle */\n  const char *zDestName,                 /* Destination database name */\n  sqlite3 *pSource,                      /* Source database handle */\n  const char *zSourceName                /* Source database name */\n);\nSQLITE_API int sqlite3_backup_step(sqlite3_backup *p, int nPage);\nSQLITE_API int sqlite3_backup_finish(sqlite3_backup *p);\nSQLITE_API int sqlite3_backup_remaining(sqlite3_backup *p);\nSQLITE_API int sqlite3_backup_pagecount(sqlite3_backup *p);\n\n/*\n** CAPI3REF: Unlock Notification\n** METHOD: sqlite3\n**\n** ^When running in shared-cache mode, a database operation may fail with\n** an [SQLITE_LOCKED] error if the required locks on the shared-cache or\n** individual tables within the shared-cache cannot be obtained. See\n** [SQLite Shared-Cache Mode] for a description of shared-cache locking.\n** ^This API may be used to register a callback that SQLite will invoke\n** when the connection currently holding the required lock relinquishes it.\n** ^This API is only available if the library was compiled with the\n** [SQLITE_ENABLE_UNLOCK_NOTIFY] C-preprocessor symbol defined.\n**\n** See Also: [Using the SQLite Unlock Notification Feature].\n**\n** ^Shared-cache locks are released when a database connection concludes\n** its current transaction, either by committing it or rolling it back.\n**\n** ^When a connection (known as the blocked connection) fails to obtain a\n** shared-cache lock and SQLITE_LOCKED is returned to the caller, the\n** identity of the database connection (the blocking connection) that\n** has locked the required resource is stored internally. ^After an\n** application receives an SQLITE_LOCKED error, it may call the\n** sqlite3_unlock_notify() method with the blocked connection handle as\n** the first argument to register for a callback that will be invoked\n** when the blocking connections current transaction is concluded. ^The\n** callback is invoked from within the [sqlite3_step] or [sqlite3_close]\n** call that concludes the blocking connection's transaction.\n**\n** ^(If sqlite3_unlock_notify() is called in a multi-threaded application,\n** there is a chance that the blocking connection will have already\n** concluded its transaction by the time sqlite3_unlock_notify() is invoked.\n** If this happens, then the specified callback is invoked immediately,\n** from within the call to sqlite3_unlock_notify().)^\n**\n** ^If the blocked connection is attempting to obtain a write-lock on a\n** shared-cache table, and more than one other connection currently holds\n** a read-lock on the same table, then SQLite arbitrarily selects one of\n** the other connections to use as the blocking connection.\n**\n** ^(There may be at most one unlock-notify callback registered by a\n** blocked connection. If sqlite3_unlock_notify() is called when the\n** blocked connection already has a registered unlock-notify callback,\n** then the new callback replaces the old.)^ ^If sqlite3_unlock_notify() is\n** called with a NULL pointer as its second argument, then any existing\n** unlock-notify callback is canceled. ^The blocked connections\n** unlock-notify callback may also be canceled by closing the blocked\n** connection using [sqlite3_close()].\n**\n** The unlock-notify callback is not reentrant. If an application invokes\n** any sqlite3_xxx API functions from within an unlock-notify callback, a\n** crash or deadlock may be the result.\n**\n** ^Unless deadlock is detected (see below), sqlite3_unlock_notify() always\n** returns SQLITE_OK.\n**\n** <b>Callback Invocation Details</b>\n**\n** When an unlock-notify callback is registered, the application provides a\n** single void* pointer that is passed to the callback when it is invoked.\n** However, the signature of the callback function allows SQLite to pass\n** it an array of void* context pointers. The first argument passed to\n** an unlock-notify callback is a pointer to an array of void* pointers,\n** and the second is the number of entries in the array.\n**\n** When a blocking connection's transaction is concluded, there may be\n** more than one blocked connection that has registered for an unlock-notify\n** callback. ^If two or more such blocked connections have specified the\n** same callback function, then instead of invoking the callback function\n** multiple times, it is invoked once with the set of void* context pointers\n** specified by the blocked connections bundled together into an array.\n** This gives the application an opportunity to prioritize any actions\n** related to the set of unblocked database connections.\n**\n** <b>Deadlock Detection</b>\n**\n** Assuming that after registering for an unlock-notify callback a\n** database waits for the callback to be issued before taking any further\n** action (a reasonable assumption), then using this API may cause the\n** application to deadlock. For example, if connection X is waiting for\n** connection Y's transaction to be concluded, and similarly connection\n** Y is waiting on connection X's transaction, then neither connection\n** will proceed and the system may remain deadlocked indefinitely.\n**\n** To avoid this scenario, the sqlite3_unlock_notify() performs deadlock\n** detection. ^If a given call to sqlite3_unlock_notify() would put the\n** system in a deadlocked state, then SQLITE_LOCKED is returned and no\n** unlock-notify callback is registered. The system is said to be in\n** a deadlocked state if connection A has registered for an unlock-notify\n** callback on the conclusion of connection B's transaction, and connection\n** B has itself registered for an unlock-notify callback when connection\n** A's transaction is concluded. ^Indirect deadlock is also detected, so\n** the system is also considered to be deadlocked if connection B has\n** registered for an unlock-notify callback on the conclusion of connection\n** C's transaction, where connection C is waiting on connection A. ^Any\n** number of levels of indirection are allowed.\n**\n** <b>The \"DROP TABLE\" Exception</b>\n**\n** When a call to [sqlite3_step()] returns SQLITE_LOCKED, it is almost\n** always appropriate to call sqlite3_unlock_notify(). There is however,\n** one exception. When executing a \"DROP TABLE\" or \"DROP INDEX\" statement,\n** SQLite checks if there are any currently executing SELECT statements\n** that belong to the same connection. If there are, SQLITE_LOCKED is\n** returned. In this case there is no \"blocking connection\", so invoking\n** sqlite3_unlock_notify() results in the unlock-notify callback being\n** invoked immediately. If the application then re-attempts the \"DROP TABLE\"\n** or \"DROP INDEX\" query, an infinite loop might be the result.\n**\n** One way around this problem is to check the extended error code returned\n** by an sqlite3_step() call. ^(If there is a blocking connection, then the\n** extended error code is set to SQLITE_LOCKED_SHAREDCACHE. Otherwise, in\n** the special \"DROP TABLE/INDEX\" case, the extended error code is just\n** SQLITE_LOCKED.)^\n*/\nSQLITE_API int sqlite3_unlock_notify(\n  sqlite3 *pBlocked,                          /* Waiting connection */\n  void (*xNotify)(void **apArg, int nArg),    /* Callback function to invoke */\n  void *pNotifyArg                            /* Argument to pass to xNotify */\n);\n\n\n/*\n** CAPI3REF: String Comparison\n**\n** ^The [sqlite3_stricmp()] and [sqlite3_strnicmp()] APIs allow applications\n** and extensions to compare the contents of two buffers containing UTF-8\n** strings in a case-independent fashion, using the same definition of \"case\n** independence\" that SQLite uses internally when comparing identifiers.\n*/\nSQLITE_API int sqlite3_stricmp(const char *, const char *);\nSQLITE_API int sqlite3_strnicmp(const char *, const char *, int);\n\n/*\n** CAPI3REF: String Globbing\n*\n** ^The [sqlite3_strglob(P,X)] interface returns zero if and only if\n** string X matches the [GLOB] pattern P.\n** ^The definition of [GLOB] pattern matching used in\n** [sqlite3_strglob(P,X)] is the same as for the \"X GLOB P\" operator in the\n** SQL dialect understood by SQLite.  ^The [sqlite3_strglob(P,X)] function\n** is case sensitive.\n**\n** Note that this routine returns zero on a match and non-zero if the strings\n** do not match, the same as [sqlite3_stricmp()] and [sqlite3_strnicmp()].\n**\n** See also: [sqlite3_strlike()].\n*/\nSQLITE_API int sqlite3_strglob(const char *zGlob, const char *zStr);\n\n/*\n** CAPI3REF: String LIKE Matching\n*\n** ^The [sqlite3_strlike(P,X,E)] interface returns zero if and only if\n** string X matches the [LIKE] pattern P with escape character E.\n** ^The definition of [LIKE] pattern matching used in\n** [sqlite3_strlike(P,X,E)] is the same as for the \"X LIKE P ESCAPE E\"\n** operator in the SQL dialect understood by SQLite.  ^For \"X LIKE P\" without\n** the ESCAPE clause, set the E parameter of [sqlite3_strlike(P,X,E)] to 0.\n** ^As with the LIKE operator, the [sqlite3_strlike(P,X,E)] function is case\n** insensitive - equivalent upper and lower case ASCII characters match\n** one another.\n**\n** ^The [sqlite3_strlike(P,X,E)] function matches Unicode characters, though\n** only ASCII characters are case folded.\n**\n** Note that this routine returns zero on a match and non-zero if the strings\n** do not match, the same as [sqlite3_stricmp()] and [sqlite3_strnicmp()].\n**\n** See also: [sqlite3_strglob()].\n*/\nSQLITE_API int sqlite3_strlike(const char *zGlob, const char *zStr, unsigned int cEsc);\n\n/*\n** CAPI3REF: Error Logging Interface\n**\n** ^The [sqlite3_log()] interface writes a message into the [error log]\n** established by the [SQLITE_CONFIG_LOG] option to [sqlite3_config()].\n** ^If logging is enabled, the zFormat string and subsequent arguments are\n** used with [sqlite3_snprintf()] to generate the final output string.\n**\n** The sqlite3_log() interface is intended for use by extensions such as\n** virtual tables, collating functions, and SQL functions.  While there is\n** nothing to prevent an application from calling sqlite3_log(), doing so\n** is considered bad form.\n**\n** The zFormat string must not be NULL.\n**\n** To avoid deadlocks and other threading problems, the sqlite3_log() routine\n** will not use dynamically allocated memory.  The log message is stored in\n** a fixed-length buffer on the stack.  If the log message is longer than\n** a few hundred characters, it will be truncated to the length of the\n** buffer.\n*/\nSQLITE_API void sqlite3_log(int iErrCode, const char *zFormat, ...);\n\n/*\n** CAPI3REF: Write-Ahead Log Commit Hook\n** METHOD: sqlite3\n**\n** ^The [sqlite3_wal_hook()] function is used to register a callback that\n** is invoked each time data is committed to a database in wal mode.\n**\n** ^(The callback is invoked by SQLite after the commit has taken place and\n** the associated write-lock on the database released)^, so the implementation\n** may read, write or [checkpoint] the database as required.\n**\n** ^The first parameter passed to the callback function when it is invoked\n** is a copy of the third parameter passed to sqlite3_wal_hook() when\n** registering the callback. ^The second is a copy of the database handle.\n** ^The third parameter is the name of the database that was written to -\n** either \"main\" or the name of an [ATTACH]-ed database. ^The fourth parameter\n** is the number of pages currently in the write-ahead log file,\n** including those that were just committed.\n**\n** The callback function should normally return [SQLITE_OK].  ^If an error\n** code is returned, that error will propagate back up through the\n** SQLite code base to cause the statement that provoked the callback\n** to report an error, though the commit will have still occurred. If the\n** callback returns [SQLITE_ROW] or [SQLITE_DONE], or if it returns a value\n** that does not correspond to any valid SQLite error code, the results\n** are undefined.\n**\n** A single database handle may have at most a single write-ahead log callback\n** registered at one time. ^Calling [sqlite3_wal_hook()] replaces any\n** previously registered write-ahead log callback. ^The return value is\n** a copy of the third parameter from the previous call, if any, or 0.\n** ^Note that the [sqlite3_wal_autocheckpoint()] interface and the\n** [wal_autocheckpoint pragma] both invoke [sqlite3_wal_hook()] and will\n** overwrite any prior [sqlite3_wal_hook()] settings.\n*/\nSQLITE_API void *sqlite3_wal_hook(\n  sqlite3*,\n  int(*)(void *,sqlite3*,const char*,int),\n  void*\n);\n\n/*\n** CAPI3REF: Configure an auto-checkpoint\n** METHOD: sqlite3\n**\n** ^The [sqlite3_wal_autocheckpoint(D,N)] is a wrapper around\n** [sqlite3_wal_hook()] that causes any database on [database connection] D\n** to automatically [checkpoint]\n** after committing a transaction if there are N or\n** more frames in the [write-ahead log] file.  ^Passing zero or\n** a negative value as the nFrame parameter disables automatic\n** checkpoints entirely.\n**\n** ^The callback registered by this function replaces any existing callback\n** registered using [sqlite3_wal_hook()].  ^Likewise, registering a callback\n** using [sqlite3_wal_hook()] disables the automatic checkpoint mechanism\n** configured by this function.\n**\n** ^The [wal_autocheckpoint pragma] can be used to invoke this interface\n** from SQL.\n**\n** ^Checkpoints initiated by this mechanism are\n** [sqlite3_wal_checkpoint_v2|PASSIVE].\n**\n** ^Every new [database connection] defaults to having the auto-checkpoint\n** enabled with a threshold of 1000 or [SQLITE_DEFAULT_WAL_AUTOCHECKPOINT]\n** pages.  The use of this interface\n** is only necessary if the default setting is found to be suboptimal\n** for a particular application.\n*/\nSQLITE_API int sqlite3_wal_autocheckpoint(sqlite3 *db, int N);\n\n/*\n** CAPI3REF: Checkpoint a database\n** METHOD: sqlite3\n**\n** ^(The sqlite3_wal_checkpoint(D,X) is equivalent to\n** [sqlite3_wal_checkpoint_v2](D,X,[SQLITE_CHECKPOINT_PASSIVE],0,0).)^\n**\n** In brief, sqlite3_wal_checkpoint(D,X) causes the content in the\n** [write-ahead log] for database X on [database connection] D to be\n** transferred into the database file and for the write-ahead log to\n** be reset.  See the [checkpointing] documentation for addition\n** information.\n**\n** This interface used to be the only way to cause a checkpoint to\n** occur.  But then the newer and more powerful [sqlite3_wal_checkpoint_v2()]\n** interface was added.  This interface is retained for backwards\n** compatibility and as a convenience for applications that need to manually\n** start a callback but which do not need the full power (and corresponding\n** complication) of [sqlite3_wal_checkpoint_v2()].\n*/\nSQLITE_API int sqlite3_wal_checkpoint(sqlite3 *db, const char *zDb);\n\n/*\n** CAPI3REF: Checkpoint a database\n** METHOD: sqlite3\n**\n** ^(The sqlite3_wal_checkpoint_v2(D,X,M,L,C) interface runs a checkpoint\n** operation on database X of [database connection] D in mode M.  Status\n** information is written back into integers pointed to by L and C.)^\n** ^(The M parameter must be a valid [checkpoint mode]:)^\n**\n** <dl>\n** <dt>SQLITE_CHECKPOINT_PASSIVE<dd>\n**   ^Checkpoint as many frames as possible without waiting for any database\n**   readers or writers to finish, then sync the database file if all frames\n**   in the log were checkpointed. ^The [busy-handler callback]\n**   is never invoked in the SQLITE_CHECKPOINT_PASSIVE mode.\n**   ^On the other hand, passive mode might leave the checkpoint unfinished\n**   if there are concurrent readers or writers.\n**\n** <dt>SQLITE_CHECKPOINT_FULL<dd>\n**   ^This mode blocks (it invokes the\n**   [sqlite3_busy_handler|busy-handler callback]) until there is no\n**   database writer and all readers are reading from the most recent database\n**   snapshot. ^It then checkpoints all frames in the log file and syncs the\n**   database file. ^This mode blocks new database writers while it is pending,\n**   but new database readers are allowed to continue unimpeded.\n**\n** <dt>SQLITE_CHECKPOINT_RESTART<dd>\n**   ^This mode works the same way as SQLITE_CHECKPOINT_FULL with the addition\n**   that after checkpointing the log file it blocks (calls the\n**   [busy-handler callback])\n**   until all readers are reading from the database file only. ^This ensures\n**   that the next writer will restart the log file from the beginning.\n**   ^Like SQLITE_CHECKPOINT_FULL, this mode blocks new\n**   database writer attempts while it is pending, but does not impede readers.\n**\n** <dt>SQLITE_CHECKPOINT_TRUNCATE<dd>\n**   ^This mode works the same way as SQLITE_CHECKPOINT_RESTART with the\n**   addition that it also truncates the log file to zero bytes just prior\n**   to a successful return.\n** </dl>\n**\n** ^If pnLog is not NULL, then *pnLog is set to the total number of frames in\n** the log file or to -1 if the checkpoint could not run because\n** of an error or because the database is not in [WAL mode]. ^If pnCkpt is not\n** NULL,then *pnCkpt is set to the total number of checkpointed frames in the\n** log file (including any that were already checkpointed before the function\n** was called) or to -1 if the checkpoint could not run due to an error or\n** because the database is not in WAL mode. ^Note that upon successful\n** completion of an SQLITE_CHECKPOINT_TRUNCATE, the log file will have been\n** truncated to zero bytes and so both *pnLog and *pnCkpt will be set to zero.\n**\n** ^All calls obtain an exclusive \"checkpoint\" lock on the database file. ^If\n** any other process is running a checkpoint operation at the same time, the\n** lock cannot be obtained and SQLITE_BUSY is returned. ^Even if there is a\n** busy-handler configured, it will not be invoked in this case.\n**\n** ^The SQLITE_CHECKPOINT_FULL, RESTART and TRUNCATE modes also obtain the\n** exclusive \"writer\" lock on the database file. ^If the writer lock cannot be\n** obtained immediately, and a busy-handler is configured, it is invoked and\n** the writer lock retried until either the busy-handler returns 0 or the lock\n** is successfully obtained. ^The busy-handler is also invoked while waiting for\n** database readers as described above. ^If the busy-handler returns 0 before\n** the writer lock is obtained or while waiting for database readers, the\n** checkpoint operation proceeds from that point in the same way as\n** SQLITE_CHECKPOINT_PASSIVE - checkpointing as many frames as possible\n** without blocking any further. ^SQLITE_BUSY is returned in this case.\n**\n** ^If parameter zDb is NULL or points to a zero length string, then the\n** specified operation is attempted on all WAL databases [attached] to\n** [database connection] db.  In this case the\n** values written to output parameters *pnLog and *pnCkpt are undefined. ^If\n** an SQLITE_BUSY error is encountered when processing one or more of the\n** attached WAL databases, the operation is still attempted on any remaining\n** attached databases and SQLITE_BUSY is returned at the end. ^If any other\n** error occurs while processing an attached database, processing is abandoned\n** and the error code is returned to the caller immediately. ^If no error\n** (SQLITE_BUSY or otherwise) is encountered while processing the attached\n** databases, SQLITE_OK is returned.\n**\n** ^If database zDb is the name of an attached database that is not in WAL\n** mode, SQLITE_OK is returned and both *pnLog and *pnCkpt set to -1. ^If\n** zDb is not NULL (or a zero length string) and is not the name of any\n** attached database, SQLITE_ERROR is returned to the caller.\n**\n** ^Unless it returns SQLITE_MISUSE,\n** the sqlite3_wal_checkpoint_v2() interface\n** sets the error information that is queried by\n** [sqlite3_errcode()] and [sqlite3_errmsg()].\n**\n** ^The [PRAGMA wal_checkpoint] command can be used to invoke this interface\n** from SQL.\n*/\nSQLITE_API int sqlite3_wal_checkpoint_v2(\n  sqlite3 *db,                    /* Database handle */\n  const char *zDb,                /* Name of attached database (or NULL) */\n  int eMode,                      /* SQLITE_CHECKPOINT_* value */\n  int *pnLog,                     /* OUT: Size of WAL log in frames */\n  int *pnCkpt                     /* OUT: Total number of frames checkpointed */\n);\n\n/*\n** CAPI3REF: Checkpoint Mode Values\n** KEYWORDS: {checkpoint mode}\n**\n** These constants define all valid values for the \"checkpoint mode\" passed\n** as the third parameter to the [sqlite3_wal_checkpoint_v2()] interface.\n** See the [sqlite3_wal_checkpoint_v2()] documentation for details on the\n** meaning of each of these checkpoint modes.\n*/\n#define SQLITE_CHECKPOINT_PASSIVE  0  /* Do as much as possible w/o blocking */\n#define SQLITE_CHECKPOINT_FULL     1  /* Wait for writers, then checkpoint */\n#define SQLITE_CHECKPOINT_RESTART  2  /* Like FULL but wait for readers */\n#define SQLITE_CHECKPOINT_TRUNCATE 3  /* Like RESTART but also truncate WAL */\n\n/*\n** CAPI3REF: Virtual Table Interface Configuration\n**\n** This function may be called by either the [xConnect] or [xCreate] method\n** of a [virtual table] implementation to configure\n** various facets of the virtual table interface.\n**\n** If this interface is invoked outside the context of an xConnect or\n** xCreate virtual table method then the behavior is undefined.\n**\n** In the call sqlite3_vtab_config(D,C,...) the D parameter is the\n** [database connection] in which the virtual table is being created and\n** which is passed in as the first argument to the [xConnect] or [xCreate]\n** method that is invoking sqlite3_vtab_config().  The C parameter is one\n** of the [virtual table configuration options].  The presence and meaning\n** of parameters after C depend on which [virtual table configuration option]\n** is used.\n*/\nSQLITE_API int sqlite3_vtab_config(sqlite3*, int op, ...);\n\n/*\n** CAPI3REF: Virtual Table Configuration Options\n** KEYWORDS: {virtual table configuration options}\n** KEYWORDS: {virtual table configuration option}\n**\n** These macros define the various options to the\n** [sqlite3_vtab_config()] interface that [virtual table] implementations\n** can use to customize and optimize their behavior.\n**\n** <dl>\n** [[SQLITE_VTAB_CONSTRAINT_SUPPORT]]\n** <dt>SQLITE_VTAB_CONSTRAINT_SUPPORT</dt>\n** <dd>Calls of the form\n** [sqlite3_vtab_config](db,SQLITE_VTAB_CONSTRAINT_SUPPORT,X) are supported,\n** where X is an integer.  If X is zero, then the [virtual table] whose\n** [xCreate] or [xConnect] method invoked [sqlite3_vtab_config()] does not\n** support constraints.  In this configuration (which is the default) if\n** a call to the [xUpdate] method returns [SQLITE_CONSTRAINT], then the entire\n** statement is rolled back as if [ON CONFLICT | OR ABORT] had been\n** specified as part of the users SQL statement, regardless of the actual\n** ON CONFLICT mode specified.\n**\n** If X is non-zero, then the virtual table implementation guarantees\n** that if [xUpdate] returns [SQLITE_CONSTRAINT], it will do so before\n** any modifications to internal or persistent data structures have been made.\n** If the [ON CONFLICT] mode is ABORT, FAIL, IGNORE or ROLLBACK, SQLite\n** is able to roll back a statement or database transaction, and abandon\n** or continue processing the current SQL statement as appropriate.\n** If the ON CONFLICT mode is REPLACE and the [xUpdate] method returns\n** [SQLITE_CONSTRAINT], SQLite handles this as if the ON CONFLICT mode\n** had been ABORT.\n**\n** Virtual table implementations that are required to handle OR REPLACE\n** must do so within the [xUpdate] method. If a call to the\n** [sqlite3_vtab_on_conflict()] function indicates that the current ON\n** CONFLICT policy is REPLACE, the virtual table implementation should\n** silently replace the appropriate rows within the xUpdate callback and\n** return SQLITE_OK. Or, if this is not possible, it may return\n** SQLITE_CONSTRAINT, in which case SQLite falls back to OR ABORT\n** constraint handling.\n** </dd>\n**\n** [[SQLITE_VTAB_DIRECTONLY]]<dt>SQLITE_VTAB_DIRECTONLY</dt>\n** <dd>Calls of the form\n** [sqlite3_vtab_config](db,SQLITE_VTAB_DIRECTONLY) from within the\n** the [xConnect] or [xCreate] methods of a [virtual table] implementation\n** prohibits that virtual table from being used from within triggers and\n** views.\n** </dd>\n**\n** [[SQLITE_VTAB_INNOCUOUS]]<dt>SQLITE_VTAB_INNOCUOUS</dt>\n** <dd>Calls of the form\n** [sqlite3_vtab_config](db,SQLITE_VTAB_INNOCUOUS) from within the\n** the [xConnect] or [xCreate] methods of a [virtual table] implementation\n** identify that virtual table as being safe to use from within triggers\n** and views.  Conceptually, the SQLITE_VTAB_INNOCUOUS tag means that the\n** virtual table can do no serious harm even if it is controlled by a\n** malicious hacker.  Developers should avoid setting the SQLITE_VTAB_INNOCUOUS\n** flag unless absolutely necessary.\n** </dd>\n**\n** [[SQLITE_VTAB_USES_ALL_SCHEMAS]]<dt>SQLITE_VTAB_USES_ALL_SCHEMAS</dt>\n** <dd>Calls of the form\n** [sqlite3_vtab_config](db,SQLITE_VTAB_USES_ALL_SCHEMA) from within the\n** the [xConnect] or [xCreate] methods of a [virtual table] implementation\n** instruct the query planner to begin at least a read transaction on\n** all schemas (\"main\", \"temp\", and any ATTACH-ed databases) whenever the\n** virtual table is used.\n** </dd>\n** </dl>\n*/\n#define SQLITE_VTAB_CONSTRAINT_SUPPORT 1\n#define SQLITE_VTAB_INNOCUOUS          2\n#define SQLITE_VTAB_DIRECTONLY         3\n#define SQLITE_VTAB_USES_ALL_SCHEMAS   4\n\n/*\n** CAPI3REF: Determine The Virtual Table Conflict Policy\n**\n** This function may only be called from within a call to the [xUpdate] method\n** of a [virtual table] implementation for an INSERT or UPDATE operation. ^The\n** value returned is one of [SQLITE_ROLLBACK], [SQLITE_IGNORE], [SQLITE_FAIL],\n** [SQLITE_ABORT], or [SQLITE_REPLACE], according to the [ON CONFLICT] mode\n** of the SQL statement that triggered the call to the [xUpdate] method of the\n** [virtual table].\n*/\nSQLITE_API int sqlite3_vtab_on_conflict(sqlite3 *);\n\n/*\n** CAPI3REF: Determine If Virtual Table Column Access Is For UPDATE\n**\n** If the sqlite3_vtab_nochange(X) routine is called within the [xColumn]\n** method of a [virtual table], then it might return true if the\n** column is being fetched as part of an UPDATE operation during which the\n** column value will not change.  The virtual table implementation can use\n** this hint as permission to substitute a return value that is less\n** expensive to compute and that the corresponding\n** [xUpdate] method understands as a \"no-change\" value.\n**\n** If the [xColumn] method calls sqlite3_vtab_nochange() and finds that\n** the column is not changed by the UPDATE statement, then the xColumn\n** method can optionally return without setting a result, without calling\n** any of the [sqlite3_result_int|sqlite3_result_xxxxx() interfaces].\n** In that case, [sqlite3_value_nochange(X)] will return true for the\n** same column in the [xUpdate] method.\n**\n** The sqlite3_vtab_nochange() routine is an optimization.  Virtual table\n** implementations should continue to give a correct answer even if the\n** sqlite3_vtab_nochange() interface were to always return false.  In the\n** current implementation, the sqlite3_vtab_nochange() interface does always\n** returns false for the enhanced [UPDATE FROM] statement.\n*/\nSQLITE_API int sqlite3_vtab_nochange(sqlite3_context*);\n\n/*\n** CAPI3REF: Determine The Collation For a Virtual Table Constraint\n** METHOD: sqlite3_index_info\n**\n** This function may only be called from within a call to the [xBestIndex]\n** method of a [virtual table].  This function returns a pointer to a string\n** that is the name of the appropriate collation sequence to use for text\n** comparisons on the constraint identified by its arguments.\n**\n** The first argument must be the pointer to the [sqlite3_index_info] object\n** that is the first parameter to the xBestIndex() method. The second argument\n** must be an index into the aConstraint[] array belonging to the\n** sqlite3_index_info structure passed to xBestIndex.\n**\n** Important:\n** The first parameter must be the same pointer that is passed into the\n** xBestMethod() method.  The first parameter may not be a pointer to a\n** different [sqlite3_index_info] object, even an exact copy.\n**\n** The return value is computed as follows:\n**\n** <ol>\n** <li><p> If the constraint comes from a WHERE clause expression that contains\n**         a [COLLATE operator], then the name of the collation specified by\n**         that COLLATE operator is returned.\n** <li><p> If there is no COLLATE operator, but the column that is the subject\n**         of the constraint specifies an alternative collating sequence via\n**         a [COLLATE clause] on the column definition within the CREATE TABLE\n**         statement that was passed into [sqlite3_declare_vtab()], then the\n**         name of that alternative collating sequence is returned.\n** <li><p> Otherwise, \"BINARY\" is returned.\n** </ol>\n*/\nSQLITE_API const char *sqlite3_vtab_collation(sqlite3_index_info*,int);\n\n/*\n** CAPI3REF: Determine if a virtual table query is DISTINCT\n** METHOD: sqlite3_index_info\n**\n** This API may only be used from within an [xBestIndex|xBestIndex method]\n** of a [virtual table] implementation. The result of calling this\n** interface from outside of xBestIndex() is undefined and probably harmful.\n**\n** ^The sqlite3_vtab_distinct() interface returns an integer between 0 and\n** 3.  The integer returned by sqlite3_vtab_distinct()\n** gives the virtual table additional information about how the query\n** planner wants the output to be ordered. As long as the virtual table\n** can meet the ordering requirements of the query planner, it may set\n** the \"orderByConsumed\" flag.\n**\n** <ol><li value=\"0\"><p>\n** ^If the sqlite3_vtab_distinct() interface returns 0, that means\n** that the query planner needs the virtual table to return all rows in the\n** sort order defined by the \"nOrderBy\" and \"aOrderBy\" fields of the\n** [sqlite3_index_info] object.  This is the default expectation.  If the\n** virtual table outputs all rows in sorted order, then it is always safe for\n** the xBestIndex method to set the \"orderByConsumed\" flag, regardless of\n** the return value from sqlite3_vtab_distinct().\n** <li value=\"1\"><p>\n** ^(If the sqlite3_vtab_distinct() interface returns 1, that means\n** that the query planner does not need the rows to be returned in sorted order\n** as long as all rows with the same values in all columns identified by the\n** \"aOrderBy\" field are adjacent.)^  This mode is used when the query planner\n** is doing a GROUP BY.\n** <li value=\"2\"><p>\n** ^(If the sqlite3_vtab_distinct() interface returns 2, that means\n** that the query planner does not need the rows returned in any particular\n** order, as long as rows with the same values in all columns identified\n** by \"aOrderBy\" are adjacent.)^  ^(Furthermore, when two or more rows\n** contain the same values for all columns identified by \"colUsed\", all but\n** one such row may optionally be omitted from the result.)^\n** The virtual table is not required to omit rows that are duplicates\n** over the \"colUsed\" columns, but if the virtual table can do that without\n** too much extra effort, it could potentially help the query to run faster.\n** This mode is used for a DISTINCT query.\n** <li value=\"3\"><p>\n** ^(If the sqlite3_vtab_distinct() interface returns 3, that means the\n** virtual table must return rows in the order defined by \"aOrderBy\" as\n** if the sqlite3_vtab_distinct() interface had returned 0.  However if\n** two or more rows in the result have the same values for all columns\n** identified by \"colUsed\", then all but one such row may optionally be\n** omitted.)^  Like when the return value is 2, the virtual table\n** is not required to omit rows that are duplicates over the \"colUsed\"\n** columns, but if the virtual table can do that without\n** too much extra effort, it could potentially help the query to run faster.\n** This mode is used for queries\n** that have both DISTINCT and ORDER BY clauses.\n** </ol>\n**\n** <p>The following table summarizes the conditions under which the\n** virtual table is allowed to set the \"orderByConsumed\" flag based on\n** the value returned by sqlite3_vtab_distinct().  This table is a\n** restatement of the previous four paragraphs:\n**\n** <table border=1 cellspacing=0 cellpadding=10 width=\"90%\">\n** <tr>\n** <td valign=\"top\">sqlite3_vtab_distinct() return value\n** <td valign=\"top\">Rows are returned in aOrderBy order\n** <td valign=\"top\">Rows with the same value in all aOrderBy columns are adjacent\n** <td valign=\"top\">Duplicates over all colUsed columns may be omitted\n** <tr><td>0<td>yes<td>yes<td>no\n** <tr><td>1<td>no<td>yes<td>no\n** <tr><td>2<td>no<td>yes<td>yes\n** <tr><td>3<td>yes<td>yes<td>yes\n** </table>\n**\n** ^For the purposes of comparing virtual table output values to see if the\n** values are same value for sorting purposes, two NULL values are considered\n** to be the same.  In other words, the comparison operator is \"IS\"\n** (or \"IS NOT DISTINCT FROM\") and not \"==\".\n**\n** If a virtual table implementation is unable to meet the requirements\n** specified above, then it must not set the \"orderByConsumed\" flag in the\n** [sqlite3_index_info] object or an incorrect answer may result.\n**\n** ^A virtual table implementation is always free to return rows in any order\n** it wants, as long as the \"orderByConsumed\" flag is not set.  ^When the\n** the \"orderByConsumed\" flag is unset, the query planner will add extra\n** [bytecode] to ensure that the final results returned by the SQL query are\n** ordered correctly.  The use of the \"orderByConsumed\" flag and the\n** sqlite3_vtab_distinct() interface is merely an optimization.  ^Careful\n** use of the sqlite3_vtab_distinct() interface and the \"orderByConsumed\"\n** flag might help queries against a virtual table to run faster.  Being\n** overly aggressive and setting the \"orderByConsumed\" flag when it is not\n** valid to do so, on the other hand, might cause SQLite to return incorrect\n** results.\n*/\nSQLITE_API int sqlite3_vtab_distinct(sqlite3_index_info*);\n\n/*\n** CAPI3REF: Identify and handle IN constraints in xBestIndex\n**\n** This interface may only be used from within an\n** [xBestIndex|xBestIndex() method] of a [virtual table] implementation.\n** The result of invoking this interface from any other context is\n** undefined and probably harmful.\n**\n** ^(A constraint on a virtual table of the form\n** \"[IN operator|column IN (...)]\" is\n** communicated to the xBestIndex method as a\n** [SQLITE_INDEX_CONSTRAINT_EQ] constraint.)^  If xBestIndex wants to use\n** this constraint, it must set the corresponding\n** aConstraintUsage[].argvIndex to a positive integer.  ^(Then, under\n** the usual mode of handling IN operators, SQLite generates [bytecode]\n** that invokes the [xFilter|xFilter() method] once for each value\n** on the right-hand side of the IN operator.)^  Thus the virtual table\n** only sees a single value from the right-hand side of the IN operator\n** at a time.\n**\n** In some cases, however, it would be advantageous for the virtual\n** table to see all values on the right-hand of the IN operator all at\n** once.  The sqlite3_vtab_in() interfaces facilitates this in two ways:\n**\n** <ol>\n** <li><p>\n**   ^A call to sqlite3_vtab_in(P,N,-1) will return true (non-zero)\n**   if and only if the [sqlite3_index_info|P->aConstraint][N] constraint\n**   is an [IN operator] that can be processed all at once.  ^In other words,\n**   sqlite3_vtab_in() with -1 in the third argument is a mechanism\n**   by which the virtual table can ask SQLite if all-at-once processing\n**   of the IN operator is even possible.\n**\n** <li><p>\n**   ^A call to sqlite3_vtab_in(P,N,F) with F==1 or F==0 indicates\n**   to SQLite that the virtual table does or does not want to process\n**   the IN operator all-at-once, respectively.  ^Thus when the third\n**   parameter (F) is non-negative, this interface is the mechanism by\n**   which the virtual table tells SQLite how it wants to process the\n**   IN operator.\n** </ol>\n**\n** ^The sqlite3_vtab_in(P,N,F) interface can be invoked multiple times\n** within the same xBestIndex method call.  ^For any given P,N pair,\n** the return value from sqlite3_vtab_in(P,N,F) will always be the same\n** within the same xBestIndex call.  ^If the interface returns true\n** (non-zero), that means that the constraint is an IN operator\n** that can be processed all-at-once.  ^If the constraint is not an IN\n** operator or cannot be processed all-at-once, then the interface returns\n** false.\n**\n** ^(All-at-once processing of the IN operator is selected if both of the\n** following conditions are met:\n**\n** <ol>\n** <li><p> The P->aConstraintUsage[N].argvIndex value is set to a positive\n** integer.  This is how the virtual table tells SQLite that it wants to\n** use the N-th constraint.\n**\n** <li><p> The last call to sqlite3_vtab_in(P,N,F) for which F was\n** non-negative had F>=1.\n** </ol>)^\n**\n** ^If either or both of the conditions above are false, then SQLite uses\n** the traditional one-at-a-time processing strategy for the IN constraint.\n** ^If both conditions are true, then the argvIndex-th parameter to the\n** xFilter method will be an [sqlite3_value] that appears to be NULL,\n** but which can be passed to [sqlite3_vtab_in_first()] and\n** [sqlite3_vtab_in_next()] to find all values on the right-hand side\n** of the IN constraint.\n*/\nSQLITE_API int sqlite3_vtab_in(sqlite3_index_info*, int iCons, int bHandle);\n\n/*\n** CAPI3REF: Find all elements on the right-hand side of an IN constraint.\n**\n** These interfaces are only useful from within the\n** [xFilter|xFilter() method] of a [virtual table] implementation.\n** The result of invoking these interfaces from any other context\n** is undefined and probably harmful.\n**\n** The X parameter in a call to sqlite3_vtab_in_first(X,P) or\n** sqlite3_vtab_in_next(X,P) should be one of the parameters to the\n** xFilter method which invokes these routines, and specifically\n** a parameter that was previously selected for all-at-once IN constraint\n** processing use the [sqlite3_vtab_in()] interface in the\n** [xBestIndex|xBestIndex method].  ^(If the X parameter is not\n** an xFilter argument that was selected for all-at-once IN constraint\n** processing, then these routines return [SQLITE_ERROR].)^\n**\n** ^(Use these routines to access all values on the right-hand side\n** of the IN constraint using code like the following:\n**\n** <blockquote><pre>\n** &nbsp;  for(rc=sqlite3_vtab_in_first(pList, &pVal);\n** &nbsp;      rc==SQLITE_OK && pVal;\n** &nbsp;      rc=sqlite3_vtab_in_next(pList, &pVal)\n** &nbsp;  ){\n** &nbsp;    // do something with pVal\n** &nbsp;  }\n** &nbsp;  if( rc!=SQLITE_OK ){\n** &nbsp;    // an error has occurred\n** &nbsp;  }\n** </pre></blockquote>)^\n**\n** ^On success, the sqlite3_vtab_in_first(X,P) and sqlite3_vtab_in_next(X,P)\n** routines return SQLITE_OK and set *P to point to the first or next value\n** on the RHS of the IN constraint.  ^If there are no more values on the\n** right hand side of the IN constraint, then *P is set to NULL and these\n** routines return [SQLITE_DONE].  ^The return value might be\n** some other value, such as SQLITE_NOMEM, in the event of a malfunction.\n**\n** The *ppOut values returned by these routines are only valid until the\n** next call to either of these routines or until the end of the xFilter\n** method from which these routines were called.  If the virtual table\n** implementation needs to retain the *ppOut values for longer, it must make\n** copies.  The *ppOut values are [protected sqlite3_value|protected].\n*/\nSQLITE_API int sqlite3_vtab_in_first(sqlite3_value *pVal, sqlite3_value **ppOut);\nSQLITE_API int sqlite3_vtab_in_next(sqlite3_value *pVal, sqlite3_value **ppOut);\n\n/*\n** CAPI3REF: Constraint values in xBestIndex()\n** METHOD: sqlite3_index_info\n**\n** This API may only be used from within the [xBestIndex|xBestIndex method]\n** of a [virtual table] implementation. The result of calling this interface\n** from outside of an xBestIndex method are undefined and probably harmful.\n**\n** ^When the sqlite3_vtab_rhs_value(P,J,V) interface is invoked from within\n** the [xBestIndex] method of a [virtual table] implementation, with P being\n** a copy of the [sqlite3_index_info] object pointer passed into xBestIndex and\n** J being a 0-based index into P->aConstraint[], then this routine\n** attempts to set *V to the value of the right-hand operand of\n** that constraint if the right-hand operand is known.  ^If the\n** right-hand operand is not known, then *V is set to a NULL pointer.\n** ^The sqlite3_vtab_rhs_value(P,J,V) interface returns SQLITE_OK if\n** and only if *V is set to a value.  ^The sqlite3_vtab_rhs_value(P,J,V)\n** inteface returns SQLITE_NOTFOUND if the right-hand side of the J-th\n** constraint is not available.  ^The sqlite3_vtab_rhs_value() interface\n** can return an result code other than SQLITE_OK or SQLITE_NOTFOUND if\n** something goes wrong.\n**\n** The sqlite3_vtab_rhs_value() interface is usually only successful if\n** the right-hand operand of a constraint is a literal value in the original\n** SQL statement.  If the right-hand operand is an expression or a reference\n** to some other column or a [host parameter], then sqlite3_vtab_rhs_value()\n** will probably return [SQLITE_NOTFOUND].\n**\n** ^(Some constraints, such as [SQLITE_INDEX_CONSTRAINT_ISNULL] and\n** [SQLITE_INDEX_CONSTRAINT_ISNOTNULL], have no right-hand operand.  For such\n** constraints, sqlite3_vtab_rhs_value() always returns SQLITE_NOTFOUND.)^\n**\n** ^The [sqlite3_value] object returned in *V is a protected sqlite3_value\n** and remains valid for the duration of the xBestIndex method call.\n** ^When xBestIndex returns, the sqlite3_value object returned by\n** sqlite3_vtab_rhs_value() is automatically deallocated.\n**\n** The \"_rhs_\" in the name of this routine is an abbreviation for\n** \"Right-Hand Side\".\n*/\nSQLITE_API int sqlite3_vtab_rhs_value(sqlite3_index_info*, int, sqlite3_value **ppVal);\n\n/*\n** CAPI3REF: Conflict resolution modes\n** KEYWORDS: {conflict resolution mode}\n**\n** These constants are returned by [sqlite3_vtab_on_conflict()] to\n** inform a [virtual table] implementation what the [ON CONFLICT] mode\n** is for the SQL statement being evaluated.\n**\n** Note that the [SQLITE_IGNORE] constant is also used as a potential\n** return value from the [sqlite3_set_authorizer()] callback and that\n** [SQLITE_ABORT] is also a [result code].\n*/\n#define SQLITE_ROLLBACK 1\n/* #define SQLITE_IGNORE 2 // Also used by sqlite3_authorizer() callback */\n#define SQLITE_FAIL     3\n/* #define SQLITE_ABORT 4  // Also an error code */\n#define SQLITE_REPLACE  5\n\n/*\n** CAPI3REF: Prepared Statement Scan Status Opcodes\n** KEYWORDS: {scanstatus options}\n**\n** The following constants can be used for the T parameter to the\n** [sqlite3_stmt_scanstatus(S,X,T,V)] interface.  Each constant designates a\n** different metric for sqlite3_stmt_scanstatus() to return.\n**\n** When the value returned to V is a string, space to hold that string is\n** managed by the prepared statement S and will be automatically freed when\n** S is finalized.\n**\n** Not all values are available for all query elements. When a value is\n** not available, the output variable is set to -1 if the value is numeric,\n** or to NULL if it is a string (SQLITE_SCANSTAT_NAME).\n**\n** <dl>\n** [[SQLITE_SCANSTAT_NLOOP]] <dt>SQLITE_SCANSTAT_NLOOP</dt>\n** <dd>^The [sqlite3_int64] variable pointed to by the V parameter will be\n** set to the total number of times that the X-th loop has run.</dd>\n**\n** [[SQLITE_SCANSTAT_NVISIT]] <dt>SQLITE_SCANSTAT_NVISIT</dt>\n** <dd>^The [sqlite3_int64] variable pointed to by the V parameter will be set\n** to the total number of rows examined by all iterations of the X-th loop.</dd>\n**\n** [[SQLITE_SCANSTAT_EST]] <dt>SQLITE_SCANSTAT_EST</dt>\n** <dd>^The \"double\" variable pointed to by the V parameter will be set to the\n** query planner's estimate for the average number of rows output from each\n** iteration of the X-th loop.  If the query planner's estimates was accurate,\n** then this value will approximate the quotient NVISIT/NLOOP and the\n** product of this value for all prior loops with the same SELECTID will\n** be the NLOOP value for the current loop.\n**\n** [[SQLITE_SCANSTAT_NAME]] <dt>SQLITE_SCANSTAT_NAME</dt>\n** <dd>^The \"const char *\" variable pointed to by the V parameter will be set\n** to a zero-terminated UTF-8 string containing the name of the index or table\n** used for the X-th loop.\n**\n** [[SQLITE_SCANSTAT_EXPLAIN]] <dt>SQLITE_SCANSTAT_EXPLAIN</dt>\n** <dd>^The \"const char *\" variable pointed to by the V parameter will be set\n** to a zero-terminated UTF-8 string containing the [EXPLAIN QUERY PLAN]\n** description for the X-th loop.\n**\n** [[SQLITE_SCANSTAT_SELECTID]] <dt>SQLITE_SCANSTAT_SELECTID</dt>\n** <dd>^The \"int\" variable pointed to by the V parameter will be set to the\n** id for the X-th query plan element. The id value is unique within the\n** statement. The select-id is the same value as is output in the first\n** column of an [EXPLAIN QUERY PLAN] query.\n**\n** [[SQLITE_SCANSTAT_PARENTID]] <dt>SQLITE_SCANSTAT_PARENTID</dt>\n** <dd>The \"int\" variable pointed to by the V parameter will be set to the\n** the id of the parent of the current query element, if applicable, or\n** to zero if the query element has no parent. This is the same value as\n** returned in the second column of an [EXPLAIN QUERY PLAN] query.\n**\n** [[SQLITE_SCANSTAT_NCYCLE]] <dt>SQLITE_SCANSTAT_NCYCLE</dt>\n** <dd>The sqlite3_int64 output value is set to the number of cycles,\n** according to the processor time-stamp counter, that elapsed while the\n** query element was being processed. This value is not available for\n** all query elements - if it is unavailable the output variable is\n** set to -1.\n** </dl>\n*/\n#define SQLITE_SCANSTAT_NLOOP    0\n#define SQLITE_SCANSTAT_NVISIT   1\n#define SQLITE_SCANSTAT_EST      2\n#define SQLITE_SCANSTAT_NAME     3\n#define SQLITE_SCANSTAT_EXPLAIN  4\n#define SQLITE_SCANSTAT_SELECTID 5\n#define SQLITE_SCANSTAT_PARENTID 6\n#define SQLITE_SCANSTAT_NCYCLE   7\n\n/*\n** CAPI3REF: Prepared Statement Scan Status\n** METHOD: sqlite3_stmt\n**\n** These interfaces return information about the predicted and measured\n** performance for pStmt.  Advanced applications can use this\n** interface to compare the predicted and the measured performance and\n** issue warnings and/or rerun [ANALYZE] if discrepancies are found.\n**\n** Since this interface is expected to be rarely used, it is only\n** available if SQLite is compiled using the [SQLITE_ENABLE_STMT_SCANSTATUS]\n** compile-time option.\n**\n** The \"iScanStatusOp\" parameter determines which status information to return.\n** The \"iScanStatusOp\" must be one of the [scanstatus options] or the behavior\n** of this interface is undefined. ^The requested measurement is written into\n** a variable pointed to by the \"pOut\" parameter.\n**\n** The \"flags\" parameter must be passed a mask of flags. At present only\n** one flag is defined - SQLITE_SCANSTAT_COMPLEX. If SQLITE_SCANSTAT_COMPLEX\n** is specified, then status information is available for all elements\n** of a query plan that are reported by \"EXPLAIN QUERY PLAN\" output. If\n** SQLITE_SCANSTAT_COMPLEX is not specified, then only query plan elements\n** that correspond to query loops (the \"SCAN...\" and \"SEARCH...\" elements of\n** the EXPLAIN QUERY PLAN output) are available. Invoking API\n** sqlite3_stmt_scanstatus() is equivalent to calling\n** sqlite3_stmt_scanstatus_v2() with a zeroed flags parameter.\n**\n** Parameter \"idx\" identifies the specific query element to retrieve statistics\n** for. Query elements are numbered starting from zero. A value of -1 may be\n** to query for statistics regarding the entire query. ^If idx is out of range\n** - less than -1 or greater than or equal to the total number of query\n** elements used to implement the statement - a non-zero value is returned and\n** the variable that pOut points to is unchanged.\n**\n** See also: [sqlite3_stmt_scanstatus_reset()]\n*/\nSQLITE_API int sqlite3_stmt_scanstatus(\n  sqlite3_stmt *pStmt,      /* Prepared statement for which info desired */\n  int idx,                  /* Index of loop to report on */\n  int iScanStatusOp,        /* Information desired.  SQLITE_SCANSTAT_* */\n  void *pOut                /* Result written here */\n);\nSQLITE_API int sqlite3_stmt_scanstatus_v2(\n  sqlite3_stmt *pStmt,      /* Prepared statement for which info desired */\n  int idx,                  /* Index of loop to report on */\n  int iScanStatusOp,        /* Information desired.  SQLITE_SCANSTAT_* */\n  int flags,                /* Mask of flags defined below */\n  void *pOut                /* Result written here */\n);\n\n/*\n** CAPI3REF: Prepared Statement Scan Status\n** KEYWORDS: {scan status flags}\n*/\n#define SQLITE_SCANSTAT_COMPLEX 0x0001\n\n/*\n** CAPI3REF: Zero Scan-Status Counters\n** METHOD: sqlite3_stmt\n**\n** ^Zero all [sqlite3_stmt_scanstatus()] related event counters.\n**\n** This API is only available if the library is built with pre-processor\n** symbol [SQLITE_ENABLE_STMT_SCANSTATUS] defined.\n*/\nSQLITE_API void sqlite3_stmt_scanstatus_reset(sqlite3_stmt*);\n\n/*\n** CAPI3REF: Flush caches to disk mid-transaction\n** METHOD: sqlite3\n**\n** ^If a write-transaction is open on [database connection] D when the\n** [sqlite3_db_cacheflush(D)] interface invoked, any dirty\n** pages in the pager-cache that are not currently in use are written out\n** to disk. A dirty page may be in use if a database cursor created by an\n** active SQL statement is reading from it, or if it is page 1 of a database\n** file (page 1 is always \"in use\").  ^The [sqlite3_db_cacheflush(D)]\n** interface flushes caches for all schemas - \"main\", \"temp\", and\n** any [attached] databases.\n**\n** ^If this function needs to obtain extra database locks before dirty pages\n** can be flushed to disk, it does so. ^If those locks cannot be obtained\n** immediately and there is a busy-handler callback configured, it is invoked\n** in the usual manner. ^If the required lock still cannot be obtained, then\n** the database is skipped and an attempt made to flush any dirty pages\n** belonging to the next (if any) database. ^If any databases are skipped\n** because locks cannot be obtained, but no other error occurs, this\n** function returns SQLITE_BUSY.\n**\n** ^If any other error occurs while flushing dirty pages to disk (for\n** example an IO error or out-of-memory condition), then processing is\n** abandoned and an SQLite [error code] is returned to the caller immediately.\n**\n** ^Otherwise, if no error occurs, [sqlite3_db_cacheflush()] returns SQLITE_OK.\n**\n** ^This function does not set the database handle error code or message\n** returned by the [sqlite3_errcode()] and [sqlite3_errmsg()] functions.\n*/\nSQLITE_API int sqlite3_db_cacheflush(sqlite3*);\n\n/*\n** CAPI3REF: The pre-update hook.\n** METHOD: sqlite3\n**\n** ^These interfaces are only available if SQLite is compiled using the\n** [SQLITE_ENABLE_PREUPDATE_HOOK] compile-time option.\n**\n** ^The [sqlite3_preupdate_hook()] interface registers a callback function\n** that is invoked prior to each [INSERT], [UPDATE], and [DELETE] operation\n** on a database table.\n** ^At most one preupdate hook may be registered at a time on a single\n** [database connection]; each call to [sqlite3_preupdate_hook()] overrides\n** the previous setting.\n** ^The preupdate hook is disabled by invoking [sqlite3_preupdate_hook()]\n** with a NULL pointer as the second parameter.\n** ^The third parameter to [sqlite3_preupdate_hook()] is passed through as\n** the first parameter to callbacks.\n**\n** ^The preupdate hook only fires for changes to real database tables; the\n** preupdate hook is not invoked for changes to [virtual tables] or to\n** system tables like sqlite_sequence or sqlite_stat1.\n**\n** ^The second parameter to the preupdate callback is a pointer to\n** the [database connection] that registered the preupdate hook.\n** ^The third parameter to the preupdate callback is one of the constants\n** [SQLITE_INSERT], [SQLITE_DELETE], or [SQLITE_UPDATE] to identify the\n** kind of update operation that is about to occur.\n** ^(The fourth parameter to the preupdate callback is the name of the\n** database within the database connection that is being modified.  This\n** will be \"main\" for the main database or \"temp\" for TEMP tables or\n** the name given after the AS keyword in the [ATTACH] statement for attached\n** databases.)^\n** ^The fifth parameter to the preupdate callback is the name of the\n** table that is being modified.\n**\n** For an UPDATE or DELETE operation on a [rowid table], the sixth\n** parameter passed to the preupdate callback is the initial [rowid] of the\n** row being modified or deleted. For an INSERT operation on a rowid table,\n** or any operation on a WITHOUT ROWID table, the value of the sixth\n** parameter is undefined. For an INSERT or UPDATE on a rowid table the\n** seventh parameter is the final rowid value of the row being inserted\n** or updated. The value of the seventh parameter passed to the callback\n** function is not defined for operations on WITHOUT ROWID tables, or for\n** DELETE operations on rowid tables.\n**\n** ^The sqlite3_preupdate_hook(D,C,P) function returns the P argument from\n** the previous call on the same [database connection] D, or NULL for\n** the first call on D.\n**\n** The [sqlite3_preupdate_old()], [sqlite3_preupdate_new()],\n** [sqlite3_preupdate_count()], and [sqlite3_preupdate_depth()] interfaces\n** provide additional information about a preupdate event. These routines\n** may only be called from within a preupdate callback.  Invoking any of\n** these routines from outside of a preupdate callback or with a\n** [database connection] pointer that is different from the one supplied\n** to the preupdate callback results in undefined and probably undesirable\n** behavior.\n**\n** ^The [sqlite3_preupdate_count(D)] interface returns the number of columns\n** in the row that is being inserted, updated, or deleted.\n**\n** ^The [sqlite3_preupdate_old(D,N,P)] interface writes into P a pointer to\n** a [protected sqlite3_value] that contains the value of the Nth column of\n** the table row before it is updated.  The N parameter must be between 0\n** and one less than the number of columns or the behavior will be\n** undefined. This must only be used within SQLITE_UPDATE and SQLITE_DELETE\n** preupdate callbacks; if it is used by an SQLITE_INSERT callback then the\n** behavior is undefined.  The [sqlite3_value] that P points to\n** will be destroyed when the preupdate callback returns.\n**\n** ^The [sqlite3_preupdate_new(D,N,P)] interface writes into P a pointer to\n** a [protected sqlite3_value] that contains the value of the Nth column of\n** the table row after it is updated.  The N parameter must be between 0\n** and one less than the number of columns or the behavior will be\n** undefined. This must only be used within SQLITE_INSERT and SQLITE_UPDATE\n** preupdate callbacks; if it is used by an SQLITE_DELETE callback then the\n** behavior is undefined.  The [sqlite3_value] that P points to\n** will be destroyed when the preupdate callback returns.\n**\n** ^The [sqlite3_preupdate_depth(D)] interface returns 0 if the preupdate\n** callback was invoked as a result of a direct insert, update, or delete\n** operation; or 1 for inserts, updates, or deletes invoked by top-level\n** triggers; or 2 for changes resulting from triggers called by top-level\n** triggers; and so forth.\n**\n** When the [sqlite3_blob_write()] API is used to update a blob column,\n** the pre-update hook is invoked with SQLITE_DELETE. This is because the\n*"
        },
        {
          "name": "sqlite3.go",
          "type": "blob",
          "size": 65.5576171875,
          "content": "// Copyright (C) 2019 Yasuhiro Matsumoto <mattn.jp@gmail.com>.\n// Copyright (C) 2018 G.J.R. Timmer <gjr.timmer@gmail.com>.\n//\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n//go:build cgo\n// +build cgo\n\npackage sqlite3\n\n/*\n#cgo CFLAGS: -std=gnu99\n#cgo CFLAGS: -DSQLITE_ENABLE_RTREE\n#cgo CFLAGS: -DSQLITE_THREADSAFE=1\n#cgo CFLAGS: -DHAVE_USLEEP=1\n#cgo CFLAGS: -DSQLITE_ENABLE_FTS3\n#cgo CFLAGS: -DSQLITE_ENABLE_FTS3_PARENTHESIS\n#cgo CFLAGS: -DSQLITE_TRACE_SIZE_LIMIT=15\n#cgo CFLAGS: -DSQLITE_OMIT_DEPRECATED\n#cgo CFLAGS: -DSQLITE_DEFAULT_WAL_SYNCHRONOUS=1\n#cgo CFLAGS: -DSQLITE_ENABLE_UPDATE_DELETE_LIMIT\n#cgo CFLAGS: -Wno-deprecated-declarations\n#cgo openbsd CFLAGS: -I/usr/local/include\n#cgo openbsd LDFLAGS: -L/usr/local/lib\n#ifndef USE_LIBSQLITE3\n#include \"sqlite3-binding.h\"\n#else\n#include <sqlite3.h>\n#endif\n#include <stdlib.h>\n#include <string.h>\n\n#ifdef __CYGWIN__\n# include <errno.h>\n#endif\n\n#ifndef SQLITE_OPEN_READWRITE\n# define SQLITE_OPEN_READWRITE 0\n#endif\n\n#ifndef SQLITE_OPEN_FULLMUTEX\n# define SQLITE_OPEN_FULLMUTEX 0\n#endif\n\n#ifndef SQLITE_DETERMINISTIC\n# define SQLITE_DETERMINISTIC 0\n#endif\n\n#if defined(HAVE_PREAD64) && defined(HAVE_PWRITE64)\n# undef USE_PREAD\n# undef USE_PWRITE\n# define USE_PREAD64 1\n# define USE_PWRITE64 1\n#elif defined(HAVE_PREAD) && defined(HAVE_PWRITE)\n# undef USE_PREAD\n# undef USE_PWRITE\n# define USE_PREAD64 1\n# define USE_PWRITE64 1\n#endif\n\nstatic int\n_sqlite3_open_v2(const char *filename, sqlite3 **ppDb, int flags, const char *zVfs) {\n#ifdef SQLITE_OPEN_URI\n  return sqlite3_open_v2(filename, ppDb, flags | SQLITE_OPEN_URI, zVfs);\n#else\n  return sqlite3_open_v2(filename, ppDb, flags, zVfs);\n#endif\n}\n\nstatic int\n_sqlite3_bind_text(sqlite3_stmt *stmt, int n, char *p, int np) {\n  return sqlite3_bind_text(stmt, n, p, np, SQLITE_TRANSIENT);\n}\n\nstatic int\n_sqlite3_bind_blob(sqlite3_stmt *stmt, int n, void *p, int np) {\n  return sqlite3_bind_blob(stmt, n, p, np, SQLITE_TRANSIENT);\n}\n\n#include <stdio.h>\n#include <stdint.h>\n\nstatic int\n_sqlite3_exec(sqlite3* db, const char* pcmd, long long* rowid, long long* changes)\n{\n  int rv = sqlite3_exec(db, pcmd, 0, 0, 0);\n  *rowid = (long long) sqlite3_last_insert_rowid(db);\n  *changes = (long long) sqlite3_changes(db);\n  return rv;\n}\n\n#ifdef SQLITE_ENABLE_UNLOCK_NOTIFY\nextern int _sqlite3_step_blocking(sqlite3_stmt *stmt);\nextern int _sqlite3_step_row_blocking(sqlite3_stmt* stmt, long long* rowid, long long* changes);\nextern int _sqlite3_prepare_v2_blocking(sqlite3 *db, const char *zSql, int nBytes, sqlite3_stmt **ppStmt, const char **pzTail);\n\nstatic int\n_sqlite3_step_internal(sqlite3_stmt *stmt)\n{\n  return _sqlite3_step_blocking(stmt);\n}\n\nstatic int\n_sqlite3_step_row_internal(sqlite3_stmt* stmt, long long* rowid, long long* changes)\n{\n  return _sqlite3_step_row_blocking(stmt, rowid, changes);\n}\n\nstatic int\n_sqlite3_prepare_v2_internal(sqlite3 *db, const char *zSql, int nBytes, sqlite3_stmt **ppStmt, const char **pzTail)\n{\n  return _sqlite3_prepare_v2_blocking(db, zSql, nBytes, ppStmt, pzTail);\n}\n\n#else\nstatic int\n_sqlite3_step_internal(sqlite3_stmt *stmt)\n{\n  return sqlite3_step(stmt);\n}\n\nstatic int\n_sqlite3_step_row_internal(sqlite3_stmt* stmt, long long* rowid, long long* changes)\n{\n  int rv = sqlite3_step(stmt);\n  sqlite3* db = sqlite3_db_handle(stmt);\n  *rowid = (long long) sqlite3_last_insert_rowid(db);\n  *changes = (long long) sqlite3_changes(db);\n  return rv;\n}\n\nstatic int\n_sqlite3_prepare_v2_internal(sqlite3 *db, const char *zSql, int nBytes, sqlite3_stmt **ppStmt, const char **pzTail)\n{\n  return sqlite3_prepare_v2(db, zSql, nBytes, ppStmt, pzTail);\n}\n#endif\n\nvoid _sqlite3_result_text(sqlite3_context* ctx, const char* s) {\n  sqlite3_result_text(ctx, s, -1, &free);\n}\n\nvoid _sqlite3_result_blob(sqlite3_context* ctx, const void* b, int l) {\n  sqlite3_result_blob(ctx, b, l, SQLITE_TRANSIENT);\n}\n\n\nint _sqlite3_create_function(\n  sqlite3 *db,\n  const char *zFunctionName,\n  int nArg,\n  int eTextRep,\n  uintptr_t pApp,\n  void (*xFunc)(sqlite3_context*,int,sqlite3_value**),\n  void (*xStep)(sqlite3_context*,int,sqlite3_value**),\n  void (*xFinal)(sqlite3_context*)\n) {\n  return sqlite3_create_function(db, zFunctionName, nArg, eTextRep, (void*) pApp, xFunc, xStep, xFinal);\n}\n\nvoid callbackTrampoline(sqlite3_context*, int, sqlite3_value**);\nvoid stepTrampoline(sqlite3_context*, int, sqlite3_value**);\nvoid doneTrampoline(sqlite3_context*);\n\nint compareTrampoline(void*, int, char*, int, char*);\nint commitHookTrampoline(void*);\nvoid rollbackHookTrampoline(void*);\nvoid updateHookTrampoline(void*, int, char*, char*, sqlite3_int64);\n\nint authorizerTrampoline(void*, int, char*, char*, char*, char*);\n\n#ifdef SQLITE_LIMIT_WORKER_THREADS\n# define _SQLITE_HAS_LIMIT\n# define SQLITE_LIMIT_LENGTH                    0\n# define SQLITE_LIMIT_SQL_LENGTH                1\n# define SQLITE_LIMIT_COLUMN                    2\n# define SQLITE_LIMIT_EXPR_DEPTH                3\n# define SQLITE_LIMIT_COMPOUND_SELECT           4\n# define SQLITE_LIMIT_VDBE_OP                   5\n# define SQLITE_LIMIT_FUNCTION_ARG              6\n# define SQLITE_LIMIT_ATTACHED                  7\n# define SQLITE_LIMIT_LIKE_PATTERN_LENGTH       8\n# define SQLITE_LIMIT_VARIABLE_NUMBER           9\n# define SQLITE_LIMIT_TRIGGER_DEPTH            10\n# define SQLITE_LIMIT_WORKER_THREADS           11\n# else\n# define SQLITE_LIMIT_WORKER_THREADS           11\n#endif\n\nstatic int _sqlite3_limit(sqlite3* db, int limitId, int newLimit) {\n#ifndef _SQLITE_HAS_LIMIT\n  return -1;\n#else\n  return sqlite3_limit(db, limitId, newLimit);\n#endif\n}\n\n#if SQLITE_VERSION_NUMBER < 3012000\nstatic int sqlite3_system_errno(sqlite3 *db) {\n  return 0;\n}\n#endif\n*/\nimport \"C\"\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"database/sql/driver\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/url\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"syscall\"\n\t\"time\"\n\t\"unsafe\"\n)\n\n// SQLiteTimestampFormats is timestamp formats understood by both this module\n// and SQLite.  The first format in the slice will be used when saving time\n// values into the database. When parsing a string from a timestamp or datetime\n// column, the formats are tried in order.\nvar SQLiteTimestampFormats = []string{\n\t// By default, store timestamps with whatever timezone they come with.\n\t// When parsed, they will be returned with the same timezone.\n\t\"2006-01-02 15:04:05.999999999-07:00\",\n\t\"2006-01-02T15:04:05.999999999-07:00\",\n\t\"2006-01-02 15:04:05.999999999\",\n\t\"2006-01-02T15:04:05.999999999\",\n\t\"2006-01-02 15:04:05\",\n\t\"2006-01-02T15:04:05\",\n\t\"2006-01-02 15:04\",\n\t\"2006-01-02T15:04\",\n\t\"2006-01-02\",\n}\n\nconst (\n\tcolumnDate      string = \"date\"\n\tcolumnDatetime  string = \"datetime\"\n\tcolumnTimestamp string = \"timestamp\"\n)\n\n// This variable can be replaced with -ldflags like below:\n// go build -ldflags=\"-X 'github.com/mattn/go-sqlite3.driverName=my-sqlite3'\"\nvar driverName = \"sqlite3\"\n\nfunc init() {\n\tif driverName != \"\" {\n\t\tsql.Register(driverName, &SQLiteDriver{})\n\t}\n}\n\n// Version returns SQLite library version information.\nfunc Version() (libVersion string, libVersionNumber int, sourceID string) {\n\tlibVersion = C.GoString(C.sqlite3_libversion())\n\tlibVersionNumber = int(C.sqlite3_libversion_number())\n\tsourceID = C.GoString(C.sqlite3_sourceid())\n\treturn libVersion, libVersionNumber, sourceID\n}\n\nconst (\n\t// used by authorizer and pre_update_hook\n\tSQLITE_DELETE = C.SQLITE_DELETE\n\tSQLITE_INSERT = C.SQLITE_INSERT\n\tSQLITE_UPDATE = C.SQLITE_UPDATE\n\n\t// used by authorzier - as return value\n\tSQLITE_OK     = C.SQLITE_OK\n\tSQLITE_IGNORE = C.SQLITE_IGNORE\n\tSQLITE_DENY   = C.SQLITE_DENY\n\n\t// different actions query tries to do - passed as argument to authorizer\n\tSQLITE_CREATE_INDEX        = C.SQLITE_CREATE_INDEX\n\tSQLITE_CREATE_TABLE        = C.SQLITE_CREATE_TABLE\n\tSQLITE_CREATE_TEMP_INDEX   = C.SQLITE_CREATE_TEMP_INDEX\n\tSQLITE_CREATE_TEMP_TABLE   = C.SQLITE_CREATE_TEMP_TABLE\n\tSQLITE_CREATE_TEMP_TRIGGER = C.SQLITE_CREATE_TEMP_TRIGGER\n\tSQLITE_CREATE_TEMP_VIEW    = C.SQLITE_CREATE_TEMP_VIEW\n\tSQLITE_CREATE_TRIGGER      = C.SQLITE_CREATE_TRIGGER\n\tSQLITE_CREATE_VIEW         = C.SQLITE_CREATE_VIEW\n\tSQLITE_CREATE_VTABLE       = C.SQLITE_CREATE_VTABLE\n\tSQLITE_DROP_INDEX          = C.SQLITE_DROP_INDEX\n\tSQLITE_DROP_TABLE          = C.SQLITE_DROP_TABLE\n\tSQLITE_DROP_TEMP_INDEX     = C.SQLITE_DROP_TEMP_INDEX\n\tSQLITE_DROP_TEMP_TABLE     = C.SQLITE_DROP_TEMP_TABLE\n\tSQLITE_DROP_TEMP_TRIGGER   = C.SQLITE_DROP_TEMP_TRIGGER\n\tSQLITE_DROP_TEMP_VIEW      = C.SQLITE_DROP_TEMP_VIEW\n\tSQLITE_DROP_TRIGGER        = C.SQLITE_DROP_TRIGGER\n\tSQLITE_DROP_VIEW           = C.SQLITE_DROP_VIEW\n\tSQLITE_DROP_VTABLE         = C.SQLITE_DROP_VTABLE\n\tSQLITE_PRAGMA              = C.SQLITE_PRAGMA\n\tSQLITE_READ                = C.SQLITE_READ\n\tSQLITE_SELECT              = C.SQLITE_SELECT\n\tSQLITE_TRANSACTION         = C.SQLITE_TRANSACTION\n\tSQLITE_ATTACH              = C.SQLITE_ATTACH\n\tSQLITE_DETACH              = C.SQLITE_DETACH\n\tSQLITE_ALTER_TABLE         = C.SQLITE_ALTER_TABLE\n\tSQLITE_REINDEX             = C.SQLITE_REINDEX\n\tSQLITE_ANALYZE             = C.SQLITE_ANALYZE\n\tSQLITE_FUNCTION            = C.SQLITE_FUNCTION\n\tSQLITE_SAVEPOINT           = C.SQLITE_SAVEPOINT\n\tSQLITE_COPY                = C.SQLITE_COPY\n\t/*SQLITE_RECURSIVE           = C.SQLITE_RECURSIVE*/\n)\n\n// Standard File Control Opcodes\n// See: https://www.sqlite.org/c3ref/c_fcntl_begin_atomic_write.html\nconst (\n\tSQLITE_FCNTL_LOCKSTATE             = int(1)\n\tSQLITE_FCNTL_GET_LOCKPROXYFILE     = int(2)\n\tSQLITE_FCNTL_SET_LOCKPROXYFILE     = int(3)\n\tSQLITE_FCNTL_LAST_ERRNO            = int(4)\n\tSQLITE_FCNTL_SIZE_HINT             = int(5)\n\tSQLITE_FCNTL_CHUNK_SIZE            = int(6)\n\tSQLITE_FCNTL_FILE_POINTER          = int(7)\n\tSQLITE_FCNTL_SYNC_OMITTED          = int(8)\n\tSQLITE_FCNTL_WIN32_AV_RETRY        = int(9)\n\tSQLITE_FCNTL_PERSIST_WAL           = int(10)\n\tSQLITE_FCNTL_OVERWRITE             = int(11)\n\tSQLITE_FCNTL_VFSNAME               = int(12)\n\tSQLITE_FCNTL_POWERSAFE_OVERWRITE   = int(13)\n\tSQLITE_FCNTL_PRAGMA                = int(14)\n\tSQLITE_FCNTL_BUSYHANDLER           = int(15)\n\tSQLITE_FCNTL_TEMPFILENAME          = int(16)\n\tSQLITE_FCNTL_MMAP_SIZE             = int(18)\n\tSQLITE_FCNTL_TRACE                 = int(19)\n\tSQLITE_FCNTL_HAS_MOVED             = int(20)\n\tSQLITE_FCNTL_SYNC                  = int(21)\n\tSQLITE_FCNTL_COMMIT_PHASETWO       = int(22)\n\tSQLITE_FCNTL_WIN32_SET_HANDLE      = int(23)\n\tSQLITE_FCNTL_WAL_BLOCK             = int(24)\n\tSQLITE_FCNTL_ZIPVFS                = int(25)\n\tSQLITE_FCNTL_RBU                   = int(26)\n\tSQLITE_FCNTL_VFS_POINTER           = int(27)\n\tSQLITE_FCNTL_JOURNAL_POINTER       = int(28)\n\tSQLITE_FCNTL_WIN32_GET_HANDLE      = int(29)\n\tSQLITE_FCNTL_PDB                   = int(30)\n\tSQLITE_FCNTL_BEGIN_ATOMIC_WRITE    = int(31)\n\tSQLITE_FCNTL_COMMIT_ATOMIC_WRITE   = int(32)\n\tSQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE = int(33)\n\tSQLITE_FCNTL_LOCK_TIMEOUT          = int(34)\n\tSQLITE_FCNTL_DATA_VERSION          = int(35)\n\tSQLITE_FCNTL_SIZE_LIMIT            = int(36)\n\tSQLITE_FCNTL_CKPT_DONE             = int(37)\n\tSQLITE_FCNTL_RESERVE_BYTES         = int(38)\n\tSQLITE_FCNTL_CKPT_START            = int(39)\n\tSQLITE_FCNTL_EXTERNAL_READER       = int(40)\n\tSQLITE_FCNTL_CKSM_FILE             = int(41)\n)\n\n// SQLiteDriver implements driver.Driver.\ntype SQLiteDriver struct {\n\tExtensions  []string\n\tConnectHook func(*SQLiteConn) error\n}\n\n// SQLiteConn implements driver.Conn.\ntype SQLiteConn struct {\n\tmu          sync.Mutex\n\tdb          *C.sqlite3\n\tloc         *time.Location\n\ttxlock      string\n\tfuncs       []*functionInfo\n\taggregators []*aggInfo\n}\n\n// SQLiteTx implements driver.Tx.\ntype SQLiteTx struct {\n\tc *SQLiteConn\n}\n\n// SQLiteStmt implements driver.Stmt.\ntype SQLiteStmt struct {\n\tmu     sync.Mutex\n\tc      *SQLiteConn\n\ts      *C.sqlite3_stmt\n\tt      string\n\tclosed bool\n\tcls    bool // True if the statement was created by SQLiteConn.Query\n}\n\n// SQLiteResult implements sql.Result.\ntype SQLiteResult struct {\n\tid      int64\n\tchanges int64\n}\n\n// SQLiteRows implements driver.Rows.\ntype SQLiteRows struct {\n\ts        *SQLiteStmt\n\tnc       int32 // Number of columns\n\tcls      bool  // True if we need to close the parent statement in Close\n\tcols     []string\n\tdecltype []string\n\tctx      context.Context // no better alternative to pass context into Next() method\n\tclosemu  sync.Mutex\n}\n\ntype functionInfo struct {\n\tf                 reflect.Value\n\targConverters     []callbackArgConverter\n\tvariadicConverter callbackArgConverter\n\tretConverter      callbackRetConverter\n}\n\nfunc (fi *functionInfo) Call(ctx *C.sqlite3_context, argv []*C.sqlite3_value) {\n\targs, err := callbackConvertArgs(argv, fi.argConverters, fi.variadicConverter)\n\tif err != nil {\n\t\tcallbackError(ctx, err)\n\t\treturn\n\t}\n\n\tret := fi.f.Call(args)\n\n\tif len(ret) == 2 && ret[1].Interface() != nil {\n\t\tcallbackError(ctx, ret[1].Interface().(error))\n\t\treturn\n\t}\n\n\terr = fi.retConverter(ctx, ret[0])\n\tif err != nil {\n\t\tcallbackError(ctx, err)\n\t\treturn\n\t}\n}\n\ntype aggInfo struct {\n\tconstructor reflect.Value\n\n\t// Active aggregator objects for aggregations in flight. The\n\t// aggregators are indexed by a counter stored in the aggregation\n\t// user data space provided by sqlite.\n\tactive map[int64]reflect.Value\n\tnext   int64\n\n\tstepArgConverters     []callbackArgConverter\n\tstepVariadicConverter callbackArgConverter\n\n\tdoneRetConverter callbackRetConverter\n}\n\nfunc (ai *aggInfo) agg(ctx *C.sqlite3_context) (int64, reflect.Value, error) {\n\taggIdx := (*int64)(C.sqlite3_aggregate_context(ctx, C.int(8)))\n\tif *aggIdx == 0 {\n\t\t*aggIdx = ai.next\n\t\tret := ai.constructor.Call(nil)\n\t\tif len(ret) == 2 && ret[1].Interface() != nil {\n\t\t\treturn 0, reflect.Value{}, ret[1].Interface().(error)\n\t\t}\n\t\tif ret[0].IsNil() {\n\t\t\treturn 0, reflect.Value{}, errors.New(\"aggregator constructor returned nil state\")\n\t\t}\n\t\tai.next++\n\t\tai.active[*aggIdx] = ret[0]\n\t}\n\treturn *aggIdx, ai.active[*aggIdx], nil\n}\n\nfunc (ai *aggInfo) Step(ctx *C.sqlite3_context, argv []*C.sqlite3_value) {\n\t_, agg, err := ai.agg(ctx)\n\tif err != nil {\n\t\tcallbackError(ctx, err)\n\t\treturn\n\t}\n\n\targs, err := callbackConvertArgs(argv, ai.stepArgConverters, ai.stepVariadicConverter)\n\tif err != nil {\n\t\tcallbackError(ctx, err)\n\t\treturn\n\t}\n\n\tret := agg.MethodByName(\"Step\").Call(args)\n\tif len(ret) == 1 && ret[0].Interface() != nil {\n\t\tcallbackError(ctx, ret[0].Interface().(error))\n\t\treturn\n\t}\n}\n\nfunc (ai *aggInfo) Done(ctx *C.sqlite3_context) {\n\tidx, agg, err := ai.agg(ctx)\n\tif err != nil {\n\t\tcallbackError(ctx, err)\n\t\treturn\n\t}\n\tdefer func() { delete(ai.active, idx) }()\n\n\tret := agg.MethodByName(\"Done\").Call(nil)\n\tif len(ret) == 2 && ret[1].Interface() != nil {\n\t\tcallbackError(ctx, ret[1].Interface().(error))\n\t\treturn\n\t}\n\n\terr = ai.doneRetConverter(ctx, ret[0])\n\tif err != nil {\n\t\tcallbackError(ctx, err)\n\t\treturn\n\t}\n}\n\n// Commit transaction.\nfunc (tx *SQLiteTx) Commit() error {\n\t_, err := tx.c.exec(context.Background(), \"COMMIT\", nil)\n\tif err != nil {\n\t\t// sqlite3 may leave the transaction open in this scenario.\n\t\t// However, database/sql considers the transaction complete once we\n\t\t// return from Commit() - we must clean up to honour its semantics.\n\t\t// We don't know if the ROLLBACK is strictly necessary, but according\n\t\t// to sqlite's docs, there is no harm in calling ROLLBACK unnecessarily.\n\t\ttx.c.exec(context.Background(), \"ROLLBACK\", nil)\n\t}\n\treturn err\n}\n\n// Rollback transaction.\nfunc (tx *SQLiteTx) Rollback() error {\n\t_, err := tx.c.exec(context.Background(), \"ROLLBACK\", nil)\n\treturn err\n}\n\n// RegisterCollation makes a Go function available as a collation.\n//\n// cmp receives two UTF-8 strings, a and b. The result should be 0 if\n// a==b, -1 if a < b, and +1 if a > b.\n//\n// cmp must always return the same result given the same\n// inputs. Additionally, it must have the following properties for all\n// strings A, B and C: if A==B then B==A; if A==B and B==C then A==C;\n// if A<B then B>A; if A<B and B<C then A<C.\n//\n// If cmp does not obey these constraints, sqlite3's behavior is\n// undefined when the collation is used.\nfunc (c *SQLiteConn) RegisterCollation(name string, cmp func(string, string) int) error {\n\thandle := newHandle(c, cmp)\n\tcname := C.CString(name)\n\tdefer C.free(unsafe.Pointer(cname))\n\trv := C.sqlite3_create_collation(c.db, cname, C.SQLITE_UTF8, handle, (*[0]byte)(unsafe.Pointer(C.compareTrampoline)))\n\tif rv != C.SQLITE_OK {\n\t\treturn c.lastError()\n\t}\n\treturn nil\n}\n\n// RegisterCommitHook sets the commit hook for a connection.\n//\n// If the callback returns non-zero the transaction will become a rollback.\n//\n// If there is an existing commit hook for this connection, it will be\n// removed. If callback is nil the existing hook (if any) will be removed\n// without creating a new one.\nfunc (c *SQLiteConn) RegisterCommitHook(callback func() int) {\n\tif callback == nil {\n\t\tC.sqlite3_commit_hook(c.db, nil, nil)\n\t} else {\n\t\tC.sqlite3_commit_hook(c.db, (*[0]byte)(C.commitHookTrampoline), newHandle(c, callback))\n\t}\n}\n\n// RegisterRollbackHook sets the rollback hook for a connection.\n//\n// If there is an existing rollback hook for this connection, it will be\n// removed. If callback is nil the existing hook (if any) will be removed\n// without creating a new one.\nfunc (c *SQLiteConn) RegisterRollbackHook(callback func()) {\n\tif callback == nil {\n\t\tC.sqlite3_rollback_hook(c.db, nil, nil)\n\t} else {\n\t\tC.sqlite3_rollback_hook(c.db, (*[0]byte)(C.rollbackHookTrampoline), newHandle(c, callback))\n\t}\n}\n\n// RegisterUpdateHook sets the update hook for a connection.\n//\n// The parameters to the callback are the operation (one of the constants\n// SQLITE_INSERT, SQLITE_DELETE, or SQLITE_UPDATE), the database name, the\n// table name, and the rowid.\n//\n// If there is an existing update hook for this connection, it will be\n// removed. If callback is nil the existing hook (if any) will be removed\n// without creating a new one.\nfunc (c *SQLiteConn) RegisterUpdateHook(callback func(int, string, string, int64)) {\n\tif callback == nil {\n\t\tC.sqlite3_update_hook(c.db, nil, nil)\n\t} else {\n\t\tC.sqlite3_update_hook(c.db, (*[0]byte)(C.updateHookTrampoline), newHandle(c, callback))\n\t}\n}\n\n// RegisterAuthorizer sets the authorizer for connection.\n//\n// The parameters to the callback are the operation (one of the constants\n// SQLITE_INSERT, SQLITE_DELETE, or SQLITE_UPDATE), and 1 to 3 arguments,\n// depending on operation. More details see:\n// https://www.sqlite.org/c3ref/c_alter_table.html\nfunc (c *SQLiteConn) RegisterAuthorizer(callback func(int, string, string, string) int) {\n\tif callback == nil {\n\t\tC.sqlite3_set_authorizer(c.db, nil, nil)\n\t} else {\n\t\tC.sqlite3_set_authorizer(c.db, (*[0]byte)(C.authorizerTrampoline), newHandle(c, callback))\n\t}\n}\n\n// RegisterFunc makes a Go function available as a SQLite function.\n//\n// The Go function can have arguments of the following types: any\n// numeric type except complex, bool, []byte, string and any.\n// any arguments are given the direct translation of the SQLite data type:\n// int64 for INTEGER, float64 for FLOAT, []byte for BLOB, string for TEXT.\n//\n// The function can additionally be variadic, as long as the type of\n// the variadic argument is one of the above.\n//\n// If pure is true. SQLite will assume that the function's return\n// value depends only on its inputs, and make more aggressive\n// optimizations in its queries.\n//\n// See _example/go_custom_funcs for a detailed example.\nfunc (c *SQLiteConn) RegisterFunc(name string, impl any, pure bool) error {\n\tvar fi functionInfo\n\tfi.f = reflect.ValueOf(impl)\n\tt := fi.f.Type()\n\tif t.Kind() != reflect.Func {\n\t\treturn errors.New(\"Non-function passed to RegisterFunc\")\n\t}\n\tif t.NumOut() != 1 && t.NumOut() != 2 {\n\t\treturn errors.New(\"SQLite functions must return 1 or 2 values\")\n\t}\n\tif t.NumOut() == 2 && !t.Out(1).Implements(reflect.TypeOf((*error)(nil)).Elem()) {\n\t\treturn errors.New(\"Second return value of SQLite function must be error\")\n\t}\n\n\tnumArgs := t.NumIn()\n\tif t.IsVariadic() {\n\t\tnumArgs--\n\t}\n\n\tfor i := 0; i < numArgs; i++ {\n\t\tconv, err := callbackArg(t.In(i))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfi.argConverters = append(fi.argConverters, conv)\n\t}\n\n\tif t.IsVariadic() {\n\t\tconv, err := callbackArg(t.In(numArgs).Elem())\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfi.variadicConverter = conv\n\t\t// Pass -1 to sqlite so that it allows any number of\n\t\t// arguments. The call helper verifies that the minimum number\n\t\t// of arguments is present for variadic functions.\n\t\tnumArgs = -1\n\t}\n\n\tconv, err := callbackRet(t.Out(0))\n\tif err != nil {\n\t\treturn err\n\t}\n\tfi.retConverter = conv\n\n\t// fi must outlast the database connection, or we'll have dangling pointers.\n\tc.funcs = append(c.funcs, &fi)\n\n\tcname := C.CString(name)\n\tdefer C.free(unsafe.Pointer(cname))\n\topts := C.SQLITE_UTF8\n\tif pure {\n\t\topts |= C.SQLITE_DETERMINISTIC\n\t}\n\trv := sqlite3CreateFunction(c.db, cname, C.int(numArgs), C.int(opts), newHandle(c, &fi), C.callbackTrampoline, nil, nil)\n\tif rv != C.SQLITE_OK {\n\t\treturn c.lastError()\n\t}\n\treturn nil\n}\n\nfunc sqlite3CreateFunction(db *C.sqlite3, zFunctionName *C.char, nArg C.int, eTextRep C.int, pApp unsafe.Pointer, xFunc unsafe.Pointer, xStep unsafe.Pointer, xFinal unsafe.Pointer) C.int {\n\treturn C._sqlite3_create_function(db, zFunctionName, nArg, eTextRep, C.uintptr_t(uintptr(pApp)), (*[0]byte)(xFunc), (*[0]byte)(xStep), (*[0]byte)(xFinal))\n}\n\n// RegisterAggregator makes a Go type available as a SQLite aggregation function.\n//\n// Because aggregation is incremental, it's implemented in Go with a\n// type that has 2 methods: func Step(values) accumulates one row of\n// data into the accumulator, and func Done() ret finalizes and\n// returns the aggregate value. \"values\" and \"ret\" may be any type\n// supported by RegisterFunc.\n//\n// RegisterAggregator takes as implementation a constructor function\n// that constructs an instance of the aggregator type each time an\n// aggregation begins. The constructor must return a pointer to a\n// type, or an interface that implements Step() and Done().\n//\n// The constructor function and the Step/Done methods may optionally\n// return an error in addition to their other return values.\n//\n// See _example/go_custom_funcs for a detailed example.\nfunc (c *SQLiteConn) RegisterAggregator(name string, impl any, pure bool) error {\n\tvar ai aggInfo\n\tai.constructor = reflect.ValueOf(impl)\n\tt := ai.constructor.Type()\n\tif t.Kind() != reflect.Func {\n\t\treturn errors.New(\"non-function passed to RegisterAggregator\")\n\t}\n\tif t.NumOut() != 1 && t.NumOut() != 2 {\n\t\treturn errors.New(\"SQLite aggregator constructors must return 1 or 2 values\")\n\t}\n\tif t.NumOut() == 2 && !t.Out(1).Implements(reflect.TypeOf((*error)(nil)).Elem()) {\n\t\treturn errors.New(\"Second return value of SQLite function must be error\")\n\t}\n\tif t.NumIn() != 0 {\n\t\treturn errors.New(\"SQLite aggregator constructors must not have arguments\")\n\t}\n\n\tagg := t.Out(0)\n\tswitch agg.Kind() {\n\tcase reflect.Ptr, reflect.Interface:\n\tdefault:\n\t\treturn errors.New(\"SQlite aggregator constructor must return a pointer object\")\n\t}\n\tstepFn, found := agg.MethodByName(\"Step\")\n\tif !found {\n\t\treturn errors.New(\"SQlite aggregator doesn't have a Step() function\")\n\t}\n\tstep := stepFn.Type\n\tif step.NumOut() != 0 && step.NumOut() != 1 {\n\t\treturn errors.New(\"SQlite aggregator Step() function must return 0 or 1 values\")\n\t}\n\tif step.NumOut() == 1 && !step.Out(0).Implements(reflect.TypeOf((*error)(nil)).Elem()) {\n\t\treturn errors.New(\"type of SQlite aggregator Step() return value must be error\")\n\t}\n\n\tstepNArgs := step.NumIn()\n\tstart := 0\n\tif agg.Kind() == reflect.Ptr {\n\t\t// Skip over the method receiver\n\t\tstepNArgs--\n\t\tstart++\n\t}\n\tif step.IsVariadic() {\n\t\tstepNArgs--\n\t}\n\tfor i := start; i < start+stepNArgs; i++ {\n\t\tconv, err := callbackArg(step.In(i))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tai.stepArgConverters = append(ai.stepArgConverters, conv)\n\t}\n\tif step.IsVariadic() {\n\t\tconv, err := callbackArg(step.In(start + stepNArgs).Elem())\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tai.stepVariadicConverter = conv\n\t\t// Pass -1 to sqlite so that it allows any number of\n\t\t// arguments. The call helper verifies that the minimum number\n\t\t// of arguments is present for variadic functions.\n\t\tstepNArgs = -1\n\t}\n\n\tdoneFn, found := agg.MethodByName(\"Done\")\n\tif !found {\n\t\treturn errors.New(\"SQlite aggregator doesn't have a Done() function\")\n\t}\n\tdone := doneFn.Type\n\tdoneNArgs := done.NumIn()\n\tif agg.Kind() == reflect.Ptr {\n\t\t// Skip over the method receiver\n\t\tdoneNArgs--\n\t}\n\tif doneNArgs != 0 {\n\t\treturn errors.New(\"SQlite aggregator Done() function must have no arguments\")\n\t}\n\tif done.NumOut() != 1 && done.NumOut() != 2 {\n\t\treturn errors.New(\"SQLite aggregator Done() function must return 1 or 2 values\")\n\t}\n\tif done.NumOut() == 2 && !done.Out(1).Implements(reflect.TypeOf((*error)(nil)).Elem()) {\n\t\treturn errors.New(\"second return value of SQLite aggregator Done() function must be error\")\n\t}\n\n\tconv, err := callbackRet(done.Out(0))\n\tif err != nil {\n\t\treturn err\n\t}\n\tai.doneRetConverter = conv\n\tai.active = make(map[int64]reflect.Value)\n\tai.next = 1\n\n\t// ai must outlast the database connection, or we'll have dangling pointers.\n\tc.aggregators = append(c.aggregators, &ai)\n\n\tcname := C.CString(name)\n\tdefer C.free(unsafe.Pointer(cname))\n\topts := C.SQLITE_UTF8\n\tif pure {\n\t\topts |= C.SQLITE_DETERMINISTIC\n\t}\n\trv := sqlite3CreateFunction(c.db, cname, C.int(stepNArgs), C.int(opts), newHandle(c, &ai), nil, C.stepTrampoline, C.doneTrampoline)\n\tif rv != C.SQLITE_OK {\n\t\treturn c.lastError()\n\t}\n\treturn nil\n}\n\n// AutoCommit return which currently auto commit or not.\nfunc (c *SQLiteConn) AutoCommit() bool {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\treturn int(C.sqlite3_get_autocommit(c.db)) != 0\n}\n\nfunc (c *SQLiteConn) lastError() error {\n\treturn lastError(c.db)\n}\n\n// Note: may be called with db == nil\nfunc lastError(db *C.sqlite3) error {\n\trv := C.sqlite3_errcode(db) // returns SQLITE_NOMEM if db == nil\n\tif rv == C.SQLITE_OK {\n\t\treturn nil\n\t}\n\textrv := C.sqlite3_extended_errcode(db)    // returns SQLITE_NOMEM if db == nil\n\terrStr := C.GoString(C.sqlite3_errmsg(db)) // returns \"out of memory\" if db == nil\n\n\t// https://www.sqlite.org/c3ref/system_errno.html\n\t// sqlite3_system_errno is only meaningful if the error code was SQLITE_CANTOPEN,\n\t// or it was SQLITE_IOERR and the extended code was not SQLITE_IOERR_NOMEM\n\tvar systemErrno syscall.Errno\n\tif rv == C.SQLITE_CANTOPEN || (rv == C.SQLITE_IOERR && extrv != C.SQLITE_IOERR_NOMEM) {\n\t\tsystemErrno = syscall.Errno(C.sqlite3_system_errno(db))\n\t}\n\n\treturn Error{\n\t\tCode:         ErrNo(rv),\n\t\tExtendedCode: ErrNoExtended(extrv),\n\t\tSystemErrno:  systemErrno,\n\t\terr:          errStr,\n\t}\n}\n\n// Exec implements Execer.\nfunc (c *SQLiteConn) Exec(query string, args []driver.Value) (driver.Result, error) {\n\tlist := make([]driver.NamedValue, len(args))\n\tfor i, v := range args {\n\t\tlist[i] = driver.NamedValue{\n\t\t\tOrdinal: i + 1,\n\t\t\tValue:   v,\n\t\t}\n\t}\n\treturn c.exec(context.Background(), query, list)\n}\n\nfunc (c *SQLiteConn) exec(ctx context.Context, query string, args []driver.NamedValue) (driver.Result, error) {\n\tstart := 0\n\tfor {\n\t\ts, err := c.prepare(ctx, query)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tvar res driver.Result\n\t\tif s.(*SQLiteStmt).s != nil {\n\t\t\tstmtArgs := make([]driver.NamedValue, 0, len(args))\n\t\t\tna := s.NumInput()\n\t\t\tif len(args)-start < na {\n\t\t\t\ts.Close()\n\t\t\t\treturn nil, fmt.Errorf(\"not enough args to execute query: want %d got %d\", na, len(args))\n\t\t\t}\n\t\t\t// consume the number of arguments used in the current\n\t\t\t// statement and append all named arguments not\n\t\t\t// contained therein\n\t\t\tif len(args[start:start+na]) > 0 {\n\t\t\t\tstmtArgs = append(stmtArgs, args[start:start+na]...)\n\t\t\t\tfor i := range args {\n\t\t\t\t\tif (i < start || i >= na) && args[i].Name != \"\" {\n\t\t\t\t\t\tstmtArgs = append(stmtArgs, args[i])\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor i := range stmtArgs {\n\t\t\t\t\tstmtArgs[i].Ordinal = i + 1\n\t\t\t\t}\n\t\t\t}\n\t\t\tres, err = s.(*SQLiteStmt).exec(ctx, stmtArgs)\n\t\t\tif err != nil && err != driver.ErrSkip {\n\t\t\t\ts.Close()\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tstart += na\n\t\t}\n\t\ttail := s.(*SQLiteStmt).t\n\t\ts.Close()\n\t\tif tail == \"\" {\n\t\t\tif res == nil {\n\t\t\t\t// https://github.com/mattn/go-sqlite3/issues/963\n\t\t\t\tres = &SQLiteResult{0, 0}\n\t\t\t}\n\t\t\treturn res, nil\n\t\t}\n\t\tquery = tail\n\t}\n}\n\n// Query implements Queryer.\nfunc (c *SQLiteConn) Query(query string, args []driver.Value) (driver.Rows, error) {\n\tlist := make([]driver.NamedValue, len(args))\n\tfor i, v := range args {\n\t\tlist[i] = driver.NamedValue{\n\t\t\tOrdinal: i + 1,\n\t\t\tValue:   v,\n\t\t}\n\t}\n\treturn c.query(context.Background(), query, list)\n}\n\nfunc (c *SQLiteConn) query(ctx context.Context, query string, args []driver.NamedValue) (driver.Rows, error) {\n\tstart := 0\n\tfor {\n\t\tstmtArgs := make([]driver.NamedValue, 0, len(args))\n\t\ts, err := c.prepare(ctx, query)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\ts.(*SQLiteStmt).cls = true\n\t\tna := s.NumInput()\n\t\tif len(args)-start < na {\n\t\t\ts.Close()\n\t\t\treturn nil, fmt.Errorf(\"not enough args to execute query: want %d got %d\", na, len(args)-start)\n\t\t}\n\t\t// consume the number of arguments used in the current\n\t\t// statement and append all named arguments not contained\n\t\t// therein\n\t\tstmtArgs = append(stmtArgs, args[start:start+na]...)\n\t\tfor i := range args {\n\t\t\tif (i < start || i >= na) && args[i].Name != \"\" {\n\t\t\t\tstmtArgs = append(stmtArgs, args[i])\n\t\t\t}\n\t\t}\n\t\tfor i := range stmtArgs {\n\t\t\tstmtArgs[i].Ordinal = i + 1\n\t\t}\n\t\trows, err := s.(*SQLiteStmt).query(ctx, stmtArgs)\n\t\tif err != nil && err != driver.ErrSkip {\n\t\t\ts.Close()\n\t\t\treturn rows, err\n\t\t}\n\t\tstart += na\n\t\ttail := s.(*SQLiteStmt).t\n\t\tif tail == \"\" {\n\t\t\treturn rows, nil\n\t\t}\n\t\trows.Close()\n\t\ts.Close()\n\t\tquery = tail\n\t}\n}\n\n// Begin transaction.\nfunc (c *SQLiteConn) Begin() (driver.Tx, error) {\n\treturn c.begin(context.Background())\n}\n\nfunc (c *SQLiteConn) begin(ctx context.Context) (driver.Tx, error) {\n\tif _, err := c.exec(ctx, c.txlock, nil); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &SQLiteTx{c}, nil\n}\n\n// Open database and return a new connection.\n//\n// A pragma can take either zero or one argument.\n// The argument is may be either in parentheses or it may be separated from\n// the pragma name by an equal sign. The two syntaxes yield identical results.\n// In many pragmas, the argument is a boolean. The boolean can be one of:\n//\n//\t1 yes true on\n//\t0 no false off\n//\n// You can specify a DSN string using a URI as the filename.\n//\n//\ttest.db\n//\tfile:test.db?cache=shared&mode=memory\n//\t:memory:\n//\tfile::memory:\n//\n//\tmode\n//\t  Access mode of the database.\n//\t  https://www.sqlite.org/c3ref/open.html\n//\t  Values:\n//\t   - ro\n//\t   - rw\n//\t   - rwc\n//\t   - memory\n//\n//\tcache\n//\t  SQLite Shared-Cache Mode\n//\t  https://www.sqlite.org/sharedcache.html\n//\t  Values:\n//\t    - shared\n//\t    - private\n//\n//\timmutable=Boolean\n//\t  The immutable parameter is a boolean query parameter that indicates\n//\t  that the database file is stored on read-only media. When immutable is set,\n//\t  SQLite assumes that the database file cannot be changed,\n//\t  even by a process with higher privilege,\n//\t  and so the database is opened read-only and all locking and change detection is disabled.\n//\t  Caution: Setting the immutable property on a database file that\n//\t  does in fact change can result in incorrect query results and/or SQLITE_CORRUPT errors.\n//\n// go-sqlite3 adds the following query parameters to those used by SQLite:\n//\n//\t_loc=XXX\n//\t  Specify location of time format. It's possible to specify \"auto\".\n//\n//\t_mutex=XXX\n//\t  Specify mutex mode. XXX can be \"no\", \"full\".\n//\n//\t_txlock=XXX\n//\t  Specify locking behavior for transactions.  XXX can be \"immediate\",\n//\t  \"deferred\", \"exclusive\".\n//\n//\t_auto_vacuum=X | _vacuum=X\n//\t  0 | none - Auto Vacuum disabled\n//\t  1 | full - Auto Vacuum FULL\n//\t  2 | incremental - Auto Vacuum Incremental\n//\n//\t_busy_timeout=XXX\"| _timeout=XXX\n//\t  Specify value for sqlite3_busy_timeout.\n//\n//\t_case_sensitive_like=Boolean | _cslike=Boolean\n//\t  https://www.sqlite.org/pragma.html#pragma_case_sensitive_like\n//\t  Default or disabled the LIKE operation is case-insensitive.\n//\t  When enabling this options behaviour of LIKE will become case-sensitive.\n//\n//\t_defer_foreign_keys=Boolean | _defer_fk=Boolean\n//\t  Defer Foreign Keys until outermost transaction is committed.\n//\n//\t_foreign_keys=Boolean | _fk=Boolean\n//\t  Enable or disable enforcement of foreign keys.\n//\n//\t_ignore_check_constraints=Boolean\n//\t  This pragma enables or disables the enforcement of CHECK constraints.\n//\t  The default setting is off, meaning that CHECK constraints are enforced by default.\n//\n//\t_journal_mode=MODE | _journal=MODE\n//\t  Set journal mode for the databases associated with the current connection.\n//\t  https://www.sqlite.org/pragma.html#pragma_journal_mode\n//\n//\t_locking_mode=X | _locking=X\n//\t  Sets the database connection locking-mode.\n//\t  The locking-mode is either NORMAL or EXCLUSIVE.\n//\t  https://www.sqlite.org/pragma.html#pragma_locking_mode\n//\n//\t_query_only=Boolean\n//\t  The query_only pragma prevents all changes to database files when enabled.\n//\n//\t_recursive_triggers=Boolean | _rt=Boolean\n//\t  Enable or disable recursive triggers.\n//\n//\t_secure_delete=Boolean|FAST\n//\t  When secure_delete is on, SQLite overwrites deleted content with zeros.\n//\t  https://www.sqlite.org/pragma.html#pragma_secure_delete\n//\n//\t_synchronous=X | _sync=X\n//\t  Change the setting of the \"synchronous\" flag.\n//\t  https://www.sqlite.org/pragma.html#pragma_synchronous\n//\n//\t_writable_schema=Boolean\n//\t  When this pragma is on, the SQLITE_MASTER tables in which database\n//\t  can be changed using ordinary UPDATE, INSERT, and DELETE statements.\n//\t  Warning: misuse of this pragma can easily result in a corrupt database file.\nfunc (d *SQLiteDriver) Open(dsn string) (driver.Conn, error) {\n\tif C.sqlite3_threadsafe() == 0 {\n\t\treturn nil, errors.New(\"sqlite library was not compiled for thread-safe operation\")\n\t}\n\n\tvar pkey string\n\n\t// Options\n\tvar loc *time.Location\n\tauthCreate := false\n\tauthUser := \"\"\n\tauthPass := \"\"\n\tauthCrypt := \"\"\n\tauthSalt := \"\"\n\tmutex := C.int(C.SQLITE_OPEN_FULLMUTEX)\n\ttxlock := \"BEGIN\"\n\n\t// PRAGMA's\n\tautoVacuum := -1\n\tbusyTimeout := 5000\n\tcaseSensitiveLike := -1\n\tdeferForeignKeys := -1\n\tforeignKeys := -1\n\tignoreCheckConstraints := -1\n\tvar journalMode string\n\tlockingMode := \"NORMAL\"\n\tqueryOnly := -1\n\trecursiveTriggers := -1\n\tsecureDelete := \"DEFAULT\"\n\tsynchronousMode := \"NORMAL\"\n\twritableSchema := -1\n\tvfsName := \"\"\n\tvar cacheSize *int64\n\n\tpos := strings.IndexRune(dsn, '?')\n\tif pos >= 1 {\n\t\tparams, err := url.ParseQuery(dsn[pos+1:])\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// Authentication\n\t\tif _, ok := params[\"_auth\"]; ok {\n\t\t\tauthCreate = true\n\t\t}\n\t\tif val := params.Get(\"_auth_user\"); val != \"\" {\n\t\t\tauthUser = val\n\t\t}\n\t\tif val := params.Get(\"_auth_pass\"); val != \"\" {\n\t\t\tauthPass = val\n\t\t}\n\t\tif val := params.Get(\"_auth_crypt\"); val != \"\" {\n\t\t\tauthCrypt = val\n\t\t}\n\t\tif val := params.Get(\"_auth_salt\"); val != \"\" {\n\t\t\tauthSalt = val\n\t\t}\n\n\t\t// _loc\n\t\tif val := params.Get(\"_loc\"); val != \"\" {\n\t\t\tswitch strings.ToLower(val) {\n\t\t\tcase \"auto\":\n\t\t\t\tloc = time.Local\n\t\t\tdefault:\n\t\t\t\tloc, err = time.LoadLocation(val)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, fmt.Errorf(\"Invalid _loc: %v: %v\", val, err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// _mutex\n\t\tif val := params.Get(\"_mutex\"); val != \"\" {\n\t\t\tswitch strings.ToLower(val) {\n\t\t\tcase \"no\":\n\t\t\t\tmutex = C.SQLITE_OPEN_NOMUTEX\n\t\t\tcase \"full\":\n\t\t\t\tmutex = C.SQLITE_OPEN_FULLMUTEX\n\t\t\tdefault:\n\t\t\t\treturn nil, fmt.Errorf(\"Invalid _mutex: %v\", val)\n\t\t\t}\n\t\t}\n\n\t\t// _txlock\n\t\tif val := params.Get(\"_txlock\"); val != \"\" {\n\t\t\tswitch strings.ToLower(val) {\n\t\t\tcase \"immediate\":\n\t\t\t\ttxlock = \"BEGIN IMMEDIATE\"\n\t\t\tcase \"exclusive\":\n\t\t\t\ttxlock = \"BEGIN EXCLUSIVE\"\n\t\t\tcase \"deferred\":\n\t\t\t\ttxlock = \"BEGIN\"\n\t\t\tdefault:\n\t\t\t\treturn nil, fmt.Errorf(\"Invalid _txlock: %v\", val)\n\t\t\t}\n\t\t}\n\n\t\t// Auto Vacuum (_vacuum)\n\t\t//\n\t\t// https://www.sqlite.org/pragma.html#pragma_auto_vacuum\n\t\t//\n\t\tpkey = \"\" // Reset pkey\n\t\tif _, ok := params[\"_auto_vacuum\"]; ok {\n\t\t\tpkey = \"_auto_vacuum\"\n\t\t}\n\t\tif _, ok := params[\"_vacuum\"]; ok {\n\t\t\tpkey = \"_vacuum\"\n\t\t}\n\t\tif val := params.Get(pkey); val != \"\" {\n\t\t\tswitch strings.ToLower(val) {\n\t\t\tcase \"0\", \"none\":\n\t\t\t\tautoVacuum = 0\n\t\t\tcase \"1\", \"full\":\n\t\t\t\tautoVacuum = 1\n\t\t\tcase \"2\", \"incremental\":\n\t\t\t\tautoVacuum = 2\n\t\t\tdefault:\n\t\t\t\treturn nil, fmt.Errorf(\"Invalid _auto_vacuum: %v, expecting value of '0 NONE 1 FULL 2 INCREMENTAL'\", val)\n\t\t\t}\n\t\t}\n\n\t\t// Busy Timeout (_busy_timeout)\n\t\t//\n\t\t// https://www.sqlite.org/pragma.html#pragma_busy_timeout\n\t\t//\n\t\tpkey = \"\" // Reset pkey\n\t\tif _, ok := params[\"_busy_timeout\"]; ok {\n\t\t\tpkey = \"_busy_timeout\"\n\t\t}\n\t\tif _, ok := params[\"_timeout\"]; ok {\n\t\t\tpkey = \"_timeout\"\n\t\t}\n\t\tif val := params.Get(pkey); val != \"\" {\n\t\t\tiv, err := strconv.ParseInt(val, 10, 64)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"Invalid _busy_timeout: %v: %v\", val, err)\n\t\t\t}\n\t\t\tbusyTimeout = int(iv)\n\t\t}\n\n\t\t// Case Sensitive Like (_cslike)\n\t\t//\n\t\t// https://www.sqlite.org/pragma.html#pragma_case_sensitive_like\n\t\t//\n\t\tpkey = \"\" // Reset pkey\n\t\tif _, ok := params[\"_case_sensitive_like\"]; ok {\n\t\t\tpkey = \"_case_sensitive_like\"\n\t\t}\n\t\tif _, ok := params[\"_cslike\"]; ok {\n\t\t\tpkey = \"_cslike\"\n\t\t}\n\t\tif val := params.Get(pkey); val != \"\" {\n\t\t\tswitch strings.ToLower(val) {\n\t\t\tcase \"0\", \"no\", \"false\", \"off\":\n\t\t\t\tcaseSensitiveLike = 0\n\t\t\tcase \"1\", \"yes\", \"true\", \"on\":\n\t\t\t\tcaseSensitiveLike = 1\n\t\t\tdefault:\n\t\t\t\treturn nil, fmt.Errorf(\"Invalid _case_sensitive_like: %v, expecting boolean value of '0 1 false true no yes off on'\", val)\n\t\t\t}\n\t\t}\n\n\t\t// Defer Foreign Keys (_defer_foreign_keys | _defer_fk)\n\t\t//\n\t\t// https://www.sqlite.org/pragma.html#pragma_defer_foreign_keys\n\t\t//\n\t\tpkey = \"\" // Reset pkey\n\t\tif _, ok := params[\"_defer_foreign_keys\"]; ok {\n\t\t\tpkey = \"_defer_foreign_keys\"\n\t\t}\n\t\tif _, ok := params[\"_defer_fk\"]; ok {\n\t\t\tpkey = \"_defer_fk\"\n\t\t}\n\t\tif val := params.Get(pkey); val != \"\" {\n\t\t\tswitch strings.ToLower(val) {\n\t\t\tcase \"0\", \"no\", \"false\", \"off\":\n\t\t\t\tdeferForeignKeys = 0\n\t\t\tcase \"1\", \"yes\", \"true\", \"on\":\n\t\t\t\tdeferForeignKeys = 1\n\t\t\tdefault:\n\t\t\t\treturn nil, fmt.Errorf(\"Invalid _defer_foreign_keys: %v, expecting boolean value of '0 1 false true no yes off on'\", val)\n\t\t\t}\n\t\t}\n\n\t\t// Foreign Keys (_foreign_keys | _fk)\n\t\t//\n\t\t// https://www.sqlite.org/pragma.html#pragma_foreign_keys\n\t\t//\n\t\tpkey = \"\" // Reset pkey\n\t\tif _, ok := params[\"_foreign_keys\"]; ok {\n\t\t\tpkey = \"_foreign_keys\"\n\t\t}\n\t\tif _, ok := params[\"_fk\"]; ok {\n\t\t\tpkey = \"_fk\"\n\t\t}\n\t\tif val := params.Get(pkey); val != \"\" {\n\t\t\tswitch strings.ToLower(val) {\n\t\t\tcase \"0\", \"no\", \"false\", \"off\":\n\t\t\t\tforeignKeys = 0\n\t\t\tcase \"1\", \"yes\", \"true\", \"on\":\n\t\t\t\tforeignKeys = 1\n\t\t\tdefault:\n\t\t\t\treturn nil, fmt.Errorf(\"Invalid _foreign_keys: %v, expecting boolean value of '0 1 false true no yes off on'\", val)\n\t\t\t}\n\t\t}\n\n\t\t// Ignore CHECK Constrains (_ignore_check_constraints)\n\t\t//\n\t\t// https://www.sqlite.org/pragma.html#pragma_ignore_check_constraints\n\t\t//\n\t\tif val := params.Get(\"_ignore_check_constraints\"); val != \"\" {\n\t\t\tswitch strings.ToLower(val) {\n\t\t\tcase \"0\", \"no\", \"false\", \"off\":\n\t\t\t\tignoreCheckConstraints = 0\n\t\t\tcase \"1\", \"yes\", \"true\", \"on\":\n\t\t\t\tignoreCheckConstraints = 1\n\t\t\tdefault:\n\t\t\t\treturn nil, fmt.Errorf(\"Invalid _ignore_check_constraints: %v, expecting boolean value of '0 1 false true no yes off on'\", val)\n\t\t\t}\n\t\t}\n\n\t\t// Journal Mode (_journal_mode | _journal)\n\t\t//\n\t\t// https://www.sqlite.org/pragma.html#pragma_journal_mode\n\t\t//\n\t\tpkey = \"\" // Reset pkey\n\t\tif _, ok := params[\"_journal_mode\"]; ok {\n\t\t\tpkey = \"_journal_mode\"\n\t\t}\n\t\tif _, ok := params[\"_journal\"]; ok {\n\t\t\tpkey = \"_journal\"\n\t\t}\n\t\tif val := params.Get(pkey); val != \"\" {\n\t\t\tswitch strings.ToUpper(val) {\n\t\t\tcase \"DELETE\", \"TRUNCATE\", \"PERSIST\", \"MEMORY\", \"OFF\":\n\t\t\t\tjournalMode = strings.ToUpper(val)\n\t\t\tcase \"WAL\":\n\t\t\t\tjournalMode = strings.ToUpper(val)\n\n\t\t\t\t// For WAL Mode set Synchronous Mode to 'NORMAL'\n\t\t\t\t// See https://www.sqlite.org/pragma.html#pragma_synchronous\n\t\t\t\tsynchronousMode = \"NORMAL\"\n\t\t\tdefault:\n\t\t\t\treturn nil, fmt.Errorf(\"Invalid _journal: %v, expecting value of 'DELETE TRUNCATE PERSIST MEMORY WAL OFF'\", val)\n\t\t\t}\n\t\t}\n\n\t\t// Locking Mode (_locking)\n\t\t//\n\t\t// https://www.sqlite.org/pragma.html#pragma_locking_mode\n\t\t//\n\t\tpkey = \"\" // Reset pkey\n\t\tif _, ok := params[\"_locking_mode\"]; ok {\n\t\t\tpkey = \"_locking_mode\"\n\t\t}\n\t\tif _, ok := params[\"_locking\"]; ok {\n\t\t\tpkey = \"_locking\"\n\t\t}\n\t\tif val := params.Get(pkey); val != \"\" {\n\t\t\tswitch strings.ToUpper(val) {\n\t\t\tcase \"NORMAL\", \"EXCLUSIVE\":\n\t\t\t\tlockingMode = strings.ToUpper(val)\n\t\t\tdefault:\n\t\t\t\treturn nil, fmt.Errorf(\"Invalid _locking_mode: %v, expecting value of 'NORMAL EXCLUSIVE\", val)\n\t\t\t}\n\t\t}\n\n\t\t// Query Only (_query_only)\n\t\t//\n\t\t// https://www.sqlite.org/pragma.html#pragma_query_only\n\t\t//\n\t\tif val := params.Get(\"_query_only\"); val != \"\" {\n\t\t\tswitch strings.ToLower(val) {\n\t\t\tcase \"0\", \"no\", \"false\", \"off\":\n\t\t\t\tqueryOnly = 0\n\t\t\tcase \"1\", \"yes\", \"true\", \"on\":\n\t\t\t\tqueryOnly = 1\n\t\t\tdefault:\n\t\t\t\treturn nil, fmt.Errorf(\"Invalid _query_only: %v, expecting boolean value of '0 1 false true no yes off on'\", val)\n\t\t\t}\n\t\t}\n\n\t\t// Recursive Triggers (_recursive_triggers)\n\t\t//\n\t\t// https://www.sqlite.org/pragma.html#pragma_recursive_triggers\n\t\t//\n\t\tpkey = \"\" // Reset pkey\n\t\tif _, ok := params[\"_recursive_triggers\"]; ok {\n\t\t\tpkey = \"_recursive_triggers\"\n\t\t}\n\t\tif _, ok := params[\"_rt\"]; ok {\n\t\t\tpkey = \"_rt\"\n\t\t}\n\t\tif val := params.Get(pkey); val != \"\" {\n\t\t\tswitch strings.ToLower(val) {\n\t\t\tcase \"0\", \"no\", \"false\", \"off\":\n\t\t\t\trecursiveTriggers = 0\n\t\t\tcase \"1\", \"yes\", \"true\", \"on\":\n\t\t\t\trecursiveTriggers = 1\n\t\t\tdefault:\n\t\t\t\treturn nil, fmt.Errorf(\"Invalid _recursive_triggers: %v, expecting boolean value of '0 1 false true no yes off on'\", val)\n\t\t\t}\n\t\t}\n\n\t\t// Secure Delete (_secure_delete)\n\t\t//\n\t\t// https://www.sqlite.org/pragma.html#pragma_secure_delete\n\t\t//\n\t\tif val := params.Get(\"_secure_delete\"); val != \"\" {\n\t\t\tswitch strings.ToLower(val) {\n\t\t\tcase \"0\", \"no\", \"false\", \"off\":\n\t\t\t\tsecureDelete = \"OFF\"\n\t\t\tcase \"1\", \"yes\", \"true\", \"on\":\n\t\t\t\tsecureDelete = \"ON\"\n\t\t\tcase \"fast\":\n\t\t\t\tsecureDelete = \"FAST\"\n\t\t\tdefault:\n\t\t\t\treturn nil, fmt.Errorf(\"Invalid _secure_delete: %v, expecting boolean value of '0 1 false true no yes off on fast'\", val)\n\t\t\t}\n\t\t}\n\n\t\t// Synchronous Mode (_synchronous | _sync)\n\t\t//\n\t\t// https://www.sqlite.org/pragma.html#pragma_synchronous\n\t\t//\n\t\tpkey = \"\" // Reset pkey\n\t\tif _, ok := params[\"_synchronous\"]; ok {\n\t\t\tpkey = \"_synchronous\"\n\t\t}\n\t\tif _, ok := params[\"_sync\"]; ok {\n\t\t\tpkey = \"_sync\"\n\t\t}\n\t\tif val := params.Get(pkey); val != \"\" {\n\t\t\tswitch strings.ToUpper(val) {\n\t\t\tcase \"0\", \"OFF\", \"1\", \"NORMAL\", \"2\", \"FULL\", \"3\", \"EXTRA\":\n\t\t\t\tsynchronousMode = strings.ToUpper(val)\n\t\t\tdefault:\n\t\t\t\treturn nil, fmt.Errorf(\"Invalid _synchronous: %v, expecting value of '0 OFF 1 NORMAL 2 FULL 3 EXTRA'\", val)\n\t\t\t}\n\t\t}\n\n\t\t// Writable Schema (_writeable_schema)\n\t\t//\n\t\t// https://www.sqlite.org/pragma.html#pragma_writeable_schema\n\t\t//\n\t\tif val := params.Get(\"_writable_schema\"); val != \"\" {\n\t\t\tswitch strings.ToLower(val) {\n\t\t\tcase \"0\", \"no\", \"false\", \"off\":\n\t\t\t\twritableSchema = 0\n\t\t\tcase \"1\", \"yes\", \"true\", \"on\":\n\t\t\t\twritableSchema = 1\n\t\t\tdefault:\n\t\t\t\treturn nil, fmt.Errorf(\"Invalid _writable_schema: %v, expecting boolean value of '0 1 false true no yes off on'\", val)\n\t\t\t}\n\t\t}\n\n\t\t// Cache size (_cache_size)\n\t\t//\n\t\t// https://sqlite.org/pragma.html#pragma_cache_size\n\t\t//\n\t\tif val := params.Get(\"_cache_size\"); val != \"\" {\n\t\t\tiv, err := strconv.ParseInt(val, 10, 64)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"Invalid _cache_size: %v: %v\", val, err)\n\t\t\t}\n\t\t\tcacheSize = &iv\n\t\t}\n\n\t\tif val := params.Get(\"vfs\"); val != \"\" {\n\t\t\tvfsName = val\n\t\t}\n\n\t\tif !strings.HasPrefix(dsn, \"file:\") {\n\t\t\tdsn = dsn[:pos]\n\t\t}\n\t}\n\n\tvar db *C.sqlite3\n\tname := C.CString(dsn)\n\tdefer C.free(unsafe.Pointer(name))\n\tvar vfs *C.char\n\tif vfsName != \"\" {\n\t\tvfs = C.CString(vfsName)\n\t\tdefer C.free(unsafe.Pointer(vfs))\n\t}\n\trv := C._sqlite3_open_v2(name, &db,\n\t\tmutex|C.SQLITE_OPEN_READWRITE|C.SQLITE_OPEN_CREATE,\n\t\tvfs)\n\tif rv != 0 {\n\t\t// Save off the error _before_ closing the database.\n\t\t// This is safe even if db is nil.\n\t\terr := lastError(db)\n\t\tif db != nil {\n\t\t\tC.sqlite3_close_v2(db)\n\t\t}\n\t\treturn nil, err\n\t}\n\tif db == nil {\n\t\treturn nil, errors.New(\"sqlite succeeded without returning a database\")\n\t}\n\n\texec := func(s string) error {\n\t\tcs := C.CString(s)\n\t\trv := C.sqlite3_exec(db, cs, nil, nil, nil)\n\t\tC.free(unsafe.Pointer(cs))\n\t\tif rv != C.SQLITE_OK {\n\t\t\treturn lastError(db)\n\t\t}\n\t\treturn nil\n\t}\n\n\t// Busy timeout\n\tif err := exec(fmt.Sprintf(\"PRAGMA busy_timeout = %d;\", busyTimeout)); err != nil {\n\t\tC.sqlite3_close_v2(db)\n\t\treturn nil, err\n\t}\n\n\t// USER AUTHENTICATION\n\t//\n\t// User Authentication is always performed even when\n\t// sqlite_userauth is not compiled in, because without user authentication\n\t// the authentication is a no-op.\n\t//\n\t// Workflow\n\t//\t- Authenticate\n\t//\t\tON::SUCCESS\t\t=> Continue\n\t//\t\tON::SQLITE_AUTH => Return error and exit Open(...)\n\t//\n\t//  - Activate User Authentication\n\t//\t\tCheck if the user wants to activate User Authentication.\n\t//\t\tIf so then first create a temporary AuthConn to the database\n\t//\t\tThis is possible because we are already successfully authenticated.\n\t//\n\t//\t- Check if `sqlite_user`` table exists\n\t//\t\tYES\t\t\t\t=> Add the provided user from DSN as Admin User and\n\t//\t\t\t\t\t\t   activate user authentication.\n\t//\t\tNO\t\t\t\t=> Continue\n\t//\n\n\t// Create connection to SQLite\n\tconn := &SQLiteConn{db: db, loc: loc, txlock: txlock}\n\n\t// Password Cipher has to be registered before authentication\n\tif len(authCrypt) > 0 {\n\t\tswitch strings.ToUpper(authCrypt) {\n\t\tcase \"SHA1\":\n\t\t\tif err := conn.RegisterFunc(\"sqlite_crypt\", CryptEncoderSHA1, true); err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"CryptEncoderSHA1: %s\", err)\n\t\t\t}\n\t\tcase \"SSHA1\":\n\t\t\tif len(authSalt) == 0 {\n\t\t\t\treturn nil, fmt.Errorf(\"_auth_crypt=ssha1, requires _auth_salt\")\n\t\t\t}\n\t\t\tif err := conn.RegisterFunc(\"sqlite_crypt\", CryptEncoderSSHA1(authSalt), true); err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"CryptEncoderSSHA1: %s\", err)\n\t\t\t}\n\t\tcase \"SHA256\":\n\t\t\tif err := conn.RegisterFunc(\"sqlite_crypt\", CryptEncoderSHA256, true); err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"CryptEncoderSHA256: %s\", err)\n\t\t\t}\n\t\tcase \"SSHA256\":\n\t\t\tif len(authSalt) == 0 {\n\t\t\t\treturn nil, fmt.Errorf(\"_auth_crypt=ssha256, requires _auth_salt\")\n\t\t\t}\n\t\t\tif err := conn.RegisterFunc(\"sqlite_crypt\", CryptEncoderSSHA256(authSalt), true); err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"CryptEncoderSSHA256: %s\", err)\n\t\t\t}\n\t\tcase \"SHA384\":\n\t\t\tif err := conn.RegisterFunc(\"sqlite_crypt\", CryptEncoderSHA384, true); err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"CryptEncoderSHA384: %s\", err)\n\t\t\t}\n\t\tcase \"SSHA384\":\n\t\t\tif len(authSalt) == 0 {\n\t\t\t\treturn nil, fmt.Errorf(\"_auth_crypt=ssha384, requires _auth_salt\")\n\t\t\t}\n\t\t\tif err := conn.RegisterFunc(\"sqlite_crypt\", CryptEncoderSSHA384(authSalt), true); err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"CryptEncoderSSHA384: %s\", err)\n\t\t\t}\n\t\tcase \"SHA512\":\n\t\t\tif err := conn.RegisterFunc(\"sqlite_crypt\", CryptEncoderSHA512, true); err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"CryptEncoderSHA512: %s\", err)\n\t\t\t}\n\t\tcase \"SSHA512\":\n\t\t\tif len(authSalt) == 0 {\n\t\t\t\treturn nil, fmt.Errorf(\"_auth_crypt=ssha512, requires _auth_salt\")\n\t\t\t}\n\t\t\tif err := conn.RegisterFunc(\"sqlite_crypt\", CryptEncoderSSHA512(authSalt), true); err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"CryptEncoderSSHA512: %s\", err)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Preform Authentication\n\tif err := conn.Authenticate(authUser, authPass); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Register: authenticate\n\t// Authenticate will perform an authentication of the provided username\n\t// and password against the database.\n\t//\n\t// If a database contains the SQLITE_USER table, then the\n\t// call to Authenticate must be invoked with an\n\t// appropriate username and password prior to enable read and write\n\t//access to the database.\n\t//\n\t// Return SQLITE_OK on success or SQLITE_ERROR if the username/password\n\t// combination is incorrect or unknown.\n\t//\n\t// If the SQLITE_USER table is not present in the database file, then\n\t// this interface is a harmless no-op returnning SQLITE_OK.\n\tif err := conn.RegisterFunc(\"authenticate\", conn.authenticate, true); err != nil {\n\t\treturn nil, err\n\t}\n\t//\n\t// Register: auth_user_add\n\t// auth_user_add can be used (by an admin user only)\n\t// to create a new user. When called on a no-authentication-required\n\t// database, this routine converts the database into an authentication-\n\t// required database, automatically makes the added user an\n\t// administrator, and logs in the current connection as that user.\n\t// The AuthUserAdd only works for the \"main\" database, not\n\t// for any ATTACH-ed databases. Any call to AuthUserAdd by a\n\t// non-admin user results in an error.\n\tif err := conn.RegisterFunc(\"auth_user_add\", conn.authUserAdd, true); err != nil {\n\t\treturn nil, err\n\t}\n\t//\n\t// Register: auth_user_change\n\t// auth_user_change can be used to change a users\n\t// login credentials or admin privilege.  Any user can change their own\n\t// login credentials. Only an admin user can change another users login\n\t// credentials or admin privilege setting. No user may change their own\n\t// admin privilege setting.\n\tif err := conn.RegisterFunc(\"auth_user_change\", conn.authUserChange, true); err != nil {\n\t\treturn nil, err\n\t}\n\t//\n\t// Register: auth_user_delete\n\t// auth_user_delete can be used (by an admin user only)\n\t// to delete a user. The currently logged-in user cannot be deleted,\n\t// which guarantees that there is always an admin user and hence that\n\t// the database cannot be converted into a no-authentication-required\n\t// database.\n\tif err := conn.RegisterFunc(\"auth_user_delete\", conn.authUserDelete, true); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Register: auth_enabled\n\t// auth_enabled can be used to check if user authentication is enabled\n\tif err := conn.RegisterFunc(\"auth_enabled\", conn.authEnabled, true); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Auto Vacuum\n\t// Moved auto_vacuum command, the user preference for auto_vacuum needs to be implemented directly after\n\t// the authentication and before the sqlite_user table gets created if the user\n\t// decides to activate User Authentication because\n\t// auto_vacuum needs to be set before any tables are created\n\t// and activating user authentication creates the internal table `sqlite_user`.\n\tif autoVacuum > -1 {\n\t\tif err := exec(fmt.Sprintf(\"PRAGMA auto_vacuum = %d;\", autoVacuum)); err != nil {\n\t\t\tC.sqlite3_close_v2(db)\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Check if user wants to activate User Authentication\n\tif authCreate {\n\t\t// Before going any further, we need to check that the user\n\t\t// has provided an username and password within the DSN.\n\t\t// We are not allowed to continue.\n\t\tif len(authUser) == 0 {\n\t\t\treturn nil, fmt.Errorf(\"Missing '_auth_user' while user authentication was requested with '_auth'\")\n\t\t}\n\t\tif len(authPass) == 0 {\n\t\t\treturn nil, fmt.Errorf(\"Missing '_auth_pass' while user authentication was requested with '_auth'\")\n\t\t}\n\n\t\t// Check if User Authentication is Enabled\n\t\tauthExists := conn.AuthEnabled()\n\t\tif !authExists {\n\t\t\tif err := conn.AuthUserAdd(authUser, authPass, true); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\n\t// Case Sensitive LIKE\n\tif caseSensitiveLike > -1 {\n\t\tif err := exec(fmt.Sprintf(\"PRAGMA case_sensitive_like = %d;\", caseSensitiveLike)); err != nil {\n\t\t\tC.sqlite3_close_v2(db)\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Defer Foreign Keys\n\tif deferForeignKeys > -1 {\n\t\tif err := exec(fmt.Sprintf(\"PRAGMA defer_foreign_keys = %d;\", deferForeignKeys)); err != nil {\n\t\t\tC.sqlite3_close_v2(db)\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Foreign Keys\n\tif foreignKeys > -1 {\n\t\tif err := exec(fmt.Sprintf(\"PRAGMA foreign_keys = %d;\", foreignKeys)); err != nil {\n\t\t\tC.sqlite3_close_v2(db)\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Ignore CHECK Constraints\n\tif ignoreCheckConstraints > -1 {\n\t\tif err := exec(fmt.Sprintf(\"PRAGMA ignore_check_constraints = %d;\", ignoreCheckConstraints)); err != nil {\n\t\t\tC.sqlite3_close_v2(db)\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Journal Mode\n\tif journalMode != \"\" {\n\t\tif err := exec(fmt.Sprintf(\"PRAGMA journal_mode = %s;\", journalMode)); err != nil {\n\t\t\tC.sqlite3_close_v2(db)\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Locking Mode\n\t// Because the default is NORMAL and this is not changed in this package\n\t// by using the compile time SQLITE_DEFAULT_LOCKING_MODE this PRAGMA can always be executed\n\tif err := exec(fmt.Sprintf(\"PRAGMA locking_mode = %s;\", lockingMode)); err != nil {\n\t\tC.sqlite3_close_v2(db)\n\t\treturn nil, err\n\t}\n\n\t// Query Only\n\tif queryOnly > -1 {\n\t\tif err := exec(fmt.Sprintf(\"PRAGMA query_only = %d;\", queryOnly)); err != nil {\n\t\t\tC.sqlite3_close_v2(db)\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Recursive Triggers\n\tif recursiveTriggers > -1 {\n\t\tif err := exec(fmt.Sprintf(\"PRAGMA recursive_triggers = %d;\", recursiveTriggers)); err != nil {\n\t\t\tC.sqlite3_close_v2(db)\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Secure Delete\n\t//\n\t// Because this package can set the compile time flag SQLITE_SECURE_DELETE with a build tag\n\t// the default value for secureDelete var is 'DEFAULT' this way\n\t// you can compile with secure_delete 'ON' and disable it for a specific database connection.\n\tif secureDelete != \"DEFAULT\" {\n\t\tif err := exec(fmt.Sprintf(\"PRAGMA secure_delete = %s;\", secureDelete)); err != nil {\n\t\t\tC.sqlite3_close_v2(db)\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Synchronous Mode\n\t//\n\t// Because default is NORMAL this statement is always executed\n\tif err := exec(fmt.Sprintf(\"PRAGMA synchronous = %s;\", synchronousMode)); err != nil {\n\t\tconn.Close()\n\t\treturn nil, err\n\t}\n\n\t// Writable Schema\n\tif writableSchema > -1 {\n\t\tif err := exec(fmt.Sprintf(\"PRAGMA writable_schema = %d;\", writableSchema)); err != nil {\n\t\t\tC.sqlite3_close_v2(db)\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Cache Size\n\tif cacheSize != nil {\n\t\tif err := exec(fmt.Sprintf(\"PRAGMA cache_size = %d;\", *cacheSize)); err != nil {\n\t\t\tC.sqlite3_close_v2(db)\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif len(d.Extensions) > 0 {\n\t\tif err := conn.loadExtensions(d.Extensions); err != nil {\n\t\t\tconn.Close()\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif d.ConnectHook != nil {\n\t\tif err := d.ConnectHook(conn); err != nil {\n\t\t\tconn.Close()\n\t\t\treturn nil, err\n\t\t}\n\t}\n\truntime.SetFinalizer(conn, (*SQLiteConn).Close)\n\treturn conn, nil\n}\n\n// Close the connection.\nfunc (c *SQLiteConn) Close() error {\n\trv := C.sqlite3_close_v2(c.db)\n\tif rv != C.SQLITE_OK {\n\t\treturn c.lastError()\n\t}\n\tdeleteHandles(c)\n\tc.mu.Lock()\n\tc.db = nil\n\tc.mu.Unlock()\n\truntime.SetFinalizer(c, nil)\n\treturn nil\n}\n\nfunc (c *SQLiteConn) dbConnOpen() bool {\n\tif c == nil {\n\t\treturn false\n\t}\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\treturn c.db != nil\n}\n\n// Prepare the query string. Return a new statement.\nfunc (c *SQLiteConn) Prepare(query string) (driver.Stmt, error) {\n\treturn c.prepare(context.Background(), query)\n}\n\nfunc (c *SQLiteConn) prepare(ctx context.Context, query string) (driver.Stmt, error) {\n\tpquery := C.CString(query)\n\tdefer C.free(unsafe.Pointer(pquery))\n\tvar s *C.sqlite3_stmt\n\tvar tail *C.char\n\trv := C._sqlite3_prepare_v2_internal(c.db, pquery, C.int(-1), &s, &tail)\n\tif rv != C.SQLITE_OK {\n\t\treturn nil, c.lastError()\n\t}\n\tvar t string\n\tif tail != nil && *tail != '\\000' {\n\t\tt = strings.TrimSpace(C.GoString(tail))\n\t}\n\tss := &SQLiteStmt{c: c, s: s, t: t}\n\truntime.SetFinalizer(ss, (*SQLiteStmt).Close)\n\treturn ss, nil\n}\n\n// Run-Time Limit Categories.\n// See: http://www.sqlite.org/c3ref/c_limit_attached.html\nconst (\n\tSQLITE_LIMIT_LENGTH              = C.SQLITE_LIMIT_LENGTH\n\tSQLITE_LIMIT_SQL_LENGTH          = C.SQLITE_LIMIT_SQL_LENGTH\n\tSQLITE_LIMIT_COLUMN              = C.SQLITE_LIMIT_COLUMN\n\tSQLITE_LIMIT_EXPR_DEPTH          = C.SQLITE_LIMIT_EXPR_DEPTH\n\tSQLITE_LIMIT_COMPOUND_SELECT     = C.SQLITE_LIMIT_COMPOUND_SELECT\n\tSQLITE_LIMIT_VDBE_OP             = C.SQLITE_LIMIT_VDBE_OP\n\tSQLITE_LIMIT_FUNCTION_ARG        = C.SQLITE_LIMIT_FUNCTION_ARG\n\tSQLITE_LIMIT_ATTACHED            = C.SQLITE_LIMIT_ATTACHED\n\tSQLITE_LIMIT_LIKE_PATTERN_LENGTH = C.SQLITE_LIMIT_LIKE_PATTERN_LENGTH\n\tSQLITE_LIMIT_VARIABLE_NUMBER     = C.SQLITE_LIMIT_VARIABLE_NUMBER\n\tSQLITE_LIMIT_TRIGGER_DEPTH       = C.SQLITE_LIMIT_TRIGGER_DEPTH\n\tSQLITE_LIMIT_WORKER_THREADS      = C.SQLITE_LIMIT_WORKER_THREADS\n)\n\n// GetFilename returns the absolute path to the file containing\n// the requested schema. When passed an empty string, it will\n// instead use the database's default schema: \"main\".\n// See: sqlite3_db_filename, https://www.sqlite.org/c3ref/db_filename.html\nfunc (c *SQLiteConn) GetFilename(schemaName string) string {\n\tif schemaName == \"\" {\n\t\tschemaName = \"main\"\n\t}\n\treturn C.GoString(C.sqlite3_db_filename(c.db, C.CString(schemaName)))\n}\n\n// GetLimit returns the current value of a run-time limit.\n// See: sqlite3_limit, http://www.sqlite.org/c3ref/limit.html\nfunc (c *SQLiteConn) GetLimit(id int) int {\n\treturn int(C._sqlite3_limit(c.db, C.int(id), C.int(-1)))\n}\n\n// SetLimit changes the value of a run-time limits.\n// Then this method returns the prior value of the limit.\n// See: sqlite3_limit, http://www.sqlite.org/c3ref/limit.html\nfunc (c *SQLiteConn) SetLimit(id int, newVal int) int {\n\treturn int(C._sqlite3_limit(c.db, C.int(id), C.int(newVal)))\n}\n\n// SetFileControlInt invokes the xFileControl method on a given database. The\n// dbName is the name of the database. It will default to \"main\" if left blank.\n// The op is one of the opcodes prefixed by \"SQLITE_FCNTL_\". The arg argument\n// and return code are both opcode-specific. Please see the SQLite documentation.\n//\n// This method is not thread-safe as the returned error code can be changed by\n// another call if invoked concurrently.\n//\n// See: sqlite3_file_control, https://www.sqlite.org/c3ref/file_control.html\nfunc (c *SQLiteConn) SetFileControlInt(dbName string, op int, arg int) error {\n\tif dbName == \"\" {\n\t\tdbName = \"main\"\n\t}\n\n\tcDBName := C.CString(dbName)\n\tdefer C.free(unsafe.Pointer(cDBName))\n\n\tcArg := C.int(arg)\n\trv := C.sqlite3_file_control(c.db, cDBName, C.int(op), unsafe.Pointer(&cArg))\n\tif rv != C.SQLITE_OK {\n\t\treturn c.lastError()\n\t}\n\treturn nil\n}\n\n// Close the statement.\nfunc (s *SQLiteStmt) Close() error {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\tif s.closed {\n\t\treturn nil\n\t}\n\ts.closed = true\n\tif !s.c.dbConnOpen() {\n\t\treturn errors.New(\"sqlite statement with already closed database connection\")\n\t}\n\trv := C.sqlite3_finalize(s.s)\n\ts.s = nil\n\tif rv != C.SQLITE_OK {\n\t\treturn s.c.lastError()\n\t}\n\ts.c = nil\n\truntime.SetFinalizer(s, nil)\n\treturn nil\n}\n\n// NumInput return a number of parameters.\nfunc (s *SQLiteStmt) NumInput() int {\n\treturn int(C.sqlite3_bind_parameter_count(s.s))\n}\n\nvar placeHolder = []byte{0}\n\nfunc (s *SQLiteStmt) bind(args []driver.NamedValue) error {\n\trv := C.sqlite3_reset(s.s)\n\tif rv != C.SQLITE_ROW && rv != C.SQLITE_OK && rv != C.SQLITE_DONE {\n\t\treturn s.c.lastError()\n\t}\n\n\tbindIndices := make([][3]int, len(args))\n\tprefixes := []string{\":\", \"@\", \"$\"}\n\tfor i, v := range args {\n\t\tbindIndices[i][0] = args[i].Ordinal\n\t\tif v.Name != \"\" {\n\t\t\tfor j := range prefixes {\n\t\t\t\tcname := C.CString(prefixes[j] + v.Name)\n\t\t\t\tbindIndices[i][j] = int(C.sqlite3_bind_parameter_index(s.s, cname))\n\t\t\t\tC.free(unsafe.Pointer(cname))\n\t\t\t}\n\t\t\targs[i].Ordinal = bindIndices[i][0]\n\t\t}\n\t}\n\n\tfor i, arg := range args {\n\t\tfor j := range bindIndices[i] {\n\t\t\tif bindIndices[i][j] == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tn := C.int(bindIndices[i][j])\n\t\t\tswitch v := arg.Value.(type) {\n\t\t\tcase nil:\n\t\t\t\trv = C.sqlite3_bind_null(s.s, n)\n\t\t\tcase string:\n\t\t\t\tif len(v) == 0 {\n\t\t\t\t\trv = C._sqlite3_bind_text(s.s, n, (*C.char)(unsafe.Pointer(&placeHolder[0])), C.int(0))\n\t\t\t\t} else {\n\t\t\t\t\tb := []byte(v)\n\t\t\t\t\trv = C._sqlite3_bind_text(s.s, n, (*C.char)(unsafe.Pointer(&b[0])), C.int(len(b)))\n\t\t\t\t}\n\t\t\tcase int64:\n\t\t\t\trv = C.sqlite3_bind_int64(s.s, n, C.sqlite3_int64(v))\n\t\t\tcase bool:\n\t\t\t\tif v {\n\t\t\t\t\trv = C.sqlite3_bind_int(s.s, n, 1)\n\t\t\t\t} else {\n\t\t\t\t\trv = C.sqlite3_bind_int(s.s, n, 0)\n\t\t\t\t}\n\t\t\tcase float64:\n\t\t\t\trv = C.sqlite3_bind_double(s.s, n, C.double(v))\n\t\t\tcase []byte:\n\t\t\t\tif v == nil {\n\t\t\t\t\trv = C.sqlite3_bind_null(s.s, n)\n\t\t\t\t} else {\n\t\t\t\t\tln := len(v)\n\t\t\t\t\tif ln == 0 {\n\t\t\t\t\t\tv = placeHolder\n\t\t\t\t\t}\n\t\t\t\t\trv = C._sqlite3_bind_blob(s.s, n, unsafe.Pointer(&v[0]), C.int(ln))\n\t\t\t\t}\n\t\t\tcase time.Time:\n\t\t\t\tb := []byte(v.Format(SQLiteTimestampFormats[0]))\n\t\t\t\trv = C._sqlite3_bind_text(s.s, n, (*C.char)(unsafe.Pointer(&b[0])), C.int(len(b)))\n\t\t\t}\n\t\t\tif rv != C.SQLITE_OK {\n\t\t\t\treturn s.c.lastError()\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// Query the statement with arguments. Return records.\nfunc (s *SQLiteStmt) Query(args []driver.Value) (driver.Rows, error) {\n\tlist := make([]driver.NamedValue, len(args))\n\tfor i, v := range args {\n\t\tlist[i] = driver.NamedValue{\n\t\t\tOrdinal: i + 1,\n\t\t\tValue:   v,\n\t\t}\n\t}\n\treturn s.query(context.Background(), list)\n}\n\nfunc (s *SQLiteStmt) query(ctx context.Context, args []driver.NamedValue) (driver.Rows, error) {\n\tif err := s.bind(args); err != nil {\n\t\treturn nil, err\n\t}\n\n\trows := &SQLiteRows{\n\t\ts:        s,\n\t\tnc:       int32(C.sqlite3_column_count(s.s)),\n\t\tcls:      s.cls,\n\t\tcols:     nil,\n\t\tdecltype: nil,\n\t\tctx:      ctx,\n\t}\n\n\treturn rows, nil\n}\n\n// LastInsertId return last inserted ID.\nfunc (r *SQLiteResult) LastInsertId() (int64, error) {\n\treturn r.id, nil\n}\n\n// RowsAffected return how many rows affected.\nfunc (r *SQLiteResult) RowsAffected() (int64, error) {\n\treturn r.changes, nil\n}\n\n// Exec execute the statement with arguments. Return result object.\nfunc (s *SQLiteStmt) Exec(args []driver.Value) (driver.Result, error) {\n\tlist := make([]driver.NamedValue, len(args))\n\tfor i, v := range args {\n\t\tlist[i] = driver.NamedValue{\n\t\t\tOrdinal: i + 1,\n\t\t\tValue:   v,\n\t\t}\n\t}\n\treturn s.exec(context.Background(), list)\n}\n\nfunc isInterruptErr(err error) bool {\n\tsqliteErr, ok := err.(Error)\n\tif ok {\n\t\treturn sqliteErr.Code == ErrInterrupt\n\t}\n\treturn false\n}\n\n// exec executes a query that doesn't return rows. Attempts to honor context timeout.\nfunc (s *SQLiteStmt) exec(ctx context.Context, args []driver.NamedValue) (driver.Result, error) {\n\tif ctx.Done() == nil {\n\t\treturn s.execSync(args)\n\t}\n\n\ttype result struct {\n\t\tr   driver.Result\n\t\terr error\n\t}\n\tresultCh := make(chan result)\n\tdefer close(resultCh)\n\tgo func() {\n\t\tr, err := s.execSync(args)\n\t\tresultCh <- result{r, err}\n\t}()\n\tvar rv result\n\tselect {\n\tcase rv = <-resultCh:\n\tcase <-ctx.Done():\n\t\tselect {\n\t\tcase rv = <-resultCh: // no need to interrupt, operation completed in db\n\t\tdefault:\n\t\t\t// this is still racy and can be no-op if executed between sqlite3_* calls in execSync.\n\t\t\tC.sqlite3_interrupt(s.c.db)\n\t\t\trv = <-resultCh // wait for goroutine completed\n\t\t\tif isInterruptErr(rv.err) {\n\t\t\t\treturn nil, ctx.Err()\n\t\t\t}\n\t\t}\n\t}\n\treturn rv.r, rv.err\n}\n\nfunc (s *SQLiteStmt) execSync(args []driver.NamedValue) (driver.Result, error) {\n\tif err := s.bind(args); err != nil {\n\t\tC.sqlite3_reset(s.s)\n\t\tC.sqlite3_clear_bindings(s.s)\n\t\treturn nil, err\n\t}\n\n\tvar rowid, changes C.longlong\n\trv := C._sqlite3_step_row_internal(s.s, &rowid, &changes)\n\tif rv != C.SQLITE_ROW && rv != C.SQLITE_OK && rv != C.SQLITE_DONE {\n\t\terr := s.c.lastError()\n\t\tC.sqlite3_reset(s.s)\n\t\tC.sqlite3_clear_bindings(s.s)\n\t\treturn nil, err\n\t}\n\n\treturn &SQLiteResult{id: int64(rowid), changes: int64(changes)}, nil\n}\n\n// Readonly reports if this statement is considered readonly by SQLite.\n//\n// See: https://sqlite.org/c3ref/stmt_readonly.html\nfunc (s *SQLiteStmt) Readonly() bool {\n\treturn C.sqlite3_stmt_readonly(s.s) == 1\n}\n\n// Close the rows.\nfunc (rc *SQLiteRows) Close() error {\n\trc.closemu.Lock()\n\tdefer rc.closemu.Unlock()\n\ts := rc.s\n\tif s == nil {\n\t\treturn nil\n\t}\n\trc.s = nil // remove reference to SQLiteStmt\n\ts.mu.Lock()\n\tif s.closed {\n\t\ts.mu.Unlock()\n\t\treturn nil\n\t}\n\tif rc.cls {\n\t\ts.mu.Unlock()\n\t\treturn s.Close()\n\t}\n\trv := C.sqlite3_reset(s.s)\n\tif rv != C.SQLITE_OK {\n\t\ts.mu.Unlock()\n\t\treturn s.c.lastError()\n\t}\n\ts.mu.Unlock()\n\treturn nil\n}\n\n// Columns return column names.\nfunc (rc *SQLiteRows) Columns() []string {\n\trc.s.mu.Lock()\n\tdefer rc.s.mu.Unlock()\n\tif rc.s.s != nil && int(rc.nc) != len(rc.cols) {\n\t\trc.cols = make([]string, rc.nc)\n\t\tfor i := 0; i < int(rc.nc); i++ {\n\t\t\trc.cols[i] = C.GoString(C.sqlite3_column_name(rc.s.s, C.int(i)))\n\t\t}\n\t}\n\treturn rc.cols\n}\n\nfunc (rc *SQLiteRows) declTypes() []string {\n\tif rc.s.s != nil && rc.decltype == nil {\n\t\trc.decltype = make([]string, rc.nc)\n\t\tfor i := 0; i < int(rc.nc); i++ {\n\t\t\trc.decltype[i] = strings.ToLower(C.GoString(C.sqlite3_column_decltype(rc.s.s, C.int(i))))\n\t\t}\n\t}\n\treturn rc.decltype\n}\n\n// DeclTypes return column types.\nfunc (rc *SQLiteRows) DeclTypes() []string {\n\trc.s.mu.Lock()\n\tdefer rc.s.mu.Unlock()\n\treturn rc.declTypes()\n}\n\n// Next move cursor to next. Attempts to honor context timeout from QueryContext call.\nfunc (rc *SQLiteRows) Next(dest []driver.Value) error {\n\trc.s.mu.Lock()\n\tdefer rc.s.mu.Unlock()\n\n\tif rc.s.closed {\n\t\treturn io.EOF\n\t}\n\n\tif rc.ctx.Done() == nil {\n\t\treturn rc.nextSyncLocked(dest)\n\t}\n\tresultCh := make(chan error)\n\tdefer close(resultCh)\n\tgo func() {\n\t\tresultCh <- rc.nextSyncLocked(dest)\n\t}()\n\tselect {\n\tcase err := <-resultCh:\n\t\treturn err\n\tcase <-rc.ctx.Done():\n\t\tselect {\n\t\tcase <-resultCh: // no need to interrupt\n\t\tdefault:\n\t\t\t// this is still racy and can be no-op if executed between sqlite3_* calls in nextSyncLocked.\n\t\t\tC.sqlite3_interrupt(rc.s.c.db)\n\t\t\t<-resultCh // ensure goroutine completed\n\t\t}\n\t\treturn rc.ctx.Err()\n\t}\n}\n\n// nextSyncLocked moves cursor to next; must be called with locked mutex.\nfunc (rc *SQLiteRows) nextSyncLocked(dest []driver.Value) error {\n\trv := C._sqlite3_step_internal(rc.s.s)\n\tif rv == C.SQLITE_DONE {\n\t\treturn io.EOF\n\t}\n\tif rv != C.SQLITE_ROW {\n\t\trv = C.sqlite3_reset(rc.s.s)\n\t\tif rv != C.SQLITE_OK {\n\t\t\treturn rc.s.c.lastError()\n\t\t}\n\t\treturn nil\n\t}\n\n\trc.declTypes()\n\n\tfor i := range dest {\n\t\tswitch C.sqlite3_column_type(rc.s.s, C.int(i)) {\n\t\tcase C.SQLITE_INTEGER:\n\t\t\tval := int64(C.sqlite3_column_int64(rc.s.s, C.int(i)))\n\t\t\tswitch rc.decltype[i] {\n\t\t\tcase columnTimestamp, columnDatetime, columnDate:\n\t\t\t\tvar t time.Time\n\t\t\t\t// Assume a millisecond unix timestamp if it's 13 digits -- too\n\t\t\t\t// large to be a reasonable timestamp in seconds.\n\t\t\t\tif val > 1e12 || val < -1e12 {\n\t\t\t\t\tval *= int64(time.Millisecond) // convert ms to nsec\n\t\t\t\t\tt = time.Unix(0, val)\n\t\t\t\t} else {\n\t\t\t\t\tt = time.Unix(val, 0)\n\t\t\t\t}\n\t\t\t\tt = t.UTC()\n\t\t\t\tif rc.s.c.loc != nil {\n\t\t\t\t\tt = t.In(rc.s.c.loc)\n\t\t\t\t}\n\t\t\t\tdest[i] = t\n\t\t\tcase \"boolean\":\n\t\t\t\tdest[i] = val > 0\n\t\t\tdefault:\n\t\t\t\tdest[i] = val\n\t\t\t}\n\t\tcase C.SQLITE_FLOAT:\n\t\t\tdest[i] = float64(C.sqlite3_column_double(rc.s.s, C.int(i)))\n\t\tcase C.SQLITE_BLOB:\n\t\t\tp := C.sqlite3_column_blob(rc.s.s, C.int(i))\n\t\t\tif p == nil {\n\t\t\t\tdest[i] = []byte{}\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tn := C.sqlite3_column_bytes(rc.s.s, C.int(i))\n\t\t\tdest[i] = C.GoBytes(p, n)\n\t\tcase C.SQLITE_NULL:\n\t\t\tdest[i] = nil\n\t\tcase C.SQLITE_TEXT:\n\t\t\tvar err error\n\t\t\tvar timeVal time.Time\n\n\t\t\tn := int(C.sqlite3_column_bytes(rc.s.s, C.int(i)))\n\t\t\ts := C.GoStringN((*C.char)(unsafe.Pointer(C.sqlite3_column_text(rc.s.s, C.int(i)))), C.int(n))\n\n\t\t\tswitch rc.decltype[i] {\n\t\t\tcase columnTimestamp, columnDatetime, columnDate:\n\t\t\t\tvar t time.Time\n\t\t\t\ts = strings.TrimSuffix(s, \"Z\")\n\t\t\t\tfor _, format := range SQLiteTimestampFormats {\n\t\t\t\t\tif timeVal, err = time.ParseInLocation(format, s, time.UTC); err == nil {\n\t\t\t\t\t\tt = timeVal\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif err != nil {\n\t\t\t\t\t// The column is a time value, so return the zero time on parse failure.\n\t\t\t\t\tt = time.Time{}\n\t\t\t\t}\n\t\t\t\tif rc.s.c.loc != nil {\n\t\t\t\t\tt = t.In(rc.s.c.loc)\n\t\t\t\t}\n\t\t\t\tdest[i] = t\n\t\t\tdefault:\n\t\t\t\tdest[i] = s\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "sqlite3_context.go",
          "type": "blob",
          "size": 2.9541015625,
          "content": "// Copyright (C) 2019 Yasuhiro Matsumoto <mattn.jp@gmail.com>.\n//\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\npackage sqlite3\n\n/*\n\n#ifndef USE_LIBSQLITE3\n#include \"sqlite3-binding.h\"\n#else\n#include <sqlite3.h>\n#endif\n#include <stdlib.h>\n// These wrappers are necessary because SQLITE_TRANSIENT\n// is a pointer constant, and cgo doesn't translate them correctly.\n\nstatic inline void my_result_text(sqlite3_context *ctx, char *p, int np) {\n\tsqlite3_result_text(ctx, p, np, SQLITE_TRANSIENT);\n}\n\nstatic inline void my_result_blob(sqlite3_context *ctx, void *p, int np) {\n\tsqlite3_result_blob(ctx, p, np, SQLITE_TRANSIENT);\n}\n*/\nimport \"C\"\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"unsafe\"\n)\n\nconst i64 = unsafe.Sizeof(int(0)) > 4\n\n// SQLiteContext behave sqlite3_context\ntype SQLiteContext C.sqlite3_context\n\n// ResultBool sets the result of an SQL function.\nfunc (c *SQLiteContext) ResultBool(b bool) {\n\tif b {\n\t\tc.ResultInt(1)\n\t} else {\n\t\tc.ResultInt(0)\n\t}\n}\n\n// ResultBlob sets the result of an SQL function.\n// See: sqlite3_result_blob, http://sqlite.org/c3ref/result_blob.html\nfunc (c *SQLiteContext) ResultBlob(b []byte) {\n\tif i64 && len(b) > math.MaxInt32 {\n\t\tC.sqlite3_result_error_toobig((*C.sqlite3_context)(c))\n\t\treturn\n\t}\n\tvar p *byte\n\tif len(b) > 0 {\n\t\tp = &b[0]\n\t}\n\tC.my_result_blob((*C.sqlite3_context)(c), unsafe.Pointer(p), C.int(len(b)))\n}\n\n// ResultDouble sets the result of an SQL function.\n// See: sqlite3_result_double, http://sqlite.org/c3ref/result_blob.html\nfunc (c *SQLiteContext) ResultDouble(d float64) {\n\tC.sqlite3_result_double((*C.sqlite3_context)(c), C.double(d))\n}\n\n// ResultInt sets the result of an SQL function.\n// See: sqlite3_result_int, http://sqlite.org/c3ref/result_blob.html\nfunc (c *SQLiteContext) ResultInt(i int) {\n\tif i64 && (i > math.MaxInt32 || i < math.MinInt32) {\n\t\tC.sqlite3_result_int64((*C.sqlite3_context)(c), C.sqlite3_int64(i))\n\t} else {\n\t\tC.sqlite3_result_int((*C.sqlite3_context)(c), C.int(i))\n\t}\n}\n\n// ResultInt64 sets the result of an SQL function.\n// See: sqlite3_result_int64, http://sqlite.org/c3ref/result_blob.html\nfunc (c *SQLiteContext) ResultInt64(i int64) {\n\tC.sqlite3_result_int64((*C.sqlite3_context)(c), C.sqlite3_int64(i))\n}\n\n// ResultNull sets the result of an SQL function.\n// See: sqlite3_result_null, http://sqlite.org/c3ref/result_blob.html\nfunc (c *SQLiteContext) ResultNull() {\n\tC.sqlite3_result_null((*C.sqlite3_context)(c))\n}\n\n// ResultText sets the result of an SQL function.\n// See: sqlite3_result_text, http://sqlite.org/c3ref/result_blob.html\nfunc (c *SQLiteContext) ResultText(s string) {\n\th := (*reflect.StringHeader)(unsafe.Pointer(&s))\n\tcs, l := (*C.char)(unsafe.Pointer(h.Data)), C.int(h.Len)\n\tC.my_result_text((*C.sqlite3_context)(c), cs, l)\n}\n\n// ResultZeroblob sets the result of an SQL function.\n// See: sqlite3_result_zeroblob, http://sqlite.org/c3ref/result_blob.html\nfunc (c *SQLiteContext) ResultZeroblob(n int) {\n\tC.sqlite3_result_zeroblob((*C.sqlite3_context)(c), C.int(n))\n}\n"
        },
        {
          "name": "sqlite3_func_crypt.go",
          "type": "blob",
          "size": 3.8837890625,
          "content": "// Copyright (C) 2018 G.J.R. Timmer <gjr.timmer@gmail.com>.\n//\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\npackage sqlite3\n\nimport (\n\t\"crypto/sha1\"\n\t\"crypto/sha256\"\n\t\"crypto/sha512\"\n)\n\n// This file provides several different implementations for the\n// default embedded sqlite_crypt function.\n// This function is uses a caesar-cypher by default\n// and is used within the UserAuthentication module to encode\n// the password.\n//\n// The provided functions can be used as an overload to the sqlite_crypt\n// function through the use of the RegisterFunc on the connection.\n//\n// Because the functions can serv a purpose to an end-user\n// without using the UserAuthentication module\n// the functions are default compiled in.\n//\n// From SQLITE3 - user-auth.txt\n// The sqlite_user.pw field is encoded by a built-in SQL function\n// \"sqlite_crypt(X,Y)\".  The two arguments are both BLOBs.  The first argument\n// is the plaintext password supplied to the sqlite3_user_authenticate()\n// interface.  The second argument is the sqlite_user.pw value and is supplied\n// so that the function can extract the \"salt\" used by the password encoder.\n// The result of sqlite_crypt(X,Y) is another blob which is the value that\n// ends up being stored in sqlite_user.pw.  To verify credentials X supplied\n// by the sqlite3_user_authenticate() routine, SQLite runs:\n//\n//     sqlite_user.pw == sqlite_crypt(X, sqlite_user.pw)\n//\n// To compute an appropriate sqlite_user.pw value from a new or modified\n// password X, sqlite_crypt(X,NULL) is run.  A new random salt is selected\n// when the second argument is NULL.\n//\n// The built-in version of of sqlite_crypt() uses a simple Caesar-cypher\n// which prevents passwords from being revealed by searching the raw database\n// for ASCII text, but is otherwise trivally broken.  For better password\n// security, the database should be encrypted using the SQLite Encryption\n// Extension or similar technology.  Or, the application can use the\n// sqlite3_create_function() interface to provide an alternative\n// implementation of sqlite_crypt() that computes a stronger password hash,\n// perhaps using a cryptographic hash function like SHA1.\n\n// CryptEncoderSHA1 encodes a password with SHA1\nfunc CryptEncoderSHA1(pass []byte, hash any) []byte {\n\th := sha1.Sum(pass)\n\treturn h[:]\n}\n\n// CryptEncoderSSHA1 encodes a password with SHA1 with the\n// configured salt.\nfunc CryptEncoderSSHA1(salt string) func(pass []byte, hash any) []byte {\n\treturn func(pass []byte, hash any) []byte {\n\t\ts := []byte(salt)\n\t\tp := append(pass, s...)\n\t\th := sha1.Sum(p)\n\t\treturn h[:]\n\t}\n}\n\n// CryptEncoderSHA256 encodes a password with SHA256\nfunc CryptEncoderSHA256(pass []byte, hash any) []byte {\n\th := sha256.Sum256(pass)\n\treturn h[:]\n}\n\n// CryptEncoderSSHA256 encodes a password with SHA256\n// with the configured salt\nfunc CryptEncoderSSHA256(salt string) func(pass []byte, hash any) []byte {\n\treturn func(pass []byte, hash any) []byte {\n\t\ts := []byte(salt)\n\t\tp := append(pass, s...)\n\t\th := sha256.Sum256(p)\n\t\treturn h[:]\n\t}\n}\n\n// CryptEncoderSHA384 encodes a password with SHA384\nfunc CryptEncoderSHA384(pass []byte, hash any) []byte {\n\th := sha512.Sum384(pass)\n\treturn h[:]\n}\n\n// CryptEncoderSSHA384 encodes a password with SHA384\n// with the configured salt\nfunc CryptEncoderSSHA384(salt string) func(pass []byte, hash any) []byte {\n\treturn func(pass []byte, hash any) []byte {\n\t\ts := []byte(salt)\n\t\tp := append(pass, s...)\n\t\th := sha512.Sum384(p)\n\t\treturn h[:]\n\t}\n}\n\n// CryptEncoderSHA512 encodes a password with SHA512\nfunc CryptEncoderSHA512(pass []byte, hash any) []byte {\n\th := sha512.Sum512(pass)\n\treturn h[:]\n}\n\n// CryptEncoderSSHA512 encodes a password with SHA512\n// with the configured salt\nfunc CryptEncoderSSHA512(salt string) func(pass []byte, hash any) []byte {\n\treturn func(pass []byte, hash any) []byte {\n\t\ts := []byte(salt)\n\t\tp := append(pass, s...)\n\t\th := sha512.Sum512(p)\n\t\treturn h[:]\n\t}\n}\n\n// EOF\n"
        },
        {
          "name": "sqlite3_func_crypt_test.go",
          "type": "blob",
          "size": 1.8671875,
          "content": "// Copyright (C) 2018 G.J.R. Timmer <gjr.timmer@gmail.com>.\n//\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\npackage sqlite3\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"testing\"\n)\n\n// TestCryptEncoders to increase coverage\nfunc TestCryptEncoders(t *testing.T) {\n\ttests := []struct {\n\t\tenc      string\n\t\tsalt     string\n\t\texpected string\n\t}{\n\t\t{\"sha1\", \"\", \"d033e22ae348aeb5660fc2140aec35850c4da997\"},\n\t\t{\"sha256\", \"\", \"8c6976e5b5410415bde908bd4dee15dfb167a9c873fc4bb8a81f6f2ab448a918\"},\n\t\t{\"sha384\", \"\", \"9ca694a90285c034432c9550421b7b9dbd5c0f4b6673f05f6dbce58052ba20e4248041956ee8c9a2ec9f10290cdc0782\"},\n\t\t{\"sha512\", \"\", \"c7ad44cbad762a5da0a452f9e854fdc1e0e7a52a38015f23f3eab1d80b931dd472634dfac71cd34ebc35d16ab7fb8a90c81f975113d6c7538dc69dd8de9077ec\"},\n\t\t{\"ssha1\", \"salt\", \"9bc7aa55f08fdad935c3f8362d3f48bcf70eb280\"},\n\t\t{\"ssha256\", \"salt\", \"f9a81477552594c79f2abc3fc099daa896a6e3a3590a55ffa392b6000412e80b\"},\n\t\t{\"ssha384\", \"salt\", \"9ed776b477fcfc1b5e584989e8d770f5e17d98a7643546a63c2b07d4ab00f1348f6b8e73103d3a23554f727136e8c215\"},\n\t\t{\"ssha512\", \"salt\", \"3c4a79782143337be4492be072abcfe979dd703c00541a8c39a0f3df4bab2029c050cf46fddc47090b5b04ac537b3e78189e3de16e601e859f95c51ac9f6dafb\"},\n\t}\n\n\tfor _, e := range tests {\n\t\tvar fn func(pass []byte, hash any) []byte\n\t\tswitch e.enc {\n\t\tcase \"sha1\":\n\t\t\tfn = CryptEncoderSHA1\n\t\tcase \"ssha1\":\n\t\t\tfn = CryptEncoderSSHA1(e.salt)\n\t\tcase \"sha256\":\n\t\t\tfn = CryptEncoderSHA256\n\t\tcase \"ssha256\":\n\t\t\tfn = CryptEncoderSSHA256(e.salt)\n\t\tcase \"sha384\":\n\t\t\tfn = CryptEncoderSHA384\n\t\tcase \"ssha384\":\n\t\t\tfn = CryptEncoderSSHA384(e.salt)\n\t\tcase \"sha512\":\n\t\t\tfn = CryptEncoderSHA512\n\t\tcase \"ssha512\":\n\t\t\tfn = CryptEncoderSSHA512(e.salt)\n\t\t}\n\n\t\th := fn([]byte(\"admin\"), nil)\n\t\tif strings.Compare(fmt.Sprintf(\"%x\", h), e.expected) != 0 {\n\t\t\tt.Fatalf(\"Invalid %s hash: expected: %s; got: %x\", strings.ToUpper(e.enc), e.expected, h)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "sqlite3_go113_test.go",
          "type": "blob",
          "size": 2.4599609375,
          "content": "// Copyright (C) 2019 Yasuhiro Matsumoto <mattn.jp@gmail.com>.\n//\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n//go:build go1.13 && cgo\n// +build go1.13,cgo\n\npackage sqlite3\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"database/sql/driver\"\n\t\"errors\"\n\t\"os\"\n\t\"testing\"\n)\n\nfunc TestBeginTxCancel(t *testing.T) {\n\tsrcTempFilename := TempFilename(t)\n\tdefer os.Remove(srcTempFilename)\n\n\tdb, err := sql.Open(\"sqlite3\", srcTempFilename)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tdb.SetMaxOpenConns(10)\n\tdb.SetMaxIdleConns(5)\n\n\tdefer db.Close()\n\tinitDatabase(t, db, 100)\n\n\t// create several go-routines to expose racy issue\n\tfor i := 0; i < 1000; i++ {\n\t\tfunc() {\n\t\t\tctx, cancel := context.WithCancel(context.Background())\n\t\t\tconn, err := db.Conn(ctx)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tdefer func() {\n\t\t\t\tif err := conn.Close(); err != nil {\n\t\t\t\t\tt.Error(err)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\terr = conn.Raw(func(driverConn any) error {\n\t\t\t\td, ok := driverConn.(driver.ConnBeginTx)\n\t\t\t\tif !ok {\n\t\t\t\t\tt.Fatal(\"unexpected: wrong type\")\n\t\t\t\t}\n\t\t\t\t// checks that conn.Raw can be used to get *SQLiteConn\n\t\t\t\tif _, ok = driverConn.(*SQLiteConn); !ok {\n\t\t\t\t\tt.Fatalf(\"conn.Raw() driverConn type=%T, expected *SQLiteConn\", driverConn)\n\t\t\t\t}\n\n\t\t\t\tgo cancel() // make it cancel concurrently with exec(\"BEGIN\");\n\t\t\t\ttx, err := d.BeginTx(ctx, driver.TxOptions{})\n\t\t\t\tswitch err {\n\t\t\t\tcase nil:\n\t\t\t\t\tswitch err := tx.Rollback(); err {\n\t\t\t\t\tcase nil, sql.ErrTxDone:\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\tcase context.Canceled:\n\t\t\t\tdefault:\n\t\t\t\t\t// must not fail with \"cannot start a transaction within a transaction\"\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t}()\n\t}\n}\n\nfunc TestStmtReadonly(t *testing.T) {\n\tdb, err := sql.Open(\"sqlite3\", \":memory:\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, err = db.Exec(\"CREATE TABLE t (count INT)\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tisRO := func(query string) bool {\n\t\tc, err := db.Conn(context.Background())\n\t\tif err != nil {\n\t\t\treturn false\n\t\t}\n\n\t\tvar ro bool\n\t\tc.Raw(func(dc any) error {\n\t\t\tstmt, err := dc.(*SQLiteConn).Prepare(query)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif stmt == nil {\n\t\t\t\treturn errors.New(\"stmt is nil\")\n\t\t\t}\n\t\t\tro = stmt.(*SQLiteStmt).Readonly()\n\t\t\treturn nil\n\t\t})\n\t\treturn ro // On errors ro will remain false.\n\t}\n\n\tif !isRO(`select * from t`) {\n\t\tt.Error(\"select not seen as read-only\")\n\t}\n\tif isRO(`insert into t values (1), (2)`) {\n\t\tt.Error(\"insert seen as read-only\")\n\t}\n}\n"
        },
        {
          "name": "sqlite3_go18.go",
          "type": "blob",
          "size": 1.5107421875,
          "content": "// Copyright (C) 2019 Yasuhiro Matsumoto <mattn.jp@gmail.com>.\n//\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n//go:build cgo && go1.8\n// +build cgo,go1.8\n\npackage sqlite3\n\nimport (\n\t\"database/sql/driver\"\n\n\t\"context\"\n)\n\n// Ping implement Pinger.\nfunc (c *SQLiteConn) Ping(ctx context.Context) error {\n\tif c.db == nil {\n\t\t// must be ErrBadConn for sql to close the database\n\t\treturn driver.ErrBadConn\n\t}\n\treturn nil\n}\n\n// QueryContext implement QueryerContext.\nfunc (c *SQLiteConn) QueryContext(ctx context.Context, query string, args []driver.NamedValue) (driver.Rows, error) {\n\treturn c.query(ctx, query, args)\n}\n\n// ExecContext implement ExecerContext.\nfunc (c *SQLiteConn) ExecContext(ctx context.Context, query string, args []driver.NamedValue) (driver.Result, error) {\n\treturn c.exec(ctx, query, args)\n}\n\n// PrepareContext implement ConnPrepareContext.\nfunc (c *SQLiteConn) PrepareContext(ctx context.Context, query string) (driver.Stmt, error) {\n\treturn c.prepare(ctx, query)\n}\n\n// BeginTx implement ConnBeginTx.\nfunc (c *SQLiteConn) BeginTx(ctx context.Context, opts driver.TxOptions) (driver.Tx, error) {\n\treturn c.begin(ctx)\n}\n\n// QueryContext implement QueryerContext.\nfunc (s *SQLiteStmt) QueryContext(ctx context.Context, args []driver.NamedValue) (driver.Rows, error) {\n\treturn s.query(ctx, args)\n}\n\n// ExecContext implement ExecerContext.\nfunc (s *SQLiteStmt) ExecContext(ctx context.Context, args []driver.NamedValue) (driver.Result, error) {\n\treturn s.exec(ctx, args)\n}\n"
        },
        {
          "name": "sqlite3_go18_test.go",
          "type": "blob",
          "size": 11.658203125,
          "content": "// Copyright (C) 2019 Yasuhiro Matsumoto <mattn.jp@gmail.com>.\n//\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n//go:build go1.8 && cgo\n// +build go1.8,cgo\n\npackage sqlite3\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"math/rand\"\n\t\"os\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestNamedParams(t *testing.T) {\n\ttempFilename := TempFilename(t)\n\tdefer os.Remove(tempFilename)\n\tdb, err := sql.Open(\"sqlite3\", tempFilename)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to open database:\", err)\n\t}\n\tdefer db.Close()\n\n\t_, err = db.Exec(`\n\tcreate table foo (id integer, name text, extra text);\n\t`)\n\tif err != nil {\n\t\tt.Error(\"Failed to call db.Query:\", err)\n\t}\n\n\t_, err = db.Exec(`insert into foo(id, name, extra) values(:id, :name, :name)`, sql.Named(\"name\", \"foo\"), sql.Named(\"id\", 1))\n\tif err != nil {\n\t\tt.Error(\"Failed to call db.Exec:\", err)\n\t}\n\n\trow := db.QueryRow(`select id, extra from foo where id = :id and extra = :extra`, sql.Named(\"id\", 1), sql.Named(\"extra\", \"foo\"))\n\tif row == nil {\n\t\tt.Error(\"Failed to call db.QueryRow\")\n\t}\n\tvar id int\n\tvar extra string\n\terr = row.Scan(&id, &extra)\n\tif err != nil {\n\t\tt.Error(\"Failed to db.Scan:\", err)\n\t}\n\tif id != 1 || extra != \"foo\" {\n\t\tt.Error(\"Failed to db.QueryRow: not matched results\")\n\t}\n}\n\nvar (\n\ttestTableStatements = []string{\n\t\t`DROP TABLE IF EXISTS test_table`,\n\t\t`\nCREATE TABLE IF NOT EXISTS test_table (\n\tkey1      VARCHAR(64) PRIMARY KEY,\n\tkey_id    VARCHAR(64) NOT NULL,\n\tkey2      VARCHAR(64) NOT NULL,\n\tkey3      VARCHAR(64) NOT NULL,\n\tkey4      VARCHAR(64) NOT NULL,\n\tkey5      VARCHAR(64) NOT NULL,\n\tkey6      VARCHAR(64) NOT NULL,\n\tdata      BLOB        NOT NULL\n);`,\n\t}\n\tletterBytes = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n)\n\nfunc randStringBytes(n int) string {\n\tb := make([]byte, n)\n\tfor i := range b {\n\t\tb[i] = letterBytes[rand.Intn(len(letterBytes))]\n\t}\n\treturn string(b)\n}\n\nfunc initDatabase(t *testing.T, db *sql.DB, rowCount int64) {\n\tfor _, query := range testTableStatements {\n\t\t_, err := db.Exec(query)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\tfor i := int64(0); i < rowCount; i++ {\n\t\tquery := `INSERT INTO test_table\n\t\t\t(key1, key_id, key2, key3, key4, key5, key6, data)\n\t\t\tVALUES\n\t\t\t(?, ?, ?, ?, ?, ?, ?, ?);`\n\t\targs := []interface{}{\n\t\t\trandStringBytes(50),\n\t\t\tfmt.Sprint(i),\n\t\t\trandStringBytes(50),\n\t\t\trandStringBytes(50),\n\t\t\trandStringBytes(50),\n\t\t\trandStringBytes(50),\n\t\t\trandStringBytes(50),\n\t\t\trandStringBytes(50),\n\t\t\trandStringBytes(2048),\n\t\t}\n\t\t_, err := db.Exec(query, args...)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n}\n\nfunc TestShortTimeout(t *testing.T) {\n\tsrcTempFilename := TempFilename(t)\n\tdefer os.Remove(srcTempFilename)\n\n\tdb, err := sql.Open(\"sqlite3\", srcTempFilename)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\tinitDatabase(t, db, 100)\n\n\tctx, cancel := context.WithTimeout(context.Background(), 1*time.Microsecond)\n\tdefer cancel()\n\tquery := `SELECT key1, key_id, key2, key3, key4, key5, key6, data\n\t\tFROM test_table\n\t\tORDER BY key2 ASC`\n\t_, err = db.QueryContext(ctx, query)\n\tif err != nil && err != context.DeadlineExceeded {\n\t\tt.Fatal(err)\n\t}\n\tif ctx.Err() != nil && ctx.Err() != context.DeadlineExceeded {\n\t\tt.Fatal(ctx.Err())\n\t}\n}\n\nfunc TestExecContextCancel(t *testing.T) {\n\tsrcTempFilename := TempFilename(t)\n\tdefer os.Remove(srcTempFilename)\n\n\tdb, err := sql.Open(\"sqlite3\", srcTempFilename)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tdefer db.Close()\n\n\tts := time.Now()\n\tinitDatabase(t, db, 1000)\n\tspent := time.Since(ts)\n\tconst minTestTime = 100 * time.Millisecond\n\tif spent < minTestTime {\n\t\tt.Skipf(\"test will be too racy (spent=%s < min=%s) as ExecContext below will be too fast.\",\n\t\t\tspent.String(), minTestTime.String(),\n\t\t)\n\t}\n\n\t// expected to be extremely slow query\n\tq := `\nINSERT INTO test_table (key1, key_id, key2, key3, key4, key5, key6, data)\nSELECT t1.key1 || t2.key1, t1.key_id || t2.key_id, t1.key2 || t2.key2, t1.key3 || t2.key3, t1.key4 || t2.key4, t1.key5 || t2.key5, t1.key6 || t2.key6, t1.data || t2.data\nFROM test_table t1 LEFT OUTER JOIN test_table t2`\n\t// expect query above take ~ same time as setup above\n\t// This is racy: the context must be valid so sql/db.ExecContext calls the sqlite3 driver.\n\t// It starts the query, the context expires, then calls sqlite3_interrupt\n\tctx, cancel := context.WithTimeout(context.Background(), minTestTime/2)\n\tdefer cancel()\n\tts = time.Now()\n\tr, err := db.ExecContext(ctx, q)\n\t// racy check\n\tif r != nil {\n\t\tn, err := r.RowsAffected()\n\t\tt.Logf(\"query should not have succeeded: rows=%d; err=%v; duration=%s\",\n\t\t\tn, err, time.Since(ts).String())\n\t}\n\tif err != context.DeadlineExceeded {\n\t\tt.Fatal(err, ctx.Err())\n\t}\n}\n\nfunc TestQueryRowContextCancel(t *testing.T) {\n\tsrcTempFilename := TempFilename(t)\n\tdefer os.Remove(srcTempFilename)\n\n\tdb, err := sql.Open(\"sqlite3\", srcTempFilename)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\tinitDatabase(t, db, 100)\n\n\tconst query = `SELECT key_id FROM test_table ORDER BY key2 ASC`\n\tvar keyID string\n\tunexpectedErrors := make(map[string]int)\n\tfor i := 0; i < 10000; i++ {\n\t\tctx, cancel := context.WithCancel(context.Background())\n\t\trow := db.QueryRowContext(ctx, query)\n\n\t\tcancel()\n\t\t// it is fine to get \"nil\" as context cancellation can be handled with delay\n\t\tif err := row.Scan(&keyID); err != nil && err != context.Canceled {\n\t\t\tif err.Error() == \"sql: Rows are closed\" {\n\t\t\t\t// see https://github.com/golang/go/issues/24431\n\t\t\t\t// fixed in 1.11.1 to properly return context error\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tunexpectedErrors[err.Error()]++\n\t\t}\n\t}\n\tfor errText, count := range unexpectedErrors {\n\t\tt.Error(errText, count)\n\t}\n}\n\nfunc TestQueryRowContextCancelParallel(t *testing.T) {\n\tsrcTempFilename := TempFilename(t)\n\tdefer os.Remove(srcTempFilename)\n\n\tdb, err := sql.Open(\"sqlite3\", srcTempFilename)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdb.SetMaxOpenConns(10)\n\tdb.SetMaxIdleConns(5)\n\n\tdefer db.Close()\n\tinitDatabase(t, db, 100)\n\n\tconst query = `SELECT key_id FROM test_table ORDER BY key2 ASC`\n\twg := sync.WaitGroup{}\n\tdefer wg.Wait()\n\n\ttestCtx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\tfor i := 0; i < 10; i++ {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\n\t\t\tvar keyID string\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase <-testCtx.Done():\n\t\t\t\t\treturn\n\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\t\tctx, cancel := context.WithCancel(context.Background())\n\t\t\t\trow := db.QueryRowContext(ctx, query)\n\n\t\t\t\tcancel()\n\t\t\t\t_ = row.Scan(&keyID) // see TestQueryRowContextCancel\n\t\t\t}\n\t\t}()\n\t}\n\n\tvar keyID string\n\tfor i := 0; i < 10000; i++ {\n\t\t// note that testCtx is not cancelled during query execution\n\t\trow := db.QueryRowContext(testCtx, query)\n\n\t\tif err := row.Scan(&keyID); err != nil {\n\t\t\tt.Fatal(i, err)\n\t\t}\n\t}\n}\n\nfunc TestExecCancel(t *testing.T) {\n\tdb, err := sql.Open(\"sqlite3\", \":memory:\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\tif _, err = db.Exec(\"create table foo (id integer primary key)\"); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfor n := 0; n < 100; n++ {\n\t\tctx, cancel := context.WithCancel(context.Background())\n\t\t_, err = db.ExecContext(ctx, \"insert into foo (id) values (?)\", n)\n\t\tcancel()\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n}\n\nfunc doTestOpenContext(t *testing.T, option string) (string, error) {\n\ttempFilename := TempFilename(t)\n\turl := tempFilename + option\n\n\tdefer func() {\n\t\terr := os.Remove(tempFilename)\n\t\tif err != nil {\n\t\t\tt.Error(\"temp file remove error:\", err)\n\t\t}\n\t}()\n\n\tdb, err := sql.Open(\"sqlite3\", url)\n\tif err != nil {\n\t\treturn \"Failed to open database:\", err\n\t}\n\n\tdefer func() {\n\t\terr = db.Close()\n\t\tif err != nil {\n\t\t\tt.Error(\"db close error:\", err)\n\t\t}\n\t}()\n\n\tctx, cancel := context.WithTimeout(context.Background(), 55*time.Second)\n\terr = db.PingContext(ctx)\n\tcancel()\n\tif err != nil {\n\t\treturn \"ping error:\", err\n\t}\n\n\tctx, cancel = context.WithTimeout(context.Background(), 55*time.Second)\n\t_, err = db.ExecContext(ctx, \"drop table foo\")\n\tcancel()\n\tctx, cancel = context.WithTimeout(context.Background(), 55*time.Second)\n\t_, err = db.ExecContext(ctx, \"create table foo (id integer)\")\n\tcancel()\n\tif err != nil {\n\t\treturn \"Failed to create table:\", err\n\t}\n\n\tif stat, err := os.Stat(tempFilename); err != nil || stat.IsDir() {\n\t\treturn \"Failed to create ./foo.db\", nil\n\t}\n\n\treturn \"\", nil\n}\n\nfunc TestOpenContext(t *testing.T) {\n\tcases := map[string]bool{\n\t\t\"\":                   true,\n\t\t\"?_txlock=immediate\": true,\n\t\t\"?_txlock=deferred\":  true,\n\t\t\"?_txlock=exclusive\": true,\n\t\t\"?_txlock=bogus\":     false,\n\t}\n\tfor option, expectedPass := range cases {\n\t\tresult, err := doTestOpenContext(t, option)\n\t\tif result == \"\" {\n\t\t\tif !expectedPass {\n\t\t\t\terrmsg := fmt.Sprintf(\"_txlock error not caught at dbOpen with option: %s\", option)\n\t\t\t\tt.Fatal(errmsg)\n\t\t\t}\n\t\t} else if expectedPass {\n\t\t\tif err == nil {\n\t\t\t\tt.Fatal(result)\n\t\t\t} else {\n\t\t\t\tt.Fatal(result, err)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestFileCopyTruncate(t *testing.T) {\n\tvar err error\n\ttempFilename := TempFilename(t)\n\n\tdefer func() {\n\t\terr = os.Remove(tempFilename)\n\t\tif err != nil {\n\t\t\tt.Error(\"temp file remove error:\", err)\n\t\t}\n\t}()\n\n\tdb, err := sql.Open(\"sqlite3\", tempFilename)\n\tif err != nil {\n\t\tt.Fatal(\"open error:\", err)\n\t}\n\n\tdefer func() {\n\t\terr = db.Close()\n\t\tif err != nil {\n\t\t\tt.Error(\"db close error:\", err)\n\t\t}\n\t}()\n\n\tctx, cancel := context.WithTimeout(context.Background(), 55*time.Second)\n\terr = db.PingContext(ctx)\n\tcancel()\n\tif err != nil {\n\t\tt.Fatal(\"ping error:\", err)\n\t}\n\n\tctx, cancel = context.WithTimeout(context.Background(), 55*time.Second)\n\t_, err = db.ExecContext(ctx, \"drop table foo\")\n\tcancel()\n\tctx, cancel = context.WithTimeout(context.Background(), 55*time.Second)\n\t_, err = db.ExecContext(ctx, \"create table foo (id integer)\")\n\tcancel()\n\tif err != nil {\n\t\tt.Fatal(\"create table error:\", err)\n\t}\n\n\t// copy db to new file\n\tvar data []byte\n\tdata, err = ioutil.ReadFile(tempFilename)\n\tif err != nil {\n\t\tt.Fatal(\"read file error:\", err)\n\t}\n\n\tvar f *os.File\n\tf, err = os.Create(tempFilename + \"-db-copy\")\n\tif err != nil {\n\t\tt.Fatal(\"create file error:\", err)\n\t}\n\n\tdefer func() {\n\t\terr = os.Remove(tempFilename + \"-db-copy\")\n\t\tif err != nil {\n\t\t\tt.Error(\"temp file moved remove error:\", err)\n\t\t}\n\t}()\n\n\t_, err = f.Write(data)\n\tif err != nil {\n\t\tf.Close()\n\t\tt.Fatal(\"write file error:\", err)\n\t}\n\terr = f.Close()\n\tif err != nil {\n\t\tt.Fatal(\"close file error:\", err)\n\t}\n\n\t// truncate current db file\n\tf, err = os.OpenFile(tempFilename, os.O_WRONLY|os.O_TRUNC, 0666)\n\tif err != nil {\n\t\tt.Fatal(\"open file error:\", err)\n\t}\n\terr = f.Close()\n\tif err != nil {\n\t\tt.Fatal(\"close file error:\", err)\n\t}\n\n\t// test db after file truncate\n\tctx, cancel = context.WithTimeout(context.Background(), 55*time.Second)\n\terr = db.PingContext(ctx)\n\tcancel()\n\tif err != nil {\n\t\tt.Fatal(\"ping error:\", err)\n\t}\n\n\tctx, cancel = context.WithTimeout(context.Background(), 55*time.Second)\n\t_, err = db.ExecContext(ctx, \"drop table foo\")\n\tcancel()\n\tif err == nil {\n\t\tt.Fatal(\"drop table no error\")\n\t}\n\n\tctx, cancel = context.WithTimeout(context.Background(), 55*time.Second)\n\t_, err = db.ExecContext(ctx, \"create table foo (id integer)\")\n\tcancel()\n\tif err != nil {\n\t\tt.Fatal(\"create table error:\", err)\n\t}\n\n\terr = db.Close()\n\tif err != nil {\n\t\tt.Error(\"db close error:\", err)\n\t}\n\n\t// test copied file\n\tdb, err = sql.Open(\"sqlite3\", tempFilename+\"-db-copy\")\n\tif err != nil {\n\t\tt.Fatal(\"open error:\", err)\n\t}\n\n\tdefer func() {\n\t\terr = db.Close()\n\t\tif err != nil {\n\t\t\tt.Error(\"db close error:\", err)\n\t\t}\n\t}()\n\n\tctx, cancel = context.WithTimeout(context.Background(), 55*time.Second)\n\terr = db.PingContext(ctx)\n\tcancel()\n\tif err != nil {\n\t\tt.Fatal(\"ping error:\", err)\n\t}\n\n\tctx, cancel = context.WithTimeout(context.Background(), 55*time.Second)\n\t_, err = db.ExecContext(ctx, \"drop table foo\")\n\tcancel()\n\tif err != nil {\n\t\tt.Fatal(\"drop table error:\", err)\n\t}\n\n\tctx, cancel = context.WithTimeout(context.Background(), 55*time.Second)\n\t_, err = db.ExecContext(ctx, \"create table foo (id integer)\")\n\tcancel()\n\tif err != nil {\n\t\tt.Fatal(\"create table error:\", err)\n\t}\n}\n"
        },
        {
          "name": "sqlite3_libsqlite3.go",
          "type": "blob",
          "size": 0.671875,
          "content": "// Copyright (C) 2019 Yasuhiro Matsumoto <mattn.jp@gmail.com>.\n//\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n//go:build libsqlite3\n// +build libsqlite3\n\npackage sqlite3\n\n/*\n#cgo CFLAGS: -DUSE_LIBSQLITE3\n#cgo linux LDFLAGS: -lsqlite3\n#cgo darwin,amd64 LDFLAGS: -L/usr/local/opt/sqlite/lib -lsqlite3\n#cgo darwin,amd64 CFLAGS:  -I/usr/local/opt/sqlite/include\n#cgo darwin,arm64 LDFLAGS: -L/opt/homebrew/opt/sqlite/lib -lsqlite3\n#cgo darwin,arm64 CFLAGS:  -I/opt/homebrew/opt/sqlite/include\n#cgo openbsd LDFLAGS: -lsqlite3\n#cgo solaris LDFLAGS: -lsqlite3\n#cgo windows LDFLAGS: -lsqlite3\n#cgo zos LDFLAGS: -lsqlite3\n*/\nimport \"C\"\n"
        },
        {
          "name": "sqlite3_load_extension.go",
          "type": "blob",
          "size": 1.8427734375,
          "content": "// Copyright (C) 2019 Yasuhiro Matsumoto <mattn.jp@gmail.com>.\n//\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n//go:build !sqlite_omit_load_extension\n// +build !sqlite_omit_load_extension\n\npackage sqlite3\n\n/*\n#ifndef USE_LIBSQLITE3\n#include \"sqlite3-binding.h\"\n#else\n#include <sqlite3.h>\n#endif\n#include <stdlib.h>\n*/\nimport \"C\"\nimport (\n\t\"errors\"\n\t\"unsafe\"\n)\n\nfunc (c *SQLiteConn) loadExtensions(extensions []string) error {\n\trv := C.sqlite3_enable_load_extension(c.db, 1)\n\tif rv != C.SQLITE_OK {\n\t\treturn errors.New(C.GoString(C.sqlite3_errmsg(c.db)))\n\t}\n\n\tfor _, extension := range extensions {\n\t\tif err := c.loadExtension(extension, nil); err != nil {\n\t\t\tC.sqlite3_enable_load_extension(c.db, 0)\n\t\t\treturn err\n\t\t}\n\t}\n\n\trv = C.sqlite3_enable_load_extension(c.db, 0)\n\tif rv != C.SQLITE_OK {\n\t\treturn errors.New(C.GoString(C.sqlite3_errmsg(c.db)))\n\t}\n\n\treturn nil\n}\n\n// LoadExtension load the sqlite3 extension.\nfunc (c *SQLiteConn) LoadExtension(lib string, entry string) error {\n\trv := C.sqlite3_enable_load_extension(c.db, 1)\n\tif rv != C.SQLITE_OK {\n\t\treturn errors.New(C.GoString(C.sqlite3_errmsg(c.db)))\n\t}\n\n\tif err := c.loadExtension(lib, &entry); err != nil {\n\t\tC.sqlite3_enable_load_extension(c.db, 0)\n\t\treturn err\n\t}\n\n\trv = C.sqlite3_enable_load_extension(c.db, 0)\n\tif rv != C.SQLITE_OK {\n\t\treturn errors.New(C.GoString(C.sqlite3_errmsg(c.db)))\n\t}\n\n\treturn nil\n}\n\nfunc (c *SQLiteConn) loadExtension(lib string, entry *string) error {\n\tclib := C.CString(lib)\n\tdefer C.free(unsafe.Pointer(clib))\n\n\tvar centry *C.char\n\tif entry != nil {\n\t\tcentry = C.CString(*entry)\n\t\tdefer C.free(unsafe.Pointer(centry))\n\t}\n\n\tvar errMsg *C.char\n\tdefer C.sqlite3_free(unsafe.Pointer(errMsg))\n\n\trv := C.sqlite3_load_extension(c.db, clib, centry, &errMsg)\n\tif rv != C.SQLITE_OK {\n\t\treturn errors.New(C.GoString(errMsg))\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "sqlite3_load_extension_omit.go",
          "type": "blob",
          "size": 0.6103515625,
          "content": "// Copyright (C) 2019 Yasuhiro Matsumoto <mattn.jp@gmail.com>.\n//\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n//go:build sqlite_omit_load_extension\n// +build sqlite_omit_load_extension\n\npackage sqlite3\n\n/*\n#cgo CFLAGS: -DSQLITE_OMIT_LOAD_EXTENSION\n*/\nimport \"C\"\nimport (\n\t\"errors\"\n)\n\nfunc (c *SQLiteConn) loadExtensions(extensions []string) error {\n\treturn errors.New(\"Extensions have been disabled for static builds\")\n}\n\nfunc (c *SQLiteConn) LoadExtension(lib string, entry string) error {\n\treturn errors.New(\"Extensions have been disabled for static builds\")\n}\n"
        },
        {
          "name": "sqlite3_load_extension_test.go",
          "type": "blob",
          "size": 1.3125,
          "content": "// Copyright (C) 2019 Yasuhiro Matsumoto <mattn.jp@gmail.com>.\n//\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n//go:build !sqlite_omit_load_extension\n// +build !sqlite_omit_load_extension\n\npackage sqlite3\n\nimport (\n\t\"database/sql\"\n\t\"testing\"\n)\n\nfunc TestExtensionsError(t *testing.T) {\n\tsql.Register(\"sqlite3_TestExtensionsError\",\n\t\t&SQLiteDriver{\n\t\t\tExtensions: []string{\n\t\t\t\t\"foobar\",\n\t\t\t},\n\t\t},\n\t)\n\n\tdb, err := sql.Open(\"sqlite3_TestExtensionsError\", \":memory:\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\terr = db.Ping()\n\tif err == nil {\n\t\tt.Fatal(\"expected error loading non-existent extension\")\n\t}\n\n\tif err.Error() == \"not an error\" {\n\t\tt.Fatal(\"expected error from sqlite3_enable_load_extension to be returned\")\n\t}\n}\n\nfunc TestLoadExtensionError(t *testing.T) {\n\tsql.Register(\"sqlite3_TestLoadExtensionError\",\n\t\t&SQLiteDriver{\n\t\t\tConnectHook: func(c *SQLiteConn) error {\n\t\t\t\treturn c.LoadExtension(\"foobar\", \"\")\n\t\t\t},\n\t\t},\n\t)\n\n\tdb, err := sql.Open(\"sqlite3_TestLoadExtensionError\", \":memory:\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\terr = db.Ping()\n\tif err == nil {\n\t\tt.Fatal(\"expected error loading non-existent extension\")\n\t}\n\n\tif err.Error() == \"not an error\" {\n\t\tt.Fatal(\"expected error from sqlite3_enable_load_extension to be returned\")\n\t}\n}\n"
        },
        {
          "name": "sqlite3_opt_allow_uri_authority.go",
          "type": "blob",
          "size": 0.392578125,
          "content": "// Copyright (C) 2019 Yasuhiro Matsumoto <mattn.jp@gmail.com>.\n// Copyright (C) 2018 G.J.R. Timmer <gjr.timmer@gmail.com>.\n//\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n//go:build sqlite_allow_uri_authority\n// +build sqlite_allow_uri_authority\n\npackage sqlite3\n\n/*\n#cgo CFLAGS: -DSQLITE_ALLOW_URI_AUTHORITY\n#cgo LDFLAGS: -lm\n*/\nimport \"C\"\n"
        },
        {
          "name": "sqlite3_opt_app_armor.go",
          "type": "blob",
          "size": 0.390625,
          "content": "// Copyright (C) 2019 Yasuhiro Matsumoto <mattn.jp@gmail.com>.\n// Copyright (C) 2018 G.J.R. Timmer <gjr.timmer@gmail.com>.\n//\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n//go:build !windows && sqlite_app_armor\n// +build !windows,sqlite_app_armor\n\npackage sqlite3\n\n/*\n#cgo CFLAGS: -DSQLITE_ENABLE_API_ARMOR\n#cgo LDFLAGS: -lm\n*/\nimport \"C\"\n"
        },
        {
          "name": "sqlite3_opt_column_metadata.go",
          "type": "blob",
          "size": 0.5166015625,
          "content": "//go:build sqlite_column_metadata\n// +build sqlite_column_metadata\n\npackage sqlite3\n\n/*\n#ifndef USE_LIBSQLITE3\n#cgo CFLAGS: -DSQLITE_ENABLE_COLUMN_METADATA\n#include <sqlite3-binding.h>\n#else\n#include <sqlite3.h>\n#endif\n*/\nimport \"C\"\n\n// ColumnTableName returns the table that is the origin of a particular result\n// column in a SELECT statement.\n//\n// See https://www.sqlite.org/c3ref/column_database_name.html\nfunc (s *SQLiteStmt) ColumnTableName(n int) string {\n\treturn C.GoString(C.sqlite3_column_table_name(s.s, C.int(n)))\n}\n"
        },
        {
          "name": "sqlite3_opt_column_metadata_test.go",
          "type": "blob",
          "size": 1.140625,
          "content": "//go:build sqlite_column_metadata\n// +build sqlite_column_metadata\n\npackage sqlite3\n\nimport \"testing\"\n\nfunc TestColumnTableName(t *testing.T) {\n\td := SQLiteDriver{}\n\tconn, err := d.Open(\":memory:\")\n\tif err != nil {\n\t\tt.Fatal(\"failed to get database connection:\", err)\n\t}\n\tdefer conn.Close()\n\tsqlite3conn := conn.(*SQLiteConn)\n\n\t_, err = sqlite3conn.Exec(`CREATE TABLE foo (name string)`, nil)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to create table:\", err)\n\t}\n\t_, err = sqlite3conn.Exec(`CREATE TABLE bar (name string)`, nil)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to create table:\", err)\n\t}\n\n\tstmt, err := sqlite3conn.Prepare(`SELECT * FROM foo JOIN bar ON foo.name = bar.name`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif exp, got := \"foo\", stmt.(*SQLiteStmt).ColumnTableName(0); exp != got {\n\t\tt.Fatalf(\"Incorrect table name returned expected: %s, got: %s\", exp, got)\n\t}\n\tif exp, got := \"bar\", stmt.(*SQLiteStmt).ColumnTableName(1); exp != got {\n\t\tt.Fatalf(\"Incorrect table name returned expected: %s, got: %s\", exp, got)\n\t}\n\tif exp, got := \"\", stmt.(*SQLiteStmt).ColumnTableName(2); exp != got {\n\t\tt.Fatalf(\"Incorrect table name returned expected: %s, got: %s\", exp, got)\n\t}\n}\n"
        },
        {
          "name": "sqlite3_opt_foreign_keys.go",
          "type": "blob",
          "size": 0.3818359375,
          "content": "// Copyright (C) 2019 Yasuhiro Matsumoto <mattn.jp@gmail.com>.\n// Copyright (C) 2018 G.J.R. Timmer <gjr.timmer@gmail.com>.\n//\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n//go:build sqlite_foreign_keys\n// +build sqlite_foreign_keys\n\npackage sqlite3\n\n/*\n#cgo CFLAGS: -DSQLITE_DEFAULT_FOREIGN_KEYS=1\n#cgo LDFLAGS: -lm\n*/\nimport \"C\"\n"
        },
        {
          "name": "sqlite3_opt_fts3_test.go",
          "type": "blob",
          "size": 3.2607421875,
          "content": "// Copyright (C) 2019 Yasuhiro Matsumoto <mattn.jp@gmail.com>.\n//\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n//go:build cgo\n// +build cgo\n\npackage sqlite3\n\nimport (\n\t\"database/sql\"\n\t\"os\"\n\t\"testing\"\n)\n\nfunc TestFTS3(t *testing.T) {\n\ttempFilename := TempFilename(t)\n\tdefer os.Remove(tempFilename)\n\tdb, err := sql.Open(\"sqlite3\", tempFilename)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to open database:\", err)\n\t}\n\tdefer db.Close()\n\n\t_, err = db.Exec(\"DROP TABLE foo\")\n\t_, err = db.Exec(\"CREATE VIRTUAL TABLE foo USING fts3(id INTEGER PRIMARY KEY, value TEXT)\")\n\tif err != nil {\n\t\tt.Fatal(\"Failed to create table:\", err)\n\t}\n\n\t_, err = db.Exec(\"INSERT INTO foo(id, value) VALUES(?, ?)\", 1, `  `)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to insert value:\", err)\n\t}\n\n\t_, err = db.Exec(\"INSERT INTO foo(id, value) VALUES(?, ?)\", 2, `  `)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to insert value:\", err)\n\t}\n\n\trows, err := db.Query(\"SELECT id, value FROM foo WHERE value MATCH '* *'\")\n\tif err != nil {\n\t\tt.Fatal(\"Unable to query foo table:\", err)\n\t}\n\tdefer rows.Close()\n\n\tfor rows.Next() {\n\t\tvar id int\n\t\tvar value string\n\n\t\tif err := rows.Scan(&id, &value); err != nil {\n\t\t\tt.Error(\"Unable to scan results:\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif id == 1 && value != `  ` {\n\t\t\tt.Error(\"Value for id 1 should be `  `, but:\", value)\n\t\t} else if id == 2 && value != `  ` {\n\t\t\tt.Error(\"Value for id 2 should be `  `, but:\", value)\n\t\t}\n\t}\n\n\trows, err = db.Query(\"SELECT value FROM foo WHERE value MATCH '* *'\")\n\tif err != nil {\n\t\tt.Fatal(\"Unable to query foo table:\", err)\n\t}\n\tdefer rows.Close()\n\n\tvar value string\n\tif !rows.Next() {\n\t\tt.Fatal(\"Result should be only one\")\n\t}\n\n\tif err := rows.Scan(&value); err != nil {\n\t\tt.Fatal(\"Unable to scan results:\", err)\n\t}\n\n\tif value != `  ` {\n\t\tt.Fatal(\"Value should be `  `, but:\", value)\n\t}\n\n\tif rows.Next() {\n\t\tt.Fatal(\"Result should be only one\")\n\t}\n}\n\nfunc TestFTS4(t *testing.T) {\n\ttempFilename := TempFilename(t)\n\tdefer os.Remove(tempFilename)\n\tdb, err := sql.Open(\"sqlite3\", tempFilename)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to open database:\", err)\n\t}\n\tdefer db.Close()\n\n\t_, err = db.Exec(\"DROP TABLE foo\")\n\t_, err = db.Exec(\"CREATE VIRTUAL TABLE foo USING fts4(tokenize=unicode61, id INTEGER PRIMARY KEY, value TEXT)\")\n\tswitch {\n\tcase err != nil && err.Error() == \"unknown tokenizer: unicode61\":\n\t\tt.Skip(\"FTS4 not supported\")\n\tcase err != nil:\n\t\tt.Fatal(\"Failed to create table:\", err)\n\t}\n\n\t_, err = db.Exec(\"INSERT INTO foo(id, value) VALUES(?, ?)\", 1, `fvrier`)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to insert value:\", err)\n\t}\n\n\trows, err := db.Query(\"SELECT value FROM foo WHERE value MATCH 'fevrier'\")\n\tif err != nil {\n\t\tt.Fatal(\"Unable to query foo table:\", err)\n\t}\n\tdefer rows.Close()\n\n\tvar value string\n\tif !rows.Next() {\n\t\tt.Fatal(\"Result should be only one\")\n\t}\n\n\tif err := rows.Scan(&value); err != nil {\n\t\tt.Fatal(\"Unable to scan results:\", err)\n\t}\n\n\tif value != `fvrier` {\n\t\tt.Fatal(\"Value should be `fvrier`, but:\", value)\n\t}\n\n\tif rows.Next() {\n\t\tt.Fatal(\"Result should be only one\")\n\t}\n}\n"
        },
        {
          "name": "sqlite3_opt_fts5.go",
          "type": "blob",
          "size": 0.3095703125,
          "content": "// Copyright (C) 2019 Yasuhiro Matsumoto <mattn.jp@gmail.com>.\n//\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n//go:build sqlite_fts5 || fts5\n// +build sqlite_fts5 fts5\n\npackage sqlite3\n\n/*\n#cgo CFLAGS: -DSQLITE_ENABLE_FTS5\n#cgo LDFLAGS: -lm\n*/\nimport \"C\"\n"
        },
        {
          "name": "sqlite3_opt_icu.go",
          "type": "blob",
          "size": 0.57421875,
          "content": "// Copyright (C) 2019 Yasuhiro Matsumoto <mattn.jp@gmail.com>.\n//\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n//go:build sqlite_icu || icu\n// +build sqlite_icu icu\n\npackage sqlite3\n\n/*\n#cgo LDFLAGS: -licuuc -licui18n\n#cgo CFLAGS: -DSQLITE_ENABLE_ICU\n#cgo darwin,amd64 CFLAGS:  -I/usr/local/opt/icu4c/include\n#cgo darwin,amd64 LDFLAGS: -L/usr/local/opt/icu4c/lib\n#cgo darwin,arm64 CFLAGS:  -I/opt/homebrew/opt/icu4c/include\n#cgo darwin,arm64 LDFLAGS: -L/opt/homebrew/opt/icu4c/lib\n#cgo openbsd LDFLAGS: -lsqlite3\n*/\nimport \"C\"\n"
        },
        {
          "name": "sqlite3_opt_introspect.go",
          "type": "blob",
          "size": 0.375,
          "content": "// Copyright (C) 2019 Yasuhiro Matsumoto <mattn.jp@gmail.com>.\n// Copyright (C) 2018 G.J.R. Timmer <gjr.timmer@gmail.com>.\n\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n//go:build sqlite_introspect\n// +build sqlite_introspect\n\npackage sqlite3\n\n/*\n#cgo CFLAGS: -DSQLITE_INTROSPECTION_PRAGMAS\n#cgo LDFLAGS: -lm\n*/\nimport \"C\"\n"
        },
        {
          "name": "sqlite3_opt_math_functions.go",
          "type": "blob",
          "size": 0.326171875,
          "content": "// Copyright (C) 2022 Yasuhiro Matsumoto <mattn.jp@gmail.com>.\n//\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n//go:build sqlite_math_functions\n// +build sqlite_math_functions\n\npackage sqlite3\n\n/*\n#cgo CFLAGS: -DSQLITE_ENABLE_MATH_FUNCTIONS\n#cgo LDFLAGS: -lm\n*/\nimport \"C\"\n"
        },
        {
          "name": "sqlite3_opt_math_functions_test.go",
          "type": "blob",
          "size": 0.5537109375,
          "content": "//go:build sqlite_math_functions\n// +build sqlite_math_functions\n\npackage sqlite3\n\nimport (\n\t\"database/sql\"\n\t\"testing\"\n)\n\nfunc TestMathFunctions(t *testing.T) {\n\tdb, err := sql.Open(\"sqlite3\", \":memory:\")\n\tif err != nil {\n\t\tt.Fatal(\"Failed to open database:\", err)\n\t}\n\tdefer db.Close()\n\n\tqueries := []string{\n\t\t`SELECT acos(1)`,\n\t\t`SELECT log(10, 100)`,\n\t\t`SELECT power(2, 2)`,\n\t}\n\n\tfor _, query := range queries {\n\t\tvar result float64\n\t\tif err := db.QueryRow(query).Scan(&result); err != nil {\n\t\t\tt.Errorf(\"invoking math function query %q: %v\", query, err)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "sqlite3_opt_os_trace.go",
          "type": "blob",
          "size": 0.330078125,
          "content": "// Copyright (C) 2022 Yasuhiro Matsumoto <mattn.jp@gmail.com>.\n//\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n//go:build sqlite_os_trace\n// +build sqlite_os_trace\n\npackage sqlite3\n\n/*\n#cgo CFLAGS: -DSQLITE_FORCE_OS_TRACE=1\n#cgo CFLAGS: -DSQLITE_DEBUG_OS_TRACE=1\n*/\nimport \"C\"\n"
        },
        {
          "name": "sqlite3_opt_preupdate.go",
          "type": "blob",
          "size": 0.515625,
          "content": "// Copyright (C) 2019 G.J.R. Timmer <gjr.timmer@gmail.com>.\n// Copyright (C) 2018 segment.com <friends@segment.com>\n//\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n//go:build cgo\n// +build cgo\n\npackage sqlite3\n\n// SQLitePreUpdateData represents all of the data available during a\n// pre-update hook call.\ntype SQLitePreUpdateData struct {\n\tConn         *SQLiteConn\n\tOp           int\n\tDatabaseName string\n\tTableName    string\n\tOldRowID     int64\n\tNewRowID     int64\n}\n"
        },
        {
          "name": "sqlite3_opt_preupdate_hook.go",
          "type": "blob",
          "size": 3.1640625,
          "content": "// Copyright (C) 2019 G.J.R. Timmer <gjr.timmer@gmail.com>.\n// Copyright (C) 2018 segment.com <friends@segment.com>\n//\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n//go:build sqlite_preupdate_hook\n// +build sqlite_preupdate_hook\n\npackage sqlite3\n\n/*\n#cgo CFLAGS: -DSQLITE_ENABLE_PREUPDATE_HOOK\n#cgo LDFLAGS: -lm\n\n#ifndef USE_LIBSQLITE3\n#include \"sqlite3-binding.h\"\n#else\n#include <sqlite3.h>\n#endif\n#include <stdlib.h>\n#include <string.h>\n\nvoid preUpdateHookTrampoline(void*, sqlite3 *, int, char *, char *, sqlite3_int64, sqlite3_int64);\n*/\nimport \"C\"\nimport (\n\t\"errors\"\n\t\"unsafe\"\n)\n\n// RegisterPreUpdateHook sets the pre-update hook for a connection.\n//\n// The callback is passed a SQLitePreUpdateData struct with the data for\n// the update, as well as methods for fetching copies of impacted data.\n//\n// If there is an existing preupdate hook for this connection, it will be\n// removed. If callback is nil the existing hook (if any) will be removed\n// without creating a new one.\nfunc (c *SQLiteConn) RegisterPreUpdateHook(callback func(SQLitePreUpdateData)) {\n\tif callback == nil {\n\t\tC.sqlite3_preupdate_hook(c.db, nil, nil)\n\t} else {\n\t\tC.sqlite3_preupdate_hook(c.db, (*[0]byte)(unsafe.Pointer(C.preUpdateHookTrampoline)), unsafe.Pointer(newHandle(c, callback)))\n\t}\n}\n\n// Depth returns the source path of the write, see sqlite3_preupdate_depth()\nfunc (d *SQLitePreUpdateData) Depth() int {\n\treturn int(C.sqlite3_preupdate_depth(d.Conn.db))\n}\n\n// Count returns the number of columns in the row\nfunc (d *SQLitePreUpdateData) Count() int {\n\treturn int(C.sqlite3_preupdate_count(d.Conn.db))\n}\n\nfunc (d *SQLitePreUpdateData) row(dest []any, new bool) error {\n\tfor i := 0; i < d.Count() && i < len(dest); i++ {\n\t\tvar val *C.sqlite3_value\n\t\tvar src any\n\n\t\t// Initially I tried making this just a function pointer argument, but\n\t\t// it's absurdly complicated to pass C function pointers.\n\t\tif new {\n\t\t\tC.sqlite3_preupdate_new(d.Conn.db, C.int(i), &val)\n\t\t} else {\n\t\t\tC.sqlite3_preupdate_old(d.Conn.db, C.int(i), &val)\n\t\t}\n\n\t\tswitch C.sqlite3_value_type(val) {\n\t\tcase C.SQLITE_INTEGER:\n\t\t\tsrc = int64(C.sqlite3_value_int64(val))\n\t\tcase C.SQLITE_FLOAT:\n\t\t\tsrc = float64(C.sqlite3_value_double(val))\n\t\tcase C.SQLITE_BLOB:\n\t\t\tlen := C.sqlite3_value_bytes(val)\n\t\t\tblobptr := C.sqlite3_value_blob(val)\n\t\t\tsrc = C.GoBytes(blobptr, len)\n\t\tcase C.SQLITE_TEXT:\n\t\t\tlen := C.sqlite3_value_bytes(val)\n\t\t\tcstrptr := unsafe.Pointer(C.sqlite3_value_text(val))\n\t\t\tsrc = C.GoBytes(cstrptr, len)\n\t\tcase C.SQLITE_NULL:\n\t\t\tsrc = nil\n\t\t}\n\n\t\terr := convertAssign(&dest[i], src)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// Old populates dest with the row data to be replaced. This works similar to\n// database/sql's Rows.Scan()\nfunc (d *SQLitePreUpdateData) Old(dest ...any) error {\n\tif d.Op == SQLITE_INSERT {\n\t\treturn errors.New(\"There is no old row for INSERT operations\")\n\t}\n\treturn d.row(dest, false)\n}\n\n// New populates dest with the replacement row data. This works similar to\n// database/sql's Rows.Scan()\nfunc (d *SQLitePreUpdateData) New(dest ...any) error {\n\tif d.Op == SQLITE_DELETE {\n\t\treturn errors.New(\"There is no new row for DELETE operations\")\n\t}\n\treturn d.row(dest, true)\n}\n"
        },
        {
          "name": "sqlite3_opt_preupdate_hook_test.go",
          "type": "blob",
          "size": 3.220703125,
          "content": "// Copyright (C) 2019 G.J.R. Timmer <gjr.timmer@gmail.com>.\n// Copyright (C) 2018 segment.com <friends@segment.com>\n//\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n//go:build sqlite_preupdate_hook\n// +build sqlite_preupdate_hook\n\npackage sqlite3\n\nimport (\n\t\"database/sql\"\n\t\"testing\"\n)\n\ntype preUpdateHookDataForTest struct {\n\tdatabaseName string\n\ttableName    string\n\tcount        int\n\top           int\n\toldRow       []any\n\tnewRow       []any\n}\n\nfunc TestPreUpdateHook(t *testing.T) {\n\tvar events []preUpdateHookDataForTest\n\n\tsql.Register(\"sqlite3_PreUpdateHook\", &SQLiteDriver{\n\t\tConnectHook: func(conn *SQLiteConn) error {\n\t\t\tconn.RegisterPreUpdateHook(func(data SQLitePreUpdateData) {\n\t\t\t\teval := -1\n\t\t\t\toldRow := []any{eval}\n\t\t\t\tif data.Op != SQLITE_INSERT {\n\t\t\t\t\terr := data.Old(oldRow...)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tt.Fatalf(\"Unexpected error calling SQLitePreUpdateData.Old: %v\", err)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\teval2 := -1\n\t\t\t\tnewRow := []any{eval2}\n\t\t\t\tif data.Op != SQLITE_DELETE {\n\t\t\t\t\terr := data.New(newRow...)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tt.Fatalf(\"Unexpected error calling SQLitePreUpdateData.New: %v\", err)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// tests dest bound checks in loop\n\t\t\t\tvar tooSmallRow []any\n\t\t\t\tif data.Op != SQLITE_INSERT {\n\t\t\t\t\terr := data.Old(tooSmallRow...)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tt.Fatalf(\"Unexpected error calling SQLitePreUpdateData.Old: %v\", err)\n\t\t\t\t\t}\n\t\t\t\t\tif len(tooSmallRow) != 0 {\n\t\t\t\t\t\tt.Errorf(\"Expected tooSmallRow to be empty, got: %v\", tooSmallRow)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tevents = append(events, preUpdateHookDataForTest{\n\t\t\t\t\tdatabaseName: data.DatabaseName,\n\t\t\t\t\ttableName:    data.TableName,\n\t\t\t\t\tcount:        data.Count(),\n\t\t\t\t\top:           data.Op,\n\t\t\t\t\toldRow:       oldRow,\n\t\t\t\t\tnewRow:       newRow,\n\t\t\t\t})\n\t\t\t})\n\t\t\treturn nil\n\t\t},\n\t})\n\n\tdb, err := sql.Open(\"sqlite3_PreUpdateHook\", \":memory:\")\n\tif err != nil {\n\t\tt.Fatal(\"Failed to open database:\", err)\n\t}\n\tdefer db.Close()\n\n\tstatements := []string{\n\t\t\"create table foo (id integer primary key)\",\n\t\t\"insert into foo values (9)\",\n\t\t\"update foo set id = 99 where id = 9\",\n\t\t\"delete from foo where id = 99\",\n\t}\n\tfor _, statement := range statements {\n\t\t_, err = db.Exec(statement)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Unable to prepare test data [%v]: %v\", statement, err)\n\t\t}\n\t}\n\n\tif len(events) != 3 {\n\t\tt.Errorf(\"Events should be 3 entries, got: %d\", len(events))\n\t}\n\n\tif events[0].op != SQLITE_INSERT {\n\t\tt.Errorf(\"Op isn't as expected: %v\", events[0].op)\n\t}\n\n\tif events[1].op != SQLITE_UPDATE {\n\t\tt.Errorf(\"Op isn't as expected: %v\", events[1].op)\n\t}\n\n\tif events[1].count != 1 {\n\t\tt.Errorf(\"Expected event row 1 to have 1 column, had: %v\", events[1].count)\n\t}\n\n\tnewRow_0_0 := events[0].newRow[0].(int64)\n\tif newRow_0_0 != 9 {\n\t\tt.Errorf(\"Expected event row 0 new column 0 to be == 9, got: %v\", newRow_0_0)\n\t}\n\n\toldRow_1_0 := events[1].oldRow[0].(int64)\n\tif oldRow_1_0 != 9 {\n\t\tt.Errorf(\"Expected event row 1 old column 0 to be == 9, got: %v\", oldRow_1_0)\n\t}\n\n\tnewRow_1_0 := events[1].newRow[0].(int64)\n\tif newRow_1_0 != 99 {\n\t\tt.Errorf(\"Expected event row 1 new column 0 to be == 99, got: %v\", newRow_1_0)\n\t}\n\n\toldRow_2_0 := events[2].oldRow[0].(int64)\n\tif oldRow_2_0 != 99 {\n\t\tt.Errorf(\"Expected event row 1 new column 0 to be == 99, got: %v\", oldRow_2_0)\n\t}\n}\n"
        },
        {
          "name": "sqlite3_opt_preupdate_omit.go",
          "type": "blob",
          "size": 0.7919921875,
          "content": "// Copyright (C) 2019 G.J.R. Timmer <gjr.timmer@gmail.com>.\n// Copyright (C) 2018 segment.com <friends@segment.com>\n//\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n//go:build !sqlite_preupdate_hook && cgo\n// +build !sqlite_preupdate_hook,cgo\n\npackage sqlite3\n\n// RegisterPreUpdateHook sets the pre-update hook for a connection.\n//\n// The callback is passed a SQLitePreUpdateData struct with the data for\n// the update, as well as methods for fetching copies of impacted data.\n//\n// If there is an existing preupdate hook for this connection, it will be\n// removed. If callback is nil the existing hook (if any) will be removed\n// without creating a new one.\nfunc (c *SQLiteConn) RegisterPreUpdateHook(callback func(SQLitePreUpdateData)) {\n\t// NOOP\n}\n"
        },
        {
          "name": "sqlite3_opt_secure_delete.go",
          "type": "blob",
          "size": 0.376953125,
          "content": "// Copyright (C) 2019 Yasuhiro Matsumoto <mattn.jp@gmail.com>.\n// Copyright (C) 2018 G.J.R. Timmer <gjr.timmer@gmail.com>.\n//\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n//go:build sqlite_secure_delete\n// +build sqlite_secure_delete\n\npackage sqlite3\n\n/*\n#cgo CFLAGS: -DSQLITE_SECURE_DELETE=1\n#cgo LDFLAGS: -lm\n*/\nimport \"C\"\n"
        },
        {
          "name": "sqlite3_opt_secure_delete_fast.go",
          "type": "blob",
          "size": 0.3896484375,
          "content": "// Copyright (C) 2019 Yasuhiro Matsumoto <mattn.jp@gmail.com>.\n// Copyright (C) 2018 G.J.R. Timmer <gjr.timmer@gmail.com>.\n//\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n//go:build sqlite_secure_delete_fast\n// +build sqlite_secure_delete_fast\n\npackage sqlite3\n\n/*\n#cgo CFLAGS: -DSQLITE_SECURE_DELETE=FAST\n#cgo LDFLAGS: -lm\n*/\nimport \"C\"\n"
        },
        {
          "name": "sqlite3_opt_serialize.go",
          "type": "blob",
          "size": 1.9482421875,
          "content": "//go:build !libsqlite3 || sqlite_serialize\n// +build !libsqlite3 sqlite_serialize\n\npackage sqlite3\n\n/*\n#ifndef USE_LIBSQLITE3\n#include <sqlite3-binding.h>\n#else\n#include <sqlite3.h>\n#endif\n#include <stdlib.h>\n#include <stdint.h>\n*/\nimport \"C\"\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"reflect\"\n\t\"unsafe\"\n)\n\n// Serialize returns a byte slice that is a serialization of the database.\n//\n// See https://www.sqlite.org/c3ref/serialize.html\nfunc (c *SQLiteConn) Serialize(schema string) ([]byte, error) {\n\tif schema == \"\" {\n\t\tschema = \"main\"\n\t}\n\tvar zSchema *C.char\n\tzSchema = C.CString(schema)\n\tdefer C.free(unsafe.Pointer(zSchema))\n\n\tvar sz C.sqlite3_int64\n\tptr := C.sqlite3_serialize(c.db, zSchema, &sz, 0)\n\tif ptr == nil {\n\t\treturn nil, fmt.Errorf(\"serialize failed\")\n\t}\n\tdefer C.sqlite3_free(unsafe.Pointer(ptr))\n\n\tif sz > C.sqlite3_int64(math.MaxInt) {\n\t\treturn nil, fmt.Errorf(\"serialized database is too large (%d bytes)\", sz)\n\t}\n\n\tcBuf := *(*[]byte)(unsafe.Pointer(&reflect.SliceHeader{\n\t\tData: uintptr(unsafe.Pointer(ptr)),\n\t\tLen:  int(sz),\n\t\tCap:  int(sz),\n\t}))\n\n\tres := make([]byte, int(sz))\n\tcopy(res, cBuf)\n\treturn res, nil\n}\n\n// Deserialize causes the connection to disconnect from the current database and\n// then re-open as an in-memory database based on the contents of the byte slice.\n//\n// See https://www.sqlite.org/c3ref/deserialize.html\nfunc (c *SQLiteConn) Deserialize(b []byte, schema string) error {\n\tif schema == \"\" {\n\t\tschema = \"main\"\n\t}\n\tvar zSchema *C.char\n\tzSchema = C.CString(schema)\n\tdefer C.free(unsafe.Pointer(zSchema))\n\n\ttmpBuf := (*C.uchar)(C.sqlite3_malloc64(C.sqlite3_uint64(len(b))))\n\tcBuf := *(*[]byte)(unsafe.Pointer(&reflect.SliceHeader{\n\t\tData: uintptr(unsafe.Pointer(tmpBuf)),\n\t\tLen:  len(b),\n\t\tCap:  len(b),\n\t}))\n\tcopy(cBuf, b)\n\n\trc := C.sqlite3_deserialize(c.db, zSchema, tmpBuf, C.sqlite3_int64(len(b)),\n\t\tC.sqlite3_int64(len(b)), C.SQLITE_DESERIALIZE_FREEONCLOSE)\n\tif rc != C.SQLITE_OK {\n\t\treturn fmt.Errorf(\"deserialize failed with return %v\", rc)\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "sqlite3_opt_serialize_omit.go",
          "type": "blob",
          "size": 0.5419921875,
          "content": "//go:build libsqlite3 && !sqlite_serialize\n// +build libsqlite3,!sqlite_serialize\n\npackage sqlite3\n\nimport (\n\t\"errors\"\n)\n\n/*\n#cgo CFLAGS: -DSQLITE_OMIT_DESERIALIZE\n*/\nimport \"C\"\n\nfunc (c *SQLiteConn) Serialize(schema string) ([]byte, error) {\n\treturn nil, errors.New(\"sqlite3: Serialize requires the sqlite_serialize build tag when using the libsqlite3 build tag\")\n}\n\nfunc (c *SQLiteConn) Deserialize(b []byte, schema string) error {\n\treturn errors.New(\"sqlite3: Deserialize requires the sqlite_serialize build tag when using the libsqlite3 build tag\")\n}\n"
        },
        {
          "name": "sqlite3_opt_serialize_test.go",
          "type": "blob",
          "size": 2.7529296875,
          "content": "//go:build !libsqlite3 || sqlite_serialize\n// +build !libsqlite3 sqlite_serialize\n\npackage sqlite3\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"os\"\n\t\"testing\"\n)\n\nfunc TestSerializeDeserialize(t *testing.T) {\n\t// Connect to the source database.\n\tsrcTempFilename := TempFilename(t)\n\tdefer os.Remove(srcTempFilename)\n\tsrcDb, err := sql.Open(driverName, srcTempFilename)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to open the source database:\", err)\n\t}\n\tdefer srcDb.Close()\n\terr = srcDb.Ping()\n\tif err != nil {\n\t\tt.Fatal(\"Failed to connect to the source database:\", err)\n\t}\n\n\t// Connect to the destination database.\n\tdestTempFilename := TempFilename(t)\n\tdefer os.Remove(destTempFilename)\n\tdestDb, err := sql.Open(driverName, destTempFilename)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to open the destination database:\", err)\n\t}\n\tdefer destDb.Close()\n\terr = destDb.Ping()\n\tif err != nil {\n\t\tt.Fatal(\"Failed to connect to the destination database:\", err)\n\t}\n\n\t// Write data to source database.\n\t_, err = srcDb.Exec(`CREATE TABLE foo (name string)`)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to create table in source database:\", err)\n\t}\n\t_, err = srcDb.Exec(`INSERT INTO foo(name) VALUES(\"alice\")`)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to insert data into source database\", err)\n\t}\n\n\t// Serialize the source database\n\tsrcConn, err := srcDb.Conn(context.Background())\n\tif err != nil {\n\t\tt.Fatal(\"Failed to get connection to source database:\", err)\n\t}\n\tdefer srcConn.Close()\n\n\tvar serialized []byte\n\tif err := srcConn.Raw(func(raw any) error {\n\t\tvar err error\n\t\tserialized, err = raw.(*SQLiteConn).Serialize(\"\")\n\t\treturn err\n\t}); err != nil {\n\t\tt.Fatal(\"Failed to serialize source database:\", err)\n\t}\n\tsrcConn.Close()\n\n\t// Confirm that the destination database is initially empty.\n\tvar destTableCount int\n\terr = destDb.QueryRow(\"SELECT COUNT(*) FROM sqlite_master WHERE type = 'table'\").Scan(&destTableCount)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to check the destination table count:\", err)\n\t}\n\tif destTableCount != 0 {\n\t\tt.Fatalf(\"The destination database is not empty; %v table(s) found.\", destTableCount)\n\t}\n\n\t// Deserialize to destination database\n\tdestConn, err := destDb.Conn(context.Background())\n\tif err != nil {\n\t\tt.Fatal(\"Failed to get connection to destination database:\", err)\n\t}\n\tdefer destConn.Close()\n\n\tif err := destConn.Raw(func(raw any) error {\n\t\treturn raw.(*SQLiteConn).Deserialize(serialized, \"\")\n\t}); err != nil {\n\t\tt.Fatal(\"Failed to deserialize source database:\", err)\n\t}\n\tdestConn.Close()\n\n\t// Confirm that destination database has been loaded correctly.\n\tvar destRowCount int\n\terr = destDb.QueryRow(`SELECT COUNT(*) FROM foo`).Scan(&destRowCount)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to count rows in destination database table\", err)\n\t}\n\tif destRowCount != 1 {\n\t\tt.Fatalf(\"Destination table does not have the expected records\")\n\t}\n}\n"
        },
        {
          "name": "sqlite3_opt_stat4.go",
          "type": "blob",
          "size": 0.3583984375,
          "content": "// Copyright (C) 2019 Yasuhiro Matsumoto <mattn.jp@gmail.com>.\n// Copyright (C) 2018 G.J.R. Timmer <gjr.timmer@gmail.com>.\n//\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n//go:build sqlite_stat4\n// +build sqlite_stat4\n\npackage sqlite3\n\n/*\n#cgo CFLAGS: -DSQLITE_ENABLE_STAT4\n#cgo LDFLAGS: -lm\n*/\nimport \"C\"\n"
        },
        {
          "name": "sqlite3_opt_unlock_notify.c",
          "type": "blob",
          "size": 1.7314453125,
          "content": "// Copyright (C) 2018 Yasuhiro Matsumoto <mattn.jp@gmail.com>.\n//\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n#ifdef SQLITE_ENABLE_UNLOCK_NOTIFY\n#include <stdio.h>\n#ifndef USE_LIBSQLITE3\n#include \"sqlite3-binding.h\"\n#else\n#include <sqlite3.h>\n#endif\n\nextern int unlock_notify_wait(sqlite3 *db);\n\nint\n_sqlite3_step_blocking(sqlite3_stmt *stmt)\n{\n  int rv;\n  sqlite3* db;\n\n  db = sqlite3_db_handle(stmt);\n  for (;;) {\n    rv = sqlite3_step(stmt);\n    if (rv != SQLITE_LOCKED) {\n      break;\n    }\n    if (sqlite3_extended_errcode(db) != SQLITE_LOCKED_SHAREDCACHE) {\n      break;\n    }\n    rv = unlock_notify_wait(db);\n    if (rv != SQLITE_OK) {\n      break;\n    }\n    sqlite3_reset(stmt);\n  }\n\n  return rv;\n}\n\nint\n_sqlite3_step_row_blocking(sqlite3_stmt* stmt, long long* rowid, long long* changes)\n{\n  int rv;\n  sqlite3* db;\n\n  db = sqlite3_db_handle(stmt);\n  for (;;) {\n    rv = sqlite3_step(stmt);\n    if (rv!=SQLITE_LOCKED) {\n      break;\n    }\n    if (sqlite3_extended_errcode(db) != SQLITE_LOCKED_SHAREDCACHE) {\n      break;\n    }\n    rv = unlock_notify_wait(db);\n    if (rv != SQLITE_OK) {\n      break;\n    }\n    sqlite3_reset(stmt);\n  }\n\n  *rowid = (long long) sqlite3_last_insert_rowid(db);\n  *changes = (long long) sqlite3_changes(db);\n  return rv;\n}\n\nint\n_sqlite3_prepare_v2_blocking(sqlite3 *db, const char *zSql, int nBytes, sqlite3_stmt **ppStmt, const char **pzTail)\n{\n  int rv;\n\n  for (;;) {\n    rv = sqlite3_prepare_v2(db, zSql, nBytes, ppStmt, pzTail);\n    if (rv!=SQLITE_LOCKED) {\n      break;\n    }\n    if (sqlite3_extended_errcode(db) != SQLITE_LOCKED_SHAREDCACHE) {\n      break;\n    }\n    rv = unlock_notify_wait(db);\n    if (rv != SQLITE_OK) {\n      break;\n    }\n  }\n\n  return rv;\n}\n#endif\n"
        },
        {
          "name": "sqlite3_opt_unlock_notify.go",
          "type": "blob",
          "size": 1.970703125,
          "content": "// Copyright (C) 2019 Yasuhiro Matsumoto <mattn.jp@gmail.com>.\n//\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n//go:build cgo && sqlite_unlock_notify\n// +build cgo,sqlite_unlock_notify\n\npackage sqlite3\n\n/*\n#cgo CFLAGS: -DSQLITE_ENABLE_UNLOCK_NOTIFY\n\n#include <stdlib.h>\n#ifndef USE_LIBSQLITE3\n#include \"sqlite3-binding.h\"\n#else\n#include <sqlite3.h>\n#endif\n\nextern void unlock_notify_callback(void *arg, int argc);\n*/\nimport \"C\"\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"sync\"\n\t\"unsafe\"\n)\n\ntype unlock_notify_table struct {\n\tsync.Mutex\n\tseqnum uint\n\ttable  map[uint]chan struct{}\n}\n\nvar unt unlock_notify_table = unlock_notify_table{table: make(map[uint]chan struct{})}\n\nfunc (t *unlock_notify_table) add(c chan struct{}) uint {\n\tt.Lock()\n\tdefer t.Unlock()\n\th := t.seqnum\n\tt.table[h] = c\n\tt.seqnum++\n\treturn h\n}\n\nfunc (t *unlock_notify_table) remove(h uint) {\n\tt.Lock()\n\tdefer t.Unlock()\n\tdelete(t.table, h)\n}\n\nfunc (t *unlock_notify_table) get(h uint) chan struct{} {\n\tt.Lock()\n\tdefer t.Unlock()\n\tc, ok := t.table[h]\n\tif !ok {\n\t\tpanic(fmt.Sprintf(\"Non-existent key for unlcok-notify channel: %d\", h))\n\t}\n\treturn c\n}\n\n//export unlock_notify_callback\nfunc unlock_notify_callback(argv unsafe.Pointer, argc C.int) {\n\tfor i := 0; i < int(argc); i++ {\n\t\tparg := ((*(*[(math.MaxInt32 - 1) / unsafe.Sizeof((*C.uint)(nil))]*[1]uint)(argv))[i])\n\t\targ := *parg\n\t\th := arg[0]\n\t\tc := unt.get(h)\n\t\tc <- struct{}{}\n\t}\n}\n\n//export unlock_notify_wait\nfunc unlock_notify_wait(db *C.sqlite3) C.int {\n\t// It has to be a bufferred channel to not block in sqlite_unlock_notify\n\t// as sqlite_unlock_notify could invoke the callback before it returns.\n\tc := make(chan struct{}, 1)\n\tdefer close(c)\n\n\th := unt.add(c)\n\tdefer unt.remove(h)\n\n\tpargv := C.malloc(C.sizeof_uint)\n\tdefer C.free(pargv)\n\n\targv := (*[1]uint)(pargv)\n\targv[0] = h\n\tif rv := C.sqlite3_unlock_notify(db, (*[0]byte)(C.unlock_notify_callback), unsafe.Pointer(pargv)); rv != C.SQLITE_OK {\n\t\treturn rv\n\t}\n\n\t<-c\n\n\treturn C.SQLITE_OK\n}\n"
        },
        {
          "name": "sqlite3_opt_unlock_notify_test.go",
          "type": "blob",
          "size": 4.7568359375,
          "content": "// Copyright (C) 2019 Yasuhiro Matsumoto <mattn.jp@gmail.com>.\n//\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n//go:build sqlite_unlock_notify\n// +build sqlite_unlock_notify\n\npackage sqlite3\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"os\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestUnlockNotify(t *testing.T) {\n\ttempFilename := TempFilename(t)\n\tdefer os.Remove(tempFilename)\n\tdsn := fmt.Sprintf(\"file:%s?cache=shared&mode=rwc&_busy_timeout=%d\", tempFilename, 500)\n\tdb, err := sql.Open(\"sqlite3\", dsn)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to open database:\", err)\n\t}\n\tdefer db.Close()\n\n\t_, err = db.Exec(\"CREATE TABLE foo(id INTEGER, status INTEGER)\")\n\tif err != nil {\n\t\tt.Fatal(\"Failed to create table:\", err)\n\t}\n\n\ttx, err := db.Begin()\n\tif err != nil {\n\t\tt.Fatal(\"Failed to begin transaction:\", err)\n\t}\n\n\t_, err = tx.Exec(\"INSERT INTO foo(id, status) VALUES(1, 100)\")\n\tif err != nil {\n\t\tt.Fatal(\"Failed to insert null:\", err)\n\t}\n\n\t_, err = tx.Exec(\"UPDATE foo SET status = 200 WHERE id = 1\")\n\tif err != nil {\n\t\tt.Fatal(\"Failed to update table:\", err)\n\t}\n\n\twg := sync.WaitGroup{}\n\twg.Add(1)\n\ttimer := time.NewTimer(500 * time.Millisecond)\n\tgo func() {\n\t\t<-timer.C\n\t\terr := tx.Commit()\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Failed to commit transaction:\", err)\n\t\t}\n\t\twg.Done()\n\t}()\n\n\trows, err := db.Query(\"SELECT count(*) from foo\")\n\tif err != nil {\n\t\tt.Fatal(\"Unable to query foo table:\", err)\n\t}\n\n\tif rows.Next() {\n\t\tvar count int\n\t\tif err := rows.Scan(&count); err != nil {\n\t\t\tt.Fatal(\"Failed to Scan rows\", err)\n\t\t}\n\t}\n\tif err := rows.Err(); err != nil {\n\t\tt.Fatal(\"Failed at the call to Next:\", err)\n\t}\n\twg.Wait()\n\n}\n\nfunc TestUnlockNotifyMany(t *testing.T) {\n\ttempFilename := TempFilename(t)\n\tdefer os.Remove(tempFilename)\n\tdsn := fmt.Sprintf(\"file:%s?cache=shared&mode=rwc&_busy_timeout=%d\", tempFilename, 500)\n\tdb, err := sql.Open(\"sqlite3\", dsn)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to open database:\", err)\n\t}\n\tdefer db.Close()\n\n\t_, err = db.Exec(\"CREATE TABLE foo(id INTEGER, status INTEGER)\")\n\tif err != nil {\n\t\tt.Fatal(\"Failed to create table:\", err)\n\t}\n\n\ttx, err := db.Begin()\n\tif err != nil {\n\t\tt.Fatal(\"Failed to begin transaction:\", err)\n\t}\n\n\t_, err = tx.Exec(\"INSERT INTO foo(id, status) VALUES(1, 100)\")\n\tif err != nil {\n\t\tt.Fatal(\"Failed to insert null:\", err)\n\t}\n\n\t_, err = tx.Exec(\"UPDATE foo SET status = 200 WHERE id = 1\")\n\tif err != nil {\n\t\tt.Fatal(\"Failed to update table:\", err)\n\t}\n\n\twg := sync.WaitGroup{}\n\twg.Add(1)\n\ttimer := time.NewTimer(500 * time.Millisecond)\n\tgo func() {\n\t\t<-timer.C\n\t\terr := tx.Commit()\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Failed to commit transaction:\", err)\n\t\t}\n\t\twg.Done()\n\t}()\n\n\tconst concurrentQueries = 1000\n\twg.Add(concurrentQueries)\n\tfor i := 0; i < concurrentQueries; i++ {\n\t\tgo func() {\n\t\t\trows, err := db.Query(\"SELECT count(*) from foo\")\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(\"Unable to query foo table:\", err)\n\t\t\t}\n\n\t\t\tif rows.Next() {\n\t\t\t\tvar count int\n\t\t\t\tif err := rows.Scan(&count); err != nil {\n\t\t\t\t\tt.Fatal(\"Failed to Scan rows\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif err := rows.Err(); err != nil {\n\t\t\t\tt.Fatal(\"Failed at the call to Next:\", err)\n\t\t\t}\n\t\t\twg.Done()\n\t\t}()\n\t}\n\twg.Wait()\n}\n\nfunc TestUnlockNotifyDeadlock(t *testing.T) {\n\ttempFilename := TempFilename(t)\n\tdefer os.Remove(tempFilename)\n\tdsn := fmt.Sprintf(\"file:%s?cache=shared&mode=rwc&_busy_timeout=%d\", tempFilename, 500)\n\tdb, err := sql.Open(\"sqlite3\", dsn)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to open database:\", err)\n\t}\n\tdefer db.Close()\n\n\t_, err = db.Exec(\"CREATE TABLE foo(id INTEGER, status INTEGER)\")\n\tif err != nil {\n\t\tt.Fatal(\"Failed to create table:\", err)\n\t}\n\n\ttx, err := db.Begin()\n\tif err != nil {\n\t\tt.Fatal(\"Failed to begin transaction:\", err)\n\t}\n\n\t_, err = tx.Exec(\"INSERT INTO foo(id, status) VALUES(1, 100)\")\n\tif err != nil {\n\t\tt.Fatal(\"Failed to insert null:\", err)\n\t}\n\n\t_, err = tx.Exec(\"UPDATE foo SET status = 200 WHERE id = 1\")\n\tif err != nil {\n\t\tt.Fatal(\"Failed to update table:\", err)\n\t}\n\n\twg := sync.WaitGroup{}\n\twg.Add(1)\n\ttimer := time.NewTimer(500 * time.Millisecond)\n\tgo func() {\n\t\t<-timer.C\n\t\terr := tx.Commit()\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Failed to commit transaction:\", err)\n\t\t}\n\t\twg.Done()\n\t}()\n\n\twg.Add(1)\n\tgo func() {\n\t\ttx2, err := db.Begin()\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Failed to begin transaction:\", err)\n\t\t}\n\t\tdefer tx2.Rollback()\n\n\t\t_, err = tx2.Exec(\"DELETE FROM foo\")\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Failed to delete table:\", err)\n\t\t}\n\t\terr = tx2.Commit()\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Failed to commit transaction:\", err)\n\t\t}\n\t\twg.Done()\n\t}()\n\n\trows, err := tx.Query(\"SELECT count(*) from foo\")\n\tif err != nil {\n\t\tt.Fatal(\"Unable to query foo table:\", err)\n\t}\n\n\tif rows.Next() {\n\t\tvar count int\n\t\tif err := rows.Scan(&count); err != nil {\n\t\t\tt.Fatal(\"Failed to Scan rows\", err)\n\t\t}\n\t}\n\tif err := rows.Err(); err != nil {\n\t\tt.Fatal(\"Failed at the call to Next:\", err)\n\t}\n\n\twg.Wait()\n}\n"
        },
        {
          "name": "sqlite3_opt_userauth.go",
          "type": "blob",
          "size": 7.4296875,
          "content": "// Copyright (C) 2018 G.J.R. Timmer <gjr.timmer@gmail.com>.\n//\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n//go:build sqlite_userauth\n// +build sqlite_userauth\n\npackage sqlite3\n\n/*\n#cgo CFLAGS: -DSQLITE_USER_AUTHENTICATION\n#cgo LDFLAGS: -lm\n#ifndef USE_LIBSQLITE3\n#include \"sqlite3-binding.h\"\n#else\n#include <sqlite3.h>\n#endif\n#include <stdlib.h>\n\nstatic int\n_sqlite3_user_authenticate(sqlite3* db, const char* zUsername, const char* aPW, int nPW)\n{\n  return sqlite3_user_authenticate(db, zUsername, aPW, nPW);\n}\n\nstatic int\n_sqlite3_user_add(sqlite3* db, const char* zUsername, const char* aPW, int nPW, int isAdmin)\n{\n  return sqlite3_user_add(db, zUsername, aPW, nPW, isAdmin);\n}\n\nstatic int\n_sqlite3_user_change(sqlite3* db, const char* zUsername, const char* aPW, int nPW, int isAdmin)\n{\n  return sqlite3_user_change(db, zUsername, aPW, nPW, isAdmin);\n}\n\nstatic int\n_sqlite3_user_delete(sqlite3* db, const char* zUsername)\n{\n  return sqlite3_user_delete(db, zUsername);\n}\n\nstatic int\n_sqlite3_auth_enabled(sqlite3* db)\n{\n\tint exists = -1;\n\n\tsqlite3_stmt *stmt;\n\tsqlite3_prepare_v2(db, \"select count(type) from sqlite_master WHERE type='table' and name='sqlite_user';\", -1, &stmt, NULL);\n\n\twhile ( sqlite3_step(stmt) == SQLITE_ROW) {\n\t\texists = sqlite3_column_int(stmt, 0);\n\t}\n\n\tsqlite3_finalize(stmt);\n\n\treturn exists;\n}\n*/\nimport \"C\"\nimport (\n\t\"errors\"\n\t\"unsafe\"\n)\n\nconst (\n\tSQLITE_AUTH = C.SQLITE_AUTH\n)\n\nvar (\n\tErrUnauthorized  = errors.New(\"SQLITE_AUTH: Unauthorized\")\n\tErrAdminRequired = errors.New(\"SQLITE_AUTH: Unauthorized; Admin Privileges Required\")\n)\n\n// Authenticate will perform an authentication of the provided username\n// and password against the database.\n//\n// If a database contains the SQLITE_USER table, then the\n// call to Authenticate must be invoked with an\n// appropriate username and password prior to enable read and write\n// access to the database.\n//\n// Return SQLITE_OK on success or SQLITE_ERROR if the username/password\n// combination is incorrect or unknown.\n//\n// If the SQLITE_USER table is not present in the database file, then\n// this interface is a harmless no-op returning SQLITE_OK.\nfunc (c *SQLiteConn) Authenticate(username, password string) error {\n\trv := c.authenticate(username, password)\n\tswitch rv {\n\tcase C.SQLITE_ERROR, C.SQLITE_AUTH:\n\t\treturn ErrUnauthorized\n\tcase C.SQLITE_OK:\n\t\treturn nil\n\tdefault:\n\t\treturn c.lastError()\n\t}\n}\n\n// authenticate provides the actual authentication to SQLite.\n// This is not exported for usage in Go.\n// It is however exported for usage within SQL by the user.\n//\n// Returns:\n//\n//\t\tC.SQLITE_OK (0)\n//\t\tC.SQLITE_ERROR (1)\n//\t C.SQLITE_AUTH (23)\nfunc (c *SQLiteConn) authenticate(username, password string) int {\n\t// Allocate C Variables\n\tcuser := C.CString(username)\n\tcpass := C.CString(password)\n\n\t// Free C Variables\n\tdefer func() {\n\t\tC.free(unsafe.Pointer(cuser))\n\t\tC.free(unsafe.Pointer(cpass))\n\t}()\n\n\treturn int(C._sqlite3_user_authenticate(c.db, cuser, cpass, C.int(len(password))))\n}\n\n// AuthUserAdd can be used (by an admin user only)\n// to create a new user. When called on a no-authentication-required\n// database, this routine converts the database into an authentication-\n// required database, automatically makes the added user an\n// administrator, and logs in the current connection as that user.\n// The AuthUserAdd only works for the \"main\" database, not\n// for any ATTACH-ed databases. Any call to AuthUserAdd by a\n// non-admin user results in an error.\nfunc (c *SQLiteConn) AuthUserAdd(username, password string, admin bool) error {\n\tisAdmin := 0\n\tif admin {\n\t\tisAdmin = 1\n\t}\n\n\trv := c.authUserAdd(username, password, isAdmin)\n\tswitch rv {\n\tcase C.SQLITE_ERROR, C.SQLITE_AUTH:\n\t\treturn ErrAdminRequired\n\tcase C.SQLITE_OK:\n\t\treturn nil\n\tdefault:\n\t\treturn c.lastError()\n\t}\n}\n\n// authUserAdd enables the User Authentication if not enabled.\n// Otherwise it will add a user.\n//\n// When user authentication is already enabled then this function\n// can only be called by an admin.\n//\n// This is not exported for usage in Go.\n// It is however exported for usage within SQL by the user.\n//\n// Returns:\n//\n//\t\tC.SQLITE_OK (0)\n//\t\tC.SQLITE_ERROR (1)\n//\t C.SQLITE_AUTH (23)\nfunc (c *SQLiteConn) authUserAdd(username, password string, admin int) int {\n\t// Allocate C Variables\n\tcuser := C.CString(username)\n\tcpass := C.CString(password)\n\n\t// Free C Variables\n\tdefer func() {\n\t\tC.free(unsafe.Pointer(cuser))\n\t\tC.free(unsafe.Pointer(cpass))\n\t}()\n\n\treturn int(C._sqlite3_user_add(c.db, cuser, cpass, C.int(len(password)), C.int(admin)))\n}\n\n// AuthUserChange can be used to change a users\n// login credentials or admin privilege.  Any user can change their own\n// login credentials. Only an admin user can change another users login\n// credentials or admin privilege setting. No user may change their own\n// admin privilege setting.\nfunc (c *SQLiteConn) AuthUserChange(username, password string, admin bool) error {\n\tisAdmin := 0\n\tif admin {\n\t\tisAdmin = 1\n\t}\n\n\trv := c.authUserChange(username, password, isAdmin)\n\tswitch rv {\n\tcase C.SQLITE_ERROR, C.SQLITE_AUTH:\n\t\treturn ErrAdminRequired\n\tcase C.SQLITE_OK:\n\t\treturn nil\n\tdefault:\n\t\treturn c.lastError()\n\t}\n}\n\n// authUserChange allows to modify a user.\n// Users can change their own password.\n//\n// Only admins can change passwords for other users\n// and modify the admin flag.\n//\n// The admin flag of the current logged in user cannot be changed.\n// THis ensures that their is always an admin.\n//\n// This is not exported for usage in Go.\n// It is however exported for usage within SQL by the user.\n//\n// Returns:\n//\n//\t\tC.SQLITE_OK (0)\n//\t\tC.SQLITE_ERROR (1)\n//\t C.SQLITE_AUTH (23)\nfunc (c *SQLiteConn) authUserChange(username, password string, admin int) int {\n\t// Allocate C Variables\n\tcuser := C.CString(username)\n\tcpass := C.CString(password)\n\n\t// Free C Variables\n\tdefer func() {\n\t\tC.free(unsafe.Pointer(cuser))\n\t\tC.free(unsafe.Pointer(cpass))\n\t}()\n\n\treturn int(C._sqlite3_user_change(c.db, cuser, cpass, C.int(len(password)), C.int(admin)))\n}\n\n// AuthUserDelete can be used (by an admin user only)\n// to delete a user. The currently logged-in user cannot be deleted,\n// which guarantees that there is always an admin user and hence that\n// the database cannot be converted into a no-authentication-required\n// database.\nfunc (c *SQLiteConn) AuthUserDelete(username string) error {\n\trv := c.authUserDelete(username)\n\tswitch rv {\n\tcase C.SQLITE_ERROR, C.SQLITE_AUTH:\n\t\treturn ErrAdminRequired\n\tcase C.SQLITE_OK:\n\t\treturn nil\n\tdefault:\n\t\treturn c.lastError()\n\t}\n}\n\n// authUserDelete can be used to delete a user.\n//\n// This function can only be executed by an admin.\n//\n// This is not exported for usage in Go.\n// It is however exported for usage within SQL by the user.\n//\n// Returns:\n//\n//\t\tC.SQLITE_OK (0)\n//\t\tC.SQLITE_ERROR (1)\n//\t C.SQLITE_AUTH (23)\nfunc (c *SQLiteConn) authUserDelete(username string) int {\n\t// Allocate C Variables\n\tcuser := C.CString(username)\n\n\t// Free C Variables\n\tdefer func() {\n\t\tC.free(unsafe.Pointer(cuser))\n\t}()\n\n\treturn int(C._sqlite3_user_delete(c.db, cuser))\n}\n\n// AuthEnabled checks if the database is protected by user authentication\nfunc (c *SQLiteConn) AuthEnabled() (exists bool) {\n\trv := c.authEnabled()\n\tif rv == 1 {\n\t\texists = true\n\t}\n\n\treturn\n}\n\n// authEnabled perform the actual check for user authentication.\n//\n// This is not exported for usage in Go.\n// It is however exported for usage within SQL by the user.\n//\n// Returns:\n//\n//\t\t0 - Disabled\n//\t 1 - Enabled\nfunc (c *SQLiteConn) authEnabled() int {\n\treturn int(C._sqlite3_auth_enabled(c.db))\n}\n\n// EOF\n"
        },
        {
          "name": "sqlite3_opt_userauth_omit.go",
          "type": "blob",
          "size": 4.365234375,
          "content": "// Copyright (C) 2018 G.J.R. Timmer <gjr.timmer@gmail.com>.\n//\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n//go:build !sqlite_userauth\n// +build !sqlite_userauth\n\npackage sqlite3\n\nimport (\n\t\"C\"\n)\n\n// Authenticate will perform an authentication of the provided username\n// and password against the database.\n//\n// If a database contains the SQLITE_USER table, then the\n// call to Authenticate must be invoked with an\n// appropriate username and password prior to enable read and write\n// access to the database.\n//\n// Return SQLITE_OK on success or SQLITE_ERROR if the username/password\n// combination is incorrect or unknown.\n//\n// If the SQLITE_USER table is not present in the database file, then\n// this interface is a harmless no-op returnning SQLITE_OK.\nfunc (c *SQLiteConn) Authenticate(username, password string) error {\n\t// NOOP\n\treturn nil\n}\n\n// authenticate provides the actual authentication to SQLite.\n// This is not exported for usage in Go.\n// It is however exported for usage within SQL by the user.\n//\n// Returns:\n//\n//\t\tC.SQLITE_OK (0)\n//\t\tC.SQLITE_ERROR (1)\n//\t C.SQLITE_AUTH (23)\nfunc (c *SQLiteConn) authenticate(username, password string) int {\n\t// NOOP\n\treturn 0\n}\n\n// AuthUserAdd can be used (by an admin user only)\n// to create a new user.  When called on a no-authentication-required\n// database, this routine converts the database into an authentication-\n// required database, automatically makes the added user an\n// administrator, and logs in the current connection as that user.\n// The AuthUserAdd only works for the \"main\" database, not\n// for any ATTACH-ed databases. Any call to AuthUserAdd by a\n// non-admin user results in an error.\nfunc (c *SQLiteConn) AuthUserAdd(username, password string, admin bool) error {\n\t// NOOP\n\treturn nil\n}\n\n// authUserAdd enables the User Authentication if not enabled.\n// Otherwise it will add a user.\n//\n// When user authentication is already enabled then this function\n// can only be called by an admin.\n//\n// This is not exported for usage in Go.\n// It is however exported for usage within SQL by the user.\n//\n// Returns:\n//\n//\t\tC.SQLITE_OK (0)\n//\t\tC.SQLITE_ERROR (1)\n//\t C.SQLITE_AUTH (23)\nfunc (c *SQLiteConn) authUserAdd(username, password string, admin int) int {\n\t// NOOP\n\treturn 0\n}\n\n// AuthUserChange can be used to change a users\n// login credentials or admin privilege.  Any user can change their own\n// login credentials.  Only an admin user can change another users login\n// credentials or admin privilege setting.  No user may change their own\n// admin privilege setting.\nfunc (c *SQLiteConn) AuthUserChange(username, password string, admin bool) error {\n\t// NOOP\n\treturn nil\n}\n\n// authUserChange allows to modify a user.\n// Users can change their own password.\n//\n// Only admins can change passwords for other users\n// and modify the admin flag.\n//\n// The admin flag of the current logged in user cannot be changed.\n// THis ensures that their is always an admin.\n//\n// This is not exported for usage in Go.\n// It is however exported for usage within SQL by the user.\n//\n// Returns:\n//\n//\t\tC.SQLITE_OK (0)\n//\t\tC.SQLITE_ERROR (1)\n//\t C.SQLITE_AUTH (23)\nfunc (c *SQLiteConn) authUserChange(username, password string, admin int) int {\n\t// NOOP\n\treturn 0\n}\n\n// AuthUserDelete can be used (by an admin user only)\n// to delete a user.  The currently logged-in user cannot be deleted,\n// which guarantees that there is always an admin user and hence that\n// the database cannot be converted into a no-authentication-required\n// database.\nfunc (c *SQLiteConn) AuthUserDelete(username string) error {\n\t// NOOP\n\treturn nil\n}\n\n// authUserDelete can be used to delete a user.\n//\n// This function can only be executed by an admin.\n//\n// This is not exported for usage in Go.\n// It is however exported for usage within SQL by the user.\n//\n// Returns:\n//\n//\t\tC.SQLITE_OK (0)\n//\t\tC.SQLITE_ERROR (1)\n//\t C.SQLITE_AUTH (23)\nfunc (c *SQLiteConn) authUserDelete(username string) int {\n\t// NOOP\n\treturn 0\n}\n\n// AuthEnabled checks if the database is protected by user authentication\nfunc (c *SQLiteConn) AuthEnabled() (exists bool) {\n\t// NOOP\n\treturn false\n}\n\n// authEnabled perform the actual check for user authentication.\n//\n// This is not exported for usage in Go.\n// It is however exported for usage within SQL by the user.\n//\n// Returns:\n//\n//\t\t0 - Disabled\n//\t 1 - Enabled\nfunc (c *SQLiteConn) authEnabled() int {\n\t// NOOP\n\treturn 0\n}\n\n// EOF\n"
        },
        {
          "name": "sqlite3_opt_userauth_test.go",
          "type": "blob",
          "size": 15.009765625,
          "content": "// Copyright (C) 2018 G.J.R. Timmer <gjr.timmer@gmail.com>.\n//\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n//go:build sqlite_userauth\n// +build sqlite_userauth\n\npackage sqlite3\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"os\"\n\t\"testing\"\n)\n\nvar (\n\tconn             *SQLiteConn\n\tcreate           func(t *testing.T, username, password string) (file string, err error)\n\tcreateWithCrypt  func(t *testing.T, username, password, crypt, salt string) (file string, err error)\n\tconnect          func(t *testing.T, f string, username, password string) (file string, db *sql.DB, c *SQLiteConn, err error)\n\tconnectWithCrypt func(t *testing.T, f string, username, password string, crypt string, salt string) (file string, db *sql.DB, c *SQLiteConn, err error)\n\tauthEnabled      func(db *sql.DB) (exists bool, err error)\n\taddUser          func(db *sql.DB, username, password string, admin int) (rv int, err error)\n\tuserExists       func(db *sql.DB, username string) (rv int, err error)\n\tisAdmin          func(db *sql.DB, username string) (rv bool, err error)\n\tmodifyUser       func(db *sql.DB, username, password string, admin int) (rv int, err error)\n\tdeleteUser       func(db *sql.DB, username string) (rv int, err error)\n)\n\nfunc init() {\n\t// Create database connection\n\tsql.Register(\"sqlite3_with_conn\",\n\t\t&SQLiteDriver{\n\t\t\tConnectHook: func(c *SQLiteConn) error {\n\t\t\t\tconn = c\n\t\t\t\treturn nil\n\t\t\t},\n\t\t})\n\n\tcreate = func(t *testing.T, username, password string) (file string, err error) {\n\t\tvar db *sql.DB\n\t\tfile, db, _, err = connect(t, \"\", username, password)\n\t\tdb.Close()\n\t\treturn\n\t}\n\n\tcreateWithCrypt = func(t *testing.T, username, password, crypt, salt string) (file string, err error) {\n\t\tvar db *sql.DB\n\t\tfile, db, _, err = connectWithCrypt(t, \"\", \"admin\", \"admin\", crypt, salt)\n\t\tdb.Close()\n\t\treturn\n\t}\n\n\tconnect = func(t *testing.T, f string, username, password string) (file string, db *sql.DB, c *SQLiteConn, err error) {\n\t\tconn = nil // Clear connection\n\t\tfile = f   // Copy provided file (f) => file\n\t\tif file == \"\" {\n\t\t\t// Create dummy file\n\t\t\tfile = TempFilename(t)\n\t\t}\n\n\t\tparams := \"?_auth\"\n\t\tif len(username) > 0 {\n\t\t\tparams = fmt.Sprintf(\"%s&_auth_user=%s\", params, username)\n\t\t}\n\t\tif len(password) > 0 {\n\t\t\tparams = fmt.Sprintf(\"%s&_auth_pass=%s\", params, password)\n\t\t}\n\t\tdb, err = sql.Open(\"sqlite3_with_conn\", \"file:\"+file+params)\n\t\tif err != nil {\n\t\t\tdefer os.Remove(file)\n\t\t\treturn file, nil, nil, err\n\t\t}\n\n\t\t// Dummy query to force connection and database creation\n\t\t// Will return ErrUnauthorized (SQLITE_AUTH) if user authentication fails\n\t\tif _, err = db.Exec(\"SELECT 1;\"); err != nil {\n\t\t\tdefer os.Remove(file)\n\t\t\tdefer db.Close()\n\t\t\treturn file, nil, nil, err\n\t\t}\n\t\tc = conn\n\n\t\treturn\n\t}\n\n\tconnectWithCrypt = func(t *testing.T, f string, username, password string, crypt string, salt string) (file string, db *sql.DB, c *SQLiteConn, err error) {\n\t\tconn = nil // Clear connection\n\t\tfile = f   // Copy provided file (f) => file\n\t\tif file == \"\" {\n\t\t\t// Create dummy file\n\t\t\tfile = TempFilename(t)\n\t\t}\n\n\t\tdb, err = sql.Open(\"sqlite3_with_conn\", \"file:\"+file+fmt.Sprintf(\"?_auth&_auth_user=%s&_auth_pass=%s&_auth_crypt=%s&_auth_salt=%s\", username, password, crypt, salt))\n\t\tif err != nil {\n\t\t\tdefer os.Remove(file)\n\t\t\treturn file, nil, nil, err\n\t\t}\n\n\t\t// Dummy query to force connection and database creation\n\t\t// Will return ErrUnauthorized (SQLITE_AUTH) if user authentication fails\n\t\tif _, err = db.Exec(\"SELECT 1;\"); err != nil {\n\t\t\tdefer os.Remove(file)\n\t\t\tdefer db.Close()\n\t\t\treturn file, nil, nil, err\n\t\t}\n\t\tc = conn\n\n\t\treturn\n\t}\n\n\tauthEnabled = func(db *sql.DB) (exists bool, err error) {\n\t\terr = db.QueryRow(\"select count(type) from sqlite_master WHERE type='table' and name='sqlite_user';\").Scan(&exists)\n\t\treturn\n\t}\n\n\taddUser = func(db *sql.DB, username, password string, admin int) (rv int, err error) {\n\t\terr = db.QueryRow(\"select auth_user_add(?, ?, ?);\", username, password, admin).Scan(&rv)\n\t\treturn\n\t}\n\n\tuserExists = func(db *sql.DB, username string) (rv int, err error) {\n\t\terr = db.QueryRow(\"select count(uname) from sqlite_user where uname=?\", username).Scan(&rv)\n\t\treturn\n\t}\n\n\tisAdmin = func(db *sql.DB, username string) (rv bool, err error) {\n\t\terr = db.QueryRow(\"select isAdmin from sqlite_user where uname=?\", username).Scan(&rv)\n\t\treturn\n\t}\n\n\tmodifyUser = func(db *sql.DB, username, password string, admin int) (rv int, err error) {\n\t\terr = db.QueryRow(\"select auth_user_change(?, ?, ?);\", username, password, admin).Scan(&rv)\n\t\treturn\n\t}\n\n\tdeleteUser = func(db *sql.DB, username string) (rv int, err error) {\n\t\terr = db.QueryRow(\"select auth_user_delete(?);\", username).Scan(&rv)\n\t\treturn\n\t}\n}\n\nfunc TestUserAuthCreateDatabase(t *testing.T) {\n\tf, db, c, err := connect(t, \"\", \"admin\", \"admin\")\n\tif err != nil && c == nil && db == nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\tdefer os.Remove(f)\n\n\tenabled, err := authEnabled(db)\n\tif err != nil || !enabled {\n\t\tt.Fatalf(\"UserAuth not enabled: %s\", err)\n\t}\n\n\te, err := userExists(db, \"admin\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif e != 1 {\n\t\tt.Fatal(\"UserAuth: admin does not exists\")\n\t}\n\ta, err := isAdmin(db, \"admin\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !a {\n\t\tt.Fatal(\"UserAuth: User is not administrator\")\n\t}\n}\n\nfunc TestUserAuthCreateDatabaseWithoutArgs(t *testing.T) {\n\t_, db, c, err := connect(t, \"\", \"\", \"\")\n\tif err == nil && c == nil && db == nil {\n\t\tt.Fatal(\"Should have failed due to missing _auth_* parameters\")\n\t}\n\n\t_, db, c, err = connect(t, \"\", \"\", \"admin\")\n\tif err == nil && c == nil && db == nil {\n\t\tt.Fatal(\"Should have failed due to missing _auth_user parameter\")\n\t}\n\n\t_, db, c, err = connect(t, \"\", \"admin\", \"\")\n\tif err == nil && c == nil && db == nil {\n\t\tt.Fatal(\"Should have failed due to missing _auth_pass parameter\")\n\t}\n}\n\nfunc TestUserAuthLogin(t *testing.T) {\n\tf1, err := create(t, \"admin\", \"admin\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(f1)\n\n\tf2, db2, c2, err := connect(t, f1, \"admin\", \"admin\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db2.Close()\n\tif f1 != f2 {\n\t\tt.Fatal(\"UserAuth: Database file mismatch\")\n\t}\n\n\t// Test lower level authentication\n\terr = c2.Authenticate(\"admin\", \"admin\")\n\tif err != nil {\n\t\tt.Fatalf(\"UserAuth: *SQLiteConn.Authenticate() Failed: %s\", err)\n\t}\n\n\t// Test Login Failed\n\t_, _, _, err = connect(t, f1, \"admin\", \"invalid\")\n\tif err == nil {\n\t\tt.Fatal(\"Login successful while expecting to fail\")\n\t}\n\tif err != ErrUnauthorized {\n\t\tt.Fatal(err)\n\t}\n\terr = c2.Authenticate(\"admin\", \"invalid\")\n\tif err == nil {\n\t\tt.Fatal(\"Login successful while expecting to fail\")\n\t}\n\tif err != ErrUnauthorized {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestUserAuthAddAdmin(t *testing.T) {\n\tf, db, c, err := connect(t, \"\", \"admin\", \"admin\")\n\tif err != nil && c == nil && db == nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\tdefer os.Remove(f)\n\n\t// Add Admin User through SQL call\n\trv, err := addUser(db, \"admin2\", \"admin2\", 1)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif rv != 0 {\n\t\tt.Fatal(\"Failed to add user\")\n\t}\n\n\t// Check if user was created\n\texists, err := userExists(db, \"admin2\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif exists != 1 {\n\t\tt.Fatal(\"UserAuth: 'admin2' does not exists\")\n\t}\n\n\t// Check if user was created as an Administrator\n\tadmin, err := isAdmin(db, \"admin2\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !admin {\n\t\tt.Fatal(\"UserAuth: 'admin2' is not administrator\")\n\t}\n\n\t// Test *SQLiteConn\n\terr = c.AuthUserAdd(\"admin3\", \"admin3\", true)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Check if user was created\n\texists, err = userExists(db, \"admin2\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif exists != 1 {\n\t\tt.Fatal(\"UserAuth: 'admin3' does not exists\")\n\t}\n\n\t// Check if the user was created as an Administrator\n\tadmin, err = isAdmin(db, \"admin3\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !admin {\n\t\tt.Fatal(\"UserAuth: 'admin3' is not administrator\")\n\t}\n}\n\nfunc TestUserAuthAddUser(t *testing.T) {\n\tf1, db1, c, err := connect(t, \"\", \"admin\", \"admin\")\n\tif err != nil && c == nil && db == nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(f1)\n\n\t// Add user through SQL call\n\trv, err := addUser(db1, \"user\", \"user\", 0)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif rv != 0 {\n\t\tt.Fatal(\"Failed to add user\")\n\t}\n\n\t// Check if user was created\n\texists, err := userExists(db1, \"user\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif exists != 1 {\n\t\tt.Fatal(\"UserAuth: 'user' does not exists\")\n\t}\n\n\t// Check if user was created as an Administrator\n\tadmin, err := isAdmin(db1, \"user\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif admin {\n\t\tt.Fatal(\"UserAuth: 'user' is administrator\")\n\t}\n\n\t// Test *SQLiteConn\n\terr = c.AuthUserAdd(\"user2\", \"user2\", false)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Check if user was created\n\texists, err = userExists(db1, \"user2\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif exists != 1 {\n\t\tt.Fatal(\"UserAuth: 'user2' does not exists\")\n\t}\n\n\t// Check if the user was created as an Administrator\n\tadmin, err = isAdmin(db1, \"user2\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif admin {\n\t\tt.Fatal(\"UserAuth: 'user2' is administrator\")\n\t}\n\n\t// Reconnect as normal user\n\tdb1.Close()\n\t_, db2, c2, err := connect(t, f1, \"user\", \"user\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db2.Close()\n\n\t// Try to create admin user while logged in as normal user\n\trv, err = addUser(db2, \"admin2\", \"admin2\", 1)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif rv != SQLITE_AUTH {\n\t\tt.Fatal(\"Created admin user while not allowed\")\n\t}\n\n\terr = c2.AuthUserAdd(\"admin3\", \"admin3\", true)\n\tif err != ErrAdminRequired {\n\t\tt.Fatal(\"Created admin user while not allowed\")\n\t}\n\n\t// Try to create normal user while logged in as normal user\n\trv, err = addUser(db2, \"user3\", \"user3\", 0)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif rv != SQLITE_AUTH {\n\t\tt.Fatal(\"Created user while not allowed\")\n\t}\n\n\terr = c2.AuthUserAdd(\"user4\", \"user4\", false)\n\tif err != ErrAdminRequired {\n\t\tt.Fatal(\"Created user while not allowed\")\n\t}\n}\n\nfunc TestUserAuthModifyUser(t *testing.T) {\n\tf1, db1, c1, err := connect(t, \"\", \"admin\", \"admin\")\n\tif err != nil && c1 == nil && db == nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(f1)\n\n\t// Modify Password for current logged in admin\n\t// through SQL\n\trv, err := modifyUser(db1, \"admin\", \"admin2\", 1)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif rv != 0 {\n\t\tt.Fatal(\"Failed to modify password for admin\")\n\t}\n\n\t// Modify password for current logged in admin\n\t// through *SQLiteConn\n\terr = c1.AuthUserChange(\"admin\", \"admin3\", true)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Modify Administrator Flag\n\t// Because we are current logged in as 'admin'\n\t// Changing our own admin flag should fail.\n\trv, err = modifyUser(db1, \"admin\", \"admin3\", 0)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif rv != SQLITE_AUTH {\n\t\tt.Fatal(\"Successfully changed admin flag while not allowed\")\n\t}\n\n\t// Modify admin flag through (*SQLiteConn)\n\t// Because we are current logged in as 'admin'\n\t// Changing our own admin flag should fail.\n\terr = c1.AuthUserChange(\"admin\", \"admin3\", false)\n\tif err != ErrAdminRequired {\n\t\tt.Fatal(\"Successfully changed admin flag while not allowed\")\n\t}\n\n\t// Add normal user\n\trv, err = addUser(db1, \"user\", \"password\", 0)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif rv != 0 {\n\t\tt.Fatal(\"Failed to add user\")\n\t}\n\n\trv, err = addUser(db1, \"user2\", \"user2\", 0)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif rv != 0 {\n\t\tt.Fatal(\"Failed to add user\")\n\t}\n\n\t// Modify other user password and flag through SQL\n\trv, err = modifyUser(db1, \"user\", \"pass\", 1)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif rv != 0 {\n\t\tt.Fatal(\"Failed to modify password for user\")\n\t}\n\n\t// Modify other user password and flag through *SQLiteConn\n\terr = c1.AuthUserChange(\"user\", \"newpass\", false)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Disconnect database for reconnect\n\tdb1.Close()\n\t_, db2, c2, err := connect(t, f1, \"user\", \"newpass\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db2.Close()\n\n\t// Modify other user password through SQL\n\trv, err = modifyUser(db2, \"user2\", \"newpass\", 0)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif rv != SQLITE_AUTH {\n\t\tt.Fatal(\"Password change successful while not allowed\")\n\t}\n\n\t// Modify other user password and flag through *SQLiteConn\n\terr = c2.AuthUserChange(\"user2\", \"invalid\", false)\n\tif err != ErrAdminRequired {\n\t\tt.Fatal(\"Password change successful while not allowed\")\n\t}\n}\n\nfunc TestUserAuthDeleteUser(t *testing.T) {\n\tf1, db1, c, err := connect(t, \"\", \"admin\", \"admin\")\n\tif err != nil && c == nil && db == nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(f1)\n\n\t// Add Admin User 2\n\trv, err := addUser(db1, \"admin2\", \"admin2\", 1)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif rv != 0 {\n\t\tt.Fatal(\"Failed to add user\")\n\t}\n\n\trv, err = addUser(db1, \"admin3\", \"admin3\", 1)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif rv != 0 {\n\t\tt.Fatal(\"Failed to add user\")\n\t}\n\n\t// Check if user was created\n\texists, err := userExists(db1, \"admin2\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif exists != 1 {\n\t\tt.Fatal(\"UserAuth: 'admin2' does not exists\")\n\t}\n\n\texists, err = userExists(db1, \"admin3\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif exists != 1 {\n\t\tt.Fatal(\"UserAuth: 'admin2' does not exists\")\n\t}\n\n\t// Delete user through SQL\n\trv, err = deleteUser(db1, \"admin2\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif rv != 0 {\n\t\tt.Fatal(\"Failed to delete admin2\")\n\t}\n\n\t// Verify user admin2 deleted\n\texists, err = userExists(db1, \"admin2\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif exists != 0 {\n\t\tt.Fatal(\"UserAuth: 'admin2' still exists\")\n\t}\n\n\t// Delete user through *SQLiteConn\n\trv, err = deleteUser(db1, \"admin3\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif rv != 0 {\n\t\tt.Fatal(\"Failed to delete admin3\")\n\t}\n\n\t// Verify user admin3 deleted\n\texists, err = userExists(db1, \"admin3\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif exists != 0 {\n\t\tt.Fatal(\"UserAuth: 'admin3' still exists\")\n\t}\n\n\t// Add normal user for reconnect and privileges check\n\trv, err = addUser(db1, \"reconnect\", \"reconnect\", 0)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif rv != 0 {\n\t\tt.Fatal(\"Failed to add user\")\n\t}\n\n\t// Add normal user for deletion through SQL\n\trv, err = addUser(db1, \"user\", \"user\", 0)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif rv != 0 {\n\t\tt.Fatal(\"Failed to add user\")\n\t}\n\n\trv, err = addUser(db1, \"user2\", \"user2\", 0)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif rv != 0 {\n\t\tt.Fatal(\"Failed to add user\")\n\t}\n\n\t// Close database for reconnect\n\tdb1.Close()\n\n\t// Reconnect as normal user\n\t_, db2, c2, err := connect(t, f1, \"reconnect\", \"reconnect\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db2.Close()\n\n\t// Delete user while logged in as normal user\n\t// through SQL\n\trv, err = deleteUser(db2, \"user\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif rv != SQLITE_AUTH {\n\t\tt.Fatal(\"Successfully deleted user wthout proper privileges\")\n\t}\n\n\t// Delete user while logged in as normal user\n\t// through *SQLiteConn\n\terr = c2.AuthUserDelete(\"user2\")\n\tif err != ErrAdminRequired {\n\t\tt.Fatal(\"Successfully deleted user wthout proper privileges\")\n\t}\n}\n\nfunc TestUserAuthEncoders(t *testing.T) {\n\tcases := map[string]string{\n\t\t\"sha1\":    \"\",\n\t\t\"ssha1\":   \"salted\",\n\t\t\"sha256\":  \"\",\n\t\t\"ssha256\": \"salted\",\n\t\t\"sha384\":  \"\",\n\t\t\"ssha384\": \"salted\",\n\t\t\"sha512\":  \"\",\n\t\t\"ssha512\": \"salted\",\n\t}\n\n\tfor enc, salt := range cases {\n\t\tf, err := createWithCrypt(t, \"admin\", \"admin\", enc, salt)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tdefer os.Remove(f)\n\n\t\t_, db, _, err := connectWithCrypt(t, f, \"admin\", \"admin\", enc, salt)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tdefer db.Close()\n\t\tif e, err := authEnabled(db); err != nil && !e {\n\t\t\tt.Fatalf(\"UserAuth (%s) not enabled %s\", enc, err)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "sqlite3_opt_vacuum_full.go",
          "type": "blob",
          "size": 0.3779296875,
          "content": "// Copyright (C) 2019 Yasuhiro Matsumoto <mattn.jp@gmail.com>.\n// Copyright (C) 2018 G.J.R. Timmer <gjr.timmer@gmail.com>.\n//\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n//go:build sqlite_vacuum_full\n// +build sqlite_vacuum_full\n\npackage sqlite3\n\n/*\n#cgo CFLAGS: -DSQLITE_DEFAULT_AUTOVACUUM=1\n#cgo LDFLAGS: -lm\n*/\nimport \"C\"\n"
        },
        {
          "name": "sqlite3_opt_vacuum_incr.go",
          "type": "blob",
          "size": 0.3779296875,
          "content": "// Copyright (C) 2019 Yasuhiro Matsumoto <mattn.jp@gmail.com>.\n// Copyright (C) 2018 G.J.R. Timmer <gjr.timmer@gmail.com>.\n//\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n//go:build sqlite_vacuum_incr\n// +build sqlite_vacuum_incr\n\npackage sqlite3\n\n/*\n#cgo CFLAGS: -DSQLITE_DEFAULT_AUTOVACUUM=2\n#cgo LDFLAGS: -lm\n*/\nimport \"C\"\n"
        },
        {
          "name": "sqlite3_opt_vtable.go",
          "type": "blob",
          "size": 19.8798828125,
          "content": "// Copyright (C) 2019 Yasuhiro Matsumoto <mattn.jp@gmail.com>.\n//\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n//go:build sqlite_vtable || vtable\n// +build sqlite_vtable vtable\n\npackage sqlite3\n\n/*\n#cgo CFLAGS: -std=gnu99\n#cgo CFLAGS: -DSQLITE_ENABLE_RTREE\n#cgo CFLAGS: -DSQLITE_THREADSAFE\n#cgo CFLAGS: -DSQLITE_ENABLE_FTS3\n#cgo CFLAGS: -DSQLITE_ENABLE_FTS3_PARENTHESIS\n#cgo CFLAGS: -DSQLITE_ENABLE_FTS4_UNICODE61\n#cgo CFLAGS: -DSQLITE_TRACE_SIZE_LIMIT=15\n#cgo CFLAGS: -DSQLITE_ENABLE_COLUMN_METADATA=1\n#cgo CFLAGS: -Wno-deprecated-declarations\n\n#ifndef USE_LIBSQLITE3\n#include \"sqlite3-binding.h\"\n#else\n#include <sqlite3.h>\n#endif\n#include <stdlib.h>\n#include <stdint.h>\n#include <memory.h>\n\nstatic inline char *_sqlite3_mprintf(char *zFormat, char *arg) {\n  return sqlite3_mprintf(zFormat, arg);\n}\n\ntypedef struct goVTab goVTab;\n\nstruct goVTab {\n\tsqlite3_vtab base;\n\tvoid *vTab;\n};\n\nuintptr_t goMInit(void *db, void *pAux, int argc, char **argv, char **pzErr, int isCreate);\n\nstatic int cXInit(sqlite3 *db, void *pAux, int argc, const char *const*argv, sqlite3_vtab **ppVTab, char **pzErr, int isCreate) {\n\tvoid *vTab = (void *)goMInit(db, pAux, argc, (char**)argv, pzErr, isCreate);\n\tif (!vTab || *pzErr) {\n\t\treturn SQLITE_ERROR;\n\t}\n\tgoVTab *pvTab = (goVTab *)sqlite3_malloc(sizeof(goVTab));\n\tif (!pvTab) {\n\t\t*pzErr = sqlite3_mprintf(\"%s\", \"Out of memory\");\n\t\treturn SQLITE_NOMEM;\n\t}\n\tmemset(pvTab, 0, sizeof(goVTab));\n\tpvTab->vTab = vTab;\n\n\t*ppVTab = (sqlite3_vtab *)pvTab;\n\t*pzErr = 0;\n\treturn SQLITE_OK;\n}\n\nstatic inline int cXCreate(sqlite3 *db, void *pAux, int argc, const char *const*argv, sqlite3_vtab **ppVTab, char **pzErr) {\n\treturn cXInit(db, pAux, argc, argv, ppVTab, pzErr, 1);\n}\nstatic inline int cXConnect(sqlite3 *db, void *pAux, int argc, const char *const*argv, sqlite3_vtab **ppVTab, char **pzErr) {\n\treturn cXInit(db, pAux, argc, argv, ppVTab, pzErr, 0);\n}\n\nchar* goVBestIndex(void *pVTab, void *icp);\n\nstatic inline int cXBestIndex(sqlite3_vtab *pVTab, sqlite3_index_info *info) {\n\tchar *pzErr = goVBestIndex(((goVTab*)pVTab)->vTab, info);\n\tif (pzErr) {\n\t\tif (pVTab->zErrMsg)\n\t\t\tsqlite3_free(pVTab->zErrMsg);\n\t\tpVTab->zErrMsg = pzErr;\n\t\treturn SQLITE_ERROR;\n\t}\n\treturn SQLITE_OK;\n}\n\nchar* goVRelease(void *pVTab, int isDestroy);\n\nstatic int cXRelease(sqlite3_vtab *pVTab, int isDestroy) {\n\tchar *pzErr = goVRelease(((goVTab*)pVTab)->vTab, isDestroy);\n\tif (pzErr) {\n\t\tif (pVTab->zErrMsg)\n\t\t\tsqlite3_free(pVTab->zErrMsg);\n\t\tpVTab->zErrMsg = pzErr;\n\t\treturn SQLITE_ERROR;\n\t}\n\tif (pVTab->zErrMsg)\n\t\tsqlite3_free(pVTab->zErrMsg);\n\tsqlite3_free(pVTab);\n\treturn SQLITE_OK;\n}\n\nstatic inline int cXDisconnect(sqlite3_vtab *pVTab) {\n\treturn cXRelease(pVTab, 0);\n}\nstatic inline int cXDestroy(sqlite3_vtab *pVTab) {\n\treturn cXRelease(pVTab, 1);\n}\n\ntypedef struct goVTabCursor goVTabCursor;\n\nstruct goVTabCursor {\n\tsqlite3_vtab_cursor base;\n\tvoid *vTabCursor;\n};\n\nuintptr_t goVOpen(void *pVTab, char **pzErr);\n\nstatic int cXOpen(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor) {\n\tvoid *vTabCursor = (void *)goVOpen(((goVTab*)pVTab)->vTab, &(pVTab->zErrMsg));\n\tgoVTabCursor *pCursor = (goVTabCursor *)sqlite3_malloc(sizeof(goVTabCursor));\n\tif (!pCursor) {\n\t\treturn SQLITE_NOMEM;\n\t}\n\tmemset(pCursor, 0, sizeof(goVTabCursor));\n\tpCursor->vTabCursor = vTabCursor;\n\t*ppCursor = (sqlite3_vtab_cursor *)pCursor;\n\treturn SQLITE_OK;\n}\n\nstatic int setErrMsg(sqlite3_vtab_cursor *pCursor, char *pzErr) {\n\tif (pCursor->pVtab->zErrMsg)\n\t\tsqlite3_free(pCursor->pVtab->zErrMsg);\n\tpCursor->pVtab->zErrMsg = pzErr;\n\treturn SQLITE_ERROR;\n}\n\nchar* goVClose(void *pCursor);\n\nstatic int cXClose(sqlite3_vtab_cursor *pCursor) {\n\tchar *pzErr = goVClose(((goVTabCursor*)pCursor)->vTabCursor);\n\tif (pzErr) {\n\t\treturn setErrMsg(pCursor, pzErr);\n\t}\n\tsqlite3_free(pCursor);\n\treturn SQLITE_OK;\n}\n\nchar* goVFilter(void *pCursor, int idxNum, char* idxName, int argc, sqlite3_value **argv);\n\nstatic int cXFilter(sqlite3_vtab_cursor *pCursor, int idxNum, const char *idxStr, int argc, sqlite3_value **argv) {\n\tchar *pzErr = goVFilter(((goVTabCursor*)pCursor)->vTabCursor, idxNum, (char*)idxStr, argc, argv);\n\tif (pzErr) {\n\t\treturn setErrMsg(pCursor, pzErr);\n\t}\n\treturn SQLITE_OK;\n}\n\nchar* goVNext(void *pCursor);\n\nstatic int cXNext(sqlite3_vtab_cursor *pCursor) {\n\tchar *pzErr = goVNext(((goVTabCursor*)pCursor)->vTabCursor);\n\tif (pzErr) {\n\t\treturn setErrMsg(pCursor, pzErr);\n\t}\n\treturn SQLITE_OK;\n}\n\nint goVEof(void *pCursor);\n\nstatic inline int cXEof(sqlite3_vtab_cursor *pCursor) {\n\treturn goVEof(((goVTabCursor*)pCursor)->vTabCursor);\n}\n\nchar* goVColumn(void *pCursor, void *cp, int col);\n\nstatic int cXColumn(sqlite3_vtab_cursor *pCursor, sqlite3_context *ctx, int i) {\n\tchar *pzErr = goVColumn(((goVTabCursor*)pCursor)->vTabCursor, ctx, i);\n\tif (pzErr) {\n\t\treturn setErrMsg(pCursor, pzErr);\n\t}\n\treturn SQLITE_OK;\n}\n\nchar* goVRowid(void *pCursor, sqlite3_int64 *pRowid);\n\nstatic int cXRowid(sqlite3_vtab_cursor *pCursor, sqlite3_int64 *pRowid) {\n\tchar *pzErr = goVRowid(((goVTabCursor*)pCursor)->vTabCursor, pRowid);\n\tif (pzErr) {\n\t\treturn setErrMsg(pCursor, pzErr);\n\t}\n\treturn SQLITE_OK;\n}\n\nchar* goVUpdate(void *pVTab, int argc, sqlite3_value **argv, sqlite3_int64 *pRowid);\n\nstatic int cXUpdate(sqlite3_vtab *pVTab, int argc, sqlite3_value **argv, sqlite3_int64 *pRowid) {\n\tchar *pzErr = goVUpdate(((goVTab*)pVTab)->vTab, argc, argv, pRowid);\n\tif (pzErr) {\n\t\tif (pVTab->zErrMsg)\n\t\t\tsqlite3_free(pVTab->zErrMsg);\n\t\tpVTab->zErrMsg = pzErr;\n\t\treturn SQLITE_ERROR;\n\t}\n\treturn SQLITE_OK;\n}\n\nstatic sqlite3_module goModule = {\n\t0,                       // iVersion\n\tcXCreate,                // xCreate - create a table\n\tcXConnect,               // xConnect - connect to an existing table\n\tcXBestIndex,             // xBestIndex - Determine search strategy\n\tcXDisconnect,            // xDisconnect - Disconnect from a table\n\tcXDestroy,               // xDestroy - Drop a table\n\tcXOpen,                  // xOpen - open a cursor\n\tcXClose,                 // xClose - close a cursor\n\tcXFilter,                // xFilter - configure scan constraints\n\tcXNext,                  // xNext - advance a cursor\n\tcXEof,                   // xEof\n\tcXColumn,                // xColumn - read data\n\tcXRowid,                 // xRowid - read data\n\tcXUpdate,                // xUpdate - write data\n// Not implemented\n\t0,                       // xBegin - begin transaction\n\t0,                       // xSync - sync transaction\n\t0,                       // xCommit - commit transaction\n\t0,                       // xRollback - rollback transaction\n\t0,                       // xFindFunction - function overloading\n\t0,                       // xRename - rename the table\n\t0,                       // xSavepoint\n\t0,                       // xRelease\n\t0\t                     // xRollbackTo\n};\n\n// See https://sqlite.org/vtab.html#eponymous_only_virtual_tables\nstatic sqlite3_module goModuleEponymousOnly = {\n\t0,                       // iVersion\n\t0,                       // xCreate - create a table, which here is null\n\tcXConnect,               // xConnect - connect to an existing table\n\tcXBestIndex,             // xBestIndex - Determine search strategy\n\tcXDisconnect,            // xDisconnect - Disconnect from a table\n\tcXDestroy,               // xDestroy - Drop a table\n\tcXOpen,                  // xOpen - open a cursor\n\tcXClose,                 // xClose - close a cursor\n\tcXFilter,                // xFilter - configure scan constraints\n\tcXNext,                  // xNext - advance a cursor\n\tcXEof,                   // xEof\n\tcXColumn,                // xColumn - read data\n\tcXRowid,                 // xRowid - read data\n\tcXUpdate,                // xUpdate - write data\n// Not implemented\n\t0,                       // xBegin - begin transaction\n\t0,                       // xSync - sync transaction\n\t0,                       // xCommit - commit transaction\n\t0,                       // xRollback - rollback transaction\n\t0,                       // xFindFunction - function overloading\n\t0,                       // xRename - rename the table\n\t0,                       // xSavepoint\n\t0,                       // xRelease\n\t0\t                     // xRollbackTo\n};\n\nvoid goMDestroy(void*);\n\nstatic int _sqlite3_create_module(sqlite3 *db, const char *zName, uintptr_t pClientData) {\n  return sqlite3_create_module_v2(db, zName, &goModule, (void*) pClientData, goMDestroy);\n}\n\nstatic int _sqlite3_create_module_eponymous_only(sqlite3 *db, const char *zName, uintptr_t pClientData) {\n  return sqlite3_create_module_v2(db, zName, &goModuleEponymousOnly, (void*) pClientData, goMDestroy);\n}\n*/\nimport \"C\"\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"reflect\"\n\t\"unsafe\"\n)\n\ntype sqliteModule struct {\n\tc      *SQLiteConn\n\tname   string\n\tmodule Module\n}\n\ntype sqliteVTab struct {\n\tmodule *sqliteModule\n\tvTab   VTab\n}\n\ntype sqliteVTabCursor struct {\n\tvTab       *sqliteVTab\n\tvTabCursor VTabCursor\n}\n\n// Op is type of operations.\ntype Op uint8\n\n// Op mean identity of operations.\nconst (\n\tOpEQ         Op = 2\n\tOpGT            = 4\n\tOpLE            = 8\n\tOpLT            = 16\n\tOpGE            = 32\n\tOpMATCH         = 64\n\tOpLIKE          = 65 /* 3.10.0 and later only */\n\tOpGLOB          = 66 /* 3.10.0 and later only */\n\tOpREGEXP        = 67 /* 3.10.0 and later only */\n\tOpScanUnique    = 1  /* Scan visits at most 1 row */\n)\n\n// InfoConstraint give information of constraint.\ntype InfoConstraint struct {\n\tColumn int\n\tOp     Op\n\tUsable bool\n}\n\n// InfoOrderBy give information of order-by.\ntype InfoOrderBy struct {\n\tColumn int\n\tDesc   bool\n}\n\nfunc constraints(info *C.sqlite3_index_info) []InfoConstraint {\n\tslice := *(*[]C.struct_sqlite3_index_constraint)(unsafe.Pointer(&reflect.SliceHeader{\n\t\tData: uintptr(unsafe.Pointer(info.aConstraint)),\n\t\tLen:  int(info.nConstraint),\n\t\tCap:  int(info.nConstraint),\n\t}))\n\n\tcst := make([]InfoConstraint, 0, len(slice))\n\tfor _, c := range slice {\n\t\tvar usable bool\n\t\tif c.usable > 0 {\n\t\t\tusable = true\n\t\t}\n\t\tcst = append(cst, InfoConstraint{\n\t\t\tColumn: int(c.iColumn),\n\t\t\tOp:     Op(c.op),\n\t\t\tUsable: usable,\n\t\t})\n\t}\n\treturn cst\n}\n\nfunc orderBys(info *C.sqlite3_index_info) []InfoOrderBy {\n\tslice := *(*[]C.struct_sqlite3_index_orderby)(unsafe.Pointer(&reflect.SliceHeader{\n\t\tData: uintptr(unsafe.Pointer(info.aOrderBy)),\n\t\tLen:  int(info.nOrderBy),\n\t\tCap:  int(info.nOrderBy),\n\t}))\n\n\tob := make([]InfoOrderBy, 0, len(slice))\n\tfor _, c := range slice {\n\t\tvar desc bool\n\t\tif c.desc > 0 {\n\t\t\tdesc = true\n\t\t}\n\t\tob = append(ob, InfoOrderBy{\n\t\t\tColumn: int(c.iColumn),\n\t\t\tDesc:   desc,\n\t\t})\n\t}\n\treturn ob\n}\n\n// IndexResult is a Go struct representation of what eventually ends up in the\n// output fields for `sqlite3_index_info`\n// See: https://www.sqlite.org/c3ref/index_info.html\ntype IndexResult struct {\n\tUsed           []bool // aConstraintUsage\n\tIdxNum         int\n\tIdxStr         string\n\tAlreadyOrdered bool // orderByConsumed\n\tEstimatedCost  float64\n\tEstimatedRows  float64\n}\n\n// mPrintf is a utility wrapper around sqlite3_mprintf\nfunc mPrintf(format, arg string) *C.char {\n\tcf := C.CString(format)\n\tdefer C.free(unsafe.Pointer(cf))\n\tca := C.CString(arg)\n\tdefer C.free(unsafe.Pointer(ca))\n\treturn C._sqlite3_mprintf(cf, ca)\n}\n\n//export goMInit\nfunc goMInit(db, pClientData unsafe.Pointer, argc C.int, argv **C.char, pzErr **C.char, isCreate C.int) C.uintptr_t {\n\tm := lookupHandle(pClientData).(*sqliteModule)\n\tif m.c.db != (*C.sqlite3)(db) {\n\t\t*pzErr = mPrintf(\"%s\", \"Inconsistent db handles\")\n\t\treturn 0\n\t}\n\targs := make([]string, argc)\n\tvar A []*C.char\n\tslice := reflect.SliceHeader{Data: uintptr(unsafe.Pointer(argv)), Len: int(argc), Cap: int(argc)}\n\ta := reflect.NewAt(reflect.TypeOf(A), unsafe.Pointer(&slice)).Elem().Interface()\n\tfor i, s := range a.([]*C.char) {\n\t\targs[i] = C.GoString(s)\n\t}\n\tvar vTab VTab\n\tvar err error\n\tif isCreate == 1 {\n\t\tvTab, err = m.module.Create(m.c, args)\n\t} else {\n\t\tvTab, err = m.module.Connect(m.c, args)\n\t}\n\n\tif err != nil {\n\t\t*pzErr = mPrintf(\"%s\", err.Error())\n\t\treturn 0\n\t}\n\tvt := sqliteVTab{m, vTab}\n\t*pzErr = nil\n\treturn C.uintptr_t(uintptr(newHandle(m.c, &vt)))\n}\n\n//export goVRelease\nfunc goVRelease(pVTab unsafe.Pointer, isDestroy C.int) *C.char {\n\tvt := lookupHandle(pVTab).(*sqliteVTab)\n\tvar err error\n\tif isDestroy == 1 {\n\t\terr = vt.vTab.Destroy()\n\t} else {\n\t\terr = vt.vTab.Disconnect()\n\t}\n\tif err != nil {\n\t\treturn mPrintf(\"%s\", err.Error())\n\t}\n\treturn nil\n}\n\n//export goVOpen\nfunc goVOpen(pVTab unsafe.Pointer, pzErr **C.char) C.uintptr_t {\n\tvt := lookupHandle(pVTab).(*sqliteVTab)\n\tvTabCursor, err := vt.vTab.Open()\n\tif err != nil {\n\t\t*pzErr = mPrintf(\"%s\", err.Error())\n\t\treturn 0\n\t}\n\tvtc := sqliteVTabCursor{vt, vTabCursor}\n\t*pzErr = nil\n\treturn C.uintptr_t(uintptr(newHandle(vt.module.c, &vtc)))\n}\n\n//export goVBestIndex\nfunc goVBestIndex(pVTab unsafe.Pointer, icp unsafe.Pointer) *C.char {\n\tvt := lookupHandle(pVTab).(*sqliteVTab)\n\tinfo := (*C.sqlite3_index_info)(icp)\n\tcsts := constraints(info)\n\tres, err := vt.vTab.BestIndex(csts, orderBys(info))\n\tif err != nil {\n\t\treturn mPrintf(\"%s\", err.Error())\n\t}\n\tif len(res.Used) != len(csts) {\n\t\treturn mPrintf(\"Result.Used != expected value\", \"\")\n\t}\n\n\t// Get a pointer to constraint_usage struct so we can update in place.\n\n\tslice := *(*[]C.struct_sqlite3_index_constraint_usage)(unsafe.Pointer(&reflect.SliceHeader{\n\t\tData: uintptr(unsafe.Pointer(info.aConstraintUsage)),\n\t\tLen:  int(info.nConstraint),\n\t\tCap:  int(info.nConstraint),\n\t}))\n\tindex := 1\n\tfor i := range slice {\n\t\tif res.Used[i] {\n\t\t\tslice[i].argvIndex = C.int(index)\n\t\t\tslice[i].omit = C.uchar(1)\n\t\t\tindex++\n\t\t}\n\t}\n\n\tinfo.idxNum = C.int(res.IdxNum)\n\tinfo.idxStr = (*C.char)(C.sqlite3_malloc(C.int(len(res.IdxStr) + 1)))\n\tif info.idxStr == nil {\n\t\t// C.malloc and C.CString ordinarily do this for you. See https://golang.org/cmd/cgo/\n\t\tpanic(\"out of memory\")\n\t}\n\tinfo.needToFreeIdxStr = C.int(1)\n\n\tidxStr := *(*[]byte)(unsafe.Pointer(&reflect.SliceHeader{\n\t\tData: uintptr(unsafe.Pointer(info.idxStr)),\n\t\tLen:  len(res.IdxStr) + 1,\n\t\tCap:  len(res.IdxStr) + 1,\n\t}))\n\tcopy(idxStr, res.IdxStr)\n\tidxStr[len(idxStr)-1] = 0 // null-terminated string\n\n\tif res.AlreadyOrdered {\n\t\tinfo.orderByConsumed = C.int(1)\n\t}\n\tinfo.estimatedCost = C.double(res.EstimatedCost)\n\tinfo.estimatedRows = C.sqlite3_int64(res.EstimatedRows)\n\n\treturn nil\n}\n\n//export goVClose\nfunc goVClose(pCursor unsafe.Pointer) *C.char {\n\tvtc := lookupHandle(pCursor).(*sqliteVTabCursor)\n\terr := vtc.vTabCursor.Close()\n\tif err != nil {\n\t\treturn mPrintf(\"%s\", err.Error())\n\t}\n\treturn nil\n}\n\n//export goMDestroy\nfunc goMDestroy(pClientData unsafe.Pointer) {\n\tm := lookupHandle(pClientData).(*sqliteModule)\n\tm.module.DestroyModule()\n}\n\n//export goVFilter\nfunc goVFilter(pCursor unsafe.Pointer, idxNum C.int, idxName *C.char, argc C.int, argv **C.sqlite3_value) *C.char {\n\tvtc := lookupHandle(pCursor).(*sqliteVTabCursor)\n\targs := (*[(math.MaxInt32 - 1) / unsafe.Sizeof((*C.sqlite3_value)(nil))]*C.sqlite3_value)(unsafe.Pointer(argv))[:argc:argc]\n\tvals := make([]any, 0, argc)\n\tfor _, v := range args {\n\t\tconv, err := callbackArgGeneric(v)\n\t\tif err != nil {\n\t\t\treturn mPrintf(\"%s\", err.Error())\n\t\t}\n\t\tvals = append(vals, conv.Interface())\n\t}\n\terr := vtc.vTabCursor.Filter(int(idxNum), C.GoString(idxName), vals)\n\tif err != nil {\n\t\treturn mPrintf(\"%s\", err.Error())\n\t}\n\treturn nil\n}\n\n//export goVNext\nfunc goVNext(pCursor unsafe.Pointer) *C.char {\n\tvtc := lookupHandle(pCursor).(*sqliteVTabCursor)\n\terr := vtc.vTabCursor.Next()\n\tif err != nil {\n\t\treturn mPrintf(\"%s\", err.Error())\n\t}\n\treturn nil\n}\n\n//export goVEof\nfunc goVEof(pCursor unsafe.Pointer) C.int {\n\tvtc := lookupHandle(pCursor).(*sqliteVTabCursor)\n\terr := vtc.vTabCursor.EOF()\n\tif err {\n\t\treturn 1\n\t}\n\treturn 0\n}\n\n//export goVColumn\nfunc goVColumn(pCursor, cp unsafe.Pointer, col C.int) *C.char {\n\tvtc := lookupHandle(pCursor).(*sqliteVTabCursor)\n\tc := (*SQLiteContext)(cp)\n\terr := vtc.vTabCursor.Column(c, int(col))\n\tif err != nil {\n\t\treturn mPrintf(\"%s\", err.Error())\n\t}\n\treturn nil\n}\n\n//export goVRowid\nfunc goVRowid(pCursor unsafe.Pointer, pRowid *C.sqlite3_int64) *C.char {\n\tvtc := lookupHandle(pCursor).(*sqliteVTabCursor)\n\trowid, err := vtc.vTabCursor.Rowid()\n\tif err != nil {\n\t\treturn mPrintf(\"%s\", err.Error())\n\t}\n\t*pRowid = C.sqlite3_int64(rowid)\n\treturn nil\n}\n\n//export goVUpdate\nfunc goVUpdate(pVTab unsafe.Pointer, argc C.int, argv **C.sqlite3_value, pRowid *C.sqlite3_int64) *C.char {\n\tvt := lookupHandle(pVTab).(*sqliteVTab)\n\n\tvar tname string\n\tif n, ok := vt.vTab.(interface {\n\t\tTableName() string\n\t}); ok {\n\t\ttname = n.TableName() + \" \"\n\t}\n\n\terr := fmt.Errorf(\"virtual %s table %sis read-only\", vt.module.name, tname)\n\tif v, ok := vt.vTab.(VTabUpdater); ok {\n\t\t// convert argv\n\t\targs := (*[(math.MaxInt32 - 1) / unsafe.Sizeof((*C.sqlite3_value)(nil))]*C.sqlite3_value)(unsafe.Pointer(argv))[:argc:argc]\n\t\tvals := make([]any, 0, argc)\n\t\tfor _, v := range args {\n\t\t\tconv, err := callbackArgGeneric(v)\n\t\t\tif err != nil {\n\t\t\t\treturn mPrintf(\"%s\", err.Error())\n\t\t\t}\n\n\t\t\t// work around for SQLITE_NULL\n\t\t\tx := conv.Interface()\n\t\t\tif z, ok := x.([]byte); ok && z == nil {\n\t\t\t\tx = nil\n\t\t\t}\n\n\t\t\tvals = append(vals, x)\n\t\t}\n\n\t\tswitch {\n\t\tcase argc == 1:\n\t\t\terr = v.Delete(vals[0])\n\n\t\tcase argc > 1 && vals[0] == nil:\n\t\t\tvar id int64\n\t\t\tid, err = v.Insert(vals[1], vals[2:])\n\t\t\tif err == nil {\n\t\t\t\t*pRowid = C.sqlite3_int64(id)\n\t\t\t}\n\n\t\tcase argc > 1:\n\t\t\terr = v.Update(vals[1], vals[2:])\n\t\t}\n\t}\n\n\tif err != nil {\n\t\treturn mPrintf(\"%s\", err.Error())\n\t}\n\n\treturn nil\n}\n\n// Module is a \"virtual table module\", it defines the implementation of a\n// virtual tables. See: http://sqlite.org/c3ref/module.html\ntype Module interface {\n\t// http://sqlite.org/vtab.html#xcreate\n\tCreate(c *SQLiteConn, args []string) (VTab, error)\n\t// http://sqlite.org/vtab.html#xconnect\n\tConnect(c *SQLiteConn, args []string) (VTab, error)\n\t// http://sqlite.org/c3ref/create_module.html\n\tDestroyModule()\n}\n\n// EponymousOnlyModule is a \"virtual table module\" (as above), but\n// for defining \"eponymous only\" virtual tables See: https://sqlite.org/vtab.html#eponymous_only_virtual_tables\ntype EponymousOnlyModule interface {\n\tModule\n\tEponymousOnlyModule()\n}\n\n// VTab describes a particular instance of the virtual table.\n// See: http://sqlite.org/c3ref/vtab.html\ntype VTab interface {\n\t// http://sqlite.org/vtab.html#xbestindex\n\tBestIndex([]InfoConstraint, []InfoOrderBy) (*IndexResult, error)\n\t// http://sqlite.org/vtab.html#xdisconnect\n\tDisconnect() error\n\t// http://sqlite.org/vtab.html#sqlite3_module.xDestroy\n\tDestroy() error\n\t// http://sqlite.org/vtab.html#xopen\n\tOpen() (VTabCursor, error)\n}\n\n// VTabUpdater is a type that allows a VTab to be inserted, updated, or\n// deleted.\n// See: https://sqlite.org/vtab.html#xupdate\ntype VTabUpdater interface {\n\tDelete(any) error\n\tInsert(any, []any) (int64, error)\n\tUpdate(any, []any) error\n}\n\n// VTabCursor describes cursors that point into the virtual table and are used\n// to loop through the virtual table. See: http://sqlite.org/c3ref/vtab_cursor.html\ntype VTabCursor interface {\n\t// http://sqlite.org/vtab.html#xclose\n\tClose() error\n\t// http://sqlite.org/vtab.html#xfilter\n\tFilter(idxNum int, idxStr string, vals []any) error\n\t// http://sqlite.org/vtab.html#xnext\n\tNext() error\n\t// http://sqlite.org/vtab.html#xeof\n\tEOF() bool\n\t// http://sqlite.org/vtab.html#xcolumn\n\tColumn(c *SQLiteContext, col int) error\n\t// http://sqlite.org/vtab.html#xrowid\n\tRowid() (int64, error)\n}\n\n// DeclareVTab declares the Schema of a virtual table.\n// See: http://sqlite.org/c3ref/declare_vtab.html\nfunc (c *SQLiteConn) DeclareVTab(sql string) error {\n\tzSQL := C.CString(sql)\n\tdefer C.free(unsafe.Pointer(zSQL))\n\trv := C.sqlite3_declare_vtab(c.db, zSQL)\n\tif rv != C.SQLITE_OK {\n\t\treturn c.lastError()\n\t}\n\treturn nil\n}\n\n// CreateModule registers a virtual table implementation.\n// See: http://sqlite.org/c3ref/create_module.html\nfunc (c *SQLiteConn) CreateModule(moduleName string, module Module) error {\n\tmname := C.CString(moduleName)\n\tdefer C.free(unsafe.Pointer(mname))\n\tudm := sqliteModule{c, moduleName, module}\n\tswitch module.(type) {\n\tcase EponymousOnlyModule:\n\t\trv := C._sqlite3_create_module_eponymous_only(c.db, mname, C.uintptr_t(uintptr(newHandle(c, &udm))))\n\t\tif rv != C.SQLITE_OK {\n\t\t\treturn c.lastError()\n\t\t}\n\t\treturn nil\n\tcase Module:\n\t\trv := C._sqlite3_create_module(c.db, mname, C.uintptr_t(uintptr(newHandle(c, &udm))))\n\t\tif rv != C.SQLITE_OK {\n\t\t\treturn c.lastError()\n\t\t}\n\t\treturn nil\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "sqlite3_opt_vtable_test.go",
          "type": "blob",
          "size": 13.671875,
          "content": "// Copyright (C) 2019 Yasuhiro Matsumoto <mattn.jp@gmail.com>.\n//\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n//go:build sqlite_vtable || vtable\n// +build sqlite_vtable vtable\n\npackage sqlite3\n\nimport (\n\t\"database/sql\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n)\n\ntype testModule struct {\n\tt        *testing.T\n\tintarray []int\n}\n\ntype testVTab struct {\n\tintarray []int\n}\n\ntype testVTabCursor struct {\n\tvTab  *testVTab\n\tindex int\n}\n\nfunc (m testModule) Create(c *SQLiteConn, args []string) (VTab, error) {\n\tif len(args) != 6 {\n\t\tm.t.Fatal(\"six arguments expected\")\n\t}\n\tif args[0] != \"test\" {\n\t\tm.t.Fatal(\"module name\")\n\t}\n\tif args[1] != \"main\" {\n\t\tm.t.Fatal(\"db name\")\n\t}\n\tif args[2] != \"vtab\" {\n\t\tm.t.Fatal(\"table name\")\n\t}\n\tif args[3] != \"'1'\" {\n\t\tm.t.Fatal(\"first arg\")\n\t}\n\tif args[4] != \"2\" {\n\t\tm.t.Fatal(\"second arg\")\n\t}\n\tif args[5] != \"three\" {\n\t\tm.t.Fatal(\"third argsecond arg\")\n\t}\n\terr := c.DeclareVTab(\"CREATE TABLE x(test TEXT)\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &testVTab{m.intarray}, nil\n}\n\nfunc (m testModule) Connect(c *SQLiteConn, args []string) (VTab, error) {\n\treturn m.Create(c, args)\n}\n\nfunc (m testModule) DestroyModule() {}\n\nfunc (v *testVTab) BestIndex(cst []InfoConstraint, ob []InfoOrderBy) (*IndexResult, error) {\n\tused := make([]bool, 0, len(cst))\n\tfor range cst {\n\t\tused = append(used, false)\n\t}\n\treturn &IndexResult{\n\t\tUsed:           used,\n\t\tIdxNum:         0,\n\t\tIdxStr:         \"test-index\",\n\t\tAlreadyOrdered: true,\n\t\tEstimatedCost:  100,\n\t\tEstimatedRows:  200,\n\t}, nil\n}\n\nfunc (v *testVTab) Disconnect() error {\n\treturn nil\n}\n\nfunc (v *testVTab) Destroy() error {\n\treturn nil\n}\n\nfunc (v *testVTab) Open() (VTabCursor, error) {\n\treturn &testVTabCursor{v, 0}, nil\n}\n\nfunc (vc *testVTabCursor) Close() error {\n\treturn nil\n}\n\nfunc (vc *testVTabCursor) Filter(idxNum int, idxStr string, vals []any) error {\n\tvc.index = 0\n\treturn nil\n}\n\nfunc (vc *testVTabCursor) Next() error {\n\tvc.index++\n\treturn nil\n}\n\nfunc (vc *testVTabCursor) EOF() bool {\n\treturn vc.index >= len(vc.vTab.intarray)\n}\n\nfunc (vc *testVTabCursor) Column(c *SQLiteContext, col int) error {\n\tif col != 0 {\n\t\treturn fmt.Errorf(\"column index out of bounds: %d\", col)\n\t}\n\tc.ResultInt(vc.vTab.intarray[vc.index])\n\treturn nil\n}\n\nfunc (vc *testVTabCursor) Rowid() (int64, error) {\n\treturn int64(vc.index), nil\n}\n\nfunc TestCreateModule(t *testing.T) {\n\ttempFilename := TempFilename(t)\n\tdefer os.Remove(tempFilename)\n\tintarray := []int{1, 2, 3}\n\tsql.Register(\"sqlite3_TestCreateModule\", &SQLiteDriver{\n\t\tConnectHook: func(conn *SQLiteConn) error {\n\t\t\treturn conn.CreateModule(\"test\", testModule{t, intarray})\n\t\t},\n\t})\n\tdb, err := sql.Open(\"sqlite3_TestCreateModule\", tempFilename)\n\tif err != nil {\n\t\tt.Fatalf(\"could not open db: %v\", err)\n\t}\n\t_, err = db.Exec(\"CREATE VIRTUAL TABLE vtab USING test('1', 2, three)\")\n\tif err != nil {\n\t\tt.Fatalf(\"could not create vtable: %v\", err)\n\t}\n\n\tvar i, value int\n\trows, err := db.Query(\"SELECT rowid, * FROM vtab WHERE test = '3'\")\n\tif err != nil {\n\t\tt.Fatalf(\"couldn't select from virtual table: %v\", err)\n\t}\n\tfor rows.Next() {\n\t\trows.Scan(&i, &value)\n\t\tif intarray[i] != value {\n\t\t\tt.Fatalf(\"want %v but %v\", intarray[i], value)\n\t\t}\n\t}\n\n\t_, err = db.Exec(\"DROP TABLE vtab\")\n\tif err != nil {\n\t\tt.Fatalf(\"couldn't drop virtual table: %v\", err)\n\t}\n}\n\nfunc TestVUpdate(t *testing.T) {\n\ttempFilename := TempFilename(t)\n\tdefer os.Remove(tempFilename)\n\n\t// create module\n\tupdateMod := &vtabUpdateModule{t, make(map[string]*vtabUpdateTable)}\n\n\t// register module\n\tsql.Register(\"sqlite3_TestVUpdate\", &SQLiteDriver{\n\t\tConnectHook: func(conn *SQLiteConn) error {\n\t\t\treturn conn.CreateModule(\"updatetest\", updateMod)\n\t\t},\n\t})\n\n\t// connect\n\tdb, err := sql.Open(\"sqlite3_TestVUpdate\", tempFilename)\n\tif err != nil {\n\t\tt.Fatalf(\"could not open db: %v\", err)\n\t}\n\n\t// create test table\n\t_, err = db.Exec(`CREATE VIRTUAL TABLE vt USING updatetest(f1 integer, f2 text, f3 text)`)\n\tif err != nil {\n\t\tt.Fatalf(\"could not create updatetest vtable vt, got: %v\", err)\n\t}\n\n\t// check that table is defined properly\n\tif len(updateMod.tables) != 1 {\n\t\tt.Fatalf(\"expected exactly 1 table to exist, got: %d\", len(updateMod.tables))\n\t}\n\tif _, ok := updateMod.tables[\"vt\"]; !ok {\n\t\tt.Fatalf(\"expected table `vt` to exist in tables\")\n\t}\n\n\t// check nothing in updatetest\n\trows, err := db.Query(`select * from vt`)\n\tif err != nil {\n\t\tt.Fatalf(\"could not query vt, got: %v\", err)\n\t}\n\ti, err := getRowCount(rows)\n\tif err != nil {\n\t\tt.Fatalf(\"expected no error, got: %v\", err)\n\t}\n\tif i != 0 {\n\t\tt.Fatalf(\"expected no rows in vt, got: %d\", i)\n\t}\n\n\t_, err = db.Exec(`delete from vt where f1 = 'yes'`)\n\tif err != nil {\n\t\tt.Fatalf(\"expected error on delete, got nil\")\n\t}\n\n\t// test bad column name\n\t_, err = db.Exec(`insert into vt (f4) values('a')`)\n\tif err == nil {\n\t\tt.Fatalf(\"expected error on insert, got nil\")\n\t}\n\n\t// insert to vt\n\tres, err := db.Exec(`insert into vt (f1, f2, f3) values (115, 'b', 'c'), (116, 'd', 'e')`)\n\tif err != nil {\n\t\tt.Fatalf(\"expected no error on insert, got: %v\", err)\n\t}\n\tn, err := res.RowsAffected()\n\tif err != nil {\n\t\tt.Fatalf(\"expected no error, got: %v\", err)\n\t}\n\tif n != 2 {\n\t\tt.Fatalf(\"expected 1 row affected, got: %d\", n)\n\t}\n\n\t// check vt table\n\tvt := updateMod.tables[\"vt\"]\n\tif len(vt.data) != 2 {\n\t\tt.Fatalf(\"expected table vt to have exactly 2 rows, got: %d\", len(vt.data))\n\t}\n\tif !reflect.DeepEqual(vt.data[0], []any{int64(115), \"b\", \"c\"}) {\n\t\tt.Fatalf(\"expected table vt entry 0 to be [115 b c], instead: %v\", vt.data[0])\n\t}\n\tif !reflect.DeepEqual(vt.data[1], []any{int64(116), \"d\", \"e\"}) {\n\t\tt.Fatalf(\"expected table vt entry 1 to be [116 d e], instead: %v\", vt.data[1])\n\t}\n\n\t// query vt\n\tvar f1 int\n\tvar f2, f3 string\n\terr = db.QueryRow(`select * from vt where f1 = 115`).Scan(&f1, &f2, &f3)\n\tif err != nil {\n\t\tt.Fatalf(\"expected no error on vt query, got: %v\", err)\n\t}\n\n\t// check column values\n\tif f1 != 115 || f2 != \"b\" || f3 != \"c\" {\n\t\tt.Errorf(\"expected f1==115, f2==b, f3==c, got: %d, %q, %q\", f1, f2, f3)\n\t}\n\n\t// update vt\n\tres, err = db.Exec(`update vt set f1=117, f2='f' where f3='e'`)\n\tif err != nil {\n\t\tt.Fatalf(\"expected no error, got: %v\", err)\n\t}\n\tn, err = res.RowsAffected()\n\tif err != nil {\n\t\tt.Fatalf(\"expected no error, got: %v\", err)\n\t}\n\tif n != 1 {\n\t\tt.Fatalf(\"expected exactly one row updated, got: %d\", n)\n\t}\n\n\t// check vt table\n\tif len(vt.data) != 2 {\n\t\tt.Fatalf(\"expected table vt to have exactly 2 rows, got: %d\", len(vt.data))\n\t}\n\tif !reflect.DeepEqual(vt.data[0], []any{int64(115), \"b\", \"c\"}) {\n\t\tt.Fatalf(\"expected table vt entry 0 to be [115 b c], instead: %v\", vt.data[0])\n\t}\n\tif !reflect.DeepEqual(vt.data[1], []any{int64(117), \"f\", \"e\"}) {\n\t\tt.Fatalf(\"expected table vt entry 1 to be [117 f e], instead: %v\", vt.data[1])\n\t}\n\n\t// delete from vt\n\tres, err = db.Exec(`delete from vt where f1 = 117`)\n\tif err != nil {\n\t\tt.Fatalf(\"expected no error, got: %v\", err)\n\t}\n\tn, err = res.RowsAffected()\n\tif err != nil {\n\t\tt.Fatalf(\"expected no error, got: %v\", err)\n\t}\n\tif n != 1 {\n\t\tt.Fatalf(\"expected exactly one row deleted, got: %d\", n)\n\t}\n\n\t// check vt table\n\tif len(vt.data) != 1 {\n\t\tt.Fatalf(\"expected table vt to have exactly 1 row, got: %d\", len(vt.data))\n\t}\n\tif !reflect.DeepEqual(vt.data[0], []any{int64(115), \"b\", \"c\"}) {\n\t\tt.Fatalf(\"expected table vt entry 0 to be [115 b c], instead: %v\", vt.data[0])\n\t}\n\n\t// check updatetest has 1 result\n\trows, err = db.Query(`select * from vt`)\n\tif err != nil {\n\t\tt.Fatalf(\"could not query vt, got: %v\", err)\n\t}\n\ti, err = getRowCount(rows)\n\tif err != nil {\n\t\tt.Fatalf(\"expected no error, got: %v\", err)\n\t}\n\tif i != 1 {\n\t\tt.Fatalf(\"expected 1 row in vt, got: %d\", i)\n\t}\n}\n\nfunc getRowCount(rows *sql.Rows) (int, error) {\n\tvar i int\n\tfor rows.Next() {\n\t\ti++\n\t}\n\treturn i, nil\n}\n\ntype vtabUpdateModule struct {\n\tt      *testing.T\n\ttables map[string]*vtabUpdateTable\n}\n\nfunc (m *vtabUpdateModule) Create(c *SQLiteConn, args []string) (VTab, error) {\n\tif len(args) < 2 {\n\t\treturn nil, errors.New(\"must declare at least one column\")\n\t}\n\n\t// get database name, table name, and column declarations ...\n\tdbname, tname, decls := args[1], args[2], args[3:]\n\n\t// extract column names + types from parameters declarations\n\tcols, typs := make([]string, len(decls)), make([]string, len(decls))\n\tfor i := 0; i < len(decls); i++ {\n\t\tn, typ := decls[i], \"\"\n\t\tif j := strings.IndexAny(n, \" \\t\\n\"); j != -1 {\n\t\t\ttyp, n = strings.TrimSpace(n[j+1:]), n[:j]\n\t\t}\n\t\tcols[i], typs[i] = n, typ\n\t}\n\n\t// declare table\n\terr := c.DeclareVTab(fmt.Sprintf(`CREATE TABLE \"%s\".\"%s\" (%s)`, dbname, tname, strings.Join(decls, \",\")))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// create table\n\tvtab := &vtabUpdateTable{m.t, dbname, tname, cols, typs, make([][]any, 0)}\n\tm.tables[tname] = vtab\n\treturn vtab, nil\n}\n\nfunc (m *vtabUpdateModule) Connect(c *SQLiteConn, args []string) (VTab, error) {\n\treturn m.Create(c, args)\n}\n\nfunc (m *vtabUpdateModule) DestroyModule() {}\n\ntype vtabUpdateTable struct {\n\tt    *testing.T\n\tdb   string\n\tname string\n\tcols []string\n\ttyps []string\n\tdata [][]any\n}\n\nfunc (t *vtabUpdateTable) Open() (VTabCursor, error) {\n\treturn &vtabUpdateCursor{t, 0}, nil\n}\n\nfunc (t *vtabUpdateTable) BestIndex(cst []InfoConstraint, ob []InfoOrderBy) (*IndexResult, error) {\n\treturn &IndexResult{Used: make([]bool, len(cst))}, nil\n}\n\nfunc (t *vtabUpdateTable) Disconnect() error {\n\treturn nil\n}\n\nfunc (t *vtabUpdateTable) Destroy() error {\n\treturn nil\n}\n\nfunc (t *vtabUpdateTable) Insert(id any, vals []any) (int64, error) {\n\tvar i int64\n\tif id == nil {\n\t\ti, t.data = int64(len(t.data)), append(t.data, vals)\n\t\treturn i, nil\n\t}\n\n\tvar ok bool\n\ti, ok = id.(int64)\n\tif !ok {\n\t\treturn 0, fmt.Errorf(\"id is invalid type: %T\", id)\n\t}\n\n\tt.data[i] = vals\n\n\treturn i, nil\n}\n\nfunc (t *vtabUpdateTable) Update(id any, vals []any) error {\n\ti, ok := id.(int64)\n\tif !ok {\n\t\treturn fmt.Errorf(\"id is invalid type: %T\", id)\n\t}\n\n\tif int(i) >= len(t.data) || i < 0 {\n\t\treturn fmt.Errorf(\"invalid row id %d\", i)\n\t}\n\n\tt.data[int(i)] = vals\n\n\treturn nil\n}\n\nfunc (t *vtabUpdateTable) Delete(id any) error {\n\ti, ok := id.(int64)\n\tif !ok {\n\t\treturn fmt.Errorf(\"id is invalid type: %T\", id)\n\t}\n\n\tif int(i) >= len(t.data) || i < 0 {\n\t\treturn fmt.Errorf(\"invalid row id %d\", i)\n\t}\n\n\tt.data = append(t.data[:i], t.data[i+1:]...)\n\n\treturn nil\n}\n\ntype vtabUpdateCursor struct {\n\tt *vtabUpdateTable\n\ti int\n}\n\nfunc (c *vtabUpdateCursor) Column(ctxt *SQLiteContext, col int) error {\n\tswitch x := c.t.data[c.i][col].(type) {\n\tcase []byte:\n\t\tctxt.ResultBlob(x)\n\tcase bool:\n\t\tctxt.ResultBool(x)\n\tcase float64:\n\t\tctxt.ResultDouble(x)\n\tcase int:\n\t\tctxt.ResultInt(x)\n\tcase int64:\n\t\tctxt.ResultInt64(x)\n\tcase nil:\n\t\tctxt.ResultNull()\n\tcase string:\n\t\tctxt.ResultText(x)\n\tdefault:\n\t\tctxt.ResultText(fmt.Sprintf(\"%v\", x))\n\t}\n\n\treturn nil\n}\n\nfunc (c *vtabUpdateCursor) Filter(ixNum int, ixName string, vals []any) error {\n\treturn nil\n}\n\nfunc (c *vtabUpdateCursor) Next() error {\n\tc.i++\n\treturn nil\n}\n\nfunc (c *vtabUpdateCursor) EOF() bool {\n\treturn c.i >= len(c.t.data)\n}\n\nfunc (c *vtabUpdateCursor) Rowid() (int64, error) {\n\treturn int64(c.i), nil\n}\n\nfunc (c *vtabUpdateCursor) Close() error {\n\treturn nil\n}\n\ntype testModuleEponymousOnly struct {\n\tt        *testing.T\n\tintarray []int\n}\n\ntype testVTabEponymousOnly struct {\n\tintarray []int\n}\n\ntype testVTabCursorEponymousOnly struct {\n\tvTab  *testVTabEponymousOnly\n\tindex int\n}\n\nfunc (m testModuleEponymousOnly) EponymousOnlyModule() {}\n\nfunc (m testModuleEponymousOnly) Create(c *SQLiteConn, args []string) (VTab, error) {\n\terr := c.DeclareVTab(\"CREATE TABLE x(test INT)\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &testVTabEponymousOnly{m.intarray}, nil\n}\n\nfunc (m testModuleEponymousOnly) Connect(c *SQLiteConn, args []string) (VTab, error) {\n\treturn m.Create(c, args)\n}\n\nfunc (m testModuleEponymousOnly) DestroyModule() {}\n\nfunc (v *testVTabEponymousOnly) BestIndex(cst []InfoConstraint, ob []InfoOrderBy) (*IndexResult, error) {\n\tused := make([]bool, 0, len(cst))\n\tfor range cst {\n\t\tused = append(used, false)\n\t}\n\treturn &IndexResult{\n\t\tUsed:           used,\n\t\tIdxNum:         0,\n\t\tIdxStr:         \"test-index\",\n\t\tAlreadyOrdered: true,\n\t\tEstimatedCost:  100,\n\t\tEstimatedRows:  200,\n\t}, nil\n}\n\nfunc (v *testVTabEponymousOnly) Disconnect() error {\n\treturn nil\n}\n\nfunc (v *testVTabEponymousOnly) Destroy() error {\n\treturn nil\n}\n\nfunc (v *testVTabEponymousOnly) Open() (VTabCursor, error) {\n\treturn &testVTabCursorEponymousOnly{v, 0}, nil\n}\n\nfunc (vc *testVTabCursorEponymousOnly) Close() error {\n\treturn nil\n}\n\nfunc (vc *testVTabCursorEponymousOnly) Filter(idxNum int, idxStr string, vals []any) error {\n\tvc.index = 0\n\treturn nil\n}\n\nfunc (vc *testVTabCursorEponymousOnly) Next() error {\n\tvc.index++\n\treturn nil\n}\n\nfunc (vc *testVTabCursorEponymousOnly) EOF() bool {\n\treturn vc.index >= len(vc.vTab.intarray)\n}\n\nfunc (vc *testVTabCursorEponymousOnly) Column(c *SQLiteContext, col int) error {\n\tif col != 0 {\n\t\treturn fmt.Errorf(\"column index out of bounds: %d\", col)\n\t}\n\tc.ResultInt(vc.vTab.intarray[vc.index])\n\treturn nil\n}\n\nfunc (vc *testVTabCursorEponymousOnly) Rowid() (int64, error) {\n\treturn int64(vc.index), nil\n}\n\nfunc TestCreateModuleEponymousOnly(t *testing.T) {\n\ttempFilename := TempFilename(t)\n\tdefer os.Remove(tempFilename)\n\tintarray := []int{1, 2, 3}\n\tsql.Register(\"sqlite3_TestCreateModuleEponymousOnly\", &SQLiteDriver{\n\t\tConnectHook: func(conn *SQLiteConn) error {\n\t\t\treturn conn.CreateModule(\"test\", testModuleEponymousOnly{t, intarray})\n\t\t},\n\t})\n\tdb, err := sql.Open(\"sqlite3_TestCreateModuleEponymousOnly\", tempFilename)\n\tif err != nil {\n\t\tt.Fatalf(\"could not open db: %v\", err)\n\t}\n\n\tvar i, value int\n\trows, err := db.Query(\"SELECT rowid, * FROM test\")\n\tif err != nil {\n\t\tt.Fatalf(\"couldn't select from virtual table: %v\", err)\n\t}\n\tfor rows.Next() {\n\t\terr := rows.Scan(&i, &value)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif intarray[i] != value {\n\t\t\tt.Fatalf(\"want %v but %v\", intarray[i], value)\n\t\t}\n\t}\n\n\t_, err = db.Exec(\"DROP TABLE test\")\n\tif err != nil {\n\t\tt.Logf(\"couldn't drop virtual table: %v\", err)\n\t}\n}\n"
        },
        {
          "name": "sqlite3_other.go",
          "type": "blob",
          "size": 0.38671875,
          "content": "// Copyright (C) 2019 Yasuhiro Matsumoto <mattn.jp@gmail.com>.\n//\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n//go:build !windows\n// +build !windows\n\npackage sqlite3\n\n/*\n#cgo CFLAGS: -I.\n#cgo linux LDFLAGS: -ldl\n#cgo linux,ppc LDFLAGS: -lpthread\n#cgo linux,ppc64 LDFLAGS: -lpthread\n#cgo linux,ppc64le LDFLAGS: -lpthread\n*/\nimport \"C\"\n"
        },
        {
          "name": "sqlite3_solaris.go",
          "type": "blob",
          "size": 0.287109375,
          "content": "// Copyright (C) 2019 Yasuhiro Matsumoto <mattn.jp@gmail.com>.\n//\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n//go:build solaris\n// +build solaris\n\npackage sqlite3\n\n/*\n#cgo CFLAGS: -D__EXTENSIONS__=1\n#cgo LDFLAGS: -lc\n*/\nimport \"C\"\n"
        },
        {
          "name": "sqlite3_test.go",
          "type": "blob",
          "size": 62.544921875,
          "content": "// Copyright (C) 2019 Yasuhiro Matsumoto <mattn.jp@gmail.com>.\n//\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n//go:build cgo\n// +build cgo\n\npackage sqlite3\n\nimport (\n\t\"bytes\"\n\t\"database/sql\"\n\t\"database/sql/driver\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"math/rand\"\n\t\"net/url\"\n\t\"os\"\n\t\"reflect\"\n\t\"regexp\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TempFilename(t testing.TB) string {\n\tf, err := ioutil.TempFile(\"\", \"go-sqlite3-test-\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tf.Close()\n\treturn f.Name()\n}\n\nfunc doTestOpen(t *testing.T, option string) (string, error) {\n\ttempFilename := TempFilename(t)\n\turl := tempFilename + option\n\n\tdefer func() {\n\t\terr := os.Remove(tempFilename)\n\t\tif err != nil {\n\t\t\tt.Error(\"temp file remove error:\", err)\n\t\t}\n\t}()\n\n\tdb, err := sql.Open(\"sqlite3\", url)\n\tif err != nil {\n\t\treturn \"Failed to open database:\", err\n\t}\n\n\tdefer func() {\n\t\terr = db.Close()\n\t\tif err != nil {\n\t\t\tt.Error(\"db close error:\", err)\n\t\t}\n\t}()\n\n\terr = db.Ping()\n\tif err != nil {\n\t\treturn \"ping error:\", err\n\t}\n\n\t_, err = db.Exec(\"drop table foo\")\n\t_, err = db.Exec(\"create table foo (id integer)\")\n\tif err != nil {\n\t\treturn \"Failed to create table:\", err\n\t}\n\n\tif stat, err := os.Stat(tempFilename); err != nil || stat.IsDir() {\n\t\treturn \"Failed to create ./foo.db\", nil\n\t}\n\n\treturn \"\", nil\n}\n\nfunc TestOpen(t *testing.T) {\n\tcases := map[string]bool{\n\t\t\"\":                   true,\n\t\t\"?_txlock=immediate\": true,\n\t\t\"?_txlock=deferred\":  true,\n\t\t\"?_txlock=exclusive\": true,\n\t\t\"?_txlock=bogus\":     false,\n\t}\n\tfor option, expectedPass := range cases {\n\t\tresult, err := doTestOpen(t, option)\n\t\tif result == \"\" {\n\t\t\tif !expectedPass {\n\t\t\t\terrmsg := fmt.Sprintf(\"_txlock error not caught at dbOpen with option: %s\", option)\n\t\t\t\tt.Fatal(errmsg)\n\t\t\t}\n\t\t} else if expectedPass {\n\t\t\tif err == nil {\n\t\t\t\tt.Fatal(result)\n\t\t\t} else {\n\t\t\t\tt.Fatal(result, err)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestOpenWithVFS(t *testing.T) {\n\tfilename := t.Name() + \".sqlite\"\n\n\tif err := os.Remove(filename); err != nil && !os.IsNotExist(err) {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(filename)\n\n\tdb, err := sql.Open(\"sqlite3\", fmt.Sprintf(\"file:%s?vfs=hello\", filename))\n\tif err != nil {\n\t\tt.Fatal(\"Failed to open\", err)\n\t}\n\terr = db.Ping()\n\tif err == nil {\n\t\tt.Fatal(\"Failed to open\", err)\n\t}\n\tdb.Close()\n\n\tdefer os.Remove(filename)\n\n\tvar vfs string\n\tif runtime.GOOS == \"windows\" {\n\t\tvfs = \"win32-none\"\n\t} else {\n\t\tvfs = \"unix-none\"\n\t}\n\tdb, err = sql.Open(\"sqlite3\", fmt.Sprintf(\"file:%s?vfs=%s\", filename, vfs))\n\tif err != nil {\n\t\tt.Fatal(\"Failed to open\", err)\n\t}\n\terr = db.Ping()\n\tif err != nil {\n\t\tt.Fatal(\"Failed to ping\", err)\n\t}\n\tdb.Close()\n}\n\nfunc TestOpenNoCreate(t *testing.T) {\n\tfilename := t.Name() + \".sqlite\"\n\n\tif err := os.Remove(filename); err != nil && !os.IsNotExist(err) {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(filename)\n\n\t// https://golang.org/pkg/database/sql/#Open\n\t// \"Open may just validate its arguments without creating a connection\n\t// to the database. To verify that the data source name is valid, call Ping.\"\n\tdb, err := sql.Open(\"sqlite3\", fmt.Sprintf(\"file:%s?mode=rw\", filename))\n\tif err == nil {\n\t\tdefer db.Close()\n\n\t\terr = db.Ping()\n\t\tif err == nil {\n\t\t\tt.Fatal(\"expected error from Open or Ping\")\n\t\t}\n\t}\n\n\tsqlErr, ok := err.(Error)\n\tif !ok {\n\t\tt.Fatalf(\"expected sqlite3.Error, but got %T\", err)\n\t}\n\n\tif sqlErr.Code != ErrCantOpen {\n\t\tt.Fatalf(\"expected SQLITE_CANTOPEN, but got %v\", sqlErr)\n\t}\n\n\t// make sure database file truly was not created\n\tif _, err := os.Stat(filename); !os.IsNotExist(err) {\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tt.Fatal(\"expected database file to not exist\")\n\t}\n\n\t// verify that it works if the mode is \"rwc\" instead\n\tdb, err = sql.Open(\"sqlite3\", fmt.Sprintf(\"file:%s?mode=rwc\", filename))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\tif err := db.Ping(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// make sure database file truly was created\n\tif _, err := os.Stat(filename); err != nil {\n\t\tif !os.IsNotExist(err) {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tt.Fatal(\"expected database file to exist\")\n\t}\n}\n\nfunc TestReadonly(t *testing.T) {\n\ttempFilename := TempFilename(t)\n\tdefer os.Remove(tempFilename)\n\n\tdb1, err := sql.Open(\"sqlite3\", \"file:\"+tempFilename)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdb1.Exec(\"CREATE TABLE test (x int, y float)\")\n\n\tdb2, err := sql.Open(\"sqlite3\", \"file:\"+tempFilename+\"?mode=ro\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t_ = db2\n\t_, err = db2.Exec(\"INSERT INTO test VALUES (1, 3.14)\")\n\tif err == nil {\n\t\tt.Fatal(\"didn't expect INSERT into read-only database to work\")\n\t}\n}\n\nfunc TestForeignKeys(t *testing.T) {\n\tcases := map[string]bool{\n\t\t\"?_foreign_keys=1\": true,\n\t\t\"?_foreign_keys=0\": false,\n\t}\n\tfor option, want := range cases {\n\t\tfname := TempFilename(t)\n\t\turi := \"file:\" + fname + option\n\t\tdb, err := sql.Open(\"sqlite3\", uri)\n\t\tif err != nil {\n\t\t\tos.Remove(fname)\n\t\t\tt.Errorf(\"sql.Open(\\\"sqlite3\\\", %q): %v\", uri, err)\n\t\t\tcontinue\n\t\t}\n\t\tvar enabled bool\n\t\terr = db.QueryRow(\"PRAGMA foreign_keys;\").Scan(&enabled)\n\t\tdb.Close()\n\t\tos.Remove(fname)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"query foreign_keys for %s: %v\", uri, err)\n\t\t\tcontinue\n\t\t}\n\t\tif enabled != want {\n\t\t\tt.Errorf(\"\\\"PRAGMA foreign_keys;\\\" for %q = %t; want %t\", uri, enabled, want)\n\t\t\tcontinue\n\t\t}\n\t}\n}\n\nfunc TestDeferredForeignKey(t *testing.T) {\n\tfname := TempFilename(t)\n\turi := \"file:\" + fname + \"?_foreign_keys=1\"\n\tdb, err := sql.Open(\"sqlite3\", uri)\n\tif err != nil {\n\t\tos.Remove(fname)\n\t\tt.Errorf(\"sql.Open(\\\"sqlite3\\\", %q): %v\", uri, err)\n\t}\n\t_, err = db.Exec(\"CREATE TABLE bar (id INTEGER PRIMARY KEY)\")\n\tif err != nil {\n\t\tt.Errorf(\"failed creating tables: %v\", err)\n\t}\n\t_, err = db.Exec(\"CREATE TABLE foo (bar_id INTEGER, FOREIGN KEY(bar_id) REFERENCES bar(id) DEFERRABLE INITIALLY DEFERRED)\")\n\tif err != nil {\n\t\tt.Errorf(\"failed creating tables: %v\", err)\n\t}\n\ttx, err := db.Begin()\n\tif err != nil {\n\t\tt.Errorf(\"Failed to begin transaction: %v\", err)\n\t}\n\t_, err = tx.Exec(\"INSERT INTO foo (bar_id) VALUES (123)\")\n\tif err != nil {\n\t\tt.Errorf(\"Failed to insert row: %v\", err)\n\t}\n\terr = tx.Commit()\n\tif err == nil {\n\t\tt.Errorf(\"Expected an error: %v\", err)\n\t}\n\t_, err = db.Begin()\n\tif err != nil {\n\t\tt.Errorf(\"Failed to begin transaction: %v\", err)\n\t}\n\n\tdb.Close()\n\tos.Remove(fname)\n}\n\nfunc TestRecursiveTriggers(t *testing.T) {\n\tcases := map[string]bool{\n\t\t\"?_recursive_triggers=1\": true,\n\t\t\"?_recursive_triggers=0\": false,\n\t}\n\tfor option, want := range cases {\n\t\tfname := TempFilename(t)\n\t\turi := \"file:\" + fname + option\n\t\tdb, err := sql.Open(\"sqlite3\", uri)\n\t\tif err != nil {\n\t\t\tos.Remove(fname)\n\t\t\tt.Errorf(\"sql.Open(\\\"sqlite3\\\", %q): %v\", uri, err)\n\t\t\tcontinue\n\t\t}\n\t\tvar enabled bool\n\t\terr = db.QueryRow(\"PRAGMA recursive_triggers;\").Scan(&enabled)\n\t\tdb.Close()\n\t\tos.Remove(fname)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"query recursive_triggers for %s: %v\", uri, err)\n\t\t\tcontinue\n\t\t}\n\t\tif enabled != want {\n\t\t\tt.Errorf(\"\\\"PRAGMA recursive_triggers;\\\" for %q = %t; want %t\", uri, enabled, want)\n\t\t\tcontinue\n\t\t}\n\t}\n}\n\nfunc TestClose(t *testing.T) {\n\ttempFilename := TempFilename(t)\n\tdefer os.Remove(tempFilename)\n\tdb, err := sql.Open(\"sqlite3\", tempFilename)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to open database:\", err)\n\t}\n\n\t_, err = db.Exec(\"drop table foo\")\n\t_, err = db.Exec(\"create table foo (id integer)\")\n\tif err != nil {\n\t\tt.Fatal(\"Failed to create table:\", err)\n\t}\n\n\tstmt, err := db.Prepare(\"select id from foo where id = ?\")\n\tif err != nil {\n\t\tt.Fatal(\"Failed to select records:\", err)\n\t}\n\n\tdb.Close()\n\t_, err = stmt.Exec(1)\n\tif err == nil {\n\t\tt.Fatal(\"Failed to operate closed statement\")\n\t}\n}\n\nfunc TestInsert(t *testing.T) {\n\ttempFilename := TempFilename(t)\n\tdefer os.Remove(tempFilename)\n\tdb, err := sql.Open(\"sqlite3\", tempFilename)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to open database:\", err)\n\t}\n\tdefer db.Close()\n\n\t_, err = db.Exec(\"drop table foo\")\n\t_, err = db.Exec(\"create table foo (id integer)\")\n\tif err != nil {\n\t\tt.Fatal(\"Failed to create table:\", err)\n\t}\n\n\tres, err := db.Exec(\"insert into foo(id) values(123)\")\n\tif err != nil {\n\t\tt.Fatal(\"Failed to insert record:\", err)\n\t}\n\taffected, _ := res.RowsAffected()\n\tif affected != 1 {\n\t\tt.Fatalf(\"Expected %d for affected rows, but %d:\", 1, affected)\n\t}\n\n\trows, err := db.Query(\"select id from foo\")\n\tif err != nil {\n\t\tt.Fatal(\"Failed to select records:\", err)\n\t}\n\tdefer rows.Close()\n\n\trows.Next()\n\n\tvar result int\n\trows.Scan(&result)\n\tif result != 123 {\n\t\tt.Errorf(\"Expected %d for fetched result, but %d:\", 123, result)\n\t}\n}\n\nfunc TestUpsert(t *testing.T) {\n\t_, n, _ := Version()\n\tif n < 3024000 {\n\t\tt.Skip(\"UPSERT requires sqlite3 >= 3.24.0\")\n\t}\n\ttempFilename := TempFilename(t)\n\tdefer os.Remove(tempFilename)\n\tdb, err := sql.Open(\"sqlite3\", tempFilename)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to open database:\", err)\n\t}\n\tdefer db.Close()\n\n\t_, err = db.Exec(\"drop table foo\")\n\t_, err = db.Exec(\"create table foo (name string primary key, counter integer)\")\n\tif err != nil {\n\t\tt.Fatal(\"Failed to create table:\", err)\n\t}\n\n\tfor i := 0; i < 10; i++ {\n\t\tres, err := db.Exec(\"insert into foo(name, counter) values('key', 1) on conflict (name) do update set counter=counter+1\")\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Failed to upsert record:\", err)\n\t\t}\n\t\taffected, _ := res.RowsAffected()\n\t\tif affected != 1 {\n\t\t\tt.Fatalf(\"Expected %d for affected rows, but %d:\", 1, affected)\n\t\t}\n\t}\n\trows, err := db.Query(\"select name, counter from foo\")\n\tif err != nil {\n\t\tt.Fatal(\"Failed to select records:\", err)\n\t}\n\tdefer rows.Close()\n\n\trows.Next()\n\n\tvar resultName string\n\tvar resultCounter int\n\trows.Scan(&resultName, &resultCounter)\n\tif resultName != \"key\" {\n\t\tt.Errorf(\"Expected %s for fetched result, but %s:\", \"key\", resultName)\n\t}\n\tif resultCounter != 10 {\n\t\tt.Errorf(\"Expected %d for fetched result, but %d:\", 10, resultCounter)\n\t}\n\n}\n\nfunc TestUpdate(t *testing.T) {\n\ttempFilename := TempFilename(t)\n\tdefer os.Remove(tempFilename)\n\tdb, err := sql.Open(\"sqlite3\", tempFilename)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to open database:\", err)\n\t}\n\tdefer db.Close()\n\n\t_, err = db.Exec(\"drop table foo\")\n\t_, err = db.Exec(\"create table foo (id integer)\")\n\tif err != nil {\n\t\tt.Fatal(\"Failed to create table:\", err)\n\t}\n\n\tres, err := db.Exec(\"insert into foo(id) values(123)\")\n\tif err != nil {\n\t\tt.Fatal(\"Failed to insert record:\", err)\n\t}\n\texpected, err := res.LastInsertId()\n\tif err != nil {\n\t\tt.Fatal(\"Failed to get LastInsertId:\", err)\n\t}\n\taffected, _ := res.RowsAffected()\n\tif err != nil {\n\t\tt.Fatal(\"Failed to get RowsAffected:\", err)\n\t}\n\tif affected != 1 {\n\t\tt.Fatalf(\"Expected %d for affected rows, but %d:\", 1, affected)\n\t}\n\n\tres, err = db.Exec(\"update foo set id = 234\")\n\tif err != nil {\n\t\tt.Fatal(\"Failed to update record:\", err)\n\t}\n\tlastID, err := res.LastInsertId()\n\tif err != nil {\n\t\tt.Fatal(\"Failed to get LastInsertId:\", err)\n\t}\n\tif expected != lastID {\n\t\tt.Errorf(\"Expected %q for last Id, but %q:\", expected, lastID)\n\t}\n\taffected, _ = res.RowsAffected()\n\tif err != nil {\n\t\tt.Fatal(\"Failed to get RowsAffected:\", err)\n\t}\n\tif affected != 1 {\n\t\tt.Fatalf(\"Expected %d for affected rows, but %d:\", 1, affected)\n\t}\n\n\trows, err := db.Query(\"select id from foo\")\n\tif err != nil {\n\t\tt.Fatal(\"Failed to select records:\", err)\n\t}\n\tdefer rows.Close()\n\n\trows.Next()\n\n\tvar result int\n\trows.Scan(&result)\n\tif result != 234 {\n\t\tt.Errorf(\"Expected %d for fetched result, but %d:\", 234, result)\n\t}\n}\n\nfunc TestDelete(t *testing.T) {\n\ttempFilename := TempFilename(t)\n\tdefer os.Remove(tempFilename)\n\tdb, err := sql.Open(\"sqlite3\", tempFilename)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to open database:\", err)\n\t}\n\tdefer db.Close()\n\n\t_, err = db.Exec(\"drop table foo\")\n\t_, err = db.Exec(\"create table foo (id integer)\")\n\tif err != nil {\n\t\tt.Fatal(\"Failed to create table:\", err)\n\t}\n\n\tres, err := db.Exec(\"insert into foo(id) values(123)\")\n\tif err != nil {\n\t\tt.Fatal(\"Failed to insert record:\", err)\n\t}\n\texpected, err := res.LastInsertId()\n\tif err != nil {\n\t\tt.Fatal(\"Failed to get LastInsertId:\", err)\n\t}\n\taffected, err := res.RowsAffected()\n\tif err != nil {\n\t\tt.Fatal(\"Failed to get RowsAffected:\", err)\n\t}\n\tif affected != 1 {\n\t\tt.Errorf(\"Expected %d for cout of affected rows, but %q:\", 1, affected)\n\t}\n\n\tres, err = db.Exec(\"delete from foo where id = 123\")\n\tif err != nil {\n\t\tt.Fatal(\"Failed to delete record:\", err)\n\t}\n\tlastID, err := res.LastInsertId()\n\tif err != nil {\n\t\tt.Fatal(\"Failed to get LastInsertId:\", err)\n\t}\n\tif expected != lastID {\n\t\tt.Errorf(\"Expected %q for last Id, but %q:\", expected, lastID)\n\t}\n\taffected, err = res.RowsAffected()\n\tif err != nil {\n\t\tt.Fatal(\"Failed to get RowsAffected:\", err)\n\t}\n\tif affected != 1 {\n\t\tt.Errorf(\"Expected %d for cout of affected rows, but %q:\", 1, affected)\n\t}\n\n\trows, err := db.Query(\"select id from foo\")\n\tif err != nil {\n\t\tt.Fatal(\"Failed to select records:\", err)\n\t}\n\tdefer rows.Close()\n\n\tif rows.Next() {\n\t\tt.Error(\"Fetched row but expected not rows\")\n\t}\n}\n\nfunc TestBooleanRoundtrip(t *testing.T) {\n\ttempFilename := TempFilename(t)\n\tdefer os.Remove(tempFilename)\n\tdb, err := sql.Open(\"sqlite3\", tempFilename)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to open database:\", err)\n\t}\n\tdefer db.Close()\n\n\t_, err = db.Exec(\"DROP TABLE foo\")\n\t_, err = db.Exec(\"CREATE TABLE foo(id INTEGER, value BOOL)\")\n\tif err != nil {\n\t\tt.Fatal(\"Failed to create table:\", err)\n\t}\n\n\t_, err = db.Exec(\"INSERT INTO foo(id, value) VALUES(1, ?)\", true)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to insert true value:\", err)\n\t}\n\n\t_, err = db.Exec(\"INSERT INTO foo(id, value) VALUES(2, ?)\", false)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to insert false value:\", err)\n\t}\n\n\trows, err := db.Query(\"SELECT id, value FROM foo\")\n\tif err != nil {\n\t\tt.Fatal(\"Unable to query foo table:\", err)\n\t}\n\tdefer rows.Close()\n\n\tfor rows.Next() {\n\t\tvar id int\n\t\tvar value bool\n\n\t\tif err := rows.Scan(&id, &value); err != nil {\n\t\t\tt.Error(\"Unable to scan results:\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif id == 1 && !value {\n\t\t\tt.Error(\"Value for id 1 should be true, not false\")\n\n\t\t} else if id == 2 && value {\n\t\t\tt.Error(\"Value for id 2 should be false, not true\")\n\t\t}\n\t}\n}\n\nfunc timezone(t time.Time) string { return t.Format(\"-07:00\") }\n\nfunc TestTimestamp(t *testing.T) {\n\ttempFilename := TempFilename(t)\n\tdefer os.Remove(tempFilename)\n\tdb, err := sql.Open(\"sqlite3\", tempFilename)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to open database:\", err)\n\t}\n\tdefer db.Close()\n\n\t_, err = db.Exec(\"DROP TABLE foo\")\n\t_, err = db.Exec(\"CREATE TABLE foo(id INTEGER, ts timeSTAMP, dt DATETIME)\")\n\tif err != nil {\n\t\tt.Fatal(\"Failed to create table:\", err)\n\t}\n\n\ttimestamp1 := time.Date(2012, time.April, 6, 22, 50, 0, 0, time.UTC)\n\ttimestamp2 := time.Date(2006, time.January, 2, 15, 4, 5, 123456789, time.UTC)\n\ttimestamp3 := time.Date(2012, time.November, 4, 0, 0, 0, 0, time.UTC)\n\ttzTest := time.FixedZone(\"TEST\", -9*3600-13*60)\n\ttests := []struct {\n\t\tvalue    any\n\t\texpected time.Time\n\t}{\n\t\t{\"nonsense\", time.Time{}},\n\t\t{\"0000-00-00 00:00:00\", time.Time{}},\n\t\t{time.Time{}.Unix(), time.Time{}},\n\t\t{timestamp1, timestamp1},\n\t\t{timestamp2.Unix(), timestamp2.Truncate(time.Second)},\n\t\t{timestamp2.UnixNano() / int64(time.Millisecond), timestamp2.Truncate(time.Millisecond)},\n\t\t{timestamp1.In(tzTest), timestamp1.In(tzTest)},\n\t\t{timestamp1.Format(\"2006-01-02 15:04:05.000\"), timestamp1},\n\t\t{timestamp1.Format(\"2006-01-02T15:04:05.000\"), timestamp1},\n\t\t{timestamp1.Format(\"2006-01-02 15:04:05\"), timestamp1},\n\t\t{timestamp1.Format(\"2006-01-02T15:04:05\"), timestamp1},\n\t\t{timestamp2, timestamp2},\n\t\t{\"2006-01-02 15:04:05.123456789\", timestamp2},\n\t\t{\"2006-01-02T15:04:05.123456789\", timestamp2},\n\t\t{\"2006-01-02T05:51:05.123456789-09:13\", timestamp2.In(tzTest)},\n\t\t{\"2012-11-04\", timestamp3},\n\t\t{\"2012-11-04 00:00\", timestamp3},\n\t\t{\"2012-11-04 00:00:00\", timestamp3},\n\t\t{\"2012-11-04 00:00:00.000\", timestamp3},\n\t\t{\"2012-11-04T00:00\", timestamp3},\n\t\t{\"2012-11-04T00:00:00\", timestamp3},\n\t\t{\"2012-11-04T00:00:00.000\", timestamp3},\n\t\t{\"2006-01-02T15:04:05.123456789Z\", timestamp2},\n\t\t{\"2012-11-04Z\", timestamp3},\n\t\t{\"2012-11-04 00:00Z\", timestamp3},\n\t\t{\"2012-11-04 00:00:00Z\", timestamp3},\n\t\t{\"2012-11-04 00:00:00.000Z\", timestamp3},\n\t\t{\"2012-11-04T00:00Z\", timestamp3},\n\t\t{\"2012-11-04T00:00:00Z\", timestamp3},\n\t\t{\"2012-11-04T00:00:00.000Z\", timestamp3},\n\t}\n\tfor i := range tests {\n\t\t_, err = db.Exec(\"INSERT INTO foo(id, ts, dt) VALUES(?, ?, ?)\", i, tests[i].value, tests[i].value)\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Failed to insert timestamp:\", err)\n\t\t}\n\t}\n\n\trows, err := db.Query(\"SELECT id, ts, dt FROM foo ORDER BY id ASC\")\n\tif err != nil {\n\t\tt.Fatal(\"Unable to query foo table:\", err)\n\t}\n\tdefer rows.Close()\n\n\tseen := 0\n\tfor rows.Next() {\n\t\tvar id int\n\t\tvar ts, dt time.Time\n\n\t\tif err := rows.Scan(&id, &ts, &dt); err != nil {\n\t\t\tt.Error(\"Unable to scan results:\", err)\n\t\t\tcontinue\n\t\t}\n\t\tif id < 0 || id >= len(tests) {\n\t\t\tt.Error(\"Bad row id: \", id)\n\t\t\tcontinue\n\t\t}\n\t\tseen++\n\t\tif !tests[id].expected.Equal(ts) {\n\t\t\tt.Errorf(\"Timestamp value for id %v (%v) should be %v, not %v\", id, tests[id].value, tests[id].expected, dt)\n\t\t}\n\t\tif !tests[id].expected.Equal(dt) {\n\t\t\tt.Errorf(\"Datetime value for id %v (%v) should be %v, not %v\", id, tests[id].value, tests[id].expected, dt)\n\t\t}\n\t\tif timezone(tests[id].expected) != timezone(ts) {\n\t\t\tt.Errorf(\"Timezone for id %v (%v) should be %v, not %v\", id, tests[id].value,\n\t\t\t\ttimezone(tests[id].expected), timezone(ts))\n\t\t}\n\t\tif timezone(tests[id].expected) != timezone(dt) {\n\t\t\tt.Errorf(\"Timezone for id %v (%v) should be %v, not %v\", id, tests[id].value,\n\t\t\t\ttimezone(tests[id].expected), timezone(dt))\n\t\t}\n\t}\n\n\tif seen != len(tests) {\n\t\tt.Errorf(\"Expected to see %d rows\", len(tests))\n\t}\n}\n\nfunc TestBoolean(t *testing.T) {\n\ttempFilename := TempFilename(t)\n\tdefer os.Remove(tempFilename)\n\tdb, err := sql.Open(\"sqlite3\", tempFilename)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to open database:\", err)\n\t}\n\n\tdefer db.Close()\n\n\t_, err = db.Exec(\"CREATE TABLE foo(id INTEGER, fbool BOOLEAN)\")\n\tif err != nil {\n\t\tt.Fatal(\"Failed to create table:\", err)\n\t}\n\n\tbool1 := true\n\t_, err = db.Exec(\"INSERT INTO foo(id, fbool) VALUES(1, ?)\", bool1)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to insert boolean:\", err)\n\t}\n\n\tbool2 := false\n\t_, err = db.Exec(\"INSERT INTO foo(id, fbool) VALUES(2, ?)\", bool2)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to insert boolean:\", err)\n\t}\n\n\tbool3 := \"nonsense\"\n\t_, err = db.Exec(\"INSERT INTO foo(id, fbool) VALUES(3, ?)\", bool3)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to insert nonsense:\", err)\n\t}\n\n\trows, err := db.Query(\"SELECT id, fbool FROM foo where fbool = ?\", bool1)\n\tif err != nil {\n\t\tt.Fatal(\"Unable to query foo table:\", err)\n\t}\n\tcounter := 0\n\n\tvar id int\n\tvar fbool bool\n\n\tfor rows.Next() {\n\t\tif err := rows.Scan(&id, &fbool); err != nil {\n\t\t\tt.Fatal(\"Unable to scan results:\", err)\n\t\t}\n\t\tcounter++\n\t}\n\n\tif counter != 1 {\n\t\tt.Fatalf(\"Expected 1 row but %v\", counter)\n\t}\n\n\tif id != 1 && !fbool {\n\t\tt.Fatalf(\"Value for id 1 should be %v, not %v\", bool1, fbool)\n\t}\n\n\trows, err = db.Query(\"SELECT id, fbool FROM foo where fbool = ?\", bool2)\n\tif err != nil {\n\t\tt.Fatal(\"Unable to query foo table:\", err)\n\t}\n\n\tcounter = 0\n\n\tfor rows.Next() {\n\t\tif err := rows.Scan(&id, &fbool); err != nil {\n\t\t\tt.Fatal(\"Unable to scan results:\", err)\n\t\t}\n\t\tcounter++\n\t}\n\n\tif counter != 1 {\n\t\tt.Fatalf(\"Expected 1 row but %v\", counter)\n\t}\n\n\tif id != 2 && fbool {\n\t\tt.Fatalf(\"Value for id 2 should be %v, not %v\", bool2, fbool)\n\t}\n\n\t// make sure \"nonsense\" triggered an error\n\trows, err = db.Query(\"SELECT id, fbool FROM foo where id=?;\", 3)\n\tif err != nil {\n\t\tt.Fatal(\"Unable to query foo table:\", err)\n\t}\n\n\trows.Next()\n\terr = rows.Scan(&id, &fbool)\n\tif err == nil {\n\t\tt.Error(\"Expected error from \\\"nonsense\\\" bool\")\n\t}\n}\n\nfunc TestFloat32(t *testing.T) {\n\ttempFilename := TempFilename(t)\n\tdefer os.Remove(tempFilename)\n\tdb, err := sql.Open(\"sqlite3\", tempFilename)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to open database:\", err)\n\t}\n\tdefer db.Close()\n\n\t_, err = db.Exec(\"CREATE TABLE foo(id INTEGER)\")\n\tif err != nil {\n\t\tt.Fatal(\"Failed to create table:\", err)\n\t}\n\n\t_, err = db.Exec(\"INSERT INTO foo(id) VALUES(null)\")\n\tif err != nil {\n\t\tt.Fatal(\"Failed to insert null:\", err)\n\t}\n\n\trows, err := db.Query(\"SELECT id FROM foo\")\n\tif err != nil {\n\t\tt.Fatal(\"Unable to query foo table:\", err)\n\t}\n\n\tif !rows.Next() {\n\t\tt.Fatal(\"Unable to query results:\", err)\n\t}\n\n\tvar id any\n\tif err := rows.Scan(&id); err != nil {\n\t\tt.Fatal(\"Unable to scan results:\", err)\n\t}\n\tif id != nil {\n\t\tt.Error(\"Expected nil but not\")\n\t}\n}\n\nfunc TestNull(t *testing.T) {\n\ttempFilename := TempFilename(t)\n\tdefer os.Remove(tempFilename)\n\tdb, err := sql.Open(\"sqlite3\", tempFilename)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to open database:\", err)\n\t}\n\tdefer db.Close()\n\n\trows, err := db.Query(\"SELECT 3.141592\")\n\tif err != nil {\n\t\tt.Fatal(\"Unable to query foo table:\", err)\n\t}\n\n\tif !rows.Next() {\n\t\tt.Fatal(\"Unable to query results:\", err)\n\t}\n\n\tvar v any\n\tif err := rows.Scan(&v); err != nil {\n\t\tt.Fatal(\"Unable to scan results:\", err)\n\t}\n\tf, ok := v.(float64)\n\tif !ok {\n\t\tt.Error(\"Expected float but not\")\n\t}\n\tif f != 3.141592 {\n\t\tt.Error(\"Expected 3.141592 but not\")\n\t}\n}\n\nfunc TestTransaction(t *testing.T) {\n\ttempFilename := TempFilename(t)\n\tdefer os.Remove(tempFilename)\n\tdb, err := sql.Open(\"sqlite3\", tempFilename)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to open database:\", err)\n\t}\n\tdefer db.Close()\n\n\t_, err = db.Exec(\"CREATE TABLE foo(id INTEGER)\")\n\tif err != nil {\n\t\tt.Fatal(\"Failed to create table:\", err)\n\t}\n\n\ttx, err := db.Begin()\n\tif err != nil {\n\t\tt.Fatal(\"Failed to begin transaction:\", err)\n\t}\n\n\t_, err = tx.Exec(\"INSERT INTO foo(id) VALUES(1)\")\n\tif err != nil {\n\t\tt.Fatal(\"Failed to insert null:\", err)\n\t}\n\n\trows, err := tx.Query(\"SELECT id from foo\")\n\tif err != nil {\n\t\tt.Fatal(\"Unable to query foo table:\", err)\n\t}\n\n\terr = tx.Rollback()\n\tif err != nil {\n\t\tt.Fatal(\"Failed to rollback transaction:\", err)\n\t}\n\n\tif rows.Next() {\n\t\tt.Fatal(\"Unable to query results:\", err)\n\t}\n\n\ttx, err = db.Begin()\n\tif err != nil {\n\t\tt.Fatal(\"Failed to begin transaction:\", err)\n\t}\n\n\t_, err = tx.Exec(\"INSERT INTO foo(id) VALUES(1)\")\n\tif err != nil {\n\t\tt.Fatal(\"Failed to insert null:\", err)\n\t}\n\n\terr = tx.Commit()\n\tif err != nil {\n\t\tt.Fatal(\"Failed to commit transaction:\", err)\n\t}\n\n\trows, err = tx.Query(\"SELECT id from foo\")\n\tif err == nil {\n\t\tt.Fatal(\"Expected failure to query\")\n\t}\n}\n\nfunc TestWAL(t *testing.T) {\n\ttempFilename := TempFilename(t)\n\tdefer os.Remove(tempFilename)\n\tdb, err := sql.Open(\"sqlite3\", tempFilename)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to open database:\", err)\n\t}\n\tdefer db.Close()\n\n\tif _, err = db.Exec(\"PRAGMA journal_mode=WAL;\"); err != nil {\n\t\tt.Fatal(\"Failed to Exec PRAGMA journal_mode:\", err)\n\t}\n\tif _, err = db.Exec(\"PRAGMA locking_mode=EXCLUSIVE;\"); err != nil {\n\t\tt.Fatal(\"Failed to Exec PRAGMA locking_mode:\", err)\n\t}\n\tif _, err = db.Exec(\"CREATE TABLE test (id SERIAL, user TEXT NOT NULL, name TEXT NOT NULL);\"); err != nil {\n\t\tt.Fatal(\"Failed to Exec CREATE TABLE:\", err)\n\t}\n\tif _, err = db.Exec(\"INSERT INTO test (user, name) VALUES ('user','name');\"); err != nil {\n\t\tt.Fatal(\"Failed to Exec INSERT:\", err)\n\t}\n\n\ttrans, err := db.Begin()\n\tif err != nil {\n\t\tt.Fatal(\"Failed to Begin:\", err)\n\t}\n\ts, err := trans.Prepare(\"INSERT INTO test (user, name) VALUES (?, ?);\")\n\tif err != nil {\n\t\tt.Fatal(\"Failed to Prepare:\", err)\n\t}\n\n\tvar count int\n\tif err = trans.QueryRow(\"SELECT count(user) FROM test;\").Scan(&count); err != nil {\n\t\tt.Fatal(\"Failed to QueryRow:\", err)\n\t}\n\tif _, err = s.Exec(\"bbbb\", \"aaaa\"); err != nil {\n\t\tt.Fatal(\"Failed to Exec prepared statement:\", err)\n\t}\n\tif err = s.Close(); err != nil {\n\t\tt.Fatal(\"Failed to Close prepared statement:\", err)\n\t}\n\tif err = trans.Commit(); err != nil {\n\t\tt.Fatal(\"Failed to Commit:\", err)\n\t}\n}\n\nfunc TestTimezoneConversion(t *testing.T) {\n\tzones := []string{\"UTC\", \"US/Central\", \"US/Pacific\", \"Local\"}\n\tfor _, tz := range zones {\n\t\ttempFilename := TempFilename(t)\n\t\tdefer os.Remove(tempFilename)\n\t\tdb, err := sql.Open(\"sqlite3\", tempFilename+\"?_loc=\"+url.QueryEscape(tz))\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Failed to open database:\", err)\n\t\t}\n\t\tdefer db.Close()\n\n\t\t_, err = db.Exec(\"DROP TABLE foo\")\n\t\t_, err = db.Exec(\"CREATE TABLE foo(id INTEGER, ts TIMESTAMP, dt DATETIME)\")\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Failed to create table:\", err)\n\t\t}\n\n\t\tloc, err := time.LoadLocation(tz)\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Failed to load location:\", err)\n\t\t}\n\n\t\ttimestamp1 := time.Date(2012, time.April, 6, 22, 50, 0, 0, time.UTC)\n\t\ttimestamp2 := time.Date(2006, time.January, 2, 15, 4, 5, 123456789, time.UTC)\n\t\ttimestamp3 := time.Date(2012, time.November, 4, 0, 0, 0, 0, time.UTC)\n\t\ttests := []struct {\n\t\t\tvalue    any\n\t\t\texpected time.Time\n\t\t}{\n\t\t\t{\"nonsense\", time.Time{}.In(loc)},\n\t\t\t{\"0000-00-00 00:00:00\", time.Time{}.In(loc)},\n\t\t\t{timestamp1, timestamp1.In(loc)},\n\t\t\t{timestamp1.Unix(), timestamp1.In(loc)},\n\t\t\t{timestamp1.In(time.FixedZone(\"TEST\", -7*3600)), timestamp1.In(loc)},\n\t\t\t{timestamp1.Format(\"2006-01-02 15:04:05.000\"), timestamp1.In(loc)},\n\t\t\t{timestamp1.Format(\"2006-01-02T15:04:05.000\"), timestamp1.In(loc)},\n\t\t\t{timestamp1.Format(\"2006-01-02 15:04:05\"), timestamp1.In(loc)},\n\t\t\t{timestamp1.Format(\"2006-01-02T15:04:05\"), timestamp1.In(loc)},\n\t\t\t{timestamp2, timestamp2.In(loc)},\n\t\t\t{\"2006-01-02 15:04:05.123456789\", timestamp2.In(loc)},\n\t\t\t{\"2006-01-02T15:04:05.123456789\", timestamp2.In(loc)},\n\t\t\t{\"2012-11-04\", timestamp3.In(loc)},\n\t\t\t{\"2012-11-04 00:00\", timestamp3.In(loc)},\n\t\t\t{\"2012-11-04 00:00:00\", timestamp3.In(loc)},\n\t\t\t{\"2012-11-04 00:00:00.000\", timestamp3.In(loc)},\n\t\t\t{\"2012-11-04T00:00\", timestamp3.In(loc)},\n\t\t\t{\"2012-11-04T00:00:00\", timestamp3.In(loc)},\n\t\t\t{\"2012-11-04T00:00:00.000\", timestamp3.In(loc)},\n\t\t}\n\t\tfor i := range tests {\n\t\t\t_, err = db.Exec(\"INSERT INTO foo(id, ts, dt) VALUES(?, ?, ?)\", i, tests[i].value, tests[i].value)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(\"Failed to insert timestamp:\", err)\n\t\t\t}\n\t\t}\n\n\t\trows, err := db.Query(\"SELECT id, ts, dt FROM foo ORDER BY id ASC\")\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Unable to query foo table:\", err)\n\t\t}\n\t\tdefer rows.Close()\n\n\t\tseen := 0\n\t\tfor rows.Next() {\n\t\t\tvar id int\n\t\t\tvar ts, dt time.Time\n\n\t\t\tif err := rows.Scan(&id, &ts, &dt); err != nil {\n\t\t\t\tt.Error(\"Unable to scan results:\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif id < 0 || id >= len(tests) {\n\t\t\t\tt.Error(\"Bad row id: \", id)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tseen++\n\t\t\tif !tests[id].expected.Equal(ts) {\n\t\t\t\tt.Errorf(\"Timestamp value for id %v (%v) should be %v, not %v\", id, tests[id].value, tests[id].expected, ts)\n\t\t\t}\n\t\t\tif !tests[id].expected.Equal(dt) {\n\t\t\t\tt.Errorf(\"Datetime value for id %v (%v) should be %v, not %v\", id, tests[id].value, tests[id].expected, dt)\n\t\t\t}\n\t\t\tif tests[id].expected.Location().String() != ts.Location().String() {\n\t\t\t\tt.Errorf(\"Location for id %v (%v) should be %v, not %v\", id, tests[id].value, tests[id].expected.Location().String(), ts.Location().String())\n\t\t\t}\n\t\t\tif tests[id].expected.Location().String() != dt.Location().String() {\n\t\t\t\tt.Errorf(\"Location for id %v (%v) should be %v, not %v\", id, tests[id].value, tests[id].expected.Location().String(), dt.Location().String())\n\t\t\t}\n\t\t}\n\n\t\tif seen != len(tests) {\n\t\t\tt.Errorf(\"Expected to see %d rows\", len(tests))\n\t\t}\n\t}\n}\n\n// TODO: Execer & Queryer currently disabled\n// https://github.com/mattn/go-sqlite3/issues/82\nfunc TestExecer(t *testing.T) {\n\ttempFilename := TempFilename(t)\n\tdefer os.Remove(tempFilename)\n\tdb, err := sql.Open(\"sqlite3\", tempFilename)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to open database:\", err)\n\t}\n\tdefer db.Close()\n\n\t_, err = db.Exec(`\n       create table foo (id integer); -- one comment\n       insert into foo(id) values(?);\n       insert into foo(id) values(?);\n       insert into foo(id) values(?); -- another comment\n       `, 1, 2, 3)\n\tif err != nil {\n\t\tt.Error(\"Failed to call db.Exec:\", err)\n\t}\n}\n\nfunc TestQueryer(t *testing.T) {\n\ttempFilename := TempFilename(t)\n\tdefer os.Remove(tempFilename)\n\tdb, err := sql.Open(\"sqlite3\", tempFilename)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to open database:\", err)\n\t}\n\tdefer db.Close()\n\n\t_, err = db.Exec(`\n\t\tcreate table foo (id integer);\n\t`)\n\tif err != nil {\n\t\tt.Error(\"Failed to call db.Query:\", err)\n\t}\n\n\t_, err = db.Exec(`\n\t\tinsert into foo(id) values(?);\n\t\tinsert into foo(id) values(?);\n\t\tinsert into foo(id) values(?);\n\t`, 3, 2, 1)\n\tif err != nil {\n\t\tt.Error(\"Failed to call db.Exec:\", err)\n\t}\n\trows, err := db.Query(`\n\t\tselect id from foo order by id;\n\t`)\n\tif err != nil {\n\t\tt.Error(\"Failed to call db.Query:\", err)\n\t}\n\tdefer rows.Close()\n\tn := 0\n\tfor rows.Next() {\n\t\tvar id int\n\t\terr = rows.Scan(&id)\n\t\tif err != nil {\n\t\t\tt.Error(\"Failed to db.Query:\", err)\n\t\t}\n\t\tif id != n+1 {\n\t\t\tt.Error(\"Failed to db.Query: not matched results\")\n\t\t}\n\t\tn = n + 1\n\t}\n\tif err := rows.Err(); err != nil {\n\t\tt.Errorf(\"Post-scan failed: %v\\n\", err)\n\t}\n\tif n != 3 {\n\t\tt.Errorf(\"Expected 3 rows but retrieved %v\", n)\n\t}\n}\n\nfunc TestStress(t *testing.T) {\n\ttempFilename := TempFilename(t)\n\tdefer os.Remove(tempFilename)\n\tdb, err := sql.Open(\"sqlite3\", tempFilename)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to open database:\", err)\n\t}\n\tdb.Exec(\"CREATE TABLE foo (id int);\")\n\tdb.Exec(\"INSERT INTO foo VALUES(1);\")\n\tdb.Exec(\"INSERT INTO foo VALUES(2);\")\n\tdb.Close()\n\n\tfor i := 0; i < 10000; i++ {\n\t\tdb, err := sql.Open(\"sqlite3\", tempFilename)\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Failed to open database:\", err)\n\t\t}\n\n\t\tfor j := 0; j < 3; j++ {\n\t\t\trows, err := db.Query(\"select * from foo where id=1;\")\n\t\t\tif err != nil {\n\t\t\t\tt.Error(\"Failed to call db.Query:\", err)\n\t\t\t}\n\t\t\tfor rows.Next() {\n\t\t\t\tvar i int\n\t\t\t\tif err := rows.Scan(&i); err != nil {\n\t\t\t\t\tt.Errorf(\"Scan failed: %v\\n\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif err := rows.Err(); err != nil {\n\t\t\t\tt.Errorf(\"Post-scan failed: %v\\n\", err)\n\t\t\t}\n\t\t\trows.Close()\n\t\t}\n\t\tdb.Close()\n\t}\n}\n\nfunc TestDateTimeLocal(t *testing.T) {\n\tzone := \"Asia/Tokyo\"\n\ttempFilename := TempFilename(t)\n\tdefer os.Remove(tempFilename)\n\tdb, err := sql.Open(\"sqlite3\", tempFilename+\"?_loc=\"+zone)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to open database:\", err)\n\t}\n\tdb.Exec(\"CREATE TABLE foo (dt datetime);\")\n\tdb.Exec(\"INSERT INTO foo VALUES('2015-03-05 15:16:17');\")\n\n\trow := db.QueryRow(\"select * from foo\")\n\tvar d time.Time\n\terr = row.Scan(&d)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to scan datetime:\", err)\n\t}\n\tif d.Hour() == 15 || !strings.Contains(d.String(), \"JST\") {\n\t\tt.Fatal(\"Result should have timezone\", d)\n\t}\n\tdb.Close()\n\n\tdb, err = sql.Open(\"sqlite3\", tempFilename)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to open database:\", err)\n\t}\n\n\trow = db.QueryRow(\"select * from foo\")\n\terr = row.Scan(&d)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to scan datetime:\", err)\n\t}\n\tif d.UTC().Hour() != 15 || !strings.Contains(d.String(), \"UTC\") {\n\t\tt.Fatalf(\"Result should not have timezone %v %v\", zone, d.String())\n\t}\n\n\t_, err = db.Exec(\"DELETE FROM foo\")\n\tif err != nil {\n\t\tt.Fatal(\"Failed to delete table:\", err)\n\t}\n\tdt, err := time.Parse(\"2006/1/2 15/4/5 -0700 MST\", \"2015/3/5 15/16/17 +0900 JST\")\n\tif err != nil {\n\t\tt.Fatal(\"Failed to parse datetime:\", err)\n\t}\n\tdb.Exec(\"INSERT INTO foo VALUES(?);\", dt)\n\n\tdb.Close()\n\tdb, err = sql.Open(\"sqlite3\", tempFilename+\"?_loc=\"+zone)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to open database:\", err)\n\t}\n\n\trow = db.QueryRow(\"select * from foo\")\n\terr = row.Scan(&d)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to scan datetime:\", err)\n\t}\n\tif d.Hour() != 15 || !strings.Contains(d.String(), \"JST\") {\n\t\tt.Fatalf(\"Result should have timezone %v %v\", zone, d.String())\n\t}\n}\n\nfunc TestVersion(t *testing.T) {\n\ts, n, id := Version()\n\tif s == \"\" || n == 0 || id == \"\" {\n\t\tt.Errorf(\"Version failed %q, %d, %q\\n\", s, n, id)\n\t}\n}\n\nfunc TestStringContainingZero(t *testing.T) {\n\ttempFilename := TempFilename(t)\n\tdefer os.Remove(tempFilename)\n\tdb, err := sql.Open(\"sqlite3\", tempFilename)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to open database:\", err)\n\t}\n\tdefer db.Close()\n\n\t_, err = db.Exec(`\n\tcreate table foo (id integer, name, extra text);\n\t`)\n\tif err != nil {\n\t\tt.Error(\"Failed to call db.Query:\", err)\n\t}\n\n\tconst text = \"foo\\x00bar\"\n\n\t_, err = db.Exec(`insert into foo(id, name, extra) values($1, $2, $2)`, 1, text)\n\tif err != nil {\n\t\tt.Error(\"Failed to call db.Exec:\", err)\n\t}\n\n\trow := db.QueryRow(`select id, extra from foo where id = $1 and extra = $2`, 1, text)\n\tif row == nil {\n\t\tt.Error(\"Failed to call db.QueryRow\")\n\t}\n\n\tvar id int\n\tvar extra string\n\terr = row.Scan(&id, &extra)\n\tif err != nil {\n\t\tt.Error(\"Failed to db.Scan:\", err)\n\t}\n\tif id != 1 || extra != text {\n\t\tt.Error(\"Failed to db.QueryRow: not matched results\")\n\t}\n}\n\nconst CurrentTimeStamp = \"2006-01-02 15:04:05\"\n\ntype TimeStamp struct{ *time.Time }\n\nfunc (t TimeStamp) Scan(value any) error {\n\tvar err error\n\tswitch v := value.(type) {\n\tcase string:\n\t\t*t.Time, err = time.Parse(CurrentTimeStamp, v)\n\tcase []byte:\n\t\t*t.Time, err = time.Parse(CurrentTimeStamp, string(v))\n\tdefault:\n\t\terr = errors.New(\"invalid type for current_timestamp\")\n\t}\n\treturn err\n}\n\nfunc (t TimeStamp) Value() (driver.Value, error) {\n\treturn t.Time.Format(CurrentTimeStamp), nil\n}\n\nfunc TestDateTimeNow(t *testing.T) {\n\ttempFilename := TempFilename(t)\n\tdefer os.Remove(tempFilename)\n\tdb, err := sql.Open(\"sqlite3\", tempFilename)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to open database:\", err)\n\t}\n\tdefer db.Close()\n\n\tvar d time.Time\n\terr = db.QueryRow(\"SELECT datetime('now')\").Scan(TimeStamp{&d})\n\tif err != nil {\n\t\tt.Fatal(\"Failed to scan datetime:\", err)\n\t}\n}\n\nfunc TestFunctionRegistration(t *testing.T) {\n\taddi8_16_32 := func(a int8, b int16) int32 { return int32(a) + int32(b) }\n\taddi64 := func(a, b int64) int64 { return a + b }\n\taddu8_16_32 := func(a uint8, b uint16) uint32 { return uint32(a) + uint32(b) }\n\taddu64 := func(a, b uint64) uint64 { return a + b }\n\taddiu := func(a int, b uint) int64 { return int64(a) + int64(b) }\n\taddf32_64 := func(a float32, b float64) float64 { return float64(a) + b }\n\tnot := func(a bool) bool { return !a }\n\tregex := func(re, s string) (bool, error) {\n\t\treturn regexp.MatchString(re, s)\n\t}\n\tgeneric := func(a any) int64 {\n\t\tswitch a.(type) {\n\t\tcase int64:\n\t\t\treturn 1\n\t\tcase float64:\n\t\t\treturn 2\n\t\tcase []byte:\n\t\t\treturn 3\n\t\tcase string:\n\t\t\treturn 4\n\t\tdefault:\n\t\t\tpanic(\"unreachable\")\n\t\t}\n\t}\n\tvariadic := func(a, b int64, c ...int64) int64 {\n\t\tret := a + b\n\t\tfor _, d := range c {\n\t\t\tret += d\n\t\t}\n\t\treturn ret\n\t}\n\tvariadicGeneric := func(a ...any) int64 {\n\t\treturn int64(len(a))\n\t}\n\n\tsql.Register(\"sqlite3_FunctionRegistration\", &SQLiteDriver{\n\t\tConnectHook: func(conn *SQLiteConn) error {\n\t\t\tif err := conn.RegisterFunc(\"addi8_16_32\", addi8_16_32, true); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err := conn.RegisterFunc(\"addi64\", addi64, true); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err := conn.RegisterFunc(\"addu8_16_32\", addu8_16_32, true); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err := conn.RegisterFunc(\"addu64\", addu64, true); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err := conn.RegisterFunc(\"addiu\", addiu, true); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err := conn.RegisterFunc(\"addf32_64\", addf32_64, true); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err := conn.RegisterFunc(\"not\", not, true); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err := conn.RegisterFunc(\"regex\", regex, true); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err := conn.RegisterFunc(\"generic\", generic, true); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err := conn.RegisterFunc(\"variadic\", variadic, true); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err := conn.RegisterFunc(\"variadicGeneric\", variadicGeneric, true); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t})\n\tdb, err := sql.Open(\"sqlite3_FunctionRegistration\", \":memory:\")\n\tif err != nil {\n\t\tt.Fatal(\"Failed to open database:\", err)\n\t}\n\tdefer db.Close()\n\n\tops := []struct {\n\t\tquery    string\n\t\texpected any\n\t}{\n\t\t{\"SELECT addi8_16_32(1,2)\", int32(3)},\n\t\t{\"SELECT addi64(1,2)\", int64(3)},\n\t\t{\"SELECT addu8_16_32(1,2)\", uint32(3)},\n\t\t{\"SELECT addu64(1,2)\", uint64(3)},\n\t\t{\"SELECT addiu(1,2)\", int64(3)},\n\t\t{\"SELECT addf32_64(1.5,1.5)\", float64(3)},\n\t\t{\"SELECT not(1)\", false},\n\t\t{\"SELECT not(0)\", true},\n\t\t{`SELECT regex('^foo.*', 'foobar')`, true},\n\t\t{`SELECT regex('^foo.*', 'barfoobar')`, false},\n\t\t{\"SELECT generic(1)\", int64(1)},\n\t\t{\"SELECT generic(1.1)\", int64(2)},\n\t\t{`SELECT generic(NULL)`, int64(3)},\n\t\t{`SELECT generic('foo')`, int64(4)},\n\t\t{\"SELECT variadic(1,2)\", int64(3)},\n\t\t{\"SELECT variadic(1,2,3,4)\", int64(10)},\n\t\t{\"SELECT variadic(1,1,1,1,1,1,1,1,1,1)\", int64(10)},\n\t\t{`SELECT variadicGeneric(1,'foo',2.3, NULL)`, int64(4)},\n\t}\n\n\tfor _, op := range ops {\n\t\tret := reflect.New(reflect.TypeOf(op.expected))\n\t\terr = db.QueryRow(op.query).Scan(ret.Interface())\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Query %q failed: %s\", op.query, err)\n\t\t} else if !reflect.DeepEqual(ret.Elem().Interface(), op.expected) {\n\t\t\tt.Errorf(\"Query %q returned wrong value: got %v (%T), want %v (%T)\", op.query, ret.Elem().Interface(), ret.Elem().Interface(), op.expected, op.expected)\n\t\t}\n\t}\n}\n\ntype sumAggregator int64\n\nfunc (s *sumAggregator) Step(x int64) {\n\t*s += sumAggregator(x)\n}\n\nfunc (s *sumAggregator) Done() int64 {\n\treturn int64(*s)\n}\n\nfunc TestAggregatorRegistration(t *testing.T) {\n\tcustomSum := func() *sumAggregator {\n\t\tvar ret sumAggregator\n\t\treturn &ret\n\t}\n\n\tsql.Register(\"sqlite3_AggregatorRegistration\", &SQLiteDriver{\n\t\tConnectHook: func(conn *SQLiteConn) error {\n\t\t\treturn conn.RegisterAggregator(\"customSum\", customSum, true)\n\t\t},\n\t})\n\tdb, err := sql.Open(\"sqlite3_AggregatorRegistration\", \":memory:\")\n\tif err != nil {\n\t\tt.Fatal(\"Failed to open database:\", err)\n\t}\n\tdefer db.Close()\n\n\t_, err = db.Exec(\"create table foo (department integer, profits integer)\")\n\tif err != nil {\n\t\t// trace feature is not implemented\n\t\tt.Skip(\"Failed to create table:\", err)\n\t}\n\n\t_, err = db.Exec(\"insert into foo values (1, 10), (1, 20), (2, 42)\")\n\tif err != nil {\n\t\tt.Fatal(\"Failed to insert records:\", err)\n\t}\n\n\ttests := []struct {\n\t\tdept, sum int64\n\t}{\n\t\t{1, 30},\n\t\t{2, 42},\n\t}\n\n\tfor _, test := range tests {\n\t\tvar ret int64\n\t\terr = db.QueryRow(\"select customSum(profits) from foo where department = $1 group by department\", test.dept).Scan(&ret)\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Query failed:\", err)\n\t\t}\n\t\tif ret != test.sum {\n\t\t\tt.Fatalf(\"Custom sum returned wrong value, got %d, want %d\", ret, test.sum)\n\t\t}\n\t}\n}\n\ntype mode struct {\n\tcounts   map[any]int\n\ttop      any\n\ttopCount int\n}\n\nfunc newMode() *mode {\n\treturn &mode{\n\t\tcounts: map[any]int{},\n\t}\n}\n\nfunc (m *mode) Step(x any) {\n\tm.counts[x]++\n\tc := m.counts[x]\n\tif c > m.topCount {\n\t\tm.top = x\n\t\tm.topCount = c\n\t}\n}\n\nfunc (m *mode) Done() any {\n\treturn m.top\n}\n\nfunc TestAggregatorRegistration_GenericReturn(t *testing.T) {\n\tsql.Register(\"sqlite3_AggregatorRegistration_GenericReturn\", &SQLiteDriver{\n\t\tConnectHook: func(conn *SQLiteConn) error {\n\t\t\treturn conn.RegisterAggregator(\"mode\", newMode, true)\n\t\t},\n\t})\n\tdb, err := sql.Open(\"sqlite3_AggregatorRegistration_GenericReturn\", \":memory:\")\n\tif err != nil {\n\t\tt.Fatal(\"Failed to open database:\", err)\n\t}\n\tdefer db.Close()\n\n\t_, err = db.Exec(\"create table foo (department integer, profits integer)\")\n\tif err != nil {\n\t\tt.Fatal(\"Failed to create table:\", err)\n\t}\n\t_, err = db.Exec(\"insert into foo values (1, 10), (1, 20), (1, 45), (2, 42), (2, 115), (2, 20)\")\n\tif err != nil {\n\t\tt.Fatal(\"Failed to insert records:\", err)\n\t}\n\n\tvar mode int\n\terr = db.QueryRow(\"select mode(profits) from foo\").Scan(&mode)\n\tif err != nil {\n\t\tt.Fatal(\"MODE query error:\", err)\n\t}\n\n\tif mode != 20 {\n\t\tt.Fatal(\"Got incorrect mode. Wanted 20, got: \", mode)\n\t}\n}\n\nfunc rot13(r rune) rune {\n\tswitch {\n\tcase r >= 'A' && r <= 'Z':\n\t\treturn 'A' + (r-'A'+13)%26\n\tcase r >= 'a' && r <= 'z':\n\t\treturn 'a' + (r-'a'+13)%26\n\t}\n\treturn r\n}\n\nfunc TestCollationRegistration(t *testing.T) {\n\tcollateRot13 := func(a, b string) int {\n\t\tra, rb := strings.Map(rot13, a), strings.Map(rot13, b)\n\t\treturn strings.Compare(ra, rb)\n\t}\n\tcollateRot13Reverse := func(a, b string) int {\n\t\treturn collateRot13(b, a)\n\t}\n\n\tsql.Register(\"sqlite3_CollationRegistration\", &SQLiteDriver{\n\t\tConnectHook: func(conn *SQLiteConn) error {\n\t\t\tif err := conn.RegisterCollation(\"rot13\", collateRot13); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err := conn.RegisterCollation(\"rot13reverse\", collateRot13Reverse); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t})\n\n\tdb, err := sql.Open(\"sqlite3_CollationRegistration\", \":memory:\")\n\tif err != nil {\n\t\tt.Fatal(\"Failed to open database:\", err)\n\t}\n\tdefer db.Close()\n\n\tpopulate := []string{\n\t\t`CREATE TABLE test (s TEXT)`,\n\t\t`INSERT INTO test VALUES ('aaaa')`,\n\t\t`INSERT INTO test VALUES ('ffff')`,\n\t\t`INSERT INTO test VALUES ('qqqq')`,\n\t\t`INSERT INTO test VALUES ('tttt')`,\n\t\t`INSERT INTO test VALUES ('zzzz')`,\n\t}\n\tfor _, stmt := range populate {\n\t\tif _, err := db.Exec(stmt); err != nil {\n\t\t\tt.Fatal(\"Failed to populate test DB:\", err)\n\t\t}\n\t}\n\n\tops := []struct {\n\t\tquery string\n\t\twant  []string\n\t}{\n\t\t{\n\t\t\t\"SELECT * FROM test ORDER BY s COLLATE rot13 ASC\",\n\t\t\t[]string{\n\t\t\t\t\"qqqq\",\n\t\t\t\t\"tttt\",\n\t\t\t\t\"zzzz\",\n\t\t\t\t\"aaaa\",\n\t\t\t\t\"ffff\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"SELECT * FROM test ORDER BY s COLLATE rot13 DESC\",\n\t\t\t[]string{\n\t\t\t\t\"ffff\",\n\t\t\t\t\"aaaa\",\n\t\t\t\t\"zzzz\",\n\t\t\t\t\"tttt\",\n\t\t\t\t\"qqqq\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"SELECT * FROM test ORDER BY s COLLATE rot13reverse ASC\",\n\t\t\t[]string{\n\t\t\t\t\"ffff\",\n\t\t\t\t\"aaaa\",\n\t\t\t\t\"zzzz\",\n\t\t\t\t\"tttt\",\n\t\t\t\t\"qqqq\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"SELECT * FROM test ORDER BY s COLLATE rot13reverse DESC\",\n\t\t\t[]string{\n\t\t\t\t\"qqqq\",\n\t\t\t\t\"tttt\",\n\t\t\t\t\"zzzz\",\n\t\t\t\t\"aaaa\",\n\t\t\t\t\"ffff\",\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, op := range ops {\n\t\trows, err := db.Query(op.query)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Query %q failed: %s\", op.query, err)\n\t\t}\n\t\tgot := []string{}\n\t\tdefer rows.Close()\n\t\tfor rows.Next() {\n\t\t\tvar s string\n\t\t\tif err = rows.Scan(&s); err != nil {\n\t\t\t\tt.Fatalf(\"Reading row for %q: %s\", op.query, err)\n\t\t\t}\n\t\t\tgot = append(got, s)\n\t\t}\n\t\tif err = rows.Err(); err != nil {\n\t\t\tt.Fatalf(\"Reading rows for %q: %s\", op.query, err)\n\t\t}\n\n\t\tif !reflect.DeepEqual(got, op.want) {\n\t\t\tt.Fatalf(\"Unexpected output from %q\\ngot:\\n%s\\n\\nwant:\\n%s\", op.query, strings.Join(got, \"\\n\"), strings.Join(op.want, \"\\n\"))\n\t\t}\n\t}\n}\n\nfunc TestDeclTypes(t *testing.T) {\n\n\td := SQLiteDriver{}\n\n\tconn, err := d.Open(\":memory:\")\n\tif err != nil {\n\t\tt.Fatal(\"Failed to begin transaction:\", err)\n\t}\n\tdefer conn.Close()\n\n\tsqlite3conn := conn.(*SQLiteConn)\n\n\t_, err = sqlite3conn.Exec(\"create table foo (id integer not null primary key, name text)\", nil)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to create table:\", err)\n\t}\n\n\t_, err = sqlite3conn.Exec(\"insert into foo(name) values('bar')\", nil)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to insert:\", err)\n\t}\n\n\trs, err := sqlite3conn.Query(\"select * from foo\", nil)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to select:\", err)\n\t}\n\tdefer rs.Close()\n\n\tdeclTypes := rs.(*SQLiteRows).DeclTypes()\n\n\tif !reflect.DeepEqual(declTypes, []string{\"integer\", \"text\"}) {\n\t\tt.Fatal(\"Unexpected declTypes:\", declTypes)\n\t}\n}\n\nfunc TestPinger(t *testing.T) {\n\tdb, err := sql.Open(\"sqlite3\", \":memory:\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\terr = db.Ping()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdb.Close()\n\terr = db.Ping()\n\tif err == nil {\n\t\tt.Fatal(\"Should be closed\")\n\t}\n}\n\nfunc TestUpdateAndTransactionHooks(t *testing.T) {\n\tvar events []string\n\tvar commitHookReturn = 0\n\n\tsql.Register(\"sqlite3_UpdateHook\", &SQLiteDriver{\n\t\tConnectHook: func(conn *SQLiteConn) error {\n\t\t\tconn.RegisterCommitHook(func() int {\n\t\t\t\tevents = append(events, \"commit\")\n\t\t\t\treturn commitHookReturn\n\t\t\t})\n\t\t\tconn.RegisterRollbackHook(func() {\n\t\t\t\tevents = append(events, \"rollback\")\n\t\t\t})\n\t\t\tconn.RegisterUpdateHook(func(op int, db string, table string, rowid int64) {\n\t\t\t\tevents = append(events, fmt.Sprintf(\"update(op=%v db=%v table=%v rowid=%v)\", op, db, table, rowid))\n\t\t\t})\n\t\t\treturn nil\n\t\t},\n\t})\n\tdb, err := sql.Open(\"sqlite3_UpdateHook\", \":memory:\")\n\tif err != nil {\n\t\tt.Fatal(\"Failed to open database:\", err)\n\t}\n\tdefer db.Close()\n\n\tstatements := []string{\n\t\t\"create table foo (id integer primary key)\",\n\t\t\"insert into foo values (9)\",\n\t\t\"update foo set id = 99 where id = 9\",\n\t\t\"delete from foo where id = 99\",\n\t}\n\tfor _, statement := range statements {\n\t\t_, err = db.Exec(statement)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Unable to prepare test data [%v]: %v\", statement, err)\n\t\t}\n\t}\n\n\tcommitHookReturn = 1\n\t_, err = db.Exec(\"insert into foo values (5)\")\n\tif err == nil {\n\t\tt.Error(\"Commit hook failed to rollback transaction\")\n\t}\n\n\tvar expected = []string{\n\t\t\"commit\",\n\t\tfmt.Sprintf(\"update(op=%v db=main table=foo rowid=9)\", SQLITE_INSERT),\n\t\t\"commit\",\n\t\tfmt.Sprintf(\"update(op=%v db=main table=foo rowid=99)\", SQLITE_UPDATE),\n\t\t\"commit\",\n\t\tfmt.Sprintf(\"update(op=%v db=main table=foo rowid=99)\", SQLITE_DELETE),\n\t\t\"commit\",\n\t\tfmt.Sprintf(\"update(op=%v db=main table=foo rowid=5)\", SQLITE_INSERT),\n\t\t\"commit\",\n\t\t\"rollback\",\n\t}\n\tif !reflect.DeepEqual(events, expected) {\n\t\tt.Errorf(\"Expected notifications %v but got %v\", expected, events)\n\t}\n}\n\nfunc TestAuthorizer(t *testing.T) {\n\tvar authorizerReturn = 0\n\n\tsql.Register(\"sqlite3_Authorizer\", &SQLiteDriver{\n\t\tConnectHook: func(conn *SQLiteConn) error {\n\t\t\tconn.RegisterAuthorizer(func(op int, arg1, arg2, arg3 string) int {\n\t\t\t\treturn authorizerReturn\n\t\t\t})\n\t\t\treturn nil\n\t\t},\n\t})\n\tdb, err := sql.Open(\"sqlite3_Authorizer\", \":memory:\")\n\tif err != nil {\n\t\tt.Fatal(\"Failed to open database:\", err)\n\t}\n\tdefer db.Close()\n\n\tstatements := []string{\n\t\t\"create table foo (id integer primary key, name varchar)\",\n\t\t\"insert into foo values (9, 'test9')\",\n\t\t\"update foo set name = 'test99' where id = 9\",\n\t\t\"select * from foo\",\n\t}\n\n\tauthorizerReturn = SQLITE_OK\n\tfor _, statement := range statements {\n\t\t_, err = db.Exec(statement)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"No error expected [%v]: %v\", statement, err)\n\t\t}\n\t}\n\n\tauthorizerReturn = SQLITE_DENY\n\tfor _, statement := range statements {\n\t\t_, err = db.Exec(statement)\n\t\tif err == nil {\n\t\t\tt.Fatalf(\"Authorizer didn't worked - nil received, but error expected: [%v]\", statement)\n\t\t}\n\t}\n}\n\nfunc TestSetFileControlInt(t *testing.T) {\n\tt.Run(\"PERSIST_WAL\", func(t *testing.T) {\n\t\ttempFilename := TempFilename(t)\n\t\tdefer os.Remove(tempFilename)\n\n\t\tsql.Register(\"sqlite3_FCNTL_PERSIST_WAL\", &SQLiteDriver{\n\t\t\tConnectHook: func(conn *SQLiteConn) error {\n\t\t\t\tif err := conn.SetFileControlInt(\"\", SQLITE_FCNTL_PERSIST_WAL, 1); err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"Unexpected error from SetFileControlInt(): %w\", err)\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t},\n\t\t})\n\n\t\tdb, err := sql.Open(\"sqlite3_FCNTL_PERSIST_WAL\", tempFilename)\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Failed to open database:\", err)\n\t\t}\n\t\tdefer db.Close()\n\n\t\t// Set to WAL mode & write a page.\n\t\tif _, err := db.Exec(`PRAGMA journal_mode = wal`); err != nil {\n\t\t\tt.Fatal(\"Failed to set journal mode:\", err)\n\t\t} else if _, err := db.Exec(`CREATE TABLE t (x)`); err != nil {\n\t\t\tt.Fatal(\"Failed to create table:\", err)\n\t\t}\n\t\tif err := db.Close(); err != nil {\n\t\t\tt.Fatal(\"Failed to close database\", err)\n\t\t}\n\n\t\t// Ensure WAL file persists after close.\n\t\tif _, err := os.Stat(tempFilename + \"-wal\"); err != nil {\n\t\t\tt.Fatal(\"Expected WAL file to be persisted after close\", err)\n\t\t}\n\t})\n}\n\nfunc TestNonColumnString(t *testing.T) {\n\tdb, err := sql.Open(\"sqlite3\", \":memory:\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\tvar x any\n\tif err := db.QueryRow(\"SELECT 'hello'\").Scan(&x); err != nil {\n\t\tt.Fatal(err)\n\t}\n\ts, ok := x.(string)\n\tif !ok {\n\t\tt.Fatalf(\"non-column string must return string but got %T\", x)\n\t}\n\tif s != \"hello\" {\n\t\tt.Fatalf(\"non-column string must return %q but got %q\", \"hello\", s)\n\t}\n}\n\nfunc TestNilAndEmptyBytes(t *testing.T) {\n\tdb, err := sql.Open(\"sqlite3\", \":memory:\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\tactualNil := []byte(\"use this to use an actual nil not a reference to nil\")\n\temptyBytes := []byte{}\n\tfor tsti, tst := range []struct {\n\t\tname          string\n\t\tcolumnType    string\n\t\tinsertBytes   []byte\n\t\texpectedBytes []byte\n\t}{\n\t\t{\"actual nil blob\", \"blob\", actualNil, nil},\n\t\t{\"referenced nil blob\", \"blob\", nil, nil},\n\t\t{\"empty blob\", \"blob\", emptyBytes, emptyBytes},\n\t\t{\"actual nil text\", \"text\", actualNil, nil},\n\t\t{\"referenced nil text\", \"text\", nil, nil},\n\t\t{\"empty text\", \"text\", emptyBytes, emptyBytes},\n\t} {\n\t\tif _, err = db.Exec(fmt.Sprintf(\"create table tbl%d (txt %s)\", tsti, tst.columnType)); err != nil {\n\t\t\tt.Fatal(tst.name, err)\n\t\t}\n\t\tif bytes.Equal(tst.insertBytes, actualNil) {\n\t\t\tif _, err = db.Exec(fmt.Sprintf(\"insert into tbl%d (txt) values (?)\", tsti), nil); err != nil {\n\t\t\t\tt.Fatal(tst.name, err)\n\t\t\t}\n\t\t} else {\n\t\t\tif _, err = db.Exec(fmt.Sprintf(\"insert into tbl%d (txt) values (?)\", tsti), &tst.insertBytes); err != nil {\n\t\t\t\tt.Fatal(tst.name, err)\n\t\t\t}\n\t\t}\n\t\trows, err := db.Query(fmt.Sprintf(\"select txt from tbl%d\", tsti))\n\t\tif err != nil {\n\t\t\tt.Fatal(tst.name, err)\n\t\t}\n\t\tif !rows.Next() {\n\t\t\tt.Fatal(tst.name, \"no rows\")\n\t\t}\n\t\tvar scanBytes []byte\n\t\tif err = rows.Scan(&scanBytes); err != nil {\n\t\t\tt.Fatal(tst.name, err)\n\t\t}\n\t\tif err = rows.Err(); err != nil {\n\t\t\tt.Fatal(tst.name, err)\n\t\t}\n\t\tif tst.expectedBytes == nil && scanBytes != nil {\n\t\t\tt.Errorf(\"%s: %#v != %#v\", tst.name, scanBytes, tst.expectedBytes)\n\t\t} else if !bytes.Equal(scanBytes, tst.expectedBytes) {\n\t\t\tt.Errorf(\"%s: %#v != %#v\", tst.name, scanBytes, tst.expectedBytes)\n\t\t}\n\t}\n}\n\nfunc TestInsertNilByteSlice(t *testing.T) {\n\tdb, err := sql.Open(\"sqlite3\", \":memory:\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\tif _, err := db.Exec(\"create table blob_not_null (b blob not null)\"); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tvar nilSlice []byte\n\tif _, err := db.Exec(\"insert into blob_not_null (b) values (?)\", nilSlice); err == nil {\n\t\tt.Fatal(\"didn't expect INSERT to 'not null' column with a nil []byte slice to work\")\n\t}\n\tzeroLenSlice := []byte{}\n\tif _, err := db.Exec(\"insert into blob_not_null (b) values (?)\", zeroLenSlice); err != nil {\n\t\tt.Fatal(\"failed to insert zero-length slice\")\n\t}\n}\n\nfunc TestNamedParam(t *testing.T) {\n\ttempFilename := TempFilename(t)\n\tdefer os.Remove(tempFilename)\n\tdb, err := sql.Open(\"sqlite3\", tempFilename)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to open database:\", err)\n\t}\n\tdefer db.Close()\n\n\t_, err = db.Exec(\"drop table foo\")\n\t_, err = db.Exec(\"create table foo (id integer, name text, amount integer)\")\n\tif err != nil {\n\t\tt.Fatal(\"Failed to create table:\", err)\n\t}\n\n\t_, err = db.Exec(\"insert into foo(id, name, amount) values(:id, @name, $amount)\",\n\t\tsql.Named(\"bar\", 42), sql.Named(\"baz\", \"quux\"),\n\t\tsql.Named(\"amount\", 123), sql.Named(\"corge\", \"waldo\"),\n\t\tsql.Named(\"id\", 2), sql.Named(\"name\", \"grault\"))\n\tif err != nil {\n\t\tt.Fatal(\"Failed to insert record with named parameters:\", err)\n\t}\n\n\trows, err := db.Query(\"select id, name, amount from foo\")\n\tif err != nil {\n\t\tt.Fatal(\"Failed to select records:\", err)\n\t}\n\tdefer rows.Close()\n\n\trows.Next()\n\n\tvar id, amount int\n\tvar name string\n\trows.Scan(&id, &name, &amount)\n\tif id != 2 || name != \"grault\" || amount != 123 {\n\t\tt.Errorf(\"Expected %d, %q, %d for fetched result, but got %d, %q, %d:\", 2, \"grault\", 123, id, name, amount)\n\t}\n}\n\nvar customFunctionOnce sync.Once\n\nfunc BenchmarkCustomFunctions(b *testing.B) {\n\tcustomFunctionOnce.Do(func() {\n\t\tcustomAdd := func(a, b int64) int64 {\n\t\t\treturn a + b\n\t\t}\n\n\t\tsql.Register(\"sqlite3_BenchmarkCustomFunctions\", &SQLiteDriver{\n\t\t\tConnectHook: func(conn *SQLiteConn) error {\n\t\t\t\t// Impure function to force sqlite to reexecute it each time.\n\t\t\t\treturn conn.RegisterFunc(\"custom_add\", customAdd, false)\n\t\t\t},\n\t\t})\n\t})\n\n\tdb, err := sql.Open(\"sqlite3_BenchmarkCustomFunctions\", \":memory:\")\n\tif err != nil {\n\t\tb.Fatal(\"Failed to open database:\", err)\n\t}\n\tdefer db.Close()\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tvar i int64\n\t\terr = db.QueryRow(\"SELECT custom_add(1,2)\").Scan(&i)\n\t\tif err != nil {\n\t\t\tb.Fatal(\"Failed to run custom add:\", err)\n\t\t}\n\t}\n}\n\nfunc TestSuite(t *testing.T) {\n\tinitializeTestDB(t)\n\tdefer freeTestDB()\n\n\tfor _, test := range tests {\n\t\tt.Run(test.Name, test.F)\n\t}\n}\n\nfunc BenchmarkSuite(b *testing.B) {\n\tinitializeTestDB(b)\n\tdefer freeTestDB()\n\n\tfor _, benchmark := range benchmarks {\n\t\tb.Run(benchmark.Name, benchmark.F)\n\t}\n}\n\n// Dialect is a type of dialect of databases.\ntype Dialect int\n\n// Dialects for databases.\nconst (\n\tSQLITE     Dialect = iota // SQLITE mean SQLite3 dialect\n\tPOSTGRESQL                // POSTGRESQL mean PostgreSQL dialect\n\tMYSQL                     // MYSQL mean MySQL dialect\n)\n\n// DB provide context for the tests\ntype TestDB struct {\n\ttesting.TB\n\t*sql.DB\n\tdialect      Dialect\n\tonce         sync.Once\n\ttempFilename string\n}\n\nvar db *TestDB\n\nfunc initializeTestDB(t testing.TB) {\n\ttempFilename := TempFilename(t)\n\td, err := sql.Open(\"sqlite3\", tempFilename+\"?_busy_timeout=99999\")\n\tif err != nil {\n\t\tos.Remove(tempFilename)\n\t\tt.Fatal(err)\n\t}\n\n\tdb = &TestDB{t, d, SQLITE, sync.Once{}, tempFilename}\n}\n\nfunc freeTestDB() {\n\terr := db.DB.Close()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\terr = os.Remove(db.tempFilename)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// the following tables will be created and dropped during the test\nvar testTables = []string{\"foo\", \"bar\", \"t\", \"bench\"}\n\nvar tests = []testing.InternalTest{\n\t{Name: \"TestResult\", F: testResult},\n\t{Name: \"TestBlobs\", F: testBlobs},\n\t{Name: \"TestMultiBlobs\", F: testMultiBlobs},\n\t{Name: \"TestNullZeroLengthBlobs\", F: testNullZeroLengthBlobs},\n\t{Name: \"TestManyQueryRow\", F: testManyQueryRow},\n\t{Name: \"TestTxQuery\", F: testTxQuery},\n\t{Name: \"TestPreparedStmt\", F: testPreparedStmt},\n\t{Name: \"TestExecEmptyQuery\", F: testExecEmptyQuery},\n}\n\nvar benchmarks = []testing.InternalBenchmark{\n\t{Name: \"BenchmarkExec\", F: benchmarkExec},\n\t{Name: \"BenchmarkQuery\", F: benchmarkQuery},\n\t{Name: \"BenchmarkParams\", F: benchmarkParams},\n\t{Name: \"BenchmarkStmt\", F: benchmarkStmt},\n\t{Name: \"BenchmarkRows\", F: benchmarkRows},\n\t{Name: \"BenchmarkStmtRows\", F: benchmarkStmtRows},\n\t{Name: \"BenchmarkQueryParallel\", F: benchmarkQueryParallel},\n}\n\nfunc (db *TestDB) mustExec(sql string, args ...any) sql.Result {\n\tres, err := db.Exec(sql, args...)\n\tif err != nil {\n\t\tdb.Fatalf(\"Error running %q: %v\", sql, err)\n\t}\n\treturn res\n}\n\nfunc (db *TestDB) tearDown() {\n\tfor _, tbl := range testTables {\n\t\tswitch db.dialect {\n\t\tcase SQLITE:\n\t\t\tdb.mustExec(\"drop table if exists \" + tbl)\n\t\tcase MYSQL, POSTGRESQL:\n\t\t\tdb.mustExec(\"drop table if exists \" + tbl)\n\t\tdefault:\n\t\t\tdb.Fatal(\"unknown dialect\")\n\t\t}\n\t}\n}\n\n// q replaces ? parameters if needed\nfunc (db *TestDB) q(sql string) string {\n\tswitch db.dialect {\n\tcase POSTGRESQL: // replace with $1, $2, ..\n\t\tqrx := regexp.MustCompile(`\\?`)\n\t\tn := 0\n\t\treturn qrx.ReplaceAllStringFunc(sql, func(string) string {\n\t\t\tn++\n\t\t\treturn \"$\" + strconv.Itoa(n)\n\t\t})\n\t}\n\treturn sql\n}\n\nfunc (db *TestDB) blobType(size int) string {\n\tswitch db.dialect {\n\tcase SQLITE:\n\t\treturn fmt.Sprintf(\"blob[%d]\", size)\n\tcase POSTGRESQL:\n\t\treturn \"bytea\"\n\tcase MYSQL:\n\t\treturn fmt.Sprintf(\"VARBINARY(%d)\", size)\n\t}\n\tpanic(\"unknown dialect\")\n}\n\nfunc (db *TestDB) serialPK() string {\n\tswitch db.dialect {\n\tcase SQLITE:\n\t\treturn \"integer primary key autoincrement\"\n\tcase POSTGRESQL:\n\t\treturn \"serial primary key\"\n\tcase MYSQL:\n\t\treturn \"integer primary key auto_increment\"\n\t}\n\tpanic(\"unknown dialect\")\n}\n\nfunc (db *TestDB) now() string {\n\tswitch db.dialect {\n\tcase SQLITE:\n\t\treturn \"datetime('now')\"\n\tcase POSTGRESQL:\n\t\treturn \"now()\"\n\tcase MYSQL:\n\t\treturn \"now()\"\n\t}\n\tpanic(\"unknown dialect\")\n}\n\nfunc makeBench() {\n\tif _, err := db.Exec(\"create table bench (n varchar(32), i integer, d double, s varchar(32), t datetime)\"); err != nil {\n\t\tpanic(err)\n\t}\n\tst, err := db.Prepare(\"insert into bench values (?, ?, ?, ?, ?)\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer st.Close()\n\tfor i := 0; i < 100; i++ {\n\t\tif _, err = st.Exec(nil, i, float64(i), fmt.Sprintf(\"%d\", i), time.Now()); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n}\n\n// testResult is test for result\nfunc testResult(t *testing.T) {\n\tdb.tearDown()\n\tdb.mustExec(\"create temporary table test (id \" + db.serialPK() + \", name varchar(10))\")\n\n\tfor i := 1; i < 3; i++ {\n\t\tr := db.mustExec(db.q(\"insert into test (name) values (?)\"), fmt.Sprintf(\"row %d\", i))\n\t\tn, err := r.RowsAffected()\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif n != 1 {\n\t\t\tt.Errorf(\"got %v, want %v\", n, 1)\n\t\t}\n\t\tn, err = r.LastInsertId()\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif n != int64(i) {\n\t\t\tt.Errorf(\"got %v, want %v\", n, i)\n\t\t}\n\t}\n\tif _, err := db.Exec(\"error!\"); err == nil {\n\t\tt.Fatalf(\"expected error\")\n\t}\n}\n\n// testBlobs is test for blobs\nfunc testBlobs(t *testing.T) {\n\tdb.tearDown()\n\tvar blob = []byte{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15}\n\tdb.mustExec(\"create table foo (id integer primary key, bar \" + db.blobType(16) + \")\")\n\tdb.mustExec(db.q(\"insert into foo (id, bar) values(?,?)\"), 0, blob)\n\n\twant := fmt.Sprintf(\"%x\", blob)\n\n\tb := make([]byte, 16)\n\terr := db.QueryRow(db.q(\"select bar from foo where id = ?\"), 0).Scan(&b)\n\tgot := fmt.Sprintf(\"%x\", b)\n\tif err != nil {\n\t\tt.Errorf(\"[]byte scan: %v\", err)\n\t} else if got != want {\n\t\tt.Errorf(\"for []byte, got %q; want %q\", got, want)\n\t}\n\n\terr = db.QueryRow(db.q(\"select bar from foo where id = ?\"), 0).Scan(&got)\n\twant = string(blob)\n\tif err != nil {\n\t\tt.Errorf(\"string scan: %v\", err)\n\t} else if got != want {\n\t\tt.Errorf(\"for string, got %q; want %q\", got, want)\n\t}\n}\n\nfunc testMultiBlobs(t *testing.T) {\n\tdb.tearDown()\n\tdb.mustExec(\"create table foo (id integer primary key, bar \" + db.blobType(16) + \")\")\n\tvar blob0 = []byte{0, 1, 2, 3, 4, 5, 6, 7}\n\tdb.mustExec(db.q(\"insert into foo (id, bar) values(?,?)\"), 0, blob0)\n\tvar blob1 = []byte{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15}\n\tdb.mustExec(db.q(\"insert into foo (id, bar) values(?,?)\"), 1, blob1)\n\n\tr, err := db.Query(db.q(\"select bar from foo order by id\"))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer r.Close()\n\tif !r.Next() {\n\t\tif r.Err() != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tt.Fatal(\"expected one rows\")\n\t}\n\n\twant0 := fmt.Sprintf(\"%x\", blob0)\n\tb0 := make([]byte, 8)\n\terr = r.Scan(&b0)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tgot0 := fmt.Sprintf(\"%x\", b0)\n\n\tif !r.Next() {\n\t\tif r.Err() != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tt.Fatal(\"expected one rows\")\n\t}\n\n\twant1 := fmt.Sprintf(\"%x\", blob1)\n\tb1 := make([]byte, 16)\n\terr = r.Scan(&b1)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tgot1 := fmt.Sprintf(\"%x\", b1)\n\tif got0 != want0 {\n\t\tt.Errorf(\"for []byte, got %q; want %q\", got0, want0)\n\t}\n\tif got1 != want1 {\n\t\tt.Errorf(\"for []byte, got %q; want %q\", got1, want1)\n\t}\n}\n\n// testBlobs tests that we distinguish between null and zero-length blobs\nfunc testNullZeroLengthBlobs(t *testing.T) {\n\tdb.tearDown()\n\tdb.mustExec(\"create table foo (id integer primary key, bar \" + db.blobType(16) + \")\")\n\tdb.mustExec(db.q(\"insert into foo (id, bar) values(?,?)\"), 0, nil)\n\tdb.mustExec(db.q(\"insert into foo (id, bar) values(?,?)\"), 1, []byte{})\n\n\tr0 := db.QueryRow(db.q(\"select bar from foo where id=0\"))\n\tvar b0 []byte\n\terr := r0.Scan(&b0)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif b0 != nil {\n\t\tt.Errorf(\"for id=0, got %x; want nil\", b0)\n\t}\n\n\tr1 := db.QueryRow(db.q(\"select bar from foo where id=1\"))\n\tvar b1 []byte\n\terr = r1.Scan(&b1)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif b1 == nil {\n\t\tt.Error(\"for id=1, got nil; want zero-length slice\")\n\t} else if len(b1) > 0 {\n\t\tt.Errorf(\"for id=1, got %x; want zero-length slice\", b1)\n\t}\n}\n\n// testManyQueryRow is test for many query row\nfunc testManyQueryRow(t *testing.T) {\n\tif testing.Short() {\n\t\tt.Log(\"skipping in short mode\")\n\t\treturn\n\t}\n\tdb.tearDown()\n\tdb.mustExec(\"create table foo (id integer primary key, name varchar(50))\")\n\tdb.mustExec(db.q(\"insert into foo (id, name) values(?,?)\"), 1, \"bob\")\n\tvar name string\n\tfor i := 0; i < 10000; i++ {\n\t\terr := db.QueryRow(db.q(\"select name from foo where id = ?\"), 1).Scan(&name)\n\t\tif err != nil || name != \"bob\" {\n\t\t\tt.Fatalf(\"on query %d: err=%v, name=%q\", i, err, name)\n\t\t}\n\t}\n}\n\n// testTxQuery is test for transactional query\nfunc testTxQuery(t *testing.T) {\n\tdb.tearDown()\n\ttx, err := db.Begin()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer tx.Rollback()\n\n\t_, err = tx.Exec(\"create table foo (id integer primary key, name varchar(50))\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, err = tx.Exec(db.q(\"insert into foo (id, name) values(?,?)\"), 1, \"bob\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tr, err := tx.Query(db.q(\"select name from foo where id = ?\"), 1)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer r.Close()\n\n\tif !r.Next() {\n\t\tif r.Err() != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tt.Fatal(\"expected one rows\")\n\t}\n\n\tvar name string\n\terr = r.Scan(&name)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// testPreparedStmt is test for prepared statement\nfunc testPreparedStmt(t *testing.T) {\n\tdb.tearDown()\n\tdb.mustExec(\"CREATE TABLE t (count INT)\")\n\tsel, err := db.Prepare(\"SELECT count FROM t ORDER BY count DESC\")\n\tif err != nil {\n\t\tt.Fatalf(\"prepare 1: %v\", err)\n\t}\n\tins, err := db.Prepare(db.q(\"INSERT INTO t (count) VALUES (?)\"))\n\tif err != nil {\n\t\tt.Fatalf(\"prepare 2: %v\", err)\n\t}\n\n\tfor n := 1; n <= 3; n++ {\n\t\tif _, err := ins.Exec(n); err != nil {\n\t\t\tt.Fatalf(\"insert(%d) = %v\", n, err)\n\t\t}\n\t}\n\n\tconst nRuns = 10\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < nRuns; i++ {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\tfor j := 0; j < 10; j++ {\n\t\t\t\tcount := 0\n\t\t\t\tif err := sel.QueryRow().Scan(&count); err != nil && err != sql.ErrNoRows {\n\t\t\t\t\tt.Errorf(\"Query: %v\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif _, err := ins.Exec(rand.Intn(100)); err != nil {\n\t\t\t\t\tt.Errorf(\"Insert: %v\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t}\n\twg.Wait()\n}\n\n// testEmptyQuery is test for validating the API in case of empty query\nfunc testExecEmptyQuery(t *testing.T) {\n\tdb.tearDown()\n\tres, err := db.Exec(\" -- this is just a comment \")\n\tif err != nil {\n\t\tt.Fatalf(\"empty query err: %v\", err)\n\t}\n\n\t_, err = res.LastInsertId()\n\tif err != nil {\n\t\tt.Fatalf(\"LastInsertId returned an error: %v\", err)\n\t}\n\n\t_, err = res.RowsAffected()\n\tif err != nil {\n\t\tt.Fatalf(\"RowsAffected returned an error: %v\", err)\n\t}\n}\n\n// Benchmarks need to use panic() since b.Error errors are lost when\n// running via testing.Benchmark() I would like to run these via go\n// test -bench but calling Benchmark() from a benchmark test\n// currently hangs go.\n\n// benchmarkExec is benchmark for exec\nfunc benchmarkExec(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tif _, err := db.Exec(\"select 1\"); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n}\n\n// benchmarkQuery is benchmark for query\nfunc benchmarkQuery(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tvar n sql.NullString\n\t\tvar i int\n\t\tvar f float64\n\t\tvar s string\n\t\t//\t\tvar t time.Time\n\t\tif err := db.QueryRow(\"select null, 1, 1.1, 'foo'\").Scan(&n, &i, &f, &s); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n}\n\n// benchmarkParams is benchmark for params\nfunc benchmarkParams(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tvar n sql.NullString\n\t\tvar i int\n\t\tvar f float64\n\t\tvar s string\n\t\t//\t\tvar t time.Time\n\t\tif err := db.QueryRow(\"select ?, ?, ?, ?\", nil, 1, 1.1, \"foo\").Scan(&n, &i, &f, &s); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n}\n\n// benchmarkStmt is benchmark for statement\nfunc benchmarkStmt(b *testing.B) {\n\tst, err := db.Prepare(\"select ?, ?, ?, ?\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer st.Close()\n\n\tfor n := 0; n < b.N; n++ {\n\t\tvar n sql.NullString\n\t\tvar i int\n\t\tvar f float64\n\t\tvar s string\n\t\t//\t\tvar t time.Time\n\t\tif err := st.QueryRow(nil, 1, 1.1, \"foo\").Scan(&n, &i, &f, &s); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n}\n\n// benchmarkRows is benchmark for rows\nfunc benchmarkRows(b *testing.B) {\n\tdb.once.Do(makeBench)\n\n\tfor n := 0; n < b.N; n++ {\n\t\tvar n sql.NullString\n\t\tvar i int\n\t\tvar f float64\n\t\tvar s string\n\t\tvar t time.Time\n\t\tr, err := db.Query(\"select * from bench\")\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tfor r.Next() {\n\t\t\tif err = r.Scan(&n, &i, &f, &s, &t); err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t}\n\t\tif err = r.Err(); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n}\n\n// benchmarkStmtRows is benchmark for statement rows\nfunc benchmarkStmtRows(b *testing.B) {\n\tdb.once.Do(makeBench)\n\n\tst, err := db.Prepare(\"select * from bench\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer st.Close()\n\n\tfor n := 0; n < b.N; n++ {\n\t\tvar n sql.NullString\n\t\tvar i int\n\t\tvar f float64\n\t\tvar s string\n\t\tvar t time.Time\n\t\tr, err := st.Query()\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tfor r.Next() {\n\t\t\tif err = r.Scan(&n, &i, &f, &s, &t); err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t}\n\t\tif err = r.Err(); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n}\n\nfunc benchmarkQueryParallel(b *testing.B) {\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tdb, err := sql.Open(\"sqlite3\", \":memory:\")\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tdb.SetMaxOpenConns(runtime.NumCPU())\n\t\tdefer db.Close()\n\t\tvar i int64\n\t\tfor pb.Next() {\n\t\t\tif err := db.QueryRow(\"SELECT 1, 2, 3, 4\").Scan(&i, &i, &i, &i); err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "sqlite3_trace.go",
          "type": "blob",
          "size": 8.173828125,
          "content": "// Copyright (C) 2019 Yasuhiro Matsumoto <mattn.jp@gmail.com>.\n//\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n//go:build sqlite_trace || trace\n// +build sqlite_trace trace\n\npackage sqlite3\n\n/*\n#ifndef USE_LIBSQLITE3\n#include \"sqlite3-binding.h\"\n#else\n#include <sqlite3.h>\n#endif\n#include <stdlib.h>\n\nint traceCallbackTrampoline(unsigned int traceEventCode, void *ctx, void *p, void *x);\n*/\nimport \"C\"\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"sync\"\n\t\"unsafe\"\n)\n\n// Trace... constants identify the possible events causing callback invocation.\n// Values are same as the corresponding SQLite Trace Event Codes.\nconst (\n\tTraceStmt    = uint32(C.SQLITE_TRACE_STMT)\n\tTraceProfile = uint32(C.SQLITE_TRACE_PROFILE)\n\tTraceRow     = uint32(C.SQLITE_TRACE_ROW)\n\tTraceClose   = uint32(C.SQLITE_TRACE_CLOSE)\n)\n\ntype TraceInfo struct {\n\t// Pack together the shorter fields, to keep the struct smaller.\n\t// On a 64-bit machine there would be padding\n\t// between EventCode and ConnHandle; having AutoCommit here is \"free\":\n\tEventCode  uint32\n\tAutoCommit bool\n\tConnHandle uintptr\n\n\t// Usually filled, unless EventCode = TraceClose = SQLITE_TRACE_CLOSE:\n\t// identifier for a prepared statement:\n\tStmtHandle uintptr\n\n\t// Two strings filled when EventCode = TraceStmt = SQLITE_TRACE_STMT:\n\t// (1) either the unexpanded SQL text of the prepared statement, or\n\t//     an SQL comment that indicates the invocation of a trigger;\n\t// (2) expanded SQL, if requested and if (1) is not an SQL comment.\n\tStmtOrTrigger string\n\tExpandedSQL   string // only if requested (TraceConfig.WantExpandedSQL = true)\n\n\t// filled when EventCode = TraceProfile = SQLITE_TRACE_PROFILE:\n\t// estimated number of nanoseconds that the prepared statement took to run:\n\tRunTimeNanosec int64\n\n\tDBError Error\n}\n\n// TraceUserCallback gives the signature for a trace function\n// provided by the user (Go application programmer).\n// SQLite 3.14 documentation (as of September 2, 2016)\n// for SQL Trace Hook = sqlite3_trace_v2():\n// The integer return value from the callback is currently ignored,\n// though this may change in future releases. Callback implementations\n// should return zero to ensure future compatibility.\ntype TraceUserCallback func(TraceInfo) int\n\ntype TraceConfig struct {\n\tCallback        TraceUserCallback\n\tEventMask       uint32\n\tWantExpandedSQL bool\n}\n\nfunc fillDBError(dbErr *Error, db *C.sqlite3) {\n\t// See SQLiteConn.lastError(), in file 'sqlite3.go' at the time of writing (Sept 5, 2016)\n\tdbErr.Code = ErrNo(C.sqlite3_errcode(db))\n\tdbErr.ExtendedCode = ErrNoExtended(C.sqlite3_extended_errcode(db))\n\tdbErr.err = C.GoString(C.sqlite3_errmsg(db))\n}\n\nfunc fillExpandedSQL(info *TraceInfo, db *C.sqlite3, pStmt unsafe.Pointer) {\n\tif pStmt == nil {\n\t\tpanic(\"No SQLite statement pointer in P arg of trace_v2 callback\")\n\t}\n\n\texpSQLiteCStr := C.sqlite3_expanded_sql((*C.sqlite3_stmt)(pStmt))\n\tdefer C.sqlite3_free(unsafe.Pointer(expSQLiteCStr))\n\tif expSQLiteCStr == nil {\n\t\tfillDBError(&info.DBError, db)\n\t\treturn\n\t}\n\tinfo.ExpandedSQL = C.GoString(expSQLiteCStr)\n}\n\n//export traceCallbackTrampoline\nfunc traceCallbackTrampoline(\n\ttraceEventCode C.uint,\n\t// Parameter named 'C' in SQLite docs = Context given at registration:\n\tctx unsafe.Pointer,\n\t// Parameter named 'P' in SQLite docs (Primary event data?):\n\tp unsafe.Pointer,\n\t// Parameter named 'X' in SQLite docs (eXtra event data?):\n\txValue unsafe.Pointer) C.int {\n\n\teventCode := uint32(traceEventCode)\n\n\tif ctx == nil {\n\t\tpanic(fmt.Sprintf(\"No context (ev 0x%x)\", traceEventCode))\n\t}\n\n\tcontextDB := (*C.sqlite3)(ctx)\n\tconnHandle := uintptr(ctx)\n\n\tvar traceConf TraceConfig\n\tvar found bool\n\tif eventCode == TraceClose {\n\t\t// clean up traceMap: 'pop' means get and delete\n\t\ttraceConf, found = popTraceMapping(connHandle)\n\t} else {\n\t\ttraceConf, found = lookupTraceMapping(connHandle)\n\t}\n\n\tif !found {\n\t\tpanic(fmt.Sprintf(\"Mapping not found for handle 0x%x (ev 0x%x)\",\n\t\t\tconnHandle, eventCode))\n\t}\n\n\tvar info TraceInfo\n\n\tinfo.EventCode = eventCode\n\tinfo.AutoCommit = (int(C.sqlite3_get_autocommit(contextDB)) != 0)\n\tinfo.ConnHandle = connHandle\n\n\tswitch eventCode {\n\tcase TraceStmt:\n\t\tinfo.StmtHandle = uintptr(p)\n\n\t\tvar xStr string\n\t\tif xValue != nil {\n\t\t\txStr = C.GoString((*C.char)(xValue))\n\t\t}\n\t\tinfo.StmtOrTrigger = xStr\n\t\tif !strings.HasPrefix(xStr, \"--\") {\n\t\t\t// Not SQL comment, therefore the current event\n\t\t\t// is not related to a trigger.\n\t\t\t// The user might want to receive the expanded SQL;\n\t\t\t// let's check:\n\t\t\tif traceConf.WantExpandedSQL {\n\t\t\t\tfillExpandedSQL(&info, contextDB, p)\n\t\t\t}\n\t\t}\n\n\tcase TraceProfile:\n\t\tinfo.StmtHandle = uintptr(p)\n\n\t\tif xValue == nil {\n\t\t\tpanic(\"NULL pointer in X arg of trace_v2 callback for SQLITE_TRACE_PROFILE event\")\n\t\t}\n\n\t\tinfo.RunTimeNanosec = *(*int64)(xValue)\n\n\t\t// sample the error //TODO: is it safe? is it useful?\n\t\tfillDBError(&info.DBError, contextDB)\n\n\tcase TraceRow:\n\t\tinfo.StmtHandle = uintptr(p)\n\n\tcase TraceClose:\n\t\thandle := uintptr(p)\n\t\tif handle != info.ConnHandle {\n\t\t\tpanic(fmt.Sprintf(\"Different conn handle 0x%x (expected 0x%x) in SQLITE_TRACE_CLOSE event.\",\n\t\t\t\thandle, info.ConnHandle))\n\t\t}\n\n\tdefault:\n\t\t// Pass unsupported events to the user callback (if configured);\n\t\t// let the user callback decide whether to panic or ignore them.\n\t}\n\n\t// Do not execute user callback when the event was not requested by user!\n\t// Remember that the Close event is always selected when\n\t// registering this callback trampoline with SQLite --- for cleanup.\n\t// In the future there may be more events forced to \"selected\" in SQLite\n\t// for the driver's needs.\n\tif traceConf.EventMask&eventCode == 0 {\n\t\treturn 0\n\t}\n\n\tr := 0\n\tif traceConf.Callback != nil {\n\t\tr = traceConf.Callback(info)\n\t}\n\treturn C.int(r)\n}\n\ntype traceMapEntry struct {\n\tconfig TraceConfig\n}\n\nvar traceMapLock sync.Mutex\nvar traceMap = make(map[uintptr]traceMapEntry)\n\nfunc addTraceMapping(connHandle uintptr, traceConf TraceConfig) {\n\ttraceMapLock.Lock()\n\tdefer traceMapLock.Unlock()\n\n\toldEntryCopy, found := traceMap[connHandle]\n\tif found {\n\t\tpanic(fmt.Sprintf(\"Adding trace config %v: handle 0x%x already registered (%v).\",\n\t\t\ttraceConf, connHandle, oldEntryCopy.config))\n\t}\n\ttraceMap[connHandle] = traceMapEntry{config: traceConf}\n}\n\nfunc lookupTraceMapping(connHandle uintptr) (TraceConfig, bool) {\n\ttraceMapLock.Lock()\n\tdefer traceMapLock.Unlock()\n\n\tentryCopy, found := traceMap[connHandle]\n\treturn entryCopy.config, found\n}\n\n// 'pop' = get and delete from map before returning the value to the caller\nfunc popTraceMapping(connHandle uintptr) (TraceConfig, bool) {\n\ttraceMapLock.Lock()\n\tdefer traceMapLock.Unlock()\n\n\tentryCopy, found := traceMap[connHandle]\n\tif found {\n\t\tdelete(traceMap, connHandle)\n\t}\n\treturn entryCopy.config, found\n}\n\n// SetTrace installs or removes the trace callback for the given database connection.\n// It's not named 'RegisterTrace' because only one callback can be kept and called.\n// Calling SetTrace a second time on same database connection\n// overrides (cancels) any prior callback and all its settings:\n// event mask, etc.\nfunc (c *SQLiteConn) SetTrace(requested *TraceConfig) error {\n\tconnHandle := uintptr(unsafe.Pointer(c.db))\n\n\t_, _ = popTraceMapping(connHandle)\n\n\tif requested == nil {\n\t\t// The traceMap entry was deleted already by popTraceMapping():\n\t\t// can disable all events now, no need to watch for TraceClose.\n\t\terr := c.setSQLiteTrace(0)\n\t\treturn err\n\t}\n\n\treqCopy := *requested\n\n\t// Disable potentially expensive operations\n\t// if their result will not be used. We are doing this\n\t// just in case the caller provided nonsensical input.\n\tif reqCopy.EventMask&TraceStmt == 0 {\n\t\treqCopy.WantExpandedSQL = false\n\t}\n\n\taddTraceMapping(connHandle, reqCopy)\n\n\t// The callback trampoline function does cleanup on Close event,\n\t// regardless of the presence or absence of the user callback.\n\t// Therefore it needs the Close event to be selected:\n\tactualEventMask := uint(reqCopy.EventMask | TraceClose)\n\terr := c.setSQLiteTrace(actualEventMask)\n\treturn err\n}\n\nfunc (c *SQLiteConn) setSQLiteTrace(sqliteEventMask uint) error {\n\trv := C.sqlite3_trace_v2(c.db,\n\t\tC.uint(sqliteEventMask),\n\t\t(*[0]byte)(unsafe.Pointer(C.traceCallbackTrampoline)),\n\t\tunsafe.Pointer(c.db)) // Fourth arg is same as first: we are\n\t// passing the database connection handle as callback context.\n\n\tif rv != C.SQLITE_OK {\n\t\treturn c.lastError()\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "sqlite3_type.go",
          "type": "blob",
          "size": 2.3896484375,
          "content": "// Copyright (C) 2019 Yasuhiro Matsumoto <mattn.jp@gmail.com>.\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\npackage sqlite3\n\n/*\n#ifndef USE_LIBSQLITE3\n#include \"sqlite3-binding.h\"\n#else\n#include <sqlite3.h>\n#endif\n*/\nimport \"C\"\nimport (\n\t\"database/sql\"\n\t\"reflect\"\n\t\"strings\"\n)\n\n// ColumnTypeDatabaseTypeName implement RowsColumnTypeDatabaseTypeName.\nfunc (rc *SQLiteRows) ColumnTypeDatabaseTypeName(i int) string {\n\treturn C.GoString(C.sqlite3_column_decltype(rc.s.s, C.int(i)))\n}\n\n/*\nfunc (rc *SQLiteRows) ColumnTypeLength(index int) (length int64, ok bool) {\n\treturn 0, false\n}\n\nfunc (rc *SQLiteRows) ColumnTypePrecisionScale(index int) (precision, scale int64, ok bool) {\n\treturn 0, 0, false\n}\n*/\n\n// ColumnTypeNullable implement RowsColumnTypeNullable.\nfunc (rc *SQLiteRows) ColumnTypeNullable(i int) (nullable, ok bool) {\n\treturn true, true\n}\n\n// ColumnTypeScanType implement RowsColumnTypeScanType.\nfunc (rc *SQLiteRows) ColumnTypeScanType(i int) reflect.Type {\n\t//ct := C.sqlite3_column_type(rc.s.s, C.int(i))  // Always returns 5\n\treturn scanType(C.GoString(C.sqlite3_column_decltype(rc.s.s, C.int(i))))\n}\n\nconst (\n\tSQLITE_INTEGER = iota\n\tSQLITE_TEXT\n\tSQLITE_BLOB\n\tSQLITE_REAL\n\tSQLITE_NUMERIC\n\tSQLITE_TIME\n\tSQLITE_BOOL\n\tSQLITE_NULL\n)\n\nfunc scanType(cdt string) reflect.Type {\n\tt := strings.ToUpper(cdt)\n\ti := databaseTypeConvSqlite(t)\n\tswitch i {\n\tcase SQLITE_INTEGER:\n\t\treturn reflect.TypeOf(sql.NullInt64{})\n\tcase SQLITE_TEXT:\n\t\treturn reflect.TypeOf(sql.NullString{})\n\tcase SQLITE_BLOB:\n\t\treturn reflect.TypeOf(sql.RawBytes{})\n\tcase SQLITE_REAL:\n\t\treturn reflect.TypeOf(sql.NullFloat64{})\n\tcase SQLITE_NUMERIC:\n\t\treturn reflect.TypeOf(sql.NullFloat64{})\n\tcase SQLITE_BOOL:\n\t\treturn reflect.TypeOf(sql.NullBool{})\n\tcase SQLITE_TIME:\n\t\treturn reflect.TypeOf(sql.NullTime{})\n\t}\n\treturn reflect.TypeOf(new(any))\n}\n\nfunc databaseTypeConvSqlite(t string) int {\n\tif strings.Contains(t, \"INT\") {\n\t\treturn SQLITE_INTEGER\n\t}\n\tif t == \"CLOB\" || t == \"TEXT\" ||\n\t\tstrings.Contains(t, \"CHAR\") {\n\t\treturn SQLITE_TEXT\n\t}\n\tif t == \"BLOB\" {\n\t\treturn SQLITE_BLOB\n\t}\n\tif t == \"REAL\" || t == \"FLOAT\" ||\n\t\tstrings.Contains(t, \"DOUBLE\") {\n\t\treturn SQLITE_REAL\n\t}\n\tif t == \"DATE\" || t == \"DATETIME\" ||\n\t\tt == \"TIMESTAMP\" {\n\t\treturn SQLITE_TIME\n\t}\n\tif t == \"NUMERIC\" ||\n\t\tstrings.Contains(t, \"DECIMAL\") {\n\t\treturn SQLITE_NUMERIC\n\t}\n\tif t == \"BOOLEAN\" {\n\t\treturn SQLITE_BOOL\n\t}\n\n\treturn SQLITE_NULL\n}\n"
        },
        {
          "name": "sqlite3_usleep_windows.go",
          "type": "blob",
          "size": 1.2236328125,
          "content": "// Copyright (C) 2018 G.J.R. Timmer <gjr.timmer@gmail.com>.\n//\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n//go:build cgo\n// +build cgo\n\npackage sqlite3\n\n// usleep is a function available on *nix based systems.\n// This function is not present in Windows.\n// Windows has a sleep function but this works with seconds\n// and not with microseconds as usleep.\n//\n// This code should improve performance on windows because\n// without the presence of usleep SQLite waits 1 second.\n//\n// Source:  https://github.com/php/php-src/blob/PHP-5.0/win32/time.c\n// License: https://github.com/php/php-src/blob/PHP-5.0/LICENSE\n// Details: https://stackoverflow.com/questions/5801813/c-usleep-is-obsolete-workarounds-for-windows-mingw?utm_medium=organic&utm_source=google_rich_qa&utm_campaign=google_rich_qa\n\n/*\n#include <windows.h>\n\nvoid usleep(__int64 usec)\n{\n    HANDLE timer;\n    LARGE_INTEGER ft;\n\n    // Convert to 100 nanosecond interval, negative value indicates relative time\n    ft.QuadPart = -(10*usec);\n\n    timer = CreateWaitableTimer(NULL, TRUE, NULL);\n    SetWaitableTimer(timer, &ft, 0, NULL, NULL, 0);\n    WaitForSingleObject(timer, INFINITE);\n    CloseHandle(timer);\n}\n*/\nimport \"C\"\n\n// EOF\n"
        },
        {
          "name": "sqlite3_windows.go",
          "type": "blob",
          "size": 0.39453125,
          "content": "// Copyright (C) 2019 Yasuhiro Matsumoto <mattn.jp@gmail.com>.\n//\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n//go:build windows\n// +build windows\n\npackage sqlite3\n\n/*\n#cgo CFLAGS: -I.\n#cgo CFLAGS: -fno-stack-check\n#cgo CFLAGS: -fno-stack-protector\n#cgo CFLAGS: -mno-stack-arg-probe\n#cgo windows,386 CFLAGS: -D_USE_32BIT_TIME_T\n*/\nimport \"C\"\n"
        },
        {
          "name": "sqlite3ext.h",
          "type": "blob",
          "size": 37.4697265625,
          "content": "#ifndef USE_LIBSQLITE3\n/*\n** 2006 June 7\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This header file defines the SQLite interface for use by\n** shared libraries that want to be imported as extensions into\n** an SQLite instance.  Shared libraries that intend to be loaded\n** as extensions by SQLite should #include this file instead of \n** sqlite3.h.\n*/\n#ifndef SQLITE3EXT_H\n#define SQLITE3EXT_H\n#include \"sqlite3-binding.h\"\n#ifdef __clang__\n#define assert(condition) ((void)0)\n#endif\n\n\n/*\n** The following structure holds pointers to all of the SQLite API\n** routines.\n**\n** WARNING:  In order to maintain backwards compatibility, add new\n** interfaces to the end of this structure only.  If you insert new\n** interfaces in the middle of this structure, then older different\n** versions of SQLite will not be able to load each other's shared\n** libraries!\n*/\nstruct sqlite3_api_routines {\n  void * (*aggregate_context)(sqlite3_context*,int nBytes);\n  int  (*aggregate_count)(sqlite3_context*);\n  int  (*bind_blob)(sqlite3_stmt*,int,const void*,int n,void(*)(void*));\n  int  (*bind_double)(sqlite3_stmt*,int,double);\n  int  (*bind_int)(sqlite3_stmt*,int,int);\n  int  (*bind_int64)(sqlite3_stmt*,int,sqlite_int64);\n  int  (*bind_null)(sqlite3_stmt*,int);\n  int  (*bind_parameter_count)(sqlite3_stmt*);\n  int  (*bind_parameter_index)(sqlite3_stmt*,const char*zName);\n  const char * (*bind_parameter_name)(sqlite3_stmt*,int);\n  int  (*bind_text)(sqlite3_stmt*,int,const char*,int n,void(*)(void*));\n  int  (*bind_text16)(sqlite3_stmt*,int,const void*,int,void(*)(void*));\n  int  (*bind_value)(sqlite3_stmt*,int,const sqlite3_value*);\n  int  (*busy_handler)(sqlite3*,int(*)(void*,int),void*);\n  int  (*busy_timeout)(sqlite3*,int ms);\n  int  (*changes)(sqlite3*);\n  int  (*close)(sqlite3*);\n  int  (*collation_needed)(sqlite3*,void*,void(*)(void*,sqlite3*,\n                           int eTextRep,const char*));\n  int  (*collation_needed16)(sqlite3*,void*,void(*)(void*,sqlite3*,\n                             int eTextRep,const void*));\n  const void * (*column_blob)(sqlite3_stmt*,int iCol);\n  int  (*column_bytes)(sqlite3_stmt*,int iCol);\n  int  (*column_bytes16)(sqlite3_stmt*,int iCol);\n  int  (*column_count)(sqlite3_stmt*pStmt);\n  const char * (*column_database_name)(sqlite3_stmt*,int);\n  const void * (*column_database_name16)(sqlite3_stmt*,int);\n  const char * (*column_decltype)(sqlite3_stmt*,int i);\n  const void * (*column_decltype16)(sqlite3_stmt*,int);\n  double  (*column_double)(sqlite3_stmt*,int iCol);\n  int  (*column_int)(sqlite3_stmt*,int iCol);\n  sqlite_int64  (*column_int64)(sqlite3_stmt*,int iCol);\n  const char * (*column_name)(sqlite3_stmt*,int);\n  const void * (*column_name16)(sqlite3_stmt*,int);\n  const char * (*column_origin_name)(sqlite3_stmt*,int);\n  const void * (*column_origin_name16)(sqlite3_stmt*,int);\n  const char * (*column_table_name)(sqlite3_stmt*,int);\n  const void * (*column_table_name16)(sqlite3_stmt*,int);\n  const unsigned char * (*column_text)(sqlite3_stmt*,int iCol);\n  const void * (*column_text16)(sqlite3_stmt*,int iCol);\n  int  (*column_type)(sqlite3_stmt*,int iCol);\n  sqlite3_value* (*column_value)(sqlite3_stmt*,int iCol);\n  void * (*commit_hook)(sqlite3*,int(*)(void*),void*);\n  int  (*complete)(const char*sql);\n  int  (*complete16)(const void*sql);\n  int  (*create_collation)(sqlite3*,const char*,int,void*,\n                           int(*)(void*,int,const void*,int,const void*));\n  int  (*create_collation16)(sqlite3*,const void*,int,void*,\n                             int(*)(void*,int,const void*,int,const void*));\n  int  (*create_function)(sqlite3*,const char*,int,int,void*,\n                          void (*xFunc)(sqlite3_context*,int,sqlite3_value**),\n                          void (*xStep)(sqlite3_context*,int,sqlite3_value**),\n                          void (*xFinal)(sqlite3_context*));\n  int  (*create_function16)(sqlite3*,const void*,int,int,void*,\n                            void (*xFunc)(sqlite3_context*,int,sqlite3_value**),\n                            void (*xStep)(sqlite3_context*,int,sqlite3_value**),\n                            void (*xFinal)(sqlite3_context*));\n  int (*create_module)(sqlite3*,const char*,const sqlite3_module*,void*);\n  int  (*data_count)(sqlite3_stmt*pStmt);\n  sqlite3 * (*db_handle)(sqlite3_stmt*);\n  int (*declare_vtab)(sqlite3*,const char*);\n  int  (*enable_shared_cache)(int);\n  int  (*errcode)(sqlite3*db);\n  const char * (*errmsg)(sqlite3*);\n  const void * (*errmsg16)(sqlite3*);\n  int  (*exec)(sqlite3*,const char*,sqlite3_callback,void*,char**);\n  int  (*expired)(sqlite3_stmt*);\n  int  (*finalize)(sqlite3_stmt*pStmt);\n  void  (*free)(void*);\n  void  (*free_table)(char**result);\n  int  (*get_autocommit)(sqlite3*);\n  void * (*get_auxdata)(sqlite3_context*,int);\n  int  (*get_table)(sqlite3*,const char*,char***,int*,int*,char**);\n  int  (*global_recover)(void);\n  void  (*interruptx)(sqlite3*);\n  sqlite_int64  (*last_insert_rowid)(sqlite3*);\n  const char * (*libversion)(void);\n  int  (*libversion_number)(void);\n  void *(*malloc)(int);\n  char * (*mprintf)(const char*,...);\n  int  (*open)(const char*,sqlite3**);\n  int  (*open16)(const void*,sqlite3**);\n  int  (*prepare)(sqlite3*,const char*,int,sqlite3_stmt**,const char**);\n  int  (*prepare16)(sqlite3*,const void*,int,sqlite3_stmt**,const void**);\n  void * (*profile)(sqlite3*,void(*)(void*,const char*,sqlite_uint64),void*);\n  void  (*progress_handler)(sqlite3*,int,int(*)(void*),void*);\n  void *(*realloc)(void*,int);\n  int  (*reset)(sqlite3_stmt*pStmt);\n  void  (*result_blob)(sqlite3_context*,const void*,int,void(*)(void*));\n  void  (*result_double)(sqlite3_context*,double);\n  void  (*result_error)(sqlite3_context*,const char*,int);\n  void  (*result_error16)(sqlite3_context*,const void*,int);\n  void  (*result_int)(sqlite3_context*,int);\n  void  (*result_int64)(sqlite3_context*,sqlite_int64);\n  void  (*result_null)(sqlite3_context*);\n  void  (*result_text)(sqlite3_context*,const char*,int,void(*)(void*));\n  void  (*result_text16)(sqlite3_context*,const void*,int,void(*)(void*));\n  void  (*result_text16be)(sqlite3_context*,const void*,int,void(*)(void*));\n  void  (*result_text16le)(sqlite3_context*,const void*,int,void(*)(void*));\n  void  (*result_value)(sqlite3_context*,sqlite3_value*);\n  void * (*rollback_hook)(sqlite3*,void(*)(void*),void*);\n  int  (*set_authorizer)(sqlite3*,int(*)(void*,int,const char*,const char*,\n                         const char*,const char*),void*);\n  void  (*set_auxdata)(sqlite3_context*,int,void*,void (*)(void*));\n  char * (*xsnprintf)(int,char*,const char*,...);\n  int  (*step)(sqlite3_stmt*);\n  int  (*table_column_metadata)(sqlite3*,const char*,const char*,const char*,\n                                char const**,char const**,int*,int*,int*);\n  void  (*thread_cleanup)(void);\n  int  (*total_changes)(sqlite3*);\n  void * (*trace)(sqlite3*,void(*xTrace)(void*,const char*),void*);\n  int  (*transfer_bindings)(sqlite3_stmt*,sqlite3_stmt*);\n  void * (*update_hook)(sqlite3*,void(*)(void*,int ,char const*,char const*,\n                                         sqlite_int64),void*);\n  void * (*user_data)(sqlite3_context*);\n  const void * (*value_blob)(sqlite3_value*);\n  int  (*value_bytes)(sqlite3_value*);\n  int  (*value_bytes16)(sqlite3_value*);\n  double  (*value_double)(sqlite3_value*);\n  int  (*value_int)(sqlite3_value*);\n  sqlite_int64  (*value_int64)(sqlite3_value*);\n  int  (*value_numeric_type)(sqlite3_value*);\n  const unsigned char * (*value_text)(sqlite3_value*);\n  const void * (*value_text16)(sqlite3_value*);\n  const void * (*value_text16be)(sqlite3_value*);\n  const void * (*value_text16le)(sqlite3_value*);\n  int  (*value_type)(sqlite3_value*);\n  char *(*vmprintf)(const char*,va_list);\n  /* Added ??? */\n  int (*overload_function)(sqlite3*, const char *zFuncName, int nArg);\n  /* Added by 3.3.13 */\n  int (*prepare_v2)(sqlite3*,const char*,int,sqlite3_stmt**,const char**);\n  int (*prepare16_v2)(sqlite3*,const void*,int,sqlite3_stmt**,const void**);\n  int (*clear_bindings)(sqlite3_stmt*);\n  /* Added by 3.4.1 */\n  int (*create_module_v2)(sqlite3*,const char*,const sqlite3_module*,void*,\n                          void (*xDestroy)(void *));\n  /* Added by 3.5.0 */\n  int (*bind_zeroblob)(sqlite3_stmt*,int,int);\n  int (*blob_bytes)(sqlite3_blob*);\n  int (*blob_close)(sqlite3_blob*);\n  int (*blob_open)(sqlite3*,const char*,const char*,const char*,sqlite3_int64,\n                   int,sqlite3_blob**);\n  int (*blob_read)(sqlite3_blob*,void*,int,int);\n  int (*blob_write)(sqlite3_blob*,const void*,int,int);\n  int (*create_collation_v2)(sqlite3*,const char*,int,void*,\n                             int(*)(void*,int,const void*,int,const void*),\n                             void(*)(void*));\n  int (*file_control)(sqlite3*,const char*,int,void*);\n  sqlite3_int64 (*memory_highwater)(int);\n  sqlite3_int64 (*memory_used)(void);\n  sqlite3_mutex *(*mutex_alloc)(int);\n  void (*mutex_enter)(sqlite3_mutex*);\n  void (*mutex_free)(sqlite3_mutex*);\n  void (*mutex_leave)(sqlite3_mutex*);\n  int (*mutex_try)(sqlite3_mutex*);\n  int (*open_v2)(const char*,sqlite3**,int,const char*);\n  int (*release_memory)(int);\n  void (*result_error_nomem)(sqlite3_context*);\n  void (*result_error_toobig)(sqlite3_context*);\n  int (*sleep)(int);\n  void (*soft_heap_limit)(int);\n  sqlite3_vfs *(*vfs_find)(const char*);\n  int (*vfs_register)(sqlite3_vfs*,int);\n  int (*vfs_unregister)(sqlite3_vfs*);\n  int (*xthreadsafe)(void);\n  void (*result_zeroblob)(sqlite3_context*,int);\n  void (*result_error_code)(sqlite3_context*,int);\n  int (*test_control)(int, ...);\n  void (*randomness)(int,void*);\n  sqlite3 *(*context_db_handle)(sqlite3_context*);\n  int (*extended_result_codes)(sqlite3*,int);\n  int (*limit)(sqlite3*,int,int);\n  sqlite3_stmt *(*next_stmt)(sqlite3*,sqlite3_stmt*);\n  const char *(*sql)(sqlite3_stmt*);\n  int (*status)(int,int*,int*,int);\n  int (*backup_finish)(sqlite3_backup*);\n  sqlite3_backup *(*backup_init)(sqlite3*,const char*,sqlite3*,const char*);\n  int (*backup_pagecount)(sqlite3_backup*);\n  int (*backup_remaining)(sqlite3_backup*);\n  int (*backup_step)(sqlite3_backup*,int);\n  const char *(*compileoption_get)(int);\n  int (*compileoption_used)(const char*);\n  int (*create_function_v2)(sqlite3*,const char*,int,int,void*,\n                            void (*xFunc)(sqlite3_context*,int,sqlite3_value**),\n                            void (*xStep)(sqlite3_context*,int,sqlite3_value**),\n                            void (*xFinal)(sqlite3_context*),\n                            void(*xDestroy)(void*));\n  int (*db_config)(sqlite3*,int,...);\n  sqlite3_mutex *(*db_mutex)(sqlite3*);\n  int (*db_status)(sqlite3*,int,int*,int*,int);\n  int (*extended_errcode)(sqlite3*);\n  void (*log)(int,const char*,...);\n  sqlite3_int64 (*soft_heap_limit64)(sqlite3_int64);\n  const char *(*sourceid)(void);\n  int (*stmt_status)(sqlite3_stmt*,int,int);\n  int (*strnicmp)(const char*,const char*,int);\n  int (*unlock_notify)(sqlite3*,void(*)(void**,int),void*);\n  int (*wal_autocheckpoint)(sqlite3*,int);\n  int (*wal_checkpoint)(sqlite3*,const char*);\n  void *(*wal_hook)(sqlite3*,int(*)(void*,sqlite3*,const char*,int),void*);\n  int (*blob_reopen)(sqlite3_blob*,sqlite3_int64);\n  int (*vtab_config)(sqlite3*,int op,...);\n  int (*vtab_on_conflict)(sqlite3*);\n  /* Version 3.7.16 and later */\n  int (*close_v2)(sqlite3*);\n  const char *(*db_filename)(sqlite3*,const char*);\n  int (*db_readonly)(sqlite3*,const char*);\n  int (*db_release_memory)(sqlite3*);\n  const char *(*errstr)(int);\n  int (*stmt_busy)(sqlite3_stmt*);\n  int (*stmt_readonly)(sqlite3_stmt*);\n  int (*stricmp)(const char*,const char*);\n  int (*uri_boolean)(const char*,const char*,int);\n  sqlite3_int64 (*uri_int64)(const char*,const char*,sqlite3_int64);\n  const char *(*uri_parameter)(const char*,const char*);\n  char *(*xvsnprintf)(int,char*,const char*,va_list);\n  int (*wal_checkpoint_v2)(sqlite3*,const char*,int,int*,int*);\n  /* Version 3.8.7 and later */\n  int (*auto_extension)(void(*)(void));\n  int (*bind_blob64)(sqlite3_stmt*,int,const void*,sqlite3_uint64,\n                     void(*)(void*));\n  int (*bind_text64)(sqlite3_stmt*,int,const char*,sqlite3_uint64,\n                      void(*)(void*),unsigned char);\n  int (*cancel_auto_extension)(void(*)(void));\n  int (*load_extension)(sqlite3*,const char*,const char*,char**);\n  void *(*malloc64)(sqlite3_uint64);\n  sqlite3_uint64 (*msize)(void*);\n  void *(*realloc64)(void*,sqlite3_uint64);\n  void (*reset_auto_extension)(void);\n  void (*result_blob64)(sqlite3_context*,const void*,sqlite3_uint64,\n                        void(*)(void*));\n  void (*result_text64)(sqlite3_context*,const char*,sqlite3_uint64,\n                         void(*)(void*), unsigned char);\n  int (*strglob)(const char*,const char*);\n  /* Version 3.8.11 and later */\n  sqlite3_value *(*value_dup)(const sqlite3_value*);\n  void (*value_free)(sqlite3_value*);\n  int (*result_zeroblob64)(sqlite3_context*,sqlite3_uint64);\n  int (*bind_zeroblob64)(sqlite3_stmt*, int, sqlite3_uint64);\n  /* Version 3.9.0 and later */\n  unsigned int (*value_subtype)(sqlite3_value*);\n  void (*result_subtype)(sqlite3_context*,unsigned int);\n  /* Version 3.10.0 and later */\n  int (*status64)(int,sqlite3_int64*,sqlite3_int64*,int);\n  int (*strlike)(const char*,const char*,unsigned int);\n  int (*db_cacheflush)(sqlite3*);\n  /* Version 3.12.0 and later */\n  int (*system_errno)(sqlite3*);\n  /* Version 3.14.0 and later */\n  int (*trace_v2)(sqlite3*,unsigned,int(*)(unsigned,void*,void*,void*),void*);\n  char *(*expanded_sql)(sqlite3_stmt*);\n  /* Version 3.18.0 and later */\n  void (*set_last_insert_rowid)(sqlite3*,sqlite3_int64);\n  /* Version 3.20.0 and later */\n  int (*prepare_v3)(sqlite3*,const char*,int,unsigned int,\n                    sqlite3_stmt**,const char**);\n  int (*prepare16_v3)(sqlite3*,const void*,int,unsigned int,\n                      sqlite3_stmt**,const void**);\n  int (*bind_pointer)(sqlite3_stmt*,int,void*,const char*,void(*)(void*));\n  void (*result_pointer)(sqlite3_context*,void*,const char*,void(*)(void*));\n  void *(*value_pointer)(sqlite3_value*,const char*);\n  int (*vtab_nochange)(sqlite3_context*);\n  int (*value_nochange)(sqlite3_value*);\n  const char *(*vtab_collation)(sqlite3_index_info*,int);\n  /* Version 3.24.0 and later */\n  int (*keyword_count)(void);\n  int (*keyword_name)(int,const char**,int*);\n  int (*keyword_check)(const char*,int);\n  sqlite3_str *(*str_new)(sqlite3*);\n  char *(*str_finish)(sqlite3_str*);\n  void (*str_appendf)(sqlite3_str*, const char *zFormat, ...);\n  void (*str_vappendf)(sqlite3_str*, const char *zFormat, va_list);\n  void (*str_append)(sqlite3_str*, const char *zIn, int N);\n  void (*str_appendall)(sqlite3_str*, const char *zIn);\n  void (*str_appendchar)(sqlite3_str*, int N, char C);\n  void (*str_reset)(sqlite3_str*);\n  int (*str_errcode)(sqlite3_str*);\n  int (*str_length)(sqlite3_str*);\n  char *(*str_value)(sqlite3_str*);\n  /* Version 3.25.0 and later */\n  int (*create_window_function)(sqlite3*,const char*,int,int,void*,\n                            void (*xStep)(sqlite3_context*,int,sqlite3_value**),\n                            void (*xFinal)(sqlite3_context*),\n                            void (*xValue)(sqlite3_context*),\n                            void (*xInv)(sqlite3_context*,int,sqlite3_value**),\n                            void(*xDestroy)(void*));\n  /* Version 3.26.0 and later */\n  const char *(*normalized_sql)(sqlite3_stmt*);\n  /* Version 3.28.0 and later */\n  int (*stmt_isexplain)(sqlite3_stmt*);\n  int (*value_frombind)(sqlite3_value*);\n  /* Version 3.30.0 and later */\n  int (*drop_modules)(sqlite3*,const char**);\n  /* Version 3.31.0 and later */\n  sqlite3_int64 (*hard_heap_limit64)(sqlite3_int64);\n  const char *(*uri_key)(const char*,int);\n  const char *(*filename_database)(const char*);\n  const char *(*filename_journal)(const char*);\n  const char *(*filename_wal)(const char*);\n  /* Version 3.32.0 and later */\n  const char *(*create_filename)(const char*,const char*,const char*,\n                           int,const char**);\n  void (*free_filename)(const char*);\n  sqlite3_file *(*database_file_object)(const char*);\n  /* Version 3.34.0 and later */\n  int (*txn_state)(sqlite3*,const char*);\n  /* Version 3.36.1 and later */\n  sqlite3_int64 (*changes64)(sqlite3*);\n  sqlite3_int64 (*total_changes64)(sqlite3*);\n  /* Version 3.37.0 and later */\n  int (*autovacuum_pages)(sqlite3*,\n     unsigned int(*)(void*,const char*,unsigned int,unsigned int,unsigned int),\n     void*, void(*)(void*));\n  /* Version 3.38.0 and later */\n  int (*error_offset)(sqlite3*);\n  int (*vtab_rhs_value)(sqlite3_index_info*,int,sqlite3_value**);\n  int (*vtab_distinct)(sqlite3_index_info*);\n  int (*vtab_in)(sqlite3_index_info*,int,int);\n  int (*vtab_in_first)(sqlite3_value*,sqlite3_value**);\n  int (*vtab_in_next)(sqlite3_value*,sqlite3_value**);\n  /* Version 3.39.0 and later */\n  int (*deserialize)(sqlite3*,const char*,unsigned char*,\n                     sqlite3_int64,sqlite3_int64,unsigned);\n  unsigned char *(*serialize)(sqlite3*,const char *,sqlite3_int64*,\n                              unsigned int);\n  const char *(*db_name)(sqlite3*,int);\n  /* Version 3.40.0 and later */\n  int (*value_encoding)(sqlite3_value*);\n  /* Version 3.41.0 and later */\n  int (*is_interrupted)(sqlite3*);\n  /* Version 3.43.0 and later */\n  int (*stmt_explain)(sqlite3_stmt*,int);\n  /* Version 3.44.0 and later */\n  void *(*get_clientdata)(sqlite3*,const char*);\n  int (*set_clientdata)(sqlite3*, const char*, void*, void(*)(void*));\n};\n\n/*\n** This is the function signature used for all extension entry points.  It\n** is also defined in the file \"loadext.c\".\n*/\ntypedef int (*sqlite3_loadext_entry)(\n  sqlite3 *db,                       /* Handle to the database. */\n  char **pzErrMsg,                   /* Used to set error string on failure. */\n  const sqlite3_api_routines *pThunk /* Extension API function pointers. */\n);\n\n/*\n** The following macros redefine the API routines so that they are\n** redirected through the global sqlite3_api structure.\n**\n** This header file is also used by the loadext.c source file\n** (part of the main SQLite library - not an extension) so that\n** it can get access to the sqlite3_api_routines structure\n** definition.  But the main library does not want to redefine\n** the API.  So the redefinition macros are only valid if the\n** SQLITE_CORE macros is undefined.\n*/\n#if !defined(SQLITE_CORE) && !defined(SQLITE_OMIT_LOAD_EXTENSION)\n#define sqlite3_aggregate_context      sqlite3_api->aggregate_context\n#ifndef SQLITE_OMIT_DEPRECATED\n#define sqlite3_aggregate_count        sqlite3_api->aggregate_count\n#endif\n#define sqlite3_bind_blob              sqlite3_api->bind_blob\n#define sqlite3_bind_double            sqlite3_api->bind_double\n#define sqlite3_bind_int               sqlite3_api->bind_int\n#define sqlite3_bind_int64             sqlite3_api->bind_int64\n#define sqlite3_bind_null              sqlite3_api->bind_null\n#define sqlite3_bind_parameter_count   sqlite3_api->bind_parameter_count\n#define sqlite3_bind_parameter_index   sqlite3_api->bind_parameter_index\n#define sqlite3_bind_parameter_name    sqlite3_api->bind_parameter_name\n#define sqlite3_bind_text              sqlite3_api->bind_text\n#define sqlite3_bind_text16            sqlite3_api->bind_text16\n#define sqlite3_bind_value             sqlite3_api->bind_value\n#define sqlite3_busy_handler           sqlite3_api->busy_handler\n#define sqlite3_busy_timeout           sqlite3_api->busy_timeout\n#define sqlite3_changes                sqlite3_api->changes\n#define sqlite3_close                  sqlite3_api->close\n#define sqlite3_collation_needed       sqlite3_api->collation_needed\n#define sqlite3_collation_needed16     sqlite3_api->collation_needed16\n#define sqlite3_column_blob            sqlite3_api->column_blob\n#define sqlite3_column_bytes           sqlite3_api->column_bytes\n#define sqlite3_column_bytes16         sqlite3_api->column_bytes16\n#define sqlite3_column_count           sqlite3_api->column_count\n#define sqlite3_column_database_name   sqlite3_api->column_database_name\n#define sqlite3_column_database_name16 sqlite3_api->column_database_name16\n#define sqlite3_column_decltype        sqlite3_api->column_decltype\n#define sqlite3_column_decltype16      sqlite3_api->column_decltype16\n#define sqlite3_column_double          sqlite3_api->column_double\n#define sqlite3_column_int             sqlite3_api->column_int\n#define sqlite3_column_int64           sqlite3_api->column_int64\n#define sqlite3_column_name            sqlite3_api->column_name\n#define sqlite3_column_name16          sqlite3_api->column_name16\n#define sqlite3_column_origin_name     sqlite3_api->column_origin_name\n#define sqlite3_column_origin_name16   sqlite3_api->column_origin_name16\n#define sqlite3_column_table_name      sqlite3_api->column_table_name\n#define sqlite3_column_table_name16    sqlite3_api->column_table_name16\n#define sqlite3_column_text            sqlite3_api->column_text\n#define sqlite3_column_text16          sqlite3_api->column_text16\n#define sqlite3_column_type            sqlite3_api->column_type\n#define sqlite3_column_value           sqlite3_api->column_value\n#define sqlite3_commit_hook            sqlite3_api->commit_hook\n#define sqlite3_complete               sqlite3_api->complete\n#define sqlite3_complete16             sqlite3_api->complete16\n#define sqlite3_create_collation       sqlite3_api->create_collation\n#define sqlite3_create_collation16     sqlite3_api->create_collation16\n#define sqlite3_create_function        sqlite3_api->create_function\n#define sqlite3_create_function16      sqlite3_api->create_function16\n#define sqlite3_create_module          sqlite3_api->create_module\n#define sqlite3_create_module_v2       sqlite3_api->create_module_v2\n#define sqlite3_data_count             sqlite3_api->data_count\n#define sqlite3_db_handle              sqlite3_api->db_handle\n#define sqlite3_declare_vtab           sqlite3_api->declare_vtab\n#define sqlite3_enable_shared_cache    sqlite3_api->enable_shared_cache\n#define sqlite3_errcode                sqlite3_api->errcode\n#define sqlite3_errmsg                 sqlite3_api->errmsg\n#define sqlite3_errmsg16               sqlite3_api->errmsg16\n#define sqlite3_exec                   sqlite3_api->exec\n#ifndef SQLITE_OMIT_DEPRECATED\n#define sqlite3_expired                sqlite3_api->expired\n#endif\n#define sqlite3_finalize               sqlite3_api->finalize\n#define sqlite3_free                   sqlite3_api->free\n#define sqlite3_free_table             sqlite3_api->free_table\n#define sqlite3_get_autocommit         sqlite3_api->get_autocommit\n#define sqlite3_get_auxdata            sqlite3_api->get_auxdata\n#define sqlite3_get_table              sqlite3_api->get_table\n#ifndef SQLITE_OMIT_DEPRECATED\n#define sqlite3_global_recover         sqlite3_api->global_recover\n#endif\n#define sqlite3_interrupt              sqlite3_api->interruptx\n#define sqlite3_last_insert_rowid      sqlite3_api->last_insert_rowid\n#define sqlite3_libversion             sqlite3_api->libversion\n#define sqlite3_libversion_number      sqlite3_api->libversion_number\n#define sqlite3_malloc                 sqlite3_api->malloc\n#define sqlite3_mprintf                sqlite3_api->mprintf\n#define sqlite3_open                   sqlite3_api->open\n#define sqlite3_open16                 sqlite3_api->open16\n#define sqlite3_prepare                sqlite3_api->prepare\n#define sqlite3_prepare16              sqlite3_api->prepare16\n#define sqlite3_prepare_v2             sqlite3_api->prepare_v2\n#define sqlite3_prepare16_v2           sqlite3_api->prepare16_v2\n#define sqlite3_profile                sqlite3_api->profile\n#define sqlite3_progress_handler       sqlite3_api->progress_handler\n#define sqlite3_realloc                sqlite3_api->realloc\n#define sqlite3_reset                  sqlite3_api->reset\n#define sqlite3_result_blob            sqlite3_api->result_blob\n#define sqlite3_result_double          sqlite3_api->result_double\n#define sqlite3_result_error           sqlite3_api->result_error\n#define sqlite3_result_error16         sqlite3_api->result_error16\n#define sqlite3_result_int             sqlite3_api->result_int\n#define sqlite3_result_int64           sqlite3_api->result_int64\n#define sqlite3_result_null            sqlite3_api->result_null\n#define sqlite3_result_text            sqlite3_api->result_text\n#define sqlite3_result_text16          sqlite3_api->result_text16\n#define sqlite3_result_text16be        sqlite3_api->result_text16be\n#define sqlite3_result_text16le        sqlite3_api->result_text16le\n#define sqlite3_result_value           sqlite3_api->result_value\n#define sqlite3_rollback_hook          sqlite3_api->rollback_hook\n#define sqlite3_set_authorizer         sqlite3_api->set_authorizer\n#define sqlite3_set_auxdata            sqlite3_api->set_auxdata\n#define sqlite3_snprintf               sqlite3_api->xsnprintf\n#define sqlite3_step                   sqlite3_api->step\n#define sqlite3_table_column_metadata  sqlite3_api->table_column_metadata\n#define sqlite3_thread_cleanup         sqlite3_api->thread_cleanup\n#define sqlite3_total_changes          sqlite3_api->total_changes\n#define sqlite3_trace                  sqlite3_api->trace\n#ifndef SQLITE_OMIT_DEPRECATED\n#define sqlite3_transfer_bindings      sqlite3_api->transfer_bindings\n#endif\n#define sqlite3_update_hook            sqlite3_api->update_hook\n#define sqlite3_user_data              sqlite3_api->user_data\n#define sqlite3_value_blob             sqlite3_api->value_blob\n#define sqlite3_value_bytes            sqlite3_api->value_bytes\n#define sqlite3_value_bytes16          sqlite3_api->value_bytes16\n#define sqlite3_value_double           sqlite3_api->value_double\n#define sqlite3_value_int              sqlite3_api->value_int\n#define sqlite3_value_int64            sqlite3_api->value_int64\n#define sqlite3_value_numeric_type     sqlite3_api->value_numeric_type\n#define sqlite3_value_text             sqlite3_api->value_text\n#define sqlite3_value_text16           sqlite3_api->value_text16\n#define sqlite3_value_text16be         sqlite3_api->value_text16be\n#define sqlite3_value_text16le         sqlite3_api->value_text16le\n#define sqlite3_value_type             sqlite3_api->value_type\n#define sqlite3_vmprintf               sqlite3_api->vmprintf\n#define sqlite3_vsnprintf              sqlite3_api->xvsnprintf\n#define sqlite3_overload_function      sqlite3_api->overload_function\n#define sqlite3_prepare_v2             sqlite3_api->prepare_v2\n#define sqlite3_prepare16_v2           sqlite3_api->prepare16_v2\n#define sqlite3_clear_bindings         sqlite3_api->clear_bindings\n#define sqlite3_bind_zeroblob          sqlite3_api->bind_zeroblob\n#define sqlite3_blob_bytes             sqlite3_api->blob_bytes\n#define sqlite3_blob_close             sqlite3_api->blob_close\n#define sqlite3_blob_open              sqlite3_api->blob_open\n#define sqlite3_blob_read              sqlite3_api->blob_read\n#define sqlite3_blob_write             sqlite3_api->blob_write\n#define sqlite3_create_collation_v2    sqlite3_api->create_collation_v2\n#define sqlite3_file_control           sqlite3_api->file_control\n#define sqlite3_memory_highwater       sqlite3_api->memory_highwater\n#define sqlite3_memory_used            sqlite3_api->memory_used\n#define sqlite3_mutex_alloc            sqlite3_api->mutex_alloc\n#define sqlite3_mutex_enter            sqlite3_api->mutex_enter\n#define sqlite3_mutex_free             sqlite3_api->mutex_free\n#define sqlite3_mutex_leave            sqlite3_api->mutex_leave\n#define sqlite3_mutex_try              sqlite3_api->mutex_try\n#define sqlite3_open_v2                sqlite3_api->open_v2\n#define sqlite3_release_memory         sqlite3_api->release_memory\n#define sqlite3_result_error_nomem     sqlite3_api->result_error_nomem\n#define sqlite3_result_error_toobig    sqlite3_api->result_error_toobig\n#define sqlite3_sleep                  sqlite3_api->sleep\n#define sqlite3_soft_heap_limit        sqlite3_api->soft_heap_limit\n#define sqlite3_vfs_find               sqlite3_api->vfs_find\n#define sqlite3_vfs_register           sqlite3_api->vfs_register\n#define sqlite3_vfs_unregister         sqlite3_api->vfs_unregister\n#define sqlite3_threadsafe             sqlite3_api->xthreadsafe\n#define sqlite3_result_zeroblob        sqlite3_api->result_zeroblob\n#define sqlite3_result_error_code      sqlite3_api->result_error_code\n#define sqlite3_test_control           sqlite3_api->test_control\n#define sqlite3_randomness             sqlite3_api->randomness\n#define sqlite3_context_db_handle      sqlite3_api->context_db_handle\n#define sqlite3_extended_result_codes  sqlite3_api->extended_result_codes\n#define sqlite3_limit                  sqlite3_api->limit\n#define sqlite3_next_stmt              sqlite3_api->next_stmt\n#define sqlite3_sql                    sqlite3_api->sql\n#define sqlite3_status                 sqlite3_api->status\n#define sqlite3_backup_finish          sqlite3_api->backup_finish\n#define sqlite3_backup_init            sqlite3_api->backup_init\n#define sqlite3_backup_pagecount       sqlite3_api->backup_pagecount\n#define sqlite3_backup_remaining       sqlite3_api->backup_remaining\n#define sqlite3_backup_step            sqlite3_api->backup_step\n#define sqlite3_compileoption_get      sqlite3_api->compileoption_get\n#define sqlite3_compileoption_used     sqlite3_api->compileoption_used\n#define sqlite3_create_function_v2     sqlite3_api->create_function_v2\n#define sqlite3_db_config              sqlite3_api->db_config\n#define sqlite3_db_mutex               sqlite3_api->db_mutex\n#define sqlite3_db_status              sqlite3_api->db_status\n#define sqlite3_extended_errcode       sqlite3_api->extended_errcode\n#define sqlite3_log                    sqlite3_api->log\n#define sqlite3_soft_heap_limit64      sqlite3_api->soft_heap_limit64\n#define sqlite3_sourceid               sqlite3_api->sourceid\n#define sqlite3_stmt_status            sqlite3_api->stmt_status\n#define sqlite3_strnicmp               sqlite3_api->strnicmp\n#define sqlite3_unlock_notify          sqlite3_api->unlock_notify\n#define sqlite3_wal_autocheckpoint     sqlite3_api->wal_autocheckpoint\n#define sqlite3_wal_checkpoint         sqlite3_api->wal_checkpoint\n#define sqlite3_wal_hook               sqlite3_api->wal_hook\n#define sqlite3_blob_reopen            sqlite3_api->blob_reopen\n#define sqlite3_vtab_config            sqlite3_api->vtab_config\n#define sqlite3_vtab_on_conflict       sqlite3_api->vtab_on_conflict\n/* Version 3.7.16 and later */\n#define sqlite3_close_v2               sqlite3_api->close_v2\n#define sqlite3_db_filename            sqlite3_api->db_filename\n#define sqlite3_db_readonly            sqlite3_api->db_readonly\n#define sqlite3_db_release_memory      sqlite3_api->db_release_memory\n#define sqlite3_errstr                 sqlite3_api->errstr\n#define sqlite3_stmt_busy              sqlite3_api->stmt_busy\n#define sqlite3_stmt_readonly          sqlite3_api->stmt_readonly\n#define sqlite3_stricmp                sqlite3_api->stricmp\n#define sqlite3_uri_boolean            sqlite3_api->uri_boolean\n#define sqlite3_uri_int64              sqlite3_api->uri_int64\n#define sqlite3_uri_parameter          sqlite3_api->uri_parameter\n#define sqlite3_uri_vsnprintf          sqlite3_api->xvsnprintf\n#define sqlite3_wal_checkpoint_v2      sqlite3_api->wal_checkpoint_v2\n/* Version 3.8.7 and later */\n#define sqlite3_auto_extension         sqlite3_api->auto_extension\n#define sqlite3_bind_blob64            sqlite3_api->bind_blob64\n#define sqlite3_bind_text64            sqlite3_api->bind_text64\n#define sqlite3_cancel_auto_extension  sqlite3_api->cancel_auto_extension\n#define sqlite3_load_extension         sqlite3_api->load_extension\n#define sqlite3_malloc64               sqlite3_api->malloc64\n#define sqlite3_msize                  sqlite3_api->msize\n#define sqlite3_realloc64              sqlite3_api->realloc64\n#define sqlite3_reset_auto_extension   sqlite3_api->reset_auto_extension\n#define sqlite3_result_blob64          sqlite3_api->result_blob64\n#define sqlite3_result_text64          sqlite3_api->result_text64\n#define sqlite3_strglob                sqlite3_api->strglob\n/* Version 3.8.11 and later */\n#define sqlite3_value_dup              sqlite3_api->value_dup\n#define sqlite3_value_free             sqlite3_api->value_free\n#define sqlite3_result_zeroblob64      sqlite3_api->result_zeroblob64\n#define sqlite3_bind_zeroblob64        sqlite3_api->bind_zeroblob64\n/* Version 3.9.0 and later */\n#define sqlite3_value_subtype          sqlite3_api->value_subtype\n#define sqlite3_result_subtype         sqlite3_api->result_subtype\n/* Version 3.10.0 and later */\n#define sqlite3_status64               sqlite3_api->status64\n#define sqlite3_strlike                sqlite3_api->strlike\n#define sqlite3_db_cacheflush          sqlite3_api->db_cacheflush\n/* Version 3.12.0 and later */\n#define sqlite3_system_errno           sqlite3_api->system_errno\n/* Version 3.14.0 and later */\n#define sqlite3_trace_v2               sqlite3_api->trace_v2\n#define sqlite3_expanded_sql           sqlite3_api->expanded_sql\n/* Version 3.18.0 and later */\n#define sqlite3_set_last_insert_rowid  sqlite3_api->set_last_insert_rowid\n/* Version 3.20.0 and later */\n#define sqlite3_prepare_v3             sqlite3_api->prepare_v3\n#define sqlite3_prepare16_v3           sqlite3_api->prepare16_v3\n#define sqlite3_bind_pointer           sqlite3_api->bind_pointer\n#define sqlite3_result_pointer         sqlite3_api->result_pointer\n#define sqlite3_value_pointer          sqlite3_api->value_pointer\n/* Version 3.22.0 and later */\n#define sqlite3_vtab_nochange          sqlite3_api->vtab_nochange\n#define sqlite3_value_nochange         sqlite3_api->value_nochange\n#define sqlite3_vtab_collation         sqlite3_api->vtab_collation\n/* Version 3.24.0 and later */\n#define sqlite3_keyword_count          sqlite3_api->keyword_count\n#define sqlite3_keyword_name           sqlite3_api->keyword_name\n#define sqlite3_keyword_check          sqlite3_api->keyword_check\n#define sqlite3_str_new                sqlite3_api->str_new\n#define sqlite3_str_finish             sqlite3_api->str_finish\n#define sqlite3_str_appendf            sqlite3_api->str_appendf\n#define sqlite3_str_vappendf           sqlite3_api->str_vappendf\n#define sqlite3_str_append             sqlite3_api->str_append\n#define sqlite3_str_appendall          sqlite3_api->str_appendall\n#define sqlite3_str_appendchar         sqlite3_api->str_appendchar\n#define sqlite3_str_reset              sqlite3_api->str_reset\n#define sqlite3_str_errcode            sqlite3_api->str_errcode\n#define sqlite3_str_length             sqlite3_api->str_length\n#define sqlite3_str_value              sqlite3_api->str_value\n/* Version 3.25.0 and later */\n#define sqlite3_create_window_function sqlite3_api->create_window_function\n/* Version 3.26.0 and later */\n#define sqlite3_normalized_sql         sqlite3_api->normalized_sql\n/* Version 3.28.0 and later */\n#define sqlite3_stmt_isexplain         sqlite3_api->stmt_isexplain\n#define sqlite3_value_frombind         sqlite3_api->value_frombind\n/* Version 3.30.0 and later */\n#define sqlite3_drop_modules           sqlite3_api->drop_modules\n/* Version 3.31.0 and later */\n#define sqlite3_hard_heap_limit64      sqlite3_api->hard_heap_limit64\n#define sqlite3_uri_key                sqlite3_api->uri_key\n#define sqlite3_filename_database      sqlite3_api->filename_database\n#define sqlite3_filename_journal       sqlite3_api->filename_journal\n#define sqlite3_filename_wal           sqlite3_api->filename_wal\n/* Version 3.32.0 and later */\n#define sqlite3_create_filename        sqlite3_api->create_filename\n#define sqlite3_free_filename          sqlite3_api->free_filename\n#define sqlite3_database_file_object   sqlite3_api->database_file_object\n/* Version 3.34.0 and later */\n#define sqlite3_txn_state              sqlite3_api->txn_state\n/* Version 3.36.1 and later */\n#define sqlite3_changes64              sqlite3_api->changes64\n#define sqlite3_total_changes64        sqlite3_api->total_changes64\n/* Version 3.37.0 and later */\n#define sqlite3_autovacuum_pages       sqlite3_api->autovacuum_pages\n/* Version 3.38.0 and later */\n#define sqlite3_error_offset           sqlite3_api->error_offset\n#define sqlite3_vtab_rhs_value         sqlite3_api->vtab_rhs_value\n#define sqlite3_vtab_distinct          sqlite3_api->vtab_distinct\n#define sqlite3_vtab_in                sqlite3_api->vtab_in\n#define sqlite3_vtab_in_first          sqlite3_api->vtab_in_first\n#define sqlite3_vtab_in_next           sqlite3_api->vtab_in_next\n/* Version 3.39.0 and later */\n#ifndef SQLITE_OMIT_DESERIALIZE\n#define sqlite3_deserialize            sqlite3_api->deserialize\n#define sqlite3_serialize              sqlite3_api->serialize\n#endif\n#define sqlite3_db_name                sqlite3_api->db_name\n/* Version 3.40.0 and later */\n#define sqlite3_value_encoding         sqlite3_api->value_encoding\n/* Version 3.41.0 and later */\n#define sqlite3_is_interrupted         sqlite3_api->is_interrupted\n/* Version 3.43.0 and later */\n#define sqlite3_stmt_explain           sqlite3_api->stmt_explain\n/* Version 3.44.0 and later */\n#define sqlite3_get_clientdata         sqlite3_api->get_clientdata\n#define sqlite3_set_clientdata         sqlite3_api->set_clientdata\n#endif /* !defined(SQLITE_CORE) && !defined(SQLITE_OMIT_LOAD_EXTENSION) */\n\n#if !defined(SQLITE_CORE) && !defined(SQLITE_OMIT_LOAD_EXTENSION)\n  /* This case when the file really is being compiled as a loadable \n  ** extension */\n# define SQLITE_EXTENSION_INIT1     const sqlite3_api_routines *sqlite3_api=0;\n# define SQLITE_EXTENSION_INIT2(v)  sqlite3_api=v;\n# define SQLITE_EXTENSION_INIT3     \\\n    extern const sqlite3_api_routines *sqlite3_api;\n#else\n  /* This case when the file is being statically linked into the \n  ** application */\n# define SQLITE_EXTENSION_INIT1     /*no-op*/\n# define SQLITE_EXTENSION_INIT2(v)  (void)v; /* unused parameter */\n# define SQLITE_EXTENSION_INIT3     /*no-op*/\n#endif\n\n#endif /* SQLITE3EXT_H */\n#else // USE_LIBSQLITE3\n // If users really want to link against the system sqlite3 we\n// need to make this file a noop.\n #endif"
        },
        {
          "name": "static_mock.go",
          "type": "blob",
          "size": 1.27734375,
          "content": "// Copyright (C) 2019 Yasuhiro Matsumoto <mattn.jp@gmail.com>.\n//\n// Use of this source code is governed by an MIT-style\n// license that can be found in the LICENSE file.\n\n//go:build !cgo\n// +build !cgo\n\npackage sqlite3\n\nimport (\n\t\"database/sql\"\n\t\"database/sql/driver\"\n\t\"errors\"\n)\n\nvar errorMsg = errors.New(\"Binary was compiled with 'CGO_ENABLED=0', go-sqlite3 requires cgo to work. This is a stub\")\n\nfunc init() {\n\tsql.Register(\"sqlite3\", &SQLiteDriver{})\n}\n\ntype (\n\tSQLiteDriver struct {\n\t\tExtensions  []string\n\t\tConnectHook func(*SQLiteConn) error\n\t}\n\tSQLiteConn struct{}\n)\n\nfunc (SQLiteDriver) Open(s string) (driver.Conn, error)                        { return nil, errorMsg }\nfunc (c *SQLiteConn) RegisterAggregator(string, any, bool) error               { return errorMsg }\nfunc (c *SQLiteConn) RegisterAuthorizer(func(int, string, string, string) int) {}\nfunc (c *SQLiteConn) RegisterCollation(string, func(string, string) int) error { return errorMsg }\nfunc (c *SQLiteConn) RegisterCommitHook(func() int)                            {}\nfunc (c *SQLiteConn) RegisterFunc(string, any, bool) error                     { return errorMsg }\nfunc (c *SQLiteConn) RegisterRollbackHook(func())                              {}\nfunc (c *SQLiteConn) RegisterUpdateHook(func(int, string, string, int64))      {}\n"
        },
        {
          "name": "upgrade",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}