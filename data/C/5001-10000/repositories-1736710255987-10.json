{
  "metadata": {
    "timestamp": 1736710255987,
    "page": 10,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "bol-van/zapret",
      "stars": 9694,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.0478515625,
          "content": "* text=auto eol=lf\n*.cmd eol=crlf\n*.bat eol=crlf\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1728515625,
          "content": "/config\nip2net/ip2net\nmdig/mdig\nnfq/dvtws\nnfq/nfqws\nnfq/winws.exe\ntpws/tpws\nbinaries/my/\nipset/zapret-ip*.txt\nipset/zapret-ip*.gz\nipset/zapret-hosts*.txt\nipset/zapret-hosts*.gz\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 1.6953125,
          "content": "DIRS := nfq tpws ip2net mdig\nDIRS_MAC := tpws ip2net mdig\nTGT := binaries/my\n\nall:\tclean\n\t@mkdir -p \"$(TGT)\"; \\\n\tfor dir in $(DIRS); do \\\n\t\tfind \"$$dir\" -type f  \\( -name \"*.c\" -o -name \"*.h\" -o -name \"*akefile\" \\) -exec chmod -x {} \\; ; \\\n\t\t$(MAKE) -C \"$$dir\" || exit; \\\n\t\tfor exe in \"$$dir/\"*; do \\\n\t\t\tif [ -f \"$$exe\" ] && [ -x \"$$exe\" ]; then \\\n\t\t\t\tmv -f \"$$exe\" \"${TGT}\" ; \\\n\t\t\t\tln -fs \"../${TGT}/$$(basename \"$$exe\")\" \"$$exe\" ; \\\n\t\t\tfi \\\n\t\tdone \\\n\tdone\n\nandroid: clean\n\t@mkdir -p \"$(TGT)\"; \\\n\tfor dir in $(DIRS); do \\\n\t\tfind \"$$dir\" -type f  \\( -name \"*.c\" -o -name \"*.h\" -o -name \"*akefile\" \\) -exec chmod -x {} \\; ; \\\n\t\t$(MAKE) -C \"$$dir\" android || exit; \\\n\t\tfor exe in \"$$dir/\"*; do \\\n\t\t\tif [ -f \"$$exe\" ] && [ -x \"$$exe\" ]; then \\\n\t\t\t\tmv -f \"$$exe\" \"${TGT}\" ; \\\n\t\t\t\tln -fs \"../${TGT}/$$(basename \"$$exe\")\" \"$$exe\" ; \\\n\t\t\tfi \\\n\t\tdone \\\n\tdone\n\nbsd:\tclean\n\t@mkdir -p \"$(TGT)\"; \\\n\tfor dir in $(DIRS); do \\\n\t\tfind \"$$dir\" -type f  \\( -name \"*.c\" -o -name \"*.h\" -o -name \"*akefile\" \\) -exec chmod -x {} \\; ; \\\n\t\t$(MAKE) -C \"$$dir\" bsd || exit; \\\n\t\tfor exe in \"$$dir/\"*; do \\\n\t\t\tif [ -f \"$$exe\" ] && [ -x \"$$exe\" ]; then \\\n\t\t\t\tmv -f \"$$exe\" \"${TGT}\" ; \\\n\t\t\t\tln -fs \"../${TGT}/$$(basename \"$$exe\")\" \"$$exe\" ; \\\n\t\t\tfi \\\n\t\tdone \\\n\tdone\n\nmac:\tclean\n\t@mkdir -p \"$(TGT)\"; \\\n\tfor dir in $(DIRS_MAC); do \\\n\t\tfind \"$$dir\" -type f  \\( -name \"*.c\" -o -name \"*.h\" -o -name \"*akefile\" \\) -exec chmod -x {} \\; ; \\\n\t\t$(MAKE) -C \"$$dir\" mac || exit; \\\n\t\tfor exe in \"$$dir/\"*; do \\\n\t\t\tif [ -f \"$$exe\" ] && [ -x \"$$exe\" ]; then \\\n\t\t\t\tmv -f \"$$exe\" \"${TGT}\" ; \\\n\t\t\t\tln -fs \"../${TGT}/$$(basename \"$$exe\")\" \"$$exe\" ; \\\n\t\t\tfi \\\n\t\tdone \\\n\tdone\n\nclean:\n\t@[ -d \"$(TGT)\" ] && rm -rf \"$(TGT)\" ; \\\n\tfor dir in $(DIRS); do \\\n\t\t$(MAKE) -C \"$$dir\" clean; \\\n\tdone\n"
        },
        {
          "name": "blockcheck.sh",
          "type": "blob",
          "size": 53.298828125,
          "content": "#!/bin/sh\n\nEXEDIR=\"$(dirname \"$0\")\"\nEXEDIR=\"$(cd \"$EXEDIR\"; pwd)\"\nZAPRET_BASE=${ZAPRET_BASE:-\"$EXEDIR\"}\nZAPRET_RW=${ZAPRET_RW:-\"$ZAPRET_BASE\"}\nZAPRET_CONFIG=${ZAPRET_CONFIG:-\"$ZAPRET_RW/config\"}\nZAPRET_CONFIG_DEFAULT=\"$ZAPRET_BASE/config.default\"\n\nCURL=${CURL:-curl}\n\n[ -f \"$ZAPRET_CONFIG\" ] || {\n\t[ -f \"$ZAPRET_CONFIG_DEFAULT\" ] && {\n\t\tZAPRET_CONFIG_DIR=\"$(dirname \"$ZAPRET_CONFIG\")\"\n\t\t[ -d \"$ZAPRET_CONFIG_DIR\" ] || mkdir -p \"$ZAPRET_CONFIG_DIR\"\n\t\tcp \"$ZAPRET_CONFIG_DEFAULT\" \"$ZAPRET_CONFIG\"\n\t}\n}\n[ -f \"$ZAPRET_CONFIG\" ] && . \"$ZAPRET_CONFIG\"\n. \"$ZAPRET_BASE/common/base.sh\"\n. \"$ZAPRET_BASE/common/dialog.sh\"\n. \"$ZAPRET_BASE/common/elevate.sh\"\n. \"$ZAPRET_BASE/common/fwtype.sh\"\n. \"$ZAPRET_BASE/common/virt.sh\"\n\nDOMAINS_DEFAULT=${DOMAINS_DEFAULT:-rutracker.org}\nQNUM=${QNUM:-59780}\nSOCKS_PORT=${SOCKS_PORT:-1993}\nTPWS_UID=${TPWS_UID:-1}\nTPWS_GID=${TPWS_GID:-3003}\nNFQWS=${NFQWS:-${ZAPRET_BASE}/nfq/nfqws}\nDVTWS=${DVTWS:-${ZAPRET_BASE}/nfq/dvtws}\nWINWS=${WINWS:-${ZAPRET_BASE}/nfq/winws}\nTPWS=${TPWS:-${ZAPRET_BASE}/tpws/tpws}\nMDIG=${MDIG:-${ZAPRET_BASE}/mdig/mdig}\nDESYNC_MARK=0x10000000\nIPFW_RULE_NUM=${IPFW_RULE_NUM:-1}\nIPFW_DIVERT_PORT=${IPFW_DIVERT_PORT:-59780}\nCURL_MAX_TIME=${CURL_MAX_TIME:-2}\nCURL_MAX_TIME_QUIC=${CURL_MAX_TIME_QUIC:-$CURL_MAX_TIME}\nCURL_MAX_TIME_DOH=${CURL_MAX_TIME_DOH:-2}\nMIN_TTL=${MIN_TTL:-1}\nMAX_TTL=${MAX_TTL:-12}\nUSER_AGENT=${USER_AGENT:-Mozilla}\nHTTP_PORT=${HTTP_PORT:-80}\nHTTPS_PORT=${HTTPS_PORT:-443}\nQUIC_PORT=${QUIC_PORT:-443}\nUNBLOCKED_DOM=${UNBLOCKED_DOM:-iana.org}\nPARALLEL_OUT=/tmp/zapret_parallel\n\nHDRTEMP=/tmp/zapret-hdr\n\nNFT_TABLE=blockcheck\n\nDNSCHECK_DNS=${DNSCHECK_DNS:-8.8.8.8 1.1.1.1 77.88.8.1}\nDNSCHECK_DOM=${DNSCHECK_DOM:-pornhub.com ntc.party rutracker.org www.torproject.org bbc.com}\nDOH_SERVERS=${DOH_SERVERS:-\"https://cloudflare-dns.com/dns-query https://dns.google/dns-query https://dns.quad9.net/dns-query https://dns.adguard.com/dns-query https://common.dot.dns.yandex.net/dns-query\"}\nDNSCHECK_DIG1=/tmp/dig1.txt\nDNSCHECK_DIG2=/tmp/dig2.txt\nDNSCHECK_DIGS=/tmp/digs.txt\n\nIPSET_FILE=/tmp/blockcheck_ipset.txt\n\nunset PF_STATUS\nPF_RULES_SAVE=/tmp/pf-zapret-save.conf\n\nunset ALL_PROXY\n\nkillwait()\n{\n\t# $1 - signal (-9, -2, ...)\n\t# $2 - pid\n\tkill $1 $2\n\t# suppress job kill message\n\twait $2 2>/dev/null\n}\n\nexitp()\n{\n\tlocal A\n\n\t[ \"$BATCH\" = 1 ] || {\n\t\techo\n\t\techo press enter to continue\n\t\tread A\n\t}\n\texit $1\n}\n\npf_is_avail()\n{\n\t[ -c /dev/pf ]\n}\npf_status()\n{\n\tpfctl -qsi  | sed -nre \"s/^Status: ([^ ]+).*$/\\1/p\"\n}\npf_is_enabled()\n{\n\t[ \"$(pf_status)\" = Enabled ]\n}\npf_save()\n{\n\tPF_STATUS=0\n\tpf_is_enabled && PF_STATUS=1\n\t[ \"$UNAME\" = \"OpenBSD\" ] && pfctl -sr >\"$PF_RULES_SAVE\"\n}\npf_restore()\n{\n\t[ -n \"$PF_STATUS\" ] || return\n\tcase \"$UNAME\" in\n\t\tOpenBSD)\n\t\t\tif [ -f \"$PF_RULES_SAVE\" ]; then\n\t\t\t\tpfctl -qf \"$PF_RULES_SAVE\"\n\t\t\telse\n\t\t\t\techo | pfctl -qf -\n\t\t\tfi\n\t\t\t;;\n\t\tDarwin)\n\t\t\t# it's not possible to save all rules in the right order. hard to reorder. if not ordered pf will refuse to load conf.\n\t\t\tpfctl -qf /etc/pf.conf\n\t\t\t;;\n\tesac\n\tif [ \"$PF_STATUS\" = 1 ]; then\n\t\tpfctl -qe\n\telse\n\t\tpfctl -qd\n\tfi\n}\npf_clean()\n{\n\trm -f \"$PF_RULES_SAVE\"\n}\nopf_dvtws_anchor()\n{\n\t# $1 - tcp/udp\n\t# $2 - port\n\t# $3 - ip list\n\tlocal iplist family=inet\n\t[ \"$IPV\" = 6 ] && family=inet6\n\tmake_comma_list iplist \"$3\"\n\techo \"set reassemble no\"\n\t[ \"$1\" = tcp ] && echo \"pass in quick $family proto $1 from {$iplist} port $2 flags SA/SA divert-packet port $IPFW_DIVERT_PORT no state\"\n\techo \"pass in  quick $family proto $1 from {$iplist} port $2 no state\"\n\techo \"pass out quick $family proto $1 to   {$iplist} port $2 divert-packet port $IPFW_DIVERT_PORT no state\"\n\techo \"pass\"\n}\nopf_prepare_dvtws()\n{\n\t# $1 - tcp/udp\n\t# $2 - port\n\t# $3 - ip list\n\topf_dvtws_anchor $1 $2 \"$3\" | pfctl -qf -\n\tpfctl -qe\n}\n\ncleanup()\n{\n\tcase \"$UNAME\" in\n\t\tOpenBSD)\n\t\t    pf_clean\n\t\t    ;;\n\tesac\n}\n\nIPT()\n{\n\t$IPTABLES -C \"$@\" >/dev/null 2>/dev/null || $IPTABLES -I \"$@\"\n}\nIPT_DEL()\n{\n\t$IPTABLES -C \"$@\" >/dev/null 2>/dev/null && $IPTABLES -D \"$@\"\n}\nIPT_ADD_DEL()\n{\n\ton_off_function IPT IPT_DEL \"$@\"\n}\nIPFW_ADD()\n{\n\tipfw -qf add $IPFW_RULE_NUM \"$@\"\n}\nIPFW_DEL()\n{\n\tipfw -qf delete $IPFW_RULE_NUM 2>/dev/null\n}\nipt6_has_raw()\n{\n\tip6tables -nL -t raw >/dev/null 2>/dev/null\n}\nipt6_has_frag()\n{\n\tip6tables -A OUTPUT -m frag 2>/dev/null || return 1\n\tip6tables -D OUTPUT -m frag 2>/dev/null\n}\nipt_has_nfq()\n{\n\t# cannot just check /proc/net/ip_tables_targets because of iptables-nft or modules not loaded yet\n\tiptables -A OUTPUT -t mangle -p 255 -j NFQUEUE --queue-num $QNUM --queue-bypass 2>/dev/null || return 1\n\tiptables -D OUTPUT -t mangle -p 255 -j NFQUEUE --queue-num $QNUM --queue-bypass 2>/dev/null\n\treturn 0\n}\nnft_has_nfq()\n{\n\tlocal res=1\n\tnft delete table ${NFT_TABLE}_test 2>/dev/null\n\tnft add table ${NFT_TABLE}_test 2>/dev/null && {\n\t\tnft add chain ${NFT_TABLE}_test test\n\t\tnft add rule ${NFT_TABLE}_test test queue num $QNUM bypass 2>/dev/null && res=0\n\t\tnft delete table ${NFT_TABLE}_test\n\t}\n\treturn $res\n}\n\ndoh_resolve()\n{\n\t# $1 - ip version 4/6\n\t# $2 - hostname\n\t# $3 - doh server URL. use $DOH_SERVER if empty\n\t$MDIG --family=$1 --dns-make-query=$2 | $CURL --max-time $CURL_MAX_TIME_DOH -s --data-binary @- -H \"Content-Type: application/dns-message\" \"${3:-$DOH_SERVER}\" | $MDIG --dns-parse-query\n}\ndoh_find_working()\n{\n\tlocal doh\n\n\t[ -n \"$DOH_SERVER\" ] && return 0\n\techo \"* searching working DoH server\"\n\tDOH_SERVER=\n\tfor doh in $DOH_SERVERS; do\n\t\techo -n \"$doh : \"\n\t\tif doh_resolve 4 iana.org $doh >/dev/null 2>/dev/null; then\n\t\t\techo OK\n\t\t\tDOH_SERVER=\"$doh\"\n\t\t\treturn 0\n\t\telse\n\t\t\techo FAIL\n\t\tfi\n\tdone\n\techo all DoH servers failed\n\treturn 1\n}\n\nmdig_vars()\n{\n\t# $1 - ip version 4/6\n\t# $2 - hostname\n\n\thostvar=$(echo $2 | sed -e 's/[\\.-]/_/g')\n\tcachevar=DNSCACHE_${hostvar}_$1\n\tcountvar=${cachevar}_COUNT\n\teval count=\\$${countvar}\n}\nmdig_cache()\n{\n\t# $1 - ip version 4/6\n\t# $2 - hostname\n\tlocal hostvar cachevar countvar count ip ips\n\tmdig_vars \"$@\"\n\t[ -n \"$count\" ] || {\n\t\t# windows version of mdig outputs 0D0A line ending. remove 0D.\n\t\tif [ \"$SECURE_DNS\" = 1 ]; then\n\t\t\tips=\"$(echo $2 | doh_resolve $1 $2 | tr -d '\\r' | xargs)\"\n\t\telse\n\t\t\tips=\"$(echo $2 | \"$MDIG\" --family=$1 | tr -d '\\r' | xargs)\"\n\t\tfi\n\t\t[ -n \"$ips\" ] || return 1\n\t\tcount=0\n\t\tfor ip in $ips; do\n\t\t\teval ${cachevar}_$count=$ip\n\t\t\tcount=$(($count+1))\n\t\tdone\n\t\teval $countvar=$count\n\t}\n\treturn 0\n}\nmdig_resolve()\n{\n\t# $1 - ip version 4/6\n\t# $2 - hostname\n\n\tlocal hostvar cachevar countvar count ip n\n\tmdig_vars \"$@\"\n\tif [ -n \"$count\" ]; then\n\t\tn=$(random 0 $(($count-1)))\n\t\teval ip=\\$${cachevar}_$n\n\t\techo $ip\n\t\treturn 0\n\telse\n\t\tmdig_cache \"$@\" && mdig_resolve \"$@\"\n\tfi\n}\nmdig_resolve_all()\n{\n\t# $1 - ip version 4/6\n\t# $2 - hostname\n\n\tlocal hostvar cachevar countvar count ip ips n\n\tmdig_vars \"$@\"\n\tif [ -n \"$count\" ]; then\n\t\tn=0\n\t\twhile [ \"$n\" -le $count ]; do\n\t\t\teval ip=\\$${cachevar}_$n\n\t\t\tif [ -n \"$ips\" ]; then\n\t\t\t\tips=\"$ips $ip\"\n\t\t\telse\n\t\t\t\tips=\"$ip\"\n\t\t\tfi\n\t\t\tn=$(($n + 1))\n\t\tdone\n\t\techo \"$ips\"\n\t\treturn 0\n\telse\n\t\tmdig_cache \"$@\" && mdig_resolve_all \"$@\"\n\tfi\n}\n\nnetcat_setup()\n{\n\t[ -n \"$NCAT\" ] || {\n\t\tif exists ncat; then\n\t\t\tNCAT=ncat\n\t\telif exists nc; then\n\t\t\t# busybox netcat does not support any required options\n\t\t\tis_linked_to_busybox nc && return 1\n\t\t\tNCAT=nc\n\t\telse\n\t\t\treturn 1\n\t\tfi\n\t}\n\treturn 0\n\t\n}\nnetcat_test()\n{\n\t# $1 - ip\n\t# $2 - port\n\tlocal cmd\n\tnetcat_setup && {\n\t\tcmd=\"$NCAT -z -w 2 $1 $2\"\n\t\techo $cmd\n\t\t$cmd 2>&1\n\t}\n}\n\ncheck_system()\n{\n\techo \\* checking system\n\n\tUNAME=$(uname)\n\tSUBSYS=\n\tlocal s\n\n\t# can be passed FWTYPE=iptables to override default nftables preference\n\tcase \"$UNAME\" in\n\t\tLinux)\n\t\t\tPKTWS=\"$NFQWS\"\n\t\t\tPKTWSD=nfqws\n\t\t\tlinux_fwtype\n\t\t\t[ \"$FWTYPE\" = iptables -o \"$FWTYPE\" = nftables ] || {\n\t\t\t\techo firewall type $FWTYPE not supported in $UNAME\n\t\t\t\texitp 5\n\t\t\t}\n\t\t\t;;\n\t\tFreeBSD)\n\t\t\tPKTWS=\"$DVTWS\"\n\t\t\tPKTWSD=dvtws\n\t\t\tFWTYPE=ipfw\n\t\t\t[ -f /etc/platform ] && read SUBSYS </etc/platform\n\t\t\t;;\n\t\tOpenBSD)\n\t\t\tPKTWS=\"$DVTWS\"\n\t\t\tPKTWSD=dvtws\n\t\t\tFWTYPE=opf\n\t\t\t;;\n\t\tDarwin)\n\t\t\tPKTWS=\"$DVTWS\"\n\t\t\tPKTWSD=dvtws\n\t\t\tFWTYPE=mpf\n\t\t\t;;\n\t\tCYGWIN*)\n\t\t\tUNAME=CYGWIN\n\t\t\tPKTWS=\"$WINWS\"\n\t\t\tPKTWSD=winws\n\t\t\tFWTYPE=windivert\n\t\t\t;;\n\t\t*)\n\t\t\techo $UNAME not supported\n\t\t\texitp 5\n\tesac\n\techo $UNAME${SUBSYS:+/$SUBSYS} detected\n\techo firewall type is $FWTYPE\n}\n\nzp_already_running()\n{\n\tcase \"$UNAME\" in\n\t\tCYGWIN)\n\t\t\twin_process_exists $PKTWSD || win_process_exists goodbyedpi\n\t\t\t;;\n\t\t*)\n\t\t\tprocess_exists $PKTWSD || process_exists tpws\n\tesac\n}\ncheck_already()\n{\n\techo \\* checking already running DPI bypass processes\n\tif zp_already_running; then\n\t\techo \"!!! WARNING. some dpi bypass processes already running !!!\"\n\t\techo \"!!! WARNING. blockcheck requires all DPI bypass methods disabled !!!\"\n\t\techo \"!!! WARNING. pls stop all dpi bypass instances that may interfere with blockcheck !!!\"\n\tfi\n}\n\nfreebsd_module_loaded()\n{\n\t# $1 - module name\n\tkldstat -qm \"${1}\"\n}\nfreebsd_modules_loaded()\n{\n\t# $1,$2,$3, ... - module names\n\twhile [ -n \"$1\" ]; do\n\t\tfreebsd_module_loaded $1 || return 1\n\t\tshift\n\tdone\n\treturn 0\n}\n\ncheck_prerequisites()\n{\n\techo \\* checking prerequisites\n\t\n\t[ \"$SKIP_PKTWS\" = 1 -o \"$UNAME\" = Darwin -o -x \"$PKTWS\" ] && [ \"$SKIP_TPWS\" = 1 -o \"$UNAME\" = CYGWIN -o -x \"$TPWS\" ] && [ -x \"$MDIG\" ] || {\n\t\tlocal target\n\t\tcase $UNAME in\n\t\t\tDarwin)\n\t\t\t\ttarget=\"mac\"\n\t\t\t\t;;\n\t\t\tOpenBSD)\n\t\t\t\ttarget=\"bsd\"\n\t\t\t\t;;\n\t\tesac\n\t\techo $PKTWS or $TPWS or $MDIG is not available. run \\\"$ZAPRET_BASE/install_bin.sh\\\" or \\`make -C \\\"$ZAPRET_BASE\\\" $target\\`\n\t\texitp 6\n\t}\n\n\tlocal prog progs='curl'\n\t[ \"$SKIP_PKTWS\" = 1 ] || {\n\t\tcase \"$UNAME\" in\n\t\t\tLinux)\n\t\t\t\tcase \"$FWTYPE\" in\n\t\t\t\t\tiptables)\n\t\t\t\t\t\tipt_has_nfq || {\n\t\t\t\t\t\t\techo NFQUEUE iptables or ip6tables target is missing. pls install modules.\n\t\t\t\t\t\t\texitp 6\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprogs=\"$progs iptables ip6tables\"\n\t\t\t\t\t\t;;\n\t\t\t\t\tnftables)\n\t\t\t\t\t\tnft_has_nfq || {\n\t\t\t\t\t\t\techo nftables queue support is not available. pls install modules.\n\t\t\t\t\t\t\texitp 6\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprogs=\"$progs nft\"\n\t\t\t\t\t\t;;\n\t\t\t\tesac\n\t\t\t\t;;\n\t\t\tFreeBSD)\n\t\t\t\tfreebsd_modules_loaded ipfw ipdivert || {\n\t\t\t\t\techo ipfw or ipdivert kernel module not loaded\n\t\t\t\t\t\texitp 6\n\t\t\t\t}\n\t\t\t\t[ \"$(sysctl -qn net.inet.ip.fw.enable)\" = 0 -o \"$(sysctl -qn net.inet6.ip6.fw.enable)\" = 0 ] && {\n\t\t\t\t\techo ipfw is disabled. use : ipfw enable firewall\n\t\t\t\t\texitp 6\n\t\t\t\t}\n\t\t\t\tpf_is_avail && {\n\t\t\t\t\tpf_save\n\t\t\t\t\t[ \"$SUBSYS\" = \"pfSense\" ] && {\n\t\t\t\t\t\t# pfsense's ipfw may not work without these workarounds\n\t\t\t\t\t\tsysctl net.inet.ip.pfil.outbound=ipfw,pf 2>/dev/null\n\t\t\t\t\t\tsysctl net.inet.ip.pfil.inbound=ipfw,pf 2>/dev/null\n\t\t\t\t\t\tsysctl net.inet6.ip6.pfil.outbound=ipfw,pf 2>/dev/null\n\t\t\t\t\t\tsysctl net.inet6.ip6.pfil.inbound=ipfw,pf 2>/dev/null\n\t\t\t\t\t\tpfctl -qd\n\t\t\t\t\t\tpfctl -qe\n\t\t\t\t\t\tpf_restore\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tprogs=\"$progs ipfw\"\n\t\t\t\t;;\n\t\t\tOpenBSD|Darwin)\n\t\t\t\tpf_is_avail || {\n\t\t\t\t\techo pf is not available\n\t\t\t\t\texitp 6\n\t\t\t\t}\n\t\t\t\tpf_save\n\t\t\t\tprogs=\"$progs pfctl\"\n\t\t\t\t;;\n\t\tesac\n\t}\n\n\tcase \"$UNAME\" in\n\t\tCYGWIN)\n\t\t\tSKIP_TPWS=1\n\t\t\t;;\n\tesac\n\n\tfor prog in $progs; do\n\t\texists $prog || {\n\t\t\techo $prog does not exist. please install\n\t\t\texitp 6\n\t\t}\n\tdone\n\n\tif exists nslookup; then\n\t\tLOOKUP=nslookup\n\telif exists host; then\n\t\tLOOKUP=host\n\telse\n\t\techo nslookup or host does not exist. please install\n\t\texitp 6\n\tfi\n}\n\n\ncurl_translate_code()\n{\n\t# $1 - code\n\tprintf $1\n\tcase $1 in\n\t\t0) printf \": ok\"\n\t\t;;\n\t\t1) printf \": unsupported protocol\"\n\t\t;;\n\t\t2) printf \": early initialization code failed\"\n\t\t;;\n\t\t3) printf \": the URL was not properly formatted\"\n\t\t;;\n\t\t4) printf \": feature not supported by libcurl\"\n\t\t;;\n\t\t5) printf \": could not resolve proxy\"\n\t\t;;\n\t\t6) printf \": could not resolve host\"\n\t\t;;\n\t\t7) printf \": could not connect\"\n\t\t;;\n\t\t8) printf \": invalid server reply\"\n\t\t;;\n\t\t9) printf \": remote access denied\"\n\t\t;;\n\t\t27) printf \": out of memory\"\n\t\t;;\n\t\t28) printf \": operation timed out\"\n\t\t;;\n\t\t35) printf \": SSL connect error\"\n\t\t;;\n\tesac\n}\ncurl_supports_tls13()\n{\n\tlocal r\n\t$CURL --tlsv1.3 -Is -o /dev/null --max-time 1 http://127.0.0.1:65535 2>/dev/null\n\t# return code 2 = init failed. likely bad command line options\n\t[ $? = 2 ] && return 1\n\t# curl can have tlsv1.3 key present but ssl library without TLS 1.3 support\n\t# this is online test because there's no other way to trigger library incompatibility case\n\t$CURL --tlsv1.3 --max-time 1 -Is -o /dev/null https://iana.org 2>/dev/null\n\tr=$?\n\t[ $r != 4 -a $r != 35 ]\n}\n\ncurl_supports_tlsmax()\n{\n\t# supported only in OpenSSL and LibreSSL\n\t$CURL --version | grep -Fq -e OpenSSL -e LibreSSL -e BoringSSL -e GnuTLS -e quictls || return 1\n\t# supported since curl 7.54\n\t$CURL --tls-max 1.2 -Is -o /dev/null --max-time 1 http://127.0.0.1:65535 2>/dev/null\n\t# return code 2 = init failed. likely bad command line options\n\t[ $? != 2 ]\n}\n\ncurl_supports_connect_to()\n{\n\t$CURL --connect-to 127.0.0.1:: -o /dev/null --max-time 1 http://127.0.0.1:65535 2>/dev/null\n\t[ \"$?\" != 2 ]\n}\n\ncurl_supports_http3()\n{\n\t# if it has http3 : curl: (3) HTTP/3 requested for non-HTTPS URL\n\t# otherwise : curl: (2) option --http3-only: is unknown\n\t$CURL --connect-to 127.0.0.1:: -o /dev/null --max-time 1 --http3-only http://127.0.0.1:65535 2>/dev/null\n\t[ \"$?\" != 2 ]\n}\n\nhdrfile_http_code()\n{\n\t# $1 - hdr file\n\tsed -nre '1,1 s/^HTTP\\/1\\.[0,1] ([0-9]+) .*$/\\1/p' \"$1\"\n}\nhdrfile_location()\n{\n\t# $1 - hdr file\n\n\t# some DPIs return CRLF line ending\n\ttr -d '\\015' <\"$1\" | sed -nre 's/^[Ll][Oo][Cc][Aa][Tt][Ii][Oo][Nn]:[ \t]*([^ \t]*)[ \t]*$/\\1/p'\n}\n\ncurl_with_subst_ip()\n{\n\t# $1 - domain\n\t# $2 - port\n\t# $3 - ip\n\t# $4+ - curl params\n\tlocal connect_to=\"--connect-to $1::[$3]${2:+:$2}\" arg\n\tshift ; shift ; shift\n\t[ \"$CURL_VERBOSE\" = 1 ] && arg=\"-v\"\n\t[ \"$CURL_CMD\" = 1 ] && echo $CURL ${arg:+$arg }$connect_to \"$@\"\n\tALL_PROXY=\"$ALL_PROXY\" $CURL ${arg:+$arg }$connect_to \"$@\"\n}\ncurl_with_dig()\n{\n\t# $1 - ip version : 4/6\n\t# $2 - domain name\n\t# $3 - port\n\t# $4+ - curl params\n\tlocal dom=$2 port=$3\n\tlocal ip=$(mdig_resolve $1 $dom)\n\tshift ; shift ; shift\n\tif [ -n \"$ip\" ]; then\n\t\tcurl_with_subst_ip $dom $port $ip \"$@\"\n\telse\n\t\treturn 6\n\tfi\n}\ncurl_probe()\n{\n\t# $1 - ip version : 4/6\n\t# $2 - domain name\n\t# $3 - port\n\t# $4 - subst ip\n\t# $5+ - curl params\n\tlocal ipv=$1 dom=$2 port=$3 subst=$4\n\tshift; shift; shift; shift\n\tif [ -n \"$subst\" ]; then\n\t\tcurl_with_subst_ip $dom $port $subst \"$@\"\n\telse\n\t\tcurl_with_dig $ipv $dom $port \"$@\"\n\tfi\n}\ncurl_test_http()\n{\n\t# $1 - ip version : 4/6\n\t# $2 - domain name\n\t# $3 - subst ip\n\t# $4 - \"detail\" - detail info\n\n\tlocal code loc hdrt=\"${HDRTEMP}_${!:-$$}.txt\"\n\tcurl_probe $1 $2 $HTTP_PORT \"$3\" -SsD \"$hdrt\" -A \"$USER_AGENT\" --max-time $CURL_MAX_TIME $CURL_OPT \"http://$2\" -o /dev/null 2>&1 || {\n\t\tcode=$?\n\t\trm -f \"$hdrt\"\n\t\treturn $code\n\t}\n\tif [ \"$4\" = \"detail\" ] ; then\n\t\thead -n 1 \"$hdrt\"\n\t\tgrep \"^[lL]ocation:\" \"$hdrt\"\n\telse\n\t\tcode=$(hdrfile_http_code \"$hdrt\")\n\t\t[ \"$code\" = 301 -o \"$code\" = 302 -o \"$code\" = 307 -o \"$code\" = 308 ] && {\n\t\t\tloc=$(hdrfile_location \"$hdrt\")\n\t\t\techo \"$loc\" | grep -qE \"^https?://.*$2(/|$)\" ||\n\t\t\techo \"$loc\" | grep -vqE '^https?://' || {\n\t\t\t\techo suspicious redirection $code to : $loc\n\t\t\t\trm -f \"$hdrt\"\n\t\t\t\treturn 254\n\t\t\t}\n\t\t}\n\tfi\n\trm -f \"$hdrt\"\n\t[ \"$code\" = 400 ] && {\n\t\t# this can often happen if the server receives fake packets it should not receive\n\t\techo http code $code. likely the server receives fakes.\n\t\treturn 254\n\t}\n\treturn 0\n}\ncurl_test_https_tls12()\n{\n\t# $1 - ip version : 4/6\n\t# $2 - domain name\n\t# $3 - subst ip\n\n\t# do not use tls 1.3 to make sure server certificate is not encrypted\n\tcurl_probe $1 $2 $HTTPS_PORT \"$3\" -ISs -A \"$USER_AGENT\" --max-time $CURL_MAX_TIME $CURL_OPT --tlsv1.2 $TLSMAX12 \"https://$2\" -o /dev/null 2>&1\n}\ncurl_test_https_tls13()\n{\n\t# $1 - ip version : 4/6\n\t# $2 - domain name\n\t# $3 - subst ip\n\n\t# force TLS1.3 mode\n\tcurl_probe $1 $2 $HTTPS_PORT \"$3\" -ISs -A \"$USER_AGENT\" --max-time $CURL_MAX_TIME $CURL_OPT --tlsv1.3 $TLSMAX13 \"https://$2\" -o /dev/null 2>&1\n}\n\ncurl_test_http3()\n{\n\t# $1 - ip version : 4/6\n\t# $2 - domain name\n\n\t# force QUIC only mode without tcp\n\tcurl_with_dig $1 $2 $QUIC_PORT -ISs -A \"$USER_AGENT\" --max-time $CURL_MAX_TIME_QUIC --http3-only $CURL_OPT \"https://$2\" -o /dev/null 2>&1\n}\n\nipt_aux_scheme()\n{\n\t# $1 - 1 - add , 0 - del\n\t# $2 - tcp/udp\n\t# $3 - port\n\n\t# to avoid possible INVALID state drop\n\t[ \"$2\" = tcp ] && IPT_ADD_DEL $1 INPUT -p $2 --sport $3 ! --syn -j ACCEPT\n\t# for strategies with incoming packets involved (autottl)\n\tIPT_ADD_DEL $1 OUTPUT -p $2 --dport $3 -m conntrack --ctstate INVALID -j ACCEPT\n\tif [ \"$IPV\" = 6 -a -n \"$IP6_DEFRAG_DISABLE\" ]; then\n\t\t# the only way to reliable disable ipv6 defrag. works only in 4.16+ kernels\n\t\tIPT_ADD_DEL $1 OUTPUT -t raw -p $2 -m frag -j CT --notrack\n\telif [ \"$IPV\" = 4 ]; then\n\t\t# enable fragments\n\t\tIPT_ADD_DEL $1 OUTPUT -f -j ACCEPT\n\tfi\n\t# enable everything generated by nfqws (works only in OUTPUT, not in FORWARD)\n\t# raw table may not be present\n\tIPT_ADD_DEL $1 OUTPUT -t raw -m mark --mark $DESYNC_MARK/$DESYNC_MARK -j CT --notrack\n}\nipt_scheme()\n{\n\t# $1 - tcp/udp\n\t# $2 - port\n\t# $3 - ip list\n\n\tlocal ip\n\n\t$IPTABLES -t mangle -N blockcheck_output 2>/dev/null\n\t$IPTABLES -t mangle -F blockcheck_output\n\tIPT OUTPUT -t mangle -j blockcheck_output\n\n\t# prevent loop\n\t$IPTABLES -t mangle -A blockcheck_output -m mark --mark $DESYNC_MARK/$DESYNC_MARK -j RETURN\n\t$IPTABLES -t mangle -A blockcheck_output ! -p $1 -j RETURN\n\t$IPTABLES -t mangle -A blockcheck_output -p $1 ! --dport $2 -j RETURN\n\n\tfor ip in $3; do\n\t\t$IPTABLES -t mangle -A blockcheck_output -d $ip -j NFQUEUE --queue-num $QNUM\n\tdone\n\n\tipt_aux_scheme 1 $1 $2\n}\nnft_scheme()\n{\n\t# $1 - tcp/udp\n\t# $2 - port\n\t# $3 - ip list\n\n\tlocal iplist ipver=$IPV\n\t[ \"$IPV\" = 6 ] || ipver=\n\tmake_comma_list iplist $3\n\n\tnft add table inet $NFT_TABLE\n\tnft \"add chain inet $NFT_TABLE postnat { type filter hook output priority 102; }\"\n\tnft \"add rule inet $NFT_TABLE postnat meta nfproto ipv${IPV} $1 dport $2 mark and $DESYNC_MARK != $DESYNC_MARK ip${ipver} daddr {$iplist} queue num $QNUM\"\n\t# for strategies with incoming packets involved (autottl)\n\tnft \"add chain inet $NFT_TABLE prenat { type filter hook prerouting priority -102; }\"\n\t# enable everything generated by nfqws (works only in OUTPUT, not in FORWARD)\n\tnft \"add chain inet $NFT_TABLE predefrag { type filter hook output priority -402; }\"\n\tnft \"add rule inet $NFT_TABLE predefrag meta nfproto ipv${IPV} mark and $DESYNC_MARK !=0 notrack\"\n}\n\npktws_ipt_prepare()\n{\n\t# $1 - tcp/udp\n\t# $2 - port\n\t# $3 - ip list\n\n\tlocal ip\n\n\tcase \"$FWTYPE\" in\n\t\tiptables)\n\t\t\tipt_scheme $1 $2 \"$3\"\n\t\t\t;;\n\t\tnftables)\n\t\t\tnft_scheme $1 $2 \"$3\"\n\t\t\t;;\n\t\tipfw)\n\t\t\t# disable PF to avoid interferences\n\t\t\tpf_is_avail && pfctl -qd\n\t\t\tfor ip in $3; do\n\t\t\t\tIPFW_ADD divert $IPFW_DIVERT_PORT $1 from me to $ip $2 proto ip${IPV} out not diverted\n\t\t\tdone\n\t\t\t;;\n\t\topf)\n\t\t\topf_prepare_dvtws $1 $2 \"$3\"\n\t\t\t;;\n\t\twindivert)\n\t\t\tWF=\"--wf-l3=ipv${IPV} --wf-${1}=$2\"\n\t\t\trm -f \"$IPSET_FILE\"\n\t\t\tfor ip in $3; do\n\t\t\t\techo $ip >>\"$IPSET_FILE\"\n\t\t\tdone\n\t\t\t;;\n\n\tesac\n}\npktws_ipt_unprepare()\n{\n\t# $1 - tcp/udp\n\t# $2 - port\n\n\tcase \"$FWTYPE\" in\n\t\tiptables)\n\t\t\tipt_aux_scheme 0 $1 $2\n\t\t\tIPT_DEL OUTPUT -t mangle -j blockcheck_output\n\t\t\t$IPTABLES -t mangle -F blockcheck_output 2>/dev/null\n\t\t\t$IPTABLES -t mangle -X blockcheck_output 2>/dev/null\n\t\t\t;;\n\t\tnftables)\n\t\t\tnft delete table inet $NFT_TABLE 2>/dev/null\n\t\t\t;;\n\t\tipfw)\n\t\t\tIPFW_DEL\n\t\t\tpf_is_avail && pf_restore\n\t\t\t;;\n\t\topf)\n\t\t\tpf_restore\n\t\t\t;;\n\t\twindivert)\n\t\t\tunset WF\n\t\t\trm -f \"$IPSET_FILE\"\n\t\t\t;;\n\tesac\n}\n\npktws_ipt_prepare_tcp()\n{\n\t# $1 - port\n\t# $2 - ip list\n\n\tlocal ip iplist ipver\n\n\tpktws_ipt_prepare tcp $1 \"$2\"\n\n\t# for autottl mode\n\tcase \"$FWTYPE\" in\n\t\tiptables)\n\t\t\t$IPTABLES -N blockcheck_input -t mangle 2>/dev/null\n\t\t\t$IPTABLES -F blockcheck_input -t mangle 2>/dev/null\n\t\t\tIPT INPUT -t mangle -j blockcheck_input\n\t\t\t$IPTABLES -t mangle -A blockcheck_input ! -p tcp -j RETURN\n\t\t\t$IPTABLES -t mangle -A blockcheck_input -p tcp ! --sport $1 -j RETURN\n\t\t\t$IPTABLES -t mangle -A blockcheck_input -p tcp ! --tcp-flags SYN,ACK SYN,ACK -j RETURN\n\t\t\tfor ip in $2; do\n\t\t\t\t$IPTABLES -A blockcheck_input -t mangle -s $ip -j NFQUEUE --queue-num $QNUM\n\t\t\tdone\n\t\t\t;;\n\t\tnftables)\n\t\t\tipver=$IPV\n\t\t\t[ \"$IPV\" = 6 ] || ipver=\n\t\t\tmake_comma_list iplist $2\n\t\t\tnft \"add rule inet $NFT_TABLE prenat meta nfproto ipv${IPV} tcp sport $1 tcp flags & (syn | ack) == (syn | ack) ip${ipver} saddr {$iplist} queue num $QNUM\"\n\t\t\t;;\n\t\tipfw)\n\t\t\tfor ip in $2; do\n\t\t\t\tIPFW_ADD divert $IPFW_DIVERT_PORT tcp from $ip $1 to me proto ip${IPV} tcpflags syn,ack in not diverted\n\t\t\tdone\n\t\t\t;;\n\tesac\n}\npktws_ipt_unprepare_tcp()\n{\n\t# $1 - port\n\t\n\tpktws_ipt_unprepare tcp $1\n\n\tcase \"$FWTYPE\" in\n\t\tiptables)\n\t\t\tIPT_DEL INPUT -t mangle -j blockcheck_input\n\t\t\t$IPTABLES -t mangle -F blockcheck_input 2>/dev/null\n\t\t\t$IPTABLES -t mangle -X blockcheck_input 2>/dev/null\n\t\t\t;;\n\tesac\n}\npktws_ipt_prepare_udp()\n{\n\t# $1 - port\n\t# $2 - ip list\n\n\tpktws_ipt_prepare udp $1 \"$2\"\n}\npktws_ipt_unprepare_udp()\n{\n\t# $1 - port\n\t\n\tpktws_ipt_unprepare udp $1\n}\n\npktws_start()\n{\n\tcase \"$UNAME\" in\n\t\tLinux)\n\t\t\t\"$NFQWS\" --uid $TPWS_UID:$TPWS_GID --dpi-desync-fwmark=$DESYNC_MARK --qnum=$QNUM \"$@\" >/dev/null &\n\t\t\t;;\n\t\tFreeBSD|OpenBSD)\n\t\t\t\"$DVTWS\" --port=$IPFW_DIVERT_PORT \"$@\" >/dev/null &\n\t\t\t;;\n\t\tCYGWIN)\n\t\t\t\"$WINWS\" $WF --ipset=\"$IPSET_FILE\" \"$@\" >/dev/null &\n\t\t\t;;\n\tesac\n\tPID=$!\n\t# give some time to initialize\n\tminsleep\n}\ntpws_start()\n{\n\tlocal uid\n\t[ -n \"$HAVE_ROOT\" ] && uid=\"--uid $TPWS_UID:$TPWS_GID\"\n\t\"$TPWS\" $uid --socks --bind-addr=127.0.0.1 --port=$SOCKS_PORT \"$@\" >/dev/null &\n\tPID=$!\n\t# give some time to initialize\n\tminsleep\n}\nws_kill()\n{\n\t[ -z \"$PID\" ] || {\n\t\tkillwait -9 $PID 2>/dev/null\n\t\tPID=\n\t}\n}\n\ncheck_domain_port_block()\n{\n\t# $1 - domain\n\t# $2 - port\n\tlocal ip ips\n\techo\n\techo \\* port block tests ipv$IPV $1:$2\n\tif netcat_setup; then\n\t\tips=$(mdig_resolve_all $IPV $1)\n\t\tif [ -n \"$ips\" ]; then\n\t\t\tfor ip in $ips; do\n\t\t\t\tif netcat_test $ip $2; then\n\t\t\t\t\techo $ip connects\n\t\t\t\telse\n\t\t\t\t\techo $ip does not connect. netcat code $?\n\t\t\t\tfi\n\t\t\tdone\n\t\telse\n\t\t\techo \"ipv${IPV} $1 does not resolve\"\n\t\tfi\n\telse\n\t\techo suitable netcat not found. busybox nc is not supported. pls install nmap ncat or openbsd netcat.\n\tfi\n}\n\ncurl_test()\n{\n\t# $1 - test function\n\t# $2 - domain\n\t# $3 - subst ip\n\t# $4 - param of test function\n\tlocal code=0 n=0 p pids\n\n\tif [ \"$PARALLEL\" = 1 ]; then\n\t\trm -f \"${PARALLEL_OUT}\"*\n\t\tfor n in $(seq -s ' ' 1 $REPEATS); do\n\t\t\t$1 \"$IPV\" $2 $3 \"$4\" >\"${PARALLEL_OUT}_$n\" &\n\t\t\tpids=\"${pids:+$pids }$!\"\n\t\tdone\n\t\tn=1\n\t\tfor p in $pids; do\n\t\t\t[ $REPEATS -gt 1 ] && printf \"[attempt $n] \"\n\t\t\tif wait $p; then\n\t\t\t\t[ $REPEATS -gt 1 ] && echo 'AVAILABLE'\n\t\t\telse\n\t\t\t\tcode=$?\n\t\t\t\tcat \"${PARALLEL_OUT}_$n\"\n\t\t\tfi\n\t\t\tn=$(($n+1))\n\t\tdone\n\t\trm -f \"${PARALLEL_OUT}\"*\n\telse\n\t\twhile [ $n -lt $REPEATS ]; do\n\t\t\tn=$(($n+1))\n\t\t\t[ $REPEATS -gt 1 ] && printf \"[attempt $n] \"\n\t\t\tif $1 \"$IPV\" $2 $3 \"$4\" ; then\n\t\t\t\t[ $REPEATS -gt 1 ] && echo 'AVAILABLE'\n\t\t\telse\n\t\t\t\tcode=$?\n\t\t\t\t[ \"$SCANLEVEL\" = quick ] && break\n\t\t\tfi\n\t\tdone\n\tfi\n\t[ \"$4\" = detail ] || {\n\t\tif [ $code = 254 ]; then\n\t\t\techo \"UNAVAILABLE\"\n\t\telif [ $code = 0 ]; then\n\t\t\techo '!!!!! AVAILABLE !!!!!'\n\t\telse\n\t\t\techo \"UNAVAILABLE code=$code\"\n\t\tfi\n\t}\n\treturn $code\n}\nws_curl_test()\n{\n\t# $1 - ws start function\n\t# $2 - test function\n\t# $3 - domain\n\t# $4,$5,$6, ... - ws params\n\tlocal code ws_start=$1 testf=$2 dom=$3\n\tshift\n\tshift\n\tshift\n\t$ws_start \"$@\"\n\tcurl_test $testf $dom\n\tcode=$?\n\tws_kill\n\treturn $code\n}\ntpws_curl_test()\n{\n\t# $1 - test function\n\t# $2 - domain\n\t# $3,$4,$5, ... - tpws params\n\techo - checking tpws $3 $4 $5 $6 $7 $8 $9${TPWS_EXTRA:+ $TPWS_EXTRA}${TPWS_EXTRA_1:+ \"$TPWS_EXTRA_1\"}${TPWS_EXTRA_2:+ \"$TPWS_EXTRA_2\"}${TPWS_EXTRA_3:+ \"$TPWS_EXTRA_3\"}${TPWS_EXTRA_4:+ \"$TPWS_EXTRA_4\"}${TPWS_EXTRA_5:+ \"$TPWS_EXTRA_5\"}${TPWS_EXTRA_6:+ \"$TPWS_EXTRA_6\"}${TPWS_EXTRA_7:+ \"$TPWS_EXTRA_7\"}${TPWS_EXTRA_8:+ \"$TPWS_EXTRA_8\"}${TPWS_EXTRA_9:+ \"$TPWS_EXTRA_9\"}\n\tlocal ALL_PROXY=\"socks5://127.0.0.1:$SOCKS_PORT\"\n\tws_curl_test tpws_start \"$@\"${TPWS_EXTRA:+ $TPWS_EXTRA}${TPWS_EXTRA_1:+ \"$TPWS_EXTRA_1\"}${TPWS_EXTRA_2:+ \"$TPWS_EXTRA_2\"}${TPWS_EXTRA_3:+ \"$TPWS_EXTRA_3\"}${TPWS_EXTRA_4:+ \"$TPWS_EXTRA_4\"}${TPWS_EXTRA_5:+ \"$TPWS_EXTRA_5\"}${TPWS_EXTRA_6:+ \"$TPWS_EXTRA_6\"}${TPWS_EXTRA_7:+ \"$TPWS_EXTRA_7\"}${TPWS_EXTRA_8:+ \"$TPWS_EXTRA_8\"}${TPWS_EXTRA_9:+ \"$TPWS_EXTRA_9\"}\n\tlocal testf=$1 dom=$2 strategy code=$?\n\t[ \"$code\" = 0 ] && {\n\t\tshift; shift;\n\t\tstrategy=\"$@\"\n\t\tstrategy_append_extra_tpws\n\t\treport_append \"ipv${IPV} $dom $testf : tpws ${WF:+$WF }$strategy\"\n\t}\n\treturn $code\n}\npktws_curl_test()\n{\n\t# $1 - test function\n\t# $2 - domain\n\t# $3,$4,$5, ... - nfqws/dvtws params\n\techo - checking $PKTWSD ${WF:+$WF }$3 $4 $5 $6 $7 $8 $9${PKTWS_EXTRA:+ $PKTWS_EXTRA}${PKTWS_EXTRA_1:+ \"$PKTWS_EXTRA_1\"}${PKTWS_EXTRA_2:+ \"$PKTWS_EXTRA_2\"}${PKTWS_EXTRA_3:+ \"$PKTWS_EXTRA_3\"}${PKTWS_EXTRA_4:+ \"$PKTWS_EXTRA_4\"}${PKTWS_EXTRA_5:+ \"$PKTWS_EXTRA_5\"}${PKTWS_EXTRA_6:+ \"$PKTWS_EXTRA_6\"}${PKTWS_EXTRA_7:+ \"$PKTWS_EXTRA_7\"}${PKTWS_EXTRA_8:+ \"$PKTWS_EXTRA_8\"}${PKTWS_EXTRA_9:+ \"$PKTWS_EXTRA_9\"}\n\tws_curl_test pktws_start \"$@\"${PKTWS_EXTRA:+ $PKTWS_EXTRA}${PKTWS_EXTRA_1:+ \"$PKTWS_EXTRA_1\"}${PKTWS_EXTRA_2:+ \"$PKTWS_EXTRA_2\"}${PKTWS_EXTRA_3:+ \"$PKTWS_EXTRA_3\"}${PKTWS_EXTRA_4:+ \"$PKTWS_EXTRA_4\"}${PKTWS_EXTRA_5:+ \"$PKTWS_EXTRA_5\"}${PKTWS_EXTRA_6:+ \"$PKTWS_EXTRA_6\"}${PKTWS_EXTRA_7:+ \"$PKTWS_EXTRA_7\"}${PKTWS_EXTRA_8:+ \"$PKTWS_EXTRA_8\"}${PKTWS_EXTRA_9:+ \"$PKTWS_EXTRA_9\"}\n\tlocal testf=$1 dom=$2 strategy code=$?\n\t[ \"$code\" = 0 ] && {\n\t\tshift; shift;\n\t\tstrategy=\"$@\"\n\t\tstrategy_append_extra_pktws\n\t\treport_append \"ipv${IPV} $dom $testf : $PKTWSD ${WF:+$WF }$strategy\"\n\t}\n\treturn $code\n}\n\nstrategy_append_extra_pktws()\n{\n\tstrategy=\"${strategy:+$strategy${PKTWS_EXTRA:+ $PKTWS_EXTRA}${PKTWS_EXTRA_1:+ \"$PKTWS_EXTRA_1\"}${PKTWS_EXTRA_2:+ \"$PKTWS_EXTRA_2\"}${PKTWS_EXTRA_3:+ \"$PKTWS_EXTRA_3\"}${PKTWS_EXTRA_4:+ \"$PKTWS_EXTRA_4\"}${PKTWS_EXTRA_5:+ \"$PKTWS_EXTRA_5\"}${PKTWS_EXTRA_6:+ \"$PKTWS_EXTRA_6\"}${PKTWS_EXTRA_7:+ \"$PKTWS_EXTRA_7\"}${PKTWS_EXTRA_8:+ \"$PKTWS_EXTRA_8\"}${PKTWS_EXTRA_9:+ \"$PKTWS_EXTRA_9\"}}\"\n}\nstrategy_append_extra_tpws()\n{\n\tstrategy=\"${strategy:+$strategy${TPWS_EXTRA:+ $TPWS_EXTRA}${TPWS_EXTRA_1:+ \"$TPWS_EXTRA_1\"}${TPWS_EXTRA_2:+ \"$TPWS_EXTRA_2\"}${TPWS_EXTRA_3:+ \"$TPWS_EXTRA_3\"}${TPWS_EXTRA_4:+ \"$TPWS_EXTRA_4\"}${TPWS_EXTRA_5:+ \"$TPWS_EXTRA_5\"}${TPWS_EXTRA_6:+ \"$TPWS_EXTRA_6\"}${TPWS_EXTRA_7:+ \"$TPWS_EXTRA_7\"}${TPWS_EXTRA_8:+ \"$TPWS_EXTRA_8\"}${TPWS_EXTRA_9:+ \"$TPWS_EXTRA_9\"}}\"\n}\n\nxxxws_curl_test_update()\n{\n\t# $1 - xxx_curl_test function\n\t# $2 - test function\n\t# $3 - domain\n\t# $4,$5,$6, ... - nfqws/dvtws params\n\tlocal code xxxf=$1 testf=$2 dom=$3\n\tshift\n\tshift\n\tshift\n\t$xxxf $testf $dom \"$@\"\n\tcode=$?\n\t[ $code = 0 ] && strategy=\"${strategy:-$@}\"\n\treturn $code\n}\npktws_curl_test_update()\n{\n\txxxws_curl_test_update pktws_curl_test \"$@\"\n}\ntpws_curl_test_update()\n{\n\txxxws_curl_test_update tpws_curl_test \"$@\"\n}\n\nreport_append()\n{\n\tNREPORT=${NREPORT:-0}\n\teval REPORT_${NREPORT}=\\\"$@\\\"\n\tNREPORT=$(($NREPORT+1))\n}\nreport_print()\n{\n\tlocal n=0 s\n\tNREPORT=${NREPORT:-0}\n\twhile [ $n -lt $NREPORT ]; do\n\t\teval s=\\\"\\${REPORT_$n}\\\"\n\t\techo $s\n\t\tn=$(($n+1))\n\tdone\n}\nreport_strategy()\n{\n\t# $1 - test function\n\t# $2 - domain\n\t# $3 - daemon\n\techo\n\tif [ -n \"$strategy\" ]; then\n\t\t# trim spaces at the end\n\t\tstrategy=\"$(echo \"$strategy\" | xargs)\"\n\t\techo \"!!!!! $1: working strategy found for ipv${IPV} $2 : $3 $strategy !!!!!\"\n\t\techo\n#\t\treport_append \"ipv${IPV} $2 $1 : $3 ${WF:+$WF }$strategy\"\n\t\treturn 0\n\telse\n\t\techo \"$1: $3 strategy for ipv${IPV} $2 not found\"\n\t\techo\n\t\treport_append \"ipv${IPV} $2 $1 : $3 not working\"\n\t\treturn 1\n\tfi\n}\ntest_has_split()\n{\n\tcontains \"$1\" split || contains \"$1\" disorder\n}\ntest_has_fakedsplit()\n{\n\tcontains \"$1\" fakedsplit || contains \"$1\" fakeddisorder\n}\ntest_has_fake()\n{\n\t[ \"$1\" = fake ] || starts_with \"$1\" fake,\n}\nwarn_fool()\n{\n\tcase \"$1\" in\n\t\tmd5sig) echo 'WARNING ! although md5sig fooling worked it will not work on all sites. it typically works only on linux servers.' ;;\n\t\tdatanoack) echo 'WARNING ! although datanoack fooling worked it may break NAT and may only work with external IP. Additionally it may require nftables to work correctly.' ;;\n\tesac\n}\npktws_curl_test_update_vary()\n{\n\t# $1 - test function\n\t# $2 - encrypted test : 0 = plain, 1 - encrypted with server reply risk, 2 - encrypted without server reply risk\n\t# $3 - domain\n\t# $4 - desync mode\n\t# $5,$6,... - strategy\n\n\tlocal testf=$1 sec=$2 domain=$3 desync=$4 proto zerofake= splits= pos fake ret=1\n\t\n\tshift; shift; shift; shift\n\t\n\tproto=http\n\t[ \"$sec\" = 0 ] || proto=tls\n\ttest_has_fake $desync && zerofake=\"--dpi-desync-fake-$proto=0x00000000\"\n\tif test_has_fakedsplit $desync ; then\n\t\tsplits=\"method+2 midsld\"\n\t\t[ \"$sec\" = 0 ] || splits=\"1 midsld\"\n\telif test_has_split $desync ; then\n\t\tsplits=\"method+2 midsld\"\n\t\t[ \"$sec\" = 0 ] || splits=\"1 midsld 1,midsld\"\n\tfi\n\tfor fake in '' $zerofake ; do\n\t\tif [ -n \"$splits\" ]; then\n\t\t\tfor pos in $splits ; do\n\t\t\t\tpktws_curl_test_update $testf $domain --dpi-desync=$desync \"$@\" --dpi-desync-split-pos=$pos $fake && {\n\t\t\t\t\t[ \"$SCANLEVEL\" = force ] || return 0\n\t\t\t\t\tret=0\n\t\t\t\t}\n\t\t\tdone\n\t\telse\n\t\t\tpktws_curl_test_update $testf $domain --dpi-desync=$desync \"$@\" $fake && {\n\t\t\t\t[ \"$SCANLEVEL\" = force ] || return 0\n\t\t\t\tret=0\n\t\t\t}\n\t\tfi\n\tdone\n\n\treturn $ret\n}\n\npktws_check_domain_http_bypass_()\n{\n\t# $1 - test function\n\t# $2 - encrypted test : 0 = plain, 1 - encrypted with server reply risk, 2 - encrypted without server reply risk\n\t# $3 - domain\n\n\tlocal ok ttls s f f2 e desync pos fooling frag sec=\"$2\" delta splits\n\tlocal need_split need_disorder need_fakedsplit need_fakeddisorder need_fake need_wssize\n\tlocal splits_http='method+2 midsld method+2,midsld'\n\tlocal splits_tls='2 1 sniext+1 sniext+4 host+1 midsld 1,midsld 1,sniext+1,host+1,midsld-2,midsld,midsld+2,endhost-1'\n\n\t[ \"$sec\" = 0 ] && {\n\t\tfor s in '--hostcase' '--hostspell=hoSt' '--hostnospace' '--domcase' '--methodeol'; do\n\t\t\tpktws_curl_test_update $1 $3 $s\n\t\tdone\n\t}\n\n\tttls=$(seq -s ' ' $MIN_TTL $MAX_TTL)\n\tneed_wssize=1\n\tfor e in '' '--wssize 1:6'; do\n\t\tneed_split=\n\t\tneed_disorder=\n\n\t\t[ -n \"$e\" ] && {\n\t\t\tpktws_curl_test_update $1 $3 $e && [ \"$SCANLEVEL\" = quick ] && return\n\t\t}\n\n\t\tfor desync in multisplit multidisorder; do\n\t\t\tok=0\n\t\t\tsplits=\"$splits_http\"\n\t\t\t[ \"$sec\" = 0 ] || splits=\"$splits_tls\"\n\t\t\tfor pos in $splits; do\n\t\t\t\tpktws_curl_test_update $1 $3 --dpi-desync=$desync --dpi-desync-split-pos=$pos $e && {\n\t\t\t\t\t[ \"$SCANLEVEL\" = quick ] && return\n\t\t\t\t\tok=1\n\t\t\t\t\tneed_wssize=0\n\t\t\t\t\t[ \"$SCANLEVEL\" = force ] || break\n\t\t\t\t}\n\t\t\tdone\n\t\t\t[ \"$ok\" = 1 -a \"$SCANLEVEL\" != force ] || {\n\t\t\t\tcase $desync in\n\t\t\t\t\tmultisplit)\n\t\t\t\t\t\tneed_split=1\n\t\t\t\t\t\t;;\n\t\t\t\t\tmultidisorder)\n\t\t\t\t\t\tneed_disorder=1\n\t\t\t\t\t\t;;\n\t\t\t\tesac\n\t\t\t}\n\t\tdone\n\n\t\tneed_fakedsplit=1\n\t\tneed_fakeddisorder=1\n\t\tneed_fake=1\n\t\tfor desync in fake ${need_split:+fakedsplit fake,multisplit fake,fakedsplit} ${need_disorder:+fakeddisorder fake,multidisorder fake,fakeddisorder}; do\n\t\t\t[ \"$need_fake\" = 0 ] && test_has_fake \"$desync\" && continue\n\t\t\t[ \"$need_fakedsplit\" = 0 ] && contains \"$desync\" fakedsplit && continue\n\t\t\t[ \"$need_fakeddisorder\" = 0 ] && contains \"$desync\" fakeddisorder && continue\n\t\t\tok=0\n\t\t\tfor ttl in $ttls; do\n\t\t\t\tpktws_curl_test_update_vary $1 $2 $3 $desync --dpi-desync-ttl=$ttl $e && {\n\t\t\t\t\t[ \"$SCANLEVEL\" = quick ] && return\n\t\t\t\t\tok=1\n\t\t\t\t\tneed_wssize=0\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\tdone\n\t\t\t# only skip tests if TTL succeeded. do not skip if TTL failed but fooling succeeded\n\t\t\t[ $ok = 1 -a \"$SCANLEVEL\" != force ] && {\n\t\t\t\t[ \"$desync\" = fake ] && need_fake=0\n\t\t\t\t[ \"$desync\" = fakedsplit ] && need_fakedsplit=0\n\t\t\t\t[ \"$desync\" = fakeddisorder ] && need_fakeddisorder=0\n\t\t\t}\n\t\t\tf=\n\t\t\t[ \"$UNAME\" = \"OpenBSD\" ] || f=\"badsum\"\n\t\t\tf=\"$f badseq datanoack md5sig\"\n\t\t\t[ \"$IPV\" = 6 ] && f=\"$f hopbyhop hopbyhop2\"\n\t\t\tfor fooling in $f; do\n\t\t\t\tpktws_curl_test_update_vary $1 $2 $3 $desync --dpi-desync-fooling=$fooling $e && {\n\t\t\t\t\twarn_fool $fooling\n\t\t\t\t\t[ \"$SCANLEVEL\" = quick ] && return\n\t\t\t\t\tneed_wssize=0\n\t\t\t\t}\n\t\t\tdone\n\t\tdone\n\n\t\t[ \"$IPV\" = 6 ] && {\n\t\t\tf=\"hopbyhop ${need_split:+hopbyhop,multisplit} ${need_disorder:+hopbyhop,multidisorder} destopt ${need_split:+destopt,multisplit} ${need_disorder:+destopt,multidisorder}\"\n\t\t\t[ -n \"$IP6_DEFRAG_DISABLE\" ] && f=\"$f ipfrag1 ${need_split:+ ipfrag1,multisplit} ${need_disorder:+ ipfrag1,multidisorder}\"\n\t\t\tfor desync in $f; do\n\t\t\t\tpktws_curl_test_update_vary $1 $2 $3 $desync $e && {\n\t\t\t\t\t[ \"$SCANLEVEL\" = quick ] && return\n\t\t\t\t\tneed_wssize=0\n\t\t\t\t}\n\t\t\tdone\n\t\t}\n\n\t\t[ \"$need_split\" = 1 ] && {\n\t\t\t# relative markers can be anywhere, even in subsequent packets. first packet can be MTU-full.\n\t\t\t# make additional split pos \"10\" to guarantee enough space for seqovl and likely to be before midsld,sniext,...\n\t\t\t# method is always expected in the beginning of the first packet\n\t\t\tf=\"method+2 method+2,midsld\"\n\t\t\t[ \"$sec\" = 0 ] || f=\"10 10,sniext+1 10,sniext+4 10,midsld\"\n\t\t\tfor pos in $f; do\n\t\t\t\tpktws_curl_test_update $1 $3 --dpi-desync=multisplit --dpi-desync-split-pos=$pos --dpi-desync-split-seqovl=1 $e && {\n\t\t\t\t\t[ \"$SCANLEVEL\" = quick ] && return\n\t\t\t\t\tneed_wssize=0\n\t\t\t\t}\n\t\t\tdone\n\t\t\t[ \"$sec\" != 0 ] && pktws_curl_test_update $1 $3 --dpi-desync=multisplit --dpi-desync-split-pos=2 --dpi-desync-split-seqovl=336 --dpi-desync-split-seqovl-pattern=\"$ZAPRET_BASE/files/fake/tls_clienthello_iana_org.bin\" $e && {\n\t\t\t\t[ \"$SCANLEVEL\" = quick ] && return\n\t\t\t\tneed_wssize=0\n\t\t\t}\n\t\t}\n\t\t[ \"$need_disorder\" = 1 ] && {\n\t\t\tif [ \"$sec\" = 0 ]; then\n\t\t\t\tfor pos in 'method+1 method+2' 'midsld-1 midsld' 'method+1 method+2,midsld'; do\n\t\t\t\t\tf=\"$(extract_arg 1 $pos)\"\n\t\t\t\t\tf2=\"$(extract_arg 2 $pos)\"\n\t\t\t\t\tpktws_curl_test_update $1 $3 --dpi-desync=multidisorder --dpi-desync-split-pos=$f2 --dpi-desync-split-seqovl=$f $e && {\n\t\t\t\t\t\t[ \"$SCANLEVEL\" = quick ] && return\n\t\t\t\t\t\tneed_wssize=0\n\t\t\t\t\t}\n\t\t\t\tdone\n\t\t\telse\n\t\t\t\tfor pos in '1 2' 'sniext sniext+1' 'sniext+3 sniext+4' 'midsld-1 midsld' '1 2,midsld'; do\n\t\t\t\t\tf=$(extract_arg 1 $pos)\n\t\t\t\t\tf2=$(extract_arg 2 $pos)\n\t\t\t\t\tpktws_curl_test_update $1 $3 --dpi-desync=multidisorder --dpi-desync-split-pos=$f2 --dpi-desync-split-seqovl=$f $e && {\n\t\t\t\t\t\t[ \"$SCANLEVEL\" = quick ] && return\n\t\t\t\t\t\tneed_wssize=0\n\t\t\t\t\t}\n\t\t\t\tdone\n\t\t\tfi\n\t\t}\n\n\t\tneed_fakedsplit=1\n\t\tneed_fakeddisorder=1\n\t\tneed_fake=1\n\t\tfor desync in fake ${need_split:+fakedsplit fake,multisplit fake,fakedsplit} ${need_disorder:+fakeddisorder fake,multidisorder fake,fakeddisorder}; do\n\t\t\t[ \"$need_fake\" = 0 ] && test_has_fake \"$desync\" && continue\n\t\t\t[ \"$need_fakedsplit\" = 0 ] && contains \"$desync\" fakedsplit && continue\n\t\t\t[ \"$need_fakeddisorder\" = 0 ] && contains \"$desync\" fakeddisorder && continue\n\t\t\tok=0\n\t\t\tfor delta in 1 2 3 4 5; do\n\t\t\t\tpktws_curl_test_update_vary $1 $2 $3 $desync --dpi-desync-ttl=1 --dpi-desync-autottl=$delta $e && ok=1\n\t\t\tdone\n\t\t\t[ \"$ok\" = 1 ] &&\n\t\t\t{\n\t\t\t\techo \"WARNING ! although autottl worked it requires testing on multiple domains to find out reliable delta\"\n\t\t\t\techo \"WARNING ! if a reliable delta cannot be found it's a good idea not to use autottl\"\n\t\t\t\t[ \"$SCANLEVEL\" = quick ] && return\n\t\t\t\tneed_wssize=0\n\t\t\t\t[ \"$SCANLEVEL\" = force ] || {\n\t\t\t\t\t[ \"$desync\" = fake ] && need_fake=0\n\t\t\t\t\t[ \"$desync\" = fakedsplit ] && need_fakedsplit=0\n\t\t\t\t\t[ \"$desync\" = fakeddisorder ] && need_fakeddisorder=0\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\tdone\n\n\t\ts=\"http_iana_org.bin\"\n\t\t[ \"$sec\" = 0 ] || s=\"tls_clienthello_iana_org.bin\"\n\t\tfor desync in syndata ${need_split:+syndata,multisplit} ${need_disorder:+syndata,multidisorder} ; do\n\t\t\tpktws_curl_test_update_vary $1 $2 $3 $desync $e && [ \"$SCANLEVEL\" = quick ] && return\n\t\t\tpktws_curl_test_update_vary $1 $2 $3 $desync --dpi-desync-fake-syndata=\"$ZAPRET_BASE/files/fake/$s\" $e && [ \"$SCANLEVEL\" = quick ] && return\n\t\tdone\n\n\t\t# do not do wssize test for http and TLS 1.3. it's useless\n\t\t[ \"$sec\" = 1 ] || break\n\t\t[ \"$SCANLEVEL\" = force -o \"$need_wssize\" = 1 ] || break\n\tdone\n}\npktws_check_domain_http_bypass()\n{\n\t# $1 - test function\n\t# $2 - encrypted test : 0 = plain, 1 - encrypted with server reply risk, 2 - encrypted without server reply risk\n\t# $3 - domain\n\n\tlocal strategy\n\tpktws_check_domain_http_bypass_ \"$@\"\n\tstrategy_append_extra_pktws\n\treport_strategy $1 $3 $PKTWSD\n}\n\npktws_check_domain_http3_bypass_()\n{\n\t# $1 - test function\n\t# $2 - domain\n\n\tlocal f desync frag tests rep\n\n\tfor rep in '' 2 5 10 20; do\n\t\tpktws_curl_test_update $1 $2 --dpi-desync=fake ${rep:+--dpi-desync-repeats=$rep} && [ \"$SCANLEVEL\" != force ] && {\n\t\t\t[ \"$SCANLEVEL\" = quick ] && return\n\t\t\tbreak\n\t\t}\n\tdone\n\n\t[ \"$IPV\" = 6 ] && {\n\t\tf=\"hopbyhop destopt\"\n\t\t[ -n \"$IP6_DEFRAG_DISABLE\" ] && f=\"$f ipfrag1\"\n\t\tfor desync in $f; do\n\t\t\tpktws_curl_test_update $1 $2 --dpi-desync=$desync && [ \"$SCANLEVEL\" = quick ] && return\n\t\tdone\n\t}\n\n\t# OpenBSD has checksum issues with fragmented packets\n\t[ \"$UNAME\" != \"OpenBSD\" ] && [ \"$IPV\" = 4 -o -n \"$IP6_DEFRAG_DISABLE\" ] && {\n\t\tfor frag in 8 16 24 32 40 64; do\n\t\t\ttests=\"ipfrag2\"\n\t\t\t[ \"$IPV\" = 6 ] && tests=\"$tests hopbyhop,ipfrag2 destopt,ipfrag2\"\n\t\t\tfor desync in $tests; do\n\t\t\t\tpktws_curl_test_update $1 $2 --dpi-desync=$desync --dpi-desync-ipfrag-pos-udp=$frag && [ \"$SCANLEVEL\" = quick ] && return\n\t\t\tdone\n\t\tdone\n\t}\n\t\n}\npktws_check_domain_http3_bypass()\n{\n\t# $1 - test function\n\t# $2 - domain\n\n\tlocal strategy\n\tpktws_check_domain_http3_bypass_ \"$@\"\n\tstrategy_append_extra_pktws\n\treport_strategy $1 $2 $PKTWSD\n}\nwarn_mss()\n{\n\t[ -n \"$1\" ] && echo 'WARNING ! although mss worked it may not work on all sites and will likely cause significant slowdown. it may only be required for TLS1.2, not TLS1.3'\n\treturn 0\n}\n\ntpws_check_domain_http_bypass_()\n{\n\t# $1 - test function\n\t# $2 - encrypted test : 0 = plain, 1 - encrypted with server reply risk, 2 - encrypted without server reply risk\n\t# $3 - domain\n\n\tlocal s mss s2 s3 oobdis pos sec=\"$2\"\n\tlocal splits_tls='2 1 sniext+1 sniext+4 host+1 midsld 1,midsld 1,sniext+1,host+1,midsld,endhost-1'\n\tlocal splits_http='method+2 midsld method+2,midsld'\n\n\t# simulteneous oob and disorder works properly only in linux. other systems retransmit oob byte without URG tcp flag and poison tcp stream.\n\t[ \"$UNAME\" = Linux ] && oobdis='--oob --disorder'\n\tif [ \"$sec\" = 0 ]; then\n\t\tfor s in '--hostcase' '--hostspell=hoSt' '--hostdot' '--hosttab' '--hostnospace' '--domcase' ; do\n\t\t\ttpws_curl_test_update $1 $3 $s && [ \"$SCANLEVEL\" = quick ] && return\n\t\tdone\n\t\tfor s in 1024 2048 4096 8192 16384 ; do\n\t\t\ttpws_curl_test_update $1 $3 --hostpad=$s && [ \"$SCANLEVEL\" != force ] && {\n\t\t\t\t[ \"$SCANLEVEL\" = quick ] && return\n\t\t\t\tbreak\n\t\t\t}\n\t\tdone\n\t\tfor s2 in '' '--hostcase' '--oob' '--disorder' ${oobdis:+\"$oobdis\"}; do\n\t\t\tfor s in $splits_http ; do\n\t\t\t\ttpws_curl_test_update $1 $3 --split-pos=$s $s2 && [ \"$SCANLEVEL\" != force ] && {\n\t\t\t\t\t[ \"$SCANLEVEL\" = quick ] && return\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\tdone\n\t\tdone\n\t\tfor s in  '--methodspace' '--unixeol' '--methodeol'; do\n\t\t\ttpws_curl_test_update $1 $3 $s && [ \"$SCANLEVEL\" = quick ] && return\n\t\tdone\n\telse\n\t\tlocal need_mss=1\n\t\tfor mss in '' 88; do\n\t\t\ts3=${mss:+--mss=$mss}\n\t\t\tfor s2 in '' '--oob' '--disorder' ${oobdis:+\"$oobdis\"}; do\n\t\t\t\tfor pos in $splits_tls; do\n\t\t\t\t\ttpws_curl_test_update $1 $3 --split-pos=$pos $s2 $s3 && warn_mss $s3 && [ \"$SCANLEVEL\" != force ] && {\n\t\t\t\t\t\t[ \"$SCANLEVEL\" = quick ] && return\n\t\t\t\t\t\tneed_mss=0\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\tdone\n\t\t\tdone\n\t\t\tfor s in '' '--oob' '--disorder' ${oobdis:+\"$oobdis\"}; do\n\t\t\t\tfor s2 in '--tlsrec=midsld' '--tlsrec=sniext+1 --split-pos=midsld' '--tlsrec=sniext+4 --split-pos=midsld' '--tlsrec=sniext+1 --split-pos=1,midsld' '--tlsrec=sniext+4 --split-pos=1,midsld' ; do\n\t\t\t\t\ttpws_curl_test_update $1 $3 $s2 $s $s3 && warn_mss $s3 && [ \"$SCANLEVEL\" != force ] && {\n\t\t\t\t\t\t[ \"$SCANLEVEL\" = quick ] && return\n\t\t\t\t\t\tneed_mss=0\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\tdone\n\t\t\tdone\n\t\t\t# only linux supports mss\n\t\t\t[ \"$UNAME\" = Linux -a \"$sec\" = 1 ] || break\n\t\t\t[ \"$SCANLEVEL\" = force -o \"$need_mss\" = 1 ] || break\n\t\tdone\n\tfi\n}\ntpws_check_domain_http_bypass()\n{\n\t# $1 - test function\n\t# $2 - encrypted test : 0 = plain, 1 - encrypted with server reply risk, 2 - encrypted without server reply risk\n\t# $3 - domain\n\n\tlocal strategy\n\ttpws_check_domain_http_bypass_ \"$@\"\n\tstrategy_append_extra_tpws\n\treport_strategy $1 $3 tpws\n}\n\ncheck_dpi_ip_block()\n{\n\t# $1 - test function\n\t# $2 - domain\n\n\tlocal blocked_dom=$2\n\tlocal blocked_ip blocked_ips unblocked_ip\n\n\techo \n\techo \"- IP block tests (requires manual interpretation)\"\n\n\techo \"> testing $UNBLOCKED_DOM on it's original ip\"\n\tif curl_test $1 $UNBLOCKED_DOM; then\n\t\tunblocked_ip=$(mdig_resolve $IPV $UNBLOCKED_DOM)\n\t\t[ -n \"$unblocked_ip\" ] || {\n\t\t\techo $UNBLOCKED_DOM does not resolve. tests not possible.\n\t\t\treturn 1\n\t\t}\n\n\t\techo \"> testing $blocked_dom on $unblocked_ip ($UNBLOCKED_DOM)\"\n\t\tcurl_test $1 $blocked_dom $unblocked_ip detail\n\n\t\tblocked_ips=$(mdig_resolve_all $IPV $blocked_dom)\n\t\tfor blocked_ip in $blocked_ips; do\n\t\t\techo \"> testing $UNBLOCKED_DOM on $blocked_ip ($blocked_dom)\"\n\t\t\tcurl_test $1 $UNBLOCKED_DOM $blocked_ip detail\n\t\tdone\n\telse\n\t\techo $UNBLOCKED_DOM is not available. skipping this test.\n\tfi\n}\n\ncurl_has_reason_to_continue()\n{\n\t# $1 - curl return code\n\tfor c in 1 2 3 4 6 27 ; do\n\t\t[ $1 = $c ] && return 1\n\tdone\n\treturn 0\n}\n\ncheck_domain_prolog()\n{\n\t# $1 - test function\n\t# $2 - port\n\t# $3 - domain\n\n\tlocal code\n\n\techo\n\techo \\* $1 ipv$IPV $3\n\n\techo \"- checking without DPI bypass\"\n\tcurl_test $1 $3 && {\n\t\treport_append \"ipv${IPV} $3 $1 : working without bypass\"\n\t\t[ \"$SCANLEVEL\" = force ] || return 1\n\t}\n\tcode=$?\n\tcurl_has_reason_to_continue $code || {\n\t\treport_append \"ipv${IPV} $3 $1 : test aborted, no reason to continue. curl code $(curl_translate_code $code)\"\n\t\treturn 1\n\t}\n\treturn 0\n}\ncheck_domain_http_tcp()\n{\n\t# $1 - test function\n\t# $2 - port\n\t# $3 - encrypted test : 0 = plain, 1 - encrypted with server reply risk, 2 - encrypted without server reply risk\n\t# $4 - domain\n\n\t# in case was interrupted before\n\tpktws_ipt_unprepare_tcp $2\n\tws_kill\n\n\tcheck_domain_prolog $1 $2 $4 || return\n\n\t[ \"$SKIP_IPBLOCK\" = 1 ] || check_dpi_ip_block $1 $4\n\n\t[ \"$SKIP_TPWS\" = 1 ] || {\n\t\techo\n\t\ttpws_check_domain_http_bypass $1 $3 $4\n\t}\n\n\t[ \"$SKIP_PKTWS\" = 1 ] || {\n\t\techo\n\t        echo preparing $PKTWSD redirection\n\t\tpktws_ipt_prepare_tcp $2 \"$(mdig_resolve_all $IPV $4)\"\n\n\t\tpktws_check_domain_http_bypass $1 $3 $4\n\n\t\techo clearing $PKTWSD redirection\n\t\tpktws_ipt_unprepare_tcp $2\n\t}\n}\ncheck_domain_http_udp()\n{\n\t# $1 - test function\n\t# $2 - port\n\t# $3 - domain\n\n\t# in case was interrupted before\n\tpktws_ipt_unprepare_udp $2\n\tws_kill\n\n\tcheck_domain_prolog $1 $2 $3 || return\n\n\t[ \"$SKIP_PKTWS\" = 1 ] || {\n\t\techo\n\t        echo preparing $PKTWSD redirection\n\t\tpktws_ipt_prepare_udp $2 \"$(mdig_resolve_all $IPV $3)\"\n\n\t\tpktws_check_domain_http3_bypass $1 $3\n\n\t\techo clearing $PKTWSD redirection\n\t\tpktws_ipt_unprepare_udp $2\n\t}\n}\n\n\ncheck_domain_http()\n{\n\t# $1 - domain\n\tcheck_domain_http_tcp curl_test_http $HTTP_PORT 0 $1\n}\ncheck_domain_https_tls12()\n{\n\t# $1 - domain\n\tcheck_domain_http_tcp curl_test_https_tls12 $HTTPS_PORT 1 $1\n}\ncheck_domain_https_tls13()\n{\n\t# $1 - domain\n\tcheck_domain_http_tcp curl_test_https_tls13 $HTTPS_PORT 2 $1\n}\ncheck_domain_http3()\n{\n\t# $1 - domain\n\tcheck_domain_http_udp curl_test_http3 $QUIC_PORT $1\n}\n\nconfigure_ip_version()\n{\n\tif [ \"$IPV\" = 6 ]; then\n\t\tLOCALHOST=::1\n\t\tLOCALHOST_IPT=[${LOCALHOST}]\n\t\tIPVV=6\n\telse\n\t\tIPTABLES=iptables\n\t\tLOCALHOST=127.0.0.1\n\t\tLOCALHOST_IPT=$LOCALHOST\n\t\tIPVV=\n\tfi\n\tIPTABLES=ip${IPVV}tables\n}\nconfigure_curl_opt()\n{\n\t# wolfssl : --tlsv1.x mandates exact ssl version, tls-max not supported\n\t# openssl : --tlsv1.x means \"version equal or greater\", tls-max supported\n\tTLSMAX12=\n\tTLSMAX13=\n\tcurl_supports_tlsmax && {\n\t\tTLSMAX12=\"--tls-max 1.2\"\n\t\tTLSMAX13=\"--tls-max 1.3\"\n\t}\n\tTLS13=\n\tcurl_supports_tls13 && TLS13=1\n\tHTTP3=\n\tcurl_supports_http3 && HTTP3=1\n}\n\nlinux_ipv6_defrag_can_be_disabled()\n{\n\tlinux_min_version 4 16\n}\n\nconfigure_defrag()\n{\n\tIP6_DEFRAG_DISABLE=\n\n\t[ \"$IPVS\" = 4 ] && return\n\n\t[ \"$UNAME\" = \"Linux\" ] && {\n\t\tlinux_ipv6_defrag_can_be_disabled || {\n\t\t\techo \"WARNING ! ipv6 defrag can only be effectively disabled in linux kernel 4.16+\"\n\t\t\techo \"WARNING ! ipv6 ipfrag tests are disabled\"\n\t\t\techo\n\t\t\treturn\n\t\t}\n\t}\n\n\tcase \"$FWTYPE\" in\n\t\tiptables)\n\t\t\tif ipt6_has_raw ; then\n\t\t\t\tif ipt6_has_frag; then\n\t\t\t\t\tIP6_DEFRAG_DISABLE=1\n\t\t\t\telse\n\t\t\t\t\techo \"WARNING ! ip6tables does not have '-m frag' module, ipv6 ipfrag tests are disabled\"\n\t\t\t\t\techo\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\techo \"WARNING ! ip6tables raw table is not available, ipv6 ipfrag tests are disabled\"\n\t\t\t\techo\n\t\t\tfi\n\t\t\t[ -n \"$IP6_DEFRAG_DISABLE\" ] && {\n\t\t\t\tlocal ipexe=\"$(readlink -f $(whichq ip6tables))\"\n\t\t\t\tif contains \"$ipexe\" nft; then\n\t\t\t\t\techo \"WARNING ! ipv6 ipfrag tests may have no effect if ip6tables-nft is used. current ip6tables point to : $ipexe\"\n\t\t\t\telse\n\t\t\t\t\techo \"WARNING ! ipv6 ipfrag tests may have no effect if ip6table_raw kernel module is not loaded with parameter : raw_before_defrag=1\"\n\t\t\t\tfi\n\t\t\t\techo\n\t\t\t}\n\t\t\t;;\n\t\t*)\n\t\t\tIP6_DEFRAG_DISABLE=1\n\t\t\t;;\n\tesac\n}\n\nask_params()\n{\n\techo\n\techo NOTE ! this test should be run with zapret or any other bypass software disabled, without VPN\n\techo\n\t\n\tcurl_supports_connect_to || {\n\t\techo \"installed curl does not support --connect-to option. pls install at least curl 7.49\"\n\t\techo \"current curl version:\"\n\t\t$CURL --version\n\t\texitp 1\n\t}\n\n\tlocal dom\n\t[ -n \"$DOMAINS\" ] || {\n\t\tDOMAINS=\"$DOMAINS_DEFAULT\"\n\t\t[ \"$BATCH\" = 1 ] || {\n\t\t\techo \"specify domain(s) to test. multiple domains are space separated.\"\n\t\t\tprintf \"domain(s) (default: $DOMAINS) : \"\n\t\t\tread dom\n\t\t\t[ -n \"$dom\" ] && DOMAINS=\"$dom\"\n\t\t}\n\t}\n\n\tlocal IPVS_def=4\n\t[ -n \"$IPVS\" ] || {\n\t\t# yandex public dns\n\t\tpingtest 6 2a02:6b8::feed:0ff && IPVS_def=46\n\t\t[ \"$BATCH\" = 1 ] || {\n\t\t\tprintf \"ip protocol version(s) - 4, 6 or 46 for both (default: $IPVS_def) : \"\n\t\t\tread IPVS\n\t\t}\n\t\t[ -n \"$IPVS\" ] || IPVS=$IPVS_def\n\t\t[ \"$IPVS\" = 4 -o \"$IPVS\" = 6 -o \"$IPVS\" = 46 ] || {\n\t\t\techo 'invalid ip version(s). should be 4, 6 or 46.'\n\t\t\texitp 1\n\t\t}\n\t}\n\t[ \"$IPVS\" = 46 ] && IPVS=\"4 6\"\n\n\tconfigure_curl_opt\n\n\t[ -n \"$ENABLE_HTTP\" ] || {\n\t\tENABLE_HTTP=1\n\t\t[ \"$BATCH\" = 1 ] || {\n\t\t\techo\n\t\t\task_yes_no_var ENABLE_HTTP \"check http\"\n\t\t}\n\t}\n\n\t[ -n \"$ENABLE_HTTPS_TLS12\" ] || {\n\t\tENABLE_HTTPS_TLS12=1\n\t\t[ \"$BATCH\" = 1 ] || {\n\t\t\techo\n\t\t\task_yes_no_var ENABLE_HTTPS_TLS12 \"check https tls 1.2\"\n\t\t}\n\t}\n\n\t[ -n \"$ENABLE_HTTPS_TLS13\" ] || {\n\t\tENABLE_HTTPS_TLS13=0\n\t\tif [ -n \"$TLS13\" ]; then\n\t\t\t[ \"$BATCH\" = 1 ] || {\n\t\t\t\techo\n\t\t\t\techo \"TLS 1.3 uses encrypted ServerHello. DPI cannot check domain name in server response.\"\n\t\t\t\techo \"This can allow more bypass strategies to work.\"\n\t\t\t\techo \"What works for TLS 1.2 will also work for TLS 1.3 but not vice versa.\"\n\t\t\t\techo \"Most sites nowadays support TLS 1.3 but not all. If you can't find a strategy for TLS 1.2 use this test.\"\n\t\t\t\techo \"TLS 1.3 only strategy is better than nothing.\"\n\t\t\t\task_yes_no_var ENABLE_HTTPS_TLS13 \"check https tls 1.3\"\n\t\t\t}\n\t\telse\n\t\t\techo\n\t\t\techo \"installed curl version does not support TLS 1.3 . tests disabled.\"\n\t\tfi\n\t}\n\n\t[ -n \"$ENABLE_HTTP3\" ] || {\n\t\tENABLE_HTTP3=0\n\t\tif [ -n \"$HTTP3\" ]; then\n\t\t\tENABLE_HTTP3=1\n\t\t\t[ \"$BATCH\" = 1 ] || {\n\t\t\t\techo\n\t\t\t\techo \"make sure target domain(s) support QUIC or result will be negative in any case\"\n\t\t\t\task_yes_no_var ENABLE_HTTP3 \"check http3 QUIC\"\n\t\t\t}\n\t\telse\n\t\t\techo\n\t\t\techo \"installed curl version does not support http3 QUIC. tests disabled.\"\n\t\tfi\n\t}\n\n\t[ -n \"$REPEATS\" ] || {\n\t\t[ \"$BATCH\" = 1 ] || {\n\t\t\techo\n\t\t\techo \"sometimes ISPs use multiple DPIs or load balancing. bypass strategies may work unstable.\"\n\t\t\tprintf \"how many times to repeat each test (default: 1) : \"\n\t\t\tread REPEATS\n\t\t}\n\t\tREPEATS=$((0+${REPEATS:-1}))\n\t\t[ \"$REPEATS\" = 0 ] && {\n\t\t\techo invalid repeat count\n\t\t\texitp 1\n\t\t}\n\t}\n\t[ -z \"$PARALLEL\" -a $REPEATS -gt 1 ] && {\n\t\tPARALLEL=0\n\t\t[ \"$BATCH\" = 1 ] || {\n\t\t\techo\n\t\t\techo \"parallel scan can greatly increase speed but may also trigger DDoS protection and cause false result\"\n\t\t\task_yes_no_var PARALLEL \"enable parallel scan\"\n\t\t}\n\t}\n\tPARALLEL=${PARALLEL:-0}\n\n\t[ -n \"$SCANLEVEL\" ] || {\n\t\tSCANLEVEL=standard\n\t\t[ \"$BATCH\" = 1 ] || {\n\t\t\techo\n\t\t\techo quick    - scan as fast as possible to reveal any working strategy\n\t\t\techo standard - do investigation what works on your DPI\n\t\t\techo force    - scan maximum despite of result\n\t\t\task_list SCANLEVEL \"quick standard force\" \"$SCANLEVEL\"\n\t\t\t# disable tpws checks by default in quick mode\n\t\t\t[ \"$SCANLEVEL\" = quick -a -z \"$SKIP_TPWS\" -a \"$UNAME\" != Darwin ] && SKIP_TPWS=1\n\t\t}\n\t}\n\n\techo\n\n\tconfigure_defrag\n}\n\n\n\nping_with_fix()\n{\n\tlocal ret\n\t$PING $2 $1 >/dev/null 2>/dev/null\n\tret=$?\n\t# can be because of unsupported -4 option\n\tif [ \"$ret\" = 2 -o \"$ret\" = 64 ]; then\n\t\tping $2 $1 >/dev/null\n\telse\n\t\treturn $ret\n\tfi\n}\n\npingtest()\n{\n\t# $1 - ip version : 4 or 6\n\t# $2 - domain or ip\n\n\t# ping command can vary a lot. some implementations have -4/-6 options. others don.t\n\t# WARNING ! macos ping6 command does not have timeout option. ping6 will fail\n\n\tlocal PING=ping ret\n\tif [ \"$1\" = 6 ]; then\n\t\tif exists ping6; then\n\t\t\tPING=ping6\n\t\telse\n\t\t\tPING=\"ping -6\"\n\t\tfi\n\telse\n\t\tif [ \"$UNAME\" = Darwin -o \"$UNAME\" = FreeBSD -o \"$UNAME\" = OpenBSD ]; then\n\t\t\t# ping by default pings ipv4, ping6 only pings ipv6\n\t\t\t# in FreeBSD -4/-6 options are supported, in others not\n\t\t\tPING=ping\n\t\telse\n\t\t\t# this can be linux or cygwin\n\t\t\t# in linux it's not possible for sure to figure out if it supports -4/-6. only try and check for result code=2 (invalid option)\n\t\t\tPING=\"ping -4\"\n\t\tfi\n\tfi\n\tcase \"$UNAME\" in\n\t\tDarwin)\n\t\t\t$PING -c 1 -t 1 $2 >/dev/null 2>/dev/null\n\t\t\t# WARNING ! macos ping6 command does not have timeout option. ping6 will fail. but without timeout is not an option.\n\t\t\t;;\n\t\tOpenBSD)\n\t\t\t$PING -c 1 -w 1 $2 >/dev/null\n\t\t\t;;\n\t\tCYGWIN)\n\t\t\tif starts_with \"$(which ping)\" /cygdrive; then\n\t\t\t\t# cygwin does not have own ping by default. use windows PING.\n\t\t\t\t$PING -n 1 -w 1000 $2 >/dev/null\n\t\t\telse\n\t\t\t\tping_with_fix $2 '-c 1 -w 1'\n\t\t\tfi\n\t\t\t;;\n\t\t*)\n\t\t\tping_with_fix $2 '-c 1 -W 1'\n\t\t\t;;\n\tesac\n}\ndnstest()\n{\n\t# $1 - dns server. empty for system resolver\n\t\"$LOOKUP\" iana.org $1 >/dev/null 2>/dev/null\n}\nfind_working_public_dns()\n{\n\tlocal dns\n\tfor dns in $DNSCHECK_DNS; do\n\t\tpingtest 4 $dns && dnstest $dns && {\n\t\t\tPUBDNS=$dns\n\t\t\treturn 0\n\t\t}\n\tdone\n\treturn 1\n}\nlookup4()\n{\n\t# $1 - domain\n\t# $2 - DNS\n\tcase \"$LOOKUP\" in\n\t\tnslookup)\n\t\t\tif is_linked_to_busybox nslookup; then\n\t\t\t\tnslookup $1 $2 2>/dev/null | sed -e '1,3d' -nre 's/^.*:[^0-9]*(([0-9]{1,3}\\.){3}[0-9]{1,3}).*$/\\1/p'\n\t\t\telse\n\t\t\t\tnslookup $1 $2 2>/dev/null | sed -e '1,3d' -nre 's/^[^0-9]*(([0-9]{1,3}\\.){3}[0-9]{1,3}).*$/\\1/p'\n\t\t\tfi\n\t\t\t;;\n\t\thost)\n\t\t\thost -t A $1 $2 | grep \"has address\" | grep -oE '([0-9]{1,3}\\.){3}[0-9]{1,3}'\n\t\t\t;;\n\tesac\n}\ncheck_dns_spoof()\n{\n\t# $1 - domain\n\t# $2 - public DNS\n\n\t# windows version of mdig outputs 0D0A line ending. remove 0D.\n\techo $1 | \"$MDIG\" --family=4 | tr -d '\\r' >\"$DNSCHECK_DIG1\"\n\tlookup4 $1 $2 >\"$DNSCHECK_DIG2\"\n\t# check whether system resolver returns anything other than public DNS\n\tgrep -qvFf \"$DNSCHECK_DIG2\" \"$DNSCHECK_DIG1\"\n}\ncheck_dns_cleanup()\n{\n\trm -f \"$DNSCHECK_DIG1\" \"$DNSCHECK_DIG2\" \"$DNSCHECK_DIGS\" 2>/dev/null\n}\ncheck_dns_()\n{\n\tlocal C1 C2 dom\n\n\tDNS_IS_SPOOFED=0\n\n\t[ \"$SKIP_DNSCHECK\" = 1 ] && return 0\n\n\techo \\* checking DNS\n\n\t[ -f \"$DNSCHECK_DIGS\" ] && rm -f \"$DNSCHECK_DIGS\"\n\n\tdnstest || {\n\t\techo -- DNS is not working. It's either misconfigured or blocked or you don't have inet access.\n\t\treturn 1\n\t}\n\techo system DNS is working\n\n\tif find_working_public_dns ; then\n\t\techo comparing system resolver to public DNS : $PUBDNS\n\t\tfor dom in $DNSCHECK_DOM; do\n\t\t\tif check_dns_spoof $dom $PUBDNS ; then\n\t\t\t\techo $dom : MISMATCH\n\t\t\t\techo -- system resolver :\n\t\t\t\tcat \"$DNSCHECK_DIG1\"\n\t\t\t\techo -- $PUBDNS :\n\t\t\t\tcat \"$DNSCHECK_DIG2\"\n\t\t\t\tcheck_dns_cleanup\n\t\t\t\techo -- POSSIBLE DNS HIJACK DETECTED. ZAPRET WILL NOT HELP YOU IN CASE DNS IS SPOOFED !!!\n\t\t\t\techo -- DNS CHANGE OR DNSCRYPT MAY BE REQUIRED\n\t\t\t\tDNS_IS_SPOOFED=1\n\t\t\t\treturn 1\n\t\t\telse\n\t\t\t\techo $dom : OK\n\t\t\t\tcat \"$DNSCHECK_DIG1\" >>\"$DNSCHECK_DIGS\"\n\t\t\tfi\n\t\tdone\n\telse\n\t\techo no working public DNS was found. looks like public DNS blocked.\n\t\tfor dom in $DNSCHECK_DOM; do echo $dom; done | \"$MDIG\" --threads=10 --family=4 >\"$DNSCHECK_DIGS\"\n\tfi\n\n\techo \"checking resolved IP uniqueness for : $DNSCHECK_DOM\"\n\techo \"censor's DNS can return equal result for multiple blocked domains.\"\n\tC1=$(wc -l <\"$DNSCHECK_DIGS\")\n\tC2=$(sort -u \"$DNSCHECK_DIGS\" | wc -l)\n\t[ \"$C1\" -eq 0 ] &&\n\t{\n\t\techo -- DNS is not working. It's either misconfigured or blocked or you don't have inet access.\n\t\tcheck_dns_cleanup\n\t\treturn 1\n\t}\n\t[ \"$C1\" = \"$C2\" ] ||\n\t{\n\t\techo system dns resolver has returned equal IPs for some domains checked above \\($C1 total, $C2 unique\\)\n\t\techo non-unique IPs :\n\t\tsort \"$DNSCHECK_DIGS\" | uniq -d\n\t\techo -- POSSIBLE DNS HIJACK DETECTED. ZAPRET WILL NOT HELP YOU IN CASE DNS IS SPOOFED !!!\n\t\techo -- DNSCRYPT MAY BE REQUIRED\n\t\tcheck_dns_cleanup\n\t\tDNS_IS_SPOOFED=1\n\t\treturn 1\n\t}\n\techo all resolved IPs are unique\n\techo -- DNS looks good\n\techo -- NOTE this check is Russia targeted. In your country other domains may be blocked.\n\tcheck_dns_cleanup\n\treturn 0\n}\n\ncheck_dns()\n{\n\tlocal r\n\tcheck_dns_\n\tr=$?\n\t[ \"$DNS_IS_SPOOFED\" = 1 ] && SECURE_DNS=${SECURE_DNS:-1}\n\t[ \"$SECURE_DNS\" = 1 ] && {\n\t\tdoh_find_working || {\n\t\t\techo could not find working DoH server. exiting.\n\t\t\texitp 7\n\t\t}\n\t}\n\treturn $r\n}\n\nunprepare_all()\n{\n\t# make sure we are not in a middle state that impacts connectivity\n\tws_kill\n\twait\n\t[ -n \"$IPV\" ] && {\n\t\tpktws_ipt_unprepare_tcp $HTTP_PORT\n\t\tpktws_ipt_unprepare_tcp $HTTPS_PORT\n\t\tpktws_ipt_unprepare_udp $QUIC_PORT\n\t}\n\tcleanup\n\trm -f \"${HDRTEMP}\"* \"${PARALLEL_OUT}\"*\n}\nsigint()\n{\n\techo\n\techo terminating...\n\tunprepare_all\n\texitp 1\n}\nsigint_cleanup()\n{\n\tcleanup\n\texit 1\n}\nsigsilent()\n{\n\t# must not write anything here to stdout\n\tunprepare_all\n\texit 1\n}\n\n\nfsleep_setup\nfix_sbin_path\ncheck_system\ncheck_already\n# no divert sockets in MacOS\n[ \"$UNAME\" = \"Darwin\" ] && SKIP_PKTWS=1\n[ \"$UNAME\" != CYGWIN  -a \"$SKIP_PKTWS\" != 1 ] && require_root\ncheck_prerequisites\ntrap sigint_cleanup INT\ncheck_dns\ncheck_virt\nask_params\ntrap - INT\n\nPID=\nNREPORT=\nunset WF\ntrap sigint INT\ntrap sigsilent PIPE\ntrap sigsilent HUP\nfor dom in $DOMAINS; do\n\tfor IPV in $IPVS; do\n\t\tconfigure_ip_version\n\t\t[ \"$ENABLE_HTTP\" = 1 ] && {\n\t\t\t[ \"$SKIP_IPBLOCK\" = 1 ] || check_domain_port_block $dom $HTTP_PORT\n\t\t\tcheck_domain_http $dom\n\t\t}\n\t\t[ \"$ENABLE_HTTPS_TLS12\" = 1 -o \"$ENABLE_HTTPS_TLS13\" = 1 ] && [ \"$SKIP_IPBLOCK\" != 1 ] && check_domain_port_block $dom $HTTPS_PORT\n\t\t[ \"$ENABLE_HTTPS_TLS12\" = 1 ] && check_domain_https_tls12 $dom\n\t\t[ \"$ENABLE_HTTPS_TLS13\" = 1 ] && check_domain_https_tls13 $dom\n\t\t[ \"$ENABLE_HTTP3\" = 1 ] && check_domain_http3 $dom\n\tdone\ndone\ntrap - HUP\ntrap - PIPE\ntrap - INT\n\ncleanup\n\necho\necho \\* SUMMARY\nreport_print\necho\necho \"Please note this SUMMARY does not guarantee a magic pill for you to copy/paste and be happy.\"\necho \"Understanding how strategies work is very desirable.\"\necho \"This knowledge allows to understand better which strategies to prefer and which to avoid if possible, how to combine strategies.\"\necho \"Blockcheck does it's best to prioritize good strategies but it's not bullet-proof.\"\necho \"It was designed not as magic pill maker but as a DPI bypass test tool.\"\n\nexitp 0\n"
        },
        {
          "name": "common",
          "type": "tree",
          "content": null
        },
        {
          "name": "config.default",
          "type": "blob",
          "size": 5.3857421875,
          "content": "# this file is included from init scripts\n# change values here\n\n# can help in case /tmp has not enough space\n#TMPDIR=/opt/zapret/tmp\n\n# redefine user for zapret daemons. required on Keenetic\n#WS_USER=nobody\n\n# override firewall type : iptables,nftables,ipfw\n#FWTYPE=iptables\n# nftables only : set this to 0 to use pre-nat mode. default is post-nat.\n# pre-nat mode disables some bypass techniques for forwarded traffic but allows to see client IP addresses in debug log\n#POSTNAT=0\n\n# options for ipsets\n# maximum number of elements in sets. also used for nft sets\nSET_MAXELEM=522288\n# too low hashsize can cause memory allocation errors on low RAM systems , even if RAM is enough\n# too large hashsize will waste lots of RAM\nIPSET_OPT=\"hashsize 262144 maxelem $SET_MAXELEM\"\n# dynamically generate additional ip. $1 = ipset/nfset/table name\n#IPSET_HOOK=\"/etc/zapret.ipset.hook\"\n\n# options for ip2net. \"-4\" or \"-6\" auto added by ipset create script\nIP2NET_OPT4=\"--prefix-length=22-30 --v4-threshold=3/4\"\nIP2NET_OPT6=\"--prefix-length=56-64 --v6-threshold=5\"\n# options for auto hostlist\nAUTOHOSTLIST_RETRANS_THRESHOLD=3\nAUTOHOSTLIST_FAIL_THRESHOLD=3\nAUTOHOSTLIST_FAIL_TIME=60\n# 1 = debug autohostlist positives to ipset/zapret-hosts-auto-debug.log\nAUTOHOSTLIST_DEBUGLOG=0\n\n# number of parallel threads for domain list resolves\nMDIG_THREADS=30\n\n# ipset/*.sh can compress large lists\nGZIP_LISTS=1\n# command to reload ip/host lists after update\n# comment or leave empty for auto backend selection : ipset or ipfw if present\n# on BSD systems with PF no auto reloading happens. you must provide your own command\n# set to \"-\" to disable reload\n#LISTS_RELOAD=\"pfctl -f /etc/pf.conf\"\n\n# mark bit used by nfqws to prevent loop\nDESYNC_MARK=0x40000000\nDESYNC_MARK_POSTNAT=0x20000000\n\nTPWS_SOCKS_ENABLE=0\n# tpws socks listens on this port on localhost and LAN interfaces\nTPPORT_SOCKS=987\n# use <HOSTLIST> and <HOSTLIST_NOAUTO> placeholders to engage standard hostlists and autohostlist in ipset dir\n# hostlist markers are replaced to empty string if MODE_FILTER does not satisfy\n# <HOSTLIST_NOAUTO> appends ipset/zapret-hosts-auto.txt as normal list\nTPWS_SOCKS_OPT=\"\n--filter-tcp=80 --methodeol <HOSTLIST> --new\n--filter-tcp=443 --split-pos=1,midsld --disorder <HOSTLIST>\n\"\n\nTPWS_ENABLE=0\nTPWS_PORTS=80,443\n# use <HOSTLIST> and <HOSTLIST_NOAUTO> placeholders to engage standard hostlists and autohostlist in ipset dir\n# hostlist markers are replaced to empty string if MODE_FILTER does not satisfy\n# <HOSTLIST_NOAUTO> appends ipset/zapret-hosts-auto.txt as normal list\nTPWS_OPT=\"\n--filter-tcp=80 --methodeol <HOSTLIST> --new\n--filter-tcp=443 --split-pos=1,midsld --disorder <HOSTLIST>\n\"\n\nNFQWS_ENABLE=0\n# redirect outgoing traffic with connbytes limiter applied in both directions.\nNFQWS_PORTS_TCP=80,443\nNFQWS_PORTS_UDP=443\n# PKT_OUT means connbytes dir original\n# PKT_IN means connbytes dir reply\n# this is --dpi-desync-cutoff=nX kernel mode implementation for linux. it saves a lot of CPU.\nNFQWS_TCP_PKT_OUT=$((6+$AUTOHOSTLIST_RETRANS_THRESHOLD))\nNFQWS_TCP_PKT_IN=3\nNFQWS_UDP_PKT_OUT=$((6+$AUTOHOSTLIST_RETRANS_THRESHOLD))\nNFQWS_UDP_PKT_IN=0\n# redirect outgoing traffic without connbytes limiter and incoming with connbytes limiter\n# normally it's needed only for stateless DPI that matches every packet in a single TCP session\n# typical example are plain HTTP keep alives\n# this mode can be very CPU consuming. enable with care !\n#NFQWS_PORTS_TCP_KEEPALIVE=80\n#NFQWS_PORTS_UDP_KEEPALIVE=\n# use <HOSTLIST> and <HOSTLIST_NOAUTO> placeholders to engage standard hostlists and autohostlist in ipset dir\n# hostlist markers are replaced to empty string if MODE_FILTER does not satisfy\n# <HOSTLIST_NOAUTO> appends ipset/zapret-hosts-auto.txt as normal list\nNFQWS_OPT=\"\n--filter-tcp=80 --dpi-desync=fake,multisplit --dpi-desync-split-pos=method+2 --dpi-desync-fooling=md5sig <HOSTLIST> --new\n--filter-tcp=443 --dpi-desync=fake,multidisorder --dpi-desync-split-pos=1,midsld --dpi-desync-fooling=badseq,md5sig <HOSTLIST> --new\n--filter-udp=443 --dpi-desync=fake --dpi-desync-repeats=6 <HOSTLIST_NOAUTO>\n\"\n\n# none,ipset,hostlist,autohostlist\nMODE_FILTER=none\n\n# openwrt only : donttouch,none,software,hardware\nFLOWOFFLOAD=donttouch\n\n# openwrt: specify networks to be treated as LAN. default is \"lan\"\n#OPENWRT_LAN=\"lan lan2 lan3\"\n# openwrt: specify networks to be treated as WAN. default wans are interfaces with default route\n#OPENWRT_WAN4=\"wan vpn\"\n#OPENWRT_WAN6=\"wan6 vpn6\"\n\n# for routers based on desktop linux and macos. has no effect in openwrt.\n# CHOOSE LAN and optinally WAN/WAN6 NETWORK INTERFACES\n# or leave them commented if its not router\n# it's possible to specify multiple interfaces like this : IFACE_LAN=\"eth0 eth1 eth2\"\n# if IFACE_WAN6 is not defined it take the value of IFACE_WAN\n#IFACE_LAN=eth0\n#IFACE_WAN=eth1\n#IFACE_WAN6=\"ipsec0 wireguard0 he_net\"\n\n# should start/stop command of init scripts apply firewall rules ?\n# not applicable to openwrt with firewall3+iptables\nINIT_APPLY_FW=1\n# firewall apply hooks\n#INIT_FW_PRE_UP_HOOK=\"/etc/firewall.zapret.hook.pre_up\"\n#INIT_FW_POST_UP_HOOK=\"/etc/firewall.zapret.hook.post_up\"\n#INIT_FW_PRE_DOWN_HOOK=\"/etc/firewall.zapret.hook.pre_down\"\n#INIT_FW_POST_DOWN_HOOK=\"/etc/firewall.zapret.hook.post_down\"\n\n# do not work with ipv4\n#DISABLE_IPV4=1\n# do not work with ipv6\nDISABLE_IPV6=1\n\n# select which init script will be used to get ip or host list\n# possible values : get_user.sh get_antizapret.sh get_combined.sh get_reestr.sh get_hostlist.sh\n# comment if not required\n#GETLIST=\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "files",
          "type": "tree",
          "content": null
        },
        {
          "name": "init.d",
          "type": "tree",
          "content": null
        },
        {
          "name": "install_bin.sh",
          "type": "blob",
          "size": 2.427734375,
          "content": "#!/bin/sh\n\nEXEDIR=\"$(dirname \"$0\")\"\nEXEDIR=\"$(cd \"$EXEDIR\"; pwd)\"\nBINS=binaries\nBINDIR=\"$EXEDIR/$BINS\"\n\nZAPRET_BASE=${ZAPRET_BASE:-\"$EXEDIR\"}\n. \"$ZAPRET_BASE/common/base.sh\"\n\ncheck_dir()\n{\n\tlocal dir=\"$BINDIR/$1\"\n\tlocal exe=\"$dir/ip2net\"\n\tlocal out\n\tif [ -f \"$exe\" ]; then\n\t\tif [ -x \"$exe\" ]; then\n\t\t\t# ash and dash try to execute invalid executables as a script. they interpret binary garbage with possible negative consequences\n\t\t\t# bash and zsh do not do this\n\t\t\tif exists bash; then\n\t\t\t\tout=$(echo 0.0.0.0 | bash -c \"\\\"$exe\"\\\" 2>/dev/null)\n\t\t\telif exists zsh; then\n\t\t\t\tout=$(echo 0.0.0.0 | zsh -c \"\\\"$exe\\\"\" 2>/dev/null)\n\t\t\telse\n\t\t\t\t# find does not use its own shell exec\n\t\t\t\t# it uses execvp(). in musl libc it does not call shell, in glibc it DOES call /bin/sh\n\t\t\t\t# that's why prefer bash or zsh if present. otherwise it's our last chance\n\t\t\t\tlocal FIND=find\n\t\t\t\tif ! exists find && exists busybox; then\n\t\t\t\t\tFIND=\"busybox find\"\n\t\t\t\tfi\n\t\t\t\tout=$(echo 0.0.0.0 | $FIND \"$dir\" -maxdepth 1 -name ip2net -exec {} \\; 2>/dev/null)\n\t\t\tfi\n\t\t\t[ -n \"$out\" ]\n\t\telse\n\t\t\techo >&2 \"$exe is not executable. set proper chmod.\"\n\t\t\treturn 1\n\t\tfi\n\telse\n\t\techo >&2 \"$exe is absent\"\n\t\treturn 2\n\tfi\n}\n\n# link or copy executables. uncomment either ln or cp, comment other\nccp()\n{\n\tlocal F=\"$(basename \"$1\")\"\n\t[ -d \"$ZAPRET_BASE/$2\" ] || mkdir \"$ZAPRET_BASE/$2\"\n\t[ -f \"$ZAPRET_BASE/$2/$F\" ] && rm -f \"$ZAPRET_BASE/$2/$F\"\n\tln -fs \"../$BINS/$1\" \"$ZAPRET_BASE/$2\" && echo linking : \"../$BINS/$1\" =\\> \"$ZAPRET_BASE/$2\"\n\t#cp -f \"../$BINS/$1\" \"$ZAPRET_BASE/$2\" && echo copying : \"../$BINS/$1\" =\\> \"$ZAPRET_BASE/$2\"\n}\n\nUNAME=$(uname)\nunset PKTWS\ncase $UNAME in\n\tLinux)\n\t\tARCHLIST=\"my x86_64 x86 aarch64 arm mips64r2-msb mips32r1-lsb mips32r1-msb lexra ppc\"\n\t\tPKTWS=nfqws\n\t\t;;\n\tDarwin)\n\t\tARCHLIST=\"my mac64\"\n\t\t;;\n\tFreeBSD)\n\t\tARCHLIST=\"my freebsd-x64\"\n\t\tPKTWS=dvtws\n\t\t;;\n\tCYGWIN*)\n\t\tUNAME=CYGWIN\n\t\tARCHLIST=\"win64 win32\"\n\t\tPKTWS=winws\n\t\t;;\n\t*)\n\t\tARCHLIST=\"my\"\nesac\n\nif [ \"$1\" = \"getarch\" ]; then\n\tfor arch in $ARCHLIST\n\tdo\n\t\t[ -d \"$BINDIR/$arch\" ] || continue\n\t\tif check_dir $arch; then\n\t \t\techo $arch\n\t \t\texit 0\n\t \tfi\n\tdone\nelse\n\tfor arch in $ARCHLIST\n\tdo\n\t\t[ -d \"$BINDIR/$arch\" ] || continue\n\t\tif check_dir $arch; then\n\t\t\techo $arch is OK\n\t\t\techo installing binaries ...\n\t\t\tccp $arch/ip2net ip2net\n\t\t\tccp $arch/mdig mdig\n\t\t\t[ -n \"$PKTWS\" ] && ccp $arch/$PKTWS nfq\n\t\t\t[ \"$UNAME\" = CYGWIN ] || ccp $arch/tpws tpws\n\t \t\texit 0\n\t\telse\n\t\t\techo $arch is NOT OK\n\t\tfi\n\tdone\n\techo no compatible binaries found\nfi\n\nexit 1\n"
        },
        {
          "name": "install_easy.sh",
          "type": "blob",
          "size": 23.28125,
          "content": "#!/bin/sh\n\n# automated script for easy installing zapret\n\nEXEDIR=\"$(dirname \"$0\")\"\nEXEDIR=\"$(cd \"$EXEDIR\"; pwd)\"\nZAPRET_BASE=${ZAPRET_BASE:-\"$EXEDIR\"}\nZAPRET_TARGET=${ZAPRET_TARGET:-/opt/zapret}\nZAPRET_TARGET_RW=${ZAPRET_RW:-\"$ZAPRET_TARGET\"}\nZAPRET_TARGET_CONFIG=\"$ZAPRET_TARGET_RW/config\"\nZAPRET_RW=${ZAPRET_RW:-\"$ZAPRET_BASE\"}\nZAPRET_CONFIG=${ZAPRET_CONFIG:-\"$ZAPRET_RW/config\"}\nZAPRET_CONFIG_DEFAULT=\"$ZAPRET_BASE/config.default\"\nIPSET_DIR=\"$ZAPRET_BASE/ipset\"\n\n[ -f \"$ZAPRET_CONFIG\" ] || {\n\tZAPRET_CONFIG_DIR=\"$(dirname \"$ZAPRET_CONFIG\")\"\n\t[ -d \"$ZAPRET_CONFIG_DIR\" ] || mkdir -p \"$ZAPRET_CONFIG_DIR\"\n\tcp \"$ZAPRET_CONFIG_DEFAULT\" \"$ZAPRET_CONFIG\"\n}\n. \"$ZAPRET_CONFIG\"\n. \"$ZAPRET_BASE/common/base.sh\"\n. \"$ZAPRET_BASE/common/elevate.sh\"\n. \"$ZAPRET_BASE/common/fwtype.sh\"\n. \"$ZAPRET_BASE/common/dialog.sh\"\n. \"$ZAPRET_BASE/common/ipt.sh\"\n. \"$ZAPRET_BASE/common/installer.sh\"\n. \"$ZAPRET_BASE/common/virt.sh\"\n. \"$ZAPRET_BASE/common/list.sh\"\n\nGET_LIST=\"$IPSET_DIR/get_config.sh\"\n\ncheck_readonly_system()\n{\n\tlocal RO\n\techo \\* checking readonly system\n        case $SYSTEM in\n\t\tsystemd)\n\t\t\t[ -w \"$SYSTEMD_SYSTEM_DIR\" ] || RO=1\n\t\t\t;;\n\t\topenrc)\n\t\t\t[ -w \"$(dirname \"$INIT_SCRIPT\")\" ] || RO=1\n\t\t\t;;\n\tesac\n\t[ -z \"$RO\" ] || {\n\t\techo '!!! READONLY SYSTEM DETECTED !!!'\n\t\techo '!!! WILL NOT BE ABLE TO CONFIGURE STARTUP !!!'\n\t\techo '!!! MANUAL STARTUP CONFIGURATION IS REQUIRED !!!'\n\t\task_yes_no N \"do you want to continue\" || exitp 5\n\t}\n}\n\ncheck_bins()\n{\n\techo \\* checking executables\n\n\tfix_perms_bin_test \"$EXEDIR\"\n\tlocal arch=\"$(get_bin_arch)\"\n\tlocal make_target\n\t[ \"$FORCE_BUILD\" = \"1\" ] && {\n\t\techo forced build mode\n\t\tif [ \"$arch\" = \"my\" ]; then\n\t\t\techo already compiled\n\t\telse\n\t\t\tarch=\"\"\n\t\tfi\n\t}\n\tif [ -n \"$arch\" ] ; then\n\t\techo found architecture \"\\\"$arch\\\"\"\n\telif [ -f \"$EXEDIR/Makefile\" ] && exists make; then\n\t\techo trying to compile\n\t\t[ \"$SYSTEM\" = \"macos\" ] && make_target=mac\n\t\tCFLAGS=\"-march=native ${CFLAGS}\" make -C \"$EXEDIR\" $make_target || {\n\t\t\techo could not compile\n\t\t\tmake -C \"$EXEDIR\" clean\n\t\t\texitp 8\n\t\t}\n\t\techo compiled\n\telse\n\t\techo build tools not found\n\t\texitp 8\n\tfi\n}\n\ncall_install_bin()\n{\n\tsh \"$EXEDIR/install_bin.sh\" $1\n}\nget_bin_arch()\n{\n\tcall_install_bin getarch\n}\n\ninstall_binaries()\n{\n\techo \\* installing binaries\n\n\tcall_install_bin || {\n\t\techo compatible binaries not found\n\t\texitp 8\n\t}\n}\n\nws_opt_validate()\n{\n\t#    \n\t#      ,        \n\t#           ,    .   custom script.\n\t# custom script -  ,      ,     ,  .\n\t#   IPSET    ,      nfqws   \n\t# --ipset      LINUX   ipset (, Android).\n\t#           LINUX \n\thas_bad_ws_options \"$1\" && {\n\t\thelp_bad_ws_options\n\t\treturn 1\n\t}\n\treturn 0\n}\ntpws_opt_validate()\n{\n\tws_opt_validate \"$1\" || return 1\n\tdry_run_tpws || {\n\t\techo invalid tpws options\n\t\treturn 1\n\t}\n}\ntpws_socks_opt_validate()\n{\n\t# --ipset allowed here\n\tdry_run_tpws_socks || {\n\t\techo invalid tpws options\n\t\treturn 1\n\t}\n}\nnfqws_opt_validate()\n{\n\tws_opt_validate \"$1\" || return 1\n\tdry_run_nfqws || {\n\t\techo invalid nfqws options\n\t\treturn 1\n\t}\n}\n\nselect_mode_group()\n{\n\t# $1 - ENABLE var name\n\t# $2 - ask text\n\t# $3 - vars\n\t# $4 - validator func\n\t# $5 - validator func param var\n\n\tlocal enabled var v edited bad Y param\n\n\techo\n\task_yes_no_var $1 \"$2\"\n\twrite_config_var $1\n\teval enabled=\\$$1\n\t[ \"$enabled\" = 1 ] && {\n\t\techo\n\t\twhile  : ; do\n\t\t\tlist_vars $3\n\t\t\tbad=0; Y=N\n\t\t\t[ -n \"$4\" ] && {\n\t\t\t\teval param=\"\\$$5\"\n\t\t\t\t$4 \"$param\"; bad=$?\n\t\t\t\t[ \"$bad\" = 1 ] && Y=Y\n\t\t\t}\n\t\t\task_yes_no $Y \"do you want to edit the options\" || {\n\t\t\t\t[ \"$bad\" = 1 ] && {\n\t\t\t\t\techo installer will not allow to use bad options. exiting.\n\t\t\t\t\texitp 3\n\t\t\t\t}\n\t\t\t\t[ -n \"$edited\" ] && {\n\t\t\t\t\tfor var in $3; do\n\t\t\t\t\t\twrite_config_var $var\n\t\t\t\t\tdone\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tedit_vars $3\n\t\t\tedited=1\n\t\t\techo ..edited..\n\t\tdone\n\t}\n}\n\nselect_mode_tpws_socks()\n{\n\tlocal EDITVAR_NEWLINE_DELIMETER=\"--new\" EDITVAR_NEWLINE_VARS=\"TPWS_SOCKS_OPT\"\n\tselect_mode_group TPWS_SOCKS_ENABLE \"enable tpws socks mode on port $TPPORT_SOCKS ?\" \"TPPORT_SOCKS TPWS_SOCKS_OPT\" tpws_socks_opt_validate TPWS_SOCKS_OPT\n}\nselect_mode_tpws()\n{\n\tlocal EDITVAR_NEWLINE_DELIMETER=\"--new\" EDITVAR_NEWLINE_VARS=\"TPWS_OPT\"\n\tselect_mode_group TPWS_ENABLE \"enable tpws transparent mode ?\" \"TPWS_PORTS TPWS_OPT\" tpws_opt_validate TPWS_OPT\n}\nselect_mode_nfqws()\n{\n\tlocal EDITVAR_NEWLINE_DELIMETER=\"--new\" EDITVAR_NEWLINE_VARS=\"NFQWS_OPT\"\n\tselect_mode_group NFQWS_ENABLE \"enable nfqws ?\" \"NFQWS_PORTS_TCP NFQWS_PORTS_UDP NFQWS_TCP_PKT_OUT NFQWS_TCP_PKT_IN NFQWS_UDP_PKT_OUT NFQWS_UDP_PKT_IN NFQWS_PORTS_TCP_KEEPALIVE NFQWS_PORTS_UDP_KEEPALIVE NFQWS_OPT\" nfqws_opt_validate NFQWS_OPT\n}\n\nselect_mode_mode()\n{\n\tselect_mode_tpws_socks\n\tselect_mode_tpws\n\t[ \"$UNAME\" = Linux ] && select_mode_nfqws\n\n\techo\n\techo \"current custom scripts in $CUSTOM_DIR/custom.d:\"\n\t[ -d \"$CUSTOM_DIR/custom.d\" ] && ls \"$CUSTOM_DIR/custom.d\"\n\techo \"Make sure this is ok\"\n\techo\n}\n\nselect_mode_filter()\n{\n\tlocal filter=\"none ipset hostlist autohostlist\"\n\techo\n\techo select filtering :\n\task_list MODE_FILTER \"$filter\" none && write_config_var MODE_FILTER\n}\n\nselect_mode()\n{\n\tselect_mode_mode\n\tselect_mode_iface\n\tselect_mode_filter\n}\n\nselect_getlist()\n{\n\tif [ \"$MODE_FILTER\" = \"ipset\" -o \"$MODE_FILTER\" = \"hostlist\" -o \"$MODE_FILTER\" = \"autohostlist\" ]; then\n\t\tlocal D=N\n\t\t[ -n \"$GETLIST\" ] && D=Y\n\t\techo\n\t\tif ask_yes_no $D \"do you want to auto download ip/host list\"; then\n\t\t\tif [ \"$MODE_FILTER\" = \"hostlist\" -o \"$MODE_FILTER\" = \"autohostlist\" ] ; then\n\t\t\t\tGETLISTS=\"get_refilter_domains.sh get_antizapret_domains.sh get_reestr_resolvable_domains.sh get_reestr_hostlist.sh\"\n\t\t\t\tGETLIST_DEF=\"get_antizapret_domains.sh\"\n\t\t\telse\n\t\t\t\tGETLISTS=\"get_user.sh get_refilter_ipsum.sh get_antifilter_ip.sh get_antifilter_ipsmart.sh get_antifilter_ipsum.sh get_antifilter_ipresolve.sh get_antifilter_allyouneed.sh get_reestr_resolve.sh get_reestr_preresolved.sh get_reestr_preresolved_smart.sh\"\n\t\t\t\tGETLIST_DEF=\"get_antifilter_allyouneed.sh\"\n\t\t\tfi\n\t\t\task_list GETLIST \"$GETLISTS\" \"$GETLIST_DEF\" && write_config_var GETLIST\n\t\t\treturn\n\t\tfi\n\tfi\n\tGETLIST=\"\"\n\twrite_config_var GETLIST\n}\n\nask_config()\n{\n\tselect_mode\n\tselect_getlist\n}\n\nask_config_offload()\n{\n\t[ \"$FWTYPE\" = nftables ] || is_ipt_flow_offload_avail && {\n\t\techo\n\t\techo flow offloading can greatly increase speed on slow devices and high speed links \\(usually 150+ mbits\\)\n\t\tif [ \"$SYSTEM\" = openwrt ]; then\n\t\t\techo unfortuantely its not compatible with most nfqws options. nfqws traffic must be exempted from flow offloading.\n\t\t\techo donttouch = disable system flow offloading setting if nfqws mode was selected, dont touch it otherwise and dont configure selective flow offloading\n\t\t\techo none = always disable system flow offloading setting and dont configure selective flow offloading\n\t\t\techo software = always disable system flow offloading setting and configure selective software flow offloading\n\t\t\techo hardware = always disable system flow offloading setting and configure selective hardware flow offloading\n\t\telse\n\t\t\techo offloading is applicable only to forwarded traffic. it has no effect on outgoing traffic\n\t\t\techo hardware flow offloading is available only on specific supporting hardware. most likely will not work on a generic system\n\t\tfi\n\t\techo offloading breaks traffic shaper\n\t\techo select flow offloading :\n\t\tlocal options=\"none software hardware\"\n\t\tlocal default=\"none\"\n\t\t[ \"$SYSTEM\" = openwrt ] && {\n\t\t\toptions=\"donttouch none software hardware\"\n\t\t\tdefault=\"donttouch\"\n\t\t}\n\t\task_list FLOWOFFLOAD \"$options\" $default && write_config_var FLOWOFFLOAD\n\t}\n}\n\nask_config_tmpdir()\n{\n\t# ask tmpdir change for low ram systems with enough free disk space\n\t[ -n \"$GETLIST\" ] && [ $(get_free_space_mb \"$EXEDIR/tmp\") -ge 128 ] && [ $(get_ram_mb) -le 400 ] && {\n\t\techo\n\t\techo /tmp in openwrt is tmpfs. on low RAM systems there may be not enough RAM to store downloaded files\n\t\techo default tmpfs has size of 50% RAM\n\t\techo \"RAM  : $(get_ram_mb) Mb\"\n\t\techo \"DISK : $(get_free_space_mb) Mb\"\n\t\techo select temp file location\n\t\t[ -z \"$TMPDIR\" ] && TMPDIR=/tmp\n\t\task_list TMPDIR \"/tmp $EXEDIR/tmp\" && {\n\t\t    [ \"$TMPDIR\" = \"/tmp\" ] && TMPDIR=\n\t\t    write_config_var TMPDIR\n\t\t}\n\t}\n}\n\nnft_flow_offload()\n{\n\t[ \"$UNAME\" = Linux -a \"$FWTYPE\" = nftables ] && [ \"$FLOWOFFLOAD\" = software -o \"$FLOWOFFLOAD\" = hardware ]\n}\n\nask_iface()\n{\n\t# $1 - var to ask\n\t# $2 - additional name for empty string synonim\n\n\tlocal ifs i0 def new\n\teval def=\"\\$$1\"\n\n\t[ -n \"$2\" ] && i0=\"$2 \"\n\tcase $SYSTEM in\n\t\tmacos)\n\t\t\tifs=\"$(ifconfig -l)\"\n\t\t\t;;\n\t\t*)\n\t\t\tifs=\"$(ls /sys/class/net)\"\n\t\t\t;;\n\tesac\n\t[ -z \"$def\" ] && eval $1=\"$2\"\n\task_list $1 \"$i0$ifs\" && {\n\t\teval new=\"\\$$1\"\n\t\t[ \"$new\" = \"$2\" ] && eval $1=\"\"\n\t\twrite_config_var $1\n\t}\n}\nask_iface_lan()\n{\n\techo LAN interface :\n\tlocal opt\n\tnft_flow_offload || opt=NONE\n\task_iface IFACE_LAN $opt\n}\nask_iface_wan()\n{\n\techo WAN interface :\n\tlocal opt\n\tnft_flow_offload || opt=ANY\n\task_iface IFACE_WAN $opt\n}\n\nselect_mode_iface()\n{\n\t# openwrt has its own interface management scheme\n\t# filter just creates ip tables, no daemons involved\n\t# nfqws sits in POSTROUTING chain and unable to filter by incoming interface\n\t# tpws redirection works in PREROUTING chain\n\t# in tpws-socks mode IFACE_LAN specifies additional bind interface for the socks listener\n\t# it's not possible to instruct tpws to route outgoing connection to an interface (OS routing table decides)\n\t# custom mode can also benefit from interface names (depends on custom script code)\n\n\t[ \"$SYSTEM\" = \"openwrt\" ] && return\n\n\task_iface_lan\n\task_iface_wan\n}\n\ndefault_files()\n{\n\t# $1 - ro location\n\t# $2 - rw location (can be equal to $1)\n\t[ -d \"$2/ipset\" ] || mkdir -p \"$2/ipset\"\n\t[ -f \"$2/ipset/zapret-hosts-user-exclude.txt\" ] || cp \"$1/ipset/zapret-hosts-user-exclude.txt.default\" \"$2/ipset/zapret-hosts-user-exclude.txt\"\n\t[ -f \"$2/ipset/zapret-hosts-user.txt\" ] || echo nonexistent.domain >> \"$2/ipset/zapret-hosts-user.txt\"\n\t[ -f \"$2/ipset/zapret-hosts-user-ipban.txt\" ] || touch \"$2/ipset/zapret-hosts-user-ipban.txt\"\n\tfor dir in openwrt sysv macos; do\n\t\t[ -d \"$1/init.d/$dir\" ] && {\n\t\t\t[ -d \"$2/init.d/$dir\" ] || mkdir -p \"$2/init.d/$dir\"\n\t\t\t[ -d \"$2/init.d/$dir/custom.d\" ] || mkdir -p \"$2/init.d/$dir/custom.d\"\n\t\t}\n\tdone\n}\ncopy_all()\n{\n\tlocal dir\n\n\tcp -R \"$1\" \"$2\"\n\t[ -d \"$2/tmp\" ] || mkdir \"$2/tmp\"\n}\ncopy_openwrt()\n{\n\tlocal ARCH=\"$(get_bin_arch)\"\n\tlocal BINDIR=\"$1/binaries/$ARCH\"\n\tlocal file\n\n\t[ -d \"$2\" ] || mkdir -p \"$2\"\n\n\tmkdir \"$2/tpws\" \"$2/nfq\" \"$2/ip2net\" \"$2/mdig\" \"$2/binaries\" \"$2/binaries/$ARCH\" \"$2/init.d\" \"$2/tmp\" \"$2/files\"\n\tcp -R \"$1/files/fake\" \"$2/files\"\n\tcp -R \"$1/common\" \"$1/ipset\" \"$2\"\n\tcp -R \"$1/init.d/openwrt\" \"$1/init.d/custom.d.examples.linux\" \"$2/init.d\"\n\tcp \"$1/config\" \"$1/config.default\" \"$1/install_easy.sh\" \"$1/uninstall_easy.sh\" \"$1/install_bin.sh\" \"$1/install_prereq.sh\" \"$1/blockcheck.sh\" \"$2\"\n\tcp \"$BINDIR/tpws\" \"$BINDIR/nfqws\" \"$BINDIR/ip2net\" \"$BINDIR/mdig\" \"$2/binaries/$ARCH\"\n}\n\nfix_perms_bin_test()\n{\n\t[ -d \"$1\" ] || return\n\tfind \"$1/binaries\" -name ip2net ! -perm -111 -exec chmod +x {} \\;\n}\nfix_perms()\n{\n\t[ -d \"$1\" ] || return\n\tfind \"$1\" -type d -exec chmod 755 {} \\;\n\tfind \"$1\" -type f -exec chmod 644 {} \\;\n\tlocal chow\n\tcase \"$UNAME\" in\n\t\tLinux)\n\t\t\tchow=root:root\n\t\t\t;;\n\t\t*)\n\t\t\tchow=root:wheel\n\tesac\n\tchown -R $chow \"$1\"\n\tfind \"$1/binaries\" '(' -name tpws -o -name dvtws -o -name nfqws -o -name ip2net -o -name mdig ')' -exec chmod 755 {} \\;\n\tfor f in \\\ninstall_bin.sh \\\nblockcheck.sh \\\ninstall_easy.sh \\\ninstall_prereq.sh \\\nfiles/huawei/E8372/zapret-ip \\\nfiles/huawei/E8372/unzapret-ip \\\nfiles/huawei/E8372/run-zapret-hostlist \\\nfiles/huawei/E8372/unzapret \\\nfiles/huawei/E8372/zapret \\\nfiles/huawei/E8372/run-zapret-ip \\\nipset/get_exclude.sh \\\nipset/clear_lists.sh \\\nipset/get_refilter_domains.sh \\\nipset/get_refilter_ipsum.sh \\\nipset/get_antifilter_ipresolve.sh \\\nipset/get_reestr_resolvable_domains.sh \\\nipset/get_config.sh \\\nipset/get_reestr_preresolved.sh \\\nipset/get_user.sh \\\nipset/get_antifilter_allyouneed.sh \\\nipset/get_reestr_resolve.sh \\\nipset/create_ipset.sh \\\nipset/get_reestr_hostlist.sh \\\nipset/get_ipban.sh \\\nipset/get_antifilter_ipsum.sh \\\nipset/get_antifilter_ipsmart.sh \\\nipset/get_antizapret_domains.sh \\\nipset/get_reestr_preresolved_smart.sh \\\nipset/get_antifilter_ip.sh \\\ninit.d/pfsense/zapret.sh \\\ninit.d/macos/zapret \\\ninit.d/runit/zapret/run \\\ninit.d/runit/zapret/finish \\\ninit.d/openrc/zapret \\\ninit.d/sysv/zapret \\\ninit.d/openwrt/zapret \\\ninit.d/openwrt-minimal/tpws/etc/init.d/tpws \\\nuninstall_easy.sh \\\n\t; do chmod 755 \"$1/$f\" 2>/dev/null ; done\n}\n\n\n_backup_settings()\n{\n\tlocal i=0\n\tfor f in \"$@\"; do\n\t\t# safety check\n\t\t[ -z \"$f\" -o \"$f\" = \"/\" ] && continue\n\n\t\t[ -f \"$ZAPRET_TARGET/$f\" ] && cp -f \"$ZAPRET_TARGET/$f\" \"/tmp/zapret-bkp-$i\"\n\t\t[ -d \"$ZAPRET_TARGET/$f\" ] && cp -rf \"$ZAPRET_TARGET/$f\" \"/tmp/zapret-bkp-$i\"\n\t\ti=$(($i+1))\n\tdone\n}\n_restore_settings()\n{\n\tlocal i=0\n\tfor f in \"$@\"; do\n\t\t# safety check\n\t\t[ -z \"$f\" -o \"$f\" = \"/\" ] && continue\n\n\t\t[ -f \"/tmp/zapret-bkp-$i\" ] && {\n\t\t\tmv -f \"/tmp/zapret-bkp-$i\" \"$ZAPRET_TARGET/$f\" || rm -f \"/tmp/zapret-bkp-$i\"\n\t\t}\n\t\t[ -d \"/tmp/zapret-bkp-$i\" ] && {\n\t\t\t[ -d \"$ZAPRET_TARGET/$f\" ] && rm -r \"$ZAPRET_TARGET/$f\"\n\t\t\tmv -f \"/tmp/zapret-bkp-$i\" \"$ZAPRET_TARGET/$f\" || rm -r \"/tmp/zapret-bkp-$i\"\n\t\t}\n\t\ti=$(($i+1))\n\tdone\n}\nbackup_restore_settings()\n{\n\t# $1 - 1 - backup, 0 - restore\n\tlocal mode=$1\n\ton_off_function _backup_settings _restore_settings $mode \"config\" \"init.d/sysv/custom.d\" \"init.d/openwrt/custom.d\" \"init.d/macos/custom.d\" \"ipset/zapret-hosts-user.txt\" \"ipset/zapret-hosts-user-exclude.txt\" \"ipset/zapret-hosts-user-ipban.txt\" \"ipset/zapret-hosts-auto.txt\"\n}\n\nconfig_is_obsolete()\n{\n\t[ -f \"$1\" ] && grep -qE \"^[[:space:]]*NFQWS_OPT_DESYNC=|^[[:space:]]*MODE_HTTP=|^[[:space:]]*MODE_HTTPS=|^[[:space:]]*MODE_QUIC=|^[[:space:]]*MODE=\" \"$1\"\n}\n\ncheck_location()\n{\n\t# $1 - copy function\n\n\techo \\* checking location\n\t# use inodes in case something is linked\n\tif [ -d \"$ZAPRET_TARGET\" ] && [ $(get_dir_inode \"$EXEDIR\") = $(get_dir_inode \"$ZAPRET_TARGET\") ]; then\n\t\tconfig_is_obsolete \"$ZAPRET_CONFIG\" && {\n\t\t\techo config file $ZAPRET_CONFIG is obsolete. cannot continue.\n\t\t\texitp 3\n\t\t}\n\t\tdefault_files \"$ZAPRET_TARGET\" \"$ZAPRET_RW\"\n\telse\n\t\tlocal obsolete=0 rwdir=0\n\t\tconfig_is_obsolete \"$ZAPRET_TARGET_CONFIG\" && obsolete=1\n\t\t[ $(get_dir_inode \"$ZAPRET_BASE\") = $(get_dir_inode \"$ZAPRET_RW\") ] || rwdir=1\n\t\t[ $rwdir = 1 -a $obsolete = 1 ] && {\n                 \techo config file in custom ZAPRET_RW directory is obsolete : $ZAPRET_TARGET_CONFIG\n\t\t\techo you need to edit or delete it to continue. also check for obsolete custom scripts.\n\t\t\texitp 3\n\t\t}\n\t\techo\n\t\techo easy install is supported only from default location : $ZAPRET_TARGET\n\t\techo currently its run from $EXEDIR\n\t\tif ask_yes_no N \"do you want the installer to copy it for you\"; then\n\t\t\tlocal keep=N\n\t\t\tif [ -d \"$ZAPRET_TARGET\" ]; then\n\t\t\t\techo\n\t\t\t\techo installer found existing $ZAPRET_TARGET\n\t\t\t\techo directory needs to be replaced. config and custom scripts can be kept or replaced with clean version\n\t\t\t\tif ask_yes_no N \"do you want to delete all files there and copy this version\"; then\n\t\t\t\t\techo\n\t\t\t\t\tif [ $obsolete = 1 ] ; then\n\t\t\t\t\t\techo obsolete config is detected : $ZAPRET_TARGET_RW\n\t\t\t\t\t\task_yes_no N \"impossible to keep config, custom scripts and user lists. do you want to delete them ?\" || {\n\t\t\t\t\t\t\techo refused to delete config in $ZAPRET_TARGET. exiting\n\t\t\t\t\t\t\texitp 3\n\t\t\t\t\t\t}\n\t\t\t\t\telif [ $rwdir != 1 ]; then\n\t\t\t\t\t\task_yes_no Y \"keep config, custom scripts and user lists\" && keep=Y\n\t\t\t\t\t\t[ \"$keep\" = \"Y\" ] && backup_restore_settings 1\n\t\t\t\t\tfi\n\t\t\t\t\trm -r \"$ZAPRET_TARGET\"\n\t\t\t\telse\n\t\t\t\t\techo refused to overwrite $ZAPRET_TARGET. exiting\n\t\t\t\t\texitp 3\n\t\t\t\tfi\n\t\t\tfi\n\t\t\tlocal B=\"$(dirname \"$ZAPRET_TARGET\")\"\n\t\t\t[ -d \"$B\" ] || mkdir -p \"$B\"\n\t\t\t$1 \"$EXEDIR\" \"$ZAPRET_TARGET\"\n\t\t\tfix_perms \"$ZAPRET_TARGET\"\n\t\t\t[ \"$keep\" = \"Y\" ] && backup_restore_settings 0\n\t\t\techo relaunching itself from $ZAPRET_TARGET\n\t\t\texec \"$ZAPRET_TARGET/$(basename \"$0\")\"\n\t\telse\n\t\t\techo copying aborted. exiting\n\t\t\texitp 3\n\t\tfi\n\tfi\n\techo running from $EXEDIR\n}\n\n\nservice_install_systemd()\n{\n\techo \\* installing zapret service\n\n\tif [ -w \"$SYSTEMD_SYSTEM_DIR\" ] ; then\n\t\trm -f \"$INIT_SCRIPT\"\n\t\tcp -f \"$EXEDIR/init.d/systemd/zapret.service\" \"$SYSTEMD_SYSTEM_DIR\"\n\t\t\"$SYSTEMCTL\" daemon-reload\n\t\t\"$SYSTEMCTL\" enable zapret || {\n\t\t\techo could not enable systemd service\n\t\t\texitp 20\n\t\t}\n\telse\n\t\techo '!!! READONLY SYSTEM DETECTED !!! CANNOT INSTALL SYSTEMD UNITS !!!'\n\tfi\n}\n\ntimer_install_systemd()\n{\n\techo \\* installing zapret-list-update timer\n\n\tif [ -w \"$SYSTEMD_SYSTEM_DIR\" ] ; then\n\t\t\"$SYSTEMCTL\" disable zapret-list-update.timer\n\t\t\"$SYSTEMCTL\" stop zapret-list-update.timer\n\t\tcp -f \"$EXEDIR/init.d/systemd/zapret-list-update.service\" \"$SYSTEMD_SYSTEM_DIR\"\n\t\tcp -f \"$EXEDIR/init.d/systemd/zapret-list-update.timer\" \"$SYSTEMD_SYSTEM_DIR\"\n\t\t\"$SYSTEMCTL\" daemon-reload\n\t\t\"$SYSTEMCTL\" enable zapret-list-update.timer || {\n\t\t\techo could not enable zapret-list-update.timer\n\t\t\texitp 20\n\t\t}\n\t\t\"$SYSTEMCTL\" start zapret-list-update.timer || {\n\t\t\techo could not start zapret-list-update.timer\n\t\t\texitp 30\n\t\t}\n\telse\n\t\techo '!!! READONLY SYSTEM DETECTED !!! CANNOT INSTALL SYSTEMD UNITS !!!'\n\tfi\n}\n\ndownload_list()\n{\n\t[ -x \"$GET_LIST\" ] &&\t{\n\t\techo \\* downloading blocked ip/host list\n\n\t\t# can be txt or txt.gz\n\t\t\"$IPSET_DIR/clear_lists.sh\"\n\t\t\"$GET_LIST\"\n\t}\n}\n\n\ndnstest()\n{\n\t# $1 - dns server. empty for system resolver\n\tnslookup w3.org $1 >/dev/null 2>/dev/null\n}\ncheck_dns()\n{\n\techo \\* checking DNS\n\n\tdnstest || {\n\t\techo -- DNS is not working. It's either misconfigured or blocked or you don't have inet access.\n\t\treturn 1\n\t}\n\techo system DNS is working\n\treturn 0\n}\n\n\ninstall_systemd()\n{\n\tINIT_SCRIPT_SRC=\"$EXEDIR/init.d/sysv/zapret\"\n\tCUSTOM_DIR=\"$ZAPRET_RW/init.d/sysv\"\n\n\tcheck_bins\n\trequire_root\n\tcheck_readonly_system\n\tcheck_location copy_all\n\tcheck_dns\n\tcheck_virt\n\tservice_stop_systemd\n\tselect_fwtype\n\tcheck_prerequisites_linux\n\tinstall_binaries\n\tselect_ipv6\n\task_config_offload\n\task_config\n\tservice_install_systemd\n\tdownload_list\n\t# in case its left from old version of zapret\n\tcrontab_del_quiet\n\t# now we use systemd timers\n\ttimer_install_systemd\n\tservice_start_systemd\n}\n\n_install_sysv()\n{\n\t# $1 - install init script\n\n\tCUSTOM_DIR=\"$ZAPRET_RW/init.d/sysv\"\n\n\tcheck_bins\n\trequire_root\n\tcheck_readonly_system\n\tcheck_location copy_all\n\tcheck_dns\n\tcheck_virt\n\tservice_stop_sysv\n\tselect_fwtype\n\tcheck_prerequisites_linux\n\tinstall_binaries\n\tselect_ipv6\n\task_config_offload\n\task_config\n\t$1\n\tdownload_list\n\tcrontab_del_quiet\n\t# desktop system. more likely up at daytime\n\tcrontab_add 10 22\n\tservice_start_sysv\n}\n\ninstall_sysv()\n{\n\tINIT_SCRIPT_SRC=\"$EXEDIR/init.d/sysv/zapret\"\n\t_install_sysv install_sysv_init\n}\n\ninstall_openrc()\n{\n\tINIT_SCRIPT_SRC=\"$EXEDIR/init.d/openrc/zapret\"\n\t_install_sysv install_openrc_init\n}\n\n\ninstall_linux()\n{\n\tINIT_SCRIPT_SRC=\"$EXEDIR/init.d/sysv/zapret\"\n\tCUSTOM_DIR=\"$ZAPRET_RW/init.d/sysv\"\n\n\tcheck_bins\n\trequire_root\n\tcheck_location copy_all\n\tcheck_dns\n\tcheck_virt\n\tselect_fwtype\n\tcheck_prerequisites_linux\n\tinstall_binaries\n\tselect_ipv6\n\task_config_offload\n\task_config\n\tdownload_list\n\tcrontab_del_quiet\n\t# desktop system. more likely up at daytime\n\tcrontab_add 10 22\n\n\techo\n\techo '!!! WARNING. YOUR SETUP IS INCOMPLETE !!!'\n\techo you must manually add to auto start : $INIT_SCRIPT_SRC start\n\techo make sure it\\'s executed after your custom/firewall iptables configuration\n\techo \"if your system uses sysv init : ln -fs $INIT_SCRIPT_SRC /etc/init.d/zapret ; chkconfig zapret on\"\n}\n\n\ndeoffload_openwrt_firewall()\n{\n\techo \\* checking flow offloading\n\n\t[ \"$FWTYPE\" = \"nftables\" ] || is_ipt_flow_offload_avail || {\n\t\techo unavailable\n\t\treturn\n\t}\n\n\tlocal fo=$(uci -q get firewall.@defaults[0].flow_offloading)\n\n\tif [ \"$fo\" = \"1\" ] ; then\n\t\tlocal mod=0\n\t\tprintf \"system wide flow offloading detected. \"\n\t\tcase $FLOWOFFLOAD in\n\t\t\tdonttouch)\n\t\t\t\tif [ \"$NFQWS_ENABLE\" = \"1\" ]; then\n\t\t\t\t\techo its incompatible with nfqws tcp data tampering. disabling\n\t\t\t\t\tuci set firewall.@defaults[0].flow_offloading=0\n\t\t\t\t\tmod=1\n\t\t\t\telse\n\t\t\t\t\tif dir_is_not_empty \"$CUSTOM_DIR/custom.d\" ; then\n\t\t\t\t\t\techo\n\t\t\t\t\t\techo !!! CUSTOM SCRIPTS ARE PRESENT !!! only you can decide whether flow offloading is compatible.\n\t\t\t\t\t\techo !!! CUSTOM SCRIPTS ARE PRESENT !!! if they use nfqws they will not work. you have to disable system-wide offloading.\n\t\t\t\t\telse\n\t\t\t\t\t\techo its compatible with selected options. not disabling\n\t\t\t\t\tfi\n\t\t\t\tfi\n\t\t\t;;\n\t\t*)\n\t\t\techo zapret will disable system wide offloading setting and add selective rules if required\n\t\t\tuci set firewall.@defaults[0].flow_offloading=0\n\t\t\tmod=1\n\t\tesac\n\t\t[ \"$mod\" = \"1\" ] && uci commit firewall\n\telse\n\t\techo system wide software flow offloading disabled. ok\n\tfi\n}\n\n\n\ninstall_openwrt()\n{\n\tINIT_SCRIPT_SRC=\"$EXEDIR/init.d/openwrt/zapret\"\n\tCUSTOM_DIR=\"$ZAPRET_RW/init.d/openwrt\"\n\tFW_SCRIPT_SRC=\"$EXEDIR/init.d/openwrt/firewall.zapret\"\n\tOPENWRT_FW_INCLUDE=/etc/firewall.zapret\n\tOPENWRT_IFACE_HOOK=\"$EXEDIR/init.d/openwrt/90-zapret\"\n\n\tcheck_bins\n\trequire_root\n\tcheck_location copy_openwrt\n\tinstall_binaries\n\tcheck_dns\n\tcheck_virt\n\n\tlocal FWTYPE_OLD=$FWTYPE\n\n\techo \\* stopping current firewall rules/daemons\n\t\"$INIT_SCRIPT_SRC\" stop_fw\n\t\"$INIT_SCRIPT_SRC\" stop_daemons\n\n\tselect_fwtype\n\tselect_ipv6\n\tcheck_prerequisites_openwrt\n\task_config\n\task_config_tmpdir\n\task_config_offload\n\t# stop and reinstall sysv init\n\tinstall_sysv_init\n\t[ \"$FWTYPE_OLD\" != \"$FWTYPE\" -a \"$FWTYPE_OLD\" = iptables -a -n \"$OPENWRT_FW3\" ] && remove_openwrt_firewall\n\t# free some RAM\n\tclear_ipset\n\tdownload_list\n\tcrontab_del_quiet\n\t# router system : works 24/7. night is the best time\n\tcrontab_add 0 6\n\tcron_ensure_running\n\tinstall_openwrt_iface_hook\n\t# in case of nftables or iptables without fw3 sysv init script also controls firewall\n\t[ -n \"$OPENWRT_FW3\" -a \"$FWTYPE\" = iptables ] && install_openwrt_firewall\n\tservice_start_sysv\n\tdeoffload_openwrt_firewall\n\trestart_openwrt_firewall\n}\n\n\n\nremove_pf_zapret_hooks()\n{\n\techo \\* removing zapret PF hooks\n\n\tpf_anchors_clear\n}\n\nmacos_fw_reload_trigger_clear()\n{\n\tLISTS_RELOAD=\n\twrite_config_var LISTS_RELOAD\n}\nmacos_fw_reload_trigger_set()\n{\n\tLISTS_RELOAD=\"$INIT_SCRIPT_SRC reload-fw-tables\"\n\twrite_config_var LISTS_RELOAD\n}\n\ninstall_macos()\n{\n\tINIT_SCRIPT_SRC=\"$EXEDIR/init.d/macos/zapret\"\n\tCUSTOM_DIR=\"$ZAPRET_RW/init.d/macos\"\n\n\t# compile before root\n\tcheck_bins\n\trequire_root\n\tcheck_location copy_all\n\tservice_stop_macos\n\tremove_pf_zapret_hooks\n\tinstall_binaries\n\tcheck_dns\n\tselect_ipv6\n\task_config\n\tservice_install_macos\n\tmacos_fw_reload_trigger_clear\n\t# gzip lists are incompatible with PF\n\tGZIP_LISTS=0 write_config_var GZIP_LISTS\n\tdownload_list\n\tmacos_fw_reload_trigger_set\n\tcrontab_del_quiet\n\t# desktop system. more likely up at daytime\n\tcrontab_add 10 22\n\tservice_start_macos\n}\n\n\n# build binaries, do not use precompiled\n[ \"$1\" = \"make\" ] && FORCE_BUILD=1\n\numask 0022\nfix_sbin_path\nfsleep_setup\ncheck_system\n\n[ \"$SYSTEM\" = \"macos\" ] && . \"$EXEDIR/init.d/macos/functions\"\n\ncase $SYSTEM in\n\tsystemd)\n\t\tinstall_systemd\n\t\t;;\n\topenrc)\n\t\tinstall_openrc\n\t\t;;\n\tlinux)\n\t\tinstall_linux\n\t\t;;\n\topenwrt)\n\t\tinstall_openwrt\n\t\t;;\n\tmacos)\n\t\tinstall_macos\n\t\t;;\nesac\n\n\nexitp 0\n"
        },
        {
          "name": "install_prereq.sh",
          "type": "blob",
          "size": 1.0166015625,
          "content": "#!/bin/sh\n\n# install prerequisites\n\nEXEDIR=\"$(dirname \"$0\")\"\nEXEDIR=\"$(cd \"$EXEDIR\"; pwd)\"\nZAPRET_BASE=${ZAPRET_BASE:-\"$EXEDIR\"}\nZAPRET_RW=${ZAPRET_RW:-\"$ZAPRET_BASE\"}\nZAPRET_CONFIG=${ZAPRET_CONFIG:-\"$ZAPRET_RW/config\"}\nZAPRET_CONFIG_DEFAULT=\"$ZAPRET_BASE/config.default\"\n\n[ -f \"$ZAPRET_CONFIG\" ] || {\n\tZAPRET_CONFIG_DIR=\"$(dirname \"$ZAPRET_CONFIG\")\"\n\t[ -d \"$ZAPRET_CONFIG_DIR\" ] || mkdir -p \"$ZAPRET_CONFIG_DIR\"\n\tcp \"$ZAPRET_CONFIG_DEFAULT\" \"$ZAPRET_CONFIG\"\n}\n\n. \"$ZAPRET_CONFIG\"\n. \"$ZAPRET_BASE/common/base.sh\"\n. \"$ZAPRET_BASE/common/elevate.sh\"\n. \"$ZAPRET_BASE/common/fwtype.sh\"\n. \"$ZAPRET_BASE/common/dialog.sh\"\n. \"$ZAPRET_BASE/common/installer.sh\"\n. \"$ZAPRET_BASE/common/ipt.sh\"\n\numask 0022\nfix_sbin_path\nfsleep_setup\ncheck_system accept_unknown_rc\n[ $UNAME = \"Linux\" ] || {\n\techo no prerequisites required for $UNAME\n\texitp 0\n}\nrequire_root\n\ncase $UNAME in\n\tLinux)\n\t\tselect_fwtype\n\t\tcase $SYSTEM in\n\t\t\topenwrt)\n\t\t\t\tselect_ipv6\n\t\t\t\tcheck_prerequisites_openwrt\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\tcheck_prerequisites_linux\n\t\t\t\t;;\n\t\tesac\n\t\t;;\nesac\n\nexitp 0\n"
        },
        {
          "name": "ip2net",
          "type": "tree",
          "content": null
        },
        {
          "name": "ipset",
          "type": "tree",
          "content": null
        },
        {
          "name": "mdig",
          "type": "tree",
          "content": null
        },
        {
          "name": "nfq",
          "type": "tree",
          "content": null
        },
        {
          "name": "tmp",
          "type": "tree",
          "content": null
        },
        {
          "name": "tpws",
          "type": "tree",
          "content": null
        },
        {
          "name": "uninstall_easy.sh",
          "type": "blob",
          "size": 1.9248046875,
          "content": "#!/bin/sh\n\n# automated script for easy uninstalling zapret\n\nEXEDIR=\"$(dirname \"$0\")\"\nEXEDIR=\"$(cd \"$EXEDIR\"; pwd)\"\nZAPRET_BASE=${ZAPRET_BASE:-\"$EXEDIR\"}\nZAPRET_RW=${ZAPRET_RW:-\"$ZAPRET_BASE\"}\nZAPRET_CONFIG=${ZAPRET_CONFIG:-\"$ZAPRET_RW/config\"}\nZAPRET_CONFIG_DEFAULT=\"$ZAPRET_BASE/config.default\"\nIPSET_DIR=\"$ZAPRET_BASE/ipset\"\n\n[ -f \"$ZAPRET_CONFIG\" ] || {\n\tZAPRET_CONFIG_DIR=\"$(dirname \"$ZAPRET_CONFIG\")\"\n\t[ -d \"$ZAPRET_CONFIG_DIR\" ] || mkdir -p \"$ZAPRET_CONFIG_DIR\"\n\tcp \"$ZAPRET_CONFIG_DEFAULT\" \"$ZAPRET_CONFIG\"\n}\n\n. \"$ZAPRET_CONFIG\"\n. \"$ZAPRET_BASE/common/base.sh\"\n. \"$ZAPRET_BASE/common/elevate.sh\"\n. \"$ZAPRET_BASE/common/fwtype.sh\"\n. \"$ZAPRET_BASE/common/dialog.sh\"\n. \"$ZAPRET_BASE/common/ipt.sh\"\n. \"$ZAPRET_BASE/common/nft.sh\"\n. \"$ZAPRET_BASE/common/pf.sh\"\n. \"$ZAPRET_BASE/common/installer.sh\"\n\nremove_systemd()\n{\n\tclear_ipset\n\tservice_stop_systemd\n\tservice_remove_systemd\n\ttimer_remove_systemd\n\tnft_del_table\n\tcrontab_del\n}\n\nremove_openrc()\n{\n\tclear_ipset\n\tservice_remove_openrc\n\tnft_del_table\n\tcrontab_del\n}\n\nremove_linux()\n{\n\tINIT_SCRIPT_SRC=\"$EXEDIR/init.d/sysv/zapret\"\n\n\tclear_ipset\n\n\techo \\* executing sysv init stop\n\t\"$INIT_SCRIPT_SRC\" stop\n\t\n\tnft_del_table\n\tcrontab_del\n\n\techo\n\techo '!!! WARNING. YOUR UNINSTALL IS INCOMPLETE !!!'\n\techo 'you must manually remove zapret auto start from your system'\n}\n\nremove_openwrt()\n{\n\tOPENWRT_FW_INCLUDE=/etc/firewall.zapret\n\n\tclear_ipset\n\tservice_remove_sysv\n\tremove_openwrt_firewall\n\tremove_openwrt_iface_hook\n\tnft_del_table\n\trestart_openwrt_firewall\n\tcrontab_del\n\tremove_extra_pkgs_openwrt\n\techo\n\techo to fully remove zapret : rm -r \\\"$ZAPRET_BASE\\\"\n}\n\nremove_macos()\n{\n\tremove_macos_firewall\n\tservice_remove_macos\n\tcrontab_del\n}\n\n\nfix_sbin_path\ncheck_system\nrequire_root\n\n[ \"$SYSTEM\" = \"macos\" ] && . \"$EXEDIR/init.d/macos/functions\"\n\ncase $SYSTEM in\n\tsystemd)\n\t\tremove_systemd\n\t\t;;\n\topenrc)\n\t\tremove_openrc\n\t\t;;\n\tlinux)\n\t\tremove_linux\n\t\t;;\n\topenwrt)\n\t\tremove_openwrt\n\t\t;;\n\tmacos)\n\t\tremove_macos\n\t\t;;\nesac\n\n\nexitp 0\n"
        }
      ]
    }
  ]
}