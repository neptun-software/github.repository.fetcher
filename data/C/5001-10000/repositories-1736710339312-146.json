{
  "metadata": {
    "timestamp": 1736710339312,
    "page": 146,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "nelhage/reptyr",
      "stars": 5867,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".cirrus.yml",
          "type": "blob",
          "size": 0.205078125,
          "content": "freebsd_12_task:\n  freebsd_instance:\n    image: freebsd-12-4-release-amd64\n  install_script:\n    pkg install -y gmake py39-pexpect\n  build_script:\n    gmake\n  test_script:\n    - gmake test PYTHON_CMD=python3.9\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0322265625,
          "content": "reptyr\nptrace\n*.o\n*.d\n/.vagrant/\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.1904296875,
          "content": "script: make test\nlanguage: python\npython:\n  - \"3.7\"\ninstall:\n  - pip install -r test/requirements.txt\narch:\n  - arm64\naddons:\n  apt:\n    packages:\n      - libcap-dev\nenv:\n  - PYTHON_CMD=python3\n"
        },
        {
          "name": "COPYING",
          "type": "blob",
          "size": 1.03515625,
          "content": "Copyright (C) 2011 by Nelson Elhage\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "ChangeLog",
          "type": "blob",
          "size": 1.275390625,
          "content": "* 0.10.0 (Jun 04, 2023)\n - Add arm7 and aarch64 support for FreeBSD\n\n* 0.9.0 (Jun 12, 2022)\n - Add RISCV64 support on Linux\n - Fix tty-stealing on PowerPC\n\n* 0.8.0 (Sep 29, 2020)\n - Resolve a number of bugs in FreeBSD support\n - Implement reptyr -T support for FreeBSD\n\n* 0.7.0 (Dec 05, 2018)\n - Add bash completion support\n - Fix compilation with musl libc, CentOS, or GCC 7+\n - Support for PowerPC and aarch64\n\n* 0.6.2 (Jan 31, 2015)\n - Fix tty-stealing on i386\n\n* 0.6.1 (Jan 18, 2015)\n - Fix compilation when chown is declared as `warn_unused_result``\n\n* 0.6 (Jan 4, 2015)\n - Add -T (\"tty-stealing\") mode, which works on processes with children.\n   See https://blog.nelhage.com/2014/08/new-reptyr-feature-tty-stealing/\n - Added FreeBSD support\n - Minor bugfixes\n\n* 0.5 (Jun 5, 2013)\n - Add an early check and error if attaching a process with children.\n\n* 0.4 (Aug 16, 2012)\n - Add support for scripting with the -l flag.\n - Add a French translation of the man page\n - Add a -V flag\n\n* 0.3 (May 27, 2011)\n - Add support for attaching 32-bit programs on x86_64.\n - Fix a bug on ARM.\n\n* 0.2 (Mar 1, 2011)\n - Add a man page\n - Add a 'make install' target\n - Improve detection of which fd's to attach,\n - Add a '-s' option to attach programs not currently on a tty.\n\n* 0.1 (Jan 27, 2011)\n - Initial release\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 1.708984375,
          "content": "override CFLAGS := -MD -Wall -Werror -D_GNU_SOURCE -g $(CFLAGS)\nOBJS=reptyr.o reallocarray.o attach.o\nDEPS=$(wildcard *.d platform/*/*.d)\nUNAME_S := $(shell uname -s)\nifeq ($(UNAME_S),Linux)\n\tOBJS += platform/linux/linux_ptrace.o platform/linux/linux.o\nendif\nifeq ($(UNAME_S),FreeBSD)\n\tOBJS += platform/freebsd/freebsd_ptrace.o platform/freebsd/freebsd.o\n\tLDFLAGS += -lprocstat\nendif\n# Note that because of how Make works, this can be overridden from the\n# command-line.\n#\n# e.g. install to /usr with `make PREFIX=/usr`\nPREFIX=/usr/local\nBINDIR=$(PREFIX)/bin\nMANDIR=$(PREFIX)/share/man\n\nPKG_CONFIG ?= pkg-config\nPYTHON_CMD ?= python2\n\nall: reptyr\n\nreptyr: $(OBJS)\n\nifeq ($(DISABLE_TESTS),)\ntest: reptyr test/victim PHONY\n\t$(PYTHON_CMD) test/basic.py\n\t$(PYTHON_CMD) test/tty-steal.py\nelse\ntest: all\nendif\n\nVICTIM_CFLAGS ?= $(CFLAGS)\nVICTIM_LDFLAGS ?= $(LDFLAGS)\ntest/victim: test/victim.o\ntest/victim: override CFLAGS := $(VICTIM_CFLAGS)\ntest/victim: override LDFLAGS := $(VICTIM_LDFLAGS)\n\nclean:\n\trm -f reptyr $(OBJS) test/victim.o test/victim $(DEPS)\n\nBASHCOMPDIR ?= $(shell $(PKG_CONFIG) --variable=completionsdir bash-completion 2>/dev/null)\n\ninstall: reptyr\n\tinstall -d -m 755 $(DESTDIR)$(BINDIR)\n\tinstall -m 755 reptyr $(DESTDIR)$(BINDIR)/reptyr\n\tinstall -d -m 755 $(DESTDIR)$(MANDIR)/man1\n\tinstall -m 644 reptyr.1 $(DESTDIR)$(MANDIR)/man1/reptyr.1\n\tinstall -d -m 755 $(DESTDIR)$(MANDIR)/fr/man1\n\tinstall -m 644 reptyr.fr.1 $(DESTDIR)$(MANDIR)/fr/man1/reptyr.1\n\tbashcompdir=$(BASHCOMPDIR) ; \\\n\ttest -z \"$$bashcompdir\" && bashcompdir=/etc/bash_completion.d ; \\\n\tinstall -d -m 755 $(DESTDIR)$$bashcompdir ; \\\n\tinstall -m 644 reptyr.bash $(DESTDIR)$$bashcompdir/reptyr\n\n.PHONY: PHONY\n\n# Pull-in dependencies generated by -MD\n-include $(OBJS:.o=.d)\n"
        },
        {
          "name": "NOTES",
          "type": "blob",
          "size": 0.4453125,
          "content": "Attaching:\n - Find an fd corresponding to the tty in the child\n - Open the new pty in the child\n - Copy the termios settings over\n - dup() it over the old ones\n - Make the new tty the controlling tty:\n  - Fork a dummy child\n  - Find all processes in the child's process group.\n   - For each one, move them to the dummy child's process group\n  - Make the child setsid()\n  - Set the terminal as the controlling tty\n - Close the newly allocated tty\n - Detach\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.3505859375,
          "content": "reptyr - A tool for \"re-ptying\" programs.\n=========================================\n\nreptyr is a utility for taking an existing running program and\nattaching it to a new terminal. Started a long-running process over\nssh, but have to leave and don't want to interrupt it? Just start a\nscreen, use reptyr to grab it, and then kill the ssh session and head\non home.\n\nUSAGE\n-----\n\n    reptyr PID\n\n\"reptyr PID\" will grab the process with id PID and attach it to your\ncurrent terminal.\n\nAfter attaching, the process will take input from and write output to\nthe new terminal, including ^C and ^Z. (Unfortunately, if you\nbackground it, you will still have to run \"bg\" or \"fg\" in the old\nterminal. This is likely impossible to fix in a reasonable way without\npatching your shell.)\n\nTypical usage pattern\n---------------------\n\n* Start a long running process, e.g. `top`\n* Background the process with CTRL-Z\n* Resume the process in the background: `bg`\n* Display your running background jobs with `jobs -l`, this should look like this:\n  * `[1]+  4711 Stopped (signal)        top`\n  * (The `-l` in `jobs -l` makes sure you'll get the PID)\n* Disown the jobs from the current parent with `disown top`. After that, `jobs` will not show the job any more, but `ps -a` will.\n* Start your terminal multiplexer of choice, e.g. `tmux`\n* Reattach to the backgrounded process: `reptyr 4711`\n* Detach your terminal multiplexer (e.g. CTRL-A D) and close ssh\n* Reconnect ssh, attach to your multiplexer (e.g. `tmux attach`), rejoice!\n\n\"But wait, isn't this just screenify?\"\n--------------------------------------\n\nThere's a shell script called \"screenify\" that's been going around the\ninternet for nigh on 10 years now that uses gdb to (supposedly)\naccomplish the same thing. The difference is that reptyr works much,\nmuch, better.\n\nIf you attach a \"less\" using screenify, it will still take input from\nthe old terminal. If you attach an ncurses program using screenify,\nand resize the window, your program won't notice. If you attach a\nprocess with screenify, ^C in the new terminal won't work.\n\nreptyr fixes all of these problems, and is the only such tool I know\nof that does so. See below for some more details on how it\naccomplishes this.\n\nPORTABILITY\n-----------\n\nreptyr supports Linux and FreeBSD. Not all functionality is currently\navailable on FreeBSD. (Notably, FreeBSD doesn't support `reptyr -T` at\nthis time.\n\n`reptyr` uses ptrace to attach to the target and control it at the\nsyscall level, so it is highly dependent on details of the syscall\nAPI, available syscalls, and terminal ioctl()s. A port to other\noperating systems may be technically feasible, but requires\nsignificant low-level knowledge of the relevant platform, and may\nentail significant refactors.\n\nreptyr works on i386, x86_64, and ARM. Ports to other architectures should be\nstraightforward, and should in most cases be as simple as adding an arch/ARCH.h\nfile and adding a clause to the ifdef ladder in ptrace.c.\n\nptrace_scope on Ubuntu Maverick and up\n--------------------------------------\n\n`reptyr` depends on the `ptrace` system call to attach to the remote program. On\nUbuntu Maverick and higher, this ability is disabled by default for security\nreasons. You can enable it temporarily by doing\n\n    # echo 0 > /proc/sys/kernel/yama/ptrace_scope\n\nas root, or permanently by editing the file /etc/sysctl.d/10-ptrace.conf, which\nalso contains more information about exactly what this setting accomplishes.\n\nreptyr -l\n---------\n\nAs a bonus feature, if you run \"reptyr -l\", reptyr will create a new\npseudo-terminal pair with nothing attached to the slave end, and print\nits name out.\n\nIf you are debugging a program in gdb, you can pass that name to \"set\ninferior-pty\". Because there is no existing program listening to that\ntty, this will work much better than passing an existing shell's\nterminal.\n\nHow does it work?\n-----------------\n\nThe main thing that reptyr does that no one else does is that it\nactually changes the controlling terminal of the process you are\nattaching. I wrote a\n[blog post](https://blog.nelhage.com/2011/02/changing-ctty/)\nexplaining just what the shenanigans involved are.\n\nPRONUNCIATION\n-------------\n\nI pronounce it like \"repeater\", but since that's easily ambiguous,\n\"re-P-T-Y-er\" is also acceptable.\n\n\nCREDITS\n-------\nreptyr was written by Nelson Elhage <nelhage@nelhage.com>. Contact him\nwith any questions or bug reports.\n\nURL\n---\nhttp://github.com/nelhage/reptyr\n"
        },
        {
          "name": "Vagrantfile",
          "type": "blob",
          "size": 0.8623046875,
          "content": "# -*- mode: ruby -*-\n# vi: set ft=ruby :\n\nVAGRANTFILE_API_VERSION = \"2\"\n\n# This Vagrantfile is only for FreeBSD testing; I do Linux development\n# natively.\nVagrant.configure(VAGRANTFILE_API_VERSION) do |config|\n  config.vm.define \"freebsd\" do |machine|\n    machine.vm.box = 'chef/freebsd-10.0'\n    machine.vm.provision 'shell', inline: <<EOS\nsudo pkg install -y gmake\nEOS\n\n    machine.ssh.shell = '/bin/sh'\n  end\n\n  config.vm.define 'fedora-20-x86' do |machine|\n    machine.vm.box = 'chef/fedora-20-i386'\n  end\n\n  config.vm.define 'fedora-20-x86_64' do |machine|\n    machine.vm.box = 'chef/fedora-20'\n  end\n\n  config.vm.define 'centos-6-x86_64' do |machine|\n    machine.vm.box = 'bento/centos-6.7'\n  end\n\n  config.vm.define 'centos-5-x86_64' do |machine|\n    machine.vm.box = 'bento/centos-5.11'\n  end\n\n  config.vm.synced_folder \".\", \"/vagrant\", type: 'nfs', id: 'vagrant-root'\n\nend\n"
        },
        {
          "name": "attach.c",
          "type": "blob",
          "size": 17.5341796875,
          "content": "/*\n * Copyright (C) 2011 by Nelson Elhage\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n#include <sys/types.h>\n#include <stdint.h>\n#include <dirent.h>\n#include <sys/syscall.h>\n#include <sys/mman.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <limits.h>\n#include <time.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n\n#include \"ptrace.h\"\n#include \"reptyr.h\"\n#include \"reallocarray.h\"\n#include \"platform/platform.h\"\n\nint fd_array_push(struct fd_array *fda, int fd) {\n    int *tmp;\n\n    if (fda->n == fda->allocated) {\n        fda->allocated = fda->allocated ? 2 * fda->allocated : 2;\n        tmp = xreallocarray(fda->fds, fda->allocated, sizeof *tmp);\n        if (tmp == NULL) {\n            free(fda->fds);\n            fda->fds = NULL;\n            fda->allocated = 0;\n            return -1;\n        }\n        fda->fds = tmp;\n    }\n    fda->fds[fda->n++] = fd;\n    return 0;\n}\n\nstatic void do_unmap(struct ptrace_child *child, child_addr_t addr, unsigned long len) {\n    if (addr == (child_addr_t) - 1)\n        return;\n    do_syscall(child, munmap, (unsigned long)addr, len, 0, 0, 0, 0);\n}\n\nstatic int do_fork(struct ptrace_child *child) {\n    if (ptrace_syscall_numbers(child)->nr_fork != -1) {\n        return do_syscall(child, fork, 0, 0, 0, 0, 0, 0);\n    } else {\n        return do_syscall(child, clone, SIGCHLD, 0, 0, 0, 0, 0);\n    }\n}\n\nint do_setsid(struct ptrace_child *child) {\n    int err = 0;\n    struct ptrace_child dummy;\n\n    err = do_fork(child);\n    if (err < 0)\n        return err;\n\n    debug(\"Forked a child: %ld\", child->forked_pid);\n\n    err = ptrace_finish_attach(&dummy, child->forked_pid);\n    if (err < 0)\n        goto out_kill;\n\n    dummy.state = ptrace_after_syscall;\n    copy_user(&dummy, child);\n    if (ptrace_restore_regs(&dummy)) {\n        err = dummy.error;\n        goto out_kill;\n    }\n\n    err = do_syscall(&dummy, setpgid, 0, 0, 0, 0, 0, 0);\n    if (err < 0) {\n        error(\"Failed to setpgid: %s\", strerror(-err));\n        goto out_kill;\n    }\n\n    move_process_group(child, child->pid, dummy.pid);\n\n    err = do_syscall(child, setsid, 0, 0, 0, 0, 0, 0);\n    if (err < 0) {\n        error(\"Failed to setsid: %s\", strerror(-err));\n        move_process_group(child, dummy.pid, child->pid);\n        goto out_kill;\n    }\n\n    debug(\"Did setsid()\");\n\nout_kill:\n    kill(dummy.pid, SIGKILL);\n    ptrace_detach_child(&dummy);\n    ptrace_wait(&dummy);\n    do_syscall(child, wait4, dummy.pid, 0, WNOHANG, 0, 0, 0);\n    return err;\n}\n\nstatic int do_dup2(struct ptrace_child *child, int oldfd, int newfd) {\n    if (oldfd == newfd) {\n        return 0;\n    }\n    if (ptrace_syscall_numbers(child)->nr_dup2 != -1) {\n        return do_syscall(child, dup2, oldfd, newfd, 0, 0, 0, 0);\n    } else {\n        return do_syscall(child, dup3, oldfd, newfd, 0, 0, 0, 0);\n    }\n}\n\nint ignore_hup(struct ptrace_child *child, child_addr_t scratch_page) {\n    int err;\n\n    struct sigaction act = {\n        .sa_handler = SIG_IGN,\n    };\n    err = ptrace_memcpy_to_child(child, scratch_page,\n                                 &act, sizeof act);\n    if (err < 0)\n        return err;\n    err = do_syscall(child, rt_sigaction,\n                     SIGHUP, (unsigned long)scratch_page,\n                     0, 8, 0, 0);\n\n    return err;\n}\n\n/*\n * Wait for the specific pid to enter state 'T', or stopped. We have to pull the\n * /proc file rather than attaching with ptrace() and doing a wait() because\n * half the point of this exercise is for the process's real parent (the shell)\n * to see the TSTP.\n *\n * In case the process is masking or ignoring SIGTSTP, we time out after a\n * second and continue with the attach -- it'll still work mostly right, you\n * just won't get the old shell back.\n */\nvoid wait_for_stop(pid_t pid, int fd) {\n    struct timeval start, now;\n    struct timespec sleep;\n\n    gettimeofday(&start, NULL);\n    while (1) {\n        gettimeofday(&now, NULL);\n        if ((now.tv_sec > start.tv_sec && now.tv_usec > start.tv_usec)\n                || (now.tv_sec - start.tv_sec > 1)) {\n            error(\"Timed out waiting for child stop.\");\n            break;\n        }\n        /*\n         * If anything goes wrong reading or parsing the stat node, just give\n         * up.\n         */\n        if (check_proc_stopped(pid, fd))\n            break;\n\n        sleep.tv_sec  = 0;\n        sleep.tv_nsec = 10000000;\n        nanosleep(&sleep, NULL);\n    }\n}\n\nint copy_tty_state(pid_t pid, const char *pty) {\n    int fd, err = EINVAL;\n    struct termios tio;\n\n    err = get_process_tty_termios(pid, &tio);\n\n    if (err)\n        return err;\n\n    if ((fd = open(pty, O_RDONLY)) < 0)\n        return -assert_nonzero(errno);\n\n    if (tcsetattr(fd, TCSANOW, &tio) < 0)\n        err = assert_nonzero(errno);\n    close(fd);\n    return -err;\n}\n\nint mmap_scratch(struct ptrace_child *child, child_addr_t *addr) {\n    long mmap_syscall;\n    child_addr_t scratch_page;\n\n    mmap_syscall = ptrace_syscall_numbers(child)->nr_mmap2;\n    if (mmap_syscall == -1)\n        mmap_syscall = ptrace_syscall_numbers(child)->nr_mmap;\n    scratch_page = ptrace_remote_syscall(child, mmap_syscall, 0,\n                                         sysconf(_SC_PAGE_SIZE), PROT_READ | PROT_WRITE,\n                                         MAP_ANONYMOUS | MAP_SHARED, -1, 0);\n    //MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);\n\n    if (scratch_page > (unsigned long) - 1000) {\n        return -(signed long)scratch_page;\n    }\n\n    *addr = scratch_page;\n    debug(\"Allocated scratch page: %lx\", scratch_page);\n\n    return 0;\n}\n\nint grab_pid(pid_t pid, struct ptrace_child *child, child_addr_t *scratch) {\n    int err;\n\n    if (ptrace_attach_child(child, pid)) {\n        err = child->error;\n        goto out;\n    }\n    if (ptrace_advance_to_state(child, ptrace_at_syscall)) {\n        err = child->error;\n        goto out;\n    }\n    if (ptrace_save_regs(child)) {\n        err = child->error;\n        goto out;\n    }\n\n    if ((err = mmap_scratch(child, scratch)))\n        goto out_restore_regs;\n\n    return 0;\n\nout_restore_regs:\n    ptrace_restore_regs(child);\n\nout:\n    ptrace_detach_child(child);\n\n    return err;\n}\n\nint preflight_check(pid_t pid) {\n    struct ptrace_child child;\n    debug(\"Making sure we have permission to attach...\");\n    if (ptrace_attach_child(&child, pid)) {\n        return child.error;\n    }\n    ptrace_detach_child(&child);\n    return 0;\n}\n\nint attach_child(pid_t pid, const char *pty, int force_stdio) {\n    struct ptrace_child child;\n    child_addr_t scratch_page = -1;\n    int *child_tty_fds = NULL, n_fds, child_fd, statfd = -1;\n    int i;\n    int err = 0;\n    long page_size = sysconf(_SC_PAGE_SIZE);\n#ifdef __linux__\n    char stat_path[PATH_MAX];\n#endif\n\n    if ((err = check_pgroup(pid))) {\n        return err;\n    }\n\n    if ((err = preflight_check(pid))) {\n        return err;\n    }\n\n    debug(\"Using tty: %s\", pty);\n\n    if ((err = copy_tty_state(pid, pty))) {\n        if (err == ENOTTY && !force_stdio) {\n            error(\"Target is not connected to a terminal.\\n\"\n                  \"    Use -s to force attaching anyways.\");\n            return err;\n        }\n    }\n\n#ifdef __linux__\n    snprintf(stat_path, sizeof stat_path, \"/proc/%d/stat\", pid);\n    statfd = open(stat_path, O_RDONLY);\n    if (statfd < 0) {\n        error(\"Unable to open %s: %s\", stat_path, strerror(errno));\n        return -statfd;\n    }\n#endif\n\n    kill(pid, SIGTSTP);\n    wait_for_stop(pid, statfd);\n\n    if ((err = grab_pid(pid, &child, &scratch_page))) {\n        goto out_cont;\n    }\n\n    if (force_stdio) {\n        child_tty_fds = malloc(3 * sizeof(int));\n        if (!child_tty_fds) {\n            err = ENOMEM;\n            goto out_unmap;\n        }\n        n_fds = 3;\n        child_tty_fds[0] = 0;\n        child_tty_fds[1] = 1;\n        child_tty_fds[2] = 2;\n    } else {\n        child_tty_fds = get_child_tty_fds(&child, statfd, &n_fds);\n        if (!child_tty_fds) {\n            err = child.error;\n            goto out_unmap;\n        }\n    }\n\n    if (ptrace_memcpy_to_child(&child, scratch_page, pty, strlen(pty) + 1)) {\n        err = child.error;\n        error(\"Unable to memcpy the pty path to child.\");\n        goto out_free_fds;\n    }\n\n    child_fd = do_syscall(&child, openat,\n                          -1, scratch_page, O_RDWR | O_NOCTTY,\n                          0, 0, 0);\n    if (child_fd < 0) {\n        err = child_fd;\n        error(\"Unable to open the tty in the child.\");\n        goto out_free_fds;\n    }\n\n    debug(\"Opened the new tty in the child: %d\", child_fd);\n\n    err = ignore_hup(&child, scratch_page);\n    if (err < 0)\n        goto out_close;\n\n    err = do_syscall(&child, getsid, 0, 0, 0, 0, 0, 0);\n    if (err != child.pid) {\n        debug(\"Target is not a session leader, attempting to setsid.\");\n        err = do_setsid(&child);\n    } else {\n        do_syscall(&child, ioctl, child_tty_fds[0], TIOCNOTTY, 0, 0, 0, 0);\n    }\n    if (err < 0)\n        goto out_close;\n\n    err = do_syscall(&child, ioctl, child_fd, TIOCSCTTY, 1, 0, 0, 0);\n    if (err != 0) { /* Seems to be returning >0 for error */\n        error(\"Unable to set controlling terminal: %s\", strerror(err));\n        goto out_close;\n    }\n\n    debug(\"Set the controlling tty\");\n\n    for (i = 0; i < n_fds; i++) {\n        err = do_dup2(&child, child_fd, child_tty_fds[i]);\n        if (err < 0)\n            error(\"Problem moving child fd number %d to new tty: %s\", child_tty_fds[i], strerror(errno));\n    }\n\n\n    err = 0;\n\nout_close:\n    do_syscall(&child, close, child_fd, 0, 0, 0, 0, 0);\nout_free_fds:\n    free(child_tty_fds);\n\nout_unmap:\n    do_unmap(&child, scratch_page, page_size);\n\n    ptrace_restore_regs(&child);\n    ptrace_detach_child(&child);\n\n    if (err == 0) {\n        kill(child.pid, SIGSTOP);\n        wait_for_stop(child.pid, statfd);\n    }\n    kill(child.pid, SIGWINCH);\nout_cont:\n    kill(child.pid, SIGCONT);\n#ifdef __linux__\n    close(statfd);\n#endif\n\n    return err < 0 ? -err : err;\n}\n\nint setup_steal_socket(struct steal_pty_state *steal) {\n    strcpy(steal->tmpdir, \"/tmp/reptyr.XXXXXX\");\n    if (mkdtemp(steal->tmpdir) == NULL)\n        return errno;\n\n    steal->addr_un.sun_family = AF_UNIX;\n    if (snprintf(steal->addr_un.sun_path, sizeof(steal->addr_un.sun_path),\n                 \"%s/reptyr.sock\", steal->tmpdir) >= sizeof(steal->addr_un.sun_path)) {\n        error(\"tmpdir path too long!\");\n        return ENAMETOOLONG;\n    }\n\n    if ((steal->sockfd = socket(AF_UNIX, SOCK_DGRAM, 0)) < 0)\n        return errno;\n\n    if (bind(steal->sockfd, &steal->addr, sizeof(steal->addr_un)) < 0)\n        return errno;\n\n    if (chown(steal->addr_un.sun_path, steal->emulator_uid, -1) < 0)\n        debug(\"chown %s: %s\", steal->addr_un.sun_path, strerror(errno));\n    if (chown(steal->tmpdir, steal->emulator_uid, -1) < 0)\n        debug(\"chown %s: %s\", steal->tmpdir, strerror(errno));\n\n    return 0;\n}\n\nint setup_steal_socket_child(struct steal_pty_state *steal) {\n    int err;\n    err = do_socketcall(&steal->child,\n                        steal->child_scratch + sysconf(_SC_PAGE_SIZE)/2,\n                        socket, AF_UNIX, SOCK_DGRAM, 0, 0, 0);\n    if (err < 0)\n        return -err;\n    steal->child_fd = err;\n    debug(\"Opened fd %d in the child.\", steal->child_fd);\n    err = ptrace_memcpy_to_child(&steal->child, steal->child_scratch,\n                                 &steal->addr_un, sizeof(steal->addr_un));\n    if (err < 0)\n        return steal->child.error;\n    err = do_socketcall(&steal->child,\n                        steal->child_scratch + sysconf(_SC_PAGE_SIZE)/2,\n                        connect, steal->child_fd, steal->child_scratch,\n                        sizeof(steal->addr_un), 0, 0);\n    if (err < 0)\n        return -err;\n    debug(\"Connected to the shared socket.\");\n    return 0;\n}\n\nint steal_child_pty(struct steal_pty_state *steal) {\n    struct {\n        struct msghdr msg;\n        unsigned char buf[CMSG_SPACE(sizeof(int))];\n    } buf = {};\n    struct cmsghdr *cm;\n    int err;\n\n    buf.msg.msg_control = buf.buf;\n    buf.msg.msg_controllen = CMSG_SPACE(sizeof(int));\n    cm = CMSG_FIRSTHDR(&buf.msg);\n    cm->cmsg_level = SOL_SOCKET;\n    cm->cmsg_type  = SCM_RIGHTS;\n    cm->cmsg_len   = CMSG_LEN(sizeof(int));\n    memcpy(CMSG_DATA(cm), &steal->master_fds.fds[0], sizeof(int));\n    buf.msg.msg_controllen = cm->cmsg_len;\n\n    // Relocate for the child\n    buf.msg.msg_control = (void*)(steal->child_scratch +\n                                  ((uint8_t*)buf.msg.msg_control - (uint8_t*)&buf));\n\n    if (ptrace_memcpy_to_child(&steal->child,\n                               steal->child_scratch,\n                               &buf, sizeof(buf))) {\n        return steal->child.error;\n    }\n\n    steal->child.error = 0;\n    err = do_socketcall(&steal->child,\n                        steal->child_scratch + sysconf(_SC_PAGE_SIZE)/2,\n                        sendmsg,\n                        steal->child_fd,\n                        steal->child_scratch,\n                        MSG_DONTWAIT, 0, 0);\n    if (err < 0) {\n        return steal->child.error ? steal->child.error : -err;\n    }\n\n    debug(\"Sent the pty fd, going to receive it.\");\n\n    buf.msg.msg_control = buf.buf;\n    buf.msg.msg_controllen = CMSG_SPACE(sizeof(int));\n\n    err = recvmsg(steal->sockfd, &buf.msg, MSG_DONTWAIT);\n    if (err < 0) {\n        error(\"Error receiving message.\");\n        return errno;\n    }\n\n    debug(\"Got a message: %d bytes, %ld control\",\n          err, (long)buf.msg.msg_controllen);\n\n    if (buf.msg.msg_controllen < CMSG_LEN(sizeof(int))) {\n        error(\"No fd received?\");\n        return EINVAL;\n    }\n\n    memcpy(&steal->ptyfd, CMSG_DATA(cm), sizeof(steal->ptyfd));\n\n    debug(\"Got tty fd: %d\", steal->ptyfd);\n\n    return 0;\n}\n\n// Attach to the session leader of the stolen session, and block\n// SIGHUP so that if and when the terminal emulator tries to HUP it,\n// it doesn't die.\nint steal_block_hup(struct steal_pty_state *steal) {\n    struct ptrace_child leader;\n    child_addr_t scratch = 0;\n    int err = 0;\n\n    if ((err = grab_pid(steal->target_stat.sid, &leader, &scratch)))\n        return err;\n\n    err = ignore_hup(&leader, scratch);\n\n    ptrace_restore_regs(&leader);\n    ptrace_detach_child(&leader);\n\n    return err;\n}\n\nint steal_cleanup_child(struct steal_pty_state *steal) {\n    if (ptrace_memcpy_to_child(&steal->child,\n                               steal->child_scratch,\n                               \"/dev/null\", sizeof(\"/dev/null\"))) {\n        return steal->child.error;\n    }\n\n    int nullfd = do_syscall(&steal->child, openat, -1, steal->child_scratch, O_RDWR, 0, 0, 0);\n    if (nullfd < 0) {\n        return steal->child.error;\n    }\n\n    int i;\n    for (i = 0; i < steal->master_fds.n; ++i) {\n        do_dup2(&steal->child, nullfd, steal->master_fds.fds[i]);\n    }\n\n    do_syscall(&steal->child, close, nullfd, 0, 0, 0, 0, 0);\n    do_syscall(&steal->child, close, steal->child_fd, 0, 0, 0, 0, 0);\n\n    steal->child_fd = 0;\n\n    ptrace_restore_regs(&steal->child);\n\n    ptrace_detach_child(&steal->child);\n    ptrace_wait(&steal->child);\n    return 0;\n}\n\nint steal_pty(pid_t pid, int *pty) {\n    int err = 0;\n    struct steal_pty_state steal = {};\n    long page_size = sysconf(_SC_PAGE_SIZE);\n\n    if ((err = preflight_check(pid)))\n        goto out;\n\n    if ((err = get_terminal_state(&steal, pid)))\n        goto out;\n\n    if ((err = setup_steal_socket(&steal)))\n        goto out;\n\n    debug(\"Listening on socket: %s\", steal.addr_un.sun_path);\n    debug(\"Attaching terminal emulator pid=%d\", steal.emulator_pid);\n\n    if ((err = grab_pid(steal.emulator_pid, &steal.child, &steal.child_scratch)))\n        goto out;\n\n    debug(\"Attached to terminal emulator (pid %d)\",\n          (int)steal.emulator_pid);\n\n    if ((err = find_master_fd(&steal))) {\n        error(\"Unable to find the fd for the pty!\");\n        goto out;\n    }\n\n    if ((err = setup_steal_socket_child(&steal)))\n        goto out;\n\n    if ((err = steal_child_pty(&steal)))\n        goto out;\n\n    if ((err = steal_block_hup(&steal)))\n        goto out;\n\n    if ((err = steal_cleanup_child(&steal)))\n        goto out;\n\n    goto out_no_child;\n\nout:\n    if (steal.ptyfd) {\n        close(steal.ptyfd);\n        steal.ptyfd = 0;\n    }\n\n    if (steal.child_fd > 0)\n        do_syscall(&steal.child, close, steal.child_fd, 0, 0, 0, 0, 0);\n\n    if (steal.child_scratch > 0)\n        do_unmap(&steal.child, steal.child_scratch, page_size);\n\n    if (steal.child.state != ptrace_detached) {\n        ptrace_restore_regs(&steal.child);\n        ptrace_detach_child(&steal.child);\n    }\n\nout_no_child:\n\n    if (steal.sockfd > 0) {\n        close(steal.sockfd);\n        unlink(steal.addr_un.sun_path);\n    }\n\n    if (steal.tmpdir[0]) {\n        rmdir(steal.tmpdir);\n    }\n\n    if (steal.ptyfd)\n        *pty = steal.ptyfd;\n\n    free(steal.master_fds.fds);\n\n    return err;\n}\n"
        },
        {
          "name": "platform",
          "type": "tree",
          "content": null
        },
        {
          "name": "ptrace.h",
          "type": "blob",
          "size": 4.1025390625,
          "content": "/*\n * Copyright (C) 2011 by Nelson Elhage\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n#ifndef PTRACE_H\n#define PTRACE_H\n\n#ifdef __powerpc__\n#include <asm/ptrace.h>\n#endif\n#ifdef __riscv\n#include <asm/ptrace.h>\n#endif\n#include <sys/ptrace.h>\n#include <sys/types.h>\n#include <sys/user.h>\n#include <unistd.h>\n\n/*\n * See https://github.com/nelhage/reptyr/issues/25 and\n * https://github.com/nelhage/reptyr/issues/26.\n *\n * Older glibc's don't define PTRACE_{SETOPTIONS,GETEVENTMSG}, (but do\n * in linux/ptrace.h), but on newer systems sys/ptrace.h and\n * linux/ptrace.h conflict. If we were using autoconf or something, we\n * could potentially detect the right headers at configure-time, but\n * I'd like to avoid adding autoconf. These numbers can't ever change\n * for ABI-compatibility reasons, at least.\n */\n#ifndef PTRACE_SETOPTIONS\n#define PTRACE_SETOPTIONS   0x4200\n#endif\n#ifndef PTRACE_GETEVENTMSG\n#define PTRACE_GETEVENTMSG  0x4201\n#endif\n#ifndef PTRACE_GETREGSET\n#define PTRACE_GETREGSET  0x4204\n#endif\n#ifndef PTRACE_SETREGSET\n#define PTRACE_SETREGSET  0x4205\n#endif\n\nenum child_state {\n    ptrace_detached = 0,\n    ptrace_at_syscall,\n    ptrace_after_syscall,\n    ptrace_running,\n    ptrace_stopped,\n    ptrace_exited\n};\n\nstruct ptrace_child {\n    pid_t pid;\n    enum child_state state;\n    int personality;\n    int status;\n    int error;\n    unsigned long forked_pid;\n    unsigned long saved_syscall;\n#ifdef __linux__\n#ifdef __arm__\n    struct user_regs regs;\n#elif defined(__powerpc__)\n    struct pt_regs regs;\n#else\n    struct user_regs_struct regs;\n#endif\n#elif defined(__FreeBSD__)\n\tstruct reg regs;\n#endif\n};\n\nstruct syscall_numbers {\n    long nr_mmap;\n    long nr_mmap2;\n    long nr_munmap;\n    long nr_getsid;\n    long nr_setsid;\n    long nr_setpgid;\n    long nr_fork;\n    long nr_clone;\n    long nr_wait4;\n    long nr_signal;\n    long nr_rt_sigaction;\n    long nr_openat;\n    long nr_close;\n    long nr_ioctl;\n    long nr_dup2;\n    long nr_dup3;\n    long nr_socket;\n    long nr_connect;\n    long nr_sendmsg;\n    long nr_socketcall;\n};\n\ntypedef unsigned long child_addr_t;\n\nint ptrace_wait(struct ptrace_child *child);\nint ptrace_attach_child(struct ptrace_child *child, pid_t pid);\nint ptrace_finish_attach(struct ptrace_child *child, pid_t pid);\nint ptrace_detach_child(struct ptrace_child *child);\nint ptrace_wait(struct ptrace_child *child);\nint ptrace_advance_to_state(struct ptrace_child *child,\n                            enum child_state desired);\nint ptrace_save_regs(struct ptrace_child *child);\nint ptrace_restore_regs(struct ptrace_child *child);\nunsigned long ptrace_remote_syscall(struct ptrace_child *child,\n                                    unsigned long sysno,\n                                    unsigned long p0, unsigned long p1,\n                                    unsigned long p2, unsigned long p3,\n                                    unsigned long p4, unsigned long p5);\n\nint ptrace_memcpy_to_child(struct ptrace_child *, child_addr_t, const void*, size_t);\nint ptrace_memcpy_from_child(struct ptrace_child *, void*, child_addr_t, size_t);\nstruct syscall_numbers *ptrace_syscall_numbers(struct ptrace_child *child);\n\n#endif\n"
        },
        {
          "name": "reallocarray.c",
          "type": "blob",
          "size": 1.3837890625,
          "content": "/*  $OpenBSD: reallocarray.c,v 1.1 2014/05/08 21:43:49 deraadt Exp $    */\n/*\n * Copyright (c) 2008 Otto Moerbeek <otto@drijf.net>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <errno.h>\n#include <stdint.h>\n#include <stdlib.h>\n\n#include \"reallocarray.h\"\n\n/*\n * This is sqrt(SIZE_MAX+1), as s1*s2 <= SIZE_MAX\n * if both s1 < MUL_NO_OVERFLOW and s2 < MUL_NO_OVERFLOW\n */\n#define MUL_NO_OVERFLOW (1UL << (sizeof(size_t) * 4))\n\nvoid *\nxreallocarray(void *optr, size_t nmemb, size_t size)\n{\n    if ((nmemb >= MUL_NO_OVERFLOW || size >= MUL_NO_OVERFLOW) &&\n            nmemb > 0 && SIZE_MAX / nmemb < size) {\n        errno = ENOMEM;\n        return NULL;\n    }\n    return realloc(optr, size * nmemb);\n}\n\n"
        },
        {
          "name": "reallocarray.h",
          "type": "blob",
          "size": 0.1181640625,
          "content": "#ifndef __reallocarray_h\n#define __reallocarray_h\n\nvoid * xreallocarray(void *optr, size_t nmemb, size_t size);\n\n#endif\n\n"
        },
        {
          "name": "release.sh",
          "type": "blob",
          "size": 0.5380859375,
          "content": "#!/bin/sh\n\nset -e\n\nversion=\"$1\"\nchangelog=\"$2\"\n\nif [ -z \"$version\" ]; then\n    echo \"Usage: $0 [NEW-VERSION]\" >&2\n    exit 2\nfi\n\n{\n    cat <<EOF\n* ${version} ($(date +\"%b %d, %Y\"))\n - ${changelog-(add changelog here)}\n\nEOF\n    cat ChangeLog\n} > ChangeLog.tmp\nmv -f ChangeLog.tmp ChangeLog\n\nif ! [ \"$changelog\" ]; then\n    \"$EDITOR\" ChangeLog\nfi\n\nversion=\"$version\" perl -i -lape '/^#define REPTYR_VERSION/ && s/\".*\"/\"$ENV{version}\"/' reptyr.h\n\ngit add ChangeLog reptyr.h\n\ngit commit -m \"reptyr $version\"\ngit tag \"reptyr-$version\" -m \"reptyr $version\"\n"
        },
        {
          "name": "reptyr.1",
          "type": "blob",
          "size": 4.4541015625,
          "content": ".mso www.tmac\n.TH reptyr 1 \"03 Feb 2011\"\n.SH NAME\nreptyr \\- Reparent a running program to a new terminal\n.SH SYNOPSIS\n.B reptyr\n.I PID\n\n.B reptyr \\-l|\\-L [COMMAND [ARGS]]\n\n.SH DESCRIPTION\n\n.B reptyr\nis a utility for taking an existing running program and\nattaching it to a new terminal. Started a long-running process over\nssh, but have to leave and don't want to interrupt it? Just start a\nscreen, use\n.B reptyr\nto grab it, and then kill the ssh session and head\non home.\n.LP\n.B reptyr\nworks by attaching to the target program using\n.BR ptrace (2),\nredirecting relevant file descriptors, and changing the program's controlling\nterminal (See\n.BR tty (4))\nIt is this last detail that makes\n.B reptyr\nwork much better than alternatives such as\n.BR retty (1).\n\n.LP\nAfter attaching a program, the program will appear to be either backgrounded or\nsuspended to the shell it was launched from (depending on the shell). For\nmaximal safety you can run\n.IP\nbg; disown\n.LP\n\nin the old shell to remove the association with the program, but\n.B reptyr\nwill attempt to ensure that the target program remains running even if you close\nthe shell without doing so.\n\n.SH OPTIONS\n\n.B \\-T\n.IP\nUse an alternate mode of attaching, \"TTY-stealing\". In this mode,\n.B reptyr\nwill not\n.BR ptrace (2)\nthe target process, but will attempt to discover the terminal emulator\nfor that process' pty, and steal the master end of the pty. This mode\nis more reliable and flexible in many circumstances (for instance, it\ncan attach all processes on a tty, rather than just a single\nprocess). However, as a downside, children of\n.BR sshd(8)\ncannot be attached via\n.B -T\nunless\n.B reptyr\nis run as root. See\n.URL https://blog.nelhage.com/2014/08/new-reptyr-feature-tty-stealing/\nfor more information about tty-stealing.\n.LP\n\n.B \\-l, \\-L [COMMAND [ARGS]]\n.IP\nInstead of attaching to a new process, create a new pty pair, proxy the master\nend to the current terminal, and then print the name of the slave pty. This can\nbe passed to e.g.\n.B gdb\\'s\n.I set inferior-tty\noption.\n\nIf an optional\n.B COMMAND\nand\n.B ARGS\nare passed in conjunction with\n.B -l,\nthat command will be executed as a child of\n.B reptyr\nwith the\n.B REPTYR_PTY\nenvironment variable set to the name of the slave pty. If\n.B -L\nis used instead of\n.B -l,\nthen fds 0-2 of the child will also be redirected to point to the\nslave, and the child will be run in a fresh session with the slave as\nits controlling terminal.\n.LP\n\n.B \\-s\n.IP\n\nBy default, reptyr will move any file descriptors in the target that were\nconnected to the target's controlling terminal to point to the new terminal. The\n.B -s\noption will cause reptyr to unconditionally attach file descriptors 0, 1, and 2\nin the target, even if the target has no controlling terminal or they are not\nconnected to a terminal.\n.LP\n\n.B \\-v\n.IP\nPrint the version of\n.B reptyr\nand exit.\n.LP\n\n.B \\-h\n.IP\nPrint a usage message and exit.\n.LP\n\n.B \\-V\n.IP\nPrint verbose debug output while running.\n.LP\n\n.SH NOTES\n\n.B reptyr\ndepends on the\n.BR ptrace (2)\nsystem call to attach to the remote program. On Ubuntu Maverick and higher, this\nability is disabled by default for security reasons. You can enable it\ntemporarily by doing\n.IP\n # echo 0 > /proc/sys/kernel/yama/ptrace_scope\n.LP\nas root, or permanently by editing the file\n.IR /etc/sysctl.d/10-ptrace.conf ,\nwhich also contains more information about this setting.\n\n.SH BUGS\n\nWhen attaching to some curses programs, they will not redraw the screen right\naway, and a\n.B ^L\nor similar will be needed to force a redraw.\n\nSimilarly, after attaching to certain programs, the old terminal will be left in\nan odd state, and a\n.B clear\nor even\n.B reset\nmay be required before the old terminal is usable again.\n\nAttaching to rtorrent (and probably some other apps) doesn't work right\n(rtorrent stops accepting input) (The problem is that rtorrent is using epoll to\npoll stdin, and we don't update the internal reference that the epoll fd has to\nthe old tty).\n\nAttaching to a process with children doesn't work right. This should be possible\nto fix -- I just need to ptrace each child individually and do the same games to\nit.\n\nAttaching a\n.BR less (1)\nprocess doesn't work if you have a\n.I .lessfilter\nfile, as\n.BR less\nleaves around a zombie child in this case. This could be worked around.\n\nBugs should be reported to the author (see below) or via the issue tracker on\nGitHub.\n\n.SH AUTHORS\n\nreptyr was written by Nelson Elhage <nelhage@nelhage.com>.\n\n.SH HOMEPAGE\n\n.URL https://github.com/nelhage/reptyr\n\n.SH SEE ALSO\n\n.BR neercs (1),\n.BR screen (1)\n"
        },
        {
          "name": "reptyr.bash",
          "type": "blob",
          "size": 0.3603515625,
          "content": "# bash completion for reptyr(1)\n\n_reptyr()\n{\n    case $3 in\n        -l|-L|-h|-v) return ;;\n    esac\n\n    if [[ $2 == -* ]]; then\n        COMPREPLY=( $(compgen -W '-l -L -s -T -h -v -V' -- \"$2\") )\n        return\n    fi\n\n    case $3 in\n        [1-9]*) ;;\n        *) COMPREPLY=( $(compgen -W '$(command ps axo pid=)' -- \"$2\") ) ;;\n    esac\n} &&\ncomplete -F _reptyr reptyr\n"
        },
        {
          "name": "reptyr.c",
          "type": "blob",
          "size": 8.783203125,
          "content": "/*\n * Copyright (C) 2011 by Nelson Elhage\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/select.h>\n#include <sys/ioctl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdarg.h>\n#include <termios.h>\n#include <signal.h>\n\n#include \"reptyr.h\"\n#include \"reallocarray.h\"\n#include \"platform/platform.h\"\n\nstatic int verbose = 0;\n\nvoid _debug(const char *pfx, const char *msg, va_list ap) {\n\n    if (pfx)\n        fprintf(stderr, \"%s\", pfx);\n    vfprintf(stderr, msg, ap);\n    fprintf(stderr, \"\\n\");\n}\n\nvoid die(const char *msg, ...) {\n    va_list ap;\n    va_start(ap, msg);\n    _debug(\"[!] \", msg, ap);\n    va_end(ap);\n\n    exit(1);\n}\n\nvoid debug(const char *msg, ...) {\n\n    va_list ap;\n\n    if (!verbose)\n        return;\n\n    va_start(ap, msg);\n    _debug(\"[+] \", msg, ap);\n    va_end(ap);\n}\n\nvoid error(const char *msg, ...) {\n    va_list ap;\n    va_start(ap, msg);\n    _debug(\"[-] \", msg, ap);\n    va_end(ap);\n}\n\nvoid setup_raw(struct termios *save) {\n    struct termios set;\n    if (tcgetattr(0, save) < 0) {\n        fprintf(stderr, \"Unable to read terminal attributes: %m\");\n        return;\n    }\n    set = *save;\n    cfmakeraw(&set);\n    if (tcsetattr(0, TCSANOW, &set) < 0)\n        die(\"Unable to set terminal attributes: %m\");\n}\n\nvoid resize_pty(int pty) {\n    struct winsize sz;\n    if (ioctl(0, TIOCGWINSZ, &sz) < 0) {\n        // provide fake size to workaround some problems\n        struct winsize defaultsize = {30, 80, 640, 480};\n        if (ioctl(pty, TIOCSWINSZ, &defaultsize) < 0) {\n            fprintf(stderr, \"Cannot set terminal size\\n\");\n        }\n        return;\n    }\n    ioctl(pty, TIOCSWINSZ, &sz);\n}\n\nint writeall(int fd, const void *buf, ssize_t count) {\n    ssize_t rv;\n    while (count > 0) {\n        rv = write(fd, buf, count);\n        if (rv < 0) {\n            if (errno == EINTR)\n                continue;\n            return rv;\n        }\n        count -= rv;\n        buf += rv;\n    }\n    return 0;\n}\n\nvolatile sig_atomic_t winch_happened = 0;\n\nvoid do_winch(int signal) {\n    winch_happened = 1;\n}\n\nvoid do_proxy(int pty) {\n    char buf[4096];\n    ssize_t count;\n    fd_set set;\n    sigset_t mask;\n    sigset_t select_mask;\n    struct sigaction sa;\n\n    // Block WINCH while we're outside the select, but unblock it\n    // while we're inside:\n    sigemptyset(&mask);\n    sigaddset(&mask, SIGWINCH);\n    if (sigprocmask(SIG_BLOCK, &mask, NULL) == -1) {\n        fprintf(stderr, \"sigprocmask: %m\");\n        return;\n    }\n    sa.sa_handler = do_winch;\n    sa.sa_flags = 0;\n    sigemptyset(&sa.sa_mask);\n    sigaction(SIGWINCH, &sa, NULL);\n    resize_pty(pty);\n\n    while (1) {\n        if (winch_happened) {\n            winch_happened = 0;\n            resize_pty(pty);\n        }\n        FD_ZERO(&set);\n        FD_SET(0, &set);\n        FD_SET(pty, &set);\n        sigemptyset(&select_mask);\n        if (pselect(pty + 1, &set, NULL, NULL, NULL, &select_mask) < 0) {\n            if (errno == EINTR)\n                continue;\n            fprintf(stderr, \"select: %m\");\n            return;\n        }\n        if (FD_ISSET(0, &set)) {\n            count = read(0, buf, sizeof buf);\n            if (count < 0)\n                return;\n            writeall(pty, buf, count);\n        }\n        if (FD_ISSET(pty, &set)) {\n            count = read(pty, buf, sizeof buf);\n            if (count <= 0)\n                return;\n            writeall(1, buf, count);\n        }\n    }\n}\n\nvoid usage(char *me) {\n    fprintf(stderr, \"Usage: %s [-s] PID\\n\", me);\n    fprintf(stderr, \"       %s -l|-L [COMMAND [ARGS]]\\n\", me);\n    fprintf(stderr, \"  -l    Create a new pty pair and print the name of the slave.\\n\");\n    fprintf(stderr, \"           if there are command-line arguments after -l\\n\");\n    fprintf(stderr, \"           they are executed with REPTYR_PTY set to path of pty.\\n\");\n    fprintf(stderr, \"  -L    Like '-l', but also redirect the child's stdio to the slave.\\n\");\n    fprintf(stderr, \"  -s    Attach fds 0-2 on the target, even if it is not attached to a tty.\\n\");\n    fprintf(stderr, \"  -T    Steal the entire terminal session of the target.\\n\");\n    fprintf(stderr, \"           [experimental] May be more reliable, and will attach all\\n\");\n    fprintf(stderr, \"           processes running on the terminal.\\n\");\n    fprintf(stderr, \"  -h    Print this help message and exit.\\n\");\n    fprintf(stderr, \"  -v    Print the version number and exit.\\n\");\n    fprintf(stderr, \"  -V    Print verbose debug output.\\n\");\n}\n\nint main(int argc, char **argv) {\n    struct termios saved_termios;\n    int pty;\n    int opt;\n    int err;\n    int do_attach = 1;\n    int force_stdio = 0;\n    int do_steal = 0;\n    int unattached_script_redirection = 0;\n\n    while ((opt = getopt(argc, argv, \"hlLsTvV\")) != -1) {\n        switch (opt) {\n        case 'h':\n            usage(argv[0]);\n            return 0;\n        case 'l':\n            do_attach = 0;\n            break;\n        case 'L':\n            do_attach = 0;\n            unattached_script_redirection = 1;\n            break;\n        case 's':\n            force_stdio = 1;\n            break;\n        case 'T':\n            do_steal = 1;\n            break;\n        case 'v':\n            printf(\"This is reptyr version %s.\\n\", REPTYR_VERSION);\n            printf(\" by Nelson Elhage <nelhage@nelhage.com>\\n\");\n            printf(\"http://github.com/nelhage/reptyr/\\n\");\n            return 0;\n        case 'V':\n            verbose = 1;\n            break;\n        default:\n            usage(argv[0]);\n            return 1;\n        }\n        if (opt == 'l' || opt == 'L') break; // the rest is a command line\n    }\n\n    if (do_attach && optind >= argc) {\n        fprintf(stderr, \"%s: No pid specified to attach\\n\", argv[0]);\n        usage(argv[0]);\n        return 1;\n    }\n\n    if (!do_steal) {\n        if ((pty = get_pt()) < 0)\n            die(\"Unable to allocate a new pseudo-terminal: %m\");\n        if (unlockpt(pty) < 0)\n            die(\"Unable to unlockpt: %m\");\n        if (grantpt(pty) < 0)\n            die(\"Unable to grantpt: %m\");\n    }\n\n    if (do_attach) {\n        char *endptr = NULL;\n        errno = 0;\n        long t = strtol(argv[optind], &endptr, 10);\n        if (errno == ERANGE)\n            die(\"Invalid pid: %m\");\n        if (*endptr)\n            die(\"Invalid pid: must be integer\");\n        /* check for overflow/underflow */\n        pid_t child = (pid_t)t;\n        if (child < t || t < 1) /* pids can't be < 1, so no *real* underflow check */\n            die(\"Invalid pid: %s\", strerror(ERANGE));\n\n        if (do_steal) {\n            err = steal_pty(child, &pty);\n        } else {\n            err = attach_child(child, ptsname(pty), force_stdio);\n        }\n        if (err) {\n            fprintf(stderr, \"Unable to attach to pid %d: %s\\n\", child, strerror(err));\n            if (err == EPERM) {\n                check_ptrace_scope();\n            }\n            return 1;\n        }\n    } else {\n        printf(\"Opened a new pty: %s\\n\", ptsname(pty));\n        fflush(stdout);\n        if (argc > 2) {\n            if (!fork()) {\n                setenv(\"REPTYR_PTY\", ptsname(pty), 1);\n                if (unattached_script_redirection) {\n                    int f;\n                    setpgid(0, getppid());\n                    setsid();\n                    f = open(ptsname(pty), O_RDONLY, 0);\n                    dup2(f, 0);\n                    close(f);\n                    f = open(ptsname(pty), O_WRONLY, 0);\n                    dup2(f, 1);\n                    dup2(f, 2);\n                    close(f);\n                }\n                close(pty);\n                execvp(argv[2], argv + 2);\n                exit(1);\n            }\n        }\n    }\n\n    setup_raw(&saved_termios);\n    do_proxy(pty);\n    do {\n        errno = 0;\n        if (tcsetattr(0, TCSANOW, &saved_termios) && errno != EINTR)\n            die(\"Unable to tcsetattr: %m\");\n    } while (errno == EINTR);\n\n    return 0;\n}\n"
        },
        {
          "name": "reptyr.fr.1",
          "type": "blob",
          "size": 3.9306640625,
          "content": ".\\\" Traduction Laurent GAUTROT <l.gautrot@free.fr> - 2011-08-06\n.mso www.tmac\n.TH reptyr 1 \"03 Feb 2011\"\n.SH NOM\nreptyr \\- Reassoccie un programme en cours d'exécution à un nouveau terminal\n.SH SYNOPSIS\n.B reptyr\n.I PID\n\n.B reptyr \\-l\n\n.SH DESCRIPTION\n\n.B reptyr\nest un utilitaire qui prend un programme en cours d'exécution et\nl'attache à un nouveau terminal. Vous avez démarré un programme long à\ntravers ssh, mais vous devez partir et vous ne voulez pas\nl'interrompre\\ ? Démarrez simplement un screen, utilisez\n.B reptyr\npour l'attraper, puis tuez la session ssh et vous pouvez rentrer à la\nmaison.\n.LP\n.B reptyr\nfonctionne en s'attachant au programme visé à l'aide de\n.BR ptrace (2),\nen redirigeant les descripteurs de fichiers appropriés et en modifiant\nle terminal de contrôle du programme (Voir\n.BR tty (4))\nC'est le détail qui fait que\n.B reptyr\nfocntionne bien mieux que les autres programmes du même type, comme\n.BR retty (1).\n\n.LP\nAprès avoir attaché un programme, il apparaît soit à l'arrière-plan,\nsoit suspendu pour le shell qui l'a lancé (variable en fonction du\nshell).\nPour une sécurité maximale, vous pouvez exécuter\n.IP\nbg; disown\n.LP\n\ndans le vieux shell pour supprimer l'association avec le programme,\nmais\n.B reptyr\ntente de s'assurer que le programme visé reste en cours d'exécution\nmême si vous fermez le shell sans le faire.\n\n.SH OPTIONS\n\n.B \\-l\n.IP\nPlutôt que d'attacher un nouveau processus, crée un couveau couple de\npty, redirige l'extrémité maîtresse vers le terminal en cours, puis\naffiche le nom du pty esclave. Il pourra être passé en argument par\nexemple à l'option\n.I set inferior-tty\nde\n.B gdb.\n.LP\n\n.B \\-s\n.IP\n\nPar défaut, reptyr déplace tout descripteur de fichier de la cible qui\nétait connecté au terminal de contrôle vers le nouveau terminal.\nL'option\n.B -s\nfait que reptyr attache les descripteurs de fichiers 0, 1 et 2 sans\ncondition même si la cible n'a pas de terminal de contrôle ou qu'elle\nn'est pas connectée à un terminal.\n.LP\n\n.B \\-v\n.IP\nAffiche la version de\n.B reptyr\net sort.\n.LP\n\n.B \\-h\n.IP\nAffiche un message d'usage et sort.\n.LP\n\n.B \\-V\n.IP\nAffiche des messages verbeux.\n.LP\n\n.SH NOTES\n\n.B reptyr\ndépend de l'appel système\n.BR ptrace (2)\npour s'attacher au programme distant. Sur Ubuntu Maverick et suivant\ncette possibilité est désactivée par défaut pour des raisons de\nsécurité. Vous pouvez l'activer temporairement avec\n.IP\n # echo 0 > /proc/sys/kernel/yama/ptrace_scope\n.LP\nen tant que rootn ou de manière permanente en éditant le fichier\n.IR /etc/sysctl.d/10-ptrace.conf ,\nui contient aussi plus d'information sur ce réglage.\n\n.SH BUGS\n\nQuand on s'attache à quelques programmes curses, ils ne redessinent\npas immédiatement l'écran, et un\n.B ^L\nou équivalent est nécessaire pour forcer l'actualisation.\n\nDe la même manière, après avoir attaché certains programmes, le vieux\nterminal est dans un état étrange et un\n.B clear\nou même un\n.B reset\nest nécessaire avant que le vieux terminal ne soit à nouveau\nutilisable.\n\nL'attachement à rtorrent (et peut-être à d'autres applications) ne\nfonctionne pas (rtorrent arrête d'accepter des entrées). Le problème\nest que rtorrent utilise epoll pour vérifier l'entrée standard et\nqu'on ne met pas à jour la référence interne que le descripteur de\nfichier d'epoll a de l'ancien terminal.\n\nL'attachement à un processus avec des fils ne fonctionne pas\ncorrectement. Il devrait être possible de le corriger. Il faut juste\nptracer chaque fils individuellement et de jouer avec lui.\n\nL'attachement à un processus\n.BR less (1)\nne fonctionne pas si vous avez un fichier\n.I .lessfilter\nparce que\n.BR less\nabandonne un fils zombie dans ce cas. Ça devrait pouvoir être corrigé.\n\nVous pouvez rapporter des bugs à l'auteur (voir ci-dessous) ou par\nl'issue tracker sur\nGitHub.\n\n.SH AUTEURS\n\nreptyr est écrit par Nelson Elhage <nelhage@nelhage.com>.\n\n.SH HOMEPAGE\n\n.URL https://github.com/nelhage/reptyr\n\n.SH VOIR AUSSI\n\n.BR neercs (1),\n.BR screen (1)\n\n"
        },
        {
          "name": "reptyr.h",
          "type": "blob",
          "size": 1.72265625,
          "content": "/*\n * Copyright (C) 2011 by Nelson Elhage\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n#define REPTYR_VERSION \"0.10.0\"\n\n#define assert_nonzero(expr) ({                         \\\n            typeof(expr) __val = expr;                  \\\n            if (__val == 0)                             \\\n                die(\"Unexpected: %s == 0!\\n\", #expr);   \\\n            __val;                                      \\\n        })\n\nint attach_child(pid_t pid, const char *pty, int force_stdio);\nint steal_pty(pid_t pid, int *pty);\n#define __printf __attribute__((format(printf, 1, 2)))\nvoid __printf die(const char *msg, ...) __attribute__((noreturn));\nvoid __printf debug(const char *msg, ...);\nvoid __printf error(const char *msg, ...);\n"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}