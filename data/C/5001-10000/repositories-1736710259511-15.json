{
  "metadata": {
    "timestamp": 1736710259511,
    "page": 15,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "Immediate-Mode-UI/Nuklear",
      "stars": 9523,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.216796875,
          "content": "# EditorConfig: https://EditorConfig.org\n\nroot = true\n\n[*]\nindent_style = space\ncharset = utf-8\nend_of_line = lf\nindent_size = 4\ninsert_final_newline = true\ntrim_trailing_whitespace = true\n\n[**.{json,yml}]\nindent_size = 2\n"
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.109375,
          "content": "# Github language settings\n*.h linguist-language=c\n*.c linguist-language=c\n\n*.h text eol=auto\n*.c text eol=auto\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1220703125,
          "content": "demo/*/*.exe\ndemo/*/*.obj\ndemo/*/bin/*\nexample/bin/*\ndocs/xml\ndocs/build\ndocs/src\ndoc/doc*\ndoc/*\n*.tmp\n*.swo\n*.swp\n/private/\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 2.6044921875,
          "content": "------------------------------------------------------------------------------\nThis software is available under 2 licenses -- choose whichever you prefer.\n------------------------------------------------------------------------------\nALTERNATIVE A - MIT License\nCopyright (c) 2017 Micha Mettke\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n------------------------------------------------------------------------------\nALTERNATIVE B - Public Domain (www.unlicense.org)\nThis is free and unencumbered software released into the public domain.\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this\nsoftware, either in source code form or as a compiled binary, for any purpose,\ncommercial or non-commercial, and by any means.\nIn jurisdictions that recognize copyright laws, the author or authors of this\nsoftware dedicate any and all copyright interest in the software to the public\ndomain. We make this dedication for the benefit of the public at large and to\nthe detriment of our heirs and successors. We intend this dedication to be an\novert act of relinquishment in perpetuity of all present and future rights to\nthis software under copyright law.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n-----------------------------------------------------------------------------\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 3.1787109375,
          "content": "\n######################################################################################\n##  \t\t\t\t\t\t\t\t SETTINGS                                       ##\n######################################################################################\n\n## path stuff\nDOCS_PATH:=./doc\nDEMO_PATH=demo\nSRC_PATH=src\n\n\n## Documents settings\nDOXYFILE:=$(DOCS_PATH)/Doxyfile\n\n\n## HEADER file packing settings\n## note: source file paths are prefixed later, no need to add prefix here; just\n## give it the name.\nMACRO = NK\nINTRO =  HEADER.md\nPUB = nuklear.h\nOUTPUT = nuklear.h\n\nPRIV1 = nuklear_internal.h nuklear_math.c nuklear_util.c nuklear_color.c nuklear_utf8.c nuklear_buffer.c nuklear_string.c nuklear_draw.c nuklear_vertex.c \n\nEXTERN =  stb_rect_pack.h stb_truetype.h \n\nPRIV2 = nuklear_font.c nuklear_input.c nuklear_style.c nuklear_context.c nuklear_pool.c nuklear_page_element.c nuklear_table.c nuklear_panel.c nuklear_window.c nuklear_popup.c nuklear_contextual.c nuklear_menu.c nuklear_layout.c nuklear_tree.c nuklear_group.c nuklear_list_view.c nuklear_widget.c nuklear_text.c nuklear_image.c nuklear_9slice.c nuklear_button.c nuklear_toggle.c nuklear_selectable.c nuklear_slider.c nuklear_knob.c nuklear_progress.c nuklear_scrollbar.c nuklear_text_editor.c nuklear_edit.c nuklear_property.c nuklear_chart.c nuklear_color_picker.c nuklear_combo.c nuklear_tooltip.c\n\nOUTRO = LICENSE CHANGELOG CREDITS\n\n## Demo settings\nDEMO_LIST = $(shell find $(DEMO_PATH) -type f -name Makefile -printf \"%h \")\n\n######################################################################################\n##  \t\t\t\t\t\t\t\t RECIPES                                        ##\n######################################################################################\n\n\n.PHONY: usage all demos $(DEMO_LIST)\n\nusage:\n\techo \"make docs\t\tto create documentation\"\n\techo \"make nuke\t\tto rebuild the single header nuklear.h from source\"\n\techo \"make demos\tto build all of the demos\"\n\techo \"make all \t\tto re-pack the header and create documentation\"\n\nall: docs nuke demos \ndemos: $(DEMO_LIST)\n\n\n########################################################################################\n##   Nuklear.h\n\nnuke: $(addprefix $(SRC_PATH)/, $(SRC))\n\tpython3 $(SRC_PATH)/build.py --macro $(MACRO) --intro $(addprefix $(SRC_PATH)/, $(INTRO)) --pub $(addprefix $(SRC_PATH)/, $(PUB)) --priv1 \"$(addprefix $(SRC_PATH)/, $(PRIV1))\" --extern \"$(addprefix $(SRC_PATH)/, $(EXTERN))\" --priv2 \"$(addprefix $(SRC_PATH)/, $(PRIV2))\" --outro \"$(addprefix $(SRC_PATH)/, $(OUTRO))\" > $(OUTPUT)\n\n\n\n\n\n########################################################################################\n##   Docs\n\ndocs: $(DOCS_PATH)/html/index.html \n\n$(DOCS_PATH)/html/index.html: $(DOCS_PATH)/doxygen-awesome-css/doxygen-awesome.css $(DOXYFILE)\n\tdoxygen $(DOXYFILE)\n\n$(DOXYFILE):\n\tdoxygen -g $@\n\n$(DOCS_PATH)/doxygen-awesome-css/doxygen-awesome.css:\n\tgit clone https://github.com/jothepro/doxygen-awesome-css.git $(DOCS_PATH)/doxygen-awesome-css --branch v2.3.4\n\n\n\n########################################################################################\n##   Demos\n\n$(DEMO_LIST):\n\t$(MAKE) -C $@\n\n\n\n########################################################################################\n##   Utility helpers\n\nclean:\n\trm -rf $(DOCS_PATH)/html $(OUTPUT)\n"
        },
        {
          "name": "Readme.md",
          "type": "blob",
          "size": 7.41796875,
          "content": "# Nuklear\n\n[![](https://github.com/Immediate-Mode-UI/Nuklear/workflows/C%2FC++%20CI/badge.svg )](https://github.com/Immediate-Mode-UI/Nuklear/actions)\n\nThis is a minimal-state, immediate-mode graphical user interface toolkit\nwritten in ANSI C and licensed under public domain. It was designed as a simple\nembeddable user interface for application and does not have any dependencies,\na default render backend or OS window/input handling but instead provides a\nhighly modular, library-based approach, with simple input state for input and\ndraw commands describing primitive shapes as output. So instead of providing a\nlayered library that tries to abstract over a number of platform and\nrender backends, it focuses only on the actual UI.\n\n## Features\n\n- Immediate-mode graphical user interface toolkit\n- Single-header library\n- Written in C89 (ANSI C)\n- Small codebase (~18kLOC)\n- Focus on portability, efficiency and simplicity\n- No dependencies (not even the standard library if not wanted)\n- Fully skinnable and customizable\n- Low memory footprint with total control of memory usage if needed / wanted\n- UTF-8 support\n- No global or hidden state\n- Customizable library modules (you can compile and use only what you need)\n- Optional font baker and vertex buffer output\n- [Documentation](https://Immediate-Mode-UI.github.io/Nuklear/)\n\n## Building\n\nThis library is self-contained in one single header file and can be used either\nin header-only mode or in implementation mode. The header-only mode is used\nby default when included and allows including this header in other headers\nand does not contain the actual implementation.\n\nThe implementation mode requires defining the preprocessor macro\n`NK_IMPLEMENTATION` in *one* .c/.cpp file before `#include`ing this file, e.g.:\n```c\n#define NK_IMPLEMENTATION\n#include \"nuklear.h\"\n```\nIMPORTANT: Every time you include \"nuklear.h\" you have to define the same optional flags.\nThis is very important; not doing it either leads to compiler errors, or even worse, stack corruptions.\n\n## Gallery\n\n![screenshot](https://cloud.githubusercontent.com/assets/8057201/11761525/ae06f0ca-a0c6-11e5-819d-5610b25f6ef4.gif)\n![screen](https://cloud.githubusercontent.com/assets/8057201/13538240/acd96876-e249-11e5-9547-5ac0b19667a0.png)\n![screen2](https://cloud.githubusercontent.com/assets/8057201/13538243/b04acd4c-e249-11e5-8fd2-ad7744a5b446.png)\n![node](https://cloud.githubusercontent.com/assets/8057201/9976995/e81ac04a-5ef7-11e5-872b-acd54fbeee03.gif)\n![skinning](https://cloud.githubusercontent.com/assets/8057201/15991632/76494854-30b8-11e6-9555-a69840d0d50b.png)\n![gamepad](https://cloud.githubusercontent.com/assets/8057201/14902576/339926a8-0d9c-11e6-9fee-a8b73af04473.png)\n\n## Example\n\n```c\n/* init gui state */\nstruct nk_context ctx;\nnk_init_fixed(&ctx, calloc(1, MAX_MEMORY), MAX_MEMORY, &font);\n\nenum {EASY, HARD};\nstatic int op = EASY;\nstatic float value = 0.6f;\nstatic int i =  20;\n\nif (nk_begin(&ctx, \"Show\", nk_rect(50, 50, 220, 220),\n    NK_WINDOW_BORDER|NK_WINDOW_MOVABLE|NK_WINDOW_CLOSABLE)) {\n    /* fixed widget pixel width */\n    nk_layout_row_static(&ctx, 30, 80, 1);\n    if (nk_button_label(&ctx, \"button\")) {\n        /* event handling */\n    }\n\n    /* fixed widget window ratio width */\n    nk_layout_row_dynamic(&ctx, 30, 2);\n    if (nk_option_label(&ctx, \"easy\", op == EASY)) op = EASY;\n    if (nk_option_label(&ctx, \"hard\", op == HARD)) op = HARD;\n\n    /* custom widget pixel width */\n    nk_layout_row_begin(&ctx, NK_STATIC, 30, 2);\n    {\n        nk_layout_row_push(&ctx, 50);\n        nk_label(&ctx, \"Volume:\", NK_TEXT_LEFT);\n        nk_layout_row_push(&ctx, 110);\n        nk_slider_float(&ctx, 0, &value, 1.0f, 0.1f);\n    }\n    nk_layout_row_end(&ctx);\n}\nnk_end(&ctx);\n```\n![example](https://cloud.githubusercontent.com/assets/8057201/10187981/584ecd68-675c-11e5-897c-822ef534a876.png)\n\n## Bindings\nThere are a number of nuklear bindings for different languages created by other authors.\nI cannot attest for their quality since I am not necessarily proficient in any of these\nlanguages. Furthermore there are no guarantee that all bindings will always be kept up to date:\n\n- [Java](https://github.com/glegris/nuklear4j) by Guillaume Legris\n- [D](https://github.com/Timu5/bindbc-nuklear) by Mateusz Muszyński\n- [Golang](https://github.com/golang-ui/nuklear) by golang-ui@github.com\n- [Rust](https://github.com/snuk182/nuklear-rust) by snuk182@github.com\n- [Chicken](https://github.com/wasamasa/nuklear) by wasamasa@github.com\n- [Nim](https://github.com/zacharycarter/nuklear-nim) by zacharycarter@github.com\n- Lua\n  - [LÖVE-Nuklear](https://github.com/keharriso/love-nuklear) by Kevin Harrison\n  - [MoonNuklear](https://github.com/stetre/moonnuklear) by Stefano Trettel\n- Python\n  - [pyNuklear](https://github.com/billsix/pyNuklear) by William Emerison Six (ctypes-based wrapper)\n  - [pynk](https://github.com/nathanrw/nuklear-cffi) by nathanrw@github.com (cffi binding)\n- [CSharp/.NET](https://github.com/cartman300/NuklearDotNet) by cartman300@github.com\n- [V](https://github.com/nsauzede/vnk) by Nicolas Sauzede\n\n## Credits\nDeveloped by Micha Mettke and every direct or indirect contributor to the GitHub.\n\n\nEmbeds `stb_texedit`, `stb_truetype` and `stb_rectpack` by Sean Barrett (public domain)\nEmbeds `ProggyClean.ttf` font by Tristan Grimmer (MIT license).\n\n\nBig thank you to Omar Cornut (ocornut@github) for his [imgui](https://github.com/ocornut/imgui) library and\ngiving me the inspiration for this library, Casey Muratori for handmade hero\nand his original immediate-mode graphical user interface idea and Sean\nBarrett for his amazing single-header [libraries](https://github.com/nothings/stb) which restored my faith\nin libraries and brought me to create some of my own. Finally Apoorva Joshi for his single-header [file packer](http://apoorvaj.io/single-header-packer.html).\n\n## License\nNuklear is avaliable under either the MIT License or public domain.\nSee [LICENSE](LICENSE) for more info.\n\n## Reviewers guide\n\nWhen reviewing pull request there are common things a reviewer should keep\nin mind.\n\nReviewing changes to `src/*` and `nuklear.h`:\n\n* Ensure C89 compatibility.\n* The code should work for several backends to an acceptable degree.\n* Check no other parts of `nuklear.h` are related to the PR and thus nothing is missing.\n* Recommend simple optimizations.\n  * Pass small structs by value instead of by pointer.\n  * Use local buffers over heap allocation when possible.\n* Check that the coding style is consistent with code around it.\n  * Variable/function name casing.\n  * Indentation.\n  * Curly bracket (`{}`) placement.\n* Ensure that the contributor has bumped the appropriate version in\n  [clib.json](https://github.com/Immediate-Mode-UI/Nuklear/blob/master/clib.json)\n  and added their changes to the\n  [CHANGELOG](https://github.com/Immediate-Mode-UI/Nuklear/blob/master/src/CHANGELOG).\n* Have at least one other person review the changes before merging.\n\nReviewing changes to `demo/*`, `example/*` and other files in the repo:\n\n* Focus on getting working code merged.\n  * We want to make it easy for people to get started with Nuklear, and any\n    `demo` and `example` improvements helps in this regard.\n* Use of newer C features, or even other languages is not discouraged.\n  * If another language is used, ensure that the build process is easy to figure out.\n* Messy or less efficient code can be merged so long as these outliers are pointed out\n  and easy to find.\n* Version shouldn't be bumped for these changes.\n* Changes that improves code to be more inline with `nuklear.h` are ofc always welcome.\n\n"
        },
        {
          "name": "clib.json",
          "type": "blob",
          "size": 0.2216796875,
          "content": "{\n  \"name\": \"nuklear\",\n  \"version\": \"4.12.3\",\n  \"repo\": \"Immediate-Mode-UI/Nuklear\",\n  \"description\": \"A small ANSI C gui toolkit\",\n  \"keywords\": [\"gl\", \"ui\", \"toolkit\"],\n  \"license\": \"MIT, Unlicense\",\n  \"src\": [\"nuklear.h\"]\n}\n"
        },
        {
          "name": "demo",
          "type": "tree",
          "content": null
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "example",
          "type": "tree",
          "content": null
        },
        {
          "name": "extra_font",
          "type": "tree",
          "content": null
        },
        {
          "name": "nuklear.h",
          "type": "blob",
          "size": 1157.5693359375,
          "content": "/*\n# Nuklear\n![](https://cloud.githubusercontent.com/assets/8057201/11761525/ae06f0ca-a0c6-11e5-819d-5610b25f6ef4.gif)\n\n## Contents\n1. About section\n2. Highlights section\n3. Features section\n4. Usage section\n    1. Flags section\n    2. Constants section\n    3. Dependencies section\n5. Example section\n6. API section\n    1. Context section\n    2. Input section\n    3. Drawing section\n    4. Window section\n    5. Layouting section\n    6. Groups section\n    7. Tree section\n    8. Properties section\n7. License section\n8. Changelog section\n9. Gallery section\n10. Credits section\n\n## About\nThis is a minimal state immediate mode graphical user interface toolkit\nwritten in ANSI C and licensed under public domain. It was designed as a simple\nembeddable user interface for application and does not have any dependencies,\na default renderbackend or OS window and input handling but instead provides a very modular\nlibrary approach by using simple input state for input and draw\ncommands describing primitive shapes as output. So instead of providing a\nlayered library that tries to abstract over a number of platform and\nrender backends it only focuses on the actual UI.\n\n## Highlights\n- Graphical user interface toolkit\n- Single header library\n- Written in C89 (a.k.a. ANSI C or ISO C90)\n- Small codebase (~18kLOC)\n- Focus on portability, efficiency and simplicity\n- No dependencies (not even the standard library if not wanted)\n- Fully skinnable and customizable\n- Low memory footprint with total memory control if needed or wanted\n- UTF-8 support\n- No global or hidden state\n- Customizable library modules (you can compile and use only what you need)\n- Optional font baker and vertex buffer output\n- [Code available on github](https://github.com/Immediate-Mode-UI/Nuklear/)\n\n## Features\n- Absolutely no platform dependent code\n- Memory management control ranging from/to\n    - Ease of use by allocating everything from standard library\n    - Control every byte of memory inside the library\n- Font handling control ranging from/to\n    - Use your own font implementation for everything\n    - Use this libraries internal font baking and handling API\n- Drawing output control ranging from/to\n    - Simple shapes for more high level APIs which already have drawing capabilities\n    - Hardware accessible anti-aliased vertex buffer output\n- Customizable colors and properties ranging from/to\n    - Simple changes to color by filling a simple color table\n    - Complete control with ability to use skinning to decorate widgets\n- Bendable UI library with widget ranging from/to\n    - Basic widgets like buttons, checkboxes, slider, ...\n    - Advanced widget like abstract comboboxes, contextual menus,...\n- Compile time configuration to only compile what you need\n    - Subset which can be used if you do not want to link or use the standard library\n- Can be easily modified to only update on user input instead of frame updates\n\n## Usage\nThis library is self contained in one single header file and can be used either\nin header only mode or in implementation mode. The header only mode is used\nby default when included and allows including this header in other headers\nand does not contain the actual implementation. <br /><br />\n\nThe implementation mode requires to define  the preprocessor macro\nNK_IMPLEMENTATION in *one* .c/.cpp file before #including this file, e.g.:\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~C\n    #define NK_IMPLEMENTATION\n    #include \"nuklear.h\"\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nAlso optionally define the symbols listed in the section \"OPTIONAL DEFINES\"\nbelow in header and implementation mode if you want to use additional functionality\nor need more control over the library.\n\n!!! WARNING\n    Every time nuklear is included define the same compiler flags. This very important not doing so could lead to compiler errors or even worse stack corruptions.\n\n### Flags\nFlag                            | Description\n--------------------------------|------------------------------------------\nNK_PRIVATE                      | If defined declares all functions as static, so they can only be accessed inside the file that contains the implementation\nNK_INCLUDE_FIXED_TYPES          | If defined it will include header `<stdint.h>` for fixed sized types otherwise nuklear tries to select the correct type. If that fails it will throw a compiler error and you have to select the correct types yourself.\nNK_INCLUDE_DEFAULT_ALLOCATOR    | If defined it will include header `<stdlib.h>` and provide additional functions to use this library without caring for memory allocation control and therefore ease memory management.\nNK_INCLUDE_STANDARD_IO          | If defined it will include header `<stdio.h>` and provide additional functions depending on file loading.\nNK_INCLUDE_STANDARD_VARARGS     | If defined it will include header <stdarg.h> and provide additional functions depending on file loading.\nNK_INCLUDE_STANDARD_BOOL        | If defined it will include header `<stdbool.h>` for nk_bool otherwise nuklear defines nk_bool as int.\nNK_INCLUDE_VERTEX_BUFFER_OUTPUT | Defining this adds a vertex draw command list backend to this library, which allows you to convert queue commands into vertex draw commands. This is mainly if you need a hardware accessible format for OpenGL, DirectX, Vulkan, Metal,...\nNK_INCLUDE_FONT_BAKING          | Defining this adds `stb_truetype` and `stb_rect_pack` implementation to this library and provides font baking and rendering. If you already have font handling or do not want to use this font handler you don't have to define it.\nNK_INCLUDE_DEFAULT_FONT         | Defining this adds the default font: ProggyClean.ttf into this library which can be loaded into a font atlas and allows using this library without having a truetype font\nNK_INCLUDE_COMMAND_USERDATA     | Defining this adds a userdata pointer into each command. Can be useful for example if you want to provide custom shaders depending on the used widget. Can be combined with the style structures.\nNK_BUTTON_TRIGGER_ON_RELEASE    | Different platforms require button clicks occurring either on buttons being pressed (up to down) or released (down to up). By default this library will react on buttons being pressed, but if you define this it will only trigger if a button is released.\nNK_ZERO_COMMAND_MEMORY          | Defining this will zero out memory for each drawing command added to a drawing queue (inside nk_command_buffer_push). Zeroing command memory is very useful for fast checking (using memcmp) if command buffers are equal and avoid drawing frames when nothing on screen has changed since previous frame.\nNK_UINT_DRAW_INDEX              | Defining this will set the size of vertex index elements when using NK_VERTEX_BUFFER_OUTPUT to 32bit instead of the default of 16bit\nNK_KEYSTATE_BASED_INPUT         | Define this if your backend uses key state for each frame rather than key press/release events\n\n!!! WARNING\n    The following flags will pull in the standard C library:\n    - NK_INCLUDE_DEFAULT_ALLOCATOR\n    - NK_INCLUDE_STANDARD_IO\n    - NK_INCLUDE_STANDARD_VARARGS\n\n!!! WARNING\n    The following flags if defined need to be defined for both header and implementation:\n    - NK_INCLUDE_FIXED_TYPES\n    - NK_INCLUDE_DEFAULT_ALLOCATOR\n    - NK_INCLUDE_STANDARD_VARARGS\n    - NK_INCLUDE_STANDARD_BOOL\n    - NK_INCLUDE_VERTEX_BUFFER_OUTPUT\n    - NK_INCLUDE_FONT_BAKING\n    - NK_INCLUDE_DEFAULT_FONT\n    - NK_INCLUDE_STANDARD_VARARGS\n    - NK_INCLUDE_COMMAND_USERDATA\n    - NK_UINT_DRAW_INDEX\n\n### Constants\nDefine                          | Description\n--------------------------------|---------------------------------------\nNK_BUFFER_DEFAULT_INITIAL_SIZE  | Initial buffer size allocated by all buffers while using the default allocator functions included by defining NK_INCLUDE_DEFAULT_ALLOCATOR. If you don't want to allocate the default 4k memory then redefine it.\nNK_MAX_NUMBER_BUFFER            | Maximum buffer size for the conversion buffer between float and string Under normal circumstances this should be more than sufficient.\nNK_INPUT_MAX                    | Defines the max number of bytes which can be added as text input in one frame. Under normal circumstances this should be more than sufficient.\n\n!!! WARNING\n    The following constants if defined need to be defined for both header and implementation:\n    - NK_MAX_NUMBER_BUFFER\n    - NK_BUFFER_DEFAULT_INITIAL_SIZE\n    - NK_INPUT_MAX\n\n### Dependencies\nFunction    | Description\n------------|---------------------------------------------------------------\nNK_ASSERT   | If you don't define this, nuklear will use <assert.h> with assert().\nNK_MEMSET   | You can define this to 'memset' or your own memset implementation replacement. If not nuklear will use its own version.\nNK_MEMCPY   | You can define this to 'memcpy' or your own memcpy implementation replacement. If not nuklear will use its own version.\nNK_INV_SQRT | You can define this to your own inverse sqrt implementation replacement. If not nuklear will use its own slow and not highly accurate version.\nNK_SIN      | You can define this to 'sinf' or your own sine implementation replacement. If not nuklear will use its own approximation implementation.\nNK_COS      | You can define this to 'cosf' or your own cosine implementation replacement. If not nuklear will use its own approximation implementation.\nNK_STRTOD   | You can define this to `strtod` or your own string to double conversion implementation replacement. If not defined nuklear will use its own imprecise and possibly unsafe version (does not handle nan or infinity!).\nNK_DTOA     | You can define this to `dtoa` or your own double to string conversion implementation replacement. If not defined nuklear will use its own imprecise and possibly unsafe version (does not handle nan or infinity!).\nNK_VSNPRINTF| If you define `NK_INCLUDE_STANDARD_VARARGS` as well as `NK_INCLUDE_STANDARD_IO` and want to be safe define this to `vsnprintf` on compilers supporting later versions of C or C++. By default nuklear will check for your stdlib version in C as well as compiler version in C++. if `vsnprintf` is available it will define it to `vsnprintf` directly. If not defined and if you have older versions of C or C++ it will be defined to `vsprintf` which is unsafe.\n\n!!! WARNING\n    The following dependencies will pull in the standard C library if not redefined:\n    - NK_ASSERT\n\n!!! WARNING\n    The following dependencies if defined need to be defined for both header and implementation:\n    - NK_ASSERT\n\n!!! WARNING\n    The following dependencies if defined need to be defined only for the implementation part:\n    - NK_MEMSET\n    - NK_MEMCPY\n    - NK_SQRT\n    - NK_SIN\n    - NK_COS\n    - NK_STRTOD\n    - NK_DTOA\n    - NK_VSNPRINTF\n\n## Example\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c\n// init gui state\nenum {EASY, HARD};\nstatic int op = EASY;\nstatic float value = 0.6f;\nstatic int i =  20;\nstruct nk_context ctx;\n\nnk_init_fixed(&ctx, calloc(1, MAX_MEMORY), MAX_MEMORY, &font);\nif (nk_begin(&ctx, \"Show\", nk_rect(50, 50, 220, 220),\n    NK_WINDOW_BORDER|NK_WINDOW_MOVABLE|NK_WINDOW_CLOSABLE)) {\n    // fixed widget pixel width\n    nk_layout_row_static(&ctx, 30, 80, 1);\n    if (nk_button_label(&ctx, \"button\")) {\n        // event handling\n    }\n\n    // fixed widget window ratio width\n    nk_layout_row_dynamic(&ctx, 30, 2);\n    if (nk_option_label(&ctx, \"easy\", op == EASY)) op = EASY;\n    if (nk_option_label(&ctx, \"hard\", op == HARD)) op = HARD;\n\n    // custom widget pixel width\n    nk_layout_row_begin(&ctx, NK_STATIC, 30, 2);\n    {\n        nk_layout_row_push(&ctx, 50);\n        nk_label(&ctx, \"Volume:\", NK_TEXT_LEFT);\n        nk_layout_row_push(&ctx, 110);\n        nk_slider_float(&ctx, 0, &value, 1.0f, 0.1f);\n    }\n    nk_layout_row_end(&ctx);\n}\nnk_end(&ctx);\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n![](https://cloud.githubusercontent.com/assets/8057201/10187981/584ecd68-675c-11e5-897c-822ef534a876.png)\n\n## API\n\n*/\n#ifndef NK_SINGLE_FILE\n  #define NK_SINGLE_FILE\n#endif\n\n/** \\file nuklear.h\n * \\brief main API and documentation file\n *\n * \\details\n */\n#ifndef NK_NUKLEAR_H_\n#define NK_NUKLEAR_H_\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n/*\n * ==============================================================\n *\n *                          CONSTANTS\n *\n * ===============================================================\n */\n\n#define NK_UNDEFINED (-1.0f)\n#define NK_UTF_INVALID 0xFFFD /**< internal invalid utf8 rune */\n#define NK_UTF_SIZE 4 /**< describes the number of bytes a glyph consists of*/\n#ifndef NK_INPUT_MAX\n  #define NK_INPUT_MAX 16\n#endif\n#ifndef NK_MAX_NUMBER_BUFFER\n  #define NK_MAX_NUMBER_BUFFER 64\n#endif\n#ifndef NK_SCROLLBAR_HIDING_TIMEOUT\n  #define NK_SCROLLBAR_HIDING_TIMEOUT 4.0f\n#endif\n/*\n * ==============================================================\n *\n *                          HELPER\n *\n * ===============================================================\n */\n\n#ifndef NK_API\n  #ifdef NK_PRIVATE\n    #if (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199409L))\n      #define NK_API static inline\n    #elif defined(__cplusplus)\n      #define NK_API static inline\n    #else\n      #define NK_API static\n    #endif\n  #else\n    #define NK_API extern\n  #endif\n#endif\n#ifndef NK_LIB\n  #ifdef NK_SINGLE_FILE\n    #define NK_LIB static\n  #else\n    #define NK_LIB extern\n  #endif\n#endif\n\n#define NK_INTERN static\n#define NK_STORAGE static\n#define NK_GLOBAL static\n\n#define NK_FLAG(x) (1 << (x))\n#define NK_STRINGIFY(x) #x\n#define NK_MACRO_STRINGIFY(x) NK_STRINGIFY(x)\n#define NK_STRING_JOIN_IMMEDIATE(arg1, arg2) arg1 ## arg2\n#define NK_STRING_JOIN_DELAY(arg1, arg2) NK_STRING_JOIN_IMMEDIATE(arg1, arg2)\n#define NK_STRING_JOIN(arg1, arg2) NK_STRING_JOIN_DELAY(arg1, arg2)\n\n#ifdef _MSC_VER\n  #define NK_UNIQUE_NAME(name) NK_STRING_JOIN(name,__COUNTER__)\n#else\n  #define NK_UNIQUE_NAME(name) NK_STRING_JOIN(name,__LINE__)\n#endif\n\n#ifndef NK_STATIC_ASSERT\n  #define NK_STATIC_ASSERT(exp) typedef char NK_UNIQUE_NAME(_dummy_array)[(exp)?1:-1]\n#endif\n\n#ifndef NK_FILE_LINE\n#ifdef _MSC_VER\n  #define NK_FILE_LINE __FILE__ \":\" NK_MACRO_STRINGIFY(__COUNTER__)\n#else\n  #define NK_FILE_LINE __FILE__ \":\" NK_MACRO_STRINGIFY(__LINE__)\n#endif\n#endif\n\n#define NK_MIN(a,b) ((a) < (b) ? (a) : (b))\n#define NK_MAX(a,b) ((a) < (b) ? (b) : (a))\n#define NK_CLAMP(i,v,x) (NK_MAX(NK_MIN(v,x), i))\n\n#ifdef NK_INCLUDE_STANDARD_VARARGS\n  #include <stdarg.h>\n  #if defined(_MSC_VER) && (_MSC_VER >= 1600) /* VS 2010 and above */\n    #include <sal.h>\n    #define NK_PRINTF_FORMAT_STRING _Printf_format_string_\n  #else\n    #define NK_PRINTF_FORMAT_STRING\n  #endif\n  #if defined(__GNUC__)\n    #define NK_PRINTF_VARARG_FUNC(fmtargnumber) __attribute__((format(__printf__, fmtargnumber, fmtargnumber+1)))\n    #define NK_PRINTF_VALIST_FUNC(fmtargnumber) __attribute__((format(__printf__, fmtargnumber, 0)))\n  #else\n    #define NK_PRINTF_VARARG_FUNC(fmtargnumber)\n    #define NK_PRINTF_VALIST_FUNC(fmtargnumber)\n  #endif\n#endif\n\n/*\n * ===============================================================\n *\n *                          BASIC\n *\n * ===============================================================\n */\n #ifdef NK_INCLUDE_FIXED_TYPES\n #include <stdint.h>\n #define NK_INT8 int8_t\n #define NK_UINT8 uint8_t\n #define NK_INT16 int16_t\n #define NK_UINT16 uint16_t\n #define NK_INT32 int32_t\n #define NK_UINT32 uint32_t\n #define NK_SIZE_TYPE uintptr_t\n #define NK_POINTER_TYPE uintptr_t\n#else\n  #ifndef NK_INT8\n    #define NK_INT8 signed char\n  #endif\n  #ifndef NK_UINT8\n    #define NK_UINT8 unsigned char\n  #endif\n  #ifndef NK_INT16\n    #define NK_INT16 signed short\n  #endif\n  #ifndef NK_UINT16\n    #define NK_UINT16 unsigned short\n  #endif\n  #ifndef NK_INT32\n    #if defined(_MSC_VER)\n      #define NK_INT32 __int32\n    #else\n      #define NK_INT32 signed int\n    #endif\n  #endif\n  #ifndef NK_UINT32\n    #if defined(_MSC_VER)\n      #define NK_UINT32 unsigned __int32\n    #else\n      #define NK_UINT32 unsigned int\n    #endif\n  #endif\n  #ifndef NK_SIZE_TYPE\n    #if defined(_WIN64) && defined(_MSC_VER)\n      #define NK_SIZE_TYPE unsigned __int64\n    #elif (defined(_WIN32) || defined(WIN32)) && defined(_MSC_VER)\n      #define NK_SIZE_TYPE unsigned __int32\n    #elif defined(__GNUC__) || defined(__clang__)\n      #if defined(__x86_64__) || defined(__ppc64__) || defined(__PPC64__) || defined(__aarch64__)\n        #define NK_SIZE_TYPE unsigned long\n      #else\n        #define NK_SIZE_TYPE unsigned int\n      #endif\n    #else\n      #define NK_SIZE_TYPE unsigned long\n    #endif\n  #endif\n  #ifndef NK_POINTER_TYPE\n    #if defined(_WIN64) && defined(_MSC_VER)\n      #define NK_POINTER_TYPE unsigned __int64\n    #elif (defined(_WIN32) || defined(WIN32)) && defined(_MSC_VER)\n      #define NK_POINTER_TYPE unsigned __int32\n    #elif defined(__GNUC__) || defined(__clang__)\n      #if defined(__x86_64__) || defined(__ppc64__) || defined(__PPC64__) || defined(__aarch64__)\n        #define NK_POINTER_TYPE unsigned long\n      #else\n        #define NK_POINTER_TYPE unsigned int\n      #endif\n    #else\n      #define NK_POINTER_TYPE unsigned long\n    #endif\n  #endif\n#endif\n\n#ifndef NK_BOOL\n  #ifdef NK_INCLUDE_STANDARD_BOOL\n    #include <stdbool.h>\n    #define NK_BOOL bool\n  #else\n    #define NK_BOOL int /**< could be char, use int for drop-in replacement backwards compatibility */\n  #endif\n#endif\n\ntypedef NK_INT8 nk_char;\ntypedef NK_UINT8 nk_uchar;\ntypedef NK_UINT8 nk_byte;\ntypedef NK_INT16 nk_short;\ntypedef NK_UINT16 nk_ushort;\ntypedef NK_INT32 nk_int;\ntypedef NK_UINT32 nk_uint;\ntypedef NK_SIZE_TYPE nk_size;\ntypedef NK_POINTER_TYPE nk_ptr;\ntypedef NK_BOOL nk_bool;\n\ntypedef nk_uint nk_hash;\ntypedef nk_uint nk_flags;\ntypedef nk_uint nk_rune;\n\n/* Make sure correct type size:\n * This will fire with a negative subscript error if the type sizes\n * are set incorrectly by the compiler, and compile out if not */\nNK_STATIC_ASSERT(sizeof(nk_short) == 2);\nNK_STATIC_ASSERT(sizeof(nk_ushort) == 2);\nNK_STATIC_ASSERT(sizeof(nk_uint) == 4);\nNK_STATIC_ASSERT(sizeof(nk_int) == 4);\nNK_STATIC_ASSERT(sizeof(nk_byte) == 1);\nNK_STATIC_ASSERT(sizeof(nk_flags) >= 4);\nNK_STATIC_ASSERT(sizeof(nk_rune) >= 4);\nNK_STATIC_ASSERT(sizeof(nk_size) >= sizeof(void*));\nNK_STATIC_ASSERT(sizeof(nk_ptr) >= sizeof(void*));\n#ifdef NK_INCLUDE_STANDARD_BOOL\nNK_STATIC_ASSERT(sizeof(nk_bool) == sizeof(bool));\n#else\nNK_STATIC_ASSERT(sizeof(nk_bool) >= 2);\n#endif\n\n/* ============================================================================\n *\n *                                  API\n *\n * =========================================================================== */\nstruct nk_buffer;\nstruct nk_allocator;\nstruct nk_command_buffer;\nstruct nk_draw_command;\nstruct nk_convert_config;\nstruct nk_style_item;\nstruct nk_text_edit;\nstruct nk_draw_list;\nstruct nk_user_font;\nstruct nk_panel;\nstruct nk_context;\nstruct nk_draw_vertex_layout_element;\nstruct nk_style_button;\nstruct nk_style_toggle;\nstruct nk_style_selectable;\nstruct nk_style_slide;\nstruct nk_style_progress;\nstruct nk_style_scrollbar;\nstruct nk_style_edit;\nstruct nk_style_property;\nstruct nk_style_chart;\nstruct nk_style_combo;\nstruct nk_style_tab;\nstruct nk_style_window_header;\nstruct nk_style_window;\n\nenum {nk_false, nk_true};\nstruct nk_color {nk_byte r,g,b,a;};\nstruct nk_colorf {float r,g,b,a;};\nstruct nk_vec2 {float x,y;};\nstruct nk_vec2i {short x, y;};\nstruct nk_rect {float x,y,w,h;};\nstruct nk_recti {short x,y,w,h;};\ntypedef char nk_glyph[NK_UTF_SIZE];\ntypedef union {void *ptr; int id;} nk_handle;\nstruct nk_image {nk_handle handle; nk_ushort w, h; nk_ushort region[4];};\nstruct nk_nine_slice {struct nk_image img; nk_ushort l, t, r, b;};\nstruct nk_cursor {struct nk_image img; struct nk_vec2 size, offset;};\nstruct nk_scroll {nk_uint x, y;};\n\nenum nk_heading         {NK_UP, NK_RIGHT, NK_DOWN, NK_LEFT};\nenum nk_button_behavior {NK_BUTTON_DEFAULT, NK_BUTTON_REPEATER};\nenum nk_modify          {NK_FIXED = nk_false, NK_MODIFIABLE = nk_true};\nenum nk_orientation     {NK_VERTICAL, NK_HORIZONTAL};\nenum nk_collapse_states {NK_MINIMIZED = nk_false, NK_MAXIMIZED = nk_true};\nenum nk_show_states     {NK_HIDDEN = nk_false, NK_SHOWN = nk_true};\nenum nk_chart_type      {NK_CHART_LINES, NK_CHART_COLUMN, NK_CHART_MAX};\nenum nk_chart_event     {NK_CHART_HOVERING = 0x01, NK_CHART_CLICKED = 0x02};\nenum nk_color_format    {NK_RGB, NK_RGBA};\nenum nk_popup_type      {NK_POPUP_STATIC, NK_POPUP_DYNAMIC};\nenum nk_layout_format   {NK_DYNAMIC, NK_STATIC};\nenum nk_tree_type       {NK_TREE_NODE, NK_TREE_TAB};\n\ntypedef void*(*nk_plugin_alloc)(nk_handle, void *old, nk_size);\ntypedef void (*nk_plugin_free)(nk_handle, void *old);\ntypedef nk_bool(*nk_plugin_filter)(const struct nk_text_edit*, nk_rune unicode);\ntypedef void(*nk_plugin_paste)(nk_handle, struct nk_text_edit*);\ntypedef void(*nk_plugin_copy)(nk_handle, const char*, int len);\n\nstruct nk_allocator {\n    nk_handle userdata;\n    nk_plugin_alloc alloc;\n    nk_plugin_free free;\n};\nenum nk_symbol_type {\n    NK_SYMBOL_NONE,\n    NK_SYMBOL_X,\n    NK_SYMBOL_UNDERSCORE,\n    NK_SYMBOL_CIRCLE_SOLID,\n    NK_SYMBOL_CIRCLE_OUTLINE,\n    NK_SYMBOL_RECT_SOLID,\n    NK_SYMBOL_RECT_OUTLINE,\n    NK_SYMBOL_TRIANGLE_UP,\n    NK_SYMBOL_TRIANGLE_DOWN,\n    NK_SYMBOL_TRIANGLE_LEFT,\n    NK_SYMBOL_TRIANGLE_RIGHT,\n    NK_SYMBOL_PLUS,\n    NK_SYMBOL_MINUS,\n    NK_SYMBOL_TRIANGLE_UP_OUTLINE,\n    NK_SYMBOL_TRIANGLE_DOWN_OUTLINE,\n    NK_SYMBOL_TRIANGLE_LEFT_OUTLINE,\n    NK_SYMBOL_TRIANGLE_RIGHT_OUTLINE,\n    NK_SYMBOL_MAX\n};\n/* =============================================================================\n *\n *                                  CONTEXT\n *\n * =============================================================================*/\n/**\n * \\page Context\n * Contexts are the main entry point and the majestro of nuklear and contain all required state.\n * They are used for window, memory, input, style, stack, commands and time management and need\n * to be passed into all nuklear GUI specific functions.\n *\n * # Usage\n * To use a context it first has to be initialized which can be achieved by calling\n * one of either `nk_init_default`, `nk_init_fixed`, `nk_init`, `nk_init_custom`.\n * Each takes in a font handle and a specific way of handling memory. Memory control\n * hereby ranges from standard library to just specifying a fixed sized block of memory\n * which nuklear has to manage itself from.\n *\n * ```c\n * struct nk_context ctx;\n * nk_init_xxx(&ctx, ...);\n * while (1) {\n *     // [...]\n *     nk_clear(&ctx);\n * }\n * nk_free(&ctx);\n * ```\n *\n * # Reference\n * Function            | Description\n * --------------------|-------------------------------------------------------\n * \\ref nk_init_default | Initializes context with standard library memory allocation (malloc,free)\n * \\ref nk_init_fixed   | Initializes context from single fixed size memory block\n * \\ref nk_init         | Initializes context with memory allocator callbacks for alloc and free\n * \\ref nk_init_custom  | Initializes context from two buffers. One for draw commands the other for window/panel/table allocations\n * \\ref nk_clear        | Called at the end of the frame to reset and prepare the context for the next frame\n * \\ref nk_free         | Shutdown and free all memory allocated inside the context\n * \\ref nk_set_user_data| Utility function to pass user data to draw command\n */\n\n#ifdef NK_INCLUDE_DEFAULT_ALLOCATOR\n\n/**\n * # nk_init_default\n * Initializes a `nk_context` struct with a default standard library allocator.\n * Should be used if you don't want to be bothered with memory management in nuklear.\n *\n * ```c\n * nk_bool nk_init_default(struct nk_context *ctx, const struct nk_user_font *font);\n * ```\n *\n * Parameter   | Description\n * ------------|---------------------------------------------------------------\n * \\param[in] ctx     | Must point to an either stack or heap allocated `nk_context` struct\n * \\param[in] font    | Must point to a previously initialized font handle for more info look at font documentation\n *\n * \\returns either `false(0)` on failure or `true(1)` on success.\n */\nNK_API nk_bool nk_init_default(struct nk_context*, const struct nk_user_font*);\n#endif\n/**\n * # nk_init_fixed\n * Initializes a `nk_context` struct from single fixed size memory block\n * Should be used if you want complete control over nuklear's memory management.\n * Especially recommended for system with little memory or systems with virtual memory.\n * For the later case you can just allocate for example 16MB of virtual memory\n * and only the required amount of memory will actually be committed.\n *\n * ```c\n * nk_bool nk_init_fixed(struct nk_context *ctx, void *memory, nk_size size, const struct nk_user_font *font);\n * ```\n *\n * !!! Warning\n *     make sure the passed memory block is aligned correctly for `nk_draw_commands`.\n *\n * Parameter   | Description\n * ------------|--------------------------------------------------------------\n * \\param[in] ctx     | Must point to an either stack or heap allocated `nk_context` struct\n * \\param[in] memory  | Must point to a previously allocated memory block\n * \\param[in] size    | Must contain the total size of memory\n * \\param[in] font    | Must point to a previously initialized font handle for more info look at font documentation\n *\n * \\returns either `false(0)` on failure or `true(1)` on success.\n */\nNK_API nk_bool nk_init_fixed(struct nk_context*, void *memory, nk_size size, const struct nk_user_font*);\n\n/**\n * # nk_init\n * Initializes a `nk_context` struct with memory allocation callbacks for nuklear to allocate\n * memory from. Used internally for `nk_init_default` and provides a kitchen sink allocation\n * interface to nuklear. Can be useful for cases like monitoring memory consumption.\n *\n * ```c\n * nk_bool nk_init(struct nk_context *ctx, const struct nk_allocator *alloc, const struct nk_user_font *font);\n * ```\n *\n * Parameter   | Description\n * ------------|---------------------------------------------------------------\n * \\param[in] ctx     | Must point to an either stack or heap allocated `nk_context` struct\n * \\param[in] alloc   | Must point to a previously allocated memory allocator\n * \\param[in] font    | Must point to a previously initialized font handle for more info look at font documentation\n *\n * \\returns either `false(0)` on failure or `true(1)` on success.\n */\nNK_API nk_bool nk_init(struct nk_context*, const struct nk_allocator*, const struct nk_user_font*);\n\n/**\n * \\brief Initializes a `nk_context` struct from two different either fixed or growing buffers.\n *\n * \\details\n * The first buffer is for allocating draw commands while the second buffer is\n * used for allocating windows, panels and state tables.\n *\n * ```c\n * nk_bool nk_init_custom(struct nk_context *ctx, struct nk_buffer *cmds, struct nk_buffer *pool, const struct nk_user_font *font);\n * ```\n *\n * \\param[in] ctx    Must point to an either stack or heap allocated `nk_context` struct\n * \\param[in] cmds   Must point to a previously initialized memory buffer either fixed or dynamic to store draw commands into\n * \\param[in] pool   Must point to a previously initialized memory buffer either fixed or dynamic to store windows, panels and tables\n * \\param[in] font   Must point to a previously initialized font handle for more info look at font documentation\n *\n * \\returns either `false(0)` on failure or `true(1)` on success.\n */\nNK_API nk_bool nk_init_custom(struct nk_context*, struct nk_buffer *cmds, struct nk_buffer *pool, const struct nk_user_font*);\n\n/**\n * \\brief Resets the context state at the end of the frame.\n *\n * \\details\n * This includes mostly garbage collector tasks like removing windows or table\n * not called and therefore used anymore.\n *\n * ```c\n * void nk_clear(struct nk_context *ctx);\n * ```\n *\n * \\param[in] ctx  Must point to a previously initialized `nk_context` struct\n */\nNK_API void nk_clear(struct nk_context*);\n\n/**\n * \\brief Frees all memory allocated by nuklear; Not needed if context was initialized with `nk_init_fixed`.\n *\n * \\details\n * ```c\n * void nk_free(struct nk_context *ctx);\n * ```\n *\n * \\param[in] ctx  Must point to a previously initialized `nk_context` struct\n */\nNK_API void nk_free(struct nk_context*);\n\n#ifdef NK_INCLUDE_COMMAND_USERDATA\n/**\n * \\brief Sets the currently passed userdata passed down into each draw command.\n *\n * \\details\n * ```c\n * void nk_set_user_data(struct nk_context *ctx, nk_handle data);\n * ```\n *\n * \\param[in] ctx Must point to a previously initialized `nk_context` struct\n * \\param[in] data  Handle with either pointer or index to be passed into every draw commands\n */\nNK_API void nk_set_user_data(struct nk_context*, nk_handle handle);\n#endif\n/* =============================================================================\n *\n *                                  INPUT\n *\n * =============================================================================*/\n/**\n * \\page Input\n *\n * The input API is responsible for holding the current input state composed of\n * mouse, key and text input states.\n * It is worth noting that no direct OS or window handling is done in nuklear.\n * Instead all input state has to be provided by platform specific code. This on one hand\n * expects more work from the user and complicates usage but on the other hand\n * provides simple abstraction over a big number of platforms, libraries and other\n * already provided functionality.\n *\n * ```c\n * nk_input_begin(&ctx);\n * while (GetEvent(&evt)) {\n *     if (evt.type == MOUSE_MOVE)\n *         nk_input_motion(&ctx, evt.motion.x, evt.motion.y);\n *     else if (evt.type == [...]) {\n *         // [...]\n *     }\n * } nk_input_end(&ctx);\n * ```\n *\n * # Usage\n * Input state needs to be provided to nuklear by first calling `nk_input_begin`\n * which resets internal state like delta mouse position and button transitions.\n * After `nk_input_begin` all current input state needs to be provided. This includes\n * mouse motion, button and key pressed and released, text input and scrolling.\n * Both event- or state-based input handling are supported by this API\n * and should work without problems. Finally after all input state has been\n * mirrored `nk_input_end` needs to be called to finish input process.\n *\n * ```c\n * struct nk_context ctx;\n * nk_init_xxx(&ctx, ...);\n * while (1) {\n *     Event evt;\n *     nk_input_begin(&ctx);\n *     while (GetEvent(&evt)) {\n *         if (evt.type == MOUSE_MOVE)\n *             nk_input_motion(&ctx, evt.motion.x, evt.motion.y);\n *         else if (evt.type == [...]) {\n *             // [...]\n *         }\n *     }\n *     nk_input_end(&ctx);\n *     // [...]\n *     nk_clear(&ctx);\n * } nk_free(&ctx);\n * ```\n *\n * # Reference\n * Function            | Description\n * --------------------|-------------------------------------------------------\n * \\ref nk_input_begin  | Begins the input mirroring process. Needs to be called before all other `nk_input_xxx` calls\n * \\ref nk_input_motion | Mirrors mouse cursor position\n * \\ref nk_input_key    | Mirrors key state with either pressed or released\n * \\ref nk_input_button | Mirrors mouse button state with either pressed or released\n * \\ref nk_input_scroll | Mirrors mouse scroll values\n * \\ref nk_input_char   | Adds a single ASCII text character into an internal text buffer\n * \\ref nk_input_glyph  | Adds a single multi-byte UTF-8 character into an internal text buffer\n * \\ref nk_input_unicode| Adds a single unicode rune into an internal text buffer\n * \\ref nk_input_end    | Ends the input mirroring process by calculating state changes. Don't call any `nk_input_xxx` function referenced above after this call\n */\n\nenum nk_keys {\n    NK_KEY_NONE,\n    NK_KEY_SHIFT,\n    NK_KEY_CTRL,\n    NK_KEY_DEL,\n    NK_KEY_ENTER,\n    NK_KEY_TAB,\n    NK_KEY_BACKSPACE,\n    NK_KEY_COPY,\n    NK_KEY_CUT,\n    NK_KEY_PASTE,\n    NK_KEY_UP,\n    NK_KEY_DOWN,\n    NK_KEY_LEFT,\n    NK_KEY_RIGHT,\n    /* Shortcuts: text field */\n    NK_KEY_TEXT_INSERT_MODE,\n    NK_KEY_TEXT_REPLACE_MODE,\n    NK_KEY_TEXT_RESET_MODE,\n    NK_KEY_TEXT_LINE_START,\n    NK_KEY_TEXT_LINE_END,\n    NK_KEY_TEXT_START,\n    NK_KEY_TEXT_END,\n    NK_KEY_TEXT_UNDO,\n    NK_KEY_TEXT_REDO,\n    NK_KEY_TEXT_SELECT_ALL,\n    NK_KEY_TEXT_WORD_LEFT,\n    NK_KEY_TEXT_WORD_RIGHT,\n    /* Shortcuts: scrollbar */\n    NK_KEY_SCROLL_START,\n    NK_KEY_SCROLL_END,\n    NK_KEY_SCROLL_DOWN,\n    NK_KEY_SCROLL_UP,\n    NK_KEY_MAX\n};\nenum nk_buttons {\n    NK_BUTTON_LEFT,\n    NK_BUTTON_MIDDLE,\n    NK_BUTTON_RIGHT,\n    NK_BUTTON_DOUBLE,\n    NK_BUTTON_MAX\n};\n\n/**\n * \\brief Begins the input mirroring process by resetting text, scroll\n * mouse, previous mouse position and movement as well as key state transitions.\n *\n * \\details\n * ```c\n * void nk_input_begin(struct nk_context*);\n * ```\n *\n * \\param[in] ctx Must point to a previously initialized `nk_context` struct\n */\nNK_API void nk_input_begin(struct nk_context*);\n\n/**\n * \\brief Mirrors current mouse position to nuklear\n *\n * \\details\n * ```c\n * void nk_input_motion(struct nk_context *ctx, int x, int y);\n * ```\n *\n * \\param[in] ctx   Must point to a previously initialized `nk_context` struct\n * \\param[in] x     Must hold an integer describing the current mouse cursor x-position\n * \\param[in] y     Must hold an integer describing the current mouse cursor y-position\n */\nNK_API void nk_input_motion(struct nk_context*, int x, int y);\n\n/**\n * \\brief Mirrors the state of a specific key to nuklear\n *\n * \\details\n * ```c\n * void nk_input_key(struct nk_context*, enum nk_keys key, nk_bool down);\n * ```\n *\n * \\param[in] ctx      Must point to a previously initialized `nk_context` struct\n * \\param[in] key      Must be any value specified in enum `nk_keys` that needs to be mirrored\n * \\param[in] down     Must be 0 for key is up and 1 for key is down\n */\nNK_API void nk_input_key(struct nk_context*, enum nk_keys, nk_bool down);\n\n/**\n * \\brief Mirrors the state of a specific mouse button to nuklear\n *\n * \\details\n * ```c\n * void nk_input_button(struct nk_context *ctx, enum nk_buttons btn, int x, int y, nk_bool down);\n * ```\n *\n * \\param[in] ctx     Must point to a previously initialized `nk_context` struct\n * \\param[in] btn     Must be any value specified in enum `nk_buttons` that needs to be mirrored\n * \\param[in] x       Must contain an integer describing mouse cursor x-position on click up/down\n * \\param[in] y       Must contain an integer describing mouse cursor y-position on click up/down\n * \\param[in] down    Must be 0 for key is up and 1 for key is down\n */\nNK_API void nk_input_button(struct nk_context*, enum nk_buttons, int x, int y, nk_bool down);\n\n/**\n * \\brief Copies the last mouse scroll value to nuklear.\n *\n * \\details\n * Is generally a scroll value. So does not have to come from mouse and could\n * also originate from balls, tracks, linear guide rails, or other programs.\n *\n * ```c\n * void nk_input_scroll(struct nk_context *ctx, struct nk_vec2 val);\n * ```\n *\n * \\param[in] ctx     | Must point to a previously initialized `nk_context` struct\n * \\param[in] val     | vector with both X- as well as Y-scroll value\n */\nNK_API void nk_input_scroll(struct nk_context*, struct nk_vec2 val);\n\n/**\n * \\brief Copies a single ASCII character into an internal text buffer\n *\n * \\details\n * This is basically a helper function to quickly push ASCII characters into\n * nuklear.\n *\n * \\note\n *     Stores up to NK_INPUT_MAX bytes between `nk_input_begin` and `nk_input_end`.\n *\n * ```c\n * void nk_input_char(struct nk_context *ctx, char c);\n * ```\n *\n * \\param[in] ctx     | Must point to a previously initialized `nk_context` struct\n * \\param[in] c       | Must be a single ASCII character preferable one that can be printed\n */\nNK_API void nk_input_char(struct nk_context*, char);\n\n/**\n * \\brief Converts an encoded unicode rune into UTF-8 and copies the result into an\n * internal text buffer.\n *\n * \\note\n *     Stores up to NK_INPUT_MAX bytes between `nk_input_begin` and `nk_input_end`.\n *\n * ```c\n * void nk_input_glyph(struct nk_context *ctx, const nk_glyph g);\n * ```\n *\n * \\param[in] ctx     | Must point to a previously initialized `nk_context` struct\n * \\param[in] g       | UTF-32 unicode codepoint\n */\nNK_API void nk_input_glyph(struct nk_context*, const nk_glyph);\n\n/**\n * \\brief Converts a unicode rune into UTF-8 and copies the result\n * into an internal text buffer.\n *\n * \\details\n * \\note\n *     Stores up to NK_INPUT_MAX bytes between `nk_input_begin` and `nk_input_end`.\n *\n * ```c\n * void nk_input_unicode(struct nk_context*, nk_rune rune);\n * ```\n *\n * \\param[in] ctx     | Must point to a previously initialized `nk_context` struct\n * \\param[in] rune    | UTF-32 unicode codepoint\n */\nNK_API void nk_input_unicode(struct nk_context*, nk_rune);\n\n/**\n * \\brief End the input mirroring process by resetting mouse grabbing\n * state to ensure the mouse cursor is not grabbed indefinitely.\n *\n * \\details\n * ```c\n * void nk_input_end(struct nk_context *ctx);\n * ```\n *\n * \\param[in] ctx     | Must point to a previously initialized `nk_context` struct\n */\nNK_API void nk_input_end(struct nk_context*);\n\n/** =============================================================================\n *\n *                                  DRAWING\n *\n * =============================================================================*/\n/**\n * \\page Drawing\n * This library was designed to be render backend agnostic so it does\n * not draw anything to screen directly. Instead all drawn shapes, widgets\n * are made of, are buffered into memory and make up a command queue.\n * Each frame therefore fills the command buffer with draw commands\n * that then need to be executed by the user and his own render backend.\n * After that the command buffer needs to be cleared and a new frame can be\n * started. It is probably important to note that the command buffer is the main\n * drawing API and the optional vertex buffer API only takes this format and\n * converts it into a hardware accessible format.\n *\n * # Usage\n * To draw all draw commands accumulated over a frame you need your own render\n * backend able to draw a number of 2D primitives. This includes at least\n * filled and stroked rectangles, circles, text, lines, triangles and scissors.\n * As soon as this criterion is met you can iterate over each draw command\n * and execute each draw command in a interpreter like fashion:\n *\n * ```c\n * const struct nk_command *cmd = 0;\n * nk_foreach(cmd, &ctx) {\n *     switch (cmd->type) {\n *     case NK_COMMAND_LINE:\n *         your_draw_line_function(...)\n *         break;\n *     case NK_COMMAND_RECT\n *         your_draw_rect_function(...)\n *         break;\n *     case //...:\n *         //[...]\n *     }\n * }\n * ```\n *\n * In program flow context draw commands need to be executed after input has been\n * gathered and the complete UI with windows and their contained widgets have\n * been executed and before calling `nk_clear` which frees all previously\n * allocated draw commands.\n *\n * ```c\n * struct nk_context ctx;\n * nk_init_xxx(&ctx, ...);\n * while (1) {\n *     Event evt;\n *     nk_input_begin(&ctx);\n *     while (GetEvent(&evt)) {\n *         if (evt.type == MOUSE_MOVE)\n *             nk_input_motion(&ctx, evt.motion.x, evt.motion.y);\n *         else if (evt.type == [...]) {\n *             [...]\n *         }\n *     }\n *     nk_input_end(&ctx);\n *     //\n *     // [...]\n *     //\n *     const struct nk_command *cmd = 0;\n *     nk_foreach(cmd, &ctx) {\n *     switch (cmd->type) {\n *     case NK_COMMAND_LINE:\n *         your_draw_line_function(...)\n *         break;\n *     case NK_COMMAND_RECT\n *         your_draw_rect_function(...)\n *         break;\n *     case ...:\n *         // [...]\n *     }\n *     nk_clear(&ctx);\n * }\n * nk_free(&ctx);\n * ```\n *\n * You probably noticed that you have to draw all of the UI each frame which is\n * quite wasteful. While the actual UI updating loop is quite fast rendering\n * without actually needing it is not. So there are multiple things you could do.\n *\n * First is only update on input. This of course is only an option if your\n * application only depends on the UI and does not require any outside calculations.\n * If you actually only update on input make sure to update the UI two times each\n * frame and call `nk_clear` directly after the first pass and only draw in\n * the second pass. In addition it is recommended to also add additional timers\n * to make sure the UI is not drawn more than a fixed number of frames per second.\n *\n * ```c\n * struct nk_context ctx;\n * nk_init_xxx(&ctx, ...);\n * while (1) {\n *     // [...wait for input ]\n *     // [...do two UI passes ...]\n *     do_ui(...)\n *     nk_clear(&ctx);\n *     do_ui(...)\n *     //\n *     // draw\n *     const struct nk_command *cmd = 0;\n *     nk_foreach(cmd, &ctx) {\n *     switch (cmd->type) {\n *     case NK_COMMAND_LINE:\n *         your_draw_line_function(...)\n *         break;\n *     case NK_COMMAND_RECT\n *         your_draw_rect_function(...)\n *         break;\n *     case ...:\n *         //[...]\n *     }\n *     nk_clear(&ctx);\n * }\n * nk_free(&ctx);\n * ```\n *\n * The second probably more applicable trick is to only draw if anything changed.\n * It is not really useful for applications with continuous draw loop but\n * quite useful for desktop applications. To actually get nuklear to only\n * draw on changes you first have to define `NK_ZERO_COMMAND_MEMORY` and\n * allocate a memory buffer that will store each unique drawing output.\n * After each frame you compare the draw command memory inside the library\n * with your allocated buffer by memcmp. If memcmp detects differences\n * you have to copy the command buffer into the allocated buffer\n * and then draw like usual (this example uses fixed memory but you could\n * use dynamically allocated memory).\n *\n * ```c\n * //[... other defines ...]\n * #define NK_ZERO_COMMAND_MEMORY\n * #include \"nuklear.h\"\n * //\n * // setup context\n * struct nk_context ctx;\n * void *last = calloc(1,64*1024);\n * void *buf = calloc(1,64*1024);\n * nk_init_fixed(&ctx, buf, 64*1024);\n * //\n * // loop\n * while (1) {\n *     // [...input...]\n *     // [...ui...]\n *     void *cmds = nk_buffer_memory(&ctx.memory);\n *     if (memcmp(cmds, last, ctx.memory.allocated)) {\n *         memcpy(last,cmds,ctx.memory.allocated);\n *         const struct nk_command *cmd = 0;\n *         nk_foreach(cmd, &ctx) {\n *             switch (cmd->type) {\n *             case NK_COMMAND_LINE:\n *                 your_draw_line_function(...)\n *                 break;\n *             case NK_COMMAND_RECT\n *                 your_draw_rect_function(...)\n *                 break;\n *             case ...:\n *                 // [...]\n *             }\n *         }\n *     }\n *     nk_clear(&ctx);\n * }\n * nk_free(&ctx);\n * ```\n *\n * Finally while using draw commands makes sense for higher abstracted platforms like\n * X11 and Win32 or drawing libraries it is often desirable to use graphics\n * hardware directly. Therefore it is possible to just define\n * `NK_INCLUDE_VERTEX_BUFFER_OUTPUT` which includes optional vertex output.\n * To access the vertex output you first have to convert all draw commands into\n * vertexes by calling `nk_convert` which takes in your preferred vertex format.\n * After successfully converting all draw commands just iterate over and execute all\n * vertex draw commands:\n *\n * ```c\n * // fill configuration\n * struct your_vertex\n * {\n *     float pos[2]; // important to keep it to 2 floats\n *     float uv[2];\n *     unsigned char col[4];\n * };\n * struct nk_convert_config cfg = {};\n * static const struct nk_draw_vertex_layout_element vertex_layout[] = {\n *     {NK_VERTEX_POSITION, NK_FORMAT_FLOAT, NK_OFFSETOF(struct your_vertex, pos)},\n *     {NK_VERTEX_TEXCOORD, NK_FORMAT_FLOAT, NK_OFFSETOF(struct your_vertex, uv)},\n *     {NK_VERTEX_COLOR, NK_FORMAT_R8G8B8A8, NK_OFFSETOF(struct your_vertex, col)},\n *     {NK_VERTEX_LAYOUT_END}\n * };\n * cfg.shape_AA = NK_ANTI_ALIASING_ON;\n * cfg.line_AA = NK_ANTI_ALIASING_ON;\n * cfg.vertex_layout = vertex_layout;\n * cfg.vertex_size = sizeof(struct your_vertex);\n * cfg.vertex_alignment = NK_ALIGNOF(struct your_vertex);\n * cfg.circle_segment_count = 22;\n * cfg.curve_segment_count = 22;\n * cfg.arc_segment_count = 22;\n * cfg.global_alpha = 1.0f;\n * cfg.tex_null = dev->tex_null;\n * //\n * // setup buffers and convert\n * struct nk_buffer cmds, verts, idx;\n * nk_buffer_init_default(&cmds);\n * nk_buffer_init_default(&verts);\n * nk_buffer_init_default(&idx);\n * nk_convert(&ctx, &cmds, &verts, &idx, &cfg);\n * //\n * // draw\n * nk_draw_foreach(cmd, &ctx, &cmds) {\n * if (!cmd->elem_count) continue;\n *     //[...]\n * }\n * nk_buffer_free(&cms);\n * nk_buffer_free(&verts);\n * nk_buffer_free(&idx);\n * ```\n *\n * # Reference\n * Function            | Description\n * --------------------|-------------------------------------------------------\n * \\ref nk__begin       | Returns the first draw command in the context draw command list to be drawn\n * \\ref nk__next        | Increments the draw command iterator to the next command inside the context draw command list\n * \\ref nk_foreach      | Iterates over each draw command inside the context draw command list\n * \\ref nk_convert      | Converts from the abstract draw commands list into a hardware accessible vertex format\n * \\ref nk_draw_begin   | Returns the first vertex command in the context vertex draw list to be executed\n * \\ref nk__draw_next   | Increments the vertex command iterator to the next command inside the context vertex command list\n * \\ref nk__draw_end    | Returns the end of the vertex draw list\n * \\ref nk_draw_foreach | Iterates over each vertex draw command inside the vertex draw list\n */\n\nenum nk_anti_aliasing {NK_ANTI_ALIASING_OFF, NK_ANTI_ALIASING_ON};\nenum nk_convert_result {\n    NK_CONVERT_SUCCESS = 0,\n    NK_CONVERT_INVALID_PARAM = 1,\n    NK_CONVERT_COMMAND_BUFFER_FULL = NK_FLAG(1),\n    NK_CONVERT_VERTEX_BUFFER_FULL = NK_FLAG(2),\n    NK_CONVERT_ELEMENT_BUFFER_FULL = NK_FLAG(3)\n};\nstruct nk_draw_null_texture {\n    nk_handle texture; /**!< texture handle to a texture with a white pixel */\n    struct nk_vec2 uv; /**!< coordinates to a white pixel in the texture  */\n};\nstruct nk_convert_config {\n    float global_alpha;             /**!< global alpha value */\n    enum nk_anti_aliasing line_AA;  /**!< line anti-aliasing flag can be turned off if you are tight on memory */\n    enum nk_anti_aliasing shape_AA; /**!< shape anti-aliasing flag can be turned off if you are tight on memory */\n    unsigned circle_segment_count;  /**!< number of segments used for circles: default to 22 */\n    unsigned arc_segment_count;     /**!< number of segments used for arcs: default to 22 */\n    unsigned curve_segment_count;   /**!< number of segments used for curves: default to 22 */\n    struct nk_draw_null_texture tex_null; /**!< handle to texture with a white pixel for shape drawing */\n    const struct nk_draw_vertex_layout_element *vertex_layout; /**!< describes the vertex output format and packing */\n    nk_size vertex_size;      /**!< sizeof one vertex for vertex packing */\n    nk_size vertex_alignment; /**!< vertex alignment: Can be obtained by NK_ALIGNOF */\n};\n\n/**\n * \\brief Returns a draw command list iterator to iterate all draw\n * commands accumulated over one frame.\n *\n * \\details\n * ```c\n * const struct nk_command* nk__begin(struct nk_context*);\n * ```\n *\n * \\param[in] ctx     | must point to an previously initialized `nk_context` struct at the end of a frame\n *\n * \\returns draw command pointer pointing to the first command inside the draw command list\n */\nNK_API const struct nk_command* nk__begin(struct nk_context*);\n\n/**\n * \\brief Returns draw command pointer pointing to the next command inside the draw command list\n *\n * \\details\n * ```c\n * const struct nk_command* nk__next(struct nk_context*, const struct nk_command*);\n * ```\n *\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct at the end of a frame\n * \\param[in] cmd     | Must point to an previously a draw command either returned by `nk__begin` or `nk__next`\n *\n * \\returns draw command pointer pointing to the next command inside the draw command list\n */\nNK_API const struct nk_command* nk__next(struct nk_context*, const struct nk_command*);\n\n/**\n * \\brief Iterates over each draw command inside the context draw command list\n *\n * ```c\n * #define nk_foreach(c, ctx)\n * ```\n *\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct at the end of a frame\n * \\param[in] cmd     | Command pointer initialized to NULL\n */\n#define nk_foreach(c, ctx) for((c) = nk__begin(ctx); (c) != 0; (c) = nk__next(ctx,c))\n\n#ifdef NK_INCLUDE_VERTEX_BUFFER_OUTPUT\n\n/**\n * \\brief Converts all internal draw commands into vertex draw commands and fills\n * three buffers with vertexes, vertex draw commands and vertex indices.\n *\n * \\details\n * The vertex format as well as some other configuration values have to be\n * configured by filling out a `nk_convert_config` struct.\n *\n * ```c\n * nk_flags nk_convert(struct nk_context *ctx, struct nk_buffer *cmds,\n *     struct nk_buffer *vertices, struct nk_buffer *elements, const struct nk_convert_config*);\n * ```\n *\n * \\param[in] ctx      Must point to an previously initialized `nk_context` struct at the end of a frame\n * \\param[out] cmds     Must point to a previously initialized buffer to hold converted vertex draw commands\n * \\param[out] vertices Must point to a previously initialized buffer to hold all produced vertices\n * \\param[out] elements Must point to a previously initialized buffer to hold all produced vertex indices\n * \\param[in] config   Must point to a filled out `nk_config` struct to configure the conversion process\n *\n * \\returns one of enum nk_convert_result error codes\n *\n * Parameter                       | Description\n * --------------------------------|-----------------------------------------------------------\n * NK_CONVERT_SUCCESS              | Signals a successful draw command to vertex buffer conversion\n * NK_CONVERT_INVALID_PARAM        | An invalid argument was passed in the function call\n * NK_CONVERT_COMMAND_BUFFER_FULL  | The provided buffer for storing draw commands is full or failed to allocate more memory\n * NK_CONVERT_VERTEX_BUFFER_FULL   | The provided buffer for storing vertices is full or failed to allocate more memory\n * NK_CONVERT_ELEMENT_BUFFER_FULL  | The provided buffer for storing indices is full or failed to allocate more memory\n */\nNK_API nk_flags nk_convert(struct nk_context*, struct nk_buffer *cmds, struct nk_buffer *vertices, struct nk_buffer *elements, const struct nk_convert_config*);\n\n/**\n * \\brief Returns a draw vertex command buffer iterator to iterate over the vertex draw command buffer\n *\n * \\details\n * ```c\n * const struct nk_draw_command* nk__draw_begin(const struct nk_context*, const struct nk_buffer*);\n * ```\n *\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct at the end of a frame\n * \\param[in] buf     | Must point to an previously by `nk_convert` filled out vertex draw command buffer\n *\n * \\returns vertex draw command pointer pointing to the first command inside the vertex draw command buffer\n */\nNK_API const struct nk_draw_command* nk__draw_begin(const struct nk_context*, const struct nk_buffer*);\n\n/**\n\n * # # nk__draw_end\n * \\returns the vertex draw command at the end of the vertex draw command buffer\n *\n * ```c\n * const struct nk_draw_command* nk__draw_end(const struct nk_context *ctx, const struct nk_buffer *buf);\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct at the end of a frame\n * \\param[in] buf     | Must point to an previously by `nk_convert` filled out vertex draw command buffer\n *\n * \\returns vertex draw command pointer pointing to the end of the last vertex draw command inside the vertex draw command buffer\n\n */\nNK_API const struct nk_draw_command* nk__draw_end(const struct nk_context*, const struct nk_buffer*);\n\n/**\n * # # nk__draw_next\n * Increments the vertex draw command buffer iterator\n *\n * ```c\n * const struct nk_draw_command* nk__draw_next(const struct nk_draw_command*, const struct nk_buffer*, const struct nk_context*);\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] cmd     | Must point to an previously either by `nk__draw_begin` or `nk__draw_next` returned vertex draw command\n * \\param[in] buf     | Must point to an previously by `nk_convert` filled out vertex draw command buffer\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct at the end of a frame\n *\n * \\returns vertex draw command pointer pointing to the end of the last vertex draw command inside the vertex draw command buffer\n\n */\nNK_API const struct nk_draw_command* nk__draw_next(const struct nk_draw_command*, const struct nk_buffer*, const struct nk_context*);\n\n/**\n * # # nk_draw_foreach\n * Iterates over each vertex draw command inside a vertex draw command buffer\n *\n * ```c\n * #define nk_draw_foreach(cmd,ctx, b)\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] cmd     | `nk_draw_command`iterator set to NULL\n * \\param[in] buf     | Must point to an previously by `nk_convert` filled out vertex draw command buffer\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct at the end of a frame\n */\n\n#define nk_draw_foreach(cmd,ctx, b) for((cmd)=nk__draw_begin(ctx, b); (cmd)!=0; (cmd)=nk__draw_next(cmd, b, ctx))\n#endif\n\n/** =============================================================================\n *\n *                                  WINDOW\n *\n * =============================================================================*/\n/**\n * \\page Window\n * Windows are the main persistent state used inside nuklear and are life time\n * controlled by simply \"retouching\" (i.e. calling) each window each frame.\n * All widgets inside nuklear can only be added inside the function pair `nk_begin_xxx`\n * and `nk_end`. Calling any widgets outside these two functions will result in an\n * assert in debug or no state change in release mode.<br /><br />\n *\n * Each window holds frame persistent state like position, size, flags, state tables,\n * and some garbage collected internal persistent widget state. Each window\n * is linked into a window stack list which determines the drawing and overlapping\n * order. The topmost window thereby is the currently active window.<br /><br />\n *\n * To change window position inside the stack occurs either automatically by\n * user input by being clicked on or programmatically by calling `nk_window_focus`.\n * Windows by default are visible unless explicitly being defined with flag\n * `NK_WINDOW_HIDDEN`, the user clicked the close button on windows with flag\n * `NK_WINDOW_CLOSABLE` or if a window was explicitly hidden by calling\n * `nk_window_show`. To explicitly close and destroy a window call `nk_window_close`.<br /><br />\n *\n * # Usage\n * To create and keep a window you have to call one of the two `nk_begin_xxx`\n * functions to start window declarations and `nk_end` at the end. Furthermore it\n * is recommended to check the return value of `nk_begin_xxx` and only process\n * widgets inside the window if the value is not 0. Either way you have to call\n * `nk_end` at the end of window declarations. Furthermore, do not attempt to\n * nest `nk_begin_xxx` calls which will hopefully result in an assert or if not\n * in a segmentation fault.\n *\n * ```c\n * if (nk_begin_xxx(...) {\n *     // [... widgets ...]\n * }\n * nk_end(ctx);\n * ```\n *\n * In the grand concept window and widget declarations need to occur after input\n * handling and before drawing to screen. Not doing so can result in higher\n * latency or at worst invalid behavior. Furthermore make sure that `nk_clear`\n * is called at the end of the frame. While nuklear's default platform backends\n * already call `nk_clear` for you if you write your own backend not calling\n * `nk_clear` can cause asserts or even worse undefined behavior.\n *\n * ```c\n * struct nk_context ctx;\n * nk_init_xxx(&ctx, ...);\n * while (1) {\n *     Event evt;\n *     nk_input_begin(&ctx);\n *     while (GetEvent(&evt)) {\n *         if (evt.type == MOUSE_MOVE)\n *             nk_input_motion(&ctx, evt.motion.x, evt.motion.y);\n *         else if (evt.type == [...]) {\n *             nk_input_xxx(...);\n *         }\n *     }\n *     nk_input_end(&ctx);\n *\n *     if (nk_begin_xxx(...) {\n *         //[...]\n *     }\n *     nk_end(ctx);\n *\n *     const struct nk_command *cmd = 0;\n *     nk_foreach(cmd, &ctx) {\n *     case NK_COMMAND_LINE:\n *         your_draw_line_function(...)\n *         break;\n *     case NK_COMMAND_RECT\n *         your_draw_rect_function(...)\n *         break;\n *     case //...:\n *         //[...]\n *     }\n *     nk_clear(&ctx);\n * }\n * nk_free(&ctx);\n * ```\n *\n * # Reference\n * Function                            | Description\n * ------------------------------------|----------------------------------------\n * \\ref nk_begin                            | Starts a new window; needs to be called every frame for every window (unless hidden) or otherwise the window gets removed\n * \\ref nk_begin_titled                     | Extended window start with separated title and identifier to allow multiple windows with same name but not title\n * \\ref nk_end                              | Needs to be called at the end of the window building process to process scaling, scrollbars and general cleanup\n *\n * \\ref nk_window_find                      | Finds and returns the window with give name\n * \\ref nk_window_get_bounds                | Returns a rectangle with screen position and size of the currently processed window.\n * \\ref nk_window_get_position              | Returns the position of the currently processed window\n * \\ref nk_window_get_size                  | Returns the size with width and height of the currently processed window\n * \\ref nk_window_get_width                 | Returns the width of the currently processed window\n * \\ref nk_window_get_height                | Returns the height of the currently processed window\n * \\ref nk_window_get_panel                 | Returns the underlying panel which contains all processing state of the current window\n * \\ref nk_window_get_content_region        | Returns the position and size of the currently visible and non-clipped space inside the currently processed window\n * \\ref nk_window_get_content_region_min    | Returns the upper rectangle position of the currently visible and non-clipped space inside the currently processed window\n * \\ref nk_window_get_content_region_max    | Returns the upper rectangle position of the currently visible and non-clipped space inside the currently processed window\n * \\ref nk_window_get_content_region_size   | Returns the size of the currently visible and non-clipped space inside the currently processed window\n * \\ref nk_window_get_canvas                | Returns the draw command buffer. Can be used to draw custom widgets\n * \\ref nk_window_get_scroll                | Gets the scroll offset of the current window\n * \\ref nk_window_has_focus                 | Returns if the currently processed window is currently active\n * \\ref nk_window_is_collapsed              | Returns if the window with given name is currently minimized/collapsed\n * \\ref nk_window_is_closed                 | Returns if the currently processed window was closed\n * \\ref nk_window_is_hidden                 | Returns if the currently processed window was hidden\n * \\ref nk_window_is_active                 | Same as nk_window_has_focus for some reason\n * \\ref nk_window_is_hovered                | Returns if the currently processed window is currently being hovered by mouse\n * \\ref nk_window_is_any_hovered            | Return if any window currently hovered\n * \\ref nk_item_is_any_active               | Returns if any window or widgets is currently hovered or active\n//\n * \\ref nk_window_set_bounds                | Updates position and size of the currently processed window\n * \\ref nk_window_set_position              | Updates position of the currently process window\n * \\ref nk_window_set_size                  | Updates the size of the currently processed window\n * \\ref nk_window_set_focus                 | Set the currently processed window as active window\n * \\ref nk_window_set_scroll                | Sets the scroll offset of the current window\n//\n * \\ref nk_window_close                     | Closes the window with given window name which deletes the window at the end of the frame\n * \\ref nk_window_collapse                  | Collapses the window with given window name\n * \\ref nk_window_collapse_if               | Collapses the window with given window name if the given condition was met\n * \\ref nk_window_show                      | Hides a visible or reshows a hidden window\n * \\ref nk_window_show_if                   | Hides/shows a window depending on condition\n\n * # nk_panel_flags\n * Flag                        | Description\n * ----------------------------|----------------------------------------\n * NK_WINDOW_BORDER            | Draws a border around the window to visually separate window from the background\n * NK_WINDOW_MOVABLE           | The movable flag indicates that a window can be moved by user input or by dragging the window header\n * NK_WINDOW_SCALABLE          | The scalable flag indicates that a window can be scaled by user input by dragging a scaler icon at the button of the window\n * NK_WINDOW_CLOSABLE          | Adds a closable icon into the header\n * NK_WINDOW_MINIMIZABLE       | Adds a minimize icon into the header\n * NK_WINDOW_NO_SCROLLBAR      | Removes the scrollbar from the window\n * NK_WINDOW_TITLE             | Forces a header at the top at the window showing the title\n * NK_WINDOW_SCROLL_AUTO_HIDE  | Automatically hides the window scrollbar if no user interaction: also requires delta time in `nk_context` to be set each frame\n * NK_WINDOW_BACKGROUND        | Always keep window in the background\n * NK_WINDOW_SCALE_LEFT        | Puts window scaler in the left-bottom corner instead right-bottom\n * NK_WINDOW_NO_INPUT          | Prevents window of scaling, moving or getting focus\n *\n * # nk_collapse_states\n * State           | Description\n * ----------------|-----------------------------------------------------------\n * NK_MINIMIZED| UI section is collapsed and not visible until maximized\n * NK_MAXIMIZED| UI section is extended and visible until minimized\n */\n\nenum nk_panel_flags {\n    NK_WINDOW_BORDER            = NK_FLAG(0),\n    NK_WINDOW_MOVABLE           = NK_FLAG(1),\n    NK_WINDOW_SCALABLE          = NK_FLAG(2),\n    NK_WINDOW_CLOSABLE          = NK_FLAG(3),\n    NK_WINDOW_MINIMIZABLE       = NK_FLAG(4),\n    NK_WINDOW_NO_SCROLLBAR      = NK_FLAG(5),\n    NK_WINDOW_TITLE             = NK_FLAG(6),\n    NK_WINDOW_SCROLL_AUTO_HIDE  = NK_FLAG(7),\n    NK_WINDOW_BACKGROUND        = NK_FLAG(8),\n    NK_WINDOW_SCALE_LEFT        = NK_FLAG(9),\n    NK_WINDOW_NO_INPUT          = NK_FLAG(10)\n};\n\n/**\n * # # nk_begin\n * Starts a new window; needs to be called every frame for every\n * window (unless hidden) or otherwise the window gets removed\n *\n * ```c\n * nk_bool nk_begin(struct nk_context *ctx, const char *title, struct nk_rect bounds, nk_flags flags);\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct\n * \\param[in] title   | Window title and identifier. Needs to be persistent over frames to identify the window\n * \\param[in] bounds  | Initial position and window size. However if you do not define `NK_WINDOW_SCALABLE` or `NK_WINDOW_MOVABLE` you can set window position and size every frame\n * \\param[in] flags   | Window flags defined in the nk_panel_flags section with a number of different window behaviors\n *\n * \\returns `true(1)` if the window can be filled up with widgets from this point\n * until `nk_end` or `false(0)` otherwise for example if minimized\n\n */\nNK_API nk_bool nk_begin(struct nk_context *ctx, const char *title, struct nk_rect bounds, nk_flags flags);\n\n/**\n * # # nk_begin_titled\n * Extended window start with separated title and identifier to allow multiple\n * windows with same title but not name\n *\n * ```c\n * nk_bool nk_begin_titled(struct nk_context *ctx, const char *name, const char *title, struct nk_rect bounds, nk_flags flags);\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct\n * \\param[in] name    | Window identifier. Needs to be persistent over frames to identify the window\n * \\param[in] title   | Window title displayed inside header if flag `NK_WINDOW_TITLE` or either `NK_WINDOW_CLOSABLE` or `NK_WINDOW_MINIMIZED` was set\n * \\param[in] bounds  | Initial position and window size. However if you do not define `NK_WINDOW_SCALABLE` or `NK_WINDOW_MOVABLE` you can set window position and size every frame\n * \\param[in] flags   | Window flags defined in the nk_panel_flags section with a number of different window behaviors\n *\n * \\returns `true(1)` if the window can be filled up with widgets from this point\n * until `nk_end` or `false(0)` otherwise for example if minimized\n\n */\nNK_API nk_bool nk_begin_titled(struct nk_context *ctx, const char *name, const char *title, struct nk_rect bounds, nk_flags flags);\n\n/**\n * # # nk_end\n * Needs to be called at the end of the window building process to process scaling, scrollbars and general cleanup.\n * All widget calls after this functions will result in asserts or no state changes\n *\n * ```c\n * void nk_end(struct nk_context *ctx);\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct\n\n */\nNK_API void nk_end(struct nk_context *ctx);\n\n/**\n * # # nk_window_find\n * Finds and returns a window from passed name\n *\n * ```c\n * struct nk_window *nk_window_find(struct nk_context *ctx, const char *name);\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct\n * \\param[in] name    | Window identifier\n *\n * \\returns a `nk_window` struct pointing to the identified window or NULL if\n * no window with the given name was found\n */\nNK_API struct nk_window *nk_window_find(const struct nk_context *ctx, const char *name);\n\n/**\n * # # nk_window_get_bounds\n * \\returns a rectangle with screen position and size of the currently processed window\n *\n * !!! \\warning\n *     Only call this function between calls `nk_begin_xxx` and `nk_end`\n * ```c\n * struct nk_rect nk_window_get_bounds(const struct nk_context *ctx);\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct\n *\n * \\returns a `nk_rect` struct with window upper left window position and size\n\n */\nNK_API struct nk_rect nk_window_get_bounds(const struct nk_context *ctx);\n\n/**\n * # # nk_window_get_position\n * \\returns the position of the currently processed window.\n *\n * !!! \\warning\n *     Only call this function between calls `nk_begin_xxx` and `nk_end`\n * ```c\n * struct nk_vec2 nk_window_get_position(const struct nk_context *ctx);\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct\n *\n * \\returns a `nk_vec2` struct with window upper left position\n\n */\nNK_API struct nk_vec2 nk_window_get_position(const struct nk_context *ctx);\n\n/**\n * # # nk_window_get_size\n * \\returns the size with width and height of the currently processed window.\n *\n * !!! \\warning\n *     Only call this function between calls `nk_begin_xxx` and `nk_end`\n * ```c\n * struct nk_vec2 nk_window_get_size(const struct nk_context *ctx);\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct\n *\n * \\returns a `nk_vec2` struct with window width and height\n\n */\nNK_API struct nk_vec2 nk_window_get_size(const struct nk_context *ctx);\n\n/**\n * nk_window_get_width\n * \\returns the width of the currently processed window.\n *\n * !!! \\warning\n *     Only call this function between calls `nk_begin_xxx` and `nk_end`\n * ```c\n * float nk_window_get_width(const struct nk_context *ctx);\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct\n *\n * \\returns the current window width\n */\nNK_API float nk_window_get_width(const struct nk_context *ctx);\n\n/**\n * # # nk_window_get_height\n * \\returns the height of the currently processed window.\n *\n * !!! \\warning\n *     Only call this function between calls `nk_begin_xxx` and `nk_end`\n * ```c\n * float nk_window_get_height(const struct nk_context *ctx);\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct\n *\n * \\returns the current window height\n\n */\nNK_API float nk_window_get_height(const struct nk_context* ctx);\n\n/**\n * # # nk_window_get_panel\n * \\returns the underlying panel which contains all processing state of the current window.\n *\n * !!! \\warning\n *     Only call this function between calls `nk_begin_xxx` and `nk_end`\n * !!! \\warning\n *     Do not keep the returned panel pointer around, it is only valid until `nk_end`\n * ```c\n * struct nk_panel* nk_window_get_panel(struct nk_context *ctx);\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct\n *\n * \\returns a pointer to window internal `nk_panel` state.\n\n */\nNK_API struct nk_panel* nk_window_get_panel(const struct nk_context* ctx);\n\n/**\n * # # nk_window_get_content_region\n * \\returns the position and size of the currently visible and non-clipped space\n * inside the currently processed window.\n *\n * !!! \\warning\n *     Only call this function between calls `nk_begin_xxx` and `nk_end`\n *\n * ```c\n * struct nk_rect nk_window_get_content_region(struct nk_context *ctx);\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct\n *\n * \\returns `nk_rect` struct with screen position and size (no scrollbar offset)\n * of the visible space inside the current window\n\n */\nNK_API struct nk_rect nk_window_get_content_region(const struct nk_context* ctx);\n\n/**\n * # # nk_window_get_content_region_min\n * \\returns the upper left position of the currently visible and non-clipped\n * space inside the currently processed window.\n *\n * !!! \\warning\n *     Only call this function between calls `nk_begin_xxx` and `nk_end`\n *\n * ```c\n * struct nk_vec2 nk_window_get_content_region_min(struct nk_context *ctx);\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct\n *\n * returns `nk_vec2` struct with  upper left screen position (no scrollbar offset)\n * of the visible space inside the current window\n\n */\nNK_API struct nk_vec2 nk_window_get_content_region_min(const struct nk_context *ctx);\n\n/**\n * # # nk_window_get_content_region_max\n * \\returns the lower right screen position of the currently visible and\n * non-clipped space inside the currently processed window.\n *\n * !!! \\warning\n *     Only call this function between calls `nk_begin_xxx` and `nk_end`\n *\n * ```c\n * struct nk_vec2 nk_window_get_content_region_max(struct nk_context *ctx);\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct\n *\n * \\returns `nk_vec2` struct with lower right screen position (no scrollbar offset)\n * of the visible space inside the current window\n\n */\nNK_API struct nk_vec2 nk_window_get_content_region_max(const struct nk_context *ctx);\n\n/**\n * # # nk_window_get_content_region_size\n * \\returns the size of the currently visible and non-clipped space inside the\n * currently processed window\n *\n * !!! \\warning\n *     Only call this function between calls `nk_begin_xxx` and `nk_end`\n *\n * ```c\n * struct nk_vec2 nk_window_get_content_region_size(struct nk_context *ctx);\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct\n *\n * \\returns `nk_vec2` struct with size the visible space inside the current window\n\n */\nNK_API struct nk_vec2 nk_window_get_content_region_size(const struct nk_context *ctx);\n\n/**\n * # # nk_window_get_canvas\n * \\returns the draw command buffer. Can be used to draw custom widgets\n * !!! \\warning\n *     Only call this function between calls `nk_begin_xxx` and `nk_end`\n * !!! \\warning\n *     Do not keep the returned command buffer pointer around it is only valid until `nk_end`\n *\n * ```c\n * struct nk_command_buffer* nk_window_get_canvas(struct nk_context *ctx);\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct\n *\n * \\returns a pointer to window internal `nk_command_buffer` struct used as\n * drawing canvas. Can be used to do custom drawing.\n */\nNK_API struct nk_command_buffer* nk_window_get_canvas(const struct nk_context* ctx);\n\n/**\n * # # nk_window_get_scroll\n * Gets the scroll offset for the current window\n * !!! \\warning\n *     Only call this function between calls `nk_begin_xxx` and `nk_end`\n *\n * ```c\n * void nk_window_get_scroll(struct nk_context *ctx, nk_uint *offset_x, nk_uint *offset_y);\n * ```\n *\n * Parameter    | Description\n * -------------|-----------------------------------------------------------\n * \\param[in] ctx      | Must point to an previously initialized `nk_context` struct\n * \\param[in] offset_x | A pointer to the x offset output (or NULL to ignore)\n * \\param[in] offset_y | A pointer to the y offset output (or NULL to ignore)\n\n */\nNK_API void nk_window_get_scroll(const struct nk_context *ctx, nk_uint *offset_x, nk_uint *offset_y);\n\n/**\n * # # nk_window_has_focus\n * \\returns if the currently processed window is currently active\n * !!! \\warning\n *     Only call this function between calls `nk_begin_xxx` and `nk_end`\n * ```c\n * nk_bool nk_window_has_focus(const struct nk_context *ctx);\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct\n *\n * \\returns `false(0)` if current window is not active or `true(1)` if it is\n\n */\nNK_API nk_bool nk_window_has_focus(const struct nk_context *ctx);\n\n/**\n * # # nk_window_is_hovered\n * Return if the current window is being hovered\n * !!! \\warning\n *     Only call this function between calls `nk_begin_xxx` and `nk_end`\n * ```c\n * nk_bool nk_window_is_hovered(struct nk_context *ctx);\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct\n *\n * \\returns `true(1)` if current window is hovered or `false(0)` otherwise\n\n */\nNK_API nk_bool nk_window_is_hovered(const struct nk_context *ctx);\n\n/**\n * # # nk_window_is_collapsed\n * \\returns if the window with given name is currently minimized/collapsed\n * ```c\n * nk_bool nk_window_is_collapsed(struct nk_context *ctx, const char *name);\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct\n * \\param[in] name    | Identifier of window you want to check if it is collapsed\n *\n * \\returns `true(1)` if current window is minimized and `false(0)` if window not\n * found or is not minimized\n\n */\nNK_API nk_bool nk_window_is_collapsed(const struct nk_context *ctx, const char *name);\n\n/**\n * # # nk_window_is_closed\n * \\returns if the window with given name was closed by calling `nk_close`\n * ```c\n * nk_bool nk_window_is_closed(struct nk_context *ctx, const char *name);\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct\n * \\param[in] name    | Identifier of window you want to check if it is closed\n *\n * \\returns `true(1)` if current window was closed or `false(0)` window not found or not closed\n\n */\nNK_API nk_bool nk_window_is_closed(const struct nk_context *ctx, const char* name);\n\n/**\n * # # nk_window_is_hidden\n * \\returns if the window with given name is hidden\n * ```c\n * nk_bool nk_window_is_hidden(struct nk_context *ctx, const char *name);\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct\n * \\param[in] name    | Identifier of window you want to check if it is hidden\n *\n * \\returns `true(1)` if current window is hidden or `false(0)` window not found or visible\n\n */\nNK_API nk_bool nk_window_is_hidden(const struct nk_context *ctx, const char* name);\n\n/**\n * # # nk_window_is_active\n * Same as nk_window_has_focus for some reason\n * ```c\n * nk_bool nk_window_is_active(struct nk_context *ctx, const char *name);\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct\n * \\param[in] name    | Identifier of window you want to check if it is active\n *\n * \\returns `true(1)` if current window is active or `false(0)` window not found or not active\n */\nNK_API nk_bool nk_window_is_active(const struct nk_context *ctx, const char* name);\n\n/**\n * # # nk_window_is_any_hovered\n * \\returns if the any window is being hovered\n * ```c\n * nk_bool nk_window_is_any_hovered(struct nk_context*);\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct\n *\n * \\returns `true(1)` if any window is hovered or `false(0)` otherwise\n */\nNK_API nk_bool nk_window_is_any_hovered(const struct nk_context *ctx);\n\n/**\n * # # nk_item_is_any_active\n * \\returns if the any window is being hovered or any widget is currently active.\n * Can be used to decide if input should be processed by UI or your specific input handling.\n * Example could be UI and 3D camera to move inside a 3D space.\n * ```c\n * nk_bool nk_item_is_any_active(struct nk_context*);\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct\n *\n * \\returns `true(1)` if any window is hovered or any item is active or `false(0)` otherwise\n\n */\nNK_API nk_bool nk_item_is_any_active(const struct nk_context *ctx);\n\n/**\n * # # nk_window_set_bounds\n * Updates position and size of window with passed in name\n * ```c\n * void nk_window_set_bounds(struct nk_context*, const char *name, struct nk_rect bounds);\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct\n * \\param[in] name    | Identifier of the window to modify both position and size\n * \\param[in] bounds  | Must point to a `nk_rect` struct with the new position and size\n\n */\nNK_API void nk_window_set_bounds(struct nk_context *ctx, const char *name, struct nk_rect bounds);\n\n/**\n * # # nk_window_set_position\n * Updates position of window with passed name\n * ```c\n * void nk_window_set_position(struct nk_context*, const char *name, struct nk_vec2 pos);\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct\n * \\param[in] name    | Identifier of the window to modify both position\n * \\param[in] pos     | Must point to a `nk_vec2` struct with the new position\n\n */\nNK_API void nk_window_set_position(struct nk_context *ctx, const char *name, struct nk_vec2 pos);\n\n/**\n * # # nk_window_set_size\n * Updates size of window with passed in name\n * ```c\n * void nk_window_set_size(struct nk_context*, const char *name, struct nk_vec2);\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct\n * \\param[in] name    | Identifier of the window to modify both window size\n * \\param[in] size    | Must point to a `nk_vec2` struct with new window size\n\n */\nNK_API void nk_window_set_size(struct nk_context *ctx, const char *name, struct nk_vec2 size);\n\n/**\n * # # nk_window_set_focus\n * Sets the window with given name as active\n * ```c\n * void nk_window_set_focus(struct nk_context*, const char *name);\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct\n * \\param[in] name    | Identifier of the window to set focus on\n\n */\nNK_API void nk_window_set_focus(struct nk_context *ctx, const char *name);\n\n/**\n * # # nk_window_set_scroll\n * Sets the scroll offset for the current window\n * !!! \\warning\n *     Only call this function between calls `nk_begin_xxx` and `nk_end`\n *\n * ```c\n * void nk_window_set_scroll(struct nk_context *ctx, nk_uint offset_x, nk_uint offset_y);\n * ```\n *\n * Parameter    | Description\n * -------------|-----------------------------------------------------------\n * \\param[in] ctx      | Must point to an previously initialized `nk_context` struct\n * \\param[in] offset_x | The x offset to scroll to\n * \\param[in] offset_y | The y offset to scroll to\n\n */\nNK_API void nk_window_set_scroll(struct nk_context *ctx, nk_uint offset_x, nk_uint offset_y);\n\n/**\n * # # nk_window_close\n * Closes a window and marks it for being freed at the end of the frame\n * ```c\n * void nk_window_close(struct nk_context *ctx, const char *name);\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct\n * \\param[in] name    | Identifier of the window to close\n\n */\nNK_API void nk_window_close(struct nk_context *ctx, const char *name);\n\n/**\n * # # nk_window_collapse\n * Updates collapse state of a window with given name\n * ```c\n * void nk_window_collapse(struct nk_context*, const char *name, enum nk_collapse_states state);\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct\n * \\param[in] name    | Identifier of the window to close\n * \\param[in] state   | value out of nk_collapse_states section\n\n */\nNK_API void nk_window_collapse(struct nk_context *ctx, const char *name, enum nk_collapse_states state);\n\n/**\n * # # nk_window_collapse_if\n * Updates collapse state of a window with given name if given condition is met\n * ```c\n * void nk_window_collapse_if(struct nk_context*, const char *name, enum nk_collapse_states, int cond);\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct\n * \\param[in] name    | Identifier of the window to either collapse or maximize\n * \\param[in] state   | value out of nk_collapse_states section the window should be put into\n * \\param[in] cond    | condition that has to be met to actually commit the collapse state change\n\n */\nNK_API void nk_window_collapse_if(struct nk_context *ctx, const char *name, enum nk_collapse_states state, int cond);\n\n/**\n * # # nk_window_show\n * updates visibility state of a window with given name\n * ```c\n * void nk_window_show(struct nk_context*, const char *name, enum nk_show_states);\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct\n * \\param[in] name    | Identifier of the window to either collapse or maximize\n * \\param[in] state   | state with either visible or hidden to modify the window with\n */\nNK_API void nk_window_show(struct nk_context *ctx, const char *name, enum nk_show_states state);\n\n/**\n * # # nk_window_show_if\n * Updates visibility state of a window with given name if a given condition is met\n * ```c\n * void nk_window_show_if(struct nk_context*, const char *name, enum nk_show_states, int cond);\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct\n * \\param[in] name    | Identifier of the window to either hide or show\n * \\param[in] state   | state with either visible or hidden to modify the window with\n * \\param[in] cond    | condition that has to be met to actually commit the visibility state change\n\n */\nNK_API void nk_window_show_if(struct nk_context *ctx, const char *name, enum nk_show_states state, int cond);\n\n/**\n * # # nk_window_show_if\n * Line for visual separation. Draws a line with thickness determined by the current row height.\n * ```c\n * void nk_rule_horizontal(struct nk_context *ctx, struct nk_color color, NK_BOOL rounding)\n * ```\n *\n * Parameter       | Description\n * ----------------|-------------------------------------------------------\n * \\param[in] ctx         | Must point to an previously initialized `nk_context` struct\n * \\param[in] color       | Color of the horizontal line\n * \\param[in] rounding    | Whether or not to make the line round\n */\nNK_API void nk_rule_horizontal(struct nk_context *ctx, struct nk_color color, nk_bool rounding);\n\n/* =============================================================================\n *\n *                                  LAYOUT\n *\n * =============================================================================*/\n/**\n * \\page Layouting\n * Layouting in general describes placing widget inside a window with position and size.\n * While in this particular implementation there are five different APIs for layouting\n * each with different trade offs between control and ease of use. <br /><br />\n *\n * All layouting methods in this library are based around the concept of a row.\n * A row has a height the window content grows by and a number of columns and each\n * layouting method specifies how each widget is placed inside the row.\n * After a row has been allocated by calling a layouting functions and then\n * filled with widgets will advance an internal pointer over the allocated row. <br /><br />\n *\n * To actually define a layout you just call the appropriate layouting function\n * and each subsequent widget call will place the widget as specified. Important\n * here is that if you define more widgets then columns defined inside the layout\n * functions it will allocate the next row without you having to make another layouting <br /><br />\n * call.\n *\n * Biggest limitation with using all these APIs outside the `nk_layout_space_xxx` API\n * is that you have to define the row height for each. However the row height\n * often depends on the height of the font. <br /><br />\n *\n * To fix that internally nuklear uses a minimum row height that is set to the\n * height plus padding of currently active font and overwrites the row height\n * value if zero. <br /><br />\n *\n * If you manually want to change the minimum row height then\n * use nk_layout_set_min_row_height, and use nk_layout_reset_min_row_height to\n * reset it back to be derived from font height. <br /><br />\n *\n * Also if you change the font in nuklear it will automatically change the minimum\n * row height for you and. This means if you change the font but still want\n * a minimum row height smaller than the font you have to repush your value. <br /><br />\n *\n * For actually more advanced UI I would even recommend using the `nk_layout_space_xxx`\n * layouting method in combination with a cassowary constraint solver (there are\n * some versions on github with permissive license model) to take over all control over widget\n * layouting yourself. However for quick and dirty layouting using all the other layouting\n * functions should be fine.\n *\n * # Usage\n * 1.  __nk_layout_row_dynamic__<br /><br />\n *     The easiest layouting function is `nk_layout_row_dynamic`. It provides each\n *     widgets with same horizontal space inside the row and dynamically grows\n *     if the owning window grows in width. So the number of columns dictates\n *     the size of each widget dynamically by formula:\n *\n *     ```c\n *     widget_width = (window_width - padding - spacing) * (1/column_count)\n *     ```\n *\n *     Just like all other layouting APIs if you define more widget than columns this\n *     library will allocate a new row and keep all layouting parameters previously\n *     defined.\n *\n *     ```c\n *     if (nk_begin_xxx(...) {\n *         // first row with height: 30 composed of two widgets\n *         nk_layout_row_dynamic(&ctx, 30, 2);\n *         nk_widget(...);\n *         nk_widget(...);\n *         //\n *         // second row with same parameter as defined above\n *         nk_widget(...);\n *         nk_widget(...);\n *         //\n *         // third row uses 0 for height which will use auto layouting\n *         nk_layout_row_dynamic(&ctx, 0, 2);\n *         nk_widget(...);\n *         nk_widget(...);\n *     }\n *     nk_end(...);\n *     ```\n *\n * 2.  __nk_layout_row_static__<br /><br />\n *     Another easy layouting function is `nk_layout_row_static`. It provides each\n *     widget with same horizontal pixel width inside the row and does not grow\n *     if the owning window scales smaller or bigger.\n *\n *     ```c\n *     if (nk_begin_xxx(...) {\n *         // first row with height: 30 composed of two widgets with width: 80\n *         nk_layout_row_static(&ctx, 30, 80, 2);\n *         nk_widget(...);\n *         nk_widget(...);\n *         //\n *         // second row with same parameter as defined above\n *         nk_widget(...);\n *         nk_widget(...);\n *         //\n *         // third row uses 0 for height which will use auto layouting\n *         nk_layout_row_static(&ctx, 0, 80, 2);\n *         nk_widget(...);\n *         nk_widget(...);\n *     }\n *     nk_end(...);\n *     ```\n *\n * 3.  __nk_layout_row_xxx__<br /><br />\n *     A little bit more advanced layouting API are functions `nk_layout_row_begin`,\n *     `nk_layout_row_push` and `nk_layout_row_end`. They allow to directly\n *     specify each column pixel or window ratio in a row. It supports either\n *     directly setting per column pixel width or widget window ratio but not\n *     both. Furthermore it is a immediate mode API so each value is directly\n *     pushed before calling a widget. Therefore the layout is not automatically\n *     repeating like the last two layouting functions.\n *\n *     ```c\n *     if (nk_begin_xxx(...) {\n *         // first row with height: 25 composed of two widgets with width 60 and 40\n *         nk_layout_row_begin(ctx, NK_STATIC, 25, 2);\n *         nk_layout_row_push(ctx, 60);\n *         nk_widget(...);\n *         nk_layout_row_push(ctx, 40);\n *         nk_widget(...);\n *         nk_layout_row_end(ctx);\n *         //\n *         // second row with height: 25 composed of two widgets with window ratio 0.25 and 0.75\n *         nk_layout_row_begin(ctx, NK_DYNAMIC, 25, 2);\n *         nk_layout_row_push(ctx, 0.25f);\n *         nk_widget(...);\n *         nk_layout_row_push(ctx, 0.75f);\n *         nk_widget(...);\n *         nk_layout_row_end(ctx);\n *         //\n *         // third row with auto generated height: composed of two widgets with window ratio 0.25 and 0.75\n *         nk_layout_row_begin(ctx, NK_DYNAMIC, 0, 2);\n *         nk_layout_row_push(ctx, 0.25f);\n *         nk_widget(...);\n *         nk_layout_row_push(ctx, 0.75f);\n *         nk_widget(...);\n *         nk_layout_row_end(ctx);\n *     }\n *     nk_end(...);\n *     ```\n *\n * 4.  __nk_layout_row__<br /><br />\n *     The array counterpart to API nk_layout_row_xxx is the single nk_layout_row\n *     functions. Instead of pushing either pixel or window ratio for every widget\n *     it allows to define it by array. The trade of for less control is that\n *     `nk_layout_row` is automatically repeating. Otherwise the behavior is the\n *     same.\n *\n *     ```c\n *     if (nk_begin_xxx(...) {\n *         // two rows with height: 30 composed of two widgets with width 60 and 40\n *         const float ratio[] = {60,40};\n *         nk_layout_row(ctx, NK_STATIC, 30, 2, ratio);\n *         nk_widget(...);\n *         nk_widget(...);\n *         nk_widget(...);\n *         nk_widget(...);\n *         //\n *         // two rows with height: 30 composed of two widgets with window ratio 0.25 and 0.75\n *         const float ratio[] = {0.25, 0.75};\n *         nk_layout_row(ctx, NK_DYNAMIC, 30, 2, ratio);\n *         nk_widget(...);\n *         nk_widget(...);\n *         nk_widget(...);\n *         nk_widget(...);\n *         //\n *         // two rows with auto generated height composed of two widgets with window ratio 0.25 and 0.75\n *         const float ratio[] = {0.25, 0.75};\n *         nk_layout_row(ctx, NK_DYNAMIC, 30, 2, ratio);\n *         nk_widget(...);\n *         nk_widget(...);\n *         nk_widget(...);\n *         nk_widget(...);\n *     }\n *     nk_end(...);\n *     ```\n *\n * 5.  __nk_layout_row_template_xxx__<br /><br />\n *     The most complex and second most flexible API is a simplified flexbox version without\n *     line wrapping and weights for dynamic widgets. It is an immediate mode API but\n *     unlike `nk_layout_row_xxx` it has auto repeat behavior and needs to be called\n *     before calling the templated widgets.\n *     The row template layout has three different per widget size specifier. The first\n *     one is the `nk_layout_row_template_push_static`  with fixed widget pixel width.\n *     They do not grow if the row grows and will always stay the same.\n *     The second size specifier is `nk_layout_row_template_push_variable`\n *     which defines a minimum widget size but it also can grow if more space is available\n *     not taken by other widgets.\n *     Finally there are dynamic widgets with `nk_layout_row_template_push_dynamic`\n *     which are completely flexible and unlike variable widgets can even shrink\n *     to zero if not enough space is provided.\n *\n *     ```c\n *     if (nk_begin_xxx(...) {\n *         // two rows with height: 30 composed of three widgets\n *         nk_layout_row_template_begin(ctx, 30);\n *         nk_layout_row_template_push_dynamic(ctx);\n *         nk_layout_row_template_push_variable(ctx, 80);\n *         nk_layout_row_template_push_static(ctx, 80);\n *         nk_layout_row_template_end(ctx);\n *         //\n *         // first row\n *         nk_widget(...); // dynamic widget can go to zero if not enough space\n *         nk_widget(...); // variable widget with min 80 pixel but can grow bigger if enough space\n *         nk_widget(...); // static widget with fixed 80 pixel width\n *         //\n *         // second row same layout\n *         nk_widget(...);\n *         nk_widget(...);\n *         nk_widget(...);\n *     }\n *     nk_end(...);\n *     ```\n *\n * 6.  __nk_layout_space_xxx__<br /><br />\n *     Finally the most flexible API directly allows you to place widgets inside the\n *     window. The space layout API is an immediate mode API which does not support\n *     row auto repeat and directly sets position and size of a widget. Position\n *     and size hereby can be either specified as ratio of allocated space or\n *     allocated space local position and pixel size. Since this API is quite\n *     powerful there are a number of utility functions to get the available space\n *     and convert between local allocated space and screen space.\n *\n *     ```c\n *     if (nk_begin_xxx(...) {\n *         // static row with height: 500 (you can set column count to INT_MAX if you don't want to be bothered)\n *         nk_layout_space_begin(ctx, NK_STATIC, 500, INT_MAX);\n *         nk_layout_space_push(ctx, nk_rect(0,0,150,200));\n *         nk_widget(...);\n *         nk_layout_space_push(ctx, nk_rect(200,200,100,200));\n *         nk_widget(...);\n *         nk_layout_space_end(ctx);\n *         //\n *         // dynamic row with height: 500 (you can set column count to INT_MAX if you don't want to be bothered)\n *         nk_layout_space_begin(ctx, NK_DYNAMIC, 500, INT_MAX);\n *         nk_layout_space_push(ctx, nk_rect(0.5,0.5,0.1,0.1));\n *         nk_widget(...);\n *         nk_layout_space_push(ctx, nk_rect(0.7,0.6,0.1,0.1));\n *         nk_widget(...);\n *     }\n *     nk_end(...);\n *     ```\n *\n * # Reference\n * Function                                     | Description\n * ---------------------------------------------|------------------------------------\n * \\ref nk_layout_set_min_row_height            | Set the currently used minimum row height to a specified value\n * \\ref nk_layout_reset_min_row_height          | Resets the currently used minimum row height to font height\n * \\ref nk_layout_widget_bounds                 | Calculates current width a static layout row can fit inside a window\n * \\ref nk_layout_ratio_from_pixel              | Utility functions to calculate window ratio from pixel size\n * \\ref nk_layout_row_dynamic                   | Current layout is divided into n same sized growing columns\n * \\ref nk_layout_row_static                    | Current layout is divided into n same fixed sized columns\n * \\ref nk_layout_row_begin                     | Starts a new row with given height and number of columns\n * \\ref nk_layout_row_push                      | Pushes another column with given size or window ratio\n * \\ref nk_layout_row_end                       | Finished previously started row\n * \\ref nk_layout_row                           | Specifies row columns in array as either window ratio or size\n * \\ref nk_layout_row_template_begin            | Begins the row template declaration\n * \\ref nk_layout_row_template_push_dynamic     | Adds a dynamic column that dynamically grows and can go to zero if not enough space\n * \\ref nk_layout_row_template_push_variable    | Adds a variable column that dynamically grows but does not shrink below specified pixel width\n * \\ref nk_layout_row_template_push_static      | Adds a static column that does not grow and will always have the same size\n * \\ref nk_layout_row_template_end              | Marks the end of the row template\n * \\ref nk_layout_space_begin                   | Begins a new layouting space that allows to specify each widgets position and size\n * \\ref nk_layout_space_push                    | Pushes position and size of the next widget in own coordinate space either as pixel or ratio\n * \\ref nk_layout_space_end                     | Marks the end of the layouting space\n * \\ref nk_layout_space_bounds                  | Callable after nk_layout_space_begin and returns total space allocated\n * \\ref nk_layout_space_to_screen               | Converts vector from nk_layout_space coordinate space into screen space\n * \\ref nk_layout_space_to_local                | Converts vector from screen space into nk_layout_space coordinates\n * \\ref nk_layout_space_rect_to_screen          | Converts rectangle from nk_layout_space coordinate space into screen space\n * \\ref nk_layout_space_rect_to_local           | Converts rectangle from screen space into nk_layout_space coordinates\n */\n\n\n\nenum nk_widget_align {\n    NK_WIDGET_ALIGN_LEFT        = 0x01,\n    NK_WIDGET_ALIGN_CENTERED    = 0x02,\n    NK_WIDGET_ALIGN_RIGHT       = 0x04,\n    NK_WIDGET_ALIGN_TOP         = 0x08,\n    NK_WIDGET_ALIGN_MIDDLE      = 0x10,\n    NK_WIDGET_ALIGN_BOTTOM      = 0x20\n};\nenum nk_widget_alignment {\n    NK_WIDGET_LEFT        = NK_WIDGET_ALIGN_MIDDLE|NK_WIDGET_ALIGN_LEFT,\n    NK_WIDGET_CENTERED    = NK_WIDGET_ALIGN_MIDDLE|NK_WIDGET_ALIGN_CENTERED,\n    NK_WIDGET_RIGHT       = NK_WIDGET_ALIGN_MIDDLE|NK_WIDGET_ALIGN_RIGHT\n};\n\n/**\n * Sets the currently used minimum row height.\n * !!! \\warning\n *     The passed height needs to include both your preferred row height\n *     as well as padding. No internal padding is added.\n *\n * ```c\n * void nk_layout_set_min_row_height(struct nk_context*, float height);\n * ```\n *\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`\n * \\param[in] height  | New minimum row height to be used for auto generating the row height\n */\nNK_API void nk_layout_set_min_row_height(struct nk_context*, float height);\n\n/**\n * Reset the currently used minimum row height back to `font_height + text_padding + padding`\n * ```c\n * void nk_layout_reset_min_row_height(struct nk_context*);\n * ```\n *\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`\n */\nNK_API void nk_layout_reset_min_row_height(struct nk_context*);\n\n/**\n * \\brief Returns the width of the next row allocate by one of the layouting functions\n *\n * \\details\n * ```c\n * struct nk_rect nk_layout_widget_bounds(struct nk_context*);\n * ```\n *\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`\n *\n * \\return `nk_rect` with both position and size of the next row\n */\nNK_API struct nk_rect nk_layout_widget_bounds(const struct nk_context *ctx);\n\n/**\n * \\brief Utility functions to calculate window ratio from pixel size\n *\n * \\details\n * ```c\n * float nk_layout_ratio_from_pixel(struct nk_context*, float pixel_width);\n * ```\n *\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`\n * \\param[in] pixel   | Pixel_width to convert to window ratio\n *\n * \\returns `nk_rect` with both position and size of the next row\n */\nNK_API float nk_layout_ratio_from_pixel(const struct nk_context *ctx, float pixel_width);\n\n/**\n * \\brief Sets current row layout to share horizontal space\n * between @cols number of widgets evenly. Once called all subsequent widget\n * calls greater than @cols will allocate a new row with same layout.\n *\n * \\details\n * ```c\n * void nk_layout_row_dynamic(struct nk_context *ctx, float height, int cols);\n * ```\n *\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`\n * \\param[in] height  | Holds height of each widget in row or zero for auto layouting\n * \\param[in] columns | Number of widget inside row\n */\nNK_API void nk_layout_row_dynamic(struct nk_context *ctx, float height, int cols);\n\n/**\n * \\brief Sets current row layout to fill @cols number of widgets\n * in row with same @item_width horizontal size. Once called all subsequent widget\n * calls greater than @cols will allocate a new row with same layout.\n *\n * \\details\n * ```c\n * void nk_layout_row_static(struct nk_context *ctx, float height, int item_width, int cols);\n * ```\n *\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`\n * \\param[in] height  | Holds height of each widget in row or zero for auto layouting\n * \\param[in] width   | Holds pixel width of each widget in the row\n * \\param[in] columns | Number of widget inside row\n */\nNK_API void nk_layout_row_static(struct nk_context *ctx, float height, int item_width, int cols);\n\n/**\n * \\brief Starts a new dynamic or fixed row with given height and columns.\n *\n * \\details\n * ```c\n * void nk_layout_row_begin(struct nk_context *ctx, enum nk_layout_format fmt, float row_height, int cols);\n * ```\n *\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`\n * \\param[in] fmt     | either `NK_DYNAMIC` for window ratio or `NK_STATIC` for fixed size columns\n * \\param[in] height  | holds height of each widget in row or zero for auto layouting\n * \\param[in] columns | Number of widget inside row\n */\nNK_API void nk_layout_row_begin(struct nk_context *ctx, enum nk_layout_format fmt, float row_height, int cols);\n\n/**\n * \\breif Specifies either window ratio or width of a single column\n *\n * \\details\n * ```c\n * void nk_layout_row_push(struct nk_context*, float value);\n * ```\n *\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`\n * \\param[in] value   | either a window ratio or fixed width depending on @fmt in previous `nk_layout_row_begin` call\n */\nNK_API void nk_layout_row_push(struct nk_context*, float value);\n\n/**\n * \\brief Finished previously started row\n *\n * \\details\n * ```c\n * void nk_layout_row_end(struct nk_context*);\n * ```\n *\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`\n */\nNK_API void nk_layout_row_end(struct nk_context*);\n\n/**\n * \\brief Specifies row columns in array as either window ratio or size\n *\n * \\details\n * ```c\n * void nk_layout_row(struct nk_context*, enum nk_layout_format, float height, int cols, const float *ratio);\n * ```\n *\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`\n * \\param[in] fmt     | Either `NK_DYNAMIC` for window ratio or `NK_STATIC` for fixed size columns\n * \\param[in] height  | Holds height of each widget in row or zero for auto layouting\n * \\param[in] columns | Number of widget inside row\n */\nNK_API void nk_layout_row(struct nk_context*, enum nk_layout_format, float height, int cols, const float *ratio);\n\n/**\n * # # nk_layout_row_template_begin\n * Begins the row template declaration\n * ```c\n * void nk_layout_row_template_begin(struct nk_context*, float row_height);\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`\n * \\param[in] height  | Holds height of each widget in row or zero for auto layouting\n */\nNK_API void nk_layout_row_template_begin(struct nk_context*, float row_height);\n\n/**\n * # # nk_layout_row_template_push_dynamic\n * Adds a dynamic column that dynamically grows and can go to zero if not enough space\n * ```c\n * void nk_layout_row_template_push_dynamic(struct nk_context*);\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`\n * \\param[in] height  | Holds height of each widget in row or zero for auto layouting\n */\nNK_API void nk_layout_row_template_push_dynamic(struct nk_context*);\n\n/**\n * # # nk_layout_row_template_push_variable\n * Adds a variable column that dynamically grows but does not shrink below specified pixel width\n * ```c\n * void nk_layout_row_template_push_variable(struct nk_context*, float min_width);\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`\n * \\param[in] width   | Holds the minimum pixel width the next column must always be\n */\nNK_API void nk_layout_row_template_push_variable(struct nk_context*, float min_width);\n\n/**\n * # # nk_layout_row_template_push_static\n * Adds a static column that does not grow and will always have the same size\n * ```c\n * void nk_layout_row_template_push_static(struct nk_context*, float width);\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`\n * \\param[in] width   | Holds the absolute pixel width value the next column must be\n */\nNK_API void nk_layout_row_template_push_static(struct nk_context*, float width);\n\n/**\n * # # nk_layout_row_template_end\n * Marks the end of the row template\n * ```c\n * void nk_layout_row_template_end(struct nk_context*);\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`\n */\nNK_API void nk_layout_row_template_end(struct nk_context*);\n\n/**\n * # # nk_layout_space_begin\n * Begins a new layouting space that allows to specify each widgets position and size.\n * ```c\n * void nk_layout_space_begin(struct nk_context*, enum nk_layout_format, float height, int widget_count);\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`\n * \\param[in] fmt     | Either `NK_DYNAMIC` for window ratio or `NK_STATIC` for fixed size columns\n * \\param[in] height  | Holds height of each widget in row or zero for auto layouting\n * \\param[in] columns | Number of widgets inside row\n */\nNK_API void nk_layout_space_begin(struct nk_context*, enum nk_layout_format, float height, int widget_count);\n\n/**\n * # # nk_layout_space_push\n * Pushes position and size of the next widget in own coordinate space either as pixel or ratio\n * ```c\n * void nk_layout_space_push(struct nk_context *ctx, struct nk_rect bounds);\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct after call `nk_layout_space_begin`\n * \\param[in] bounds  | Position and size in laoyut space local coordinates\n */\nNK_API void nk_layout_space_push(struct nk_context*, struct nk_rect bounds);\n\n/**\n * # # nk_layout_space_end\n * Marks the end of the layout space\n * ```c\n * void nk_layout_space_end(struct nk_context*);\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct after call `nk_layout_space_begin`\n */\nNK_API void nk_layout_space_end(struct nk_context*);\n\n/**\n * # # nk_layout_space_bounds\n * Utility function to calculate total space allocated for `nk_layout_space`\n * ```c\n * struct nk_rect nk_layout_space_bounds(struct nk_context*);\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct after call `nk_layout_space_begin`\n *\n * \\returns `nk_rect` holding the total space allocated\n */\nNK_API struct nk_rect nk_layout_space_bounds(const struct nk_context *ctx);\n\n/**\n * # # nk_layout_space_to_screen\n * Converts vector from nk_layout_space coordinate space into screen space\n * ```c\n * struct nk_vec2 nk_layout_space_to_screen(struct nk_context*, struct nk_vec2);\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct after call `nk_layout_space_begin`\n * \\param[in] vec     | Position to convert from layout space into screen coordinate space\n *\n * \\returns transformed `nk_vec2` in screen space coordinates\n */\nNK_API struct nk_vec2 nk_layout_space_to_screen(const struct nk_context* ctx, struct nk_vec2 vec);\n\n/**\n * # # nk_layout_space_to_local\n * Converts vector from layout space into screen space\n * ```c\n * struct nk_vec2 nk_layout_space_to_local(struct nk_context*, struct nk_vec2);\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct after call `nk_layout_space_begin`\n * \\param[in] vec     | Position to convert from screen space into layout coordinate space\n *\n * \\returns transformed `nk_vec2` in layout space coordinates\n */\nNK_API struct nk_vec2 nk_layout_space_to_local(const struct nk_context *ctx, struct nk_vec2 vec);\n\n/**\n * # # nk_layout_space_rect_to_screen\n * Converts rectangle from screen space into layout space\n * ```c\n * struct nk_rect nk_layout_space_rect_to_screen(struct nk_context*, struct nk_rect);\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct after call `nk_layout_space_begin`\n * \\param[in] bounds  | Rectangle to convert from layout space into screen space\n *\n * \\returns transformed `nk_rect` in screen space coordinates\n */\nNK_API struct nk_rect nk_layout_space_rect_to_screen(const struct nk_context *ctx, struct nk_rect bounds);\n\n/**\n * # # nk_layout_space_rect_to_local\n * Converts rectangle from layout space into screen space\n * ```c\n * struct nk_rect nk_layout_space_rect_to_local(struct nk_context*, struct nk_rect);\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct after call `nk_layout_space_begin`\n * \\param[in] bounds  | Rectangle to convert from layout space into screen space\n *\n * \\returns transformed `nk_rect` in layout space coordinates\n */\nNK_API struct nk_rect nk_layout_space_rect_to_local(const struct nk_context *ctx, struct nk_rect bounds);\n\n/**\n * # # nk_spacer\n * Spacer is a dummy widget that consumes space as usual but doesn't draw anything\n * ```c\n * void nk_spacer(struct nk_context* );\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct after call `nk_layout_space_begin`\n *\n */\nNK_API void nk_spacer(struct nk_context *ctx);\n\n\n/** =============================================================================\n *\n *                                  GROUP\n *\n * =============================================================================*/\n/**\n * \\page Groups\n * Groups are basically windows inside windows. They allow to subdivide space\n * in a window to layout widgets as a group. Almost all more complex widget\n * layouting requirements can be solved using groups and basic layouting\n * fuctionality. Groups just like windows are identified by an unique name and\n * internally keep track of scrollbar offsets by default. However additional\n * versions are provided to directly manage the scrollbar.\n *\n * # Usage\n * To create a group you have to call one of the three `nk_group_begin_xxx`\n * functions to start group declarations and `nk_group_end` at the end. Furthermore it\n * is required to check the return value of `nk_group_begin_xxx` and only process\n * widgets inside the window if the value is not 0.\n * Nesting groups is possible and even encouraged since many layouting schemes\n * can only be achieved by nesting. Groups, unlike windows, need `nk_group_end`\n * to be only called if the corresponding `nk_group_begin_xxx` call does not return 0:\n *\n * ```c\n * if (nk_group_begin_xxx(ctx, ...) {\n *     // [... widgets ...]\n *     nk_group_end(ctx);\n * }\n * ```\n *\n * In the grand concept groups can be called after starting a window\n * with `nk_begin_xxx` and before calling `nk_end`:\n *\n * ```c\n * struct nk_context ctx;\n * nk_init_xxx(&ctx, ...);\n * while (1) {\n *     // Input\n *     Event evt;\n *     nk_input_begin(&ctx);\n *     while (GetEvent(&evt)) {\n *         if (evt.type == MOUSE_MOVE)\n *             nk_input_motion(&ctx, evt.motion.x, evt.motion.y);\n *         else if (evt.type == [...]) {\n *             nk_input_xxx(...);\n *         }\n *     }\n *     nk_input_end(&ctx);\n *     //\n *     // Window\n *     if (nk_begin_xxx(...) {\n *         // [...widgets...]\n *         nk_layout_row_dynamic(...);\n *         if (nk_group_begin_xxx(ctx, ...) {\n *             //[... widgets ...]\n *             nk_group_end(ctx);\n *         }\n *     }\n *     nk_end(ctx);\n *     //\n *     // Draw\n *     const struct nk_command *cmd = 0;\n *     nk_foreach(cmd, &ctx) {\n *     switch (cmd->type) {\n *     case NK_COMMAND_LINE:\n *         your_draw_line_function(...)\n *         break;\n *     case NK_COMMAND_RECT\n *         your_draw_rect_function(...)\n *         break;\n *     case ...:\n *         // [...]\n *     }\n *     nk_clear(&ctx);\n * }\n * nk_free(&ctx);\n * ```\n * # Reference\n * Function                        | Description\n * --------------------------------|-------------------------------------------\n * \\ref nk_group_begin                  | Start a new group with internal scrollbar handling\n * \\ref nk_group_begin_titled           | Start a new group with separated name and title and internal scrollbar handling\n * \\ref nk_group_end                    | Ends a group. Should only be called if nk_group_begin returned non-zero\n * \\ref nk_group_scrolled_offset_begin  | Start a new group with manual separated handling of scrollbar x- and y-offset\n * \\ref nk_group_scrolled_begin         | Start a new group with manual scrollbar handling\n * \\ref nk_group_scrolled_end           | Ends a group with manual scrollbar handling. Should only be called if nk_group_begin returned non-zero\n * \\ref nk_group_get_scroll             | Gets the scroll offset for the given group\n * \\ref nk_group_set_scroll             | Sets the scroll offset for the given group\n */\n\n /**\n * \\brief Starts a new widget group. Requires a previous layouting function to specify a pos/size.\n * ```c\n * nk_bool nk_group_begin(struct nk_context*, const char *title, nk_flags);\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct\n * \\param[in] title   | Must be an unique identifier for this group that is also used for the group header\n * \\param[in] flags   | Window flags defined in the nk_panel_flags section with a number of different group behaviors\n *\n * \\returns `true(1)` if visible and fillable with widgets or `false(0)` otherwise\n */\nNK_API nk_bool nk_group_begin(struct nk_context*, const char *title, nk_flags);\n\n /**\n * \\brief Starts a new widget group. Requires a previous layouting function to specify a pos/size.\n * ```c\n * nk_bool nk_group_begin_titled(struct nk_context*, const char *name, const char *title, nk_flags);\n * ```\n *\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct\n * \\param[in] id      | Must be an unique identifier for this group\n * \\param[in] title   | Group header title\n * \\param[in] flags   | Window flags defined in the nk_panel_flags section with a number of different group behaviors\n *\n * \\returns `true(1)` if visible and fillable with widgets or `false(0)` otherwise\n */\nNK_API nk_bool nk_group_begin_titled(struct nk_context*, const char *name, const char *title, nk_flags);\n\n/**\n * # # nk_group_end\n * Ends a widget group\n * ```c\n * void nk_group_end(struct nk_context*);\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct\n */\nNK_API void nk_group_end(struct nk_context*);\n\n/**\n * # # nk_group_scrolled_offset_begin\n * starts a new widget group. requires a previous layouting function to specify\n * a size. Does not keep track of scrollbar.\n * ```c\n * nk_bool nk_group_scrolled_offset_begin(struct nk_context*, nk_uint *x_offset, nk_uint *y_offset, const char *title, nk_flags flags);\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct\n * \\param[in] x_offset| Scrollbar x-offset to offset all widgets inside the group horizontally.\n * \\param[in] y_offset| Scrollbar y-offset to offset all widgets inside the group vertically\n * \\param[in] title   | Window unique group title used to both identify and display in the group header\n * \\param[in] flags   | Window flags from the nk_panel_flags section\n *\n * \\returns `true(1)` if visible and fillable with widgets or `false(0)` otherwise\n */\nNK_API nk_bool nk_group_scrolled_offset_begin(struct nk_context*, nk_uint *x_offset, nk_uint *y_offset, const char *title, nk_flags flags);\n\n/**\n * # # nk_group_scrolled_begin\n * Starts a new widget group. requires a previous\n * layouting function to specify a size. Does not keep track of scrollbar.\n * ```c\n * nk_bool nk_group_scrolled_begin(struct nk_context*, struct nk_scroll *off, const char *title, nk_flags);\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct\n * \\param[in] off     | Both x- and y- scroll offset. Allows for manual scrollbar control\n * \\param[in] title   | Window unique group title used to both identify and display in the group header\n * \\param[in] flags   | Window flags from nk_panel_flags section\n *\n * \\returns `true(1)` if visible and fillable with widgets or `false(0)` otherwise\n */\nNK_API nk_bool nk_group_scrolled_begin(struct nk_context*, struct nk_scroll *off, const char *title, nk_flags);\n\n/**\n * # # nk_group_scrolled_end\n * Ends a widget group after calling nk_group_scrolled_offset_begin or nk_group_scrolled_begin.\n * ```c\n * void nk_group_scrolled_end(struct nk_context*);\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct\n */\nNK_API void nk_group_scrolled_end(struct nk_context*);\n\n/**\n * # # nk_group_get_scroll\n * Gets the scroll position of the given group.\n * ```c\n * void nk_group_get_scroll(struct nk_context*, const char *id, nk_uint *x_offset, nk_uint *y_offset);\n * ```\n *\n * Parameter    | Description\n * -------------|-----------------------------------------------------------\n * \\param[in] ctx      | Must point to an previously initialized `nk_context` struct\n * \\param[in] id       | The id of the group to get the scroll position of\n * \\param[in] x_offset | A pointer to the x offset output (or NULL to ignore)\n * \\param[in] y_offset | A pointer to the y offset output (or NULL to ignore)\n */\nNK_API void nk_group_get_scroll(struct nk_context*, const char *id, nk_uint *x_offset, nk_uint *y_offset);\n\n/**\n * # # nk_group_set_scroll\n * Sets the scroll position of the given group.\n * ```c\n * void nk_group_set_scroll(struct nk_context*, const char *id, nk_uint x_offset, nk_uint y_offset);\n * ```\n *\n * Parameter    | Description\n * -------------|-----------------------------------------------------------\n * \\param[in] ctx      | Must point to an previously initialized `nk_context` struct\n * \\param[in] id       | The id of the group to scroll\n * \\param[in] x_offset | The x offset to scroll to\n * \\param[in] y_offset | The y offset to scroll to\n */\nNK_API void nk_group_set_scroll(struct nk_context*, const char *id, nk_uint x_offset, nk_uint y_offset);\n\n/** =============================================================================\n *\n *                                  TREE\n *\n * =============================================================================*/\n/**\n * \\page Tree\n * Trees represent two different concept. First the concept of a collapsible\n * UI section that can be either in a hidden or visible state. They allow the UI\n * user to selectively minimize the current set of visible UI to comprehend.\n * The second concept are tree widgets for visual UI representation of trees.<br /><br />\n *\n * Trees thereby can be nested for tree representations and multiple nested\n * collapsible UI sections. All trees are started by calling of the\n * `nk_tree_xxx_push_tree` functions and ended by calling one of the\n * `nk_tree_xxx_pop_xxx()` functions. Each starting functions takes a title label\n * and optionally an image to be displayed and the initial collapse state from\n * the nk_collapse_states section.<br /><br />\n *\n * The runtime state of the tree is either stored outside the library by the caller\n * or inside which requires a unique ID. The unique ID can either be generated\n * automatically from `__FILE__` and `__LINE__` with function `nk_tree_push`,\n * by `__FILE__` and a user provided ID generated for example by loop index with\n * function `nk_tree_push_id` or completely provided from outside by user with\n * function `nk_tree_push_hashed`.\n *\n * # Usage\n * To create a tree you have to call one of the seven `nk_tree_xxx_push_xxx`\n * functions to start a collapsible UI section and `nk_tree_xxx_pop` to mark the\n * end.\n * Each starting function will either return `false(0)` if the tree is collapsed\n * or hidden and therefore does not need to be filled with content or `true(1)`\n * if visible and required to be filled.\n *\n * !!! Note\n *     The tree header does not require and layouting function and instead\n *     calculates a auto height based on the currently used font size\n *\n * The tree ending functions only need to be called if the tree content is\n * actually visible. So make sure the tree push function is guarded by `if`\n * and the pop call is only taken if the tree is visible.\n *\n * ```c\n * if (nk_tree_push(ctx, NK_TREE_TAB, \"Tree\", NK_MINIMIZED)) {\n *     nk_layout_row_dynamic(...);\n *     nk_widget(...);\n *     nk_tree_pop(ctx);\n * }\n * ```\n *\n * # Reference\n * Function                    | Description\n * ----------------------------|-------------------------------------------\n * nk_tree_push                | Start a collapsible UI section with internal state management\n * nk_tree_push_id             | Start a collapsible UI section with internal state management callable in a look\n * nk_tree_push_hashed         | Start a collapsible UI section with internal state management with full control over internal unique ID use to store state\n * nk_tree_image_push          | Start a collapsible UI section with image and label header\n * nk_tree_image_push_id       | Start a collapsible UI section with image and label header and internal state management callable in a look\n * nk_tree_image_push_hashed   | Start a collapsible UI section with image and label header and internal state management with full control over internal unique ID use to store state\n * nk_tree_pop                 | Ends a collapsible UI section\n * nk_tree_state_push          | Start a collapsible UI section with external state management\n * nk_tree_state_image_push    | Start a collapsible UI section with image and label header and external state management\n * nk_tree_state_pop           | Ends a collapsabale UI section\n *\n * # nk_tree_type\n * Flag            | Description\n * ----------------|----------------------------------------\n * NK_TREE_NODE    | Highlighted tree header to mark a collapsible UI section\n * NK_TREE_TAB     | Non-highlighted tree header closer to tree representations\n */\n\n/**\n * # # nk_tree_push\n * Starts a collapsible UI section with internal state management\n * !!! \\warning\n *     To keep track of the runtime tree collapsible state this function uses\n *     defines `__FILE__` and `__LINE__` to generate a unique ID. If you want\n *     to call this function in a loop please use `nk_tree_push_id` or\n *     `nk_tree_push_hashed` instead.\n *\n * ```c\n * #define nk_tree_push(ctx, type, title, state)\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct\n * \\param[in] type    | Value from the nk_tree_type section to visually mark a tree node header as either a collapseable UI section or tree node\n * \\param[in] title   | Label printed in the tree header\n * \\param[in] state   | Initial tree state value out of nk_collapse_states\n *\n * \\returns `true(1)` if visible and fillable with widgets or `false(0)` otherwise\n */\n#define nk_tree_push(ctx, type, title, state) nk_tree_push_hashed(ctx, type, title, state, NK_FILE_LINE,nk_strlen(NK_FILE_LINE),__LINE__)\n\n/**\n * # # nk_tree_push_id\n * Starts a collapsible UI section with internal state management callable in a look\n * ```c\n * #define nk_tree_push_id(ctx, type, title, state, id)\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct\n * \\param[in] type    | Value from the nk_tree_type section to visually mark a tree node header as either a collapseable UI section or tree node\n * \\param[in] title   | Label printed in the tree header\n * \\param[in] state   | Initial tree state value out of nk_collapse_states\n * \\param[in] id      | Loop counter index if this function is called in a loop\n *\n * \\returns `true(1)` if visible and fillable with widgets or `false(0)` otherwise\n */\n#define nk_tree_push_id(ctx, type, title, state, id) nk_tree_push_hashed(ctx, type, title, state, NK_FILE_LINE,nk_strlen(NK_FILE_LINE),id)\n\n/**\n * # # nk_tree_push_hashed\n * Start a collapsible UI section with internal state management with full\n * control over internal unique ID used to store state\n * ```c\n * nk_bool nk_tree_push_hashed(struct nk_context*, enum nk_tree_type, const char *title, enum nk_collapse_states initial_state, const char *hash, int len,int seed);\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct\n * \\param[in] type    | Value from the nk_tree_type section to visually mark a tree node header as either a collapseable UI section or tree node\n * \\param[in] title   | Label printed in the tree header\n * \\param[in] state   | Initial tree state value out of nk_collapse_states\n * \\param[in] hash    | Memory block or string to generate the ID from\n * \\param[in] len     | Size of passed memory block or string in __hash__\n * \\param[in] seed    | Seeding value if this function is called in a loop or default to `0`\n *\n * \\returns `true(1)` if visible and fillable with widgets or `false(0)` otherwise\n */\nNK_API nk_bool nk_tree_push_hashed(struct nk_context*, enum nk_tree_type, const char *title, enum nk_collapse_states initial_state, const char *hash, int len,int seed);\n\n/**\n * # # nk_tree_image_push\n * Start a collapsible UI section with image and label header\n * !!! \\warning\n *     To keep track of the runtime tree collapsible state this function uses\n *     defines `__FILE__` and `__LINE__` to generate a unique ID. If you want\n *     to call this function in a loop please use `nk_tree_image_push_id` or\n *     `nk_tree_image_push_hashed` instead.\n *\n * ```c\n * #define nk_tree_image_push(ctx, type, img, title, state)\n * ```\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct\n * \\param[in] type    | Value from the nk_tree_type section to visually mark a tree node header as either a collapseable UI section or tree node\n * \\param[in] img     | Image to display inside the header on the left of the label\n * \\param[in] title   | Label printed in the tree header\n * \\param[in] state   | Initial tree state value out of nk_collapse_states\n *\n * \\returns `true(1)` if visible and fillable with widgets or `false(0)` otherwise\n */\n#define nk_tree_image_push(ctx, type, img, title, state) nk_tree_image_push_hashed(ctx, type, img, title, state, NK_FILE_LINE,nk_strlen(NK_FILE_LINE),__LINE__)\n\n/**\n * # # nk_tree_image_push_id\n * Start a collapsible UI section with image and label header and internal state\n * management callable in a look\n *\n * ```c\n * #define nk_tree_image_push_id(ctx, type, img, title, state, id)\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct\n * \\param[in] type    | Value from the nk_tree_type section to visually mark a tree node header as either a collapseable UI section or tree node\n * \\param[in] img     | Image to display inside the header on the left of the label\n * \\param[in] title   | Label printed in the tree header\n * \\param[in] state   | Initial tree state value out of nk_collapse_states\n * \\param[in] id      | Loop counter index if this function is called in a loop\n *\n * \\returns `true(1)` if visible and fillable with widgets or `false(0)` otherwise\n */\n#define nk_tree_image_push_id(ctx, type, img, title, state, id) nk_tree_image_push_hashed(ctx, type, img, title, state, NK_FILE_LINE,nk_strlen(NK_FILE_LINE),id)\n\n/**\n * # # nk_tree_image_push_hashed\n * Start a collapsible UI section with internal state management with full\n * control over internal unique ID used to store state\n * ```c\n * nk_bool nk_tree_image_push_hashed(struct nk_context*, enum nk_tree_type, struct nk_image, const char *title, enum nk_collapse_states initial_state, const char *hash, int len,int seed);\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct\n * \\param[in] type    | Value from the nk_tree_type section to visually mark a tree node header as either a collapseable UI section or tree node\n * \\param[in] img     | Image to display inside the header on the left of the label\n * \\param[in] title   | Label printed in the tree header\n * \\param[in] state   | Initial tree state value out of nk_collapse_states\n * \\param[in] hash    | Memory block or string to generate the ID from\n * \\param[in] len     | Size of passed memory block or string in __hash__\n * \\param[in] seed    | Seeding value if this function is called in a loop or default to `0`\n *\n * \\returns `true(1)` if visible and fillable with widgets or `false(0)` otherwise\n */\nNK_API nk_bool nk_tree_image_push_hashed(struct nk_context*, enum nk_tree_type, struct nk_image, const char *title, enum nk_collapse_states initial_state, const char *hash, int len,int seed);\n\n/**\n * # # nk_tree_pop\n * Ends a collapsabale UI section\n * ```c\n * void nk_tree_pop(struct nk_context*);\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct after calling `nk_tree_xxx_push_xxx`\n */\nNK_API void nk_tree_pop(struct nk_context*);\n\n/**\n * # # nk_tree_state_push\n * Start a collapsible UI section with external state management\n * ```c\n * nk_bool nk_tree_state_push(struct nk_context*, enum nk_tree_type, const char *title, enum nk_collapse_states *state);\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct after calling `nk_tree_xxx_push_xxx`\n * \\param[in] type    | Value from the nk_tree_type section to visually mark a tree node header as either a collapseable UI section or tree node\n * \\param[in] title   | Label printed in the tree header\n * \\param[in] state   | Persistent state to update\n *\n * \\returns `true(1)` if visible and fillable with widgets or `false(0)` otherwise\n */\nNK_API nk_bool nk_tree_state_push(struct nk_context*, enum nk_tree_type, const char *title, enum nk_collapse_states *state);\n\n/**\n * # # nk_tree_state_image_push\n * Start a collapsible UI section with image and label header and external state management\n * ```c\n * nk_bool nk_tree_state_image_push(struct nk_context*, enum nk_tree_type, struct nk_image, const char *title, enum nk_collapse_states *state);\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct after calling `nk_tree_xxx_push_xxx`\n * \\param[in] img     | Image to display inside the header on the left of the label\n * \\param[in] type    | Value from the nk_tree_type section to visually mark a tree node header as either a collapseable UI section or tree node\n * \\param[in] title   | Label printed in the tree header\n * \\param[in] state   | Persistent state to update\n *\n * \\returns `true(1)` if visible and fillable with widgets or `false(0)` otherwise\n */\nNK_API nk_bool nk_tree_state_image_push(struct nk_context*, enum nk_tree_type, struct nk_image, const char *title, enum nk_collapse_states *state);\n\n/**\n * # # nk_tree_state_pop\n * Ends a collapsabale UI section\n * ```c\n * void nk_tree_state_pop(struct nk_context*);\n * ```\n *\n * Parameter   | Description\n * ------------|-----------------------------------------------------------\n * \\param[in] ctx     | Must point to an previously initialized `nk_context` struct after calling `nk_tree_xxx_push_xxx`\n */\nNK_API void nk_tree_state_pop(struct nk_context*);\n\n#define nk_tree_element_push(ctx, type, title, state, sel) nk_tree_element_push_hashed(ctx, type, title, state, sel, NK_FILE_LINE,nk_strlen(NK_FILE_LINE),__LINE__)\n#define nk_tree_element_push_id(ctx, type, title, state, sel, id) nk_tree_element_push_hashed(ctx, type, title, state, sel, NK_FILE_LINE,nk_strlen(NK_FILE_LINE),id)\nNK_API nk_bool nk_tree_element_push_hashed(struct nk_context*, enum nk_tree_type, const char *title, enum nk_collapse_states initial_state, nk_bool *selected, const char *hash, int len, int seed);\nNK_API nk_bool nk_tree_element_image_push_hashed(struct nk_context*, enum nk_tree_type, struct nk_image, const char *title, enum nk_collapse_states initial_state, nk_bool *selected, const char *hash, int len,int seed);\nNK_API void nk_tree_element_pop(struct nk_context*);\n\n/* =============================================================================\n *\n *                                  LIST VIEW\n *\n * ============================================================================= */\nstruct nk_list_view {\n/* public: */\n    int begin, end, count;\n/* private: */\n    int total_height;\n    struct nk_context *ctx;\n    nk_uint *scroll_pointer;\n    nk_uint scroll_value;\n};\nNK_API nk_bool nk_list_view_begin(struct nk_context*, struct nk_list_view *out, const char *id, nk_flags, int row_height, int row_count);\nNK_API void nk_list_view_end(struct nk_list_view*);\n/* =============================================================================\n *\n *                                  WIDGET\n *\n * ============================================================================= */\nenum nk_widget_layout_states {\n    NK_WIDGET_INVALID, /**< The widget cannot be seen and is completely out of view */\n    NK_WIDGET_VALID,   /**< The widget is completely inside the window and can be updated and drawn */\n    NK_WIDGET_ROM,     /**< The widget is partially visible and cannot be updated */\n    NK_WIDGET_DISABLED /**< The widget is manually disabled and acts like NK_WIDGET_ROM */\n};\nenum nk_widget_states {\n    NK_WIDGET_STATE_MODIFIED    = NK_FLAG(1),\n    NK_WIDGET_STATE_INACTIVE    = NK_FLAG(2), /**!< widget is neither active nor hovered */\n    NK_WIDGET_STATE_ENTERED     = NK_FLAG(3), /**!< widget has been hovered on the current frame */\n    NK_WIDGET_STATE_HOVER       = NK_FLAG(4), /**!< widget is being hovered */\n    NK_WIDGET_STATE_ACTIVED     = NK_FLAG(5),/**!< widget is currently activated */\n    NK_WIDGET_STATE_LEFT        = NK_FLAG(6), /**!< widget is from this frame on not hovered anymore */\n    NK_WIDGET_STATE_HOVERED     = NK_WIDGET_STATE_HOVER|NK_WIDGET_STATE_MODIFIED, /**!< widget is being hovered */\n    NK_WIDGET_STATE_ACTIVE      = NK_WIDGET_STATE_ACTIVED|NK_WIDGET_STATE_MODIFIED /**!< widget is currently activated */\n};\nNK_API enum nk_widget_layout_states nk_widget(struct nk_rect*, const struct nk_context*);\nNK_API enum nk_widget_layout_states nk_widget_fitting(struct nk_rect*, const struct nk_context*, struct nk_vec2);\nNK_API struct nk_rect nk_widget_bounds(const struct nk_context*);\nNK_API struct nk_vec2 nk_widget_position(const struct nk_context*);\nNK_API struct nk_vec2 nk_widget_size(const struct nk_context*);\nNK_API float nk_widget_width(const struct nk_context*);\nNK_API float nk_widget_height(const struct nk_context*);\nNK_API nk_bool nk_widget_is_hovered(const struct nk_context*);\nNK_API nk_bool nk_widget_is_mouse_clicked(const struct nk_context*, enum nk_buttons);\nNK_API nk_bool nk_widget_has_mouse_click_down(const struct nk_context*, enum nk_buttons, nk_bool down);\nNK_API void nk_spacing(struct nk_context*, int cols);\nNK_API void nk_widget_disable_begin(struct nk_context* ctx);\nNK_API void nk_widget_disable_end(struct nk_context* ctx);\n/* =============================================================================\n *\n *                                  TEXT\n *\n * ============================================================================= */\nenum nk_text_align {\n    NK_TEXT_ALIGN_LEFT        = 0x01,\n    NK_TEXT_ALIGN_CENTERED    = 0x02,\n    NK_TEXT_ALIGN_RIGHT       = 0x04,\n    NK_TEXT_ALIGN_TOP         = 0x08,\n    NK_TEXT_ALIGN_MIDDLE      = 0x10,\n    NK_TEXT_ALIGN_BOTTOM      = 0x20\n};\nenum nk_text_alignment {\n    NK_TEXT_LEFT        = NK_TEXT_ALIGN_MIDDLE|NK_TEXT_ALIGN_LEFT,\n    NK_TEXT_CENTERED    = NK_TEXT_ALIGN_MIDDLE|NK_TEXT_ALIGN_CENTERED,\n    NK_TEXT_RIGHT       = NK_TEXT_ALIGN_MIDDLE|NK_TEXT_ALIGN_RIGHT\n};\nNK_API void nk_text(struct nk_context*, const char*, int, nk_flags);\nNK_API void nk_text_colored(struct nk_context*, const char*, int, nk_flags, struct nk_color);\nNK_API void nk_text_wrap(struct nk_context*, const char*, int);\nNK_API void nk_text_wrap_colored(struct nk_context*, const char*, int, struct nk_color);\nNK_API void nk_label(struct nk_context*, const char*, nk_flags align);\nNK_API void nk_label_colored(struct nk_context*, const char*, nk_flags align, struct nk_color);\nNK_API void nk_label_wrap(struct nk_context*, const char*);\nNK_API void nk_label_colored_wrap(struct nk_context*, const char*, struct nk_color);\nNK_API void nk_image(struct nk_context*, struct nk_image);\nNK_API void nk_image_color(struct nk_context*, struct nk_image, struct nk_color);\n#ifdef NK_INCLUDE_STANDARD_VARARGS\nNK_API void nk_labelf(struct nk_context*, nk_flags, NK_PRINTF_FORMAT_STRING const char*, ...) NK_PRINTF_VARARG_FUNC(3);\nNK_API void nk_labelf_colored(struct nk_context*, nk_flags, struct nk_color, NK_PRINTF_FORMAT_STRING const char*,...) NK_PRINTF_VARARG_FUNC(4);\nNK_API void nk_labelf_wrap(struct nk_context*, NK_PRINTF_FORMAT_STRING const char*,...) NK_PRINTF_VARARG_FUNC(2);\nNK_API void nk_labelf_colored_wrap(struct nk_context*, struct nk_color, NK_PRINTF_FORMAT_STRING const char*,...) NK_PRINTF_VARARG_FUNC(3);\nNK_API void nk_labelfv(struct nk_context*, nk_flags, NK_PRINTF_FORMAT_STRING const char*, va_list) NK_PRINTF_VALIST_FUNC(3);\nNK_API void nk_labelfv_colored(struct nk_context*, nk_flags, struct nk_color, NK_PRINTF_FORMAT_STRING const char*, va_list) NK_PRINTF_VALIST_FUNC(4);\nNK_API void nk_labelfv_wrap(struct nk_context*, NK_PRINTF_FORMAT_STRING const char*, va_list) NK_PRINTF_VALIST_FUNC(2);\nNK_API void nk_labelfv_colored_wrap(struct nk_context*, struct nk_color, NK_PRINTF_FORMAT_STRING const char*, va_list) NK_PRINTF_VALIST_FUNC(3);\nNK_API void nk_value_bool(struct nk_context*, const char *prefix, int);\nNK_API void nk_value_int(struct nk_context*, const char *prefix, int);\nNK_API void nk_value_uint(struct nk_context*, const char *prefix, unsigned int);\nNK_API void nk_value_float(struct nk_context*, const char *prefix, float);\nNK_API void nk_value_color_byte(struct nk_context*, const char *prefix, struct nk_color);\nNK_API void nk_value_color_float(struct nk_context*, const char *prefix, struct nk_color);\nNK_API void nk_value_color_hex(struct nk_context*, const char *prefix, struct nk_color);\n#endif\n/* =============================================================================\n *\n *                                  BUTTON\n *\n * ============================================================================= */\nNK_API nk_bool nk_button_text(struct nk_context*, const char *title, int len);\nNK_API nk_bool nk_button_label(struct nk_context*, const char *title);\nNK_API nk_bool nk_button_color(struct nk_context*, struct nk_color);\nNK_API nk_bool nk_button_symbol(struct nk_context*, enum nk_symbol_type);\nNK_API nk_bool nk_button_image(struct nk_context*, struct nk_image img);\nNK_API nk_bool nk_button_symbol_label(struct nk_context*, enum nk_symbol_type, const char*, nk_flags text_alignment);\nNK_API nk_bool nk_button_symbol_text(struct nk_context*, enum nk_symbol_type, const char*, int, nk_flags alignment);\nNK_API nk_bool nk_button_image_label(struct nk_context*, struct nk_image img, const char*, nk_flags text_alignment);\nNK_API nk_bool nk_button_image_text(struct nk_context*, struct nk_image img, const char*, int, nk_flags alignment);\nNK_API nk_bool nk_button_text_styled(struct nk_context*, const struct nk_style_button*, const char *title, int len);\nNK_API nk_bool nk_button_label_styled(struct nk_context*, const struct nk_style_button*, const char *title);\nNK_API nk_bool nk_button_symbol_styled(struct nk_context*, const struct nk_style_button*, enum nk_symbol_type);\nNK_API nk_bool nk_button_image_styled(struct nk_context*, const struct nk_style_button*, struct nk_image img);\nNK_API nk_bool nk_button_symbol_text_styled(struct nk_context*,const struct nk_style_button*, enum nk_symbol_type, const char*, int, nk_flags alignment);\nNK_API nk_bool nk_button_symbol_label_styled(struct nk_context *ctx, const struct nk_style_button *style, enum nk_symbol_type symbol, const char *title, nk_flags align);\nNK_API nk_bool nk_button_image_label_styled(struct nk_context*,const struct nk_style_button*, struct nk_image img, const char*, nk_flags text_alignment);\nNK_API nk_bool nk_button_image_text_styled(struct nk_context*,const struct nk_style_button*, struct nk_image img, const char*, int, nk_flags alignment);\nNK_API void nk_button_set_behavior(struct nk_context*, enum nk_button_behavior);\nNK_API nk_bool nk_button_push_behavior(struct nk_context*, enum nk_button_behavior);\nNK_API nk_bool nk_button_pop_behavior(struct nk_context*);\n/* =============================================================================\n *\n *                                  CHECKBOX\n *\n * ============================================================================= */\nNK_API nk_bool nk_check_label(struct nk_context*, const char*, nk_bool active);\nNK_API nk_bool nk_check_text(struct nk_context*, const char*, int, nk_bool active);\nNK_API nk_bool nk_check_text_align(struct nk_context*, const char*, int, nk_bool active, nk_flags widget_alignment, nk_flags text_alignment);\nNK_API unsigned nk_check_flags_label(struct nk_context*, const char*, unsigned int flags, unsigned int value);\nNK_API unsigned nk_check_flags_text(struct nk_context*, const char*, int, unsigned int flags, unsigned int value);\nNK_API nk_bool nk_checkbox_label(struct nk_context*, const char*, nk_bool *active);\nNK_API nk_bool nk_checkbox_label_align(struct nk_context *ctx, const char *label, nk_bool *active, nk_flags widget_alignment, nk_flags text_alignment);\nNK_API nk_bool nk_checkbox_text(struct nk_context*, const char*, int, nk_bool *active);\nNK_API nk_bool nk_checkbox_text_align(struct nk_context *ctx, const char *text, int len, nk_bool *active, nk_flags widget_alignment, nk_flags text_alignment);\nNK_API nk_bool nk_checkbox_flags_label(struct nk_context*, const char*, unsigned int *flags, unsigned int value);\nNK_API nk_bool nk_checkbox_flags_text(struct nk_context*, const char*, int, unsigned int *flags, unsigned int value);\n/* =============================================================================\n *\n *                                  RADIO BUTTON\n *\n * ============================================================================= */\nNK_API nk_bool nk_radio_label(struct nk_context*, const char*, nk_bool *active);\nNK_API nk_bool nk_radio_label_align(struct nk_context *ctx, const char *label, nk_bool *active, nk_flags widget_alignment, nk_flags text_alignment);\nNK_API nk_bool nk_radio_text(struct nk_context*, const char*, int, nk_bool *active);\nNK_API nk_bool nk_radio_text_align(struct nk_context *ctx, const char *text, int len, nk_bool *active, nk_flags widget_alignment, nk_flags text_alignment);\nNK_API nk_bool nk_option_label(struct nk_context*, const char*, nk_bool active);\nNK_API nk_bool nk_option_label_align(struct nk_context *ctx, const char *label, nk_bool active, nk_flags widget_alignment, nk_flags text_alignment);\nNK_API nk_bool nk_option_text(struct nk_context*, const char*, int, nk_bool active);\nNK_API nk_bool nk_option_text_align(struct nk_context *ctx, const char *text, int len, nk_bool is_active, nk_flags widget_alignment, nk_flags text_alignment);\n/* =============================================================================\n *\n *                                  SELECTABLE\n *\n * ============================================================================= */\nNK_API nk_bool nk_selectable_label(struct nk_context*, const char*, nk_flags align, nk_bool *value);\nNK_API nk_bool nk_selectable_text(struct nk_context*, const char*, int, nk_flags align, nk_bool *value);\nNK_API nk_bool nk_selectable_image_label(struct nk_context*,struct nk_image,  const char*, nk_flags align, nk_bool *value);\nNK_API nk_bool nk_selectable_image_text(struct nk_context*,struct nk_image, const char*, int, nk_flags align, nk_bool *value);\nNK_API nk_bool nk_selectable_symbol_label(struct nk_context*,enum nk_symbol_type,  const char*, nk_flags align, nk_bool *value);\nNK_API nk_bool nk_selectable_symbol_text(struct nk_context*,enum nk_symbol_type, const char*, int, nk_flags align, nk_bool *value);\n\nNK_API nk_bool nk_select_label(struct nk_context*, const char*, nk_flags align, nk_bool value);\nNK_API nk_bool nk_select_text(struct nk_context*, const char*, int, nk_flags align, nk_bool value);\nNK_API nk_bool nk_select_image_label(struct nk_context*, struct nk_image,const char*, nk_flags align, nk_bool value);\nNK_API nk_bool nk_select_image_text(struct nk_context*, struct nk_image,const char*, int, nk_flags align, nk_bool value);\nNK_API nk_bool nk_select_symbol_label(struct nk_context*,enum nk_symbol_type,  const char*, nk_flags align, nk_bool value);\nNK_API nk_bool nk_select_symbol_text(struct nk_context*,enum nk_symbol_type, const char*, int, nk_flags align, nk_bool value);\n\n/* =============================================================================\n *\n *                                  SLIDER\n *\n * ============================================================================= */\nNK_API float nk_slide_float(struct nk_context*, float min, float val, float max, float step);\nNK_API int nk_slide_int(struct nk_context*, int min, int val, int max, int step);\nNK_API nk_bool nk_slider_float(struct nk_context*, float min, float *val, float max, float step);\nNK_API nk_bool nk_slider_int(struct nk_context*, int min, int *val, int max, int step);\n\n/* =============================================================================\n *\n *                                   KNOB\n *\n * ============================================================================= */\nNK_API nk_bool nk_knob_float(struct nk_context*, float min, float *val, float max, float step, enum nk_heading zero_direction, float dead_zone_degrees);\nNK_API nk_bool nk_knob_int(struct nk_context*, int min, int *val, int max, int step, enum nk_heading zero_direction, float dead_zone_degrees);\n\n/* =============================================================================\n *\n *                                  PROGRESSBAR\n *\n * ============================================================================= */\nNK_API nk_bool nk_progress(struct nk_context*, nk_size *cur, nk_size max, nk_bool modifyable);\nNK_API nk_size nk_prog(struct nk_context*, nk_size cur, nk_size max, nk_bool modifyable);\n\n/* =============================================================================\n *\n *                                  COLOR PICKER\n *\n * ============================================================================= */\nNK_API struct nk_colorf nk_color_picker(struct nk_context*, struct nk_colorf, enum nk_color_format);\nNK_API nk_bool nk_color_pick(struct nk_context*, struct nk_colorf*, enum nk_color_format);\n/* =============================================================================\n *\n *                                  PROPERTIES\n *\n * =============================================================================*/\n/**\n * \\page Properties\n * Properties are the main value modification widgets in Nuklear. Changing a value\n * can be achieved by dragging, adding/removing incremental steps on button click\n * or by directly typing a number.\n *\n * # Usage\n * Each property requires a unique name for identification that is also used for\n * displaying a label. If you want to use the same name multiple times make sure\n * add a '#' before your name. The '#' will not be shown but will generate a\n * unique ID. Each property also takes in a minimum and maximum value. If you want\n * to make use of the complete number range of a type just use the provided\n * type limits from `limits.h`. For example `INT_MIN` and `INT_MAX` for\n * `nk_property_int` and `nk_propertyi`. In additional each property takes in\n * a increment value that will be added or subtracted if either the increment\n * decrement button is clicked. Finally there is a value for increment per pixel\n * dragged that is added or subtracted from the value.\n *\n * ```c\n * int value = 0;\n * struct nk_context ctx;\n * nk_init_xxx(&ctx, ...);\n * while (1) {\n *     // Input\n *     Event evt;\n *     nk_input_begin(&ctx);\n *     while (GetEvent(&evt)) {\n *         if (evt.type == MOUSE_MOVE)\n *             nk_input_motion(&ctx, evt.motion.x, evt.motion.y);\n *         else if (evt.type == [...]) {\n *             nk_input_xxx(...);\n *         }\n *     }\n *     nk_input_end(&ctx);\n *     //\n *     // Window\n *     if (nk_begin_xxx(...) {\n *         // Property\n *         nk_layout_row_dynamic(...);\n *         nk_property_int(ctx, \"ID\", INT_MIN, &value, INT_MAX, 1, 1);\n *     }\n *     nk_end(ctx);\n *     //\n *     // Draw\n *     const struct nk_command *cmd = 0;\n *     nk_foreach(cmd, &ctx) {\n *     switch (cmd->type) {\n *     case NK_COMMAND_LINE:\n *         your_draw_line_function(...)\n *         break;\n *     case NK_COMMAND_RECT\n *         your_draw_rect_function(...)\n *         break;\n *     case ...:\n *         // [...]\n *     }\n *     nk_clear(&ctx);\n * }\n * nk_free(&ctx);\n * ```\n *\n * # Reference\n * Function            | Description\n * --------------------|-------------------------------------------\n * \\ref nk_property_int     | Integer property directly modifying a passed in value\n * \\ref nk_property_float   | Float property directly modifying a passed in value\n * \\ref nk_property_double  | Double property directly modifying a passed in value\n * \\ref nk_propertyi        | Integer property returning the modified int value\n * \\ref nk_propertyf        | Float property returning the modified float value\n * \\ref nk_propertyd        | Double property returning the modified double value\n *\n\n * # # nk_property_int\n * Integer property directly modifying a passed in value\n * !!! \\warning\n *     To generate a unique property ID using the same label make sure to insert\n *     a `#` at the beginning. It will not be shown but guarantees correct behavior.\n *\n * ```c\n * void nk_property_int(struct nk_context *ctx, const char *name, int min, int *val, int max, int step, float inc_per_pixel);\n * ```\n *\n * Parameter           | Description\n * --------------------|-----------------------------------------------------------\n * \\param[in] ctx             | Must point to an previously initialized `nk_context` struct after calling a layouting function\n * \\param[in] name            | String used both as a label as well as a unique identifier\n * \\param[in] min             | Minimum value not allowed to be underflown\n * \\param[in] val             | Integer pointer to be modified\n * \\param[in] max             | Maximum value not allowed to be overflown\n * \\param[in] step            | Increment added and subtracted on increment and decrement button\n * \\param[in] inc_per_pixel   | Value per pixel added or subtracted on dragging\n */\nNK_API void nk_property_int(struct nk_context*, const char *name, int min, int *val, int max, int step, float inc_per_pixel);\n\n/**\n * # # nk_property_float\n * Float property directly modifying a passed in value\n * !!! \\warning\n *     To generate a unique property ID using the same label make sure to insert\n *     a `#` at the beginning. It will not be shown but guarantees correct behavior.\n *\n * ```c\n * void nk_property_float(struct nk_context *ctx, const char *name, float min, float *val, float max, float step, float inc_per_pixel);\n * ```\n *\n * Parameter           | Description\n * --------------------|-----------------------------------------------------------\n * \\param[in] ctx             | Must point to an previously initialized `nk_context` struct after calling a layouting function\n * \\param[in] name            | String used both as a label as well as a unique identifier\n * \\param[in] min             | Minimum value not allowed to be underflown\n * \\param[in] val             | Float pointer to be modified\n * \\param[in] max             | Maximum value not allowed to be overflown\n * \\param[in] step            | Increment added and subtracted on increment and decrement button\n * \\param[in] inc_per_pixel   | Value per pixel added or subtracted on dragging\n */\nNK_API void nk_property_float(struct nk_context*, const char *name, float min, float *val, float max, float step, float inc_per_pixel);\n\n/**\n * # # nk_property_double\n * Double property directly modifying a passed in value\n * !!! \\warning\n *     To generate a unique property ID using the same label make sure to insert\n *     a `#` at the beginning. It will not be shown but guarantees correct behavior.\n *\n * ```c\n * void nk_property_double(struct nk_context *ctx, const char *name, double min, double *val, double max, double step, double inc_per_pixel);\n * ```\n *\n * Parameter           | Description\n * --------------------|-----------------------------------------------------------\n * \\param[in] ctx             | Must point to an previously initialized `nk_context` struct after calling a layouting function\n * \\param[in] name            | String used both as a label as well as a unique identifier\n * \\param[in] min             | Minimum value not allowed to be underflown\n * \\param[in] val             | Double pointer to be modified\n * \\param[in] max             | Maximum value not allowed to be overflown\n * \\param[in] step            | Increment added and subtracted on increment and decrement button\n * \\param[in] inc_per_pixel   | Value per pixel added or subtracted on dragging\n */\nNK_API void nk_property_double(struct nk_context*, const char *name, double min, double *val, double max, double step, float inc_per_pixel);\n\n/**\n * # # nk_propertyi\n * Integer property modifying a passed in value and returning the new value\n * !!! \\warning\n *     To generate a unique property ID using the same label make sure to insert\n *     a `#` at the beginning. It will not be shown but guarantees correct behavior.\n *\n * ```c\n * int nk_propertyi(struct nk_context *ctx, const char *name, int min, int val, int max, int step, float inc_per_pixel);\n * ```\n *\n * \\param[in] ctx              Must point to an previously initialized `nk_context` struct after calling a layouting function\n * \\param[in] name             String used both as a label as well as a unique identifier\n * \\param[in] min              Minimum value not allowed to be underflown\n * \\param[in] val              Current integer value to be modified and returned\n * \\param[in] max              Maximum value not allowed to be overflown\n * \\param[in] step             Increment added and subtracted on increment and decrement button\n * \\param[in] inc_per_pixel    Value per pixel added or subtracted on dragging\n *\n * \\returns the new modified integer value\n */\nNK_API int nk_propertyi(struct nk_context*, const char *name, int min, int val, int max, int step, float inc_per_pixel);\n\n/**\n * # # nk_propertyf\n * Float property modifying a passed in value and returning the new value\n * !!! \\warning\n *     To generate a unique property ID using the same label make sure to insert\n *     a `#` at the beginning. It will not be shown but guarantees correct behavior.\n *\n * ```c\n * float nk_propertyf(struct nk_context *ctx, const char *name, float min, float val, float max, float step, float inc_per_pixel);\n * ```\n *\n * \\param[in] ctx              Must point to an previously initialized `nk_context` struct after calling a layouting function\n * \\param[in] name             String used both as a label as well as a unique identifier\n * \\param[in] min              Minimum value not allowed to be underflown\n * \\param[in] val              Current float value to be modified and returned\n * \\param[in] max              Maximum value not allowed to be overflown\n * \\param[in] step             Increment added and subtracted on increment and decrement button\n * \\param[in] inc_per_pixel    Value per pixel added or subtracted on dragging\n *\n * \\returns the new modified float value\n */\nNK_API float nk_propertyf(struct nk_context*, const char *name, float min, float val, float max, float step, float inc_per_pixel);\n\n/**\n * # # nk_propertyd\n * Float property modifying a passed in value and returning the new value\n * !!! \\warning\n *     To generate a unique property ID using the same label make sure to insert\n *     a `#` at the beginning. It will not be shown but guarantees correct behavior.\n *\n * ```c\n * float nk_propertyd(struct nk_context *ctx, const char *name, double min, double val, double max, double step, double inc_per_pixel);\n * ```\n *\n * \\param[in] ctx              Must point to an previously initialized `nk_context` struct after calling a layouting function\n * \\param[in] name             String used both as a label as well as a unique identifier\n * \\param[in] min              Minimum value not allowed to be underflown\n * \\param[in] val              Current double value to be modified and returned\n * \\param[in] max              Maximum value not allowed to be overflown\n * \\param[in] step             Increment added and subtracted on increment and decrement button\n * \\param[in] inc_per_pixel    Value per pixel added or subtracted on dragging\n *\n * \\returns the new modified double value\n */\nNK_API double nk_propertyd(struct nk_context*, const char *name, double min, double val, double max, double step, float inc_per_pixel);\n\n/* =============================================================================\n *\n *                                  TEXT EDIT\n *\n * ============================================================================= */\nenum nk_edit_flags {\n    NK_EDIT_DEFAULT                 = 0,\n    NK_EDIT_READ_ONLY               = NK_FLAG(0),\n    NK_EDIT_AUTO_SELECT             = NK_FLAG(1),\n    NK_EDIT_SIG_ENTER               = NK_FLAG(2),\n    NK_EDIT_ALLOW_TAB               = NK_FLAG(3),\n    NK_EDIT_NO_CURSOR               = NK_FLAG(4),\n    NK_EDIT_SELECTABLE              = NK_FLAG(5),\n    NK_EDIT_CLIPBOARD               = NK_FLAG(6),\n    NK_EDIT_CTRL_ENTER_NEWLINE      = NK_FLAG(7),\n    NK_EDIT_NO_HORIZONTAL_SCROLL    = NK_FLAG(8),\n    NK_EDIT_ALWAYS_INSERT_MODE      = NK_FLAG(9),\n    NK_EDIT_MULTILINE               = NK_FLAG(10),\n    NK_EDIT_GOTO_END_ON_ACTIVATE    = NK_FLAG(11)\n};\nenum nk_edit_types {\n    NK_EDIT_SIMPLE  = NK_EDIT_ALWAYS_INSERT_MODE,\n    NK_EDIT_FIELD   = NK_EDIT_SIMPLE|NK_EDIT_SELECTABLE|NK_EDIT_CLIPBOARD,\n    NK_EDIT_BOX     = NK_EDIT_ALWAYS_INSERT_MODE| NK_EDIT_SELECTABLE| NK_EDIT_MULTILINE|NK_EDIT_ALLOW_TAB|NK_EDIT_CLIPBOARD,\n    NK_EDIT_EDITOR  = NK_EDIT_SELECTABLE|NK_EDIT_MULTILINE|NK_EDIT_ALLOW_TAB| NK_EDIT_CLIPBOARD\n};\nenum nk_edit_events {\n    NK_EDIT_ACTIVE      = NK_FLAG(0), /**!< edit widget is currently being modified */\n    NK_EDIT_INACTIVE    = NK_FLAG(1), /**!< edit widget is not active and is not being modified */\n    NK_EDIT_ACTIVATED   = NK_FLAG(2), /**!< edit widget went from state inactive to state active */\n    NK_EDIT_DEACTIVATED = NK_FLAG(3), /**!< edit widget went from state active to state inactive */\n    NK_EDIT_COMMITED    = NK_FLAG(4)  /**!< edit widget has received an enter and lost focus */\n};\nNK_API nk_flags nk_edit_string(struct nk_context*, nk_flags, char *buffer, int *len, int max, nk_plugin_filter);\nNK_API nk_flags nk_edit_string_zero_terminated(struct nk_context*, nk_flags, char *buffer, int max, nk_plugin_filter);\nNK_API nk_flags nk_edit_buffer(struct nk_context*, nk_flags, struct nk_text_edit*, nk_plugin_filter);\nNK_API void nk_edit_focus(struct nk_context*, nk_flags flags);\nNK_API void nk_edit_unfocus(struct nk_context*);\n/* =============================================================================\n *\n *                                  CHART\n *\n * ============================================================================= */\nNK_API nk_bool nk_chart_begin(struct nk_context*, enum nk_chart_type, int num, float min, float max);\nNK_API nk_bool nk_chart_begin_colored(struct nk_context*, enum nk_chart_type, struct nk_color, struct nk_color active, int num, float min, float max);\nNK_API void nk_chart_add_slot(struct nk_context *ctx, const enum nk_chart_type, int count, float min_value, float max_value);\nNK_API void nk_chart_add_slot_colored(struct nk_context *ctx, const enum nk_chart_type, struct nk_color, struct nk_color active, int count, float min_value, float max_value);\nNK_API nk_flags nk_chart_push(struct nk_context*, float);\nNK_API nk_flags nk_chart_push_slot(struct nk_context*, float, int);\nNK_API void nk_chart_end(struct nk_context*);\nNK_API void nk_plot(struct nk_context*, enum nk_chart_type, const float *values, int count, int offset);\nNK_API void nk_plot_function(struct nk_context*, enum nk_chart_type, void *userdata, float(*value_getter)(void* user, int index), int count, int offset);\n/* =============================================================================\n *\n *                                  POPUP\n *\n * ============================================================================= */\nNK_API nk_bool nk_popup_begin(struct nk_context*, enum nk_popup_type, const char*, nk_flags, struct nk_rect bounds);\nNK_API void nk_popup_close(struct nk_context*);\nNK_API void nk_popup_end(struct nk_context*);\nNK_API void nk_popup_get_scroll(const struct nk_context*, nk_uint *offset_x, nk_uint *offset_y);\nNK_API void nk_popup_set_scroll(struct nk_context*, nk_uint offset_x, nk_uint offset_y);\n/* =============================================================================\n *\n *                                  COMBOBOX\n *\n * ============================================================================= */\nNK_API int nk_combo(struct nk_context*, const char *const *items, int count, int selected, int item_height, struct nk_vec2 size);\nNK_API int nk_combo_separator(struct nk_context*, const char *items_separated_by_separator, int separator, int selected, int count, int item_height, struct nk_vec2 size);\nNK_API int nk_combo_string(struct nk_context*, const char *items_separated_by_zeros, int selected, int count, int item_height, struct nk_vec2 size);\nNK_API int nk_combo_callback(struct nk_context*, void(*item_getter)(void*, int, const char**), void *userdata, int selected, int count, int item_height, struct nk_vec2 size);\nNK_API void nk_combobox(struct nk_context*, const char *const *items, int count, int *selected, int item_height, struct nk_vec2 size);\nNK_API void nk_combobox_string(struct nk_context*, const char *items_separated_by_zeros, int *selected, int count, int item_height, struct nk_vec2 size);\nNK_API void nk_combobox_separator(struct nk_context*, const char *items_separated_by_separator, int separator, int *selected, int count, int item_height, struct nk_vec2 size);\nNK_API void nk_combobox_callback(struct nk_context*, void(*item_getter)(void*, int, const char**), void*, int *selected, int count, int item_height, struct nk_vec2 size);\n/* =============================================================================\n *\n *                                  ABSTRACT COMBOBOX\n *\n * ============================================================================= */\nNK_API nk_bool nk_combo_begin_text(struct nk_context*, const char *selected, int, struct nk_vec2 size);\nNK_API nk_bool nk_combo_begin_label(struct nk_context*, const char *selected, struct nk_vec2 size);\nNK_API nk_bool nk_combo_begin_color(struct nk_context*, struct nk_color color, struct nk_vec2 size);\nNK_API nk_bool nk_combo_begin_symbol(struct nk_context*,  enum nk_symbol_type,  struct nk_vec2 size);\nNK_API nk_bool nk_combo_begin_symbol_label(struct nk_context*, const char *selected, enum nk_symbol_type, struct nk_vec2 size);\nNK_API nk_bool nk_combo_begin_symbol_text(struct nk_context*, const char *selected, int, enum nk_symbol_type, struct nk_vec2 size);\nNK_API nk_bool nk_combo_begin_image(struct nk_context*, struct nk_image img,  struct nk_vec2 size);\nNK_API nk_bool nk_combo_begin_image_label(struct nk_context*, const char *selected, struct nk_image, struct nk_vec2 size);\nNK_API nk_bool nk_combo_begin_image_text(struct nk_context*,  const char *selected, int, struct nk_image, struct nk_vec2 size);\nNK_API nk_bool nk_combo_item_label(struct nk_context*, const char*, nk_flags alignment);\nNK_API nk_bool nk_combo_item_text(struct nk_context*, const char*,int, nk_flags alignment);\nNK_API nk_bool nk_combo_item_image_label(struct nk_context*, struct nk_image, const char*, nk_flags alignment);\nNK_API nk_bool nk_combo_item_image_text(struct nk_context*, struct nk_image, const char*, int,nk_flags alignment);\nNK_API nk_bool nk_combo_item_symbol_label(struct nk_context*, enum nk_symbol_type, const char*, nk_flags alignment);\nNK_API nk_bool nk_combo_item_symbol_text(struct nk_context*, enum nk_symbol_type, const char*, int, nk_flags alignment);\nNK_API void nk_combo_close(struct nk_context*);\nNK_API void nk_combo_end(struct nk_context*);\n/* =============================================================================\n *\n *                                  CONTEXTUAL\n *\n * ============================================================================= */\nNK_API nk_bool nk_contextual_begin(struct nk_context*, nk_flags, struct nk_vec2, struct nk_rect trigger_bounds);\nNK_API nk_bool nk_contextual_item_text(struct nk_context*, const char*, int,nk_flags align);\nNK_API nk_bool nk_contextual_item_label(struct nk_context*, const char*, nk_flags align);\nNK_API nk_bool nk_contextual_item_image_label(struct nk_context*, struct nk_image, const char*, nk_flags alignment);\nNK_API nk_bool nk_contextual_item_image_text(struct nk_context*, struct nk_image, const char*, int len, nk_flags alignment);\nNK_API nk_bool nk_contextual_item_symbol_label(struct nk_context*, enum nk_symbol_type, const char*, nk_flags alignment);\nNK_API nk_bool nk_contextual_item_symbol_text(struct nk_context*, enum nk_symbol_type, const char*, int, nk_flags alignment);\nNK_API void nk_contextual_close(struct nk_context*);\nNK_API void nk_contextual_end(struct nk_context*);\n/* =============================================================================\n *\n *                                  TOOLTIP\n *\n * ============================================================================= */\nNK_API void nk_tooltip(struct nk_context*, const char*);\n#ifdef NK_INCLUDE_STANDARD_VARARGS\nNK_API void nk_tooltipf(struct nk_context*, NK_PRINTF_FORMAT_STRING const char*, ...) NK_PRINTF_VARARG_FUNC(2);\nNK_API void nk_tooltipfv(struct nk_context*, NK_PRINTF_FORMAT_STRING const char*, va_list) NK_PRINTF_VALIST_FUNC(2);\n#endif\nNK_API nk_bool nk_tooltip_begin(struct nk_context*, float width);\nNK_API void nk_tooltip_end(struct nk_context*);\n/* =============================================================================\n *\n *                                  MENU\n *\n * ============================================================================= */\nNK_API void nk_menubar_begin(struct nk_context*);\nNK_API void nk_menubar_end(struct nk_context*);\nNK_API nk_bool nk_menu_begin_text(struct nk_context*, const char* title, int title_len, nk_flags align, struct nk_vec2 size);\nNK_API nk_bool nk_menu_begin_label(struct nk_context*, const char*, nk_flags align, struct nk_vec2 size);\nNK_API nk_bool nk_menu_begin_image(struct nk_context*, const char*, struct nk_image, struct nk_vec2 size);\nNK_API nk_bool nk_menu_begin_image_text(struct nk_context*, const char*, int,nk_flags align,struct nk_image, struct nk_vec2 size);\nNK_API nk_bool nk_menu_begin_image_label(struct nk_context*, const char*, nk_flags align,struct nk_image, struct nk_vec2 size);\nNK_API nk_bool nk_menu_begin_symbol(struct nk_context*, const char*, enum nk_symbol_type, struct nk_vec2 size);\nNK_API nk_bool nk_menu_begin_symbol_text(struct nk_context*, const char*, int,nk_flags align,enum nk_symbol_type, struct nk_vec2 size);\nNK_API nk_bool nk_menu_begin_symbol_label(struct nk_context*, const char*, nk_flags align,enum nk_symbol_type, struct nk_vec2 size);\nNK_API nk_bool nk_menu_item_text(struct nk_context*, const char*, int,nk_flags align);\nNK_API nk_bool nk_menu_item_label(struct nk_context*, const char*, nk_flags alignment);\nNK_API nk_bool nk_menu_item_image_label(struct nk_context*, struct nk_image, const char*, nk_flags alignment);\nNK_API nk_bool nk_menu_item_image_text(struct nk_context*, struct nk_image, const char*, int len, nk_flags alignment);\nNK_API nk_bool nk_menu_item_symbol_text(struct nk_context*, enum nk_symbol_type, const char*, int, nk_flags alignment);\nNK_API nk_bool nk_menu_item_symbol_label(struct nk_context*, enum nk_symbol_type, const char*, nk_flags alignment);\nNK_API void nk_menu_close(struct nk_context*);\nNK_API void nk_menu_end(struct nk_context*);\n/* =============================================================================\n *\n *                                  STYLE\n *\n * ============================================================================= */\n\n#define NK_WIDGET_DISABLED_FACTOR 0.5f\n\nenum nk_style_colors {\n    NK_COLOR_TEXT,\n    NK_COLOR_WINDOW,\n    NK_COLOR_HEADER,\n    NK_COLOR_BORDER,\n    NK_COLOR_BUTTON,\n    NK_COLOR_BUTTON_HOVER,\n    NK_COLOR_BUTTON_ACTIVE,\n    NK_COLOR_TOGGLE,\n    NK_COLOR_TOGGLE_HOVER,\n    NK_COLOR_TOGGLE_CURSOR,\n    NK_COLOR_SELECT,\n    NK_COLOR_SELECT_ACTIVE,\n    NK_COLOR_SLIDER,\n    NK_COLOR_SLIDER_CURSOR,\n    NK_COLOR_SLIDER_CURSOR_HOVER,\n    NK_COLOR_SLIDER_CURSOR_ACTIVE,\n    NK_COLOR_PROPERTY,\n    NK_COLOR_EDIT,\n    NK_COLOR_EDIT_CURSOR,\n    NK_COLOR_COMBO,\n    NK_COLOR_CHART,\n    NK_COLOR_CHART_COLOR,\n    NK_COLOR_CHART_COLOR_HIGHLIGHT,\n    NK_COLOR_SCROLLBAR,\n    NK_COLOR_SCROLLBAR_CURSOR,\n    NK_COLOR_SCROLLBAR_CURSOR_HOVER,\n    NK_COLOR_SCROLLBAR_CURSOR_ACTIVE,\n    NK_COLOR_TAB_HEADER,\n    NK_COLOR_KNOB,\n    NK_COLOR_KNOB_CURSOR,\n    NK_COLOR_KNOB_CURSOR_HOVER,\n    NK_COLOR_KNOB_CURSOR_ACTIVE,\n    NK_COLOR_COUNT\n};\nenum nk_style_cursor {\n    NK_CURSOR_ARROW,\n    NK_CURSOR_TEXT,\n    NK_CURSOR_MOVE,\n    NK_CURSOR_RESIZE_VERTICAL,\n    NK_CURSOR_RESIZE_HORIZONTAL,\n    NK_CURSOR_RESIZE_TOP_LEFT_DOWN_RIGHT,\n    NK_CURSOR_RESIZE_TOP_RIGHT_DOWN_LEFT,\n    NK_CURSOR_COUNT\n};\nNK_API void nk_style_default(struct nk_context*);\nNK_API void nk_style_from_table(struct nk_context*, const struct nk_color*);\nNK_API void nk_style_load_cursor(struct nk_context*, enum nk_style_cursor, const struct nk_cursor*);\nNK_API void nk_style_load_all_cursors(struct nk_context*, const struct nk_cursor*);\nNK_API const char* nk_style_get_color_by_name(enum nk_style_colors);\nNK_API void nk_style_set_font(struct nk_context*, const struct nk_user_font*);\nNK_API nk_bool nk_style_set_cursor(struct nk_context*, enum nk_style_cursor);\nNK_API void nk_style_show_cursor(struct nk_context*);\nNK_API void nk_style_hide_cursor(struct nk_context*);\n\nNK_API nk_bool nk_style_push_font(struct nk_context*, const struct nk_user_font*);\nNK_API nk_bool nk_style_push_float(struct nk_context*, float*, float);\nNK_API nk_bool nk_style_push_vec2(struct nk_context*, struct nk_vec2*, struct nk_vec2);\nNK_API nk_bool nk_style_push_style_item(struct nk_context*, struct nk_style_item*, struct nk_style_item);\nNK_API nk_bool nk_style_push_flags(struct nk_context*, nk_flags*, nk_flags);\nNK_API nk_bool nk_style_push_color(struct nk_context*, struct nk_color*, struct nk_color);\n\nNK_API nk_bool nk_style_pop_font(struct nk_context*);\nNK_API nk_bool nk_style_pop_float(struct nk_context*);\nNK_API nk_bool nk_style_pop_vec2(struct nk_context*);\nNK_API nk_bool nk_style_pop_style_item(struct nk_context*);\nNK_API nk_bool nk_style_pop_flags(struct nk_context*);\nNK_API nk_bool nk_style_pop_color(struct nk_context*);\n/* =============================================================================\n *\n *                                  COLOR\n *\n * ============================================================================= */\nNK_API struct nk_color nk_rgb(int r, int g, int b);\nNK_API struct nk_color nk_rgb_iv(const int *rgb);\nNK_API struct nk_color nk_rgb_bv(const nk_byte* rgb);\nNK_API struct nk_color nk_rgb_f(float r, float g, float b);\nNK_API struct nk_color nk_rgb_fv(const float *rgb);\nNK_API struct nk_color nk_rgb_cf(struct nk_colorf c);\nNK_API struct nk_color nk_rgb_hex(const char *rgb);\nNK_API struct nk_color nk_rgb_factor(struct nk_color col, float factor);\n\nNK_API struct nk_color nk_rgba(int r, int g, int b, int a);\nNK_API struct nk_color nk_rgba_u32(nk_uint);\nNK_API struct nk_color nk_rgba_iv(const int *rgba);\nNK_API struct nk_color nk_rgba_bv(const nk_byte *rgba);\nNK_API struct nk_color nk_rgba_f(float r, float g, float b, float a);\nNK_API struct nk_color nk_rgba_fv(const float *rgba);\nNK_API struct nk_color nk_rgba_cf(struct nk_colorf c);\nNK_API struct nk_color nk_rgba_hex(const char *rgb);\n\nNK_API struct nk_colorf nk_hsva_colorf(float h, float s, float v, float a);\nNK_API struct nk_colorf nk_hsva_colorfv(const float *c);\nNK_API void nk_colorf_hsva_f(float *out_h, float *out_s, float *out_v, float *out_a, struct nk_colorf in);\nNK_API void nk_colorf_hsva_fv(float *hsva, struct nk_colorf in);\n\nNK_API struct nk_color nk_hsv(int h, int s, int v);\nNK_API struct nk_color nk_hsv_iv(const int *hsv);\nNK_API struct nk_color nk_hsv_bv(const nk_byte *hsv);\nNK_API struct nk_color nk_hsv_f(float h, float s, float v);\nNK_API struct nk_color nk_hsv_fv(const float *hsv);\n\nNK_API struct nk_color nk_hsva(int h, int s, int v, int a);\nNK_API struct nk_color nk_hsva_iv(const int *hsva);\nNK_API struct nk_color nk_hsva_bv(const nk_byte *hsva);\nNK_API struct nk_color nk_hsva_f(float h, float s, float v, float a);\nNK_API struct nk_color nk_hsva_fv(const float *hsva);\n\n/* color (conversion nuklear --> user) */\nNK_API void nk_color_f(float *r, float *g, float *b, float *a, struct nk_color);\nNK_API void nk_color_fv(float *rgba_out, struct nk_color);\nNK_API struct nk_colorf nk_color_cf(struct nk_color);\nNK_API void nk_color_d(double *r, double *g, double *b, double *a, struct nk_color);\nNK_API void nk_color_dv(double *rgba_out, struct nk_color);\n\nNK_API nk_uint nk_color_u32(struct nk_color);\nNK_API void nk_color_hex_rgba(char *output, struct nk_color);\nNK_API void nk_color_hex_rgb(char *output, struct nk_color);\n\nNK_API void nk_color_hsv_i(int *out_h, int *out_s, int *out_v, struct nk_color);\nNK_API void nk_color_hsv_b(nk_byte *out_h, nk_byte *out_s, nk_byte *out_v, struct nk_color);\nNK_API void nk_color_hsv_iv(int *hsv_out, struct nk_color);\nNK_API void nk_color_hsv_bv(nk_byte *hsv_out, struct nk_color);\nNK_API void nk_color_hsv_f(float *out_h, float *out_s, float *out_v, struct nk_color);\nNK_API void nk_color_hsv_fv(float *hsv_out, struct nk_color);\n\nNK_API void nk_color_hsva_i(int *h, int *s, int *v, int *a, struct nk_color);\nNK_API void nk_color_hsva_b(nk_byte *h, nk_byte *s, nk_byte *v, nk_byte *a, struct nk_color);\nNK_API void nk_color_hsva_iv(int *hsva_out, struct nk_color);\nNK_API void nk_color_hsva_bv(nk_byte *hsva_out, struct nk_color);\nNK_API void nk_color_hsva_f(float *out_h, float *out_s, float *out_v, float *out_a, struct nk_color);\nNK_API void nk_color_hsva_fv(float *hsva_out, struct nk_color);\n/* =============================================================================\n *\n *                                  IMAGE\n *\n * ============================================================================= */\nNK_API nk_handle nk_handle_ptr(void*);\nNK_API nk_handle nk_handle_id(int);\nNK_API struct nk_image nk_image_handle(nk_handle);\nNK_API struct nk_image nk_image_ptr(void*);\nNK_API struct nk_image nk_image_id(int);\nNK_API nk_bool nk_image_is_subimage(const struct nk_image* img);\nNK_API struct nk_image nk_subimage_ptr(void*, nk_ushort w, nk_ushort h, struct nk_rect sub_region);\nNK_API struct nk_image nk_subimage_id(int, nk_ushort w, nk_ushort h, struct nk_rect sub_region);\nNK_API struct nk_image nk_subimage_handle(nk_handle, nk_ushort w, nk_ushort h, struct nk_rect sub_region);\n/* =============================================================================\n *\n *                                  9-SLICE\n *\n * ============================================================================= */\nNK_API struct nk_nine_slice nk_nine_slice_handle(nk_handle, nk_ushort l, nk_ushort t, nk_ushort r, nk_ushort b);\nNK_API struct nk_nine_slice nk_nine_slice_ptr(void*, nk_ushort l, nk_ushort t, nk_ushort r, nk_ushort b);\nNK_API struct nk_nine_slice nk_nine_slice_id(int, nk_ushort l, nk_ushort t, nk_ushort r, nk_ushort b);\nNK_API int nk_nine_slice_is_sub9slice(const struct nk_nine_slice* img);\nNK_API struct nk_nine_slice nk_sub9slice_ptr(void*, nk_ushort w, nk_ushort h, struct nk_rect sub_region, nk_ushort l, nk_ushort t, nk_ushort r, nk_ushort b);\nNK_API struct nk_nine_slice nk_sub9slice_id(int, nk_ushort w, nk_ushort h, struct nk_rect sub_region, nk_ushort l, nk_ushort t, nk_ushort r, nk_ushort b);\nNK_API struct nk_nine_slice nk_sub9slice_handle(nk_handle, nk_ushort w, nk_ushort h, struct nk_rect sub_region, nk_ushort l, nk_ushort t, nk_ushort r, nk_ushort b);\n/* =============================================================================\n *\n *                                  MATH\n *\n * ============================================================================= */\nNK_API nk_hash nk_murmur_hash(const void *key, int len, nk_hash seed);\nNK_API void nk_triangle_from_direction(struct nk_vec2 *result, struct nk_rect r, float pad_x, float pad_y, enum nk_heading);\n\nNK_API struct nk_vec2 nk_vec2(float x, float y);\nNK_API struct nk_vec2 nk_vec2i(int x, int y);\nNK_API struct nk_vec2 nk_vec2v(const float *xy);\nNK_API struct nk_vec2 nk_vec2iv(const int *xy);\n\nNK_API struct nk_rect nk_get_null_rect(void);\nNK_API struct nk_rect nk_rect(float x, float y, float w, float h);\nNK_API struct nk_rect nk_recti(int x, int y, int w, int h);\nNK_API struct nk_rect nk_recta(struct nk_vec2 pos, struct nk_vec2 size);\nNK_API struct nk_rect nk_rectv(const float *xywh);\nNK_API struct nk_rect nk_rectiv(const int *xywh);\nNK_API struct nk_vec2 nk_rect_pos(struct nk_rect);\nNK_API struct nk_vec2 nk_rect_size(struct nk_rect);\n/* =============================================================================\n *\n *                                  STRING\n *\n * ============================================================================= */\nNK_API int nk_strlen(const char *str);\nNK_API int nk_stricmp(const char *s1, const char *s2);\nNK_API int nk_stricmpn(const char *s1, const char *s2, int n);\nNK_API int nk_strtoi(const char *str, char **endptr);\nNK_API float nk_strtof(const char *str, char **endptr);\n#ifndef NK_STRTOD\n#define NK_STRTOD nk_strtod\nNK_API double nk_strtod(const char *str, char **endptr);\n#endif\nNK_API int nk_strfilter(const char *text, const char *regexp);\nNK_API int nk_strmatch_fuzzy_string(char const *str, char const *pattern, int *out_score);\nNK_API int nk_strmatch_fuzzy_text(const char *txt, int txt_len, const char *pattern, int *out_score);\n/* =============================================================================\n *\n *                                  UTF-8\n *\n * ============================================================================= */\nNK_API int nk_utf_decode(const char*, nk_rune*, int);\nNK_API int nk_utf_encode(nk_rune, char*, int);\nNK_API int nk_utf_len(const char*, int byte_len);\nNK_API const char* nk_utf_at(const char *buffer, int length, int index, nk_rune *unicode, int *len);\n/* ===============================================================\n *\n *                          FONT\n *\n * ===============================================================*/\n/**\n * \\page Font\n * Font handling in this library was designed to be quite customizable and lets\n * you decide what you want to use and what you want to provide. There are three\n * different ways to use the font atlas. The first two will use your font\n * handling scheme and only requires essential data to run nuklear. The next\n * slightly more advanced features is font handling with vertex buffer output.\n * Finally the most complex API wise is using nuklear's font baking API.\n *\n * # Using your own implementation without vertex buffer output\n *\n * So first up the easiest way to do font handling is by just providing a\n * `nk_user_font` struct which only requires the height in pixel of the used\n * font and a callback to calculate the width of a string. This way of handling\n * fonts is best fitted for using the normal draw shape command API where you\n * do all the text drawing yourself and the library does not require any kind\n * of deeper knowledge about which font handling mechanism you use.\n * IMPORTANT: the `nk_user_font` pointer provided to nuklear has to persist\n * over the complete life time! I know this sucks but it is currently the only\n * way to switch between fonts.\n *\n * ```c\n *     float your_text_width_calculation(nk_handle handle, float height, const char *text, int len)\n *     {\n *         your_font_type *type = handle.ptr;\n *         float text_width = ...;\n *         return text_width;\n *     }\n *\n *     struct nk_user_font font;\n *     font.userdata.ptr = &your_font_class_or_struct;\n *     font.height = your_font_height;\n *     font.width = your_text_width_calculation;\n *\n *     struct nk_context ctx;\n *     nk_init_default(&ctx, &font);\n * ```\n * # Using your own implementation with vertex buffer output\n *\n * While the first approach works fine if you don't want to use the optional\n * vertex buffer output it is not enough if you do. To get font handling working\n * for these cases you have to provide two additional parameters inside the\n * `nk_user_font`. First a texture atlas handle used to draw text as subimages\n * of a bigger font atlas texture and a callback to query a character's glyph\n * information (offset, size, ...). So it is still possible to provide your own\n * font and use the vertex buffer output.\n *\n * ```c\n *     float your_text_width_calculation(nk_handle handle, float height, const char *text, int len)\n *     {\n *         your_font_type *type = handle.ptr;\n *         float text_width = ...;\n *         return text_width;\n *     }\n *     void query_your_font_glyph(nk_handle handle, float font_height, struct nk_user_font_glyph *glyph, nk_rune codepoint, nk_rune next_codepoint)\n *     {\n *         your_font_type *type = handle.ptr;\n *         glyph.width = ...;\n *         glyph.height = ...;\n *         glyph.xadvance = ...;\n *         glyph.uv[0].x = ...;\n *         glyph.uv[0].y = ...;\n *         glyph.uv[1].x = ...;\n *         glyph.uv[1].y = ...;\n *         glyph.offset.x = ...;\n *         glyph.offset.y = ...;\n *     }\n *\n *     struct nk_user_font font;\n *     font.userdata.ptr = &your_font_class_or_struct;\n *     font.height = your_font_height;\n *     font.width = your_text_width_calculation;\n *     font.query = query_your_font_glyph;\n *     font.texture.id = your_font_texture;\n *\n *     struct nk_context ctx;\n *     nk_init_default(&ctx, &font);\n * ```\n *\n * # Nuklear font baker\n *\n * The final approach if you do not have a font handling functionality or don't\n * want to use it in this library is by using the optional font baker.\n * The font baker APIs can be used to create a font plus font atlas texture\n * and can be used with or without the vertex buffer output.\n *\n * It still uses the `nk_user_font` struct and the two different approaches\n * previously stated still work. The font baker is not located inside\n * `nk_context` like all other systems since it can be understood as more of\n * an extension to nuklear and does not really depend on any `nk_context` state.\n *\n * Font baker need to be initialized first by one of the nk_font_atlas_init_xxx\n * functions. If you don't care about memory just call the default version\n * `nk_font_atlas_init_default` which will allocate all memory from the standard library.\n * If you want to control memory allocation but you don't care if the allocated\n * memory is temporary and therefore can be freed directly after the baking process\n * is over or permanent you can call `nk_font_atlas_init`.\n *\n * After successfully initializing the font baker you can add Truetype(.ttf) fonts from\n * different sources like memory or from file by calling one of the `nk_font_atlas_add_xxx`.\n * functions. Adding font will permanently store each font, font config and ttf memory block(!)\n * inside the font atlas and allows to reuse the font atlas. If you don't want to reuse\n * the font baker by for example adding additional fonts you can call\n * `nk_font_atlas_cleanup` after the baking process is over (after calling nk_font_atlas_end).\n *\n * As soon as you added all fonts you wanted you can now start the baking process\n * for every selected glyph to image by calling `nk_font_atlas_bake`.\n * The baking process returns image memory, width and height which can be used to\n * either create your own image object or upload it to any graphics library.\n * No matter which case you finally have to call `nk_font_atlas_end` which\n * will free all temporary memory including the font atlas image so make sure\n * you created our texture beforehand. `nk_font_atlas_end` requires a handle\n * to your font texture or object and optionally fills a `struct nk_draw_null_texture`\n * which can be used for the optional vertex output. If you don't want it just\n * set the argument to `NULL`.\n *\n * At this point you are done and if you don't want to reuse the font atlas you\n * can call `nk_font_atlas_cleanup` to free all truetype blobs and configuration\n * memory. Finally if you don't use the font atlas and any of it's fonts anymore\n * you need to call `nk_font_atlas_clear` to free all memory still being used.\n *\n * ```c\n *     struct nk_font_atlas atlas;\n *     nk_font_atlas_init_default(&atlas);\n *     nk_font_atlas_begin(&atlas);\n *     nk_font *font = nk_font_atlas_add_from_file(&atlas, \"Path/To/Your/TTF_Font.ttf\", 13, 0);\n *     nk_font *font2 = nk_font_atlas_add_from_file(&atlas, \"Path/To/Your/TTF_Font2.ttf\", 16, 0);\n *     const void* img = nk_font_atlas_bake(&atlas, &img_width, &img_height, NK_FONT_ATLAS_RGBA32);\n *     nk_font_atlas_end(&atlas, nk_handle_id(texture), 0);\n *\n *     struct nk_context ctx;\n *     nk_init_default(&ctx, &font->handle);\n *     while (1) {\n *\n *     }\n *     nk_font_atlas_clear(&atlas);\n * ```\n * The font baker API is probably the most complex API inside this library and\n * I would suggest reading some of my examples `example/` to get a grip on how\n * to use the font atlas. There are a number of details I left out. For example\n * how to merge fonts, configure a font with `nk_font_config` to use other languages,\n * use another texture coordinate format and a lot more:\n *\n * ```c\n *     struct nk_font_config cfg = nk_font_config(font_pixel_height);\n *     cfg.merge_mode = nk_false or nk_true;\n *     cfg.range = nk_font_korean_glyph_ranges();\n *     cfg.coord_type = NK_COORD_PIXEL;\n *     nk_font *font = nk_font_atlas_add_from_file(&atlas, \"Path/To/Your/TTF_Font.ttf\", 13, &cfg);\n * ```\n */\n\nstruct nk_user_font_glyph;\ntypedef float(*nk_text_width_f)(nk_handle, float h, const char*, int len);\ntypedef void(*nk_query_font_glyph_f)(nk_handle handle, float font_height,\n                                    struct nk_user_font_glyph *glyph,\n                                    nk_rune codepoint, nk_rune next_codepoint);\n\n#if defined(NK_INCLUDE_VERTEX_BUFFER_OUTPUT) || defined(NK_INCLUDE_SOFTWARE_FONT)\nstruct nk_user_font_glyph {\n    struct nk_vec2 uv[2];  /**!< texture coordinates */\n    struct nk_vec2 offset; /**!< offset between top left and glyph */\n    float width, height;   /**!< size of the glyph  */\n    float xadvance;        /**!< offset to the next glyph */\n};\n#endif\n\nstruct nk_user_font {\n    nk_handle userdata;    /**!< user provided font handle */\n    float height;          /**!< max height of the font */\n    nk_text_width_f width; /**!< font string width in pixel callback */\n#ifdef NK_INCLUDE_VERTEX_BUFFER_OUTPUT\n    nk_query_font_glyph_f query; /**!< font glyph callback to query drawing info */\n    nk_handle texture;           /**!< texture handle to the used font atlas or texture */\n#endif\n};\n\n#ifdef NK_INCLUDE_FONT_BAKING\nenum nk_font_coord_type {\n    NK_COORD_UV,   /**!< texture coordinates inside font glyphs are clamped between 0-1 */\n    NK_COORD_PIXEL /**!< texture coordinates inside font glyphs are in absolute pixel */\n};\n\nstruct nk_font;\nstruct nk_baked_font {\n    float height;          /**!< height of the font  */\n    float ascent;          /**!< font glyphs ascent and descent  */\n    float descent;         /**!< font glyphs ascent and descent  */\n    nk_rune glyph_offset;  /**!< glyph array offset inside the font glyph baking output array  */\n    nk_rune glyph_count;   /**!< number of glyphs of this font inside the glyph baking array output */\n    const nk_rune *ranges; /**!< font codepoint ranges as pairs of (from/to) and 0 as last element */\n};\n\nstruct nk_font_config {\n    struct nk_font_config *next; /**!< NOTE: only used internally */\n    void *ttf_blob;              /**!< pointer to loaded TTF file memory block.  * \\note not needed for nk_font_atlas_add_from_memory and nk_font_atlas_add_from_file. */\n    nk_size ttf_size;            /**!< size of the loaded TTF file memory block * \\note not needed for nk_font_atlas_add_from_memory and nk_font_atlas_add_from_file. */\n\n    unsigned char ttf_data_owned_by_atlas;    /**!< used inside font atlas: default to: 0*/\n    unsigned char merge_mode;                 /**!< merges this font into the last font */\n    unsigned char pixel_snap;                 /**!< align every character to pixel boundary (if true set oversample (1,1)) */\n    unsigned char oversample_v, oversample_h; /**!< rasterize at high quality for sub-pixel position */\n    unsigned char padding[3];\n\n    float size;                         /**!< baked pixel height of the font */\n    enum nk_font_coord_type coord_type; /**!< texture coordinate format with either pixel or UV coordinates */\n    struct nk_vec2 spacing;             /**!< extra pixel spacing between glyphs  */\n    const nk_rune *range;               /**!< list of unicode ranges (2 values per range, zero terminated) */\n    struct nk_baked_font *font;         /**!< font to setup in the baking process: NOTE: not needed for font atlas */\n    nk_rune fallback_glyph;             /**!< fallback glyph to use if a given rune is not found */\n    struct nk_font_config *n;\n    struct nk_font_config *p;\n};\n\nstruct nk_font_glyph {\n    nk_rune codepoint;\n    float xadvance;\n    float x0, y0, x1, y1, w, h;\n    float u0, v0, u1, v1;\n};\n\nstruct nk_font {\n    struct nk_font *next;\n    struct nk_user_font handle;\n    struct nk_baked_font info;\n    float scale;\n    struct nk_font_glyph *glyphs;\n    const struct nk_font_glyph *fallback;\n    nk_rune fallback_codepoint;\n    nk_handle texture;\n    struct nk_font_config *config;\n};\n\nenum nk_font_atlas_format {\n    NK_FONT_ATLAS_ALPHA8,\n    NK_FONT_ATLAS_RGBA32\n};\n\nstruct nk_font_atlas {\n    void *pixel;\n    int tex_width;\n    int tex_height;\n\n    struct nk_allocator permanent;\n    struct nk_allocator temporary;\n\n    struct nk_recti custom;\n    struct nk_cursor cursors[NK_CURSOR_COUNT];\n\n    int glyph_count;\n    struct nk_font_glyph *glyphs;\n    struct nk_font *default_font;\n    struct nk_font *fonts;\n    struct nk_font_config *config;\n    int font_num;\n};\n\n/** some language glyph codepoint ranges */\nNK_API const nk_rune *nk_font_default_glyph_ranges(void);\nNK_API const nk_rune *nk_font_chinese_glyph_ranges(void);\nNK_API const nk_rune *nk_font_cyrillic_glyph_ranges(void);\nNK_API const nk_rune *nk_font_korean_glyph_ranges(void);\n\n#ifdef NK_INCLUDE_DEFAULT_ALLOCATOR\nNK_API void nk_font_atlas_init_default(struct nk_font_atlas*);\n#endif\nNK_API void nk_font_atlas_init(struct nk_font_atlas*, const struct nk_allocator*);\nNK_API void nk_font_atlas_init_custom(struct nk_font_atlas*, const struct nk_allocator *persistent, const struct nk_allocator *transient);\nNK_API void nk_font_atlas_begin(struct nk_font_atlas*);\nNK_API struct nk_font_config nk_font_config(float pixel_height);\nNK_API struct nk_font *nk_font_atlas_add(struct nk_font_atlas*, const struct nk_font_config*);\n#ifdef NK_INCLUDE_DEFAULT_FONT\nNK_API struct nk_font* nk_font_atlas_add_default(struct nk_font_atlas*, float height, const struct nk_font_config*);\n#endif\nNK_API struct nk_font* nk_font_atlas_add_from_memory(struct nk_font_atlas *atlas, void *memory, nk_size size, float height, const struct nk_font_config *config);\n#ifdef NK_INCLUDE_STANDARD_IO\nNK_API struct nk_font* nk_font_atlas_add_from_file(struct nk_font_atlas *atlas, const char *file_path, float height, const struct nk_font_config*);\n#endif\nNK_API struct nk_font *nk_font_atlas_add_compressed(struct nk_font_atlas*, void *memory, nk_size size, float height, const struct nk_font_config*);\nNK_API struct nk_font* nk_font_atlas_add_compressed_base85(struct nk_font_atlas*, const char *data, float height, const struct nk_font_config *config);\nNK_API const void* nk_font_atlas_bake(struct nk_font_atlas*, int *width, int *height, enum nk_font_atlas_format);\nNK_API void nk_font_atlas_end(struct nk_font_atlas*, nk_handle tex, struct nk_draw_null_texture*);\nNK_API const struct nk_font_glyph* nk_font_find_glyph(const struct nk_font*, nk_rune unicode);\nNK_API void nk_font_atlas_cleanup(struct nk_font_atlas *atlas);\nNK_API void nk_font_atlas_clear(struct nk_font_atlas*);\n\n#endif\n\n/** ==============================================================\n *\n *                          MEMORY BUFFER\n *\n * ===============================================================*/\n/**\n * \\page Memory Buffer\n * A basic (double)-buffer with linear allocation and resetting as only\n * freeing policy. The buffer's main purpose is to control all memory management\n * inside the GUI toolkit and still leave memory control as much as possible in\n * the hand of the user while also making sure the library is easy to use if\n * not as much control is needed.\n * In general all memory inside this library can be provided from the user in\n * three different ways.\n *\n * The first way and the one providing most control is by just passing a fixed\n * size memory block. In this case all control lies in the hand of the user\n * since he can exactly control where the memory comes from and how much memory\n * the library should consume. Of course using the fixed size API removes the\n * ability to automatically resize a buffer if not enough memory is provided so\n * you have to take over the resizing. While being a fixed sized buffer sounds\n * quite limiting, it is very effective in this library since the actual memory\n * consumption is quite stable and has a fixed upper bound for a lot of cases.\n *\n * If you don't want to think about how much memory the library should allocate\n * at all time or have a very dynamic UI with unpredictable memory consumption\n * habits but still want control over memory allocation you can use the dynamic\n * allocator based API. The allocator consists of two callbacks for allocating\n * and freeing memory and optional userdata so you can plugin your own allocator.\n *\n * The final and easiest way can be used by defining\n * NK_INCLUDE_DEFAULT_ALLOCATOR which uses the standard library memory\n * allocation functions malloc and free and takes over complete control over\n * memory in this library.\n */\n\nstruct nk_memory_status {\n    void *memory;\n    unsigned int type;\n    nk_size size;\n    nk_size allocated;\n    nk_size needed;\n    nk_size calls;\n};\n\nenum nk_allocation_type {\n    NK_BUFFER_FIXED,\n    NK_BUFFER_DYNAMIC\n};\n\nenum nk_buffer_allocation_type {\n    NK_BUFFER_FRONT,\n    NK_BUFFER_BACK,\n    NK_BUFFER_MAX\n};\n\nstruct nk_buffer_marker {\n    nk_bool active;\n    nk_size offset;\n};\n\nstruct nk_memory {void *ptr;nk_size size;};\nstruct nk_buffer {\n    struct nk_buffer_marker marker[NK_BUFFER_MAX]; /**!< buffer marker to free a buffer to a certain offset */\n    struct nk_allocator pool;     /**!< allocator callback for dynamic buffers */\n    enum nk_allocation_type type; /**!< memory management type */\n    struct nk_memory memory;      /**!< memory and size of the current memory block */\n    float grow_factor;            /**!< growing factor for dynamic memory management */\n    nk_size allocated;            /**!< total amount of memory allocated */\n    nk_size needed;               /**!< totally consumed memory given that enough memory is present */\n    nk_size calls;                /**!< number of allocation calls */\n    nk_size size;                 /**!< current size of the buffer */\n};\n\n#ifdef NK_INCLUDE_DEFAULT_ALLOCATOR\nNK_API void nk_buffer_init_default(struct nk_buffer*);\n#endif\nNK_API void nk_buffer_init(struct nk_buffer*, const struct nk_allocator*, nk_size size);\nNK_API void nk_buffer_init_fixed(struct nk_buffer*, void *memory, nk_size size);\nNK_API void nk_buffer_info(struct nk_memory_status*, const struct nk_buffer*);\nNK_API void nk_buffer_push(struct nk_buffer*, enum nk_buffer_allocation_type type, const void *memory, nk_size size, nk_size align);\nNK_API void nk_buffer_mark(struct nk_buffer*, enum nk_buffer_allocation_type type);\nNK_API void nk_buffer_reset(struct nk_buffer*, enum nk_buffer_allocation_type type);\nNK_API void nk_buffer_clear(struct nk_buffer*);\nNK_API void nk_buffer_free(struct nk_buffer*);\nNK_API void *nk_buffer_memory(struct nk_buffer*);\nNK_API const void *nk_buffer_memory_const(const struct nk_buffer*);\nNK_API nk_size nk_buffer_total(const struct nk_buffer*);\n\n/** ==============================================================\n *\n *                          STRING\n *\n * ===============================================================*/\n/**  Basic string buffer which is only used in context with the text editor\n *  to manage and manipulate dynamic or fixed size string content. This is _NOT_\n *  the default string handling method. The only instance you should have any contact\n *  with this API is if you interact with an `nk_text_edit` object inside one of the\n *  copy and paste functions and even there only for more advanced cases. */\nstruct nk_str {\n    struct nk_buffer buffer;\n    int len; /**!< in codepoints/runes/glyphs */\n};\n\n#ifdef NK_INCLUDE_DEFAULT_ALLOCATOR\nNK_API void nk_str_init_default(struct nk_str*);\n#endif\nNK_API void nk_str_init(struct nk_str*, const struct nk_allocator*, nk_size size);\nNK_API void nk_str_init_fixed(struct nk_str*, void *memory, nk_size size);\nNK_API void nk_str_clear(struct nk_str*);\nNK_API void nk_str_free(struct nk_str*);\n\nNK_API int nk_str_append_text_char(struct nk_str*, const char*, int);\nNK_API int nk_str_append_str_char(struct nk_str*, const char*);\nNK_API int nk_str_append_text_utf8(struct nk_str*, const char*, int);\nNK_API int nk_str_append_str_utf8(struct nk_str*, const char*);\nNK_API int nk_str_append_text_runes(struct nk_str*, const nk_rune*, int);\nNK_API int nk_str_append_str_runes(struct nk_str*, const nk_rune*);\n\nNK_API int nk_str_insert_at_char(struct nk_str*, int pos, const char*, int);\nNK_API int nk_str_insert_at_rune(struct nk_str*, int pos, const char*, int);\n\nNK_API int nk_str_insert_text_char(struct nk_str*, int pos, const char*, int);\nNK_API int nk_str_insert_str_char(struct nk_str*, int pos, const char*);\nNK_API int nk_str_insert_text_utf8(struct nk_str*, int pos, const char*, int);\nNK_API int nk_str_insert_str_utf8(struct nk_str*, int pos, const char*);\nNK_API int nk_str_insert_text_runes(struct nk_str*, int pos, const nk_rune*, int);\nNK_API int nk_str_insert_str_runes(struct nk_str*, int pos, const nk_rune*);\n\nNK_API void nk_str_remove_chars(struct nk_str*, int len);\nNK_API void nk_str_remove_runes(struct nk_str *str, int len);\nNK_API void nk_str_delete_chars(struct nk_str*, int pos, int len);\nNK_API void nk_str_delete_runes(struct nk_str*, int pos, int len);\n\nNK_API char *nk_str_at_char(struct nk_str*, int pos);\nNK_API char *nk_str_at_rune(struct nk_str*, int pos, nk_rune *unicode, int *len);\nNK_API nk_rune nk_str_rune_at(const struct nk_str*, int pos);\nNK_API const char *nk_str_at_char_const(const struct nk_str*, int pos);\nNK_API const char *nk_str_at_const(const struct nk_str*, int pos, nk_rune *unicode, int *len);\n\nNK_API char *nk_str_get(struct nk_str*);\nNK_API const char *nk_str_get_const(const struct nk_str*);\nNK_API int nk_str_len(const struct nk_str*);\nNK_API int nk_str_len_char(const struct nk_str*);\n\n/**===============================================================\n *\n *                      TEXT EDITOR\n *\n * ===============================================================*/\n/**\n * \\page Text Editor\n * Editing text in this library is handled by either `nk_edit_string` or\n * `nk_edit_buffer`. But like almost everything in this library there are multiple\n * ways of doing it and a balance between control and ease of use with memory\n * as well as functionality controlled by flags.\n *\n * This library generally allows three different levels of memory control:\n * First of is the most basic way of just providing a simple char array with\n * string length. This method is probably the easiest way of handling simple\n * user text input. Main upside is complete control over memory while the biggest\n * downside in comparison with the other two approaches is missing undo/redo.\n *\n * For UIs that require undo/redo the second way was created. It is based on\n * a fixed size nk_text_edit struct, which has an internal undo/redo stack.\n * This is mainly useful if you want something more like a text editor but don't want\n * to have a dynamically growing buffer.\n *\n * The final way is using a dynamically growing nk_text_edit struct, which\n * has both a default version if you don't care where memory comes from and an\n * allocator version if you do. While the text editor is quite powerful for its\n * complexity I would not recommend editing gigabytes of data with it.\n * It is rather designed for uses cases which make sense for a GUI library not for\n * an full blown text editor.\n */\n\n#ifndef NK_TEXTEDIT_UNDOSTATECOUNT\n#define NK_TEXTEDIT_UNDOSTATECOUNT     99\n#endif\n\n#ifndef NK_TEXTEDIT_UNDOCHARCOUNT\n#define NK_TEXTEDIT_UNDOCHARCOUNT      999\n#endif\n\nstruct nk_text_edit;\nstruct nk_clipboard {\n    nk_handle userdata;\n    nk_plugin_paste paste;\n    nk_plugin_copy copy;\n};\n\nstruct nk_text_undo_record {\n   int where;\n   short insert_length;\n   short delete_length;\n   short char_storage;\n};\n\nstruct nk_text_undo_state {\n   struct nk_text_undo_record undo_rec[NK_TEXTEDIT_UNDOSTATECOUNT];\n   nk_rune undo_char[NK_TEXTEDIT_UNDOCHARCOUNT];\n   short undo_point;\n   short redo_point;\n   short undo_char_point;\n   short redo_char_point;\n};\n\nenum nk_text_edit_type {\n    NK_TEXT_EDIT_SINGLE_LINE,\n    NK_TEXT_EDIT_MULTI_LINE\n};\n\nenum nk_text_edit_mode {\n    NK_TEXT_EDIT_MODE_VIEW,\n    NK_TEXT_EDIT_MODE_INSERT,\n    NK_TEXT_EDIT_MODE_REPLACE\n};\n\nstruct nk_text_edit {\n    struct nk_clipboard clip;\n    struct nk_str string;\n    nk_plugin_filter filter;\n    struct nk_vec2 scrollbar;\n\n    int cursor;\n    int select_start;\n    int select_end;\n    unsigned char mode;\n    unsigned char cursor_at_end_of_line;\n    unsigned char initialized;\n    unsigned char has_preferred_x;\n    unsigned char single_line;\n    unsigned char active;\n    unsigned char padding1;\n    float preferred_x;\n    struct nk_text_undo_state undo;\n};\n\n/** filter function */\nNK_API nk_bool nk_filter_default(const struct nk_text_edit*, nk_rune unicode);\nNK_API nk_bool nk_filter_ascii(const struct nk_text_edit*, nk_rune unicode);\nNK_API nk_bool nk_filter_float(const struct nk_text_edit*, nk_rune unicode);\nNK_API nk_bool nk_filter_decimal(const struct nk_text_edit*, nk_rune unicode);\nNK_API nk_bool nk_filter_hex(const struct nk_text_edit*, nk_rune unicode);\nNK_API nk_bool nk_filter_oct(const struct nk_text_edit*, nk_rune unicode);\nNK_API nk_bool nk_filter_binary(const struct nk_text_edit*, nk_rune unicode);\n\n/** text editor */\n#ifdef NK_INCLUDE_DEFAULT_ALLOCATOR\nNK_API void nk_textedit_init_default(struct nk_text_edit*);\n#endif\nNK_API void nk_textedit_init(struct nk_text_edit*, const struct nk_allocator*, nk_size size);\nNK_API void nk_textedit_init_fixed(struct nk_text_edit*, void *memory, nk_size size);\nNK_API void nk_textedit_free(struct nk_text_edit*);\nNK_API void nk_textedit_text(struct nk_text_edit*, const char*, int total_len);\nNK_API void nk_textedit_delete(struct nk_text_edit*, int where, int len);\nNK_API void nk_textedit_delete_selection(struct nk_text_edit*);\nNK_API void nk_textedit_select_all(struct nk_text_edit*);\nNK_API nk_bool nk_textedit_cut(struct nk_text_edit*);\nNK_API nk_bool nk_textedit_paste(struct nk_text_edit*, char const*, int len);\nNK_API void nk_textedit_undo(struct nk_text_edit*);\nNK_API void nk_textedit_redo(struct nk_text_edit*);\n\n/* ===============================================================\n *\n *                          DRAWING\n *\n * ===============================================================*/\n/**\n * \\page Drawing\n * This library was designed to be render backend agnostic so it does\n * not draw anything to screen. Instead all drawn shapes, widgets\n * are made of, are buffered into memory and make up a command queue.\n * Each frame therefore fills the command buffer with draw commands\n * that then need to be executed by the user and his own render backend.\n * After that the command buffer needs to be cleared and a new frame can be\n * started. It is probably important to note that the command buffer is the main\n * drawing API and the optional vertex buffer API only takes this format and\n * converts it into a hardware accessible format.\n *\n * To use the command queue to draw your own widgets you can access the\n * command buffer of each window by calling `nk_window_get_canvas` after\n * previously having called `nk_begin`:\n *\n * ```c\n *     void draw_red_rectangle_widget(struct nk_context *ctx)\n *     {\n *         struct nk_command_buffer *canvas;\n *         struct nk_input *input = &ctx->input;\n *         canvas = nk_window_get_canvas(ctx);\n *\n *         struct nk_rect space;\n *         enum nk_widget_layout_states state;\n *         state = nk_widget(&space, ctx);\n *         if (!state) return;\n *\n *         if (state != NK_WIDGET_ROM)\n *             update_your_widget_by_user_input(...);\n *         nk_fill_rect(canvas, space, 0, nk_rgb(255,0,0));\n *     }\n *\n *     if (nk_begin(...)) {\n *         nk_layout_row_dynamic(ctx, 25, 1);\n *         draw_red_rectangle_widget(ctx);\n *     }\n *     nk_end(..)\n *\n * ```\n * Important to know if you want to create your own widgets is the `nk_widget`\n * call. It allocates space on the panel reserved for this widget to be used,\n * but also returns the state of the widget space. If your widget is not seen and does\n * not have to be updated it is '0' and you can just return. If it only has\n * to be drawn the state will be `NK_WIDGET_ROM` otherwise you can do both\n * update and draw your widget. The reason for separating is to only draw and\n * update what is actually necessary which is crucial for performance.\n */\n\nenum nk_command_type {\n    NK_COMMAND_NOP,\n    NK_COMMAND_SCISSOR,\n    NK_COMMAND_LINE,\n    NK_COMMAND_CURVE,\n    NK_COMMAND_RECT,\n    NK_COMMAND_RECT_FILLED,\n    NK_COMMAND_RECT_MULTI_COLOR,\n    NK_COMMAND_CIRCLE,\n    NK_COMMAND_CIRCLE_FILLED,\n    NK_COMMAND_ARC,\n    NK_COMMAND_ARC_FILLED,\n    NK_COMMAND_TRIANGLE,\n    NK_COMMAND_TRIANGLE_FILLED,\n    NK_COMMAND_POLYGON,\n    NK_COMMAND_POLYGON_FILLED,\n    NK_COMMAND_POLYLINE,\n    NK_COMMAND_TEXT,\n    NK_COMMAND_IMAGE,\n    NK_COMMAND_CUSTOM\n};\n\n /** command base and header of every command inside the buffer */\nstruct nk_command {\n    enum nk_command_type type;\n    nk_size next;\n#ifdef NK_INCLUDE_COMMAND_USERDATA\n    nk_handle userdata;\n#endif\n};\n\nstruct nk_command_scissor {\n    struct nk_command header;\n    short x, y;\n    unsigned short w, h;\n};\n\nstruct nk_command_line {\n    struct nk_command header;\n    unsigned short line_thickness;\n    struct nk_vec2i begin;\n    struct nk_vec2i end;\n    struct nk_color color;\n};\n\nstruct nk_command_curve {\n    struct nk_command header;\n    unsigned short line_thickness;\n    struct nk_vec2i begin;\n    struct nk_vec2i end;\n    struct nk_vec2i ctrl[2];\n    struct nk_color color;\n};\n\nstruct nk_command_rect {\n    struct nk_command header;\n    unsigned short rounding;\n    unsigned short line_thickness;\n    short x, y;\n    unsigned short w, h;\n    struct nk_color color;\n};\n\nstruct nk_command_rect_filled {\n    struct nk_command header;\n    unsigned short rounding;\n    short x, y;\n    unsigned short w, h;\n    struct nk_color color;\n};\n\nstruct nk_command_rect_multi_color {\n    struct nk_command header;\n    short x, y;\n    unsigned short w, h;\n    struct nk_color left;\n    struct nk_color top;\n    struct nk_color bottom;\n    struct nk_color right;\n};\n\nstruct nk_command_triangle {\n    struct nk_command header;\n    unsigned short line_thickness;\n    struct nk_vec2i a;\n    struct nk_vec2i b;\n    struct nk_vec2i c;\n    struct nk_color color;\n};\n\nstruct nk_command_triangle_filled {\n    struct nk_command header;\n    struct nk_vec2i a;\n    struct nk_vec2i b;\n    struct nk_vec2i c;\n    struct nk_color color;\n};\n\nstruct nk_command_circle {\n    struct nk_command header;\n    short x, y;\n    unsigned short line_thickness;\n    unsigned short w, h;\n    struct nk_color color;\n};\n\nstruct nk_command_circle_filled {\n    struct nk_command header;\n    short x, y;\n    unsigned short w, h;\n    struct nk_color color;\n};\n\nstruct nk_command_arc {\n    struct nk_command header;\n    short cx, cy;\n    unsigned short r;\n    unsigned short line_thickness;\n    float a[2];\n    struct nk_color color;\n};\n\nstruct nk_command_arc_filled {\n    struct nk_command header;\n    short cx, cy;\n    unsigned short r;\n    float a[2];\n    struct nk_color color;\n};\n\nstruct nk_command_polygon {\n    struct nk_command header;\n    struct nk_color color;\n    unsigned short line_thickness;\n    unsigned short point_count;\n    struct nk_vec2i points[1];\n};\n\nstruct nk_command_polygon_filled {\n    struct nk_command header;\n    struct nk_color color;\n    unsigned short point_count;\n    struct nk_vec2i points[1];\n};\n\nstruct nk_command_polyline {\n    struct nk_command header;\n    struct nk_color color;\n    unsigned short line_thickness;\n    unsigned short point_count;\n    struct nk_vec2i points[1];\n};\n\nstruct nk_command_image {\n    struct nk_command header;\n    short x, y;\n    unsigned short w, h;\n    struct nk_image img;\n    struct nk_color col;\n};\n\ntypedef void (*nk_command_custom_callback)(void *canvas, short x,short y,\n    unsigned short w, unsigned short h, nk_handle callback_data);\nstruct nk_command_custom {\n    struct nk_command header;\n    short x, y;\n    unsigned short w, h;\n    nk_handle callback_data;\n    nk_command_custom_callback callback;\n};\n\nstruct nk_command_text {\n    struct nk_command header;\n    const struct nk_user_font *font;\n    struct nk_color background;\n    struct nk_color foreground;\n    short x, y;\n    unsigned short w, h;\n    float height;\n    int length;\n    char string[1];\n};\n\nenum nk_command_clipping {\n    NK_CLIPPING_OFF = nk_false,\n    NK_CLIPPING_ON = nk_true\n};\n\nstruct nk_command_buffer {\n    struct nk_buffer *base;\n    struct nk_rect clip;\n    int use_clipping;\n    nk_handle userdata;\n    nk_size begin, end, last;\n};\n\n/** shape outlines */\nNK_API void nk_stroke_line(struct nk_command_buffer *b, float x0, float y0, float x1, float y1, float line_thickness, struct nk_color);\nNK_API void nk_stroke_curve(struct nk_command_buffer*, float, float, float, float, float, float, float, float, float line_thickness, struct nk_color);\nNK_API void nk_stroke_rect(struct nk_command_buffer*, struct nk_rect, float rounding, float line_thickness, struct nk_color);\nNK_API void nk_stroke_circle(struct nk_command_buffer*, struct nk_rect, float line_thickness, struct nk_color);\nNK_API void nk_stroke_arc(struct nk_command_buffer*, float cx, float cy, float radius, float a_min, float a_max, float line_thickness, struct nk_color);\nNK_API void nk_stroke_triangle(struct nk_command_buffer*, float, float, float, float, float, float, float line_thichness, struct nk_color);\nNK_API void nk_stroke_polyline(struct nk_command_buffer*, const float *points, int point_count, float line_thickness, struct nk_color col);\nNK_API void nk_stroke_polygon(struct nk_command_buffer*, const float *points, int point_count, float line_thickness, struct nk_color);\n\n/** filled shades */\nNK_API void nk_fill_rect(struct nk_command_buffer*, struct nk_rect, float rounding, struct nk_color);\nNK_API void nk_fill_rect_multi_color(struct nk_command_buffer*, struct nk_rect, struct nk_color left, struct nk_color top, struct nk_color right, struct nk_color bottom);\nNK_API void nk_fill_circle(struct nk_command_buffer*, struct nk_rect, struct nk_color);\nNK_API void nk_fill_arc(struct nk_command_buffer*, float cx, float cy, float radius, float a_min, float a_max, struct nk_color);\nNK_API void nk_fill_triangle(struct nk_command_buffer*, float x0, float y0, float x1, float y1, float x2, float y2, struct nk_color);\nNK_API void nk_fill_polygon(struct nk_command_buffer*, const float *points, int point_count, struct nk_color);\n\n/** misc */\nNK_API void nk_draw_image(struct nk_command_buffer*, struct nk_rect, const struct nk_image*, struct nk_color);\nNK_API void nk_draw_nine_slice(struct nk_command_buffer*, struct nk_rect, const struct nk_nine_slice*, struct nk_color);\nNK_API void nk_draw_text(struct nk_command_buffer*, struct nk_rect, const char *text, int len, const struct nk_user_font*, struct nk_color, struct nk_color);\nNK_API void nk_push_scissor(struct nk_command_buffer*, struct nk_rect);\nNK_API void nk_push_custom(struct nk_command_buffer*, struct nk_rect, nk_command_custom_callback, nk_handle usr);\n\n/* ===============================================================\n *\n *                          INPUT\n *\n * ===============================================================*/\nstruct nk_mouse_button {\n    nk_bool down;\n    unsigned int clicked;\n    struct nk_vec2 clicked_pos;\n};\nstruct nk_mouse {\n    struct nk_mouse_button buttons[NK_BUTTON_MAX];\n    struct nk_vec2 pos;\n#ifdef NK_BUTTON_TRIGGER_ON_RELEASE\n    struct nk_vec2 down_pos;\n#endif\n    struct nk_vec2 prev;\n    struct nk_vec2 delta;\n    struct nk_vec2 scroll_delta;\n    unsigned char grab;\n    unsigned char grabbed;\n    unsigned char ungrab;\n};\n\nstruct nk_key {\n    nk_bool down;\n    unsigned int clicked;\n};\nstruct nk_keyboard {\n    struct nk_key keys[NK_KEY_MAX];\n    char text[NK_INPUT_MAX];\n    int text_len;\n};\n\nstruct nk_input {\n    struct nk_keyboard keyboard;\n    struct nk_mouse mouse;\n};\n\nNK_API nk_bool nk_input_has_mouse_click(const struct nk_input*, enum nk_buttons);\nNK_API nk_bool nk_input_has_mouse_click_in_rect(const struct nk_input*, enum nk_buttons, struct nk_rect);\nNK_API nk_bool nk_input_has_mouse_click_in_button_rect(const struct nk_input*, enum nk_buttons, struct nk_rect);\nNK_API nk_bool nk_input_has_mouse_click_down_in_rect(const struct nk_input*, enum nk_buttons, struct nk_rect, nk_bool down);\nNK_API nk_bool nk_input_is_mouse_click_in_rect(const struct nk_input*, enum nk_buttons, struct nk_rect);\nNK_API nk_bool nk_input_is_mouse_click_down_in_rect(const struct nk_input *i, enum nk_buttons id, struct nk_rect b, nk_bool down);\nNK_API nk_bool nk_input_any_mouse_click_in_rect(const struct nk_input*, struct nk_rect);\nNK_API nk_bool nk_input_is_mouse_prev_hovering_rect(const struct nk_input*, struct nk_rect);\nNK_API nk_bool nk_input_is_mouse_hovering_rect(const struct nk_input*, struct nk_rect);\nNK_API nk_bool nk_input_mouse_clicked(const struct nk_input*, enum nk_buttons, struct nk_rect);\nNK_API nk_bool nk_input_is_mouse_down(const struct nk_input*, enum nk_buttons);\nNK_API nk_bool nk_input_is_mouse_pressed(const struct nk_input*, enum nk_buttons);\nNK_API nk_bool nk_input_is_mouse_released(const struct nk_input*, enum nk_buttons);\nNK_API nk_bool nk_input_is_key_pressed(const struct nk_input*, enum nk_keys);\nNK_API nk_bool nk_input_is_key_released(const struct nk_input*, enum nk_keys);\nNK_API nk_bool nk_input_is_key_down(const struct nk_input*, enum nk_keys);\n\n/* ===============================================================\n *\n *                          DRAW LIST\n *\n * ===============================================================*/\n#ifdef NK_INCLUDE_VERTEX_BUFFER_OUTPUT\n/**\n * \\page \"Draw List\"\n * The optional vertex buffer draw list provides a 2D drawing context\n * with antialiasing functionality which takes basic filled or outlined shapes\n * or a path and outputs vertexes, elements and draw commands.\n * The actual draw list API is not required to be used directly while using this\n * library since converting the default library draw command output is done by\n * just calling `nk_convert` but I decided to still make this library accessible\n * since it can be useful.\n *\n * The draw list is based on a path buffering and polygon and polyline\n * rendering API which allows a lot of ways to draw 2D content to screen.\n * In fact it is probably more powerful than needed but allows even more crazy\n * things than this library provides by default.\n */\n\n#ifdef NK_UINT_DRAW_INDEX\ntypedef nk_uint nk_draw_index;\n#else\ntypedef nk_ushort nk_draw_index;\n#endif\nenum nk_draw_list_stroke {\n    NK_STROKE_OPEN = nk_false, /***< build up path has no connection back to the beginning */\n    NK_STROKE_CLOSED = nk_true /***< build up path has a connection back to the beginning */\n};\n\nenum nk_draw_vertex_layout_attribute {\n    NK_VERTEX_POSITION,\n    NK_VERTEX_COLOR,\n    NK_VERTEX_TEXCOORD,\n    NK_VERTEX_ATTRIBUTE_COUNT\n};\n\nenum nk_draw_vertex_layout_format {\n    NK_FORMAT_SCHAR,\n    NK_FORMAT_SSHORT,\n    NK_FORMAT_SINT,\n    NK_FORMAT_UCHAR,\n    NK_FORMAT_USHORT,\n    NK_FORMAT_UINT,\n    NK_FORMAT_FLOAT,\n    NK_FORMAT_DOUBLE,\n\nNK_FORMAT_COLOR_BEGIN,\n    NK_FORMAT_R8G8B8 = NK_FORMAT_COLOR_BEGIN,\n    NK_FORMAT_R16G15B16,\n    NK_FORMAT_R32G32B32,\n\n    NK_FORMAT_R8G8B8A8,\n    NK_FORMAT_B8G8R8A8,\n    NK_FORMAT_R16G15B16A16,\n    NK_FORMAT_R32G32B32A32,\n    NK_FORMAT_R32G32B32A32_FLOAT,\n    NK_FORMAT_R32G32B32A32_DOUBLE,\n\n    NK_FORMAT_RGB32,\n    NK_FORMAT_RGBA32,\nNK_FORMAT_COLOR_END = NK_FORMAT_RGBA32,\n    NK_FORMAT_COUNT\n};\n\n#define NK_VERTEX_LAYOUT_END NK_VERTEX_ATTRIBUTE_COUNT,NK_FORMAT_COUNT,0\nstruct nk_draw_vertex_layout_element {\n    enum nk_draw_vertex_layout_attribute attribute;\n    enum nk_draw_vertex_layout_format format;\n    nk_size offset;\n};\n\nstruct nk_draw_command {\n    unsigned int elem_count; /**< number of elements in the current draw batch */\n    struct nk_rect clip_rect; /**< current screen clipping rectangle */\n    nk_handle texture; /**< current texture to set */\n#ifdef NK_INCLUDE_COMMAND_USERDATA\n    nk_handle userdata;\n#endif\n};\n\nstruct nk_draw_list {\n    struct nk_rect clip_rect;\n    struct nk_vec2 circle_vtx[12];\n    struct nk_convert_config config;\n\n    struct nk_buffer *buffer;\n    struct nk_buffer *vertices;\n    struct nk_buffer *elements;\n\n    unsigned int element_count;\n    unsigned int vertex_count;\n    unsigned int cmd_count;\n    nk_size cmd_offset;\n\n    unsigned int path_count;\n    unsigned int path_offset;\n\n    enum nk_anti_aliasing line_AA;\n    enum nk_anti_aliasing shape_AA;\n\n#ifdef NK_INCLUDE_COMMAND_USERDATA\n    nk_handle userdata;\n#endif\n};\n\n/* draw list */\nNK_API void nk_draw_list_init(struct nk_draw_list*);\nNK_API void nk_draw_list_setup(struct nk_draw_list*, const struct nk_convert_config*, struct nk_buffer *cmds, struct nk_buffer *vertices, struct nk_buffer *elements, enum nk_anti_aliasing line_aa,enum nk_anti_aliasing shape_aa);\n\n/* drawing */\n#define nk_draw_list_foreach(cmd, can, b) for((cmd)=nk__draw_list_begin(can, b); (cmd)!=0; (cmd)=nk__draw_list_next(cmd, b, can))\nNK_API const struct nk_draw_command* nk__draw_list_begin(const struct nk_draw_list*, const struct nk_buffer*);\nNK_API const struct nk_draw_command* nk__draw_list_next(const struct nk_draw_command*, const struct nk_buffer*, const struct nk_draw_list*);\nNK_API const struct nk_draw_command* nk__draw_list_end(const struct nk_draw_list*, const struct nk_buffer*);\n\n/* path */\nNK_API void nk_draw_list_path_clear(struct nk_draw_list*);\nNK_API void nk_draw_list_path_line_to(struct nk_draw_list*, struct nk_vec2 pos);\nNK_API void nk_draw_list_path_arc_to_fast(struct nk_draw_list*, struct nk_vec2 center, float radius, int a_min, int a_max);\nNK_API void nk_draw_list_path_arc_to(struct nk_draw_list*, struct nk_vec2 center, float radius, float a_min, float a_max, unsigned int segments);\nNK_API void nk_draw_list_path_rect_to(struct nk_draw_list*, struct nk_vec2 a, struct nk_vec2 b, float rounding);\nNK_API void nk_draw_list_path_curve_to(struct nk_draw_list*, struct nk_vec2 p2, struct nk_vec2 p3, struct nk_vec2 p4, unsigned int num_segments);\nNK_API void nk_draw_list_path_fill(struct nk_draw_list*, struct nk_color);\nNK_API void nk_draw_list_path_stroke(struct nk_draw_list*, struct nk_color, enum nk_draw_list_stroke closed, float thickness);\n\n/* stroke */\nNK_API void nk_draw_list_stroke_line(struct nk_draw_list*, struct nk_vec2 a, struct nk_vec2 b, struct nk_color, float thickness);\nNK_API void nk_draw_list_stroke_rect(struct nk_draw_list*, struct nk_rect rect, struct nk_color, float rounding, float thickness);\nNK_API void nk_draw_list_stroke_triangle(struct nk_draw_list*, struct nk_vec2 a, struct nk_vec2 b, struct nk_vec2 c, struct nk_color, float thickness);\nNK_API void nk_draw_list_stroke_circle(struct nk_draw_list*, struct nk_vec2 center, float radius, struct nk_color, unsigned int segs, float thickness);\nNK_API void nk_draw_list_stroke_curve(struct nk_draw_list*, struct nk_vec2 p0, struct nk_vec2 cp0, struct nk_vec2 cp1, struct nk_vec2 p1, struct nk_color, unsigned int segments, float thickness);\nNK_API void nk_draw_list_stroke_poly_line(struct nk_draw_list*, const struct nk_vec2 *pnts, const unsigned int cnt, struct nk_color, enum nk_draw_list_stroke, float thickness, enum nk_anti_aliasing);\n\n/* fill */\nNK_API void nk_draw_list_fill_rect(struct nk_draw_list*, struct nk_rect rect, struct nk_color, float rounding);\nNK_API void nk_draw_list_fill_rect_multi_color(struct nk_draw_list*, struct nk_rect rect, struct nk_color left, struct nk_color top, struct nk_color right, struct nk_color bottom);\nNK_API void nk_draw_list_fill_triangle(struct nk_draw_list*, struct nk_vec2 a, struct nk_vec2 b, struct nk_vec2 c, struct nk_color);\nNK_API void nk_draw_list_fill_circle(struct nk_draw_list*, struct nk_vec2 center, float radius, struct nk_color col, unsigned int segs);\nNK_API void nk_draw_list_fill_poly_convex(struct nk_draw_list*, const struct nk_vec2 *points, const unsigned int count, struct nk_color, enum nk_anti_aliasing);\n\n/* misc */\nNK_API void nk_draw_list_add_image(struct nk_draw_list*, struct nk_image texture, struct nk_rect rect, struct nk_color);\nNK_API void nk_draw_list_add_text(struct nk_draw_list*, const struct nk_user_font*, struct nk_rect, const char *text, int len, float font_height, struct nk_color);\n#ifdef NK_INCLUDE_COMMAND_USERDATA\nNK_API void nk_draw_list_push_userdata(struct nk_draw_list*, nk_handle userdata);\n#endif\n\n#endif\n\n/* ===============================================================\n *\n *                          GUI\n *\n * ===============================================================*/\nenum nk_style_item_type {\n    NK_STYLE_ITEM_COLOR,\n    NK_STYLE_ITEM_IMAGE,\n    NK_STYLE_ITEM_NINE_SLICE\n};\n\nunion nk_style_item_data {\n    struct nk_color color;\n    struct nk_image image;\n    struct nk_nine_slice slice;\n};\n\nstruct nk_style_item {\n    enum nk_style_item_type type;\n    union nk_style_item_data data;\n};\n\nstruct nk_style_text {\n    struct nk_color color;\n    struct nk_vec2 padding;\n    float color_factor;\n    float disabled_factor;\n};\n\nstruct nk_style_button {\n    /* background */\n    struct nk_style_item normal;\n    struct nk_style_item hover;\n    struct nk_style_item active;\n    struct nk_color border_color;\n    float color_factor_background;\n\n    /* text */\n    struct nk_color text_background;\n    struct nk_color text_normal;\n    struct nk_color text_hover;\n    struct nk_color text_active;\n    nk_flags text_alignment;\n    float color_factor_text;\n\n    /* properties */\n    float border;\n    float rounding;\n    struct nk_vec2 padding;\n    struct nk_vec2 image_padding;\n    struct nk_vec2 touch_padding;\n    float disabled_factor;\n\n    /* optional user callbacks */\n    nk_handle userdata;\n    void(*draw_begin)(struct nk_command_buffer*, nk_handle userdata);\n    void(*draw_end)(struct nk_command_buffer*, nk_handle userdata);\n};\n\nstruct nk_style_toggle {\n    /* background */\n    struct nk_style_item normal;\n    struct nk_style_item hover;\n    struct nk_style_item active;\n    struct nk_color border_color;\n\n    /* cursor */\n    struct nk_style_item cursor_normal;\n    struct nk_style_item cursor_hover;\n\n    /* text */\n    struct nk_color text_normal;\n    struct nk_color text_hover;\n    struct nk_color text_active;\n    struct nk_color text_background;\n    nk_flags text_alignment;\n\n    /* properties */\n    struct nk_vec2 padding;\n    struct nk_vec2 touch_padding;\n    float spacing;\n    float border;\n    float color_factor;\n    float disabled_factor;\n\n    /* optional user callbacks */\n    nk_handle userdata;\n    void(*draw_begin)(struct nk_command_buffer*, nk_handle);\n    void(*draw_end)(struct nk_command_buffer*, nk_handle);\n};\n\nstruct nk_style_selectable {\n    /* background (inactive) */\n    struct nk_style_item normal;\n    struct nk_style_item hover;\n    struct nk_style_item pressed;\n\n    /* background (active) */\n    struct nk_style_item normal_active;\n    struct nk_style_item hover_active;\n    struct nk_style_item pressed_active;\n\n    /* text color (inactive) */\n    struct nk_color text_normal;\n    struct nk_color text_hover;\n    struct nk_color text_pressed;\n\n    /* text color (active) */\n    struct nk_color text_normal_active;\n    struct nk_color text_hover_active;\n    struct nk_color text_pressed_active;\n    struct nk_color text_background;\n    nk_flags text_alignment;\n\n    /* properties */\n    float rounding;\n    struct nk_vec2 padding;\n    struct nk_vec2 touch_padding;\n    struct nk_vec2 image_padding;\n    float color_factor;\n    float disabled_factor;\n\n    /* optional user callbacks */\n    nk_handle userdata;\n    void(*draw_begin)(struct nk_command_buffer*, nk_handle);\n    void(*draw_end)(struct nk_command_buffer*, nk_handle);\n};\n\nstruct nk_style_slider {\n    /* background */\n    struct nk_style_item normal;\n    struct nk_style_item hover;\n    struct nk_style_item active;\n    struct nk_color border_color;\n\n    /* background bar */\n    struct nk_color bar_normal;\n    struct nk_color bar_hover;\n    struct nk_color bar_active;\n    struct nk_color bar_filled;\n\n    /* cursor */\n    struct nk_style_item cursor_normal;\n    struct nk_style_item cursor_hover;\n    struct nk_style_item cursor_active;\n\n    /* properties */\n    float border;\n    float rounding;\n    float bar_height;\n    struct nk_vec2 padding;\n    struct nk_vec2 spacing;\n    struct nk_vec2 cursor_size;\n    float color_factor;\n    float disabled_factor;\n\n    /* optional buttons */\n    int show_buttons;\n    struct nk_style_button inc_button;\n    struct nk_style_button dec_button;\n    enum nk_symbol_type inc_symbol;\n    enum nk_symbol_type dec_symbol;\n\n    /* optional user callbacks */\n    nk_handle userdata;\n    void(*draw_begin)(struct nk_command_buffer*, nk_handle);\n    void(*draw_end)(struct nk_command_buffer*, nk_handle);\n};\n\nstruct nk_style_knob {\n    /* background */\n    struct nk_style_item normal;\n    struct nk_style_item hover;\n    struct nk_style_item active;\n    struct nk_color border_color;\n\n    /* knob */\n    struct nk_color knob_normal;\n    struct nk_color knob_hover;\n    struct nk_color knob_active;\n    struct nk_color knob_border_color;\n\n    /* cursor */\n    struct nk_color cursor_normal;\n    struct nk_color cursor_hover;\n    struct nk_color cursor_active;\n\n    /* properties */\n    float border;\n    float knob_border;\n    struct nk_vec2 padding;\n    struct nk_vec2 spacing;\n    float cursor_width;\n    float color_factor;\n    float disabled_factor;\n\n    /* optional user callbacks */\n    nk_handle userdata;\n    void(*draw_begin)(struct nk_command_buffer*, nk_handle);\n    void(*draw_end)(struct nk_command_buffer*, nk_handle);\n};\n\nstruct nk_style_progress {\n    /* background */\n    struct nk_style_item normal;\n    struct nk_style_item hover;\n    struct nk_style_item active;\n    struct nk_color border_color;\n\n    /* cursor */\n    struct nk_style_item cursor_normal;\n    struct nk_style_item cursor_hover;\n    struct nk_style_item cursor_active;\n    struct nk_color cursor_border_color;\n\n    /* properties */\n    float rounding;\n    float border;\n    float cursor_border;\n    float cursor_rounding;\n    struct nk_vec2 padding;\n    float color_factor;\n    float disabled_factor;\n\n    /* optional user callbacks */\n    nk_handle userdata;\n    void(*draw_begin)(struct nk_command_buffer*, nk_handle);\n    void(*draw_end)(struct nk_command_buffer*, nk_handle);\n};\n\nstruct nk_style_scrollbar {\n    /* background */\n    struct nk_style_item normal;\n    struct nk_style_item hover;\n    struct nk_style_item active;\n    struct nk_color border_color;\n\n    /* cursor */\n    struct nk_style_item cursor_normal;\n    struct nk_style_item cursor_hover;\n    struct nk_style_item cursor_active;\n    struct nk_color cursor_border_color;\n\n    /* properties */\n    float border;\n    float rounding;\n    float border_cursor;\n    float rounding_cursor;\n    struct nk_vec2 padding;\n    float color_factor;\n    float disabled_factor;\n\n    /* optional buttons */\n    int show_buttons;\n    struct nk_style_button inc_button;\n    struct nk_style_button dec_button;\n    enum nk_symbol_type inc_symbol;\n    enum nk_symbol_type dec_symbol;\n\n    /* optional user callbacks */\n    nk_handle userdata;\n    void(*draw_begin)(struct nk_command_buffer*, nk_handle);\n    void(*draw_end)(struct nk_command_buffer*, nk_handle);\n};\n\nstruct nk_style_edit {\n    /* background */\n    struct nk_style_item normal;\n    struct nk_style_item hover;\n    struct nk_style_item active;\n    struct nk_color border_color;\n    struct nk_style_scrollbar scrollbar;\n\n    /* cursor  */\n    struct nk_color cursor_normal;\n    struct nk_color cursor_hover;\n    struct nk_color cursor_text_normal;\n    struct nk_color cursor_text_hover;\n\n    /* text (unselected) */\n    struct nk_color text_normal;\n    struct nk_color text_hover;\n    struct nk_color text_active;\n\n    /* text (selected) */\n    struct nk_color selected_normal;\n    struct nk_color selected_hover;\n    struct nk_color selected_text_normal;\n    struct nk_color selected_text_hover;\n\n    /* properties */\n    float border;\n    float rounding;\n    float cursor_size;\n    struct nk_vec2 scrollbar_size;\n    struct nk_vec2 padding;\n    float row_padding;\n    float color_factor;\n    float disabled_factor;\n};\n\nstruct nk_style_property {\n    /* background */\n    struct nk_style_item normal;\n    struct nk_style_item hover;\n    struct nk_style_item active;\n    struct nk_color border_color;\n\n    /* text */\n    struct nk_color label_normal;\n    struct nk_color label_hover;\n    struct nk_color label_active;\n\n    /* symbols */\n    enum nk_symbol_type sym_left;\n    enum nk_symbol_type sym_right;\n\n    /* properties */\n    float border;\n    float rounding;\n    struct nk_vec2 padding;\n    float color_factor;\n    float disabled_factor;\n\n    struct nk_style_edit edit;\n    struct nk_style_button inc_button;\n    struct nk_style_button dec_button;\n\n    /* optional user callbacks */\n    nk_handle userdata;\n    void(*draw_begin)(struct nk_command_buffer*, nk_handle);\n    void(*draw_end)(struct nk_command_buffer*, nk_handle);\n};\n\nstruct nk_style_chart {\n    /* colors */\n    struct nk_style_item background;\n    struct nk_color border_color;\n    struct nk_color selected_color;\n    struct nk_color color;\n\n    /* properties */\n    float border;\n    float rounding;\n    struct nk_vec2 padding;\n    float color_factor;\n    float disabled_factor;\n    nk_bool show_markers;\n};\n\nstruct nk_style_combo {\n    /* background */\n    struct nk_style_item normal;\n    struct nk_style_item hover;\n    struct nk_style_item active;\n    struct nk_color border_color;\n\n    /* label */\n    struct nk_color label_normal;\n    struct nk_color label_hover;\n    struct nk_color label_active;\n\n    /* symbol */\n    struct nk_color symbol_normal;\n    struct nk_color symbol_hover;\n    struct nk_color symbol_active;\n\n    /* button */\n    struct nk_style_button button;\n    enum nk_symbol_type sym_normal;\n    enum nk_symbol_type sym_hover;\n    enum nk_symbol_type sym_active;\n\n    /* properties */\n    float border;\n    float rounding;\n    struct nk_vec2 content_padding;\n    struct nk_vec2 button_padding;\n    struct nk_vec2 spacing;\n    float color_factor;\n    float disabled_factor;\n};\n\nstruct nk_style_tab {\n    /* background */\n    struct nk_style_item background;\n    struct nk_color border_color;\n    struct nk_color text;\n\n    /* button */\n    struct nk_style_button tab_maximize_button;\n    struct nk_style_button tab_minimize_button;\n    struct nk_style_button node_maximize_button;\n    struct nk_style_button node_minimize_button;\n    enum nk_symbol_type sym_minimize;\n    enum nk_symbol_type sym_maximize;\n\n    /* properties */\n    float border;\n    float rounding;\n    float indent;\n    struct nk_vec2 padding;\n    struct nk_vec2 spacing;\n    float color_factor;\n    float disabled_factor;\n};\n\nenum nk_style_header_align {\n    NK_HEADER_LEFT,\n    NK_HEADER_RIGHT\n};\nstruct nk_style_window_header {\n    /* background */\n    struct nk_style_item normal;\n    struct nk_style_item hover;\n    struct nk_style_item active;\n\n    /* button */\n    struct nk_style_button close_button;\n    struct nk_style_button minimize_button;\n    enum nk_symbol_type close_symbol;\n    enum nk_symbol_type minimize_symbol;\n    enum nk_symbol_type maximize_symbol;\n\n    /* title */\n    struct nk_color label_normal;\n    struct nk_color label_hover;\n    struct nk_color label_active;\n\n    /* properties */\n    enum nk_style_header_align align;\n    struct nk_vec2 padding;\n    struct nk_vec2 label_padding;\n    struct nk_vec2 spacing;\n};\n\nstruct nk_style_window {\n    struct nk_style_window_header header;\n    struct nk_style_item fixed_background;\n    struct nk_color background;\n\n    struct nk_color border_color;\n    struct nk_color popup_border_color;\n    struct nk_color combo_border_color;\n    struct nk_color contextual_border_color;\n    struct nk_color menu_border_color;\n    struct nk_color group_border_color;\n    struct nk_color tooltip_border_color;\n    struct nk_style_item scaler;\n\n    float border;\n    float combo_border;\n    float contextual_border;\n    float menu_border;\n    float group_border;\n    float tooltip_border;\n    float popup_border;\n    float min_row_height_padding;\n\n    float rounding;\n    struct nk_vec2 spacing;\n    struct nk_vec2 scrollbar_size;\n    struct nk_vec2 min_size;\n\n    struct nk_vec2 padding;\n    struct nk_vec2 group_padding;\n    struct nk_vec2 popup_padding;\n    struct nk_vec2 combo_padding;\n    struct nk_vec2 contextual_padding;\n    struct nk_vec2 menu_padding;\n    struct nk_vec2 tooltip_padding;\n};\n\nstruct nk_style {\n    const struct nk_user_font *font;\n    const struct nk_cursor *cursors[NK_CURSOR_COUNT];\n    const struct nk_cursor *cursor_active;\n    struct nk_cursor *cursor_last;\n    int cursor_visible;\n\n    struct nk_style_text text;\n    struct nk_style_button button;\n    struct nk_style_button contextual_button;\n    struct nk_style_button menu_button;\n    struct nk_style_toggle option;\n    struct nk_style_toggle checkbox;\n    struct nk_style_selectable selectable;\n    struct nk_style_slider slider;\n    struct nk_style_knob knob;\n    struct nk_style_progress progress;\n    struct nk_style_property property;\n    struct nk_style_edit edit;\n    struct nk_style_chart chart;\n    struct nk_style_scrollbar scrollh;\n    struct nk_style_scrollbar scrollv;\n    struct nk_style_tab tab;\n    struct nk_style_combo combo;\n    struct nk_style_window window;\n};\n\nNK_API struct nk_style_item nk_style_item_color(struct nk_color);\nNK_API struct nk_style_item nk_style_item_image(struct nk_image img);\nNK_API struct nk_style_item nk_style_item_nine_slice(struct nk_nine_slice slice);\nNK_API struct nk_style_item nk_style_item_hide(void);\n\n/*==============================================================\n *                          PANEL\n * =============================================================*/\n#ifndef NK_MAX_LAYOUT_ROW_TEMPLATE_COLUMNS\n#define NK_MAX_LAYOUT_ROW_TEMPLATE_COLUMNS 16\n#endif\n#ifndef NK_CHART_MAX_SLOT\n#define NK_CHART_MAX_SLOT 4\n#endif\n\nenum nk_panel_type {\n    NK_PANEL_NONE       = 0,\n    NK_PANEL_WINDOW     = NK_FLAG(0),\n    NK_PANEL_GROUP      = NK_FLAG(1),\n    NK_PANEL_POPUP      = NK_FLAG(2),\n    NK_PANEL_CONTEXTUAL = NK_FLAG(4),\n    NK_PANEL_COMBO      = NK_FLAG(5),\n    NK_PANEL_MENU       = NK_FLAG(6),\n    NK_PANEL_TOOLTIP    = NK_FLAG(7)\n};\nenum nk_panel_set {\n    NK_PANEL_SET_NONBLOCK = NK_PANEL_CONTEXTUAL|NK_PANEL_COMBO|NK_PANEL_MENU|NK_PANEL_TOOLTIP,\n    NK_PANEL_SET_POPUP = NK_PANEL_SET_NONBLOCK|NK_PANEL_POPUP,\n    NK_PANEL_SET_SUB = NK_PANEL_SET_POPUP|NK_PANEL_GROUP\n};\n\nstruct nk_chart_slot {\n    enum nk_chart_type type;\n    struct nk_color color;\n    struct nk_color highlight;\n    float min, max, range;\n    int count;\n    struct nk_vec2 last;\n    int index;\n    nk_bool show_markers;\n};\n\nstruct nk_chart {\n    int slot;\n    float x, y, w, h;\n    struct nk_chart_slot slots[NK_CHART_MAX_SLOT];\n};\n\nenum nk_panel_row_layout_type {\n    NK_LAYOUT_DYNAMIC_FIXED = 0,\n    NK_LAYOUT_DYNAMIC_ROW,\n    NK_LAYOUT_DYNAMIC_FREE,\n    NK_LAYOUT_DYNAMIC,\n    NK_LAYOUT_STATIC_FIXED,\n    NK_LAYOUT_STATIC_ROW,\n    NK_LAYOUT_STATIC_FREE,\n    NK_LAYOUT_STATIC,\n    NK_LAYOUT_TEMPLATE,\n    NK_LAYOUT_COUNT\n};\nstruct nk_row_layout {\n    enum nk_panel_row_layout_type type;\n    int index;\n    float height;\n    float min_height;\n    int columns;\n    const float *ratio;\n    float item_width;\n    float item_height;\n    float item_offset;\n    float filled;\n    struct nk_rect item;\n    int tree_depth;\n    float templates[NK_MAX_LAYOUT_ROW_TEMPLATE_COLUMNS];\n};\n\nstruct nk_popup_buffer {\n    nk_size begin;\n    nk_size parent;\n    nk_size last;\n    nk_size end;\n    nk_bool active;\n};\n\nstruct nk_menu_state {\n    float x, y, w, h;\n    struct nk_scroll offset;\n};\n\nstruct nk_panel {\n    enum nk_panel_type type;\n    nk_flags flags;\n    struct nk_rect bounds;\n    nk_uint *offset_x;\n    nk_uint *offset_y;\n    float at_x, at_y, max_x;\n    float footer_height;\n    float header_height;\n    float border;\n    unsigned int has_scrolling;\n    struct nk_rect clip;\n    struct nk_menu_state menu;\n    struct nk_row_layout row;\n    struct nk_chart chart;\n    struct nk_command_buffer *buffer;\n    struct nk_panel *parent;\n};\n\n/*==============================================================\n *                          WINDOW\n * =============================================================*/\n#ifndef NK_WINDOW_MAX_NAME\n#define NK_WINDOW_MAX_NAME 64\n#endif\n\nstruct nk_table;\nenum nk_window_flags {\n    NK_WINDOW_PRIVATE       = NK_FLAG(11),\n    NK_WINDOW_DYNAMIC       = NK_WINDOW_PRIVATE,                  /**< special window type growing up in height while being filled to a certain maximum height */\n    NK_WINDOW_ROM           = NK_FLAG(12),                        /**< sets window widgets into a read only mode and does not allow input changes */\n    NK_WINDOW_NOT_INTERACTIVE = NK_WINDOW_ROM|NK_WINDOW_NO_INPUT, /**< prevents all interaction caused by input to either window or widgets inside */\n    NK_WINDOW_HIDDEN        = NK_FLAG(13),                        /**< Hides window and stops any window interaction and drawing */\n    NK_WINDOW_CLOSED        = NK_FLAG(14),                        /**< Directly closes and frees the window at the end of the frame */\n    NK_WINDOW_MINIMIZED     = NK_FLAG(15),                        /**< marks the window as minimized */\n    NK_WINDOW_REMOVE_ROM    = NK_FLAG(16)                         /**< Removes read only mode at the end of the window */\n};\n\nstruct nk_popup_state {\n    struct nk_window *win;\n    enum nk_panel_type type;\n    struct nk_popup_buffer buf;\n    nk_hash name;\n    nk_bool active;\n    unsigned combo_count;\n    unsigned con_count, con_old;\n    unsigned active_con;\n    struct nk_rect header;\n};\n\nstruct nk_edit_state {\n    nk_hash name;\n    unsigned int seq;\n    unsigned int old;\n    int active, prev;\n    int cursor;\n    int sel_start;\n    int sel_end;\n    struct nk_scroll scrollbar;\n    unsigned char mode;\n    unsigned char single_line;\n};\n\nstruct nk_property_state {\n    int active, prev;\n    char buffer[NK_MAX_NUMBER_BUFFER];\n    int length;\n    int cursor;\n    int select_start;\n    int select_end;\n    nk_hash name;\n    unsigned int seq;\n    unsigned int old;\n    int state;\n};\n\nstruct nk_window {\n    unsigned int seq;\n    nk_hash name;\n    char name_string[NK_WINDOW_MAX_NAME];\n    nk_flags flags;\n\n    struct nk_rect bounds;\n    struct nk_scroll scrollbar;\n    struct nk_command_buffer buffer;\n    struct nk_panel *layout;\n    float scrollbar_hiding_timer;\n\n    /* persistent widget state */\n    struct nk_property_state property;\n    struct nk_popup_state popup;\n    struct nk_edit_state edit;\n    unsigned int scrolled;\n    nk_bool widgets_disabled;\n\n    struct nk_table *tables;\n    unsigned int table_count;\n\n    /* window list hooks */\n    struct nk_window *next;\n    struct nk_window *prev;\n    struct nk_window *parent;\n};\n\n/*==============================================================\n *                          STACK\n * =============================================================*/\n/**\n * \\page Stack\n * # Stack\n * The style modifier stack can be used to temporarily change a\n * property inside `nk_style`. For example if you want a special\n * red button you can temporarily push the old button color onto a stack\n * draw the button with a red color and then you just pop the old color\n * back from the stack:\n *\n *     nk_style_push_style_item(ctx, &ctx->style.button.normal, nk_style_item_color(nk_rgb(255,0,0)));\n *     nk_style_push_style_item(ctx, &ctx->style.button.hover, nk_style_item_color(nk_rgb(255,0,0)));\n *     nk_style_push_style_item(ctx, &ctx->style.button.active, nk_style_item_color(nk_rgb(255,0,0)));\n *     nk_style_push_vec2(ctx, &cx->style.button.padding, nk_vec2(2,2));\n *\n *     nk_button(...);\n *\n *     nk_style_pop_style_item(ctx);\n *     nk_style_pop_style_item(ctx);\n *     nk_style_pop_style_item(ctx);\n *     nk_style_pop_vec2(ctx);\n *\n * Nuklear has a stack for style_items, float properties, vector properties,\n * flags, colors, fonts and for button_behavior. Each has it's own fixed size stack\n * which can be changed at compile time.\n */\n\n#ifndef NK_BUTTON_BEHAVIOR_STACK_SIZE\n#define NK_BUTTON_BEHAVIOR_STACK_SIZE 8\n#endif\n\n#ifndef NK_FONT_STACK_SIZE\n#define NK_FONT_STACK_SIZE 8\n#endif\n\n#ifndef NK_STYLE_ITEM_STACK_SIZE\n#define NK_STYLE_ITEM_STACK_SIZE 16\n#endif\n\n#ifndef NK_FLOAT_STACK_SIZE\n#define NK_FLOAT_STACK_SIZE 32\n#endif\n\n#ifndef NK_VECTOR_STACK_SIZE\n#define NK_VECTOR_STACK_SIZE 16\n#endif\n\n#ifndef NK_FLAGS_STACK_SIZE\n#define NK_FLAGS_STACK_SIZE 32\n#endif\n\n#ifndef NK_COLOR_STACK_SIZE\n#define NK_COLOR_STACK_SIZE 32\n#endif\n\n#define NK_CONFIGURATION_STACK_TYPE(prefix, name, type)\\\n    struct nk_config_stack_##name##_element {\\\n        prefix##_##type *address;\\\n        prefix##_##type old_value;\\\n    }\n#define NK_CONFIG_STACK(type,size)\\\n    struct nk_config_stack_##type {\\\n        int head;\\\n        struct nk_config_stack_##type##_element elements[size];\\\n    }\n\n#define nk_float float\nNK_CONFIGURATION_STACK_TYPE(struct nk, style_item, style_item);\nNK_CONFIGURATION_STACK_TYPE(nk ,float, float);\nNK_CONFIGURATION_STACK_TYPE(struct nk, vec2, vec2);\nNK_CONFIGURATION_STACK_TYPE(nk ,flags, flags);\nNK_CONFIGURATION_STACK_TYPE(struct nk, color, color);\nNK_CONFIGURATION_STACK_TYPE(const struct nk, user_font, user_font*);\nNK_CONFIGURATION_STACK_TYPE(enum nk, button_behavior, button_behavior);\n\nNK_CONFIG_STACK(style_item, NK_STYLE_ITEM_STACK_SIZE);\nNK_CONFIG_STACK(float, NK_FLOAT_STACK_SIZE);\nNK_CONFIG_STACK(vec2, NK_VECTOR_STACK_SIZE);\nNK_CONFIG_STACK(flags, NK_FLAGS_STACK_SIZE);\nNK_CONFIG_STACK(color, NK_COLOR_STACK_SIZE);\nNK_CONFIG_STACK(user_font, NK_FONT_STACK_SIZE);\nNK_CONFIG_STACK(button_behavior, NK_BUTTON_BEHAVIOR_STACK_SIZE);\n\nstruct nk_configuration_stacks {\n    struct nk_config_stack_style_item style_items;\n    struct nk_config_stack_float floats;\n    struct nk_config_stack_vec2 vectors;\n    struct nk_config_stack_flags flags;\n    struct nk_config_stack_color colors;\n    struct nk_config_stack_user_font fonts;\n    struct nk_config_stack_button_behavior button_behaviors;\n};\n\n/*==============================================================\n *                          CONTEXT\n * =============================================================*/\n#define NK_VALUE_PAGE_CAPACITY \\\n    (((NK_MAX(sizeof(struct nk_window),sizeof(struct nk_panel)) / sizeof(nk_uint))) / 2)\n\nstruct nk_table {\n    unsigned int seq;\n    unsigned int size;\n    nk_hash keys[NK_VALUE_PAGE_CAPACITY];\n    nk_uint values[NK_VALUE_PAGE_CAPACITY];\n    struct nk_table *next, *prev;\n};\n\nunion nk_page_data {\n    struct nk_table tbl;\n    struct nk_panel pan;\n    struct nk_window win;\n};\n\nstruct nk_page_element {\n    union nk_page_data data;\n    struct nk_page_element *next;\n    struct nk_page_element *prev;\n};\n\nstruct nk_page {\n    unsigned int size;\n    struct nk_page *next;\n    struct nk_page_element win[1];\n};\n\nstruct nk_pool {\n    struct nk_allocator alloc;\n    enum nk_allocation_type type;\n    unsigned int page_count;\n    struct nk_page *pages;\n    struct nk_page_element *freelist;\n    unsigned capacity;\n    nk_size size;\n    nk_size cap;\n};\n\nstruct nk_context {\n/* public: can be accessed freely */\n    struct nk_input input;\n    struct nk_style style;\n    struct nk_buffer memory;\n    struct nk_clipboard clip;\n    nk_flags last_widget_state;\n    enum nk_button_behavior button_behavior;\n    struct nk_configuration_stacks stacks;\n    float delta_time_seconds;\n\n/* private:\n    should only be accessed if you\n    know what you are doing */\n#ifdef NK_INCLUDE_VERTEX_BUFFER_OUTPUT\n    struct nk_draw_list draw_list;\n#endif\n#ifdef NK_INCLUDE_COMMAND_USERDATA\n    nk_handle userdata;\n#endif\n    /** text editor objects are quite big because of an internal\n     * undo/redo stack. Therefore it does not make sense to have one for\n     * each window for temporary use cases, so I only provide *one* instance\n     * for all windows. This works because the content is cleared anyway */\n    struct nk_text_edit text_edit;\n    /** draw buffer used for overlay drawing operation like cursor */\n    struct nk_command_buffer overlay;\n\n    /** windows */\n    int build;\n    int use_pool;\n    struct nk_pool pool;\n    struct nk_window *begin;\n    struct nk_window *end;\n    struct nk_window *active;\n    struct nk_window *current;\n    struct nk_page_element *freelist;\n    unsigned int count;\n    unsigned int seq;\n};\n\n/* ==============================================================\n *                          MATH\n * =============================================================== */\n#define NK_PI 3.141592654f\n#define NK_PI_HALF 1.570796326f\n#define NK_UTF_INVALID 0xFFFD\n#define NK_MAX_FLOAT_PRECISION 2\n\n#define NK_UNUSED(x) ((void)(x))\n#define NK_SATURATE(x) (NK_MAX(0, NK_MIN(1.0f, x)))\n#define NK_LEN(a) (sizeof(a)/sizeof(a)[0])\n#define NK_ABS(a) (((a) < 0) ? -(a) : (a))\n#define NK_BETWEEN(x, a, b) ((a) <= (x) && (x) < (b))\n#define NK_INBOX(px, py, x, y, w, h)\\\n    (NK_BETWEEN(px,x,x+w) && NK_BETWEEN(py,y,y+h))\n#define NK_INTERSECT(x0, y0, w0, h0, x1, y1, w1, h1) \\\n    ((x1 < (x0 + w0)) && (x0 < (x1 + w1)) && \\\n    (y1 < (y0 + h0)) && (y0 < (y1 + h1)))\n#define NK_CONTAINS(x, y, w, h, bx, by, bw, bh)\\\n    (NK_INBOX(x,y, bx, by, bw, bh) && NK_INBOX(x+w,y+h, bx, by, bw, bh))\n\n#define nk_vec2_sub(a, b) nk_vec2((a).x - (b).x, (a).y - (b).y)\n#define nk_vec2_add(a, b) nk_vec2((a).x + (b).x, (a).y + (b).y)\n#define nk_vec2_len_sqr(a) ((a).x*(a).x+(a).y*(a).y)\n#define nk_vec2_muls(a, t) nk_vec2((a).x * (t), (a).y * (t))\n\n#define nk_ptr_add(t, p, i) ((t*)((void*)((nk_byte*)(p) + (i))))\n#define nk_ptr_add_const(t, p, i) ((const t*)((const void*)((const nk_byte*)(p) + (i))))\n#define nk_zero_struct(s) nk_zero(&s, sizeof(s))\n\n/* ==============================================================\n *                          ALIGNMENT\n * =============================================================== */\n/* Pointer to Integer type conversion for pointer alignment */\n#if defined(__PTRDIFF_TYPE__) /* This case should work for GCC*/\n# define NK_UINT_TO_PTR(x) ((void*)(__PTRDIFF_TYPE__)(x))\n# define NK_PTR_TO_UINT(x) ((nk_size)(__PTRDIFF_TYPE__)(x))\n#elif !defined(__GNUC__) /* works for compilers other than LLVM */\n# define NK_UINT_TO_PTR(x) ((void*)&((char*)0)[x])\n# define NK_PTR_TO_UINT(x) ((nk_size)(((char*)x)-(char*)0))\n#elif defined(NK_USE_FIXED_TYPES) /* used if we have <stdint.h> */\n# define NK_UINT_TO_PTR(x) ((void*)(uintptr_t)(x))\n# define NK_PTR_TO_UINT(x) ((uintptr_t)(x))\n#else /* generates warning but works */\n# define NK_UINT_TO_PTR(x) ((void*)(x))\n# define NK_PTR_TO_UINT(x) ((nk_size)(x))\n#endif\n\n#define NK_ALIGN_PTR(x, mask)\\\n    (NK_UINT_TO_PTR((NK_PTR_TO_UINT((nk_byte*)(x) + (mask-1)) & ~(mask-1))))\n#define NK_ALIGN_PTR_BACK(x, mask)\\\n    (NK_UINT_TO_PTR((NK_PTR_TO_UINT((nk_byte*)(x)) & ~(mask-1))))\n\n#if ((defined(__GNUC__) && __GNUC__ >= 4) || defined(__clang__)) && !defined(EMSCRIPTEN)\n#define NK_OFFSETOF(st,m) (__builtin_offsetof(st,m))\n#else\n#define NK_OFFSETOF(st,m) ((nk_ptr)&(((st*)0)->m))\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n#ifdef __cplusplus\ntemplate<typename T> struct nk_alignof;\ntemplate<typename T, int size_diff> struct nk_helper{enum {value = size_diff};};\ntemplate<typename T> struct nk_helper<T,0>{enum {value = nk_alignof<T>::value};};\ntemplate<typename T> struct nk_alignof{struct Big {T x; char c;}; enum {\n    diff = sizeof(Big) - sizeof(T), value = nk_helper<Big, diff>::value};};\n#define NK_ALIGNOF(t) (nk_alignof<t>::value)\n#else\n#define NK_ALIGNOF(t) NK_OFFSETOF(struct {char c; t _h;}, _h)\n#endif\n\n#define NK_CONTAINER_OF(ptr,type,member)\\\n    (type*)((void*)((char*)(1 ? (ptr): &((type*)0)->member) - NK_OFFSETOF(type, member)))\n\n\n\n#endif /* NK_NUKLEAR_H_ */\n\n#ifdef NK_IMPLEMENTATION\n\n#ifndef NK_INTERNAL_H\n#define NK_INTERNAL_H\n\n#ifndef NK_POOL_DEFAULT_CAPACITY\n#define NK_POOL_DEFAULT_CAPACITY 16\n#endif\n\n#ifndef NK_DEFAULT_COMMAND_BUFFER_SIZE\n#define NK_DEFAULT_COMMAND_BUFFER_SIZE (4*1024)\n#endif\n\n#ifndef NK_BUFFER_DEFAULT_INITIAL_SIZE\n#define NK_BUFFER_DEFAULT_INITIAL_SIZE (4*1024)\n#endif\n\n/* standard library headers */\n#ifdef NK_INCLUDE_DEFAULT_ALLOCATOR\n#include <stdlib.h> /* malloc, free */\n#endif\n#ifdef NK_INCLUDE_STANDARD_IO\n#include <stdio.h> /* fopen, fclose,... */\n#endif\n#ifdef NK_INCLUDE_STANDARD_VARARGS\n#include <stdarg.h> /* valist, va_start, va_end, ... */\n#endif\n#ifndef NK_ASSERT\n#include <assert.h>\n#define NK_ASSERT(expr) assert(expr)\n#endif\n\n#define NK_DEFAULT (-1)\n\n#ifndef NK_VSNPRINTF\n/* If your compiler does support `vsnprintf` I would highly recommend\n * defining this to vsnprintf instead since `vsprintf` is basically\n * unbelievable unsafe and should *NEVER* be used. But I have to support\n * it since C89 only provides this unsafe version. */\n  #if (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)) ||\\\n      (defined(__cplusplus) && (__cplusplus >= 201103L)) || \\\n      (defined(_POSIX_C_SOURCE) && (_POSIX_C_SOURCE >= 200112L)) ||\\\n      (defined(_XOPEN_SOURCE) && (_XOPEN_SOURCE >= 500)) ||\\\n       defined(_ISOC99_SOURCE) || defined(_BSD_SOURCE)\n      #define NK_VSNPRINTF(s,n,f,a) vsnprintf(s,n,f,a)\n  #else\n    #define NK_VSNPRINTF(s,n,f,a) vsprintf(s,f,a)\n  #endif\n#endif\n\n#define NK_SCHAR_MIN (-127)\n#define NK_SCHAR_MAX 127\n#define NK_UCHAR_MIN 0\n#define NK_UCHAR_MAX 256\n#define NK_SSHORT_MIN (-32767)\n#define NK_SSHORT_MAX 32767\n#define NK_USHORT_MIN 0\n#define NK_USHORT_MAX 65535\n#define NK_SINT_MIN (-2147483647)\n#define NK_SINT_MAX 2147483647\n#define NK_UINT_MIN 0\n#define NK_UINT_MAX 4294967295u\n\n/* Make sure correct type size:\n * This will fire with a negative subscript error if the type sizes\n * are set incorrectly by the compiler, and compile out if not */\nNK_STATIC_ASSERT(sizeof(nk_size) >= sizeof(void*));\nNK_STATIC_ASSERT(sizeof(nk_ptr) == sizeof(void*));\nNK_STATIC_ASSERT(sizeof(nk_flags) >= 4);\nNK_STATIC_ASSERT(sizeof(nk_rune) >= 4);\nNK_STATIC_ASSERT(sizeof(nk_ushort) == 2);\nNK_STATIC_ASSERT(sizeof(nk_short) == 2);\nNK_STATIC_ASSERT(sizeof(nk_uint) == 4);\nNK_STATIC_ASSERT(sizeof(nk_int) == 4);\nNK_STATIC_ASSERT(sizeof(nk_byte) == 1);\n#ifdef NK_INCLUDE_STANDARD_BOOL\nNK_STATIC_ASSERT(sizeof(nk_bool) == sizeof(bool));\n#else\nNK_STATIC_ASSERT(sizeof(nk_bool) == 4);\n#endif\n\nNK_GLOBAL const struct nk_rect nk_null_rect = {-8192.0f, -8192.0f, 16384, 16384};\n#define NK_FLOAT_PRECISION 0.00000000000001\n\nNK_GLOBAL const struct nk_color nk_red = {255,0,0,255};\nNK_GLOBAL const struct nk_color nk_green = {0,255,0,255};\nNK_GLOBAL const struct nk_color nk_blue = {0,0,255,255};\nNK_GLOBAL const struct nk_color nk_white = {255,255,255,255};\nNK_GLOBAL const struct nk_color nk_black = {0,0,0,255};\nNK_GLOBAL const struct nk_color nk_yellow = {255,255,0,255};\n\n/* widget */\n#define nk_widget_state_reset(s)\\\n    if ((*(s)) & NK_WIDGET_STATE_MODIFIED)\\\n        (*(s)) = NK_WIDGET_STATE_INACTIVE|NK_WIDGET_STATE_MODIFIED;\\\n    else (*(s)) = NK_WIDGET_STATE_INACTIVE;\n\n/* math */\n#ifndef NK_INV_SQRT\nNK_LIB float nk_inv_sqrt(float n);\n#endif\n#ifndef NK_SIN\nNK_LIB float nk_sin(float x);\n#endif\n#ifndef NK_COS\nNK_LIB float nk_cos(float x);\n#endif\n#ifndef NK_ATAN\nNK_LIB float nk_atan(float x);\n#endif\n#ifndef NK_ATAN2\nNK_LIB float nk_atan2(float y, float x);\n#endif\nNK_LIB nk_uint nk_round_up_pow2(nk_uint v);\nNK_LIB struct nk_rect nk_shrink_rect(struct nk_rect r, float amount);\nNK_LIB struct nk_rect nk_pad_rect(struct nk_rect r, struct nk_vec2 pad);\nNK_LIB void nk_unify(struct nk_rect *clip, const struct nk_rect *a, float x0, float y0, float x1, float y1);\nNK_LIB double nk_pow(double x, int n);\nNK_LIB int nk_ifloord(double x);\nNK_LIB int nk_ifloorf(float x);\nNK_LIB int nk_iceilf(float x);\nNK_LIB int nk_log10(double n);\nNK_LIB float nk_roundf(float x);\n\n/* util */\nenum {NK_DO_NOT_STOP_ON_NEW_LINE, NK_STOP_ON_NEW_LINE};\nNK_LIB nk_bool nk_is_lower(int c);\nNK_LIB nk_bool nk_is_upper(int c);\nNK_LIB int nk_to_upper(int c);\nNK_LIB int nk_to_lower(int c);\n\n#ifndef NK_MEMCPY\nNK_LIB void* nk_memcopy(void *dst, const void *src, nk_size n);\n#endif\n#ifndef NK_MEMSET\nNK_LIB void nk_memset(void *ptr, int c0, nk_size size);\n#endif\nNK_LIB void nk_zero(void *ptr, nk_size size);\nNK_LIB char *nk_itoa(char *s, long n);\nNK_LIB int nk_string_float_limit(char *string, int prec);\n#ifndef NK_DTOA\nNK_LIB char *nk_dtoa(char *s, double n);\n#endif\nNK_LIB int nk_text_clamp(const struct nk_user_font *font, const char *text, int text_len, float space, int *glyphs, float *text_width, nk_rune *sep_list, int sep_count);\nNK_LIB struct nk_vec2 nk_text_calculate_text_bounds(const struct nk_user_font *font, const char *begin, int byte_len, float row_height, const char **remaining, struct nk_vec2 *out_offset, int *glyphs, int op);\n#ifdef NK_INCLUDE_STANDARD_VARARGS\nNK_LIB int nk_strfmt(char *buf, int buf_size, const char *fmt, va_list args);\n#endif\n#ifdef NK_INCLUDE_STANDARD_IO\nNK_LIB char *nk_file_load(const char* path, nk_size* siz, const struct nk_allocator *alloc);\n#endif\n\n/* buffer */\n#ifdef NK_INCLUDE_DEFAULT_ALLOCATOR\nNK_LIB void* nk_malloc(nk_handle unused, void *old,nk_size size);\nNK_LIB void nk_mfree(nk_handle unused, void *ptr);\n#endif\nNK_LIB void* nk_buffer_align(void *unaligned, nk_size align, nk_size *alignment, enum nk_buffer_allocation_type type);\nNK_LIB void* nk_buffer_alloc(struct nk_buffer *b, enum nk_buffer_allocation_type type, nk_size size, nk_size align);\nNK_LIB void* nk_buffer_realloc(struct nk_buffer *b, nk_size capacity, nk_size *size);\n\n/* draw */\nNK_LIB void nk_command_buffer_init(struct nk_command_buffer *cb, struct nk_buffer *b, enum nk_command_clipping clip);\nNK_LIB void nk_command_buffer_reset(struct nk_command_buffer *b);\nNK_LIB void* nk_command_buffer_push(struct nk_command_buffer* b, enum nk_command_type t, nk_size size);\nNK_LIB void nk_draw_symbol(struct nk_command_buffer *out, enum nk_symbol_type type, struct nk_rect content, struct nk_color background, struct nk_color foreground, float border_width, const struct nk_user_font *font);\n\n/* buffering */\nNK_LIB void nk_start_buffer(struct nk_context *ctx, struct nk_command_buffer *b);\nNK_LIB void nk_start(struct nk_context *ctx, struct nk_window *win);\nNK_LIB void nk_start_popup(struct nk_context *ctx, struct nk_window *win);\nNK_LIB void nk_finish_popup(struct nk_context *ctx, struct nk_window*);\nNK_LIB void nk_finish_buffer(struct nk_context *ctx, struct nk_command_buffer *b);\nNK_LIB void nk_finish(struct nk_context *ctx, struct nk_window *w);\nNK_LIB void nk_build(struct nk_context *ctx);\n\n/* text editor */\nNK_LIB void nk_textedit_clear_state(struct nk_text_edit *state, enum nk_text_edit_type type, nk_plugin_filter filter);\nNK_LIB void nk_textedit_click(struct nk_text_edit *state, float x, float y, const struct nk_user_font *font, float row_height);\nNK_LIB void nk_textedit_drag(struct nk_text_edit *state, float x, float y, const struct nk_user_font *font, float row_height);\nNK_LIB void nk_textedit_key(struct nk_text_edit *state, enum nk_keys key, int shift_mod, const struct nk_user_font *font, float row_height);\n\n/* window */\nenum nk_window_insert_location {\n    NK_INSERT_BACK, /* inserts window into the back of list (front of screen) */\n    NK_INSERT_FRONT /* inserts window into the front of list (back of screen) */\n};\nNK_LIB void *nk_create_window(struct nk_context *ctx);\nNK_LIB void nk_remove_window(struct nk_context*, struct nk_window*);\nNK_LIB void nk_free_window(struct nk_context *ctx, struct nk_window *win);\nNK_LIB struct nk_window *nk_find_window(const struct nk_context *ctx, nk_hash hash, const char *name);\nNK_LIB void nk_insert_window(struct nk_context *ctx, struct nk_window *win, enum nk_window_insert_location loc);\n\n/* pool */\nNK_LIB void nk_pool_init(struct nk_pool *pool, const struct nk_allocator *alloc, unsigned int capacity);\nNK_LIB void nk_pool_free(struct nk_pool *pool);\nNK_LIB void nk_pool_init_fixed(struct nk_pool *pool, void *memory, nk_size size);\nNK_LIB struct nk_page_element *nk_pool_alloc(struct nk_pool *pool);\n\n/* page-element */\nNK_LIB struct nk_page_element* nk_create_page_element(struct nk_context *ctx);\nNK_LIB void nk_link_page_element_into_freelist(struct nk_context *ctx, struct nk_page_element *elem);\nNK_LIB void nk_free_page_element(struct nk_context *ctx, struct nk_page_element *elem);\n\n/* table */\nNK_LIB struct nk_table* nk_create_table(struct nk_context *ctx);\nNK_LIB void nk_remove_table(struct nk_window *win, struct nk_table *tbl);\nNK_LIB void nk_free_table(struct nk_context *ctx, struct nk_table *tbl);\nNK_LIB void nk_push_table(struct nk_window *win, struct nk_table *tbl);\nNK_LIB nk_uint *nk_add_value(struct nk_context *ctx, struct nk_window *win, nk_hash name, nk_uint value);\nNK_LIB nk_uint *nk_find_value(const struct nk_window *win, nk_hash name);\n\n/* panel */\nNK_LIB void *nk_create_panel(struct nk_context *ctx);\nNK_LIB void nk_free_panel(struct nk_context*, struct nk_panel *pan);\nNK_LIB nk_bool nk_panel_has_header(nk_flags flags, const char *title);\nNK_LIB struct nk_vec2 nk_panel_get_padding(const struct nk_style *style, enum nk_panel_type type);\nNK_LIB float nk_panel_get_border(const struct nk_style *style, nk_flags flags, enum nk_panel_type type);\nNK_LIB struct nk_color nk_panel_get_border_color(const struct nk_style *style, enum nk_panel_type type);\nNK_LIB nk_bool nk_panel_is_sub(enum nk_panel_type type);\nNK_LIB nk_bool nk_panel_is_nonblock(enum nk_panel_type type);\nNK_LIB nk_bool nk_panel_begin(struct nk_context *ctx, const char *title, enum nk_panel_type panel_type);\nNK_LIB void nk_panel_end(struct nk_context *ctx);\n\n/* layout */\nNK_LIB float nk_layout_row_calculate_usable_space(const struct nk_style *style, enum nk_panel_type type, float total_space, int columns);\nNK_LIB void nk_panel_layout(const struct nk_context *ctx, struct nk_window *win, float height, int cols);\nNK_LIB void nk_row_layout(struct nk_context *ctx, enum nk_layout_format fmt, float height, int cols, int width);\nNK_LIB void nk_panel_alloc_row(const struct nk_context *ctx, struct nk_window *win);\nNK_LIB void nk_layout_widget_space(struct nk_rect *bounds, const struct nk_context *ctx, struct nk_window *win, int modify);\nNK_LIB void nk_panel_alloc_space(struct nk_rect *bounds, const struct nk_context *ctx);\nNK_LIB void nk_layout_peek(struct nk_rect *bounds, const struct nk_context *ctx);\n\n/* popup */\nNK_LIB nk_bool nk_nonblock_begin(struct nk_context *ctx, nk_flags flags, struct nk_rect body, struct nk_rect header, enum nk_panel_type panel_type);\n\n/* text */\nstruct nk_text {\n    struct nk_vec2 padding;\n    struct nk_color background;\n    struct nk_color text;\n};\nNK_LIB void nk_widget_text(struct nk_command_buffer *o, struct nk_rect b, const char *string, int len, const struct nk_text *t, nk_flags a, const struct nk_user_font *f);\nNK_LIB void nk_widget_text_wrap(struct nk_command_buffer *o, struct nk_rect b, const char *string, int len, const struct nk_text *t, const struct nk_user_font *f);\n\n/* button */\nNK_LIB nk_bool nk_button_behavior(nk_flags *state, struct nk_rect r, const struct nk_input *i, enum nk_button_behavior behavior);\nNK_LIB const struct nk_style_item* nk_draw_button(struct nk_command_buffer *out, const struct nk_rect *bounds, nk_flags state, const struct nk_style_button *style);\nNK_LIB nk_bool nk_do_button(nk_flags *state, struct nk_command_buffer *out, struct nk_rect r, const struct nk_style_button *style, const struct nk_input *in, enum nk_button_behavior behavior, struct nk_rect *content);\nNK_LIB void nk_draw_button_text(struct nk_command_buffer *out, const struct nk_rect *bounds, const struct nk_rect *content, nk_flags state, const struct nk_style_button *style, const char *txt, int len, nk_flags text_alignment, const struct nk_user_font *font);\nNK_LIB nk_bool nk_do_button_text(nk_flags *state, struct nk_command_buffer *out, struct nk_rect bounds, const char *string, int len, nk_flags align, enum nk_button_behavior behavior, const struct nk_style_button *style, const struct nk_input *in, const struct nk_user_font *font);\nNK_LIB void nk_draw_button_symbol(struct nk_command_buffer *out, const struct nk_rect *bounds, const struct nk_rect *content, nk_flags state, const struct nk_style_button *style, enum nk_symbol_type type, const struct nk_user_font *font);\nNK_LIB nk_bool nk_do_button_symbol(nk_flags *state, struct nk_command_buffer *out, struct nk_rect bounds, enum nk_symbol_type symbol, enum nk_button_behavior behavior, const struct nk_style_button *style, const struct nk_input *in, const struct nk_user_font *font);\nNK_LIB void nk_draw_button_image(struct nk_command_buffer *out, const struct nk_rect *bounds, const struct nk_rect *content, nk_flags state, const struct nk_style_button *style, const struct nk_image *img);\nNK_LIB nk_bool nk_do_button_image(nk_flags *state, struct nk_command_buffer *out, struct nk_rect bounds, struct nk_image img, enum nk_button_behavior b, const struct nk_style_button *style, const struct nk_input *in);\nNK_LIB void nk_draw_button_text_symbol(struct nk_command_buffer *out, const struct nk_rect *bounds, const struct nk_rect *label, const struct nk_rect *symbol, nk_flags state, const struct nk_style_button *style, const char *str, int len, enum nk_symbol_type type, const struct nk_user_font *font);\nNK_LIB nk_bool nk_do_button_text_symbol(nk_flags *state, struct nk_command_buffer *out, struct nk_rect bounds, enum nk_symbol_type symbol, const char *str, int len, nk_flags align, enum nk_button_behavior behavior, const struct nk_style_button *style, const struct nk_user_font *font, const struct nk_input *in);\nNK_LIB void nk_draw_button_text_image(struct nk_command_buffer *out, const struct nk_rect *bounds, const struct nk_rect *label, const struct nk_rect *image, nk_flags state, const struct nk_style_button *style, const char *str, int len, const struct nk_user_font *font, const struct nk_image *img);\nNK_LIB nk_bool nk_do_button_text_image(nk_flags *state, struct nk_command_buffer *out, struct nk_rect bounds, struct nk_image img, const char* str, int len, nk_flags align, enum nk_button_behavior behavior, const struct nk_style_button *style, const struct nk_user_font *font, const struct nk_input *in);\n\n/* toggle */\nenum nk_toggle_type {\n    NK_TOGGLE_CHECK,\n    NK_TOGGLE_OPTION\n};\nNK_LIB nk_bool nk_toggle_behavior(const struct nk_input *in, struct nk_rect select, nk_flags *state, nk_bool active);\nNK_LIB void nk_draw_checkbox(struct nk_command_buffer *out, nk_flags state, const struct nk_style_toggle *style, nk_bool active, const struct nk_rect *label, const struct nk_rect *selector, const struct nk_rect *cursors, const char *string, int len, const struct nk_user_font *font, nk_flags text_alignment);\nNK_LIB void nk_draw_option(struct nk_command_buffer *out, nk_flags state, const struct nk_style_toggle *style, nk_bool active, const struct nk_rect *label, const struct nk_rect *selector, const struct nk_rect *cursors, const char *string, int len, const struct nk_user_font *font, nk_flags text_alignment);\nNK_LIB nk_bool nk_do_toggle(nk_flags *state, struct nk_command_buffer *out, struct nk_rect r, nk_bool *active, const char *str, int len, enum nk_toggle_type type, const struct nk_style_toggle *style, const struct nk_input *in, const struct nk_user_font *font, nk_flags widget_alignment, nk_flags text_alignment);\n\n/* progress */\nNK_LIB nk_size nk_progress_behavior(nk_flags *state, struct nk_input *in, struct nk_rect r, struct nk_rect cursor, nk_size max, nk_size value, nk_bool modifiable);\nNK_LIB void nk_draw_progress(struct nk_command_buffer *out, nk_flags state, const struct nk_style_progress *style, const struct nk_rect *bounds, const struct nk_rect *scursor, nk_size value, nk_size max);\nNK_LIB nk_size nk_do_progress(nk_flags *state, struct nk_command_buffer *out, struct nk_rect bounds, nk_size value, nk_size max, nk_bool modifiable, const struct nk_style_progress *style, struct nk_input *in);\n\n/* slider */\nNK_LIB float nk_slider_behavior(nk_flags *state, struct nk_rect *logical_cursor, struct nk_rect *visual_cursor, struct nk_input *in, struct nk_rect bounds, float slider_min, float slider_max, float slider_value, float slider_step, float slider_steps);\nNK_LIB void nk_draw_slider(struct nk_command_buffer *out, nk_flags state, const struct nk_style_slider *style, const struct nk_rect *bounds, const struct nk_rect *visual_cursor, float min, float value, float max);\nNK_LIB float nk_do_slider(nk_flags *state, struct nk_command_buffer *out, struct nk_rect bounds, float min, float val, float max, float step, const struct nk_style_slider *style, struct nk_input *in, const struct nk_user_font *font);\n\n/* scrollbar */\nNK_LIB float nk_scrollbar_behavior(nk_flags *state, struct nk_input *in, int has_scrolling, const struct nk_rect *scroll, const struct nk_rect *cursor, const struct nk_rect *empty0, const struct nk_rect *empty1, float scroll_offset, float target, float scroll_step, enum nk_orientation o);\nNK_LIB void nk_draw_scrollbar(struct nk_command_buffer *out, nk_flags state, const struct nk_style_scrollbar *style, const struct nk_rect *bounds, const struct nk_rect *scroll);\nNK_LIB float nk_do_scrollbarv(nk_flags *state, struct nk_command_buffer *out, struct nk_rect scroll, int has_scrolling, float offset, float target, float step, float button_pixel_inc, const struct nk_style_scrollbar *style, struct nk_input *in, const struct nk_user_font *font);\nNK_LIB float nk_do_scrollbarh(nk_flags *state, struct nk_command_buffer *out, struct nk_rect scroll, int has_scrolling, float offset, float target, float step, float button_pixel_inc, const struct nk_style_scrollbar *style, struct nk_input *in, const struct nk_user_font *font);\n\n/* selectable */\nNK_LIB void nk_draw_selectable(struct nk_command_buffer *out, nk_flags state, const struct nk_style_selectable *style, nk_bool active, const struct nk_rect *bounds, const struct nk_rect *icon, const struct nk_image *img, enum nk_symbol_type sym, const char *string, int len, nk_flags align, const struct nk_user_font *font);\nNK_LIB nk_bool nk_do_selectable(nk_flags *state, struct nk_command_buffer *out, struct nk_rect bounds, const char *str, int len, nk_flags align, nk_bool *value, const struct nk_style_selectable *style, const struct nk_input *in, const struct nk_user_font *font);\nNK_LIB nk_bool nk_do_selectable_image(nk_flags *state, struct nk_command_buffer *out, struct nk_rect bounds, const char *str, int len, nk_flags align, nk_bool *value, const struct nk_image *img, const struct nk_style_selectable *style, const struct nk_input *in, const struct nk_user_font *font);\n\n/* edit */\nNK_LIB void nk_edit_draw_text(struct nk_command_buffer *out, const struct nk_style_edit *style, float pos_x, float pos_y, float x_offset, const char *text, int byte_len, float row_height, const struct nk_user_font *font, struct nk_color background, struct nk_color foreground, nk_bool is_selected);\nNK_LIB nk_flags nk_do_edit(nk_flags *state, struct nk_command_buffer *out, struct nk_rect bounds, nk_flags flags, nk_plugin_filter filter, struct nk_text_edit *edit, const struct nk_style_edit *style, struct nk_input *in, const struct nk_user_font *font);\n\n/* color-picker */\nNK_LIB nk_bool nk_color_picker_behavior(nk_flags *state, const struct nk_rect *bounds, const struct nk_rect *matrix, const struct nk_rect *hue_bar, const struct nk_rect *alpha_bar, struct nk_colorf *color, const struct nk_input *in);\nNK_LIB void nk_draw_color_picker(struct nk_command_buffer *o, const struct nk_rect *matrix, const struct nk_rect *hue_bar, const struct nk_rect *alpha_bar, struct nk_colorf col);\nNK_LIB nk_bool nk_do_color_picker(nk_flags *state, struct nk_command_buffer *out, struct nk_colorf *col, enum nk_color_format fmt, struct nk_rect bounds, struct nk_vec2 padding, const struct nk_input *in, const struct nk_user_font *font);\n\n/* property */\nenum nk_property_status {\n    NK_PROPERTY_DEFAULT,\n    NK_PROPERTY_EDIT,\n    NK_PROPERTY_DRAG\n};\nenum nk_property_filter {\n    NK_FILTER_INT,\n    NK_FILTER_FLOAT\n};\nenum nk_property_kind {\n    NK_PROPERTY_INT,\n    NK_PROPERTY_FLOAT,\n    NK_PROPERTY_DOUBLE\n};\nunion nk_property {\n    int i;\n    float f;\n    double d;\n};\nstruct nk_property_variant {\n    enum nk_property_kind kind;\n    union nk_property value;\n    union nk_property min_value;\n    union nk_property max_value;\n    union nk_property step;\n};\nNK_LIB struct nk_property_variant nk_property_variant_int(int value, int min_value, int max_value, int step);\nNK_LIB struct nk_property_variant nk_property_variant_float(float value, float min_value, float max_value, float step);\nNK_LIB struct nk_property_variant nk_property_variant_double(double value, double min_value, double max_value, double step);\n\nNK_LIB void nk_drag_behavior(nk_flags *state, const struct nk_input *in, struct nk_rect drag, struct nk_property_variant *variant, float inc_per_pixel);\nNK_LIB void nk_property_behavior(nk_flags *ws, const struct nk_input *in, struct nk_rect property,  struct nk_rect label, struct nk_rect edit, struct nk_rect empty, int *state, struct nk_property_variant *variant, float inc_per_pixel);\nNK_LIB void nk_draw_property(struct nk_command_buffer *out, const struct nk_style_property *style, const struct nk_rect *bounds, const struct nk_rect *label, nk_flags state, const char *name, int len, const struct nk_user_font *font);\nNK_LIB void nk_do_property(nk_flags *ws, struct nk_command_buffer *out, struct nk_rect property, const char *name, struct nk_property_variant *variant, float inc_per_pixel, char *buffer, int *len, int *state, int *cursor, int *select_begin, int *select_end, const struct nk_style_property *style, enum nk_property_filter filter, struct nk_input *in, const struct nk_user_font *font, struct nk_text_edit *text_edit, enum nk_button_behavior behavior);\nNK_LIB void nk_property(struct nk_context *ctx, const char *name, struct nk_property_variant *variant, float inc_per_pixel, const enum nk_property_filter filter);\n\n#ifdef NK_INCLUDE_FONT_BAKING\n\n/**\n * @def NK_NO_STB_RECT_PACK_IMPLEMENTATION\n *\n * When defined, will avoid enabling STB_RECT_PACK_IMPLEMENTATION for when stb_rect_pack.h is already implemented elsewhere.\n */\n#ifndef NK_NO_STB_RECT_PACK_IMPLEMENTATION\n#define STB_RECT_PACK_IMPLEMENTATION\n#endif /* NK_NO_STB_RECT_PACK_IMPLEMENTATION */\n\n/**\n * @def NK_NO_STB_TRUETYPE_IMPLEMENTATION\n *\n * When defined, will avoid enabling STB_TRUETYPE_IMPLEMENTATION for when stb_truetype.h is already implemented elsewhere.\n */\n#ifndef NK_NO_STB_TRUETYPE_IMPLEMENTATION\n#define STB_TRUETYPE_IMPLEMENTATION\n#endif /* NK_NO_STB_TRUETYPE_IMPLEMENTATION */\n\n/* Allow consumer to define own STBTT_malloc/STBTT_free, and use the font atlas' allocator otherwise */\n#ifndef STBTT_malloc\nstatic void*\nnk_stbtt_malloc(nk_size size, void *user_data) {\n    struct nk_allocator *alloc = (struct nk_allocator *) user_data;\n    return alloc->alloc(alloc->userdata, 0, size);\n}\n\nstatic void\nnk_stbtt_free(void *ptr, void *user_data) {\n    struct nk_allocator *alloc = (struct nk_allocator *) user_data;\n    alloc->free(alloc->userdata, ptr);\n}\n\n#define STBTT_malloc(x,u)  nk_stbtt_malloc(x,u)\n#define STBTT_free(x,u)    nk_stbtt_free(x,u)\n\n#endif /* STBTT_malloc */\n\n#endif /* NK_INCLUDE_FONT_BAKING */\n\n#endif\n\n\n\n\n/* ===============================================================\n *\n *                              MATH\n *\n * ===============================================================*/\n/*/// ### Math\n///  Since nuklear is supposed to work on all systems providing floating point\n///  math without any dependencies I also had to implement my own math functions\n///  for sqrt, sin and cos. Since the actual highly accurate implementations for\n///  the standard library functions are quite complex and I do not need high\n///  precision for my use cases I use approximations.\n///\n///  Sqrt\n///  ----\n///  For square root nuklear uses the famous fast inverse square root:\n///  https://en.wikipedia.org/wiki/Fast_inverse_square_root with\n///  slightly tweaked magic constant. While on today's hardware it is\n///  probably not faster it is still fast and accurate enough for\n///  nuklear's use cases. IMPORTANT: this requires float format IEEE 754\n///\n///  Sine/Cosine\n///  -----------\n///  All constants inside both function are generated Remez's minimax\n///  approximations for value range 0...2*PI. The reason why I decided to\n///  approximate exactly that range is that nuklear only needs sine and\n///  cosine to generate circles which only requires that exact range.\n///  In addition I used Remez instead of Taylor for additional precision:\n///  www.lolengine.net/blog/2011/12/21/better-function-approximations.\n///\n///  The tool I used to generate constants for both sine and cosine\n///  (it can actually approximate a lot more functions) can be\n///  found here: www.lolengine.net/wiki/oss/lolremez\n*/\n#ifndef NK_INV_SQRT\n#define NK_INV_SQRT nk_inv_sqrt\nNK_LIB float\nnk_inv_sqrt(float n)\n{\n    float x2;\n    const float threehalfs = 1.5f;\n    union {nk_uint i; float f;} conv = {0};\n    conv.f = n;\n    x2 = n * 0.5f;\n    conv.i = 0x5f375A84 - (conv.i >> 1);\n    conv.f = conv.f * (threehalfs - (x2 * conv.f * conv.f));\n    return conv.f;\n}\n#endif\n#ifndef NK_SIN\n#define NK_SIN nk_sin\nNK_LIB float\nnk_sin(float x)\n{\n    NK_STORAGE const float a0 = +1.91059300966915117e-31f;\n    NK_STORAGE const float a1 = +1.00086760103908896f;\n    NK_STORAGE const float a2 = -1.21276126894734565e-2f;\n    NK_STORAGE const float a3 = -1.38078780785773762e-1f;\n    NK_STORAGE const float a4 = -2.67353392911981221e-2f;\n    NK_STORAGE const float a5 = +2.08026600266304389e-2f;\n    NK_STORAGE const float a6 = -3.03996055049204407e-3f;\n    NK_STORAGE const float a7 = +1.38235642404333740e-4f;\n    return a0 + x*(a1 + x*(a2 + x*(a3 + x*(a4 + x*(a5 + x*(a6 + x*a7))))));\n}\n#endif\n#ifndef NK_COS\n#define NK_COS nk_cos\nNK_LIB float\nnk_cos(float x)\n{\n    /* New implementation. Also generated using lolremez. */\n    /* Old version significantly deviated from expected results. */\n    NK_STORAGE const float a0 = 9.9995999154986614e-1f;\n    NK_STORAGE const float a1 = 1.2548995793001028e-3f;\n    NK_STORAGE const float a2 = -5.0648546280678015e-1f;\n    NK_STORAGE const float a3 = 1.2942246466519995e-2f;\n    NK_STORAGE const float a4 = 2.8668384702547972e-2f;\n    NK_STORAGE const float a5 = 7.3726485210586547e-3f;\n    NK_STORAGE const float a6 = -3.8510875386947414e-3f;\n    NK_STORAGE const float a7 = 4.7196604604366623e-4f;\n    NK_STORAGE const float a8 = -1.8776444013090451e-5f;\n    return a0 + x*(a1 + x*(a2 + x*(a3 + x*(a4 + x*(a5 + x*(a6 + x*(a7 + x*a8)))))));\n}\n#endif\n#ifndef NK_ATAN\n#define NK_ATAN nk_atan\nNK_LIB float\nnk_atan(float x)\n{\n    /* ./lolremez --progress --float -d 9 -r \"0:pi*2\" \"atan(x)\" */\n    float u = -1.0989005e-05f;\n    NK_ASSERT(x >= 0.0f && \"TODO support negative floats\");\n    u = u * x + 0.00034117949f;\n    u = u * x + -0.0044932296f;\n    u = u * x + 0.032596264f;\n    u = u * x + -0.14088021f;\n    u = u * x + 0.36040401f;\n    u = u * x + -0.47017866f;\n    u = u * x + 0.00050198776f;\n    u = u * x + 1.0077682f;\n    u = u * x + -0.0004765437f;\n    return u;\n}\n#endif\n#ifndef NK_ATAN2\n#define NK_ATAN2 nk_atan2\nNK_LIB float\nnk_atan2(float y, float x)\n{\n    float ax = NK_ABS(x),\n          ay = NK_ABS(y);\n    /* 0 = +y +x    1 = -y +x\n       2 = +y -x    3 = -y -x */\n    nk_uint signs = (y < 0) | ((x < 0) << 1);\n\n    float a;\n    if(y == 0.0 && x == 0.0) return 0.0f;\n    a = (ay > ax)\n        ? NK_PI_HALF - NK_ATAN(ax / ay)\n        : NK_ATAN(ay / ax);\n\n    switch(signs){\n        case 0: return a;\n        case 1: return -a;\n        case 2: return -a + NK_PI;\n        case 3: return a - NK_PI;\n    }\n    return 0.0f; /* prevents warning */\n}\n#endif\nNK_LIB nk_uint\nnk_round_up_pow2(nk_uint v)\n{\n    v--;\n    v |= v >> 1;\n    v |= v >> 2;\n    v |= v >> 4;\n    v |= v >> 8;\n    v |= v >> 16;\n    v++;\n    return v;\n}\nNK_LIB double\nnk_pow(double x, int n)\n{\n    /*  check the sign of n */\n    double r = 1;\n    int plus = n >= 0;\n    n = (plus) ? n : -n;\n    while (n > 0) {\n        if ((n & 1) == 1)\n            r *= x;\n        n /= 2;\n        x *= x;\n    }\n    return plus ? r : 1.0 / r;\n}\nNK_LIB int\nnk_ifloord(double x)\n{\n    x = (double)((int)x - ((x < 0.0) ? 1 : 0));\n    return (int)x;\n}\nNK_LIB int\nnk_ifloorf(float x)\n{\n    x = (float)((int)x - ((x < 0.0f) ? 1 : 0));\n    return (int)x;\n}\nNK_LIB int\nnk_iceilf(float x)\n{\n    if (x >= 0) {\n        int i = (int)x;\n        return (x > i) ? i+1: i;\n    } else {\n        int t = (int)x;\n        float r = x - (float)t;\n        return (r > 0.0f) ? t+1: t;\n    }\n}\nNK_LIB int\nnk_log10(double n)\n{\n    int neg;\n    int ret;\n    int exp = 0;\n\n    neg = (n < 0) ? 1 : 0;\n    ret = (neg) ? (int)-n : (int)n;\n    while ((ret / 10) > 0) {\n        ret /= 10;\n        exp++;\n    }\n    if (neg) exp = -exp;\n    return exp;\n}\nNK_LIB float\nnk_roundf(float x)\n{\n    return (x >= 0.0f) ? (float)nk_ifloorf(x + 0.5f) : (float)nk_iceilf(x - 0.5f);\n}\nNK_API struct nk_rect\nnk_get_null_rect(void)\n{\n    return nk_null_rect;\n}\nNK_API struct nk_rect\nnk_rect(float x, float y, float w, float h)\n{\n    struct nk_rect r;\n    r.x = x; r.y = y;\n    r.w = w; r.h = h;\n    return r;\n}\nNK_API struct nk_rect\nnk_recti(int x, int y, int w, int h)\n{\n    struct nk_rect r;\n    r.x = (float)x;\n    r.y = (float)y;\n    r.w = (float)w;\n    r.h = (float)h;\n    return r;\n}\nNK_API struct nk_rect\nnk_recta(struct nk_vec2 pos, struct nk_vec2 size)\n{\n    return nk_rect(pos.x, pos.y, size.x, size.y);\n}\nNK_API struct nk_rect\nnk_rectv(const float *r)\n{\n    return nk_rect(r[0], r[1], r[2], r[3]);\n}\nNK_API struct nk_rect\nnk_rectiv(const int *r)\n{\n    return nk_recti(r[0], r[1], r[2], r[3]);\n}\nNK_API struct nk_vec2\nnk_rect_pos(struct nk_rect r)\n{\n    struct nk_vec2 ret;\n    ret.x = r.x; ret.y = r.y;\n    return ret;\n}\nNK_API struct nk_vec2\nnk_rect_size(struct nk_rect r)\n{\n    struct nk_vec2 ret;\n    ret.x = r.w; ret.y = r.h;\n    return ret;\n}\nNK_LIB struct nk_rect\nnk_shrink_rect(struct nk_rect r, float amount)\n{\n    struct nk_rect res;\n    r.w = NK_MAX(r.w, 2 * amount);\n    r.h = NK_MAX(r.h, 2 * amount);\n    res.x = r.x + amount;\n    res.y = r.y + amount;\n    res.w = r.w - 2 * amount;\n    res.h = r.h - 2 * amount;\n    return res;\n}\nNK_LIB struct nk_rect\nnk_pad_rect(struct nk_rect r, struct nk_vec2 pad)\n{\n    r.w = NK_MAX(r.w, 2 * pad.x);\n    r.h = NK_MAX(r.h, 2 * pad.y);\n    r.x += pad.x; r.y += pad.y;\n    r.w -= 2 * pad.x;\n    r.h -= 2 * pad.y;\n    return r;\n}\nNK_API struct nk_vec2\nnk_vec2(float x, float y)\n{\n    struct nk_vec2 ret;\n    ret.x = x; ret.y = y;\n    return ret;\n}\nNK_API struct nk_vec2\nnk_vec2i(int x, int y)\n{\n    struct nk_vec2 ret;\n    ret.x = (float)x;\n    ret.y = (float)y;\n    return ret;\n}\nNK_API struct nk_vec2\nnk_vec2v(const float *v)\n{\n    return nk_vec2(v[0], v[1]);\n}\nNK_API struct nk_vec2\nnk_vec2iv(const int *v)\n{\n    return nk_vec2i(v[0], v[1]);\n}\nNK_LIB void\nnk_unify(struct nk_rect *clip, const struct nk_rect *a, float x0, float y0,\n    float x1, float y1)\n{\n    NK_ASSERT(a);\n    NK_ASSERT(clip);\n    clip->x = NK_MAX(a->x, x0);\n    clip->y = NK_MAX(a->y, y0);\n    clip->w = NK_MIN(a->x + a->w, x1) - clip->x;\n    clip->h = NK_MIN(a->y + a->h, y1) - clip->y;\n    clip->w = NK_MAX(0, clip->w);\n    clip->h = NK_MAX(0, clip->h);\n}\n\nNK_API void\nnk_triangle_from_direction(struct nk_vec2 *result, struct nk_rect r,\n    float pad_x, float pad_y, enum nk_heading direction)\n{\n    float w_half, h_half;\n    NK_ASSERT(result);\n\n    r.w = NK_MAX(2 * pad_x, r.w);\n    r.h = NK_MAX(2 * pad_y, r.h);\n    r.w = r.w - 2 * pad_x;\n    r.h = r.h - 2 * pad_y;\n\n    r.x = r.x + pad_x;\n    r.y = r.y + pad_y;\n\n    w_half = r.w / 2.0f;\n    h_half = r.h / 2.0f;\n\n    if (direction == NK_UP) {\n        result[0] = nk_vec2(r.x + w_half, r.y);\n        result[1] = nk_vec2(r.x + r.w, r.y + r.h);\n        result[2] = nk_vec2(r.x, r.y + r.h);\n    } else if (direction == NK_RIGHT) {\n        result[0] = nk_vec2(r.x, r.y);\n        result[1] = nk_vec2(r.x + r.w, r.y + h_half);\n        result[2] = nk_vec2(r.x, r.y + r.h);\n    } else if (direction == NK_DOWN) {\n        result[0] = nk_vec2(r.x, r.y);\n        result[1] = nk_vec2(r.x + r.w, r.y);\n        result[2] = nk_vec2(r.x + w_half, r.y + r.h);\n    } else {\n        result[0] = nk_vec2(r.x, r.y + h_half);\n        result[1] = nk_vec2(r.x + r.w, r.y);\n        result[2] = nk_vec2(r.x + r.w, r.y + r.h);\n    }\n}\n\n\n\n\n\n/* ===============================================================\n *\n *                              UTIL\n *\n * ===============================================================*/\nNK_INTERN int nk_str_match_here(const char *regexp, const char *text);\nNK_INTERN int nk_str_match_star(int c, const char *regexp, const char *text);\nNK_LIB nk_bool nk_is_lower(int c) {return (c >= 'a' && c <= 'z') || (c >= 0xE0 && c <= 0xFF);}\nNK_LIB nk_bool nk_is_upper(int c){return (c >= 'A' && c <= 'Z') || (c >= 0xC0 && c <= 0xDF);}\nNK_LIB int nk_to_upper(int c) {return (c >= 'a' && c <= 'z') ? (c - ('a' - 'A')) : c;}\nNK_LIB int nk_to_lower(int c) {return (c >= 'A' && c <= 'Z') ? (c - ('a' + 'A')) : c;}\n\n#ifndef NK_MEMCPY\n#define NK_MEMCPY nk_memcopy\nNK_LIB void*\nnk_memcopy(void *dst0, const void *src0, nk_size length)\n{\n    nk_ptr t;\n    char *dst = (char*)dst0;\n    const char *src = (const char*)src0;\n    if (length == 0 || dst == src)\n        goto done;\n\n    #define nk_word int\n    #define nk_wsize sizeof(nk_word)\n    #define nk_wmask (nk_wsize-1)\n    #define NK_TLOOP(s) if (t) NK_TLOOP1(s)\n    #define NK_TLOOP1(s) do { s; } while (--t)\n\n    if (dst < src) {\n        t = (nk_ptr)src; /* only need low bits */\n        if ((t | (nk_ptr)dst) & nk_wmask) {\n            if ((t ^ (nk_ptr)dst) & nk_wmask || length < nk_wsize)\n                t = length;\n            else\n                t = nk_wsize - (t & nk_wmask);\n            length -= t;\n            NK_TLOOP1(*dst++ = *src++);\n        }\n        t = length / nk_wsize;\n        NK_TLOOP(*(nk_word*)(void*)dst = *(const nk_word*)(const void*)src;\n            src += nk_wsize; dst += nk_wsize);\n        t = length & nk_wmask;\n        NK_TLOOP(*dst++ = *src++);\n    } else {\n        src += length;\n        dst += length;\n        t = (nk_ptr)src;\n        if ((t | (nk_ptr)dst) & nk_wmask) {\n            if ((t ^ (nk_ptr)dst) & nk_wmask || length <= nk_wsize)\n                t = length;\n            else\n                t &= nk_wmask;\n            length -= t;\n            NK_TLOOP1(*--dst = *--src);\n        }\n        t = length / nk_wsize;\n        NK_TLOOP(src -= nk_wsize; dst -= nk_wsize;\n            *(nk_word*)(void*)dst = *(const nk_word*)(const void*)src);\n        t = length & nk_wmask;\n        NK_TLOOP(*--dst = *--src);\n    }\n    #undef nk_word\n    #undef nk_wsize\n    #undef nk_wmask\n    #undef NK_TLOOP\n    #undef NK_TLOOP1\ndone:\n    return (dst0);\n}\n#endif\n#ifndef NK_MEMSET\n#define NK_MEMSET nk_memset\nNK_LIB void\nnk_memset(void *ptr, int c0, nk_size size)\n{\n    #define nk_word unsigned\n    #define nk_wsize sizeof(nk_word)\n    #define nk_wmask (nk_wsize - 1)\n    nk_byte *dst = (nk_byte*)ptr;\n    unsigned c = 0;\n    nk_size t = 0;\n\n    if ((c = (nk_byte)c0) != 0) {\n        c = (c << 8) | c; /* at least 16-bits  */\n        if (sizeof(unsigned int) > 2)\n            c = (c << 16) | c; /* at least 32-bits*/\n    }\n\n    /* too small of a word count */\n    dst = (nk_byte*)ptr;\n    if (size < 3 * nk_wsize) {\n        while (size--) *dst++ = (nk_byte)c0;\n        return;\n    }\n\n    /* align destination */\n    if ((t = NK_PTR_TO_UINT(dst) & nk_wmask) != 0) {\n        t = nk_wsize -t;\n        size -= t;\n        do {\n            *dst++ = (nk_byte)c0;\n        } while (--t != 0);\n    }\n\n    /* fill word */\n    t = size / nk_wsize;\n    do {\n        *(nk_word*)((void*)dst) = c;\n        dst += nk_wsize;\n    } while (--t != 0);\n\n    /* fill trailing bytes */\n    t = (size & nk_wmask);\n    if (t != 0) {\n        do {\n            *dst++ = (nk_byte)c0;\n        } while (--t != 0);\n    }\n\n    #undef nk_word\n    #undef nk_wsize\n    #undef nk_wmask\n}\n#endif\nNK_LIB void\nnk_zero(void *ptr, nk_size size)\n{\n    NK_ASSERT(ptr);\n    NK_MEMSET(ptr, 0, size);\n}\nNK_API int\nnk_strlen(const char *str)\n{\n    int siz = 0;\n    NK_ASSERT(str);\n    while (str && *str++ != '\\0') siz++;\n    return siz;\n}\nNK_API int\nnk_strtoi(const char *str, char **endptr)\n{\n    int neg = 1;\n    const char *p = str;\n    int value = 0;\n\n    NK_ASSERT(str);\n    if (!str) return 0;\n\n    /* skip whitespace */\n    while (*p == ' ') p++;\n    if (*p == '-') {\n        neg = -1;\n        p++;\n    }\n    while (*p && *p >= '0' && *p <= '9') {\n        value = value * 10 + (int) (*p - '0');\n        p++;\n    }\n    if (endptr)\n        *endptr = (char *)p;\n    return neg*value;\n}\nNK_API double\nnk_strtod(const char *str, char **endptr)\n{\n    double m;\n    double neg = 1.0;\n    char *p = (char *)str;\n    double value = 0;\n    double number = 0;\n\n    NK_ASSERT(str);\n    if (!str) return 0;\n\n    /* skip whitespace */\n    while (*p == ' ') p++;\n    if (*p == '-') {\n        neg = -1.0;\n        p++;\n    }\n\n    while (*p && *p != '.' && *p != 'e') {\n        value = value * 10.0 + (double) (*p - '0');\n        p++;\n    }\n\n    if (*p == '.') {\n        p++;\n        for(m = 0.1; *p && *p != 'e'; p++ ) {\n            value = value + (double) (*p - '0') * m;\n            m *= 0.1;\n        }\n    }\n    if (*p == 'e') {\n        int i, pow, div;\n        p++;\n        if (*p == '-') {\n            div = nk_true;\n            p++;\n        } else if (*p == '+') {\n            div = nk_false;\n            p++;\n        } else div = nk_false;\n\n        for (pow = 0; *p; p++)\n            pow = pow * 10 + (int) (*p - '0');\n\n        for (m = 1.0, i = 0; i < pow; i++)\n            m *= 10.0;\n\n        if (div)\n            value /= m;\n        else value *= m;\n    }\n    number = value * neg;\n    if (endptr)\n        *endptr = p;\n    return number;\n}\nNK_API float\nnk_strtof(const char *str, char **endptr)\n{\n    float float_value;\n    double double_value;\n    double_value = NK_STRTOD(str, endptr);\n    float_value = (float)double_value;\n    return float_value;\n}\nNK_API int\nnk_stricmp(const char *s1, const char *s2)\n{\n    nk_int c1,c2,d;\n    do {\n        c1 = *s1++;\n        c2 = *s2++;\n        d = c1 - c2;\n        while (d) {\n            if (c1 <= 'Z' && c1 >= 'A') {\n                d += ('a' - 'A');\n                if (!d) break;\n            }\n            if (c2 <= 'Z' && c2 >= 'A') {\n                d -= ('a' - 'A');\n                if (!d) break;\n            }\n            return ((d >= 0) << 1) - 1;\n        }\n    } while (c1);\n    return 0;\n}\nNK_API int\nnk_stricmpn(const char *s1, const char *s2, int n)\n{\n    int c1,c2,d;\n    NK_ASSERT(n >= 0);\n    do {\n        c1 = *s1++;\n        c2 = *s2++;\n        if (!n--) return 0;\n\n        d = c1 - c2;\n        while (d) {\n            if (c1 <= 'Z' && c1 >= 'A') {\n                d += ('a' - 'A');\n                if (!d) break;\n            }\n            if (c2 <= 'Z' && c2 >= 'A') {\n                d -= ('a' - 'A');\n                if (!d) break;\n            }\n            return ((d >= 0) << 1) - 1;\n        }\n    } while (c1);\n    return 0;\n}\nNK_INTERN int\nnk_str_match_here(const char *regexp, const char *text)\n{\n    if (regexp[0] == '\\0')\n        return 1;\n    if (regexp[1] == '*')\n        return nk_str_match_star(regexp[0], regexp+2, text);\n    if (regexp[0] == '$' && regexp[1] == '\\0')\n        return *text == '\\0';\n    if (*text!='\\0' && (regexp[0]=='.' || regexp[0]==*text))\n        return nk_str_match_here(regexp+1, text+1);\n    return 0;\n}\nNK_INTERN int\nnk_str_match_star(int c, const char *regexp, const char *text)\n{\n    do {/* a '* matches zero or more instances */\n        if (nk_str_match_here(regexp, text))\n            return 1;\n    } while (*text != '\\0' && (*text++ == c || c == '.'));\n    return 0;\n}\nNK_API int\nnk_strfilter(const char *text, const char *regexp)\n{\n    /*\n    c    matches any literal character c\n    .    matches any single character\n    ^    matches the beginning of the input string\n    $    matches the end of the input string\n    *    matches zero or more occurrences of the previous character*/\n    if (regexp[0] == '^')\n        return nk_str_match_here(regexp+1, text);\n    do {    /* must look even if string is empty */\n        if (nk_str_match_here(regexp, text))\n            return 1;\n    } while (*text++ != '\\0');\n    return 0;\n}\nNK_API int\nnk_strmatch_fuzzy_text(const char *str, int str_len,\n    const char *pattern, int *out_score)\n{\n    /* Returns true if each character in pattern is found sequentially within str\n     * if found then out_score is also set. Score value has no intrinsic meaning.\n     * Range varies with pattern. Can only compare scores with same search pattern. */\n\n    /* bonus for adjacent matches */\n    #define NK_ADJACENCY_BONUS 5\n    /* bonus if match occurs after a separator */\n    #define NK_SEPARATOR_BONUS 10\n    /* bonus if match is uppercase and prev is lower */\n    #define NK_CAMEL_BONUS 10\n    /* penalty applied for every letter in str before the first match */\n    #define NK_LEADING_LETTER_PENALTY (-3)\n    /* maximum penalty for leading letters */\n    #define NK_MAX_LEADING_LETTER_PENALTY (-9)\n    /* penalty for every letter that doesn't matter */\n    #define NK_UNMATCHED_LETTER_PENALTY (-1)\n\n    /* loop variables */\n    int score = 0;\n    char const * pattern_iter = pattern;\n    int str_iter = 0;\n    int prev_matched = nk_false;\n    int prev_lower = nk_false;\n    /* true so if first letter match gets separator bonus*/\n    int prev_separator = nk_true;\n\n    /* use \"best\" matched letter if multiple string letters match the pattern */\n    char const * best_letter = 0;\n    int best_letter_score = 0;\n\n    /* loop over strings */\n    NK_ASSERT(str);\n    NK_ASSERT(pattern);\n    if (!str || !str_len || !pattern) return 0;\n    while (str_iter < str_len)\n    {\n        const char pattern_letter = *pattern_iter;\n        const char str_letter = str[str_iter];\n\n        int next_match = *pattern_iter != '\\0' &&\n            nk_to_lower(pattern_letter) == nk_to_lower(str_letter);\n        int rematch = best_letter && nk_to_upper(*best_letter) == nk_to_upper(str_letter);\n\n        int advanced = next_match && best_letter;\n        int pattern_repeat = best_letter && *pattern_iter != '\\0';\n        pattern_repeat = pattern_repeat &&\n            nk_to_lower(*best_letter) == nk_to_lower(pattern_letter);\n\n        if (advanced || pattern_repeat) {\n            score += best_letter_score;\n            best_letter = 0;\n            best_letter_score = 0;\n        }\n\n        if (next_match || rematch)\n        {\n            int new_score = 0;\n            /* Apply penalty for each letter before the first pattern match */\n            if (pattern_iter == pattern) {\n                int count = (int)(&str[str_iter] - str);\n                int penalty = NK_LEADING_LETTER_PENALTY * count;\n                if (penalty < NK_MAX_LEADING_LETTER_PENALTY)\n                    penalty = NK_MAX_LEADING_LETTER_PENALTY;\n\n                score += penalty;\n            }\n\n            /* apply bonus for consecutive bonuses */\n            if (prev_matched)\n                new_score += NK_ADJACENCY_BONUS;\n\n            /* apply bonus for matches after a separator */\n            if (prev_separator)\n                new_score += NK_SEPARATOR_BONUS;\n\n            /* apply bonus across camel case boundaries */\n            if (prev_lower && nk_is_upper(str_letter))\n                new_score += NK_CAMEL_BONUS;\n\n            /* update pattern iter IFF the next pattern letter was matched */\n            if (next_match)\n                ++pattern_iter;\n\n            /* update best letter in str which may be for a \"next\" letter or a rematch */\n            if (new_score >= best_letter_score) {\n                /* apply penalty for now skipped letter */\n                if (best_letter != 0)\n                    score += NK_UNMATCHED_LETTER_PENALTY;\n\n                best_letter = &str[str_iter];\n                best_letter_score = new_score;\n            }\n            prev_matched = nk_true;\n        } else {\n            score += NK_UNMATCHED_LETTER_PENALTY;\n            prev_matched = nk_false;\n        }\n\n        /* separators should be more easily defined */\n        prev_lower = nk_is_lower(str_letter) != 0;\n        prev_separator = str_letter == '_' || str_letter == ' ';\n\n        ++str_iter;\n    }\n\n    /* apply score for last match */\n    if (best_letter)\n        score += best_letter_score;\n\n    /* did not match full pattern */\n    if (*pattern_iter != '\\0')\n        return nk_false;\n\n    if (out_score)\n        *out_score = score;\n    return nk_true;\n}\nNK_API int\nnk_strmatch_fuzzy_string(char const *str, char const *pattern, int *out_score)\n{\n    return nk_strmatch_fuzzy_text(str, nk_strlen(str), pattern, out_score);\n}\nNK_LIB int\nnk_string_float_limit(char *string, int prec)\n{\n    int dot = 0;\n    char *c = string;\n    while (*c) {\n        if (*c == '.') {\n            dot = 1;\n            c++;\n            continue;\n        }\n        if (dot == (prec+1)) {\n            *c = 0;\n            break;\n        }\n        if (dot > 0) dot++;\n        c++;\n    }\n    return (int)(c - string);\n}\nNK_INTERN void\nnk_strrev_ascii(char *s)\n{\n    int len = nk_strlen(s);\n    int end = len / 2;\n    int i = 0;\n    char t;\n    for (; i < end; ++i) {\n        t = s[i];\n        s[i] = s[len - 1 - i];\n        s[len -1 - i] = t;\n    }\n}\nNK_LIB char*\nnk_itoa(char *s, long n)\n{\n    long i = 0;\n    if (n == 0) {\n        s[i++] = '0';\n        s[i] = 0;\n        return s;\n    }\n    if (n < 0) {\n        s[i++] = '-';\n        n = -n;\n    }\n    while (n > 0) {\n        s[i++] = (char)('0' + (n % 10));\n        n /= 10;\n    }\n    s[i] = 0;\n    if (s[0] == '-')\n        ++s;\n\n    nk_strrev_ascii(s);\n    return s;\n}\n#ifndef NK_DTOA\n#define NK_DTOA nk_dtoa\nNK_LIB char*\nnk_dtoa(char *s, double n)\n{\n    int useExp = 0;\n    int digit = 0, m = 0, m1 = 0;\n    char *c = s;\n    int neg = 0;\n\n    NK_ASSERT(s);\n    if (!s) return 0;\n\n    if (n == 0.0) {\n        s[0] = '0'; s[1] = '\\0';\n        return s;\n    }\n\n    neg = (n < 0);\n    if (neg) n = -n;\n\n    /* calculate magnitude */\n    m = nk_log10(n);\n    useExp = (m >= 14 || (neg && m >= 9) || m <= -9);\n    if (neg) *(c++) = '-';\n\n    /* set up for scientific notation */\n    if (useExp) {\n        if (m < 0)\n           m -= 1;\n        n = n / (double)nk_pow(10.0, m);\n        m1 = m;\n        m = 0;\n    }\n    if (m < 1.0) {\n        m = 0;\n    }\n\n    /* convert the number */\n    while (n > NK_FLOAT_PRECISION || m >= 0) {\n        double weight = nk_pow(10.0, m);\n        if (weight > 0) {\n            double t = (double)n / weight;\n            digit = nk_ifloord(t);\n            n -= ((double)digit * weight);\n            *(c++) = (char)('0' + (char)digit);\n        }\n        if (m == 0 && n > 0)\n            *(c++) = '.';\n        m--;\n    }\n\n    if (useExp) {\n        /* convert the exponent */\n        int i, j;\n        *(c++) = 'e';\n        if (m1 > 0) {\n            *(c++) = '+';\n        } else {\n            *(c++) = '-';\n            m1 = -m1;\n        }\n        m = 0;\n        while (m1 > 0) {\n            *(c++) = (char)('0' + (char)(m1 % 10));\n            m1 /= 10;\n            m++;\n        }\n        c -= m;\n        for (i = 0, j = m-1; i<j; i++, j--) {\n            /* swap without temporary */\n            c[i] ^= c[j];\n            c[j] ^= c[i];\n            c[i] ^= c[j];\n        }\n        c += m;\n    }\n    *(c) = '\\0';\n    return s;\n}\n#endif\n#ifdef NK_INCLUDE_STANDARD_VARARGS\n#ifndef NK_INCLUDE_STANDARD_IO\nNK_INTERN int\nnk_vsnprintf(char *buf, int buf_size, const char *fmt, va_list args)\n{\n    enum nk_arg_type {\n        NK_ARG_TYPE_CHAR,\n        NK_ARG_TYPE_SHORT,\n        NK_ARG_TYPE_DEFAULT,\n        NK_ARG_TYPE_LONG\n    };\n    enum nk_arg_flags {\n        NK_ARG_FLAG_LEFT = 0x01,\n        NK_ARG_FLAG_PLUS = 0x02,\n        NK_ARG_FLAG_SPACE = 0x04,\n        NK_ARG_FLAG_NUM = 0x10,\n        NK_ARG_FLAG_ZERO = 0x20\n    };\n\n    char number_buffer[NK_MAX_NUMBER_BUFFER];\n    enum nk_arg_type arg_type = NK_ARG_TYPE_DEFAULT;\n    int precision = NK_DEFAULT;\n    int width = NK_DEFAULT;\n    nk_flags flag = 0;\n\n    int len = 0;\n    int result = -1;\n    const char *iter = fmt;\n\n    NK_ASSERT(buf);\n    NK_ASSERT(buf_size);\n    if (!buf || !buf_size || !fmt) return 0;\n    for (iter = fmt; *iter && len < buf_size; iter++) {\n        /* copy all non-format characters */\n        while (*iter && (*iter != '%') && (len < buf_size))\n            buf[len++] = *iter++;\n        if (!(*iter) || len >= buf_size) break;\n        iter++;\n\n        /* flag arguments */\n        while (*iter) {\n            if (*iter == '-') flag |= NK_ARG_FLAG_LEFT;\n            else if (*iter == '+') flag |= NK_ARG_FLAG_PLUS;\n            else if (*iter == ' ') flag |= NK_ARG_FLAG_SPACE;\n            else if (*iter == '#') flag |= NK_ARG_FLAG_NUM;\n            else if (*iter == '0') flag |= NK_ARG_FLAG_ZERO;\n            else break;\n            iter++;\n        }\n\n        /* width argument */\n        width = NK_DEFAULT;\n        if (*iter >= '1' && *iter <= '9') {\n            char *end;\n            width = nk_strtoi(iter, &end);\n            if (end == iter)\n                width = -1;\n            else iter = end;\n        } else if (*iter == '*') {\n            width = va_arg(args, int);\n            iter++;\n        }\n\n        /* precision argument */\n        precision = NK_DEFAULT;\n        if (*iter == '.') {\n            iter++;\n            if (*iter == '*') {\n                precision = va_arg(args, int);\n                iter++;\n            } else {\n                char *end;\n                precision = nk_strtoi(iter, &end);\n                if (end == iter)\n                    precision = -1;\n                else iter = end;\n            }\n        }\n\n        /* length modifier */\n        if (*iter == 'h') {\n            if (*(iter+1) == 'h') {\n                arg_type = NK_ARG_TYPE_CHAR;\n                iter++;\n            } else arg_type = NK_ARG_TYPE_SHORT;\n            iter++;\n        } else if (*iter == 'l') {\n            arg_type = NK_ARG_TYPE_LONG;\n            iter++;\n        } else arg_type = NK_ARG_TYPE_DEFAULT;\n\n        /* specifier */\n        if (*iter == '%') {\n            NK_ASSERT(arg_type == NK_ARG_TYPE_DEFAULT);\n            NK_ASSERT(precision == NK_DEFAULT);\n            NK_ASSERT(width == NK_DEFAULT);\n            if (len < buf_size)\n                buf[len++] = '%';\n        } else if (*iter == 's') {\n            /* string  */\n            const char *str = va_arg(args, const char*);\n            NK_ASSERT(str != buf && \"buffer and argument are not allowed to overlap!\");\n            NK_ASSERT(arg_type == NK_ARG_TYPE_DEFAULT);\n            NK_ASSERT(precision == NK_DEFAULT);\n            NK_ASSERT(width == NK_DEFAULT);\n            if (str == buf) return -1;\n            while (str && *str && len < buf_size)\n                buf[len++] = *str++;\n        } else if (*iter == 'n') {\n            /* current length callback */\n            signed int *n = va_arg(args, int*);\n            NK_ASSERT(arg_type == NK_ARG_TYPE_DEFAULT);\n            NK_ASSERT(precision == NK_DEFAULT);\n            NK_ASSERT(width == NK_DEFAULT);\n            if (n) *n = len;\n        } else if (*iter == 'c' || *iter == 'i' || *iter == 'd') {\n            /* signed integer */\n            long value = 0;\n            const char *num_iter;\n            int num_len, num_print, padding;\n            int cur_precision = NK_MAX(precision, 1);\n            int cur_width = NK_MAX(width, 0);\n\n            /* retrieve correct value type */\n            if (arg_type == NK_ARG_TYPE_CHAR)\n                value = (signed char)va_arg(args, int);\n            else if (arg_type == NK_ARG_TYPE_SHORT)\n                value = (signed short)va_arg(args, int);\n            else if (arg_type == NK_ARG_TYPE_LONG)\n                value = va_arg(args, signed long);\n            else if (*iter == 'c')\n                value = (unsigned char)va_arg(args, int);\n            else value = va_arg(args, signed int);\n\n            /* convert number to string */\n            nk_itoa(number_buffer, value);\n            num_len = nk_strlen(number_buffer);\n            padding = NK_MAX(cur_width - NK_MAX(cur_precision, num_len), 0);\n            if ((flag & NK_ARG_FLAG_PLUS) || (flag & NK_ARG_FLAG_SPACE))\n                padding = NK_MAX(padding-1, 0);\n\n            /* fill left padding up to a total of `width` characters */\n            if (!(flag & NK_ARG_FLAG_LEFT)) {\n                while (padding-- > 0 && (len < buf_size)) {\n                    if ((flag & NK_ARG_FLAG_ZERO) && (precision == NK_DEFAULT))\n                        buf[len++] = '0';\n                    else buf[len++] = ' ';\n                }\n            }\n\n            /* copy string value representation into buffer */\n            if ((flag & NK_ARG_FLAG_PLUS) && value >= 0 && len < buf_size)\n                buf[len++] = '+';\n            else if ((flag & NK_ARG_FLAG_SPACE) && value >= 0 && len < buf_size)\n                buf[len++] = ' ';\n\n            /* fill up to precision number of digits with '0' */\n            num_print = NK_MAX(cur_precision, num_len);\n            while (precision && (num_print > num_len) && (len < buf_size)) {\n                buf[len++] = '0';\n                num_print--;\n            }\n\n            /* copy string value representation into buffer */\n            num_iter = number_buffer;\n            while (precision && *num_iter && len < buf_size)\n                buf[len++] = *num_iter++;\n\n            /* fill right padding up to width characters */\n            if (flag & NK_ARG_FLAG_LEFT) {\n                while ((padding-- > 0) && (len < buf_size))\n                    buf[len++] = ' ';\n            }\n        } else if (*iter == 'o' || *iter == 'x' || *iter == 'X' || *iter == 'u') {\n            /* unsigned integer */\n            unsigned long value = 0;\n            int num_len = 0, num_print, padding = 0;\n            int cur_precision = NK_MAX(precision, 1);\n            int cur_width = NK_MAX(width, 0);\n            unsigned int base = (*iter == 'o') ? 8: (*iter == 'u')? 10: 16;\n\n            /* print oct/hex/dec value */\n            const char *upper_output_format = \"0123456789ABCDEF\";\n            const char *lower_output_format = \"0123456789abcdef\";\n            const char *output_format = (*iter == 'x') ?\n                lower_output_format: upper_output_format;\n\n            /* retrieve correct value type */\n            if (arg_type == NK_ARG_TYPE_CHAR)\n                value = (unsigned char)va_arg(args, int);\n            else if (arg_type == NK_ARG_TYPE_SHORT)\n                value = (unsigned short)va_arg(args, int);\n            else if (arg_type == NK_ARG_TYPE_LONG)\n                value = va_arg(args, unsigned long);\n            else value = va_arg(args, unsigned int);\n\n            do {\n                /* convert decimal number into hex/oct number */\n                int digit = output_format[value % base];\n                if (num_len < NK_MAX_NUMBER_BUFFER)\n                    number_buffer[num_len++] = (char)digit;\n                value /= base;\n            } while (value > 0);\n\n            num_print = NK_MAX(cur_precision, num_len);\n            padding = NK_MAX(cur_width - NK_MAX(cur_precision, num_len), 0);\n            if (flag & NK_ARG_FLAG_NUM)\n                padding = NK_MAX(padding-1, 0);\n\n            /* fill left padding up to a total of `width` characters */\n            if (!(flag & NK_ARG_FLAG_LEFT)) {\n                while ((padding-- > 0) && (len < buf_size)) {\n                    if ((flag & NK_ARG_FLAG_ZERO) && (precision == NK_DEFAULT))\n                        buf[len++] = '0';\n                    else buf[len++] = ' ';\n                }\n            }\n\n            /* fill up to precision number of digits */\n            if (num_print && (flag & NK_ARG_FLAG_NUM)) {\n                if ((*iter == 'o') && (len < buf_size)) {\n                    buf[len++] = '0';\n                } else if ((*iter == 'x') && ((len+1) < buf_size)) {\n                    buf[len++] = '0';\n                    buf[len++] = 'x';\n                } else if ((*iter == 'X') && ((len+1) < buf_size)) {\n                    buf[len++] = '0';\n                    buf[len++] = 'X';\n                }\n            }\n            while (precision && (num_print > num_len) && (len < buf_size)) {\n                buf[len++] = '0';\n                num_print--;\n            }\n\n            /* reverse number direction */\n            while (num_len > 0) {\n                if (precision && (len < buf_size))\n                    buf[len++] = number_buffer[num_len-1];\n                num_len--;\n            }\n\n            /* fill right padding up to width characters */\n            if (flag & NK_ARG_FLAG_LEFT) {\n                while ((padding-- > 0) && (len < buf_size))\n                    buf[len++] = ' ';\n            }\n        } else if (*iter == 'f') {\n            /* floating point */\n            const char *num_iter;\n            int cur_precision = (precision < 0) ? 6: precision;\n            int prefix, cur_width = NK_MAX(width, 0);\n            double value = va_arg(args, double);\n            int num_len = 0, frac_len = 0, dot = 0;\n            int padding = 0;\n\n            NK_ASSERT(arg_type == NK_ARG_TYPE_DEFAULT);\n            NK_DTOA(number_buffer, value);\n            num_len = nk_strlen(number_buffer);\n\n            /* calculate padding */\n            num_iter = number_buffer;\n            while (*num_iter && *num_iter != '.')\n                num_iter++;\n\n            prefix = (*num_iter == '.')?(int)(num_iter - number_buffer)+1:0;\n            padding = NK_MAX(cur_width - (prefix + NK_MIN(cur_precision, num_len - prefix)) , 0);\n            if ((flag & NK_ARG_FLAG_PLUS) || (flag & NK_ARG_FLAG_SPACE))\n                padding = NK_MAX(padding-1, 0);\n\n            /* fill left padding up to a total of `width` characters */\n            if (!(flag & NK_ARG_FLAG_LEFT)) {\n                while (padding-- > 0 && (len < buf_size)) {\n                    if (flag & NK_ARG_FLAG_ZERO)\n                        buf[len++] = '0';\n                    else buf[len++] = ' ';\n                }\n            }\n\n            /* copy string value representation into buffer */\n            num_iter = number_buffer;\n            if ((flag & NK_ARG_FLAG_PLUS) && (value >= 0) && (len < buf_size))\n                buf[len++] = '+';\n            else if ((flag & NK_ARG_FLAG_SPACE) && (value >= 0) && (len < buf_size))\n                buf[len++] = ' ';\n            while (*num_iter) {\n                if (dot) frac_len++;\n                if (len < buf_size)\n                    buf[len++] = *num_iter;\n                if (*num_iter == '.') dot = 1;\n                if (frac_len >= cur_precision) break;\n                num_iter++;\n            }\n\n            /* fill number up to precision */\n            while (frac_len < cur_precision) {\n                if (!dot && len < buf_size) {\n                    buf[len++] = '.';\n                    dot = 1;\n                }\n                if (len < buf_size)\n                    buf[len++] = '0';\n                frac_len++;\n            }\n\n            /* fill right padding up to width characters */\n            if (flag & NK_ARG_FLAG_LEFT) {\n                while ((padding-- > 0) && (len < buf_size))\n                    buf[len++] = ' ';\n            }\n        } else {\n            /* Specifier not supported: g,G,e,E,p,z */\n            NK_ASSERT(0 && \"specifier is not supported!\");\n            return result;\n        }\n    }\n    buf[(len >= buf_size)?(buf_size-1):len] = 0;\n    result = (len >= buf_size)?-1:len;\n    return result;\n}\n#endif\nNK_LIB int\nnk_strfmt(char *buf, int buf_size, const char *fmt, va_list args)\n{\n    int result = -1;\n    NK_ASSERT(buf);\n    NK_ASSERT(buf_size);\n    if (!buf || !buf_size || !fmt) return 0;\n#ifdef NK_INCLUDE_STANDARD_IO\n    result = NK_VSNPRINTF(buf, (nk_size)buf_size, fmt, args);\n    result = (result >= buf_size) ? -1: result;\n    buf[buf_size-1] = 0;\n#else\n    result = nk_vsnprintf(buf, buf_size, fmt, args);\n#endif\n    return result;\n}\n#endif\nNK_API nk_hash\nnk_murmur_hash(const void * key, int len, nk_hash seed)\n{\n    /* 32-Bit MurmurHash3: https://code.google.com/p/smhasher/wiki/MurmurHash3*/\n    #define NK_ROTL(x,r) ((x) << (r) | ((x) >> (32 - r)))\n\n    nk_uint h1 = seed;\n    nk_uint k1;\n    const nk_byte *data = (const nk_byte*)key;\n    const nk_byte *keyptr = data;\n    nk_byte *k1ptr;\n    const int bsize = sizeof(k1);\n    const int nblocks = len/4;\n\n    const nk_uint c1 = 0xcc9e2d51;\n    const nk_uint c2 = 0x1b873593;\n    const nk_byte *tail;\n    int i;\n\n    /* body */\n    if (!key) return 0;\n    for (i = 0; i < nblocks; ++i, keyptr += bsize) {\n        k1ptr = (nk_byte*)&k1;\n        k1ptr[0] = keyptr[0];\n        k1ptr[1] = keyptr[1];\n        k1ptr[2] = keyptr[2];\n        k1ptr[3] = keyptr[3];\n\n        k1 *= c1;\n        k1 = NK_ROTL(k1,15);\n        k1 *= c2;\n\n        h1 ^= k1;\n        h1 = NK_ROTL(h1,13);\n        h1 = h1*5+0xe6546b64;\n    }\n\n    /* tail */\n    tail = (const nk_byte*)(data + nblocks*4);\n    k1 = 0;\n    switch (len & 3) {\n        case 3: k1 ^= (nk_uint)(tail[2] << 16); /* fallthrough */\n        case 2: k1 ^= (nk_uint)(tail[1] << 8u); /* fallthrough */\n        case 1: k1 ^= tail[0];\n            k1 *= c1;\n            k1 = NK_ROTL(k1,15);\n            k1 *= c2;\n            h1 ^= k1;\n            break;\n        default: break;\n    }\n\n    /* finalization */\n    h1 ^= (nk_uint)len;\n    /* fmix32 */\n    h1 ^= h1 >> 16;\n    h1 *= 0x85ebca6b;\n    h1 ^= h1 >> 13;\n    h1 *= 0xc2b2ae35;\n    h1 ^= h1 >> 16;\n\n    #undef NK_ROTL\n    return h1;\n}\n#ifdef NK_INCLUDE_STANDARD_IO\nNK_LIB char*\nnk_file_load(const char* path, nk_size* siz, const struct nk_allocator *alloc)\n{\n    char *buf;\n    FILE *fd;\n    long ret;\n\n    NK_ASSERT(path);\n    NK_ASSERT(siz);\n    NK_ASSERT(alloc);\n    if (!path || !siz || !alloc)\n        return 0;\n\n    fd = fopen(path, \"rb\");\n    if (!fd) return 0;\n    fseek(fd, 0, SEEK_END);\n    ret = ftell(fd);\n    if (ret < 0) {\n        fclose(fd);\n        return 0;\n    }\n    *siz = (nk_size)ret;\n    fseek(fd, 0, SEEK_SET);\n    buf = (char*)alloc->alloc(alloc->userdata,0, *siz);\n    NK_ASSERT(buf);\n    if (!buf) {\n        fclose(fd);\n        return 0;\n    }\n    *siz = (nk_size)fread(buf, 1,*siz, fd);\n    fclose(fd);\n    return buf;\n}\n#endif\nNK_LIB int\nnk_text_clamp(const struct nk_user_font *font, const char *text,\n    int text_len, float space, int *glyphs, float *text_width,\n    nk_rune *sep_list, int sep_count)\n{\n    int i = 0;\n    int glyph_len = 0;\n    float last_width = 0;\n    nk_rune unicode = 0;\n    float width = 0;\n    int len = 0;\n    int g = 0;\n    float s;\n\n    int sep_len = 0;\n    int sep_g = 0;\n    float sep_width = 0;\n    sep_count = NK_MAX(sep_count,0);\n\n    glyph_len = nk_utf_decode(text, &unicode, text_len);\n    while (glyph_len && (width < space) && (len < text_len)) {\n        len += glyph_len;\n        s = font->width(font->userdata, font->height, text, len);\n        for (i = 0; i < sep_count; ++i) {\n            if (unicode != sep_list[i]) continue;\n            sep_width = last_width = width;\n            sep_g = g+1;\n            sep_len = len;\n            break;\n        }\n        if (i == sep_count){\n            last_width = sep_width = width;\n            sep_g = g+1;\n        }\n        width = s;\n        glyph_len = nk_utf_decode(&text[len], &unicode, text_len - len);\n        g++;\n    }\n    if (len >= text_len) {\n        *glyphs = g;\n        *text_width = last_width;\n        return len;\n    } else {\n        *glyphs = sep_g;\n        *text_width = sep_width;\n        return (!sep_len) ? len: sep_len;\n    }\n}\nNK_LIB struct nk_vec2\nnk_text_calculate_text_bounds(const struct nk_user_font *font,\n    const char *begin, int byte_len, float row_height, const char **remaining,\n    struct nk_vec2 *out_offset, int *glyphs, int op)\n{\n    float line_height = row_height;\n    struct nk_vec2 text_size = nk_vec2(0,0);\n    float line_width = 0.0f;\n\n    float glyph_width;\n    int glyph_len = 0;\n    nk_rune unicode = 0;\n    int text_len = 0;\n    if (!begin || byte_len <= 0 || !font)\n        return nk_vec2(0,row_height);\n\n    glyph_len = nk_utf_decode(begin, &unicode, byte_len);\n    if (!glyph_len) return text_size;\n    glyph_width = font->width(font->userdata, font->height, begin, glyph_len);\n\n    *glyphs = 0;\n    while ((text_len < byte_len) && glyph_len) {\n        if (unicode == '\\n') {\n            text_size.x = NK_MAX(text_size.x, line_width);\n            text_size.y += line_height;\n            line_width = 0;\n            *glyphs+=1;\n            if (op == NK_STOP_ON_NEW_LINE)\n                break;\n\n            text_len++;\n            glyph_len = nk_utf_decode(begin + text_len, &unicode, byte_len-text_len);\n            continue;\n        }\n\n        if (unicode == '\\r') {\n            text_len++;\n            *glyphs+=1;\n            glyph_len = nk_utf_decode(begin + text_len, &unicode, byte_len-text_len);\n            continue;\n        }\n\n        *glyphs = *glyphs + 1;\n        text_len += glyph_len;\n        line_width += (float)glyph_width;\n        glyph_len = nk_utf_decode(begin + text_len, &unicode, byte_len-text_len);\n        glyph_width = font->width(font->userdata, font->height, begin+text_len, glyph_len);\n        continue;\n    }\n\n    if (text_size.x < line_width)\n        text_size.x = line_width;\n    if (out_offset)\n        *out_offset = nk_vec2(line_width, text_size.y + line_height);\n    if (line_width > 0 || text_size.y == 0.0f)\n        text_size.y += line_height;\n    if (remaining)\n        *remaining = begin+text_len;\n    return text_size;\n}\n\n\n\n\n\n/* ==============================================================\n *\n *                          COLOR\n *\n * ===============================================================*/\nNK_INTERN int\nnk_parse_hex(const char *p, int length)\n{\n    int i = 0;\n    int len = 0;\n    while (len < length) {\n        i <<= 4;\n        if (p[len] >= 'a' && p[len] <= 'f')\n            i += ((p[len] - 'a') + 10);\n        else if (p[len] >= 'A' && p[len] <= 'F')\n            i += ((p[len] - 'A') + 10);\n        else i += (p[len] - '0');\n        len++;\n    }\n    return i;\n}\nNK_API struct nk_color\nnk_rgb_factor(struct nk_color col, float factor)\n{\n    if (factor == 1.0f)\n        return col;\n    col.r = (nk_byte)(col.r * factor);\n    col.g = (nk_byte)(col.g * factor);\n    col.b = (nk_byte)(col.b * factor);\n    return col;\n}\nNK_API struct nk_color\nnk_rgba(int r, int g, int b, int a)\n{\n    struct nk_color ret;\n    ret.r = (nk_byte)NK_CLAMP(0, r, 255);\n    ret.g = (nk_byte)NK_CLAMP(0, g, 255);\n    ret.b = (nk_byte)NK_CLAMP(0, b, 255);\n    ret.a = (nk_byte)NK_CLAMP(0, a, 255);\n    return ret;\n}\nNK_API struct nk_color\nnk_rgb_hex(const char *rgb)\n{\n    struct nk_color col;\n    const char *c = rgb;\n    if (*c == '#') c++;\n    col.r = (nk_byte)nk_parse_hex(c, 2);\n    col.g = (nk_byte)nk_parse_hex(c+2, 2);\n    col.b = (nk_byte)nk_parse_hex(c+4, 2);\n    col.a = 255;\n    return col;\n}\nNK_API struct nk_color\nnk_rgba_hex(const char *rgb)\n{\n    struct nk_color col;\n    const char *c = rgb;\n    if (*c == '#') c++;\n    col.r = (nk_byte)nk_parse_hex(c, 2);\n    col.g = (nk_byte)nk_parse_hex(c+2, 2);\n    col.b = (nk_byte)nk_parse_hex(c+4, 2);\n    col.a = (nk_byte)nk_parse_hex(c+6, 2);\n    return col;\n}\nNK_API void\nnk_color_hex_rgba(char *output, struct nk_color col)\n{\n    #define NK_TO_HEX(i) ((i) <= 9 ? '0' + (i): 'A' - 10 + (i))\n    output[0] = (char)NK_TO_HEX((col.r & 0xF0) >> 4);\n    output[1] = (char)NK_TO_HEX((col.r & 0x0F));\n    output[2] = (char)NK_TO_HEX((col.g & 0xF0) >> 4);\n    output[3] = (char)NK_TO_HEX((col.g & 0x0F));\n    output[4] = (char)NK_TO_HEX((col.b & 0xF0) >> 4);\n    output[5] = (char)NK_TO_HEX((col.b & 0x0F));\n    output[6] = (char)NK_TO_HEX((col.a & 0xF0) >> 4);\n    output[7] = (char)NK_TO_HEX((col.a & 0x0F));\n    output[8] = '\\0';\n    #undef NK_TO_HEX\n}\nNK_API void\nnk_color_hex_rgb(char *output, struct nk_color col)\n{\n    #define NK_TO_HEX(i) ((i) <= 9 ? '0' + (i): 'A' - 10 + (i))\n    output[0] = (char)NK_TO_HEX((col.r & 0xF0) >> 4);\n    output[1] = (char)NK_TO_HEX((col.r & 0x0F));\n    output[2] = (char)NK_TO_HEX((col.g & 0xF0) >> 4);\n    output[3] = (char)NK_TO_HEX((col.g & 0x0F));\n    output[4] = (char)NK_TO_HEX((col.b & 0xF0) >> 4);\n    output[5] = (char)NK_TO_HEX((col.b & 0x0F));\n    output[6] = '\\0';\n    #undef NK_TO_HEX\n}\nNK_API struct nk_color\nnk_rgba_iv(const int *c)\n{\n    return nk_rgba(c[0], c[1], c[2], c[3]);\n}\nNK_API struct nk_color\nnk_rgba_bv(const nk_byte *c)\n{\n    return nk_rgba(c[0], c[1], c[2], c[3]);\n}\nNK_API struct nk_color\nnk_rgb(int r, int g, int b)\n{\n    struct nk_color ret;\n    ret.r = (nk_byte)NK_CLAMP(0, r, 255);\n    ret.g = (nk_byte)NK_CLAMP(0, g, 255);\n    ret.b = (nk_byte)NK_CLAMP(0, b, 255);\n    ret.a = (nk_byte)255;\n    return ret;\n}\nNK_API struct nk_color\nnk_rgb_iv(const int *c)\n{\n    return nk_rgb(c[0], c[1], c[2]);\n}\nNK_API struct nk_color\nnk_rgb_bv(const nk_byte* c)\n{\n    return nk_rgb(c[0], c[1], c[2]);\n}\nNK_API struct nk_color\nnk_rgba_u32(nk_uint in)\n{\n    struct nk_color ret;\n    ret.r = (in & 0xFF);\n    ret.g = ((in >> 8) & 0xFF);\n    ret.b = ((in >> 16) & 0xFF);\n    ret.a = (nk_byte)((in >> 24) & 0xFF);\n    return ret;\n}\nNK_API struct nk_color\nnk_rgba_f(float r, float g, float b, float a)\n{\n    struct nk_color ret;\n    ret.r = (nk_byte)(NK_SATURATE(r) * 255.0f);\n    ret.g = (nk_byte)(NK_SATURATE(g) * 255.0f);\n    ret.b = (nk_byte)(NK_SATURATE(b) * 255.0f);\n    ret.a = (nk_byte)(NK_SATURATE(a) * 255.0f);\n    return ret;\n}\nNK_API struct nk_color\nnk_rgba_fv(const float *c)\n{\n    return nk_rgba_f(c[0], c[1], c[2], c[3]);\n}\nNK_API struct nk_color\nnk_rgba_cf(struct nk_colorf c)\n{\n    return nk_rgba_f(c.r, c.g, c.b, c.a);\n}\nNK_API struct nk_color\nnk_rgb_f(float r, float g, float b)\n{\n    struct nk_color ret;\n    ret.r = (nk_byte)(NK_SATURATE(r) * 255.0f);\n    ret.g = (nk_byte)(NK_SATURATE(g) * 255.0f);\n    ret.b = (nk_byte)(NK_SATURATE(b) * 255.0f);\n    ret.a = 255;\n    return ret;\n}\nNK_API struct nk_color\nnk_rgb_fv(const float *c)\n{\n    return nk_rgb_f(c[0], c[1], c[2]);\n}\nNK_API struct nk_color\nnk_rgb_cf(struct nk_colorf c)\n{\n    return nk_rgb_f(c.r, c.g, c.b);\n}\nNK_API struct nk_color\nnk_hsv(int h, int s, int v)\n{\n    return nk_hsva(h, s, v, 255);\n}\nNK_API struct nk_color\nnk_hsv_iv(const int *c)\n{\n    return nk_hsv(c[0], c[1], c[2]);\n}\nNK_API struct nk_color\nnk_hsv_bv(const nk_byte *c)\n{\n    return nk_hsv(c[0], c[1], c[2]);\n}\nNK_API struct nk_color\nnk_hsv_f(float h, float s, float v)\n{\n    return nk_hsva_f(h, s, v, 1.0f);\n}\nNK_API struct nk_color\nnk_hsv_fv(const float *c)\n{\n    return nk_hsv_f(c[0], c[1], c[2]);\n}\nNK_API struct nk_color\nnk_hsva(int h, int s, int v, int a)\n{\n    float hf = ((float)NK_CLAMP(0, h, 255)) / 255.0f;\n    float sf = ((float)NK_CLAMP(0, s, 255)) / 255.0f;\n    float vf = ((float)NK_CLAMP(0, v, 255)) / 255.0f;\n    float af = ((float)NK_CLAMP(0, a, 255)) / 255.0f;\n    return nk_hsva_f(hf, sf, vf, af);\n}\nNK_API struct nk_color\nnk_hsva_iv(const int *c)\n{\n    return nk_hsva(c[0], c[1], c[2], c[3]);\n}\nNK_API struct nk_color\nnk_hsva_bv(const nk_byte *c)\n{\n    return nk_hsva(c[0], c[1], c[2], c[3]);\n}\nNK_API struct nk_colorf\nnk_hsva_colorf(float h, float s, float v, float a)\n{\n    int i;\n    float p, q, t, f;\n    struct nk_colorf out = {0,0,0,0};\n    if (s <= 0.0f) {\n        out.r = v; out.g = v; out.b = v; out.a = a;\n        return out;\n    }\n    h = h / (60.0f/360.0f);\n    i = (int)h;\n    f = h - (float)i;\n    p = v * (1.0f - s);\n    q = v * (1.0f - (s * f));\n    t = v * (1.0f - s * (1.0f - f));\n\n    switch (i) {\n    case 0: default: out.r = v; out.g = t; out.b = p; break;\n    case 1: out.r = q; out.g = v; out.b = p; break;\n    case 2: out.r = p; out.g = v; out.b = t; break;\n    case 3: out.r = p; out.g = q; out.b = v; break;\n    case 4: out.r = t; out.g = p; out.b = v; break;\n    case 5: out.r = v; out.g = p; out.b = q; break;}\n    out.a = a;\n    return out;\n}\nNK_API struct nk_colorf\nnk_hsva_colorfv(const float *c)\n{\n    return nk_hsva_colorf(c[0], c[1], c[2], c[3]);\n}\nNK_API struct nk_color\nnk_hsva_f(float h, float s, float v, float a)\n{\n    struct nk_colorf c = nk_hsva_colorf(h, s, v, a);\n    return nk_rgba_f(c.r, c.g, c.b, c.a);\n}\nNK_API struct nk_color\nnk_hsva_fv(const float *c)\n{\n    return nk_hsva_f(c[0], c[1], c[2], c[3]);\n}\nNK_API nk_uint\nnk_color_u32(struct nk_color in)\n{\n    nk_uint out = (nk_uint)in.r;\n    out |= ((nk_uint)in.g << 8);\n    out |= ((nk_uint)in.b << 16);\n    out |= ((nk_uint)in.a << 24);\n    return out;\n}\nNK_API void\nnk_color_f(float *r, float *g, float *b, float *a, struct nk_color in)\n{\n    NK_STORAGE const float s = 1.0f/255.0f;\n    *r = (float)in.r * s;\n    *g = (float)in.g * s;\n    *b = (float)in.b * s;\n    *a = (float)in.a * s;\n}\nNK_API void\nnk_color_fv(float *c, struct nk_color in)\n{\n    nk_color_f(&c[0], &c[1], &c[2], &c[3], in);\n}\nNK_API struct nk_colorf\nnk_color_cf(struct nk_color in)\n{\n    struct nk_colorf o;\n    nk_color_f(&o.r, &o.g, &o.b, &o.a, in);\n    return o;\n}\nNK_API void\nnk_color_d(double *r, double *g, double *b, double *a, struct nk_color in)\n{\n    NK_STORAGE const double s = 1.0/255.0;\n    *r = (double)in.r * s;\n    *g = (double)in.g * s;\n    *b = (double)in.b * s;\n    *a = (double)in.a * s;\n}\nNK_API void\nnk_color_dv(double *c, struct nk_color in)\n{\n    nk_color_d(&c[0], &c[1], &c[2], &c[3], in);\n}\nNK_API void\nnk_color_hsv_f(float *out_h, float *out_s, float *out_v, struct nk_color in)\n{\n    float a;\n    nk_color_hsva_f(out_h, out_s, out_v, &a, in);\n}\nNK_API void\nnk_color_hsv_fv(float *out, struct nk_color in)\n{\n    float a;\n    nk_color_hsva_f(&out[0], &out[1], &out[2], &a, in);\n}\nNK_API void\nnk_colorf_hsva_f(float *out_h, float *out_s,\n    float *out_v, float *out_a, struct nk_colorf in)\n{\n    float chroma;\n    float K = 0.0f;\n    if (in.g < in.b) {\n        const float t = in.g; in.g = in.b; in.b = t;\n        K = -1.f;\n    }\n    if (in.r < in.g) {\n        const float t = in.r; in.r = in.g; in.g = t;\n        K = -2.f/6.0f - K;\n    }\n    chroma = in.r - ((in.g < in.b) ? in.g: in.b);\n    *out_h = NK_ABS(K + (in.g - in.b)/(6.0f * chroma + 1e-20f));\n    *out_s = chroma / (in.r + 1e-20f);\n    *out_v = in.r;\n    *out_a = in.a;\n\n}\nNK_API void\nnk_colorf_hsva_fv(float *hsva, struct nk_colorf in)\n{\n    nk_colorf_hsva_f(&hsva[0], &hsva[1], &hsva[2], &hsva[3], in);\n}\nNK_API void\nnk_color_hsva_f(float *out_h, float *out_s,\n    float *out_v, float *out_a, struct nk_color in)\n{\n    struct nk_colorf col;\n    nk_color_f(&col.r,&col.g,&col.b,&col.a, in);\n    nk_colorf_hsva_f(out_h, out_s, out_v, out_a, col);\n}\nNK_API void\nnk_color_hsva_fv(float *out, struct nk_color in)\n{\n    nk_color_hsva_f(&out[0], &out[1], &out[2], &out[3], in);\n}\nNK_API void\nnk_color_hsva_i(int *out_h, int *out_s, int *out_v,\n                int *out_a, struct nk_color in)\n{\n    float h,s,v,a;\n    nk_color_hsva_f(&h, &s, &v, &a, in);\n    *out_h = (nk_byte)(h * 255.0f);\n    *out_s = (nk_byte)(s * 255.0f);\n    *out_v = (nk_byte)(v * 255.0f);\n    *out_a = (nk_byte)(a * 255.0f);\n}\nNK_API void\nnk_color_hsva_iv(int *out, struct nk_color in)\n{\n    nk_color_hsva_i(&out[0], &out[1], &out[2], &out[3], in);\n}\nNK_API void\nnk_color_hsva_bv(nk_byte *out, struct nk_color in)\n{\n    int tmp[4];\n    nk_color_hsva_i(&tmp[0], &tmp[1], &tmp[2], &tmp[3], in);\n    out[0] = (nk_byte)tmp[0];\n    out[1] = (nk_byte)tmp[1];\n    out[2] = (nk_byte)tmp[2];\n    out[3] = (nk_byte)tmp[3];\n}\nNK_API void\nnk_color_hsva_b(nk_byte *h, nk_byte *s, nk_byte *v, nk_byte *a, struct nk_color in)\n{\n    int tmp[4];\n    nk_color_hsva_i(&tmp[0], &tmp[1], &tmp[2], &tmp[3], in);\n    *h = (nk_byte)tmp[0];\n    *s = (nk_byte)tmp[1];\n    *v = (nk_byte)tmp[2];\n    *a = (nk_byte)tmp[3];\n}\nNK_API void\nnk_color_hsv_i(int *out_h, int *out_s, int *out_v, struct nk_color in)\n{\n    int a;\n    nk_color_hsva_i(out_h, out_s, out_v, &a, in);\n}\nNK_API void\nnk_color_hsv_b(nk_byte *out_h, nk_byte *out_s, nk_byte *out_v, struct nk_color in)\n{\n    int tmp[4];\n    nk_color_hsva_i(&tmp[0], &tmp[1], &tmp[2], &tmp[3], in);\n    *out_h = (nk_byte)tmp[0];\n    *out_s = (nk_byte)tmp[1];\n    *out_v = (nk_byte)tmp[2];\n}\nNK_API void\nnk_color_hsv_iv(int *out, struct nk_color in)\n{\n    nk_color_hsv_i(&out[0], &out[1], &out[2], in);\n}\nNK_API void\nnk_color_hsv_bv(nk_byte *out, struct nk_color in)\n{\n    int tmp[4];\n    nk_color_hsv_i(&tmp[0], &tmp[1], &tmp[2], in);\n    out[0] = (nk_byte)tmp[0];\n    out[1] = (nk_byte)tmp[1];\n    out[2] = (nk_byte)tmp[2];\n}\n\n\n\n\n/* ===============================================================\n *\n *                              UTF-8\n *\n * ===============================================================*/\nNK_GLOBAL const nk_byte nk_utfbyte[NK_UTF_SIZE+1] = {0x80, 0, 0xC0, 0xE0, 0xF0};\nNK_GLOBAL const nk_byte nk_utfmask[NK_UTF_SIZE+1] = {0xC0, 0x80, 0xE0, 0xF0, 0xF8};\nNK_GLOBAL const nk_uint nk_utfmin[NK_UTF_SIZE+1] = {0, 0, 0x80, 0x800, 0x10000};\nNK_GLOBAL const nk_uint nk_utfmax[NK_UTF_SIZE+1] = {0x10FFFF, 0x7F, 0x7FF, 0xFFFF, 0x10FFFF};\n\nNK_INTERN int\nnk_utf_validate(nk_rune *u, int i)\n{\n    NK_ASSERT(u);\n    if (!u) return 0;\n    if (!NK_BETWEEN(*u, nk_utfmin[i], nk_utfmax[i]) ||\n         NK_BETWEEN(*u, 0xD800, 0xDFFF))\n            *u = NK_UTF_INVALID;\n    for (i = 1; *u > nk_utfmax[i]; ++i);\n    return i;\n}\nNK_INTERN nk_rune\nnk_utf_decode_byte(char c, int *i)\n{\n    NK_ASSERT(i);\n    if (!i) return 0;\n    for(*i = 0; *i < (int)NK_LEN(nk_utfmask); ++(*i)) {\n        if (((nk_byte)c & nk_utfmask[*i]) == nk_utfbyte[*i])\n            return (nk_byte)(c & ~nk_utfmask[*i]);\n    }\n    return 0;\n}\nNK_API int\nnk_utf_decode(const char *c, nk_rune *u, int clen)\n{\n    int i, j, len, type=0;\n    nk_rune udecoded;\n\n    NK_ASSERT(c);\n    NK_ASSERT(u);\n\n    if (!c || !u) return 0;\n    if (!clen) return 0;\n    *u = NK_UTF_INVALID;\n\n    udecoded = nk_utf_decode_byte(c[0], &len);\n    if (!NK_BETWEEN(len, 1, NK_UTF_SIZE))\n        return 1;\n\n    for (i = 1, j = 1; i < clen && j < len; ++i, ++j) {\n        udecoded = (udecoded << 6) | nk_utf_decode_byte(c[i], &type);\n        if (type != 0)\n            return j;\n    }\n    if (j < len)\n        return 0;\n    *u = udecoded;\n    nk_utf_validate(u, len);\n    return len;\n}\nNK_INTERN char\nnk_utf_encode_byte(nk_rune u, int i)\n{\n    return (char)((nk_utfbyte[i]) | ((nk_byte)u & ~nk_utfmask[i]));\n}\nNK_API int\nnk_utf_encode(nk_rune u, char *c, int clen)\n{\n    int len, i;\n    len = nk_utf_validate(&u, 0);\n    if (clen < len || !len || len > NK_UTF_SIZE)\n        return 0;\n\n    for (i = len - 1; i != 0; --i) {\n        c[i] = nk_utf_encode_byte(u, 0);\n        u >>= 6;\n    }\n    c[0] = nk_utf_encode_byte(u, len);\n    return len;\n}\nNK_API int\nnk_utf_len(const char *str, int len)\n{\n    const char *text;\n    int glyphs = 0;\n    int text_len;\n    int glyph_len;\n    int src_len = 0;\n    nk_rune unicode;\n\n    NK_ASSERT(str);\n    if (!str || !len) return 0;\n\n    text = str;\n    text_len = len;\n    glyph_len = nk_utf_decode(text, &unicode, text_len);\n    while (glyph_len && src_len < len) {\n        glyphs++;\n        src_len = src_len + glyph_len;\n        glyph_len = nk_utf_decode(text + src_len, &unicode, text_len - src_len);\n    }\n    return glyphs;\n}\nNK_API const char*\nnk_utf_at(const char *buffer, int length, int index,\n    nk_rune *unicode, int *len)\n{\n    int i = 0;\n    int src_len = 0;\n    int glyph_len = 0;\n    const char *text;\n    int text_len;\n\n    NK_ASSERT(buffer);\n    NK_ASSERT(unicode);\n    NK_ASSERT(len);\n\n    if (!buffer || !unicode || !len) return 0;\n    if (index < 0) {\n        *unicode = NK_UTF_INVALID;\n        *len = 0;\n        return 0;\n    }\n\n    text = buffer;\n    text_len = length;\n    glyph_len = nk_utf_decode(text, unicode, text_len);\n    while (glyph_len) {\n        if (i == index) {\n            *len = glyph_len;\n            break;\n        }\n\n        i++;\n        src_len = src_len + glyph_len;\n        glyph_len = nk_utf_decode(text + src_len, unicode, text_len - src_len);\n    }\n    if (i != index) return 0;\n    return buffer + src_len;\n}\n\n\n\n\n\n/* ==============================================================\n *\n *                          BUFFER\n *\n * ===============================================================*/\n#ifdef NK_INCLUDE_DEFAULT_ALLOCATOR\nNK_LIB void*\nnk_malloc(nk_handle unused, void *old,nk_size size)\n{\n    NK_UNUSED(unused);\n    NK_UNUSED(old);\n    return malloc(size);\n}\nNK_LIB void\nnk_mfree(nk_handle unused, void *ptr)\n{\n    NK_UNUSED(unused);\n    free(ptr);\n}\nNK_API void\nnk_buffer_init_default(struct nk_buffer *buffer)\n{\n    struct nk_allocator alloc;\n    alloc.userdata.ptr = 0;\n    alloc.alloc = nk_malloc;\n    alloc.free = nk_mfree;\n    nk_buffer_init(buffer, &alloc, NK_BUFFER_DEFAULT_INITIAL_SIZE);\n}\n#endif\n\nNK_API void\nnk_buffer_init(struct nk_buffer *b, const struct nk_allocator *a,\n    nk_size initial_size)\n{\n    NK_ASSERT(b);\n    NK_ASSERT(a);\n    NK_ASSERT(initial_size);\n    if (!b || !a || !initial_size) return;\n\n    nk_zero(b, sizeof(*b));\n    b->type = NK_BUFFER_DYNAMIC;\n    b->memory.ptr = a->alloc(a->userdata,0, initial_size);\n    b->memory.size = initial_size;\n    b->size = initial_size;\n    b->grow_factor = 2.0f;\n    b->pool = *a;\n}\nNK_API void\nnk_buffer_init_fixed(struct nk_buffer *b, void *m, nk_size size)\n{\n    NK_ASSERT(b);\n    NK_ASSERT(m);\n    NK_ASSERT(size);\n    if (!b || !m || !size) return;\n\n    nk_zero(b, sizeof(*b));\n    b->type = NK_BUFFER_FIXED;\n    b->memory.ptr = m;\n    b->memory.size = size;\n    b->size = size;\n}\nNK_LIB void*\nnk_buffer_align(void *unaligned,\n    nk_size align, nk_size *alignment,\n    enum nk_buffer_allocation_type type)\n{\n    void *memory = 0;\n    switch (type) {\n    default:\n    case NK_BUFFER_MAX:\n    case NK_BUFFER_FRONT:\n        if (align) {\n            memory = NK_ALIGN_PTR(unaligned, align);\n            *alignment = (nk_size)((nk_byte*)memory - (nk_byte*)unaligned);\n        } else {\n            memory = unaligned;\n            *alignment = 0;\n        }\n        break;\n    case NK_BUFFER_BACK:\n        if (align) {\n            memory = NK_ALIGN_PTR_BACK(unaligned, align);\n            *alignment = (nk_size)((nk_byte*)unaligned - (nk_byte*)memory);\n        } else {\n            memory = unaligned;\n            *alignment = 0;\n        }\n        break;\n    }\n    return memory;\n}\nNK_LIB void*\nnk_buffer_realloc(struct nk_buffer *b, nk_size capacity, nk_size *size)\n{\n    void *temp;\n    nk_size buffer_size;\n\n    NK_ASSERT(b);\n    NK_ASSERT(size);\n    if (!b || !size || !b->pool.alloc || !b->pool.free)\n        return 0;\n\n    buffer_size = b->memory.size;\n    temp = b->pool.alloc(b->pool.userdata, b->memory.ptr, capacity);\n    NK_ASSERT(temp);\n    if (!temp) return 0;\n\n    *size = capacity;\n    if (temp != b->memory.ptr) {\n        NK_MEMCPY(temp, b->memory.ptr, buffer_size);\n        b->pool.free(b->pool.userdata, b->memory.ptr);\n    }\n\n    if (b->size == buffer_size) {\n        /* no back buffer so just set correct size */\n        b->size = capacity;\n        return temp;\n    } else {\n        /* copy back buffer to the end of the new buffer */\n        void *dst, *src;\n        nk_size back_size;\n        back_size = buffer_size - b->size;\n        dst = nk_ptr_add(void, temp, capacity - back_size);\n        src = nk_ptr_add(void, temp, b->size);\n        NK_MEMCPY(dst, src, back_size);\n        b->size = capacity - back_size;\n    }\n    return temp;\n}\nNK_LIB void*\nnk_buffer_alloc(struct nk_buffer *b, enum nk_buffer_allocation_type type,\n    nk_size size, nk_size align)\n{\n    int full;\n    nk_size alignment;\n    void *unaligned;\n    void *memory;\n\n    NK_ASSERT(b);\n    NK_ASSERT(size);\n    if (!b || !size) return 0;\n    b->needed += size;\n\n    /* calculate total size with needed alignment + size */\n    if (type == NK_BUFFER_FRONT)\n        unaligned = nk_ptr_add(void, b->memory.ptr, b->allocated);\n    else unaligned = nk_ptr_add(void, b->memory.ptr, b->size - size);\n    memory = nk_buffer_align(unaligned, align, &alignment, type);\n\n    /* check if buffer has enough memory*/\n    if (type == NK_BUFFER_FRONT)\n        full = ((b->allocated + size + alignment) > b->size);\n    else full = ((b->size - NK_MIN(b->size,(size + alignment))) <= b->allocated);\n\n    if (full) {\n        nk_size capacity;\n        if (b->type != NK_BUFFER_DYNAMIC)\n            return 0;\n        NK_ASSERT(b->pool.alloc && b->pool.free);\n        if (b->type != NK_BUFFER_DYNAMIC || !b->pool.alloc || !b->pool.free)\n            return 0;\n\n        /* buffer is full so allocate bigger buffer if dynamic */\n        capacity = (nk_size)((float)b->memory.size * b->grow_factor);\n        capacity = NK_MAX(capacity, nk_round_up_pow2((nk_uint)(b->allocated + size)));\n        b->memory.ptr = nk_buffer_realloc(b, capacity, &b->memory.size);\n        if (!b->memory.ptr) return 0;\n\n        /* align newly allocated pointer */\n        if (type == NK_BUFFER_FRONT)\n            unaligned = nk_ptr_add(void, b->memory.ptr, b->allocated);\n        else unaligned = nk_ptr_add(void, b->memory.ptr, b->size - size);\n        memory = nk_buffer_align(unaligned, align, &alignment, type);\n    }\n    if (type == NK_BUFFER_FRONT)\n        b->allocated += size + alignment;\n    else b->size -= (size + alignment);\n    b->needed += alignment;\n    b->calls++;\n    return memory;\n}\nNK_API void\nnk_buffer_push(struct nk_buffer *b, enum nk_buffer_allocation_type type,\n    const void *memory, nk_size size, nk_size align)\n{\n    void *mem = nk_buffer_alloc(b, type, size, align);\n    if (!mem) return;\n    NK_MEMCPY(mem, memory, size);\n}\nNK_API void\nnk_buffer_mark(struct nk_buffer *buffer, enum nk_buffer_allocation_type type)\n{\n    NK_ASSERT(buffer);\n    if (!buffer) return;\n    buffer->marker[type].active = nk_true;\n    if (type == NK_BUFFER_BACK)\n        buffer->marker[type].offset = buffer->size;\n    else buffer->marker[type].offset = buffer->allocated;\n}\nNK_API void\nnk_buffer_reset(struct nk_buffer *buffer, enum nk_buffer_allocation_type type)\n{\n    NK_ASSERT(buffer);\n    if (!buffer) return;\n    if (type == NK_BUFFER_BACK) {\n        /* reset back buffer either back to marker or empty */\n        buffer->needed -= (buffer->memory.size - buffer->marker[type].offset);\n        if (buffer->marker[type].active)\n            buffer->size = buffer->marker[type].offset;\n        else buffer->size = buffer->memory.size;\n        buffer->marker[type].active = nk_false;\n    } else {\n        /* reset front buffer either back to back marker or empty */\n        buffer->needed -= (buffer->allocated - buffer->marker[type].offset);\n        if (buffer->marker[type].active)\n            buffer->allocated = buffer->marker[type].offset;\n        else buffer->allocated = 0;\n        buffer->marker[type].active = nk_false;\n    }\n}\nNK_API void\nnk_buffer_clear(struct nk_buffer *b)\n{\n    NK_ASSERT(b);\n    if (!b) return;\n    b->allocated = 0;\n    b->size = b->memory.size;\n    b->calls = 0;\n    b->needed = 0;\n}\nNK_API void\nnk_buffer_free(struct nk_buffer *b)\n{\n    NK_ASSERT(b);\n    if (!b || !b->memory.ptr) return;\n    if (b->type == NK_BUFFER_FIXED) return;\n    if (!b->pool.free) return;\n    NK_ASSERT(b->pool.free);\n    b->pool.free(b->pool.userdata, b->memory.ptr);\n}\nNK_API void\nnk_buffer_info(struct nk_memory_status *s, const struct nk_buffer *b)\n{\n    NK_ASSERT(b);\n    NK_ASSERT(s);\n    if (!s || !b) return;\n    s->allocated = b->allocated;\n    s->size =  b->memory.size;\n    s->needed = b->needed;\n    s->memory = b->memory.ptr;\n    s->calls = b->calls;\n}\nNK_API void*\nnk_buffer_memory(struct nk_buffer *buffer)\n{\n    NK_ASSERT(buffer);\n    if (!buffer) return 0;\n    return buffer->memory.ptr;\n}\nNK_API const void*\nnk_buffer_memory_const(const struct nk_buffer *buffer)\n{\n    NK_ASSERT(buffer);\n    if (!buffer) return 0;\n    return buffer->memory.ptr;\n}\nNK_API nk_size\nnk_buffer_total(const struct nk_buffer *buffer)\n{\n    NK_ASSERT(buffer);\n    if (!buffer) return 0;\n    return buffer->memory.size;\n}\n\n\n\n\n/* ===============================================================\n *\n *                              STRING\n *\n * ===============================================================*/\n#ifdef NK_INCLUDE_DEFAULT_ALLOCATOR\nNK_API void\nnk_str_init_default(struct nk_str *str)\n{\n    struct nk_allocator alloc;\n    alloc.userdata.ptr = 0;\n    alloc.alloc = nk_malloc;\n    alloc.free = nk_mfree;\n    nk_buffer_init(&str->buffer, &alloc, 32);\n    str->len = 0;\n}\n#endif\n\nNK_API void\nnk_str_init(struct nk_str *str, const struct nk_allocator *alloc, nk_size size)\n{\n    nk_buffer_init(&str->buffer, alloc, size);\n    str->len = 0;\n}\nNK_API void\nnk_str_init_fixed(struct nk_str *str, void *memory, nk_size size)\n{\n    nk_buffer_init_fixed(&str->buffer, memory, size);\n    str->len = 0;\n}\nNK_API int\nnk_str_append_text_char(struct nk_str *s, const char *str, int len)\n{\n    char *mem;\n    NK_ASSERT(s);\n    NK_ASSERT(str);\n    if (!s || !str || !len) return 0;\n    mem = (char*)nk_buffer_alloc(&s->buffer, NK_BUFFER_FRONT, (nk_size)len * sizeof(char), 0);\n    if (!mem) return 0;\n    NK_MEMCPY(mem, str, (nk_size)len * sizeof(char));\n    s->len += nk_utf_len(str, len);\n    return len;\n}\nNK_API int\nnk_str_append_str_char(struct nk_str *s, const char *str)\n{\n    return nk_str_append_text_char(s, str, nk_strlen(str));\n}\nNK_API int\nnk_str_append_text_utf8(struct nk_str *str, const char *text, int len)\n{\n    int i = 0;\n    int byte_len = 0;\n    nk_rune unicode;\n    if (!str || !text || !len) return 0;\n    for (i = 0; i < len; ++i)\n        byte_len += nk_utf_decode(text+byte_len, &unicode, 4);\n    nk_str_append_text_char(str, text, byte_len);\n    return len;\n}\nNK_API int\nnk_str_append_str_utf8(struct nk_str *str, const char *text)\n{\n    int byte_len = 0;\n    int num_runes = 0;\n    int glyph_len = 0;\n    nk_rune unicode;\n    if (!str || !text) return 0;\n\n    glyph_len = byte_len = nk_utf_decode(text+byte_len, &unicode, 4);\n    while (unicode != '\\0' && glyph_len) {\n        glyph_len = nk_utf_decode(text+byte_len, &unicode, 4);\n        byte_len += glyph_len;\n        num_runes++;\n    }\n    nk_str_append_text_char(str, text, byte_len);\n    return num_runes;\n}\nNK_API int\nnk_str_append_text_runes(struct nk_str *str, const nk_rune *text, int len)\n{\n    int i = 0;\n    int byte_len = 0;\n    nk_glyph glyph;\n\n    NK_ASSERT(str);\n    if (!str || !text || !len) return 0;\n    for (i = 0; i < len; ++i) {\n        byte_len = nk_utf_encode(text[i], glyph, NK_UTF_SIZE);\n        if (!byte_len) break;\n        nk_str_append_text_char(str, glyph, byte_len);\n    }\n    return len;\n}\nNK_API int\nnk_str_append_str_runes(struct nk_str *str, const nk_rune *runes)\n{\n    int i = 0;\n    nk_glyph glyph;\n    int byte_len;\n    NK_ASSERT(str);\n    if (!str || !runes) return 0;\n    while (runes[i] != '\\0') {\n        byte_len = nk_utf_encode(runes[i], glyph, NK_UTF_SIZE);\n        nk_str_append_text_char(str, glyph, byte_len);\n        i++;\n    }\n    return i;\n}\nNK_API int\nnk_str_insert_at_char(struct nk_str *s, int pos, const char *str, int len)\n{\n    int i;\n    void *mem;\n    char *src;\n    char *dst;\n\n    int copylen;\n    NK_ASSERT(s);\n    NK_ASSERT(str);\n    NK_ASSERT(len >= 0);\n    if (!s || !str || !len || (nk_size)pos > s->buffer.allocated) return 0;\n    if ((s->buffer.allocated + (nk_size)len >= s->buffer.memory.size) &&\n        (s->buffer.type == NK_BUFFER_FIXED)) return 0;\n\n    copylen = (int)s->buffer.allocated - pos;\n    if (!copylen) {\n        nk_str_append_text_char(s, str, len);\n        return 1;\n    }\n    mem = nk_buffer_alloc(&s->buffer, NK_BUFFER_FRONT, (nk_size)len * sizeof(char), 0);\n    if (!mem) return 0;\n\n    /* memmove */\n    NK_ASSERT(((int)pos + (int)len + ((int)copylen - 1)) >= 0);\n    NK_ASSERT(((int)pos + ((int)copylen - 1)) >= 0);\n    dst = nk_ptr_add(char, s->buffer.memory.ptr, pos + len + (copylen - 1));\n    src = nk_ptr_add(char, s->buffer.memory.ptr, pos + (copylen-1));\n    for (i = 0; i < copylen; ++i) *dst-- = *src--;\n    mem = nk_ptr_add(void, s->buffer.memory.ptr, pos);\n    NK_MEMCPY(mem, str, (nk_size)len * sizeof(char));\n    s->len = nk_utf_len((char *)s->buffer.memory.ptr, (int)s->buffer.allocated);\n    return 1;\n}\nNK_API int\nnk_str_insert_at_rune(struct nk_str *str, int pos, const char *cstr, int len)\n{\n    int glyph_len;\n    nk_rune unicode;\n    const char *begin;\n    const char *buffer;\n\n    NK_ASSERT(str);\n    NK_ASSERT(cstr);\n    NK_ASSERT(len);\n    if (!str || !cstr || !len) return 0;\n    begin = nk_str_at_rune(str, pos, &unicode, &glyph_len);\n    if (!str->len)\n        return nk_str_append_text_char(str, cstr, len);\n    buffer = nk_str_get_const(str);\n    if (!begin) return 0;\n    return nk_str_insert_at_char(str, (int)(begin - buffer), cstr, len);\n}\nNK_API int\nnk_str_insert_text_char(struct nk_str *str, int pos, const char *text, int len)\n{\n    return nk_str_insert_text_utf8(str, pos, text, len);\n}\nNK_API int\nnk_str_insert_str_char(struct nk_str *str, int pos, const char *text)\n{\n    return nk_str_insert_text_utf8(str, pos, text, nk_strlen(text));\n}\nNK_API int\nnk_str_insert_text_utf8(struct nk_str *str, int pos, const char *text, int len)\n{\n    int i = 0;\n    int byte_len = 0;\n    nk_rune unicode;\n\n    NK_ASSERT(str);\n    NK_ASSERT(text);\n    if (!str || !text || !len) return 0;\n    for (i = 0; i < len; ++i)\n        byte_len += nk_utf_decode(text+byte_len, &unicode, 4);\n    nk_str_insert_at_rune(str, pos, text, byte_len);\n    return len;\n}\nNK_API int\nnk_str_insert_str_utf8(struct nk_str *str, int pos, const char *text)\n{\n    int byte_len = 0;\n    int num_runes = 0;\n    int glyph_len = 0;\n    nk_rune unicode;\n    if (!str || !text) return 0;\n\n    glyph_len = byte_len = nk_utf_decode(text+byte_len, &unicode, 4);\n    while (unicode != '\\0' && glyph_len) {\n        glyph_len = nk_utf_decode(text+byte_len, &unicode, 4);\n        byte_len += glyph_len;\n        num_runes++;\n    }\n    nk_str_insert_at_rune(str, pos, text, byte_len);\n    return num_runes;\n}\nNK_API int\nnk_str_insert_text_runes(struct nk_str *str, int pos, const nk_rune *runes, int len)\n{\n    int i = 0;\n    int byte_len = 0;\n    nk_glyph glyph;\n\n    NK_ASSERT(str);\n    if (!str || !runes || !len) return 0;\n    for (i = 0; i < len; ++i) {\n        byte_len = nk_utf_encode(runes[i], glyph, NK_UTF_SIZE);\n        if (!byte_len) break;\n        nk_str_insert_at_rune(str, pos+i, glyph, byte_len);\n    }\n    return len;\n}\nNK_API int\nnk_str_insert_str_runes(struct nk_str *str, int pos, const nk_rune *runes)\n{\n    int i = 0;\n    nk_glyph glyph;\n    int byte_len;\n    NK_ASSERT(str);\n    if (!str || !runes) return 0;\n    while (runes[i] != '\\0') {\n        byte_len = nk_utf_encode(runes[i], glyph, NK_UTF_SIZE);\n        nk_str_insert_at_rune(str, pos+i, glyph, byte_len);\n        i++;\n    }\n    return i;\n}\nNK_API void\nnk_str_remove_chars(struct nk_str *s, int len)\n{\n    NK_ASSERT(s);\n    NK_ASSERT(len >= 0);\n    if (!s || len < 0 || (nk_size)len > s->buffer.allocated) return;\n    NK_ASSERT(((int)s->buffer.allocated - (int)len) >= 0);\n    s->buffer.allocated -= (nk_size)len;\n    s->len = nk_utf_len((char *)s->buffer.memory.ptr, (int)s->buffer.allocated);\n}\nNK_API void\nnk_str_remove_runes(struct nk_str *str, int len)\n{\n    int index;\n    const char *begin;\n    const char *end;\n    nk_rune unicode;\n\n    NK_ASSERT(str);\n    NK_ASSERT(len >= 0);\n    if (!str || len < 0) return;\n    if (len >= str->len) {\n        str->len = 0;\n        return;\n    }\n\n    index = str->len - len;\n    begin = nk_str_at_rune(str, index, &unicode, &len);\n    end = (const char*)str->buffer.memory.ptr + str->buffer.allocated;\n    nk_str_remove_chars(str, (int)(end-begin)+1);\n}\nNK_API void\nnk_str_delete_chars(struct nk_str *s, int pos, int len)\n{\n    NK_ASSERT(s);\n    if (!s || !len || (nk_size)pos > s->buffer.allocated ||\n        (nk_size)(pos + len) > s->buffer.allocated) return;\n\n    if ((nk_size)(pos + len) < s->buffer.allocated) {\n        /* memmove */\n        char *dst = nk_ptr_add(char, s->buffer.memory.ptr, pos);\n        char *src = nk_ptr_add(char, s->buffer.memory.ptr, pos + len);\n        NK_MEMCPY(dst, src, s->buffer.allocated - (nk_size)(pos + len));\n        NK_ASSERT(((int)s->buffer.allocated - (int)len) >= 0);\n        s->buffer.allocated -= (nk_size)len;\n    } else nk_str_remove_chars(s, len);\n    s->len = nk_utf_len((char *)s->buffer.memory.ptr, (int)s->buffer.allocated);\n}\nNK_API void\nnk_str_delete_runes(struct nk_str *s, int pos, int len)\n{\n    char *temp;\n    nk_rune unicode;\n    char *begin;\n    char *end;\n    int unused;\n\n    NK_ASSERT(s);\n    NK_ASSERT(s->len >= pos + len);\n    if (s->len < pos + len)\n        len = NK_CLAMP(0, (s->len - pos), s->len);\n    if (!len) return;\n\n    temp = (char *)s->buffer.memory.ptr;\n    begin = nk_str_at_rune(s, pos, &unicode, &unused);\n    if (!begin) return;\n    s->buffer.memory.ptr = begin;\n    end = nk_str_at_rune(s, len, &unicode, &unused);\n    s->buffer.memory.ptr = temp;\n    if (!end) return;\n    nk_str_delete_chars(s, (int)(begin - temp), (int)(end - begin));\n}\nNK_API char*\nnk_str_at_char(struct nk_str *s, int pos)\n{\n    NK_ASSERT(s);\n    if (!s || pos > (int)s->buffer.allocated) return 0;\n    return nk_ptr_add(char, s->buffer.memory.ptr, pos);\n}\nNK_API char*\nnk_str_at_rune(struct nk_str *str, int pos, nk_rune *unicode, int *len)\n{\n    int i = 0;\n    int src_len = 0;\n    int glyph_len = 0;\n    char *text;\n    int text_len;\n\n    NK_ASSERT(str);\n    NK_ASSERT(unicode);\n    NK_ASSERT(len);\n\n    if (!str || !unicode || !len) return 0;\n    if (pos < 0) {\n        *unicode = 0;\n        *len = 0;\n        return 0;\n    }\n\n    text = (char*)str->buffer.memory.ptr;\n    text_len = (int)str->buffer.allocated;\n    glyph_len = nk_utf_decode(text, unicode, text_len);\n    while (glyph_len) {\n        if (i == pos) {\n            *len = glyph_len;\n            break;\n        }\n\n        i++;\n        src_len = src_len + glyph_len;\n        glyph_len = nk_utf_decode(text + src_len, unicode, text_len - src_len);\n    }\n    if (i != pos) return 0;\n    return text + src_len;\n}\nNK_API const char*\nnk_str_at_char_const(const struct nk_str *s, int pos)\n{\n    NK_ASSERT(s);\n    if (!s || pos > (int)s->buffer.allocated) return 0;\n    return nk_ptr_add(char, s->buffer.memory.ptr, pos);\n}\nNK_API const char*\nnk_str_at_const(const struct nk_str *str, int pos, nk_rune *unicode, int *len)\n{\n    int i = 0;\n    int src_len = 0;\n    int glyph_len = 0;\n    char *text;\n    int text_len;\n\n    NK_ASSERT(str);\n    NK_ASSERT(unicode);\n    NK_ASSERT(len);\n\n    if (!str || !unicode || !len) return 0;\n    if (pos < 0) {\n        *unicode = 0;\n        *len = 0;\n        return 0;\n    }\n\n    text = (char*)str->buffer.memory.ptr;\n    text_len = (int)str->buffer.allocated;\n    glyph_len = nk_utf_decode(text, unicode, text_len);\n    while (glyph_len) {\n        if (i == pos) {\n            *len = glyph_len;\n            break;\n        }\n\n        i++;\n        src_len = src_len + glyph_len;\n        glyph_len = nk_utf_decode(text + src_len, unicode, text_len - src_len);\n    }\n    if (i != pos) return 0;\n    return text + src_len;\n}\nNK_API nk_rune\nnk_str_rune_at(const struct nk_str *str, int pos)\n{\n    int len;\n    nk_rune unicode = 0;\n    nk_str_at_const(str, pos, &unicode, &len);\n    return unicode;\n}\nNK_API char*\nnk_str_get(struct nk_str *s)\n{\n    NK_ASSERT(s);\n    if (!s || !s->len || !s->buffer.allocated) return 0;\n    return (char*)s->buffer.memory.ptr;\n}\nNK_API const char*\nnk_str_get_const(const struct nk_str *s)\n{\n    NK_ASSERT(s);\n    if (!s || !s->len || !s->buffer.allocated) return 0;\n    return (const char*)s->buffer.memory.ptr;\n}\nNK_API int\nnk_str_len(const struct nk_str *s)\n{\n    NK_ASSERT(s);\n    if (!s || !s->len || !s->buffer.allocated) return 0;\n    return s->len;\n}\nNK_API int\nnk_str_len_char(const struct nk_str *s)\n{\n    NK_ASSERT(s);\n    if (!s || !s->len || !s->buffer.allocated) return 0;\n    return (int)s->buffer.allocated;\n}\nNK_API void\nnk_str_clear(struct nk_str *str)\n{\n    NK_ASSERT(str);\n    nk_buffer_clear(&str->buffer);\n    str->len = 0;\n}\nNK_API void\nnk_str_free(struct nk_str *str)\n{\n    NK_ASSERT(str);\n    nk_buffer_free(&str->buffer);\n    str->len = 0;\n}\n\n\n\n\n/* ==============================================================\n *\n *                          DRAW\n *\n * ===============================================================*/\nNK_LIB void\nnk_command_buffer_init(struct nk_command_buffer *cb,\n    struct nk_buffer *b, enum nk_command_clipping clip)\n{\n    NK_ASSERT(cb);\n    NK_ASSERT(b);\n    if (!cb || !b) return;\n    cb->base = b;\n    cb->use_clipping = (int)clip;\n    cb->begin = b->allocated;\n    cb->end = b->allocated;\n    cb->last = b->allocated;\n}\nNK_LIB void\nnk_command_buffer_reset(struct nk_command_buffer *b)\n{\n    NK_ASSERT(b);\n    if (!b) return;\n    b->begin = 0;\n    b->end = 0;\n    b->last = 0;\n    b->clip = nk_null_rect;\n#ifdef NK_INCLUDE_COMMAND_USERDATA\n    b->userdata.ptr = 0;\n#endif\n}\nNK_LIB void*\nnk_command_buffer_push(struct nk_command_buffer* b,\n    enum nk_command_type t, nk_size size)\n{\n    NK_STORAGE const nk_size align = NK_ALIGNOF(struct nk_command);\n    struct nk_command *cmd;\n    nk_size alignment;\n    void *unaligned;\n    void *memory;\n\n    NK_ASSERT(b);\n    NK_ASSERT(b->base);\n    if (!b) return 0;\n    cmd = (struct nk_command*)nk_buffer_alloc(b->base,NK_BUFFER_FRONT,size,align);\n    if (!cmd) return 0;\n\n    /* make sure the offset to the next command is aligned */\n    b->last = (nk_size)((nk_byte*)cmd - (nk_byte*)b->base->memory.ptr);\n    unaligned = (nk_byte*)cmd + size;\n    memory = NK_ALIGN_PTR(unaligned, align);\n    alignment = (nk_size)((nk_byte*)memory - (nk_byte*)unaligned);\n#ifdef NK_ZERO_COMMAND_MEMORY\n    NK_MEMSET(cmd, 0, size + alignment);\n#endif\n\n    cmd->type = t;\n    cmd->next = b->base->allocated + alignment;\n#ifdef NK_INCLUDE_COMMAND_USERDATA\n    cmd->userdata = b->userdata;\n#endif\n    b->end = cmd->next;\n    return cmd;\n}\nNK_API void\nnk_push_scissor(struct nk_command_buffer *b, struct nk_rect r)\n{\n    struct nk_command_scissor *cmd;\n    NK_ASSERT(b);\n    if (!b) return;\n\n    b->clip.x = r.x;\n    b->clip.y = r.y;\n    b->clip.w = r.w;\n    b->clip.h = r.h;\n    cmd = (struct nk_command_scissor*)\n        nk_command_buffer_push(b, NK_COMMAND_SCISSOR, sizeof(*cmd));\n\n    if (!cmd) return;\n    cmd->x = (short)r.x;\n    cmd->y = (short)r.y;\n    cmd->w = (unsigned short)NK_MAX(0, r.w);\n    cmd->h = (unsigned short)NK_MAX(0, r.h);\n}\nNK_API void\nnk_stroke_line(struct nk_command_buffer *b, float x0, float y0,\n    float x1, float y1, float line_thickness, struct nk_color c)\n{\n    struct nk_command_line *cmd;\n    NK_ASSERT(b);\n    if (!b || line_thickness <= 0) return;\n    cmd = (struct nk_command_line*)\n        nk_command_buffer_push(b, NK_COMMAND_LINE, sizeof(*cmd));\n    if (!cmd) return;\n    cmd->line_thickness = (unsigned short)line_thickness;\n    cmd->begin.x = (short)x0;\n    cmd->begin.y = (short)y0;\n    cmd->end.x = (short)x1;\n    cmd->end.y = (short)y1;\n    cmd->color = c;\n}\nNK_API void\nnk_stroke_curve(struct nk_command_buffer *b, float ax, float ay,\n    float ctrl0x, float ctrl0y, float ctrl1x, float ctrl1y,\n    float bx, float by, float line_thickness, struct nk_color col)\n{\n    struct nk_command_curve *cmd;\n    NK_ASSERT(b);\n    if (!b || col.a == 0 || line_thickness <= 0) return;\n\n    cmd = (struct nk_command_curve*)\n        nk_command_buffer_push(b, NK_COMMAND_CURVE, sizeof(*cmd));\n    if (!cmd) return;\n    cmd->line_thickness = (unsigned short)line_thickness;\n    cmd->begin.x = (short)ax;\n    cmd->begin.y = (short)ay;\n    cmd->ctrl[0].x = (short)ctrl0x;\n    cmd->ctrl[0].y = (short)ctrl0y;\n    cmd->ctrl[1].x = (short)ctrl1x;\n    cmd->ctrl[1].y = (short)ctrl1y;\n    cmd->end.x = (short)bx;\n    cmd->end.y = (short)by;\n    cmd->color = col;\n}\nNK_API void\nnk_stroke_rect(struct nk_command_buffer *b, struct nk_rect rect,\n    float rounding, float line_thickness, struct nk_color c)\n{\n    struct nk_command_rect *cmd;\n    NK_ASSERT(b);\n    if (!b || c.a == 0 || rect.w == 0 || rect.h == 0 || line_thickness <= 0) return;\n    if (b->use_clipping) {\n        const struct nk_rect *clip = &b->clip;\n        if (!NK_INTERSECT(rect.x, rect.y, rect.w, rect.h,\n            clip->x, clip->y, clip->w, clip->h)) return;\n    }\n    cmd = (struct nk_command_rect*)\n        nk_command_buffer_push(b, NK_COMMAND_RECT, sizeof(*cmd));\n    if (!cmd) return;\n    cmd->rounding = (unsigned short)rounding;\n    cmd->line_thickness = (unsigned short)line_thickness;\n    cmd->x = (short)rect.x;\n    cmd->y = (short)rect.y;\n    cmd->w = (unsigned short)NK_MAX(0, rect.w);\n    cmd->h = (unsigned short)NK_MAX(0, rect.h);\n    cmd->color = c;\n}\nNK_API void\nnk_fill_rect(struct nk_command_buffer *b, struct nk_rect rect,\n    float rounding, struct nk_color c)\n{\n    struct nk_command_rect_filled *cmd;\n    NK_ASSERT(b);\n    if (!b || c.a == 0 || rect.w == 0 || rect.h == 0) return;\n    if (b->use_clipping) {\n        const struct nk_rect *clip = &b->clip;\n        if (!NK_INTERSECT(rect.x, rect.y, rect.w, rect.h,\n            clip->x, clip->y, clip->w, clip->h)) return;\n    }\n\n    cmd = (struct nk_command_rect_filled*)\n        nk_command_buffer_push(b, NK_COMMAND_RECT_FILLED, sizeof(*cmd));\n    if (!cmd) return;\n    cmd->rounding = (unsigned short)rounding;\n    cmd->x = (short)rect.x;\n    cmd->y = (short)rect.y;\n    cmd->w = (unsigned short)NK_MAX(0, rect.w);\n    cmd->h = (unsigned short)NK_MAX(0, rect.h);\n    cmd->color = c;\n}\nNK_API void\nnk_fill_rect_multi_color(struct nk_command_buffer *b, struct nk_rect rect,\n    struct nk_color left, struct nk_color top, struct nk_color right,\n    struct nk_color bottom)\n{\n    struct nk_command_rect_multi_color *cmd;\n    NK_ASSERT(b);\n    if (!b || rect.w == 0 || rect.h == 0) return;\n    if (b->use_clipping) {\n        const struct nk_rect *clip = &b->clip;\n        if (!NK_INTERSECT(rect.x, rect.y, rect.w, rect.h,\n            clip->x, clip->y, clip->w, clip->h)) return;\n    }\n\n    cmd = (struct nk_command_rect_multi_color*)\n        nk_command_buffer_push(b, NK_COMMAND_RECT_MULTI_COLOR, sizeof(*cmd));\n    if (!cmd) return;\n    cmd->x = (short)rect.x;\n    cmd->y = (short)rect.y;\n    cmd->w = (unsigned short)NK_MAX(0, rect.w);\n    cmd->h = (unsigned short)NK_MAX(0, rect.h);\n    cmd->left = left;\n    cmd->top = top;\n    cmd->right = right;\n    cmd->bottom = bottom;\n}\nNK_API void\nnk_stroke_circle(struct nk_command_buffer *b, struct nk_rect r,\n    float line_thickness, struct nk_color c)\n{\n    struct nk_command_circle *cmd;\n    if (!b || r.w == 0 || r.h == 0 || line_thickness <= 0) return;\n    if (b->use_clipping) {\n        const struct nk_rect *clip = &b->clip;\n        if (!NK_INTERSECT(r.x, r.y, r.w, r.h, clip->x, clip->y, clip->w, clip->h))\n            return;\n    }\n\n    cmd = (struct nk_command_circle*)\n        nk_command_buffer_push(b, NK_COMMAND_CIRCLE, sizeof(*cmd));\n    if (!cmd) return;\n    cmd->line_thickness = (unsigned short)line_thickness;\n    cmd->x = (short)r.x;\n    cmd->y = (short)r.y;\n    cmd->w = (unsigned short)NK_MAX(r.w, 0);\n    cmd->h = (unsigned short)NK_MAX(r.h, 0);\n    cmd->color = c;\n}\nNK_API void\nnk_fill_circle(struct nk_command_buffer *b, struct nk_rect r, struct nk_color c)\n{\n    struct nk_command_circle_filled *cmd;\n    NK_ASSERT(b);\n    if (!b || c.a == 0 || r.w == 0 || r.h == 0) return;\n    if (b->use_clipping) {\n        const struct nk_rect *clip = &b->clip;\n        if (!NK_INTERSECT(r.x, r.y, r.w, r.h, clip->x, clip->y, clip->w, clip->h))\n            return;\n    }\n\n    cmd = (struct nk_command_circle_filled*)\n        nk_command_buffer_push(b, NK_COMMAND_CIRCLE_FILLED, sizeof(*cmd));\n    if (!cmd) return;\n    cmd->x = (short)r.x;\n    cmd->y = (short)r.y;\n    cmd->w = (unsigned short)NK_MAX(r.w, 0);\n    cmd->h = (unsigned short)NK_MAX(r.h, 0);\n    cmd->color = c;\n}\nNK_API void\nnk_stroke_arc(struct nk_command_buffer *b, float cx, float cy, float radius,\n    float a_min, float a_max, float line_thickness, struct nk_color c)\n{\n    struct nk_command_arc *cmd;\n    if (!b || c.a == 0 || line_thickness <= 0) return;\n    cmd = (struct nk_command_arc*)\n        nk_command_buffer_push(b, NK_COMMAND_ARC, sizeof(*cmd));\n    if (!cmd) return;\n    cmd->line_thickness = (unsigned short)line_thickness;\n    cmd->cx = (short)cx;\n    cmd->cy = (short)cy;\n    cmd->r = (unsigned short)radius;\n    cmd->a[0] = a_min;\n    cmd->a[1] = a_max;\n    cmd->color = c;\n}\nNK_API void\nnk_fill_arc(struct nk_command_buffer *b, float cx, float cy, float radius,\n    float a_min, float a_max, struct nk_color c)\n{\n    struct nk_command_arc_filled *cmd;\n    NK_ASSERT(b);\n    if (!b || c.a == 0) return;\n    cmd = (struct nk_command_arc_filled*)\n        nk_command_buffer_push(b, NK_COMMAND_ARC_FILLED, sizeof(*cmd));\n    if (!cmd) return;\n    cmd->cx = (short)cx;\n    cmd->cy = (short)cy;\n    cmd->r = (unsigned short)radius;\n    cmd->a[0] = a_min;\n    cmd->a[1] = a_max;\n    cmd->color = c;\n}\nNK_API void\nnk_stroke_triangle(struct nk_command_buffer *b, float x0, float y0, float x1,\n    float y1, float x2, float y2, float line_thickness, struct nk_color c)\n{\n    struct nk_command_triangle *cmd;\n    NK_ASSERT(b);\n    if (!b || c.a == 0 || line_thickness <= 0) return;\n    if (b->use_clipping) {\n        const struct nk_rect *clip = &b->clip;\n        if (!NK_INBOX(x0, y0, clip->x, clip->y, clip->w, clip->h) &&\n            !NK_INBOX(x1, y1, clip->x, clip->y, clip->w, clip->h) &&\n            !NK_INBOX(x2, y2, clip->x, clip->y, clip->w, clip->h))\n            return;\n    }\n\n    cmd = (struct nk_command_triangle*)\n        nk_command_buffer_push(b, NK_COMMAND_TRIANGLE, sizeof(*cmd));\n    if (!cmd) return;\n    cmd->line_thickness = (unsigned short)line_thickness;\n    cmd->a.x = (short)x0;\n    cmd->a.y = (short)y0;\n    cmd->b.x = (short)x1;\n    cmd->b.y = (short)y1;\n    cmd->c.x = (short)x2;\n    cmd->c.y = (short)y2;\n    cmd->color = c;\n}\nNK_API void\nnk_fill_triangle(struct nk_command_buffer *b, float x0, float y0, float x1,\n    float y1, float x2, float y2, struct nk_color c)\n{\n    struct nk_command_triangle_filled *cmd;\n    NK_ASSERT(b);\n    if (!b || c.a == 0) return;\n    if (!b) return;\n    if (b->use_clipping) {\n        const struct nk_rect *clip = &b->clip;\n        if (!NK_INBOX(x0, y0, clip->x, clip->y, clip->w, clip->h) &&\n            !NK_INBOX(x1, y1, clip->x, clip->y, clip->w, clip->h) &&\n            !NK_INBOX(x2, y2, clip->x, clip->y, clip->w, clip->h))\n            return;\n    }\n\n    cmd = (struct nk_command_triangle_filled*)\n        nk_command_buffer_push(b, NK_COMMAND_TRIANGLE_FILLED, sizeof(*cmd));\n    if (!cmd) return;\n    cmd->a.x = (short)x0;\n    cmd->a.y = (short)y0;\n    cmd->b.x = (short)x1;\n    cmd->b.y = (short)y1;\n    cmd->c.x = (short)x2;\n    cmd->c.y = (short)y2;\n    cmd->color = c;\n}\nNK_API void\nnk_stroke_polygon(struct nk_command_buffer *b, const float *points, int point_count,\n    float line_thickness, struct nk_color col)\n{\n    int i;\n    nk_size size = 0;\n    struct nk_command_polygon *cmd;\n\n    NK_ASSERT(b);\n    if (!b || col.a == 0 || line_thickness <= 0) return;\n    size = sizeof(*cmd) + sizeof(short) * 2 * (nk_size)point_count;\n    cmd = (struct nk_command_polygon*) nk_command_buffer_push(b, NK_COMMAND_POLYGON, size);\n    if (!cmd) return;\n    cmd->color = col;\n    cmd->line_thickness = (unsigned short)line_thickness;\n    cmd->point_count = (unsigned short)point_count;\n    for (i = 0; i < point_count; ++i) {\n        cmd->points[i].x = (short)points[i*2];\n        cmd->points[i].y = (short)points[i*2+1];\n    }\n}\nNK_API void\nnk_fill_polygon(struct nk_command_buffer *b, const float *points, int point_count,\n    struct nk_color col)\n{\n    int i;\n    nk_size size = 0;\n    struct nk_command_polygon_filled *cmd;\n\n    NK_ASSERT(b);\n    if (!b || col.a == 0) return;\n    size = sizeof(*cmd) + sizeof(short) * 2 * (nk_size)point_count;\n    cmd = (struct nk_command_polygon_filled*)\n        nk_command_buffer_push(b, NK_COMMAND_POLYGON_FILLED, size);\n    if (!cmd) return;\n    cmd->color = col;\n    cmd->point_count = (unsigned short)point_count;\n    for (i = 0; i < point_count; ++i) {\n        cmd->points[i].x = (short)points[i*2+0];\n        cmd->points[i].y = (short)points[i*2+1];\n    }\n}\nNK_API void\nnk_stroke_polyline(struct nk_command_buffer *b, const float *points, int point_count,\n    float line_thickness, struct nk_color col)\n{\n    int i;\n    nk_size size = 0;\n    struct nk_command_polyline *cmd;\n\n    NK_ASSERT(b);\n    if (!b || col.a == 0 || line_thickness <= 0) return;\n    size = sizeof(*cmd) + sizeof(short) * 2 * (nk_size)point_count;\n    cmd = (struct nk_command_polyline*) nk_command_buffer_push(b, NK_COMMAND_POLYLINE, size);\n    if (!cmd) return;\n    cmd->color = col;\n    cmd->point_count = (unsigned short)point_count;\n    cmd->line_thickness = (unsigned short)line_thickness;\n    for (i = 0; i < point_count; ++i) {\n        cmd->points[i].x = (short)points[i*2];\n        cmd->points[i].y = (short)points[i*2+1];\n    }\n}\nNK_API void\nnk_draw_image(struct nk_command_buffer *b, struct nk_rect r,\n    const struct nk_image *img, struct nk_color col)\n{\n    struct nk_command_image *cmd;\n    NK_ASSERT(b);\n    if (!b) return;\n    if (b->use_clipping) {\n        const struct nk_rect *c = &b->clip;\n        if (c->w == 0 || c->h == 0 || !NK_INTERSECT(r.x, r.y, r.w, r.h, c->x, c->y, c->w, c->h))\n            return;\n    }\n\n    cmd = (struct nk_command_image*)\n        nk_command_buffer_push(b, NK_COMMAND_IMAGE, sizeof(*cmd));\n    if (!cmd) return;\n    cmd->x = (short)r.x;\n    cmd->y = (short)r.y;\n    cmd->w = (unsigned short)NK_MAX(0, r.w);\n    cmd->h = (unsigned short)NK_MAX(0, r.h);\n    cmd->img = *img;\n    cmd->col = col;\n}\nNK_API void\nnk_draw_nine_slice(struct nk_command_buffer *b, struct nk_rect r,\n    const struct nk_nine_slice *slc, struct nk_color col)\n{\n    struct nk_image img;\n    const struct nk_image *slcimg = (const struct nk_image*)slc;\n    nk_ushort rgnX, rgnY, rgnW, rgnH;\n    rgnX = slcimg->region[0];\n    rgnY = slcimg->region[1];\n    rgnW = slcimg->region[2];\n    rgnH = slcimg->region[3];\n\n    /* top-left */\n    img.handle = slcimg->handle;\n    img.w = slcimg->w;\n    img.h = slcimg->h;\n    img.region[0] = rgnX;\n    img.region[1] = rgnY;\n    img.region[2] = slc->l;\n    img.region[3] = slc->t;\n\n    nk_draw_image(b,\n        nk_rect(r.x, r.y, (float)slc->l, (float)slc->t),\n        &img, col);\n\n#define IMG_RGN(x, y, w, h) img.region[0] = (nk_ushort)(x); img.region[1] = (nk_ushort)(y); img.region[2] = (nk_ushort)(w); img.region[3] = (nk_ushort)(h);\n\n    /* top-center */\n    IMG_RGN(rgnX + slc->l, rgnY, rgnW - slc->l - slc->r, slc->t);\n    nk_draw_image(b,\n        nk_rect(r.x + (float)slc->l, r.y, (float)(r.w - slc->l - slc->r), (float)slc->t),\n        &img, col);\n\n    /* top-right */\n    IMG_RGN(rgnX + rgnW - slc->r, rgnY, slc->r, slc->t);\n    nk_draw_image(b,\n        nk_rect(r.x + r.w - (float)slc->r, r.y, (float)slc->r, (float)slc->t),\n        &img, col);\n\n    /* center-left */\n    IMG_RGN(rgnX, rgnY + slc->t, slc->l, rgnH - slc->t - slc->b);\n    nk_draw_image(b,\n        nk_rect(r.x, r.y + (float)slc->t, (float)slc->l, (float)(r.h - slc->t - slc->b)),\n        &img, col);\n\n    /* center */\n    IMG_RGN(rgnX + slc->l, rgnY + slc->t, rgnW - slc->l - slc->r, rgnH - slc->t - slc->b);\n    nk_draw_image(b,\n        nk_rect(r.x + (float)slc->l, r.y + (float)slc->t, (float)(r.w - slc->l - slc->r), (float)(r.h - slc->t - slc->b)),\n        &img, col);\n\n    /* center-right */\n    IMG_RGN(rgnX + rgnW - slc->r, rgnY + slc->t, slc->r, rgnH - slc->t - slc->b);\n    nk_draw_image(b,\n        nk_rect(r.x + r.w - (float)slc->r, r.y + (float)slc->t, (float)slc->r, (float)(r.h - slc->t - slc->b)),\n        &img, col);\n\n    /* bottom-left */\n    IMG_RGN(rgnX, rgnY + rgnH - slc->b, slc->l, slc->b);\n    nk_draw_image(b,\n        nk_rect(r.x, r.y + r.h - (float)slc->b, (float)slc->l, (float)slc->b),\n        &img, col);\n\n    /* bottom-center */\n    IMG_RGN(rgnX + slc->l, rgnY + rgnH - slc->b, rgnW - slc->l - slc->r, slc->b);\n    nk_draw_image(b,\n        nk_rect(r.x + (float)slc->l, r.y + r.h - (float)slc->b, (float)(r.w - slc->l - slc->r), (float)slc->b),\n        &img, col);\n\n    /* bottom-right */\n    IMG_RGN(rgnX + rgnW - slc->r, rgnY + rgnH - slc->b, slc->r, slc->b);\n    nk_draw_image(b,\n        nk_rect(r.x + r.w - (float)slc->r, r.y + r.h - (float)slc->b, (float)slc->r, (float)slc->b),\n        &img, col);\n\n#undef IMG_RGN\n}\nNK_API void\nnk_push_custom(struct nk_command_buffer *b, struct nk_rect r,\n    nk_command_custom_callback cb, nk_handle usr)\n{\n    struct nk_command_custom *cmd;\n    NK_ASSERT(b);\n    if (!b) return;\n    if (b->use_clipping) {\n        const struct nk_rect *c = &b->clip;\n        if (c->w == 0 || c->h == 0 || !NK_INTERSECT(r.x, r.y, r.w, r.h, c->x, c->y, c->w, c->h))\n            return;\n    }\n\n    cmd = (struct nk_command_custom*)\n        nk_command_buffer_push(b, NK_COMMAND_CUSTOM, sizeof(*cmd));\n    if (!cmd) return;\n    cmd->x = (short)r.x;\n    cmd->y = (short)r.y;\n    cmd->w = (unsigned short)NK_MAX(0, r.w);\n    cmd->h = (unsigned short)NK_MAX(0, r.h);\n    cmd->callback_data = usr;\n    cmd->callback = cb;\n}\nNK_API void\nnk_draw_text(struct nk_command_buffer *b, struct nk_rect r,\n    const char *string, int length, const struct nk_user_font *font,\n    struct nk_color bg, struct nk_color fg)\n{\n    float text_width = 0;\n    struct nk_command_text *cmd;\n\n    NK_ASSERT(b);\n    NK_ASSERT(font);\n    if (!b || !string || !length || (bg.a == 0 && fg.a == 0)) return;\n    if (b->use_clipping) {\n        const struct nk_rect *c = &b->clip;\n        if (c->w == 0 || c->h == 0 || !NK_INTERSECT(r.x, r.y, r.w, r.h, c->x, c->y, c->w, c->h))\n            return;\n    }\n\n    /* make sure text fits inside bounds */\n    text_width = font->width(font->userdata, font->height, string, length);\n    if (text_width > r.w){\n        int glyphs = 0;\n        float txt_width = (float)text_width;\n        length = nk_text_clamp(font, string, length, r.w, &glyphs, &txt_width, 0,0);\n    }\n\n    if (!length) return;\n    cmd = (struct nk_command_text*)\n        nk_command_buffer_push(b, NK_COMMAND_TEXT, sizeof(*cmd) + (nk_size)(length + 1));\n    if (!cmd) return;\n    cmd->x = (short)r.x;\n    cmd->y = (short)r.y;\n    cmd->w = (unsigned short)r.w;\n    cmd->h = (unsigned short)r.h;\n    cmd->background = bg;\n    cmd->foreground = fg;\n    cmd->font = font;\n    cmd->length = length;\n    cmd->height = font->height;\n    NK_MEMCPY(cmd->string, string, (nk_size)length);\n    cmd->string[length] = '\\0';\n}\n\n\n\n\n/* ===============================================================\n *\n *                              VERTEX\n *\n * ===============================================================*/\n#ifdef NK_INCLUDE_VERTEX_BUFFER_OUTPUT\nNK_API void\nnk_draw_list_init(struct nk_draw_list *list)\n{\n    nk_size i = 0;\n    NK_ASSERT(list);\n    if (!list) return;\n    nk_zero(list, sizeof(*list));\n    for (i = 0; i < NK_LEN(list->circle_vtx); ++i) {\n        const float a = ((float)i / (float)NK_LEN(list->circle_vtx)) * 2 * NK_PI;\n        list->circle_vtx[i].x = (float)NK_COS(a);\n        list->circle_vtx[i].y = (float)NK_SIN(a);\n    }\n}\nNK_API void\nnk_draw_list_setup(struct nk_draw_list *canvas, const struct nk_convert_config *config,\n    struct nk_buffer *cmds, struct nk_buffer *vertices, struct nk_buffer *elements,\n    enum nk_anti_aliasing line_aa, enum nk_anti_aliasing shape_aa)\n{\n    NK_ASSERT(canvas);\n    NK_ASSERT(config);\n    NK_ASSERT(cmds);\n    NK_ASSERT(vertices);\n    NK_ASSERT(elements);\n    if (!canvas || !config || !cmds || !vertices || !elements)\n        return;\n\n    canvas->buffer = cmds;\n    canvas->config = *config;\n    canvas->elements = elements;\n    canvas->vertices = vertices;\n    canvas->line_AA = line_aa;\n    canvas->shape_AA = shape_aa;\n    canvas->clip_rect = nk_null_rect;\n\n    canvas->cmd_offset = 0;\n    canvas->element_count = 0;\n    canvas->vertex_count = 0;\n    canvas->cmd_offset = 0;\n    canvas->cmd_count = 0;\n    canvas->path_count = 0;\n}\nNK_API const struct nk_draw_command*\nnk__draw_list_begin(const struct nk_draw_list *canvas, const struct nk_buffer *buffer)\n{\n    nk_byte *memory;\n    nk_size offset;\n    const struct nk_draw_command *cmd;\n\n    NK_ASSERT(buffer);\n    if (!buffer || !buffer->size || !canvas->cmd_count)\n        return 0;\n\n    memory = (nk_byte*)buffer->memory.ptr;\n    offset = buffer->memory.size - canvas->cmd_offset;\n    cmd = nk_ptr_add(const struct nk_draw_command, memory, offset);\n    return cmd;\n}\nNK_API const struct nk_draw_command*\nnk__draw_list_end(const struct nk_draw_list *canvas, const struct nk_buffer *buffer)\n{\n    nk_size size;\n    nk_size offset;\n    nk_byte *memory;\n    const struct nk_draw_command *end;\n\n    NK_ASSERT(buffer);\n    NK_ASSERT(canvas);\n    if (!buffer || !canvas)\n        return 0;\n\n    memory = (nk_byte*)buffer->memory.ptr;\n    size = buffer->memory.size;\n    offset = size - canvas->cmd_offset;\n    end = nk_ptr_add(const struct nk_draw_command, memory, offset);\n    end -= (canvas->cmd_count-1);\n    return end;\n}\nNK_API const struct nk_draw_command*\nnk__draw_list_next(const struct nk_draw_command *cmd,\n    const struct nk_buffer *buffer, const struct nk_draw_list *canvas)\n{\n    const struct nk_draw_command *end;\n    NK_ASSERT(buffer);\n    NK_ASSERT(canvas);\n    if (!cmd || !buffer || !canvas)\n        return 0;\n\n    end = nk__draw_list_end(canvas, buffer);\n    if (cmd <= end) return 0;\n    return (cmd-1);\n}\nNK_INTERN struct nk_vec2*\nnk_draw_list_alloc_path(struct nk_draw_list *list, int count)\n{\n    struct nk_vec2 *points;\n    NK_STORAGE const nk_size point_align = NK_ALIGNOF(struct nk_vec2);\n    NK_STORAGE const nk_size point_size = sizeof(struct nk_vec2);\n    points = (struct nk_vec2*)\n        nk_buffer_alloc(list->buffer, NK_BUFFER_FRONT,\n                        point_size * (nk_size)count, point_align);\n\n    if (!points) return 0;\n    if (!list->path_offset) {\n        void *memory = nk_buffer_memory(list->buffer);\n        list->path_offset = (unsigned int)((nk_byte*)points - (nk_byte*)memory);\n    }\n    list->path_count += (unsigned int)count;\n    return points;\n}\nNK_INTERN struct nk_vec2\nnk_draw_list_path_last(struct nk_draw_list *list)\n{\n    void *memory;\n    struct nk_vec2 *point;\n    NK_ASSERT(list->path_count);\n    memory = nk_buffer_memory(list->buffer);\n    point = nk_ptr_add(struct nk_vec2, memory, list->path_offset);\n    point += (list->path_count-1);\n    return *point;\n}\nNK_INTERN struct nk_draw_command*\nnk_draw_list_push_command(struct nk_draw_list *list, struct nk_rect clip,\n    nk_handle texture)\n{\n    NK_STORAGE const nk_size cmd_align = NK_ALIGNOF(struct nk_draw_command);\n    NK_STORAGE const nk_size cmd_size = sizeof(struct nk_draw_command);\n    struct nk_draw_command *cmd;\n\n    NK_ASSERT(list);\n    cmd = (struct nk_draw_command*)\n        nk_buffer_alloc(list->buffer, NK_BUFFER_BACK, cmd_size, cmd_align);\n\n    if (!cmd) return 0;\n    if (!list->cmd_count) {\n        nk_byte *memory = (nk_byte*)nk_buffer_memory(list->buffer);\n        nk_size total = nk_buffer_total(list->buffer);\n        memory = nk_ptr_add(nk_byte, memory, total);\n        list->cmd_offset = (nk_size)(memory - (nk_byte*)cmd);\n    }\n\n    cmd->elem_count = 0;\n    cmd->clip_rect = clip;\n    cmd->texture = texture;\n#ifdef NK_INCLUDE_COMMAND_USERDATA\n    cmd->userdata = list->userdata;\n#endif\n\n    list->cmd_count++;\n    list->clip_rect = clip;\n    return cmd;\n}\nNK_INTERN struct nk_draw_command*\nnk_draw_list_command_last(struct nk_draw_list *list)\n{\n    void *memory;\n    nk_size size;\n    struct nk_draw_command *cmd;\n    NK_ASSERT(list->cmd_count);\n\n    memory = nk_buffer_memory(list->buffer);\n    size = nk_buffer_total(list->buffer);\n    cmd = nk_ptr_add(struct nk_draw_command, memory, size - list->cmd_offset);\n    return (cmd - (list->cmd_count-1));\n}\nNK_INTERN void\nnk_draw_list_add_clip(struct nk_draw_list *list, struct nk_rect rect)\n{\n    NK_ASSERT(list);\n    if (!list) return;\n    if (!list->cmd_count) {\n        nk_draw_list_push_command(list, rect, list->config.tex_null.texture);\n    } else {\n        struct nk_draw_command *prev = nk_draw_list_command_last(list);\n        if (prev->elem_count == 0)\n            prev->clip_rect = rect;\n        nk_draw_list_push_command(list, rect, prev->texture);\n    }\n}\nNK_INTERN void\nnk_draw_list_push_image(struct nk_draw_list *list, nk_handle texture)\n{\n    NK_ASSERT(list);\n    if (!list) return;\n    if (!list->cmd_count) {\n        nk_draw_list_push_command(list, nk_null_rect, texture);\n    } else {\n        struct nk_draw_command *prev = nk_draw_list_command_last(list);\n        if (prev->elem_count == 0) {\n            prev->texture = texture;\n            #ifdef NK_INCLUDE_COMMAND_USERDATA\n            prev->userdata = list->userdata;\n            #endif\n        } else if (prev->texture.id != texture.id\n                #ifdef NK_INCLUDE_COMMAND_USERDATA\n                || prev->userdata.id != list->userdata.id\n                #endif\n                ) {\n            nk_draw_list_push_command(list, prev->clip_rect, texture);\n        }\n    }\n}\n#ifdef NK_INCLUDE_COMMAND_USERDATA\nNK_API void\nnk_draw_list_push_userdata(struct nk_draw_list *list, nk_handle userdata)\n{\n    list->userdata = userdata;\n}\n#endif\nNK_INTERN void*\nnk_draw_list_alloc_vertices(struct nk_draw_list *list, nk_size count)\n{\n    void *vtx;\n    NK_ASSERT(list);\n    if (!list) return 0;\n    vtx = nk_buffer_alloc(list->vertices, NK_BUFFER_FRONT,\n        list->config.vertex_size*count, list->config.vertex_alignment);\n    if (!vtx) return 0;\n    list->vertex_count += (unsigned int)count;\n\n    /* This assert triggers because your are drawing a lot of stuff and nuklear\n     * defined `nk_draw_index` as `nk_ushort` to safe space be default.\n     *\n     * So you reached the maximum number of indices or rather vertexes.\n     * To solve this issue please change typedef `nk_draw_index` to `nk_uint`\n     * and don't forget to specify the new element size in your drawing\n     * backend (OpenGL, DirectX, ...). For example in OpenGL for `glDrawElements`\n     * instead of specifying `GL_UNSIGNED_SHORT` you have to define `GL_UNSIGNED_INT`.\n     * Sorry for the inconvenience. */\n    if(sizeof(nk_draw_index)==2) NK_ASSERT((list->vertex_count < NK_USHORT_MAX &&\n        \"To many vertices for 16-bit vertex indices. Please read comment above on how to solve this problem\"));\n    return vtx;\n}\nNK_INTERN nk_draw_index*\nnk_draw_list_alloc_elements(struct nk_draw_list *list, nk_size count)\n{\n    nk_draw_index *ids;\n    struct nk_draw_command *cmd;\n    NK_STORAGE const nk_size elem_align = NK_ALIGNOF(nk_draw_index);\n    NK_STORAGE const nk_size elem_size = sizeof(nk_draw_index);\n    NK_ASSERT(list);\n    if (!list) return 0;\n\n    ids = (nk_draw_index*)\n        nk_buffer_alloc(list->elements, NK_BUFFER_FRONT, elem_size*count, elem_align);\n    if (!ids) return 0;\n    cmd = nk_draw_list_command_last(list);\n    list->element_count += (unsigned int)count;\n    cmd->elem_count += (unsigned int)count;\n    return ids;\n}\nNK_INTERN int\nnk_draw_vertex_layout_element_is_end_of_layout(\n    const struct nk_draw_vertex_layout_element *element)\n{\n    return (element->attribute == NK_VERTEX_ATTRIBUTE_COUNT ||\n            element->format == NK_FORMAT_COUNT);\n}\nNK_INTERN void\nnk_draw_vertex_color(void *attr, const float *vals,\n    enum nk_draw_vertex_layout_format format)\n{\n    /* if this triggers you tried to provide a value format for a color */\n    float val[4];\n    NK_ASSERT(format >= NK_FORMAT_COLOR_BEGIN);\n    NK_ASSERT(format <= NK_FORMAT_COLOR_END);\n    if (format < NK_FORMAT_COLOR_BEGIN || format > NK_FORMAT_COLOR_END) return;\n\n    val[0] = NK_SATURATE(vals[0]);\n    val[1] = NK_SATURATE(vals[1]);\n    val[2] = NK_SATURATE(vals[2]);\n    val[3] = NK_SATURATE(vals[3]);\n\n    switch (format) {\n    default: NK_ASSERT(0 && \"Invalid vertex layout color format\"); break;\n    case NK_FORMAT_R8G8B8A8:\n    case NK_FORMAT_R8G8B8: {\n        struct nk_color col = nk_rgba_fv(val);\n        NK_MEMCPY(attr, &col.r, sizeof(col));\n    } break;\n    case NK_FORMAT_B8G8R8A8: {\n        struct nk_color col = nk_rgba_fv(val);\n        struct nk_color bgra = nk_rgba(col.b, col.g, col.r, col.a);\n        NK_MEMCPY(attr, &bgra, sizeof(bgra));\n    } break;\n    case NK_FORMAT_R16G15B16: {\n        nk_ushort col[3];\n        col[0] = (nk_ushort)(val[0]*(float)NK_USHORT_MAX);\n        col[1] = (nk_ushort)(val[1]*(float)NK_USHORT_MAX);\n        col[2] = (nk_ushort)(val[2]*(float)NK_USHORT_MAX);\n        NK_MEMCPY(attr, col, sizeof(col));\n    } break;\n    case NK_FORMAT_R16G15B16A16: {\n        nk_ushort col[4];\n        col[0] = (nk_ushort)(val[0]*(float)NK_USHORT_MAX);\n        col[1] = (nk_ushort)(val[1]*(float)NK_USHORT_MAX);\n        col[2] = (nk_ushort)(val[2]*(float)NK_USHORT_MAX);\n        col[3] = (nk_ushort)(val[3]*(float)NK_USHORT_MAX);\n        NK_MEMCPY(attr, col, sizeof(col));\n    } break;\n    case NK_FORMAT_R32G32B32: {\n        nk_uint col[3];\n        col[0] = (nk_uint)(val[0]*(float)NK_UINT_MAX);\n        col[1] = (nk_uint)(val[1]*(float)NK_UINT_MAX);\n        col[2] = (nk_uint)(val[2]*(float)NK_UINT_MAX);\n        NK_MEMCPY(attr, col, sizeof(col));\n    } break;\n    case NK_FORMAT_R32G32B32A32: {\n        nk_uint col[4];\n        col[0] = (nk_uint)(val[0]*(float)NK_UINT_MAX);\n        col[1] = (nk_uint)(val[1]*(float)NK_UINT_MAX);\n        col[2] = (nk_uint)(val[2]*(float)NK_UINT_MAX);\n        col[3] = (nk_uint)(val[3]*(float)NK_UINT_MAX);\n        NK_MEMCPY(attr, col, sizeof(col));\n    } break;\n    case NK_FORMAT_R32G32B32A32_FLOAT:\n        NK_MEMCPY(attr, val, sizeof(float)*4);\n        break;\n    case NK_FORMAT_R32G32B32A32_DOUBLE: {\n        double col[4];\n        col[0] = (double)val[0];\n        col[1] = (double)val[1];\n        col[2] = (double)val[2];\n        col[3] = (double)val[3];\n        NK_MEMCPY(attr, col, sizeof(col));\n    } break;\n    case NK_FORMAT_RGB32:\n    case NK_FORMAT_RGBA32: {\n        struct nk_color col = nk_rgba_fv(val);\n        nk_uint color = nk_color_u32(col);\n        NK_MEMCPY(attr, &color, sizeof(color));\n    } break; }\n}\nNK_INTERN void\nnk_draw_vertex_element(void *dst, const float *values, int value_count,\n    enum nk_draw_vertex_layout_format format)\n{\n    int value_index;\n    void *attribute = dst;\n    /* if this triggers you tried to provide a color format for a value */\n    NK_ASSERT(format < NK_FORMAT_COLOR_BEGIN);\n    if (format >= NK_FORMAT_COLOR_BEGIN && format <= NK_FORMAT_COLOR_END) return;\n    for (value_index = 0; value_index < value_count; ++value_index) {\n        switch (format) {\n        default: NK_ASSERT(0 && \"invalid vertex layout format\"); break;\n        case NK_FORMAT_SCHAR: {\n            char value = (char)NK_CLAMP((float)NK_SCHAR_MIN, values[value_index], (float)NK_SCHAR_MAX);\n            NK_MEMCPY(attribute, &value, sizeof(value));\n            attribute = (void*)((char*)attribute + sizeof(char));\n        } break;\n        case NK_FORMAT_SSHORT: {\n            nk_short value = (nk_short)NK_CLAMP((float)NK_SSHORT_MIN, values[value_index], (float)NK_SSHORT_MAX);\n            NK_MEMCPY(attribute, &value, sizeof(value));\n            attribute = (void*)((char*)attribute + sizeof(value));\n        } break;\n        case NK_FORMAT_SINT: {\n            nk_int value = (nk_int)NK_CLAMP((float)NK_SINT_MIN, values[value_index], (float)NK_SINT_MAX);\n            NK_MEMCPY(attribute, &value, sizeof(value));\n            attribute = (void*)((char*)attribute + sizeof(nk_int));\n        } break;\n        case NK_FORMAT_UCHAR: {\n            unsigned char value = (unsigned char)NK_CLAMP((float)NK_UCHAR_MIN, values[value_index], (float)NK_UCHAR_MAX);\n            NK_MEMCPY(attribute, &value, sizeof(value));\n            attribute = (void*)((char*)attribute + sizeof(unsigned char));\n        } break;\n        case NK_FORMAT_USHORT: {\n            nk_ushort value = (nk_ushort)NK_CLAMP((float)NK_USHORT_MIN, values[value_index], (float)NK_USHORT_MAX);\n            NK_MEMCPY(attribute, &value, sizeof(value));\n            attribute = (void*)((char*)attribute + sizeof(value));\n            } break;\n        case NK_FORMAT_UINT: {\n            nk_uint value = (nk_uint)NK_CLAMP((float)NK_UINT_MIN, values[value_index], (float)NK_UINT_MAX);\n            NK_MEMCPY(attribute, &value, sizeof(value));\n            attribute = (void*)((char*)attribute + sizeof(nk_uint));\n        } break;\n        case NK_FORMAT_FLOAT:\n            NK_MEMCPY(attribute, &values[value_index], sizeof(values[value_index]));\n            attribute = (void*)((char*)attribute + sizeof(float));\n            break;\n        case NK_FORMAT_DOUBLE: {\n            double value = (double)values[value_index];\n            NK_MEMCPY(attribute, &value, sizeof(value));\n            attribute = (void*)((char*)attribute + sizeof(double));\n            } break;\n        }\n    }\n}\nNK_INTERN void*\nnk_draw_vertex(void *dst, const struct nk_convert_config *config,\n    struct nk_vec2 pos, struct nk_vec2 uv, struct nk_colorf color)\n{\n    void *result = (void*)((char*)dst + config->vertex_size);\n    const struct nk_draw_vertex_layout_element *elem_iter = config->vertex_layout;\n    while (!nk_draw_vertex_layout_element_is_end_of_layout(elem_iter)) {\n        void *address = (void*)((char*)dst + elem_iter->offset);\n        switch (elem_iter->attribute) {\n        case NK_VERTEX_ATTRIBUTE_COUNT:\n        default: NK_ASSERT(0 && \"wrong element attribute\"); break;\n        case NK_VERTEX_POSITION: nk_draw_vertex_element(address, &pos.x, 2, elem_iter->format); break;\n        case NK_VERTEX_TEXCOORD: nk_draw_vertex_element(address, &uv.x, 2, elem_iter->format); break;\n        case NK_VERTEX_COLOR: nk_draw_vertex_color(address, &color.r, elem_iter->format); break;\n        }\n        elem_iter++;\n    }\n    return result;\n}\nNK_API void\nnk_draw_list_stroke_poly_line(struct nk_draw_list *list, const struct nk_vec2 *points,\n    const unsigned int points_count, struct nk_color color, enum nk_draw_list_stroke closed,\n    float thickness, enum nk_anti_aliasing aliasing)\n{\n    nk_size count;\n    int thick_line;\n    struct nk_colorf col;\n    struct nk_colorf col_trans;\n    NK_ASSERT(list);\n    if (!list || points_count < 2) return;\n\n    color.a = (nk_byte)((float)color.a * list->config.global_alpha);\n    count = points_count;\n    if (!closed) count = points_count-1;\n    thick_line = thickness > 1.0f;\n\n#ifdef NK_INCLUDE_COMMAND_USERDATA\n    nk_draw_list_push_userdata(list, list->userdata);\n#endif\n\n    color.a = (nk_byte)((float)color.a * list->config.global_alpha);\n    nk_color_fv(&col.r, color);\n    col_trans = col;\n    col_trans.a = 0;\n\n    if (aliasing == NK_ANTI_ALIASING_ON) {\n        /* ANTI-ALIASED STROKE */\n        const float AA_SIZE = 1.0f;\n        NK_STORAGE const nk_size pnt_align = NK_ALIGNOF(struct nk_vec2);\n        NK_STORAGE const nk_size pnt_size = sizeof(struct nk_vec2);\n\n        /* allocate vertices and elements  */\n        nk_size i1 = 0;\n        nk_size vertex_offset;\n        nk_size index = list->vertex_count;\n\n        const nk_size idx_count = (thick_line) ?  (count * 18) : (count * 12);\n        const nk_size vtx_count = (thick_line) ? (points_count * 4): (points_count *3);\n\n        void *vtx = nk_draw_list_alloc_vertices(list, vtx_count);\n        nk_draw_index *ids = nk_draw_list_alloc_elements(list, idx_count);\n\n        nk_size size;\n        struct nk_vec2 *normals, *temp;\n        if (!vtx || !ids) return;\n\n        /* temporary allocate normals + points */\n        vertex_offset = (nk_size)((nk_byte*)vtx - (nk_byte*)list->vertices->memory.ptr);\n        nk_buffer_mark(list->vertices, NK_BUFFER_FRONT);\n        size = pnt_size * ((thick_line) ? 5 : 3) * points_count;\n        normals = (struct nk_vec2*) nk_buffer_alloc(list->vertices, NK_BUFFER_FRONT, size, pnt_align);\n        if (!normals) return;\n        temp = normals + points_count;\n\n        /* make sure vertex pointer is still correct */\n        vtx = (void*)((nk_byte*)list->vertices->memory.ptr + vertex_offset);\n\n        /* calculate normals */\n        for (i1 = 0; i1 < count; ++i1) {\n            const nk_size i2 = ((i1 + 1) == points_count) ? 0 : (i1 + 1);\n            struct nk_vec2 diff = nk_vec2_sub(points[i2], points[i1]);\n            float len;\n\n            /* vec2 inverted length  */\n            len = nk_vec2_len_sqr(diff);\n            if (len != 0.0f)\n                len = NK_INV_SQRT(len);\n            else len = 1.0f;\n\n            diff = nk_vec2_muls(diff, len);\n            normals[i1].x = diff.y;\n            normals[i1].y = -diff.x;\n        }\n\n        if (!closed)\n            normals[points_count-1] = normals[points_count-2];\n\n        if (!thick_line) {\n            nk_size idx1, i;\n            if (!closed) {\n                struct nk_vec2 d;\n                temp[0] = nk_vec2_add(points[0], nk_vec2_muls(normals[0], AA_SIZE));\n                temp[1] = nk_vec2_sub(points[0], nk_vec2_muls(normals[0], AA_SIZE));\n                d = nk_vec2_muls(normals[points_count-1], AA_SIZE);\n                temp[(points_count-1) * 2 + 0] = nk_vec2_add(points[points_count-1], d);\n                temp[(points_count-1) * 2 + 1] = nk_vec2_sub(points[points_count-1], d);\n            }\n\n            /* fill elements */\n            idx1 = index;\n            for (i1 = 0; i1 < count; i1++) {\n                struct nk_vec2 dm;\n                float dmr2;\n                nk_size i2 = ((i1 + 1) == points_count) ? 0 : (i1 + 1);\n                nk_size idx2 = ((i1+1) == points_count) ? index: (idx1 + 3);\n\n                /* average normals */\n                dm = nk_vec2_muls(nk_vec2_add(normals[i1], normals[i2]), 0.5f);\n                dmr2 = dm.x * dm.x + dm.y* dm.y;\n                if (dmr2 > 0.000001f) {\n                    float scale = 1.0f/dmr2;\n                    scale = NK_MIN(100.0f, scale);\n                    dm = nk_vec2_muls(dm, scale);\n                }\n\n                dm = nk_vec2_muls(dm, AA_SIZE);\n                temp[i2*2+0] = nk_vec2_add(points[i2], dm);\n                temp[i2*2+1] = nk_vec2_sub(points[i2], dm);\n\n                ids[0] = (nk_draw_index)(idx2 + 0); ids[1] = (nk_draw_index)(idx1+0);\n                ids[2] = (nk_draw_index)(idx1 + 2); ids[3] = (nk_draw_index)(idx1+2);\n                ids[4] = (nk_draw_index)(idx2 + 2); ids[5] = (nk_draw_index)(idx2+0);\n                ids[6] = (nk_draw_index)(idx2 + 1); ids[7] = (nk_draw_index)(idx1+1);\n                ids[8] = (nk_draw_index)(idx1 + 0); ids[9] = (nk_draw_index)(idx1+0);\n                ids[10]= (nk_draw_index)(idx2 + 0); ids[11]= (nk_draw_index)(idx2+1);\n                ids += 12;\n                idx1 = idx2;\n            }\n\n            /* fill vertices */\n            for (i = 0; i < points_count; ++i) {\n                const struct nk_vec2 uv = list->config.tex_null.uv;\n                vtx = nk_draw_vertex(vtx, &list->config, points[i], uv, col);\n                vtx = nk_draw_vertex(vtx, &list->config, temp[i*2+0], uv, col_trans);\n                vtx = nk_draw_vertex(vtx, &list->config, temp[i*2+1], uv, col_trans);\n            }\n        } else {\n            nk_size idx1, i;\n            const float half_inner_thickness = (thickness - AA_SIZE) * 0.5f;\n            if (!closed) {\n                struct nk_vec2 d1 = nk_vec2_muls(normals[0], half_inner_thickness + AA_SIZE);\n                struct nk_vec2 d2 = nk_vec2_muls(normals[0], half_inner_thickness);\n\n                temp[0] = nk_vec2_add(points[0], d1);\n                temp[1] = nk_vec2_add(points[0], d2);\n                temp[2] = nk_vec2_sub(points[0], d2);\n                temp[3] = nk_vec2_sub(points[0], d1);\n\n                d1 = nk_vec2_muls(normals[points_count-1], half_inner_thickness + AA_SIZE);\n                d2 = nk_vec2_muls(normals[points_count-1], half_inner_thickness);\n\n                temp[(points_count-1)*4+0] = nk_vec2_add(points[points_count-1], d1);\n                temp[(points_count-1)*4+1] = nk_vec2_add(points[points_count-1], d2);\n                temp[(points_count-1)*4+2] = nk_vec2_sub(points[points_count-1], d2);\n                temp[(points_count-1)*4+3] = nk_vec2_sub(points[points_count-1], d1);\n            }\n\n            /* add all elements */\n            idx1 = index;\n            for (i1 = 0; i1 < count; ++i1) {\n                struct nk_vec2 dm_out, dm_in;\n                const nk_size i2 = ((i1+1) == points_count) ? 0: (i1 + 1);\n                nk_size idx2 = ((i1+1) == points_count) ? index: (idx1 + 4);\n\n                /* average normals */\n                struct nk_vec2 dm = nk_vec2_muls(nk_vec2_add(normals[i1], normals[i2]), 0.5f);\n                float dmr2 = dm.x * dm.x + dm.y* dm.y;\n                if (dmr2 > 0.000001f) {\n                    float scale = 1.0f/dmr2;\n                    scale = NK_MIN(100.0f, scale);\n                    dm = nk_vec2_muls(dm, scale);\n                }\n\n                dm_out = nk_vec2_muls(dm, ((half_inner_thickness) + AA_SIZE));\n                dm_in = nk_vec2_muls(dm, half_inner_thickness);\n                temp[i2*4+0] = nk_vec2_add(points[i2], dm_out);\n                temp[i2*4+1] = nk_vec2_add(points[i2], dm_in);\n                temp[i2*4+2] = nk_vec2_sub(points[i2], dm_in);\n                temp[i2*4+3] = nk_vec2_sub(points[i2], dm_out);\n\n                /* add indexes */\n                ids[0] = (nk_draw_index)(idx2 + 1); ids[1] = (nk_draw_index)(idx1+1);\n                ids[2] = (nk_draw_index)(idx1 + 2); ids[3] = (nk_draw_index)(idx1+2);\n                ids[4] = (nk_draw_index)(idx2 + 2); ids[5] = (nk_draw_index)(idx2+1);\n                ids[6] = (nk_draw_index)(idx2 + 1); ids[7] = (nk_draw_index)(idx1+1);\n                ids[8] = (nk_draw_index)(idx1 + 0); ids[9] = (nk_draw_index)(idx1+0);\n                ids[10]= (nk_draw_index)(idx2 + 0); ids[11] = (nk_draw_index)(idx2+1);\n                ids[12]= (nk_draw_index)(idx2 + 2); ids[13] = (nk_draw_index)(idx1+2);\n                ids[14]= (nk_draw_index)(idx1 + 3); ids[15] = (nk_draw_index)(idx1+3);\n                ids[16]= (nk_draw_index)(idx2 + 3); ids[17] = (nk_draw_index)(idx2+2);\n                ids += 18;\n                idx1 = idx2;\n            }\n\n            /* add vertices */\n            for (i = 0; i < points_count; ++i) {\n                const struct nk_vec2 uv = list->config.tex_null.uv;\n                vtx = nk_draw_vertex(vtx, &list->config, temp[i*4+0], uv, col_trans);\n                vtx = nk_draw_vertex(vtx, &list->config, temp[i*4+1], uv, col);\n                vtx = nk_draw_vertex(vtx, &list->config, temp[i*4+2], uv, col);\n                vtx = nk_draw_vertex(vtx, &list->config, temp[i*4+3], uv, col_trans);\n            }\n        }\n        /* free temporary normals + points */\n        nk_buffer_reset(list->vertices, NK_BUFFER_FRONT);\n    } else {\n        /* NON ANTI-ALIASED STROKE */\n        nk_size i1 = 0;\n        nk_size idx = list->vertex_count;\n        const nk_size idx_count = count * 6;\n        const nk_size vtx_count = count * 4;\n        void *vtx = nk_draw_list_alloc_vertices(list, vtx_count);\n        nk_draw_index *ids = nk_draw_list_alloc_elements(list, idx_count);\n        if (!vtx || !ids) return;\n\n        for (i1 = 0; i1 < count; ++i1) {\n            float dx, dy;\n            const struct nk_vec2 uv = list->config.tex_null.uv;\n            const nk_size i2 = ((i1+1) == points_count) ? 0 : i1 + 1;\n            const struct nk_vec2 p1 = points[i1];\n            const struct nk_vec2 p2 = points[i2];\n            struct nk_vec2 diff = nk_vec2_sub(p2, p1);\n            float len;\n\n            /* vec2 inverted length  */\n            len = nk_vec2_len_sqr(diff);\n            if (len != 0.0f)\n                len = NK_INV_SQRT(len);\n            else len = 1.0f;\n            diff = nk_vec2_muls(diff, len);\n\n            /* add vertices */\n            dx = diff.x * (thickness * 0.5f);\n            dy = diff.y * (thickness * 0.5f);\n\n            vtx = nk_draw_vertex(vtx, &list->config, nk_vec2(p1.x + dy, p1.y - dx), uv, col);\n            vtx = nk_draw_vertex(vtx, &list->config, nk_vec2(p2.x + dy, p2.y - dx), uv, col);\n            vtx = nk_draw_vertex(vtx, &list->config, nk_vec2(p2.x - dy, p2.y + dx), uv, col);\n            vtx = nk_draw_vertex(vtx, &list->config, nk_vec2(p1.x - dy, p1.y + dx), uv, col);\n\n            ids[0] = (nk_draw_index)(idx+0); ids[1] = (nk_draw_index)(idx+1);\n            ids[2] = (nk_draw_index)(idx+2); ids[3] = (nk_draw_index)(idx+0);\n            ids[4] = (nk_draw_index)(idx+2); ids[5] = (nk_draw_index)(idx+3);\n\n            ids += 6;\n            idx += 4;\n        }\n    }\n}\nNK_API void\nnk_draw_list_fill_poly_convex(struct nk_draw_list *list,\n    const struct nk_vec2 *points, const unsigned int points_count,\n    struct nk_color color, enum nk_anti_aliasing aliasing)\n{\n    struct nk_colorf col;\n    struct nk_colorf col_trans;\n\n    NK_STORAGE const nk_size pnt_align = NK_ALIGNOF(struct nk_vec2);\n    NK_STORAGE const nk_size pnt_size = sizeof(struct nk_vec2);\n    NK_ASSERT(list);\n    if (!list || points_count < 3) return;\n\n#ifdef NK_INCLUDE_COMMAND_USERDATA\n    nk_draw_list_push_userdata(list, list->userdata);\n#endif\n\n    color.a = (nk_byte)((float)color.a * list->config.global_alpha);\n    nk_color_fv(&col.r, color);\n    col_trans = col;\n    col_trans.a = 0;\n\n    if (aliasing == NK_ANTI_ALIASING_ON) {\n        nk_size i = 0;\n        nk_size i0 = 0;\n        nk_size i1 = 0;\n\n        const float AA_SIZE = 1.0f;\n        nk_size vertex_offset = 0;\n        nk_size index = list->vertex_count;\n\n        const nk_size idx_count = (points_count-2)*3 + points_count*6;\n        const nk_size vtx_count = (points_count*2);\n\n        void *vtx = nk_draw_list_alloc_vertices(list, vtx_count);\n        nk_draw_index *ids = nk_draw_list_alloc_elements(list, idx_count);\n\n        nk_size size = 0;\n        struct nk_vec2 *normals = 0;\n        unsigned int vtx_inner_idx = (unsigned int)(index + 0);\n        unsigned int vtx_outer_idx = (unsigned int)(index + 1);\n        if (!vtx || !ids) return;\n\n        /* temporary allocate normals */\n        vertex_offset = (nk_size)((nk_byte*)vtx - (nk_byte*)list->vertices->memory.ptr);\n        nk_buffer_mark(list->vertices, NK_BUFFER_FRONT);\n        size = pnt_size * points_count;\n        normals = (struct nk_vec2*) nk_buffer_alloc(list->vertices, NK_BUFFER_FRONT, size, pnt_align);\n        if (!normals) return;\n        vtx = (void*)((nk_byte*)list->vertices->memory.ptr + vertex_offset);\n\n        /* add elements */\n        for (i = 2; i < points_count; i++) {\n            ids[0] = (nk_draw_index)(vtx_inner_idx);\n            ids[1] = (nk_draw_index)(vtx_inner_idx + ((i-1) << 1));\n            ids[2] = (nk_draw_index)(vtx_inner_idx + (i << 1));\n            ids += 3;\n        }\n\n        /* compute normals */\n        for (i0 = points_count-1, i1 = 0; i1 < points_count; i0 = i1++) {\n            struct nk_vec2 p0 = points[i0];\n            struct nk_vec2 p1 = points[i1];\n            struct nk_vec2 diff = nk_vec2_sub(p1, p0);\n\n            /* vec2 inverted length  */\n            float len = nk_vec2_len_sqr(diff);\n            if (len != 0.0f)\n                len = NK_INV_SQRT(len);\n            else len = 1.0f;\n            diff = nk_vec2_muls(diff, len);\n\n            normals[i0].x = diff.y;\n            normals[i0].y = -diff.x;\n        }\n\n        /* add vertices + indexes */\n        for (i0 = points_count-1, i1 = 0; i1 < points_count; i0 = i1++) {\n            const struct nk_vec2 uv = list->config.tex_null.uv;\n            struct nk_vec2 n0 = normals[i0];\n            struct nk_vec2 n1 = normals[i1];\n            struct nk_vec2 dm = nk_vec2_muls(nk_vec2_add(n0, n1), 0.5f);\n            float dmr2 = dm.x*dm.x + dm.y*dm.y;\n            if (dmr2 > 0.000001f) {\n                float scale = 1.0f / dmr2;\n                scale = NK_MIN(scale, 100.0f);\n                dm = nk_vec2_muls(dm, scale);\n            }\n            dm = nk_vec2_muls(dm, AA_SIZE * 0.5f);\n\n            /* add vertices */\n            vtx = nk_draw_vertex(vtx, &list->config, nk_vec2_sub(points[i1], dm), uv, col);\n            vtx = nk_draw_vertex(vtx, &list->config, nk_vec2_add(points[i1], dm), uv, col_trans);\n\n            /* add indexes */\n            ids[0] = (nk_draw_index)(vtx_inner_idx+(i1<<1));\n            ids[1] = (nk_draw_index)(vtx_inner_idx+(i0<<1));\n            ids[2] = (nk_draw_index)(vtx_outer_idx+(i0<<1));\n            ids[3] = (nk_draw_index)(vtx_outer_idx+(i0<<1));\n            ids[4] = (nk_draw_index)(vtx_outer_idx+(i1<<1));\n            ids[5] = (nk_draw_index)(vtx_inner_idx+(i1<<1));\n            ids += 6;\n        }\n        /* free temporary normals + points */\n        nk_buffer_reset(list->vertices, NK_BUFFER_FRONT);\n    } else {\n        nk_size i = 0;\n        nk_size index = list->vertex_count;\n        const nk_size idx_count = (points_count-2)*3;\n        const nk_size vtx_count = points_count;\n        void *vtx = nk_draw_list_alloc_vertices(list, vtx_count);\n        nk_draw_index *ids = nk_draw_list_alloc_elements(list, idx_count);\n\n        if (!vtx || !ids) return;\n        for (i = 0; i < vtx_count; ++i)\n            vtx = nk_draw_vertex(vtx, &list->config, points[i], list->config.tex_null.uv, col);\n        for (i = 2; i < points_count; ++i) {\n            ids[0] = (nk_draw_index)index;\n            ids[1] = (nk_draw_index)(index+ i - 1);\n            ids[2] = (nk_draw_index)(index+i);\n            ids += 3;\n        }\n    }\n}\nNK_API void\nnk_draw_list_path_clear(struct nk_draw_list *list)\n{\n    NK_ASSERT(list);\n    if (!list) return;\n    nk_buffer_reset(list->buffer, NK_BUFFER_FRONT);\n    list->path_count = 0;\n    list->path_offset = 0;\n}\nNK_API void\nnk_draw_list_path_line_to(struct nk_draw_list *list, struct nk_vec2 pos)\n{\n    struct nk_vec2 *points = 0;\n    struct nk_draw_command *cmd = 0;\n    NK_ASSERT(list);\n    if (!list) return;\n    if (!list->cmd_count)\n        nk_draw_list_add_clip(list, nk_null_rect);\n\n    cmd = nk_draw_list_command_last(list);\n    if (cmd && cmd->texture.ptr != list->config.tex_null.texture.ptr)\n        nk_draw_list_push_image(list, list->config.tex_null.texture);\n\n    points = nk_draw_list_alloc_path(list, 1);\n    if (!points) return;\n    points[0] = pos;\n}\nNK_API void\nnk_draw_list_path_arc_to_fast(struct nk_draw_list *list, struct nk_vec2 center,\n    float radius, int a_min, int a_max)\n{\n    int a = 0;\n    NK_ASSERT(list);\n    if (!list) return;\n    if (a_min <= a_max) {\n        for (a = a_min; a <= a_max; a++) {\n            const struct nk_vec2 c = list->circle_vtx[(nk_size)a % NK_LEN(list->circle_vtx)];\n            const float x = center.x + c.x * radius;\n            const float y = center.y + c.y * radius;\n            nk_draw_list_path_line_to(list, nk_vec2(x, y));\n        }\n    }\n}\nNK_API void\nnk_draw_list_path_arc_to(struct nk_draw_list *list, struct nk_vec2 center,\n    float radius, float a_min, float a_max, unsigned int segments)\n{\n    unsigned int i = 0;\n    NK_ASSERT(list);\n    if (!list) return;\n    if (radius == 0.0f) return;\n\n    /*  This algorithm for arc drawing relies on these two trigonometric identities[1]:\n            sin(a + b) = sin(a) * cos(b) + cos(a) * sin(b)\n            cos(a + b) = cos(a) * cos(b) - sin(a) * sin(b)\n\n        Two coordinates (x, y) of a point on a circle centered on\n        the origin can be written in polar form as:\n            x = r * cos(a)\n            y = r * sin(a)\n        where r is the radius of the circle,\n            a is the angle between (x, y) and the origin.\n\n        This allows us to rotate the coordinates around the\n        origin by an angle b using the following transformation:\n            x' = r * cos(a + b) = x * cos(b) - y * sin(b)\n            y' = r * sin(a + b) = y * cos(b) + x * sin(b)\n\n        [1] https://en.wikipedia.org/wiki/List_of_trigonometric_identities#Angle_sum_and_difference_identities\n    */\n    {const float d_angle = (a_max - a_min) / (float)segments;\n    const float sin_d = (float)NK_SIN(d_angle);\n    const float cos_d = (float)NK_COS(d_angle);\n\n    float cx = (float)NK_COS(a_min) * radius;\n    float cy = (float)NK_SIN(a_min) * radius;\n    for(i = 0; i <= segments; ++i) {\n        float new_cx, new_cy;\n        const float x = center.x + cx;\n        const float y = center.y + cy;\n        nk_draw_list_path_line_to(list, nk_vec2(x, y));\n\n        new_cx = cx * cos_d - cy * sin_d;\n        new_cy = cy * cos_d + cx * sin_d;\n        cx = new_cx;\n        cy = new_cy;\n    }}\n}\nNK_API void\nnk_draw_list_path_rect_to(struct nk_draw_list *list, struct nk_vec2 a,\n    struct nk_vec2 b, float rounding)\n{\n    float r;\n    NK_ASSERT(list);\n    if (!list) return;\n    r = rounding;\n    r = NK_MIN(r, ((b.x-a.x) < 0) ? -(b.x-a.x): (b.x-a.x));\n    r = NK_MIN(r, ((b.y-a.y) < 0) ? -(b.y-a.y): (b.y-a.y));\n\n    if (r == 0.0f) {\n        nk_draw_list_path_line_to(list, a);\n        nk_draw_list_path_line_to(list, nk_vec2(b.x,a.y));\n        nk_draw_list_path_line_to(list, b);\n        nk_draw_list_path_line_to(list, nk_vec2(a.x,b.y));\n    } else {\n        nk_draw_list_path_arc_to_fast(list, nk_vec2(a.x + r, a.y + r), r, 6, 9);\n        nk_draw_list_path_arc_to_fast(list, nk_vec2(b.x - r, a.y + r), r, 9, 12);\n        nk_draw_list_path_arc_to_fast(list, nk_vec2(b.x - r, b.y - r), r, 0, 3);\n        nk_draw_list_path_arc_to_fast(list, nk_vec2(a.x + r, b.y - r), r, 3, 6);\n    }\n}\nNK_API void\nnk_draw_list_path_curve_to(struct nk_draw_list *list, struct nk_vec2 p2,\n    struct nk_vec2 p3, struct nk_vec2 p4, unsigned int num_segments)\n{\n    float t_step;\n    unsigned int i_step;\n    struct nk_vec2 p1;\n\n    NK_ASSERT(list);\n    NK_ASSERT(list->path_count);\n    if (!list || !list->path_count) return;\n    num_segments = NK_MAX(num_segments, 1);\n\n    p1 = nk_draw_list_path_last(list);\n    t_step = 1.0f/(float)num_segments;\n    for (i_step = 1; i_step <= num_segments; ++i_step) {\n        float t = t_step * (float)i_step;\n        float u = 1.0f - t;\n        float w1 = u*u*u;\n        float w2 = 3*u*u*t;\n        float w3 = 3*u*t*t;\n        float w4 = t * t *t;\n        float x = w1 * p1.x + w2 * p2.x + w3 * p3.x + w4 * p4.x;\n        float y = w1 * p1.y + w2 * p2.y + w3 * p3.y + w4 * p4.y;\n        nk_draw_list_path_line_to(list, nk_vec2(x,y));\n    }\n}\nNK_API void\nnk_draw_list_path_fill(struct nk_draw_list *list, struct nk_color color)\n{\n    struct nk_vec2 *points;\n    NK_ASSERT(list);\n    if (!list) return;\n    points = (struct nk_vec2*)nk_buffer_memory(list->buffer);\n    nk_draw_list_fill_poly_convex(list, points, list->path_count, color, list->config.shape_AA);\n    nk_draw_list_path_clear(list);\n}\nNK_API void\nnk_draw_list_path_stroke(struct nk_draw_list *list, struct nk_color color,\n    enum nk_draw_list_stroke closed, float thickness)\n{\n    struct nk_vec2 *points;\n    NK_ASSERT(list);\n    if (!list) return;\n    points = (struct nk_vec2*)nk_buffer_memory(list->buffer);\n    nk_draw_list_stroke_poly_line(list, points, list->path_count, color,\n        closed, thickness, list->config.line_AA);\n    nk_draw_list_path_clear(list);\n}\nNK_API void\nnk_draw_list_stroke_line(struct nk_draw_list *list, struct nk_vec2 a,\n    struct nk_vec2 b, struct nk_color col, float thickness)\n{\n    NK_ASSERT(list);\n    if (!list || !col.a) return;\n    if (list->line_AA == NK_ANTI_ALIASING_ON) {\n        nk_draw_list_path_line_to(list, a);\n        nk_draw_list_path_line_to(list, b);\n    } else {\n        nk_draw_list_path_line_to(list, nk_vec2_sub(a,nk_vec2(0.5f,0.5f)));\n        nk_draw_list_path_line_to(list, nk_vec2_sub(b,nk_vec2(0.5f,0.5f)));\n    }\n    nk_draw_list_path_stroke(list,  col, NK_STROKE_OPEN, thickness);\n}\nNK_API void\nnk_draw_list_fill_rect(struct nk_draw_list *list, struct nk_rect rect,\n    struct nk_color col, float rounding)\n{\n    NK_ASSERT(list);\n    if (!list || !col.a) return;\n\n    if (list->line_AA == NK_ANTI_ALIASING_ON) {\n        nk_draw_list_path_rect_to(list, nk_vec2(rect.x, rect.y),\n            nk_vec2(rect.x + rect.w, rect.y + rect.h), rounding);\n    } else {\n        nk_draw_list_path_rect_to(list, nk_vec2(rect.x-0.5f, rect.y-0.5f),\n            nk_vec2(rect.x + rect.w, rect.y + rect.h), rounding);\n    } nk_draw_list_path_fill(list,  col);\n}\nNK_API void\nnk_draw_list_stroke_rect(struct nk_draw_list *list, struct nk_rect rect,\n    struct nk_color col, float rounding, float thickness)\n{\n    NK_ASSERT(list);\n    if (!list || !col.a) return;\n    if (list->line_AA == NK_ANTI_ALIASING_ON) {\n        nk_draw_list_path_rect_to(list, nk_vec2(rect.x, rect.y),\n            nk_vec2(rect.x + rect.w, rect.y + rect.h), rounding);\n    } else {\n        nk_draw_list_path_rect_to(list, nk_vec2(rect.x-0.5f, rect.y-0.5f),\n            nk_vec2(rect.x + rect.w, rect.y + rect.h), rounding);\n    } nk_draw_list_path_stroke(list,  col, NK_STROKE_CLOSED, thickness);\n}\nNK_API void\nnk_draw_list_fill_rect_multi_color(struct nk_draw_list *list, struct nk_rect rect,\n    struct nk_color left, struct nk_color top, struct nk_color right,\n    struct nk_color bottom)\n{\n    void *vtx;\n    struct nk_colorf col_left, col_top;\n    struct nk_colorf col_right, col_bottom;\n    nk_draw_index *idx;\n    nk_draw_index index;\n\n    nk_color_fv(&col_left.r, left);\n    nk_color_fv(&col_right.r, right);\n    nk_color_fv(&col_top.r, top);\n    nk_color_fv(&col_bottom.r, bottom);\n\n    NK_ASSERT(list);\n    if (!list) return;\n\n    nk_draw_list_push_image(list, list->config.tex_null.texture);\n    index = (nk_draw_index)list->vertex_count;\n    vtx = nk_draw_list_alloc_vertices(list, 4);\n    idx = nk_draw_list_alloc_elements(list, 6);\n    if (!vtx || !idx) return;\n\n    idx[0] = (nk_draw_index)(index+0); idx[1] = (nk_draw_index)(index+1);\n    idx[2] = (nk_draw_index)(index+2); idx[3] = (nk_draw_index)(index+0);\n    idx[4] = (nk_draw_index)(index+2); idx[5] = (nk_draw_index)(index+3);\n\n    vtx = nk_draw_vertex(vtx, &list->config, nk_vec2(rect.x, rect.y), list->config.tex_null.uv, col_left);\n    vtx = nk_draw_vertex(vtx, &list->config, nk_vec2(rect.x + rect.w, rect.y), list->config.tex_null.uv, col_top);\n    vtx = nk_draw_vertex(vtx, &list->config, nk_vec2(rect.x + rect.w, rect.y + rect.h), list->config.tex_null.uv, col_right);\n    vtx = nk_draw_vertex(vtx, &list->config, nk_vec2(rect.x, rect.y + rect.h), list->config.tex_null.uv, col_bottom);\n}\nNK_API void\nnk_draw_list_fill_triangle(struct nk_draw_list *list, struct nk_vec2 a,\n    struct nk_vec2 b, struct nk_vec2 c, struct nk_color col)\n{\n    NK_ASSERT(list);\n    if (!list || !col.a) return;\n    nk_draw_list_path_line_to(list, a);\n    nk_draw_list_path_line_to(list, b);\n    nk_draw_list_path_line_to(list, c);\n    nk_draw_list_path_fill(list, col);\n}\nNK_API void\nnk_draw_list_stroke_triangle(struct nk_draw_list *list, struct nk_vec2 a,\n    struct nk_vec2 b, struct nk_vec2 c, struct nk_color col, float thickness)\n{\n    NK_ASSERT(list);\n    if (!list || !col.a) return;\n    nk_draw_list_path_line_to(list, a);\n    nk_draw_list_path_line_to(list, b);\n    nk_draw_list_path_line_to(list, c);\n    nk_draw_list_path_stroke(list, col, NK_STROKE_CLOSED, thickness);\n}\nNK_API void\nnk_draw_list_fill_circle(struct nk_draw_list *list, struct nk_vec2 center,\n    float radius, struct nk_color col, unsigned int segs)\n{\n    float a_max;\n    NK_ASSERT(list);\n    if (!list || !col.a) return;\n    a_max = NK_PI * 2.0f * ((float)segs - 1.0f) / (float)segs;\n    nk_draw_list_path_arc_to(list, center, radius, 0.0f, a_max, segs);\n    nk_draw_list_path_fill(list, col);\n}\nNK_API void\nnk_draw_list_stroke_circle(struct nk_draw_list *list, struct nk_vec2 center,\n    float radius, struct nk_color col, unsigned int segs, float thickness)\n{\n    float a_max;\n    NK_ASSERT(list);\n    if (!list || !col.a) return;\n    a_max = NK_PI * 2.0f * ((float)segs - 1.0f) / (float)segs;\n    nk_draw_list_path_arc_to(list, center, radius, 0.0f, a_max, segs);\n    nk_draw_list_path_stroke(list, col, NK_STROKE_CLOSED, thickness);\n}\nNK_API void\nnk_draw_list_stroke_curve(struct nk_draw_list *list, struct nk_vec2 p0,\n    struct nk_vec2 cp0, struct nk_vec2 cp1, struct nk_vec2 p1,\n    struct nk_color col, unsigned int segments, float thickness)\n{\n    NK_ASSERT(list);\n    if (!list || !col.a) return;\n    nk_draw_list_path_line_to(list, p0);\n    nk_draw_list_path_curve_to(list, cp0, cp1, p1, segments);\n    nk_draw_list_path_stroke(list, col, NK_STROKE_OPEN, thickness);\n}\nNK_INTERN void\nnk_draw_list_push_rect_uv(struct nk_draw_list *list, struct nk_vec2 a,\n    struct nk_vec2 c, struct nk_vec2 uva, struct nk_vec2 uvc,\n    struct nk_color color)\n{\n    void *vtx;\n    struct nk_vec2 uvb;\n    struct nk_vec2 uvd;\n    struct nk_vec2 b;\n    struct nk_vec2 d;\n\n    struct nk_colorf col;\n    nk_draw_index *idx;\n    nk_draw_index index;\n    NK_ASSERT(list);\n    if (!list) return;\n\n    nk_color_fv(&col.r, color);\n    uvb = nk_vec2(uvc.x, uva.y);\n    uvd = nk_vec2(uva.x, uvc.y);\n    b = nk_vec2(c.x, a.y);\n    d = nk_vec2(a.x, c.y);\n\n    index = (nk_draw_index)list->vertex_count;\n    vtx = nk_draw_list_alloc_vertices(list, 4);\n    idx = nk_draw_list_alloc_elements(list, 6);\n    if (!vtx || !idx) return;\n\n    idx[0] = (nk_draw_index)(index+0); idx[1] = (nk_draw_index)(index+1);\n    idx[2] = (nk_draw_index)(index+2); idx[3] = (nk_draw_index)(index+0);\n    idx[4] = (nk_draw_index)(index+2); idx[5] = (nk_draw_index)(index+3);\n\n    vtx = nk_draw_vertex(vtx, &list->config, a, uva, col);\n    vtx = nk_draw_vertex(vtx, &list->config, b, uvb, col);\n    vtx = nk_draw_vertex(vtx, &list->config, c, uvc, col);\n    vtx = nk_draw_vertex(vtx, &list->config, d, uvd, col);\n}\nNK_API void\nnk_draw_list_add_image(struct nk_draw_list *list, struct nk_image texture,\n    struct nk_rect rect, struct nk_color color)\n{\n    NK_ASSERT(list);\n    if (!list) return;\n    /* push new command with given texture */\n    nk_draw_list_push_image(list, texture.handle);\n    if (nk_image_is_subimage(&texture)) {\n        /* add region inside of the texture  */\n        struct nk_vec2 uv[2];\n        uv[0].x = (float)texture.region[0]/(float)texture.w;\n        uv[0].y = (float)texture.region[1]/(float)texture.h;\n        uv[1].x = (float)(texture.region[0] + texture.region[2])/(float)texture.w;\n        uv[1].y = (float)(texture.region[1] + texture.region[3])/(float)texture.h;\n        nk_draw_list_push_rect_uv(list, nk_vec2(rect.x, rect.y),\n            nk_vec2(rect.x + rect.w, rect.y + rect.h),  uv[0], uv[1], color);\n    } else nk_draw_list_push_rect_uv(list, nk_vec2(rect.x, rect.y),\n            nk_vec2(rect.x + rect.w, rect.y + rect.h),\n            nk_vec2(0.0f, 0.0f), nk_vec2(1.0f, 1.0f),color);\n}\nNK_API void\nnk_draw_list_add_text(struct nk_draw_list *list, const struct nk_user_font *font,\n    struct nk_rect rect, const char *text, int len, float font_height,\n    struct nk_color fg)\n{\n    float x = 0;\n    int text_len = 0;\n    nk_rune unicode = 0;\n    nk_rune next = 0;\n    int glyph_len = 0;\n    int next_glyph_len = 0;\n    struct nk_user_font_glyph g;\n\n    NK_ASSERT(list);\n    if (!list || !len || !text) return;\n    if (!NK_INTERSECT(rect.x, rect.y, rect.w, rect.h,\n        list->clip_rect.x, list->clip_rect.y, list->clip_rect.w, list->clip_rect.h)) return;\n\n    nk_draw_list_push_image(list, font->texture);\n    x = rect.x;\n    glyph_len = nk_utf_decode(text, &unicode, len);\n    if (!glyph_len) return;\n\n    /* draw every glyph image */\n    fg.a = (nk_byte)((float)fg.a * list->config.global_alpha);\n    while (text_len < len && glyph_len) {\n        float gx, gy, gh, gw;\n        float char_width = 0;\n        if (unicode == NK_UTF_INVALID) break;\n\n        /* query currently drawn glyph information */\n        next_glyph_len = nk_utf_decode(text + text_len + glyph_len, &next, (int)len - text_len);\n        font->query(font->userdata, font_height, &g, unicode,\n                    (next == NK_UTF_INVALID) ? '\\0' : next);\n\n        /* calculate and draw glyph drawing rectangle and image */\n        gx = x + g.offset.x;\n        gy = rect.y + g.offset.y;\n        gw = g.width; gh = g.height;\n        char_width = g.xadvance;\n        nk_draw_list_push_rect_uv(list, nk_vec2(gx,gy), nk_vec2(gx + gw, gy+ gh),\n            g.uv[0], g.uv[1], fg);\n\n        /* offset next glyph */\n        text_len += glyph_len;\n        x += char_width;\n        glyph_len = next_glyph_len;\n        unicode = next;\n    }\n}\nNK_API nk_flags\nnk_convert(struct nk_context *ctx, struct nk_buffer *cmds,\n    struct nk_buffer *vertices, struct nk_buffer *elements,\n    const struct nk_convert_config *config)\n{\n    nk_flags res = NK_CONVERT_SUCCESS;\n    const struct nk_command *cmd;\n    NK_ASSERT(ctx);\n    NK_ASSERT(cmds);\n    NK_ASSERT(vertices);\n    NK_ASSERT(elements);\n    NK_ASSERT(config);\n    NK_ASSERT(config->vertex_layout);\n    NK_ASSERT(config->vertex_size);\n    if (!ctx || !cmds || !vertices || !elements || !config || !config->vertex_layout)\n        return NK_CONVERT_INVALID_PARAM;\n\n    nk_draw_list_setup(&ctx->draw_list, config, cmds, vertices, elements,\n        config->line_AA, config->shape_AA);\n    nk_foreach(cmd, ctx)\n    {\n#ifdef NK_INCLUDE_COMMAND_USERDATA\n        ctx->draw_list.userdata = cmd->userdata;\n#endif\n        switch (cmd->type) {\n        case NK_COMMAND_NOP: break;\n        case NK_COMMAND_SCISSOR: {\n            const struct nk_command_scissor *s = (const struct nk_command_scissor*)cmd;\n            nk_draw_list_add_clip(&ctx->draw_list, nk_rect(s->x, s->y, s->w, s->h));\n        } break;\n        case NK_COMMAND_LINE: {\n            const struct nk_command_line *l = (const struct nk_command_line*)cmd;\n            nk_draw_list_stroke_line(&ctx->draw_list, nk_vec2(l->begin.x, l->begin.y),\n                nk_vec2(l->end.x, l->end.y), l->color, l->line_thickness);\n        } break;\n        case NK_COMMAND_CURVE: {\n            const struct nk_command_curve *q = (const struct nk_command_curve*)cmd;\n            nk_draw_list_stroke_curve(&ctx->draw_list, nk_vec2(q->begin.x, q->begin.y),\n                nk_vec2(q->ctrl[0].x, q->ctrl[0].y), nk_vec2(q->ctrl[1].x,\n                q->ctrl[1].y), nk_vec2(q->end.x, q->end.y), q->color,\n                config->curve_segment_count, q->line_thickness);\n        } break;\n        case NK_COMMAND_RECT: {\n            const struct nk_command_rect *r = (const struct nk_command_rect*)cmd;\n            nk_draw_list_stroke_rect(&ctx->draw_list, nk_rect(r->x, r->y, r->w, r->h),\n                r->color, (float)r->rounding, r->line_thickness);\n        } break;\n        case NK_COMMAND_RECT_FILLED: {\n            const struct nk_command_rect_filled *r = (const struct nk_command_rect_filled*)cmd;\n            nk_draw_list_fill_rect(&ctx->draw_list, nk_rect(r->x, r->y, r->w, r->h),\n                r->color, (float)r->rounding);\n        } break;\n        case NK_COMMAND_RECT_MULTI_COLOR: {\n            const struct nk_command_rect_multi_color *r = (const struct nk_command_rect_multi_color*)cmd;\n            nk_draw_list_fill_rect_multi_color(&ctx->draw_list, nk_rect(r->x, r->y, r->w, r->h),\n                r->left, r->top, r->right, r->bottom);\n        } break;\n        case NK_COMMAND_CIRCLE: {\n            const struct nk_command_circle *c = (const struct nk_command_circle*)cmd;\n            nk_draw_list_stroke_circle(&ctx->draw_list, nk_vec2((float)c->x + (float)c->w/2,\n                (float)c->y + (float)c->h/2), (float)c->w/2, c->color,\n                config->circle_segment_count, c->line_thickness);\n        } break;\n        case NK_COMMAND_CIRCLE_FILLED: {\n            const struct nk_command_circle_filled *c = (const struct nk_command_circle_filled *)cmd;\n            nk_draw_list_fill_circle(&ctx->draw_list, nk_vec2((float)c->x + (float)c->w/2,\n                (float)c->y + (float)c->h/2), (float)c->w/2, c->color,\n                config->circle_segment_count);\n        } break;\n        case NK_COMMAND_ARC: {\n            const struct nk_command_arc *c = (const struct nk_command_arc*)cmd;\n            nk_draw_list_path_line_to(&ctx->draw_list, nk_vec2(c->cx, c->cy));\n            nk_draw_list_path_arc_to(&ctx->draw_list, nk_vec2(c->cx, c->cy), c->r,\n                c->a[0], c->a[1], config->arc_segment_count);\n            nk_draw_list_path_stroke(&ctx->draw_list, c->color, NK_STROKE_CLOSED, c->line_thickness);\n        } break;\n        case NK_COMMAND_ARC_FILLED: {\n            const struct nk_command_arc_filled *c = (const struct nk_command_arc_filled*)cmd;\n            nk_draw_list_path_line_to(&ctx->draw_list, nk_vec2(c->cx, c->cy));\n            nk_draw_list_path_arc_to(&ctx->draw_list, nk_vec2(c->cx, c->cy), c->r,\n                c->a[0], c->a[1], config->arc_segment_count);\n            nk_draw_list_path_fill(&ctx->draw_list, c->color);\n        } break;\n        case NK_COMMAND_TRIANGLE: {\n            const struct nk_command_triangle *t = (const struct nk_command_triangle*)cmd;\n            nk_draw_list_stroke_triangle(&ctx->draw_list, nk_vec2(t->a.x, t->a.y),\n                nk_vec2(t->b.x, t->b.y), nk_vec2(t->c.x, t->c.y), t->color,\n                t->line_thickness);\n        } break;\n        case NK_COMMAND_TRIANGLE_FILLED: {\n            const struct nk_command_triangle_filled *t = (const struct nk_command_triangle_filled*)cmd;\n            nk_draw_list_fill_triangle(&ctx->draw_list, nk_vec2(t->a.x, t->a.y),\n                nk_vec2(t->b.x, t->b.y), nk_vec2(t->c.x, t->c.y), t->color);\n        } break;\n        case NK_COMMAND_POLYGON: {\n            int i;\n            const struct nk_command_polygon*p = (const struct nk_command_polygon*)cmd;\n            for (i = 0; i < p->point_count; ++i) {\n                struct nk_vec2 pnt = nk_vec2((float)p->points[i].x, (float)p->points[i].y);\n                nk_draw_list_path_line_to(&ctx->draw_list, pnt);\n            }\n            nk_draw_list_path_stroke(&ctx->draw_list, p->color, NK_STROKE_CLOSED, p->line_thickness);\n        } break;\n        case NK_COMMAND_POLYGON_FILLED: {\n            int i;\n            const struct nk_command_polygon_filled *p = (const struct nk_command_polygon_filled*)cmd;\n            for (i = 0; i < p->point_count; ++i) {\n                struct nk_vec2 pnt = nk_vec2((float)p->points[i].x, (float)p->points[i].y);\n                nk_draw_list_path_line_to(&ctx->draw_list, pnt);\n            }\n            nk_draw_list_path_fill(&ctx->draw_list, p->color);\n        } break;\n        case NK_COMMAND_POLYLINE: {\n            int i;\n            const struct nk_command_polyline *p = (const struct nk_command_polyline*)cmd;\n            for (i = 0; i < p->point_count; ++i) {\n                struct nk_vec2 pnt = nk_vec2((float)p->points[i].x, (float)p->points[i].y);\n                nk_draw_list_path_line_to(&ctx->draw_list, pnt);\n            }\n            nk_draw_list_path_stroke(&ctx->draw_list, p->color, NK_STROKE_OPEN, p->line_thickness);\n        } break;\n        case NK_COMMAND_TEXT: {\n            const struct nk_command_text *t = (const struct nk_command_text*)cmd;\n            nk_draw_list_add_text(&ctx->draw_list, t->font, nk_rect(t->x, t->y, t->w, t->h),\n                t->string, t->length, t->height, t->foreground);\n        } break;\n        case NK_COMMAND_IMAGE: {\n            const struct nk_command_image *i = (const struct nk_command_image*)cmd;\n            nk_draw_list_add_image(&ctx->draw_list, i->img, nk_rect(i->x, i->y, i->w, i->h), i->col);\n        } break;\n        case NK_COMMAND_CUSTOM: {\n            const struct nk_command_custom *c = (const struct nk_command_custom*)cmd;\n            c->callback(&ctx->draw_list, c->x, c->y, c->w, c->h, c->callback_data);\n        } break;\n        default: break;\n        }\n    }\n    res |= (cmds->needed > cmds->allocated + (cmds->memory.size - cmds->size)) ? NK_CONVERT_COMMAND_BUFFER_FULL: 0;\n    res |= (vertices->needed > vertices->allocated) ? NK_CONVERT_VERTEX_BUFFER_FULL: 0;\n    res |= (elements->needed > elements->allocated) ? NK_CONVERT_ELEMENT_BUFFER_FULL: 0;\n    return res;\n}\nNK_API const struct nk_draw_command*\nnk__draw_begin(const struct nk_context *ctx,\n    const struct nk_buffer *buffer)\n{\n    return nk__draw_list_begin(&ctx->draw_list, buffer);\n}\nNK_API const struct nk_draw_command*\nnk__draw_end(const struct nk_context *ctx, const struct nk_buffer *buffer)\n{\n    return nk__draw_list_end(&ctx->draw_list, buffer);\n}\nNK_API const struct nk_draw_command*\nnk__draw_next(const struct nk_draw_command *cmd,\n    const struct nk_buffer *buffer, const struct nk_context *ctx)\n{\n    return nk__draw_list_next(cmd, buffer, &ctx->draw_list);\n}\n#endif\n\n\n/*  stb_rect_pack.h - v1.01 - public domain - rectangle packing */\n/*  Sean Barrett 2014 */\n/*  */\n/*  Useful for e.g. packing rectangular textures into an atlas. */\n/*  Does not do rotation. */\n/*  */\n/*  Before #including, */\n/*  */\n/*     #define STB_RECT_PACK_IMPLEMENTATION */\n/*  */\n/*  in the file that you want to have the implementation. */\n/*  */\n/*  Not necessarily the awesomest packing method, but better than */\n/*  the totally naive one in stb_truetype (which is primarily what */\n/*  this is meant to replace). */\n/*  */\n/*  Has only had a few tests run, may have issues. */\n/*  */\n/*  More docs to come. */\n/*  */\n/*  No memory allocations; uses qsort() and assert() from stdlib. */\n/*  Can override those by defining STBRP_SORT and STBRP_ASSERT. */\n/*  */\n/*  This library currently uses the Skyline Bottom-Left algorithm. */\n/*  */\n/*  Please note: better rectangle packers are welcome! Please */\n/*  implement them to the same API, but with a different init */\n/*  function. */\n/*  */\n/*  Credits */\n/*  */\n/*   Library */\n/*     Sean Barrett */\n/*   Minor features */\n/*     Martins Mozeiko */\n/*     github:IntellectualKitty */\n/*  */\n/*   Bugfixes / warning fixes */\n/*     Jeremy Jaussaud */\n/*     Fabian Giesen */\n/*  */\n/*  Version history: */\n/*  */\n/*      1.01  (2021-07-11)  always use large rect mode, expose STBRP__MAXVAL in public section */\n/*      1.00  (2019-02-25)  avoid small space waste; gracefully fail too-wide rectangles */\n/*      0.99  (2019-02-07)  warning fixes */\n/*      0.11  (2017-03-03)  return packing success/fail result */\n/*      0.10  (2016-10-25)  remove cast-away-const to avoid warnings */\n/*      0.09  (2016-08-27)  fix compiler warnings */\n/*      0.08  (2015-09-13)  really fix bug with empty rects (w=0 or h=0) */\n/*      0.07  (2015-09-13)  fix bug with empty rects (w=0 or h=0) */\n/*      0.06  (2015-04-15)  added STBRP_SORT to allow replacing qsort */\n/*      0.05:  added STBRP_ASSERT to allow replacing assert */\n/*      0.04:  fixed minor bug in STBRP_LARGE_RECTS support */\n/*      0.01:  initial release */\n/*  */\n/*  LICENSE */\n/*  */\n/*    See end of file for license information. */\n\n/* //////////////////////////////////////////////////////////////////////////// */\n/*  */\n/*        INCLUDE SECTION */\n/*  */\n\n#ifndef STB_INCLUDE_STB_RECT_PACK_H\n#define STB_INCLUDE_STB_RECT_PACK_H\n\n#define STB_RECT_PACK_VERSION  1\n\n#ifdef STBRP_STATIC\n#define STBRP_DEF static\n#else\n#define STBRP_DEF extern\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct stbrp_context stbrp_context;\ntypedef struct stbrp_node    stbrp_node;\ntypedef struct stbrp_rect    stbrp_rect;\n\ntypedef int            stbrp_coord;\n\n#define STBRP__MAXVAL  0x7fffffff\n/*  Mostly for internal use, but this is the maximum supported coordinate value. */\n\nSTBRP_DEF int stbrp_pack_rects (stbrp_context *context, stbrp_rect *rects, int num_rects);\n/*  Assign packed locations to rectangles. The rectangles are of type */\n/*  'stbrp_rect' defined below, stored in the array 'rects', and there */\n/*  are 'num_rects' many of them. */\n/*  */\n/*  Rectangles which are successfully packed have the 'was_packed' flag */\n/*  set to a non-zero value and 'x' and 'y' store the minimum location */\n/*  on each axis (i.e. bottom-left in cartesian coordinates, top-left */\n/*  if you imagine y increasing downwards). Rectangles which do not fit */\n/*  have the 'was_packed' flag set to 0. */\n/*  */\n/*  You should not try to access the 'rects' array from another thread */\n/*  while this function is running, as the function temporarily reorders */\n/*  the array while it executes. */\n/*  */\n/*  To pack into another rectangle, you need to call stbrp_init_target */\n/*  again. To continue packing into the same rectangle, you can call */\n/*  this function again. Calling this multiple times with multiple rect */\n/*  arrays will probably produce worse packing results than calling it */\n/*  a single time with the full rectangle array, but the option is */\n/*  available. */\n/*  */\n/*  The function returns 1 if all of the rectangles were successfully */\n/*  packed and 0 otherwise. */\n\nstruct stbrp_rect\n{\n   /*  reserved for your use: */\n   int            id;\n\n   /*  input: */\n   stbrp_coord    w, h;\n\n   /*  output: */\n   stbrp_coord    x, y;\n   int            was_packed;  /*  non-zero if valid packing */\n\n}; /*  16 bytes, nominally */\n\n\nSTBRP_DEF void stbrp_init_target (stbrp_context *context, int width, int height, stbrp_node *nodes, int num_nodes);\n/*  Initialize a rectangle packer to: */\n/*     pack a rectangle that is 'width' by 'height' in dimensions */\n/*     using temporary storage provided by the array 'nodes', which is 'num_nodes' long */\n/*  */\n/*  You must call this function every time you start packing into a new target. */\n/*  */\n/*  There is no \"shutdown\" function. The 'nodes' memory must stay valid for */\n/*  the following stbrp_pack_rects() call (or calls), but can be freed after */\n/*  the call (or calls) finish. */\n/*  */\n/*  Note: to guarantee best results, either: */\n/*        1. make sure 'num_nodes' >= 'width' */\n/*    or  2. call stbrp_allow_out_of_mem() defined below with 'allow_out_of_mem = 1' */\n/*  */\n/*  If you don't do either of the above things, widths will be quantized to multiples */\n/*  of small integers to guarantee the algorithm doesn't run out of temporary storage. */\n/*  */\n/*  If you do #2, then the non-quantized algorithm will be used, but the algorithm */\n/*  may run out of temporary storage and be unable to pack some rectangles. */\n\nSTBRP_DEF void stbrp_setup_allow_out_of_mem (stbrp_context *context, int allow_out_of_mem);\n/*  Optionally call this function after init but before doing any packing to */\n/*  change the handling of the out-of-temp-memory scenario, described above. */\n/*  If you call init again, this will be reset to the default (false). */\n\n\nSTBRP_DEF void stbrp_setup_heuristic (stbrp_context *context, int heuristic);\n/*  Optionally select which packing heuristic the library should use. Different */\n/*  heuristics will produce better/worse results for different data sets. */\n/*  If you call init again, this will be reset to the default. */\n\nenum\n{\n   STBRP_HEURISTIC_Skyline_default=0,\n   STBRP_HEURISTIC_Skyline_BL_sortHeight = STBRP_HEURISTIC_Skyline_default,\n   STBRP_HEURISTIC_Skyline_BF_sortHeight\n};\n\n\n/* //////////////////////////////////////////////////////////////////////////// */\n/*  */\n/*  the details of the following structures don't matter to you, but they must */\n/*  be visible so you can handle the memory allocations for them */\n\nstruct stbrp_node\n{\n   stbrp_coord  x,y;\n   stbrp_node  *next;\n};\n\nstruct stbrp_context\n{\n   int width;\n   int height;\n   int align;\n   int init_mode;\n   int heuristic;\n   int num_nodes;\n   stbrp_node *active_head;\n   stbrp_node *free_head;\n   stbrp_node extra[2]; /*  we allocate two extra nodes so optimal user-node-count is 'width' not 'width+2' */\n};\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n/* //////////////////////////////////////////////////////////////////////////// */\n/*  */\n/*      IMPLEMENTATION SECTION */\n/*  */\n\n#ifdef STB_RECT_PACK_IMPLEMENTATION\n#ifndef STBRP_SORT\n#include <stdlib.h>\n#define STBRP_SORT qsort\n#endif\n\n#ifndef STBRP_ASSERT\n#include <assert.h>\n#define STBRP_ASSERT assert\n#endif\n\n#ifdef _MSC_VER\n#define STBRP__NOTUSED(v)  (void)(v)\n#define STBRP__CDECL       __cdecl\n#else\n#define STBRP__NOTUSED(v)  (void)sizeof(v)\n#define STBRP__CDECL\n#endif\n\nenum\n{\n   STBRP__INIT_skyline = 1\n};\n\nSTBRP_DEF void stbrp_setup_heuristic(stbrp_context *context, int heuristic)\n{\n   switch (context->init_mode) {\n      case STBRP__INIT_skyline:\n         STBRP_ASSERT(heuristic == STBRP_HEURISTIC_Skyline_BL_sortHeight || heuristic == STBRP_HEURISTIC_Skyline_BF_sortHeight);\n         context->heuristic = heuristic;\n         break;\n      default:\n         STBRP_ASSERT(0);\n   }\n}\n\nSTBRP_DEF void stbrp_setup_allow_out_of_mem(stbrp_context *context, int allow_out_of_mem)\n{\n   if (allow_out_of_mem)\n      /*  if it's ok to run out of memory, then don't bother aligning them; */\n      /*  this gives better packing, but may fail due to OOM (even though */\n      /*  the rectangles easily fit). @TODO a smarter approach would be to only */\n      /*  quantize once we've hit OOM, then we could get rid of this parameter. */\n      context->align = 1;\n   else {\n      /*  if it's not ok to run out of memory, then quantize the widths */\n      /*  so that num_nodes is always enough nodes. */\n      /*  */\n      /*  I.e. num_nodes * align >= width */\n      /*                   align >= width / num_nodes */\n      /*                   align = ceil(width/num_nodes) */\n\n      context->align = (context->width + context->num_nodes-1) / context->num_nodes;\n   }\n}\n\nSTBRP_DEF void stbrp_init_target(stbrp_context *context, int width, int height, stbrp_node *nodes, int num_nodes)\n{\n   int i;\n\n   for (i=0; i < num_nodes-1; ++i)\n      nodes[i].next = &nodes[i+1];\n   nodes[i].next = NULL;\n   context->init_mode = STBRP__INIT_skyline;\n   context->heuristic = STBRP_HEURISTIC_Skyline_default;\n   context->free_head = &nodes[0];\n   context->active_head = &context->extra[0];\n   context->width = width;\n   context->height = height;\n   context->num_nodes = num_nodes;\n   stbrp_setup_allow_out_of_mem(context, 0);\n\n   /*  node 0 is the full width, node 1 is the sentinel (lets us not store width explicitly) */\n   context->extra[0].x = 0;\n   context->extra[0].y = 0;\n   context->extra[0].next = &context->extra[1];\n   context->extra[1].x = (stbrp_coord) width;\n   context->extra[1].y = (1<<30);\n   context->extra[1].next = NULL;\n}\n\n/*  find minimum y position if it starts at x1 */\nstatic int stbrp__skyline_find_min_y(stbrp_context *c, stbrp_node *first, int x0, int width, int *pwaste)\n{\n   stbrp_node *node = first;\n   int x1 = x0 + width;\n   int min_y, visited_width, waste_area;\n\n   STBRP__NOTUSED(c);\n\n   STBRP_ASSERT(first->x <= x0);\n\n   #if 0\n   /*  skip in case we're past the node */\n   while (node->next->x <= x0)\n      ++node;\n   #else\n   STBRP_ASSERT(node->next->x > x0); /*  we ended up handling this in the caller for efficiency */\n   #endif\n\n   STBRP_ASSERT(node->x <= x0);\n\n   min_y = 0;\n   waste_area = 0;\n   visited_width = 0;\n   while (node->x < x1) {\n      if (node->y > min_y) {\n         /*  raise min_y higher. */\n         /*  we've accounted for all waste up to min_y, */\n         /*  but we'll now add more waste for everything we've visited */\n         waste_area += visited_width * (node->y - min_y);\n         min_y = node->y;\n         /*  the first time through, visited_width might be reduced */\n         if (node->x < x0)\n            visited_width += node->next->x - x0;\n         else\n            visited_width += node->next->x - node->x;\n      } else {\n         /*  add waste area */\n         int under_width = node->next->x - node->x;\n         if (under_width + visited_width > width)\n            under_width = width - visited_width;\n         waste_area += under_width * (min_y - node->y);\n         visited_width += under_width;\n      }\n      node = node->next;\n   }\n\n   *pwaste = waste_area;\n   return min_y;\n}\n\ntypedef struct\n{\n   int x,y;\n   stbrp_node **prev_link;\n} stbrp__findresult;\n\nstatic stbrp__findresult stbrp__skyline_find_best_pos(stbrp_context *c, int width, int height)\n{\n   int best_waste = (1<<30), best_x, best_y = (1 << 30);\n   stbrp__findresult fr;\n   stbrp_node **prev, *node, *tail, **best = NULL;\n\n   /*  align to multiple of c->align */\n   width = (width + c->align - 1);\n   width -= width % c->align;\n   STBRP_ASSERT(width % c->align == 0);\n\n   /*  if it can't possibly fit, bail immediately */\n   if (width > c->width || height > c->height) {\n      fr.prev_link = NULL;\n      fr.x = fr.y = 0;\n      return fr;\n   }\n\n   node = c->active_head;\n   prev = &c->active_head;\n   while (node->x + width <= c->width) {\n      int y,waste;\n      y = stbrp__skyline_find_min_y(c, node, node->x, width, &waste);\n      if (c->heuristic == STBRP_HEURISTIC_Skyline_BL_sortHeight) { /*  actually just want to test BL */\n         /*  bottom left */\n         if (y < best_y) {\n            best_y = y;\n            best = prev;\n         }\n      } else {\n         /*  best-fit */\n         if (y + height <= c->height) {\n            /*  can only use it if it first vertically */\n            if (y < best_y || (y == best_y && waste < best_waste)) {\n               best_y = y;\n               best_waste = waste;\n               best = prev;\n            }\n         }\n      }\n      prev = &node->next;\n      node = node->next;\n   }\n\n   best_x = (best == NULL) ? 0 : (*best)->x;\n\n   /*  if doing best-fit (BF), we also have to try aligning right edge to each node position */\n   /*  */\n   /*  e.g, if fitting */\n   /*  */\n   /*      ____________________ */\n   /*     |____________________| */\n   /*  */\n   /*             into */\n   /*  */\n   /*    |                         | */\n   /*    |             ____________| */\n   /*    |____________| */\n   /*  */\n   /*  then right-aligned reduces waste, but bottom-left BL is always chooses left-aligned */\n   /*  */\n   /*  This makes BF take about 2x the time */\n\n   if (c->heuristic == STBRP_HEURISTIC_Skyline_BF_sortHeight) {\n      tail = c->active_head;\n      node = c->active_head;\n      prev = &c->active_head;\n      /*  find first node that's admissible */\n      while (tail->x < width)\n         tail = tail->next;\n      while (tail) {\n         int xpos = tail->x - width;\n         int y,waste;\n         STBRP_ASSERT(xpos >= 0);\n         /*  find the left position that matches this */\n         while (node->next->x <= xpos) {\n            prev = &node->next;\n            node = node->next;\n         }\n         STBRP_ASSERT(node->next->x > xpos && node->x <= xpos);\n         y = stbrp__skyline_find_min_y(c, node, xpos, width, &waste);\n         if (y + height <= c->height) {\n            if (y <= best_y) {\n               if (y < best_y || waste < best_waste || (waste==best_waste && xpos < best_x)) {\n                  best_x = xpos;\n                  STBRP_ASSERT(y <= best_y);\n                  best_y = y;\n                  best_waste = waste;\n                  best = prev;\n               }\n            }\n         }\n         tail = tail->next;\n      }\n   }\n\n   fr.prev_link = best;\n   fr.x = best_x;\n   fr.y = best_y;\n   return fr;\n}\n\nstatic stbrp__findresult stbrp__skyline_pack_rectangle(stbrp_context *context, int width, int height)\n{\n   /*  find best position according to heuristic */\n   stbrp__findresult res = stbrp__skyline_find_best_pos(context, width, height);\n   stbrp_node *node, *cur;\n\n   /*  bail if: */\n   /*     1. it failed */\n   /*     2. the best node doesn't fit (we don't always check this) */\n   /*     3. we're out of memory */\n   if (res.prev_link == NULL || res.y + height > context->height || context->free_head == NULL) {\n      res.prev_link = NULL;\n      return res;\n   }\n\n   /*  on success, create new node */\n   node = context->free_head;\n   node->x = (stbrp_coord) res.x;\n   node->y = (stbrp_coord) (res.y + height);\n\n   context->free_head = node->next;\n\n   /*  insert the new node into the right starting point, and */\n   /*  let 'cur' point to the remaining nodes needing to be */\n   /*  stitched back in */\n\n   cur = *res.prev_link;\n   if (cur->x < res.x) {\n      /*  preserve the existing one, so start testing with the next one */\n      stbrp_node *next = cur->next;\n      cur->next = node;\n      cur = next;\n   } else {\n      *res.prev_link = node;\n   }\n\n   /*  from here, traverse cur and free the nodes, until we get to one */\n   /*  that shouldn't be freed */\n   while (cur->next && cur->next->x <= res.x + width) {\n      stbrp_node *next = cur->next;\n      /*  move the current node to the free list */\n      cur->next = context->free_head;\n      context->free_head = cur;\n      cur = next;\n   }\n\n   /*  stitch the list back in */\n   node->next = cur;\n\n   if (cur->x < res.x + width)\n      cur->x = (stbrp_coord) (res.x + width);\n\n#ifdef _DEBUG\n   cur = context->active_head;\n   while (cur->x < context->width) {\n      STBRP_ASSERT(cur->x < cur->next->x);\n      cur = cur->next;\n   }\n   STBRP_ASSERT(cur->next == NULL);\n\n   {\n      int count=0;\n      cur = context->active_head;\n      while (cur) {\n         cur = cur->next;\n         ++count;\n      }\n      cur = context->free_head;\n      while (cur) {\n         cur = cur->next;\n         ++count;\n      }\n      STBRP_ASSERT(count == context->num_nodes+2);\n   }\n#endif\n\n   return res;\n}\n\nstatic int STBRP__CDECL rect_height_compare(const void *a, const void *b)\n{\n   const stbrp_rect *p = (const stbrp_rect *) a;\n   const stbrp_rect *q = (const stbrp_rect *) b;\n   if (p->h > q->h)\n      return -1;\n   if (p->h < q->h)\n      return  1;\n   return (p->w > q->w) ? -1 : (p->w < q->w);\n}\n\nstatic int STBRP__CDECL rect_original_order(const void *a, const void *b)\n{\n   const stbrp_rect *p = (const stbrp_rect *) a;\n   const stbrp_rect *q = (const stbrp_rect *) b;\n   return (p->was_packed < q->was_packed) ? -1 : (p->was_packed > q->was_packed);\n}\n\nSTBRP_DEF int stbrp_pack_rects(stbrp_context *context, stbrp_rect *rects, int num_rects)\n{\n   int i, all_rects_packed = 1;\n\n   /*  we use the 'was_packed' field internally to allow sorting/unsorting */\n   for (i=0; i < num_rects; ++i) {\n      rects[i].was_packed = i;\n   }\n\n   /*  sort according to heuristic */\n   STBRP_SORT(rects, num_rects, sizeof(rects[0]), rect_height_compare);\n\n   for (i=0; i < num_rects; ++i) {\n      if (rects[i].w == 0 || rects[i].h == 0) {\n         rects[i].x = rects[i].y = 0;  /*  empty rect needs no space */\n      } else {\n         stbrp__findresult fr = stbrp__skyline_pack_rectangle(context, rects[i].w, rects[i].h);\n         if (fr.prev_link) {\n            rects[i].x = (stbrp_coord) fr.x;\n            rects[i].y = (stbrp_coord) fr.y;\n         } else {\n            rects[i].x = rects[i].y = STBRP__MAXVAL;\n         }\n      }\n   }\n\n   /*  unsort */\n   STBRP_SORT(rects, num_rects, sizeof(rects[0]), rect_original_order);\n\n   /*  set was_packed flags and all_rects_packed status */\n   for (i=0; i < num_rects; ++i) {\n      rects[i].was_packed = !(rects[i].x == STBRP__MAXVAL && rects[i].y == STBRP__MAXVAL);\n      if (!rects[i].was_packed)\n         all_rects_packed = 0;\n   }\n\n   /*  return the all_rects_packed status */\n   return all_rects_packed;\n}\n#endif\n\n/*\n------------------------------------------------------------------------------\nThis software is available under 2 licenses -- choose whichever you prefer.\n------------------------------------------------------------------------------\nALTERNATIVE A - MIT License\nCopyright (c) 2017 Sean Barrett\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n------------------------------------------------------------------------------\nALTERNATIVE B - Public Domain (www.unlicense.org)\nThis is free and unencumbered software released into the public domain.\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this\nsoftware, either in source code form or as a compiled binary, for any purpose,\ncommercial or non-commercial, and by any means.\nIn jurisdictions that recognize copyright laws, the author or authors of this\nsoftware dedicate any and all copyright interest in the software to the public\ndomain. We make this dedication for the benefit of the public at large and to\nthe detriment of our heirs and successors. We intend this dedication to be an\novert act of relinquishment in perpetuity of all present and future rights to\nthis software under copyright law.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n------------------------------------------------------------------------------\n*/\n\n/*  stb_truetype.h - v1.26 - public domain */\n/*  authored from 2009-2021 by Sean Barrett / RAD Game Tools */\n/*  */\n/*  ======================================================================= */\n/*  */\n/*     NO SECURITY GUARANTEE -- DO NOT USE THIS ON UNTRUSTED FONT FILES */\n/*  */\n/*  This library does no range checking of the offsets found in the file, */\n/*  meaning an attacker can use it to read arbitrary memory. */\n/*  */\n/*  ======================================================================= */\n/*  */\n/*    This library processes TrueType files: */\n/*         parse files */\n/*         extract glyph metrics */\n/*         extract glyph shapes */\n/*         render glyphs to one-channel bitmaps with antialiasing (box filter) */\n/*         render glyphs to one-channel SDF bitmaps (signed-distance field/function) */\n/*  */\n/*    Todo: */\n/*         non-MS cmaps */\n/*         crashproof on bad data */\n/*         hinting? (no longer patented) */\n/*         cleartype-style AA? */\n/*         optimize: use simple memory allocator for intermediates */\n/*         optimize: build edge-list directly from curves */\n/*         optimize: rasterize directly from curves? */\n/*  */\n/*  ADDITIONAL CONTRIBUTORS */\n/*  */\n/*    Mikko Mononen: compound shape support, more cmap formats */\n/*    Tor Andersson: kerning, subpixel rendering */\n/*    Dougall Johnson: OpenType / Type 2 font handling */\n/*    Daniel Ribeiro Maciel: basic GPOS-based kerning */\n/*  */\n/*    Misc other: */\n/*        Ryan Gordon */\n/*        Simon Glass */\n/*        github:IntellectualKitty */\n/*        Imanol Celaya */\n/*        Daniel Ribeiro Maciel */\n/*  */\n/*    Bug/warning reports/fixes: */\n/*        \"Zer\" on mollyrocket       Fabian \"ryg\" Giesen   github:NiLuJe */\n/*        Cass Everitt               Martins Mozeiko       github:aloucks */\n/*        stoiko (Haemimont Games)   Cap Petschulat        github:oyvindjam */\n/*        Brian Hook                 Omar Cornut           github:vassvik */\n/*        Walter van Niftrik         Ryan Griege */\n/*        David Gow                  Peter LaValle */\n/*        David Given                Sergey Popov */\n/*        Ivan-Assen Ivanov          Giumo X. Clanjor */\n/*        Anthony Pesch              Higor Euripedes */\n/*        Johan Duparc               Thomas Fields */\n/*        Hou Qiming                 Derek Vinyard */\n/*        Rob Loach                  Cort Stratton */\n/*        Kenney Phillis Jr.         Brian Costabile */\n/*        Ken Voskuil (kaesve) */\n/*  */\n/*  VERSION HISTORY */\n/*  */\n/*    1.26 (2021-08-28) fix broken rasterizer */\n/*    1.25 (2021-07-11) many fixes */\n/*    1.24 (2020-02-05) fix warning */\n/*    1.23 (2020-02-02) query SVG data for glyphs; query whole kerning table (but only kern not GPOS) */\n/*    1.22 (2019-08-11) minimize missing-glyph duplication; fix kerning if both 'GPOS' and 'kern' are defined */\n/*    1.21 (2019-02-25) fix warning */\n/*    1.20 (2019-02-07) PackFontRange skips missing codepoints; GetScaleFontVMetrics() */\n/*    1.19 (2018-02-11) GPOS kerning, STBTT_fmod */\n/*    1.18 (2018-01-29) add missing function */\n/*    1.17 (2017-07-23) make more arguments const; doc fix */\n/*    1.16 (2017-07-12) SDF support */\n/*    1.15 (2017-03-03) make more arguments const */\n/*    1.14 (2017-01-16) num-fonts-in-TTC function */\n/*    1.13 (2017-01-02) support OpenType fonts, certain Apple fonts */\n/*    1.12 (2016-10-25) suppress warnings about casting away const with -Wcast-qual */\n/*    1.11 (2016-04-02) fix unused-variable warning */\n/*    1.10 (2016-04-02) user-defined fabs(); rare memory leak; remove duplicate typedef */\n/*    1.09 (2016-01-16) warning fix; avoid crash on outofmem; use allocation userdata properly */\n/*    1.08 (2015-09-13) document stbtt_Rasterize(); fixes for vertical & horizontal edges */\n/*    1.07 (2015-08-01) allow PackFontRanges to accept arrays of sparse codepoints; */\n/*                      variant PackFontRanges to pack and render in separate phases; */\n/*                      fix stbtt_GetFontOFfsetForIndex (never worked for non-0 input?); */\n/*                      fixed an assert() bug in the new rasterizer */\n/*                      replace assert() with STBTT_assert() in new rasterizer */\n/*  */\n/*    Full history can be found at the end of this file. */\n/*  */\n/*  LICENSE */\n/*  */\n/*    See end of file for license information. */\n/*  */\n/*  USAGE */\n/*  */\n/*    Include this file in whatever places need to refer to it. In ONE C/C++ */\n/*    file, write: */\n/*       #define STB_TRUETYPE_IMPLEMENTATION */\n/*    before the #include of this file. This expands out the actual */\n/*    implementation into that C/C++ file. */\n/*  */\n/*    To make the implementation private to the file that generates the implementation, */\n/*       #define STBTT_STATIC */\n/*  */\n/*    Simple 3D API (don't ship this, but it's fine for tools and quick start) */\n/*            stbtt_BakeFontBitmap()               -- bake a font to a bitmap for use as texture */\n/*            stbtt_GetBakedQuad()                 -- compute quad to draw for a given char */\n/*  */\n/*    Improved 3D API (more shippable): */\n/*            #include \"stb_rect_pack.h\"           -- optional, but you really want it */\n/*            stbtt_PackBegin() */\n/*            stbtt_PackSetOversampling()          -- for improved quality on small fonts */\n/*            stbtt_PackFontRanges()               -- pack and renders */\n/*            stbtt_PackEnd() */\n/*            stbtt_GetPackedQuad() */\n/*  */\n/*    \"Load\" a font file from a memory buffer (you have to keep the buffer loaded) */\n/*            stbtt_InitFont() */\n/*            stbtt_GetFontOffsetForIndex()        -- indexing for TTC font collections */\n/*            stbtt_GetNumberOfFonts()             -- number of fonts for TTC font collections */\n/*  */\n/*    Render a unicode codepoint to a bitmap */\n/*            stbtt_GetCodepointBitmap()           -- allocates and returns a bitmap */\n/*            stbtt_MakeCodepointBitmap()          -- renders into bitmap you provide */\n/*            stbtt_GetCodepointBitmapBox()        -- how big the bitmap must be */\n/*  */\n/*    Character advance/positioning */\n/*            stbtt_GetCodepointHMetrics() */\n/*            stbtt_GetFontVMetrics() */\n/*            stbtt_GetFontVMetricsOS2() */\n/*            stbtt_GetCodepointKernAdvance() */\n/*  */\n/*    Starting with version 1.06, the rasterizer was replaced with a new, */\n/*    faster and generally-more-precise rasterizer. The new rasterizer more */\n/*    accurately measures pixel coverage for anti-aliasing, except in the case */\n/*    where multiple shapes overlap, in which case it overestimates the AA pixel */\n/*    coverage. Thus, anti-aliasing of intersecting shapes may look wrong. If */\n/*    this turns out to be a problem, you can re-enable the old rasterizer with */\n/*         #define STBTT_RASTERIZER_VERSION 1 */\n/*    which will incur about a 15% speed hit. */\n/*  */\n/*  ADDITIONAL DOCUMENTATION */\n/*  */\n/*    Immediately after this block comment are a series of sample programs. */\n/*  */\n/*    After the sample programs is the \"header file\" section. This section */\n/*    includes documentation for each API function. */\n/*  */\n/*    Some important concepts to understand to use this library: */\n/*  */\n/*       Codepoint */\n/*          Characters are defined by unicode codepoints, e.g. 65 is */\n/*          uppercase A, 231 is lowercase c with a cedilla, 0x7e30 is */\n/*          the hiragana for \"ma\". */\n/*  */\n/*       Glyph */\n/*          A visual character shape (every codepoint is rendered as */\n/*          some glyph) */\n/*  */\n/*       Glyph index */\n/*          A font-specific integer ID representing a glyph */\n/*  */\n/*       Baseline */\n/*          Glyph shapes are defined relative to a baseline, which is the */\n/*          bottom of uppercase characters. Characters extend both above */\n/*          and below the baseline. */\n/*  */\n/*       Current Point */\n/*          As you draw text to the screen, you keep track of a \"current point\" */\n/*          which is the origin of each character. The current point's vertical */\n/*          position is the baseline. Even \"baked fonts\" use this model. */\n/*  */\n/*       Vertical Font Metrics */\n/*          The vertical qualities of the font, used to vertically position */\n/*          and space the characters. See docs for stbtt_GetFontVMetrics. */\n/*  */\n/*       Font Size in Pixels or Points */\n/*          The preferred interface for specifying font sizes in stb_truetype */\n/*          is to specify how tall the font's vertical extent should be in pixels. */\n/*          If that sounds good enough, skip the next paragraph. */\n/*  */\n/*          Most font APIs instead use \"points\", which are a common typographic */\n/*          measurement for describing font size, defined as 72 points per inch. */\n/*          stb_truetype provides a point API for compatibility. However, true */\n/*          \"per inch\" conventions don't make much sense on computer displays */\n/*          since different monitors have different number of pixels per */\n/*          inch. For example, Windows traditionally uses a convention that */\n/*          there are 96 pixels per inch, thus making 'inch' measurements have */\n/*          nothing to do with inches, and thus effectively defining a point to */\n/*          be 1.333 pixels. Additionally, the TrueType font data provides */\n/*          an explicit scale factor to scale a given font's glyphs to points, */\n/*          but the author has observed that this scale factor is often wrong */\n/*          for non-commercial fonts, thus making fonts scaled in points */\n/*          according to the TrueType spec incoherently sized in practice. */\n/*  */\n/*  DETAILED USAGE: */\n/*  */\n/*   Scale: */\n/*     Select how high you want the font to be, in points or pixels. */\n/*     Call ScaleForPixelHeight or ScaleForMappingEmToPixels to compute */\n/*     a scale factor SF that will be used by all other functions. */\n/*  */\n/*   Baseline: */\n/*     You need to select a y-coordinate that is the baseline of where */\n/*     your text will appear. Call GetFontBoundingBox to get the baseline-relative */\n/*     bounding box for all characters. SF*-y0 will be the distance in pixels */\n/*     that the worst-case character could extend above the baseline, so if */\n/*     you want the top edge of characters to appear at the top of the */\n/*     screen where y=0, then you would set the baseline to SF*-y0. */\n/*  */\n/*   Current point: */\n/*     Set the current point where the first character will appear. The */\n/*     first character could extend left of the current point; this is font */\n/*     dependent. You can either choose a current point that is the leftmost */\n/*     point and hope, or add some padding, or check the bounding box or */\n/*     left-side-bearing of the first character to be displayed and set */\n/*     the current point based on that. */\n/*  */\n/*   Displaying a character: */\n/*     Compute the bounding box of the character. It will contain signed values */\n/*     relative to <current_point, baseline>. I.e. if it returns x0,y0,x1,y1, */\n/*     then the character should be displayed in the rectangle from */\n/*     <current_point+SF*x0, baseline+SF*y0> to <current_point+SF*x1,baseline+SF*y1). */\n/*  */\n/*   Advancing for the next character: */\n/*     Call GlyphHMetrics, and compute 'current_point += SF * advance'. */\n/*  */\n/*  */\n/*  ADVANCED USAGE */\n/*  */\n/*    Quality: */\n/*  */\n/*     - Use the functions with Subpixel at the end to allow your characters */\n/*       to have subpixel positioning. Since the font is anti-aliased, not */\n/*       hinted, this is very import for quality. (This is not possible with */\n/*       baked fonts.) */\n/*  */\n/*     - Kerning is now supported, and if you're supporting subpixel rendering */\n/*       then kerning is worth using to give your text a polished look. */\n/*  */\n/*    Performance: */\n/*  */\n/*     - Convert Unicode codepoints to glyph indexes and operate on the glyphs; */\n/*       if you don't do this, stb_truetype is forced to do the conversion on */\n/*       every call. */\n/*  */\n/*     - There are a lot of memory allocations. We should modify it to take */\n/*       a temp buffer and allocate from the temp buffer (without freeing), */\n/*       should help performance a lot. */\n/*  */\n/*  NOTES */\n/*  */\n/*    The system uses the raw data found in the .ttf file without changing it */\n/*    and without building auxiliary data structures. This is a bit inefficient */\n/*    on little-endian systems (the data is big-endian), but assuming you're */\n/*    caching the bitmaps or glyph shapes this shouldn't be a big deal. */\n/*  */\n/*    It appears to be very hard to programmatically determine what font a */\n/*    given file is in a general way. I provide an API for this, but I don't */\n/*    recommend it. */\n/*  */\n/*  */\n/*  PERFORMANCE MEASUREMENTS FOR 1.06: */\n/*  */\n/*                       32-bit     64-bit */\n/*    Previous release:  8.83 s     7.68 s */\n/*    Pool allocations:  7.72 s     6.34 s */\n/*    Inline sort     :  6.54 s     5.65 s */\n/*    New rasterizer  :  5.63 s     5.00 s */\n\n/* //////////////////////////////////////////////////////////////////////////// */\n/* //////////////////////////////////////////////////////////////////////////// */\n/* // */\n/* //  SAMPLE PROGRAMS */\n/* // */\n/*  */\n/*   Incomplete text-in-3d-api example, which draws quads properly aligned to be lossless. */\n/*   See \"tests/truetype_demo_win32.c\" for a complete version. */\n#if 0\n#define STB_TRUETYPE_IMPLEMENTATION  /*  force following include to generate implementation */\n#include \"stb_truetype.h\"\n\nunsigned char ttf_buffer[1<<20];\nunsigned char temp_bitmap[512*512];\n\nstbtt_bakedchar cdata[96]; /*  ASCII 32..126 is 95 glyphs */\nGLuint ftex;\n\nvoid my_stbtt_initfont(void)\n{\n   fread(ttf_buffer, 1, 1<<20, fopen(\"c:/windows/fonts/times.ttf\", \"rb\"));\n   stbtt_BakeFontBitmap(ttf_buffer,0, 32.0, temp_bitmap,512,512, 32,96, cdata); /*  no guarantee this fits! */\n   /*  can free ttf_buffer at this point */\n   glGenTextures(1, &ftex);\n   glBindTexture(GL_TEXTURE_2D, ftex);\n   glTexImage2D(GL_TEXTURE_2D, 0, GL_ALPHA, 512,512, 0, GL_ALPHA, GL_UNSIGNED_BYTE, temp_bitmap);\n   /*  can free temp_bitmap at this point */\n   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n}\n\nvoid my_stbtt_print(float x, float y, char *text)\n{\n   /*  assume orthographic projection with units = screen pixels, origin at top left */\n   glEnable(GL_BLEND);\n   glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n   glEnable(GL_TEXTURE_2D);\n   glBindTexture(GL_TEXTURE_2D, ftex);\n   glBegin(GL_QUADS);\n   while (*text) {\n      if (*text >= 32 && *text < 128) {\n         stbtt_aligned_quad q;\n         stbtt_GetBakedQuad(cdata, 512,512, *text-32, &x,&y,&q,1);/* 1=opengl & d3d10+,0=d3d9 */\n         glTexCoord2f(q.s0,q.t0); glVertex2f(q.x0,q.y0);\n         glTexCoord2f(q.s1,q.t0); glVertex2f(q.x1,q.y0);\n         glTexCoord2f(q.s1,q.t1); glVertex2f(q.x1,q.y1);\n         glTexCoord2f(q.s0,q.t1); glVertex2f(q.x0,q.y1);\n      }\n      ++text;\n   }\n   glEnd();\n}\n#endif\n/*  */\n/*  */\n/* //////////////////////////////////////////////////////////////////////////// */\n/*  */\n/*  Complete program (this compiles): get a single bitmap, print as ASCII art */\n/*  */\n#if 0\n#include <stdio.h>\n#define STB_TRUETYPE_IMPLEMENTATION  /*  force following include to generate implementation */\n#include \"stb_truetype.h\"\n\nchar ttf_buffer[1<<25];\n\nint main(int argc, char **argv)\n{\n   stbtt_fontinfo font;\n   unsigned char *bitmap;\n   int w,h,i,j,c = (argc > 1 ? atoi(argv[1]) : 'a'), s = (argc > 2 ? atoi(argv[2]) : 20);\n\n   fread(ttf_buffer, 1, 1<<25, fopen(argc > 3 ? argv[3] : \"c:/windows/fonts/arialbd.ttf\", \"rb\"));\n\n   stbtt_InitFont(&font, ttf_buffer, stbtt_GetFontOffsetForIndex(ttf_buffer,0));\n   bitmap = stbtt_GetCodepointBitmap(&font, 0,stbtt_ScaleForPixelHeight(&font, s), c, &w, &h, 0,0);\n\n   for (j=0; j < h; ++j) {\n      for (i=0; i < w; ++i)\n         putchar(\" .:ioVM@\"[bitmap[j*w+i]>>5]);\n      putchar('\\n');\n   }\n   return 0;\n}\n#endif\n/*  */\n/*  Output: */\n/*  */\n/*      .ii. */\n/*     @@@@@@. */\n/*    V@Mio@@o */\n/*    :i.  V@V */\n/*      :oM@@M */\n/*    :@@@MM@M */\n/*    @@o  o@M */\n/*   :@@.  M@M */\n/*    @@@o@@@@ */\n/*    :M@@V:@@. */\n/*  */\n/* //////////////////////////////////////////////////////////////////////////// */\n/*  */\n/*  Complete program: print \"Hello World!\" banner, with bugs */\n/*  */\n#if 0\nchar buffer[24<<20];\nunsigned char screen[20][79];\n\nint main(int arg, char **argv)\n{\n   stbtt_fontinfo font;\n   int i,j,ascent,baseline,ch=0;\n   float scale, xpos=2; /*  leave a little padding in case the character extends left */\n   char *text = \"Heljo World!\"; /*  intentionally misspelled to show 'lj' brokenness */\n\n   fread(buffer, 1, 1000000, fopen(\"c:/windows/fonts/arialbd.ttf\", \"rb\"));\n   stbtt_InitFont(&font, buffer, 0);\n\n   scale = stbtt_ScaleForPixelHeight(&font, 15);\n   stbtt_GetFontVMetrics(&font, &ascent,0,0);\n   baseline = (int) (ascent*scale);\n\n   while (text[ch]) {\n      int advance,lsb,x0,y0,x1,y1;\n      float x_shift = xpos - (float) floor(xpos);\n      stbtt_GetCodepointHMetrics(&font, text[ch], &advance, &lsb);\n      stbtt_GetCodepointBitmapBoxSubpixel(&font, text[ch], scale,scale,x_shift,0, &x0,&y0,&x1,&y1);\n      stbtt_MakeCodepointBitmapSubpixel(&font, &screen[baseline + y0][(int) xpos + x0], x1-x0,y1-y0, 79, scale,scale,x_shift,0, text[ch]);\n      /*  note that this stomps the old data, so where character boxes overlap (e.g. 'lj') it's wrong */\n      /*  because this API is really for baking character bitmaps into textures. if you want to render */\n      /*  a sequence of characters, you really need to render each bitmap to a temp buffer, then */\n      /*  \"alpha blend\" that into the working buffer */\n      xpos += (advance * scale);\n      if (text[ch+1])\n         xpos += scale*stbtt_GetCodepointKernAdvance(&font, text[ch],text[ch+1]);\n      ++ch;\n   }\n\n   for (j=0; j < 20; ++j) {\n      for (i=0; i < 78; ++i)\n         putchar(\" .:ioVM@\"[screen[j][i]>>5]);\n      putchar('\\n');\n   }\n\n   return 0;\n}\n#endif\n\n\n/* //////////////////////////////////////////////////////////////////////////// */\n/* //////////////////////////////////////////////////////////////////////////// */\n/* // */\n/* //   INTEGRATION WITH YOUR CODEBASE */\n/* // */\n/* //   The following sections allow you to supply alternate definitions */\n/* //   of C library functions used by stb_truetype, e.g. if you don't */\n/* //   link with the C runtime library. */\n\n#ifdef STB_TRUETYPE_IMPLEMENTATION\n   /*  #define your own (u)stbtt_int8/16/32 before including to override this */\n   #ifndef stbtt_uint8\n   typedef unsigned char   stbtt_uint8;\n   typedef signed   char   stbtt_int8;\n   typedef unsigned short  stbtt_uint16;\n   typedef signed   short  stbtt_int16;\n   typedef unsigned int    stbtt_uint32;\n   typedef signed   int    stbtt_int32;\n   #endif\n\n   typedef char stbtt__check_size32[sizeof(stbtt_int32)==4 ? 1 : -1];\n   typedef char stbtt__check_size16[sizeof(stbtt_int16)==2 ? 1 : -1];\n\n   /*  e.g. #define your own STBTT_ifloor/STBTT_iceil() to avoid math.h */\n   #ifndef STBTT_ifloor\n   #include <math.h>\n   #define STBTT_ifloor(x)   ((int) floor(x))\n   #define STBTT_iceil(x)    ((int) ceil(x))\n   #endif\n\n   #ifndef STBTT_sqrt\n   #include <math.h>\n   #define STBTT_sqrt(x)      sqrt(x)\n   #define STBTT_pow(x,y)     pow(x,y)\n   #endif\n\n   #ifndef STBTT_fmod\n   #include <math.h>\n   #define STBTT_fmod(x,y)    fmod(x,y)\n   #endif\n\n   #ifndef STBTT_cos\n   #include <math.h>\n   #define STBTT_cos(x)       cos(x)\n   #define STBTT_acos(x)      acos(x)\n   #endif\n\n   #ifndef STBTT_fabs\n   #include <math.h>\n   #define STBTT_fabs(x)      fabs(x)\n   #endif\n\n   /*  #define your own functions \"STBTT_malloc\" / \"STBTT_free\" to avoid malloc.h */\n   #ifndef STBTT_malloc\n   #include <stdlib.h>\n   #define STBTT_malloc(x,u)  ((void)(u),malloc(x))\n   #define STBTT_free(x,u)    ((void)(u),free(x))\n   #endif\n\n   #ifndef STBTT_assert\n   #include <assert.h>\n   #define STBTT_assert(x)    assert(x)\n   #endif\n\n   #ifndef STBTT_strlen\n   #include <string.h>\n   #define STBTT_strlen(x)    strlen(x)\n   #endif\n\n   #ifndef STBTT_memcpy\n   #include <string.h>\n   #define STBTT_memcpy       memcpy\n   #define STBTT_memset       memset\n   #endif\n#endif\n\n/* ///////////////////////////////////////////////////////////////////////////// */\n/* ///////////////////////////////////////////////////////////////////////////// */\n/* // */\n/* //   INTERFACE */\n/* // */\n/* // */\n\n#ifndef __STB_INCLUDE_STB_TRUETYPE_H__\n#define __STB_INCLUDE_STB_TRUETYPE_H__\n\n#ifdef STBTT_STATIC\n#define STBTT_DEF static\n#else\n#define STBTT_DEF extern\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/*  private structure */\ntypedef struct\n{\n   unsigned char *data;\n   int cursor;\n   int size;\n} stbtt__buf;\n\n/* //////////////////////////////////////////////////////////////////////////// */\n/*  */\n/*  TEXTURE BAKING API */\n/*  */\n/*  If you use this API, you only have to call two functions ever. */\n/*  */\n\ntypedef struct\n{\n   unsigned short x0,y0,x1,y1; /*  coordinates of bbox in bitmap */\n   float xoff,yoff,xadvance;\n} stbtt_bakedchar;\n\nSTBTT_DEF int stbtt_BakeFontBitmap(const unsigned char *data, int offset,  /*  font location (use offset=0 for plain .ttf) */\n                                float pixel_height,                     /*  height of font in pixels */\n                                unsigned char *pixels, int pw, int ph,  /*  bitmap to be filled in */\n                                int first_char, int num_chars,          /*  characters to bake */\n                                stbtt_bakedchar *chardata);             /*  you allocate this, it's num_chars long */\n/*  if return is positive, the first unused row of the bitmap */\n/*  if return is negative, returns the negative of the number of characters that fit */\n/*  if return is 0, no characters fit and no rows were used */\n/*  This uses a very crappy packing. */\n\ntypedef struct\n{\n   float x0,y0,s0,t0; /*  top-left */\n   float x1,y1,s1,t1; /*  bottom-right */\n} stbtt_aligned_quad;\n\nSTBTT_DEF void stbtt_GetBakedQuad(const stbtt_bakedchar *chardata, int pw, int ph,  /*  same data as above */\n                               int char_index,             /*  character to display */\n                               float *xpos, float *ypos,   /*  pointers to current position in screen pixel space */\n                               stbtt_aligned_quad *q,      /*  output: quad to draw */\n                               int opengl_fillrule);       /*  true if opengl fill rule; false if DX9 or earlier */\n/*  Call GetBakedQuad with char_index = 'character - first_char', and it */\n/*  creates the quad you need to draw and advances the current position. */\n/*  */\n/*  The coordinate system used assumes y increases downwards. */\n/*  */\n/*  Characters will extend both above and below the current position; */\n/*  see discussion of \"BASELINE\" above. */\n/*  */\n/*  It's inefficient; you might want to c&p it and optimize it. */\n\nSTBTT_DEF void stbtt_GetScaledFontVMetrics(const unsigned char *fontdata, int index, float size, float *ascent, float *descent, float *lineGap);\n/*  Query the font vertical metrics without having to create a font first. */\n\n\n/* //////////////////////////////////////////////////////////////////////////// */\n/*  */\n/*  NEW TEXTURE BAKING API */\n/*  */\n/*  This provides options for packing multiple fonts into one atlas, not */\n/*  perfectly but better than nothing. */\n\ntypedef struct\n{\n   unsigned short x0,y0,x1,y1; /*  coordinates of bbox in bitmap */\n   float xoff,yoff,xadvance;\n   float xoff2,yoff2;\n} stbtt_packedchar;\n\ntypedef struct stbtt_pack_context stbtt_pack_context;\ntypedef struct stbtt_fontinfo stbtt_fontinfo;\n#ifndef STB_RECT_PACK_VERSION\ntypedef struct stbrp_rect stbrp_rect;\n#endif\n\nSTBTT_DEF int  stbtt_PackBegin(stbtt_pack_context *spc, unsigned char *pixels, int width, int height, int stride_in_bytes, int padding, void *alloc_context);\n/*  Initializes a packing context stored in the passed-in stbtt_pack_context. */\n/*  Future calls using this context will pack characters into the bitmap passed */\n/*  in here: a 1-channel bitmap that is width * height. stride_in_bytes is */\n/*  the distance from one row to the next (or 0 to mean they are packed tightly */\n/*  together). \"padding\" is the amount of padding to leave between each */\n/*  character (normally you want '1' for bitmaps you'll use as textures with */\n/*  bilinear filtering). */\n/*  */\n/*  Returns 0 on failure, 1 on success. */\n\nSTBTT_DEF void stbtt_PackEnd  (stbtt_pack_context *spc);\n/*  Cleans up the packing context and frees all memory. */\n\n#define STBTT_POINT_SIZE(x)   (-(x))\n\nSTBTT_DEF int  stbtt_PackFontRange(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, float font_size,\n                                int first_unicode_char_in_range, int num_chars_in_range, stbtt_packedchar *chardata_for_range);\n/*  Creates character bitmaps from the font_index'th font found in fontdata (use */\n/*  font_index=0 if you don't know what that is). It creates num_chars_in_range */\n/*  bitmaps for characters with unicode values starting at first_unicode_char_in_range */\n/*  and increasing. Data for how to render them is stored in chardata_for_range; */\n/*  pass these to stbtt_GetPackedQuad to get back renderable quads. */\n/*  */\n/*  font_size is the full height of the character from ascender to descender, */\n/*  as computed by stbtt_ScaleForPixelHeight. To use a point size as computed */\n/*  by stbtt_ScaleForMappingEmToPixels, wrap the point size in STBTT_POINT_SIZE() */\n/*  and pass that result as 'font_size': */\n/*        ...,                  20 , ... // font max minus min y is 20 pixels tall */\n/*        ..., STBTT_POINT_SIZE(20), ... // 'M' is 20 pixels tall */\n\ntypedef struct\n{\n   float font_size;\n   int first_unicode_codepoint_in_range;  /*  if non-zero, then the chars are continuous, and this is the first codepoint */\n   int *array_of_unicode_codepoints;       /*  if non-zero, then this is an array of unicode codepoints */\n   int num_chars;\n   stbtt_packedchar *chardata_for_range; /*  output */\n   unsigned char h_oversample, v_oversample; /*  don't set these, they're used internally */\n} stbtt_pack_range;\n\nSTBTT_DEF int  stbtt_PackFontRanges(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, stbtt_pack_range *ranges, int num_ranges);\n/*  Creates character bitmaps from multiple ranges of characters stored in */\n/*  ranges. This will usually create a better-packed bitmap than multiple */\n/*  calls to stbtt_PackFontRange. Note that you can call this multiple */\n/*  times within a single PackBegin/PackEnd. */\n\nSTBTT_DEF void stbtt_PackSetOversampling(stbtt_pack_context *spc, unsigned int h_oversample, unsigned int v_oversample);\n/*  Oversampling a font increases the quality by allowing higher-quality subpixel */\n/*  positioning, and is especially valuable at smaller text sizes. */\n/*  */\n/*  This function sets the amount of oversampling for all following calls to */\n/*  stbtt_PackFontRange(s) or stbtt_PackFontRangesGatherRects for a given */\n/*  pack context. The default (no oversampling) is achieved by h_oversample=1 */\n/*  and v_oversample=1. The total number of pixels required is */\n/*  h_oversample*v_oversample larger than the default; for example, 2x2 */\n/*  oversampling requires 4x the storage of 1x1. For best results, render */\n/*  oversampled textures with bilinear filtering. Look at the readme in */\n/*  stb/tests/oversample for information about oversampled fonts */\n/*  */\n/*  To use with PackFontRangesGather etc., you must set it before calls */\n/*  call to PackFontRangesGatherRects. */\n\nSTBTT_DEF void stbtt_PackSetSkipMissingCodepoints(stbtt_pack_context *spc, int skip);\n/*  If skip != 0, this tells stb_truetype to skip any codepoints for which */\n/*  there is no corresponding glyph. If skip=0, which is the default, then */\n/*  codepoints without a glyph recived the font's \"missing character\" glyph, */\n/*  typically an empty box by convention. */\n\nSTBTT_DEF void stbtt_GetPackedQuad(const stbtt_packedchar *chardata, int pw, int ph,  /*  same data as above */\n                               int char_index,             /*  character to display */\n                               float *xpos, float *ypos,   /*  pointers to current position in screen pixel space */\n                               stbtt_aligned_quad *q,      /*  output: quad to draw */\n                               int align_to_integer);\n\nSTBTT_DEF int  stbtt_PackFontRangesGatherRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects);\nSTBTT_DEF void stbtt_PackFontRangesPackRects(stbtt_pack_context *spc, stbrp_rect *rects, int num_rects);\nSTBTT_DEF int  stbtt_PackFontRangesRenderIntoRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects);\n/*  Calling these functions in sequence is roughly equivalent to calling */\n/*  stbtt_PackFontRanges(). If you more control over the packing of multiple */\n/*  fonts, or if you want to pack custom data into a font texture, take a look */\n/*  at the source to of stbtt_PackFontRanges() and create a custom version */\n/*  using these functions, e.g. call GatherRects multiple times, */\n/*  building up a single array of rects, then call PackRects once, */\n/*  then call RenderIntoRects repeatedly. This may result in a */\n/*  better packing than calling PackFontRanges multiple times */\n/*  (or it may not). */\n\n/*  this is an opaque structure that you shouldn't mess with which holds */\n/*  all the context needed from PackBegin to PackEnd. */\nstruct stbtt_pack_context {\n   void *user_allocator_context;\n   void *pack_info;\n   int   width;\n   int   height;\n   int   stride_in_bytes;\n   int   padding;\n   int   skip_missing;\n   unsigned int   h_oversample, v_oversample;\n   unsigned char *pixels;\n   void  *nodes;\n};\n\n/* //////////////////////////////////////////////////////////////////////////// */\n/*  */\n/*  FONT LOADING */\n/*  */\n/*  */\n\nSTBTT_DEF int stbtt_GetNumberOfFonts(const unsigned char *data);\n/*  This function will determine the number of fonts in a font file.  TrueType */\n/*  collection (.ttc) files may contain multiple fonts, while TrueType font */\n/*  (.ttf) files only contain one font. The number of fonts can be used for */\n/*  indexing with the previous function where the index is between zero and one */\n/*  less than the total fonts. If an error occurs, -1 is returned. */\n\nSTBTT_DEF int stbtt_GetFontOffsetForIndex(const unsigned char *data, int index);\n/*  Each .ttf/.ttc file may have more than one font. Each font has a sequential */\n/*  index number starting from 0. Call this function to get the font offset for */\n/*  a given index; it returns -1 if the index is out of range. A regular .ttf */\n/*  file will only define one font and it always be at offset 0, so it will */\n/*  return '0' for index 0, and -1 for all other indices. */\n\n/*  The following structure is defined publicly so you can declare one on */\n/*  the stack or as a global or etc, but you should treat it as opaque. */\nstruct stbtt_fontinfo\n{\n   void           * userdata;\n   unsigned char  * data;              /*  pointer to .ttf file */\n   int              fontstart;         /*  offset of start of font */\n\n   int numGlyphs;                     /*  number of glyphs, needed for range checking */\n\n   int loca,head,glyf,hhea,hmtx,kern,gpos,svg; /*  table locations as offset from start of .ttf */\n   int index_map;                     /*  a cmap mapping for our chosen character encoding */\n   int indexToLocFormat;              /*  format needed to map from glyph index to glyph */\n\n   stbtt__buf cff;                    /*  cff font data */\n   stbtt__buf charstrings;            /*  the charstring index */\n   stbtt__buf gsubrs;                 /*  global charstring subroutines index */\n   stbtt__buf subrs;                  /*  private charstring subroutines index */\n   stbtt__buf fontdicts;              /*  array of font dicts */\n   stbtt__buf fdselect;               /*  map from glyph to fontdict */\n};\n\nSTBTT_DEF int stbtt_InitFont(stbtt_fontinfo *info, const unsigned char *data, int offset);\n/*  Given an offset into the file that defines a font, this function builds */\n/*  the necessary cached info for the rest of the system. You must allocate */\n/*  the stbtt_fontinfo yourself, and stbtt_InitFont will fill it out. You don't */\n/*  need to do anything special to free it, because the contents are pure */\n/*  value data with no additional data structures. Returns 0 on failure. */\n\n\n/* //////////////////////////////////////////////////////////////////////////// */\n/*  */\n/*  CHARACTER TO GLYPH-INDEX CONVERSIOn */\n\nSTBTT_DEF int stbtt_FindGlyphIndex(const stbtt_fontinfo *info, int unicode_codepoint);\n/*  If you're going to perform multiple operations on the same character */\n/*  and you want a speed-up, call this function with the character you're */\n/*  going to process, then use glyph-based functions instead of the */\n/*  codepoint-based functions. */\n/*  Returns 0 if the character codepoint is not defined in the font. */\n\n\n/* //////////////////////////////////////////////////////////////////////////// */\n/*  */\n/*  CHARACTER PROPERTIES */\n/*  */\n\nSTBTT_DEF float stbtt_ScaleForPixelHeight(const stbtt_fontinfo *info, float pixels);\n/*  computes a scale factor to produce a font whose \"height\" is 'pixels' tall. */\n/*  Height is measured as the distance from the highest ascender to the lowest */\n/*  descender; in other words, it's equivalent to calling stbtt_GetFontVMetrics */\n/*  and computing: */\n/*        scale = pixels / (ascent - descent) */\n/*  so if you prefer to measure height by the ascent only, use a similar calculation. */\n\nSTBTT_DEF float stbtt_ScaleForMappingEmToPixels(const stbtt_fontinfo *info, float pixels);\n/*  computes a scale factor to produce a font whose EM size is mapped to */\n/*  'pixels' tall. This is probably what traditional APIs compute, but */\n/*  I'm not positive. */\n\nSTBTT_DEF void stbtt_GetFontVMetrics(const stbtt_fontinfo *info, int *ascent, int *descent, int *lineGap);\n/*  ascent is the coordinate above the baseline the font extends; descent */\n/*  is the coordinate below the baseline the font extends (i.e. it is typically negative) */\n/*  lineGap is the spacing between one row's descent and the next row's ascent... */\n/*  so you should advance the vertical position by \"*ascent - *descent + *lineGap\" */\n/*    these are expressed in unscaled coordinates, so you must multiply by */\n/*    the scale factor for a given size */\n\nSTBTT_DEF int  stbtt_GetFontVMetricsOS2(const stbtt_fontinfo *info, int *typoAscent, int *typoDescent, int *typoLineGap);\n/*  analogous to GetFontVMetrics, but returns the \"typographic\" values from the OS/2 */\n/*  table (specific to MS/Windows TTF files). */\n/*  */\n/*  Returns 1 on success (table present), 0 on failure. */\n\nSTBTT_DEF void stbtt_GetFontBoundingBox(const stbtt_fontinfo *info, int *x0, int *y0, int *x1, int *y1);\n/*  the bounding box around all possible characters */\n\nSTBTT_DEF void stbtt_GetCodepointHMetrics(const stbtt_fontinfo *info, int codepoint, int *advanceWidth, int *leftSideBearing);\n/*  leftSideBearing is the offset from the current horizontal position to the left edge of the character */\n/*  advanceWidth is the offset from the current horizontal position to the next horizontal position */\n/*    these are expressed in unscaled coordinates */\n\nSTBTT_DEF int  stbtt_GetCodepointKernAdvance(const stbtt_fontinfo *info, int ch1, int ch2);\n/*  an additional amount to add to the 'advance' value between ch1 and ch2 */\n\nSTBTT_DEF int stbtt_GetCodepointBox(const stbtt_fontinfo *info, int codepoint, int *x0, int *y0, int *x1, int *y1);\n/*  Gets the bounding box of the visible part of the glyph, in unscaled coordinates */\n\nSTBTT_DEF void stbtt_GetGlyphHMetrics(const stbtt_fontinfo *info, int glyph_index, int *advanceWidth, int *leftSideBearing);\nSTBTT_DEF int  stbtt_GetGlyphKernAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2);\nSTBTT_DEF int  stbtt_GetGlyphBox(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1);\n/*  as above, but takes one or more glyph indices for greater efficiency */\n\ntypedef struct stbtt_kerningentry\n{\n   int glyph1; /*  use stbtt_FindGlyphIndex */\n   int glyph2;\n   int advance;\n} stbtt_kerningentry;\n\nSTBTT_DEF int  stbtt_GetKerningTableLength(const stbtt_fontinfo *info);\nSTBTT_DEF int  stbtt_GetKerningTable(const stbtt_fontinfo *info, stbtt_kerningentry* table, int table_length);\n/*  Retrieves a complete list of all of the kerning pairs provided by the font */\n/*  stbtt_GetKerningTable never writes more than table_length entries and returns how many entries it did write. */\n/*  The table will be sorted by (a.glyph1 == b.glyph1)?(a.glyph2 < b.glyph2):(a.glyph1 < b.glyph1) */\n\n/* //////////////////////////////////////////////////////////////////////////// */\n/*  */\n/*  GLYPH SHAPES (you probably don't need these, but they have to go before */\n/*  the bitmaps for C declaration-order reasons) */\n/*  */\n\n#ifndef STBTT_vmove /*  you can predefine these to use different values (but why?) */\n   enum {\n      STBTT_vmove=1,\n      STBTT_vline,\n      STBTT_vcurve,\n      STBTT_vcubic\n   };\n#endif\n\n#ifndef stbtt_vertex /*  you can predefine this to use different values */\n                   /*  (we share this with other code at RAD) */\n   #define stbtt_vertex_type short /*  can't use stbtt_int16 because that's not visible in the header file */\n   typedef struct\n   {\n      stbtt_vertex_type x,y,cx,cy,cx1,cy1;\n      unsigned char type,padding;\n   } stbtt_vertex;\n#endif\n\nSTBTT_DEF int stbtt_IsGlyphEmpty(const stbtt_fontinfo *info, int glyph_index);\n/*  returns non-zero if nothing is drawn for this glyph */\n\nSTBTT_DEF int stbtt_GetCodepointShape(const stbtt_fontinfo *info, int unicode_codepoint, stbtt_vertex **vertices);\nSTBTT_DEF int stbtt_GetGlyphShape(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **vertices);\n/*  returns # of vertices and fills *vertices with the pointer to them */\n/*    these are expressed in \"unscaled\" coordinates */\n/*  */\n/*  The shape is a series of contours. Each one starts with */\n/*  a STBTT_moveto, then consists of a series of mixed */\n/*  STBTT_lineto and STBTT_curveto segments. A lineto */\n/*  draws a line from previous endpoint to its x,y; a curveto */\n/*  draws a quadratic bezier from previous endpoint to */\n/*  its x,y, using cx,cy as the bezier control point. */\n\nSTBTT_DEF void stbtt_FreeShape(const stbtt_fontinfo *info, stbtt_vertex *vertices);\n/*  frees the data allocated above */\n\nSTBTT_DEF unsigned char *stbtt_FindSVGDoc(const stbtt_fontinfo *info, int gl);\nSTBTT_DEF int stbtt_GetCodepointSVG(const stbtt_fontinfo *info, int unicode_codepoint, const char **svg);\nSTBTT_DEF int stbtt_GetGlyphSVG(const stbtt_fontinfo *info, int gl, const char **svg);\n/*  fills svg with the character's SVG data. */\n/*  returns data size or 0 if SVG not found. */\n\n/* //////////////////////////////////////////////////////////////////////////// */\n/*  */\n/*  BITMAP RENDERING */\n/*  */\n\nSTBTT_DEF void stbtt_FreeBitmap(unsigned char *bitmap, void *userdata);\n/*  frees the bitmap allocated below */\n\nSTBTT_DEF unsigned char *stbtt_GetCodepointBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int codepoint, int *width, int *height, int *xoff, int *yoff);\n/*  allocates a large-enough single-channel 8bpp bitmap and renders the */\n/*  specified character/glyph at the specified scale into it, with */\n/*  antialiasing. 0 is no coverage (transparent), 255 is fully covered (opaque). */\n/*  *width & *height are filled out with the width & height of the bitmap, */\n/*  which is stored left-to-right, top-to-bottom. */\n/*  */\n/*  xoff/yoff are the offset it pixel space from the glyph origin to the top-left of the bitmap */\n\nSTBTT_DEF unsigned char *stbtt_GetCodepointBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint, int *width, int *height, int *xoff, int *yoff);\n/*  the same as stbtt_GetCodepoitnBitmap, but you can specify a subpixel */\n/*  shift for the character */\n\nSTBTT_DEF void stbtt_MakeCodepointBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int codepoint);\n/*  the same as stbtt_GetCodepointBitmap, but you pass in storage for the bitmap */\n/*  in the form of 'output', with row spacing of 'out_stride' bytes. the bitmap */\n/*  is clipped to out_w/out_h bytes. Call stbtt_GetCodepointBitmapBox to get the */\n/*  width and height and positioning info for it first. */\n\nSTBTT_DEF void stbtt_MakeCodepointBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint);\n/*  same as stbtt_MakeCodepointBitmap, but you can specify a subpixel */\n/*  shift for the character */\n\nSTBTT_DEF void stbtt_MakeCodepointBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int oversample_x, int oversample_y, float *sub_x, float *sub_y, int codepoint);\n/*  same as stbtt_MakeCodepointBitmapSubpixel, but prefiltering */\n/*  is performed (see stbtt_PackSetOversampling) */\n\nSTBTT_DEF void stbtt_GetCodepointBitmapBox(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1);\n/*  get the bbox of the bitmap centered around the glyph origin; so the */\n/*  bitmap width is ix1-ix0, height is iy1-iy0, and location to place */\n/*  the bitmap top left is (leftSideBearing*scale,iy0). */\n/*  (Note that the bitmap uses y-increases-down, but the shape uses */\n/*  y-increases-up, so CodepointBitmapBox and CodepointBox are inverted.) */\n\nSTBTT_DEF void stbtt_GetCodepointBitmapBoxSubpixel(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1);\n/*  same as stbtt_GetCodepointBitmapBox, but you can specify a subpixel */\n/*  shift for the character */\n\n/*  the following functions are equivalent to the above functions, but operate */\n/*  on glyph indices instead of Unicode codepoints (for efficiency) */\nSTBTT_DEF unsigned char *stbtt_GetGlyphBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int glyph, int *width, int *height, int *xoff, int *yoff);\nSTBTT_DEF unsigned char *stbtt_GetGlyphBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, int *width, int *height, int *xoff, int *yoff);\nSTBTT_DEF void stbtt_MakeGlyphBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int glyph);\nSTBTT_DEF void stbtt_MakeGlyphBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int glyph);\nSTBTT_DEF void stbtt_MakeGlyphBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int oversample_x, int oversample_y, float *sub_x, float *sub_y, int glyph);\nSTBTT_DEF void stbtt_GetGlyphBitmapBox(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1);\nSTBTT_DEF void stbtt_GetGlyphBitmapBoxSubpixel(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y,float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1);\n\n\n/*  @TODO: don't expose this structure */\ntypedef struct\n{\n   int w,h,stride;\n   unsigned char *pixels;\n} stbtt__bitmap;\n\n/*  rasterize a shape with quadratic beziers into a bitmap */\nSTBTT_DEF void stbtt_Rasterize(stbtt__bitmap *result,        /*  1-channel bitmap to draw into */\n                               float flatness_in_pixels,     /*  allowable error of curve in pixels */\n                               stbtt_vertex *vertices,       /*  array of vertices defining shape */\n                               int num_verts,                /*  number of vertices in above array */\n                               float scale_x, float scale_y, /*  scale applied to input vertices */\n                               float shift_x, float shift_y, /*  translation applied to input vertices */\n                               int x_off, int y_off,         /*  another translation applied to input */\n                               int invert,                   /*  if non-zero, vertically flip shape */\n                               void *userdata);              /*  context for to STBTT_MALLOC */\n\n/* //////////////////////////////////////////////////////////////////////////// */\n/*  */\n/*  Signed Distance Function (or Field) rendering */\n\nSTBTT_DEF void stbtt_FreeSDF(unsigned char *bitmap, void *userdata);\n/*  frees the SDF bitmap allocated below */\n\nSTBTT_DEF unsigned char * stbtt_GetGlyphSDF(const stbtt_fontinfo *info, float scale, int glyph, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff);\nSTBTT_DEF unsigned char * stbtt_GetCodepointSDF(const stbtt_fontinfo *info, float scale, int codepoint, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff);\n/*  These functions compute a discretized SDF field for a single character, suitable for storing */\n/*  in a single-channel texture, sampling with bilinear filtering, and testing against */\n/*  larger than some threshold to produce scalable fonts. */\n/*         info              --  the font */\n/*         scale             --  controls the size of the resulting SDF bitmap, same as it would be creating a regular bitmap */\n/*         glyph/codepoint   --  the character to generate the SDF for */\n/*         padding           --  extra \"pixels\" around the character which are filled with the distance to the character (not 0), */\n/*                                  which allows effects like bit outlines */\n/*         onedge_value      --  value 0-255 to test the SDF against to reconstruct the character (i.e. the isocontour of the character) */\n/*         pixel_dist_scale  --  what value the SDF should increase by when moving one SDF \"pixel\" away from the edge (on the 0..255 scale) */\n/*                                  if positive, > onedge_value is inside; if negative, < onedge_value is inside */\n/*         width,height      --  output height & width of the SDF bitmap (including padding) */\n/*         xoff,yoff         --  output origin of the character */\n/*         return value      --  a 2D array of bytes 0..255, width*height in size */\n/*  */\n/*  pixel_dist_scale & onedge_value are a scale & bias that allows you to make */\n/*  optimal use of the limited 0..255 for your application, trading off precision */\n/*  and special effects. SDF values outside the range 0..255 are clamped to 0..255. */\n/*  */\n/*  Example: */\n/*       scale = stbtt_ScaleForPixelHeight(22) */\n/*       padding = 5 */\n/*       onedge_value = 180 */\n/*       pixel_dist_scale = 180/5.0 = 36.0 */\n/*  */\n/*       This will create an SDF bitmap in which the character is about 22 pixels */\n/*       high but the whole bitmap is about 22+5+5=32 pixels high. To produce a filled */\n/*       shape, sample the SDF at each pixel and fill the pixel if the SDF value */\n/*       is greater than or equal to 180/255. (You'll actually want to antialias, */\n/*       which is beyond the scope of this example.) Additionally, you can compute */\n/*       offset outlines (e.g. to stroke the character border inside & outside, */\n/*       or only outside). For example, to fill outside the character up to 3 SDF */\n/*       pixels, you would compare against (180-36.0*3)/255 = 72/255. The above */\n/*       choice of variables maps a range from 5 pixels outside the shape to */\n/*       2 pixels inside the shape to 0..255; this is intended primarily for apply */\n/*       outside effects only (the interior range is needed to allow proper */\n/*       antialiasing of the font at *smaller* sizes) */\n/*  */\n/*  The function computes the SDF analytically at each SDF pixel, not by e.g. */\n/*  building a higher-res bitmap and approximating it. In theory the quality */\n/*  should be as high as possible for an SDF of this size & representation, but */\n/*  unclear if this is true in practice (perhaps building a higher-res bitmap */\n/*  and computing from that can allow drop-out prevention). */\n/*  */\n/*  The algorithm has not been optimized at all, so expect it to be slow */\n/*  if computing lots of characters or very large sizes. */\n\n\n\n/* //////////////////////////////////////////////////////////////////////////// */\n/*  */\n/*  Finding the right font... */\n/*  */\n/*  You should really just solve this offline, keep your own tables */\n/*  of what font is what, and don't try to get it out of the .ttf file. */\n/*  That's because getting it out of the .ttf file is really hard, because */\n/*  the names in the file can appear in many possible encodings, in many */\n/*  possible languages, and e.g. if you need a case-insensitive comparison, */\n/*  the details of that depend on the encoding & language in a complex way */\n/*  (actually underspecified in truetype, but also gigantic). */\n/*  */\n/*  But you can use the provided functions in two possible ways: */\n/*      stbtt_FindMatchingFont() will use *case-sensitive* comparisons on */\n/*              unicode-encoded names to try to find the font you want; */\n/*              you can run this before calling stbtt_InitFont() */\n/*  */\n/*      stbtt_GetFontNameString() lets you get any of the various strings */\n/*              from the file yourself and do your own comparisons on them. */\n/*              You have to have called stbtt_InitFont() first. */\n\n\nSTBTT_DEF int stbtt_FindMatchingFont(const unsigned char *fontdata, const char *name, int flags);\n/*  returns the offset (not index) of the font that matches, or -1 if none */\n/*    if you use STBTT_MACSTYLE_DONTCARE, use a font name like \"Arial Bold\". */\n/*    if you use any other flag, use a font name like \"Arial\"; this checks */\n/*      the 'macStyle' header field; i don't know if fonts set this consistently */\n#define STBTT_MACSTYLE_DONTCARE     0\n#define STBTT_MACSTYLE_BOLD         1\n#define STBTT_MACSTYLE_ITALIC       2\n#define STBTT_MACSTYLE_UNDERSCORE   4\n#define STBTT_MACSTYLE_NONE         8   /*  <= not same as 0, this makes us check the bitfield is 0 */\n\nSTBTT_DEF int stbtt_CompareUTF8toUTF16_bigendian(const char *s1, int len1, const char *s2, int len2);\n/*  returns 1/0 whether the first string interpreted as utf8 is identical to */\n/*  the second string interpreted as big-endian utf16... useful for strings from next func */\n\nSTBTT_DEF const char *stbtt_GetFontNameString(const stbtt_fontinfo *font, int *length, int platformID, int encodingID, int languageID, int nameID);\n/*  returns the string (which may be big-endian double byte, e.g. for unicode) */\n/*  and puts the length in bytes in *length. */\n/*  */\n/*  some of the values for the IDs are below; for more see the truetype spec: */\n/*      http://developer.apple.com/textfonts/TTRefMan/RM06/Chap6name.html */\n/*      http://www.microsoft.com/typography/otspec/name.htm */\n\nenum { /*  platformID */\n   STBTT_PLATFORM_ID_UNICODE   =0,\n   STBTT_PLATFORM_ID_MAC       =1,\n   STBTT_PLATFORM_ID_ISO       =2,\n   STBTT_PLATFORM_ID_MICROSOFT =3\n};\n\nenum { /*  encodingID for STBTT_PLATFORM_ID_UNICODE */\n   STBTT_UNICODE_EID_UNICODE_1_0    =0,\n   STBTT_UNICODE_EID_UNICODE_1_1    =1,\n   STBTT_UNICODE_EID_ISO_10646      =2,\n   STBTT_UNICODE_EID_UNICODE_2_0_BMP=3,\n   STBTT_UNICODE_EID_UNICODE_2_0_FULL=4\n};\n\nenum { /*  encodingID for STBTT_PLATFORM_ID_MICROSOFT */\n   STBTT_MS_EID_SYMBOL        =0,\n   STBTT_MS_EID_UNICODE_BMP   =1,\n   STBTT_MS_EID_SHIFTJIS      =2,\n   STBTT_MS_EID_UNICODE_FULL  =10\n};\n\nenum { /*  encodingID for STBTT_PLATFORM_ID_MAC; same as Script Manager codes */\n   STBTT_MAC_EID_ROMAN        =0,   STBTT_MAC_EID_ARABIC       =4,\n   STBTT_MAC_EID_JAPANESE     =1,   STBTT_MAC_EID_HEBREW       =5,\n   STBTT_MAC_EID_CHINESE_TRAD =2,   STBTT_MAC_EID_GREEK        =6,\n   STBTT_MAC_EID_KOREAN       =3,   STBTT_MAC_EID_RUSSIAN      =7\n};\n\nenum { /*  languageID for STBTT_PLATFORM_ID_MICROSOFT; same as LCID... */\n       /*  problematic because there are e.g. 16 english LCIDs and 16 arabic LCIDs */\n   STBTT_MS_LANG_ENGLISH     =0x0409,   STBTT_MS_LANG_ITALIAN     =0x0410,\n   STBTT_MS_LANG_CHINESE     =0x0804,   STBTT_MS_LANG_JAPANESE    =0x0411,\n   STBTT_MS_LANG_DUTCH       =0x0413,   STBTT_MS_LANG_KOREAN      =0x0412,\n   STBTT_MS_LANG_FRENCH      =0x040c,   STBTT_MS_LANG_RUSSIAN     =0x0419,\n   STBTT_MS_LANG_GERMAN      =0x0407,   STBTT_MS_LANG_SPANISH     =0x0409,\n   STBTT_MS_LANG_HEBREW      =0x040d,   STBTT_MS_LANG_SWEDISH     =0x041D\n};\n\nenum { /*  languageID for STBTT_PLATFORM_ID_MAC */\n   STBTT_MAC_LANG_ENGLISH      =0 ,   STBTT_MAC_LANG_JAPANESE     =11,\n   STBTT_MAC_LANG_ARABIC       =12,   STBTT_MAC_LANG_KOREAN       =23,\n   STBTT_MAC_LANG_DUTCH        =4 ,   STBTT_MAC_LANG_RUSSIAN      =32,\n   STBTT_MAC_LANG_FRENCH       =1 ,   STBTT_MAC_LANG_SPANISH      =6 ,\n   STBTT_MAC_LANG_GERMAN       =2 ,   STBTT_MAC_LANG_SWEDISH      =5 ,\n   STBTT_MAC_LANG_HEBREW       =10,   STBTT_MAC_LANG_CHINESE_SIMPLIFIED =33,\n   STBTT_MAC_LANG_ITALIAN      =3 ,   STBTT_MAC_LANG_CHINESE_TRAD =19\n};\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /*  __STB_INCLUDE_STB_TRUETYPE_H__ */\n\n/* ///////////////////////////////////////////////////////////////////////////// */\n/* ///////////////////////////////////////////////////////////////////////////// */\n/* // */\n/* //   IMPLEMENTATION */\n/* // */\n/* // */\n\n#ifdef STB_TRUETYPE_IMPLEMENTATION\n\n#ifndef STBTT_MAX_OVERSAMPLE\n#define STBTT_MAX_OVERSAMPLE   8\n#endif\n\n#if STBTT_MAX_OVERSAMPLE > 255\n#error \"STBTT_MAX_OVERSAMPLE cannot be > 255\"\n#endif\n\ntypedef int stbtt__test_oversample_pow2[(STBTT_MAX_OVERSAMPLE & (STBTT_MAX_OVERSAMPLE-1)) == 0 ? 1 : -1];\n\n#ifndef STBTT_RASTERIZER_VERSION\n#define STBTT_RASTERIZER_VERSION 2\n#endif\n\n#ifdef _MSC_VER\n#define STBTT__NOTUSED(v)  (void)(v)\n#else\n#define STBTT__NOTUSED(v)  (void)sizeof(v)\n#endif\n\n/* //////////////////////////////////////////////////////////////////////// */\n/*  */\n/*  stbtt__buf helpers to parse data from file */\n/*  */\n\nstatic stbtt_uint8 stbtt__buf_get8(stbtt__buf *b)\n{\n   if (b->cursor >= b->size)\n      return 0;\n   return b->data[b->cursor++];\n}\n\nstatic stbtt_uint8 stbtt__buf_peek8(stbtt__buf *b)\n{\n   if (b->cursor >= b->size)\n      return 0;\n   return b->data[b->cursor];\n}\n\nstatic void stbtt__buf_seek(stbtt__buf *b, int o)\n{\n   STBTT_assert(!(o > b->size || o < 0));\n   b->cursor = (o > b->size || o < 0) ? b->size : o;\n}\n\nstatic void stbtt__buf_skip(stbtt__buf *b, int o)\n{\n   stbtt__buf_seek(b, b->cursor + o);\n}\n\nstatic stbtt_uint32 stbtt__buf_get(stbtt__buf *b, int n)\n{\n   stbtt_uint32 v = 0;\n   int i;\n   STBTT_assert(n >= 1 && n <= 4);\n   for (i = 0; i < n; i++)\n      v = (v << 8) | stbtt__buf_get8(b);\n   return v;\n}\n\nstatic stbtt__buf stbtt__new_buf(const void *p, size_t size)\n{\n   stbtt__buf r;\n   STBTT_assert(size < 0x40000000);\n   r.data = (stbtt_uint8*) p;\n   r.size = (int) size;\n   r.cursor = 0;\n   return r;\n}\n\n#define stbtt__buf_get16(b)  stbtt__buf_get((b), 2)\n#define stbtt__buf_get32(b)  stbtt__buf_get((b), 4)\n\nstatic stbtt__buf stbtt__buf_range(const stbtt__buf *b, int o, int s)\n{\n   stbtt__buf r = stbtt__new_buf(NULL, 0);\n   if (o < 0 || s < 0 || o > b->size || s > b->size - o) return r;\n   r.data = b->data + o;\n   r.size = s;\n   return r;\n}\n\nstatic stbtt__buf stbtt__cff_get_index(stbtt__buf *b)\n{\n   int count, start, offsize;\n   start = b->cursor;\n   count = stbtt__buf_get16(b);\n   if (count) {\n      offsize = stbtt__buf_get8(b);\n      STBTT_assert(offsize >= 1 && offsize <= 4);\n      stbtt__buf_skip(b, offsize * count);\n      stbtt__buf_skip(b, stbtt__buf_get(b, offsize) - 1);\n   }\n   return stbtt__buf_range(b, start, b->cursor - start);\n}\n\nstatic stbtt_uint32 stbtt__cff_int(stbtt__buf *b)\n{\n   int b0 = stbtt__buf_get8(b);\n   if (b0 >= 32 && b0 <= 246)       return b0 - 139;\n   else if (b0 >= 247 && b0 <= 250) return (b0 - 247)*256 + stbtt__buf_get8(b) + 108;\n   else if (b0 >= 251 && b0 <= 254) return -(b0 - 251)*256 - stbtt__buf_get8(b) - 108;\n   else if (b0 == 28)               return stbtt__buf_get16(b);\n   else if (b0 == 29)               return stbtt__buf_get32(b);\n   STBTT_assert(0);\n   return 0;\n}\n\nstatic void stbtt__cff_skip_operand(stbtt__buf *b) {\n   int v, b0 = stbtt__buf_peek8(b);\n   STBTT_assert(b0 >= 28);\n   if (b0 == 30) {\n      stbtt__buf_skip(b, 1);\n      while (b->cursor < b->size) {\n         v = stbtt__buf_get8(b);\n         if ((v & 0xF) == 0xF || (v >> 4) == 0xF)\n            break;\n      }\n   } else {\n      stbtt__cff_int(b);\n   }\n}\n\nstatic stbtt__buf stbtt__dict_get(stbtt__buf *b, int key)\n{\n   stbtt__buf_seek(b, 0);\n   while (b->cursor < b->size) {\n      int start = b->cursor, end, op;\n      while (stbtt__buf_peek8(b) >= 28)\n         stbtt__cff_skip_operand(b);\n      end = b->cursor;\n      op = stbtt__buf_get8(b);\n      if (op == 12)  op = stbtt__buf_get8(b) | 0x100;\n      if (op == key) return stbtt__buf_range(b, start, end-start);\n   }\n   return stbtt__buf_range(b, 0, 0);\n}\n\nstatic void stbtt__dict_get_ints(stbtt__buf *b, int key, int outcount, stbtt_uint32 *out)\n{\n   int i;\n   stbtt__buf operands = stbtt__dict_get(b, key);\n   for (i = 0; i < outcount && operands.cursor < operands.size; i++)\n      out[i] = stbtt__cff_int(&operands);\n}\n\nstatic int stbtt__cff_index_count(stbtt__buf *b)\n{\n   stbtt__buf_seek(b, 0);\n   return stbtt__buf_get16(b);\n}\n\nstatic stbtt__buf stbtt__cff_index_get(stbtt__buf b, int i)\n{\n   int count, offsize, start, end;\n   stbtt__buf_seek(&b, 0);\n   count = stbtt__buf_get16(&b);\n   offsize = stbtt__buf_get8(&b);\n   STBTT_assert(i >= 0 && i < count);\n   STBTT_assert(offsize >= 1 && offsize <= 4);\n   stbtt__buf_skip(&b, i*offsize);\n   start = stbtt__buf_get(&b, offsize);\n   end = stbtt__buf_get(&b, offsize);\n   return stbtt__buf_range(&b, 2+(count+1)*offsize+start, end - start);\n}\n\n/* //////////////////////////////////////////////////////////////////////// */\n/*  */\n/*  accessors to parse data from file */\n/*  */\n\n/*  on platforms that don't allow misaligned reads, if we want to allow */\n/*  truetype fonts that aren't padded to alignment, define ALLOW_UNALIGNED_TRUETYPE */\n\n#define ttBYTE(p)     (* (stbtt_uint8 *) (p))\n#define ttCHAR(p)     (* (stbtt_int8 *) (p))\n#define ttFixed(p)    ttLONG(p)\n\nstatic stbtt_uint16 ttUSHORT(stbtt_uint8 *p) { return p[0]*256 + p[1]; }\nstatic stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }\nstatic stbtt_uint32 ttULONG(stbtt_uint8 *p)  { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }\nstatic stbtt_int32 ttLONG(stbtt_uint8 *p)    { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }\n\n#define stbtt_tag4(p,c0,c1,c2,c3) ((p)[0] == (c0) && (p)[1] == (c1) && (p)[2] == (c2) && (p)[3] == (c3))\n#define stbtt_tag(p,str)           stbtt_tag4(p,str[0],str[1],str[2],str[3])\n\nstatic int stbtt__isfont(stbtt_uint8 *font)\n{\n   /*  check the version number */\n   if (stbtt_tag4(font, '1',0,0,0))  return 1; /*  TrueType 1 */\n   if (stbtt_tag(font, \"typ1\"))   return 1; /*  TrueType with type 1 font -- we don't support this! */\n   if (stbtt_tag(font, \"OTTO\"))   return 1; /*  OpenType with CFF */\n   if (stbtt_tag4(font, 0,1,0,0)) return 1; /*  OpenType 1.0 */\n   if (stbtt_tag(font, \"true\"))   return 1; /*  Apple specification for TrueType fonts */\n   return 0;\n}\n\n/*  @OPTIMIZE: binary search */\nstatic stbtt_uint32 stbtt__find_table(stbtt_uint8 *data, stbtt_uint32 fontstart, const char *tag)\n{\n   stbtt_int32 num_tables = ttUSHORT(data+fontstart+4);\n   stbtt_uint32 tabledir = fontstart + 12;\n   stbtt_int32 i;\n   for (i=0; i < num_tables; ++i) {\n      stbtt_uint32 loc = tabledir + 16*i;\n      if (stbtt_tag(data+loc+0, tag))\n         return ttULONG(data+loc+8);\n   }\n   return 0;\n}\n\nstatic int stbtt_GetFontOffsetForIndex_internal(unsigned char *font_collection, int index)\n{\n   /*  if it's just a font, there's only one valid index */\n   if (stbtt__isfont(font_collection))\n      return index == 0 ? 0 : -1;\n\n   /*  check if it's a TTC */\n   if (stbtt_tag(font_collection, \"ttcf\")) {\n      /*  version 1? */\n      if (ttULONG(font_collection+4) == 0x00010000 || ttULONG(font_collection+4) == 0x00020000) {\n         stbtt_int32 n = ttLONG(font_collection+8);\n         if (index >= n)\n            return -1;\n         return ttULONG(font_collection+12+index*4);\n      }\n   }\n   return -1;\n}\n\nstatic int stbtt_GetNumberOfFonts_internal(unsigned char *font_collection)\n{\n   /*  if it's just a font, there's only one valid font */\n   if (stbtt__isfont(font_collection))\n      return 1;\n\n   /*  check if it's a TTC */\n   if (stbtt_tag(font_collection, \"ttcf\")) {\n      /*  version 1? */\n      if (ttULONG(font_collection+4) == 0x00010000 || ttULONG(font_collection+4) == 0x00020000) {\n         return ttLONG(font_collection+8);\n      }\n   }\n   return 0;\n}\n\nstatic stbtt__buf stbtt__get_subrs(stbtt__buf cff, stbtt__buf fontdict)\n{\n   stbtt_uint32 subrsoff = 0, private_loc[2] = { 0, 0 };\n   stbtt__buf pdict;\n   stbtt__dict_get_ints(&fontdict, 18, 2, private_loc);\n   if (!private_loc[1] || !private_loc[0]) return stbtt__new_buf(NULL, 0);\n   pdict = stbtt__buf_range(&cff, private_loc[1], private_loc[0]);\n   stbtt__dict_get_ints(&pdict, 19, 1, &subrsoff);\n   if (!subrsoff) return stbtt__new_buf(NULL, 0);\n   stbtt__buf_seek(&cff, private_loc[1]+subrsoff);\n   return stbtt__cff_get_index(&cff);\n}\n\n/*  since most people won't use this, find this table the first time it's needed */\nstatic int stbtt__get_svg(stbtt_fontinfo *info)\n{\n   stbtt_uint32 t;\n   if (info->svg < 0) {\n      t = stbtt__find_table(info->data, info->fontstart, \"SVG \");\n      if (t) {\n         stbtt_uint32 offset = ttULONG(info->data + t + 2);\n         info->svg = t + offset;\n      } else {\n         info->svg = 0;\n      }\n   }\n   return info->svg;\n}\n\nstatic int stbtt_InitFont_internal(stbtt_fontinfo *info, unsigned char *data, int fontstart)\n{\n   stbtt_uint32 cmap, t;\n   stbtt_int32 i,numTables;\n\n   info->data = "
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}