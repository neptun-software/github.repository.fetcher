{
  "metadata": {
    "timestamp": 1736710288593,
    "page": 62,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjcw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "floooh/sokol",
      "stars": 7503,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.1240234375,
          "content": "root=true\n[**]\nindent_style=space\nindent_size=4\ntrim_trailing_whitespace=true\ninsert_final_newline=true\n\n[*.yml]\nindent_size=2\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0859375,
          "content": ".vscode/\nbuild/\n#>fips\n# this area is managed by fips, do not edit\n.fips-*\n*.pyc\n#<fips\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 171.8271484375,
          "content": "## Updates\n\n### 12-Jan-2025\n\n- The Jai and D language bindings now also have integrated comments\n  (see https://github.com/floooh/sokol/pull/1182 and https://github.com/floooh/sokol/pull/1183).\n- sokol_app.h html5: a new init flag `sapp_desc.html5_update_document_title` has been\n  added. When this is set to true, sokol-app will overwrite the HTML `document.title` property with\n  the `sapp_desc.window_title` string (also see issue https://github.com/floooh/sokol/issues/1132\n  and PR https://github.com/floooh/sokol/pull/1186)\n\n### 11-Jan-2025\n\nThe language bindings code-generation can now extract comments from the C headers\nand include them into the language bindings. Currently this is supported in\nthe Odin and Zig bindings, but adding comments to the other language bindings\nis fairly easy since the bulk of the work happens in the common `gen_ir.py` script\nwhich parses the C API declarations into a JSON tree.\n\nRelated PR: https://github.com/floooh/sokol/pull/1176, many thanks to\n@AlexanderArvidsson!\n\n### 17-Dec-2024\n\n- sokol_imgui.h (breaking change): user-provided images and samplers are now\n  stashed directly in a Dear ImGui ImTextureID handle instead of in a separate backing\n  object (this is possible now because ImTextureID is now guaranteed to be 64 bits,\n  so it can directly hold two 32-bit sokol-gfx handles). This change drastically\n  simplifies the sokol_imgui.h implementatation, but requires some breaking API\n  changes (please read the updated doc section `ON USER-PROVIDED IMAGES AND SAMPLERS`\n  in sokol_imgui.h)\n- sokol_gfx.h: a couple of new functions to get granular buffer and image properties\n  called `sg_query_buffer_[property]()` and `sg_query_image_[property]()`. Those are\n  cheaper than the similar `sg_query_buffer_desc()` and `sg_query_image_desc()`\n  functions if you only need to get one or few properties.\n- sokol_gfx_imgui.h: internal non-breaking fixes for the sokol_imgui.h API update.\n\nAssociated PR: https://github.com/floooh/sokol/pull/1169\n\n### 14-Dec-2024\n\n- sokol_app.h win32: merged PR https://github.com/floooh/sokol/pull/1167, this\n  adds a new config define `SOKOL_WIN32_FORCE_WINMAIN`. This allows to expose\n  both a `main()` and `WinMain()` entry point in the same link library by\n  defining both `SOKOL_WIN32_FORCE_MAIN` and `SOKOL_WIN32_FORCE_WINMAIN` before\n  including the sokol_app.h implementation.\n  In this case sokol_app.h will not automatically activate the right Windows subsystem\n  via `#pragma comment (linker) \"/subsystem:X\")` though, instead the build system\n  must take care of picking the correct subsystem.\n\n  Many thanks to @Querijn for the PR!\n\n### 08-Dec-2924\n\n- sokol_imgui.h: when compiling the implementation in C mode, it is now possible\n  to define an alternative function prefix via the define SOKOL_IMGUI_CPREFIX\n  (with `ig` being the default prefix), this allows sokol_imgui.h to be\n  used with the default dear_bindings prefix (which is `ImGui_`), the\n  traditional cimgui.h prefix (`ig`) and it is also possible to not use\n  a prefix at all, which might be useful for language bindings.\n\n  See PR https://github.com/floooh/sokol/pull/1166 for details.\n\n### 07-Dec-2024\n\n- Changes in sokol_imgui.h and sokol_gfx_imgui.h for a switch of the Dear ImGui\n  C bindings from https://github.com/cimgui/cimgui to https://github.com/floooh/dcimgui\n  (this is a 'source distribution repository' with the Dear ImGui C binding generated through the\n  new 'official' dear_bindings code generation - see https://github.com/dearimgui/dear_bindings).\n\n  This is only a breaking change if you include the sokol_gfx_imgui.h implementation\n  into a C source file, in that case you need to switch from https://github.com/cimgui/cimgui\n  to https://github.com/floooh/dcimgui. All other scenarios should be backward\n  compatible.\n\n  For details see PR https://github.com/floooh/sokol/pull/1163\n\n### 23-Nov-2024\n\n- sokol_app.h html5: Merged PR https://github.com/floooh/sokol/pull/1159 (related\n  issue https://github.com/floooh/sokol/issues/1154).\n\n  This cleans up code that is concerned about finding the WebGL/WebGPU HTML canvas by:\n\n    - removing any leftover hacks from the time when Emscripten moved\n      from `document.getElementById()` to `document.querySelector()` for\n      looking up the canvas object\n    - adding two options for canvas objects that can't be looked up via\n      `document.querySelector()`\n\n  If you don't provide a custom canvas name to sokol_app.h this change\n  is non-breaking. Otherwise:\n\n    - in sokol_main(): change `.html5_canvas_name` to `.html5_canvas_selector`\n    - change the canvas name string to a CSS selector string (e.g.\n    from `\"my_canvas\"` to `\"#my_canvas\"`)\n\n  For more options to communicate the HTML canvas object to sokol_app.h,\n  please read the new doc section `SETTING THE CANVAS OBJECT ON THE WEB PLATFORM` in sokol_app.h.\n\n  Additionally, please also note the simplified `shell.html` in the\n  sokol-samples repository (some outdated cruft has been removed):\n\n  https://github.com/floooh/sokol-samples/blob/master/webpage/shell.html\n\n  Many thanks to @konsumer for kicking off the feature and the following\n  discussion :)\n\n\n### 19-Nov-2024\n\n- Merged PR https://github.com/floooh/sokol/pull/1155, this allows to use\n  MSAA textures as resource bindings to load individual MSAA samples in\n  shaders. This is an optional feature and isn't supported on the following\n  platform/backend combos:\n\n  - macOS+GL\n  - iOS+GLES3\n  - WebGL2\n  - Android\n\n  You can also check the new feature flag `sg_features.msaa_image_bindings`\n  for support at runtime.\n\n  There's also a new sample https://floooh.github.io/sokol-webgpu/customresolve-sapp.html\n  which demonstrates how to access multisampled textures and the MSAA coverage mask\n  (requires a browser with WebGPU support).\n\n### 13-Nov-2024\n\n- sokol_nuklear.h: merge PR https://github.com/floooh/sokol/pull/1150, this allows to connect the\n  Nuklear mouse cursor handling to the sokol_app.h mouse cursor functions\n  via the new `snk_desc_t.enable_set_mouse_cursor` config flag. When setting\n  this to true you'd also might want to hide the Nuklear software mouse\n  cursor via `nk_style_hide_cursor(ctx)`. Many thanks to @zeozeozeo for the PR!\n\n### 09-Nov-2024\n\nPlease be aware of this regression fix in sokol-shdc:\n\nhttps://github.com/floooh/sokol-tools/blob/master/CHANGELOG.md#09-nov-2024\n\n### 07-Nov-2024\n\nThe sokol-gfx 'bindings cleanup update'. This is a breaking change.\n\nPlease read this blog post to get an idea what the update is about\nand how existing code needs to be changed:\n\nhttps://floooh.github.io/2024/11/04/sokol-fall-2024-update.html\n\nTL;DR:\n\n- sokol-shdc input shader sources now require to annotate uniform blocks,\n  textures, samplers and storage buffers with `layout(binding=N)` where `N`\n  directly maps to sokol-gfx bindslots\n- the concept of 'shader stages' has mostly been removed from the sokol-gfx API\n- in the `sg_bindings` struct, the nested per-shader-stage binding arrays have\n  been replaced with unified binding arrays\n- in the function `sg_apply_uniforms()`, the shader stage parameter has been\n  removed\n- only relevant if you don't use sokol-shdc: the interior of the `sg_shader_desc`\n  struct has been changed according to the new binding model, and additional\n  information must be provided for each resource binding:\n    - what shader change the binding appears in\n    - backend 3D API specific resource bindslots to map sokol-gfx\n      bindslots to 3D API bindslots\n\nThe update is implemented in PR https://github.com/floooh/sokol/pull/1111.\n\nThe detailed API changes in the sokol_gfx.h API:\n\n- the `sg_apply_uniforms()` function no longer has a shader stage parameter:\n    ```c\n    void sg_apply_uniforms(int ub_slot, const sg_range* data);\n    ```\n- the `sg_bindings` struct interior no longer separates resource\n  bindings by shader stages:\n    ```c\n    typedef struct sg_bindings {\n        uint32_t _start_canary;\n        sg_buffer vertex_buffers[SG_MAX_VERTEXBUFFER_BINDSLOTS];\n        int vertex_buffer_offsets[SG_MAX_VERTEXBUFFER_BINDSLOTS];\n        sg_buffer index_buffer;\n        int index_buffer_offset;\n        sg_image images[SG_MAX_IMAGE_BINDSLOTS];\n        sg_sampler samplers[SG_MAX_SAMPLER_BINDSLOTS];\n        sg_buffer storage_buffers[SG_MAX_STORAGEBUFFER_BINDSLOTS];\n        uint32_t _end_canary;\n    } sg_bindings;\n    ```\n- some public constants starting with `SG_NUM_*` or `SG_MAX_*`\n  have been removed or renamed (those typically shouldn't show up\n  in user code)\n- similar to the `sg_bindings` struct, the bindings reflection is no\n  longer split between shader stages in `sg_shader_desc`:\n  ```c\n  typedef struct sg_shader_desc {\n      uint32_t _start_canary;\n      sg_shader_function vertex_func;\n      sg_shader_function fragment_func;\n      sg_shader_vertex_attr attrs[SG_MAX_VERTEX_ATTRIBUTES];\n      sg_shader_uniform_block uniform_blocks[SG_MAX_UNIFORMBLOCK_BINDSLOTS];\n      sg_shader_storage_buffer storage_buffers[SG_MAX_STORAGEBUFFER_BINDSLOTS];\n      sg_shader_image images[SG_MAX_IMAGE_BINDSLOTS];\n      sg_shader_sampler samplers[SG_MAX_SAMPLER_BINDSLOTS];\n      sg_shader_image_sampler_pair image_sampler_pairs[SG_MAX_IMAGE_SAMPLER_PAIRS];\n      const char* label;\n      uint32_t _end_canary;\n  } sg_shader_desc;\n  ```\n\nBehaviour changes:\n\n- Resource bindings can now have gaps, and validation of `sg_apply_bindings()`\n  has been relaxed to allow bindslots in `sg_bindings` to be occupied even\n  if those bindings are not used by the current shader. This allows to use the\n  same `sg_bindings` struct for different but related shader variants.\n- Likewise, uniform block bindslots can now have gaps (but currently it's still\n  an error trying to apply uniform block data for a bindslot that's not used\n  by the current shader)\n- In debug mode, `sg_draw()` now checks that `sg_apply_bindings()` and/or\n  `sg_apply_uniforms()` has been called after `sg_apply_pipeline()` when required.\n- Lots of new validation checks for the new reflection information in `sg_shader_desc`.\n\nDrive by fixes:\n\n- the sokol_gfx.h WebGPU backend is now compatible again with the latest\n  Google Dawn library (Chrome's native WebGPU implementation)\n- the [fips-dawn glue repository](https://github.com/fips-libs/fips-dawn) has been fixed to work with the latest\n  Dawn build system changes (still only tested on macOS though)\n\n### 24-Oct-2024\n\n- sokol_nuklear.h: Merged https://github.com/floooh/sokol/pull/1138 which\n  allows to use Nuklear's software mouse cursors. Many thanks to @dlannan!\n\n### 22-Oct-2024\n\n- sokol_imgui.h: Fixed for latest Dear ImGui version 1.91.4 (Dear ImGui has\n  changed the ImTextureID handle from `void*` to `uint64_t` which requires some\n  minor fixes, also in the public API (so technically it's a breaking change\n  but it's unlikely that most code will be affected).\n\n  Many thanks to @DctrNoob for the PR (https://github.com/floooh/sokol/pull/1134).\n\n  Also related change if you're using fips: the following ImGui wrapper repos\n  have been updated to 1.91.4:\n\n  - https://github.com/fips-libs/fips-imgui\n  - https://github.com/fips-libs/fips-cimgui\n  - https://github.com/fips-libs/fips-imgui-dock\n\n  PS: This Dear ImGui change will also allow to remove a lot of complexity\n  from sokol_imgui again which was necessary after the image/sampler split\n  in sokol_gfx.h. Since ImTextureID is now guaranteed to be 64-bits (even when\n  the pointer size is 32-bits like on WASM), it's possible to stash the sokol-gfx\n  image- and sampler-handles (which are 32-bits each) directly into the 64-bit\n  ImTextureID instead of maintaining an internal object in sokol_imgui.h just\n  to associate a sokol-gfx image handle with a sampler handle. That's for a later\n  time though :)\n\n### 14-Oct-2024\n\n- sokol_gfx.h: The pixel format RG11B10F is now marked as renderable in the GL\n  backend (generally on desktop GL, and on GLES3/WebGL2 when the necessary\n  extensions are present). Many thanks to @kcbanner for the PR\n  (https://github.com/floooh/sokol/pull/1121)!\n\n### 17-Sep-2024\n\n- The sokol_app.h Linux backend now has clipboard support. Many thanks to\n  @Dvad for the initial PR with most of the work and @qwx9 for the addtional\n  updates. See PR https://github.com/floooh/sokol/pull/1108 for details (this\n  isn't quite what ended up in sokol_app.h either, because I did a couple of code\n  cleanup changes during the merge).\n\n### 10-Sep-2024\n\n- Update sokol_imgui.h for Dear ImGui and cimgui version 1.91.1. This\n  breaks compatibility with older ImGui versions.\n  Fixes issue https://github.com/floooh/sokol/issues/1105.\n\n### 02-Sep-2024\n\n- Minor breaking change in sokol_gfx.h: The enum item `SG_FILTER_NONE` has been\n  removed. Until around Oct-2023 this was required to be used as mip-filter\n  on textures without mipmaps because of an unnecessary restriction in the\n  GL backend (see https://github.com/floooh/sokol/issues/929 for details).\n  The concept of a 'none' mipmap filter never mapped to some 3D backends\n  (specifically D3D11 and WebGPU).\n  If you are currently creating samplers with `.mipmap_filter = SG_FILTER_NONE`\n  you can simply remove that line. The new default value is `SG_FILTER_NEAREST`.\n  To restrict mipmap sampling access to a specific mipmap (or mipmap range),\n  use the `.min_lod` and `.max_lod` items in struct `sg_sampler_desc`.\n\n  The change has been implemented in PR https://github.com/floooh/sokol/pull/1103.\n\n### 01-Sep-2024\n\n- sokol_gfx.h d3d11: added a new configuration flag `d3d11_shader_debugging`\n  to the `sg_desc` struct. When this is true, D3D11 shaders which are provided\n  as HLSL source code will be compiled with debug information and no optimization\n  which allows shader debugging in tools like RenderDoc. If you use `sokol-shdc`\n  to build shaders, just omit the `--bytecode / -b` cmdline option to get\n  HLSL source code instead of bytecode, if you use the `fips` build system\n  wrapper (like the `sokol-samples` project), just replace the cmake macro\n  `sokol_shader()` with `sokol_shader_debuggable()`.\n\n  For details see issue https://github.com/floooh/sokol/issues/1043\n  and PR: https://github.com/floooh/sokol/pull/1101.\n\n### 31-Aug-2024\n\n- Some cleanup work in the WebGPU backend bindgroups cache which fixes\n  a number of issues: Destroying an image, sampler, storage buffer\n  or pipeline object now properly evicts any associated item in\n  the bindgroups cache and releases the associated WebGPU BindGroup\n  object. Doing this while the BindGroup is in flight also no longer\n  causes WebGPU errors.\n\n  For details see issue https://github.com/floooh/sokol/issues/1066\n  and PR https://github.com/floooh/sokol/pull/1097\n\n- A fix in the sokol-zig bindings generator for a breaking naming convention\n  change in the Zig stdlib. The fix supports both the old and new naming\n  convention so that sokol-zig continues to be compatible with zig 0.13.0.\n\n  To update the sokol-zig dependency in your project, just run:\n\n  ```\n  zig fetch --save=sokol git+https://github.com/floooh/sokol-zig.git\n  ```\n\n  More Details in PR https://github.com/floooh/sokol/pull/1100\n\n### 26-Aug-2024\n\nA small behaviour update for sokol_gl.h (may be breaking if you call `sgl_error()`):\n\n- Instead of skipping rendering completely for the current frame if an error is encountered\n  (for instance the vertex- or command-buffer running full), sokol-gl will now\n  render all successfully recorded draw commands before the error was recorded.\n- Minor breaking change: `sgl_error_t` has been changed from an error code enum to\n  a struct with a boolean flag per error type, that way no error information is\n  lost if multiple error happen in the same frame.\n- Two new functions to query the current number of recorded vertices and commands\n  in the current frame:\n    - `int sgl_num_vertices(void)`\n    - `int sgl_num_commands(void)`\n\nAlso see ticket https://github.com/floooh/sokol/issues/1092 and PR https://github.com/floooh/sokol/pull/1096 for details!\n\n### 14-Aug-2024\n\nThe previously 'unofficial' Jai bindings at https://github.com/colinbellino/sokol-jai\nhave now been properly integrated with the sokol main repository (meaning that each\nchange to the sokol headers will update the bindings automatically).\n\nThe only missing part currently is that no test compilation happens in the CI\npipeline (that's also why the Jai bindings have no badge yet in the readme, I\nthink these things will have to wait until Jai leaves closed beta).\n\nMany thanks to @colinbellino for creating the bindings scripts and preparing\nthe PR (https://github.com/floooh/sokol/pull/1090).\n\n### 30-Jul-2024\n\nMerged PR https://github.com/floooh/sokol/pull/1086 which adds Emscripten target platform\nsupport for the Nim bindings. Please also see PR https://github.com/floooh/sokol-nim/pull/31\nand the sokol-nim readme for details: https://github.com/floooh/sokol-nim\n\nMany thanks to @Nazariglez for the PRs!\n\n### 28-Jul-2024\n\nsokol_gfx.h WebGL2: An important hotfix/workaround for a regression\nin Chrome v127 on macOS and Safari Technology Preview 199 which broke all offscreen\nrendering in sokol_gfx.h on WebGL2. The details are here https://github.com/floooh/sokol/issues/1085\nand in this Chromium ticket: https://issues.chromium.org/issues/355605685.\n\nThe PR is here: https://github.com/floooh/sokol/pull/1087\n\nIt might take a little bit before the Chrome/Safari fix lands, and I fully expect\nthat the breakage will very slowly crawl through all sorts of other products\ndepending on Chromium (like VSCode, or the Qt WebView widget), so it made sense\nto implement a workaround instead of waiting for the upstream fix to arrive.\n\nThe TL;DR is: A regression in the Chrome and Safari WebGL2 Metal backends\nsubtly breaks offscreen rendering for render target textures which have their\nGL_TEXTURE_MAX_LEVEL set, but don't explicitly allocate texture storage\nvia the glTexStorage calls (this is entirely valid GL and WebGL2 though).\n\nThe breakage manifests as a 'stuck' offscreen rendering in Chrome, and as\na lost WebGL context in Safari Tech Preview (ok, that one isn't exactly 'subtle').\n\nThe workaround in the sokol_gfx.h GL backend is:\n\n- on Emscripten only:\n- for textures without initial data, explicitly allocate texture storage\n  via the glTexStorage functions\n- and otherwise call the glTexImage functions as before\n\nA better fix which I'll tackle later would be to rewrite the GL texture initialization\nto generally use glTexStorage + glTexSubImage, but this will require a separate\nfallback code path for macOS which doesn't have the glTexStorage calls because\nGL on macOS is stuck at version 4.1, while glTexStorage has only been added in GL 4.2.\n\n> NOTE: if you are affected by the breakage but cannot update to the most recent\nsokol_gfx.h version, a simpler hotfix might be to just comment out this call\nin `_sg_gl_create_image`, but this will only work for render target textures\nwith a single mip level (which is the common case though):\n\n```c\nglTexParameteri(img->gl.target, GL_TEXTURE_MAX_LEVEL, img->cmn.num_mipmaps - 1);\n```\n\n\n\n### 16-Jul-2024\n\nsokol_app.h Linux: Fixed a long-standing issue on Linux where sokol-app key\nup/down events were not keyboard layout independent. Instead the first keyboard\nlayout in the system settings would be used (this was responsible for why the\nbug slipped through for so long, because on my Linux laptop I have a US layout\nfirst in the list, followed by the German layout - this caused sokol-app key\ncodes to always be consistent with the US layout, even when the German layout\nwas selected, which is the intended behaviour. The bug only manifested itself\nwhen moving the German layout into the top spot.\n\nThe fix has been adapted from GLFW by building a runtime-dynamic mapping table\nfrom keyboard scan codes to sokol-app key codes at application start. As always,\nbig kudos to GLFW for investigating and implementing a fix after running into\nthe same issue before.\n\nAlso many thanks to GH user @marekmaskarinec for providing an initial PR\n(https://github.com/floooh/sokol/pull/1078) which unfortunately couldn't be\nused because it doesn't work on XWayland.\n\nFor more details see issue https://github.com/floooh/sokol/issues/1080 and\nPR https://github.com/floooh/sokol/pull/1081.\n\n### 04-Jul-2024\n\nThe public sokol_audio.h functions now have an assert to make sure that saudio_setup()\nhas already been called.\n\n### 19-Jun-2024\n\nBugfix in the sokol_gfx.h D3D11 backend: calling `sg_update_image()` with a 3D texture\ndidn't take the 'depth pitch' into account which then caused invalid texture content\nin small-ish textures. This happened at a specific size cutoff which seems to be GPU\nspecific (on my laptop with integrated Intel GPU only for textures smaller than\n32x32xN).\n\nRelated ticket: https://github.com/floooh/sokol/issues/1063\n...and PR: https://github.com/floooh/sokol/pull/1065\n\nI also wrote a new sample for investigating the issue and to protect from\nfuture regressions: https://floooh.github.io/sokol-html5/dyntex3d-sapp.html\n\n### 01-Jun-2024\n\nsokol_imgui.h is now officially supported in the [sokol-zig bindings](https://github.com/floooh/sokol-zig).\n\nThis caused a very minor breaking change in the sokol_imgui.h function\n`simgui_add_key_event()`: previously this took a callback function pointer\nwhich mapped the incoming key code to a Dear ImGui compatible keycode,\nthis is now expected to be performed by the caller before calling\n`simgui_add_key_event()`.\n\nOther than the minor API change there's an equally minor internal code cleanup:\nThe ImGuiIO method `SetKeyEventNativeData()` is no longer called. This change shouldn't\nhave any side effects.\n\nFor more details about the Zig sokol_imgui.h also see this example project:\n\nhttps://github.com/floooh/sokol-zig-imgui-sample\n\n### 14-May-2024\n\nsokol_fetch.h: A minor breaking change in which hopefully doesn't affect anybody:\n\nThe function typedef `sfetch_callback_t` has been removed and the type signature\nfor the callback has been directly embedded in the `sfetch_request_t` struct. This\nis a preparation for adding sokol_fetch.h to the language bindings (first in\nsokol-zig, see this PR for details: https://github.com/floooh/sokol/pull/1048).\n\n### 13-May-2024\n\nOfficial bindings for the **D language** have been added, like the other official\nbindings those will be automatically updated on commits to the main repository:\n\nhttps://github.com/kassane/sokol-d\n\n...this also includes a matching output format `sokol_d` in the sokol-shdc shader\ncompiler.\n\nAlso see PR https://github.com/floooh/sokol/pull/955.\n\nMany thanks to @kassane for the hard work!\n\n...and a couple minor texture format related fixes in the WebGPU backends in sokol_gfx.h and sokol_app.h:\n\n- merged PR https://github.com/floooh/sokol/pull/1045, this sets 32-bit float textures\n  to filterable if supported (depending on `WGPUFeatureName_Float32Filterable`), many\n  thanks to @jdah!\n- in sokol_app.h, the WebGPU feature detection code has been fixed:\n  - previously, BC and ETC2 texture compression support was mutually exclusive, which\n    was a bug (for instance on Apple Silicon, both formats are available)\n  - the missing ASTC texture compression detection has been added (sokol_gfx.h already\n    checked the WebGPU device for support of ASTC compression, but this code never\n    worked because the feature was not requested when the WebGPU device was created\n    in sokol_app.h\n\n### 10-May-2024\n\nA minor breaking change regarding ETC2/EAC pixel formats:\n\n- `SG_PIXELFORMAT_ETC2_RG11` has been renamed to `SG_PIXELFORMAT_EAC_RG11`\n- `SG_PIXELFORMAT_ETC2_RG11SN` has been renamed to `SG_PIXELFORMAT_EAC_RG11SN`\n- the pixel formats `SG_PIXELFORMAT_EAC_R11` and `SG_PIXELFORMAT_EAC_R11SN` have been added\n- fixed a pixel format mapping bug in WebGPU (the EAC RG11 formats were actually mapped to R11)\n\nSee ticket https://github.com/floooh/sokol/issues/1041, and PR https://github.com/floooh/sokol/pull/1044 for details.\n\n### 09-May-2024\n\nThe 'storage buffer update'. sokol_gfx.h now has (readonly) storage buffer support, providing\na more flexible way to pass array-like random access data from the CPU to the GPU side.\n\nPlease see the following [blog post](https://floooh.github.io/2024/05/06/sokol-storage-buffers.html)\nand the [associated PR #1007](https://github.com/floooh/sokol/pull/1007) for details.\n\nPlease also note the new documentation section `ON STORAGE BUFFERS` in sokol_gfx.h.\n\nAlso see the related [changes in sokol-shdc](https://github.com/floooh/sokol-tools/blob/master/CHANGELOG.md).\n\n...and finally the following new samples (note that the demos are running on WebGPU and currently\nrequire a recent Chrome on macOS or Windows):\n\n- rendering without buffer bindings (this sample actually also runs on WebGL2):\n  - WebGPU: https://floooh.github.io/sokol-webgpu/triangle-bufferless-sapp.html\n  - WebGL2: https://floooh.github.io/sokol-html5/triangle-bufferless-sapp.html\n  - C source: https://github.com/floooh/sokol-samples/blob/master/sapp/triangle-bufferless-sapp.c\n  - GLSL source: https://github.com/floooh/sokol-samples/blob/master/sapp/triangle-bufferless-sapp.glsl\n- vertex pulling from a storage buffer:\n  - WebGPU: https://floooh.github.io/sokol-webgpu/vertexpull-sapp.html\n  - C source: https://github.com/floooh/sokol-samples/tree/master/sapp/vertexpull-sapp.c\n  - GLSL source: https://github.com/floooh/sokol-samples/tree/master/sapp/vertexpull-sapp.glsl\n- reading storage buffer content in fragment shader:\n  - WebGPU: https://floooh.github.io/sokol-webgpu/sbuftex-sapp.html\n  - C source: https://github.com/floooh/sokol-samples/tree/master/sapp/sbuftex-sapp.c\n  - GLSL source: https://github.com/floooh/sokol-samples/tree/master/sapp/sbuftex-sapp.glsl\n- instanced rendering via storage buffer:\n  - WebGPU: https://floooh.github.io/sokol-webgpu/instancing-pull-sapp.html\n  - C source: https://github.com/floooh/sokol-samples/tree/master/sapp/instancing-pull-sapp.c\n  - GLSL source: https://github.com/floooh/sokol-samples/tree/master/sapp/instancing-pull-sapp.glsl\n- skinned character rendering via storage buffers:\n  - WebGPU: https://floooh.github.io/sokol-webgpu/ozz-storagebuffer-sapp.html\n  - C source: https://github.com/floooh/sokol-samples/tree/master/sapp/ozz-storagebuffer-sapp.cc\n  - GLSL source: https://github.com/floooh/sokol-samples/tree/master/sapp/ozz-storagebuffer-sapp.glsl\n\nAlso see the following backend-specific samples which don't use sokol-shdc:\n\n- D3D11: https://github.com/floooh/sokol-samples/blob/master/d3d11/vertexpulling-d3d11.c\n- Metal: https://github.com/floooh/sokol-samples/blob/master/metal/vertexpulling-metal.c\n- WebGPU: https://github.com/floooh/sokol-samples/blob/master/wgpu/vertexpulling-wgpu.c\n- Desktop GL: https://github.com/floooh/sokol-samples/blob/master/glfw/vertexpulling-glfw.c\n\nStorage buffer support is not available on the following platform/backend combos:\n\n- macOS + GL (stuck at GL 4.1)\n- iOS + GL (stuck at GLES 3.0)\n- WebGL2 (stuck at GLES 3.0)\n- Android (support may be implemented at a later time)\n\n#### **BREAKING CHANGES**\n\n- the config define `SOKOL_GLCORE33` has been renamed to `SOKOL_GLCORE`, this affects\n  the following headers:\n    - sokol_gfx.h\n    - sokol_app.h\n    - sokol_debugtext.h\n    - sokol_fontstash.h\n    - sokol_gl.h\n    - sokol_imgui.h\n    - sokol_nuklear.h\n    - sokol_spine.h\n- likewise in the sokol_gfx.h enum `sg_backend` the enum item `SG_BACKEND_GLCORE33` has been\n  renamed to `SG_BACKEND_GLCORE`\n- sokol_gfx.h now expects a minimal desktop GL version of 4.1 on macOS, and 4.3 on other\n  platforms (this only matters if you don't use sokol_app.h), storage buffer support is only\n  available on GL 4.3 contexts\n- likewise, shaders passed into sokol_gfx.h when the desktop GL backend is active are now expected\n  to be `#version 410` or `#version 430` (`#version 330` may still work but is untested)\n- likewise, by default sokol_app.h now creates a GL 4.1 context on macOS and a GL 4.3 context on other\n  desktop platforms when `SOKOL_GLCORE` is defined\n- if you're passing WGSL shaders directly into sokol_gfx.h (instead of using sokol-shdc), please\n  be aware that the binding offsets for the different shader resource types have moved:\n    - vertex shader stage:\n      - textures: `@group(1) @binding(0..15)`\n      - samplers: `@group(1) @binding(16..31)`\n      - storage buffers: `@group(1) @binding(32..47)`\n    - fragment shader stage:\n      - textures: `@group(1) @binding(48..63)`\n      - samplers: `@group(1) @binding(64..79)`\n      - storage buffers `@group(1) @binding(80..95)`\n\n#### **NON-BREAKING CHANGES**\n\n- **sokol_app.h** learned two new functions to get the desktop GL version (note that on GLES\n  these return 0, this behaviour may change at a later time):\n  - `int sapp_gl_get_major_version(void)`\n  - `int sapp_gl_get_minor_version(void)`\n\n- **sokol_gfx.h**:\n  - The enum `sg_buffer_type` has a new member `SG_BUFFERTYPE_STORAGEBUFFER`, used\n    in the `sg_make_buffer()` call to create a storage buffer\n  - The struct `sg_features` has a new member `bool storage_buffer`, used to indicate\n    that the current 3D backend supports storage buffers\n  - The stats struct `sg_frame_stats_metal_bindings` has a new member `num_set_fragment_buffer`\n  - There are various new error codes and validation checks related to storage buffers\n  - A new struct `sg_shader_storage_buffer_desc`, nested in `sg_shader_desc`.\n    This is used in the `sg_make_shader()` call to communicate to sokol_gfx.h\n    what storage buffer bind slots are used in a shader\n\n- **sokol_gfx_imgui.h**: The debug UI panels have been updated to visualize the new\n  storage buffer related state\n\n- in the following headers, the embedded shaders have been updated via the new\n  sokol-shdc version, switching the embedded GLSL shaders to `#version 410`\n  - sokol_debugtext.h\n  - sokol_fontstash.h\n  - sokol_gl.h\n  - sokol_imgui.h\n  - sokol_nuklear.h\n  - sokol_spine.h\n\n\n### 03-May-2024:\n\n- sokol_app.h win32: Merged PR https://github.com/floooh/sokol/pull/1034, this adds a NOAPI mode\n  to the sokol_app.h Windows backend by defining SOKOL_NOAPI before including the implementation.\n  Same thing as GLFW's NOAPI mode basically, to allow using the sokol_app.h windowing features\n  without setting up D3D11 or OpenGL. NOAPI implementations for other platforms will follow in the\n  future. Many thanks to @pplux and @castano!\n\n### 13-Apr-2024:\n\n- sokol_gfx.h d3d11: resource label strings are now communicated to D3D11 resource objects,\n  making it easier to identify those resources in tools like the Visual Studio Graphics Debugger\n  or RenderDoc. See PR https://github.com/floooh/sokol/pull/1025 for details. Many thanks to\n  @jakubtomsu for the PR!\n- Odin bindings: merged https://github.com/floooh/sokol/pull/1023 (and related PR\n  https://github.com/floooh/sokol-odin/pull/11 in the actual bindings repo). This changes\n  the directory structure of the bindings to make them a bit friendlier to integrate\n  with Odin projects, and also adds a couple of smaller improvements and fixes.\n  Many thanks to @jakubtomsu for the PRs!\n- Also a couple of smaller 'drive-by PRs' I merged over the last couple of days but didn't mention\n  yet in the changelog:\n  - https://github.com/floooh/sokol/pull/1029: exclude NUM enum items in Odin bindings, many thanks to @jakubtomsu\n  - https://github.com/floooh/sokol/pull/1028: in sokol_gfx.h fix GCC warnings in the d3d11 backend (when compiling\n    via mingw on Windows), many thanks @edubart\n  - https://github.com/floooh/sokol/pull/1026: in sokol_gfx.h increase the internal `_SG_STRING_SIZE` from\n    16 to 32, by @jakubtomsu\n  - https://github.com/floooh/sokol/pull/1021, https://github.com/floooh/sokol-odin/pull/10: re-enable Odin CI builds\n    for macOS (by linking against LLVM 17), also by @jakubtomsu\n\n### 21-Mar-2024:\n\n- sokol_imgui.h: merged PR https://github.com/floooh/sokol/pull/1010, this will automatically\n  re-create the sokol-gfx font texture resources in the `simgui_new_frame()` call\n  when the Dear ImGui texture atlas has changed. This is an alternative to calling the\n  functions `simgui_create_fonts_texture()` and `simgui_destroy_fonts_texture()` manually.\n  One important reason why you'd want to call those functions manually is to create the fonts texture\n  with custom texture sampler attributes (the new implicit re-creation inside `simgui_new_frame()`\n  calls `sg_make_sampler()` with default attributes).\n\n  Many thanks to @elloramir for the PR!\n\n### 02-Mar-2024:\n\n- sokol_app.h emscripten: two new flags in `sapp_desc` to configure the Emscripten main loop:\n  - `.html5_use_emsc_set_main_loop`: when this is true, the function `emscripten_set_main_loop()` will be used\n    to drive the sokol-app frame callback (otherwise `emscripten_request_animation_frame()` as before)\n  - `.html5_emsc_set_main_loop_simulate_infinite_loop`: this is passed as the `simulate_infinite_loop` parameter\n    into the `emscripten_set_main_loop()` function.\n\n  In general you should stick with sokol_app.h's default behaviour and only use those settings if you run\n  into specific problems, for instance as discussed here: https://github.com/floooh/sokol/issues/843\n\n  Related PR: https://github.com/floooh/sokol/pull/997\n\n  Many thanks to @Dvad for the PR, and also to @ambrusc for an alternative PR that hadn't been used, @voidware\n  for kicking off the discussion and all contributors!\n\n  The sample `texcube-sapp` has been updated to use the set-main-loop method:\n\n  https://floooh.github.io/sokol-html5/texcube-sapp.html\n\n- sokol_imgui.h: PR https://github.com/floooh/sokol/pull/994 has been merged, this adds two\n  font management helper functions which drastically reduce boilerplate code\n  when injecting a custom font into Dear ImGui via sokol_imgui.h.\n\n  See the PR for details, and the updated sample https://floooh.github.io/sokol-html5/imgui-highdpi-sapp.html\n  via this PR: https://github.com/floooh/sokol-samples/pull/135\n\n  Many thanks to @Dvad for the PR!\n\n### 01-Mar-2024:\n\nMinor regression fix for yesterdays merge in the sokol_gfx.h Metal backend:\n\nA swapchain render pass with an SG_PIXELFORMAT_DEPTH depth-buffer would try\nto set a stencil surface (currently this only matters if you use your own\nwindow system glue since sokol_app.h always creates a depth+stencil-buffer).\n\nSee https://github.com/floooh/sokol/issues/1004 for details.\n\nThe [Metal samples in the sokol-samples project](https://github.com/floooh/sokol-samples/tree/master/metal) have been updated to use all variants\nof SG_PIXELFORMAT_NONE, SG_PIXELFORMAT_DEPTH and SG_PIXELFORMAT_DEPTH_STENCIL\nnow to catch similar regressions in the future.\n\nPlus 2 minor drive-by fixes:\n\n- fix the sokol_gfx.h WebGPU backend for a spec-fix in Chrome (see https://github.com/floooh/sokol/issues/1003)\n- in the Emscripten backends of sokol_app.h and sokol_args.h, replace the deprecated JS helper function\n  `allocateUTF8OnStack` with its replacement `stringToUTF8OnStack` (see: https://github.com/floooh/sokol/commit/49a75e1476153cb2605d3b3ebd2f07e3eb0536d9)\n\n### 29-Feb-2024:\n\n**BREAKING CHANGES** in sokol_gfx.h, sokol_app.h, sokol_glue.h and sokol_gfx_imgui.h\n(the 'big render pass cleanup').\n\n- In sokol_gfx.h, the concepts of 'render contexts' and 'default render passes' have\n  been removed and replaced with a unified `sg_begin_pass()` which handles both\n  rendering into 'offscreen-passes' and 'swapchain-passes'.\n\n  [Please read this blog\n  post](https://floooh.github.io/2024/02/26/sokol-spring-cleaning-2024.html)\n  carefully for a detailed overview what has changed, why the changes make\n  sense, and how existing code needs to be updated.\n\n  Also see the related PR for further details: https://github.com/floooh/sokol/pull/985\n\n- There are also minimal related changes in the sokol_app.h and a complete\n  rewrite of the sokol_glue.h APIs, also detailed in the above blog post.\n\n- The namespace-prefix for the header sokol_gfx_imgui.h has been changed from\n  `sg_imgui_` to `sgimgui_`.\n\n- In sokol_gfx.h with the Metal backend, a runtime configuration flag has been\n  added to `sg_desc` to create a Metal command buffer with\n  'retained-references'. See issue\n  [#981](https://github.com/floooh/sokol/issues/981) for details.\n\n- Also in sokol_gfx.h, the struct item `sg_limits.gl_max_vertex_uniform_vectors` has been changed\n  to `sg_limits.gl_max_vertex_uniform_components` (note that there are 4x more 'components'\n  than 'vectors'). See issue [#714](https://github.com/floooh/sokol/issues/714) for details.\n\n- All sampples, language binding examples and 'side projects' have been updated, see the above blog post\n  for links to the respective PRs.\n\n### 27-Feb-2024:\n\n- Merged PR https://github.com/floooh/sokol/pull/1001, this is a small fix for GLES3 to avoid\n  calling glInvalidateFramebuffer() on non-existing depth/stencil surfaces.\n\n  Many thanks to @danielchasehooper!\n\n#### 26-Feb-2024:\n\n- Minor fix in sokol_imgui.h: The drawing code now detects and skips the special\n  `ImDrawCallback_ResetRenderState` constant, not doing so would try to call a function\n  at address (-8) which then results in a crash.\n\n  See for what this is: https://github.com/ocornut/imgui/blob/277ae93c41314ba5f4c7444f37c4319cdf07e8cf/imgui.h#L2583-L2587\n\n  sokol_imgui.h doesn't have any handling for this special callback, it will just ignore it.\n\n  As a minor additional behaviour change, any user callback will now also cause `sg_reset_state_cache()`\n  to be called. This is just a precaution in case the user callback code calls any native 3D backend API\n  functions.\n\n  Related issue: https://github.com/floooh/sokol/issues/1000\n\n#### 21-Feb-2024:\n\n- PR https://github.com/floooh/sokol/pull/993 has been merged, this allows to inject\n  additional GL functions into the Win32 GL loader of sokol_gfx.h (TBH, it's a very specialized\n  feature for people who know what they're doing, but it also fixes a very specific problem\n  while at the same time resolving to 'nothing' when not used).\n\n  Many thanks for @kcbanner for the PR!\n\n#### 31-Jan-2024:\n\n- sokol_app.h macOS: merged a workaround for the application window not being focused\n  if the init callback takes a while (not reproducible on my M1 Mac with latest Sonoma,\n  but might fix the issue for older Macs, and the change seems harmless enough -\n  sokol_app.h essentially sends a focusEvent to itself)\n\n  Related issue: https://github.com/floooh/sokol/issues/757\n  Implemented in PR: https://github.com/floooh/sokol/pull/982\n\n  Many thanks to @zoo-3d for investigating the issue and the PR!\n\n#### 28-Jan-2024:\n\n- sokol_app.h web: the canvas resize callback is now unregistered on cleanup.\n\n  Related issue: https://github.com/floooh/sokol/issues/983 and PR: https://github.com/floooh/sokol/pull/984\n  Many thanks to @edubart!\n\n#### 27-Jan-2024\n\n- sokol_app.h web: The HTML5 event bubbling changes introduced in the 02-Jan-2024\n  update have been reverted because they introduced some undesired side effects.\n  By default, most input events now *don't* bubble up (which restores the\n  old behaviour), but it's now possible to enable bubbling for categories\n  of input events (mouse, touch, wheel, keys and chars) during sokol-app setup.\n  It's then possible to control bubbling of individual events by calling\n  `sapp_consume_event()` from within the sokol-app event callback.\n\n  See issue https://github.com/floooh/sokol/issues/972 for details and\n  PR https://github.com/floooh/sokol/pull/975 for the actual changes.\n\n  Also check out the new doc section `INPUT EVENT BUBBLING ON THE WEB PLATFORM`\n  in the sokol_app.h header documentation block.\n\n- sokol_gfx.h metal: Merged PR https://github.com/floooh/sokol/pull/980. When\n  only the offset changes in a vertex buffer binding, only the buffer offset\n  is now updated (e.g. instead of the Metal method `setVertexBuffer:offset:atIndex`,\n  the leaner method `setVertexBufferOffset:atIndex` is called. Apart from the\n  actual PR I also removed a couple of actually unused items from the Metal\n  backend state cache. Many thanks to @staminajim for the PR!\n\n  Related issue: https://github.com/floooh/sokol/issues/979\n\n#### 23-Jan-2024\n\n- sokol_app.h android: Touch event coordinates are now using AMotionEvent_getX/Y() instead\n  of AMotionEvent_getRawX/Y(). The raw functions don't work well in multi-window\n  scenarios. See PR https://github.com/floooh/sokol/pull/974 for details.\n  Many thanks to GitHub user @Comanx!\n\n#### 19-Jan-2024\n\n- sokol_app.h wgpu: tiny fix for a breaking API change in webgpu.h in the Emscripten 3.1.52 SDK\n- Merged PR https://github.com/floooh/sokol/pull/970 (many thanks to @waywardmonkeys) which\n  fixes a couple of strict-prototype warnings (e.g. C functions using func() instead of func(void)).\n  I also enabled `-Wstrict-prototypes` now in the CI tests for GCC and Clang, so such cases\n  should be caught in the future.\n\n#### 18-Jan-2024\n\n- sokol_gfx.h: added support for the following pixel formats:\n  - BC3_SRGBA\n  - BC7_SRGBA\n  - ETC2_SRGB8\n  - ETC2_SRGB8A8\n  - ASTC_4x4_RGBA\n  - ASTC_4x4_SRGBA\n\n  Related PR: https://github.com/floooh/sokol/pull/967\n\n  Many thanks to GH user @allcreater!\n\n#### 07-Jan-2024\n\n- sokol_app.h (macos+metal): window content no longer 'wobbles' during window resizing. Many\n  thanks to @Seb-degraff for picking up and investigating this longstanding issue\n  (https://github.com/floooh/sokol/issues/700), finding a fix for the remaining problem\n  and providing a really nice PR (https://github.com/floooh/sokol/pull/963)\n\n#### 06-Jan-2024\n\n> NOTE: if you use sokol_gfx.h and sokol_app.h together, make sure to update both. This is\nbecause the pixel format enum in sokol_gfx.h has been shuffled around a bit, and as a result, some internal\npixel format constants in sokol_app.h had to move too!\n\n- sokol_gfx.h: some minor new features (non-breaking):\n  - the struct `sg_pixel_format` has two new items:\n    - `bool compressed`: true if this is a hardware-compressed pixel format\n    - `int bytes_per_pixel`: as the name says, with the caveat that this is\n      zero for compressed pixel formats (because the smallest element in compressed formats is a block, not a pixel)\n  - two previously private helper functions have been exposed to help with size computations\n    for texture data, these may be useful when preparing image data for consumption by `sg_make_image()`\n    and `sg_update_image()`:\n      - `int sg_query_row_pitch(sg_pixel_format fmt, int width, int row_align_bytes)`:\n        Computes the number of bytes in a texture row for a given pixel format. A 'row' has\n        different meanings for uncompressed vs compressed formats: For uncompressed pixel\n        formats, a row is a single line of pixels, while for compressed formats, a row is\n        a line of 'compression blocks'. `width` is always in pixels.\n      - `int sg_query_surface_pitch(sg_pixel_format fmt, int width, int height, int row_align_bytes)`:\n        Computes number of bytes in a texture surface (e.g. a single mipmap) for a given\n        pixel format. `width` and `height` are always in pixels.\n\n    The `row_align_bytes` parameter is for added flexibility. For image data that goes into\n    the `sg_make_image()` or `sg_update_image()` functions this should generally be 1, because these\n    functions take tightly packed image data as input no matter what alignment restrictions\n    exist in the backend 3D APIs.\n- Related issue: https://github.com/floooh/sokol/issues/946, and PR: https://github.com/floooh/sokol/pull/962\n\n#### 03-Jan-2024\n\n- sokol_nuklear.h: `snk_handle_event()` now returns a bool to indicate whether the\n  event was handled by Nuklear (this allows an application to skip its own event\n  handling if Nuklear already handled the event). Issue link: https://github.com/floooh/sokol/issues/958,\n  fixed in PR: https://github.com/floooh/sokol/pull/959. Many thanks to @adamrt for the PR!\n\n#### 02-Jan-2024\n\nHappy New Year! A couple of input-related changes in the sokol_app.h Emscripten backend:\n\n- Mouse and touch events now bubble up to the HTML document instead of being consumed, in some scenarios this\n  allows better integration with the surrounding web page. To prevent event bubbling,\n  call `sapp_consume_event()` from within the sokol_app.h event callback function.\n- **NOTE**: wheel/scroll events behave as before and are always consumed. This prevents\n  an ugly \"scroll bumping\" effect when a wheel event bubbles up on a page where\n  scrolling shouldn't be possible.\n- The hidden HTML text input field hack for text input on mobile browsers has been\n  removed. This idea never really worked across all browsers, and it actually\n  interfered with Dear ImGui text input fields because the hidden HTML text field\n  generated focus-in/out events which confused the Dear ImGui input handling code.\n\nThose changes fix a couple of problem when trying to integrate sokol_app.h applications\ninto VSCode webview panels, see: https://marketplace.visualstudio.com/items?itemName=floooh.vscode-kcide\n\nRelated PR: https://github.com/floooh/sokol/pull/939\n\n#### 10-Nov-2023\n\nA small change in the sokol_gfx.h GL backend on Windows only:\n\nPR https://github.com/floooh/sokol/pull/839 has been merged, in debug mode this creates\nthe GL context with WGL_CONTEXT_DEBUG_BIT_ARB. Thanks to @castano for the PR!\n\n#### 06-Nov-2023\n\nA bugfix in the sokol_gfx.h D3D11 backend, and some related cleanup when creating depth-stencil\nrender target images and resource views:\n\n- fixed: render target images with format SG_PIXELFORMAT_DEPTH_STENCIL triggered a validation\n  error because the pixel format capabilities code marked them as non-renderable. Now\n  the SG_PIXELFORMAT_DEPTH_STENCIL pixel format is properly reported as renderable.\n- the DXGIFormats for SG_PIXELFORMAT_DEPTH_STENCIL images are now as follows:\n  - D3D11 texture object: DXGI_FORMAT_R24G8_TYPELESS\n  - D3D11 shader-resource-view object: DXGI_FORMAT_R24_UNORM_X8_TYPELESS\n  - D3D11 depth-stencil-view object: DXGI_FORMAT_D24_UNORM_S8_UINT\n\nRelated PR: https://github.com/floooh/sokol/pull/937\n\n#### 30-Oct-2023\n\nSome sokol_gfx.h backend-specific updates and tweaks (very minor chance that this is breaking if you are injecting textures into the D3D11 backend).\n\n- a new set of public API functions to access the native backend 3D-API resource objects of\n  sokol-gfx resource objects:\n\n  ```\n  sg_[api]_[type]_info sg_[api]_query_[type]_info(sg_[type])\n  ```\n  ...where `[api]` is any of `[gl, d3d11, mtl, wgpu]` and `[type]` is any of `[buffer, image, sampler, shader, pipeline, pass]`.\n\n  This is mainly useful when mixing native 3D-API code with sokol-gfx code.\n\n  See issue https://github.com/floooh/sokol/issues/931 for details.\n\n- WebGPU backend: `sg_make_image()` will no longer automatically create a WebGPU texture-view object when injecting a WebGPU texture object, instead\nthis must now be explicitly provided.\n\n- D3D11 backend: `sg_make_image()` will no longer automatically create a\nshader-resource-view object when injecting a D3D11 texture object, and\nvice versa, a texture object will no longer be looked up from an injected\nshader-resource-view object (e.g. the injection rules are now more straightforward and explicit). See issue https://github.com/floooh/sokol/issues/930 for details.\n\nFor the detailed changes, see PR https://github.com/floooh/sokol/pull/932.\n\n#### 27-Oct-2023\n\nFix broken render-to-mipmap in the sokol_gfx.h GL backend.\n\nThere was a subtle bug / \"feature gap\" lurking in sokol_gfx.h GL backend: trying\nto render to any mipmap except the top-level mipmap resulted in a black screen\nbecause of an incomplete-framebuffer error. This is fixed now. The changes in detail:\n\n- creating a texture in the GL backend now sets the GL_TEXTURE_MAX_LEVEL property\n  (this is the fix to make everything work)\n- the framebuffer completeness check in the GL backend now has more detailed error logging\n- in the validation layer, the requirement that a sampler that's used with a\n  single-mipmap-texture must use `.mipmap_filter = SG_FILTER_NONE` has been\n  relaxed (a later update will remove SG_FILTER_NONE entirely since it's not needed anymore\n  and the concept of a \"none\" mipmap filter only exists in GL and Metal, but not D3D, WebGPU\n  and Vulkan)\n\nTicket: https://github.com/floooh/sokol/issues/923\n\nPR: https://github.com/floooh/sokol/pull/924\n\nThere's also a new render-to-mipmap sample which covers to close this 'feature gap':\n\nhttps://floooh.github.io/sokol-html5/miprender-sapp.html\n\nA couple of similar samples will follow over the next few days\n(rendering to texture array layers and 3d texture slices).\n\n#### 26-Oct-2023\n\n- sokol_app.h gl: fix a regression introduced in https://github.com/floooh/sokol/pull/916\n  which could select the wrong framebuffer pixel format and break rendering\n  on some GL drivers (in my case: an older Intel GPU).\n\n  If you are using the GL backend on Windows, please make sure to upgrade!\n\n#### 23-Oct-2023\n\n- sokol_app.h gl: some further startup optimizations in the WGL code path\n  via PR https://github.com/floooh/sokol/pull/916\n\n#### 21-Oct-2023\n\nThe major topic of this update is the 'finalized' WebGPU support in sokol_gfx.h and sokol_app.h.\n\n- WebGPU samples are hosted here:\n\n  https://floooh.github.io/sokol-webgpu/\n\n- WebGL2 samples remain hosted here:\n\n  https://floooh.github.io/sokol-html5/\n\n- Please read the following blog post as introduction:\n\n  https://floooh.github.io/2023/10/16/sokol-webgpu.html\n\n- ...and the changelog and updated documentation in the sokol-shdc repository:\n\n  https://github.com/floooh/sokol-tools\n\n- You'll also need to update the sokol-shdc binaries:\n\n  https://github.com/floooh/sokol-tools-bin\n\n- Please also read the following new or updated sections in the embedded   sokol_gfx.h header documentation:\n\n  - `ON SHADER CREATION`\n  - `ON SG_IMAGESAMPLETYPE_UNFILTERABLE_FLOAT AND SG_SAMPLERTYPE_NONFILTERING`\n  - `WEBGPU CAVEATS`\n\n  Please do this especially when using any of the following texture pixel formats, as you will most likely encounter new validation layer errors:\n\n  - `SG_PIXELFORMAT_R32F`\n  - `SG_PIXELFORMAT_RG32F`\n  - `SG_PIXELFORMAT_RGBA32F`\n\n- There is a tiny breaking change in the sokol_gfx.h API (only requires action when not using sokol-shdc):\n\n  - the following `sg_sampler_type` enum items have been renamed to better match their WebGPU counterparts:\n    - SG_SAMPLERTYPE_SAMPLE => SG_SAMPLERTYPE_FILTERING\n    - SG_SAMPLERTYPE_COMPARE => SG_SAMPLERTYPE_COMPARISON\n\n  - the enum `sg_image_sample_type` gained a new item:\n    - SG_IMAGESAMPLETYPE_UNFILTERABLE_FLOAT\n\n  - the enum `sg_sampler_type` gained a new item:\n    - SG_SAMPLERTYPE_NONFILTERING\n\n- The sokol_gfx.h struct `sg_desc` has two new items:\n  - `.wgpu_bindgroups_cache_size` - must be power-of-2, default: 1024\n  - `.wgpu_disable_bindgroups_cache` - default: false\n\n- sokol_gfx.h gained the following new public API functions to query per-frame information:\n  - `sg_frame_stats sg_query_frame_stats()`\n  - `void sg_enable_frame_stats(void)`\n  - `void sg_disable_frame_stats(void)`\n  - `bool sg_frame_stats_enabled(void)`\n\n  Frame statistics gathering is enabled after startup, but can be temporarily\n  disabled and enabled again via `sg_disable_frame_stats()` and `sg_enable_frame_stats`.\n\n- The sokol_gfx.h validation layer has new validation checks in `sg_make_shader()`\n  regarding image/sampler pair compatibility (WebGPU is particularly strict about\n  this stuff).\n\n- In sokol_app.h, the old wip WebGPU device and swapchain setup code is now implemented\n  in pure C code (previously this was a mix of Javascript and C).\n\n- Also note that sokol_app.h currently only supports WebGPU in the Emscripten backend.\n  If you want to use sokol_gfx.h with the WebGPU backend in a native scenario, you'll have\n  to use a different window system glue library (like GLFW). The sokol-samples directory\n  has a handful of examples for using sokol_gfx.h + Dawn + GLFW.\n\n- The following headers have been made compatible with the sokol_gfx.h WebGPU backend\n  (mainly by embedding WGSL shader code):\n  - sokol_debugtext.h\n  - sokol_fontstash.h\n  - sokol_gl.h\n  - sokol_spine.h\n  - sokol_imgui.h (also required some more changes for embedding `unfilterable-float`\n    textures, since these now require separate shader and pipeline objects)\n  - sokol_nuklear.h (works in WebGPU, but doesn't contain the work from sokol_imgui.h\n    to support `unfilterable-float` user textures)\n\n- sokol_gfx_imgui.h gained a new function `sg_imgui_draw_menu()` which renders a\n  menu panel to show/hide all debug windows. Previously this had to be done\n  outside the header.\n\n- sokol_gfx_imgui.h gained a new 'frame stats' window, which allows to peak into\n  sokol_gfx.h frame-rendering internals. This basically visualizes the struct\n  `sg_frame_stats` returned by the new sokol_gfx.h function `sg_query_frame_stats()`.\n\n- The sokol-samples repository gained 3 new samples:\n  - cubemap-jpeg-sapp.c (load a cubemap from separate JPEG files)\n  - cubemaprt-sapp.c (render into cubemap faces - this demo actually existed a while but wasn't \"official\" so far)\n  - drawcallperf-sapp.c (a sample to explore the performance overhead of sg_apply_bindings, sg_apply_uniforms and sg_draw)\n\n#### 03-Oct-2023\n\n- sokol_app.h win/gl: PR https://github.com/floooh/sokol/pull/886 has been merged, this makes\n  GL context initialization on Windows slightly more efficient. Many thanks to @dtrebilco!\n\n#### 25-Sep-2023\n\n- The allocator callback functions in all headers that support custom allocators have been renamed\n  from `alloc` and `free` to `alloc_fn` and `free_fn`, this is because the symbol `free` is quite\n  likely to collide with a preprocessor macro of the same name if the standard C allocator is\n  replaced with a custom allocator.\n\n  This is a breaking change only if you've been providing your own allocator functions to\n  the sokol headers.\n\n  See issue https://github.com/floooh/sokol/issues/903 and PR https://github.com/floooh/sokol/pull/908\n  for details.\n\n#### 23-Sep-2023\n\n- sokol_gfx.h gl: Allow to inject an external GL framebuffer id into the sokol-gfx default\n  pass. See PR https://github.com/floooh/sokol/pull/899 and issue https://github.com/floooh/sokol/issues/892\n  for details. Many thanks to @danielchasehooper for the discussion and PR!\n\n  Further down the road I want to make the whole topic more flexible while at the same time\n  simplifying the sokol-gfx API, see here: https://github.com/floooh/sokol/issues/904\n\n#### 22-Sep-2023\n\n- sokol_gfx.h: Fixed a Metal validation error on Intel Macs when creating textures (Intel Macs\n  have unified memory, but don't support textures in shared storage mode). This was a regression\n  in the image/sampler split update in mid-July 2023. Fixes issue https://github.com/floooh/sokol/issues/905\n  via PR https://github.com/floooh/sokol/pull/907.\n\n#### 19-Sep-2023\n\n- sokol_fetch.h: fixed a minor issue where a request that was cancelled before it was dispatched\n  had an incomplete response state set in the response callback (the `finished`, `failed` and\n  `error_code` fields were not set). This fixes issue https://github.com/floooh/sokol/issues/882\n  via PR https://github.com/floooh/sokol/pull/898\n\n#### 18-Sep-2023\n\n- PR https://github.com/floooh/sokol/pull/893 has been merged, this fixes a minor issue\n  in the GL backend when using an injected texture as framebuffer attachment.\n- Issue https://github.com/floooh/sokol/issues/884 has been fixed via PR https://github.com/floooh/sokol/pull/894,\n  this adds missing error code paths in the Metal backend when Metal object creation fails.\n- Clarified `sapp_run()` behaviour in the sokol_app.h documentation header (search for `OPTIONAL: DON'T HIJACK main()`)\n- sokol_args.h now fully supports \"key-only args\", see issue https://github.com/floooh/sokol/issues/876 for details,\n  fixed via PR https://github.com/floooh/sokol/pull/896\n\n#### 17-Sep-2023\n\n- The sokol-gfx Metal backend now adds debug labels to Metal resource objects and\n  also passes through the `sg_push/pop_debug_group()` calls. If you use the push/pop\n  debug group calls, please be aware of the following limitations:\n\n  - a push inside a render pass must have an associated pop inside the same render pass\n  - a push outside any render pass must have an associated pop outside any render pass\n  - Metal will ignore any push/pop calls outside render passes (this is because in Metal\n    these are MTLCommandEncoder methods)\n\n  Associated issue: https://github.com/floooh/sokol/issues/889, and PR: https://github.com/floooh/sokol/pull/890.\n\n#### 09-Sep-2023\n\n- a small PR has been merged which fixes a redundant glBindFramebuffer() in the GLES3 backend\n  in `sg_end_pass()` (see: https://github.com/floooh/sokol/pull/878), many thanks to @danielchasehooper\n  for catching that issue!\n- sokol_imgui.h has been fixed for cimgui 1.89.9 (see https://github.com/floooh/sokol/issues/879)\n\n#### 28-Aug-2023\n\n**sokol_gfx.h metal**: A new attempt at fixing a rare Metal validation layer\nerror about MTKView swapchain resource lifetimes. See PR https://github.com/floooh/sokol/pull/873\nfor details.\n\n#### 26-Jul-2023\n\n**sokol_nuklear.h**: The same image+sampler support has been added as in sokol_imgui.h\nthree days ago:\n\n- a new object type `snk_image_t` which wraps a sokol-gfx image and sampler\n  under a common handle\n- new functions:\n  - snk_make_image()\n  - snk_destroy_image()\n  - snk_query_image_desc()\n  - snk_image_from_nkhandle()\n- the function snk_nkhandle() now takes an snk_image_t handle instead of an sg_image handle\n- the nuklear.h header needs to be included before the declaration (not just the implementation),\n  this was already required before, but now you get a proper error message if the include is missing\n- the 'standard' logging- and error-reporting callback has been added as in the other sokol headers\n  (don't forget to add a logging callback in snk_setup(), otherwise sokol-nuklear will be silent)\n- since sokol-nuklear now needs to allocate memory, an allocator can now be provided to the\n  snk_setup() call (otherwise malloc/free will be used)\n\nPlease also read the new documentation section `ON USER-PROVIDED IMAGES AND SAMPLERS`\nin sokol_nuklear.h, and also check out the (rewritten) sample:\n\nhttps://floooh.github.io/sokol-html5/nuklear-images-sapp.html\n\nAssociated PR: https://github.com/floooh/sokol/pull/862\n\n#### 23-Jul-2023\n\n**sokol_imgui.h**: Add proper support for injecting user-provided sokol-gfx\nimages and samplers into Dear ImGui UIs. With the introduction of separate\nsampler objects in sokol_gfx.h there's a temporary feature regression in\nsokol_imgui.h and sokol_nuklear.h in that user provided images had to use a\nshared sampler that's hardwired into the respective headers. This update fixes\nthis problem for sokol_imgui.h, with a similar fix for sokol_nuklear.h coming\nup next.\n\nThe sokol_imgui.h changes in detail are:\n\n- a new object type `simgui_image_t` which wraps a sokol-gfx image and sampler\n  object under a common handle\n- two new function `simgui_make_image()` and `simgui_destroy_image()` to\n  create and destroy such a new `simgui_image_t` object.\n- the existing function `simgui_imtextureid()` has been changed to take\n  an `simgui_image_t`\n- sokol_imgui.h now also uses the same error-handling and logging callback\n  as the other sokol headers (this was needed because creating an `simgui_image_t`\n  object may fail because the object pool is exhausted) - don't forget\n  to provide a logging callback (for instance via sokol_log.h), otherwise\n  sokol_imgui.h will be entirely silent in case of errors.\n\nPlease also read the new documentation section `ON USER-PROVIDED IMAGES AND SAMPLERS`\nin sokol_imgui.h, and also check out the new sample:\n\nhttps://floooh.github.io/sokol-html5/imgui-images-sapp.html\n\nAssociated PR: https://github.com/floooh/sokol/pull/861\n\n#### 16-Jul-2023\n\n**BREAKING CHANGES**\n\nThe main topic of this update is to separate sampler state from image state in\nsokol_gfx.h which became possible after GLES2 support had been removed from\nsokol_gfx.h.\n\nThis also causes some 'collateral changes' in shader authoring and\nother sokol headers, but there was opportunity to fill a few feature gaps\nin sokol_gfx.h as well:\n\n- it's now possible to sample depth textures in shaders both with regular\n  samplers, and with 'comparison samplers' (which is mainly useful for shadow mapping)\n- it's now possible to create render passes without color attachments for\n  'depth-only' rendering\n\nSee the new [shadows-depthtex-sapp](https://floooh.github.io/sokol-html5/shadows-depthtex-sapp.html) sample which demonstrates both features.\n\n> NOTE: all related projects have a git tag `pre-separate-samplers` in case you are not ready yet to make the switch\n\n> NOTE 2: if you use sokol-gfx with the sokol-shdc shader compiler, you'll also need\n> to update the sokol-shdc binaries from https://github.com/floooh/sokol-tools-bin\n\n##### **sokol_gfx.h**\n\n- texture sampler state has been removed from `sg_image_desc`, instead you now\n  need to create separate sampler objects:\n\n    ```c\n    sg_sampler smp = sg_make_sampler(&(sg_sampler_desc){\n        .min_filter = SG_FILTER_LINEAR,\n        .mag_filter = SG_FILTER_LINEAR,\n        .wrap_u = SG_WRAP_CLAMP_TO_EDGE,\n        .wrap_v = SG_WRAP_CLAMP_TO_EDGE\n    });\n    ```\n\n- texture filtering is now described by 3 separate filters:\n    - min_filter = SG_FILTER_NEAREST | SG_FILTER_LINEAR\n    - mag_filter = SG_FILTER_NEAREST | SG_FILTER_LINEAR\n    - mipmap_filter = SG_FILTER_NONE | SG_FILTER_NEAREST | SG_FILTER_LINEAR\n\n  ...this basically switches from the esoteric GL convention to a convention\n  that's used by all other 3D APIs. There's still a limitation that's caused by\n  GL though: a sampler which is going to be used with an image that has a\n  `mipmap_count = 1` requires that `.mipmap_filter = SG_FILTER_NONE`.\n\n- another new sampler state in `sg_sampler_desc` is `sg_compare_func compare;`,\n  this allows to create 'comparison samplers' for shadow mapping\n\n- when calling `sg_apply_bindings()` the struct `sg_bindings` now has changed\n  to also include sampler objects, note that there is no 1:1 relationship\n  between images and samplers required:\n\n    ```c\n    sg_apply_bindings(&(sg_bindings){\n        .vertex_buffers[0] = vbuf,\n        .fs = {\n            .images = {\n                [SLOT_tex0] = img0,\n                [SLOT_tex1] = img1,\n                [SLOT_tex2] = img2,\n            },\n            .samplers[SLOT_smp] = smp,\n        }\n    });\n    ```\n\n- if you use sokol-shdc, you need to rewrite your shaders from 'OpenGL GLSL style' (with\n  combined image samplers) to 'Vulkan GLSL style' (with separate textures and samplers):\n\n  E.g. the old GL-style shader with combined image samplers:\n\n  ```glsl\n  uniform sampler2D tex;\n\n  void main() {\n      frag_color = texture(tex, uv);\n  }\n  ```\n  ...now needs to look like this:\n\n  ```glsl\n  uniform texture2D tex;\n  uniform sampler smp;\n\n  void main() {\n      frag_color = texture(sampler2D(tex, smp), uv);\n  }\n  ```\n\n  sokol-shdc will now throw an error if it encounters an 'old' shader using combined\n  image-samplers, this helps you to catch all places where a rewrite to separate\n  texture and sampler objects is required.\n\n- If you *don't* use sokol-shdc and instead provide your own backend-specific\n  shaders, you need to provide more shader interface reflection info about the texture\n  and sampler usage in a shader when calling `sg_make_shader`.\n  Please see the new documentation block `ON SHADER CREATION` in sokol_gfx.h for more details!\n\n  Also refer to the updated 3D-backend-specific samples here:\n\n  - for GL: https://github.com/floooh/sokol-samples/tree/master/glfw\n  - for GLES3: https://github.com/floooh/sokol-samples/tree/master/html5\n  - for D3D11: https://github.com/floooh/sokol-samples/tree/master/d3d11\n  - for Metal: https://github.com/floooh/sokol-samples/tree/master/metal\n\n- it's now possible to create `sg_pass` objects without color attachments to\n  enable depth-only rendering, see the new sample [shadows-depthtex-sapp](https://floooh.github.io/sokol-html5/shadows-depthtex-sapp.html) for details,\n  specifically be aware of the caveat that a depth-only-compatible `sg_pipeline` object\n  needs to 'deactivate' the first color target by setting its pixel format\n  to `NONE`:\n\n  ```c\n  sg_pipeline pip = sg_make_pipeline(&(sg_pipeline_desc){\n      ...\n      .colors[0].pixel_format = SG_PIXELFORMAT_NONE,\n      ...\n  });\n  ```\n\n- the following struct names have been changed to be more in line with related\n  struct names, this also makes those names similar to WebGPU types:\n\n    - `sg_buffer_layout_desc` => `sg_vertex_buffer_layout_state`\n    - `sg_vertex_attr_desc` => `sg_vertex_attr_state`\n    - `sg_layout_desc` => `sg_vertex_layout_state`\n    - `sg_color_state` => `sg_color_target_state`\n\n- bugfixes and under-the-hood changes\n    - `sg_begin_pass()` used the wrong framebuffer size when rendering to a mip-level != 0\n    - the Metal backend code started to use the `if (@available(...))` statement\n      to check for runtime-availability of macOS/iOS API features\n    - **NOTE:** this change (`if (@available(...))`) caused linking problems in\n      the Zig and Rust bindings on GH Actions (missing symbol\n      `___isPlatformVersionAtLeast`) which I could not reproduce locally on my\n      M1 Mac. On Zig this could be fixed by moving to the latest zig-0.11.0-dev\n      version, but for Rust this still needs to be fixed).\n    - on macOS the Metal backend now creates resources in Shared resource storage mode if\n      supported by the device\n    - on iOS the Metal backend now supports clamp-to-border-color if possible (depends on\n      iOS version and GPU family)\n\n##### **sokol_gl.h**\n\n- The function `sgl_texture(sg_image img)` has been changed to accept a sampler\n  object to `sgl_texture(sg_image img, sg_sampler smp)`. Passing an invalid image handle\n  will use the builtin default (white) texture, and passing an invalid sampler\n  handle will use the builtin default sampler.\n\n##### **sokol_shape.h**\n\n- Some sokol-shape functions have been renamed to match renamed structs in sokol-gfx:\n\n    - `sshape_buffer_layout_desc()` => `sshape_vertex_buffer_layout_state()`\n    - `sshape_position_attr_desc()` => `sshape_position_vertex_attr_state()`\n    - `sshape_normal_attr_desc()` => `sshape_normal_vertex_attr_state()`\n    - `sshape_texcoord_attr_desc()` => `sshape_texcoord_vertex_attr_state()`\n    - `sshape_color_attr_desc()` => `sshape_color_vertex_attr_state()`\n\n##### **sokol_spine.h**\n\n- A sokol-spine atlas object now allocates both an `sg_image` and `sg_sampler` handle\n  and expects the user code to initialize those handles to complete image and\n  sampler objects. Check the updated sokol-spine samples here for more details:\n\n  https://github.com/floooh/sokol-samples/tree/master/sapp\n\n##### **sokol_imgui.h**\n\n- sokol_imgui.h has a new public function to create an ImTextureID handle from\n  an `sg_image` handle which can be used like this:\n\n    ```c\n    ImTextureID tex_id = simgui_imtextureid(img);\n    ```\n\n  Note that sokol-imgui currently doesn't currently allow to pass user-provided `sg_sampler`\n  object with the user-provided image.\n\n##### **sokol_nuklear.h**\n\n- similar to sokol_imgui.h, there's a new public function `snk_nkhandle()`\n  which creates a Nuklear handle from a sokol-gfx image handle which can be\n  used like this to create a Nuklear image handle:\n\n    ```c\n    nk_image nki = nk_image_handle(snk_nkhandle(img));\n    ```\n\n  As with sokol_imgui.h, it's currently not possible to pass a user-provided `sg_sampler`\n  object with the image.\n\n\n#### 20-May-2023\n\nSome minor event-related cleanup in sokol_app.h and a touchscreen fix in sokol_imgui.h\n\n- in the event `SAPP_EVENTTYPE_FILESDROPPED`:\n    - the `sapp_event.modifier` field now contains the active modifier keys\n      at the time of the file drop operations on the platforms macOS, Emscripten\n      and Win32 (on Linux I haven't figured out how this might work with the\n      Xlib API)\n    - on macOS, the `sapp_event.mouse_x/y` fields now contain the window-relative\n      mouse position where the drop happened (this already worked as expected on\n      the other desktop platforms)\n    - on macOS and Linux, the `sapp_event.mouse_dx/dy` fields are now set to zero\n      (this already was the case on Emscripten and Win32)\n- in the events `SAPP_EVENTTYPE_MOUSE_ENTER` and `SAPP_EVENTTYPE_MOUSE_LEAVE`:\n    - the `sapp_event.mouse_dx/dy` fields are now set to zero, previously this\n      could be a very big value on some desktop platforms\n\nMany thanks to @castano for the initial PR (https://github.com/floooh/sokol/pull/830)!\n\n- In sokol_imgui.h, the new io.AddMouseSourceEvent() function in Dear ImGui 1.89.5\n  is called to differentiate between mouse- and touch-events, this makes ui tabs\n  work with a single tap (previously a double-tap on the tab was needed). The code\n  won't break if the ImGui version is older (in this case the function simply isn't called)\n\n\n#### 19-May-2023\n\n**BREAKING CHANGES**_ in sokol_gfx.h: Render passes are now more 'harmonized'\nwith Metal and WebGPU by exposing a 'store action', and making MSAA resolve attachments\nexplicit. The changes in detail:\n\n  - A new documentation section `ON RENDER PASSES` has been added to sokol_gfx.h, this\n    gives a much more detailed overview of the new render pass behaviour than this\n    changelog, please make sure to give it a read - especially when you are using\n    MSAA offscreen render passes in your code.\n  - `sg_action` has been renamed to `sg_load_action`.\n  - A new enum `sg_store_action` has been added.\n  - In `sg_pass_action`:\n    - `.action` has been renamed to `.load_action`.\n    - `.value` has been renamed to `.clear_value`.\n    - A new field `.store_action` has been added.\n  - An `sg_image` object with a sample count > 1 no longer contains a second implicit\n    texture for the msaa-resolve operation.\n  - When creating a pass object, there's now an array of `sg_image` objects\n    called `resolve_attachments[]`. When a resolve attachment image is set, the\n    color attachment at the same slot index must be an image with a sample count >\n    1, and an 'msaa-resolve' operation from the color attachment into the\n    resolve attachment will take place in `sg_end_pass()`.\n  - Pass attachments are now more flexible (there were a couple of gaps where specific\n    image types were not allowed as pass attachments, especially for the depth-stencil-\n    attachment - but this hadn't actually been checked by the validation layer).\n  - Some gaps in the validation layer around images and passes have been tightened up,\n    those usually don't work in one backend or another, but have been ignored so far\n    in the validation layer, mainly:\n    - MSAA images must have num_mipmaps = 1.\n    - 3D images cannot have a sample_count > 1.\n    - 3D images cannot have depth or depth-stencil image formats.\n    - It's not allowed to bind MSAA images as texture.\n    - It's not allowed to bind depth or depth-stencil images as texture.\n    - (I'll see if I can relax some of those restrictions after the WebGPU backend release)\n  - **A lot** of new tests have been added to cover validation layer checks when creating\n    image and pass objects.\n\n  Next up: WebGPU!\n\n#### 30-Apr-2023\n\nGLES2/WebGL1 support has been removed from the sokol headers (now that\n  all browsers support WebGL2, and WebGPU is around the corner I feel like it's finally\n  time to ditch GLES2.\n\n  This is a breaking API change in sokol_gfx.h and sokol_app.h.\n\n  Common changes across all headers:\n  - (breaking change) the `SOKOL_GLES2` config define is no longer accepted and will cause a compile error\n    (use `SOKOL_GLES3` instead)\n  - (breaking change) on Emscripten use the linker option `-s USE_WEBGL2=1`\n  - any embedded GLES shaders have been updated from glsl100 to glsl300es (but glsl100 shaders\n    still work fine with the GLES3 backend)\n\n  Changes in sokol_gfx.h:\n  - (breaking change) the following `sg_features` members have been removed (because those features\n    are no longer optional, but guaranteed across all backends):\n      - `sg_features.instancing`\n      - `sg_features.multiple_render_targets`\n      - `sg_features.msaa_render_targets`\n      - `sg_features.imagetype_3d`\n      - `sg_features.imagetype_array`\n  - (breaking change) the struct `sg_gl_context_desc` and its embedded instance `sg_desc.gl` have been removed\n  - `sg_image` objects with `SG_PIXELFORMAT_DEPTH` or `SG_PIXELFORMAT_DEPTH_STENCIL` with\n    a `sample_count == 1` are now regular textures in the GL backend (this is not true\n    for MSAA depth textures unfortunately, those are still GL render buffer objects)\n  - in the GL backend, `SG_PIXELFORMAT_DEPTH` now resolves to `GL_DEPTH_COMPONENT32F` (same\n    as in the other backends), previously it was `GL_DEPTH_COMPONENT16`\n  - in `sg_begin_pass()`, the GL backend now only uses the new `glClearBuffer*` functions, the\n    old GLES2 clear functions have been removed\n  - in `sg_end_pass()`, the GLES3 backend now invalidates MSAA render buffers after they have\n    been resolved (via `glInvalidateFramebuffer`) - more control over this will come soon-ish\n    when this ticket is implemented: https://github.com/floooh/sokol/issues/816\n  - the instanced rendering functions are no longer wrapped in C macros in the GL backend\n\n  Changes in sokol_app.h:\n  - (breaking) the config item `sapp_desc.gl_force_gles2` has been removed\n  - (breaking) the function `sapp_gles2()` has been removed\n  - any fallback logic from GLES3 to GLES2 has been removed (in the Emscripten, Android and\n    iOS backends)\n\n- **20-Feb-2023**: sokol_gfx.h has a new set of functions to get a 'best-effort'\n  desc struct with the creation parameters of a specific resource object:\n\n    ```c\n    sg_buffer_desc sg_query_buffer_desc(sg_buffer buf);\n    sg_image_desc sg_query_image_desc(sg_image img);\n    sg_shader_desc sg_query_shader_desc(sg_shader shd);\n    sg_pipeline_desc sg_query_pipeline_desc(sg_pipeline pip);\n    sg_pass_desc sg_query_pass_desc(sg_pass pass);\n    ```\n\n  The returned structs will *not* be an exact copy of the desc struct that\n  was used for creation the resource object, instead:\n\n    - references to external data (like buffer and image content or\n      shader sources) will be zeroed\n    - any attributes that have not been kept around internally after\n      creation will be zeroed (the ```sg_shader_desc``` struct is most\n      affected by this, the other structs are fairly complete).\n\n  Calling the functions with an invalid or dangling resource handle\n  will return a completely zeroed struct (thus it may make sense\n  to first check the resource state via ```sg_query_*_state()```)\n\n  Nevertheless, those functions may be useful to get a partially filled out\n  'creation blueprint' for creating similar resources without the need\n  to keep and pass around the original desc structs.\n\n  >MINOR BREAKING CHANGE: the struct members ```sg_image_info.width``` and\n  ```sg_image_info.height``` have been removed, this information is now\n  returned by ```sg_query_image_desc()```.\n\n  PR: https://github.com/floooh/sokol/pull/796, fixes: https://github.com/floooh/sokol/issues/568\n\n- **17-Feb-2023**: sokol_app.h on macOS now has a proper fix for the problem\n  that macOS doesn't send key-up events while the Cmd key is held down.\n  Previously this was handled through a workaround of immediately sending a\n  key-up event after its key-down event if the Cmd key is currently held down\n  to prevent a 'stuck key'. The proper fix is now to install an \"event monitor\"\n  callback (many thanks to GLFW for finding and implementing the solution).\n  Unfortunately there's no such solution for the Emscripten code path, which\n  also don't send a key-up event while Cmd is pressed on macOS (the workaround\n  there to send a key-up event right on key-down while Cmd is held down to\n  prevent a stuck key is still in place) For more details, see:\n  https://github.com/floooh/sokol/issues/794\n\n- **15-Feb-2023**: A fix in the sokol_gfx.h GL backend: due to a bug in the\n  state cache, the GL backend could only bind a total of\n  SG_MAX_SHADERSTAGE_IMAGES (= 12) when it actually should be twice that amount\n  (12 per shader stage). Note however that the total amount of texture bindings\n  is still internally limited by the GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS\n  runtime variable (~~currently this is not exposed in sg_limits though~~). Many\n  thanks to @allcreater for PR https://github.com/floooh/sokol/pull/787.\n  PS: sg_limits now exposes GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS as\n  ```sg_limits.gl_max_combined_texture_image_units```, and the\n  value can also be inspected via the debug UI in sokol_gfx_imgui.h.\n\n- **13-Feb-2023**: The way logging works has been completely revamped in\n  the sokol headers. UWP support has been removed from sokol_audio.h\n  and sokol_app.h (this also means that the sokol headers no longer contain\n  any C++ code).\n\n  **REQUIRED ACTION**: Since the sokol headers are now completely silent\n  without a logging callback (explanation below), it is highly recommended\n  to use the standard logging callback provided by the new header ```sokol_log.h```.\n  For instance for sokol_gfx.h it looks like this:\n\n    ```c\n    #include \"sokol_log.h\"\n    //...\n        sg_setup(&(sg_desc){\n            //...\n            .logger.func = slog_func,\n        });\n    ```\n\n  All sokol samples have been updated to use sokol_log.h for logging.\n\n  The former logging callback is now a combined\n  logging- and error-reporting callback, and more information is available\n  to the logging function:\n    - a 'tag string' which identifies the sokol headers, this string\n      is identical with the API prefix (e.g. \"sg\" for sokol_gfx.h,\n      \"sapp\" for sokol_app.h etc...)\n    - a numeric log level: 0=panic, 1=error, 2=warning, 3=info\n    - a numeric 'log item id' (think of it as error code, but since\n      not only errors are reported I called it a log item id)\n    - a human readable error message\n    - a source file line number where the log item was reported\n    - the file path of the sokol header\n\n  Log level ```panic``` is special in that it terminates execution inside\n  the log function. When a sokol header issues a panic log message, it means\n  that the problem is so big that execution can not continue. By default,\n  the sokol headers and the standard log function in sokol_log.h call\n  ```abort()``` when a panic log message is issued.\n\n  In debug mode (NDEBUG not defined, or SOKOL_DEBUG defined), a log message\n  (in this case from sokol_spine.h) will look like this:\n\n  ```\n  [sspine][error][id:12] /Users/floh/projects/sokol/util/sokol_spine.h:3472:0:\n      SKELETON_DESC_NO_ATLAS: no atlas object provided in sspine_skeleton_desc.atlas\n  ```\n  The information can be 'parsed' like this:\n    - ```[sspine]```: it's a message from sokol_spine.h\n    - ```[error]```: it's an error\n    - ```[id:12]```: the numeric log item id (associated with ```SKELETON_DESC_NO_ATLAS``` below)\n    - source file path and line number in a compiler-specific format - in some IDEs and terminals\n      this is a clickable link\n    - the line below is the human readable log item id and message\n\n  In release mode (NDEBUG is defined and SOKOL_DEBUG is not defined), log messages\n  are drastically reduced (the reason is to not bloat the executable with all the extra string data):\n\n  ```\n  [sspine][error][id:12][line:3472]\n  ```\n  ...this reduced information still gives all the necessary information to identify the location and type of error.\n\n  A custom logging function must adhere to a few rules:\n\n    - must be re-entrant because it might be called from different threads\n    - must treat **all** provided string pointers as optional (can be null)\n    - don't store the string pointers, copy the string data instead\n    - must not return for log level panic\n\n  A new header ```sokol_log.h``` has been added to provide a standard logging callback implementation\n  which provides logging output on all platforms to stderr and/or platform specific logging\n  facilities. ```sokol_log.h``` only uses fputs() and platform specific logging function instead\n  of fprintf() to preserve some executable size.\n\n  **QUESTION**: Why are the sokol headers now silent, unless a logging callback is installed?\n  This is mainly because a standard logging function which does something meaningful on all\n  platforms (including Windows and Android) isn't trivial. E.g. printing to stderr is not\n  enough. It's better to move that stuff into a centralized place in a separate header,\n  but since the core sokol headers must not (statically) depend on other sokol headers\n  the only solution that made sense was to provide a standard logging function which must\n  be 'registered' as a callback.\n\n- **26-Jan-2023**: Work on SRGB support in sokol_gfx.h has started, but\n  this requires more effort to be really usable. For now, only a new\n  pixel format has been added: SG_PIXELFORMAT_SRGB8A8 (see https://github.com/floooh/sokol/pull/758,\n  many thanks to @allcreater). The sokol-gfx GL backend has a temporary\n  workaround to align behaviour with D3D11 and Metal: automatic SRGB conversion\n  is enabled for offscreen render passes, but disabled for the default\n  framebuffer. A proper fix will require separate work on sokol_app.h to\n  support an SRGB default framebuffer and communicate to sokol-gfx\n  whether the default framebuffer is SRGB enabled or not.\n\n- **24-Jan-2023**: sokol_gfx.h Metal: A minor inconsistency has been fixed in\n  the validation layer and an assert for the function ```sg_apply_uniforms()```\n  which checks the size of the incoming data against the uniform block size.\n  The validation layer and Metal backend did a ```<=``` test while the D3D11\n  and GL backends checked for an exact size match. Both the validation layer\n  and the Metal backend now also check for an exact match. Thanks to @nmr8acme\n  for noticing the issue and providing a PR! (https://github.com/floooh/sokol/pull/776)\n\n- **23-Jan-2023**: A couple more sokol_audio.h updates:\n  - an AAudio backend has been added for Android, and made the default. This\n    means you now need to link with ```aaudio``` instead of ```OpenSLES``` when\n    using sokol_audio.h on Android. The OpenSLES backend code still exists (for\n    now), but must be explicitly selected by compiling the sokol_audio.h\n    implementation with the define ```SAUDIO_ANDROID_SLES``` (e.g. there is\n    no runtime fallback from AAudio to OpenSLES). AAudio is fully supported\n    since Android 8.1. Many thanks to @oviano for the initial AAudio PR\n    (https://github.com/floooh/sokol/pull/484)\n  - in the WebAudio backend, WebAudio is now properly activated on the first\n    input action again on Chrome for Android (at some point activating WebAudio\n    via a ```touchstart``` event stopped working and had to be moved to the\n    ```touchend``` event, see https://github.com/floooh/sokol/issues/701)\n  - audio backend initialization on iOS and macOS is now a bit more fault-tolerant,\n    errors during initialization now properly set sokol_audio.h to 'silent mode'\n    instead of asserting (or in release mode ignoring the error)\n  - ...and some minor general code cleanup things in sokol_audio.h: backend-specific\n    functions now generally have a matching prefix (like ```_saudio_alsa_...()```)\n    for better searchability\n\n- **16-Jan-2023**:\n  - sokol_audio.h android: https://github.com/floooh/sokol/pull/747 has been merged\n    which adds a couple more error checks at OpenSLES startup.\n  - sokol_gfx.h: support for half-float vertex formats has been added via\n    PR https://github.com/floooh/sokol/pull/745\n  - sokol_imgui.h: fixes for Dear ImGui 1.89 deprecations (via PR https://github.com/floooh/sokol/pull/761)\n\n- **15-Jan-2023**: two bugfixes in sokol_app.h and sokol_gfx.h:\n  - sokol_app.h x11: Mouse button events now always return valid mouse\n    coordinates, also when no mouse movement happened yet\n    (fixes https://github.com/floooh/sokol/issues/770)\n  - sokol_gfx.h gl: The GL context is now configured with\n    GL_UNPACK_ALIGNMENT = 1, this should bring texture creation and updating\n    behaviour in line with the other backends for tightly packed texture\n    data that doesn't have a row-pitch with a multiple of 4\n    (fixes https://github.com/floooh/sokol/issues/767)\n\n- **14-Jan-2023**: sokol_app.h x11: a drag'n'drop related bugfix, the\n  XdndFinished reply event was sent with the wrong window handle which\n  confused some apps where the drag operation originated\n  (see https://github.com/floooh/sokol/pull/765#issuecomment-1382750611)\n\n- **16-Dec-2022**: In the sokol_gfx.h Metal backend: A fix for a Metal\n  validation layer error which I just discovered yesterday (seems to be new in\n  macOS 13). When the validation layer is active, and the application window\n  becomes fully obscured, the validation layer throws an error after a short\n  time (for details see: https://github.com/floooh/sokol/issues/762).\n  The reason appears to be that sokol_gfx.h creates a command buffer with\n  'unretained references' (e.g. the command buffer doesn't manage the\n  lifetime of resources used by the commands stored in the buffer). This\n  seems to clash with MTKView's and/or CAMetalLayer's expectations. I fixed\n  this now by creating a second command buffer with 'retained references',\n  which only holds the ```presentDrawable``` command. That way, regular\n  draw commands don't have the refcounting overhead (because they're stored\n  in an unretained-references cmdbuffer), while the drawable surface is\n  still properly lifetime managed (because it's used in a separate command\n  buffer with retained references).\n\n- **15-Dec-2022**: A small but important update in sokol_imgui.h which fixes\n  touch input handling on mobile devices. Many thanks to GitHub user @Xadiant\n  for the bug investigation and [PR](https://github.com/floooh/sokol/pull/760).\n\n- **25-Nov-2022**: Some code cleanup around resource creation and destruction in sokol_gfx.h:\n    - It's now safe to call the destroy, uninit and dealloc functions in any\n      resource state, in general, the functions will do the right thing without\n      assertions getting in the way (there are however new log warnings in some\n      cases though, such as attempting to call an ```sg_dealloc_*()``` function on\n      a resource object that's not in ALLOC state)\n    - A related **minor breaking change**: the ```sg_uninit_*()``` functions now return\n      void instead of bool, this is because ```sg_dealloc_*()``` no longer asserts\n      when called in the wrong resource state\n    - Related internal code cleanup in the backend-agnostic resource creation\n      and cleanup code, better or more consistent function names, etc...\n    - The validation layer can now be disabled in debug mode with a runtime\n      flag during setup: ```sg_desc.disable_validation```. This is mainly useful\n      for test code.\n    - Creating a pass object with invalid image objects now no longer asserts,\n      but instead results in a pass object in FAILED state. In debug mode,\n      the validation layer will still stop at this problem though (it's mostly\n      an 'undefined API behaviour' fix in release mode).\n    - Calling ```sg_shutdown()``` with existing resources in ALLOC state will\n      no longer print a log message about an 'active context mismatch'.\n    - A new header documentation blurb about the two-step resource creation\n      and destruction functions (search for RESOURCE CREATION AND DESTRUCTION IN DETAIL)\n\n- **16-Nov-2022**: Render layer support has been added to sokol_debugtext.h,\n  same general changes as in sokol_gl.h with two new functions:\n  sdtx_layer(layer_id) to select the layer to record text into, and\n  sdtx_draw_layer(layer_id) to draw the recorded text in that layer inside a\n  sokol-gfx render pass. The new sample [debugtext-layers-sapp](https://floooh.github.io/sokol-html5/debugtext-layers-sapp) demonstrates the feature together with\n  sokol-gl.\n\n\n- **11-Nov-2022**: sokol_gl.h has 2 new public API functions which enable\n  layered rendering: sgl_layer(), sgl_draw_layer() (technically it's three\n  functions: there's also sgl_context_draw_layer(), but that's just a variant of\n  sgl_draw_layer()). This allows to 'interleave' sokol-gl rendering\n  with other render operations. The [spine-layers-sapp](https://floooh.github.io/sokol-html5/spine-layers-sapp.html)\n  sample has been updated to use multiple sokol-gl layers.\n\n- **09-Nov-2022**: sokol_gfx.h now allows to add 'commit listeners', these\n  are callback functions which are called from inside sg_commit(). This is\n  mainly useful for libraries which build on top of sokol-gfx to be notified\n  about the start/end point of a frame, which in turn may simplify the public\n  API, or the internal implementation, because the library no longer needs to\n  'guess' when a new frame starts.\n\n  For more details, search for 'COMMIT LISTENERS' in the sokol_gfx.h header.\n\n  This also results in a minor breaking change in sokol_spine.h: The function\n  ```sspine_new_frame()``` has been removed and replaced with an internal commit\n  listener.\n\n  Likewise, sokol_gl.h now uses a commit listener in the implementation, but\n  without changing the public API (the feature will be important for an upcoming\n  sokol-gl feature to support rendering layers, and for this a 'new-frame-function'\n  would have been needed).\n\n- **05-Nov-2022** A breaking change in sokol_fetch.h, and a minor change in\n  sokol_app.h which should only break for very few users:\n  - An ```sfetch_range_t``` ptr/size pair struct has been added to sokol_fetch.h,\n    and discrete ptr/size pairs have been replaced with sfetch_range_t\n    items. This affects the structs ```sfetch_request_t``` and ```sfetch_response_t```,\n    and the function ```sfetch_bind_buffer()```.\n  - The required changes in ```sfetch_response_t``` might be a bit non-obviois: To\n    access the fetched data, previous ```.buffer_ptr``` and ```.fetched_size```\n    was used. The fetched data is now accessible through an ```sfetch_range_t data```\n    item (```data.ptr``` and ```data.size```). The old ```.fetched_offset``` item\n    has been renamed to ```.data_offset``` to better conform with the new naming.\n  - The last two occurrences of discrete ptr/size pairs in sokol_app.h now have also\n    been replaced with ```sapp_range_t``` items, this only affects the structs\n    ```sapp_html5_fetch_request``` and ```sapp_html5_fetch_response```.\n\n- **03-Nov-2022** The language bindings generation has been updated for Zig 0.10.0,\n  and clang-14 (there was a minor change in the JSON ast-dump format).\n  Many thanks to GitHub user @kcbanner for the Zig PR!\n\n- **02-Nov-2022** A new header sokol_spine.h (in the util dir), this is a\n  renderer and 'handle wrapper' around the spine-c runtime (Spine is a popular 2D\n  character anim system: http://esotericsoftware.com/). This turned out a much bigger\n  rabbit-hole than I initially expected, but the effort is justified by being a\n  experimentation testbed for a couple of things I want to add to other sokol\n  headers (for instance cleaned up handle pool code, a new logging- and error-reporting\n  system, render layers which will be useful for sokol_gl.h and sokol_debugtext.h).\n\n- **22-Oct-2022** All sokol headers now allow to override logging with a\n  callback function (installed in the setup call) instead of defining a SOKOL_LOG\n  macro. Overriding SOKOL_LOG still works as default fallback, but this is no\n  longer documented, consider this deprecated. Many thanks to GitHub user\n  @Manuzor for the PR (see https://github.com/floooh/sokol/pull/721 for details)\n\n- **21-Oct-2022** RGB9E5 pixel format support in sokol_gfx.h and a GLES2 related\n  bugfix in the sokol_app.h Android backend:\n  - sokol_gfx.h now supports RGB9E5 textures (3*9 bit RGB + 5 bit shared exponent),\n    this works in all backends except GLES2 and WebGL1 (use ```sg_query_pixelformat()```\n    to check for runtime support). Many thanks to GitHub user @allcreater for the PR!\n  - a bugfix in the sokol_app.h Android backend: when forcing a GLES2 context via\n    sapp_desc.gl_force_gles2, the Android backend correctly created a GLES2 context,\n    but then didn't communicate this through the function ```sapp_gles2()``` (which\n    still returned false in this case). This caused the sokol_gfx.h GL backend to\n    use the GLES3 code path instead GLES2 (which surprisingly seemed to have worked\n    fine, at least for the sokol samples which force GLES2).\n\n- **19-Oct-2022** Some fixes in the embedded Javascript code blocks (via EM_JS)\n  in sokol_app.h, sokol_args.h, sokol_audio.h and sokol_fetch.h:\n  - the JS code has been 'modernized' (e.g. const and let instead of var,\n    ```() => { ... }``` instead of ```function () { ... }``` for callbacks)\n  - false positives in the Closure static analysis have been suppressed\n    via inline hints\n\n- **16-Oct-2022** The Odin bindings generator and the generated bindings have\n  been simplified (the Odin binding now don't have separate wrapper functions).\n  Requires the latest Odin release. Also note: On M1 Macs I'm currently seeing\n  what looks like an ABI problem (in functions which pass color values to the C\n  side as uint8_t, the colors come out wrong). This also happened with the\n  previous binding version, so it looks like a regression in Odin. Might be\n  related to this recent bugfix (which I haven't tested yet):\n  https://github.com/odin-lang/Odin/issues/2121 Many thanks to @thePHTest for the\n  PR! (https://github.com/floooh/sokol/pull/719)\n\n- **15-Oct-2022**\n    - fixes for Emscripten 3.1.24: the sokol headers now use the new\n    **EM_JS_DEPS()** macro to declare 'indirect dependencies on JS library functions'.\n    This is a (much more robust) follow-up fix to the Emscripten related fixes from 10-Sep-2022.\n    The new Emscripten SDK also displays a couple of Javascript \"static analyzer\" warnings\n    by the Closure compiler (used in release mode to optimize and minify the generated\n    JS code). I fixed a couple of those warnings, but some warnings persist (all of them\n    false positives). Not sure yet if these can be fixed or need to be suppressed, but\n    that's for another time.\n    - the webkitAudioContext() fallback in sokol_audio.h's Emscripten backend\n    has been removed (only AudioContext is supported now), the fallback also\n    triggered a Closure warning, so it probably never worked as intended anyway.\n    - I also had to undo an older workaround in sokol_app.h on iOS (https://github.com/floooh/sokol/issues/645)\n    because this is now triggering a Metal validation layer error (https://github.com/floooh/sokol/issues/726).\n    The original case is no longer reproducible, so undoing the old workaround seems to\n    be a quick fix. Eventually I want to get rid of MTKView though, and go down to\n    CAMetalLayer.\n\n- **08-Oct-2022** sokol_app.h Android backend: the ```sapp_touchpoint``` struct\n  now has a new item ```sapp_android_tooltype android_tooltype;```. This exposes the\n  result of the Android NDK function ```AMotionEvent_getToolType()```.\n  Many thanks to @Wertzui123 for the initial PR (https://github.com/floooh/sokol/pull/717).\n\n- **25-Sep-2022**: sokol_app.h on Linux now optionally supports EGL instead of\n  GLX for the window system glue code and can create a GLES2 or GLES3 context\n  instead of a 'desktop GL' context.\n  To get EGL+GLES2/GLES3, just define SOKOL_GLES2 or SOKOL_GLES3 to compile the\n  implementation. To get EGL+GL, define SOKOL_GLCORE *and* SOKOL_FORCE_EGL.\n  By default, defining just SOKOL_GLCORE uses GLX for the window system glue\n  (just as before). Many thanks to GH user @billzez for the PR!\n\n- **10-Sep-2022**: sokol_app.h and sokol_args.h has been fixed for Emscripten 3.21, those headers\n  used the Emscripten Javascript helper function ```ccall()``` which is now part of the\n  'legacy runtime' and causes linker errors. Instead of ```ccall()``` sokol_app.h and sokol_args.h\n  now drop down to a lower level set of Emscripten JS helper functions (which hopefully won't\n  go away anytime soon).\n\n- **05-Aug-2022**: New officially supported and automatically updated language bindings for Odin:\n  https://github.com/floooh/sokol-odin (also see [gen_odin.py](https://github.com/floooh/sokol/blob/master/bindgen/gen_odin.py))\n\n- **10-Jul-2022**: New features in sokol_app.h and sokol_imgui.h:\n    - In sokol_app.h it's now possible to set a mouse cursor type from a number of predefined\n      types via the new function ```sapp_set_mouse_cursor(sapp_mouse_cursor cursor)```. The\n      available cursor types are compatible with GLFW and Dear ImGui. Supported platforms\n      are: macOS, linux, win32, uwp and web.\n    - ```sapp_show_mouse(bool shown)``` now also works on the web platform.\n    - In sokol_app.h, the poorly defined 'user cursor' feature has been removed (```sapp_desc.user_cursor```\n      and ```SAPP_EVENTTYPE_UPDATE_CURSOR```). This was a hack to allow changing the mouse cursor and\n      only worked on Win32 and macOS (with different behaviour). Since setting the cursor type\n      is now 'properly supported, this hack was removed.\n    - sokol_imgui.h will now set the cursor type via ```sapp_set_mouse_cursor()```. This can be\n      disabled with the new ```simgui_desc_t``` item ```disable_set_mouse_cursor```.\n    - sokol_imgui.h now automatically enables resizing windows from edges (not just the bottom-right corner),\n      this behaviour can be disabled with the new ```simgui_desc_t``` item ```disable_windows_resize_from_edges```.\n    - sokol_imgui.h can now optionally write to the alpha channel (useful if you want to render the UI\n      into a separate render target, which is later composed onto the default framebuffer). The feature\n      is enabled with the new ```simgui_desc_t``` item ```write_alpha_channel```.\n\n  Many thanks to **@tomc1998** for the initial [Linux/X11 mouse cursor type PR](https://github.com/floooh/sokol/pull/678) and\n  **@luigi-rosso** for the [sokol_imgui.h alpha channel PR](https://github.com/floooh/sokol/pull/687)!\n\n- **03-Jul-2022**: A new sokol_gfx.h function ```bool sg_query_buffer_will_overflow(sg_buffer buf, size_t size)```\nwhich allows to check if a call to ```sg_append_buffer()``` would overflow the buffer. This\nis an alternative to the ```sg_query_buffer_overflow()``` function which only reports\nthe overflow after the fact. Many thanks to @RandyGaul for the PR!\n\n- **29-Jun-2022**: In sokol_app.h with the D3D11 backend, if SOKOL_DEBUG is\ndefined, and the D3D11 device creation fails, there's now a fallback code\npath which tries to create the device again without the D3D11_CREATE_DEVICE_DEBUG\nflag. Turns out the D3D11 debug support may suddenly stop working (just happened\nto me, indicated by the Win10 \"Graphics Tool\" feature being silently uninstalled\nand failing to install when asked to do so). This fix at least allows sokol_app.h\napplications compiled in debug mode to run, even if the D3D11 debug layer doesn't\nwork.\n\n- **29-May-2022**: The code generation scripts for the\n[sokol-nim](https://github.com/floooh/sokol-nim) language bindings have been\nrevised and updated, many thanks to Gustav Olsson for the PR! (I'm planning to\nspend a few more days integrating the bindings generation with GitHub Actions,\nso that it's easier to publish new bindings after updates to the sokol headers).\n\n- **26-May-2022**: The GL backend in sokol_app.h now allows to override the GL\n  context version via two new items in the ```sapp_desc``` struct:\n  ```sapp_desc.gl_major_version``` and ```sapp_desc.gl_minor_version```. The\n  default GL context version remains at 3.2. Overriding the GL version might make\n  sense if you're not using sokol_app.h together with sokol_gfx.h, or otherwise\n  want to call GL functions directly. Note that this only works for the\n  'desktop GL' backends (Windows, Linux and macOS), but not for the GLES backends\n  (Android, iOS, web). Furthermore, on macOS only the GL versions 3.2 and 4.1\n  are available (plus the special config major=1 minor=0 creates an\n  NSOpenGLProfileVersionLegacy context). In general: use at your risk :) Many\n  thanks to GitHub user @pplux for the PR!\n\n- **15-May-2022**: The way internal memory allocation can be overridden with\n  your own functions has been changed from global macros to callbacks\n  provided in the API setup call. For instance in sokol_gfx.h:\n\n  ```c\n  void* my_malloc(size_t size, void* userdata) {\n    (void)userdata; // unused\n    return malloc(size);\n  }\n\n  void my_free(void* ptr, void* userdata) {\n    (void)userdata; // unused\n    free(ptr);\n  }\n\n  //...\n    sg_setup(&(sg_desc){\n      //...\n      .allocator = {\n        .alloc = my_malloc,\n        .free = my_free,\n        .user_data = ...,\n      }\n    });\n  ```\n\n  sokol_gfx.h will now call ```my_malloc()``` and ```my_free()``` whenever it needs\n  to allocate or free memory (note however that allocations inside OS\n  functions or 3rd party libraries are not affected).\n\n  If no override functions are provided, the standard library functions ```malloc()``` and ```free()```\n  will be used, just as before.\n\n  This change breaks source compatibility in the following headers:\n\n    - **sokol_fontstash.h**: the function signature of ```sfons_create()``` has changed,\n      this now takes a pointer to a new ```sfons_desc_t``` struct instead of\n      individual parameters.\n    - **sokol_gfx_imgui.h** (NOT sokol_imgui.h!): likewise, the function signature of\n      ```sg_imgui_init()``` has changed, this now takes an additional parameter\n      which is a pointer to a new ```sg_imgui_desc_t``` struct.\n\n  All affected headers also have a preprocessor check for the outdated\n  macros ```SOKOL_MALLOC```, ```SOKOL_CALLOC``` and ```SOKOL_FREE``` and throw\n  a compilation error if those macros are detected.\n\n  (if configuration through macros is still desired this could be added back in\n  the future, but I figured that the new way is more flexible in most situations).\n\n  The header sokol_memtrack.h and the sample [restart-sapp](https://floooh.github.io/sokol-html5/restart-sapp.html) have been updated accordingly.\n\n  Also search for ```MEMORY ALLOCATION OVERRIDE``` in the header documentation block\n  for more details.\n\n- **14-May-2022**: added a helper function ```simgui_map_keycode()``` to\n  sokol_imgui.h to map sokol_app.h keycodes (```sapp_keycode```,\n  ```SAPP_KEYCODE_*```) to Dear ImGui keycodes (```ImGuiKey```, ```ImGuiKey_*```).\n  If you're using Dear ImGui function to check for key input, you'll need to\n  update the code like this:\n\n  - Old:\n    ```cpp\n    ImGui::IsKeyPressed(SAPP_KEYCODE_A);\n    ```\n  - New:\n    ```cpp\n    ImGui::IsKeyPressed(simgui_map_keycode(SAPP_KEYCODE_A));\n    ```\n\n  This was basically 'fallout' from rewriting the input system in sokol_imgui.h\n  to the new evented IO system in Dear ImGui.\n\n- **08-Feb-2022**: sokol_imgui.h has been updated for Dear ImGui 1.87:\n  - sokol_imgui.h's input code has been rewritten to use the new evented IO\n    system and extended virtual key codes in Dear ImGui\n  - on non-Emscripten platforms, mouse buttons are no longer \"cancelled\" when\n    the mouse leaves the window (since the native desktop platforms\n    automatically capture the mouse when mouse buttons are pressed, but mouse\n    capture is not supported in the sokol_app.h Emscripten backend)\n\n- **28-Jan-2022**: some window size behaviour changes in sokol_app.h.\n  - Asking for a default-sized window (via sapp_desc.width/height = 0) now\n    behaves a bit differently on desktop platforms. Previously this set the\n    window size to 640x480, now a default window covers more screen area:\n      - on Windows CW_USEDEFAULT will be used for the size\n      - on macOS and Linux, the window size will be 4/5 of the\n        display size\n      - no behaviour changes on other platforms\n  - On Windows and Linux, the window is now centered (in a later update,\n    more control over the initial window position, and new functions for\n    positioning and sizing might be provided)\n  - On Windows, when toggling between windowed and fullscreen, the\n    window position and size will now be restored (on other platforms\n    this already happened automatically through the window system)\n  - On all desktop platforms if an application starts in fullscreen and\n    then is toggled back to windowed, the window will now be of the\n    expected size (provided in sapp_desc.width/height)\n\n- **20-Jan-2022**:\n  - sokol_audio.h: A compatibility fix in the sokol_audio.h WASAPI backend (Windows): On\n    some configs the IAudioClient::Initialize() call could fail because\n    of a mismatch between the requested number of channels and speaker config.\n    See [#614](https://github.com/floooh/sokol/issues/614) for details.\n  - sokol_app.h D3D11/DXGI: Fix an (uncritical) COM interface leak warning for IDXGIAdapter and\n    IDXGIFactory at shutdown, introduced with the recent disabling of Alt-Enter.\n\n- **18-Jan-2022**:\n  - sokol_app.h now has per-monitor DPI support on Windows and macOS: when\n    the application window is moved to a monitor with different DPI, the values\n    returned by sapp_dpi_scale(), sapp_width() and sapp_height() will update\n    accordingly (only if the application requested high-dpi rendering with\n    ```sapp_desc.high_dpi=true```, otherwise the dpi scale value remains\n    fixed at 1.0f). The application will receive an SAPP_EVENTTYPE_RESIZED event\n    if the default framebuffer size has changed because of a DPI change.\n    On Windows this feature requires Win10 version 1703 or later (aka the\n    'Creators Update'), older Windows version simply behave as before.\n    Many thank to @tjachmann for the initial PR with the Windows implementation!\n  - sokol_app.h: DPI scale computation on macOS is now more robust using the\n    NSScreen.backingScaleFactor value\n  - sokol_app.h: the new frame timing code in sokol_app.h now detects if the display\n    refresh rate changes and adjusts itself accordingly (for instance if the\n    window is moved between displays with different refresh rate)\n  - sokol_app.h D3D11/DXGI: during window movement and resize, the frame is now\n    presented with DXGI_PRESENT_DO_NOT_WAIT, this fixes some window system\n    stuttering issues on Win10 configs with recent NVIDIA drivers.\n  - sokol_app.h D3D11/DXGI: the application will no longer appear to freeze for\n    0.5 seconds when the title bar is grabbed with the mouse for movement, but\n    then not moving the mouse.\n  - sokol_app.h D3D11/DXGI: DXGI's automatic windowed/fullscreen switching via\n    Alt-Enter has been disabled, because this switched to 'real' fullscreen mode,\n    while sokol_app.h's fullscreen mode uses a borderless window. Use the\n    programmatic fullscreen/window switching via ```sapp_toggle_fullscreen()```\n    instead.\n  - **BREAKING CHANGE** in sokol_imgui.h: because the applications' DPI scale\n    can now change at any time, the DPI scale value is now communicated to\n    sokol_imgui.h in the ```simgui_new_frame()``` function. This has been\n    changed to accept a pointer to a new ```simgui_frame_desc_t``` struct.\n    With C99, change the simgui_new_frame() call as follows (if also using\n    sokol_app.h):\n    ```c\n    simgui_new_frame(&(simgui_frame_desc_t){\n        .width = sapp_width(),\n        .height = sapp_height(),\n        .delta_time = sapp_frame_duration(),\n        .dpi_scale = sapp_dpi_scale()\n    });\n    ```\n    On C++ this works:\n    ```c++\n    simgui_new_frame({ sapp_width(), sapp_height(), sapp_frame_duration(), sapp_dpi_scale() });\n    ```\n    ...or in C++20:\n    ```c++\n    simgui_new_frame({\n        .width = sapp_width(),\n        .height = sapp_height(),\n        .delta_time = sapp_frame_duration(),\n        .dpi_scale = sapp_dpi_scale()\n    });\n    ```\n  - **KNOWN ISSUE**: the recent change in sokol-audio's WASAPI backend to directly consume\n    float samples doesn't appear to work on some configs (see [#614](https://github.com/floooh/sokol/issues/614)),\n    investigation is underway\n\n- **15-Jan-2022**:\n  - A bugfix in the GL backend for uniform arrays using the 'native' uniform block layout.\n    The bug was a regression in the recent 'uniform data handling' update. See\n    [PR #611](https://github.com/floooh/sokol/pull/611) for details, and this [new sample/test](https://github.com/floooh/sokol-samples/blob/master/glfw/uniformarrays-glfw.c).\n    Many thanks to @nmr8acme for the PR!\n\n- **08-Jan-2022**: some enhancements and cleanup to uniform data handling in sokol_gfx.h\n  and the sokol-shdc shader compiler:\n    - *IMPORTANT*: when updating sokol_gfx.h (and you're using the sokol-shdc shader compiler),\n      don't forget to update the sokol-shdc binaries too!\n    - The GLSL uniform types int, ivec2, ivec3 and\n      ivec4 can now be used in shader code, those are exposed to the GL\n      backends with the new ```sg_uniform_type``` items\n      ```SG_UNIFORM_TYPE_INT[2,3,4]```.\n    - A new enum ```sg_uniform_layout```, currently with the values SG_UNIFORMLAYOUT_NATIVE\n      and SG_UNIFORMLAYOUT_STD140. The enum is used in ```sg_shader_uniform_block_desc```\n      as a 'packing rule hint', so that the GL backend can properly locate the offset\n      of uniform block members. The default (SG_UNIFORMLAYOUT_NATIVE) keeps the same\n      behaviour, so existing code shouldn't need to be changed. With the packing\n      rule SG_UNIFORMLAYOUT_STD140 the uniform block interior is expected to be\n      laid out according to the OpenGL std140 packing rule.\n    - Note that the SG_UNIFORMLAYOUT_STD140 only allows a subset of the actual std140\n      packing rule: arrays are only allowed for the types vec4, int4 and mat4.\n      This is because the uniform data must still be compatible with\n      ```glUniform()``` calls in the GL backends (which have different\n      'interior alignment' for arrays).\n    - The sokol-shdc compiler supports the new uniform types and will annotate the\n      code-generated sg_shader_desc structs with SG_UNIFORMLAYOUT_STD140,\n      and there are new errors to make sure that uniform blocks are compatible\n      with all sokol_gfx.h backends.\n    - Likewise, sokol_gfx.h has tighter validation for the ```sg_shader_uniform_block```\n      desc struct, but only when the GL backend is used (in general, the interior\n      layout of uniform blocks is only relevant for GL backends, on all other backends\n      sokol_gfx.h just passes the uniform data as an opaque block to the shader)\n  For more details see:\n    - [new sections in the sokol_gfx.h documentation](https://github.com/floooh/sokol/blob/ba64add0b67cac16fc86fb6b64d1da5f67e80c0f/sokol_gfx.h#L343-L450)\n    - [documentation of ```sg_uniform_layout```](https://github.com/floooh/sokol/blob/ba64add0b67cac16fc86fb6b64d1da5f67e80c0f/sokol_gfx.h#L1322-L1355)\n    - [enhanced sokol-shdc documentation](https://github.com/floooh/sokol-tools/blob/master/docs/sokol-shdc.md#glsl-uniform-blocks-and-c-structs)\n    - [a new sample 'uniformtypes-sapp'](https://floooh.github.io/sokol-html5/uniformtypes-sapp.html)\n\n  PS: and an unrelated change: the frame latency on Win32+D3D11 has been slightly improved\n  via IDXGIDevice1::SetMaximumFrameLatency()\n\n- **27-Dec-2021**: sokol_app.h frame timing improvements:\n  - A new function ```double sapp_frame_duration(void)``` which returns the frame\n    duration in seconds, averaged over the last 256 frames to smooth out\n    jittering spikes. If available, this uses platform/backend specific\n    functions of the swapchain API:\n      - On Windows: DXGI's GetFrameStatistics().SyncQPCTime.\n      - On Emscripten: the timestamp provided by the RAF callback, this will\n        still be clamped and jittered on some browsers, but averaged over\n        a number of frames yields a pretty accurate approximation\n        of the actual frame duration.\n      - On Metal, ```MTLDrawable addPresentedHandler + presentedTime```\n        doesn't appear to function correctly on macOS Monterey and/or M1 Macs, so\n        instead mach_absolute_time() is called at the start of the MTKView\n        frame callback.\n      - In all other situations, the same timing method is used as\n        in sokol_time.h.\n  - On macOS and iOS, sokol_app.h now queries the maximum display refresh rate\n    of the main display and uses this as base to compute the preferred frame\n    rate (by multiplying with ```sapp_desc.swap_interval```), previously the\n    preferred frame rate was hardwired to ```60 * swap_interval```. This means\n    that native macOS and iOS applications may now run at 120Hz instead of\n    60Hz depending on the device (I realize that this isn't ideal, there\n    will probably be a different way to hint the preferred interval at\n    which the frame callback is called, which would also support disabling\n    vsync and probably also adaptive vsync).\n\n- **19-Dec-2021**: some sokol_audio.h changes:\n  - on Windows, sokol_audio.h no longer converts audio samples\n    from float to int16_t, but instead configures WASAPI to directly accept\n    float samples. Many thanks to GitHub user iOrange for the PR!\n  - sokol_audio.h has a new public function ```saudio_suspended()``` which\n    returns true if the audio device/context is currently in suspended mode.\n    On all backends except WebAudio this always returns false. This allows\n    to show a visual hint to the user that audio is muted until the first\n    input event is received.\n\n- **18-Dec-2021**: the sokol_gfx.h ```sg_draw()``` function now uses the currently applied\n  pipeline object to decide if the GL or D3D11 backend's instanced drawing function\n  should be called instead of the ```num_instances``` argument. This fixes a\n  bug on some WebGL configs when instanced rendering is configured\n  but ```sg_draw()``` is called with an instance count of 1.\n\n- **18-Nov-2021**: sokol_gl.h has a new function to control the point size for\n  point list rendering: ```void sgl_point_size(float size)```. Note that on D3D11\n  the point size is currently ignored (since D3D11 doesn't support a point size at\n  all, the feature will need to be emulated in sokol_gl.h when the D3D11 backend is active).\n  Also note that points cannot currently be textured, only colored.\n\n- **08-Oct-2021**: texture compression support in sokol_gfx.h has been revisited:\n    - tighter validation checks on texture creation:\n        - content data validation now also happens in ```sg_make_image()``` (previously only in ```sg_update_image()```)\n        - validate that compressed textures are immutable\n        - separate \"no data\" validation checks for immutable vs dynamic/stream textures\n        - provided data size for creating or updating textures must match the expected surface sizes exactly\n    - fix PVRTC row and surface pitch computation according to the GL PVRTC extension spec\n    - better adhere to Metal documentation for the ```MTLTexture.replaceRegion``` parameters (when bytesPerImage is expected to be zero or not)\n\n- **02-Sep-2021**: some minor non-breaking additions:\n    - sokol_app.h: new events FOCUSED and UNFOCUSED to indicate that the\n      window has gained or lost the focused state (Win32: WM_SETFOCUS/WM_KILLFOCUS,\n      macOS: windowDidBecomeKey/windowDidResignKey, X11: FocusIn/FocusOut,\n      HTML5: focus/blur).\n    - sokol_app.h Emscripten backend: the input event keycode is now extracted\n      from the HTML5 code string which yields the actual unmapped virtual key code.\n\n- **21-Aug-2021**: some minor API tweaks in sokol_gl.h and sokol_debugtext.h,\n  one of them breaking (still minor though):\n    - sokol_gl.h has a new function ```sgl_default_context()``` which returns the\n      default context handle, it's the same as the global constant SGL_DEFAULT_CONTEXT,\n      but wrapping this in a function is better for language bindings\n    - ...and a similar function in sokol_debugtext.h: ```sdtx_default_context()```\n    - The sokol_gl.h function ```sgl_default_pipeline()``` has been renamed to\n      ```sgl_load_default_pipeline()```. This fits better with the related\n      function ```sgl_load_pipeline()``` and doesn't 'semantically clash'\n      with the new function sgl_default_context(). The sgl_default_pipeline()\n      function is rarely used, so it's quite unlikely that this change breaks\n      your code.\n\n- **19-Aug-2021**: sokol_gl.h gained rendering context support, this allows\n  sokol-gl to render into different sokol-gfx render passes. No changes are\n  needed for existing sokol-gl code. Check the updated\n  [header documentation](https://github.com/floooh/sokol/blob/master/util/sokol_gl.h)\n  and the new sample\n  [sgl-context-sapp](https://floooh.github.io/sokol-html5/sgl-context-sapp.html)\n  for details!\n\n- **21-Jun-2021**: A new utility header sokol_color.h has been added, which adds\n  sokol_gfx.h-compatible named color constants and a handful initial utility\n  functions. See the [header documentation](https://github.com/floooh/sokol/blob/master/util/sokol_color.h)\n  for details. Many thanks to Stuart Adams (@nyalloc) for contributing the header!\n\n- **12-Apr-2021**: Minor new feature in sokol_app.h: mouse buttons are now\n  also reported as modifier flags in most input events (similar to the\n  Ctrl-, Alt-, Shift- and Super-key modifiers). This lets you quickly check\n  what mouse buttons are currently pressed in any input event without having\n  to keep track of pressed mouse buttons yourself. This is implemented in the following\n  sokol_app.h backends: Win32, UWP, Emscripten, X11 and macOS. Example\n  code is in the [events-sapp.cc](https://floooh.github.io/sokol-html5/events-sapp.html) sample\n\n- **10-Apr-2021**: followup fixes from yesterday: custom icon support on macOS\n  has been added (since macOS has no regular window icons, the dock icon is\n  updated instead), and a bugfix in the internal helper which select the\n  best matching candidate image (this actually always selected the first\n  candidate image)\n\n- **09-Apr-2021**: sokol_app.h now allows to programmatically set the window\n  icon in the Win32, X11 and HTML5 backends. Search for \"WINDOW ICON SUPPORT\"\n  in sokol_app.h for documentation, and see the new\n  [icon sample](https://floooh.github.io/sokol-html5/icon-sapp.html) for example code.\n\n- **01-Apr-2021**: some fixes in sokol_app.h's iOS backend:\n    - In the iOS Metal backend, high-dpi vs low-dpi works again. Some time\n    ago (around iOS 12.x) MTKView started to ignore the contentScaleFactor\n    property, which lead to sokol_app.h always setting up a HighDPI\n    framebuffer even when sapp_desc.high_dpi wasn't set. The fix is to set\n    the MTKView's drawableSize explicitly now.\n    - The iOS GL backend didn't support MSAA multisampling so far, this has\n    been fixed now, but only one MSAA mode (4x) is available, which will be\n    selected when sapp_desc.sample_count is greater than 1.\n\n- **31-Mar-2021**: sokol_audio.h on macOS no longer includes system framework\n  headers (AudioToolbox/AudioToolbox.h), instead the necessary declarations\n  are embedded directly in sokol_audio.h (to get the old behaviour and\n  force inclusion of AudioToolbox/AudioToolbox.h, define\n  ```SAUDIO_OSX_USE_SYSTEM_HEADERS``` before including the sokol_audio.h\n  implementation). This \"fix\" is both an experiment and an immediate workaround\n  for a current issue in Zig's HEAD version (what will eventually become\n  zig 0.8.0). See this issue for details: https://github.com/ziglang/zig/issues/8360).\n  The experiment is basically to see whether this approach generally makes sense\n  (replacing system headers with embedded declarations, so that the sokol headers\n  only depend on C standard library headers). This approach might\n  simplify cross-compilation and integration with other languages than C and C++.\n\n- **20-Mar-2021**: The Windows-specific OpenGL loader, and the platform-specific\nGL header includes have been moved from sokol_app.h to sokol_gfx.h. This means:\n  - In general, the sokol_gfx.h implementation can now simply be included\n    without having to include other headers which provide the GL API declarations\n    first (e.g. when sokol_gfx.h is used without sokol_app.h, you don't need to\n    use a GL loader, or include the system-specific GL headers yourself).\n  - When sokol_gfx.h is used together with sokol_app.h, the include order\n    for the implementations doesn't matter anymore (until now, the sokol_app.h\n    implementation had to be included before the sokol_gfx.h implementation).\n  - The only \"downside\" (not really a downside) is that sokol_gfx.h now has\n    platform detection ifdefs to include the correct GL headers for a given\n    platform. Until now this problem was \"delegated\" to the library user.\n  - The old macro **SOKOL_WIN32_NO_GL_LOADER** has been removed, and replaced\n    with a more general **SOKOL_EXTERNAL_GL_LOADER**. Define this before\n    including the sokol_gfx.h implementation if you are using your own GL\n    loader or provide the GL API declarations in any other way. In this case,\n    sokol_gfx.h will not include any platform GL headers, and the embedded\n    Win32 GL loader will be disabled.\n\n- **22-Feb-2021**: Mouse input latency in sokol_app.h's macOS backend has been\n  quite significantly reduced, please see the detailed explanation [in this\n  PR](https://github.com/floooh/sokol/pull/483). Many thanks to @randrew for\n  the PR!\n\n- **19-Feb-2021**: sokol_app.h learned some Windows-specific config options\nto redirect stdout/stderr to the parent terminal or a separate console\nwindow, and allow outputting UTF-8 encoded text. For details, search for\n\"WINDOWS CONSOLE OUTPUT\" in\n[sokol_app.h](https://github.com/floooh/sokol/blob/master/sokol_app.h). Many\nthanks to @garettbass for the initial PR!\n\n- **17-Feb-2021**: When compiled for iOS, the sokol_audio.h CoreAudio backend now\nuses the **AVAudioSession** class to activate and deactivate audio output as needed.\nThis fixes sokol_audio.h for iPhones (so far, sokol_audio.h accidentally only worked\nfor iPads). Please see [this issue](https://github.com/floooh/sokol/issues/431) for details.\nA somewhat unfortunate side effect of this fix is that sokol_audio.h must now be compiled\nas Objective-C when targeting iOS, also note that a new framework must be linked: ```AVFoundation```.\nMany thanks to @oviano for providing the PR!\n\n- **14-Feb-2021**: The Dear ImGui rendering backend in [sokol_imgui.h](https://github.com/floooh/sokol/blob/master/util/sokol_imgui.h) has been rewritten to only do a single\nbuffer-update per frame each for vertex- and index-data. This addresses performance-problems\nwith sg_append_buffer() in the GL backend on some platforms (see [this issue](https://github.com/floooh/sokol/issues/399) for details.\n\n- **13-Feb-2021**: A new utility header [sokol_nuklear.h](https://github.com/floooh/sokol/blob/master/util/sokol_nuklear.h)\nhas been added which implements a rendering backend for [Nuklear](https://github.com/Immediate-Mode-UI/Nuklear)\non top of sokol_gfx.h. Also see the new sample [nuklear-sapp](https://floooh.github.io/sokol-html5/nuklear-sapp.html).\nMany thanks to **@wmerrifield** for the PR!\n\n- **10-Feb-2021**: The breaking API-update has been merged (mainly sokol_gfx.h).\nPlease see [this blogpost](https://floooh.github.io/2021/02/07/sokol-api-overhaul.html)\nand the updates [sokol samples](https://floooh.github.io/sokol-html5/) for details.\nI also created a git tag named 'pre-feb2021-api-changes' which captures the previous\nstate in all related projects. Please also update the [sokol-tools-bin](https://github.com/floooh/sokol-tools-bin) if you're using the sokol-shdc shader compiler.\n\n- **07-Feb-2021**: A PSA about upcoming breaking changes in (mainly) sokol_gfx.h: https://floooh.github.io/2021/02/07/sokol-api-overhaul.html\n\n- **20-Dec-2020**: A couple of minor breaking changes in the sokol_gfx.h and\nsokol_app.h APIs as preparation for the upcoming automatic language binding\ngeneration:\n    - in **sokol_gfx.h** nested unions have been removed:\n        - **sg_image_desc.depth/.layers** has been renamed to **.num_slices**\n        - **sg_attachment_desc.face/.layer/.slice** has been unified to **.slice**\n    - in **sokol_app.h** the return value of **sapp_run()** has been changed from\n      **int** to **void** (the function always returned zero anyway)\n\n    Non-breaking (or at most potentially breaking) changes:\n    - expressions in enums have been replaced with integer literals (e.g. (1<<2) becomes 4)\n    - the value of **SAPP_MOUSEBUTTON_INVALID** has been changed from -1 to 0x100\n\n    For more information about the upcoming automatic language-bindings generation [see this bog post](https://floooh.github.io/2020/08/23/sokol-bindgen.html)\n\n- **02-Dec-2020**: sokol_gfx.h has a couple new public API functions for\ndestroying resources in two steps:\n    - sg_uninit_buffer + sg_dealloc_buffer\n    - sg_uninit_image + sg_dealloc_image\n    - sg_uninit_shader + sg_dealloc_shader\n    - sg_uninit_pipeline + sg_dealloc_pipeline\n    - sg_uninit_pass + sg_dealloc_pass\n\n    Calling both functions in this order is identical with calling the\n    traditional sg_destroy_xxx() functions. See this PR for more details:\n    https://github.com/floooh/sokol/pull/435. Many thanks to @oviano for the\n    PR!\n\n- **28-Nov-2020**: In addition to the generic SOKOL_API_DECL and SOKOL_IMPL\ndefines there are now header-specific versions SOKOL_xxx_API_DECL and\nSOKOL_xxx_IMPL (for instance SOKOL_GFX_API_DECL and SOKOL_GFX_IMPL). The\noriginal motivation for splitting the SOKOL_API_DECL defines up is described\nhere: https://github.com/floooh/sokol/issues/428). The same change for\nSOKOL_IMPL also finally unifies the approach used in the utility headers (in\nthe ```util``` subdirectory), which exclusively used the SOKOL_xxx_IMPL\npattern with the core headers which exclusively used SOKOL_IMPL before (all\nheaders accept both patterns now). Many thanks to @iboB for providing the\nAPI_DECL PR!\n\n- **17-Nov-2020**: A new utility header **sokol_shape.h** to generate\n  vertices+indices for simple shapes (plane, box, sphere, cylinder and torus),\n  which seamlessly plug into the sokol_gfx.h resource creation functions. As\n  with most new utility headers, the initial functionality is a bit bare bones\n  and the public API shouldn't be considered stable yet. Check the sokol-samples\n  webpage for new and updates samples: https://floooh.github.io/sokol-html5/\n\n- **08-Nov-2020** PSA: It appears that RenderDoc v1.10 chokes on the new\n  D3D11/DXGI swapchain code from 10-Oct-2020 in sokol_app.h. The current\n  RenderDoc Nightly Build works, so I guess in v1.11 everything will be fine.\n\n- **03-Nov-2020**: sokol_app.h: the missing drag'n'drop support for HTML5/WASM\n  has been added. This adds two platform-specific functions\n  ```sapp_html5_get_dropped_file_size()``` and\n  ```sapp_html5_fetch_dropped_file()```. Please read the documentation\n  section in sokol_app.h under 'DRAG AND DROP SUPPORT' for additional\n  details and example code. Also consult the source code of the new\n  ```droptest-sapp``` sample for an example of how to load the content\n  of dropped files on the web and native platforms:\n\n  https://floooh.github.io/sokol-html5/droptest-sapp.html\n\n\n- **27-Oct-2020**: I committed a bugfix for a longstanding WebGL canvas id versus\n  css-selector confusion in the emscripten/WASM backend code in sokol_app.h.\n  I think the fix should not require any changes in your code (because if\n  you'd be using a canvas name different from the default \"canvas\" it wouldn't\n  have worked before anyway). See this bug for details: https://github.com/floooh/sokol/issues/407\n\n- **22-Oct-2020**: sokol_app.h now has file drag'n'drop support on Win32,\n  macOS and Linux. WASM/HTML5 support will be added soon-ish. This will\n  work a bit differently because of security-related restrictions in the\n  HTML5 drag'n'drop API, but more on that later. For documentation,\n  search for 'DRAG AND DROP SUPPORT' in [sokol_app.h](https://github.com/floooh/sokol/blob/master/sokol_app.h).\n\n  Check out [events-sapp.c](https://github.com/floooh/sokol-samples/blob/master/sapp/events-sapp.cc)\n  for a simple usage example (I will also add a more real-world example to my\n  chips emulators once the WASM/HTML5 implementation is ready).\n\n  Many thanks for @prime31 and @hb3p8 for the initial PRs and valuable feature\n  discussions!\n\n- **10-Oct-2020**: Improvements to the sokol_app.h Win32+D3D11 and UWP+D3D11 swapchain code:\n  - In the Win32+D3D11 backend and when running on Win10,\n    ```DXGI_SWAP_EFFECT_FLIP_DISCARD``` is now used.  This gets rid of a\n    deprecation warning in the debugger console and also should allow slightly\n    more efficient swaps in some situations. When running on Win7 or Win8, the\n    traditional ```DXGI_SWAP_EFFECT_DISCARD``` is used.\n  - The UWP backend now supports MSAA multisampling (the required fixes for\n    this are the same as in the Win32 backend with the new swap effect: a\n    separate MSAA texture and render-target-view is created where\n    rendering goes into, and this MSAA texture is resolved into the actual\n    swapchain surface before presentation).\n\n- **07-Oct-2020**:\n    A fix in the ALSA/Linux backend initialization in sokol_audio.h: Previously,\n    initialization would fail if ALSA can't allocate the exact requested\n    buffer size. Instead sokol_audio.h let's now pick ALSA a suitable buffer\n    size. Also better log messages in the ALSA initialization code if something\n    goes wrong. Unfortunately I'm not able to reproduce the buffer allocation\n    problem on my Linux machine. Details are in this issue: https://github.com/floooh/sokol/issues/400\n\n    **NARRATOR**: the fix didn't work.\n\n- **02-Oct-2020**:\n    The sokol_app.h Win32 backend can now render while moving and resizing\n    the window. NOTE that resizing the swapchain buffers (and receiving\n    SAPP_EVENTTYPE_RESIZED events) is deferred until the resizing finished.\n    Resizing the swapchain buffers each frame created a substantial temporary\n    memory spike of up to several hundred MBytes. I need to figure out a better\n    swapchain resizing strategy.\n\n- **30-Sep-2020**:\n    sokol_audio.h now works on UWP, thanks again to Alberto Fustinoni\n    (@albertofustinoni) for the PR!\n\n- **26-Sep-2020**:\n    sokol_app.h gained a new function sapp_set_window_title() to change\n    the window title on Windows, macOS and Linux. Many thanks to\n    @medvednikov for the initial PR!\n\n- **23-Sep-2020**:\n    sokol_app.h now has initial UWP support using the C++/WinRT set of APIs.\n    Currently this requires \"bleeding edge\" tools: A recent VS2019 version,\n    and a very recent Windows SDK version (at least version 10.0.19041.0).\n    Furthermore the sokol_app.h implementation must be compiled as C++17\n    (this is a requirement of the C++/WinRT headers). Note that the Win32\n    backend will remain the primary and recommended backend on Windows. The UWP\n    backend should only be used when the Win32 backend is not an option.\n    The [sokol-samples](https://github.com/floooh/sokol-samples) project\n    has two new build configs ```sapp-uwp-vstudio-debug``` and\n    ```sapp-uwp-vstudio-release``` to build the sokol-app samples for UWP.\n\n    Many thanks to Alberto Fustinoni (@albertofustinoni) for providing\n    the initial PR!\n\n    (also NOTE: UWP-related fixes in other sokol headers will follow)\n\n- **22-Sep-2020**:\n    A small fix in sokol_app.h's Win32 backend: when a mouse button is pressed,\n    mouse input is now 'captured' by calling SetCapture(), and when the last\n    mouse button is released, ReleaseCapture() is called. This also provides\n    mouse events outside the window area as long as a mouse button is pressed,\n    which is useful for windowed UI applicactions (this is not the same as the\n    more 'rigorous' and explicit pointer-lock feature which is more useful for\n    camera-controls)\n\n- **31-Aug-2020**:\n    Internal change: The D3D11/DXGI backend code in sokol_gfx.h and sokol_app.h\n    now use the D3D11 and DXGI C++-APIs when the implementation is compiled as\n    C++, and the C-APIs when the implementation is compiled as C (before, the C\n    API was also used when the implementation is compiled as C++). The new\n    behaviour is useful when another header *must* use the D3D11/DXGI C++ APIs\n    but should be included in the same compilation unit as sokol_gfx.h an\n    sokol_app.h (for example see this PR:\n    https://github.com/floooh/sokol/pull/351).\n\n- **24-Aug-2020**:\n    The backend-specific callback functions that are provided to sokol_gfx.h\n    in the ```sg_setup()``` initialization call now have alternative\n    versions which accept a userdata-pointer argument. The userdata-free functions\n    still exist, so no changes are required for existing code.\n\n- **02-Aug-2020**:\n    - sokol_app.h now has a mouse-lock feature (aka pointer-lock) via two\n      new functions ```void sapp_lock_mouse(bool lock)``` and ```bool sapp_mouse_locked(void)```.\n      For documentation, please search for 'MOUSE LOCK' in sokol_app.h.\n      The sokol-app samples [events-sapp](https://floooh.github.io/sokol-html5/events-sapp.html)\n      and [cgltf-sapp](https://floooh.github.io/sokol-html5/cgltf-sapp.html) have been\n      updated to demonstrate the feature.\n    - sokol_app.h Linux: mouse pointer visibility (via ```void sapp_show_mouse(bool show)```)\n      has been implemented for Linux/X11\n    - sokol_app.h WASM: mouse wheel scroll deltas are now 'normalized' between\n      the different scroll modes (pixels, lines, pages). See this issue:\n      https://github.com/floooh/sokol/issues/339. Many thanks to @bqqbarbhg for\n      investigating the issue and providing a solution!\n    - sokol_app.h now has [better documentation](https://github.com/floooh/sokol/blob/89a3bb8da0a2df843d6cc60a270ddc69f9aa69d6/sokol_app.h#L70)\n      what system libraries must be linked on the various platforms (and on Linux two additional libraries must be\n      linked now: Xcursor and Xi)\n\n- **22-Jul-2020**: **PLEASE NOTE** cmake 3.18 breaks some of sokol samples when\n  compiling with the Visual Studio toolchain because some C files now actually\n  compile as C++ for some reason (see:\n  https://twitter.com/FlohOfWoe/status/1285996526117040128).  Until this is\n  fixed, or I have come up with a workaround, please use an older cmake version\n  to build the sokol samples with the Visual Studio compiler.\n\n  (Update: I have added a workaround to fips: https://github.com/floooh/fips/commit/89997b8ebdca6fc9455a5cfe6145eecaa017df49\n  which fixes the issue at least for fips projects)\n\n- **14-Jul-2020**:\n    - sapp_mouse_shown() has been implemented for macOS (thanks to @slmjkdbtl for\n      providing the initial PR!)\n    - On macOS, the lower-level functions CGDisplayShowCursor and CGDisplayHideCursor\n      are now used instead of the NSCursor class. This is in preparation for the\n      'pointer lock' feature which will also use CGDisplay* functions.\n    - Calling ```sapp_show_mouse(bool visible)``` no longer 'stacks' (e.g. there's\n      no 'hidden counter' underneath anymore, instead calling ```sapp_show_mouse(true)```\n      will always show the cursor and ```sapp_show_mouse(false)``` will always\n      hide it. This is a different behaviour than the underlying Win32 and\n      macOS functions ShowCursor() and CGDisplaShow/HideCursor()\n    - The mouse show/hide behaviour can now be tested in the ```events-sapp``` sample\n      (so far this only works on Windows and macOS).\n\n- **13-Jul-2020**:\n    - On macOS and iOS, sokol_app.h and sokol_gfx.h can now be compiled with\n      ARC (Automatic Reference Counting) **disabled** (previously ARC had to be\n      enabled).\n    - Compiling with ARC enabled is still supported but with a little caveat:\n      if you're compiling sokol_app.h or sokol_gfx.h in ObjC mode (not ObjC++\n      mode) *AND* ARC is enabled, then the Xcode version must be more recent\n      than before (the language feature ```__has_feature(objc_arc_fields)```\n      must be supported, which I think has been added in Xcode 10.2, I couldn't\n      find this mentioned in any Xcode release notes though). Compiling with\n      ARC disabled should also work on older Xcode versions though.\n    - Various internal code cleanup things:\n        - sokol_app.h had the same 'structural cleanup' as sokol_gfx.h in\n          January, all internal state (including ObjC id's) has been merged into\n          a single big state structure. Backend specific struct declarations\n          have been moved closer together in the header, and\n          backend-specific structures and functions have been named more\n          consistently for better 'searchability'\n        - The 'mini GL' loader in the sokol_app.h Win32+WGL backend has been\n          rewritten to use X-Macros (less redundant lines of code)\n        - All macOS and iOS code has been revised and cleaned up\n        - On macOS a workaround for a (what looks like) post-Catalina\n          NSOpenGLView issue has been added: if the sokol_app.h window doesn't\n          fit on screen (and was thus 'clamped' by Cocoa) *AND* the\n          content-size was not set to native Retina resolution, the initial\n          content size was reported as if it was in Retina resolution. This\n          caused an empty screen to be rendered in the imgui-sapp demo. The\n          workaround is to hook into the NSOpenGLView reshape event at which\n          point the reported content size is correct.\n        - On macOS and iOS, the various 'view delegate' objects have been\n          removed, and rendering happens instead in the subclasses of MTKView,\n          GLKView and NSOpenGLView.\n        - On macOS and iOS, there's now proper cleanup code in the\n          applicationWillTerminate callback (although note that on iOS this\n          function isn't guaranteed to be called, because an application can\n          also simply be killed by the operating system.\n\n- **22-Jun-2020**: The X11/GLX backend in sokol_app.h now has (soft-)fullscreen\nsupport, bringing the feature on par with Windows and macOS. Many thanks to\n@medvednikov for the PR!\n\n- **20-Jun-2020**: Some work to better support older DX10-level GPUs in the\nsokol_gfx.h D3D11 backend:\n    - sg_make_shader() now by default compiles HLSL shader code as shader model 4.0\n      (previously shader model 5.0 which caused problems with some older\n      Intel GPUs still in use, see this issue: https://github.com/floooh/sokol/issues/179)\n    - A new string item ```const char* d3d11_target``` in ```sg_shader_stage_desc``` now allows\n      to pass in the D3D shader model for compiling shaders. This defaults to\n      \"vs_4_0\" for the vertex shader stage and \"ps_4_0\" for the fragment shader stage.\n      The minimal DX shader model for use with the sokol_gfx.h D3D11 backend is\n      shader model 4.0, because that's the first shader model supporting\n      constant buffers.\n    - The *sokol-shdc* shader compiler tool has a new output option ```hlsl4```\n      to generate HLSL4 source code and shader model 4.0 byte code.\n    - All embedded D3D shader byte code in the sokol utility headers has been\n      changed from shader model 5.0 to 4.0\n\n    If you are using sokol_gfx.h with sokol-shdc, please update both at the same time\n    to avoid compilation errors caused by the new ```sg_shader_stage_desc.d3d11_target```\n    item. The sg_shader_desc initialization code in sokol-shdc has now been made more\n    robust to prevent similar problems in the future.\n\n- **14-Jun-2020**: I have added a very simple utility header ```sokol_memtrack.h```\nwhich allows to track memory allocations in sokol headers (number and overall\nsize of allocations) by overriding the macros SOKOL_MALLOC, SOKOL_CALLOC and\nSOKOL_FREE. Simply include ```sokol_memtrack.h``` before the other sokol\nheader implementation includes to enable memory tracking in those headers\n(but remember that the sokol_memtrack.h implementation must only be included\nonce in the whole project, so this only works when all other sokol header\nimplementations are included in the same compilation unit).\n\n- **06-Jun-2020**: Some optimizations in the sokol_gfx.h GL backend to avoid\n  redundant GL calls in two areas: in the sg_begin_pass() calls when not\n  clearing the color- and depth-stencil-attachments, and in sg_apply_bindings()\n  when binding textures.  Everything should behave exactly as before, but if\n  you notice any problems in those areas, please file a bug. Many thanks to\n  @edubart for the PRs!\n\n- **01-Jun-2020**: sokol_app.h now allows to toggle to and from fullscreen\nprogrammatically and to query the current fullscreen state via 2 new\nfunctions: ```sapp_toggle_fullscreen()``` and ```sapp_is_fullscreen()```.\nCurrently this is only implemented for Windows and macOS (not Linux).\nThanks to @mattiasljungstrom for getting the feature started and providing\nthe Win32 implementation!\n\n- **28-May-2020**: a small quality-of-life improvement for C++ coders: when the\nsokol headers are included into C++, all public API functions which take a\npointer to a struct now have a C++ overload which instead takes a const-ref.\nThis allows to move the struct initialization right into the function call\njust like in C99. For instance, in C99 one can write:\n    ```c\n    sg_buffer buf = sg_make_buffer(&(sg_buffer_desc){\n        .size = sizeof(vertices),\n        .type = SG_BUFFERTYPE_VERTEXBUFFER,\n        .content = vertices\n    });\n    ```\n    In C++ it isn't possible to take the address of an 'adhoc-initialized'\n    struct like this, but with the new reference-wrapper functions (and C++20\n    designated initialization) this should work now:\n    ```cpp\n    sg_buffer buf = sg_make_buffer({\n        .size = sizeof(vertices),\n        .type = SG_BUFFERTYPE_VERTEXBUFFER,\n        .content = vertices\n    });\n    ```\n    Many thanks to @garettbass for providing the PR!\n\n\n- **27-May-2020**: a new utility header [sokol_debugtext.h](https://github.com/floooh/sokol/blob/master/util/sokol_debugtext.h)\nfor rendering simple ASCII text using vintage home computer fonts via sokol_gfx.h\n\n- **13-May-2020**: a new function in sokol_time.h to round a measured frame time\nto common display refresh rates: ```stm_round_to_common_refresh_rate()```.\nSee the header documentation for the motivation behind this function.\n\n- **02-May-2020**: sokol_app.h: the 'programmatic quit' behaviour on the\nweb-platform is now more in line with other platforms: calling\n```sapp_quit()``` will invoke the cleanup callback function, perform\nplatform-specific cleanup (like unregistering JS event handlers), and finally\nexit the frame loop. In typical scenarios this isn't very useful (because\nusually the user will simply close the tab, which doesn't allow to run\ncleanup code), but it's useful for situations where the same\ncode needs to run repeatedly on a web page. Many thanks to @caiiiycuk\nfor providing the PR!\n\n- **30-Apr-2020**: experimental WebGPU backend and a minor breaking change:\n    - sokol_gfx.h: a new WebGPU backend, expect frequent breakage for a while\n      because the WebGPU API is still in flux\n    - a new header sokol_glue.h, with interop helper functions when specific combinations\n      of sokol headers are used together\n    - changes in the way sokol_gfx.h is initialized via a new layout of the\n      sg_desc structure\n    - sokol_gfx.h: a new ```sg_sampler_type``` enum which is required for\n      shader creation to tell the WebGPU backend about the sampler data types\n      (float, signed int, or unsigned int) used in the shader\n    - sokol_app.h: a handful new functions to query default framebuffer attributes (color- and\n      depth-buffer pixel formats, and MSAA sample count)\n    - sokol_app.h: WebGPU device and swapchain initialization (currently only\n      in the emscripten code path)\n    - [sokol-shdc](https://github.com/floooh/sokol-tools/blob/master/docs/sokol-shdc.md) has\n      been updated with WebGPU support (currently outputs SPIRV bytecode), and to output the new\n      ```sg_sampler_type``` enum in ```sg_shader_image_desc```\n    - [sokol-samples](https://github.com/floooh/sokol-samples/) has a new set of\n      backend-specific WebGPU samples, and the other samples have been updated\n      for the new sokol-gfx initialization\n    - ```pre-webgpu``` tags have been added to the [sokol](https://github.com/floooh/sokol/releases/tag/pre-webgpu), [sokol-samples](https://github.com/floooh/sokol-samples/releases/tag/pre-webgpu), [sokol-tools](https://github.com/floooh/sokol-tools/releases/tag/pre-webgpu)\n      and [sokol-tools-bin](https://github.com/floooh/sokol-tools-bin/releases/tag/pre-webgpu) github repositories (in case you need to continue working with\n      the older versions)\n    - please see this [blog post](https://floooh.github.io/2020/04/26/sokol-spring-2020-update.html)\n      for more details\n\n- **05-Apr-2020**: A bugfix in sokol_gl.h, the (fairly recent) optimization for\n    merging draw calls contained a bug that could be triggered in an \"empty\"\n    sgl_begin/sgl_end pair (with no vertices recorded inbetween). This could\n    lead to the following draw call being rendered with the wrong uniform data.\n\n- **30-Jan-2020**: Some cleanup in sokol_gfx.h in the backend implementation code,\n    internal data structures and documentation comments. The public\n    API hasn't changed, so the change should be completely invisible\n    from the outside.\n\n- **02-Dec-2019**: Initial clipboard support in sokol_app.h for Windows, macOS\n    and HTML5. This allows to read and write UTF-8 encoded strings from and\n    to the target platform's shared clipboard.\n\n    A 'real-world' example usage is in the [Visual6502 Remix project](https://github.com/floooh/v6502r).\n\n    Unfortunately clipboard support on the HTML5 platform comes with a lot of\n    platform-specific caveats which can't be solved in sokol_app.h alone\n    because of the restrictions the web platform puts on clipboard access and\n    different behaviours and support levels of the various HTML5 clipboard\n    APIs. I'm not really happy with the current HTML5 clipboard\n    implementation. It sorta works, but it sure ain't pretty :)\n\n    Maybe the situation will improve in a few years when all browsers agree\n    on and support the new [permission-based clipboard\n    API](https://developer.mozilla.org/en-US/docs/Web/API/Clipboard_API).\n\n    For documentation of the clipboard feature, search for CLIPBOARD SUPPORT\n    in sokol_app.h\n\n- **08-Sep-2019**: sokol_gfx.h now supports clamp-to-border texture sampling:\n    - the enum ```sg_wrap``` has a new member ```SG_WRAP_CLAMP_TO_BORDER```\n    - there's a new enum ```sg_border_color```\n    - the struct ```sg_image_desc``` has a new member ```sg_border_color border_color```\n    - new feature flag in ```sg_features```: ```image_clamp_to_border```\n\n  Note the following caveats:\n\n    - clamp-to-border is only supported on a subset of platforms, support can\n    be checked at runtime via ```sg_query_features().image_clamp_to_border```\n    (D3D11, desktop-GL and macOS-Metal support clamp-to-border,\n    all other platforms don't)\n    - there are three hardwired border colors: transparent-black,\n    opaque-black and opaque-white (modern 3D APIs have moved away from\n    a freely programmable border color)\n    - if clamp-to-border is not supported, sampling will fall back to\n    clamp-to-edge without a validation warning\n\n  Many thanks to @martincohen for suggesting the feature and providing the initial\nD3D11 implementation!\n\n- **31-Aug-2019**: The header **sokol_gfx_cimgui.h** has been merged into\n[**sokol_gfx_imgui.h**](https://github.com/floooh/sokol/blob/master/util/sokol_gfx_imgui.h).\nSame idea as merging sokol_cimgui.h into sokol_imgui.h, the implementation\nis now \"bilingual\", and can either be included into a C++ file or into a C file.\nWhen included into a C++ file, the Dear ImGui C++ API will be called directly,\notherwise the C API bindings via cimgui.h\n\n- **28-Aug-2019**: The header **sokol_cimgui.h** has been merged into\n[**sokol_imgui.h**](https://github.com/floooh/sokol/blob/master/util/sokol_imgui.h).\nThe sokol_cimgui.h header had been created to implement Dear ImGui UIs from\npure C applications, instead of having to fall back to C++ just for the UI\ncode. However, there was a lot of code duplication between sokol_imgui.h and\nsokol_cimgui.h, so that it made more sense to merge the two headers. The C vs\nC++ code path will be selected automatically: When the implementation of\nsokol_imgui.h is included into a C++ source file, the Dear ImGui C++ API will\nbe used. Otherwise, when the implementation is included into a C source file,\nthe C API via cimgui.h\n\n- **27-Aug-2019**: [**sokol_audio.h**](https://github.com/floooh/sokol/blob/master/sokol_audio.h)\n  now has an OpenSLES backend for Android. Many thanks to Sepehr Taghdisian (@septag)\n  for the PR!\n\n- **26-Aug-2019**: new utility header for text rendering, and fixes in sokol_gl.h:\n    - a new utility header [**sokol_fontstash.h**](https://github.com/floooh/sokol/blob/master/util/sokol_fontstash.h)\n      which implements a renderer for [fontstash.h](https://github.com/memononen/fontstash)\n      on top of sokol_gl.h\n    - **sokol_gl.h** updates:\n        - Optimization: If no relevant state between two begin/end pairs has\n        changed, draw commands will be merged into a single sokol-gfx draw\n        call. This is especially useful for text- and sprite-rendering (previously,\n        each begin/end pair would always result in one draw call).\n        - Bugfix: When calling sgl_disable_texture() the previously active\n        texture would still remain active which could lead to rendering\n        artefacts. This has been fixed.\n        - Feature: It's now possible to provide a custom shader in the\n        'desc' argument of *sgl_make_pipeline()*, as long as the shader\n        is \"compatible\" with sokol_gl.h, see the sokol_fontstash.h\n        header for an example. This feature isn't \"advertised\" in the\n        sokol_gl.h documentation because it's a bit brittle (for instance\n        if sokol_gl.h updates uniform block structures, custom shaders\n        would break), but it may still come in handy in some situations.\n\n- **20-Aug-2019**: sokol_gfx.h has a couple new query functions to inspect the\n  default values of resource-creation desc structures:\n\n    ```c\n    sg_buffer_desc sg_query_buffer_defaults(const sg_buffer_desc* desc);\n    sg_image_desc sg_query_image_defaults(const sg_image_desc* desc);\n    sg_shader_desc sg_query_shader_defaults(const sg_shader_desc* desc);\n    sg_pipeline_desc sg_query_pipeline_defaults(const sg_pipeline_desc* desc);\n    sg_pass_desc sg_query_pass_defaults(const sg_pass_desc* desc);\n    ```\n  These functions take a pointer to a resource creation desc struct that\n  may contain zero-initialized values (to indicate default values) and\n  return a new struct where the zero-init values have been replaced with\n  concrete values. This is useful to inspect the actual creation attributes\n  of a resource.\n\n- **18-Aug-2019**:\n    - Pixelformat and runtime capabilities modernization in sokol_gfx.h (breaking changes):\n        - The list of pixel formats supported in sokol_gfx.h has been modernized,\n          many new formats are available, and some formats have been removed. The\n          supported pixel formats are now identical with what WebGPU provides,\n          minus the SRGB formats (if SRGB conversion is needed it should be done\n          in the pixel shader)\n        - The pixel format list is now more \"orthogonal\":\n            - one, two or four color components (R, RG, RGBA)\n            - 8-, 16- or 32-bit component width\n            - unsigned-normalized (no postfix), signed-normalized (SN postfix),\n              unsigned-integer (UI postfix) and signed-integer (SI postfix)\n              and float (F postfix) component types.\n            - special pixel formats BGRA8 (default render target format on\n              Metal and D3D11), RGB10A2 and RG11B10F\n            - DXT compressed formats replaced with BC1 to BC7 (BC1 to BC3\n              are identical to the old DXT pixel formats)\n            - packed 16-bit formats (like RGBA4) have been removed\n            - packed 24-bit formats (RGB8) have been removed\n        - Use the new function ```sg_query_pixelformat()``` to get detailed\n          runtime capability information about a pixelformat (for instance\n          whether it is supported at all, can be used as render target etc...).\n        - Use the new function ```sg_query_limits()``` to query \"numeric limits\"\n          like maximum texture dimensions for different texture types.\n        - The enumeration ```sg_feature``` and the function ```sg_query_feature()```\n          has been replaced with the new function ```sg_query_features()```, which\n          returns a struct ```sg_features``` (this contains a bool for each\n          optional feature).\n        - The default pixelformat for render target images and pipeline objects\n          now depends on the backend:\n            - for GL backends, the default pixelformat stays the same: RGBA8\n            - for the Metal and D3D11 backends, the default pixelformat for\n            render target images is now BGRA8 (the reason is because\n            MTKView's pixelformat was always BGRA8 but this was \"hidden\"\n            through an internal hack, and a BGRA swapchain is more efficient\n            than RGBA in D3D11/DXGI)\n        - Because of the above RGBA/BGRA change, you may see pixelformat validation\n          errors in existing code if the code assumes that a render target image is\n          always created with a default pixelformat of RGBA8.\n    - Changes in sokol_app.h:\n        - The D3D11 backend now creates the DXGI swapchain with BGRA8 pixelformat\n          (previously: RGBA8), this allows more efficient presentation in some\n          situations since no format-conversion-blit needs to happen.\n\n- **18-Jul-2019**:\n    - sokol_fetch.h has been fixed and can be used again :)\n\n- **11-Jul-2019**:\n    - Don't use sokol_fetch.h for now, the current version assumes that\n      it is possible to obtain the content size of a file from the\n      HTTP server without downloading the entire file first. Turns out\n      that's not possible with vanilla HTTP when the web server serves\n      files compressed (in that case the Content-Length is the _compressed_\n      size, yet JS/WASM only has access to the uncompressed data).\n      Long story short, I need to go back to the drawing board :)\n\n- **06-Jul-2019**:\n    - new header [sokol_fetch.h](https://github.com/floooh/sokol/blob/master/sokol_fetch.h) for asynchronously loading data.\n        - make sure to carefully read the embedded documentation\n        for making the best use of the header\n        - two new samples: [simple PNG file loadng with stb_image.h](https://floooh.github.io/sokol-html5/loadpng-sapp.html) and  [MPEG1 streaming with pl_mpeg.h](https://floooh.github.io/sokol-html5/plmpeg-sapp.html)\n    - sokol_gfx.h: increased SG_MAX_SHADERSTAGE_BUFFERS configuration\n    constant from 4 to 8.\n\n- **10-Jun-2019**: sokol_app.h now has proper \"application quit handling\":\n    - a pending quit can be intercepted, for instance to show a \"Really Quit?\" dialog box\n    - application code can now initiate a \"soft quit\" (interceptable) or\n      \"hard quit\" (not interceptable)\n    - on the web platform, the standard \"Leave Site?\" dialog box implemented\n      by browsers can be shown when the user leaves the site\n    - Android and iOS currently don't have any of those features (since the\n      operating system may decide to terminate mobile applications at any time\n      anyway, if similar features are added they will most likely have\n      similar limitations as the web platform)\n  For details, search for 'APPLICATION QUIT' in the sokol_app.h documentation\n  header: https://github.com/floooh/sokol/blob/master/sokol_app.h\n\n  The [imgui-highdpi-sapp](https://github.com/floooh/sokol-samples/tree/master/sapp)\n  contains sample code for all new quit-related features.\n\n- **08-Jun-2019**: some new stuff in sokol_app.h:\n    - the ```sapp_event``` struct has a new field ```bool key_repeat```\n    which is true when a keyboard event is a key-repeat (for the\n    event types ```SAPP_EVENTTYPE_KEY_DOWN``` and ```SAPP_EVENTTYPE_CHAR```).\n    Many thanks to [Scott Lembcke](https://github.com/slembcke) for\n    the pull request!\n    - a new function to poll the internal frame counter:\n    ```uint64_t sapp_frame_count(void)```, previously the frame counter\n    was only available via ```sapp_event```.\n    - also check out the new [event-inspector sample](https://floooh.github.io/sokol-html5/wasm/events-sapp.html)\n\n- **04-Jun-2019**: All sokol headers now recognize a config-define ```SOKOL_DLL```\n  if sokol should be compiled into a DLL (when used with ```SOKOL_IMPL```)\n  or used as a DLL. On Windows, this will prepend the public function declarations\n  with ```__declspec(dllexport)``` or ```__declspec(dllimport)```.\n\n- **31-May-2019**: if you're working with emscripten and fips, please note the\n  following changes:\n\n    https://github.com/floooh/fips#public-service-announcements\n\n- **27-May-2019**: some D3D11 updates:\n    - The shader-cross-compiler can now generate D3D bytecode when\n    running on Windows, see the [sokol-shdc docs](https://github.com/floooh/sokol-tools/blob/master/docs/sokol-shdc.md) for more\ndetails.\n    - sokol_gfx.h no longer needs to be compiled with a\n    SOKOL_D3D11_SHADER_COMPILER define to enable shader compilation in the\n    D3D11 backend. Instead, the D3D shader compiler DLL (d3dcompiler_47.dll)\n    will be loaded on-demand when the first HLSL shader needs to be compiled.\n    If an application only uses D3D shader byte code, the compiler DLL won't\n    be loaded into the process.\n\n- **24-May-2019** The shader-cross-compiler can now generate Metal byte code\nfor macOS or iOS when the build is running on macOS. This is enabled\nautomatically with the fips-integration files in [sokol-tools-bin](https://github.com/floooh/sokol-tools-bin),\nsee the [sokol-shdc docs](https://github.com/floooh/sokol-tools/blob/master/docs/sokol-shdc.md) for more\ndetails.\n\n- **16-May-2019** two new utility headers: *sokol_cimgui.h* and *sokol_gfx_cimgui.h*,\nthose are the same as their counterparts sokol_imgui.h and sokol_gfx_imgui.h, but\nuse the [cimgui](https://github.com/cimgui/cimgui) C-API for Dear ImGui. This\nis useful if you don't want to - or cannot - use C++ for creating Dear ImGui UIs.\n\n    Many thanks to @prime31 for contributing those!\n\n    sokol_cimgui.h [is used\nhere](https://floooh.github.io/sokol-html5/wasm/cimgui-sapp.html), and\nsokol_gfx_cimgui.h is used for the [debugging UI\nhere](https://floooh.github.io/sokol-html5/wasm/sgl-microui-sapp-ui.html)\n\n- **15-May-2019** there's now an optional shader-cross-compiler solution for\nsokol_gfx.h: [see here for details](https://github.com/floooh/sokol-tools/blob/master/docs/sokol-shdc.md).\nThis is \"V1.0\" with two notable features missing:\n\n    - an include-file feature for GLSL shaders\n    - compilation to Metal- and D3D-bytecode (currently\n      only source-code generation is supported)\n\n    The [sokol-app samples](https://floooh.github.io/sokol-html5/) have been\n    ported to the new shader-cross-compilation, follow the ```src``` and\n    ```glsl``` links on the specific sample webpages to see the C- and GLSL-\n    source-code.\n\n- **02-May-2019** sokol_gfx.h has a new function ```sg_query_backend()```, this\nwill return an enum ```sg_backend``` identifying the backend sokol-gfx is\ncurrently running on, which is one of the following values:\n\n    - SG_BACKEND_GLCORE33\n    - SG_BACKEND_GLES2\n    - SG_BACKEND_GLES3\n    - SG_BACKEND_D3D11\n    - SG_BACKEND_METAL_MACOS\n    - SG_BACKEND_METAL_IOS\n\n    When compiled with SOKOL_GLES3, sg_query_backend() may return SG_BACKEND_GLES2\n    when the runtime platform doesn't support GLES3/WebGL2 and had to fallback\n    to GLES2/WebGL2.\n\n    When compiled with SOKOL_METAL, sg_query_backend() will return SG_BACKEND_METAL_MACOS\n    when the compile target is macOS, and SG_BACKEND_METAL_IOS when the target is iOS.\n\n- **26-Apr-2019** Small but breaking change in **sokol_gfx.h** how the vertex\nlayout definition in sg_pipeline_desc works:\n\n    Vertex component names and semantics (needed by the GLES2 and D3D11 backends) have moved from ```sg_pipeline_desc``` into ```sg_shader_desc```.\n\n    This may seem like a rather pointless small detail to change, especially\n    for breaking existing code, but the whole thing will make a bit more\n    sense when the new shader-cross-compiler will be integrated which I'm\n    currently working on (here: https://github.com/floooh/sokol-tools).\n\n    While working on getting reflection data out of the shaders (e.g. what\n    uniform blocks and textures the shader uses), it occurred to me that\n    vertex-attribute-names and -semantics are actually part of the reflection\n    info and belong to the shader, not to the vertex layout in the pipeline\n    object (which only describes how the incoming vertex data maps to\n    vertex-component **slots**. Instead of (optionally) mapping this\n    association through a name, the pipeline's vertex layout is now always\n    strictly defined in terms of numeric 'bind slots' for **all** sokol_gfx.h\n    backends. For 3D APIs where the vertex component slot isn't explicitly\n    defined in the shader language (GLES2/WebGL, D3D11, and optionally\n    GLES3/GL), the shader merely offers a lookup table how vertex-layout\n    slot-indices map to names/semantics (and the underlying 3D API than maps\n    those names back to slot indices, which shows that Metal and GL made the\n    right choice defining the slots right in the shader).\n\n    Here's how the code changes (taken from the triangle-sapp.c sample):\n\n    **OLD**:\n    ```c\n    /* create a shader */\n    sg_shader shd = sg_make_shader(&(sg_shader_desc){\n        .vs.source = vs_src,\n        .fs.source = fs_src,\n    });\n\n    /* create a pipeline object (default render states are fine for triangle) */\n    pip = sg_make_pipeline(&(sg_pipeline_desc){\n        /* if the vertex layout doesn't have gaps, don't need to provide strides and offsets */\n        .shader = shd,\n        .layout = {\n            .attrs = {\n                [0] = { .name=\"position\", .sem_name=\"POS\", .format=SG_VERTEXFORMAT_FLOAT3 },\n                [1] = { .name=\"color0\", .sem_name=\"COLOR\", .format=SG_VERTEXFORMAT_FLOAT4 }\n            }\n        },\n    });\n    ```\n\n    **NEW**:\n    ```c\n        /* create a shader */\n        sg_shader shd = sg_make_shader(&(sg_shader_desc){\n            .attrs = {\n                [0] = { .name=\"position\", .sem_name=\"POS\" },\n                [1] = { .name=\"color0\", .sem_name=\"COLOR\" }\n            },\n            .vs.source = vs_src,\n            .fs.source = fs_src,\n        });\n\n        /* create a pipeline object (default render states are fine for triangle) */\n        pip = sg_make_pipeline(&(sg_pipeline_desc){\n            /* if the vertex layout doesn't have gaps, don't need to provide strides and offsets */\n            .shader = shd,\n            .layout = {\n                .attrs = {\n                    [0].format=SG_VERTEXFORMAT_FLOAT3,\n                    [1].format=SG_VERTEXFORMAT_FLOAT4\n                }\n            },\n        });\n    ```\n\n    ```sg_shader_desc``` has a new embedded struct ```attrs``` which\n    contains a vertex attribute _name_ (for GLES2/WebGL) and\n    _sem_name/sem_index_ (for D3D11). For the Metal backend this struct is\n    ignored completely, and for GLES3/GL it is optional, and not required\n    when the vertex shader inputs are annotated with ```layout(location=N)```.\n\n    The remaining attribute description members in ```sg_pipeline_desc``` are:\n    - **.format**: the format of input vertex data (this can be different\n          from the vertex shader's inputs when data is extended during\n          vertex fetch (e.g. input can be vec3 while the vertex shader\n          expects vec4)\n    - **.offset**: optional offset of the vertex component data (not needed\n          when the input vertex has no gaps between the components)\n    - **.buffer**: the vertex buffer bind slot if the vertex data is coming\n          from different buffers\n\n    Also check out the various samples:\n\n    - for GLSL (explicit slots via ```layout(location=N)```): https://github.com/floooh/sokol-samples/tree/master/glfw\n    - for D3D11 (semantic names/indices): https://github.com/floooh/sokol-samples/tree/master/d3d11\n    - for GLES2: (vertex attribute names): https://github.com/floooh/sokol-samples/tree/master/html5\n    - for Metal: (explicit slots): https://github.com/floooh/sokol-samples/tree/master/metal\n    - ...and all of the above combined: https://github.com/floooh/sokol-samples/tree/master/sapp\n\n- **19-Apr-2019** I have replaced the rather inflexible render-state handling\nin **sokol_gl.h** with a *pipeline stack* (like the GL matrix stack, but with\npipeline-state-objects), along with a couple of other minor API tweaks.\n\n    These are the new pipeline-stack functions:\n    ```c\n    sgl_pipeline sgl_make_pipeline(const sg_pipeline_desc* desc);\n    void sgl_destroy_pipeline(sgl_pipeline pip);\n    void sgl_default_pipeline(void);\n    void sgl_load_pipeline(sgl_pipeline pip);\n    void sgl_push_pipeline(void);\n    void sgl_pop_pipeline(void);\n    ```\n\n    A pipeline object is created just like in sokol_gfx.h, but without shaders,\n    vertex layout, pixel formats, primitive-type and sample count (these details\n    are filled in by the ```sgl_make_pipeline()``` wrapper function. For instance\n    to create a pipeline object for additive transparency:\n\n    ```c\n    sgl_pipeline additive_pip = sgl_make_pipeline(&(sg_pipeline_desc){\n        .blend = {\n            .enabled = true,\n            .src_factor_rgb = SG_BLENDFACTOR_ONE,\n            .dst_factor_rgb = SG_BLENDFACTOR_ONE\n        }\n    });\n    ```\n\n    And to render with this, simply call ```sgl_load_pipeline()```:\n\n    ```c\n    sgl_load_pipeline(additive_pip);\n    sgl_begin_triangles();\n    ...\n    sgl_end();\n    ```\n\n    Or to preserve and restore the previously active pipeline state:\n\n    ```c\n    sgl_push_pipeline();\n    sgl_load_pipeline(additive_pip);\n    sgl_begin_quads();\n    ...\n    sgl_end();\n    sgl_pop_pipeline();\n    ```\n\n    You can also load the 'default pipeline' explicitly on the top of the\n    pipeline stack with ```sgl_default_pipeline()```.\n\n    The other API change is:\n\n    - ```sgl_state_texture(bool b)``` has been replaced with ```sgl_enable_texture()```\n      and ```sgl_disable_texture()```\n\n    The code samples have been updated accordingly:\n\n    - [sgl-sapp.c](https://github.com/floooh/sokol-samples/blob/master/sapp/sgl-sapp.c)\n    - [sgl-lines-sapp.c](https://github.com/floooh/sokol-samples/blob/master/sapp/sgl-lines-sapp.c)\n    - [sgl-microui-sapp.c](https://github.com/floooh/sokol-samples/blob/master/sapp/sgl-microui-sapp.c)\n\n- **01-Apr-2019** (not an April Fool's joke): There's a new **sokol_gl.h**\nutil header which implements an 'OpenGL-1.x-in-spirit' rendering API on top\nof sokol_gfx.h (vertex specification via begin/end, and a matrix stack). This is\nonly a small subset of OpenGL 1.x, mainly intended for debug-visualization or\nsimple tasks like 2D UI rendering. As always, sample code is in the\n[sokol-samples](https://github.com/floooh/sokol-samples) project.\n\n- **15-Mar-2019**: various Dear ImGui related changes:\n    - there's a new utility header sokol_imgui.h with a simple drop-in\n      renderer for Dear ImGui on top of sokol_gfx.h and sokol_app.h\n      (sokol_app.h is optional, and only used for input handling)\n    - the sokol_gfx_imgui.h debug inspection header no longer\n      depends on internal data structures and functions of sokol_gfx.h, as such\n      it is now a normal *utility header* and has been moved to the *utils*\n      directory\n    - the implementation macro for sokol_gfx_imgui.h has been changed\n      from SOKOL_IMPL to SOKOL_GFX_IMGUI_IMPL (so when you suddenly get\n      unresolved linker errors, that's the reason)\n    - all headers now have two preprocessor defines for the declaration\n      and implementation (for instance in sokol_gfx.h: SOKOL_GFX_INCLUDED\n      and SOKOL_GFX_IMPL_INCLUDED) these are checked in the utility-headers\n      to provide useful error message when dependent headers are missing\n\n- **05-Mar-2019**: sokol_gfx.h now has a 'trace hook' API, and I have started\nimplementing optional debug-inspection-UI headers on top of Dear ImGui:\n    - sokol_gfx.h has a new function *sg_install_trace_hooks()*, this allows\n      you to install a callback function for each public sokol_gfx.h function\n      (and a couple of error callbacks). For more details, search for \"TRACE HOOKS\"\n      in sokol_gfx.h\n    - when creating sokol_gfx.h resources, you can now set a 'debug label'\n      in the desc structure, this is ignored by sokol_gfx.h itself, but is\n      useful for debuggers or profilers hooking in via the new trace hooks\n    - likewise, two new functions *sg_push_debug_group()* and *sg_pop_debug_group()*\n      can be used to group related drawing functions under a name, this\n      is also ignored by sokol_gfx.h itself and only useful when hooking\n      into the API calls\n    - I have started a new 'subproject' in the 'imgui' directory, this will\n      contain a slowly growing set of optional debug-inspection-UI headers\n      which allow to peek under the hood of the Sokol headers. The UIs are\n      implemented with [Dear ImGui](https://github.com/ocornut/imgui). Again,\n      see the README in the 'imgui' directory and the headers in there\n      for details, and check out the live demos on the [Sokol Sample Webpage](https://floooh.github.io/sokol-html5/)\n      (click on the little UI buttons in the top right corner of each thumbnail)\n\n- **21-Feb-2019**: sokol_app.h and sokol_audio.h now have an alternative\nset of callbacks with user_data arguments. This is useful if you don't\nwant or cannot store your own application state in global variables.\nSee the header documentation in sokol_app.h and sokol_audio.h for details,\nand check out the samples *sapp/noentry-sapp.c* and *sapp/modplay-sapp.c*\nin https://github.com/floooh/sokol-samples\n\n- **19-Feb-2019**: sokol_app.h now has an alternative mode where it doesn't\n\"hijack\" the platform's main() function. Search for SOKOL_NO_ENTRY in\nsokol_app.h for details and documentation.\n\n- **26-Jan-2019**: sokol_app.h now has an Android backend contributed by\n  [Gustav Olsson](https://github.com/gustavolsson)!\n  See the [sokol-samples readme](https://github.com/floooh/sokol-samples/blob/master/README.md)\n  for build instructions.\n\n- **21-Jan-2019**: sokol_gfx.h - pool-slot-generation-counters and a dummy backend:\n    - Resource pool slots now have a generation-counter for the resource-id\n      unique-tag, instead of a single counter for the whole pool. This allows\n      to create many more unique handles.\n    - sokol_gfx.h now has a dummy backend, activated by defining SOKOL_DUMMY_BACKEND\n      (instead of SOKOL_METAL, SOKOL_D3D11, ...), this allows to write\n      'headless' tests (and there's now a sokol-gfx-test in the sokol-samples\n      repository which mainly tests the resource pool system)\n\n- **12-Jan-2019**: sokol_gfx.h - setting the pipeline state and resource\nbindings now happens in separate calls, specifically:\n    - *sg_apply_draw_state()* has been replaced with *sg_apply_pipeline()* and\n    *sg_apply_bindings()*\n    - the *sg_draw_state* struct has been replaced with *sg_bindings*\n    - *sg_apply_uniform_block()* has been renamed to *sg_apply_uniforms()*\n\nAll existing code will still work. See [this blog\npost](https://floooh.github.io/2019/01/12/sokol-apply-pipeline.html) for\ndetails.\n\n- **29-Oct-2018**:\n    - sokol_gfx.h has a new function **sg_append_buffer()** which allows to\n    append new data to a buffer multiple times per frame and interleave this\n    with draw calls. This basically implements the\n    D3D11_MAP_WRITE_NO_OVERWRITE update strategy for buffer objects. For\n    example usage, see the updated Dear ImGui samples in the [sokol_samples\n    repo](https://github.com/floooh/sokol-samples)\n    - the GL state cache in sokol_gfx.h handles buffers bindings in a\n    more robust way, previously it might have happened that the\n    buffer binding gets confused when creating buffers or updating\n    buffer contents in the render loop\n\n- **17-Oct-2018**: sokol_args.h added\n\n- **26-Sep-2018**: sokol_audio.h ready for prime time :)\n\n- **11-May-2018**: sokol_gfx.h now autodetects iOS vs MacOS in the Metal\nbackend during compilation using the standard define TARGET_OS_IPHONE defined\nin the TargetConditionals.h system header, please replace the old\nbackend-selection defines SOKOL_METAL_MACOS and SOKOL_METAL_IOS with\n**SOKOL_METAL**\n\n- **20-Apr-2018**: 3 new context-switching functions have been added\nto make it possible to use sokol together with applications that\nuse multiple GL contexts. On D3D11 and Metal, the functions are currently\nempty. See the new section ```WORKING WITH CONTEXTS``` in the sokol_gfx.h\nheader documentation, and the new sample [multiwindow-glfw](https://github.com/floooh/sokol-samples/blob/master/glfw/multiwindow-glfw.c)\n\n- **31-Jan-2018**: The vertex layout declaration in sg\\_pipeline\\_desc had\nsome fairly subtle flaws and has been changed to work like Metal or Vulkan.\nThe gist is that the vertex-buffer-layout properties (vertex stride,\nvertex-step-rate and -step-function for instancing) is now defined in a\nseparate array from the vertex attributes. This removes some brittle backend\ncode which tries to guess the right vertex attribute slot if no attribute\nnames are given, and which was wrong for shader-code-generation pipelines\nwhich reorder the vertex attributes (I stumbled over this when porting the\nOryol Gfx module over to sokol-gfx). Some code samples:\n\n```c\n// a complete vertex layout declaration with a single input buffer\n// with two vertex attributes\nsg_pipeline pip = sg_make_pipeline(&(sg_pipeline_desc){\n    .layout = {\n        .buffers = {\n            [0] = {\n                .stride = 20,\n                .step_func = SG_VERTEXSTEP_PER_VERTEX,\n                .step_rate = 1\n            }\n        },\n        .attrs = {\n            [0] = {\n                .name = \"pos\",\n                .offset = 0,\n                .format = SG_VERTEXFORMAT_FLOAT3,\n                .buffer_index = 0\n            },\n            [1] = {\n                .name = \"uv\",\n                .offset = 12,\n                .format = SG_VERTEXFORMAT_FLOAT2,\n                .buffer_index = 0\n            }\n        }\n    },\n    ...\n});\n\n// if the vertex layout has no gaps, we can get rid of the strides and offsets:\nsg_pipeline pip = sg_make_pipeline(&(sg_pipeline_desc){\n    .layout = {\n        .buffers = {\n            [0] = {\n                .step_func = SG_VERTEXSTEP_PER_VERTEX,\n                .step_rate=1\n            }\n        },\n        .attrs = {\n            [0] = {\n                .name = \"pos\",\n                .format = SG_VERTEXFORMAT_FLOAT3,\n                .buffer_index = 0\n            },\n            [1] = {\n                .name = \"uv\",\n                .format = SG_VERTEXFORMAT_FLOAT2,\n                .buffer_index = 0\n            }\n        }\n    },\n    ...\n});\n\n// we can also get rid of the other default-values, which leaves buffers[0]\n// as all-defaults, so it can disappear completely:\nsg_pipeline pip = sg_make_pipeline(&(sg_pipeline_desc){\n    .layout = {\n        .attrs = {\n            [0] = { .name = \"pos\", .format = SG_VERTEXFORMAT_FLOAT3 },\n            [1] = { .name = \"uv\", .format = SG_VERTEXFORMAT_FLOAT2 }\n        }\n    },\n    ...\n});\n\n// and finally on GL3.3 and Metal and we don't need the attribute names\n// (on D3D11, a semantic name and index must be provided though)\nsg_pipeline pip = sg_make_pipeline(&(sg_pipeline_desc){\n    .layout = {\n        .attrs = {\n            [0] = { .format = SG_VERTEXFORMAT_FLOAT3 },\n            [1] = { .format = SG_VERTEXFORMAT_FLOAT2 }\n        }\n    },\n    ...\n});\n```\n\nPlease check the sample code in https://github.com/floooh/sokol-samples for\nmore examples!\n\nEnjoy!\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 0.8759765625,
          "content": "zlib/libpng license\n\nCopyright (c) 2018 Andre Weissflog\n\nThis software is provided 'as-is', without any express or implied warranty.\nIn no event will the authors be held liable for any damages arising from the\nuse of this software.\n\nPermission is granted to anyone to use this software for any purpose,\nincluding commercial applications, and to alter it and redistribute it\nfreely, subject to the following restrictions:\n\n    1. The origin of this software must not be misrepresented; you must not\n    claim that you wrote the original software. If you use this software in a\n    product, an acknowledgment in the product documentation would be\n    appreciated but is not required.\n\n    2. Altered source versions must be plainly marked as such, and must not\n    be misrepresented as being the original software.\n\n    3. This notice may not be removed or altered from any source\n    distribution.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 15.423828125,
          "content": "<p align=\"center\">\n    <img src=\"assets/logo_full_large.png\" style=\"width: 60%\" /><br/><br/>Simple\n    <a href=\"https://github.com/nothings/stb/blob/master/docs/stb_howto.txt\">STB-style</a>\n    cross-platform libraries for C and C++, written in C.<br/><br/>\n</p>\n\n# Sokol\n\n[**See what's new**](https://github.com/floooh/sokol/blob/master/CHANGELOG.md) (**07-Nov-2024** sokol_gfx.h: the 'bindings cleanup' update\n\n[![Build](/../../actions/workflows/main.yml/badge.svg)](/../../actions/workflows/main.yml) [![Bindings](/../../actions/workflows/gen_bindings.yml/badge.svg)](/../../actions/workflows/gen_bindings.yml) [![build](https://github.com/floooh/sokol-zig/actions/workflows/main.yml/badge.svg)](https://github.com/floooh/sokol-zig/actions/workflows/main.yml) [![build](https://github.com/floooh/sokol-nim/actions/workflows/main.yml/badge.svg)](https://github.com/floooh/sokol-nim/actions/workflows/main.yml) [![Odin](https://github.com/floooh/sokol-odin/actions/workflows/main.yml/badge.svg)](https://github.com/floooh/sokol-odin/actions/workflows/main.yml)[![Rust](https://github.com/floooh/sokol-rust/actions/workflows/main.yml/badge.svg)](https://github.com/floooh/sokol-rust/actions/workflows/main.yml)[![Dlang](https://github.com/kassane/sokol-d/actions/workflows/build.yml/badge.svg)](https://github.com/kassane/sokol-d/actions/workflows/build.yml)\n\n## Examples and Related Projects\n\n- [Live Samples](https://floooh.github.io/sokol-html5/index.html) via WASM ([source](https://github.com/floooh/sokol-samples))\n\n- [Doom Shareware](https://floooh.github.io/doom-sokol/) ported to the Sokol headers ([source](https://github.com/floooh/doom-sokol))\n\n- [Everybody Wants to Crank the World](https://aras-p.github.io/demo-pd-cranktheworld/) demo by\nAras Pranckeviius, PC/web port via sokol ([source](https://github.com/aras-p/demo-pd-cranktheworld)).\n\n- [sokol_gp.h](https://github.com/edubart/sokol_gp) a 2D shape drawing library on top of sokol_gfx.h\n\n- [LearnOpenGL examples ported to sokol-gfx](https://zeromake.github.io/learnopengl-examples/) ([git repo](https://github.com/zeromake/learnopengl-examples))\n\n- [Dear ImGui starterkit](https://github.com/floooh/cimgui-sokol-starterkit) a self-contained starterkit for writing Dear ImGui apps in C.\n\n- [qoiview](https://github.com/floooh/qoiview) a basic viewer for the new QOI image file format\n\n- [Tiny 8-bit emulators](https://floooh.github.io/tiny8bit/)\n\n- A 'single-file' [Pacman clone in C99](https://github.com/floooh/pacman.c/), also available in [Zig](https://github.com/floooh/pacman.zig/)\n\n- [Solar Storm](https://store.steampowered.com/app/2754920/Solar_Storm/), a turn-based scifi artillery game built with Odin and Sokol, released on Steam.\n\n- [Spanking Runners (Samogonki)](https://store.steampowered.com/app/2599800/Spanking_Runners/), arcade racing in a bright and unusual world, released on Steam.\n\n- [MEG-4](https://bztsrc.gitlab.io/meg4) a virtual fantasy console emulator in C89, ported to sokol\n\n- A [Minigolf game](https://mgerdes.github.io/minigolf.html) ([source](https://github.com/mgerdes/minigolf)).\n\n- [hIghQube](https://github.com/RuiVarela/hIghQube) A game demo that used sokol rendering extensively\n\n- [Senos](https://github.com/RuiVarela/Senos) A music app that uses sokol as backend\n\n- ['Dealer's Dungeon'](https://dealers-dungeon.com/demo/) ([lower graphics quality](https://dealers-dungeon.com/demo/?q=3),\n[source](https://github.com/bqqbarbhg/spear))\n\n- [Command line tools](https://github.com/floooh/sokol-tools) (shader compiler)\n\n- [How to build without a build system](https://github.com/floooh/sokol-samples#how-to-build-without-a-build-system):\nuseful details for integrating the Sokol headers into your own project with your favourite C/C++ build system\n\n## Core libraries\n\n- [**sokol\\_gfx.h**](https://github.com/floooh/sokol/blob/master/sokol_gfx.h): 3D-API wrapper (GL/GLES3/WebGL2 + Metal + D3D11 + WebGPU)\n- [**sokol\\_app.h**](https://github.com/floooh/sokol/blob/master/sokol_app.h): app framework wrapper (entry + window + 3D-context + input)\n- [**sokol\\_time.h**](https://github.com/floooh/sokol/blob/master/sokol_time.h): time measurement\n- [**sokol\\_audio.h**](https://github.com/floooh/sokol/blob/master/sokol_audio.h): minimal buffer-streaming audio playback\n- [**sokol\\_fetch.h**](https://github.com/floooh/sokol/blob/master/sokol_fetch.h): asynchronous data streaming from HTTP and local filesystem\n- [**sokol\\_args.h**](https://github.com/floooh/sokol/blob/master/sokol_args.h): unified cmdline/URL arg parser for web and native apps\n- [**sokol\\_log.h**](https://github.com/floooh/sokol/blob/master/sokol_log.h): provides a standard logging callback for the other sokol headers\n\n## Utility libraries\n\n- [**sokol\\_imgui.h**](https://github.com/floooh/sokol/blob/master/util/sokol_imgui.h): sokol_gfx.h rendering backend for [Dear ImGui](https://github.com/ocornut/imgui)\n- [**sokol\\_nuklear.h**](https://github.com/floooh/sokol/blob/master/util/sokol_nuklear.h): sokol_gfx.h rendering backend for [Nuklear](https://github.com/Immediate-Mode-UI/Nuklear)\n- [**sokol\\_gl.h**](https://github.com/floooh/sokol/blob/master/util/sokol_gl.h): OpenGL 1.x style immediate-mode rendering API on top of sokol_gfx.h\n- [**sokol\\_fontstash.h**](https://github.com/floooh/sokol/blob/master/util/sokol_fontstash.h): sokol_gl.h rendering backend for [fontstash](https://github.com/memononen/fontstash)\n- [**sokol\\_gfx\\_imgui.h**](https://github.com/floooh/sokol/blob/master/util/sokol_gfx_imgui.h): debug-inspection UI for sokol_gfx.h (implemented with Dear ImGui)\n- [**sokol\\_debugtext.h**](https://github.com/floooh/sokol/blob/master/util/sokol_debugtext.h): a simple text renderer using vintage home computer fonts\n- [**sokol\\_memtrack.h**](https://github.com/floooh/sokol/blob/master/util/sokol_memtrack.h): easily track memory allocations in sokol headers\n- [**sokol\\_shape.h**](https://github.com/floooh/sokol/blob/master/util/sokol_shape.h): generate simple shapes and plug them into sokol-gfx resource creation structs\n- [**sokol\\_color.h**](https://github.com/floooh/sokol/blob/master/util/sokol_color.h): X11 style color constants and functions for creating sg_color objects\n- [**sokol\\_spine.h**](https://github.com/floooh/sokol/blob/master/util/sokol_spine.h): a sokol-style wrapper around the Spine C runtime (http://en.esotericsoftware.com/spine-in-depth)\n\n## 'Official' Language Bindings\n\nThese are automatically updated on changes to the C headers:\n\n- [sokol-zig](https://github.com/floooh/sokol-zig)\n- [sokol-odin](https://github.com/floooh/sokol-odin)\n- [sokol-nim](https://github.com/floooh/sokol-nim)\n- [sokol-rust](https://github.com/floooh/sokol-rust)\n- [sokol-d](https://github.com/kassane/sokol-d)\n- [sokol-jai](https://github.com/colinbellino/sokol-jai)\n\n## Notes\n\nWebAssembly is a 'first-class citizen', one important motivation for the\nSokol headers is to provide a collection of cross-platform APIs with a\nminimal footprint on the web platform while still being useful.\n\nThe core headers are standalone and can be used independently from each other.\n\n### Why C:\n\n- easier integration with other languages\n- easier integration into other projects\n- adds only minimal size overhead to executables\n\nA blog post with more background info: [A Tour of sokol_gfx.h](http://floooh.github.io/2017/07/29/sokol-gfx-tour.html)\n\n# sokol_gfx.h:\n\n- simple, modern wrapper around GLES3/WebGL2, GL3.3, D3D11, Metal, and WebGPU\n- buffers, images, shaders, pipeline-state-objects and render-passes\n- does *not* handle window creation or 3D API context initialization\n- does *not* provide shader dialect cross-translation (**BUT** there's now an 'official' shader-cross-compiler solution which\nseamlessly integrates with sokol_gfx.h and IDEs: [see here for details](https://github.com/floooh/sokol-tools/blob/master/docs/sokol-shdc.md)\n\n# sokol_app.h\n\nA minimal cross-platform application-wrapper library:\n\n- unified application entry\n- single window or canvas for 3D rendering\n- 3D context initialization\n- event-based keyboard, mouse and touch input\n- supported platforms: Win32, MacOS, Linux (X11), iOS, WASM, Android, UWP\n- supported 3D-APIs: GL3.3 (GLX/WGL), Metal, D3D11, GLES3/WebGL2\n\nThe vanilla Hello-Triangle using sokol_gfx.h, sokol_app.h and the\nsokol-shdc shader compiler (shader code not shown):\n\n```c\n#include \"sokol_app.h\"\n#include \"sokol_gfx.h\"\n#include \"sokol_log.h\"\n#include \"sokol_glue.h\"\n#include \"triangle-sapp.glsl.h\"\n\nstatic struct {\n    sg_pipeline pip;\n    sg_bindings bind;\n    sg_pass_action pass_action;\n} state;\n\nstatic void init(void) {\n    sg_setup(&(sg_desc){\n        .environment = sglue_environment(),\n        .logger.func = slog_func,\n    });\n\n    float vertices[] = {\n         0.0f,  0.5f, 0.5f,     1.0f, 0.0f, 0.0f, 1.0f,\n         0.5f, -0.5f, 0.5f,     0.0f, 1.0f, 0.0f, 1.0f,\n        -0.5f, -0.5f, 0.5f,     0.0f, 0.0f, 1.0f, 1.0f\n    };\n    state.bind.vertex_buffers[0] = sg_make_buffer(&(sg_buffer_desc){\n        .data = SG_RANGE(vertices),\n    });\n\n    state.pip = sg_make_pipeline(&(sg_pipeline_desc){\n        .shader = sg_make_shader(triangle_shader_desc(sg_query_backend())),\n        .layout = {\n            .attrs = {\n                [ATTR_triangle_position].format = SG_VERTEXFORMAT_FLOAT3,\n                [ATTR_triangle_color0].format = SG_VERTEXFORMAT_FLOAT4\n            }\n        },\n    });\n\n    state.pass_action = (sg_pass_action) {\n        .colors[0] = { .load_action=SG_LOADACTION_CLEAR, .clear_value={0.0f, 0.0f, 0.0f, 1.0f } }\n    };\n}\n\nvoid frame(void) {\n    sg_begin_pass(&(sg_pass){ .action = state.pass_action, .swapchain = sglue_swapchain() });\n    sg_apply_pipeline(state.pip);\n    sg_apply_bindings(&state.bind);\n    sg_draw(0, 3, 1);\n    sg_end_pass();\n    sg_commit();\n}\n\nvoid cleanup(void) {\n    sg_shutdown();\n}\n\nsapp_desc sokol_main(int argc, char* argv[]) {\n    (void)argc; (void)argv;\n    return (sapp_desc){\n        .init_cb = init,\n        .frame_cb = frame,\n        .cleanup_cb = cleanup,\n        .width = 640,\n        .height = 480,\n        .window_title = \"Triangle\",\n        .icon.sokol_default = true,\n        .logger.func = slog_func,\n    };\n}\n```\n\n# sokol_audio.h\n\nA minimal audio-streaming API:\n\n- you provide a mono- or stereo-stream of 32-bit float samples which sokol_audio.h forwards into platform-specific backends\n- two ways to provide the data:\n    1. directly fill backend audio buffer from your callback function running in the audio thread\n    2. alternatively push small packets of audio data from your main loop,\n    or a separate thread created by you\n- platform backends:\n    - Windows: WASAPI\n    - macOS/iOS: CoreAudio\n    - Linux: ALSA\n    - emscripten: WebAudio + ScriptProcessorNode (doesn't use the emscripten-provided OpenAL or SDL Audio wrappers)\n\nA simple mono square-wave generator using the callback model:\n\n```c\n// the sample callback, running in audio thread\nstatic void stream_cb(float* buffer, int num_frames, int num_channels) {\n    assert(1 == num_channels);\n    static uint32_t count = 0;\n    for (int i = 0; i < num_frames; i++) {\n        buffer[i] = (count++ & (1<<3)) ? 0.5f : -0.5f;\n    }\n}\n\nint main() {\n    // init sokol-audio with default params\n    saudio_setup(&(saudio_desc){\n        .stream_cb = stream_cb,\n        .logger.func = slog_func,\n    });\n\n    // run main loop\n    ...\n\n    // shutdown sokol-audio\n    saudio_shutdown();\n    return 0;\n```\n\nThe same code using the push-model\n\n```c\n#define BUF_SIZE (32)\nint main() {\n    // init sokol-audio with default params, no callback\n    saudio_setup(&(saudio_desc){\n        .logger.func = slog_func,\n    });\n    assert(saudio_channels() == 1);\n\n    // a small intermediate buffer so we don't need to push\n    // individual samples, which would be quite inefficient\n    float buf[BUF_SIZE];\n    int buf_pos = 0;\n    uint32_t count = 0;\n\n    // push samples from main loop\n    bool done = false;\n    while (!done) {\n        // generate and push audio samples...\n        int num_frames = saudio_expect();\n        for (int i = 0; i < num_frames; i++) {\n            // simple square wave generator\n            buf[buf_pos++] = (count++ & (1<<3)) ? 0.5f : -0.5f;\n            if (buf_pos == BUF_SIZE) {\n                buf_pos = 0;\n                saudio_push(buf, BUF_SIZE);\n            }\n        }\n        // handle other per-frame stuff...\n        ...\n    }\n\n    // shutdown sokol-audio\n    saudio_shutdown();\n    return 0;\n}\n```\n\n# sokol_fetch.h\n\nLoad entire files, or stream data asynchronously over HTTP (emscripten/wasm)\nor the local filesystem (all native platforms).\n\nSimple C99 example loading a file into a static buffer:\n\n```c\n#include \"sokol_fetch.h\"\n#include \"sokol_log.h\"\n\nstatic void response_callback(const sfetch_response*);\n\n#define MAX_FILE_SIZE (1024*1024)\nstatic uint8_t buffer[MAX_FILE_SIZE];\n\n// application init\nstatic void init(void) {\n    ...\n    // setup sokol-fetch with default config:\n    sfetch_setup(&(sfetch_desc_t){ .logger.func = slog_func });\n\n    // start loading a file into a statically allocated buffer:\n    sfetch_send(&(sfetch_request_t){\n        .path = \"hello_world.txt\",\n        .callback = response_callback\n        .buffer_ptr = buffer,\n        .buffer_size = sizeof(buffer)\n    });\n}\n\n// per frame...\nstatic void frame(void) {\n    ...\n    // need to call sfetch_dowork() once per frame to 'turn the gears':\n    sfetch_dowork();\n    ...\n}\n\n// the response callback is where the interesting stuff happens:\nstatic void response_callback(const sfetch_response_t* response) {\n    if (response->fetched) {\n        // data has been loaded into the provided buffer, do something\n        // with the data...\n        const void* data = response->buffer_ptr;\n        uint64_t data_size = response->fetched_size;\n    }\n    // the finished flag is set both on success and failure\n    if (response->failed) {\n        // oops, something went wrong\n        switch (response->error_code) {\n            SFETCH_ERROR_FILE_NOT_FOUND: ...\n            SFETCH_ERROR_BUFFER_TOO_SMALL: ...\n            ...\n        }\n    }\n}\n\n// application shutdown\nstatic void shutdown(void) {\n    ...\n    sfetch_shutdown();\n    ...\n}\n```\n\n# sokol_time.h:\n\nSimple cross-platform time measurement:\n\n```c\n#include \"sokol_time.h\"\n...\n/* initialize sokol_time */\nstm_setup();\n\n/* take start timestamp */\nuint64_t start = stm_now();\n\n...some code to measure...\n\n/* compute elapsed time */\nuint64_t elapsed = stm_since(start);\n\n/* convert to time units */\ndouble seconds = stm_sec(elapsed);\ndouble milliseconds = stm_ms(elapsed);\ndouble microseconds = stm_us(elapsed);\ndouble nanoseconds = stm_ns(elapsed);\n\n/* difference between 2 time stamps */\nuint64_t start = stm_now();\n...\nuint64_t end = stm_now();\nuint64_t elapsed = stm_diff(end, start);\n\n/* compute a 'lap time' (e.g. for fps) */\nuint64_t last_time = 0;\nwhile (!done) {\n    ...render something...\n    double frame_time_ms = stm_ms(stm_laptime(&last_time));\n}\n```\n\n# sokol_args.h\n\nUnified argument parsing for web and native apps. Uses argc/argv on native\nplatforms and the URL query string on the web.\n\nExample URL with one arg:\n\nhttps://floooh.github.io/tiny8bit/kc85.html?type=kc85_4\n\nThe same as command line app:\n\n> kc85 type=kc85_4\n\nParsed like this:\n\n```c\n#include \"sokol_args.h\"\n\nint main(int argc, char* argv[]) {\n    sargs_setup(&(sargs_desc){ .argc=argc, .argv=argv });\n    if (sargs_exists(\"type\")) {\n        if (sargs_equals(\"type\", \"kc85_4\")) {\n            // start as KC85/4\n        }\n        else if (sargs_equals(\"type\", \"kc85_3\")) {\n            // start as KC85/3\n        }\n        else {\n            // start as KC85/2\n        }\n    }\n    sargs_shutdown();\n    return 0;\n}\n```\n\nSee the sokol_args.h header for a more complete documentation, and the [Tiny\nEmulators](https://floooh.github.io/tiny8bit/) for more interesting usage examples.\n"
        },
        {
          "name": "assets",
          "type": "tree",
          "content": null
        },
        {
          "name": "bindgen",
          "type": "tree",
          "content": null
        },
        {
          "name": "fips.yml",
          "type": "blob",
          "size": 0.0390625,
          "content": "exports:\n  header-dirs: [ \".\", \"util\" ]\n"
        },
        {
          "name": "sokol_app.h",
          "type": "blob",
          "size": 472.169921875,
          "content": "#if defined(SOKOL_IMPL) && !defined(SOKOL_APP_IMPL)\n#define SOKOL_APP_IMPL\n#endif\n#ifndef SOKOL_APP_INCLUDED\n/*\n    sokol_app.h -- cross-platform application wrapper\n\n    Project URL: https://github.com/floooh/sokol\n\n    Do this:\n        #define SOKOL_IMPL or\n        #define SOKOL_APP_IMPL\n    before you include this file in *one* C or C++ file to create the\n    implementation.\n\n    In the same place define one of the following to select the 3D-API\n    which should be initialized by sokol_app.h (this must also match\n    the backend selected for sokol_gfx.h if both are used in the same\n    project):\n\n        #define SOKOL_GLCORE\n        #define SOKOL_GLES3\n        #define SOKOL_D3D11\n        #define SOKOL_METAL\n        #define SOKOL_WGPU\n        #define SOKOL_NOAPI\n\n    Optionally provide the following defines with your own implementations:\n\n        SOKOL_ASSERT(c)             - your own assert macro (default: assert(c))\n        SOKOL_UNREACHABLE()         - a guard macro for unreachable code (default: assert(false))\n        SOKOL_WIN32_FORCE_MAIN      - define this on Win32 to add a main() entry point\n        SOKOL_WIN32_FORCE_WINMAIN   - define this on Win32 to add a WinMain() entry point (enabled by default unless SOKOL_WIN32_FORCE_MAIN or SOKOL_NO_ENTRY is defined)\n        SOKOL_NO_ENTRY              - define this if sokol_app.h shouldn't \"hijack\" the main() function\n        SOKOL_APP_API_DECL          - public function declaration prefix (default: extern)\n        SOKOL_API_DECL              - same as SOKOL_APP_API_DECL\n        SOKOL_API_IMPL              - public function implementation prefix (default: -)\n\n    Optionally define the following to force debug checks and validations\n    even in release mode:\n\n        SOKOL_DEBUG         - by default this is defined if _DEBUG is defined\n\n    If sokol_app.h is compiled as a DLL, define the following before\n    including the declaration or implementation:\n\n        SOKOL_DLL\n\n    On Windows, SOKOL_DLL will define SOKOL_APP_API_DECL as __declspec(dllexport)\n    or __declspec(dllimport) as needed.\n\n    if SOKOL_WIN32_FORCE_MAIN and SOKOL_WIN32_FORCE_WINMAIN are both defined,\n    it is up to the developer to define the desired subsystem.\n\n    On Linux, SOKOL_GLCORE can use either GLX or EGL.\n    GLX is default, set SOKOL_FORCE_EGL to override.\n\n    For example code, see https://github.com/floooh/sokol-samples/tree/master/sapp\n\n    Portions of the Windows and Linux GL initialization, event-, icon- etc... code\n    have been taken from GLFW (http://www.glfw.org/).\n\n    iOS onscreen keyboard support 'inspired' by libgdx.\n\n    Link with the following system libraries:\n\n    - on macOS with Metal: Cocoa, QuartzCore, Metal, MetalKit\n    - on macOS with GL: Cocoa, QuartzCore, OpenGL\n    - on iOS with Metal: Foundation, UIKit, Metal, MetalKit\n    - on iOS with GL: Foundation, UIKit, OpenGLES, GLKit\n    - on Linux with EGL: X11, Xi, Xcursor, EGL, GL (or GLESv2), dl, pthread, m(?)\n    - on Linux with GLX: X11, Xi, Xcursor, GL, dl, pthread, m(?)\n    - on Android: GLESv3, EGL, log, android\n    - on Windows with the MSVC or Clang toolchains: no action needed, libs are defined in-source via pragma-comment-lib\n    - on Windows with MINGW/MSYS2 gcc: compile with '-mwin32' so that _WIN32 is defined\n        - link with the following libs: -lkernel32 -luser32 -lshell32\n        - additionally with the GL backend: -lgdi32\n        - additionally with the D3D11 backend: -ld3d11 -ldxgi\n\n    On Linux, you also need to use the -pthread compiler and linker option, otherwise weird\n    things will happen, see here for details: https://github.com/floooh/sokol/issues/376\n\n    On macOS and iOS, the implementation must be compiled as Objective-C.\n\n    FEATURE OVERVIEW\n    ================\n    sokol_app.h provides a minimalistic cross-platform API which\n    implements the 'application-wrapper' parts of a 3D application:\n\n    - a common application entry function\n    - creates a window and 3D-API context/device with a 'default framebuffer'\n    - makes the rendered frame visible\n    - provides keyboard-, mouse- and low-level touch-events\n    - platforms: MacOS, iOS, HTML5, Win32, Linux/RaspberryPi, Android\n    - 3D-APIs: Metal, D3D11, GL4.1, GL4.3, GLES3, WebGL, WebGL2, NOAPI\n\n    FEATURE/PLATFORM MATRIX\n    =======================\n                        | Windows | macOS | Linux |  iOS  | Android |  HTML5\n    --------------------+---------+-------+-------+-------+---------+--------\n    gl 4.x              | YES     | YES   | YES   | ---   | ---     |  ---\n    gles3/webgl2        | ---     | ---   | YES(2)| YES   | YES     |  YES\n    metal               | ---     | YES   | ---   | YES   | ---     |  ---\n    d3d11               | YES     | ---   | ---   | ---   | ---     |  ---\n    noapi               | YES     | TODO  | TODO  | ---   | TODO    |  ---\n    KEY_DOWN            | YES     | YES   | YES   | SOME  | TODO    |  YES\n    KEY_UP              | YES     | YES   | YES   | SOME  | TODO    |  YES\n    CHAR                | YES     | YES   | YES   | YES   | TODO    |  YES\n    MOUSE_DOWN          | YES     | YES   | YES   | ---   | ---     |  YES\n    MOUSE_UP            | YES     | YES   | YES   | ---   | ---     |  YES\n    MOUSE_SCROLL        | YES     | YES   | YES   | ---   | ---     |  YES\n    MOUSE_MOVE          | YES     | YES   | YES   | ---   | ---     |  YES\n    MOUSE_ENTER         | YES     | YES   | YES   | ---   | ---     |  YES\n    MOUSE_LEAVE         | YES     | YES   | YES   | ---   | ---     |  YES\n    TOUCHES_BEGAN       | ---     | ---   | ---   | YES   | YES     |  YES\n    TOUCHES_MOVED       | ---     | ---   | ---   | YES   | YES     |  YES\n    TOUCHES_ENDED       | ---     | ---   | ---   | YES   | YES     |  YES\n    TOUCHES_CANCELLED   | ---     | ---   | ---   | YES   | YES     |  YES\n    RESIZED             | YES     | YES   | YES   | YES   | YES     |  YES\n    ICONIFIED           | YES     | YES   | YES   | ---   | ---     |  ---\n    RESTORED            | YES     | YES   | YES   | ---   | ---     |  ---\n    FOCUSED             | YES     | YES   | YES   | ---   | ---     |  YES\n    UNFOCUSED           | YES     | YES   | YES   | ---   | ---     |  YES\n    SUSPENDED           | ---     | ---   | ---   | YES   | YES     |  TODO\n    RESUMED             | ---     | ---   | ---   | YES   | YES     |  TODO\n    QUIT_REQUESTED      | YES     | YES   | YES   | ---   | ---     |  YES\n    IME                 | TODO    | TODO? | TODO  | ???   | TODO    |  ???\n    key repeat flag     | YES     | YES   | YES   | ---   | ---     |  YES\n    windowed            | YES     | YES   | YES   | ---   | ---     |  YES\n    fullscreen          | YES     | YES   | YES   | YES   | YES     |  ---\n    mouse hide          | YES     | YES   | YES   | ---   | ---     |  YES\n    mouse lock          | YES     | YES   | YES   | ---   | ---     |  YES\n    set cursor type     | YES     | YES   | YES   | ---   | ---     |  YES\n    screen keyboard     | ---     | ---   | ---   | YES   | TODO    |  YES\n    swap interval       | YES     | YES   | YES   | YES   | TODO    |  YES\n    high-dpi            | YES     | YES   | TODO  | YES   | YES     |  YES\n    clipboard           | YES     | YES   | YES   | ---   | ---     |  YES\n    MSAA                | YES     | YES   | YES   | YES   | YES     |  YES\n    drag'n'drop         | YES     | YES   | YES   | ---   | ---     |  YES\n    window icon         | YES     | YES(1)| YES   | ---   | ---     |  YES\n\n    (1) macOS has no regular window icons, instead the dock icon is changed\n    (2) supported with EGL only (not GLX)\n\n    STEP BY STEP\n    ============\n    --- Add a sokol_main() function to your code which returns a sapp_desc structure\n        with initialization parameters and callback function pointers. This\n        function is called very early, usually at the start of the\n        platform's entry function (e.g. main or WinMain). You should do as\n        little as possible here, since the rest of your code might be called\n        from another thread (this depends on the platform):\n\n            sapp_desc sokol_main(int argc, char* argv[]) {\n                return (sapp_desc) {\n                    .width = 640,\n                    .height = 480,\n                    .init_cb = my_init_func,\n                    .frame_cb = my_frame_func,\n                    .cleanup_cb = my_cleanup_func,\n                    .event_cb = my_event_func,\n                    ...\n                };\n            }\n\n        To get any logging output in case of errors you need to provide a log\n        callback. The easiest way is via sokol_log.h:\n\n            #include \"sokol_log.h\"\n\n            sapp_desc sokol_main(int argc, char* argv[]) {\n                return (sapp_desc) {\n                    ...\n                    .logger.func = slog_func,\n                };\n            }\n\n        There are many more setup parameters, but these are the most important.\n        For a complete list search for the sapp_desc structure declaration\n        below.\n\n        DO NOT call any sokol-app function from inside sokol_main(), since\n        sokol-app will not be initialized at this point.\n\n        The .width and .height parameters are the preferred size of the 3D\n        rendering canvas. The actual size may differ from this depending on\n        platform and other circumstances. Also the canvas size may change at\n        any time (for instance when the user resizes the application window,\n        or rotates the mobile device). You can just keep .width and .height\n        zero-initialized to open a default-sized window (what \"default-size\"\n        exactly means is platform-specific, but usually it's a size that covers\n        most of, but not all, of the display).\n\n        All provided function callbacks will be called from the same thread,\n        but this may be different from the thread where sokol_main() was called.\n\n        .init_cb (void (*)(void))\n            This function is called once after the application window,\n            3D rendering context and swap chain have been created. The\n            function takes no arguments and has no return value.\n        .frame_cb (void (*)(void))\n            This is the per-frame callback, which is usually called 60\n            times per second. This is where your application would update\n            most of its state and perform all rendering.\n        .cleanup_cb (void (*)(void))\n            The cleanup callback is called once right before the application\n            quits.\n        .event_cb (void (*)(const sapp_event* event))\n            The event callback is mainly for input handling, but is also\n            used to communicate other types of events to the application. Keep the\n            event_cb struct member zero-initialized if your application doesn't require\n            event handling.\n\n        As you can see, those 'standard callbacks' don't have a user_data\n        argument, so any data that needs to be preserved between callbacks\n        must live in global variables. If keeping state in global variables\n        is not an option, there's an alternative set of callbacks with\n        an additional user_data pointer argument:\n\n        .user_data (void*)\n            The user-data argument for the callbacks below\n        .init_userdata_cb (void (*)(void* user_data))\n        .frame_userdata_cb (void (*)(void* user_data))\n        .cleanup_userdata_cb (void (*)(void* user_data))\n        .event_userdata_cb (void(*)(const sapp_event* event, void* user_data))\n\n        The function sapp_userdata() can be used to query the user_data\n        pointer provided in the sapp_desc struct.\n\n        You can also call sapp_query_desc() to get a copy of the\n        original sapp_desc structure.\n\n        NOTE that there's also an alternative compile mode where sokol_app.h\n        doesn't \"hijack\" the main() function. Search below for SOKOL_NO_ENTRY.\n\n    --- Implement the initialization callback function (init_cb), this is called\n        once after the rendering surface, 3D API and swap chain have been\n        initialized by sokol_app. All sokol-app functions can be called\n        from inside the initialization callback, the most useful functions\n        at this point are:\n\n        int sapp_width(void)\n        int sapp_height(void)\n            Returns the current width and height of the default framebuffer in pixels,\n            this may change from one frame to the next, and it may be different\n            from the initial size provided in the sapp_desc struct.\n\n        float sapp_widthf(void)\n        float sapp_heightf(void)\n            These are alternatives to sapp_width() and sapp_height() which return\n            the default framebuffer size as float values instead of integer. This\n            may help to prevent casting back and forth between int and float\n            in more strongly typed languages than C and C++.\n\n        double sapp_frame_duration(void)\n            Returns the frame duration in seconds averaged over a number of\n            frames to smooth out any jittering spikes.\n\n        int sapp_color_format(void)\n        int sapp_depth_format(void)\n            The color and depth-stencil pixelformats of the default framebuffer,\n            as integer values which are compatible with sokol-gfx's\n            sg_pixel_format enum (so that they can be plugged directly in places\n            where sg_pixel_format is expected). Possible values are:\n\n                23 == SG_PIXELFORMAT_RGBA8\n                28 == SG_PIXELFORMAT_BGRA8\n                42 == SG_PIXELFORMAT_DEPTH\n                43 == SG_PIXELFORMAT_DEPTH_STENCIL\n\n        int sapp_sample_count(void)\n            Return the MSAA sample count of the default framebuffer.\n\n        const void* sapp_metal_get_device(void)\n        const void* sapp_metal_get_current_drawable(void)\n        const void* sapp_metal_get_depth_stencil_texture(void)\n        const void* sapp_metal_get_msaa_color_texture(void)\n            If the Metal backend has been selected, these functions return pointers\n            to various Metal API objects required for rendering, otherwise\n            they return a null pointer. These void pointers are actually\n            Objective-C ids converted with a (ARC) __bridge cast so that\n            the ids can be tunneled through C code. Also note that the returned\n            pointers may change from one frame to the next, only the Metal device\n            object is guaranteed to stay the same.\n\n        const void* sapp_macos_get_window(void)\n            On macOS, get the NSWindow object pointer, otherwise a null pointer.\n            Before being used as Objective-C object, the void* must be converted\n            back with a (ARC) __bridge cast.\n\n        const void* sapp_ios_get_window(void)\n            On iOS, get the UIWindow object pointer, otherwise a null pointer.\n            Before being used as Objective-C object, the void* must be converted\n            back with a (ARC) __bridge cast.\n\n        const void* sapp_d3d11_get_device(void)\n        const void* sapp_d3d11_get_device_context(void)\n        const void* sapp_d3d11_get_render_view(void)\n        const void* sapp_d3d11_get_resolve_view(void);\n        const void* sapp_d3d11_get_depth_stencil_view(void)\n            Similar to the sapp_metal_* functions, the sapp_d3d11_* functions\n            return pointers to D3D11 API objects required for rendering,\n            only if the D3D11 backend has been selected. Otherwise they\n            return a null pointer. Note that the returned pointers to the\n            render-target-view and depth-stencil-view may change from one\n            frame to the next!\n\n        const void* sapp_win32_get_hwnd(void)\n            On Windows, get the window's HWND, otherwise a null pointer. The\n            HWND has been cast to a void pointer in order to be tunneled\n            through code which doesn't include Windows.h.\n\n        const void* sapp_wgpu_get_device(void)\n        const void* sapp_wgpu_get_render_view(void)\n        const void* sapp_wgpu_get_resolve_view(void)\n        const void* sapp_wgpu_get_depth_stencil_view(void)\n            These are the WebGPU-specific functions to get the WebGPU\n            objects and values required for rendering. If sokol_app.h\n            is not compiled with SOKOL_WGPU, these functions return null.\n\n        uint32_t sapp_gl_get_framebuffer(void)\n            This returns the 'default framebuffer' of the GL context.\n            Typically this will be zero.\n\n        int sapp_gl_get_major_version(void)\n        int sapp_gl_get_minor_version(void)\n            Returns the major and minor version of the GL context\n            (only for SOKOL_GLCORE, all other backends return zero here, including SOKOL_GLES3)\n\n        const void* sapp_android_get_native_activity(void);\n            On Android, get the native activity ANativeActivity pointer, otherwise\n            a null pointer.\n\n    --- Implement the frame-callback function, this function will be called\n        on the same thread as the init callback, but might be on a different\n        thread than the sokol_main() function. Note that the size of\n        the rendering framebuffer might have changed since the frame callback\n        was called last. Call the functions sapp_width() and sapp_height()\n        each frame to get the current size.\n\n    --- Optionally implement the event-callback to handle input events.\n        sokol-app provides the following type of input events:\n            - a 'virtual key' was pressed down or released\n            - a single text character was entered (provided as UTF-32 encoded\n              UNICODE code point)\n            - a mouse button was pressed down or released (left, right, middle)\n            - mouse-wheel or 2D scrolling events\n            - the mouse was moved\n            - the mouse has entered or left the application window boundaries\n            - low-level, portable multi-touch events (began, moved, ended, cancelled)\n            - the application window was resized, iconified or restored\n            - the application was suspended or restored (on mobile platforms)\n            - the user or application code has asked to quit the application\n            - a string was pasted to the system clipboard\n            - one or more files have been dropped onto the application window\n\n        To explicitly 'consume' an event and prevent that the event is\n        forwarded for further handling to the operating system, call\n        sapp_consume_event() from inside the event handler (NOTE that\n        this behaviour is currently only implemented for some HTML5\n        events, support for other platforms and event types will\n        be added as needed, please open a GitHub ticket and/or provide\n        a PR if needed).\n\n        NOTE: Do *not* call any 3D API rendering functions in the event\n        callback function, since the 3D API context may not be active when the\n        event callback is called (it may work on some platforms and 3D APIs,\n        but not others, and the exact behaviour may change between\n        sokol-app versions).\n\n    --- Implement the cleanup-callback function, this is called once\n        after the user quits the application (see the section\n        \"APPLICATION QUIT\" for detailed information on quitting\n        behaviour, and how to intercept a pending quit - for instance to show a\n        \"Really Quit?\" dialog box). Note that the cleanup-callback isn't\n        guaranteed to be called on the web and mobile platforms.\n\n    MOUSE CURSOR TYPE AND VISIBILITY\n    ================================\n    You can show and hide the mouse cursor with\n\n        void sapp_show_mouse(bool show)\n\n    And to get the current shown status:\n\n        bool sapp_mouse_shown(void)\n\n    NOTE that hiding the mouse cursor is different and independent from\n    the MOUSE/POINTER LOCK feature which will also hide the mouse pointer when\n    active (MOUSE LOCK is described below).\n\n    To change the mouse cursor to one of several predefined types, call\n    the function:\n\n        void sapp_set_mouse_cursor(sapp_mouse_cursor cursor)\n\n    Setting the default mouse cursor SAPP_MOUSECURSOR_DEFAULT will restore\n    the standard look.\n\n    To get the currently active mouse cursor type, call:\n\n        sapp_mouse_cursor sapp_get_mouse_cursor(void)\n\n    MOUSE LOCK (AKA POINTER LOCK, AKA MOUSE CAPTURE)\n    ================================================\n    In normal mouse mode, no mouse movement events are reported when the\n    mouse leaves the windows client area or hits the screen border (whether\n    it's one or the other depends on the platform), and the mouse move events\n    (SAPP_EVENTTYPE_MOUSE_MOVE) contain absolute mouse positions in\n    framebuffer pixels in the sapp_event items mouse_x and mouse_y, and\n    relative movement in framebuffer pixels in the sapp_event items mouse_dx\n    and mouse_dy.\n\n    To get continuous mouse movement (also when the mouse leaves the window\n    client area or hits the screen border), activate mouse-lock mode\n    by calling:\n\n        sapp_lock_mouse(true)\n\n    When mouse lock is activated, the mouse pointer is hidden, the\n    reported absolute mouse position (sapp_event.mouse_x/y) appears\n    frozen, and the relative mouse movement in sapp_event.mouse_dx/dy\n    no longer has a direct relation to framebuffer pixels but instead\n    uses \"raw mouse input\" (what \"raw mouse input\" exactly means also\n    differs by platform).\n\n    To deactivate mouse lock and return to normal mouse mode, call\n\n        sapp_lock_mouse(false)\n\n    And finally, to check if mouse lock is currently active, call\n\n        if (sapp_mouse_locked()) { ... }\n\n    On native platforms, the sapp_lock_mouse() and sapp_mouse_locked()\n    functions work as expected (mouse lock is activated or deactivated\n    immediately when sapp_lock_mouse() is called, and sapp_mouse_locked()\n    also immediately returns the new state after sapp_lock_mouse()\n    is called.\n\n    On the web platform, sapp_lock_mouse() and sapp_mouse_locked() behave\n    differently, as dictated by the limitations of the HTML5 Pointer Lock API:\n\n        - sapp_lock_mouse(true) can be called at any time, but it will\n          only take effect in a 'short-lived input event handler of a specific\n          type', meaning when one of the following events happens:\n            - SAPP_EVENTTYPE_MOUSE_DOWN\n            - SAPP_EVENTTYPE_MOUSE_UP\n            - SAPP_EVENTTYPE_MOUSE_SCROLL\n            - SAPP_EVENTTYPE_KEY_UP\n            - SAPP_EVENTTYPE_KEY_DOWN\n        - The mouse lock/unlock action on the web platform is asynchronous,\n          this means that sapp_mouse_locked() won't immediately return\n          the new status after calling sapp_lock_mouse(), instead the\n          reported status will only change when the pointer lock has actually\n          been activated or deactivated in the browser.\n        - On the web, mouse lock can be deactivated by the user at any time\n          by pressing the Esc key. When this happens, sokol_app.h behaves\n          the same as if sapp_lock_mouse(false) is called.\n\n    For things like camera manipulation it's most straightforward to lock\n    and unlock the mouse right from the sokol_app.h event handler, for\n    instance the following code enters and leaves mouse lock when the\n    left mouse button is pressed and released, and then uses the relative\n    movement information to manipulate a camera (taken from the\n    cgltf-sapp.c sample in the sokol-samples repository\n    at https://github.com/floooh/sokol-samples):\n\n        static void input(const sapp_event* ev) {\n            switch (ev->type) {\n                case SAPP_EVENTTYPE_MOUSE_DOWN:\n                    if (ev->mouse_button == SAPP_MOUSEBUTTON_LEFT) {\n                        sapp_lock_mouse(true);\n                    }\n                    break;\n\n                case SAPP_EVENTTYPE_MOUSE_UP:\n                    if (ev->mouse_button == SAPP_MOUSEBUTTON_LEFT) {\n                        sapp_lock_mouse(false);\n                    }\n                    break;\n\n                case SAPP_EVENTTYPE_MOUSE_MOVE:\n                    if (sapp_mouse_locked()) {\n                        cam_orbit(&state.camera, ev->mouse_dx * 0.25f, ev->mouse_dy * 0.25f);\n                    }\n                    break;\n\n                default:\n                    break;\n            }\n        }\n\n    CLIPBOARD SUPPORT\n    =================\n    Applications can send and receive UTF-8 encoded text data from and to the\n    system clipboard. By default, clipboard support is disabled and\n    must be enabled at startup via the following sapp_desc struct\n    members:\n\n        sapp_desc.enable_clipboard  - set to true to enable clipboard support\n        sapp_desc.clipboard_size    - size of the internal clipboard buffer in bytes\n\n    Enabling the clipboard will dynamically allocate a clipboard buffer\n    for UTF-8 encoded text data of the requested size in bytes, the default\n    size is 8 KBytes. Strings that don't fit into the clipboard buffer\n    (including the terminating zero) will be silently clipped, so it's\n    important that you provide a big enough clipboard size for your\n    use case.\n\n    To send data to the clipboard, call sapp_set_clipboard_string() with\n    a pointer to an UTF-8 encoded, null-terminated C-string.\n\n    NOTE that on the HTML5 platform, sapp_set_clipboard_string() must be\n    called from inside a 'short-lived event handler', and there are a few\n    other HTML5-specific caveats to workaround. You'll basically have to\n    tinker until it works in all browsers :/ (maybe the situation will\n    improve when all browsers agree on and implement the new\n    HTML5 navigator.clipboard API).\n\n    To get data from the clipboard, check for the SAPP_EVENTTYPE_CLIPBOARD_PASTED\n    event in your event handler function, and then call sapp_get_clipboard_string()\n    to obtain the pasted UTF-8 encoded text.\n\n    NOTE that behaviour of sapp_get_clipboard_string() is slightly different\n    depending on platform:\n\n        - on the HTML5 platform, the internal clipboard buffer will only be updated\n          right before the SAPP_EVENTTYPE_CLIPBOARD_PASTED event is sent,\n          and sapp_get_clipboard_string() will simply return the current content\n          of the clipboard buffer\n        - on 'native' platforms, the call to sapp_get_clipboard_string() will\n          update the internal clipboard buffer with the most recent data\n          from the system clipboard\n\n    Portable code should check for the SAPP_EVENTTYPE_CLIPBOARD_PASTED event,\n    and then call sapp_get_clipboard_string() right in the event handler.\n\n    The SAPP_EVENTTYPE_CLIPBOARD_PASTED event will be generated by sokol-app\n    as follows:\n\n        - on macOS: when the Cmd+V key is pressed down\n        - on HTML5: when the browser sends a 'paste' event to the global 'window' object\n        - on all other platforms: when the Ctrl+V key is pressed down\n\n    DRAG AND DROP SUPPORT\n    =====================\n    PLEASE NOTE: the drag'n'drop feature works differently on WASM/HTML5\n    and on the native desktop platforms (Win32, Linux and macOS) because\n    of security-related restrictions in the HTML5 drag'n'drop API. The\n    WASM/HTML5 specifics are described at the end of this documentation\n    section:\n\n    Like clipboard support, drag'n'drop support must be explicitly enabled\n    at startup in the sapp_desc struct.\n\n        sapp_desc sokol_main(void) {\n            return (sapp_desc) {\n                .enable_dragndrop = true,   // default is false\n                ...\n            };\n        }\n\n    You can also adjust the maximum number of files that are accepted\n    in a drop operation, and the maximum path length in bytes if needed:\n\n        sapp_desc sokol_main(void) {\n            return (sapp_desc) {\n                .enable_dragndrop = true,               // default is false\n                .max_dropped_files = 8,                 // default is 1\n                .max_dropped_file_path_length = 8192,   // in bytes, default is 2048\n                ...\n            };\n        }\n\n    When drag'n'drop is enabled, the event callback will be invoked with an\n    event of type SAPP_EVENTTYPE_FILES_DROPPED whenever the user drops files on\n    the application window.\n\n    After the SAPP_EVENTTYPE_FILES_DROPPED is received, you can query the\n    number of dropped files, and their absolute paths by calling separate\n    functions:\n\n        void on_event(const sapp_event* ev) {\n            if (ev->type == SAPP_EVENTTYPE_FILES_DROPPED) {\n\n                // the mouse position where the drop happened\n                float x = ev->mouse_x;\n                float y = ev->mouse_y;\n\n                // get the number of files and their paths like this:\n                const int num_dropped_files = sapp_get_num_dropped_files();\n                for (int i = 0; i < num_dropped_files; i++) {\n                    const char* path = sapp_get_dropped_file_path(i);\n                    ...\n                }\n            }\n        }\n\n    The returned file paths are UTF-8 encoded strings.\n\n    You can call sapp_get_num_dropped_files() and sapp_get_dropped_file_path()\n    anywhere, also outside the event handler callback, but be aware that the\n    file path strings will be overwritten with the next drop operation.\n\n    In any case, sapp_get_dropped_file_path() will never return a null pointer,\n    instead an empty string \"\" will be returned if the drag'n'drop feature\n    hasn't been enabled, the last drop-operation failed, or the file path index\n    is out of range.\n\n    Drag'n'drop caveats:\n\n        - if more files are dropped in a single drop-action\n          than sapp_desc.max_dropped_files, the additional\n          files will be silently ignored\n        - if any of the file paths is longer than\n          sapp_desc.max_dropped_file_path_length (in number of bytes, after UTF-8\n          encoding) the entire drop operation will be silently ignored (this\n          needs some sort of error feedback in the future)\n        - no mouse positions are reported while the drag is in\n          process, this may change in the future\n\n    Drag'n'drop on HTML5/WASM:\n\n    The HTML5 drag'n'drop API doesn't return file paths, but instead\n    black-box 'file objects' which must be used to load the content\n    of dropped files. This is the reason why sokol_app.h adds two\n    HTML5-specific functions to the drag'n'drop API:\n\n        uint32_t sapp_html5_get_dropped_file_size(int index)\n            Returns the size in bytes of a dropped file.\n\n        void sapp_html5_fetch_dropped_file(const sapp_html5_fetch_request* request)\n            Asynchronously loads the content of a dropped file into a\n            provided memory buffer (which must be big enough to hold\n            the file content)\n\n    To start loading the first dropped file after an SAPP_EVENTTYPE_FILES_DROPPED\n    event is received:\n\n        sapp_html5_fetch_dropped_file(&(sapp_html5_fetch_request){\n            .dropped_file_index = 0,\n            .callback = fetch_cb\n            .buffer = {\n                .ptr = buf,\n                .size = sizeof(buf)\n            },\n            .user_data = ...\n        });\n\n    Make sure that the memory pointed to by 'buf' stays valid until the\n    callback function is called!\n\n    As result of the asynchronous loading operation (no matter if succeeded or\n    failed) the 'fetch_cb' function will be called:\n\n        void fetch_cb(const sapp_html5_fetch_response* response) {\n            // IMPORTANT: check if the loading operation actually succeeded:\n            if (response->succeeded) {\n                // the size of the loaded file:\n                const size_t num_bytes = response->data.size;\n                // and the pointer to the data (same as 'buf' in the fetch-call):\n                const void* ptr = response->data.ptr;\n            }\n            else {\n                // on error check the error code:\n                switch (response->error_code) {\n                    case SAPP_HTML5_FETCH_ERROR_BUFFER_TOO_SMALL:\n                        ...\n                        break;\n                    case SAPP_HTML5_FETCH_ERROR_OTHER:\n                        ...\n                        break;\n                }\n            }\n        }\n\n    Check the droptest-sapp example for a real-world example which works\n    both on native platforms and the web:\n\n    https://github.com/floooh/sokol-samples/blob/master/sapp/droptest-sapp.c\n\n    HIGH-DPI RENDERING\n    ==================\n    You can set the sapp_desc.high_dpi flag during initialization to request\n    a full-resolution framebuffer on HighDPI displays. The default behaviour\n    is sapp_desc.high_dpi=false, this means that the application will\n    render to a lower-resolution framebuffer on HighDPI displays and the\n    rendered content will be upscaled by the window system composer.\n\n    In a HighDPI scenario, you still request the same window size during\n    sokol_main(), but the framebuffer sizes returned by sapp_width()\n    and sapp_height() will be scaled up according to the DPI scaling\n    ratio.\n\n    Note that on some platforms the DPI scaling factor may change at any\n    time (for instance when a window is moved from a high-dpi display\n    to a low-dpi display).\n\n    To query the current DPI scaling factor, call the function:\n\n    float sapp_dpi_scale(void);\n\n    For instance on a Retina Mac, returning the following sapp_desc\n    struct from sokol_main():\n\n    sapp_desc sokol_main(void) {\n        return (sapp_desc) {\n            .width = 640,\n            .height = 480,\n            .high_dpi = true,\n            ...\n        };\n    }\n\n    ...the functions the functions sapp_width(), sapp_height()\n    and sapp_dpi_scale() will return the following values:\n\n    sapp_width:     1280\n    sapp_height:    960\n    sapp_dpi_scale: 2.0\n\n    If the high_dpi flag is false, or you're not running on a Retina display,\n    the values would be:\n\n    sapp_width:     640\n    sapp_height:    480\n    sapp_dpi_scale: 1.0\n\n    If the window is moved from the Retina display to a low-dpi external display,\n    the values would change as follows:\n\n    sapp_width:     1280 => 640\n    sapp_height:    960  => 480\n    sapp_dpi_scale: 2.0  => 1.0\n\n    Currently there is no event associated with a DPI change, but an\n    SAPP_EVENTTYPE_RESIZED will be sent as a side effect of the\n    framebuffer size changing.\n\n    Per-monitor DPI is currently supported on macOS and Windows.\n\n    APPLICATION QUIT\n    ================\n    Without special quit handling, a sokol_app.h application will quit\n    'gracefully' when the user clicks the window close-button unless a\n    platform's application model prevents this (e.g. on web or mobile).\n    'Graceful exit' means that the application-provided cleanup callback will\n    be called before the application quits.\n\n    On native desktop platforms sokol_app.h provides more control over the\n    application-quit-process. It's possible to initiate a 'programmatic quit'\n    from the application code, and a quit initiated by the application user can\n    be intercepted (for instance to show a custom dialog box).\n\n    This 'programmatic quit protocol' is implemented through 3 functions\n    and 1 event:\n\n        - sapp_quit(): This function simply quits the application without\n          giving the user a chance to intervene. Usually this might\n          be called when the user clicks the 'Ok' button in a 'Really Quit?'\n          dialog box\n        - sapp_request_quit(): Calling sapp_request_quit() will send the\n          event SAPP_EVENTTYPE_QUIT_REQUESTED to the applications event handler\n          callback, giving the user code a chance to intervene and cancel the\n          pending quit process (for instance to show a 'Really Quit?' dialog\n          box). If the event handler callback does nothing, the application\n          will be quit as usual. To prevent this, call the function\n          sapp_cancel_quit() from inside the event handler.\n        - sapp_cancel_quit(): Cancels a pending quit request, either initiated\n          by the user clicking the window close button, or programmatically\n          by calling sapp_request_quit(). The only place where calling this\n          function makes sense is from inside the event handler callback when\n          the SAPP_EVENTTYPE_QUIT_REQUESTED event has been received.\n        - SAPP_EVENTTYPE_QUIT_REQUESTED: this event is sent when the user\n          clicks the window's close button or application code calls the\n          sapp_request_quit() function. The event handler callback code can handle\n          this event by calling sapp_cancel_quit() to cancel the quit.\n          If the event is ignored, the application will quit as usual.\n\n    On the web platform, the quit behaviour differs from native platforms,\n    because of web-specific restrictions:\n\n    A `programmatic quit` initiated by calling sapp_quit() or\n    sapp_request_quit() will work as described above: the cleanup callback is\n    called, platform-specific cleanup is performed (on the web\n    this means that JS event handlers are unregistered), and then\n    the request-animation-loop will be exited. However that's all. The\n    web page itself will continue to exist (e.g. it's not possible to\n    programmatically close the browser tab).\n\n    On the web it's also not possible to run custom code when the user\n    closes a browser tab, so it's not possible to prevent this with a\n    fancy custom dialog box.\n\n    Instead the standard \"Leave Site?\" dialog box can be activated (or\n    deactivated) with the following function:\n\n        sapp_html5_ask_leave_site(bool ask);\n\n    The initial state of the associated internal flag can be provided\n    at startup via sapp_desc.html5_ask_leave_site.\n\n    This feature should only be used sparingly in critical situations - for\n    instance when the user would loose data - since popping up modal dialog\n    boxes is considered quite rude in the web world. Note that there's no way\n    to customize the content of this dialog box or run any code as a result\n    of the user's decision. Also note that the user must have interacted with\n    the site before the dialog box will appear. These are all security measures\n    to prevent fishing.\n\n    The Dear ImGui HighDPI sample contains example code of how to\n    implement a 'Really Quit?' dialog box with Dear ImGui (native desktop\n    platforms only), and for showing the hardwired \"Leave Site?\" dialog box\n    when running on the web platform:\n\n        https://floooh.github.io/sokol-html5/wasm/imgui-highdpi-sapp.html\n\n    FULLSCREEN\n    ==========\n    If the sapp_desc.fullscreen flag is true, sokol-app will try to create\n    a fullscreen window on platforms with a 'proper' window system\n    (mobile devices will always use fullscreen). The implementation details\n    depend on the target platform, in general sokol-app will use a\n    'soft approach' which doesn't interfere too much with the platform's\n    window system (for instance borderless fullscreen window instead of\n    a 'real' fullscreen mode). Such details might change over time\n    as sokol-app is adapted for different needs.\n\n    The most important effect of fullscreen mode to keep in mind is that\n    the requested canvas width and height will be ignored for the initial\n    window size, calling sapp_width() and sapp_height() will instead return\n    the resolution of the fullscreen canvas (however the provided size\n    might still be used for the non-fullscreen window, in case the user can\n    switch back from fullscreen- to windowed-mode).\n\n    To toggle fullscreen mode programmatically, call sapp_toggle_fullscreen().\n\n    To check if the application window is currently in fullscreen mode,\n    call sapp_is_fullscreen().\n\n    WINDOW ICON SUPPORT\n    ===================\n    Some sokol_app.h backends allow to change the window icon programmatically:\n\n        - on Win32: the small icon in the window's title bar, and the\n          bigger icon in the task bar\n        - on Linux: highly dependent on the used window manager, but usually\n          the window's title bar icon and/or the task bar icon\n        - on HTML5: the favicon shown in the page's browser tab\n        - on macOS: the application icon shown in the dock, but only\n          for currently running applications\n\n    NOTE that it is not possible to set the actual application icon which is\n    displayed by the operating system on the desktop or 'home screen'. Those\n    icons must be provided 'traditionally' through operating-system-specific\n    resources which are associated with the application (sokol_app.h might\n    later support setting the window icon from platform specific resource data\n    though).\n\n    There are two ways to set the window icon:\n\n        - at application start in the sokol_main() function by initializing\n          the sapp_desc.icon nested struct\n        - or later by calling the function sapp_set_icon()\n\n    As a convenient shortcut, sokol_app.h comes with a builtin default-icon\n    (a rainbow-colored 'S', which at least looks a bit better than the Windows\n    default icon for applications), which can be activated like this:\n\n    At startup in sokol_main():\n\n        sapp_desc sokol_main(...) {\n            return (sapp_desc){\n                ...\n                icon.sokol_default = true\n            };\n        }\n\n    Or later by calling:\n\n        sapp_set_icon(&(sapp_icon_desc){ .sokol_default = true });\n\n    NOTE that a completely zero-initialized sapp_icon_desc struct will not\n    update the window icon in any way. This is an 'escape hatch' so that you\n    can handle the window icon update yourself (or if you do this already,\n    sokol_app.h won't get in your way, in this case just leave the\n    sapp_desc.icon struct zero-initialized).\n\n    Providing your own icon images works exactly like in GLFW (down to the\n    data format):\n\n    You provide one or more 'candidate images' in different sizes, and the\n    sokol_app.h platform backends pick the best match for the specific backend\n    and icon type.\n\n    For each candidate image, you need to provide:\n\n        - the width in pixels\n        - the height in pixels\n        - and the actual pixel data in RGBA8 pixel format (e.g. 0xFFCC8844\n          on a little-endian CPU means: alpha=0xFF, blue=0xCC, green=0x88, red=0x44)\n\n    For instance, if you have 3 candidate images (small, medium, big) of\n    sizes 16x16, 32x32 and 64x64 the corresponding sapp_icon_desc struct is setup\n    like this:\n\n        // the actual pixel data (RGBA8, origin top-left)\n        const uint32_t small[16][16]  = { ... };\n        const uint32_t medium[32][32] = { ... };\n        const uint32_t big[64][64]    = { ... };\n\n        const sapp_icon_desc icon_desc = {\n            .images = {\n                { .width = 16, .height = 16, .pixels = SAPP_RANGE(small) },\n                { .width = 32, .height = 32, .pixels = SAPP_RANGE(medium) },\n                // ...or without the SAPP_RANGE helper macro:\n                { .width = 64, .height = 64, .pixels = { .ptr=big, .size=sizeof(big) } }\n            }\n        };\n\n    An sapp_icon_desc struct initialized like this can then either be applied\n    at application start in sokol_main:\n\n        sapp_desc sokol_main(...) {\n            return (sapp_desc){\n                ...\n                icon = icon_desc\n            };\n        }\n\n    ...or later by calling sapp_set_icon():\n\n        sapp_set_icon(&icon_desc);\n\n    Some window icon caveats:\n\n        - once the window icon has been updated, there's no way to go back to\n          the platform's default icon, this is because some platforms (Linux\n          and HTML5) don't switch the icon visual back to the default even if\n          the custom icon is deleted or removed\n        - on HTML5, if the sokol_app.h icon doesn't show up in the browser\n          tab, check that there's no traditional favicon 'link' element\n          is defined in the page's index.html, sokol_app.h will only\n          append a new favicon link element, but not delete any manually\n          defined favicon in the page\n\n    For an example and test of the window icon feature, check out the\n    'icon-sapp' sample on the sokol-samples git repository.\n\n    ONSCREEN KEYBOARD\n    =================\n    On some platforms which don't provide a physical keyboard, sokol-app\n    can display the platform's integrated onscreen keyboard for text\n    input. To request that the onscreen keyboard is shown, call\n\n        sapp_show_keyboard(true);\n\n    Likewise, to hide the keyboard call:\n\n        sapp_show_keyboard(false);\n\n    Note that onscreen keyboard functionality is no longer supported\n    on the browser platform (the previous hacks and workarounds to make browser\n    keyboards work for on web applications that don't use HTML UIs\n    never really worked across browsers).\n\n    INPUT EVENT BUBBLING ON THE WEB PLATFORM\n    ========================================\n    By default, input event bubbling on the web platform is configured in\n    a way that makes the most sense for 'full-canvas' apps that cover the\n    entire browser client window area:\n\n    - mouse, touch and wheel events do not bubble up, this prevents various\n      ugly side events, like:\n        - HTML text overlays being selected on double- or triple-click into\n          the canvas\n        - 'scroll bumping' even when the canvas covers the entire client area\n    - key_up/down events for 'character keys' *do* bubble up (otherwise\n      the browser will not generate UNICODE character events)\n    - all other key events *do not* bubble up by default (this prevents side effects\n      like F1 opening help, or F7 starting 'caret browsing')\n    - character events do not bubble up (although I haven't noticed any side effects\n      otherwise)\n\n    Event bubbling can be enabled for input event categories during initialization\n    in the sapp_desc struct:\n\n        sapp_desc sokol_main(int argc, char* argv[]) {\n            return (sapp_desc){\n                //...\n                .html5_bubble_mouse_events = true,\n                .html5_bubble_touch_events = true,\n                .html5_bubble_wheel_events = true,\n                .html5_bubble_key_events = true,\n                .html5_bubble_char_events = true,\n            };\n        }\n\n    This basically opens the floodgates and lets *all* input events bubble up to the browser.\n\n    To prevent individual events from bubbling, call sapp_consume_event() from within\n    the sokol_app.h event callback when that specific event is reported.\n\n\n    SETTING THE CANVAS OBJECT ON THE WEB PLATFORM\n    =============================================\n    On the web, sokol_app.h and the Emscripten SDK functions need to find\n    the WebGL/WebGPU canvas intended for rendering and attaching event\n    handlers. This can happen in four ways:\n\n    1. do nothing and just set the id of the canvas object to 'canvas' (preferred)\n    2. via a CSS Selector string (preferred)\n    3. by setting the `Module.canvas` property to the canvas object\n    4. by adding the canvas object to the global variable `specialHTMLTargets[]`\n       (this is a special variable used by the Emscripten runtime to lookup\n       event target objects for which document.querySelector() cannot be used)\n\n    The easiest way is to just name your canvas object 'canvas':\n\n        <canvas id=\"canvas\" ...></canvas>\n\n    This works because the default css selector string used by sokol_app.h\n    is '#canvas'.\n\n    If you name your canvas differently, you need to communicate that name to\n    sokol_app.h via `sapp_desc.html5_canvas_selector` as a regular css selector\n    string that's compatible with `document.querySelector()`. E.g. if your canvas\n    object looks like this:\n\n        <canvas id=\"bla\" ...></canvas>\n\n    The `sapp_desc.html5_canvas_selector` string must be set to '#bla':\n\n        .html5_canvas_selector = \"#bla\"\n\n    If the canvas object cannot be looked up via `document.querySelector()` you\n    need to use one of the alternative methods, both involve the special\n    Emscripten runtime `Module` object which is usually setup in the index.html\n    like this before the WASM blob is loaded and instantiated:\n\n        <script type='text/javascript'>\n            var Module = {\n                // ...\n            };\n        </script>\n\n    The first option is to set the `Module.canvas` property to your canvas object:\n\n        <script type='text/javascript'>\n            var Module = {\n                canvas: my_canvas_object,\n            };\n        </script>\n\n    When sokol_app.h initializes, it will check the global Module object whether\n    a `Module.canvas` property exists and is an object. This method will add\n    a new entry to the `specialHTMLTargets[]` object\n\n    The other option is to add the canvas under a name chosen by you to the\n    special `specialHTMLTargets[]` map, which is used by the Emscripten runtime\n    to lookup 'event target objects' which are not visible to `document.querySelector()`.\n    Note that `specialHTMLTargets[]` must be updated after the Emscripten runtime\n    has started but before the WASM code is running. A good place for this is\n    the special `Module.preRun` array in index.html:\n\n        <script type='text/javascript'>\n            var Module = {\n                preRun: [\n                    () => {\n                        specialHTMLTargets['my_canvas'] = my_canvas_object;\n                    }\n                ],\n            };\n        </script>\n\n    In that case, pass the same string to sokol_app.h which is used as key\n    in the specialHTMLTargets[] map:\n\n        .html5_canvas_selector = \"my_canvas\"\n\n    If sokol_app.h can't find your canvas for some reason check for warning\n    messages on the browser console.\n\n\n    OPTIONAL: DON'T HIJACK main() (#define SOKOL_NO_ENTRY)\n    ======================================================\n    NOTE: SOKOL_NO_ENTRY and sapp_run() is currently not supported on Android.\n\n    In its default configuration, sokol_app.h \"hijacks\" the platform's\n    standard main() function. This was done because different platforms\n    have different entry point conventions which are not compatible with\n    C's main() (for instance WinMain on Windows has completely different\n    arguments). However, this \"main hijacking\" posed a problem for\n    usage scenarios like integrating sokol_app.h with other languages than\n    C or C++, so an alternative SOKOL_NO_ENTRY mode has been added\n    in which the user code provides the platform's main function:\n\n    - define SOKOL_NO_ENTRY before including the sokol_app.h implementation\n    - do *not* provide a sokol_main() function\n    - instead provide the standard main() function of the platform\n    - from the main function, call the function ```sapp_run()``` which\n      takes a pointer to an ```sapp_desc``` structure.\n    - from here on```sapp_run()``` takes over control and calls the provided\n      init-, frame-, event- and cleanup-callbacks just like in the default model.\n\n    sapp_run() behaves differently across platforms:\n\n        - on some platforms, sapp_run() will return when the application quits\n        - on other platforms, sapp_run() will never return, even when the\n          application quits (the operating system is free to simply terminate\n          the application at any time)\n        - on Emscripten specifically, sapp_run() will return immediately while\n          the frame callback keeps being called\n\n    This different behaviour of sapp_run() essentially means that there shouldn't\n    be any code *after* sapp_run(), because that may either never be called, or in\n    case of Emscripten will be called at an unexpected time (at application start).\n\n    An application also should not depend on the cleanup-callback being called\n    when cross-platform compatibility is required.\n\n    Since sapp_run() returns immediately on Emscripten you shouldn't activate\n    the 'EXIT_RUNTIME' linker option (this is disabled by default when compiling\n    for the browser target), since the C/C++ exit runtime would be called immediately at\n    application start, causing any global objects to be destroyed and global\n    variables to be zeroed.\n\n    WINDOWS CONSOLE OUTPUT\n    ======================\n    On Windows, regular windowed applications don't show any stdout/stderr text\n    output, which can be a bit of a hassle for printf() debugging or generally\n    logging text to the console. Also, console output by default uses a local\n    codepage setting and thus international UTF-8 encoded text is printed\n    as garbage.\n\n    To help with these issues, sokol_app.h can be configured at startup\n    via the following Windows-specific sapp_desc flags:\n\n        sapp_desc.win32_console_utf8 (default: false)\n            When set to true, the output console codepage will be switched\n            to UTF-8 (and restored to the original codepage on exit)\n\n        sapp_desc.win32_console_attach (default: false)\n            When set to true, stdout and stderr will be attached to the\n            console of the parent process (if the parent process actually\n            has a console). This means that if the application was started\n            in a command line window, stdout and stderr output will be printed\n            to the terminal, just like a regular command line program. But if\n            the application is started via double-click, it will behave like\n            a regular UI application, and stdout/stderr will not be visible.\n\n        sapp_desc.win32_console_create (default: false)\n            When set to true, a new console window will be created and\n            stdout/stderr will be redirected to that console window. It\n            doesn't matter if the application is started from the command\n            line or via double-click.\n\n    MEMORY ALLOCATION OVERRIDE\n    ==========================\n    You can override the memory allocation functions at initialization time\n    like this:\n\n        void* my_alloc(size_t size, void* user_data) {\n            return malloc(size);\n        }\n\n        void my_free(void* ptr, void* user_data) {\n            free(ptr);\n        }\n\n        sapp_desc sokol_main(int argc, char* argv[]) {\n            return (sapp_desc){\n                // ...\n                .allocator = {\n                    .alloc_fn = my_alloc,\n                    .free_fn = my_free,\n                    .user_data = ...,\n                }\n            };\n        }\n\n    If no overrides are provided, malloc and free will be used.\n\n    This only affects memory allocation calls done by sokol_app.h\n    itself though, not any allocations in OS libraries.\n\n\n    ERROR REPORTING AND LOGGING\n    ===========================\n    To get any logging information at all you need to provide a logging callback in the setup call\n    the easiest way is to use sokol_log.h:\n\n        #include \"sokol_log.h\"\n\n        sapp_desc sokol_main(int argc, char* argv[]) {\n            return (sapp_desc) {\n                ...\n                .logger.func = slog_func,\n            };\n        }\n\n    To override logging with your own callback, first write a logging function like this:\n\n        void my_log(const char* tag,                // e.g. 'sapp'\n                    uint32_t log_level,             // 0=panic, 1=error, 2=warn, 3=info\n                    uint32_t log_item_id,           // SAPP_LOGITEM_*\n                    const char* message_or_null,    // a message string, may be nullptr in release mode\n                    uint32_t line_nr,               // line number in sokol_app.h\n                    const char* filename_or_null,   // source filename, may be nullptr in release mode\n                    void* user_data)\n        {\n            ...\n        }\n\n    ...and then setup sokol-app like this:\n\n        sapp_desc sokol_main(int argc, char* argv[]) {\n            return (sapp_desc) {\n                ...\n                .logger = {\n                    .func = my_log,\n                    .user_data = my_user_data,\n                }\n            };\n        }\n\n    The provided logging function must be reentrant (e.g. be callable from\n    different threads).\n\n    If you don't want to provide your own custom logger it is highly recommended to use\n    the standard logger in sokol_log.h instead, otherwise you won't see any warnings or\n    errors.\n\n    TEMP NOTE DUMP\n    ==============\n    - sapp_desc needs a bool whether to initialize depth-stencil surface\n    - the Android implementation calls cleanup_cb() and destroys the egl context in onDestroy\n      at the latest but should do it earlier, in onStop, as an app is \"killable\" after onStop\n      on Android Honeycomb and later (it can't be done at the moment as the app may be started\n      again after onStop and the sokol lifecycle does not yet handle context teardown/bringup)\n\n\n    LICENSE\n    =======\n    zlib/libpng license\n\n    Copyright (c) 2018 Andre Weissflog\n\n    This software is provided 'as-is', without any express or implied warranty.\n    In no event will the authors be held liable for any damages arising from the\n    use of this software.\n\n    Permission is granted to anyone to use this software for any purpose,\n    including commercial applications, and to alter it and redistribute it\n    freely, subject to the following restrictions:\n\n        1. The origin of this software must not be misrepresented; you must not\n        claim that you wrote the original software. If you use this software in a\n        product, an acknowledgment in the product documentation would be\n        appreciated but is not required.\n\n        2. Altered source versions must be plainly marked as such, and must not\n        be misrepresented as being the original software.\n\n        3. This notice may not be removed or altered from any source\n        distribution.\n*/\n#define SOKOL_APP_INCLUDED (1)\n#include <stddef.h> // size_t\n#include <stdint.h>\n#include <stdbool.h>\n\n#if defined(SOKOL_API_DECL) && !defined(SOKOL_APP_API_DECL)\n#define SOKOL_APP_API_DECL SOKOL_API_DECL\n#endif\n#ifndef SOKOL_APP_API_DECL\n#if defined(_WIN32) && defined(SOKOL_DLL) && defined(SOKOL_APP_IMPL)\n#define SOKOL_APP_API_DECL __declspec(dllexport)\n#elif defined(_WIN32) && defined(SOKOL_DLL)\n#define SOKOL_APP_API_DECL __declspec(dllimport)\n#else\n#define SOKOL_APP_API_DECL extern\n#endif\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* misc constants */\nenum {\n    SAPP_MAX_TOUCHPOINTS = 8,\n    SAPP_MAX_MOUSEBUTTONS = 3,\n    SAPP_MAX_KEYCODES = 512,\n    SAPP_MAX_ICONIMAGES = 8,\n};\n\n/*\n    sapp_event_type\n\n    The type of event that's passed to the event handler callback\n    in the sapp_event.type field. These are not just \"traditional\"\n    input events, but also notify the application about state changes\n    or other user-invoked actions.\n*/\ntypedef enum sapp_event_type {\n    SAPP_EVENTTYPE_INVALID,\n    SAPP_EVENTTYPE_KEY_DOWN,\n    SAPP_EVENTTYPE_KEY_UP,\n    SAPP_EVENTTYPE_CHAR,\n    SAPP_EVENTTYPE_MOUSE_DOWN,\n    SAPP_EVENTTYPE_MOUSE_UP,\n    SAPP_EVENTTYPE_MOUSE_SCROLL,\n    SAPP_EVENTTYPE_MOUSE_MOVE,\n    SAPP_EVENTTYPE_MOUSE_ENTER,\n    SAPP_EVENTTYPE_MOUSE_LEAVE,\n    SAPP_EVENTTYPE_TOUCHES_BEGAN,\n    SAPP_EVENTTYPE_TOUCHES_MOVED,\n    SAPP_EVENTTYPE_TOUCHES_ENDED,\n    SAPP_EVENTTYPE_TOUCHES_CANCELLED,\n    SAPP_EVENTTYPE_RESIZED,\n    SAPP_EVENTTYPE_ICONIFIED,\n    SAPP_EVENTTYPE_RESTORED,\n    SAPP_EVENTTYPE_FOCUSED,\n    SAPP_EVENTTYPE_UNFOCUSED,\n    SAPP_EVENTTYPE_SUSPENDED,\n    SAPP_EVENTTYPE_RESUMED,\n    SAPP_EVENTTYPE_QUIT_REQUESTED,\n    SAPP_EVENTTYPE_CLIPBOARD_PASTED,\n    SAPP_EVENTTYPE_FILES_DROPPED,\n    _SAPP_EVENTTYPE_NUM,\n    _SAPP_EVENTTYPE_FORCE_U32 = 0x7FFFFFFF\n} sapp_event_type;\n\n/*\n    sapp_keycode\n\n    The 'virtual keycode' of a KEY_DOWN or KEY_UP event in the\n    struct field sapp_event.key_code.\n\n    Note that the keycode values are identical with GLFW.\n*/\ntypedef enum sapp_keycode {\n    SAPP_KEYCODE_INVALID          = 0,\n    SAPP_KEYCODE_SPACE            = 32,\n    SAPP_KEYCODE_APOSTROPHE       = 39,  /* ' */\n    SAPP_KEYCODE_COMMA            = 44,  /* , */\n    SAPP_KEYCODE_MINUS            = 45,  /* - */\n    SAPP_KEYCODE_PERIOD           = 46,  /* . */\n    SAPP_KEYCODE_SLASH            = 47,  /* / */\n    SAPP_KEYCODE_0                = 48,\n    SAPP_KEYCODE_1                = 49,\n    SAPP_KEYCODE_2                = 50,\n    SAPP_KEYCODE_3                = 51,\n    SAPP_KEYCODE_4                = 52,\n    SAPP_KEYCODE_5                = 53,\n    SAPP_KEYCODE_6                = 54,\n    SAPP_KEYCODE_7                = 55,\n    SAPP_KEYCODE_8                = 56,\n    SAPP_KEYCODE_9                = 57,\n    SAPP_KEYCODE_SEMICOLON        = 59,  /* ; */\n    SAPP_KEYCODE_EQUAL            = 61,  /* = */\n    SAPP_KEYCODE_A                = 65,\n    SAPP_KEYCODE_B                = 66,\n    SAPP_KEYCODE_C                = 67,\n    SAPP_KEYCODE_D                = 68,\n    SAPP_KEYCODE_E                = 69,\n    SAPP_KEYCODE_F                = 70,\n    SAPP_KEYCODE_G                = 71,\n    SAPP_KEYCODE_H                = 72,\n    SAPP_KEYCODE_I                = 73,\n    SAPP_KEYCODE_J                = 74,\n    SAPP_KEYCODE_K                = 75,\n    SAPP_KEYCODE_L                = 76,\n    SAPP_KEYCODE_M                = 77,\n    SAPP_KEYCODE_N                = 78,\n    SAPP_KEYCODE_O                = 79,\n    SAPP_KEYCODE_P                = 80,\n    SAPP_KEYCODE_Q                = 81,\n    SAPP_KEYCODE_R                = 82,\n    SAPP_KEYCODE_S                = 83,\n    SAPP_KEYCODE_T                = 84,\n    SAPP_KEYCODE_U                = 85,\n    SAPP_KEYCODE_V                = 86,\n    SAPP_KEYCODE_W                = 87,\n    SAPP_KEYCODE_X                = 88,\n    SAPP_KEYCODE_Y                = 89,\n    SAPP_KEYCODE_Z                = 90,\n    SAPP_KEYCODE_LEFT_BRACKET     = 91,  /* [ */\n    SAPP_KEYCODE_BACKSLASH        = 92,  /* \\ */\n    SAPP_KEYCODE_RIGHT_BRACKET    = 93,  /* ] */\n    SAPP_KEYCODE_GRAVE_ACCENT     = 96,  /* ` */\n    SAPP_KEYCODE_WORLD_1          = 161, /* non-US #1 */\n    SAPP_KEYCODE_WORLD_2          = 162, /* non-US #2 */\n    SAPP_KEYCODE_ESCAPE           = 256,\n    SAPP_KEYCODE_ENTER            = 257,\n    SAPP_KEYCODE_TAB              = 258,\n    SAPP_KEYCODE_BACKSPACE        = 259,\n    SAPP_KEYCODE_INSERT           = 260,\n    SAPP_KEYCODE_DELETE           = 261,\n    SAPP_KEYCODE_RIGHT            = 262,\n    SAPP_KEYCODE_LEFT             = 263,\n    SAPP_KEYCODE_DOWN             = 264,\n    SAPP_KEYCODE_UP               = 265,\n    SAPP_KEYCODE_PAGE_UP          = 266,\n    SAPP_KEYCODE_PAGE_DOWN        = 267,\n    SAPP_KEYCODE_HOME             = 268,\n    SAPP_KEYCODE_END              = 269,\n    SAPP_KEYCODE_CAPS_LOCK        = 280,\n    SAPP_KEYCODE_SCROLL_LOCK      = 281,\n    SAPP_KEYCODE_NUM_LOCK         = 282,\n    SAPP_KEYCODE_PRINT_SCREEN     = 283,\n    SAPP_KEYCODE_PAUSE            = 284,\n    SAPP_KEYCODE_F1               = 290,\n    SAPP_KEYCODE_F2               = 291,\n    SAPP_KEYCODE_F3               = 292,\n    SAPP_KEYCODE_F4               = 293,\n    SAPP_KEYCODE_F5               = 294,\n    SAPP_KEYCODE_F6               = 295,\n    SAPP_KEYCODE_F7               = 296,\n    SAPP_KEYCODE_F8               = 297,\n    SAPP_KEYCODE_F9               = 298,\n    SAPP_KEYCODE_F10              = 299,\n    SAPP_KEYCODE_F11              = 300,\n    SAPP_KEYCODE_F12              = 301,\n    SAPP_KEYCODE_F13              = 302,\n    SAPP_KEYCODE_F14              = 303,\n    SAPP_KEYCODE_F15              = 304,\n    SAPP_KEYCODE_F16              = 305,\n    SAPP_KEYCODE_F17              = 306,\n    SAPP_KEYCODE_F18              = 307,\n    SAPP_KEYCODE_F19              = 308,\n    SAPP_KEYCODE_F20              = 309,\n    SAPP_KEYCODE_F21              = 310,\n    SAPP_KEYCODE_F22              = 311,\n    SAPP_KEYCODE_F23              = 312,\n    SAPP_KEYCODE_F24              = 313,\n    SAPP_KEYCODE_F25              = 314,\n    SAPP_KEYCODE_KP_0             = 320,\n    SAPP_KEYCODE_KP_1             = 321,\n    SAPP_KEYCODE_KP_2             = 322,\n    SAPP_KEYCODE_KP_3             = 323,\n    SAPP_KEYCODE_KP_4             = 324,\n    SAPP_KEYCODE_KP_5             = 325,\n    SAPP_KEYCODE_KP_6             = 326,\n    SAPP_KEYCODE_KP_7             = 327,\n    SAPP_KEYCODE_KP_8             = 328,\n    SAPP_KEYCODE_KP_9             = 329,\n    SAPP_KEYCODE_KP_DECIMAL       = 330,\n    SAPP_KEYCODE_KP_DIVIDE        = 331,\n    SAPP_KEYCODE_KP_MULTIPLY      = 332,\n    SAPP_KEYCODE_KP_SUBTRACT      = 333,\n    SAPP_KEYCODE_KP_ADD           = 334,\n    SAPP_KEYCODE_KP_ENTER         = 335,\n    SAPP_KEYCODE_KP_EQUAL         = 336,\n    SAPP_KEYCODE_LEFT_SHIFT       = 340,\n    SAPP_KEYCODE_LEFT_CONTROL     = 341,\n    SAPP_KEYCODE_LEFT_ALT         = 342,\n    SAPP_KEYCODE_LEFT_SUPER       = 343,\n    SAPP_KEYCODE_RIGHT_SHIFT      = 344,\n    SAPP_KEYCODE_RIGHT_CONTROL    = 345,\n    SAPP_KEYCODE_RIGHT_ALT        = 346,\n    SAPP_KEYCODE_RIGHT_SUPER      = 347,\n    SAPP_KEYCODE_MENU             = 348,\n} sapp_keycode;\n\n/*\n    Android specific 'tool type' enum for touch events. This lets the\n    application check what type of input device was used for\n    touch events.\n\n    NOTE: the values must remain in sync with the corresponding\n    Android SDK type, so don't change those.\n\n    See https://developer.android.com/reference/android/view/MotionEvent#TOOL_TYPE_UNKNOWN\n*/\ntypedef enum sapp_android_tooltype {\n    SAPP_ANDROIDTOOLTYPE_UNKNOWN = 0,   // TOOL_TYPE_UNKNOWN\n    SAPP_ANDROIDTOOLTYPE_FINGER = 1,    // TOOL_TYPE_FINGER\n    SAPP_ANDROIDTOOLTYPE_STYLUS = 2,    // TOOL_TYPE_STYLUS\n    SAPP_ANDROIDTOOLTYPE_MOUSE = 3,     // TOOL_TYPE_MOUSE\n} sapp_android_tooltype;\n\n/*\n    sapp_touchpoint\n\n    Describes a single touchpoint in a multitouch event (TOUCHES_BEGAN,\n    TOUCHES_MOVED, TOUCHES_ENDED).\n\n    Touch points are stored in the nested array sapp_event.touches[],\n    and the number of touches is stored in sapp_event.num_touches.\n*/\ntypedef struct sapp_touchpoint {\n    uintptr_t identifier;\n    float pos_x;\n    float pos_y;\n    sapp_android_tooltype android_tooltype; // only valid on Android\n    bool changed;\n} sapp_touchpoint;\n\n/*\n    sapp_mousebutton\n\n    The currently pressed mouse button in the events MOUSE_DOWN\n    and MOUSE_UP, stored in the struct field sapp_event.mouse_button.\n*/\ntypedef enum sapp_mousebutton {\n    SAPP_MOUSEBUTTON_LEFT = 0x0,\n    SAPP_MOUSEBUTTON_RIGHT = 0x1,\n    SAPP_MOUSEBUTTON_MIDDLE = 0x2,\n    SAPP_MOUSEBUTTON_INVALID = 0x100,\n} sapp_mousebutton;\n\n/*\n    These are currently pressed modifier keys (and mouse buttons) which are\n    passed in the event struct field sapp_event.modifiers.\n*/\nenum {\n    SAPP_MODIFIER_SHIFT = 0x1,      // left or right shift key\n    SAPP_MODIFIER_CTRL  = 0x2,      // left or right control key\n    SAPP_MODIFIER_ALT   = 0x4,      // left or right alt key\n    SAPP_MODIFIER_SUPER = 0x8,      // left or right 'super' key\n    SAPP_MODIFIER_LMB   = 0x100,    // left mouse button\n    SAPP_MODIFIER_RMB   = 0x200,    // right mouse button\n    SAPP_MODIFIER_MMB   = 0x400,    // middle mouse button\n};\n\n/*\n    sapp_event\n\n    This is an all-in-one event struct passed to the event handler\n    user callback function. Note that it depends on the event\n    type what struct fields actually contain useful values, so you\n    should first check the event type before reading other struct\n    fields.\n*/\ntypedef struct sapp_event {\n    uint64_t frame_count;               // current frame counter, always valid, useful for checking if two events were issued in the same frame\n    sapp_event_type type;               // the event type, always valid\n    sapp_keycode key_code;              // the virtual key code, only valid in KEY_UP, KEY_DOWN\n    uint32_t char_code;                 // the UTF-32 character code, only valid in CHAR events\n    bool key_repeat;                    // true if this is a key-repeat event, valid in KEY_UP, KEY_DOWN and CHAR\n    uint32_t modifiers;                 // current modifier keys, valid in all key-, char- and mouse-events\n    sapp_mousebutton mouse_button;      // mouse button that was pressed or released, valid in MOUSE_DOWN, MOUSE_UP\n    float mouse_x;                      // current horizontal mouse position in pixels, always valid except during mouse lock\n    float mouse_y;                      // current vertical mouse position in pixels, always valid except during mouse lock\n    float mouse_dx;                     // relative horizontal mouse movement since last frame, always valid\n    float mouse_dy;                     // relative vertical mouse movement since last frame, always valid\n    float scroll_x;                     // horizontal mouse wheel scroll distance, valid in MOUSE_SCROLL events\n    float scroll_y;                     // vertical mouse wheel scroll distance, valid in MOUSE_SCROLL events\n    int num_touches;                    // number of valid items in the touches[] array\n    sapp_touchpoint touches[SAPP_MAX_TOUCHPOINTS];  // current touch points, valid in TOUCHES_BEGIN, TOUCHES_MOVED, TOUCHES_ENDED\n    int window_width;                   // current window- and framebuffer sizes in pixels, always valid\n    int window_height;\n    int framebuffer_width;              // = window_width * dpi_scale\n    int framebuffer_height;             // = window_height * dpi_scale\n} sapp_event;\n\n/*\n    sg_range\n\n    A general pointer/size-pair struct and constructor macros for passing binary blobs\n    into sokol_app.h.\n*/\ntypedef struct sapp_range {\n    const void* ptr;\n    size_t size;\n} sapp_range;\n// disabling this for every includer isn't great, but the warnings are also quite pointless\n#if defined(_MSC_VER)\n#pragma warning(disable:4221)   /* /W4 only: nonstandard extension used: 'x': cannot be initialized using address of automatic variable 'y' */\n#pragma warning(disable:4204)   /* VS2015: nonstandard extension used: non-constant aggregate initializer */\n#endif\n#if defined(__cplusplus)\n#define SAPP_RANGE(x) sapp_range{ &x, sizeof(x) }\n#else\n#define SAPP_RANGE(x) (sapp_range){ &x, sizeof(x) }\n#endif\n\n/*\n    sapp_image_desc\n\n    This is used to describe image data to sokol_app.h (at first, window\n    icons, later maybe cursor images).\n\n    Note that the actual image pixel format depends on the use case:\n\n    - window icon pixels are RGBA8\n*/\ntypedef struct sapp_image_desc {\n    int width;\n    int height;\n    sapp_range pixels;\n} sapp_image_desc;\n\n/*\n    sapp_icon_desc\n\n    An icon description structure for use in sapp_desc.icon and\n    sapp_set_icon().\n\n    When setting a custom image, the application can provide a number of\n    candidates differing in size, and sokol_app.h will pick the image(s)\n    closest to the size expected by the platform's window system.\n\n    To set sokol-app's default icon, set .sokol_default to true.\n\n    Otherwise provide candidate images of different sizes in the\n    images[] array.\n\n    If both the sokol_default flag is set to true, any image candidates\n    will be ignored and the sokol_app.h default icon will be set.\n*/\ntypedef struct sapp_icon_desc {\n    bool sokol_default;\n    sapp_image_desc images[SAPP_MAX_ICONIMAGES];\n} sapp_icon_desc;\n\n/*\n    sapp_allocator\n\n    Used in sapp_desc to provide custom memory-alloc and -free functions\n    to sokol_app.h. If memory management should be overridden, both the\n    alloc_fn and free_fn function must be provided (e.g. it's not valid to\n    override one function but not the other).\n*/\ntypedef struct sapp_allocator {\n    void* (*alloc_fn)(size_t size, void* user_data);\n    void (*free_fn)(void* ptr, void* user_data);\n    void* user_data;\n} sapp_allocator;\n\n/*\n    sapp_log_item\n\n    Log items are defined via X-Macros and expanded to an enum\n    'sapp_log_item', and in debug mode to corresponding\n    human readable error messages.\n*/\n#define _SAPP_LOG_ITEMS \\\n    _SAPP_LOGITEM_XMACRO(OK, \"Ok\") \\\n    _SAPP_LOGITEM_XMACRO(MALLOC_FAILED, \"memory allocation failed\") \\\n    _SAPP_LOGITEM_XMACRO(MACOS_INVALID_NSOPENGL_PROFILE, \"macos: invalid NSOpenGLProfile (valid choices are 1.0 and 4.1)\") \\\n    _SAPP_LOGITEM_XMACRO(WIN32_LOAD_OPENGL32_DLL_FAILED, \"failed loading opengl32.dll\") \\\n    _SAPP_LOGITEM_XMACRO(WIN32_CREATE_HELPER_WINDOW_FAILED, \"failed to create helper window\") \\\n    _SAPP_LOGITEM_XMACRO(WIN32_HELPER_WINDOW_GETDC_FAILED, \"failed to get helper window DC\") \\\n    _SAPP_LOGITEM_XMACRO(WIN32_DUMMY_CONTEXT_SET_PIXELFORMAT_FAILED, \"failed to set pixel format for dummy GL context\") \\\n    _SAPP_LOGITEM_XMACRO(WIN32_CREATE_DUMMY_CONTEXT_FAILED, \"failed to create dummy GL context\") \\\n    _SAPP_LOGITEM_XMACRO(WIN32_DUMMY_CONTEXT_MAKE_CURRENT_FAILED, \"failed to make dummy GL context current\") \\\n    _SAPP_LOGITEM_XMACRO(WIN32_GET_PIXELFORMAT_ATTRIB_FAILED, \"failed to get WGL pixel format attribute\") \\\n    _SAPP_LOGITEM_XMACRO(WIN32_WGL_FIND_PIXELFORMAT_FAILED, \"failed to find matching WGL pixel format\") \\\n    _SAPP_LOGITEM_XMACRO(WIN32_WGL_DESCRIBE_PIXELFORMAT_FAILED, \"failed to get pixel format descriptor\") \\\n    _SAPP_LOGITEM_XMACRO(WIN32_WGL_SET_PIXELFORMAT_FAILED, \"failed to set selected pixel format\") \\\n    _SAPP_LOGITEM_XMACRO(WIN32_WGL_ARB_CREATE_CONTEXT_REQUIRED, \"ARB_create_context required\") \\\n    _SAPP_LOGITEM_XMACRO(WIN32_WGL_ARB_CREATE_CONTEXT_PROFILE_REQUIRED, \"ARB_create_context_profile required\") \\\n    _SAPP_LOGITEM_XMACRO(WIN32_WGL_OPENGL_VERSION_NOT_SUPPORTED, \"requested OpenGL version not supported by GL driver (ERROR_INVALID_VERSION_ARB)\") \\\n    _SAPP_LOGITEM_XMACRO(WIN32_WGL_OPENGL_PROFILE_NOT_SUPPORTED, \"requested OpenGL profile not support by GL driver (ERROR_INVALID_PROFILE_ARB)\") \\\n    _SAPP_LOGITEM_XMACRO(WIN32_WGL_INCOMPATIBLE_DEVICE_CONTEXT, \"CreateContextAttribsARB failed with ERROR_INCOMPATIBLE_DEVICE_CONTEXTS_ARB\") \\\n    _SAPP_LOGITEM_XMACRO(WIN32_WGL_CREATE_CONTEXT_ATTRIBS_FAILED_OTHER, \"CreateContextAttribsARB failed for other reason\") \\\n    _SAPP_LOGITEM_XMACRO(WIN32_D3D11_CREATE_DEVICE_AND_SWAPCHAIN_WITH_DEBUG_FAILED, \"D3D11CreateDeviceAndSwapChain() with D3D11_CREATE_DEVICE_DEBUG failed, retrying without debug flag.\") \\\n    _SAPP_LOGITEM_XMACRO(WIN32_D3D11_GET_IDXGIFACTORY_FAILED, \"could not obtain IDXGIFactory object\") \\\n    _SAPP_LOGITEM_XMACRO(WIN32_D3D11_GET_IDXGIADAPTER_FAILED, \"could not obtain IDXGIAdapter object\") \\\n    _SAPP_LOGITEM_XMACRO(WIN32_D3D11_QUERY_INTERFACE_IDXGIDEVICE1_FAILED, \"could not obtain IDXGIDevice1 interface\") \\\n    _SAPP_LOGITEM_XMACRO(WIN32_REGISTER_RAW_INPUT_DEVICES_FAILED_MOUSE_LOCK, \"RegisterRawInputDevices() failed (on mouse lock)\") \\\n    _SAPP_LOGITEM_XMACRO(WIN32_REGISTER_RAW_INPUT_DEVICES_FAILED_MOUSE_UNLOCK, \"RegisterRawInputDevices() failed (on mouse unlock)\") \\\n    _SAPP_LOGITEM_XMACRO(WIN32_GET_RAW_INPUT_DATA_FAILED, \"GetRawInputData() failed\") \\\n    _SAPP_LOGITEM_XMACRO(LINUX_GLX_LOAD_LIBGL_FAILED, \"failed to load libGL\") \\\n    _SAPP_LOGITEM_XMACRO(LINUX_GLX_LOAD_ENTRY_POINTS_FAILED, \"failed to load GLX entry points\") \\\n    _SAPP_LOGITEM_XMACRO(LINUX_GLX_EXTENSION_NOT_FOUND, \"GLX extension not found\") \\\n    _SAPP_LOGITEM_XMACRO(LINUX_GLX_QUERY_VERSION_FAILED, \"failed to query GLX version\") \\\n    _SAPP_LOGITEM_XMACRO(LINUX_GLX_VERSION_TOO_LOW, \"GLX version too low (need at least 1.3)\") \\\n    _SAPP_LOGITEM_XMACRO(LINUX_GLX_NO_GLXFBCONFIGS, \"glXGetFBConfigs() returned no configs\") \\\n    _SAPP_LOGITEM_XMACRO(LINUX_GLX_NO_SUITABLE_GLXFBCONFIG, \"failed to find a suitable GLXFBConfig\") \\\n    _SAPP_LOGITEM_XMACRO(LINUX_GLX_GET_VISUAL_FROM_FBCONFIG_FAILED, \"glXGetVisualFromFBConfig failed\") \\\n    _SAPP_LOGITEM_XMACRO(LINUX_GLX_REQUIRED_EXTENSIONS_MISSING, \"GLX extensions ARB_create_context and ARB_create_context_profile missing\") \\\n    _SAPP_LOGITEM_XMACRO(LINUX_GLX_CREATE_CONTEXT_FAILED, \"Failed to create GL context via glXCreateContextAttribsARB\") \\\n    _SAPP_LOGITEM_XMACRO(LINUX_GLX_CREATE_WINDOW_FAILED, \"glXCreateWindow() failed\") \\\n    _SAPP_LOGITEM_XMACRO(LINUX_X11_CREATE_WINDOW_FAILED, \"XCreateWindow() failed\") \\\n    _SAPP_LOGITEM_XMACRO(LINUX_EGL_BIND_OPENGL_API_FAILED, \"eglBindAPI(EGL_OPENGL_API) failed\") \\\n    _SAPP_LOGITEM_XMACRO(LINUX_EGL_BIND_OPENGL_ES_API_FAILED, \"eglBindAPI(EGL_OPENGL_ES_API) failed\") \\\n    _SAPP_LOGITEM_XMACRO(LINUX_EGL_GET_DISPLAY_FAILED, \"eglGetDisplay() failed\") \\\n    _SAPP_LOGITEM_XMACRO(LINUX_EGL_INITIALIZE_FAILED, \"eglInitialize() failed\") \\\n    _SAPP_LOGITEM_XMACRO(LINUX_EGL_NO_CONFIGS, \"eglChooseConfig() returned no configs\") \\\n    _SAPP_LOGITEM_XMACRO(LINUX_EGL_NO_NATIVE_VISUAL, \"eglGetConfigAttrib() for EGL_NATIVE_VISUAL_ID failed\") \\\n    _SAPP_LOGITEM_XMACRO(LINUX_EGL_GET_VISUAL_INFO_FAILED, \"XGetVisualInfo() failed\") \\\n    _SAPP_LOGITEM_XMACRO(LINUX_EGL_CREATE_WINDOW_SURFACE_FAILED, \"eglCreateWindowSurface() failed\") \\\n    _SAPP_LOGITEM_XMACRO(LINUX_EGL_CREATE_CONTEXT_FAILED, \"eglCreateContext() failed\") \\\n    _SAPP_LOGITEM_XMACRO(LINUX_EGL_MAKE_CURRENT_FAILED, \"eglMakeCurrent() failed\") \\\n    _SAPP_LOGITEM_XMACRO(LINUX_X11_OPEN_DISPLAY_FAILED, \"XOpenDisplay() failed\") \\\n    _SAPP_LOGITEM_XMACRO(LINUX_X11_QUERY_SYSTEM_DPI_FAILED, \"failed to query system dpi value, assuming default 96.0\") \\\n    _SAPP_LOGITEM_XMACRO(LINUX_X11_DROPPED_FILE_URI_WRONG_SCHEME, \"dropped file URL doesn't start with 'file://'\") \\\n    _SAPP_LOGITEM_XMACRO(LINUX_X11_FAILED_TO_BECOME_OWNER_OF_CLIPBOARD, \"X11: Failed to become owner of clipboard selection\") \\\n    _SAPP_LOGITEM_XMACRO(ANDROID_UNSUPPORTED_INPUT_EVENT_INPUT_CB, \"unsupported input event encountered in _sapp_android_input_cb()\") \\\n    _SAPP_LOGITEM_XMACRO(ANDROID_UNSUPPORTED_INPUT_EVENT_MAIN_CB, \"unsupported input event encountered in _sapp_android_main_cb()\") \\\n    _SAPP_LOGITEM_XMACRO(ANDROID_READ_MSG_FAILED, \"failed to read message in _sapp_android_main_cb()\") \\\n    _SAPP_LOGITEM_XMACRO(ANDROID_WRITE_MSG_FAILED, \"failed to write message in _sapp_android_msg\") \\\n    _SAPP_LOGITEM_XMACRO(ANDROID_MSG_CREATE, \"MSG_CREATE\") \\\n    _SAPP_LOGITEM_XMACRO(ANDROID_MSG_RESUME, \"MSG_RESUME\") \\\n    _SAPP_LOGITEM_XMACRO(ANDROID_MSG_PAUSE, \"MSG_PAUSE\") \\\n    _SAPP_LOGITEM_XMACRO(ANDROID_MSG_FOCUS, \"MSG_FOCUS\") \\\n    _SAPP_LOGITEM_XMACRO(ANDROID_MSG_NO_FOCUS, \"MSG_NO_FOCUS\") \\\n    _SAPP_LOGITEM_XMACRO(ANDROID_MSG_SET_NATIVE_WINDOW, \"MSG_SET_NATIVE_WINDOW\") \\\n    _SAPP_LOGITEM_XMACRO(ANDROID_MSG_SET_INPUT_QUEUE, \"MSG_SET_INPUT_QUEUE\") \\\n    _SAPP_LOGITEM_XMACRO(ANDROID_MSG_DESTROY, \"MSG_DESTROY\") \\\n    _SAPP_LOGITEM_XMACRO(ANDROID_UNKNOWN_MSG, \"unknown msg type received\") \\\n    _SAPP_LOGITEM_XMACRO(ANDROID_LOOP_THREAD_STARTED, \"loop thread started\") \\\n    _SAPP_LOGITEM_XMACRO(ANDROID_LOOP_THREAD_DONE, \"loop thread done\") \\\n    _SAPP_LOGITEM_XMACRO(ANDROID_NATIVE_ACTIVITY_ONSTART, \"NativeActivity onStart()\") \\\n    _SAPP_LOGITEM_XMACRO(ANDROID_NATIVE_ACTIVITY_ONRESUME, \"NativeActivity onResume\") \\\n    _SAPP_LOGITEM_XMACRO(ANDROID_NATIVE_ACTIVITY_ONSAVEINSTANCESTATE, \"NativeActivity onSaveInstanceState\") \\\n    _SAPP_LOGITEM_XMACRO(ANDROID_NATIVE_ACTIVITY_ONWINDOWFOCUSCHANGED, \"NativeActivity onWindowFocusChanged\") \\\n    _SAPP_LOGITEM_XMACRO(ANDROID_NATIVE_ACTIVITY_ONPAUSE, \"NativeActivity onPause\") \\\n    _SAPP_LOGITEM_XMACRO(ANDROID_NATIVE_ACTIVITY_ONSTOP, \"NativeActivity onStop()\") \\\n    _SAPP_LOGITEM_XMACRO(ANDROID_NATIVE_ACTIVITY_ONNATIVEWINDOWCREATED, \"NativeActivity onNativeWindowCreated\") \\\n    _SAPP_LOGITEM_XMACRO(ANDROID_NATIVE_ACTIVITY_ONNATIVEWINDOWDESTROYED, \"NativeActivity onNativeWindowDestroyed\") \\\n    _SAPP_LOGITEM_XMACRO(ANDROID_NATIVE_ACTIVITY_ONINPUTQUEUECREATED, \"NativeActivity onInputQueueCreated\") \\\n    _SAPP_LOGITEM_XMACRO(ANDROID_NATIVE_ACTIVITY_ONINPUTQUEUEDESTROYED, \"NativeActivity onInputQueueDestroyed\") \\\n    _SAPP_LOGITEM_XMACRO(ANDROID_NATIVE_ACTIVITY_ONCONFIGURATIONCHANGED, \"NativeActivity onConfigurationChanged\") \\\n    _SAPP_LOGITEM_XMACRO(ANDROID_NATIVE_ACTIVITY_ONLOWMEMORY, \"NativeActivity onLowMemory\") \\\n    _SAPP_LOGITEM_XMACRO(ANDROID_NATIVE_ACTIVITY_ONDESTROY, \"NativeActivity onDestroy\") \\\n    _SAPP_LOGITEM_XMACRO(ANDROID_NATIVE_ACTIVITY_DONE, \"NativeActivity done\") \\\n    _SAPP_LOGITEM_XMACRO(ANDROID_NATIVE_ACTIVITY_ONCREATE, \"NativeActivity onCreate\") \\\n    _SAPP_LOGITEM_XMACRO(ANDROID_CREATE_THREAD_PIPE_FAILED, \"failed to create thread pipe\") \\\n    _SAPP_LOGITEM_XMACRO(ANDROID_NATIVE_ACTIVITY_CREATE_SUCCESS, \"NativeActivity successfully created\") \\\n    _SAPP_LOGITEM_XMACRO(WGPU_SWAPCHAIN_CREATE_SURFACE_FAILED, \"wgpu: failed to create surface for swapchain\") \\\n    _SAPP_LOGITEM_XMACRO(WGPU_SWAPCHAIN_CREATE_SWAPCHAIN_FAILED, \"wgpu: failed to create swapchain object\") \\\n    _SAPP_LOGITEM_XMACRO(WGPU_SWAPCHAIN_CREATE_DEPTH_STENCIL_TEXTURE_FAILED, \"wgpu: failed to create depth-stencil texture for swapchain\") \\\n    _SAPP_LOGITEM_XMACRO(WGPU_SWAPCHAIN_CREATE_DEPTH_STENCIL_VIEW_FAILED, \"wgpu: failed to create view object for swapchain depth-stencil texture\") \\\n    _SAPP_LOGITEM_XMACRO(WGPU_SWAPCHAIN_CREATE_MSAA_TEXTURE_FAILED, \"wgpu: failed to create msaa texture for swapchain\") \\\n    _SAPP_LOGITEM_XMACRO(WGPU_SWAPCHAIN_CREATE_MSAA_VIEW_FAILED, \"wgpu: failed to create view object for swapchain msaa texture\") \\\n    _SAPP_LOGITEM_XMACRO(WGPU_REQUEST_DEVICE_STATUS_ERROR, \"wgpu: requesting device failed with status 'error'\") \\\n    _SAPP_LOGITEM_XMACRO(WGPU_REQUEST_DEVICE_STATUS_UNKNOWN, \"wgpu: requesting device failed with status 'unknown'\") \\\n    _SAPP_LOGITEM_XMACRO(WGPU_REQUEST_ADAPTER_STATUS_UNAVAILABLE, \"wgpu: requesting adapter failed with 'unavailable'\") \\\n    _SAPP_LOGITEM_XMACRO(WGPU_REQUEST_ADAPTER_STATUS_ERROR, \"wgpu: requesting adapter failed with status 'error'\") \\\n    _SAPP_LOGITEM_XMACRO(WGPU_REQUEST_ADAPTER_STATUS_UNKNOWN, \"wgpu: requesting adapter failed with status 'unknown'\") \\\n    _SAPP_LOGITEM_XMACRO(WGPU_CREATE_INSTANCE_FAILED, \"wgpu: failed to create instance\") \\\n    _SAPP_LOGITEM_XMACRO(IMAGE_DATA_SIZE_MISMATCH, \"image data size mismatch (must be width*height*4 bytes)\") \\\n    _SAPP_LOGITEM_XMACRO(DROPPED_FILE_PATH_TOO_LONG, \"dropped file path too long (sapp_desc.max_dropped_filed_path_length)\") \\\n    _SAPP_LOGITEM_XMACRO(CLIPBOARD_STRING_TOO_BIG, \"clipboard string didn't fit into clipboard buffer\") \\\n\n#define _SAPP_LOGITEM_XMACRO(item,msg) SAPP_LOGITEM_##item,\ntypedef enum sapp_log_item {\n    _SAPP_LOG_ITEMS\n} sapp_log_item;\n#undef _SAPP_LOGITEM_XMACRO\n\n/*\n    sapp_logger\n\n    Used in sapp_desc to provide a logging function. Please be aware that\n    without logging function, sokol-app will be completely silent, e.g. it will\n    not report errors or warnings. For maximum error verbosity, compile in\n    debug mode (e.g. NDEBUG *not* defined) and install a logger (for instance\n    the standard logging function from sokol_log.h).\n*/\ntypedef struct sapp_logger {\n    void (*func)(\n        const char* tag,                // always \"sapp\"\n        uint32_t log_level,             // 0=panic, 1=error, 2=warning, 3=info\n        uint32_t log_item_id,           // SAPP_LOGITEM_*\n        const char* message_or_null,    // a message string, may be nullptr in release mode\n        uint32_t line_nr,               // line number in sokol_app.h\n        const char* filename_or_null,   // source filename, may be nullptr in release mode\n        void* user_data);\n    void* user_data;\n} sapp_logger;\n\n/*\n    sokol-app initialization options, used as return value of sokol_main()\n    or sapp_run() argument.\n*/\ntypedef struct sapp_desc {\n    void (*init_cb)(void);                  // these are the user-provided callbacks without user data\n    void (*frame_cb)(void);\n    void (*cleanup_cb)(void);\n    void (*event_cb)(const sapp_event*);\n\n    void* user_data;                        // these are the user-provided callbacks with user data\n    void (*init_userdata_cb)(void*);\n    void (*frame_userdata_cb)(void*);\n    void (*cleanup_userdata_cb)(void*);\n    void (*event_userdata_cb)(const sapp_event*, void*);\n\n    int width;                          // the preferred width of the window / canvas\n    int height;                         // the preferred height of the window / canvas\n    int sample_count;                   // MSAA sample count\n    int swap_interval;                  // the preferred swap interval (ignored on some platforms)\n    bool high_dpi;                      // whether the rendering canvas is full-resolution on HighDPI displays\n    bool fullscreen;                    // whether the window should be created in fullscreen mode\n    bool alpha;                         // whether the framebuffer should have an alpha channel (ignored on some platforms)\n    const char* window_title;           // the window title as UTF-8 encoded string\n    bool enable_clipboard;              // enable clipboard access, default is false\n    int clipboard_size;                 // max size of clipboard content in bytes\n    bool enable_dragndrop;              // enable file dropping (drag'n'drop), default is false\n    int max_dropped_files;              // max number of dropped files to process (default: 1)\n    int max_dropped_file_path_length;   // max length in bytes of a dropped UTF-8 file path (default: 2048)\n    sapp_icon_desc icon;                // the initial window icon to set\n    sapp_allocator allocator;           // optional memory allocation overrides (default: malloc/free)\n    sapp_logger logger;                 // logging callback override (default: NO LOGGING!)\n\n    // backend-specific options\n    int gl_major_version;               // override GL major and minor version (the default GL version is 4.1 on macOS, 4.3 elsewhere)\n    int gl_minor_version;\n    bool win32_console_utf8;            // if true, set the output console codepage to UTF-8\n    bool win32_console_create;          // if true, attach stdout/stderr to a new console window\n    bool win32_console_attach;          // if true, attach stdout/stderr to parent process\n    const char* html5_canvas_selector;  // css selector of the HTML5 canvas element, default is \"#canvas\"\n    bool html5_canvas_resize;           // if true, the HTML5 canvas size is set to sapp_desc.width/height, otherwise canvas size is tracked\n    bool html5_preserve_drawing_buffer; // HTML5 only: whether to preserve default framebuffer content between frames\n    bool html5_premultiplied_alpha;     // HTML5 only: whether the rendered pixels use premultiplied alpha convention\n    bool html5_ask_leave_site;          // initial state of the internal html5_ask_leave_site flag (see sapp_html5_ask_leave_site())\n    bool html5_update_document_title;   // if true, update the HTML document.title with sapp_desc.window_title\n    bool html5_bubble_mouse_events;     // if true, mouse events will bubble up to the web page\n    bool html5_bubble_touch_events;     // same for touch events\n    bool html5_bubble_wheel_events;     // same for wheel events\n    bool html5_bubble_key_events;       // if true, bubble up *all* key events to browser, not just key events that represent characters\n    bool html5_bubble_char_events;      // if true, bubble up character events to browser\n    bool html5_use_emsc_set_main_loop;  // if true, use emscripten_set_main_loop() instead of emscripten_request_animation_frame_loop()\n    bool html5_emsc_set_main_loop_simulate_infinite_loop;   // this will be passed as the simulate_infinite_loop arg to emscripten_set_main_loop()\n    bool ios_keyboard_resizes_canvas;   // if true, showing the iOS keyboard shrinks the canvas\n} sapp_desc;\n\n/* HTML5 specific: request and response structs for\n   asynchronously loading dropped-file content.\n*/\ntypedef enum sapp_html5_fetch_error {\n    SAPP_HTML5_FETCH_ERROR_NO_ERROR,\n    SAPP_HTML5_FETCH_ERROR_BUFFER_TOO_SMALL,\n    SAPP_HTML5_FETCH_ERROR_OTHER,\n} sapp_html5_fetch_error;\n\ntypedef struct sapp_html5_fetch_response {\n    bool succeeded;         // true if the loading operation has succeeded\n    sapp_html5_fetch_error error_code;\n    int file_index;         // index of the dropped file (0..sapp_get_num_dropped_filed()-1)\n    sapp_range data;        // pointer and size of the fetched data (data.ptr == buffer.ptr, data.size <= buffer.size)\n    sapp_range buffer;      // the user-provided buffer ptr/size pair (buffer.ptr == data.ptr, buffer.size >= data.size)\n    void* user_data;        // user-provided user data pointer\n} sapp_html5_fetch_response;\n\ntypedef struct sapp_html5_fetch_request {\n    int dropped_file_index; // 0..sapp_get_num_dropped_files()-1\n    void (*callback)(const sapp_html5_fetch_response*);     // response callback function pointer (required)\n    sapp_range buffer;      // ptr/size of a memory buffer to load the data into\n    void* user_data;        // optional userdata pointer\n} sapp_html5_fetch_request;\n\n/*\n    sapp_mouse_cursor\n\n    Predefined cursor image definitions, set with sapp_set_mouse_cursor(sapp_mouse_cursor cursor)\n*/\ntypedef enum sapp_mouse_cursor {\n    SAPP_MOUSECURSOR_DEFAULT = 0,   // equivalent with system default cursor\n    SAPP_MOUSECURSOR_ARROW,\n    SAPP_MOUSECURSOR_IBEAM,\n    SAPP_MOUSECURSOR_CROSSHAIR,\n    SAPP_MOUSECURSOR_POINTING_HAND,\n    SAPP_MOUSECURSOR_RESIZE_EW,\n    SAPP_MOUSECURSOR_RESIZE_NS,\n    SAPP_MOUSECURSOR_RESIZE_NWSE,\n    SAPP_MOUSECURSOR_RESIZE_NESW,\n    SAPP_MOUSECURSOR_RESIZE_ALL,\n    SAPP_MOUSECURSOR_NOT_ALLOWED,\n    _SAPP_MOUSECURSOR_NUM,\n} sapp_mouse_cursor;\n\n/* user-provided functions */\nextern sapp_desc sokol_main(int argc, char* argv[]);\n\n/* returns true after sokol-app has been initialized */\nSOKOL_APP_API_DECL bool sapp_isvalid(void);\n/* returns the current framebuffer width in pixels */\nSOKOL_APP_API_DECL int sapp_width(void);\n/* same as sapp_width(), but returns float */\nSOKOL_APP_API_DECL float sapp_widthf(void);\n/* returns the current framebuffer height in pixels */\nSOKOL_APP_API_DECL int sapp_height(void);\n/* same as sapp_height(), but returns float */\nSOKOL_APP_API_DECL float sapp_heightf(void);\n/* get default framebuffer color pixel format */\nSOKOL_APP_API_DECL int sapp_color_format(void);\n/* get default framebuffer depth pixel format */\nSOKOL_APP_API_DECL int sapp_depth_format(void);\n/* get default framebuffer sample count */\nSOKOL_APP_API_DECL int sapp_sample_count(void);\n/* returns true when high_dpi was requested and actually running in a high-dpi scenario */\nSOKOL_APP_API_DECL bool sapp_high_dpi(void);\n/* returns the dpi scaling factor (window pixels to framebuffer pixels) */\nSOKOL_APP_API_DECL float sapp_dpi_scale(void);\n/* show or hide the mobile device onscreen keyboard */\nSOKOL_APP_API_DECL void sapp_show_keyboard(bool show);\n/* return true if the mobile device onscreen keyboard is currently shown */\nSOKOL_APP_API_DECL bool sapp_keyboard_shown(void);\n/* query fullscreen mode */\nSOKOL_APP_API_DECL bool sapp_is_fullscreen(void);\n/* toggle fullscreen mode */\nSOKOL_APP_API_DECL void sapp_toggle_fullscreen(void);\n/* show or hide the mouse cursor */\nSOKOL_APP_API_DECL void sapp_show_mouse(bool show);\n/* show or hide the mouse cursor */\nSOKOL_APP_API_DECL bool sapp_mouse_shown(void);\n/* enable/disable mouse-pointer-lock mode */\nSOKOL_APP_API_DECL void sapp_lock_mouse(bool lock);\n/* return true if in mouse-pointer-lock mode (this may toggle a few frames later) */\nSOKOL_APP_API_DECL bool sapp_mouse_locked(void);\n/* set mouse cursor type */\nSOKOL_APP_API_DECL void sapp_set_mouse_cursor(sapp_mouse_cursor cursor);\n/* get current mouse cursor type */\nSOKOL_APP_API_DECL sapp_mouse_cursor sapp_get_mouse_cursor(void);\n/* return the userdata pointer optionally provided in sapp_desc */\nSOKOL_APP_API_DECL void* sapp_userdata(void);\n/* return a copy of the sapp_desc structure */\nSOKOL_APP_API_DECL sapp_desc sapp_query_desc(void);\n/* initiate a \"soft quit\" (sends SAPP_EVENTTYPE_QUIT_REQUESTED) */\nSOKOL_APP_API_DECL void sapp_request_quit(void);\n/* cancel a pending quit (when SAPP_EVENTTYPE_QUIT_REQUESTED has been received) */\nSOKOL_APP_API_DECL void sapp_cancel_quit(void);\n/* initiate a \"hard quit\" (quit application without sending SAPP_EVENTTYPE_QUIT_REQUESTED) */\nSOKOL_APP_API_DECL void sapp_quit(void);\n/* call from inside event callback to consume the current event (don't forward to platform) */\nSOKOL_APP_API_DECL void sapp_consume_event(void);\n/* get the current frame counter (for comparison with sapp_event.frame_count) */\nSOKOL_APP_API_DECL uint64_t sapp_frame_count(void);\n/* get an averaged/smoothed frame duration in seconds */\nSOKOL_APP_API_DECL double sapp_frame_duration(void);\n/* write string into clipboard */\nSOKOL_APP_API_DECL void sapp_set_clipboard_string(const char* str);\n/* read string from clipboard (usually during SAPP_EVENTTYPE_CLIPBOARD_PASTED) */\nSOKOL_APP_API_DECL const char* sapp_get_clipboard_string(void);\n/* set the window title (only on desktop platforms) */\nSOKOL_APP_API_DECL void sapp_set_window_title(const char* str);\n/* set the window icon (only on Windows and Linux) */\nSOKOL_APP_API_DECL void sapp_set_icon(const sapp_icon_desc* icon_desc);\n/* gets the total number of dropped files (after an SAPP_EVENTTYPE_FILES_DROPPED event) */\nSOKOL_APP_API_DECL int sapp_get_num_dropped_files(void);\n/* gets the dropped file paths */\nSOKOL_APP_API_DECL const char* sapp_get_dropped_file_path(int index);\n\n/* special run-function for SOKOL_NO_ENTRY (in standard mode this is an empty stub) */\nSOKOL_APP_API_DECL void sapp_run(const sapp_desc* desc);\n\n/* EGL: get EGLDisplay object */\nSOKOL_APP_API_DECL const void* sapp_egl_get_display(void);\n/* EGL: get EGLContext object */\nSOKOL_APP_API_DECL const void* sapp_egl_get_context(void);\n\n/* HTML5: enable or disable the hardwired \"Leave Site?\" dialog box */\nSOKOL_APP_API_DECL void sapp_html5_ask_leave_site(bool ask);\n/* HTML5: get byte size of a dropped file */\nSOKOL_APP_API_DECL uint32_t sapp_html5_get_dropped_file_size(int index);\n/* HTML5: asynchronously load the content of a dropped file */\nSOKOL_APP_API_DECL void sapp_html5_fetch_dropped_file(const sapp_html5_fetch_request* request);\n\n/* Metal: get bridged pointer to Metal device object */\nSOKOL_APP_API_DECL const void* sapp_metal_get_device(void);\n/* Metal: get bridged pointer to MTKView's current drawable of type CAMetalDrawable */\nSOKOL_APP_API_DECL const void* sapp_metal_get_current_drawable(void);\n/* Metal: get bridged pointer to MTKView's depth-stencil texture of type MTLTexture */\nSOKOL_APP_API_DECL const void* sapp_metal_get_depth_stencil_texture(void);\n/* Metal: get bridged pointer to MTKView's msaa-color-texture of type MTLTexture (may be null) */\nSOKOL_APP_API_DECL const void* sapp_metal_get_msaa_color_texture(void);\n/* macOS: get bridged pointer to macOS NSWindow */\nSOKOL_APP_API_DECL const void* sapp_macos_get_window(void);\n/* iOS: get bridged pointer to iOS UIWindow */\nSOKOL_APP_API_DECL const void* sapp_ios_get_window(void);\n\n/* D3D11: get pointer to ID3D11Device object */\nSOKOL_APP_API_DECL const void* sapp_d3d11_get_device(void);\n/* D3D11: get pointer to ID3D11DeviceContext object */\nSOKOL_APP_API_DECL const void* sapp_d3d11_get_device_context(void);\n/* D3D11: get pointer to IDXGISwapChain object */\nSOKOL_APP_API_DECL const void* sapp_d3d11_get_swap_chain(void);\n/* D3D11: get pointer to ID3D11RenderTargetView object for rendering */\nSOKOL_APP_API_DECL const void* sapp_d3d11_get_render_view(void);\n/* D3D11: get pointer ID3D11RenderTargetView object for msaa-resolve (may return null) */\nSOKOL_APP_API_DECL const void* sapp_d3d11_get_resolve_view(void);\n/* D3D11: get pointer ID3D11DepthStencilView */\nSOKOL_APP_API_DECL const void* sapp_d3d11_get_depth_stencil_view(void);\n/* Win32: get the HWND window handle */\nSOKOL_APP_API_DECL const void* sapp_win32_get_hwnd(void);\n\n/* WebGPU: get WGPUDevice handle */\nSOKOL_APP_API_DECL const void* sapp_wgpu_get_device(void);\n/* WebGPU: get swapchain's WGPUTextureView handle for rendering */\nSOKOL_APP_API_DECL const void* sapp_wgpu_get_render_view(void);\n/* WebGPU: get swapchain's MSAA-resolve WGPUTextureView (may return null) */\nSOKOL_APP_API_DECL const void* sapp_wgpu_get_resolve_view(void);\n/* WebGPU: get swapchain's WGPUTextureView for the depth-stencil surface */\nSOKOL_APP_API_DECL const void* sapp_wgpu_get_depth_stencil_view(void);\n\n/* GL: get framebuffer object */\nSOKOL_APP_API_DECL uint32_t sapp_gl_get_framebuffer(void);\n/* GL: get major version (only valid for desktop GL) */\nSOKOL_APP_API_DECL int sapp_gl_get_major_version(void);\n/* GL: get minor version (only valid for desktop GL) */\nSOKOL_APP_API_DECL int sapp_gl_get_minor_version(void);\n\n/* Android: get native activity handle */\nSOKOL_APP_API_DECL const void* sapp_android_get_native_activity(void);\n\n#ifdef __cplusplus\n} /* extern \"C\" */\n\n/* reference-based equivalents for C++ */\ninline void sapp_run(const sapp_desc& desc) { return sapp_run(&desc); }\n\n#endif\n\n#endif // SOKOL_APP_INCLUDED\n\n//                                        \n//                                                             \n//                                                  \n//                                                                   \n//                                                      \n//\n// >>implementation\n#ifdef SOKOL_APP_IMPL\n#define SOKOL_APP_IMPL_INCLUDED (1)\n\n#if defined(SOKOL_MALLOC) || defined(SOKOL_CALLOC) || defined(SOKOL_FREE)\n#error \"SOKOL_MALLOC/CALLOC/FREE macros are no longer supported, please use sapp_desc.allocator to override memory allocation functions\"\n#endif\n\n#include <stdlib.h> // malloc, free\n#include <string.h> // memset, strncmp\n#include <stddef.h> // size_t\n#include <math.h>   // roundf\n\n// helper macros\n#define _sapp_def(val, def) (((val) == 0) ? (def) : (val))\n#define _sapp_absf(a) (((a)<0.0f)?-(a):(a))\n\n#define _SAPP_MAX_TITLE_LENGTH (128)\n#define _SAPP_FALLBACK_DEFAULT_WINDOW_WIDTH (640)\n#define _SAPP_FALLBACK_DEFAULT_WINDOW_HEIGHT (480)\n// NOTE: the pixel format values *must* be compatible with sg_pixel_format\n#define _SAPP_PIXELFORMAT_RGBA8 (23)\n#define _SAPP_PIXELFORMAT_BGRA8 (28)\n#define _SAPP_PIXELFORMAT_DEPTH (43)\n#define _SAPP_PIXELFORMAT_DEPTH_STENCIL (44)\n\n// check if the config defines are alright\n#if defined(__APPLE__)\n    // see https://clang.llvm.org/docs/LanguageExtensions.html#automatic-reference-counting\n    #if !defined(__cplusplus)\n        #if __has_feature(objc_arc) && !__has_feature(objc_arc_fields)\n            #error \"sokol_app.h requires __has_feature(objc_arc_field) if ARC is enabled (use a more recent compiler version)\"\n        #endif\n    #endif\n    #define _SAPP_APPLE (1)\n    #include <TargetConditionals.h>\n    #if defined(TARGET_OS_IPHONE) && !TARGET_OS_IPHONE\n        /* MacOS */\n        #define _SAPP_MACOS (1)\n        #if !defined(SOKOL_METAL) && !defined(SOKOL_GLCORE)\n        #error(\"sokol_app.h: unknown 3D API selected for MacOS, must be SOKOL_METAL or SOKOL_GLCORE\")\n        #endif\n    #else\n        /* iOS or iOS Simulator */\n        #define _SAPP_IOS (1)\n        #if !defined(SOKOL_METAL) && !defined(SOKOL_GLES3)\n        #error(\"sokol_app.h: unknown 3D API selected for iOS, must be SOKOL_METAL or SOKOL_GLES3\")\n        #endif\n    #endif\n#elif defined(__EMSCRIPTEN__)\n    /* emscripten (asm.js or wasm) */\n    #define _SAPP_EMSCRIPTEN (1)\n    #if !defined(SOKOL_GLES3) && !defined(SOKOL_WGPU)\n    #error(\"sokol_app.h: unknown 3D API selected for emscripten, must be SOKOL_GLES3 or SOKOL_WGPU\")\n    #endif\n#elif defined(_WIN32)\n    /* Windows (D3D11 or GL) */\n    #define _SAPP_WIN32 (1)\n    #if !defined(SOKOL_D3D11) && !defined(SOKOL_GLCORE) && !defined(SOKOL_NOAPI)\n    #error(\"sokol_app.h: unknown 3D API selected for Win32, must be SOKOL_D3D11, SOKOL_GLCORE or SOKOL_NOAPI\")\n    #endif\n#elif defined(__ANDROID__)\n    /* Android */\n    #define _SAPP_ANDROID (1)\n    #if !defined(SOKOL_GLES3)\n    #error(\"sokol_app.h: unknown 3D API selected for Android, must be SOKOL_GLES3\")\n    #endif\n    #if defined(SOKOL_NO_ENTRY)\n    #error(\"sokol_app.h: SOKOL_NO_ENTRY is not supported on Android\")\n    #endif\n#elif defined(__linux__) || defined(__unix__)\n    /* Linux */\n    #define _SAPP_LINUX (1)\n    #if defined(SOKOL_GLCORE)\n        #if !defined(SOKOL_FORCE_EGL)\n            #define _SAPP_GLX (1)\n        #endif\n        #define GL_GLEXT_PROTOTYPES\n        #include <GL/gl.h>\n    #elif defined(SOKOL_GLES3)\n        #include <GLES3/gl3.h>\n        #include <GLES3/gl3ext.h>\n    #else\n        #error(\"sokol_app.h: unknown 3D API selected for Linux, must be SOKOL_GLCORE, SOKOL_GLES3\")\n    #endif\n#else\n#error \"sokol_app.h: Unknown platform\"\n#endif\n\n#if defined(SOKOL_GLCORE) || defined(SOKOL_GLES3)\n    #define _SAPP_ANY_GL (1)\n#endif\n\n#ifndef SOKOL_API_IMPL\n    #define SOKOL_API_IMPL\n#endif\n#ifndef SOKOL_DEBUG\n    #ifndef NDEBUG\n        #define SOKOL_DEBUG\n    #endif\n#endif\n#ifndef SOKOL_ASSERT\n    #include <assert.h>\n    #define SOKOL_ASSERT(c) assert(c)\n#endif\n#ifndef SOKOL_UNREACHABLE\n    #define SOKOL_UNREACHABLE SOKOL_ASSERT(false)\n#endif\n\n#ifndef _SOKOL_PRIVATE\n    #if defined(__GNUC__) || defined(__clang__)\n        #define _SOKOL_PRIVATE __attribute__((unused)) static\n    #else\n        #define _SOKOL_PRIVATE static\n    #endif\n#endif\n#ifndef _SOKOL_UNUSED\n    #define _SOKOL_UNUSED(x) (void)(x)\n#endif\n\n#if defined(_SAPP_APPLE)\n    #if defined(SOKOL_METAL)\n        #import <Metal/Metal.h>\n        #import <MetalKit/MetalKit.h>\n    #endif\n    #if defined(_SAPP_MACOS)\n        #if defined(_SAPP_ANY_GL)\n            #ifndef GL_SILENCE_DEPRECATION\n            #define GL_SILENCE_DEPRECATION\n            #endif\n            #include <Cocoa/Cocoa.h>\n            #include <OpenGL/gl3.h>\n        #endif\n    #elif defined(_SAPP_IOS)\n        #import <UIKit/UIKit.h>\n        #if defined(_SAPP_ANY_GL)\n            #import <GLKit/GLKit.h>\n            #include <OpenGLES/ES3/gl.h>\n        #endif\n    #endif\n    #include <AvailabilityMacros.h>\n    #include <mach/mach_time.h>\n#elif defined(_SAPP_EMSCRIPTEN)\n    #if defined(SOKOL_WGPU)\n        #include <webgpu/webgpu.h>\n    #endif\n    #if defined(SOKOL_GLES3)\n        #include <GLES3/gl3.h>\n    #endif\n    #include <emscripten/emscripten.h>\n    #include <emscripten/html5.h>\n#elif defined(_SAPP_WIN32)\n    #ifdef _MSC_VER\n        #pragma warning(push)\n        #pragma warning(disable:4201)   /* nonstandard extension used: nameless struct/union */\n        #pragma warning(disable:4204)   /* nonstandard extension used: non-constant aggregate initializer */\n        #pragma warning(disable:4054)   /* 'type cast': from function pointer */\n        #pragma warning(disable:4055)   /* 'type cast': from data pointer */\n        #pragma warning(disable:4505)   /* unreferenced local function has been removed */\n        #pragma warning(disable:4115)   /* /W4: 'ID3D11ModuleInstance': named type definition in parentheses (in d3d11.h) */\n    #endif\n    #ifndef WIN32_LEAN_AND_MEAN\n        #define WIN32_LEAN_AND_MEAN\n    #endif\n    #ifndef NOMINMAX\n        #define NOMINMAX\n    #endif\n    #include <windows.h>\n    #include <windowsx.h>\n    #include <shellapi.h>\n    #if !defined(SOKOL_NO_ENTRY)    // if SOKOL_NO_ENTRY is defined, it's the application's responsibility to use the right subsystem\n\n        #if defined(SOKOL_WIN32_FORCE_MAIN) && defined(SOKOL_WIN32_FORCE_WINMAIN)\n            // If both are defined, it's the application's responsibility to use the right subsystem\n        #elif defined(SOKOL_WIN32_FORCE_MAIN)\n            #pragma comment (linker, \"/subsystem:console\")\n        #else\n            #pragma comment (linker, \"/subsystem:windows\")\n        #endif\n    #endif\n    #include <stdio.h>  /* freopen_s() */\n    #include <wchar.h>  /* wcslen() */\n\n    #pragma comment (lib, \"kernel32\")\n    #pragma comment (lib, \"user32\")\n    #pragma comment (lib, \"shell32\")    /* CommandLineToArgvW, DragQueryFileW, DragFinished */\n    #pragma comment (lib, \"gdi32\")\n    #if defined(SOKOL_D3D11)\n        #pragma comment (lib, \"dxgi\")\n        #pragma comment (lib, \"d3d11\")\n    #endif\n\n    #if defined(SOKOL_D3D11)\n        #ifndef D3D11_NO_HELPERS\n            #define D3D11_NO_HELPERS\n        #endif\n        #include <d3d11.h>\n        #include <dxgi.h>\n        // DXGI_SWAP_EFFECT_FLIP_DISCARD is only defined in newer Windows SDKs, so don't depend on it\n        #define _SAPP_DXGI_SWAP_EFFECT_FLIP_DISCARD (4)\n    #endif\n    #ifndef WM_MOUSEHWHEEL /* see https://github.com/floooh/sokol/issues/138 */\n        #define WM_MOUSEHWHEEL (0x020E)\n    #endif\n    #ifndef WM_DPICHANGED\n        #define WM_DPICHANGED (0x02E0)\n    #endif\n#elif defined(_SAPP_ANDROID)\n    #include <pthread.h>\n    #include <unistd.h>\n    #include <time.h>\n    #include <android/native_activity.h>\n    #include <android/looper.h>\n    #include <EGL/egl.h>\n    #include <GLES3/gl3.h>\n#elif defined(_SAPP_LINUX)\n    #define GL_GLEXT_PROTOTYPES\n    #include <X11/Xlib.h>\n    #include <X11/Xutil.h>\n    #include <X11/XKBlib.h>\n    #include <X11/keysym.h>\n    #include <X11/Xresource.h>\n    #include <X11/Xatom.h>\n    #include <X11/extensions/XInput2.h>\n    #include <X11/Xcursor/Xcursor.h>\n    #include <X11/cursorfont.h> /* XC_* font cursors */\n    #include <X11/Xmd.h> /* CARD32 */\n    #if !defined(_SAPP_GLX)\n        #include <EGL/egl.h>\n    #endif\n    #include <dlfcn.h> /* dlopen, dlsym, dlclose */\n    #include <limits.h> /* LONG_MAX */\n    #include <pthread.h>    /* only used a linker-guard, search for _sapp_linux_run() and see first comment */\n    #include <time.h>\n    #include <poll.h>\n#endif\n\n#if defined(_SAPP_APPLE)\n    // this is ARC compatible\n    #if defined(__cplusplus)\n        #define _SAPP_CLEAR_ARC_STRUCT(type, item) { item = type(); }\n    #else\n        #define _SAPP_CLEAR_ARC_STRUCT(type, item) { item = (type) { 0 }; }\n    #endif\n#else\n    #define _SAPP_CLEAR_ARC_STRUCT(type, item) { _sapp_clear(&item, sizeof(item)); }\n#endif\n\n\n//                               \n//                                            \n//                                    \n//                                                    \n//                                                \n//\n// >>frame timing\n#define _SAPP_RING_NUM_SLOTS (256)\ntypedef struct {\n    int head;\n    int tail;\n    double buf[_SAPP_RING_NUM_SLOTS];\n} _sapp_ring_t;\n\n_SOKOL_PRIVATE int _sapp_ring_idx(int i) {\n    return i % _SAPP_RING_NUM_SLOTS;\n}\n\n_SOKOL_PRIVATE void _sapp_ring_init(_sapp_ring_t* ring) {\n    ring->head = 0;\n    ring->tail = 0;\n}\n\n_SOKOL_PRIVATE bool _sapp_ring_full(_sapp_ring_t* ring) {\n    return _sapp_ring_idx(ring->head + 1) == ring->tail;\n}\n\n_SOKOL_PRIVATE bool _sapp_ring_empty(_sapp_ring_t* ring) {\n    return ring->head == ring->tail;\n}\n\n_SOKOL_PRIVATE int _sapp_ring_count(_sapp_ring_t* ring) {\n    int count;\n    if (ring->head >= ring->tail) {\n        count = ring->head - ring->tail;\n    }\n    else {\n        count = (ring->head + _SAPP_RING_NUM_SLOTS) - ring->tail;\n    }\n    SOKOL_ASSERT((count >= 0) && (count < _SAPP_RING_NUM_SLOTS));\n    return count;\n}\n\n_SOKOL_PRIVATE void _sapp_ring_enqueue(_sapp_ring_t* ring, double val) {\n    SOKOL_ASSERT(!_sapp_ring_full(ring));\n    ring->buf[ring->head] = val;\n    ring->head = _sapp_ring_idx(ring->head + 1);\n}\n\n_SOKOL_PRIVATE double _sapp_ring_dequeue(_sapp_ring_t* ring) {\n    SOKOL_ASSERT(!_sapp_ring_empty(ring));\n    double val = ring->buf[ring->tail];\n    ring->tail = _sapp_ring_idx(ring->tail + 1);\n    return val;\n}\n\n/*\n    NOTE:\n\n    Q: Why not use CAMetalDrawable.presentedTime on macOS and iOS?\n    A: The value appears to be highly unstable during the first few\n    seconds, sometimes several frames are dropped in sequence, or\n    switch between 120 and 60 Hz for a few frames. Simply measuring\n    and averaging the frame time yielded a more stable frame duration.\n    Maybe switching to CVDisplayLink would yield better results.\n    Until then just measure the time.\n*/\ntypedef struct {\n    #if defined(_SAPP_APPLE)\n        struct {\n            mach_timebase_info_data_t timebase;\n            uint64_t start;\n        } mach;\n    #elif defined(_SAPP_EMSCRIPTEN)\n        // empty\n    #elif defined(_SAPP_WIN32)\n        struct {\n            LARGE_INTEGER freq;\n            LARGE_INTEGER start;\n        } win;\n    #else // Linux, Android, ...\n        #ifdef CLOCK_MONOTONIC\n        #define _SAPP_CLOCK_MONOTONIC CLOCK_MONOTONIC\n        #else\n        // on some embedded platforms, CLOCK_MONOTONIC isn't defined\n        #define _SAPP_CLOCK_MONOTONIC (1)\n        #endif\n        struct {\n            uint64_t start;\n        } posix;\n    #endif\n} _sapp_timestamp_t;\n\n_SOKOL_PRIVATE int64_t _sapp_int64_muldiv(int64_t value, int64_t numer, int64_t denom) {\n    int64_t q = value / denom;\n    int64_t r = value % denom;\n    return q * numer + r * numer / denom;\n}\n\n_SOKOL_PRIVATE void _sapp_timestamp_init(_sapp_timestamp_t* ts) {\n    #if defined(_SAPP_APPLE)\n        mach_timebase_info(&ts->mach.timebase);\n        ts->mach.start = mach_absolute_time();\n    #elif defined(_SAPP_EMSCRIPTEN)\n        (void)ts;\n    #elif defined(_SAPP_WIN32)\n        QueryPerformanceFrequency(&ts->win.freq);\n        QueryPerformanceCounter(&ts->win.start);\n    #else\n        struct timespec tspec;\n        clock_gettime(_SAPP_CLOCK_MONOTONIC, &tspec);\n        ts->posix.start = (uint64_t)tspec.tv_sec*1000000000 + (uint64_t)tspec.tv_nsec;\n    #endif\n}\n\n_SOKOL_PRIVATE double _sapp_timestamp_now(_sapp_timestamp_t* ts) {\n    #if defined(_SAPP_APPLE)\n        const uint64_t traw = mach_absolute_time() - ts->mach.start;\n        const uint64_t now = (uint64_t) _sapp_int64_muldiv((int64_t)traw, (int64_t)ts->mach.timebase.numer, (int64_t)ts->mach.timebase.denom);\n        return (double)now / 1000000000.0;\n    #elif defined(_SAPP_EMSCRIPTEN)\n        (void)ts;\n        SOKOL_ASSERT(false);\n        return 0.0;\n    #elif defined(_SAPP_WIN32)\n        LARGE_INTEGER qpc;\n        QueryPerformanceCounter(&qpc);\n        const uint64_t now = (uint64_t)_sapp_int64_muldiv(qpc.QuadPart - ts->win.start.QuadPart, 1000000000, ts->win.freq.QuadPart);\n        return (double)now / 1000000000.0;\n    #else\n        struct timespec tspec;\n        clock_gettime(_SAPP_CLOCK_MONOTONIC, &tspec);\n        const uint64_t now = ((uint64_t)tspec.tv_sec*1000000000 + (uint64_t)tspec.tv_nsec) - ts->posix.start;\n        return (double)now / 1000000000.0;\n    #endif\n}\n\ntypedef struct {\n    double last;\n    double accum;\n    double avg;\n    int spike_count;\n    int num;\n    _sapp_timestamp_t timestamp;\n    _sapp_ring_t ring;\n} _sapp_timing_t;\n\n_SOKOL_PRIVATE void _sapp_timing_reset(_sapp_timing_t* t) {\n    t->last = 0.0;\n    t->accum = 0.0;\n    t->spike_count = 0;\n    t->num = 0;\n    _sapp_ring_init(&t->ring);\n}\n\n_SOKOL_PRIVATE void _sapp_timing_init(_sapp_timing_t* t) {\n    t->avg = 1.0 / 60.0;    // dummy value until first actual value is available\n    _sapp_timing_reset(t);\n    _sapp_timestamp_init(&t->timestamp);\n}\n\n_SOKOL_PRIVATE void _sapp_timing_put(_sapp_timing_t* t, double dur) {\n    // arbitrary upper limit to ignore outliers (e.g. during window resizing, or debugging)\n    double min_dur = 0.0;\n    double max_dur = 0.1;\n    // if we have enough samples for a useful average, use a much tighter 'valid window'\n    if (_sapp_ring_full(&t->ring)) {\n        min_dur = t->avg * 0.8;\n        max_dur = t->avg * 1.2;\n    }\n    if ((dur < min_dur) || (dur > max_dur)) {\n        t->spike_count++;\n        // if there have been many spikes in a row, the display refresh rate\n        // might have changed, so a timing reset is needed\n        if (t->spike_count > 20) {\n            _sapp_timing_reset(t);\n        }\n        return;\n    }\n    if (_sapp_ring_full(&t->ring)) {\n        double old_val = _sapp_ring_dequeue(&t->ring);\n        t->accum -= old_val;\n        t->num -= 1;\n    }\n    _sapp_ring_enqueue(&t->ring, dur);\n    t->accum += dur;\n    t->num += 1;\n    SOKOL_ASSERT(t->num > 0);\n    t->avg = t->accum / t->num;\n    t->spike_count = 0;\n}\n\n_SOKOL_PRIVATE void _sapp_timing_discontinuity(_sapp_timing_t* t) {\n    t->last = 0.0;\n}\n\n_SOKOL_PRIVATE void _sapp_timing_measure(_sapp_timing_t* t) {\n    const double now = _sapp_timestamp_now(&t->timestamp);\n    if (t->last > 0.0) {\n        double dur = now - t->last;\n        _sapp_timing_put(t, dur);\n    }\n    t->last = now;\n}\n\n_SOKOL_PRIVATE void _sapp_timing_external(_sapp_timing_t* t, double now) {\n    if (t->last > 0.0) {\n        double dur = now - t->last;\n        _sapp_timing_put(t, dur);\n    }\n    t->last = now;\n}\n\n_SOKOL_PRIVATE double _sapp_timing_get_avg(_sapp_timing_t* t) {\n    return t->avg;\n}\n\n//             \n//                                    \n//                             \n//                                         \n//                         \n//\n// >> structs\n#if defined(_SAPP_MACOS)\n@interface _sapp_macos_app_delegate : NSObject<NSApplicationDelegate>\n@end\n@interface _sapp_macos_window : NSWindow\n@end\n@interface _sapp_macos_window_delegate : NSObject<NSWindowDelegate>\n@end\n#if defined(SOKOL_METAL)\n    @interface _sapp_macos_view : MTKView\n    @end\n#elif defined(SOKOL_GLCORE)\n    @interface _sapp_macos_view : NSOpenGLView\n    - (void)timerFired:(id)sender;\n    @end\n#endif // SOKOL_GLCORE\n\ntypedef struct {\n    uint32_t flags_changed_store;\n    uint8_t mouse_buttons;\n    NSWindow* window;\n    NSTrackingArea* tracking_area;\n    id keyup_monitor;\n    _sapp_macos_app_delegate* app_dlg;\n    _sapp_macos_window_delegate* win_dlg;\n    _sapp_macos_view* view;\n    NSCursor* cursors[_SAPP_MOUSECURSOR_NUM];\n    #if defined(SOKOL_METAL)\n        id<MTLDevice> mtl_device;\n    #endif\n} _sapp_macos_t;\n\n#endif // _SAPP_MACOS\n\n#if defined(_SAPP_IOS)\n\n@interface _sapp_app_delegate : NSObject<UIApplicationDelegate>\n@end\n@interface _sapp_textfield_dlg : NSObject<UITextFieldDelegate>\n- (void)keyboardWasShown:(NSNotification*)notif;\n- (void)keyboardWillBeHidden:(NSNotification*)notif;\n- (void)keyboardDidChangeFrame:(NSNotification*)notif;\n@end\n#if defined(SOKOL_METAL)\n    @interface _sapp_ios_view : MTKView;\n    @end\n#else\n    @interface _sapp_ios_view : GLKView\n    @end\n#endif\n\ntypedef struct {\n    UIWindow* window;\n    _sapp_ios_view* view;\n    UITextField* textfield;\n    _sapp_textfield_dlg* textfield_dlg;\n    #if defined(SOKOL_METAL)\n        UIViewController* view_ctrl;\n        id<MTLDevice> mtl_device;\n    #else\n        GLKViewController* view_ctrl;\n        EAGLContext* eagl_ctx;\n    #endif\n    bool suspended;\n} _sapp_ios_t;\n\n#endif // _SAPP_IOS\n\n#if defined(_SAPP_EMSCRIPTEN)\n\n#if defined(SOKOL_WGPU)\ntypedef struct {\n    WGPUInstance instance;\n    WGPUAdapter adapter;\n    WGPUDevice device;\n    WGPUTextureFormat render_format;\n    WGPUSurface surface;\n    WGPUSwapChain swapchain;\n    WGPUTexture msaa_tex;\n    WGPUTextureView msaa_view;\n    WGPUTexture depth_stencil_tex;\n    WGPUTextureView depth_stencil_view;\n    WGPUTextureView swapchain_view;\n    bool async_init_done;\n} _sapp_wgpu_t;\n#endif\n\ntypedef struct {\n    bool mouse_lock_requested;\n    uint16_t mouse_buttons;\n} _sapp_emsc_t;\n#endif // _SAPP_EMSCRIPTEN\n\n#if defined(SOKOL_D3D11) && defined(_SAPP_WIN32)\ntypedef struct {\n    ID3D11Device* device;\n    ID3D11DeviceContext* device_context;\n    ID3D11Texture2D* rt;\n    ID3D11RenderTargetView* rtv;\n    ID3D11Texture2D* msaa_rt;\n    ID3D11RenderTargetView* msaa_rtv;\n    ID3D11Texture2D* ds;\n    ID3D11DepthStencilView* dsv;\n    DXGI_SWAP_CHAIN_DESC swap_chain_desc;\n    IDXGISwapChain* swap_chain;\n    IDXGIDevice1* dxgi_device;\n    bool use_dxgi_frame_stats;\n    UINT sync_refresh_count;\n} _sapp_d3d11_t;\n#endif\n\n#if defined(_SAPP_WIN32)\n\n#ifndef DPI_ENUMS_DECLARED\ntypedef enum PROCESS_DPI_AWARENESS\n{\n    PROCESS_DPI_UNAWARE = 0,\n    PROCESS_SYSTEM_DPI_AWARE = 1,\n    PROCESS_PER_MONITOR_DPI_AWARE = 2\n} PROCESS_DPI_AWARENESS;\ntypedef enum MONITOR_DPI_TYPE {\n    MDT_EFFECTIVE_DPI = 0,\n    MDT_ANGULAR_DPI = 1,\n    MDT_RAW_DPI = 2,\n    MDT_DEFAULT = MDT_EFFECTIVE_DPI\n} MONITOR_DPI_TYPE;\n#endif // DPI_ENUMS_DECLARED\n\ntypedef struct {\n    bool aware;\n    float content_scale;\n    float window_scale;\n    float mouse_scale;\n} _sapp_win32_dpi_t;\n\ntypedef struct {\n    HWND hwnd;\n    HMONITOR hmonitor;\n    HDC dc;\n    HICON big_icon;\n    HICON small_icon;\n    HCURSOR cursors[_SAPP_MOUSECURSOR_NUM];\n    UINT orig_codepage;\n    LONG mouse_locked_x, mouse_locked_y;\n    RECT stored_window_rect;    // used to restore window pos/size when toggling fullscreen => windowed\n    bool is_win10_or_greater;\n    bool in_create_window;\n    bool iconified;\n    bool mouse_tracked;\n    uint8_t mouse_capture_mask;\n    _sapp_win32_dpi_t dpi;\n    bool raw_input_mousepos_valid;\n    LONG raw_input_mousepos_x;\n    LONG raw_input_mousepos_y;\n    uint8_t raw_input_data[256];\n} _sapp_win32_t;\n\n#if defined(SOKOL_GLCORE)\n#define WGL_NUMBER_PIXEL_FORMATS_ARB 0x2000\n#define WGL_SUPPORT_OPENGL_ARB 0x2010\n#define WGL_DRAW_TO_WINDOW_ARB 0x2001\n#define WGL_PIXEL_TYPE_ARB 0x2013\n#define WGL_TYPE_RGBA_ARB 0x202b\n#define WGL_ACCELERATION_ARB 0x2003\n#define WGL_NO_ACCELERATION_ARB 0x2025\n#define WGL_RED_BITS_ARB 0x2015\n#define WGL_GREEN_BITS_ARB 0x2017\n#define WGL_BLUE_BITS_ARB 0x2019\n#define WGL_ALPHA_BITS_ARB 0x201b\n#define WGL_DEPTH_BITS_ARB 0x2022\n#define WGL_STENCIL_BITS_ARB 0x2023\n#define WGL_DOUBLE_BUFFER_ARB 0x2011\n#define WGL_SAMPLES_ARB 0x2042\n#define WGL_CONTEXT_DEBUG_BIT_ARB 0x00000001\n#define WGL_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB 0x00000002\n#define WGL_CONTEXT_PROFILE_MASK_ARB 0x9126\n#define WGL_CONTEXT_CORE_PROFILE_BIT_ARB 0x00000001\n#define WGL_CONTEXT_MAJOR_VERSION_ARB 0x2091\n#define WGL_CONTEXT_MINOR_VERSION_ARB 0x2092\n#define WGL_CONTEXT_FLAGS_ARB 0x2094\n#define ERROR_INVALID_VERSION_ARB 0x2095\n#define ERROR_INVALID_PROFILE_ARB 0x2096\n#define ERROR_INCOMPATIBLE_DEVICE_CONTEXTS_ARB 0x2054\ntypedef BOOL (WINAPI * PFNWGLSWAPINTERVALEXTPROC)(int);\ntypedef BOOL (WINAPI * PFNWGLGETPIXELFORMATATTRIBIVARBPROC)(HDC,int,int,UINT,const int*,int*);\ntypedef const char* (WINAPI * PFNWGLGETEXTENSIONSSTRINGEXTPROC)(void);\ntypedef const char* (WINAPI * PFNWGLGETEXTENSIONSSTRINGARBPROC)(HDC);\ntypedef HGLRC (WINAPI * PFNWGLCREATECONTEXTATTRIBSARBPROC)(HDC,HGLRC,const int*);\ntypedef HGLRC (WINAPI * PFN_wglCreateContext)(HDC);\ntypedef BOOL (WINAPI * PFN_wglDeleteContext)(HGLRC);\ntypedef PROC (WINAPI * PFN_wglGetProcAddress)(LPCSTR);\ntypedef HDC (WINAPI * PFN_wglGetCurrentDC)(void);\ntypedef BOOL (WINAPI * PFN_wglMakeCurrent)(HDC,HGLRC);\n\ntypedef struct {\n    HINSTANCE opengl32;\n    HGLRC gl_ctx;\n    PFN_wglCreateContext CreateContext;\n    PFN_wglDeleteContext DeleteContext;\n    PFN_wglGetProcAddress GetProcAddress;\n    PFN_wglGetCurrentDC GetCurrentDC;\n    PFN_wglMakeCurrent MakeCurrent;\n    PFNWGLSWAPINTERVALEXTPROC SwapIntervalEXT;\n    PFNWGLGETPIXELFORMATATTRIBIVARBPROC GetPixelFormatAttribivARB;\n    PFNWGLGETEXTENSIONSSTRINGEXTPROC GetExtensionsStringEXT;\n    PFNWGLGETEXTENSIONSSTRINGARBPROC GetExtensionsStringARB;\n    PFNWGLCREATECONTEXTATTRIBSARBPROC CreateContextAttribsARB;\n    // special case glGetIntegerv\n    void (WINAPI *GetIntegerv)(uint32_t pname, int32_t* data);\n    bool ext_swap_control;\n    bool arb_multisample;\n    bool arb_pixel_format;\n    bool arb_create_context;\n    bool arb_create_context_profile;\n    HWND msg_hwnd;\n    HDC msg_dc;\n} _sapp_wgl_t;\n#endif // SOKOL_GLCORE\n\n#endif // _SAPP_WIN32\n\n#if defined(_SAPP_ANDROID)\ntypedef enum {\n    _SOKOL_ANDROID_MSG_CREATE,\n    _SOKOL_ANDROID_MSG_RESUME,\n    _SOKOL_ANDROID_MSG_PAUSE,\n    _SOKOL_ANDROID_MSG_FOCUS,\n    _SOKOL_ANDROID_MSG_NO_FOCUS,\n    _SOKOL_ANDROID_MSG_SET_NATIVE_WINDOW,\n    _SOKOL_ANDROID_MSG_SET_INPUT_QUEUE,\n    _SOKOL_ANDROID_MSG_DESTROY,\n} _sapp_android_msg_t;\n\ntypedef struct {\n    pthread_t thread;\n    pthread_mutex_t mutex;\n    pthread_cond_t cond;\n    int read_from_main_fd;\n    int write_from_main_fd;\n} _sapp_android_pt_t;\n\ntypedef struct {\n    ANativeWindow* window;\n    AInputQueue* input;\n} _sapp_android_resources_t;\n\ntypedef struct {\n    ANativeActivity* activity;\n    _sapp_android_pt_t pt;\n    _sapp_android_resources_t pending;\n    _sapp_android_resources_t current;\n    ALooper* looper;\n    bool is_thread_started;\n    bool is_thread_stopping;\n    bool is_thread_stopped;\n    bool has_created;\n    bool has_resumed;\n    bool has_focus;\n    EGLConfig config;\n    EGLDisplay display;\n    EGLContext context;\n    EGLSurface surface;\n} _sapp_android_t;\n\n#endif // _SAPP_ANDROID\n\n#if defined(_SAPP_LINUX)\n\n#define _SAPP_X11_XDND_VERSION (5)\n#define _SAPP_X11_MAX_X11_KEYCODES (256)\n\n#define GLX_VENDOR 1\n#define GLX_RGBA_BIT 0x00000001\n#define GLX_WINDOW_BIT 0x00000001\n#define GLX_DRAWABLE_TYPE 0x8010\n#define GLX_RENDER_TYPE\t0x8011\n#define GLX_DOUBLEBUFFER 5\n#define GLX_RED_SIZE 8\n#define GLX_GREEN_SIZE 9\n#define GLX_BLUE_SIZE 10\n#define GLX_ALPHA_SIZE 11\n#define GLX_DEPTH_SIZE 12\n#define GLX_STENCIL_SIZE 13\n#define GLX_SAMPLES 0x186a1\n#define GLX_CONTEXT_CORE_PROFILE_BIT_ARB 0x00000001\n#define GLX_CONTEXT_PROFILE_MASK_ARB 0x9126\n#define GLX_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB 0x00000002\n#define GLX_CONTEXT_MAJOR_VERSION_ARB 0x2091\n#define GLX_CONTEXT_MINOR_VERSION_ARB 0x2092\n#define GLX_CONTEXT_FLAGS_ARB 0x2094\n\ntypedef XID GLXWindow;\ntypedef XID GLXDrawable;\ntypedef struct __GLXFBConfig* GLXFBConfig;\ntypedef struct __GLXcontext* GLXContext;\ntypedef void (*__GLXextproc)(void);\n\ntypedef int (*PFNGLXGETFBCONFIGATTRIBPROC)(Display*,GLXFBConfig,int,int*);\ntypedef const char* (*PFNGLXGETCLIENTSTRINGPROC)(Display*,int);\ntypedef Bool (*PFNGLXQUERYEXTENSIONPROC)(Display*,int*,int*);\ntypedef Bool (*PFNGLXQUERYVERSIONPROC)(Display*,int*,int*);\ntypedef void (*PFNGLXDESTROYCONTEXTPROC)(Display*,GLXContext);\ntypedef Bool (*PFNGLXMAKECURRENTPROC)(Display*,GLXDrawable,GLXContext);\ntypedef void (*PFNGLXSWAPBUFFERSPROC)(Display*,GLXDrawable);\ntypedef const char* (*PFNGLXQUERYEXTENSIONSSTRINGPROC)(Display*,int);\ntypedef GLXFBConfig* (*PFNGLXGETFBCONFIGSPROC)(Display*,int,int*);\ntypedef __GLXextproc (* PFNGLXGETPROCADDRESSPROC)(const char *procName);\ntypedef void (*PFNGLXSWAPINTERVALEXTPROC)(Display*,GLXDrawable,int);\ntypedef XVisualInfo* (*PFNGLXGETVISUALFROMFBCONFIGPROC)(Display*,GLXFBConfig);\ntypedef GLXWindow (*PFNGLXCREATEWINDOWPROC)(Display*,GLXFBConfig,Window,const int*);\ntypedef void (*PFNGLXDESTROYWINDOWPROC)(Display*,GLXWindow);\n\ntypedef int (*PFNGLXSWAPINTERVALMESAPROC)(int);\ntypedef GLXContext (*PFNGLXCREATECONTEXTATTRIBSARBPROC)(Display*,GLXFBConfig,GLXContext,Bool,const int*);\n\ntypedef struct {\n    bool available;\n    int major_opcode;\n    int event_base;\n    int error_base;\n    int major;\n    int minor;\n} _sapp_xi_t;\n\ntypedef struct {\n    int version;\n    Window source;\n    Atom format;\n    Atom XdndAware;\n    Atom XdndEnter;\n    Atom XdndPosition;\n    Atom XdndStatus;\n    Atom XdndActionCopy;\n    Atom XdndDrop;\n    Atom XdndFinished;\n    Atom XdndSelection;\n    Atom XdndTypeList;\n    Atom text_uri_list;\n} _sapp_xdnd_t;\n\ntypedef struct {\n    uint8_t mouse_buttons;\n    Display* display;\n    int screen;\n    Window root;\n    Colormap colormap;\n    Window window;\n    Cursor hidden_cursor;\n    Cursor cursors[_SAPP_MOUSECURSOR_NUM];\n    int window_state;\n    float dpi;\n    unsigned char error_code;\n    Atom UTF8_STRING;\n    Atom CLIPBOARD;\n    Atom TARGETS;\n    Atom WM_PROTOCOLS;\n    Atom WM_DELETE_WINDOW;\n    Atom WM_STATE;\n    Atom NET_WM_NAME;\n    Atom NET_WM_ICON_NAME;\n    Atom NET_WM_ICON;\n    Atom NET_WM_STATE;\n    Atom NET_WM_STATE_FULLSCREEN;\n    _sapp_xi_t xi;\n    _sapp_xdnd_t xdnd;\n    // XLib manual says keycodes are in the range [8, 255] inclusive.\n    // https://tronche.com/gui/x/xlib/input/keyboard-encoding.html\n    bool key_repeat[_SAPP_X11_MAX_X11_KEYCODES];\n} _sapp_x11_t;\n\n#if defined(_SAPP_GLX)\n\ntypedef struct {\n    void* libgl;\n    int major;\n    int minor;\n    int event_base;\n    int error_base;\n    GLXContext ctx;\n    GLXWindow window;\n\n    // GLX 1.3 functions\n    PFNGLXGETFBCONFIGSPROC GetFBConfigs;\n    PFNGLXGETFBCONFIGATTRIBPROC GetFBConfigAttrib;\n    PFNGLXGETCLIENTSTRINGPROC GetClientString;\n    PFNGLXQUERYEXTENSIONPROC QueryExtension;\n    PFNGLXQUERYVERSIONPROC QueryVersion;\n    PFNGLXDESTROYCONTEXTPROC DestroyContext;\n    PFNGLXMAKECURRENTPROC MakeCurrent;\n    PFNGLXSWAPBUFFERSPROC SwapBuffers;\n    PFNGLXQUERYEXTENSIONSSTRINGPROC QueryExtensionsString;\n    PFNGLXGETVISUALFROMFBCONFIGPROC GetVisualFromFBConfig;\n    PFNGLXCREATEWINDOWPROC CreateWindow;\n    PFNGLXDESTROYWINDOWPROC DestroyWindow;\n\n    // GLX 1.4 and extension functions\n    PFNGLXGETPROCADDRESSPROC GetProcAddress;\n    PFNGLXGETPROCADDRESSPROC GetProcAddressARB;\n    PFNGLXSWAPINTERVALEXTPROC SwapIntervalEXT;\n    PFNGLXSWAPINTERVALMESAPROC SwapIntervalMESA;\n    PFNGLXCREATECONTEXTATTRIBSARBPROC CreateContextAttribsARB;\n\n    // special case glGetIntegerv\n    void (*GetIntegerv)(uint32_t pname, int32_t* data);\n\n    // extension availability\n    bool EXT_swap_control;\n    bool MESA_swap_control;\n    bool ARB_multisample;\n    bool ARB_create_context;\n    bool ARB_create_context_profile;\n} _sapp_glx_t;\n\n#else\n\ntypedef struct {\n    EGLDisplay display;\n    EGLContext context;\n    EGLSurface surface;\n} _sapp_egl_t;\n\n#endif // _SAPP_GLX\n#endif // _SAPP_LINUX\n\n#if defined(_SAPP_ANY_GL)\ntypedef struct {\n    uint32_t framebuffer;\n} _sapp_gl_t;\n#endif\n\ntypedef struct {\n    bool enabled;\n    int buf_size;\n    char* buffer;\n} _sapp_clipboard_t;\n\ntypedef struct {\n    bool enabled;\n    int max_files;\n    int max_path_length;\n    int num_files;\n    int buf_size;\n    char* buffer;\n} _sapp_drop_t;\n\ntypedef struct {\n    float x, y;\n    float dx, dy;\n    bool shown;\n    bool locked;\n    bool pos_valid;\n    sapp_mouse_cursor current_cursor;\n} _sapp_mouse_t;\n\ntypedef struct {\n    sapp_desc desc;\n    bool valid;\n    bool fullscreen;\n    bool first_frame;\n    bool init_called;\n    bool cleanup_called;\n    bool quit_requested;\n    bool quit_ordered;\n    bool event_consumed;\n    bool html5_ask_leave_site;\n    bool onscreen_keyboard_shown;\n    int window_width;\n    int window_height;\n    int framebuffer_width;\n    int framebuffer_height;\n    int sample_count;\n    int swap_interval;\n    float dpi_scale;\n    uint64_t frame_count;\n    _sapp_timing_t timing;\n    sapp_event event;\n    _sapp_mouse_t mouse;\n    _sapp_clipboard_t clipboard;\n    _sapp_drop_t drop;\n    sapp_icon_desc default_icon_desc;\n    uint32_t* default_icon_pixels;\n    #if defined(_SAPP_MACOS)\n        _sapp_macos_t macos;\n    #elif defined(_SAPP_IOS)\n        _sapp_ios_t ios;\n    #elif defined(_SAPP_EMSCRIPTEN)\n        _sapp_emsc_t emsc;\n        #if defined(SOKOL_WGPU)\n            _sapp_wgpu_t wgpu;\n        #endif\n    #elif defined(_SAPP_WIN32)\n        _sapp_win32_t win32;\n        #if defined(SOKOL_D3D11)\n            _sapp_d3d11_t d3d11;\n        #elif defined(SOKOL_GLCORE)\n            _sapp_wgl_t wgl;\n        #endif\n    #elif defined(_SAPP_ANDROID)\n        _sapp_android_t android;\n    #elif defined(_SAPP_LINUX)\n        _sapp_x11_t x11;\n        #if defined(_SAPP_GLX)\n            _sapp_glx_t glx;\n        #else\n            _sapp_egl_t egl;\n        #endif\n    #endif\n    #if defined(_SAPP_ANY_GL)\n        _sapp_gl_t gl;\n    #endif\n    char html5_canvas_selector[_SAPP_MAX_TITLE_LENGTH];\n    char window_title[_SAPP_MAX_TITLE_LENGTH];      // UTF-8\n    wchar_t window_title_wide[_SAPP_MAX_TITLE_LENGTH];   // UTF-32 or UCS-2 */\n    sapp_keycode keycodes[SAPP_MAX_KEYCODES];\n} _sapp_t;\nstatic _sapp_t _sapp;\n\n//                       \n//                               \n//                            \n//                               \n//                 \n//\n// >>logging\n#if defined(SOKOL_DEBUG)\n#define _SAPP_LOGITEM_XMACRO(item,msg) #item \": \" msg,\nstatic const char* _sapp_log_messages[] = {\n    _SAPP_LOG_ITEMS\n};\n#undef _SAPP_LOGITEM_XMACRO\n#endif // SOKOL_DEBUG\n\n#define _SAPP_PANIC(code) _sapp_log(SAPP_LOGITEM_ ##code, 0, 0, __LINE__)\n#define _SAPP_ERROR(code) _sapp_log(SAPP_LOGITEM_ ##code, 1, 0, __LINE__)\n#define _SAPP_WARN(code) _sapp_log(SAPP_LOGITEM_ ##code, 2, 0, __LINE__)\n#define _SAPP_INFO(code) _sapp_log(SAPP_LOGITEM_ ##code, 3, 0, __LINE__)\n\nstatic void _sapp_log(sapp_log_item log_item, uint32_t log_level, const char* msg, uint32_t line_nr) {\n    if (_sapp.desc.logger.func) {\n        const char* filename = 0;\n        #if defined(SOKOL_DEBUG)\n            filename = __FILE__;\n            if (0 == msg) {\n                msg = _sapp_log_messages[log_item];\n            }\n        #endif\n        _sapp.desc.logger.func(\"sapp\", log_level, log_item, msg, line_nr, filename, _sapp.desc.logger.user_data);\n    }\n    else {\n        // for log level PANIC it would be 'undefined behaviour' to continue\n        if (log_level == 0) {\n            abort();\n        }\n    }\n}\n\n//                     \n//                         \n//                   \n//                             \n//                          \n//\n// >>memory\n_SOKOL_PRIVATE void _sapp_clear(void* ptr, size_t size) {\n    SOKOL_ASSERT(ptr && (size > 0));\n    memset(ptr, 0, size);\n}\n\n_SOKOL_PRIVATE void* _sapp_malloc(size_t size) {\n    SOKOL_ASSERT(size > 0);\n    void* ptr;\n    if (_sapp.desc.allocator.alloc_fn) {\n        ptr = _sapp.desc.allocator.alloc_fn(size, _sapp.desc.allocator.user_data);\n    } else {\n        ptr = malloc(size);\n    }\n    if (0 == ptr) {\n        _SAPP_PANIC(MALLOC_FAILED);\n    }\n    return ptr;\n}\n\n_SOKOL_PRIVATE void* _sapp_malloc_clear(size_t size) {\n    void* ptr = _sapp_malloc(size);\n    _sapp_clear(ptr, size);\n    return ptr;\n}\n\n_SOKOL_PRIVATE void _sapp_free(void* ptr) {\n    if (_sapp.desc.allocator.free_fn) {\n        _sapp.desc.allocator.free_fn(ptr, _sapp.desc.allocator.user_data);\n    }\n    else {\n        free(ptr);\n    }\n}\n\n//                 \n//                               \n//                  \n//                                      \n//                  \n//\n// >>helpers\n_SOKOL_PRIVATE void _sapp_call_init(void) {\n    if (_sapp.desc.init_cb) {\n        _sapp.desc.init_cb();\n    }\n    else if (_sapp.desc.init_userdata_cb) {\n        _sapp.desc.init_userdata_cb(_sapp.desc.user_data);\n    }\n    _sapp.init_called = true;\n}\n\n_SOKOL_PRIVATE void _sapp_call_frame(void) {\n    if (_sapp.init_called && !_sapp.cleanup_called) {\n        if (_sapp.desc.frame_cb) {\n            _sapp.desc.frame_cb();\n        }\n        else if (_sapp.desc.frame_userdata_cb) {\n            _sapp.desc.frame_userdata_cb(_sapp.desc.user_data);\n        }\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_call_cleanup(void) {\n    if (!_sapp.cleanup_called) {\n        if (_sapp.desc.cleanup_cb) {\n            _sapp.desc.cleanup_cb();\n        }\n        else if (_sapp.desc.cleanup_userdata_cb) {\n            _sapp.desc.cleanup_userdata_cb(_sapp.desc.user_data);\n        }\n        _sapp.cleanup_called = true;\n    }\n}\n\n_SOKOL_PRIVATE bool _sapp_call_event(const sapp_event* e) {\n    if (!_sapp.cleanup_called) {\n        if (_sapp.desc.event_cb) {\n            _sapp.desc.event_cb(e);\n        }\n        else if (_sapp.desc.event_userdata_cb) {\n            _sapp.desc.event_userdata_cb(e, _sapp.desc.user_data);\n        }\n    }\n    if (_sapp.event_consumed) {\n        _sapp.event_consumed = false;\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\n_SOKOL_PRIVATE char* _sapp_dropped_file_path_ptr(int index) {\n    SOKOL_ASSERT(_sapp.drop.buffer);\n    SOKOL_ASSERT((index >= 0) && (index <= _sapp.drop.max_files));\n    int offset = index * _sapp.drop.max_path_length;\n    SOKOL_ASSERT(offset < _sapp.drop.buf_size);\n    return &_sapp.drop.buffer[offset];\n}\n\n/* Copy a string into a fixed size buffer with guaranteed zero-\n   termination.\n\n   Return false if the string didn't fit into the buffer and had to be clamped.\n\n   FIXME: Currently UTF-8 strings might become invalid if the string\n   is clamped, because the last zero-byte might be written into\n   the middle of a multi-byte sequence.\n*/\n_SOKOL_PRIVATE bool _sapp_strcpy(const char* src, char* dst, int max_len) {\n    SOKOL_ASSERT(src && dst && (max_len > 0));\n    char* const end = &(dst[max_len-1]);\n    char c = 0;\n    for (int i = 0; i < max_len; i++) {\n        c = *src;\n        if (c != 0) {\n            src++;\n        }\n        *dst++ = c;\n    }\n    /* truncated? */\n    if (c != 0) {\n        *end = 0;\n        return false;\n    }\n    else {\n        return true;\n    }\n}\n\n_SOKOL_PRIVATE sapp_desc _sapp_desc_defaults(const sapp_desc* desc) {\n    SOKOL_ASSERT((desc->allocator.alloc_fn && desc->allocator.free_fn) || (!desc->allocator.alloc_fn && !desc->allocator.free_fn));\n    sapp_desc res = *desc;\n    res.sample_count = _sapp_def(res.sample_count, 1);\n    res.swap_interval = _sapp_def(res.swap_interval, 1);\n    // NOTE: can't patch the default for gl_major_version and gl_minor_version\n    // independently, because a desired version 4.0 would be patched to 4.2\n    // (or expressed differently: zero is a valid value for gl_minor_version\n    // and can't be used to indicate 'default')\n    if (0 == res.gl_major_version) {\n        #if defined(_SAPP_APPLE)\n            res.gl_major_version = 4;\n            res.gl_minor_version = 1;\n        #else\n            res.gl_major_version = 4;\n            res.gl_minor_version = 3;\n        #endif\n    }\n    res.html5_canvas_selector = _sapp_def(res.html5_canvas_selector, \"#canvas\");\n    res.clipboard_size = _sapp_def(res.clipboard_size, 8192);\n    res.max_dropped_files = _sapp_def(res.max_dropped_files, 1);\n    res.max_dropped_file_path_length = _sapp_def(res.max_dropped_file_path_length, 2048);\n    res.window_title = _sapp_def(res.window_title, \"sokol\");\n    return res;\n}\n\n_SOKOL_PRIVATE void _sapp_init_state(const sapp_desc* desc) {\n    SOKOL_ASSERT(desc);\n    SOKOL_ASSERT(desc->width >= 0);\n    SOKOL_ASSERT(desc->height >= 0);\n    SOKOL_ASSERT(desc->sample_count >= 0);\n    SOKOL_ASSERT(desc->swap_interval >= 0);\n    SOKOL_ASSERT(desc->clipboard_size >= 0);\n    SOKOL_ASSERT(desc->max_dropped_files >= 0);\n    SOKOL_ASSERT(desc->max_dropped_file_path_length >= 0);\n    _SAPP_CLEAR_ARC_STRUCT(_sapp_t, _sapp);\n    _sapp.desc = _sapp_desc_defaults(desc);\n    _sapp.first_frame = true;\n    // NOTE: _sapp.desc.width/height may be 0! Platform backends need to deal with this\n    _sapp.window_width = _sapp.desc.width;\n    _sapp.window_height = _sapp.desc.height;\n    _sapp.framebuffer_width = _sapp.window_width;\n    _sapp.framebuffer_height = _sapp.window_height;\n    _sapp.sample_count = _sapp.desc.sample_count;\n    _sapp.swap_interval = _sapp.desc.swap_interval;\n    _sapp_strcpy(_sapp.desc.html5_canvas_selector, _sapp.html5_canvas_selector, sizeof(_sapp.html5_canvas_selector));\n    _sapp.desc.html5_canvas_selector = _sapp.html5_canvas_selector;\n    _sapp.html5_ask_leave_site = _sapp.desc.html5_ask_leave_site;\n    _sapp.clipboard.enabled = _sapp.desc.enable_clipboard;\n    if (_sapp.clipboard.enabled) {\n        _sapp.clipboard.buf_size = _sapp.desc.clipboard_size;\n        _sapp.clipboard.buffer = (char*) _sapp_malloc_clear((size_t)_sapp.clipboard.buf_size);\n    }\n    _sapp.drop.enabled = _sapp.desc.enable_dragndrop;\n    if (_sapp.drop.enabled) {\n        _sapp.drop.max_files = _sapp.desc.max_dropped_files;\n        _sapp.drop.max_path_length = _sapp.desc.max_dropped_file_path_length;\n        _sapp.drop.buf_size = _sapp.drop.max_files * _sapp.drop.max_path_length;\n        _sapp.drop.buffer = (char*) _sapp_malloc_clear((size_t)_sapp.drop.buf_size);\n    }\n    _sapp_strcpy(_sapp.desc.window_title, _sapp.window_title, sizeof(_sapp.window_title));\n    _sapp.desc.window_title = _sapp.window_title;\n    _sapp.dpi_scale = 1.0f;\n    _sapp.fullscreen = _sapp.desc.fullscreen;\n    _sapp.mouse.shown = true;\n    _sapp_timing_init(&_sapp.timing);\n}\n\n_SOKOL_PRIVATE void _sapp_discard_state(void) {\n    if (_sapp.clipboard.enabled) {\n        SOKOL_ASSERT(_sapp.clipboard.buffer);\n        _sapp_free((void*)_sapp.clipboard.buffer);\n    }\n    if (_sapp.drop.enabled) {\n        SOKOL_ASSERT(_sapp.drop.buffer);\n        _sapp_free((void*)_sapp.drop.buffer);\n    }\n    if (_sapp.default_icon_pixels) {\n        _sapp_free((void*)_sapp.default_icon_pixels);\n    }\n    _SAPP_CLEAR_ARC_STRUCT(_sapp_t, _sapp);\n}\n\n_SOKOL_PRIVATE void _sapp_init_event(sapp_event_type type) {\n    _sapp_clear(&_sapp.event, sizeof(_sapp.event));\n    _sapp.event.type = type;\n    _sapp.event.frame_count = _sapp.frame_count;\n    _sapp.event.mouse_button = SAPP_MOUSEBUTTON_INVALID;\n    _sapp.event.window_width = _sapp.window_width;\n    _sapp.event.window_height = _sapp.window_height;\n    _sapp.event.framebuffer_width = _sapp.framebuffer_width;\n    _sapp.event.framebuffer_height = _sapp.framebuffer_height;\n    _sapp.event.mouse_x = _sapp.mouse.x;\n    _sapp.event.mouse_y = _sapp.mouse.y;\n    _sapp.event.mouse_dx = _sapp.mouse.dx;\n    _sapp.event.mouse_dy = _sapp.mouse.dy;\n}\n\n_SOKOL_PRIVATE bool _sapp_events_enabled(void) {\n    /* only send events when an event callback is set, and the init function was called */\n    return (_sapp.desc.event_cb || _sapp.desc.event_userdata_cb) && _sapp.init_called;\n}\n\n_SOKOL_PRIVATE sapp_keycode _sapp_translate_key(int scan_code) {\n    if ((scan_code >= 0) && (scan_code < SAPP_MAX_KEYCODES)) {\n        return _sapp.keycodes[scan_code];\n    }\n    else {\n        return SAPP_KEYCODE_INVALID;\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_clear_drop_buffer(void) {\n    if (_sapp.drop.enabled) {\n        SOKOL_ASSERT(_sapp.drop.buffer);\n        _sapp_clear(_sapp.drop.buffer, (size_t)_sapp.drop.buf_size);\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_frame(void) {\n    if (_sapp.first_frame) {\n        _sapp.first_frame = false;\n        _sapp_call_init();\n    }\n    _sapp_call_frame();\n    _sapp.frame_count++;\n}\n\n_SOKOL_PRIVATE bool _sapp_image_validate(const sapp_image_desc* desc) {\n    SOKOL_ASSERT(desc->width > 0);\n    SOKOL_ASSERT(desc->height > 0);\n    SOKOL_ASSERT(desc->pixels.ptr != 0);\n    SOKOL_ASSERT(desc->pixels.size > 0);\n    const size_t wh_size = (size_t)(desc->width * desc->height) * sizeof(uint32_t);\n    if (wh_size != desc->pixels.size) {\n        _SAPP_ERROR(IMAGE_DATA_SIZE_MISMATCH);\n        return false;\n    }\n    return true;\n}\n\n_SOKOL_PRIVATE int _sapp_image_bestmatch(const sapp_image_desc image_descs[], int num_images, int width, int height) {\n    int least_diff = 0x7FFFFFFF;\n    int least_index = 0;\n    for (int i = 0; i < num_images; i++) {\n        int diff = (image_descs[i].width * image_descs[i].height) - (width * height);\n        if (diff < 0) {\n            diff = -diff;\n        }\n        if (diff < least_diff) {\n            least_diff = diff;\n            least_index = i;\n        }\n    }\n    return least_index;\n}\n\n_SOKOL_PRIVATE int _sapp_icon_num_images(const sapp_icon_desc* desc) {\n    int index = 0;\n    for (; index < SAPP_MAX_ICONIMAGES; index++) {\n        if (0 == desc->images[index].pixels.ptr) {\n            break;\n        }\n    }\n    return index;\n}\n\n_SOKOL_PRIVATE bool _sapp_validate_icon_desc(const sapp_icon_desc* desc, int num_images) {\n    SOKOL_ASSERT(num_images <= SAPP_MAX_ICONIMAGES);\n    for (int i = 0; i < num_images; i++) {\n        const sapp_image_desc* img_desc = &desc->images[i];\n        if (!_sapp_image_validate(img_desc)) {\n            return false;\n        }\n    }\n    return true;\n}\n\n_SOKOL_PRIVATE void _sapp_setup_default_icon(void) {\n    SOKOL_ASSERT(0 == _sapp.default_icon_pixels);\n\n    const int num_icons = 3;\n    const int icon_sizes[3] = { 16, 32, 64 };   // must be multiple of 8!\n\n    // allocate a pixel buffer for all icon pixels\n    int all_num_pixels = 0;\n    for (int i = 0; i < num_icons; i++) {\n        all_num_pixels += icon_sizes[i] * icon_sizes[i];\n    }\n    _sapp.default_icon_pixels = (uint32_t*) _sapp_malloc_clear((size_t)all_num_pixels * sizeof(uint32_t));\n\n    // initialize default_icon_desc struct\n    uint32_t* dst = _sapp.default_icon_pixels;\n    const uint32_t* dst_end = dst + all_num_pixels;\n    (void)dst_end; // silence unused warning in release mode\n    for (int i = 0; i < num_icons; i++) {\n        const int dim = (int) icon_sizes[i];\n        const int num_pixels = dim * dim;\n        sapp_image_desc* img_desc = &_sapp.default_icon_desc.images[i];\n        img_desc->width = dim;\n        img_desc->height = dim;\n        img_desc->pixels.ptr = dst;\n        img_desc->pixels.size = (size_t)num_pixels * sizeof(uint32_t);\n        dst += num_pixels;\n    }\n    SOKOL_ASSERT(dst == dst_end);\n\n    // Amstrad CPC font 'S'\n    const uint8_t tile[8] = {\n        0x3C,\n        0x66,\n        0x60,\n        0x3C,\n        0x06,\n        0x66,\n        0x3C,\n        0x00,\n    };\n    // rainbow colors\n    const uint32_t colors[8] = {\n        0xFF4370FF,\n        0xFF26A7FF,\n        0xFF58EEFF,\n        0xFF57E1D4,\n        0xFF65CC9C,\n        0xFF6ABB66,\n        0xFFF5A542,\n        0xFFC2577E,\n    };\n    dst = _sapp.default_icon_pixels;\n    const uint32_t blank = 0x00FFFFFF;\n    const uint32_t shadow = 0xFF000000;\n    for (int i = 0; i < num_icons; i++) {\n        const int dim = icon_sizes[i];\n        SOKOL_ASSERT((dim % 8) == 0);\n        const int scale = dim / 8;\n        for (int ty = 0, y = 0; ty < 8; ty++) {\n            const uint32_t color = colors[ty];\n            for (int sy = 0; sy < scale; sy++, y++) {\n                uint8_t bits = tile[ty];\n                for (int tx = 0, x = 0; tx < 8; tx++, bits<<=1) {\n                    uint32_t pixel = (0 == (bits & 0x80)) ? blank : color;\n                    for (int sx = 0; sx < scale; sx++, x++) {\n                        SOKOL_ASSERT(dst < dst_end);\n                        *dst++ = pixel;\n                    }\n                }\n            }\n        }\n    }\n    SOKOL_ASSERT(dst == dst_end);\n\n    // right shadow\n    dst = _sapp.default_icon_pixels;\n    for (int i = 0; i < num_icons; i++) {\n        const int dim = icon_sizes[i];\n        for (int y = 0; y < dim; y++) {\n            uint32_t prev_color = blank;\n            for (int x = 0; x < dim; x++) {\n                const int dst_index = y * dim + x;\n                const uint32_t cur_color = dst[dst_index];\n                if ((cur_color == blank) && (prev_color != blank)) {\n                    dst[dst_index] = shadow;\n                }\n                prev_color = cur_color;\n            }\n        }\n        dst += dim * dim;\n    }\n    SOKOL_ASSERT(dst == dst_end);\n\n    // bottom shadow\n    dst = _sapp.default_icon_pixels;\n    for (int i = 0; i < num_icons; i++) {\n        const int dim = icon_sizes[i];\n        for (int x = 0; x < dim; x++) {\n            uint32_t prev_color = blank;\n            for (int y = 0; y < dim; y++) {\n                const int dst_index = y * dim + x;\n                const uint32_t cur_color = dst[dst_index];\n                if ((cur_color == blank) && (prev_color != blank)) {\n                    dst[dst_index] = shadow;\n                }\n                prev_color = cur_color;\n            }\n        }\n        dst += dim * dim;\n    }\n    SOKOL_ASSERT(dst == dst_end);\n}\n\n//              \n//                   \n//            \n//                       \n//                  \n//\n// >>apple\n#if defined(_SAPP_APPLE)\n\n#if __has_feature(objc_arc)\n#define _SAPP_OBJC_RELEASE(obj) { obj = nil; }\n#else\n#define _SAPP_OBJC_RELEASE(obj) { [obj release]; obj = nil; }\n#endif\n\n//              \n//                   \n//                \n//                          \n//                 \n//\n// >>macos\n#if defined(_SAPP_MACOS)\n\n_SOKOL_PRIVATE void _sapp_macos_init_keytable(void) {\n    _sapp.keycodes[0x1D] = SAPP_KEYCODE_0;\n    _sapp.keycodes[0x12] = SAPP_KEYCODE_1;\n    _sapp.keycodes[0x13] = SAPP_KEYCODE_2;\n    _sapp.keycodes[0x14] = SAPP_KEYCODE_3;\n    _sapp.keycodes[0x15] = SAPP_KEYCODE_4;\n    _sapp.keycodes[0x17] = SAPP_KEYCODE_5;\n    _sapp.keycodes[0x16] = SAPP_KEYCODE_6;\n    _sapp.keycodes[0x1A] = SAPP_KEYCODE_7;\n    _sapp.keycodes[0x1C] = SAPP_KEYCODE_8;\n    _sapp.keycodes[0x19] = SAPP_KEYCODE_9;\n    _sapp.keycodes[0x00] = SAPP_KEYCODE_A;\n    _sapp.keycodes[0x0B] = SAPP_KEYCODE_B;\n    _sapp.keycodes[0x08] = SAPP_KEYCODE_C;\n    _sapp.keycodes[0x02] = SAPP_KEYCODE_D;\n    _sapp.keycodes[0x0E] = SAPP_KEYCODE_E;\n    _sapp.keycodes[0x03] = SAPP_KEYCODE_F;\n    _sapp.keycodes[0x05] = SAPP_KEYCODE_G;\n    _sapp.keycodes[0x04] = SAPP_KEYCODE_H;\n    _sapp.keycodes[0x22] = SAPP_KEYCODE_I;\n    _sapp.keycodes[0x26] = SAPP_KEYCODE_J;\n    _sapp.keycodes[0x28] = SAPP_KEYCODE_K;\n    _sapp.keycodes[0x25] = SAPP_KEYCODE_L;\n    _sapp.keycodes[0x2E] = SAPP_KEYCODE_M;\n    _sapp.keycodes[0x2D] = SAPP_KEYCODE_N;\n    _sapp.keycodes[0x1F] = SAPP_KEYCODE_O;\n    _sapp.keycodes[0x23] = SAPP_KEYCODE_P;\n    _sapp.keycodes[0x0C] = SAPP_KEYCODE_Q;\n    _sapp.keycodes[0x0F] = SAPP_KEYCODE_R;\n    _sapp.keycodes[0x01] = SAPP_KEYCODE_S;\n    _sapp.keycodes[0x11] = SAPP_KEYCODE_T;\n    _sapp.keycodes[0x20] = SAPP_KEYCODE_U;\n    _sapp.keycodes[0x09] = SAPP_KEYCODE_V;\n    _sapp.keycodes[0x0D] = SAPP_KEYCODE_W;\n    _sapp.keycodes[0x07] = SAPP_KEYCODE_X;\n    _sapp.keycodes[0x10] = SAPP_KEYCODE_Y;\n    _sapp.keycodes[0x06] = SAPP_KEYCODE_Z;\n    _sapp.keycodes[0x27] = SAPP_KEYCODE_APOSTROPHE;\n    _sapp.keycodes[0x2A] = SAPP_KEYCODE_BACKSLASH;\n    _sapp.keycodes[0x2B] = SAPP_KEYCODE_COMMA;\n    _sapp.keycodes[0x18] = SAPP_KEYCODE_EQUAL;\n    _sapp.keycodes[0x32] = SAPP_KEYCODE_GRAVE_ACCENT;\n    _sapp.keycodes[0x21] = SAPP_KEYCODE_LEFT_BRACKET;\n    _sapp.keycodes[0x1B] = SAPP_KEYCODE_MINUS;\n    _sapp.keycodes[0x2F] = SAPP_KEYCODE_PERIOD;\n    _sapp.keycodes[0x1E] = SAPP_KEYCODE_RIGHT_BRACKET;\n    _sapp.keycodes[0x29] = SAPP_KEYCODE_SEMICOLON;\n    _sapp.keycodes[0x2C] = SAPP_KEYCODE_SLASH;\n    _sapp.keycodes[0x0A] = SAPP_KEYCODE_WORLD_1;\n    _sapp.keycodes[0x33] = SAPP_KEYCODE_BACKSPACE;\n    _sapp.keycodes[0x39] = SAPP_KEYCODE_CAPS_LOCK;\n    _sapp.keycodes[0x75] = SAPP_KEYCODE_DELETE;\n    _sapp.keycodes[0x7D] = SAPP_KEYCODE_DOWN;\n    _sapp.keycodes[0x77] = SAPP_KEYCODE_END;\n    _sapp.keycodes[0x24] = SAPP_KEYCODE_ENTER;\n    _sapp.keycodes[0x35] = SAPP_KEYCODE_ESCAPE;\n    _sapp.keycodes[0x7A] = SAPP_KEYCODE_F1;\n    _sapp.keycodes[0x78] = SAPP_KEYCODE_F2;\n    _sapp.keycodes[0x63] = SAPP_KEYCODE_F3;\n    _sapp.keycodes[0x76] = SAPP_KEYCODE_F4;\n    _sapp.keycodes[0x60] = SAPP_KEYCODE_F5;\n    _sapp.keycodes[0x61] = SAPP_KEYCODE_F6;\n    _sapp.keycodes[0x62] = SAPP_KEYCODE_F7;\n    _sapp.keycodes[0x64] = SAPP_KEYCODE_F8;\n    _sapp.keycodes[0x65] = SAPP_KEYCODE_F9;\n    _sapp.keycodes[0x6D] = SAPP_KEYCODE_F10;\n    _sapp.keycodes[0x67] = SAPP_KEYCODE_F11;\n    _sapp.keycodes[0x6F] = SAPP_KEYCODE_F12;\n    _sapp.keycodes[0x69] = SAPP_KEYCODE_F13;\n    _sapp.keycodes[0x6B] = SAPP_KEYCODE_F14;\n    _sapp.keycodes[0x71] = SAPP_KEYCODE_F15;\n    _sapp.keycodes[0x6A] = SAPP_KEYCODE_F16;\n    _sapp.keycodes[0x40] = SAPP_KEYCODE_F17;\n    _sapp.keycodes[0x4F] = SAPP_KEYCODE_F18;\n    _sapp.keycodes[0x50] = SAPP_KEYCODE_F19;\n    _sapp.keycodes[0x5A] = SAPP_KEYCODE_F20;\n    _sapp.keycodes[0x73] = SAPP_KEYCODE_HOME;\n    _sapp.keycodes[0x72] = SAPP_KEYCODE_INSERT;\n    _sapp.keycodes[0x7B] = SAPP_KEYCODE_LEFT;\n    _sapp.keycodes[0x3A] = SAPP_KEYCODE_LEFT_ALT;\n    _sapp.keycodes[0x3B] = SAPP_KEYCODE_LEFT_CONTROL;\n    _sapp.keycodes[0x38] = SAPP_KEYCODE_LEFT_SHIFT;\n    _sapp.keycodes[0x37] = SAPP_KEYCODE_LEFT_SUPER;\n    _sapp.keycodes[0x6E] = SAPP_KEYCODE_MENU;\n    _sapp.keycodes[0x47] = SAPP_KEYCODE_NUM_LOCK;\n    _sapp.keycodes[0x79] = SAPP_KEYCODE_PAGE_DOWN;\n    _sapp.keycodes[0x74] = SAPP_KEYCODE_PAGE_UP;\n    _sapp.keycodes[0x7C] = SAPP_KEYCODE_RIGHT;\n    _sapp.keycodes[0x3D] = SAPP_KEYCODE_RIGHT_ALT;\n    _sapp.keycodes[0x3E] = SAPP_KEYCODE_RIGHT_CONTROL;\n    _sapp.keycodes[0x3C] = SAPP_KEYCODE_RIGHT_SHIFT;\n    _sapp.keycodes[0x36] = SAPP_KEYCODE_RIGHT_SUPER;\n    _sapp.keycodes[0x31] = SAPP_KEYCODE_SPACE;\n    _sapp.keycodes[0x30] = SAPP_KEYCODE_TAB;\n    _sapp.keycodes[0x7E] = SAPP_KEYCODE_UP;\n    _sapp.keycodes[0x52] = SAPP_KEYCODE_KP_0;\n    _sapp.keycodes[0x53] = SAPP_KEYCODE_KP_1;\n    _sapp.keycodes[0x54] = SAPP_KEYCODE_KP_2;\n    _sapp.keycodes[0x55] = SAPP_KEYCODE_KP_3;\n    _sapp.keycodes[0x56] = SAPP_KEYCODE_KP_4;\n    _sapp.keycodes[0x57] = SAPP_KEYCODE_KP_5;\n    _sapp.keycodes[0x58] = SAPP_KEYCODE_KP_6;\n    _sapp.keycodes[0x59] = SAPP_KEYCODE_KP_7;\n    _sapp.keycodes[0x5B] = SAPP_KEYCODE_KP_8;\n    _sapp.keycodes[0x5C] = SAPP_KEYCODE_KP_9;\n    _sapp.keycodes[0x45] = SAPP_KEYCODE_KP_ADD;\n    _sapp.keycodes[0x41] = SAPP_KEYCODE_KP_DECIMAL;\n    _sapp.keycodes[0x4B] = SAPP_KEYCODE_KP_DIVIDE;\n    _sapp.keycodes[0x4C] = SAPP_KEYCODE_KP_ENTER;\n    _sapp.keycodes[0x51] = SAPP_KEYCODE_KP_EQUAL;\n    _sapp.keycodes[0x43] = SAPP_KEYCODE_KP_MULTIPLY;\n    _sapp.keycodes[0x4E] = SAPP_KEYCODE_KP_SUBTRACT;\n}\n\n_SOKOL_PRIVATE void _sapp_macos_discard_state(void) {\n    // NOTE: it's safe to call [release] on a nil object\n    if (_sapp.macos.keyup_monitor != nil) {\n        [NSEvent removeMonitor:_sapp.macos.keyup_monitor];\n        // NOTE: removeMonitor also releases the object\n        _sapp.macos.keyup_monitor = nil;\n    }\n    _SAPP_OBJC_RELEASE(_sapp.macos.tracking_area);\n    _SAPP_OBJC_RELEASE(_sapp.macos.app_dlg);\n    _SAPP_OBJC_RELEASE(_sapp.macos.win_dlg);\n    _SAPP_OBJC_RELEASE(_sapp.macos.view);\n    #if defined(SOKOL_METAL)\n        _SAPP_OBJC_RELEASE(_sapp.macos.mtl_device);\n    #endif\n    _SAPP_OBJC_RELEASE(_sapp.macos.window);\n}\n\n// undocumented methods for creating cursors (see GLFW 3.4 and imgui_impl_osx.mm)\n@interface NSCursor()\n+ (id)_windowResizeNorthWestSouthEastCursor;\n+ (id)_windowResizeNorthEastSouthWestCursor;\n+ (id)_windowResizeNorthSouthCursor;\n+ (id)_windowResizeEastWestCursor;\n@end\n\n_SOKOL_PRIVATE void _sapp_macos_init_cursors(void) {\n    _sapp.macos.cursors[SAPP_MOUSECURSOR_DEFAULT] = nil; // not a bug\n    _sapp.macos.cursors[SAPP_MOUSECURSOR_ARROW] = [NSCursor arrowCursor];\n    _sapp.macos.cursors[SAPP_MOUSECURSOR_IBEAM] = [NSCursor IBeamCursor];\n    _sapp.macos.cursors[SAPP_MOUSECURSOR_CROSSHAIR] = [NSCursor crosshairCursor];\n    _sapp.macos.cursors[SAPP_MOUSECURSOR_POINTING_HAND] = [NSCursor pointingHandCursor];\n    _sapp.macos.cursors[SAPP_MOUSECURSOR_RESIZE_EW] = [NSCursor respondsToSelector:@selector(_windowResizeEastWestCursor)] ? [NSCursor _windowResizeEastWestCursor] : [NSCursor resizeLeftRightCursor];\n    _sapp.macos.cursors[SAPP_MOUSECURSOR_RESIZE_NS] = [NSCursor respondsToSelector:@selector(_windowResizeNorthSouthCursor)] ? [NSCursor _windowResizeNorthSouthCursor] : [NSCursor resizeUpDownCursor];\n    _sapp.macos.cursors[SAPP_MOUSECURSOR_RESIZE_NWSE] = [NSCursor respondsToSelector:@selector(_windowResizeNorthWestSouthEastCursor)] ? [NSCursor _windowResizeNorthWestSouthEastCursor] : [NSCursor closedHandCursor];\n    _sapp.macos.cursors[SAPP_MOUSECURSOR_RESIZE_NESW] = [NSCursor respondsToSelector:@selector(_windowResizeNorthEastSouthWestCursor)] ? [NSCursor _windowResizeNorthEastSouthWestCursor] : [NSCursor closedHandCursor];\n    _sapp.macos.cursors[SAPP_MOUSECURSOR_RESIZE_ALL] = [NSCursor closedHandCursor];\n    _sapp.macos.cursors[SAPP_MOUSECURSOR_NOT_ALLOWED] = [NSCursor operationNotAllowedCursor];\n}\n\n_SOKOL_PRIVATE void _sapp_macos_run(const sapp_desc* desc) {\n    _sapp_init_state(desc);\n    _sapp_macos_init_keytable();\n    [NSApplication sharedApplication];\n\n    // set the application dock icon as early as possible, otherwise\n    // the dummy icon will be visible for a short time\n    sapp_set_icon(&_sapp.desc.icon);\n    _sapp.macos.app_dlg = [[_sapp_macos_app_delegate alloc] init];\n    NSApp.delegate = _sapp.macos.app_dlg;\n\n    // workaround for \"no key-up sent while Cmd is pressed\" taken from GLFW:\n    NSEvent* (^keyup_monitor)(NSEvent*) = ^NSEvent* (NSEvent* event) {\n        if ([event modifierFlags] & NSEventModifierFlagCommand) {\n            [[NSApp keyWindow] sendEvent:event];\n        }\n        return event;\n    };\n    _sapp.macos.keyup_monitor = [NSEvent addLocalMonitorForEventsMatchingMask:NSEventMaskKeyUp handler:keyup_monitor];\n\n    [NSApp run];\n    // NOTE: [NSApp run] never returns, instead cleanup code\n    // must be put into applicationWillTerminate\n}\n\n/* MacOS entry function */\n#if !defined(SOKOL_NO_ENTRY)\nint main(int argc, char* argv[]) {\n    sapp_desc desc = sokol_main(argc, argv);\n    _sapp_macos_run(&desc);\n    return 0;\n}\n#endif /* SOKOL_NO_ENTRY */\n\n_SOKOL_PRIVATE uint32_t _sapp_macos_mods(NSEvent* ev) {\n    const NSEventModifierFlags f = (ev == nil) ? NSEvent.modifierFlags : ev.modifierFlags;\n    const NSUInteger b = NSEvent.pressedMouseButtons;\n    uint32_t m = 0;\n    if (f & NSEventModifierFlagShift) {\n        m |= SAPP_MODIFIER_SHIFT;\n    }\n    if (f & NSEventModifierFlagControl) {\n        m |= SAPP_MODIFIER_CTRL;\n    }\n    if (f & NSEventModifierFlagOption) {\n        m |= SAPP_MODIFIER_ALT;\n    }\n    if (f & NSEventModifierFlagCommand) {\n        m |= SAPP_MODIFIER_SUPER;\n    }\n    if (0 != (b & (1<<0))) {\n        m |= SAPP_MODIFIER_LMB;\n    }\n    if (0 != (b & (1<<1))) {\n        m |= SAPP_MODIFIER_RMB;\n    }\n    if (0 != (b & (1<<2))) {\n        m |= SAPP_MODIFIER_MMB;\n    }\n    return m;\n}\n\n_SOKOL_PRIVATE void _sapp_macos_mouse_event(sapp_event_type type, sapp_mousebutton btn, uint32_t mod) {\n    if (_sapp_events_enabled()) {\n        _sapp_init_event(type);\n        _sapp.event.mouse_button = btn;\n        _sapp.event.modifiers = mod;\n        _sapp_call_event(&_sapp.event);\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_macos_key_event(sapp_event_type type, sapp_keycode key, bool repeat, uint32_t mod) {\n    if (_sapp_events_enabled()) {\n        _sapp_init_event(type);\n        _sapp.event.key_code = key;\n        _sapp.event.key_repeat = repeat;\n        _sapp.event.modifiers = mod;\n        _sapp_call_event(&_sapp.event);\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_macos_app_event(sapp_event_type type) {\n    if (_sapp_events_enabled()) {\n        _sapp_init_event(type);\n        _sapp_call_event(&_sapp.event);\n    }\n}\n\n/* NOTE: unlike the iOS version of this function, the macOS version\n    can dynamically update the DPI scaling factor when a window is moved\n    between HighDPI / LowDPI screens.\n*/\n_SOKOL_PRIVATE void _sapp_macos_update_dimensions(void) {\n    if (_sapp.desc.high_dpi) {\n        _sapp.dpi_scale = [_sapp.macos.window screen].backingScaleFactor;\n    }\n    else {\n        _sapp.dpi_scale = 1.0f;\n    }\n    _sapp.macos.view.layer.contentsScale = _sapp.dpi_scale; // NOTE: needed because we set layerContentsPlacement to a non-scaling value in windowWillStartLiveResize.\n    const NSRect bounds = [_sapp.macos.view bounds];\n    _sapp.window_width = (int)roundf(bounds.size.width);\n    _sapp.window_height = (int)roundf(bounds.size.height);\n    #if defined(SOKOL_METAL)\n        _sapp.framebuffer_width = (int)roundf(bounds.size.width * _sapp.dpi_scale);\n        _sapp.framebuffer_height = (int)roundf(bounds.size.height * _sapp.dpi_scale);\n        const CGSize fb_size = _sapp.macos.view.drawableSize;\n        const int cur_fb_width = (int)roundf(fb_size.width);\n        const int cur_fb_height = (int)roundf(fb_size.height);\n        const bool dim_changed = (_sapp.framebuffer_width != cur_fb_width) ||\n                                 (_sapp.framebuffer_height != cur_fb_height);\n    #elif defined(SOKOL_GLCORE)\n        const int cur_fb_width = (int)roundf(bounds.size.width * _sapp.dpi_scale);\n        const int cur_fb_height = (int)roundf(bounds.size.height * _sapp.dpi_scale);\n        const bool dim_changed = (_sapp.framebuffer_width != cur_fb_width) ||\n                                 (_sapp.framebuffer_height != cur_fb_height);\n        _sapp.framebuffer_width = cur_fb_width;\n        _sapp.framebuffer_height = cur_fb_height;\n    #endif\n    if (_sapp.framebuffer_width == 0) {\n        _sapp.framebuffer_width = 1;\n    }\n    if (_sapp.framebuffer_height == 0) {\n        _sapp.framebuffer_height = 1;\n    }\n    if (_sapp.window_width == 0) {\n        _sapp.window_width = 1;\n    }\n    if (_sapp.window_height == 0) {\n        _sapp.window_height = 1;\n    }\n    if (dim_changed) {\n        #if defined(SOKOL_METAL)\n            CGSize drawable_size = { (CGFloat) _sapp.framebuffer_width, (CGFloat) _sapp.framebuffer_height };\n            _sapp.macos.view.drawableSize = drawable_size;\n        #else\n            // nothing to do for GL?\n        #endif\n        if (!_sapp.first_frame) {\n            _sapp_macos_app_event(SAPP_EVENTTYPE_RESIZED);\n        }\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_macos_toggle_fullscreen(void) {\n    /* NOTE: the _sapp.fullscreen flag is also notified by the\n       windowDidEnterFullscreen / windowDidExitFullscreen\n       event handlers\n    */\n    _sapp.fullscreen = !_sapp.fullscreen;\n    [_sapp.macos.window toggleFullScreen:nil];\n}\n\n_SOKOL_PRIVATE void _sapp_macos_set_clipboard_string(const char* str) {\n    @autoreleasepool {\n        NSPasteboard* pasteboard = [NSPasteboard generalPasteboard];\n        [pasteboard declareTypes:@[NSPasteboardTypeString] owner:nil];\n        [pasteboard setString:@(str) forType:NSPasteboardTypeString];\n    }\n}\n\n_SOKOL_PRIVATE const char* _sapp_macos_get_clipboard_string(void) {\n    SOKOL_ASSERT(_sapp.clipboard.buffer);\n    @autoreleasepool {\n        _sapp.clipboard.buffer[0] = 0;\n        NSPasteboard* pasteboard = [NSPasteboard generalPasteboard];\n        if (![[pasteboard types] containsObject:NSPasteboardTypeString]) {\n            return _sapp.clipboard.buffer;\n        }\n        NSString* str = [pasteboard stringForType:NSPasteboardTypeString];\n        if (!str) {\n            return _sapp.clipboard.buffer;\n        }\n        _sapp_strcpy([str UTF8String], _sapp.clipboard.buffer, _sapp.clipboard.buf_size);\n    }\n    return _sapp.clipboard.buffer;\n}\n\n_SOKOL_PRIVATE void _sapp_macos_update_window_title(void) {\n    [_sapp.macos.window setTitle: [NSString stringWithUTF8String:_sapp.window_title]];\n}\n\n_SOKOL_PRIVATE void _sapp_macos_mouse_update_from_nspoint(NSPoint mouse_pos, bool clear_dxdy) {\n    if (!_sapp.mouse.locked) {\n        float new_x = mouse_pos.x * _sapp.dpi_scale;\n        float new_y = _sapp.framebuffer_height - (mouse_pos.y * _sapp.dpi_scale) - 1;\n        if (clear_dxdy) {\n            _sapp.mouse.dx = 0.0f;\n            _sapp.mouse.dy = 0.0f;\n        }\n        else if (_sapp.mouse.pos_valid) {\n            // don't update dx/dy in the very first update\n            _sapp.mouse.dx = new_x - _sapp.mouse.x;\n            _sapp.mouse.dy = new_y - _sapp.mouse.y;\n        }\n        _sapp.mouse.x = new_x;\n        _sapp.mouse.y = new_y;\n        _sapp.mouse.pos_valid = true;\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_macos_mouse_update_from_nsevent(NSEvent* event, bool clear_dxdy) {\n    _sapp_macos_mouse_update_from_nspoint(event.locationInWindow, clear_dxdy);\n}\n\n_SOKOL_PRIVATE void _sapp_macos_show_mouse(bool visible) {\n    /* NOTE: this function is only called when the mouse visibility actually changes */\n    if (visible) {\n        CGDisplayShowCursor(kCGDirectMainDisplay);\n    }\n    else {\n        CGDisplayHideCursor(kCGDirectMainDisplay);\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_macos_lock_mouse(bool lock) {\n    if (lock == _sapp.mouse.locked) {\n        return;\n    }\n    _sapp.mouse.dx = 0.0f;\n    _sapp.mouse.dy = 0.0f;\n    _sapp.mouse.locked = lock;\n    /*\n        NOTE that this code doesn't warp the mouse cursor to the window\n        center as everybody else does it. This lead to a spike in the\n        *second* mouse-moved event after the warp happened. The\n        mouse centering doesn't seem to be required (mouse-moved events\n        are reported correctly even when the cursor is at an edge of the screen).\n\n        NOTE also that the hide/show of the mouse cursor should properly\n        stack with calls to sapp_show_mouse()\n    */\n    if (_sapp.mouse.locked) {\n        CGAssociateMouseAndMouseCursorPosition(NO);\n        [NSCursor hide];\n    }\n    else {\n        [NSCursor unhide];\n        CGAssociateMouseAndMouseCursorPosition(YES);\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_macos_update_cursor(sapp_mouse_cursor cursor, bool shown) {\n    // show/hide cursor only if visibility status has changed (required because show/hide stacks)\n    if (shown != _sapp.mouse.shown) {\n        if (shown) {\n            [NSCursor unhide];\n        }\n        else {\n            [NSCursor hide];\n        }\n    }\n    // update cursor type\n    SOKOL_ASSERT((cursor >= 0) && (cursor < _SAPP_MOUSECURSOR_NUM));\n    if (_sapp.macos.cursors[cursor]) {\n        [_sapp.macos.cursors[cursor] set];\n    }\n    else {\n        [[NSCursor arrowCursor] set];\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_macos_set_icon(const sapp_icon_desc* icon_desc, int num_images) {\n    NSDockTile* dock_tile = NSApp.dockTile;\n    const int wanted_width = (int) dock_tile.size.width;\n    const int wanted_height = (int) dock_tile.size.height;\n    const int img_index = _sapp_image_bestmatch(icon_desc->images, num_images, wanted_width, wanted_height);\n    const sapp_image_desc* img_desc = &icon_desc->images[img_index];\n\n    CGColorSpaceRef cg_color_space = CGColorSpaceCreateDeviceRGB();\n    CFDataRef cf_data = CFDataCreate(kCFAllocatorDefault, (const UInt8*)img_desc->pixels.ptr, (CFIndex)img_desc->pixels.size);\n    CGDataProviderRef cg_data_provider = CGDataProviderCreateWithCFData(cf_data);\n    CGImageRef cg_img = CGImageCreate(\n        (size_t)img_desc->width,    // width\n        (size_t)img_desc->height,   // height\n        8,                          // bitsPerComponent\n        32,                         // bitsPerPixel\n        (size_t)img_desc->width * 4,// bytesPerRow\n        cg_color_space,             // space\n        kCGImageAlphaLast | kCGImageByteOrderDefault,  // bitmapInfo\n        cg_data_provider,           // provider\n        NULL,                       // decode\n        false,                      // shouldInterpolate\n        kCGRenderingIntentDefault);\n    CFRelease(cf_data);\n    CGDataProviderRelease(cg_data_provider);\n    CGColorSpaceRelease(cg_color_space);\n\n    NSImage* ns_image = [[NSImage alloc] initWithCGImage:cg_img size:dock_tile.size];\n    dock_tile.contentView = [NSImageView imageViewWithImage:ns_image];\n    [dock_tile display];\n    _SAPP_OBJC_RELEASE(ns_image);\n    CGImageRelease(cg_img);\n}\n\n_SOKOL_PRIVATE void _sapp_macos_frame(void) {\n    _sapp_frame();\n    if (_sapp.quit_requested || _sapp.quit_ordered) {\n        [_sapp.macos.window performClose:nil];\n    }\n}\n\n@implementation _sapp_macos_app_delegate\n- (void)applicationDidFinishLaunching:(NSNotification*)aNotification {\n    _SOKOL_UNUSED(aNotification);\n    _sapp_macos_init_cursors();\n    if ((_sapp.window_width == 0) || (_sapp.window_height == 0)) {\n        // use 4/5 of screen size as default size\n        NSRect screen_rect = NSScreen.mainScreen.frame;\n        if (_sapp.window_width == 0) {\n            _sapp.window_width = (int)roundf((screen_rect.size.width * 4.0f) / 5.0f);\n        }\n        if (_sapp.window_height == 0) {\n            _sapp.window_height = (int)roundf((screen_rect.size.height * 4.0f) / 5.0f);\n        }\n    }\n    const NSUInteger style =\n        NSWindowStyleMaskTitled |\n        NSWindowStyleMaskClosable |\n        NSWindowStyleMaskMiniaturizable |\n        NSWindowStyleMaskResizable;\n    NSRect window_rect = NSMakeRect(0, 0, _sapp.window_width, _sapp.window_height);\n    _sapp.macos.window = [[_sapp_macos_window alloc]\n        initWithContentRect:window_rect\n        styleMask:style\n        backing:NSBackingStoreBuffered\n        defer:NO];\n    _sapp.macos.window.releasedWhenClosed = NO; // this is necessary for proper cleanup in applicationWillTerminate\n    _sapp.macos.window.title = [NSString stringWithUTF8String:_sapp.window_title];\n    _sapp.macos.window.acceptsMouseMovedEvents = YES;\n    _sapp.macos.window.restorable = YES;\n\n    _sapp.macos.win_dlg = [[_sapp_macos_window_delegate alloc] init];\n    _sapp.macos.window.delegate = _sapp.macos.win_dlg;\n    #if defined(SOKOL_METAL)\n        NSInteger max_fps = 60;\n        #if (__MAC_OS_X_VERSION_MAX_ALLOWED >= 120000)\n        if (@available(macOS 12.0, *)) {\n            max_fps = [NSScreen.mainScreen maximumFramesPerSecond];\n        }\n        #endif\n        _sapp.macos.mtl_device = MTLCreateSystemDefaultDevice();\n        _sapp.macos.view = [[_sapp_macos_view alloc] init];\n        [_sapp.macos.view updateTrackingAreas];\n        _sapp.macos.view.preferredFramesPerSecond = max_fps / _sapp.swap_interval;\n        _sapp.macos.view.device = _sapp.macos.mtl_device;\n        _sapp.macos.view.colorPixelFormat = MTLPixelFormatBGRA8Unorm;\n        _sapp.macos.view.depthStencilPixelFormat = MTLPixelFormatDepth32Float_Stencil8;\n        _sapp.macos.view.sampleCount = (NSUInteger) _sapp.sample_count;\n        _sapp.macos.view.autoResizeDrawable = false;\n        _sapp.macos.window.contentView = _sapp.macos.view;\n        [_sapp.macos.window makeFirstResponder:_sapp.macos.view];\n        _sapp.macos.view.layer.magnificationFilter = kCAFilterNearest;\n    #elif defined(SOKOL_GLCORE)\n        NSOpenGLPixelFormatAttribute attrs[32];\n        int i = 0;\n        attrs[i++] = NSOpenGLPFAAccelerated;\n        attrs[i++] = NSOpenGLPFADoubleBuffer;\n        attrs[i++] = NSOpenGLPFAOpenGLProfile;\n        const int glVersion = _sapp.desc.gl_major_version * 10 + _sapp.desc.gl_minor_version;\n        switch(glVersion) {\n            case 10: attrs[i++] = NSOpenGLProfileVersionLegacy;  break;\n            case 32: attrs[i++] = NSOpenGLProfileVersion3_2Core; break;\n            case 41: attrs[i++] = NSOpenGLProfileVersion4_1Core; break;\n            default:\n                _SAPP_PANIC(MACOS_INVALID_NSOPENGL_PROFILE);\n        }\n        attrs[i++] = NSOpenGLPFAColorSize; attrs[i++] = 24;\n        attrs[i++] = NSOpenGLPFAAlphaSize; attrs[i++] = 8;\n        attrs[i++] = NSOpenGLPFADepthSize; attrs[i++] = 24;\n        attrs[i++] = NSOpenGLPFAStencilSize; attrs[i++] = 8;\n        if (_sapp.sample_count > 1) {\n            attrs[i++] = NSOpenGLPFAMultisample;\n            attrs[i++] = NSOpenGLPFASampleBuffers; attrs[i++] = 1;\n            attrs[i++] = NSOpenGLPFASamples; attrs[i++] = (NSOpenGLPixelFormatAttribute)_sapp.sample_count;\n        }\n        else {\n            attrs[i++] = NSOpenGLPFASampleBuffers; attrs[i++] = 0;\n        }\n        attrs[i++] = 0;\n        NSOpenGLPixelFormat* glpixelformat_obj = [[NSOpenGLPixelFormat alloc] initWithAttributes:attrs];\n        SOKOL_ASSERT(glpixelformat_obj != nil);\n\n        _sapp.macos.view = [[_sapp_macos_view alloc]\n            initWithFrame:window_rect\n            pixelFormat:glpixelformat_obj];\n        _SAPP_OBJC_RELEASE(glpixelformat_obj);\n        [_sapp.macos.view updateTrackingAreas];\n        if (_sapp.desc.high_dpi) {\n            [_sapp.macos.view setWantsBestResolutionOpenGLSurface:YES];\n        }\n        else {\n            [_sapp.macos.view setWantsBestResolutionOpenGLSurface:NO];\n        }\n\n        _sapp.macos.window.contentView = _sapp.macos.view;\n        [_sapp.macos.window makeFirstResponder:_sapp.macos.view];\n\n        NSTimer* timer_obj = [NSTimer timerWithTimeInterval:0.001\n            target:_sapp.macos.view\n            selector:@selector(timerFired:)\n            userInfo:nil\n            repeats:YES];\n        [[NSRunLoop currentRunLoop] addTimer:timer_obj forMode:NSDefaultRunLoopMode];\n        timer_obj = nil;\n    #endif\n    [_sapp.macos.window center];\n    _sapp.valid = true;\n    if (_sapp.fullscreen) {\n        /* ^^^ on GL, this already toggles a rendered frame, so set the valid flag before */\n        [_sapp.macos.window toggleFullScreen:self];\n    }\n    NSApp.activationPolicy = NSApplicationActivationPolicyRegular;\n    [NSApp activateIgnoringOtherApps:YES];\n    [_sapp.macos.window makeKeyAndOrderFront:nil];\n    _sapp_macos_update_dimensions();\n    [NSEvent setMouseCoalescingEnabled:NO];\n\n    // workaround for window not being focused during a long init callback\n    // for details see: https://github.com/floooh/sokol/pull/982\n    // also see: https://gitlab.gnome.org/GNOME/gtk/-/issues/2342\n    NSEvent *focusevent = [NSEvent otherEventWithType:NSEventTypeAppKitDefined\n        location:NSZeroPoint\n        modifierFlags:0x40\n        timestamp:0\n        windowNumber:0\n        context:nil\n        subtype:NSEventSubtypeApplicationActivated\n        data1:0\n        data2:0];\n    [NSApp postEvent:focusevent atStart:YES];\n}\n\n- (BOOL)applicationShouldTerminateAfterLastWindowClosed:(NSApplication*)sender {\n    _SOKOL_UNUSED(sender);\n    return YES;\n}\n\n- (void)applicationWillTerminate:(NSNotification*)notification {\n    _SOKOL_UNUSED(notification);\n    _sapp_call_cleanup();\n    _sapp_macos_discard_state();\n    _sapp_discard_state();\n}\n@end\n\n@implementation _sapp_macos_window_delegate\n- (BOOL)windowShouldClose:(id)sender {\n    _SOKOL_UNUSED(sender);\n    /* only give user-code a chance to intervene when sapp_quit() wasn't already called */\n    if (!_sapp.quit_ordered) {\n        /* if window should be closed and event handling is enabled, give user code\n           a chance to intervene via sapp_cancel_quit()\n        */\n        _sapp.quit_requested = true;\n        _sapp_macos_app_event(SAPP_EVENTTYPE_QUIT_REQUESTED);\n        /* user code hasn't intervened, quit the app */\n        if (_sapp.quit_requested) {\n            _sapp.quit_ordered = true;\n        }\n    }\n    if (_sapp.quit_ordered) {\n        return YES;\n    }\n    else {\n        return NO;\n    }\n}\n\n#if defined(SOKOL_METAL)\n- (void)windowWillStartLiveResize:(NSNotification *)notification {\n    // Work around the MTKView resizing glitch by \"anchoring\" the layer to the window corner opposite\n    // to the currently manipulated corner (or edge). This prevents the content stretching back and\n    // forth during resizing. This is a workaround for this issue: https://github.com/floooh/sokol/issues/700\n    // Can be removed if/when migrating to CAMetalLayer: https://github.com/floooh/sokol/issues/727\n    bool resizing_from_left = _sapp.mouse.x < _sapp.window_width/2;\n    bool resizing_from_top = _sapp.mouse.y < _sapp.window_height/2;\n    NSViewLayerContentsPlacement placement;\n    if (resizing_from_left) {\n        placement = resizing_from_top ? NSViewLayerContentsPlacementBottomRight : NSViewLayerContentsPlacementTopRight;\n    } else {\n        placement = resizing_from_top ? NSViewLayerContentsPlacementBottomLeft : NSViewLayerContentsPlacementTopLeft;\n    }\n    _sapp.macos.view.layerContentsPlacement = placement;\n}\n#endif\n\n- (void)windowDidResize:(NSNotification*)notification {\n    _SOKOL_UNUSED(notification);\n    _sapp_macos_update_dimensions();\n}\n\n- (void)windowDidChangeScreen:(NSNotification*)notification {\n    _SOKOL_UNUSED(notification);\n    _sapp_timing_reset(&_sapp.timing);\n    _sapp_macos_update_dimensions();\n}\n\n- (void)windowDidMiniaturize:(NSNotification*)notification {\n    _SOKOL_UNUSED(notification);\n    _sapp_macos_app_event(SAPP_EVENTTYPE_ICONIFIED);\n}\n\n- (void)windowDidDeminiaturize:(NSNotification*)notification {\n    _SOKOL_UNUSED(notification);\n    _sapp_macos_app_event(SAPP_EVENTTYPE_RESTORED);\n}\n\n- (void)windowDidBecomeKey:(NSNotification*)notification {\n    _SOKOL_UNUSED(notification);\n    _sapp_macos_app_event(SAPP_EVENTTYPE_FOCUSED);\n}\n\n- (void)windowDidResignKey:(NSNotification*)notification {\n    _SOKOL_UNUSED(notification);\n    _sapp_macos_app_event(SAPP_EVENTTYPE_UNFOCUSED);\n}\n\n- (void)windowDidEnterFullScreen:(NSNotification*)notification {\n    _SOKOL_UNUSED(notification);\n    _sapp.fullscreen = true;\n}\n\n- (void)windowDidExitFullScreen:(NSNotification*)notification {\n    _SOKOL_UNUSED(notification);\n    _sapp.fullscreen = false;\n}\n@end\n\n@implementation _sapp_macos_window\n- (instancetype)initWithContentRect:(NSRect)contentRect\n                          styleMask:(NSWindowStyleMask)style\n                            backing:(NSBackingStoreType)backingStoreType\n                              defer:(BOOL)flag {\n    if (self = [super initWithContentRect:contentRect styleMask:style backing:backingStoreType defer:flag]) {\n        #if __MAC_OS_X_VERSION_MAX_ALLOWED >= 101300\n            [self registerForDraggedTypes:[NSArray arrayWithObject:NSPasteboardTypeFileURL]];\n        #endif\n    }\n    return self;\n}\n\n- (NSDragOperation)draggingEntered:(id<NSDraggingInfo>)sender {\n    return NSDragOperationCopy;\n}\n\n- (NSDragOperation)draggingUpdated:(id<NSDraggingInfo>)sender {\n    return NSDragOperationCopy;\n}\n\n- (BOOL)performDragOperation:(id<NSDraggingInfo>)sender {\n    #if __MAC_OS_X_VERSION_MAX_ALLOWED >= 101300\n    NSPasteboard *pboard = [sender draggingPasteboard];\n    if ([pboard.types containsObject:NSPasteboardTypeFileURL]) {\n        _sapp_clear_drop_buffer();\n        _sapp.drop.num_files = ((int)pboard.pasteboardItems.count > _sapp.drop.max_files) ? _sapp.drop.max_files : (int)pboard.pasteboardItems.count;\n        bool drop_failed = false;\n        for (int i = 0; i < _sapp.drop.num_files; i++) {\n            NSURL *fileUrl = [NSURL fileURLWithPath:[pboard.pasteboardItems[(NSUInteger)i] stringForType:NSPasteboardTypeFileURL]];\n            if (!_sapp_strcpy(fileUrl.standardizedURL.path.UTF8String, _sapp_dropped_file_path_ptr(i), _sapp.drop.max_path_length)) {\n                _SAPP_ERROR(DROPPED_FILE_PATH_TOO_LONG);\n                drop_failed = true;\n                break;\n            }\n        }\n        if (!drop_failed) {\n            if (_sapp_events_enabled()) {\n                _sapp_macos_mouse_update_from_nspoint(sender.draggingLocation, true);\n                _sapp_init_event(SAPP_EVENTTYPE_FILES_DROPPED);\n                _sapp.event.modifiers = _sapp_macos_mods(nil);\n                _sapp_call_event(&_sapp.event);\n            }\n        }\n        else {\n            _sapp_clear_drop_buffer();\n            _sapp.drop.num_files = 0;\n        }\n        return YES;\n    }\n    #endif\n    return NO;\n}\n@end\n\n@implementation _sapp_macos_view\n#if defined(SOKOL_GLCORE)\n- (void)timerFired:(id)sender {\n    _SOKOL_UNUSED(sender);\n    [self setNeedsDisplay:YES];\n}\n- (void)prepareOpenGL {\n    [super prepareOpenGL];\n    GLint swapInt = 1;\n    NSOpenGLContext* ctx = [_sapp.macos.view openGLContext];\n    [ctx setValues:&swapInt forParameter:NSOpenGLContextParameterSwapInterval];\n    [ctx makeCurrentContext];\n}\n#endif\n\n_SOKOL_PRIVATE void _sapp_macos_poll_input_events(void) {\n    /*\n\n    NOTE: late event polling temporarily out-commented to check if this\n    causes infrequent and almost impossible to reproduce problems with the\n    window close events, see:\n    https://github.com/floooh/sokol/pull/483#issuecomment-805148815\n\n\n    const NSEventMask mask = NSEventMaskLeftMouseDown |\n                             NSEventMaskLeftMouseUp|\n                             NSEventMaskRightMouseDown |\n                             NSEventMaskRightMouseUp |\n                             NSEventMaskMouseMoved |\n                             NSEventMaskLeftMouseDragged |\n                             NSEventMaskRightMouseDragged |\n                             NSEventMaskMouseEntered |\n                             NSEventMaskMouseExited |\n                             NSEventMaskKeyDown |\n                             NSEventMaskKeyUp |\n                             NSEventMaskCursorUpdate |\n                             NSEventMaskScrollWheel |\n                             NSEventMaskTabletPoint |\n                             NSEventMaskTabletProximity |\n                             NSEventMaskOtherMouseDown |\n                             NSEventMaskOtherMouseUp |\n                             NSEventMaskOtherMouseDragged |\n                             NSEventMaskPressure |\n                             NSEventMaskDirectTouch;\n    @autoreleasepool {\n        for (;;) {\n            // NOTE: using NSDefaultRunLoopMode here causes stuttering in the GL backend,\n            // see: https://github.com/floooh/sokol/issues/486\n            NSEvent* event = [NSApp nextEventMatchingMask:mask untilDate:nil inMode:NSEventTrackingRunLoopMode dequeue:YES];\n            if (event == nil) {\n                break;\n            }\n            [NSApp sendEvent:event];\n        }\n    }\n    */\n}\n\n- (void)drawRect:(NSRect)rect {\n    _SOKOL_UNUSED(rect);\n    #if defined(_SAPP_ANY_GL)\n    glGetIntegerv(GL_FRAMEBUFFER_BINDING, (GLint*)&_sapp.gl.framebuffer);\n    #endif\n    _sapp_timing_measure(&_sapp.timing);\n    /* Catch any last-moment input events */\n    _sapp_macos_poll_input_events();\n    @autoreleasepool {\n        _sapp_macos_frame();\n    }\n    #if defined(_SAPP_ANY_GL)\n    [[_sapp.macos.view openGLContext] flushBuffer];\n    #endif\n}\n\n- (BOOL)isOpaque {\n    return YES;\n}\n- (BOOL)canBecomeKeyView {\n    return YES;\n}\n- (BOOL)acceptsFirstResponder {\n    return YES;\n}\n- (void)updateTrackingAreas {\n    if (_sapp.macos.tracking_area != nil) {\n        [self removeTrackingArea:_sapp.macos.tracking_area];\n        _SAPP_OBJC_RELEASE(_sapp.macos.tracking_area);\n    }\n    const NSTrackingAreaOptions options = NSTrackingMouseEnteredAndExited |\n                                          NSTrackingActiveInKeyWindow |\n                                          NSTrackingEnabledDuringMouseDrag |\n                                          NSTrackingCursorUpdate |\n                                          NSTrackingInVisibleRect |\n                                          NSTrackingAssumeInside;\n    _sapp.macos.tracking_area = [[NSTrackingArea alloc] initWithRect:[self bounds] options:options owner:self userInfo:nil];\n    [self addTrackingArea:_sapp.macos.tracking_area];\n    [super updateTrackingAreas];\n}\n\n// helper function to make GL context active\nstatic void _sapp_gl_make_current(void) {\n    #if defined(SOKOL_GLCORE)\n    [[_sapp.macos.view openGLContext] makeCurrentContext];\n    #endif\n}\n\n- (void)mouseEntered:(NSEvent*)event {\n    _sapp_gl_make_current();\n    _sapp_macos_mouse_update_from_nsevent(event, true);\n    /* don't send mouse enter/leave while dragging (so that it behaves the same as\n       on Windows while SetCapture is active\n    */\n    if (0 == _sapp.macos.mouse_buttons) {\n        _sapp_macos_mouse_event(SAPP_EVENTTYPE_MOUSE_ENTER, SAPP_MOUSEBUTTON_INVALID, _sapp_macos_mods(event));\n    }\n}\n- (void)mouseExited:(NSEvent*)event {\n    _sapp_gl_make_current();\n    _sapp_macos_mouse_update_from_nsevent(event, true);\n    if (0 == _sapp.macos.mouse_buttons) {\n        _sapp_macos_mouse_event(SAPP_EVENTTYPE_MOUSE_LEAVE, SAPP_MOUSEBUTTON_INVALID, _sapp_macos_mods(event));\n    }\n}\n- (void)mouseDown:(NSEvent*)event {\n    _sapp_gl_make_current();\n    _sapp_macos_mouse_update_from_nsevent(event, false);\n    _sapp_macos_mouse_event(SAPP_EVENTTYPE_MOUSE_DOWN, SAPP_MOUSEBUTTON_LEFT, _sapp_macos_mods(event));\n    _sapp.macos.mouse_buttons |= (1<<SAPP_MOUSEBUTTON_LEFT);\n}\n- (void)mouseUp:(NSEvent*)event {\n    _sapp_gl_make_current();\n    _sapp_macos_mouse_update_from_nsevent(event, false);\n    _sapp_macos_mouse_event(SAPP_EVENTTYPE_MOUSE_UP, SAPP_MOUSEBUTTON_LEFT, _sapp_macos_mods(event));\n    _sapp.macos.mouse_buttons &= ~(1<<SAPP_MOUSEBUTTON_LEFT);\n}\n- (void)rightMouseDown:(NSEvent*)event {\n    _sapp_gl_make_current();\n    _sapp_macos_mouse_update_from_nsevent(event, false);\n    _sapp_macos_mouse_event(SAPP_EVENTTYPE_MOUSE_DOWN, SAPP_MOUSEBUTTON_RIGHT, _sapp_macos_mods(event));\n    _sapp.macos.mouse_buttons |= (1<<SAPP_MOUSEBUTTON_RIGHT);\n}\n- (void)rightMouseUp:(NSEvent*)event {\n    _sapp_gl_make_current();\n    _sapp_macos_mouse_update_from_nsevent(event, false);\n    _sapp_macos_mouse_event(SAPP_EVENTTYPE_MOUSE_UP, SAPP_MOUSEBUTTON_RIGHT, _sapp_macos_mods(event));\n    _sapp.macos.mouse_buttons &= ~(1<<SAPP_MOUSEBUTTON_RIGHT);\n}\n- (void)otherMouseDown:(NSEvent*)event {\n    _sapp_gl_make_current();\n    _sapp_macos_mouse_update_from_nsevent(event, false);\n    if (2 == event.buttonNumber) {\n        _sapp_macos_mouse_event(SAPP_EVENTTYPE_MOUSE_DOWN, SAPP_MOUSEBUTTON_MIDDLE, _sapp_macos_mods(event));\n        _sapp.macos.mouse_buttons |= (1<<SAPP_MOUSEBUTTON_MIDDLE);\n    }\n}\n- (void)otherMouseUp:(NSEvent*)event {\n    _sapp_gl_make_current();\n    _sapp_macos_mouse_update_from_nsevent(event, false);\n    if (2 == event.buttonNumber) {\n        _sapp_macos_mouse_event(SAPP_EVENTTYPE_MOUSE_UP, SAPP_MOUSEBUTTON_MIDDLE, _sapp_macos_mods(event));\n        _sapp.macos.mouse_buttons &= (1<<SAPP_MOUSEBUTTON_MIDDLE);\n    }\n}\n- (void)otherMouseDragged:(NSEvent*)event {\n    _sapp_gl_make_current();\n    _sapp_macos_mouse_update_from_nsevent(event, false);\n    if (2 == event.buttonNumber) {\n        if (_sapp.mouse.locked) {\n            _sapp.mouse.dx = [event deltaX];\n            _sapp.mouse.dy = [event deltaY];\n        }\n        _sapp_macos_mouse_event(SAPP_EVENTTYPE_MOUSE_MOVE, SAPP_MOUSEBUTTON_INVALID, _sapp_macos_mods(event));\n    }\n}\n- (void)mouseMoved:(NSEvent*)event {\n    _sapp_gl_make_current();\n    _sapp_macos_mouse_update_from_nsevent(event, false);\n    if (_sapp.mouse.locked) {\n        _sapp.mouse.dx = [event deltaX];\n        _sapp.mouse.dy = [event deltaY];\n    }\n    _sapp_macos_mouse_event(SAPP_EVENTTYPE_MOUSE_MOVE, SAPP_MOUSEBUTTON_INVALID , _sapp_macos_mods(event));\n}\n- (void)mouseDragged:(NSEvent*)event {\n    _sapp_gl_make_current();\n    _sapp_macos_mouse_update_from_nsevent(event, false);\n    if (_sapp.mouse.locked) {\n        _sapp.mouse.dx = [event deltaX];\n        _sapp.mouse.dy = [event deltaY];\n    }\n    _sapp_macos_mouse_event(SAPP_EVENTTYPE_MOUSE_MOVE, SAPP_MOUSEBUTTON_INVALID , _sapp_macos_mods(event));\n}\n- (void)rightMouseDragged:(NSEvent*)event {\n    _sapp_gl_make_current();\n    _sapp_macos_mouse_update_from_nsevent(event, false);\n    if (_sapp.mouse.locked) {\n        _sapp.mouse.dx = [event deltaX];\n        _sapp.mouse.dy = [event deltaY];\n    }\n    _sapp_macos_mouse_event(SAPP_EVENTTYPE_MOUSE_MOVE, SAPP_MOUSEBUTTON_INVALID, _sapp_macos_mods(event));\n}\n- (void)scrollWheel:(NSEvent*)event {\n    _sapp_gl_make_current();\n    _sapp_macos_mouse_update_from_nsevent(event, true);\n    if (_sapp_events_enabled()) {\n        float dx = (float) event.scrollingDeltaX;\n        float dy = (float) event.scrollingDeltaY;\n        if (event.hasPreciseScrollingDeltas) {\n            dx *= 0.1;\n            dy *= 0.1;\n        }\n        if ((_sapp_absf(dx) > 0.0f) || (_sapp_absf(dy) > 0.0f)) {\n            _sapp_init_event(SAPP_EVENTTYPE_MOUSE_SCROLL);\n            _sapp.event.modifiers = _sapp_macos_mods(event);\n            _sapp.event.scroll_x = dx;\n            _sapp.event.scroll_y = dy;\n            _sapp_call_event(&_sapp.event);\n        }\n    }\n}\n- (void)keyDown:(NSEvent*)event {\n    if (_sapp_events_enabled()) {\n        _sapp_gl_make_current();\n        const uint32_t mods = _sapp_macos_mods(event);\n        const sapp_keycode key_code = _sapp_translate_key(event.keyCode);\n        _sapp_macos_key_event(SAPP_EVENTTYPE_KEY_DOWN, key_code, event.isARepeat, mods);\n        const NSString* chars = event.characters;\n        const NSUInteger len = chars.length;\n        if (len > 0) {\n            _sapp_init_event(SAPP_EVENTTYPE_CHAR);\n            _sapp.event.modifiers = mods;\n            for (NSUInteger i = 0; i < len; i++) {\n                const unichar codepoint = [chars characterAtIndex:i];\n                if ((codepoint & 0xFF00) == 0xF700) {\n                    continue;\n                }\n                _sapp.event.char_code = codepoint;\n                _sapp.event.key_repeat = event.isARepeat;\n                _sapp_call_event(&_sapp.event);\n            }\n        }\n        /* if this is a Cmd+V (paste), also send a CLIPBOARD_PASTE event */\n        if (_sapp.clipboard.enabled && (mods == SAPP_MODIFIER_SUPER) && (key_code == SAPP_KEYCODE_V)) {\n            _sapp_init_event(SAPP_EVENTTYPE_CLIPBOARD_PASTED);\n            _sapp_call_event(&_sapp.event);\n        }\n    }\n}\n- (void)keyUp:(NSEvent*)event {\n    _sapp_gl_make_current();\n    _sapp_macos_key_event(SAPP_EVENTTYPE_KEY_UP,\n        _sapp_translate_key(event.keyCode),\n        event.isARepeat,\n        _sapp_macos_mods(event));\n}\n- (void)flagsChanged:(NSEvent*)event {\n    const uint32_t old_f = _sapp.macos.flags_changed_store;\n    const uint32_t new_f = (uint32_t)event.modifierFlags;\n    _sapp.macos.flags_changed_store = new_f;\n    sapp_keycode key_code = SAPP_KEYCODE_INVALID;\n    bool down = false;\n    if ((new_f ^ old_f) & NSEventModifierFlagShift) {\n        key_code = SAPP_KEYCODE_LEFT_SHIFT;\n        down = 0 != (new_f & NSEventModifierFlagShift);\n    }\n    if ((new_f ^ old_f) & NSEventModifierFlagControl) {\n        key_code = SAPP_KEYCODE_LEFT_CONTROL;\n        down = 0 != (new_f & NSEventModifierFlagControl);\n    }\n    if ((new_f ^ old_f) & NSEventModifierFlagOption) {\n        key_code = SAPP_KEYCODE_LEFT_ALT;\n        down = 0 != (new_f & NSEventModifierFlagOption);\n    }\n    if ((new_f ^ old_f) & NSEventModifierFlagCommand) {\n        key_code = SAPP_KEYCODE_LEFT_SUPER;\n        down = 0 != (new_f & NSEventModifierFlagCommand);\n    }\n    if (key_code != SAPP_KEYCODE_INVALID) {\n        _sapp_macos_key_event(down ? SAPP_EVENTTYPE_KEY_DOWN : SAPP_EVENTTYPE_KEY_UP,\n            key_code,\n            false,\n            _sapp_macos_mods(event));\n    }\n}\n@end\n\n#endif // macOS\n\n//     \n//       \n//       \n//            \n//     \n//\n// >>ios\n#if defined(_SAPP_IOS)\n\n_SOKOL_PRIVATE void _sapp_ios_discard_state(void) {\n    // NOTE: it's safe to call [release] on a nil object\n    _SAPP_OBJC_RELEASE(_sapp.ios.textfield_dlg);\n    _SAPP_OBJC_RELEASE(_sapp.ios.textfield);\n    #if defined(SOKOL_METAL)\n        _SAPP_OBJC_RELEASE(_sapp.ios.view_ctrl);\n        _SAPP_OBJC_RELEASE(_sapp.ios.mtl_device);\n    #else\n        _SAPP_OBJC_RELEASE(_sapp.ios.view_ctrl);\n        _SAPP_OBJC_RELEASE(_sapp.ios.eagl_ctx);\n    #endif\n    _SAPP_OBJC_RELEASE(_sapp.ios.view);\n    _SAPP_OBJC_RELEASE(_sapp.ios.window);\n}\n\n_SOKOL_PRIVATE void _sapp_ios_run(const sapp_desc* desc) {\n    _sapp_init_state(desc);\n    static int argc = 1;\n    static char* argv[] = { (char*)\"sokol_app\" };\n    UIApplicationMain(argc, argv, nil, NSStringFromClass([_sapp_app_delegate class]));\n}\n\n/* iOS entry function */\n#if !defined(SOKOL_NO_ENTRY)\nint main(int argc, char* argv[]) {\n    sapp_desc desc = sokol_main(argc, argv);\n    _sapp_ios_run(&desc);\n    return 0;\n}\n#endif /* SOKOL_NO_ENTRY */\n\n_SOKOL_PRIVATE void _sapp_ios_app_event(sapp_event_type type) {\n    if (_sapp_events_enabled()) {\n        _sapp_init_event(type);\n        _sapp_call_event(&_sapp.event);\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_ios_touch_event(sapp_event_type type, NSSet<UITouch *>* touches, UIEvent* event) {\n    if (_sapp_events_enabled()) {\n        _sapp_init_event(type);\n        NSEnumerator* enumerator = event.allTouches.objectEnumerator;\n        UITouch* ios_touch;\n        while ((ios_touch = [enumerator nextObject])) {\n            if ((_sapp.event.num_touches + 1) < SAPP_MAX_TOUCHPOINTS) {\n                CGPoint ios_pos = [ios_touch locationInView:_sapp.ios.view];\n                sapp_touchpoint* cur_point = &_sapp.event.touches[_sapp.event.num_touches++];\n                cur_point->identifier = (uintptr_t) ios_touch;\n                cur_point->pos_x = ios_pos.x * _sapp.dpi_scale;\n                cur_point->pos_y = ios_pos.y * _sapp.dpi_scale;\n                cur_point->changed = [touches containsObject:ios_touch];\n            }\n        }\n        if (_sapp.event.num_touches > 0) {\n            _sapp_call_event(&_sapp.event);\n        }\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_ios_update_dimensions(void) {\n    CGRect screen_rect = UIScreen.mainScreen.bounds;\n    _sapp.framebuffer_width = (int)roundf(screen_rect.size.width * _sapp.dpi_scale);\n    _sapp.framebuffer_height = (int)roundf(screen_rect.size.height * _sapp.dpi_scale);\n    _sapp.window_width = (int)roundf(screen_rect.size.width);\n    _sapp.window_height = (int)roundf(screen_rect.size.height);\n    int cur_fb_width, cur_fb_height;\n    #if defined(SOKOL_METAL)\n        const CGSize fb_size = _sapp.ios.view.drawableSize;\n        cur_fb_width = (int)roundf(fb_size.width);\n        cur_fb_height = (int)roundf(fb_size.height);\n    #else\n        cur_fb_width = (int)roundf(_sapp.ios.view.drawableWidth);\n        cur_fb_height = (int)roundf(_sapp.ios.view.drawableHeight);\n    #endif\n    const bool dim_changed = (_sapp.framebuffer_width != cur_fb_width) ||\n                             (_sapp.framebuffer_height != cur_fb_height);\n    if (dim_changed) {\n        #if defined(SOKOL_METAL)\n            const CGSize drawable_size = { (CGFloat) _sapp.framebuffer_width, (CGFloat) _sapp.framebuffer_height };\n            _sapp.ios.view.drawableSize = drawable_size;\n        #else\n            // nothing to do here, GLKView correctly respects the view's contentScaleFactor\n        #endif\n        if (!_sapp.first_frame) {\n            _sapp_ios_app_event(SAPP_EVENTTYPE_RESIZED);\n        }\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_ios_frame(void) {\n    _sapp_ios_update_dimensions();\n    _sapp_frame();\n}\n\n_SOKOL_PRIVATE void _sapp_ios_show_keyboard(bool shown) {\n    /* if not happened yet, create an invisible text field */\n    if (nil == _sapp.ios.textfield) {\n        _sapp.ios.textfield_dlg = [[_sapp_textfield_dlg alloc] init];\n        _sapp.ios.textfield = [[UITextField alloc] initWithFrame:CGRectMake(10, 10, 100, 50)];\n        _sapp.ios.textfield.keyboardType = UIKeyboardTypeDefault;\n        _sapp.ios.textfield.returnKeyType = UIReturnKeyDefault;\n        _sapp.ios.textfield.autocapitalizationType = UITextAutocapitalizationTypeNone;\n        _sapp.ios.textfield.autocorrectionType = UITextAutocorrectionTypeNo;\n        _sapp.ios.textfield.spellCheckingType = UITextSpellCheckingTypeNo;\n        _sapp.ios.textfield.hidden = YES;\n        _sapp.ios.textfield.text = @\"x\";\n        _sapp.ios.textfield.delegate = _sapp.ios.textfield_dlg;\n        [_sapp.ios.view_ctrl.view addSubview:_sapp.ios.textfield];\n\n        [[NSNotificationCenter defaultCenter] addObserver:_sapp.ios.textfield_dlg\n            selector:@selector(keyboardWasShown:)\n            name:UIKeyboardDidShowNotification object:nil];\n        [[NSNotificationCenter defaultCenter] addObserver:_sapp.ios.textfield_dlg\n            selector:@selector(keyboardWillBeHidden:)\n            name:UIKeyboardWillHideNotification object:nil];\n        [[NSNotificationCenter defaultCenter] addObserver:_sapp.ios.textfield_dlg\n            selector:@selector(keyboardDidChangeFrame:)\n            name:UIKeyboardDidChangeFrameNotification object:nil];\n    }\n    if (shown) {\n        /* setting the text field as first responder brings up the onscreen keyboard */\n        [_sapp.ios.textfield becomeFirstResponder];\n    }\n    else {\n        [_sapp.ios.textfield resignFirstResponder];\n    }\n}\n\n@implementation _sapp_app_delegate\n- (BOOL)application:(UIApplication*)application didFinishLaunchingWithOptions:(NSDictionary*)launchOptions {\n    CGRect screen_rect = UIScreen.mainScreen.bounds;\n    _sapp.ios.window = [[UIWindow alloc] initWithFrame:screen_rect];\n    _sapp.window_width = (int)roundf(screen_rect.size.width);\n    _sapp.window_height = (int)roundf(screen_rect.size.height);\n    if (_sapp.desc.high_dpi) {\n        _sapp.dpi_scale = (float) UIScreen.mainScreen.nativeScale;\n    }\n    else {\n        _sapp.dpi_scale = 1.0f;\n    }\n    _sapp.framebuffer_width = (int)roundf(_sapp.window_width * _sapp.dpi_scale);\n    _sapp.framebuffer_height = (int)roundf(_sapp.window_height * _sapp.dpi_scale);\n    NSInteger max_fps = UIScreen.mainScreen.maximumFramesPerSecond;\n    #if defined(SOKOL_METAL)\n        _sapp.ios.mtl_device = MTLCreateSystemDefaultDevice();\n        _sapp.ios.view = [[_sapp_ios_view alloc] init];\n        _sapp.ios.view.preferredFramesPerSecond = max_fps / _sapp.swap_interval;\n        _sapp.ios.view.device = _sapp.ios.mtl_device;\n        _sapp.ios.view.colorPixelFormat = MTLPixelFormatBGRA8Unorm;\n        _sapp.ios.view.depthStencilPixelFormat = MTLPixelFormatDepth32Float_Stencil8;\n        _sapp.ios.view.sampleCount = (NSUInteger)_sapp.sample_count;\n        /* NOTE: iOS MTKView seems to ignore thew view's contentScaleFactor\n            and automatically renders at Retina resolution. We'll disable\n            autoResize and instead do the resizing in _sapp_ios_update_dimensions()\n        */\n        _sapp.ios.view.autoResizeDrawable = false;\n        _sapp.ios.view.userInteractionEnabled = YES;\n        _sapp.ios.view.multipleTouchEnabled = YES;\n        _sapp.ios.view_ctrl = [[UIViewController alloc] init];\n        _sapp.ios.view_ctrl.modalPresentationStyle = UIModalPresentationFullScreen;\n        _sapp.ios.view_ctrl.view = _sapp.ios.view;\n        _sapp.ios.window.rootViewController = _sapp.ios.view_ctrl;\n    #else\n        _sapp.ios.eagl_ctx = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES3];\n        _sapp.ios.view = [[_sapp_ios_view alloc] initWithFrame:screen_rect];\n        _sapp.ios.view.drawableColorFormat = GLKViewDrawableColorFormatRGBA8888;\n        _sapp.ios.view.drawableDepthFormat = GLKViewDrawableDepthFormat24;\n        _sapp.ios.view.drawableStencilFormat = GLKViewDrawableStencilFormatNone;\n        GLKViewDrawableMultisample msaa = _sapp.sample_count > 1 ? GLKViewDrawableMultisample4X : GLKViewDrawableMultisampleNone;\n        _sapp.ios.view.drawableMultisample = msaa;\n        _sapp.ios.view.context = _sapp.ios.eagl_ctx;\n        _sapp.ios.view.enableSetNeedsDisplay = NO;\n        _sapp.ios.view.userInteractionEnabled = YES;\n        _sapp.ios.view.multipleTouchEnabled = YES;\n        // on GLKView, contentScaleFactor appears to work just fine!\n        if (_sapp.desc.high_dpi) {\n            _sapp.ios.view.contentScaleFactor = _sapp.dpi_scale;\n        }\n        else {\n            _sapp.ios.view.contentScaleFactor = 1.0;\n        }\n        _sapp.ios.view_ctrl = [[GLKViewController alloc] init];\n        _sapp.ios.view_ctrl.view = _sapp.ios.view;\n        _sapp.ios.view_ctrl.preferredFramesPerSecond = max_fps / _sapp.swap_interval;\n        _sapp.ios.window.rootViewController = _sapp.ios.view_ctrl;\n    #endif\n    [_sapp.ios.window makeKeyAndVisible];\n\n    _sapp.valid = true;\n    return YES;\n}\n\n- (void)applicationWillResignActive:(UIApplication *)application {\n    if (!_sapp.ios.suspended) {\n        _sapp.ios.suspended = true;\n        _sapp_ios_app_event(SAPP_EVENTTYPE_SUSPENDED);\n    }\n}\n\n- (void)applicationDidBecomeActive:(UIApplication *)application {\n    if (_sapp.ios.suspended) {\n        _sapp.ios.suspended = false;\n        _sapp_ios_app_event(SAPP_EVENTTYPE_RESUMED);\n    }\n}\n\n/* NOTE: this method will rarely ever be called, iOS application\n    which are terminated by the user are usually killed via signal 9\n    by the operating system.\n*/\n- (void)applicationWillTerminate:(UIApplication *)application {\n    _SOKOL_UNUSED(application);\n    _sapp_call_cleanup();\n    _sapp_ios_discard_state();\n    _sapp_discard_state();\n}\n@end\n\n@implementation _sapp_textfield_dlg\n- (void)keyboardWasShown:(NSNotification*)notif {\n    _sapp.onscreen_keyboard_shown = true;\n    /* query the keyboard's size, and modify the content view's size */\n    if (_sapp.desc.ios_keyboard_resizes_canvas) {\n        NSDictionary* info = notif.userInfo;\n        CGFloat kbd_h = [[info objectForKey:UIKeyboardFrameEndUserInfoKey] CGRectValue].size.height;\n        CGRect view_frame = UIScreen.mainScreen.bounds;\n        view_frame.size.height -= kbd_h;\n        _sapp.ios.view.frame = view_frame;\n    }\n}\n- (void)keyboardWillBeHidden:(NSNotification*)notif {\n    _sapp.onscreen_keyboard_shown = false;\n    if (_sapp.desc.ios_keyboard_resizes_canvas) {\n        _sapp.ios.view.frame = UIScreen.mainScreen.bounds;\n    }\n}\n- (void)keyboardDidChangeFrame:(NSNotification*)notif {\n    /* this is for the case when the screen rotation changes while the keyboard is open */\n    if (_sapp.onscreen_keyboard_shown && _sapp.desc.ios_keyboard_resizes_canvas) {\n        NSDictionary* info = notif.userInfo;\n        CGFloat kbd_h = [[info objectForKey:UIKeyboardFrameEndUserInfoKey] CGRectValue].size.height;\n        CGRect view_frame = UIScreen.mainScreen.bounds;\n        view_frame.size.height -= kbd_h;\n        _sapp.ios.view.frame = view_frame;\n    }\n}\n- (BOOL)textField:(UITextField*)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString*)string {\n    if (_sapp_events_enabled()) {\n        const NSUInteger len = string.length;\n        if (len > 0) {\n            for (NSUInteger i = 0; i < len; i++) {\n                unichar c = [string characterAtIndex:i];\n                if (c >= 32) {\n                    /* ignore surrogates for now */\n                    if ((c < 0xD800) || (c > 0xDFFF)) {\n                        _sapp_init_event(SAPP_EVENTTYPE_CHAR);\n                        _sapp.event.char_code = c;\n                        _sapp_call_event(&_sapp.event);\n                    }\n                }\n                if (c <= 32) {\n                    sapp_keycode k = SAPP_KEYCODE_INVALID;\n                    switch (c) {\n                        case 10: k = SAPP_KEYCODE_ENTER; break;\n                        case 32: k = SAPP_KEYCODE_SPACE; break;\n                        default: break;\n                    }\n                    if (k != SAPP_KEYCODE_INVALID) {\n                        _sapp_init_event(SAPP_EVENTTYPE_KEY_DOWN);\n                        _sapp.event.key_code = k;\n                        _sapp_call_event(&_sapp.event);\n                        _sapp_init_event(SAPP_EVENTTYPE_KEY_UP);\n                        _sapp.event.key_code = k;\n                        _sapp_call_event(&_sapp.event);\n                    }\n                }\n            }\n        }\n        else {\n            /* this was a backspace */\n            _sapp_init_event(SAPP_EVENTTYPE_KEY_DOWN);\n            _sapp.event.key_code = SAPP_KEYCODE_BACKSPACE;\n            _sapp_call_event(&_sapp.event);\n            _sapp_init_event(SAPP_EVENTTYPE_KEY_UP);\n            _sapp.event.key_code = SAPP_KEYCODE_BACKSPACE;\n            _sapp_call_event(&_sapp.event);\n        }\n    }\n    return NO;\n}\n@end\n\n@implementation _sapp_ios_view\n- (void)drawRect:(CGRect)rect {\n    _SOKOL_UNUSED(rect);\n    #if defined(_SAPP_ANY_GL)\n    glGetIntegerv(GL_FRAMEBUFFER_BINDING, (GLint*)&_sapp.gl.framebuffer);\n    #endif\n    _sapp_timing_measure(&_sapp.timing);\n    @autoreleasepool {\n        _sapp_ios_frame();\n    }\n}\n- (BOOL)isOpaque {\n    return YES;\n}\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent*)event {\n    _sapp_ios_touch_event(SAPP_EVENTTYPE_TOUCHES_BEGAN, touches, event);\n}\n- (void)touchesMoved:(NSSet<UITouch *> *)touches withEvent:(UIEvent*)event {\n    _sapp_ios_touch_event(SAPP_EVENTTYPE_TOUCHES_MOVED, touches, event);\n}\n- (void)touchesEnded:(NSSet<UITouch *> *)touches withEvent:(UIEvent*)event {\n    _sapp_ios_touch_event(SAPP_EVENTTYPE_TOUCHES_ENDED, touches, event);\n}\n- (void)touchesCancelled:(NSSet<UITouch *> *)touches withEvent:(UIEvent*)event {\n    _sapp_ios_touch_event(SAPP_EVENTTYPE_TOUCHES_CANCELLED, touches, event);\n}\n@end\n#endif /* TARGET_OS_IPHONE */\n\n#endif /* _SAPP_APPLE */\n\n//                     \n//                                               \n//                                \n//                                                   \n//                                  \n//\n// >>emscripten\n#if defined(_SAPP_EMSCRIPTEN)\n\n#if defined(EM_JS_DEPS)\nEM_JS_DEPS(sokol_app, \"$withStackSave,$stringToUTF8OnStack,$findCanvasEventTarget\");\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef void (*_sapp_html5_fetch_callback) (const sapp_html5_fetch_response*);\n\nEMSCRIPTEN_KEEPALIVE void _sapp_emsc_onpaste(const char* str) {\n    if (_sapp.clipboard.enabled) {\n        _sapp_strcpy(str, _sapp.clipboard.buffer, _sapp.clipboard.buf_size);\n        if (_sapp_events_enabled()) {\n            _sapp_init_event(SAPP_EVENTTYPE_CLIPBOARD_PASTED);\n            _sapp_call_event(&_sapp.event);\n        }\n    }\n}\n\n/*  https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onbeforeunload */\nEMSCRIPTEN_KEEPALIVE int _sapp_html5_get_ask_leave_site(void) {\n    return _sapp.html5_ask_leave_site ? 1 : 0;\n}\n\nEMSCRIPTEN_KEEPALIVE void _sapp_emsc_begin_drop(int num) {\n    if (!_sapp.drop.enabled) {\n        return;\n    }\n    if (num < 0) {\n        num = 0;\n    }\n    if (num > _sapp.drop.max_files) {\n        num = _sapp.drop.max_files;\n    }\n    _sapp.drop.num_files = num;\n    _sapp_clear_drop_buffer();\n}\n\nEMSCRIPTEN_KEEPALIVE void _sapp_emsc_drop(int i, const char* name) {\n    /* NOTE: name is only the filename part, not a path */\n    if (!_sapp.drop.enabled) {\n        return;\n    }\n    if (0 == name) {\n        return;\n    }\n    SOKOL_ASSERT(_sapp.drop.num_files <= _sapp.drop.max_files);\n    if ((i < 0) || (i >= _sapp.drop.num_files)) {\n        return;\n    }\n    if (!_sapp_strcpy(name, _sapp_dropped_file_path_ptr(i), _sapp.drop.max_path_length)) {\n        _SAPP_ERROR(DROPPED_FILE_PATH_TOO_LONG);\n        _sapp.drop.num_files = 0;\n    }\n}\n\nEMSCRIPTEN_KEEPALIVE void _sapp_emsc_end_drop(int x, int y, int mods) {\n    if (!_sapp.drop.enabled) {\n        return;\n    }\n    if (0 == _sapp.drop.num_files) {\n        /* there was an error copying the filenames */\n        _sapp_clear_drop_buffer();\n        return;\n\n    }\n    if (_sapp_events_enabled()) {\n        _sapp.mouse.x = (float)x * _sapp.dpi_scale;\n        _sapp.mouse.y = (float)y * _sapp.dpi_scale;\n        _sapp.mouse.dx = 0.0f;\n        _sapp.mouse.dy = 0.0f;\n        _sapp_init_event(SAPP_EVENTTYPE_FILES_DROPPED);\n        // see sapp_js_add_dragndrop_listeners for mods constants\n        if (mods & 1) { _sapp.event.modifiers |= SAPP_MODIFIER_SHIFT; }\n        if (mods & 2) { _sapp.event.modifiers |= SAPP_MODIFIER_CTRL; }\n        if (mods & 4) { _sapp.event.modifiers |= SAPP_MODIFIER_ALT; }\n        if (mods & 8) { _sapp.event.modifiers |= SAPP_MODIFIER_SUPER; }\n        _sapp_call_event(&_sapp.event);\n    }\n}\n\nEMSCRIPTEN_KEEPALIVE void _sapp_emsc_invoke_fetch_cb(int index, int success, int error_code, _sapp_html5_fetch_callback callback, uint32_t fetched_size, void* buf_ptr, uint32_t buf_size, void* user_data) {\n    sapp_html5_fetch_response response;\n    _sapp_clear(&response, sizeof(response));\n    response.succeeded = (0 != success);\n    response.error_code = (sapp_html5_fetch_error) error_code;\n    response.file_index = index;\n    response.data.ptr = buf_ptr;\n    response.data.size = fetched_size;\n    response.buffer.ptr = buf_ptr;\n    response.buffer.size = buf_size;\n    response.user_data = user_data;\n    callback(&response);\n}\n\n#ifdef __cplusplus\n} /* extern \"C\" */\n#endif\n\nEM_JS(void, sapp_js_add_beforeunload_listener, (void), {\n    Module.sokol_beforeunload = (event) => {\n        if (__sapp_html5_get_ask_leave_site() != 0) {\n            event.preventDefault();\n            event.returnValue = ' ';\n        }\n    };\n    window.addEventListener('beforeunload', Module.sokol_beforeunload);\n});\n\nEM_JS(void, sapp_js_remove_beforeunload_listener, (void), {\n    window.removeEventListener('beforeunload', Module.sokol_beforeunload);\n});\n\nEM_JS(void, sapp_js_add_clipboard_listener, (void), {\n    Module.sokol_paste = (event) => {\n        const pasted_str = event.clipboardData.getData('text');\n        withStackSave(() => {\n            const cstr = stringToUTF8OnStack(pasted_str);\n            __sapp_emsc_onpaste(cstr);\n        });\n    };\n    window.addEventListener('paste', Module.sokol_paste);\n});\n\nEM_JS(void, sapp_js_remove_clipboard_listener, (void), {\n    window.removeEventListener('paste', Module.sokol_paste);\n});\n\nEM_JS(void, sapp_js_write_clipboard, (const char* c_str), {\n    const str = UTF8ToString(c_str);\n    const ta = document.createElement('textarea');\n    ta.setAttribute('autocomplete', 'off');\n    ta.setAttribute('autocorrect', 'off');\n    ta.setAttribute('autocapitalize', 'off');\n    ta.setAttribute('spellcheck', 'false');\n    ta.style.left = -100 + 'px';\n    ta.style.top = -100 + 'px';\n    ta.style.height = 1;\n    ta.style.width = 1;\n    ta.value = str;\n    document.body.appendChild(ta);\n    ta.select();\n    document.execCommand('copy');\n    document.body.removeChild(ta);\n});\n\n_SOKOL_PRIVATE void _sapp_emsc_set_clipboard_string(const char* str) {\n    sapp_js_write_clipboard(str);\n}\n\nEM_JS(void, sapp_js_add_dragndrop_listeners, (void), {\n    Module.sokol_drop_files = [];\n    Module.sokol_dragenter = (event) => {\n        event.stopPropagation();\n        event.preventDefault();\n    };\n    Module.sokol_dragleave = (event) => {\n        event.stopPropagation();\n        event.preventDefault();\n    };\n    Module.sokol_dragover = (event) => {\n        event.stopPropagation();\n        event.preventDefault();\n    };\n    Module.sokol_drop = (event) => {\n        event.stopPropagation();\n        event.preventDefault();\n        const files = event.dataTransfer.files;\n        Module.sokol_dropped_files = files;\n        __sapp_emsc_begin_drop(files.length);\n        for (let i = 0; i < files.length; i++) {\n            withStackSave(() => {\n                const cstr = stringToUTF8OnStack(files[i].name);\n                __sapp_emsc_drop(i, cstr);\n            });\n        }\n        let mods = 0;\n        if (event.shiftKey) { mods |= 1; }\n        if (event.ctrlKey) { mods |= 2; }\n        if (event.altKey) { mods |= 4; }\n        if (event.metaKey) { mods |= 8; }\n        // FIXME? see computation of targetX/targetY in emscripten via getClientBoundingRect\n        __sapp_emsc_end_drop(event.clientX, event.clientY, mods);\n    };\n    \\x2F\\x2A\\x2A @suppress {missingProperties} \\x2A\\x2F\n    const canvas = Module.sapp_emsc_target;\n    canvas.addEventListener('dragenter', Module.sokol_dragenter, false);\n    canvas.addEventListener('dragleave', Module.sokol_dragleave, false);\n    canvas.addEventListener('dragover',  Module.sokol_dragover, false);\n    canvas.addEventListener('drop',      Module.sokol_drop, false);\n});\n\nEM_JS(uint32_t, sapp_js_dropped_file_size, (int index), {\n    \\x2F\\x2A\\x2A @suppress {missingProperties} \\x2A\\x2F\n    const files = Module.sokol_dropped_files;\n    if ((index < 0) || (index >= files.length)) {\n        return 0;\n    }\n    else {\n        return files[index].size;\n    }\n});\n\nEM_JS(void, sapp_js_fetch_dropped_file, (int index, _sapp_html5_fetch_callback callback, void* buf_ptr, uint32_t buf_size, void* user_data), {\n    const reader = new FileReader();\n    reader.onload = (loadEvent) => {\n        const content = loadEvent.target.result;\n        if (content.byteLength > buf_size) {\n            // SAPP_HTML5_FETCH_ERROR_BUFFER_TOO_SMALL\n            __sapp_emsc_invoke_fetch_cb(index, 0, 1, callback, 0, buf_ptr, buf_size, user_data);\n        }\n        else {\n            HEAPU8.set(new Uint8Array(content), buf_ptr);\n            __sapp_emsc_invoke_fetch_cb(index, 1, 0, callback, content.byteLength, buf_ptr, buf_size, user_data);\n        }\n    };\n    reader.onerror = () => {\n        // SAPP_HTML5_FETCH_ERROR_OTHER\n        __sapp_emsc_invoke_fetch_cb(index, 0, 2, callback, 0, buf_ptr, buf_size, user_data);\n    };\n    \\x2F\\x2A\\x2A @suppress {missingProperties} \\x2A\\x2F\n    const files = Module.sokol_dropped_files;\n    reader.readAsArrayBuffer(files[index]);\n});\n\nEM_JS(void, sapp_js_remove_dragndrop_listeners, (void), {\n    \\x2F\\x2A\\x2A @suppress {missingProperties} \\x2A\\x2F\n    const canvas = Module.sapp_emsc_target;\n    canvas.removeEventListener('dragenter', Module.sokol_dragenter);\n    canvas.removeEventListener('dragleave', Module.sokol_dragleave);\n    canvas.removeEventListener('dragover',  Module.sokol_dragover);\n    canvas.removeEventListener('drop',      Module.sokol_drop);\n});\n\nEM_JS(void, sapp_js_init, (const char* c_str_target_selector, const char* c_str_document_title), {\n    if (c_str_document_title !== 0) {\n        document.title = UTF8ToString(c_str_document_title);\n    }\n    const target_selector_str = UTF8ToString(c_str_target_selector);\n    if (Module['canvas'] !== undefined) {\n        if (typeof Module['canvas'] === 'object') {\n            specialHTMLTargets[target_selector_str] = Module['canvas'];\n        } else {\n            console.warn(\"sokol_app.h: Module['canvas'] is set but is not an object\");\n        }\n    }\n    Module.sapp_emsc_target = findCanvasEventTarget(target_selector_str);\n    if (!Module.sapp_emsc_target) {\n        console.warn(\"sokol_app.h: can't find html5_canvas_selector \", target_selector_str);\n    }\n    if (!Module.sapp_emsc_target.requestPointerLock) {\n        console.warn(\"sokol_app.h: target doesn't support requestPointerLock: \", target_selector_str);\n    }\n});\n\n_SOKOL_PRIVATE EM_BOOL _sapp_emsc_pointerlockchange_cb(int emsc_type, const EmscriptenPointerlockChangeEvent* emsc_event, void* user_data) {\n    _SOKOL_UNUSED(emsc_type);\n    _SOKOL_UNUSED(user_data);\n    _sapp.mouse.locked = emsc_event->isActive;\n    return EM_TRUE;\n}\n\n_SOKOL_PRIVATE EM_BOOL _sapp_emsc_pointerlockerror_cb(int emsc_type, const void* reserved, void* user_data) {\n    _SOKOL_UNUSED(emsc_type);\n    _SOKOL_UNUSED(reserved);\n    _SOKOL_UNUSED(user_data);\n    _sapp.mouse.locked = false;\n    _sapp.emsc.mouse_lock_requested = false;\n    return true;\n}\n\nEM_JS(void, sapp_js_request_pointerlock, (void), {\n    if (Module.sapp_emsc_target) {\n        if (Module.sapp_emsc_target.requestPointerLock) {\n            Module.sapp_emsc_target.requestPointerLock();\n        }\n    }\n});\n\nEM_JS(void, sapp_js_exit_pointerlock, (void), {\n    if (document.exitPointerLock) {\n        document.exitPointerLock();\n    }\n});\n\n_SOKOL_PRIVATE void _sapp_emsc_lock_mouse(bool lock) {\n    if (lock) {\n        /* request mouse-lock during event handler invocation (see _sapp_emsc_update_mouse_lock_state) */\n        _sapp.emsc.mouse_lock_requested = true;\n    }\n    else {\n        /* NOTE: the _sapp.mouse_locked state will be set in the pointerlockchange callback */\n        _sapp.emsc.mouse_lock_requested = false;\n        sapp_js_exit_pointerlock();\n    }\n}\n\n/* called from inside event handlers to check if mouse lock had been requested,\n   and if yes, actually enter mouse lock.\n*/\n_SOKOL_PRIVATE void _sapp_emsc_update_mouse_lock_state(void) {\n    if (_sapp.emsc.mouse_lock_requested) {\n        _sapp.emsc.mouse_lock_requested = false;\n        sapp_js_request_pointerlock();\n    }\n}\n\n// set mouse cursor type\nEM_JS(void, sapp_js_set_cursor, (int cursor_type, int shown), {\n    if (Module.sapp_emsc_target) {\n        let cursor;\n        if (shown === 0) {\n            cursor = \"none\";\n        }\n        else switch (cursor_type) {\n            case 0: cursor = \"auto\"; break;         // SAPP_MOUSECURSOR_DEFAULT\n            case 1: cursor = \"default\"; break;      // SAPP_MOUSECURSOR_ARROW\n            case 2: cursor = \"text\"; break;         // SAPP_MOUSECURSOR_IBEAM\n            case 3: cursor = \"crosshair\"; break;    // SAPP_MOUSECURSOR_CROSSHAIR\n            case 4: cursor = \"pointer\"; break;      // SAPP_MOUSECURSOR_POINTING_HAND\n            case 5: cursor = \"ew-resize\"; break;    // SAPP_MOUSECURSOR_RESIZE_EW\n            case 6: cursor = \"ns-resize\"; break;    // SAPP_MOUSECURSOR_RESIZE_NS\n            case 7: cursor = \"nwse-resize\"; break;  // SAPP_MOUSECURSOR_RESIZE_NWSE\n            case 8: cursor = \"nesw-resize\"; break;  // SAPP_MOUSECURSOR_RESIZE_NESW\n            case 9: cursor = \"all-scroll\"; break;   // SAPP_MOUSECURSOR_RESIZE_ALL\n            case 10: cursor = \"not-allowed\"; break; // SAPP_MOUSECURSOR_NOT_ALLOWED\n            default: cursor = \"auto\"; break;\n        }\n        Module.sapp_emsc_target.style.cursor = cursor;\n    }\n});\n\n_SOKOL_PRIVATE void _sapp_emsc_update_cursor(sapp_mouse_cursor cursor, bool shown) {\n    SOKOL_ASSERT((cursor >= 0) && (cursor < _SAPP_MOUSECURSOR_NUM));\n    sapp_js_set_cursor((int)cursor, shown ? 1 : 0);\n}\n\n/* JS helper functions to update browser tab favicon */\nEM_JS(void, sapp_js_clear_favicon, (void), {\n    const link = document.getElementById('sokol-app-favicon');\n    if (link) {\n        document.head.removeChild(link);\n    }\n});\n\nEM_JS(void, sapp_js_set_favicon, (int w, int h, const uint8_t* pixels), {\n    const canvas = document.createElement('canvas');\n    canvas.width = w;\n    canvas.height = h;\n    const ctx = canvas.getContext('2d');\n    const img_data = ctx.createImageData(w, h);\n    img_data.data.set(HEAPU8.subarray(pixels, pixels + w*h*4));\n    ctx.putImageData(img_data, 0, 0);\n    const new_link = document.createElement('link');\n    new_link.id = 'sokol-app-favicon';\n    new_link.rel = 'shortcut icon';\n    new_link.href = canvas.toDataURL();\n    document.head.appendChild(new_link);\n});\n\n_SOKOL_PRIVATE void _sapp_emsc_set_icon(const sapp_icon_desc* icon_desc, int num_images) {\n    SOKOL_ASSERT((num_images > 0) && (num_images <= SAPP_MAX_ICONIMAGES));\n    sapp_js_clear_favicon();\n    // find the best matching image candidate for 16x16 pixels\n    int img_index = _sapp_image_bestmatch(icon_desc->images, num_images, 16, 16);\n    const sapp_image_desc* img_desc = &icon_desc->images[img_index];\n    sapp_js_set_favicon(img_desc->width, img_desc->height, (const uint8_t*) img_desc->pixels.ptr);\n}\n\n_SOKOL_PRIVATE uint32_t _sapp_emsc_mouse_button_mods(uint16_t buttons) {\n    uint32_t m = 0;\n    if (0 != (buttons & (1<<0))) { m |= SAPP_MODIFIER_LMB; }\n    if (0 != (buttons & (1<<1))) { m |= SAPP_MODIFIER_RMB; } // not a bug\n    if (0 != (buttons & (1<<2))) { m |= SAPP_MODIFIER_MMB; } // not a bug\n    return m;\n}\n\n_SOKOL_PRIVATE uint32_t _sapp_emsc_mouse_event_mods(const EmscriptenMouseEvent* ev) {\n    uint32_t m = 0;\n    if (ev->ctrlKey)    { m |= SAPP_MODIFIER_CTRL; }\n    if (ev->shiftKey)   { m |= SAPP_MODIFIER_SHIFT; }\n    if (ev->altKey)     { m |= SAPP_MODIFIER_ALT; }\n    if (ev->metaKey)    { m |= SAPP_MODIFIER_SUPER; }\n    m |= _sapp_emsc_mouse_button_mods(_sapp.emsc.mouse_buttons);\n    return m;\n}\n\n_SOKOL_PRIVATE uint32_t _sapp_emsc_key_event_mods(const EmscriptenKeyboardEvent* ev) {\n    uint32_t m = 0;\n    if (ev->ctrlKey)    { m |= SAPP_MODIFIER_CTRL; }\n    if (ev->shiftKey)   { m |= SAPP_MODIFIER_SHIFT; }\n    if (ev->altKey)     { m |= SAPP_MODIFIER_ALT; }\n    if (ev->metaKey)    { m |= SAPP_MODIFIER_SUPER; }\n    m |= _sapp_emsc_mouse_button_mods(_sapp.emsc.mouse_buttons);\n    return m;\n}\n\n_SOKOL_PRIVATE uint32_t _sapp_emsc_touch_event_mods(const EmscriptenTouchEvent* ev) {\n    uint32_t m = 0;\n    if (ev->ctrlKey)    { m |= SAPP_MODIFIER_CTRL; }\n    if (ev->shiftKey)   { m |= SAPP_MODIFIER_SHIFT; }\n    if (ev->altKey)     { m |= SAPP_MODIFIER_ALT; }\n    if (ev->metaKey)    { m |= SAPP_MODIFIER_SUPER; }\n    m |= _sapp_emsc_mouse_button_mods(_sapp.emsc.mouse_buttons);\n    return m;\n}\n\n#if defined(SOKOL_WGPU)\n_SOKOL_PRIVATE void _sapp_emsc_wgpu_size_changed(void);\n#endif\n\n_SOKOL_PRIVATE EM_BOOL _sapp_emsc_size_changed(int event_type, const EmscriptenUiEvent* ui_event, void* user_data) {\n    _SOKOL_UNUSED(event_type);\n    _SOKOL_UNUSED(user_data);\n    double w, h;\n    emscripten_get_element_css_size(_sapp.html5_canvas_selector, &w, &h);\n    /* The above method might report zero when toggling HTML5 fullscreen,\n       in that case use the window's inner width reported by the\n       emscripten event. This works ok when toggling *into* fullscreen\n       but doesn't properly restore the previous canvas size when switching\n       back from fullscreen.\n\n       In general, due to the HTML5's fullscreen API's flaky nature it is\n       recommended to use 'soft fullscreen' (stretching the WebGL canvas\n       over the browser windows client rect) with a CSS definition like this:\n\n            position: absolute;\n            top: 0px;\n            left: 0px;\n            margin: 0px;\n            border: 0;\n            width: 100%;\n            height: 100%;\n            overflow: hidden;\n            display: block;\n    */\n    if (w < 1.0) {\n        w = ui_event->windowInnerWidth;\n    }\n    else {\n        _sapp.window_width = (int)roundf(w);\n    }\n    if (h < 1.0) {\n        h = ui_event->windowInnerHeight;\n    }\n    else {\n        _sapp.window_height = (int)roundf(h);\n    }\n    if (_sapp.desc.high_dpi) {\n        _sapp.dpi_scale = emscripten_get_device_pixel_ratio();\n    }\n    _sapp.framebuffer_width = (int)roundf(w * _sapp.dpi_scale);\n    _sapp.framebuffer_height = (int)roundf(h * _sapp.dpi_scale);\n    SOKOL_ASSERT((_sapp.framebuffer_width > 0) && (_sapp.framebuffer_height > 0));\n    emscripten_set_canvas_element_size(_sapp.html5_canvas_selector, _sapp.framebuffer_width, _sapp.framebuffer_height);\n    #if defined(SOKOL_WGPU)\n        // on WebGPU: recreate size-dependent rendering surfaces\n        _sapp_emsc_wgpu_size_changed();\n    #endif\n    if (_sapp_events_enabled()) {\n        _sapp_init_event(SAPP_EVENTTYPE_RESIZED);\n        _sapp_call_event(&_sapp.event);\n    }\n    return true;\n}\n\n_SOKOL_PRIVATE EM_BOOL _sapp_emsc_mouse_cb(int emsc_type, const EmscriptenMouseEvent* emsc_event, void* user_data) {\n    _SOKOL_UNUSED(user_data);\n    bool consume_event = !_sapp.desc.html5_bubble_mouse_events;\n    _sapp.emsc.mouse_buttons = emsc_event->buttons;\n    if (_sapp.mouse.locked) {\n        _sapp.mouse.dx = (float) emsc_event->movementX;\n        _sapp.mouse.dy = (float) emsc_event->movementY;\n    } else {\n        float new_x = emsc_event->targetX * _sapp.dpi_scale;\n        float new_y = emsc_event->targetY * _sapp.dpi_scale;\n        if (_sapp.mouse.pos_valid) {\n            _sapp.mouse.dx = new_x - _sapp.mouse.x;\n            _sapp.mouse.dy = new_y - _sapp.mouse.y;\n        }\n        _sapp.mouse.x = new_x;\n        _sapp.mouse.y = new_y;\n        _sapp.mouse.pos_valid = true;\n    }\n    if (_sapp_events_enabled() && (emsc_event->button >= 0) && (emsc_event->button < SAPP_MAX_MOUSEBUTTONS)) {\n        sapp_event_type type;\n        bool is_button_event = false;\n        bool clear_dxdy = false;\n        switch (emsc_type) {\n            case EMSCRIPTEN_EVENT_MOUSEDOWN:\n                type = SAPP_EVENTTYPE_MOUSE_DOWN;\n                is_button_event = true;\n                break;\n            case EMSCRIPTEN_EVENT_MOUSEUP:\n                type = SAPP_EVENTTYPE_MOUSE_UP;\n                is_button_event = true;\n                break;\n            case EMSCRIPTEN_EVENT_MOUSEMOVE:\n                type = SAPP_EVENTTYPE_MOUSE_MOVE;\n                break;\n            case EMSCRIPTEN_EVENT_MOUSEENTER:\n                type = SAPP_EVENTTYPE_MOUSE_ENTER;\n                clear_dxdy = true;\n                break;\n            case EMSCRIPTEN_EVENT_MOUSELEAVE:\n                type = SAPP_EVENTTYPE_MOUSE_LEAVE;\n                clear_dxdy = true;\n                break;\n            default:\n                type = SAPP_EVENTTYPE_INVALID;\n                break;\n        }\n        if (clear_dxdy) {\n            _sapp.mouse.dx = 0.0f;\n            _sapp.mouse.dy = 0.0f;\n        }\n        if (type != SAPP_EVENTTYPE_INVALID) {\n            _sapp_init_event(type);\n            _sapp.event.modifiers = _sapp_emsc_mouse_event_mods(emsc_event);\n            if (is_button_event) {\n                switch (emsc_event->button) {\n                    case 0: _sapp.event.mouse_button = SAPP_MOUSEBUTTON_LEFT; break;\n                    case 1: _sapp.event.mouse_button = SAPP_MOUSEBUTTON_MIDDLE; break;\n                    case 2: _sapp.event.mouse_button = SAPP_MOUSEBUTTON_RIGHT; break;\n                    default: _sapp.event.mouse_button = (sapp_mousebutton)emsc_event->button; break;\n                }\n            } else {\n                _sapp.event.mouse_button = SAPP_MOUSEBUTTON_INVALID;\n            }\n            consume_event |= _sapp_call_event(&_sapp.event);\n        }\n        // mouse lock can only be activated in mouse button events (not in move, enter or leave)\n        if (is_button_event) {\n            _sapp_emsc_update_mouse_lock_state();\n        }\n    }\n    return consume_event;\n}\n\n_SOKOL_PRIVATE EM_BOOL _sapp_emsc_wheel_cb(int emsc_type, const EmscriptenWheelEvent* emsc_event, void* user_data) {\n    _SOKOL_UNUSED(emsc_type);\n    _SOKOL_UNUSED(user_data);\n    bool consume_event = !_sapp.desc.html5_bubble_wheel_events;\n    _sapp.emsc.mouse_buttons = emsc_event->mouse.buttons;\n    if (_sapp_events_enabled()) {\n        _sapp_init_event(SAPP_EVENTTYPE_MOUSE_SCROLL);\n        _sapp.event.modifiers = _sapp_emsc_mouse_event_mods(&emsc_event->mouse);\n        /* see https://github.com/floooh/sokol/issues/339 */\n        float scale;\n        switch (emsc_event->deltaMode) {\n            case DOM_DELTA_PIXEL: scale = -0.04f; break;\n            case DOM_DELTA_LINE:  scale = -1.33f; break;\n            case DOM_DELTA_PAGE:  scale = -10.0f; break; // FIXME: this is a guess\n            default:              scale = -0.1f; break;  // shouldn't happen\n        }\n        _sapp.event.scroll_x = scale * (float)emsc_event->deltaX;\n        _sapp.event.scroll_y = scale * (float)emsc_event->deltaY;\n        consume_event |= _sapp_call_event(&_sapp.event);\n    }\n    _sapp_emsc_update_mouse_lock_state();\n    return consume_event;\n}\n\nstatic struct {\n    const char* str;\n    sapp_keycode code;\n} _sapp_emsc_keymap[] = {\n    { \"Backspace\",      SAPP_KEYCODE_BACKSPACE },\n    { \"Tab\",            SAPP_KEYCODE_TAB },\n    { \"Enter\",          SAPP_KEYCODE_ENTER },\n    { \"ShiftLeft\",      SAPP_KEYCODE_LEFT_SHIFT },\n    { \"ShiftRight\",     SAPP_KEYCODE_RIGHT_SHIFT },\n    { \"ControlLeft\",    SAPP_KEYCODE_LEFT_CONTROL },\n    { \"ControlRight\",   SAPP_KEYCODE_RIGHT_CONTROL },\n    { \"AltLeft\",        SAPP_KEYCODE_LEFT_ALT },\n    { \"AltRight\",       SAPP_KEYCODE_RIGHT_ALT },\n    { \"Pause\",          SAPP_KEYCODE_PAUSE },\n    { \"CapsLock\",       SAPP_KEYCODE_CAPS_LOCK },\n    { \"Escape\",         SAPP_KEYCODE_ESCAPE },\n    { \"Space\",          SAPP_KEYCODE_SPACE },\n    { \"PageUp\",         SAPP_KEYCODE_PAGE_UP },\n    { \"PageDown\",       SAPP_KEYCODE_PAGE_DOWN },\n    { \"End\",            SAPP_KEYCODE_END },\n    { \"Home\",           SAPP_KEYCODE_HOME },\n    { \"ArrowLeft\",      SAPP_KEYCODE_LEFT },\n    { \"ArrowUp\",        SAPP_KEYCODE_UP },\n    { \"ArrowRight\",     SAPP_KEYCODE_RIGHT },\n    { \"ArrowDown\",      SAPP_KEYCODE_DOWN },\n    { \"PrintScreen\",    SAPP_KEYCODE_PRINT_SCREEN },\n    { \"Insert\",         SAPP_KEYCODE_INSERT },\n    { \"Delete\",         SAPP_KEYCODE_DELETE },\n    { \"Digit0\",         SAPP_KEYCODE_0 },\n    { \"Digit1\",         SAPP_KEYCODE_1 },\n    { \"Digit2\",         SAPP_KEYCODE_2 },\n    { \"Digit3\",         SAPP_KEYCODE_3 },\n    { \"Digit4\",         SAPP_KEYCODE_4 },\n    { \"Digit5\",         SAPP_KEYCODE_5 },\n    { \"Digit6\",         SAPP_KEYCODE_6 },\n    { \"Digit7\",         SAPP_KEYCODE_7 },\n    { \"Digit8\",         SAPP_KEYCODE_8 },\n    { \"Digit9\",         SAPP_KEYCODE_9 },\n    { \"KeyA\",           SAPP_KEYCODE_A },\n    { \"KeyB\",           SAPP_KEYCODE_B },\n    { \"KeyC\",           SAPP_KEYCODE_C },\n    { \"KeyD\",           SAPP_KEYCODE_D },\n    { \"KeyE\",           SAPP_KEYCODE_E },\n    { \"KeyF\",           SAPP_KEYCODE_F },\n    { \"KeyG\",           SAPP_KEYCODE_G },\n    { \"KeyH\",           SAPP_KEYCODE_H },\n    { \"KeyI\",           SAPP_KEYCODE_I },\n    { \"KeyJ\",           SAPP_KEYCODE_J },\n    { \"KeyK\",           SAPP_KEYCODE_K },\n    { \"KeyL\",           SAPP_KEYCODE_L },\n    { \"KeyM\",           SAPP_KEYCODE_M },\n    { \"KeyN\",           SAPP_KEYCODE_N },\n    { \"KeyO\",           SAPP_KEYCODE_O },\n    { \"KeyP\",           SAPP_KEYCODE_P },\n    { \"KeyQ\",           SAPP_KEYCODE_Q },\n    { \"KeyR\",           SAPP_KEYCODE_R },\n    { \"KeyS\",           SAPP_KEYCODE_S },\n    { \"KeyT\",           SAPP_KEYCODE_T },\n    { \"KeyU\",           SAPP_KEYCODE_U },\n    { \"KeyV\",           SAPP_KEYCODE_V },\n    { \"KeyW\",           SAPP_KEYCODE_W },\n    { \"KeyX\",           SAPP_KEYCODE_X },\n    { \"KeyY\",           SAPP_KEYCODE_Y },\n    { \"KeyZ\",           SAPP_KEYCODE_Z },\n    { \"MetaLeft\",       SAPP_KEYCODE_LEFT_SUPER },\n    { \"MetaRight\",      SAPP_KEYCODE_RIGHT_SUPER },\n    { \"Numpad0\",        SAPP_KEYCODE_KP_0 },\n    { \"Numpad1\",        SAPP_KEYCODE_KP_1 },\n    { \"Numpad2\",        SAPP_KEYCODE_KP_2 },\n    { \"Numpad3\",        SAPP_KEYCODE_KP_3 },\n    { \"Numpad4\",        SAPP_KEYCODE_KP_4 },\n    { \"Numpad5\",        SAPP_KEYCODE_KP_5 },\n    { \"Numpad6\",        SAPP_KEYCODE_KP_6 },\n    { \"Numpad7\",        SAPP_KEYCODE_KP_7 },\n    { \"Numpad8\",        SAPP_KEYCODE_KP_8 },\n    { \"Numpad9\",        SAPP_KEYCODE_KP_9 },\n    { \"NumpadMultiply\", SAPP_KEYCODE_KP_MULTIPLY },\n    { \"NumpadAdd\",      SAPP_KEYCODE_KP_ADD },\n    { \"NumpadSubtract\", SAPP_KEYCODE_KP_SUBTRACT },\n    { \"NumpadDecimal\",  SAPP_KEYCODE_KP_DECIMAL },\n    { \"NumpadDivide\",   SAPP_KEYCODE_KP_DIVIDE },\n    { \"F1\",             SAPP_KEYCODE_F1 },\n    { \"F2\",             SAPP_KEYCODE_F2 },\n    { \"F3\",             SAPP_KEYCODE_F3 },\n    { \"F4\",             SAPP_KEYCODE_F4 },\n    { \"F5\",             SAPP_KEYCODE_F5 },\n    { \"F6\",             SAPP_KEYCODE_F6 },\n    { \"F7\",             SAPP_KEYCODE_F7 },\n    { \"F8\",             SAPP_KEYCODE_F8 },\n    { \"F9\",             SAPP_KEYCODE_F9 },\n    { \"F10\",            SAPP_KEYCODE_F10 },\n    { \"F11\",            SAPP_KEYCODE_F11 },\n    { \"F12\",            SAPP_KEYCODE_F12 },\n    { \"NumLock\",        SAPP_KEYCODE_NUM_LOCK },\n    { \"ScrollLock\",     SAPP_KEYCODE_SCROLL_LOCK },\n    { \"Semicolon\",      SAPP_KEYCODE_SEMICOLON },\n    { \"Equal\",          SAPP_KEYCODE_EQUAL },\n    { \"Comma\",          SAPP_KEYCODE_COMMA },\n    { \"Minus\",          SAPP_KEYCODE_MINUS },\n    { \"Period\",         SAPP_KEYCODE_PERIOD },\n    { \"Slash\",          SAPP_KEYCODE_SLASH },\n    { \"Backquote\",      SAPP_KEYCODE_GRAVE_ACCENT },\n    { \"BracketLeft\",    SAPP_KEYCODE_LEFT_BRACKET },\n    { \"Backslash\",      SAPP_KEYCODE_BACKSLASH },\n    { \"BracketRight\",   SAPP_KEYCODE_RIGHT_BRACKET },\n    { \"Quote\",          SAPP_KEYCODE_GRAVE_ACCENT },    // FIXME: ???\n    { 0, SAPP_KEYCODE_INVALID },\n};\n\n_SOKOL_PRIVATE sapp_keycode _sapp_emsc_translate_key(const char* str) {\n    int i = 0;\n    const char* keystr;\n    while (( keystr = _sapp_emsc_keymap[i].str )) {\n        if (0 == strcmp(str, keystr)) {\n            return _sapp_emsc_keymap[i].code;\n        }\n        i += 1;\n    }\n    return SAPP_KEYCODE_INVALID;\n}\n\n// returns true if the key code is a 'character key', this is used to decide\n// if a key event needs to bubble up to create a char event\n_SOKOL_PRIVATE bool _sapp_emsc_is_char_key(sapp_keycode key_code) {\n    return key_code < SAPP_KEYCODE_WORLD_1;\n}\n\n_SOKOL_PRIVATE EM_BOOL _sapp_emsc_key_cb(int emsc_type, const EmscriptenKeyboardEvent* emsc_event, void* user_data) {\n    _SOKOL_UNUSED(user_data);\n    bool consume_event = false;\n    if (_sapp_events_enabled()) {\n        sapp_event_type type;\n        switch (emsc_type) {\n            case EMSCRIPTEN_EVENT_KEYDOWN:\n                type = SAPP_EVENTTYPE_KEY_DOWN;\n                break;\n            case EMSCRIPTEN_EVENT_KEYUP:\n                type = SAPP_EVENTTYPE_KEY_UP;\n                break;\n            case EMSCRIPTEN_EVENT_KEYPRESS:\n                type = SAPP_EVENTTYPE_CHAR;\n                break;\n            default:\n                type = SAPP_EVENTTYPE_INVALID;\n                break;\n        }\n        if (type != SAPP_EVENTTYPE_INVALID) {\n            bool send_keyup_followup = false;\n            _sapp_init_event(type);\n            _sapp.event.key_repeat = emsc_event->repeat;\n            _sapp.event.modifiers = _sapp_emsc_key_event_mods(emsc_event);\n            if (type == SAPP_EVENTTYPE_CHAR) {\n                // NOTE: charCode doesn't appear to be supported on Android Chrome\n                _sapp.event.char_code = emsc_event->charCode;\n                consume_event |= !_sapp.desc.html5_bubble_char_events;\n            } else {\n                if (0 != emsc_event->code[0]) {\n                    // This code path is for desktop browsers which send untranslated 'physical' key code strings\n                    // (which is what we actually want for key events)\n                    _sapp.event.key_code = _sapp_emsc_translate_key(emsc_event->code);\n                } else {\n                    // This code path is for mobile browsers which only send localized key code\n                    // strings. Note that the translation will only work for a small subset\n                    // of localization-agnostic keys (like Enter, arrow keys, etc...), but\n                    // regular alpha-numeric keys will all result in an SAPP_KEYCODE_INVALID)\n                    _sapp.event.key_code = _sapp_emsc_translate_key(emsc_event->key);\n                }\n\n                // Special hack for macOS: if the Super key is pressed, macOS doesn't\n                //  send keyUp events. As a workaround, to prevent keys from\n                //  \"sticking\", we'll send a keyup event following a keydown\n                //  when the SUPER key is pressed\n                if ((type == SAPP_EVENTTYPE_KEY_DOWN) &&\n                    (_sapp.event.key_code != SAPP_KEYCODE_LEFT_SUPER) &&\n                    (_sapp.event.key_code != SAPP_KEYCODE_RIGHT_SUPER) &&\n                    (_sapp.event.modifiers & SAPP_MODIFIER_SUPER))\n                {\n                    send_keyup_followup = true;\n                }\n\n                // 'character key events' will always need to bubble up, otherwise the browser\n                // wouldn't be able to generate character events.\n                if (!_sapp_emsc_is_char_key(_sapp.event.key_code)) {\n                    consume_event |= !_sapp.desc.html5_bubble_key_events;\n                }\n            }\n            consume_event |= _sapp_call_event(&_sapp.event);\n            if (send_keyup_followup) {\n                _sapp.event.type = SAPP_EVENTTYPE_KEY_UP;\n                consume_event |= _sapp_call_event(&_sapp.event);\n            }\n        }\n    }\n    _sapp_emsc_update_mouse_lock_state();\n    return consume_event;\n}\n\n_SOKOL_PRIVATE EM_BOOL _sapp_emsc_touch_cb(int emsc_type, const EmscriptenTouchEvent* emsc_event, void* user_data) {\n    _SOKOL_UNUSED(user_data);\n    bool consume_event = !_sapp.desc.html5_bubble_touch_events;\n    if (_sapp_events_enabled()) {\n        sapp_event_type type;\n        switch (emsc_type) {\n            case EMSCRIPTEN_EVENT_TOUCHSTART:\n                type = SAPP_EVENTTYPE_TOUCHES_BEGAN;\n                break;\n            case EMSCRIPTEN_EVENT_TOUCHMOVE:\n                type = SAPP_EVENTTYPE_TOUCHES_MOVED;\n                break;\n            case EMSCRIPTEN_EVENT_TOUCHEND:\n                type = SAPP_EVENTTYPE_TOUCHES_ENDED;\n                break;\n            case EMSCRIPTEN_EVENT_TOUCHCANCEL:\n                type = SAPP_EVENTTYPE_TOUCHES_CANCELLED;\n                break;\n            default:\n                type = SAPP_EVENTTYPE_INVALID;\n                break;\n        }\n        if (type != SAPP_EVENTTYPE_INVALID) {\n            _sapp_init_event(type);\n            _sapp.event.modifiers = _sapp_emsc_touch_event_mods(emsc_event);\n            _sapp.event.num_touches = emsc_event->numTouches;\n            if (_sapp.event.num_touches > SAPP_MAX_TOUCHPOINTS) {\n                _sapp.event.num_touches = SAPP_MAX_TOUCHPOINTS;\n            }\n            for (int i = 0; i < _sapp.event.num_touches; i++) {\n                const EmscriptenTouchPoint* src = &emsc_event->touches[i];\n                sapp_touchpoint* dst = &_sapp.event.touches[i];\n                dst->identifier = (uintptr_t)src->identifier;\n                dst->pos_x = src->targetX * _sapp.dpi_scale;\n                dst->pos_y = src->targetY * _sapp.dpi_scale;\n                dst->changed = src->isChanged;\n            }\n            consume_event |= _sapp_call_event(&_sapp.event);\n        }\n    }\n    return consume_event;\n}\n\n_SOKOL_PRIVATE EM_BOOL _sapp_emsc_focus_cb(int emsc_type, const EmscriptenFocusEvent* emsc_event, void* user_data) {\n    _SOKOL_UNUSED(emsc_type);\n    _SOKOL_UNUSED(emsc_event);\n    _SOKOL_UNUSED(user_data);\n    if (_sapp_events_enabled()) {\n        _sapp_init_event(SAPP_EVENTTYPE_FOCUSED);\n        _sapp_call_event(&_sapp.event);\n    }\n    return true;\n}\n\n_SOKOL_PRIVATE EM_BOOL _sapp_emsc_blur_cb(int emsc_type, const EmscriptenFocusEvent* emsc_event, void* user_data) {\n    _SOKOL_UNUSED(emsc_type);\n    _SOKOL_UNUSED(emsc_event);\n    _SOKOL_UNUSED(user_data);\n    if (_sapp_events_enabled()) {\n        _sapp_init_event(SAPP_EVENTTYPE_UNFOCUSED);\n        _sapp_call_event(&_sapp.event);\n    }\n    return true;\n}\n\n#if defined(SOKOL_GLES3)\n_SOKOL_PRIVATE EM_BOOL _sapp_emsc_webgl_context_cb(int emsc_type, const void* reserved, void* user_data) {\n    _SOKOL_UNUSED(reserved);\n    _SOKOL_UNUSED(user_data);\n    sapp_event_type type;\n    switch (emsc_type) {\n        case EMSCRIPTEN_EVENT_WEBGLCONTEXTLOST:     type = SAPP_EVENTTYPE_SUSPENDED; break;\n        case EMSCRIPTEN_EVENT_WEBGLCONTEXTRESTORED: type = SAPP_EVENTTYPE_RESUMED; break;\n        default:                                    type = SAPP_EVENTTYPE_INVALID; break;\n    }\n    if (_sapp_events_enabled() && (SAPP_EVENTTYPE_INVALID != type)) {\n        _sapp_init_event(type);\n        _sapp_call_event(&_sapp.event);\n    }\n    return true;\n}\n\n_SOKOL_PRIVATE void _sapp_emsc_webgl_init(void) {\n    EmscriptenWebGLContextAttributes attrs;\n    emscripten_webgl_init_context_attributes(&attrs);\n    attrs.alpha = _sapp.desc.alpha;\n    attrs.depth = true;\n    attrs.stencil = true;\n    attrs.antialias = _sapp.sample_count > 1;\n    attrs.premultipliedAlpha = _sapp.desc.html5_premultiplied_alpha;\n    attrs.preserveDrawingBuffer = _sapp.desc.html5_preserve_drawing_buffer;\n    attrs.enableExtensionsByDefault = true;\n    attrs.majorVersion = 2;\n    EMSCRIPTEN_WEBGL_CONTEXT_HANDLE ctx = emscripten_webgl_create_context(_sapp.html5_canvas_selector, &attrs);\n    // FIXME: error message?\n    emscripten_webgl_make_context_current(ctx);\n    glGetIntegerv(GL_FRAMEBUFFER_BINDING, (GLint*)&_sapp.gl.framebuffer);\n\n    // FIXME: remove PVRTC support here and in sokol-gfx at some point\n    // some WebGL extension are not enabled automatically by emscripten\n    emscripten_webgl_enable_extension(ctx, \"WEBKIT_WEBGL_compressed_texture_pvrtc\");\n}\n#endif\n\n#if defined(SOKOL_WGPU)\n\n_SOKOL_PRIVATE void _sapp_emsc_wgpu_create_swapchain(void) {\n    SOKOL_ASSERT(_sapp.wgpu.instance);\n    SOKOL_ASSERT(_sapp.wgpu.device);\n    SOKOL_ASSERT(0 == _sapp.wgpu.surface);\n    SOKOL_ASSERT(0 == _sapp.wgpu.swapchain);\n    SOKOL_ASSERT(0 == _sapp.wgpu.msaa_tex);\n    SOKOL_ASSERT(0 == _sapp.wgpu.msaa_view);\n    SOKOL_ASSERT(0 == _sapp.wgpu.depth_stencil_tex);\n    SOKOL_ASSERT(0 == _sapp.wgpu.depth_stencil_view);\n    SOKOL_ASSERT(0 == _sapp.wgpu.swapchain_view);\n\n    WGPUSurfaceDescriptorFromCanvasHTMLSelector canvas_desc;\n    _sapp_clear(&canvas_desc, sizeof(canvas_desc));\n    canvas_desc.chain.sType = WGPUSType_SurfaceDescriptorFromCanvasHTMLSelector;\n    canvas_desc.selector = _sapp.html5_canvas_selector;\n    WGPUSurfaceDescriptor surf_desc;\n    _sapp_clear(&surf_desc, sizeof(surf_desc));\n    surf_desc.nextInChain = &canvas_desc.chain;\n    _sapp.wgpu.surface = wgpuInstanceCreateSurface(_sapp.wgpu.instance, &surf_desc);\n    if (0 == _sapp.wgpu.surface) {\n        _SAPP_PANIC(WGPU_SWAPCHAIN_CREATE_SURFACE_FAILED);\n    }\n    _sapp.wgpu.render_format = wgpuSurfaceGetPreferredFormat(_sapp.wgpu.surface, _sapp.wgpu.adapter);\n\n    WGPUSwapChainDescriptor sc_desc;\n    _sapp_clear(&sc_desc, sizeof(sc_desc));\n    sc_desc.usage = WGPUTextureUsage_RenderAttachment;\n    sc_desc.format = _sapp.wgpu.render_format;\n    sc_desc.width = (uint32_t)_sapp.framebuffer_width;\n    sc_desc.height = (uint32_t)_sapp.framebuffer_height;\n    sc_desc.presentMode = WGPUPresentMode_Fifo;\n    _sapp.wgpu.swapchain = wgpuDeviceCreateSwapChain(_sapp.wgpu.device, _sapp.wgpu.surface, &sc_desc);\n    if (0 == _sapp.wgpu.swapchain) {\n        _SAPP_PANIC(WGPU_SWAPCHAIN_CREATE_SWAPCHAIN_FAILED);\n    }\n\n    WGPUTextureDescriptor ds_desc;\n    _sapp_clear(&ds_desc, sizeof(ds_desc));\n    ds_desc.usage = WGPUTextureUsage_RenderAttachment;\n    ds_desc.dimension = WGPUTextureDimension_2D;\n    ds_desc.size.width = (uint32_t)_sapp.framebuffer_width;\n    ds_desc.size.height = (uint32_t)_sapp.framebuffer_height;\n    ds_desc.size.depthOrArrayLayers = 1;\n    ds_desc.format = WGPUTextureFormat_Depth32FloatStencil8;\n    ds_desc.mipLevelCount = 1;\n    ds_desc.sampleCount = (uint32_t)_sapp.sample_count;\n    _sapp.wgpu.depth_stencil_tex = wgpuDeviceCreateTexture(_sapp.wgpu.device, &ds_desc);\n    if (0 == _sapp.wgpu.depth_stencil_tex) {\n        _SAPP_PANIC(WGPU_SWAPCHAIN_CREATE_DEPTH_STENCIL_TEXTURE_FAILED);\n    }\n    _sapp.wgpu.depth_stencil_view = wgpuTextureCreateView(_sapp.wgpu.depth_stencil_tex, 0);\n    if (0 == _sapp.wgpu.depth_stencil_view) {\n        _SAPP_PANIC(WGPU_SWAPCHAIN_CREATE_DEPTH_STENCIL_VIEW_FAILED);\n    }\n\n    if (_sapp.sample_count > 1) {\n        WGPUTextureDescriptor msaa_desc;\n        _sapp_clear(&msaa_desc, sizeof(msaa_desc));\n        msaa_desc.usage = WGPUTextureUsage_RenderAttachment;\n        msaa_desc.dimension = WGPUTextureDimension_2D;\n        msaa_desc.size.width = (uint32_t)_sapp.framebuffer_width;\n        msaa_desc.size.height = (uint32_t)_sapp.framebuffer_height;\n        msaa_desc.size.depthOrArrayLayers = 1;\n        msaa_desc.format = _sapp.wgpu.render_format;\n        msaa_desc.mipLevelCount = 1;\n        msaa_desc.sampleCount = (uint32_t)_sapp.sample_count;\n        _sapp.wgpu.msaa_tex = wgpuDeviceCreateTexture(_sapp.wgpu.device, &msaa_desc);\n        if (0 == _sapp.wgpu.msaa_tex) {\n            _SAPP_PANIC(WGPU_SWAPCHAIN_CREATE_MSAA_TEXTURE_FAILED);\n        }\n        _sapp.wgpu.msaa_view = wgpuTextureCreateView(_sapp.wgpu.msaa_tex, 0);\n        if (0 == _sapp.wgpu.msaa_view) {\n            _SAPP_PANIC(WGPU_SWAPCHAIN_CREATE_MSAA_VIEW_FAILED);\n        }\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_emsc_wgpu_discard_swapchain(void) {\n    if (_sapp.wgpu.msaa_view) {\n        wgpuTextureViewRelease(_sapp.wgpu.msaa_view);\n        _sapp.wgpu.msaa_view = 0;\n    }\n    if (_sapp.wgpu.msaa_tex) {\n        wgpuTextureRelease(_sapp.wgpu.msaa_tex);\n        _sapp.wgpu.msaa_tex = 0;\n    }\n    if (_sapp.wgpu.depth_stencil_view) {\n        wgpuTextureViewRelease(_sapp.wgpu.depth_stencil_view);\n        _sapp.wgpu.depth_stencil_view = 0;\n    }\n    if (_sapp.wgpu.depth_stencil_tex) {\n        wgpuTextureRelease(_sapp.wgpu.depth_stencil_tex);\n        _sapp.wgpu.depth_stencil_tex = 0;\n    }\n    if (_sapp.wgpu.swapchain) {\n        wgpuSwapChainRelease(_sapp.wgpu.swapchain);\n        _sapp.wgpu.swapchain = 0;\n    }\n    if (_sapp.wgpu.surface) {\n        wgpuSurfaceRelease(_sapp.wgpu.surface);\n        _sapp.wgpu.surface = 0;\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_emsc_wgpu_size_changed(void) {\n    _sapp_emsc_wgpu_discard_swapchain();\n    _sapp_emsc_wgpu_create_swapchain();\n}\n\n_SOKOL_PRIVATE void _sapp_emsc_wgpu_request_device_cb(WGPURequestDeviceStatus status, WGPUDevice device, const char* msg, void* userdata) {\n    _SOKOL_UNUSED(msg);\n    _SOKOL_UNUSED(userdata);\n    SOKOL_ASSERT(!_sapp.wgpu.async_init_done);\n    if (status != WGPURequestDeviceStatus_Success) {\n        if (status == WGPURequestDeviceStatus_Error) {\n            _SAPP_PANIC(WGPU_REQUEST_DEVICE_STATUS_ERROR);\n        } else {\n            _SAPP_PANIC(WGPU_REQUEST_DEVICE_STATUS_UNKNOWN);\n        }\n    }\n    SOKOL_ASSERT(device);\n    _sapp.wgpu.device = device;\n    _sapp_emsc_wgpu_create_swapchain();\n    _sapp.wgpu.async_init_done = true;\n}\n\n_SOKOL_PRIVATE void _sapp_emsc_wgpu_request_adapter_cb(WGPURequestAdapterStatus status, WGPUAdapter adapter, const char* msg, void* userdata) {\n    _SOKOL_UNUSED(msg);\n    _SOKOL_UNUSED(userdata);\n    if (status != WGPURequestAdapterStatus_Success) {\n        switch (status) {\n            case WGPURequestAdapterStatus_Unavailable: _SAPP_PANIC(WGPU_REQUEST_ADAPTER_STATUS_UNAVAILABLE); break;\n            case WGPURequestAdapterStatus_Error: _SAPP_PANIC(WGPU_REQUEST_ADAPTER_STATUS_ERROR); break;\n            default: _SAPP_PANIC(WGPU_REQUEST_ADAPTER_STATUS_UNKNOWN); break;\n        }\n    }\n    SOKOL_ASSERT(adapter);\n    _sapp.wgpu.adapter = adapter;\n    size_t cur_feature_index = 1;\n    #define _SAPP_WGPU_MAX_REQUESTED_FEATURES (8)\n    WGPUFeatureName requiredFeatures[_SAPP_WGPU_MAX_REQUESTED_FEATURES] = {\n        WGPUFeatureName_Depth32FloatStencil8,\n    };\n    // check for optional features we're interested in\n    if (wgpuAdapterHasFeature(adapter, WGPUFeatureName_TextureCompressionBC)) {\n        SOKOL_ASSERT(cur_feature_index < _SAPP_WGPU_MAX_REQUESTED_FEATURES);\n        requiredFeatures[cur_feature_index++] = WGPUFeatureName_TextureCompressionBC;\n    }\n    if (wgpuAdapterHasFeature(adapter, WGPUFeatureName_TextureCompressionETC2)) {\n        SOKOL_ASSERT(cur_feature_index < _SAPP_WGPU_MAX_REQUESTED_FEATURES);\n        requiredFeatures[cur_feature_index++] = WGPUFeatureName_TextureCompressionETC2;\n    }\n    if (wgpuAdapterHasFeature(adapter, WGPUFeatureName_TextureCompressionASTC)) {\n        SOKOL_ASSERT(cur_feature_index < _SAPP_WGPU_MAX_REQUESTED_FEATURES);\n        requiredFeatures[cur_feature_index++] = WGPUFeatureName_TextureCompressionASTC;\n    }\n    if (wgpuAdapterHasFeature(adapter, WGPUFeatureName_Float32Filterable)) {\n        SOKOL_ASSERT(cur_feature_index < _SAPP_WGPU_MAX_REQUESTED_FEATURES);\n        requiredFeatures[cur_feature_index++] = WGPUFeatureName_Float32Filterable;\n    }\n    #undef _SAPP_WGPU_MAX_REQUESTED_FEATURES\n\n    WGPUDeviceDescriptor dev_desc;\n    _sapp_clear(&dev_desc, sizeof(dev_desc));\n    dev_desc.requiredFeatureCount = cur_feature_index;\n    dev_desc.requiredFeatures = requiredFeatures,\n    wgpuAdapterRequestDevice(adapter, &dev_desc, _sapp_emsc_wgpu_request_device_cb, 0);\n}\n\n_SOKOL_PRIVATE void _sapp_emsc_wgpu_init(void) {\n    SOKOL_ASSERT(0 == _sapp.wgpu.instance);\n    SOKOL_ASSERT(!_sapp.wgpu.async_init_done);\n    _sapp.wgpu.instance = wgpuCreateInstance(0);\n    if (0 == _sapp.wgpu.instance) {\n        _SAPP_PANIC(WGPU_CREATE_INSTANCE_FAILED);\n    }\n    // FIXME: power preference?\n    wgpuInstanceRequestAdapter(_sapp.wgpu.instance, 0, _sapp_emsc_wgpu_request_adapter_cb, 0);\n}\n\n_SOKOL_PRIVATE void _sapp_emsc_wgpu_frame(void) {\n    if (_sapp.wgpu.async_init_done) {\n        _sapp.wgpu.swapchain_view = wgpuSwapChainGetCurrentTextureView(_sapp.wgpu.swapchain);\n        _sapp_frame();\n        wgpuTextureViewRelease(_sapp.wgpu.swapchain_view);\n        _sapp.wgpu.swapchain_view = 0;\n    }\n}\n#endif // SOKOL_WGPU\n\n_SOKOL_PRIVATE void _sapp_emsc_register_eventhandlers(void) {\n    // NOTE: HTML canvas doesn't receive input focus, this is why key event handlers are added\n    // to the window object (this could be worked around by adding a \"tab index\" to the\n    // canvas)\n    emscripten_set_mousedown_callback(_sapp.html5_canvas_selector, 0, true, _sapp_emsc_mouse_cb);\n    emscripten_set_mouseup_callback(_sapp.html5_canvas_selector, 0, true, _sapp_emsc_mouse_cb);\n    emscripten_set_mousemove_callback(_sapp.html5_canvas_selector, 0, true, _sapp_emsc_mouse_cb);\n    emscripten_set_mouseenter_callback(_sapp.html5_canvas_selector, 0, true, _sapp_emsc_mouse_cb);\n    emscripten_set_mouseleave_callback(_sapp.html5_canvas_selector, 0, true, _sapp_emsc_mouse_cb);\n    emscripten_set_wheel_callback(_sapp.html5_canvas_selector, 0, true, _sapp_emsc_wheel_cb);\n    emscripten_set_keydown_callback(EMSCRIPTEN_EVENT_TARGET_WINDOW, 0, true, _sapp_emsc_key_cb);\n    emscripten_set_keyup_callback(EMSCRIPTEN_EVENT_TARGET_WINDOW, 0, true, _sapp_emsc_key_cb);\n    emscripten_set_keypress_callback(EMSCRIPTEN_EVENT_TARGET_WINDOW, 0, true, _sapp_emsc_key_cb);\n    emscripten_set_touchstart_callback(_sapp.html5_canvas_selector, 0, true, _sapp_emsc_touch_cb);\n    emscripten_set_touchmove_callback(_sapp.html5_canvas_selector, 0, true, _sapp_emsc_touch_cb);\n    emscripten_set_touchend_callback(_sapp.html5_canvas_selector, 0, true, _sapp_emsc_touch_cb);\n    emscripten_set_touchcancel_callback(_sapp.html5_canvas_selector, 0, true, _sapp_emsc_touch_cb);\n    emscripten_set_pointerlockchange_callback(EMSCRIPTEN_EVENT_TARGET_DOCUMENT, 0, true, _sapp_emsc_pointerlockchange_cb);\n    emscripten_set_pointerlockerror_callback(EMSCRIPTEN_EVENT_TARGET_DOCUMENT, 0, true, _sapp_emsc_pointerlockerror_cb);\n    emscripten_set_focus_callback(EMSCRIPTEN_EVENT_TARGET_WINDOW, 0, true, _sapp_emsc_focus_cb);\n    emscripten_set_blur_callback(EMSCRIPTEN_EVENT_TARGET_WINDOW, 0, true, _sapp_emsc_blur_cb);\n    sapp_js_add_beforeunload_listener();\n    if (_sapp.clipboard.enabled) {\n        sapp_js_add_clipboard_listener();\n    }\n    if (_sapp.drop.enabled) {\n        sapp_js_add_dragndrop_listeners();\n    }\n    #if defined(SOKOL_GLES3)\n        emscripten_set_webglcontextlost_callback(_sapp.html5_canvas_selector, 0, true, _sapp_emsc_webgl_context_cb);\n        emscripten_set_webglcontextrestored_callback(_sapp.html5_canvas_selector, 0, true, _sapp_emsc_webgl_context_cb);\n    #endif\n}\n\n_SOKOL_PRIVATE void _sapp_emsc_unregister_eventhandlers(void) {\n    emscripten_set_mousedown_callback(_sapp.html5_canvas_selector, 0, true, 0);\n    emscripten_set_mouseup_callback(_sapp.html5_canvas_selector, 0, true, 0);\n    emscripten_set_mousemove_callback(_sapp.html5_canvas_selector, 0, true, 0);\n    emscripten_set_mouseenter_callback(_sapp.html5_canvas_selector, 0, true, 0);\n    emscripten_set_mouseleave_callback(_sapp.html5_canvas_selector, 0, true, 0);\n    emscripten_set_wheel_callback(_sapp.html5_canvas_selector, 0, true, 0);\n    emscripten_set_keydown_callback(EMSCRIPTEN_EVENT_TARGET_WINDOW, 0, true, 0);\n    emscripten_set_keyup_callback(EMSCRIPTEN_EVENT_TARGET_WINDOW, 0, true, 0);\n    emscripten_set_keypress_callback(EMSCRIPTEN_EVENT_TARGET_WINDOW, 0, true, 0);\n    emscripten_set_touchstart_callback(_sapp.html5_canvas_selector, 0, true, 0);\n    emscripten_set_touchmove_callback(_sapp.html5_canvas_selector, 0, true, 0);\n    emscripten_set_touchend_callback(_sapp.html5_canvas_selector, 0, true, 0);\n    emscripten_set_touchcancel_callback(_sapp.html5_canvas_selector, 0, true, 0);\n    emscripten_set_pointerlockchange_callback(EMSCRIPTEN_EVENT_TARGET_DOCUMENT, 0, true, 0);\n    emscripten_set_pointerlockerror_callback(EMSCRIPTEN_EVENT_TARGET_DOCUMENT, 0, true, 0);\n    emscripten_set_focus_callback(EMSCRIPTEN_EVENT_TARGET_WINDOW, 0, true, 0);\n    emscripten_set_blur_callback(EMSCRIPTEN_EVENT_TARGET_WINDOW, 0, true, 0);\n    if (!_sapp.desc.html5_canvas_resize) {\n        emscripten_set_resize_callback(EMSCRIPTEN_EVENT_TARGET_WINDOW, 0, true, 0);\n    }\n    sapp_js_remove_beforeunload_listener();\n    if (_sapp.clipboard.enabled) {\n        sapp_js_remove_clipboard_listener();\n    }\n    if (_sapp.drop.enabled) {\n        sapp_js_remove_dragndrop_listeners();\n    }\n    #if defined(SOKOL_GLES3)\n        emscripten_set_webglcontextlost_callback(_sapp.html5_canvas_selector, 0, true, 0);\n        emscripten_set_webglcontextrestored_callback(_sapp.html5_canvas_selector, 0, true, 0);\n    #endif\n}\n\n_SOKOL_PRIVATE EM_BOOL _sapp_emsc_frame_animation_loop(double time, void* userData) {\n    _SOKOL_UNUSED(userData);\n    _sapp_timing_external(&_sapp.timing, time / 1000.0);\n\n    #if defined(SOKOL_WGPU)\n        _sapp_emsc_wgpu_frame();\n    #else\n        _sapp_frame();\n    #endif\n\n    // quit-handling\n    if (_sapp.quit_requested) {\n        _sapp_init_event(SAPP_EVENTTYPE_QUIT_REQUESTED);\n        _sapp_call_event(&_sapp.event);\n        if (_sapp.quit_requested) {\n            _sapp.quit_ordered = true;\n        }\n    }\n    if (_sapp.quit_ordered) {\n        _sapp_emsc_unregister_eventhandlers();\n        _sapp_call_cleanup();\n        _sapp_discard_state();\n        return EM_FALSE;\n    }\n    return EM_TRUE;\n}\n\n_SOKOL_PRIVATE void _sapp_emsc_frame_main_loop(void) {\n    const double time = emscripten_performance_now();\n    if (!_sapp_emsc_frame_animation_loop(time, 0)) {\n        emscripten_cancel_main_loop();\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_emsc_run(const sapp_desc* desc) {\n    _sapp_init_state(desc);\n    const char* document_title = desc->html5_update_document_title ? _sapp.window_title : 0;\n    sapp_js_init(_sapp.html5_canvas_selector, document_title);\n    double w, h;\n    if (_sapp.desc.html5_canvas_resize) {\n        w = (double) _sapp_def(_sapp.desc.width, _SAPP_FALLBACK_DEFAULT_WINDOW_WIDTH);\n        h = (double) _sapp_def(_sapp.desc.height, _SAPP_FALLBACK_DEFAULT_WINDOW_HEIGHT);\n    }\n    else {\n        emscripten_get_element_css_size(_sapp.html5_canvas_selector, &w, &h);\n        emscripten_set_resize_callback(EMSCRIPTEN_EVENT_TARGET_WINDOW, 0, false, _sapp_emsc_size_changed);\n    }\n    if (_sapp.desc.high_dpi) {\n        _sapp.dpi_scale = emscripten_get_device_pixel_ratio();\n    }\n    _sapp.window_width = (int)roundf(w);\n    _sapp.window_height = (int)roundf(h);\n    _sapp.framebuffer_width = (int)roundf(w * _sapp.dpi_scale);\n    _sapp.framebuffer_height = (int)roundf(h * _sapp.dpi_scale);\n    emscripten_set_canvas_element_size(_sapp.html5_canvas_selector, _sapp.framebuffer_width, _sapp.framebuffer_height);\n    #if defined(SOKOL_GLES3)\n        _sapp_emsc_webgl_init();\n    #elif defined(SOKOL_WGPU)\n        _sapp_emsc_wgpu_init();\n    #endif\n    _sapp.valid = true;\n    _sapp_emsc_register_eventhandlers();\n    sapp_set_icon(&desc->icon);\n\n    // start the frame loop\n    if (_sapp.desc.html5_use_emsc_set_main_loop) {\n        emscripten_set_main_loop(_sapp_emsc_frame_main_loop, 0, _sapp.desc.html5_emsc_set_main_loop_simulate_infinite_loop);\n    } else {\n        emscripten_request_animation_frame_loop(_sapp_emsc_frame_animation_loop, 0);\n    }\n    // NOT A BUG: do not call _sapp_discard_state() here, instead this is\n    // called in _sapp_emsc_frame() when the application is ordered to quit\n}\n\n#if !defined(SOKOL_NO_ENTRY)\nint main(int argc, char* argv[]) {\n    sapp_desc desc = sokol_main(argc, argv);\n    _sapp_emsc_run(&desc);\n    return 0;\n}\n#endif /* SOKOL_NO_ENTRY */\n#endif /* _SAPP_EMSCRIPTEN */\n\n//                              \n//                                                \n//                                \n//                                                     \n//                          \n//\n// >>gl helpers\n#if defined(SOKOL_GLCORE)\ntypedef struct {\n    int         red_bits;\n    int         green_bits;\n    int         blue_bits;\n    int         alpha_bits;\n    int         depth_bits;\n    int         stencil_bits;\n    int         samples;\n    bool        doublebuffer;\n    uintptr_t   handle;\n} _sapp_gl_fbconfig;\n\n_SOKOL_PRIVATE void _sapp_gl_init_fbconfig(_sapp_gl_fbconfig* fbconfig) {\n    _sapp_clear(fbconfig, sizeof(_sapp_gl_fbconfig));\n    /* -1 means \"don't care\" */\n    fbconfig->red_bits = -1;\n    fbconfig->green_bits = -1;\n    fbconfig->blue_bits = -1;\n    fbconfig->alpha_bits = -1;\n    fbconfig->depth_bits = -1;\n    fbconfig->stencil_bits = -1;\n    fbconfig->samples = -1;\n}\n\ntypedef struct {\n    int least_missing;\n    int least_color_diff;\n    int least_extra_diff;\n    bool best_match;\n} _sapp_gl_fbselect;\n\n_SOKOL_PRIVATE void _sapp_gl_init_fbselect(_sapp_gl_fbselect* fbselect) {\n    _sapp_clear(fbselect, sizeof(_sapp_gl_fbselect));\n    fbselect->least_missing = 1000000;\n    fbselect->least_color_diff = 10000000;\n    fbselect->least_extra_diff = 10000000;\n    fbselect->best_match = false;\n}\n\n// NOTE: this is used only in the WGL code path\n_SOKOL_PRIVATE bool _sapp_gl_select_fbconfig(_sapp_gl_fbselect* fbselect, const _sapp_gl_fbconfig* desired, const _sapp_gl_fbconfig* current) {\n    int missing = 0;\n    if (desired->doublebuffer != current->doublebuffer) {\n        return false;\n    }\n\n    if ((desired->alpha_bits > 0) && (current->alpha_bits == 0)) {\n        missing++;\n    }\n    if ((desired->depth_bits > 0) && (current->depth_bits == 0)) {\n        missing++;\n    }\n    if ((desired->stencil_bits > 0) && (current->stencil_bits == 0)) {\n        missing++;\n    }\n    if ((desired->samples > 0) && (current->samples == 0)) {\n        /* Technically, several multisampling buffers could be\n            involved, but that's a lower level implementation detail and\n            not important to us here, so we count them as one\n        */\n        missing++;\n    }\n\n    /* These polynomials make many small channel size differences matter\n        less than one large channel size difference\n        Calculate color channel size difference value\n    */\n    int color_diff = 0;\n    if (desired->red_bits != -1) {\n        color_diff += (desired->red_bits - current->red_bits) * (desired->red_bits - current->red_bits);\n    }\n    if (desired->green_bits != -1) {\n        color_diff += (desired->green_bits - current->green_bits) * (desired->green_bits - current->green_bits);\n    }\n    if (desired->blue_bits != -1) {\n        color_diff += (desired->blue_bits - current->blue_bits) * (desired->blue_bits - current->blue_bits);\n    }\n\n    /* Calculate non-color channel size difference value */\n    int extra_diff = 0;\n    if (desired->alpha_bits != -1) {\n        extra_diff += (desired->alpha_bits - current->alpha_bits) * (desired->alpha_bits - current->alpha_bits);\n    }\n    if (desired->depth_bits != -1) {\n        extra_diff += (desired->depth_bits - current->depth_bits) * (desired->depth_bits - current->depth_bits);\n    }\n    if (desired->stencil_bits != -1) {\n        extra_diff += (desired->stencil_bits - current->stencil_bits) * (desired->stencil_bits - current->stencil_bits);\n    }\n    if (desired->samples != -1) {\n        extra_diff += (desired->samples - current->samples) * (desired->samples - current->samples);\n    }\n\n    /* Figure out if the current one is better than the best one found so far\n        Least number of missing buffers is the most important heuristic,\n        then color buffer size match and lastly size match for other buffers\n    */\n    bool new_closest = false;\n    if (missing < fbselect->least_missing) {\n        new_closest = true;\n    } else if (missing == fbselect->least_missing) {\n        if ((color_diff < fbselect->least_color_diff) ||\n            ((color_diff == fbselect->least_color_diff) && (extra_diff < fbselect->least_extra_diff)))\n        {\n            new_closest = true;\n        }\n    }\n    if (new_closest) {\n        fbselect->least_missing = missing;\n        fbselect->least_color_diff = color_diff;\n        fbselect->least_extra_diff = extra_diff;\n        fbselect->best_match = (missing | color_diff | extra_diff) == 0;\n    }\n    return new_closest;\n}\n\n// NOTE: this is used only in the GLX code path\n_SOKOL_PRIVATE const _sapp_gl_fbconfig* _sapp_gl_choose_fbconfig(const _sapp_gl_fbconfig* desired, const _sapp_gl_fbconfig* alternatives, int count) {\n    int missing, least_missing = 1000000;\n    int color_diff, least_color_diff = 10000000;\n    int extra_diff, least_extra_diff = 10000000;\n    const _sapp_gl_fbconfig* current;\n    const _sapp_gl_fbconfig* closest = 0;\n    for (int i = 0;  i < count;  i++) {\n        current = alternatives + i;\n        if (desired->doublebuffer != current->doublebuffer) {\n            continue;\n        }\n        missing = 0;\n        if (desired->alpha_bits > 0 && current->alpha_bits == 0) {\n            missing++;\n        }\n        if (desired->depth_bits > 0 && current->depth_bits == 0) {\n            missing++;\n        }\n        if (desired->stencil_bits > 0 && current->stencil_bits == 0) {\n            missing++;\n        }\n        if (desired->samples > 0 && current->samples == 0) {\n            /* Technically, several multisampling buffers could be\n                involved, but that's a lower level implementation detail and\n                not important to us here, so we count them as one\n            */\n            missing++;\n        }\n\n        /* These polynomials make many small channel size differences matter\n            less than one large channel size difference\n            Calculate color channel size difference value\n        */\n        color_diff = 0;\n        if (desired->red_bits != -1) {\n            color_diff += (desired->red_bits - current->red_bits) * (desired->red_bits - current->red_bits);\n        }\n        if (desired->green_bits != -1) {\n            color_diff += (desired->green_bits - current->green_bits) * (desired->green_bits - current->green_bits);\n        }\n        if (desired->blue_bits != -1) {\n            color_diff += (desired->blue_bits - current->blue_bits) * (desired->blue_bits - current->blue_bits);\n        }\n\n        /* Calculate non-color channel size difference value */\n        extra_diff = 0;\n        if (desired->alpha_bits != -1) {\n            extra_diff += (desired->alpha_bits - current->alpha_bits) * (desired->alpha_bits - current->alpha_bits);\n        }\n        if (desired->depth_bits != -1) {\n            extra_diff += (desired->depth_bits - current->depth_bits) * (desired->depth_bits - current->depth_bits);\n        }\n        if (desired->stencil_bits != -1) {\n            extra_diff += (desired->stencil_bits - current->stencil_bits) * (desired->stencil_bits - current->stencil_bits);\n        }\n        if (desired->samples != -1) {\n            extra_diff += (desired->samples - current->samples) * (desired->samples - current->samples);\n        }\n\n        /* Figure out if the current one is better than the best one found so far\n            Least number of missing buffers is the most important heuristic,\n            then color buffer size match and lastly size match for other buffers\n        */\n        if (missing < least_missing) {\n            closest = current;\n        }\n        else if (missing == least_missing) {\n            if ((color_diff < least_color_diff) ||\n                (color_diff == least_color_diff && extra_diff < least_extra_diff))\n            {\n                closest = current;\n            }\n        }\n        if (current == closest) {\n            least_missing = missing;\n            least_color_diff = color_diff;\n            least_extra_diff = extra_diff;\n        }\n    }\n    return closest;\n}\n#endif\n\n//                        \n//                           \n//                         \n//                          \n//                   \n//\n// >>windows\n#if defined(_SAPP_WIN32)\n_SOKOL_PRIVATE bool _sapp_win32_utf8_to_wide(const char* src, wchar_t* dst, int dst_num_bytes) {\n    SOKOL_ASSERT(src && dst && (dst_num_bytes > 1));\n    _sapp_clear(dst, (size_t)dst_num_bytes);\n    const int dst_chars = dst_num_bytes / (int)sizeof(wchar_t);\n    const int dst_needed = MultiByteToWideChar(CP_UTF8, 0, src, -1, 0, 0);\n    if ((dst_needed > 0) && (dst_needed < dst_chars)) {\n        MultiByteToWideChar(CP_UTF8, 0, src, -1, dst, dst_chars);\n        return true;\n    }\n    else {\n        /* input string doesn't fit into destination buffer */\n        return false;\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_win32_app_event(sapp_event_type type) {\n    if (_sapp_events_enabled()) {\n        _sapp_init_event(type);\n        _sapp_call_event(&_sapp.event);\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_win32_init_keytable(void) {\n    /* same as GLFW */\n    _sapp.keycodes[0x00B] = SAPP_KEYCODE_0;\n    _sapp.keycodes[0x002] = SAPP_KEYCODE_1;\n    _sapp.keycodes[0x003] = SAPP_KEYCODE_2;\n    _sapp.keycodes[0x004] = SAPP_KEYCODE_3;\n    _sapp.keycodes[0x005] = SAPP_KEYCODE_4;\n    _sapp.keycodes[0x006] = SAPP_KEYCODE_5;\n    _sapp.keycodes[0x007] = SAPP_KEYCODE_6;\n    _sapp.keycodes[0x008] = SAPP_KEYCODE_7;\n    _sapp.keycodes[0x009] = SAPP_KEYCODE_8;\n    _sapp.keycodes[0x00A] = SAPP_KEYCODE_9;\n    _sapp.keycodes[0x01E] = SAPP_KEYCODE_A;\n    _sapp.keycodes[0x030] = SAPP_KEYCODE_B;\n    _sapp.keycodes[0x02E] = SAPP_KEYCODE_C;\n    _sapp.keycodes[0x020] = SAPP_KEYCODE_D;\n    _sapp.keycodes[0x012] = SAPP_KEYCODE_E;\n    _sapp.keycodes[0x021] = SAPP_KEYCODE_F;\n    _sapp.keycodes[0x022] = SAPP_KEYCODE_G;\n    _sapp.keycodes[0x023] = SAPP_KEYCODE_H;\n    _sapp.keycodes[0x017] = SAPP_KEYCODE_I;\n    _sapp.keycodes[0x024] = SAPP_KEYCODE_J;\n    _sapp.keycodes[0x025] = SAPP_KEYCODE_K;\n    _sapp.keycodes[0x026] = SAPP_KEYCODE_L;\n    _sapp.keycodes[0x032] = SAPP_KEYCODE_M;\n    _sapp.keycodes[0x031] = SAPP_KEYCODE_N;\n    _sapp.keycodes[0x018] = SAPP_KEYCODE_O;\n    _sapp.keycodes[0x019] = SAPP_KEYCODE_P;\n    _sapp.keycodes[0x010] = SAPP_KEYCODE_Q;\n    _sapp.keycodes[0x013] = SAPP_KEYCODE_R;\n    _sapp.keycodes[0x01F] = SAPP_KEYCODE_S;\n    _sapp.keycodes[0x014] = SAPP_KEYCODE_T;\n    _sapp.keycodes[0x016] = SAPP_KEYCODE_U;\n    _sapp.keycodes[0x02F] = SAPP_KEYCODE_V;\n    _sapp.keycodes[0x011] = SAPP_KEYCODE_W;\n    _sapp.keycodes[0x02D] = SAPP_KEYCODE_X;\n    _sapp.keycodes[0x015] = SAPP_KEYCODE_Y;\n    _sapp.keycodes[0x02C] = SAPP_KEYCODE_Z;\n    _sapp.keycodes[0x028] = SAPP_KEYCODE_APOSTROPHE;\n    _sapp.keycodes[0x02B] = SAPP_KEYCODE_BACKSLASH;\n    _sapp.keycodes[0x033] = SAPP_KEYCODE_COMMA;\n    _sapp.keycodes[0x00D] = SAPP_KEYCODE_EQUAL;\n    _sapp.keycodes[0x029] = SAPP_KEYCODE_GRAVE_ACCENT;\n    _sapp.keycodes[0x01A] = SAPP_KEYCODE_LEFT_BRACKET;\n    _sapp.keycodes[0x00C] = SAPP_KEYCODE_MINUS;\n    _sapp.keycodes[0x034] = SAPP_KEYCODE_PERIOD;\n    _sapp.keycodes[0x01B] = SAPP_KEYCODE_RIGHT_BRACKET;\n    _sapp.keycodes[0x027] = SAPP_KEYCODE_SEMICOLON;\n    _sapp.keycodes[0x035] = SAPP_KEYCODE_SLASH;\n    _sapp.keycodes[0x056] = SAPP_KEYCODE_WORLD_2;\n    _sapp.keycodes[0x00E] = SAPP_KEYCODE_BACKSPACE;\n    _sapp.keycodes[0x153] = SAPP_KEYCODE_DELETE;\n    _sapp.keycodes[0x14F] = SAPP_KEYCODE_END;\n    _sapp.keycodes[0x01C] = SAPP_KEYCODE_ENTER;\n    _sapp.keycodes[0x001] = SAPP_KEYCODE_ESCAPE;\n    _sapp.keycodes[0x147] = SAPP_KEYCODE_HOME;\n    _sapp.keycodes[0x152] = SAPP_KEYCODE_INSERT;\n    _sapp.keycodes[0x15D] = SAPP_KEYCODE_MENU;\n    _sapp.keycodes[0x151] = SAPP_KEYCODE_PAGE_DOWN;\n    _sapp.keycodes[0x149] = SAPP_KEYCODE_PAGE_UP;\n    _sapp.keycodes[0x045] = SAPP_KEYCODE_PAUSE;\n    _sapp.keycodes[0x146] = SAPP_KEYCODE_PAUSE;\n    _sapp.keycodes[0x039] = SAPP_KEYCODE_SPACE;\n    _sapp.keycodes[0x00F] = SAPP_KEYCODE_TAB;\n    _sapp.keycodes[0x03A] = SAPP_KEYCODE_CAPS_LOCK;\n    _sapp.keycodes[0x145] = SAPP_KEYCODE_NUM_LOCK;\n    _sapp.keycodes[0x046] = SAPP_KEYCODE_SCROLL_LOCK;\n    _sapp.keycodes[0x03B] = SAPP_KEYCODE_F1;\n    _sapp.keycodes[0x03C] = SAPP_KEYCODE_F2;\n    _sapp.keycodes[0x03D] = SAPP_KEYCODE_F3;\n    _sapp.keycodes[0x03E] = SAPP_KEYCODE_F4;\n    _sapp.keycodes[0x03F] = SAPP_KEYCODE_F5;\n    _sapp.keycodes[0x040] = SAPP_KEYCODE_F6;\n    _sapp.keycodes[0x041] = SAPP_KEYCODE_F7;\n    _sapp.keycodes[0x042] = SAPP_KEYCODE_F8;\n    _sapp.keycodes[0x043] = SAPP_KEYCODE_F9;\n    _sapp.keycodes[0x044] = SAPP_KEYCODE_F10;\n    _sapp.keycodes[0x057] = SAPP_KEYCODE_F11;\n    _sapp.keycodes[0x058] = SAPP_KEYCODE_F12;\n    _sapp.keycodes[0x064] = SAPP_KEYCODE_F13;\n    _sapp.keycodes[0x065] = SAPP_KEYCODE_F14;\n    _sapp.keycodes[0x066] = SAPP_KEYCODE_F15;\n    _sapp.keycodes[0x067] = SAPP_KEYCODE_F16;\n    _sapp.keycodes[0x068] = SAPP_KEYCODE_F17;\n    _sapp.keycodes[0x069] = SAPP_KEYCODE_F18;\n    _sapp.keycodes[0x06A] = SAPP_KEYCODE_F19;\n    _sapp.keycodes[0x06B] = SAPP_KEYCODE_F20;\n    _sapp.keycodes[0x06C] = SAPP_KEYCODE_F21;\n    _sapp.keycodes[0x06D] = SAPP_KEYCODE_F22;\n    _sapp.keycodes[0x06E] = SAPP_KEYCODE_F23;\n    _sapp.keycodes[0x076] = SAPP_KEYCODE_F24;\n    _sapp.keycodes[0x038] = SAPP_KEYCODE_LEFT_ALT;\n    _sapp.keycodes[0x01D] = SAPP_KEYCODE_LEFT_CONTROL;\n    _sapp.keycodes[0x02A] = SAPP_KEYCODE_LEFT_SHIFT;\n    _sapp.keycodes[0x15B] = SAPP_KEYCODE_LEFT_SUPER;\n    _sapp.keycodes[0x137] = SAPP_KEYCODE_PRINT_SCREEN;\n    _sapp.keycodes[0x138] = SAPP_KEYCODE_RIGHT_ALT;\n    _sapp.keycodes[0x11D] = SAPP_KEYCODE_RIGHT_CONTROL;\n    _sapp.keycodes[0x036] = SAPP_KEYCODE_RIGHT_SHIFT;\n    _sapp.keycodes[0x136] = SAPP_KEYCODE_RIGHT_SHIFT;\n    _sapp.keycodes[0x15C] = SAPP_KEYCODE_RIGHT_SUPER;\n    _sapp.keycodes[0x150] = SAPP_KEYCODE_DOWN;\n    _sapp.keycodes[0x14B] = SAPP_KEYCODE_LEFT;\n    _sapp.keycodes[0x14D] = SAPP_KEYCODE_RIGHT;\n    _sapp.keycodes[0x148] = SAPP_KEYCODE_UP;\n    _sapp.keycodes[0x052] = SAPP_KEYCODE_KP_0;\n    _sapp.keycodes[0x04F] = SAPP_KEYCODE_KP_1;\n    _sapp.keycodes[0x050] = SAPP_KEYCODE_KP_2;\n    _sapp.keycodes[0x051] = SAPP_KEYCODE_KP_3;\n    _sapp.keycodes[0x04B] = SAPP_KEYCODE_KP_4;\n    _sapp.keycodes[0x04C] = SAPP_KEYCODE_KP_5;\n    _sapp.keycodes[0x04D] = SAPP_KEYCODE_KP_6;\n    _sapp.keycodes[0x047] = SAPP_KEYCODE_KP_7;\n    _sapp.keycodes[0x048] = SAPP_KEYCODE_KP_8;\n    _sapp.keycodes[0x049] = SAPP_KEYCODE_KP_9;\n    _sapp.keycodes[0x04E] = SAPP_KEYCODE_KP_ADD;\n    _sapp.keycodes[0x053] = SAPP_KEYCODE_KP_DECIMAL;\n    _sapp.keycodes[0x135] = SAPP_KEYCODE_KP_DIVIDE;\n    _sapp.keycodes[0x11C] = SAPP_KEYCODE_KP_ENTER;\n    _sapp.keycodes[0x037] = SAPP_KEYCODE_KP_MULTIPLY;\n    _sapp.keycodes[0x04A] = SAPP_KEYCODE_KP_SUBTRACT;\n}\n#endif // _SAPP_WIN32\n\n#if defined(_SAPP_WIN32)\n\n#if defined(SOKOL_D3D11)\n\n#if defined(__cplusplus)\n#define _sapp_d3d11_Release(self) (self)->Release()\n#define _sapp_win32_refiid(iid) iid\n#else\n#define _sapp_d3d11_Release(self) (self)->lpVtbl->Release(self)\n#define _sapp_win32_refiid(iid) &iid\n#endif\n\n#define _SAPP_SAFE_RELEASE(obj) if (obj) { _sapp_d3d11_Release(obj); obj=0; }\n\n\nstatic const IID _sapp_IID_ID3D11Texture2D = { 0x6f15aaf2,0xd208,0x4e89, {0x9a,0xb4,0x48,0x95,0x35,0xd3,0x4f,0x9c} };\nstatic const IID _sapp_IID_IDXGIDevice1    = { 0x77db970f,0x6276,0x48ba, {0xba,0x28,0x07,0x01,0x43,0xb4,0x39,0x2c} };\nstatic const IID _sapp_IID_IDXGIFactory    = { 0x7b7166ec,0x21c7,0x44ae, {0xb2,0x1a,0xc9,0xae,0x32,0x1a,0xe3,0x69} };\n\nstatic inline HRESULT _sapp_dxgi_GetBuffer(IDXGISwapChain* self, UINT Buffer, REFIID riid, void** ppSurface) {\n    #if defined(__cplusplus)\n        return self->GetBuffer(Buffer, riid, ppSurface);\n    #else\n        return self->lpVtbl->GetBuffer(self, Buffer, riid, ppSurface);\n    #endif\n}\n\nstatic inline HRESULT _sapp_d3d11_QueryInterface(ID3D11Device* self, REFIID riid, void** ppvObject) {\n    #if defined(__cplusplus)\n        return self->QueryInterface(riid, ppvObject);\n    #else\n        return self->lpVtbl->QueryInterface(self, riid, ppvObject);\n    #endif\n}\n\nstatic inline HRESULT _sapp_d3d11_CreateRenderTargetView(ID3D11Device* self, ID3D11Resource *pResource, const D3D11_RENDER_TARGET_VIEW_DESC* pDesc, ID3D11RenderTargetView** ppRTView) {\n    #if defined(__cplusplus)\n        return self->CreateRenderTargetView(pResource, pDesc, ppRTView);\n    #else\n        return self->lpVtbl->CreateRenderTargetView(self, pResource, pDesc, ppRTView);\n    #endif\n}\n\nstatic inline HRESULT _sapp_d3d11_CreateTexture2D(ID3D11Device* self, const D3D11_TEXTURE2D_DESC* pDesc, const D3D11_SUBRESOURCE_DATA* pInitialData, ID3D11Texture2D** ppTexture2D) {\n    #if defined(__cplusplus)\n        return self->CreateTexture2D(pDesc, pInitialData, ppTexture2D);\n    #else\n        return self->lpVtbl->CreateTexture2D(self, pDesc, pInitialData, ppTexture2D);\n    #endif\n}\n\nstatic inline HRESULT _sapp_d3d11_CreateDepthStencilView(ID3D11Device* self, ID3D11Resource* pResource, const D3D11_DEPTH_STENCIL_VIEW_DESC* pDesc, ID3D11DepthStencilView** ppDepthStencilView) {\n    #if defined(__cplusplus)\n        return self->CreateDepthStencilView(pResource, pDesc, ppDepthStencilView);\n    #else\n        return self->lpVtbl->CreateDepthStencilView(self, pResource, pDesc, ppDepthStencilView);\n    #endif\n}\n\nstatic inline HRESULT _sapp_dxgi_ResizeBuffers(IDXGISwapChain* self, UINT BufferCount, UINT Width, UINT Height, DXGI_FORMAT NewFormat, UINT SwapChainFlags) {\n    #if defined(__cplusplus)\n        return self->ResizeBuffers(BufferCount, Width, Height, NewFormat, SwapChainFlags);\n    #else\n        return self->lpVtbl->ResizeBuffers(self, BufferCount, Width, Height, NewFormat, SwapChainFlags);\n    #endif\n}\n\nstatic inline HRESULT _sapp_dxgi_Present(IDXGISwapChain* self, UINT SyncInterval, UINT Flags) {\n    #if defined(__cplusplus)\n        return self->Present(SyncInterval, Flags);\n    #else\n        return self->lpVtbl->Present(self, SyncInterval, Flags);\n    #endif\n}\n\nstatic inline HRESULT _sapp_dxgi_GetFrameStatistics(IDXGISwapChain* self, DXGI_FRAME_STATISTICS* pStats) {\n    #if defined(__cplusplus)\n        return self->GetFrameStatistics(pStats);\n    #else\n        return self->lpVtbl->GetFrameStatistics(self, pStats);\n    #endif\n}\n\nstatic inline HRESULT _sapp_dxgi_SetMaximumFrameLatency(IDXGIDevice1* self, UINT MaxLatency) {\n    #if defined(__cplusplus)\n        return self->SetMaximumFrameLatency(MaxLatency);\n    #else\n        return self->lpVtbl->SetMaximumFrameLatency(self, MaxLatency);\n    #endif\n}\n\nstatic inline HRESULT _sapp_dxgi_GetAdapter(IDXGIDevice1* self, IDXGIAdapter** pAdapter) {\n    #if defined(__cplusplus)\n        return self->GetAdapter(pAdapter);\n    #else\n        return self->lpVtbl->GetAdapter(self, pAdapter);\n    #endif\n}\n\nstatic inline HRESULT _sapp_dxgi_GetParent(IDXGIObject* self, REFIID riid, void** ppParent) {\n    #if defined(__cplusplus)\n        return self->GetParent(riid, ppParent);\n    #else\n        return self->lpVtbl->GetParent(self, riid, ppParent);\n    #endif\n}\n\nstatic inline HRESULT _sapp_dxgi_MakeWindowAssociation(IDXGIFactory* self, HWND WindowHandle, UINT Flags) {\n    #if defined(__cplusplus)\n        return self->MakeWindowAssociation(WindowHandle, Flags);\n    #else\n        return self->lpVtbl->MakeWindowAssociation(self, WindowHandle, Flags);\n    #endif\n}\n\n_SOKOL_PRIVATE void _sapp_d3d11_create_device_and_swapchain(void) {\n    DXGI_SWAP_CHAIN_DESC* sc_desc = &_sapp.d3d11.swap_chain_desc;\n    sc_desc->BufferDesc.Width = (UINT)_sapp.framebuffer_width;\n    sc_desc->BufferDesc.Height = (UINT)_sapp.framebuffer_height;\n    sc_desc->BufferDesc.Format = DXGI_FORMAT_B8G8R8A8_UNORM;\n    sc_desc->BufferDesc.RefreshRate.Numerator = 60;\n    sc_desc->BufferDesc.RefreshRate.Denominator = 1;\n    sc_desc->OutputWindow = _sapp.win32.hwnd;\n    sc_desc->Windowed = true;\n    if (_sapp.win32.is_win10_or_greater) {\n        sc_desc->BufferCount = 2;\n        sc_desc->SwapEffect = (DXGI_SWAP_EFFECT) _SAPP_DXGI_SWAP_EFFECT_FLIP_DISCARD;\n        _sapp.d3d11.use_dxgi_frame_stats = true;\n    }\n    else {\n        sc_desc->BufferCount = 1;\n        sc_desc->SwapEffect = DXGI_SWAP_EFFECT_DISCARD;\n        _sapp.d3d11.use_dxgi_frame_stats = false;\n    }\n    sc_desc->SampleDesc.Count = 1;\n    sc_desc->SampleDesc.Quality = 0;\n    sc_desc->BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;\n    UINT create_flags = D3D11_CREATE_DEVICE_SINGLETHREADED | D3D11_CREATE_DEVICE_BGRA_SUPPORT;\n    #if defined(SOKOL_DEBUG)\n        create_flags |= D3D11_CREATE_DEVICE_DEBUG;\n    #endif\n    D3D_FEATURE_LEVEL feature_level;\n    HRESULT hr = D3D11CreateDeviceAndSwapChain(\n        NULL,                           /* pAdapter (use default) */\n        D3D_DRIVER_TYPE_HARDWARE,       /* DriverType */\n        NULL,                           /* Software */\n        create_flags,                   /* Flags */\n        NULL,                           /* pFeatureLevels */\n        0,                              /* FeatureLevels */\n        D3D11_SDK_VERSION,              /* SDKVersion */\n        sc_desc,                        /* pSwapChainDesc */\n        &_sapp.d3d11.swap_chain,        /* ppSwapChain */\n        &_sapp.d3d11.device,            /* ppDevice */\n        &feature_level,                 /* pFeatureLevel */\n        &_sapp.d3d11.device_context);   /* ppImmediateContext */\n    _SOKOL_UNUSED(hr);\n    #if defined(SOKOL_DEBUG)\n    if (!SUCCEEDED(hr)) {\n        // if initialization with D3D11_CREATE_DEVICE_DEBUG fails, this could be because the\n        // 'D3D11 debug layer' stopped working, indicated by the error message:\n        // ===\n        // D3D11CreateDevice: Flags (0x2) were specified which require the D3D11 SDK Layers for Windows 10, but they are not present on the system.\n        // These flags must be removed, or the Windows 10 SDK must be installed.\n        // Flags include: D3D11_CREATE_DEVICE_DEBUG\n        // ===\n        //\n        // ...just retry with the DEBUG flag switched off\n        _SAPP_ERROR(WIN32_D3D11_CREATE_DEVICE_AND_SWAPCHAIN_WITH_DEBUG_FAILED);\n        create_flags &= ~D3D11_CREATE_DEVICE_DEBUG;\n        hr = D3D11CreateDeviceAndSwapChain(\n            NULL,                           /* pAdapter (use default) */\n            D3D_DRIVER_TYPE_HARDWARE,       /* DriverType */\n            NULL,                           /* Software */\n            create_flags,                   /* Flags */\n            NULL,                           /* pFeatureLevels */\n            0,                              /* FeatureLevels */\n            D3D11_SDK_VERSION,              /* SDKVersion */\n            sc_desc,                        /* pSwapChainDesc */\n            &_sapp.d3d11.swap_chain,        /* ppSwapChain */\n            &_sapp.d3d11.device,            /* ppDevice */\n            &feature_level,                 /* pFeatureLevel */\n            &_sapp.d3d11.device_context);   /* ppImmediateContext */\n    }\n    #endif\n    SOKOL_ASSERT(SUCCEEDED(hr) && _sapp.d3d11.swap_chain && _sapp.d3d11.device && _sapp.d3d11.device_context);\n\n    // minimize frame latency, disable Alt-Enter\n    hr = _sapp_d3d11_QueryInterface(_sapp.d3d11.device, _sapp_win32_refiid(_sapp_IID_IDXGIDevice1), (void**)&_sapp.d3d11.dxgi_device);\n    if (SUCCEEDED(hr) && _sapp.d3d11.dxgi_device) {\n        _sapp_dxgi_SetMaximumFrameLatency(_sapp.d3d11.dxgi_device, 1);\n        IDXGIAdapter* dxgi_adapter = 0;\n        hr = _sapp_dxgi_GetAdapter(_sapp.d3d11.dxgi_device, &dxgi_adapter);\n        if (SUCCEEDED(hr) && dxgi_adapter) {\n            IDXGIFactory* dxgi_factory = 0;\n            hr = _sapp_dxgi_GetParent((IDXGIObject*)dxgi_adapter, _sapp_win32_refiid(_sapp_IID_IDXGIFactory), (void**)&dxgi_factory);\n            if (SUCCEEDED(hr)) {\n                _sapp_dxgi_MakeWindowAssociation(dxgi_factory, _sapp.win32.hwnd, DXGI_MWA_NO_ALT_ENTER|DXGI_MWA_NO_PRINT_SCREEN);\n                _SAPP_SAFE_RELEASE(dxgi_factory);\n            }\n            else {\n                _SAPP_ERROR(WIN32_D3D11_GET_IDXGIFACTORY_FAILED);\n            }\n            _SAPP_SAFE_RELEASE(dxgi_adapter);\n        }\n        else {\n            _SAPP_ERROR(WIN32_D3D11_GET_IDXGIADAPTER_FAILED);\n        }\n    }\n    else {\n        _SAPP_PANIC(WIN32_D3D11_QUERY_INTERFACE_IDXGIDEVICE1_FAILED);\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_d3d11_destroy_device_and_swapchain(void) {\n    _SAPP_SAFE_RELEASE(_sapp.d3d11.swap_chain);\n    _SAPP_SAFE_RELEASE(_sapp.d3d11.dxgi_device);\n    _SAPP_SAFE_RELEASE(_sapp.d3d11.device_context);\n    _SAPP_SAFE_RELEASE(_sapp.d3d11.device);\n}\n\n_SOKOL_PRIVATE void _sapp_d3d11_create_default_render_target(void) {\n    SOKOL_ASSERT(0 == _sapp.d3d11.rt);\n    SOKOL_ASSERT(0 == _sapp.d3d11.rtv);\n    SOKOL_ASSERT(0 == _sapp.d3d11.msaa_rt);\n    SOKOL_ASSERT(0 == _sapp.d3d11.msaa_rtv);\n    SOKOL_ASSERT(0 == _sapp.d3d11.ds);\n    SOKOL_ASSERT(0 == _sapp.d3d11.dsv);\n\n    HRESULT hr;\n\n    /* view for the swapchain-created framebuffer */\n    hr = _sapp_dxgi_GetBuffer(_sapp.d3d11.swap_chain, 0, _sapp_win32_refiid(_sapp_IID_ID3D11Texture2D), (void**)&_sapp.d3d11.rt);\n    SOKOL_ASSERT(SUCCEEDED(hr) && _sapp.d3d11.rt);\n    hr = _sapp_d3d11_CreateRenderTargetView(_sapp.d3d11.device, (ID3D11Resource*)_sapp.d3d11.rt, NULL, &_sapp.d3d11.rtv);\n    SOKOL_ASSERT(SUCCEEDED(hr) && _sapp.d3d11.rtv);\n\n    /* common desc for MSAA and depth-stencil texture */\n    D3D11_TEXTURE2D_DESC tex_desc;\n    _sapp_clear(&tex_desc, sizeof(tex_desc));\n    tex_desc.Width = (UINT)_sapp.framebuffer_width;\n    tex_desc.Height = (UINT)_sapp.framebuffer_height;\n    tex_desc.MipLevels = 1;\n    tex_desc.ArraySize = 1;\n    tex_desc.Usage = D3D11_USAGE_DEFAULT;\n    tex_desc.BindFlags = D3D11_BIND_RENDER_TARGET;\n    tex_desc.SampleDesc.Count = (UINT) _sapp.sample_count;\n    tex_desc.SampleDesc.Quality = (UINT) (_sapp.sample_count > 1 ? D3D11_STANDARD_MULTISAMPLE_PATTERN : 0);\n\n    /* create MSAA texture and view if antialiasing requested */\n    if (_sapp.sample_count > 1) {\n        tex_desc.Format = DXGI_FORMAT_B8G8R8A8_UNORM;\n        hr = _sapp_d3d11_CreateTexture2D(_sapp.d3d11.device, &tex_desc, NULL, &_sapp.d3d11.msaa_rt);\n        SOKOL_ASSERT(SUCCEEDED(hr) && _sapp.d3d11.msaa_rt);\n        hr = _sapp_d3d11_CreateRenderTargetView(_sapp.d3d11.device, (ID3D11Resource*)_sapp.d3d11.msaa_rt, NULL, &_sapp.d3d11.msaa_rtv);\n        SOKOL_ASSERT(SUCCEEDED(hr) && _sapp.d3d11.msaa_rtv);\n    }\n\n    /* texture and view for the depth-stencil-surface */\n    tex_desc.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;\n    tex_desc.BindFlags = D3D11_BIND_DEPTH_STENCIL;\n    hr = _sapp_d3d11_CreateTexture2D(_sapp.d3d11.device, &tex_desc, NULL, &_sapp.d3d11.ds);\n    SOKOL_ASSERT(SUCCEEDED(hr) && _sapp.d3d11.ds);\n    hr = _sapp_d3d11_CreateDepthStencilView(_sapp.d3d11.device, (ID3D11Resource*)_sapp.d3d11.ds, NULL, &_sapp.d3d11.dsv);\n    SOKOL_ASSERT(SUCCEEDED(hr) && _sapp.d3d11.dsv);\n}\n\n_SOKOL_PRIVATE void _sapp_d3d11_destroy_default_render_target(void) {\n    _SAPP_SAFE_RELEASE(_sapp.d3d11.rt);\n    _SAPP_SAFE_RELEASE(_sapp.d3d11.rtv);\n    _SAPP_SAFE_RELEASE(_sapp.d3d11.msaa_rt);\n    _SAPP_SAFE_RELEASE(_sapp.d3d11.msaa_rtv);\n    _SAPP_SAFE_RELEASE(_sapp.d3d11.ds);\n    _SAPP_SAFE_RELEASE(_sapp.d3d11.dsv);\n}\n\n_SOKOL_PRIVATE void _sapp_d3d11_resize_default_render_target(void) {\n    if (_sapp.d3d11.swap_chain) {\n        _sapp_d3d11_destroy_default_render_target();\n        _sapp_dxgi_ResizeBuffers(_sapp.d3d11.swap_chain, _sapp.d3d11.swap_chain_desc.BufferCount, (UINT)_sapp.framebuffer_width, (UINT)_sapp.framebuffer_height, DXGI_FORMAT_B8G8R8A8_UNORM, 0);\n        _sapp_d3d11_create_default_render_target();\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_d3d11_present(bool do_not_wait) {\n    UINT flags = 0;\n    if (_sapp.win32.is_win10_or_greater && do_not_wait) {\n        /* this hack/workaround somewhat improves window-movement and -sizing\n            responsiveness when rendering is controlled via WM_TIMER during window\n            move and resize on NVIDIA cards on Win10 with recent drivers.\n        */\n        flags = DXGI_PRESENT_DO_NOT_WAIT;\n    }\n    _sapp_dxgi_Present(_sapp.d3d11.swap_chain, (UINT)_sapp.swap_interval, flags);\n}\n\n#endif /* SOKOL_D3D11 */\n\n#if defined(SOKOL_GLCORE)\n_SOKOL_PRIVATE void _sapp_wgl_init(void) {\n    _sapp.wgl.opengl32 = LoadLibraryA(\"opengl32.dll\");\n    if (!_sapp.wgl.opengl32) {\n        _SAPP_PANIC(WIN32_LOAD_OPENGL32_DLL_FAILED);\n    }\n    SOKOL_ASSERT(_sapp.wgl.opengl32);\n    _sapp.wgl.CreateContext = (PFN_wglCreateContext)(void*) GetProcAddress(_sapp.wgl.opengl32, \"wglCreateContext\");\n    SOKOL_ASSERT(_sapp.wgl.CreateContext);\n    _sapp.wgl.DeleteContext = (PFN_wglDeleteContext)(void*) GetProcAddress(_sapp.wgl.opengl32, \"wglDeleteContext\");\n    SOKOL_ASSERT(_sapp.wgl.DeleteContext);\n    _sapp.wgl.GetProcAddress = (PFN_wglGetProcAddress)(void*) GetProcAddress(_sapp.wgl.opengl32, \"wglGetProcAddress\");\n    SOKOL_ASSERT(_sapp.wgl.GetProcAddress);\n    _sapp.wgl.GetCurrentDC = (PFN_wglGetCurrentDC)(void*) GetProcAddress(_sapp.wgl.opengl32, \"wglGetCurrentDC\");\n    SOKOL_ASSERT(_sapp.wgl.GetCurrentDC);\n    _sapp.wgl.MakeCurrent = (PFN_wglMakeCurrent)(void*) GetProcAddress(_sapp.wgl.opengl32, \"wglMakeCurrent\");\n    SOKOL_ASSERT(_sapp.wgl.MakeCurrent);\n    _sapp.wgl.GetIntegerv = (void(WINAPI*)(uint32_t, int32_t*)) GetProcAddress(_sapp.wgl.opengl32, \"glGetIntegerv\");\n    SOKOL_ASSERT(_sapp.wgl.GetIntegerv);\n\n    _sapp.wgl.msg_hwnd = CreateWindowExW(WS_EX_OVERLAPPEDWINDOW,\n        L\"SOKOLAPP\",\n        L\"sokol-app message window\",\n        WS_CLIPSIBLINGS|WS_CLIPCHILDREN,\n        0, 0, 1, 1,\n        NULL, NULL,\n        GetModuleHandleW(NULL),\n        NULL);\n    if (!_sapp.wgl.msg_hwnd) {\n        _SAPP_PANIC(WIN32_CREATE_HELPER_WINDOW_FAILED);\n    }\n    SOKOL_ASSERT(_sapp.wgl.msg_hwnd);\n    ShowWindow(_sapp.wgl.msg_hwnd, SW_HIDE);\n    MSG msg;\n    while (PeekMessageW(&msg, _sapp.wgl.msg_hwnd, 0, 0, PM_REMOVE)) {\n        TranslateMessage(&msg);\n        DispatchMessageW(&msg);\n    }\n    _sapp.wgl.msg_dc = GetDC(_sapp.wgl.msg_hwnd);\n    if (!_sapp.wgl.msg_dc) {\n        _SAPP_PANIC(WIN32_HELPER_WINDOW_GETDC_FAILED);\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_wgl_shutdown(void) {\n    SOKOL_ASSERT(_sapp.wgl.opengl32 && _sapp.wgl.msg_hwnd);\n    DestroyWindow(_sapp.wgl.msg_hwnd); _sapp.wgl.msg_hwnd = 0;\n    FreeLibrary(_sapp.wgl.opengl32); _sapp.wgl.opengl32 = 0;\n}\n\n_SOKOL_PRIVATE bool _sapp_wgl_has_ext(const char* ext, const char* extensions) {\n    SOKOL_ASSERT(ext && extensions);\n    const char* start = extensions;\n    while (true) {\n        const char* where = strstr(start, ext);\n        if (!where) {\n            return false;\n        }\n        const char* terminator = where + strlen(ext);\n        if ((where == start) || (*(where - 1) == ' ')) {\n            if (*terminator == ' ' || *terminator == '\\0') {\n                break;\n            }\n        }\n        start = terminator;\n    }\n    return true;\n}\n\n_SOKOL_PRIVATE bool _sapp_wgl_ext_supported(const char* ext) {\n    SOKOL_ASSERT(ext);\n    if (_sapp.wgl.GetExtensionsStringEXT) {\n        const char* extensions = _sapp.wgl.GetExtensionsStringEXT();\n        if (extensions) {\n            if (_sapp_wgl_has_ext(ext, extensions)) {\n                return true;\n            }\n        }\n    }\n    if (_sapp.wgl.GetExtensionsStringARB) {\n        const char* extensions = _sapp.wgl.GetExtensionsStringARB(_sapp.wgl.GetCurrentDC());\n        if (extensions) {\n            if (_sapp_wgl_has_ext(ext, extensions)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n_SOKOL_PRIVATE void _sapp_wgl_load_extensions(void) {\n    SOKOL_ASSERT(_sapp.wgl.msg_dc);\n    PIXELFORMATDESCRIPTOR pfd;\n    _sapp_clear(&pfd, sizeof(pfd));\n    pfd.nSize = sizeof(pfd);\n    pfd.nVersion = 1;\n    pfd.dwFlags = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER;\n    pfd.iPixelType = PFD_TYPE_RGBA;\n    pfd.cColorBits = 24;\n    if (!SetPixelFormat(_sapp.wgl.msg_dc, ChoosePixelFormat(_sapp.wgl.msg_dc, &pfd), &pfd)) {\n        _SAPP_PANIC(WIN32_DUMMY_CONTEXT_SET_PIXELFORMAT_FAILED);\n    }\n    HGLRC rc = _sapp.wgl.CreateContext(_sapp.wgl.msg_dc);\n    if (!rc) {\n        _SAPP_PANIC(WIN32_CREATE_DUMMY_CONTEXT_FAILED);\n    }\n    if (!_sapp.wgl.MakeCurrent(_sapp.wgl.msg_dc, rc)) {\n        _SAPP_PANIC(WIN32_DUMMY_CONTEXT_MAKE_CURRENT_FAILED);\n    }\n    _sapp.wgl.GetExtensionsStringEXT = (PFNWGLGETEXTENSIONSSTRINGEXTPROC)(void*) _sapp.wgl.GetProcAddress(\"wglGetExtensionsStringEXT\");\n    _sapp.wgl.GetExtensionsStringARB = (PFNWGLGETEXTENSIONSSTRINGARBPROC)(void*) _sapp.wgl.GetProcAddress(\"wglGetExtensionsStringARB\");\n    _sapp.wgl.CreateContextAttribsARB = (PFNWGLCREATECONTEXTATTRIBSARBPROC)(void*) _sapp.wgl.GetProcAddress(\"wglCreateContextAttribsARB\");\n    _sapp.wgl.SwapIntervalEXT = (PFNWGLSWAPINTERVALEXTPROC)(void*) _sapp.wgl.GetProcAddress(\"wglSwapIntervalEXT\");\n    _sapp.wgl.GetPixelFormatAttribivARB = (PFNWGLGETPIXELFORMATATTRIBIVARBPROC)(void*) _sapp.wgl.GetProcAddress(\"wglGetPixelFormatAttribivARB\");\n    _sapp.wgl.arb_multisample = _sapp_wgl_ext_supported(\"WGL_ARB_multisample\");\n    _sapp.wgl.arb_create_context = _sapp_wgl_ext_supported(\"WGL_ARB_create_context\");\n    _sapp.wgl.arb_create_context_profile = _sapp_wgl_ext_supported(\"WGL_ARB_create_context_profile\");\n    _sapp.wgl.ext_swap_control = _sapp_wgl_ext_supported(\"WGL_EXT_swap_control\");\n    _sapp.wgl.arb_pixel_format = _sapp_wgl_ext_supported(\"WGL_ARB_pixel_format\");\n    _sapp.wgl.MakeCurrent(_sapp.wgl.msg_dc, 0);\n    _sapp.wgl.DeleteContext(rc);\n}\n\n_SOKOL_PRIVATE int _sapp_wgl_attrib(int pixel_format, int attrib) {\n    SOKOL_ASSERT(_sapp.wgl.arb_pixel_format);\n    int value = 0;\n    if (!_sapp.wgl.GetPixelFormatAttribivARB(_sapp.win32.dc, pixel_format, 0, 1, &attrib, &value)) {\n        _SAPP_PANIC(WIN32_GET_PIXELFORMAT_ATTRIB_FAILED);\n    }\n    return value;\n}\n\n_SOKOL_PRIVATE void _sapp_wgl_attribiv(int pixel_format, int num_attribs, const int* attribs, int* results) {\n    SOKOL_ASSERT(_sapp.wgl.arb_pixel_format);\n    if (!_sapp.wgl.GetPixelFormatAttribivARB(_sapp.win32.dc, pixel_format, 0, num_attribs, attribs, results)) {\n        _SAPP_PANIC(WIN32_GET_PIXELFORMAT_ATTRIB_FAILED);\n    }\n}\n\n_SOKOL_PRIVATE int _sapp_wgl_find_pixel_format(void) {\n    SOKOL_ASSERT(_sapp.win32.dc);\n    SOKOL_ASSERT(_sapp.wgl.arb_pixel_format);\n\n    #define _sapp_wgl_num_query_tags (12)\n    const int query_tags[_sapp_wgl_num_query_tags] = {\n        WGL_SUPPORT_OPENGL_ARB,\n        WGL_DRAW_TO_WINDOW_ARB,\n        WGL_PIXEL_TYPE_ARB,\n        WGL_ACCELERATION_ARB,\n        WGL_DOUBLE_BUFFER_ARB,\n        WGL_RED_BITS_ARB,\n        WGL_GREEN_BITS_ARB,\n        WGL_BLUE_BITS_ARB,\n        WGL_ALPHA_BITS_ARB,\n        WGL_DEPTH_BITS_ARB,\n        WGL_STENCIL_BITS_ARB,\n        WGL_SAMPLES_ARB,\n    };\n    const int result_support_opengl_index = 0;\n    const int result_draw_to_window_index = 1;\n    const int result_pixel_type_index = 2;\n    const int result_acceleration_index = 3;\n    const int result_double_buffer_index = 4;\n    const int result_red_bits_index = 5;\n    const int result_green_bits_index = 6;\n    const int result_blue_bits_index = 7;\n    const int result_alpha_bits_index = 8;\n    const int result_depth_bits_index = 9;\n    const int result_stencil_bits_index = 10;\n    const int result_samples_index = 11;\n\n    int query_results[_sapp_wgl_num_query_tags] = {0};\n    // Drop the last item if multisample extension is not supported.\n    //  If in future querying with multiple extensions, will have to shuffle index values to have active extensions on the end.\n    int query_count = _sapp_wgl_num_query_tags;\n    if (!_sapp.wgl.arb_multisample) {\n        query_count = _sapp_wgl_num_query_tags - 1;\n    }\n\n    int native_count = _sapp_wgl_attrib(1, WGL_NUMBER_PIXEL_FORMATS_ARB);\n\n    _sapp_gl_fbconfig desired;\n    _sapp_gl_init_fbconfig(&desired);\n    desired.red_bits = 8;\n    desired.green_bits = 8;\n    desired.blue_bits = 8;\n    desired.alpha_bits = 8;\n    desired.depth_bits = 24;\n    desired.stencil_bits = 8;\n    desired.doublebuffer = true;\n    desired.samples = (_sapp.sample_count > 1) ? _sapp.sample_count : 0;\n\n    int pixel_format = 0;\n\n    _sapp_gl_fbselect fbselect;\n    _sapp_gl_init_fbselect(&fbselect);\n    for (int i = 0; i < native_count; i++) {\n        const int n = i + 1;\n        _sapp_wgl_attribiv(n, query_count, query_tags, query_results);\n\n        if (query_results[result_support_opengl_index] == 0\n            || query_results[result_draw_to_window_index] == 0\n            || query_results[result_pixel_type_index] != WGL_TYPE_RGBA_ARB\n            || query_results[result_acceleration_index] == WGL_NO_ACCELERATION_ARB)\n        {\n            continue;\n        }\n\n        _sapp_gl_fbconfig u;\n        _sapp_clear(&u, sizeof(u));\n        u.red_bits     = query_results[result_red_bits_index];\n        u.green_bits   = query_results[result_green_bits_index];\n        u.blue_bits    = query_results[result_blue_bits_index];\n        u.alpha_bits   = query_results[result_alpha_bits_index];\n        u.depth_bits   = query_results[result_depth_bits_index];\n        u.stencil_bits = query_results[result_stencil_bits_index];\n        u.doublebuffer = 0 != query_results[result_double_buffer_index];\n        u.samples = query_results[result_samples_index]; // NOTE: If arb_multisample is not supported  - just takes the default 0\n\n        // Test if this pixel format is better than the previous one\n        if (_sapp_gl_select_fbconfig(&fbselect, &desired, &u)) {\n            pixel_format = (uintptr_t)n;\n\n            // Early exit if matching as good as possible\n            if (fbselect.best_match) {\n                break;\n            }\n        }\n    }\n\n    return pixel_format;\n}\n\n_SOKOL_PRIVATE void _sapp_wgl_create_context(void) {\n    int pixel_format = _sapp_wgl_find_pixel_format();\n    if (0 == pixel_format) {\n        _SAPP_PANIC(WIN32_WGL_FIND_PIXELFORMAT_FAILED);\n    }\n    PIXELFORMATDESCRIPTOR pfd;\n    if (!DescribePixelFormat(_sapp.win32.dc, pixel_format, sizeof(pfd), &pfd)) {\n        _SAPP_PANIC(WIN32_WGL_DESCRIBE_PIXELFORMAT_FAILED);\n    }\n    if (!SetPixelFormat(_sapp.win32.dc, pixel_format, &pfd)) {\n        _SAPP_PANIC(WIN32_WGL_SET_PIXELFORMAT_FAILED);\n    }\n    if (!_sapp.wgl.arb_create_context) {\n        _SAPP_PANIC(WIN32_WGL_ARB_CREATE_CONTEXT_REQUIRED);\n    }\n    if (!_sapp.wgl.arb_create_context_profile) {\n        _SAPP_PANIC(WIN32_WGL_ARB_CREATE_CONTEXT_PROFILE_REQUIRED);\n    }\n    const int attrs[] = {\n        WGL_CONTEXT_MAJOR_VERSION_ARB, _sapp.desc.gl_major_version,\n        WGL_CONTEXT_MINOR_VERSION_ARB, _sapp.desc.gl_minor_version,\n#if defined(SOKOL_DEBUG)\n        WGL_CONTEXT_FLAGS_ARB, WGL_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB | WGL_CONTEXT_DEBUG_BIT_ARB,\n#else\n        WGL_CONTEXT_FLAGS_ARB, WGL_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB,\n#endif\n        WGL_CONTEXT_PROFILE_MASK_ARB, WGL_CONTEXT_CORE_PROFILE_BIT_ARB,\n        0, 0\n    };\n    _sapp.wgl.gl_ctx = _sapp.wgl.CreateContextAttribsARB(_sapp.win32.dc, 0, attrs);\n    if (!_sapp.wgl.gl_ctx) {\n        const DWORD err = GetLastError();\n        if (err == (0xc0070000 | ERROR_INVALID_VERSION_ARB)) {\n            _SAPP_PANIC(WIN32_WGL_OPENGL_VERSION_NOT_SUPPORTED);\n        }\n        else if (err == (0xc0070000 | ERROR_INVALID_PROFILE_ARB)) {\n            _SAPP_PANIC(WIN32_WGL_OPENGL_PROFILE_NOT_SUPPORTED);\n        }\n        else if (err == (0xc0070000 | ERROR_INCOMPATIBLE_DEVICE_CONTEXTS_ARB)) {\n            _SAPP_PANIC(WIN32_WGL_INCOMPATIBLE_DEVICE_CONTEXT);\n        }\n        else {\n            _SAPP_PANIC(WIN32_WGL_CREATE_CONTEXT_ATTRIBS_FAILED_OTHER);\n        }\n    }\n    _sapp.wgl.MakeCurrent(_sapp.win32.dc, _sapp.wgl.gl_ctx);\n    if (_sapp.wgl.ext_swap_control) {\n        /* FIXME: DwmIsCompositionEnabled() (see GLFW) */\n        _sapp.wgl.SwapIntervalEXT(_sapp.swap_interval);\n    }\n    const uint32_t gl_framebuffer_binding = 0x8CA6;\n    _sapp.wgl.GetIntegerv(gl_framebuffer_binding, (int32_t*)&_sapp.gl.framebuffer);\n}\n\n_SOKOL_PRIVATE void _sapp_wgl_destroy_context(void) {\n    SOKOL_ASSERT(_sapp.wgl.gl_ctx);\n    _sapp.wgl.DeleteContext(_sapp.wgl.gl_ctx);\n    _sapp.wgl.gl_ctx = 0;\n}\n\n_SOKOL_PRIVATE void _sapp_wgl_swap_buffers(void) {\n    SOKOL_ASSERT(_sapp.win32.dc);\n    /* FIXME: DwmIsCompositionEnabled? (see GLFW) */\n    SwapBuffers(_sapp.win32.dc);\n}\n#endif /* SOKOL_GLCORE */\n\n_SOKOL_PRIVATE bool _sapp_win32_wide_to_utf8(const wchar_t* src, char* dst, int dst_num_bytes) {\n    SOKOL_ASSERT(src && dst && (dst_num_bytes > 1));\n    _sapp_clear(dst, (size_t)dst_num_bytes);\n    const int bytes_needed = WideCharToMultiByte(CP_UTF8, 0, src, -1, NULL, 0, NULL, NULL);\n    if (bytes_needed <= dst_num_bytes) {\n        WideCharToMultiByte(CP_UTF8, 0, src, -1, dst, dst_num_bytes, NULL, NULL);\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\n/* updates current window and framebuffer size from the window's client rect, returns true if size has changed */\n_SOKOL_PRIVATE bool _sapp_win32_update_dimensions(void) {\n    RECT rect;\n    if (GetClientRect(_sapp.win32.hwnd, &rect)) {\n        float window_width = (float)(rect.right - rect.left) / _sapp.win32.dpi.window_scale;\n        float window_height = (float)(rect.bottom - rect.top) / _sapp.win32.dpi.window_scale;\n        _sapp.window_width = (int)roundf(window_width);\n        _sapp.window_height = (int)roundf(window_height);\n        int fb_width = (int)roundf(window_width * _sapp.win32.dpi.content_scale);\n        int fb_height = (int)roundf(window_height * _sapp.win32.dpi.content_scale);\n        /* prevent a framebuffer size of 0 when window is minimized */\n        if (0 == fb_width) {\n            fb_width = 1;\n        }\n        if (0 == fb_height) {\n            fb_height = 1;\n        }\n        if ((fb_width != _sapp.framebuffer_width) || (fb_height != _sapp.framebuffer_height)) {\n            _sapp.framebuffer_width = fb_width;\n            _sapp.framebuffer_height = fb_height;\n            return true;\n        }\n    }\n    else {\n        _sapp.window_width = _sapp.window_height = 1;\n        _sapp.framebuffer_width = _sapp.framebuffer_height = 1;\n    }\n    return false;\n}\n\n_SOKOL_PRIVATE void _sapp_win32_set_fullscreen(bool fullscreen, UINT swp_flags) {\n    HMONITOR monitor = MonitorFromWindow(_sapp.win32.hwnd, MONITOR_DEFAULTTONEAREST);\n    MONITORINFO minfo;\n    _sapp_clear(&minfo, sizeof(minfo));\n    minfo.cbSize = sizeof(MONITORINFO);\n    GetMonitorInfo(monitor, &minfo);\n    const RECT mr = minfo.rcMonitor;\n    const int monitor_w = mr.right - mr.left;\n    const int monitor_h = mr.bottom - mr.top;\n\n    const DWORD win_ex_style = WS_EX_APPWINDOW | WS_EX_WINDOWEDGE;\n    DWORD win_style;\n    RECT rect = { 0, 0, 0, 0 };\n\n    _sapp.fullscreen = fullscreen;\n    if (!_sapp.fullscreen) {\n        win_style = WS_CLIPSIBLINGS | WS_CLIPCHILDREN | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX | WS_MAXIMIZEBOX | WS_SIZEBOX;\n        rect = _sapp.win32.stored_window_rect;\n    }\n    else {\n        GetWindowRect(_sapp.win32.hwnd, &_sapp.win32.stored_window_rect);\n        win_style = WS_POPUP | WS_SYSMENU | WS_VISIBLE;\n        rect.left = mr.left;\n        rect.top = mr.top;\n        rect.right = rect.left + monitor_w;\n        rect.bottom = rect.top + monitor_h;\n        AdjustWindowRectEx(&rect, win_style, FALSE, win_ex_style);\n    }\n    const int win_w = rect.right - rect.left;\n    const int win_h = rect.bottom - rect.top;\n    const int win_x = rect.left;\n    const int win_y = rect.top;\n    SetWindowLongPtr(_sapp.win32.hwnd, GWL_STYLE, win_style);\n    SetWindowPos(_sapp.win32.hwnd, HWND_TOP, win_x, win_y, win_w, win_h, swp_flags | SWP_FRAMECHANGED);\n}\n\n_SOKOL_PRIVATE void _sapp_win32_toggle_fullscreen(void) {\n    _sapp_win32_set_fullscreen(!_sapp.fullscreen, SWP_SHOWWINDOW);\n}\n\n_SOKOL_PRIVATE void _sapp_win32_init_cursor(sapp_mouse_cursor cursor) {\n    SOKOL_ASSERT((cursor >= 0) && (cursor < _SAPP_MOUSECURSOR_NUM));\n    // NOTE: the OCR_* constants are only defined if OEMRESOURCE is defined\n    // before windows.h is included, but we can't guarantee that because\n    // the sokol_app.h implementation may be included with other implementations\n    // in the same compilation unit\n    int id = 0;\n    switch (cursor) {\n        case SAPP_MOUSECURSOR_ARROW:            id = 32512; break;  // OCR_NORMAL\n        case SAPP_MOUSECURSOR_IBEAM:            id = 32513; break;  // OCR_IBEAM\n        case SAPP_MOUSECURSOR_CROSSHAIR:        id = 32515; break;  // OCR_CROSS\n        case SAPP_MOUSECURSOR_POINTING_HAND:    id = 32649; break;  // OCR_HAND\n        case SAPP_MOUSECURSOR_RESIZE_EW:        id = 32644; break;  // OCR_SIZEWE\n        case SAPP_MOUSECURSOR_RESIZE_NS:        id = 32645; break;  // OCR_SIZENS\n        case SAPP_MOUSECURSOR_RESIZE_NWSE:      id = 32642; break;  // OCR_SIZENWSE\n        case SAPP_MOUSECURSOR_RESIZE_NESW:      id = 32643; break;  // OCR_SIZENESW\n        case SAPP_MOUSECURSOR_RESIZE_ALL:       id = 32646; break;  // OCR_SIZEALL\n        case SAPP_MOUSECURSOR_NOT_ALLOWED:      id = 32648; break;  // OCR_NO\n        default: break;\n    }\n    if (id != 0) {\n        _sapp.win32.cursors[cursor] = (HCURSOR)LoadImageW(NULL, MAKEINTRESOURCEW(id), IMAGE_CURSOR, 0, 0, LR_DEFAULTSIZE|LR_SHARED);\n    }\n    // fallback: default cursor\n    if (0 == _sapp.win32.cursors[cursor]) {\n        // 32512 => IDC_ARROW\n        _sapp.win32.cursors[cursor] = LoadCursorW(NULL, MAKEINTRESOURCEW(32512));\n    }\n    SOKOL_ASSERT(0 != _sapp.win32.cursors[cursor]);\n}\n\n_SOKOL_PRIVATE void _sapp_win32_init_cursors(void) {\n    for (int i = 0; i < _SAPP_MOUSECURSOR_NUM; i++) {\n        _sapp_win32_init_cursor((sapp_mouse_cursor)i);\n    }\n}\n\n_SOKOL_PRIVATE bool _sapp_win32_cursor_in_content_area(void) {\n    POINT pos;\n    if (!GetCursorPos(&pos)) {\n        return false;\n    }\n    if (WindowFromPoint(pos) != _sapp.win32.hwnd) {\n        return false;\n    }\n    RECT area;\n    GetClientRect(_sapp.win32.hwnd, &area);\n    ClientToScreen(_sapp.win32.hwnd, (POINT*)&area.left);\n    ClientToScreen(_sapp.win32.hwnd, (POINT*)&area.right);\n    return PtInRect(&area, pos) == TRUE;\n}\n\n_SOKOL_PRIVATE void _sapp_win32_update_cursor(sapp_mouse_cursor cursor, bool shown, bool skip_area_test) {\n    // NOTE: when called from WM_SETCURSOR, the area test would be redundant\n    if (!skip_area_test) {\n        if (!_sapp_win32_cursor_in_content_area()) {\n            return;\n        }\n    }\n    if (!shown) {\n        SetCursor(NULL);\n    }\n    else {\n        SOKOL_ASSERT((cursor >= 0) && (cursor < _SAPP_MOUSECURSOR_NUM));\n        SOKOL_ASSERT(0 != _sapp.win32.cursors[cursor]);\n        SetCursor(_sapp.win32.cursors[cursor]);\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_win32_capture_mouse(uint8_t btn_mask) {\n    if (0 == _sapp.win32.mouse_capture_mask) {\n        SetCapture(_sapp.win32.hwnd);\n    }\n    _sapp.win32.mouse_capture_mask |= btn_mask;\n}\n\n_SOKOL_PRIVATE void _sapp_win32_release_mouse(uint8_t btn_mask) {\n    if (0 != _sapp.win32.mouse_capture_mask) {\n        _sapp.win32.mouse_capture_mask &= ~btn_mask;\n        if (0 == _sapp.win32.mouse_capture_mask) {\n            ReleaseCapture();\n        }\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_win32_lock_mouse(bool lock) {\n    if (lock == _sapp.mouse.locked) {\n        return;\n    }\n    _sapp.mouse.dx = 0.0f;\n    _sapp.mouse.dy = 0.0f;\n    _sapp.mouse.locked = lock;\n    _sapp_win32_release_mouse(0xFF);\n    if (_sapp.mouse.locked) {\n        /* store the current mouse position, so it can be restored when unlocked */\n        POINT pos;\n        BOOL res = GetCursorPos(&pos);\n        SOKOL_ASSERT(res); _SOKOL_UNUSED(res);\n        _sapp.win32.mouse_locked_x = pos.x;\n        _sapp.win32.mouse_locked_y = pos.y;\n\n        /* while the mouse is locked, make the mouse cursor invisible and\n           confine the mouse movement to a small rectangle inside our window\n           (so that we don't miss any mouse up events)\n        */\n        RECT client_rect = {\n            _sapp.win32.mouse_locked_x,\n            _sapp.win32.mouse_locked_y,\n            _sapp.win32.mouse_locked_x,\n            _sapp.win32.mouse_locked_y\n        };\n        ClipCursor(&client_rect);\n\n        /* make the mouse cursor invisible, this will stack with sapp_show_mouse() */\n        ShowCursor(FALSE);\n\n        /* enable raw input for mouse, starts sending WM_INPUT messages to WinProc (see GLFW) */\n        const RAWINPUTDEVICE rid = {\n            0x01,   // usUsagePage: HID_USAGE_PAGE_GENERIC\n            0x02,   // usUsage: HID_USAGE_GENERIC_MOUSE\n            0,      // dwFlags\n            _sapp.win32.hwnd    // hwndTarget\n        };\n        if (!RegisterRawInputDevices(&rid, 1, sizeof(rid))) {\n            _SAPP_ERROR(WIN32_REGISTER_RAW_INPUT_DEVICES_FAILED_MOUSE_LOCK);\n        }\n        /* in case the raw mouse device only supports absolute position reporting,\n           we need to skip the dx/dy compution for the first WM_INPUT event\n        */\n        _sapp.win32.raw_input_mousepos_valid = false;\n    }\n    else {\n        /* disable raw input for mouse */\n        const RAWINPUTDEVICE rid = { 0x01, 0x02, RIDEV_REMOVE, NULL };\n        if (!RegisterRawInputDevices(&rid, 1, sizeof(rid))) {\n            _SAPP_ERROR(WIN32_REGISTER_RAW_INPUT_DEVICES_FAILED_MOUSE_UNLOCK);\n        }\n\n        /* let the mouse roam freely again */\n        ClipCursor(NULL);\n        ShowCursor(TRUE);\n\n        /* restore the 'pre-locked' mouse position */\n        BOOL res = SetCursorPos(_sapp.win32.mouse_locked_x, _sapp.win32.mouse_locked_y);\n        SOKOL_ASSERT(res); _SOKOL_UNUSED(res);\n    }\n}\n\n_SOKOL_PRIVATE bool _sapp_win32_update_monitor(void) {\n    const HMONITOR cur_monitor = MonitorFromWindow(_sapp.win32.hwnd, MONITOR_DEFAULTTONULL);\n    if (cur_monitor != _sapp.win32.hmonitor) {\n        _sapp.win32.hmonitor = cur_monitor;\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\n_SOKOL_PRIVATE uint32_t _sapp_win32_mods(void) {\n    uint32_t mods = 0;\n    if (GetKeyState(VK_SHIFT) & (1<<15)) {\n        mods |= SAPP_MODIFIER_SHIFT;\n    }\n    if (GetKeyState(VK_CONTROL) & (1<<15)) {\n        mods |= SAPP_MODIFIER_CTRL;\n    }\n    if (GetKeyState(VK_MENU) & (1<<15)) {\n        mods |= SAPP_MODIFIER_ALT;\n    }\n    if ((GetKeyState(VK_LWIN) | GetKeyState(VK_RWIN)) & (1<<15)) {\n        mods |= SAPP_MODIFIER_SUPER;\n    }\n    const bool swapped = (TRUE == GetSystemMetrics(SM_SWAPBUTTON));\n    if (GetAsyncKeyState(VK_LBUTTON)) {\n        mods |= swapped ? SAPP_MODIFIER_RMB : SAPP_MODIFIER_LMB;\n    }\n    if (GetAsyncKeyState(VK_RBUTTON)) {\n        mods |= swapped ? SAPP_MODIFIER_LMB : SAPP_MODIFIER_RMB;\n    }\n    if (GetAsyncKeyState(VK_MBUTTON)) {\n        mods |= SAPP_MODIFIER_MMB;\n    }\n    return mods;\n}\n\n_SOKOL_PRIVATE void _sapp_win32_mouse_update(LPARAM lParam) {\n    if (!_sapp.mouse.locked) {\n        const float new_x  = (float)GET_X_LPARAM(lParam) * _sapp.win32.dpi.mouse_scale;\n        const float new_y = (float)GET_Y_LPARAM(lParam) * _sapp.win32.dpi.mouse_scale;\n        if (_sapp.mouse.pos_valid) {\n            // don't update dx/dy in the very first event\n            _sapp.mouse.dx = new_x - _sapp.mouse.x;\n            _sapp.mouse.dy = new_y - _sapp.mouse.y;\n        }\n        _sapp.mouse.x = new_x;\n        _sapp.mouse.y = new_y;\n        _sapp.mouse.pos_valid = true;\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_win32_mouse_event(sapp_event_type type, sapp_mousebutton btn) {\n    if (_sapp_events_enabled()) {\n        _sapp_init_event(type);\n        _sapp.event.modifiers = _sapp_win32_mods();\n        _sapp.event.mouse_button = btn;\n        _sapp_call_event(&_sapp.event);\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_win32_scroll_event(float x, float y) {\n    if (_sapp_events_enabled()) {\n        _sapp_init_event(SAPP_EVENTTYPE_MOUSE_SCROLL);\n        _sapp.event.modifiers = _sapp_win32_mods();\n        _sapp.event.scroll_x = -x / 30.0f;\n        _sapp.event.scroll_y = y / 30.0f;\n        _sapp_call_event(&_sapp.event);\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_win32_key_event(sapp_event_type type, int vk, bool repeat) {\n    if (_sapp_events_enabled() && (vk < SAPP_MAX_KEYCODES)) {\n        _sapp_init_event(type);\n        _sapp.event.modifiers = _sapp_win32_mods();\n        _sapp.event.key_code = _sapp.keycodes[vk];\n        _sapp.event.key_repeat = repeat;\n        _sapp_call_event(&_sapp.event);\n        /* check if a CLIPBOARD_PASTED event must be sent too */\n        if (_sapp.clipboard.enabled &&\n            (type == SAPP_EVENTTYPE_KEY_DOWN) &&\n            (_sapp.event.modifiers == SAPP_MODIFIER_CTRL) &&\n            (_sapp.event.key_code == SAPP_KEYCODE_V))\n        {\n            _sapp_init_event(SAPP_EVENTTYPE_CLIPBOARD_PASTED);\n            _sapp_call_event(&_sapp.event);\n        }\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_win32_char_event(uint32_t c, bool repeat) {\n    if (_sapp_events_enabled() && (c >= 32)) {\n        _sapp_init_event(SAPP_EVENTTYPE_CHAR);\n        _sapp.event.modifiers = _sapp_win32_mods();\n        _sapp.event.char_code = c;\n        _sapp.event.key_repeat = repeat;\n        _sapp_call_event(&_sapp.event);\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_win32_dpi_changed(HWND hWnd, LPRECT proposed_win_rect) {\n    /* called on WM_DPICHANGED, which will only be sent to the application\n        if sapp_desc.high_dpi is true and the Windows version is recent enough\n        to support DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2\n    */\n    SOKOL_ASSERT(_sapp.desc.high_dpi);\n    HINSTANCE user32 = LoadLibraryA(\"user32.dll\");\n    if (!user32) {\n        return;\n    }\n    typedef UINT(WINAPI * GETDPIFORWINDOW_T)(HWND hwnd);\n    GETDPIFORWINDOW_T fn_getdpiforwindow = (GETDPIFORWINDOW_T)(void*)GetProcAddress(user32, \"GetDpiForWindow\");\n    if (fn_getdpiforwindow) {\n        UINT dpix = fn_getdpiforwindow(_sapp.win32.hwnd);\n        // NOTE: for high-dpi apps, mouse_scale remains one\n        _sapp.win32.dpi.window_scale = (float)dpix / 96.0f;\n        _sapp.win32.dpi.content_scale = _sapp.win32.dpi.window_scale;\n        _sapp.dpi_scale = _sapp.win32.dpi.window_scale;\n        SetWindowPos(hWnd, 0,\n            proposed_win_rect->left,\n            proposed_win_rect->top,\n            proposed_win_rect->right - proposed_win_rect->left,\n            proposed_win_rect->bottom - proposed_win_rect->top,\n            SWP_NOZORDER | SWP_NOACTIVATE);\n    }\n    FreeLibrary(user32);\n}\n\n_SOKOL_PRIVATE void _sapp_win32_files_dropped(HDROP hdrop) {\n    if (!_sapp.drop.enabled) {\n        return;\n    }\n    _sapp_clear_drop_buffer();\n    bool drop_failed = false;\n    const int count = (int) DragQueryFileW(hdrop, 0xffffffff, NULL, 0);\n    _sapp.drop.num_files = (count > _sapp.drop.max_files) ? _sapp.drop.max_files : count;\n    for (UINT i = 0;  i < (UINT)_sapp.drop.num_files;  i++) {\n        const UINT num_chars = DragQueryFileW(hdrop, i, NULL, 0) + 1;\n        WCHAR* buffer = (WCHAR*) _sapp_malloc_clear(num_chars * sizeof(WCHAR));\n        DragQueryFileW(hdrop, i, buffer, num_chars);\n        if (!_sapp_win32_wide_to_utf8(buffer, _sapp_dropped_file_path_ptr((int)i), _sapp.drop.max_path_length)) {\n            _SAPP_ERROR(DROPPED_FILE_PATH_TOO_LONG);\n            drop_failed = true;\n        }\n        _sapp_free(buffer);\n    }\n    DragFinish(hdrop);\n    if (!drop_failed) {\n        if (_sapp_events_enabled()) {\n            _sapp_init_event(SAPP_EVENTTYPE_FILES_DROPPED);\n            _sapp.event.modifiers = _sapp_win32_mods();\n            _sapp_call_event(&_sapp.event);\n        }\n    }\n    else {\n        _sapp_clear_drop_buffer();\n        _sapp.drop.num_files = 0;\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_win32_timing_measure(void) {\n    #if defined(SOKOL_D3D11)\n        // on D3D11, use the more precise DXGI timestamp\n        if (_sapp.d3d11.use_dxgi_frame_stats) {\n            DXGI_FRAME_STATISTICS dxgi_stats;\n            _sapp_clear(&dxgi_stats, sizeof(dxgi_stats));\n            HRESULT hr = _sapp_dxgi_GetFrameStatistics(_sapp.d3d11.swap_chain, &dxgi_stats);\n            if (SUCCEEDED(hr)) {\n                if (dxgi_stats.SyncRefreshCount != _sapp.d3d11.sync_refresh_count) {\n                    if ((_sapp.d3d11.sync_refresh_count + 1) != dxgi_stats.SyncRefreshCount) {\n                        _sapp_timing_discontinuity(&_sapp.timing);\n                    }\n                    _sapp.d3d11.sync_refresh_count = dxgi_stats.SyncRefreshCount;\n                    LARGE_INTEGER qpc = dxgi_stats.SyncQPCTime;\n                    const uint64_t now = (uint64_t)_sapp_int64_muldiv(qpc.QuadPart - _sapp.timing.timestamp.win.start.QuadPart, 1000000000, _sapp.timing.timestamp.win.freq.QuadPart);\n                    _sapp_timing_external(&_sapp.timing, (double)now / 1000000000.0);\n                }\n                return;\n            }\n        }\n        // fallback if swap model isn't \"flip-discard\" or GetFrameStatistics failed for another reason\n        _sapp_timing_measure(&_sapp.timing);\n    #endif\n    #if defined(SOKOL_GLCORE)\n        _sapp_timing_measure(&_sapp.timing);\n    #endif\n    #if defined(SOKOL_NOAPI)\n        _sapp_timing_measure(&_sapp.timing);\n    #endif\n}\n\n_SOKOL_PRIVATE LRESULT CALLBACK _sapp_win32_wndproc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {\n    if (!_sapp.win32.in_create_window) {\n        switch (uMsg) {\n            case WM_CLOSE:\n                /* only give user a chance to intervene when sapp_quit() wasn't already called */\n                if (!_sapp.quit_ordered) {\n                    /* if window should be closed and event handling is enabled, give user code\n                        a change to intervene via sapp_cancel_quit()\n                    */\n                    _sapp.quit_requested = true;\n                    _sapp_win32_app_event(SAPP_EVENTTYPE_QUIT_REQUESTED);\n                    /* if user code hasn't intervened, quit the app */\n                    if (_sapp.quit_requested) {\n                        _sapp.quit_ordered = true;\n                    }\n                }\n                if (_sapp.quit_ordered) {\n                    PostQuitMessage(0);\n                }\n                return 0;\n            case WM_SYSCOMMAND:\n                switch (wParam & 0xFFF0) {\n                    case SC_SCREENSAVE:\n                    case SC_MONITORPOWER:\n                        if (_sapp.fullscreen) {\n                            /* disable screen saver and blanking in fullscreen mode */\n                            return 0;\n                        }\n                        break;\n                    case SC_KEYMENU:\n                        /* user trying to access menu via ALT */\n                        return 0;\n                }\n                break;\n            case WM_ERASEBKGND:\n                return 1;\n            case WM_SIZE:\n                {\n                    const bool iconified = wParam == SIZE_MINIMIZED;\n                    if (iconified != _sapp.win32.iconified) {\n                        _sapp.win32.iconified = iconified;\n                        if (iconified) {\n                            _sapp_win32_app_event(SAPP_EVENTTYPE_ICONIFIED);\n                        }\n                        else {\n                            _sapp_win32_app_event(SAPP_EVENTTYPE_RESTORED);\n                        }\n                    }\n                }\n                break;\n            case WM_SETFOCUS:\n                _sapp_win32_app_event(SAPP_EVENTTYPE_FOCUSED);\n                break;\n            case WM_KILLFOCUS:\n                /* if focus is lost for any reason, and we're in mouse locked mode, disable mouse lock */\n                if (_sapp.mouse.locked) {\n                    _sapp_win32_lock_mouse(false);\n                }\n                _sapp_win32_app_event(SAPP_EVENTTYPE_UNFOCUSED);\n                break;\n            case WM_SETCURSOR:\n                if (LOWORD(lParam) == HTCLIENT) {\n                    _sapp_win32_update_cursor(_sapp.mouse.current_cursor, _sapp.mouse.shown, true);\n                    return TRUE;\n                }\n                break;\n            case WM_DPICHANGED:\n            {\n                /* Update window's DPI and size if its moved to another monitor with a different DPI\n                   Only sent if DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2 is used.\n                */\n                _sapp_win32_dpi_changed(hWnd, (LPRECT)lParam);\n                break;\n            }\n            case WM_LBUTTONDOWN:\n                _sapp_win32_mouse_update(lParam);\n                _sapp_win32_mouse_event(SAPP_EVENTTYPE_MOUSE_DOWN, SAPP_MOUSEBUTTON_LEFT);\n                _sapp_win32_capture_mouse(1<<SAPP_MOUSEBUTTON_LEFT);\n                break;\n            case WM_RBUTTONDOWN:\n                _sapp_win32_mouse_update(lParam);\n                _sapp_win32_mouse_event(SAPP_EVENTTYPE_MOUSE_DOWN, SAPP_MOUSEBUTTON_RIGHT);\n                _sapp_win32_capture_mouse(1<<SAPP_MOUSEBUTTON_RIGHT);\n                break;\n            case WM_MBUTTONDOWN:\n                _sapp_win32_mouse_update(lParam);\n                _sapp_win32_mouse_event(SAPP_EVENTTYPE_MOUSE_DOWN, SAPP_MOUSEBUTTON_MIDDLE);\n                _sapp_win32_capture_mouse(1<<SAPP_MOUSEBUTTON_MIDDLE);\n                break;\n            case WM_LBUTTONUP:\n                _sapp_win32_mouse_update(lParam);\n                _sapp_win32_mouse_event(SAPP_EVENTTYPE_MOUSE_UP, SAPP_MOUSEBUTTON_LEFT);\n                _sapp_win32_release_mouse(1<<SAPP_MOUSEBUTTON_LEFT);\n                break;\n            case WM_RBUTTONUP:\n                _sapp_win32_mouse_update(lParam);\n                _sapp_win32_mouse_event(SAPP_EVENTTYPE_MOUSE_UP, SAPP_MOUSEBUTTON_RIGHT);\n                _sapp_win32_release_mouse(1<<SAPP_MOUSEBUTTON_RIGHT);\n                break;\n            case WM_MBUTTONUP:\n                _sapp_win32_mouse_update(lParam);\n                _sapp_win32_mouse_event(SAPP_EVENTTYPE_MOUSE_UP, SAPP_MOUSEBUTTON_MIDDLE);\n                _sapp_win32_release_mouse(1<<SAPP_MOUSEBUTTON_MIDDLE);\n                break;\n            case WM_MOUSEMOVE:\n                if (!_sapp.mouse.locked) {\n                    _sapp_win32_mouse_update(lParam);\n                    if (!_sapp.win32.mouse_tracked) {\n                        _sapp.win32.mouse_tracked = true;\n                        TRACKMOUSEEVENT tme;\n                        _sapp_clear(&tme, sizeof(tme));\n                        tme.cbSize = sizeof(tme);\n                        tme.dwFlags = TME_LEAVE;\n                        tme.hwndTrack = _sapp.win32.hwnd;\n                        TrackMouseEvent(&tme);\n                        _sapp.mouse.dx = 0.0f;\n                        _sapp.mouse.dy = 0.0f;\n                        _sapp_win32_mouse_event(SAPP_EVENTTYPE_MOUSE_ENTER, SAPP_MOUSEBUTTON_INVALID);\n                    }\n                    _sapp_win32_mouse_event(SAPP_EVENTTYPE_MOUSE_MOVE, SAPP_MOUSEBUTTON_INVALID);\n                }\n                break;\n            case WM_INPUT:\n                /* raw mouse input during mouse-lock */\n                if (_sapp.mouse.locked) {\n                    HRAWINPUT ri = (HRAWINPUT) lParam;\n                    UINT size = sizeof(_sapp.win32.raw_input_data);\n                    // see: https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getrawinputdata\n                    if ((UINT)-1 == GetRawInputData(ri, RID_INPUT, &_sapp.win32.raw_input_data, &size, sizeof(RAWINPUTHEADER))) {\n                        _SAPP_ERROR(WIN32_GET_RAW_INPUT_DATA_FAILED);\n                        break;\n                    }\n                    const RAWINPUT* raw_mouse_data = (const RAWINPUT*) &_sapp.win32.raw_input_data;\n                    if (raw_mouse_data->data.mouse.usFlags & MOUSE_MOVE_ABSOLUTE) {\n                        /* mouse only reports absolute position\n                           NOTE: This code is untested and will most likely behave wrong in Remote Desktop sessions.\n                           (such remote desktop sessions are setting the MOUSE_MOVE_ABSOLUTE flag).\n                           See: https://github.com/floooh/sokol/issues/806 and\n                           https://github.com/microsoft/DirectXTK/commit/ef56b63f3739381e451f7a5a5bd2c9779d2a7555)\n                        */\n                        LONG new_x = raw_mouse_data->data.mouse.lLastX;\n                        LONG new_y = raw_mouse_data->data.mouse.lLastY;\n                        if (_sapp.win32.raw_input_mousepos_valid) {\n                            _sapp.mouse.dx = (float) (new_x - _sapp.win32.raw_input_mousepos_x);\n                            _sapp.mouse.dy = (float) (new_y - _sapp.win32.raw_input_mousepos_y);\n                        }\n                        _sapp.win32.raw_input_mousepos_x = new_x;\n                        _sapp.win32.raw_input_mousepos_y = new_y;\n                        _sapp.win32.raw_input_mousepos_valid = true;\n                    }\n                    else {\n                        /* mouse reports movement delta (this seems to be the common case) */\n                        _sapp.mouse.dx = (float) raw_mouse_data->data.mouse.lLastX;\n                        _sapp.mouse.dy = (float) raw_mouse_data->data.mouse.lLastY;\n                    }\n                    _sapp_win32_mouse_event(SAPP_EVENTTYPE_MOUSE_MOVE, SAPP_MOUSEBUTTON_INVALID);\n                }\n                break;\n\n            case WM_MOUSELEAVE:\n                if (!_sapp.mouse.locked) {\n                    _sapp.mouse.dx = 0.0f;\n                    _sapp.mouse.dy = 0.0f;\n                    _sapp.win32.mouse_tracked = false;\n                    _sapp_win32_mouse_event(SAPP_EVENTTYPE_MOUSE_LEAVE, SAPP_MOUSEBUTTON_INVALID);\n                }\n                break;\n            case WM_MOUSEWHEEL:\n                _sapp_win32_scroll_event(0.0f, (float)((SHORT)HIWORD(wParam)));\n                break;\n            case WM_MOUSEHWHEEL:\n                _sapp_win32_scroll_event((float)((SHORT)HIWORD(wParam)), 0.0f);\n                break;\n            case WM_CHAR:\n                _sapp_win32_char_event((uint32_t)wParam, !!(lParam&0x40000000));\n                break;\n            case WM_KEYDOWN:\n            case WM_SYSKEYDOWN:\n                _sapp_win32_key_event(SAPP_EVENTTYPE_KEY_DOWN, (int)(HIWORD(lParam)&0x1FF), !!(lParam&0x40000000));\n                break;\n            case WM_KEYUP:\n            case WM_SYSKEYUP:\n                _sapp_win32_key_event(SAPP_EVENTTYPE_KEY_UP, (int)(HIWORD(lParam)&0x1FF), false);\n                break;\n            case WM_ENTERSIZEMOVE:\n                SetTimer(_sapp.win32.hwnd, 1, USER_TIMER_MINIMUM, NULL);\n                break;\n            case WM_EXITSIZEMOVE:\n                KillTimer(_sapp.win32.hwnd, 1);\n                break;\n            case WM_TIMER:\n                _sapp_win32_timing_measure();\n                _sapp_frame();\n                #if defined(SOKOL_D3D11)\n                    // present with DXGI_PRESENT_DO_NOT_WAIT\n                    _sapp_d3d11_present(true);\n                #endif\n                #if defined(SOKOL_GLCORE)\n                    _sapp_wgl_swap_buffers();\n                #endif\n                /* NOTE: resizing the swap-chain during resize leads to a substantial\n                   memory spike (hundreds of megabytes for a few seconds).\n\n                if (_sapp_win32_update_dimensions()) {\n                    #if defined(SOKOL_D3D11)\n                    _sapp_d3d11_resize_default_render_target();\n                    #endif\n                    _sapp_win32_app_event(SAPP_EVENTTYPE_RESIZED);\n                }\n                */\n                break;\n            case WM_NCLBUTTONDOWN:\n                /* workaround for half-second pause when starting to move window\n                    see: https://gamedev.net/forums/topic/672094-keeping-things-moving-during-win32-moveresize-events/5254386/\n                */\n                if (SendMessage(_sapp.win32.hwnd, WM_NCHITTEST, wParam, lParam) == HTCAPTION) {\n                    POINT point = { 0, 0 };\n                    if (GetCursorPos(&point)) {\n                        ScreenToClient(_sapp.win32.hwnd, &point);\n                        PostMessage(_sapp.win32.hwnd, WM_MOUSEMOVE, 0, ((uint32_t)point.x)|(((uint32_t)point.y) << 16));\n                    }\n                }\n                break;\n            case WM_DROPFILES:\n                _sapp_win32_files_dropped((HDROP)wParam);\n                break;\n            case WM_DISPLAYCHANGE:\n                // refresh rate might have changed\n                _sapp_timing_reset(&_sapp.timing);\n                break;\n\n            default:\n                break;\n        }\n    }\n    return DefWindowProcW(hWnd, uMsg, wParam, lParam);\n}\n\n_SOKOL_PRIVATE void _sapp_win32_create_window(void) {\n    WNDCLASSW wndclassw;\n    _sapp_clear(&wndclassw, sizeof(wndclassw));\n    wndclassw.style = CS_HREDRAW | CS_VREDRAW | CS_OWNDC;\n    wndclassw.lpfnWndProc = (WNDPROC) _sapp_win32_wndproc;\n    wndclassw.hInstance = GetModuleHandleW(NULL);\n    wndclassw.hCursor = LoadCursor(NULL, IDC_ARROW);\n    wndclassw.hIcon = LoadIcon(NULL, IDI_WINLOGO);\n    wndclassw.lpszClassName = L\"SOKOLAPP\";\n    RegisterClassW(&wndclassw);\n\n    /* NOTE: regardless whether fullscreen is requested or not, a regular\n       windowed-mode window will always be created first (however in hidden\n       mode, so that no windowed-mode window pops up before the fullscreen window)\n    */\n    const DWORD win_ex_style = WS_EX_APPWINDOW | WS_EX_WINDOWEDGE;\n    RECT rect = { 0, 0, 0, 0 };\n    DWORD win_style = WS_CLIPSIBLINGS | WS_CLIPCHILDREN | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX | WS_MAXIMIZEBOX | WS_SIZEBOX;\n    rect.right = (int) ((float)_sapp.window_width * _sapp.win32.dpi.window_scale);\n    rect.bottom = (int) ((float)_sapp.window_height * _sapp.win32.dpi.window_scale);\n    const bool use_default_width = 0 == _sapp.window_width;\n    const bool use_default_height = 0 == _sapp.window_height;\n    AdjustWindowRectEx(&rect, win_style, FALSE, win_ex_style);\n    const int win_width = rect.right - rect.left;\n    const int win_height = rect.bottom - rect.top;\n    _sapp.win32.in_create_window = true;\n    _sapp.win32.hwnd = CreateWindowExW(\n        win_ex_style,               // dwExStyle\n        L\"SOKOLAPP\",                // lpClassName\n        _sapp.window_title_wide,    // lpWindowName\n        win_style,                  // dwStyle\n        CW_USEDEFAULT,              // X\n        SW_HIDE,                    // Y (NOTE: CW_USEDEFAULT is not used for position here, but internally calls ShowWindow!\n        use_default_width ? CW_USEDEFAULT : win_width, // nWidth\n        use_default_height ? CW_USEDEFAULT : win_height, // nHeight (NOTE: if width is CW_USEDEFAULT, height is actually ignored)\n        NULL,                       // hWndParent\n        NULL,                       // hMenu\n        GetModuleHandle(NULL),      // hInstance\n        NULL);                      // lParam\n    _sapp.win32.in_create_window = false;\n    _sapp.win32.dc = GetDC(_sapp.win32.hwnd);\n    _sapp.win32.hmonitor = MonitorFromWindow(_sapp.win32.hwnd, MONITOR_DEFAULTTONULL);\n    SOKOL_ASSERT(_sapp.win32.dc);\n\n    /* this will get the actual windowed-mode window size, if fullscreen\n       is requested, the set_fullscreen function will then capture the\n       current window rectangle, which then might be used later to\n       restore the window position when switching back to windowed\n    */\n    _sapp_win32_update_dimensions();\n    if (_sapp.fullscreen) {\n        _sapp_win32_set_fullscreen(_sapp.fullscreen, SWP_HIDEWINDOW);\n        _sapp_win32_update_dimensions();\n    }\n    ShowWindow(_sapp.win32.hwnd, SW_SHOW);\n    DragAcceptFiles(_sapp.win32.hwnd, 1);\n}\n\n_SOKOL_PRIVATE void _sapp_win32_destroy_window(void) {\n    DestroyWindow(_sapp.win32.hwnd); _sapp.win32.hwnd = 0;\n    UnregisterClassW(L\"SOKOLAPP\", GetModuleHandleW(NULL));\n}\n\n_SOKOL_PRIVATE void _sapp_win32_destroy_icons(void) {\n    if (_sapp.win32.big_icon) {\n        DestroyIcon(_sapp.win32.big_icon);\n        _sapp.win32.big_icon = 0;\n    }\n    if (_sapp.win32.small_icon) {\n        DestroyIcon(_sapp.win32.small_icon);\n        _sapp.win32.small_icon = 0;\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_win32_init_console(void) {\n    if (_sapp.desc.win32_console_create || _sapp.desc.win32_console_attach) {\n        BOOL con_valid = FALSE;\n        if (_sapp.desc.win32_console_create) {\n            con_valid = AllocConsole();\n        }\n        else if (_sapp.desc.win32_console_attach) {\n            con_valid = AttachConsole(ATTACH_PARENT_PROCESS);\n        }\n        if (con_valid) {\n            FILE* res_fp = 0;\n            errno_t err;\n            err = freopen_s(&res_fp, \"CON\", \"w\", stdout);\n            (void)err;\n            err = freopen_s(&res_fp, \"CON\", \"w\", stderr);\n            (void)err;\n        }\n    }\n    if (_sapp.desc.win32_console_utf8) {\n        _sapp.win32.orig_codepage = GetConsoleOutputCP();\n        SetConsoleOutputCP(CP_UTF8);\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_win32_restore_console(void) {\n    if (_sapp.desc.win32_console_utf8) {\n        SetConsoleOutputCP(_sapp.win32.orig_codepage);\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_win32_init_dpi(void) {\n\n    DECLARE_HANDLE(DPI_AWARENESS_CONTEXT_T);\n    typedef BOOL(WINAPI * SETPROCESSDPIAWARE_T)(void);\n    typedef bool (WINAPI * SETPROCESSDPIAWARENESSCONTEXT_T)(DPI_AWARENESS_CONTEXT_T); // since Windows 10, version 1703\n    typedef HRESULT(WINAPI * SETPROCESSDPIAWARENESS_T)(PROCESS_DPI_AWARENESS);\n    typedef HRESULT(WINAPI * GETDPIFORMONITOR_T)(HMONITOR, MONITOR_DPI_TYPE, UINT*, UINT*);\n\n    SETPROCESSDPIAWARE_T fn_setprocessdpiaware = 0;\n    SETPROCESSDPIAWARENESS_T fn_setprocessdpiawareness = 0;\n    GETDPIFORMONITOR_T fn_getdpiformonitor = 0;\n    SETPROCESSDPIAWARENESSCONTEXT_T fn_setprocessdpiawarenesscontext =0;\n\n    HINSTANCE user32 = LoadLibraryA(\"user32.dll\");\n    if (user32) {\n        fn_setprocessdpiaware = (SETPROCESSDPIAWARE_T)(void*) GetProcAddress(user32, \"SetProcessDPIAware\");\n        fn_setprocessdpiawarenesscontext = (SETPROCESSDPIAWARENESSCONTEXT_T)(void*) GetProcAddress(user32, \"SetProcessDpiAwarenessContext\");\n    }\n    HINSTANCE shcore = LoadLibraryA(\"shcore.dll\");\n    if (shcore) {\n        fn_setprocessdpiawareness = (SETPROCESSDPIAWARENESS_T)(void*) GetProcAddress(shcore, \"SetProcessDpiAwareness\");\n        fn_getdpiformonitor = (GETDPIFORMONITOR_T)(void*) GetProcAddress(shcore, \"GetDpiForMonitor\");\n    }\n    /*\n        NOTE on SetProcessDpiAware() vs SetProcessDpiAwareness() vs SetProcessDpiAwarenessContext():\n\n        These are different attempts to get DPI handling on Windows right, from oldest\n        to newest. SetProcessDpiAwarenessContext() is required for the new\n        DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2 method.\n    */\n    if (fn_setprocessdpiawareness) {\n        if (_sapp.desc.high_dpi) {\n            /* app requests HighDPI rendering, first try the Win10 Creator Update per-monitor-dpi awareness,\n               if that fails, fall back to system-dpi-awareness\n            */\n            _sapp.win32.dpi.aware = true;\n            DPI_AWARENESS_CONTEXT_T per_monitor_aware_v2 = (DPI_AWARENESS_CONTEXT_T)-4;\n            if (!(fn_setprocessdpiawarenesscontext && fn_setprocessdpiawarenesscontext(per_monitor_aware_v2))) {\n                // fallback to system-dpi-aware\n                fn_setprocessdpiawareness(PROCESS_SYSTEM_DPI_AWARE);\n            }\n        }\n        else {\n            /* if the app didn't request HighDPI rendering, let Windows do the upscaling */\n            _sapp.win32.dpi.aware = false;\n            fn_setprocessdpiawareness(PROCESS_DPI_UNAWARE);\n        }\n    }\n    else if (fn_setprocessdpiaware) {\n        // fallback for Windows 7\n        _sapp.win32.dpi.aware = true;\n        fn_setprocessdpiaware();\n    }\n    /* get dpi scale factor for main monitor */\n    if (fn_getdpiformonitor && _sapp.win32.dpi.aware) {\n        POINT pt = { 1, 1 };\n        HMONITOR hm = MonitorFromPoint(pt, MONITOR_DEFAULTTONEAREST);\n        UINT dpix, dpiy;\n        HRESULT hr = fn_getdpiformonitor(hm, MDT_EFFECTIVE_DPI, &dpix, &dpiy);\n        _SOKOL_UNUSED(hr);\n        SOKOL_ASSERT(SUCCEEDED(hr));\n        /* clamp window scale to an integer factor */\n        _sapp.win32.dpi.window_scale = (float)dpix / 96.0f;\n    }\n    else {\n        _sapp.win32.dpi.window_scale = 1.0f;\n    }\n    if (_sapp.desc.high_dpi) {\n        _sapp.win32.dpi.content_scale = _sapp.win32.dpi.window_scale;\n        _sapp.win32.dpi.mouse_scale = 1.0f;\n    }\n    else {\n        _sapp.win32.dpi.content_scale = 1.0f;\n        _sapp.win32.dpi.mouse_scale = 1.0f / _sapp.win32.dpi.window_scale;\n    }\n    _sapp.dpi_scale = _sapp.win32.dpi.content_scale;\n    if (user32) {\n        FreeLibrary(user32);\n    }\n    if (shcore) {\n        FreeLibrary(shcore);\n    }\n}\n\n_SOKOL_PRIVATE bool _sapp_win32_set_clipboard_string(const char* str) {\n    SOKOL_ASSERT(str);\n    SOKOL_ASSERT(_sapp.win32.hwnd);\n    SOKOL_ASSERT(_sapp.clipboard.enabled && (_sapp.clipboard.buf_size > 0));\n\n    if (!OpenClipboard(_sapp.win32.hwnd)) {\n        return false;\n    }\n\n    HANDLE object = 0;\n    wchar_t* wchar_buf = 0;\n\n    const SIZE_T wchar_buf_size = (SIZE_T)_sapp.clipboard.buf_size * sizeof(wchar_t);\n    object = GlobalAlloc(GMEM_MOVEABLE, wchar_buf_size);\n    if (NULL == object) {\n        goto error;\n    }\n    wchar_buf = (wchar_t*) GlobalLock(object);\n    if (NULL == wchar_buf) {\n        goto error;\n    }\n    if (!_sapp_win32_utf8_to_wide(str, wchar_buf, (int)wchar_buf_size)) {\n        goto error;\n    }\n    GlobalUnlock(object);\n    wchar_buf = 0;\n    EmptyClipboard();\n    // NOTE: when successful, SetClipboardData() takes ownership of memory object!\n    if (NULL == SetClipboardData(CF_UNICODETEXT, object)) {\n        goto error;\n    }\n    CloseClipboard();\n    return true;\n\nerror:\n    if (wchar_buf) {\n        GlobalUnlock(object);\n    }\n    if (object) {\n        GlobalFree(object);\n    }\n    CloseClipboard();\n    return false;\n}\n\n_SOKOL_PRIVATE const char* _sapp_win32_get_clipboard_string(void) {\n    SOKOL_ASSERT(_sapp.clipboard.enabled && _sapp.clipboard.buffer);\n    SOKOL_ASSERT(_sapp.win32.hwnd);\n    if (!OpenClipboard(_sapp.win32.hwnd)) {\n        /* silently ignore any errors and just return the current\n           content of the local clipboard buffer\n        */\n        return _sapp.clipboard.buffer;\n    }\n    HANDLE object = GetClipboardData(CF_UNICODETEXT);\n    if (!object) {\n        CloseClipboard();\n        return _sapp.clipboard.buffer;\n    }\n    const wchar_t* wchar_buf = (const wchar_t*) GlobalLock(object);\n    if (!wchar_buf) {\n        CloseClipboard();\n        return _sapp.clipboard.buffer;\n    }\n    if (!_sapp_win32_wide_to_utf8(wchar_buf, _sapp.clipboard.buffer, _sapp.clipboard.buf_size)) {\n        _SAPP_ERROR(CLIPBOARD_STRING_TOO_BIG);\n    }\n    GlobalUnlock(object);\n    CloseClipboard();\n    return _sapp.clipboard.buffer;\n}\n\n_SOKOL_PRIVATE void _sapp_win32_update_window_title(void) {\n    _sapp_win32_utf8_to_wide(_sapp.window_title, _sapp.window_title_wide, sizeof(_sapp.window_title_wide));\n    SetWindowTextW(_sapp.win32.hwnd, _sapp.window_title_wide);\n}\n\n_SOKOL_PRIVATE HICON _sapp_win32_create_icon_from_image(const sapp_image_desc* desc) {\n    BITMAPV5HEADER bi;\n    _sapp_clear(&bi, sizeof(bi));\n    bi.bV5Size = sizeof(bi);\n    bi.bV5Width = desc->width;\n    bi.bV5Height = -desc->height;   // NOTE the '-' here to indicate that origin is top-left\n    bi.bV5Planes = 1;\n    bi.bV5BitCount = 32;\n    bi.bV5Compression = BI_BITFIELDS;\n    bi.bV5RedMask = 0x00FF0000;\n    bi.bV5GreenMask = 0x0000FF00;\n    bi.bV5BlueMask = 0x000000FF;\n    bi.bV5AlphaMask = 0xFF000000;\n\n    uint8_t* target = 0;\n    const uint8_t* source = (const uint8_t*)desc->pixels.ptr;\n\n    HDC dc = GetDC(NULL);\n    HBITMAP color = CreateDIBSection(dc, (BITMAPINFO*)&bi, DIB_RGB_COLORS, (void**)&target, NULL, (DWORD)0);\n    ReleaseDC(NULL, dc);\n    if (0 == color) {\n        return NULL;\n    }\n    SOKOL_ASSERT(target);\n\n    HBITMAP mask = CreateBitmap(desc->width, desc->height, 1, 1, NULL);\n    if (0 == mask) {\n        DeleteObject(color);\n        return NULL;\n    }\n\n    for (int i = 0; i < (desc->width*desc->height); i++) {\n        target[0] = source[2];\n        target[1] = source[1];\n        target[2] = source[0];\n        target[3] = source[3];\n        target += 4;\n        source += 4;\n    }\n\n    ICONINFO icon_info;\n    _sapp_clear(&icon_info, sizeof(icon_info));\n    icon_info.fIcon = true;\n    icon_info.xHotspot = 0;\n    icon_info.yHotspot = 0;\n    icon_info.hbmMask = mask;\n    icon_info.hbmColor = color;\n    HICON icon_handle = CreateIconIndirect(&icon_info);\n    DeleteObject(color);\n    DeleteObject(mask);\n\n    return icon_handle;\n}\n\n_SOKOL_PRIVATE void _sapp_win32_set_icon(const sapp_icon_desc* icon_desc, int num_images) {\n    SOKOL_ASSERT((num_images > 0) && (num_images <= SAPP_MAX_ICONIMAGES));\n\n    int big_img_index = _sapp_image_bestmatch(icon_desc->images, num_images, GetSystemMetrics(SM_CXICON), GetSystemMetrics(SM_CYICON));\n    int sml_img_index = _sapp_image_bestmatch(icon_desc->images, num_images, GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON));\n    HICON big_icon = _sapp_win32_create_icon_from_image(&icon_desc->images[big_img_index]);\n    HICON sml_icon = _sapp_win32_create_icon_from_image(&icon_desc->images[sml_img_index]);\n\n    // if icon creation or lookup has failed for some reason, leave the currently set icon untouched\n    if (0 != big_icon) {\n        SendMessage(_sapp.win32.hwnd, WM_SETICON, ICON_BIG, (LPARAM) big_icon);\n        if (0 != _sapp.win32.big_icon) {\n            DestroyIcon(_sapp.win32.big_icon);\n        }\n        _sapp.win32.big_icon = big_icon;\n    }\n    if (0 != sml_icon) {\n        SendMessage(_sapp.win32.hwnd, WM_SETICON, ICON_SMALL, (LPARAM) sml_icon);\n        if (0 != _sapp.win32.small_icon) {\n            DestroyIcon(_sapp.win32.small_icon);\n        }\n        _sapp.win32.small_icon = sml_icon;\n    }\n}\n\n/* don't laugh, but this seems to be the easiest and most robust\n   way to check if we're running on Win10\n\n   From: https://github.com/videolan/vlc/blob/232fb13b0d6110c4d1b683cde24cf9a7f2c5c2ea/modules/video_output/win32/d3d11_swapchain.c#L263\n*/\n_SOKOL_PRIVATE bool _sapp_win32_is_win10_or_greater(void) {\n    HMODULE h = GetModuleHandleW(L\"kernel32.dll\");\n    if (NULL != h) {\n        return (NULL != GetProcAddress(h, \"GetSystemCpuSetInformation\"));\n    }\n    else {\n        return false;\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_win32_run(const sapp_desc* desc) {\n    _sapp_init_state(desc);\n    _sapp_win32_init_console();\n    _sapp.win32.is_win10_or_greater = _sapp_win32_is_win10_or_greater();\n    _sapp_win32_init_keytable();\n    _sapp_win32_utf8_to_wide(_sapp.window_title, _sapp.window_title_wide, sizeof(_sapp.window_title_wide));\n    _sapp_win32_init_dpi();\n    _sapp_win32_init_cursors();\n    _sapp_win32_create_window();\n    sapp_set_icon(&desc->icon);\n    #if defined(SOKOL_D3D11)\n        _sapp_d3d11_create_device_and_swapchain();\n        _sapp_d3d11_create_default_render_target();\n    #endif\n    #if defined(SOKOL_GLCORE)\n        _sapp_wgl_init();\n        _sapp_wgl_load_extensions();\n        _sapp_wgl_create_context();\n    #endif\n    _sapp.valid = true;\n\n    bool done = false;\n    while (!(done || _sapp.quit_ordered)) {\n        _sapp_win32_timing_measure();\n        MSG msg;\n        while (PeekMessageW(&msg, NULL, 0, 0, PM_REMOVE)) {\n            if (WM_QUIT == msg.message) {\n                done = true;\n                continue;\n            }\n            else {\n                TranslateMessage(&msg);\n                DispatchMessageW(&msg);\n            }\n        }\n        _sapp_frame();\n        #if defined(SOKOL_D3D11)\n            _sapp_d3d11_present(false);\n            if (IsIconic(_sapp.win32.hwnd)) {\n                Sleep((DWORD)(16 * _sapp.swap_interval));\n            }\n        #endif\n        #if defined(SOKOL_GLCORE)\n            _sapp_wgl_swap_buffers();\n        #endif\n        /* check for window resized, this cannot happen in WM_SIZE as it explodes memory usage */\n        if (_sapp_win32_update_dimensions()) {\n            #if defined(SOKOL_D3D11)\n            _sapp_d3d11_resize_default_render_target();\n            #endif\n            _sapp_win32_app_event(SAPP_EVENTTYPE_RESIZED);\n        }\n        /* check if the window monitor has changed, need to reset timing because\n           the new monitor might have a different refresh rate\n        */\n        if (_sapp_win32_update_monitor()) {\n            _sapp_timing_reset(&_sapp.timing);\n        }\n        if (_sapp.quit_requested) {\n            PostMessage(_sapp.win32.hwnd, WM_CLOSE, 0, 0);\n        }\n    }\n    _sapp_call_cleanup();\n\n    #if defined(SOKOL_D3D11)\n        _sapp_d3d11_destroy_default_render_target();\n        _sapp_d3d11_destroy_device_and_swapchain();\n    #elif defined(SOKOL_GLCORE)\n        _sapp_wgl_destroy_context();\n        _sapp_wgl_shutdown();\n    #endif\n    _sapp_win32_destroy_window();\n    _sapp_win32_destroy_icons();\n    _sapp_win32_restore_console();\n    _sapp_discard_state();\n}\n\n_SOKOL_PRIVATE char** _sapp_win32_command_line_to_utf8_argv(LPWSTR w_command_line, int* o_argc) {\n    int argc = 0;\n    char** argv = 0;\n    char* args;\n\n    LPWSTR* w_argv = CommandLineToArgvW(w_command_line, &argc);\n    if (w_argv == NULL) {\n        // FIXME: chicken egg problem, can't report errors before sokol_main() is called!\n    } else {\n        size_t size = wcslen(w_command_line) * 4;\n        argv = (char**) _sapp_malloc_clear(((size_t)argc + 1) * sizeof(char*) + size);\n        SOKOL_ASSERT(argv);\n        args = (char*) &argv[argc + 1];\n        int n;\n        for (int i = 0; i < argc; ++i) {\n            n = WideCharToMultiByte(CP_UTF8, 0, w_argv[i], -1, args, (int)size, NULL, NULL);\n            if (n == 0) {\n                // FIXME: chicken egg problem, can't report errors before sokol_main() is called!\n                break;\n            }\n            argv[i] = args;\n            size -= (size_t)n;\n            args += n;\n        }\n        LocalFree(w_argv);\n    }\n    *o_argc = argc;\n    return argv;\n}\n\n#if !defined(SOKOL_NO_ENTRY)\n#if defined(SOKOL_WIN32_FORCE_MAIN)\nint main(int argc, char* argv[]) {\n    sapp_desc desc = sokol_main(argc, argv);\n    _sapp_win32_run(&desc);\n    return 0;\n}\n#endif /* SOKOL_WIN32_FORCE_MAIN */\n#if defined(SOKOL_WIN32_FORCE_WINMAIN) || !defined(SOKOL_WIN32_FORCE_MAIN)\nint WINAPI WinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPSTR lpCmdLine, _In_ int nCmdShow) {\n    _SOKOL_UNUSED(hInstance);\n    _SOKOL_UNUSED(hPrevInstance);\n    _SOKOL_UNUSED(lpCmdLine);\n    _SOKOL_UNUSED(nCmdShow);\n    int argc_utf8 = 0;\n    char** argv_utf8 = _sapp_win32_command_line_to_utf8_argv(GetCommandLineW(), &argc_utf8);\n    sapp_desc desc = sokol_main(argc_utf8, argv_utf8);\n    _sapp_win32_run(&desc);\n    _sapp_free(argv_utf8);\n    return 0;\n}\n#endif /* SOKOL_WIN32_FORCE_WINMAIN */\n#endif /* SOKOL_NO_ENTRY */\n\n#ifdef _MSC_VER\n    #pragma warning(pop)\n#endif\n\n#endif /* _SAPP_WIN32 */\n\n//                 \n//                          \n//                     \n//                          \n//                   \n//\n// >>android\n#if defined(_SAPP_ANDROID)\n\n/* android loop thread */\n_SOKOL_PRIVATE bool _sapp_android_init_egl(void) {\n    SOKOL_ASSERT(_sapp.android.display == EGL_NO_DISPLAY);\n    SOKOL_ASSERT(_sapp.android.context == EGL_NO_CONTEXT);\n\n    EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);\n    if (display == EGL_NO_DISPLAY) {\n        return false;\n    }\n    if (eglInitialize(display, NULL, NULL) == EGL_FALSE) {\n        return false;\n    }\n    EGLint alpha_size = _sapp.desc.alpha ? 8 : 0;\n    const EGLint cfg_attributes[] = {\n        EGL_SURFACE_TYPE, EGL_WINDOW_BIT,\n        EGL_RENDERABLE_TYPE, EGL_OPENGL_ES3_BIT,\n        EGL_RED_SIZE, 8,\n        EGL_GREEN_SIZE, 8,\n        EGL_BLUE_SIZE, 8,\n        EGL_ALPHA_SIZE, alpha_size,\n        EGL_DEPTH_SIZE, 16,\n        EGL_STENCIL_SIZE, 0,\n        EGL_NONE,\n    };\n    EGLConfig available_cfgs[32];\n    EGLint cfg_count;\n    eglChooseConfig(display, cfg_attributes, available_cfgs, 32, &cfg_count);\n    SOKOL_ASSERT(cfg_count > 0);\n    SOKOL_ASSERT(cfg_count <= 32);\n\n    /* find config with 8-bit rgb buffer if available, ndk sample does not trust egl spec */\n    EGLConfig config;\n    bool exact_cfg_found = false;\n    for (int i = 0; i < cfg_count; ++i) {\n        EGLConfig c = available_cfgs[i];\n        EGLint r, g, b, a, d;\n        if (eglGetConfigAttrib(display, c, EGL_RED_SIZE, &r) == EGL_TRUE &&\n            eglGetConfigAttrib(display, c, EGL_GREEN_SIZE, &g) == EGL_TRUE &&\n            eglGetConfigAttrib(display, c, EGL_BLUE_SIZE, &b) == EGL_TRUE &&\n            eglGetConfigAttrib(display, c, EGL_ALPHA_SIZE, &a) == EGL_TRUE &&\n            eglGetConfigAttrib(display, c, EGL_DEPTH_SIZE, &d) == EGL_TRUE &&\n            r == 8 && g == 8 && b == 8 && (alpha_size == 0 || a == alpha_size) && d == 16) {\n            exact_cfg_found = true;\n            config = c;\n            break;\n        }\n    }\n    if (!exact_cfg_found) {\n        config = available_cfgs[0];\n    }\n\n    EGLint ctx_attributes[] = {\n        EGL_CONTEXT_CLIENT_VERSION, 3,\n        EGL_NONE,\n    };\n    EGLContext context = eglCreateContext(display, config, EGL_NO_CONTEXT, ctx_attributes);\n    if (context == EGL_NO_CONTEXT) {\n        return false;\n    }\n\n    _sapp.android.config = config;\n    _sapp.android.display = display;\n    _sapp.android.context = context;\n    return true;\n}\n\n_SOKOL_PRIVATE void _sapp_android_cleanup_egl(void) {\n    if (_sapp.android.display != EGL_NO_DISPLAY) {\n        eglMakeCurrent(_sapp.android.display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);\n        if (_sapp.android.surface != EGL_NO_SURFACE) {\n            eglDestroySurface(_sapp.android.display, _sapp.android.surface);\n            _sapp.android.surface = EGL_NO_SURFACE;\n        }\n        if (_sapp.android.context != EGL_NO_CONTEXT) {\n            eglDestroyContext(_sapp.android.display, _sapp.android.context);\n            _sapp.android.context = EGL_NO_CONTEXT;\n        }\n        eglTerminate(_sapp.android.display);\n        _sapp.android.display = EGL_NO_DISPLAY;\n    }\n}\n\n_SOKOL_PRIVATE bool _sapp_android_init_egl_surface(ANativeWindow* window) {\n    SOKOL_ASSERT(_sapp.android.display != EGL_NO_DISPLAY);\n    SOKOL_ASSERT(_sapp.android.context != EGL_NO_CONTEXT);\n    SOKOL_ASSERT(_sapp.android.surface == EGL_NO_SURFACE);\n    SOKOL_ASSERT(window);\n\n    /* TODO: set window flags */\n    /* ANativeActivity_setWindowFlags(activity, AWINDOW_FLAG_KEEP_SCREEN_ON, 0); */\n\n    /* create egl surface and make it current */\n    EGLSurface surface = eglCreateWindowSurface(_sapp.android.display, _sapp.android.config, window, NULL);\n    if (surface == EGL_NO_SURFACE) {\n        return false;\n    }\n    if (eglMakeCurrent(_sapp.android.display, surface, surface, _sapp.android.context) == EGL_FALSE) {\n        return false;\n    }\n    _sapp.android.surface = surface;\n    glGetIntegerv(GL_FRAMEBUFFER_BINDING, (GLint*)&_sapp.gl.framebuffer);\n    return true;\n}\n\n_SOKOL_PRIVATE void _sapp_android_cleanup_egl_surface(void) {\n    if (_sapp.android.display == EGL_NO_DISPLAY) {\n        return;\n    }\n    eglMakeCurrent(_sapp.android.display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);\n    if (_sapp.android.surface != EGL_NO_SURFACE) {\n        eglDestroySurface(_sapp.android.display, _sapp.android.surface);\n        _sapp.android.surface = EGL_NO_SURFACE;\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_android_app_event(sapp_event_type type) {\n    if (_sapp_events_enabled()) {\n        _sapp_init_event(type);\n        _sapp_call_event(&_sapp.event);\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_android_update_dimensions(ANativeWindow* window, bool force_update) {\n    SOKOL_ASSERT(_sapp.android.display != EGL_NO_DISPLAY);\n    SOKOL_ASSERT(_sapp.android.context != EGL_NO_CONTEXT);\n    SOKOL_ASSERT(_sapp.android.surface != EGL_NO_SURFACE);\n    SOKOL_ASSERT(window);\n\n    const int32_t win_w = ANativeWindow_getWidth(window);\n    const int32_t win_h = ANativeWindow_getHeight(window);\n    SOKOL_ASSERT(win_w >= 0 && win_h >= 0);\n    const bool win_changed = (win_w != _sapp.window_width) || (win_h != _sapp.window_height);\n    _sapp.window_width = win_w;\n    _sapp.window_height = win_h;\n    if (win_changed || force_update) {\n        if (!_sapp.desc.high_dpi) {\n            const int32_t buf_w = win_w / 2;\n            const int32_t buf_h = win_h / 2;\n            EGLint format;\n            EGLBoolean egl_result = eglGetConfigAttrib(_sapp.android.display, _sapp.android.config, EGL_NATIVE_VISUAL_ID, &format);\n            SOKOL_ASSERT(egl_result == EGL_TRUE); _SOKOL_UNUSED(egl_result);\n            /* NOTE: calling ANativeWindow_setBuffersGeometry() with the same dimensions\n                as the ANativeWindow size results in weird display artefacts, that's\n                why it's only called when the buffer geometry is different from\n                the window size\n            */\n            int32_t result = ANativeWindow_setBuffersGeometry(window, buf_w, buf_h, format);\n            SOKOL_ASSERT(result == 0); _SOKOL_UNUSED(result);\n        }\n    }\n\n    /* query surface size */\n    EGLint fb_w, fb_h;\n    EGLBoolean egl_result_w = eglQuerySurface(_sapp.android.display, _sapp.android.surface, EGL_WIDTH, &fb_w);\n    EGLBoolean egl_result_h = eglQuerySurface(_sapp.android.display, _sapp.android.surface, EGL_HEIGHT, &fb_h);\n    SOKOL_ASSERT(egl_result_w == EGL_TRUE); _SOKOL_UNUSED(egl_result_w);\n    SOKOL_ASSERT(egl_result_h == EGL_TRUE); _SOKOL_UNUSED(egl_result_h);\n    const bool fb_changed = (fb_w != _sapp.framebuffer_width) || (fb_h != _sapp.framebuffer_height);\n    _sapp.framebuffer_width = fb_w;\n    _sapp.framebuffer_height = fb_h;\n    _sapp.dpi_scale = (float)_sapp.framebuffer_width / (float)_sapp.window_width;\n    if (win_changed || fb_changed || force_update) {\n        if (!_sapp.first_frame) {\n            _sapp_android_app_event(SAPP_EVENTTYPE_RESIZED);\n        }\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_android_cleanup(void) {\n    if (_sapp.android.surface != EGL_NO_SURFACE) {\n        /* egl context is bound, cleanup gracefully */\n        if (_sapp.init_called && !_sapp.cleanup_called) {\n            _sapp_call_cleanup();\n        }\n    }\n    /* always try to cleanup by destroying egl context */\n    _sapp_android_cleanup_egl();\n}\n\n_SOKOL_PRIVATE void _sapp_android_shutdown(void) {\n    /* try to cleanup while we still have a surface and can call cleanup_cb() */\n    _sapp_android_cleanup();\n    /* request exit */\n    ANativeActivity_finish(_sapp.android.activity);\n}\n\n_SOKOL_PRIVATE void _sapp_android_frame(void) {\n    SOKOL_ASSERT(_sapp.android.display != EGL_NO_DISPLAY);\n    SOKOL_ASSERT(_sapp.android.context != EGL_NO_CONTEXT);\n    SOKOL_ASSERT(_sapp.android.surface != EGL_NO_SURFACE);\n    _sapp_timing_measure(&_sapp.timing);\n    _sapp_android_update_dimensions(_sapp.android.current.window, false);\n    _sapp_frame();\n    eglSwapBuffers(_sapp.android.display, _sapp.android.surface);\n}\n\n_SOKOL_PRIVATE bool _sapp_android_touch_event(const AInputEvent* e) {\n    if (AInputEvent_getType(e) != AINPUT_EVENT_TYPE_MOTION) {\n        return false;\n    }\n    if (!_sapp_events_enabled()) {\n        return false;\n    }\n    int32_t action_idx = AMotionEvent_getAction(e);\n    int32_t action = action_idx & AMOTION_EVENT_ACTION_MASK;\n    sapp_event_type type = SAPP_EVENTTYPE_INVALID;\n    switch (action) {\n        case AMOTION_EVENT_ACTION_DOWN:\n        case AMOTION_EVENT_ACTION_POINTER_DOWN:\n            type = SAPP_EVENTTYPE_TOUCHES_BEGAN;\n            break;\n        case AMOTION_EVENT_ACTION_MOVE:\n            type = SAPP_EVENTTYPE_TOUCHES_MOVED;\n            break;\n        case AMOTION_EVENT_ACTION_UP:\n        case AMOTION_EVENT_ACTION_POINTER_UP:\n            type = SAPP_EVENTTYPE_TOUCHES_ENDED;\n            break;\n        case AMOTION_EVENT_ACTION_CANCEL:\n            type = SAPP_EVENTTYPE_TOUCHES_CANCELLED;\n            break;\n        default:\n            break;\n    }\n    if (type == SAPP_EVENTTYPE_INVALID) {\n        return false;\n    }\n    int32_t idx = action_idx >> AMOTION_EVENT_ACTION_POINTER_INDEX_SHIFT;\n    _sapp_init_event(type);\n    _sapp.event.num_touches = (int)AMotionEvent_getPointerCount(e);\n    if (_sapp.event.num_touches > SAPP_MAX_TOUCHPOINTS) {\n        _sapp.event.num_touches = SAPP_MAX_TOUCHPOINTS;\n    }\n    for (int32_t i = 0; i < _sapp.event.num_touches; i++) {\n        sapp_touchpoint* dst = &_sapp.event.touches[i];\n        dst->identifier = (uintptr_t)AMotionEvent_getPointerId(e, (size_t)i);\n        dst->pos_x = (AMotionEvent_getX(e, (size_t)i) / _sapp.window_width) * _sapp.framebuffer_width;\n        dst->pos_y = (AMotionEvent_getY(e, (size_t)i) / _sapp.window_height) * _sapp.framebuffer_height;\n        dst->android_tooltype = (sapp_android_tooltype) AMotionEvent_getToolType(e, (size_t)i);\n        if (action == AMOTION_EVENT_ACTION_POINTER_DOWN ||\n            action == AMOTION_EVENT_ACTION_POINTER_UP) {\n            dst->changed = (i == idx);\n        } else {\n            dst->changed = true;\n        }\n    }\n    _sapp_call_event(&_sapp.event);\n    return true;\n}\n\n_SOKOL_PRIVATE bool _sapp_android_key_event(const AInputEvent* e) {\n    if (AInputEvent_getType(e) != AINPUT_EVENT_TYPE_KEY) {\n        return false;\n    }\n    if (AKeyEvent_getKeyCode(e) == AKEYCODE_BACK) {\n        /* FIXME: this should be hooked into a \"really quit?\" mechanism\n           so the app can ask the user for confirmation, this is currently\n           generally missing in sokol_app.h\n        */\n        _sapp_android_shutdown();\n        return true;\n    }\n    return false;\n}\n\n_SOKOL_PRIVATE int _sapp_android_input_cb(int fd, int events, void* data) {\n    _SOKOL_UNUSED(fd);\n    _SOKOL_UNUSED(data);\n    if ((events & ALOOPER_EVENT_INPUT) == 0) {\n        _SAPP_ERROR(ANDROID_UNSUPPORTED_INPUT_EVENT_INPUT_CB);\n        return 1;\n    }\n    SOKOL_ASSERT(_sapp.android.current.input);\n    AInputEvent* event = NULL;\n    while (AInputQueue_getEvent(_sapp.android.current.input, &event) >= 0) {\n        if (AInputQueue_preDispatchEvent(_sapp.android.current.input, event) != 0) {\n            continue;\n        }\n        int32_t handled = 0;\n        if (_sapp_android_touch_event(event) || _sapp_android_key_event(event)) {\n            handled = 1;\n        }\n        AInputQueue_finishEvent(_sapp.android.current.input, event, handled);\n    }\n    return 1;\n}\n\n_SOKOL_PRIVATE int _sapp_android_main_cb(int fd, int events, void* data) {\n    _SOKOL_UNUSED(data);\n    if ((events & ALOOPER_EVENT_INPUT) == 0) {\n        _SAPP_ERROR(ANDROID_UNSUPPORTED_INPUT_EVENT_MAIN_CB);\n        return 1;\n    }\n\n    _sapp_android_msg_t msg;\n    if (read(fd, &msg, sizeof(msg)) != sizeof(msg)) {\n        _SAPP_ERROR(ANDROID_READ_MSG_FAILED);\n        return 1;\n    }\n\n    pthread_mutex_lock(&_sapp.android.pt.mutex);\n    switch (msg) {\n        case _SOKOL_ANDROID_MSG_CREATE:\n            {\n                _SAPP_INFO(ANDROID_MSG_CREATE);\n                SOKOL_ASSERT(!_sapp.valid);\n                bool result = _sapp_android_init_egl();\n                SOKOL_ASSERT(result); _SOKOL_UNUSED(result);\n                _sapp.valid = true;\n                _sapp.android.has_created = true;\n            }\n            break;\n        case _SOKOL_ANDROID_MSG_RESUME:\n            _SAPP_INFO(ANDROID_MSG_RESUME);\n            _sapp.android.has_resumed = true;\n            _sapp_android_app_event(SAPP_EVENTTYPE_RESUMED);\n            break;\n        case _SOKOL_ANDROID_MSG_PAUSE:\n            _SAPP_INFO(ANDROID_MSG_PAUSE);\n            _sapp.android.has_resumed = false;\n            _sapp_android_app_event(SAPP_EVENTTYPE_SUSPENDED);\n            break;\n        case _SOKOL_ANDROID_MSG_FOCUS:\n            _SAPP_INFO(ANDROID_MSG_FOCUS);\n            _sapp.android.has_focus = true;\n            break;\n        case _SOKOL_ANDROID_MSG_NO_FOCUS:\n            _SAPP_INFO(ANDROID_MSG_NO_FOCUS);\n            _sapp.android.has_focus = false;\n            break;\n        case _SOKOL_ANDROID_MSG_SET_NATIVE_WINDOW:\n            _SAPP_INFO(ANDROID_MSG_SET_NATIVE_WINDOW);\n            if (_sapp.android.current.window != _sapp.android.pending.window) {\n                if (_sapp.android.current.window != NULL) {\n                    _sapp_android_cleanup_egl_surface();\n                }\n                if (_sapp.android.pending.window != NULL) {\n                    if (_sapp_android_init_egl_surface(_sapp.android.pending.window)) {\n                        _sapp_android_update_dimensions(_sapp.android.pending.window, true);\n                    } else {\n                        _sapp_android_shutdown();\n                    }\n                }\n            }\n            _sapp.android.current.window = _sapp.android.pending.window;\n            break;\n        case _SOKOL_ANDROID_MSG_SET_INPUT_QUEUE:\n            _SAPP_INFO(ANDROID_MSG_SET_INPUT_QUEUE);\n            if (_sapp.android.current.input != _sapp.android.pending.input) {\n                if (_sapp.android.current.input != NULL) {\n                    AInputQueue_detachLooper(_sapp.android.current.input);\n                }\n                if (_sapp.android.pending.input != NULL) {\n                    AInputQueue_attachLooper(\n                        _sapp.android.pending.input,\n                        _sapp.android.looper,\n                        ALOOPER_POLL_CALLBACK,\n                        _sapp_android_input_cb,\n                        NULL); /* data */\n                }\n            }\n            _sapp.android.current.input = _sapp.android.pending.input;\n            break;\n        case _SOKOL_ANDROID_MSG_DESTROY:\n            _SAPP_INFO(ANDROID_MSG_DESTROY);\n            _sapp_android_cleanup();\n            _sapp.valid = false;\n            _sapp.android.is_thread_stopping = true;\n            break;\n        default:\n            _SAPP_WARN(ANDROID_UNKNOWN_MSG);\n            break;\n    }\n    pthread_cond_broadcast(&_sapp.android.pt.cond); /* signal \"received\" */\n    pthread_mutex_unlock(&_sapp.android.pt.mutex);\n    return 1;\n}\n\n_SOKOL_PRIVATE bool _sapp_android_should_update(void) {\n    bool is_in_front = _sapp.android.has_resumed && _sapp.android.has_focus;\n    bool has_surface = _sapp.android.surface != EGL_NO_SURFACE;\n    return is_in_front && has_surface;\n}\n\n_SOKOL_PRIVATE void _sapp_android_show_keyboard(bool shown) {\n    SOKOL_ASSERT(_sapp.valid);\n    /* This seems to be broken in the NDK, but there is (a very cumbersome) workaround... */\n    if (shown) {\n        ANativeActivity_showSoftInput(_sapp.android.activity, ANATIVEACTIVITY_SHOW_SOFT_INPUT_FORCED);\n    } else {\n        ANativeActivity_hideSoftInput(_sapp.android.activity, ANATIVEACTIVITY_HIDE_SOFT_INPUT_NOT_ALWAYS);\n    }\n}\n\n_SOKOL_PRIVATE void* _sapp_android_loop(void* arg) {\n    _SOKOL_UNUSED(arg);\n    _SAPP_INFO(ANDROID_LOOP_THREAD_STARTED);\n\n    _sapp.android.looper = ALooper_prepare(0 /* or ALOOPER_PREPARE_ALLOW_NON_CALLBACKS*/);\n    ALooper_addFd(_sapp.android.looper,\n        _sapp.android.pt.read_from_main_fd,\n        ALOOPER_POLL_CALLBACK,\n        ALOOPER_EVENT_INPUT,\n        _sapp_android_main_cb,\n        NULL); /* data */\n\n    /* signal start to main thread */\n    pthread_mutex_lock(&_sapp.android.pt.mutex);\n    _sapp.android.is_thread_started = true;\n    pthread_cond_broadcast(&_sapp.android.pt.cond);\n    pthread_mutex_unlock(&_sapp.android.pt.mutex);\n\n    /* main loop */\n    while (!_sapp.android.is_thread_stopping) {\n        /* sokol frame */\n        if (_sapp_android_should_update()) {\n            _sapp_android_frame();\n        }\n\n        /* process all events (or stop early if app is requested to quit) */\n        bool process_events = true;\n        while (process_events && !_sapp.android.is_thread_stopping) {\n            bool block_until_event = !_sapp.android.is_thread_stopping && !_sapp_android_should_update();\n            process_events = ALooper_pollOnce(block_until_event ? -1 : 0, NULL, NULL, NULL) == ALOOPER_POLL_CALLBACK;\n        }\n    }\n\n    /* cleanup thread */\n    if (_sapp.android.current.input != NULL) {\n        AInputQueue_detachLooper(_sapp.android.current.input);\n    }\n\n    /* the following causes heap corruption on exit, why??\n    ALooper_removeFd(_sapp.android.looper, _sapp.android.pt.read_from_main_fd);\n    ALooper_release(_sapp.android.looper);*/\n\n    /* signal \"destroyed\" */\n    pthread_mutex_lock(&_sapp.android.pt.mutex);\n    _sapp.android.is_thread_stopped = true;\n    pthread_cond_broadcast(&_sapp.android.pt.cond);\n    pthread_mutex_unlock(&_sapp.android.pt.mutex);\n\n    _SAPP_INFO(ANDROID_LOOP_THREAD_DONE);\n    return NULL;\n}\n\n/* android main/ui thread */\n_SOKOL_PRIVATE void _sapp_android_msg(_sapp_android_msg_t msg) {\n    if (write(_sapp.android.pt.write_from_main_fd, &msg, sizeof(msg)) != sizeof(msg)) {\n        _SAPP_ERROR(ANDROID_WRITE_MSG_FAILED);\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_android_on_start(ANativeActivity* activity) {\n    _SOKOL_UNUSED(activity);\n    _SAPP_INFO(ANDROID_NATIVE_ACTIVITY_ONSTART);\n}\n\n_SOKOL_PRIVATE void _sapp_android_on_resume(ANativeActivity* activity) {\n    _SOKOL_UNUSED(activity);\n    _SAPP_INFO(ANDROID_NATIVE_ACTIVITY_ONRESUME);\n    _sapp_android_msg(_SOKOL_ANDROID_MSG_RESUME);\n}\n\n_SOKOL_PRIVATE void* _sapp_android_on_save_instance_state(ANativeActivity* activity, size_t* out_size) {\n    _SOKOL_UNUSED(activity);\n    _SAPP_INFO(ANDROID_NATIVE_ACTIVITY_ONSAVEINSTANCESTATE);\n    *out_size = 0;\n    return NULL;\n}\n\n_SOKOL_PRIVATE void _sapp_android_on_window_focus_changed(ANativeActivity* activity, int has_focus) {\n    _SOKOL_UNUSED(activity);\n    _SAPP_INFO(ANDROID_NATIVE_ACTIVITY_ONWINDOWFOCUSCHANGED);\n    if (has_focus) {\n        _sapp_android_msg(_SOKOL_ANDROID_MSG_FOCUS);\n    } else {\n        _sapp_android_msg(_SOKOL_ANDROID_MSG_NO_FOCUS);\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_android_on_pause(ANativeActivity* activity) {\n    _SOKOL_UNUSED(activity);\n    _SAPP_INFO(ANDROID_NATIVE_ACTIVITY_ONPAUSE);\n    _sapp_android_msg(_SOKOL_ANDROID_MSG_PAUSE);\n}\n\n_SOKOL_PRIVATE void _sapp_android_on_stop(ANativeActivity* activity) {\n    _SOKOL_UNUSED(activity);\n    _SAPP_INFO(ANDROID_NATIVE_ACTIVITY_ONSTOP);\n}\n\n_SOKOL_PRIVATE void _sapp_android_msg_set_native_window(ANativeWindow* window) {\n    pthread_mutex_lock(&_sapp.android.pt.mutex);\n    _sapp.android.pending.window = window;\n    _sapp_android_msg(_SOKOL_ANDROID_MSG_SET_NATIVE_WINDOW);\n    while (_sapp.android.current.window != window) {\n        pthread_cond_wait(&_sapp.android.pt.cond, &_sapp.android.pt.mutex);\n    }\n    pthread_mutex_unlock(&_sapp.android.pt.mutex);\n}\n\n_SOKOL_PRIVATE void _sapp_android_on_native_window_created(ANativeActivity* activity, ANativeWindow* window) {\n    _SOKOL_UNUSED(activity);\n    _SAPP_INFO(ANDROID_NATIVE_ACTIVITY_ONNATIVEWINDOWCREATED);\n    _sapp_android_msg_set_native_window(window);\n}\n\n_SOKOL_PRIVATE void _sapp_android_on_native_window_destroyed(ANativeActivity* activity, ANativeWindow* window) {\n    _SOKOL_UNUSED(activity);\n    _SOKOL_UNUSED(window);\n    _SAPP_INFO(ANDROID_NATIVE_ACTIVITY_ONNATIVEWINDOWDESTROYED);\n    _sapp_android_msg_set_native_window(NULL);\n}\n\n_SOKOL_PRIVATE void _sapp_android_msg_set_input_queue(AInputQueue* input) {\n    pthread_mutex_lock(&_sapp.android.pt.mutex);\n    _sapp.android.pending.input = input;\n    _sapp_android_msg(_SOKOL_ANDROID_MSG_SET_INPUT_QUEUE);\n    while (_sapp.android.current.input != input) {\n        pthread_cond_wait(&_sapp.android.pt.cond, &_sapp.android.pt.mutex);\n    }\n    pthread_mutex_unlock(&_sapp.android.pt.mutex);\n}\n\n_SOKOL_PRIVATE void _sapp_android_on_input_queue_created(ANativeActivity* activity, AInputQueue* queue) {\n    _SOKOL_UNUSED(activity);\n    _SAPP_INFO(ANDROID_NATIVE_ACTIVITY_ONINPUTQUEUECREATED);\n    _sapp_android_msg_set_input_queue(queue);\n}\n\n_SOKOL_PRIVATE void _sapp_android_on_input_queue_destroyed(ANativeActivity* activity, AInputQueue* queue) {\n    _SOKOL_UNUSED(activity);\n    _SOKOL_UNUSED(queue);\n    _SAPP_INFO(ANDROID_NATIVE_ACTIVITY_ONINPUTQUEUEDESTROYED);\n    _sapp_android_msg_set_input_queue(NULL);\n}\n\n_SOKOL_PRIVATE void _sapp_android_on_config_changed(ANativeActivity* activity) {\n    _SOKOL_UNUSED(activity);\n    _SAPP_INFO(ANDROID_NATIVE_ACTIVITY_ONCONFIGURATIONCHANGED);\n    /* see android:configChanges in manifest */\n}\n\n_SOKOL_PRIVATE void _sapp_android_on_low_memory(ANativeActivity* activity) {\n    _SOKOL_UNUSED(activity);\n    _SAPP_INFO(ANDROID_NATIVE_ACTIVITY_ONLOWMEMORY);\n}\n\n_SOKOL_PRIVATE void _sapp_android_on_destroy(ANativeActivity* activity) {\n    /*\n     * For some reason even an empty app using nativeactivity.h will crash (WIN DEATH)\n     * on my device (Moto X 2nd gen) when the app is removed from the task view\n     * (TaskStackView: onTaskViewDismissed).\n     *\n     * However, if ANativeActivity_finish() is explicitly called from for example\n     * _sapp_android_on_stop(), the crash disappears. Is this a bug in NativeActivity?\n     */\n    _SOKOL_UNUSED(activity);\n    _SAPP_INFO(ANDROID_NATIVE_ACTIVITY_ONDESTROY);\n\n    /* send destroy msg */\n    pthread_mutex_lock(&_sapp.android.pt.mutex);\n    _sapp_android_msg(_SOKOL_ANDROID_MSG_DESTROY);\n    while (!_sapp.android.is_thread_stopped) {\n        pthread_cond_wait(&_sapp.android.pt.cond, &_sapp.android.pt.mutex);\n    }\n    pthread_mutex_unlock(&_sapp.android.pt.mutex);\n\n    /* clean up main thread */\n    pthread_cond_destroy(&_sapp.android.pt.cond);\n    pthread_mutex_destroy(&_sapp.android.pt.mutex);\n\n    close(_sapp.android.pt.read_from_main_fd);\n    close(_sapp.android.pt.write_from_main_fd);\n\n    _SAPP_INFO(ANDROID_NATIVE_ACTIVITY_DONE);\n\n    /* this is a bit naughty, but causes a clean restart of the app (static globals are reset) */\n    exit(0);\n}\n\nJNIEXPORT\nvoid ANativeActivity_onCreate(ANativeActivity* activity, void* saved_state, size_t saved_state_size) {\n    _SOKOL_UNUSED(saved_state);\n    _SOKOL_UNUSED(saved_state_size);\n    _SAPP_INFO(ANDROID_NATIVE_ACTIVITY_ONCREATE);\n\n    // the NativeActity pointer needs to be available inside sokol_main()\n    // (see https://github.com/floooh/sokol/issues/708), however _sapp_init_state()\n    // will clear the global _sapp_t struct, so we need to initialize the native\n    // activity pointer twice, once before sokol_main() and once after _sapp_init_state()\n    _sapp_clear(&_sapp, sizeof(_sapp));\n    _sapp.android.activity = activity;\n    sapp_desc desc = sokol_main(0, NULL);\n    _sapp_init_state(&desc);\n    _sapp.android.activity = activity;\n\n    int pipe_fd[2];\n    if (pipe(pipe_fd) != 0) {\n        _SAPP_ERROR(ANDROID_CREATE_THREAD_PIPE_FAILED);\n        return;\n    }\n    _sapp.android.pt.read_from_main_fd = pipe_fd[0];\n    _sapp.android.pt.write_from_main_fd = pipe_fd[1];\n\n    pthread_mutex_init(&_sapp.android.pt.mutex, NULL);\n    pthread_cond_init(&_sapp.android.pt.cond, NULL);\n\n    pthread_attr_t attr;\n    pthread_attr_init(&attr);\n    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n    pthread_create(&_sapp.android.pt.thread, &attr, _sapp_android_loop, 0);\n    pthread_attr_destroy(&attr);\n\n    /* wait until main loop has started */\n    pthread_mutex_lock(&_sapp.android.pt.mutex);\n    while (!_sapp.android.is_thread_started) {\n        pthread_cond_wait(&_sapp.android.pt.cond, &_sapp.android.pt.mutex);\n    }\n    pthread_mutex_unlock(&_sapp.android.pt.mutex);\n\n    /* send create msg */\n    pthread_mutex_lock(&_sapp.android.pt.mutex);\n    _sapp_android_msg(_SOKOL_ANDROID_MSG_CREATE);\n    while (!_sapp.android.has_created) {\n        pthread_cond_wait(&_sapp.android.pt.cond, &_sapp.android.pt.mutex);\n    }\n    pthread_mutex_unlock(&_sapp.android.pt.mutex);\n\n    /* register for callbacks */\n    activity->callbacks->onStart = _sapp_android_on_start;\n    activity->callbacks->onResume = _sapp_android_on_resume;\n    activity->callbacks->onSaveInstanceState = _sapp_android_on_save_instance_state;\n    activity->callbacks->onWindowFocusChanged = _sapp_android_on_window_focus_changed;\n    activity->callbacks->onPause = _sapp_android_on_pause;\n    activity->callbacks->onStop = _sapp_android_on_stop;\n    activity->callbacks->onDestroy = _sapp_android_on_destroy;\n    activity->callbacks->onNativeWindowCreated = _sapp_android_on_native_window_created;\n    /* activity->callbacks->onNativeWindowResized = _sapp_android_on_native_window_resized; */\n    /* activity->callbacks->onNativeWindowRedrawNeeded = _sapp_android_on_native_window_redraw_needed; */\n    activity->callbacks->onNativeWindowDestroyed = _sapp_android_on_native_window_destroyed;\n    activity->callbacks->onInputQueueCreated = _sapp_android_on_input_queue_created;\n    activity->callbacks->onInputQueueDestroyed = _sapp_android_on_input_queue_destroyed;\n    /* activity->callbacks->onContentRectChanged = _sapp_android_on_content_rect_changed; */\n    activity->callbacks->onConfigurationChanged = _sapp_android_on_config_changed;\n    activity->callbacks->onLowMemory = _sapp_android_on_low_memory;\n\n    _SAPP_INFO(ANDROID_NATIVE_ACTIVITY_CREATE_SUCCESS);\n\n    /* NOT A BUG: do NOT call sapp_discard_state() */\n}\n\n#endif /* _SAPP_ANDROID */\n\n//                     \n//                   \n//                   \n//                   \n//             \n//\n// >>linux\n#if defined(_SAPP_LINUX)\n\n/* see GLFW's xkb_unicode.c */\nstatic const struct _sapp_x11_codepair {\n  uint16_t keysym;\n  uint16_t ucs;\n} _sapp_x11_keysymtab[] = {\n  { 0x01a1, 0x0104 },\n  { 0x01a2, 0x02d8 },\n  { 0x01a3, 0x0141 },\n  { 0x01a5, 0x013d },\n  { 0x01a6, 0x015a },\n  { 0x01a9, 0x0160 },\n  { 0x01aa, 0x015e },\n  { 0x01ab, 0x0164 },\n  { 0x01ac, 0x0179 },\n  { 0x01ae, 0x017d },\n  { 0x01af, 0x017b },\n  { 0x01b1, 0x0105 },\n  { 0x01b2, 0x02db },\n  { 0x01b3, 0x0142 },\n  { 0x01b5, 0x013e },\n  { 0x01b6, 0x015b },\n  { 0x01b7, 0x02c7 },\n  { 0x01b9, 0x0161 },\n  { 0x01ba, 0x015f },\n  { 0x01bb, 0x0165 },\n  { 0x01bc, 0x017a },\n  { 0x01bd, 0x02dd },\n  { 0x01be, 0x017e },\n  { 0x01bf, 0x017c },\n  { 0x01c0, 0x0154 },\n  { 0x01c3, 0x0102 },\n  { 0x01c5, 0x0139 },\n  { 0x01c6, 0x0106 },\n  { 0x01c8, 0x010c },\n  { 0x01ca, 0x0118 },\n  { 0x01cc, 0x011a },\n  { 0x01cf, 0x010e },\n  { 0x01d0, 0x0110 },\n  { 0x01d1, 0x0143 },\n  { 0x01d2, 0x0147 },\n  { 0x01d5, 0x0150 },\n  { 0x01d8, 0x0158 },\n  { 0x01d9, 0x016e },\n  { 0x01db, 0x0170 },\n  { 0x01de, 0x0162 },\n  { 0x01e0, 0x0155 },\n  { 0x01e3, 0x0103 },\n  { 0x01e5, 0x013a },\n  { 0x01e6, 0x0107 },\n  { 0x01e8, 0x010d },\n  { 0x01ea, 0x0119 },\n  { 0x01ec, 0x011b },\n  { 0x01ef, 0x010f },\n  { 0x01f0, 0x0111 },\n  { 0x01f1, 0x0144 },\n  { 0x01f2, 0x0148 },\n  { 0x01f5, 0x0151 },\n  { 0x01f8, 0x0159 },\n  { 0x01f9, 0x016f },\n  { 0x01fb, 0x0171 },\n  { 0x01fe, 0x0163 },\n  { 0x01ff, 0x02d9 },\n  { 0x02a1, 0x0126 },\n  { 0x02a6, 0x0124 },\n  { 0x02a9, 0x0130 },\n  { 0x02ab, 0x011e },\n  { 0x02ac, 0x0134 },\n  { 0x02b1, 0x0127 },\n  { 0x02b6, 0x0125 },\n  { 0x02b9, 0x0131 },\n  { 0x02bb, 0x011f },\n  { 0x02bc, 0x0135 },\n  { 0x02c5, 0x010a },\n  { 0x02c6, 0x0108 },\n  { 0x02d5, 0x0120 },\n  { 0x02d8, 0x011c },\n  { 0x02dd, 0x016c },\n  { 0x02de, 0x015c },\n  { 0x02e5, 0x010b },\n  { 0x02e6, 0x0109 },\n  { 0x02f5, 0x0121 },\n  { 0x02f8, 0x011d },\n  { 0x02fd, 0x016d },\n  { 0x02fe, 0x015d },\n  { 0x03a2, 0x0138 },\n  { 0x03a3, 0x0156 },\n  { 0x03a5, 0x0128 },\n  { 0x03a6, 0x013b },\n  { 0x03aa, 0x0112 },\n  { 0x03ab, 0x0122 },\n  { 0x03ac, 0x0166 },\n  { 0x03b3, 0x0157 },\n  { 0x03b5, 0x0129 },\n  { 0x03b6, 0x013c },\n  { 0x03ba, 0x0113 },\n  { 0x03bb, 0x0123 },\n  { 0x03bc, 0x0167 },\n  { 0x03bd, 0x014a },\n  { 0x03bf, 0x014b },\n  { 0x03c0, 0x0100 },\n  { 0x03c7, 0x012e },\n  { 0x03cc, 0x0116 },\n  { 0x03cf, 0x012a },\n  { 0x03d1, 0x0145 },\n  { 0x03d2, 0x014c },\n  { 0x03d3, 0x0136 },\n  { 0x03d9, 0x0172 },\n  { 0x03dd, 0x0168 },\n  { 0x03de, 0x016a },\n  { 0x03e0, 0x0101 },\n  { 0x03e7, 0x012f },\n  { 0x03ec, 0x0117 },\n  { 0x03ef, 0x012b },\n  { 0x03f1, 0x0146 },\n  { 0x03f2, 0x014d },\n  { 0x03f3, 0x0137 },\n  { 0x03f9, 0x0173 },\n  { 0x03fd, 0x0169 },\n  { 0x03fe, 0x016b },\n  { 0x047e, 0x203e },\n  { 0x04a1, 0x3002 },\n  { 0x04a2, 0x300c },\n  { 0x04a3, 0x300d },\n  { 0x04a4, 0x3001 },\n  { 0x04a5, 0x30fb },\n  { 0x04a6, 0x30f2 },\n  { 0x04a7, 0x30a1 },\n  { 0x04a8, 0x30a3 },\n  { 0x04a9, 0x30a5 },\n  { 0x04aa, 0x30a7 },\n  { 0x04ab, 0x30a9 },\n  { 0x04ac, 0x30e3 },\n  { 0x04ad, 0x30e5 },\n  { 0x04ae, 0x30e7 },\n  { 0x04af, 0x30c3 },\n  { 0x04b0, 0x30fc },\n  { 0x04b1, 0x30a2 },\n  { 0x04b2, 0x30a4 },\n  { 0x04b3, 0x30a6 },\n  { 0x04b4, 0x30a8 },\n  { 0x04b5, 0x30aa },\n  { 0x04b6, 0x30ab },\n  { 0x04b7, 0x30ad },\n  { 0x04b8, 0x30af },\n  { 0x04b9, 0x30b1 },\n  { 0x04ba, 0x30b3 },\n  { 0x04bb, 0x30b5 },\n  { 0x04bc, 0x30b7 },\n  { 0x04bd, 0x30b9 },\n  { 0x04be, 0x30bb },\n  { 0x04bf, 0x30bd },\n  { 0x04c0, 0x30bf },\n  { 0x04c1, 0x30c1 },\n  { 0x04c2, 0x30c4 },\n  { 0x04c3, 0x30c6 },\n  { 0x04c4, 0x30c8 },\n  { 0x04c5, 0x30ca },\n  { 0x04c6, 0x30cb },\n  { 0x04c7, 0x30cc },\n  { 0x04c8, 0x30cd },\n  { 0x04c9, 0x30ce },\n  { 0x04ca, 0x30cf },\n  { 0x04cb, 0x30d2 },\n  { 0x04cc, 0x30d5 },\n  { 0x04cd, 0x30d8 },\n  { 0x04ce, 0x30db },\n  { 0x04cf, 0x30de },\n  { 0x04d0, 0x30df },\n  { 0x04d1, 0x30e0 },\n  { 0x04d2, 0x30e1 },\n  { 0x04d3, 0x30e2 },\n  { 0x04d4, 0x30e4 },\n  { 0x04d5, 0x30e6 },\n  { 0x04d6, 0x30e8 },\n  { 0x04d7, 0x30e9 },\n  { 0x04d8, 0x30ea },\n  { 0x04d9, 0x30eb },\n  { 0x04da, 0x30ec },\n  { 0x04db, 0x30ed },\n  { 0x04dc, 0x30ef },\n  { 0x04dd, 0x30f3 },\n  { 0x04de, 0x309b },\n  { 0x04df, 0x309c },\n  { 0x05ac, 0x060c },\n  { 0x05bb, 0x061b },\n  { 0x05bf, 0x061f },\n  { 0x05c1, 0x0621 },\n  { 0x05c2, 0x0622 },\n  { 0x05c3, 0x0623 },\n  { 0x05c4, 0x0624 },\n  { 0x05c5, 0x0625 },\n  { 0x05c6, 0x0626 },\n  { 0x05c7, 0x0627 },\n  { 0x05c8, 0x0628 },\n  { 0x05c9, 0x0629 },\n  { 0x05ca, 0x062a },\n  { 0x05cb, 0x062b },\n  { 0x05cc, 0x062c },\n  { 0x05cd, 0x062d },\n  { 0x05ce, 0x062e },\n  { 0x05cf, 0x062f },\n  { 0x05d0, 0x0630 },\n  { 0x05d1, 0x0631 },\n  { 0x05d2, 0x0632 },\n  { 0x05d3, 0x0633 },\n  { 0x05d4, 0x0634 },\n  { 0x05d5, 0x0635 },\n  { 0x05d6, 0x0636 },\n  { 0x05d7, 0x0637 },\n  { 0x05d8, 0x0638 },\n  { 0x05d9, 0x0639 },\n  { 0x05da, 0x063a },\n  { 0x05e0, 0x0640 },\n  { 0x05e1, 0x0641 },\n  { 0x05e2, 0x0642 },\n  { 0x05e3, 0x0643 },\n  { 0x05e4, 0x0644 },\n  { 0x05e5, 0x0645 },\n  { 0x05e6, 0x0646 },\n  { 0x05e7, 0x0647 },\n  { 0x05e8, 0x0648 },\n  { 0x05e9, 0x0649 },\n  { 0x05ea, 0x064a },\n  { 0x05eb, 0x064b },\n  { 0x05ec, 0x064c },\n  { 0x05ed, 0x064d },\n  { 0x05ee, 0x064e },\n  { 0x05ef, 0x064f },\n  { 0x05f0, 0x0650 },\n  { 0x05f1, 0x0651 },\n  { 0x05f2, 0x0652 },\n  { 0x06a1, 0x0452 },\n  { 0x06a2, 0x0453 },\n  { 0x06a3, 0x0451 },\n  { 0x06a4, 0x0454 },\n  { 0x06a5, 0x0455 },\n  { 0x06a6, 0x0456 },\n  { 0x06a7, 0x0457 },\n  { 0x06a8, 0x0458 },\n  { 0x06a9, 0x0459 },\n  { 0x06aa, 0x045a },\n  { 0x06ab, 0x045b },\n  { 0x06ac, 0x045c },\n  { 0x06ae, 0x045e },\n  { 0x06af, 0x045f },\n  { 0x06b0, 0x2116 },\n  { 0x06b1, 0x0402 },\n  { 0x06b2, 0x0403 },\n  { 0x06b3, 0x0401 },\n  { 0x06b4, 0x0404 },\n  { 0x06b5, 0x0405 },\n  { 0x06b6, 0x0406 },\n  { 0x06b7, 0x0407 },\n  { 0x06b8, 0x0408 },\n  { 0x06b9, 0x0409 },\n  { 0x06ba, 0x040a },\n  { 0x06bb, 0x040b },\n  { 0x06bc, 0x040c },\n  { 0x06be, 0x040e },\n  { 0x06bf, 0x040f },\n  { 0x06c0, 0x044e },\n  { 0x06c1, 0x0430 },\n  { 0x06c2, 0x0431 },\n  { 0x06c3, 0x0446 },\n  { 0x06c4, 0x0434 },\n  { 0x06c5, 0x0435 },\n  { 0x06c6, 0x0444 },\n  { 0x06c7, 0x0433 },\n  { 0x06c8, 0x0445 },\n  { 0x06c9, 0x0438 },\n  { 0x06ca, 0x0439 },\n  { 0x06cb, 0x043a },\n  { 0x06cc, 0x043b },\n  { 0x06cd, 0x043c },\n  { 0x06ce, 0x043d },\n  { 0x06cf, 0x043e },\n  { 0x06d0, 0x043f },\n  { 0x06d1, 0x044f },\n  { 0x06d2, 0x0440 },\n  { 0x06d3, 0x0441 },\n  { 0x06d4, 0x0442 },\n  { 0x06d5, 0x0443 },\n  { 0x06d6, 0x0436 },\n  { 0x06d7, 0x0432 },\n  { 0x06d8, 0x044c },\n  { 0x06d9, 0x044b },\n  { 0x06da, 0x0437 },\n  { 0x06db, 0x0448 },\n  { 0x06dc, 0x044d },\n  { 0x06dd, 0x0449 },\n  { 0x06de, 0x0447 },\n  { 0x06df, 0x044a },\n  { 0x06e0, 0x042e },\n  { 0x06e1, 0x0410 },\n  { 0x06e2, 0x0411 },\n  { 0x06e3, 0x0426 },\n  { 0x06e4, 0x0414 },\n  { 0x06e5, 0x0415 },\n  { 0x06e6, 0x0424 },\n  { 0x06e7, 0x0413 },\n  { 0x06e8, 0x0425 },\n  { 0x06e9, 0x0418 },\n  { 0x06ea, 0x0419 },\n  { 0x06eb, 0x041a },\n  { 0x06ec, 0x041b },\n  { 0x06ed, 0x041c },\n  { 0x06ee, 0x041d },\n  { 0x06ef, 0x041e },\n  { 0x06f0, 0x041f },\n  { 0x06f1, 0x042f },\n  { 0x06f2, 0x0420 },\n  { 0x06f3, 0x0421 },\n  { 0x06f4, 0x0422 },\n  { 0x06f5, 0x0423 },\n  { 0x06f6, 0x0416 },\n  { 0x06f7, 0x0412 },\n  { 0x06f8, 0x042c },\n  { 0x06f9, 0x042b },\n  { 0x06fa, 0x0417 },\n  { 0x06fb, 0x0428 },\n  { 0x06fc, 0x042d },\n  { 0x06fd, 0x0429 },\n  { 0x06fe, 0x0427 },\n  { 0x06ff, 0x042a },\n  { 0x07a1, 0x0386 },\n  { 0x07a2, 0x0388 },\n  { 0x07a3, 0x0389 },\n  { 0x07a4, 0x038a },\n  { 0x07a5, 0x03aa },\n  { 0x07a7, 0x038c },\n  { 0x07a8, 0x038e },\n  { 0x07a9, 0x03ab },\n  { 0x07ab, 0x038f },\n  { 0x07ae, 0x0385 },\n  { 0x07af, 0x2015 },\n  { 0x07b1, 0x03ac },\n  { 0x07b2, 0x03ad },\n  { 0x07b3, 0x03ae },\n  { 0x07b4, 0x03af },\n  { 0x07b5, 0x03ca },\n  { 0x07b6, 0x0390 },\n  { 0x07b7, 0x03cc },\n  { 0x07b8, 0x03cd },\n  { 0x07b9, 0x03cb },\n  { 0x07ba, 0x03b0 },\n  { 0x07bb, 0x03ce },\n  { 0x07c1, 0x0391 },\n  { 0x07c2, 0x0392 },\n  { 0x07c3, 0x0393 },\n  { 0x07c4, 0x0394 },\n  { 0x07c5, 0x0395 },\n  { 0x07c6, 0x0396 },\n  { 0x07c7, 0x0397 },\n  { 0x07c8, 0x0398 },\n  { 0x07c9, 0x0399 },\n  { 0x07ca, 0x039a },\n  { 0x07cb, 0x039b },\n  { 0x07cc, 0x039c },\n  { 0x07cd, 0x039d },\n  { 0x07ce, 0x039e },\n  { 0x07cf, 0x039f },\n  { 0x07d0, 0x03a0 },\n  { 0x07d1, 0x03a1 },\n  { 0x07d2, 0x03a3 },\n  { 0x07d4, 0x03a4 },\n  { 0x07d5, 0x03a5 },\n  { 0x07d6, 0x03a6 },\n  { 0x07d7, 0x03a7 },\n  { 0x07d8, 0x03a8 },\n  { 0x07d9, 0x03a9 },\n  { 0x07e1, 0x03b1 },\n  { 0x07e2, 0x03b2 },\n  { 0x07e3, 0x03b3 },\n  { 0x07e4, 0x03b4 },\n  { 0x07e5, 0x03b5 },\n  { 0x07e6, 0x03b6 },\n  { 0x07e7, 0x03b7 },\n  { 0x07e8, 0x03b8 },\n  { 0x07e9, 0x03b9 },\n  { 0x07ea, 0x03ba },\n  { 0x07eb, 0x03bb },\n  { 0x07ec, 0x03bc },\n  { 0x07ed, 0x03bd },\n  { 0x07ee, 0x03be },\n  { 0x07ef, 0x03bf },\n  { 0x07f0, 0x03c0 },\n  { 0x07f1, 0x03c1 },\n  { 0x07f2, 0x03c3 },\n  { 0x07f3, 0x03c2 },\n  { 0x07f4, 0x03c4 },\n  { 0x07f5, 0x03c5 },\n  { 0x07f6, 0x03c6 },\n  { 0x07f7, 0x03c7 },\n  { 0x07f8, 0x03c8 },\n  { 0x07f9, 0x03c9 },\n  { 0x08a1, 0x23b7 },\n  { 0x08a2, 0x250c },\n  { 0x08a3, 0x2500 },\n  { 0x08a4, 0x2320 },\n  { 0x08a5, 0x2321 },\n  { 0x08a6, 0x2502 },\n  { 0x08a7, 0x23a1 },\n  { 0x08a8, 0x23a3 },\n  { 0x08a9, 0x23a4 },\n  { 0x08aa, 0x23a6 },\n  { 0x08ab, 0x239b },\n  { 0x08ac, 0x239d },\n  { 0x08ad, 0x239e },\n  { 0x08ae, 0x23a0 },\n  { 0x08af, 0x23a8 },\n  { 0x08b0, 0x23ac },\n  { 0x08bc, 0x2264 },\n  { 0x08bd, 0x2260 },\n  { 0x08be, 0x2265 },\n  { 0x08bf, 0x222b },\n  { 0x08c0, 0x2234 },\n  { 0x08c1, 0x221d },\n  { 0x08c2, 0x221e },\n  { 0x08c5, 0x2207 },\n  { 0x08c8, 0x223c },\n  { 0x08c9, 0x2243 },\n  { 0x08cd, 0x21d4 },\n  { 0x08ce, 0x21d2 },\n  { 0x08cf, 0x2261 },\n  { 0x08d6, 0x221a },\n  { 0x08da, 0x2282 },\n  { 0x08db, 0x2283 },\n  { 0x08dc, 0x2229 },\n  { 0x08dd, 0x222a },\n  { 0x08de, 0x2227 },\n  { 0x08df, 0x2228 },\n  { 0x08ef, 0x2202 },\n  { 0x08f6, 0x0192 },\n  { 0x08fb, 0x2190 },\n  { 0x08fc, 0x2191 },\n  { 0x08fd, 0x2192 },\n  { 0x08fe, 0x2193 },\n  { 0x09e0, 0x25c6 },\n  { 0x09e1, 0x2592 },\n  { 0x09e2, 0x2409 },\n  { 0x09e3, 0x240c },\n  { 0x09e4, 0x240d },\n  { 0x09e5, 0x240a },\n  { 0x09e8, 0x2424 },\n  { 0x09e9, 0x240b },\n  { 0x09ea, 0x2518 },\n  { 0x09eb, 0x2510 },\n  { 0x09ec, 0x250c },\n  { 0x09ed, 0x2514 },\n  { 0x09ee, 0x253c },\n  { 0x09ef, 0x23ba },\n  { 0x09f0, 0x23bb },\n  { 0x09f1, 0x2500 },\n  { 0x09f2, 0x23bc },\n  { 0x09f3, 0x23bd },\n  { 0x09f4, 0x251c },\n  { 0x09f5, 0x2524 },\n  { 0x09f6, 0x2534 },\n  { 0x09f7, 0x252c },\n  { 0x09f8, 0x2502 },\n  { 0x0aa1, 0x2003 },\n  { 0x0aa2, 0x2002 },\n  { 0x0aa3, 0x2004 },\n  { 0x0aa4, 0x2005 },\n  { 0x0aa5, 0x2007 },\n  { 0x0aa6, 0x2008 },\n  { 0x0aa7, 0x2009 },\n  { 0x0aa8, 0x200a },\n  { 0x0aa9, 0x2014 },\n  { 0x0aaa, 0x2013 },\n  { 0x0aae, 0x2026 },\n  { 0x0aaf, 0x2025 },\n  { 0x0ab0, 0x2153 },\n  { 0x0ab1, 0x2154 },\n  { 0x0ab2, 0x2155 },\n  { 0x0ab3, 0x2156 },\n  { 0x0ab4, 0x2157 },\n  { 0x0ab5, 0x2158 },\n  { 0x0ab6, 0x2159 },\n  { 0x0ab7, 0x215a },\n  { 0x0ab8, 0x2105 },\n  { 0x0abb, 0x2012 },\n  { 0x0abc, 0x2329 },\n  { 0x0abe, 0x232a },\n  { 0x0ac3, 0x215b },\n  { 0x0ac4, 0x215c },\n  { 0x0ac5, 0x215d },\n  { 0x0ac6, 0x215e },\n  { 0x0ac9, 0x2122 },\n  { 0x0aca, 0x2613 },\n  { 0x0acc, 0x25c1 },\n  { 0x0acd, 0x25b7 },\n  { 0x0ace, 0x25cb },\n  { 0x0acf, 0x25af },\n  { 0x0ad0, 0x2018 },\n  { 0x0ad1, 0x2019 },\n  { 0x0ad2, 0x201c },\n  { 0x0ad3, 0x201d },\n  { 0x0ad4, 0x211e },\n  { 0x0ad6, 0x2032 },\n  { 0x0ad7, 0x2033 },\n  { 0x0ad9, 0x271d },\n  { 0x0adb, 0x25ac },\n  { 0x0adc, 0x25c0 },\n  { 0x0add, 0x25b6 },\n  { 0x0ade, 0x25cf },\n  { 0x0adf, 0x25ae },\n  { 0x0ae0, 0x25e6 },\n  { 0x0ae1, 0x25ab },\n  { 0x0ae2, 0x25ad },\n  { 0x0ae3, 0x25b3 },\n  { 0x0ae4, 0x25bd },\n  { 0x0ae5, 0x2606 },\n  { 0x0ae6, 0x2022 },\n  { 0x0ae7, 0x25aa },\n  { 0x0ae8, 0x25b2 },\n  { 0x0ae9, 0x25bc },\n  { 0x0aea, 0x261c },\n  { 0x0aeb, 0x261e },\n  { 0x0aec, 0x2663 },\n  { 0x0aed, 0x2666 },\n  { 0x0aee, 0x2665 },\n  { 0x0af0, 0x2720 },\n  { 0x0af1, 0x2020 },\n  { 0x0af2, 0x2021 },\n  { 0x0af3, 0x2713 },\n  { 0x0af4, 0x2717 },\n  { 0x0af5, 0x266f },\n  { 0x0af6, 0x266d },\n  { 0x0af7, 0x2642 },\n  { 0x0af8, 0x2640 },\n  { 0x0af9, 0x260e },\n  { 0x0afa, 0x2315 },\n  { 0x0afb, 0x2117 },\n  { 0x0afc, 0x2038 },\n  { 0x0afd, 0x201a },\n  { 0x0afe, 0x201e },\n  { 0x0ba3, 0x003c },\n  { 0x0ba6, 0x003e },\n  { 0x0ba8, 0x2228 },\n  { 0x0ba9, 0x2227 },\n  { 0x0bc0, 0x00af },\n  { 0x0bc2, 0x22a5 },\n  { 0x0bc3, 0x2229 },\n  { 0x0bc4, 0x230a },\n  { 0x0bc6, 0x005f },\n  { 0x0bca, 0x2218 },\n  { 0x0bcc, 0x2395 },\n  { 0x0bce, 0x22a4 },\n  { 0x0bcf, 0x25cb },\n  { 0x0bd3, 0x2308 },\n  { 0x0bd6, 0x222a },\n  { 0x0bd8, 0x2283 },\n  { 0x0bda, 0x2282 },\n  { 0x0bdc, 0x22a2 },\n  { 0x0bfc, 0x22a3 },\n  { 0x0cdf, 0x2017 },\n  { 0x0ce0, 0x05d0 },\n  { 0x0ce1, 0x05d1 },\n  { 0x0ce2, 0x05d2 },\n  { 0x0ce3, 0x05d3 },\n  { 0x0ce4, 0x05d4 },\n  { 0x0ce5, 0x05d5 },\n  { 0x0ce6, 0x05d6 },\n  { 0x0ce7, 0x05d7 },\n  { 0x0ce8, 0x05d8 },\n  { 0x0ce9, 0x05d9 },\n  { 0x0cea, 0x05da },\n  { 0x0ceb, 0x05db },\n  { 0x0cec, 0x05dc },\n  { 0x0ced, 0x05dd },\n  { 0x0cee, 0x05de },\n  { 0x0cef, 0x05df },\n  { 0x0cf0, 0x05e0 },\n  { 0x0cf1, 0x05e1 },\n  { 0x0cf2, 0x05e2 },\n  { 0x0cf3, 0x05e3 },\n  { 0x0cf4, 0x05e4 },\n  { 0x0cf5, 0x05e5 },\n  { 0x0cf6, 0x05e6 },\n  { 0x0cf7, 0x05e7 },\n  { 0x0cf8, 0x05e8 },\n  { 0x0cf9, 0x05e9 },\n  { 0x0cfa, 0x05ea },\n  { 0x0da1, 0x0e01 },\n  { 0x0da2, 0x0e02 },\n  { 0x0da3, 0x0e03 },\n  { 0x0da4, 0x0e04 },\n  { 0x0da5, 0x0e05 },\n  { 0x0da6, 0x0e06 },\n  { 0x0da7, 0x0e07 },\n  { 0x0da8, 0x0e08 },\n  { 0x0da9, 0x0e09 },\n  { 0x0daa, 0x0e0a },\n  { 0x0dab, 0x0e0b },\n  { 0x0dac, 0x0e0c },\n  { 0x0dad, 0x0e0d },\n  { 0x0dae, 0x0e0e },\n  { 0x0daf, 0x0e0f },\n  { 0x0db0, 0x0e10 },\n  { 0x0db1, 0x0e11 },\n  { 0x0db2, 0x0e12 },\n  { 0x0db3, 0x0e13 },\n  { 0x0db4, 0x0e14 },\n  { 0x0db5, 0x0e15 },\n  { 0x0db6, 0x0e16 },\n  { 0x0db7, 0x0e17 },\n  { 0x0db8, 0x0e18 },\n  { 0x0db9, 0x0e19 },\n  { 0x0dba, 0x0e1a },\n  { 0x0dbb, 0x0e1b },\n  { 0x0dbc, 0x0e1c },\n  { 0x0dbd, 0x0e1d },\n  { 0x0dbe, 0x0e1e },\n  { 0x0dbf, 0x0e1f },\n  { 0x0dc0, 0x0e20 },\n  { 0x0dc1, 0x0e21 },\n  { 0x0dc2, 0x0e22 },\n  { 0x0dc3, 0x0e23 },\n  { 0x0dc4, 0x0e24 },\n  { 0x0dc5, 0x0e25 },\n  { 0x0dc6, 0x0e26 },\n  { 0x0dc7, 0x0e27 },\n  { 0x0dc8, 0x0e28 },\n  { 0x0dc9, 0x0e29 },\n  { 0x0dca, 0x0e2a },\n  { 0x0dcb, 0x0e2b },\n  { 0x0dcc, 0x0e2c },\n  { 0x0dcd, 0x0e2d },\n  { 0x0dce, 0x0e2e },\n  { 0x0dcf, 0x0e2f },\n  { 0x0dd0, 0x0e30 },\n  { 0x0dd1, 0x0e31 },\n  { 0x0dd2, 0x0e32 },\n  { 0x0dd3, 0x0e33 },\n  { 0x0dd4, 0x0e34 },\n  { 0x0dd5, 0x0e35 },\n  { 0x0dd6, 0x0e36 },\n  { 0x0dd7, 0x0e37 },\n  { 0x0dd8, 0x0e38 },\n  { 0x0dd9, 0x0e39 },\n  { 0x0dda, 0x0e3a },\n  { 0x0ddf, 0x0e3f },\n  { 0x0de0, 0x0e40 },\n  { 0x0de1, 0x0e41 },\n  { 0x0de2, 0x0e42 },\n  { 0x0de3, 0x0e43 },\n  { 0x0de4, 0x0e44 },\n  { 0x0de5, 0x0e45 },\n  { 0x0de6, 0x0e46 },\n  { 0x0de7, 0x0e47 },\n  { 0x0de8, 0x0e48 },\n  { 0x0de9, 0x0e49 },\n  { 0x0dea, 0x0e4a },\n  { 0x0deb, 0x0e4b },\n  { 0x0dec, 0x0e4c },\n  { 0x0ded, 0x0e4d },\n  { 0x0df0, 0x0e50 },\n  { 0x0df1, 0x0e51 },\n  { 0x0df2, 0x0e52 },\n  { 0x0df3, 0x0e53 },\n  { 0x0df4, 0x0e54 },\n  { 0x0df5, 0x0e55 },\n  { 0x0df6, 0x0e56 },\n  { 0x0df7, 0x0e57 },\n  { 0x0df8, 0x0e58 },\n  { 0x0df9, 0x0e59 },\n  { 0x0ea1, 0x3131 },\n  { 0x0ea2, 0x3132 },\n  { 0x0ea3, 0x3133 },\n  { 0x0ea4, 0x3134 },\n  { 0x0ea5, 0x3135 },\n  { 0x0ea6, 0x3136 },\n  { 0x0ea7, 0x3137 },\n  { 0x0ea8, 0x3138 },\n  { 0x0ea9, 0x3139 },\n  { 0x0eaa, 0x313a },\n  { 0x0eab, 0x313b },\n  { 0x0eac, 0x313c },\n  { 0x0ead, 0x313d },\n  { 0x0eae, 0x313e },\n  { 0x0eaf, 0x313f },\n  { 0x0eb0, 0x3140 },\n  { 0x0eb1, 0x3141 },\n  { 0x0eb2, 0x3142 },\n  { 0x0eb3, 0x3143 },\n  { 0x0eb4, 0x3144 },\n  { 0x0eb5, 0x3145 },\n  { 0x0eb6, 0x3146 },\n  { 0x0eb7, 0x3147 },\n  { 0x0eb8, 0x3148 },\n  { 0x0eb9, 0x3149 },\n  { 0x0eba, 0x314a },\n  { 0x0ebb, 0x314b },\n  { 0x0ebc, 0x314c },\n  { 0x0ebd, 0x314d },\n  { 0x0ebe, 0x314e },\n  { 0x0ebf, 0x314f },\n  { 0x0ec0, 0x3150 },\n  { 0x0ec1, 0x3151 },\n  { 0x0ec2, 0x3152 },\n  { 0x0ec3, 0x3153 },\n  { 0x0ec4, 0x3154 },\n  { 0x0ec5, 0x3155 },\n  { 0x0ec6, 0x3156 },\n  { 0x0ec7, 0x3157 },\n  { 0x0ec8, 0x3158 },\n  { 0x0ec9, 0x3159 },\n  { 0x0eca, 0x315a },\n  { 0x0ecb, 0x315b },\n  { 0x0ecc, 0x315c },\n  { 0x0ecd, 0x315d },\n  { 0x0ece, 0x315e },\n  { 0x0ecf, 0x315f },\n  { 0x0ed0, 0x3160 },\n  { 0x0ed1, 0x3161 },\n  { 0x0ed2, 0x3162 },\n  { 0x0ed3, 0x3163 },\n  { 0x0ed4, 0x11a8 },\n  { 0x0ed5, 0x11a9 },\n  { 0x0ed6, 0x11aa },\n  { 0x0ed7, 0x11ab },\n  { 0x0ed8, 0x11ac },\n  { 0x0ed9, 0x11ad },\n  { 0x0eda, 0x11ae },\n  { 0x0edb, 0x11af },\n  { 0x0edc, 0x11b0 },\n  { 0x0edd, 0x11b1 },\n  { 0x0ede, 0x11b2 },\n  { 0x0edf, 0x11b3 },\n  { 0x0ee0, 0x11b4 },\n  { 0x0ee1, 0x11b5 },\n  { 0x0ee2, 0x11b6 },\n  { 0x0ee3, 0x11b7 },\n  { 0x0ee4, 0x11b8 },\n  { 0x0ee5, 0x11b9 },\n  { 0x0ee6, 0x11ba },\n  { 0x0ee7, 0x11bb },\n  { 0x0ee8, 0x11bc },\n  { 0x0ee9, 0x11bd },\n  { 0x0eea, 0x11be },\n  { 0x0eeb, 0x11bf },\n  { 0x0eec, 0x11c0 },\n  { 0x0eed, 0x11c1 },\n  { 0x0eee, 0x11c2 },\n  { 0x0eef, 0x316d },\n  { 0x0ef0, 0x3171 },\n  { 0x0ef1, 0x3178 },\n  { 0x0ef2, 0x317f },\n  { 0x0ef3, 0x3181 },\n  { 0x0ef4, 0x3184 },\n  { 0x0ef5, 0x3186 },\n  { 0x0ef6, 0x318d },\n  { 0x0ef7, 0x318e },\n  { 0x0ef8, 0x11eb },\n  { 0x0ef9, 0x11f0 },\n  { 0x0efa, 0x11f9 },\n  { 0x0eff, 0x20a9 },\n  { 0x13a4, 0x20ac },\n  { 0x13bc, 0x0152 },\n  { 0x13bd, 0x0153 },\n  { 0x13be, 0x0178 },\n  { 0x20ac, 0x20ac },\n  { 0xfe50,    '`' },\n  { 0xfe51, 0x00b4 },\n  { 0xfe52,    '^' },\n  { 0xfe53,    '~' },\n  { 0xfe54, 0x00af },\n  { 0xfe55, 0x02d8 },\n  { 0xfe56, 0x02d9 },\n  { 0xfe57, 0x00a8 },\n  { 0xfe58, 0x02da },\n  { 0xfe59, 0x02dd },\n  { 0xfe5a, 0x02c7 },\n  { 0xfe5b, 0x00b8 },\n  { 0xfe5c, 0x02db },\n  { 0xfe5d, 0x037a },\n  { 0xfe5e, 0x309b },\n  { 0xfe5f, 0x309c },\n  { 0xfe63,    '/' },\n  { 0xfe64, 0x02bc },\n  { 0xfe65, 0x02bd },\n  { 0xfe66, 0x02f5 },\n  { 0xfe67, 0x02f3 },\n  { 0xfe68, 0x02cd },\n  { 0xfe69, 0xa788 },\n  { 0xfe6a, 0x02f7 },\n  { 0xfe6e,    ',' },\n  { 0xfe6f, 0x00a4 },\n  { 0xfe80,    'a' }, /* XK_dead_a */\n  { 0xfe81,    'A' }, /* XK_dead_A */\n  { 0xfe82,    'e' }, /* XK_dead_e */\n  { 0xfe83,    'E' }, /* XK_dead_E */\n  { 0xfe84,    'i' }, /* XK_dead_i */\n  { 0xfe85,    'I' }, /* XK_dead_I */\n  { 0xfe86,    'o' }, /* XK_dead_o */\n  { 0xfe87,    'O' }, /* XK_dead_O */\n  { 0xfe88,    'u' }, /* XK_dead_u */\n  { 0xfe89,    'U' }, /* XK_dead_U */\n  { 0xfe8a, 0x0259 },\n  { 0xfe8b, 0x018f },\n  { 0xfe8c, 0x00b5 },\n  { 0xfe90,    '_' },\n  { 0xfe91, 0x02c8 },\n  { 0xfe92, 0x02cc },\n  { 0xff80 /*XKB_KEY_KP_Space*/,     ' ' },\n  { 0xff95 /*XKB_KEY_KP_7*/, 0x0037 },\n  { 0xff96 /*XKB_KEY_KP_4*/, 0x0034 },\n  { 0xff97 /*XKB_KEY_KP_8*/, 0x0038 },\n  { 0xff98 /*XKB_KEY_KP_6*/, 0x0036 },\n  { 0xff99 /*XKB_KEY_KP_2*/, 0x0032 },\n  { 0xff9a /*XKB_KEY_KP_9*/, 0x0039 },\n  { 0xff9b /*XKB_KEY_KP_3*/, 0x0033 },\n  { 0xff9c /*XKB_KEY_KP_1*/, 0x0031 },\n  { 0xff9d /*XKB_KEY_KP_5*/, 0x0035 },\n  { 0xff9e /*XKB_KEY_KP_0*/, 0x0030 },\n  { 0xffaa /*XKB_KEY_KP_Multiply*/,  '*' },\n  { 0xffab /*XKB_KEY_KP_Add*/,       '+' },\n  { 0xffac /*XKB_KEY_KP_Separator*/, ',' },\n  { 0xffad /*XKB_KEY_KP_Subtract*/,  '-' },\n  { 0xffae /*XKB_KEY_KP_Decimal*/,   '.' },\n  { 0xffaf /*XKB_KEY_KP_Divide*/,    '/' },\n  { 0xffb0 /*XKB_KEY_KP_0*/, 0x0030 },\n  { 0xffb1 /*XKB_KEY_KP_1*/, 0x0031 },\n  { 0xffb2 /*XKB_KEY_KP_2*/, 0x0032 },\n  { 0xffb3 /*XKB_KEY_KP_3*/, 0x0033 },\n  { 0xffb4 /*XKB_KEY_KP_4*/, 0x0034 },\n  { 0xffb5 /*XKB_KEY_KP_5*/, 0x0035 },\n  { 0xffb6 /*XKB_KEY_KP_6*/, 0x0036 },\n  { 0xffb7 /*XKB_KEY_KP_7*/, 0x0037 },\n  { 0xffb8 /*XKB_KEY_KP_8*/, 0x0038 },\n  { 0xffb9 /*XKB_KEY_KP_9*/, 0x0039 },\n  { 0xffbd /*XKB_KEY_KP_Equal*/,     '=' }\n};\n\n_SOKOL_PRIVATE int _sapp_x11_error_handler(Display* display, XErrorEvent* event) {\n    _SOKOL_UNUSED(display);\n    _sapp.x11.error_code = event->error_code;\n    return 0;\n}\n\n_SOKOL_PRIVATE void _sapp_x11_grab_error_handler(void) {\n    _sapp.x11.error_code = Success;\n    XSetErrorHandler(_sapp_x11_error_handler);\n}\n\n_SOKOL_PRIVATE void _sapp_x11_release_error_handler(void) {\n    XSync(_sapp.x11.display, False);\n    XSetErrorHandler(NULL);\n}\n\n_SOKOL_PRIVATE void _sapp_x11_init_extensions(void) {\n    _sapp.x11.UTF8_STRING             = XInternAtom(_sapp.x11.display, \"UTF8_STRING\", False);\n    _sapp.x11.WM_PROTOCOLS            = XInternAtom(_sapp.x11.display, \"WM_PROTOCOLS\", False);\n    _sapp.x11.WM_DELETE_WINDOW        = XInternAtom(_sapp.x11.display, \"WM_DELETE_WINDOW\", False);\n    _sapp.x11.WM_STATE                = XInternAtom(_sapp.x11.display, \"WM_STATE\", False);\n    _sapp.x11.NET_WM_NAME             = XInternAtom(_sapp.x11.display, \"_NET_WM_NAME\", False);\n    _sapp.x11.NET_WM_ICON_NAME        = XInternAtom(_sapp.x11.display, \"_NET_WM_ICON_NAME\", False);\n    _sapp.x11.NET_WM_ICON             = XInternAtom(_sapp.x11.display, \"_NET_WM_ICON\", False);\n    _sapp.x11.NET_WM_STATE            = XInternAtom(_sapp.x11.display, \"_NET_WM_STATE\", False);\n    _sapp.x11.NET_WM_STATE_FULLSCREEN = XInternAtom(_sapp.x11.display, \"_NET_WM_STATE_FULLSCREEN\", False);\n    _sapp.x11.CLIPBOARD = XInternAtom(_sapp.x11.display, \"CLIPBOARD\", False);\n    _sapp.x11.TARGETS   = XInternAtom(_sapp.x11.display, \"TARGETS\", False);\n    if (_sapp.drop.enabled) {\n        _sapp.x11.xdnd.XdndAware        = XInternAtom(_sapp.x11.display, \"XdndAware\", False);\n        _sapp.x11.xdnd.XdndEnter        = XInternAtom(_sapp.x11.display, \"XdndEnter\", False);\n        _sapp.x11.xdnd.XdndPosition     = XInternAtom(_sapp.x11.display, \"XdndPosition\", False);\n        _sapp.x11.xdnd.XdndStatus       = XInternAtom(_sapp.x11.display, \"XdndStatus\", False);\n        _sapp.x11.xdnd.XdndActionCopy   = XInternAtom(_sapp.x11.display, \"XdndActionCopy\", False);\n        _sapp.x11.xdnd.XdndDrop         = XInternAtom(_sapp.x11.display, \"XdndDrop\", False);\n        _sapp.x11.xdnd.XdndFinished     = XInternAtom(_sapp.x11.display, \"XdndFinished\", False);\n        _sapp.x11.xdnd.XdndSelection    = XInternAtom(_sapp.x11.display, \"XdndSelection\", False);\n        _sapp.x11.xdnd.XdndTypeList     = XInternAtom(_sapp.x11.display, \"XdndTypeList\", False);\n        _sapp.x11.xdnd.text_uri_list    = XInternAtom(_sapp.x11.display, \"text/uri-list\", False);\n    }\n\n    /* check Xi extension for raw mouse input */\n    if (XQueryExtension(_sapp.x11.display, \"XInputExtension\", &_sapp.x11.xi.major_opcode, &_sapp.x11.xi.event_base, &_sapp.x11.xi.error_base)) {\n        _sapp.x11.xi.major = 2;\n        _sapp.x11.xi.minor = 0;\n        if (XIQueryVersion(_sapp.x11.display, &_sapp.x11.xi.major, &_sapp.x11.xi.minor) == Success) {\n            _sapp.x11.xi.available = true;\n        }\n    }\n}\n\n// translate the X11 KeySyms for a key to sokol-app key code\n// NOTE: this is only used as a fallback, in case the XBK method fails\n//       it is layout-dependent and will fail partially on most non-US layouts.\n//\n_SOKOL_PRIVATE sapp_keycode _sapp_x11_translate_keysyms(const KeySym* keysyms, int width) {\n    if (width > 1) {\n        switch (keysyms[1]) {\n            case XK_KP_0:           return SAPP_KEYCODE_KP_0;\n            case XK_KP_1:           return SAPP_KEYCODE_KP_1;\n            case XK_KP_2:           return SAPP_KEYCODE_KP_2;\n            case XK_KP_3:           return SAPP_KEYCODE_KP_3;\n            case XK_KP_4:           return SAPP_KEYCODE_KP_4;\n            case XK_KP_5:           return SAPP_KEYCODE_KP_5;\n            case XK_KP_6:           return SAPP_KEYCODE_KP_6;\n            case XK_KP_7:           return SAPP_KEYCODE_KP_7;\n            case XK_KP_8:           return SAPP_KEYCODE_KP_8;\n            case XK_KP_9:           return SAPP_KEYCODE_KP_9;\n            case XK_KP_Separator:\n            case XK_KP_Decimal:     return SAPP_KEYCODE_KP_DECIMAL;\n            case XK_KP_Equal:       return SAPP_KEYCODE_KP_EQUAL;\n            case XK_KP_Enter:       return SAPP_KEYCODE_KP_ENTER;\n            default:                break;\n        }\n    }\n\n    switch (keysyms[0]) {\n        case XK_Escape:         return SAPP_KEYCODE_ESCAPE;\n        case XK_Tab:            return SAPP_KEYCODE_TAB;\n        case XK_Shift_L:        return SAPP_KEYCODE_LEFT_SHIFT;\n        case XK_Shift_R:        return SAPP_KEYCODE_RIGHT_SHIFT;\n        case XK_Control_L:      return SAPP_KEYCODE_LEFT_CONTROL;\n        case XK_Control_R:      return SAPP_KEYCODE_RIGHT_CONTROL;\n        case XK_Meta_L:\n        case XK_Alt_L:          return SAPP_KEYCODE_LEFT_ALT;\n        case XK_Mode_switch: // Mapped to Alt_R on many keyboards\n        case XK_ISO_Level3_Shift: // AltGr on at least some machines\n        case XK_Meta_R:\n        case XK_Alt_R:          return SAPP_KEYCODE_RIGHT_ALT;\n        case XK_Super_L:        return SAPP_KEYCODE_LEFT_SUPER;\n        case XK_Super_R:        return SAPP_KEYCODE_RIGHT_SUPER;\n        case XK_Menu:           return SAPP_KEYCODE_MENU;\n        case XK_Num_Lock:       return SAPP_KEYCODE_NUM_LOCK;\n        case XK_Caps_Lock:      return SAPP_KEYCODE_CAPS_LOCK;\n        case XK_Print:          return SAPP_KEYCODE_PRINT_SCREEN;\n        case XK_Scroll_Lock:    return SAPP_KEYCODE_SCROLL_LOCK;\n        case XK_Pause:          return SAPP_KEYCODE_PAUSE;\n        case XK_Delete:         return SAPP_KEYCODE_DELETE;\n        case XK_BackSpace:      return SAPP_KEYCODE_BACKSPACE;\n        case XK_Return:         return SAPP_KEYCODE_ENTER;\n        case XK_Home:           return SAPP_KEYCODE_HOME;\n        case XK_End:            return SAPP_KEYCODE_END;\n        case XK_Page_Up:        return SAPP_KEYCODE_PAGE_UP;\n        case XK_Page_Down:      return SAPP_KEYCODE_PAGE_DOWN;\n        case XK_Insert:         return SAPP_KEYCODE_INSERT;\n        case XK_Left:           return SAPP_KEYCODE_LEFT;\n        case XK_Right:          return SAPP_KEYCODE_RIGHT;\n        case XK_Down:           return SAPP_KEYCODE_DOWN;\n        case XK_Up:             return SAPP_KEYCODE_UP;\n        case XK_F1:             return SAPP_KEYCODE_F1;\n        case XK_F2:             return SAPP_KEYCODE_F2;\n        case XK_F3:             return SAPP_KEYCODE_F3;\n        case XK_F4:             return SAPP_KEYCODE_F4;\n        case XK_F5:             return SAPP_KEYCODE_F5;\n        case XK_F6:             return SAPP_KEYCODE_F6;\n        case XK_F7:             return SAPP_KEYCODE_F7;\n        case XK_F8:             return SAPP_KEYCODE_F8;\n        case XK_F9:             return SAPP_KEYCODE_F9;\n        case XK_F10:            return SAPP_KEYCODE_F10;\n        case XK_F11:            return SAPP_KEYCODE_F11;\n        case XK_F12:            return SAPP_KEYCODE_F12;\n        case XK_F13:            return SAPP_KEYCODE_F13;\n        case XK_F14:            return SAPP_KEYCODE_F14;\n        case XK_F15:            return SAPP_KEYCODE_F15;\n        case XK_F16:            return SAPP_KEYCODE_F16;\n        case XK_F17:            return SAPP_KEYCODE_F17;\n        case XK_F18:            return SAPP_KEYCODE_F18;\n        case XK_F19:            return SAPP_KEYCODE_F19;\n        case XK_F20:            return SAPP_KEYCODE_F20;\n        case XK_F21:            return SAPP_KEYCODE_F21;\n        case XK_F22:            return SAPP_KEYCODE_F22;\n        case XK_F23:            return SAPP_KEYCODE_F23;\n        case XK_F24:            return SAPP_KEYCODE_F24;\n        case XK_F25:            return SAPP_KEYCODE_F25;\n\n        // numeric keypad\n        case XK_KP_Divide:      return SAPP_KEYCODE_KP_DIVIDE;\n        case XK_KP_Multiply:    return SAPP_KEYCODE_KP_MULTIPLY;\n        case XK_KP_Subtract:    return SAPP_KEYCODE_KP_SUBTRACT;\n        case XK_KP_Add:         return SAPP_KEYCODE_KP_ADD;\n\n        // these should have been detected in secondary keysym test above!\n        case XK_KP_Insert:      return SAPP_KEYCODE_KP_0;\n        case XK_KP_End:         return SAPP_KEYCODE_KP_1;\n        case XK_KP_Down:        return SAPP_KEYCODE_KP_2;\n        case XK_KP_Page_Down:   return SAPP_KEYCODE_KP_3;\n        case XK_KP_Left:        return SAPP_KEYCODE_KP_4;\n        case XK_KP_Right:       return SAPP_KEYCODE_KP_6;\n        case XK_KP_Home:        return SAPP_KEYCODE_KP_7;\n        case XK_KP_Up:          return SAPP_KEYCODE_KP_8;\n        case XK_KP_Page_Up:     return SAPP_KEYCODE_KP_9;\n        case XK_KP_Delete:      return SAPP_KEYCODE_KP_DECIMAL;\n        case XK_KP_Equal:       return SAPP_KEYCODE_KP_EQUAL;\n        case XK_KP_Enter:       return SAPP_KEYCODE_KP_ENTER;\n\n        // last resort: Check for printable keys (should not happen if the XKB\n        // extension is available). This will give a layout dependent mapping\n        // (which is wrong, and we may miss some keys, especially on non-US\n        // keyboards), but it's better than nothing...\n        case XK_a:              return SAPP_KEYCODE_A;\n        case XK_b:              return SAPP_KEYCODE_B;\n        case XK_c:              return SAPP_KEYCODE_C;\n        case XK_d:              return SAPP_KEYCODE_D;\n        case XK_e:              return SAPP_KEYCODE_E;\n        case XK_f:              return SAPP_KEYCODE_F;\n        case XK_g:              return SAPP_KEYCODE_G;\n        case XK_h:              return SAPP_KEYCODE_H;\n        case XK_i:              return SAPP_KEYCODE_I;\n        case XK_j:              return SAPP_KEYCODE_J;\n        case XK_k:              return SAPP_KEYCODE_K;\n        case XK_l:              return SAPP_KEYCODE_L;\n        case XK_m:              return SAPP_KEYCODE_M;\n        case XK_n:              return SAPP_KEYCODE_N;\n        case XK_o:              return SAPP_KEYCODE_O;\n        case XK_p:              return SAPP_KEYCODE_P;\n        case XK_q:              return SAPP_KEYCODE_Q;\n        case XK_r:              return SAPP_KEYCODE_R;\n        case XK_s:              return SAPP_KEYCODE_S;\n        case XK_t:              return SAPP_KEYCODE_T;\n        case XK_u:              return SAPP_KEYCODE_U;\n        case XK_v:              return SAPP_KEYCODE_V;\n        case XK_w:              return SAPP_KEYCODE_W;\n        case XK_x:              return SAPP_KEYCODE_X;\n        case XK_y:              return SAPP_KEYCODE_Y;\n        case XK_z:              return SAPP_KEYCODE_Z;\n        case XK_1:              return SAPP_KEYCODE_1;\n        case XK_2:              return SAPP_KEYCODE_2;\n        case XK_3:              return SAPP_KEYCODE_3;\n        case XK_4:              return SAPP_KEYCODE_4;\n        case XK_5:              return SAPP_KEYCODE_5;\n        case XK_6:              return SAPP_KEYCODE_6;\n        case XK_7:              return SAPP_KEYCODE_7;\n        case XK_8:              return SAPP_KEYCODE_8;\n        case XK_9:              return SAPP_KEYCODE_9;\n        case XK_0:              return SAPP_KEYCODE_0;\n        case XK_space:          return SAPP_KEYCODE_SPACE;\n        case XK_minus:          return SAPP_KEYCODE_MINUS;\n        case XK_equal:          return SAPP_KEYCODE_EQUAL;\n        case XK_bracketleft:    return SAPP_KEYCODE_LEFT_BRACKET;\n        case XK_bracketright:   return SAPP_KEYCODE_RIGHT_BRACKET;\n        case XK_backslash:      return SAPP_KEYCODE_BACKSLASH;\n        case XK_semicolon:      return SAPP_KEYCODE_SEMICOLON;\n        case XK_apostrophe:     return SAPP_KEYCODE_APOSTROPHE;\n        case XK_grave:          return SAPP_KEYCODE_GRAVE_ACCENT;\n        case XK_comma:          return SAPP_KEYCODE_COMMA;\n        case XK_period:         return SAPP_KEYCODE_PERIOD;\n        case XK_slash:          return SAPP_KEYCODE_SLASH;\n        case XK_less:           return SAPP_KEYCODE_WORLD_1; // At least in some layouts...\n        default:                break;\n    }\n\n    // no matching translation was found\n    return SAPP_KEYCODE_INVALID;\n}\n\n\n// setup dynamic keycode/scancode mapping tables, this is required\n// for getting layout-independent keycodes on X11.\n//\n// see GLFW x11_init.c/createKeyTables()\n_SOKOL_PRIVATE void _sapp_x11_init_keytable(void) {\n    for (int i = 0; i < SAPP_MAX_KEYCODES; i++) {\n        _sapp.keycodes[i] = SAPP_KEYCODE_INVALID;\n    }\n    // use XKB to determine physical key locations independently of the current keyboard layout\n    XkbDescPtr desc = XkbGetMap(_sapp.x11.display, 0, XkbUseCoreKbd);\n    SOKOL_ASSERT(desc);\n    XkbGetNames(_sapp.x11.display, XkbKeyNamesMask | XkbKeyAliasesMask, desc);\n\n    const int scancode_min = desc->min_key_code;\n    const int scancode_max = desc->max_key_code;\n\n    const struct { sapp_keycode key; const char* name; } keymap[] = {\n        { SAPP_KEYCODE_GRAVE_ACCENT, \"TLDE\" },\n        { SAPP_KEYCODE_1, \"AE01\" },\n        { SAPP_KEYCODE_2, \"AE02\" },\n        { SAPP_KEYCODE_3, \"AE03\" },\n        { SAPP_KEYCODE_4, \"AE04\" },\n        { SAPP_KEYCODE_5, \"AE05\" },\n        { SAPP_KEYCODE_6, \"AE06\" },\n        { SAPP_KEYCODE_7, \"AE07\" },\n        { SAPP_KEYCODE_8, \"AE08\" },\n        { SAPP_KEYCODE_9, \"AE09\" },\n        { SAPP_KEYCODE_0, \"AE10\" },\n        { SAPP_KEYCODE_MINUS, \"AE11\" },\n        { SAPP_KEYCODE_EQUAL, \"AE12\" },\n        { SAPP_KEYCODE_Q, \"AD01\" },\n        { SAPP_KEYCODE_W, \"AD02\" },\n        { SAPP_KEYCODE_E, \"AD03\" },\n        { SAPP_KEYCODE_R, \"AD04\" },\n        { SAPP_KEYCODE_T, \"AD05\" },\n        { SAPP_KEYCODE_Y, \"AD06\" },\n        { SAPP_KEYCODE_U, \"AD07\" },\n        { SAPP_KEYCODE_I, \"AD08\" },\n        { SAPP_KEYCODE_O, \"AD09\" },\n        { SAPP_KEYCODE_P, \"AD10\" },\n        { SAPP_KEYCODE_LEFT_BRACKET, \"AD11\" },\n        { SAPP_KEYCODE_RIGHT_BRACKET, \"AD12\" },\n        { SAPP_KEYCODE_A, \"AC01\" },\n        { SAPP_KEYCODE_S, \"AC02\" },\n        { SAPP_KEYCODE_D, \"AC03\" },\n        { SAPP_KEYCODE_F, \"AC04\" },\n        { SAPP_KEYCODE_G, \"AC05\" },\n        { SAPP_KEYCODE_H, \"AC06\" },\n        { SAPP_KEYCODE_J, \"AC07\" },\n        { SAPP_KEYCODE_K, \"AC08\" },\n        { SAPP_KEYCODE_L, \"AC09\" },\n        { SAPP_KEYCODE_SEMICOLON, \"AC10\" },\n        { SAPP_KEYCODE_APOSTROPHE, \"AC11\" },\n        { SAPP_KEYCODE_Z, \"AB01\" },\n        { SAPP_KEYCODE_X, \"AB02\" },\n        { SAPP_KEYCODE_C, \"AB03\" },\n        { SAPP_KEYCODE_V, \"AB04\" },\n        { SAPP_KEYCODE_B, \"AB05\" },\n        { SAPP_KEYCODE_N, \"AB06\" },\n        { SAPP_KEYCODE_M, \"AB07\" },\n        { SAPP_KEYCODE_COMMA, \"AB08\" },\n        { SAPP_KEYCODE_PERIOD, \"AB09\" },\n        { SAPP_KEYCODE_SLASH, \"AB10\" },\n        { SAPP_KEYCODE_BACKSLASH, \"BKSL\" },\n        { SAPP_KEYCODE_WORLD_1, \"LSGT\" },\n        { SAPP_KEYCODE_SPACE, \"SPCE\" },\n        { SAPP_KEYCODE_ESCAPE, \"ESC\" },\n        { SAPP_KEYCODE_ENTER, \"RTRN\" },\n        { SAPP_KEYCODE_TAB, \"TAB\" },\n        { SAPP_KEYCODE_BACKSPACE, \"BKSP\" },\n        { SAPP_KEYCODE_INSERT, \"INS\" },\n        { SAPP_KEYCODE_DELETE, \"DELE\" },\n        { SAPP_KEYCODE_RIGHT, \"RGHT\" },\n        { SAPP_KEYCODE_LEFT, \"LEFT\" },\n        { SAPP_KEYCODE_DOWN, \"DOWN\" },\n        { SAPP_KEYCODE_UP, \"UP\" },\n        { SAPP_KEYCODE_PAGE_UP, \"PGUP\" },\n        { SAPP_KEYCODE_PAGE_DOWN, \"PGDN\" },\n        { SAPP_KEYCODE_HOME, \"HOME\" },\n        { SAPP_KEYCODE_END, \"END\" },\n        { SAPP_KEYCODE_CAPS_LOCK, \"CAPS\" },\n        { SAPP_KEYCODE_SCROLL_LOCK, \"SCLK\" },\n        { SAPP_KEYCODE_NUM_LOCK, \"NMLK\" },\n        { SAPP_KEYCODE_PRINT_SCREEN, \"PRSC\" },\n        { SAPP_KEYCODE_PAUSE, \"PAUS\" },\n        { SAPP_KEYCODE_F1, \"FK01\" },\n        { SAPP_KEYCODE_F2, \"FK02\" },\n        { SAPP_KEYCODE_F3, \"FK03\" },\n        { SAPP_KEYCODE_F4, \"FK04\" },\n        { SAPP_KEYCODE_F5, \"FK05\" },\n        { SAPP_KEYCODE_F6, \"FK06\" },\n        { SAPP_KEYCODE_F7, \"FK07\" },\n        { SAPP_KEYCODE_F8, \"FK08\" },\n        { SAPP_KEYCODE_F9, \"FK09\" },\n        { SAPP_KEYCODE_F10, \"FK10\" },\n        { SAPP_KEYCODE_F11, \"FK11\" },\n        { SAPP_KEYCODE_F12, \"FK12\" },\n        { SAPP_KEYCODE_F13, \"FK13\" },\n        { SAPP_KEYCODE_F14, \"FK14\" },\n        { SAPP_KEYCODE_F15, \"FK15\" },\n        { SAPP_KEYCODE_F16, \"FK16\" },\n        { SAPP_KEYCODE_F17, \"FK17\" },\n        { SAPP_KEYCODE_F18, \"FK18\" },\n        { SAPP_KEYCODE_F19, \"FK19\" },\n        { SAPP_KEYCODE_F20, \"FK20\" },\n        { SAPP_KEYCODE_F21, \"FK21\" },\n        { SAPP_KEYCODE_F22, \"FK22\" },\n        { SAPP_KEYCODE_F23, \"FK23\" },\n        { SAPP_KEYCODE_F24, \"FK24\" },\n        { SAPP_KEYCODE_F25, \"FK25\" },\n        { SAPP_KEYCODE_KP_0, \"KP0\" },\n        { SAPP_KEYCODE_KP_1, \"KP1\" },\n        { SAPP_KEYCODE_KP_2, \"KP2\" },\n        { SAPP_KEYCODE_KP_3, \"KP3\" },\n        { SAPP_KEYCODE_KP_4, \"KP4\" },\n        { SAPP_KEYCODE_KP_5, \"KP5\" },\n        { SAPP_KEYCODE_KP_6, \"KP6\" },\n        { SAPP_KEYCODE_KP_7, \"KP7\" },\n        { SAPP_KEYCODE_KP_8, \"KP8\" },\n        { SAPP_KEYCODE_KP_9, \"KP9\" },\n        { SAPP_KEYCODE_KP_DECIMAL, \"KPDL\" },\n        { SAPP_KEYCODE_KP_DIVIDE, \"KPDV\" },\n        { SAPP_KEYCODE_KP_MULTIPLY, \"KPMU\" },\n        { SAPP_KEYCODE_KP_SUBTRACT, \"KPSU\" },\n        { SAPP_KEYCODE_KP_ADD, \"KPAD\" },\n        { SAPP_KEYCODE_KP_ENTER, \"KPEN\" },\n        { SAPP_KEYCODE_KP_EQUAL, \"KPEQ\" },\n        { SAPP_KEYCODE_LEFT_SHIFT, \"LFSH\" },\n        { SAPP_KEYCODE_LEFT_CONTROL, \"LCTL\" },\n        { SAPP_KEYCODE_LEFT_ALT, \"LALT\" },\n        { SAPP_KEYCODE_LEFT_SUPER, \"LWIN\" },\n        { SAPP_KEYCODE_RIGHT_SHIFT, \"RTSH\" },\n        { SAPP_KEYCODE_RIGHT_CONTROL, \"RCTL\" },\n        { SAPP_KEYCODE_RIGHT_ALT, \"RALT\" },\n        { SAPP_KEYCODE_RIGHT_ALT, \"LVL3\" },\n        { SAPP_KEYCODE_RIGHT_ALT, \"MDSW\" },\n        { SAPP_KEYCODE_RIGHT_SUPER, \"RWIN\" },\n        { SAPP_KEYCODE_MENU, \"MENU\" }\n    };\n    const int num_keymap_items = (int)(sizeof(keymap) / sizeof(keymap[0]));\n\n    // find X11 keycode to sokol-app key code mapping\n    for (int scancode = scancode_min; scancode <= scancode_max; scancode++) {\n        sapp_keycode key = SAPP_KEYCODE_INVALID;\n        for (int i = 0; i < num_keymap_items; i++) {\n            if (strncmp(desc->names->keys[scancode].name, keymap[i].name, XkbKeyNameLength) == 0) {\n                key = keymap[i].key;\n                break;\n            }\n        }\n\n        // fall back to key aliases in case the key name did not match\n        for (int i = 0; i < desc->names->num_key_aliases; i++) {\n            if (key != SAPP_KEYCODE_INVALID) {\n                break;\n            }\n            if (strncmp(desc->names->key_aliases[i].real, desc->names->keys[scancode].name, XkbKeyNameLength) != 0) {\n                continue;\n            }\n            for (int j = 0; j < num_keymap_items; j++) {\n                if (strncmp(desc->names->key_aliases[i].alias, keymap[i].name, XkbKeyNameLength) == 0) {\n                    key = keymap[i].key;\n                    break;\n                }\n            }\n        }\n        _sapp.keycodes[scancode] = key;\n    }\n    XkbFreeNames(desc, XkbKeyNamesMask, True);\n    XkbFreeKeyboard(desc, 0, True);\n\n    int width = 0;\n    KeySym* keysyms = XGetKeyboardMapping(_sapp.x11.display, scancode_min, scancode_max - scancode_min + 1, &width);\n    for (int scancode = scancode_min; scancode <= scancode_max; scancode++) {\n        // translate untranslated key codes using the traditional X11 KeySym lookups\n        if (_sapp.keycodes[scancode] == SAPP_KEYCODE_INVALID) {\n            const size_t base = (size_t)((scancode - scancode_min) * width);\n            _sapp.keycodes[scancode] = _sapp_x11_translate_keysyms(&keysyms[base], width);\n        }\n    }\n    XFree(keysyms);\n}\n\n_SOKOL_PRIVATE void _sapp_x11_query_system_dpi(void) {\n    /* from GLFW:\n\n       NOTE: Default to the display-wide DPI as we don't currently have a policy\n             for which monitor a window is considered to be on\n\n        _sapp.x11.dpi = DisplayWidth(_sapp.x11.display, _sapp.x11.screen) *\n                        25.4f / DisplayWidthMM(_sapp.x11.display, _sapp.x11.screen);\n\n       NOTE: Basing the scale on Xft.dpi where available should provide the most\n             consistent user experience (matches Qt, Gtk, etc), although not\n             always the most accurate one\n    */\n    bool dpi_ok = false;\n    char* rms = XResourceManagerString(_sapp.x11.display);\n    if (rms) {\n        XrmDatabase db = XrmGetStringDatabase(rms);\n        if (db) {\n            XrmValue value;\n            char* type = NULL;\n            if (XrmGetResource(db, \"Xft.dpi\", \"Xft.Dpi\", &type, &value)) {\n                if (type && strcmp(type, \"String\") == 0) {\n                    _sapp.x11.dpi = atof(value.addr);\n                    dpi_ok = true;\n                }\n            }\n            XrmDestroyDatabase(db);\n        }\n    }\n    // fallback if querying DPI had failed: assume the standard DPI 96.0f\n    if (!dpi_ok) {\n        _sapp.x11.dpi = 96.0f;\n        _SAPP_WARN(LINUX_X11_QUERY_SYSTEM_DPI_FAILED);\n    }\n}\n\n#if defined(_SAPP_GLX)\n\n_SOKOL_PRIVATE bool _sapp_glx_has_ext(const char* ext, const char* extensions) {\n    SOKOL_ASSERT(ext);\n    const char* start = extensions;\n    while (true) {\n        const char* where = strstr(start, ext);\n        if (!where) {\n            return false;\n        }\n        const char* terminator = where + strlen(ext);\n        if ((where == start) || (*(where - 1) == ' ')) {\n            if (*terminator == ' ' || *terminator == '\\0') {\n                break;\n            }\n        }\n        start = terminator;\n    }\n    return true;\n}\n\n_SOKOL_PRIVATE bool _sapp_glx_extsupported(const char* ext, const char* extensions) {\n    if (extensions) {\n        return _sapp_glx_has_ext(ext, extensions);\n    }\n    else {\n        return false;\n    }\n}\n\n_SOKOL_PRIVATE void* _sapp_glx_getprocaddr(const char* procname)\n{\n    if (_sapp.glx.GetProcAddress) {\n        return (void*) _sapp.glx.GetProcAddress(procname);\n    }\n    else if (_sapp.glx.GetProcAddressARB) {\n        return (void*) _sapp.glx.GetProcAddressARB(procname);\n    }\n    else {\n        return dlsym(_sapp.glx.libgl, procname);\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_glx_init(void) {\n    const char* sonames[] = { \"libGL.so.1\", \"libGL.so\", 0 };\n    for (int i = 0; sonames[i]; i++) {\n        _sapp.glx.libgl = dlopen(sonames[i], RTLD_LAZY|RTLD_GLOBAL);\n        if (_sapp.glx.libgl) {\n            break;\n        }\n    }\n    if (!_sapp.glx.libgl) {\n        _SAPP_PANIC(LINUX_GLX_LOAD_LIBGL_FAILED);\n    }\n    _sapp.glx.GetFBConfigs          = (PFNGLXGETFBCONFIGSPROC)          dlsym(_sapp.glx.libgl, \"glXGetFBConfigs\");\n    _sapp.glx.GetFBConfigAttrib     = (PFNGLXGETFBCONFIGATTRIBPROC)     dlsym(_sapp.glx.libgl, \"glXGetFBConfigAttrib\");\n    _sapp.glx.GetClientString       = (PFNGLXGETCLIENTSTRINGPROC)       dlsym(_sapp.glx.libgl, \"glXGetClientString\");\n    _sapp.glx.QueryExtension        = (PFNGLXQUERYEXTENSIONPROC)        dlsym(_sapp.glx.libgl, \"glXQueryExtension\");\n    _sapp.glx.QueryVersion          = (PFNGLXQUERYVERSIONPROC)          dlsym(_sapp.glx.libgl, \"glXQueryVersion\");\n    _sapp.glx.DestroyContext        = (PFNGLXDESTROYCONTEXTPROC)        dlsym(_sapp.glx.libgl, \"glXDestroyContext\");\n    _sapp.glx.MakeCurrent           = (PFNGLXMAKECURRENTPROC)           dlsym(_sapp.glx.libgl, \"glXMakeCurrent\");\n    _sapp.glx.SwapBuffers           = (PFNGLXSWAPBUFFERSPROC)           dlsym(_sapp.glx.libgl, \"glXSwapBuffers\");\n    _sapp.glx.QueryExtensionsString = (PFNGLXQUERYEXTENSIONSSTRINGPROC) dlsym(_sapp.glx.libgl, \"glXQueryExtensionsString\");\n    _sapp.glx.CreateWindow          = (PFNGLXCREATEWINDOWPROC)          dlsym(_sapp.glx.libgl, \"glXCreateWindow\");\n    _sapp.glx.DestroyWindow         = (PFNGLXDESTROYWINDOWPROC)         dlsym(_sapp.glx.libgl, \"glXDestroyWindow\");\n    _sapp.glx.GetProcAddress        = (PFNGLXGETPROCADDRESSPROC)        dlsym(_sapp.glx.libgl, \"glXGetProcAddress\");\n    _sapp.glx.GetProcAddressARB     = (PFNGLXGETPROCADDRESSPROC)        dlsym(_sapp.glx.libgl, \"glXGetProcAddressARB\");\n    _sapp.glx.GetVisualFromFBConfig = (PFNGLXGETVISUALFROMFBCONFIGPROC) dlsym(_sapp.glx.libgl, \"glXGetVisualFromFBConfig\");\n    if (!_sapp.glx.GetFBConfigs ||\n        !_sapp.glx.GetFBConfigAttrib ||\n        !_sapp.glx.GetClientString ||\n        !_sapp.glx.QueryExtension ||\n        !_sapp.glx.QueryVersion ||\n        !_sapp.glx.DestroyContext ||\n        !_sapp.glx.MakeCurrent ||\n        !_sapp.glx.SwapBuffers ||\n        !_sapp.glx.QueryExtensionsString ||\n        !_sapp.glx.CreateWindow ||\n        !_sapp.glx.DestroyWindow ||\n        !_sapp.glx.GetProcAddress ||\n        !_sapp.glx.GetProcAddressARB ||\n        !_sapp.glx.GetVisualFromFBConfig)\n    {\n        _SAPP_PANIC(LINUX_GLX_LOAD_ENTRY_POINTS_FAILED);\n    }\n\n    if (!_sapp.glx.QueryExtension(_sapp.x11.display, &_sapp.glx.error_base, &_sapp.glx.event_base)) {\n        _SAPP_PANIC(LINUX_GLX_EXTENSION_NOT_FOUND);\n    }\n    if (!_sapp.glx.QueryVersion(_sapp.x11.display, &_sapp.glx.major, &_sapp.glx.minor)) {\n        _SAPP_PANIC(LINUX_GLX_QUERY_VERSION_FAILED);\n    }\n    if (_sapp.glx.major == 1 && _sapp.glx.minor < 3) {\n        _SAPP_PANIC(LINUX_GLX_VERSION_TOO_LOW);\n    }\n    const char* exts = _sapp.glx.QueryExtensionsString(_sapp.x11.display, _sapp.x11.screen);\n    if (_sapp_glx_extsupported(\"GLX_EXT_swap_control\", exts)) {\n        _sapp.glx.SwapIntervalEXT = (PFNGLXSWAPINTERVALEXTPROC) _sapp_glx_getprocaddr(\"glXSwapIntervalEXT\");\n        _sapp.glx.EXT_swap_control = 0 != _sapp.glx.SwapIntervalEXT;\n    }\n    if (_sapp_glx_extsupported(\"GLX_MESA_swap_control\", exts)) {\n        _sapp.glx.SwapIntervalMESA = (PFNGLXSWAPINTERVALMESAPROC) _sapp_glx_getprocaddr(\"glXSwapIntervalMESA\");\n        _sapp.glx.MESA_swap_control = 0 != _sapp.glx.SwapIntervalMESA;\n    }\n    _sapp.glx.ARB_multisample = _sapp_glx_extsupported(\"GLX_ARB_multisample\", exts);\n    if (_sapp_glx_extsupported(\"GLX_ARB_create_context\", exts)) {\n        _sapp.glx.CreateContextAttribsARB = (PFNGLXCREATECONTEXTATTRIBSARBPROC) _sapp_glx_getprocaddr(\"glXCreateContextAttribsARB\");\n        _sapp.glx.ARB_create_context = 0 != _sapp.glx.CreateContextAttribsARB;\n    }\n    _sapp.glx.ARB_create_context_profile = _sapp_glx_extsupported(\"GLX_ARB_create_context_profile\", exts);\n}\n\n_SOKOL_PRIVATE int _sapp_glx_attrib(GLXFBConfig fbconfig, int attrib) {\n    int value;\n    _sapp.glx.GetFBConfigAttrib(_sapp.x11.display, fbconfig, attrib, &value);\n    return value;\n}\n\n_SOKOL_PRIVATE GLXFBConfig _sapp_glx_choosefbconfig(void) {\n    GLXFBConfig* native_configs;\n    _sapp_gl_fbconfig* usable_configs;\n    const _sapp_gl_fbconfig* closest;\n    int i, native_count, usable_count;\n    const char* vendor;\n    bool trust_window_bit = true;\n\n    /* HACK: This is a (hopefully temporary) workaround for Chromium\n           (VirtualBox GL) not setting the window bit on any GLXFBConfigs\n    */\n    vendor = _sapp.glx.GetClientString(_sapp.x11.display, GLX_VENDOR);\n    if (vendor && strcmp(vendor, \"Chromium\") == 0) {\n        trust_window_bit = false;\n    }\n\n    native_configs = _sapp.glx.GetFBConfigs(_sapp.x11.display, _sapp.x11.screen, &native_count);\n    if (!native_configs || !native_count) {\n        _SAPP_PANIC(LINUX_GLX_NO_GLXFBCONFIGS);\n    }\n\n    usable_configs = (_sapp_gl_fbconfig*) _sapp_malloc_clear((size_t)native_count * sizeof(_sapp_gl_fbconfig));\n    usable_count = 0;\n    for (i = 0;  i < native_count;  i++) {\n        const GLXFBConfig n = native_configs[i];\n        _sapp_gl_fbconfig* u = usable_configs + usable_count;\n        _sapp_gl_init_fbconfig(u);\n\n        /* Only consider RGBA GLXFBConfigs */\n        if (0 == (_sapp_glx_attrib(n, GLX_RENDER_TYPE) & GLX_RGBA_BIT)) {\n            continue;\n        }\n        /* Only consider window GLXFBConfigs */\n        if (0 == (_sapp_glx_attrib(n, GLX_DRAWABLE_TYPE) & GLX_WINDOW_BIT)) {\n            if (trust_window_bit) {\n                continue;\n            }\n        }\n        u->red_bits = _sapp_glx_attrib(n, GLX_RED_SIZE);\n        u->green_bits = _sapp_glx_attrib(n, GLX_GREEN_SIZE);\n        u->blue_bits = _sapp_glx_attrib(n, GLX_BLUE_SIZE);\n        u->alpha_bits = _sapp_glx_attrib(n, GLX_ALPHA_SIZE);\n        u->depth_bits = _sapp_glx_attrib(n, GLX_DEPTH_SIZE);\n        u->stencil_bits = _sapp_glx_attrib(n, GLX_STENCIL_SIZE);\n        if (_sapp_glx_attrib(n, GLX_DOUBLEBUFFER)) {\n            u->doublebuffer = true;\n        }\n        if (_sapp.glx.ARB_multisample) {\n            u->samples = _sapp_glx_attrib(n, GLX_SAMPLES);\n        }\n        u->handle = (uintptr_t) n;\n        usable_count++;\n    }\n    _sapp_gl_fbconfig desired;\n    _sapp_gl_init_fbconfig(&desired);\n    desired.red_bits = 8;\n    desired.green_bits = 8;\n    desired.blue_bits = 8;\n    desired.alpha_bits = 8;\n    desired.depth_bits = 24;\n    desired.stencil_bits = 8;\n    desired.doublebuffer = true;\n    desired.samples = _sapp.sample_count > 1 ? _sapp.sample_count : 0;\n    closest = _sapp_gl_choose_fbconfig(&desired, usable_configs, usable_count);\n    GLXFBConfig result = 0;\n    if (closest) {\n        result = (GLXFBConfig) closest->handle;\n    }\n    XFree(native_configs);\n    _sapp_free(usable_configs);\n    return result;\n}\n\n_SOKOL_PRIVATE void _sapp_glx_choose_visual(Visual** visual, int* depth) {\n    GLXFBConfig native = _sapp_glx_choosefbconfig();\n    if (0 == native) {\n        _SAPP_PANIC(LINUX_GLX_NO_SUITABLE_GLXFBCONFIG);\n    }\n    XVisualInfo* result = _sapp.glx.GetVisualFromFBConfig(_sapp.x11.display, native);\n    if (!result) {\n        _SAPP_PANIC(LINUX_GLX_GET_VISUAL_FROM_FBCONFIG_FAILED);\n    }\n    *visual = result->visual;\n    *depth = result->depth;\n    XFree(result);\n}\n\n_SOKOL_PRIVATE void _sapp_glx_make_current(void) {\n    _sapp.glx.MakeCurrent(_sapp.x11.display, _sapp.glx.window, _sapp.glx.ctx);\n    glGetIntegerv(GL_FRAMEBUFFER_BINDING, (GLint*)&_sapp.gl.framebuffer);\n}\n\n_SOKOL_PRIVATE void _sapp_glx_create_context(void) {\n    GLXFBConfig native = _sapp_glx_choosefbconfig();\n    if (0 == native){\n        _SAPP_PANIC(LINUX_GLX_NO_SUITABLE_GLXFBCONFIG);\n    }\n    if (!(_sapp.glx.ARB_create_context && _sapp.glx.ARB_create_context_profile)) {\n        _SAPP_PANIC(LINUX_GLX_REQUIRED_EXTENSIONS_MISSING);\n    }\n    _sapp_x11_grab_error_handler();\n    const int attribs[] = {\n        GLX_CONTEXT_MAJOR_VERSION_ARB, _sapp.desc.gl_major_version,\n        GLX_CONTEXT_MINOR_VERSION_ARB, _sapp.desc.gl_minor_version,\n        GLX_CONTEXT_PROFILE_MASK_ARB, GLX_CONTEXT_CORE_PROFILE_BIT_ARB,\n        GLX_CONTEXT_FLAGS_ARB, GLX_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB,\n        0, 0\n    };\n    _sapp.glx.ctx = _sapp.glx.CreateContextAttribsARB(_sapp.x11.display, native, NULL, True, attribs);\n    if (!_sapp.glx.ctx) {\n        _SAPP_PANIC(LINUX_GLX_CREATE_CONTEXT_FAILED);\n    }\n    _sapp_x11_release_error_handler();\n    _sapp.glx.window = _sapp.glx.CreateWindow(_sapp.x11.display, native, _sapp.x11.window, NULL);\n    if (!_sapp.glx.window) {\n        _SAPP_PANIC(LINUX_GLX_CREATE_WINDOW_FAILED);\n    }\n    _sapp_glx_make_current();\n}\n\n_SOKOL_PRIVATE void _sapp_glx_destroy_context(void) {\n    if (_sapp.glx.window) {\n        _sapp.glx.DestroyWindow(_sapp.x11.display, _sapp.glx.window);\n        _sapp.glx.window = 0;\n    }\n    if (_sapp.glx.ctx) {\n        _sapp.glx.DestroyContext(_sapp.x11.display, _sapp.glx.ctx);\n        _sapp.glx.ctx = 0;\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_glx_swap_buffers(void) {\n    _sapp.glx.SwapBuffers(_sapp.x11.display, _sapp.glx.window);\n}\n\n_SOKOL_PRIVATE void _sapp_glx_swapinterval(int interval) {\n    if (_sapp.glx.EXT_swap_control) {\n        _sapp.glx.SwapIntervalEXT(_sapp.x11.display, _sapp.glx.window, interval);\n    }\n    else if (_sapp.glx.MESA_swap_control) {\n        _sapp.glx.SwapIntervalMESA(interval);\n    }\n}\n\n#endif /* _SAPP_GLX */\n\n_SOKOL_PRIVATE void _sapp_x11_send_event(Atom type, int a, int b, int c, int d, int e) {\n    XEvent event;\n    _sapp_clear(&event, sizeof(event));\n\n    event.type = ClientMessage;\n    event.xclient.window = _sapp.x11.window;\n    event.xclient.format = 32;\n    event.xclient.message_type = type;\n    event.xclient.data.l[0] = a;\n    event.xclient.data.l[1] = b;\n    event.xclient.data.l[2] = c;\n    event.xclient.data.l[3] = d;\n    event.xclient.data.l[4] = e;\n\n    XSendEvent(_sapp.x11.display, _sapp.x11.root,\n               False,\n               SubstructureNotifyMask | SubstructureRedirectMask,\n               &event);\n}\n\n_SOKOL_PRIVATE void _sapp_x11_query_window_size(void) {\n    XWindowAttributes attribs;\n    XGetWindowAttributes(_sapp.x11.display, _sapp.x11.window, &attribs);\n    _sapp.window_width = attribs.width;\n    _sapp.window_height = attribs.height;\n    _sapp.framebuffer_width = _sapp.window_width;\n    _sapp.framebuffer_height = _sapp.window_height;\n}\n\n_SOKOL_PRIVATE void _sapp_x11_set_fullscreen(bool enable) {\n    /* NOTE: this function must be called after XMapWindow (which happens in _sapp_x11_show_window()) */\n    if (_sapp.x11.NET_WM_STATE && _sapp.x11.NET_WM_STATE_FULLSCREEN) {\n        if (enable) {\n            const int _NET_WM_STATE_ADD = 1;\n            _sapp_x11_send_event(_sapp.x11.NET_WM_STATE,\n                                _NET_WM_STATE_ADD,\n                                _sapp.x11.NET_WM_STATE_FULLSCREEN,\n                                0, 1, 0);\n        }\n        else {\n            const int _NET_WM_STATE_REMOVE = 0;\n            _sapp_x11_send_event(_sapp.x11.NET_WM_STATE,\n                                _NET_WM_STATE_REMOVE,\n                                _sapp.x11.NET_WM_STATE_FULLSCREEN,\n                                0, 1, 0);\n        }\n    }\n    XFlush(_sapp.x11.display);\n}\n\n_SOKOL_PRIVATE void _sapp_x11_create_hidden_cursor(void) {\n    SOKOL_ASSERT(0 == _sapp.x11.hidden_cursor);\n    const int w = 16;\n    const int h = 16;\n    XcursorImage* img = XcursorImageCreate(w, h);\n    SOKOL_ASSERT(img && (img->width == 16) && (img->height == 16) && img->pixels);\n    img->xhot = 0;\n    img->yhot = 0;\n    const size_t num_bytes = (size_t)(w * h) * sizeof(XcursorPixel);\n    _sapp_clear(img->pixels, num_bytes);\n    _sapp.x11.hidden_cursor = XcursorImageLoadCursor(_sapp.x11.display, img);\n    XcursorImageDestroy(img);\n}\n\n _SOKOL_PRIVATE void _sapp_x11_create_standard_cursor(sapp_mouse_cursor cursor, const char* name, const char* theme, int size, uint32_t fallback_native) {\n    SOKOL_ASSERT((cursor >= 0) && (cursor < _SAPP_MOUSECURSOR_NUM));\n    SOKOL_ASSERT(_sapp.x11.display);\n    if (theme) {\n        XcursorImage* img = XcursorLibraryLoadImage(name, theme, size);\n        if (img) {\n            _sapp.x11.cursors[cursor] = XcursorImageLoadCursor(_sapp.x11.display, img);\n            XcursorImageDestroy(img);\n        }\n    }\n    if (0 == _sapp.x11.cursors[cursor]) {\n        _sapp.x11.cursors[cursor] = XCreateFontCursor(_sapp.x11.display, fallback_native);\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_x11_create_cursors(void) {\n    SOKOL_ASSERT(_sapp.x11.display);\n    const char* cursor_theme = XcursorGetTheme(_sapp.x11.display);\n    const int size = XcursorGetDefaultSize(_sapp.x11.display);\n    _sapp_x11_create_standard_cursor(SAPP_MOUSECURSOR_ARROW, \"default\", cursor_theme, size, XC_left_ptr);\n    _sapp_x11_create_standard_cursor(SAPP_MOUSECURSOR_IBEAM, \"text\", cursor_theme, size, XC_xterm);\n    _sapp_x11_create_standard_cursor(SAPP_MOUSECURSOR_CROSSHAIR, \"crosshair\", cursor_theme, size, XC_crosshair);\n    _sapp_x11_create_standard_cursor(SAPP_MOUSECURSOR_POINTING_HAND, \"pointer\", cursor_theme, size, XC_hand2);\n    _sapp_x11_create_standard_cursor(SAPP_MOUSECURSOR_RESIZE_EW, \"ew-resize\", cursor_theme, size, XC_sb_h_double_arrow);\n    _sapp_x11_create_standard_cursor(SAPP_MOUSECURSOR_RESIZE_NS, \"ns-resize\", cursor_theme, size, XC_sb_v_double_arrow);\n    _sapp_x11_create_standard_cursor(SAPP_MOUSECURSOR_RESIZE_NWSE, \"nwse-resize\", cursor_theme, size, 0);\n    _sapp_x11_create_standard_cursor(SAPP_MOUSECURSOR_RESIZE_NESW, \"nesw-resize\", cursor_theme, size, 0);\n    _sapp_x11_create_standard_cursor(SAPP_MOUSECURSOR_RESIZE_ALL, \"all-scroll\", cursor_theme, size, XC_fleur);\n    _sapp_x11_create_standard_cursor(SAPP_MOUSECURSOR_NOT_ALLOWED, \"no-allowed\", cursor_theme, size, 0);\n    _sapp_x11_create_hidden_cursor();\n}\n\n_SOKOL_PRIVATE void _sapp_x11_destroy_cursors(void) {\n    SOKOL_ASSERT(_sapp.x11.display);\n    if (_sapp.x11.hidden_cursor) {\n        XFreeCursor(_sapp.x11.display, _sapp.x11.hidden_cursor);\n        _sapp.x11.hidden_cursor = 0;\n    }\n    for (int i = 0; i < _SAPP_MOUSECURSOR_NUM; i++) {\n        if (_sapp.x11.cursors[i]) {\n            XFreeCursor(_sapp.x11.display, _sapp.x11.cursors[i]);\n            _sapp.x11.cursors[i] = 0;\n        }\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_x11_toggle_fullscreen(void) {\n    _sapp.fullscreen = !_sapp.fullscreen;\n    _sapp_x11_set_fullscreen(_sapp.fullscreen);\n    _sapp_x11_query_window_size();\n}\n\n_SOKOL_PRIVATE void _sapp_x11_update_cursor(sapp_mouse_cursor cursor, bool shown) {\n    SOKOL_ASSERT((cursor >= 0) && (cursor < _SAPP_MOUSECURSOR_NUM));\n    if (shown) {\n        if (_sapp.x11.cursors[cursor]) {\n            XDefineCursor(_sapp.x11.display, _sapp.x11.window, _sapp.x11.cursors[cursor]);\n        }\n        else {\n            XUndefineCursor(_sapp.x11.display, _sapp.x11.window);\n        }\n    }\n    else {\n        XDefineCursor(_sapp.x11.display, _sapp.x11.window, _sapp.x11.hidden_cursor);\n    }\n    XFlush(_sapp.x11.display);\n}\n\n_SOKOL_PRIVATE void _sapp_x11_lock_mouse(bool lock) {\n    if (lock == _sapp.mouse.locked) {\n        return;\n    }\n    _sapp.mouse.dx = 0.0f;\n    _sapp.mouse.dy = 0.0f;\n    _sapp.mouse.locked = lock;\n    if (_sapp.mouse.locked) {\n        if (_sapp.x11.xi.available) {\n            XIEventMask em;\n            unsigned char mask[XIMaskLen(XI_RawMotion)] = { 0 }; // XIMaskLen is a macro\n            em.deviceid = XIAllMasterDevices;\n            em.mask_len = sizeof(mask);\n            em.mask = mask;\n            XISetMask(mask, XI_RawMotion);\n            XISelectEvents(_sapp.x11.display, _sapp.x11.root, &em, 1);\n        }\n        XGrabPointer(_sapp.x11.display, // display\n            _sapp.x11.window,           // grab_window\n            True,                       // owner_events\n            ButtonPressMask | ButtonReleaseMask | PointerMotionMask,    // event_mask\n            GrabModeAsync,              // pointer_mode\n            GrabModeAsync,              // keyboard_mode\n            _sapp.x11.window,           // confine_to\n            _sapp.x11.hidden_cursor,    // cursor\n            CurrentTime);               // time\n    }\n    else {\n        if (_sapp.x11.xi.available) {\n            XIEventMask em;\n            unsigned char mask[] = { 0 };\n            em.deviceid = XIAllMasterDevices;\n            em.mask_len = sizeof(mask);\n            em.mask = mask;\n            XISelectEvents(_sapp.x11.display, _sapp.x11.root, &em, 1);\n        }\n        XWarpPointer(_sapp.x11.display, None, _sapp.x11.window, 0, 0, 0, 0, (int) _sapp.mouse.x, _sapp.mouse.y);\n        XUngrabPointer(_sapp.x11.display, CurrentTime);\n    }\n    XFlush(_sapp.x11.display);\n}\n\n_SOKOL_PRIVATE void _sapp_x11_set_clipboard_string(const char* str) {\n    SOKOL_ASSERT(_sapp.clipboard.enabled && _sapp.clipboard.buffer);\n    if (strlen(str) >= (size_t)_sapp.clipboard.buf_size) {\n        _SAPP_ERROR(CLIPBOARD_STRING_TOO_BIG);\n    }\n    XSetSelectionOwner(_sapp.x11.display, _sapp.x11.CLIPBOARD, _sapp.x11.window, CurrentTime);\n    if (XGetSelectionOwner(_sapp.x11.display, _sapp.x11.CLIPBOARD) != _sapp.x11.window) {\n        _SAPP_ERROR(LINUX_X11_FAILED_TO_BECOME_OWNER_OF_CLIPBOARD);\n    }\n}\n\n_SOKOL_PRIVATE const char* _sapp_x11_get_clipboard_string(void) {\n    SOKOL_ASSERT(_sapp.clipboard.enabled && _sapp.clipboard.buffer);\n    Atom none = XInternAtom(_sapp.x11.display, \"SAPP_SELECTION\", False);\n    Atom incremental = XInternAtom(_sapp.x11.display, \"INCR\", False);\n    if (XGetSelectionOwner(_sapp.x11.display, _sapp.x11.CLIPBOARD) == _sapp.x11.window) {\n        // Instead of doing a large number of X round-trips just to put this\n        // string into a window property and then read it back, just return it\n        return _sapp.clipboard.buffer;\n    }\n    XConvertSelection(_sapp.x11.display,\n                      _sapp.x11.CLIPBOARD,\n                      _sapp.x11.UTF8_STRING,\n                      none,\n                      _sapp.x11.window,\n                      CurrentTime);\n    XEvent event;\n    while (!XCheckTypedWindowEvent(_sapp.x11.display, _sapp.x11.window, SelectionNotify, &event)) {\n        // Wait for event data to arrive on the X11 display socket\n        struct pollfd fd = { ConnectionNumber(_sapp.x11.display), POLLIN };\n        while (!XPending(_sapp.x11.display)) {\n            poll(&fd, 1, -1);\n        }\n    }\n    if (event.xselection.property == None) {\n        return NULL;\n    }\n    char* data = NULL;\n    Atom actualType;\n    int actualFormat;\n    unsigned long itemCount, bytesAfter;\n    const bool ret = XGetWindowProperty(_sapp.x11.display,\n                        event.xselection.requestor,\n                        event.xselection.property,\n                        0,\n                        LONG_MAX,\n                        True,\n                        _sapp.x11.UTF8_STRING,\n                        &actualType,\n                        &actualFormat,\n                        &itemCount,\n                        &bytesAfter,\n                        (unsigned char**) &data);\n    if (ret != Success || data == NULL) {\n        if (data != NULL) {\n            XFree(data);\n        }\n        return NULL;\n    }\n    if ((actualType == incremental) || (itemCount >= (size_t)_sapp.clipboard.buf_size)) {\n        _SAPP_ERROR(CLIPBOARD_STRING_TOO_BIG);\n        XFree(data);\n        return NULL;\n    }\n    _sapp_strcpy(data, _sapp.clipboard.buffer, _sapp.clipboard.buf_size);\n    XFree(data);\n    return _sapp.clipboard.buffer;\n}\n\n_SOKOL_PRIVATE void _sapp_x11_update_window_title(void) {\n    Xutf8SetWMProperties(_sapp.x11.display,\n        _sapp.x11.window,\n        _sapp.window_title, _sapp.window_title,\n        NULL, 0, NULL, NULL, NULL);\n    XChangeProperty(_sapp.x11.display, _sapp.x11.window,\n        _sapp.x11.NET_WM_NAME, _sapp.x11.UTF8_STRING, 8,\n        PropModeReplace,\n        (unsigned char*)_sapp.window_title,\n        strlen(_sapp.window_title));\n    XChangeProperty(_sapp.x11.display, _sapp.x11.window,\n        _sapp.x11.NET_WM_ICON_NAME, _sapp.x11.UTF8_STRING, 8,\n        PropModeReplace,\n        (unsigned char*)_sapp.window_title,\n        strlen(_sapp.window_title));\n    XFlush(_sapp.x11.display);\n}\n\n_SOKOL_PRIVATE void _sapp_x11_set_icon(const sapp_icon_desc* icon_desc, int num_images) {\n    SOKOL_ASSERT((num_images > 0) && (num_images <= SAPP_MAX_ICONIMAGES));\n    int long_count = 0;\n    for (int i = 0; i < num_images; i++) {\n        const sapp_image_desc* img_desc = &icon_desc->images[i];\n        long_count += 2 + (img_desc->width * img_desc->height);\n    }\n    long* icon_data = (long*) _sapp_malloc_clear((size_t)long_count * sizeof(long));\n    SOKOL_ASSERT(icon_data);\n    long* dst = icon_data;\n    for (int img_index = 0; img_index < num_images; img_index++) {\n        const sapp_image_desc* img_desc = &icon_desc->images[img_index];\n        const uint8_t* src = (const uint8_t*) img_desc->pixels.ptr;\n        *dst++ = img_desc->width;\n        *dst++ = img_desc->height;\n        const int num_pixels = img_desc->width * img_desc->height;\n        for (int pixel_index = 0; pixel_index < num_pixels; pixel_index++) {\n            *dst++ = ((long)(src[pixel_index * 4 + 0]) << 16) |\n                     ((long)(src[pixel_index * 4 + 1]) << 8) |\n                     ((long)(src[pixel_index * 4 + 2]) << 0) |\n                     ((long)(src[pixel_index * 4 + 3]) << 24);\n        }\n    }\n    XChangeProperty(_sapp.x11.display, _sapp.x11.window,\n        _sapp.x11.NET_WM_ICON,\n        XA_CARDINAL, 32,\n        PropModeReplace,\n        (unsigned char*)icon_data,\n        long_count);\n    _sapp_free(icon_data);\n    XFlush(_sapp.x11.display);\n}\n\n_SOKOL_PRIVATE void _sapp_x11_create_window(Visual* visual, int depth) {\n    _sapp.x11.colormap = XCreateColormap(_sapp.x11.display, _sapp.x11.root, visual, AllocNone);\n    XSetWindowAttributes wa;\n    _sapp_clear(&wa, sizeof(wa));\n    const uint32_t wamask = CWBorderPixel | CWColormap | CWEventMask;\n    wa.colormap = _sapp.x11.colormap;\n    wa.border_pixel = 0;\n    wa.event_mask = StructureNotifyMask | KeyPressMask | KeyReleaseMask |\n                    PointerMotionMask | ButtonPressMask | ButtonReleaseMask |\n                    ExposureMask | FocusChangeMask | VisibilityChangeMask |\n                    EnterWindowMask | LeaveWindowMask | PropertyChangeMask;\n\n    int display_width = DisplayWidth(_sapp.x11.display, _sapp.x11.screen);\n    int display_height = DisplayHeight(_sapp.x11.display, _sapp.x11.screen);\n    int window_width = _sapp.window_width;\n    int window_height = _sapp.window_height;\n    if (0 == window_width) {\n        window_width = (display_width * 4) / 5;\n    }\n    if (0 == window_height) {\n        window_height = (display_height * 4) / 5;\n    }\n    int window_xpos = (display_width - window_width) / 2;\n    int window_ypos = (display_height - window_height) / 2;\n    if (window_xpos < 0) {\n        window_xpos = 0;\n    }\n    if (window_ypos < 0) {\n        window_ypos = 0;\n    }\n    _sapp_x11_grab_error_handler();\n    _sapp.x11.window = XCreateWindow(_sapp.x11.display,\n                                     _sapp.x11.root,\n                                     window_xpos,\n                                     window_ypos,\n                                     (uint32_t)window_width,\n                                     (uint32_t)window_height,\n                                     0,     /* border width */\n                                     depth, /* color depth */\n                                     InputOutput,\n                                     visual,\n                                     wamask,\n                                     &wa);\n    _sapp_x11_release_error_handler();\n    if (!_sapp.x11.window) {\n        _SAPP_PANIC(LINUX_X11_CREATE_WINDOW_FAILED);\n    }\n    Atom protocols[] = {\n        _sapp.x11.WM_DELETE_WINDOW\n    };\n    XSetWMProtocols(_sapp.x11.display, _sapp.x11.window, protocols, 1);\n\n    XSizeHints* hints = XAllocSizeHints();\n    hints->flags = (PWinGravity | PPosition | PSize);\n    hints->win_gravity = StaticGravity;\n    hints->x = window_xpos;\n    hints->y = window_ypos;\n    hints->width = window_width;\n    hints->height = window_height;\n    XSetWMNormalHints(_sapp.x11.display, _sapp.x11.window, hints);\n    XFree(hints);\n\n    /* announce support for drag'n'drop */\n    if (_sapp.drop.enabled) {\n        const Atom version = _SAPP_X11_XDND_VERSION;\n        XChangeProperty(_sapp.x11.display, _sapp.x11.window, _sapp.x11.xdnd.XdndAware, XA_ATOM, 32, PropModeReplace, (unsigned char*) &version, 1);\n    }\n    _sapp_x11_update_window_title();\n    _sapp_x11_query_window_size();\n}\n\n_SOKOL_PRIVATE void _sapp_x11_destroy_window(void) {\n    if (_sapp.x11.window) {\n        XUnmapWindow(_sapp.x11.display, _sapp.x11.window);\n        XDestroyWindow(_sapp.x11.display, _sapp.x11.window);\n        _sapp.x11.window = 0;\n    }\n    if (_sapp.x11.colormap) {\n        XFreeColormap(_sapp.x11.display, _sapp.x11.colormap);\n        _sapp.x11.colormap = 0;\n    }\n    XFlush(_sapp.x11.display);\n}\n\n_SOKOL_PRIVATE bool _sapp_x11_window_visible(void) {\n    XWindowAttributes wa;\n    XGetWindowAttributes(_sapp.x11.display, _sapp.x11.window, &wa);\n    return wa.map_state == IsViewable;\n}\n\n_SOKOL_PRIVATE void _sapp_x11_show_window(void) {\n    if (!_sapp_x11_window_visible()) {\n        XMapWindow(_sapp.x11.display, _sapp.x11.window);\n        XRaiseWindow(_sapp.x11.display, _sapp.x11.window);\n        XFlush(_sapp.x11.display);\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_x11_hide_window(void) {\n    XUnmapWindow(_sapp.x11.display, _sapp.x11.window);\n    XFlush(_sapp.x11.display);\n}\n\n_SOKOL_PRIVATE unsigned long _sapp_x11_get_window_property(Window window, Atom property, Atom type, unsigned char** value) {\n    Atom actualType;\n    int actualFormat;\n    unsigned long itemCount, bytesAfter;\n    XGetWindowProperty(_sapp.x11.display,\n                       window,\n                       property,\n                       0,\n                       LONG_MAX,\n                       False,\n                       type,\n                       &actualType,\n                       &actualFormat,\n                       &itemCount,\n                       &bytesAfter,\n                       value);\n    return itemCount;\n}\n\n_SOKOL_PRIVATE int _sapp_x11_get_window_state(void) {\n    int result = WithdrawnState;\n    struct {\n        CARD32 state;\n        Window icon;\n    } *state = NULL;\n\n    if (_sapp_x11_get_window_property(_sapp.x11.window, _sapp.x11.WM_STATE, _sapp.x11.WM_STATE, (unsigned char**)&state) >= 2) {\n        result = (int)state->state;\n    }\n    if (state) {\n        XFree(state);\n    }\n    return result;\n}\n\n_SOKOL_PRIVATE uint32_t _sapp_x11_key_modifier_bit(sapp_keycode key) {\n    switch (key) {\n        case SAPP_KEYCODE_LEFT_SHIFT:\n        case SAPP_KEYCODE_RIGHT_SHIFT:\n            return SAPP_MODIFIER_SHIFT;\n        case SAPP_KEYCODE_LEFT_CONTROL:\n        case SAPP_KEYCODE_RIGHT_CONTROL:\n            return SAPP_MODIFIER_CTRL;\n        case SAPP_KEYCODE_LEFT_ALT:\n        case SAPP_KEYCODE_RIGHT_ALT:\n            return SAPP_MODIFIER_ALT;\n        case SAPP_KEYCODE_LEFT_SUPER:\n        case SAPP_KEYCODE_RIGHT_SUPER:\n            return SAPP_MODIFIER_SUPER;\n        default:\n            return 0;\n    }\n}\n\n_SOKOL_PRIVATE uint32_t _sapp_x11_button_modifier_bit(sapp_mousebutton btn) {\n    switch (btn) {\n        case SAPP_MOUSEBUTTON_LEFT:     return SAPP_MODIFIER_LMB;\n        case SAPP_MOUSEBUTTON_RIGHT:    return SAPP_MODIFIER_RMB;\n        case SAPP_MOUSEBUTTON_MIDDLE:   return SAPP_MODIFIER_MMB;\n        default: return 0;\n    }\n}\n\n_SOKOL_PRIVATE uint32_t _sapp_x11_mods(uint32_t x11_mods) {\n    uint32_t mods = 0;\n    if (x11_mods & ShiftMask) {\n        mods |= SAPP_MODIFIER_SHIFT;\n    }\n    if (x11_mods & ControlMask) {\n        mods |= SAPP_MODIFIER_CTRL;\n    }\n    if (x11_mods & Mod1Mask) {\n        mods |= SAPP_MODIFIER_ALT;\n    }\n    if (x11_mods & Mod4Mask) {\n        mods |= SAPP_MODIFIER_SUPER;\n    }\n    if (x11_mods & Button1Mask) {\n        mods |= SAPP_MODIFIER_LMB;\n    }\n    if (x11_mods & Button2Mask) {\n        mods |= SAPP_MODIFIER_MMB;\n    }\n    if (x11_mods & Button3Mask) {\n        mods |= SAPP_MODIFIER_RMB;\n    }\n    return mods;\n}\n\n_SOKOL_PRIVATE void _sapp_x11_app_event(sapp_event_type type) {\n    if (_sapp_events_enabled()) {\n        _sapp_init_event(type);\n        _sapp_call_event(&_sapp.event);\n    }\n}\n\n_SOKOL_PRIVATE sapp_mousebutton _sapp_x11_translate_button(const XEvent* event) {\n    switch (event->xbutton.button) {\n        case Button1: return SAPP_MOUSEBUTTON_LEFT;\n        case Button2: return SAPP_MOUSEBUTTON_MIDDLE;\n        case Button3: return SAPP_MOUSEBUTTON_RIGHT;\n        default:      return SAPP_MOUSEBUTTON_INVALID;\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_x11_mouse_update(int x, int y, bool clear_dxdy) {\n    if (!_sapp.mouse.locked) {\n        const float new_x = (float) x;\n        const float new_y = (float) y;\n        if (clear_dxdy) {\n            _sapp.mouse.dx = 0.0f;\n            _sapp.mouse.dy = 0.0f;\n        } else if (_sapp.mouse.pos_valid) {\n            _sapp.mouse.dx = new_x - _sapp.mouse.x;\n            _sapp.mouse.dy = new_y - _sapp.mouse.y;\n        }\n        _sapp.mouse.x = new_x;\n        _sapp.mouse.y = new_y;\n        _sapp.mouse.pos_valid = true;\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_x11_mouse_event(sapp_event_type type, sapp_mousebutton btn, uint32_t mods) {\n    if (_sapp_events_enabled()) {\n        _sapp_init_event(type);\n        _sapp.event.mouse_button = btn;\n        _sapp.event.modifiers = mods;\n        _sapp_call_event(&_sapp.event);\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_x11_scroll_event(float x, float y, uint32_t mods) {\n    if (_sapp_events_enabled()) {\n        _sapp_init_event(SAPP_EVENTTYPE_MOUSE_SCROLL);\n        _sapp.event.modifiers = mods;\n        _sapp.event.scroll_x = x;\n        _sapp.event.scroll_y = y;\n        _sapp_call_event(&_sapp.event);\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_x11_key_event(sapp_event_type type, sapp_keycode key, bool repeat, uint32_t mods) {\n    if (_sapp_events_enabled()) {\n        _sapp_init_event(type);\n        _sapp.event.key_code = key;\n        _sapp.event.key_repeat = repeat;\n        _sapp.event.modifiers = mods;\n        _sapp_call_event(&_sapp.event);\n        /* check if a CLIPBOARD_PASTED event must be sent too */\n        if (_sapp.clipboard.enabled &&\n            (type == SAPP_EVENTTYPE_KEY_DOWN) &&\n            (_sapp.event.modifiers == SAPP_MODIFIER_CTRL) &&\n            (_sapp.event.key_code == SAPP_KEYCODE_V))\n        {\n            _sapp_init_event(SAPP_EVENTTYPE_CLIPBOARD_PASTED);\n            _sapp_call_event(&_sapp.event);\n        }\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_x11_char_event(uint32_t chr, bool repeat, uint32_t mods) {\n    if (_sapp_events_enabled()) {\n        _sapp_init_event(SAPP_EVENTTYPE_CHAR);\n        _sapp.event.char_code = chr;\n        _sapp.event.key_repeat = repeat;\n        _sapp.event.modifiers = mods;\n        _sapp_call_event(&_sapp.event);\n    }\n}\n\n_SOKOL_PRIVATE sapp_keycode _sapp_x11_translate_key(int scancode) {\n    if ((scancode >= 0) && (scancode < _SAPP_X11_MAX_X11_KEYCODES)) {\n        return _sapp.keycodes[scancode];\n    } else {\n        return SAPP_KEYCODE_INVALID;\n    }\n}\n\n_SOKOL_PRIVATE int32_t _sapp_x11_keysym_to_unicode(KeySym keysym) {\n    int min = 0;\n    int max = sizeof(_sapp_x11_keysymtab) / sizeof(struct _sapp_x11_codepair) - 1;\n    int mid;\n\n    /* First check for Latin-1 characters (1:1 mapping) */\n    if ((keysym >= 0x0020 && keysym <= 0x007e) ||\n        (keysym >= 0x00a0 && keysym <= 0x00ff))\n    {\n        return keysym;\n    }\n\n    /* Also check for directly encoded 24-bit UCS characters */\n    if ((keysym & 0xff000000) == 0x01000000) {\n        return keysym & 0x00ffffff;\n    }\n\n    /* Binary search in table */\n    while (max >= min) {\n        mid = (min + max) / 2;\n        if (_sapp_x11_keysymtab[mid].keysym < keysym) {\n            min = mid + 1;\n        }\n        else if (_sapp_x11_keysymtab[mid].keysym > keysym) {\n            max = mid - 1;\n        }\n        else {\n            return _sapp_x11_keysymtab[mid].ucs;\n        }\n    }\n\n    /* No matching Unicode value found */\n    return -1;\n}\n\n_SOKOL_PRIVATE bool _sapp_x11_keypress_repeat(int keycode) {\n    bool repeat = false;\n    if ((keycode >= 0) && (keycode < _SAPP_X11_MAX_X11_KEYCODES)) {\n        repeat = _sapp.x11.key_repeat[keycode];\n        _sapp.x11.key_repeat[keycode] = true;\n    }\n    return repeat;\n}\n\n_SOKOL_PRIVATE void _sapp_x11_keyrelease_repeat(int keycode) {\n    if ((keycode >= 0) && (keycode < _SAPP_X11_MAX_X11_KEYCODES)) {\n        _sapp.x11.key_repeat[keycode] = false;\n    }\n}\n\n_SOKOL_PRIVATE bool _sapp_x11_parse_dropped_files_list(const char* src) {\n    SOKOL_ASSERT(src);\n    SOKOL_ASSERT(_sapp.drop.buffer);\n\n    _sapp_clear_drop_buffer();\n    _sapp.drop.num_files = 0;\n\n    /*\n        src is (potentially percent-encoded) string made of one or multiple paths\n        separated by \\r\\n, each path starting with 'file://'\n    */\n    bool err = false;\n    int src_count = 0;\n    char src_chr = 0;\n    char* dst_ptr = _sapp.drop.buffer;\n    const char* dst_end_ptr = dst_ptr + (_sapp.drop.max_path_length - 1); // room for terminating 0\n    while (0 != (src_chr = *src++)) {\n        src_count++;\n        char dst_chr = 0;\n        /* check leading 'file://' */\n        if (src_count <= 7) {\n            if (((src_count == 1) && (src_chr != 'f')) ||\n                ((src_count == 2) && (src_chr != 'i')) ||\n                ((src_count == 3) && (src_chr != 'l')) ||\n                ((src_count == 4) && (src_chr != 'e')) ||\n                ((src_count == 5) && (src_chr != ':')) ||\n                ((src_count == 6) && (src_chr != '/')) ||\n                ((src_count == 7) && (src_chr != '/')))\n            {\n                _SAPP_ERROR(LINUX_X11_DROPPED_FILE_URI_WRONG_SCHEME);\n                err = true;\n                break;\n            }\n        }\n        else if (src_chr == '\\r') {\n            // skip\n        }\n        else if (src_chr == '\\n') {\n            src_count = 0;\n            _sapp.drop.num_files++;\n            // too many files is not an error\n            if (_sapp.drop.num_files >= _sapp.drop.max_files) {\n                break;\n            }\n            dst_ptr = _sapp.drop.buffer + _sapp.drop.num_files * _sapp.drop.max_path_length;\n            dst_end_ptr = dst_ptr + (_sapp.drop.max_path_length - 1);\n        }\n        else if ((src_chr == '%') && src[0] && src[1]) {\n            // a percent-encoded byte (most likely UTF-8 multibyte sequence)\n            const char digits[3] = { src[0], src[1], 0 };\n            src += 2;\n            dst_chr = (char) strtol(digits, 0, 16);\n        }\n        else {\n            dst_chr = src_chr;\n        }\n        if (dst_chr) {\n            // dst_end_ptr already has adjustment for terminating zero\n            if (dst_ptr < dst_end_ptr) {\n                *dst_ptr++ = dst_chr;\n            }\n            else {\n                _SAPP_ERROR(DROPPED_FILE_PATH_TOO_LONG);\n                err = true;\n                break;\n            }\n        }\n    }\n    if (err) {\n        _sapp_clear_drop_buffer();\n        _sapp.drop.num_files = 0;\n        return false;\n    }\n    else {\n        return true;\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_x11_on_genericevent(XEvent* event) {\n    if (_sapp.mouse.locked && _sapp.x11.xi.available) {\n        if (event->xcookie.extension == _sapp.x11.xi.major_opcode) {\n            if (XGetEventData(_sapp.x11.display, &event->xcookie)) {\n                if (event->xcookie.evtype == XI_RawMotion) {\n                    XIRawEvent* re = (XIRawEvent*) event->xcookie.data;\n                    if (re->valuators.mask_len) {\n                        const double* values = re->raw_values;\n                        if (XIMaskIsSet(re->valuators.mask, 0)) {\n                            _sapp.mouse.dx = (float) *values;\n                            values++;\n                        }\n                        if (XIMaskIsSet(re->valuators.mask, 1)) {\n                            _sapp.mouse.dy = (float) *values;\n                        }\n                        _sapp_x11_mouse_event(SAPP_EVENTTYPE_MOUSE_MOVE, SAPP_MOUSEBUTTON_INVALID, _sapp_x11_mods(event->xmotion.state));\n                    }\n                }\n                XFreeEventData(_sapp.x11.display, &event->xcookie);\n            }\n        }\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_x11_on_focusin(XEvent* event) {\n    // NOTE: ignoring NotifyGrab and NotifyUngrab is same behaviour as GLFW\n    if ((event->xfocus.mode != NotifyGrab) && (event->xfocus.mode != NotifyUngrab)) {\n        _sapp_x11_app_event(SAPP_EVENTTYPE_FOCUSED);\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_x11_on_focusout(XEvent* event) {\n    // if focus is lost for any reason, and we're in mouse locked mode, disable mouse lock\n    if (_sapp.mouse.locked) {\n        _sapp_x11_lock_mouse(false);\n    }\n    // NOTE: ignoring NotifyGrab and NotifyUngrab is same behaviour as GLFW\n    if ((event->xfocus.mode != NotifyGrab) && (event->xfocus.mode != NotifyUngrab)) {\n        _sapp_x11_app_event(SAPP_EVENTTYPE_UNFOCUSED);\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_x11_on_keypress(XEvent* event) {\n    int keycode = (int)event->xkey.keycode;\n\n    const sapp_keycode key = _sapp_x11_translate_key(keycode);\n    const bool repeat = _sapp_x11_keypress_repeat(keycode);\n    uint32_t mods = _sapp_x11_mods(event->xkey.state);\n    // X11 doesn't set modifier bit on key down, so emulate that\n    mods |= _sapp_x11_key_modifier_bit(key);\n    if (key != SAPP_KEYCODE_INVALID) {\n        _sapp_x11_key_event(SAPP_EVENTTYPE_KEY_DOWN, key, repeat, mods);\n    }\n    KeySym keysym;\n    XLookupString(&event->xkey, NULL, 0, &keysym, NULL);\n    int32_t chr = _sapp_x11_keysym_to_unicode(keysym);\n    if (chr > 0) {\n        _sapp_x11_char_event((uint32_t)chr, repeat, mods);\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_x11_on_keyrelease(XEvent* event) {\n    int keycode = (int)event->xkey.keycode;\n    const sapp_keycode key = _sapp_x11_translate_key(keycode);\n    _sapp_x11_keyrelease_repeat(keycode);\n    if (key != SAPP_KEYCODE_INVALID) {\n        uint32_t mods = _sapp_x11_mods(event->xkey.state);\n        // X11 doesn't clear modifier bit on key up, so emulate that\n        mods &= ~_sapp_x11_key_modifier_bit(key);\n        _sapp_x11_key_event(SAPP_EVENTTYPE_KEY_UP, key, false, mods);\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_x11_on_buttonpress(XEvent* event) {\n    _sapp_x11_mouse_update(event->xbutton.x, event->xbutton.y, false);\n    const sapp_mousebutton btn = _sapp_x11_translate_button(event);\n    uint32_t mods = _sapp_x11_mods(event->xbutton.state);\n    // X11 doesn't set modifier bit on button down, so emulate that\n    mods |= _sapp_x11_button_modifier_bit(btn);\n    if (btn != SAPP_MOUSEBUTTON_INVALID) {\n        _sapp_x11_mouse_event(SAPP_EVENTTYPE_MOUSE_DOWN, btn, mods);\n        _sapp.x11.mouse_buttons |= (1 << btn);\n    }\n    else {\n        // might be a scroll event\n        switch (event->xbutton.button) {\n            case 4: _sapp_x11_scroll_event(0.0f, 1.0f, mods); break;\n            case 5: _sapp_x11_scroll_event(0.0f, -1.0f, mods); break;\n            case 6: _sapp_x11_scroll_event(1.0f, 0.0f, mods); break;\n            case 7: _sapp_x11_scroll_event(-1.0f, 0.0f, mods); break;\n        }\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_x11_on_buttonrelease(XEvent* event) {\n    _sapp_x11_mouse_update(event->xbutton.x, event->xbutton.y, false);\n    const sapp_mousebutton btn = _sapp_x11_translate_button(event);\n    if (btn != SAPP_MOUSEBUTTON_INVALID) {\n        uint32_t mods = _sapp_x11_mods(event->xbutton.state);\n        // X11 doesn't clear modifier bit on button up, so emulate that\n        mods &= ~_sapp_x11_button_modifier_bit(btn);\n        _sapp_x11_mouse_event(SAPP_EVENTTYPE_MOUSE_UP, btn, mods);\n        _sapp.x11.mouse_buttons &= ~(1 << btn);\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_x11_on_enternotify(XEvent* event) {\n    // don't send enter/leave events while mouse button held down\n    if (0 == _sapp.x11.mouse_buttons) {\n        _sapp_x11_mouse_update(event->xcrossing.x, event->xcrossing.y, true);\n        _sapp_x11_mouse_event(SAPP_EVENTTYPE_MOUSE_ENTER, SAPP_MOUSEBUTTON_INVALID, _sapp_x11_mods(event->xcrossing.state));\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_x11_on_leavenotify(XEvent* event) {\n    if (0 == _sapp.x11.mouse_buttons) {\n        _sapp_x11_mouse_update(event->xcrossing.x, event->xcrossing.y, true);\n        _sapp_x11_mouse_event(SAPP_EVENTTYPE_MOUSE_LEAVE, SAPP_MOUSEBUTTON_INVALID, _sapp_x11_mods(event->xcrossing.state));\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_x11_on_motionnotify(XEvent* event) {\n    if (!_sapp.mouse.locked) {\n        _sapp_x11_mouse_update(event->xmotion.x, event->xmotion.y, false);\n        _sapp_x11_mouse_event(SAPP_EVENTTYPE_MOUSE_MOVE, SAPP_MOUSEBUTTON_INVALID, _sapp_x11_mods(event->xmotion.state));\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_x11_on_configurenotify(XEvent* event) {\n    if ((event->xconfigure.width != _sapp.window_width) || (event->xconfigure.height != _sapp.window_height)) {\n        _sapp.window_width = event->xconfigure.width;\n        _sapp.window_height = event->xconfigure.height;\n        _sapp.framebuffer_width = _sapp.window_width;\n        _sapp.framebuffer_height = _sapp.window_height;\n        _sapp_x11_app_event(SAPP_EVENTTYPE_RESIZED);\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_x11_on_propertynotify(XEvent* event) {\n    if (event->xproperty.state == PropertyNewValue) {\n        if (event->xproperty.atom == _sapp.x11.WM_STATE) {\n            const int state = _sapp_x11_get_window_state();\n            if (state != _sapp.x11.window_state) {\n                _sapp.x11.window_state = state;\n                if (state == IconicState) {\n                    _sapp_x11_app_event(SAPP_EVENTTYPE_ICONIFIED);\n                }\n                else if (state == NormalState) {\n                    _sapp_x11_app_event(SAPP_EVENTTYPE_RESTORED);\n                }\n            }\n        }\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_x11_on_selectionnotify(XEvent* event) {\n    if (event->xselection.property == _sapp.x11.xdnd.XdndSelection) {\n        char* data = 0;\n        uint32_t result = _sapp_x11_get_window_property(event->xselection.requestor,\n                                                        event->xselection.property,\n                                                        event->xselection.target,\n                                                        (unsigned char**) &data);\n        if (_sapp.drop.enabled && result) {\n            if (_sapp_x11_parse_dropped_files_list(data)) {\n                _sapp.mouse.dx = 0.0f;\n                _sapp.mouse.dy = 0.0f;\n                if (_sapp_events_enabled()) {\n                    // FIXME: Figure out how to get modifier key state here.\n                    // The XSelection event has no 'state' item, and\n                    // XQueryKeymap() always returns a zeroed array.\n                    _sapp_init_event(SAPP_EVENTTYPE_FILES_DROPPED);\n                    _sapp_call_event(&_sapp.event);\n                }\n            }\n        }\n        if (_sapp.x11.xdnd.version >= 2) {\n            XEvent reply;\n            _sapp_clear(&reply, sizeof(reply));\n            reply.type = ClientMessage;\n            reply.xclient.window = _sapp.x11.xdnd.source;\n            reply.xclient.message_type = _sapp.x11.xdnd.XdndFinished;\n            reply.xclient.format = 32;\n            reply.xclient.data.l[0] = (long)_sapp.x11.window;\n            reply.xclient.data.l[1] = result;\n            reply.xclient.data.l[2] = (long)_sapp.x11.xdnd.XdndActionCopy;\n            XSendEvent(_sapp.x11.display, _sapp.x11.xdnd.source, False, NoEventMask, &reply);\n            XFlush(_sapp.x11.display);\n        }\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_x11_on_clientmessage(XEvent* event) {\n    if (XFilterEvent(event, None)) {\n        return;\n    }\n    if (event->xclient.message_type == _sapp.x11.WM_PROTOCOLS) {\n        const Atom protocol = (Atom)event->xclient.data.l[0];\n        if (protocol == _sapp.x11.WM_DELETE_WINDOW) {\n            _sapp.quit_requested = true;\n        }\n    } else if (event->xclient.message_type == _sapp.x11.xdnd.XdndEnter) {\n        const bool is_list = 0 != (event->xclient.data.l[1] & 1);\n        _sapp.x11.xdnd.source  = (Window)event->xclient.data.l[0];\n        _sapp.x11.xdnd.version = event->xclient.data.l[1] >> 24;\n        _sapp.x11.xdnd.format  = None;\n        if (_sapp.x11.xdnd.version > _SAPP_X11_XDND_VERSION) {\n            return;\n        }\n        uint32_t count = 0;\n        Atom* formats = 0;\n        if (is_list) {\n            count = _sapp_x11_get_window_property(_sapp.x11.xdnd.source, _sapp.x11.xdnd.XdndTypeList, XA_ATOM, (unsigned char**)&formats);\n        } else {\n            count = 3;\n            formats = (Atom*) event->xclient.data.l + 2;\n        }\n        for (uint32_t i = 0; i < count; i++) {\n            if (formats[i] == _sapp.x11.xdnd.text_uri_list) {\n                _sapp.x11.xdnd.format = _sapp.x11.xdnd.text_uri_list;\n                break;\n            }\n        }\n        if (is_list && formats) {\n            XFree(formats);\n        }\n    } else if (event->xclient.message_type == _sapp.x11.xdnd.XdndDrop) {\n        if (_sapp.x11.xdnd.version > _SAPP_X11_XDND_VERSION) {\n            return;\n        }\n        Time time = CurrentTime;\n        if (_sapp.x11.xdnd.format) {\n            if (_sapp.x11.xdnd.version >= 1) {\n                time = (Time)event->xclient.data.l[2];\n            }\n            XConvertSelection(_sapp.x11.display,\n                                _sapp.x11.xdnd.XdndSelection,\n                                _sapp.x11.xdnd.format,\n                                _sapp.x11.xdnd.XdndSelection,\n                                _sapp.x11.window,\n                                time);\n        } else if (_sapp.x11.xdnd.version >= 2) {\n            XEvent reply;\n            _sapp_clear(&reply, sizeof(reply));\n            reply.type = ClientMessage;\n            reply.xclient.window = _sapp.x11.xdnd.source;\n            reply.xclient.message_type = _sapp.x11.xdnd.XdndFinished;\n            reply.xclient.format = 32;\n            reply.xclient.data.l[0] = (long)_sapp.x11.window;\n            reply.xclient.data.l[1] = 0;    // drag was rejected\n            reply.xclient.data.l[2] = None;\n            XSendEvent(_sapp.x11.display, _sapp.x11.xdnd.source, False, NoEventMask, &reply);\n            XFlush(_sapp.x11.display);\n        }\n    } else if (event->xclient.message_type == _sapp.x11.xdnd.XdndPosition) {\n        // drag operation has moved over the window\n        //  FIXME: we could track the mouse position here, but\n        //  this isn't implemented on other platforms either so far\n        if (_sapp.x11.xdnd.version > _SAPP_X11_XDND_VERSION) {\n            return;\n        }\n        XEvent reply;\n        _sapp_clear(&reply, sizeof(reply));\n        reply.type = ClientMessage;\n        reply.xclient.window = _sapp.x11.xdnd.source;\n        reply.xclient.message_type = _sapp.x11.xdnd.XdndStatus;\n        reply.xclient.format = 32;\n        reply.xclient.data.l[0] = (long)_sapp.x11.window;\n        if (_sapp.x11.xdnd.format) {\n            /* reply that we are ready to copy the dragged data */\n            reply.xclient.data.l[1] = 1;    // accept with no rectangle\n            if (_sapp.x11.xdnd.version >= 2) {\n                reply.xclient.data.l[4] = (long)_sapp.x11.xdnd.XdndActionCopy;\n            }\n        }\n        XSendEvent(_sapp.x11.display, _sapp.x11.xdnd.source, False, NoEventMask, &reply);\n        XFlush(_sapp.x11.display);\n    }\n}\n\n_SOKOL_PRIVATE void _sapp_x11_on_selectionrequest(XEvent* event) {\n    XSelectionRequestEvent* req = &event->xselectionrequest;\n    if (req->selection != _sapp.x11.CLIPBOARD) {\n        return;\n    }\n    if (!_sapp.clipboard.enabled) {\n        return;\n    }\n    SOKOL_ASSERT(_sapp.clipboard.buffer);\n    XSelectionEvent reply;\n    _sapp_clear(&reply, sizeof(reply));\n    reply.type = SelectionNotify;\n    reply.display = req->display;\n    reply.requestor = req->requestor;\n    reply.selection = req->selection;\n    reply.target = req->target;\n    reply.property = req->property;\n    reply.time = req->time;\n    if (req->target == _sapp.x11.UTF8_STRING) {\n        XChangeProperty(_sapp.x11.display,\n                        req->requestor,\n                        req->property,\n                        _sapp.x11.UTF8_STRING,\n                        8,\n                        PropModeReplace,\n                        (unsigned char*) _sapp.clipboard.buffer,\n                        strlen(_sapp.clipboard.buffer));\n    } else if (req->target == _sapp.x11.TARGETS) {\n        XChangeProperty(_sapp.x11.display,\n                        req->requestor,\n                        req->property,\n                        XA_ATOM,\n                        32,\n                        PropModeReplace,\n                        (unsigned char*) &_sapp.x11.UTF8_STRING,\n                        1);\n    } else {\n        reply.property = None;\n    }\n    XSendEvent(_sapp.x11.display, req->requestor, False, 0, (XEvent*) &reply);\n}\n\n_SOKOL_PRIVATE void _sapp_x11_process_event(XEvent* event) {\n    switch (event->type) {\n        case GenericEvent:\n            _sapp_x11_on_genericevent(event);\n            break;\n        case FocusIn:\n            _sapp_x11_on_focusin(event);\n            break;\n        case FocusOut:\n            _sapp_x11_on_focusout(event);\n            break;\n        case KeyPress:\n            _sapp_x11_on_keypress(event);\n            break;\n        case KeyRelease:\n            _sapp_x11_on_keyrelease(event);\n            break;\n        case ButtonPress:\n            _sapp_x11_on_buttonpress(event);\n            break;\n        case ButtonRelease:\n            _sapp_x11_on_buttonrelease(event);\n            break;\n        case EnterNotify:\n            _sapp_x11_on_enternotify(event);\n            break;\n        case LeaveNotify:\n            _sapp_x11_on_leavenotify(event);\n            break;\n        case MotionNotify:\n            _sapp_x11_on_motionnotify(event);\n            break;\n        case ConfigureNotify:\n            _sapp_x11_on_configurenotify(event);\n            break;\n        case PropertyNotify:\n            _sapp_x11_on_propertynotify(event);\n            break;\n        case SelectionNotify:\n            _sapp_x11_on_selectionnotify(event);\n            break;\n        case SelectionRequest:\n            _sapp_x11_on_selectionrequest(event);\n            break;\n        case DestroyNotify:\n            // not a bug\n            break;\n        case ClientMessage:\n            _sapp_x11_on_clientmessage(event);\n            break;\n    }\n}\n\n#if !defined(_SAPP_GLX)\n\n_SOKOL_PRIVATE void _sapp_egl_init(void) {\n#if defined(SOKOL_GLCORE)\n    if (!eglBindAPI(EGL_OPENGL_API)) {\n        _SAPP_PANIC(LINUX_EGL_BIND_OPENGL_API_FAILED);\n    }\n#else\n    if (!eglBindAPI(EGL_OPENGL_ES_API)) {\n        _SAPP_PANIC(LINUX_EGL_BIND_OPENGL_ES_API_FAILED);\n    }\n#endif\n\n    _sapp.egl.display = eglGetDisplay((EGLNativeDisplayType)_sapp.x11.display);\n    if (EGL_NO_DISPLAY == _sapp.egl.display) {\n        _SAPP_PANIC(LINUX_EGL_GET_DISPLAY_FAILED);\n    }\n\n    EGLint major, minor;\n    if (!eglInitialize(_sapp.egl.display, &major, &minor)) {\n        _SAPP_PANIC(LINUX_EGL_INITIALIZE_FAILED);\n    }\n\n    EGLint sample_count = _sapp.desc.sample_count > 1 ? _sapp.desc.sample_count : 0;\n    EGLint alpha_size = _sapp.desc.alpha ? 8 : 0;\n    const EGLint config_attrs[] = {\n        EGL_SURFACE_TYPE, EGL_WINDOW_BIT,\n        #if defined(SOKOL_GLCORE)\n            EGL_RENDERABLE_TYPE, EGL_OPENGL_BIT,\n        #elif defined(SOKOL_GLES3)\n            EGL_RENDERABLE_TYPE, EGL_OPENGL_ES3_BIT,\n        #endif\n        EGL_RED_SIZE, 8,\n        EGL_GREEN_SIZE, 8,\n        EGL_BLUE_SIZE, 8,\n        EGL_ALPHA_SIZE, alpha_size,\n        EGL_DEPTH_SIZE, 24,\n        EGL_STENCIL_SIZE, 8,\n        EGL_SAMPLE_BUFFERS, _sapp.desc.sample_count > 1 ? 1 : 0,\n        EGL_SAMPLES, sample_count,\n        EGL_NONE,\n    };\n\n    EGLConfig egl_configs[32];\n    EGLint config_count;\n    if (!eglChooseConfig(_sapp.egl.display, config_attrs, egl_configs, 32, &config_count) || config_count == 0) {\n        _SAPP_PANIC(LINUX_EGL_NO_CONFIGS);\n    }\n\n    EGLConfig config = egl_configs[0];\n    for (int i = 0; i < config_count; ++i) {\n        EGLConfig c = egl_configs[i];\n        EGLint r, g, b, a, d, s, n;\n        if (eglGetConfigAttrib(_sapp.egl.display, c, EGL_RED_SIZE, &r) &&\n            eglGetConfigAttrib(_sapp.egl.display, c, EGL_GREEN_SIZE, &g) &&\n            eglGetConfigAttrib(_sapp.egl.display, c, EGL_BLUE_SIZE, &b) &&\n            eglGetConfigAttrib(_sapp.egl.display, c, EGL_ALPHA_SIZE, &a) &&\n            eglGetConfigAttrib(_sapp.egl.display, c, EGL_DEPTH_SIZE, &d) &&\n            eglGetConfigAttrib(_sapp.egl.display, c, EGL_STENCIL_SIZE, &s) &&\n            eglGetConfigAttrib(_sapp.egl.display, c, EGL_SAMPLES, &n) &&\n            (r == 8) && (g == 8) && (b == 8) && (a == alpha_size) && (d == 24) && (s == 8) && (n == sample_count)) {\n            config = c;\n            break;\n        }\n    }\n\n    EGLint visual_id;\n    if (!eglGetConfigAttrib(_sapp.egl.display, config, EGL_NATIVE_VISUAL_ID, &visual_id)) {\n        _SAPP_PANIC(LINUX_EGL_NO_NATIVE_VISUAL);\n    }\n\n    XVisualInfo visual_info_template;\n    _sapp_clear(&visual_info_template, sizeof(visual_info_template));\n    visual_info_template.visualid = (VisualID)visual_id;\n\n    int num_visuals;\n    XVisualInfo* visual_info = XGetVisualInfo(_sapp.x11.display, VisualIDMask, &visual_info_template, &num_visuals);\n    if (!visual_info) {\n        _SAPP_PANIC(LINUX_EGL_GET_VISUAL_INFO_FAILED);\n    }\n\n    _sapp_x11_create_window(visual_info->visual, visual_info->depth);\n    XFree(visual_info);\n\n    _sapp.egl.surface = eglCreateWindowSurface(_sapp.egl.display, config, (EGLNativeWindowType)_sapp.x11.window, NULL);\n    if (EGL_NO_SURFACE == _sapp.egl.surface) {\n        _SAPP_PANIC(LINUX_EGL_CREATE_WINDOW_SURFACE_FAILED);\n    }\n\n    EGLint ctx_attrs[] = {\n        #if defined(SOKOL_GLCORE)\n            EGL_CONTEXT_MAJOR_VERSION, _sapp.desc.gl_major_version,\n            EGL_CONTEXT_MINOR_VERSION, _sapp.desc.gl_minor_version,\n            EGL_CONTEXT_OPENGL_PROFILE_MASK, EGL_CONTEXT_OPENGL_CORE_PROFILE_BIT,\n        #elif defined(SOKOL_GLES3)\n            EGL_CONTEXT_CLIENT_VERSION, 3,\n        #endif\n        EGL_NONE,\n    };\n\n    _sapp.egl.context = eglCreateContext(_sapp.egl.display, config, EGL_NO_CONTEXT, ctx_attrs);\n    if (EGL_NO_CONTEXT == _sapp.egl.context) {\n        _SAPP_PANIC(LINUX_EGL_CREATE_CONTEXT_FAILED);\n    }\n\n    if (!eglMakeCurrent(_sapp.egl.display, _sapp.egl.surface, _sapp.egl.surface, _sapp.egl.context)) {\n        _SAPP_PANIC(LINUX_EGL_MAKE_CURRENT_FAILED);\n    }\n    glGetIntegerv(GL_FRAMEBUFFER_BINDING, (GLint*)&_sapp.gl.framebuffer);\n\n    eglSwapInterval(_sapp.egl.display, _sapp.swap_interval);\n}\n\n_SOKOL_PRIVATE void _sapp_egl_destroy(void) {\n    if (_sapp.egl.display != EGL_NO_DISPLAY) {\n        eglMakeCurrent(_sapp.egl.display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);\n\n        if (_sapp.egl.context != EGL_NO_CONTEXT) {\n            eglDestroyContext(_sapp.egl.display, _sapp.egl.context);\n            _sapp.egl.context = EGL_NO_CONTEXT;\n        }\n\n        if (_sapp.egl.surface != EGL_NO_SURFACE) {\n            eglDestroySurface(_sapp.egl.display, _sapp.egl.surface);\n            _sapp.egl.surface = EGL_NO_SURFACE;\n        }\n\n        eglTerminate(_sapp.egl.display);\n        _sapp.egl.display = EGL_NO_DISPLAY;\n    }\n}\n\n#endif /* _SAPP_GLX */\n\n_SOKOL_PRIVATE void _sapp_linux_run(const sapp_desc* desc) {\n    /* The following lines are here to trigger a linker error instead of an\n        obscure runtime error if the user has forgotten to add -pthread to\n        the compiler or linker options. They have no other purpose.\n    */\n    pthread_attr_t pthread_attr;\n    pthread_attr_init(&pthread_attr);\n    pthread_attr_destroy(&pthread_attr);\n\n    _sapp_init_state(desc);\n    _sapp.x11.window_state = NormalState;\n\n    XInitThreads();\n    XrmInitialize();\n    _sapp.x11.display = XOpenDisplay(NULL);\n    if (!_sapp.x11.display) {\n        _SAPP_PANIC(LINUX_X11_OPEN_DISPLAY_FAILED);\n    }\n    _sapp.x11.screen = DefaultScreen(_sapp.x11.display);\n    _sapp.x11.root = DefaultRootWindow(_sapp.x11.display);\n    _sapp_x11_query_system_dpi();\n    _sapp.dpi_scale = _sapp.x11.dpi / 96.0f;\n    _sapp_x11_init_extensions();\n    _sapp_x11_create_cursors();\n    XkbSetDetectableAutoRepeat(_sapp.x11.display, true, NULL);\n    _sapp_x11_init_keytable();\n#if defined(_SAPP_GLX)\n    _sapp_glx_init();\n    Visual* visual = 0;\n    int depth = 0;\n    _sapp_glx_choose_visual(&visual, &depth);\n    _sapp_x11_create_window(visual, depth);\n    _sapp_glx_create_context();\n    _sapp_glx_swapinterval(_sapp.swap_interval);\n#else\n    _sapp_egl_init();\n#endif\n    sapp_set_icon(&desc->icon);\n    _sapp.valid = true;\n    _sapp_x11_show_window();\n    if (_sapp.fullscreen) {\n        _sapp_x11_set_fullscreen(true);\n    }\n\n    XFlush(_sapp.x11.display);\n    while (!_sapp.quit_ordered) {\n        _sapp_timing_measure(&_sapp.timing);\n        int count = XPending(_sapp.x11.display);\n        while (count--) {\n            XEvent event;\n            XNextEvent(_sapp.x11.display, &event);\n            _sapp_x11_process_event(&event);\n        }\n        _sapp_frame();\n#if defined(_SAPP_GLX)\n        _sapp_glx_swap_buffers();\n#else\n        eglSwapBuffers(_sapp.egl.display, _sapp.egl.surface);\n#endif\n        XFlush(_sapp.x11.display);\n        /* handle quit-requested, either from window or from sapp_request_quit() */\n        if (_sapp.quit_requested && !_sapp.quit_ordered) {\n            /* give user code a chance to intervene */\n            _sapp_x11_app_event(SAPP_EVENTTYPE_QUIT_REQUESTED);\n            /* if user code hasn't intervened, quit the app */\n            if (_sapp.quit_requested) {\n                _sapp.quit_ordered = true;\n            }\n        }\n    }\n    _sapp_call_cleanup();\n#if defined(_SAPP_GLX)\n    _sapp_glx_destroy_context();\n#else\n    _sapp_egl_destroy();\n#endif\n    _sapp_x11_destroy_window();\n    _sapp_x11_destroy_cursors();\n    XCloseDisplay(_sapp.x11.display);\n    _sapp_discard_state();\n}\n\n#if !defined(SOKOL_NO_ENTRY)\nint main(int argc, char* argv[]) {\n    sapp_desc desc = sokol_main(argc, argv);\n    _sapp_linux_run(&desc);\n    return 0;\n}\n#endif /* SOKOL_NO_ENTRY */\n#endif /* _SAPP_LINUX */\n\n//                  \n//                     \n//                 \n//                       \n//               \n//\n// >>public\n#if defined(SOKOL_NO_ENTRY)\nSOKOL_API_IMPL void sapp_run(const sapp_desc* desc) {\n    SOKOL_ASSERT(desc);\n    #if defined(_SAPP_MACOS)\n        _sapp_macos_run(desc);\n    #elif defined(_SAPP_IOS)\n        _sapp_ios_run(desc);\n    #elif defined(_SAPP_EMSCRIPTEN)\n        _sapp_emsc_run(desc);\n    #elif defined(_SAPP_WIN32)\n        _sapp_win32_run(desc);\n    #elif defined(_SAPP_LINUX)\n        _sapp_linux_run(desc);\n    #else\n    #error \"sapp_run() not supported on this platform\"\n    #endif\n}\n\n/* this is just a stub so the linker doesn't complain */\nsapp_desc sokol_main(int argc, char* argv[]) {\n    _SOKOL_UNUSED(argc);\n    _SOKOL_UNUSED(argv);\n    sapp_desc desc;\n    _sapp_clear(&desc, sizeof(desc));\n    return desc;\n}\n#else\n/* likewise, in normal mode, sapp_run() is just an empty stub */\nSOKOL_API_IMPL void sapp_run(const sapp_desc* desc) {\n    _SOKOL_UNUSED(desc);\n}\n#endif\n\nSOKOL_API_IMPL bool sapp_isvalid(void) {\n    return _sapp.valid;\n}\n\nSOKOL_API_IMPL void* sapp_userdata(void) {\n    return _sapp.desc.user_data;\n}\n\nSOKOL_API_IMPL sapp_desc sapp_query_desc(void) {\n    return _sapp.desc;\n}\n\nSOKOL_API_IMPL uint64_t sapp_frame_count(void) {\n    return _sapp.frame_count;\n}\n\nSOKOL_API_IMPL double sapp_frame_duration(void) {\n    return _sapp_timing_get_avg(&_sapp.timing);\n}\n\nSOKOL_API_IMPL int sapp_width(void) {\n    return (_sapp.framebuffer_width > 0) ? _sapp.framebuffer_width : 1;\n}\n\nSOKOL_API_IMPL float sapp_widthf(void) {\n    return (float)sapp_width();\n}\n\nSOKOL_API_IMPL int sapp_height(void) {\n    return (_sapp.framebuffer_height > 0) ? _sapp.framebuffer_height : 1;\n}\n\nSOKOL_API_IMPL float sapp_heightf(void) {\n    return (float)sapp_height();\n}\n\nSOKOL_API_IMPL int sapp_color_format(void) {\n    #if defined(_SAPP_EMSCRIPTEN) && defined(SOKOL_WGPU)\n        switch (_sapp.wgpu.render_format) {\n            case WGPUTextureFormat_RGBA8Unorm:\n                return _SAPP_PIXELFORMAT_RGBA8;\n            case WGPUTextureFormat_BGRA8Unorm:\n                return _SAPP_PIXELFORMAT_BGRA8;\n            default:\n                SOKOL_UNREACHABLE;\n                return 0;\n        }\n    #elif defined(SOKOL_METAL) || defined(SOKOL_D3D11)\n        return _SAPP_PIXELFORMAT_BGRA8;\n    #else\n        return _SAPP_PIXELFORMAT_RGBA8;\n    #endif\n}\n\nSOKOL_API_IMPL int sapp_depth_format(void) {\n    return _SAPP_PIXELFORMAT_DEPTH_STENCIL;\n}\n\nSOKOL_API_IMPL int sapp_sample_count(void) {\n    return _sapp.sample_count;\n}\n\nSOKOL_API_IMPL bool sapp_high_dpi(void) {\n    return _sapp.desc.high_dpi && (_sapp.dpi_scale >= 1.5f);\n}\n\nSOKOL_API_IMPL float sapp_dpi_scale(void) {\n    return _sapp.dpi_scale;\n}\n\nSOKOL_API_IMPL const void* sapp_egl_get_display(void) {\n    SOKOL_ASSERT(_sapp.valid);\n    #if defined(_SAPP_ANDROID)\n        return _sapp.android.display;\n    #elif defined(_SAPP_LINUX) && !defined(_SAPP_GLX)\n        return _sapp.egl.display;\n    #else\n        return 0;\n    #endif\n}\n\nSOKOL_API_IMPL const void* sapp_egl_get_context(void) {\n    SOKOL_ASSERT(_sapp.valid);\n    #if defined(_SAPP_ANDROID)\n        return _sapp.android.context;\n    #elif defined(_SAPP_LINUX) && !defined(_SAPP_GLX)\n        return _sapp.egl.context;\n    #else\n        return 0;\n    #endif\n}\n\nSOKOL_API_IMPL void sapp_show_keyboard(bool show) {\n    #if defined(_SAPP_IOS)\n    _sapp_ios_show_keyboard(show);\n    #elif defined(_SAPP_ANDROID)\n    _sapp_android_show_keyboard(show);\n    #else\n    _SOKOL_UNUSED(show);\n    #endif\n}\n\nSOKOL_API_IMPL bool sapp_keyboard_shown(void) {\n    return _sapp.onscreen_keyboard_shown;\n}\n\nSOKOL_API_IMPL bool sapp_is_fullscreen(void) {\n    return _sapp.fullscreen;\n}\n\nSOKOL_API_IMPL void sapp_toggle_fullscreen(void) {\n    #if defined(_SAPP_MACOS)\n    _sapp_macos_toggle_fullscreen();\n    #elif defined(_SAPP_WIN32)\n    _sapp_win32_toggle_fullscreen();\n    #elif defined(_SAPP_LINUX)\n    _sapp_x11_toggle_fullscreen();\n    #endif\n}\n\n/* NOTE that sapp_show_mouse() does not \"stack\" like the Win32 or macOS API functions! */\nSOKOL_API_IMPL void sapp_show_mouse(bool show) {\n    if (_sapp.mouse.shown != show) {\n        #if defined(_SAPP_MACOS)\n        _sapp_macos_update_cursor(_sapp.mouse.current_cursor, show);\n        #elif defined(_SAPP_WIN32)\n        _sapp_win32_update_cursor(_sapp.mouse.current_cursor, show, false);\n        #elif defined(_SAPP_LINUX)\n        _sapp_x11_update_cursor(_sapp.mouse.current_cursor, show);\n        #elif defined(_SAPP_EMSCRIPTEN)\n        _sapp_emsc_update_cursor(_sapp.mouse.current_cursor, show);\n        #endif\n        _sapp.mouse.shown = show;\n    }\n}\n\nSOKOL_API_IMPL bool sapp_mouse_shown(void) {\n    return _sapp.mouse.shown;\n}\n\nSOKOL_API_IMPL void sapp_lock_mouse(bool lock) {\n    #if defined(_SAPP_MACOS)\n    _sapp_macos_lock_mouse(lock);\n    #elif defined(_SAPP_EMSCRIPTEN)\n    _sapp_emsc_lock_mouse(lock);\n    #elif defined(_SAPP_WIN32)\n    _sapp_win32_lock_mouse(lock);\n    #elif defined(_SAPP_LINUX)\n    _sapp_x11_lock_mouse(lock);\n    #else\n    _sapp.mouse.locked = lock;\n    #endif\n}\n\nSOKOL_API_IMPL bool sapp_mouse_locked(void) {\n    return _sapp.mouse.locked;\n}\n\nSOKOL_API_IMPL void sapp_set_mouse_cursor(sapp_mouse_cursor cursor) {\n    SOKOL_ASSERT((cursor >= 0) && (cursor < _SAPP_MOUSECURSOR_NUM));\n    if (_sapp.mouse.current_cursor != cursor) {\n        #if defined(_SAPP_MACOS)\n        _sapp_macos_update_cursor(cursor, _sapp.mouse.shown);\n        #elif defined(_SAPP_WIN32)\n        _sapp_win32_update_cursor(cursor, _sapp.mouse.shown, false);\n        #elif defined(_SAPP_LINUX)\n        _sapp_x11_update_cursor(cursor, _sapp.mouse.shown);\n        #elif defined(_SAPP_EMSCRIPTEN)\n        _sapp_emsc_update_cursor(cursor, _sapp.mouse.shown);\n        #endif\n        _sapp.mouse.current_cursor = cursor;\n    }\n}\n\nSOKOL_API_IMPL sapp_mouse_cursor sapp_get_mouse_cursor(void) {\n    return _sapp.mouse.current_cursor;\n}\n\nSOKOL_API_IMPL void sapp_request_quit(void) {\n    _sapp.quit_requested = true;\n}\n\nSOKOL_API_IMPL void sapp_cancel_quit(void) {\n    _sapp.quit_requested = false;\n}\n\nSOKOL_API_IMPL void sapp_quit(void) {\n    _sapp.quit_ordered = true;\n}\n\nSOKOL_API_IMPL void sapp_consume_event(void) {\n    _sapp.event_consumed = true;\n}\n\n/* NOTE: on HTML5, sapp_set_clipboard_string() must be called from within event handler! */\nSOKOL_API_IMPL void sapp_set_clipboard_string(const char* str) {\n    if (!_sapp.clipboard.enabled) {\n        return;\n    }\n    SOKOL_ASSERT(str);\n    #if defined(_SAPP_MACOS)\n        _sapp_macos_set_clipboard_string(str);\n    #elif defined(_SAPP_EMSCRIPTEN)\n        _sapp_emsc_set_clipboard_string(str);\n    #elif defined(_SAPP_WIN32)\n        _sapp_win32_set_clipboard_string(str);\n    #elif defined(_SAPP_LINUX)\n        _sapp_x11_set_clipboard_string(str);\n    #else\n        /* not implemented */\n    #endif\n    _sapp_strcpy(str, _sapp.clipboard.buffer, _sapp.clipboard.buf_size);\n}\n\nSOKOL_API_IMPL const char* sapp_get_clipboard_string(void) {\n    if (!_sapp.clipboard.enabled) {\n        return \"\";\n    }\n    #if defined(_SAPP_MACOS)\n        return _sapp_macos_get_clipboard_string();\n    #elif defined(_SAPP_EMSCRIPTEN)\n        return _sapp.clipboard.buffer;\n    #elif defined(_SAPP_WIN32)\n        return _sapp_win32_get_clipboard_string();\n    #elif defined(_SAPP_LINUX)\n        return _sapp_x11_get_clipboard_string();\n    #else\n        /* not implemented */\n        return _sapp.clipboard.buffer;\n    #endif\n}\n\nSOKOL_API_IMPL void sapp_set_window_title(const char* title) {\n    SOKOL_ASSERT(title);\n    _sapp_strcpy(title, _sapp.window_title, sizeof(_sapp.window_title));\n    #if defined(_SAPP_MACOS)\n        _sapp_macos_update_window_title();\n    #elif defined(_SAPP_WIN32)\n        _sapp_win32_update_window_title();\n    #elif defined(_SAPP_LINUX)\n        _sapp_x11_update_window_title();\n    #endif\n}\n\nSOKOL_API_IMPL void sapp_set_icon(const sapp_icon_desc* desc) {\n    SOKOL_ASSERT(desc);\n    if (desc->sokol_default) {\n        if (0 == _sapp.default_icon_pixels) {\n            _sapp_setup_default_icon();\n        }\n        SOKOL_ASSERT(0 != _sapp.default_icon_pixels);\n        desc = &_sapp.default_icon_desc;\n    }\n    const int num_images = _sapp_icon_num_images(desc);\n    if (num_images == 0) {\n        return;\n    }\n    SOKOL_ASSERT((num_images > 0) && (num_images <= SAPP_MAX_ICONIMAGES));\n    if (!_sapp_validate_icon_desc(desc, num_images)) {\n        return;\n    }\n    #if defined(_SAPP_MACOS)\n        _sapp_macos_set_icon(desc, num_images);\n    #elif defined(_SAPP_WIN32)\n        _sapp_win32_set_icon(desc, num_images);\n    #elif defined(_SAPP_LINUX)\n        _sapp_x11_set_icon(desc, num_images);\n    #elif defined(_SAPP_EMSCRIPTEN)\n        _sapp_emsc_set_icon(desc, num_images);\n    #endif\n}\n\nSOKOL_API_IMPL int sapp_get_num_dropped_files(void) {\n    SOKOL_ASSERT(_sapp.drop.enabled);\n    return _sapp.drop.num_files;\n}\n\nSOKOL_API_IMPL const char* sapp_get_dropped_file_path(int index) {\n    SOKOL_ASSERT(_sapp.drop.enabled);\n    SOKOL_ASSERT((index >= 0) && (index < _sapp.drop.num_files));\n    SOKOL_ASSERT(_sapp.drop.buffer);\n    if (!_sapp.drop.enabled) {\n        return \"\";\n    }\n    if ((index < 0) || (index >= _sapp.drop.max_files)) {\n        return \"\";\n    }\n    return (const char*) _sapp_dropped_file_path_ptr(index);\n}\n\nSOKOL_API_IMPL uint32_t sapp_html5_get_dropped_file_size(int index) {\n    SOKOL_ASSERT(_sapp.drop.enabled);\n    SOKOL_ASSERT((index >= 0) && (index < _sapp.drop.num_files));\n    #if defined(_SAPP_EMSCRIPTEN)\n        if (!_sapp.drop.enabled) {\n            return 0;\n        }\n        return sapp_js_dropped_file_size(index);\n    #else\n        (void)index;\n        return 0;\n    #endif\n}\n\nSOKOL_API_IMPL void sapp_html5_fetch_dropped_file(const sapp_html5_fetch_request* request) {\n    SOKOL_ASSERT(_sapp.drop.enabled);\n    SOKOL_ASSERT(request);\n    SOKOL_ASSERT(request->callback);\n    SOKOL_ASSERT(request->buffer.ptr);\n    SOKOL_ASSERT(request->buffer.size > 0);\n    #if defined(_SAPP_EMSCRIPTEN)\n        const int index = request->dropped_file_index;\n        sapp_html5_fetch_error error_code = SAPP_HTML5_FETCH_ERROR_NO_ERROR;\n        if ((index < 0) || (index >= _sapp.drop.num_files)) {\n            error_code = SAPP_HTML5_FETCH_ERROR_OTHER;\n        }\n        if (sapp_html5_get_dropped_file_size(index) > request->buffer.size) {\n            error_code = SAPP_HTML5_FETCH_ERROR_BUFFER_TOO_SMALL;\n        }\n        if (SAPP_HTML5_FETCH_ERROR_NO_ERROR != error_code) {\n            _sapp_emsc_invoke_fetch_cb(index,\n                false, // success\n                (int)error_code,\n                request->callback,\n                0, // fetched_size\n                (void*)request->buffer.ptr,\n                request->buffer.size,\n                request->user_data);\n        }\n        else {\n            sapp_js_fetch_dropped_file(index,\n                request->callback,\n                (void*)request->buffer.ptr,\n                request->buffer.size,\n                request->user_data);\n        }\n    #else\n        (void)request;\n    #endif\n}\n\nSOKOL_API_IMPL const void* sapp_metal_get_device(void) {\n    SOKOL_ASSERT(_sapp.valid);\n    #if defined(SOKOL_METAL)\n        #if defined(_SAPP_MACOS)\n            const void* obj = (__bridge const void*) _sapp.macos.mtl_device;\n        #else\n            const void* obj = (__bridge const void*) _sapp.ios.mtl_device;\n        #endif\n        SOKOL_ASSERT(obj);\n        return obj;\n    #else\n        return 0;\n    #endif\n}\n\nSOKOL_API_IMPL const void* sapp_metal_get_current_drawable(void) {\n    SOKOL_ASSERT(_sapp.valid);\n    #if defined(SOKOL_METAL)\n        #if defined(_SAPP_MACOS)\n            const void* obj = (__bridge const void*) [_sapp.macos.view currentDrawable];\n        #else\n            const void* obj = (__bridge const void*) [_sapp.ios.view currentDrawable];\n        #endif\n        SOKOL_ASSERT(obj);\n        return obj;\n    #else\n        return 0;\n    #endif\n}\n\nSOKOL_API_IMPL const void* sapp_metal_get_depth_stencil_texture(void) {\n    SOKOL_ASSERT(_sapp.valid);\n    #if defined(SOKOL_METAL)\n        #if defined(_SAPP_MACOS)\n            const void* obj = (__bridge const void*) [_sapp.macos.view depthStencilTexture];\n        #else\n            const void* obj = (__bridge const void*) [_sapp.ios.view depthStencilTexture];\n        #endif\n        return obj;\n    #else\n        return 0;\n    #endif\n}\n\nSOKOL_API_IMPL const void* sapp_metal_get_msaa_color_texture(void) {\n    SOKOL_ASSERT(_sapp.valid);\n    #if defined(SOKOL_METAL)\n        #if defined(_SAPP_MACOS)\n            const void* obj = (__bridge const void*) [_sapp.macos.view multisampleColorTexture];\n        #else\n            const void* obj = (__bridge const void*) [_sapp.ios.view multisampleColorTexture];\n        #endif\n        return obj;\n    #else\n        return 0;\n    #endif\n}\n\nSOKOL_API_IMPL const void* sapp_macos_get_window(void) {\n    #if defined(_SAPP_MACOS)\n        const void* obj = (__bridge const void*) _sapp.macos.window;\n        SOKOL_ASSERT(obj);\n        return obj;\n    #else\n        return 0;\n    #endif\n}\n\nSOKOL_API_IMPL const void* sapp_ios_get_window(void) {\n    #if defined(_SAPP_IOS)\n        const void* obj = (__bridge const void*) _sapp.ios.window;\n        SOKOL_ASSERT(obj);\n        return obj;\n    #else\n        return 0;\n    #endif\n}\n\nSOKOL_API_IMPL const void* sapp_d3d11_get_device(void) {\n    SOKOL_ASSERT(_sapp.valid);\n    #if defined(SOKOL_D3D11)\n        return _sapp.d3d11.device;\n    #else\n        return 0;\n    #endif\n}\n\nSOKOL_API_IMPL const void* sapp_d3d11_get_device_context(void) {\n    SOKOL_ASSERT(_sapp.valid);\n    #if defined(SOKOL_D3D11)\n        return _sapp.d3d11.device_context;\n    #else\n        return 0;\n    #endif\n}\n\nSOKOL_API_IMPL const void* sapp_d3d11_get_swap_chain(void) {\n    SOKOL_ASSERT(_sapp.valid);\n#if defined(SOKOL_D3D11)\n    return _sapp.d3d11.swap_chain;\n#else\n    return 0;\n#endif\n}\n\nSOKOL_API_IMPL const void* sapp_d3d11_get_render_view(void) {\n    SOKOL_ASSERT(_sapp.valid);\n    #if defined(SOKOL_D3D11)\n        if (_sapp.sample_count > 1) {\n            SOKOL_ASSERT(_sapp.d3d11.msaa_rtv);\n            return _sapp.d3d11.msaa_rtv;\n        } else {\n            SOKOL_ASSERT(_sapp.d3d11.rtv);\n            return _sapp.d3d11.rtv;\n        }\n    #else\n        return 0;\n    #endif\n}\n\nSOKOL_API_IMPL const void* sapp_d3d11_get_resolve_view(void) {\n    SOKOL_ASSERT(_sapp.valid);\n    #if defined(SOKOL_D3D11)\n        if (_sapp.sample_count > 1) {\n            SOKOL_ASSERT(_sapp.d3d11.rtv);\n            return _sapp.d3d11.rtv;\n        } else {\n            return 0;\n        }\n    #else\n        return 0;\n    #endif\n}\n\nSOKOL_API_IMPL const void* sapp_d3d11_get_depth_stencil_view(void) {\n    SOKOL_ASSERT(_sapp.valid);\n    #if defined(SOKOL_D3D11)\n        return _sapp.d3d11.dsv;\n    #else\n        return 0;\n    #endif\n}\n\nSOKOL_API_IMPL const void* sapp_win32_get_hwnd(void) {\n    SOKOL_ASSERT(_sapp.valid);\n    #if defined(_SAPP_WIN32)\n        return _sapp.win32.hwnd;\n    #else\n        return 0;\n    #endif\n}\n\nSOKOL_API_IMPL const void* sapp_wgpu_get_device(void) {\n    SOKOL_ASSERT(_sapp.valid);\n    #if defined(_SAPP_EMSCRIPTEN) && defined(SOKOL_WGPU)\n        return (const void*) _sapp.wgpu.device;\n    #else\n        return 0;\n    #endif\n}\n\nSOKOL_API_IMPL const void* sapp_wgpu_get_render_view(void) {\n    SOKOL_ASSERT(_sapp.valid);\n    #if defined(_SAPP_EMSCRIPTEN) && defined(SOKOL_WGPU)\n        if (_sapp.sample_count > 1) {\n            SOKOL_ASSERT(_sapp.wgpu.msaa_view);\n            return (const void*) _sapp.wgpu.msaa_view;\n        } else {\n            SOKOL_ASSERT(_sapp.wgpu.swapchain_view);\n            return (const void*) _sapp.wgpu.swapchain_view;\n        }\n    #else\n        return 0;\n    #endif\n}\n\nSOKOL_API_IMPL const void* sapp_wgpu_get_resolve_view(void) {\n    SOKOL_ASSERT(_sapp.valid);\n    #if defined(_SAPP_EMSCRIPTEN) && defined(SOKOL_WGPU)\n        if (_sapp.sample_count > 1) {\n            SOKOL_ASSERT(_sapp.wgpu.swapchain_view);\n            return (const void*) _sapp.wgpu.swapchain_view;\n        } else {\n            return 0;\n        }\n    #else\n        return 0;\n    #endif\n}\n\nSOKOL_API_IMPL const void* sapp_wgpu_get_depth_stencil_view(void) {\n    SOKOL_ASSERT(_sapp.valid);\n    #if defined(_SAPP_EMSCRIPTEN) && defined(SOKOL_WGPU)\n        return (const void*) _sapp.wgpu.depth_stencil_view;\n    #else\n        return 0;\n    #endif\n}\n\nSOKOL_API_IMPL uint32_t sapp_gl_get_framebuffer(void) {\n    SOKOL_ASSERT(_sapp.valid);\n    #if defined(_SAPP_ANY_GL)\n        return _sapp.gl.framebuffer;\n    #else\n        return 0;\n    #endif\n}\n\nSOKOL_API_IMPL int sapp_gl_get_major_version(void) {\n    SOKOL_ASSERT(_sapp.valid);\n    #if defined(SOKOL_GLCORE)\n        return _sapp.desc.gl_major_version;\n    #else\n        return 0;\n    #endif\n}\n\nSOKOL_API_IMPL int sapp_gl_get_minor_version(void) {\n    SOKOL_ASSERT(_sapp.valid);\n    #if defined(SOKOL_GLCORE)\n        return _sapp.desc.gl_minor_version;\n    #else\n        return 0;\n    #endif\n}\n\nSOKOL_API_IMPL const void* sapp_android_get_native_activity(void) {\n    // NOTE: _sapp.valid is not asserted here because sapp_android_get_native_activity()\n    // needs to be callable from within sokol_main() (see: https://github.com/floooh/sokol/issues/708)\n    #if defined(_SAPP_ANDROID)\n        return (void*)_sapp.android.activity;\n    #else\n        return 0;\n    #endif\n}\n\nSOKOL_API_IMPL void sapp_html5_ask_leave_site(bool ask) {\n    _sapp.html5_ask_leave_site = ask;\n}\n\n#endif /* SOKOL_APP_IMPL */\n"
        },
        {
          "name": "sokol_args.h",
          "type": "blob",
          "size": 26.072265625,
          "content": "#if defined(SOKOL_IMPL) && !defined(SOKOL_ARGS_IMPL)\n#define SOKOL_ARGS_IMPL\n#endif\n#ifndef SOKOL_ARGS_INCLUDED\n/*\n    sokol_args.h    -- cross-platform key/value arg-parsing for web and native\n\n    Project URL: https://github.com/floooh/sokol\n\n    Do this:\n        #define SOKOL_IMPL or\n        #define SOKOL_ARGS_IMPL\n    before you include this file in *one* C or C++ file to create the\n    implementation.\n\n    Optionally provide the following defines with your own implementations:\n\n    SOKOL_ASSERT(c)     - your own assert macro (default: assert(c))\n    SOKOL_ARGS_API_DECL - public function declaration prefix (default: extern)\n    SOKOL_API_DECL      - same as SOKOL_ARGS_API_DECL\n    SOKOL_API_IMPL      - public function implementation prefix (default: -)\n\n    If sokol_args.h is compiled as a DLL, define the following before\n    including the declaration or implementation:\n\n    SOKOL_DLL\n\n    On Windows, SOKOL_DLL will define SOKOL_ARGS_API_DECL as __declspec(dllexport)\n    or __declspec(dllimport) as needed.\n\n    OVERVIEW\n    ========\n    sokol_args.h provides a simple unified argument parsing API for WebAssembly and\n    native apps.\n\n    When running as a WebAssembly app, arguments are taken from the page URL:\n\n        https://floooh.github.io/tiny8bit/kc85.html?type=kc85_3&mod=m022&snapshot=kc85/jungle.kcc\n\n    The same arguments provided to a command line app:\n\n        kc85 type=kc85_3 mod=m022 snapshot=kc85/jungle.kcc\n\n    You can also use standalone keys without value:\n\n        https://floooh.github.io/tiny8bit/kc85.html?bla&blub\n\n    On the command line:\n\n        kc85 bla blub\n\n    Such value-less keys are reported as the value being an empty string, but they\n    can be tested with `sapp_exists(\"bla\")` or `sapp_boolean(\"blub\")`.\n\n    ARGUMENT FORMATTING\n    ===================\n    On the web platform, arguments must be formatted as a valid URL query string\n    with 'percent encoding' used for special characters.\n\n    Strings are expected to be UTF-8 encoded (although sokol_args.h doesn't\n    contain any special UTF-8 handling). See below on how to obtain\n    UTF-8 encoded argc/argv values on Windows when using WinMain() as\n    entry point.\n\n    On native platforms the following rules must be followed:\n\n    Arguments have the general form\n\n        key=value\n\n    or\n\n        key\n\n    When a key has no value, the value will be assigned an empty string.\n\n    Key/value pairs are separated by 'whitespace', valid whitespace\n    characters are space and tab.\n\n    Whitespace characters in front and after the separating '=' character\n    are ignored:\n\n        key = value\n\n    ...is the same as\n\n        key=value\n\n    The 'key' string must be a simple string without escape sequences or whitespace.\n\n    The 'value' string can be quoted, and quoted value strings can contain\n    whitespace:\n\n        key = 'single-quoted value'\n        key = \"double-quoted value\"\n\n    Single-quoted value strings can contain double quotes, and vice-versa:\n\n        key = 'single-quoted value \"can contain double-quotes\"'\n        key = \"double-quoted value 'can contain single-quotes'\"\n\n    Note that correct quoting can be tricky on some shells, since command\n    shells may remove quotes, unless they're escaped.\n\n    Value strings can contain a small selection of escape sequences:\n\n        \\n  - newline\n        \\r  - carriage return\n        \\t  - tab\n        \\\\  - escaped backslash\n\n    (more escape codes may be added in the future).\n\n    CODE EXAMPLE\n    ============\n\n        int main(int argc, char* argv[]) {\n            // initialize sokol_args with default parameters\n            sargs_setup(&(sargs_desc){\n                .argc = argc,\n                .argv = argv\n            });\n\n            // check if a key exists...\n            if (sargs_exists(\"bla\")) {\n                ...\n            }\n\n            // get value string for key, if not found, return empty string \"\"\n            const char* val0 = sargs_value(\"bla\");\n\n            // get value string for key, or default string if key not found\n            const char* val1 = sargs_value_def(\"bla\", \"default_value\");\n\n            // check if a key matches expected value\n            if (sargs_equals(\"type\", \"kc85_4\")) {\n                ...\n            }\n\n            // check if a key's value is \"true\", \"yes\" or \"on\" or if this is a standalone key\n            if (sargs_boolean(\"joystick_enabled\")) {\n                ...\n            }\n\n            // iterate over keys and values\n            for (int i = 0; i < sargs_num_args(); i++) {\n                printf(\"key: %s, value: %s\\n\", sargs_key_at(i), sargs_value_at(i));\n            }\n\n            // lookup argument index by key string, will return -1 if key\n            // is not found, sargs_key_at() and sargs_value_at() will return\n            // an empty string for invalid indices\n            int index = sargs_find(\"bla\");\n            printf(\"key: %s, value: %s\\n\", sargs_key_at(index), sargs_value_at(index));\n\n            // shutdown sokol-args\n            sargs_shutdown();\n        }\n\n    WINMAIN AND ARGC / ARGV\n    =======================\n    On Windows with WinMain() based apps, getting UTF8-encoded command line\n    arguments is a bit more complicated:\n\n    First call GetCommandLineW(), this returns the entire command line\n    as UTF-16 string. Then call CommandLineToArgvW(), this parses the\n    command line string into the usual argc/argv format (but in UTF-16).\n    Finally convert the UTF-16 strings in argv[] into UTF-8 via\n    WideCharToMultiByte().\n\n    See the function _sapp_win32_command_line_to_utf8_argv() in sokol_app.h\n    for example code how to do this (if you're using sokol_app.h, it will\n    already convert the command line arguments to UTF-8 for you of course,\n    so you can plug them directly into sokol_app.h).\n\n    API DOCUMENTATION\n    =================\n    void sargs_setup(const sargs_desc* desc)\n        Initialize sokol_args, desc contains the following configuration\n        parameters:\n            int argc        - the main function's argc parameter\n            char** argv     - the main function's argv parameter\n            int max_args    - max number of key/value pairs, default is 16\n            int buf_size    - size of the internal string buffer, default is 16384\n\n        Note that on the web, argc and argv will be ignored and the arguments\n        will be taken from the page URL instead.\n\n        sargs_setup() will allocate 2 memory chunks: one for keeping track\n        of the key/value args of size 'max_args*8', and a string buffer\n        of size 'buf_size'.\n\n    void sargs_shutdown(void)\n        Shutdown sokol-args and free any allocated memory.\n\n    bool sargs_isvalid(void)\n        Return true between sargs_setup() and sargs_shutdown()\n\n    bool sargs_exists(const char* key)\n        Test if an argument exists by its key name.\n\n    const char* sargs_value(const char* key)\n        Return value associated with key. Returns an empty string (\"\") if the\n        key doesn't exist, or if the key doesn't have a value.\n\n    const char* sargs_value_def(const char* key, const char* default)\n        Return value associated with key, or the provided default value if the\n        key doesn't exist, or this is a value-less key.\n\n    bool sargs_equals(const char* key, const char* val);\n        Return true if the value associated with key matches\n        the 'val' argument.\n\n    bool sargs_boolean(const char* key)\n        Return true if the value string of 'key' is one of 'true', 'yes', 'on',\n        or this is a key without value.\n\n    int sargs_find(const char* key)\n        Find argument by key name and return its index, or -1 if not found.\n\n    int sargs_num_args(void)\n        Return number of key/value pairs.\n\n    const char* sargs_key_at(int index)\n        Return the key name of argument at index. Returns empty string if\n        is index is outside range.\n\n    const char* sargs_value_at(int index)\n        Return the value of argument at index. Returns empty string\n        if the key at index has no value, or the index is out-of-range.\n\n\n    MEMORY ALLOCATION OVERRIDE\n    ==========================\n    You can override the memory allocation functions at initialization time\n    like this:\n\n        void* my_alloc(size_t size, void* user_data) {\n            return malloc(size);\n        }\n\n        void my_free(void* ptr, void* user_data) {\n            free(ptr);\n        }\n\n        ...\n            sargs_setup(&(sargs_desc){\n                // ...\n                .allocator = {\n                    .alloc_fn = my_alloc,\n                    .free_fn = my_free,\n                    .user_data = ...,\n                }\n            });\n        ...\n\n    If no overrides are provided, malloc and free will be used.\n\n    This only affects memory allocation calls done by sokol_args.h\n    itself though, not any allocations in OS libraries.\n\n    TODO\n    ====\n    - parsing errors?\n\n    LICENSE\n    =======\n\n    zlib/libpng license\n\n    Copyright (c) 2018 Andre Weissflog\n\n    This software is provided 'as-is', without any express or implied warranty.\n    In no event will the authors be held liable for any damages arising from the\n    use of this software.\n\n    Permission is granted to anyone to use this software for any purpose,\n    including commercial applications, and to alter it and redistribute it\n    freely, subject to the following restrictions:\n\n        1. The origin of this software must not be misrepresented; you must not\n        claim that you wrote the original software. If you use this software in a\n        product, an acknowledgment in the product documentation would be\n        appreciated but is not required.\n\n        2. Altered source versions must be plainly marked as such, and must not\n        be misrepresented as being the original software.\n\n        3. This notice may not be removed or altered from any source\n        distribution.\n*/\n#define SOKOL_ARGS_INCLUDED (1)\n#include <stdint.h>\n#include <stdbool.h>\n#include <stddef.h> // size_t\n\n#if defined(SOKOL_API_DECL) && !defined(SOKOL_ARGS_API_DECL)\n#define SOKOL_ARGS_API_DECL SOKOL_API_DECL\n#endif\n#ifndef SOKOL_ARGS_API_DECL\n#if defined(_WIN32) && defined(SOKOL_DLL) && defined(SOKOL_ARGS_IMPL)\n#define SOKOL_ARGS_API_DECL __declspec(dllexport)\n#elif defined(_WIN32) && defined(SOKOL_DLL)\n#define SOKOL_ARGS_API_DECL __declspec(dllimport)\n#else\n#define SOKOL_ARGS_API_DECL extern\n#endif\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/*\n    sargs_allocator\n\n    Used in sargs_desc to provide custom memory-alloc and -free functions\n    to sokol_args.h. If memory management should be overridden, both the\n    alloc_fn and free_fn function must be provided (e.g. it's not valid to\n    override one function but not the other).\n*/\ntypedef struct sargs_allocator {\n    void* (*alloc_fn)(size_t size, void* user_data);\n    void (*free_fn)(void* ptr, void* user_data);\n    void* user_data;\n} sargs_allocator;\n\ntypedef struct sargs_desc {\n    int argc;\n    char** argv;\n    int max_args;\n    int buf_size;\n    sargs_allocator allocator;\n} sargs_desc;\n\n/* setup sokol-args */\nSOKOL_ARGS_API_DECL void sargs_setup(const sargs_desc* desc);\n/* shutdown sokol-args */\nSOKOL_ARGS_API_DECL void sargs_shutdown(void);\n/* true between sargs_setup() and sargs_shutdown() */\nSOKOL_ARGS_API_DECL bool sargs_isvalid(void);\n/* test if an argument exists by key name */\nSOKOL_ARGS_API_DECL bool sargs_exists(const char* key);\n/* get value by key name, return empty string if key doesn't exist or an existing key has no value */\nSOKOL_ARGS_API_DECL const char* sargs_value(const char* key);\n/* get value by key name, return provided default if key doesn't exist or has no value */\nSOKOL_ARGS_API_DECL const char* sargs_value_def(const char* key, const char* def);\n/* return true if val arg matches the value associated with key */\nSOKOL_ARGS_API_DECL bool sargs_equals(const char* key, const char* val);\n/* return true if key's value is \"true\", \"yes\", \"on\" or an existing key has no value */\nSOKOL_ARGS_API_DECL bool sargs_boolean(const char* key);\n/* get index of arg by key name, return -1 if not exists */\nSOKOL_ARGS_API_DECL int sargs_find(const char* key);\n/* get number of parsed arguments */\nSOKOL_ARGS_API_DECL int sargs_num_args(void);\n/* get key name of argument at index, or empty string */\nSOKOL_ARGS_API_DECL const char* sargs_key_at(int index);\n/* get value string of argument at index, or empty string */\nSOKOL_ARGS_API_DECL const char* sargs_value_at(int index);\n\n#ifdef __cplusplus\n} /* extern \"C\" */\n\n/* reference-based equivalents for c++ */\ninline void sargs_setup(const sargs_desc& desc) { return sargs_setup(&desc); }\n\n#endif\n#endif // SOKOL_ARGS_INCLUDED\n\n/*--- IMPLEMENTATION ---------------------------------------------------------*/\n#ifdef SOKOL_ARGS_IMPL\n#define SOKOL_ARGS_IMPL_INCLUDED (1)\n\n#if defined(SOKOL_MALLOC) || defined(SOKOL_CALLOC) || defined(SOKOL_FREE)\n#error \"SOKOL_MALLOC/CALLOC/FREE macros are no longer supported, please use sargs_desc.allocator to override memory allocation functions\"\n#endif\n\n#include <string.h> // memset, strcmp\n#include <stdlib.h> // malloc, free\n\n#if defined(__EMSCRIPTEN__)\n#include <emscripten/emscripten.h>\n#endif\n\n#ifndef SOKOL_API_IMPL\n    #define SOKOL_API_IMPL\n#endif\n#ifndef SOKOL_DEBUG\n    #ifndef NDEBUG\n        #define SOKOL_DEBUG\n    #endif\n#endif\n#ifndef SOKOL_ASSERT\n    #include <assert.h>\n    #define SOKOL_ASSERT(c) assert(c)\n#endif\n\n#ifndef _SOKOL_PRIVATE\n    #if defined(__GNUC__) || defined(__clang__)\n        #define _SOKOL_PRIVATE __attribute__((unused)) static\n    #else\n        #define _SOKOL_PRIVATE static\n    #endif\n#endif\n\n#define _sargs_def(val, def) (((val) == 0) ? (def) : (val))\n\n#define _SARGS_MAX_ARGS_DEF (16)\n#define _SARGS_BUF_SIZE_DEF (16*1024)\n\n/* parser state */\n#define _SARGS_EXPECT_KEY (1<<0)\n#define _SARGS_EXPECT_SEP (1<<1)\n#define _SARGS_EXPECT_VAL (1<<2)\n#define _SARGS_PARSING_KEY (1<<3)\n#define _SARGS_PARSING_VAL (1<<4)\n#define _SARGS_ERROR (1<<5)\n\n/* a key/value pair struct */\ntypedef struct {\n    int key;        /* index to start of key string in buf */\n    int val;        /* index to start of value string in buf */\n} _sargs_kvp_t;\n\n/* sokol-args state */\ntypedef struct {\n    int max_args;       /* number of key/value pairs in args array */\n    int num_args;       /* number of valid items in args array */\n    _sargs_kvp_t* args;   /* key/value pair array */\n    int buf_size;       /* size of buffer in bytes */\n    int buf_pos;        /* current buffer position */\n    char* buf;          /* character buffer, first char is reserved and zero for 'empty string' */\n    bool valid;\n    uint32_t parse_state;\n    char quote;         /* current quote char, 0 if not in a quote */\n    bool in_escape;     /* currently in an escape sequence */\n    sargs_allocator allocator;\n} _sargs_state_t;\nstatic _sargs_state_t _sargs;\n\n/*== PRIVATE IMPLEMENTATION FUNCTIONS ========================================*/\n_SOKOL_PRIVATE void _sargs_clear(void* ptr, size_t size) {\n    SOKOL_ASSERT(ptr && (size > 0));\n    memset(ptr, 0, size);\n}\n\n_SOKOL_PRIVATE void* _sargs_malloc(size_t size) {\n    SOKOL_ASSERT(size > 0);\n    void* ptr;\n    if (_sargs.allocator.alloc_fn) {\n        ptr = _sargs.allocator.alloc_fn(size, _sargs.allocator.user_data);\n    } else {\n        ptr = malloc(size);\n    }\n    SOKOL_ASSERT(ptr);\n    return ptr;\n}\n\n_SOKOL_PRIVATE void* _sargs_malloc_clear(size_t size) {\n    void* ptr = _sargs_malloc(size);\n    _sargs_clear(ptr, size);\n    return ptr;\n}\n\n_SOKOL_PRIVATE void _sargs_free(void* ptr) {\n    if (_sargs.allocator.free_fn) {\n        _sargs.allocator.free_fn(ptr, _sargs.allocator.user_data);\n    } else {\n        free(ptr);\n    }\n}\n\n_SOKOL_PRIVATE void _sargs_putc(char c) {\n    if ((_sargs.buf_pos+2) < _sargs.buf_size) {\n        _sargs.buf[_sargs.buf_pos++] = c;\n    }\n}\n\n_SOKOL_PRIVATE const char* _sargs_str(int index) {\n    SOKOL_ASSERT((index >= 0) && (index < _sargs.buf_size));\n    return &_sargs.buf[index];\n}\n\n/*-- argument parser functions ------------------*/\n_SOKOL_PRIVATE void _sargs_expect_key(void) {\n    _sargs.parse_state = _SARGS_EXPECT_KEY;\n}\n\n_SOKOL_PRIVATE bool _sargs_key_expected(void) {\n    return 0 != (_sargs.parse_state & _SARGS_EXPECT_KEY);\n}\n\n_SOKOL_PRIVATE void _sargs_expect_val(void) {\n    _sargs.parse_state = _SARGS_EXPECT_VAL;\n}\n\n_SOKOL_PRIVATE bool _sargs_val_expected(void) {\n    return 0 != (_sargs.parse_state & _SARGS_EXPECT_VAL);\n}\n\n_SOKOL_PRIVATE void _sargs_expect_sep_or_key(void) {\n    _sargs.parse_state = _SARGS_EXPECT_SEP | _SARGS_EXPECT_KEY;\n}\n\n_SOKOL_PRIVATE bool _sargs_any_expected(void) {\n    return 0 != (_sargs.parse_state & (_SARGS_EXPECT_KEY | _SARGS_EXPECT_VAL | _SARGS_EXPECT_SEP));\n}\n\n_SOKOL_PRIVATE bool _sargs_is_separator(char c) {\n    return c == '=';\n}\n\n_SOKOL_PRIVATE bool _sargs_is_quote(char c) {\n    if (0 == _sargs.quote) {\n        return (c == '\\'') || (c == '\"');\n    }\n    else {\n        return c == _sargs.quote;\n    }\n}\n\n_SOKOL_PRIVATE void _sargs_begin_quote(char c) {\n    _sargs.quote = c;\n}\n\n_SOKOL_PRIVATE void _sargs_end_quote(void) {\n    _sargs.quote = 0;\n}\n\n_SOKOL_PRIVATE bool _sargs_in_quotes(void) {\n    return 0 != _sargs.quote;\n}\n\n_SOKOL_PRIVATE bool _sargs_is_whitespace(char c) {\n    return !_sargs_in_quotes() && ((c == ' ') || (c == '\\t'));\n}\n\n_SOKOL_PRIVATE void _sargs_start_key(void) {\n    SOKOL_ASSERT((_sargs.num_args >= 0) && (_sargs.num_args < _sargs.max_args));\n    _sargs.parse_state = _SARGS_PARSING_KEY;\n    _sargs.args[_sargs.num_args].key = _sargs.buf_pos;\n}\n\n_SOKOL_PRIVATE void _sargs_end_key(void) {\n    SOKOL_ASSERT((_sargs.num_args >= 0) && (_sargs.num_args < _sargs.max_args));\n    _sargs_putc(0);\n    // declare val as empty string in case this is a key-only arg\n    _sargs.args[_sargs.num_args].val = _sargs.buf_pos - 1;\n    _sargs.num_args++;\n    _sargs.parse_state = 0;\n}\n\n_SOKOL_PRIVATE bool _sargs_parsing_key(void) {\n    return 0 != (_sargs.parse_state & _SARGS_PARSING_KEY);\n}\n\n_SOKOL_PRIVATE void _sargs_start_val(void) {\n    SOKOL_ASSERT((_sargs.num_args > 0) && (_sargs.num_args <= _sargs.max_args));\n    _sargs.parse_state = _SARGS_PARSING_VAL;\n    _sargs.args[_sargs.num_args - 1].val = _sargs.buf_pos;\n}\n\n_SOKOL_PRIVATE void _sargs_end_val(void) {\n    _sargs_putc(0);\n    _sargs.parse_state = 0;\n}\n\n_SOKOL_PRIVATE bool _sargs_is_escape(char c) {\n    return '\\\\' == c;\n}\n\n_SOKOL_PRIVATE void _sargs_start_escape(void) {\n    _sargs.in_escape = true;\n}\n\n_SOKOL_PRIVATE bool _sargs_in_escape(void) {\n    return _sargs.in_escape;\n}\n\n_SOKOL_PRIVATE char _sargs_escape(char c) {\n    switch (c) {\n        case 'n':   return '\\n';\n        case 't':   return '\\t';\n        case 'r':   return '\\r';\n        case '\\\\':  return '\\\\';\n        default:    return c;\n    }\n}\n\n_SOKOL_PRIVATE void _sargs_end_escape(void) {\n    _sargs.in_escape = false;\n}\n\n_SOKOL_PRIVATE bool _sargs_parsing_val(void) {\n    return 0 != (_sargs.parse_state & _SARGS_PARSING_VAL);\n}\n\n_SOKOL_PRIVATE bool _sargs_parse_carg(const char* src) {\n    char c;\n    while (0 != (c = *src++)) {\n        if (_sargs_in_escape()) {\n            c = _sargs_escape(c);\n            _sargs_end_escape();\n        }\n        else if (_sargs_is_escape(c)) {\n            _sargs_start_escape();\n            continue;\n        }\n        if (_sargs_any_expected()) {\n            if (!_sargs_is_whitespace(c)) {\n                /* start of key, value or separator */\n                if (_sargs_is_separator(c)) {\n                    /* skip separator and expect value */\n                    _sargs_expect_val();\n                    continue;\n                }\n                else if (_sargs_key_expected()) {\n                    /* start of new key */\n                    _sargs_start_key();\n                }\n                else if (_sargs_val_expected()) {\n                    /* start of value */\n                    if (_sargs_is_quote(c)) {\n                        _sargs_begin_quote(c);\n                        continue;\n                    }\n                    _sargs_start_val();\n                }\n            }\n            else {\n                /* skip white space */\n                continue;\n            }\n        }\n        else if (_sargs_parsing_key()) {\n            if (_sargs_is_whitespace(c) || _sargs_is_separator(c)) {\n                /* end of key string */\n                _sargs_end_key();\n                if (_sargs_is_separator(c)) {\n                    _sargs_expect_val();\n                }\n                else {\n                    _sargs_expect_sep_or_key();\n                }\n                continue;\n            }\n        }\n        else if (_sargs_parsing_val()) {\n            if (_sargs_in_quotes()) {\n                /* when in quotes, whitespace is a normal character\n                   and a matching quote ends the value string\n                */\n                if (_sargs_is_quote(c)) {\n                    _sargs_end_quote();\n                    _sargs_end_val();\n                    _sargs_expect_key();\n                    continue;\n                }\n            }\n            else if (_sargs_is_whitespace(c)) {\n                /* end of value string (no quotes) */\n                _sargs_end_val();\n                _sargs_expect_key();\n                continue;\n            }\n        }\n        _sargs_putc(c);\n    }\n    if (_sargs_parsing_key()) {\n        _sargs_end_key();\n        _sargs_expect_sep_or_key();\n    }\n    else if (_sargs_parsing_val() && !_sargs_in_quotes()) {\n        _sargs_end_val();\n        _sargs_expect_key();\n    }\n    return true;\n}\n\n_SOKOL_PRIVATE bool _sargs_parse_cargs(int argc, const char** argv) {\n    _sargs_expect_key();\n    bool retval = true;\n    for (int i = 1; i < argc; i++) {\n        retval &= _sargs_parse_carg(argv[i]);\n    }\n    _sargs.parse_state = 0;\n    return retval;\n}\n\n/*-- EMSCRIPTEN IMPLEMENTATION -----------------------------------------------*/\n#if defined(__EMSCRIPTEN__)\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#if defined(EM_JS_DEPS)\nEM_JS_DEPS(sokol_audio, \"$withStackSave,$stringToUTF8OnStack\");\n#endif\n\nEMSCRIPTEN_KEEPALIVE void _sargs_add_kvp(const char* key, const char* val) {\n    SOKOL_ASSERT(_sargs.valid && key && val);\n    if (_sargs.num_args >= _sargs.max_args) {\n        return;\n    }\n\n    /* copy key string */\n    char c;\n    _sargs.args[_sargs.num_args].key = _sargs.buf_pos;\n    const char* ptr = key;\n    while (0 != (c = *ptr++)) {\n        _sargs_putc(c);\n    }\n    _sargs_putc(0);\n\n    /* copy value string */\n    _sargs.args[_sargs.num_args].val = _sargs.buf_pos;\n    ptr = val;\n    while (0 != (c = *ptr++)) {\n        _sargs_putc(c);\n    }\n    _sargs_putc(0);\n\n    _sargs.num_args++;\n}\n#ifdef __cplusplus\n} /* extern \"C\" */\n#endif\n\n/* JS function to extract arguments from the page URL */\nEM_JS(void, sargs_js_parse_url, (void), {\n    const params = new URLSearchParams(window.location.search).entries();\n    for (let p = params.next(); !p.done; p = params.next()) {\n        const key = p.value[0];\n        const val = p.value[1];\n        withStackSave(() => {\n            const key_cstr = stringToUTF8OnStack(key);\n            const val_cstr = stringToUTF8OnStack(val);\n            __sargs_add_kvp(key_cstr, val_cstr)\n        });\n    }\n});\n\n#endif /* EMSCRIPTEN */\n\n/*== PUBLIC IMPLEMENTATION FUNCTIONS =========================================*/\nSOKOL_API_IMPL void sargs_setup(const sargs_desc* desc) {\n    SOKOL_ASSERT(desc);\n    _sargs_clear(&_sargs, sizeof(_sargs));\n    _sargs.max_args = _sargs_def(desc->max_args, _SARGS_MAX_ARGS_DEF);\n    _sargs.buf_size = _sargs_def(desc->buf_size, _SARGS_BUF_SIZE_DEF);\n    SOKOL_ASSERT(_sargs.buf_size > 8);\n    _sargs.args = (_sargs_kvp_t*) _sargs_malloc_clear((size_t)_sargs.max_args * sizeof(_sargs_kvp_t));\n    _sargs.buf = (char*) _sargs_malloc_clear((size_t)_sargs.buf_size * sizeof(char));\n    /* the first character in buf is reserved and always zero, this is the 'empty string' */\n    _sargs.buf_pos = 1;\n    _sargs.allocator = desc->allocator;\n    _sargs.valid = true;\n\n    /* parse argc/argv */\n    _sargs_parse_cargs(desc->argc, (const char**) desc->argv);\n\n    #if defined(__EMSCRIPTEN__)\n        /* on emscripten, also parse the page URL*/\n        sargs_js_parse_url();\n    #endif\n}\n\nSOKOL_API_IMPL void sargs_shutdown(void) {\n    SOKOL_ASSERT(_sargs.valid);\n    if (_sargs.args) {\n        _sargs_free(_sargs.args);\n        _sargs.args = 0;\n    }\n    if (_sargs.buf) {\n        _sargs_free(_sargs.buf);\n        _sargs.buf = 0;\n    }\n    _sargs.valid = false;\n}\n\nSOKOL_API_IMPL bool sargs_isvalid(void) {\n    return _sargs.valid;\n}\n\nSOKOL_API_IMPL int sargs_find(const char* key) {\n    SOKOL_ASSERT(_sargs.valid && key);\n    for (int i = 0; i < _sargs.num_args; i++) {\n        if (0 == strcmp(_sargs_str(_sargs.args[i].key), key)) {\n            return i;\n        }\n    }\n    return -1;\n}\n\nSOKOL_API_IMPL int sargs_num_args(void) {\n    SOKOL_ASSERT(_sargs.valid);\n    return _sargs.num_args;\n}\n\nSOKOL_API_IMPL const char* sargs_key_at(int index) {\n    SOKOL_ASSERT(_sargs.valid);\n    if ((index >= 0) && (index < _sargs.num_args)) {\n        return _sargs_str(_sargs.args[index].key);\n    }\n    else {\n        /* index 0 is always the empty string */\n        return _sargs_str(0);\n    }\n}\n\nSOKOL_API_IMPL const char* sargs_value_at(int index) {\n    SOKOL_ASSERT(_sargs.valid);\n    if ((index >= 0) && (index < _sargs.num_args)) {\n        return _sargs_str(_sargs.args[index].val);\n    }\n    else {\n        /* index 0 is always the empty string */\n        return _sargs_str(0);\n    }\n}\n\nSOKOL_API_IMPL bool sargs_exists(const char* key) {\n    SOKOL_ASSERT(_sargs.valid && key);\n    return -1 != sargs_find(key);\n}\n\nSOKOL_API_IMPL const char* sargs_value(const char* key) {\n    SOKOL_ASSERT(_sargs.valid && key);\n    return sargs_value_at(sargs_find(key));\n}\n\nSOKOL_API_IMPL const char* sargs_value_def(const char* key, const char* def) {\n    SOKOL_ASSERT(_sargs.valid && key && def);\n    int arg_index = sargs_find(key);\n    if (-1 != arg_index) {\n        const char* res = sargs_value_at(arg_index);\n        SOKOL_ASSERT(res);\n        if (res[0] == 0) {\n            return def;\n        } else {\n            return res;\n        }\n    }\n    else {\n        return def;\n    }\n}\n\nSOKOL_API_IMPL bool sargs_equals(const char* key, const char* val) {\n    SOKOL_ASSERT(_sargs.valid && key && val);\n    return 0 == strcmp(sargs_value(key), val);\n}\n\nSOKOL_API_IMPL bool sargs_boolean(const char* key) {\n    if (sargs_exists(key)) {\n        const char* val = sargs_value(key);\n        return (0 == strcmp(\"true\", val)) ||\n               (0 == strcmp(\"yes\", val)) ||\n               (0 == strcmp(\"on\", val)) ||\n               (0 == strcmp(\"\", val));\n    } else {\n        return false;\n    }\n}\n\n#endif /* SOKOL_ARGS_IMPL */\n"
        },
        {
          "name": "sokol_audio.h",
          "type": "blob",
          "size": 102.1357421875,
          "content": "#if defined(SOKOL_IMPL) && !defined(SOKOL_AUDIO_IMPL)\n#define SOKOL_AUDIO_IMPL\n#endif\n#ifndef SOKOL_AUDIO_INCLUDED\n/*\n    sokol_audio.h -- cross-platform audio-streaming API\n\n    Project URL: https://github.com/floooh/sokol\n\n    Do this:\n        #define SOKOL_IMPL or\n        #define SOKOL_AUDIO_IMPL\n    before you include this file in *one* C or C++ file to create the\n    implementation.\n\n    Optionally provide the following defines with your own implementations:\n\n    SOKOL_DUMMY_BACKEND - use a dummy backend\n    SOKOL_ASSERT(c)     - your own assert macro (default: assert(c))\n    SOKOL_AUDIO_API_DECL- public function declaration prefix (default: extern)\n    SOKOL_API_DECL      - same as SOKOL_AUDIO_API_DECL\n    SOKOL_API_IMPL      - public function implementation prefix (default: -)\n\n    SAUDIO_RING_MAX_SLOTS           - max number of slots in the push-audio ring buffer (default 1024)\n    SAUDIO_OSX_USE_SYSTEM_HEADERS   - define this to force inclusion of system headers on\n                                      macOS instead of using embedded CoreAudio declarations\n    SAUDIO_ANDROID_AAUDIO           - on Android, select the AAudio backend (default)\n    SAUDIO_ANDROID_SLES             - on Android, select the OpenSLES backend\n\n    If sokol_audio.h is compiled as a DLL, define the following before\n    including the declaration or implementation:\n\n    SOKOL_DLL\n\n    On Windows, SOKOL_DLL will define SOKOL_AUDIO_API_DECL as __declspec(dllexport)\n    or __declspec(dllimport) as needed.\n\n    Link with the following libraries:\n\n    - on macOS: AudioToolbox\n    - on iOS: AudioToolbox, AVFoundation\n    - on FreeBSD: asound\n    - on Linux: asound\n    - on Android: link with OpenSLES or aaudio\n    - on Windows with MSVC or Clang toolchain: no action needed, libs are defined in-source via pragma-comment-lib\n    - on Windows with MINGW/MSYS2 gcc: compile with '-mwin32' and link with -lole32\n\n    FEATURE OVERVIEW\n    ================\n    You provide a mono- or stereo-stream of 32-bit float samples, which\n    Sokol Audio feeds into platform-specific audio backends:\n\n    - Windows: WASAPI\n    - Linux: ALSA\n    - FreeBSD: ALSA\n    - macOS: CoreAudio\n    - iOS: CoreAudio+AVAudioSession\n    - emscripten: WebAudio with ScriptProcessorNode\n    - Android: AAudio (default) or OpenSLES, select at build time\n\n    Sokol Audio will not do any buffer mixing or volume control, if you have\n    multiple independent input streams of sample data you need to perform the\n    mixing yourself before forwarding the data to Sokol Audio.\n\n    There are two mutually exclusive ways to provide the sample data:\n\n    1. Callback model: You provide a callback function, which will be called\n       when Sokol Audio needs new samples. On all platforms except emscripten,\n       this function is called from a separate thread.\n    2. Push model: Your code pushes small blocks of sample data from your\n       main loop or a thread you created. The pushed data is stored in\n       a ring buffer where it is pulled by the backend code when\n       needed.\n\n    The callback model is preferred because it is the most direct way to\n    feed sample data into the audio backends and also has less moving parts\n    (there is no ring buffer between your code and the audio backend).\n\n    Sometimes it is not possible to generate the audio stream directly in a\n    callback function running in a separate thread, for such cases Sokol Audio\n    provides the push-model as a convenience.\n\n    SOKOL AUDIO, SOLOUD AND MINIAUDIO\n    =================================\n    The WASAPI, ALSA, OpenSLES and CoreAudio backend code has been taken from the\n    SoLoud library (with some modifications, so any bugs in there are most\n    likely my fault). If you need a more fully-featured audio solution, check\n    out SoLoud, it's excellent:\n\n        https://github.com/jarikomppa/soloud\n\n    Another alternative which feature-wise is somewhere inbetween SoLoud and\n    sokol-audio might be MiniAudio:\n\n        https://github.com/mackron/miniaudio\n\n    GLOSSARY\n    ========\n    - stream buffer:\n        The internal audio data buffer, usually provided by the backend API. The\n        size of the stream buffer defines the base latency, smaller buffers have\n        lower latency but may cause audio glitches. Bigger buffers reduce or\n        eliminate glitches, but have a higher base latency.\n\n    - stream callback:\n        Optional callback function which is called by Sokol Audio when it\n        needs new samples. On Windows, macOS/iOS and Linux, this is called in\n        a separate thread, on WebAudio, this is called per-frame in the\n        browser thread.\n\n    - channel:\n        A discrete track of audio data, currently 1-channel (mono) and\n        2-channel (stereo) is supported and tested.\n\n    - sample:\n        The magnitude of an audio signal on one channel at a given time. In\n        Sokol Audio, samples are 32-bit float numbers in the range -1.0 to\n        +1.0.\n\n    - frame:\n        The tightly packed set of samples for all channels at a given time.\n        For mono 1 frame is 1 sample. For stereo, 1 frame is 2 samples.\n\n    - packet:\n        In Sokol Audio, a small chunk of audio data that is moved from the\n        main thread to the audio streaming thread in order to decouple the\n        rate at which the main thread provides new audio data, and the\n        streaming thread consuming audio data.\n\n    WORKING WITH SOKOL AUDIO\n    ========================\n    First call saudio_setup() with your preferred audio playback options.\n    In most cases you can stick with the default values, these provide\n    a good balance between low-latency and glitch-free playback\n    on all audio backends.\n\n    You should always provide a logging callback to be aware of any\n    warnings and errors. The easiest way is to use sokol_log.h for this:\n\n        #include \"sokol_log.h\"\n        // ...\n        saudio_setup(&(saudio_desc){\n            .logger = {\n                .func = slog_func,\n            }\n        });\n\n    If you want to use the callback-model, you need to provide a stream\n    callback function either in saudio_desc.stream_cb or saudio_desc.stream_userdata_cb,\n    otherwise keep both function pointers zero-initialized.\n\n    Use push model and default playback parameters:\n\n        saudio_setup(&(saudio_desc){ .logger.func = slog_func });\n\n    Use stream callback model and default playback parameters:\n\n        saudio_setup(&(saudio_desc){\n            .stream_cb = my_stream_callback\n            .logger.func = slog_func,\n        });\n\n    The standard stream callback doesn't have a user data argument, if you want\n    that, use the alternative stream_userdata_cb and also set the user_data pointer:\n\n        saudio_setup(&(saudio_desc){\n            .stream_userdata_cb = my_stream_callback,\n            .user_data = &my_data\n            .logger.func = slog_func,\n        });\n\n    The following playback parameters can be provided through the\n    saudio_desc struct:\n\n    General parameters (both for stream-callback and push-model):\n\n        int sample_rate     -- the sample rate in Hz, default: 44100\n        int num_channels    -- number of channels, default: 1 (mono)\n        int buffer_frames   -- number of frames in streaming buffer, default: 2048\n\n    The stream callback prototype (either with or without userdata):\n\n        void (*stream_cb)(float* buffer, int num_frames, int num_channels)\n        void (*stream_userdata_cb)(float* buffer, int num_frames, int num_channels, void* user_data)\n            Function pointer to the user-provide stream callback.\n\n    Push-model parameters:\n\n        int packet_frames   -- number of frames in a packet, default: 128\n        int num_packets     -- number of packets in ring buffer, default: 64\n\n    The sample_rate and num_channels parameters are only hints for the audio\n    backend, it isn't guaranteed that those are the values used for actual\n    playback.\n\n    To get the actual parameters, call the following functions after\n    saudio_setup():\n\n        int saudio_sample_rate(void)\n        int saudio_channels(void);\n\n    It's unlikely that the number of channels will be different than requested,\n    but a different sample rate isn't uncommon.\n\n    (NOTE: there's an yet unsolved issue when an audio backend might switch\n    to a different sample rate when switching output devices, for instance\n    plugging in a bluetooth headset, this case is currently not handled in\n    Sokol Audio).\n\n    You can check if audio initialization was successful with\n    saudio_isvalid(). If backend initialization failed for some reason\n    (for instance when there's no audio device in the machine), this\n    will return false. Not checking for success won't do any harm, all\n    Sokol Audio function will silently fail when called after initialization\n    has failed, so apart from missing audio output, nothing bad will happen.\n\n    Before your application exits, you should call\n\n        saudio_shutdown();\n\n    This stops the audio thread (on Linux, Windows and macOS/iOS) and\n    properly shuts down the audio backend.\n\n    THE STREAM CALLBACK MODEL\n    =========================\n    To use Sokol Audio in stream-callback-mode, provide a callback function\n    like this in the saudio_desc struct when calling saudio_setup():\n\n    void stream_cb(float* buffer, int num_frames, int num_channels) {\n        ...\n    }\n\n    Or the alternative version with a user-data argument:\n\n    void stream_userdata_cb(float* buffer, int num_frames, int num_channels, void* user_data) {\n        my_data_t* my_data = (my_data_t*) user_data;\n        ...\n    }\n\n    The job of the callback function is to fill the *buffer* with 32-bit\n    float sample values.\n\n    To output silence, fill the buffer with zeros:\n\n        void stream_cb(float* buffer, int num_frames, int num_channels) {\n            const int num_samples = num_frames * num_channels;\n            for (int i = 0; i < num_samples; i++) {\n                buffer[i] = 0.0f;\n            }\n        }\n\n    For stereo output (num_channels == 2), the samples for the left\n    and right channel are interleaved:\n\n        void stream_cb(float* buffer, int num_frames, int num_channels) {\n            assert(2 == num_channels);\n            for (int i = 0; i < num_frames; i++) {\n                buffer[2*i + 0] = ...;  // left channel\n                buffer[2*i + 1] = ...;  // right channel\n            }\n        }\n\n    Please keep in mind that the stream callback function is running in a\n    separate thread, if you need to share data with the main thread you need\n    to take care yourself to make the access to the shared data thread-safe!\n\n    THE PUSH MODEL\n    ==============\n    To use the push-model for providing audio data, simply don't set (keep\n    zero-initialized) the stream_cb field in the saudio_desc struct when\n    calling saudio_setup().\n\n    To provide sample data with the push model, call the saudio_push()\n    function at regular intervals (for instance once per frame). You can\n    call the saudio_expect() function to ask Sokol Audio how much room is\n    in the ring buffer, but if you provide a continuous stream of data\n    at the right sample rate, saudio_expect() isn't required (it's a simple\n    way to sync/throttle your sample generation code with the playback\n    rate though).\n\n    With saudio_push() you may need to maintain your own intermediate sample\n    buffer, since pushing individual sample values isn't very efficient.\n    The following example is from the MOD player sample in\n    sokol-samples (https://github.com/floooh/sokol-samples):\n\n        const int num_frames = saudio_expect();\n        if (num_frames > 0) {\n            const int num_samples = num_frames * saudio_channels();\n            read_samples(flt_buf, num_samples);\n            saudio_push(flt_buf, num_frames);\n        }\n\n    Another option is to ignore saudio_expect(), and just push samples as they\n    are generated in small batches. In this case you *need* to generate the\n    samples at the right sample rate:\n\n    The following example is taken from the Tiny Emulators project\n    (https://github.com/floooh/chips-test), this is for mono playback,\n    so (num_samples == num_frames):\n\n        // tick the sound generator\n        if (ay38910_tick(&sys->psg)) {\n            // new sample is ready\n            sys->sample_buffer[sys->sample_pos++] = sys->psg.sample;\n            if (sys->sample_pos == sys->num_samples) {\n                // new sample packet is ready\n                saudio_push(sys->sample_buffer, sys->num_samples);\n                sys->sample_pos = 0;\n            }\n        }\n\n    THE WEBAUDIO BACKEND\n    ====================\n    The WebAudio backend is currently using a ScriptProcessorNode callback to\n    feed the sample data into WebAudio. ScriptProcessorNode has been\n    deprecated for a while because it is running from the main thread, with\n    the default initialization parameters it works 'pretty well' though.\n    Ultimately Sokol Audio will use Audio Worklets, but this requires a few\n    more things to fall into place (Audio Worklets implemented everywhere,\n    SharedArrayBuffers enabled again, and I need to figure out a 'low-cost'\n    solution in terms of implementation effort, since Audio Worklets are\n    a lot more complex than ScriptProcessorNode if the audio data needs to come\n    from the main thread).\n\n    The WebAudio backend is automatically selected when compiling for\n    emscripten (__EMSCRIPTEN__ define exists).\n\n    https://developers.google.com/web/updates/2017/12/audio-worklet\n    https://developers.google.com/web/updates/2018/06/audio-worklet-design-pattern\n\n    \"Blob URLs\": https://www.html5rocks.com/en/tutorials/workers/basics/\n\n    Also see: https://blog.paul.cx/post/a-wait-free-spsc-ringbuffer-for-the-web/\n\n    THE COREAUDIO BACKEND\n    =====================\n    The CoreAudio backend is selected on macOS and iOS (__APPLE__ is defined).\n    Since the CoreAudio API is implemented in C (not Objective-C) on macOS the\n    implementation part of Sokol Audio can be included into a C source file.\n\n    However on iOS, Sokol Audio must be compiled as Objective-C due to it's\n    reliance on the AVAudioSession object. The iOS code path support both\n    being compiled with or without ARC (Automatic Reference Counting).\n\n    For thread synchronisation, the CoreAudio backend will use the\n    pthread_mutex_* functions.\n\n    The incoming floating point samples will be directly forwarded to\n    CoreAudio without further conversion.\n\n    macOS and iOS applications that use Sokol Audio need to link with\n    the AudioToolbox framework.\n\n    THE WASAPI BACKEND\n    ==================\n    The WASAPI backend is automatically selected when compiling on Windows\n    (_WIN32 is defined).\n\n    For thread synchronisation a Win32 critical section is used.\n\n    WASAPI may use a different size for its own streaming buffer then requested,\n    so the base latency may be slightly bigger. The current backend implementation\n    converts the incoming floating point sample values to signed 16-bit\n    integers.\n\n    The required Windows system DLLs are linked with #pragma comment(lib, ...),\n    so you shouldn't need to add additional linker libs in the build process\n    (otherwise this is a bug which should be fixed in sokol_audio.h).\n\n    THE ALSA BACKEND\n    ================\n    The ALSA backend is automatically selected when compiling on Linux\n    ('linux' is defined).\n\n    For thread synchronisation, the pthread_mutex_* functions are used.\n\n    Samples are directly forwarded to ALSA in 32-bit float format, no\n    further conversion is taking place.\n\n    You need to link with the 'asound' library, and the <alsa/asoundlib.h>\n    header must be present (usually both are installed with some sort\n    of ALSA development package).\n\n\n    MEMORY ALLOCATION OVERRIDE\n    ==========================\n    You can override the memory allocation functions at initialization time\n    like this:\n\n        void* my_alloc(size_t size, void* user_data) {\n            return malloc(size);\n        }\n\n        void my_free(void* ptr, void* user_data) {\n            free(ptr);\n        }\n\n        ...\n            saudio_setup(&(saudio_desc){\n                // ...\n                .allocator = {\n                    .alloc_fn = my_alloc,\n                    .free_fn = my_free,\n                    .user_data = ...,\n                }\n            });\n        ...\n\n    If no overrides are provided, malloc and free will be used.\n\n    This only affects memory allocation calls done by sokol_audio.h\n    itself though, not any allocations in OS libraries.\n\n    Memory allocation will only happen on the same thread where saudio_setup()\n    was called, so you don't need to worry about thread-safety.\n\n\n    ERROR REPORTING AND LOGGING\n    ===========================\n    To get any logging information at all you need to provide a logging callback in the setup call\n    the easiest way is to use sokol_log.h:\n\n        #include \"sokol_log.h\"\n\n        saudio_setup(&(saudio_desc){ .logger.func = slog_func });\n\n    To override logging with your own callback, first write a logging function like this:\n\n        void my_log(const char* tag,                // e.g. 'saudio'\n                    uint32_t log_level,             // 0=panic, 1=error, 2=warn, 3=info\n                    uint32_t log_item_id,           // SAUDIO_LOGITEM_*\n                    const char* message_or_null,    // a message string, may be nullptr in release mode\n                    uint32_t line_nr,               // line number in sokol_audio.h\n                    const char* filename_or_null,   // source filename, may be nullptr in release mode\n                    void* user_data)\n        {\n            ...\n        }\n\n    ...and then setup sokol-audio like this:\n\n        saudio_setup(&(saudio_desc){\n            .logger = {\n                .func = my_log,\n                .user_data = my_user_data,\n            }\n        });\n\n    The provided logging function must be reentrant (e.g. be callable from\n    different threads).\n\n    If you don't want to provide your own custom logger it is highly recommended to use\n    the standard logger in sokol_log.h instead, otherwise you won't see any warnings or\n    errors.\n\n\n    LICENSE\n    =======\n\n    zlib/libpng license\n\n    Copyright (c) 2018 Andre Weissflog\n\n    This software is provided 'as-is', without any express or implied warranty.\n    In no event will the authors be held liable for any damages arising from the\n    use of this software.\n\n    Permission is granted to anyone to use this software for any purpose,\n    including commercial applications, and to alter it and redistribute it\n    freely, subject to the following restrictions:\n\n        1. The origin of this software must not be misrepresented; you must not\n        claim that you wrote the original software. If you use this software in a\n        product, an acknowledgment in the product documentation would be\n        appreciated but is not required.\n\n        2. Altered source versions must be plainly marked as such, and must not\n        be misrepresented as being the original software.\n\n        3. This notice may not be removed or altered from any source\n        distribution.\n*/\n#define SOKOL_AUDIO_INCLUDED (1)\n#include <stddef.h> // size_t\n#include <stdint.h>\n#include <stdbool.h>\n\n#if defined(SOKOL_API_DECL) && !defined(SOKOL_AUDIO_API_DECL)\n#define SOKOL_AUDIO_API_DECL SOKOL_API_DECL\n#endif\n#ifndef SOKOL_AUDIO_API_DECL\n#if defined(_WIN32) && defined(SOKOL_DLL) && defined(SOKOL_AUDIO_IMPL)\n#define SOKOL_AUDIO_API_DECL __declspec(dllexport)\n#elif defined(_WIN32) && defined(SOKOL_DLL)\n#define SOKOL_AUDIO_API_DECL __declspec(dllimport)\n#else\n#define SOKOL_AUDIO_API_DECL extern\n#endif\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/*\n    saudio_log_item\n\n    Log items are defined via X-Macros, and expanded to an\n    enum 'saudio_log_item', and in debug mode only,\n    corresponding strings.\n\n    Used as parameter in the logging callback.\n*/\n#define _SAUDIO_LOG_ITEMS \\\n    _SAUDIO_LOGITEM_XMACRO(OK, \"Ok\") \\\n    _SAUDIO_LOGITEM_XMACRO(MALLOC_FAILED, \"memory allocation failed\") \\\n    _SAUDIO_LOGITEM_XMACRO(ALSA_SND_PCM_OPEN_FAILED, \"snd_pcm_open() failed\") \\\n    _SAUDIO_LOGITEM_XMACRO(ALSA_FLOAT_SAMPLES_NOT_SUPPORTED, \"floating point sample format not supported\") \\\n    _SAUDIO_LOGITEM_XMACRO(ALSA_REQUESTED_BUFFER_SIZE_NOT_SUPPORTED, \"requested buffer size not supported\") \\\n    _SAUDIO_LOGITEM_XMACRO(ALSA_REQUESTED_CHANNEL_COUNT_NOT_SUPPORTED, \"requested channel count not supported\") \\\n    _SAUDIO_LOGITEM_XMACRO(ALSA_SND_PCM_HW_PARAMS_SET_RATE_NEAR_FAILED, \"snd_pcm_hw_params_set_rate_near() failed\") \\\n    _SAUDIO_LOGITEM_XMACRO(ALSA_SND_PCM_HW_PARAMS_FAILED, \"snd_pcm_hw_params() failed\") \\\n    _SAUDIO_LOGITEM_XMACRO(ALSA_PTHREAD_CREATE_FAILED, \"pthread_create() failed\") \\\n    _SAUDIO_LOGITEM_XMACRO(WASAPI_CREATE_EVENT_FAILED, \"CreateEvent() failed\") \\\n    _SAUDIO_LOGITEM_XMACRO(WASAPI_CREATE_DEVICE_ENUMERATOR_FAILED, \"CoCreateInstance() for IMMDeviceEnumerator failed\") \\\n    _SAUDIO_LOGITEM_XMACRO(WASAPI_GET_DEFAULT_AUDIO_ENDPOINT_FAILED, \"IMMDeviceEnumerator.GetDefaultAudioEndpoint() failed\") \\\n    _SAUDIO_LOGITEM_XMACRO(WASAPI_DEVICE_ACTIVATE_FAILED, \"IMMDevice.Activate() failed\") \\\n    _SAUDIO_LOGITEM_XMACRO(WASAPI_AUDIO_CLIENT_INITIALIZE_FAILED, \"IAudioClient.Initialize() failed\") \\\n    _SAUDIO_LOGITEM_XMACRO(WASAPI_AUDIO_CLIENT_GET_BUFFER_SIZE_FAILED, \"IAudioClient.GetBufferSize() failed\") \\\n    _SAUDIO_LOGITEM_XMACRO(WASAPI_AUDIO_CLIENT_GET_SERVICE_FAILED, \"IAudioClient.GetService() failed\") \\\n    _SAUDIO_LOGITEM_XMACRO(WASAPI_AUDIO_CLIENT_SET_EVENT_HANDLE_FAILED, \"IAudioClient.SetEventHandle() failed\") \\\n    _SAUDIO_LOGITEM_XMACRO(WASAPI_CREATE_THREAD_FAILED, \"CreateThread() failed\") \\\n    _SAUDIO_LOGITEM_XMACRO(AAUDIO_STREAMBUILDER_OPEN_STREAM_FAILED, \"AAudioStreamBuilder_openStream() failed\") \\\n    _SAUDIO_LOGITEM_XMACRO(AAUDIO_PTHREAD_CREATE_FAILED, \"pthread_create() failed after AAUDIO_ERROR_DISCONNECTED\") \\\n    _SAUDIO_LOGITEM_XMACRO(AAUDIO_RESTARTING_STREAM_AFTER_ERROR, \"restarting AAudio stream after error\") \\\n    _SAUDIO_LOGITEM_XMACRO(USING_AAUDIO_BACKEND, \"using AAudio backend\") \\\n    _SAUDIO_LOGITEM_XMACRO(AAUDIO_CREATE_STREAMBUILDER_FAILED, \"AAudio_createStreamBuilder() failed\") \\\n    _SAUDIO_LOGITEM_XMACRO(USING_SLES_BACKEND, \"using OpenSLES backend\") \\\n    _SAUDIO_LOGITEM_XMACRO(SLES_CREATE_ENGINE_FAILED, \"slCreateEngine() failed\") \\\n    _SAUDIO_LOGITEM_XMACRO(SLES_ENGINE_GET_ENGINE_INTERFACE_FAILED, \"GetInterface() for SL_IID_ENGINE failed\") \\\n    _SAUDIO_LOGITEM_XMACRO(SLES_CREATE_OUTPUT_MIX_FAILED, \"CreateOutputMix() failed\") \\\n    _SAUDIO_LOGITEM_XMACRO(SLES_MIXER_GET_VOLUME_INTERFACE_FAILED, \"GetInterface() for SL_IID_VOLUME failed\") \\\n    _SAUDIO_LOGITEM_XMACRO(SLES_ENGINE_CREATE_AUDIO_PLAYER_FAILED, \"CreateAudioPlayer() failed\") \\\n    _SAUDIO_LOGITEM_XMACRO(SLES_PLAYER_GET_PLAY_INTERFACE_FAILED, \"GetInterface() for SL_IID_PLAY failed\") \\\n    _SAUDIO_LOGITEM_XMACRO(SLES_PLAYER_GET_VOLUME_INTERFACE_FAILED, \"GetInterface() for SL_IID_VOLUME failed\") \\\n    _SAUDIO_LOGITEM_XMACRO(SLES_PLAYER_GET_BUFFERQUEUE_INTERFACE_FAILED, \"GetInterface() for SL_IID_ANDROIDSIMPLEBUFFERQUEUE failed\") \\\n    _SAUDIO_LOGITEM_XMACRO(COREAUDIO_NEW_OUTPUT_FAILED, \"AudioQueueNewOutput() failed\") \\\n    _SAUDIO_LOGITEM_XMACRO(COREAUDIO_ALLOCATE_BUFFER_FAILED, \"AudioQueueAllocateBuffer() failed\") \\\n    _SAUDIO_LOGITEM_XMACRO(COREAUDIO_START_FAILED, \"AudioQueueStart() failed\") \\\n    _SAUDIO_LOGITEM_XMACRO(BACKEND_BUFFER_SIZE_ISNT_MULTIPLE_OF_PACKET_SIZE, \"backend buffer size isn't multiple of packet size\") \\\n\n#define _SAUDIO_LOGITEM_XMACRO(item,msg) SAUDIO_LOGITEM_##item,\ntypedef enum saudio_log_item {\n    _SAUDIO_LOG_ITEMS\n} saudio_log_item;\n#undef _SAUDIO_LOGITEM_XMACRO\n\n/*\n    saudio_logger\n\n    Used in saudio_desc to provide a custom logging and error reporting\n    callback to sokol-audio.\n*/\ntypedef struct saudio_logger {\n    void (*func)(\n        const char* tag,                // always \"saudio\"\n        uint32_t log_level,             // 0=panic, 1=error, 2=warning, 3=info\n        uint32_t log_item_id,           // SAUDIO_LOGITEM_*\n        const char* message_or_null,    // a message string, may be nullptr in release mode\n        uint32_t line_nr,               // line number in sokol_audio.h\n        const char* filename_or_null,   // source filename, may be nullptr in release mode\n        void* user_data);\n    void* user_data;\n} saudio_logger;\n\n/*\n    saudio_allocator\n\n    Used in saudio_desc to provide custom memory-alloc and -free functions\n    to sokol_audio.h. If memory management should be overridden, both the\n    alloc_fn and free_fn function must be provided (e.g. it's not valid to\n    override one function but not the other).\n*/\ntypedef struct saudio_allocator {\n    void* (*alloc_fn)(size_t size, void* user_data);\n    void (*free_fn)(void* ptr, void* user_data);\n    void* user_data;\n} saudio_allocator;\n\ntypedef struct saudio_desc {\n    int sample_rate;        // requested sample rate\n    int num_channels;       // number of channels, default: 1 (mono)\n    int buffer_frames;      // number of frames in streaming buffer\n    int packet_frames;      // number of frames in a packet\n    int num_packets;        // number of packets in packet queue\n    void (*stream_cb)(float* buffer, int num_frames, int num_channels);  // optional streaming callback (no user data)\n    void (*stream_userdata_cb)(float* buffer, int num_frames, int num_channels, void* user_data); //... and with user data\n    void* user_data;        // optional user data argument for stream_userdata_cb\n    saudio_allocator allocator;     // optional allocation override functions\n    saudio_logger logger;           // optional logging function (default: NO LOGGING!)\n} saudio_desc;\n\n/* setup sokol-audio */\nSOKOL_AUDIO_API_DECL void saudio_setup(const saudio_desc* desc);\n/* shutdown sokol-audio */\nSOKOL_AUDIO_API_DECL void saudio_shutdown(void);\n/* true after setup if audio backend was successfully initialized */\nSOKOL_AUDIO_API_DECL bool saudio_isvalid(void);\n/* return the saudio_desc.user_data pointer */\nSOKOL_AUDIO_API_DECL void* saudio_userdata(void);\n/* return a copy of the original saudio_desc struct */\nSOKOL_AUDIO_API_DECL saudio_desc saudio_query_desc(void);\n/* actual sample rate */\nSOKOL_AUDIO_API_DECL int saudio_sample_rate(void);\n/* return actual backend buffer size in number of frames */\nSOKOL_AUDIO_API_DECL int saudio_buffer_frames(void);\n/* actual number of channels */\nSOKOL_AUDIO_API_DECL int saudio_channels(void);\n/* return true if audio context is currently suspended (only in WebAudio backend, all other backends return false) */\nSOKOL_AUDIO_API_DECL bool saudio_suspended(void);\n/* get current number of frames to fill packet queue */\nSOKOL_AUDIO_API_DECL int saudio_expect(void);\n/* push sample frames from main thread, returns number of frames actually pushed */\nSOKOL_AUDIO_API_DECL int saudio_push(const float* frames, int num_frames);\n\n#ifdef __cplusplus\n} /* extern \"C\" */\n\n/* reference-based equivalents for c++ */\ninline void saudio_setup(const saudio_desc& desc) { return saudio_setup(&desc); }\n\n#endif\n#endif // SOKOL_AUDIO_INCLUDED\n\n//                                        \n//                                                             \n//                                                  \n//                                                                   \n//                                                      \n//\n// >>implementation\n#ifdef SOKOL_AUDIO_IMPL\n#define SOKOL_AUDIO_IMPL_INCLUDED (1)\n\n#if defined(SOKOL_MALLOC) || defined(SOKOL_CALLOC) || defined(SOKOL_FREE)\n#error \"SOKOL_MALLOC/CALLOC/FREE macros are no longer supported, please use saudio_desc.allocator to override memory allocation functions\"\n#endif\n\n#include <stdlib.h> // alloc, free\n#include <string.h> // memset, memcpy\n#include <stddef.h> // size_t\n\n#ifndef SOKOL_API_IMPL\n    #define SOKOL_API_IMPL\n#endif\n#ifndef SOKOL_DEBUG\n    #ifndef NDEBUG\n        #define SOKOL_DEBUG\n    #endif\n#endif\n#ifndef SOKOL_ASSERT\n    #include <assert.h>\n    #define SOKOL_ASSERT(c) assert(c)\n#endif\n\n#ifndef _SOKOL_PRIVATE\n    #if defined(__GNUC__) || defined(__clang__)\n        #define _SOKOL_PRIVATE __attribute__((unused)) static\n    #else\n        #define _SOKOL_PRIVATE static\n    #endif\n#endif\n\n#ifndef _SOKOL_UNUSED\n    #define _SOKOL_UNUSED(x) (void)(x)\n#endif\n\n// platform detection defines\n#if defined(SOKOL_DUMMY_BACKEND)\n    // nothing\n#elif defined(__APPLE__)\n    #define _SAUDIO_APPLE (1)\n    #include <TargetConditionals.h>\n    #if defined(TARGET_OS_IPHONE) && TARGET_OS_IPHONE\n        #define _SAUDIO_IOS (1)\n    #else\n        #define _SAUDIO_MACOS (1)\n    #endif\n#elif defined(__EMSCRIPTEN__)\n    #define _SAUDIO_EMSCRIPTEN (1)\n#elif defined(_WIN32)\n    #define _SAUDIO_WINDOWS (1)\n    #include <winapifamily.h>\n    #if (defined(WINAPI_FAMILY_PARTITION) && !WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP))\n        #error \"sokol_audio.h no longer supports UWP\"\n    #endif\n#elif defined(__ANDROID__)\n    #define _SAUDIO_ANDROID (1)\n    #if !defined(SAUDIO_ANDROID_SLES) && !defined(SAUDIO_ANDROID_AAUDIO)\n        #define SAUDIO_ANDROID_AAUDIO (1)\n    #endif\n#elif defined(__linux__) || defined(__unix__)\n    #define _SAUDIO_LINUX (1)\n#else\n#error \"sokol_audio.h: Unknown platform\"\n#endif\n\n// platform-specific headers and definitions\n#if defined(SOKOL_DUMMY_BACKEND)\n    #define _SAUDIO_NOTHREADS (1)\n#elif defined(_SAUDIO_WINDOWS)\n    #define _SAUDIO_WINTHREADS (1)\n    #ifndef WIN32_LEAN_AND_MEAN\n    #define WIN32_LEAN_AND_MEAN\n    #endif\n    #ifndef NOMINMAX\n    #define NOMINMAX\n    #endif\n    #include <windows.h>\n    #include <synchapi.h>\n    #pragma comment (lib, \"kernel32\")\n    #pragma comment (lib, \"ole32\")\n    #ifndef CINTERFACE\n    #define CINTERFACE\n    #endif\n    #ifndef COBJMACROS\n    #define COBJMACROS\n    #endif\n    #ifndef CONST_VTABLE\n    #define CONST_VTABLE\n    #endif\n    #include <mmdeviceapi.h>\n    #include <audioclient.h>\n    static const IID _saudio_IID_IAudioClient                               = { 0x1cb9ad4c, 0xdbfa, 0x4c32, {0xb1, 0x78, 0xc2, 0xf5, 0x68, 0xa7, 0x03, 0xb2} };\n    static const IID _saudio_IID_IMMDeviceEnumerator                        = { 0xa95664d2, 0x9614, 0x4f35, {0xa7, 0x46, 0xde, 0x8d, 0xb6, 0x36, 0x17, 0xe6} };\n    static const CLSID _saudio_CLSID_IMMDeviceEnumerator                    = { 0xbcde0395, 0xe52f, 0x467c, {0x8e, 0x3d, 0xc4, 0x57, 0x92, 0x91, 0x69, 0x2e} };\n    static const IID _saudio_IID_IAudioRenderClient                         = { 0xf294acfc, 0x3146, 0x4483, {0xa7, 0xbf, 0xad, 0xdc, 0xa7, 0xc2, 0x60, 0xe2} };\n    static const IID _saudio_IID_Devinterface_Audio_Render                  = { 0xe6327cad, 0xdcec, 0x4949, {0xae, 0x8a, 0x99, 0x1e, 0x97, 0x6a, 0x79, 0xd2} };\n    static const IID _saudio_IID_IActivateAudioInterface_Completion_Handler = { 0x94ea2b94, 0xe9cc, 0x49e0, {0xc0, 0xff, 0xee, 0x64, 0xca, 0x8f, 0x5b, 0x90} };\n    static const GUID _saudio_KSDATAFORMAT_SUBTYPE_IEEE_FLOAT               = { 0x00000003, 0x0000, 0x0010, {0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71} };\n    #if defined(__cplusplus)\n    #define _SOKOL_AUDIO_WIN32COM_ID(x) (x)\n    #else\n    #define _SOKOL_AUDIO_WIN32COM_ID(x) (&x)\n    #endif\n    /* fix for Visual Studio 2015 SDKs */\n    #ifndef AUDCLNT_STREAMFLAGS_AUTOCONVERTPCM\n    #define AUDCLNT_STREAMFLAGS_AUTOCONVERTPCM 0x80000000\n    #endif\n    #ifndef AUDCLNT_STREAMFLAGS_SRC_DEFAULT_QUALITY\n    #define AUDCLNT_STREAMFLAGS_SRC_DEFAULT_QUALITY 0x08000000\n    #endif\n    #ifdef _MSC_VER\n        #pragma warning(push)\n        #pragma warning(disable:4505)   /* unreferenced local function has been removed */\n    #endif\n#elif defined(_SAUDIO_APPLE)\n    #define _SAUDIO_PTHREADS (1)\n    #include <pthread.h>\n    #if defined(_SAUDIO_IOS)\n        // always use system headers on iOS (for now at least)\n        #if !defined(SAUDIO_OSX_USE_SYSTEM_HEADERS)\n            #define SAUDIO_OSX_USE_SYSTEM_HEADERS (1)\n        #endif\n        #if !defined(__cplusplus)\n            #if __has_feature(objc_arc) && !__has_feature(objc_arc_fields)\n                #error \"sokol_audio.h on iOS requires __has_feature(objc_arc_field) if ARC is enabled (use a more recent compiler version)\"\n            #endif\n        #endif\n        #include <AudioToolbox/AudioToolbox.h>\n        #include <AVFoundation/AVFoundation.h>\n    #else\n        #if defined(SAUDIO_OSX_USE_SYSTEM_HEADERS)\n            #include <AudioToolbox/AudioToolbox.h>\n        #endif\n    #endif\n#elif defined(_SAUDIO_ANDROID)\n    #define _SAUDIO_PTHREADS (1)\n    #include <pthread.h>\n    #if defined(SAUDIO_ANDROID_SLES)\n        #include \"SLES/OpenSLES_Android.h\"\n    #elif defined(SAUDIO_ANDROID_AAUDIO)\n        #include \"aaudio/AAudio.h\"\n    #endif\n#elif defined(_SAUDIO_LINUX)\n    #if !defined(__FreeBSD__)\n        #include <alloca.h>\n    #endif\n    #define _SAUDIO_PTHREADS (1)\n    #include <pthread.h>\n    #define ALSA_PCM_NEW_HW_PARAMS_API\n    #include <alsa/asoundlib.h>\n#elif defined(__EMSCRIPTEN__)\n    #define _SAUDIO_NOTHREADS (1)\n    #include <emscripten/emscripten.h>\n#endif\n\n#define _saudio_def(val, def) (((val) == 0) ? (def) : (val))\n#define _saudio_def_flt(val, def) (((val) == 0.0f) ? (def) : (val))\n\n#define _SAUDIO_DEFAULT_SAMPLE_RATE (44100)\n#define _SAUDIO_DEFAULT_BUFFER_FRAMES (2048)\n#define _SAUDIO_DEFAULT_PACKET_FRAMES (128)\n#define _SAUDIO_DEFAULT_NUM_PACKETS ((_SAUDIO_DEFAULT_BUFFER_FRAMES/_SAUDIO_DEFAULT_PACKET_FRAMES)*4)\n\n#ifndef SAUDIO_RING_MAX_SLOTS\n#define SAUDIO_RING_MAX_SLOTS (1024)\n#endif\n\n//             \n//                                    \n//                             \n//                                         \n//                         \n//\n// >>structs\n#if defined(_SAUDIO_PTHREADS)\n\ntypedef struct {\n    pthread_mutex_t mutex;\n} _saudio_mutex_t;\n\n#elif defined(_SAUDIO_WINTHREADS)\n\ntypedef struct {\n    CRITICAL_SECTION critsec;\n} _saudio_mutex_t;\n\n#elif defined(_SAUDIO_NOTHREADS)\n\ntypedef struct {\n    int dummy_mutex;\n} _saudio_mutex_t;\n\n#endif\n\n#if defined(SOKOL_DUMMY_BACKEND)\n\ntypedef struct {\n    int dummy;\n} _saudio_dummy_backend_t;\n\n#elif defined(_SAUDIO_APPLE)\n\n#if defined(SAUDIO_OSX_USE_SYSTEM_HEADERS)\n\ntypedef AudioQueueRef _saudio_AudioQueueRef;\ntypedef AudioQueueBufferRef _saudio_AudioQueueBufferRef;\ntypedef AudioStreamBasicDescription _saudio_AudioStreamBasicDescription;\ntypedef OSStatus _saudio_OSStatus;\n\n#define _saudio_kAudioFormatLinearPCM (kAudioFormatLinearPCM)\n#define _saudio_kLinearPCMFormatFlagIsFloat (kLinearPCMFormatFlagIsFloat)\n#define _saudio_kAudioFormatFlagIsPacked (kAudioFormatFlagIsPacked)\n\n#else\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// embedded AudioToolbox declarations\ntypedef uint32_t _saudio_AudioFormatID;\ntypedef uint32_t _saudio_AudioFormatFlags;\ntypedef int32_t _saudio_OSStatus;\ntypedef uint32_t _saudio_SMPTETimeType;\ntypedef uint32_t _saudio_SMPTETimeFlags;\ntypedef uint32_t _saudio_AudioTimeStampFlags;\ntypedef void* _saudio_CFRunLoopRef;\ntypedef void* _saudio_CFStringRef;\ntypedef void* _saudio_AudioQueueRef;\n\n#define _saudio_kAudioFormatLinearPCM ('lpcm')\n#define _saudio_kLinearPCMFormatFlagIsFloat (1U << 0)\n#define _saudio_kAudioFormatFlagIsPacked (1U << 3)\n\ntypedef struct _saudio_AudioStreamBasicDescription {\n    double mSampleRate;\n    _saudio_AudioFormatID mFormatID;\n    _saudio_AudioFormatFlags mFormatFlags;\n    uint32_t mBytesPerPacket;\n    uint32_t mFramesPerPacket;\n    uint32_t mBytesPerFrame;\n    uint32_t mChannelsPerFrame;\n    uint32_t mBitsPerChannel;\n    uint32_t mReserved;\n} _saudio_AudioStreamBasicDescription;\n\ntypedef struct _saudio_AudioStreamPacketDescription {\n    int64_t mStartOffset;\n    uint32_t mVariableFramesInPacket;\n    uint32_t mDataByteSize;\n} _saudio_AudioStreamPacketDescription;\n\ntypedef struct _saudio_SMPTETime {\n    int16_t mSubframes;\n    int16_t mSubframeDivisor;\n    uint32_t mCounter;\n    _saudio_SMPTETimeType mType;\n    _saudio_SMPTETimeFlags mFlags;\n    int16_t mHours;\n    int16_t mMinutes;\n    int16_t mSeconds;\n    int16_t mFrames;\n} _saudio_SMPTETime;\n\ntypedef struct _saudio_AudioTimeStamp {\n    double mSampleTime;\n    uint64_t mHostTime;\n    double mRateScalar;\n    uint64_t mWordClockTime;\n    _saudio_SMPTETime mSMPTETime;\n    _saudio_AudioTimeStampFlags mFlags;\n    uint32_t mReserved;\n} _saudio_AudioTimeStamp;\n\ntypedef struct _saudio_AudioQueueBuffer {\n    const uint32_t mAudioDataBytesCapacity;\n    void* const mAudioData;\n    uint32_t mAudioDataByteSize;\n    void * mUserData;\n    const uint32_t mPacketDescriptionCapacity;\n    _saudio_AudioStreamPacketDescription* const mPacketDescriptions;\n    uint32_t mPacketDescriptionCount;\n} _saudio_AudioQueueBuffer;\ntypedef _saudio_AudioQueueBuffer* _saudio_AudioQueueBufferRef;\n\ntypedef void (*_saudio_AudioQueueOutputCallback)(void* user_data, _saudio_AudioQueueRef inAQ, _saudio_AudioQueueBufferRef inBuffer);\n\nextern _saudio_OSStatus AudioQueueNewOutput(const _saudio_AudioStreamBasicDescription* inFormat, _saudio_AudioQueueOutputCallback inCallbackProc, void* inUserData, _saudio_CFRunLoopRef inCallbackRunLoop, _saudio_CFStringRef inCallbackRunLoopMode, uint32_t inFlags, _saudio_AudioQueueRef* outAQ);\nextern _saudio_OSStatus AudioQueueDispose(_saudio_AudioQueueRef inAQ, bool inImmediate);\nextern _saudio_OSStatus AudioQueueAllocateBuffer(_saudio_AudioQueueRef inAQ, uint32_t inBufferByteSize, _saudio_AudioQueueBufferRef* outBuffer);\nextern _saudio_OSStatus AudioQueueEnqueueBuffer(_saudio_AudioQueueRef inAQ, _saudio_AudioQueueBufferRef inBuffer, uint32_t inNumPacketDescs, const _saudio_AudioStreamPacketDescription* inPacketDescs);\nextern _saudio_OSStatus AudioQueueStart(_saudio_AudioQueueRef inAQ, const _saudio_AudioTimeStamp * inStartTime);\nextern _saudio_OSStatus AudioQueueStop(_saudio_AudioQueueRef inAQ, bool inImmediate);\n\n#ifdef __cplusplus\n} // extern \"C\"\n#endif\n\n#endif // SAUDIO_OSX_USE_SYSTEM_HEADERS\n\ntypedef struct {\n    _saudio_AudioQueueRef ca_audio_queue;\n    #if defined(_SAUDIO_IOS)\n    id ca_interruption_handler;\n    #endif\n} _saudio_apple_backend_t;\n\n#elif defined(_SAUDIO_LINUX)\n\ntypedef struct {\n    snd_pcm_t* device;\n    float* buffer;\n    int buffer_byte_size;\n    int buffer_frames;\n    pthread_t thread;\n    bool thread_stop;\n} _saudio_alsa_backend_t;\n\n#elif defined(SAUDIO_ANDROID_SLES)\n\n#define SAUDIO_SLES_NUM_BUFFERS (2)\n\ntypedef struct {\n    pthread_mutex_t mutex;\n    pthread_cond_t cond;\n    int count;\n} _saudio_sles_semaphore_t;\n\ntypedef struct {\n    SLObjectItf engine_obj;\n    SLEngineItf engine;\n    SLObjectItf output_mix_obj;\n    SLVolumeItf output_mix_vol;\n    SLDataLocator_OutputMix out_locator;\n    SLDataSink dst_data_sink;\n    SLObjectItf player_obj;\n    SLPlayItf player;\n    SLVolumeItf player_vol;\n    SLAndroidSimpleBufferQueueItf player_buffer_queue;\n\n    int16_t* output_buffers[SAUDIO_SLES_NUM_BUFFERS];\n    float* src_buffer;\n    int active_buffer;\n    _saudio_sles_semaphore_t buffer_sem;\n    pthread_t thread;\n    volatile int thread_stop;\n    SLDataLocator_AndroidSimpleBufferQueue in_locator;\n} _saudio_sles_backend_t;\n\n#elif defined(SAUDIO_ANDROID_AAUDIO)\n\ntypedef struct {\n    AAudioStreamBuilder* builder;\n    AAudioStream* stream;\n    pthread_t thread;\n    pthread_mutex_t mutex;\n} _saudio_aaudio_backend_t;\n\n#elif defined(_SAUDIO_WINDOWS)\n\ntypedef struct {\n    HANDLE thread_handle;\n    HANDLE buffer_end_event;\n    bool stop;\n    UINT32 dst_buffer_frames;\n    int src_buffer_frames;\n    int src_buffer_byte_size;\n    int src_buffer_pos;\n    float* src_buffer;\n} _saudio_wasapi_thread_data_t;\n\ntypedef struct {\n    IMMDeviceEnumerator* device_enumerator;\n    IMMDevice* device;\n    IAudioClient* audio_client;\n    IAudioRenderClient* render_client;\n    _saudio_wasapi_thread_data_t thread;\n} _saudio_wasapi_backend_t;\n\n#elif defined(_SAUDIO_EMSCRIPTEN)\n\ntypedef struct {\n    uint8_t* buffer;\n} _saudio_web_backend_t;\n\n#else\n#error \"unknown platform\"\n#endif\n\n#if defined(SOKOL_DUMMY_BACKEND)\ntypedef _saudio_dummy_backend_t _saudio_backend_t;\n#elif defined(_SAUDIO_APPLE)\ntypedef _saudio_apple_backend_t _saudio_backend_t;\n#elif defined(_SAUDIO_EMSCRIPTEN)\ntypedef _saudio_web_backend_t _saudio_backend_t;\n#elif defined(_SAUDIO_WINDOWS)\ntypedef _saudio_wasapi_backend_t _saudio_backend_t;\n#elif defined(SAUDIO_ANDROID_SLES)\ntypedef _saudio_sles_backend_t _saudio_backend_t;\n#elif defined(SAUDIO_ANDROID_AAUDIO)\ntypedef _saudio_aaudio_backend_t _saudio_backend_t;\n#elif defined(_SAUDIO_LINUX)\ntypedef _saudio_alsa_backend_t _saudio_backend_t;\n#endif\n\n/* a ringbuffer structure */\ntypedef struct {\n    int head;  // next slot to write to\n    int tail;  // next slot to read from\n    int num;   // number of slots in queue\n    int queue[SAUDIO_RING_MAX_SLOTS];\n} _saudio_ring_t;\n\n/* a packet FIFO structure */\ntypedef struct {\n    bool valid;\n    int packet_size;            /* size of a single packets in bytes(!) */\n    int num_packets;            /* number of packet in fifo */\n    uint8_t* base_ptr;          /* packet memory chunk base pointer (dynamically allocated) */\n    int cur_packet;             /* current write-packet */\n    int cur_offset;             /* current byte-offset into current write packet */\n    _saudio_mutex_t mutex;      /* mutex for thread-safe access */\n    _saudio_ring_t read_queue;  /* buffers with data, ready to be streamed */\n    _saudio_ring_t write_queue; /* empty buffers, ready to be pushed to */\n} _saudio_fifo_t;\n\n/* sokol-audio state */\ntypedef struct {\n    bool valid;\n    bool setup_called;\n    void (*stream_cb)(float* buffer, int num_frames, int num_channels);\n    void (*stream_userdata_cb)(float* buffer, int num_frames, int num_channels, void* user_data);\n    void* user_data;\n    int sample_rate;            /* sample rate */\n    int buffer_frames;          /* number of frames in streaming buffer */\n    int bytes_per_frame;        /* filled by backend */\n    int packet_frames;          /* number of frames in a packet */\n    int num_packets;            /* number of packets in packet queue */\n    int num_channels;           /* actual number of channels */\n    saudio_desc desc;\n    _saudio_fifo_t fifo;\n    _saudio_backend_t backend;\n} _saudio_state_t;\n\n_SOKOL_PRIVATE _saudio_state_t _saudio;\n\n_SOKOL_PRIVATE bool _saudio_has_callback(void) {\n    return (_saudio.stream_cb || _saudio.stream_userdata_cb);\n}\n\n_SOKOL_PRIVATE void _saudio_stream_callback(float* buffer, int num_frames, int num_channels) {\n    if (_saudio.stream_cb) {\n        _saudio.stream_cb(buffer, num_frames, num_channels);\n    }\n    else if (_saudio.stream_userdata_cb) {\n        _saudio.stream_userdata_cb(buffer, num_frames, num_channels, _saudio.user_data);\n    }\n}\n\n//                       \n//                               \n//                            \n//                               \n//                 \n//\n// >>logging\n#if defined(SOKOL_DEBUG)\n#define _SAUDIO_LOGITEM_XMACRO(item,msg) #item \": \" msg,\nstatic const char* _saudio_log_messages[] = {\n    _SAUDIO_LOG_ITEMS\n};\n#undef _SAUDIO_LOGITEM_XMACRO\n#endif // SOKOL_DEBUG\n\n#define _SAUDIO_PANIC(code) _saudio_log(SAUDIO_LOGITEM_ ##code, 0, __LINE__)\n#define _SAUDIO_ERROR(code) _saudio_log(SAUDIO_LOGITEM_ ##code, 1, __LINE__)\n#define _SAUDIO_WARN(code) _saudio_log(SAUDIO_LOGITEM_ ##code, 2, __LINE__)\n#define _SAUDIO_INFO(code) _saudio_log(SAUDIO_LOGITEM_ ##code, 3, __LINE__)\n\nstatic void _saudio_log(saudio_log_item log_item, uint32_t log_level, uint32_t line_nr) {\n    if (_saudio.desc.logger.func) {\n        #if defined(SOKOL_DEBUG)\n            const char* filename = __FILE__;\n            const char* message = _saudio_log_messages[log_item];\n        #else\n            const char* filename = 0;\n            const char* message = 0;\n        #endif\n        _saudio.desc.logger.func(\"saudio\", log_level, log_item, message, line_nr, filename, _saudio.desc.logger.user_data);\n    }\n    else {\n        // for log level PANIC it would be 'undefined behaviour' to continue\n        if (log_level == 0) {\n            abort();\n        }\n    }\n}\n\n//                     \n//                         \n//                   \n//                             \n//                          \n//\n// >>memory\n_SOKOL_PRIVATE void _saudio_clear(void* ptr, size_t size) {\n    SOKOL_ASSERT(ptr && (size > 0));\n    memset(ptr, 0, size);\n}\n\n_SOKOL_PRIVATE void* _saudio_malloc(size_t size) {\n    SOKOL_ASSERT(size > 0);\n    void* ptr;\n    if (_saudio.desc.allocator.alloc_fn) {\n        ptr = _saudio.desc.allocator.alloc_fn(size, _saudio.desc.allocator.user_data);\n    } else {\n        ptr = malloc(size);\n    }\n    if (0 == ptr) {\n        _SAUDIO_PANIC(MALLOC_FAILED);\n    }\n    return ptr;\n}\n\n_SOKOL_PRIVATE void* _saudio_malloc_clear(size_t size) {\n    void* ptr = _saudio_malloc(size);\n    _saudio_clear(ptr, size);\n    return ptr;\n}\n\n_SOKOL_PRIVATE void _saudio_free(void* ptr) {\n    if (_saudio.desc.allocator.free_fn) {\n        _saudio.desc.allocator.free_fn(ptr, _saudio.desc.allocator.user_data);\n    } else {\n        free(ptr);\n    }\n}\n\n//                \n//                        \n//                     \n//                          \n//                      \n//\n// >>mutex\n#if defined(_SAUDIO_NOTHREADS)\n\n_SOKOL_PRIVATE void _saudio_mutex_init(_saudio_mutex_t* m) { (void)m; }\n_SOKOL_PRIVATE void _saudio_mutex_destroy(_saudio_mutex_t* m) { (void)m; }\n_SOKOL_PRIVATE void _saudio_mutex_lock(_saudio_mutex_t* m) { (void)m; }\n_SOKOL_PRIVATE void _saudio_mutex_unlock(_saudio_mutex_t* m) { (void)m; }\n\n#elif defined(_SAUDIO_PTHREADS)\n\n_SOKOL_PRIVATE void _saudio_mutex_init(_saudio_mutex_t* m) {\n    pthread_mutexattr_t attr;\n    pthread_mutexattr_init(&attr);\n    pthread_mutex_init(&m->mutex, &attr);\n}\n\n_SOKOL_PRIVATE void _saudio_mutex_destroy(_saudio_mutex_t* m) {\n    pthread_mutex_destroy(&m->mutex);\n}\n\n_SOKOL_PRIVATE void _saudio_mutex_lock(_saudio_mutex_t* m) {\n    pthread_mutex_lock(&m->mutex);\n}\n\n_SOKOL_PRIVATE void _saudio_mutex_unlock(_saudio_mutex_t* m) {\n    pthread_mutex_unlock(&m->mutex);\n}\n\n#elif defined(_SAUDIO_WINTHREADS)\n\n_SOKOL_PRIVATE void _saudio_mutex_init(_saudio_mutex_t* m) {\n    InitializeCriticalSection(&m->critsec);\n}\n\n_SOKOL_PRIVATE void _saudio_mutex_destroy(_saudio_mutex_t* m) {\n    DeleteCriticalSection(&m->critsec);\n}\n\n_SOKOL_PRIVATE void _saudio_mutex_lock(_saudio_mutex_t* m) {\n    EnterCriticalSection(&m->critsec);\n}\n\n_SOKOL_PRIVATE void _saudio_mutex_unlock(_saudio_mutex_t* m) {\n    LeaveCriticalSection(&m->critsec);\n}\n#else\n#error \"sokol_audio.h: unknown platform!\"\n#endif\n\n//                      \n//                                               \n//                            \n//                                             \n//                                  \n//\n// >>ringbuffer\n_SOKOL_PRIVATE int _saudio_ring_idx(_saudio_ring_t* ring, int i) {\n    return (i % ring->num);\n}\n\n_SOKOL_PRIVATE void _saudio_ring_init(_saudio_ring_t* ring, int num_slots) {\n    SOKOL_ASSERT((num_slots + 1) <= SAUDIO_RING_MAX_SLOTS);\n    ring->head = 0;\n    ring->tail = 0;\n    /* one slot reserved to detect 'full' vs 'empty' */\n    ring->num = num_slots + 1;\n}\n\n_SOKOL_PRIVATE bool _saudio_ring_full(_saudio_ring_t* ring) {\n    return _saudio_ring_idx(ring, ring->head + 1) == ring->tail;\n}\n\n_SOKOL_PRIVATE bool _saudio_ring_empty(_saudio_ring_t* ring) {\n    return ring->head == ring->tail;\n}\n\n_SOKOL_PRIVATE int _saudio_ring_count(_saudio_ring_t* ring) {\n    int count;\n    if (ring->head >= ring->tail) {\n        count = ring->head - ring->tail;\n    }\n    else {\n        count = (ring->head + ring->num) - ring->tail;\n    }\n    SOKOL_ASSERT(count < ring->num);\n    return count;\n}\n\n_SOKOL_PRIVATE void _saudio_ring_enqueue(_saudio_ring_t* ring, int val) {\n    SOKOL_ASSERT(!_saudio_ring_full(ring));\n    ring->queue[ring->head] = val;\n    ring->head = _saudio_ring_idx(ring, ring->head + 1);\n}\n\n_SOKOL_PRIVATE int _saudio_ring_dequeue(_saudio_ring_t* ring) {\n    SOKOL_ASSERT(!_saudio_ring_empty(ring));\n    int val = ring->queue[ring->tail];\n    ring->tail = _saudio_ring_idx(ring, ring->tail + 1);\n    return val;\n}\n\n//     \n//                  \n//            \n//                  \n//               \n//\n// >>fifo\n_SOKOL_PRIVATE void _saudio_fifo_init_mutex(_saudio_fifo_t* fifo) {\n    /* this must be called before initializing both the backend and the fifo itself! */\n    _saudio_mutex_init(&fifo->mutex);\n}\n\n_SOKOL_PRIVATE void _saudio_fifo_destroy_mutex(_saudio_fifo_t* fifo) {\n    _saudio_mutex_destroy(&fifo->mutex);\n}\n\n_SOKOL_PRIVATE void _saudio_fifo_init(_saudio_fifo_t* fifo, int packet_size, int num_packets) {\n    /* NOTE: there's a chicken-egg situation during the init phase where the\n        streaming thread must be started before the fifo is actually initialized,\n        thus the fifo init must already be protected from access by the fifo_read() func.\n    */\n    _saudio_mutex_lock(&fifo->mutex);\n    SOKOL_ASSERT((packet_size > 0) && (num_packets > 0));\n    fifo->packet_size = packet_size;\n    fifo->num_packets = num_packets;\n    fifo->base_ptr = (uint8_t*) _saudio_malloc((size_t)(packet_size * num_packets));\n    fifo->cur_packet = -1;\n    fifo->cur_offset = 0;\n    _saudio_ring_init(&fifo->read_queue, num_packets);\n    _saudio_ring_init(&fifo->write_queue, num_packets);\n    for (int i = 0; i < num_packets; i++) {\n        _saudio_ring_enqueue(&fifo->write_queue, i);\n    }\n    SOKOL_ASSERT(_saudio_ring_full(&fifo->write_queue));\n    SOKOL_ASSERT(_saudio_ring_count(&fifo->write_queue) == num_packets);\n    SOKOL_ASSERT(_saudio_ring_empty(&fifo->read_queue));\n    SOKOL_ASSERT(_saudio_ring_count(&fifo->read_queue) == 0);\n    fifo->valid = true;\n    _saudio_mutex_unlock(&fifo->mutex);\n}\n\n_SOKOL_PRIVATE void _saudio_fifo_shutdown(_saudio_fifo_t* fifo) {\n    SOKOL_ASSERT(fifo->base_ptr);\n    _saudio_free(fifo->base_ptr);\n    fifo->base_ptr = 0;\n    fifo->valid = false;\n}\n\n_SOKOL_PRIVATE int _saudio_fifo_writable_bytes(_saudio_fifo_t* fifo) {\n    _saudio_mutex_lock(&fifo->mutex);\n    int num_bytes = (_saudio_ring_count(&fifo->write_queue) * fifo->packet_size);\n    if (fifo->cur_packet != -1) {\n        num_bytes += fifo->packet_size - fifo->cur_offset;\n    }\n    _saudio_mutex_unlock(&fifo->mutex);\n    SOKOL_ASSERT((num_bytes >= 0) && (num_bytes <= (fifo->num_packets * fifo->packet_size)));\n    return num_bytes;\n}\n\n/* write new data to the write queue, this is called from main thread */\n_SOKOL_PRIVATE int _saudio_fifo_write(_saudio_fifo_t* fifo, const uint8_t* ptr, int num_bytes) {\n    /* returns the number of bytes written, this will be smaller then requested\n        if the write queue runs full\n    */\n    int all_to_copy = num_bytes;\n    while (all_to_copy > 0) {\n        /* need to grab a new packet? */\n        if (fifo->cur_packet == -1) {\n            _saudio_mutex_lock(&fifo->mutex);\n            if (!_saudio_ring_empty(&fifo->write_queue)) {\n                fifo->cur_packet = _saudio_ring_dequeue(&fifo->write_queue);\n            }\n            _saudio_mutex_unlock(&fifo->mutex);\n            SOKOL_ASSERT(fifo->cur_offset == 0);\n        }\n        /* append data to current write packet */\n        if (fifo->cur_packet != -1) {\n            int to_copy = all_to_copy;\n            const int max_copy = fifo->packet_size - fifo->cur_offset;\n            if (to_copy > max_copy) {\n                to_copy = max_copy;\n            }\n            uint8_t* dst = fifo->base_ptr + fifo->cur_packet * fifo->packet_size + fifo->cur_offset;\n            memcpy(dst, ptr, (size_t)to_copy);\n            ptr += to_copy;\n            fifo->cur_offset += to_copy;\n            all_to_copy -= to_copy;\n            SOKOL_ASSERT(fifo->cur_offset <= fifo->packet_size);\n            SOKOL_ASSERT(all_to_copy >= 0);\n        }\n        else {\n            /* early out if we're starving */\n            int bytes_copied = num_bytes - all_to_copy;\n            SOKOL_ASSERT((bytes_copied >= 0) && (bytes_copied < num_bytes));\n            return bytes_copied;\n        }\n        /* if write packet is full, push to read queue */\n        if (fifo->cur_offset == fifo->packet_size) {\n            _saudio_mutex_lock(&fifo->mutex);\n            _saudio_ring_enqueue(&fifo->read_queue, fifo->cur_packet);\n            _saudio_mutex_unlock(&fifo->mutex);\n            fifo->cur_packet = -1;\n            fifo->cur_offset = 0;\n        }\n    }\n    SOKOL_ASSERT(all_to_copy == 0);\n    return num_bytes;\n}\n\n/* read queued data, this is called form the stream callback (maybe separate thread) */\n_SOKOL_PRIVATE int _saudio_fifo_read(_saudio_fifo_t* fifo, uint8_t* ptr, int num_bytes) {\n    /* NOTE: fifo_read might be called before the fifo is properly initialized */\n    _saudio_mutex_lock(&fifo->mutex);\n    int num_bytes_copied = 0;\n    if (fifo->valid) {\n        SOKOL_ASSERT(0 == (num_bytes % fifo->packet_size));\n        SOKOL_ASSERT(num_bytes <= (fifo->packet_size * fifo->num_packets));\n        const int num_packets_needed = num_bytes / fifo->packet_size;\n        uint8_t* dst = ptr;\n        /* either pull a full buffer worth of data, or nothing */\n        if (_saudio_ring_count(&fifo->read_queue) >= num_packets_needed) {\n            for (int i = 0; i < num_packets_needed; i++) {\n                int packet_index = _saudio_ring_dequeue(&fifo->read_queue);\n                _saudio_ring_enqueue(&fifo->write_queue, packet_index);\n                const uint8_t* src = fifo->base_ptr + packet_index * fifo->packet_size;\n                memcpy(dst, src, (size_t)fifo->packet_size);\n                dst += fifo->packet_size;\n                num_bytes_copied += fifo->packet_size;\n            }\n            SOKOL_ASSERT(num_bytes == num_bytes_copied);\n        }\n    }\n    _saudio_mutex_unlock(&fifo->mutex);\n    return num_bytes_copied;\n}\n\n//                      \n//                   \n//                  \n//                       \n//                       \n//\n// >>dummy\n#if defined(SOKOL_DUMMY_BACKEND)\n_SOKOL_PRIVATE bool _saudio_dummy_backend_init(void) {\n    _saudio.bytes_per_frame = _saudio.num_channels * (int)sizeof(float);\n    return true;\n};\n_SOKOL_PRIVATE void _saudio_dummy_backend_shutdown(void) { };\n\n//            \n//                    \n//         \n//                    \n//          \n//\n// >>alsa\n#elif defined(_SAUDIO_LINUX)\n\n/* the streaming callback runs in a separate thread */\n_SOKOL_PRIVATE void* _saudio_alsa_cb(void* param) {\n    _SOKOL_UNUSED(param);\n    while (!_saudio.backend.thread_stop) {\n        /* snd_pcm_writei() will be blocking until it needs data */\n        int write_res = snd_pcm_writei(_saudio.backend.device, _saudio.backend.buffer, (snd_pcm_uframes_t)_saudio.backend.buffer_frames);\n        if (write_res < 0) {\n            /* underrun occurred */\n            snd_pcm_prepare(_saudio.backend.device);\n        }\n        else {\n            /* fill the streaming buffer with new data */\n            if (_saudio_has_callback()) {\n                _saudio_stream_callback(_saudio.backend.buffer, _saudio.backend.buffer_frames, _saudio.num_channels);\n            }\n            else {\n                if (0 == _saudio_fifo_read(&_saudio.fifo, (uint8_t*)_saudio.backend.buffer, _saudio.backend.buffer_byte_size)) {\n                    /* not enough read data available, fill the entire buffer with silence */\n                    _saudio_clear(_saudio.backend.buffer, (size_t)_saudio.backend.buffer_byte_size);\n                }\n            }\n        }\n    }\n    return 0;\n}\n\n_SOKOL_PRIVATE bool _saudio_alsa_backend_init(void) {\n    int dir; uint32_t rate;\n    int rc = snd_pcm_open(&_saudio.backend.device, \"default\", SND_PCM_STREAM_PLAYBACK, 0);\n    if (rc < 0) {\n        _SAUDIO_ERROR(ALSA_SND_PCM_OPEN_FAILED);\n        return false;\n    }\n\n    /* configuration works by restricting the 'configuration space' step\n       by step, we require all parameters except the sample rate to\n       match perfectly\n    */\n    snd_pcm_hw_params_t* params = 0;\n    snd_pcm_hw_params_alloca(&params);\n    snd_pcm_hw_params_any(_saudio.backend.device, params);\n    snd_pcm_hw_params_set_access(_saudio.backend.device, params, SND_PCM_ACCESS_RW_INTERLEAVED);\n    if (0 > snd_pcm_hw_params_set_format(_saudio.backend.device, params, SND_PCM_FORMAT_FLOAT_LE)) {\n        _SAUDIO_ERROR(ALSA_FLOAT_SAMPLES_NOT_SUPPORTED);\n        goto error;\n    }\n    if (0 > snd_pcm_hw_params_set_buffer_size(_saudio.backend.device, params, (snd_pcm_uframes_t)_saudio.buffer_frames)) {\n        _SAUDIO_ERROR(ALSA_REQUESTED_BUFFER_SIZE_NOT_SUPPORTED);\n        goto error;\n    }\n    if (0 > snd_pcm_hw_params_set_channels(_saudio.backend.device, params, (uint32_t)_saudio.num_channels)) {\n        _SAUDIO_ERROR(ALSA_REQUESTED_CHANNEL_COUNT_NOT_SUPPORTED);\n        goto error;\n    }\n    /* let ALSA pick a nearby sampling rate */\n    rate = (uint32_t) _saudio.sample_rate;\n    dir = 0;\n    if (0 > snd_pcm_hw_params_set_rate_near(_saudio.backend.device, params, &rate, &dir)) {\n        _SAUDIO_ERROR(ALSA_SND_PCM_HW_PARAMS_SET_RATE_NEAR_FAILED);\n        goto error;\n    }\n    if (0 > snd_pcm_hw_params(_saudio.backend.device, params)) {\n        _SAUDIO_ERROR(ALSA_SND_PCM_HW_PARAMS_FAILED);\n        goto error;\n    }\n\n    /* read back actual sample rate and channels */\n    _saudio.sample_rate = (int)rate;\n    _saudio.bytes_per_frame = _saudio.num_channels * (int)sizeof(float);\n\n    /* allocate the streaming buffer */\n    _saudio.backend.buffer_byte_size = _saudio.buffer_frames * _saudio.bytes_per_frame;\n    _saudio.backend.buffer_frames = _saudio.buffer_frames;\n    _saudio.backend.buffer = (float*) _saudio_malloc_clear((size_t)_saudio.backend.buffer_byte_size);\n\n    /* create the buffer-streaming start thread */\n    if (0 != pthread_create(&_saudio.backend.thread, 0, _saudio_alsa_cb, 0)) {\n        _SAUDIO_ERROR(ALSA_PTHREAD_CREATE_FAILED);\n        goto error;\n    }\n\n    return true;\nerror:\n    if (_saudio.backend.device) {\n        snd_pcm_close(_saudio.backend.device);\n        _saudio.backend.device = 0;\n    }\n    return false;\n};\n\n_SOKOL_PRIVATE void _saudio_alsa_backend_shutdown(void) {\n    SOKOL_ASSERT(_saudio.backend.device);\n    _saudio.backend.thread_stop = true;\n    pthread_join(_saudio.backend.thread, 0);\n    snd_pcm_drain(_saudio.backend.device);\n    snd_pcm_close(_saudio.backend.device);\n    _saudio_free(_saudio.backend.buffer);\n};\n\n//                \n//                         \n//           \n//                        \n//                    \n//\n// >>wasapi\n#elif defined(_SAUDIO_WINDOWS)\n\n/* fill intermediate buffer with new data and reset buffer_pos */\n_SOKOL_PRIVATE void _saudio_wasapi_fill_buffer(void) {\n    if (_saudio_has_callback()) {\n        _saudio_stream_callback(_saudio.backend.thread.src_buffer, _saudio.backend.thread.src_buffer_frames, _saudio.num_channels);\n    }\n    else {\n        if (0 == _saudio_fifo_read(&_saudio.fifo, (uint8_t*)_saudio.backend.thread.src_buffer, _saudio.backend.thread.src_buffer_byte_size)) {\n            /* not enough read data available, fill the entire buffer with silence */\n            _saudio_clear(_saudio.backend.thread.src_buffer, (size_t)_saudio.backend.thread.src_buffer_byte_size);\n        }\n    }\n}\n\n_SOKOL_PRIVATE int _saudio_wasapi_min(int a, int b) {\n    return (a < b) ? a : b;\n}\n\n_SOKOL_PRIVATE void _saudio_wasapi_submit_buffer(int num_frames) {\n    BYTE* wasapi_buffer = 0;\n    if (FAILED(IAudioRenderClient_GetBuffer(_saudio.backend.render_client, num_frames, &wasapi_buffer))) {\n        return;\n    }\n    SOKOL_ASSERT(wasapi_buffer);\n\n    /* copy samples to WASAPI buffer, refill source buffer if needed */\n    int num_remaining_samples = num_frames * _saudio.num_channels;\n    int buffer_pos = _saudio.backend.thread.src_buffer_pos;\n    const int buffer_size_in_samples = _saudio.backend.thread.src_buffer_byte_size / (int)sizeof(float);\n    float* dst = (float*)wasapi_buffer;\n    const float* dst_end = dst + num_remaining_samples;\n    _SOKOL_UNUSED(dst_end); // suppress unused warning in release mode\n    const float* src = _saudio.backend.thread.src_buffer;\n\n    while (num_remaining_samples > 0) {\n        if (0 == buffer_pos) {\n            _saudio_wasapi_fill_buffer();\n        }\n        const int samples_to_copy = _saudio_wasapi_min(num_remaining_samples, buffer_size_in_samples - buffer_pos);\n        SOKOL_ASSERT((buffer_pos + samples_to_copy) <= buffer_size_in_samples);\n        SOKOL_ASSERT((dst + samples_to_copy) <= dst_end);\n        memcpy(dst, &src[buffer_pos], (size_t)samples_to_copy * sizeof(float));\n        num_remaining_samples -= samples_to_copy;\n        SOKOL_ASSERT(num_remaining_samples >= 0);\n        buffer_pos += samples_to_copy;\n        dst += samples_to_copy;\n\n        SOKOL_ASSERT(buffer_pos <= buffer_size_in_samples);\n        if (buffer_pos == buffer_size_in_samples) {\n            buffer_pos = 0;\n        }\n    }\n    _saudio.backend.thread.src_buffer_pos = buffer_pos;\n    IAudioRenderClient_ReleaseBuffer(_saudio.backend.render_client, num_frames, 0);\n}\n\n_SOKOL_PRIVATE DWORD WINAPI _saudio_wasapi_thread_fn(LPVOID param) {\n    (void)param;\n    _saudio_wasapi_submit_buffer(_saudio.backend.thread.src_buffer_frames);\n    IAudioClient_Start(_saudio.backend.audio_client);\n    while (!_saudio.backend.thread.stop) {\n        WaitForSingleObject(_saudio.backend.thread.buffer_end_event, INFINITE);\n        UINT32 padding = 0;\n        if (FAILED(IAudioClient_GetCurrentPadding(_saudio.backend.audio_client, &padding))) {\n            continue;\n        }\n        SOKOL_ASSERT(_saudio.backend.thread.dst_buffer_frames >= padding);\n        int num_frames = (int)_saudio.backend.thread.dst_buffer_frames - (int)padding;\n        if (num_frames > 0) {\n            _saudio_wasapi_submit_buffer(num_frames);\n        }\n    }\n    return 0;\n}\n\n_SOKOL_PRIVATE void _saudio_wasapi_release(void) {\n    if (_saudio.backend.thread.src_buffer) {\n        _saudio_free(_saudio.backend.thread.src_buffer);\n        _saudio.backend.thread.src_buffer = 0;\n    }\n    if (_saudio.backend.render_client) {\n        IAudioRenderClient_Release(_saudio.backend.render_client);\n        _saudio.backend.render_client = 0;\n    }\n    if (_saudio.backend.audio_client) {\n        IAudioClient_Release(_saudio.backend.audio_client);\n        _saudio.backend.audio_client = 0;\n    }\n    if (_saudio.backend.device) {\n        IMMDevice_Release(_saudio.backend.device);\n        _saudio.backend.device = 0;\n    }\n    if (_saudio.backend.device_enumerator) {\n        IMMDeviceEnumerator_Release(_saudio.backend.device_enumerator);\n        _saudio.backend.device_enumerator = 0;\n    }\n    if (0 != _saudio.backend.thread.buffer_end_event) {\n        CloseHandle(_saudio.backend.thread.buffer_end_event);\n        _saudio.backend.thread.buffer_end_event = 0;\n    }\n}\n\n_SOKOL_PRIVATE bool _saudio_wasapi_backend_init(void) {\n    REFERENCE_TIME dur;\n    /* CoInitializeEx could have been called elsewhere already, in which\n        case the function returns with S_FALSE (thus it does not make much\n        sense to check the result)\n    */\n    HRESULT hr = CoInitializeEx(0, COINIT_MULTITHREADED);\n    _SOKOL_UNUSED(hr);\n    _saudio.backend.thread.buffer_end_event = CreateEvent(0, FALSE, FALSE, 0);\n    if (0 == _saudio.backend.thread.buffer_end_event) {\n        _SAUDIO_ERROR(WASAPI_CREATE_EVENT_FAILED);\n        goto error;\n    }\n    if (FAILED(CoCreateInstance(_SOKOL_AUDIO_WIN32COM_ID(_saudio_CLSID_IMMDeviceEnumerator),\n        0, CLSCTX_ALL,\n        _SOKOL_AUDIO_WIN32COM_ID(_saudio_IID_IMMDeviceEnumerator),\n        (void**)&_saudio.backend.device_enumerator)))\n    {\n        _SAUDIO_ERROR(WASAPI_CREATE_DEVICE_ENUMERATOR_FAILED);\n        goto error;\n    }\n    if (FAILED(IMMDeviceEnumerator_GetDefaultAudioEndpoint(_saudio.backend.device_enumerator,\n        eRender, eConsole,\n        &_saudio.backend.device)))\n    {\n        _SAUDIO_ERROR(WASAPI_GET_DEFAULT_AUDIO_ENDPOINT_FAILED);\n        goto error;\n    }\n    if (FAILED(IMMDevice_Activate(_saudio.backend.device,\n        _SOKOL_AUDIO_WIN32COM_ID(_saudio_IID_IAudioClient),\n        CLSCTX_ALL, 0,\n        (void**)&_saudio.backend.audio_client)))\n    {\n        _SAUDIO_ERROR(WASAPI_DEVICE_ACTIVATE_FAILED);\n        goto error;\n    }\n\n    WAVEFORMATEXTENSIBLE fmtex;\n    _saudio_clear(&fmtex, sizeof(fmtex));\n    fmtex.Format.nChannels = (WORD)_saudio.num_channels;\n    fmtex.Format.nSamplesPerSec = (DWORD)_saudio.sample_rate;\n    fmtex.Format.wFormatTag = WAVE_FORMAT_EXTENSIBLE;\n    fmtex.Format.wBitsPerSample = 32;\n    fmtex.Format.nBlockAlign = (fmtex.Format.nChannels * fmtex.Format.wBitsPerSample) / 8;\n    fmtex.Format.nAvgBytesPerSec = fmtex.Format.nSamplesPerSec * fmtex.Format.nBlockAlign;\n    fmtex.Format.cbSize = 22;   /* WORD + DWORD + GUID */\n    fmtex.Samples.wValidBitsPerSample = 32;\n    if (_saudio.num_channels == 1) {\n        fmtex.dwChannelMask = SPEAKER_FRONT_CENTER;\n    }\n    else {\n        fmtex.dwChannelMask = SPEAKER_FRONT_LEFT|SPEAKER_FRONT_RIGHT;\n    }\n    fmtex.SubFormat = _saudio_KSDATAFORMAT_SUBTYPE_IEEE_FLOAT;\n    dur = (REFERENCE_TIME)\n        (((double)_saudio.buffer_frames) / (((double)_saudio.sample_rate) * (1.0/10000000.0)));\n    if (FAILED(IAudioClient_Initialize(_saudio.backend.audio_client,\n        AUDCLNT_SHAREMODE_SHARED,\n        AUDCLNT_STREAMFLAGS_EVENTCALLBACK|AUDCLNT_STREAMFLAGS_AUTOCONVERTPCM|AUDCLNT_STREAMFLAGS_SRC_DEFAULT_QUALITY,\n        dur, 0, (WAVEFORMATEX*)&fmtex, 0)))\n    {\n        _SAUDIO_ERROR(WASAPI_AUDIO_CLIENT_INITIALIZE_FAILED);\n        goto error;\n    }\n    if (FAILED(IAudioClient_GetBufferSize(_saudio.backend.audio_client, &_saudio.backend.thread.dst_buffer_frames))) {\n        _SAUDIO_ERROR(WASAPI_AUDIO_CLIENT_GET_BUFFER_SIZE_FAILED);\n        goto error;\n    }\n    if (FAILED(IAudioClient_GetService(_saudio.backend.audio_client,\n        _SOKOL_AUDIO_WIN32COM_ID(_saudio_IID_IAudioRenderClient),\n        (void**)&_saudio.backend.render_client)))\n    {\n        _SAUDIO_ERROR(WASAPI_AUDIO_CLIENT_GET_SERVICE_FAILED);\n        goto error;\n    }\n    if (FAILED(IAudioClient_SetEventHandle(_saudio.backend.audio_client, _saudio.backend.thread.buffer_end_event))) {\n        _SAUDIO_ERROR(WASAPI_AUDIO_CLIENT_SET_EVENT_HANDLE_FAILED);\n        goto error;\n    }\n    _saudio.bytes_per_frame = _saudio.num_channels * (int)sizeof(float);\n    _saudio.backend.thread.src_buffer_frames = _saudio.buffer_frames;\n    _saudio.backend.thread.src_buffer_byte_size = _saudio.backend.thread.src_buffer_frames * _saudio.bytes_per_frame;\n\n    /* allocate an intermediate buffer for sample format conversion */\n    _saudio.backend.thread.src_buffer = (float*) _saudio_malloc((size_t)_saudio.backend.thread.src_buffer_byte_size);\n\n    /* create streaming thread */\n    _saudio.backend.thread.thread_handle = CreateThread(NULL, 0, _saudio_wasapi_thread_fn, 0, 0, 0);\n    if (0 == _saudio.backend.thread.thread_handle) {\n        _SAUDIO_ERROR(WASAPI_CREATE_THREAD_FAILED);\n        goto error;\n    }\n    return true;\nerror:\n    _saudio_wasapi_release();\n    return false;\n}\n\n_SOKOL_PRIVATE void _saudio_wasapi_backend_shutdown(void) {\n    if (_saudio.backend.thread.thread_handle) {\n        _saudio.backend.thread.stop = true;\n        SetEvent(_saudio.backend.thread.buffer_end_event);\n        WaitForSingleObject(_saudio.backend.thread.thread_handle, INFINITE);\n        CloseHandle(_saudio.backend.thread.thread_handle);\n        _saudio.backend.thread.thread_handle = 0;\n    }\n    if (_saudio.backend.audio_client) {\n        IAudioClient_Stop(_saudio.backend.audio_client);\n    }\n    _saudio_wasapi_release();\n    CoUninitialize();\n}\n\n//                      \n//                                   \n//                          \n//                                \n//                   \n//\n// >>webaudio\n#elif defined(_SAUDIO_EMSCRIPTEN)\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nEMSCRIPTEN_KEEPALIVE int _saudio_emsc_pull(int num_frames) {\n    SOKOL_ASSERT(_saudio.backend.buffer);\n    if (num_frames == _saudio.buffer_frames) {\n        if (_saudio_has_callback()) {\n            _saudio_stream_callback((float*)_saudio.backend.buffer, num_frames, _saudio.num_channels);\n        }\n        else {\n            const int num_bytes = num_frames * _saudio.bytes_per_frame;\n            if (0 == _saudio_fifo_read(&_saudio.fifo, _saudio.backend.buffer, num_bytes)) {\n                /* not enough read data available, fill the entire buffer with silence */\n                _saudio_clear(_saudio.backend.buffer, (size_t)num_bytes);\n            }\n        }\n        int res = (int) _saudio.backend.buffer;\n        return res;\n    }\n    else {\n        return 0;\n    }\n}\n\n#ifdef __cplusplus\n} /* extern \"C\" */\n#endif\n\n/* setup the WebAudio context and attach a ScriptProcessorNode */\nEM_JS(int, saudio_js_init, (int sample_rate, int num_channels, int buffer_size), {\n    Module._saudio_context = null;\n    Module._saudio_node = null;\n    if (typeof AudioContext !== 'undefined') {\n        Module._saudio_context = new AudioContext({\n            sampleRate: sample_rate,\n            latencyHint: 'interactive',\n        });\n    }\n    else {\n        Module._saudio_context = null;\n        console.log('sokol_audio.h: no WebAudio support');\n    }\n    if (Module._saudio_context) {\n        console.log('sokol_audio.h: sample rate ', Module._saudio_context.sampleRate);\n        Module._saudio_node = Module._saudio_context.createScriptProcessor(buffer_size, 0, num_channels);\n        Module._saudio_node.onaudioprocess = (event) => {\n            const num_frames = event.outputBuffer.length;\n            const ptr = __saudio_emsc_pull(num_frames);\n            if (ptr) {\n                const num_channels = event.outputBuffer.numberOfChannels;\n                for (let chn = 0; chn < num_channels; chn++) {\n                    const chan = event.outputBuffer.getChannelData(chn);\n                    for (let i = 0; i < num_frames; i++) {\n                        chan[i] = HEAPF32[(ptr>>2) + ((num_channels*i)+chn)]\n                    }\n                }\n            }\n        };\n        Module._saudio_node.connect(Module._saudio_context.destination);\n\n        // in some browsers, WebAudio needs to be activated on a user action\n        const resume_webaudio = () => {\n            if (Module._saudio_context) {\n                if (Module._saudio_context.state === 'suspended') {\n                    Module._saudio_context.resume();\n                }\n            }\n        };\n        document.addEventListener('click', resume_webaudio, {once:true});\n        document.addEventListener('touchend', resume_webaudio, {once:true});\n        document.addEventListener('keydown', resume_webaudio, {once:true});\n        return 1;\n    }\n    else {\n        return 0;\n    }\n});\n\n/* shutdown the WebAudioContext and ScriptProcessorNode */\nEM_JS(void, saudio_js_shutdown, (void), {\n    \\x2F\\x2A\\x2A @suppress {missingProperties} \\x2A\\x2F\n    const ctx = Module._saudio_context;\n    if (ctx !== null) {\n        if (Module._saudio_node) {\n            Module._saudio_node.disconnect();\n        }\n        ctx.close();\n        Module._saudio_context = null;\n        Module._saudio_node = null;\n    }\n});\n\n/* get the actual sample rate back from the WebAudio context */\nEM_JS(int, saudio_js_sample_rate, (void), {\n    if (Module._saudio_context) {\n        return Module._saudio_context.sampleRate;\n    }\n    else {\n        return 0;\n    }\n});\n\n/* get the actual buffer size in number of frames */\nEM_JS(int, saudio_js_buffer_frames, (void), {\n    if (Module._saudio_node) {\n        return Module._saudio_node.bufferSize;\n    }\n    else {\n        return 0;\n    }\n});\n\n/* return 1 if the WebAudio context is currently suspended, else 0 */\nEM_JS(int, saudio_js_suspended, (void), {\n    if (Module._saudio_context) {\n        if (Module._saudio_context.state === 'suspended') {\n            return 1;\n        }\n        else {\n            return 0;\n        }\n    }\n});\n\n_SOKOL_PRIVATE bool _saudio_webaudio_backend_init(void) {\n    if (saudio_js_init(_saudio.sample_rate, _saudio.num_channels, _saudio.buffer_frames)) {\n        _saudio.bytes_per_frame = (int)sizeof(float) * _saudio.num_channels;\n        _saudio.sample_rate = saudio_js_sample_rate();\n        _saudio.buffer_frames = saudio_js_buffer_frames();\n        const size_t buf_size = (size_t) (_saudio.buffer_frames * _saudio.bytes_per_frame);\n        _saudio.backend.buffer = (uint8_t*) _saudio_malloc(buf_size);\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\n_SOKOL_PRIVATE void _saudio_webaudio_backend_shutdown(void) {\n    saudio_js_shutdown();\n    if (_saudio.backend.buffer) {\n        _saudio_free(_saudio.backend.buffer);\n        _saudio.backend.buffer = 0;\n    }\n}\n\n//                \n//                       \n//                 \n//                       \n//                \n//\n// >>aaudio\n#elif defined(SAUDIO_ANDROID_AAUDIO)\n\n_SOKOL_PRIVATE aaudio_data_callback_result_t _saudio_aaudio_data_callback(AAudioStream* stream, void* user_data, void* audio_data, int32_t num_frames) {\n    _SOKOL_UNUSED(user_data);\n    _SOKOL_UNUSED(stream);\n    if (_saudio_has_callback()) {\n        _saudio_stream_callback((float*)audio_data, (int)num_frames, _saudio.num_channels);\n    }\n    else {\n        uint8_t* ptr = (uint8_t*)audio_data;\n        int num_bytes = _saudio.bytes_per_frame * num_frames;\n        if (0 == _saudio_fifo_read(&_saudio.fifo, ptr, num_bytes)) {\n            // not enough read data available, fill the entire buffer with silence\n            memset(ptr, 0, (size_t)num_bytes);\n        }\n    }\n    return AAUDIO_CALLBACK_RESULT_CONTINUE;\n}\n\n_SOKOL_PRIVATE bool _saudio_aaudio_start_stream(void) {\n    if (AAudioStreamBuilder_openStream(_saudio.backend.builder, &_saudio.backend.stream) != AAUDIO_OK) {\n        _SAUDIO_ERROR(AAUDIO_STREAMBUILDER_OPEN_STREAM_FAILED);\n        return false;\n    }\n    AAudioStream_requestStart(_saudio.backend.stream);\n    return true;\n}\n\n_SOKOL_PRIVATE void _saudio_aaudio_stop_stream(void) {\n    if (_saudio.backend.stream) {\n        AAudioStream_requestStop(_saudio.backend.stream);\n        AAudioStream_close(_saudio.backend.stream);\n        _saudio.backend.stream = 0;\n    }\n}\n\n_SOKOL_PRIVATE void* _saudio_aaudio_restart_stream_thread_fn(void* param) {\n    _SOKOL_UNUSED(param);\n    _SAUDIO_WARN(AAUDIO_RESTARTING_STREAM_AFTER_ERROR);\n    pthread_mutex_lock(&_saudio.backend.mutex);\n    _saudio_aaudio_stop_stream();\n    _saudio_aaudio_start_stream();\n    pthread_mutex_unlock(&_saudio.backend.mutex);\n    return 0;\n}\n\n_SOKOL_PRIVATE void _saudio_aaudio_error_callback(AAudioStream* stream, void* user_data, aaudio_result_t error) {\n    _SOKOL_UNUSED(stream);\n    _SOKOL_UNUSED(user_data);\n    if (error == AAUDIO_ERROR_DISCONNECTED) {\n        if (0 != pthread_create(&_saudio.backend.thread, 0, _saudio_aaudio_restart_stream_thread_fn, 0)) {\n            _SAUDIO_ERROR(AAUDIO_PTHREAD_CREATE_FAILED);\n        }\n    }\n}\n\n_SOKOL_PRIVATE void _saudio_aaudio_backend_shutdown(void) {\n    pthread_mutex_lock(&_saudio.backend.mutex);\n    _saudio_aaudio_stop_stream();\n    pthread_mutex_unlock(&_saudio.backend.mutex);\n    if (_saudio.backend.builder) {\n        AAudioStreamBuilder_delete(_saudio.backend.builder);\n        _saudio.backend.builder = 0;\n    }\n    pthread_mutex_destroy(&_saudio.backend.mutex);\n}\n\n_SOKOL_PRIVATE bool _saudio_aaudio_backend_init(void) {\n    _SAUDIO_INFO(USING_AAUDIO_BACKEND);\n\n    _saudio.bytes_per_frame = _saudio.num_channels * (int)sizeof(float);\n\n    pthread_mutexattr_t attr;\n    pthread_mutexattr_init(&attr);\n    pthread_mutex_init(&_saudio.backend.mutex, &attr);\n\n    if (AAudio_createStreamBuilder(&_saudio.backend.builder) != AAUDIO_OK) {\n        _SAUDIO_ERROR(AAUDIO_CREATE_STREAMBUILDER_FAILED);\n        _saudio_aaudio_backend_shutdown();\n        return false;\n    }\n\n    AAudioStreamBuilder_setFormat(_saudio.backend.builder, AAUDIO_FORMAT_PCM_FLOAT);\n    AAudioStreamBuilder_setSampleRate(_saudio.backend.builder, _saudio.sample_rate);\n    AAudioStreamBuilder_setChannelCount(_saudio.backend.builder, _saudio.num_channels);\n    AAudioStreamBuilder_setBufferCapacityInFrames(_saudio.backend.builder, _saudio.buffer_frames * 2);\n    AAudioStreamBuilder_setFramesPerDataCallback(_saudio.backend.builder, _saudio.buffer_frames);\n    AAudioStreamBuilder_setDataCallback(_saudio.backend.builder, _saudio_aaudio_data_callback, 0);\n    AAudioStreamBuilder_setErrorCallback(_saudio.backend.builder, _saudio_aaudio_error_callback, 0);\n\n    if (!_saudio_aaudio_start_stream()) {\n        _saudio_aaudio_backend_shutdown();\n        return false;\n    }\n\n    return true;\n}\n\n//                    \n//                                      \n//                         \n//                                             \n//                  \n//\n//  >>opensles\n//  >>sles\n#elif defined(SAUDIO_ANDROID_SLES)\n\n_SOKOL_PRIVATE void _saudio_sles_semaphore_init(_saudio_sles_semaphore_t* sem) {\n    sem->count = 0;\n    int r = pthread_mutex_init(&sem->mutex, NULL);\n    SOKOL_ASSERT(r == 0);\n    r = pthread_cond_init(&sem->cond, NULL);\n    SOKOL_ASSERT(r == 0);\n    (void)(r);\n}\n\n_SOKOL_PRIVATE void _saudio_sles_semaphore_destroy(_saudio_sles_semaphore_t* sem) {\n    pthread_cond_destroy(&sem->cond);\n    pthread_mutex_destroy(&sem->mutex);\n}\n\n_SOKOL_PRIVATE void _saudio_sles_semaphore_post(_saudio_sles_semaphore_t* sem, int count) {\n    int r = pthread_mutex_lock(&sem->mutex);\n    SOKOL_ASSERT(r == 0);\n    for (int ii = 0; ii < count; ii++) {\n        r = pthread_cond_signal(&sem->cond);\n        SOKOL_ASSERT(r == 0);\n    }\n    sem->count += count;\n    r = pthread_mutex_unlock(&sem->mutex);\n    SOKOL_ASSERT(r == 0);\n    (void)(r);\n}\n\n_SOKOL_PRIVATE bool _saudio_sles_semaphore_wait(_saudio_sles_semaphore_t* sem) {\n    int r = pthread_mutex_lock(&sem->mutex);\n    SOKOL_ASSERT(r == 0);\n    while (r == 0 && sem->count <= 0) {\n        r = pthread_cond_wait(&sem->cond, &sem->mutex);\n    }\n    bool ok = (r == 0);\n    if (ok) {\n        --sem->count;\n    }\n    r = pthread_mutex_unlock(&sem->mutex);\n    (void)(r);\n    return ok;\n}\n\n/* fill intermediate buffer with new data and reset buffer_pos */\n_SOKOL_PRIVATE void _saudio_sles_fill_buffer(void) {\n    int src_buffer_frames = _saudio.buffer_frames;\n    if (_saudio_has_callback()) {\n        _saudio_stream_callback(_saudio.backend.src_buffer, src_buffer_frames, _saudio.num_channels);\n    }\n    else {\n        const int src_buffer_byte_size = src_buffer_frames * _saudio.num_channels * (int)sizeof(float);\n        if (0 == _saudio_fifo_read(&_saudio.fifo, (uint8_t*)_saudio.backend.src_buffer, src_buffer_byte_size)) {\n            /* not enough read data available, fill the entire buffer with silence */\n            _saudio_clear(_saudio.backend.src_buffer, (size_t)src_buffer_byte_size);\n        }\n    }\n}\n\n_SOKOL_PRIVATE void SLAPIENTRY _saudio_sles_play_cb(SLPlayItf player, void *context, SLuint32 event) {\n    _SOKOL_UNUSED(context);\n    _SOKOL_UNUSED(player);\n    if (event & SL_PLAYEVENT_HEADATEND) {\n        _saudio_sles_semaphore_post(&_saudio.backend.buffer_sem, 1);\n    }\n}\n\n_SOKOL_PRIVATE void* _saudio_sles_thread_fn(void* param) {\n    _SOKOL_UNUSED(param);\n    while (!_saudio.backend.thread_stop)  {\n        /* get next output buffer, advance, next buffer. */\n        int16_t* out_buffer = _saudio.backend.output_buffers[_saudio.backend.active_buffer];\n        _saudio.backend.active_buffer = (_saudio.backend.active_buffer + 1) % SAUDIO_SLES_NUM_BUFFERS;\n        int16_t* next_buffer = _saudio.backend.output_buffers[_saudio.backend.active_buffer];\n\n        /* queue this buffer */\n        const int buffer_size_bytes = _saudio.buffer_frames * _saudio.num_channels * (int)sizeof(short);\n        (*_saudio.backend.player_buffer_queue)->Enqueue(_saudio.backend.player_buffer_queue, out_buffer, (SLuint32)buffer_size_bytes);\n\n        /* fill the next buffer */\n        _saudio_sles_fill_buffer();\n        const int num_samples = _saudio.num_channels * _saudio.buffer_frames;\n        for (int i = 0; i < num_samples; ++i) {\n            next_buffer[i] = (int16_t) (_saudio.backend.src_buffer[i] * 0x7FFF);\n        }\n\n        _saudio_sles_semaphore_wait(&_saudio.backend.buffer_sem);\n    }\n\n    return 0;\n}\n\n_SOKOL_PRIVATE void _saudio_sles_backend_shutdown(void) {\n    _saudio.backend.thread_stop = 1;\n    pthread_join(_saudio.backend.thread, 0);\n\n    if (_saudio.backend.player_obj) {\n        (*_saudio.backend.player_obj)->Destroy(_saudio.backend.player_obj);\n    }\n\n    if (_saudio.backend.output_mix_obj) {\n        (*_saudio.backend.output_mix_obj)->Destroy(_saudio.backend.output_mix_obj);\n    }\n\n    if (_saudio.backend.engine_obj) {\n        (*_saudio.backend.engine_obj)->Destroy(_saudio.backend.engine_obj);\n    }\n\n    for (int i = 0; i < SAUDIO_SLES_NUM_BUFFERS; i++) {\n        _saudio_free(_saudio.backend.output_buffers[i]);\n    }\n    _saudio_free(_saudio.backend.src_buffer);\n}\n\n_SOKOL_PRIVATE bool _saudio_sles_backend_init(void) {\n    _SAUDIO_INFO(USING_SLES_BACKEND);\n\n    _saudio.bytes_per_frame = (int)sizeof(float) * _saudio.num_channels;\n\n    for (int i = 0; i < SAUDIO_SLES_NUM_BUFFERS; ++i) {\n        const int buffer_size_bytes = (int)sizeof(int16_t) * _saudio.num_channels * _saudio.buffer_frames;\n        _saudio.backend.output_buffers[i] = (int16_t*) _saudio_malloc_clear((size_t)buffer_size_bytes);\n    }\n\n    {\n        const int buffer_size_bytes = _saudio.bytes_per_frame * _saudio.buffer_frames;\n        _saudio.backend.src_buffer = (float*) _saudio_malloc_clear((size_t)buffer_size_bytes);\n    }\n\n    /* Create engine */\n    const SLEngineOption opts[] = { { SL_ENGINEOPTION_THREADSAFE, SL_BOOLEAN_TRUE } };\n    if (slCreateEngine(&_saudio.backend.engine_obj, 1, opts, 0, NULL, NULL ) != SL_RESULT_SUCCESS) {\n        _SAUDIO_ERROR(SLES_CREATE_ENGINE_FAILED);\n        _saudio_sles_backend_shutdown();\n        return false;\n    }\n\n    (*_saudio.backend.engine_obj)->Realize(_saudio.backend.engine_obj, SL_BOOLEAN_FALSE);\n    if ((*_saudio.backend.engine_obj)->GetInterface(_saudio.backend.engine_obj, SL_IID_ENGINE, &_saudio.backend.engine) != SL_RESULT_SUCCESS) {\n        _SAUDIO_ERROR(SLES_ENGINE_GET_ENGINE_INTERFACE_FAILED);\n        _saudio_sles_backend_shutdown();\n        return false;\n    }\n\n    /* Create output mix. */\n    {\n        const SLInterfaceID ids[] = { SL_IID_VOLUME };\n        const SLboolean req[] = { SL_BOOLEAN_FALSE };\n\n        if ((*_saudio.backend.engine)->CreateOutputMix(_saudio.backend.engine, &_saudio.backend.output_mix_obj, 1, ids, req) != SL_RESULT_SUCCESS) {\n            _SAUDIO_ERROR(SLES_CREATE_OUTPUT_MIX_FAILED);\n            _saudio_sles_backend_shutdown();\n            return false;\n        }\n        (*_saudio.backend.output_mix_obj)->Realize(_saudio.backend.output_mix_obj, SL_BOOLEAN_FALSE);\n\n        if ((*_saudio.backend.output_mix_obj)->GetInterface(_saudio.backend.output_mix_obj, SL_IID_VOLUME, &_saudio.backend.output_mix_vol) != SL_RESULT_SUCCESS) {\n            _SAUDIO_WARN(SLES_MIXER_GET_VOLUME_INTERFACE_FAILED);\n        }\n    }\n\n    /* android buffer queue */\n    _saudio.backend.in_locator.locatorType = SL_DATALOCATOR_ANDROIDSIMPLEBUFFERQUEUE;\n    _saudio.backend.in_locator.numBuffers = SAUDIO_SLES_NUM_BUFFERS;\n\n    /* data format */\n    SLDataFormat_PCM format;\n    format.formatType = SL_DATAFORMAT_PCM;\n    format.numChannels = (SLuint32)_saudio.num_channels;\n    format.samplesPerSec = (SLuint32) (_saudio.sample_rate * 1000);\n    format.bitsPerSample = SL_PCMSAMPLEFORMAT_FIXED_16;\n    format.containerSize = 16;\n    format.endianness = SL_BYTEORDER_LITTLEENDIAN;\n\n    if (_saudio.num_channels == 2) {\n        format.channelMask = SL_SPEAKER_FRONT_LEFT | SL_SPEAKER_FRONT_RIGHT;\n    } else {\n        format.channelMask = SL_SPEAKER_FRONT_CENTER;\n    }\n\n    SLDataSource src;\n    src.pLocator = &_saudio.backend.in_locator;\n    src.pFormat = &format;\n\n    /* Output mix. */\n    _saudio.backend.out_locator.locatorType = SL_DATALOCATOR_OUTPUTMIX;\n    _saudio.backend.out_locator.outputMix = _saudio.backend.output_mix_obj;\n\n    _saudio.backend.dst_data_sink.pLocator = &_saudio.backend.out_locator;\n    _saudio.backend.dst_data_sink.pFormat = NULL;\n\n    /* setup player */\n    {\n        const SLInterfaceID ids[] = { SL_IID_VOLUME, SL_IID_ANDROIDSIMPLEBUFFERQUEUE };\n        const SLboolean req[] = { SL_BOOLEAN_FALSE, SL_BOOLEAN_TRUE };\n\n        if ((*_saudio.backend.engine)->CreateAudioPlayer(_saudio.backend.engine, &_saudio.backend.player_obj, &src, &_saudio.backend.dst_data_sink, sizeof(ids) / sizeof(ids[0]), ids, req) != SL_RESULT_SUCCESS)\n        {\n            _SAUDIO_ERROR(SLES_ENGINE_CREATE_AUDIO_PLAYER_FAILED);\n            _saudio_sles_backend_shutdown();\n            return false;\n        }\n        (*_saudio.backend.player_obj)->Realize(_saudio.backend.player_obj, SL_BOOLEAN_FALSE);\n\n        if ((*_saudio.backend.player_obj)->GetInterface(_saudio.backend.player_obj, SL_IID_PLAY, &_saudio.backend.player) != SL_RESULT_SUCCESS) {\n            _SAUDIO_ERROR(SLES_PLAYER_GET_PLAY_INTERFACE_FAILED);\n            _saudio_sles_backend_shutdown();\n            return false;\n        }\n        if ((*_saudio.backend.player_obj)->GetInterface(_saudio.backend.player_obj, SL_IID_VOLUME, &_saudio.backend.player_vol) != SL_RESULT_SUCCESS) {\n            _SAUDIO_ERROR(SLES_PLAYER_GET_VOLUME_INTERFACE_FAILED);\n        }\n        if ((*_saudio.backend.player_obj)->GetInterface(_saudio.backend.player_obj, SL_IID_ANDROIDSIMPLEBUFFERQUEUE, &_saudio.backend.player_buffer_queue) != SL_RESULT_SUCCESS) {\n            _SAUDIO_ERROR(SLES_PLAYER_GET_BUFFERQUEUE_INTERFACE_FAILED);\n            _saudio_sles_backend_shutdown();\n            return false;\n        }\n    }\n\n    /* begin */\n    {\n        const int buffer_size_bytes = (int)sizeof(int16_t) * _saudio.num_channels * _saudio.buffer_frames;\n        (*_saudio.backend.player_buffer_queue)->Enqueue(_saudio.backend.player_buffer_queue, _saudio.backend.output_buffers[0], (SLuint32)buffer_size_bytes);\n        _saudio.backend.active_buffer = (_saudio.backend.active_buffer + 1) % SAUDIO_SLES_NUM_BUFFERS;\n\n        (*_saudio.backend.player)->RegisterCallback(_saudio.backend.player, _saudio_sles_play_cb, NULL);\n        (*_saudio.backend.player)->SetCallbackEventsMask(_saudio.backend.player, SL_PLAYEVENT_HEADATEND);\n        (*_saudio.backend.player)->SetPlayState(_saudio.backend.player, SL_PLAYSTATE_PLAYING);\n    }\n\n    /* create the buffer-streaming start thread */\n    if (0 != pthread_create(&_saudio.backend.thread, 0, _saudio_sles_thread_fn, 0)) {\n        _saudio_sles_backend_shutdown();\n        return false;\n    }\n\n    return true;\n}\n\n//                     \n//                                        \n//                                \n//                                        \n//                      \n//\n// >>coreaudio\n#elif defined(_SAUDIO_APPLE)\n\n#if defined(_SAUDIO_IOS)\n#if __has_feature(objc_arc)\n#define _SAUDIO_OBJC_RELEASE(obj) { obj = nil; }\n#else\n#define _SAUDIO_OBJC_RELEASE(obj) { [obj release]; obj = nil; }\n#endif\n\n@interface _saudio_interruption_handler : NSObject { }\n@end\n\n@implementation _saudio_interruption_handler\n-(id)init {\n    self = [super init];\n    AVAudioSession* session = [AVAudioSession sharedInstance];\n    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handle_interruption:) name:AVAudioSessionInterruptionNotification object:session];\n    return self;\n}\n\n-(void)dealloc {\n    [self remove_handler];\n    #if !__has_feature(objc_arc)\n    [super dealloc];\n    #endif\n}\n\n-(void)remove_handler {\n    [[NSNotificationCenter defaultCenter] removeObserver:self name:@\"AVAudioSessionInterruptionNotification\" object:nil];\n}\n\n-(void)handle_interruption:(NSNotification*)notification {\n    AVAudioSession* session = [AVAudioSession sharedInstance];\n    SOKOL_ASSERT(session);\n    NSDictionary* dict = notification.userInfo;\n    SOKOL_ASSERT(dict);\n    NSInteger type = [[dict valueForKey:AVAudioSessionInterruptionTypeKey] integerValue];\n    switch (type) {\n        case AVAudioSessionInterruptionTypeBegan:\n            if (_saudio.backend.ca_audio_queue) {\n                AudioQueuePause(_saudio.backend.ca_audio_queue);\n            }\n            [session setActive:false error:nil];\n            break;\n        case AVAudioSessionInterruptionTypeEnded:\n            [session setActive:true error:nil];\n            if (_saudio.backend.ca_audio_queue) {\n                AudioQueueStart(_saudio.backend.ca_audio_queue, NULL);\n            }\n            break;\n        default:\n            break;\n    }\n}\n@end\n#endif // _SAUDIO_IOS\n\n/* NOTE: the buffer data callback is called on a separate thread! */\n_SOKOL_PRIVATE void _saudio_coreaudio_callback(void* user_data, _saudio_AudioQueueRef queue, _saudio_AudioQueueBufferRef buffer) {\n    _SOKOL_UNUSED(user_data);\n    if (_saudio_has_callback()) {\n        const int num_frames = (int)buffer->mAudioDataByteSize / _saudio.bytes_per_frame;\n        const int num_channels = _saudio.num_channels;\n        _saudio_stream_callback((float*)buffer->mAudioData, num_frames, num_channels);\n    }\n    else {\n        uint8_t* ptr = (uint8_t*)buffer->mAudioData;\n        int num_bytes = (int) buffer->mAudioDataByteSize;\n        if (0 == _saudio_fifo_read(&_saudio.fifo, ptr, num_bytes)) {\n            /* not enough read data available, fill the entire buffer with silence */\n            _saudio_clear(ptr, (size_t)num_bytes);\n        }\n    }\n    AudioQueueEnqueueBuffer(queue, buffer, 0, NULL);\n}\n\n_SOKOL_PRIVATE void _saudio_coreaudio_backend_shutdown(void) {\n    if (_saudio.backend.ca_audio_queue) {\n        AudioQueueStop(_saudio.backend.ca_audio_queue, true);\n        AudioQueueDispose(_saudio.backend.ca_audio_queue, false);\n        _saudio.backend.ca_audio_queue = 0;\n    }\n    #if defined(_SAUDIO_IOS)\n        /* remove interruption handler */\n        if (_saudio.backend.ca_interruption_handler != nil) {\n            [_saudio.backend.ca_interruption_handler remove_handler];\n            _SAUDIO_OBJC_RELEASE(_saudio.backend.ca_interruption_handler);\n        }\n        /* deactivate audio session */\n        AVAudioSession* session = [AVAudioSession sharedInstance];\n        SOKOL_ASSERT(session);\n        [session setActive:false error:nil];;\n    #endif // _SAUDIO_IOS\n}\n\n_SOKOL_PRIVATE bool _saudio_coreaudio_backend_init(void) {\n    SOKOL_ASSERT(0 == _saudio.backend.ca_audio_queue);\n\n    #if defined(_SAUDIO_IOS)\n        /* activate audio session */\n        AVAudioSession* session = [AVAudioSession sharedInstance];\n        SOKOL_ASSERT(session != nil);\n        [session setCategory: AVAudioSessionCategoryPlayback error:nil];\n        [session setActive:true error:nil];\n\n        /* create interruption handler */\n        _saudio.backend.ca_interruption_handler = [[_saudio_interruption_handler alloc] init];\n    #endif\n\n    /* create an audio queue with fp32 samples */\n    _saudio_AudioStreamBasicDescription fmt;\n    _saudio_clear(&fmt, sizeof(fmt));\n    fmt.mSampleRate = (double) _saudio.sample_rate;\n    fmt.mFormatID = _saudio_kAudioFormatLinearPCM;\n    fmt.mFormatFlags = _saudio_kLinearPCMFormatFlagIsFloat | _saudio_kAudioFormatFlagIsPacked;\n    fmt.mFramesPerPacket = 1;\n    fmt.mChannelsPerFrame = (uint32_t) _saudio.num_channels;\n    fmt.mBytesPerFrame = (uint32_t)sizeof(float) * (uint32_t)_saudio.num_channels;\n    fmt.mBytesPerPacket = fmt.mBytesPerFrame;\n    fmt.mBitsPerChannel = 32;\n    _saudio_OSStatus res = AudioQueueNewOutput(&fmt, _saudio_coreaudio_callback, 0, NULL, NULL, 0, &_saudio.backend.ca_audio_queue);\n    if (0 != res) {\n        _SAUDIO_ERROR(COREAUDIO_NEW_OUTPUT_FAILED);\n        return false;\n    }\n    SOKOL_ASSERT(_saudio.backend.ca_audio_queue);\n\n    /* create 2 audio buffers */\n    for (int i = 0; i < 2; i++) {\n        _saudio_AudioQueueBufferRef buf = NULL;\n        const uint32_t buf_byte_size = (uint32_t)_saudio.buffer_frames * fmt.mBytesPerFrame;\n        res = AudioQueueAllocateBuffer(_saudio.backend.ca_audio_queue, buf_byte_size, &buf);\n        if (0 != res) {\n            _SAUDIO_ERROR(COREAUDIO_ALLOCATE_BUFFER_FAILED);\n            _saudio_coreaudio_backend_shutdown();\n            return false;\n        }\n        buf->mAudioDataByteSize = buf_byte_size;\n        _saudio_clear(buf->mAudioData, buf->mAudioDataByteSize);\n        AudioQueueEnqueueBuffer(_saudio.backend.ca_audio_queue, buf, 0, NULL);\n    }\n\n    /* init or modify actual playback parameters */\n    _saudio.bytes_per_frame = (int)fmt.mBytesPerFrame;\n\n    /* ...and start playback */\n    res = AudioQueueStart(_saudio.backend.ca_audio_queue, NULL);\n    if (0 != res) {\n        _SAUDIO_ERROR(COREAUDIO_START_FAILED);\n        _saudio_coreaudio_backend_shutdown();\n        return false;\n    }\n    return true;\n}\n\n#else\n#error \"unsupported platform\"\n#endif\n\nbool _saudio_backend_init(void) {\n    #if defined(SOKOL_DUMMY_BACKEND)\n        return _saudio_dummy_backend_init();\n    #elif defined(_SAUDIO_LINUX)\n        return _saudio_alsa_backend_init();\n    #elif defined(_SAUDIO_WINDOWS)\n        return _saudio_wasapi_backend_init();\n    #elif defined(_SAUDIO_EMSCRIPTEN)\n        return _saudio_webaudio_backend_init();\n    #elif defined(SAUDIO_ANDROID_AAUDIO)\n        return _saudio_aaudio_backend_init();\n    #elif defined(SAUDIO_ANDROID_SLES)\n        return _saudio_sles_backend_init();\n    #elif defined(_SAUDIO_APPLE)\n        return _saudio_coreaudio_backend_init();\n    #else\n    #error \"unknown platform\"\n    #endif\n}\n\nvoid _saudio_backend_shutdown(void) {\n    #if defined(SOKOL_DUMMY_BACKEND)\n        _saudio_dummy_backend_shutdown();\n    #elif defined(_SAUDIO_LINUX)\n        _saudio_alsa_backend_shutdown();\n    #elif defined(_SAUDIO_WINDOWS)\n        _saudio_wasapi_backend_shutdown();\n    #elif defined(_SAUDIO_EMSCRIPTEN)\n        _saudio_webaudio_backend_shutdown();\n    #elif defined(SAUDIO_ANDROID_AAUDIO)\n        _saudio_aaudio_backend_shutdown();\n    #elif defined(SAUDIO_ANDROID_SLES)\n        _saudio_sles_backend_shutdown();\n    #elif defined(_SAUDIO_APPLE)\n        _saudio_coreaudio_backend_shutdown();\n    #else\n    #error \"unknown platform\"\n    #endif\n}\n\n//                  \n//                     \n//                 \n//                       \n//               \n//\n// >>public\nSOKOL_API_IMPL void saudio_setup(const saudio_desc* desc) {\n    SOKOL_ASSERT(!_saudio.valid);\n    SOKOL_ASSERT(!_saudio.setup_called);\n    SOKOL_ASSERT(desc);\n    SOKOL_ASSERT((desc->allocator.alloc_fn && desc->allocator.free_fn) || (!desc->allocator.alloc_fn && !desc->allocator.free_fn));\n    _saudio_clear(&_saudio, sizeof(_saudio));\n    _saudio.setup_called = true;\n    _saudio.desc = *desc;\n    _saudio.stream_cb = desc->stream_cb;\n    _saudio.stream_userdata_cb = desc->stream_userdata_cb;\n    _saudio.user_data = desc->user_data;\n    _saudio.sample_rate = _saudio_def(_saudio.desc.sample_rate, _SAUDIO_DEFAULT_SAMPLE_RATE);\n    _saudio.buffer_frames = _saudio_def(_saudio.desc.buffer_frames, _SAUDIO_DEFAULT_BUFFER_FRAMES);\n    _saudio.packet_frames = _saudio_def(_saudio.desc.packet_frames, _SAUDIO_DEFAULT_PACKET_FRAMES);\n    _saudio.num_packets = _saudio_def(_saudio.desc.num_packets, _SAUDIO_DEFAULT_NUM_PACKETS);\n    _saudio.num_channels = _saudio_def(_saudio.desc.num_channels, 1);\n    _saudio_fifo_init_mutex(&_saudio.fifo);\n    if (_saudio_backend_init()) {\n        /* the backend might not support the requested exact buffer size,\n           make sure the actual buffer size is still a multiple of\n           the requested packet size\n        */\n        if (0 != (_saudio.buffer_frames % _saudio.packet_frames)) {\n            _SAUDIO_ERROR(BACKEND_BUFFER_SIZE_ISNT_MULTIPLE_OF_PACKET_SIZE);\n            _saudio_backend_shutdown();\n            return;\n        }\n        SOKOL_ASSERT(_saudio.bytes_per_frame > 0);\n        _saudio_fifo_init(&_saudio.fifo, _saudio.packet_frames * _saudio.bytes_per_frame, _saudio.num_packets);\n        _saudio.valid = true;\n    }\n    else {\n        _saudio_fifo_destroy_mutex(&_saudio.fifo);\n    }\n}\n\nSOKOL_API_IMPL void saudio_shutdown(void) {\n    SOKOL_ASSERT(_saudio.setup_called);\n    _saudio.setup_called = false;\n    if (_saudio.valid) {\n        _saudio_backend_shutdown();\n        _saudio_fifo_shutdown(&_saudio.fifo);\n        _saudio_fifo_destroy_mutex(&_saudio.fifo);\n        _saudio.valid = false;\n    }\n}\n\nSOKOL_API_IMPL bool saudio_isvalid(void) {\n    return _saudio.valid;\n}\n\nSOKOL_API_IMPL void* saudio_userdata(void) {\n    SOKOL_ASSERT(_saudio.setup_called);\n    return _saudio.desc.user_data;\n}\n\nSOKOL_API_IMPL saudio_desc saudio_query_desc(void) {\n    SOKOL_ASSERT(_saudio.setup_called);\n    return _saudio.desc;\n}\n\nSOKOL_API_IMPL int saudio_sample_rate(void) {\n    SOKOL_ASSERT(_saudio.setup_called);\n    return _saudio.sample_rate;\n}\n\nSOKOL_API_IMPL int saudio_buffer_frames(void) {\n    SOKOL_ASSERT(_saudio.setup_called);\n    return _saudio.buffer_frames;\n}\n\nSOKOL_API_IMPL int saudio_channels(void) {\n    SOKOL_ASSERT(_saudio.setup_called);\n    return _saudio.num_channels;\n}\n\nSOKOL_API_IMPL bool saudio_suspended(void) {\n    SOKOL_ASSERT(_saudio.setup_called);\n    #if defined(_SAUDIO_EMSCRIPTEN)\n        if (_saudio.valid) {\n            return 1 == saudio_js_suspended();\n        }\n        else {\n            return false;\n        }\n    #else\n        return false;\n    #endif\n}\n\nSOKOL_API_IMPL int saudio_expect(void) {\n    SOKOL_ASSERT(_saudio.setup_called);\n    if (_saudio.valid) {\n        const int num_frames = _saudio_fifo_writable_bytes(&_saudio.fifo) / _saudio.bytes_per_frame;\n        return num_frames;\n    }\n    else {\n        return 0;\n    }\n}\n\nSOKOL_API_IMPL int saudio_push(const float* frames, int num_frames) {\n    SOKOL_ASSERT(_saudio.setup_called);\n    SOKOL_ASSERT(frames && (num_frames > 0));\n    if (_saudio.valid) {\n        const int num_bytes = num_frames * _saudio.bytes_per_frame;\n        const int num_written = _saudio_fifo_write(&_saudio.fifo, (const uint8_t*)frames, num_bytes);\n        return num_written / _saudio.bytes_per_frame;\n    }\n    else {\n        return 0;\n    }\n}\n\n#undef _saudio_def\n#undef _saudio_def_flt\n\n#if defined(_SAUDIO_WINDOWS)\n#ifdef _MSC_VER\n#pragma warning(pop)\n#endif\n#endif\n\n#endif /* SOKOL_AUDIO_IMPL */\n"
        },
        {
          "name": "sokol_fetch.h",
          "type": "blob",
          "size": 114.80859375,
          "content": "#if defined(SOKOL_IMPL) && !defined(SOKOL_FETCH_IMPL)\n#define SOKOL_FETCH_IMPL\n#endif\n#ifndef SOKOL_FETCH_INCLUDED\n/*\n    sokol_fetch.h -- asynchronous data loading/streaming\n\n    Project URL: https://github.com/floooh/sokol\n\n    Do this:\n        #define SOKOL_IMPL or\n        #define SOKOL_FETCH_IMPL\n    before you include this file in *one* C or C++ file to create the\n    implementation.\n\n    Optionally provide the following defines with your own implementations:\n\n    SOKOL_ASSERT(c)             - your own assert macro (default: assert(c))\n    SOKOL_UNREACHABLE()         - a guard macro for unreachable code (default: assert(false))\n    SOKOL_FETCH_API_DECL        - public function declaration prefix (default: extern)\n    SOKOL_API_DECL              - same as SOKOL_FETCH_API_DECL\n    SOKOL_API_IMPL              - public function implementation prefix (default: -)\n    SFETCH_MAX_PATH             - max length of UTF-8 filesystem path / URL (default: 1024 bytes)\n    SFETCH_MAX_USERDATA_UINT64  - max size of embedded userdata in number of uint64_t, userdata\n                                  will be copied into an 8-byte aligned memory region associated\n                                  with each in-flight request, default value is 16 (== 128 bytes)\n    SFETCH_MAX_CHANNELS         - max number of IO channels (default is 16, also see sfetch_desc_t.num_channels)\n\n    If sokol_fetch.h is compiled as a DLL, define the following before\n    including the declaration or implementation:\n\n    SOKOL_DLL\n\n    On Windows, SOKOL_DLL will define SOKOL_FETCH_API_DECL as __declspec(dllexport)\n    or __declspec(dllimport) as needed.\n\n    NOTE: The following documentation talks a lot about \"IO threads\". Actual\n    threads are only used on platforms where threads are available. The web\n    version (emscripten/wasm) doesn't use POSIX-style threads, but instead\n    asynchronous Javascript calls chained together by callbacks. The actual\n    source code differences between the two approaches have been kept to\n    a minimum though.\n\n    FEATURE OVERVIEW\n    ================\n\n    - Asynchronously load complete files, or stream files incrementally via\n      HTTP (on web platform), or the local file system (on native platforms)\n\n    - Request / response-callback model, user code sends a request\n      to initiate a file-load, sokol_fetch.h calls the response callback\n      on the same thread when data is ready or user-code needs\n      to respond otherwise\n\n    - Not limited to the main-thread or a single thread: A sokol-fetch\n      \"context\" can live on any thread, and multiple contexts\n      can operate side-by-side on different threads.\n\n    - Memory management for data buffers is under full control of user code.\n      sokol_fetch.h won't allocate memory after it has been setup.\n\n    - Automatic rate-limiting guarantees that only a maximum number of\n      requests is processed at any one time, allowing a zero-allocation\n      model, where all data is streamed into fixed-size, pre-allocated\n      buffers.\n\n    - Active Requests can be paused, continued and cancelled from anywhere\n      in the user-thread which sent this request.\n\n\n    TL;DR EXAMPLE CODE\n    ==================\n    This is the most-simple example code to load a single data file with a\n    known maximum size:\n\n    (1) initialize sokol-fetch with default parameters (but NOTE that the\n        default setup parameters provide a safe-but-slow \"serialized\"\n        operation). In order to see any logging output in case or errors\n        you should always provide a logging function\n        (such as 'slog_func' from sokol_log.h):\n\n        sfetch_setup(&(sfetch_desc_t){ .logger.func = slog_func });\n\n    (2) send a fetch-request to load a file from the current directory\n        into a buffer big enough to hold the entire file content:\n\n        static uint8_t buf[MAX_FILE_SIZE];\n\n        sfetch_send(&(sfetch_request_t){\n            .path = \"my_file.txt\",\n            .callback = response_callback,\n            .buffer = {\n                .ptr = buf,\n                .size = sizeof(buf)\n            }\n        });\n\n        If 'buf' is a value (e.g. an array or struct item), the .buffer item can\n        be initialized with the SFETCH_RANGE() helper macro:\n\n        sfetch_send(&(sfetch_request_t){\n            .path = \"my_file.txt\",\n            .callback = response_callback,\n            .buffer = SFETCH_RANGE(buf)\n        });\n\n    (3) write a 'response-callback' function, this will be called whenever\n        the user-code must respond to state changes of the request\n        (most importantly when data has been loaded):\n\n        void response_callback(const sfetch_response_t* response) {\n            if (response->fetched) {\n                // data has been loaded, and is available via the\n                // sfetch_range_t struct item 'data':\n                const void* ptr = response->data.ptr;\n                size_t num_bytes = response->data.size;\n            }\n            if (response->finished) {\n                // the 'finished'-flag is the catch-all flag for when the request\n                // is finished, no matter if loading was successful or failed,\n                // so any cleanup-work should happen here...\n                ...\n                if (response->failed) {\n                    // 'failed' is true in (addition to 'finished') if something\n                    // went wrong (file doesn't exist, or less bytes could be\n                    // read from the file than expected)\n                }\n            }\n        }\n\n    (4) pump the sokol-fetch message queues, and invoke response callbacks\n        by calling:\n\n        sfetch_dowork();\n\n        In an event-driven app this should be called in the event loop. If you\n        use sokol-app this would be in your frame_cb function.\n\n    (5) finally, call sfetch_shutdown() at the end of the application:\n\n    There's many other loading-scenarios, for instance one doesn't have to\n    provide a buffer upfront, this can also happen in the response callback.\n\n    Or it's possible to stream huge files into small fixed-size buffer,\n    complete with pausing and continuing the download.\n\n    It's also possible to improve the 'pipeline throughput' by fetching\n    multiple files in parallel, but at the same time limit the maximum\n    number of requests that can be 'in-flight'.\n\n    For how this all works, please read the following documentation sections :)\n\n\n    API DOCUMENTATION\n    =================\n\n    void sfetch_setup(const sfetch_desc_t* desc)\n    --------------------------------------------\n    First call sfetch_setup(const sfetch_desc_t*) on any thread before calling\n    any other sokol-fetch functions on the same thread.\n\n    sfetch_setup() takes a pointer to an sfetch_desc_t struct with setup\n    parameters. Parameters which should use their default values must\n    be zero-initialized:\n\n        - max_requests (uint32_t):\n            The maximum number of requests that can be alive at any time, the\n            default is 128.\n\n        - num_channels (uint32_t):\n            The number of \"IO channels\" used to parallelize and prioritize\n            requests, the default is 1.\n\n        - num_lanes (uint32_t):\n            The number of \"lanes\" on a single channel. Each request which is\n            currently 'inflight' on a channel occupies one lane until the\n            request is finished. This is used for automatic rate-limiting\n            (search below for CHANNELS AND LANES for more details). The\n            default number of lanes is 1.\n\n    For example, to setup sokol-fetch for max 1024 active requests, 4 channels,\n    and 8 lanes per channel in C99:\n\n        sfetch_setup(&(sfetch_desc_t){\n            .max_requests = 1024,\n            .num_channels = 4,\n            .num_lanes = 8\n        });\n\n    sfetch_setup() is the only place where sokol-fetch will allocate memory.\n\n    NOTE that the default setup parameters of 1 channel and 1 lane per channel\n    has a very poor 'pipeline throughput' since this essentially serializes\n    IO requests (a new request will only be processed when the last one has\n    finished), and since each request needs at least one roundtrip between\n    the user- and IO-thread the throughput will be at most one request per\n    frame. Search for LATENCY AND THROUGHPUT below for more information on\n    how to increase throughput.\n\n    NOTE that you can call sfetch_setup() on multiple threads, each thread\n    will get its own thread-local sokol-fetch instance, which will work\n    independently from sokol-fetch instances on other threads.\n\n    void sfetch_shutdown(void)\n    --------------------------\n    Call sfetch_shutdown() at the end of the application to stop any\n    IO threads and free all memory that was allocated in sfetch_setup().\n\n    sfetch_handle_t sfetch_send(const sfetch_request_t* request)\n    ------------------------------------------------------------\n    Call sfetch_send() to start loading data, the function takes a pointer to an\n    sfetch_request_t struct with request parameters and returns a\n    sfetch_handle_t identifying the request for later calls. At least\n    a path/URL and callback must be provided:\n\n        sfetch_handle_t h = sfetch_send(&(sfetch_request_t){\n            .path = \"my_file.txt\",\n            .callback = my_response_callback\n        });\n\n    sfetch_send() will return an invalid handle if no request can be allocated\n    from the internal pool because all available request items are 'in-flight'.\n\n    The sfetch_request_t struct contains the following parameters (optional\n    parameters that are not provided must be zero-initialized):\n\n        - path (const char*, required)\n            Pointer to an UTF-8 encoded C string describing the filesystem\n            path or HTTP URL. The string will be copied into an internal data\n            structure, and passed \"as is\" (apart from any required\n            encoding-conversions) to fopen(), CreateFileW() or\n            XMLHttpRequest. The maximum length of the string is defined by\n            the SFETCH_MAX_PATH configuration define, the default is 1024 bytes\n            including the 0-terminator byte.\n\n        - callback (sfetch_callback_t, required)\n            Pointer to a response-callback function which is called when the\n            request needs \"user code attention\". Search below for REQUEST\n            STATES AND THE RESPONSE CALLBACK for detailed information about\n            handling responses in the response callback.\n\n        - channel (uint32_t, optional)\n            Index of the IO channel where the request should be processed.\n            Channels are used to parallelize and prioritize requests relative\n            to each other. Search below for CHANNELS AND LANES for more\n            information. The default channel is 0.\n\n        - chunk_size (uint32_t, optional)\n            The chunk_size member is used for streaming data incrementally\n            in small chunks. After 'chunk_size' bytes have been loaded into\n            to the streaming buffer, the response callback will be called\n            with the buffer containing the fetched data for the current chunk.\n            If chunk_size is 0 (the default), than the whole file will be loaded.\n            Please search below for CHUNK SIZE AND HTTP COMPRESSION for\n            important information how streaming works if the web server\n            is serving compressed data.\n\n        - buffer (sfetch_range_t)\n            This is a optional pointer/size pair describing a chunk of memory where\n            data will be loaded into (if no buffer is provided upfront, this\n            must happen in the response callback). If a buffer is provided,\n            it must be big enough to either hold the entire file (if chunk_size\n            is zero), or the *uncompressed* data for one downloaded chunk\n            (if chunk_size is > 0).\n\n        - user_data (sfetch_range_t)\n            The user_data ptr/size range struct describe an optional POD blob\n            (plain-old-data) associated with the request which will be copied(!)\n            into an internal memory block. The maximum default size of this\n            memory block is 128 bytes (but can be overridden by defining\n            SFETCH_MAX_USERDATA_UINT64 before including the notification, note\n            that this define is in \"number of uint64_t\", not number of bytes).\n            The user-data block is 8-byte aligned, and will be copied via\n            memcpy() (so don't put any C++ \"smart members\" in there).\n\n    NOTE that request handles are strictly thread-local and only unique\n    within the thread the handle was created on, and all function calls\n    involving a request handle must happen on that same thread.\n\n    bool sfetch_handle_valid(sfetch_handle_t request)\n    -------------------------------------------------\n    This checks if the provided request handle is valid, and is associated with\n    a currently active request. It will return false if:\n\n        - sfetch_send() returned an invalid handle because it couldn't allocate\n          a new request from the internal request pool (because they're all\n          in flight)\n        - the request associated with the handle is no longer alive (because\n          it either finished successfully, or the request failed for some\n          reason)\n\n    void sfetch_dowork(void)\n    ------------------------\n    Call sfetch_dowork(void) in regular intervals (for instance once per frame)\n    on the same thread as sfetch_setup() to \"turn the gears\". If you are sending\n    requests but never hear back from them in the response callback function, then\n    the most likely reason is that you forgot to add the call to sfetch_dowork()\n    in the per-frame function.\n\n    sfetch_dowork() roughly performs the following work:\n\n        - any new requests that have been sent with sfetch_send() since the\n        last call to sfetch_dowork() will be dispatched to their IO channels\n        and assigned a free lane. If all lanes on that channel are occupied\n        by requests 'in flight', incoming requests must wait until\n        a lane becomes available\n\n        - for all new requests which have been enqueued on a channel which\n        don't already have a buffer assigned the response callback will be\n        called with (response->dispatched == true) so that the response\n        callback can inspect the dynamically assigned lane and bind a buffer\n        to the request (search below for CHANNELS AND LANE for more info)\n\n        - a state transition from \"user side\" to \"IO thread side\" happens for\n        each new request that has been dispatched to a channel.\n\n        - requests dispatched to a channel are either forwarded into that\n        channel's worker thread (on native platforms), or cause an HTTP\n        request to be sent via an asynchronous XMLHttpRequest (on the web\n        platform)\n\n        - for all requests which have finished their current IO operation a\n        state transition from \"IO thread side\" to \"user side\" happens,\n        and the response callback is called so that the fetched data\n        can be processed.\n\n        - requests which are completely finished (either because the entire\n        file content has been loaded, or they are in the FAILED state) are\n        freed (this just changes their state in the 'request pool', no actual\n        memory is freed)\n\n        - requests which are not yet finished are fed back into the\n        'incoming' queue of their channel, and the cycle starts again, this\n        only happens for requests which perform data streaming (not load\n        the entire file at once).\n\n    void sfetch_cancel(sfetch_handle_t request)\n    -------------------------------------------\n    This cancels a request in the next sfetch_dowork() call and invokes the\n    response callback with (response.failed == true) and (response.finished\n    == true) to give user-code a chance to do any cleanup work for the\n    request. If sfetch_cancel() is called for a request that is no longer\n    alive, nothing bad will happen (the call will simply do nothing).\n\n    void sfetch_pause(sfetch_handle_t request)\n    ------------------------------------------\n    This pauses an active request in the next sfetch_dowork() call and puts\n    it into the PAUSED state. For all requests in PAUSED state, the response\n    callback will be called in each call to sfetch_dowork() to give user-code\n    a chance to CONTINUE the request (by calling sfetch_continue()). Pausing\n    a request makes sense for dynamic rate-limiting in streaming scenarios\n    (like video/audio streaming with a fixed number of streaming buffers. As\n    soon as all available buffers are filled with download data, downloading\n    more data must be prevented to allow video/audio playback to catch up and\n    free up empty buffers for new download data.\n\n    void sfetch_continue(sfetch_handle_t request)\n    ---------------------------------------------\n    Continues a paused request, counterpart to the sfetch_pause() function.\n\n    void sfetch_bind_buffer(sfetch_handle_t request, sfetch_range_t buffer)\n    ----------------------------------------------------------------------------------------\n    This \"binds\" a new buffer (as pointer/size pair) to an active request. The\n    function *must* be called from inside the response-callback, and there\n    must not already be another buffer bound.\n\n    void* sfetch_unbind_buffer(sfetch_handle_t request)\n    ---------------------------------------------------\n    This removes the current buffer binding from the request and returns\n    a pointer to the previous buffer (useful if the buffer was dynamically\n    allocated and it must be freed).\n\n    sfetch_unbind_buffer() *must* be called from inside the response callback.\n\n    The usual code sequence to bind a different buffer in the response\n    callback might look like this:\n\n        void response_callback(const sfetch_response_t* response) {\n            if (response.fetched) {\n                ...\n                // switch to a different buffer (in the FETCHED state it is\n                // guaranteed that the request has a buffer, otherwise it\n                // would have gone into the FAILED state\n                void* old_buf_ptr = sfetch_unbind_buffer(response.handle);\n                free(old_buf_ptr);\n                void* new_buf_ptr = malloc(new_buf_size);\n                sfetch_bind_buffer(response.handle, new_buf_ptr, new_buf_size);\n            }\n            if (response.finished) {\n                // unbind and free the currently associated buffer,\n                // the buffer pointer could be null if the request has failed\n                // NOTE that it is legal to call free() with a nullptr,\n                // this happens if the request failed to open its file\n                // and never goes into the OPENED state\n                void* buf_ptr = sfetch_unbind_buffer(response.handle);\n                free(buf_ptr);\n            }\n        }\n\n    sfetch_desc_t sfetch_desc(void)\n    -------------------------------\n    sfetch_desc() returns a copy of the sfetch_desc_t struct passed to\n    sfetch_setup(), with zero-initialized values replaced with\n    their default values.\n\n    int sfetch_max_userdata_bytes(void)\n    -----------------------------------\n    This returns the value of the SFETCH_MAX_USERDATA_UINT64 config\n    define, but in number of bytes (so SFETCH_MAX_USERDATA_UINT64*8).\n\n    int sfetch_max_path(void)\n    -------------------------\n    Returns the value of the SFETCH_MAX_PATH config define.\n\n\n    REQUEST STATES AND THE RESPONSE CALLBACK\n    ========================================\n    A request goes through a number of states during its lifetime. Depending\n    on the current state of a request, it will be 'owned' either by the\n    \"user-thread\" (where the request was sent) or an IO thread.\n\n    You can think of a request as \"ping-ponging\" between the IO thread and\n    user thread, any actual IO work is done on the IO thread, while\n    invocations of the response-callback happen on the user-thread.\n\n    All state transitions and callback invocations happen inside the\n    sfetch_dowork() function.\n\n    An active request goes through the following states:\n\n    ALLOCATED (user-thread)\n\n        The request has been allocated in sfetch_send() and is\n        waiting to be dispatched into its IO channel. When this\n        happens, the request will transition into the DISPATCHED state.\n\n    DISPATCHED (IO thread)\n\n        The request has been dispatched into its IO channel, and a\n        lane has been assigned to the request.\n\n        If a buffer was provided in sfetch_send() the request will\n        immediately transition into the FETCHING state and start loading\n        data into the buffer.\n\n        If no buffer was provided in sfetch_send(), the response\n        callback will be called with (response->dispatched == true),\n        so that the response callback can bind a buffer to the\n        request. Binding the buffer in the response callback makes\n        sense if the buffer isn't dynamically allocated, but instead\n        a pre-allocated buffer must be selected from the request's\n        channel and lane.\n\n        Note that it isn't possible to get a file size in the response callback\n        which would help with allocating a buffer of the right size, this is\n        because it isn't possible in HTTP to query the file size before the\n        entire file is downloaded (...when the web server serves files compressed).\n\n        If opening the file failed, the request will transition into\n        the FAILED state with the error code SFETCH_ERROR_FILE_NOT_FOUND.\n\n    FETCHING (IO thread)\n\n        While a request is in the FETCHING state, data will be loaded into\n        the user-provided buffer.\n\n        If no buffer was provided, the request will go into the FAILED\n        state with the error code SFETCH_ERROR_NO_BUFFER.\n\n        If a buffer was provided, but it is too small to contain the\n        fetched data, the request will go into the FAILED state with\n        error code SFETCH_ERROR_BUFFER_TOO_SMALL.\n\n        If less data can be read from the file than expected, the request\n        will go into the FAILED state with error code SFETCH_ERROR_UNEXPECTED_EOF.\n\n        If loading data into the provided buffer works as expected, the\n        request will go into the FETCHED state.\n\n    FETCHED (user thread)\n\n        The request goes into the FETCHED state either when the entire file\n        has been loaded into the provided buffer (when request.chunk_size == 0),\n        or a chunk has been loaded (and optionally decompressed) into the\n        buffer (when request.chunk_size > 0).\n\n        The response callback will be called so that the user-code can\n        process the loaded data using the following sfetch_response_t struct members:\n\n            - data.ptr: pointer to the start of fetched data\n            - data.size: the number of bytes in the provided buffer\n            - data_offset: the byte offset of the loaded data chunk in the\n              overall file (this is only set to a non-zero value in a streaming\n              scenario)\n\n        Once all file data has been loaded, the 'finished' flag will be set\n        in the response callback's sfetch_response_t argument.\n\n        After the user callback returns, and all file data has been loaded\n        (response.finished flag is set) the request has reached its end-of-life\n        and will be recycled.\n\n        Otherwise, if there's still data to load (because streaming was\n        requested by providing a non-zero request.chunk_size), the request\n        will switch back to the FETCHING state to load the next chunk of data.\n\n        Note that it is ok to associate a different buffer or buffer-size\n        with the request by calling sfetch_bind_buffer() in the response-callback.\n\n        To check in the response callback for the FETCHED state, and\n        independently whether the request is finished:\n\n            void response_callback(const sfetch_response_t* response) {\n                if (response->fetched) {\n                    // request is in FETCHED state, the loaded data is available\n                    // in .data.ptr, and the number of bytes that have been\n                    // loaded in .data.size:\n                    const void* data = response->data.ptr;\n                    size_t num_bytes = response->data.size;\n                }\n                if (response->finished) {\n                    // the finished flag is set either when all data\n                    // has been loaded, the request has been cancelled,\n                    // or the file operation has failed, this is where\n                    // any required per-request cleanup work should happen\n                }\n            }\n\n\n    FAILED (user thread)\n\n        A request will transition into the FAILED state in the following situations:\n\n            - if the file doesn't exist or couldn't be opened for other\n              reasons (SFETCH_ERROR_FILE_NOT_FOUND)\n            - if no buffer is associated with the request in the FETCHING state\n              (SFETCH_ERROR_NO_BUFFER)\n            - if the provided buffer is too small to hold the entire file\n              (if request.chunk_size == 0), or the (potentially decompressed)\n              partial data chunk (SFETCH_ERROR_BUFFER_TOO_SMALL)\n            - if less bytes could be read from the file then expected\n              (SFETCH_ERROR_UNEXPECTED_EOF)\n            - if a request has been cancelled via sfetch_cancel()\n              (SFETCH_ERROR_CANCELLED)\n\n        The response callback will be called once after a request goes into\n        the FAILED state, with the 'response->finished' and\n        'response->failed' flags set to true.\n\n        This gives the user-code a chance to cleanup any resources associated\n        with the request.\n\n        To check for the failed state in the response callback:\n\n            void response_callback(const sfetch_response_t* response) {\n                if (response->failed) {\n                    // specifically check for the failed state...\n                }\n                // or you can do a catch-all check via the finished-flag:\n                if (response->finished) {\n                    if (response->failed) {\n                        // if more detailed error handling is needed:\n                        switch (response->error_code) {\n                            ...\n                        }\n                    }\n                }\n            }\n\n    PAUSED (user thread)\n\n        A request will transition into the PAUSED state after user-code\n        calls the function sfetch_pause() on the request's handle. Usually\n        this happens from within the response-callback in streaming scenarios\n        when the data streaming needs to wait for a data decoder (like\n        a video/audio player) to catch up.\n\n        While a request is in PAUSED state, the response-callback will be\n        called in each sfetch_dowork(), so that the user-code can either\n        continue the request by calling sfetch_continue(), or cancel\n        the request by calling sfetch_cancel().\n\n        When calling sfetch_continue() on a paused request, the request will\n        transition into the FETCHING state. Otherwise if sfetch_cancel() is\n        called, the request will switch into the FAILED state.\n\n        To check for the PAUSED state in the response callback:\n\n            void response_callback(const sfetch_response_t* response) {\n                if (response->paused) {\n                    // we can check here whether the request should\n                    // continue to load data:\n                    if (should_continue(response->handle)) {\n                        sfetch_continue(response->handle);\n                    }\n                }\n            }\n\n\n    CHUNK SIZE AND HTTP COMPRESSION\n    ===============================\n    TL;DR: for streaming scenarios, the provided chunk-size must be smaller\n    than the provided buffer-size because the web server may decide to\n    serve the data compressed and the chunk-size must be given in 'compressed\n    bytes' while the buffer receives 'uncompressed bytes'. It's not possible\n    in HTTP to query the uncompressed size for a compressed download until\n    that download has finished.\n\n    With vanilla HTTP, it is not possible to query the actual size of a file\n    without downloading the entire file first (the Content-Length response\n    header only provides the compressed size). Furthermore, for HTTP\n    range-requests, the range is given on the compressed data, not the\n    uncompressed data. So if the web server decides to serve the data\n    compressed, the content-length and range-request parameters don't\n    correspond to the uncompressed data that's arriving in the sokol-fetch\n    buffers, and there's no way from JS or WASM to either force uncompressed\n    downloads (e.g. by setting the Accept-Encoding field), or access the\n    compressed data.\n\n    This has some implications for sokol_fetch.h, most notably that buffers\n    can't be provided in the exactly right size, because that size can't\n    be queried from HTTP before the data is actually downloaded.\n\n    When downloading whole files at once, it is basically expected that you\n    know the maximum files size upfront through other means (for instance\n    through a separate meta-data-file which contains the file sizes and\n    other meta-data for each file that needs to be loaded).\n\n    For streaming downloads the situation is a bit more complicated. These\n    use HTTP range-requests, and those ranges are defined on the (potentially)\n    compressed data which the JS/WASM side doesn't have access to. However,\n    the JS/WASM side only ever sees the uncompressed data, and it's not possible\n    to query the uncompressed size of a range request before that range request\n    has finished.\n\n    If the provided buffer is too small to contain the uncompressed data,\n    the request will fail with error code SFETCH_ERROR_BUFFER_TOO_SMALL.\n\n\n    CHANNELS AND LANES\n    ==================\n    Channels and lanes are (somewhat artificial) concepts to manage\n    parallelization, prioritization and rate-limiting.\n\n    Channels can be used to parallelize message processing for better 'pipeline\n    throughput', and to prioritize requests: user-code could reserve one\n    channel for streaming downloads which need to run in parallel to other\n    requests, another channel for \"regular\" downloads and yet another\n    high-priority channel which would only be used for small files which need\n    to start loading immediately.\n\n    Each channel comes with its own IO thread and message queues for pumping\n    messages in and out of the thread. The channel where a request is\n    processed is selected manually when sending a message:\n\n        sfetch_send(&(sfetch_request_t){\n            .path = \"my_file.txt\",\n            .callback = my_response_callback,\n            .channel = 2\n        });\n\n    The number of channels is configured at startup in sfetch_setup() and\n    cannot be changed afterwards.\n\n    Channels are completely separate from each other, and a request will\n    never \"hop\" from one channel to another.\n\n    Each channel consists of a fixed number of \"lanes\" for automatic rate\n    limiting:\n\n    When a request is sent to a channel via sfetch_send(), a \"free lane\" will\n    be picked and assigned to the request. The request will occupy this lane\n    for its entire life time (also while it is paused). If all lanes of a\n    channel are currently occupied, new requests will wait until a\n    lane becomes unoccupied.\n\n    Since the number of channels and lanes is known upfront, it is guaranteed\n    that there will never be more than \"num_channels * num_lanes\" requests\n    in flight at any one time.\n\n    This guarantee eliminates unexpected load- and memory-spikes when\n    many requests are sent in very short time, and it allows to pre-allocate\n    a fixed number of memory buffers which can be reused for the entire\n    \"lifetime\" of a sokol-fetch context.\n\n    In the most simple scenario - when a maximum file size is known - buffers\n    can be statically allocated like this:\n\n        uint8_t buffer[NUM_CHANNELS][NUM_LANES][MAX_FILE_SIZE];\n\n    Then in the user callback pick a buffer by channel and lane,\n    and associate it with the request like this:\n\n        void response_callback(const sfetch_response_t* response) {\n            if (response->dispatched) {\n                void* ptr = buffer[response->channel][response->lane];\n                sfetch_bind_buffer(response->handle, ptr, MAX_FILE_SIZE);\n            }\n            ...\n        }\n\n\n    NOTES ON OPTIMIZING PIPELINE LATENCY AND THROUGHPUT\n    ===================================================\n    With the default configuration of 1 channel and 1 lane per channel,\n    sokol_fetch.h will appear to have a shockingly bad loading performance\n    if several files are loaded.\n\n    This has two reasons:\n\n        (1) all parallelization when loading data has been disabled. A new\n        request will only be processed, when the last request has finished.\n\n        (2) every invocation of the response-callback adds one frame of latency\n        to the request, because callbacks will only be called from within\n        sfetch_dowork()\n\n    sokol-fetch takes a few shortcuts to improve step (2) and reduce\n    the 'inherent latency' of a request:\n\n        - if a buffer is provided upfront, the response-callback won't be\n        called in the DISPATCHED state, but start right with the FETCHED state\n        where data has already been loaded into the buffer\n\n        - there is no separate CLOSED state where the callback is invoked\n        separately when loading has finished (or the request has failed),\n        instead the finished and failed flags will be set as part of\n        the last FETCHED invocation\n\n    This means providing a big-enough buffer to fit the entire file is the\n    best case, the response callback will only be called once, ideally in\n    the next frame (or two calls to sfetch_dowork()).\n\n    If no buffer is provided upfront, one frame of latency is added because\n    the response callback needs to be invoked in the DISPATCHED state so that\n    the user code can bind a buffer.\n\n    This means the best case for a request without an upfront-provided\n    buffer is 2 frames (or 3 calls to sfetch_dowork()).\n\n    That's about what can be done to improve the latency for a single request,\n    but the really important step is to improve overall throughput. If you\n    need to load thousands of files you don't want that to be completely\n    serialized.\n\n    The most important action to increase throughput is to increase the\n    number of lanes per channel. This defines how many requests can be\n    'in flight' on a single channel at the same time. The guiding decision\n    factor for how many lanes you can \"afford\" is the memory size you want\n    to set aside for buffers. Each lane needs its own buffer so that\n    the data loaded for one request doesn't scribble over the data\n    loaded for another request.\n\n    Here's a simple example of sending 4 requests without upfront buffer\n    on a channel with 1, 2 and 4 lanes, each line is one frame:\n\n        1 LANE (8 frames):\n            Lane 0:\n            -------------\n            REQ 0 DISPATCHED\n            REQ 0 FETCHED\n            REQ 1 DISPATCHED\n            REQ 1 FETCHED\n            REQ 2 DISPATCHED\n            REQ 2 FETCHED\n            REQ 3 DISPATCHED\n            REQ 3 FETCHED\n\n    Note how the request don't overlap, so they can all use the same buffer.\n\n        2 LANES (4 frames):\n            Lane 0:             Lane 1:\n            ------------------------------------\n            REQ 0 DISPATCHED    REQ 1 DISPATCHED\n            REQ 0 FETCHED       REQ 1 FETCHED\n            REQ 2 DISPATCHED    REQ 3 DISPATCHED\n            REQ 2 FETCHED       REQ 3 FETCHED\n\n    This reduces the overall time to 4 frames, but now you need 2 buffers so\n    that requests don't scribble over each other.\n\n        4 LANES (2 frames):\n            Lane 0:             Lane 1:             Lane 2:             Lane 3:\n            ----------------------------------------------------------------------------\n            REQ 0 DISPATCHED    REQ 1 DISPATCHED    REQ 2 DISPATCHED    REQ 3 DISPATCHED\n            REQ 0 FETCHED       REQ 1 FETCHED       REQ 2 FETCHED       REQ 3 FETCHED\n\n    Now we're down to the same 'best-case' latency as sending a single\n    request.\n\n    Apart from the memory requirements for the streaming buffers (which is\n    under your control), you can be generous with the number of lanes,\n    they don't add any processing overhead.\n\n    The last option for tweaking latency and throughput is channels. Each\n    channel works independently from other channels, so while one\n    channel is busy working through a large number of requests (or one\n    very long streaming download), you can set aside a high-priority channel\n    for requests that need to start as soon as possible.\n\n    On platforms with threading support, each channel runs on its own\n    thread, but this is mainly an implementation detail to work around\n    the traditional blocking file IO functions, not for performance reasons.\n\n\n    MEMORY ALLOCATION OVERRIDE\n    ==========================\n    You can override the memory allocation functions at initialization time\n    like this:\n\n        void* my_alloc(size_t size, void* user_data) {\n            return malloc(size);\n        }\n\n        void my_free(void* ptr, void* user_data) {\n            free(ptr);\n        }\n\n        ...\n            sfetch_setup(&(sfetch_desc_t){\n                // ...\n                .allocator = {\n                    .alloc_fn = my_alloc,\n                    .free_fn = my_free,\n                    .user_data = ...,\n                }\n            });\n        ...\n\n    If no overrides are provided, malloc and free will be used.\n\n    This only affects memory allocation calls done by sokol_fetch.h\n    itself though, not any allocations in OS libraries.\n\n    Memory allocation will only happen on the same thread where sfetch_setup()\n    was called, so you don't need to worry about thread-safety.\n\n\n    ERROR REPORTING AND LOGGING\n    ===========================\n    To get any logging information at all you need to provide a logging callback in the setup call,\n    the easiest way is to use sokol_log.h:\n\n        #include \"sokol_log.h\"\n\n        sfetch_setup(&(sfetch_desc_t){\n            // ...\n            .logger.func = slog_func\n        });\n\n    To override logging with your own callback, first write a logging function like this:\n\n        void my_log(const char* tag,                // e.g. 'sfetch'\n                    uint32_t log_level,             // 0=panic, 1=error, 2=warn, 3=info\n                    uint32_t log_item_id,           // SFETCH_LOGITEM_*\n                    const char* message_or_null,    // a message string, may be nullptr in release mode\n                    uint32_t line_nr,               // line number in sokol_fetch.h\n                    const char* filename_or_null,   // source filename, may be nullptr in release mode\n                    void* user_data)\n        {\n            ...\n        }\n\n    ...and then setup sokol-fetch like this:\n\n        sfetch_setup(&(sfetch_desc_t){\n            .logger = {\n                .func = my_log,\n                .user_data = my_user_data,\n            }\n        });\n\n    The provided logging function must be reentrant (e.g. be callable from\n    different threads).\n\n    If you don't want to provide your own custom logger it is highly recommended to use\n    the standard logger in sokol_log.h instead, otherwise you won't see any warnings or\n    errors.\n\n\n    FUTURE PLANS / V2.0 IDEA DUMP\n    =============================\n    - An optional polling API (as alternative to callback API)\n    - Move buffer-management into the API? The \"manual management\"\n      can be quite tricky especially for dynamic allocation scenarios,\n      API support for buffer management would simplify cases like\n      preventing that requests scribble over each other's buffers, or\n      an automatic garbage collection for dynamically allocated buffers,\n      or automatically falling back to dynamic allocation if static\n      buffers aren't big enough.\n    - Pluggable request handlers to load data from other \"sources\"\n      (especially HTTP downloads on native platforms via e.g. libcurl\n      would be useful)\n    - I'm currently not happy how the user-data block is handled, this\n      should getting and updating the user-data should be wrapped by\n      API functions (similar to bind/unbind buffer)\n\n\n    LICENSE\n    =======\n    zlib/libpng license\n\n    Copyright (c) 2019 Andre Weissflog\n\n    This software is provided 'as-is', without any express or implied warranty.\n    In no event will the authors be held liable for any damages arising from the\n    use of this software.\n\n    Permission is granted to anyone to use this software for any purpose,\n    including commercial applications, and to alter it and redistribute it\n    freely, subject to the following restrictions:\n\n        1. The origin of this software must not be misrepresented; you must not\n        claim that you wrote the original software. If you use this software in a\n        product, an acknowledgment in the product documentation would be\n        appreciated but is not required.\n\n        2. Altered source versions must be plainly marked as such, and must not\n        be misrepresented as being the original software.\n\n        3. This notice may not be removed or altered from any source\n        distribution.\n*/\n#define SOKOL_FETCH_INCLUDED (1)\n#include <stddef.h> // size_t\n#include <stdint.h>\n#include <stdbool.h>\n\n#if defined(SOKOL_API_DECL) && !defined(SOKOL_FETCH_API_DECL)\n#define SOKOL_FETCH_API_DECL SOKOL_API_DECL\n#endif\n#ifndef SOKOL_FETCH_API_DECL\n#if defined(_WIN32) && defined(SOKOL_DLL) && defined(SOKOL_FETCH_IMPL)\n#define SOKOL_FETCH_API_DECL __declspec(dllexport)\n#elif defined(_WIN32) && defined(SOKOL_DLL)\n#define SOKOL_FETCH_API_DECL __declspec(dllimport)\n#else\n#define SOKOL_FETCH_API_DECL extern\n#endif\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/*\n    sfetch_log_item_t\n\n    Log items are defined via X-Macros, and expanded to an\n    enum 'sfetch_log_item', and in debug mode only,\n    corresponding strings.\n\n    Used as parameter in the logging callback.\n*/\n#define _SFETCH_LOG_ITEMS \\\n    _SFETCH_LOGITEM_XMACRO(OK, \"Ok\") \\\n    _SFETCH_LOGITEM_XMACRO(MALLOC_FAILED, \"memory allocation failed\") \\\n    _SFETCH_LOGITEM_XMACRO(FILE_PATH_UTF8_DECODING_FAILED, \"failed converting file path from UTF8 to wide\") \\\n    _SFETCH_LOGITEM_XMACRO(SEND_QUEUE_FULL, \"send queue full (adjust via sfetch_desc_t.max_requests)\")  \\\n    _SFETCH_LOGITEM_XMACRO(REQUEST_CHANNEL_INDEX_TOO_BIG, \"channel index too big (adjust via sfetch_desc_t.num_channels)\") \\\n    _SFETCH_LOGITEM_XMACRO(REQUEST_PATH_IS_NULL, \"file path is nullptr (sfetch_request_t.path)\") \\\n    _SFETCH_LOGITEM_XMACRO(REQUEST_PATH_TOO_LONG, \"file path is too long (SFETCH_MAX_PATH)\") \\\n    _SFETCH_LOGITEM_XMACRO(REQUEST_CALLBACK_MISSING, \"no callback provided (sfetch_request_t.callback)\") \\\n    _SFETCH_LOGITEM_XMACRO(REQUEST_CHUNK_SIZE_GREATER_BUFFER_SIZE, \"chunk size is greater buffer size (sfetch_request_t.chunk_size vs .buffer.size)\") \\\n    _SFETCH_LOGITEM_XMACRO(REQUEST_USERDATA_PTR_IS_SET_BUT_USERDATA_SIZE_IS_NULL, \"user data ptr is set but user data size is null (sfetch_request_t.user_data.ptr vs .size)\") \\\n    _SFETCH_LOGITEM_XMACRO(REQUEST_USERDATA_PTR_IS_NULL_BUT_USERDATA_SIZE_IS_NOT, \"user data ptr is null but size is not (sfetch_request_t.user_data.ptr vs .size)\") \\\n    _SFETCH_LOGITEM_XMACRO(REQUEST_USERDATA_SIZE_TOO_BIG, \"user data size too big (see SFETCH_MAX_USERDATA_UINT64)\") \\\n    _SFETCH_LOGITEM_XMACRO(CLAMPING_NUM_CHANNELS_TO_MAX_CHANNELS, \"clamping num channels to SFETCH_MAX_CHANNELS\") \\\n    _SFETCH_LOGITEM_XMACRO(REQUEST_POOL_EXHAUSTED, \"request pool exhausted (tweak via sfetch_desc_t.max_requests)\") \\\n\n#define _SFETCH_LOGITEM_XMACRO(item,msg) SFETCH_LOGITEM_##item,\ntypedef enum sfetch_log_item_t {\n    _SFETCH_LOG_ITEMS\n} sfetch_log_item_t;\n#undef _SFETCH_LOGITEM_XMACRO\n\n/*\n    sfetch_logger_t\n\n    Used in sfetch_desc_t to provide a custom logging and error reporting\n    callback to sokol-fetch.\n*/\ntypedef struct sfetch_logger_t {\n    void (*func)(\n        const char* tag,                // always \"sfetch\"\n        uint32_t log_level,             // 0=panic, 1=error, 2=warning, 3=info\n        uint32_t log_item_id,           // SFETCH_LOGITEM_*\n        const char* message_or_null,    // a message string, may be nullptr in release mode\n        uint32_t line_nr,               // line number in sokol_fetch.h\n        const char* filename_or_null,   // source filename, may be nullptr in release mode\n        void* user_data);\n    void* user_data;\n} sfetch_logger_t;\n\n/*\n    sfetch_range_t\n\n    A pointer-size pair struct to pass memory ranges into and out of sokol-fetch.\n    When initialized from a value type (array or struct) you can use the\n    SFETCH_RANGE() helper macro to build an sfetch_range_t struct.\n*/\ntypedef struct sfetch_range_t {\n    const void* ptr;\n    size_t size;\n} sfetch_range_t;\n\n// disabling this for every includer isn't great, but the warnings are also quite pointless\n#if defined(_MSC_VER)\n#pragma warning(disable:4221)   // /W4 only: nonstandard extension used: 'x': cannot be initialized using address of automatic variable 'y'\n#pragma warning(disable:4204)   // VS2015: nonstandard extension used: non-constant aggregate initializer\n#endif\n#if defined(__cplusplus)\n#define SFETCH_RANGE(x) sfetch_range_t{ &x, sizeof(x) }\n#else\n#define SFETCH_RANGE(x) (sfetch_range_t){ &x, sizeof(x) }\n#endif\n\n/*\n    sfetch_allocator_t\n\n    Used in sfetch_desc_t to provide custom memory-alloc and -free functions\n    to sokol_fetch.h. If memory management should be overridden, both the\n    alloc and free function must be provided (e.g. it's not valid to\n    override one function but not the other).\n*/\ntypedef struct sfetch_allocator_t {\n    void* (*alloc_fn)(size_t size, void* user_data);\n    void (*free_fn)(void* ptr, void* user_data);\n    void* user_data;\n} sfetch_allocator_t;\n\n/* configuration values for sfetch_setup() */\ntypedef struct sfetch_desc_t {\n    uint32_t max_requests;          // max number of active requests across all channels (default: 128)\n    uint32_t num_channels;          // number of channels to fetch requests in parallel (default: 1)\n    uint32_t num_lanes;             // max number of requests active on the same channel (default: 1)\n    sfetch_allocator_t allocator;   // optional memory allocation overrides (default: malloc/free)\n    sfetch_logger_t logger;         // optional log function overrides (default: NO LOGGING!)\n} sfetch_desc_t;\n\n/* a request handle to identify an active fetch request, returned by sfetch_send() */\ntypedef struct sfetch_handle_t { uint32_t id; } sfetch_handle_t;\n\n/* error codes */\ntypedef enum sfetch_error_t {\n    SFETCH_ERROR_NO_ERROR,\n    SFETCH_ERROR_FILE_NOT_FOUND,\n    SFETCH_ERROR_NO_BUFFER,\n    SFETCH_ERROR_BUFFER_TOO_SMALL,\n    SFETCH_ERROR_UNEXPECTED_EOF,\n    SFETCH_ERROR_INVALID_HTTP_STATUS,\n    SFETCH_ERROR_CANCELLED\n} sfetch_error_t;\n\n/* the response struct passed to the response callback */\ntypedef struct sfetch_response_t {\n    sfetch_handle_t handle;         // request handle this response belongs to\n    bool dispatched;                // true when request is in DISPATCHED state (lane has been assigned)\n    bool fetched;                   // true when request is in FETCHED state (fetched data is available)\n    bool paused;                    // request is currently in paused state\n    bool finished;                  // this is the last response for this request\n    bool failed;                    // request has failed (always set together with 'finished')\n    bool cancelled;                 // request was cancelled (always set together with 'finished')\n    sfetch_error_t error_code;      // more detailed error code when failed is true\n    uint32_t channel;               // the channel which processes this request\n    uint32_t lane;                  // the lane this request occupies on its channel\n    const char* path;               // the original filesystem path of the request\n    void* user_data;                // pointer to read/write user-data area\n    uint32_t data_offset;           // current offset of fetched data chunk in the overall file data\n    sfetch_range_t data;            // the fetched data as ptr/size pair (data.ptr == buffer.ptr, data.size <= buffer.size)\n    sfetch_range_t buffer;          // the user-provided buffer which holds the fetched data\n} sfetch_response_t;\n\n/* request parameters passed to sfetch_send() */\ntypedef struct sfetch_request_t {\n    uint32_t channel;                                // index of channel this request is assigned to (default: 0)\n    const char* path;                                // filesystem path or HTTP URL (required)\n    void (*callback) (const sfetch_response_t*);     // response callback function pointer (required)\n    uint32_t chunk_size;                             // number of bytes to load per stream-block (optional)\n    sfetch_range_t buffer;                           // a memory buffer where the data will be loaded into (optional)\n    sfetch_range_t user_data;                        // ptr/size of a POD user data block which will be memcpy'd (optional)\n} sfetch_request_t;\n\n/* setup sokol-fetch (can be called on multiple threads) */\nSOKOL_FETCH_API_DECL void sfetch_setup(const sfetch_desc_t* desc);\n/* discard a sokol-fetch context */\nSOKOL_FETCH_API_DECL void sfetch_shutdown(void);\n/* return true if sokol-fetch has been setup */\nSOKOL_FETCH_API_DECL bool sfetch_valid(void);\n/* get the desc struct that was passed to sfetch_setup() */\nSOKOL_FETCH_API_DECL sfetch_desc_t sfetch_desc(void);\n/* return the max userdata size in number of bytes (SFETCH_MAX_USERDATA_UINT64 * sizeof(uint64_t)) */\nSOKOL_FETCH_API_DECL int sfetch_max_userdata_bytes(void);\n/* return the value of the SFETCH_MAX_PATH implementation config value */\nSOKOL_FETCH_API_DECL int sfetch_max_path(void);\n\n/* send a fetch-request, get handle to request back */\nSOKOL_FETCH_API_DECL sfetch_handle_t sfetch_send(const sfetch_request_t* request);\n/* return true if a handle is valid *and* the request is alive */\nSOKOL_FETCH_API_DECL bool sfetch_handle_valid(sfetch_handle_t h);\n/* do per-frame work, moves requests into and out of IO threads, and invokes response-callbacks */\nSOKOL_FETCH_API_DECL void sfetch_dowork(void);\n\n/* bind a data buffer to a request (request must not currently have a buffer bound, must be called from response callback */\nSOKOL_FETCH_API_DECL void sfetch_bind_buffer(sfetch_handle_t h, sfetch_range_t buffer);\n/* clear the 'buffer binding' of a request, returns previous buffer pointer (can be 0), must be called from response callback */\nSOKOL_FETCH_API_DECL void* sfetch_unbind_buffer(sfetch_handle_t h);\n/* cancel a request that's in flight (will call response callback with .cancelled + .finished) */\nSOKOL_FETCH_API_DECL void sfetch_cancel(sfetch_handle_t h);\n/* pause a request (will call response callback each frame with .paused) */\nSOKOL_FETCH_API_DECL void sfetch_pause(sfetch_handle_t h);\n/* continue a paused request */\nSOKOL_FETCH_API_DECL void sfetch_continue(sfetch_handle_t h);\n\n#ifdef __cplusplus\n} /* extern \"C\" */\n\n/* reference-based equivalents for c++ */\ninline void sfetch_setup(const sfetch_desc_t& desc) { return sfetch_setup(&desc); }\ninline sfetch_handle_t sfetch_send(const sfetch_request_t& request) { return sfetch_send(&request); }\n\n#endif\n#endif // SOKOL_FETCH_INCLUDED\n\n//                                        \n//                                                             \n//                                                  \n//                                                                   \n//                                                      \n//\n// >>implementation\n#ifdef SOKOL_FETCH_IMPL\n#define SOKOL_FETCH_IMPL_INCLUDED (1)\n\n#if defined(SOKOL_MALLOC) || defined(SOKOL_CALLOC) || defined(SOKOL_FREE)\n#error \"SOKOL_MALLOC/CALLOC/FREE macros are no longer supported, please use sfetch_desc_t.allocator to override memory allocation functions\"\n#endif\n\n#include <stdlib.h> /* malloc, free */\n#include <string.h> /* memset, memcpy */\n\n#ifndef SFETCH_MAX_PATH\n#define SFETCH_MAX_PATH (1024)\n#endif\n#ifndef SFETCH_MAX_USERDATA_UINT64\n#define SFETCH_MAX_USERDATA_UINT64 (16)\n#endif\n#ifndef SFETCH_MAX_CHANNELS\n#define SFETCH_MAX_CHANNELS (16)\n#endif\n\n#ifndef SOKOL_API_IMPL\n    #define SOKOL_API_IMPL\n#endif\n#ifndef SOKOL_DEBUG\n    #ifndef NDEBUG\n        #define SOKOL_DEBUG\n    #endif\n#endif\n#ifndef SOKOL_ASSERT\n    #include <assert.h>\n    #define SOKOL_ASSERT(c) assert(c)\n#endif\n\n#ifndef _SOKOL_PRIVATE\n    #if defined(__GNUC__) || defined(__clang__)\n        #define _SOKOL_PRIVATE __attribute__((unused)) static\n    #else\n        #define _SOKOL_PRIVATE static\n    #endif\n#endif\n\n#ifndef _SOKOL_UNUSED\n    #define _SOKOL_UNUSED(x) (void)(x)\n#endif\n\n#if defined(__EMSCRIPTEN__)\n    #include <emscripten/emscripten.h>\n    #define _SFETCH_PLATFORM_EMSCRIPTEN (1)\n    #define _SFETCH_PLATFORM_WINDOWS (0)\n    #define _SFETCH_PLATFORM_POSIX (0)\n    #define _SFETCH_HAS_THREADS (0)\n#elif defined(_WIN32)\n    #ifndef WIN32_LEAN_AND_MEAN\n    #define WIN32_LEAN_AND_MEAN\n    #endif\n    #ifndef NOMINMAX\n    #define NOMINMAX\n    #endif\n    #include <windows.h>\n    #define _SFETCH_PLATFORM_WINDOWS (1)\n    #define _SFETCH_PLATFORM_EMSCRIPTEN (0)\n    #define _SFETCH_PLATFORM_POSIX (0)\n    #define _SFETCH_HAS_THREADS (1)\n#else\n    #include <pthread.h>\n    #include <stdio.h>  /* fopen, fread, fseek, fclose */\n    #define _SFETCH_PLATFORM_POSIX (1)\n    #define _SFETCH_PLATFORM_EMSCRIPTEN (0)\n    #define _SFETCH_PLATFORM_WINDOWS (0)\n    #define _SFETCH_HAS_THREADS (1)\n#endif\n\n#ifdef _MSC_VER\n#pragma warning(push)\n#pragma warning(disable:4724) // potential mod by 0\n#endif\n\n//             \n//                                    \n//                             \n//                                         \n//                         \n//\n// >>structs\ntypedef struct _sfetch_path_t {\n    char buf[SFETCH_MAX_PATH];\n} _sfetch_path_t;\n\n/* a thread with incoming and outgoing message queue syncing */\n#if _SFETCH_PLATFORM_POSIX\ntypedef struct {\n    pthread_t thread;\n    pthread_cond_t incoming_cond;\n    pthread_mutex_t incoming_mutex;\n    pthread_mutex_t outgoing_mutex;\n    pthread_mutex_t running_mutex;\n    pthread_mutex_t stop_mutex;\n    bool stop_requested;\n    bool valid;\n} _sfetch_thread_t;\n#elif _SFETCH_PLATFORM_WINDOWS\ntypedef struct {\n    HANDLE thread;\n    HANDLE incoming_event;\n    CRITICAL_SECTION incoming_critsec;\n    CRITICAL_SECTION outgoing_critsec;\n    CRITICAL_SECTION running_critsec;\n    CRITICAL_SECTION stop_critsec;\n    bool stop_requested;\n    bool valid;\n} _sfetch_thread_t;\n#endif\n\n/* file handle abstraction */\n#if _SFETCH_PLATFORM_POSIX\ntypedef FILE* _sfetch_file_handle_t;\n#define _SFETCH_INVALID_FILE_HANDLE (0)\ntypedef void*(*_sfetch_thread_func_t)(void*);\n#elif _SFETCH_PLATFORM_WINDOWS\ntypedef HANDLE _sfetch_file_handle_t;\n#define _SFETCH_INVALID_FILE_HANDLE (INVALID_HANDLE_VALUE)\ntypedef LPTHREAD_START_ROUTINE _sfetch_thread_func_t;\n#endif\n\n/* user-side per-request state */\ntypedef struct {\n    bool pause;                 /* switch item to PAUSED state if true */\n    bool cont;                  /* switch item back to FETCHING if true */\n    bool cancel;                /* cancel the request, switch into FAILED state */\n    /* transfer IO => user thread */\n    uint32_t fetched_offset;    /* number of bytes fetched so far */\n    uint32_t fetched_size;      /* size of last fetched chunk */\n    sfetch_error_t error_code;\n    bool finished;\n    /* user thread only */\n    size_t user_data_size;\n    uint64_t user_data[SFETCH_MAX_USERDATA_UINT64];\n} _sfetch_item_user_t;\n\n/* thread-side per-request state */\ntypedef struct {\n    /* transfer IO => user thread */\n    uint32_t fetched_offset;\n    uint32_t fetched_size;\n    sfetch_error_t error_code;\n    bool failed;\n    bool finished;\n    /* IO thread only */\n    #if _SFETCH_PLATFORM_EMSCRIPTEN\n    uint32_t http_range_offset;\n    #else\n    _sfetch_file_handle_t file_handle;\n    #endif\n    uint32_t content_size;\n} _sfetch_item_thread_t;\n\n/* a request goes through the following states, ping-ponging between IO and user thread */\ntypedef enum _sfetch_state_t {\n    _SFETCH_STATE_INITIAL,      /* internal: request has just been initialized */\n    _SFETCH_STATE_ALLOCATED,    /* internal: request has been allocated from internal pool */\n    _SFETCH_STATE_DISPATCHED,   /* user thread: request has been dispatched to its IO channel */\n    _SFETCH_STATE_FETCHING,     /* IO thread: waiting for data to be fetched */\n    _SFETCH_STATE_FETCHED,      /* user thread: fetched data available */\n    _SFETCH_STATE_PAUSED,       /* user thread: request has been paused via sfetch_pause() */\n    _SFETCH_STATE_FAILED,       /* user thread: follow state or FETCHING if something went wrong */\n} _sfetch_state_t;\n\n/* an internal request item */\n#define _SFETCH_INVALID_LANE (0xFFFFFFFF)\ntypedef struct {\n    sfetch_handle_t handle;\n    _sfetch_state_t state;\n    uint32_t channel;\n    uint32_t lane;\n    uint32_t chunk_size;\n    void (*callback) (const sfetch_response_t*);\n    sfetch_range_t buffer;\n\n    /* updated by IO-thread, off-limits to user thread */\n    _sfetch_item_thread_t thread;\n\n    /* accessible by user-thread, off-limits to IO thread */\n    _sfetch_item_user_t user;\n\n    /* big stuff at the end */\n    _sfetch_path_t path;\n} _sfetch_item_t;\n\n/* a pool of internal per-request items */\ntypedef struct {\n    uint32_t size;\n    uint32_t free_top;\n    _sfetch_item_t* items;\n    uint32_t* free_slots;\n    uint32_t* gen_ctrs;\n    bool valid;\n} _sfetch_pool_t;\n\n/* a ringbuffer for pool-slot ids */\ntypedef struct {\n    uint32_t head;\n    uint32_t tail;\n    uint32_t num;\n    uint32_t* buf;\n} _sfetch_ring_t;\n\n/* an IO channel with its own IO thread */\nstruct _sfetch_t;\ntypedef struct {\n    struct _sfetch_t* ctx;  // back-pointer to thread-local _sfetch state pointer, since this isn't accessible from the IO threads\n    _sfetch_ring_t free_lanes;\n    _sfetch_ring_t user_sent;\n    _sfetch_ring_t user_incoming;\n    _sfetch_ring_t user_outgoing;\n    #if _SFETCH_HAS_THREADS\n    _sfetch_ring_t thread_incoming;\n    _sfetch_ring_t thread_outgoing;\n    _sfetch_thread_t thread;\n    #endif\n    void (*request_handler)(struct _sfetch_t* ctx, uint32_t slot_id);\n    bool valid;\n} _sfetch_channel_t;\n\n/* the sfetch global state */\ntypedef struct _sfetch_t {\n    bool setup;\n    bool valid;\n    bool in_callback;\n    sfetch_desc_t desc;\n    _sfetch_pool_t pool;\n    _sfetch_channel_t chn[SFETCH_MAX_CHANNELS];\n} _sfetch_t;\n#if _SFETCH_HAS_THREADS\n#if defined(_MSC_VER)\nstatic __declspec(thread) _sfetch_t* _sfetch;\n#else\nstatic __thread _sfetch_t* _sfetch;\n#endif\n#else\nstatic _sfetch_t* _sfetch;\n#endif\n#define _sfetch_def(val, def) (((val) == 0) ? (def) : (val))\n\n//                       \n//                               \n//                            \n//                               \n//                 \n//\n// >>logging\n#if defined(SOKOL_DEBUG)\n#define _SFETCH_LOGITEM_XMACRO(item,msg) #item \": \" msg,\nstatic const char* _sfetch_log_messages[] = {\n    _SFETCH_LOG_ITEMS\n};\n#undef _SFETCH_LOGITEM_XMACRO\n#endif // SOKOL_DEBUG\n\n#define _SFETCH_PANIC(code) _sfetch_log(SFETCH_LOGITEM_ ##code, 0, __LINE__)\n#define _SFETCH_ERROR(code) _sfetch_log(SFETCH_LOGITEM_ ##code, 1, __LINE__)\n#define _SFETCH_WARN(code) _sfetch_log(SFETCH_LOGITEM_ ##code, 2, __LINE__)\n#define _SFETCH_INFO(code) _sfetch_log(SFETCH_LOGITEM_ ##code, 3, __LINE__)\n\nstatic void _sfetch_log(sfetch_log_item_t log_item, uint32_t log_level, uint32_t line_nr) {\n    if (_sfetch->desc.logger.func) {\n        #if defined(SOKOL_DEBUG)\n            const char* filename = __FILE__;\n            const char* message = _sfetch_log_messages[log_item];\n        #else\n            const char* filename = 0;\n            const char* message = 0;\n        #endif\n        _sfetch->desc.logger.func(\"sfetch\", log_level, log_item, message, line_nr, filename, _sfetch->desc.logger.user_data);\n    }\n    else {\n        // for log level PANIC it would be 'undefined behaviour' to continue\n        if (log_level == 0) {\n            abort();\n        }\n    }\n}\n\n//                     \n//                         \n//                   \n//                             \n//                          \n//\n// >>memory\n_SOKOL_PRIVATE void _sfetch_clear(void* ptr, size_t size) {\n    SOKOL_ASSERT(ptr && (size > 0));\n    memset(ptr, 0, size);\n}\n\n_SOKOL_PRIVATE void* _sfetch_malloc_with_allocator(const sfetch_allocator_t* allocator, size_t size) {\n    SOKOL_ASSERT(size > 0);\n    void* ptr;\n    if (allocator->alloc_fn) {\n        ptr = allocator->alloc_fn(size, allocator->user_data);\n    } else {\n        ptr = malloc(size);\n    }\n    if (0 == ptr) {\n        _SFETCH_PANIC(MALLOC_FAILED);\n    }\n    return ptr;\n}\n\n_SOKOL_PRIVATE void* _sfetch_malloc(size_t size) {\n    return _sfetch_malloc_with_allocator(&_sfetch->desc.allocator, size);\n}\n\n_SOKOL_PRIVATE void* _sfetch_malloc_clear(size_t size) {\n    void* ptr = _sfetch_malloc(size);\n    _sfetch_clear(ptr, size);\n    return ptr;\n}\n\n_SOKOL_PRIVATE void _sfetch_free(void* ptr) {\n    if (_sfetch->desc.allocator.free_fn) {\n        _sfetch->desc.allocator.free_fn(ptr, _sfetch->desc.allocator.user_data);\n    } else {\n        free(ptr);\n    }\n}\n\n_SOKOL_PRIVATE _sfetch_t* _sfetch_ctx(void) {\n    return _sfetch;\n}\n\n_SOKOL_PRIVATE void _sfetch_path_copy(_sfetch_path_t* dst, const char* src) {\n    SOKOL_ASSERT(dst);\n    if (src && (strlen(src) < SFETCH_MAX_PATH)) {\n        #if defined(_MSC_VER)\n        strncpy_s(dst->buf, SFETCH_MAX_PATH, src, (SFETCH_MAX_PATH-1));\n        #else\n        strncpy(dst->buf, src, SFETCH_MAX_PATH);\n        #endif\n        dst->buf[SFETCH_MAX_PATH-1] = 0;\n    }\n    else {\n        _sfetch_clear(dst->buf, SFETCH_MAX_PATH);\n    }\n}\n\n_SOKOL_PRIVATE _sfetch_path_t _sfetch_path_make(const char* str) {\n    _sfetch_path_t res;\n    _sfetch_path_copy(&res, str);\n    return res;\n}\n\n//                                  \n//                                                                \n//                                       \n//                                                              \n//                                 \n//                                                                     \n// >>message queue\n_SOKOL_PRIVATE uint32_t _sfetch_ring_wrap(const _sfetch_ring_t* rb, uint32_t i) {\n    return i % rb->num;\n}\n\n_SOKOL_PRIVATE void _sfetch_ring_discard(_sfetch_ring_t* rb) {\n    SOKOL_ASSERT(rb);\n    if (rb->buf) {\n        _sfetch_free(rb->buf);\n        rb->buf = 0;\n    }\n    rb->head = 0;\n    rb->tail = 0;\n    rb->num = 0;\n}\n\n_SOKOL_PRIVATE bool _sfetch_ring_init(_sfetch_ring_t* rb, uint32_t num_slots) {\n    SOKOL_ASSERT(rb && (num_slots > 0));\n    SOKOL_ASSERT(0 == rb->buf);\n    rb->head = 0;\n    rb->tail = 0;\n    /* one slot reserved to detect full vs empty */\n    rb->num = num_slots + 1;\n    const size_t queue_size = rb->num * sizeof(sfetch_handle_t);\n    rb->buf = (uint32_t*) _sfetch_malloc_clear(queue_size);\n    if (rb->buf) {\n        return true;\n    }\n    else {\n        _sfetch_ring_discard(rb);\n        return false;\n    }\n}\n\n_SOKOL_PRIVATE bool _sfetch_ring_full(const _sfetch_ring_t* rb) {\n    SOKOL_ASSERT(rb && rb->buf);\n    return _sfetch_ring_wrap(rb, rb->head + 1) == rb->tail;\n}\n\n_SOKOL_PRIVATE bool _sfetch_ring_empty(const _sfetch_ring_t* rb) {\n    SOKOL_ASSERT(rb && rb->buf);\n    return rb->head == rb->tail;\n}\n\n_SOKOL_PRIVATE uint32_t _sfetch_ring_count(const _sfetch_ring_t* rb) {\n    SOKOL_ASSERT(rb && rb->buf);\n    uint32_t count;\n    if (rb->head >= rb->tail) {\n        count = rb->head - rb->tail;\n    }\n    else {\n        count = (rb->head + rb->num) - rb->tail;\n    }\n    SOKOL_ASSERT(count < rb->num);\n    return count;\n}\n\n_SOKOL_PRIVATE void _sfetch_ring_enqueue(_sfetch_ring_t* rb, uint32_t slot_id) {\n    SOKOL_ASSERT(rb && rb->buf);\n    SOKOL_ASSERT(!_sfetch_ring_full(rb));\n    SOKOL_ASSERT(rb->head < rb->num);\n    rb->buf[rb->head] = slot_id;\n    rb->head = _sfetch_ring_wrap(rb, rb->head + 1);\n}\n\n_SOKOL_PRIVATE uint32_t _sfetch_ring_dequeue(_sfetch_ring_t* rb) {\n    SOKOL_ASSERT(rb && rb->buf);\n    SOKOL_ASSERT(!_sfetch_ring_empty(rb));\n    SOKOL_ASSERT(rb->tail < rb->num);\n    uint32_t slot_id = rb->buf[rb->tail];\n    rb->tail = _sfetch_ring_wrap(rb, rb->tail + 1);\n    return slot_id;\n}\n\n_SOKOL_PRIVATE uint32_t _sfetch_ring_peek(const _sfetch_ring_t* rb, uint32_t index) {\n    SOKOL_ASSERT(rb && rb->buf);\n    SOKOL_ASSERT(!_sfetch_ring_empty(rb));\n    SOKOL_ASSERT(index < _sfetch_ring_count(rb));\n    uint32_t rb_index = _sfetch_ring_wrap(rb, rb->tail + index);\n    return rb->buf[rb_index];\n}\n\n//                           \n//                                                          \n//                                           \n//                                                          \n//                                     \n//                     \n// >>request pool\n_SOKOL_PRIVATE uint32_t _sfetch_make_id(uint32_t index, uint32_t gen_ctr) {\n    return (gen_ctr<<16) | (index & 0xFFFF);\n}\n\n_SOKOL_PRIVATE sfetch_handle_t _sfetch_make_handle(uint32_t slot_id) {\n    sfetch_handle_t h;\n    h.id = slot_id;\n    return h;\n}\n\n_SOKOL_PRIVATE uint32_t _sfetch_slot_index(uint32_t slot_id) {\n    return slot_id & 0xFFFF;\n}\n\n_SOKOL_PRIVATE void _sfetch_item_init(_sfetch_item_t* item, uint32_t slot_id, const sfetch_request_t* request) {\n    SOKOL_ASSERT(item && (0 == item->handle.id));\n    SOKOL_ASSERT(request && request->path);\n    _sfetch_clear(item, sizeof(_sfetch_item_t));\n    item->handle.id = slot_id;\n    item->state = _SFETCH_STATE_INITIAL;\n    item->channel = request->channel;\n    item->chunk_size = request->chunk_size;\n    item->lane = _SFETCH_INVALID_LANE;\n    item->callback = request->callback;\n    item->buffer = request->buffer;\n    item->path = _sfetch_path_make(request->path);\n    #if !_SFETCH_PLATFORM_EMSCRIPTEN\n    item->thread.file_handle = _SFETCH_INVALID_FILE_HANDLE;\n    #endif\n    if (request->user_data.ptr &&\n        (request->user_data.size > 0) &&\n        (request->user_data.size <= (SFETCH_MAX_USERDATA_UINT64*8)))\n    {\n        item->user.user_data_size = request->user_data.size;\n        memcpy(item->user.user_data, request->user_data.ptr, request->user_data.size);\n    }\n}\n\n_SOKOL_PRIVATE void _sfetch_item_discard(_sfetch_item_t* item) {\n    SOKOL_ASSERT(item && (0 != item->handle.id));\n    _sfetch_clear(item, sizeof(_sfetch_item_t));\n}\n\n_SOKOL_PRIVATE void _sfetch_pool_discard(_sfetch_pool_t* pool) {\n    SOKOL_ASSERT(pool);\n    if (pool->free_slots) {\n        _sfetch_free(pool->free_slots);\n        pool->free_slots = 0;\n    }\n    if (pool->gen_ctrs) {\n        _sfetch_free(pool->gen_ctrs);\n        pool->gen_ctrs = 0;\n    }\n    if (pool->items) {\n        _sfetch_free(pool->items);\n        pool->items = 0;\n    }\n    pool->size = 0;\n    pool->free_top = 0;\n    pool->valid = false;\n}\n\n_SOKOL_PRIVATE bool _sfetch_pool_init(_sfetch_pool_t* pool, uint32_t num_items) {\n    SOKOL_ASSERT(pool && (num_items > 0) && (num_items < ((1<<16)-1)));\n    SOKOL_ASSERT(0 == pool->items);\n    /* NOTE: item slot 0 is reserved for the special \"invalid\" item index 0*/\n    pool->size = num_items + 1;\n    pool->free_top = 0;\n    const size_t items_size = pool->size * sizeof(_sfetch_item_t);\n    pool->items = (_sfetch_item_t*) _sfetch_malloc_clear(items_size);\n    /* generation counters indexable by pool slot index, slot 0 is reserved */\n    const size_t gen_ctrs_size = sizeof(uint32_t) * pool->size;\n    pool->gen_ctrs = (uint32_t*) _sfetch_malloc_clear(gen_ctrs_size);\n    SOKOL_ASSERT(pool->gen_ctrs);\n    /* NOTE: it's not a bug to only reserve num_items here */\n    const size_t free_slots_size = num_items * sizeof(int);\n    pool->free_slots = (uint32_t*) _sfetch_malloc_clear(free_slots_size);\n    if (pool->items && pool->free_slots) {\n        /* never allocate the 0-th item, this is the reserved 'invalid item' */\n        for (uint32_t i = pool->size - 1; i >= 1; i--) {\n            pool->free_slots[pool->free_top++] = i;\n        }\n        pool->valid = true;\n    }\n    else {\n        /* allocation error */\n        _sfetch_pool_discard(pool);\n    }\n    return pool->valid;\n}\n\n_SOKOL_PRIVATE uint32_t _sfetch_pool_item_alloc(_sfetch_pool_t* pool, const sfetch_request_t* request) {\n    SOKOL_ASSERT(pool && pool->valid);\n    if (pool->free_top > 0) {\n        uint32_t slot_index = pool->free_slots[--pool->free_top];\n        SOKOL_ASSERT((slot_index > 0) && (slot_index < pool->size));\n        uint32_t slot_id = _sfetch_make_id(slot_index, ++pool->gen_ctrs[slot_index]);\n        _sfetch_item_init(&pool->items[slot_index], slot_id, request);\n        pool->items[slot_index].state = _SFETCH_STATE_ALLOCATED;\n        return slot_id;\n    }\n    else {\n        /* pool exhausted, return the 'invalid handle' */\n        return _sfetch_make_id(0, 0);\n    }\n}\n\n_SOKOL_PRIVATE void _sfetch_pool_item_free(_sfetch_pool_t* pool, uint32_t slot_id) {\n    SOKOL_ASSERT(pool && pool->valid);\n    uint32_t slot_index = _sfetch_slot_index(slot_id);\n    SOKOL_ASSERT((slot_index > 0) && (slot_index < pool->size));\n    SOKOL_ASSERT(pool->items[slot_index].handle.id == slot_id);\n    #if defined(SOKOL_DEBUG)\n    /* debug check against double-free */\n    for (uint32_t i = 0; i < pool->free_top; i++) {\n        SOKOL_ASSERT(pool->free_slots[i] != slot_index);\n    }\n    #endif\n    _sfetch_item_discard(&pool->items[slot_index]);\n    pool->free_slots[pool->free_top++] = slot_index;\n    SOKOL_ASSERT(pool->free_top <= (pool->size - 1));\n}\n\n/* return pointer to item by handle without matching id check */\n_SOKOL_PRIVATE _sfetch_item_t* _sfetch_pool_item_at(_sfetch_pool_t* pool, uint32_t slot_id) {\n    SOKOL_ASSERT(pool && pool->valid);\n    uint32_t slot_index = _sfetch_slot_index(slot_id);\n    SOKOL_ASSERT((slot_index > 0) && (slot_index < pool->size));\n    return &pool->items[slot_index];\n}\n\n/* return pointer to item by handle with matching id check */\n_SOKOL_PRIVATE _sfetch_item_t* _sfetch_pool_item_lookup(_sfetch_pool_t* pool, uint32_t slot_id) {\n    SOKOL_ASSERT(pool && pool->valid);\n    if (0 != slot_id) {\n        _sfetch_item_t* item = _sfetch_pool_item_at(pool, slot_id);\n        if (item->handle.id == slot_id) {\n            return item;\n        }\n    }\n    return 0;\n}\n\n//           \n//                   \n//            \n//                     \n//               \n//\n// >>posix\n#if _SFETCH_PLATFORM_POSIX\n_SOKOL_PRIVATE _sfetch_file_handle_t _sfetch_file_open(const _sfetch_path_t* path) {\n    return fopen(path->buf, \"rb\");\n}\n\n_SOKOL_PRIVATE void _sfetch_file_close(_sfetch_file_handle_t h) {\n    fclose(h);\n}\n\n_SOKOL_PRIVATE bool _sfetch_file_handle_valid(_sfetch_file_handle_t h) {\n    return h != _SFETCH_INVALID_FILE_HANDLE;\n}\n\n_SOKOL_PRIVATE uint32_t _sfetch_file_size(_sfetch_file_handle_t h) {\n    fseek(h, 0, SEEK_END);\n    return (uint32_t) ftell(h);\n}\n\n_SOKOL_PRIVATE bool _sfetch_file_read(_sfetch_file_handle_t h, uint32_t offset, uint32_t num_bytes, void* ptr) {\n    fseek(h, (long)offset, SEEK_SET);\n    return num_bytes == fread(ptr, 1, num_bytes, h);\n}\n\n_SOKOL_PRIVATE bool _sfetch_thread_init(_sfetch_thread_t* thread, _sfetch_thread_func_t thread_func, void* thread_arg) {\n    SOKOL_ASSERT(thread && !thread->valid && !thread->stop_requested);\n\n    pthread_mutexattr_t attr;\n    pthread_mutexattr_init(&attr);\n    pthread_mutex_init(&thread->incoming_mutex, &attr);\n    pthread_mutexattr_destroy(&attr);\n\n    pthread_mutexattr_init(&attr);\n    pthread_mutex_init(&thread->outgoing_mutex, &attr);\n    pthread_mutexattr_destroy(&attr);\n\n    pthread_mutexattr_init(&attr);\n    pthread_mutex_init(&thread->running_mutex, &attr);\n    pthread_mutexattr_destroy(&attr);\n\n    pthread_mutexattr_init(&attr);\n    pthread_mutex_init(&thread->stop_mutex, &attr);\n    pthread_mutexattr_destroy(&attr);\n\n    pthread_condattr_t cond_attr;\n    pthread_condattr_init(&cond_attr);\n    pthread_cond_init(&thread->incoming_cond, &cond_attr);\n    pthread_condattr_destroy(&cond_attr);\n\n    /* FIXME: in debug mode, the threads should be named */\n    pthread_mutex_lock(&thread->running_mutex);\n    int res = pthread_create(&thread->thread, 0, thread_func, thread_arg);\n    thread->valid = (0 == res);\n    pthread_mutex_unlock(&thread->running_mutex);\n    return thread->valid;\n}\n\n_SOKOL_PRIVATE void _sfetch_thread_request_stop(_sfetch_thread_t* thread) {\n    pthread_mutex_lock(&thread->stop_mutex);\n    thread->stop_requested = true;\n    pthread_mutex_unlock(&thread->stop_mutex);\n}\n\n_SOKOL_PRIVATE bool _sfetch_thread_stop_requested(_sfetch_thread_t* thread) {\n    pthread_mutex_lock(&thread->stop_mutex);\n    bool stop_requested = thread->stop_requested;\n    pthread_mutex_unlock(&thread->stop_mutex);\n    return stop_requested;\n}\n\n_SOKOL_PRIVATE void _sfetch_thread_join(_sfetch_thread_t* thread) {\n    SOKOL_ASSERT(thread);\n    if (thread->valid) {\n        pthread_mutex_lock(&thread->incoming_mutex);\n        _sfetch_thread_request_stop(thread);\n        pthread_cond_signal(&thread->incoming_cond);\n        pthread_mutex_unlock(&thread->incoming_mutex);\n        pthread_join(thread->thread, 0);\n        thread->valid = false;\n    }\n    pthread_mutex_destroy(&thread->stop_mutex);\n    pthread_mutex_destroy(&thread->running_mutex);\n    pthread_mutex_destroy(&thread->incoming_mutex);\n    pthread_mutex_destroy(&thread->outgoing_mutex);\n    pthread_cond_destroy(&thread->incoming_cond);\n}\n\n/* called when the thread-func is entered, this blocks the thread func until\n   the _sfetch_thread_t object is fully initialized\n*/\n_SOKOL_PRIVATE void _sfetch_thread_entered(_sfetch_thread_t* thread) {\n    pthread_mutex_lock(&thread->running_mutex);\n}\n\n/* called by the thread-func right before it is left */\n_SOKOL_PRIVATE void _sfetch_thread_leaving(_sfetch_thread_t* thread) {\n    pthread_mutex_unlock(&thread->running_mutex);\n}\n\n_SOKOL_PRIVATE void _sfetch_thread_enqueue_incoming(_sfetch_thread_t* thread, _sfetch_ring_t* incoming, _sfetch_ring_t* src) {\n    /* called from user thread */\n    SOKOL_ASSERT(thread && thread->valid);\n    SOKOL_ASSERT(incoming && incoming->buf);\n    SOKOL_ASSERT(src && src->buf);\n    if (!_sfetch_ring_empty(src)) {\n        pthread_mutex_lock(&thread->incoming_mutex);\n        while (!_sfetch_ring_full(incoming) && !_sfetch_ring_empty(src)) {\n            _sfetch_ring_enqueue(incoming, _sfetch_ring_dequeue(src));\n        }\n        pthread_cond_signal(&thread->incoming_cond);\n        pthread_mutex_unlock(&thread->incoming_mutex);\n    }\n}\n\n_SOKOL_PRIVATE uint32_t _sfetch_thread_dequeue_incoming(_sfetch_thread_t* thread, _sfetch_ring_t* incoming) {\n    /* called from thread function */\n    SOKOL_ASSERT(thread && thread->valid);\n    SOKOL_ASSERT(incoming && incoming->buf);\n    pthread_mutex_lock(&thread->incoming_mutex);\n    while (_sfetch_ring_empty(incoming) && !thread->stop_requested) {\n        pthread_cond_wait(&thread->incoming_cond, &thread->incoming_mutex);\n    }\n    uint32_t item = 0;\n    if (!thread->stop_requested) {\n        item = _sfetch_ring_dequeue(incoming);\n    }\n    pthread_mutex_unlock(&thread->incoming_mutex);\n    return item;\n}\n\n_SOKOL_PRIVATE bool _sfetch_thread_enqueue_outgoing(_sfetch_thread_t* thread, _sfetch_ring_t* outgoing, uint32_t item) {\n    /* called from thread function */\n    SOKOL_ASSERT(thread && thread->valid);\n    SOKOL_ASSERT(outgoing && outgoing->buf);\n    SOKOL_ASSERT(0 != item);\n    pthread_mutex_lock(&thread->outgoing_mutex);\n    bool result = false;\n    if (!_sfetch_ring_full(outgoing)) {\n        _sfetch_ring_enqueue(outgoing, item);\n    }\n    pthread_mutex_unlock(&thread->outgoing_mutex);\n    return result;\n}\n\n_SOKOL_PRIVATE void _sfetch_thread_dequeue_outgoing(_sfetch_thread_t* thread, _sfetch_ring_t* outgoing, _sfetch_ring_t* dst) {\n    /* called from user thread */\n    SOKOL_ASSERT(thread && thread->valid);\n    SOKOL_ASSERT(outgoing && outgoing->buf);\n    SOKOL_ASSERT(dst && dst->buf);\n    pthread_mutex_lock(&thread->outgoing_mutex);\n    while (!_sfetch_ring_full(dst) && !_sfetch_ring_empty(outgoing)) {\n        _sfetch_ring_enqueue(dst, _sfetch_ring_dequeue(outgoing));\n    }\n    pthread_mutex_unlock(&thread->outgoing_mutex);\n}\n#endif /* _SFETCH_PLATFORM_POSIX */\n\n//                        \n//                           \n//                         \n//                          \n//                   \n//\n// >>windows\n#if _SFETCH_PLATFORM_WINDOWS\n_SOKOL_PRIVATE bool _sfetch_win32_utf8_to_wide(const char* src, wchar_t* dst, int dst_num_bytes) {\n    SOKOL_ASSERT(src && dst && (dst_num_bytes > 1));\n    _sfetch_clear(dst, (size_t)dst_num_bytes);\n    const int dst_chars = dst_num_bytes / (int)sizeof(wchar_t);\n    const int dst_needed = MultiByteToWideChar(CP_UTF8, 0, src, -1, 0, 0);\n    if ((dst_needed > 0) && (dst_needed < dst_chars)) {\n        MultiByteToWideChar(CP_UTF8, 0, src, -1, dst, dst_chars);\n        return true;\n    }\n    else {\n        /* input string doesn't fit into destination buffer */\n        return false;\n    }\n}\n\n_SOKOL_PRIVATE _sfetch_file_handle_t _sfetch_file_open(const _sfetch_path_t* path) {\n    wchar_t w_path[SFETCH_MAX_PATH];\n    if (!_sfetch_win32_utf8_to_wide(path->buf, w_path, sizeof(w_path))) {\n        _SFETCH_ERROR(FILE_PATH_UTF8_DECODING_FAILED);\n        return 0;\n    }\n    _sfetch_file_handle_t h = CreateFileW(\n        w_path,                 /* lpFileName */\n        GENERIC_READ,           /* dwDesiredAccess */\n        FILE_SHARE_READ,        /* dwShareMode */\n        NULL,                   /* lpSecurityAttributes */\n        OPEN_EXISTING,          /* dwCreationDisposition */\n        FILE_ATTRIBUTE_NORMAL|FILE_FLAG_SEQUENTIAL_SCAN,    /* dwFlagsAndAttributes */\n        NULL);                  /* hTemplateFile */\n    return h;\n}\n\n_SOKOL_PRIVATE void _sfetch_file_close(_sfetch_file_handle_t h) {\n    CloseHandle(h);\n}\n\n_SOKOL_PRIVATE bool _sfetch_file_handle_valid(_sfetch_file_handle_t h) {\n    return h != _SFETCH_INVALID_FILE_HANDLE;\n}\n\n_SOKOL_PRIVATE uint32_t _sfetch_file_size(_sfetch_file_handle_t h) {\n    return GetFileSize(h, NULL);\n}\n\n_SOKOL_PRIVATE bool _sfetch_file_read(_sfetch_file_handle_t h, uint32_t offset, uint32_t num_bytes, void* ptr) {\n    LARGE_INTEGER offset_li;\n    offset_li.QuadPart = offset;\n    BOOL seek_res = SetFilePointerEx(h, offset_li, NULL, FILE_BEGIN);\n    if (seek_res) {\n        DWORD bytes_read = 0;\n        BOOL read_res = ReadFile(h, ptr, (DWORD)num_bytes, &bytes_read, NULL);\n        return read_res && (bytes_read == num_bytes);\n    }\n    else {\n        return false;\n    }\n}\n\n_SOKOL_PRIVATE bool _sfetch_thread_init(_sfetch_thread_t* thread, _sfetch_thread_func_t thread_func, void* thread_arg) {\n    SOKOL_ASSERT(thread && !thread->valid && !thread->stop_requested);\n\n    thread->incoming_event = CreateEventA(NULL, FALSE, FALSE, NULL);\n    SOKOL_ASSERT(NULL != thread->incoming_event);\n    InitializeCriticalSection(&thread->incoming_critsec);\n    InitializeCriticalSection(&thread->outgoing_critsec);\n    InitializeCriticalSection(&thread->running_critsec);\n    InitializeCriticalSection(&thread->stop_critsec);\n\n    EnterCriticalSection(&thread->running_critsec);\n    const SIZE_T stack_size = 512 * 1024;\n    thread->thread = CreateThread(NULL, stack_size, thread_func, thread_arg, 0, NULL);\n    thread->valid = (NULL != thread->thread);\n    LeaveCriticalSection(&thread->running_critsec);\n    return thread->valid;\n}\n\n_SOKOL_PRIVATE void _sfetch_thread_request_stop(_sfetch_thread_t* thread) {\n    EnterCriticalSection(&thread->stop_critsec);\n    thread->stop_requested = true;\n    LeaveCriticalSection(&thread->stop_critsec);\n}\n\n_SOKOL_PRIVATE bool _sfetch_thread_stop_requested(_sfetch_thread_t* thread) {\n    EnterCriticalSection(&thread->stop_critsec);\n    bool stop_requested = thread->stop_requested;\n    LeaveCriticalSection(&thread->stop_critsec);\n    return stop_requested;\n}\n\n_SOKOL_PRIVATE void _sfetch_thread_join(_sfetch_thread_t* thread) {\n    if (thread->valid) {\n        EnterCriticalSection(&thread->incoming_critsec);\n        _sfetch_thread_request_stop(thread);\n        BOOL set_event_res = SetEvent(thread->incoming_event);\n        _SOKOL_UNUSED(set_event_res);\n        SOKOL_ASSERT(set_event_res);\n        LeaveCriticalSection(&thread->incoming_critsec);\n        WaitForSingleObject(thread->thread, INFINITE);\n        CloseHandle(thread->thread);\n        thread->valid = false;\n    }\n    CloseHandle(thread->incoming_event);\n    DeleteCriticalSection(&thread->stop_critsec);\n    DeleteCriticalSection(&thread->running_critsec);\n    DeleteCriticalSection(&thread->outgoing_critsec);\n    DeleteCriticalSection(&thread->incoming_critsec);\n}\n\n_SOKOL_PRIVATE void _sfetch_thread_entered(_sfetch_thread_t* thread) {\n    EnterCriticalSection(&thread->running_critsec);\n}\n\n/* called by the thread-func right before it is left */\n_SOKOL_PRIVATE void _sfetch_thread_leaving(_sfetch_thread_t* thread) {\n    LeaveCriticalSection(&thread->running_critsec);\n}\n\n_SOKOL_PRIVATE void _sfetch_thread_enqueue_incoming(_sfetch_thread_t* thread, _sfetch_ring_t* incoming, _sfetch_ring_t* src) {\n    /* called from user thread */\n    SOKOL_ASSERT(thread && thread->valid);\n    SOKOL_ASSERT(incoming && incoming->buf);\n    SOKOL_ASSERT(src && src->buf);\n    if (!_sfetch_ring_empty(src)) {\n        EnterCriticalSection(&thread->incoming_critsec);\n        while (!_sfetch_ring_full(incoming) && !_sfetch_ring_empty(src)) {\n            _sfetch_ring_enqueue(incoming, _sfetch_ring_dequeue(src));\n        }\n        LeaveCriticalSection(&thread->incoming_critsec);\n        BOOL set_event_res = SetEvent(thread->incoming_event);\n        _SOKOL_UNUSED(set_event_res);\n        SOKOL_ASSERT(set_event_res);\n    }\n}\n\n_SOKOL_PRIVATE uint32_t _sfetch_thread_dequeue_incoming(_sfetch_thread_t* thread, _sfetch_ring_t* incoming) {\n    /* called from thread function */\n    SOKOL_ASSERT(thread && thread->valid);\n    SOKOL_ASSERT(incoming && incoming->buf);\n    EnterCriticalSection(&thread->incoming_critsec);\n    while (_sfetch_ring_empty(incoming) && !thread->stop_requested) {\n        LeaveCriticalSection(&thread->incoming_critsec);\n        WaitForSingleObject(thread->incoming_event, INFINITE);\n        EnterCriticalSection(&thread->incoming_critsec);\n    }\n    uint32_t item = 0;\n    if (!thread->stop_requested) {\n        item = _sfetch_ring_dequeue(incoming);\n    }\n    LeaveCriticalSection(&thread->incoming_critsec);\n    return item;\n}\n\n_SOKOL_PRIVATE bool _sfetch_thread_enqueue_outgoing(_sfetch_thread_t* thread, _sfetch_ring_t* outgoing, uint32_t item) {\n    /* called from thread function */\n    SOKOL_ASSERT(thread && thread->valid);\n    SOKOL_ASSERT(outgoing && outgoing->buf);\n    EnterCriticalSection(&thread->outgoing_critsec);\n    bool result = false;\n    if (!_sfetch_ring_full(outgoing)) {\n        _sfetch_ring_enqueue(outgoing, item);\n    }\n    LeaveCriticalSection(&thread->outgoing_critsec);\n    return result;\n}\n\n_SOKOL_PRIVATE void _sfetch_thread_dequeue_outgoing(_sfetch_thread_t* thread, _sfetch_ring_t* outgoing, _sfetch_ring_t* dst) {\n    /* called from user thread */\n    SOKOL_ASSERT(thread && thread->valid);\n    SOKOL_ASSERT(outgoing && outgoing->buf);\n    SOKOL_ASSERT(dst && dst->buf);\n    EnterCriticalSection(&thread->outgoing_critsec);\n    while (!_sfetch_ring_full(dst) && !_sfetch_ring_empty(outgoing)) {\n        _sfetch_ring_enqueue(dst, _sfetch_ring_dequeue(outgoing));\n    }\n    LeaveCriticalSection(&thread->outgoing_critsec);\n}\n#endif /* _SFETCH_PLATFORM_WINDOWS */\n\n//                           \n//                                   \n//                          \n//                                        \n//                     \n//\n// >>channels\n\n/* per-channel request handler for native platforms accessing the local filesystem */\n#if _SFETCH_HAS_THREADS\n_SOKOL_PRIVATE void _sfetch_request_handler(_sfetch_t* ctx, uint32_t slot_id) {\n    _sfetch_state_t state;\n    _sfetch_path_t* path;\n    _sfetch_item_thread_t* thread;\n    sfetch_range_t* buffer;\n    uint32_t chunk_size;\n    {\n        _sfetch_item_t* item = _sfetch_pool_item_lookup(&ctx->pool, slot_id);\n        if (!item) {\n            return;\n        }\n        state = item->state;\n        SOKOL_ASSERT((state == _SFETCH_STATE_FETCHING) ||\n                     (state == _SFETCH_STATE_PAUSED) ||\n                     (state == _SFETCH_STATE_FAILED));\n        path = &item->path;\n        thread = &item->thread;\n        buffer = &item->buffer;\n        chunk_size = item->chunk_size;\n    }\n    if (thread->failed) {\n        return;\n    }\n    if (state == _SFETCH_STATE_FETCHING) {\n        if ((buffer->ptr == 0) || (buffer->size == 0)) {\n            thread->error_code = SFETCH_ERROR_NO_BUFFER;\n            thread->failed = true;\n        }\n        else {\n            /* open file if not happened yet */\n            if (!_sfetch_file_handle_valid(thread->file_handle)) {\n                SOKOL_ASSERT(path->buf[0]);\n                SOKOL_ASSERT(thread->fetched_offset == 0);\n                SOKOL_ASSERT(thread->fetched_size == 0);\n                thread->file_handle = _sfetch_file_open(path);\n                if (_sfetch_file_handle_valid(thread->file_handle)) {\n                    thread->content_size = _sfetch_file_size(thread->file_handle);\n                }\n                else {\n                    thread->error_code = SFETCH_ERROR_FILE_NOT_FOUND;\n                    thread->failed = true;\n                }\n            }\n            if (!thread->failed) {\n                uint32_t read_offset = 0;\n                uint32_t bytes_to_read = 0;\n                if (chunk_size == 0) {\n                    /* load entire file */\n                    if (thread->content_size <= buffer->size) {\n                        bytes_to_read = thread->content_size;\n                        read_offset = 0;\n                    }\n                    else {\n                        /* provided buffer to small to fit entire file */\n                        thread->error_code = SFETCH_ERROR_BUFFER_TOO_SMALL;\n                        thread->failed = true;\n                    }\n                }\n                else {\n                    if (chunk_size <= buffer->size) {\n                        bytes_to_read = chunk_size;\n                        read_offset = thread->fetched_offset;\n                        if ((read_offset + bytes_to_read) > thread->content_size) {\n                            bytes_to_read = thread->content_size - read_offset;\n                        }\n                    }\n                    else {\n                        /* provided buffer to small to fit next chunk */\n                        thread->error_code = SFETCH_ERROR_BUFFER_TOO_SMALL;\n                        thread->failed = true;\n                    }\n                }\n                if (!thread->failed) {\n                    if (_sfetch_file_read(thread->file_handle, read_offset, bytes_to_read, (void*)buffer->ptr)) {\n                        thread->fetched_size = bytes_to_read;\n                        thread->fetched_offset += bytes_to_read;\n                    }\n                    else {\n                        thread->error_code = SFETCH_ERROR_UNEXPECTED_EOF;\n                        thread->failed = true;\n                    }\n                }\n            }\n        }\n        SOKOL_ASSERT(thread->fetched_offset <= thread->content_size);\n        if (thread->failed || (thread->fetched_offset == thread->content_size)) {\n            if (_sfetch_file_handle_valid(thread->file_handle)) {\n                _sfetch_file_close(thread->file_handle);\n                thread->file_handle = _SFETCH_INVALID_FILE_HANDLE;\n            }\n            thread->finished = true;\n        }\n    }\n    /* ignore items in PAUSED or FAILED state */\n}\n\n#if _SFETCH_PLATFORM_WINDOWS\n_SOKOL_PRIVATE DWORD WINAPI _sfetch_channel_thread_func(LPVOID arg) {\n#else\n_SOKOL_PRIVATE void* _sfetch_channel_thread_func(void* arg) {\n#endif\n    _sfetch_channel_t* chn = (_sfetch_channel_t*) arg;\n    _sfetch_thread_entered(&chn->thread);\n    while (!_sfetch_thread_stop_requested(&chn->thread)) {\n        /* block until work arrives */\n        uint32_t slot_id = _sfetch_thread_dequeue_incoming(&chn->thread, &chn->thread_incoming);\n        /* slot_id will be invalid if the thread was woken up to join */\n        if (!_sfetch_thread_stop_requested(&chn->thread)) {\n            SOKOL_ASSERT(0 != slot_id);\n            chn->request_handler(chn->ctx, slot_id);\n            SOKOL_ASSERT(!_sfetch_ring_full(&chn->thread_outgoing));\n            _sfetch_thread_enqueue_outgoing(&chn->thread, &chn->thread_outgoing, slot_id);\n        }\n    }\n    _sfetch_thread_leaving(&chn->thread);\n    return 0;\n}\n#endif /* _SFETCH_HAS_THREADS */\n\n#if _SFETCH_PLATFORM_EMSCRIPTEN\nEM_JS(void, sfetch_js_send_head_request, (uint32_t slot_id, const char* path_cstr), {\n    const path_str = UTF8ToString(path_cstr);\n    const req = new XMLHttpRequest();\n    req.open('HEAD', path_str);\n    req.onreadystatechange = function() {\n        if (req.readyState == XMLHttpRequest.DONE) {\n            if (req.status == 200) {\n                const content_length = req.getResponseHeader('Content-Length');\n                __sfetch_emsc_head_response(slot_id, content_length);\n            }\n            else {\n                __sfetch_emsc_failed_http_status(slot_id, req.status);\n            }\n        }\n    };\n    req.send();\n});\n\n/* if bytes_to_read != 0, a range-request will be sent, otherwise a normal request */\nEM_JS(void, sfetch_js_send_get_request, (uint32_t slot_id, const char* path_cstr, uint32_t offset, uint32_t bytes_to_read, void* buf_ptr, uint32_t buf_size), {\n    const path_str = UTF8ToString(path_cstr);\n    const req = new XMLHttpRequest();\n    req.open('GET', path_str);\n    req.responseType = 'arraybuffer';\n    const need_range_request = (bytes_to_read > 0);\n    if (need_range_request) {\n        req.setRequestHeader('Range', 'bytes='+offset+'-'+(offset+bytes_to_read-1));\n    }\n    req.onreadystatechange = function() {\n        if (req.readyState == XMLHttpRequest.DONE) {\n            if ((req.status == 206) || ((req.status == 200) && !need_range_request)) {\n                const u8_array = new Uint8Array(\\x2F\\x2A\\x2A @type {!ArrayBuffer} \\x2A\\x2F (req.response));\n                const content_fetched_size = u8_array.length;\n                if (content_fetched_size <= buf_size) {\n                    HEAPU8.set(u8_array, buf_ptr);\n                    __sfetch_emsc_get_response(slot_id, bytes_to_read, content_fetched_size);\n                }\n                else {\n                    __sfetch_emsc_failed_buffer_too_small(slot_id);\n                }\n            }\n            else {\n                __sfetch_emsc_failed_http_status(slot_id, req.status);\n            }\n        }\n    };\n    req.send();\n});\n\n/*=== emscripten specific C helper functions =================================*/\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nvoid _sfetch_emsc_send_get_request(uint32_t slot_id, _sfetch_item_t* item) {\n    if ((item->buffer.ptr == 0) || (item->buffer.size == 0)) {\n        item->thread.error_code = SFETCH_ERROR_NO_BUFFER;\n        item->thread.failed = true;\n    }\n    else {\n        uint32_t offset = 0;\n        uint32_t bytes_to_read = 0;\n        if (item->chunk_size > 0) {\n            /* send HTTP range request */\n            SOKOL_ASSERT(item->thread.content_size > 0);\n            SOKOL_ASSERT(item->thread.http_range_offset < item->thread.content_size);\n            bytes_to_read = item->thread.content_size - item->thread.http_range_offset;\n            if (bytes_to_read > item->chunk_size) {\n                bytes_to_read = item->chunk_size;\n            }\n            SOKOL_ASSERT(bytes_to_read > 0);\n            offset = item->thread.http_range_offset;\n        }\n        sfetch_js_send_get_request(slot_id, item->path.buf, offset, bytes_to_read, (void*)item->buffer.ptr, item->buffer.size);\n    }\n}\n\n/* called by JS when an initial HEAD request finished successfully (only when streaming chunks) */\nEMSCRIPTEN_KEEPALIVE void _sfetch_emsc_head_response(uint32_t slot_id, uint32_t content_length) {\n    _sfetch_t* ctx = _sfetch_ctx();\n    if (ctx && ctx->valid) {\n        _sfetch_item_t* item = _sfetch_pool_item_lookup(&ctx->pool, slot_id);\n        if (item) {\n            SOKOL_ASSERT(item->buffer.ptr && (item->buffer.size > 0));\n            item->thread.content_size = content_length;\n            _sfetch_emsc_send_get_request(slot_id, item);\n        }\n    }\n}\n\n/* called by JS when a followup GET request finished successfully */\nEMSCRIPTEN_KEEPALIVE void _sfetch_emsc_get_response(uint32_t slot_id, uint32_t range_fetched_size, uint32_t content_fetched_size) {\n    _sfetch_t* ctx = _sfetch_ctx();\n    if (ctx && ctx->valid) {\n        _sfetch_item_t* item = _sfetch_pool_item_lookup(&ctx->pool, slot_id);\n        if (item) {\n            item->thread.fetched_size = content_fetched_size;\n            item->thread.fetched_offset += content_fetched_size;\n            item->thread.http_range_offset += range_fetched_size;\n            if (item->chunk_size == 0) {\n                item->thread.finished = true;\n            }\n            else if (item->thread.http_range_offset >= item->thread.content_size) {\n                item->thread.finished = true;\n            }\n            _sfetch_ring_enqueue(&ctx->chn[item->channel].user_outgoing, slot_id);\n        }\n    }\n}\n\n/* called by JS when an error occurred */\nEMSCRIPTEN_KEEPALIVE void _sfetch_emsc_failed_http_status(uint32_t slot_id, uint32_t http_status) {\n    _sfetch_t* ctx = _sfetch_ctx();\n    if (ctx && ctx->valid) {\n        _sfetch_item_t* item = _sfetch_pool_item_lookup(&ctx->pool, slot_id);\n        if (item) {\n            if (http_status == 404) {\n                item->thread.error_code = SFETCH_ERROR_FILE_NOT_FOUND;\n            }\n            else {\n                item->thread.error_code = SFETCH_ERROR_INVALID_HTTP_STATUS;\n            }\n            item->thread.failed = true;\n            item->thread.finished = true;\n            _sfetch_ring_enqueue(&ctx->chn[item->channel].user_outgoing, slot_id);\n        }\n    }\n}\n\nEMSCRIPTEN_KEEPALIVE void _sfetch_emsc_failed_buffer_too_small(uint32_t slot_id) {\n    _sfetch_t* ctx = _sfetch_ctx();\n    if (ctx && ctx->valid) {\n        _sfetch_item_t* item = _sfetch_pool_item_lookup(&ctx->pool, slot_id);\n        if (item) {\n            item->thread.error_code = SFETCH_ERROR_BUFFER_TOO_SMALL;\n            item->thread.failed = true;\n            item->thread.finished = true;\n            _sfetch_ring_enqueue(&ctx->chn[item->channel].user_outgoing, slot_id);\n        }\n    }\n}\n\n#ifdef __cplusplus\n} /* extern \"C\" */\n#endif\n\n_SOKOL_PRIVATE void _sfetch_request_handler(_sfetch_t* ctx, uint32_t slot_id) {\n    _sfetch_item_t* item = _sfetch_pool_item_lookup(&ctx->pool, slot_id);\n    if (!item) {\n        return;\n    }\n    if (item->state == _SFETCH_STATE_FETCHING) {\n        if ((item->chunk_size > 0) && (item->thread.content_size == 0)) {\n            /* if streaming download is requested, and the content-length isn't known\n               yet, need to send a HEAD request first\n             */\n            sfetch_js_send_head_request(slot_id, item->path.buf);\n        }\n        else {\n            /* otherwise, this is either a request to load the entire file, or\n               to load the next streaming chunk\n             */\n            _sfetch_emsc_send_get_request(slot_id, item);\n        }\n    }\n    else {\n        /* just move all other items (e.g. paused or cancelled)\n           into the outgoing queue, so they won't get lost\n        */\n        _sfetch_ring_enqueue(&ctx->chn[item->channel].user_outgoing, slot_id);\n    }\n    if (item->thread.failed) {\n        item->thread.finished = true;\n    }\n}\n#endif /* _SFETCH_PLATFORM_EMSCRIPTEN */\n\n_SOKOL_PRIVATE void _sfetch_channel_discard(_sfetch_channel_t* chn) {\n    SOKOL_ASSERT(chn);\n    #if _SFETCH_HAS_THREADS\n        if (chn->valid) {\n            _sfetch_thread_join(&chn->thread);\n        }\n        _sfetch_ring_discard(&chn->thread_incoming);\n        _sfetch_ring_discard(&chn->thread_outgoing);\n    #endif\n    _sfetch_ring_discard(&chn->free_lanes);\n    _sfetch_ring_discard(&chn->user_sent);\n    _sfetch_ring_discard(&chn->user_incoming);\n    _sfetch_ring_discard(&chn->user_outgoing);\n    _sfetch_ring_discard(&chn->free_lanes);\n    chn->valid = false;\n}\n\n_SOKOL_PRIVATE bool _sfetch_channel_init(_sfetch_channel_t* chn, _sfetch_t* ctx, uint32_t num_items, uint32_t num_lanes, void (*request_handler)(_sfetch_t* ctx, uint32_t)) {\n    SOKOL_ASSERT(chn && (num_items > 0) && request_handler);\n    SOKOL_ASSERT(!chn->valid);\n    bool valid = true;\n    chn->request_handler = request_handler;\n    chn->ctx = ctx;\n    valid &= _sfetch_ring_init(&chn->free_lanes, num_lanes);\n    for (uint32_t lane = 0; lane < num_lanes; lane++) {\n        _sfetch_ring_enqueue(&chn->free_lanes, lane);\n    }\n    valid &= _sfetch_ring_init(&chn->user_sent, num_items);\n    valid &= _sfetch_ring_init(&chn->user_incoming, num_lanes);\n    valid &= _sfetch_ring_init(&chn->user_outgoing, num_lanes);\n    #if _SFETCH_HAS_THREADS\n        valid &= _sfetch_ring_init(&chn->thread_incoming, num_lanes);\n        valid &= _sfetch_ring_init(&chn->thread_outgoing, num_lanes);\n    #endif\n    if (valid) {\n        chn->valid = true;\n        #if _SFETCH_HAS_THREADS\n        _sfetch_thread_init(&chn->thread, _sfetch_channel_thread_func, chn);\n        #endif\n        return true;\n    }\n    else {\n        _sfetch_channel_discard(chn);\n        return false;\n    }\n}\n\n/* put a request into the channels sent-queue, this is where all new requests\n   are stored until a lane becomes free.\n*/\n_SOKOL_PRIVATE bool _sfetch_channel_send(_sfetch_channel_t* chn, uint32_t slot_id) {\n    SOKOL_ASSERT(chn && chn->valid);\n    if (!_sfetch_ring_full(&chn->user_sent)) {\n        _sfetch_ring_enqueue(&chn->user_sent, slot_id);\n        return true;\n    }\n    else {\n        _SFETCH_ERROR(SEND_QUEUE_FULL);\n        return false;\n    }\n}\n\n_SOKOL_PRIVATE void _sfetch_invoke_response_callback(_sfetch_item_t* item) {\n    sfetch_response_t response;\n    _sfetch_clear(&response, sizeof(response));\n    response.handle = item->handle;\n    response.dispatched = (item->state == _SFETCH_STATE_DISPATCHED);\n    response.fetched = (item->state == _SFETCH_STATE_FETCHED);\n    response.paused = (item->state == _SFETCH_STATE_PAUSED);\n    response.finished = item->user.finished;\n    response.failed = (item->state == _SFETCH_STATE_FAILED);\n    response.cancelled = item->user.cancel;\n    response.error_code = item->user.error_code;\n    response.channel = item->channel;\n    response.lane = item->lane;\n    response.path = item->path.buf;\n    response.user_data = item->user.user_data;\n    response.data_offset = item->user.fetched_offset - item->user.fetched_size;\n    response.data.ptr = item->buffer.ptr;\n    response.data.size = item->user.fetched_size;\n    response.buffer = item->buffer;\n    item->callback(&response);\n}\n\n_SOKOL_PRIVATE void _sfetch_cancel_item(_sfetch_item_t* item) {\n    item->state = _SFETCH_STATE_FAILED;\n    item->user.finished = true;\n    item->user.error_code = SFETCH_ERROR_CANCELLED;\n}\n\n/* per-frame channel stuff: move requests in and out of the IO threads, call response callbacks */\n_SOKOL_PRIVATE void _sfetch_channel_dowork(_sfetch_channel_t* chn, _sfetch_pool_t* pool) {\n\n    /* move items from sent- to incoming-queue permitting free lanes */\n    const uint32_t num_sent = _sfetch_ring_count(&chn->user_sent);\n    const uint32_t avail_lanes = _sfetch_ring_count(&chn->free_lanes);\n    const uint32_t num_move = (num_sent < avail_lanes) ? num_sent : avail_lanes;\n    for (uint32_t i = 0; i < num_move; i++) {\n        const uint32_t slot_id = _sfetch_ring_dequeue(&chn->user_sent);\n        _sfetch_item_t* item = _sfetch_pool_item_lookup(pool, slot_id);\n        SOKOL_ASSERT(item);\n        SOKOL_ASSERT(item->state == _SFETCH_STATE_ALLOCATED);\n        // if the item was cancelled early, kick it out immediately\n        if (item->user.cancel) {\n            _sfetch_cancel_item(item);\n            _sfetch_invoke_response_callback(item);\n            _sfetch_pool_item_free(pool, slot_id);\n            continue;\n        }\n        item->state = _SFETCH_STATE_DISPATCHED;\n        item->lane = _sfetch_ring_dequeue(&chn->free_lanes);\n        // if no buffer provided yet, invoke response callback to do so\n        if (0 == item->buffer.ptr) {\n            _sfetch_invoke_response_callback(item);\n        }\n        _sfetch_ring_enqueue(&chn->user_incoming, slot_id);\n    }\n\n    /* prepare incoming items for being moved into the IO thread */\n    const uint32_t num_incoming = _sfetch_ring_count(&chn->user_incoming);\n    for (uint32_t i = 0; i < num_incoming; i++) {\n        const uint32_t slot_id = _sfetch_ring_peek(&chn->user_incoming, i);\n        _sfetch_item_t* item = _sfetch_pool_item_lookup(pool, slot_id);\n        SOKOL_ASSERT(item);\n        SOKOL_ASSERT(item->state != _SFETCH_STATE_INITIAL);\n        SOKOL_ASSERT(item->state != _SFETCH_STATE_FETCHING);\n        /* transfer input params from user- to thread-data */\n        if (item->user.pause) {\n            item->state = _SFETCH_STATE_PAUSED;\n            item->user.pause = false;\n        }\n        if (item->user.cont) {\n            if (item->state == _SFETCH_STATE_PAUSED) {\n                item->state = _SFETCH_STATE_FETCHED;\n            }\n            item->user.cont = false;\n        }\n        if (item->user.cancel) {\n            _sfetch_cancel_item(item);\n        }\n        switch (item->state) {\n            case _SFETCH_STATE_DISPATCHED:\n            case _SFETCH_STATE_FETCHED:\n                item->state = _SFETCH_STATE_FETCHING;\n                break;\n            default: break;\n        }\n    }\n\n    #if _SFETCH_HAS_THREADS\n        /* move new items into the IO threads and processed items out of IO threads */\n        _sfetch_thread_enqueue_incoming(&chn->thread, &chn->thread_incoming, &chn->user_incoming);\n        _sfetch_thread_dequeue_outgoing(&chn->thread, &chn->thread_outgoing, &chn->user_outgoing);\n    #else\n        /* without threading just directly dequeue items from the user_incoming queue and\n           call the request handler, the user_outgoing queue will be filled as the\n           asynchronous HTTP requests sent by the request handler are completed\n        */\n        while (!_sfetch_ring_empty(&chn->user_incoming)) {\n            uint32_t slot_id = _sfetch_ring_dequeue(&chn->user_incoming);\n            _sfetch_request_handler(chn->ctx, slot_id);\n        }\n    #endif\n\n    /* drain the outgoing queue, prepare items for invoking the response\n       callback, and finally call the response callback, free finished items\n    */\n    while (!_sfetch_ring_empty(&chn->user_outgoing)) {\n        const uint32_t slot_id = _sfetch_ring_dequeue(&chn->user_outgoing);\n        SOKOL_ASSERT(slot_id);\n        _sfetch_item_t* item = _sfetch_pool_item_lookup(pool, slot_id);\n        SOKOL_ASSERT(item && item->callback);\n        SOKOL_ASSERT(item->state != _SFETCH_STATE_INITIAL);\n        SOKOL_ASSERT(item->state != _SFETCH_STATE_ALLOCATED);\n        SOKOL_ASSERT(item->state != _SFETCH_STATE_DISPATCHED);\n        SOKOL_ASSERT(item->state != _SFETCH_STATE_FETCHED);\n        /* transfer output params from thread- to user-data */\n        item->user.fetched_offset = item->thread.fetched_offset;\n        item->user.fetched_size = item->thread.fetched_size;\n        if (item->user.cancel) {\n            _sfetch_cancel_item(item);\n        }\n        else {\n            item->user.error_code = item->thread.error_code;\n        }\n        if (item->thread.finished) {\n            item->user.finished = true;\n        }\n        /* state transition */\n        if (item->thread.failed) {\n            item->state = _SFETCH_STATE_FAILED;\n        }\n        else if (item->state == _SFETCH_STATE_FETCHING) {\n            item->state = _SFETCH_STATE_FETCHED;\n        }\n        _sfetch_invoke_response_callback(item);\n\n        /* when the request is finished, free the lane for another request,\n           otherwise feed it back into the incoming queue\n        */\n        if (item->user.finished) {\n            _sfetch_ring_enqueue(&chn->free_lanes, item->lane);\n            _sfetch_pool_item_free(pool, slot_id);\n        }\n        else {\n            _sfetch_ring_enqueue(&chn->user_incoming, slot_id);\n        }\n    }\n}\n\n_SOKOL_PRIVATE bool _sfetch_validate_request(_sfetch_t* ctx, const sfetch_request_t* req) {\n    if (req->channel >= ctx->desc.num_channels) {\n        _SFETCH_ERROR(REQUEST_CHANNEL_INDEX_TOO_BIG);\n        return false;\n    }\n    if (!req->path) {\n        _SFETCH_ERROR(REQUEST_PATH_IS_NULL);\n        return false;\n    }\n    if (strlen(req->path) >= (SFETCH_MAX_PATH-1)) {\n        _SFETCH_ERROR(REQUEST_PATH_TOO_LONG);\n        return false;\n    }\n    if (!req->callback) {\n        _SFETCH_ERROR(REQUEST_CALLBACK_MISSING);\n        return false;\n    }\n    if (req->chunk_size > req->buffer.size) {\n        _SFETCH_ERROR(REQUEST_CHUNK_SIZE_GREATER_BUFFER_SIZE);\n        return false;\n    }\n    if (req->user_data.ptr && (req->user_data.size == 0)) {\n        _SFETCH_ERROR(REQUEST_USERDATA_PTR_IS_SET_BUT_USERDATA_SIZE_IS_NULL);\n        return false;\n    }\n    if (!req->user_data.ptr && (req->user_data.size > 0)) {\n        _SFETCH_ERROR(REQUEST_USERDATA_PTR_IS_NULL_BUT_USERDATA_SIZE_IS_NOT);\n        return false;\n    }\n    if (req->user_data.size > SFETCH_MAX_USERDATA_UINT64 * sizeof(uint64_t)) {\n        _SFETCH_ERROR(REQUEST_USERDATA_SIZE_TOO_BIG);\n        return false;\n    }\n    return true;\n}\n\n_SOKOL_PRIVATE sfetch_desc_t _sfetch_desc_defaults(const sfetch_desc_t* desc) {\n    SOKOL_ASSERT((desc->allocator.alloc_fn && desc->allocator.free_fn) || (!desc->allocator.alloc_fn && !desc->allocator.free_fn));\n    sfetch_desc_t res = *desc;\n    res.max_requests = _sfetch_def(desc->max_requests, 128);\n    res.num_channels = _sfetch_def(desc->num_channels, 1);\n    res.num_lanes = _sfetch_def(desc->num_lanes, 1);\n    return res;\n}\n\n//                  \n//                     \n//                 \n//                       \n//               \n//\n// >>public\nSOKOL_API_IMPL void sfetch_setup(const sfetch_desc_t* desc_) {\n    SOKOL_ASSERT(desc_);\n    SOKOL_ASSERT(0 == _sfetch);\n\n    sfetch_desc_t desc = _sfetch_desc_defaults(desc_);\n    _sfetch = (_sfetch_t*) _sfetch_malloc_with_allocator(&desc.allocator, sizeof(_sfetch_t));\n    SOKOL_ASSERT(_sfetch);\n    _sfetch_t* ctx = _sfetch_ctx();\n    _sfetch_clear(ctx, sizeof(_sfetch_t));\n    ctx->desc = desc;\n    ctx->setup = true;\n    ctx->valid = true;\n\n    /* replace zero-init items with default values */\n    if (ctx->desc.num_channels > SFETCH_MAX_CHANNELS) {\n        ctx->desc.num_channels = SFETCH_MAX_CHANNELS;\n        _SFETCH_WARN(CLAMPING_NUM_CHANNELS_TO_MAX_CHANNELS);\n    }\n\n    /* setup the global request item pool */\n    ctx->valid &= _sfetch_pool_init(&ctx->pool, ctx->desc.max_requests);\n\n    /* setup IO channels (one thread per channel) */\n    for (uint32_t i = 0; i < ctx->desc.num_channels; i++) {\n        ctx->valid &= _sfetch_channel_init(&ctx->chn[i], ctx, ctx->desc.max_requests, ctx->desc.num_lanes, _sfetch_request_handler);\n    }\n}\n\nSOKOL_API_IMPL void sfetch_shutdown(void) {\n    _sfetch_t* ctx = _sfetch_ctx();\n    SOKOL_ASSERT(ctx && ctx->setup);\n    ctx->valid = false;\n    /* IO threads must be shutdown first */\n    for (uint32_t i = 0; i < ctx->desc.num_channels; i++) {\n        if (ctx->chn[i].valid) {\n            _sfetch_channel_discard(&ctx->chn[i]);\n        }\n    }\n    _sfetch_pool_discard(&ctx->pool);\n    ctx->setup = false;\n    _sfetch_free(ctx);\n    _sfetch = 0;\n}\n\nSOKOL_API_IMPL bool sfetch_valid(void) {\n    _sfetch_t* ctx = _sfetch_ctx();\n    return ctx && ctx->valid;\n}\n\nSOKOL_API_IMPL sfetch_desc_t sfetch_desc(void) {\n    _sfetch_t* ctx = _sfetch_ctx();\n    SOKOL_ASSERT(ctx && ctx->valid);\n    return ctx->desc;\n}\n\nSOKOL_API_IMPL int sfetch_max_userdata_bytes(void) {\n    return SFETCH_MAX_USERDATA_UINT64 * 8;\n}\n\nSOKOL_API_IMPL int sfetch_max_path(void) {\n    return SFETCH_MAX_PATH;\n}\n\nSOKOL_API_IMPL bool sfetch_handle_valid(sfetch_handle_t h) {\n    _sfetch_t* ctx = _sfetch_ctx();\n    SOKOL_ASSERT(ctx && ctx->valid);\n    /* shortcut invalid handle */\n    if (h.id == 0) {\n        return false;\n    }\n    return 0 != _sfetch_pool_item_lookup(&ctx->pool, h.id);\n}\n\nSOKOL_API_IMPL sfetch_handle_t sfetch_send(const sfetch_request_t* request) {\n    _sfetch_t* ctx = _sfetch_ctx();\n    SOKOL_ASSERT(ctx && ctx->setup);\n\n    const sfetch_handle_t invalid_handle = _sfetch_make_handle(0);\n    if (!ctx->valid) {\n        return invalid_handle;\n    }\n    if (!_sfetch_validate_request(ctx, request)) {\n        return invalid_handle;\n    }\n    SOKOL_ASSERT(request->channel < ctx->desc.num_channels);\n\n    uint32_t slot_id = _sfetch_pool_item_alloc(&ctx->pool, request);\n    if (0 == slot_id) {\n        _SFETCH_WARN(REQUEST_POOL_EXHAUSTED);\n        return invalid_handle;\n    }\n    if (!_sfetch_channel_send(&ctx->chn[request->channel], slot_id)) {\n        /* send failed because the channels sent-queue overflowed */\n        _sfetch_pool_item_free(&ctx->pool, slot_id);\n        return invalid_handle;\n    }\n    return _sfetch_make_handle(slot_id);\n}\n\nSOKOL_API_IMPL void sfetch_dowork(void) {\n    _sfetch_t* ctx = _sfetch_ctx();\n    SOKOL_ASSERT(ctx && ctx->setup);\n    if (!ctx->valid) {\n        return;\n    }\n    /* we're pumping each channel 2x so that unfinished request items coming out the\n       IO threads can be moved back into the IO-thread immediately without\n       having to wait a frame\n     */\n    ctx->in_callback = true;\n    for (int pass = 0; pass < 2; pass++) {\n        for (uint32_t chn_index = 0; chn_index < ctx->desc.num_channels; chn_index++) {\n            _sfetch_channel_dowork(&ctx->chn[chn_index], &ctx->pool);\n        }\n    }\n    ctx->in_callback = false;\n}\n\nSOKOL_API_IMPL void sfetch_bind_buffer(sfetch_handle_t h, sfetch_range_t buffer) {\n    _sfetch_t* ctx = _sfetch_ctx();\n    SOKOL_ASSERT(ctx && ctx->valid);\n    SOKOL_ASSERT(ctx->in_callback);\n    SOKOL_ASSERT(buffer.ptr && (buffer.size > 0));\n    _sfetch_item_t* item = _sfetch_pool_item_lookup(&ctx->pool, h.id);\n    if (item) {\n        SOKOL_ASSERT((0 == item->buffer.ptr) && (0 == item->buffer.size));\n        item->buffer = buffer;\n    }\n}\n\nSOKOL_API_IMPL void* sfetch_unbind_buffer(sfetch_handle_t h) {\n    _sfetch_t* ctx = _sfetch_ctx();\n    SOKOL_ASSERT(ctx && ctx->valid);\n    SOKOL_ASSERT(ctx->in_callback);\n    _sfetch_item_t* item = _sfetch_pool_item_lookup(&ctx->pool, h.id);\n    if (item) {\n        void* prev_buf_ptr = (void*)item->buffer.ptr;\n        item->buffer.ptr = 0;\n        item->buffer.size = 0;\n        return prev_buf_ptr;\n    }\n    else {\n        return 0;\n    }\n}\n\nSOKOL_API_IMPL void sfetch_pause(sfetch_handle_t h) {\n    _sfetch_t* ctx = _sfetch_ctx();\n    SOKOL_ASSERT(ctx && ctx->valid);\n    _sfetch_item_t* item = _sfetch_pool_item_lookup(&ctx->pool, h.id);\n    if (item) {\n        item->user.pause = true;\n        item->user.cont = false;\n    }\n}\n\nSOKOL_API_IMPL void sfetch_continue(sfetch_handle_t h) {\n    _sfetch_t* ctx = _sfetch_ctx();\n    SOKOL_ASSERT(ctx && ctx->valid);\n    _sfetch_item_t* item = _sfetch_pool_item_lookup(&ctx->pool, h.id);\n    if (item) {\n        item->user.cont = true;\n        item->user.pause = false;\n    }\n}\n\nSOKOL_API_IMPL void sfetch_cancel(sfetch_handle_t h) {\n    _sfetch_t* ctx = _sfetch_ctx();\n    SOKOL_ASSERT(ctx && ctx->valid);\n    _sfetch_item_t* item = _sfetch_pool_item_lookup(&ctx->pool, h.id);\n    if (item) {\n        item->user.cont = false;\n        item->user.pause = false;\n        item->user.cancel = true;\n    }\n}\n\n#ifdef _MSC_VER\n#pragma warning(pop)\n#endif\n\n#endif /* SOKOL_FETCH_IMPL */\n"
        },
        {
          "name": "sokol_gfx.h",
          "type": "blob",
          "size": 870.0546875,
          "content": "#if defined(SOKOL_IMPL) && !defined(SOKOL_GFX_IMPL)\n#define SOKOL_GFX_IMPL\n#endif\n#ifndef SOKOL_GFX_INCLUDED\n/*\n    sokol_gfx.h -- simple 3D API wrapper\n\n    Project URL: https://github.com/floooh/sokol\n\n    Example code: https://github.com/floooh/sokol-samples\n\n    Do this:\n        #define SOKOL_IMPL or\n        #define SOKOL_GFX_IMPL\n    before you include this file in *one* C or C++ file to create the\n    implementation.\n\n    In the same place define one of the following to select the rendering\n    backend:\n        #define SOKOL_GLCORE\n        #define SOKOL_GLES3\n        #define SOKOL_D3D11\n        #define SOKOL_METAL\n        #define SOKOL_WGPU\n        #define SOKOL_DUMMY_BACKEND\n\n    I.e. for the desktop GL it should look like this:\n\n    #include ...\n    #include ...\n    #define SOKOL_IMPL\n    #define SOKOL_GLCORE\n    #include \"sokol_gfx.h\"\n\n    The dummy backend replaces the platform-specific backend code with empty\n    stub functions. This is useful for writing tests that need to run on the\n    command line.\n\n    Optionally provide the following defines with your own implementations:\n\n    SOKOL_ASSERT(c)             - your own assert macro (default: assert(c))\n    SOKOL_UNREACHABLE()         - a guard macro for unreachable code (default: assert(false))\n    SOKOL_GFX_API_DECL          - public function declaration prefix (default: extern)\n    SOKOL_API_DECL              - same as SOKOL_GFX_API_DECL\n    SOKOL_API_IMPL              - public function implementation prefix (default: -)\n    SOKOL_TRACE_HOOKS           - enable trace hook callbacks (search below for TRACE HOOKS)\n    SOKOL_EXTERNAL_GL_LOADER    - indicates that you're using your own GL loader, in this case\n                                  sokol_gfx.h will not include any platform GL headers and disable\n                                  the integrated Win32 GL loader\n\n    If sokol_gfx.h is compiled as a DLL, define the following before\n    including the declaration or implementation:\n\n    SOKOL_DLL\n\n    On Windows, SOKOL_DLL will define SOKOL_GFX_API_DECL as __declspec(dllexport)\n    or __declspec(dllimport) as needed.\n\n    If you want to compile without deprecated structs and functions,\n    define:\n\n    SOKOL_NO_DEPRECATED\n\n    Optionally define the following to force debug checks and validations\n    even in release mode:\n\n    SOKOL_DEBUG - by default this is defined if _DEBUG is defined\n\n    sokol_gfx DOES NOT:\n    ===================\n    - create a window, swapchain or the 3D-API context/device, you must do this\n      before sokol_gfx is initialized, and pass any required information\n      (like 3D device pointers) to the sokol_gfx initialization call\n\n    - present the rendered frame, how this is done exactly usually depends\n      on how the window and 3D-API context/device was created\n\n    - provide a unified shader language, instead 3D-API-specific shader\n      source-code or shader-bytecode must be provided (for the \"official\"\n      offline shader cross-compiler / code-generator, see here:\n      https://github.com/floooh/sokol-tools/blob/master/docs/sokol-shdc.md)\n\n\n    STEP BY STEP\n    ============\n    --- to initialize sokol_gfx, after creating a window and a 3D-API\n        context/device, call:\n\n            sg_setup(const sg_desc*)\n\n        Depending on the selected 3D backend, sokol-gfx requires some\n        information, like a device pointer, default swapchain pixel formats\n        and so on. If you are using sokol_app.h for the window system\n        glue, you can use a helper function provided in the sokol_glue.h\n        header:\n\n            #include \"sokol_gfx.h\"\n            #include \"sokol_app.h\"\n            #include \"sokol_glue.h\"\n            //...\n            sg_setup(&(sg_desc){\n                .environment = sglue_environment(),\n            });\n\n        To get any logging output for errors and from the validation layer, you\n        need to provide a logging callback. Easiest way is through sokol_log.h:\n\n            #include \"sokol_log.h\"\n            //...\n            sg_setup(&(sg_desc){\n                //...\n                .logger.func = slog_func,\n            });\n\n    --- create resource objects (at least buffers, shaders and pipelines,\n        and optionally images, samplers and render-pass-attachments):\n\n            sg_buffer sg_make_buffer(const sg_buffer_desc*)\n            sg_image sg_make_image(const sg_image_desc*)\n            sg_sampler sg_make_sampler(const sg_sampler_desc*)\n            sg_shader sg_make_shader(const sg_shader_desc*)\n            sg_pipeline sg_make_pipeline(const sg_pipeline_desc*)\n            sg_attachments sg_make_attachments(const sg_attachments_desc*)\n\n    --- start a render pass:\n\n            sg_begin_pass(const sg_pass* pass);\n\n        Typically, passes render into an externally provided swapchain which\n        presents the rendering result on the display. Such a 'swapchain pass'\n        is started like this:\n\n            sg_begin_pass(&(sg_pass){ .action = { ... }, .swapchain = sglue_swapchain() })\n\n        ...where .action is an sg_pass_action struct containing actions to be performed\n        at the start and end of a render pass (such as clearing the render surfaces to\n        a specific color), and .swapchain is an sg_swapchain\n        struct all the required information to render into the swapchain's surfaces.\n\n        To start an 'offscreen pass' into sokol-gfx image objects, an sg_attachment\n        object handle is required instead of an sg_swapchain struct. An offscreen\n        pass is started like this (assuming attachments is an sg_attachments handle):\n\n            sg_begin_pass(&(sg_pass){ .action = { ... }, .attachments = attachments });\n\n    --- set the render pipeline state for the next draw call with:\n\n            sg_apply_pipeline(sg_pipeline pip)\n\n    --- fill an sg_bindings struct with the resource bindings for the next\n        draw call (0..N vertex buffers, 0 or 1 index buffer, 0..N images,\n        samplers and storage-buffers), and call:\n\n            sg_apply_bindings(const sg_bindings* bindings)\n\n        to update the resource bindings\n\n    --- optionally update shader uniform data with:\n\n            sg_apply_uniforms(int ub_slot, const sg_range* data)\n\n        Read the section 'UNIFORM DATA LAYOUT' to learn about the expected memory layout\n        of the uniform data passed into sg_apply_uniforms().\n\n    --- kick off a draw call with:\n\n            sg_draw(int base_element, int num_elements, int num_instances)\n\n        The sg_draw() function unifies all the different ways to render primitives\n        in a single call (indexed vs non-indexed rendering, and instanced vs non-instanced\n        rendering). In case of indexed rendering, base_element and num_element specify\n        indices in the currently bound index buffer. In case of non-indexed rendering\n        base_element and num_elements specify vertices in the currently bound\n        vertex-buffer(s). To perform instanced rendering, the rendering pipeline\n        must be setup for instancing (see sg_pipeline_desc below), a separate vertex buffer\n        containing per-instance data must be bound, and the num_instances parameter\n        must be > 1.\n\n    --- finish the current rendering pass with:\n\n            sg_end_pass()\n\n    --- when done with the current frame, call\n\n            sg_commit()\n\n    --- at the end of your program, shutdown sokol_gfx with:\n\n            sg_shutdown()\n\n    --- if you need to destroy resources before sg_shutdown(), call:\n\n            sg_destroy_buffer(sg_buffer buf)\n            sg_destroy_image(sg_image img)\n            sg_destroy_sampler(sg_sampler smp)\n            sg_destroy_shader(sg_shader shd)\n            sg_destroy_pipeline(sg_pipeline pip)\n            sg_destroy_attachments(sg_attachments atts)\n\n    --- to set a new viewport rectangle, call\n\n            sg_apply_viewport(int x, int y, int width, int height, bool origin_top_left)\n\n        ...or if you want to specify the viewport rectangle with float values:\n\n            sg_apply_viewportf(float x, float y, float width, float height, bool origin_top_left)\n\n    --- to set a new scissor rect, call:\n\n            sg_apply_scissor_rect(int x, int y, int width, int height, bool origin_top_left)\n\n        ...or with float values:\n\n            sg_apply_scissor_rectf(float x, float y, float width, float height, bool origin_top_left)\n\n        Both sg_apply_viewport() and sg_apply_scissor_rect() must be called\n        inside a rendering pass\n\n        Note that sg_begin_default_pass() and sg_begin_pass() will reset both the\n        viewport and scissor rectangles to cover the entire framebuffer.\n\n    --- to update (overwrite) the content of buffer and image resources, call:\n\n            sg_update_buffer(sg_buffer buf, const sg_range* data)\n            sg_update_image(sg_image img, const sg_image_data* data)\n\n        Buffers and images to be updated must have been created with\n        SG_USAGE_DYNAMIC or SG_USAGE_STREAM\n\n        Only one update per frame is allowed for buffer and image resources when\n        using the sg_update_*() functions. The rationale is to have a simple\n        countermeasure to avoid the CPU scribbling over data the GPU is currently\n        using, or the CPU having to wait for the GPU\n\n        Buffer and image updates can be partial, as long as a rendering\n        operation only references the valid (updated) data in the\n        buffer or image.\n\n    --- to append a chunk of data to a buffer resource, call:\n\n            int sg_append_buffer(sg_buffer buf, const sg_range* data)\n\n        The difference to sg_update_buffer() is that sg_append_buffer()\n        can be called multiple times per frame to append new data to the\n        buffer piece by piece, optionally interleaved with draw calls referencing\n        the previously written data.\n\n        sg_append_buffer() returns a byte offset to the start of the\n        written data, this offset can be assigned to\n        sg_bindings.vertex_buffer_offsets[n] or\n        sg_bindings.index_buffer_offset\n\n        Code example:\n\n        for (...) {\n            const void* data = ...;\n            const int num_bytes = ...;\n            int offset = sg_append_buffer(buf, &(sg_range) { .ptr=data, .size=num_bytes });\n            bindings.vertex_buffer_offsets[0] = offset;\n            sg_apply_pipeline(pip);\n            sg_apply_bindings(&bindings);\n            sg_apply_uniforms(...);\n            sg_draw(...);\n        }\n\n        A buffer to be used with sg_append_buffer() must have been created\n        with SG_USAGE_DYNAMIC or SG_USAGE_STREAM.\n\n        If the application appends more data to the buffer then fits into\n        the buffer, the buffer will go into the \"overflow\" state for the\n        rest of the frame.\n\n        Any draw calls attempting to render an overflown buffer will be\n        silently dropped (in debug mode this will also result in a\n        validation error).\n\n        You can also check manually if a buffer is in overflow-state by calling\n\n            bool sg_query_buffer_overflow(sg_buffer buf)\n\n        You can manually check to see if an overflow would occur before adding\n        any data to a buffer by calling\n\n            bool sg_query_buffer_will_overflow(sg_buffer buf, size_t size)\n\n        NOTE: Due to restrictions in underlying 3D-APIs, appended chunks of\n        data will be 4-byte aligned in the destination buffer. This means\n        that there will be gaps in index buffers containing 16-bit indices\n        when the number of indices in a call to sg_append_buffer() is\n        odd. This isn't a problem when each call to sg_append_buffer()\n        is associated with one draw call, but will be problematic when\n        a single indexed draw call spans several appended chunks of indices.\n\n    --- to check at runtime for optional features, limits and pixelformat support,\n        call:\n\n            sg_features sg_query_features()\n            sg_limits sg_query_limits()\n            sg_pixelformat_info sg_query_pixelformat(sg_pixel_format fmt)\n\n    --- if you need to call into the underlying 3D-API directly, you must call:\n\n            sg_reset_state_cache()\n\n        ...before calling sokol_gfx functions again\n\n    --- you can inspect the original sg_desc structure handed to sg_setup()\n        by calling sg_query_desc(). This will return an sg_desc struct with\n        the default values patched in instead of any zero-initialized values\n\n    --- you can get a desc struct matching the creation attributes of a\n        specific resource object via:\n\n            sg_buffer_desc sg_query_buffer_desc(sg_buffer buf)\n            sg_image_desc sg_query_image_desc(sg_image img)\n            sg_sampler_desc sg_query_sampler_desc(sg_sampler smp)\n            sg_shader_desc sq_query_shader_desc(sg_shader shd)\n            sg_pipeline_desc sg_query_pipeline_desc(sg_pipeline pip)\n            sg_attachments_desc sg_query_attachments_desc(sg_attachments atts)\n\n        ...but NOTE that the returned desc structs may be incomplete, only\n        creation attributes that are kept around internally after resource\n        creation will be filled in, and in some cases (like shaders) that's\n        very little. Any missing attributes will be set to zero. The returned\n        desc structs might still be useful as partial blueprint for creating\n        similar resources if filled up with the missing attributes.\n\n        Calling the query-desc functions on an invalid resource will return\n        completely zeroed structs (it makes sense to check  the resource state\n        with sg_query_*_state() first)\n\n    --- you can query the default resource creation parameters through the functions\n\n            sg_buffer_desc sg_query_buffer_defaults(const sg_buffer_desc* desc)\n            sg_image_desc sg_query_image_defaults(const sg_image_desc* desc)\n            sg_sampler_desc sg_query_sampler_defaults(const sg_sampler_desc* desc)\n            sg_shader_desc sg_query_shader_defaults(const sg_shader_desc* desc)\n            sg_pipeline_desc sg_query_pipeline_defaults(const sg_pipeline_desc* desc)\n            sg_attachments_desc sg_query_attachments_defaults(const sg_attachments_desc* desc)\n\n        These functions take a pointer to a desc structure which may contain\n        zero-initialized items for default values. These zero-init values\n        will be replaced with their concrete values in the returned desc\n        struct.\n\n    --- you can inspect various internal resource runtime values via:\n\n            sg_buffer_info sg_query_buffer_info(sg_buffer buf)\n            sg_image_info sg_query_image_info(sg_image img)\n            sg_sampler_info sg_query_sampler_info(sg_sampler smp)\n            sg_shader_info sg_query_shader_info(sg_shader shd)\n            sg_pipeline_info sg_query_pipeline_info(sg_pipeline pip)\n            sg_attachments_info sg_query_attachments_info(sg_attachments atts)\n\n        ...please note that the returned info-structs are tied quite closely\n        to sokol_gfx.h internals, and may change more often than other\n        public API functions and structs.\n\n    --- you can query frame stats and control stats collection via:\n\n            sg_query_frame_stats()\n            sg_enable_frame_stats()\n            sg_disable_frame_stats()\n            sg_frame_stats_enabled()\n\n    --- you can ask at runtime what backend sokol_gfx.h has been compiled for:\n\n            sg_backend sg_query_backend(void)\n\n    --- call the following helper functions to compute the number of\n        bytes in a texture row or surface for a specific pixel format.\n        These functions might be helpful when preparing image data for consumption\n        by sg_make_image() or sg_update_image():\n\n            int sg_query_row_pitch(sg_pixel_format fmt, int width, int int row_align_bytes);\n            int sg_query_surface_pitch(sg_pixel_format fmt, int width, int height, int row_align_bytes);\n\n        Width and height are generally in number pixels, but note that 'row' has different meaning\n        for uncompressed vs compressed pixel formats: for uncompressed formats, a row is identical\n        with a single line if pixels, while in compressed formats, one row is a line of *compression blocks*.\n\n        This is why calling sg_query_surface_pitch() for a compressed pixel format and height\n        N, N+1, N+2, ... may return the same result.\n\n        The row_align_bytes parammeter is for added flexibility. For image data that goes into\n        the sg_make_image() or sg_update_image() this should generally be 1, because these\n        functions take tightly packed image data as input no matter what alignment restrictions\n        exist in the backend 3D APIs.\n\n    ON INITIALIZATION:\n    ==================\n    When calling sg_setup(), a pointer to an sg_desc struct must be provided\n    which contains initialization options. These options provide two types\n    of information to sokol-gfx:\n\n        (1) upper bounds and limits needed to allocate various internal\n            data structures:\n                - the max number of resources of each type that can\n                  be alive at the same time, this is used for allocating\n                  internal pools\n                - the max overall size of uniform data that can be\n                  updated per frame, including a worst-case alignment\n                  per uniform update (this worst-case alignment is 256 bytes)\n                - the max size of all dynamic resource updates (sg_update_buffer,\n                  sg_append_buffer and sg_update_image) per frame\n            Not all of those limit values are used by all backends, but it is\n            good practice to provide them none-the-less.\n\n        (2) 3D backend \"environment information\" in a nested sg_environment struct:\n            - pointers to backend-specific context- or device-objects (for instance\n              the D3D11, WebGPU or Metal device objects)\n            - defaults for external swapchain pixel formats and sample counts,\n              these will be used as default values in image and pipeline objects,\n              and the sg_swapchain struct passed into sg_begin_pass()\n            Usually you provide a complete sg_environment struct through\n            a helper function, as an example look at the sglue_environment()\n            function in the sokol_glue.h header.\n\n    See the documentation block of the sg_desc struct below for more information.\n\n\n    ON RENDER PASSES\n    ================\n    Relevant samples:\n        - https://floooh.github.io/sokol-html5/offscreen-sapp.html\n        - https://floooh.github.io/sokol-html5/offscreen-msaa-sapp.html\n        - https://floooh.github.io/sokol-html5/mrt-sapp.html\n        - https://floooh.github.io/sokol-html5/mrt-pixelformats-sapp.html\n\n    A render pass groups rendering commands into a set of render target images\n    (called 'pass attachments'). Render target images can be used in subsequent\n    passes as textures (it is invalid to use the same image both as render target\n    and as texture in the same pass).\n\n    The following sokol-gfx functions must only be called inside a render pass:\n\n        sg_apply_viewport(f)\n        sg_apply_scissor_rect(f)\n        sg_apply_pipeline\n        sg_apply_bindings\n        sg_apply_uniforms\n        sg_draw\n\n    A frame must have at least one 'swapchain render pass' which renders into an\n    externally provided swapchain provided as an sg_swapchain struct to the\n    sg_begin_pass() function. If you use sokol_gfx.h together with sokol_app.h,\n    just call the sglue_swapchain() helper function in sokol_glue.h to\n    provide the swapchain information. Otherwise the following information\n    must be provided:\n\n        - the color pixel-format of the swapchain's render surface\n        - an optional depth/stencil pixel format if the swapchain\n          has a depth/stencil buffer\n        - an optional sample-count for MSAA rendering\n        - NOTE: the above three values can be zero-initialized, in that\n          case the defaults from the sg_environment struct will be used that\n          had been passed to the sg_setup() function.\n        - a number of backend specific objects:\n            - GL/GLES3: just a GL framebuffer handle\n            - D3D11:\n                - an ID3D11RenderTargetView for the rendering surface\n                - if MSAA is used, an ID3D11RenderTargetView as\n                  MSAA resolve-target\n                - an optional ID3D11DepthStencilView for the\n                  depth/stencil buffer\n            - WebGPU\n                - a WGPUTextureView object for the rendering surface\n                - if MSAA is used, a WGPUTextureView object as MSAA resolve target\n                - an optional WGPUTextureView for the\n            - Metal (NOTE that the roles of provided surfaces is slightly\n              different in Metal than in D3D11 or WebGPU, notably, the\n              CAMetalDrawable is either rendered to directly, or serves\n              as MSAA resolve target):\n                - a CAMetalDrawable object which is either rendered\n                  into directly, or in case of MSAA rendering, serves\n                  as MSAA-resolve-target\n                - if MSAA is used, an multisampled MTLTexture where\n                  rendering goes into\n                - an optional MTLTexture for the depth/stencil buffer\n\n    It's recommended that you create a helper function which returns an\n    initialized sg_swapchain struct by value. This can then be directly plugged\n    into the sg_begin_pass function like this:\n\n        sg_begin_pass(&(sg_pass){ .swapchain = sglue_swapchain() });\n\n    As an example for such a helper function check out the function sglue_swapchain()\n    in the sokol_glue.h header.\n\n    For offscreen render passes, the render target images used in a render pass\n    are baked into an immutable sg_attachments object.\n\n    For a simple offscreen scenario with one color-, one depth-stencil-render\n    target and without multisampling, creating an attachment object looks like this:\n\n    First create two render target images, one with a color pixel format,\n    and one with the depth- or depth-stencil pixel format. Both images\n    must have the same dimensions:\n\n        const sg_image color_img = sg_make_image(&(sg_image_desc){\n            .render_target = true,\n            .width = 256,\n            .height = 256,\n            .pixel_format = SG_PIXELFORMAT_RGBA8,\n            .sample_count = 1,\n        });\n        const sg_image depth_img = sg_make_image(&(sg_image_desc){\n            .render_target = true,\n            .width = 256,\n            .height = 256,\n            .pixel_format = SG_PIXELFORMAT_DEPTH,\n            .sample_count = 1,\n        });\n\n    NOTE: when creating render target images, have in mind that some default values\n    are aligned with the default environment attributes in the sg_environment struct\n    that was passed into the sg_setup() call:\n\n        - the default value for sg_image_desc.pixel_format is taken from\n          sg_environment.defaults.color_format\n        - the default value for sg_image_desc.sample_count is taken from\n          sg_environment.defaults.sample_count\n        - the default value for sg_image_desc.num_mipmaps is always 1\n\n    Next create an attachments object:\n\n        const sg_attachments atts = sg_make_attachments(&(sg_attachments_desc){\n            .colors[0].image = color_img,\n            .depth_stencil.image = depth_img,\n        });\n\n    This attachments object is then passed into the sg_begin_pass() function\n    in place of the swapchain struct:\n\n        sg_begin_pass(&(sg_pass){ .attachments = atts });\n\n    Swapchain and offscreen passes form dependency trees each with a swapchain\n    pass at the root, offscreen passes as nodes, and render target images as\n    dependencies between passes.\n\n    sg_pass_action structs are used to define actions that should happen at the\n    start and end of rendering passes (such as clearing pass attachments to a\n    specific color or depth-value, or performing an MSAA resolve operation at\n    the end of a pass).\n\n    A typical sg_pass_action object which clears the color attachment to black\n    might look like this:\n\n        const sg_pass_action = {\n            .colors[0] = {\n                .load_action = SG_LOADACTION_CLEAR,\n                .clear_value = { 0.0f, 0.0f, 0.0f, 1.0f }\n            }\n        };\n\n    This omits the defaults for the color attachment store action, and\n    the depth-stencil-attachments actions. The same pass action with the\n    defaults explicitly filled in would look like this:\n\n        const sg_pass_action pass_action = {\n            .colors[0] = {\n                .load_action = SG_LOADACTION_CLEAR,\n                .store_action = SG_STOREACTION_STORE,\n                .clear_value = { 0.0f, 0.0f, 0.0f, 1.0f }\n            },\n            .depth = = {\n                .load_action = SG_LOADACTION_CLEAR,\n                .store_action = SG_STOREACTION_DONTCARE,\n                .clear_value = 1.0f,\n            },\n            .stencil = {\n                .load_action = SG_LOADACTION_CLEAR,\n                .store_action = SG_STOREACTION_DONTCARE,\n                .clear_value = 0\n            }\n        };\n\n    With the sg_pass object and sg_pass_action struct in place everything\n    is ready now for the actual render pass:\n\n    Using such this prepared sg_pass_action in a swapchain pass looks like\n    this:\n\n        sg_begin_pass(&(sg_pass){\n            .action = pass_action,\n            .swapchain = sglue_swapchain()\n        });\n        ...\n        sg_end_pass();\n\n    ...of alternatively in one offscreen pass:\n\n        sg_begin_pass(&(sg_pass){\n            .action = pass_action,\n            .attachments = attachments,\n        });\n        ...\n        sg_end_pass();\n\n    Offscreen rendering can also go into a mipmap, or a slice/face of\n    a cube-, array- or 3d-image (which some restrictions, for instance\n    it's not possible to create a 3D image with a depth/stencil pixel format,\n    these exceptions are generally caught by the sokol-gfx validation layer).\n\n    The mipmap/slice selection happens at attachments creation time, for instance\n    to render into mipmap 2 of slice 3 of an array texture:\n\n        const sg_attachments atts = sg_make_attachments(&(sg_attachments_desc){\n            .colors[0] = {\n                .image = color_img,\n                .mip_level = 2,\n                .slice = 3,\n            },\n            .depth_stencil.image = depth_img,\n        });\n\n    If MSAA offscreen rendering is desired, the multi-sample rendering result\n    must be 'resolved' into a separate 'resolve image', before that image can\n    be used as texture.\n\n    NOTE: currently multisample-images cannot be bound as textures.\n\n    Creating a simple attachments object for multisampled rendering requires\n    3 attachment images: the color attachment image which has a sample\n    count > 1, a resolve attachment image of the same size and pixel format\n    but a sample count == 1, and a depth/stencil attachment image with\n    the same size and sample count as the color attachment image:\n\n        const sg_image color_img = sg_make_image(&(sg_image_desc){\n            .render_target = true,\n            .width = 256,\n            .height = 256,\n            .pixel_format = SG_PIXELFORMAT_RGBA8,\n            .sample_count = 4,\n        });\n        const sg_image resolve_img = sg_make_image(&(sg_image_desc){\n            .render_target = true,\n            .width = 256,\n            .height = 256,\n            .pixel_format = SG_PIXELFORMAT_RGBA8,\n            .sample_count = 1,\n        });\n        const sg_image depth_img = sg_make_image(&(sg_image_desc){\n            .render_target = true,\n            .width = 256,\n            .height = 256,\n            .pixel_format = SG_PIXELFORMAT_DEPTH,\n            .sample_count = 4,\n        });\n\n    ...create the attachments object:\n\n        const sg_attachments atts = sg_make_attachments(&(sg_attachments_desc){\n            .colors[0].image = color_img,\n            .resolves[0].image = resolve_img,\n            .depth_stencil.image = depth_img,\n        });\n\n    If an attachments object defines a resolve image in a specific resolve attachment slot,\n    an 'msaa resolve operation' will happen in sg_end_pass().\n\n    In this scenario, the content of the MSAA color attachment doesn't need to be\n    preserved (since it's only needed inside sg_end_pass for the msaa-resolve), so\n    the .store_action should be set to \"don't care\":\n\n        const sg_pass_action = {\n            .colors[0] = {\n                .load_action = SG_LOADACTION_CLEAR,\n                .store_action = SG_STOREACTION_DONTCARE,\n                .clear_value = { 0.0f, 0.0f, 0.0f, 1.0f }\n            }\n        };\n\n    The actual render pass looks as usual:\n\n        sg_begin_pass(&(sg_pass){ .action = pass_action, .attachments = atts });\n        ...\n        sg_end_pass();\n\n    ...after sg_end_pass() the only difference to the non-msaa scenario is that the\n    rendering result which is going to be used as texture in a followup pass is\n    in 'resolve_img', not in 'color_img' (in fact, trying to bind color_img as a\n    texture would result in a validation error).\n\n\n    ON SHADER CREATION\n    ==================\n    sokol-gfx doesn't come with an integrated shader cross-compiler, instead\n    backend-specific shader sources or binary blobs need to be provided when\n    creating a shader object, along with information about the shader resource\n    binding interface needed to bind sokol-gfx resources to the proper\n    shader inputs.\n\n    The easiest way to provide all this shader creation data is to use the\n    sokol-shdc shader compiler tool to compile shaders from a common\n    GLSL syntax into backend-specific sources or binary blobs, along with\n    shader interface information and uniform blocks mapped to C structs.\n\n    To create a shader using a C header which has been code-generated by sokol-shdc:\n\n        // include the C header code-generated by sokol-shdc:\n        #include \"myshader.glsl.h\"\n        ...\n\n        // create shader using a code-generated helper function from the C header:\n        sg_shader shd = sg_make_shader(myshader_shader_desc(sg_query_backend()));\n\n    The samples in the 'sapp' subdirectory of the sokol-samples project\n    also use the sokol-shdc approach:\n\n        https://github.com/floooh/sokol-samples/tree/master/sapp\n\n    If you're planning to use sokol-shdc, you can stop reading here, instead\n    continue with the sokol-shdc documentation:\n\n        https://github.com/floooh/sokol-tools/blob/master/docs/sokol-shdc.md\n\n    To create shaders with backend-specific shader code or binary blobs,\n    the sg_make_shader() function requires the following information:\n\n    - Shader code or shader binary blobs for the vertex- and fragment- shader-stage:\n        - for the desktop GL backend, source code can be provided in '#version 410' or\n          '#version 430', version 430 is required for storage buffer support, but note\n          that this is not available on macOS\n        - for the GLES3 backend, source code must be provided in '#version 300 es' syntax\n        - for the D3D11 backend, shaders can be provided as source or binary blobs, the\n          source code should be in HLSL4.0 (for best compatibility) or alternatively\n          in HLSL5.0 syntax (other versions may work but are not tested), NOTE: when\n          shader source code is provided for the D3D11 backend, sokol-gfx will dynamically\n          load 'd3dcompiler_47.dll'\n        - for the Metal backends, shaders can be provided as source or binary blobs, the\n          MSL version should be in 'metal-1.1' (other versions may work but are not tested)\n        - for the WebGPU backend, shaders must be provided as WGSL source code\n        - optionally the following shader-code related attributes can be provided:\n            - an entry function name (only on D3D11 or Metal, but not OpenGL)\n            - on D3D11 only, a compilation target (default is \"vs_4_0\" and \"ps_4_0\")\n\n    - Depending on backend, information about the input vertex attributes used by the\n      vertex shader:\n        - Metal: no information needed since vertex attributes are always bound\n          by their attribute location defined in the shader via '[[attribute(N)]]'\n        - WebGPU: no information needed since vertex attributes are always\n          bound by their attribute location defined in the shader via `@location(N)`\n        - GLSL: vertex attribute names can be optionally provided, in that case their\n          location will be looked up by name, otherwise, the vertex attribute location\n          can be defined with 'layout(location = N)'\n        - D3D11: a 'semantic name' and 'semantic index' must be provided for each vertex\n          attribute, e.g. if the vertex attribute is defined as 'TEXCOORD1' in the shader,\n          the semantic name would be 'TEXCOORD', and the semantic index would be '1'\n\n      NOTE that vertex attributes currently must not have gaps. This requirement\n      may be relaxed in the future.\n\n    - Information about each uniform block used in the shader:\n        - the shader stage of the uniform block (vertex or fragment)\n        - the size of the uniform block in number of bytes\n        - a memory layout hint (currently 'native' or 'std140') where 'native' defines a\n          backend-specific memory layout which shouldn't be used for cross-platform code.\n          Only std140 guarantees a backend-agnostic memory layout.\n        - a backend-specific bind slot:\n            - D3D11/HLSL: the buffer register N (`register(bN)`) where N is 0..7\n            - Metal/MSL: the buffer bind slot N (`[[buffer(N)]]`) where N is 0..7\n            - WebGPU: the binding N in `@group(0) @binding(N)` where N is 0..15\n        - For GLSL only: a description of the internal uniform block layout, which maps\n          member types and their offsets on the CPU side to uniform variable names\n          in the GLSL shader\n        - please also NOTE the documentation sections about UNIFORM DATA LAYOUT\n          and CROSS-BACKEND COMMON UNIFORM DATA LAYOUT below!\n\n    - A description of each storage buffer used in the shader:\n        - the shader stage of the storage buffer\n        - a boolean 'readonly' flag, note that currently only\n          readonly storage buffers are supported\n        - a backend-specific bind slot:\n            - D3D11/HLSL: the texture register N (`register(tN)`) where N is 0..23\n              (in HLSL, storage buffers and texture share the same bind space)\n            - Metal/MSL: the buffer bind slot N (`[[buffer(N)]]`) where N is 8..15\n            - WebGPU/WGSL: the binding N in `@group(0) @binding(N)` where N is 0..127\n            - GL/GLSL: the buffer binding N in `layout(binding=N)` where N is 0..16\n        - note that storage buffers are not supported on all backends\n          and platforms\n\n    - A description of each texture/image used in the shader:\n        - the shader stage of the texture (vertex or fragment)\n        - the expected image type:\n            - SG_IMAGETYPE_2D\n            - SG_IMAGETYPE_CUBE\n            - SG_IMAGETYPE_3D\n            - SG_IMAGETYPE_ARRAY\n        - the expected 'image sample type':\n            - SG_IMAGESAMPLETYPE_FLOAT\n            - SG_IMAGESAMPLETYPE_DEPTH\n            - SG_IMAGESAMPLETYPE_SINT\n            - SG_IMAGESAMPLETYPE_UINT\n            - SG_IMAGESAMPLETYPE_UNFILTERABLE_FLOAT\n        - a flag whether the texture is expected to be multisampled\n          (currently it's not supported to fetch data from multisampled\n          textures in shaders, but this is planned for a later time)\n        - a backend-specific bind slot:\n            - D3D11/HLSL: the texture register N (`register(tN)`) where N is 0..23\n              (in HLSL, storage buffers and texture share the same bind space)\n            - Metal/MSL: the texture bind slot N (`[[texture(N)]]`) where N is 0..15\n            - WebGPU/WGSL: the binding N in `@group(0) @binding(N)` where N is 0..127\n\n    - A description of each sampler used in the shader:\n        - the shader stage of the sampler (vertex or fragment)\n        - the expected sampler type:\n            - SG_SAMPLERTYPE_FILTERING,\n            - SG_SAMPLERTYPE_NONFILTERING,\n            - SG_SAMPLERTYPE_COMPARISON,\n        - a backend-specific bind slot:\n            - D3D11/HLSL: the sampler register N (`register(sN)`) where N is 0..15\n            - Metal/MSL: the sampler bind slot N (`[[sampler(N)]]`) where N is 0..15\n            - WebGPU/WGSL: the binding N in `@group(0) @binding(N)` where N is 0..127\n\n    - An array of 'image-sampler-pairs' used by the shader to sample textures,\n      for D3D11, Metal and WebGPU this is used for validation purposes to check\n      whether the texture and sampler are compatible with each other (especially\n      WebGPU is very picky about combining the correct\n      texture-sample-type with the correct sampler-type). For GLSL an\n      additional 'combined-image-sampler name' must be provided because 'OpenGL\n      style GLSL' cannot handle separate texture and sampler objects, but still\n      groups them into a traditional GLSL 'sampler object'.\n\n    Compatibility rules for image-sample-type vs sampler-type are as follows:\n\n        - SG_IMAGESAMPLETYPE_FLOAT => (SG_SAMPLERTYPE_FILTERING or SG_SAMPLERTYPE_NONFILTERING)\n        - SG_IMAGESAMPLETYPE_UNFILTERABLE_FLOAT => SG_SAMPLERTYPE_NONFILTERING\n        - SG_IMAGESAMPLETYPE_SINT => SG_SAMPLERTYPE_NONFILTERING\n        - SG_IMAGESAMPLETYPE_UINT => SG_SAMPLERTYPE_NONFILTERING\n        - SG_IMAGESAMPLETYPE_DEPTH => SG_SAMPLERTYPE_COMPARISON\n\n    Backend-specific bindslot ranges (not relevant when using sokol-shdc):\n\n        - D3D11/HLSL:\n            - separate bindslot space per shader stage\n            - uniform blocks (as cbuffer): `register(b0..b7)`\n            - textures and storage buffers: `register(t0..t23)`\n            - samplers: `register(s0..s15)`\n        - Metal/MSL:\n            - separate bindslot space per shader stage\n            - uniform blocks: `[[buffer(0..7)]]`\n            - storage buffers: `[[buffer(8..15)]]`\n            - textures: `[[texture(0..15)]]`\n            - samplers: `[[sampler(0..15)]]`\n        - WebGPU/WGSL:\n            - common bindslot space across shader stages\n            - uniform blocks: `@group(0) @binding(0..15)`\n            - textures, samplers and storage buffers: `@group(1) @binding(0..127)`\n        - GL/GLSL:\n            - uniforms and image-samplers are bound by name\n            - storage buffers: `layout(std430, binding=0..7)` (common\n              bindslot space across shader stages)\n\n    For example code of how to create backend-specific shader objects,\n    please refer to the following samples:\n\n        - for D3D11:    https://github.com/floooh/sokol-samples/tree/master/d3d11\n        - for Metal:    https://github.com/floooh/sokol-samples/tree/master/metal\n        - for OpenGL:   https://github.com/floooh/sokol-samples/tree/master/glfw\n        - for GLES3:    https://github.com/floooh/sokol-samples/tree/master/html5\n        - for WebGPI:   https://github.com/floooh/sokol-samples/tree/master/wgpu\n\n\n    ON SG_IMAGESAMPLETYPE_UNFILTERABLE_FLOAT AND SG_SAMPLERTYPE_NONFILTERING\n    ========================================================================\n    The WebGPU backend introduces the concept of 'unfilterable-float' textures,\n    which can only be combined with 'nonfiltering' samplers (this is a restriction\n    specific to WebGPU, but since the same sokol-gfx code should work across\n    all backend, the sokol-gfx validation layer also enforces this restriction\n    - the alternative would be undefined behaviour in some backend APIs on\n    some devices).\n\n    The background is that some mobile devices (most notably iOS devices) can\n    not perform linear filtering when sampling textures with certain pixel\n    formats, most notable the 32F formats:\n\n        - SG_PIXELFORMAT_R32F\n        - SG_PIXELFORMAT_RG32F\n        - SG_PIXELFORMAT_RGBA32F\n\n    The information of whether a shader is going to be used with such an\n    unfilterable-float texture must already be provided in the sg_shader_desc\n    struct when creating the shader (see the above section \"ON SHADER CREATION\").\n\n    If you are using the sokol-shdc shader compiler, the information whether a\n    texture/sampler binding expects an 'unfilterable-float/nonfiltering'\n    texture/sampler combination cannot be inferred from the shader source\n    alone, you'll need to provide this hint via annotation-tags. For instance\n    here is an example from the ozz-skin-sapp.c sample shader which samples an\n    RGBA32F texture with skinning matrices in the vertex shader:\n\n    ```glsl\n    @image_sample_type joint_tex unfilterable_float\n    uniform texture2D joint_tex;\n    @sampler_type smp nonfiltering\n    uniform sampler smp;\n    ```\n\n    This will result in SG_IMAGESAMPLETYPE_UNFILTERABLE_FLOAT and\n    SG_SAMPLERTYPE_NONFILTERING being written to the code-generated\n    sg_shader_desc struct.\n\n\n    UNIFORM DATA LAYOUT:\n    ====================\n    NOTE: if you use the sokol-shdc shader compiler tool, you don't need to worry\n    about the following details.\n\n    The data that's passed into the sg_apply_uniforms() function must adhere to\n    specific layout rules so that the GPU shader finds the uniform block\n    items at the right offset.\n\n    For the D3D11 and Metal backends, sokol-gfx only cares about the size of uniform\n    blocks, but not about the internal layout. The data will just be copied into\n    a uniform/constant buffer in a single operation and it's up you to arrange the\n    CPU-side layout so that it matches the GPU side layout. This also means that with\n    the D3D11 and Metal backends you are not limited to a 'cross-platform' subset\n    of uniform variable types.\n\n    If you ever only use one of the D3D11, Metal *or* WebGPU backend, you can stop reading here.\n\n    For the GL backends, the internal layout of uniform blocks matters though,\n    and you are limited to a small number of uniform variable types. This is\n    because sokol-gfx must be able to locate the uniform block members in order\n    to upload them to the GPU with glUniformXXX() calls.\n\n    To describe the uniform block layout to sokol-gfx, the following information\n    must be passed to the sg_make_shader() call in the sg_shader_desc struct:\n\n        - a hint about the used packing rule (either SG_UNIFORMLAYOUT_NATIVE or\n          SG_UNIFORMLAYOUT_STD140)\n        - a list of the uniform block members types in the correct order they\n          appear on the CPU side\n\n    For example if the GLSL shader has the following uniform declarations:\n\n        uniform mat4 mvp;\n        uniform vec2 offset0;\n        uniform vec2 offset1;\n        uniform vec2 offset2;\n\n    ...and on the CPU side, there's a similar C struct:\n\n        typedef struct {\n            float mvp[16];\n            float offset0[2];\n            float offset1[2];\n            float offset2[2];\n        } params_t;\n\n    ...the uniform block description in the sg_shader_desc must look like this:\n\n        sg_shader_desc desc = {\n            .vs.uniform_blocks[0] = {\n                .size = sizeof(params_t),\n                .layout = SG_UNIFORMLAYOUT_NATIVE,  // this is the default and can be omitted\n                .uniforms = {\n                    // order must be the same as in 'params_t':\n                    [0] = { .name = \"mvp\", .type = SG_UNIFORMTYPE_MAT4 },\n                    [1] = { .name = \"offset0\", .type = SG_UNIFORMTYPE_VEC2 },\n                    [2] = { .name = \"offset1\", .type = SG_UNIFORMTYPE_VEC2 },\n                    [3] = { .name = \"offset2\", .type = SG_UNIFORMTYPE_VEC2 },\n                }\n            }\n        };\n\n    With this information sokol-gfx can now compute the correct offsets of the data items\n    within the uniform block struct.\n\n    The SG_UNIFORMLAYOUT_NATIVE packing rule works fine if only the GL backends are used,\n    but for proper D3D11/Metal/GL a subset of the std140 layout must be used which is\n    described in the next section:\n\n\n    CROSS-BACKEND COMMON UNIFORM DATA LAYOUT\n    ========================================\n    For cross-platform / cross-3D-backend code it is important that the same uniform block\n    layout on the CPU side can be used for all sokol-gfx backends. To achieve this,\n    a common subset of the std140 layout must be used:\n\n    - The uniform block layout hint in sg_shader_desc must be explicitly set to\n      SG_UNIFORMLAYOUT_STD140.\n    - Only the following GLSL uniform types can be used (with their associated sokol-gfx enums):\n        - float => SG_UNIFORMTYPE_FLOAT\n        - vec2  => SG_UNIFORMTYPE_FLOAT2\n        - vec3  => SG_UNIFORMTYPE_FLOAT3\n        - vec4  => SG_UNIFORMTYPE_FLOAT4\n        - int   => SG_UNIFORMTYPE_INT\n        - ivec2 => SG_UNIFORMTYPE_INT2\n        - ivec3 => SG_UNIFORMTYPE_INT3\n        - ivec4 => SG_UNIFORMTYPE_INT4\n        - mat4  => SG_UNIFORMTYPE_MAT4\n    - Alignment for those types must be as follows (in bytes):\n        - float => 4\n        - vec2  => 8\n        - vec3  => 16\n        - vec4  => 16\n        - int   => 4\n        - ivec2 => 8\n        - ivec3 => 16\n        - ivec4 => 16\n        - mat4  => 16\n    - Arrays are only allowed for the following types: vec4, int4, mat4.\n\n    Note that the HLSL cbuffer layout rules are slightly different from the\n    std140 layout rules, this means that the cbuffer declarations in HLSL code\n    must be tweaked so that the layout is compatible with std140.\n\n    The by far easiest way to tackle the common uniform block layout problem is\n    to use the sokol-shdc shader cross-compiler tool!\n\n    ON STORAGE BUFFERS\n    ==================\n    Storage buffers can be used to pass large amounts of random access structured\n    data from the CPU side to the shaders. They are similar to data textures, but are\n    more convenient to use both on the CPU and shader side since they can be accessed\n    in shaders as as a 1-dimensional array of struct items.\n\n    Storage buffers are *NOT* supported on the following platform/backend combos:\n\n    - macOS+GL (because storage buffers require GL 4.3, while macOS only goes up to GL 4.1)\n    - all GLES3 platforms (WebGL2, iOS, Android - with the option that support on\n      Android may be added at a later point)\n\n    Currently only 'readonly' storage buffers are supported (meaning it's not possible\n    to write to storage buffers from shaders).\n\n    To use storage buffers, the following steps are required:\n\n        - write a shader which uses storage buffers (also see the example links below)\n        - create one or more storage buffers via sg_make_buffer() with the\n          buffer type SG_BUFFERTYPE_STORAGEBUFFER\n        - when creating a shader via sg_make_shader(), populate the sg_shader_desc\n          struct with binding info (when using sokol-shdc, this step will be taken care\n          of automatically)\n            - which storage buffer bind slots on the vertex- and fragment-stage\n              are occupied\n            - whether the storage buffer on that bind slot is readonly (this is currently required\n              to be true)\n        - when calling sg_apply_bindings(), apply the matching bind slots with the previously\n          created storage buffers\n        - ...and that's it.\n\n    For more details, see the following backend-agnostic sokol samples:\n\n    - simple vertex pulling from a storage buffer:\n        - C code: https://github.com/floooh/sokol-samples/blob/master/sapp/vertexpull-sapp.c\n        - shader: https://github.com/floooh/sokol-samples/blob/master/sapp/vertexpull-sapp.glsl\n    - instanced rendering via storage buffers (vertex- and instance-pulling):\n        - C code: https://github.com/floooh/sokol-samples/blob/master/sapp/instancing-pull-sapp.c\n        - shader: https://github.com/floooh/sokol-samples/blob/master/sapp/instancing-pull-sapp.glsl\n    - storage buffers both on the vertex- and fragment-stage:\n        - C code: https://github.com/floooh/sokol-samples/blob/master/sapp/sbuftex-sapp.c\n        - shader: https://github.com/floooh/sokol-samples/blob/master/sapp/sbuftex-sapp.glsl\n    - the Ozz animation sample rewritten to pull all rendering data from storage buffers:\n        - C code: https://github.com/floooh/sokol-samples/blob/master/sapp/ozz-storagebuffer-sapp.cc\n        - shader: https://github.com/floooh/sokol-samples/blob/master/sapp/ozz-storagebuffer-sapp.glsl\n\n    ...also see the following backend-specific vertex pulling samples (those also don't use sokol-shdc):\n\n    - D3D11: https://github.com/floooh/sokol-samples/blob/master/d3d11/vertexpulling-d3d11.c\n    - desktop GL: https://github.com/floooh/sokol-samples/blob/master/glfw/vertexpulling-glfw.c\n    - Metal: https://github.com/floooh/sokol-samples/blob/master/metal/vertexpulling-metal.c\n    - WebGPU: https://github.com/floooh/sokol-samples/blob/master/wgpu/vertexpulling-wgpu.c\n\n    Storage buffer shader authoring caveats when using sokol-shdc:\n\n        - declare a storage buffer interface block with `layout(binding=N) readonly buffer [name] { ... }`\n          (where 'N' is the index in `sg_bindings.storage_buffers[N]`)\n        - declare a struct which describes a single array item in the storage buffer interface block\n        - only put a single flexible array member into the storage buffer interface block\n\n        E.g. a complete example in 'sokol-shdc GLSL':\n\n        ```glsl\n        // declare a struct:\n        struct sb_vertex {\n            vec3 pos;\n            vec4 color;\n        }\n        // declare a buffer interface block with a single flexible struct array:\n        layout(binding=0) readonly buffer vertices {\n            sb_vertex vtx[];\n        }\n        // in the shader function, access the storage buffer like this:\n        void main() {\n            vec3 pos = vtx[gl_VertexIndex].pos;\n            ...\n        }\n        ```\n\n    Backend-specific storage-buffer caveats (not relevant when using sokol-shdc):\n\n        D3D11:\n            - storage buffers are created as 'raw' Byte Address Buffers\n              (https://learn.microsoft.com/en-us/windows/win32/direct3d11/overviews-direct3d-11-resources-intro#raw-views-of-buffers)\n            - in HLSL, use a ByteAddressBuffer to access the buffer content\n              (https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/sm5-object-byteaddressbuffer)\n            - in D3D11, storage buffers and textures share the same bind slots (declared as\n              `register(tN)` in HLSL), where N must be in the range 0..23)\n\n        Metal:\n            - in Metal there is no internal difference between vertex-, uniform- and\n              storage-buffers, all are bound to the same 'buffer bind slots' with the\n              following reserved ranges:\n                - vertex shader stage:\n                    - uniform buffers: slots 0..7\n                    - storage buffers: slots 8..15\n                    - vertex buffers: slots 15..23\n                - fragment shader stage:\n                    - uniform buffers: slots 0..7\n                    - storage buffers: slots 8..15\n            - this means in MSL, storage buffer bindings start at [[buffer(8)]] both in\n              the vertex and fragment stage\n\n        GL:\n            - the GL backend doesn't use name-lookup to find storage buffer bindings, this\n              means you must annotate buffers with `layout(std430, binding=N)` in GLSL\n            - ...where N is 0..7 in the vertex shader, and 8..15 in the fragment shader\n\n        WebGPU:\n            - in WGSL, textures, samplers and storage buffers all use a shared\n              bindspace across all shader stages on bindgroup 1:\n\n              `@group(1) @binding(0..127)\n\n    TRACE HOOKS:\n    ============\n    sokol_gfx.h optionally allows to install \"trace hook\" callbacks for\n    each public API functions. When a public API function is called, and\n    a trace hook callback has been installed for this function, the\n    callback will be invoked with the parameters and result of the function.\n    This is useful for things like debugging- and profiling-tools, or\n    keeping track of resource creation and destruction.\n\n    To use the trace hook feature:\n\n    --- Define SOKOL_TRACE_HOOKS before including the implementation.\n\n    --- Setup an sg_trace_hooks structure with your callback function\n        pointers (keep all function pointers you're not interested\n        in zero-initialized), optionally set the user_data member\n        in the sg_trace_hooks struct.\n\n    --- Install the trace hooks by calling sg_install_trace_hooks(),\n        the return value of this function is another sg_trace_hooks\n        struct which contains the previously set of trace hooks.\n        You should keep this struct around, and call those previous\n        functions pointers from your own trace callbacks for proper\n        chaining.\n\n    As an example of how trace hooks are used, have a look at the\n    imgui/sokol_gfx_imgui.h header which implements a realtime\n    debugging UI for sokol_gfx.h on top of Dear ImGui.\n\n\n    A NOTE ON PORTABLE PACKED VERTEX FORMATS:\n    =========================================\n    There are two things to consider when using packed\n    vertex formats like UBYTE4, SHORT2, etc which need to work\n    across all backends:\n\n    - D3D11 can only convert *normalized* vertex formats to\n      floating point during vertex fetch, normalized formats\n      have a trailing 'N', and are \"normalized\" to a range\n      -1.0..+1.0 (for the signed formats) or 0.0..1.0 (for the\n      unsigned formats):\n\n        - SG_VERTEXFORMAT_BYTE4N\n        - SG_VERTEXFORMAT_UBYTE4N\n        - SG_VERTEXFORMAT_SHORT2N\n        - SG_VERTEXFORMAT_USHORT2N\n        - SG_VERTEXFORMAT_SHORT4N\n        - SG_VERTEXFORMAT_USHORT4N\n\n      D3D11 will not convert *non-normalized* vertex formats to floating point\n      vertex shader inputs, those can only be uses with the *ivecn* vertex shader\n      input types when D3D11 is used as backend (GL and Metal can use both formats)\n\n        - SG_VERTEXFORMAT_BYTE4,\n        - SG_VERTEXFORMAT_UBYTE4\n        - SG_VERTEXFORMAT_SHORT2\n        - SG_VERTEXFORMAT_SHORT4\n\n    For a vertex input layout which works on all platforms, only use the following\n    vertex formats, and if needed \"expand\" the normalized vertex shader\n    inputs in the vertex shader by multiplying with 127.0, 255.0, 32767.0 or\n    65535.0:\n\n        - SG_VERTEXFORMAT_FLOAT,\n        - SG_VERTEXFORMAT_FLOAT2,\n        - SG_VERTEXFORMAT_FLOAT3,\n        - SG_VERTEXFORMAT_FLOAT4,\n        - SG_VERTEXFORMAT_BYTE4N,\n        - SG_VERTEXFORMAT_UBYTE4N,\n        - SG_VERTEXFORMAT_SHORT2N,\n        - SG_VERTEXFORMAT_USHORT2N\n        - SG_VERTEXFORMAT_SHORT4N,\n        - SG_VERTEXFORMAT_USHORT4N\n        - SG_VERTEXFORMAT_UINT10_N2\n        - SG_VERTEXFORMAT_HALF2\n        - SG_VERTEXFORMAT_HALF4\n\n\n    MEMORY ALLOCATION OVERRIDE\n    ==========================\n    You can override the memory allocation functions at initialization time\n    like this:\n\n        void* my_alloc(size_t size, void* user_data) {\n            return malloc(size);\n        }\n\n        void my_free(void* ptr, void* user_data) {\n            free(ptr);\n        }\n\n        ...\n            sg_setup(&(sg_desc){\n                // ...\n                .allocator = {\n                    .alloc_fn = my_alloc,\n                    .free_fn = my_free,\n                    .user_data = ...,\n                }\n            });\n        ...\n\n    If no overrides are provided, malloc and free will be used.\n\n    This only affects memory allocation calls done by sokol_gfx.h\n    itself though, not any allocations in OS libraries.\n\n\n    ERROR REPORTING AND LOGGING\n    ===========================\n    To get any logging information at all you need to provide a logging callback in the setup call\n    the easiest way is to use sokol_log.h:\n\n        #include \"sokol_log.h\"\n\n        sg_setup(&(sg_desc){ .logger.func = slog_func });\n\n    To override logging with your own callback, first write a logging function like this:\n\n        void my_log(const char* tag,                // e.g. 'sg'\n                    uint32_t log_level,             // 0=panic, 1=error, 2=warn, 3=info\n                    uint32_t log_item_id,           // SG_LOGITEM_*\n                    const char* message_or_null,    // a message string, may be nullptr in release mode\n                    uint32_t line_nr,               // line number in sokol_gfx.h\n                    const char* filename_or_null,   // source filename, may be nullptr in release mode\n                    void* user_data)\n        {\n            ...\n        }\n\n    ...and then setup sokol-gfx like this:\n\n        sg_setup(&(sg_desc){\n            .logger = {\n                .func = my_log,\n                .user_data = my_user_data,\n            }\n        });\n\n    The provided logging function must be reentrant (e.g. be callable from\n    different threads).\n\n    If you don't want to provide your own custom logger it is highly recommended to use\n    the standard logger in sokol_log.h instead, otherwise you won't see any warnings or\n    errors.\n\n\n    COMMIT LISTENERS\n    ================\n    It's possible to hook callback functions into sokol-gfx which are called from\n    inside sg_commit() in unspecified order. This is mainly useful for libraries\n    that build on top of sokol_gfx.h to be notified about the end/start of a frame.\n\n    To add a commit listener, call:\n\n        static void my_commit_listener(void* user_data) {\n            ...\n        }\n\n        bool success = sg_add_commit_listener((sg_commit_listener){\n            .func = my_commit_listener,\n            .user_data = ...,\n        });\n\n    The function returns false if the internal array of commit listeners is full,\n    or the same commit listener had already been added.\n\n    If the function returns true, my_commit_listener() will be called each frame\n    from inside sg_commit().\n\n    By default, 1024 distinct commit listeners can be added, but this number\n    can be tweaked in the sg_setup() call:\n\n        sg_setup(&(sg_desc){\n            .max_commit_listeners = 2048,\n        });\n\n    An sg_commit_listener item is equal to another if both the function\n    pointer and user_data field are equal.\n\n    To remove a commit listener:\n\n        bool success = sg_remove_commit_listener((sg_commit_listener){\n            .func = my_commit_listener,\n            .user_data = ...,\n        });\n\n    ...where the .func and .user_data field are equal to a previous\n    sg_add_commit_listener() call. The function returns true if the commit\n    listener item was found and removed, and false otherwise.\n\n\n    RESOURCE CREATION AND DESTRUCTION IN DETAIL\n    ===========================================\n    The 'vanilla' way to create resource objects is with the 'make functions':\n\n        sg_buffer sg_make_buffer(const sg_buffer_desc* desc)\n        sg_image sg_make_image(const sg_image_desc* desc)\n        sg_sampler sg_make_sampler(const sg_sampler_desc* desc)\n        sg_shader sg_make_shader(const sg_shader_desc* desc)\n        sg_pipeline sg_make_pipeline(const sg_pipeline_desc* desc)\n        sg_attachments sg_make_attachments(const sg_attachments_desc* desc)\n\n    This will result in one of three cases:\n\n        1. The returned handle is invalid. This happens when there are no more\n           free slots in the resource pool for this resource type. An invalid\n           handle is associated with the INVALID resource state, for instance:\n\n                sg_buffer buf = sg_make_buffer(...)\n                if (sg_query_buffer_state(buf) == SG_RESOURCESTATE_INVALID) {\n                    // buffer pool is exhausted\n                }\n\n        2. The returned handle is valid, but creating the underlying resource\n           has failed for some reason. This results in a resource object in the\n           FAILED state. The reason *why* resource creation has failed differ\n           by resource type. Look for log messages with more details. A failed\n           resource state can be checked with:\n\n                sg_buffer buf = sg_make_buffer(...)\n                if (sg_query_buffer_state(buf) == SG_RESOURCESTATE_FAILED) {\n                    // creating the resource has failed\n                }\n\n        3. And finally, if everything goes right, the returned resource is\n           in resource state VALID and ready to use. This can be checked\n           with:\n\n                sg_buffer buf = sg_make_buffer(...)\n                if (sg_query_buffer_state(buf) == SG_RESOURCESTATE_VALID) {\n                    // creating the resource has failed\n                }\n\n    When calling the 'make functions', the created resource goes through a number\n    of states:\n\n        - INITIAL: the resource slot associated with the new resource is currently\n          free (technically, there is no resource yet, just an empty pool slot)\n        - ALLOC: a handle for the new resource has been allocated, this just means\n          a pool slot has been reserved.\n        - VALID or FAILED: in VALID state any 3D API backend resource objects have\n          been successfully created, otherwise if anything went wrong, the resource\n          will be in FAILED state.\n\n    Sometimes it makes sense to first grab a handle, but initialize the\n    underlying resource at a later time. For instance when loading data\n    asynchronously from a slow data source, you may know what buffers and\n    textures are needed at an early stage of the loading process, but actually\n    loading the buffer or texture content can only be completed at a later time.\n\n    For such situations, sokol-gfx resource objects can be created in two steps.\n    You can allocate a handle upfront with one of the 'alloc functions':\n\n        sg_buffer sg_alloc_buffer(void)\n        sg_image sg_alloc_image(void)\n        sg_sampler sg_alloc_sampler(void)\n        sg_shader sg_alloc_shader(void)\n        sg_pipeline sg_alloc_pipeline(void)\n        sg_attachments sg_alloc_attachments(void)\n\n    This will return a handle with the underlying resource object in the\n    ALLOC state:\n\n        sg_image img = sg_alloc_image();\n        if (sg_query_image_state(img) == SG_RESOURCESTATE_ALLOC) {\n            // allocating an image handle has succeeded, otherwise\n            // the image pool is full\n        }\n\n    Such an 'incomplete' handle can be used in most sokol-gfx rendering functions\n    without doing any harm, sokol-gfx will simply skip any rendering operation\n    that involve resources which are not in VALID state.\n\n    At a later time (for instance once the texture has completed loading\n    asynchronously), the resource creation can be completed by calling one of\n    the 'init functions', those functions take an existing resource handle and\n    'desc struct':\n\n        void sg_init_buffer(sg_buffer buf, const sg_buffer_desc* desc)\n        void sg_init_image(sg_image img, const sg_image_desc* desc)\n        void sg_init_sampler(sg_sampler smp, const sg_sampler_desc* desc)\n        void sg_init_shader(sg_shader shd, const sg_shader_desc* desc)\n        void sg_init_pipeline(sg_pipeline pip, const sg_pipeline_desc* desc)\n        void sg_init_attachments(sg_attachments atts, const sg_attachments_desc* desc)\n\n    The init functions expect a resource in ALLOC state, and after the function\n    returns, the resource will be either in VALID or FAILED state. Calling\n    an 'alloc function' followed by the matching 'init function' is fully\n    equivalent with calling the 'make function' alone.\n\n    Destruction can also happen as a two-step process. The 'uninit functions'\n    will put a resource object from the VALID or FAILED state back into the\n    ALLOC state:\n\n        void sg_uninit_buffer(sg_buffer buf)\n        void sg_uninit_image(sg_image img)\n        void sg_uninit_sampler(sg_sampler smp)\n        void sg_uninit_shader(sg_shader shd)\n        void sg_uninit_pipeline(sg_pipeline pip)\n        void sg_uninit_attachments(sg_attachments pass)\n\n    Calling the 'uninit functions' with a resource that is not in the VALID or\n    FAILED state is a no-op.\n\n    To finally free the pool slot for recycling call the 'dealloc functions':\n\n        void sg_dealloc_buffer(sg_buffer buf)\n        void sg_dealloc_image(sg_image img)\n        void sg_dealloc_sampler(sg_sampler smp)\n        void sg_dealloc_shader(sg_shader shd)\n        void sg_dealloc_pipeline(sg_pipeline pip)\n        void sg_dealloc_attachments(sg_attachments atts)\n\n    Calling the 'dealloc functions' on a resource that's not in ALLOC state is\n    a no-op, but will generate a warning log message.\n\n    Calling an 'uninit function' and 'dealloc function' in sequence is equivalent\n    with calling the associated 'destroy function':\n\n        void sg_destroy_buffer(sg_buffer buf)\n        void sg_destroy_image(sg_image img)\n        void sg_destroy_sampler(sg_sampler smp)\n        void sg_destroy_shader(sg_shader shd)\n        void sg_destroy_pipeline(sg_pipeline pip)\n        void sg_destroy_attachments(sg_attachments atts)\n\n    The 'destroy functions' can be called on resources in any state and generally\n    do the right thing (for instance if the resource is in ALLOC state, the destroy\n    function will be equivalent to the 'dealloc function' and skip the 'uninit part').\n\n    And finally to close the circle, the 'fail functions' can be called to manually\n    put a resource in ALLOC state into the FAILED state:\n\n        sg_fail_buffer(sg_buffer buf)\n        sg_fail_image(sg_image img)\n        sg_fail_sampler(sg_sampler smp)\n        sg_fail_shader(sg_shader shd)\n        sg_fail_pipeline(sg_pipeline pip)\n        sg_fail_attachments(sg_attachments atts)\n\n    This is recommended if anything went wrong outside of sokol-gfx during asynchronous\n    resource setup (for instance a file loading operation failed). In this case,\n    the 'fail function' should be called instead of the 'init function'.\n\n    Calling a 'fail function' on a resource that's not in ALLOC state is a no-op,\n    but will generate a warning log message.\n\n    NOTE: that two-step resource creation usually only makes sense for buffers\n    and images, but not for samplers, shaders, pipelines or attachments. Most notably, trying\n    to create a pipeline object with a shader that's not in VALID state will\n    trigger a validation layer error, or if the validation layer is disabled,\n    result in a pipeline object in FAILED state. Same when trying to create\n    an attachments object with invalid image objects.\n\n\n    WEBGPU CAVEATS\n    ==============\n    For a general overview and design notes of the WebGPU backend see:\n\n        https://floooh.github.io/2023/10/16/sokol-webgpu.html\n\n    In general, don't expect an automatic speedup when switching from the WebGL2\n    backend to the WebGPU backend. Some WebGPU functions currently actually\n    have a higher CPU overhead than similar WebGL2 functions, leading to the\n    paradoxical situation that some WebGPU code may be slower than similar WebGL2\n    code.\n\n    - when writing WGSL shader code by hand, a specific bind-slot convention\n      must be used:\n\n      All uniform block structs must use `@group(0)` and bindings in the\n      range 0..127:\n\n        @group(0) @binding(0..7)\n\n      All textures, samplers and storage buffers must use `@group(1)` and\n      bindings must be in the range 0..127:\n\n        @group(1) @binding(0..127)\n\n      Note that the number of texture, sampler and storage buffer bindings\n      is still limited despite the large bind range:\n\n        - up to 16 textures and sampler across all shader stages\n        - up to 8 storage buffers across all shader stages\n\n      If you use sokol-shdc to generate WGSL shader code, you don't need to worry\n      about the above binding conventions since sokol-shdc.\n\n    - The sokol-gfx WebGPU backend uses the sg_desc.uniform_buffer_size item\n      to allocate a single per-frame uniform buffer which must be big enough\n      to hold all data written by sg_apply_uniforms() during a single frame,\n      including a worst-case 256-byte alignment (e.g. each sg_apply_uniform\n      call will cost at least 256 bytes of uniform buffer size). The default size\n      is 4 MB, which is enough for 16384 sg_apply_uniform() calls per\n      frame (assuming the uniform data 'payload' is less than 256 bytes\n      per call). These rules are the same as for the Metal backend, so if\n      you are already using the Metal backend you'll be fine.\n\n    - sg_apply_bindings(): the sokol-gfx WebGPU backend implements a bindgroup\n      cache to prevent excessive creation and destruction of BindGroup objects\n      when calling sg_apply_bindings(). The number of slots in the bindgroups\n      cache is defined in sg_desc.wgpu_bindgroups_cache_size when calling\n      sg_setup. The cache size must be a power-of-2 number, with the default being\n      1024. The bindgroups cache behaviour can be observed by calling the new\n      function sg_query_frame_stats(), where the following struct items are\n      of interest:\n\n        .wgpu.num_bindgroup_cache_hits\n        .wgpu.num_bindgroup_cache_misses\n        .wgpu.num_bindgroup_cache_collisions\n        .wgpu_num_bindgroup_cache_invalidates\n        .wgpu.num_bindgroup_cache_vs_hash_key_mismatch\n\n      The value to pay attention to is `.wgpu.num_bindgroup_cache_collisions`,\n      if this number is consistently higher than a few percent of the\n      .wgpu.num_set_bindgroup value, it might be a good idea to bump the\n      bindgroups cache size to the next power-of-2.\n\n    - sg_apply_viewport(): WebGPU currently has a unique restriction that viewport\n      rectangles must be contained entirely within the framebuffer. As a shitty\n      workaround sokol_gfx.h will clip incoming viewport rectangles against\n      the framebuffer, but this will distort the clipspace-to-screenspace mapping.\n      There's no proper way to handle this inside sokol_gfx.h, this must be fixed\n      in a future WebGPU update.\n\n    - The sokol shader compiler generally adds `diagnostic(off, derivative_uniformity);`\n      into the WGSL output. Currently only the Chrome WebGPU implementation seems\n      to recognize this.\n\n    - The vertex format SG_VERTEXFORMAT_UINT10_N2 is currently not supported because\n      WebGPU lacks a matching vertex format (this is currently being worked on though,\n      as soon as the vertex format shows up in webgpu.h, sokol_gfx.h will add support.\n\n    - Likewise, the following sokol-gfx vertex formats are not supported in WebGPU:\n      R16, R16SN, RG16, RG16SN, RGBA16, RGBA16SN and all PVRTC compressed format.\n      Unlike unsupported vertex formats, unsupported pixel formats can be queried\n      in cross-backend code via sg_query_pixel_format() though.\n\n    - The Emscripten WebGPU shim currently doesn't support the Closure minification\n      post-link-step (e.g. currently the emcc argument '--closure 1' or '--closure 2'\n      will generate broken Javascript code.\n\n    - sokol-gfx requires the WebGPU device feature `depth32float-stencil8` to be enabled\n      (this should be widely supported)\n\n    - sokol-gfx expects that the WebGPU device feature `float32-filterable` to *not* be\n      enabled (since this would exclude all iOS devices)\n\n\n    LICENSE\n    =======\n    zlib/libpng license\n\n    Copyright (c) 2018 Andre Weissflog\n\n    This software is provided 'as-is', without any express or implied warranty.\n    In no event will the authors be held liable for any damages arising from the\n    use of this software.\n\n    Permission is granted to anyone to use this software for any purpose,\n    including commercial applications, and to alter it and redistribute it\n    freely, subject to the following restrictions:\n\n        1. The origin of this software must not be misrepresented; you must not\n        claim that you wrote the original software. If you use this software in a\n        product, an acknowledgment in the product documentation would be\n        appreciated but is not required.\n\n        2. Altered source versions must be plainly marked as such, and must not\n        be misrepresented as being the original software.\n\n        3. This notice may not be removed or altered from any source\n        distribution.\n*/\n#define SOKOL_GFX_INCLUDED (1)\n#include <stddef.h>     // size_t\n#include <stdint.h>\n#include <stdbool.h>\n\n#if defined(SOKOL_API_DECL) && !defined(SOKOL_GFX_API_DECL)\n#define SOKOL_GFX_API_DECL SOKOL_API_DECL\n#endif\n#ifndef SOKOL_GFX_API_DECL\n#if defined(_WIN32) && defined(SOKOL_DLL) && defined(SOKOL_GFX_IMPL)\n#define SOKOL_GFX_API_DECL __declspec(dllexport)\n#elif defined(_WIN32) && defined(SOKOL_DLL)\n#define SOKOL_GFX_API_DECL __declspec(dllimport)\n#else\n#define SOKOL_GFX_API_DECL extern\n#endif\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/*\n    Resource id typedefs:\n\n    sg_buffer:      vertex- and index-buffers\n    sg_image:       images used as textures and render-pass attachments\n    sg_sampler      sampler objects describing how a texture is sampled in a shader\n    sg_shader:      vertex- and fragment-shaders and shader interface information\n    sg_pipeline:    associated shader and vertex-layouts, and render states\n    sg_attachments: a baked collection of render pass attachment images\n\n    Instead of pointers, resource creation functions return a 32-bit\n    handle which uniquely identifies the resource object.\n\n    The 32-bit resource id is split into a 16-bit pool index in the lower bits,\n    and a 16-bit 'generation counter' in the upper bits. The index allows fast\n    pool lookups, and combined with the generation-counter it allows to detect\n    'dangling accesses' (trying to use an object which no longer exists, and\n    its pool slot has been reused for a new object)\n\n    The resource ids are wrapped into a strongly-typed struct so that\n    trying to pass an incompatible resource id is a compile error.\n*/\ntypedef struct sg_buffer        { uint32_t id; } sg_buffer;\ntypedef struct sg_image         { uint32_t id; } sg_image;\ntypedef struct sg_sampler       { uint32_t id; } sg_sampler;\ntypedef struct sg_shader        { uint32_t id; } sg_shader;\ntypedef struct sg_pipeline      { uint32_t id; } sg_pipeline;\ntypedef struct sg_attachments   { uint32_t id; } sg_attachments;\n\n/*\n    sg_range is a pointer-size-pair struct used to pass memory blobs into\n    sokol-gfx. When initialized from a value type (array or struct), you can\n    use the SG_RANGE() macro to build an sg_range struct. For functions which\n    take either a sg_range pointer, or a (C++) sg_range reference, use the\n    SG_RANGE_REF macro as a solution which compiles both in C and C++.\n*/\ntypedef struct sg_range {\n    const void* ptr;\n    size_t size;\n} sg_range;\n\n// disabling this for every includer isn't great, but the warnings are also quite pointless\n#if defined(_MSC_VER)\n#pragma warning(disable:4221)   // /W4 only: nonstandard extension used: 'x': cannot be initialized using address of automatic variable 'y'\n#pragma warning(disable:4204)   // VS2015: nonstandard extension used: non-constant aggregate initializer\n#endif\n#if defined(__cplusplus)\n#define SG_RANGE(x) sg_range{ &x, sizeof(x) }\n#define SG_RANGE_REF(x) sg_range{ &x, sizeof(x) }\n#else\n#define SG_RANGE(x) (sg_range){ &x, sizeof(x) }\n#define SG_RANGE_REF(x) &(sg_range){ &x, sizeof(x) }\n#endif\n\n// various compile-time constants in the public API\nenum {\n    SG_INVALID_ID = 0,\n    SG_NUM_INFLIGHT_FRAMES = 2,\n    SG_MAX_COLOR_ATTACHMENTS = 4,\n    SG_MAX_UNIFORMBLOCK_MEMBERS = 16,\n    SG_MAX_VERTEX_ATTRIBUTES = 16,\n    SG_MAX_MIPMAPS = 16,\n    SG_MAX_TEXTUREARRAY_LAYERS = 128,\n    SG_MAX_UNIFORMBLOCK_BINDSLOTS = 8,\n    SG_MAX_VERTEXBUFFER_BINDSLOTS = 8,\n    SG_MAX_IMAGE_BINDSLOTS = 16,\n    SG_MAX_SAMPLER_BINDSLOTS = 16,\n    SG_MAX_STORAGEBUFFER_BINDSLOTS = 8,\n    SG_MAX_IMAGE_SAMPLER_PAIRS = 16,\n};\n\n/*\n    sg_color\n\n    An RGBA color value.\n*/\ntypedef struct sg_color { float r, g, b, a; } sg_color;\n\n/*\n    sg_backend\n\n    The active 3D-API backend, use the function sg_query_backend()\n    to get the currently active backend.\n*/\ntypedef enum sg_backend {\n    SG_BACKEND_GLCORE,\n    SG_BACKEND_GLES3,\n    SG_BACKEND_D3D11,\n    SG_BACKEND_METAL_IOS,\n    SG_BACKEND_METAL_MACOS,\n    SG_BACKEND_METAL_SIMULATOR,\n    SG_BACKEND_WGPU,\n    SG_BACKEND_DUMMY,\n} sg_backend;\n\n/*\n    sg_pixel_format\n\n    sokol_gfx.h basically uses the same pixel formats as WebGPU, since these\n    are supported on most newer GPUs.\n\n    A pixelformat name consist of three parts:\n\n        - components (R, RG, RGB or RGBA)\n        - bit width per component (8, 16 or 32)\n        - component data type:\n            - unsigned normalized (no postfix)\n            - signed normalized (SN postfix)\n            - unsigned integer (UI postfix)\n            - signed integer (SI postfix)\n            - float (F postfix)\n\n    Not all pixel formats can be used for everything, call sg_query_pixelformat()\n    to inspect the capabilities of a given pixelformat. The function returns\n    an sg_pixelformat_info struct with the following members:\n\n        - sample: the pixelformat can be sampled as texture at least with\n                  nearest filtering\n        - filter: the pixelformat can be sampled as texture with linear\n                  filtering\n        - render: the pixelformat can be used as render-pass attachment\n        - blend:  blending is supported when used as render-pass attachment\n        - msaa:   multisample-antialiasing is supported when used\n                  as render-pass attachment\n        - depth:  the pixelformat can be used for depth-stencil attachments\n        - compressed: this is a block-compressed format\n        - bytes_per_pixel: the numbers of bytes in a pixel (0 for compressed formats)\n\n    The default pixel format for texture images is SG_PIXELFORMAT_RGBA8.\n\n    The default pixel format for render target images is platform-dependent\n    and taken from the sg_environment struct passed into sg_setup(). Typically\n    the default formats are:\n\n        - for the Metal, D3D11 and WebGPU backends: SG_PIXELFORMAT_BGRA8\n        - for GL backends: SG_PIXELFORMAT_RGBA8\n*/\ntypedef enum sg_pixel_format {\n    _SG_PIXELFORMAT_DEFAULT,    // value 0 reserved for default-init\n    SG_PIXELFORMAT_NONE,\n\n    SG_PIXELFORMAT_R8,\n    SG_PIXELFORMAT_R8SN,\n    SG_PIXELFORMAT_R8UI,\n    SG_PIXELFORMAT_R8SI,\n\n    SG_PIXELFORMAT_R16,\n    SG_PIXELFORMAT_R16SN,\n    SG_PIXELFORMAT_R16UI,\n    SG_PIXELFORMAT_R16SI,\n    SG_PIXELFORMAT_R16F,\n    SG_PIXELFORMAT_RG8,\n    SG_PIXELFORMAT_RG8SN,\n    SG_PIXELFORMAT_RG8UI,\n    SG_PIXELFORMAT_RG8SI,\n\n    SG_PIXELFORMAT_R32UI,\n    SG_PIXELFORMAT_R32SI,\n    SG_PIXELFORMAT_R32F,\n    SG_PIXELFORMAT_RG16,\n    SG_PIXELFORMAT_RG16SN,\n    SG_PIXELFORMAT_RG16UI,\n    SG_PIXELFORMAT_RG16SI,\n    SG_PIXELFORMAT_RG16F,\n    SG_PIXELFORMAT_RGBA8,\n    SG_PIXELFORMAT_SRGB8A8,\n    SG_PIXELFORMAT_RGBA8SN,\n    SG_PIXELFORMAT_RGBA8UI,\n    SG_PIXELFORMAT_RGBA8SI,\n    SG_PIXELFORMAT_BGRA8,\n    SG_PIXELFORMAT_RGB10A2,\n    SG_PIXELFORMAT_RG11B10F,\n    SG_PIXELFORMAT_RGB9E5,\n\n    SG_PIXELFORMAT_RG32UI,\n    SG_PIXELFORMAT_RG32SI,\n    SG_PIXELFORMAT_RG32F,\n    SG_PIXELFORMAT_RGBA16,\n    SG_PIXELFORMAT_RGBA16SN,\n    SG_PIXELFORMAT_RGBA16UI,\n    SG_PIXELFORMAT_RGBA16SI,\n    SG_PIXELFORMAT_RGBA16F,\n\n    SG_PIXELFORMAT_RGBA32UI,\n    SG_PIXELFORMAT_RGBA32SI,\n    SG_PIXELFORMAT_RGBA32F,\n\n    // NOTE: when adding/removing pixel formats before DEPTH, also update sokol_app.h/_SAPP_PIXELFORMAT_*\n    SG_PIXELFORMAT_DEPTH,\n    SG_PIXELFORMAT_DEPTH_STENCIL,\n\n    // NOTE: don't put any new compressed format in front of here\n    SG_PIXELFORMAT_BC1_RGBA,\n    SG_PIXELFORMAT_BC2_RGBA,\n    SG_PIXELFORMAT_BC3_RGBA,\n    SG_PIXELFORMAT_BC3_SRGBA,\n    SG_PIXELFORMAT_BC4_R,\n    SG_PIXELFORMAT_BC4_RSN,\n    SG_PIXELFORMAT_BC5_RG,\n    SG_PIXELFORMAT_BC5_RGSN,\n    SG_PIXELFORMAT_BC6H_RGBF,\n    SG_PIXELFORMAT_BC6H_RGBUF,\n    SG_PIXELFORMAT_BC7_RGBA,\n    SG_PIXELFORMAT_BC7_SRGBA,\n    SG_PIXELFORMAT_PVRTC_RGB_2BPP,      // FIXME: deprecated\n    SG_PIXELFORMAT_PVRTC_RGB_4BPP,      // FIXME: deprecated\n    SG_PIXELFORMAT_PVRTC_RGBA_2BPP,     // FIXME: deprecated\n    SG_PIXELFORMAT_PVRTC_RGBA_4BPP,     // FIXME: deprecated\n    SG_PIXELFORMAT_ETC2_RGB8,\n    SG_PIXELFORMAT_ETC2_SRGB8,\n    SG_PIXELFORMAT_ETC2_RGB8A1,\n    SG_PIXELFORMAT_ETC2_RGBA8,\n    SG_PIXELFORMAT_ETC2_SRGB8A8,\n    SG_PIXELFORMAT_EAC_R11,\n    SG_PIXELFORMAT_EAC_R11SN,\n    SG_PIXELFORMAT_EAC_RG11,\n    SG_PIXELFORMAT_EAC_RG11SN,\n\n    SG_PIXELFORMAT_ASTC_4x4_RGBA,\n    SG_PIXELFORMAT_ASTC_4x4_SRGBA,\n\n    _SG_PIXELFORMAT_NUM,\n    _SG_PIXELFORMAT_FORCE_U32 = 0x7FFFFFFF\n} sg_pixel_format;\n\n/*\n    Runtime information about a pixel format, returned by sg_query_pixelformat().\n*/\ntypedef struct sg_pixelformat_info {\n    bool sample;            // pixel format can be sampled in shaders at least with nearest filtering\n    bool filter;            // pixel format can be sampled with linear filtering\n    bool render;            // pixel format can be used as render-pass attachment\n    bool blend;             // pixel format supports alpha-blending when used as render-pass attachment\n    bool msaa;              // pixel format supports MSAA when used as render-pass attachment\n    bool depth;             // pixel format is a depth format\n    bool compressed;        // true if this is a hardware-compressed format\n    int bytes_per_pixel;    // NOTE: this is 0 for compressed formats, use sg_query_row_pitch() / sg_query_surface_pitch() as alternative\n} sg_pixelformat_info;\n\n/*\n    Runtime information about available optional features, returned by sg_query_features()\n*/\ntypedef struct sg_features {\n    bool origin_top_left;               // framebuffer- and texture-origin is in top left corner\n    bool image_clamp_to_border;         // border color and clamp-to-border uv-wrap mode is supported\n    bool mrt_independent_blend_state;   // multiple-render-target rendering can use per-render-target blend state\n    bool mrt_independent_write_mask;    // multiple-render-target rendering can use per-render-target color write masks\n    bool storage_buffer;                // storage buffers are supported\n    bool msaa_image_bindings;           // if true, multisampled images can be bound as texture resources\n} sg_features;\n\n/*\n    Runtime information about resource limits, returned by sg_query_limit()\n*/\ntypedef struct sg_limits {\n    int max_image_size_2d;          // max width/height of SG_IMAGETYPE_2D images\n    int max_image_size_cube;        // max width/height of SG_IMAGETYPE_CUBE images\n    int max_image_size_3d;          // max width/height/depth of SG_IMAGETYPE_3D images\n    int max_image_size_array;       // max width/height of SG_IMAGETYPE_ARRAY images\n    int max_image_array_layers;     // max number of layers in SG_IMAGETYPE_ARRAY images\n    int max_vertex_attrs;           // max number of vertex attributes, clamped to SG_MAX_VERTEX_ATTRIBUTES\n    int gl_max_vertex_uniform_components;    // <= GL_MAX_VERTEX_UNIFORM_COMPONENTS (only on GL backends)\n    int gl_max_combined_texture_image_units; // <= GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS (only on GL backends)\n} sg_limits;\n\n/*\n    sg_resource_state\n\n    The current state of a resource in its resource pool.\n    Resources start in the INITIAL state, which means the\n    pool slot is unoccupied and can be allocated. When a resource is\n    created, first an id is allocated, and the resource pool slot\n    is set to state ALLOC. After allocation, the resource is\n    initialized, which may result in the VALID or FAILED state. The\n    reason why allocation and initialization are separate is because\n    some resource types (e.g. buffers and images) might be asynchronously\n    initialized by the user application. If a resource which is not\n    in the VALID state is attempted to be used for rendering, rendering\n    operations will silently be dropped.\n\n    The special INVALID state is returned in sg_query_xxx_state() if no\n    resource object exists for the provided resource id.\n*/\ntypedef enum sg_resource_state {\n    SG_RESOURCESTATE_INITIAL,\n    SG_RESOURCESTATE_ALLOC,\n    SG_RESOURCESTATE_VALID,\n    SG_RESOURCESTATE_FAILED,\n    SG_RESOURCESTATE_INVALID,\n    _SG_RESOURCESTATE_FORCE_U32 = 0x7FFFFFFF\n} sg_resource_state;\n\n/*\n    sg_usage\n\n    A resource usage hint describing the update strategy of\n    buffers and images. This is used in the sg_buffer_desc.usage\n    and sg_image_desc.usage members when creating buffers\n    and images:\n\n    SG_USAGE_IMMUTABLE:     the resource will never be updated with\n                            new data, instead the content of the\n                            resource must be provided on creation\n    SG_USAGE_DYNAMIC:       the resource will be updated infrequently\n                            with new data (this could range from \"once\n                            after creation\", to \"quite often but not\n                            every frame\")\n    SG_USAGE_STREAM:        the resource will be updated each frame\n                            with new content\n\n    The rendering backends use this hint to prevent that the\n    CPU needs to wait for the GPU when attempting to update\n    a resource that might be currently accessed by the GPU.\n\n    Resource content is updated with the functions sg_update_buffer() or\n    sg_append_buffer() for buffer objects, and sg_update_image() for image\n    objects. For the sg_update_*() functions, only one update is allowed per\n    frame and resource object, while sg_append_buffer() can be called\n    multiple times per frame on the same buffer. The application must update\n    all data required for rendering (this means that the update data can be\n    smaller than the resource size, if only a part of the overall resource\n    size is used for rendering, you only need to make sure that the data that\n    *is* used is valid).\n\n    The default usage is SG_USAGE_IMMUTABLE.\n*/\ntypedef enum sg_usage {\n    _SG_USAGE_DEFAULT,      // value 0 reserved for default-init\n    SG_USAGE_IMMUTABLE,\n    SG_USAGE_DYNAMIC,\n    SG_USAGE_STREAM,\n    _SG_USAGE_NUM,\n    _SG_USAGE_FORCE_U32 = 0x7FFFFFFF\n} sg_usage;\n\n/*\n    sg_buffer_type\n\n    Indicates whether a buffer will be bound as vertex-,\n    index- or storage-buffer.\n\n    Used in the sg_buffer_desc.type member when creating a buffer.\n\n    The default value is SG_BUFFERTYPE_VERTEXBUFFER.\n*/\ntypedef enum sg_buffer_type {\n    _SG_BUFFERTYPE_DEFAULT,         // value 0 reserved for default-init\n    SG_BUFFERTYPE_VERTEXBUFFER,\n    SG_BUFFERTYPE_INDEXBUFFER,\n    SG_BUFFERTYPE_STORAGEBUFFER,\n    _SG_BUFFERTYPE_NUM,\n    _SG_BUFFERTYPE_FORCE_U32 = 0x7FFFFFFF\n} sg_buffer_type;\n\n/*\n    sg_index_type\n\n    Indicates whether indexed rendering (fetching vertex-indices from an\n    index buffer) is used, and if yes, the index data type (16- or 32-bits).\n\n    This is used in the sg_pipeline_desc.index_type member when creating a\n    pipeline object.\n\n    The default index type is SG_INDEXTYPE_NONE.\n*/\ntypedef enum sg_index_type {\n    _SG_INDEXTYPE_DEFAULT,   // value 0 reserved for default-init\n    SG_INDEXTYPE_NONE,\n    SG_INDEXTYPE_UINT16,\n    SG_INDEXTYPE_UINT32,\n    _SG_INDEXTYPE_NUM,\n    _SG_INDEXTYPE_FORCE_U32 = 0x7FFFFFFF\n} sg_index_type;\n\n/*\n    sg_image_type\n\n    Indicates the basic type of an image object (2D-texture, cubemap,\n    3D-texture or 2D-array-texture). Used in the sg_image_desc.type member when\n    creating an image, and in sg_shader_image_desc to describe a sampled texture\n    in the shader (both must match and will be checked in the validation layer\n    when calling sg_apply_bindings).\n\n    The default image type when creating an image is SG_IMAGETYPE_2D.\n*/\ntypedef enum sg_image_type {\n    _SG_IMAGETYPE_DEFAULT,  // value 0 reserved for default-init\n    SG_IMAGETYPE_2D,\n    SG_IMAGETYPE_CUBE,\n    SG_IMAGETYPE_3D,\n    SG_IMAGETYPE_ARRAY,\n    _SG_IMAGETYPE_NUM,\n    _SG_IMAGETYPE_FORCE_U32 = 0x7FFFFFFF\n} sg_image_type;\n\n/*\n    sg_image_sample_type\n\n    The basic data type of a texture sample as expected by a shader.\n    Must be provided in sg_shader_image and used by the validation\n    layer in sg_apply_bindings() to check if the provided image object\n    is compatible with what the shader expects. Apart from the sokol-gfx\n    validation layer, WebGPU is the only backend API which actually requires\n    matching texture and sampler type to be provided upfront for validation\n    (other 3D APIs treat texture/sampler type mismatches as undefined behaviour).\n\n    NOTE that the following texture pixel formats require the use\n    of SG_IMAGESAMPLETYPE_UNFILTERABLE_FLOAT, combined with a sampler\n    of type SG_SAMPLERTYPE_NONFILTERING:\n\n    - SG_PIXELFORMAT_R32F\n    - SG_PIXELFORMAT_RG32F\n    - SG_PIXELFORMAT_RGBA32F\n\n    (when using sokol-shdc, also check out the meta tags `@image_sample_type`\n    and `@sampler_type`)\n*/\ntypedef enum sg_image_sample_type {\n    _SG_IMAGESAMPLETYPE_DEFAULT,  // value 0 reserved for default-init\n    SG_IMAGESAMPLETYPE_FLOAT,\n    SG_IMAGESAMPLETYPE_DEPTH,\n    SG_IMAGESAMPLETYPE_SINT,\n    SG_IMAGESAMPLETYPE_UINT,\n    SG_IMAGESAMPLETYPE_UNFILTERABLE_FLOAT,\n    _SG_IMAGESAMPLETYPE_NUM,\n    _SG_IMAGESAMPLETYPE_FORCE_U32 = 0x7FFFFFFF\n} sg_image_sample_type;\n\n/*\n    sg_sampler_type\n\n    The basic type of a texture sampler (sampling vs comparison) as\n    defined in a shader. Must be provided in sg_shader_sampler_desc.\n\n    sg_image_sample_type and sg_sampler_type for a texture/sampler\n    pair must be compatible with each other, specifically only\n    the following pairs are allowed:\n\n    - SG_IMAGESAMPLETYPE_FLOAT => (SG_SAMPLERTYPE_FILTERING or SG_SAMPLERTYPE_NONFILTERING)\n    - SG_IMAGESAMPLETYPE_UNFILTERABLE_FLOAT => SG_SAMPLERTYPE_NONFILTERING\n    - SG_IMAGESAMPLETYPE_SINT => SG_SAMPLERTYPE_NONFILTERING\n    - SG_IMAGESAMPLETYPE_UINT => SG_SAMPLERTYPE_NONFILTERING\n    - SG_IMAGESAMPLETYPE_DEPTH => SG_SAMPLERTYPE_COMPARISON\n*/\ntypedef enum sg_sampler_type {\n    _SG_SAMPLERTYPE_DEFAULT,\n    SG_SAMPLERTYPE_FILTERING,\n    SG_SAMPLERTYPE_NONFILTERING,\n    SG_SAMPLERTYPE_COMPARISON,\n    _SG_SAMPLERTYPE_NUM,\n    _SG_SAMPLERTYPE_FORCE_U32,\n} sg_sampler_type;\n\n/*\n    sg_cube_face\n\n    The cubemap faces. Use these as indices in the sg_image_desc.content\n    array.\n*/\ntypedef enum sg_cube_face {\n    SG_CUBEFACE_POS_X,\n    SG_CUBEFACE_NEG_X,\n    SG_CUBEFACE_POS_Y,\n    SG_CUBEFACE_NEG_Y,\n    SG_CUBEFACE_POS_Z,\n    SG_CUBEFACE_NEG_Z,\n    SG_CUBEFACE_NUM,\n    _SG_CUBEFACE_FORCE_U32 = 0x7FFFFFFF\n} sg_cube_face;\n\n/*\n    sg_primitive_type\n\n    This is the common subset of 3D primitive types supported across all 3D\n    APIs. This is used in the sg_pipeline_desc.primitive_type member when\n    creating a pipeline object.\n\n    The default primitive type is SG_PRIMITIVETYPE_TRIANGLES.\n*/\ntypedef enum sg_primitive_type {\n    _SG_PRIMITIVETYPE_DEFAULT,  // value 0 reserved for default-init\n    SG_PRIMITIVETYPE_POINTS,\n    SG_PRIMITIVETYPE_LINES,\n    SG_PRIMITIVETYPE_LINE_STRIP,\n    SG_PRIMITIVETYPE_TRIANGLES,\n    SG_PRIMITIVETYPE_TRIANGLE_STRIP,\n    _SG_PRIMITIVETYPE_NUM,\n    _SG_PRIMITIVETYPE_FORCE_U32 = 0x7FFFFFFF\n} sg_primitive_type;\n\n/*\n    sg_filter\n\n    The filtering mode when sampling a texture image. This is\n    used in the sg_sampler_desc.min_filter, sg_sampler_desc.mag_filter\n    and sg_sampler_desc.mipmap_filter members when creating a sampler object.\n\n    For the default is SG_FILTER_NEAREST.\n*/\ntypedef enum sg_filter {\n    _SG_FILTER_DEFAULT, // value 0 reserved for default-init\n    SG_FILTER_NEAREST,\n    SG_FILTER_LINEAR,\n    _SG_FILTER_NUM,\n    _SG_FILTER_FORCE_U32 = 0x7FFFFFFF\n} sg_filter;\n\n/*\n    sg_wrap\n\n    The texture coordinates wrapping mode when sampling a texture\n    image. This is used in the sg_image_desc.wrap_u, .wrap_v\n    and .wrap_w members when creating an image.\n\n    The default wrap mode is SG_WRAP_REPEAT.\n\n    NOTE: SG_WRAP_CLAMP_TO_BORDER is not supported on all backends\n    and platforms. To check for support, call sg_query_features()\n    and check the \"clamp_to_border\" boolean in the returned\n    sg_features struct.\n\n    Platforms which don't support SG_WRAP_CLAMP_TO_BORDER will silently fall back\n    to SG_WRAP_CLAMP_TO_EDGE without a validation error.\n*/\ntypedef enum sg_wrap {\n    _SG_WRAP_DEFAULT,   // value 0 reserved for default-init\n    SG_WRAP_REPEAT,\n    SG_WRAP_CLAMP_TO_EDGE,\n    SG_WRAP_CLAMP_TO_BORDER,\n    SG_WRAP_MIRRORED_REPEAT,\n    _SG_WRAP_NUM,\n    _SG_WRAP_FORCE_U32 = 0x7FFFFFFF\n} sg_wrap;\n\n/*\n    sg_border_color\n\n    The border color to use when sampling a texture, and the UV wrap\n    mode is SG_WRAP_CLAMP_TO_BORDER.\n\n    The default border color is SG_BORDERCOLOR_OPAQUE_BLACK\n*/\ntypedef enum sg_border_color {\n    _SG_BORDERCOLOR_DEFAULT,    // value 0 reserved for default-init\n    SG_BORDERCOLOR_TRANSPARENT_BLACK,\n    SG_BORDERCOLOR_OPAQUE_BLACK,\n    SG_BORDERCOLOR_OPAQUE_WHITE,\n    _SG_BORDERCOLOR_NUM,\n    _SG_BORDERCOLOR_FORCE_U32 = 0x7FFFFFFF\n} sg_border_color;\n\n/*\n    sg_vertex_format\n\n    The data type of a vertex component. This is used to describe\n    the layout of vertex data when creating a pipeline object.\n*/\ntypedef enum sg_vertex_format {\n    SG_VERTEXFORMAT_INVALID,\n    SG_VERTEXFORMAT_FLOAT,\n    SG_VERTEXFORMAT_FLOAT2,\n    SG_VERTEXFORMAT_FLOAT3,\n    SG_VERTEXFORMAT_FLOAT4,\n    SG_VERTEXFORMAT_BYTE4,\n    SG_VERTEXFORMAT_BYTE4N,\n    SG_VERTEXFORMAT_UBYTE4,\n    SG_VERTEXFORMAT_UBYTE4N,\n    SG_VERTEXFORMAT_SHORT2,\n    SG_VERTEXFORMAT_SHORT2N,\n    SG_VERTEXFORMAT_USHORT2N,\n    SG_VERTEXFORMAT_SHORT4,\n    SG_VERTEXFORMAT_SHORT4N,\n    SG_VERTEXFORMAT_USHORT4N,\n    SG_VERTEXFORMAT_UINT10_N2,\n    SG_VERTEXFORMAT_HALF2,\n    SG_VERTEXFORMAT_HALF4,\n    _SG_VERTEXFORMAT_NUM,\n    _SG_VERTEXFORMAT_FORCE_U32 = 0x7FFFFFFF\n} sg_vertex_format;\n\n/*\n    sg_vertex_step\n\n    Defines whether the input pointer of a vertex input stream is advanced\n    'per vertex' or 'per instance'. The default step-func is\n    SG_VERTEXSTEP_PER_VERTEX. SG_VERTEXSTEP_PER_INSTANCE is used with\n    instanced-rendering.\n\n    The vertex-step is part of the vertex-layout definition\n    when creating pipeline objects.\n*/\ntypedef enum sg_vertex_step {\n    _SG_VERTEXSTEP_DEFAULT,     // value 0 reserved for default-init\n    SG_VERTEXSTEP_PER_VERTEX,\n    SG_VERTEXSTEP_PER_INSTANCE,\n    _SG_VERTEXSTEP_NUM,\n    _SG_VERTEXSTEP_FORCE_U32 = 0x7FFFFFFF\n} sg_vertex_step;\n\n/*\n    sg_uniform_type\n\n    The data type of a uniform block member. This is used to\n    describe the internal layout of uniform blocks when creating\n    a shader object. This is only required for the GL backend, all\n    other backends will ignore the interior layout of uniform blocks.\n*/\ntypedef enum sg_uniform_type {\n    SG_UNIFORMTYPE_INVALID,\n    SG_UNIFORMTYPE_FLOAT,\n    SG_UNIFORMTYPE_FLOAT2,\n    SG_UNIFORMTYPE_FLOAT3,\n    SG_UNIFORMTYPE_FLOAT4,\n    SG_UNIFORMTYPE_INT,\n    SG_UNIFORMTYPE_INT2,\n    SG_UNIFORMTYPE_INT3,\n    SG_UNIFORMTYPE_INT4,\n    SG_UNIFORMTYPE_MAT4,\n    _SG_UNIFORMTYPE_NUM,\n    _SG_UNIFORMTYPE_FORCE_U32 = 0x7FFFFFFF\n} sg_uniform_type;\n\n/*\n    sg_uniform_layout\n\n    A hint for the interior memory layout of uniform blocks. This is\n    only relevant for the GL backend where the internal layout\n    of uniform blocks must be known to sokol-gfx. For all other backends the\n    internal memory layout of uniform blocks doesn't matter, sokol-gfx\n    will just pass uniform data as a single memory blob to the\n    3D backend.\n\n    SG_UNIFORMLAYOUT_NATIVE (default)\n        Native layout means that a 'backend-native' memory layout\n        is used. For the GL backend this means that uniforms\n        are packed tightly in memory (e.g. there are no padding\n        bytes).\n\n    SG_UNIFORMLAYOUT_STD140\n        The memory layout is a subset of std140. Arrays are only\n        allowed for the FLOAT4, INT4 and MAT4. Alignment is as\n        is as follows:\n\n            FLOAT, INT:         4 byte alignment\n            FLOAT2, INT2:       8 byte alignment\n            FLOAT3, INT3:       16 byte alignment(!)\n            FLOAT4, INT4:       16 byte alignment\n            MAT4:               16 byte alignment\n            FLOAT4[], INT4[]:   16 byte alignment\n\n        The overall size of the uniform block must be a multiple\n        of 16.\n\n    For more information search for 'UNIFORM DATA LAYOUT' in the documentation block\n    at the start of the header.\n*/\ntypedef enum sg_uniform_layout {\n    _SG_UNIFORMLAYOUT_DEFAULT,     // value 0 reserved for default-init\n    SG_UNIFORMLAYOUT_NATIVE,       // default: layout depends on currently active backend\n    SG_UNIFORMLAYOUT_STD140,       // std140: memory layout according to std140\n    _SG_UNIFORMLAYOUT_NUM,\n    _SG_UNIFORMLAYOUT_FORCE_U32 = 0x7FFFFFFF\n} sg_uniform_layout;\n\n/*\n    sg_cull_mode\n\n    The face-culling mode, this is used in the\n    sg_pipeline_desc.cull_mode member when creating a\n    pipeline object.\n\n    The default cull mode is SG_CULLMODE_NONE\n*/\ntypedef enum sg_cull_mode {\n    _SG_CULLMODE_DEFAULT,   // value 0 reserved for default-init\n    SG_CULLMODE_NONE,\n    SG_CULLMODE_FRONT,\n    SG_CULLMODE_BACK,\n    _SG_CULLMODE_NUM,\n    _SG_CULLMODE_FORCE_U32 = 0x7FFFFFFF\n} sg_cull_mode;\n\n/*\n    sg_face_winding\n\n    The vertex-winding rule that determines a front-facing primitive. This\n    is used in the member sg_pipeline_desc.face_winding\n    when creating a pipeline object.\n\n    The default winding is SG_FACEWINDING_CW (clockwise)\n*/\ntypedef enum sg_face_winding {\n    _SG_FACEWINDING_DEFAULT,    // value 0 reserved for default-init\n    SG_FACEWINDING_CCW,\n    SG_FACEWINDING_CW,\n    _SG_FACEWINDING_NUM,\n    _SG_FACEWINDING_FORCE_U32 = 0x7FFFFFFF\n} sg_face_winding;\n\n/*\n    sg_compare_func\n\n    The compare-function for configuring depth- and stencil-ref tests\n    in pipeline objects, and for texture samplers which perform a comparison\n    instead of regular sampling operation.\n\n    Used in the following structs:\n\n    sg_pipeline_desc\n        .depth\n            .compare\n        .stencil\n            .front.compare\n            .back.compar\n\n    sg_sampler_desc\n        .compare\n\n    The default compare func for depth- and stencil-tests is\n    SG_COMPAREFUNC_ALWAYS.\n\n    The default compare func for samplers is SG_COMPAREFUNC_NEVER.\n*/\ntypedef enum sg_compare_func {\n    _SG_COMPAREFUNC_DEFAULT,    // value 0 reserved for default-init\n    SG_COMPAREFUNC_NEVER,\n    SG_COMPAREFUNC_LESS,\n    SG_COMPAREFUNC_EQUAL,\n    SG_COMPAREFUNC_LESS_EQUAL,\n    SG_COMPAREFUNC_GREATER,\n    SG_COMPAREFUNC_NOT_EQUAL,\n    SG_COMPAREFUNC_GREATER_EQUAL,\n    SG_COMPAREFUNC_ALWAYS,\n    _SG_COMPAREFUNC_NUM,\n    _SG_COMPAREFUNC_FORCE_U32 = 0x7FFFFFFF\n} sg_compare_func;\n\n/*\n    sg_stencil_op\n\n    The operation performed on a currently stored stencil-value when a\n    comparison test passes or fails. This is used when creating a pipeline\n    object in the following sg_pipeline_desc struct items:\n\n    sg_pipeline_desc\n        .stencil\n            .front\n                .fail_op\n                .depth_fail_op\n                .pass_op\n            .back\n                .fail_op\n                .depth_fail_op\n                .pass_op\n\n    The default value is SG_STENCILOP_KEEP.\n*/\ntypedef enum sg_stencil_op {\n    _SG_STENCILOP_DEFAULT,      // value 0 reserved for default-init\n    SG_STENCILOP_KEEP,\n    SG_STENCILOP_ZERO,\n    SG_STENCILOP_REPLACE,\n    SG_STENCILOP_INCR_CLAMP,\n    SG_STENCILOP_DECR_CLAMP,\n    SG_STENCILOP_INVERT,\n    SG_STENCILOP_INCR_WRAP,\n    SG_STENCILOP_DECR_WRAP,\n    _SG_STENCILOP_NUM,\n    _SG_STENCILOP_FORCE_U32 = 0x7FFFFFFF\n} sg_stencil_op;\n\n/*\n    sg_blend_factor\n\n    The source and destination factors in blending operations.\n    This is used in the following members when creating a pipeline object:\n\n    sg_pipeline_desc\n        .colors[i]\n            .blend\n                .src_factor_rgb\n                .dst_factor_rgb\n                .src_factor_alpha\n                .dst_factor_alpha\n\n    The default value is SG_BLENDFACTOR_ONE for source\n    factors, and SG_BLENDFACTOR_ZERO for destination factors.\n*/\ntypedef enum sg_blend_factor {\n    _SG_BLENDFACTOR_DEFAULT,    // value 0 reserved for default-init\n    SG_BLENDFACTOR_ZERO,\n    SG_BLENDFACTOR_ONE,\n    SG_BLENDFACTOR_SRC_COLOR,\n    SG_BLENDFACTOR_ONE_MINUS_SRC_COLOR,\n    SG_BLENDFACTOR_SRC_ALPHA,\n    SG_BLENDFACTOR_ONE_MINUS_SRC_ALPHA,\n    SG_BLENDFACTOR_DST_COLOR,\n    SG_BLENDFACTOR_ONE_MINUS_DST_COLOR,\n    SG_BLENDFACTOR_DST_ALPHA,\n    SG_BLENDFACTOR_ONE_MINUS_DST_ALPHA,\n    SG_BLENDFACTOR_SRC_ALPHA_SATURATED,\n    SG_BLENDFACTOR_BLEND_COLOR,\n    SG_BLENDFACTOR_ONE_MINUS_BLEND_COLOR,\n    SG_BLENDFACTOR_BLEND_ALPHA,\n    SG_BLENDFACTOR_ONE_MINUS_BLEND_ALPHA,\n    _SG_BLENDFACTOR_NUM,\n    _SG_BLENDFACTOR_FORCE_U32 = 0x7FFFFFFF\n} sg_blend_factor;\n\n/*\n    sg_blend_op\n\n    Describes how the source and destination values are combined in the\n    fragment blending operation. It is used in the following struct items\n    when creating a pipeline object:\n\n    sg_pipeline_desc\n        .colors[i]\n            .blend\n                .op_rgb\n                .op_alpha\n\n    The default value is SG_BLENDOP_ADD.\n*/\ntypedef enum sg_blend_op {\n    _SG_BLENDOP_DEFAULT,    // value 0 reserved for default-init\n    SG_BLENDOP_ADD,\n    SG_BLENDOP_SUBTRACT,\n    SG_BLENDOP_REVERSE_SUBTRACT,\n    _SG_BLENDOP_NUM,\n    _SG_BLENDOP_FORCE_U32 = 0x7FFFFFFF\n} sg_blend_op;\n\n/*\n    sg_color_mask\n\n    Selects the active color channels when writing a fragment color to the\n    framebuffer. This is used in the members\n    sg_pipeline_desc.colors[i].write_mask when creating a pipeline object.\n\n    The default colormask is SG_COLORMASK_RGBA (write all colors channels)\n\n    NOTE: since the color mask value 0 is reserved for the default value\n    (SG_COLORMASK_RGBA), use SG_COLORMASK_NONE if all color channels\n    should be disabled.\n*/\ntypedef enum sg_color_mask {\n    _SG_COLORMASK_DEFAULT = 0,    // value 0 reserved for default-init\n    SG_COLORMASK_NONE   = 0x10,   // special value for 'all channels disabled\n    SG_COLORMASK_R      = 0x1,\n    SG_COLORMASK_G      = 0x2,\n    SG_COLORMASK_RG     = 0x3,\n    SG_COLORMASK_B      = 0x4,\n    SG_COLORMASK_RB     = 0x5,\n    SG_COLORMASK_GB     = 0x6,\n    SG_COLORMASK_RGB    = 0x7,\n    SG_COLORMASK_A      = 0x8,\n    SG_COLORMASK_RA     = 0x9,\n    SG_COLORMASK_GA     = 0xA,\n    SG_COLORMASK_RGA    = 0xB,\n    SG_COLORMASK_BA     = 0xC,\n    SG_COLORMASK_RBA    = 0xD,\n    SG_COLORMASK_GBA    = 0xE,\n    SG_COLORMASK_RGBA   = 0xF,\n    _SG_COLORMASK_FORCE_U32 = 0x7FFFFFFF\n} sg_color_mask;\n\n/*\n    sg_load_action\n\n    Defines the load action that should be performed at the start of a render pass:\n\n    SG_LOADACTION_CLEAR:        clear the render target\n    SG_LOADACTION_LOAD:         load the previous content of the render target\n    SG_LOADACTION_DONTCARE:     leave the render target in an undefined state\n\n    This is used in the sg_pass_action structure.\n\n    The default load action for all pass attachments is SG_LOADACTION_CLEAR,\n    with the values rgba = { 0.5f, 0.5f, 0.5f, 1.0f }, depth=1.0f and stencil=0.\n\n    If you want to override the default behaviour, it is important to not\n    only set the clear color, but the 'action' field as well (as long as this\n    is _SG_LOADACTION_DEFAULT, the value fields will be ignored).\n*/\ntypedef enum sg_load_action {\n    _SG_LOADACTION_DEFAULT,\n    SG_LOADACTION_CLEAR,\n    SG_LOADACTION_LOAD,\n    SG_LOADACTION_DONTCARE,\n    _SG_LOADACTION_FORCE_U32 = 0x7FFFFFFF\n} sg_load_action;\n\n/*\n    sg_store_action\n\n    Defines the store action that should be performed at the end of a render pass:\n\n    SG_STOREACTION_STORE:       store the rendered content to the color attachment image\n    SG_STOREACTION_DONTCARE:    allows the GPU to discard the rendered content\n*/\ntypedef enum sg_store_action {\n    _SG_STOREACTION_DEFAULT,\n    SG_STOREACTION_STORE,\n    SG_STOREACTION_DONTCARE,\n    _SG_STOREACTION_FORCE_U32 = 0x7FFFFFFF\n} sg_store_action;\n\n\n/*\n    sg_pass_action\n\n    The sg_pass_action struct defines the actions to be performed\n    at the start and end of a render pass.\n\n    - at the start of the pass: whether the render attachments should be cleared,\n      loaded with their previous content, or start in an undefined state\n    - for clear operations: the clear value (color, depth, or stencil values)\n    - at the end of the pass: whether the rendering result should be\n      stored back into the render attachment or discarded\n*/\ntypedef struct sg_color_attachment_action {\n    sg_load_action load_action;         // default: SG_LOADACTION_CLEAR\n    sg_store_action store_action;       // default: SG_STOREACTION_STORE\n    sg_color clear_value;               // default: { 0.5f, 0.5f, 0.5f, 1.0f }\n} sg_color_attachment_action;\n\ntypedef struct sg_depth_attachment_action {\n    sg_load_action load_action;         // default: SG_LOADACTION_CLEAR\n    sg_store_action store_action;       // default: SG_STOREACTION_DONTCARE\n    float clear_value;                  // default: 1.0\n} sg_depth_attachment_action;\n\ntypedef struct sg_stencil_attachment_action {\n    sg_load_action load_action;         // default: SG_LOADACTION_CLEAR\n    sg_store_action store_action;       // default: SG_STOREACTION_DONTCARE\n    uint8_t clear_value;                // default: 0\n} sg_stencil_attachment_action;\n\ntypedef struct sg_pass_action {\n    sg_color_attachment_action colors[SG_MAX_COLOR_ATTACHMENTS];\n    sg_depth_attachment_action depth;\n    sg_stencil_attachment_action stencil;\n} sg_pass_action;\n\n/*\n    sg_swapchain\n\n    Used in sg_begin_pass() to provide details about an external swapchain\n    (pixel formats, sample count and backend-API specific render surface objects).\n\n    The following information must be provided:\n\n    - the width and height of the swapchain surfaces in number of pixels,\n    - the pixel format of the render- and optional msaa-resolve-surface\n    - the pixel format of the optional depth- or depth-stencil-surface\n    - the MSAA sample count for the render and depth-stencil surface\n\n    If the pixel formats and MSAA sample counts are left zero-initialized,\n    their defaults are taken from the sg_environment struct provided in the\n    sg_setup() call.\n\n    The width and height *must* be > 0.\n\n    Additionally the following backend API specific objects must be passed in\n    as 'type erased' void pointers:\n\n    GL:\n        - on all GL backends, a GL framebuffer object must be provided. This\n          can be zero for the default framebuffer.\n\n    D3D11:\n        - an ID3D11RenderTargetView for the rendering surface, without\n          MSAA rendering this surface will also be displayed\n        - an optional ID3D11DepthStencilView for the depth- or depth/stencil\n          buffer surface\n        - when MSAA rendering is used, another ID3D11RenderTargetView\n          which serves as MSAA resolve target and will be displayed\n\n    WebGPU (same as D3D11, except different types)\n        - a WGPUTextureView for the rendering surface, without\n          MSAA rendering this surface will also be displayed\n        - an optional WGPUTextureView for the depth- or depth/stencil\n          buffer surface\n        - when MSAA rendering is used, another WGPUTextureView\n          which serves as MSAA resolve target and will be displayed\n\n    Metal (NOTE that the roles of provided surfaces is slightly different\n    than on D3D11 or WebGPU in case of MSAA vs non-MSAA rendering):\n\n        - A current CAMetalDrawable (NOT an MTLDrawable!) which will be presented.\n          This will either be rendered to directly (if no MSAA is used), or serve\n          as MSAA-resolve target.\n        - an optional MTLTexture for the depth- or depth-stencil buffer\n        - an optional multisampled MTLTexture which serves as intermediate\n          rendering surface which will then be resolved into the\n          CAMetalDrawable.\n\n    NOTE that for Metal you must use an ObjC __bridge cast to\n    properly tunnel the ObjC object id through a C void*, e.g.:\n\n        swapchain.metal.current_drawable = (__bridge const void*) [mtkView currentDrawable];\n\n    On all other backends you shouldn't need to mess with the reference count.\n\n    It's a good practice to write a helper function which returns an initialized\n    sg_swapchain structs, which can then be plugged directly into\n    sg_pass.swapchain. Look at the function sglue_swapchain() in the sokol_glue.h\n    as an example.\n*/\ntypedef struct sg_metal_swapchain {\n    const void* current_drawable;       // CAMetalDrawable (NOT MTLDrawable!!!)\n    const void* depth_stencil_texture;  // MTLTexture\n    const void* msaa_color_texture;     // MTLTexture\n} sg_metal_swapchain;\n\ntypedef struct sg_d3d11_swapchain {\n    const void* render_view;            // ID3D11RenderTargetView\n    const void* resolve_view;           // ID3D11RenderTargetView\n    const void* depth_stencil_view;     // ID3D11DepthStencilView\n} sg_d3d11_swapchain;\n\ntypedef struct sg_wgpu_swapchain {\n    const void* render_view;            // WGPUTextureView\n    const void* resolve_view;           // WGPUTextureView\n    const void* depth_stencil_view;     // WGPUTextureView\n} sg_wgpu_swapchain;\n\ntypedef struct sg_gl_swapchain {\n    uint32_t framebuffer;               // GL framebuffer object\n} sg_gl_swapchain;\n\ntypedef struct sg_swapchain {\n    int width;\n    int height;\n    int sample_count;\n    sg_pixel_format color_format;\n    sg_pixel_format depth_format;\n    sg_metal_swapchain metal;\n    sg_d3d11_swapchain d3d11;\n    sg_wgpu_swapchain wgpu;\n    sg_gl_swapchain gl;\n} sg_swapchain;\n\n/*\n    sg_pass\n\n    The sg_pass structure is passed as argument into the sg_begin_pass()\n    function.\n\n    For an offscreen rendering pass, an sg_pass_action struct and sg_attachments\n    object must be provided, and for swapchain passes, an sg_pass_action and\n    an sg_swapchain struct. It is an error to provide both an sg_attachments\n    handle and an initialized sg_swapchain struct in the same sg_begin_pass().\n\n    An sg_begin_pass() call for an offscreen pass would look like this (where\n    `attachments` is an sg_attachments handle):\n\n        sg_begin_pass(&(sg_pass){\n            .action = { ... },\n            .attachments = attachments,\n        });\n\n    ...and a swapchain render pass would look like this (using the sokol_glue.h\n    helper function sglue_swapchain() which gets the swapchain properties from\n    sokol_app.h):\n\n        sg_begin_pass(&(sg_pass){\n            .action = { ... },\n            .swapchain = sglue_swapchain(),\n        });\n\n    You can also omit the .action object to get default pass action behaviour\n    (clear to color=grey, depth=1 and stencil=0).\n*/\ntypedef struct sg_pass {\n    uint32_t _start_canary;\n    sg_pass_action action;\n    sg_attachments attachments;\n    sg_swapchain swapchain;\n    const char* label;\n    uint32_t _end_canary;\n} sg_pass;\n\n/*\n    sg_bindings\n\n    The sg_bindings structure defines the buffers, images and\n    samplers resource bindings for the next draw call.\n\n    To update the resource bindings, call sg_apply_bindings() with\n    a pointer to a populated sg_bindings struct. Note that\n    sg_apply_bindings() must be called after sg_apply_pipeline()\n    and that bindings are not preserved across sg_apply_pipeline()\n    calls, even when the new pipeline uses the same 'bindings layout'.\n\n    A resource binding struct contains:\n\n    - 1..N vertex buffers\n    - 0..N vertex buffer offsets\n    - 0..1 index buffers\n    - 0..1 index buffer offsets\n    - 0..N images\n    - 0..N samplers\n    - 0..N storage buffers\n\n    Where 'N' is defined in the following constants:\n\n    - SG_MAX_VERTEXBUFFER_BINDSLOTS\n    - SG_MAX_IMAGE_BINDLOTS\n    - SG_MAX_SAMPLER_BINDSLOTS\n    - SG_MAX_STORAGEBUFFER_BINDGLOTS\n\n    When using sokol-shdc for shader authoring, the `layout(binding=N)`\n    annotation in the shader code directly maps to the slot index for that\n    resource type in the bindings struct, for instance the following vertex-\n    and fragment-shader interface for sokol-shdc:\n\n        @vs vs\n        layout(binding=0) uniform vs_params { ... };\n        layout(binding=0) readonly buffer ssbo { ... };\n        layout(binding=0) uniform texture2D vs_tex;\n        layout(binding=0) uniform sampler vs_smp;\n        ...\n        @end\n\n        @fs fs\n        layout(binding=1) uniform fs_params { ... };\n        layout(binding=1) uniform texture2D fs_tex;\n        layout(binding=1) uniform sampler fs_smp;\n        ...\n        @end\n\n    ...would map to the following sg_bindings struct:\n\n        const sg_bindings bnd = {\n            .vertex_buffers[0] = ...,\n            .images[0] = vs_tex,\n            .images[1] = fs_tex,\n            .samplers[0] = vs_smp,\n            .samplers[1] = fs_smp,\n            .storage_buffers[0] = ssbo,\n        };\n\n    ...alternatively you can use code-generated slot indices:\n\n        const sg_bindings bnd = {\n            .vertex_buffers[0] = ...,\n            .images[IMG_vs_tex] = vs_tex,\n            .images[IMG_fs_tex] = fs_tex,\n            .samplers[SMP_vs_smp] = vs_smp,\n            .samplers[SMP_fs_smp] = fs_smp,\n            .storage_buffers[SBUF_ssbo] = ssbo,\n        };\n\n    Resource bindslots for a specific shader/pipeline may have gaps, and an\n    sg_bindings struct may have populated bind slots which are not used by a\n    specific shader. This allows to use the same sg_bindings struct across\n    different shader variants.\n\n    When not using sokol-shdc, the bindslot indices in the sg_bindings\n    struct need to match the per-resource reflection info slot indices\n    in the sg_shader_desc struct (for details about that see the\n    sg_shader_desc struct documentation).\n\n    The optional buffer offsets can be used to put different unrelated\n    chunks of vertex- and/or index-data into the same buffer objects.\n*/\ntypedef struct sg_bindings {\n    uint32_t _start_canary;\n    sg_buffer vertex_buffers[SG_MAX_VERTEXBUFFER_BINDSLOTS];\n    int vertex_buffer_offsets[SG_MAX_VERTEXBUFFER_BINDSLOTS];\n    sg_buffer index_buffer;\n    int index_buffer_offset;\n    sg_image images[SG_MAX_IMAGE_BINDSLOTS];\n    sg_sampler samplers[SG_MAX_SAMPLER_BINDSLOTS];\n    sg_buffer storage_buffers[SG_MAX_STORAGEBUFFER_BINDSLOTS];\n    uint32_t _end_canary;\n} sg_bindings;\n\n/*\n    sg_buffer_desc\n\n    Creation parameters for sg_buffer objects, used in the\n    sg_make_buffer() call.\n\n    The default configuration is:\n\n    .size:      0       (*must* be >0 for buffers without data)\n    .type:      SG_BUFFERTYPE_VERTEXBUFFER\n    .usage:     SG_USAGE_IMMUTABLE\n    .data.ptr   0       (*must* be valid for immutable buffers)\n    .data.size  0       (*must* be > 0 for immutable buffers)\n    .label      0       (optional string label)\n\n    For immutable buffers which are initialized with initial data,\n    keep the .size item zero-initialized, and set the size together with the\n    pointer to the initial data in the .data item.\n\n    For mutable buffers without initial data, keep the .data item\n    zero-initialized, and set the buffer size in the .size item instead.\n\n    You can also set both size values, but currently both size values must\n    be identical (this may change in the future when the dynamic resource\n    management may become more flexible).\n\n    ADVANCED TOPIC: Injecting native 3D-API buffers:\n\n    The following struct members allow to inject your own GL, Metal\n    or D3D11 buffers into sokol_gfx:\n\n    .gl_buffers[SG_NUM_INFLIGHT_FRAMES]\n    .mtl_buffers[SG_NUM_INFLIGHT_FRAMES]\n    .d3d11_buffer\n\n    You must still provide all other struct items except the .data item, and\n    these must match the creation parameters of the native buffers you\n    provide. For SG_USAGE_IMMUTABLE, only provide a single native 3D-API\n    buffer, otherwise you need to provide SG_NUM_INFLIGHT_FRAMES buffers\n    (only for GL and Metal, not D3D11). Providing multiple buffers for GL and\n    Metal is necessary because sokol_gfx will rotate through them when\n    calling sg_update_buffer() to prevent lock-stalls.\n\n    Note that it is expected that immutable injected buffer have already been\n    initialized with content, and the .content member must be 0!\n\n    Also you need to call sg_reset_state_cache() after calling native 3D-API\n    functions, and before calling any sokol_gfx function.\n*/\ntypedef struct sg_buffer_desc {\n    uint32_t _start_canary;\n    size_t size;\n    sg_buffer_type type;\n    sg_usage usage;\n    sg_range data;\n    const char* label;\n    // optionally inject backend-specific resources\n    uint32_t gl_buffers[SG_NUM_INFLIGHT_FRAMES];\n    const void* mtl_buffers[SG_NUM_INFLIGHT_FRAMES];\n    const void* d3d11_buffer;\n    const void* wgpu_buffer;\n    uint32_t _end_canary;\n} sg_buffer_desc;\n\n/*\n    sg_image_data\n\n    Defines the content of an image through a 2D array of sg_range structs.\n    The first array dimension is the cubemap face, and the second array\n    dimension the mipmap level.\n*/\ntypedef struct sg_image_data {\n    sg_range subimage[SG_CUBEFACE_NUM][SG_MAX_MIPMAPS];\n} sg_image_data;\n\n/*\n    sg_image_desc\n\n    Creation parameters for sg_image objects, used in the sg_make_image() call.\n\n    The default configuration is:\n\n    .type:              SG_IMAGETYPE_2D\n    .render_target:     false\n    .width              0 (must be set to >0)\n    .height             0 (must be set to >0)\n    .num_slices         1 (3D textures: depth; array textures: number of layers)\n    .num_mipmaps:       1\n    .usage:             SG_USAGE_IMMUTABLE\n    .pixel_format:      SG_PIXELFORMAT_RGBA8 for textures, or sg_desc.environment.defaults.color_format for render targets\n    .sample_count:      1 for textures, or sg_desc.environment.defaults.sample_count for render targets\n    .data               an sg_image_data struct to define the initial content\n    .label              0 (optional string label for trace hooks)\n\n    Q: Why is the default sample_count for render targets identical with the\n    \"default sample count\" from sg_desc.environment.defaults.sample_count?\n\n    A: So that it matches the default sample count in pipeline objects. Even\n    though it is a bit strange/confusing that offscreen render targets by default\n    get the same sample count as 'default swapchains', but it's better that\n    an offscreen render target created with default parameters matches\n    a pipeline object created with default parameters.\n\n    NOTE:\n\n    Images with usage SG_USAGE_IMMUTABLE must be fully initialized by\n    providing a valid .data member which points to initialization data.\n\n    ADVANCED TOPIC: Injecting native 3D-API textures:\n\n    The following struct members allow to inject your own GL, Metal or D3D11\n    textures into sokol_gfx:\n\n    .gl_textures[SG_NUM_INFLIGHT_FRAMES]\n    .mtl_textures[SG_NUM_INFLIGHT_FRAMES]\n    .d3d11_texture\n    .d3d11_shader_resource_view\n    .wgpu_texture\n    .wgpu_texture_view\n\n    For GL, you can also specify the texture target or leave it empty to use\n    the default texture target for the image type (GL_TEXTURE_2D for\n    SG_IMAGETYPE_2D etc)\n\n    For D3D11 and WebGPU, either only provide a texture, or both a texture and\n    shader-resource-view / texture-view object. If you want to use access the\n    injected texture in a shader you *must* provide a shader-resource-view.\n\n    The same rules apply as for injecting native buffers (see sg_buffer_desc\n    documentation for more details).\n*/\ntypedef struct sg_image_desc {\n    uint32_t _start_canary;\n    sg_image_type type;\n    bool render_target;\n    int width;\n    int height;\n    int num_slices;\n    int num_mipmaps;\n    sg_usage usage;\n    sg_pixel_format pixel_format;\n    int sample_count;\n    sg_image_data data;\n    const char* label;\n    // optionally inject backend-specific resources\n    uint32_t gl_textures[SG_NUM_INFLIGHT_FRAMES];\n    uint32_t gl_texture_target;\n    const void* mtl_textures[SG_NUM_INFLIGHT_FRAMES];\n    const void* d3d11_texture;\n    const void* d3d11_shader_resource_view;\n    const void* wgpu_texture;\n    const void* wgpu_texture_view;\n    uint32_t _end_canary;\n} sg_image_desc;\n\n/*\n    sg_sampler_desc\n\n    Creation parameters for sg_sampler objects, used in the sg_make_sampler() call\n\n    .min_filter:        SG_FILTER_NEAREST\n    .mag_filter:        SG_FILTER_NEAREST\n    .mipmap_filter      SG_FILTER_NEAREST\n    .wrap_u:            SG_WRAP_REPEAT\n    .wrap_v:            SG_WRAP_REPEAT\n    .wrap_w:            SG_WRAP_REPEAT (only SG_IMAGETYPE_3D)\n    .min_lod            0.0f\n    .max_lod            FLT_MAX\n    .border_color       SG_BORDERCOLOR_OPAQUE_BLACK\n    .compare            SG_COMPAREFUNC_NEVER\n    .max_anisotropy     1 (must be 1..16)\n\n*/\ntypedef struct sg_sampler_desc {\n    uint32_t _start_canary;\n    sg_filter min_filter;\n    sg_filter mag_filter;\n    sg_filter mipmap_filter;\n    sg_wrap wrap_u;\n    sg_wrap wrap_v;\n    sg_wrap wrap_w;\n    float min_lod;\n    float max_lod;\n    sg_border_color border_color;\n    sg_compare_func compare;\n    uint32_t max_anisotropy;\n    const char* label;\n    // optionally inject backend-specific resources\n    uint32_t gl_sampler;\n    const void* mtl_sampler;\n    const void* d3d11_sampler;\n    const void* wgpu_sampler;\n    uint32_t _end_canary;\n} sg_sampler_desc;\n\n/*\n    sg_shader_desc\n\n    Used as parameter of sg_make_shader() to create a shader object which\n    communicates shader source or bytecode and shader interface\n    reflection information to sokol-gfx.\n\n    If you use sokol-shdc you can ignore the following information since\n    the sg_shader_desc struct will be code generated.\n\n    Otherwise you need to provide the following information to the\n    sg_make_shader() call:\n\n    - a vertex- and fragment-shader function:\n        - the shader source or bytecode\n        - an optional entry point name\n        - for D3D11: an optional compile target when source code is provided\n          (the defaults are \"vs_4_0\" and \"ps_4_0\")\n\n    - vertex attributes required by some backends:\n        - for the GL backend: optional vertex attribute names\n          used for name lookup\n        - for the D3D11 backend: semantic names and indices\n\n    - reflection information for each uniform block used by the shader:\n        - the shader stage the uniform block appears in (SG_SHADERSTAGE_*)\n        - the size in bytes of the uniform block\n        - backend-specific bindslots:\n            - HLSL: the constant buffer register `register(b0..7)`\n            - MSL: the buffer attribute `[[buffer(0..7)]]`\n            - WGSL: the binding in `@group(0) @binding(0..15)`\n        - GLSL only: a description of the uniform block interior\n            - the memory layout standard (SG_UNIFORMLAYOUT_*)\n            - for each member in the uniform block:\n                - the member type (SG_UNIFORM_*)\n                - if the member is an array, the array count\n                - the member name\n\n    - reflection information for each texture used by the shader:\n        - the shader stage the texture appears in (SG_SHADERSTAGE_*)\n        - the image type (SG_IMAGETYPE_*)\n        - the image-sample type (SG_IMAGESAMPLETYPE_*)\n        - whether the texture is multisampled\n        - backend specific bindslots:\n            - HLSL: the texture register `register(t0..23)`\n            - MSL: the texture attribute `[[texture(0..15)]]`\n            - WGSL: the binding in `@group(1) @binding(0..127)`\n\n    - reflection information for each sampler used by the shader:\n        - the shader stage the sampler appears in (SG_SHADERSTAGE_*)\n        - the sampler type (SG_SAMPLERTYPE_*)\n        - backend specific bindslots:\n            - HLSL: the sampler register `register(s0..15)`\n            - MSL: the sampler attribute `[[sampler(0..15)]]`\n            - WGSL: the binding in `@group(0) @binding(0..127)`\n\n    - reflection information for each storage buffer used by the shader:\n        - the shader stage the storage buffer appears in (SG_SHADERSTAGE_*)\n        - whether the storage buffer is readonly (currently this must\n          always be true)\n        - backend specific bindslots:\n            - HLSL: the texture(sic) register `register(t0..23)`\n            - MSL: the buffer attribute `[[buffer(8..15)]]`\n            - WGSL: the binding in `@group(1) @binding(0..127)`\n            - GL: the binding in `layout(binding=0..16)`\n\n    - reflection information for each combined image-sampler object\n      used by the shader:\n        - the shader stage (SG_SHADERSTAGE_*)\n        - the texture's array index in the sg_shader_desc.images[] array\n        - the sampler's array index in the sg_shader_desc.samplers[] array\n        - GLSL only: the name of the combined image-sampler object\n\n    The number and order of items in the sg_shader_desc.attrs[]\n    array corresponds to the items in sg_pipeline_desc.layout.attrs.\n\n        - sg_shader_desc.attrs[N] => sg_pipeline_desc.layout.attrs[N]\n\n    NOTE that vertex attribute indices currently cannot have gaps.\n\n    The items index in the sg_shader_desc.uniform_blocks[] array corresponds\n    to the ub_slot arg in sg_apply_uniforms():\n\n        - sg_shader_desc.uniform_blocks[N] => sg_apply_uniforms(N, ...)\n\n    The items in the shader_desc images, samplers and storage_buffers\n    arrays correspond to the same array items in the sg_bindings struct:\n\n        - sg_shader_desc.images[N] => sg_bindings.images[N]\n        - sg_shader_desc.samplers[N] => sg_bindings.samplers[N]\n        - sg_shader_desc.storage_buffers[N] => sg_bindings.storage_buffers[N]\n\n    For all GL backends, shader source-code must be provided. For D3D11 and Metal,\n    either shader source-code or byte-code can be provided.\n\n    NOTE that the uniform block, image, sampler and storage_buffer arrays\n    can have gaps. This allows to use the same sg_bindings struct for\n    different related shader variants.\n\n    For D3D11, if source code is provided, the d3dcompiler_47.dll will be loaded\n    on demand. If this fails, shader creation will fail. When compiling HLSL\n    source code, you can provide an optional target string via\n    sg_shader_stage_desc.d3d11_target, the default target is \"vs_4_0\" for the\n    vertex shader stage and \"ps_4_0\" for the pixel shader stage.\n*/\ntypedef enum sg_shader_stage {\n    SG_SHADERSTAGE_NONE,\n    SG_SHADERSTAGE_VERTEX,\n    SG_SHADERSTAGE_FRAGMENT,\n} sg_shader_stage;\n\ntypedef struct sg_shader_function {\n    const char* source;\n    sg_range bytecode;\n    const char* entry;\n    const char* d3d11_target;   // default: \"vs_4_0\" or \"ps_4_0\"\n} sg_shader_function;\n\ntypedef struct sg_shader_vertex_attr {\n    const char* glsl_name;      // [optional] GLSL attribute name\n    const char* hlsl_sem_name;  // HLSL semantic name\n    uint8_t hlsl_sem_index;     // HLSL semantic index\n} sg_shader_vertex_attr;\n\ntypedef struct sg_glsl_shader_uniform {\n    sg_uniform_type type;\n    uint16_t array_count;       // 0 or 1 for scalars, >1 for arrays\n    const char* glsl_name;      // glsl name binding is required on GL 4.1 and WebGL2\n} sg_glsl_shader_uniform;\n\ntypedef struct sg_shader_uniform_block {\n    sg_shader_stage stage;\n    uint32_t size;\n    uint8_t hlsl_register_b_n;  // HLSL register(bn)\n    uint8_t msl_buffer_n;       // MSL [[buffer(n)]]\n    uint8_t wgsl_group0_binding_n; // WGSL @group(0) @binding(n)\n    sg_uniform_layout layout;\n    sg_glsl_shader_uniform glsl_uniforms[SG_MAX_UNIFORMBLOCK_MEMBERS];\n} sg_shader_uniform_block;\n\ntypedef struct sg_shader_image {\n    sg_shader_stage stage;\n    sg_image_type image_type;\n    sg_image_sample_type sample_type;\n    bool multisampled;\n    uint8_t hlsl_register_t_n;      // HLSL register(tn) bind slot\n    uint8_t msl_texture_n;          // MSL [[texture(n)]] bind slot\n    uint8_t wgsl_group1_binding_n;  // WGSL @group(1) @binding(n) bind slot\n} sg_shader_image;\n\ntypedef struct sg_shader_sampler {\n    sg_shader_stage stage;\n    sg_sampler_type sampler_type;\n    uint8_t hlsl_register_s_n;      // HLSL register(sn) bind slot\n    uint8_t msl_sampler_n;          // MSL [[sampler(n)]] bind slot\n    uint8_t wgsl_group1_binding_n;  // WGSL @group(1) @binding(n) bind slot\n} sg_shader_sampler;\n\ntypedef struct sg_shader_storage_buffer {\n    sg_shader_stage stage;\n    bool readonly;\n    uint8_t hlsl_register_t_n;      // HLSL register(tn) bind slot\n    uint8_t msl_buffer_n;           // MSL [[buffer(n)]] bind slot\n    uint8_t wgsl_group1_binding_n;  // WGSL @group(1) @binding(n) bind slot\n    uint8_t glsl_binding_n;         // GLSL layout(binding=n)\n} sg_shader_storage_buffer;\n\ntypedef struct sg_shader_image_sampler_pair {\n    sg_shader_stage stage;\n    uint8_t image_slot;\n    uint8_t sampler_slot;\n    const char* glsl_name;          // glsl name binding required because of GL 4.1 and WebGL2\n} sg_shader_image_sampler_pair;\n\ntypedef struct sg_shader_desc {\n    uint32_t _start_canary;\n    sg_shader_function vertex_func;\n    sg_shader_function fragment_func;\n    sg_shader_vertex_attr attrs[SG_MAX_VERTEX_ATTRIBUTES];\n    sg_shader_uniform_block uniform_blocks[SG_MAX_UNIFORMBLOCK_BINDSLOTS];\n    sg_shader_storage_buffer storage_buffers[SG_MAX_STORAGEBUFFER_BINDSLOTS];\n    sg_shader_image images[SG_MAX_IMAGE_BINDSLOTS];\n    sg_shader_sampler samplers[SG_MAX_SAMPLER_BINDSLOTS];\n    sg_shader_image_sampler_pair image_sampler_pairs[SG_MAX_IMAGE_SAMPLER_PAIRS];\n    const char* label;\n    uint32_t _end_canary;\n} sg_shader_desc;\n\n/*\n    sg_pipeline_desc\n\n    The sg_pipeline_desc struct defines all creation parameters for an\n    sg_pipeline object, used as argument to the sg_make_pipeline() function:\n\n    - the vertex layout for all input vertex buffers\n    - a shader object\n    - the 3D primitive type (points, lines, triangles, ...)\n    - the index type (none, 16- or 32-bit)\n    - all the fixed-function-pipeline state (depth-, stencil-, blend-state, etc...)\n\n    If the vertex data has no gaps between vertex components, you can omit\n    the .layout.buffers[].stride and layout.attrs[].offset items (leave them\n    default-initialized to 0), sokol-gfx will then compute the offsets and\n    strides from the vertex component formats (.layout.attrs[].format).\n    Please note that ALL vertex attribute offsets must be 0 in order for the\n    automatic offset computation to kick in.\n\n    The default configuration is as follows:\n\n    .shader:                0 (must be initialized with a valid sg_shader id!)\n    .layout:\n        .buffers[]:         vertex buffer layouts\n            .stride:        0 (if no stride is given it will be computed)\n            .step_func      SG_VERTEXSTEP_PER_VERTEX\n            .step_rate      1\n        .attrs[]:           vertex attribute declarations\n            .buffer_index   0 the vertex buffer bind slot\n            .offset         0 (offsets can be omitted if the vertex layout has no gaps)\n            .format         SG_VERTEXFORMAT_INVALID (must be initialized!)\n    .depth:\n        .pixel_format:      sg_desc.context.depth_format\n        .compare:           SG_COMPAREFUNC_ALWAYS\n        .write_enabled:     false\n        .bias:              0.0f\n        .bias_slope_scale:  0.0f\n        .bias_clamp:        0.0f\n    .stencil:\n        .enabled:           false\n        .front/back:\n            .compare:       SG_COMPAREFUNC_ALWAYS\n            .fail_op:       SG_STENCILOP_KEEP\n            .depth_fail_op: SG_STENCILOP_KEEP\n            .pass_op:       SG_STENCILOP_KEEP\n        .read_mask:         0\n        .write_mask:        0\n        .ref:               0\n    .color_count            1\n    .colors[0..color_count]\n        .pixel_format       sg_desc.context.color_format\n        .write_mask:        SG_COLORMASK_RGBA\n        .blend:\n            .enabled:           false\n            .src_factor_rgb:    SG_BLENDFACTOR_ONE\n            .dst_factor_rgb:    SG_BLENDFACTOR_ZERO\n            .op_rgb:            SG_BLENDOP_ADD\n            .src_factor_alpha:  SG_BLENDFACTOR_ONE\n            .dst_factor_alpha:  SG_BLENDFACTOR_ZERO\n            .op_alpha:          SG_BLENDOP_ADD\n    .primitive_type:            SG_PRIMITIVETYPE_TRIANGLES\n    .index_type:                SG_INDEXTYPE_NONE\n    .cull_mode:                 SG_CULLMODE_NONE\n    .face_winding:              SG_FACEWINDING_CW\n    .sample_count:              sg_desc.context.sample_count\n    .blend_color:               (sg_color) { 0.0f, 0.0f, 0.0f, 0.0f }\n    .alpha_to_coverage_enabled: false\n    .label  0       (optional string label for trace hooks)\n*/\ntypedef struct sg_vertex_buffer_layout_state {\n    int stride;\n    sg_vertex_step step_func;\n    int step_rate;\n} sg_vertex_buffer_layout_state;\n\ntypedef struct sg_vertex_attr_state {\n    int buffer_index;\n    int offset;\n    sg_vertex_format format;\n} sg_vertex_attr_state;\n\ntypedef struct sg_vertex_layout_state {\n    sg_vertex_buffer_layout_state buffers[SG_MAX_VERTEXBUFFER_BINDSLOTS];\n    sg_vertex_attr_state attrs[SG_MAX_VERTEX_ATTRIBUTES];\n} sg_vertex_layout_state;\n\ntypedef struct sg_stencil_face_state {\n    sg_compare_func compare;\n    sg_stencil_op fail_op;\n    sg_stencil_op depth_fail_op;\n    sg_stencil_op pass_op;\n} sg_stencil_face_state;\n\ntypedef struct sg_stencil_state {\n    bool enabled;\n    sg_stencil_face_state front;\n    sg_stencil_face_state back;\n    uint8_t read_mask;\n    uint8_t write_mask;\n    uint8_t ref;\n} sg_stencil_state;\n\ntypedef struct sg_depth_state {\n    sg_pixel_format pixel_format;\n    sg_compare_func compare;\n    bool write_enabled;\n    float bias;\n    float bias_slope_scale;\n    float bias_clamp;\n} sg_depth_state;\n\ntypedef struct sg_blend_state {\n    bool enabled;\n    sg_blend_factor src_factor_rgb;\n    sg_blend_factor dst_factor_rgb;\n    sg_blend_op op_rgb;\n    sg_blend_factor src_factor_alpha;\n    sg_blend_factor dst_factor_alpha;\n    sg_blend_op op_alpha;\n} sg_blend_state;\n\ntypedef struct sg_color_target_state {\n    sg_pixel_format pixel_format;\n    sg_color_mask write_mask;\n    sg_blend_state blend;\n} sg_color_target_state;\n\ntypedef struct sg_pipeline_desc {\n    uint32_t _start_canary;\n    sg_shader shader;\n    sg_vertex_layout_state layout;\n    sg_depth_state depth;\n    sg_stencil_state stencil;\n    int color_count;\n    sg_color_target_state colors[SG_MAX_COLOR_ATTACHMENTS];\n    sg_primitive_type primitive_type;\n    sg_index_type index_type;\n    sg_cull_mode cull_mode;\n    sg_face_winding face_winding;\n    int sample_count;\n    sg_color blend_color;\n    bool alpha_to_coverage_enabled;\n    const char* label;\n    uint32_t _end_canary;\n} sg_pipeline_desc;\n\n/*\n    sg_attachments_desc\n\n    Creation parameters for an sg_attachments object, used as argument to the\n    sg_make_attachments() function.\n\n    An attachments object bundles 0..4 color attachments, 0..4 msaa-resolve\n    attachments, and none or one depth-stencil attachmente for use\n    in a render pass. At least one color attachment or one depth-stencil\n    attachment must be provided (no color attachment and a depth-stencil\n    attachment is useful for a depth-only render pass).\n\n    Each attachment definition consists of an image object, and two additional indices\n    describing which subimage the pass will render into: one mipmap index, and if the image\n    is a cubemap, array-texture or 3D-texture, the face-index, array-layer or\n    depth-slice.\n\n    All attachments must have the same width and height.\n\n    All color attachments and the depth-stencil attachment must have the\n    same sample count.\n\n    If a resolve attachment is set, an MSAA-resolve operation from the\n    associated color attachment image into the resolve attachment image will take\n    place in the sg_end_pass() function. In this case, the color attachment\n    must have a (sample_count>1), and the resolve attachment a\n    (sample_count==1). The resolve attachment also must have the same pixel\n    format as the color attachment.\n\n    NOTE that MSAA depth-stencil attachments cannot be msaa-resolved!\n*/\ntypedef struct sg_attachment_desc {\n    sg_image image;\n    int mip_level;\n    int slice;      // cube texture: face; array texture: layer; 3D texture: slice\n} sg_attachment_desc;\n\ntypedef struct sg_attachments_desc {\n    uint32_t _start_canary;\n    sg_attachment_desc colors[SG_MAX_COLOR_ATTACHMENTS];\n    sg_attachment_desc resolves[SG_MAX_COLOR_ATTACHMENTS];\n    sg_attachment_desc depth_stencil;\n    const char* label;\n    uint32_t _end_canary;\n} sg_attachments_desc;\n\n/*\n    sg_trace_hooks\n\n    Installable callback functions to keep track of the sokol-gfx calls,\n    this is useful for debugging, or keeping track of resource creation\n    and destruction.\n\n    Trace hooks are installed with sg_install_trace_hooks(), this returns\n    another sg_trace_hooks struct with the previous set of\n    trace hook function pointers. These should be invoked by the\n    new trace hooks to form a proper call chain.\n*/\ntypedef struct sg_trace_hooks {\n    void* user_data;\n    void (*reset_state_cache)(void* user_data);\n    void (*make_buffer)(const sg_buffer_desc* desc, sg_buffer result, void* user_data);\n    void (*make_image)(const sg_image_desc* desc, sg_image result, void* user_data);\n    void (*make_sampler)(const sg_sampler_desc* desc, sg_sampler result, void* user_data);\n    void (*make_shader)(const sg_shader_desc* desc, sg_shader result, void* user_data);\n    void (*make_pipeline)(const sg_pipeline_desc* desc, sg_pipeline result, void* user_data);\n    void (*make_attachments)(const sg_attachments_desc* desc, sg_attachments result, void* user_data);\n    void (*destroy_buffer)(sg_buffer buf, void* user_data);\n    void (*destroy_image)(sg_image img, void* user_data);\n    void (*destroy_sampler)(sg_sampler smp, void* user_data);\n    void (*destroy_shader)(sg_shader shd, void* user_data);\n    void (*destroy_pipeline)(sg_pipeline pip, void* user_data);\n    void (*destroy_attachments)(sg_attachments atts, void* user_data);\n    void (*update_buffer)(sg_buffer buf, const sg_range* data, void* user_data);\n    void (*update_image)(sg_image img, const sg_image_data* data, void* user_data);\n    void (*append_buffer)(sg_buffer buf, const sg_range* data, int result, void* user_data);\n    void (*begin_pass)(const sg_pass* pass, void* user_data);\n    void (*apply_viewport)(int x, int y, int width, int height, bool origin_top_left, void* user_data);\n    void (*apply_scissor_rect)(int x, int y, int width, int height, bool origin_top_left, void* user_data);\n    void (*apply_pipeline)(sg_pipeline pip, void* user_data);\n    void (*apply_bindings)(const sg_bindings* bindings, void* user_data);\n    void (*apply_uniforms)(int ub_index, const sg_range* data, void* user_data);\n    void (*draw)(int base_element, int num_elements, int num_instances, void* user_data);\n    void (*end_pass)(void* user_data);\n    void (*commit)(void* user_data);\n    void (*alloc_buffer)(sg_buffer result, void* user_data);\n    void (*alloc_image)(sg_image result, void* user_data);\n    void (*alloc_sampler)(sg_sampler result, void* user_data);\n    void (*alloc_shader)(sg_shader result, void* user_data);\n    void (*alloc_pipeline)(sg_pipeline result, void* user_data);\n    void (*alloc_attachments)(sg_attachments result, void* user_data);\n    void (*dealloc_buffer)(sg_buffer buf_id, void* user_data);\n    void (*dealloc_image)(sg_image img_id, void* user_data);\n    void (*dealloc_sampler)(sg_sampler smp_id, void* user_data);\n    void (*dealloc_shader)(sg_shader shd_id, void* user_data);\n    void (*dealloc_pipeline)(sg_pipeline pip_id, void* user_data);\n    void (*dealloc_attachments)(sg_attachments atts_id, void* user_data);\n    void (*init_buffer)(sg_buffer buf_id, const sg_buffer_desc* desc, void* user_data);\n    void (*init_image)(sg_image img_id, const sg_image_desc* desc, void* user_data);\n    void (*init_sampler)(sg_sampler smp_id, const sg_sampler_desc* desc, void* user_data);\n    void (*init_shader)(sg_shader shd_id, const sg_shader_desc* desc, void* user_data);\n    void (*init_pipeline)(sg_pipeline pip_id, const sg_pipeline_desc* desc, void* user_data);\n    void (*init_attachments)(sg_attachments atts_id, const sg_attachments_desc* desc, void* user_data);\n    void (*uninit_buffer)(sg_buffer buf_id, void* user_data);\n    void (*uninit_image)(sg_image img_id, void* user_data);\n    void (*uninit_sampler)(sg_sampler smp_id, void* user_data);\n    void (*uninit_shader)(sg_shader shd_id, void* user_data);\n    void (*uninit_pipeline)(sg_pipeline pip_id, void* user_data);\n    void (*uninit_attachments)(sg_attachments atts_id, void* user_data);\n    void (*fail_buffer)(sg_buffer buf_id, void* user_data);\n    void (*fail_image)(sg_image img_id, void* user_data);\n    void (*fail_sampler)(sg_sampler smp_id, void* user_data);\n    void (*fail_shader)(sg_shader shd_id, void* user_data);\n    void (*fail_pipeline)(sg_pipeline pip_id, void* user_data);\n    void (*fail_attachments)(sg_attachments atts_id, void* user_data);\n    void (*push_debug_group)(const char* name, void* user_data);\n    void (*pop_debug_group)(void* user_data);\n} sg_trace_hooks;\n\n/*\n    sg_buffer_info\n    sg_image_info\n    sg_sampler_info\n    sg_shader_info\n    sg_pipeline_info\n    sg_attachments_info\n\n    These structs contain various internal resource attributes which\n    might be useful for debug-inspection. Please don't rely on the\n    actual content of those structs too much, as they are quite closely\n    tied to sokol_gfx.h internals and may change more frequently than\n    the other public API elements.\n\n    The *_info structs are used as the return values of the following functions:\n\n    sg_query_buffer_info()\n    sg_query_image_info()\n    sg_query_sampler_info()\n    sg_query_shader_info()\n    sg_query_pipeline_info()\n    sg_query_pass_info()\n*/\ntypedef struct sg_slot_info {\n    sg_resource_state state;    // the current state of this resource slot\n    uint32_t res_id;            // type-neutral resource if (e.g. sg_buffer.id)\n} sg_slot_info;\n\ntypedef struct sg_buffer_info {\n    sg_slot_info slot;              // resource pool slot info\n    uint32_t update_frame_index;    // frame index of last sg_update_buffer()\n    uint32_t append_frame_index;    // frame index of last sg_append_buffer()\n    int append_pos;                 // current position in buffer for sg_append_buffer()\n    bool append_overflow;           // is buffer in overflow state (due to sg_append_buffer)\n    int num_slots;                  // number of renaming-slots for dynamically updated buffers\n    int active_slot;                // currently active write-slot for dynamically updated buffers\n} sg_buffer_info;\n\ntypedef struct sg_image_info {\n    sg_slot_info slot;              // resource pool slot info\n    uint32_t upd_frame_index;       // frame index of last sg_update_image()\n    int num_slots;                  // number of renaming-slots for dynamically updated images\n    int active_slot;                // currently active write-slot for dynamically updated images\n} sg_image_info;\n\ntypedef struct sg_sampler_info {\n    sg_slot_info slot;              // resource pool slot info\n} sg_sampler_info;\n\ntypedef struct sg_shader_info {\n    sg_slot_info slot;              // resource pool slot info\n} sg_shader_info;\n\ntypedef struct sg_pipeline_info {\n    sg_slot_info slot;              // resource pool slot info\n} sg_pipeline_info;\n\ntypedef struct sg_attachments_info {\n    sg_slot_info slot;              // resource pool slot info\n} sg_attachments_info;\n\n/*\n    sg_frame_stats\n\n    Allows to track generic and backend-specific stats about a\n    render frame. Obtained by calling sg_query_frame_stats(). The returned\n    struct contains information about the *previous* frame.\n*/\ntypedef struct sg_frame_stats_gl {\n    uint32_t num_bind_buffer;\n    uint32_t num_active_texture;\n    uint32_t num_bind_texture;\n    uint32_t num_bind_sampler;\n    uint32_t num_use_program;\n    uint32_t num_render_state;\n    uint32_t num_vertex_attrib_pointer;\n    uint32_t num_vertex_attrib_divisor;\n    uint32_t num_enable_vertex_attrib_array;\n    uint32_t num_disable_vertex_attrib_array;\n    uint32_t num_uniform;\n} sg_frame_stats_gl;\n\ntypedef struct sg_frame_stats_d3d11_pass {\n    uint32_t num_om_set_render_targets;\n    uint32_t num_clear_render_target_view;\n    uint32_t num_clear_depth_stencil_view;\n    uint32_t num_resolve_subresource;\n} sg_frame_stats_d3d11_pass;\n\ntypedef struct sg_frame_stats_d3d11_pipeline {\n    uint32_t num_rs_set_state;\n    uint32_t num_om_set_depth_stencil_state;\n    uint32_t num_om_set_blend_state;\n    uint32_t num_ia_set_primitive_topology;\n    uint32_t num_ia_set_input_layout;\n    uint32_t num_vs_set_shader;\n    uint32_t num_vs_set_constant_buffers;\n    uint32_t num_ps_set_shader;\n    uint32_t num_ps_set_constant_buffers;\n} sg_frame_stats_d3d11_pipeline;\n\ntypedef struct sg_frame_stats_d3d11_bindings {\n    uint32_t num_ia_set_vertex_buffers;\n    uint32_t num_ia_set_index_buffer;\n    uint32_t num_vs_set_shader_resources;\n    uint32_t num_ps_set_shader_resources;\n    uint32_t num_vs_set_samplers;\n    uint32_t num_ps_set_samplers;\n} sg_frame_stats_d3d11_bindings;\n\ntypedef struct sg_frame_stats_d3d11_uniforms {\n    uint32_t num_update_subresource;\n} sg_frame_stats_d3d11_uniforms;\n\ntypedef struct sg_frame_stats_d3d11_draw {\n    uint32_t num_draw_indexed_instanced;\n    uint32_t num_draw_indexed;\n    uint32_t num_draw_instanced;\n    uint32_t num_draw;\n} sg_frame_stats_d3d11_draw;\n\ntypedef struct sg_frame_stats_d3d11 {\n    sg_frame_stats_d3d11_pass pass;\n    sg_frame_stats_d3d11_pipeline pipeline;\n    sg_frame_stats_d3d11_bindings bindings;\n    sg_frame_stats_d3d11_uniforms uniforms;\n    sg_frame_stats_d3d11_draw draw;\n    uint32_t num_map;\n    uint32_t num_unmap;\n} sg_frame_stats_d3d11;\n\ntypedef struct sg_frame_stats_metal_idpool {\n    uint32_t num_added;\n    uint32_t num_released;\n    uint32_t num_garbage_collected;\n} sg_frame_stats_metal_idpool;\n\ntypedef struct sg_frame_stats_metal_pipeline {\n    uint32_t num_set_blend_color;\n    uint32_t num_set_cull_mode;\n    uint32_t num_set_front_facing_winding;\n    uint32_t num_set_stencil_reference_value;\n    uint32_t num_set_depth_bias;\n    uint32_t num_set_render_pipeline_state;\n    uint32_t num_set_depth_stencil_state;\n} sg_frame_stats_metal_pipeline;\n\ntypedef struct sg_frame_stats_metal_bindings {\n    uint32_t num_set_vertex_buffer;\n    uint32_t num_set_vertex_texture;\n    uint32_t num_set_vertex_sampler_state;\n    uint32_t num_set_fragment_buffer;\n    uint32_t num_set_fragment_texture;\n    uint32_t num_set_fragment_sampler_state;\n} sg_frame_stats_metal_bindings;\n\ntypedef struct sg_frame_stats_metal_uniforms {\n    uint32_t num_set_vertex_buffer_offset;\n    uint32_t num_set_fragment_buffer_offset;\n} sg_frame_stats_metal_uniforms;\n\ntypedef struct sg_frame_stats_metal {\n    sg_frame_stats_metal_idpool idpool;\n    sg_frame_stats_metal_pipeline pipeline;\n    sg_frame_stats_metal_bindings bindings;\n    sg_frame_stats_metal_uniforms uniforms;\n} sg_frame_stats_metal;\n\ntypedef struct sg_frame_stats_wgpu_uniforms {\n    uint32_t num_set_bindgroup;\n    uint32_t size_write_buffer;\n} sg_frame_stats_wgpu_uniforms;\n\ntypedef struct sg_frame_stats_wgpu_bindings {\n    uint32_t num_set_vertex_buffer;\n    uint32_t num_skip_redundant_vertex_buffer;\n    uint32_t num_set_index_buffer;\n    uint32_t num_skip_redundant_index_buffer;\n    uint32_t num_create_bindgroup;\n    uint32_t num_discard_bindgroup;\n    uint32_t num_set_bindgroup;\n    uint32_t num_skip_redundant_bindgroup;\n    uint32_t num_bindgroup_cache_hits;\n    uint32_t num_bindgroup_cache_misses;\n    uint32_t num_bindgroup_cache_collisions;\n    uint32_t num_bindgroup_cache_invalidates;\n    uint32_t num_bindgroup_cache_hash_vs_key_mismatch;\n} sg_frame_stats_wgpu_bindings;\n\ntypedef struct sg_frame_stats_wgpu {\n    sg_frame_stats_wgpu_uniforms uniforms;\n    sg_frame_stats_wgpu_bindings bindings;\n} sg_frame_stats_wgpu;\n\ntypedef struct sg_frame_stats {\n    uint32_t frame_index;   // current frame counter, starts at 0\n\n    uint32_t num_passes;\n    uint32_t num_apply_viewport;\n    uint32_t num_apply_scissor_rect;\n    uint32_t num_apply_pipeline;\n    uint32_t num_apply_bindings;\n    uint32_t num_apply_uniforms;\n    uint32_t num_draw;\n    uint32_t num_update_buffer;\n    uint32_t num_append_buffer;\n    uint32_t num_update_image;\n\n    uint32_t size_apply_uniforms;\n    uint32_t size_update_buffer;\n    uint32_t size_append_buffer;\n    uint32_t size_update_image;\n\n    sg_frame_stats_gl gl;\n    sg_frame_stats_d3d11 d3d11;\n    sg_frame_stats_metal metal;\n    sg_frame_stats_wgpu wgpu;\n} sg_frame_stats;\n\n/*\n    sg_log_item\n\n    An enum with a unique item for each log message, warning, error\n    and validation layer message. Note that these messages are only\n    visible when a logger function is installed in the sg_setup() call.\n*/\n#define _SG_LOG_ITEMS \\\n    _SG_LOGITEM_XMACRO(OK, \"Ok\") \\\n    _SG_LOGITEM_XMACRO(MALLOC_FAILED, \"memory allocation failed\") \\\n    _SG_LOGITEM_XMACRO(GL_TEXTURE_FORMAT_NOT_SUPPORTED, \"pixel format not supported for texture (gl)\") \\\n    _SG_LOGITEM_XMACRO(GL_3D_TEXTURES_NOT_SUPPORTED, \"3d textures not supported (gl)\") \\\n    _SG_LOGITEM_XMACRO(GL_ARRAY_TEXTURES_NOT_SUPPORTED, \"array textures not supported (gl)\") \\\n    _SG_LOGITEM_XMACRO(GL_SHADER_COMPILATION_FAILED, \"shader compilation failed (gl)\") \\\n    _SG_LOGITEM_XMACRO(GL_SHADER_LINKING_FAILED, \"shader linking failed (gl)\") \\\n    _SG_LOGITEM_XMACRO(GL_VERTEX_ATTRIBUTE_NOT_FOUND_IN_SHADER, \"vertex attribute not found in shader; NOTE: may be caused by GL driver's GLSL compiler removing unused globals\") \\\n    _SG_LOGITEM_XMACRO(GL_UNIFORMBLOCK_NAME_NOT_FOUND_IN_SHADER, \"uniform block name not found in shader; NOTE: may be caused by GL driver's GLSL compiler removing unused globals\") \\\n    _SG_LOGITEM_XMACRO(GL_IMAGE_SAMPLER_NAME_NOT_FOUND_IN_SHADER, \"image-sampler name not found in shader; NOTE: may be caused by GL driver's GLSL compiler removing unused globals\") \\\n    _SG_LOGITEM_XMACRO(GL_FRAMEBUFFER_STATUS_UNDEFINED, \"framebuffer completeness check failed with GL_FRAMEBUFFER_UNDEFINED (gl)\") \\\n    _SG_LOGITEM_XMACRO(GL_FRAMEBUFFER_STATUS_INCOMPLETE_ATTACHMENT, \"framebuffer completeness check failed with GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT (gl)\") \\\n    _SG_LOGITEM_XMACRO(GL_FRAMEBUFFER_STATUS_INCOMPLETE_MISSING_ATTACHMENT, \"framebuffer completeness check failed with GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT (gl)\") \\\n    _SG_LOGITEM_XMACRO(GL_FRAMEBUFFER_STATUS_UNSUPPORTED, \"framebuffer completeness check failed with GL_FRAMEBUFFER_UNSUPPORTED (gl)\") \\\n    _SG_LOGITEM_XMACRO(GL_FRAMEBUFFER_STATUS_INCOMPLETE_MULTISAMPLE, \"framebuffer completeness check failed with GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE (gl)\") \\\n    _SG_LOGITEM_XMACRO(GL_FRAMEBUFFER_STATUS_UNKNOWN, \"framebuffer completeness check failed (unknown reason) (gl)\") \\\n    _SG_LOGITEM_XMACRO(D3D11_CREATE_BUFFER_FAILED, \"CreateBuffer() failed (d3d11)\") \\\n    _SG_LOGITEM_XMACRO(D3D11_CREATE_BUFFER_SRV_FAILED, \"CreateShaderResourceView() failed for storage buffer (d3d11)\") \\\n    _SG_LOGITEM_XMACRO(D3D11_CREATE_DEPTH_TEXTURE_UNSUPPORTED_PIXEL_FORMAT, \"pixel format not supported for depth-stencil texture (d3d11)\") \\\n    _SG_LOGITEM_XMACRO(D3D11_CREATE_DEPTH_TEXTURE_FAILED, \"CreateTexture2D() failed for depth-stencil texture (d3d11)\") \\\n    _SG_LOGITEM_XMACRO(D3D11_CREATE_2D_TEXTURE_UNSUPPORTED_PIXEL_FORMAT, \"pixel format not supported for 2d-, cube- or array-texture (d3d11)\") \\\n    _SG_LOGITEM_XMACRO(D3D11_CREATE_2D_TEXTURE_FAILED, \"CreateTexture2D() failed for 2d-, cube- or array-texture (d3d11)\") \\\n    _SG_LOGITEM_XMACRO(D3D11_CREATE_2D_SRV_FAILED, \"CreateShaderResourceView() failed for 2d-, cube- or array-texture (d3d11)\") \\\n    _SG_LOGITEM_XMACRO(D3D11_CREATE_3D_TEXTURE_UNSUPPORTED_PIXEL_FORMAT, \"pixel format not supported for 3D texture (d3d11)\") \\\n    _SG_LOGITEM_XMACRO(D3D11_CREATE_3D_TEXTURE_FAILED, \"CreateTexture3D() failed (d3d11)\") \\\n    _SG_LOGITEM_XMACRO(D3D11_CREATE_3D_SRV_FAILED, \"CreateShaderResourceView() failed for 3d texture (d3d11)\") \\\n    _SG_LOGITEM_XMACRO(D3D11_CREATE_MSAA_TEXTURE_FAILED, \"CreateTexture2D() failed for MSAA render target texture (d3d11)\") \\\n    _SG_LOGITEM_XMACRO(D3D11_CREATE_SAMPLER_STATE_FAILED, \"CreateSamplerState() failed (d3d11)\") \\\n    _SG_LOGITEM_XMACRO(D3D11_LOAD_D3DCOMPILER_47_DLL_FAILED, \"loading d3dcompiler_47.dll failed (d3d11)\") \\\n    _SG_LOGITEM_XMACRO(D3D11_SHADER_COMPILATION_FAILED, \"shader compilation failed (d3d11)\") \\\n    _SG_LOGITEM_XMACRO(D3D11_SHADER_COMPILATION_OUTPUT, \"\") \\\n    _SG_LOGITEM_XMACRO(D3D11_CREATE_CONSTANT_BUFFER_FAILED, \"CreateBuffer() failed for uniform constant buffer (d3d11)\") \\\n    _SG_LOGITEM_XMACRO(D3D11_CREATE_INPUT_LAYOUT_FAILED, \"CreateInputLayout() failed (d3d11)\") \\\n    _SG_LOGITEM_XMACRO(D3D11_CREATE_RASTERIZER_STATE_FAILED, \"CreateRasterizerState() failed (d3d11)\") \\\n    _SG_LOGITEM_XMACRO(D3D11_CREATE_DEPTH_STENCIL_STATE_FAILED, \"CreateDepthStencilState() failed (d3d11)\") \\\n    _SG_LOGITEM_XMACRO(D3D11_CREATE_BLEND_STATE_FAILED, \"CreateBlendState() failed (d3d11)\") \\\n    _SG_LOGITEM_XMACRO(D3D11_CREATE_RTV_FAILED, \"CreateRenderTargetView() failed (d3d11)\") \\\n    _SG_LOGITEM_XMACRO(D3D11_CREATE_DSV_FAILED, \"CreateDepthStencilView() failed (d3d11)\") \\\n    _SG_LOGITEM_XMACRO(D3D11_MAP_FOR_UPDATE_BUFFER_FAILED, \"Map() failed when updating buffer (d3d11)\") \\\n    _SG_LOGITEM_XMACRO(D3D11_MAP_FOR_APPEND_BUFFER_FAILED, \"Map() failed when appending to buffer (d3d11)\") \\\n    _SG_LOGITEM_XMACRO(D3D11_MAP_FOR_UPDATE_IMAGE_FAILED, \"Map() failed when updating image (d3d11)\") \\\n    _SG_LOGITEM_XMACRO(METAL_CREATE_BUFFER_FAILED, \"failed to create buffer object (metal)\") \\\n    _SG_LOGITEM_XMACRO(METAL_TEXTURE_FORMAT_NOT_SUPPORTED, \"pixel format not supported for texture (metal)\") \\\n    _SG_LOGITEM_XMACRO(METAL_CREATE_TEXTURE_FAILED, \"failed to create texture object (metal)\") \\\n    _SG_LOGITEM_XMACRO(METAL_CREATE_SAMPLER_FAILED, \"failed to create sampler object (metal)\") \\\n    _SG_LOGITEM_XMACRO(METAL_SHADER_COMPILATION_FAILED, \"shader compilation failed (metal)\") \\\n    _SG_LOGITEM_XMACRO(METAL_SHADER_CREATION_FAILED, \"shader creation failed (metal)\") \\\n    _SG_LOGITEM_XMACRO(METAL_SHADER_COMPILATION_OUTPUT, \"\") \\\n    _SG_LOGITEM_XMACRO(METAL_SHADER_ENTRY_NOT_FOUND, \"shader entry function not found (metal)\") \\\n    _SG_LOGITEM_XMACRO(METAL_CREATE_RPS_FAILED, \"failed to create render pipeline state (metal)\") \\\n    _SG_LOGITEM_XMACRO(METAL_CREATE_RPS_OUTPUT, \"\") \\\n    _SG_LOGITEM_XMACRO(METAL_CREATE_DSS_FAILED, \"failed to create depth stencil state (metal)\") \\\n    _SG_LOGITEM_XMACRO(WGPU_BINDGROUPS_POOL_EXHAUSTED, \"bindgroups pool exhausted (increase sg_desc.bindgroups_cache_size) (wgpu)\") \\\n    _SG_LOGITEM_XMACRO(WGPU_BINDGROUPSCACHE_SIZE_GREATER_ONE, \"sg_desc.wgpu_bindgroups_cache_size must be > 1 (wgpu)\") \\\n    _SG_LOGITEM_XMACRO(WGPU_BINDGROUPSCACHE_SIZE_POW2, \"sg_desc.wgpu_bindgroups_cache_size must be a power of 2 (wgpu)\") \\\n    _SG_LOGITEM_XMACRO(WGPU_CREATEBINDGROUP_FAILED, \"wgpuDeviceCreateBindGroup failed\") \\\n    _SG_LOGITEM_XMACRO(WGPU_CREATE_BUFFER_FAILED, \"wgpuDeviceCreateBuffer() failed\") \\\n    _SG_LOGITEM_XMACRO(WGPU_CREATE_TEXTURE_FAILED, \"wgpuDeviceCreateTexture() failed\") \\\n    _SG_LOGITEM_XMACRO(WGPU_CREATE_TEXTURE_VIEW_FAILED, \"wgpuTextureCreateView() failed\") \\\n    _SG_LOGITEM_XMACRO(WGPU_CREATE_SAMPLER_FAILED, \"wgpuDeviceCreateSampler() failed\") \\\n    _SG_LOGITEM_XMACRO(WGPU_CREATE_SHADER_MODULE_FAILED, \"wgpuDeviceCreateShaderModule() failed\") \\\n    _SG_LOGITEM_XMACRO(WGPU_SHADER_CREATE_BINDGROUP_LAYOUT_FAILED, \"wgpuDeviceCreateBindGroupLayout() for shader stage failed\") \\\n    _SG_LOGITEM_XMACRO(WGPU_CREATE_PIPELINE_LAYOUT_FAILED, \"wgpuDeviceCreatePipelineLayout() failed\") \\\n    _SG_LOGITEM_XMACRO(WGPU_CREATE_RENDER_PIPELINE_FAILED, \"wgpuDeviceCreateRenderPipeline() failed\") \\\n    _SG_LOGITEM_XMACRO(WGPU_ATTACHMENTS_CREATE_TEXTURE_VIEW_FAILED, \"wgpuTextureCreateView() failed in create attachments\") \\\n    _SG_LOGITEM_XMACRO(DRAW_REQUIRED_BINDINGS_OR_UNIFORMS_MISSING, \"call to sg_apply_bindings() and/or sg_apply_uniforms() missing after sg_apply_pipeline()\") \\\n    _SG_LOGITEM_XMACRO(IDENTICAL_COMMIT_LISTENER, \"attempting to add identical commit listener\") \\\n    _SG_LOGITEM_XMACRO(COMMIT_LISTENER_ARRAY_FULL, \"commit listener array full\") \\\n    _SG_LOGITEM_XMACRO(TRACE_HOOKS_NOT_ENABLED, \"sg_install_trace_hooks() called, but SOKOL_TRACE_HOOKS is not defined\") \\\n    _SG_LOGITEM_XMACRO(DEALLOC_BUFFER_INVALID_STATE, \"sg_dealloc_buffer(): buffer must be in ALLOC state\") \\\n    _SG_LOGITEM_XMACRO(DEALLOC_IMAGE_INVALID_STATE, \"sg_dealloc_image(): image must be in alloc state\") \\\n    _SG_LOGITEM_XMACRO(DEALLOC_SAMPLER_INVALID_STATE, \"sg_dealloc_sampler(): sampler must be in alloc state\") \\\n    _SG_LOGITEM_XMACRO(DEALLOC_SHADER_INVALID_STATE, \"sg_dealloc_shader(): shader must be in ALLOC state\") \\\n    _SG_LOGITEM_XMACRO(DEALLOC_PIPELINE_INVALID_STATE, \"sg_dealloc_pipeline(): pipeline must be in ALLOC state\") \\\n    _SG_LOGITEM_XMACRO(DEALLOC_ATTACHMENTS_INVALID_STATE, \"sg_dealloc_attachments(): attachments must be in ALLOC state\") \\\n    _SG_LOGITEM_XMACRO(INIT_BUFFER_INVALID_STATE, \"sg_init_buffer(): buffer must be in ALLOC state\") \\\n    _SG_LOGITEM_XMACRO(INIT_IMAGE_INVALID_STATE, \"sg_init_image(): image must be in ALLOC state\") \\\n    _SG_LOGITEM_XMACRO(INIT_SAMPLER_INVALID_STATE, \"sg_init_sampler(): sampler must be in ALLOC state\") \\\n    _SG_LOGITEM_XMACRO(INIT_SHADER_INVALID_STATE, \"sg_init_shader(): shader must be in ALLOC state\") \\\n    _SG_LOGITEM_XMACRO(INIT_PIPELINE_INVALID_STATE, \"sg_init_pipeline(): pipeline must be in ALLOC state\") \\\n    _SG_LOGITEM_XMACRO(INIT_ATTACHMENTS_INVALID_STATE, \"sg_init_attachments(): pass must be in ALLOC state\") \\\n    _SG_LOGITEM_XMACRO(UNINIT_BUFFER_INVALID_STATE, \"sg_uninit_buffer(): buffer must be in VALID or FAILED state\") \\\n    _SG_LOGITEM_XMACRO(UNINIT_IMAGE_INVALID_STATE, \"sg_uninit_image(): image must be in VALID or FAILED state\") \\\n    _SG_LOGITEM_XMACRO(UNINIT_SAMPLER_INVALID_STATE, \"sg_uninit_sampler(): sampler must be in VALID or FAILED state\") \\\n    _SG_LOGITEM_XMACRO(UNINIT_SHADER_INVALID_STATE, \"sg_uninit_shader(): shader must be in VALID or FAILED state\") \\\n    _SG_LOGITEM_XMACRO(UNINIT_PIPELINE_INVALID_STATE, \"sg_uninit_pipeline(): pipeline must be in VALID or FAILED state\") \\\n    _SG_LOGITEM_XMACRO(UNINIT_ATTACHMENTS_INVALID_STATE, \"sg_uninit_attachments(): attachments must be in VALID or FAILED state\") \\\n    _SG_LOGITEM_XMACRO(FAIL_BUFFER_INVALID_STATE, \"sg_fail_buffer(): buffer must be in ALLOC state\") \\\n    _SG_LOGITEM_XMACRO(FAIL_IMAGE_INVALID_STATE, \"sg_fail_image(): image must be in ALLOC state\") \\\n    _SG_LOGITEM_XMACRO(FAIL_SAMPLER_INVALID_STATE, \"sg_fail_sampler(): sampler must be in ALLOC state\") \\\n    _SG_LOGITEM_XMACRO(FAIL_SHADER_INVALID_STATE, \"sg_fail_shader(): shader must be in ALLOC state\") \\\n    _SG_LOGITEM_XMACRO(FAIL_PIPELINE_INVALID_STATE, \"sg_fail_pipeline(): pipeline must be in ALLOC state\") \\\n    _SG_LOGITEM_XMACRO(FAIL_ATTACHMENTS_INVALID_STATE, \"sg_fail_attachments(): attachments must be in ALLOC state\") \\\n    _SG_LOGITEM_XMACRO(BUFFER_POOL_EXHAUSTED, \"buffer pool exhausted\") \\\n    _SG_LOGITEM_XMACRO(IMAGE_POOL_EXHAUSTED, \"image pool exhausted\") \\\n    _SG_LOGITEM_XMACRO(SAMPLER_POOL_EXHAUSTED, \"sampler pool exhausted\") \\\n    _SG_LOGITEM_XMACRO(SHADER_POOL_EXHAUSTED, \"shader pool exhausted\") \\\n    _SG_LOGITEM_XMACRO(PIPELINE_POOL_EXHAUSTED, \"pipeline pool exhausted\") \\\n    _SG_LOGITEM_XMACRO(PASS_POOL_EXHAUSTED, \"pass pool exhausted\") \\\n    _SG_LOGITEM_XMACRO(BEGINPASS_ATTACHMENT_INVALID, \"sg_begin_pass: an attachment was provided that no longer exists\") \\\n    _SG_LOGITEM_XMACRO(DRAW_WITHOUT_BINDINGS, \"attempting to draw without resource bindings\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_BUFFERDESC_CANARY, \"sg_buffer_desc not initialized\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_BUFFERDESC_SIZE, \"sg_buffer_desc.size and .data.size cannot both be 0\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_BUFFERDESC_DATA, \"immutable buffers must be initialized with data (sg_buffer_desc.data.ptr and sg_buffer_desc.data.size)\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_BUFFERDESC_DATA_SIZE, \"immutable buffer data size differs from buffer size\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_BUFFERDESC_NO_DATA, \"dynamic/stream usage buffers cannot be initialized with data\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_BUFFERDESC_STORAGEBUFFER_SUPPORTED, \"storage buffers not supported by the backend 3D API (requires OpenGL >= 4.3)\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_BUFFERDESC_STORAGEBUFFER_SIZE_MULTIPLE_4, \"size of storage buffers must be a multiple of 4\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_IMAGEDATA_NODATA, \"sg_image_data: no data (.ptr and/or .size is zero)\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_IMAGEDATA_DATA_SIZE, \"sg_image_data: data size doesn't match expected surface size\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_IMAGEDESC_CANARY, \"sg_image_desc not initialized\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_IMAGEDESC_WIDTH, \"sg_image_desc.width must be > 0\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_IMAGEDESC_HEIGHT, \"sg_image_desc.height must be > 0\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_IMAGEDESC_RT_PIXELFORMAT, \"invalid pixel format for render-target image\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_IMAGEDESC_NONRT_PIXELFORMAT, \"invalid pixel format for non-render-target image\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_IMAGEDESC_MSAA_BUT_NO_RT, \"non-render-target images cannot be multisampled\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_IMAGEDESC_NO_MSAA_RT_SUPPORT, \"MSAA not supported for this pixel format\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_IMAGEDESC_MSAA_NUM_MIPMAPS, \"MSAA images must have num_mipmaps == 1\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_IMAGEDESC_MSAA_3D_IMAGE, \"3D images cannot have a sample_count > 1\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_IMAGEDESC_MSAA_CUBE_IMAGE, \"cube images cannot have sample_count > 1\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_IMAGEDESC_DEPTH_3D_IMAGE, \"3D images cannot have a depth/stencil image format\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_IMAGEDESC_RT_IMMUTABLE, \"render target images must be SG_USAGE_IMMUTABLE\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_IMAGEDESC_RT_NO_DATA, \"render target images cannot be initialized with data\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_IMAGEDESC_INJECTED_NO_DATA, \"images with injected textures cannot be initialized with data\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_IMAGEDESC_DYNAMIC_NO_DATA, \"dynamic/stream images cannot be initialized with data\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_IMAGEDESC_COMPRESSED_IMMUTABLE, \"compressed images must be immutable\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_SAMPLERDESC_CANARY, \"sg_sampler_desc not initialized\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_SAMPLERDESC_ANISTROPIC_REQUIRES_LINEAR_FILTERING, \"sg_sampler_desc.max_anisotropy > 1 requires min/mag/mipmap_filter to be SG_FILTER_LINEAR\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_SHADERDESC_CANARY, \"sg_shader_desc not initialized\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_SHADERDESC_SOURCE, \"shader source code required\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_SHADERDESC_BYTECODE, \"shader byte code required\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_SHADERDESC_SOURCE_OR_BYTECODE, \"shader source or byte code required\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_SHADERDESC_NO_BYTECODE_SIZE, \"shader byte code length (in bytes) required\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_SHADERDESC_NO_CONT_UB_MEMBERS, \"uniform block members must occupy continuous slots\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_SHADERDESC_UB_SIZE_IS_ZERO, \"bound uniform block size cannot be zero\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_SHADERDESC_UB_METAL_BUFFER_SLOT_OUT_OF_RANGE, \"uniform block 'msl_buffer_n' is out of range (must be 0..7)\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_SHADERDESC_UB_METAL_BUFFER_SLOT_COLLISION, \"uniform block 'msl_buffer_n' must be unique across uniform blocks and storage buffers in same shader stage\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_SHADERDESC_UB_HLSL_REGISTER_B_OUT_OF_RANGE, \"uniform block 'hlsl_register_b_n' is out of range (must be 0..7)\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_SHADERDESC_UB_HLSL_REGISTER_B_COLLISION, \"uniform block 'hlsl_register_b_n' must be unique across uniform blocks in same shader stage\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_SHADERDESC_UB_WGSL_GROUP0_BINDING_OUT_OF_RANGE, \"uniform block 'wgsl_group0_binding_n' is out of range (must be 0..15)\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_SHADERDESC_UB_WGSL_GROUP0_BINDING_COLLISION, \"uniform block 'wgsl_group0_binding_n' must be unique across all uniform blocks\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_SHADERDESC_NO_UB_MEMBERS, \"GL backend requires uniform block member declarations\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_SHADERDESC_UB_UNIFORM_GLSL_NAME, \"uniform block member 'glsl_name' missing\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_SHADERDESC_UB_SIZE_MISMATCH, \"size of uniform block members doesn't match uniform block size\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_SHADERDESC_UB_ARRAY_COUNT, \"uniform array count must be >= 1\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_SHADERDESC_UB_STD140_ARRAY_TYPE, \"uniform arrays only allowed for FLOAT4, INT4, MAT4 in std140 layout\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_SHADERDESC_STORAGEBUFFER_METAL_BUFFER_SLOT_OUT_OF_RANGE, \"storage buffer 'msl_buffer_n' is out of range (must be 8..15)\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_SHADERDESC_STORAGEBUFFER_METAL_BUFFER_SLOT_COLLISION, \"storage buffer 'msl_buffer_n' must be unique across uniform blocks and storage buffer in same shader stage\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_SHADERDESC_STORAGEBUFFER_HLSL_REGISTER_T_OUT_OF_RANGE, \"storage buffer 'hlsl_register_t_n' is out of range (must be 0..23)\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_SHADERDESC_STORAGEBUFFER_HLSL_REGISTER_T_COLLISION, \"storage_buffer 'hlsl_register_t_n' must be unique across storage buffers and images in same shader stage\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_SHADERDESC_STORAGEBUFFER_GLSL_BINDING_OUT_OF_RANGE, \"storage buffer 'glsl_binding_n' is out of range (must be 0..15)\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_SHADERDESC_STORAGEBUFFER_GLSL_BINDING_COLLISION, \"storage buffer 'glsl_binding_n' must be unique across shader stages\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_SHADERDESC_STORAGEBUFFER_WGSL_GROUP1_BINDING_OUT_OF_RANGE, \"storage buffer 'wgsl_group1_binding_n' is out of range (must be 0..127)\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_SHADERDESC_STORAGEBUFFER_WGSL_GROUP1_BINDING_COLLISION, \"storage buffer 'wgsl_group1_binding_n' must be unique across all images, samplers and storage buffers\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_SHADERDESC_STORAGEBUFFER_READONLY, \"shader stage storage buffers must be readonly (sg_shader_desc.storage_buffers[].readonly)\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_SHADERDESC_IMAGE_METAL_TEXTURE_SLOT_OUT_OF_RANGE, \"image 'msl_texture_n' is out of range (must be 0..15)\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_SHADERDESC_IMAGE_METAL_TEXTURE_SLOT_COLLISION, \"image 'msl_texture_n' must be unique in same shader stage\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_SHADERDESC_IMAGE_HLSL_REGISTER_T_OUT_OF_RANGE, \"image 'hlsl_register_t_n' is out of range (must be 0..23)\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_SHADERDESC_IMAGE_HLSL_REGISTER_T_COLLISION, \"image 'hlsl_register_t_n' must be unique across images and storage buffers in same shader stage\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_SHADERDESC_IMAGE_WGSL_GROUP1_BINDING_OUT_OF_RANGE, \"image 'wgsl_group1_binding_n' is out of range (must be 0..127)\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_SHADERDESC_IMAGE_WGSL_GROUP1_BINDING_COLLISION, \"image 'wgsl_group1_binding_n' must be unique across all images, samplers and storage buffers\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_SHADERDESC_SAMPLER_METAL_SAMPLER_SLOT_OUT_OF_RANGE, \"sampler 'msl_sampler_n' is out of range (must be 0..15)\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_SHADERDESC_SAMPLER_METAL_SAMPLER_SLOT_COLLISION, \"sampler 'msl_sampler_n' must be unique in same shader stage\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_SHADERDESC_SAMPLER_HLSL_REGISTER_S_OUT_OF_RANGE, \"sampler 'hlsl_register_s_n' is out of rang (must be 0..15)\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_SHADERDESC_SAMPLER_HLSL_REGISTER_S_COLLISION, \"sampler 'hlsl_register_s_n' must be unique in same shader stage\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_SHADERDESC_SAMPLER_WGSL_GROUP1_BINDING_OUT_OF_RANGE, \"sampler 'wgsl_group1_binding_n' is out of range (must be 0..127)\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_SHADERDESC_SAMPLER_WGSL_GROUP1_BINDING_COLLISION, \"sampler 'wgsl_group1_binding_n' must be unique across all images, samplers and storage buffers\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_SHADERDESC_IMAGE_SAMPLER_PAIR_IMAGE_SLOT_OUT_OF_RANGE, \"image-sampler-pair image slot index is out of range (sg_shader_desc.image_sampler_pairs[].image_slot)\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_SHADERDESC_IMAGE_SAMPLER_PAIR_SAMPLER_SLOT_OUT_OF_RANGE, \"image-sampler-pair sampler slot index is out of range (sg_shader_desc.image_sampler_pairs[].sampler_slot)\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_SHADERDESC_IMAGE_SAMPLER_PAIR_IMAGE_STAGE_MISMATCH, \"image-sampler-pair stage doesn't match referenced image stage\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_SHADERDESC_IMAGE_SAMPLER_PAIR_SAMPLER_STAGE_MISMATCH, \"image-sampler-pair stage doesn't match referenced sampler stage\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_SHADERDESC_IMAGE_SAMPLER_PAIR_GLSL_NAME, \"image-sampler-pair 'glsl_name' missing\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_SHADERDESC_NONFILTERING_SAMPLER_REQUIRED, \"image sample type UNFILTERABLE_FLOAT, UINT, SINT can only be used with NONFILTERING sampler\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_SHADERDESC_COMPARISON_SAMPLER_REQUIRED, \"image sample type DEPTH can only be used with COMPARISON sampler\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_SHADERDESC_IMAGE_NOT_REFERENCED_BY_IMAGE_SAMPLER_PAIRS, \"one or more images are not referenced by by image-sampler-pairs (sg_shader_desc.image_sampler_pairs[].image_slot)\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_SHADERDESC_SAMPLER_NOT_REFERENCED_BY_IMAGE_SAMPLER_PAIRS, \"one or more samplers are not referenced by image-sampler-pairs (sg_shader_desc.image_sampler_pairs[].sampler_slot)\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_SHADERDESC_ATTR_STRING_TOO_LONG, \"vertex attribute name/semantic string too long (max len 16)\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_PIPELINEDESC_CANARY, \"sg_pipeline_desc not initialized\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_PIPELINEDESC_SHADER, \"sg_pipeline_desc.shader missing or invalid\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_PIPELINEDESC_NO_CONT_ATTRS, \"sg_pipeline_desc.layout.attrs is not continuous\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_PIPELINEDESC_LAYOUT_STRIDE4, \"sg_pipeline_desc.layout.buffers[].stride must be multiple of 4\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_PIPELINEDESC_ATTR_SEMANTICS, \"D3D11 missing vertex attribute semantics in shader\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_ATTACHMENTSDESC_CANARY, \"sg_attachments_desc not initialized\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_ATTACHMENTSDESC_NO_ATTACHMENTS, \"sg_attachments_desc no color or depth-stencil attachments\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_ATTACHMENTSDESC_NO_CONT_COLOR_ATTS, \"color attachments must occupy continuous slots\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_ATTACHMENTSDESC_IMAGE, \"pass attachment image is not valid\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_ATTACHMENTSDESC_MIPLEVEL, \"pass attachment mip level is bigger than image has mipmaps\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_ATTACHMENTSDESC_FACE, \"pass attachment image is cubemap, but face index is too big\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_ATTACHMENTSDESC_LAYER, \"pass attachment image is array texture, but layer index is too big\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_ATTACHMENTSDESC_SLICE, \"pass attachment image is 3d texture, but slice value is too big\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_ATTACHMENTSDESC_IMAGE_NO_RT, \"pass attachment image must be have render_target=true\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_ATTACHMENTSDESC_COLOR_INV_PIXELFORMAT, \"pass color-attachment images must be renderable color pixel format\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_ATTACHMENTSDESC_DEPTH_INV_PIXELFORMAT, \"pass depth-attachment image must be depth or depth-stencil pixel format\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_ATTACHMENTSDESC_IMAGE_SIZES, \"all pass attachments must have the same size\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_ATTACHMENTSDESC_IMAGE_SAMPLE_COUNTS, \"all pass attachments must have the same sample count\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_ATTACHMENTSDESC_RESOLVE_COLOR_IMAGE_MSAA, \"pass resolve attachments must have a color attachment image with sample count > 1\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_ATTACHMENTSDESC_RESOLVE_IMAGE, \"pass resolve attachment image not valid\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_ATTACHMENTSDESC_RESOLVE_SAMPLE_COUNT, \"pass resolve attachment image sample count must be 1\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_ATTACHMENTSDESC_RESOLVE_MIPLEVEL, \"pass resolve attachment mip level is bigger than image has mipmaps\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_ATTACHMENTSDESC_RESOLVE_FACE, \"pass resolve attachment is cubemap, but face index is too big\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_ATTACHMENTSDESC_RESOLVE_LAYER, \"pass resolve attachment is array texture, but layer index is too big\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_ATTACHMENTSDESC_RESOLVE_SLICE, \"pass resolve attachment is 3d texture, but slice value is too big\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_ATTACHMENTSDESC_RESOLVE_IMAGE_NO_RT, \"pass resolve attachment image must have render_target=true\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_ATTACHMENTSDESC_RESOLVE_IMAGE_SIZES, \"pass resolve attachment size must match color attachment image size\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_ATTACHMENTSDESC_RESOLVE_IMAGE_FORMAT, \"pass resolve attachment pixel format must match color attachment pixel format\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_ATTACHMENTSDESC_DEPTH_IMAGE, \"pass depth attachment image is not valid\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_ATTACHMENTSDESC_DEPTH_MIPLEVEL, \"pass depth attachment mip level is bigger than image has mipmaps\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_ATTACHMENTSDESC_DEPTH_FACE, \"pass depth attachment image is cubemap, but face index is too big\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_ATTACHMENTSDESC_DEPTH_LAYER, \"pass depth attachment image is array texture, but layer index is too big\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_ATTACHMENTSDESC_DEPTH_SLICE, \"pass depth attachment image is 3d texture, but slice value is too big\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_ATTACHMENTSDESC_DEPTH_IMAGE_NO_RT, \"pass depth attachment image must be have render_target=true\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_ATTACHMENTSDESC_DEPTH_IMAGE_SIZES, \"pass depth attachment image size must match color attachment image size\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_ATTACHMENTSDESC_DEPTH_IMAGE_SAMPLE_COUNT, \"pass depth attachment sample count must match color attachment sample count\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_BEGINPASS_CANARY, \"sg_begin_pass: pass struct not initialized\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_BEGINPASS_ATTACHMENTS_EXISTS, \"sg_begin_pass: attachments object no longer alive\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_BEGINPASS_ATTACHMENTS_VALID, \"sg_begin_pass: attachments object not in resource state VALID\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_BEGINPASS_COLOR_ATTACHMENT_IMAGE, \"sg_begin_pass: one or more color attachment images are not valid\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_BEGINPASS_RESOLVE_ATTACHMENT_IMAGE, \"sg_begin_pass: one or more resolve attachment images are not valid\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_BEGINPASS_DEPTHSTENCIL_ATTACHMENT_IMAGE, \"sg_begin_pass: one or more depth-stencil attachment images are not valid\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_BEGINPASS_SWAPCHAIN_EXPECT_WIDTH, \"sg_begin_pass: expected pass.swapchain.width > 0\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_BEGINPASS_SWAPCHAIN_EXPECT_WIDTH_NOTSET, \"sg_begin_pass: expected pass.swapchain.width == 0\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_BEGINPASS_SWAPCHAIN_EXPECT_HEIGHT, \"sg_begin_pass: expected pass.swapchain.height > 0\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_BEGINPASS_SWAPCHAIN_EXPECT_HEIGHT_NOTSET, \"sg_begin_pass: expected pass.swapchain.height == 0\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_BEGINPASS_SWAPCHAIN_EXPECT_SAMPLECOUNT, \"sg_begin_pass: expected pass.swapchain.sample_count > 0\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_BEGINPASS_SWAPCHAIN_EXPECT_SAMPLECOUNT_NOTSET, \"sg_begin_pass: expected pass.swapchain.sample_count == 0\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_BEGINPASS_SWAPCHAIN_EXPECT_COLORFORMAT, \"sg_begin_pass: expected pass.swapchain.color_format to be valid\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_BEGINPASS_SWAPCHAIN_EXPECT_COLORFORMAT_NOTSET, \"sg_begin_pass: expected pass.swapchain.color_format to be unset\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_BEGINPASS_SWAPCHAIN_EXPECT_DEPTHFORMAT_NOTSET, \"sg_begin_pass: expected pass.swapchain.depth_format to be unset\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_BEGINPASS_SWAPCHAIN_METAL_EXPECT_CURRENTDRAWABLE, \"sg_begin_pass: expected pass.swapchain.metal.current_drawable != 0\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_BEGINPASS_SWAPCHAIN_METAL_EXPECT_CURRENTDRAWABLE_NOTSET, \"sg_begin_pass: expected pass.swapchain.metal.current_drawable == 0\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_BEGINPASS_SWAPCHAIN_METAL_EXPECT_DEPTHSTENCILTEXTURE, \"sg_begin_pass: expected pass.swapchain.metal.depth_stencil_texture != 0\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_BEGINPASS_SWAPCHAIN_METAL_EXPECT_DEPTHSTENCILTEXTURE_NOTSET, \"sg_begin_pass: expected pass.swapchain.metal.depth_stencil_texture == 0\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_BEGINPASS_SWAPCHAIN_METAL_EXPECT_MSAACOLORTEXTURE, \"sg_begin_pass: expected pass.swapchain.metal.msaa_color_texture != 0\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_BEGINPASS_SWAPCHAIN_METAL_EXPECT_MSAACOLORTEXTURE_NOTSET, \"sg_begin_pass: expected pass.swapchain.metal.msaa_color_texture == 0\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_BEGINPASS_SWAPCHAIN_D3D11_EXPECT_RENDERVIEW, \"sg_begin_pass: expected pass.swapchain.d3d11.render_view != 0\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_BEGINPASS_SWAPCHAIN_D3D11_EXPECT_RENDERVIEW_NOTSET, \"sg_begin_pass: expected pass.swapchain.d3d11.render_view == 0\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_BEGINPASS_SWAPCHAIN_D3D11_EXPECT_RESOLVEVIEW, \"sg_begin_pass: expected pass.swapchain.d3d11.resolve_view != 0\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_BEGINPASS_SWAPCHAIN_D3D11_EXPECT_RESOLVEVIEW_NOTSET, \"sg_begin_pass: expected pass.swapchain.d3d11.resolve_view == 0\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_BEGINPASS_SWAPCHAIN_D3D11_EXPECT_DEPTHSTENCILVIEW, \"sg_begin_pass: expected pass.swapchain.d3d11.depth_stencil_view != 0\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_BEGINPASS_SWAPCHAIN_D3D11_EXPECT_DEPTHSTENCILVIEW_NOTSET, \"sg_begin_pass: expected pass.swapchain.d3d11.depth_stencil_view == 0\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_BEGINPASS_SWAPCHAIN_WGPU_EXPECT_RENDERVIEW, \"sg_begin_pass: expected pass.swapchain.wgpu.render_view != 0\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_BEGINPASS_SWAPCHAIN_WGPU_EXPECT_RENDERVIEW_NOTSET, \"sg_begin_pass: expected pass.swapchain.wgpu.render_view == 0\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_BEGINPASS_SWAPCHAIN_WGPU_EXPECT_RESOLVEVIEW, \"sg_begin_pass: expected pass.swapchain.wgpu.resolve_view != 0\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_BEGINPASS_SWAPCHAIN_WGPU_EXPECT_RESOLVEVIEW_NOTSET, \"sg_begin_pass: expected pass.swapchain.wgpu.resolve_view == 0\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_BEGINPASS_SWAPCHAIN_WGPU_EXPECT_DEPTHSTENCILVIEW, \"sg_begin_pass: expected pass.swapchain.wgpu.depth_stencil_view != 0\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_BEGINPASS_SWAPCHAIN_WGPU_EXPECT_DEPTHSTENCILVIEW_NOTSET, \"sg_begin_pass: expected pass.swapchain.wgpu.depth_stencil_view == 0\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_BEGINPASS_SWAPCHAIN_GL_EXPECT_FRAMEBUFFER_NOTSET, \"sg_begin_pass: expected pass.swapchain.gl.framebuffer == 0\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_APIP_PIPELINE_VALID_ID, \"sg_apply_pipeline: invalid pipeline id provided\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_APIP_PIPELINE_EXISTS, \"sg_apply_pipeline: pipeline object no longer alive\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_APIP_PIPELINE_VALID, \"sg_apply_pipeline: pipeline object not in valid state\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_APIP_SHADER_EXISTS, \"sg_apply_pipeline: shader object no longer alive\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_APIP_SHADER_VALID, \"sg_apply_pipeline: shader object not in valid state\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_APIP_CURPASS_ATTACHMENTS_EXISTS, \"sg_apply_pipeline: current pass attachments no longer alive\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_APIP_CURPASS_ATTACHMENTS_VALID, \"sg_apply_pipeline: current pass attachments not in valid state\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_APIP_ATT_COUNT, \"sg_apply_pipeline: number of pipeline color attachments doesn't match number of pass color attachments\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_APIP_COLOR_FORMAT, \"sg_apply_pipeline: pipeline color attachment pixel format doesn't match pass color attachment pixel format\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_APIP_DEPTH_FORMAT, \"sg_apply_pipeline: pipeline depth pixel_format doesn't match pass depth attachment pixel format\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_APIP_SAMPLE_COUNT, \"sg_apply_pipeline: pipeline MSAA sample count doesn't match render pass attachment sample count\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_ABND_PIPELINE, \"sg_apply_bindings: must be called after sg_apply_pipeline\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_ABND_PIPELINE_EXISTS, \"sg_apply_bindings: currently applied pipeline object no longer alive\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_ABND_PIPELINE_VALID, \"sg_apply_bindings: currently applied pipeline object not in valid state\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_ABND_EXPECTED_VB, \"sg_apply_bindings: vertex buffer binding is missing or buffer handle is invalid\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_ABND_VB_EXISTS, \"sg_apply_bindings: vertex buffer no longer alive\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_ABND_VB_TYPE, \"sg_apply_bindings: buffer in vertex buffer slot is not a SG_BUFFERTYPE_VERTEXBUFFER\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_ABND_VB_OVERFLOW, \"sg_apply_bindings: buffer in vertex buffer slot is overflown\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_ABND_NO_IB, \"sg_apply_bindings: pipeline object defines indexed rendering, but no index buffer provided\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_ABND_IB, \"sg_apply_bindings: pipeline object defines non-indexed rendering, but index buffer provided\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_ABND_IB_EXISTS, \"sg_apply_bindings: index buffer no longer alive\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_ABND_IB_TYPE, \"sg_apply_bindings: buffer in index buffer slot is not a SG_BUFFERTYPE_INDEXBUFFER\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_ABND_IB_OVERFLOW, \"sg_apply_bindings: buffer in index buffer slot is overflown\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_ABND_EXPECTED_IMAGE_BINDING, \"sg_apply_bindings: image binding is missing or the image handle is invalid\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_ABND_IMG_EXISTS, \"sg_apply_bindings: bound image no longer alive\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_ABND_IMAGE_TYPE_MISMATCH, \"sg_apply_bindings: type of bound image doesn't match shader desc\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_ABND_EXPECTED_MULTISAMPLED_IMAGE, \"sg_apply_bindings: expected image with sample_count > 1\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_ABND_IMAGE_MSAA, \"sg_apply_bindings: cannot bind image with sample_count>1\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_ABND_EXPECTED_FILTERABLE_IMAGE, \"sg_apply_bindings: filterable image expected\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_ABND_EXPECTED_DEPTH_IMAGE, \"sg_apply_bindings: depth image expected\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_ABND_EXPECTED_SAMPLER_BINDING, \"sg_apply_bindings: sampler binding is missing or the sampler handle is invalid\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_ABND_UNEXPECTED_SAMPLER_COMPARE_NEVER, \"sg_apply_bindings: shader expects SG_SAMPLERTYPE_COMPARISON but sampler has SG_COMPAREFUNC_NEVER\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_ABND_EXPECTED_SAMPLER_COMPARE_NEVER, \"sg_apply_bindings: shader expects SG_SAMPLERTYPE_FILTERING or SG_SAMPLERTYPE_NONFILTERING but sampler doesn't have SG_COMPAREFUNC_NEVER\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_ABND_EXPECTED_NONFILTERING_SAMPLER, \"sg_apply_bindings: shader expected SG_SAMPLERTYPE_NONFILTERING, but sampler has SG_FILTER_LINEAR filters\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_ABND_SMP_EXISTS, \"sg_apply_bindings: bound sampler no longer alive\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_ABND_EXPECTED_STORAGEBUFFER_BINDING, \"sg_apply_bindings: storage buffer binding is missing or the buffer handle is invalid\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_ABND_STORAGEBUFFER_EXISTS, \"sg_apply_bindings: bound storage buffer no longer alive\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_ABND_STORAGEBUFFER_BINDING_BUFFERTYPE, \"sg_apply_bindings: buffer bound storage buffer slot is not of type storage buffer\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_AUB_NO_PIPELINE, \"sg_apply_uniforms: must be called after sg_apply_pipeline()\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_AUB_NO_UB_AT_SLOT, \"sg_apply_uniforms: no uniform block declaration at this shader stage UB slot\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_AUB_SIZE, \"sg_apply_uniforms: data size doesn't match declared uniform block size\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_UPDATEBUF_USAGE, \"sg_update_buffer: cannot update immutable buffer\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_UPDATEBUF_SIZE, \"sg_update_buffer: update size is bigger than buffer size\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_UPDATEBUF_ONCE, \"sg_update_buffer: only one update allowed per buffer and frame\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_UPDATEBUF_APPEND, \"sg_update_buffer: cannot call sg_update_buffer and sg_append_buffer in same frame\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_APPENDBUF_USAGE, \"sg_append_buffer: cannot append to immutable buffer\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_APPENDBUF_SIZE, \"sg_append_buffer: overall appended size is bigger than buffer size\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_APPENDBUF_UPDATE, \"sg_append_buffer: cannot call sg_append_buffer and sg_update_buffer in same frame\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_UPDIMG_USAGE, \"sg_update_image: cannot update immutable image\") \\\n    _SG_LOGITEM_XMACRO(VALIDATE_UPDIMG_ONCE, \"sg_update_image: only one update allowed per image and frame\") \\\n    _SG_LOGITEM_XMACRO(VALIDATION_FAILED, \"validation layer checks failed\") \\\n\n#define _SG_LOGITEM_XMACRO(item,msg) SG_LOGITEM_##item,\ntypedef enum sg_log_item {\n    _SG_LOG_ITEMS\n} sg_log_item;\n#undef _SG_LOGITEM_XMACRO\n\n/*\n    sg_desc\n\n    The sg_desc struct contains configuration values for sokol_gfx,\n    it is used as parameter to the sg_setup() call.\n\n    The default configuration is:\n\n    .buffer_pool_size       128\n    .image_pool_size        128\n    .sampler_pool_size      64\n    .shader_pool_size       32\n    .pipeline_pool_size     64\n    .pass_pool_size         16\n    .uniform_buffer_size    4 MB (4*1024*1024)\n    .max_commit_listeners   1024\n    .disable_validation     false\n    .mtl_force_managed_storage_mode false\n    .wgpu_disable_bindgroups_cache  false\n    .wgpu_bindgroups_cache_size     1024\n\n    .allocator.alloc_fn     0 (in this case, malloc() will be called)\n    .allocator.free_fn      0 (in this case, free() will be called)\n    .allocator.user_data    0\n\n    .environment.defaults.color_format: default value depends on selected backend:\n        all GL backends:    SG_PIXELFORMAT_RGBA8\n        Metal and D3D11:    SG_PIXELFORMAT_BGRA8\n        WebGPU:             *no default* (must be queried from WebGPU swapchain object)\n    .environment.defaults.depth_format: SG_PIXELFORMAT_DEPTH_STENCIL\n    .environment.defaults.sample_count: 1\n\n    Metal specific:\n        (NOTE: All Objective-C object references are transferred through\n        a bridged cast (__bridge const void*) to sokol_gfx, which will use an\n        unretained bridged cast (__bridge id<xxx>) to retrieve the Objective-C\n        references back. Since the bridge cast is unretained, the caller\n        must hold a strong reference to the Objective-C object until sg_setup()\n        returns.\n\n        .mtl_force_managed_storage_mode\n            when enabled, Metal buffers and texture resources are created in managed storage\n            mode, otherwise sokol-gfx will decide whether to create buffers and\n            textures in managed or shared storage mode (this is mainly a debugging option)\n        .mtl_use_command_buffer_with_retained_references\n            when true, the sokol-gfx Metal backend will use Metal command buffers which\n            bump the reference count of resource objects as long as they are inflight,\n            this is slower than the default command-buffer-with-unretained-references\n            method, this may be a workaround when confronted with lifetime validation\n            errors from the Metal validation layer until a proper fix has been implemented\n        .environment.metal.device\n            a pointer to the MTLDevice object\n\n    D3D11 specific:\n        .environment.d3d11.device\n            a pointer to the ID3D11Device object, this must have been created\n            before sg_setup() is called\n        .environment.d3d11.device_context\n            a pointer to the ID3D11DeviceContext object\n        .d3d11_shader_debugging\n            set this to true to compile shaders which are provided as HLSL source\n            code with debug information and without optimization, this allows\n            shader debugging in tools like RenderDoc, to output source code\n            instead of byte code from sokol-shdc, omit the `--binary` cmdline\n            option\n\n    WebGPU specific:\n        .wgpu_disable_bindgroups_cache\n            When this is true, the WebGPU backend will create and immediately\n            release a BindGroup object in the sg_apply_bindings() call, only\n            use this for debugging purposes.\n        .wgpu_bindgroups_cache_size\n            The size of the bindgroups cache for re-using BindGroup objects\n            between sg_apply_bindings() calls. The smaller the cache size,\n            the more likely are cache slot collisions which will cause\n            a BindGroups object to be destroyed and a new one created.\n            Use the information returned by sg_query_stats() to check\n            if this is a frequent occurrence, and increase the cache size as\n            needed (the default is 1024).\n            NOTE: wgpu_bindgroups_cache_size must be a power-of-2 number!\n        .environment.wgpu.device\n            a WGPUDevice handle\n\n    When using sokol_gfx.h and sokol_app.h together, consider using the\n    helper function sglue_environment() in the sokol_glue.h header to\n    initialize the sg_desc.environment nested struct. sglue_environment() returns\n    a completely initialized sg_environment struct with information\n    provided by sokol_app.h.\n*/\ntypedef struct sg_environment_defaults {\n    sg_pixel_format color_format;\n    sg_pixel_format depth_format;\n    int sample_count;\n} sg_environment_defaults;\n\ntypedef struct sg_metal_environment {\n    const void* device;\n} sg_metal_environment;\n\ntypedef struct sg_d3d11_environment {\n    const void* device;\n    const void* device_context;\n} sg_d3d11_environment;\n\ntypedef struct sg_wgpu_environment {\n    const void* device;\n} sg_wgpu_environment;\n\ntypedef struct sg_environment {\n    sg_environment_defaults defaults;\n    sg_metal_environment metal;\n    sg_d3d11_environment d3d11;\n    sg_wgpu_environment wgpu;\n} sg_environment;\n\n/*\n    sg_commit_listener\n\n    Used with function sg_add_commit_listener() to add a callback\n    which will be called in sg_commit(). This is useful for libraries\n    building on top of sokol-gfx to be notified about when a frame\n    ends (instead of having to guess, or add a manual 'new-frame'\n    function.\n*/\ntypedef struct sg_commit_listener {\n    void (*func)(void* user_data);\n    void* user_data;\n} sg_commit_listener;\n\n/*\n    sg_allocator\n\n    Used in sg_desc to provide custom memory-alloc and -free functions\n    to sokol_gfx.h. If memory management should be overridden, both the\n    alloc_fn and free_fn function must be provided (e.g. it's not valid to\n    override one function but not the other).\n*/\ntypedef struct sg_allocator {\n    void* (*alloc_fn)(size_t size, void* user_data);\n    void (*free_fn)(void* ptr, void* user_data);\n    void* user_data;\n} sg_allocator;\n\n/*\n    sg_logger\n\n    Used in sg_desc to provide a logging function. Please be aware\n    that without logging function, sokol-gfx will be completely\n    silent, e.g. it will not report errors, warnings and\n    validation layer messages. For maximum error verbosity,\n    compile in debug mode (e.g. NDEBUG *not* defined) and provide a\n    compatible logger function in the sg_setup() call\n    (for instance the standard logging function from sokol_log.h).\n*/\ntypedef struct sg_logger {\n    void (*func)(\n        const char* tag,                // always \"sg\"\n        uint32_t log_level,             // 0=panic, 1=error, 2=warning, 3=info\n        uint32_t log_item_id,           // SG_LOGITEM_*\n        const char* message_or_null,    // a message string, may be nullptr in release mode\n        uint32_t line_nr,               // line number in sokol_gfx.h\n        const char* filename_or_null,   // source filename, may be nullptr in release mode\n        void* user_data);\n    void* user_data;\n} sg_logger;\n\ntypedef struct sg_desc {\n    uint32_t _start_canary;\n    int buffer_pool_size;\n    int image_pool_size;\n    int sampler_pool_size;\n    int shader_pool_size;\n    int pipeline_pool_size;\n    int attachments_pool_size;\n    int uniform_buffer_size;\n    int max_commit_listeners;\n    bool disable_validation;    // disable validation layer even in debug mode, useful for tests\n    bool d3d11_shader_debugging;    // if true, HLSL shaders are compiled with D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION\n    bool mtl_force_managed_storage_mode; // for debugging: use Metal managed storage mode for resources even with UMA\n    bool mtl_use_command_buffer_with_retained_references;    // Metal: use a managed MTLCommandBuffer which ref-counts used resources\n    bool wgpu_disable_bindgroups_cache;  // set to true to disable the WebGPU backend BindGroup cache\n    int wgpu_bindgroups_cache_size;      // number of slots in the WebGPU bindgroup cache (must be 2^N)\n    sg_allocator allocator;\n    sg_logger logger; // optional log function override\n    sg_environment environment;\n    uint32_t _end_canary;\n} sg_desc;\n\n// setup and misc functions\nSOKOL_GFX_API_DECL void sg_setup(const sg_desc* desc);\nSOKOL_GFX_API_DECL void sg_shutdown(void);\nSOKOL_GFX_API_DECL bool sg_isvalid(void);\nSOKOL_GFX_API_DECL void sg_reset_state_cache(void);\nSOKOL_GFX_API_DECL sg_trace_hooks sg_install_trace_hooks(const sg_trace_hooks* trace_hooks);\nSOKOL_GFX_API_DECL void sg_push_debug_group(const char* name);\nSOKOL_GFX_API_DECL void sg_pop_debug_group(void);\nSOKOL_GFX_API_DECL bool sg_add_commit_listener(sg_commit_listener listener);\nSOKOL_GFX_API_DECL bool sg_remove_commit_listener(sg_commit_listener listener);\n\n// resource creation, destruction and updating\nSOKOL_GFX_API_DECL sg_buffer sg_make_buffer(const sg_buffer_desc* desc);\nSOKOL_GFX_API_DECL sg_image sg_make_image(const sg_image_desc* desc);\nSOKOL_GFX_API_DECL sg_sampler sg_make_sampler(const sg_sampler_desc* desc);\nSOKOL_GFX_API_DECL sg_shader sg_make_shader(const sg_shader_desc* desc);\nSOKOL_GFX_API_DECL sg_pipeline sg_make_pipeline(const sg_pipeline_desc* desc);\nSOKOL_GFX_API_DECL sg_attachments sg_make_attachments(const sg_attachments_desc* desc);\nSOKOL_GFX_API_DECL void sg_destroy_buffer(sg_buffer buf);\nSOKOL_GFX_API_DECL void sg_destroy_image(sg_image img);\nSOKOL_GFX_API_DECL void sg_destroy_sampler(sg_sampler smp);\nSOKOL_GFX_API_DECL void sg_destroy_shader(sg_shader shd);\nSOKOL_GFX_API_DECL void sg_destroy_pipeline(sg_pipeline pip);\nSOKOL_GFX_API_DECL void sg_destroy_attachments(sg_attachments atts);\nSOKOL_GFX_API_DECL void sg_update_buffer(sg_buffer buf, const sg_range* data);\nSOKOL_GFX_API_DECL void sg_update_image(sg_image img, const sg_image_data* data);\nSOKOL_GFX_API_DECL int sg_append_buffer(sg_buffer buf, const sg_range* data);\nSOKOL_GFX_API_DECL bool sg_query_buffer_overflow(sg_buffer buf);\nSOKOL_GFX_API_DECL bool sg_query_buffer_will_overflow(sg_buffer buf, size_t size);\n\n// rendering functions\nSOKOL_GFX_API_DECL void sg_begin_pass(const sg_pass* pass);\nSOKOL_GFX_API_DECL void sg_apply_viewport(int x, int y, int width, int height, bool origin_top_left);\nSOKOL_GFX_API_DECL void sg_apply_viewportf(float x, float y, float width, float height, bool origin_top_left);\nSOKOL_GFX_API_DECL void sg_apply_scissor_rect(int x, int y, int width, int height, bool origin_top_left);\nSOKOL_GFX_API_DECL void sg_apply_scissor_rectf(float x, float y, float width, float height, bool origin_top_left);\nSOKOL_GFX_API_DECL void sg_apply_pipeline(sg_pipeline pip);\nSOKOL_GFX_API_DECL void sg_apply_bindings(const sg_bindings* bindings);\nSOKOL_GFX_API_DECL void sg_apply_uniforms(int ub_slot, const sg_range* data);\nSOKOL_GFX_API_DECL void sg_draw(int base_element, int num_elements, int num_instances);\nSOKOL_GFX_API_DECL void sg_end_pass(void);\nSOKOL_GFX_API_DECL void sg_commit(void);\n\n// getting information\nSOKOL_GFX_API_DECL sg_desc sg_query_desc(void);\nSOKOL_GFX_API_DECL sg_backend sg_query_backend(void);\nSOKOL_GFX_API_DECL sg_features sg_query_features(void);\nSOKOL_GFX_API_DECL sg_limits sg_query_limits(void);\nSOKOL_GFX_API_DECL sg_pixelformat_info sg_query_pixelformat(sg_pixel_format fmt);\nSOKOL_GFX_API_DECL int sg_query_row_pitch(sg_pixel_format fmt, int width, int row_align_bytes);\nSOKOL_GFX_API_DECL int sg_query_surface_pitch(sg_pixel_format fmt, int width, int height, int row_align_bytes);\n// get current state of a resource (INITIAL, ALLOC, VALID, FAILED, INVALID)\nSOKOL_GFX_API_DECL sg_resource_state sg_query_buffer_state(sg_buffer buf);\nSOKOL_GFX_API_DECL sg_resource_state sg_query_image_state(sg_image img);\nSOKOL_GFX_API_DECL sg_resource_state sg_query_sampler_state(sg_sampler smp);\nSOKOL_GFX_API_DECL sg_resource_state sg_query_shader_state(sg_shader shd);\nSOKOL_GFX_API_DECL sg_resource_state sg_query_pipeline_state(sg_pipeline pip);\nSOKOL_GFX_API_DECL sg_resource_state sg_query_attachments_state(sg_attachments atts);\n// get runtime information about a resource\nSOKOL_GFX_API_DECL sg_buffer_info sg_query_buffer_info(sg_buffer buf);\nSOKOL_GFX_API_DECL sg_image_info sg_query_image_info(sg_image img);\nSOKOL_GFX_API_DECL sg_sampler_info sg_query_sampler_info(sg_sampler smp);\nSOKOL_GFX_API_DECL sg_shader_info sg_query_shader_info(sg_shader shd);\nSOKOL_GFX_API_DECL sg_pipeline_info sg_query_pipeline_info(sg_pipeline pip);\nSOKOL_GFX_API_DECL sg_attachments_info sg_query_attachments_info(sg_attachments atts);\n// get desc structs matching a specific resource (NOTE that not all creation attributes may be provided)\nSOKOL_GFX_API_DECL sg_buffer_desc sg_query_buffer_desc(sg_buffer buf);\nSOKOL_GFX_API_DECL sg_image_desc sg_query_image_desc(sg_image img);\nSOKOL_GFX_API_DECL sg_sampler_desc sg_query_sampler_desc(sg_sampler smp);\nSOKOL_GFX_API_DECL sg_shader_desc sg_query_shader_desc(sg_shader shd);\nSOKOL_GFX_API_DECL sg_pipeline_desc sg_query_pipeline_desc(sg_pipeline pip);\nSOKOL_GFX_API_DECL sg_attachments_desc sg_query_attachments_desc(sg_attachments atts);\n// get resource creation desc struct with their default values replaced\nSOKOL_GFX_API_DECL sg_buffer_desc sg_query_buffer_defaults(const sg_buffer_desc* desc);\nSOKOL_GFX_API_DECL sg_image_desc sg_query_image_defaults(const sg_image_desc* desc);\nSOKOL_GFX_API_DECL sg_sampler_desc sg_query_sampler_defaults(const sg_sampler_desc* desc);\nSOKOL_GFX_API_DECL sg_shader_desc sg_query_shader_defaults(const sg_shader_desc* desc);\nSOKOL_GFX_API_DECL sg_pipeline_desc sg_query_pipeline_defaults(const sg_pipeline_desc* desc);\nSOKOL_GFX_API_DECL sg_attachments_desc sg_query_attachments_defaults(const sg_attachments_desc* desc);\n// assorted query functions\nSOKOL_GFX_API_DECL size_t sg_query_buffer_size(sg_buffer buf);\nSOKOL_GFX_API_DECL sg_buffer_type sg_query_buffer_type(sg_buffer buf);\nSOKOL_GFX_API_DECL sg_usage sg_query_buffer_usage(sg_buffer buf);\nSOKOL_GFX_API_DECL sg_image_type sg_query_image_type(sg_image img);\nSOKOL_GFX_API_DECL int sg_query_image_width(sg_image img);\nSOKOL_GFX_API_DECL int sg_query_image_height(sg_image img);\nSOKOL_GFX_API_DECL int sg_query_image_num_slices(sg_image img);\nSOKOL_GFX_API_DECL int sg_query_image_num_mipmaps(sg_image img);\nSOKOL_GFX_API_DECL sg_pixel_format sg_query_image_pixelformat(sg_image img);\nSOKOL_GFX_API_DECL sg_usage sg_query_image_usage(sg_image img);\nSOKOL_GFX_API_DECL int sg_query_image_sample_count(sg_image img);\n\n// separate resource allocation and initialization (for async setup)\nSOKOL_GFX_API_DECL sg_buffer sg_alloc_buffer(void);\nSOKOL_GFX_API_DECL sg_image sg_alloc_image(void);\nSOKOL_GFX_API_DECL sg_sampler sg_alloc_sampler(void);\nSOKOL_GFX_API_DECL sg_shader sg_alloc_shader(void);\nSOKOL_GFX_API_DECL sg_pipeline sg_alloc_pipeline(void);\nSOKOL_GFX_API_DECL sg_attachments sg_alloc_attachments(void);\nSOKOL_GFX_API_DECL void sg_dealloc_buffer(sg_buffer buf);\nSOKOL_GFX_API_DECL void sg_dealloc_image(sg_image img);\nSOKOL_GFX_API_DECL void sg_dealloc_sampler(sg_sampler smp);\nSOKOL_GFX_API_DECL void sg_dealloc_shader(sg_shader shd);\nSOKOL_GFX_API_DECL void sg_dealloc_pipeline(sg_pipeline pip);\nSOKOL_GFX_API_DECL void sg_dealloc_attachments(sg_attachments attachments);\nSOKOL_GFX_API_DECL void sg_init_buffer(sg_buffer buf, const sg_buffer_desc* desc);\nSOKOL_GFX_API_DECL void sg_init_image(sg_image img, const sg_image_desc* desc);\nSOKOL_GFX_API_DECL void sg_init_sampler(sg_sampler smg, const sg_sampler_desc* desc);\nSOKOL_GFX_API_DECL void sg_init_shader(sg_shader shd, const sg_shader_desc* desc);\nSOKOL_GFX_API_DECL void sg_init_pipeline(sg_pipeline pip, const sg_pipeline_desc* desc);\nSOKOL_GFX_API_DECL void sg_init_attachments(sg_attachments attachments, const sg_attachments_desc* desc);\nSOKOL_GFX_API_DECL void sg_uninit_buffer(sg_buffer buf);\nSOKOL_GFX_API_DECL void sg_uninit_image(sg_image img);\nSOKOL_GFX_API_DECL void sg_uninit_sampler(sg_sampler smp);\nSOKOL_GFX_API_DECL void sg_uninit_shader(sg_shader shd);\nSOKOL_GFX_API_DECL void sg_uninit_pipeline(sg_pipeline pip);\nSOKOL_GFX_API_DECL void sg_uninit_attachments(sg_attachments atts);\nSOKOL_GFX_API_DECL void sg_fail_buffer(sg_buffer buf);\nSOKOL_GFX_API_DECL void sg_fail_image(sg_image img);\nSOKOL_GFX_API_DECL void sg_fail_sampler(sg_sampler smp);\nSOKOL_GFX_API_DECL void sg_fail_shader(sg_shader shd);\nSOKOL_GFX_API_DECL void sg_fail_pipeline(sg_pipeline pip);\nSOKOL_GFX_API_DECL void sg_fail_attachments(sg_attachments atts);\n\n// frame stats\nSOKOL_GFX_API_DECL void sg_enable_frame_stats(void);\nSOKOL_GFX_API_DECL void sg_disable_frame_stats(void);\nSOKOL_GFX_API_DECL bool sg_frame_stats_enabled(void);\nSOKOL_GFX_API_DECL sg_frame_stats sg_query_frame_stats(void);\n\n/* Backend-specific structs and functions, these may come in handy for mixing\n   sokol-gfx rendering with 'native backend' rendering functions.\n\n   This group of functions will be expanded as needed.\n*/\n\ntypedef struct sg_d3d11_buffer_info {\n    const void* buf;      // ID3D11Buffer*\n} sg_d3d11_buffer_info;\n\ntypedef struct sg_d3d11_image_info {\n    const void* tex2d;    // ID3D11Texture2D*\n    const void* tex3d;    // ID3D11Texture3D*\n    const void* res;      // ID3D11Resource* (either tex2d or tex3d)\n    const void* srv;      // ID3D11ShaderResourceView*\n} sg_d3d11_image_info;\n\ntypedef struct sg_d3d11_sampler_info {\n    const void* smp;      // ID3D11SamplerState*\n} sg_d3d11_sampler_info;\n\ntypedef struct sg_d3d11_shader_info {\n    const void* cbufs[SG_MAX_UNIFORMBLOCK_BINDSLOTS]; // ID3D11Buffer* (constant buffers by bind slot)\n    const void* vs;   // ID3D11VertexShader*\n    const void* fs;   // ID3D11PixelShader*\n} sg_d3d11_shader_info;\n\ntypedef struct sg_d3d11_pipeline_info {\n    const void* il;   // ID3D11InputLayout*\n    const void* rs;   // ID3D11RasterizerState*\n    const void* dss;  // ID3D11DepthStencilState*\n    const void* bs;   // ID3D11BlendState*\n} sg_d3d11_pipeline_info;\n\ntypedef struct sg_d3d11_attachments_info {\n    const void* color_rtv[SG_MAX_COLOR_ATTACHMENTS];      // ID3D11RenderTargetView\n    const void* resolve_rtv[SG_MAX_COLOR_ATTACHMENTS];    // ID3D11RenderTargetView\n    const void* dsv;  // ID3D11DepthStencilView\n} sg_d3d11_attachments_info;\n\ntypedef struct sg_mtl_buffer_info {\n    const void* buf[SG_NUM_INFLIGHT_FRAMES];  // id<MTLBuffer>\n    int active_slot;\n} sg_mtl_buffer_info;\n\ntypedef struct sg_mtl_image_info {\n    const void* tex[SG_NUM_INFLIGHT_FRAMES]; // id<MTLTexture>\n    int active_slot;\n} sg_mtl_image_info;\n\ntypedef struct sg_mtl_sampler_info {\n    const void* smp;  // id<MTLSamplerState>\n} sg_mtl_sampler_info;\n\ntypedef struct sg_mtl_shader_info {\n    const void* vertex_lib;     // id<MTLLibrary>\n    const void* fragment_lib;   // id<MTLLibrary>\n    const void* vertex_func;    // id<MTLFunction>\n    const void* fragment_func;  // id<MTLFunction>\n} sg_mtl_shader_info;\n\ntypedef struct sg_mtl_pipeline_info {\n    const void* rps;      // id<MTLRenderPipelineState>\n    const void* dss;      // id<MTLDepthStencilState>\n} sg_mtl_pipeline_info;\n\ntypedef struct sg_wgpu_buffer_info {\n    const void* buf;  // WGPUBuffer\n} sg_wgpu_buffer_info;\n\ntypedef struct sg_wgpu_image_info {\n    const void* tex;  // WGPUTexture\n    const void* view; // WGPUTextureView\n} sg_wgpu_image_info;\n\ntypedef struct sg_wgpu_sampler_info {\n    const void* smp;  // WGPUSampler\n} sg_wgpu_sampler_info;\n\ntypedef struct sg_wgpu_shader_info {\n    const void* vs_mod;   // WGPUShaderModule\n    const void* fs_mod;   // WGPUShaderModule\n    const void* bgl;      // WGPUBindGroupLayout;\n} sg_wgpu_shader_info;\n\ntypedef struct sg_wgpu_pipeline_info {\n    const void* pip;      // WGPURenderPipeline\n} sg_wgpu_pipeline_info;\n\ntypedef struct sg_wgpu_attachments_info {\n    const void* color_view[SG_MAX_COLOR_ATTACHMENTS];     // WGPUTextureView\n    const void* resolve_view[SG_MAX_COLOR_ATTACHMENTS];    // WGPUTextureView\n    const void* ds_view;  // WGPUTextureView\n} sg_wgpu_attachments_info;\n\ntypedef struct sg_gl_buffer_info {\n    uint32_t buf[SG_NUM_INFLIGHT_FRAMES];\n    int active_slot;\n} sg_gl_buffer_info;\n\ntypedef struct sg_gl_image_info {\n    uint32_t tex[SG_NUM_INFLIGHT_FRAMES];\n    uint32_t tex_target;\n    uint32_t msaa_render_buffer;\n    int active_slot;\n} sg_gl_image_info;\n\ntypedef struct sg_gl_sampler_info {\n    uint32_t smp;\n} sg_gl_sampler_info;\n\ntypedef struct sg_gl_shader_info {\n    uint32_t prog;\n} sg_gl_shader_info;\n\ntypedef struct sg_gl_attachments_info {\n    uint32_t framebuffer;\n    uint32_t msaa_resolve_framebuffer[SG_MAX_COLOR_ATTACHMENTS];\n} sg_gl_attachments_info;\n\n// D3D11: return ID3D11Device\nSOKOL_GFX_API_DECL const void* sg_d3d11_device(void);\n// D3D11: return ID3D11DeviceContext\nSOKOL_GFX_API_DECL const void* sg_d3d11_device_context(void);\n// D3D11: get internal buffer resource objects\nSOKOL_GFX_API_DECL sg_d3d11_buffer_info sg_d3d11_query_buffer_info(sg_buffer buf);\n// D3D11: get internal image resource objects\nSOKOL_GFX_API_DECL sg_d3d11_image_info sg_d3d11_query_image_info(sg_image img);\n// D3D11: get internal sampler resource objects\nSOKOL_GFX_API_DECL sg_d3d11_sampler_info sg_d3d11_query_sampler_info(sg_sampler smp);\n// D3D11: get internal shader resource objects\nSOKOL_GFX_API_DECL sg_d3d11_shader_info sg_d3d11_query_shader_info(sg_shader shd);\n// D3D11: get internal pipeline resource objects\nSOKOL_GFX_API_DECL sg_d3d11_pipeline_info sg_d3d11_query_pipeline_info(sg_pipeline pip);\n// D3D11: get internal pass resource objects\nSOKOL_GFX_API_DECL sg_d3d11_attachments_info sg_d3d11_query_attachments_info(sg_attachments atts);\n\n// Metal: return __bridge-casted MTLDevice\nSOKOL_GFX_API_DECL const void* sg_mtl_device(void);\n// Metal: return __bridge-casted MTLRenderCommandEncoder in current pass (or zero if outside pass)\nSOKOL_GFX_API_DECL const void* sg_mtl_render_command_encoder(void);\n// Metal: get internal __bridge-casted buffer resource objects\nSOKOL_GFX_API_DECL sg_mtl_buffer_info sg_mtl_query_buffer_info(sg_buffer buf);\n// Metal: get internal __bridge-casted image resource objects\nSOKOL_GFX_API_DECL sg_mtl_image_info sg_mtl_query_image_info(sg_image img);\n// Metal: get internal __bridge-casted sampler resource objects\nSOKOL_GFX_API_DECL sg_mtl_sampler_info sg_mtl_query_sampler_info(sg_sampler smp);\n// Metal: get internal __bridge-casted shader resource objects\nSOKOL_GFX_API_DECL sg_mtl_shader_info sg_mtl_query_shader_info(sg_shader shd);\n// Metal: get internal __bridge-casted pipeline resource objects\nSOKOL_GFX_API_DECL sg_mtl_pipeline_info sg_mtl_query_pipeline_info(sg_pipeline pip);\n\n// WebGPU: return WGPUDevice object\nSOKOL_GFX_API_DECL const void* sg_wgpu_device(void);\n// WebGPU: return WGPUQueue object\nSOKOL_GFX_API_DECL const void* sg_wgpu_queue(void);\n// WebGPU: return this frame's WGPUCommandEncoder\nSOKOL_GFX_API_DECL const void* sg_wgpu_command_encoder(void);\n// WebGPU: return WGPURenderPassEncoder of current pass\nSOKOL_GFX_API_DECL const void* sg_wgpu_render_pass_encoder(void);\n// WebGPU: get internal buffer resource objects\nSOKOL_GFX_API_DECL sg_wgpu_buffer_info sg_wgpu_query_buffer_info(sg_buffer buf);\n// WebGPU: get internal image resource objects\nSOKOL_GFX_API_DECL sg_wgpu_image_info sg_wgpu_query_image_info(sg_image img);\n// WebGPU: get internal sampler resource objects\nSOKOL_GFX_API_DECL sg_wgpu_sampler_info sg_wgpu_query_sampler_info(sg_sampler smp);\n// WebGPU: get internal shader resource objects\nSOKOL_GFX_API_DECL sg_wgpu_shader_info sg_wgpu_query_shader_info(sg_shader shd);\n// WebGPU: get internal pipeline resource objects\nSOKOL_GFX_API_DECL sg_wgpu_pipeline_info sg_wgpu_query_pipeline_info(sg_pipeline pip);\n// WebGPU: get internal pass resource objects\nSOKOL_GFX_API_DECL sg_wgpu_attachments_info sg_wgpu_query_attachments_info(sg_attachments atts);\n\n// GL: get internal buffer resource objects\nSOKOL_GFX_API_DECL sg_gl_buffer_info sg_gl_query_buffer_info(sg_buffer buf);\n// GL: get internal image resource objects\nSOKOL_GFX_API_DECL sg_gl_image_info sg_gl_query_image_info(sg_image img);\n// GL: get internal sampler resource objects\nSOKOL_GFX_API_DECL sg_gl_sampler_info sg_gl_query_sampler_info(sg_sampler smp);\n// GL: get internal shader resource objects\nSOKOL_GFX_API_DECL sg_gl_shader_info sg_gl_query_shader_info(sg_shader shd);\n// GL: get internal pass resource objects\nSOKOL_GFX_API_DECL sg_gl_attachments_info sg_gl_query_attachments_info(sg_attachments atts);\n\n#ifdef __cplusplus\n} // extern \"C\"\n\n// reference-based equivalents for c++\ninline void sg_setup(const sg_desc& desc) { return sg_setup(&desc); }\n\ninline sg_buffer sg_make_buffer(const sg_buffer_desc& desc) { return sg_make_buffer(&desc); }\ninline sg_image sg_make_image(const sg_image_desc& desc) { return sg_make_image(&desc); }\ninline sg_sampler sg_make_sampler(const sg_sampler_desc& desc) { return sg_make_sampler(&desc); }\ninline sg_shader sg_make_shader(const sg_shader_desc& desc) { return sg_make_shader(&desc); }\ninline sg_pipeline sg_make_pipeline(const sg_pipeline_desc& desc) { return sg_make_pipeline(&desc); }\ninline sg_attachments sg_make_attachments(const sg_attachments_desc& desc) { return sg_make_attachments(&desc); }\ninline void sg_update_image(sg_image img, const sg_image_data& data) { return sg_update_image(img, &data); }\n\ninline void sg_begin_pass(const sg_pass& pass) { return sg_begin_pass(&pass); }\ninline void sg_apply_bindings(const sg_bindings& bindings) { return sg_apply_bindings(&bindings); }\ninline void sg_apply_uniforms(int ub_slot, const sg_range& data) { return sg_apply_uniforms(ub_slot, &data); }\n\ninline sg_buffer_desc sg_query_buffer_defaults(const sg_buffer_desc& desc) { return sg_query_buffer_defaults(&desc); }\ninline sg_image_desc sg_query_image_defaults(const sg_image_desc& desc) { return sg_query_image_defaults(&desc); }\ninline sg_sampler_desc sg_query_sampler_defaults(const sg_sampler_desc& desc) { return sg_query_sampler_defaults(&desc); }\ninline sg_shader_desc sg_query_shader_defaults(const sg_shader_desc& desc) { return sg_query_shader_defaults(&desc); }\ninline sg_pipeline_desc sg_query_pipeline_defaults(const sg_pipeline_desc& desc) { return sg_query_pipeline_defaults(&desc); }\ninline sg_attachments_desc sg_query_attachments_defaults(const sg_attachments_desc& desc) { return sg_query_attachments_defaults(&desc); }\n\ninline void sg_init_buffer(sg_buffer buf, const sg_buffer_desc& desc) { return sg_init_buffer(buf, &desc); }\ninline void sg_init_image(sg_image img, const sg_image_desc& desc) { return sg_init_image(img, &desc); }\ninline void sg_init_sampler(sg_sampler smp, const sg_sampler_desc& desc) { return sg_init_sampler(smp, &desc); }\ninline void sg_init_shader(sg_shader shd, const sg_shader_desc& desc) { return sg_init_shader(shd, &desc); }\ninline void sg_init_pipeline(sg_pipeline pip, const sg_pipeline_desc& desc) { return sg_init_pipeline(pip, &desc); }\ninline void sg_init_attachments(sg_attachments atts, const sg_attachments_desc& desc) { return sg_init_attachments(atts, &desc); }\n\ninline void sg_update_buffer(sg_buffer buf_id, const sg_range& data) { return sg_update_buffer(buf_id, &data); }\ninline int sg_append_buffer(sg_buffer buf_id, const sg_range& data) { return sg_append_buffer(buf_id, &data); }\n#endif\n#endif // SOKOL_GFX_INCLUDED\n\n//                                        \n//                                                             \n//                                                  \n//                                                                   \n//                                                      \n//\n// >>implementation\n#ifdef SOKOL_GFX_IMPL\n#define SOKOL_GFX_IMPL_INCLUDED (1)\n\n#if !(defined(SOKOL_GLCORE)||defined(SOKOL_GLES3)||defined(SOKOL_D3D11)||defined(SOKOL_METAL)||defined(SOKOL_WGPU)||defined(SOKOL_DUMMY_BACKEND))\n#error \"Please select a backend with SOKOL_GLCORE, SOKOL_GLES3, SOKOL_D3D11, SOKOL_METAL, SOKOL_WGPU or SOKOL_DUMMY_BACKEND\"\n#endif\n#if defined(SOKOL_MALLOC) || defined(SOKOL_CALLOC) || defined(SOKOL_FREE)\n#error \"SOKOL_MALLOC/CALLOC/FREE macros are no longer supported, please use sg_desc.allocator to override memory allocation functions\"\n#endif\n\n#include <stdlib.h> // malloc, free, qsort\n#include <string.h> // memset\n#include <float.h> // FLT_MAX\n\n#ifndef SOKOL_API_IMPL\n    #define SOKOL_API_IMPL\n#endif\n#ifndef SOKOL_DEBUG\n    #ifndef NDEBUG\n        #define SOKOL_DEBUG\n    #endif\n#endif\n#ifndef SOKOL_ASSERT\n    #include <assert.h>\n    #define SOKOL_ASSERT(c) assert(c)\n#endif\n#ifndef SOKOL_UNREACHABLE\n    #define SOKOL_UNREACHABLE SOKOL_ASSERT(false)\n#endif\n\n#ifndef _SOKOL_PRIVATE\n    #if defined(__GNUC__) || defined(__clang__)\n        #define _SOKOL_PRIVATE __attribute__((unused)) static\n    #else\n        #define _SOKOL_PRIVATE static\n    #endif\n#endif\n\n#ifndef _SOKOL_UNUSED\n    #define _SOKOL_UNUSED(x) (void)(x)\n#endif\n\n#if defined(SOKOL_TRACE_HOOKS)\n#define _SG_TRACE_ARGS(fn, ...) if (_sg.hooks.fn) { _sg.hooks.fn(__VA_ARGS__, _sg.hooks.user_data); }\n#define _SG_TRACE_NOARGS(fn) if (_sg.hooks.fn) { _sg.hooks.fn(_sg.hooks.user_data); }\n#else\n#define _SG_TRACE_ARGS(fn, ...)\n#define _SG_TRACE_NOARGS(fn)\n#endif\n\n// default clear values\n#ifndef SG_DEFAULT_CLEAR_RED\n#define SG_DEFAULT_CLEAR_RED (0.5f)\n#endif\n#ifndef SG_DEFAULT_CLEAR_GREEN\n#define SG_DEFAULT_CLEAR_GREEN (0.5f)\n#endif\n#ifndef SG_DEFAULT_CLEAR_BLUE\n#define SG_DEFAULT_CLEAR_BLUE (0.5f)\n#endif\n#ifndef SG_DEFAULT_CLEAR_ALPHA\n#define SG_DEFAULT_CLEAR_ALPHA (1.0f)\n#endif\n#ifndef SG_DEFAULT_CLEAR_DEPTH\n#define SG_DEFAULT_CLEAR_DEPTH (1.0f)\n#endif\n#ifndef SG_DEFAULT_CLEAR_STENCIL\n#define SG_DEFAULT_CLEAR_STENCIL (0)\n#endif\n\n#ifdef _MSC_VER\n#pragma warning(push)\n#pragma warning(disable:4115)   // named type definition in parentheses\n#pragma warning(disable:4505)   // unreferenced local function has been removed\n#pragma warning(disable:4201)   // nonstandard extension used: nameless struct/union (needed by d3d11.h)\n#pragma warning(disable:4054)   // 'type cast': from function pointer\n#pragma warning(disable:4055)   // 'type cast': from data pointer\n#endif\n\n#if defined(SOKOL_D3D11)\n    #ifndef D3D11_NO_HELPERS\n    #define D3D11_NO_HELPERS\n    #endif\n    #ifndef WIN32_LEAN_AND_MEAN\n    #define WIN32_LEAN_AND_MEAN\n    #endif\n    #ifndef NOMINMAX\n    #define NOMINMAX\n    #endif\n    #include <d3d11.h>\n    #include <d3dcompiler.h>\n    #ifdef _MSC_VER\n    #pragma comment (lib, \"kernel32\")\n    #pragma comment (lib, \"user32\")\n    #pragma comment (lib, \"dxgi\")\n    #pragma comment (lib, \"d3d11\")\n    #endif\n#elif defined(SOKOL_METAL)\n    // see https://clang.llvm.org/docs/LanguageExtensions.html#automatic-reference-counting\n    #if !defined(__cplusplus)\n        #if __has_feature(objc_arc) && !__has_feature(objc_arc_fields)\n            #error \"sokol_gfx.h requires __has_feature(objc_arc_field) if ARC is enabled (use a more recent compiler version)\"\n        #endif\n    #endif\n    #include <TargetConditionals.h>\n    #include <AvailabilityMacros.h>\n    #if defined(TARGET_OS_IPHONE) && !TARGET_OS_IPHONE\n        #define _SG_TARGET_MACOS (1)\n    #else\n        #define _SG_TARGET_IOS (1)\n        #if defined(TARGET_IPHONE_SIMULATOR) && TARGET_IPHONE_SIMULATOR\n            #define _SG_TARGET_IOS_SIMULATOR (1)\n        #endif\n    #endif\n    #import <Metal/Metal.h>\n    #import <QuartzCore/CoreAnimation.h> // needed for CAMetalDrawable\n#elif defined(SOKOL_WGPU)\n    #include <webgpu/webgpu.h>\n    #if defined(__EMSCRIPTEN__)\n        #include <emscripten/emscripten.h>\n    #endif\n#elif defined(SOKOL_GLCORE) || defined(SOKOL_GLES3)\n    #define _SOKOL_ANY_GL (1)\n\n    // include platform specific GL headers (or on Win32: use an embedded GL loader)\n    #if !defined(SOKOL_EXTERNAL_GL_LOADER)\n        #if defined(_WIN32)\n            #if defined(SOKOL_GLCORE) && !defined(SOKOL_EXTERNAL_GL_LOADER)\n                #ifndef WIN32_LEAN_AND_MEAN\n                #define WIN32_LEAN_AND_MEAN\n                #endif\n                #ifndef NOMINMAX\n                #define NOMINMAX\n                #endif\n                #include <windows.h>\n                #define _SOKOL_USE_WIN32_GL_LOADER (1)\n                #pragma comment (lib, \"kernel32\")   // GetProcAddress()\n            #endif\n        #elif defined(__APPLE__)\n            #include <TargetConditionals.h>\n            #ifndef GL_SILENCE_DEPRECATION\n                #define GL_SILENCE_DEPRECATION\n            #endif\n            #if defined(TARGET_OS_IPHONE) && !TARGET_OS_IPHONE\n                #include <OpenGL/gl3.h>\n            #else\n                #include <OpenGLES/ES3/gl.h>\n                #include <OpenGLES/ES3/glext.h>\n            #endif\n        #elif defined(__EMSCRIPTEN__) || defined(__ANDROID__)\n            #if defined(SOKOL_GLES3)\n                #include <GLES3/gl3.h>\n            #endif\n        #elif defined(__linux__) || defined(__unix__)\n            #if defined(SOKOL_GLCORE)\n                #define GL_GLEXT_PROTOTYPES\n                #include <GL/gl.h>\n            #else\n                #include <GLES3/gl3.h>\n                #include <GLES3/gl3ext.h>\n            #endif\n        #endif\n    #endif\n\n    // optional GL loader definitions (only on Win32)\n    #if defined(_SOKOL_USE_WIN32_GL_LOADER)\n        #define __gl_h_ 1\n        #define __gl32_h_ 1\n        #define __gl31_h_ 1\n        #define __GL_H__ 1\n        #define __glext_h_ 1\n        #define __GLEXT_H_ 1\n        #define __gltypes_h_ 1\n        #define __glcorearb_h_ 1\n        #define __gl_glcorearb_h_ 1\n        #define GL_APIENTRY APIENTRY\n\n        typedef unsigned int  GLenum;\n        typedef unsigned int  GLuint;\n        typedef int  GLsizei;\n        typedef char  GLchar;\n        typedef ptrdiff_t  GLintptr;\n        typedef ptrdiff_t  GLsizeiptr;\n        typedef double  GLclampd;\n        typedef unsigned short  GLushort;\n        typedef unsigned char  GLubyte;\n        typedef unsigned char  GLboolean;\n        typedef uint64_t  GLuint64;\n        typedef double  GLdouble;\n        typedef unsigned short  GLhalf;\n        typedef float  GLclampf;\n        typedef unsigned int  GLbitfield;\n        typedef signed char  GLbyte;\n        typedef short  GLshort;\n        typedef void  GLvoid;\n        typedef int64_t  GLint64;\n        typedef float  GLfloat;\n        typedef int  GLint;\n        #define GL_INT_2_10_10_10_REV 0x8D9F\n        #define GL_R32F 0x822E\n        #define GL_PROGRAM_POINT_SIZE 0x8642\n        #define GL_DEPTH_ATTACHMENT 0x8D00\n        #define GL_DEPTH_STENCIL_ATTACHMENT 0x821A\n        #define GL_COLOR_ATTACHMENT2 0x8CE2\n        #define GL_COLOR_ATTACHMENT0 0x8CE0\n        #define GL_R16F 0x822D\n        #define GL_COLOR_ATTACHMENT22 0x8CF6\n        #define GL_DRAW_FRAMEBUFFER 0x8CA9\n        #define GL_FRAMEBUFFER_COMPLETE 0x8CD5\n        #define GL_NUM_EXTENSIONS 0x821D\n        #define GL_INFO_LOG_LENGTH 0x8B84\n        #define GL_VERTEX_SHADER 0x8B31\n        #define GL_INCR 0x1E02\n        #define GL_DYNAMIC_DRAW 0x88E8\n        #define GL_STATIC_DRAW 0x88E4\n        #define GL_TEXTURE_CUBE_MAP_POSITIVE_Z 0x8519\n        #define GL_TEXTURE_CUBE_MAP 0x8513\n        #define GL_FUNC_SUBTRACT 0x800A\n        #define GL_FUNC_REVERSE_SUBTRACT 0x800B\n        #define GL_CONSTANT_COLOR 0x8001\n        #define GL_DECR_WRAP 0x8508\n        #define GL_R8 0x8229\n        #define GL_LINEAR_MIPMAP_LINEAR 0x2703\n        #define GL_ELEMENT_ARRAY_BUFFER 0x8893\n        #define GL_SHORT 0x1402\n        #define GL_DEPTH_TEST 0x0B71\n        #define GL_TEXTURE_CUBE_MAP_NEGATIVE_Y 0x8518\n        #define GL_LINK_STATUS 0x8B82\n        #define GL_TEXTURE_CUBE_MAP_POSITIVE_Y 0x8517\n        #define GL_SAMPLE_ALPHA_TO_COVERAGE 0x809E\n        #define GL_RGBA16F 0x881A\n        #define GL_CONSTANT_ALPHA 0x8003\n        #define GL_READ_FRAMEBUFFER 0x8CA8\n        #define GL_TEXTURE0 0x84C0\n        #define GL_TEXTURE_MIN_LOD 0x813A\n        #define GL_CLAMP_TO_EDGE 0x812F\n        #define GL_UNSIGNED_SHORT_5_6_5 0x8363\n        #define GL_TEXTURE_WRAP_R 0x8072\n        #define GL_UNSIGNED_SHORT_5_5_5_1 0x8034\n        #define GL_NEAREST_MIPMAP_NEAREST 0x2700\n        #define GL_UNSIGNED_SHORT_4_4_4_4 0x8033\n        #define GL_SRC_ALPHA_SATURATE 0x0308\n        #define GL_STREAM_DRAW 0x88E0\n        #define GL_ONE 1\n        #define GL_NEAREST_MIPMAP_LINEAR 0x2702\n        #define GL_RGB10_A2 0x8059\n        #define GL_RGBA8 0x8058\n        #define GL_SRGB8_ALPHA8 0x8C43\n        #define GL_COLOR_ATTACHMENT1 0x8CE1\n        #define GL_RGBA4 0x8056\n        #define GL_RGB8 0x8051\n        #define GL_ARRAY_BUFFER 0x8892\n        #define GL_STENCIL 0x1802\n        #define GL_TEXTURE_2D 0x0DE1\n        #define GL_DEPTH 0x1801\n        #define GL_FRONT 0x0404\n        #define GL_STENCIL_BUFFER_BIT 0x00000400\n        #define GL_REPEAT 0x2901\n        #define GL_RGBA 0x1908\n        #define GL_TEXTURE_CUBE_MAP_POSITIVE_X 0x8515\n        #define GL_DECR 0x1E03\n        #define GL_FRAGMENT_SHADER 0x8B30\n        #define GL_FLOAT 0x1406\n        #define GL_TEXTURE_MAX_LOD 0x813B\n        #define GL_DEPTH_COMPONENT 0x1902\n        #define GL_ONE_MINUS_DST_ALPHA 0x0305\n        #define GL_COLOR 0x1800\n        #define GL_TEXTURE_2D_ARRAY 0x8C1A\n        #define GL_TRIANGLES 0x0004\n        #define GL_UNSIGNED_BYTE 0x1401\n        #define GL_TEXTURE_MAG_FILTER 0x2800\n        #define GL_ONE_MINUS_CONSTANT_ALPHA 0x8004\n        #define GL_NONE 0\n        #define GL_SRC_COLOR 0x0300\n        #define GL_BYTE 0x1400\n        #define GL_TEXTURE_CUBE_MAP_NEGATIVE_Z 0x851A\n        #define GL_LINE_STRIP 0x0003\n        #define GL_TEXTURE_3D 0x806F\n        #define GL_CW 0x0900\n        #define GL_LINEAR 0x2601\n        #define GL_RENDERBUFFER 0x8D41\n        #define GL_GEQUAL 0x0206\n        #define GL_COLOR_BUFFER_BIT 0x00004000\n        #define GL_RGBA32F 0x8814\n        #define GL_BLEND 0x0BE2\n        #define GL_ONE_MINUS_SRC_ALPHA 0x0303\n        #define GL_ONE_MINUS_CONSTANT_COLOR 0x8002\n        #define GL_TEXTURE_WRAP_T 0x2803\n        #define GL_TEXTURE_WRAP_S 0x2802\n        #define GL_TEXTURE_MIN_FILTER 0x2801\n        #define GL_LINEAR_MIPMAP_NEAREST 0x2701\n        #define GL_EXTENSIONS 0x1F03\n        #define GL_NO_ERROR 0\n        #define GL_REPLACE 0x1E01\n        #define GL_KEEP 0x1E00\n        #define GL_CCW 0x0901\n        #define GL_TEXTURE_CUBE_MAP_NEGATIVE_X 0x8516\n        #define GL_RGB 0x1907\n        #define GL_TRIANGLE_STRIP 0x0005\n        #define GL_FALSE 0\n        #define GL_ZERO 0\n        #define GL_CULL_FACE 0x0B44\n        #define GL_INVERT 0x150A\n        #define GL_INT 0x1404\n        #define GL_UNSIGNED_INT 0x1405\n        #define GL_UNSIGNED_SHORT 0x1403\n        #define GL_NEAREST 0x2600\n        #define GL_SCISSOR_TEST 0x0C11\n        #define GL_LEQUAL 0x0203\n        #define GL_STENCIL_TEST 0x0B90\n        #define GL_DITHER 0x0BD0\n        #define GL_DEPTH_COMPONENT32F 0x8CAC\n        #define GL_EQUAL 0x0202\n        #define GL_FRAMEBUFFER 0x8D40\n        #define GL_RGB5 0x8050\n        #define GL_LINES 0x0001\n        #define GL_DEPTH_BUFFER_BIT 0x00000100\n        #define GL_SRC_ALPHA 0x0302\n        #define GL_INCR_WRAP 0x8507\n        #define GL_LESS 0x0201\n        #define GL_MULTISAMPLE 0x809D\n        #define GL_FRAMEBUFFER_BINDING 0x8CA6\n        #define GL_BACK 0x0405\n        #define GL_ALWAYS 0x0207\n        #define GL_FUNC_ADD 0x8006\n        #define GL_ONE_MINUS_DST_COLOR 0x0307\n        #define GL_NOTEQUAL 0x0205\n        #define GL_DST_COLOR 0x0306\n        #define GL_COMPILE_STATUS 0x8B81\n        #define GL_RED 0x1903\n        #define GL_COLOR_ATTACHMENT3 0x8CE3\n        #define GL_DST_ALPHA 0x0304\n        #define GL_RGB5_A1 0x8057\n        #define GL_GREATER 0x0204\n        #define GL_POLYGON_OFFSET_FILL 0x8037\n        #define GL_TRUE 1\n        #define GL_NEVER 0x0200\n        #define GL_POINTS 0x0000\n        #define GL_ONE_MINUS_SRC_COLOR 0x0301\n        #define GL_MIRRORED_REPEAT 0x8370\n        #define GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS 0x8B4D\n        #define GL_R11F_G11F_B10F 0x8C3A\n        #define GL_UNSIGNED_INT_10F_11F_11F_REV 0x8C3B\n        #define GL_RGB9_E5 0x8C3D\n        #define GL_UNSIGNED_INT_5_9_9_9_REV 0x8C3E\n        #define GL_RGBA32UI 0x8D70\n        #define GL_RGB32UI 0x8D71\n        #define GL_RGBA16UI 0x8D76\n        #define GL_RGB16UI 0x8D77\n        #define GL_RGBA8UI 0x8D7C\n        #define GL_RGB8UI 0x8D7D\n        #define GL_RGBA32I 0x8D82\n        #define GL_RGB32I 0x8D83\n        #define GL_RGBA16I 0x8D88\n        #define GL_RGB16I 0x8D89\n        #define GL_RGBA8I 0x8D8E\n        #define GL_RGB8I 0x8D8F\n        #define GL_RED_INTEGER 0x8D94\n        #define GL_RG 0x8227\n        #define GL_RG_INTEGER 0x8228\n        #define GL_R8 0x8229\n        #define GL_R16 0x822A\n        #define GL_RG8 0x822B\n        #define GL_RG16 0x822C\n        #define GL_R16F 0x822D\n        #define GL_R32F 0x822E\n        #define GL_RG16F 0x822F\n        #define GL_RG32F 0x8230\n        #define GL_R8I 0x8231\n        #define GL_R8UI 0x8232\n        #define GL_R16I 0x8233\n        #define GL_R16UI 0x8234\n        #define GL_R32I 0x8235\n        #define GL_R32UI 0x8236\n        #define GL_RG8I 0x8237\n        #define GL_RG8UI 0x8238\n        #define GL_RG16I 0x8239\n        #define GL_RG16UI 0x823A\n        #define GL_RG32I 0x823B\n        #define GL_RG32UI 0x823C\n        #define GL_RGBA_INTEGER 0x8D99\n        #define GL_R8_SNORM 0x8F94\n        #define GL_RG8_SNORM 0x8F95\n        #define GL_RGB8_SNORM 0x8F96\n        #define GL_RGBA8_SNORM 0x8F97\n        #define GL_R16_SNORM 0x8F98\n        #define GL_RG16_SNORM 0x8F99\n        #define GL_RGB16_SNORM 0x8F9A\n        #define GL_RGBA16_SNORM 0x8F9B\n        #define GL_RGBA16 0x805B\n        #define GL_MAX_TEXTURE_SIZE 0x0D33\n        #define GL_MAX_CUBE_MAP_TEXTURE_SIZE 0x851C\n        #define GL_MAX_3D_TEXTURE_SIZE 0x8073\n        #define GL_MAX_ARRAY_TEXTURE_LAYERS 0x88FF\n        #define GL_MAX_VERTEX_ATTRIBS 0x8869\n        #define GL_CLAMP_TO_BORDER 0x812D\n        #define GL_TEXTURE_BORDER_COLOR 0x1004\n        #define GL_CURRENT_PROGRAM 0x8B8D\n        #define GL_MAX_VERTEX_UNIFORM_COMPONENTS  0x8B4A\n        #define GL_UNPACK_ALIGNMENT 0x0CF5\n        #define GL_FRAMEBUFFER_SRGB 0x8DB9\n        #define GL_TEXTURE_COMPARE_MODE 0x884C\n        #define GL_TEXTURE_COMPARE_FUNC 0x884D\n        #define GL_COMPARE_REF_TO_TEXTURE 0x884E\n        #define GL_TEXTURE_CUBE_MAP_SEAMLESS 0x884F\n        #define GL_TEXTURE_MAX_LEVEL 0x813D\n        #define GL_FRAMEBUFFER_UNDEFINED 0x8219\n        #define GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT 0x8CD6\n        #define GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT 0x8CD7\n        #define GL_FRAMEBUFFER_UNSUPPORTED 0x8CDD\n        #define GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE 0x8D56\n        #define GL_MAJOR_VERSION 0x821B\n        #define GL_MINOR_VERSION 0x821C\n        #define GL_TEXTURE_2D_MULTISAMPLE 0x9100\n        #define GL_TEXTURE_2D_MULTISAMPLE_ARRAY 0x9102\n    #endif\n\n    #ifndef GL_UNSIGNED_INT_2_10_10_10_REV\n    #define GL_UNSIGNED_INT_2_10_10_10_REV 0x8368\n    #endif\n    #ifndef GL_UNSIGNED_INT_24_8\n    #define GL_UNSIGNED_INT_24_8 0x84FA\n    #endif\n    #ifndef GL_TEXTURE_MAX_ANISOTROPY_EXT\n    #define GL_TEXTURE_MAX_ANISOTROPY_EXT 0x84FE\n    #endif\n    #ifndef GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT\n    #define GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT 0x84FF\n    #endif\n    #ifndef GL_COMPRESSED_RGBA_S3TC_DXT1_EXT\n    #define GL_COMPRESSED_RGBA_S3TC_DXT1_EXT 0x83F1\n    #endif\n    #ifndef GL_COMPRESSED_RGBA_S3TC_DXT3_EXT\n    #define GL_COMPRESSED_RGBA_S3TC_DXT3_EXT 0x83F2\n    #endif\n    #ifndef GL_COMPRESSED_RGBA_S3TC_DXT5_EXT\n    #define GL_COMPRESSED_RGBA_S3TC_DXT5_EXT 0x83F3\n    #endif\n    #ifndef GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT\n    #define GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT 0x8C4F\n    #endif\n    #ifndef GL_COMPRESSED_RED_RGTC1\n    #define GL_COMPRESSED_RED_RGTC1 0x8DBB\n    #endif\n    #ifndef GL_COMPRESSED_SIGNED_RED_RGTC1\n    #define GL_COMPRESSED_SIGNED_RED_RGTC1 0x8DBC\n    #endif\n    #ifndef GL_COMPRESSED_RED_GREEN_RGTC2\n    #define GL_COMPRESSED_RED_GREEN_RGTC2 0x8DBD\n    #endif\n    #ifndef GL_COMPRESSED_SIGNED_RED_GREEN_RGTC2\n    #define GL_COMPRESSED_SIGNED_RED_GREEN_RGTC2 0x8DBE\n    #endif\n    #ifndef GL_COMPRESSED_RGBA_BPTC_UNORM_ARB\n    #define GL_COMPRESSED_RGBA_BPTC_UNORM_ARB 0x8E8C\n    #endif\n    #ifndef GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM_ARB\n    #define GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM_ARB 0x8E8D\n    #endif\n    #ifndef GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT_ARB\n    #define GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT_ARB 0x8E8E\n    #endif\n    #ifndef GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_ARB\n    #define GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_ARB 0x8E8F\n    #endif\n    #ifndef GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG\n    #define GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG 0x8C01\n    #endif\n    #ifndef GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG\n    #define GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG 0x8C00\n    #endif\n    #ifndef GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG\n    #define GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG 0x8C03\n    #endif\n    #ifndef GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG\n    #define GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG 0x8C02\n    #endif\n    #ifndef GL_COMPRESSED_RGB8_ETC2\n    #define GL_COMPRESSED_RGB8_ETC2 0x9274\n    #endif\n    #ifndef GL_COMPRESSED_SRGB8_ETC2\n    #define GL_COMPRESSED_SRGB8_ETC2 0x9275\n    #endif\n    #ifndef GL_COMPRESSED_RGBA8_ETC2_EAC\n    #define GL_COMPRESSED_RGBA8_ETC2_EAC 0x9278\n    #endif\n    #ifndef GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC\n    #define GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC 0x9279\n    #endif\n    #ifndef GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2\n    #define GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 0x9276\n    #endif\n    #ifndef GL_COMPRESSED_R11_EAC\n    #define GL_COMPRESSED_R11_EAC 0x9270\n    #endif\n    #ifndef GL_COMPRESSED_SIGNED_R11_EAC\n    #define GL_COMPRESSED_SIGNED_R11_EAC 0x9271\n    #endif\n    #ifndef GL_COMPRESSED_RG11_EAC\n    #define GL_COMPRESSED_RG11_EAC 0x9272\n    #endif\n    #ifndef GL_COMPRESSED_SIGNED_RG11_EAC\n    #define GL_COMPRESSED_SIGNED_RG11_EAC 0x9273\n    #endif\n    #ifndef GL_COMPRESSED_RGBA_ASTC_4x4_KHR\n    #define GL_COMPRESSED_RGBA_ASTC_4x4_KHR 0x93B0\n    #endif\n    #ifndef GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR\n    #define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR 0x93D0\n    #endif\n    #ifndef GL_DEPTH24_STENCIL8\n    #define GL_DEPTH24_STENCIL8 0x88F0\n    #endif\n    #ifndef GL_HALF_FLOAT\n    #define GL_HALF_FLOAT 0x140B\n    #endif\n    #ifndef GL_DEPTH_STENCIL\n    #define GL_DEPTH_STENCIL 0x84F9\n    #endif\n    #ifndef GL_LUMINANCE\n    #define GL_LUMINANCE 0x1909\n    #endif\n    #ifndef _SG_GL_CHECK_ERROR\n    #define _SG_GL_CHECK_ERROR() { SOKOL_ASSERT(glGetError() == GL_NO_ERROR); }\n    #endif\n#endif\n\n#if defined(SOKOL_GLES3)\n    // on WebGL2, GL_FRAMEBUFFER_UNDEFINED technically doesn't exist (it is defined\n    // in the Emscripten headers, but may not exist in other WebGL2 shims)\n    // see: https://github.com/floooh/sokol/pull/933\n    #ifndef GL_FRAMEBUFFER_UNDEFINED\n    #define GL_FRAMEBUFFER_UNDEFINED 0x8219\n    #endif\n#endif\n\n// make some GL constants generally available to simplify compilation,\n// use of those constants will be filtered by runtime flags\n#ifndef GL_SHADER_STORAGE_BUFFER\n#define GL_SHADER_STORAGE_BUFFER 0x90D2\n#endif\n\n//             \n//                                    \n//                             \n//                                         \n//                         \n//\n// >>structs\n// resource pool slots\ntypedef struct {\n    uint32_t id;\n    sg_resource_state state;\n} _sg_slot_t;\n\n// resource pool housekeeping struct\ntypedef struct {\n    int size;\n    int queue_top;\n    uint32_t* gen_ctrs;\n    int* free_queue;\n} _sg_pool_t;\n\n_SOKOL_PRIVATE void _sg_init_pool(_sg_pool_t* pool, int num);\n_SOKOL_PRIVATE void _sg_discard_pool(_sg_pool_t* pool);\n_SOKOL_PRIVATE int _sg_pool_alloc_index(_sg_pool_t* pool);\n_SOKOL_PRIVATE void _sg_pool_free_index(_sg_pool_t* pool, int slot_index);\n_SOKOL_PRIVATE void _sg_reset_slot(_sg_slot_t* slot);\n_SOKOL_PRIVATE uint32_t _sg_slot_alloc(_sg_pool_t* pool, _sg_slot_t* slot, int slot_index);\n_SOKOL_PRIVATE int _sg_slot_index(uint32_t id);\n\n// constants\nenum {\n    _SG_STRING_SIZE = 32,\n    _SG_SLOT_SHIFT = 16,\n    _SG_SLOT_MASK = (1<<_SG_SLOT_SHIFT)-1,\n    _SG_MAX_POOL_SIZE = (1<<_SG_SLOT_SHIFT),\n    _SG_DEFAULT_BUFFER_POOL_SIZE = 128,\n    _SG_DEFAULT_IMAGE_POOL_SIZE = 128,\n    _SG_DEFAULT_SAMPLER_POOL_SIZE = 64,\n    _SG_DEFAULT_SHADER_POOL_SIZE = 32,\n    _SG_DEFAULT_PIPELINE_POOL_SIZE = 64,\n    _SG_DEFAULT_ATTACHMENTS_POOL_SIZE = 16,\n    _SG_DEFAULT_UB_SIZE = 4 * 1024 * 1024,\n    _SG_DEFAULT_MAX_COMMIT_LISTENERS = 1024,\n    _SG_DEFAULT_WGPU_BINDGROUP_CACHE_SIZE = 1024,\n};\n\n// fixed-size string\ntypedef struct {\n    char buf[_SG_STRING_SIZE];\n} _sg_str_t;\n\n// helper macros\n#define _sg_def(val, def) (((val) == 0) ? (def) : (val))\n#define _sg_def_flt(val, def) (((val) == 0.0f) ? (def) : (val))\n#define _sg_min(a,b) (((a)<(b))?(a):(b))\n#define _sg_max(a,b) (((a)>(b))?(a):(b))\n#define _sg_clamp(v,v0,v1) (((v)<(v0))?(v0):(((v)>(v1))?(v1):(v)))\n#define _sg_fequal(val,cmp,delta) ((((val)-(cmp))> -(delta))&&(((val)-(cmp))<(delta)))\n#define _sg_ispow2(val) ((val&(val-1))==0)\n#define _sg_stats_add(key,val) {if(_sg.stats_enabled){ _sg.stats.key+=val;}}\n\n_SOKOL_PRIVATE void* _sg_malloc_clear(size_t size);\n_SOKOL_PRIVATE void _sg_free(void* ptr);\n_SOKOL_PRIVATE void _sg_clear(void* ptr, size_t size);\n\ntypedef struct {\n    int size;\n    int append_pos;\n    bool append_overflow;\n    uint32_t update_frame_index;\n    uint32_t append_frame_index;\n    int num_slots;\n    int active_slot;\n    sg_buffer_type type;\n    sg_usage usage;\n} _sg_buffer_common_t;\n\n_SOKOL_PRIVATE void _sg_buffer_common_init(_sg_buffer_common_t* cmn, const sg_buffer_desc* desc) {\n    cmn->size = (int)desc->size;\n    cmn->append_pos = 0;\n    cmn->append_overflow = false;\n    cmn->update_frame_index = 0;\n    cmn->append_frame_index = 0;\n    cmn->num_slots = (desc->usage == SG_USAGE_IMMUTABLE) ? 1 : SG_NUM_INFLIGHT_FRAMES;\n    cmn->active_slot = 0;\n    cmn->type = desc->type;\n    cmn->usage = desc->usage;\n}\n\ntypedef struct {\n    uint32_t upd_frame_index;\n    int num_slots;\n    int active_slot;\n    sg_image_type type;\n    bool render_target;\n    int width;\n    int height;\n    int num_slices;\n    int num_mipmaps;\n    sg_usage usage;\n    sg_pixel_format pixel_format;\n    int sample_count;\n} _sg_image_common_t;\n\n_SOKOL_PRIVATE void _sg_image_common_init(_sg_image_common_t* cmn, const sg_image_desc* desc) {\n    cmn->upd_frame_index = 0;\n    cmn->num_slots = (desc->usage == SG_USAGE_IMMUTABLE) ? 1 : SG_NUM_INFLIGHT_FRAMES;\n    cmn->active_slot = 0;\n    cmn->type = desc->type;\n    cmn->render_target = desc->render_target;\n    cmn->width = desc->width;\n    cmn->height = desc->height;\n    cmn->num_slices = desc->num_slices;\n    cmn->num_mipmaps = desc->num_mipmaps;\n    cmn->usage = desc->usage;\n    cmn->pixel_format = desc->pixel_format;\n    cmn->sample_count = desc->sample_count;\n}\n\ntypedef struct {\n    sg_filter min_filter;\n    sg_filter mag_filter;\n    sg_filter mipmap_filter;\n    sg_wrap wrap_u;\n    sg_wrap wrap_v;\n    sg_wrap wrap_w;\n    float min_lod;\n    float max_lod;\n    sg_border_color border_color;\n    sg_compare_func compare;\n    uint32_t max_anisotropy;\n} _sg_sampler_common_t;\n\n_SOKOL_PRIVATE void _sg_sampler_common_init(_sg_sampler_common_t* cmn, const sg_sampler_desc* desc) {\n    cmn->min_filter = desc->min_filter;\n    cmn->mag_filter = desc->mag_filter;\n    cmn->mipmap_filter = desc->mipmap_filter;\n    cmn->wrap_u = desc->wrap_u;\n    cmn->wrap_v = desc->wrap_v;\n    cmn->wrap_w = desc->wrap_w;\n    cmn->min_lod = desc->min_lod;\n    cmn->max_lod = desc->max_lod;\n    cmn->border_color = desc->border_color;\n    cmn->compare = desc->compare;\n    cmn->max_anisotropy = desc->max_anisotropy;\n}\n\ntypedef struct {\n    sg_shader_stage stage;\n    uint32_t size;\n} _sg_shader_uniform_block_t;\n\ntypedef struct {\n    sg_shader_stage stage;\n    bool readonly;\n} _sg_shader_storage_buffer_t;\n\ntypedef struct {\n    sg_shader_stage stage;\n    sg_image_type image_type;\n    sg_image_sample_type sample_type;\n    bool multisampled;\n} _sg_shader_image_t;\n\ntypedef struct {\n    sg_shader_stage stage;\n    sg_sampler_type sampler_type;\n} _sg_shader_sampler_t;\n\n// combined image sampler mappings, only needed on GL\ntypedef struct {\n    sg_shader_stage stage;\n    uint8_t image_slot;\n    uint8_t sampler_slot;\n} _sg_shader_image_sampler_t;\n\ntypedef struct {\n    uint32_t required_bindings_and_uniforms;\n    _sg_shader_uniform_block_t uniform_blocks[SG_MAX_UNIFORMBLOCK_BINDSLOTS];\n    _sg_shader_storage_buffer_t storage_buffers[SG_MAX_STORAGEBUFFER_BINDSLOTS];\n    _sg_shader_image_t images[SG_MAX_IMAGE_BINDSLOTS];\n    _sg_shader_sampler_t samplers[SG_MAX_SAMPLER_BINDSLOTS];\n    _sg_shader_image_sampler_t image_samplers[SG_MAX_IMAGE_SAMPLER_PAIRS];\n} _sg_shader_common_t;\n\n_SOKOL_PRIVATE void _sg_shader_common_init(_sg_shader_common_t* cmn, const sg_shader_desc* desc) {\n    for (size_t i = 0; i < SG_MAX_UNIFORMBLOCK_BINDSLOTS; i++) {\n        const sg_shader_uniform_block* src = &desc->uniform_blocks[i];\n        _sg_shader_uniform_block_t* dst = &cmn->uniform_blocks[i];\n        if (src->stage != SG_SHADERSTAGE_NONE) {\n            cmn->required_bindings_and_uniforms |= (1 << i);\n            dst->stage = src->stage;\n            dst->size = src->size;\n        }\n    }\n    const uint32_t required_bindings_flag = (1 << SG_MAX_UNIFORMBLOCK_BINDSLOTS);\n    for (size_t i = 0; i < SG_MAX_STORAGEBUFFER_BINDSLOTS; i++) {\n        const sg_shader_storage_buffer* src = &desc->storage_buffers[i];\n        _sg_shader_storage_buffer_t* dst = &cmn->storage_buffers[i];\n        if (src->stage != SG_SHADERSTAGE_NONE) {\n            cmn->required_bindings_and_uniforms |= required_bindings_flag;\n            dst->stage = src->stage;\n            dst->readonly = src->readonly;\n        }\n    }\n    for (size_t i = 0; i < SG_MAX_IMAGE_BINDSLOTS; i++) {\n        const sg_shader_image* src = &desc->images[i];\n        _sg_shader_image_t* dst = &cmn->images[i];\n        if (src->stage != SG_SHADERSTAGE_NONE) {\n            cmn->required_bindings_and_uniforms |= required_bindings_flag;\n            dst->stage = src->stage;\n            dst->image_type = src->image_type;\n            dst->sample_type = src->sample_type;\n            dst->multisampled = src->multisampled;\n        }\n    }\n    for (size_t i = 0; i < SG_MAX_SAMPLER_BINDSLOTS; i++) {\n        const sg_shader_sampler* src = &desc->samplers[i];\n        _sg_shader_sampler_t* dst = &cmn->samplers[i];\n        if (src->stage != SG_SHADERSTAGE_NONE) {\n            cmn->required_bindings_and_uniforms |= required_bindings_flag;\n            dst->stage = src->stage;\n            dst->sampler_type = src->sampler_type;\n        }\n    }\n    for (size_t i = 0; i < SG_MAX_IMAGE_SAMPLER_PAIRS; i++) {\n        const sg_shader_image_sampler_pair* src = &desc->image_sampler_pairs[i];\n        _sg_shader_image_sampler_t* dst = &cmn->image_samplers[i];\n        if (src->stage != SG_SHADERSTAGE_NONE) {\n            dst->stage = src->stage;\n            SOKOL_ASSERT((src->image_slot >= 0) && (src->image_slot < SG_MAX_IMAGE_BINDSLOTS));\n            SOKOL_ASSERT(desc->images[src->image_slot].stage == src->stage);\n            dst->image_slot = src->image_slot;\n            SOKOL_ASSERT((src->sampler_slot >= 0) && (src->sampler_slot < SG_MAX_SAMPLER_BINDSLOTS));\n            SOKOL_ASSERT(desc->samplers[src->sampler_slot].stage == src->stage);\n            dst->sampler_slot = src->sampler_slot;\n        }\n    }\n}\n\ntypedef struct {\n    bool vertex_buffer_layout_active[SG_MAX_VERTEXBUFFER_BINDSLOTS];\n    bool use_instanced_draw;\n    uint32_t required_bindings_and_uniforms;\n    sg_shader shader_id;\n    sg_vertex_layout_state layout;\n    sg_depth_state depth;\n    sg_stencil_state stencil;\n    int color_count;\n    sg_color_target_state colors[SG_MAX_COLOR_ATTACHMENTS];\n    sg_primitive_type primitive_type;\n    sg_index_type index_type;\n    sg_cull_mode cull_mode;\n    sg_face_winding face_winding;\n    int sample_count;\n    sg_color blend_color;\n    bool alpha_to_coverage_enabled;\n} _sg_pipeline_common_t;\n\n_SOKOL_PRIVATE void _sg_pipeline_common_init(_sg_pipeline_common_t* cmn, const sg_pipeline_desc* desc) {\n    SOKOL_ASSERT((desc->color_count >= 0) && (desc->color_count <= SG_MAX_COLOR_ATTACHMENTS));\n    const uint32_t required_bindings_flag = (1 << SG_MAX_UNIFORMBLOCK_BINDSLOTS);\n    for (int i = 0; i < SG_MAX_VERTEXBUFFER_BINDSLOTS; i++) {\n        const sg_vertex_attr_state* a_state = &desc->layout.attrs[i];\n        if (a_state->format != SG_VERTEXFORMAT_INVALID) {\n            SOKOL_ASSERT(a_state->buffer_index < SG_MAX_VERTEXBUFFER_BINDSLOTS);\n            cmn->vertex_buffer_layout_active[a_state->buffer_index] = true;\n            cmn->required_bindings_and_uniforms |= required_bindings_flag;\n        }\n    }\n    cmn->use_instanced_draw = false;\n    cmn->shader_id = desc->shader;\n    cmn->layout = desc->layout;\n    cmn->depth = desc->depth;\n    cmn->stencil = desc->stencil;\n    cmn->color_count = desc->color_count;\n    for (int i = 0; i < desc->color_count; i++) {\n        cmn->colors[i] = desc->colors[i];\n    }\n    cmn->primitive_type = desc->primitive_type;\n    cmn->index_type = desc->index_type;\n    if (cmn->index_type != SG_INDEXTYPE_NONE) {\n        cmn->required_bindings_and_uniforms |= required_bindings_flag;\n    }\n    cmn->cull_mode = desc->cull_mode;\n    cmn->face_winding = desc->face_winding;\n    cmn->sample_count = desc->sample_count;\n    cmn->blend_color = desc->blend_color;\n    cmn->alpha_to_coverage_enabled = desc->alpha_to_coverage_enabled;\n}\n\ntypedef struct {\n    sg_image image_id;\n    int mip_level;\n    int slice;\n} _sg_attachment_common_t;\n\ntypedef struct {\n    int width;\n    int height;\n    int num_colors;\n    _sg_attachment_common_t colors[SG_MAX_COLOR_ATTACHMENTS];\n    _sg_attachment_common_t resolves[SG_MAX_COLOR_ATTACHMENTS];\n    _sg_attachment_common_t depth_stencil;\n} _sg_attachments_common_t;\n\n_SOKOL_PRIVATE void _sg_attachment_common_init(_sg_attachment_common_t* cmn, const sg_attachment_desc* desc) {\n    cmn->image_id = desc->image;\n    cmn->mip_level = desc->mip_level;\n    cmn->slice = desc->slice;\n}\n\n_SOKOL_PRIVATE void _sg_attachments_common_init(_sg_attachments_common_t* cmn, const sg_attachments_desc* desc, int width, int height) {\n    SOKOL_ASSERT((width > 0) && (height > 0));\n    cmn->width = width;\n    cmn->height = height;\n    for (int i = 0; i < SG_MAX_COLOR_ATTACHMENTS; i++) {\n        if (desc->colors[i].image.id != SG_INVALID_ID) {\n            cmn->num_colors++;\n            _sg_attachment_common_init(&cmn->colors[i], &desc->colors[i]);\n            _sg_attachment_common_init(&cmn->resolves[i], &desc->resolves[i]);\n        }\n    }\n    if (desc->depth_stencil.image.id != SG_INVALID_ID) {\n        _sg_attachment_common_init(&cmn->depth_stencil, &desc->depth_stencil);\n    }\n}\n\n#if defined(SOKOL_DUMMY_BACKEND)\ntypedef struct {\n    _sg_slot_t slot;\n    _sg_buffer_common_t cmn;\n} _sg_dummy_buffer_t;\ntypedef _sg_dummy_buffer_t _sg_buffer_t;\n\ntypedef struct {\n    _sg_slot_t slot;\n    _sg_image_common_t cmn;\n} _sg_dummy_image_t;\ntypedef _sg_dummy_image_t _sg_image_t;\n\ntypedef struct {\n    _sg_slot_t slot;\n    _sg_sampler_common_t cmn;\n} _sg_dummy_sampler_t;\ntypedef _sg_dummy_sampler_t _sg_sampler_t;\n\ntypedef struct {\n    _sg_slot_t slot;\n    _sg_shader_common_t cmn;\n} _sg_dummy_shader_t;\ntypedef _sg_dummy_shader_t _sg_shader_t;\n\ntypedef struct {\n    _sg_slot_t slot;\n    _sg_shader_t* shader;\n    _sg_pipeline_common_t cmn;\n} _sg_dummy_pipeline_t;\ntypedef _sg_dummy_pipeline_t _sg_pipeline_t;\n\ntypedef struct {\n    _sg_image_t* image;\n} _sg_dummy_attachment_t;\n\ntypedef struct {\n    _sg_slot_t slot;\n    _sg_attachments_common_t cmn;\n    struct {\n        _sg_dummy_attachment_t colors[SG_MAX_COLOR_ATTACHMENTS];\n        _sg_dummy_attachment_t resolves[SG_MAX_COLOR_ATTACHMENTS];\n        _sg_dummy_attachment_t depth_stencil;\n    } dmy;\n} _sg_dummy_attachments_t;\ntypedef _sg_dummy_attachments_t _sg_attachments_t;\n\n#elif defined(_SOKOL_ANY_GL)\n\ntypedef struct {\n    _sg_slot_t slot;\n    _sg_buffer_common_t cmn;\n    struct {\n        GLuint buf[SG_NUM_INFLIGHT_FRAMES];\n        bool injected;  // if true, external buffers were injected with sg_buffer_desc.gl_buffers\n    } gl;\n} _sg_gl_buffer_t;\ntypedef _sg_gl_buffer_t _sg_buffer_t;\n\ntypedef struct {\n    _sg_slot_t slot;\n    _sg_image_common_t cmn;\n    struct {\n        GLenum target;\n        GLuint msaa_render_buffer;\n        GLuint tex[SG_NUM_INFLIGHT_FRAMES];\n        bool injected;  // if true, external textures were injected with sg_image_desc.gl_textures\n    } gl;\n} _sg_gl_image_t;\ntypedef _sg_gl_image_t _sg_image_t;\n\ntypedef struct {\n    _sg_slot_t slot;\n    _sg_sampler_common_t cmn;\n    struct {\n        GLuint smp;\n        bool injected;  // true if external sampler was injects in sg_sampler_desc.gl_sampler\n    } gl;\n} _sg_gl_sampler_t;\ntypedef _sg_gl_sampler_t _sg_sampler_t;\n\ntypedef struct {\n    GLint gl_loc;\n    sg_uniform_type type;\n    uint16_t count;\n    uint16_t offset;\n} _sg_gl_uniform_t;\n\ntypedef struct {\n    int num_uniforms;\n    _sg_gl_uniform_t uniforms[SG_MAX_UNIFORMBLOCK_MEMBERS];\n} _sg_gl_uniform_block_t;\n\ntypedef struct {\n    _sg_str_t name;\n} _sg_gl_shader_attr_t;\n\ntypedef struct {\n    _sg_slot_t slot;\n    _sg_shader_common_t cmn;\n    struct {\n        GLuint prog;\n        _sg_gl_shader_attr_t attrs[SG_MAX_VERTEX_ATTRIBUTES];\n        _sg_gl_uniform_block_t uniform_blocks[SG_MAX_UNIFORMBLOCK_BINDSLOTS];\n        uint8_t sbuf_binding[SG_MAX_STORAGEBUFFER_BINDSLOTS];\n        int8_t tex_slot[SG_MAX_IMAGE_SAMPLER_PAIRS]; // GL texture unit index\n    } gl;\n} _sg_gl_shader_t;\ntypedef _sg_gl_shader_t _sg_shader_t;\n\ntypedef struct {\n    int8_t vb_index;        // -1 if attr is not enabled\n    int8_t divisor;         // -1 if not initialized\n    uint8_t stride;\n    uint8_t size;\n    uint8_t normalized;\n    int offset;\n    GLenum type;\n} _sg_gl_attr_t;\n\ntypedef struct {\n    _sg_slot_t slot;\n    _sg_pipeline_common_t cmn;\n    _sg_shader_t* shader;\n    struct {\n        _sg_gl_attr_t attrs[SG_MAX_VERTEX_ATTRIBUTES];\n        sg_depth_state depth;\n        sg_stencil_state stencil;\n        sg_primitive_type primitive_type;\n        sg_blend_state blend;\n        sg_color_mask color_write_mask[SG_MAX_COLOR_ATTACHMENTS];\n        sg_cull_mode cull_mode;\n        sg_face_winding face_winding;\n        int sample_count;\n        bool alpha_to_coverage_enabled;\n    } gl;\n} _sg_gl_pipeline_t;\ntypedef _sg_gl_pipeline_t _sg_pipeline_t;\n\ntypedef struct {\n    _sg_image_t* image;\n} _sg_gl_attachment_t;\n\ntypedef struct {\n    _sg_slot_t slot;\n    _sg_attachments_common_t cmn;\n    struct {\n        GLuint fb;\n        _sg_gl_attachment_t colors[SG_MAX_COLOR_ATTACHMENTS];\n        _sg_gl_attachment_t resolves[SG_MAX_COLOR_ATTACHMENTS];\n        _sg_gl_attachment_t depth_stencil;\n        GLuint msaa_resolve_framebuffer[SG_MAX_COLOR_ATTACHMENTS];\n    } gl;\n} _sg_gl_attachments_t;\ntypedef _sg_gl_attachments_t _sg_attachments_t;\n\ntypedef struct {\n    _sg_gl_attr_t gl_attr;\n    GLuint gl_vbuf;\n} _sg_gl_cache_attr_t;\n\ntypedef struct {\n    GLenum target;\n    GLuint texture;\n    GLuint sampler;\n} _sg_gl_cache_texture_sampler_bind_slot;\n\n#define _SG_GL_MAX_SBUF_BINDINGS (2 * SG_MAX_STORAGEBUFFER_BINDSLOTS)\n#define _SG_GL_MAX_IMG_SMP_BINDINGS (SG_MAX_IMAGE_SAMPLER_PAIRS)\ntypedef struct {\n    sg_depth_state depth;\n    sg_stencil_state stencil;\n    sg_blend_state blend;\n    sg_color_mask color_write_mask[SG_MAX_COLOR_ATTACHMENTS];\n    sg_cull_mode cull_mode;\n    sg_face_winding face_winding;\n    bool polygon_offset_enabled;\n    int sample_count;\n    sg_color blend_color;\n    bool alpha_to_coverage_enabled;\n    _sg_gl_cache_attr_t attrs[SG_MAX_VERTEX_ATTRIBUTES];\n    GLuint vertex_buffer;\n    GLuint index_buffer;\n    GLuint storage_buffer;  // general bind point\n    GLuint storage_buffers[_SG_GL_MAX_SBUF_BINDINGS];\n    GLuint stored_vertex_buffer;\n    GLuint stored_index_buffer;\n    GLuint stored_storage_buffer;\n    GLuint prog;\n    _sg_gl_cache_texture_sampler_bind_slot texture_samplers[_SG_GL_MAX_IMG_SMP_BINDINGS];\n    _sg_gl_cache_texture_sampler_bind_slot stored_texture_sampler;\n    int cur_ib_offset;\n    GLenum cur_primitive_type;\n    GLenum cur_index_type;\n    GLenum cur_active_texture;\n    _sg_pipeline_t* cur_pipeline;\n    sg_pipeline cur_pipeline_id;\n} _sg_gl_state_cache_t;\n\ntypedef struct {\n    bool valid;\n    GLuint vao;\n    _sg_gl_state_cache_t cache;\n    bool ext_anisotropic;\n    GLint max_anisotropy;\n    sg_store_action color_store_actions[SG_MAX_COLOR_ATTACHMENTS];\n    sg_store_action depth_store_action;\n    sg_store_action stencil_store_action;\n    #if _SOKOL_USE_WIN32_GL_LOADER\n    HINSTANCE opengl32_dll;\n    #endif\n} _sg_gl_backend_t;\n\n#elif defined(SOKOL_D3D11)\n\ntypedef struct {\n    _sg_slot_t slot;\n    _sg_buffer_common_t cmn;\n    struct {\n        ID3D11Buffer* buf;\n        ID3D11ShaderResourceView* srv;\n    } d3d11;\n} _sg_d3d11_buffer_t;\ntypedef _sg_d3d11_buffer_t _sg_buffer_t;\n\ntypedef struct {\n    _sg_slot_t slot;\n    _sg_image_common_t cmn;\n    struct {\n        DXGI_FORMAT format;\n        ID3D11Texture2D* tex2d;\n        ID3D11Texture3D* tex3d;\n        ID3D11Resource* res;    // either tex2d or tex3d\n        ID3D11ShaderResourceView* srv;\n    } d3d11;\n} _sg_d3d11_image_t;\ntypedef _sg_d3d11_image_t _sg_image_t;\n\ntypedef struct {\n    _sg_slot_t slot;\n    _sg_sampler_common_t cmn;\n    struct {\n        ID3D11SamplerState* smp;\n    } d3d11;\n} _sg_d3d11_sampler_t;\ntypedef _sg_d3d11_sampler_t _sg_sampler_t;\n\ntypedef struct {\n    _sg_str_t sem_name;\n    int sem_index;\n} _sg_d3d11_shader_attr_t;\n\n#define _SG_D3D11_MAX_STAGE_UB_BINDINGS (SG_MAX_UNIFORMBLOCK_BINDSLOTS)\n#define _SG_D3D11_MAX_STAGE_TEX_SBUF_BINDINGS (SG_MAX_IMAGE_BINDSLOTS + SG_MAX_STORAGEBUFFER_BINDSLOTS)\n#define _SG_D3D11_MAX_STAGE_SMP_BINDINGS (SG_MAX_SAMPLER_BINDSLOTS)\n\ntypedef struct {\n    _sg_slot_t slot;\n    _sg_shader_common_t cmn;\n    struct {\n        _sg_d3d11_shader_attr_t attrs[SG_MAX_VERTEX_ATTRIBUTES];\n        ID3D11VertexShader* vs;\n        ID3D11PixelShader* fs;\n        void* vs_blob;\n        size_t vs_blob_length;\n        uint8_t ub_register_b_n[SG_MAX_UNIFORMBLOCK_BINDSLOTS];\n        uint8_t img_register_t_n[SG_MAX_IMAGE_BINDSLOTS];\n        uint8_t smp_register_s_n[SG_MAX_SAMPLER_BINDSLOTS];\n        uint8_t sbuf_register_t_n[SG_MAX_STORAGEBUFFER_BINDSLOTS];\n        ID3D11Buffer* all_cbufs[SG_MAX_UNIFORMBLOCK_BINDSLOTS];\n        ID3D11Buffer* vs_cbufs[_SG_D3D11_MAX_STAGE_UB_BINDINGS];\n        ID3D11Buffer* fs_cbufs[_SG_D3D11_MAX_STAGE_UB_BINDINGS];\n    } d3d11;\n} _sg_d3d11_shader_t;\ntypedef _sg_d3d11_shader_t _sg_shader_t;\n\ntypedef struct {\n    _sg_slot_t slot;\n    _sg_pipeline_common_t cmn;\n    _sg_shader_t* shader;\n    struct {\n        UINT stencil_ref;\n        UINT vb_strides[SG_MAX_VERTEXBUFFER_BINDSLOTS];\n        D3D_PRIMITIVE_TOPOLOGY topology;\n        DXGI_FORMAT index_format;\n        ID3D11InputLayout* il;\n        ID3D11RasterizerState* rs;\n        ID3D11DepthStencilState* dss;\n        ID3D11BlendState* bs;\n    } d3d11;\n} _sg_d3d11_pipeline_t;\ntypedef _sg_d3d11_pipeline_t _sg_pipeline_t;\n\ntypedef struct {\n    _sg_image_t* image;\n    union {\n        ID3D11RenderTargetView* rtv;\n        ID3D11DepthStencilView* dsv;\n    } view;\n} _sg_d3d11_attachment_t;\n\ntypedef struct {\n    _sg_slot_t slot;\n    _sg_attachments_common_t cmn;\n    struct {\n        _sg_d3d11_attachment_t colors[SG_MAX_COLOR_ATTACHMENTS];\n        _sg_d3d11_attachment_t resolves[SG_MAX_COLOR_ATTACHMENTS];\n        _sg_d3d11_attachment_t depth_stencil;\n    } d3d11;\n} _sg_d3d11_attachments_t;\ntypedef _sg_d3d11_attachments_t _sg_attachments_t;\n\ntypedef struct {\n    bool valid;\n    ID3D11Device* dev;\n    ID3D11DeviceContext* ctx;\n    bool use_indexed_draw;\n    bool use_instanced_draw;\n    _sg_pipeline_t* cur_pipeline;\n    sg_pipeline cur_pipeline_id;\n    struct {\n        ID3D11RenderTargetView* render_view;\n        ID3D11RenderTargetView* resolve_view;\n    } cur_pass;\n    // on-demand loaded d3dcompiler_47.dll handles\n    HINSTANCE d3dcompiler_dll;\n    bool d3dcompiler_dll_load_failed;\n    pD3DCompile D3DCompile_func;\n    // global subresourcedata array for texture updates\n    D3D11_SUBRESOURCE_DATA subres_data[SG_MAX_MIPMAPS * SG_MAX_TEXTUREARRAY_LAYERS];\n} _sg_d3d11_backend_t;\n\n#elif defined(SOKOL_METAL)\n\n#if defined(_SG_TARGET_MACOS) || defined(_SG_TARGET_IOS_SIMULATOR)\n#define _SG_MTL_UB_ALIGN (256)\n#else\n#define _SG_MTL_UB_ALIGN (16)\n#endif\n#define _SG_MTL_INVALID_SLOT_INDEX (0)\n\ntypedef struct {\n    uint32_t frame_index;   // frame index at which it is safe to release this resource\n    int slot_index;\n} _sg_mtl_release_item_t;\n\ntypedef struct {\n    NSMutableArray* pool;\n    int num_slots;\n    int free_queue_top;\n    int* free_queue;\n    int release_queue_front;\n    int release_queue_back;\n    _sg_mtl_release_item_t* release_queue;\n} _sg_mtl_idpool_t;\n\ntypedef struct {\n    _sg_slot_t slot;\n    _sg_buffer_common_t cmn;\n    struct {\n        int buf[SG_NUM_INFLIGHT_FRAMES];  // index into _sg_mtl_pool\n    } mtl;\n} _sg_mtl_buffer_t;\ntypedef _sg_mtl_buffer_t _sg_buffer_t;\n\ntypedef struct {\n    _sg_slot_t slot;\n    _sg_image_common_t cmn;\n    struct {\n        int tex[SG_NUM_INFLIGHT_FRAMES];\n    } mtl;\n} _sg_mtl_image_t;\ntypedef _sg_mtl_image_t _sg_image_t;\n\ntypedef struct {\n    _sg_slot_t slot;\n    _sg_sampler_common_t cmn;\n    struct {\n        int sampler_state;\n    } mtl;\n} _sg_mtl_sampler_t;\ntypedef _sg_mtl_sampler_t _sg_sampler_t;\n\ntypedef struct {\n    int mtl_lib;\n    int mtl_func;\n} _sg_mtl_shader_func_t;\n\ntypedef struct {\n    _sg_slot_t slot;\n    _sg_shader_common_t cmn;\n    struct {\n        _sg_mtl_shader_func_t vertex_func;\n        _sg_mtl_shader_func_t fragment_func;\n        uint8_t ub_buffer_n[SG_MAX_UNIFORMBLOCK_BINDSLOTS];\n        uint8_t img_texture_n[SG_MAX_IMAGE_BINDSLOTS];\n        uint8_t smp_sampler_n[SG_MAX_SAMPLER_BINDSLOTS];\n        uint8_t sbuf_buffer_n[SG_MAX_STORAGEBUFFER_BINDSLOTS];\n    } mtl;\n} _sg_mtl_shader_t;\ntypedef _sg_mtl_shader_t _sg_shader_t;\n\ntypedef struct {\n    _sg_slot_t slot;\n    _sg_pipeline_common_t cmn;\n    _sg_shader_t* shader;\n    struct {\n        MTLPrimitiveType prim_type;\n        int index_size;\n        MTLIndexType index_type;\n        MTLCullMode cull_mode;\n        MTLWinding winding;\n        uint32_t stencil_ref;\n        int rps;\n        int dss;\n    } mtl;\n} _sg_mtl_pipeline_t;\ntypedef _sg_mtl_pipeline_t _sg_pipeline_t;\n\ntypedef struct {\n    _sg_image_t* image;\n} _sg_mtl_attachment_t;\n\ntypedef struct {\n    _sg_slot_t slot;\n    _sg_attachments_common_t cmn;\n    struct {\n        _sg_mtl_attachment_t colors[SG_MAX_COLOR_ATTACHMENTS];\n        _sg_mtl_attachment_t resolves[SG_MAX_COLOR_ATTACHMENTS];\n        _sg_mtl_attachment_t depth_stencil;\n    } mtl;\n} _sg_mtl_attachments_t;\ntypedef _sg_mtl_attachments_t _sg_attachments_t;\n\n// resource binding state cache\n#define _SG_MTL_MAX_STAGE_UB_BINDINGS (SG_MAX_UNIFORMBLOCK_BINDSLOTS)\n#define _SG_MTL_MAX_STAGE_UB_SBUF_BINDINGS (_SG_MTL_MAX_STAGE_UB_BINDINGS + SG_MAX_STORAGEBUFFER_BINDSLOTS)\n#define _SG_MTL_MAX_STAGE_BUFFER_BINDINGS (_SG_MTL_MAX_STAGE_UB_SBUF_BINDINGS + SG_MAX_VERTEXBUFFER_BINDSLOTS)\n#define _SG_MTL_MAX_STAGE_IMAGE_BINDINGS (SG_MAX_IMAGE_BINDSLOTS)\n#define _SG_MTL_MAX_STAGE_SAMPLER_BINDINGS (SG_MAX_SAMPLER_BINDSLOTS)\ntypedef struct {\n    const _sg_pipeline_t* cur_pipeline;\n    sg_pipeline cur_pipeline_id;\n    const _sg_buffer_t* cur_indexbuffer;\n    sg_buffer cur_indexbuffer_id;\n    int cur_indexbuffer_offset;\n    int cur_vs_buffer_offsets[_SG_MTL_MAX_STAGE_BUFFER_BINDINGS];\n    sg_buffer cur_vs_buffer_ids[_SG_MTL_MAX_STAGE_BUFFER_BINDINGS];\n    sg_buffer cur_fs_buffer_ids[_SG_MTL_MAX_STAGE_BUFFER_BINDINGS];\n    sg_image cur_vs_image_ids[_SG_MTL_MAX_STAGE_IMAGE_BINDINGS];\n    sg_image cur_fs_image_ids[_SG_MTL_MAX_STAGE_IMAGE_BINDINGS];\n    sg_sampler cur_vs_sampler_ids[_SG_MTL_MAX_STAGE_SAMPLER_BINDINGS];\n    sg_sampler cur_fs_sampler_ids[_SG_MTL_MAX_STAGE_SAMPLER_BINDINGS];\n} _sg_mtl_state_cache_t;\n\ntypedef struct {\n    bool valid;\n    bool use_shared_storage_mode;\n    uint32_t cur_frame_rotate_index;\n    int ub_size;\n    int cur_ub_offset;\n    uint8_t* cur_ub_base_ptr;\n    _sg_mtl_state_cache_t state_cache;\n    _sg_mtl_idpool_t idpool;\n    dispatch_semaphore_t sem;\n    id<MTLDevice> device;\n    id<MTLCommandQueue> cmd_queue;\n    id<MTLCommandBuffer> cmd_buffer;\n    id<MTLRenderCommandEncoder> cmd_encoder;\n    id<CAMetalDrawable> cur_drawable;\n    id<MTLBuffer> uniform_buffers[SG_NUM_INFLIGHT_FRAMES];\n} _sg_mtl_backend_t;\n\n#elif defined(SOKOL_WGPU)\n\n#define _SG_WGPU_ROWPITCH_ALIGN (256)\n#define _SG_WGPU_MAX_UNIFORM_UPDATE_SIZE (1<<16) // also see WGPULimits.maxUniformBufferBindingSize\n#define _SG_WGPU_NUM_BINDGROUPS (2) // 0: uniforms, 1: images, samplers, storage buffers\n#define _SG_WGPU_UB_BINDGROUP_INDEX (0)\n#define _SG_WGPU_IMG_SMP_SBUF_BINDGROUP_INDEX (1)\n#define _SG_WGPU_MAX_UB_BINDGROUP_ENTRIES (SG_MAX_UNIFORMBLOCK_BINDSLOTS)\n#define _SG_WGPU_MAX_UB_BINDGROUP_BIND_SLOTS (2 * SG_MAX_UNIFORMBLOCK_BINDSLOTS)\n#define _SG_WGPU_MAX_IMG_SMP_SBUF_BINDGROUP_ENTRIES (SG_MAX_IMAGE_BINDSLOTS + SG_MAX_SAMPLER_BINDSLOTS + SG_MAX_STORAGEBUFFER_BINDSLOTS)\n#define _SG_WGPU_MAX_IMG_SMP_SBUF_BIND_SLOTS (128)\n\ntypedef struct {\n    _sg_slot_t slot;\n    _sg_buffer_common_t cmn;\n    struct {\n        WGPUBuffer buf;\n    } wgpu;\n} _sg_wgpu_buffer_t;\ntypedef _sg_wgpu_buffer_t _sg_buffer_t;\n\ntypedef struct {\n    _sg_slot_t slot;\n    _sg_image_common_t cmn;\n    struct {\n        WGPUTexture tex;\n        WGPUTextureView view;\n    } wgpu;\n} _sg_wgpu_image_t;\ntypedef _sg_wgpu_image_t _sg_image_t;\n\ntypedef struct {\n    _sg_slot_t slot;\n    _sg_sampler_common_t cmn;\n    struct {\n        WGPUSampler smp;\n    } wgpu;\n} _sg_wgpu_sampler_t;\ntypedef _sg_wgpu_sampler_t _sg_sampler_t;\n\ntypedef struct {\n    WGPUShaderModule module;\n    _sg_str_t entry;\n} _sg_wgpu_shader_func_t;\n\ntypedef struct {\n    _sg_slot_t slot;\n    _sg_shader_common_t cmn;\n    struct {\n        _sg_wgpu_shader_func_t vertex_func;\n        _sg_wgpu_shader_func_t fragment_func;\n        WGPUBindGroupLayout bgl_ub;\n        WGPUBindGroup bg_ub;\n        WGPUBindGroupLayout bgl_img_smp_sbuf;\n        // a mapping of sokol-gfx bind slots to setBindGroup dynamic-offset-array indices\n        uint8_t ub_num_dynoffsets;\n        uint8_t ub_dynoffsets[SG_MAX_UNIFORMBLOCK_BINDSLOTS];\n        // indexed by sokol-gfx bind slot:\n        uint8_t ub_grp0_bnd_n[SG_MAX_UNIFORMBLOCK_BINDSLOTS];\n        uint8_t img_grp1_bnd_n[SG_MAX_IMAGE_BINDSLOTS];\n        uint8_t smp_grp1_bnd_n[SG_MAX_SAMPLER_BINDSLOTS];\n        uint8_t sbuf_grp1_bnd_n[SG_MAX_STORAGEBUFFER_BINDSLOTS];\n    } wgpu;\n} _sg_wgpu_shader_t;\ntypedef _sg_wgpu_shader_t _sg_shader_t;\n\ntypedef struct {\n    _sg_slot_t slot;\n    _sg_pipeline_common_t cmn;\n    _sg_shader_t* shader;\n    struct {\n        WGPURenderPipeline pip;\n        WGPUColor blend_color;\n    } wgpu;\n} _sg_wgpu_pipeline_t;\ntypedef _sg_wgpu_pipeline_t _sg_pipeline_t;\n\ntypedef struct {\n    _sg_image_t* image;\n    WGPUTextureView view;\n} _sg_wgpu_attachment_t;\n\ntypedef struct {\n    _sg_slot_t slot;\n    _sg_attachments_common_t cmn;\n    struct {\n        _sg_wgpu_attachment_t colors[SG_MAX_COLOR_ATTACHMENTS];\n        _sg_wgpu_attachment_t resolves[SG_MAX_COLOR_ATTACHMENTS];\n        _sg_wgpu_attachment_t depth_stencil;\n    } wgpu;\n} _sg_wgpu_attachments_t;\ntypedef _sg_wgpu_attachments_t _sg_attachments_t;\n\n// a pool of per-frame uniform buffers\ntypedef struct {\n    uint32_t num_bytes;\n    uint32_t offset;    // current offset into buf\n    uint8_t* staging;   // intermediate buffer for uniform data updates\n    WGPUBuffer buf;     // the GPU-side uniform buffer\n    uint32_t bind_offsets[SG_MAX_UNIFORMBLOCK_BINDSLOTS];   // NOTE: index is sokol-gfx ub slot index!\n} _sg_wgpu_uniform_buffer_t;\n\ntypedef struct {\n    uint32_t id;\n} _sg_wgpu_bindgroup_handle_t;\n\ntypedef enum {\n    _SG_WGPU_BINDGROUPSCACHEITEMTYPE_NONE           = 0,\n    _SG_WGPU_BINDGROUPSCACHEITEMTYPE_IMAGE          = 0x00001111,\n    _SG_WGPU_BINDGROUPSCACHEITEMTYPE_SAMPLER        = 0x00002222,\n    _SG_WGPU_BINDGROUPSCACHEITEMTYPE_STORAGEBUFFER  = 0x00003333,\n    _SG_WGPU_BINDGROUPSCACHEITEMTYPE_PIPELINE       = 0x00004444,\n} _sg_wgpu_bindgroups_cache_item_type_t;\n\n#define _SG_WGPU_BINDGROUPSCACHEKEY_NUM_ITEMS (1 + _SG_WGPU_MAX_IMG_SMP_SBUF_BINDGROUP_ENTRIES)\ntypedef struct {\n    uint64_t hash;\n    // the format of cache key items is BBBBTTTTIIIIIIII\n    // where\n    //  - BBBB is 2x the WGPU binding\n    //  - TTTT is the _sg_wgpu_bindgroups_cache_item_type_t\n    //  - IIIIIIII is the resource id\n    //\n    // where the item type is a per-resource-type bit pattern\n    uint64_t items[_SG_WGPU_BINDGROUPSCACHEKEY_NUM_ITEMS];\n} _sg_wgpu_bindgroups_cache_key_t;\n\ntypedef struct {\n    uint32_t num;           // must be 2^n\n    uint32_t index_mask;    // mask to turn hash into valid index\n    _sg_wgpu_bindgroup_handle_t* items;\n} _sg_wgpu_bindgroups_cache_t;\n\ntypedef struct {\n    _sg_slot_t slot;\n    WGPUBindGroup bindgroup;\n    _sg_wgpu_bindgroups_cache_key_t key;\n} _sg_wgpu_bindgroup_t;\n\ntypedef struct {\n    _sg_pool_t pool;\n    _sg_wgpu_bindgroup_t* bindgroups;\n} _sg_wgpu_bindgroups_pool_t;\n\ntypedef struct {\n    struct {\n        sg_buffer buffer;\n        uint64_t offset;\n    } vbs[SG_MAX_VERTEXBUFFER_BINDSLOTS];\n    struct {\n        sg_buffer buffer;\n        uint64_t offset;\n    } ib;\n    _sg_wgpu_bindgroup_handle_t bg;\n} _sg_wgpu_bindings_cache_t;\n\n// the WGPU backend state\ntypedef struct {\n    bool valid;\n    bool use_indexed_draw;\n    WGPUDevice dev;\n    WGPUSupportedLimits limits;\n    WGPUQueue queue;\n    WGPUCommandEncoder cmd_enc;\n    WGPURenderPassEncoder pass_enc;\n    WGPUBindGroup empty_bind_group;\n    const _sg_pipeline_t* cur_pipeline;\n    sg_pipeline cur_pipeline_id;\n    _sg_wgpu_uniform_buffer_t uniform;\n    _sg_wgpu_bindings_cache_t bindings_cache;\n    _sg_wgpu_bindgroups_cache_t bindgroups_cache;\n    _sg_wgpu_bindgroups_pool_t bindgroups_pool;\n} _sg_wgpu_backend_t;\n#endif\n\n// POOL STRUCTS\n\n// this *MUST* remain 0\n#define _SG_INVALID_SLOT_INDEX (0)\n\ntypedef struct {\n    _sg_pool_t buffer_pool;\n    _sg_pool_t image_pool;\n    _sg_pool_t sampler_pool;\n    _sg_pool_t shader_pool;\n    _sg_pool_t pipeline_pool;\n    _sg_pool_t attachments_pool;\n    _sg_buffer_t* buffers;\n    _sg_image_t* images;\n    _sg_sampler_t* samplers;\n    _sg_shader_t* shaders;\n    _sg_pipeline_t* pipelines;\n    _sg_attachments_t* attachments;\n} _sg_pools_t;\n\ntypedef struct {\n    int num;        // number of allocated commit listener items\n    int upper;      // the current upper index (no valid items past this point)\n    sg_commit_listener* items;\n} _sg_commit_listeners_t;\n\n// resolved resource bindings struct\ntypedef struct {\n    _sg_pipeline_t* pip;\n    int vb_offsets[SG_MAX_VERTEXBUFFER_BINDSLOTS];\n    int ib_offset;\n    _sg_buffer_t* vbs[SG_MAX_VERTEXBUFFER_BINDSLOTS];\n    _sg_buffer_t* ib;\n    _sg_image_t* imgs[SG_MAX_IMAGE_BINDSLOTS];\n    _sg_sampler_t* smps[SG_MAX_SAMPLER_BINDSLOTS];\n    _sg_buffer_t* sbufs[SG_MAX_STORAGEBUFFER_BINDSLOTS];\n} _sg_bindings_t;\n\ntypedef struct {\n    bool sample;\n    bool filter;\n    bool render;\n    bool blend;\n    bool msaa;\n    bool depth;\n} _sg_pixelformat_info_t;\n\ntypedef struct {\n    bool valid;\n    sg_desc desc;       // original desc with default values patched in\n    uint32_t frame_index;\n    struct {\n        bool valid;\n        bool in_pass;\n        sg_attachments atts_id;     // SG_INVALID_ID in a swapchain pass\n        _sg_attachments_t* atts;    // 0 in a swapchain pass\n        int width;\n        int height;\n        struct {\n            sg_pixel_format color_fmt;\n            sg_pixel_format depth_fmt;\n            int sample_count;\n        } swapchain;\n    } cur_pass;\n    sg_pipeline cur_pipeline;\n    bool next_draw_valid;\n    uint32_t required_bindings_and_uniforms;    // used to check that bindings and uniforms are applied after applying pipeline\n    uint32_t applied_bindings_and_uniforms;     // bits 0..7: uniform blocks, bit 8: bindings\n    #if defined(SOKOL_DEBUG)\n    sg_log_item validate_error;\n    #endif\n    _sg_pools_t pools;\n    sg_backend backend;\n    sg_features features;\n    sg_limits limits;\n    _sg_pixelformat_info_t formats[_SG_PIXELFORMAT_NUM];\n    bool stats_enabled;\n    sg_frame_stats stats;\n    sg_frame_stats prev_stats;\n    #if defined(_SOKOL_ANY_GL)\n    _sg_gl_backend_t gl;\n    #elif defined(SOKOL_METAL)\n    _sg_mtl_backend_t mtl;\n    #elif defined(SOKOL_D3D11)\n    _sg_d3d11_backend_t d3d11;\n    #elif defined(SOKOL_WGPU)\n    _sg_wgpu_backend_t wgpu;\n    #endif\n    #if defined(SOKOL_TRACE_HOOKS)\n    sg_trace_hooks hooks;\n    #endif\n    _sg_commit_listeners_t commit_listeners;\n} _sg_state_t;\nstatic _sg_state_t _sg;\n\n//                       \n//                               \n//                            \n//                               \n//                 \n//\n// >>logging\n#if defined(SOKOL_DEBUG)\n#define _SG_LOGITEM_XMACRO(item,msg) #item \": \" msg,\nstatic const char* _sg_log_messages[] = {\n    _SG_LOG_ITEMS\n};\n#undef _SG_LOGITEM_XMACRO\n#endif // SOKOL_DEBUG\n\n#define _SG_PANIC(code) _sg_log(SG_LOGITEM_ ##code, 0, 0, __LINE__)\n#define _SG_ERROR(code) _sg_log(SG_LOGITEM_ ##code, 1, 0, __LINE__)\n#define _SG_WARN(code) _sg_log(SG_LOGITEM_ ##code, 2, 0, __LINE__)\n#define _SG_INFO(code) _sg_log(SG_LOGITEM_ ##code, 3, 0, __LINE__)\n#define _SG_LOGMSG(code,msg) _sg_log(SG_LOGITEM_ ##code, 3, msg, __LINE__)\n#define _SG_VALIDATE(cond,code) if (!(cond)){ _sg.validate_error = SG_LOGITEM_ ##code; _sg_log(SG_LOGITEM_ ##code, 1, 0, __LINE__); }\n\nstatic void _sg_log(sg_log_item log_item, uint32_t log_level, const char* msg, uint32_t line_nr) {\n    if (_sg.desc.logger.func) {\n        const char* filename = 0;\n        #if defined(SOKOL_DEBUG)\n            filename = __FILE__;\n            if (0 == msg) {\n                msg = _sg_log_messages[log_item];\n            }\n        #endif\n        _sg.desc.logger.func(\"sg\", log_level, log_item, msg, line_nr, filename, _sg.desc.logger.user_data);\n    } else {\n        // for log level PANIC it would be 'undefined behaviour' to continue\n        if (log_level == 0) {\n            abort();\n        }\n    }\n}\n\n//                     \n//                         \n//                   \n//                             \n//                          \n//\n// >>memory\n\n// a helper macro to clear a struct with potentially ARC'ed ObjC references\n#if defined(SOKOL_METAL)\n    #if defined(__cplusplus)\n        #define _SG_CLEAR_ARC_STRUCT(type, item) { item = type(); }\n    #else\n        #define _SG_CLEAR_ARC_STRUCT(type, item) { item = (type) { 0 }; }\n    #endif\n#else\n    #define _SG_CLEAR_ARC_STRUCT(type, item) { _sg_clear(&item, sizeof(item)); }\n#endif\n\n_SOKOL_PRIVATE void _sg_clear(void* ptr, size_t size) {\n    SOKOL_ASSERT(ptr && (size > 0));\n    memset(ptr, 0, size);\n}\n\n_SOKOL_PRIVATE void* _sg_malloc(size_t size) {\n    SOKOL_ASSERT(size > 0);\n    void* ptr;\n    if (_sg.desc.allocator.alloc_fn) {\n        ptr = _sg.desc.allocator.alloc_fn(size, _sg.desc.allocator.user_data);\n    } else {\n        ptr = malloc(size);\n    }\n    if (0 == ptr) {\n        _SG_PANIC(MALLOC_FAILED);\n    }\n    return ptr;\n}\n\n_SOKOL_PRIVATE void* _sg_malloc_clear(size_t size) {\n    void* ptr = _sg_malloc(size);\n    _sg_clear(ptr, size);\n    return ptr;\n}\n\n_SOKOL_PRIVATE void _sg_free(void* ptr) {\n    if (_sg.desc.allocator.free_fn) {\n        _sg.desc.allocator.free_fn(ptr, _sg.desc.allocator.user_data);\n    } else {\n        free(ptr);\n    }\n}\n\n_SOKOL_PRIVATE bool _sg_strempty(const _sg_str_t* str) {\n    return 0 == str->buf[0];\n}\n\n_SOKOL_PRIVATE const char* _sg_strptr(const _sg_str_t* str) {\n    return &str->buf[0];\n}\n\n_SOKOL_PRIVATE void _sg_strcpy(_sg_str_t* dst, const char* src) {\n    SOKOL_ASSERT(dst);\n    if (src) {\n        #if defined(_MSC_VER)\n        strncpy_s(dst->buf, _SG_STRING_SIZE, src, (_SG_STRING_SIZE-1));\n        #else\n        strncpy(dst->buf, src, _SG_STRING_SIZE);\n        #endif\n        dst->buf[_SG_STRING_SIZE-1] = 0;\n    } else {\n        _sg_clear(dst->buf, _SG_STRING_SIZE);\n    }\n}\n\n//                 \n//                               \n//                  \n//                                      \n//                  \n//\n// >>helpers\n_SOKOL_PRIVATE uint32_t _sg_align_u32(uint32_t val, uint32_t align) {\n    SOKOL_ASSERT((align > 0) && ((align & (align - 1)) == 0));\n    return (val + (align - 1)) & ~(align - 1);\n}\n\ntypedef struct { int x, y, w, h; } _sg_recti_t;\n\n_SOKOL_PRIVATE _sg_recti_t _sg_clipi(int x, int y, int w, int h, int clip_width, int clip_height) {\n    x = _sg_min(_sg_max(0, x), clip_width-1);\n    y = _sg_min(_sg_max(0, y), clip_height-1);\n    if ((x + w) > clip_width) {\n        w = clip_width - x;\n    }\n    if ((y + h) > clip_height) {\n        h = clip_height - y;\n    }\n    w = _sg_max(w, 1);\n    h = _sg_max(h, 1);\n    const _sg_recti_t res = { x, y, w, h };\n    return res;\n}\n\n_SOKOL_PRIVATE int _sg_vertexformat_bytesize(sg_vertex_format fmt) {\n    switch (fmt) {\n        case SG_VERTEXFORMAT_FLOAT:     return 4;\n        case SG_VERTEXFORMAT_FLOAT2:    return 8;\n        case SG_VERTEXFORMAT_FLOAT3:    return 12;\n        case SG_VERTEXFORMAT_FLOAT4:    return 16;\n        case SG_VERTEXFORMAT_BYTE4:     return 4;\n        case SG_VERTEXFORMAT_BYTE4N:    return 4;\n        case SG_VERTEXFORMAT_UBYTE4:    return 4;\n        case SG_VERTEXFORMAT_UBYTE4N:   return 4;\n        case SG_VERTEXFORMAT_SHORT2:    return 4;\n        case SG_VERTEXFORMAT_SHORT2N:   return 4;\n        case SG_VERTEXFORMAT_USHORT2N:  return 4;\n        case SG_VERTEXFORMAT_SHORT4:    return 8;\n        case SG_VERTEXFORMAT_SHORT4N:   return 8;\n        case SG_VERTEXFORMAT_USHORT4N:  return 8;\n        case SG_VERTEXFORMAT_UINT10_N2: return 4;\n        case SG_VERTEXFORMAT_HALF2:     return 4;\n        case SG_VERTEXFORMAT_HALF4:     return 8;\n        case SG_VERTEXFORMAT_INVALID:   return 0;\n        default:\n            SOKOL_UNREACHABLE;\n            return -1;\n    }\n}\n\n_SOKOL_PRIVATE uint32_t _sg_uniform_alignment(sg_uniform_type type, int array_count, sg_uniform_layout ub_layout) {\n    if (ub_layout == SG_UNIFORMLAYOUT_NATIVE) {\n        return 1;\n    } else {\n        SOKOL_ASSERT(array_count > 0);\n        if (array_count == 1) {\n            switch (type) {\n                case SG_UNIFORMTYPE_FLOAT:\n                case SG_UNIFORMTYPE_INT:\n                    return 4;\n                case SG_UNIFORMTYPE_FLOAT2:\n                case SG_UNIFORMTYPE_INT2:\n                    return 8;\n                case SG_UNIFORMTYPE_FLOAT3:\n                case SG_UNIFORMTYPE_FLOAT4:\n                case SG_UNIFORMTYPE_INT3:\n                case SG_UNIFORMTYPE_INT4:\n                    return 16;\n                case SG_UNIFORMTYPE_MAT4:\n                    return 16;\n                default:\n                    SOKOL_UNREACHABLE;\n                    return 1;\n            }\n        } else {\n            return 16;\n        }\n    }\n}\n\n_SOKOL_PRIVATE uint32_t _sg_uniform_size(sg_uniform_type type, int array_count, sg_uniform_layout ub_layout) {\n    SOKOL_ASSERT(array_count > 0);\n    if (array_count == 1) {\n        switch (type) {\n            case SG_UNIFORMTYPE_FLOAT:\n            case SG_UNIFORMTYPE_INT:\n                return 4;\n            case SG_UNIFORMTYPE_FLOAT2:\n            case SG_UNIFORMTYPE_INT2:\n                return 8;\n            case SG_UNIFORMTYPE_FLOAT3:\n            case SG_UNIFORMTYPE_INT3:\n                return 12;\n            case SG_UNIFORMTYPE_FLOAT4:\n            case SG_UNIFORMTYPE_INT4:\n                return 16;\n            case SG_UNIFORMTYPE_MAT4:\n                return 64;\n            default:\n                SOKOL_UNREACHABLE;\n                return 0;\n        }\n    } else {\n        if (ub_layout == SG_UNIFORMLAYOUT_NATIVE) {\n            switch (type) {\n                case SG_UNIFORMTYPE_FLOAT:\n                case SG_UNIFORMTYPE_INT:\n                    return 4 * (uint32_t)array_count;\n                case SG_UNIFORMTYPE_FLOAT2:\n                case SG_UNIFORMTYPE_INT2:\n                    return 8 * (uint32_t)array_count;\n                case SG_UNIFORMTYPE_FLOAT3:\n                case SG_UNIFORMTYPE_INT3:\n                    return 12 * (uint32_t)array_count;\n                case SG_UNIFORMTYPE_FLOAT4:\n                case SG_UNIFORMTYPE_INT4:\n                    return 16 * (uint32_t)array_count;\n                case SG_UNIFORMTYPE_MAT4:\n                    return 64 * (uint32_t)array_count;\n                default:\n                    SOKOL_UNREACHABLE;\n                    return 0;\n            }\n        } else {\n            switch (type) {\n                case SG_UNIFORMTYPE_FLOAT:\n                case SG_UNIFORMTYPE_FLOAT2:\n                case SG_UNIFORMTYPE_FLOAT3:\n                case SG_UNIFORMTYPE_FLOAT4:\n                case SG_UNIFORMTYPE_INT:\n                case SG_UNIFORMTYPE_INT2:\n                case SG_UNIFORMTYPE_INT3:\n                case SG_UNIFORMTYPE_INT4:\n                    return 16 * (uint32_t)array_count;\n                case SG_UNIFORMTYPE_MAT4:\n                    return 64 * (uint32_t)array_count;\n                default:\n                    SOKOL_UNREACHABLE;\n                    return 0;\n            }\n        }\n    }\n}\n\n_SOKOL_PRIVATE bool _sg_is_compressed_pixel_format(sg_pixel_format fmt) {\n    switch (fmt) {\n        case SG_PIXELFORMAT_BC1_RGBA:\n        case SG_PIXELFORMAT_BC2_RGBA:\n        case SG_PIXELFORMAT_BC3_RGBA:\n        case SG_PIXELFORMAT_BC3_SRGBA:\n        case SG_PIXELFORMAT_BC4_R:\n        case SG_PIXELFORMAT_BC4_RSN:\n        case SG_PIXELFORMAT_BC5_RG:\n        case SG_PIXELFORMAT_BC5_RGSN:\n        case SG_PIXELFORMAT_BC6H_RGBF:\n        case SG_PIXELFORMAT_BC6H_RGBUF:\n        case SG_PIXELFORMAT_BC7_RGBA:\n        case SG_PIXELFORMAT_BC7_SRGBA:\n        case SG_PIXELFORMAT_PVRTC_RGB_2BPP:\n        case SG_PIXELFORMAT_PVRTC_RGB_4BPP:\n        case SG_PIXELFORMAT_PVRTC_RGBA_2BPP:\n        case SG_PIXELFORMAT_PVRTC_RGBA_4BPP:\n        case SG_PIXELFORMAT_ETC2_RGB8:\n        case SG_PIXELFORMAT_ETC2_SRGB8:\n        case SG_PIXELFORMAT_ETC2_RGB8A1:\n        case SG_PIXELFORMAT_ETC2_RGBA8:\n        case SG_PIXELFORMAT_ETC2_SRGB8A8:\n        case SG_PIXELFORMAT_EAC_R11:\n        case SG_PIXELFORMAT_EAC_R11SN:\n        case SG_PIXELFORMAT_EAC_RG11:\n        case SG_PIXELFORMAT_EAC_RG11SN:\n        case SG_PIXELFORMAT_ASTC_4x4_RGBA:\n        case SG_PIXELFORMAT_ASTC_4x4_SRGBA:\n            return true;\n        default:\n            return false;\n    }\n}\n\n_SOKOL_PRIVATE bool _sg_is_valid_rendertarget_color_format(sg_pixel_format fmt) {\n    const int fmt_index = (int) fmt;\n    SOKOL_ASSERT((fmt_index >= 0) && (fmt_index < _SG_PIXELFORMAT_NUM));\n    return _sg.formats[fmt_index].render && !_sg.formats[fmt_index].depth;\n}\n\n_SOKOL_PRIVATE bool _sg_is_valid_rendertarget_depth_format(sg_pixel_format fmt) {\n    const int fmt_index = (int) fmt;\n    SOKOL_ASSERT((fmt_index >= 0) && (fmt_index < _SG_PIXELFORMAT_NUM));\n    return _sg.formats[fmt_index].render && _sg.formats[fmt_index].depth;\n}\n\n_SOKOL_PRIVATE bool _sg_is_depth_or_depth_stencil_format(sg_pixel_format fmt) {\n    return (SG_PIXELFORMAT_DEPTH == fmt) || (SG_PIXELFORMAT_DEPTH_STENCIL == fmt);\n}\n\n_SOKOL_PRIVATE bool _sg_is_depth_stencil_format(sg_pixel_format fmt) {\n    return (SG_PIXELFORMAT_DEPTH_STENCIL == fmt);\n}\n\n_SOKOL_PRIVATE int _sg_pixelformat_bytesize(sg_pixel_format fmt) {\n    switch (fmt) {\n        case SG_PIXELFORMAT_R8:\n        case SG_PIXELFORMAT_R8SN:\n        case SG_PIXELFORMAT_R8UI:\n        case SG_PIXELFORMAT_R8SI:\n            return 1;\n        case SG_PIXELFORMAT_R16:\n        case SG_PIXELFORMAT_R16SN:\n        case SG_PIXELFORMAT_R16UI:\n        case SG_PIXELFORMAT_R16SI:\n        case SG_PIXELFORMAT_R16F:\n        case SG_PIXELFORMAT_RG8:\n        case SG_PIXELFORMAT_RG8SN:\n        case SG_PIXELFORMAT_RG8UI:\n        case SG_PIXELFORMAT_RG8SI:\n            return 2;\n        case SG_PIXELFORMAT_R32UI:\n        case SG_PIXELFORMAT_R32SI:\n        case SG_PIXELFORMAT_R32F:\n        case SG_PIXELFORMAT_RG16:\n        case SG_PIXELFORMAT_RG16SN:\n        case SG_PIXELFORMAT_RG16UI:\n        case SG_PIXELFORMAT_RG16SI:\n        case SG_PIXELFORMAT_RG16F:\n        case SG_PIXELFORMAT_RGBA8:\n        case SG_PIXELFORMAT_SRGB8A8:\n        case SG_PIXELFORMAT_RGBA8SN:\n        case SG_PIXELFORMAT_RGBA8UI:\n        case SG_PIXELFORMAT_RGBA8SI:\n        case SG_PIXELFORMAT_BGRA8:\n        case SG_PIXELFORMAT_RGB10A2:\n        case SG_PIXELFORMAT_RG11B10F:\n        case SG_PIXELFORMAT_RGB9E5:\n            return 4;\n        case SG_PIXELFORMAT_RG32UI:\n        case SG_PIXELFORMAT_RG32SI:\n        case SG_PIXELFORMAT_RG32F:\n        case SG_PIXELFORMAT_RGBA16:\n        case SG_PIXELFORMAT_RGBA16SN:\n        case SG_PIXELFORMAT_RGBA16UI:\n        case SG_PIXELFORMAT_RGBA16SI:\n        case SG_PIXELFORMAT_RGBA16F:\n            return 8;\n        case SG_PIXELFORMAT_RGBA32UI:\n        case SG_PIXELFORMAT_RGBA32SI:\n        case SG_PIXELFORMAT_RGBA32F:\n            return 16;\n        case SG_PIXELFORMAT_DEPTH:\n        case SG_PIXELFORMAT_DEPTH_STENCIL:\n            return 4;\n        default:\n            SOKOL_UNREACHABLE;\n            return 0;\n    }\n}\n\n_SOKOL_PRIVATE int _sg_roundup(int val, int round_to) {\n    return (val+(round_to-1)) & ~(round_to-1);\n}\n\n_SOKOL_PRIVATE uint32_t _sg_roundup_u32(uint32_t val, uint32_t round_to) {\n    return (val+(round_to-1)) & ~(round_to-1);\n}\n\n_SOKOL_PRIVATE uint64_t _sg_roundup_u64(uint64_t val, uint64_t round_to) {\n    return (val+(round_to-1)) & ~(round_to-1);\n}\n\n_SOKOL_PRIVATE bool _sg_multiple_u64(uint64_t val, uint64_t of) {\n    return (val & (of-1)) == 0;\n}\n\n/* return row pitch for an image\n\n    see ComputePitch in https://github.com/microsoft/DirectXTex/blob/master/DirectXTex/DirectXTexUtil.cpp\n\n    For the special PVRTC pitch computation, see:\n    GL extension requirement (https://www.khronos.org/registry/OpenGL/extensions/IMG/IMG_texture_compression_pvrtc.txt)\n\n    Quote:\n\n    6) How is the imageSize argument calculated for the CompressedTexImage2D\n       and CompressedTexSubImage2D functions.\n\n       Resolution: For PVRTC 4BPP formats the imageSize is calculated as:\n          ( max(width, 8) * max(height, 8) * 4 + 7) / 8\n       For PVRTC 2BPP formats the imageSize is calculated as:\n          ( max(width, 16) * max(height, 8) * 2 + 7) / 8\n*/\n_SOKOL_PRIVATE int _sg_row_pitch(sg_pixel_format fmt, int width, int row_align) {\n    int pitch;\n    switch (fmt) {\n        case SG_PIXELFORMAT_BC1_RGBA:\n        case SG_PIXELFORMAT_BC4_R:\n        case SG_PIXELFORMAT_BC4_RSN:\n        case SG_PIXELFORMAT_ETC2_RGB8:\n        case SG_PIXELFORMAT_ETC2_SRGB8:\n        case SG_PIXELFORMAT_ETC2_RGB8A1:\n        case SG_PIXELFORMAT_EAC_R11:\n        case SG_PIXELFORMAT_EAC_R11SN:\n            pitch = ((width + 3) / 4) * 8;\n            pitch = pitch < 8 ? 8 : pitch;\n            break;\n        case SG_PIXELFORMAT_BC2_RGBA:\n        case SG_PIXELFORMAT_BC3_RGBA:\n        case SG_PIXELFORMAT_BC3_SRGBA:\n        case SG_PIXELFORMAT_BC5_RG:\n        case SG_PIXELFORMAT_BC5_RGSN:\n        case SG_PIXELFORMAT_BC6H_RGBF:\n        case SG_PIXELFORMAT_BC6H_RGBUF:\n        case SG_PIXELFORMAT_BC7_RGBA:\n        case SG_PIXELFORMAT_BC7_SRGBA:\n        case SG_PIXELFORMAT_ETC2_RGBA8:\n        case SG_PIXELFORMAT_ETC2_SRGB8A8:\n        case SG_PIXELFORMAT_EAC_RG11:\n        case SG_PIXELFORMAT_EAC_RG11SN:\n        case SG_PIXELFORMAT_ASTC_4x4_RGBA:\n        case SG_PIXELFORMAT_ASTC_4x4_SRGBA:\n            pitch = ((width + 3) / 4) * 16;\n            pitch = pitch < 16 ? 16 : pitch;\n            break;\n        case SG_PIXELFORMAT_PVRTC_RGB_4BPP:\n        case SG_PIXELFORMAT_PVRTC_RGBA_4BPP:\n            pitch = (_sg_max(width, 8) * 4 + 7) / 8;\n            break;\n        case SG_PIXELFORMAT_PVRTC_RGB_2BPP:\n        case SG_PIXELFORMAT_PVRTC_RGBA_2BPP:\n            pitch = (_sg_max(width, 16) * 2 + 7) / 8;\n            break;\n        default:\n            pitch = width * _sg_pixelformat_bytesize(fmt);\n            break;\n    }\n    pitch = _sg_roundup(pitch, row_align);\n    return pitch;\n}\n\n// compute the number of rows in a surface depending on pixel format\n_SOKOL_PRIVATE int _sg_num_rows(sg_pixel_format fmt, int height) {\n    int num_rows;\n    switch (fmt) {\n        case SG_PIXELFORMAT_BC1_RGBA:\n        case SG_PIXELFORMAT_BC4_R:\n        case SG_PIXELFORMAT_BC4_RSN:\n        case SG_PIXELFORMAT_ETC2_RGB8:\n        case SG_PIXELFORMAT_ETC2_SRGB8:\n        case SG_PIXELFORMAT_ETC2_RGB8A1:\n        case SG_PIXELFORMAT_ETC2_RGBA8:\n        case SG_PIXELFORMAT_ETC2_SRGB8A8:\n        case SG_PIXELFORMAT_EAC_R11:\n        case SG_PIXELFORMAT_EAC_R11SN:\n        case SG_PIXELFORMAT_EAC_RG11:\n        case SG_PIXELFORMAT_EAC_RG11SN:\n        case SG_PIXELFORMAT_BC2_RGBA:\n        case SG_PIXELFORMAT_BC3_RGBA:\n        case SG_PIXELFORMAT_BC3_SRGBA:\n        case SG_PIXELFORMAT_BC5_RG:\n        case SG_PIXELFORMAT_BC5_RGSN:\n        case SG_PIXELFORMAT_BC6H_RGBF:\n        case SG_PIXELFORMAT_BC6H_RGBUF:\n        case SG_PIXELFORMAT_BC7_RGBA:\n        case SG_PIXELFORMAT_BC7_SRGBA:\n        case SG_PIXELFORMAT_ASTC_4x4_RGBA:\n        case SG_PIXELFORMAT_ASTC_4x4_SRGBA:\n            num_rows = ((height + 3) / 4);\n            break;\n        case SG_PIXELFORMAT_PVRTC_RGB_4BPP:\n        case SG_PIXELFORMAT_PVRTC_RGBA_4BPP:\n        case SG_PIXELFORMAT_PVRTC_RGB_2BPP:\n        case SG_PIXELFORMAT_PVRTC_RGBA_2BPP:\n            /* NOTE: this is most likely not correct because it ignores any\n                PVCRTC block size, but multiplied with _sg_row_pitch()\n                it gives the correct surface pitch.\n\n                See: https://www.khronos.org/registry/OpenGL/extensions/IMG/IMG_texture_compression_pvrtc.txt\n            */\n            num_rows = ((_sg_max(height, 8) + 7) / 8) * 8;\n            break;\n        default:\n            num_rows = height;\n            break;\n    }\n    if (num_rows < 1) {\n        num_rows = 1;\n    }\n    return num_rows;\n}\n\n// return size of a mipmap level\n_SOKOL_PRIVATE int _sg_miplevel_dim(int base_dim, int mip_level) {\n    return _sg_max(base_dim >> mip_level, 1);\n}\n\n/* return pitch of a 2D subimage / texture slice\n    see ComputePitch in https://github.com/microsoft/DirectXTex/blob/master/DirectXTex/DirectXTexUtil.cpp\n*/\n_SOKOL_PRIVATE int _sg_surface_pitch(sg_pixel_format fmt, int width, int height, int row_align) {\n    int num_rows = _sg_num_rows(fmt, height);\n    return num_rows * _sg_row_pitch(fmt, width, row_align);\n}\n\n// capability table pixel format helper functions\n_SOKOL_PRIVATE void _sg_pixelformat_all(_sg_pixelformat_info_t* pfi) {\n    pfi->sample = true;\n    pfi->filter = true;\n    pfi->blend = true;\n    pfi->render = true;\n    pfi->msaa = true;\n}\n\n_SOKOL_PRIVATE void _sg_pixelformat_s(_sg_pixelformat_info_t* pfi) {\n    pfi->sample = true;\n}\n\n_SOKOL_PRIVATE void _sg_pixelformat_sf(_sg_pixelformat_info_t* pfi) {\n    pfi->sample = true;\n    pfi->filter = true;\n}\n\n_SOKOL_PRIVATE void _sg_pixelformat_sr(_sg_pixelformat_info_t* pfi) {\n    pfi->sample = true;\n    pfi->render = true;\n}\n\n_SOKOL_PRIVATE void _sg_pixelformat_sfr(_sg_pixelformat_info_t* pfi) {\n    pfi->sample = true;\n    pfi->filter = true;\n    pfi->render = true;\n}\n\n_SOKOL_PRIVATE void _sg_pixelformat_srmd(_sg_pixelformat_info_t* pfi) {\n    pfi->sample = true;\n    pfi->render = true;\n    pfi->msaa = true;\n    pfi->depth = true;\n}\n\n_SOKOL_PRIVATE void _sg_pixelformat_srm(_sg_pixelformat_info_t* pfi) {\n    pfi->sample = true;\n    pfi->render = true;\n    pfi->msaa = true;\n}\n\n_SOKOL_PRIVATE void _sg_pixelformat_sfrm(_sg_pixelformat_info_t* pfi) {\n    pfi->sample = true;\n    pfi->filter = true;\n    pfi->render = true;\n    pfi->msaa = true;\n}\n_SOKOL_PRIVATE void _sg_pixelformat_sbrm(_sg_pixelformat_info_t* pfi) {\n    pfi->sample = true;\n    pfi->blend = true;\n    pfi->render = true;\n    pfi->msaa = true;\n}\n\n_SOKOL_PRIVATE void _sg_pixelformat_sbr(_sg_pixelformat_info_t* pfi) {\n    pfi->sample = true;\n    pfi->blend = true;\n    pfi->render = true;\n}\n\n_SOKOL_PRIVATE void _sg_pixelformat_sfbr(_sg_pixelformat_info_t* pfi) {\n    pfi->sample = true;\n    pfi->filter = true;\n    pfi->blend = true;\n    pfi->render = true;\n}\n\n_SOKOL_PRIVATE sg_pass_action _sg_pass_action_defaults(const sg_pass_action* action) {\n    SOKOL_ASSERT(action);\n    sg_pass_action res = *action;\n    for (int i = 0; i < SG_MAX_COLOR_ATTACHMENTS; i++) {\n        if (res.colors[i].load_action == _SG_LOADACTION_DEFAULT) {\n            res.colors[i].load_action = SG_LOADACTION_CLEAR;\n            res.colors[i].clear_value.r = SG_DEFAULT_CLEAR_RED;\n            res.colors[i].clear_value.g = SG_DEFAULT_CLEAR_GREEN;\n            res.colors[i].clear_value.b = SG_DEFAULT_CLEAR_BLUE;\n            res.colors[i].clear_value.a = SG_DEFAULT_CLEAR_ALPHA;\n        }\n        if (res.colors[i].store_action == _SG_STOREACTION_DEFAULT) {\n            res.colors[i].store_action = SG_STOREACTION_STORE;\n        }\n    }\n    if (res.depth.load_action == _SG_LOADACTION_DEFAULT) {\n        res.depth.load_action = SG_LOADACTION_CLEAR;\n        res.depth.clear_value = SG_DEFAULT_CLEAR_DEPTH;\n    }\n    if (res.depth.store_action == _SG_STOREACTION_DEFAULT) {\n        res.depth.store_action = SG_STOREACTION_DONTCARE;\n    }\n    if (res.stencil.load_action == _SG_LOADACTION_DEFAULT) {\n        res.stencil.load_action = SG_LOADACTION_CLEAR;\n        res.stencil.clear_value = SG_DEFAULT_CLEAR_STENCIL;\n    }\n    if (res.stencil.store_action == _SG_STOREACTION_DEFAULT) {\n        res.stencil.store_action = SG_STOREACTION_DONTCARE;\n    }\n    return res;\n}\n\n//                                            \n//                                                        \n//                                               \n//                                                              \n//                                                \n//\n// >>dummy backend\n#if defined(SOKOL_DUMMY_BACKEND)\n\n_SOKOL_PRIVATE void _sg_dummy_setup_backend(const sg_desc* desc) {\n    SOKOL_ASSERT(desc);\n    _SOKOL_UNUSED(desc);\n    _sg.backend = SG_BACKEND_DUMMY;\n    for (int i = SG_PIXELFORMAT_R8; i < SG_PIXELFORMAT_BC1_RGBA; i++) {\n        _sg.formats[i].sample = true;\n        _sg.formats[i].filter = true;\n        _sg.formats[i].render = true;\n        _sg.formats[i].blend = true;\n        _sg.formats[i].msaa = true;\n    }\n    _sg.formats[SG_PIXELFORMAT_DEPTH].depth = true;\n    _sg.formats[SG_PIXELFORMAT_DEPTH_STENCIL].depth = true;\n}\n\n_SOKOL_PRIVATE void _sg_dummy_discard_backend(void) {\n    // empty\n}\n\n_SOKOL_PRIVATE void _sg_dummy_reset_state_cache(void) {\n    // empty\n}\n\n_SOKOL_PRIVATE sg_resource_state _sg_dummy_create_buffer(_sg_buffer_t* buf, const sg_buffer_desc* desc) {\n    SOKOL_ASSERT(buf && desc);\n    _SOKOL_UNUSED(buf);\n    _SOKOL_UNUSED(desc);\n    return SG_RESOURCESTATE_VALID;\n}\n\n_SOKOL_PRIVATE void _sg_dummy_discard_buffer(_sg_buffer_t* buf) {\n    SOKOL_ASSERT(buf);\n    _SOKOL_UNUSED(buf);\n}\n\n_SOKOL_PRIVATE sg_resource_state _sg_dummy_create_image(_sg_image_t* img, const sg_image_desc* desc) {\n    SOKOL_ASSERT(img && desc);\n    _SOKOL_UNUSED(img);\n    _SOKOL_UNUSED(desc);\n    return SG_RESOURCESTATE_VALID;\n}\n\n_SOKOL_PRIVATE void _sg_dummy_discard_image(_sg_image_t* img) {\n    SOKOL_ASSERT(img);\n    _SOKOL_UNUSED(img);\n}\n\n_SOKOL_PRIVATE sg_resource_state _sg_dummy_create_sampler(_sg_sampler_t* smp, const sg_sampler_desc* desc) {\n    SOKOL_ASSERT(smp && desc);\n    _SOKOL_UNUSED(smp);\n    _SOKOL_UNUSED(desc);\n    return SG_RESOURCESTATE_VALID;\n}\n\n_SOKOL_PRIVATE void _sg_dummy_discard_sampler(_sg_sampler_t* smp) {\n    SOKOL_ASSERT(smp);\n    _SOKOL_UNUSED(smp);\n}\n\n_SOKOL_PRIVATE sg_resource_state _sg_dummy_create_shader(_sg_shader_t* shd, const sg_shader_desc* desc) {\n    SOKOL_ASSERT(shd && desc);\n    _SOKOL_UNUSED(shd);\n    _SOKOL_UNUSED(desc);\n    return SG_RESOURCESTATE_VALID;\n}\n\n_SOKOL_PRIVATE void _sg_dummy_discard_shader(_sg_shader_t* shd) {\n    SOKOL_ASSERT(shd);\n    _SOKOL_UNUSED(shd);\n}\n\n_SOKOL_PRIVATE sg_resource_state _sg_dummy_create_pipeline(_sg_pipeline_t* pip, _sg_shader_t* shd, const sg_pipeline_desc* desc) {\n    SOKOL_ASSERT(pip && desc);\n    _SOKOL_UNUSED(desc);\n    pip->shader = shd;\n    return SG_RESOURCESTATE_VALID;\n}\n\n_SOKOL_PRIVATE void _sg_dummy_discard_pipeline(_sg_pipeline_t* pip) {\n    SOKOL_ASSERT(pip);\n    _SOKOL_UNUSED(pip);\n}\n\n_SOKOL_PRIVATE sg_resource_state _sg_dummy_create_attachments(_sg_attachments_t* atts, _sg_image_t** color_images, _sg_image_t** resolve_images, _sg_image_t* ds_img, const sg_attachments_desc* desc) {\n    SOKOL_ASSERT(atts && desc);\n    SOKOL_ASSERT(color_images && resolve_images);\n\n    for (int i = 0; i < atts->cmn.num_colors; i++) {\n        const sg_attachment_desc* color_desc = &desc->colors[i];\n        _SOKOL_UNUSED(color_desc);\n        SOKOL_ASSERT(color_desc->image.id != SG_INVALID_ID);\n        SOKOL_ASSERT(0 == atts->dmy.colors[i].image);\n        SOKOL_ASSERT(color_images[i] && (color_images[i]->slot.id == color_desc->image.id));\n        SOKOL_ASSERT(_sg_is_valid_rendertarget_color_format(color_images[i]->cmn.pixel_format));\n        atts->dmy.colors[i].image = color_images[i];\n\n        const sg_attachment_desc* resolve_desc = &desc->resolves[i];\n        if (resolve_desc->image.id != SG_INVALID_ID) {\n            SOKOL_ASSERT(0 == atts->dmy.resolves[i].image);\n            SOKOL_ASSERT(resolve_images[i] && (resolve_images[i]->slot.id == resolve_desc->image.id));\n            SOKOL_ASSERT(color_images[i] && (color_images[i]->cmn.pixel_format == resolve_images[i]->cmn.pixel_format));\n            atts->dmy.resolves[i].image = resolve_images[i];\n        }\n    }\n\n    SOKOL_ASSERT(0 == atts->dmy.depth_stencil.image);\n    const sg_attachment_desc* ds_desc = &desc->depth_stencil;\n    if (ds_desc->image.id != SG_INVALID_ID) {\n        SOKOL_ASSERT(ds_img && (ds_img->slot.id == ds_desc->image.id));\n        SOKOL_ASSERT(_sg_is_valid_rendertarget_depth_format(ds_img->cmn.pixel_format));\n        atts->dmy.depth_stencil.image = ds_img;\n    }\n    return SG_RESOURCESTATE_VALID;\n}\n\n_SOKOL_PRIVATE void _sg_dummy_discard_attachments(_sg_attachments_t* atts) {\n    SOKOL_ASSERT(atts);\n    _SOKOL_UNUSED(atts);\n}\n\n_SOKOL_PRIVATE _sg_image_t* _sg_dummy_attachments_color_image(const _sg_attachments_t* atts, int index) {\n    SOKOL_ASSERT(atts && (index >= 0) && (index < SG_MAX_COLOR_ATTACHMENTS));\n    return atts->dmy.colors[index].image;\n}\n\n_SOKOL_PRIVATE _sg_image_t* _sg_dummy_attachments_resolve_image(const _sg_attachments_t* atts, int index) {\n    SOKOL_ASSERT(atts && (index >= 0) && (index < SG_MAX_COLOR_ATTACHMENTS));\n    return atts->dmy.resolves[index].image;\n}\n\n_SOKOL_PRIVATE _sg_image_t* _sg_dummy_attachments_ds_image(const _sg_attachments_t* atts) {\n    SOKOL_ASSERT(atts);\n    return atts->dmy.depth_stencil.image;\n}\n\n_SOKOL_PRIVATE void _sg_dummy_begin_pass(const sg_pass* pass) {\n    SOKOL_ASSERT(pass);\n    _SOKOL_UNUSED(pass);\n}\n\n_SOKOL_PRIVATE void _sg_dummy_end_pass(void) {\n    // empty\n}\n\n_SOKOL_PRIVATE void _sg_dummy_commit(void) {\n    // empty\n}\n\n_SOKOL_PRIVATE void _sg_dummy_apply_viewport(int x, int y, int w, int h, bool origin_top_left) {\n    _SOKOL_UNUSED(x);\n    _SOKOL_UNUSED(y);\n    _SOKOL_UNUSED(w);\n    _SOKOL_UNUSED(h);\n    _SOKOL_UNUSED(origin_top_left);\n}\n\n_SOKOL_PRIVATE void _sg_dummy_apply_scissor_rect(int x, int y, int w, int h, bool origin_top_left) {\n    _SOKOL_UNUSED(x);\n    _SOKOL_UNUSED(y);\n    _SOKOL_UNUSED(w);\n    _SOKOL_UNUSED(h);\n    _SOKOL_UNUSED(origin_top_left);\n}\n\n_SOKOL_PRIVATE void _sg_dummy_apply_pipeline(_sg_pipeline_t* pip) {\n    SOKOL_ASSERT(pip);\n    _SOKOL_UNUSED(pip);\n}\n\n_SOKOL_PRIVATE bool _sg_dummy_apply_bindings(_sg_bindings_t* bnd) {\n    SOKOL_ASSERT(bnd);\n    SOKOL_ASSERT(bnd->pip);\n    _SOKOL_UNUSED(bnd);\n    return true;\n}\n\n_SOKOL_PRIVATE void _sg_dummy_apply_uniforms(int ub_slot, const sg_range* data) {\n    _SOKOL_UNUSED(ub_slot);\n    _SOKOL_UNUSED(data);\n}\n\n_SOKOL_PRIVATE void _sg_dummy_draw(int base_element, int num_elements, int num_instances) {\n    _SOKOL_UNUSED(base_element);\n    _SOKOL_UNUSED(num_elements);\n    _SOKOL_UNUSED(num_instances);\n}\n\n_SOKOL_PRIVATE void _sg_dummy_update_buffer(_sg_buffer_t* buf, const sg_range* data) {\n    SOKOL_ASSERT(buf && data && data->ptr && (data->size > 0));\n    _SOKOL_UNUSED(data);\n    if (++buf->cmn.active_slot >= buf->cmn.num_slots) {\n        buf->cmn.active_slot = 0;\n    }\n}\n\n_SOKOL_PRIVATE bool _sg_dummy_append_buffer(_sg_buffer_t* buf, const sg_range* data, bool new_frame) {\n    SOKOL_ASSERT(buf && data && data->ptr && (data->size > 0));\n    _SOKOL_UNUSED(data);\n    if (new_frame) {\n        if (++buf->cmn.active_slot >= buf->cmn.num_slots) {\n            buf->cmn.active_slot = 0;\n        }\n    }\n    return true;\n}\n\n_SOKOL_PRIVATE void _sg_dummy_update_image(_sg_image_t* img, const sg_image_data* data) {\n    SOKOL_ASSERT(img && data);\n    _SOKOL_UNUSED(data);\n    if (++img->cmn.active_slot >= img->cmn.num_slots) {\n        img->cmn.active_slot = 0;\n    }\n}\n\n//                                          \n//                                                                    \n//                                                   \n//                                                                    \n//                                        \n//\n// >>opengl backend\n#elif defined(_SOKOL_ANY_GL)\n\n// optional GL loader for win32\n#if defined(_SOKOL_USE_WIN32_GL_LOADER)\n\n#ifndef SG_GL_FUNCS_EXT\n#define SG_GL_FUNCS_EXT\n#endif\n\n// X Macro list of GL function names and signatures\n#define _SG_GL_FUNCS \\\n    SG_GL_FUNCS_EXT \\\n    _SG_XMACRO(glBindVertexArray,                 void, (GLuint array)) \\\n    _SG_XMACRO(glFramebufferTextureLayer,         void, (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer)) \\\n    _SG_XMACRO(glGenFramebuffers,                 void, (GLsizei n, GLuint * framebuffers)) \\\n    _SG_XMACRO(glBindFramebuffer,                 void, (GLenum target, GLuint framebuffer)) \\\n    _SG_XMACRO(glBindRenderbuffer,                void, (GLenum target, GLuint renderbuffer)) \\\n    _SG_XMACRO(glGetStringi,                      const GLubyte *, (GLenum name, GLuint index)) \\\n    _SG_XMACRO(glClearBufferfi,                   void, (GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil)) \\\n    _SG_XMACRO(glClearBufferfv,                   void, (GLenum buffer, GLint drawbuffer, const GLfloat * value)) \\\n    _SG_XMACRO(glClearBufferuiv,                  void, (GLenum buffer, GLint drawbuffer, const GLuint * value)) \\\n    _SG_XMACRO(glClearBufferiv,                   void, (GLenum buffer, GLint drawbuffer, const GLint * value)) \\\n    _SG_XMACRO(glDeleteRenderbuffers,             void, (GLsizei n, const GLuint * renderbuffers)) \\\n    _SG_XMACRO(glUniform1fv,                      void, (GLint location, GLsizei count, const GLfloat * value)) \\\n    _SG_XMACRO(glUniform2fv,                      void, (GLint location, GLsizei count, const GLfloat * value)) \\\n    _SG_XMACRO(glUniform3fv,                      void, (GLint location, GLsizei count, const GLfloat * value)) \\\n    _SG_XMACRO(glUniform4fv,                      void, (GLint location, GLsizei count, const GLfloat * value)) \\\n    _SG_XMACRO(glUniform1iv,                      void, (GLint location, GLsizei count, const GLint * value)) \\\n    _SG_XMACRO(glUniform2iv,                      void, (GLint location, GLsizei count, const GLint * value)) \\\n    _SG_XMACRO(glUniform3iv,                      void, (GLint location, GLsizei count, const GLint * value)) \\\n    _SG_XMACRO(glUniform4iv,                      void, (GLint location, GLsizei count, const GLint * value)) \\\n    _SG_XMACRO(glUniformMatrix4fv,                void, (GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)) \\\n    _SG_XMACRO(glUseProgram,                      void, (GLuint program)) \\\n    _SG_XMACRO(glShaderSource,                    void, (GLuint shader, GLsizei count, const GLchar *const* string, const GLint * length)) \\\n    _SG_XMACRO(glLinkProgram,                     void, (GLuint program)) \\\n    _SG_XMACRO(glGetUniformLocation,              GLint, (GLuint program, const GLchar * name)) \\\n    _SG_XMACRO(glGetShaderiv,                     void, (GLuint shader, GLenum pname, GLint * params)) \\\n    _SG_XMACRO(glGetProgramInfoLog,               void, (GLuint program, GLsizei bufSize, GLsizei * length, GLchar * infoLog)) \\\n    _SG_XMACRO(glGetAttribLocation,               GLint, (GLuint program, const GLchar * name)) \\\n    _SG_XMACRO(glDisableVertexAttribArray,        void, (GLuint index)) \\\n    _SG_XMACRO(glDeleteShader,                    void, (GLuint shader)) \\\n    _SG_XMACRO(glDeleteProgram,                   void, (GLuint program)) \\\n    _SG_XMACRO(glCompileShader,                   void, (GLuint shader)) \\\n    _SG_XMACRO(glStencilFuncSeparate,             void, (GLenum face, GLenum func, GLint ref, GLuint mask)) \\\n    _SG_XMACRO(glStencilOpSeparate,               void, (GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass)) \\\n    _SG_XMACRO(glRenderbufferStorageMultisample,  void, (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)) \\\n    _SG_XMACRO(glDrawBuffers,                     void, (GLsizei n, const GLenum * bufs)) \\\n    _SG_XMACRO(glVertexAttribDivisor,             void, (GLuint index, GLuint divisor)) \\\n    _SG_XMACRO(glBufferSubData,                   void, (GLenum target, GLintptr offset, GLsizeiptr size, const void * data)) \\\n    _SG_XMACRO(glGenBuffers,                      void, (GLsizei n, GLuint * buffers)) \\\n    _SG_XMACRO(glCheckFramebufferStatus,          GLenum, (GLenum target)) \\\n    _SG_XMACRO(glFramebufferRenderbuffer,         void, (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)) \\\n    _SG_XMACRO(glCompressedTexImage2D,            void, (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void * data)) \\\n    _SG_XMACRO(glCompressedTexImage3D,            void, (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void * data)) \\\n    _SG_XMACRO(glActiveTexture,                   void, (GLenum texture)) \\\n    _SG_XMACRO(glTexSubImage3D,                   void, (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * pixels)) \\\n    _SG_XMACRO(glRenderbufferStorage,             void, (GLenum target, GLenum internalformat, GLsizei width, GLsizei height)) \\\n    _SG_XMACRO(glGenTextures,                     void, (GLsizei n, GLuint * textures)) \\\n    _SG_XMACRO(glPolygonOffset,                   void, (GLfloat factor, GLfloat units)) \\\n    _SG_XMACRO(glDrawElements,                    void, (GLenum mode, GLsizei count, GLenum type, const void * indices)) \\\n    _SG_XMACRO(glDeleteFramebuffers,              void, (GLsizei n, const GLuint * framebuffers)) \\\n    _SG_XMACRO(glBlendEquationSeparate,           void, (GLenum modeRGB, GLenum modeAlpha)) \\\n    _SG_XMACRO(glDeleteTextures,                  void, (GLsizei n, const GLuint * textures)) \\\n    _SG_XMACRO(glGetProgramiv,                    void, (GLuint program, GLenum pname, GLint * params)) \\\n    _SG_XMACRO(glBindTexture,                     void, (GLenum target, GLuint texture)) \\\n    _SG_XMACRO(glTexImage3D,                      void, (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void * pixels)) \\\n    _SG_XMACRO(glCreateShader,                    GLuint, (GLenum type)) \\\n    _SG_XMACRO(glTexSubImage2D,                   void, (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * pixels)) \\\n    _SG_XMACRO(glFramebufferTexture2D,            void, (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)) \\\n    _SG_XMACRO(glCreateProgram,                   GLuint, (void)) \\\n    _SG_XMACRO(glViewport,                        void, (GLint x, GLint y, GLsizei width, GLsizei height)) \\\n    _SG_XMACRO(glDeleteBuffers,                   void, (GLsizei n, const GLuint * buffers)) \\\n    _SG_XMACRO(glDrawArrays,                      void, (GLenum mode, GLint first, GLsizei count)) \\\n    _SG_XMACRO(glDrawElementsInstanced,           void, (GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei instancecount)) \\\n    _SG_XMACRO(glVertexAttribPointer,             void, (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void * pointer)) \\\n    _SG_XMACRO(glUniform1i,                       void, (GLint location, GLint v0)) \\\n    _SG_XMACRO(glDisable,                         void, (GLenum cap)) \\\n    _SG_XMACRO(glColorMask,                       void, (GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)) \\\n    _SG_XMACRO(glColorMaski,                      void, (GLuint buf, GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)) \\\n    _SG_XMACRO(glBindBuffer,                      void, (GLenum target, GLuint buffer)) \\\n    _SG_XMACRO(glDeleteVertexArrays,              void, (GLsizei n, const GLuint * arrays)) \\\n    _SG_XMACRO(glDepthMask,                       void, (GLboolean flag)) \\\n    _SG_XMACRO(glDrawArraysInstanced,             void, (GLenum mode, GLint first, GLsizei count, GLsizei instancecount)) \\\n    _SG_XMACRO(glScissor,                         void, (GLint x, GLint y, GLsizei width, GLsizei height)) \\\n    _SG_XMACRO(glGenRenderbuffers,                void, (GLsizei n, GLuint * renderbuffers)) \\\n    _SG_XMACRO(glBufferData,                      void, (GLenum target, GLsizeiptr size, const void * data, GLenum usage)) \\\n    _SG_XMACRO(glBlendFuncSeparate,               void, (GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha)) \\\n    _SG_XMACRO(glTexParameteri,                   void, (GLenum target, GLenum pname, GLint param)) \\\n    _SG_XMACRO(glGetIntegerv,                     void, (GLenum pname, GLint * data)) \\\n    _SG_XMACRO(glEnable,                          void, (GLenum cap)) \\\n    _SG_XMACRO(glBlitFramebuffer,                 void, (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)) \\\n    _SG_XMACRO(glStencilMask,                     void, (GLuint mask)) \\\n    _SG_XMACRO(glAttachShader,                    void, (GLuint program, GLuint shader)) \\\n    _SG_XMACRO(glGetError,                        GLenum, (void)) \\\n    _SG_XMACRO(glBlendColor,                      void, (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)) \\\n    _SG_XMACRO(glTexParameterf,                   void, (GLenum target, GLenum pname, GLfloat param)) \\\n    _SG_XMACRO(glTexParameterfv,                  void, (GLenum target, GLenum pname, const GLfloat* params)) \\\n    _SG_XMACRO(glGetShaderInfoLog,                void, (GLuint shader, GLsizei bufSize, GLsizei * length, GLchar * infoLog)) \\\n    _SG_XMACRO(glDepthFunc,                       void, (GLenum func)) \\\n    _SG_XMACRO(glStencilOp ,                      void, (GLenum fail, GLenum zfail, GLenum zpass)) \\\n    _SG_XMACRO(glStencilFunc,                     void, (GLenum func, GLint ref, GLuint mask)) \\\n    _SG_XMACRO(glEnableVertexAttribArray,         void, (GLuint index)) \\\n    _SG_XMACRO(glBlendFunc,                       void, (GLenum sfactor, GLenum dfactor)) \\\n    _SG_XMACRO(glReadBuffer,                      void, (GLenum src)) \\\n    _SG_XMACRO(glTexImage2D,                      void, (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void * pixels)) \\\n    _SG_XMACRO(glGenVertexArrays,                 void, (GLsizei n, GLuint * arrays)) \\\n    _SG_XMACRO(glFrontFace,                       void, (GLenum mode)) \\\n    _SG_XMACRO(glCullFace,                        void, (GLenum mode)) \\\n    _SG_XMACRO(glPixelStorei,                     void, (GLenum pname, GLint param)) \\\n    _SG_XMACRO(glBindSampler,                     void, (GLuint unit, GLuint sampler)) \\\n    _SG_XMACRO(glGenSamplers,                     void, (GLsizei n, GLuint* samplers)) \\\n    _SG_XMACRO(glSamplerParameteri,               void, (GLuint sampler, GLenum pname, GLint param)) \\\n    _SG_XMACRO(glSamplerParameterf,               void, (GLuint sampler, GLenum pname, GLfloat param)) \\\n    _SG_XMACRO(glSamplerParameterfv,              void, (GLuint sampler, GLenum pname, const GLfloat* params)) \\\n    _SG_XMACRO(glDeleteSamplers,                  void, (GLsizei n, const GLuint* samplers)) \\\n    _SG_XMACRO(glBindBufferBase,                  void, (GLenum target, GLuint index, GLuint buffer)) \\\n    _SG_XMACRO(glTexImage2DMultisample,           void, (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations)) \\\n    _SG_XMACRO(glTexImage3DMultisample,           void, (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations))\n\n// generate GL function pointer typedefs\n#define _SG_XMACRO(name, ret, args) typedef ret (GL_APIENTRY* PFN_ ## name) args;\n_SG_GL_FUNCS\n#undef _SG_XMACRO\n\n// generate GL function pointers\n#define _SG_XMACRO(name, ret, args) static PFN_ ## name name;\n_SG_GL_FUNCS\n#undef _SG_XMACRO\n\n// helper function to lookup GL functions in GL DLL\ntypedef PROC (WINAPI * _sg_wglGetProcAddress)(LPCSTR);\n_SOKOL_PRIVATE void* _sg_gl_getprocaddr(const char* name, _sg_wglGetProcAddress wgl_getprocaddress) {\n    void* proc_addr = (void*) wgl_getprocaddress(name);\n    if (0 == proc_addr) {\n        proc_addr = (void*) GetProcAddress(_sg.gl.opengl32_dll, name);\n    }\n    SOKOL_ASSERT(proc_addr);\n    return proc_addr;\n}\n\n// populate GL function pointers\n_SOKOL_PRIVATE  void _sg_gl_load_opengl(void) {\n    SOKOL_ASSERT(0 == _sg.gl.opengl32_dll);\n    _sg.gl.opengl32_dll = LoadLibraryA(\"opengl32.dll\");\n    SOKOL_ASSERT(_sg.gl.opengl32_dll);\n    _sg_wglGetProcAddress wgl_getprocaddress = (_sg_wglGetProcAddress) GetProcAddress(_sg.gl.opengl32_dll, \"wglGetProcAddress\");\n    SOKOL_ASSERT(wgl_getprocaddress);\n    #define _SG_XMACRO(name, ret, args) name = (PFN_ ## name) _sg_gl_getprocaddr(#name, wgl_getprocaddress);\n    _SG_GL_FUNCS\n    #undef _SG_XMACRO\n}\n\n_SOKOL_PRIVATE void _sg_gl_unload_opengl(void) {\n    SOKOL_ASSERT(_sg.gl.opengl32_dll);\n    FreeLibrary(_sg.gl.opengl32_dll);\n    _sg.gl.opengl32_dll = 0;\n}\n#endif // _SOKOL_USE_WIN32_GL_LOADER\n\n//-- type translation ----------------------------------------------------------\n_SOKOL_PRIVATE GLenum _sg_gl_buffer_target(sg_buffer_type t) {\n    switch (t) {\n        case SG_BUFFERTYPE_VERTEXBUFFER:    return GL_ARRAY_BUFFER;\n        case SG_BUFFERTYPE_INDEXBUFFER:     return GL_ELEMENT_ARRAY_BUFFER;\n        case SG_BUFFERTYPE_STORAGEBUFFER:   return GL_SHADER_STORAGE_BUFFER;\n        default: SOKOL_UNREACHABLE; return 0;\n    }\n}\n\n_SOKOL_PRIVATE GLenum _sg_gl_texture_target(sg_image_type t, int sample_count) {\n    #if defined(SOKOL_GLCORE)\n        const bool msaa = sample_count > 1;\n        if (msaa) {\n            switch (t) {\n                case SG_IMAGETYPE_2D: return GL_TEXTURE_2D_MULTISAMPLE;\n                case SG_IMAGETYPE_ARRAY: return GL_TEXTURE_2D_MULTISAMPLE_ARRAY;\n                default: SOKOL_UNREACHABLE; return 0;\n            }\n        } else {\n            switch (t) {\n                case SG_IMAGETYPE_2D:   return GL_TEXTURE_2D;\n                case SG_IMAGETYPE_CUBE: return GL_TEXTURE_CUBE_MAP;\n                case SG_IMAGETYPE_3D:       return GL_TEXTURE_3D;\n                case SG_IMAGETYPE_ARRAY:    return GL_TEXTURE_2D_ARRAY;\n                default: SOKOL_UNREACHABLE; return 0;\n            }\n        }\n    #else\n        SOKOL_ASSERT(sample_count == 1); _SOKOL_UNUSED(sample_count);\n        switch (t) {\n            case SG_IMAGETYPE_2D:   return GL_TEXTURE_2D;\n            case SG_IMAGETYPE_CUBE: return GL_TEXTURE_CUBE_MAP;\n            case SG_IMAGETYPE_3D:       return GL_TEXTURE_3D;\n            case SG_IMAGETYPE_ARRAY:    return GL_TEXTURE_2D_ARRAY;\n            default: SOKOL_UNREACHABLE; return 0;\n        }\n    #endif\n}\n\n_SOKOL_PRIVATE GLenum _sg_gl_usage(sg_usage u) {\n    switch (u) {\n        case SG_USAGE_IMMUTABLE:    return GL_STATIC_DRAW;\n        case SG_USAGE_DYNAMIC:      return GL_DYNAMIC_DRAW;\n        case SG_USAGE_STREAM:       return GL_STREAM_DRAW;\n        default: SOKOL_UNREACHABLE; return 0;\n    }\n}\n\n_SOKOL_PRIVATE GLenum _sg_gl_shader_stage(sg_shader_stage stage) {\n    switch (stage) {\n        case SG_SHADERSTAGE_VERTEX:   return GL_VERTEX_SHADER;\n        case SG_SHADERSTAGE_FRAGMENT: return GL_FRAGMENT_SHADER;\n        default: SOKOL_UNREACHABLE; return 0;\n    }\n}\n\n_SOKOL_PRIVATE GLint _sg_gl_vertexformat_size(sg_vertex_format fmt) {\n    switch (fmt) {\n        case SG_VERTEXFORMAT_FLOAT:     return 1;\n        case SG_VERTEXFORMAT_FLOAT2:    return 2;\n        case SG_VERTEXFORMAT_FLOAT3:    return 3;\n        case SG_VERTEXFORMAT_FLOAT4:    return 4;\n        case SG_VERTEXFORMAT_BYTE4:     return 4;\n        case SG_VERTEXFORMAT_BYTE4N:    return 4;\n        case SG_VERTEXFORMAT_UBYTE4:    return 4;\n        case SG_VERTEXFORMAT_UBYTE4N:   return 4;\n        case SG_VERTEXFORMAT_SHORT2:    return 2;\n        case SG_VERTEXFORMAT_SHORT2N:   return 2;\n        case SG_VERTEXFORMAT_USHORT2N:  return 2;\n        case SG_VERTEXFORMAT_SHORT4:    return 4;\n        case SG_VERTEXFORMAT_SHORT4N:   return 4;\n        case SG_VERTEXFORMAT_USHORT4N:  return 4;\n        case SG_VERTEXFORMAT_UINT10_N2: return 4;\n        case SG_VERTEXFORMAT_HALF2:     return 2;\n        case SG_VERTEXFORMAT_HALF4:     return 4;\n        default: SOKOL_UNREACHABLE; return 0;\n    }\n}\n\n_SOKOL_PRIVATE GLenum _sg_gl_vertexformat_type(sg_vertex_format fmt) {\n    switch (fmt) {\n        case SG_VERTEXFORMAT_FLOAT:\n        case SG_VERTEXFORMAT_FLOAT2:\n        case SG_VERTEXFORMAT_FLOAT3:\n        case SG_VERTEXFORMAT_FLOAT4:\n            return GL_FLOAT;\n        case SG_VERTEXFORMAT_BYTE4:\n        case SG_VERTEXFORMAT_BYTE4N:\n            return GL_BYTE;\n        case SG_VERTEXFORMAT_UBYTE4:\n        case SG_VERTEXFORMAT_UBYTE4N:\n            return GL_UNSIGNED_BYTE;\n        case SG_VERTEXFORMAT_SHORT2:\n        case SG_VERTEXFORMAT_SHORT2N:\n        case SG_VERTEXFORMAT_SHORT4:\n        case SG_VERTEXFORMAT_SHORT4N:\n            return GL_SHORT;\n        case SG_VERTEXFORMAT_USHORT2N:\n        case SG_VERTEXFORMAT_USHORT4N:\n            return GL_UNSIGNED_SHORT;\n        case SG_VERTEXFORMAT_UINT10_N2:\n            return GL_UNSIGNED_INT_2_10_10_10_REV;\n        case SG_VERTEXFORMAT_HALF2:\n        case SG_VERTEXFORMAT_HALF4:\n            return GL_HALF_FLOAT;\n        default:\n            SOKOL_UNREACHABLE; return 0;\n    }\n}\n\n_SOKOL_PRIVATE GLboolean _sg_gl_vertexformat_normalized(sg_vertex_format fmt) {\n    switch (fmt) {\n        case SG_VERTEXFORMAT_BYTE4N:\n        case SG_VERTEXFORMAT_UBYTE4N:\n        case SG_VERTEXFORMAT_SHORT2N:\n        case SG_VERTEXFORMAT_USHORT2N:\n        case SG_VERTEXFORMAT_SHORT4N:\n        case SG_VERTEXFORMAT_USHORT4N:\n        case SG_VERTEXFORMAT_UINT10_N2:\n            return GL_TRUE;\n        default:\n            return GL_FALSE;\n    }\n}\n\n_SOKOL_PRIVATE GLenum _sg_gl_primitive_type(sg_primitive_type t) {\n    switch (t) {\n        case SG_PRIMITIVETYPE_POINTS:           return GL_POINTS;\n        case SG_PRIMITIVETYPE_LINES:            return GL_LINES;\n        case SG_PRIMITIVETYPE_LINE_STRIP:       return GL_LINE_STRIP;\n        case SG_PRIMITIVETYPE_TRIANGLES:        return GL_TRIANGLES;\n        case SG_PRIMITIVETYPE_TRIANGLE_STRIP:   return GL_TRIANGLE_STRIP;\n        default: SOKOL_UNREACHABLE; return 0;\n    }\n}\n\n_SOKOL_PRIVATE GLenum _sg_gl_index_type(sg_index_type t) {\n    switch (t) {\n        case SG_INDEXTYPE_NONE:     return 0;\n        case SG_INDEXTYPE_UINT16:   return GL_UNSIGNED_SHORT;\n        case SG_INDEXTYPE_UINT32:   return GL_UNSIGNED_INT;\n        default: SOKOL_UNREACHABLE; return 0;\n    }\n}\n\n_SOKOL_PRIVATE GLenum _sg_gl_compare_func(sg_compare_func cmp) {\n    switch (cmp) {\n        case SG_COMPAREFUNC_NEVER:          return GL_NEVER;\n        case SG_COMPAREFUNC_LESS:           return GL_LESS;\n        case SG_COMPAREFUNC_EQUAL:          return GL_EQUAL;\n        case SG_COMPAREFUNC_LESS_EQUAL:     return GL_LEQUAL;\n        case SG_COMPAREFUNC_GREATER:        return GL_GREATER;\n        case SG_COMPAREFUNC_NOT_EQUAL:      return GL_NOTEQUAL;\n        case SG_COMPAREFUNC_GREATER_EQUAL:  return GL_GEQUAL;\n        case SG_COMPAREFUNC_ALWAYS:         return GL_ALWAYS;\n        default: SOKOL_UNREACHABLE; return 0;\n    }\n}\n\n_SOKOL_PRIVATE GLenum _sg_gl_stencil_op(sg_stencil_op op) {\n    switch (op) {\n        case SG_STENCILOP_KEEP:         return GL_KEEP;\n        case SG_STENCILOP_ZERO:         return GL_ZERO;\n        case SG_STENCILOP_REPLACE:      return GL_REPLACE;\n        case SG_STENCILOP_INCR_CLAMP:   return GL_INCR;\n        case SG_STENCILOP_DECR_CLAMP:   return GL_DECR;\n        case SG_STENCILOP_INVERT:       return GL_INVERT;\n        case SG_STENCILOP_INCR_WRAP:    return GL_INCR_WRAP;\n        case SG_STENCILOP_DECR_WRAP:    return GL_DECR_WRAP;\n        default: SOKOL_UNREACHABLE; return 0;\n    }\n}\n\n_SOKOL_PRIVATE GLenum _sg_gl_blend_factor(sg_blend_factor f) {\n    switch (f) {\n        case SG_BLENDFACTOR_ZERO:                   return GL_ZERO;\n        case SG_BLENDFACTOR_ONE:                    return GL_ONE;\n        case SG_BLENDFACTOR_SRC_COLOR:              return GL_SRC_COLOR;\n        case SG_BLENDFACTOR_ONE_MINUS_SRC_COLOR:    return GL_ONE_MINUS_SRC_COLOR;\n        case SG_BLENDFACTOR_SRC_ALPHA:              return GL_SRC_ALPHA;\n        case SG_BLENDFACTOR_ONE_MINUS_SRC_ALPHA:    return GL_ONE_MINUS_SRC_ALPHA;\n        case SG_BLENDFACTOR_DST_COLOR:              return GL_DST_COLOR;\n        case SG_BLENDFACTOR_ONE_MINUS_DST_COLOR:    return GL_ONE_MINUS_DST_COLOR;\n        case SG_BLENDFACTOR_DST_ALPHA:              return GL_DST_ALPHA;\n        case SG_BLENDFACTOR_ONE_MINUS_DST_ALPHA:    return GL_ONE_MINUS_DST_ALPHA;\n        case SG_BLENDFACTOR_SRC_ALPHA_SATURATED:    return GL_SRC_ALPHA_SATURATE;\n        case SG_BLENDFACTOR_BLEND_COLOR:            return GL_CONSTANT_COLOR;\n        case SG_BLENDFACTOR_ONE_MINUS_BLEND_COLOR:  return GL_ONE_MINUS_CONSTANT_COLOR;\n        case SG_BLENDFACTOR_BLEND_ALPHA:            return GL_CONSTANT_ALPHA;\n        case SG_BLENDFACTOR_ONE_MINUS_BLEND_ALPHA:  return GL_ONE_MINUS_CONSTANT_ALPHA;\n        default: SOKOL_UNREACHABLE; return 0;\n    }\n}\n\n_SOKOL_PRIVATE GLenum _sg_gl_blend_op(sg_blend_op op) {\n    switch (op) {\n        case SG_BLENDOP_ADD:                return GL_FUNC_ADD;\n        case SG_BLENDOP_SUBTRACT:           return GL_FUNC_SUBTRACT;\n        case SG_BLENDOP_REVERSE_SUBTRACT:   return GL_FUNC_REVERSE_SUBTRACT;\n        default: SOKOL_UNREACHABLE; return 0;\n    }\n}\n\n_SOKOL_PRIVATE GLenum _sg_gl_min_filter(sg_filter min_f, sg_filter mipmap_f) {\n    if (min_f == SG_FILTER_NEAREST) {\n        switch (mipmap_f) {\n            case SG_FILTER_NEAREST: return GL_NEAREST_MIPMAP_NEAREST;\n            case SG_FILTER_LINEAR:  return GL_NEAREST_MIPMAP_LINEAR;\n            default: SOKOL_UNREACHABLE; return (GLenum)0;\n        }\n    } else if (min_f == SG_FILTER_LINEAR) {\n        switch (mipmap_f) {\n            case SG_FILTER_NEAREST: return GL_LINEAR_MIPMAP_NEAREST;\n            case SG_FILTER_LINEAR:  return GL_LINEAR_MIPMAP_LINEAR;\n            default: SOKOL_UNREACHABLE; return (GLenum)0;\n        }\n    } else {\n        SOKOL_UNREACHABLE; return (GLenum)0;\n    }\n}\n\n_SOKOL_PRIVATE GLenum _sg_gl_mag_filter(sg_filter mag_f) {\n    if (mag_f == SG_FILTER_NEAREST) {\n        return GL_NEAREST;\n    } else {\n        return GL_LINEAR;\n    }\n}\n\n_SOKOL_PRIVATE GLenum _sg_gl_wrap(sg_wrap w) {\n    switch (w) {\n        case SG_WRAP_CLAMP_TO_EDGE:     return GL_CLAMP_TO_EDGE;\n        #if defined(SOKOL_GLCORE)\n        case SG_WRAP_CLAMP_TO_BORDER:   return GL_CLAMP_TO_BORDER;\n        #else\n        case SG_WRAP_CLAMP_TO_BORDER:   return GL_CLAMP_TO_EDGE;\n        #endif\n        case SG_WRAP_REPEAT:            return GL_REPEAT;\n        case SG_WRAP_MIRRORED_REPEAT:   return GL_MIRRORED_REPEAT;\n        default: SOKOL_UNREACHABLE; return 0;\n    }\n}\n\n_SOKOL_PRIVATE GLenum _sg_gl_teximage_type(sg_pixel_format fmt) {\n    switch (fmt) {\n        case SG_PIXELFORMAT_R8:\n        case SG_PIXELFORMAT_R8UI:\n        case SG_PIXELFORMAT_RG8:\n        case SG_PIXELFORMAT_RG8UI:\n        case SG_PIXELFORMAT_RGBA8:\n        case SG_PIXELFORMAT_SRGB8A8:\n        case SG_PIXELFORMAT_RGBA8UI:\n        case SG_PIXELFORMAT_BGRA8:\n            return GL_UNSIGNED_BYTE;\n        case SG_PIXELFORMAT_R8SN:\n        case SG_PIXELFORMAT_R8SI:\n        case SG_PIXELFORMAT_RG8SN:\n        case SG_PIXELFORMAT_RG8SI:\n        case SG_PIXELFORMAT_RGBA8SN:\n        case SG_PIXELFORMAT_RGBA8SI:\n            return GL_BYTE;\n        case SG_PIXELFORMAT_R16:\n        case SG_PIXELFORMAT_R16UI:\n        case SG_PIXELFORMAT_RG16:\n        case SG_PIXELFORMAT_RG16UI:\n        case SG_PIXELFORMAT_RGBA16:\n        case SG_PIXELFORMAT_RGBA16UI:\n            return GL_UNSIGNED_SHORT;\n        case SG_PIXELFORMAT_R16SN:\n        case SG_PIXELFORMAT_R16SI:\n        case SG_PIXELFORMAT_RG16SN:\n        case SG_PIXELFORMAT_RG16SI:\n        case SG_PIXELFORMAT_RGBA16SN:\n        case SG_PIXELFORMAT_RGBA16SI:\n            return GL_SHORT;\n        case SG_PIXELFORMAT_R16F:\n        case SG_PIXELFORMAT_RG16F:\n        case SG_PIXELFORMAT_RGBA16F:\n            return GL_HALF_FLOAT;\n        case SG_PIXELFORMAT_R32UI:\n        case SG_PIXELFORMAT_RG32UI:\n        case SG_PIXELFORMAT_RGBA32UI:\n            return GL_UNSIGNED_INT;\n        case SG_PIXELFORMAT_R32SI:\n        case SG_PIXELFORMAT_RG32SI:\n        case SG_PIXELFORMAT_RGBA32SI:\n            return GL_INT;\n        case SG_PIXELFORMAT_R32F:\n        case SG_PIXELFORMAT_RG32F:\n        case SG_PIXELFORMAT_RGBA32F:\n            return GL_FLOAT;\n        case SG_PIXELFORMAT_RGB10A2:\n            return GL_UNSIGNED_INT_2_10_10_10_REV;\n        case SG_PIXELFORMAT_RG11B10F:\n            return GL_UNSIGNED_INT_10F_11F_11F_REV;\n        case SG_PIXELFORMAT_RGB9E5:\n            return GL_UNSIGNED_INT_5_9_9_9_REV;\n        case SG_PIXELFORMAT_DEPTH:\n            return GL_FLOAT;\n        case SG_PIXELFORMAT_DEPTH_STENCIL:\n            return GL_UNSIGNED_INT_24_8;\n        default:\n            SOKOL_UNREACHABLE; return 0;\n    }\n}\n\n_SOKOL_PRIVATE GLenum _sg_gl_teximage_format(sg_pixel_format fmt) {\n    switch (fmt) {\n        case SG_PIXELFORMAT_R8:\n        case SG_PIXELFORMAT_R8SN:\n        case SG_PIXELFORMAT_R16:\n        case SG_PIXELFORMAT_R16SN:\n        case SG_PIXELFORMAT_R16F:\n        case SG_PIXELFORMAT_R32F:\n            return GL_RED;\n        case SG_PIXELFORMAT_R8UI:\n        case SG_PIXELFORMAT_R8SI:\n        case SG_PIXELFORMAT_R16UI:\n        case SG_PIXELFORMAT_R16SI:\n        case SG_PIXELFORMAT_R32UI:\n        case SG_PIXELFORMAT_R32SI:\n            return GL_RED_INTEGER;\n        case SG_PIXELFORMAT_RG8:\n        case SG_PIXELFORMAT_RG8SN:\n        case SG_PIXELFORMAT_RG16:\n        case SG_PIXELFORMAT_RG16SN:\n        case SG_PIXELFORMAT_RG16F:\n        case SG_PIXELFORMAT_RG32F:\n            return GL_RG;\n        case SG_PIXELFORMAT_RG8UI:\n        case SG_PIXELFORMAT_RG8SI:\n        case SG_PIXELFORMAT_RG16UI:\n        case SG_PIXELFORMAT_RG16SI:\n        case SG_PIXELFORMAT_RG32UI:\n        case SG_PIXELFORMAT_RG32SI:\n            return GL_RG_INTEGER;\n        case SG_PIXELFORMAT_RGBA8:\n        case SG_PIXELFORMAT_SRGB8A8:\n        case SG_PIXELFORMAT_RGBA8SN:\n        case SG_PIXELFORMAT_RGBA16:\n        case SG_PIXELFORMAT_RGBA16SN:\n        case SG_PIXELFORMAT_RGBA16F:\n        case SG_PIXELFORMAT_RGBA32F:\n        case SG_PIXELFORMAT_RGB10A2:\n            return GL_RGBA;\n        case SG_PIXELFORMAT_RGBA8UI:\n        case SG_PIXELFORMAT_RGBA8SI:\n        case SG_PIXELFORMAT_RGBA16UI:\n        case SG_PIXELFORMAT_RGBA16SI:\n        case SG_PIXELFORMAT_RGBA32UI:\n        case SG_PIXELFORMAT_RGBA32SI:\n            return GL_RGBA_INTEGER;\n        case SG_PIXELFORMAT_RG11B10F:\n        case SG_PIXELFORMAT_RGB9E5:\n            return GL_RGB;\n        case SG_PIXELFORMAT_DEPTH:\n            return GL_DEPTH_COMPONENT;\n        case SG_PIXELFORMAT_DEPTH_STENCIL:\n            return GL_DEPTH_STENCIL;\n        case SG_PIXELFORMAT_BC1_RGBA:\n            return GL_COMPRESSED_RGBA_S3TC_DXT1_EXT;\n        case SG_PIXELFORMAT_BC2_RGBA:\n            return GL_COMPRESSED_RGBA_S3TC_DXT3_EXT;\n        case SG_PIXELFORMAT_BC3_RGBA:\n            return GL_COMPRESSED_RGBA_S3TC_DXT5_EXT;\n        case SG_PIXELFORMAT_BC3_SRGBA:\n            return GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;\n        case SG_PIXELFORMAT_BC4_R:\n            return GL_COMPRESSED_RED_RGTC1;\n        case SG_PIXELFORMAT_BC4_RSN:\n            return GL_COMPRESSED_SIGNED_RED_RGTC1;\n        case SG_PIXELFORMAT_BC5_RG:\n            return GL_COMPRESSED_RED_GREEN_RGTC2;\n        case SG_PIXELFORMAT_BC5_RGSN:\n            return GL_COMPRESSED_SIGNED_RED_GREEN_RGTC2;\n        case SG_PIXELFORMAT_BC6H_RGBF:\n            return GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT_ARB;\n        case SG_PIXELFORMAT_BC6H_RGBUF:\n            return GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_ARB;\n        case SG_PIXELFORMAT_BC7_RGBA:\n            return GL_COMPRESSED_RGBA_BPTC_UNORM_ARB;\n        case SG_PIXELFORMAT_BC7_SRGBA:\n            return GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM_ARB;\n        case SG_PIXELFORMAT_PVRTC_RGB_2BPP:\n            return GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\n        case SG_PIXELFORMAT_PVRTC_RGB_4BPP:\n            return GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\n        case SG_PIXELFORMAT_PVRTC_RGBA_2BPP:\n            return GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\n        case SG_PIXELFORMAT_PVRTC_RGBA_4BPP:\n            return GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\n        case SG_PIXELFORMAT_ETC2_RGB8:\n            return GL_COMPRESSED_RGB8_ETC2;\n        case SG_PIXELFORMAT_ETC2_SRGB8:\n            return GL_COMPRESSED_SRGB8_ETC2;\n        case SG_PIXELFORMAT_ETC2_RGB8A1:\n            return GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2;\n        case SG_PIXELFORMAT_ETC2_RGBA8:\n            return GL_COMPRESSED_RGBA8_ETC2_EAC;\n        case SG_PIXELFORMAT_ETC2_SRGB8A8:\n            return GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;\n        case SG_PIXELFORMAT_EAC_R11:\n            return GL_COMPRESSED_R11_EAC;\n        case SG_PIXELFORMAT_EAC_R11SN:\n            return GL_COMPRESSED_SIGNED_R11_EAC;\n        case SG_PIXELFORMAT_EAC_RG11:\n            return GL_COMPRESSED_RG11_EAC;\n        case SG_PIXELFORMAT_EAC_RG11SN:\n            return GL_COMPRESSED_SIGNED_RG11_EAC;\n        case SG_PIXELFORMAT_ASTC_4x4_RGBA:\n            return GL_COMPRESSED_RGBA_ASTC_4x4_KHR;\n        case SG_PIXELFORMAT_ASTC_4x4_SRGBA:\n            return GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;\n        default:\n            SOKOL_UNREACHABLE; return 0;\n    }\n}\n\n_SOKOL_PRIVATE GLenum _sg_gl_teximage_internal_format(sg_pixel_format fmt) {\n    switch (fmt) {\n        case SG_PIXELFORMAT_R8:         return GL_R8;\n        case SG_PIXELFORMAT_R8SN:       return GL_R8_SNORM;\n        case SG_PIXELFORMAT_R8UI:       return GL_R8UI;\n        case SG_PIXELFORMAT_R8SI:       return GL_R8I;\n        #if !defined(SOKOL_GLES3)\n            case SG_PIXELFORMAT_R16:        return GL_R16;\n            case SG_PIXELFORMAT_R16SN:      return GL_R16_SNORM;\n        #endif\n        case SG_PIXELFORMAT_R16UI:      return GL_R16UI;\n        case SG_PIXELFORMAT_R16SI:      return GL_R16I;\n        case SG_PIXELFORMAT_R16F:       return GL_R16F;\n        case SG_PIXELFORMAT_RG8:        return GL_RG8;\n        case SG_PIXELFORMAT_RG8SN:      return GL_RG8_SNORM;\n        case SG_PIXELFORMAT_RG8UI:      return GL_RG8UI;\n        case SG_PIXELFORMAT_RG8SI:      return GL_RG8I;\n        case SG_PIXELFORMAT_R32UI:      return GL_R32UI;\n        case SG_PIXELFORMAT_R32SI:      return GL_R32I;\n        case SG_PIXELFORMAT_R32F:       return GL_R32F;\n        #if !defined(SOKOL_GLES3)\n            case SG_PIXELFORMAT_RG16:       return GL_RG16;\n            case SG_PIXELFORMAT_RG16SN:     return GL_RG16_SNORM;\n        #endif\n        case SG_PIXELFORMAT_RG16UI:     return GL_RG16UI;\n        case SG_PIXELFORMAT_RG16SI:     return GL_RG16I;\n        case SG_PIXELFORMAT_RG16F:      return GL_RG16F;\n        case SG_PIXELFORMAT_RGBA8:      return GL_RGBA8;\n        case SG_PIXELFORMAT_SRGB8A8:    return GL_SRGB8_ALPHA8;\n        case SG_PIXELFORMAT_RGBA8SN:    return GL_RGBA8_SNORM;\n        case SG_PIXELFORMAT_RGBA8UI:    return GL_RGBA8UI;\n        case SG_PIXELFORMAT_RGBA8SI:    return GL_RGBA8I;\n        case SG_PIXELFORMAT_RGB10A2:    return GL_RGB10_A2;\n        case SG_PIXELFORMAT_RG11B10F:   return GL_R11F_G11F_B10F;\n        case SG_PIXELFORMAT_RGB9E5:     return GL_RGB9_E5;\n        case SG_PIXELFORMAT_RG32UI:     return GL_RG32UI;\n        case SG_PIXELFORMAT_RG32SI:     return GL_RG32I;\n        case SG_PIXELFORMAT_RG32F:      return GL_RG32F;\n        #if !defined(SOKOL_GLES3)\n            case SG_PIXELFORMAT_RGBA16:     return GL_RGBA16;\n            case SG_PIXELFORMAT_RGBA16SN:   return GL_RGBA16_SNORM;\n        #endif\n        case SG_PIXELFORMAT_RGBA16UI:   return GL_RGBA16UI;\n        case SG_PIXELFORMAT_RGBA16SI:   return GL_RGBA16I;\n        case SG_PIXELFORMAT_RGBA16F:    return GL_RGBA16F;\n        case SG_PIXELFORMAT_RGBA32UI:   return GL_RGBA32UI;\n        case SG_PIXELFORMAT_RGBA32SI:   return GL_RGBA32I;\n        case SG_PIXELFORMAT_RGBA32F:    return GL_RGBA32F;\n        case SG_PIXELFORMAT_DEPTH:      return GL_DEPTH_COMPONENT32F;\n        case SG_PIXELFORMAT_DEPTH_STENCIL:      return GL_DEPTH24_STENCIL8;\n        case SG_PIXELFORMAT_BC1_RGBA:           return GL_COMPRESSED_RGBA_S3TC_DXT1_EXT;\n        case SG_PIXELFORMAT_BC2_RGBA:           return GL_COMPRESSED_RGBA_S3TC_DXT3_EXT;\n        case SG_PIXELFORMAT_BC3_RGBA:           return GL_COMPRESSED_RGBA_S3TC_DXT5_EXT;\n        case SG_PIXELFORMAT_BC3_SRGBA:          return GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;\n        case SG_PIXELFORMAT_BC4_R:              return GL_COMPRESSED_RED_RGTC1;\n        case SG_PIXELFORMAT_BC4_RSN:            return GL_COMPRESSED_SIGNED_RED_RGTC1;\n        case SG_PIXELFORMAT_BC5_RG:             return GL_COMPRESSED_RED_GREEN_RGTC2;\n        case SG_PIXELFORMAT_BC5_RGSN:           return GL_COMPRESSED_SIGNED_RED_GREEN_RGTC2;\n        case SG_PIXELFORMAT_BC6H_RGBF:          return GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT_ARB;\n        case SG_PIXELFORMAT_BC6H_RGBUF:         return GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_ARB;\n        case SG_PIXELFORMAT_BC7_RGBA:           return GL_COMPRESSED_RGBA_BPTC_UNORM_ARB;\n        case SG_PIXELFORMAT_BC7_SRGBA:          return GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM_ARB;\n        case SG_PIXELFORMAT_PVRTC_RGB_2BPP:     return GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\n        case SG_PIXELFORMAT_PVRTC_RGB_4BPP:     return GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\n        case SG_PIXELFORMAT_PVRTC_RGBA_2BPP:    return GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\n        case SG_PIXELFORMAT_PVRTC_RGBA_4BPP:    return GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\n        case SG_PIXELFORMAT_ETC2_RGB8:          return GL_COMPRESSED_RGB8_ETC2;\n        case SG_PIXELFORMAT_ETC2_SRGB8:         return GL_COMPRESSED_SRGB8_ETC2;\n        case SG_PIXELFORMAT_ETC2_RGB8A1:        return GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2;\n        case SG_PIXELFORMAT_ETC2_RGBA8:         return GL_COMPRESSED_RGBA8_ETC2_EAC;\n        case SG_PIXELFORMAT_ETC2_SRGB8A8:       return GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;\n        case SG_PIXELFORMAT_EAC_R11:            return GL_COMPRESSED_R11_EAC;\n        case SG_PIXELFORMAT_EAC_R11SN:          return GL_COMPRESSED_SIGNED_R11_EAC;\n        case SG_PIXELFORMAT_EAC_RG11:           return GL_COMPRESSED_RG11_EAC;\n        case SG_PIXELFORMAT_EAC_RG11SN:         return GL_COMPRESSED_SIGNED_RG11_EAC;\n        case SG_PIXELFORMAT_ASTC_4x4_RGBA:      return GL_COMPRESSED_RGBA_ASTC_4x4_KHR;\n        case SG_PIXELFORMAT_ASTC_4x4_SRGBA:     return GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;\n        default: SOKOL_UNREACHABLE; return 0;\n    }\n}\n\n_SOKOL_PRIVATE GLenum _sg_gl_cubeface_target(int face_index) {\n    switch (face_index) {\n        case 0: return GL_TEXTURE_CUBE_MAP_POSITIVE_X;\n        case 1: return GL_TEXTURE_CUBE_MAP_NEGATIVE_X;\n        case 2: return GL_TEXTURE_CUBE_MAP_POSITIVE_Y;\n        case 3: return GL_TEXTURE_CUBE_MAP_NEGATIVE_Y;\n        case 4: return GL_TEXTURE_CUBE_MAP_POSITIVE_Z;\n        case 5: return GL_TEXTURE_CUBE_MAP_NEGATIVE_Z;\n        default: SOKOL_UNREACHABLE; return 0;\n    }\n}\n\n// see: https://www.khronos.org/registry/OpenGL-Refpages/es3.0/html/glTexImage2D.xhtml\n_SOKOL_PRIVATE void _sg_gl_init_pixelformats(bool has_bgra) {\n    _sg_pixelformat_all(&_sg.formats[SG_PIXELFORMAT_R8]);\n    _sg_pixelformat_sf(&_sg.formats[SG_PIXELFORMAT_R8SN]);\n    _sg_pixelformat_srm(&_sg.formats[SG_PIXELFORMAT_R8UI]);\n    _sg_pixelformat_srm(&_sg.formats[SG_PIXELFORMAT_R8SI]);\n    #if !defined(SOKOL_GLES3)\n        _sg_pixelformat_all(&_sg.formats[SG_PIXELFORMAT_R16]);\n        _sg_pixelformat_all(&_sg.formats[SG_PIXELFORMAT_R16SN]);\n    #endif\n    _sg_pixelformat_srm(&_sg.formats[SG_PIXELFORMAT_R16UI]);\n    _sg_pixelformat_srm(&_sg.formats[SG_PIXELFORMAT_R16SI]);\n    _sg_pixelformat_all(&_sg.formats[SG_PIXELFORMAT_RG8]);\n    _sg_pixelformat_sf(&_sg.formats[SG_PIXELFORMAT_RG8SN]);\n    _sg_pixelformat_srm(&_sg.formats[SG_PIXELFORMAT_RG8UI]);\n    _sg_pixelformat_srm(&_sg.formats[SG_PIXELFORMAT_RG8SI]);\n    _sg_pixelformat_sr(&_sg.formats[SG_PIXELFORMAT_R32UI]);\n    _sg_pixelformat_sr(&_sg.formats[SG_PIXELFORMAT_R32SI]);\n    #if !defined(SOKOL_GLES3)\n        _sg_pixelformat_all(&_sg.formats[SG_PIXELFORMAT_RG16]);\n        _sg_pixelformat_all(&_sg.formats[SG_PIXELFORMAT_RG16SN]);\n    #endif\n    _sg_pixelformat_srm(&_sg.formats[SG_PIXELFORMAT_RG16UI]);\n    _sg_pixelformat_srm(&_sg.formats[SG_PIXELFORMAT_RG16SI]);\n    _sg_pixelformat_all(&_sg.formats[SG_PIXELFORMAT_RGBA8]);\n    _sg_pixelformat_all(&_sg.formats[SG_PIXELFORMAT_SRGB8A8]);\n    _sg_pixelformat_sf(&_sg.formats[SG_PIXELFORMAT_RGBA8SN]);\n    _sg_pixelformat_srm(&_sg.formats[SG_PIXELFORMAT_RGBA8UI]);\n    _sg_pixelformat_srm(&_sg.formats[SG_PIXELFORMAT_RGBA8SI]);\n    if (has_bgra) {\n        _sg_pixelformat_all(&_sg.formats[SG_PIXELFORMAT_BGRA8]);\n    }\n    _sg_pixelformat_all(&_sg.formats[SG_PIXELFORMAT_RGB10A2]);\n    _sg_pixelformat_sf(&_sg.formats[SG_PIXELFORMAT_RGB9E5]);\n    _sg_pixelformat_srm(&_sg.formats[SG_PIXELFORMAT_RG32UI]);\n    _sg_pixelformat_srm(&_sg.formats[SG_PIXELFORMAT_RG32SI]);\n    #if !defined(SOKOL_GLES3)\n        _sg_pixelformat_all(&_sg.formats[SG_PIXELFORMAT_RGBA16]);\n        _sg_pixelformat_all(&_sg.formats[SG_PIXELFORMAT_RGBA16SN]);\n    #endif\n    _sg_pixelformat_srm(&_sg.formats[SG_PIXELFORMAT_RGBA16UI]);\n    _sg_pixelformat_srm(&_sg.formats[SG_PIXELFORMAT_RGBA16SI]);\n    _sg_pixelformat_srm(&_sg.formats[SG_PIXELFORMAT_RGBA32UI]);\n    _sg_pixelformat_srm(&_sg.formats[SG_PIXELFORMAT_RGBA32SI]);\n    _sg_pixelformat_srmd(&_sg.formats[SG_PIXELFORMAT_DEPTH]);\n    _sg_pixelformat_srmd(&_sg.formats[SG_PIXELFORMAT_DEPTH_STENCIL]);\n}\n\n// FIXME: OES_half_float_blend\n_SOKOL_PRIVATE void _sg_gl_init_pixelformats_half_float(bool has_colorbuffer_half_float) {\n    if (has_colorbuffer_half_float) {\n        _sg_pixelformat_all(&_sg.formats[SG_PIXELFORMAT_R16F]);\n        _sg_pixelformat_all(&_sg.formats[SG_PIXELFORMAT_RG16F]);\n        _sg_pixelformat_all(&_sg.formats[SG_PIXELFORMAT_RGBA16F]);\n    } else {\n        _sg_pixelformat_sf(&_sg.formats[SG_PIXELFORMAT_R16F]);\n        _sg_pixelformat_sf(&_sg.formats[SG_PIXELFORMAT_RG16F]);\n        _sg_pixelformat_sf(&_sg.formats[SG_PIXELFORMAT_RGBA16F]);\n    }\n}\n\n_SOKOL_PRIVATE void _sg_gl_init_pixelformats_float(bool has_colorbuffer_float, bool has_texture_float_linear, bool has_float_blend) {\n    if (has_texture_float_linear) {\n        if (has_colorbuffer_float) {\n            if (has_float_blend) {\n                _sg_pixelformat_all(&_sg.formats[SG_PIXELFORMAT_R32F]);\n                _sg_pixelformat_all(&_sg.formats[SG_PIXELFORMAT_RG32F]);\n                _sg_pixelformat_all(&_sg.formats[SG_PIXELFORMAT_RGBA32F]);\n            } else {\n                _sg_pixelformat_sfrm(&_sg.formats[SG_PIXELFORMAT_R32F]);\n                _sg_pixelformat_sfrm(&_sg.formats[SG_PIXELFORMAT_RG32F]);\n                _sg_pixelformat_sfrm(&_sg.formats[SG_PIXELFORMAT_RGBA32F]);\n            }\n            _sg_pixelformat_sfrm(&_sg.formats[SG_PIXELFORMAT_RG11B10F]);\n        } else {\n            _sg_pixelformat_sf(&_sg.formats[SG_PIXELFORMAT_R32F]);\n            _sg_pixelformat_sf(&_sg.formats[SG_PIXELFORMAT_RG32F]);\n            _sg_pixelformat_sf(&_sg.formats[SG_PIXELFORMAT_RGBA32F]);\n            _sg_pixelformat_sf(&_sg.formats[SG_PIXELFORMAT_RG11B10F]);\n        }\n    } else {\n        if (has_colorbuffer_float) {\n            _sg_pixelformat_sbrm(&_sg.formats[SG_PIXELFORMAT_R32F]);\n            _sg_pixelformat_sbrm(&_sg.formats[SG_PIXELFORMAT_RG32F]);\n            _sg_pixelformat_sbrm(&_sg.formats[SG_PIXELFORMAT_RGBA32F]);\n            _sg_pixelformat_srm(&_sg.formats[SG_PIXELFORMAT_RG11B10F]);\n        } else {\n            _sg_pixelformat_s(&_sg.formats[SG_PIXELFORMAT_R32F]);\n            _sg_pixelformat_s(&_sg.formats[SG_PIXELFORMAT_RG32F]);\n            _sg_pixelformat_s(&_sg.formats[SG_PIXELFORMAT_RGBA32F]);\n            _sg_pixelformat_s(&_sg.formats[SG_PIXELFORMAT_RG11B10F]);\n        }\n    }\n}\n\n_SOKOL_PRIVATE void _sg_gl_init_pixelformats_s3tc(void) {\n    _sg_pixelformat_sf(&_sg.formats[SG_PIXELFORMAT_BC1_RGBA]);\n    _sg_pixelformat_sf(&_sg.formats[SG_PIXELFORMAT_BC2_RGBA]);\n    _sg_pixelformat_sf(&_sg.formats[SG_PIXELFORMAT_BC3_RGBA]);\n    _sg_pixelformat_sf(&_sg.formats[SG_PIXELFORMAT_BC3_SRGBA]);\n}\n\n_SOKOL_PRIVATE void _sg_gl_init_pixelformats_rgtc(void) {\n    _sg_pixelformat_sf(&_sg.formats[SG_PIXELFORMAT_BC4_R]);\n    _sg_pixelformat_sf(&_sg.formats[SG_PIXELFORMAT_BC4_RSN]);\n    _sg_pixelformat_sf(&_sg.formats[SG_PIXELFORMAT_BC5_RG]);\n    _sg_pixelformat_sf(&_sg.formats[SG_PIXELFORMAT_BC5_RGSN]);\n}\n\n_SOKOL_PRIVATE void _sg_gl_init_pixelformats_bptc(void) {\n    _sg_pixelformat_sf(&_sg.formats[SG_PIXELFORMAT_BC6H_RGBF]);\n    _sg_pixelformat_sf(&_sg.formats[SG_PIXELFORMAT_BC6H_RGBUF]);\n    _sg_pixelformat_sf(&_sg.formats[SG_PIXELFORMAT_BC7_RGBA]);\n    _sg_pixelformat_sf(&_sg.formats[SG_PIXELFORMAT_BC7_SRGBA]);\n}\n\n_SOKOL_PRIVATE void _sg_gl_init_pixelformats_pvrtc(void) {\n    _sg_pixelformat_sf(&_sg.formats[SG_PIXELFORMAT_PVRTC_RGB_2BPP]);\n    _sg_pixelformat_sf(&_sg.formats[SG_PIXELFORMAT_PVRTC_RGB_4BPP]);\n    _sg_pixelformat_sf(&_sg.formats[SG_PIXELFORMAT_PVRTC_RGBA_2BPP]);\n    _sg_pixelformat_sf(&_sg.formats[SG_PIXELFORMAT_PVRTC_RGBA_4BPP]);\n}\n\n_SOKOL_PRIVATE void _sg_gl_init_pixelformats_etc2(void) {\n    _sg_pixelformat_sf(&_sg.formats[SG_PIXELFORMAT_ETC2_RGB8]);\n    _sg_pixelformat_sf(&_sg.formats[SG_PIXELFORMAT_ETC2_SRGB8]);\n    _sg_pixelformat_sf(&_sg.formats[SG_PIXELFORMAT_ETC2_RGB8A1]);\n    _sg_pixelformat_sf(&_sg.formats[SG_PIXELFORMAT_ETC2_RGBA8]);\n    _sg_pixelformat_sf(&_sg.formats[SG_PIXELFORMAT_ETC2_SRGB8A8]);\n    _sg_pixelformat_sf(&_sg.formats[SG_PIXELFORMAT_EAC_R11]);\n    _sg_pixelformat_sf(&_sg.formats[SG_PIXELFORMAT_EAC_R11SN]);\n    _sg_pixelformat_sf(&_sg.formats[SG_PIXELFORMAT_EAC_RG11]);\n    _sg_pixelformat_sf(&_sg.formats[SG_PIXELFORMAT_EAC_RG11SN]);\n}\n\n_SOKOL_PRIVATE void _sg_gl_init_pixelformats_astc(void) {\n     _sg_pixelformat_sf(&_sg.formats[SG_PIXELFORMAT_ASTC_4x4_RGBA]);\n     _sg_pixelformat_sf(&_sg.formats[SG_PIXELFORMAT_ASTC_4x4_SRGBA]);\n }\n\n_SOKOL_PRIVATE void _sg_gl_init_limits(void) {\n    _SG_GL_CHECK_ERROR();\n    GLint gl_int;\n    glGetIntegerv(GL_MAX_TEXTURE_SIZE, &gl_int);\n    _SG_GL_CHECK_ERROR();\n    _sg.limits.max_image_size_2d = gl_int;\n    _sg.limits.max_image_size_array = gl_int;\n    glGetIntegerv(GL_MAX_CUBE_MAP_TEXTURE_SIZE, &gl_int);\n    _SG_GL_CHECK_ERROR();\n    _sg.limits.max_image_size_cube = gl_int;\n    glGetIntegerv(GL_MAX_VERTEX_ATTRIBS, &gl_int);\n    _SG_GL_CHECK_ERROR();\n    if (gl_int > SG_MAX_VERTEX_ATTRIBUTES) {\n        gl_int = SG_MAX_VERTEX_ATTRIBUTES;\n    }\n    _sg.limits.max_vertex_attrs = gl_int;\n    glGetIntegerv(GL_MAX_VERTEX_UNIFORM_COMPONENTS, &gl_int);\n    _SG_GL_CHECK_ERROR();\n    _sg.limits.gl_max_vertex_uniform_components = gl_int;\n    glGetIntegerv(GL_MAX_3D_TEXTURE_SIZE, &gl_int);\n    _SG_GL_CHECK_ERROR();\n    _sg.limits.max_image_size_3d = gl_int;\n    glGetIntegerv(GL_MAX_ARRAY_TEXTURE_LAYERS, &gl_int);\n    _SG_GL_CHECK_ERROR();\n    _sg.limits.max_image_array_layers = gl_int;\n    if (_sg.gl.ext_anisotropic) {\n        glGetIntegerv(GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, &gl_int);\n        _SG_GL_CHECK_ERROR();\n        _sg.gl.max_anisotropy = gl_int;\n    } else {\n        _sg.gl.max_anisotropy = 1;\n    }\n    glGetIntegerv(GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS, &gl_int);\n    _SG_GL_CHECK_ERROR();\n    _sg.limits.gl_max_combined_texture_image_units = gl_int;\n}\n\n#if defined(SOKOL_GLCORE)\n_SOKOL_PRIVATE void _sg_gl_init_caps_glcore(void) {\n    _sg.backend = SG_BACKEND_GLCORE;\n\n    GLint major_version = 0;\n    GLint minor_version = 0;\n    glGetIntegerv(GL_MAJOR_VERSION, &major_version);\n    glGetIntegerv(GL_MINOR_VERSION, &minor_version);\n    const int version = major_version * 100 + minor_version * 10;\n    _sg.features.origin_top_left = false;\n    _sg.features.image_clamp_to_border = true;\n    _sg.features.mrt_independent_blend_state = false;\n    _sg.features.mrt_independent_write_mask = true;\n    _sg.features.storage_buffer = version >= 430;\n    #if defined(__APPLE__)\n    _sg.features.msaa_image_bindings = false;\n    #else\n    _sg.features.msaa_image_bindings = true;\n    #endif\n\n    // scan extensions\n    bool has_s3tc = false;  // BC1..BC3\n    bool has_rgtc = false;  // BC4 and BC5\n    bool has_bptc = false;  // BC6H and BC7\n    bool has_pvrtc = false;\n    bool has_etc2 = false;\n    bool has_astc = false;\n    GLint num_ext = 0;\n    glGetIntegerv(GL_NUM_EXTENSIONS, &num_ext);\n    for (int i = 0; i < num_ext; i++) {\n        const char* ext = (const char*) glGetStringi(GL_EXTENSIONS, (GLuint)i);\n        if (ext) {\n            if (strstr(ext, \"_texture_compression_s3tc\")) {\n                has_s3tc = true;\n            } else if (strstr(ext, \"_texture_compression_rgtc\")) {\n                has_rgtc = true;\n            } else if (strstr(ext, \"_texture_compression_bptc\")) {\n                has_bptc = true;\n            } else if (strstr(ext, \"_texture_compression_pvrtc\")) {\n                has_pvrtc = true;\n            } else if (strstr(ext, \"_ES3_compatibility\")) {\n                has_etc2 = true;\n            } else if (strstr(ext, \"_texture_filter_anisotropic\")) {\n                _sg.gl.ext_anisotropic = true;\n            } else if (strstr(ext, \"_texture_compression_astc_ldr\")) {\n                has_astc = true;\n            }\n        }\n    }\n\n    // limits\n    _sg_gl_init_limits();\n\n    // pixel formats\n    const bool has_bgra = false;    // not a bug\n    const bool has_colorbuffer_float = true;\n    const bool has_colorbuffer_half_float = true;\n    const bool has_texture_float_linear = true; // FIXME???\n    const bool has_float_blend = true;\n    _sg_gl_init_pixelformats(has_bgra);\n    _sg_gl_init_pixelformats_float(has_colorbuffer_float, has_texture_float_linear, has_float_blend);\n    _sg_gl_init_pixelformats_half_float(has_colorbuffer_half_float);\n    if (has_s3tc) {\n        _sg_gl_init_pixelformats_s3tc();\n    }\n    if (has_rgtc) {\n        _sg_gl_init_pixelformats_rgtc();\n    }\n    if (has_bptc) {\n        _sg_gl_init_pixelformats_bptc();\n    }\n    if (has_pvrtc) {\n        _sg_gl_init_pixelformats_pvrtc();\n    }\n    if (has_etc2) {\n        _sg_gl_init_pixelformats_etc2();\n    }\n    if (has_astc) {\n        _sg_gl_init_pixelformats_astc();\n    }\n}\n#endif\n\n#if defined(SOKOL_GLES3)\n_SOKOL_PRIVATE void _sg_gl_init_caps_gles3(void) {\n    _sg.backend = SG_BACKEND_GLES3;\n\n    _sg.features.origin_top_left = false;\n    _sg.features.image_clamp_to_border = false;\n    _sg.features.mrt_independent_blend_state = false;\n    _sg.features.mrt_independent_write_mask = false;\n    _sg.features.storage_buffer = false;\n    _sg.features.msaa_image_bindings = false;\n\n    bool has_s3tc = false;  // BC1..BC3\n    bool has_rgtc = false;  // BC4 and BC5\n    bool has_bptc = false;  // BC6H and BC7\n    bool has_pvrtc = false;\n    #if defined(__EMSCRIPTEN__)\n        bool has_etc2 = false;\n    #else\n        bool has_etc2 = true;\n    #endif\n    bool has_astc = false;\n    bool has_colorbuffer_float = false;\n    bool has_colorbuffer_half_float = false;\n    bool has_texture_float_linear = false;\n    bool has_float_blend = false;\n    GLint num_ext = 0;\n    glGetIntegerv(GL_NUM_EXTENSIONS, &num_ext);\n    for (int i = 0; i < num_ext; i++) {\n        const char* ext = (const char*) glGetStringi(GL_EXTENSIONS, (GLuint)i);\n        if (ext) {\n            if (strstr(ext, \"_texture_compression_s3tc\")) {\n                has_s3tc = true;\n            } else if (strstr(ext, \"_compressed_texture_s3tc\")) {\n                has_s3tc = true;\n            } else if (strstr(ext, \"_texture_compression_rgtc\")) {\n                has_rgtc = true;\n            } else if (strstr(ext, \"_texture_compression_bptc\")) {\n                has_bptc = true;\n            } else if (strstr(ext, \"_texture_compression_pvrtc\")) {\n                has_pvrtc = true;\n            } else if (strstr(ext, \"_compressed_texture_pvrtc\")) {\n                has_pvrtc = true;\n            } else if (strstr(ext, \"_compressed_texture_etc\")) {\n                has_etc2 = true;\n            } else if (strstr(ext, \"_compressed_texture_astc\")) {\n                has_astc = true;\n            } else if (strstr(ext, \"_color_buffer_float\")) {\n                has_colorbuffer_float = true;\n            } else if (strstr(ext, \"_color_buffer_half_float\")) {\n                has_colorbuffer_half_float = true;\n            } else if (strstr(ext, \"_texture_float_linear\")) {\n                has_texture_float_linear = true;\n            } else if (strstr(ext, \"_float_blend\")) {\n                has_float_blend = true;\n            } else if (strstr(ext, \"_texture_filter_anisotropic\")) {\n                _sg.gl.ext_anisotropic = true;\n            }\n        }\n    }\n\n    /* on WebGL2, color_buffer_float also includes 16-bit formats\n       see: https://developer.mozilla.org/en-US/docs/Web/API/EXT_color_buffer_float\n    */\n    #if defined(__EMSCRIPTEN__)\n    if (!has_colorbuffer_half_float && has_colorbuffer_float) {\n        has_colorbuffer_half_float = has_colorbuffer_float;\n    }\n    #endif\n\n    // limits\n    _sg_gl_init_limits();\n\n    // pixel formats\n    const bool has_bgra = false;    // not a bug\n    _sg_gl_init_pixelformats(has_bgra);\n    _sg_gl_init_pixelformats_float(has_colorbuffer_float, has_texture_float_linear, has_float_blend);\n    _sg_gl_init_pixelformats_half_float(has_colorbuffer_half_float);\n    if (has_s3tc) {\n        _sg_gl_init_pixelformats_s3tc();\n    }\n    if (has_rgtc) {\n        _sg_gl_init_pixelformats_rgtc();\n    }\n    if (has_bptc) {\n        _sg_gl_init_pixelformats_bptc();\n    }\n    if (has_pvrtc) {\n        _sg_gl_init_pixelformats_pvrtc();\n    }\n    if (has_etc2) {\n        _sg_gl_init_pixelformats_etc2();\n    }\n    if (has_astc) {\n        _sg_gl_init_pixelformats_astc();\n    }\n}\n#endif\n\n//-- state cache implementation ------------------------------------------------\n_SOKOL_PRIVATE void _sg_gl_cache_clear_buffer_bindings(bool force) {\n    if (force || (_sg.gl.cache.vertex_buffer != 0)) {\n        glBindBuffer(GL_ARRAY_BUFFER, 0);\n        _sg.gl.cache.vertex_buffer = 0;\n        _sg_stats_add(gl.num_bind_buffer, 1);\n    }\n    if (force || (_sg.gl.cache.index_buffer != 0)) {\n        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);\n        _sg.gl.cache.index_buffer = 0;\n        _sg_stats_add(gl.num_bind_buffer, 1);\n    }\n    if (force || (_sg.gl.cache.storage_buffer != 0)) {\n        if (_sg.features.storage_buffer) {\n            glBindBuffer(GL_SHADER_STORAGE_BUFFER, 0);\n        }\n        _sg.gl.cache.storage_buffer = 0;\n        _sg_stats_add(gl.num_bind_buffer, 1);\n    }\n    for (size_t i = 0; i < _SG_GL_MAX_SBUF_BINDINGS; i++) {\n        if (force || (_sg.gl.cache.storage_buffers[i] != 0)) {\n            if (_sg.features.storage_buffer) {\n                glBindBufferBase(GL_SHADER_STORAGE_BUFFER, (GLuint)i, 0);\n            }\n            _sg.gl.cache.storage_buffers[i] = 0;\n            _sg_stats_add(gl.num_bind_buffer, 1);\n        }\n    }\n}\n\n_SOKOL_PRIVATE void _sg_gl_cache_bind_buffer(GLenum target, GLuint buffer) {\n    SOKOL_ASSERT((GL_ARRAY_BUFFER == target) || (GL_ELEMENT_ARRAY_BUFFER == target) || (GL_SHADER_STORAGE_BUFFER == target));\n    if (target == GL_ARRAY_BUFFER) {\n        if (_sg.gl.cache.vertex_buffer != buffer) {\n            _sg.gl.cache.vertex_buffer = buffer;\n            glBindBuffer(target, buffer);\n            _sg_stats_add(gl.num_bind_buffer, 1);\n        }\n    } else if (target == GL_ELEMENT_ARRAY_BUFFER) {\n        if (_sg.gl.cache.index_buffer != buffer) {\n            _sg.gl.cache.index_buffer = buffer;\n            glBindBuffer(target, buffer);\n            _sg_stats_add(gl.num_bind_buffer, 1);\n        }\n    } else if (target == GL_SHADER_STORAGE_BUFFER) {\n        if (_sg.gl.cache.storage_buffer != buffer) {\n            _sg.gl.cache.storage_buffer = buffer;\n            if (_sg.features.storage_buffer) {\n                glBindBuffer(target, buffer);\n            }\n            _sg_stats_add(gl.num_bind_buffer, 1);\n        }\n    } else {\n        SOKOL_UNREACHABLE;\n    }\n}\n\n_SOKOL_PRIVATE void _sg_gl_cache_bind_storage_buffer(uint8_t glsl_binding_n, GLuint buffer) {\n    SOKOL_ASSERT(glsl_binding_n < _SG_GL_MAX_SBUF_BINDINGS);\n    if (_sg.gl.cache.storage_buffers[glsl_binding_n] != buffer) {\n        _sg.gl.cache.storage_buffers[glsl_binding_n] = buffer;\n        _sg.gl.cache.storage_buffer = buffer; // not a bug\n        if (_sg.features.storage_buffer) {\n            glBindBufferBase(GL_SHADER_STORAGE_BUFFER, glsl_binding_n, buffer);\n        }\n        _sg_stats_add(gl.num_bind_buffer, 1);\n    }\n}\n\n_SOKOL_PRIVATE void _sg_gl_cache_store_buffer_binding(GLenum target) {\n    if (target == GL_ARRAY_BUFFER) {\n        _sg.gl.cache.stored_vertex_buffer = _sg.gl.cache.vertex_buffer;\n    } else if (target == GL_ELEMENT_ARRAY_BUFFER) {\n        _sg.gl.cache.stored_index_buffer = _sg.gl.cache.index_buffer;\n    } else if (target == GL_SHADER_STORAGE_BUFFER) {\n        _sg.gl.cache.stored_storage_buffer = _sg.gl.cache.storage_buffer;\n    } else {\n        SOKOL_UNREACHABLE;\n    }\n}\n\n_SOKOL_PRIVATE void _sg_gl_cache_restore_buffer_binding(GLenum target) {\n    if (target == GL_ARRAY_BUFFER) {\n        if (_sg.gl.cache.stored_vertex_buffer != 0) {\n            // we only care about restoring valid ids\n            _sg_gl_cache_bind_buffer(target, _sg.gl.cache.stored_vertex_buffer);\n            _sg.gl.cache.stored_vertex_buffer = 0;\n        }\n    } else if (target == GL_ELEMENT_ARRAY_BUFFER) {\n        if (_sg.gl.cache.stored_index_buffer != 0) {\n            // we only care about restoring valid ids\n            _sg_gl_cache_bind_buffer(target, _sg.gl.cache.stored_index_buffer);\n            _sg.gl.cache.stored_index_buffer = 0;\n        }\n    } else if (target == GL_SHADER_STORAGE_BUFFER) {\n        if (_sg.gl.cache.stored_storage_buffer != 0) {\n            // we only care about restoring valid ids\n            _sg_gl_cache_bind_buffer(target, _sg.gl.cache.stored_storage_buffer);\n            _sg.gl.cache.stored_storage_buffer = 0;\n        }\n    } else {\n        SOKOL_UNREACHABLE;\n    }\n}\n\n// called from _sg_gl_discard_buffer()\n_SOKOL_PRIVATE void _sg_gl_cache_invalidate_buffer(GLuint buf) {\n    if (buf == _sg.gl.cache.vertex_buffer) {\n        _sg.gl.cache.vertex_buffer = 0;\n        glBindBuffer(GL_ARRAY_BUFFER, 0);\n        _sg_stats_add(gl.num_bind_buffer, 1);\n    }\n    if (buf == _sg.gl.cache.index_buffer) {\n        _sg.gl.cache.index_buffer = 0;\n        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);\n        _sg_stats_add(gl.num_bind_buffer, 1);\n    }\n    if (buf == _sg.gl.cache.storage_buffer) {\n        _sg.gl.cache.storage_buffer = 0;\n        glBindBuffer(GL_SHADER_STORAGE_BUFFER, 0);\n        _sg_stats_add(gl.num_bind_buffer, 1);\n    }\n    for (size_t i = 0; i < _SG_GL_MAX_SBUF_BINDINGS; i++) {\n        if (buf == _sg.gl.cache.storage_buffers[i]) {\n            _sg.gl.cache.storage_buffers[i] = 0;\n            _sg.gl.cache.storage_buffer = 0; // not a bug!\n            glBindBufferBase(GL_SHADER_STORAGE_BUFFER, (GLuint)i, 0);\n            _sg_stats_add(gl.num_bind_buffer, 1);\n        }\n    }\n    if (buf == _sg.gl.cache.stored_vertex_buffer) {\n        _sg.gl.cache.stored_vertex_buffer = 0;\n    }\n    if (buf == _sg.gl.cache.stored_index_buffer) {\n        _sg.gl.cache.stored_index_buffer = 0;\n    }\n    if (buf == _sg.gl.cache.stored_storage_buffer) {\n        _sg.gl.cache.stored_storage_buffer = 0;\n    }\n    for (int i = 0; i < SG_MAX_VERTEX_ATTRIBUTES; i++) {\n        if (buf == _sg.gl.cache.attrs[i].gl_vbuf) {\n            _sg.gl.cache.attrs[i].gl_vbuf = 0;\n        }\n    }\n}\n\n_SOKOL_PRIVATE void _sg_gl_cache_active_texture(GLenum texture) {\n    _SG_GL_CHECK_ERROR();\n    if (_sg.gl.cache.cur_active_texture != texture) {\n        _sg.gl.cache.cur_active_texture = texture;\n        glActiveTexture(texture);\n        _sg_stats_add(gl.num_active_texture, 1);\n    }\n    _SG_GL_CHECK_ERROR();\n}\n\n_SOKOL_PRIVATE void _sg_gl_cache_clear_texture_sampler_bindings(bool force) {\n    _SG_GL_CHECK_ERROR();\n    for (int i = 0; (i < _SG_GL_MAX_IMG_SMP_BINDINGS) && (i < _sg.limits.gl_max_combined_texture_image_units); i++) {\n        if (force || (_sg.gl.cache.texture_samplers[i].texture != 0)) {\n            GLenum gl_texture_unit = (GLenum) (GL_TEXTURE0 + i);\n            glActiveTexture(gl_texture_unit);\n            _sg_stats_add(gl.num_active_texture, 1);\n            glBindTexture(GL_TEXTURE_2D, 0);\n            glBindTexture(GL_TEXTURE_CUBE_MAP, 0);\n            glBindTexture(GL_TEXTURE_3D, 0);\n            glBindTexture(GL_TEXTURE_2D_ARRAY, 0);\n            _sg_stats_add(gl.num_bind_texture, 4);\n            glBindSampler((GLuint)i, 0);\n            _sg_stats_add(gl.num_bind_sampler, 1);\n            _sg.gl.cache.texture_samplers[i].target = 0;\n            _sg.gl.cache.texture_samplers[i].texture = 0;\n            _sg.gl.cache.texture_samplers[i].sampler = 0;\n            _sg.gl.cache.cur_active_texture = gl_texture_unit;\n        }\n    }\n    _SG_GL_CHECK_ERROR();\n}\n\n_SOKOL_PRIVATE void _sg_gl_cache_bind_texture_sampler(int8_t gl_tex_slot, GLenum target, GLuint texture, GLuint sampler) {\n    /* it's valid to call this function with target=0 and/or texture=0\n       target=0 will unbind the previous binding, texture=0 will clear\n       the new binding\n    */\n    SOKOL_ASSERT((gl_tex_slot >= 0) && (gl_tex_slot < _SG_GL_MAX_IMG_SMP_BINDINGS));\n    if (gl_tex_slot >= _sg.limits.gl_max_combined_texture_image_units) {\n        return;\n    }\n    _SG_GL_CHECK_ERROR();\n    _sg_gl_cache_texture_sampler_bind_slot* slot = &_sg.gl.cache.texture_samplers[gl_tex_slot];\n    if ((slot->target != target) || (slot->texture != texture) || (slot->sampler != sampler)) {\n        _sg_gl_cache_active_texture((GLenum)(GL_TEXTURE0 + gl_tex_slot));\n        // if the target has changed, clear the previous binding on that target\n        if ((target != slot->target) && (slot->target != 0)) {\n            glBindTexture(slot->target, 0);\n            _SG_GL_CHECK_ERROR();\n            _sg_stats_add(gl.num_bind_texture, 1);\n        }\n        // apply new binding (can be 0 to unbind)\n        if (target != 0) {\n            glBindTexture(target, texture);\n            _SG_GL_CHECK_ERROR();\n            _sg_stats_add(gl.num_bind_texture, 1);\n        }\n        // apply new sampler (can be 0 to unbind)\n        glBindSampler((GLuint)gl_tex_slot, sampler);\n        _SG_GL_CHECK_ERROR();\n        _sg_stats_add(gl.num_bind_sampler, 1);\n\n        slot->target = target;\n        slot->texture = texture;\n        slot->sampler = sampler;\n    }\n}\n\n_SOKOL_PRIVATE void _sg_gl_cache_store_texture_sampler_binding(int8_t gl_tex_slot) {\n    SOKOL_ASSERT((gl_tex_slot >= 0) && (gl_tex_slot < _SG_GL_MAX_IMG_SMP_BINDINGS));\n    _sg.gl.cache.stored_texture_sampler = _sg.gl.cache.texture_samplers[gl_tex_slot];\n}\n\n_SOKOL_PRIVATE void _sg_gl_cache_restore_texture_sampler_binding(int8_t gl_tex_slot) {\n    SOKOL_ASSERT((gl_tex_slot >= 0) && (gl_tex_slot < _SG_GL_MAX_IMG_SMP_BINDINGS));\n    _sg_gl_cache_texture_sampler_bind_slot* slot = &_sg.gl.cache.stored_texture_sampler;\n    if (slot->texture != 0) {\n        // we only care about restoring valid ids\n        SOKOL_ASSERT(slot->target != 0);\n        _sg_gl_cache_bind_texture_sampler(gl_tex_slot, slot->target, slot->texture, slot->sampler);\n        slot->target = 0;\n        slot->texture = 0;\n        slot->sampler = 0;\n    }\n}\n\n// called from _sg_gl_discard_texture() and _sg_gl_discard_sampler()\n_SOKOL_PRIVATE void _sg_gl_cache_invalidate_texture_sampler(GLuint tex, GLuint smp) {\n    _SG_GL_CHECK_ERROR();\n    for (size_t i = 0; i < _SG_GL_MAX_IMG_SMP_BINDINGS; i++) {\n        _sg_gl_cache_texture_sampler_bind_slot* slot = &_sg.gl.cache.texture_samplers[i];\n        if ((0 != slot->target) && ((tex == slot->texture) || (smp == slot->sampler))) {\n            _sg_gl_cache_active_texture((GLenum)(GL_TEXTURE0 + i));\n            glBindTexture(slot->target, 0);\n            _SG_GL_CHECK_ERROR();\n            _sg_stats_add(gl.num_bind_texture, 1);\n            glBindSampler((GLuint)i, 0);\n            _SG_GL_CHECK_ERROR();\n            _sg_stats_add(gl.num_bind_sampler, 1);\n            slot->target = 0;\n            slot->texture = 0;\n            slot->sampler = 0;\n        }\n    }\n    if ((tex == _sg.gl.cache.stored_texture_sampler.texture) || (smp == _sg.gl.cache.stored_texture_sampler.sampler)) {\n        _sg.gl.cache.stored_texture_sampler.target = 0;\n        _sg.gl.cache.stored_texture_sampler.texture = 0;\n        _sg.gl.cache.stored_texture_sampler.sampler = 0;\n    }\n}\n\n// called from _sg_gl_discard_shader()\n_SOKOL_PRIVATE void _sg_gl_cache_invalidate_program(GLuint prog) {\n    if (prog == _sg.gl.cache.prog) {\n        _sg.gl.cache.prog = 0;\n        glUseProgram(0);\n        _sg_stats_add(gl.num_use_program, 1);\n    }\n}\n\n// called from _sg_gl_discard_pipeline()\n_SOKOL_PRIVATE void _sg_gl_cache_invalidate_pipeline(_sg_pipeline_t* pip) {\n    if (pip == _sg.gl.cache.cur_pipeline) {\n        _sg.gl.cache.cur_pipeline = 0;\n        _sg.gl.cache.cur_pipeline_id.id = SG_INVALID_ID;\n    }\n}\n\n_SOKOL_PRIVATE void _sg_gl_reset_state_cache(void) {\n    _SG_GL_CHECK_ERROR();\n    glBindVertexArray(_sg.gl.vao);\n    _SG_GL_CHECK_ERROR();\n    _sg_clear(&_sg.gl.cache, sizeof(_sg.gl.cache));\n    _sg_gl_cache_clear_buffer_bindings(true);\n    _SG_GL_CHECK_ERROR();\n    _sg_gl_cache_clear_texture_sampler_bindings(true);\n    _SG_GL_CHECK_ERROR();\n    for (int i = 0; i < _sg.limits.max_vertex_attrs; i++) {\n        _sg_gl_attr_t* attr = &_sg.gl.cache.attrs[i].gl_attr;\n        attr->vb_index = -1;\n        attr->divisor = -1;\n        glDisableVertexAttribArray((GLuint)i);\n        _SG_GL_CHECK_ERROR();\n        _sg_stats_add(gl.num_disable_vertex_attrib_array, 1);\n    }\n    _sg.gl.cache.cur_primitive_type = GL_TRIANGLES;\n\n    // shader program\n    glGetIntegerv(GL_CURRENT_PROGRAM, (GLint*)&_sg.gl.cache.prog);\n    _SG_GL_CHECK_ERROR();\n\n    // depth and stencil state\n    _sg.gl.cache.depth.compare = SG_COMPAREFUNC_ALWAYS;\n    _sg.gl.cache.stencil.front.compare = SG_COMPAREFUNC_ALWAYS;\n    _sg.gl.cache.stencil.front.fail_op = SG_STENCILOP_KEEP;\n    _sg.gl.cache.stencil.front.depth_fail_op = SG_STENCILOP_KEEP;\n    _sg.gl.cache.stencil.front.pass_op = SG_STENCILOP_KEEP;\n    _sg.gl.cache.stencil.back.compare = SG_COMPAREFUNC_ALWAYS;\n    _sg.gl.cache.stencil.back.fail_op = SG_STENCILOP_KEEP;\n    _sg.gl.cache.stencil.back.depth_fail_op = SG_STENCILOP_KEEP;\n    _sg.gl.cache.stencil.back.pass_op = SG_STENCILOP_KEEP;\n    glEnable(GL_DEPTH_TEST);\n    glDepthFunc(GL_ALWAYS);\n    glDepthMask(GL_FALSE);\n    glDisable(GL_STENCIL_TEST);\n    glStencilFunc(GL_ALWAYS, 0, 0);\n    glStencilOp(GL_KEEP, GL_KEEP, GL_KEEP);\n    glStencilMask(0);\n    _sg_stats_add(gl.num_render_state, 7);\n\n    // blend state\n    _sg.gl.cache.blend.src_factor_rgb = SG_BLENDFACTOR_ONE;\n    _sg.gl.cache.blend.dst_factor_rgb = SG_BLENDFACTOR_ZERO;\n    _sg.gl.cache.blend.op_rgb = SG_BLENDOP_ADD;\n    _sg.gl.cache.blend.src_factor_alpha = SG_BLENDFACTOR_ONE;\n    _sg.gl.cache.blend.dst_factor_alpha = SG_BLENDFACTOR_ZERO;\n    _sg.gl.cache.blend.op_alpha = SG_BLENDOP_ADD;\n    glDisable(GL_BLEND);\n    glBlendFuncSeparate(GL_ONE, GL_ZERO, GL_ONE, GL_ZERO);\n    glBlendEquationSeparate(GL_FUNC_ADD, GL_FUNC_ADD);\n    glBlendColor(0.0f, 0.0f, 0.0f, 0.0f);\n    _sg_stats_add(gl.num_render_state, 4);\n\n    // standalone state\n    for (int i = 0; i < SG_MAX_COLOR_ATTACHMENTS; i++) {\n        _sg.gl.cache.color_write_mask[i] = SG_COLORMASK_RGBA;\n    }\n    _sg.gl.cache.cull_mode = SG_CULLMODE_NONE;\n    _sg.gl.cache.face_winding = SG_FACEWINDING_CW;\n    _sg.gl.cache.sample_count = 1;\n    glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);\n    glPolygonOffset(0.0f, 0.0f);\n    glDisable(GL_POLYGON_OFFSET_FILL);\n    glDisable(GL_CULL_FACE);\n    glFrontFace(GL_CW);\n    glCullFace(GL_BACK);\n    glEnable(GL_SCISSOR_TEST);\n    glDisable(GL_SAMPLE_ALPHA_TO_COVERAGE);\n    glEnable(GL_DITHER);\n    glDisable(GL_POLYGON_OFFSET_FILL);\n    _sg_stats_add(gl.num_render_state, 10);\n    #if defined(SOKOL_GLCORE)\n        glEnable(GL_MULTISAMPLE);\n        glEnable(GL_PROGRAM_POINT_SIZE);\n        _sg_stats_add(gl.num_render_state, 2);\n    #endif\n}\n\n_SOKOL_PRIVATE void _sg_gl_setup_backend(const sg_desc* desc) {\n    _SOKOL_UNUSED(desc);\n\n    // assumes that _sg.gl is already zero-initialized\n    _sg.gl.valid = true;\n\n    #if defined(_SOKOL_USE_WIN32_GL_LOADER)\n    _sg_gl_load_opengl();\n    #endif\n\n    // clear initial GL error state\n    #if defined(SOKOL_DEBUG)\n        while (glGetError() != GL_NO_ERROR);\n    #endif\n    #if defined(SOKOL_GLCORE)\n        _sg_gl_init_caps_glcore();\n    #elif defined(SOKOL_GLES3)\n        _sg_gl_init_caps_gles3();\n    #endif\n\n    glGenVertexArrays(1, &_sg.gl.vao);\n    glBindVertexArray(_sg.gl.vao);\n    _SG_GL_CHECK_ERROR();\n    // incoming texture data is generally expected to be packed tightly\n    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);\n    #if defined(SOKOL_GLCORE)\n        // enable seamless cubemap sampling (only desktop GL)\n        glEnable(GL_TEXTURE_CUBE_MAP_SEAMLESS);\n    #endif\n    _sg_gl_reset_state_cache();\n}\n\n_SOKOL_PRIVATE void _sg_gl_discard_backend(void) {\n    SOKOL_ASSERT(_sg.gl.valid);\n    if (_sg.gl.vao) {\n        glDeleteVertexArrays(1, &_sg.gl.vao);\n    }\n    #if defined(_SOKOL_USE_WIN32_GL_LOADER)\n    _sg_gl_unload_opengl();\n    #endif\n    _sg.gl.valid = false;\n}\n\n//-- GL backend resource creation and destruction ------------------------------\n_SOKOL_PRIVATE sg_resource_state _sg_gl_create_buffer(_sg_buffer_t* buf, const sg_buffer_desc* desc) {\n    SOKOL_ASSERT(buf && desc);\n    _SG_GL_CHECK_ERROR();\n    buf->gl.injected = (0 != desc->gl_buffers[0]);\n    const GLenum gl_target = _sg_gl_buffer_target(buf->cmn.type);\n    const GLenum gl_usage  = _sg_gl_usage(buf->cmn.usage);\n    for (int slot = 0; slot < buf->cmn.num_slots; slot++) {\n        GLuint gl_buf = 0;\n        if (buf->gl.injected) {\n            SOKOL_ASSERT(desc->gl_buffers[slot]);\n            gl_buf = desc->gl_buffers[slot];\n        } else {\n            glGenBuffers(1, &gl_buf);\n            SOKOL_ASSERT(gl_buf);\n            _sg_gl_cache_store_buffer_binding(gl_target);\n            _sg_gl_cache_bind_buffer(gl_target, gl_buf);\n            glBufferData(gl_target, buf->cmn.size, 0, gl_usage);\n            if (buf->cmn.usage == SG_USAGE_IMMUTABLE) {\n                SOKOL_ASSERT(desc->data.ptr);\n                glBufferSubData(gl_target, 0, buf->cmn.size, desc->data.ptr);\n            }\n            _sg_gl_cache_restore_buffer_binding(gl_target);\n        }\n        buf->gl.buf[slot] = gl_buf;\n    }\n    _SG_GL_CHECK_ERROR();\n    return SG_RESOURCESTATE_VALID;\n}\n\n_SOKOL_PRIVATE void _sg_gl_discard_buffer(_sg_buffer_t* buf) {\n    SOKOL_ASSERT(buf);\n    _SG_GL_CHECK_ERROR();\n    for (int slot = 0; slot < buf->cmn.num_slots; slot++) {\n        if (buf->gl.buf[slot]) {\n            _sg_gl_cache_invalidate_buffer(buf->gl.buf[slot]);\n            if (!buf->gl.injected) {\n                glDeleteBuffers(1, &buf->gl.buf[slot]);\n            }\n        }\n    }\n    _SG_GL_CHECK_ERROR();\n}\n\n_SOKOL_PRIVATE bool _sg_gl_supported_texture_format(sg_pixel_format fmt) {\n    const int fmt_index = (int) fmt;\n    SOKOL_ASSERT((fmt_index > SG_PIXELFORMAT_NONE) && (fmt_index < _SG_PIXELFORMAT_NUM));\n    return _sg.formats[fmt_index].sample;\n}\n\n_SOKOL_PRIVATE sg_resource_state _sg_gl_create_image(_sg_image_t* img, const sg_image_desc* desc) {\n    SOKOL_ASSERT(img && desc);\n    _SG_GL_CHECK_ERROR();\n    const bool msaa = img->cmn.sample_count > 1;\n    img->gl.injected = (0 != desc->gl_textures[0]);\n\n    // check if texture format is support\n    if (!_sg_gl_supported_texture_format(img->cmn.pixel_format)) {\n        _SG_ERROR(GL_TEXTURE_FORMAT_NOT_SUPPORTED);\n        return SG_RESOURCESTATE_FAILED;\n    }\n    const GLenum gl_internal_format = _sg_gl_teximage_internal_format(img->cmn.pixel_format);\n\n    // GLES3/WebGL2/macOS doesn't have support for multisampled textures, so create a render buffer object instead\n    if (!_sg.features.msaa_image_bindings && img->cmn.render_target && msaa) {\n        glGenRenderbuffers(1, &img->gl.msaa_render_buffer);\n        glBindRenderbuffer(GL_RENDERBUFFER, img->gl.msaa_render_buffer);\n        glRenderbufferStorageMultisample(GL_RENDERBUFFER, img->cmn.sample_count, gl_internal_format, img->cmn.width, img->cmn.height);\n    } else if (img->gl.injected) {\n        img->gl.target = _sg_gl_texture_target(img->cmn.type, img->cmn.sample_count);\n        // inject externally GL textures\n        for (int slot = 0; slot < img->cmn.num_slots; slot++) {\n            SOKOL_ASSERT(desc->gl_textures[slot]);\n            img->gl.tex[slot] = desc->gl_textures[slot];\n        }\n        if (desc->gl_texture_target) {\n            img->gl.target = (GLenum)desc->gl_texture_target;\n        }\n    } else {\n        // create our own GL texture(s)\n        img->gl.target = _sg_gl_texture_target(img->cmn.type, img->cmn.sample_count);\n        const GLenum gl_format = _sg_gl_teximage_format(img->cmn.pixel_format);\n        const bool is_compressed = _sg_is_compressed_pixel_format(img->cmn.pixel_format);\n        for (int slot = 0; slot < img->cmn.num_slots; slot++) {\n            glGenTextures(1, &img->gl.tex[slot]);\n            SOKOL_ASSERT(img->gl.tex[slot]);\n            _sg_gl_cache_store_texture_sampler_binding(0);\n            _sg_gl_cache_bind_texture_sampler(0, img->gl.target, img->gl.tex[slot], 0);\n            glTexParameteri(img->gl.target, GL_TEXTURE_MAX_LEVEL, img->cmn.num_mipmaps - 1);\n\n            // NOTE: workaround for https://issues.chromium.org/issues/355605685\n            // FIXME: on GLES3 and GL 4.3 (e.g. not macOS) the texture initialization\n            // should be rewritten to use glTexStorage + glTexSubImage\n            bool tex_storage_allocated = false;\n            #if defined(__EMSCRIPTEN__)\n                if (desc->data.subimage[0][0].ptr == 0) {\n                    SOKOL_ASSERT(!msaa);\n                    tex_storage_allocated = true;\n                    if ((SG_IMAGETYPE_2D == img->cmn.type) || (SG_IMAGETYPE_CUBE == img->cmn.type)) {\n                        glTexStorage2D(img->gl.target, img->cmn.num_mipmaps, gl_internal_format, img->cmn.width, img->cmn.height);\n                    } else if ((SG_IMAGETYPE_3D == img->cmn.type) || (SG_IMAGETYPE_ARRAY == img->cmn.type)) {\n                        glTexStorage3D(img->gl.target, img->cmn.num_mipmaps, gl_internal_format, img->cmn.width, img->cmn.height, img->cmn.num_slices);\n                    }\n                }\n            #endif\n            if (!tex_storage_allocated) {\n                const int num_faces = img->cmn.type == SG_IMAGETYPE_CUBE ? 6 : 1;\n                int data_index = 0;\n                for (int face_index = 0; face_index < num_faces; face_index++) {\n                    for (int mip_index = 0; mip_index < img->cmn.num_mipmaps; mip_index++, data_index++) {\n                        GLenum gl_img_target = img->gl.target;\n                        if (SG_IMAGETYPE_CUBE == img->cmn.type) {\n                            gl_img_target = _sg_gl_cubeface_target(face_index);\n                        }\n                        const GLvoid* data_ptr = desc->data.subimage[face_index][mip_index].ptr;\n                        const int mip_width = _sg_miplevel_dim(img->cmn.width, mip_index);\n                        const int mip_height = _sg_miplevel_dim(img->cmn.height, mip_index);\n                        if ((SG_IMAGETYPE_2D == img->cmn.type) || (SG_IMAGETYPE_CUBE == img->cmn.type)) {\n                            if (is_compressed) {\n                                SOKOL_ASSERT(!msaa);\n                                const GLsizei data_size = (GLsizei) desc->data.subimage[face_index][mip_index].size;\n                                glCompressedTexImage2D(gl_img_target, mip_index, gl_internal_format,\n                                    mip_width, mip_height, 0, data_size, data_ptr);\n                            } else {\n                                const GLenum gl_type = _sg_gl_teximage_type(img->cmn.pixel_format);\n                                #if defined(SOKOL_GLCORE) && !defined(__APPLE__)\n                                    if (msaa) {\n                                        glTexImage2DMultisample(gl_img_target, img->cmn.sample_count, gl_internal_format,\n                                            mip_width, mip_height, GL_TRUE);\n                                    } else {\n                                        glTexImage2D(gl_img_target, mip_index, (GLint)gl_internal_format,\n                                            mip_width, mip_height, 0, gl_format, gl_type, data_ptr);\n                                    }\n                                #else\n                                    SOKOL_ASSERT(!msaa);\n                                    glTexImage2D(gl_img_target, mip_index, (GLint)gl_internal_format,\n                                        mip_width, mip_height, 0, gl_format, gl_type, data_ptr);\n                                #endif\n                            }\n                        } else if ((SG_IMAGETYPE_3D == img->cmn.type) || (SG_IMAGETYPE_ARRAY == img->cmn.type)) {\n                            int mip_depth = img->cmn.num_slices;\n                            if (SG_IMAGETYPE_3D == img->cmn.type) {\n                                mip_depth = _sg_miplevel_dim(mip_depth, mip_index);\n                            }\n                            if (is_compressed) {\n                                SOKOL_ASSERT(!msaa);\n                                const GLsizei data_size = (GLsizei) desc->data.subimage[face_index][mip_index].size;\n                                glCompressedTexImage3D(gl_img_target, mip_index, gl_internal_format,\n                                    mip_width, mip_height, mip_depth, 0, data_size, data_ptr);\n                            } else {\n                                const GLenum gl_type = _sg_gl_teximage_type(img->cmn.pixel_format);\n                                #if defined(SOKOL_GLCORE) && !defined(__APPLE__)\n                                    if (msaa) {\n                                        // NOTE: only for array textures, not actual 3D textures!\n                                        glTexImage3DMultisample(gl_img_target, img->cmn.sample_count, gl_internal_format,\n                                            mip_width, mip_height, mip_depth, GL_TRUE);\n                                    } else {\n                                        glTexImage3D(gl_img_target, mip_index, (GLint)gl_internal_format,\n                                            mip_width, mip_height, mip_depth, 0, gl_format, gl_type, data_ptr);\n                                    }\n                                #else\n                                    SOKOL_ASSERT(!msaa);\n                                    glTexImage3D(gl_img_target, mip_index, (GLint)gl_internal_format,\n                                        mip_width, mip_height, mip_depth, 0, gl_format, gl_type, data_ptr);\n                                #endif\n                            }\n                        }\n                    }\n                }\n            }\n            _sg_gl_cache_restore_texture_sampler_binding(0);\n        }\n    }\n    _SG_GL_CHECK_ERROR();\n    return SG_RESOURCESTATE_VALID;\n}\n\n_SOKOL_PRIVATE void _sg_gl_discard_image(_sg_image_t* img) {\n    SOKOL_ASSERT(img);\n    _SG_GL_CHECK_ERROR();\n    for (int slot = 0; slot < img->cmn.num_slots; slot++) {\n        if (img->gl.tex[slot]) {\n            _sg_gl_cache_invalidate_texture_sampler(img->gl.tex[slot], 0);\n            if (!img->gl.injected) {\n                glDeleteTextures(1, &img->gl.tex[slot]);\n            }\n        }\n    }\n    if (img->gl.msaa_render_buffer) {\n        glDeleteRenderbuffers(1, &img->gl.msaa_render_buffer);\n    }\n    _SG_GL_CHECK_ERROR();\n}\n\n_SOKOL_PRIVATE sg_resource_state _sg_gl_create_sampler(_sg_sampler_t* smp, const sg_sampler_desc* desc) {\n    SOKOL_ASSERT(smp && desc);\n    _SG_GL_CHECK_ERROR();\n    smp->gl.injected = (0 != desc->gl_sampler);\n    if (smp->gl.injected) {\n        smp->gl.smp = (GLuint) desc->gl_sampler;\n    } else {\n        glGenSamplers(1, &smp->gl.smp);\n        SOKOL_ASSERT(smp->gl.smp);\n\n        const GLenum gl_min_filter = _sg_gl_min_filter(smp->cmn.min_filter, smp->cmn.mipmap_filter);\n        const GLenum gl_mag_filter = _sg_gl_mag_filter(smp->cmn.mag_filter);\n        glSamplerParameteri(smp->gl.smp, GL_TEXTURE_MIN_FILTER, (GLint)gl_min_filter);\n        glSamplerParameteri(smp->gl.smp, GL_TEXTURE_MAG_FILTER, (GLint)gl_mag_filter);\n        // GL spec has strange defaults for mipmap min/max lod: -1000 to +1000\n        const float min_lod = _sg_clamp(desc->min_lod, 0.0f, 1000.0f);\n        const float max_lod = _sg_clamp(desc->max_lod, 0.0f, 1000.0f);\n        glSamplerParameterf(smp->gl.smp, GL_TEXTURE_MIN_LOD, min_lod);\n        glSamplerParameterf(smp->gl.smp, GL_TEXTURE_MAX_LOD, max_lod);\n        glSamplerParameteri(smp->gl.smp, GL_TEXTURE_WRAP_S, (GLint)_sg_gl_wrap(smp->cmn.wrap_u));\n        glSamplerParameteri(smp->gl.smp, GL_TEXTURE_WRAP_T, (GLint)_sg_gl_wrap(smp->cmn.wrap_v));\n        glSamplerParameteri(smp->gl.smp, GL_TEXTURE_WRAP_R, (GLint)_sg_gl_wrap(smp->cmn.wrap_w));\n        #if defined(SOKOL_GLCORE)\n        float border[4];\n        switch (smp->cmn.border_color) {\n            case SG_BORDERCOLOR_TRANSPARENT_BLACK:\n                border[0] = 0.0f; border[1] = 0.0f; border[2] = 0.0f; border[3] = 0.0f;\n                break;\n            case SG_BORDERCOLOR_OPAQUE_WHITE:\n                border[0] = 1.0f; border[1] = 1.0f; border[2] = 1.0f; border[3] = 1.0f;\n                break;\n            default:\n                border[0] = 0.0f; border[1] = 0.0f; border[2] = 0.0f; border[3] = 1.0f;\n                break;\n        }\n        glSamplerParameterfv(smp->gl.smp, GL_TEXTURE_BORDER_COLOR, border);\n        #endif\n        if (smp->cmn.compare != SG_COMPAREFUNC_NEVER) {\n            glSamplerParameteri(smp->gl.smp, GL_TEXTURE_COMPARE_MODE, GL_COMPARE_REF_TO_TEXTURE);\n            glSamplerParameteri(smp->gl.smp, GL_TEXTURE_COMPARE_FUNC, (GLint)_sg_gl_compare_func(smp->cmn.compare));\n        } else {\n            glSamplerParameteri(smp->gl.smp, GL_TEXTURE_COMPARE_MODE, GL_NONE);\n        }\n        if (_sg.gl.ext_anisotropic && (smp->cmn.max_anisotropy > 1)) {\n            GLint max_aniso = (GLint) smp->cmn.max_anisotropy;\n            if (max_aniso > _sg.gl.max_anisotropy) {\n                max_aniso = _sg.gl.max_anisotropy;\n            }\n            glSamplerParameteri(smp->gl.smp, GL_TEXTURE_MAX_ANISOTROPY_EXT, max_aniso);\n        }\n    }\n    _SG_GL_CHECK_ERROR();\n    return SG_RESOURCESTATE_VALID;\n}\n\n_SOKOL_PRIVATE void _sg_gl_discard_sampler(_sg_sampler_t* smp) {\n    SOKOL_ASSERT(smp);\n    _SG_GL_CHECK_ERROR();\n    _sg_gl_cache_invalidate_texture_sampler(0, smp->gl.smp);\n    if (!smp->gl.injected) {\n        glDeleteSamplers(1, &smp->gl.smp);\n    }\n    _SG_GL_CHECK_ERROR();\n}\n\n_SOKOL_PRIVATE GLuint _sg_gl_compile_shader(sg_shader_stage stage, const char* src) {\n    SOKOL_ASSERT(src);\n    _SG_GL_CHECK_ERROR();\n    GLuint gl_shd = glCreateShader(_sg_gl_shader_stage(stage));\n    glShaderSource(gl_shd, 1, &src, 0);\n    glCompileShader(gl_shd);\n    GLint compile_status = 0;\n    glGetShaderiv(gl_shd, GL_COMPILE_STATUS, &compile_status);\n    if (!compile_status) {\n        // compilation failed, log error and delete shader\n        GLint log_len = 0;\n        glGetShaderiv(gl_shd, GL_INFO_LOG_LENGTH, &log_len);\n        if (log_len > 0) {\n            GLchar* log_buf = (GLchar*) _sg_malloc((size_t)log_len);\n            glGetShaderInfoLog(gl_shd, log_len, &log_len, log_buf);\n            _SG_ERROR(GL_SHADER_COMPILATION_FAILED);\n            _SG_LOGMSG(GL_SHADER_COMPILATION_FAILED, log_buf);\n            _sg_free(log_buf);\n        }\n        glDeleteShader(gl_shd);\n        gl_shd = 0;\n    }\n    _SG_GL_CHECK_ERROR();\n    return gl_shd;\n}\n\n_SOKOL_PRIVATE sg_resource_state _sg_gl_create_shader(_sg_shader_t* shd, const sg_shader_desc* desc) {\n    SOKOL_ASSERT(shd && desc);\n    SOKOL_ASSERT(!shd->gl.prog);\n    _SG_GL_CHECK_ERROR();\n\n    // copy the optional vertex attribute names over\n    for (int i = 0; i < SG_MAX_VERTEX_ATTRIBUTES; i++) {\n        _sg_strcpy(&shd->gl.attrs[i].name, desc->attrs[i].glsl_name);\n    }\n\n    GLuint gl_vs = _sg_gl_compile_shader(SG_SHADERSTAGE_VERTEX, desc->vertex_func.source);\n    GLuint gl_fs = _sg_gl_compile_shader(SG_SHADERSTAGE_FRAGMENT, desc->fragment_func.source);\n    if (!(gl_vs && gl_fs)) {\n        return SG_RESOURCESTATE_FAILED;\n    }\n    GLuint gl_prog = glCreateProgram();\n    glAttachShader(gl_prog, gl_vs);\n    glAttachShader(gl_prog, gl_fs);\n    glLinkProgram(gl_prog);\n    glDeleteShader(gl_vs);\n    glDeleteShader(gl_fs);\n    _SG_GL_CHECK_ERROR();\n\n    GLint link_status;\n    glGetProgramiv(gl_prog, GL_LINK_STATUS, &link_status);\n    if (!link_status) {\n        GLint log_len = 0;\n        glGetProgramiv(gl_prog, GL_INFO_LOG_LENGTH, &log_len);\n        if (log_len > 0) {\n            GLchar* log_buf = (GLchar*) _sg_malloc((size_t)log_len);\n            glGetProgramInfoLog(gl_prog, log_len, &log_len, log_buf);\n            _SG_ERROR(GL_SHADER_LINKING_FAILED);\n            _SG_LOGMSG(GL_SHADER_LINKING_FAILED, log_buf);\n            _sg_free(log_buf);\n        }\n        glDeleteProgram(gl_prog);\n        return SG_RESOURCESTATE_FAILED;\n    }\n    shd->gl.prog = gl_prog;\n\n    // resolve uniforms\n    _SG_GL_CHECK_ERROR();\n    for (size_t ub_index = 0; ub_index < SG_MAX_UNIFORMBLOCK_BINDSLOTS; ub_index++) {\n        const sg_shader_uniform_block* ub_desc = &desc->uniform_blocks[ub_index];\n        if (ub_desc->stage == SG_SHADERSTAGE_NONE) {\n            continue;\n        }\n        SOKOL_ASSERT(ub_desc->size > 0);\n        _sg_gl_uniform_block_t* ub = &shd->gl.uniform_blocks[ub_index];\n        SOKOL_ASSERT(ub->num_uniforms == 0);\n        uint32_t cur_uniform_offset = 0;\n        for (int u_index = 0; u_index < SG_MAX_UNIFORMBLOCK_MEMBERS; u_index++) {\n            const sg_glsl_shader_uniform* u_desc = &ub_desc->glsl_uniforms[u_index];\n            if (u_desc->type == SG_UNIFORMTYPE_INVALID) {\n                break;\n            }\n            const uint32_t u_align = _sg_uniform_alignment(u_desc->type, u_desc->array_count, ub_desc->layout);\n            const uint32_t u_size = _sg_uniform_size(u_desc->type, u_desc->array_count, ub_desc->layout);\n            cur_uniform_offset = _sg_align_u32(cur_uniform_offset, u_align);\n            _sg_gl_uniform_t* u = &ub->uniforms[u_index];\n            u->type = u_desc->type;\n            u->count = (uint16_t) u_desc->array_count;\n            u->offset = (uint16_t) cur_uniform_offset;\n            SOKOL_ASSERT(u_desc->glsl_name);\n            u->gl_loc = glGetUniformLocation(gl_prog, u_desc->glsl_name);\n            if (u->gl_loc == -1) {\n                _SG_WARN(GL_UNIFORMBLOCK_NAME_NOT_FOUND_IN_SHADER);\n                _SG_LOGMSG(GL_UNIFORMBLOCK_NAME_NOT_FOUND_IN_SHADER, u_desc->glsl_name);\n            }\n            cur_uniform_offset += u_size;\n            ub->num_uniforms++;\n        }\n        if (ub_desc->layout == SG_UNIFORMLAYOUT_STD140) {\n            cur_uniform_offset = _sg_align_u32(cur_uniform_offset, 16);\n        }\n        SOKOL_ASSERT(ub_desc->size == (size_t)cur_uniform_offset);\n        _SOKOL_UNUSED(cur_uniform_offset);\n    }\n\n    // copy storage buffer bind slots\n    for (size_t sbuf_index = 0; sbuf_index < SG_MAX_STORAGEBUFFER_BINDSLOTS; sbuf_index++) {\n        const sg_shader_storage_buffer* sbuf_desc = &desc->storage_buffers[sbuf_index];\n        if (sbuf_desc->stage == SG_SHADERSTAGE_NONE) {\n            continue;\n        }\n        SOKOL_ASSERT(sbuf_desc->glsl_binding_n < _SG_GL_MAX_SBUF_BINDINGS);\n        shd->gl.sbuf_binding[sbuf_index] = sbuf_desc->glsl_binding_n;\n    }\n\n    // record image sampler location in shader program\n    _SG_GL_CHECK_ERROR();\n    GLuint cur_prog = 0;\n    glGetIntegerv(GL_CURRENT_PROGRAM, (GLint*)&cur_prog);\n    glUseProgram(gl_prog);\n    GLint gl_tex_slot = 0;\n    for (size_t img_smp_index = 0; img_smp_index < SG_MAX_IMAGE_SAMPLER_PAIRS; img_smp_index++) {\n        const sg_shader_image_sampler_pair* img_smp_desc = &desc->image_sampler_pairs[img_smp_index];\n        if (img_smp_desc->stage == SG_SHADERSTAGE_NONE) {\n            continue;\n        }\n        SOKOL_ASSERT(img_smp_desc->glsl_name);\n        GLint gl_loc = glGetUniformLocation(gl_prog, img_smp_desc->glsl_name);\n        if (gl_loc != -1) {\n            glUniform1i(gl_loc, gl_tex_slot);\n            shd->gl.tex_slot[img_smp_index] = (int8_t)gl_tex_slot++;\n        } else {\n            shd->gl.tex_slot[img_smp_index] = -1;\n            _SG_WARN(GL_IMAGE_SAMPLER_NAME_NOT_FOUND_IN_SHADER);\n            _SG_LOGMSG(GL_IMAGE_SAMPLER_NAME_NOT_FOUND_IN_SHADER, img_smp_desc->glsl_name);\n        }\n    }\n\n    // it's legal to call glUseProgram with 0\n    glUseProgram(cur_prog);\n    _SG_GL_CHECK_ERROR();\n    return SG_RESOURCESTATE_VALID;\n}\n\n_SOKOL_PRIVATE void _sg_gl_discard_shader(_sg_shader_t* shd) {\n    SOKOL_ASSERT(shd);\n    _SG_GL_CHECK_ERROR();\n    if (shd->gl.prog) {\n        _sg_gl_cache_invalidate_program(shd->gl.prog);\n        glDeleteProgram(shd->gl.prog);\n    }\n    _SG_GL_CHECK_ERROR();\n}\n\n_SOKOL_PRIVATE sg_resource_state _sg_gl_create_pipeline(_sg_pipeline_t* pip, _sg_shader_t* shd, const sg_pipeline_desc* desc) {\n    SOKOL_ASSERT(pip && shd && desc);\n    SOKOL_ASSERT((pip->shader == 0) && (pip->cmn.shader_id.id != SG_INVALID_ID));\n    SOKOL_ASSERT(desc->shader.id == shd->slot.id);\n    SOKOL_ASSERT(shd->gl.prog);\n    SOKOL_ASSERT(_sg.limits.max_vertex_attrs <= SG_MAX_VERTEX_ATTRIBUTES);\n    pip->shader = shd;\n    pip->gl.primitive_type = desc->primitive_type;\n    pip->gl.depth = desc->depth;\n    pip->gl.stencil = desc->stencil;\n    // FIXME: blend color and write mask per draw-buffer-attachment (requires GL4)\n    pip->gl.blend = desc->colors[0].blend;\n    for (int i = 0; i < SG_MAX_COLOR_ATTACHMENTS; i++) {\n        pip->gl.color_write_mask[i] = desc->colors[i].write_mask;\n    }\n    pip->gl.cull_mode = desc->cull_mode;\n    pip->gl.face_winding = desc->face_winding;\n    pip->gl.sample_count = desc->sample_count;\n    pip->gl.alpha_to_coverage_enabled = desc->alpha_to_coverage_enabled;\n\n    // NOTE: GLSL compilers may remove unused vertex attributes so we can't rely\n    // on the 'prepopulated' vertex_buffer_layout_active[] state and need to\n    // fill this array from scratch with the actual info after GLSL compilation\n    for (int i = 0; i < SG_MAX_VERTEXBUFFER_BINDSLOTS; i++) {\n        pip->cmn.vertex_buffer_layout_active[i] = false;\n    }\n\n    // resolve vertex attributes\n    for (int attr_index = 0; attr_index < SG_MAX_VERTEX_ATTRIBUTES; attr_index++) {\n        pip->gl.attrs[attr_index].vb_index = -1;\n    }\n    for (int attr_index = 0; attr_index < _sg.limits.max_vertex_attrs; attr_index++) {\n        const sg_vertex_attr_state* a_state = &desc->layout.attrs[attr_index];\n        if (a_state->format == SG_VERTEXFORMAT_INVALID) {\n            break;\n        }\n        SOKOL_ASSERT(a_state->buffer_index < SG_MAX_VERTEXBUFFER_BINDSLOTS);\n        const sg_vertex_buffer_layout_state* l_state = &desc->layout.buffers[a_state->buffer_index];\n        const sg_vertex_step step_func = l_state->step_func;\n        const int step_rate = l_state->step_rate;\n        GLint attr_loc = attr_index;\n        if (!_sg_strempty(&shd->gl.attrs[attr_index].name)) {\n            attr_loc = glGetAttribLocation(pip->shader->gl.prog, _sg_strptr(&shd->gl.attrs[attr_index].name));\n        }\n        if (attr_loc != -1) {\n            SOKOL_ASSERT(attr_loc < (GLint)_sg.limits.max_vertex_attrs);\n            _sg_gl_attr_t* gl_attr = &pip->gl.attrs[attr_loc];\n            SOKOL_ASSERT(gl_attr->vb_index == -1);\n            gl_attr->vb_index = (int8_t) a_state->buffer_index;\n            if (step_func == SG_VERTEXSTEP_PER_VERTEX) {\n                gl_attr->divisor = 0;\n            } else {\n                gl_attr->divisor = (int8_t) step_rate;\n                pip->cmn.use_instanced_draw = true;\n            }\n            SOKOL_ASSERT(l_state->stride > 0);\n            gl_attr->stride = (uint8_t) l_state->stride;\n            gl_attr->offset = a_state->offset;\n            gl_attr->size = (uint8_t) _sg_gl_vertexformat_size(a_state->format);\n            gl_attr->type = _sg_gl_vertexformat_type(a_state->format);\n            gl_attr->normalized = _sg_gl_vertexformat_normalized(a_state->format);\n            pip->cmn.vertex_buffer_layout_active[a_state->buffer_index] = true;\n        } else {\n            _SG_WARN(GL_VERTEX_ATTRIBUTE_NOT_FOUND_IN_SHADER);\n            _SG_LOGMSG(GL_VERTEX_ATTRIBUTE_NOT_FOUND_IN_SHADER, _sg_strptr(&shd->gl.attrs[attr_index].name));\n        }\n    }\n    return SG_RESOURCESTATE_VALID;\n}\n\n_SOKOL_PRIVATE void _sg_gl_discard_pipeline(_sg_pipeline_t* pip) {\n    SOKOL_ASSERT(pip);\n    _sg_gl_cache_invalidate_pipeline(pip);\n}\n\n_SOKOL_PRIVATE void _sg_gl_fb_attach_texture(const _sg_gl_attachment_t* gl_att, const _sg_attachment_common_t* cmn_att, GLenum gl_att_type) {\n    const _sg_image_t* img = gl_att->image;\n    SOKOL_ASSERT(img);\n    const GLuint gl_tex = img->gl.tex[0];\n    SOKOL_ASSERT(gl_tex);\n    const GLuint gl_target = img->gl.target;\n    SOKOL_ASSERT(gl_target);\n    const int mip_level = cmn_att->mip_level;\n    const int slice = cmn_att->slice;\n    switch (img->cmn.type) {\n        case SG_IMAGETYPE_2D:\n            glFramebufferTexture2D(GL_FRAMEBUFFER, gl_att_type, gl_target, gl_tex, mip_level);\n            break;\n        case SG_IMAGETYPE_CUBE:\n            glFramebufferTexture2D(GL_FRAMEBUFFER, gl_att_type, _sg_gl_cubeface_target(slice), gl_tex, mip_level);\n            break;\n        default:\n            glFramebufferTextureLayer(GL_FRAMEBUFFER, gl_att_type, gl_tex, mip_level, slice);\n            break;\n    }\n}\n\n_SOKOL_PRIVATE GLenum _sg_gl_depth_stencil_attachment_type(const _sg_gl_attachment_t* ds_att) {\n    const _sg_image_t* img = ds_att->image;\n    SOKOL_ASSERT(img);\n    if (_sg_is_depth_stencil_format(img->cmn.pixel_format)) {\n        return GL_DEPTH_STENCIL_ATTACHMENT;\n    } else {\n        return GL_DEPTH_ATTACHMENT;\n    }\n}\n\n_SOKOL_PRIVATE sg_resource_state _sg_gl_create_attachments(_sg_attachments_t* atts, _sg_image_t** color_images, _sg_image_t** resolve_images, _sg_image_t* ds_image, const sg_attachments_desc* desc) {\n    SOKOL_ASSERT(atts && desc);\n    SOKOL_ASSERT(color_images && resolve_images);\n    _SG_GL_CHECK_ERROR();\n\n    // copy image pointers\n    for (int i = 0; i < atts->cmn.num_colors; i++) {\n        const sg_attachment_desc* color_desc = &desc->colors[i];\n        _SOKOL_UNUSED(color_desc);\n        SOKOL_ASSERT(color_desc->image.id != SG_INVALID_ID);\n        SOKOL_ASSERT(0 == atts->gl.colors[i].image);\n        SOKOL_ASSERT(color_images[i] && (color_images[i]->slot.id == color_desc->image.id));\n        SOKOL_ASSERT(_sg_is_valid_rendertarget_color_format(color_images[i]->cmn.pixel_format));\n        atts->gl.colors[i].image = color_images[i];\n\n        const sg_attachment_desc* resolve_desc = &desc->resolves[i];\n        if (resolve_desc->image.id != SG_INVALID_ID) {\n            SOKOL_ASSERT(0 == atts->gl.resolves[i].image);\n            SOKOL_ASSERT(resolve_images[i] && (resolve_images[i]->slot.id == resolve_desc->image.id));\n            SOKOL_ASSERT(color_images[i] && (color_images[i]->cmn.pixel_format == resolve_images[i]->cmn.pixel_format));\n            atts->gl.resolves[i].image = resolve_images[i];\n        }\n    }\n    SOKOL_ASSERT(0 == atts->gl.depth_stencil.image);\n    const sg_attachment_desc* ds_desc = &desc->depth_stencil;\n    if (ds_desc->image.id != SG_INVALID_ID) {\n        SOKOL_ASSERT(ds_image && (ds_image->slot.id == ds_desc->image.id));\n        SOKOL_ASSERT(_sg_is_valid_rendertarget_depth_format(ds_image->cmn.pixel_format));\n        atts->gl.depth_stencil.image = ds_image;\n    }\n\n    // store current framebuffer binding (restored at end of function)\n    GLuint gl_orig_fb;\n    glGetIntegerv(GL_FRAMEBUFFER_BINDING, (GLint*)&gl_orig_fb);\n\n    // create a framebuffer object\n    glGenFramebuffers(1, &atts->gl.fb);\n    glBindFramebuffer(GL_FRAMEBUFFER, atts->gl.fb);\n\n    // attach color attachments to framebuffer\n    for (int i = 0; i < atts->cmn.num_colors; i++) {\n        const _sg_image_t* color_img = atts->gl.colors[i].image;\n        SOKOL_ASSERT(color_img);\n        const GLuint gl_msaa_render_buffer = color_img->gl.msaa_render_buffer;\n        if (gl_msaa_render_buffer) {\n            glFramebufferRenderbuffer(GL_FRAMEBUFFER, (GLenum)(GL_COLOR_ATTACHMENT0+i), GL_RENDERBUFFER, gl_msaa_render_buffer);\n        } else {\n            const GLenum gl_att_type = (GLenum)(GL_COLOR_ATTACHMENT0 + i);\n            _sg_gl_fb_attach_texture(&atts->gl.colors[i], &atts->cmn.colors[i], gl_att_type);\n        }\n    }\n    // attach depth-stencil attachment\n    if (atts->gl.depth_stencil.image) {\n        const GLenum gl_att = _sg_gl_depth_stencil_attachment_type(&atts->gl.depth_stencil);\n        const _sg_image_t* ds_img = atts->gl.depth_stencil.image;\n        const GLuint gl_msaa_render_buffer = ds_img->gl.msaa_render_buffer;\n        if (gl_msaa_render_buffer) {\n            glFramebufferRenderbuffer(GL_FRAMEBUFFER, gl_att, GL_RENDERBUFFER, gl_msaa_render_buffer);\n        } else {\n            const GLenum gl_att_type = _sg_gl_depth_stencil_attachment_type(&atts->gl.depth_stencil);\n            _sg_gl_fb_attach_texture(&atts->gl.depth_stencil, &atts->cmn.depth_stencil, gl_att_type);\n        }\n    }\n\n    // check if framebuffer is complete\n    {\n        const GLenum fb_status = glCheckFramebufferStatus(GL_FRAMEBUFFER);\n        if (fb_status != GL_FRAMEBUFFER_COMPLETE) {\n            switch (fb_status) {\n                case GL_FRAMEBUFFER_UNDEFINED:\n                    _SG_ERROR(GL_FRAMEBUFFER_STATUS_UNDEFINED);\n                    break;\n                case GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT:\n                    _SG_ERROR(GL_FRAMEBUFFER_STATUS_INCOMPLETE_ATTACHMENT);\n                    break;\n                case GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:\n                    _SG_ERROR(GL_FRAMEBUFFER_STATUS_INCOMPLETE_MISSING_ATTACHMENT);\n                    break;\n                case GL_FRAMEBUFFER_UNSUPPORTED:\n                    _SG_ERROR(GL_FRAMEBUFFER_STATUS_UNSUPPORTED);\n                    break;\n                case GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE:\n                    _SG_ERROR(GL_FRAMEBUFFER_STATUS_INCOMPLETE_MULTISAMPLE);\n                    break;\n                default:\n                    _SG_ERROR(GL_FRAMEBUFFER_STATUS_UNKNOWN);\n                    break;\n            }\n            return SG_RESOURCESTATE_FAILED;\n        }\n    }\n\n    // setup color attachments for the framebuffer\n    static const GLenum gl_draw_bufs[SG_MAX_COLOR_ATTACHMENTS] = {\n        GL_COLOR_ATTACHMENT0,\n        GL_COLOR_ATTACHMENT1,\n        GL_COLOR_ATTACHMENT2,\n        GL_COLOR_ATTACHMENT3\n    };\n    glDrawBuffers(atts->cmn.num_colors, gl_draw_bufs);\n\n    // create MSAA resolve framebuffers if necessary\n    for (int i = 0; i < atts->cmn.num_colors; i++) {\n        _sg_gl_attachment_t* gl_resolve_att = &atts->gl.resolves[i];\n        if (gl_resolve_att->image) {\n            _sg_attachment_common_t* cmn_resolve_att = &atts->cmn.resolves[i];\n            SOKOL_ASSERT(0 == atts->gl.msaa_resolve_framebuffer[i]);\n            glGenFramebuffers(1, &atts->gl.msaa_resolve_framebuffer[i]);\n            glBindFramebuffer(GL_FRAMEBUFFER, atts->gl.msaa_resolve_framebuffer[i]);\n            _sg_gl_fb_attach_texture(gl_resolve_att, cmn_resolve_att, GL_COLOR_ATTACHMENT0);\n            // check if framebuffer is complete\n            const GLenum fb_status = glCheckFramebufferStatus(GL_FRAMEBUFFER);\n            if (fb_status != GL_FRAMEBUFFER_COMPLETE) {\n                switch (fb_status) {\n                    case GL_FRAMEBUFFER_UNDEFINED:\n                        _SG_ERROR(GL_FRAMEBUFFER_STATUS_UNDEFINED);\n                        break;\n                    case GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT:\n                        _SG_ERROR(GL_FRAMEBUFFER_STATUS_INCOMPLETE_ATTACHMENT);\n                        break;\n                    case GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:\n                        _SG_ERROR(GL_FRAMEBUFFER_STATUS_INCOMPLETE_MISSING_ATTACHMENT);\n                        break;\n                    case GL_FRAMEBUFFER_UNSUPPORTED:\n                        _SG_ERROR(GL_FRAMEBUFFER_STATUS_UNSUPPORTED);\n                        break;\n                    case GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE:\n                        _SG_ERROR(GL_FRAMEBUFFER_STATUS_INCOMPLETE_MULTISAMPLE);\n                        break;\n                    default:\n                        _SG_ERROR(GL_FRAMEBUFFER_STATUS_UNKNOWN);\n                        break;\n                }\n                return SG_RESOURCESTATE_FAILED;\n            }\n            // setup color attachments for the framebuffer\n            glDrawBuffers(1, &gl_draw_bufs[0]);\n        }\n    }\n\n    // restore original framebuffer binding\n    glBindFramebuffer(GL_FRAMEBUFFER, gl_orig_fb);\n    _SG_GL_CHECK_ERROR();\n    return SG_RESOURCESTATE_VALID;\n}\n\n_SOKOL_PRIVATE void _sg_gl_discard_attachments(_sg_attachments_t* atts) {\n    SOKOL_ASSERT(atts);\n    _SG_GL_CHECK_ERROR();\n    if (0 != atts->gl.fb) {\n        glDeleteFramebuffers(1, &atts->gl.fb);\n    }\n    for (int i = 0; i < SG_MAX_COLOR_ATTACHMENTS; i++) {\n        if (atts->gl.msaa_resolve_framebuffer[i]) {\n            glDeleteFramebuffers(1, &atts->gl.msaa_resolve_framebuffer[i]);\n        }\n    }\n    _SG_GL_CHECK_ERROR();\n}\n\n_SOKOL_PRIVATE _sg_image_t* _sg_gl_attachments_color_image(const _sg_attachments_t* atts, int index) {\n    SOKOL_ASSERT(atts && (index >= 0) && (index < SG_MAX_COLOR_ATTACHMENTS));\n    return atts->gl.colors[index].image;\n}\n\n_SOKOL_PRIVATE _sg_image_t* _sg_gl_attachments_resolve_image(const _sg_attachments_t* atts, int index) {\n    SOKOL_ASSERT(atts && (index >= 0) && (index < SG_MAX_COLOR_ATTACHMENTS));\n    return atts->gl.resolves[index].image;\n}\n\n_SOKOL_PRIVATE _sg_image_t* _sg_gl_attachments_ds_image(const _sg_attachments_t* atts) {\n    SOKOL_ASSERT(atts);\n    return atts->gl.depth_stencil.image;\n}\n\n_SOKOL_PRIVATE void _sg_gl_begin_pass(const sg_pass* pass) {\n    // FIXME: what if a texture used as render target is still bound, should we\n    // unbind all currently bound textures in begin pass?\n    SOKOL_ASSERT(pass);\n    _SG_GL_CHECK_ERROR();\n    const _sg_attachments_t* atts = _sg.cur_pass.atts;\n    const sg_swapchain* swapchain = &pass->swapchain;\n    const sg_pass_action* action = &pass->action;\n\n    // bind the render pass framebuffer\n    //\n    // FIXME: Disabling SRGB conversion for the default framebuffer is\n    // a crude hack to make behaviour for sRGB render target textures\n    // identical with the Metal and D3D11 swapchains created by sokol-app.\n    //\n    // This will need a cleaner solution (e.g. allowing to configure\n    // sokol_app.h with an sRGB or RGB framebuffer.\n    if (atts) {\n        // offscreen pass\n        SOKOL_ASSERT(atts->gl.fb);\n        #if defined(SOKOL_GLCORE)\n        glEnable(GL_FRAMEBUFFER_SRGB);\n        #endif\n        glBindFramebuffer(GL_FRAMEBUFFER, atts->gl.fb);\n    } else {\n        // default pass\n        #if defined(SOKOL_GLCORE)\n        glDisable(GL_FRAMEBUFFER_SRGB);\n        #endif\n        // NOTE: on some platforms, the default framebuffer of a context\n        // is null, so we can't actually assert here that the\n        // framebuffer has been provided\n        glBindFramebuffer(GL_FRAMEBUFFER, swapchain->gl.framebuffer);\n    }\n    glViewport(0, 0, _sg.cur_pass.width, _sg.cur_pass.height);\n    glScissor(0, 0, _sg.cur_pass.width, _sg.cur_pass.height);\n\n    // number of color attachments\n    const int num_color_atts = atts ? atts->cmn.num_colors : 1;\n\n    // clear color and depth-stencil attachments if needed\n    bool clear_any_color = false;\n    for (int i = 0; i < num_color_atts; i++) {\n        if (SG_LOADACTION_CLEAR == action->colors[i].load_action) {\n            clear_any_color = true;\n            break;\n        }\n    }\n    const bool clear_depth = (action->depth.load_action == SG_LOADACTION_CLEAR);\n    const bool clear_stencil = (action->stencil.load_action == SG_LOADACTION_CLEAR);\n\n    bool need_pip_cache_flush = false;\n    if (clear_any_color) {\n        bool need_color_mask_flush = false;\n        // NOTE: not a bug to iterate over all possible color attachments\n        for (int i = 0; i < SG_MAX_COLOR_ATTACHMENTS; i++) {\n            if (SG_COLORMASK_RGBA != _sg.gl.cache.color_write_mask[i]) {\n                need_pip_cache_flush = true;\n                need_color_mask_flush = true;\n                _sg.gl.cache.color_write_mask[i] = SG_COLORMASK_RGBA;\n            }\n        }\n        if (need_color_mask_flush) {\n            glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);\n        }\n    }\n    if (clear_depth) {\n        if (!_sg.gl.cache.depth.write_enabled) {\n            need_pip_cache_flush = true;\n            _sg.gl.cache.depth.write_enabled = true;\n            glDepthMask(GL_TRUE);\n        }\n        if (_sg.gl.cache.depth.compare != SG_COMPAREFUNC_ALWAYS) {\n            need_pip_cache_flush = true;\n            _sg.gl.cache.depth.compare = SG_COMPAREFUNC_ALWAYS;\n            glDepthFunc(GL_ALWAYS);\n        }\n    }\n    if (clear_stencil) {\n        if (_sg.gl.cache.stencil.write_mask != 0xFF) {\n            need_pip_cache_flush = true;\n            _sg.gl.cache.stencil.write_mask = 0xFF;\n            glStencilMask(0xFF);\n        }\n    }\n    if (need_pip_cache_flush) {\n        // we messed with the state cache directly, need to clear cached\n        // pipeline to force re-evaluation in next sg_apply_pipeline()\n        _sg.gl.cache.cur_pipeline = 0;\n        _sg.gl.cache.cur_pipeline_id.id = SG_INVALID_ID;\n    }\n    for (int i = 0; i < num_color_atts; i++) {\n        if (action->colors[i].load_action == SG_LOADACTION_CLEAR) {\n            glClearBufferfv(GL_COLOR, i, &action->colors[i].clear_value.r);\n        }\n    }\n    if ((atts == 0) || (atts->gl.depth_stencil.image)) {\n        if (clear_depth && clear_stencil) {\n            glClearBufferfi(GL_DEPTH_STENCIL, 0, action->depth.clear_value, action->stencil.clear_value);\n        } else if (clear_depth) {\n            glClearBufferfv(GL_DEPTH, 0, &action->depth.clear_value);\n        } else if (clear_stencil) {\n            GLint val = (GLint) action->stencil.clear_value;\n            glClearBufferiv(GL_STENCIL, 0, &val);\n        }\n    }\n    // keep store actions for end-pass\n    for (int i = 0; i < SG_MAX_COLOR_ATTACHMENTS; i++) {\n        _sg.gl.color_store_actions[i] = action->colors[i].store_action;\n    }\n    _sg.gl.depth_store_action = action->depth.store_action;\n    _sg.gl.stencil_store_action = action->stencil.store_action;\n\n    _SG_GL_CHECK_ERROR();\n}\n\n_SOKOL_PRIVATE void _sg_gl_end_pass(void) {\n    _SG_GL_CHECK_ERROR();\n\n    if (_sg.cur_pass.atts) {\n        const _sg_attachments_t* atts = _sg.cur_pass.atts;\n        SOKOL_ASSERT(atts->slot.id == _sg.cur_pass.atts_id.id);\n        bool fb_read_bound = false;\n        bool fb_draw_bound = false;\n        const int num_color_atts = atts->cmn.num_colors;\n        for (int i = 0; i < num_color_atts; i++) {\n            // perform MSAA resolve if needed\n            if (atts->gl.msaa_resolve_framebuffer[i] != 0) {\n                if (!fb_read_bound) {\n                    SOKOL_ASSERT(atts->gl.fb);\n                    glBindFramebuffer(GL_READ_FRAMEBUFFER, atts->gl.fb);\n                    fb_read_bound = true;\n                }\n                const int w = atts->gl.colors[i].image->cmn.width;\n                const int h = atts->gl.colors[i].image->cmn.height;\n                glBindFramebuffer(GL_DRAW_FRAMEBUFFER, atts->gl.msaa_resolve_framebuffer[i]);\n                glReadBuffer((GLenum)(GL_COLOR_ATTACHMENT0 + i));\n                glBlitFramebuffer(0, 0, w, h, 0, 0, w, h, GL_COLOR_BUFFER_BIT, GL_NEAREST);\n                fb_draw_bound = true;\n            }\n        }\n\n        // invalidate framebuffers\n        _SOKOL_UNUSED(fb_draw_bound);\n        #if defined(SOKOL_GLES3)\n        // need to restore framebuffer binding before invalidate if the MSAA resolve had changed the binding\n        if (fb_draw_bound) {\n            glBindFramebuffer(GL_FRAMEBUFFER, atts->gl.fb);\n        }\n        GLenum invalidate_atts[SG_MAX_COLOR_ATTACHMENTS + 2] = { 0 };\n        int att_index = 0;\n        for (int i = 0; i < num_color_atts; i++) {\n            if (_sg.gl.color_store_actions[i] == SG_STOREACTION_DONTCARE) {\n                invalidate_atts[att_index++] = (GLenum)(GL_COLOR_ATTACHMENT0 + i);\n            }\n        }\n        if ((_sg.gl.depth_store_action == SG_STOREACTION_DONTCARE) && (_sg.cur_pass.atts->cmn.depth_stencil.image_id.id != SG_INVALID_ID)) {\n            invalidate_atts[att_index++] = GL_DEPTH_ATTACHMENT;\n        }\n        if ((_sg.gl.stencil_store_action == SG_STOREACTION_DONTCARE) && (_sg.cur_pass.atts->cmn.depth_stencil.image_id.id != SG_INVALID_ID)) {\n            invalidate_atts[att_index++] = GL_STENCIL_ATTACHMENT;\n        }\n        if (att_index > 0) {\n            glInvalidateFramebuffer(GL_DRAW_FRAMEBUFFER, att_index, invalidate_atts);\n        }\n        #endif\n    }\n    _SG_GL_CHECK_ERROR();\n}\n\n_SOKOL_PRIVATE void _sg_gl_apply_viewport(int x, int y, int w, int h, bool origin_top_left) {\n    y = origin_top_left ? (_sg.cur_pass.height - (y+h)) : y;\n    glViewport(x, y, w, h);\n}\n\n_SOKOL_PRIVATE void _sg_gl_apply_scissor_rect(int x, int y, int w, int h, bool origin_top_left) {\n    y = origin_top_left ? (_sg.cur_pass.height - (y+h)) : y;\n    glScissor(x, y, w, h);\n}\n\n_SOKOL_PRIVATE void _sg_gl_apply_pipeline(_sg_pipeline_t* pip) {\n    SOKOL_ASSERT(pip);\n    SOKOL_ASSERT(pip->shader && (pip->cmn.shader_id.id == pip->shader->slot.id));\n    _SG_GL_CHECK_ERROR();\n    if ((_sg.gl.cache.cur_pipeline != pip) || (_sg.gl.cache.cur_pipeline_id.id != pip->slot.id)) {\n        _sg.gl.cache.cur_pipeline = pip;\n        _sg.gl.cache.cur_pipeline_id.id = pip->slot.id;\n        _sg.gl.cache.cur_primitive_type = _sg_gl_primitive_type(pip->gl.primitive_type);\n        _sg.gl.cache.cur_index_type = _sg_gl_index_type(pip->cmn.index_type);\n\n        // update depth state\n        {\n            const sg_depth_state* state_ds = &pip->gl.depth;\n            sg_depth_state* cache_ds = &_sg.gl.cache.depth;\n            if (state_ds->compare != cache_ds->compare) {\n                cache_ds->compare = state_ds->compare;\n                glDepthFunc(_sg_gl_compare_func(state_ds->compare));\n                _sg_stats_add(gl.num_render_state, 1);\n            }\n            if (state_ds->write_enabled != cache_ds->write_enabled) {\n                cache_ds->write_enabled = state_ds->write_enabled;\n                glDepthMask(state_ds->write_enabled);\n                _sg_stats_add(gl.num_render_state, 1);\n            }\n            if (!_sg_fequal(state_ds->bias, cache_ds->bias, 0.000001f) ||\n                !_sg_fequal(state_ds->bias_slope_scale, cache_ds->bias_slope_scale, 0.000001f))\n            {\n                /* according to ANGLE's D3D11 backend:\n                    D3D11 SlopeScaledDepthBias ==> GL polygonOffsetFactor\n                    D3D11 DepthBias ==> GL polygonOffsetUnits\n                    DepthBiasClamp has no meaning on GL\n                */\n                cache_ds->bias = state_ds->bias;\n                cache_ds->bias_slope_scale = state_ds->bias_slope_scale;\n                glPolygonOffset(state_ds->bias_slope_scale, state_ds->bias);\n                _sg_stats_add(gl.num_render_state, 1);\n                bool po_enabled = true;\n                if (_sg_fequal(state_ds->bias, 0.0f, 0.000001f) &&\n                    _sg_fequal(state_ds->bias_slope_scale, 0.0f, 0.000001f))\n                {\n                    po_enabled = false;\n                }\n                if (po_enabled != _sg.gl.cache.polygon_offset_enabled) {\n                    _sg.gl.cache.polygon_offset_enabled = po_enabled;\n                    if (po_enabled) {\n                        glEnable(GL_POLYGON_OFFSET_FILL);\n                    } else {\n                        glDisable(GL_POLYGON_OFFSET_FILL);\n                    }\n                    _sg_stats_add(gl.num_render_state, 1);\n                }\n            }\n        }\n\n        // update stencil state\n        {\n            const sg_stencil_state* state_ss = &pip->gl.stencil;\n            sg_stencil_state* cache_ss = &_sg.gl.cache.stencil;\n            if (state_ss->enabled != cache_ss->enabled) {\n                cache_ss->enabled = state_ss->enabled;\n                if (state_ss->enabled) {\n                    glEnable(GL_STENCIL_TEST);\n                } else {\n                    glDisable(GL_STENCIL_TEST);\n                }\n                _sg_stats_add(gl.num_render_state, 1);\n            }\n            if (state_ss->write_mask != cache_ss->write_mask) {\n                cache_ss->write_mask = state_ss->write_mask;\n                glStencilMask(state_ss->write_mask);\n                _sg_stats_add(gl.num_render_state, 1);\n            }\n            for (int i = 0; i < 2; i++) {\n                const sg_stencil_face_state* state_sfs = (i==0)? &state_ss->front : &state_ss->back;\n                sg_stencil_face_state* cache_sfs = (i==0)? &cache_ss->front : &cache_ss->back;\n                GLenum gl_face = (i==0)? GL_FRONT : GL_BACK;\n                if ((state_sfs->compare != cache_sfs->compare) ||\n                    (state_ss->read_mask != cache_ss->read_mask) ||\n                    (state_ss->ref != cache_ss->ref))\n                {\n                    cache_sfs->compare = state_sfs->compare;\n                    glStencilFuncSeparate(gl_face,\n                        _sg_gl_compare_func(state_sfs->compare),\n                        state_ss->ref,\n                        state_ss->read_mask);\n                    _sg_stats_add(gl.num_render_state, 1);\n                }\n                if ((state_sfs->fail_op != cache_sfs->fail_op) ||\n                    (state_sfs->depth_fail_op != cache_sfs->depth_fail_op) ||\n                    (state_sfs->pass_op != cache_sfs->pass_op))\n                {\n                    cache_sfs->fail_op = state_sfs->fail_op;\n                    cache_sfs->depth_fail_op = state_sfs->depth_fail_op;\n                    cache_sfs->pass_op = state_sfs->pass_op;\n                    glStencilOpSeparate(gl_face,\n                        _sg_gl_stencil_op(state_sfs->fail_op),\n                        _sg_gl_stencil_op(state_sfs->depth_fail_op),\n                        _sg_gl_stencil_op(state_sfs->pass_op));\n                    _sg_stats_add(gl.num_render_state, 1);\n                }\n            }\n            cache_ss->read_mask = state_ss->read_mask;\n            cache_ss->ref = state_ss->ref;\n        }\n\n        if (pip->cmn.color_count > 0) {\n            // update blend state\n            // FIXME: separate blend state per color attachment not support, needs GL4\n            const sg_blend_state* state_bs = &pip->gl.blend;\n            sg_blend_state* cache_bs = &_sg.gl.cache.blend;\n            if (state_bs->enabled != cache_bs->enabled) {\n                cache_bs->enabled = state_bs->enabled;\n                if (state_bs->enabled) {\n                    glEnable(GL_BLEND);\n                } else {\n                    glDisable(GL_BLEND);\n                }\n                _sg_stats_add(gl.num_render_state, 1);\n            }\n            if ((state_bs->src_factor_rgb != cache_bs->src_factor_rgb) ||\n                (state_bs->dst_factor_rgb != cache_bs->dst_factor_rgb) ||\n                (state_bs->src_factor_alpha != cache_bs->src_factor_alpha) ||\n                (state_bs->dst_factor_alpha != cache_bs->dst_factor_alpha))\n            {\n                cache_bs->src_factor_rgb = state_bs->src_factor_rgb;\n                cache_bs->dst_factor_rgb = state_bs->dst_factor_rgb;\n                cache_bs->src_factor_alpha = state_bs->src_factor_alpha;\n                cache_bs->dst_factor_alpha = state_bs->dst_factor_alpha;\n                glBlendFuncSeparate(_sg_gl_blend_factor(state_bs->src_factor_rgb),\n                    _sg_gl_blend_factor(state_bs->dst_factor_rgb),\n                    _sg_gl_blend_factor(state_bs->src_factor_alpha),\n                    _sg_gl_blend_factor(state_bs->dst_factor_alpha));\n                _sg_stats_add(gl.num_render_state, 1);\n            }\n            if ((state_bs->op_rgb != cache_bs->op_rgb) || (state_bs->op_alpha != cache_bs->op_alpha)) {\n                cache_bs->op_rgb = state_bs->op_rgb;\n                cache_bs->op_alpha = state_bs->op_alpha;\n                glBlendEquationSeparate(_sg_gl_blend_op(state_bs->op_rgb), _sg_gl_blend_op(state_bs->op_alpha));\n                _sg_stats_add(gl.num_render_state, 1);\n            }\n\n            // standalone color target state\n            for (GLuint i = 0; i < (GLuint)pip->cmn.color_count; i++) {\n                if (pip->gl.color_write_mask[i] != _sg.gl.cache.color_write_mask[i]) {\n                    const sg_color_mask cm = pip->gl.color_write_mask[i];\n                    _sg.gl.cache.color_write_mask[i] = cm;\n                    #ifdef SOKOL_GLCORE\n                        glColorMaski(i,\n                                    (cm & SG_COLORMASK_R) != 0,\n                                    (cm & SG_COLORMASK_G) != 0,\n                                    (cm & SG_COLORMASK_B) != 0,\n                                    (cm & SG_COLORMASK_A) != 0);\n                    #else\n                        if (0 == i) {\n                            glColorMask((cm & SG_COLORMASK_R) != 0,\n                                        (cm & SG_COLORMASK_G) != 0,\n                                        (cm & SG_COLORMASK_B) != 0,\n                                        (cm & SG_COLORMASK_A) != 0);\n                        }\n                    #endif\n                    _sg_stats_add(gl.num_render_state, 1);\n                }\n            }\n\n            if (!_sg_fequal(pip->cmn.blend_color.r, _sg.gl.cache.blend_color.r, 0.0001f) ||\n                !_sg_fequal(pip->cmn.blend_color.g, _sg.gl.cache.blend_color.g, 0.0001f) ||\n                !_sg_fequal(pip->cmn.blend_color.b, _sg.gl.cache.blend_color.b, 0.0001f) ||\n                !_sg_fequal(pip->cmn.blend_color.a, _sg.gl.cache.blend_color.a, 0.0001f))\n            {\n                sg_color c = pip->cmn.blend_color;\n                _sg.gl.cache.blend_color = c;\n                glBlendColor(c.r, c.g, c.b, c.a);\n                _sg_stats_add(gl.num_render_state, 1);\n            }\n        } // pip->cmn.color_count > 0\n\n        if (pip->gl.cull_mode != _sg.gl.cache.cull_mode) {\n            _sg.gl.cache.cull_mode = pip->gl.cull_mode;\n            if (SG_CULLMODE_NONE == pip->gl.cull_mode) {\n                glDisable(GL_CULL_FACE);\n                _sg_stats_add(gl.num_render_state, 1);\n            } else {\n                glEnable(GL_CULL_FACE);\n                GLenum gl_mode = (SG_CULLMODE_FRONT == pip->gl.cull_mode) ? GL_FRONT : GL_BACK;\n                glCullFace(gl_mode);\n                _sg_stats_add(gl.num_render_state, 2);\n            }\n        }\n        if (pip->gl.face_winding != _sg.gl.cache.face_winding) {\n            _sg.gl.cache.face_winding = pip->gl.face_winding;\n            GLenum gl_winding = (SG_FACEWINDING_CW == pip->gl.face_winding) ? GL_CW : GL_CCW;\n            glFrontFace(gl_winding);\n            _sg_stats_add(gl.num_render_state, 1);\n        }\n        if (pip->gl.alpha_to_coverage_enabled != _sg.gl.cache.alpha_to_coverage_enabled) {\n            _sg.gl.cache.alpha_to_coverage_enabled = pip->gl.alpha_to_coverage_enabled;\n            if (pip->gl.alpha_to_coverage_enabled) {\n                glEnable(GL_SAMPLE_ALPHA_TO_COVERAGE);\n            } else {\n                glDisable(GL_SAMPLE_ALPHA_TO_COVERAGE);\n            }\n            _sg_stats_add(gl.num_render_state, 1);\n        }\n        #ifdef SOKOL_GLCORE\n        if (pip->gl.sample_count != _sg.gl.cache.sample_count) {\n            _sg.gl.cache.sample_count = pip->gl.sample_count;\n            if (pip->gl.sample_count > 1) {\n                glEnable(GL_MULTISAMPLE);\n            } else {\n                glDisable(GL_MULTISAMPLE);\n            }\n            _sg_stats_add(gl.num_render_state, 1);\n        }\n        #endif\n\n        // bind shader program\n        if (pip->shader->gl.prog != _sg.gl.cache.prog) {\n            _sg.gl.cache.prog = pip->shader->gl.prog;\n            glUseProgram(pip->shader->gl.prog);\n            _sg_stats_add(gl.num_use_program, 1);\n        }\n    }\n    _SG_GL_CHECK_ERROR();\n}\n\n_SOKOL_PRIVATE bool _sg_gl_apply_bindings(_sg_bindings_t* bnd) {\n    SOKOL_ASSERT(bnd);\n    SOKOL_ASSERT(bnd->pip && bnd->pip->shader);\n    SOKOL_ASSERT(bnd->pip->shader->slot.id == bnd->pip->cmn.shader_id.id);\n    _SG_GL_CHECK_ERROR();\n    const _sg_shader_t* shd = bnd->pip->shader;\n\n    // bind combined image-samplers\n    _SG_GL_CHECK_ERROR();\n    for (size_t img_smp_index = 0; img_smp_index < SG_MAX_IMAGE_SAMPLER_PAIRS; img_smp_index++) {\n        const _sg_shader_image_sampler_t* img_smp = &shd->cmn.image_samplers[img_smp_index];\n        if (img_smp->stage == SG_SHADERSTAGE_NONE) {\n            continue;\n        }\n        const int8_t gl_tex_slot = (GLint)shd->gl.tex_slot[img_smp_index];\n        if (gl_tex_slot != -1) {\n            SOKOL_ASSERT(img_smp->image_slot < SG_MAX_IMAGE_BINDSLOTS);\n            SOKOL_ASSERT(img_smp->sampler_slot < SG_MAX_SAMPLER_BINDSLOTS);\n            const _sg_image_t* img = bnd->imgs[img_smp->image_slot];\n            const _sg_sampler_t* smp = bnd->smps[img_smp->sampler_slot];\n            SOKOL_ASSERT(img);\n            SOKOL_ASSERT(smp);\n            const GLenum gl_tgt = img->gl.target;\n            const GLuint gl_tex = img->gl.tex[img->cmn.active_slot];\n            const GLuint gl_smp = smp->gl.smp;\n            _sg_gl_cache_bind_texture_sampler(gl_tex_slot, gl_tgt, gl_tex, gl_smp);\n        }\n    }\n    _SG_GL_CHECK_ERROR();\n\n    // bind storage buffers\n    for (size_t sbuf_index = 0; sbuf_index < SG_MAX_STORAGEBUFFER_BINDSLOTS; sbuf_index++) {\n        if (shd->cmn.storage_buffers[sbuf_index].stage == SG_SHADERSTAGE_NONE) {\n            continue;\n        }\n        const _sg_buffer_t* sbuf = bnd->sbufs[sbuf_index];\n        const uint8_t binding = shd->gl.sbuf_binding[sbuf_index];\n        GLuint gl_sbuf = sbuf->gl.buf[sbuf->cmn.active_slot];\n        _sg_gl_cache_bind_storage_buffer(binding, gl_sbuf);\n    }\n\n    // index buffer (can be 0)\n    const GLuint gl_ib = bnd->ib ? bnd->ib->gl.buf[bnd->ib->cmn.active_slot] : 0;\n    _sg_gl_cache_bind_buffer(GL_ELEMENT_ARRAY_BUFFER, gl_ib);\n    _sg.gl.cache.cur_ib_offset = bnd->ib_offset;\n\n    // vertex attributes\n    for (GLuint attr_index = 0; attr_index < (GLuint)_sg.limits.max_vertex_attrs; attr_index++) {\n        _sg_gl_attr_t* attr = &bnd->pip->gl.attrs[attr_index];\n        _sg_gl_cache_attr_t* cache_attr = &_sg.gl.cache.attrs[attr_index];\n        bool cache_attr_dirty = false;\n        int vb_offset = 0;\n        GLuint gl_vb = 0;\n        if (attr->vb_index >= 0) {\n            // attribute is enabled\n            SOKOL_ASSERT(attr->vb_index < SG_MAX_VERTEXBUFFER_BINDSLOTS);\n            _sg_buffer_t* vb = bnd->vbs[attr->vb_index];\n            SOKOL_ASSERT(vb);\n            gl_vb = vb->gl.buf[vb->cmn.active_slot];\n            vb_offset = bnd->vb_offsets[attr->vb_index] + attr->offset;\n            if ((gl_vb != cache_attr->gl_vbuf) ||\n                (attr->size != cache_attr->gl_attr.size) ||\n                (attr->type != cache_attr->gl_attr.type) ||\n                (attr->normalized != cache_attr->gl_attr.normalized) ||\n                (attr->stride != cache_attr->gl_attr.stride) ||\n                (vb_offset != cache_attr->gl_attr.offset) ||\n                (cache_attr->gl_attr.divisor != attr->divisor))\n            {\n                _sg_gl_cache_bind_buffer(GL_ARRAY_BUFFER, gl_vb);\n                glVertexAttribPointer(attr_index, attr->size, attr->type, attr->normalized, attr->stride, (const GLvoid*)(GLintptr)vb_offset);\n                _sg_stats_add(gl.num_vertex_attrib_pointer, 1);\n                glVertexAttribDivisor(attr_index, (GLuint)attr->divisor);\n                _sg_stats_add(gl.num_vertex_attrib_divisor, 1);\n                cache_attr_dirty = true;\n            }\n            if (cache_attr->gl_attr.vb_index == -1) {\n                glEnableVertexAttribArray(attr_index);\n                _sg_stats_add(gl.num_enable_vertex_attrib_array, 1);\n                cache_attr_dirty = true;\n            }\n        } else {\n            // attribute is disabled\n            if (cache_attr->gl_attr.vb_index != -1) {\n                glDisableVertexAttribArray(attr_index);\n                _sg_stats_add(gl.num_disable_vertex_attrib_array, 1);\n                cache_attr_dirty = true;\n            }\n        }\n        if (cache_attr_dirty) {\n            cache_attr->gl_attr = *attr;\n            cache_attr->gl_attr.offset = vb_offset;\n            cache_attr->gl_vbuf = gl_vb;\n        }\n    }\n    _SG_GL_CHECK_ERROR();\n    return true;\n}\n\n_SOKOL_PRIVATE void _sg_gl_apply_uniforms(int ub_slot, const sg_range* data) {\n    SOKOL_ASSERT(_sg.gl.cache.cur_pipeline);\n    SOKOL_ASSERT((ub_slot >= 0) && (ub_slot < SG_MAX_UNIFORMBLOCK_BINDSLOTS));\n    const _sg_pipeline_t* pip = _sg.gl.cache.cur_pipeline;\n    SOKOL_ASSERT(pip && pip->shader);\n    SOKOL_ASSERT(pip->slot.id == _sg.gl.cache.cur_pipeline_id.id);\n    const _sg_shader_t* shd = pip->shader;\n    SOKOL_ASSERT(shd->slot.id == pip->cmn.shader_id.id);\n    SOKOL_ASSERT(SG_SHADERSTAGE_NONE != shd->cmn.uniform_blocks[ub_slot].stage);\n    SOKOL_ASSERT(data->size == shd->cmn.uniform_blocks[ub_slot].size);\n    const _sg_gl_uniform_block_t* gl_ub = &shd->gl.uniform_blocks[ub_slot];\n    for (int u_index = 0; u_index < gl_ub->num_uniforms; u_index++) {\n        const _sg_gl_uniform_t* u = &gl_ub->uniforms[u_index];\n        SOKOL_ASSERT(u->type != SG_UNIFORMTYPE_INVALID);\n        if (u->gl_loc == -1) {\n            continue;\n        }\n        _sg_stats_add(gl.num_uniform, 1);\n        GLfloat* fptr = (GLfloat*) (((uint8_t*)data->ptr) + u->offset);\n        GLint* iptr = (GLint*) (((uint8_t*)data->ptr) + u->offset);\n        switch (u->type) {\n            case SG_UNIFORMTYPE_INVALID:\n                break;\n            case SG_UNIFORMTYPE_FLOAT:\n                glUniform1fv(u->gl_loc, u->count, fptr);\n                break;\n            case SG_UNIFORMTYPE_FLOAT2:\n                glUniform2fv(u->gl_loc, u->count, fptr);\n                break;\n            case SG_UNIFORMTYPE_FLOAT3:\n                glUniform3fv(u->gl_loc, u->count, fptr);\n                break;\n            case SG_UNIFORMTYPE_FLOAT4:\n                glUniform4fv(u->gl_loc, u->count, fptr);\n                break;\n            case SG_UNIFORMTYPE_INT:\n                glUniform1iv(u->gl_loc, u->count, iptr);\n                break;\n            case SG_UNIFORMTYPE_INT2:\n                glUniform2iv(u->gl_loc, u->count, iptr);\n                break;\n            case SG_UNIFORMTYPE_INT3:\n                glUniform3iv(u->gl_loc, u->count, iptr);\n                break;\n            case SG_UNIFORMTYPE_INT4:\n                glUniform4iv(u->gl_loc, u->count, iptr);\n                break;\n            case SG_UNIFORMTYPE_MAT4:\n                glUniformMatrix4fv(u->gl_loc, u->count, GL_FALSE, fptr);\n                break;\n            default:\n                SOKOL_UNREACHABLE;\n                break;\n        }\n    }\n}\n\n_SOKOL_PRIVATE void _sg_gl_draw(int base_element, int num_elements, int num_instances) {\n    SOKOL_ASSERT(_sg.gl.cache.cur_pipeline);\n    const GLenum i_type = _sg.gl.cache.cur_index_type;\n    const GLenum p_type = _sg.gl.cache.cur_primitive_type;\n    const bool use_instanced_draw = (num_instances > 1) || (_sg.gl.cache.cur_pipeline->cmn.use_instanced_draw);\n    if (0 != i_type) {\n        // indexed rendering\n        const int i_size = (i_type == GL_UNSIGNED_SHORT) ? 2 : 4;\n        const int ib_offset = _sg.gl.cache.cur_ib_offset;\n        const GLvoid* indices = (const GLvoid*)(GLintptr)(base_element*i_size+ib_offset);\n        if (use_instanced_draw) {\n            glDrawElementsInstanced(p_type, num_elements, i_type, indices, num_instances);\n        } else {\n            glDrawElements(p_type, num_elements, i_type, indices);\n        }\n    } else {\n        // non-indexed rendering\n        if (use_instanced_draw) {\n            glDrawArraysInstanced(p_type, base_element, num_elements, num_instances);\n        } else {\n            glDrawArrays(p_type, base_element, num_elements);\n        }\n    }\n}\n\n_SOKOL_PRIVATE void _sg_gl_commit(void) {\n    // \"soft\" clear bindings (only those that are actually bound)\n    _sg_gl_cache_clear_buffer_bindings(false);\n    _sg_gl_cache_clear_texture_sampler_bindings(false);\n}\n\n_SOKOL_PRIVATE void _sg_gl_update_buffer(_sg_buffer_t* buf, const sg_range* data) {\n    SOKOL_ASSERT(buf && data && data->ptr && (data->size > 0));\n    // only one update per buffer per frame allowed\n    if (++buf->cmn.active_slot >= buf->cmn.num_slots) {\n        buf->cmn.active_slot = 0;\n    }\n    GLenum gl_tgt = _sg_gl_buffer_target(buf->cmn.type);\n    SOKOL_ASSERT(buf->cmn.active_slot < SG_NUM_INFLIGHT_FRAMES);\n    GLuint gl_buf = buf->gl.buf[buf->cmn.active_slot];\n    SOKOL_ASSERT(gl_buf);\n    _SG_GL_CHECK_ERROR();\n    _sg_gl_cache_store_buffer_binding(gl_tgt);\n    _sg_gl_cache_bind_buffer(gl_tgt, gl_buf);\n    glBufferSubData(gl_tgt, 0, (GLsizeiptr)data->size, data->ptr);\n    _sg_gl_cache_restore_buffer_binding(gl_tgt);\n    _SG_GL_CHECK_ERROR();\n}\n\n_SOKOL_PRIVATE void _sg_gl_append_buffer(_sg_buffer_t* buf, const sg_range* data, bool new_frame) {\n    SOKOL_ASSERT(buf && data && data->ptr && (data->size > 0));\n    if (new_frame) {\n        if (++buf->cmn.active_slot >= buf->cmn.num_slots) {\n            buf->cmn.active_slot = 0;\n        }\n    }\n    GLenum gl_tgt = _sg_gl_buffer_target(buf->cmn.type);\n    SOKOL_ASSERT(buf->cmn.active_slot < SG_NUM_INFLIGHT_FRAMES);\n    GLuint gl_buf = buf->gl.buf[buf->cmn.active_slot];\n    SOKOL_ASSERT(gl_buf);\n    _SG_GL_CHECK_ERROR();\n    _sg_gl_cache_store_buffer_binding(gl_tgt);\n    _sg_gl_cache_bind_buffer(gl_tgt, gl_buf);\n    glBufferSubData(gl_tgt, buf->cmn.append_pos, (GLsizeiptr)data->size, data->ptr);\n    _sg_gl_cache_restore_buffer_binding(gl_tgt);\n    _SG_GL_CHECK_ERROR();\n}\n\n_SOKOL_PRIVATE void _sg_gl_update_image(_sg_image_t* img, const sg_image_data* data) {\n    SOKOL_ASSERT(img && data);\n    // only one update per image per frame allowed\n    if (++img->cmn.active_slot >= img->cmn.num_slots) {\n        img->cmn.active_slot = 0;\n    }\n    SOKOL_ASSERT(img->cmn.active_slot < SG_NUM_INFLIGHT_FRAMES);\n    SOKOL_ASSERT(0 != img->gl.tex[img->cmn.active_slot]);\n    _sg_gl_cache_store_texture_sampler_binding(0);\n    _sg_gl_cache_bind_texture_sampler(0, img->gl.target, img->gl.tex[img->cmn.active_slot], 0);\n    const GLenum gl_img_format = _sg_gl_teximage_format(img->cmn.pixel_format);\n    const GLenum gl_img_type = _sg_gl_teximage_type(img->cmn.pixel_format);\n    const int num_faces = img->cmn.type == SG_IMAGETYPE_CUBE ? 6 : 1;\n    const int num_mips = img->cmn.num_mipmaps;\n    for (int face_index = 0; face_index < num_faces; face_index++) {\n        for (int mip_index = 0; mip_index < num_mips; mip_index++) {\n            GLenum gl_img_target = img->gl.target;\n            if (SG_IMAGETYPE_CUBE == img->cmn.type) {\n                gl_img_target = _sg_gl_cubeface_target(face_index);\n            }\n            const GLvoid* data_ptr = data->subimage[face_index][mip_index].ptr;\n            int mip_width = _sg_miplevel_dim(img->cmn.width, mip_index);\n            int mip_height = _sg_miplevel_dim(img->cmn.height, mip_index);\n            if ((SG_IMAGETYPE_2D == img->cmn.type) || (SG_IMAGETYPE_CUBE == img->cmn.type)) {\n                glTexSubImage2D(gl_img_target, mip_index,\n                    0, 0,\n                    mip_width, mip_height,\n                    gl_img_format, gl_img_type,\n                    data_ptr);\n            } else if ((SG_IMAGETYPE_3D == img->cmn.type) || (SG_IMAGETYPE_ARRAY == img->cmn.type)) {\n                int mip_depth = img->cmn.num_slices;\n                if (SG_IMAGETYPE_3D == img->cmn.type) {\n                    mip_depth = _sg_miplevel_dim(img->cmn.num_slices, mip_index);\n                }\n                glTexSubImage3D(gl_img_target, mip_index,\n                    0, 0, 0,\n                    mip_width, mip_height, mip_depth,\n                    gl_img_format, gl_img_type,\n                    data_ptr);\n\n            }\n        }\n    }\n    _sg_gl_cache_restore_texture_sampler_binding(0);\n}\n\n//                                \n//                                                    \n//                                          \n//                                                      \n//                                \n//\n// >>d3d11 backend\n#elif defined(SOKOL_D3D11)\n\n#if defined(__cplusplus)\n#define _sg_d3d11_AddRef(self) (self)->AddRef()\n#else\n#define _sg_d3d11_AddRef(self) (self)->lpVtbl->AddRef(self)\n#endif\n\n#if defined(__cplusplus)\n#define _sg_d3d11_Release(self) (self)->Release()\n#else\n#define _sg_d3d11_Release(self) (self)->lpVtbl->Release(self)\n#endif\n\n// NOTE: This needs to be a macro since we can't use the polymorphism in C. It's called on many kinds of resources.\n// NOTE: Based on microsoft docs, it's fine to call this with pData=NULL if DataSize is also zero.\n#if defined(__cplusplus)\n#define _sg_d3d11_SetPrivateData(self, guid, DataSize, pData) (self)->SetPrivateData(guid, DataSize, pData)\n#else\n#define _sg_d3d11_SetPrivateData(self, guid, DataSize, pData) (self)->lpVtbl->SetPrivateData(self, guid, DataSize, pData)\n#endif\n\n#if defined(__cplusplus)\n#define _sg_win32_refguid(guid) guid\n#else\n#define _sg_win32_refguid(guid) &guid\n#endif\n\nstatic const GUID _sg_d3d11_WKPDID_D3DDebugObjectName = { 0x429b8c22,0x9188,0x4b0c, {0x87,0x42,0xac,0xb0,0xbf,0x85,0xc2,0x00} };\n\n#if defined(SOKOL_DEBUG)\n#define _sg_d3d11_setlabel(self, label) _sg_d3d11_SetPrivateData(self, _sg_win32_refguid(_sg_d3d11_WKPDID_D3DDebugObjectName), label ? (UINT)strlen(label) : 0, label)\n#else\n#define _sg_d3d11_setlabel(self, label)\n#endif\n\n\n//-- D3D11 C/C++ wrappers ------------------------------------------------------\nstatic inline HRESULT _sg_d3d11_CheckFormatSupport(ID3D11Device* self, DXGI_FORMAT Format, UINT* pFormatSupport) {\n    #if defined(__cplusplus)\n        return self->CheckFormatSupport(Format, pFormatSupport);\n    #else\n        return self->lpVtbl->CheckFormatSupport(self, Format, pFormatSupport);\n    #endif\n}\n\nstatic inline void _sg_d3d11_OMSetRenderTargets(ID3D11DeviceContext* self, UINT NumViews, ID3D11RenderTargetView* const* ppRenderTargetViews, ID3D11DepthStencilView *pDepthStencilView) {\n    #if defined(__cplusplus)\n        self->OMSetRenderTargets(NumViews, ppRenderTargetViews, pDepthStencilView);\n    #else\n        self->lpVtbl->OMSetRenderTargets(self, NumViews, ppRenderTargetViews, pDepthStencilView);\n    #endif\n}\n\nstatic inline void _sg_d3d11_RSSetState(ID3D11DeviceContext* self, ID3D11RasterizerState* pRasterizerState) {\n    #if defined(__cplusplus)\n        self->RSSetState(pRasterizerState);\n    #else\n        self->lpVtbl->RSSetState(self, pRasterizerState);\n    #endif\n}\n\nstatic inline void _sg_d3d11_OMSetDepthStencilState(ID3D11DeviceContext* self, ID3D11DepthStencilState* pDepthStencilState, UINT StencilRef) {\n    #if defined(__cplusplus)\n        self->OMSetDepthStencilState(pDepthStencilState, StencilRef);\n    #else\n        self->lpVtbl->OMSetDepthStencilState(self, pDepthStencilState, StencilRef);\n    #endif\n}\n\nstatic inline void _sg_d3d11_OMSetBlendState(ID3D11DeviceContext* self, ID3D11BlendState* pBlendState, const FLOAT BlendFactor[4], UINT SampleMask) {\n    #if defined(__cplusplus)\n        self->OMSetBlendState(pBlendState, BlendFactor, SampleMask);\n    #else\n        self->lpVtbl->OMSetBlendState(self, pBlendState, BlendFactor, SampleMask);\n    #endif\n}\n\nstatic inline void _sg_d3d11_IASetVertexBuffers(ID3D11DeviceContext* self, UINT StartSlot, UINT NumBuffers, ID3D11Buffer* const* ppVertexBuffers, const UINT* pStrides, const UINT* pOffsets) {\n    #if defined(__cplusplus)\n        self->IASetVertexBuffers(StartSlot, NumBuffers, ppVertexBuffers, pStrides, pOffsets);\n    #else\n        self->lpVtbl->IASetVertexBuffers(self, StartSlot, NumBuffers, ppVertexBuffers, pStrides, pOffsets);\n    #endif\n}\n\nstatic inline void _sg_d3d11_IASetIndexBuffer(ID3D11DeviceContext* self, ID3D11Buffer* pIndexBuffer, DXGI_FORMAT Format, UINT Offset) {\n    #if defined(__cplusplus)\n        self->IASetIndexBuffer(pIndexBuffer, Format, Offset);\n    #else\n        self->lpVtbl->IASetIndexBuffer(self, pIndexBuffer, Format, Offset);\n    #endif\n}\n\nstatic inline void _sg_d3d11_IASetInputLayout(ID3D11DeviceContext* self, ID3D11InputLayout* pInputLayout) {\n    #if defined(__cplusplus)\n        self->IASetInputLayout(pInputLayout);\n    #else\n        self->lpVtbl->IASetInputLayout(self, pInputLayout);\n    #endif\n}\n\nstatic inline void _sg_d3d11_VSSetShader(ID3D11DeviceContext* self, ID3D11VertexShader* pVertexShader, ID3D11ClassInstance* const* ppClassInstances, UINT NumClassInstances) {\n    #if defined(__cplusplus)\n        self->VSSetShader(pVertexShader, ppClassInstances, NumClassInstances);\n    #else\n        self->lpVtbl->VSSetShader(self, pVertexShader, ppClassInstances, NumClassInstances);\n    #endif\n}\n\nstatic inline void _sg_d3d11_PSSetShader(ID3D11DeviceContext* self, ID3D11PixelShader* pPixelShader, ID3D11ClassInstance* const* ppClassInstances, UINT NumClassInstances) {\n    #if defined(__cplusplus)\n        self->PSSetShader(pPixelShader, ppClassInstances, NumClassInstances);\n    #else\n        self->lpVtbl->PSSetShader(self, pPixelShader, ppClassInstances, NumClassInstances);\n    #endif\n}\n\nstatic inline void _sg_d3d11_VSSetConstantBuffers(ID3D11DeviceContext* self, UINT StartSlot, UINT NumBuffers, ID3D11Buffer* const* ppConstantBuffers) {\n    #if defined(__cplusplus)\n        self->VSSetConstantBuffers(StartSlot, NumBuffers, ppConstantBuffers);\n    #else\n        self->lpVtbl->VSSetConstantBuffers(self, StartSlot, NumBuffers, ppConstantBuffers);\n    #endif\n}\n\nstatic inline void _sg_d3d11_PSSetConstantBuffers(ID3D11DeviceContext* self, UINT StartSlot, UINT NumBuffers, ID3D11Buffer* const* ppConstantBuffers) {\n    #if defined(__cplusplus)\n        self->PSSetConstantBuffers(StartSlot, NumBuffers, ppConstantBuffers);\n    #else\n        self->lpVtbl->PSSetConstantBuffers(self, StartSlot, NumBuffers, ppConstantBuffers);\n    #endif\n}\n\nstatic inline void _sg_d3d11_VSSetShaderResources(ID3D11DeviceContext* self, UINT StartSlot, UINT NumViews, ID3D11ShaderResourceView* const* ppShaderResourceViews) {\n    #if defined(__cplusplus)\n        self->VSSetShaderResources(StartSlot, NumViews, ppShaderResourceViews);\n    #else\n        self->lpVtbl->VSSetShaderResources(self, StartSlot, NumViews, ppShaderResourceViews);\n    #endif\n}\n\nstatic inline void _sg_d3d11_PSSetShaderResources(ID3D11DeviceContext* self, UINT StartSlot, UINT NumViews, ID3D11ShaderResourceView* const* ppShaderResourceViews) {\n    #if defined(__cplusplus)\n        self->PSSetShaderResources(StartSlot, NumViews, ppShaderResourceViews);\n    #else\n        self->lpVtbl->PSSetShaderResources(self, StartSlot, NumViews, ppShaderResourceViews);\n    #endif\n}\n\nstatic inline void _sg_d3d11_VSSetSamplers(ID3D11DeviceContext* self, UINT StartSlot, UINT NumSamplers, ID3D11SamplerState* const* ppSamplers) {\n    #if defined(__cplusplus)\n        self->VSSetSamplers(StartSlot, NumSamplers, ppSamplers);\n    #else\n        self->lpVtbl->VSSetSamplers(self, StartSlot, NumSamplers, ppSamplers);\n    #endif\n}\n\nstatic inline void _sg_d3d11_PSSetSamplers(ID3D11DeviceContext* self, UINT StartSlot, UINT NumSamplers, ID3D11SamplerState* const* ppSamplers) {\n    #if defined(__cplusplus)\n        self->PSSetSamplers(StartSlot, NumSamplers, ppSamplers);\n    #else\n        self->lpVtbl->PSSetSamplers(self, StartSlot, NumSamplers, ppSamplers);\n    #endif\n}\n\nstatic inline HRESULT _sg_d3d11_CreateBuffer(ID3D11Device* self, const D3D11_BUFFER_DESC* pDesc, const D3D11_SUBRESOURCE_DATA* pInitialData, ID3D11Buffer** ppBuffer) {\n    #if defined(__cplusplus)\n        return self->CreateBuffer(pDesc, pInitialData, ppBuffer);\n    #else\n        return self->lpVtbl->CreateBuffer(self, pDesc, pInitialData, ppBuffer);\n    #endif\n}\n\nstatic inline HRESULT _sg_d3d11_CreateTexture2D(ID3D11Device* self, const D3D11_TEXTURE2D_DESC* pDesc, const D3D11_SUBRESOURCE_DATA* pInitialData, ID3D11Texture2D** ppTexture2D) {\n    #if defined(__cplusplus)\n        return self->CreateTexture2D(pDesc, pInitialData, ppTexture2D);\n    #else\n        return self->lpVtbl->CreateTexture2D(self, pDesc, pInitialData, ppTexture2D);\n    #endif\n}\n\nstatic inline HRESULT _sg_d3d11_CreateShaderResourceView(ID3D11Device* self, ID3D11Resource* pResource, const D3D11_SHADER_RESOURCE_VIEW_DESC* pDesc, ID3D11ShaderResourceView** ppSRView) {\n    #if defined(__cplusplus)\n        return self->CreateShaderResourceView(pResource, pDesc, ppSRView);\n    #else\n        return self->lpVtbl->CreateShaderResourceView(self, pResource, pDesc, ppSRView);\n    #endif\n}\n\nstatic inline void _sg_d3d11_GetResource(ID3D11View* self, ID3D11Resource** ppResource) {\n    #if defined(__cplusplus)\n        self->GetResource(ppResource);\n    #else\n        self->lpVtbl->GetResource(self, ppResource);\n    #endif\n}\n\nstatic inline HRESULT _sg_d3d11_CreateTexture3D(ID3D11Device* self, const D3D11_TEXTURE3D_DESC* pDesc, const D3D11_SUBRESOURCE_DATA* pInitialData, ID3D11Texture3D** ppTexture3D) {\n    #if defined(__cplusplus)\n        return self->CreateTexture3D(pDesc, pInitialData, ppTexture3D);\n    #else\n        return self->lpVtbl->CreateTexture3D(self, pDesc, pInitialData, ppTexture3D);\n    #endif\n}\n\nstatic inline HRESULT _sg_d3d11_CreateSamplerState(ID3D11Device* self, const D3D11_SAMPLER_DESC* pSamplerDesc, ID3D11SamplerState** ppSamplerState) {\n    #if defined(__cplusplus)\n        return self->CreateSamplerState(pSamplerDesc, ppSamplerState);\n    #else\n        return self->lpVtbl->CreateSamplerState(self, pSamplerDesc, ppSamplerState);\n    #endif\n}\n\nstatic inline LPVOID _sg_d3d11_GetBufferPointer(ID3D10Blob* self) {\n    #if defined(__cplusplus)\n        return self->GetBufferPointer();\n    #else\n        return self->lpVtbl->GetBufferPointer(self);\n    #endif\n}\n\nstatic inline SIZE_T _sg_d3d11_GetBufferSize(ID3D10Blob* self) {\n    #if defined(__cplusplus)\n        return self->GetBufferSize();\n    #else\n        return self->lpVtbl->GetBufferSize(self);\n    #endif\n}\n\nstatic inline HRESULT _sg_d3d11_CreateVertexShader(ID3D11Device* self, const void* pShaderBytecode, SIZE_T BytecodeLength, ID3D11ClassLinkage* pClassLinkage, ID3D11VertexShader** ppVertexShader) {\n    #if defined(__cplusplus)\n        return self->CreateVertexShader(pShaderBytecode, BytecodeLength, pClassLinkage, ppVertexShader);\n    #else\n        return self->lpVtbl->CreateVertexShader(self, pShaderBytecode, BytecodeLength, pClassLinkage, ppVertexShader);\n    #endif\n}\n\nstatic inline HRESULT _sg_d3d11_CreatePixelShader(ID3D11Device* self, const void* pShaderBytecode, SIZE_T BytecodeLength, ID3D11ClassLinkage* pClassLinkage, ID3D11PixelShader** ppPixelShader) {\n    #if defined(__cplusplus)\n        return self->CreatePixelShader(pShaderBytecode, BytecodeLength, pClassLinkage, ppPixelShader);\n    #else\n        return self->lpVtbl->CreatePixelShader(self, pShaderBytecode, BytecodeLength, pClassLinkage, ppPixelShader);\n    #endif\n}\n\nstatic inline HRESULT _sg_d3d11_CreateInputLayout(ID3D11Device* self, const D3D11_INPUT_ELEMENT_DESC* pInputElementDescs, UINT NumElements, const void* pShaderBytecodeWithInputSignature, SIZE_T BytecodeLength, ID3D11InputLayout **ppInputLayout) {\n    #if defined(__cplusplus)\n        return self->CreateInputLayout(pInputElementDescs, NumElements, pShaderBytecodeWithInputSignature, BytecodeLength, ppInputLayout);\n    #else\n        return self->lpVtbl->CreateInputLayout(self, pInputElementDescs, NumElements, pShaderBytecodeWithInputSignature, BytecodeLength, ppInputLayout);\n    #endif\n}\n\nstatic inline HRESULT _sg_d3d11_CreateRasterizerState(ID3D11Device* self, const D3D11_RASTERIZER_DESC* pRasterizerDesc, ID3D11RasterizerState** ppRasterizerState) {\n    #if defined(__cplusplus)\n        return self->CreateRasterizerState(pRasterizerDesc, ppRasterizerState);\n    #else\n        return self->lpVtbl->CreateRasterizerState(self, pRasterizerDesc, ppRasterizerState);\n    #endif\n}\n\nstatic inline HRESULT _sg_d3d11_CreateDepthStencilState(ID3D11Device* self, const D3D11_DEPTH_STENCIL_DESC* pDepthStencilDesc, ID3D11DepthStencilState** ppDepthStencilState) {\n    #if defined(__cplusplus)\n        return self->CreateDepthStencilState(pDepthStencilDesc, ppDepthStencilState);\n    #else\n        return self->lpVtbl->CreateDepthStencilState(self, pDepthStencilDesc, ppDepthStencilState);\n    #endif\n}\n\nstatic inline HRESULT _sg_d3d11_CreateBlendState(ID3D11Device* self, const D3D11_BLEND_DESC* pBlendStateDesc, ID3D11BlendState** ppBlendState) {\n    #if defined(__cplusplus)\n        return self->CreateBlendState(pBlendStateDesc, ppBlendState);\n    #else\n        return self->lpVtbl->CreateBlendState(self, pBlendStateDesc, ppBlendState);\n    #endif\n}\n\nstatic inline HRESULT _sg_d3d11_CreateRenderTargetView(ID3D11Device* self, ID3D11Resource *pResource, const D3D11_RENDER_TARGET_VIEW_DESC* pDesc, ID3D11RenderTargetView** ppRTView) {\n    #if defined(__cplusplus)\n        return self->CreateRenderTargetView(pResource, pDesc, ppRTView);\n    #else\n        return self->lpVtbl->CreateRenderTargetView(self, pResource, pDesc, ppRTView);\n    #endif\n}\n\nstatic inline HRESULT _sg_d3d11_CreateDepthStencilView(ID3D11Device* self, ID3D11Resource* pResource, const D3D11_DEPTH_STENCIL_VIEW_DESC* pDesc, ID3D11DepthStencilView** ppDepthStencilView) {\n    #if defined(__cplusplus)\n        return self->CreateDepthStencilView(pResource, pDesc, ppDepthStencilView);\n    #else\n        return self->lpVtbl->CreateDepthStencilView(self, pResource, pDesc, ppDepthStencilView);\n    #endif\n}\n\nstatic inline void _sg_d3d11_RSSetViewports(ID3D11DeviceContext* self, UINT NumViewports, const D3D11_VIEWPORT* pViewports) {\n    #if defined(__cplusplus)\n        self->RSSetViewports(NumViewports, pViewports);\n    #else\n        self->lpVtbl->RSSetViewports(self, NumViewports, pViewports);\n    #endif\n}\n\nstatic inline void _sg_d3d11_RSSetScissorRects(ID3D11DeviceContext* self, UINT NumRects, const D3D11_RECT* pRects) {\n    #if defined(__cplusplus)\n        self->RSSetScissorRects(NumRects, pRects);\n    #else\n        self->lpVtbl->RSSetScissorRects(self, NumRects, pRects);\n    #endif\n}\n\nstatic inline void _sg_d3d11_ClearRenderTargetView(ID3D11DeviceContext* self, ID3D11RenderTargetView* pRenderTargetView, const FLOAT ColorRGBA[4]) {\n    #if defined(__cplusplus)\n        self->ClearRenderTargetView(pRenderTargetView, ColorRGBA);\n    #else\n        self->lpVtbl->ClearRenderTargetView(self, pRenderTargetView, ColorRGBA);\n    #endif\n}\n\nstatic inline void _sg_d3d11_ClearDepthStencilView(ID3D11DeviceContext* self, ID3D11DepthStencilView* pDepthStencilView, UINT ClearFlags, FLOAT Depth, UINT8 Stencil) {\n    #if defined(__cplusplus)\n        self->ClearDepthStencilView(pDepthStencilView, ClearFlags, Depth, Stencil);\n    #else\n        self->lpVtbl->ClearDepthStencilView(self, pDepthStencilView, ClearFlags, Depth, Stencil);\n    #endif\n}\n\nstatic inline void _sg_d3d11_ResolveSubresource(ID3D11DeviceContext* self, ID3D11Resource* pDstResource, UINT DstSubresource, ID3D11Resource* pSrcResource, UINT SrcSubresource, DXGI_FORMAT Format) {\n    #if defined(__cplusplus)\n        self->ResolveSubresource(pDstResource, DstSubresource, pSrcResource, SrcSubresource, Format);\n    #else\n        self->lpVtbl->ResolveSubresource(self, pDstResource, DstSubresource, pSrcResource, SrcSubresource, Format);\n    #endif\n}\n\nstatic inline void _sg_d3d11_IASetPrimitiveTopology(ID3D11DeviceContext* self, D3D11_PRIMITIVE_TOPOLOGY Topology) {\n    #if defined(__cplusplus)\n        self->IASetPrimitiveTopology(Topology);\n    #else\n        self->lpVtbl->IASetPrimitiveTopology(self, Topology);\n    #endif\n}\n\nstatic inline void _sg_d3d11_UpdateSubresource(ID3D11DeviceContext* self, ID3D11Resource* pDstResource, UINT DstSubresource, const D3D11_BOX* pDstBox, const void* pSrcData, UINT SrcRowPitch, UINT SrcDepthPitch) {\n    #if defined(__cplusplus)\n        self->UpdateSubresource(pDstResource, DstSubresource, pDstBox, pSrcData, SrcRowPitch, SrcDepthPitch);\n    #else\n        self->lpVtbl->UpdateSubresource(self, pDstResource, DstSubresource, pDstBox, pSrcData, SrcRowPitch, SrcDepthPitch);\n    #endif\n}\n\nstatic inline void _sg_d3d11_DrawIndexed(ID3D11DeviceContext* self, UINT IndexCount, UINT StartIndexLocation, INT  BaseVertexLocation) {\n    #if defined(__cplusplus)\n        self->DrawIndexed(IndexCount, StartIndexLocation, BaseVertexLocation);\n    #else\n        self->lpVtbl->DrawIndexed(self, IndexCount, StartIndexLocation, BaseVertexLocation);\n    #endif\n}\n\nstatic inline void _sg_d3d11_DrawIndexedInstanced(ID3D11DeviceContext* self, UINT IndexCountPerInstance, UINT InstanceCount, UINT StartIndexLocation, INT BaseVertexLocation, UINT StartInstanceLocation) {\n    #if defined(__cplusplus)\n        self->DrawIndexedInstanced(IndexCountPerInstance, InstanceCount, StartIndexLocation, BaseVertexLocation, StartInstanceLocation);\n    #else\n        self->lpVtbl->DrawIndexedInstanced(self, IndexCountPerInstance, InstanceCount, StartIndexLocation, BaseVertexLocation, StartInstanceLocation);\n    #endif\n}\n\nstatic inline void _sg_d3d11_Draw(ID3D11DeviceContext* self, UINT VertexCount, UINT StartVertexLocation) {\n    #if defined(__cplusplus)\n        self->Draw(VertexCount, StartVertexLocation);\n    #else\n        self->lpVtbl->Draw(self, VertexCount, StartVertexLocation);\n    #endif\n}\n\nstatic inline void _sg_d3d11_DrawInstanced(ID3D11DeviceContext* self, UINT VertexCountPerInstance, UINT InstanceCount, UINT StartVertexLocation, UINT StartInstanceLocation) {\n    #if defined(__cplusplus)\n        self->DrawInstanced(VertexCountPerInstance, InstanceCount, StartVertexLocation, StartInstanceLocation);\n    #else\n        self->lpVtbl->DrawInstanced(self, VertexCountPerInstance, InstanceCount, StartVertexLocation, StartInstanceLocation);\n    #endif\n}\n\nstatic inline HRESULT _sg_d3d11_Map(ID3D11DeviceContext* self, ID3D11Resource* pResource, UINT Subresource, D3D11_MAP MapType, UINT MapFlags, D3D11_MAPPED_SUBRESOURCE* pMappedResource) {\n    #if defined(__cplusplus)\n        return self->Map(pResource, Subresource, MapType, MapFlags, pMappedResource);\n    #else\n        return self->lpVtbl->Map(self, pResource, Subresource, MapType, MapFlags, pMappedResource);\n    #endif\n}\n\nstatic inline void _sg_d3d11_Unmap(ID3D11DeviceContext* self, ID3D11Resource* pResource, UINT Subresource) {\n    #if defined(__cplusplus)\n        self->Unmap(pResource, Subresource);\n    #else\n        self->lpVtbl->Unmap(self, pResource, Subresource);\n    #endif\n}\n\nstatic inline void _sg_d3d11_ClearState(ID3D11DeviceContext* self) {\n    #if defined(__cplusplus)\n        self->ClearState();\n    #else\n        self->lpVtbl->ClearState(self);\n    #endif\n}\n\n//-- enum translation functions ------------------------------------------------\n_SOKOL_PRIVATE D3D11_USAGE _sg_d3d11_usage(sg_usage usg) {\n    switch (usg) {\n        case SG_USAGE_IMMUTABLE:\n            return D3D11_USAGE_IMMUTABLE;\n        case SG_USAGE_DYNAMIC:\n        case SG_USAGE_STREAM:\n            return D3D11_USAGE_DYNAMIC;\n        default:\n            SOKOL_UNREACHABLE;\n            return (D3D11_USAGE) 0;\n    }\n}\n\n_SOKOL_PRIVATE UINT _sg_d3d11_buffer_bind_flags(sg_buffer_type t) {\n    switch (t) {\n        case SG_BUFFERTYPE_VERTEXBUFFER:\n            return D3D11_BIND_VERTEX_BUFFER;\n        case SG_BUFFERTYPE_INDEXBUFFER:\n            return D3D11_BIND_INDEX_BUFFER;\n        case SG_BUFFERTYPE_STORAGEBUFFER:\n            // FIXME: for compute shaders we'd want UNORDERED_ACCESS?\n            return D3D11_BIND_SHADER_RESOURCE;\n        default:\n            SOKOL_UNREACHABLE;\n            return 0;\n    }\n}\n\n_SOKOL_PRIVATE UINT _sg_d3d11_buffer_misc_flags(sg_buffer_type t) {\n    switch (t) {\n        case SG_BUFFERTYPE_VERTEXBUFFER:\n        case SG_BUFFERTYPE_INDEXBUFFER:\n            return 0;\n        case SG_BUFFERTYPE_STORAGEBUFFER:\n            return D3D11_RESOURCE_MISC_BUFFER_ALLOW_RAW_VIEWS;\n        default:\n            SOKOL_UNREACHABLE;\n            return 0;\n    }\n}\n\n_SOKOL_PRIVATE UINT _sg_d3d11_cpu_access_flags(sg_usage usg) {\n    switch (usg) {\n        case SG_USAGE_IMMUTABLE:\n            return 0;\n        case SG_USAGE_DYNAMIC:\n        case SG_USAGE_STREAM:\n            return D3D11_CPU_ACCESS_WRITE;\n        default:\n            SOKOL_UNREACHABLE;\n            return 0;\n    }\n}\n\n_SOKOL_PRIVATE DXGI_FORMAT _sg_d3d11_texture_pixel_format(sg_pixel_format fmt) {\n    switch (fmt) {\n        case SG_PIXELFORMAT_R8:             return DXGI_FORMAT_R8_UNORM;\n        case SG_PIXELFORMAT_R8SN:           return DXGI_FORMAT_R8_SNORM;\n        case SG_PIXELFORMAT_R8UI:           return DXGI_FORMAT_R8_UINT;\n        case SG_PIXELFORMAT_R8SI:           return DXGI_FORMAT_R8_SINT;\n        case SG_PIXELFORMAT_R16:            return DXGI_FORMAT_R16_UNORM;\n        case SG_PIXELFORMAT_R16SN:          return DXGI_FORMAT_R16_SNORM;\n        case SG_PIXELFORMAT_R16UI:          return DXGI_FORMAT_R16_UINT;\n        case SG_PIXELFORMAT_R16SI:          return DXGI_FORMAT_R16_SINT;\n        case SG_PIXELFORMAT_R16F:           return DXGI_FORMAT_R16_FLOAT;\n        case SG_PIXELFORMAT_RG8:            return DXGI_FORMAT_R8G8_UNORM;\n        case SG_PIXELFORMAT_RG8SN:          return DXGI_FORMAT_R8G8_SNORM;\n        case SG_PIXELFORMAT_RG8UI:          return DXGI_FORMAT_R8G8_UINT;\n        case SG_PIXELFORMAT_RG8SI:          return DXGI_FORMAT_R8G8_SINT;\n        case SG_PIXELFORMAT_R32UI:          return DXGI_FORMAT_R32_UINT;\n        case SG_PIXELFORMAT_R32SI:          return DXGI_FORMAT_R32_SINT;\n        case SG_PIXELFORMAT_R32F:           return DXGI_FORMAT_R32_FLOAT;\n        case SG_PIXELFORMAT_RG16:           return DXGI_FORMAT_R16G16_UNORM;\n        case SG_PIXELFORMAT_RG16SN:         return DXGI_FORMAT_R16G16_SNORM;\n        case SG_PIXELFORMAT_RG16UI:         return DXGI_FORMAT_R16G16_UINT;\n        case SG_PIXELFORMAT_RG16SI:         return DXGI_FORMAT_R16G16_SINT;\n        case SG_PIXELFORMAT_RG16F:          return DXGI_FORMAT_R16G16_FLOAT;\n        case SG_PIXELFORMAT_RGBA8:          return DXGI_FORMAT_R8G8B8A8_UNORM;\n        case SG_PIXELFORMAT_SRGB8A8:        return DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;\n        case SG_PIXELFORMAT_RGBA8SN:        return DXGI_FORMAT_R8G8B8A8_SNORM;\n        case SG_PIXELFORMAT_RGBA8UI:        return DXGI_FORMAT_R8G8B8A8_UINT;\n        case SG_PIXELFORMAT_RGBA8SI:        return DXGI_FORMAT_R8G8B8A8_SINT;\n        case SG_PIXELFORMAT_BGRA8:          return DXGI_FORMAT_B8G8R8A8_UNORM;\n        case SG_PIXELFORMAT_RGB10A2:        return DXGI_FORMAT_R10G10B10A2_UNORM;\n        case SG_PIXELFORMAT_RG11B10F:       return DXGI_FORMAT_R11G11B10_FLOAT;\n        case SG_PIXELFORMAT_RGB9E5:         return DXGI_FORMAT_R9G9B9E5_SHAREDEXP;\n        case SG_PIXELFORMAT_RG32UI:         return DXGI_FORMAT_R32G32_UINT;\n        case SG_PIXELFORMAT_RG32SI:         return DXGI_FORMAT_R32G32_SINT;\n        case SG_PIXELFORMAT_RG32F:          return DXGI_FORMAT_R32G32_FLOAT;\n        case SG_PIXELFORMAT_RGBA16:         return DXGI_FORMAT_R16G16B16A16_UNORM;\n        case SG_PIXELFORMAT_RGBA16SN:       return DXGI_FORMAT_R16G16B16A16_SNORM;\n        case SG_PIXELFORMAT_RGBA16UI:       return DXGI_FORMAT_R16G16B16A16_UINT;\n        case SG_PIXELFORMAT_RGBA16SI:       return DXGI_FORMAT_R16G16B16A16_SINT;\n        case SG_PIXELFORMAT_RGBA16F:        return DXGI_FORMAT_R16G16B16A16_FLOAT;\n        case SG_PIXELFORMAT_RGBA32UI:       return DXGI_FORMAT_R32G32B32A32_UINT;\n        case SG_PIXELFORMAT_RGBA32SI:       return DXGI_FORMAT_R32G32B32A32_SINT;\n        case SG_PIXELFORMAT_RGBA32F:        return DXGI_FORMAT_R32G32B32A32_FLOAT;\n        case SG_PIXELFORMAT_DEPTH:          return DXGI_FORMAT_R32_TYPELESS;\n        case SG_PIXELFORMAT_DEPTH_STENCIL:  return DXGI_FORMAT_R24G8_TYPELESS;\n        case SG_PIXELFORMAT_BC1_RGBA:       return DXGI_FORMAT_BC1_UNORM;\n        case SG_PIXELFORMAT_BC2_RGBA:       return DXGI_FORMAT_BC2_UNORM;\n        case SG_PIXELFORMAT_BC3_RGBA:       return DXGI_FORMAT_BC3_UNORM;\n        case SG_PIXELFORMAT_BC3_SRGBA:      return DXGI_FORMAT_BC3_UNORM_SRGB;\n        case SG_PIXELFORMAT_BC4_R:          return DXGI_FORMAT_BC4_UNORM;\n        case SG_PIXELFORMAT_BC4_RSN:        return DXGI_FORMAT_BC4_SNORM;\n        case SG_PIXELFORMAT_BC5_RG:         return DXGI_FORMAT_BC5_UNORM;\n        case SG_PIXELFORMAT_BC5_RGSN:       return DXGI_FORMAT_BC5_SNORM;\n        case SG_PIXELFORMAT_BC6H_RGBF:      return DXGI_FORMAT_BC6H_SF16;\n        case SG_PIXELFORMAT_BC6H_RGBUF:     return DXGI_FORMAT_BC6H_UF16;\n        case SG_PIXELFORMAT_BC7_RGBA:       return DXGI_FORMAT_BC7_UNORM;\n        case SG_PIXELFORMAT_BC7_SRGBA:      return DXGI_FORMAT_BC7_UNORM_SRGB;\n        default:                            return DXGI_FORMAT_UNKNOWN;\n    };\n}\n\n_SOKOL_PRIVATE DXGI_FORMAT _sg_d3d11_srv_pixel_format(sg_pixel_format fmt) {\n    if (fmt == SG_PIXELFORMAT_DEPTH) {\n        return DXGI_FORMAT_R32_FLOAT;\n    } else if (fmt == SG_PIXELFORMAT_DEPTH_STENCIL) {\n        return DXGI_FORMAT_R24_UNORM_X8_TYPELESS;\n    } else {\n        return _sg_d3d11_texture_pixel_format(fmt);\n    }\n}\n\n_SOKOL_PRIVATE DXGI_FORMAT _sg_d3d11_dsv_pixel_format(sg_pixel_format fmt) {\n    if (fmt == SG_PIXELFORMAT_DEPTH) {\n        return DXGI_FORMAT_D32_FLOAT;\n    } else if (fmt == SG_PIXELFORMAT_DEPTH_STENCIL) {\n        return DXGI_FORMAT_D24_UNORM_S8_UINT;\n    } else {\n        return _sg_d3d11_texture_pixel_format(fmt);\n    }\n}\n\n_SOKOL_PRIVATE DXGI_FORMAT _sg_d3d11_rtv_pixel_format(sg_pixel_format fmt) {\n    if (fmt == SG_PIXELFORMAT_DEPTH) {\n        return DXGI_FORMAT_R32_FLOAT;\n    } else if (fmt == SG_PIXELFORMAT_DEPTH_STENCIL) {\n        return DXGI_FORMAT_R24_UNORM_X8_TYPELESS;\n    } else {\n        return _sg_d3d11_texture_pixel_format(fmt);\n    }\n}\n\n_SOKOL_PRIVATE D3D11_PRIMITIVE_TOPOLOGY _sg_d3d11_primitive_topology(sg_primitive_type prim_type) {\n    switch (prim_type) {\n        case SG_PRIMITIVETYPE_POINTS:           return D3D11_PRIMITIVE_TOPOLOGY_POINTLIST;\n        case SG_PRIMITIVETYPE_LINES:            return D3D11_PRIMITIVE_TOPOLOGY_LINELIST;\n        case SG_PRIMITIVETYPE_LINE_STRIP:       return D3D11_PRIMITIVE_TOPOLOGY_LINESTRIP;\n        case SG_PRIMITIVETYPE_TRIANGLES:        return D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST;\n        case SG_PRIMITIVETYPE_TRIANGLE_STRIP:   return D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP;\n        default: SOKOL_UNREACHABLE; return (D3D11_PRIMITIVE_TOPOLOGY) 0;\n    }\n}\n\n_SOKOL_PRIVATE DXGI_FORMAT _sg_d3d11_index_format(sg_index_type index_type) {\n    switch (index_type) {\n        case SG_INDEXTYPE_NONE:     return DXGI_FORMAT_UNKNOWN;\n        case SG_INDEXTYPE_UINT16:   return DXGI_FORMAT_R16_UINT;\n        case SG_INDEXTYPE_UINT32:   return DXGI_FORMAT_R32_UINT;\n        default: SOKOL_UNREACHABLE; return (DXGI_FORMAT) 0;\n    }\n}\n\n_SOKOL_PRIVATE D3D11_FILTER _sg_d3d11_filter(sg_filter min_f, sg_filter mag_f, sg_filter mipmap_f, bool comparison, uint32_t max_anisotropy) {\n    uint32_t d3d11_filter = 0;\n    if (max_anisotropy > 1) {\n        // D3D11_FILTER_ANISOTROPIC = 0x55,\n        d3d11_filter |= 0x55;\n    } else {\n        // D3D11_FILTER_MIN_MAG_MIP_POINT = 0,\n        // D3D11_FILTER_MIN_MAG_POINT_MIP_LINEAR = 0x1,\n        // D3D11_FILTER_MIN_POINT_MAG_LINEAR_MIP_POINT = 0x4,\n        // D3D11_FILTER_MIN_POINT_MAG_MIP_LINEAR = 0x5,\n        // D3D11_FILTER_MIN_LINEAR_MAG_MIP_POINT = 0x10,\n        // D3D11_FILTER_MIN_LINEAR_MAG_POINT_MIP_LINEAR = 0x11,\n        // D3D11_FILTER_MIN_MAG_LINEAR_MIP_POINT = 0x14,\n        // D3D11_FILTER_MIN_MAG_MIP_LINEAR = 0x15,\n        if (mipmap_f == SG_FILTER_LINEAR) {\n            d3d11_filter |= 0x01;\n        }\n        if (mag_f == SG_FILTER_LINEAR) {\n            d3d11_filter |= 0x04;\n        }\n        if (min_f == SG_FILTER_LINEAR) {\n            d3d11_filter |= 0x10;\n        }\n    }\n    // D3D11_FILTER_COMPARISON_MIN_MAG_MIP_POINT = 0x80,\n    // D3D11_FILTER_COMPARISON_MIN_MAG_POINT_MIP_LINEAR = 0x81,\n    // D3D11_FILTER_COMPARISON_MIN_POINT_MAG_LINEAR_MIP_POINT = 0x84,\n    // D3D11_FILTER_COMPARISON_MIN_POINT_MAG_MIP_LINEAR = 0x85,\n    // D3D11_FILTER_COMPARISON_MIN_LINEAR_MAG_MIP_POINT = 0x90,\n    // D3D11_FILTER_COMPARISON_MIN_LINEAR_MAG_POINT_MIP_LINEAR = 0x91,\n    // D3D11_FILTER_COMPARISON_MIN_MAG_LINEAR_MIP_POINT = 0x94,\n    // D3D11_FILTER_COMPARISON_MIN_MAG_MIP_LINEAR = 0x95,\n    // D3D11_FILTER_COMPARISON_ANISOTROPIC = 0xd5,\n    if (comparison) {\n        d3d11_filter |= 0x80;\n    }\n    return (D3D11_FILTER)d3d11_filter;\n}\n\n_SOKOL_PRIVATE D3D11_TEXTURE_ADDRESS_MODE _sg_d3d11_address_mode(sg_wrap m) {\n    switch (m) {\n        case SG_WRAP_REPEAT:            return D3D11_TEXTURE_ADDRESS_WRAP;\n        case SG_WRAP_CLAMP_TO_EDGE:     return D3D11_TEXTURE_ADDRESS_CLAMP;\n        case SG_WRAP_CLAMP_TO_BORDER:   return D3D11_TEXTURE_ADDRESS_BORDER;\n        case SG_WRAP_MIRRORED_REPEAT:   return D3D11_TEXTURE_ADDRESS_MIRROR;\n        default: SOKOL_UNREACHABLE; return (D3D11_TEXTURE_ADDRESS_MODE) 0;\n    }\n}\n\n_SOKOL_PRIVATE DXGI_FORMAT _sg_d3d11_vertex_format(sg_vertex_format fmt) {\n    switch (fmt) {\n        case SG_VERTEXFORMAT_FLOAT:     return DXGI_FORMAT_R32_FLOAT;\n        case SG_VERTEXFORMAT_FLOAT2:    return DXGI_FORMAT_R32G32_FLOAT;\n        case SG_VERTEXFORMAT_FLOAT3:    return DXGI_FORMAT_R32G32B32_FLOAT;\n        case SG_VERTEXFORMAT_FLOAT4:    return DXGI_FORMAT_R32G32B32A32_FLOAT;\n        case SG_VERTEXFORMAT_BYTE4:     return DXGI_FORMAT_R8G8B8A8_SINT;\n        case SG_VERTEXFORMAT_BYTE4N:    return DXGI_FORMAT_R8G8B8A8_SNORM;\n        case SG_VERTEXFORMAT_UBYTE4:    return DXGI_FORMAT_R8G8B8A8_UINT;\n        case SG_VERTEXFORMAT_UBYTE4N:   return DXGI_FORMAT_R8G8B8A8_UNORM;\n        case SG_VERTEXFORMAT_SHORT2:    return DXGI_FORMAT_R16G16_SINT;\n        case SG_VERTEXFORMAT_SHORT2N:   return DXGI_FORMAT_R16G16_SNORM;\n        case SG_VERTEXFORMAT_USHORT2N:  return DXGI_FORMAT_R16G16_UNORM;\n        case SG_VERTEXFORMAT_SHORT4:    return DXGI_FORMAT_R16G16B16A16_SINT;\n        case SG_VERTEXFORMAT_SHORT4N:   return DXGI_FORMAT_R16G16B16A16_SNORM;\n        case SG_VERTEXFORMAT_USHORT4N:  return DXGI_FORMAT_R16G16B16A16_UNORM;\n        case SG_VERTEXFORMAT_UINT10_N2: return DXGI_FORMAT_R10G10B10A2_UNORM;\n        case SG_VERTEXFORMAT_HALF2:     return DXGI_FORMAT_R16G16_FLOAT;\n        case SG_VERTEXFORMAT_HALF4:     return DXGI_FORMAT_R16G16B16A16_FLOAT;\n        default: SOKOL_UNREACHABLE; return (DXGI_FORMAT) 0;\n    }\n}\n\n_SOKOL_PRIVATE D3D11_INPUT_CLASSIFICATION _sg_d3d11_input_classification(sg_vertex_step step) {\n    switch (step) {\n        case SG_VERTEXSTEP_PER_VERTEX:      return D3D11_INPUT_PER_VERTEX_DATA;\n        case SG_VERTEXSTEP_PER_INSTANCE:    return D3D11_INPUT_PER_INSTANCE_DATA;\n        default: SOKOL_UNREACHABLE; return (D3D11_INPUT_CLASSIFICATION) 0;\n    }\n}\n\n_SOKOL_PRIVATE D3D11_CULL_MODE _sg_d3d11_cull_mode(sg_cull_mode m) {\n    switch (m) {\n        case SG_CULLMODE_NONE:      return D3D11_CULL_NONE;\n        case SG_CULLMODE_FRONT:     return D3D11_CULL_FRONT;\n        case SG_CULLMODE_BACK:      return D3D11_CULL_BACK;\n        default: SOKOL_UNREACHABLE; return (D3D11_CULL_MODE) 0;\n    }\n}\n\n_SOKOL_PRIVATE D3D11_COMPARISON_FUNC _sg_d3d11_compare_func(sg_compare_func f) {\n    switch (f) {\n        case SG_COMPAREFUNC_NEVER:          return D3D11_COMPARISON_NEVER;\n        case SG_COMPAREFUNC_LESS:           return D3D11_COMPARISON_LESS;\n        case SG_COMPAREFUNC_EQUAL:          return D3D11_COMPARISON_EQUAL;\n        case SG_COMPAREFUNC_LESS_EQUAL:     return D3D11_COMPARISON_LESS_EQUAL;\n        case SG_COMPAREFUNC_GREATER:        return D3D11_COMPARISON_GREATER;\n        case SG_COMPAREFUNC_NOT_EQUAL:      return D3D11_COMPARISON_NOT_EQUAL;\n        case SG_COMPAREFUNC_GREATER_EQUAL:  return D3D11_COMPARISON_GREATER_EQUAL;\n        case SG_COMPAREFUNC_ALWAYS:         return D3D11_COMPARISON_ALWAYS;\n        default: SOKOL_UNREACHABLE; return (D3D11_COMPARISON_FUNC) 0;\n    }\n}\n\n_SOKOL_PRIVATE D3D11_STENCIL_OP _sg_d3d11_stencil_op(sg_stencil_op op) {\n    switch (op) {\n        case SG_STENCILOP_KEEP:         return D3D11_STENCIL_OP_KEEP;\n        case SG_STENCILOP_ZERO:         return D3D11_STENCIL_OP_ZERO;\n        case SG_STENCILOP_REPLACE:      return D3D11_STENCIL_OP_REPLACE;\n        case SG_STENCILOP_INCR_CLAMP:   return D3D11_STENCIL_OP_INCR_SAT;\n        case SG_STENCILOP_DECR_CLAMP:   return D3D11_STENCIL_OP_DECR_SAT;\n        case SG_STENCILOP_INVERT:       return D3D11_STENCIL_OP_INVERT;\n        case SG_STENCILOP_INCR_WRAP:    return D3D11_STENCIL_OP_INCR;\n        case SG_STENCILOP_DECR_WRAP:    return D3D11_STENCIL_OP_DECR;\n        default: SOKOL_UNREACHABLE; return (D3D11_STENCIL_OP) 0;\n    }\n}\n\n_SOKOL_PRIVATE D3D11_BLEND _sg_d3d11_blend_factor(sg_blend_factor f) {\n    switch (f) {\n        case SG_BLENDFACTOR_ZERO:                   return D3D11_BLEND_ZERO;\n        case SG_BLENDFACTOR_ONE:                    return D3D11_BLEND_ONE;\n        case SG_BLENDFACTOR_SRC_COLOR:              return D3D11_BLEND_SRC_COLOR;\n        case SG_BLENDFACTOR_ONE_MINUS_SRC_COLOR:    return D3D11_BLEND_INV_SRC_COLOR;\n        case SG_BLENDFACTOR_SRC_ALPHA:              return D3D11_BLEND_SRC_ALPHA;\n        case SG_BLENDFACTOR_ONE_MINUS_SRC_ALPHA:    return D3D11_BLEND_INV_SRC_ALPHA;\n        case SG_BLENDFACTOR_DST_COLOR:              return D3D11_BLEND_DEST_COLOR;\n        case SG_BLENDFACTOR_ONE_MINUS_DST_COLOR:    return D3D11_BLEND_INV_DEST_COLOR;\n        case SG_BLENDFACTOR_DST_ALPHA:              return D3D11_BLEND_DEST_ALPHA;\n        case SG_BLENDFACTOR_ONE_MINUS_DST_ALPHA:    return D3D11_BLEND_INV_DEST_ALPHA;\n        case SG_BLENDFACTOR_SRC_ALPHA_SATURATED:    return D3D11_BLEND_SRC_ALPHA_SAT;\n        case SG_BLENDFACTOR_BLEND_COLOR:            return D3D11_BLEND_BLEND_FACTOR;\n        case SG_BLENDFACTOR_ONE_MINUS_BLEND_COLOR:  return D3D11_BLEND_INV_BLEND_FACTOR;\n        case SG_BLENDFACTOR_BLEND_ALPHA:            return D3D11_BLEND_BLEND_FACTOR;\n        case SG_BLENDFACTOR_ONE_MINUS_BLEND_ALPHA:  return D3D11_BLEND_INV_BLEND_FACTOR;\n        default: SOKOL_UNREACHABLE; return (D3D11_BLEND) 0;\n    }\n}\n\n_SOKOL_PRIVATE D3D11_BLEND_OP _sg_d3d11_blend_op(sg_blend_op op) {\n    switch (op) {\n        case SG_BLENDOP_ADD:                return D3D11_BLEND_OP_ADD;\n        case SG_BLENDOP_SUBTRACT:           return D3D11_BLEND_OP_SUBTRACT;\n        case SG_BLENDOP_REVERSE_SUBTRACT:   return D3D11_BLEND_OP_REV_SUBTRACT;\n        default: SOKOL_UNREACHABLE; return (D3D11_BLEND_OP) 0;\n    }\n}\n\n_SOKOL_PRIVATE UINT8 _sg_d3d11_color_write_mask(sg_color_mask m) {\n    UINT8 res = 0;\n    if (m & SG_COLORMASK_R) {\n        res |= D3D11_COLOR_WRITE_ENABLE_RED;\n    }\n    if (m & SG_COLORMASK_G) {\n        res |= D3D11_COLOR_WRITE_ENABLE_GREEN;\n    }\n    if (m & SG_COLORMASK_B) {\n        res |= D3D11_COLOR_WRITE_ENABLE_BLUE;\n    }\n    if (m & SG_COLORMASK_A) {\n        res |= D3D11_COLOR_WRITE_ENABLE_ALPHA;\n    }\n    return res;\n}\n\n_SOKOL_PRIVATE UINT _sg_d3d11_dxgi_fmt_caps(DXGI_FORMAT dxgi_fmt) {\n    UINT dxgi_fmt_caps = 0;\n    if (dxgi_fmt != DXGI_FORMAT_UNKNOWN) {\n        HRESULT hr = _sg_d3d11_CheckFormatSupport(_sg.d3d11.dev, dxgi_fmt, &dxgi_fmt_caps);\n        SOKOL_ASSERT(SUCCEEDED(hr) || (E_FAIL == hr));\n        if (!SUCCEEDED(hr)) {\n            dxgi_fmt_caps = 0;\n        }\n    }\n    return dxgi_fmt_caps;\n}\n\n// see: https://docs.microsoft.com/en-us/windows/win32/direct3d11/overviews-direct3d-11-resources-limits#resource-limits-for-feature-level-11-hardware\n_SOKOL_PRIVATE void _sg_d3d11_init_caps(void) {\n    _sg.backend = SG_BACKEND_D3D11;\n\n    _sg.features.origin_top_left = true;\n    _sg.features.image_clamp_to_border = true;\n    _sg.features.mrt_independent_blend_state = true;\n    _sg.features.mrt_independent_write_mask = true;\n    _sg.features.storage_buffer = true;\n    _sg.features.msaa_image_bindings = true;\n\n    _sg.limits.max_image_size_2d = 16 * 1024;\n    _sg.limits.max_image_size_cube = 16 * 1024;\n    _sg.limits.max_image_size_3d = 2 * 1024;\n    _sg.limits.max_image_size_array = 16 * 1024;\n    _sg.limits.max_image_array_layers = 2 * 1024;\n    _sg.limits.max_vertex_attrs = SG_MAX_VERTEX_ATTRIBUTES;\n\n    // see: https://docs.microsoft.com/en-us/windows/win32/api/d3d11/ne-d3d11-d3d11_format_support\n    for (int fmt = (SG_PIXELFORMAT_NONE+1); fmt < _SG_PIXELFORMAT_NUM; fmt++) {\n        const UINT srv_dxgi_fmt_caps = _sg_d3d11_dxgi_fmt_caps(_sg_d3d11_srv_pixel_format((sg_pixel_format)fmt));\n        const UINT rtv_dxgi_fmt_caps = _sg_d3d11_dxgi_fmt_caps(_sg_d3d11_rtv_pixel_format((sg_pixel_format)fmt));\n        const UINT dsv_dxgi_fmt_caps = _sg_d3d11_dxgi_fmt_caps(_sg_d3d11_dsv_pixel_format((sg_pixel_format)fmt));\n        _sg_pixelformat_info_t* info = &_sg.formats[fmt];\n        const bool render = 0 != (rtv_dxgi_fmt_caps & D3D11_FORMAT_SUPPORT_RENDER_TARGET);\n        const bool depth  = 0 != (dsv_dxgi_fmt_caps & D3D11_FORMAT_SUPPORT_DEPTH_STENCIL);\n        info->sample = 0 != (srv_dxgi_fmt_caps & D3D11_FORMAT_SUPPORT_TEXTURE2D);\n        info->filter = 0 != (srv_dxgi_fmt_caps & D3D11_FORMAT_SUPPORT_SHADER_SAMPLE);\n        info->render = render || depth;\n        info->blend  = 0 != (rtv_dxgi_fmt_caps & D3D11_FORMAT_SUPPORT_BLENDABLE);\n        info->msaa   = 0 != (rtv_dxgi_fmt_caps & D3D11_FORMAT_SUPPORT_MULTISAMPLE_RENDERTARGET);\n        info->depth  = depth;\n    }\n}\n\n_SOKOL_PRIVATE void _sg_d3d11_setup_backend(const sg_desc* desc) {\n    // assume _sg.d3d11 already is zero-initialized\n    SOKOL_ASSERT(desc);\n    SOKOL_ASSERT(desc->environment.d3d11.device);\n    SOKOL_ASSERT(desc->environment.d3d11.device_context);\n    _sg.d3d11.valid = true;\n    _sg.d3d11.dev = (ID3D11Device*) desc->environment.d3d11.device;\n    _sg.d3d11.ctx = (ID3D11DeviceContext*) desc->environment.d3d11.device_context;\n    _sg_d3d11_init_caps();\n}\n\n_SOKOL_PRIVATE void _sg_d3d11_discard_backend(void) {\n    SOKOL_ASSERT(_sg.d3d11.valid);\n    _sg.d3d11.valid = false;\n}\n\n_SOKOL_PRIVATE void _sg_d3d11_clear_state(void) {\n    // clear all the device context state, so that resource refs don't keep stuck in the d3d device context\n    _sg_d3d11_ClearState(_sg.d3d11.ctx);\n}\n\n_SOKOL_PRIVATE void _sg_d3d11_reset_state_cache(void) {\n    // there's currently no state cache in the D3D11 backend, so this is a no-op\n}\n\n_SOKOL_PRIVATE sg_resource_state _sg_d3d11_create_buffer(_sg_buffer_t* buf, const sg_buffer_desc* desc) {\n    SOKOL_ASSERT(buf && desc);\n    SOKOL_ASSERT(!buf->d3d11.buf);\n    const bool injected = (0 != desc->d3d11_buffer);\n    if (injected) {\n        buf->d3d11.buf = (ID3D11Buffer*) desc->d3d11_buffer;\n        _sg_d3d11_AddRef(buf->d3d11.buf);\n        // FIXME: for storage buffers also need to inject resource view\n    } else {\n        D3D11_BUFFER_DESC d3d11_buf_desc;\n        _sg_clear(&d3d11_buf_desc, sizeof(d3d11_buf_desc));\n        d3d11_buf_desc.ByteWidth = (UINT)buf->cmn.size;\n        d3d11_buf_desc.Usage = _sg_d3d11_usage(buf->cmn.usage);\n        d3d11_buf_desc.BindFlags = _sg_d3d11_buffer_bind_flags(buf->cmn.type);\n        d3d11_buf_desc.CPUAccessFlags = _sg_d3d11_cpu_access_flags(buf->cmn.usage);\n        d3d11_buf_desc.MiscFlags = _sg_d3d11_buffer_misc_flags(buf->cmn.type);\n        D3D11_SUBRESOURCE_DATA* init_data_ptr = 0;\n        D3D11_SUBRESOURCE_DATA init_data;\n        _sg_clear(&init_data, sizeof(init_data));\n        if (buf->cmn.usage == SG_USAGE_IMMUTABLE) {\n            SOKOL_ASSERT(desc->data.ptr);\n            init_data.pSysMem = desc->data.ptr;\n            init_data_ptr = &init_data;\n        }\n        HRESULT hr = _sg_d3d11_CreateBuffer(_sg.d3d11.dev, &d3d11_buf_desc, init_data_ptr, &buf->d3d11.buf);\n        if (!(SUCCEEDED(hr) && buf->d3d11.buf)) {\n            _SG_ERROR(D3D11_CREATE_BUFFER_FAILED);\n            return SG_RESOURCESTATE_FAILED;\n        }\n\n        // for storage buffers need to create a view object\n        if (buf->cmn.type == SG_BUFFERTYPE_STORAGEBUFFER) {\n            // FIXME: currently only shader-resource-view, in future also UAV\n            // storage buffer size must be multiple of 4\n            SOKOL_ASSERT(_sg_multiple_u64(buf->cmn.size, 4));\n            D3D11_SHADER_RESOURCE_VIEW_DESC d3d11_srv_desc;\n            _sg_clear(&d3d11_srv_desc, sizeof(d3d11_srv_desc));\n            d3d11_srv_desc.Format = DXGI_FORMAT_R32_TYPELESS;\n            d3d11_srv_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFEREX;\n            d3d11_srv_desc.BufferEx.FirstElement = 0;\n            d3d11_srv_desc.BufferEx.NumElements = buf->cmn.size / 4;\n            d3d11_srv_desc.BufferEx.Flags = D3D11_BUFFEREX_SRV_FLAG_RAW;\n            hr = _sg_d3d11_CreateShaderResourceView(_sg.d3d11.dev, (ID3D11Resource*)buf->d3d11.buf, &d3d11_srv_desc, &buf->d3d11.srv);\n            if (!(SUCCEEDED(hr) && buf->d3d11.srv)) {\n                _SG_ERROR(D3D11_CREATE_BUFFER_SRV_FAILED);\n                return SG_RESOURCESTATE_FAILED;\n            }\n        }\n        _sg_d3d11_setlabel(buf->d3d11.buf, desc->label);\n    }\n    return SG_RESOURCESTATE_VALID;\n}\n\n_SOKOL_PRIVATE void _sg_d3d11_discard_buffer(_sg_buffer_t* buf) {\n    SOKOL_ASSERT(buf);\n    if (buf->d3d11.buf) {\n        _sg_d3d11_Release(buf->d3d11.buf);\n    }\n    if (buf->d3d11.srv) {\n        _sg_d3d11_Release(buf->d3d11.srv);\n    }\n}\n\n_SOKOL_PRIVATE void _sg_d3d11_fill_subres_data(const _sg_image_t* img, const sg_image_data* data) {\n    const int num_faces = (img->cmn.type == SG_IMAGETYPE_CUBE) ? 6:1;\n    const int num_slices = (img->cmn.type == SG_IMAGETYPE_ARRAY) ? img->cmn.num_slices:1;\n    int subres_index = 0;\n    for (int face_index = 0; face_index < num_faces; face_index++) {\n        for (int slice_index = 0; slice_index < num_slices; slice_index++) {\n            for (int mip_index = 0; mip_index < img->cmn.num_mipmaps; mip_index++, subres_index++) {\n                SOKOL_ASSERT(subres_index < (SG_MAX_MIPMAPS * SG_MAX_TEXTUREARRAY_LAYERS));\n                D3D11_SUBRESOURCE_DATA* subres_data = &_sg.d3d11.subres_data[subres_index];\n                const int mip_width = _sg_miplevel_dim(img->cmn.width, mip_index);\n                const int mip_height = _sg_miplevel_dim(img->cmn.height, mip_index);\n                const sg_range* subimg_data = &(data->subimage[face_index][mip_index]);\n                const size_t slice_size = subimg_data->size / (size_t)num_slices;\n                const size_t slice_offset = slice_size * (size_t)slice_index;\n                const uint8_t* ptr = (const uint8_t*) subimg_data->ptr;\n                subres_data->pSysMem = ptr + slice_offset;\n                subres_data->SysMemPitch = (UINT)_sg_row_pitch(img->cmn.pixel_format, mip_width, 1);\n                if (img->cmn.type == SG_IMAGETYPE_3D) {\n                    // FIXME? const int mip_depth = _sg_miplevel_dim(img->depth, mip_index);\n                    subres_data->SysMemSlicePitch = (UINT)_sg_surface_pitch(img->cmn.pixel_format, mip_width, mip_height, 1);\n                } else {\n                    subres_data->SysMemSlicePitch = 0;\n                }\n            }\n        }\n    }\n}\n\n_SOKOL_PRIVATE sg_resource_state _sg_d3d11_create_image(_sg_image_t* img, const sg_image_desc* desc) {\n    SOKOL_ASSERT(img && desc);\n    SOKOL_ASSERT((0 == img->d3d11.tex2d) && (0 == img->d3d11.tex3d) && (0 == img->d3d11.res) && (0 == img->d3d11.srv));\n    HRESULT hr;\n\n    const bool injected = (0 != desc->d3d11_texture);\n    const bool msaa = (img->cmn.sample_count > 1);\n    SOKOL_ASSERT(!(msaa && (img->cmn.type == SG_IMAGETYPE_CUBE)));\n    img->d3d11.format = _sg_d3d11_texture_pixel_format(img->cmn.pixel_format);\n    if (img->d3d11.format == DXGI_FORMAT_UNKNOWN) {\n        _SG_ERROR(D3D11_CREATE_2D_TEXTURE_UNSUPPORTED_PIXEL_FORMAT);\n        return SG_RESOURCESTATE_FAILED;\n    }\n\n    // prepare initial content pointers\n    D3D11_SUBRESOURCE_DATA* init_data = 0;\n    if (!injected && (img->cmn.usage == SG_USAGE_IMMUTABLE) && !img->cmn.render_target) {\n        _sg_d3d11_fill_subres_data(img, &desc->data);\n        init_data = _sg.d3d11.subres_data;\n    }\n    if (img->cmn.type != SG_IMAGETYPE_3D) {\n        // 2D-, cube- or array-texture\n        // first check for injected texture and/or resource view\n        if (injected) {\n            img->d3d11.tex2d = (ID3D11Texture2D*) desc->d3d11_texture;\n            _sg_d3d11_AddRef(img->d3d11.tex2d);\n            img->d3d11.srv = (ID3D11ShaderResourceView*) desc->d3d11_shader_resource_view;\n            if (img->d3d11.srv) {\n                _sg_d3d11_AddRef(img->d3d11.srv);\n            }\n        } else {\n            // if not injected, create 2D texture\n            D3D11_TEXTURE2D_DESC d3d11_tex_desc;\n            _sg_clear(&d3d11_tex_desc, sizeof(d3d11_tex_desc));\n            d3d11_tex_desc.Width = (UINT)img->cmn.width;\n            d3d11_tex_desc.Height = (UINT)img->cmn.height;\n            d3d11_tex_desc.MipLevels = (UINT)img->cmn.num_mipmaps;\n            switch (img->cmn.type) {\n                case SG_IMAGETYPE_ARRAY:    d3d11_tex_desc.ArraySize = (UINT)img->cmn.num_slices; break;\n                case SG_IMAGETYPE_CUBE:     d3d11_tex_desc.ArraySize = 6; break;\n                default:                    d3d11_tex_desc.ArraySize = 1; break;\n            }\n            d3d11_tex_desc.Format = img->d3d11.format;\n            d3d11_tex_desc.BindFlags = D3D11_BIND_SHADER_RESOURCE;\n            if (img->cmn.render_target) {\n                d3d11_tex_desc.Usage = D3D11_USAGE_DEFAULT;\n                if (_sg_is_depth_or_depth_stencil_format(img->cmn.pixel_format)) {\n                    d3d11_tex_desc.BindFlags |= D3D11_BIND_DEPTH_STENCIL;\n                } else {\n                    d3d11_tex_desc.BindFlags |= D3D11_BIND_RENDER_TARGET;\n                }\n                d3d11_tex_desc.CPUAccessFlags = 0;\n            } else {\n                d3d11_tex_desc.Usage = _sg_d3d11_usage(img->cmn.usage);\n                d3d11_tex_desc.CPUAccessFlags = _sg_d3d11_cpu_access_flags(img->cmn.usage);\n            }\n            d3d11_tex_desc.SampleDesc.Count = (UINT)img->cmn.sample_count;\n            d3d11_tex_desc.SampleDesc.Quality = (UINT) (msaa ? D3D11_STANDARD_MULTISAMPLE_PATTERN : 0);\n            d3d11_tex_desc.MiscFlags = (img->cmn.type == SG_IMAGETYPE_CUBE) ? D3D11_RESOURCE_MISC_TEXTURECUBE : 0;\n\n            hr = _sg_d3d11_CreateTexture2D(_sg.d3d11.dev, &d3d11_tex_desc, init_data, &img->d3d11.tex2d);\n            if (!(SUCCEEDED(hr) && img->d3d11.tex2d)) {\n                _SG_ERROR(D3D11_CREATE_2D_TEXTURE_FAILED);\n                return SG_RESOURCESTATE_FAILED;\n            }\n            _sg_d3d11_setlabel(img->d3d11.tex2d, desc->label);\n\n            // create shader-resource-view for 2D texture\n            D3D11_SHADER_RESOURCE_VIEW_DESC d3d11_srv_desc;\n            _sg_clear(&d3d11_srv_desc, sizeof(d3d11_srv_desc));\n            d3d11_srv_desc.Format = _sg_d3d11_srv_pixel_format(img->cmn.pixel_format);\n            switch (img->cmn.type) {\n                case SG_IMAGETYPE_2D:\n                    d3d11_srv_desc.ViewDimension = msaa ? D3D11_SRV_DIMENSION_TEXTURE2DMS : D3D11_SRV_DIMENSION_TEXTURE2D;\n                    d3d11_srv_desc.Texture2D.MipLevels = (UINT)img->cmn.num_mipmaps;\n                    break;\n                case SG_IMAGETYPE_CUBE:\n                    d3d11_srv_desc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURECUBE;\n                    d3d11_srv_desc.TextureCube.MipLevels = (UINT)img->cmn.num_mipmaps;\n                    break;\n                case SG_IMAGETYPE_ARRAY:\n                    d3d11_srv_desc.ViewDimension = msaa ? D3D11_SRV_DIMENSION_TEXTURE2DMSARRAY : D3D11_SRV_DIMENSION_TEXTURE2DARRAY;\n                    d3d11_srv_desc.Texture2DArray.MipLevels = (UINT)img->cmn.num_mipmaps;\n                    d3d11_srv_desc.Texture2DArray.ArraySize = (UINT)img->cmn.num_slices;\n                    break;\n                default:\n                    SOKOL_UNREACHABLE; break;\n            }\n            hr = _sg_d3d11_CreateShaderResourceView(_sg.d3d11.dev, (ID3D11Resource*)img->d3d11.tex2d, &d3d11_srv_desc, &img->d3d11.srv);\n            if (!(SUCCEEDED(hr) && img->d3d11.srv)) {\n                _SG_ERROR(D3D11_CREATE_2D_SRV_FAILED);\n                return SG_RESOURCESTATE_FAILED;\n            }\n            _sg_d3d11_setlabel(img->d3d11.srv, desc->label);\n        }\n        SOKOL_ASSERT(img->d3d11.tex2d);\n        img->d3d11.res = (ID3D11Resource*)img->d3d11.tex2d;\n        _sg_d3d11_AddRef(img->d3d11.res);\n    } else {\n        // 3D texture - same procedure, first check if injected, than create non-injected\n        if (injected) {\n            img->d3d11.tex3d = (ID3D11Texture3D*) desc->d3d11_texture;\n            _sg_d3d11_AddRef(img->d3d11.tex3d);\n            img->d3d11.srv = (ID3D11ShaderResourceView*) desc->d3d11_shader_resource_view;\n            if (img->d3d11.srv) {\n                _sg_d3d11_AddRef(img->d3d11.srv);\n            }\n        } else {\n            // not injected, create 3d texture\n            D3D11_TEXTURE3D_DESC d3d11_tex_desc;\n            _sg_clear(&d3d11_tex_desc, sizeof(d3d11_tex_desc));\n            d3d11_tex_desc.Width = (UINT)img->cmn.width;\n            d3d11_tex_desc.Height = (UINT)img->cmn.height;\n            d3d11_tex_desc.Depth = (UINT)img->cmn.num_slices;\n            d3d11_tex_desc.MipLevels = (UINT)img->cmn.num_mipmaps;\n            d3d11_tex_desc.Format = img->d3d11.format;\n            if (img->cmn.render_target) {\n                d3d11_tex_desc.Usage = D3D11_USAGE_DEFAULT;\n                d3d11_tex_desc.BindFlags = D3D11_BIND_RENDER_TARGET;\n                d3d11_tex_desc.CPUAccessFlags = 0;\n            } else {\n                d3d11_tex_desc.Usage = _sg_d3d11_usage(img->cmn.usage);\n                d3d11_tex_desc.BindFlags = D3D11_BIND_SHADER_RESOURCE;\n                d3d11_tex_desc.CPUAccessFlags = _sg_d3d11_cpu_access_flags(img->cmn.usage);\n            }\n            if (img->d3d11.format == DXGI_FORMAT_UNKNOWN) {\n                _SG_ERROR(D3D11_CREATE_3D_TEXTURE_UNSUPPORTED_PIXEL_FORMAT);\n                return SG_RESOURCESTATE_FAILED;\n            }\n            hr = _sg_d3d11_CreateTexture3D(_sg.d3d11.dev, &d3d11_tex_desc, init_data, &img->d3d11.tex3d);\n            if (!(SUCCEEDED(hr) && img->d3d11.tex3d)) {\n                _SG_ERROR(D3D11_CREATE_3D_TEXTURE_FAILED);\n                return SG_RESOURCESTATE_FAILED;\n            }\n            _sg_d3d11_setlabel(img->d3d11.tex3d, desc->label);\n\n            // create shader-resource-view for 3D texture\n            if (!msaa) {\n                D3D11_SHADER_RESOURCE_VIEW_DESC d3d11_srv_desc;\n                _sg_clear(&d3d11_srv_desc, sizeof(d3d11_srv_desc));\n                d3d11_srv_desc.Format = _sg_d3d11_srv_pixel_format(img->cmn.pixel_format);\n                d3d11_srv_desc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE3D;\n                d3d11_srv_desc.Texture3D.MipLevels = (UINT)img->cmn.num_mipmaps;\n                hr = _sg_d3d11_CreateShaderResourceView(_sg.d3d11.dev, (ID3D11Resource*)img->d3d11.tex3d, &d3d11_srv_desc, &img->d3d11.srv);\n                if (!(SUCCEEDED(hr) && img->d3d11.srv)) {\n                    _SG_ERROR(D3D11_CREATE_3D_SRV_FAILED);\n                    return SG_RESOURCESTATE_FAILED;\n                }\n                _sg_d3d11_setlabel(img->d3d11.srv, desc->label);\n            }\n        }\n        SOKOL_ASSERT(img->d3d11.tex3d);\n        img->d3d11.res = (ID3D11Resource*)img->d3d11.tex3d;\n        _sg_d3d11_AddRef(img->d3d11.res);\n    }\n    return SG_RESOURCESTATE_VALID;\n}\n\n_SOKOL_PRIVATE void _sg_d3d11_discard_image(_sg_image_t* img) {\n    SOKOL_ASSERT(img);\n    if (img->d3d11.tex2d) {\n        _sg_d3d11_Release(img->d3d11.tex2d);\n    }\n    if (img->d3d11.tex3d) {\n        _sg_d3d11_Release(img->d3d11.tex3d);\n    }\n    if (img->d3d11.res) {\n        _sg_d3d11_Release(img->d3d11.res);\n    }\n    if (img->d3d11.srv) {\n        _sg_d3d11_Release(img->d3d11.srv);\n    }\n}\n\n_SOKOL_PRIVATE sg_resource_state _sg_d3d11_create_sampler(_sg_sampler_t* smp, const sg_sampler_desc* desc) {\n    SOKOL_ASSERT(smp && desc);\n    SOKOL_ASSERT(0 == smp->d3d11.smp);\n    const bool injected = (0 != desc->d3d11_sampler);\n    if (injected) {\n        smp->d3d11.smp = (ID3D11SamplerState*)desc->d3d11_sampler;\n        _sg_d3d11_AddRef(smp->d3d11.smp);\n    } else {\n        D3D11_SAMPLER_DESC d3d11_smp_desc;\n        _sg_clear(&d3d11_smp_desc, sizeof(d3d11_smp_desc));\n        d3d11_smp_desc.Filter = _sg_d3d11_filter(desc->min_filter, desc->mag_filter, desc->mipmap_filter, desc->compare != SG_COMPAREFUNC_NEVER, desc->max_anisotropy);\n        d3d11_smp_desc.AddressU = _sg_d3d11_address_mode(desc->wrap_u);\n        d3d11_smp_desc.AddressV = _sg_d3d11_address_mode(desc->wrap_v);\n        d3d11_smp_desc.AddressW = _sg_d3d11_address_mode(desc->wrap_w);\n        d3d11_smp_desc.MipLODBias = 0.0f; // FIXME?\n        switch (desc->border_color) {\n            case SG_BORDERCOLOR_TRANSPARENT_BLACK:\n                // all 0.0f\n                break;\n            case SG_BORDERCOLOR_OPAQUE_WHITE:\n                for (int i = 0; i < 4; i++) {\n                    d3d11_smp_desc.BorderColor[i] = 1.0f;\n                }\n                break;\n            default:\n                // opaque black\n                d3d11_smp_desc.BorderColor[3] = 1.0f;\n                break;\n        }\n        d3d11_smp_desc.MaxAnisotropy = desc->max_anisotropy;\n        d3d11_smp_desc.ComparisonFunc = _sg_d3d11_compare_func(desc->compare);\n        d3d11_smp_desc.MinLOD = desc->min_lod;\n        d3d11_smp_desc.MaxLOD = desc->max_lod;\n        HRESULT hr = _sg_d3d11_CreateSamplerState(_sg.d3d11.dev, &d3d11_smp_desc, &smp->d3d11.smp);\n        if (!(SUCCEEDED(hr) && smp->d3d11.smp)) {\n            _SG_ERROR(D3D11_CREATE_SAMPLER_STATE_FAILED);\n            return SG_RESOURCESTATE_FAILED;\n        }\n        _sg_d3d11_setlabel(smp->d3d11.smp, desc->label);\n    }\n    return SG_RESOURCESTATE_VALID;\n}\n\n_SOKOL_PRIVATE void _sg_d3d11_discard_sampler(_sg_sampler_t* smp) {\n    SOKOL_ASSERT(smp);\n    if (smp->d3d11.smp) {\n        _sg_d3d11_Release(smp->d3d11.smp);\n    }\n}\n\n_SOKOL_PRIVATE bool _sg_d3d11_load_d3dcompiler_dll(void) {\n    if ((0 == _sg.d3d11.d3dcompiler_dll) && !_sg.d3d11.d3dcompiler_dll_load_failed) {\n        _sg.d3d11.d3dcompiler_dll = LoadLibraryA(\"d3dcompiler_47.dll\");\n        if (0 == _sg.d3d11.d3dcompiler_dll) {\n            // don't attempt to load missing DLL in the future\n            _SG_ERROR(D3D11_LOAD_D3DCOMPILER_47_DLL_FAILED);\n            _sg.d3d11.d3dcompiler_dll_load_failed = true;\n            return false;\n        }\n        // look up function pointers\n        _sg.d3d11.D3DCompile_func = (pD3DCompile)(void*) GetProcAddress(_sg.d3d11.d3dcompiler_dll, \"D3DCompile\");\n        SOKOL_ASSERT(_sg.d3d11.D3DCompile_func);\n    }\n    return 0 != _sg.d3d11.d3dcompiler_dll;\n}\n\n_SOKOL_PRIVATE ID3DBlob* _sg_d3d11_compile_shader(const sg_shader_function* shd_func) {\n    if (!_sg_d3d11_load_d3dcompiler_dll()) {\n        return NULL;\n    }\n    SOKOL_ASSERT(shd_func->d3d11_target);\n    UINT flags1 = D3DCOMPILE_PACK_MATRIX_COLUMN_MAJOR;\n    if (_sg.desc.d3d11_shader_debugging) {\n        flags1 |= D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION;\n    } else {\n        flags1 |= D3DCOMPILE_OPTIMIZATION_LEVEL3;\n    }\n    ID3DBlob* output = NULL;\n    ID3DBlob* errors_or_warnings = NULL;\n    HRESULT hr = _sg.d3d11.D3DCompile_func(\n        shd_func->source,               // pSrcData\n        strlen(shd_func->source),       // SrcDataSize\n        NULL,                           // pSourceName\n        NULL,                           // pDefines\n        NULL,                           // pInclude\n        shd_func->entry ? shd_func->entry : \"main\", // pEntryPoint\n        shd_func->d3d11_target,         // pTarget\n        flags1,     // Flags1\n        0,          // Flags2\n        &output,    // ppCode\n        &errors_or_warnings);   // ppErrorMsgs\n    if (FAILED(hr)) {\n        _SG_ERROR(D3D11_SHADER_COMPILATION_FAILED);\n    }\n    if (errors_or_warnings) {\n        _SG_WARN(D3D11_SHADER_COMPILATION_OUTPUT);\n        _SG_LOGMSG(D3D11_SHADER_COMPILATION_OUTPUT, (LPCSTR)_sg_d3d11_GetBufferPointer(errors_or_warnings));\n        _sg_d3d11_Release(errors_or_warnings); errors_or_warnings = NULL;\n    }\n    if (FAILED(hr)) {\n        // just in case, usually output is NULL here\n        if (output) {\n            _sg_d3d11_Release(output);\n            output = NULL;\n        }\n    }\n    return output;\n}\n\n_SOKOL_PRIVATE sg_resource_state _sg_d3d11_create_shader(_sg_shader_t* shd, const sg_shader_desc* desc) {\n    SOKOL_ASSERT(shd && desc);\n    SOKOL_ASSERT(!shd->d3d11.vs && !shd->d3d11.fs && !shd->d3d11.vs_blob);\n    HRESULT hr;\n\n    // copy vertex attribute semantic names and indices\n    for (size_t i = 0; i < SG_MAX_VERTEX_ATTRIBUTES; i++) {\n        _sg_strcpy(&shd->d3d11.attrs[i].sem_name, desc->attrs[i].hlsl_sem_name);\n        shd->d3d11.attrs[i].sem_index = desc->attrs[i].hlsl_sem_index;\n    }\n\n    // copy HLSL bind slots\n    for (size_t i = 0; i < SG_MAX_UNIFORMBLOCK_BINDSLOTS; i++) {\n        shd->d3d11.ub_register_b_n[i] = desc->uniform_blocks[i].hlsl_register_b_n;\n    }\n    for (size_t i = 0; i < SG_MAX_STORAGEBUFFER_BINDSLOTS; i++) {\n        shd->d3d11.sbuf_register_t_n[i] = desc->storage_buffers[i].hlsl_register_t_n;\n    }\n    for (size_t i = 0; i < SG_MAX_IMAGE_BINDSLOTS; i++) {\n        shd->d3d11.img_register_t_n[i] = desc->images[i].hlsl_register_t_n;\n    }\n    for (size_t i = 0; i < SG_MAX_SAMPLER_BINDSLOTS; i++) {\n        shd->d3d11.smp_register_s_n[i] = desc->samplers[i].hlsl_register_s_n;\n    }\n\n    // create a D3D constant buffer for each uniform block\n    for (size_t ub_index = 0; ub_index < SG_MAX_UNIFORMBLOCK_BINDSLOTS; ub_index++) {\n        const sg_shader_stage stage = desc->uniform_blocks[ub_index].stage;\n        if (stage == SG_SHADERSTAGE_NONE) {\n            continue;\n        }\n        SOKOL_ASSERT((stage == SG_SHADERSTAGE_VERTEX) || (stage == SG_SHADERSTAGE_FRAGMENT));\n\n        const _sg_shader_uniform_block_t* ub = &shd->cmn.uniform_blocks[ub_index];\n        ID3D11Buffer* cbuf = 0;\n        D3D11_BUFFER_DESC cb_desc;\n        _sg_clear(&cb_desc, sizeof(cb_desc));\n        cb_desc.ByteWidth = (UINT)_sg_roundup((int)ub->size, 16);\n        cb_desc.Usage = D3D11_USAGE_DEFAULT;\n        cb_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;\n        hr = _sg_d3d11_CreateBuffer(_sg.d3d11.dev, &cb_desc, NULL, &cbuf);\n        if (!(SUCCEEDED(hr) && cbuf)) {\n            _SG_ERROR(D3D11_CREATE_CONSTANT_BUFFER_FAILED);\n            return SG_RESOURCESTATE_FAILED;\n        }\n        _sg_d3d11_setlabel(cbuf, desc->label);\n        shd->d3d11.all_cbufs[ub_index] = cbuf;\n\n        const uint8_t d3d11_slot = shd->d3d11.ub_register_b_n[ub_index];\n        SOKOL_ASSERT(d3d11_slot < _SG_D3D11_MAX_STAGE_UB_BINDINGS);\n        if (stage == SG_SHADERSTAGE_VERTEX) {\n            SOKOL_ASSERT(0 == shd->d3d11.vs_cbufs[d3d11_slot]);\n            shd->d3d11.vs_cbufs[d3d11_slot] = cbuf;\n        } else {\n            SOKOL_ASSERT(0 == shd->d3d11.fs_cbufs[d3d11_slot]);\n            shd->d3d11.fs_cbufs[d3d11_slot] = cbuf;\n        }\n    }\n\n    // create shader functions\n    const void* vs_ptr = 0, *fs_ptr = 0;\n    SIZE_T vs_length = 0, fs_length = 0;\n    ID3DBlob* vs_blob = 0, *fs_blob = 0;\n    if (desc->vertex_func.bytecode.ptr && desc->fragment_func.bytecode.ptr) {\n        // create from shader byte code\n        vs_ptr = desc->vertex_func.bytecode.ptr;\n        fs_ptr = desc->fragment_func.bytecode.ptr;\n        vs_length = desc->vertex_func.bytecode.size;\n        fs_length = desc->fragment_func.bytecode.size;\n    } else {\n        // compile from shader source code\n        vs_blob = _sg_d3d11_compile_shader(&desc->vertex_func);\n        fs_blob = _sg_d3d11_compile_shader(&desc->fragment_func);\n        if (vs_blob && fs_blob) {\n            vs_ptr = _sg_d3d11_GetBufferPointer(vs_blob);\n            vs_length = _sg_d3d11_GetBufferSize(vs_blob);\n            fs_ptr = _sg_d3d11_GetBufferPointer(fs_blob);\n            fs_length = _sg_d3d11_GetBufferSize(fs_blob);\n        }\n    }\n    sg_resource_state result = SG_RESOURCESTATE_FAILED;\n    if (vs_ptr && fs_ptr && (vs_length > 0) && (fs_length > 0)) {\n        // create the D3D vertex- and pixel-shader objects\n        hr = _sg_d3d11_CreateVertexShader(_sg.d3d11.dev, vs_ptr, vs_length, NULL, &shd->d3d11.vs);\n        bool vs_succeeded = SUCCEEDED(hr) && shd->d3d11.vs;\n        hr = _sg_d3d11_CreatePixelShader(_sg.d3d11.dev, fs_ptr, fs_length, NULL, &shd->d3d11.fs);\n        bool fs_succeeded = SUCCEEDED(hr) && shd->d3d11.fs;\n\n        // need to store the vertex shader byte code, this is needed later in sg_create_pipeline\n        if (vs_succeeded && fs_succeeded) {\n            shd->d3d11.vs_blob_length = vs_length;\n            shd->d3d11.vs_blob = _sg_malloc((size_t)vs_length);\n            SOKOL_ASSERT(shd->d3d11.vs_blob);\n            memcpy(shd->d3d11.vs_blob, vs_ptr, vs_length);\n            result = SG_RESOURCESTATE_VALID;\n            _sg_d3d11_setlabel(shd->d3d11.vs, desc->label);\n            _sg_d3d11_setlabel(shd->d3d11.fs, desc->label);\n        }\n    }\n    if (vs_blob) {\n        _sg_d3d11_Release(vs_blob); vs_blob = 0;\n    }\n    if (fs_blob) {\n        _sg_d3d11_Release(fs_blob); fs_blob = 0;\n    }\n    return result;\n}\n\n_SOKOL_PRIVATE void _sg_d3d11_discard_shader(_sg_shader_t* shd) {\n    SOKOL_ASSERT(shd);\n    if (shd->d3d11.vs) {\n        _sg_d3d11_Release(shd->d3d11.vs);\n    }\n    if (shd->d3d11.fs) {\n        _sg_d3d11_Release(shd->d3d11.fs);\n    }\n    if (shd->d3d11.vs_blob) {\n        _sg_free(shd->d3d11.vs_blob);\n    }\n    for (size_t i = 0; i < SG_MAX_UNIFORMBLOCK_BINDSLOTS; i++) {\n        if (shd->d3d11.all_cbufs[i]) {\n            _sg_d3d11_Release(shd->d3d11.all_cbufs[i]);\n        }\n    }\n}\n\n_SOKOL_PRIVATE sg_resource_state _sg_d3d11_create_pipeline(_sg_pipeline_t* pip, _sg_shader_t* shd, const sg_pipeline_desc* desc) {\n    SOKOL_ASSERT(pip && shd && desc);\n    SOKOL_ASSERT(desc->shader.id == shd->slot.id);\n    SOKOL_ASSERT(shd->slot.state == SG_RESOURCESTATE_VALID);\n    SOKOL_ASSERT(shd->d3d11.vs_blob && shd->d3d11.vs_blob_length > 0);\n    SOKOL_ASSERT(!pip->d3d11.il && !pip->d3d11.rs && !pip->d3d11.dss && !pip->d3d11.bs);\n\n    pip->shader = shd;\n    pip->d3d11.index_format = _sg_d3d11_index_format(pip->cmn.index_type);\n    pip->d3d11.topology = _sg_d3d11_primitive_topology(desc->primitive_type);\n    pip->d3d11.stencil_ref = desc->stencil.ref;\n\n    // create input layout object\n    HRESULT hr;\n    D3D11_INPUT_ELEMENT_DESC d3d11_comps[SG_MAX_VERTEX_ATTRIBUTES];\n    _sg_clear(d3d11_comps, sizeof(d3d11_comps));\n    int attr_index = 0;\n    for (; attr_index < SG_MAX_VERTEX_ATTRIBUTES; attr_index++) {\n        const sg_vertex_attr_state* a_state = &desc->layout.attrs[attr_index];\n        if (a_state->format == SG_VERTEXFORMAT_INVALID) {\n            break;\n        }\n        SOKOL_ASSERT(a_state->buffer_index < SG_MAX_VERTEXBUFFER_BINDSLOTS);\n        SOKOL_ASSERT(pip->cmn.vertex_buffer_layout_active[a_state->buffer_index]);\n        const sg_vertex_buffer_layout_state* l_state = &desc->layout.buffers[a_state->buffer_index];\n        const sg_vertex_step step_func = l_state->step_func;\n        const int step_rate = l_state->step_rate;\n        D3D11_INPUT_ELEMENT_DESC* d3d11_comp = &d3d11_comps[attr_index];\n        d3d11_comp->SemanticName = _sg_strptr(&shd->d3d11.attrs[attr_index].sem_name);\n        d3d11_comp->SemanticIndex = (UINT)shd->d3d11.attrs[attr_index].sem_index;\n        d3d11_comp->Format = _sg_d3d11_vertex_format(a_state->format);\n        d3d11_comp->InputSlot = (UINT)a_state->buffer_index;\n        d3d11_comp->AlignedByteOffset = (UINT)a_state->offset;\n        d3d11_comp->InputSlotClass = _sg_d3d11_input_classification(step_func);\n        if (SG_VERTEXSTEP_PER_INSTANCE == step_func) {\n            d3d11_comp->InstanceDataStepRate = (UINT)step_rate;\n            pip->cmn.use_instanced_draw = true;\n        }\n    }\n    for (int layout_index = 0; layout_index < SG_MAX_VERTEXBUFFER_BINDSLOTS; layout_index++) {\n        if (pip->cmn.vertex_buffer_layout_active[layout_index]) {\n            const sg_vertex_buffer_layout_state* l_state = &desc->layout.buffers[layout_index];\n            SOKOL_ASSERT(l_state->stride > 0);\n            pip->d3d11.vb_strides[layout_index] = (UINT)l_state->stride;\n        } else {\n            pip->d3d11.vb_strides[layout_index] = 0;\n        }\n    }\n    if (attr_index > 0) {\n        hr = _sg_d3d11_CreateInputLayout(_sg.d3d11.dev,\n            d3d11_comps,                // pInputElementDesc\n            (UINT)attr_index,           // NumElements\n            shd->d3d11.vs_blob,         // pShaderByteCodeWithInputSignature\n            shd->d3d11.vs_blob_length,  // BytecodeLength\n            &pip->d3d11.il);\n        if (!(SUCCEEDED(hr) && pip->d3d11.il)) {\n            _SG_ERROR(D3D11_CREATE_INPUT_LAYOUT_FAILED);\n            return SG_RESOURCESTATE_FAILED;\n        }\n        _sg_d3d11_setlabel(pip->d3d11.il, desc->label);\n    }\n\n    // create rasterizer state\n    D3D11_RASTERIZER_DESC rs_desc;\n    _sg_clear(&rs_desc, sizeof(rs_desc));\n    rs_desc.FillMode = D3D11_FILL_SOLID;\n    rs_desc.CullMode = _sg_d3d11_cull_mode(desc->cull_mode);\n    rs_desc.FrontCounterClockwise = desc->face_winding == SG_FACEWINDING_CCW;\n    rs_desc.DepthBias = (INT) pip->cmn.depth.bias;\n    rs_desc.DepthBiasClamp = pip->cmn.depth.bias_clamp;\n    rs_desc.SlopeScaledDepthBias = pip->cmn.depth.bias_slope_scale;\n    rs_desc.DepthClipEnable = TRUE;\n    rs_desc.ScissorEnable = TRUE;\n    rs_desc.MultisampleEnable = desc->sample_count > 1;\n    rs_desc.AntialiasedLineEnable = FALSE;\n    hr = _sg_d3d11_CreateRasterizerState(_sg.d3d11.dev, &rs_desc, &pip->d3d11.rs);\n    if (!(SUCCEEDED(hr) && pip->d3d11.rs)) {\n        _SG_ERROR(D3D11_CREATE_RASTERIZER_STATE_FAILED);\n        return SG_RESOURCESTATE_FAILED;\n    }\n    _sg_d3d11_setlabel(pip->d3d11.rs, desc->label);\n\n    // create depth-stencil state\n    D3D11_DEPTH_STENCIL_DESC dss_desc;\n    _sg_clear(&dss_desc, sizeof(dss_desc));\n    dss_desc.DepthEnable = TRUE;\n    dss_desc.DepthWriteMask = desc->depth.write_enabled ? D3D11_DEPTH_WRITE_MASK_ALL : D3D11_DEPTH_WRITE_MASK_ZERO;\n    dss_desc.DepthFunc = _sg_d3d11_compare_func(desc->depth.compare);\n    dss_desc.StencilEnable = desc->stencil.enabled;\n    dss_desc.StencilReadMask = desc->stencil.read_mask;\n    dss_desc.StencilWriteMask = desc->stencil.write_mask;\n    const sg_stencil_face_state* sf = &desc->stencil.front;\n    dss_desc.FrontFace.StencilFailOp = _sg_d3d11_stencil_op(sf->fail_op);\n    dss_desc.FrontFace.StencilDepthFailOp = _sg_d3d11_stencil_op(sf->depth_fail_op);\n    dss_desc.FrontFace.StencilPassOp = _sg_d3d11_stencil_op(sf->pass_op);\n    dss_desc.FrontFace.StencilFunc = _sg_d3d11_compare_func(sf->compare);\n    const sg_stencil_face_state* sb = &desc->stencil.back;\n    dss_desc.BackFace.StencilFailOp = _sg_d3d11_stencil_op(sb->fail_op);\n    dss_desc.BackFace.StencilDepthFailOp = _sg_d3d11_stencil_op(sb->depth_fail_op);\n    dss_desc.BackFace.StencilPassOp = _sg_d3d11_stencil_op(sb->pass_op);\n    dss_desc.BackFace.StencilFunc = _sg_d3d11_compare_func(sb->compare);\n    hr = _sg_d3d11_CreateDepthStencilState(_sg.d3d11.dev, &dss_desc, &pip->d3d11.dss);\n    if (!(SUCCEEDED(hr) && pip->d3d11.dss)) {\n        _SG_ERROR(D3D11_CREATE_DEPTH_STENCIL_STATE_FAILED);\n        return SG_RESOURCESTATE_FAILED;\n    }\n    _sg_d3d11_setlabel(pip->d3d11.dss, desc->label);\n\n    // create blend state\n    D3D11_BLEND_DESC bs_desc;\n    _sg_clear(&bs_desc, sizeof(bs_desc));\n    bs_desc.AlphaToCoverageEnable = desc->alpha_to_coverage_enabled;\n    bs_desc.IndependentBlendEnable = TRUE;\n    {\n        int i = 0;\n        for (i = 0; i < desc->color_count; i++) {\n            const sg_blend_state* src = &desc->colors[i].blend;\n            D3D11_RENDER_TARGET_BLEND_DESC* dst = &bs_desc.RenderTarget[i];\n            dst->BlendEnable = src->enabled;\n            dst->SrcBlend = _sg_d3d11_blend_factor(src->src_factor_rgb);\n            dst->DestBlend = _sg_d3d11_blend_factor(src->dst_factor_rgb);\n            dst->BlendOp = _sg_d3d11_blend_op(src->op_rgb);\n            dst->SrcBlendAlpha = _sg_d3d11_blend_factor(src->src_factor_alpha);\n            dst->DestBlendAlpha = _sg_d3d11_blend_factor(src->dst_factor_alpha);\n            dst->BlendOpAlpha = _sg_d3d11_blend_op(src->op_alpha);\n            dst->RenderTargetWriteMask = _sg_d3d11_color_write_mask(desc->colors[i].write_mask);\n        }\n        for (; i < 8; i++) {\n            D3D11_RENDER_TARGET_BLEND_DESC* dst = &bs_desc.RenderTarget[i];\n            dst->BlendEnable = FALSE;\n            dst->SrcBlend = dst->SrcBlendAlpha = D3D11_BLEND_ONE;\n            dst->DestBlend = dst->DestBlendAlpha = D3D11_BLEND_ZERO;\n            dst->BlendOp = dst->BlendOpAlpha = D3D11_BLEND_OP_ADD;\n            dst->RenderTargetWriteMask = D3D11_COLOR_WRITE_ENABLE_ALL;\n        }\n    }\n    hr = _sg_d3d11_CreateBlendState(_sg.d3d11.dev, &bs_desc, &pip->d3d11.bs);\n    if (!(SUCCEEDED(hr) && pip->d3d11.bs)) {\n        _SG_ERROR(D3D11_CREATE_BLEND_STATE_FAILED);\n        return SG_RESOURCESTATE_FAILED;\n    }\n    _sg_d3d11_setlabel(pip->d3d11.bs, desc->label);\n    return SG_RESOURCESTATE_VALID;\n}\n\n_SOKOL_PRIVATE void _sg_d3d11_discard_pipeline(_sg_pipeline_t* pip) {\n    SOKOL_ASSERT(pip);\n    if (pip == _sg.d3d11.cur_pipeline) {\n        _sg.d3d11.cur_pipeline = 0;\n        _sg.d3d11.cur_pipeline_id.id = SG_INVALID_ID;\n    }\n    if (pip->d3d11.il) {\n        _sg_d3d11_Release(pip->d3d11.il);\n    }\n    if (pip->d3d11.rs) {\n        _sg_d3d11_Release(pip->d3d11.rs);\n    }\n    if (pip->d3d11.dss) {\n        _sg_d3d11_Release(pip->d3d11.dss);\n    }\n    if (pip->d3d11.bs) {\n        _sg_d3d11_Release(pip->d3d11.bs);\n    }\n}\n\n_SOKOL_PRIVATE sg_resource_state _sg_d3d11_create_attachments(_sg_attachments_t* atts, _sg_image_t** color_images, _sg_image_t** resolve_images, _sg_image_t* ds_img, const sg_attachments_desc* desc) {\n    SOKOL_ASSERT(atts && desc);\n    SOKOL_ASSERT(color_images && resolve_images);\n    SOKOL_ASSERT(_sg.d3d11.dev);\n\n    // copy image pointers\n    for (int i = 0; i < atts->cmn.num_colors; i++) {\n        const sg_attachment_desc* color_desc = &desc->colors[i];\n        _SOKOL_UNUSED(color_desc);\n        SOKOL_ASSERT(color_desc->image.id != SG_INVALID_ID);\n        SOKOL_ASSERT(0 == atts->d3d11.colors[i].image);\n        SOKOL_ASSERT(color_images[i] && (color_images[i]->slot.id == color_desc->image.id));\n        SOKOL_ASSERT(_sg_is_valid_rendertarget_color_format(color_images[i]->cmn.pixel_format));\n        atts->d3d11.colors[i].image = color_images[i];\n\n        const sg_attachment_desc* resolve_desc = &desc->resolves[i];\n        if (resolve_desc->image.id != SG_INVALID_ID) {\n            SOKOL_ASSERT(0 == atts->d3d11.resolves[i].image);\n            SOKOL_ASSERT(resolve_images[i] && (resolve_images[i]->slot.id == resolve_desc->image.id));\n            SOKOL_ASSERT(color_images[i] && (color_images[i]->cmn.pixel_format == resolve_images[i]->cmn.pixel_format));\n            atts->d3d11.resolves[i].image = resolve_images[i];\n        }\n    }\n    SOKOL_ASSERT(0 == atts->d3d11.depth_stencil.image);\n    const sg_attachment_desc* ds_desc = &desc->depth_stencil;\n    if (ds_desc->image.id != SG_INVALID_ID) {\n        SOKOL_ASSERT(ds_img && (ds_img->slot.id == ds_desc->image.id));\n        SOKOL_ASSERT(_sg_is_valid_rendertarget_depth_format(ds_img->cmn.pixel_format));\n        atts->d3d11.depth_stencil.image = ds_img;\n    }\n\n    // create render-target views\n    for (int i = 0; i < atts->cmn.num_colors; i++) {\n        const _sg_attachment_common_t* cmn_color_att = &atts->cmn.colors[i];\n        const _sg_image_t* color_img = color_images[i];\n        SOKOL_ASSERT(0 == atts->d3d11.colors[i].view.rtv);\n        const bool msaa = color_img->cmn.sample_count > 1;\n        D3D11_RENDER_TARGET_VIEW_DESC d3d11_rtv_desc;\n        _sg_clear(&d3d11_rtv_desc, sizeof(d3d11_rtv_desc));\n        d3d11_rtv_desc.Format = _sg_d3d11_rtv_pixel_format(color_img->cmn.pixel_format);\n        if (color_img->cmn.type == SG_IMAGETYPE_2D) {\n            if (msaa) {\n                d3d11_rtv_desc.ViewDimension = D3D11_RTV_DIMENSION_TEXTURE2DMS;\n            } else {\n                d3d11_rtv_desc.ViewDimension = D3D11_RTV_DIMENSION_TEXTURE2D;\n                d3d11_rtv_desc.Texture2D.MipSlice = (UINT)cmn_color_att->mip_level;\n            }\n        } else if ((color_img->cmn.type == SG_IMAGETYPE_CUBE) || (color_img->cmn.type == SG_IMAGETYPE_ARRAY)) {\n            if (msaa) {\n                d3d11_rtv_desc.ViewDimension = D3D11_RTV_DIMENSION_TEXTURE2DMSARRAY;\n                d3d11_rtv_desc.Texture2DMSArray.FirstArraySlice = (UINT)cmn_color_att->slice;\n                d3d11_rtv_desc.Texture2DMSArray.ArraySize = 1;\n            } else {\n                d3d11_rtv_desc.ViewDimension = D3D11_RTV_DIMENSION_TEXTURE2DARRAY;\n                d3d11_rtv_desc.Texture2DArray.MipSlice = (UINT)cmn_color_att->mip_level;\n                d3d11_rtv_desc.Texture2DArray.FirstArraySlice = (UINT)cmn_color_att->slice;\n                d3d11_rtv_desc.Texture2DArray.ArraySize = 1;\n            }\n        } else {\n            SOKOL_ASSERT(color_img->cmn.type == SG_IMAGETYPE_3D);\n            SOKOL_ASSERT(!msaa);\n            d3d11_rtv_desc.ViewDimension = D3D11_RTV_DIMENSION_TEXTURE3D;\n            d3d11_rtv_desc.Texture3D.MipSlice = (UINT)cmn_color_att->mip_level;\n            d3d11_rtv_desc.Texture3D.FirstWSlice = (UINT)cmn_color_att->slice;\n            d3d11_rtv_desc.Texture3D.WSize = 1;\n        }\n        SOKOL_ASSERT(color_img->d3d11.res);\n        HRESULT hr = _sg_d3d11_CreateRenderTargetView(_sg.d3d11.dev, color_img->d3d11.res, &d3d11_rtv_desc, &atts->d3d11.colors[i].view.rtv);\n        if (!(SUCCEEDED(hr) && atts->d3d11.colors[i].view.rtv)) {\n            _SG_ERROR(D3D11_CREATE_RTV_FAILED);\n            return SG_RESOURCESTATE_FAILED;\n        }\n        _sg_d3d11_setlabel(atts->d3d11.colors[i].view.rtv, desc->label);\n    }\n    SOKOL_ASSERT(0 == atts->d3d11.depth_stencil.view.dsv);\n    if (ds_desc->image.id != SG_INVALID_ID) {\n        const _sg_attachment_common_t* cmn_ds_att = &atts->cmn.depth_stencil;\n        const bool msaa = ds_img->cmn.sample_count > 1;\n        D3D11_DEPTH_STENCIL_VIEW_DESC d3d11_dsv_desc;\n        _sg_clear(&d3d11_dsv_desc, sizeof(d3d11_dsv_desc));\n        d3d11_dsv_desc.Format = _sg_d3d11_dsv_pixel_format(ds_img->cmn.pixel_format);\n        SOKOL_ASSERT(ds_img && ds_img->cmn.type != SG_IMAGETYPE_3D);\n        if (ds_img->cmn.type == SG_IMAGETYPE_2D) {\n            if (msaa) {\n                d3d11_dsv_desc.ViewDimension = D3D11_DSV_DIMENSION_TEXTURE2DMS;\n            } else {\n                d3d11_dsv_desc.ViewDimension = D3D11_DSV_DIMENSION_TEXTURE2D;\n                d3d11_dsv_desc.Texture2D.MipSlice = (UINT)cmn_ds_att->mip_level;\n            }\n        } else if ((ds_img->cmn.type == SG_IMAGETYPE_CUBE) || (ds_img->cmn.type == SG_IMAGETYPE_ARRAY)) {\n            if (msaa) {\n                d3d11_dsv_desc.ViewDimension = D3D11_DSV_DIMENSION_TEXTURE2DMSARRAY;\n                d3d11_dsv_desc.Texture2DMSArray.FirstArraySlice = (UINT)cmn_ds_att->slice;\n                d3d11_dsv_desc.Texture2DMSArray.ArraySize = 1;\n            } else {\n                d3d11_dsv_desc.ViewDimension = D3D11_DSV_DIMENSION_TEXTURE2DARRAY;\n                d3d11_dsv_desc.Texture2DArray.MipSlice = (UINT)cmn_ds_att->mip_level;\n                d3d11_dsv_desc.Texture2DArray.FirstArraySlice = (UINT)cmn_ds_att->slice;\n                d3d11_dsv_desc.Texture2DArray.ArraySize = 1;\n            }\n        }\n        SOKOL_ASSERT(ds_img->d3d11.res);\n        HRESULT hr = _sg_d3d11_CreateDepthStencilView(_sg.d3d11.dev, ds_img->d3d11.res, &d3d11_dsv_desc, &atts->d3d11.depth_stencil.view.dsv);\n        if (!(SUCCEEDED(hr) && atts->d3d11.depth_stencil.view.dsv)) {\n            _SG_ERROR(D3D11_CREATE_DSV_FAILED);\n            return SG_RESOURCESTATE_FAILED;\n        }\n        _sg_d3d11_setlabel(atts->d3d11.depth_stencil.view.dsv, desc->label);\n    }\n    return SG_RESOURCESTATE_VALID;\n}\n\n_SOKOL_PRIVATE void _sg_d3d11_discard_attachments(_sg_attachments_t* atts) {\n    SOKOL_ASSERT(atts);\n    for (int i = 0; i < SG_MAX_COLOR_ATTACHMENTS; i++) {\n        if (atts->d3d11.colors[i].view.rtv) {\n            _sg_d3d11_Release(atts->d3d11.colors[i].view.rtv);\n        }\n        if (atts->d3d11.resolves[i].view.rtv) {\n            _sg_d3d11_Release(atts->d3d11.resolves[i].view.rtv);\n        }\n    }\n    if (atts->d3d11.depth_stencil.view.dsv) {\n        _sg_d3d11_Release(atts->d3d11.depth_stencil.view.dsv);\n    }\n}\n\n_SOKOL_PRIVATE _sg_image_t* _sg_d3d11_attachments_color_image(const _sg_attachments_t* atts, int index) {\n    SOKOL_ASSERT(atts && (index >= 0) && (index < SG_MAX_COLOR_ATTACHMENTS));\n    return atts->d3d11.colors[index].image;\n}\n\n_SOKOL_PRIVATE _sg_image_t* _sg_d3d11_attachments_resolve_image(const _sg_attachments_t* atts, int index) {\n    SOKOL_ASSERT(atts && (index >= 0) && (index < SG_MAX_COLOR_ATTACHMENTS));\n    return atts->d3d11.resolves[index].image;\n}\n\n_SOKOL_PRIVATE _sg_image_t* _sg_d3d11_attachments_ds_image(const _sg_attachments_t* atts) {\n    SOKOL_ASSERT(atts);\n    return atts->d3d11.depth_stencil.image;\n}\n\n_SOKOL_PRIVATE void _sg_d3d11_begin_pass(const sg_pass* pass) {\n    SOKOL_ASSERT(pass);\n\n    const _sg_attachments_t* atts = _sg.cur_pass.atts;\n    const sg_swapchain* swapchain = &pass->swapchain;\n    const sg_pass_action* action = &pass->action;\n\n    int num_rtvs = 0;\n    ID3D11RenderTargetView* rtvs[SG_MAX_COLOR_ATTACHMENTS] = { 0 };\n    ID3D11DepthStencilView* dsv = 0;\n    _sg.d3d11.cur_pass.render_view = 0;\n    _sg.d3d11.cur_pass.resolve_view = 0;\n    if (atts) {\n        num_rtvs = atts->cmn.num_colors;\n        for (int i = 0; i < SG_MAX_COLOR_ATTACHMENTS; i++) {\n            rtvs[i] = atts->d3d11.colors[i].view.rtv;\n        }\n        dsv = atts->d3d11.depth_stencil.view.dsv;\n    } else {\n        // NOTE: depth-stencil-view is optional\n        SOKOL_ASSERT(swapchain->d3d11.render_view);\n        num_rtvs = 1;\n        rtvs[0] = (ID3D11RenderTargetView*) swapchain->d3d11.render_view;\n        dsv = (ID3D11DepthStencilView*) swapchain->d3d11.depth_stencil_view;\n        _sg.d3d11.cur_pass.render_view = (ID3D11RenderTargetView*) swapchain->d3d11.render_view;\n        _sg.d3d11.cur_pass.resolve_view = (ID3D11RenderTargetView*) swapchain->d3d11.resolve_view;\n    }\n    // apply the render-target- and depth-stencil-views\n    _sg_d3d11_OMSetRenderTargets(_sg.d3d11.ctx, SG_MAX_COLOR_ATTACHMENTS, rtvs, dsv);\n    _sg_stats_add(d3d11.pass.num_om_set_render_targets, 1);\n\n    // set viewport and scissor rect to cover whole screen\n    D3D11_VIEWPORT vp;\n    _sg_clear(&vp, sizeof(vp));\n    vp.Width = (FLOAT) _sg.cur_pass.width;\n    vp.Height = (FLOAT) _sg.cur_pass.height;\n    vp.MaxDepth = 1.0f;\n    _sg_d3d11_RSSetViewports(_sg.d3d11.ctx, 1, &vp);\n    D3D11_RECT rect;\n    rect.left = 0;\n    rect.top = 0;\n    rect.right = _sg.cur_pass.width;\n    rect.bottom = _sg.cur_pass.height;\n    _sg_d3d11_RSSetScissorRects(_sg.d3d11.ctx, 1, &rect);\n\n    // perform clear action\n    for (int i = 0; i < num_rtvs; i++) {\n        if (action->colors[i].load_action == SG_LOADACTION_CLEAR) {\n            _sg_d3d11_ClearRenderTargetView(_sg.d3d11.ctx, rtvs[i], (float*)&action->colors[i].clear_value);\n            _sg_stats_add(d3d11.pass.num_clear_render_target_view, 1);\n        }\n    }\n    UINT ds_flags = 0;\n    if (action->depth.load_action == SG_LOADACTION_CLEAR) {\n        ds_flags |= D3D11_CLEAR_DEPTH;\n    }\n    if (action->stencil.load_action == SG_LOADACTION_CLEAR) {\n        ds_flags |= D3D11_CLEAR_STENCIL;\n    }\n    if ((0 != ds_flags) && dsv) {\n        _sg_d3d11_ClearDepthStencilView(_sg.d3d11.ctx, dsv, ds_flags, action->depth.clear_value, action->stencil.clear_value);\n        _sg_stats_add(d3d11.pass.num_clear_depth_stencil_view, 1);\n    }\n}\n\n// D3D11CalcSubresource only exists for C++\n_SOKOL_PRIVATE UINT _sg_d3d11_calcsubresource(UINT mip_slice, UINT array_slice, UINT mip_levels) {\n    return mip_slice + array_slice * mip_levels;\n}\n\n_SOKOL_PRIVATE void _sg_d3d11_end_pass(void) {\n    SOKOL_ASSERT(_sg.d3d11.ctx);\n\n    // need to resolve MSAA render attachments into texture?\n    if (_sg.cur_pass.atts_id.id != SG_INVALID_ID) {\n        // ...for offscreen pass...\n        SOKOL_ASSERT(_sg.cur_pass.atts && _sg.cur_pass.atts->slot.id == _sg.cur_pass.atts_id.id);\n        for (int i = 0; i < _sg.cur_pass.atts->cmn.num_colors; i++) {\n            const _sg_image_t* resolve_img = _sg.cur_pass.atts->d3d11.resolves[i].image;\n            if (resolve_img) {\n                const _sg_image_t* color_img = _sg.cur_pass.atts->d3d11.colors[i].image;\n                const _sg_attachment_common_t* cmn_color_att = &_sg.cur_pass.atts->cmn.colors[i];\n                const _sg_attachment_common_t* cmn_resolve_att = &_sg.cur_pass.atts->cmn.resolves[i];\n                SOKOL_ASSERT(resolve_img->slot.id == cmn_resolve_att->image_id.id);\n                SOKOL_ASSERT(color_img && (color_img->slot.id == cmn_color_att->image_id.id));\n                SOKOL_ASSERT(color_img->cmn.sample_count > 1);\n                SOKOL_ASSERT(resolve_img->cmn.sample_count == 1);\n                const UINT src_subres = _sg_d3d11_calcsubresource(\n                    (UINT)cmn_color_att->mip_level,\n                    (UINT)cmn_color_att->slice,\n                    (UINT)color_img->cmn.num_mipmaps);\n                const UINT dst_subres = _sg_d3d11_calcsubresource(\n                    (UINT)cmn_resolve_att->mip_level,\n                    (UINT)cmn_resolve_att->slice,\n                    (UINT)resolve_img->cmn.num_mipmaps);\n                _sg_d3d11_ResolveSubresource(_sg.d3d11.ctx,\n                    resolve_img->d3d11.res,\n                    dst_subres,\n                    color_img->d3d11.res,\n                    src_subres,\n                    color_img->d3d11.format);\n                _sg_stats_add(d3d11.pass.num_resolve_subresource, 1);\n            }\n        }\n    } else {\n        // ...for swapchain pass...\n        if (_sg.d3d11.cur_pass.resolve_view) {\n            SOKOL_ASSERT(_sg.d3d11.cur_pass.render_view);\n            SOKOL_ASSERT(_sg.cur_pass.swapchain.sample_count > 1);\n            SOKOL_ASSERT(_sg.cur_pass.swapchain.color_fmt > SG_PIXELFORMAT_NONE);\n            ID3D11Resource* d3d11_render_res = 0;\n            ID3D11Resource* d3d11_resolve_res = 0;\n            _sg_d3d11_GetResource((ID3D11View*)_sg.d3d11.cur_pass.render_view, &d3d11_render_res);\n            _sg_d3d11_GetResource((ID3D11View*)_sg.d3d11.cur_pass.resolve_view, &d3d11_resolve_res);\n            SOKOL_ASSERT(d3d11_render_res);\n            SOKOL_ASSERT(d3d11_resolve_res);\n            const sg_pixel_format color_fmt = _sg.cur_pass.swapchain.color_fmt;\n            _sg_d3d11_ResolveSubresource(_sg.d3d11.ctx, d3d11_resolve_res, 0, d3d11_render_res, 0, _sg_d3d11_rtv_pixel_format(color_fmt));\n            _sg_d3d11_Release(d3d11_render_res);\n            _sg_d3d11_Release(d3d11_resolve_res);\n            _sg_stats_add(d3d11.pass.num_resolve_subresource, 1);\n        }\n    }\n    _sg.d3d11.cur_pass.render_view = 0;\n    _sg.d3d11.cur_pass.resolve_view = 0;\n    _sg.d3d11.cur_pipeline = 0;\n    _sg.d3d11.cur_pipeline_id.id = SG_INVALID_ID;\n    _sg_d3d11_clear_state();\n}\n\n_SOKOL_PRIVATE void _sg_d3d11_apply_viewport(int x, int y, int w, int h, bool origin_top_left) {\n    SOKOL_ASSERT(_sg.d3d11.ctx);\n    D3D11_VIEWPORT vp;\n    vp.TopLeftX = (FLOAT) x;\n    vp.TopLeftY = (FLOAT) (origin_top_left ? y : (_sg.cur_pass.height - (y + h)));\n    vp.Width = (FLOAT) w;\n    vp.Height = (FLOAT) h;\n    vp.MinDepth = 0.0f;\n    vp.MaxDepth = 1.0f;\n    _sg_d3d11_RSSetViewports(_sg.d3d11.ctx, 1, &vp);\n}\n\n_SOKOL_PRIVATE void _sg_d3d11_apply_scissor_rect(int x, int y, int w, int h, bool origin_top_left) {\n    SOKOL_ASSERT(_sg.d3d11.ctx);\n    D3D11_RECT rect;\n    rect.left = x;\n    rect.top = (origin_top_left ? y : (_sg.cur_pass.height - (y + h)));\n    rect.right = x + w;\n    rect.bottom = origin_top_left ? (y + h) : (_sg.cur_pass.height - y);\n    _sg_d3d11_RSSetScissorRects(_sg.d3d11.ctx, 1, &rect);\n}\n\n_SOKOL_PRIVATE void _sg_d3d11_apply_pipeline(_sg_pipeline_t* pip) {\n    SOKOL_ASSERT(pip);\n    SOKOL_ASSERT(pip->shader && (pip->cmn.shader_id.id == pip->shader->slot.id));\n    SOKOL_ASSERT(_sg.d3d11.ctx);\n    SOKOL_ASSERT(pip->d3d11.rs && pip->d3d11.bs && pip->d3d11.dss);\n\n    _sg.d3d11.cur_pipeline = pip;\n    _sg.d3d11.cur_pipeline_id.id = pip->slot.id;\n    _sg.d3d11.use_inde"
        },
        {
          "name": "sokol_glue.h",
          "type": "blob",
          "size": 5.4921875,
          "content": "#if defined(SOKOL_IMPL) && !defined(SOKOL_GLUE_IMPL)\n#define SOKOL_GLUE_IMPL\n#endif\n#ifndef SOKOL_GLUE_INCLUDED\n/*\n    sokol_glue.h -- glue helper functions for sokol headers\n\n    Project URL: https://github.com/floooh/sokol\n\n    Do this:\n        #define SOKOL_IMPL or\n        #define SOKOL_GLUE_IMPL\n    before you include this file in *one* C or C++ file to create the\n    implementation.\n\n    ...optionally provide the following macros to override defaults:\n\n    SOKOL_ASSERT(c)     - your own assert macro (default: assert(c))\n    SOKOL_GLUE_API_DECL - public function declaration prefix (default: extern)\n    SOKOL_API_DECL      - same as SOKOL_GLUE_API_DECL\n    SOKOL_API_IMPL      - public function implementation prefix (default: -)\n\n    If sokol_glue.h is compiled as a DLL, define the following before\n    including the declaration or implementation:\n\n    SOKOL_DLL\n\n    On Windows, SOKOL_DLL will define SOKOL_GLUE_API_DECL as __declspec(dllexport)\n    or __declspec(dllimport) as needed.\n\n    OVERVIEW\n    ========\n    sokol_glue.h provides glue helper functions between sokol_gfx.h and sokol_app.h,\n    so that sokol_gfx.h doesn't need to depend on sokol_app.h but can be\n    used with different window system glue libraries.\n\n    PROVIDED FUNCTIONS\n    ==================\n\n    sg_environment sglue_environment(void)\n\n        Returns an sg_environment struct initialized by calling sokol_app.h\n        functions. Use this in the sg_setup() call like this:\n\n        sg_setup(&(sg_desc){\n            .environment = sglue_environment(),\n            ...\n        });\n\n    sg_swapchain sglue_swapchain(void)\n\n        Returns an sg_swapchain struct initialized by calling sokol_app.h\n        functions. Use this in sg_begin_pass() for a 'swapchain pass' like\n        this:\n\n        sg_begin_pass(&(sg_pass){ .swapchain = sglue_swapchain(), ... });\n\n    LICENSE\n    =======\n    zlib/libpng license\n\n    Copyright (c) 2018 Andre Weissflog\n\n    This software is provided 'as-is', without any express or implied warranty.\n    In no event will the authors be held liable for any damages arising from the\n    use of this software.\n\n    Permission is granted to anyone to use this software for any purpose,\n    including commercial applications, and to alter it and redistribute it\n    freely, subject to the following restrictions:\n\n        1. The origin of this software must not be misrepresented; you must not\n        claim that you wrote the original software. If you use this software in a\n        product, an acknowledgment in the product documentation would be\n        appreciated but is not required.\n\n        2. Altered source versions must be plainly marked as such, and must not\n        be misrepresented as being the original software.\n\n        3. This notice may not be removed or altered from any source\n        distribution.\n*/\n#define SOKOL_GLUE_INCLUDED\n\n#if defined(SOKOL_API_DECL) && !defined(SOKOL_GLUE_API_DECL)\n#define SOKOL_GLUE_API_DECL SOKOL_API_DECL\n#endif\n#ifndef SOKOL_GLUE_API_DECL\n#if defined(_WIN32) && defined(SOKOL_DLL) && defined(SOKOL_GLUE_IMPL)\n#define SOKOL_GLUE_API_DECL __declspec(dllexport)\n#elif defined(_WIN32) && defined(SOKOL_DLL)\n#define SOKOL_GLUE_API_DECL __declspec(dllimport)\n#else\n#define SOKOL_GLUE_API_DECL extern\n#endif\n#endif\n\n#ifndef SOKOL_GFX_INCLUDED\n#error \"Please include sokol_gfx.h before sokol_glue.h\"\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nSOKOL_GLUE_API_DECL sg_environment sglue_environment(void);\nSOKOL_GLUE_API_DECL sg_swapchain sglue_swapchain(void);\n\n#ifdef __cplusplus\n} /* extern \"C\" */\n#endif\n#endif /* SOKOL_GLUE_INCLUDED */\n\n/*-- IMPLEMENTATION ----------------------------------------------------------*/\n#ifdef SOKOL_GLUE_IMPL\n#define SOKOL_GLUE_IMPL_INCLUDED (1)\n#include <string.h> /* memset */\n\n#ifndef SOKOL_APP_INCLUDED\n#error \"Please include sokol_app.h before the sokol_glue.h implementation\"\n#endif\n\n#ifndef SOKOL_API_IMPL\n#define SOKOL_API_IMPL\n#endif\n\n\nSOKOL_API_IMPL sg_environment sglue_environment(void) {\n    sg_environment env;\n    memset(&env, 0, sizeof(env));\n    env.defaults.color_format = (sg_pixel_format) sapp_color_format();\n    env.defaults.depth_format = (sg_pixel_format) sapp_depth_format();\n    env.defaults.sample_count = sapp_sample_count();\n    env.metal.device = sapp_metal_get_device();\n    env.d3d11.device = sapp_d3d11_get_device();\n    env.d3d11.device_context = sapp_d3d11_get_device_context();\n    env.wgpu.device = sapp_wgpu_get_device();\n    return env;\n}\n\nSOKOL_API_IMPL sg_swapchain sglue_swapchain(void) {\n    sg_swapchain swapchain;\n    memset(&swapchain, 0, sizeof(swapchain));\n    swapchain.width = sapp_width();\n    swapchain.height = sapp_height();\n    swapchain.sample_count = sapp_sample_count();\n    swapchain.color_format = (sg_pixel_format)sapp_color_format();\n    swapchain.depth_format = (sg_pixel_format)sapp_depth_format();\n    swapchain.metal.current_drawable = sapp_metal_get_current_drawable();\n    swapchain.metal.depth_stencil_texture = sapp_metal_get_depth_stencil_texture();\n    swapchain.metal.msaa_color_texture = sapp_metal_get_msaa_color_texture();\n    swapchain.d3d11.render_view = sapp_d3d11_get_render_view();\n    swapchain.d3d11.resolve_view = sapp_d3d11_get_resolve_view();\n    swapchain.d3d11.depth_stencil_view = sapp_d3d11_get_depth_stencil_view();\n    swapchain.wgpu.render_view = sapp_wgpu_get_render_view();\n    swapchain.wgpu.resolve_view = sapp_wgpu_get_resolve_view();\n    swapchain.wgpu.depth_stencil_view = sapp_wgpu_get_depth_stencil_view();\n    swapchain.gl.framebuffer = sapp_gl_get_framebuffer();\n    return swapchain;\n}\n\n#endif /* SOKOL_GLUE_IMPL */\n"
        },
        {
          "name": "sokol_log.h",
          "type": "blob",
          "size": 11.8994140625,
          "content": "#if defined(SOKOL_IMPL) && !defined(SOKOL_LOG_IMPL)\n#define SOKOL_LOG_IMPL\n#endif\n#ifndef SOKOL_LOG_INCLUDED\n/*\n    sokol_log.h -- common logging callback for sokol headers\n\n    Project URL: https://github.com/floooh/sokol\n\n    Example code: https://github.com/floooh/sokol-samples\n\n    Do this:\n        #define SOKOL_IMPL or\n        #define SOKOL_LOG_IMPL\n    before you include this file in *one* C or C++ file to create the\n    implementation.\n\n    Optionally provide the following defines when building the implementation:\n\n    SOKOL_ASSERT(c)             - your own assert macro (default: assert(c))\n    SOKOL_UNREACHABLE()         - a guard macro for unreachable code (default: assert(false))\n    SOKOL_LOG_API_DECL          - public function declaration prefix (default: extern)\n    SOKOL_API_DECL              - same as SOKOL_GFX_API_DECL\n    SOKOL_API_IMPL              - public function implementation prefix (default: -)\n\n    Optionally define the following for verbose output:\n\n    SOKOL_DEBUG         - by default this is defined if _DEBUG is defined\n\n\n    OVERVIEW\n    ========\n    sokol_log.h provides a default logging callback for other sokol headers.\n\n    To use the default log callback, just include sokol_log.h and provide\n    a function pointer to the 'slog_func' function when setting up the\n    sokol library:\n\n    For instance with sokol_audio.h:\n\n        #include \"sokol_log.h\"\n        ...\n        saudio_setup(&(saudio_desc){ .logger.func = slog_func });\n\n    Logging output goes to stderr and/or a platform specific logging subsystem\n    (which means that in some scenarios you might see logging messages duplicated):\n\n        - Windows: stderr + OutputDebugStringA()\n        - macOS/iOS/Linux: stderr + syslog()\n        - Emscripten: console.info()/warn()/error()\n        - Android: __android_log_write()\n\n    On Windows with sokol_app.h also note the runtime config items to make\n    stdout/stderr output visible on the console for WinMain() applications\n    via sapp_desc.win32_console_attach or sapp_desc.win32_console_create,\n    however when running in a debugger on Windows, the logging output should\n    show up on the debug output UI panel.\n\n    In debug mode, a log message might look like this:\n\n        [sspine][error][id:12] /Users/floh/projects/sokol/util/sokol_spine.h:3472:0:\n            SKELETON_DESC_NO_ATLAS: no atlas object provided in sspine_skeleton_desc.atlas\n\n    The source path and line number is formatted like compiler errors, in some IDEs (like VSCode)\n    such error messages are clickable.\n\n    In release mode, logging is less verbose as to not bloat the executable with string data, but you still get\n    enough information to identify the type and location of an error:\n\n        [sspine][error][id:12][line:3472]\n\n    RULES FOR WRITING YOUR OWN LOGGING FUNCTION\n    ===========================================\n    - must be re-entrant because it might be called from different threads\n    - must treat **all** provided string pointers as optional (can be null)\n    - don't store the string pointers, copy the string data instead\n    - must not return for log level panic\n\n    LICENSE\n    =======\n    zlib/libpng license\n\n    Copyright (c) 2023 Andre Weissflog\n\n    This software is provided 'as-is', without any express or implied warranty.\n    In no event will the authors be held liable for any damages arising from the\n    use of this software.\n\n    Permission is granted to anyone to use this software for any purpose,\n    including commercial applications, and to alter it and redistribute it\n    freely, subject to the following restrictions:\n\n        1. The origin of this software must not be misrepresented; you must not\n        claim that you wrote the original software. If you use this software in a\n        product, an acknowledgment in the product documentation would be\n        appreciated but is not required.\n\n        2. Altered source versions must be plainly marked as such, and must not\n        be misrepresented as being the original software.\n\n        3. This notice may not be removed or altered from any source\n        distribution.\n*/\n#define SOKOL_LOG_INCLUDED (1)\n#include <stdint.h>\n\n#if defined(SOKOL_API_DECL) && !defined(SOKOL_LOG_API_DECL)\n#define SOKOL_LOG_API_DECL SOKOL_API_DECL\n#endif\n#ifndef SOKOL_LOG_API_DECL\n#if defined(_WIN32) && defined(SOKOL_DLL) && defined(SOKOL_LOG_IMPL)\n#define SOKOL_LOG_API_DECL __declspec(dllexport)\n#elif defined(_WIN32) && defined(SOKOL_DLL)\n#define SOKOL_LOG_API_DECL __declspec(dllimport)\n#else\n#define SOKOL_LOG_API_DECL extern\n#endif\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/*\n    Plug this function into the 'logger.func' struct item when initializing any of the sokol\n    headers. For instance for sokol_audio.h it would loom like this:\n\n    saudio_setup(&(saudio_desc){\n        .logger = {\n            .func = slog_func\n        }\n    });\n*/\nSOKOL_LOG_API_DECL void slog_func(const char* tag, uint32_t log_level, uint32_t log_item, const char* message, uint32_t line_nr, const char* filename, void* user_data);\n\n#ifdef __cplusplus\n} // extern \"C\"\n#endif\n#endif // SOKOL_LOG_INCLUDED\n\n//                                        \n//                                                             \n//                                                  \n//                                                                   \n//                                                      \n//\n// >>implementation\n#ifdef SOKOL_LOG_IMPL\n#define SOKOL_LOG_IMPL_INCLUDED (1)\n\n#ifndef SOKOL_API_IMPL\n    #define SOKOL_API_IMPL\n#endif\n#ifndef SOKOL_DEBUG\n    #ifndef NDEBUG\n        #define SOKOL_DEBUG\n    #endif\n#endif\n#ifndef SOKOL_ASSERT\n    #include <assert.h>\n    #define SOKOL_ASSERT(c) assert(c)\n#endif\n\n#ifndef _SOKOL_PRIVATE\n    #if defined(__GNUC__) || defined(__clang__)\n        #define _SOKOL_PRIVATE __attribute__((unused)) static\n    #else\n        #define _SOKOL_PRIVATE static\n    #endif\n#endif\n\n#ifndef _SOKOL_UNUSED\n    #define _SOKOL_UNUSED(x) (void)(x)\n#endif\n\n// platform detection\n#if defined(__APPLE__)\n    #define _SLOG_APPLE (1)\n#elif defined(__EMSCRIPTEN__)\n    #define _SLOG_EMSCRIPTEN (1)\n#elif defined(_WIN32)\n    #define _SLOG_WINDOWS (1)\n#elif defined(__ANDROID__)\n    #define _SLOG_ANDROID (1)\n#elif defined(__linux__) || defined(__unix__)\n    #define _SLOG_LINUX (1)\n#else\n#error \"sokol_log.h: unknown platform\"\n#endif\n\n#include <stdlib.h> // abort\n#include <stdio.h>  // fputs\n#include <stddef.h> // size_t\n\n#if defined(_SLOG_EMSCRIPTEN)\n#include <emscripten/emscripten.h>\n#elif defined(_SLOG_WINDOWS)\n#ifndef WIN32_LEAN_AND_MEAN\n    #define WIN32_LEAN_AND_MEAN\n#endif\n#ifndef NOMINMAX\n    #define NOMINMAX\n#endif\n#include <windows.h>\n#elif defined(_SLOG_ANDROID)\n#include <android/log.h>\n#elif defined(_SLOG_LINUX) || defined(_SLOG_APPLE)\n#include <syslog.h>\n#endif\n\n// size of line buffer (on stack!) in bytes including terminating zero\n#define _SLOG_LINE_LENGTH (512)\n\n_SOKOL_PRIVATE char* _slog_append(const char* str, char* dst, char* end) {\n    if (str) {\n        char c;\n        while (((c = *str++) != 0) && (dst < (end - 1))) {\n            *dst++ = c;\n        }\n    }\n    *dst = 0;\n    return dst;\n}\n\n_SOKOL_PRIVATE char* _slog_itoa(uint32_t x, char* buf, size_t buf_size) {\n    const size_t max_digits_and_null = 11;\n    if (buf_size < max_digits_and_null) {\n        return 0;\n    }\n    char* p = buf + max_digits_and_null;\n    *--p = 0;\n    do {\n        *--p = '0' + (x % 10);\n        x /= 10;\n    } while (x != 0);\n    return p;\n}\n\n#if defined(_SLOG_EMSCRIPTEN)\nEM_JS(void, slog_js_log, (uint32_t level, const char* c_str), {\n    const str = UTF8ToString(c_str);\n    switch (level) {\n        case 0: console.error(str); break;\n        case 1: console.error(str); break;\n        case 2: console.warn(str); break;\n        default: console.info(str); break;\n    }\n});\n#endif\n\nSOKOL_API_IMPL void slog_func(const char* tag, uint32_t log_level, uint32_t log_item, const char* message, uint32_t line_nr, const char* filename, void* user_data) {\n    _SOKOL_UNUSED(user_data);\n\n    const char* log_level_str;\n    switch (log_level) {\n        case 0: log_level_str = \"panic\"; break;\n        case 1: log_level_str = \"error\"; break;\n        case 2: log_level_str = \"warning\"; break;\n        default: log_level_str = \"info\"; break;\n    }\n\n    // build log output line\n    char line_buf[_SLOG_LINE_LENGTH];\n    char* str = line_buf;\n    char* end = line_buf + sizeof(line_buf);\n    char num_buf[32];\n    if (tag) {\n        str = _slog_append(\"[\", str, end);\n        str = _slog_append(tag, str, end);\n        str = _slog_append(\"]\", str, end);\n    }\n    str = _slog_append(\"[\", str, end);\n    str = _slog_append(log_level_str, str, end);\n    str = _slog_append(\"]\", str, end);\n    str = _slog_append(\"[id:\", str, end);\n    str = _slog_append(_slog_itoa(log_item, num_buf, sizeof(num_buf)), str, end);\n    str = _slog_append(\"]\", str, end);\n    // if a filename is provided, build a clickable log message that's compatible with compiler error messages\n    if (filename) {\n        str = _slog_append(\" \", str, end);\n        #if defined(_MSC_VER)\n            // MSVC compiler error format\n            str = _slog_append(filename, str, end);\n            str = _slog_append(\"(\", str, end);\n            str = _slog_append(_slog_itoa(line_nr, num_buf, sizeof(num_buf)), str, end);\n            str = _slog_append(\"): \", str, end);\n        #else\n            // gcc/clang compiler error format\n            str = _slog_append(filename, str, end);\n            str = _slog_append(\":\", str, end);\n            str = _slog_append(_slog_itoa(line_nr, num_buf, sizeof(num_buf)), str, end);\n            str = _slog_append(\":0: \", str, end);\n        #endif\n    }\n    else {\n        str = _slog_append(\"[line:\", str, end);\n        str = _slog_append(_slog_itoa(line_nr, num_buf, sizeof(num_buf)), str, end);\n        str = _slog_append(\"] \", str, end);\n    }\n    if (message) {\n        str = _slog_append(\"\\n\\t\", str, end);\n        str = _slog_append(message, str, end);\n    }\n    str = _slog_append(\"\\n\\n\", str, end);\n    if (0 == log_level) {\n        str = _slog_append(\"ABORTING because of [panic]\\n\", str, end);\n        (void)str;\n    }\n\n    // print to stderr?\n    #if defined(_SLOG_LINUX) || defined(_SLOG_WINDOWS) || defined(_SLOG_APPLE)\n        fputs(line_buf, stderr);\n    #endif\n\n    // platform specific logging calls\n    #if defined(_SLOG_WINDOWS)\n        OutputDebugStringA(line_buf);\n    #elif defined(_SLOG_ANDROID)\n        int prio;\n        switch (log_level) {\n            case 0: prio = ANDROID_LOG_FATAL; break;\n            case 1: prio = ANDROID_LOG_ERROR; break;\n            case 2: prio = ANDROID_LOG_WARN; break;\n            default: prio = ANDROID_LOG_INFO; break;\n        }\n        __android_log_write(prio, \"SOKOL\", line_buf);\n    #elif defined(_SLOG_EMSCRIPTEN)\n        slog_js_log(log_level, line_buf);\n    #elif defined(_SLOG_LINUX) || defined(_SLOG_APPLE)\n        int prio;\n        switch (log_level) {\n            case 0: prio = LOG_CRIT; break;\n            case 1: prio = LOG_ERR; break;\n            case 2: prio = LOG_WARNING; break;\n            default: prio = LOG_INFO; break;\n        }\n        syslog(prio, \"%s\", line_buf);\n    #endif\n    if (0 == log_level) {\n        abort();\n    }\n}\n#endif // SOKOL_LOG_IMPL\n"
        },
        {
          "name": "sokol_time.h",
          "type": "blob",
          "size": 10.794921875,
          "content": "#if defined(SOKOL_IMPL) && !defined(SOKOL_TIME_IMPL)\n#define SOKOL_TIME_IMPL\n#endif\n#ifndef SOKOL_TIME_INCLUDED\n/*\n    sokol_time.h    -- simple cross-platform time measurement\n\n    Project URL: https://github.com/floooh/sokol\n\n    Do this:\n        #define SOKOL_IMPL or\n        #define SOKOL_TIME_IMPL\n    before you include this file in *one* C or C++ file to create the\n    implementation.\n\n    Optionally provide the following defines with your own implementations:\n    SOKOL_ASSERT(c)     - your own assert macro (default: assert(c))\n    SOKOL_TIME_API_DECL - public function declaration prefix (default: extern)\n    SOKOL_API_DECL      - same as SOKOL_TIME_API_DECL\n    SOKOL_API_IMPL      - public function implementation prefix (default: -)\n\n    If sokol_time.h is compiled as a DLL, define the following before\n    including the declaration or implementation:\n\n    SOKOL_DLL\n\n    On Windows, SOKOL_DLL will define SOKOL_TIME_API_DECL as __declspec(dllexport)\n    or __declspec(dllimport) as needed.\n\n    void stm_setup();\n        Call once before any other functions to initialize sokol_time\n        (this calls for instance QueryPerformanceFrequency on Windows)\n\n    uint64_t stm_now();\n        Get current point in time in unspecified 'ticks'. The value that\n        is returned has no relation to the 'wall-clock' time and is\n        not in a specific time unit, it is only useful to compute\n        time differences.\n\n    uint64_t stm_diff(uint64_t new, uint64_t old);\n        Computes the time difference between new and old. This will always\n        return a positive, non-zero value.\n\n    uint64_t stm_since(uint64_t start);\n        Takes the current time, and returns the elapsed time since start\n        (this is a shortcut for \"stm_diff(stm_now(), start)\")\n\n    uint64_t stm_laptime(uint64_t* last_time);\n        This is useful for measuring frame time and other recurring\n        events. It takes the current time, returns the time difference\n        to the value in last_time, and stores the current time in\n        last_time for the next call. If the value in last_time is 0,\n        the return value will be zero (this usually happens on the\n        very first call).\n\n    uint64_t stm_round_to_common_refresh_rate(uint64_t duration)\n        This oddly named function takes a measured frame time and\n        returns the closest \"nearby\" common display refresh rate frame duration\n        in ticks. If the input duration isn't close to any common display\n        refresh rate, the input duration will be returned unchanged as a fallback.\n        The main purpose of this function is to remove jitter/inaccuracies from\n        measured frame times, and instead use the display refresh rate as\n        frame duration.\n        NOTE: for more robust frame timing, consider using the\n        sokol_app.h function sapp_frame_duration()\n\n    Use the following functions to convert a duration in ticks into\n    useful time units:\n\n    double stm_sec(uint64_t ticks);\n    double stm_ms(uint64_t ticks);\n    double stm_us(uint64_t ticks);\n    double stm_ns(uint64_t ticks);\n        Converts a tick value into seconds, milliseconds, microseconds\n        or nanoseconds. Note that not all platforms will have nanosecond\n        or even microsecond precision.\n\n    Uses the following time measurement functions under the hood:\n\n    Windows:        QueryPerformanceFrequency() / QueryPerformanceCounter()\n    MacOS/iOS:      mach_absolute_time()\n    emscripten:     emscripten_get_now()\n    Linux+others:   clock_gettime(CLOCK_MONOTONIC)\n\n    zlib/libpng license\n\n    Copyright (c) 2018 Andre Weissflog\n\n    This software is provided 'as-is', without any express or implied warranty.\n    In no event will the authors be held liable for any damages arising from the\n    use of this software.\n\n    Permission is granted to anyone to use this software for any purpose,\n    including commercial applications, and to alter it and redistribute it\n    freely, subject to the following restrictions:\n\n        1. The origin of this software must not be misrepresented; you must not\n        claim that you wrote the original software. If you use this software in a\n        product, an acknowledgment in the product documentation would be\n        appreciated but is not required.\n\n        2. Altered source versions must be plainly marked as such, and must not\n        be misrepresented as being the original software.\n\n        3. This notice may not be removed or altered from any source\n        distribution.\n*/\n#define SOKOL_TIME_INCLUDED (1)\n#include <stdint.h>\n\n#if defined(SOKOL_API_DECL) && !defined(SOKOL_TIME_API_DECL)\n#define SOKOL_TIME_API_DECL SOKOL_API_DECL\n#endif\n#ifndef SOKOL_TIME_API_DECL\n#if defined(_WIN32) && defined(SOKOL_DLL) && defined(SOKOL_TIME_IMPL)\n#define SOKOL_TIME_API_DECL __declspec(dllexport)\n#elif defined(_WIN32) && defined(SOKOL_DLL)\n#define SOKOL_TIME_API_DECL __declspec(dllimport)\n#else\n#define SOKOL_TIME_API_DECL extern\n#endif\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nSOKOL_TIME_API_DECL void stm_setup(void);\nSOKOL_TIME_API_DECL uint64_t stm_now(void);\nSOKOL_TIME_API_DECL uint64_t stm_diff(uint64_t new_ticks, uint64_t old_ticks);\nSOKOL_TIME_API_DECL uint64_t stm_since(uint64_t start_ticks);\nSOKOL_TIME_API_DECL uint64_t stm_laptime(uint64_t* last_time);\nSOKOL_TIME_API_DECL uint64_t stm_round_to_common_refresh_rate(uint64_t frame_ticks);\nSOKOL_TIME_API_DECL double stm_sec(uint64_t ticks);\nSOKOL_TIME_API_DECL double stm_ms(uint64_t ticks);\nSOKOL_TIME_API_DECL double stm_us(uint64_t ticks);\nSOKOL_TIME_API_DECL double stm_ns(uint64_t ticks);\n\n#ifdef __cplusplus\n} /* extern \"C\" */\n#endif\n#endif // SOKOL_TIME_INCLUDED\n\n/*-- IMPLEMENTATION ----------------------------------------------------------*/\n#ifdef SOKOL_TIME_IMPL\n#define SOKOL_TIME_IMPL_INCLUDED (1)\n#include <string.h> /* memset */\n\n#ifndef SOKOL_API_IMPL\n    #define SOKOL_API_IMPL\n#endif\n#ifndef SOKOL_ASSERT\n    #include <assert.h>\n    #define SOKOL_ASSERT(c) assert(c)\n#endif\n#ifndef _SOKOL_PRIVATE\n    #if defined(__GNUC__) || defined(__clang__)\n        #define _SOKOL_PRIVATE __attribute__((unused)) static\n    #else\n        #define _SOKOL_PRIVATE static\n    #endif\n#endif\n\n#if defined(_WIN32)\n#ifndef WIN32_LEAN_AND_MEAN\n#define WIN32_LEAN_AND_MEAN\n#endif\n#include <windows.h>\ntypedef struct {\n    uint32_t initialized;\n    LARGE_INTEGER freq;\n    LARGE_INTEGER start;\n} _stm_state_t;\n#elif defined(__APPLE__) && defined(__MACH__)\n#include <mach/mach_time.h>\ntypedef struct {\n    uint32_t initialized;\n    mach_timebase_info_data_t timebase;\n    uint64_t start;\n} _stm_state_t;\n#elif defined(__EMSCRIPTEN__)\n#include <emscripten/emscripten.h>\ntypedef struct {\n    uint32_t initialized;\n    double start;\n} _stm_state_t;\n#else /* anything else, this will need more care for non-Linux platforms */\n#ifdef ESP8266\n// On the ESP8266, clock_gettime ignores the first argument and CLOCK_MONOTONIC isn't defined\n#define CLOCK_MONOTONIC 0\n#endif\n#include <time.h>\ntypedef struct {\n    uint32_t initialized;\n    uint64_t start;\n} _stm_state_t;\n#endif\nstatic _stm_state_t _stm;\n\n/* prevent 64-bit overflow when computing relative timestamp\n    see https://gist.github.com/jspohr/3dc4f00033d79ec5bdaf67bc46c813e3\n*/\n#if defined(_WIN32) || (defined(__APPLE__) && defined(__MACH__))\n_SOKOL_PRIVATE int64_t _stm_int64_muldiv(int64_t value, int64_t numer, int64_t denom) {\n    int64_t q = value / denom;\n    int64_t r = value % denom;\n    return q * numer + r * numer / denom;\n}\n#endif\n\nSOKOL_API_IMPL void stm_setup(void) {\n    memset(&_stm, 0, sizeof(_stm));\n    _stm.initialized = 0xABCDABCD;\n    #if defined(_WIN32)\n        QueryPerformanceFrequency(&_stm.freq);\n        QueryPerformanceCounter(&_stm.start);\n    #elif defined(__APPLE__) && defined(__MACH__)\n        mach_timebase_info(&_stm.timebase);\n        _stm.start = mach_absolute_time();\n    #elif defined(__EMSCRIPTEN__)\n        _stm.start = emscripten_get_now();\n    #else\n        struct timespec ts;\n        clock_gettime(CLOCK_MONOTONIC, &ts);\n        _stm.start = (uint64_t)ts.tv_sec*1000000000 + (uint64_t)ts.tv_nsec;\n    #endif\n}\n\nSOKOL_API_IMPL uint64_t stm_now(void) {\n    SOKOL_ASSERT(_stm.initialized == 0xABCDABCD);\n    uint64_t now;\n    #if defined(_WIN32)\n        LARGE_INTEGER qpc_t;\n        QueryPerformanceCounter(&qpc_t);\n        now = (uint64_t) _stm_int64_muldiv(qpc_t.QuadPart - _stm.start.QuadPart, 1000000000, _stm.freq.QuadPart);\n    #elif defined(__APPLE__) && defined(__MACH__)\n        const uint64_t mach_now = mach_absolute_time() - _stm.start;\n        now = (uint64_t) _stm_int64_muldiv((int64_t)mach_now, (int64_t)_stm.timebase.numer, (int64_t)_stm.timebase.denom);\n    #elif defined(__EMSCRIPTEN__)\n        double js_now = emscripten_get_now() - _stm.start;\n        now = (uint64_t) (js_now * 1000000.0);\n    #else\n        struct timespec ts;\n        clock_gettime(CLOCK_MONOTONIC, &ts);\n        now = ((uint64_t)ts.tv_sec*1000000000 + (uint64_t)ts.tv_nsec) - _stm.start;\n    #endif\n    return now;\n}\n\nSOKOL_API_IMPL uint64_t stm_diff(uint64_t new_ticks, uint64_t old_ticks) {\n    if (new_ticks > old_ticks) {\n        return new_ticks - old_ticks;\n    }\n    else {\n        return 1;\n    }\n}\n\nSOKOL_API_IMPL uint64_t stm_since(uint64_t start_ticks) {\n    return stm_diff(stm_now(), start_ticks);\n}\n\nSOKOL_API_IMPL uint64_t stm_laptime(uint64_t* last_time) {\n    SOKOL_ASSERT(last_time);\n    uint64_t dt = 0;\n    uint64_t now = stm_now();\n    if (0 != *last_time) {\n        dt = stm_diff(now, *last_time);\n    }\n    *last_time = now;\n    return dt;\n}\n\n// first number is frame duration in ns, second number is tolerance in ns,\n// the resulting min/max values must not overlap!\nstatic const uint64_t _stm_refresh_rates[][2] = {\n    { 16666667, 1000000 },  //  60 Hz: 16.6667 +- 1ms\n    { 13888889,  250000 },  //  72 Hz: 13.8889 +- 0.25ms\n    { 13333333,  250000 },  //  75 Hz: 13.3333 +- 0.25ms\n    { 11764706,  250000 },  //  85 Hz: 11.7647 +- 0.25\n    { 11111111,  250000 },  //  90 Hz: 11.1111 +- 0.25ms\n    { 10000000,  500000 },  // 100 Hz: 10.0000 +- 0.5ms\n    {  8333333,  500000 },  // 120 Hz:  8.3333 +- 0.5ms\n    {  6944445,  500000 },  // 144 Hz:  6.9445 +- 0.5ms\n    {  4166667, 1000000 },  // 240 Hz:  4.1666 +- 1ms\n    {        0,       0 },  // keep the last element always at zero\n};\n\nSOKOL_API_IMPL uint64_t stm_round_to_common_refresh_rate(uint64_t ticks) {\n    uint64_t ns;\n    int i = 0;\n    while (0 != (ns = _stm_refresh_rates[i][0])) {\n        uint64_t tol = _stm_refresh_rates[i][1];\n        if ((ticks > (ns - tol)) && (ticks < (ns + tol))) {\n            return ns;\n        }\n        i++;\n    }\n    // fallthrough: didn't fit into any buckets\n    return ticks;\n}\n\nSOKOL_API_IMPL double stm_sec(uint64_t ticks) {\n    return (double)ticks / 1000000000.0;\n}\n\nSOKOL_API_IMPL double stm_ms(uint64_t ticks) {\n    return (double)ticks / 1000000.0;\n}\n\nSOKOL_API_IMPL double stm_us(uint64_t ticks) {\n    return (double)ticks / 1000.0;\n}\n\nSOKOL_API_IMPL double stm_ns(uint64_t ticks) {\n    return (double)ticks;\n}\n#endif /* SOKOL_TIME_IMPL */\n\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "util",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}