{
  "metadata": {
    "timestamp": 1736710338115,
    "page": 144,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "madler/zlib",
      "stars": 5874,
      "defaultBranch": "develop",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.3583984375,
          "content": "*.diff\n*.patch\n*.orig\n*.rej\n\n*~\n*.a\n*.lo\n*.o\n*.dylib\n\n*.gcda\n*.gcno\n*.gcov\n\n/example\n/example64\n/examplesh\n**/libz.so*\n/minigzip\n/minigzip64\n/minigzipsh\n/zlib.pc\n/configure.log\n/build\n\n.DS_Store\n.vs\n*.user\n*.nupkg\ncontrib/vstudio/vc143/x86\ncontrib/vstudio/vc143/x64\ncontrib/vstudio/vc143/arm\ncontrib/vstudio/vc143/arm64\ncontrib/nuget/bin\ncontrib/nuget/obj\n*.included\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 7.6474609375,
          "content": "cmake_minimum_required(VERSION 2.4.4...3.15.0)\nset(CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS ON)\n\nproject(zlib C)\n\nset(VERSION \"1.3.1.1\")\n\noption(ZLIB_BUILD_EXAMPLES \"Enable Zlib Examples\" ON)\n\nset(INSTALL_BIN_DIR \"${CMAKE_INSTALL_PREFIX}/bin\" CACHE PATH \"Installation directory for executables\")\nset(INSTALL_LIB_DIR \"${CMAKE_INSTALL_PREFIX}/lib\" CACHE PATH \"Installation directory for libraries\")\nset(INSTALL_INC_DIR \"${CMAKE_INSTALL_PREFIX}/include\" CACHE PATH \"Installation directory for headers\")\nset(INSTALL_MAN_DIR \"${CMAKE_INSTALL_PREFIX}/share/man\" CACHE PATH \"Installation directory for manual pages\")\nset(INSTALL_PKGCONFIG_DIR \"${CMAKE_INSTALL_PREFIX}/share/pkgconfig\" CACHE PATH \"Installation directory for pkgconfig (.pc) files\")\n\ninclude(CheckTypeSize)\ninclude(CheckFunctionExists)\ninclude(CheckIncludeFile)\ninclude(CheckCSourceCompiles)\nenable_testing()\n\ncheck_include_file(sys/types.h HAVE_SYS_TYPES_H)\ncheck_include_file(stdint.h    HAVE_STDINT_H)\ncheck_include_file(stddef.h    HAVE_STDDEF_H)\n\n#\n# Check to see if we have large file support\n#\nset(CMAKE_REQUIRED_DEFINITIONS -D_LARGEFILE64_SOURCE=1)\n# We add these other definitions here because CheckTypeSize.cmake\n# in CMake 2.4.x does not automatically do so and we want\n# compatibility with CMake 2.4.x.\nif(HAVE_SYS_TYPES_H)\n    list(APPEND CMAKE_REQUIRED_DEFINITIONS -DHAVE_SYS_TYPES_H)\nendif()\nif(HAVE_STDINT_H)\n    list(APPEND CMAKE_REQUIRED_DEFINITIONS -DHAVE_STDINT_H)\nendif()\nif(HAVE_STDDEF_H)\n    list(APPEND CMAKE_REQUIRED_DEFINITIONS -DHAVE_STDDEF_H)\nendif()\ncheck_type_size(off64_t OFF64_T)\nif(HAVE_OFF64_T)\n   add_definitions(-D_LARGEFILE64_SOURCE=1)\nendif()\nset(CMAKE_REQUIRED_DEFINITIONS) # clear variable\n\n#\n# Check for fseeko\n#\ncheck_function_exists(fseeko HAVE_FSEEKO)\nif(NOT HAVE_FSEEKO)\n    add_definitions(-DNO_FSEEKO)\nendif()\n\n#\n# Check for unistd.h\n#\ncheck_include_file(unistd.h Z_HAVE_UNISTD_H)\n\nif(MSVC)\n    set(CMAKE_DEBUG_POSTFIX \"d\")\n    add_definitions(-D_CRT_SECURE_NO_DEPRECATE)\n    add_definitions(-D_CRT_NONSTDC_NO_DEPRECATE)\n    include_directories(${CMAKE_CURRENT_SOURCE_DIR})\nendif()\n\noption(RENAME_ZCONF \"Rename the zconf when building out of source\" ON)\nif(NOT CMAKE_CURRENT_SOURCE_DIR STREQUAL CMAKE_CURRENT_BINARY_DIR AND RENAME_ZCONF)\n    # If we're doing an out of source build and the user has a zconf.h\n    # in their source tree...\n    if(EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/zconf.h)\n        message(STATUS \"Renaming\")\n        message(STATUS \"    ${CMAKE_CURRENT_SOURCE_DIR}/zconf.h\")\n        message(STATUS \"to 'zconf.h.included' because this file is included with zlib\")\n        message(STATUS \"but CMake generates it automatically in the build directory.\")\n        file(RENAME ${CMAKE_CURRENT_SOURCE_DIR}/zconf.h ${CMAKE_CURRENT_SOURCE_DIR}/zconf.h.included)\n  endif()\nendif()\n\nset(ZLIB_PC ${CMAKE_CURRENT_BINARY_DIR}/zlib.pc)\nconfigure_file( ${CMAKE_CURRENT_SOURCE_DIR}/zlib.pc.cmakein\n\t\t${ZLIB_PC} @ONLY)\nconfigure_file(\t${CMAKE_CURRENT_SOURCE_DIR}/zconf.h.cmakein\n\t\t${CMAKE_CURRENT_BINARY_DIR}/zconf.h @ONLY)\ninclude_directories(${CMAKE_CURRENT_BINARY_DIR} ${CMAKE_SOURCE_DIR})\n\n\n#============================================================================\n# zlib\n#============================================================================\n\nset(ZLIB_PUBLIC_HDRS\n    ${CMAKE_CURRENT_BINARY_DIR}/zconf.h\n    zlib.h\n)\nset(ZLIB_PRIVATE_HDRS\n    crc32.h\n    deflate.h\n    gzguts.h\n    inffast.h\n    inffixed.h\n    inflate.h\n    inftrees.h\n    trees.h\n    zutil.h\n)\nset(ZLIB_SRCS\n    adler32.c\n    compress.c\n    crc32.c\n    deflate.c\n    gzclose.c\n    gzlib.c\n    gzread.c\n    gzwrite.c\n    inflate.c\n    infback.c\n    inftrees.c\n    inffast.c\n    trees.c\n    uncompr.c\n    zutil.c\n)\n\nif(NOT MINGW)\n    set(ZLIB_DLL_SRCS\n        win32/zlib1.rc # If present will override custom build rule below.\n    )\nendif()\n\n# parse the full version number from zlib.h and include in ZLIB_FULL_VERSION\nfile(READ ${CMAKE_CURRENT_SOURCE_DIR}/zlib.h _zlib_h_contents)\nstring(REGEX REPLACE \".*#define[ \\t]+ZLIB_VERSION[ \\t]+\\\"([-0-9A-Za-z.]+)\\\".*\"\n    \"\\\\1\" ZLIB_FULL_VERSION ${_zlib_h_contents})\n\nif(MINGW)\n    # This gets us DLL resource information when compiling on MinGW.\n    if(NOT CMAKE_RC_COMPILER)\n        set(CMAKE_RC_COMPILER windres.exe)\n    endif()\n\n    add_custom_command(OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/zlib1rc.obj\n                       COMMAND ${CMAKE_RC_COMPILER}\n                            -D GCC_WINDRES\n                            -I ${CMAKE_CURRENT_SOURCE_DIR}\n                            -I ${CMAKE_CURRENT_BINARY_DIR}\n                            -o ${CMAKE_CURRENT_BINARY_DIR}/zlib1rc.obj\n                            -i ${CMAKE_CURRENT_SOURCE_DIR}/win32/zlib1.rc)\n    set(ZLIB_DLL_SRCS ${CMAKE_CURRENT_BINARY_DIR}/zlib1rc.obj)\nendif(MINGW)\n\nadd_library(zlib SHARED ${ZLIB_SRCS} ${ZLIB_DLL_SRCS} ${ZLIB_PUBLIC_HDRS} ${ZLIB_PRIVATE_HDRS})\ntarget_include_directories(zlib PUBLIC\n    $<BUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}>\n    $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>)\nadd_library(zlibstatic STATIC ${ZLIB_SRCS} ${ZLIB_PUBLIC_HDRS} ${ZLIB_PRIVATE_HDRS})\ntarget_include_directories(zlibstatic PUBLIC\n    $<BUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}>\n    $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>)\nset_target_properties(zlib PROPERTIES DEFINE_SYMBOL ZLIB_DLL)\nset_target_properties(zlib PROPERTIES SOVERSION 1)\n\nif(NOT CYGWIN)\n    # This property causes shared libraries on Linux to have the full version\n    # encoded into their final filename.  We disable this on Cygwin because\n    # it causes cygz-${ZLIB_FULL_VERSION}.dll to be created when cygz.dll\n    # seems to be the default.\n    #\n    # This has no effect with MSVC, on that platform the version info for\n    # the DLL comes from the resource file win32/zlib1.rc\n    set_target_properties(zlib PROPERTIES VERSION ${ZLIB_FULL_VERSION})\nendif()\n\nif(UNIX)\n    # On unix-like platforms the library is almost always called libz\n   set_target_properties(zlib zlibstatic PROPERTIES OUTPUT_NAME z)\n   if(NOT APPLE AND NOT(CMAKE_SYSTEM_NAME STREQUAL AIX))\n     set_target_properties(zlib PROPERTIES LINK_FLAGS \"-Wl,--version-script,\\\"${CMAKE_CURRENT_SOURCE_DIR}/zlib.map\\\"\")\n   endif()\nelseif(BUILD_SHARED_LIBS AND WIN32)\n    # Creates zlib1.dll when building shared library version\n    set_target_properties(zlib PROPERTIES SUFFIX \"1.dll\")\nendif()\n\nif(NOT SKIP_INSTALL_LIBRARIES AND NOT SKIP_INSTALL_ALL )\n    install(TARGETS zlib zlibstatic\n        RUNTIME DESTINATION \"${INSTALL_BIN_DIR}\"\n        ARCHIVE DESTINATION \"${INSTALL_LIB_DIR}\"\n        LIBRARY DESTINATION \"${INSTALL_LIB_DIR}\" )\nendif()\nif(NOT SKIP_INSTALL_HEADERS AND NOT SKIP_INSTALL_ALL )\n    install(FILES ${ZLIB_PUBLIC_HDRS} DESTINATION \"${INSTALL_INC_DIR}\")\nendif()\nif(NOT SKIP_INSTALL_FILES AND NOT SKIP_INSTALL_ALL )\n    install(FILES zlib.3 DESTINATION \"${INSTALL_MAN_DIR}/man3\")\nendif()\nif(NOT SKIP_INSTALL_FILES AND NOT SKIP_INSTALL_ALL )\n    install(FILES ${ZLIB_PC} DESTINATION \"${INSTALL_PKGCONFIG_DIR}\")\nendif()\n\n#============================================================================\n# Example binaries\n#============================================================================\nif(ZLIB_BUILD_EXAMPLES)\n    add_executable(example test/example.c)\n    target_link_libraries(example zlib)\n    add_test(example example)\n\n    add_executable(minigzip test/minigzip.c)\n    target_link_libraries(minigzip zlib)\n\n    if(HAVE_OFF64_T)\n        add_executable(example64 test/example.c)\n        target_link_libraries(example64 zlib)\n        set_target_properties(example64 PROPERTIES COMPILE_FLAGS \"-D_FILE_OFFSET_BITS=64\")\n        add_test(example64 example64)\n\n        add_executable(minigzip64 test/minigzip.c)\n        target_link_libraries(minigzip64 zlib)\n        set_target_properties(minigzip64 PROPERTIES COMPILE_FLAGS \"-D_FILE_OFFSET_BITS=64\")\n    endif()\nendif()\n"
        },
        {
          "name": "ChangeLog",
          "type": "blob",
          "size": 81.908203125,
          "content": "\n                ChangeLog file for zlib\n\nChanges in 1.3.1.1 (xx Jan 2024)\n- \n\nChanges in 1.3.1 (22 Jan 2024)\n- Reject overflows of zip header fields in minizip\n- Fix bug in inflateSync() for data held in bit buffer\n- Add LIT_MEM define to use more memory for a small deflate speedup\n- Fix decision on the emission of Zip64 end records in minizip\n- Add bounds checking to ERR_MSG() macro, used by zError()\n- Neutralize zip file traversal attacks in miniunz\n- Fix a bug in ZLIB_DEBUG compiles in check_match()\n- Various portability and appearance improvements\n\nChanges in 1.3 (18 Aug 2023)\n- Remove K&R function definitions and zlib2ansi\n- Fix bug in deflateBound() for level 0 and memLevel 9\n- Fix bug when gzungetc() is used immediately after gzopen()\n- Fix bug when using gzflush() with a very small buffer\n- Fix crash when gzsetparams() attempted for transparent write\n- Fix test/example.c to work with FORCE_STORED\n- Rewrite of zran in examples (see zran.c version history)\n- Fix minizip to allow it to open an empty zip file\n- Fix reading disk number start on zip64 files in minizip\n- Fix logic error in minizip argument processing\n- Add minizip testing to Makefile\n- Read multiple bytes instead of byte-by-byte in minizip unzip.c\n- Add memory sanitizer to configure (--memory)\n- Various portability improvements\n- Various documentation improvements\n- Various spelling and typo corrections\n\nChanges in 1.2.13 (13 Oct 2022)\n- Fix configure issue that discarded provided CC definition\n- Correct incorrect inputs provided to the CRC functions\n- Repair prototypes and exporting of new CRC functions\n- Fix inflateBack to detect invalid input with distances too far\n- Have infback() deliver all of the available output up to any error\n- Fix a bug when getting a gzip header extra field with inflate()\n- Fix bug in block type selection when Z_FIXED used\n- Tighten deflateBound bounds\n- Remove deleted assembler code references\n- Various portability and appearance improvements\n\nChanges in 1.2.12 (27 Mar 2022)\n- Cygwin does not have _wopen(), so do not create gzopen_w() there\n- Permit a deflateParams() parameter change as soon as possible\n- Limit hash table inserts after switch from stored deflate\n- Fix bug when window full in deflate_stored()\n- Fix CLEAR_HASH macro to be usable as a single statement\n- Avoid a conversion error in gzseek when off_t type too small\n- Have Makefile return non-zero error code on test failure\n- Avoid some conversion warnings in gzread.c and gzwrite.c\n- Update use of errno for newer Windows CE versions\n- Small speedup to inflate [psumbera]\n- Return an error if the gzputs string length can't fit in an int\n- Add address checking in clang to -w option of configure\n- Don't compute check value for raw inflate if asked to validate\n- Handle case where inflateSync used when header never processed\n- Avoid the use of ptrdiff_t\n- Avoid an undefined behavior of memcpy() in gzappend()\n- Avoid undefined behaviors of memcpy() in gz*printf()\n- Avoid an undefined behavior of memcpy() in _tr_stored_block()\n- Make the names in functions declarations identical to definitions\n- Remove old assembler code in which bugs have manifested\n- Fix deflateEnd() to not report an error at start of raw deflate\n- Add legal disclaimer to README\n- Emphasize the need to continue decompressing gzip members\n- Correct the initialization requirements for deflateInit2()\n- Fix a bug that can crash deflate on some input when using Z_FIXED\n- Assure that the number of bits for deflatePrime() is valid\n- Use a structure to make globals in enough.c evident\n- Use a macro for the printf format of big_t in enough.c\n- Clean up code style in enough.c, update version\n- Use inline function instead of macro for index in enough.c\n- Clarify that prefix codes are counted in enough.c\n- Show all the codes for the maximum tables size in enough.c\n- Add gznorm.c example, which normalizes gzip files\n- Fix the zran.c example to work on a multiple-member gzip file\n- Add tables for crc32_combine(), to speed it up by a factor of 200\n- Add crc32_combine_gen() and crc32_combine_op() for fast combines\n- Speed up software CRC-32 computation by a factor of 1.5 to 3\n- Use atomic test and set, if available, for dynamic CRC tables\n- Don't bother computing check value after successful inflateSync()\n- Correct comment in crc32.c\n- Add use of the ARMv8 crc32 instructions when requested\n- Use ARM crc32 instructions if the ARM architecture has them\n- Explicitly note that the 32-bit check values are 32 bits\n- Avoid adding empty gzip member after gzflush with Z_FINISH\n- Fix memory leak on error in gzlog.c\n- Fix error in comment on the polynomial representation of a byte\n- Clarify gz* function interfaces, referring to parameter names\n- Change macro name in inflate.c to avoid collision in VxWorks\n- Correct typo in blast.c\n- Improve portability of contrib/minizip\n- Fix indentation in minizip's zip.c\n- Replace black/white with allow/block. (theresa-m)\n- minizip warning fix if MAXU32 already defined. (gvollant)\n- Fix unztell64() in minizip to work past 4GB. (Daniël Hörchner)\n- Clean up minizip to reduce warnings for testing\n- Add fallthrough comments for gcc\n- Eliminate use of ULL constants\n- Separate out address sanitizing from warnings in configure\n- Remove destructive aspects of make distclean\n- Check for cc masquerading as gcc or clang in configure\n- Fix crc32.c to compile local functions only if used\n\nChanges in 1.2.11 (15 Jan 2017)\n- Fix deflate stored bug when pulling last block from window\n- Permit immediate deflateParams changes before any deflate input\n\nChanges in 1.2.10 (2 Jan 2017)\n- Avoid warnings on snprintf() return value\n- Fix bug in deflate_stored() for zero-length input\n- Fix bug in gzwrite.c that produced corrupt gzip files\n- Remove files to be installed before copying them in Makefile.in\n- Add warnings when compiling with assembler code\n\nChanges in 1.2.9 (31 Dec 2016)\n- Fix contrib/minizip to permit unzipping with desktop API [Zouzou]\n- Improve contrib/blast to return unused bytes\n- Assure that gzoffset() is correct when appending\n- Improve compress() and uncompress() to support large lengths\n- Fix bug in test/example.c where error code not saved\n- Remedy Coverity warning [Randers-Pehrson]\n- Improve speed of gzprintf() in transparent mode\n- Fix inflateInit2() bug when windowBits is 16 or 32\n- Change DEBUG macro to ZLIB_DEBUG\n- Avoid uninitialized access by gzclose_w()\n- Allow building zlib outside of the source directory\n- Fix bug that accepted invalid zlib header when windowBits is zero\n- Fix gzseek() problem on MinGW due to buggy _lseeki64 there\n- Loop on write() calls in gzwrite.c in case of non-blocking I/O\n- Add --warn (-w) option to ./configure for more compiler warnings\n- Reject a window size of 256 bytes if not using the zlib wrapper\n- Fix bug when level 0 used with Z_HUFFMAN or Z_RLE\n- Add --debug (-d) option to ./configure to define ZLIB_DEBUG\n- Fix bugs in creating a very large gzip header\n- Add uncompress2() function, which returns the input size used\n- Assure that deflateParams() will not switch functions mid-block\n- Dramatically speed up deflation for level 0 (storing)\n- Add gzfread(), duplicating the interface of fread()\n- Add gzfwrite(), duplicating the interface of fwrite()\n- Add deflateGetDictionary() function\n- Use snprintf() for later versions of Microsoft C\n- Fix *Init macros to use z_ prefix when requested\n- Replace as400 with os400 for OS/400 support [Monnerat]\n- Add crc32_z() and adler32_z() functions with size_t lengths\n- Update Visual Studio project files [AraHaan]\n\nChanges in 1.2.8 (28 Apr 2013)\n- Update contrib/minizip/iowin32.c for Windows RT [Vollant]\n- Do not force Z_CONST for C++\n- Clean up contrib/vstudio [Roß]\n- Correct spelling error in zlib.h\n- Fix mixed line endings in contrib/vstudio\n\nChanges in 1.2.7.3 (13 Apr 2013)\n- Fix version numbers and DLL names in contrib/vstudio/*/zlib.rc\n\nChanges in 1.2.7.2 (13 Apr 2013)\n- Change check for a four-byte type back to hexadecimal\n- Fix typo in win32/Makefile.msc\n- Add casts in gzwrite.c for pointer differences\n\nChanges in 1.2.7.1 (24 Mar 2013)\n- Replace use of unsafe string functions with snprintf if available\n- Avoid including stddef.h on Windows for Z_SOLO compile [Niessink]\n- Fix gzgetc undefine when Z_PREFIX set [Turk]\n- Eliminate use of mktemp in Makefile (not always available)\n- Fix bug in 'F' mode for gzopen()\n- Add inflateGetDictionary() function\n- Correct comment in deflate.h\n- Use _snprintf for snprintf in Microsoft C\n- On Darwin, only use /usr/bin/libtool if libtool is not Apple\n- Delete \"--version\" file if created by \"ar --version\" [Richard G.]\n- Fix configure check for veracity of compiler error return codes\n- Fix CMake compilation of static lib for MSVC2010 x64\n- Remove unused variable in infback9.c\n- Fix argument checks in gzlog_compress() and gzlog_write()\n- Clean up the usage of z_const and respect const usage within zlib\n- Clean up examples/gzlog.[ch] comparisons of different types\n- Avoid shift equal to bits in type (caused endless loop)\n- Fix uninitialized value bug in gzputc() introduced by const patches\n- Fix memory allocation error in examples/zran.c [Nor]\n- Fix bug where gzopen(), gzclose() would write an empty file\n- Fix bug in gzclose() when gzwrite() runs out of memory\n- Check for input buffer malloc failure in examples/gzappend.c\n- Add note to contrib/blast to use binary mode in stdio\n- Fix comparisons of differently signed integers in contrib/blast\n- Check for invalid code length codes in contrib/puff\n- Fix serious but very rare decompression bug in inftrees.c\n- Update inflateBack() comments, since inflate() can be faster\n- Use underscored I/O function names for WINAPI_FAMILY\n- Add _tr_flush_bits to the external symbols prefixed by --zprefix\n- Add contrib/vstudio/vc10 pre-build step for static only\n- Quote --version-script argument in CMakeLists.txt\n- Don't specify --version-script on Apple platforms in CMakeLists.txt\n- Fix casting error in contrib/testzlib/testzlib.c\n- Fix types in contrib/minizip to match result of get_crc_table()\n- Simplify contrib/vstudio/vc10 with 'd' suffix\n- Add TOP support to win32/Makefile.msc\n- Support i686 and amd64 assembler builds in CMakeLists.txt\n- Fix typos in the use of _LARGEFILE64_SOURCE in zconf.h\n- Add vc11 and vc12 build files to contrib/vstudio\n- Add gzvprintf() as an undocumented function in zlib\n- Fix configure for Sun shell\n- Remove runtime check in configure for four-byte integer type\n- Add casts and consts to ease user conversion to C++\n- Add man pages for minizip and miniunzip\n- In Makefile uninstall, don't rm if preceding cd fails\n- Do not return Z_BUF_ERROR if deflateParam() has nothing to write\n\nChanges in 1.2.7 (2 May 2012)\n- Replace use of memmove() with a simple copy for portability\n- Test for existence of strerror\n- Restore gzgetc_ for backward compatibility with 1.2.6\n- Fix build with non-GNU make on Solaris\n- Require gcc 4.0 or later on Mac OS X to use the hidden attribute\n- Include unistd.h for Watcom C\n- Use __WATCOMC__ instead of __WATCOM__\n- Do not use the visibility attribute if NO_VIZ defined\n- Improve the detection of no hidden visibility attribute\n- Avoid using __int64 for gcc or solo compilation\n- Cast to char * in gzprintf to avoid warnings [Zinser]\n- Fix make_vms.com for VAX [Zinser]\n- Don't use library or built-in byte swaps\n- Simplify test and use of gcc hidden attribute\n- Fix bug in gzclose_w() when gzwrite() fails to allocate memory\n- Add \"x\" (O_EXCL) and \"e\" (O_CLOEXEC) modes support to gzopen()\n- Fix bug in test/minigzip.c for configure --solo\n- Fix contrib/vstudio project link errors [Mohanathas]\n- Add ability to choose the builder in make_vms.com [Schweda]\n- Add DESTDIR support to mingw32 win32/Makefile.gcc\n- Fix comments in win32/Makefile.gcc for proper usage\n- Allow overriding the default install locations for cmake\n- Generate and install the pkg-config file with cmake\n- Build both a static and a shared version of zlib with cmake\n- Include version symbols for cmake builds\n- If using cmake with MSVC, add the source directory to the includes\n- Remove unneeded EXTRA_CFLAGS from win32/Makefile.gcc [Truta]\n- Move obsolete emx makefile to old [Truta]\n- Allow the use of -Wundef when compiling or using zlib\n- Avoid the use of the -u option with mktemp\n- Improve inflate() documentation on the use of Z_FINISH\n- Recognize clang as gcc\n- Add gzopen_w() in Windows for wide character path names\n- Rename zconf.h in CMakeLists.txt to move it out of the way\n- Add source directory in CMakeLists.txt for building examples\n- Look in build directory for zlib.pc in CMakeLists.txt\n- Remove gzflags from zlibvc.def in vc9 and vc10\n- Fix contrib/minizip compilation in the MinGW environment\n- Update ./configure for Solaris, support --64 [Mooney]\n- Remove -R. from Solaris shared build (possible security issue)\n- Avoid race condition for parallel make (-j) running example\n- Fix type mismatch between get_crc_table() and crc_table\n- Fix parsing of version with \"-\" in CMakeLists.txt [Snider, Ziegler]\n- Fix the path to zlib.map in CMakeLists.txt\n- Force the native libtool in Mac OS X to avoid GNU libtool [Beebe]\n- Add instructions to win32/Makefile.gcc for shared install [Torri]\n\nChanges in 1.2.6.1 (12 Feb 2012)\n- Avoid the use of the Objective-C reserved name \"id\"\n- Include io.h in gzguts.h for Microsoft compilers\n- Fix problem with ./configure --prefix and gzgetc macro\n- Include gz_header definition when compiling zlib solo\n- Put gzflags() functionality back in zutil.c\n- Avoid library header include in crc32.c for Z_SOLO\n- Use name in GCC_CLASSIC as C compiler for coverage testing, if set\n- Minor cleanup in contrib/minizip/zip.c [Vollant]\n- Update make_vms.com [Zinser]\n- Remove unnecessary gzgetc_ function\n- Use optimized byte swap operations for Microsoft and GNU [Snyder]\n- Fix minor typo in zlib.h comments [Rzesniowiecki]\n\nChanges in 1.2.6 (29 Jan 2012)\n- Update the Pascal interface in contrib/pascal\n- Fix function numbers for gzgetc_ in zlibvc.def files\n- Fix configure.ac for contrib/minizip [Schiffer]\n- Fix large-entry detection in minizip on 64-bit systems [Schiffer]\n- Have ./configure use the compiler return code for error indication\n- Fix CMakeLists.txt for cross compilation [McClure]\n- Fix contrib/minizip/zip.c for 64-bit architectures [Dalsnes]\n- Fix compilation of contrib/minizip on FreeBSD [Marquez]\n- Correct suggested usages in win32/Makefile.msc [Shachar, Horvath]\n- Include io.h for Turbo C / Borland C on all platforms [Truta]\n- Make version explicit in contrib/minizip/configure.ac [Bosmans]\n- Avoid warning for no encryption in contrib/minizip/zip.c [Vollant]\n- Minor cleanup up contrib/minizip/unzip.c [Vollant]\n- Fix bug when compiling minizip with C++ [Vollant]\n- Protect for long name and extra fields in contrib/minizip [Vollant]\n- Avoid some warnings in contrib/minizip [Vollant]\n- Add -I../.. -L../.. to CFLAGS for minizip and miniunzip\n- Add missing libs to minizip linker command\n- Add support for VPATH builds in contrib/minizip\n- Add an --enable-demos option to contrib/minizip/configure\n- Add the generation of configure.log by ./configure\n- Exit when required parameters not provided to win32/Makefile.gcc\n- Have gzputc return the character written instead of the argument\n- Use the -m option on ldconfig for BSD systems [Tobias]\n- Correct in zlib.map when deflateResetKeep was added\n\nChanges in 1.2.5.3 (15 Jan 2012)\n- Restore gzgetc function for binary compatibility\n- Do not use _lseeki64 under Borland C++ [Truta]\n- Update win32/Makefile.msc to build test/*.c [Truta]\n- Remove old/visualc6 given CMakefile and other alternatives\n- Update AS400 build files and documentation [Monnerat]\n- Update win32/Makefile.gcc to build test/*.c [Truta]\n- Permit stronger flushes after Z_BLOCK flushes\n- Avoid extraneous empty blocks when doing empty flushes\n- Permit Z_NULL arguments to deflatePending\n- Allow deflatePrime() to insert bits in the middle of a stream\n- Remove second empty static block for Z_PARTIAL_FLUSH\n- Write out all of the available bits when using Z_BLOCK\n- Insert the first two strings in the hash table after a flush\n\nChanges in 1.2.5.2 (17 Dec 2011)\n- fix ld error: unable to find version dependency 'ZLIB_1.2.5'\n- use relative symlinks for shared libs\n- Avoid searching past window for Z_RLE strategy\n- Assure that high-water mark initialization is always applied in deflate\n- Add assertions to fill_window() in deflate.c to match comments\n- Update python link in README\n- Correct spelling error in gzread.c\n- Fix bug in gzgets() for a concatenated empty gzip stream\n- Correct error in comment for gz_make()\n- Change gzread() and related to ignore junk after gzip streams\n- Allow gzread() and related to continue after gzclearerr()\n- Allow gzrewind() and gzseek() after a premature end-of-file\n- Simplify gzseek() now that raw after gzip is ignored\n- Change gzgetc() to a macro for speed (~40% speedup in testing)\n- Fix gzclose() to return the actual error last encountered\n- Always add large file support for windows\n- Include zconf.h for windows large file support\n- Include zconf.h.cmakein for windows large file support\n- Update zconf.h.cmakein on make distclean\n- Merge vestigial vsnprintf determination from zutil.h to gzguts.h\n- Clarify how gzopen() appends in zlib.h comments\n- Correct documentation of gzdirect() since junk at end now ignored\n- Add a transparent write mode to gzopen() when 'T' is in the mode\n- Update python link in zlib man page\n- Get inffixed.h and MAKEFIXED result to match\n- Add a ./config --solo option to make zlib subset with no library use\n- Add undocumented inflateResetKeep() function for CAB file decoding\n- Add --cover option to ./configure for gcc coverage testing\n- Add #define ZLIB_CONST option to use const in the z_stream interface\n- Add comment to gzdopen() in zlib.h to use dup() when using fileno()\n- Note behavior of uncompress() to provide as much data as it can\n- Add files in contrib/minizip to aid in building libminizip\n- Split off AR options in Makefile.in and configure\n- Change ON macro to Z_ARG to avoid application conflicts\n- Facilitate compilation with Borland C++ for pragmas and vsnprintf\n- Include io.h for Turbo C / Borland C++\n- Move example.c and minigzip.c to test/\n- Simplify incomplete code table filling in inflate_table()\n- Remove code from inflate.c and infback.c that is impossible to execute\n- Test the inflate code with full coverage\n- Allow deflateSetDictionary, inflateSetDictionary at any time (in raw)\n- Add deflateResetKeep and fix inflateResetKeep to retain dictionary\n- Fix gzwrite.c to accommodate reduced memory zlib compilation\n- Have inflate() with Z_FINISH avoid the allocation of a window\n- Do not set strm->adler when doing raw inflate\n- Fix gzeof() to behave just like feof() when read is not past end of file\n- Fix bug in gzread.c when end-of-file is reached\n- Avoid use of Z_BUF_ERROR in gz* functions except for premature EOF\n- Document gzread() capability to read concurrently written files\n- Remove hard-coding of resource compiler in CMakeLists.txt [Blammo]\n\nChanges in 1.2.5.1 (10 Sep 2011)\n- Update FAQ entry on shared builds (#13)\n- Avoid symbolic argument to chmod in Makefile.in\n- Fix bug and add consts in contrib/puff [Oberhumer]\n- Update contrib/puff/zeros.raw test file to have all block types\n- Add full coverage test for puff in contrib/puff/Makefile\n- Fix static-only-build install in Makefile.in\n- Fix bug in unzGetCurrentFileInfo() in contrib/minizip [Kuno]\n- Add libz.a dependency to shared in Makefile.in for parallel builds\n- Spell out \"number\" (instead of \"nb\") in zlib.h for total_in, total_out\n- Replace $(...) with `...` in configure for non-bash sh [Bowler]\n- Add darwin* to Darwin* and solaris* to SunOS\\ 5* in configure [Groffen]\n- Add solaris* to Linux* in configure to allow gcc use [Groffen]\n- Add *bsd* to Linux* case in configure [Bar-Lev]\n- Add inffast.obj to dependencies in win32/Makefile.msc\n- Correct spelling error in deflate.h [Kohler]\n- Change libzdll.a again to libz.dll.a (!) in win32/Makefile.gcc\n- Add test to configure for GNU C looking for gcc in output of $cc -v\n- Add zlib.pc generation to win32/Makefile.gcc [Weigelt]\n- Fix bug in zlib.h for _FILE_OFFSET_BITS set and _LARGEFILE64_SOURCE not\n- Add comment in zlib.h that adler32_combine with len2 < 0 makes no sense\n- Make NO_DIVIDE option in adler32.c much faster (thanks to John Reiser)\n- Make stronger test in zconf.h to include unistd.h for LFS\n- Apply Darwin patches for 64-bit file offsets to contrib/minizip [Slack]\n- Fix zlib.h LFS support when Z_PREFIX used\n- Add updated as400 support (removed from old) [Monnerat]\n- Avoid deflate sensitivity to volatile input data\n- Avoid division in adler32_combine for NO_DIVIDE\n- Clarify the use of Z_FINISH with deflateBound() amount of space\n- Set binary for output file in puff.c\n- Use u4 type for crc_table to avoid conversion warnings\n- Apply casts in zlib.h to avoid conversion warnings\n- Add OF to prototypes for adler32_combine_ and crc32_combine_ [Miller]\n- Improve inflateSync() documentation to note indeterminacy\n- Add deflatePending() function to return the amount of pending output\n- Correct the spelling of \"specification\" in FAQ [Randers-Pehrson]\n- Add a check in configure for stdarg.h, use for gzprintf()\n- Check that pointers fit in ints when gzprint() compiled old style\n- Add dummy name before $(SHAREDLIBV) in Makefile [Bar-Lev, Bowler]\n- Delete line in configure that adds -L. libz.a to LDFLAGS [Weigelt]\n- Add debug records in assembler code [Londer]\n- Update RFC references to use http://tools.ietf.org/html/... [Li]\n- Add --archs option, use of libtool to configure for Mac OS X [Borstel]\n\nChanges in 1.2.5 (19 Apr 2010)\n- Disable visibility attribute in win32/Makefile.gcc [Bar-Lev]\n- Default to libdir as sharedlibdir in configure [Nieder]\n- Update copyright dates on modified source files\n- Update trees.c to be able to generate modified trees.h\n- Exit configure for MinGW, suggesting win32/Makefile.gcc\n- Check for NULL path in gz_open [Homurlu]\n\nChanges in 1.2.4.5 (18 Apr 2010)\n- Set sharedlibdir in configure [Torok]\n- Set LDFLAGS in Makefile.in [Bar-Lev]\n- Avoid mkdir objs race condition in Makefile.in [Bowler]\n- Add ZLIB_INTERNAL in front of internal inter-module functions and arrays\n- Define ZLIB_INTERNAL to hide internal functions and arrays for GNU C\n- Don't use hidden attribute when it is a warning generator (e.g. Solaris)\n\nChanges in 1.2.4.4 (18 Apr 2010)\n- Fix CROSS_PREFIX executable testing, CHOST extract, mingw* [Torok]\n- Undefine _LARGEFILE64_SOURCE in zconf.h if it is zero, but not if empty\n- Try to use bash or ksh regardless of functionality of /bin/sh\n- Fix configure incompatibility with NetBSD sh\n- Remove attempt to run under bash or ksh since have better NetBSD fix\n- Fix win32/Makefile.gcc for MinGW [Bar-Lev]\n- Add diagnostic messages when using CROSS_PREFIX in configure\n- Added --sharedlibdir option to configure [Weigelt]\n- Use hidden visibility attribute when available [Frysinger]\n\nChanges in 1.2.4.3 (10 Apr 2010)\n- Only use CROSS_PREFIX in configure for ar and ranlib if they exist\n- Use CROSS_PREFIX for nm [Bar-Lev]\n- Assume _LARGEFILE64_SOURCE defined is equivalent to true\n- Avoid use of undefined symbols in #if with && and ||\n- Make *64 prototypes in gzguts.h consistent with functions\n- Add -shared load option for MinGW in configure [Bowler]\n- Move z_off64_t to public interface, use instead of off64_t\n- Remove ! from shell test in configure (not portable to Solaris)\n- Change +0 macro tests to -0 for possibly increased portability\n\nChanges in 1.2.4.2 (9 Apr 2010)\n- Add consistent carriage returns to readme.txt's in masmx86 and masmx64\n- Really provide prototypes for *64 functions when building without LFS\n- Only define unlink() in minigzip.c if unistd.h not included\n- Update README to point to contrib/vstudio project files\n- Move projects/vc6 to old/ and remove projects/\n- Include stdlib.h in minigzip.c for setmode() definition under WinCE\n- Clean up assembler builds in win32/Makefile.msc [Rowe]\n- Include sys/types.h for Microsoft for off_t definition\n- Fix memory leak on error in gz_open()\n- Symbolize nm as $NM in configure [Weigelt]\n- Use TEST_LDSHARED instead of LDSHARED to link test programs [Weigelt]\n- Add +0 to _FILE_OFFSET_BITS and _LFS64_LARGEFILE in case not defined\n- Fix bug in gzeof() to take into account unused input data\n- Avoid initialization of structures with variables in puff.c\n- Updated win32/README-WIN32.txt [Rowe]\n\nChanges in 1.2.4.1 (28 Mar 2010)\n- Remove the use of [a-z] constructs for sed in configure [gentoo 310225]\n- Remove $(SHAREDLIB) from LIBS in Makefile.in [Creech]\n- Restore \"for debugging\" comment on sprintf() in gzlib.c\n- Remove fdopen for MVS from gzguts.h\n- Put new README-WIN32.txt in win32 [Rowe]\n- Add check for shell to configure and invoke another shell if needed\n- Fix big fat stinking bug in gzseek() on uncompressed files\n- Remove vestigial F_OPEN64 define in zutil.h\n- Set and check the value of _LARGEFILE_SOURCE and _LARGEFILE64_SOURCE\n- Avoid errors on non-LFS systems when applications define LFS macros\n- Set EXE to \".exe\" in configure for MINGW [Kahle]\n- Match crc32() in crc32.c exactly to the prototype in zlib.h [Sherrill]\n- Add prefix for cross-compilation in win32/makefile.gcc [Bar-Lev]\n- Add DLL install in win32/makefile.gcc [Bar-Lev]\n- Allow Linux* or linux* from uname in configure [Bar-Lev]\n- Allow ldconfig to be redefined in configure and Makefile.in [Bar-Lev]\n- Add cross-compilation prefixes to configure [Bar-Lev]\n- Match type exactly in gz_load() invocation in gzread.c\n- Match type exactly of zcalloc() in zutil.c to zlib.h alloc_func\n- Provide prototypes for *64 functions when building zlib without LFS\n- Don't use -lc when linking shared library on MinGW\n- Remove errno.h check in configure and vestigial errno code in zutil.h\n\nChanges in 1.2.4 (14 Mar 2010)\n- Fix VER3 extraction in configure for no fourth subversion\n- Update zlib.3, add docs to Makefile.in to make .pdf out of it\n- Add zlib.3.pdf to distribution\n- Don't set error code in gzerror() if passed pointer is NULL\n- Apply destination directory fixes to CMakeLists.txt [Lowman]\n- Move #cmakedefine's to a new zconf.in.cmakein\n- Restore zconf.h for builds that don't use configure or cmake\n- Add distclean to dummy Makefile for convenience\n- Update and improve INDEX, README, and FAQ\n- Update CMakeLists.txt for the return of zconf.h [Lowman]\n- Update contrib/vstudio/vc9 and vc10 [Vollant]\n- Change libz.dll.a back to libzdll.a in win32/Makefile.gcc\n- Apply license and readme changes to contrib/asm686 [Raiter]\n- Check file name lengths and add -c option in minigzip.c [Li]\n- Update contrib/amd64 and contrib/masmx86/ [Vollant]\n- Avoid use of \"eof\" parameter in trees.c to not shadow library variable\n- Update make_vms.com for removal of zlibdefs.h [Zinser]\n- Update assembler code and vstudio projects in contrib [Vollant]\n- Remove outdated assembler code contrib/masm686 and contrib/asm586\n- Remove old vc7 and vc8 from contrib/vstudio\n- Update win32/Makefile.msc, add ZLIB_VER_SUBREVISION [Rowe]\n- Fix memory leaks in gzclose_r() and gzclose_w(), file leak in gz_open()\n- Add contrib/gcc_gvmat64 for longest_match and inflate_fast [Vollant]\n- Remove *64 functions from win32/zlib.def (they're not 64-bit yet)\n- Fix bug in void-returning vsprintf() case in gzwrite.c\n- Fix name change from inflate.h in contrib/inflate86/inffas86.c\n- Check if temporary file exists before removing in make_vms.com [Zinser]\n- Fix make install and uninstall for --static option\n- Fix usage of _MSC_VER in gzguts.h and zutil.h [Truta]\n- Update readme.txt in contrib/masmx64 and masmx86 to assemble\n\nChanges in 1.2.3.9 (21 Feb 2010)\n- Expunge gzio.c\n- Move as400 build information to old\n- Fix updates in contrib/minizip and contrib/vstudio\n- Add const to vsnprintf test in configure to avoid warnings [Weigelt]\n- Delete zconf.h (made by configure) [Weigelt]\n- Change zconf.in.h to zconf.h.in per convention [Weigelt]\n- Check for NULL buf in gzgets()\n- Return empty string for gzgets() with len == 1 (like fgets())\n- Fix description of gzgets() in zlib.h for end-of-file, NULL return\n- Update minizip to 1.1 [Vollant]\n- Avoid MSVC loss of data warnings in gzread.c, gzwrite.c\n- Note in zlib.h that gzerror() should be used to distinguish from EOF\n- Remove use of snprintf() from gzlib.c\n- Fix bug in gzseek()\n- Update contrib/vstudio, adding vc9 and vc10 [Kuno, Vollant]\n- Fix zconf.h generation in CMakeLists.txt [Lowman]\n- Improve comments in zconf.h where modified by configure\n\nChanges in 1.2.3.8 (13 Feb 2010)\n- Clean up text files (tabs, trailing whitespace, etc.) [Oberhumer]\n- Use z_off64_t in gz_zero() and gz_skip() to match state->skip\n- Avoid comparison problem when sizeof(int) == sizeof(z_off64_t)\n- Revert to Makefile.in from 1.2.3.6 (live with the clutter)\n- Fix missing error return in gzflush(), add zlib.h note\n- Add *64 functions to zlib.map [Levin]\n- Fix signed/unsigned comparison in gz_comp()\n- Use SFLAGS when testing shared linking in configure\n- Add --64 option to ./configure to use -m64 with gcc\n- Fix ./configure --help to correctly name options\n- Have make fail if a test fails [Levin]\n- Avoid buffer overrun in contrib/masmx64/gvmat64.asm [Simpson]\n- Remove assembler object files from contrib\n\nChanges in 1.2.3.7 (24 Jan 2010)\n- Always gzopen() with O_LARGEFILE if available\n- Fix gzdirect() to work immediately after gzopen() or gzdopen()\n- Make gzdirect() more precise when the state changes while reading\n- Improve zlib.h documentation in many places\n- Catch memory allocation failure in gz_open()\n- Complete close operation if seek forward in gzclose_w() fails\n- Return Z_ERRNO from gzclose_r() if close() fails\n- Return Z_STREAM_ERROR instead of EOF for gzclose() being passed NULL\n- Return zero for gzwrite() errors to match zlib.h description\n- Return -1 on gzputs() error to match zlib.h description\n- Add zconf.in.h to allow recovery from configure modification [Weigelt]\n- Fix static library permissions in Makefile.in [Weigelt]\n- Avoid warnings in configure tests that hide functionality [Weigelt]\n- Add *BSD and DragonFly to Linux case in configure [gentoo 123571]\n- Change libzdll.a to libz.dll.a in win32/Makefile.gcc [gentoo 288212]\n- Avoid access of uninitialized data for first inflateReset2 call [Gomes]\n- Keep object files in subdirectories to reduce the clutter somewhat\n- Remove default Makefile and zlibdefs.h, add dummy Makefile\n- Add new external functions to Z_PREFIX, remove duplicates, z_z_ -> z_\n- Remove zlibdefs.h completely -- modify zconf.h instead\n\nChanges in 1.2.3.6 (17 Jan 2010)\n- Avoid void * arithmetic in gzread.c and gzwrite.c\n- Make compilers happier with const char * for gz_error message\n- Avoid unused parameter warning in inflate.c\n- Avoid signed-unsigned comparison warning in inflate.c\n- Indent #pragma's for traditional C\n- Fix usage of strwinerror() in glib.c, change to gz_strwinerror()\n- Correct email address in configure for system options\n- Update make_vms.com and add make_vms.com to contrib/minizip [Zinser]\n- Update zlib.map [Brown]\n- Fix Makefile.in for Solaris 10 make of example64 and minizip64 [Torok]\n- Apply various fixes to CMakeLists.txt [Lowman]\n- Add checks on len in gzread() and gzwrite()\n- Add error message for no more room for gzungetc()\n- Remove zlib version check in gzwrite()\n- Defer compression of gzprintf() result until need to\n- Use snprintf() in gzdopen() if available\n- Remove USE_MMAP configuration determination (only used by minigzip)\n- Remove examples/pigz.c (available separately)\n- Update examples/gun.c to 1.6\n\nChanges in 1.2.3.5 (8 Jan 2010)\n- Add space after #if in zutil.h for some compilers\n- Fix relatively harmless bug in deflate_fast() [Exarevsky]\n- Fix same problem in deflate_slow()\n- Add $(SHAREDLIBV) to LIBS in Makefile.in [Brown]\n- Add deflate_rle() for faster Z_RLE strategy run-length encoding\n- Add deflate_huff() for faster Z_HUFFMAN_ONLY encoding\n- Change name of \"write\" variable in inffast.c to avoid library collisions\n- Fix premature EOF from gzread() in gzio.c [Brown]\n- Use zlib header window size if windowBits is 0 in inflateInit2()\n- Remove compressBound() call in deflate.c to avoid linking compress.o\n- Replace use of errno in gz* with functions, support WinCE [Alves]\n- Provide alternative to perror() in minigzip.c for WinCE [Alves]\n- Don't use _vsnprintf on later versions of MSVC [Lowman]\n- Add CMake build script and input file [Lowman]\n- Update contrib/minizip to 1.1 [Svensson, Vollant]\n- Moved nintendods directory from contrib to root\n- Replace gzio.c with a new set of routines with the same functionality\n- Add gzbuffer(), gzoffset(), gzclose_r(), gzclose_w() as part of above\n- Update contrib/minizip to 1.1b\n- Change gzeof() to return 0 on error instead of -1 to agree with zlib.h\n\nChanges in 1.2.3.4 (21 Dec 2009)\n- Use old school .SUFFIXES in Makefile.in for FreeBSD compatibility\n- Update comments in configure and Makefile.in for default --shared\n- Fix test -z's in configure [Marquess]\n- Build examplesh and minigzipsh when not testing\n- Change NULL's to Z_NULL's in deflate.c and in comments in zlib.h\n- Import LDFLAGS from the environment in configure\n- Fix configure to populate SFLAGS with discovered CFLAGS options\n- Adapt make_vms.com to the new Makefile.in [Zinser]\n- Add zlib2ansi script for C++ compilation [Marquess]\n- Add _FILE_OFFSET_BITS=64 test to make test (when applicable)\n- Add AMD64 assembler code for longest match to contrib [Teterin]\n- Include options from $SFLAGS when doing $LDSHARED\n- Simplify 64-bit file support by introducing z_off64_t type\n- Make shared object files in objs directory to work around old Sun cc\n- Use only three-part version number for Darwin shared compiles\n- Add rc option to ar in Makefile.in for when ./configure not run\n- Add -WI,-rpath,. to LDFLAGS for OSF 1 V4*\n- Set LD_LIBRARYN32_PATH for SGI IRIX shared compile\n- Protect against _FILE_OFFSET_BITS being defined when compiling zlib\n- Rename Makefile.in targets allstatic to static and allshared to shared\n- Fix static and shared Makefile.in targets to be independent\n- Correct error return bug in gz_open() by setting state [Brown]\n- Put spaces before ;;'s in configure for better sh compatibility\n- Add pigz.c (parallel implementation of gzip) to examples/\n- Correct constant in crc32.c to UL [Leventhal]\n- Reject negative lengths in crc32_combine()\n- Add inflateReset2() function to work like inflateEnd()/inflateInit2()\n- Include sys/types.h for _LARGEFILE64_SOURCE [Brown]\n- Correct typo in doc/algorithm.txt [Janik]\n- Fix bug in adler32_combine() [Zhu]\n- Catch missing-end-of-block-code error in all inflates and in puff\n    Assures that random input to inflate eventually results in an error\n- Added enough.c (calculation of ENOUGH for inftrees.h) to examples/\n- Update ENOUGH and its usage to reflect discovered bounds\n- Fix gzerror() error report on empty input file [Brown]\n- Add ush casts in trees.c to avoid pedantic runtime errors\n- Fix typo in zlib.h uncompress() description [Reiss]\n- Correct inflate() comments with regard to automatic header detection\n- Remove deprecation comment on Z_PARTIAL_FLUSH (it stays)\n- Put new version of gzlog (2.0) in examples with interruption recovery\n- Add puff compile option to permit invalid distance-too-far streams\n- Add puff TEST command options, ability to read piped input\n- Prototype the *64 functions in zlib.h when _FILE_OFFSET_BITS == 64, but\n  _LARGEFILE64_SOURCE not defined\n- Fix Z_FULL_FLUSH to truly erase the past by resetting s->strstart\n- Fix deflateSetDictionary() to use all 32K for output consistency\n- Remove extraneous #define MIN_LOOKAHEAD in deflate.c (in deflate.h)\n- Clear bytes after deflate lookahead to avoid use of uninitialized data\n- Change a limit in inftrees.c to be more transparent to Coverity Prevent\n- Update win32/zlib.def with exported symbols from zlib.h\n- Correct spelling errors in zlib.h [Willem, Sobrado]\n- Allow Z_BLOCK for deflate() to force a new block\n- Allow negative bits in inflatePrime() to delete existing bit buffer\n- Add Z_TREES flush option to inflate() to return at end of trees\n- Add inflateMark() to return current state information for random access\n- Add Makefile for NintendoDS to contrib [Costa]\n- Add -w in configure compile tests to avoid spurious warnings [Beucler]\n- Fix typos in zlib.h comments for deflateSetDictionary()\n- Fix EOF detection in transparent gzread() [Maier]\n\nChanges in 1.2.3.3 (2 October 2006)\n- Make --shared the default for configure, add a --static option\n- Add compile option to permit invalid distance-too-far streams\n- Add inflateUndermine() function which is required to enable above\n- Remove use of \"this\" variable name for C++ compatibility [Marquess]\n- Add testing of shared library in make test, if shared library built\n- Use ftello() and fseeko() if available instead of ftell() and fseek()\n- Provide two versions of all functions that use the z_off_t type for\n  binary compatibility -- a normal version and a 64-bit offset version,\n  per the Large File Support Extension when _LARGEFILE64_SOURCE is\n  defined; use the 64-bit versions by default when _FILE_OFFSET_BITS\n  is defined to be 64\n- Add a --uname= option to configure to perhaps help with cross-compiling\n\nChanges in 1.2.3.2 (3 September 2006)\n- Turn off silly Borland warnings [Hay]\n- Use off64_t and define _LARGEFILE64_SOURCE when present\n- Fix missing dependency on inffixed.h in Makefile.in\n- Rig configure --shared to build both shared and static [Teredesai, Truta]\n- Remove zconf.in.h and instead create a new zlibdefs.h file\n- Fix contrib/minizip/unzip.c non-encrypted after encrypted [Vollant]\n- Add treebuild.xml (see http://treebuild.metux.de/) [Weigelt]\n\nChanges in 1.2.3.1 (16 August 2006)\n- Add watcom directory with OpenWatcom make files [Daniel]\n- Remove #undef of FAR in zconf.in.h for MVS [Fedtke]\n- Update make_vms.com [Zinser]\n- Use -fPIC for shared build in configure [Teredesai, Nicholson]\n- Use only major version number for libz.so on IRIX and OSF1 [Reinholdtsen]\n- Use fdopen() (not _fdopen()) for Interix in zutil.h [Bäck]\n- Add some FAQ entries about the contrib directory\n- Update the MVS question in the FAQ\n- Avoid extraneous reads after EOF in gzio.c [Brown]\n- Correct spelling of \"successfully\" in gzio.c [Randers-Pehrson]\n- Add comments to zlib.h about gzerror() usage [Brown]\n- Set extra flags in gzip header in gzopen() like deflate() does\n- Make configure options more compatible with double-dash conventions\n  [Weigelt]\n- Clean up compilation under Solaris SunStudio cc [Rowe, Reinholdtsen]\n- Fix uninstall target in Makefile.in [Truta]\n- Add pkgconfig support [Weigelt]\n- Use $(DESTDIR) macro in Makefile.in [Reinholdtsen, Weigelt]\n- Replace set_data_type() with a more accurate detect_data_type() in\n  trees.c, according to the txtvsbin.txt document [Truta]\n- Swap the order of #include <stdio.h> and #include \"zlib.h\" in\n  gzio.c, example.c and minigzip.c [Truta]\n- Shut up annoying VS2005 warnings about standard C deprecation [Rowe,\n  Truta] (where?)\n- Fix target \"clean\" from win32/Makefile.bor [Truta]\n- Create .pdb and .manifest files in win32/makefile.msc [Ziegler, Rowe]\n- Update zlib www home address in win32/DLL_FAQ.txt [Truta]\n- Update contrib/masmx86/inffas32.asm for VS2005 [Vollant, Van Wassenhove]\n- Enable browse info in the \"Debug\" and \"ASM Debug\" configurations in\n  the Visual C++ 6 project, and set (non-ASM) \"Debug\" as default [Truta]\n- Add pkgconfig support [Weigelt]\n- Add ZLIB_VER_MAJOR, ZLIB_VER_MINOR and ZLIB_VER_REVISION in zlib.h,\n  for use in win32/zlib1.rc [Polushin, Rowe, Truta]\n- Add a document that explains the new text detection scheme to\n  doc/txtvsbin.txt [Truta]\n- Add rfc1950.txt, rfc1951.txt and rfc1952.txt to doc/ [Truta]\n- Move algorithm.txt into doc/ [Truta]\n- Synchronize FAQ with website\n- Fix compressBound(), was low for some pathological cases [Fearnley]\n- Take into account wrapper variations in deflateBound()\n- Set examples/zpipe.c input and output to binary mode for Windows\n- Update examples/zlib_how.html with new zpipe.c (also web site)\n- Fix some warnings in examples/gzlog.c and examples/zran.c (it seems\n  that gcc became pickier in 4.0)\n- Add zlib.map for Linux: \"All symbols from zlib-1.1.4 remain\n  un-versioned, the patch adds versioning only for symbols introduced in\n  zlib-1.2.0 or later.  It also declares as local those symbols which are\n  not designed to be exported.\" [Levin]\n- Update Z_PREFIX list in zconf.in.h, add --zprefix option to configure\n- Do not initialize global static by default in trees.c, add a response\n  NO_INIT_GLOBAL_POINTERS to initialize them if needed [Marquess]\n- Don't use strerror() in gzio.c under WinCE [Yakimov]\n- Don't use errno.h in zutil.h under WinCE [Yakimov]\n- Move arguments for AR to its usage to allow replacing ar [Marot]\n- Add HAVE_VISIBILITY_PRAGMA in zconf.in.h for Mozilla [Randers-Pehrson]\n- Improve inflateInit() and inflateInit2() documentation\n- Fix structure size comment in inflate.h\n- Change configure help option from --h* to --help [Santos]\n\nChanges in 1.2.3 (18 July 2005)\n- Apply security vulnerability fixes to contrib/infback9 as well\n- Clean up some text files (carriage returns, trailing space)\n- Update testzlib, vstudio, masmx64, and masmx86 in contrib [Vollant]\n\nChanges in 1.2.2.4 (11 July 2005)\n- Add inflatePrime() function for starting inflation at bit boundary\n- Avoid some Visual C warnings in deflate.c\n- Avoid more silly Visual C warnings in inflate.c and inftrees.c for 64-bit\n  compile\n- Fix some spelling errors in comments [Betts]\n- Correct inflateInit2() error return documentation in zlib.h\n- Add zran.c example of compressed data random access to examples\n  directory, shows use of inflatePrime()\n- Fix cast for assignments to strm->state in inflate.c and infback.c\n- Fix zlibCompileFlags() in zutil.c to use 1L for long shifts [Oberhumer]\n- Move declarations of gf2 functions to right place in crc32.c [Oberhumer]\n- Add cast in trees.c t avoid a warning [Oberhumer]\n- Avoid some warnings in fitblk.c, gun.c, gzjoin.c in examples [Oberhumer]\n- Update make_vms.com [Zinser]\n- Initialize state->write in inflateReset() since copied in inflate_fast()\n- Be more strict on incomplete code sets in inflate_table() and increase\n  ENOUGH and MAXD -- this repairs a possible security vulnerability for\n  invalid inflate input.  Thanks to Tavis Ormandy and Markus Oberhumer for\n  discovering the vulnerability and providing test cases\n- Add ia64 support to configure for HP-UX [Smith]\n- Add error return to gzread() for format or i/o error [Levin]\n- Use malloc.h for OS/2 [Necasek]\n\nChanges in 1.2.2.3 (27 May 2005)\n- Replace 1U constants in inflate.c and inftrees.c for 64-bit compile\n- Typecast fread() return values in gzio.c [Vollant]\n- Remove trailing space in minigzip.c outmode (VC++ can't deal with it)\n- Fix crc check bug in gzread() after gzungetc() [Heiner]\n- Add the deflateTune() function to adjust internal compression parameters\n- Add a fast gzip decompressor, gun.c, to examples (use of inflateBack)\n- Remove an incorrect assertion in examples/zpipe.c\n- Add C++ wrapper in infback9.h [Donais]\n- Fix bug in inflateCopy() when decoding fixed codes\n- Note in zlib.h how much deflateSetDictionary() actually uses\n- Remove USE_DICT_HEAD in deflate.c (would mess up inflate if used)\n- Add _WIN32_WCE to define WIN32 in zconf.in.h [Spencer]\n- Don't include stderr.h or errno.h for _WIN32_WCE in zutil.h [Spencer]\n- Add gzdirect() function to indicate transparent reads\n- Update contrib/minizip [Vollant]\n- Fix compilation of deflate.c when both ASMV and FASTEST [Oberhumer]\n- Add casts in crc32.c to avoid warnings [Oberhumer]\n- Add contrib/masmx64 [Vollant]\n- Update contrib/asm586, asm686, masmx86, testzlib, vstudio [Vollant]\n\nChanges in 1.2.2.2 (30 December 2004)\n- Replace structure assignments in deflate.c and inflate.c with zmemcpy to\n  avoid implicit memcpy calls (portability for no-library compilation)\n- Increase sprintf() buffer size in gzdopen() to allow for large numbers\n- Add INFLATE_STRICT to check distances against zlib header\n- Improve WinCE errno handling and comments [Chang]\n- Remove comment about no gzip header processing in FAQ\n- Add Z_FIXED strategy option to deflateInit2() to force fixed trees\n- Add updated make_vms.com [Coghlan], update README\n- Create a new \"examples\" directory, move gzappend.c there, add zpipe.c,\n  fitblk.c, gzlog.[ch], gzjoin.c, and zlib_how.html\n- Add FAQ entry and comments in deflate.c on uninitialized memory access\n- Add Solaris 9 make options in configure [Gilbert]\n- Allow strerror() usage in gzio.c for STDC\n- Fix DecompressBuf in contrib/delphi/ZLib.pas [ManChesTer]\n- Update contrib/masmx86/inffas32.asm and gvmat32.asm [Vollant]\n- Use z_off_t for adler32_combine() and crc32_combine() lengths\n- Make adler32() much faster for small len\n- Use OS_CODE in deflate() default gzip header\n\nChanges in 1.2.2.1 (31 October 2004)\n- Allow inflateSetDictionary() call for raw inflate\n- Fix inflate header crc check bug for file names and comments\n- Add deflateSetHeader() and gz_header structure for custom gzip headers\n- Add inflateGetheader() to retrieve gzip headers\n- Add crc32_combine() and adler32_combine() functions\n- Add alloc_func, free_func, in_func, out_func to Z_PREFIX list\n- Use zstreamp consistently in zlib.h (inflate_back functions)\n- Remove GUNZIP condition from definition of inflate_mode in inflate.h\n  and in contrib/inflate86/inffast.S [Truta, Anderson]\n- Add support for AMD64 in contrib/inflate86/inffas86.c [Anderson]\n- Update projects/README.projects and projects/visualc6 [Truta]\n- Update win32/DLL_FAQ.txt [Truta]\n- Avoid warning under NO_GZCOMPRESS in gzio.c; fix typo [Truta]\n- Deprecate Z_ASCII; use Z_TEXT instead [Truta]\n- Use a new algorithm for setting strm->data_type in trees.c [Truta]\n- Do not define an exit() prototype in zutil.c unless DEBUG defined\n- Remove prototype of exit() from zutil.c, example.c, minigzip.c [Truta]\n- Add comment in zlib.h for Z_NO_FLUSH parameter to deflate()\n- Fix Darwin build version identification [Peterson]\n\nChanges in 1.2.2 (3 October 2004)\n- Update zlib.h comments on gzip in-memory processing\n- Set adler to 1 in inflateReset() to support Java test suite [Walles]\n- Add contrib/dotzlib [Ravn]\n- Update win32/DLL_FAQ.txt [Truta]\n- Update contrib/minizip [Vollant]\n- Move contrib/visual-basic.txt to old/ [Truta]\n- Fix assembler builds in projects/visualc6/ [Truta]\n\nChanges in 1.2.1.2 (9 September 2004)\n- Update INDEX file\n- Fix trees.c to update strm->data_type (no one ever noticed!)\n- Fix bug in error case in inflate.c, infback.c, and infback9.c [Brown]\n- Add \"volatile\" to crc table flag declaration (for DYNAMIC_CRC_TABLE)\n- Add limited multitasking protection to DYNAMIC_CRC_TABLE\n- Add NO_vsnprintf for VMS in zutil.h [Mozilla]\n- Don't declare strerror() under VMS [Mozilla]\n- Add comment to DYNAMIC_CRC_TABLE to use get_crc_table() to initialize\n- Update contrib/ada [Anisimkov]\n- Update contrib/minizip [Vollant]\n- Fix configure to not hardcode directories for Darwin [Peterson]\n- Fix gzio.c to not return error on empty files [Brown]\n- Fix indentation; update version in contrib/delphi/ZLib.pas and\n  contrib/pascal/zlibpas.pas [Truta]\n- Update mkasm.bat in contrib/masmx86 [Truta]\n- Update contrib/untgz [Truta]\n- Add projects/README.projects [Truta]\n- Add project for MS Visual C++ 6.0 in projects/visualc6 [Cadieux, Truta]\n- Update win32/DLL_FAQ.txt [Truta]\n- Update list of Z_PREFIX symbols in zconf.h [Randers-Pehrson, Truta]\n- Remove an unnecessary assignment to curr in inftrees.c [Truta]\n- Add OS/2 to exe builds in configure [Poltorak]\n- Remove err dummy parameter in zlib.h [Kientzle]\n\nChanges in 1.2.1.1 (9 January 2004)\n- Update email address in README\n- Several FAQ updates\n- Fix a big fat bug in inftrees.c that prevented decoding valid\n  dynamic blocks with only literals and no distance codes --\n  Thanks to \"Hot Emu\" for the bug report and sample file\n- Add a note to puff.c on no distance codes case\n\nChanges in 1.2.1 (17 November 2003)\n- Remove a tab in contrib/gzappend/gzappend.c\n- Update some interfaces in contrib for new zlib functions\n- Update zlib version number in some contrib entries\n- Add Windows CE definition for ptrdiff_t in zutil.h [Mai, Truta]\n- Support shared libraries on Hurd and KFreeBSD [Brown]\n- Fix error in NO_DIVIDE option of adler32.c\n\nChanges in 1.2.0.8 (4 November 2003)\n- Update version in contrib/delphi/ZLib.pas and contrib/pascal/zlibpas.pas\n- Add experimental NO_DIVIDE #define in adler32.c\n    - Possibly faster on some processors (let me know if it is)\n- Correct Z_BLOCK to not return on first inflate call if no wrap\n- Fix strm->data_type on inflate() return to correctly indicate EOB\n- Add deflatePrime() function for appending in the middle of a byte\n- Add contrib/gzappend for an example of appending to a stream\n- Update win32/DLL_FAQ.txt [Truta]\n- Delete Turbo C comment in README [Truta]\n- Improve some indentation in zconf.h [Truta]\n- Fix infinite loop on bad input in configure script [Church]\n- Fix gzeof() for concatenated gzip files [Johnson]\n- Add example to contrib/visual-basic.txt [Michael B.]\n- Add -p to mkdir's in Makefile.in [vda]\n- Fix configure to properly detect presence or lack of printf functions\n- Add AS400 support [Monnerat]\n- Add a little Cygwin support [Wilson]\n\nChanges in 1.2.0.7 (21 September 2003)\n- Correct some debug formats in contrib/infback9\n- Cast a type in a debug statement in trees.c\n- Change search and replace delimiter in configure from % to # [Beebe]\n- Update contrib/untgz to 0.2 with various fixes [Truta]\n- Add build support for Amiga [Nikl]\n- Remove some directories in old that have been updated to 1.2\n- Add dylib building for Mac OS X in configure and Makefile.in\n- Remove old distribution stuff from Makefile\n- Update README to point to DLL_FAQ.txt, and add comment on Mac OS X\n- Update links in README\n\nChanges in 1.2.0.6 (13 September 2003)\n- Minor FAQ updates\n- Update contrib/minizip to 1.00 [Vollant]\n- Remove test of gz functions in example.c when GZ_COMPRESS defined [Truta]\n- Update POSTINC comment for 68060 [Nikl]\n- Add contrib/infback9 with deflate64 decoding (unsupported)\n- For MVS define NO_vsnprintf and undefine FAR [van Burik]\n- Add pragma for fdopen on MVS [van Burik]\n\nChanges in 1.2.0.5 (8 September 2003)\n- Add OF to inflateBackEnd() declaration in zlib.h\n- Remember start when using gzdopen in the middle of a file\n- Use internal off_t counters in gz* functions to properly handle seeks\n- Perform more rigorous check for distance-too-far in inffast.c\n- Add Z_BLOCK flush option to return from inflate at block boundary\n- Set strm->data_type on return from inflate\n    - Indicate bits unused, if at block boundary, and if in last block\n- Replace size_t with ptrdiff_t in crc32.c, and check for correct size\n- Add condition so old NO_DEFLATE define still works for compatibility\n- FAQ update regarding the Windows DLL [Truta]\n- INDEX update: add qnx entry, remove aix entry [Truta]\n- Install zlib.3 into mandir [Wilson]\n- Move contrib/zlib_dll_FAQ.txt to win32/DLL_FAQ.txt; update [Truta]\n- Adapt the zlib interface to the new DLL convention guidelines [Truta]\n- Introduce ZLIB_WINAPI macro to allow the export of functions using\n  the WINAPI calling convention, for Visual Basic [Vollant, Truta]\n- Update msdos and win32 scripts and makefiles [Truta]\n- Export symbols by name, not by ordinal, in win32/zlib.def [Truta]\n- Add contrib/ada [Anisimkov]\n- Move asm files from contrib/vstudio/vc70_32 to contrib/asm386 [Truta]\n- Rename contrib/asm386 to contrib/masmx86 [Truta, Vollant]\n- Add contrib/masm686 [Truta]\n- Fix offsets in contrib/inflate86 and contrib/masmx86/inffas32.asm\n  [Truta, Vollant]\n- Update contrib/delphi; rename to contrib/pascal; add example [Truta]\n- Remove contrib/delphi2; add a new contrib/delphi [Truta]\n- Avoid inclusion of the nonstandard <memory.h> in contrib/iostream,\n  and fix some method prototypes [Truta]\n- Fix the ZCR_SEED2 constant to avoid warnings in contrib/minizip\n  [Truta]\n- Avoid the use of backslash (\\) in contrib/minizip [Vollant]\n- Fix file time handling in contrib/untgz; update makefiles [Truta]\n- Update contrib/vstudio/vc70_32 to comply with the new DLL guidelines\n  [Vollant]\n- Remove contrib/vstudio/vc15_16 [Vollant]\n- Rename contrib/vstudio/vc70_32 to contrib/vstudio/vc7 [Truta]\n- Update README.contrib [Truta]\n- Invert the assignment order of match_head and s->prev[...] in\n  INSERT_STRING [Truta]\n- Compare TOO_FAR with 32767 instead of 32768, to avoid 16-bit warnings\n  [Truta]\n- Compare function pointers with 0, not with NULL or Z_NULL [Truta]\n- Fix prototype of syncsearch in inflate.c [Truta]\n- Introduce ASMINF macro to be enabled when using an ASM implementation\n  of inflate_fast [Truta]\n- Change NO_DEFLATE to NO_GZCOMPRESS [Truta]\n- Modify test_gzio in example.c to take a single file name as a\n  parameter [Truta]\n- Exit the example.c program if gzopen fails [Truta]\n- Add type casts around strlen in example.c [Truta]\n- Remove casting to sizeof in minigzip.c; give a proper type\n  to the variable compared with SUFFIX_LEN [Truta]\n- Update definitions of STDC and STDC99 in zconf.h [Truta]\n- Synchronize zconf.h with the new Windows DLL interface [Truta]\n- Use SYS16BIT instead of __32BIT__ to distinguish between\n  16- and 32-bit platforms [Truta]\n- Use far memory allocators in small 16-bit memory models for\n  Turbo C [Truta]\n- Add info about the use of ASMV, ASMINF and ZLIB_WINAPI in\n  zlibCompileFlags [Truta]\n- Cygwin has vsnprintf [Wilson]\n- In Windows16, OS_CODE is 0, as in MSDOS [Truta]\n- In Cygwin, OS_CODE is 3 (Unix), not 11 (Windows32) [Wilson]\n\nChanges in 1.2.0.4 (10 August 2003)\n- Minor FAQ updates\n- Be more strict when checking inflateInit2's windowBits parameter\n- Change NO_GUNZIP compile option to NO_GZIP to cover deflate as well\n- Add gzip wrapper option to deflateInit2 using windowBits\n- Add updated QNX rule in configure and qnx directory [Bonnefoy]\n- Make inflate distance-too-far checks more rigorous\n- Clean up FAR usage in inflate\n- Add casting to sizeof() in gzio.c and minigzip.c\n\nChanges in 1.2.0.3 (19 July 2003)\n- Fix silly error in gzungetc() implementation [Vollant]\n- Update contrib/minizip and contrib/vstudio [Vollant]\n- Fix printf format in example.c\n- Correct cdecl support in zconf.in.h [Anisimkov]\n- Minor FAQ updates\n\nChanges in 1.2.0.2 (13 July 2003)\n- Add ZLIB_VERNUM in zlib.h for numerical preprocessor comparisons\n- Attempt to avoid warnings in crc32.c for pointer-int conversion\n- Add AIX to configure, remove aix directory [Bakker]\n- Add some casts to minigzip.c\n- Improve checking after insecure sprintf() or vsprintf() calls\n- Remove #elif's from crc32.c\n- Change leave label to inf_leave in inflate.c and infback.c to avoid\n  library conflicts\n- Remove inflate gzip decoding by default--only enable gzip decoding by\n  special request for stricter backward compatibility\n- Add zlibCompileFlags() function to return compilation information\n- More typecasting in deflate.c to avoid warnings\n- Remove leading underscore from _Capital #defines [Truta]\n- Fix configure to link shared library when testing\n- Add some Windows CE target adjustments [Mai]\n- Remove #define ZLIB_DLL in zconf.h [Vollant]\n- Add zlib.3 [Rodgers]\n- Update RFC URL in deflate.c and algorithm.txt [Mai]\n- Add zlib_dll_FAQ.txt to contrib [Truta]\n- Add UL to some constants [Truta]\n- Update minizip and vstudio [Vollant]\n- Remove vestigial NEED_DUMMY_RETURN from zconf.in.h\n- Expand use of NO_DUMMY_DECL to avoid all dummy structures\n- Added iostream3 to contrib [Schwardt]\n- Replace rewind() with fseek() for WinCE [Truta]\n- Improve setting of zlib format compression level flags\n    - Report 0 for huffman and rle strategies and for level == 0 or 1\n    - Report 2 only for level == 6\n- Only deal with 64K limit when necessary at compile time [Truta]\n- Allow TOO_FAR check to be turned off at compile time [Truta]\n- Add gzclearerr() function [Souza]\n- Add gzungetc() function\n\nChanges in 1.2.0.1 (17 March 2003)\n- Add Z_RLE strategy for run-length encoding [Truta]\n    - When Z_RLE requested, restrict matches to distance one\n    - Update zlib.h, minigzip.c, gzopen(), gzdopen() for Z_RLE\n- Correct FASTEST compilation to allow level == 0\n- Clean up what gets compiled for FASTEST\n- Incorporate changes to zconf.in.h [Vollant]\n    - Refine detection of Turbo C need for dummy returns\n    - Refine ZLIB_DLL compilation\n    - Include additional header file on VMS for off_t typedef\n- Try to use _vsnprintf where it supplants vsprintf [Vollant]\n- Add some casts in inffast.c\n- Enhance comments in zlib.h on what happens if gzprintf() tries to\n  write more than 4095 bytes before compression\n- Remove unused state from inflateBackEnd()\n- Remove exit(0) from minigzip.c, example.c\n- Get rid of all those darn tabs\n- Add \"check\" target to Makefile.in that does the same thing as \"test\"\n- Add \"mostlyclean\" and \"maintainer-clean\" targets to Makefile.in\n- Update contrib/inflate86 [Anderson]\n- Update contrib/testzlib, contrib/vstudio, contrib/minizip [Vollant]\n- Add msdos and win32 directories with makefiles [Truta]\n- More additions and improvements to the FAQ\n\nChanges in 1.2.0 (9 March 2003)\n- New and improved inflate code\n    - About 20% faster\n    - Does not allocate 32K window unless and until needed\n    - Automatically detects and decompresses gzip streams\n    - Raw inflate no longer needs an extra dummy byte at end\n    - Added inflateBack functions using a callback interface--even faster\n      than inflate, useful for file utilities (gzip, zip)\n    - Added inflateCopy() function to record state for random access on\n      externally generated deflate streams (e.g. in gzip files)\n    - More readable code (I hope)\n- New and improved crc32()\n    - About 50% faster, thanks to suggestions from Rodney Brown\n- Add deflateBound() and compressBound() functions\n- Fix memory leak in deflateInit2()\n- Permit setting dictionary for raw deflate (for parallel deflate)\n- Fix const declaration for gzwrite()\n- Check for some malloc() failures in gzio.c\n- Fix bug in gzopen() on single-byte file 0x1f\n- Fix bug in gzread() on concatenated file with 0x1f at end of buffer\n  and next buffer doesn't start with 0x8b\n- Fix uncompress() to return Z_DATA_ERROR on truncated input\n- Free memory at end of example.c\n- Remove MAX #define in trees.c (conflicted with some libraries)\n- Fix static const's in deflate.c, gzio.c, and zutil.[ch]\n- Declare malloc() and free() in gzio.c if STDC not defined\n- Use malloc() instead of calloc() in zutil.c if int big enough\n- Define STDC for AIX\n- Add aix/ with approach for compiling shared library on AIX\n- Add HP-UX support for shared libraries in configure\n- Add OpenUNIX support for shared libraries in configure\n- Use $cc instead of gcc to build shared library\n- Make prefix directory if needed when installing\n- Correct Macintosh avoidance of typedef Byte in zconf.h\n- Correct Turbo C memory allocation when under Linux\n- Use libz.a instead of -lz in Makefile (assure use of compiled library)\n- Update configure to check for snprintf or vsnprintf functions and their\n  return value, warn during make if using an insecure function\n- Fix configure problem with compile-time knowledge of HAVE_UNISTD_H that\n  is lost when library is used--resolution is to build new zconf.h\n- Documentation improvements (in zlib.h):\n    - Document raw deflate and inflate\n    - Update RFCs URL\n    - Point out that zlib and gzip formats are different\n    - Note that Z_BUF_ERROR is not fatal\n    - Document string limit for gzprintf() and possible buffer overflow\n    - Note requirement on avail_out when flushing\n    - Note permitted values of flush parameter of inflate()\n- Add some FAQs (and even answers) to the FAQ\n- Add contrib/inflate86/ for x86 faster inflate\n- Add contrib/blast/ for PKWare Data Compression Library decompression\n- Add contrib/puff/ simple inflate for deflate format description\n\nChanges in 1.1.4 (11 March 2002)\n- ZFREE was repeated on same allocation on some error conditions\n  This creates a security problem described in\n  http://www.zlib.org/advisory-2002-03-11.txt\n- Returned incorrect error (Z_MEM_ERROR) on some invalid data\n- Avoid accesses before window for invalid distances with inflate window\n  less than 32K\n- force windowBits > 8 to avoid a bug in the encoder for a window size\n  of 256 bytes. (A complete fix will be available in 1.1.5)\n\nChanges in 1.1.3 (9 July 1998)\n- fix \"an inflate input buffer bug that shows up on rare but persistent\n  occasions\" (Mark)\n- fix gzread and gztell for concatenated .gz files (Didier Le Botlan)\n- fix gzseek(..., SEEK_SET) in write mode\n- fix crc check after a gzeek (Frank Faubert)\n- fix miniunzip when the last entry in a zip file is itself a zip file\n  (J Lillge)\n- add contrib/asm586 and contrib/asm686 (Brian Raiter)\n  See http://www.muppetlabs.com/~breadbox/software/assembly.html\n- add support for Delphi 3 in contrib/delphi (Bob Dellaca)\n- add support for C++Builder 3 and Delphi 3 in contrib/delphi2 (Davide Moretti)\n- do not exit prematurely in untgz if 0 at start of block (Magnus Holmgren)\n- use macro EXTERN instead of extern to support DLL for BeOS (Sander Stoks)\n- added a FAQ file\n\n- Support gzdopen on Mac with Metrowerks (Jason Linhart)\n- Do not redefine Byte on Mac (Brad Pettit & Jason Linhart)\n- define SEEK_END too if SEEK_SET is not defined (Albert Chin-A-Young)\n- avoid some warnings with Borland C (Tom Tanner)\n- fix a problem in contrib/minizip/zip.c for 16-bit MSDOS (Gilles Vollant)\n- emulate utime() for WIN32 in contrib/untgz  (Gilles Vollant)\n- allow several arguments to configure (Tim Mooney, Frodo Looijaard)\n- use libdir and includedir in Makefile.in (Tim Mooney)\n- support shared libraries on OSF1 V4 (Tim Mooney)\n- remove so_locations in \"make clean\"  (Tim Mooney)\n- fix maketree.c compilation error (Glenn, Mark)\n- Python interface to zlib now in Python 1.5 (Jeremy Hylton)\n- new Makefile.riscos (Rich Walker)\n- initialize static descriptors in trees.c for embedded targets (Nick Smith)\n- use \"foo-gz\" in example.c for RISCOS and VMS (Nick Smith)\n- add the OS/2 files in Makefile.in too (Andrew Zabolotny)\n- fix fdopen and halloc macros for Microsoft C 6.0 (Tom Lane)\n- fix maketree.c to allow clean compilation of inffixed.h (Mark)\n- fix parameter check in deflateCopy (Gunther Nikl)\n- cleanup trees.c, use compressed_len only in debug mode (Christian Spieler)\n- Many portability patches by Christian Spieler:\n  . zutil.c, zutil.h: added \"const\" for zmem*\n  . Make_vms.com: fixed some typos\n  . Make_vms.com: msdos/Makefile.*: removed zutil.h from some dependency lists\n  . msdos/Makefile.msc: remove \"default rtl link library\" info from obj files\n  . msdos/Makefile.*: use model-dependent name for the built zlib library\n  . msdos/Makefile.emx, nt/Makefile.emx, nt/Makefile.gcc:\n     new makefiles, for emx (DOS/OS2), emx&rsxnt and mingw32 (Windows 9x / NT)\n- use define instead of typedef for Bytef also for MSC small/medium (Tom Lane)\n- replace __far with _far for better portability (Christian Spieler, Tom Lane)\n- fix test for errno.h in configure (Tim Newsham)\n\nChanges in 1.1.2 (19 March 98)\n- added contrib/minzip, mini zip and unzip based on zlib (Gilles Vollant)\n  See http://www.winimage.com/zLibDll/unzip.html\n- preinitialize the inflate tables for fixed codes, to make the code\n  completely thread safe (Mark)\n- some simplifications and slight speed-up to the inflate code (Mark)\n- fix gzeof on non-compressed files (Allan Schrum)\n- add -std1 option in configure for OSF1 to fix gzprintf (Martin Mokrejs)\n- use default value of 4K for Z_BUFSIZE for 16-bit MSDOS (Tim Wegner + Glenn)\n- added os2/Makefile.def and os2/zlib.def (Andrew Zabolotny)\n- add shared lib support for UNIX_SV4.2MP (MATSUURA Takanori)\n- do not wrap extern \"C\" around system includes (Tom Lane)\n- mention zlib binding for TCL in README (Andreas Kupries)\n- added amiga/Makefile.pup for Amiga powerUP SAS/C PPC (Andreas Kleinert)\n- allow \"make install prefix=...\" even after configure (Glenn Randers-Pehrson)\n- allow \"configure --prefix $HOME\" (Tim Mooney)\n- remove warnings in example.c and gzio.c (Glenn Randers-Pehrson)\n- move Makefile.sas to amiga/Makefile.sas\n\nChanges in 1.1.1 (27 Feb 98)\n- fix macros _tr_tally_* in deflate.h for debug mode  (Glenn Randers-Pehrson)\n- remove block truncation heuristic which had very marginal effect for zlib\n  (smaller lit_bufsize than in gzip 1.2.4) and degraded a little the\n  compression ratio on some files. This also allows inlining _tr_tally for\n  matches in deflate_slow\n- added msdos/Makefile.w32 for WIN32 Microsoft Visual C++ (Bob Frazier)\n\nChanges in 1.1.0 (24 Feb 98)\n- do not return STREAM_END prematurely in inflate (John Bowler)\n- revert to the zlib 1.0.8 inflate to avoid the gcc 2.8.0 bug (Jeremy Buhler)\n- compile with -DFASTEST to get compression code optimized for speed only\n- in minigzip, try mmap'ing the input file first (Miguel Albrecht)\n- increase size of I/O buffers in minigzip.c and gzio.c (not a big gain\n  on Sun but significant on HP)\n\n- add a pointer to experimental unzip library in README (Gilles Vollant)\n- initialize variable gcc in configure (Chris Herborth)\n\nChanges in 1.0.9 (17 Feb 1998)\n- added gzputs and gzgets functions\n- do not clear eof flag in gzseek (Mark Diekhans)\n- fix gzseek for files in transparent mode (Mark Diekhans)\n- do not assume that vsprintf returns the number of bytes written (Jens Krinke)\n- replace EXPORT with ZEXPORT to avoid conflict with other programs\n- added compress2 in zconf.h, zlib.def, zlib.dnt\n- new asm code from Gilles Vollant in contrib/asm386\n- simplify the inflate code (Mark):\n . Replace ZALLOC's in huft_build() with single ZALLOC in inflate_blocks_new()\n . ZALLOC the length list in inflate_trees_fixed() instead of using stack\n . ZALLOC the value area for huft_build() instead of using stack\n . Simplify Z_FINISH check in inflate()\n\n- Avoid gcc 2.8.0 comparison bug a little differently than zlib 1.0.8\n- in inftrees.c, avoid cc -O bug on HP (Farshid Elahi)\n- in zconf.h move the ZLIB_DLL stuff earlier to avoid problems with\n  the declaration of FAR (Gilles Vollant)\n- install libz.so* with mode 755 (executable) instead of 644 (Marc Lehmann)\n- read_buf buf parameter of type Bytef* instead of charf*\n- zmemcpy parameters are of type Bytef*, not charf* (Joseph Strout)\n- do not redeclare unlink in minigzip.c for WIN32 (John Bowler)\n- fix check for presence of directories in \"make install\" (Ian Willis)\n\nChanges in 1.0.8 (27 Jan 1998)\n- fixed offsets in contrib/asm386/gvmat32.asm (Gilles Vollant)\n- fix gzgetc and gzputc for big endian systems (Markus Oberhumer)\n- added compress2() to allow setting the compression level\n- include sys/types.h to get off_t on some systems (Marc Lehmann & QingLong)\n- use constant arrays for the static trees in trees.c instead of computing\n  them at run time (thanks to Ken Raeburn for this suggestion). To create\n  trees.h, compile with GEN_TREES_H and run \"make test\"\n- check return code of example in \"make test\" and display result\n- pass minigzip command line options to file_compress\n- simplifying code of inflateSync to avoid gcc 2.8 bug\n\n- support CC=\"gcc -Wall\" in configure -s (QingLong)\n- avoid a flush caused by ftell in gzopen for write mode (Ken Raeburn)\n- fix test for shared library support to avoid compiler warnings\n- zlib.lib -> zlib.dll in msdos/zlib.rc (Gilles Vollant)\n- check for TARGET_OS_MAC in addition to MACOS (Brad Pettit)\n- do not use fdopen for Metrowerks on Mac (Brad Pettit))\n- add checks for gzputc and gzputc in example.c\n- avoid warnings in gzio.c and deflate.c (Andreas Kleinert)\n- use const for the CRC table (Ken Raeburn)\n- fixed \"make uninstall\" for shared libraries\n- use Tracev instead of Trace in infblock.c\n- in example.c use correct compressed length for test_sync\n- suppress +vnocompatwarnings in configure for HPUX (not always supported)\n\nChanges in 1.0.7 (20 Jan 1998)\n- fix gzseek which was broken in write mode\n- return error for gzseek to negative absolute position\n- fix configure for Linux (Chun-Chung Chen)\n- increase stack space for MSC (Tim Wegner)\n- get_crc_table and inflateSyncPoint are EXPORTed (Gilles Vollant)\n- define EXPORTVA for gzprintf (Gilles Vollant)\n- added man page zlib.3 (Rick Rodgers)\n- for contrib/untgz, fix makedir() and improve Makefile\n\n- check gzseek in write mode in example.c\n- allocate extra buffer for seeks only if gzseek is actually called\n- avoid signed/unsigned comparisons (Tim Wegner, Gilles Vollant)\n- add inflateSyncPoint in zconf.h\n- fix list of exported functions in nt/zlib.dnt and mdsos/zlib.def\n\nChanges in 1.0.6 (19 Jan 1998)\n- add functions gzprintf, gzputc, gzgetc, gztell, gzeof, gzseek, gzrewind and\n  gzsetparams (thanks to Roland Giersig and Kevin Ruland for some of this code)\n- Fix a deflate bug occurring only with compression level 0 (thanks to\n  Andy Buckler for finding this one)\n- In minigzip, pass transparently also the first byte for .Z files\n- return Z_BUF_ERROR instead of Z_OK if output buffer full in uncompress()\n- check Z_FINISH in inflate (thanks to Marc Schluper)\n- Implement deflateCopy (thanks to Adam Costello)\n- make static libraries by default in configure, add --shared option\n- move MSDOS or Windows specific files to directory msdos\n- suppress the notion of partial flush to simplify the interface\n  (but the symbol Z_PARTIAL_FLUSH is kept for compatibility with 1.0.4)\n- suppress history buffer provided by application to simplify the interface\n  (this feature was not implemented anyway in 1.0.4)\n- next_in and avail_in must be initialized before calling inflateInit or\n  inflateInit2\n- add EXPORT in all exported functions (for Windows DLL)\n- added Makefile.nt (thanks to Stephen Williams)\n- added the unsupported \"contrib\" directory:\n   contrib/asm386/ by Gilles Vollant <info@winimage.com>\n        386 asm code replacing longest_match()\n   contrib/iostream/ by Kevin Ruland <kevin@rodin.wustl.edu>\n        A C++ I/O streams interface to the zlib gz* functions\n   contrib/iostream2/  by Tyge Løvset <Tyge.Lovset@cmr.no>\n        Another C++ I/O streams interface\n   contrib/untgz/  by \"Pedro A. Aranda Guti\\irrez\" <paag@tid.es>\n        A very simple tar.gz file extractor using zlib\n   contrib/visual-basic.txt by Carlos Rios <c_rios@sonda.cl>\n        How to use compress(), uncompress() and the gz* functions from VB\n- pass params -f (filtered data), -h (huffman only), -1 to -9 (compression\n  level) in minigzip (thanks to Tom Lane)\n\n- use const for rommable constants in deflate\n- added test for gzseek and gztell in example.c\n- add undocumented function inflateSyncPoint() (hack for Paul Mackerras)\n- add undocumented function zError to convert error code to string\n  (for Tim Smithers)\n- Allow compilation of gzio with -DNO_DEFLATE to avoid the compression code\n- Use default memcpy for Symantec MSDOS compiler\n- Add EXPORT keyword for check_func (needed for Windows DLL)\n- add current directory to LD_LIBRARY_PATH for \"make test\"\n- create also a link for libz.so.1\n- added support for FUJITSU UXP/DS (thanks to Toshiaki Nomura)\n- use $(SHAREDLIB) instead of libz.so in Makefile.in (for HPUX)\n- added -soname for Linux in configure (Chun-Chung Chen,\n- assign numbers to the exported functions in zlib.def (for Windows DLL)\n- add advice in zlib.h for best usage of deflateSetDictionary\n- work around compiler bug on Atari (cast Z_NULL in call of s->checkfn)\n- allow compilation with ANSI keywords only enabled for TurboC in large model\n- avoid \"versionString\"[0] (Borland bug)\n- add NEED_DUMMY_RETURN for Borland\n- use variable z_verbose for tracing in debug mode (L. Peter Deutsch)\n- allow compilation with CC\n- defined STDC for OS/2 (David Charlap)\n- limit external names to 8 chars for MVS (Thomas Lund)\n- in minigzip.c, use static buffers only for 16-bit systems\n- fix suffix check for \"minigzip -d foo.gz\"\n- do not return an error for the 2nd of two consecutive gzflush() (Felix Lee)\n- use _fdopen instead of fdopen for MSC >= 6.0 (Thomas Fanslau)\n- added makelcc.bat for lcc-win32 (Tom St Denis)\n- in Makefile.dj2, use copy and del instead of install and rm (Frank Donahoe)\n- Avoid expanded $Id$. Use \"rcs -kb\" or \"cvs admin -kb\" to avoid Id expansion\n- check for unistd.h in configure (for off_t)\n- remove useless check parameter in inflate_blocks_free\n- avoid useless assignment of s->check to itself in inflate_blocks_new\n- do not flush twice in gzclose (thanks to Ken Raeburn)\n- rename FOPEN as F_OPEN to avoid clash with /usr/include/sys/file.h\n- use NO_ERRNO_H instead of enumeration of operating systems with errno.h\n- work around buggy fclose on pipes for HP/UX\n- support zlib DLL with BORLAND C++ 5.0 (thanks to Glenn Randers-Pehrson)\n- fix configure if CC is already equal to gcc\n\nChanges in 1.0.5 (3 Jan 98)\n- Fix inflate to terminate gracefully when fed corrupted or invalid data\n- Use const for rommable constants in inflate\n- Eliminate memory leaks on error conditions in inflate\n- Removed some vestigial code in inflate\n- Update web address in README\n\nChanges in 1.0.4 (24 Jul 96)\n- In very rare conditions, deflate(s, Z_FINISH) could fail to produce an EOF\n  bit, so the decompressor could decompress all the correct data but went\n  on to attempt decompressing extra garbage data. This affected minigzip too\n- zlibVersion and gzerror return const char* (needed for DLL)\n- port to RISCOS (no fdopen, no multiple dots, no unlink, no fileno)\n- use z_error only for DEBUG (avoid problem with DLLs)\n\nChanges in 1.0.3 (2 Jul 96)\n- use z_streamp instead of z_stream *, which is now a far pointer in MSDOS\n  small and medium models; this makes the library incompatible with previous\n  versions for these models. (No effect in large model or on other systems.)\n- return OK instead of BUF_ERROR if previous deflate call returned with\n  avail_out as zero but there is nothing to do\n- added memcmp for non STDC compilers\n- define NO_DUMMY_DECL for more Mac compilers (.h files merged incorrectly)\n- define __32BIT__ if __386__ or i386 is defined (pb. with Watcom and SCO)\n- better check for 16-bit mode MSC (avoids problem with Symantec)\n\nChanges in 1.0.2 (23 May 96)\n- added Windows DLL support\n- added a function zlibVersion (for the DLL support)\n- fixed declarations using Bytef in infutil.c (pb with MSDOS medium model)\n- Bytef is define's instead of typedef'd only for Borland C\n- avoid reading uninitialized memory in example.c\n- mention in README that the zlib format is now RFC1950\n- updated Makefile.dj2\n- added algorithm.doc\n\nChanges in 1.0.1 (20 May 96) [1.0 skipped to avoid confusion]\n- fix array overlay in deflate.c which sometimes caused bad compressed data\n- fix inflate bug with empty stored block\n- fix MSDOS medium model which was broken in 0.99\n- fix deflateParams() which could generate bad compressed data\n- Bytef is define'd instead of typedef'ed (work around Borland bug)\n- added an INDEX file\n- new makefiles for DJGPP (Makefile.dj2), 32-bit Borland (Makefile.b32),\n  Watcom (Makefile.wat), Amiga SAS/C (Makefile.sas)\n- speed up adler32 for modern machines without auto-increment\n- added -ansi for IRIX in configure\n- static_init_done in trees.c is an int\n- define unlink as delete for VMS\n- fix configure for QNX\n- add configure branch for SCO and HPUX\n- avoid many warnings (unused variables, dead assignments, etc...)\n- no fdopen for BeOS\n- fix the Watcom fix for 32 bit mode (define FAR as empty)\n- removed redefinition of Byte for MKWERKS\n- work around an MWKERKS bug (incorrect merge of all .h files)\n\nChanges in 0.99 (27 Jan 96)\n- allow preset dictionary shared between compressor and decompressor\n- allow compression level 0 (no compression)\n- add deflateParams in zlib.h: allow dynamic change of compression level\n  and compression strategy\n- test large buffers and deflateParams in example.c\n- add optional \"configure\" to build zlib as a shared library\n- suppress Makefile.qnx, use configure instead\n- fixed deflate for 64-bit systems (detected on Cray)\n- fixed inflate_blocks for 64-bit systems (detected on Alpha)\n- declare Z_DEFLATED in zlib.h (possible parameter for deflateInit2)\n- always return Z_BUF_ERROR when deflate() has nothing to do\n- deflateInit and inflateInit are now macros to allow version checking\n- prefix all global functions and types with z_ with -DZ_PREFIX\n- make falloc completely reentrant (inftrees.c)\n- fixed very unlikely race condition in ct_static_init\n- free in reverse order of allocation to help memory manager\n- use zlib-1.0/* instead of zlib/* inside the tar.gz\n- make zlib warning-free with \"gcc -O3 -Wall -Wwrite-strings -Wpointer-arith\n  -Wconversion -Wstrict-prototypes -Wmissing-prototypes\"\n- allow gzread on concatenated .gz files\n- deflateEnd now returns Z_DATA_ERROR if it was premature\n- deflate is finally (?) fully deterministic (no matches beyond end of input)\n- Document Z_SYNC_FLUSH\n- add uninstall in Makefile\n- Check for __cpluplus in zlib.h\n- Better test in ct_align for partial flush\n- avoid harmless warnings for Borland C++\n- initialize hash_head in deflate.c\n- avoid warning on fdopen (gzio.c) for HP cc -Aa\n- include stdlib.h for STDC compilers\n- include errno.h for Cray\n- ignore error if ranlib doesn't exist\n- call ranlib twice for NeXTSTEP\n- use exec_prefix instead of prefix for libz.a\n- renamed ct_* as _tr_* to avoid conflict with applications\n- clear z->msg in inflateInit2 before any error return\n- initialize opaque in example.c, gzio.c, deflate.c and inflate.c\n- fixed typo in zconf.h (_GNUC__ => __GNUC__)\n- check for WIN32 in zconf.h and zutil.c (avoid farmalloc in 32-bit mode)\n- fix typo in Make_vms.com (f$trnlnm -> f$getsyi)\n- in fcalloc, normalize pointer if size > 65520 bytes\n- don't use special fcalloc for 32 bit Borland C++\n- use STDC instead of __GO32__ to avoid redeclaring exit, calloc, etc.\n- use Z_BINARY instead of BINARY\n- document that gzclose after gzdopen will close the file\n- allow \"a\" as mode in gzopen\n- fix error checking in gzread\n- allow skipping .gz extra-field on pipes\n- added reference to Perl interface in README\n- put the crc table in FAR data (I dislike more and more the medium model :)\n- added get_crc_table\n- added a dimension to all arrays (Borland C can't count)\n- workaround Borland C bug in declaration of inflate_codes_new & inflate_fast\n- guard against multiple inclusion of *.h (for precompiled header on Mac)\n- Watcom C pretends to be Microsoft C small model even in 32 bit mode\n- don't use unsized arrays to avoid silly warnings by Visual C++:\n     warning C4746: 'inflate_mask' : unsized array treated as  '__far'\n     (what's wrong with far data in far model?)\n- define enum out of inflate_blocks_state to allow compilation with C++\n\nChanges in 0.95 (16 Aug 95)\n- fix MSDOS small and medium model (now easier to adapt to any compiler)\n- inlined send_bits\n- fix the final (:-) bug for deflate with flush (output was correct but\n  not completely flushed in rare occasions)\n- default window size is same for compression and decompression\n  (it's now sufficient to set MAX_WBITS in zconf.h)\n- voidp -> voidpf and voidnp -> voidp (for consistency with other\n  typedefs and because voidnp was not near in large model)\n\nChanges in 0.94 (13 Aug 95)\n- support MSDOS medium model\n- fix deflate with flush (could sometimes generate bad output)\n- fix deflateReset (zlib header was incorrectly suppressed)\n- added support for VMS\n- allow a compression level in gzopen()\n- gzflush now calls fflush\n- For deflate with flush, flush even if no more input is provided\n- rename libgz.a as libz.a\n- avoid complex expression in infcodes.c triggering Turbo C bug\n- work around a problem with gcc on Alpha (in INSERT_STRING)\n- don't use inline functions (problem with some gcc versions)\n- allow renaming of Byte, uInt, etc... with #define\n- avoid warning about (unused) pointer before start of array in deflate.c\n- avoid various warnings in gzio.c, example.c, infblock.c, adler32.c, zutil.c\n- avoid reserved word 'new' in trees.c\n\nChanges in 0.93 (25 June 95)\n- temporarily disable inline functions\n- make deflate deterministic\n- give enough lookahead for PARTIAL_FLUSH\n- Set binary mode for stdin/stdout in minigzip.c for OS/2\n- don't even use signed char in inflate (not portable enough)\n- fix inflate memory leak for segmented architectures\n\nChanges in 0.92 (3 May 95)\n- don't assume that char is signed (problem on SGI)\n- Clear bit buffer when starting a stored block\n- no memcpy on Pyramid\n- suppressed inftest.c\n- optimized fill_window, put longest_match inline for gcc\n- optimized inflate on stored blocks\n- untabify all sources to simplify patches\n\nChanges in 0.91 (2 May 95)\n- Default MEM_LEVEL is 8 (not 9 for Unix) as documented in zlib.h\n- Document the memory requirements in zconf.h\n- added \"make install\"\n- fix sync search logic in inflateSync\n- deflate(Z_FULL_FLUSH) now works even if output buffer too short\n- after inflateSync, don't scare people with just \"lo world\"\n- added support for DJGPP\n\nChanges in 0.9 (1 May 95)\n- don't assume that zalloc clears the allocated memory (the TurboC bug\n  was Mark's bug after all :)\n- let again gzread copy uncompressed data unchanged (was working in 0.71)\n- deflate(Z_FULL_FLUSH), inflateReset and inflateSync are now fully implemented\n- added a test of inflateSync in example.c\n- moved MAX_WBITS to zconf.h because users might want to change that\n- document explicitly that zalloc(64K) on MSDOS must return a normalized\n  pointer (zero offset)\n- added Makefiles for Microsoft C, Turbo C, Borland C++\n- faster crc32()\n\nChanges in 0.8 (29 April 95)\n- added fast inflate (inffast.c)\n- deflate(Z_FINISH) now returns Z_STREAM_END when done. Warning: this\n  is incompatible with previous versions of zlib which returned Z_OK\n- work around a TurboC compiler bug (bad code for b << 0, see infutil.h)\n  (actually that was not a compiler bug, see 0.81 above)\n- gzread no longer reads one extra byte in certain cases\n- In gzio destroy(), don't reference a freed structure\n- avoid many warnings for MSDOS\n- avoid the ERROR symbol which is used by MS Windows\n\nChanges in 0.71 (14 April 95)\n- Fixed more MSDOS compilation problems :( There is still a bug with\n  TurboC large model\n\nChanges in 0.7 (14 April 95)\n- Added full inflate support\n- Simplified the crc32() interface. The pre- and post-conditioning\n  (one's complement) is now done inside crc32(). WARNING: this is\n  incompatible with previous versions; see zlib.h for the new usage\n\nChanges in 0.61 (12 April 95)\n- workaround for a bug in TurboC. example and minigzip now work on MSDOS\n\nChanges in 0.6 (11 April 95)\n- added minigzip.c\n- added gzdopen to reopen a file descriptor as gzFile\n- added transparent reading of non-gziped files in gzread\n- fixed bug in gzread (don't read crc as data)\n- fixed bug in destroy (gzio.c) (don't return Z_STREAM_END for gzclose)\n- don't allocate big arrays in the stack (for MSDOS)\n- fix some MSDOS compilation problems\n\nChanges in 0.5:\n- do real compression in deflate.c. Z_PARTIAL_FLUSH is supported but\n  not yet Z_FULL_FLUSH\n- support decompression but only in a single step (forced Z_FINISH)\n- added opaque object for zalloc and zfree\n- added deflateReset and inflateReset\n- added a variable zlib_version for consistency checking\n- renamed the 'filter' parameter of deflateInit2 as 'strategy'\n  Added Z_FILTERED and Z_HUFFMAN_ONLY constants\n\nChanges in 0.4:\n- avoid \"zip\" everywhere, use zlib instead of ziplib\n- suppress Z_BLOCK_FLUSH, interpret Z_PARTIAL_FLUSH as block flush\n  if compression method == 8\n- added adler32 and crc32\n- renamed deflateOptions as deflateInit2, call one or the other but not both\n- added the method parameter for deflateInit2\n- added inflateInit2\n- simplified considerably deflateInit and inflateInit by not supporting\n  user-provided history buffer. This is supported only in deflateInit2\n  and inflateInit2\n\nChanges in 0.3:\n- prefix all macro names with Z_\n- use Z_FINISH instead of deflateEnd to finish compression\n- added Z_HUFFMAN_ONLY\n- added gzerror()\n"
        },
        {
          "name": "FAQ",
          "type": "blob",
          "size": 16.1064453125,
          "content": "\n                Frequently Asked Questions about zlib\n\n\nIf your question is not there, please check the zlib home page\nhttp://zlib.net/ which may have more recent information.\nThe latest zlib FAQ is at http://zlib.net/zlib_faq.html\n\n\n 1. Is zlib Y2K-compliant?\n\n    Yes. zlib doesn't handle dates.\n\n 2. Where can I get a Windows DLL version?\n\n    The zlib sources can be compiled without change to produce a DLL.  See the\n    file win32/DLL_FAQ.txt in the zlib distribution.\n\n 3. Where can I get a Visual Basic interface to zlib?\n\n    See\n        * https://marknelson.us/posts/1997/01/01/zlib-engine.html\n        * win32/DLL_FAQ.txt in the zlib distribution\n\n 4. compress() returns Z_BUF_ERROR.\n\n    Make sure that before the call of compress(), the length of the compressed\n    buffer is equal to the available size of the compressed buffer and not\n    zero.  For Visual Basic, check that this parameter is passed by reference\n    (\"as any\"), not by value (\"as long\").\n\n 5. deflate() or inflate() returns Z_BUF_ERROR.\n\n    Before making the call, make sure that avail_in and avail_out are not zero.\n    When setting the parameter flush equal to Z_FINISH, also make sure that\n    avail_out is big enough to allow processing all pending input.  Note that a\n    Z_BUF_ERROR is not fatal--another call to deflate() or inflate() can be\n    made with more input or output space.  A Z_BUF_ERROR may in fact be\n    unavoidable depending on how the functions are used, since it is not\n    possible to tell whether or not there is more output pending when\n    strm.avail_out returns with zero.  See http://zlib.net/zlib_how.html for a\n    heavily annotated example.\n\n 6. Where's the zlib documentation (man pages, etc.)?\n\n    It's in zlib.h .  Examples of zlib usage are in the files test/example.c\n    and test/minigzip.c, with more in examples/ .\n\n 7. Why don't you use GNU autoconf or libtool or ...?\n\n    Because we would like to keep zlib as a very small and simple package.\n    zlib is rather portable and doesn't need much configuration.\n\n 8. I found a bug in zlib.\n\n    Most of the time, such problems are due to an incorrect usage of zlib.\n    Please try to reproduce the problem with a small program and send the\n    corresponding source to us at zlib@gzip.org .  Do not send multi-megabyte\n    data files without prior agreement.\n\n 9. Why do I get \"undefined reference to gzputc\"?\n\n    If \"make test\" produces something like\n\n       example.o(.text+0x154): undefined reference to `gzputc'\n\n    check that you don't have old files libz.* in /usr/lib, /usr/local/lib or\n    /usr/X11R6/lib. Remove any old versions, then do \"make install\".\n\n10. I need a Delphi interface to zlib.\n\n    See the contrib/delphi directory in the zlib distribution.\n\n11. Can zlib handle .zip archives?\n\n    Not by itself, no.  See the directory contrib/minizip in the zlib\n    distribution.\n\n12. Can zlib handle .Z files?\n\n    No, sorry.  You have to spawn an uncompress or gunzip subprocess, or adapt\n    the code of uncompress on your own.\n\n13. How can I make a Unix shared library?\n\n    By default a shared (and a static) library is built for Unix.  So:\n\n    make distclean\n    ./configure\n    make\n\n14. How do I install a shared zlib library on Unix?\n\n    After the above, then:\n\n    make install\n\n    However, many flavors of Unix come with a shared zlib already installed.\n    Before going to the trouble of compiling a shared version of zlib and\n    trying to install it, you may want to check if it's already there!  If you\n    can #include <zlib.h>, it's there.  The -lz option will probably link to\n    it.  You can check the version at the top of zlib.h or with the\n    ZLIB_VERSION symbol defined in zlib.h .\n\n15. I have a question about OttoPDF.\n\n    We are not the authors of OttoPDF. The real author is on the OttoPDF web\n    site: Joel Hainley, jhainley@myndkryme.com.\n\n16. Can zlib decode Flate data in an Adobe PDF file?\n\n    Yes. See http://www.pdflib.com/ . To modify PDF forms, see\n    http://sourceforge.net/projects/acroformtool/ .\n\n17. Why am I getting this \"register_frame_info not found\" error on Solaris?\n\n    After installing zlib 1.1.4 on Solaris 2.6, running applications using zlib\n    generates an error such as:\n\n        ld.so.1: rpm: fatal: relocation error: file /usr/local/lib/libz.so:\n        symbol __register_frame_info: referenced symbol not found\n\n    The symbol __register_frame_info is not part of zlib, it is generated by\n    the C compiler (cc or gcc).  You must recompile applications using zlib\n    which have this problem.  This problem is specific to Solaris.  See\n    http://www.sunfreeware.com for Solaris versions of zlib and applications\n    using zlib.\n\n18. Why does gzip give an error on a file I make with compress/deflate?\n\n    The compress and deflate functions produce data in the zlib format, which\n    is different and incompatible with the gzip format.  The gz* functions in\n    zlib on the other hand use the gzip format.  Both the zlib and gzip formats\n    use the same compressed data format internally, but have different headers\n    and trailers around the compressed data.\n\n19. Ok, so why are there two different formats?\n\n    The gzip format was designed to retain the directory information about a\n    single file, such as the name and last modification date.  The zlib format\n    on the other hand was designed for in-memory and communication channel\n    applications, and has a much more compact header and trailer and uses a\n    faster integrity check than gzip.\n\n20. Well that's nice, but how do I make a gzip file in memory?\n\n    You can request that deflate write the gzip format instead of the zlib\n    format using deflateInit2().  You can also request that inflate decode the\n    gzip format using inflateInit2().  Read zlib.h for more details.\n\n21. Is zlib thread-safe?\n\n    Yes.  However any library routines that zlib uses and any application-\n    provided memory allocation routines must also be thread-safe.  zlib's gz*\n    functions use stdio library routines, and most of zlib's functions use the\n    library memory allocation routines by default.  zlib's *Init* functions\n    allow for the application to provide custom memory allocation routines.\n\n    Of course, you should only operate on any given zlib or gzip stream from a\n    single thread at a time.\n\n22. Can I use zlib in my commercial application?\n\n    Yes.  Please read the license in zlib.h.\n\n23. Is zlib under the GNU license?\n\n    No.  Please read the license in zlib.h.\n\n24. The license says that altered source versions must be \"plainly marked\". So\n    what exactly do I need to do to meet that requirement?\n\n    You need to change the ZLIB_VERSION and ZLIB_VERNUM #defines in zlib.h.  In\n    particular, the final version number needs to be changed to \"f\", and an\n    identification string should be appended to ZLIB_VERSION.  Version numbers\n    x.x.x.f are reserved for modifications to zlib by others than the zlib\n    maintainers.  For example, if the version of the base zlib you are altering\n    is \"1.2.3.4\", then in zlib.h you should change ZLIB_VERNUM to 0x123f, and\n    ZLIB_VERSION to something like \"1.2.3.f-zachary-mods-v3\".  You can also\n    update the version strings in deflate.c and inftrees.c.\n\n    For altered source distributions, you should also note the origin and\n    nature of the changes in zlib.h, as well as in ChangeLog and README, along\n    with the dates of the alterations.  The origin should include at least your\n    name (or your company's name), and an email address to contact for help or\n    issues with the library.\n\n    Note that distributing a compiled zlib library along with zlib.h and\n    zconf.h is also a source distribution, and so you should change\n    ZLIB_VERSION and ZLIB_VERNUM and note the origin and nature of the changes\n    in zlib.h as you would for a full source distribution.\n\n25. Will zlib work on a big-endian or little-endian architecture, and can I\n    exchange compressed data between them?\n\n    Yes and yes.\n\n26. Will zlib work on a 64-bit machine?\n\n    Yes.  It has been tested on 64-bit machines, and has no dependence on any\n    data types being limited to 32-bits in length.  If you have any\n    difficulties, please provide a complete problem report to zlib@gzip.org\n\n27. Will zlib decompress data from the PKWare Data Compression Library?\n\n    No.  The PKWare DCL uses a completely different compressed data format than\n    does PKZIP and zlib.  However, you can look in zlib's contrib/blast\n    directory for a possible solution to your problem.\n\n28. Can I access data randomly in a compressed stream?\n\n    No, not without some preparation.  If when compressing you periodically use\n    Z_FULL_FLUSH, carefully write all the pending data at those points, and\n    keep an index of those locations, then you can start decompression at those\n    points.  You have to be careful to not use Z_FULL_FLUSH too often, since it\n    can significantly degrade compression.  Alternatively, you can scan a\n    deflate stream once to generate an index, and then use that index for\n    random access.  See examples/zran.c .\n\n29. Does zlib work on MVS, OS/390, CICS, etc.?\n\n    It has in the past, but we have not heard of any recent evidence.  There\n    were working ports of zlib 1.1.4 to MVS, but those links no longer work.\n    If you know of recent, successful applications of zlib on these operating\n    systems, please let us know.  Thanks.\n\n30. Is there some simpler, easier to read version of inflate I can look at to\n    understand the deflate format?\n\n    First off, you should read RFC 1951.  Second, yes.  Look in zlib's\n    contrib/puff directory.\n\n31. Does zlib infringe on any patents?\n\n    As far as we know, no.  In fact, that was originally the whole point behind\n    zlib.  Look here for some more information:\n\n    http://www.gzip.org/#faq11\n\n32. Can zlib work with greater than 4 GB of data?\n\n    Yes.  inflate() and deflate() will process any amount of data correctly.\n    Each call of inflate() or deflate() is limited to input and output chunks\n    of the maximum value that can be stored in the compiler's \"unsigned int\"\n    type, but there is no limit to the number of chunks.  Note however that the\n    strm.total_in and strm_total_out counters may be limited to 4 GB.  These\n    counters are provided as a convenience and are not used internally by\n    inflate() or deflate().  The application can easily set up its own counters\n    updated after each call of inflate() or deflate() to count beyond 4 GB.\n    compress() and uncompress() may be limited to 4 GB, since they operate in a\n    single call.  gzseek() and gztell() may be limited to 4 GB depending on how\n    zlib is compiled.  See the zlibCompileFlags() function in zlib.h.\n\n    The word \"may\" appears several times above since there is a 4 GB limit only\n    if the compiler's \"long\" type is 32 bits.  If the compiler's \"long\" type is\n    64 bits, then the limit is 16 exabytes.\n\n33. Does zlib have any security vulnerabilities?\n\n    The only one that we are aware of is potentially in gzprintf().  If zlib is\n    compiled to use sprintf() or vsprintf(), then there is no protection\n    against a buffer overflow of an 8K string space (or other value as set by\n    gzbuffer()), other than the caller of gzprintf() assuring that the output\n    will not exceed 8K.  On the other hand, if zlib is compiled to use\n    snprintf() or vsnprintf(), which should normally be the case, then there is\n    no vulnerability.  The ./configure script will display warnings if an\n    insecure variation of sprintf() will be used by gzprintf().  Also the\n    zlibCompileFlags() function will return information on what variant of\n    sprintf() is used by gzprintf().\n\n    If you don't have snprintf() or vsnprintf() and would like one, you can\n    find a portable implementation here:\n\n        http://www.ijs.si/software/snprintf/\n\n    Note that you should be using the most recent version of zlib.  Versions\n    1.1.3 and before were subject to a double-free vulnerability, and versions\n    1.2.1 and 1.2.2 were subject to an access exception when decompressing\n    invalid compressed data.\n\n34. Is there a Java version of zlib?\n\n    Probably what you want is to use zlib in Java. zlib is already included\n    as part of the Java SDK in the java.util.zip package. If you really want\n    a version of zlib written in the Java language, look on the zlib home\n    page for links: http://zlib.net/ .\n\n35. I get this or that compiler or source-code scanner warning when I crank it\n    up to maximally-pedantic. Can't you guys write proper code?\n\n    Many years ago, we gave up attempting to avoid warnings on every compiler\n    in the universe.  It just got to be a waste of time, and some compilers\n    were downright silly as well as contradicted each other.  So now, we simply\n    make sure that the code always works.\n\n36. Valgrind (or some similar memory access checker) says that deflate is\n    performing a conditional jump that depends on an uninitialized value.\n    Isn't that a bug?\n\n    No.  That is intentional for performance reasons, and the output of deflate\n    is not affected.  This only started showing up recently since zlib 1.2.x\n    uses malloc() by default for allocations, whereas earlier versions used\n    calloc(), which zeros out the allocated memory.  Even though the code was\n    correct, versions 1.2.4 and later was changed to not stimulate these\n    checkers.\n\n37. Will zlib read the (insert any ancient or arcane format here) compressed\n    data format?\n\n    Probably not. Look in the comp.compression FAQ for pointers to various\n    formats and associated software.\n\n38. How can I encrypt/decrypt zip files with zlib?\n\n    zlib doesn't support encryption.  The original PKZIP encryption is very\n    weak and can be broken with freely available programs.  To get strong\n    encryption, use GnuPG, http://www.gnupg.org/ , which already includes zlib\n    compression.  For PKZIP compatible \"encryption\", look at\n    http://www.info-zip.org/\n\n39. What's the difference between the \"gzip\" and \"deflate\" HTTP 1.1 encodings?\n\n    \"gzip\" is the gzip format, and \"deflate\" is the zlib format.  They should\n    probably have called the second one \"zlib\" instead to avoid confusion with\n    the raw deflate compressed data format.  While the HTTP 1.1 RFC 2616\n    correctly points to the zlib specification in RFC 1950 for the \"deflate\"\n    transfer encoding, there have been reports of servers and browsers that\n    incorrectly produce or expect raw deflate data per the deflate\n    specification in RFC 1951, most notably Microsoft.  So even though the\n    \"deflate\" transfer encoding using the zlib format would be the more\n    efficient approach (and in fact exactly what the zlib format was designed\n    for), using the \"gzip\" transfer encoding is probably more reliable due to\n    an unfortunate choice of name on the part of the HTTP 1.1 authors.\n\n    Bottom line: use the gzip format for HTTP 1.1 encoding.\n\n40. Does zlib support the new \"Deflate64\" format introduced by PKWare?\n\n    No.  PKWare has apparently decided to keep that format proprietary, since\n    they have not documented it as they have previous compression formats.  In\n    any case, the compression improvements are so modest compared to other more\n    modern approaches, that it's not worth the effort to implement.\n\n41. I'm having a problem with the zip functions in zlib, can you help?\n\n    There are no zip functions in zlib.  You are probably using minizip by\n    Giles Vollant, which is found in the contrib directory of zlib.  It is not\n    part of zlib.  In fact none of the stuff in contrib is part of zlib.  The\n    files in there are not supported by the zlib authors.  You need to contact\n    the authors of the respective contribution for help.\n\n42. The match.asm code in contrib is under the GNU General Public License.\n    Since it's part of zlib, doesn't that mean that all of zlib falls under the\n    GNU GPL?\n\n    No.  The files in contrib are not part of zlib.  They were contributed by\n    other authors and are provided as a convenience to the user within the zlib\n    distribution.  Each item in contrib has its own license.\n\n43. Is zlib subject to export controls?  What is its ECCN?\n\n    zlib is not subject to export controls, and so is classified as EAR99.\n\n44. Can you please sign these lengthy legal documents and fax them back to us\n    so that we can use your software in our product?\n\n    No. Go away. Shoo.\n"
        },
        {
          "name": "INDEX",
          "type": "blob",
          "size": 1.94140625,
          "content": "CMakeLists.txt  cmake build file\nChangeLog       history of changes\nFAQ             Frequently Asked Questions about zlib\nINDEX           this file\nMakefile        dummy Makefile that tells you to ./configure\nMakefile.in     template for Unix Makefile\nREADME          guess what\nconfigure       configure script for Unix\nmake_vms.com    makefile for VMS\ntest/example.c  zlib usages examples for build testing\ntest/minigzip.c minimal gzip-like functionality for build testing\ntest/infcover.c inf*.c code coverage for build coverage testing\ntreebuild.xml   XML description of source file dependencies\nzconf.h.cmakein zconf.h template for cmake\nzconf.h.in      zconf.h template for configure\nzlib.3          Man page for zlib\nzlib.3.pdf      Man page in PDF format\nzlib.map        Linux symbol information\nzlib.pc.in      Template for pkg-config descriptor\nzlib.pc.cmakein zlib.pc template for cmake\nzlib2ansi       perl script to convert source files for C++ compilation\n\namiga/          makefiles for Amiga SAS C\nas400/          makefiles for AS/400\ndoc/            documentation for formats and algorithms\nmsdos/          makefiles for MSDOS\nnintendods/     makefile for Nintendo DS\nold/            makefiles for various architectures and zlib documentation\n                files that have not yet been updated for zlib 1.2.x\nqnx/            makefiles for QNX\nwatcom/         makefiles for OpenWatcom\nwin32/          makefiles for Windows\n\n                zlib public header files (required for library use):\nzconf.h\nzlib.h\n\n                private source files used to build the zlib library:\nadler32.c\ncompress.c\ncrc32.c\ncrc32.h\ndeflate.c\ndeflate.h\ngzclose.c\ngzguts.h\ngzlib.c\ngzread.c\ngzwrite.c\ninfback.c\ninffast.c\ninffast.h\ninffixed.h\ninflate.c\ninflate.h\ninftrees.c\ninftrees.h\ntrees.c\ntrees.h\nuncompr.c\nzutil.c\nzutil.h\n\n                source files for sample programs\nSee examples/README.examples\n\n                unsupported contributions by third parties\nSee contrib/README.contrib\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 0.978515625,
          "content": "Copyright notice:\n\n (C) 1995-2024 Jean-loup Gailly and Mark Adler\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n\n  Jean-loup Gailly        Mark Adler\n  jloup@gzip.org          madler@alumni.caltech.edu\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.09765625,
          "content": "all:\n\t-@echo \"Please use ./configure first.  Thank you.\"\n\ndistclean:\n\tmake -f Makefile.in distclean\n"
        },
        {
          "name": "Makefile.in",
          "type": "blob",
          "size": 13.6416015625,
          "content": "# Makefile for zlib\n# Copyright (C) 1995-2024 Jean-loup Gailly, Mark Adler\n# For conditions of distribution and use, see copyright notice in zlib.h\n\n# To compile and test, type:\n#    ./configure; make test\n# Normally configure builds both a static and a shared library.\n# If you want to build just a static library, use: ./configure --static\n\n# To install /usr/local/lib/libz.* and /usr/local/include/zlib.h, type:\n#    make install\n# To install in $HOME instead of /usr/local, use:\n#    make install prefix=$HOME\n\nCC=cc\n\nCFLAGS=-O\n#CFLAGS=-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7\n#CFLAGS=-g -DZLIB_DEBUG\n#CFLAGS=-O3 -Wall -Wwrite-strings -Wpointer-arith -Wconversion \\\n#           -Wstrict-prototypes -Wmissing-prototypes\n\nSFLAGS=-O\nLDFLAGS=\nTEST_LIBS=-L. libz.a\nLDSHARED=$(CC)\nCPP=$(CC) -E\n\nSTATICLIB=libz.a\nSHAREDLIB=libz.so\nSHAREDLIBV=libz.so.1.3.1.1\nSHAREDLIBM=libz.so.1\nLIBS=$(STATICLIB) $(SHAREDLIBV)\n\nAR=ar\nARFLAGS=rc\nRANLIB=ranlib\nLDCONFIG=ldconfig\nLDSHAREDLIBC=-lc\nTAR=tar\nSHELL=/bin/sh\nEXE=\n\nprefix = /usr/local\nexec_prefix = ${prefix}\nlibdir = ${exec_prefix}/lib\nsharedlibdir = ${libdir}\nincludedir = ${prefix}/include\nmandir = ${prefix}/share/man\nman3dir = ${mandir}/man3\npkgconfigdir = ${libdir}/pkgconfig\nSRCDIR=\nZINC=\nZINCOUT=-I.\n\nOBJZ = adler32.o crc32.o deflate.o infback.o inffast.o inflate.o inftrees.o trees.o zutil.o\nOBJG = compress.o uncompr.o gzclose.o gzlib.o gzread.o gzwrite.o\nOBJC = $(OBJZ) $(OBJG)\n\nPIC_OBJZ = adler32.lo crc32.lo deflate.lo infback.lo inffast.lo inflate.lo inftrees.lo trees.lo zutil.lo\nPIC_OBJG = compress.lo uncompr.lo gzclose.lo gzlib.lo gzread.lo gzwrite.lo\nPIC_OBJC = $(PIC_OBJZ) $(PIC_OBJG)\n\n# to use the asm code: make OBJA=match.o, PIC_OBJA=match.lo\nOBJA =\nPIC_OBJA =\n\nOBJS = $(OBJC) $(OBJA)\n\nPIC_OBJS = $(PIC_OBJC) $(PIC_OBJA)\n\nall: static shared\n\nstatic: example$(EXE) minigzip$(EXE)\n\nshared: examplesh$(EXE) minigzipsh$(EXE)\n\nall64: example64$(EXE) minigzip64$(EXE)\n\ncheck: test\n\ntest: all teststatic testshared\n\nteststatic: static\n\t@TMPST=tmpst_$$; \\\n\tif echo hello world | ${QEMU_RUN} ./minigzip | ${QEMU_RUN} ./minigzip -d && ${QEMU_RUN} ./example $$TMPST ; then \\\n\t  echo '\t\t*** zlib test OK ***'; \\\n\telse \\\n\t  echo '\t\t*** zlib test FAILED ***'; false; \\\n\tfi\n\t@rm -f tmpst_$$\n\ntestshared: shared\n\t@LD_LIBRARY_PATH=`pwd`:$(LD_LIBRARY_PATH) ; export LD_LIBRARY_PATH; \\\n\tLD_LIBRARYN32_PATH=`pwd`:$(LD_LIBRARYN32_PATH) ; export LD_LIBRARYN32_PATH; \\\n\tDYLD_LIBRARY_PATH=`pwd`:$(DYLD_LIBRARY_PATH) ; export DYLD_LIBRARY_PATH; \\\n\tSHLIB_PATH=`pwd`:$(SHLIB_PATH) ; export SHLIB_PATH; \\\n\tTMPSH=tmpsh_$$; \\\n\tif echo hello world | ${QEMU_RUN} ./minigzipsh | ${QEMU_RUN} ./minigzipsh -d && ${QEMU_RUN} ./examplesh $$TMPSH; then \\\n\t  echo '\t\t*** zlib shared test OK ***'; \\\n\telse \\\n\t  echo '\t\t*** zlib shared test FAILED ***'; false; \\\n\tfi\n\t@rm -f tmpsh_$$\n\ntest64: all64\n\t@TMP64=tmp64_$$; \\\n\tif echo hello world | ${QEMU_RUN} ./minigzip64 | ${QEMU_RUN} ./minigzip64 -d && ${QEMU_RUN} ./example64 $$TMP64; then \\\n\t  echo '\t\t*** zlib 64-bit test OK ***'; \\\n\telse \\\n\t  echo '\t\t*** zlib 64-bit test FAILED ***'; false; \\\n\tfi\n\t@rm -f tmp64_$$\n\ninfcover.o: $(SRCDIR)test/infcover.c $(SRCDIR)zlib.h zconf.h\n\t$(CC) $(CFLAGS) $(ZINCOUT) -c -o $@ $(SRCDIR)test/infcover.c\n\ninfcover: infcover.o libz.a\n\t$(CC) $(CFLAGS) -o $@ infcover.o libz.a\n\ncover: infcover\n\trm -f *.gcda\n\t${QEMU_RUN} ./infcover\n\tgcov inf*.c\n\nlibz.a: $(OBJS)\n\t$(AR) $(ARFLAGS) $@ $(OBJS)\n\t-@ ($(RANLIB) $@ || true) >/dev/null 2>&1\n\nmatch.o: match.S\n\t$(CPP) match.S > _match.s\n\t$(CC) -c _match.s\n\tmv _match.o match.o\n\trm -f _match.s\n\nmatch.lo: match.S\n\t$(CPP) match.S > _match.s\n\t$(CC) -c -fPIC _match.s\n\tmv _match.o match.lo\n\trm -f _match.s\n\nexample.o: $(SRCDIR)test/example.c $(SRCDIR)zlib.h zconf.h\n\t$(CC) $(CFLAGS) $(ZINCOUT) -c -o $@ $(SRCDIR)test/example.c\n\nminigzip.o: $(SRCDIR)test/minigzip.c $(SRCDIR)zlib.h zconf.h\n\t$(CC) $(CFLAGS) $(ZINCOUT) -c -o $@ $(SRCDIR)test/minigzip.c\n\nexample64.o: $(SRCDIR)test/example.c $(SRCDIR)zlib.h zconf.h\n\t$(CC) $(CFLAGS) $(ZINCOUT) -D_FILE_OFFSET_BITS=64 -c -o $@ $(SRCDIR)test/example.c\n\nminigzip64.o: $(SRCDIR)test/minigzip.c $(SRCDIR)zlib.h zconf.h\n\t$(CC) $(CFLAGS) $(ZINCOUT) -D_FILE_OFFSET_BITS=64 -c -o $@ $(SRCDIR)test/minigzip.c\n\n\nadler32.o: $(SRCDIR)adler32.c\n\t$(CC) $(CFLAGS) $(ZINC) -c -o $@ $(SRCDIR)adler32.c\n\ncrc32.o: $(SRCDIR)crc32.c\n\t$(CC) $(CFLAGS) $(ZINC) -c -o $@ $(SRCDIR)crc32.c\n\ndeflate.o: $(SRCDIR)deflate.c\n\t$(CC) $(CFLAGS) $(ZINC) -c -o $@ $(SRCDIR)deflate.c\n\ninfback.o: $(SRCDIR)infback.c\n\t$(CC) $(CFLAGS) $(ZINC) -c -o $@ $(SRCDIR)infback.c\n\ninffast.o: $(SRCDIR)inffast.c\n\t$(CC) $(CFLAGS) $(ZINC) -c -o $@ $(SRCDIR)inffast.c\n\ninflate.o: $(SRCDIR)inflate.c\n\t$(CC) $(CFLAGS) $(ZINC) -c -o $@ $(SRCDIR)inflate.c\n\ninftrees.o: $(SRCDIR)inftrees.c\n\t$(CC) $(CFLAGS) $(ZINC) -c -o $@ $(SRCDIR)inftrees.c\n\ntrees.o: $(SRCDIR)trees.c\n\t$(CC) $(CFLAGS) $(ZINC) -c -o $@ $(SRCDIR)trees.c\n\nzutil.o: $(SRCDIR)zutil.c $(SRCDIR)gzguts.h\n\t$(CC) $(CFLAGS) $(ZINC) -c -o $@ $(SRCDIR)zutil.c\n\ncompress.o: $(SRCDIR)compress.c\n\t$(CC) $(CFLAGS) $(ZINC) -c -o $@ $(SRCDIR)compress.c\n\nuncompr.o: $(SRCDIR)uncompr.c\n\t$(CC) $(CFLAGS) $(ZINC) -c -o $@ $(SRCDIR)uncompr.c\n\ngzclose.o: $(SRCDIR)gzclose.c\n\t$(CC) $(CFLAGS) $(ZINC) -c -o $@ $(SRCDIR)gzclose.c\n\ngzlib.o: $(SRCDIR)gzlib.c\n\t$(CC) $(CFLAGS) $(ZINC) -c -o $@ $(SRCDIR)gzlib.c\n\ngzread.o: $(SRCDIR)gzread.c\n\t$(CC) $(CFLAGS) $(ZINC) -c -o $@ $(SRCDIR)gzread.c\n\ngzwrite.o: $(SRCDIR)gzwrite.c\n\t$(CC) $(CFLAGS) $(ZINC) -c -o $@ $(SRCDIR)gzwrite.c\n\n\nadler32.lo: $(SRCDIR)adler32.c\n\t-@mkdir objs 2>/dev/null || test -d objs\n\t$(CC) $(SFLAGS) $(ZINC) -DPIC -c -o objs/adler32.o $(SRCDIR)adler32.c\n\t-@mv objs/adler32.o $@\n\ncrc32.lo: $(SRCDIR)crc32.c\n\t-@mkdir objs 2>/dev/null || test -d objs\n\t$(CC) $(SFLAGS) $(ZINC) -DPIC -c -o objs/crc32.o $(SRCDIR)crc32.c\n\t-@mv objs/crc32.o $@\n\ndeflate.lo: $(SRCDIR)deflate.c\n\t-@mkdir objs 2>/dev/null || test -d objs\n\t$(CC) $(SFLAGS) $(ZINC) -DPIC -c -o objs/deflate.o $(SRCDIR)deflate.c\n\t-@mv objs/deflate.o $@\n\ninfback.lo: $(SRCDIR)infback.c\n\t-@mkdir objs 2>/dev/null || test -d objs\n\t$(CC) $(SFLAGS) $(ZINC) -DPIC -c -o objs/infback.o $(SRCDIR)infback.c\n\t-@mv objs/infback.o $@\n\ninffast.lo: $(SRCDIR)inffast.c\n\t-@mkdir objs 2>/dev/null || test -d objs\n\t$(CC) $(SFLAGS) $(ZINC) -DPIC -c -o objs/inffast.o $(SRCDIR)inffast.c\n\t-@mv objs/inffast.o $@\n\ninflate.lo: $(SRCDIR)inflate.c\n\t-@mkdir objs 2>/dev/null || test -d objs\n\t$(CC) $(SFLAGS) $(ZINC) -DPIC -c -o objs/inflate.o $(SRCDIR)inflate.c\n\t-@mv objs/inflate.o $@\n\ninftrees.lo: $(SRCDIR)inftrees.c\n\t-@mkdir objs 2>/dev/null || test -d objs\n\t$(CC) $(SFLAGS) $(ZINC) -DPIC -c -o objs/inftrees.o $(SRCDIR)inftrees.c\n\t-@mv objs/inftrees.o $@\n\ntrees.lo: $(SRCDIR)trees.c\n\t-@mkdir objs 2>/dev/null || test -d objs\n\t$(CC) $(SFLAGS) $(ZINC) -DPIC -c -o objs/trees.o $(SRCDIR)trees.c\n\t-@mv objs/trees.o $@\n\nzutil.lo: $(SRCDIR)zutil.c $(SRCDIR)gzguts.h\n\t-@mkdir objs 2>/dev/null || test -d objs\n\t$(CC) $(SFLAGS) $(ZINC) -DPIC -c -o objs/zutil.o $(SRCDIR)zutil.c\n\t-@mv objs/zutil.o $@\n\ncompress.lo: $(SRCDIR)compress.c\n\t-@mkdir objs 2>/dev/null || test -d objs\n\t$(CC) $(SFLAGS) $(ZINC) -DPIC -c -o objs/compress.o $(SRCDIR)compress.c\n\t-@mv objs/compress.o $@\n\nuncompr.lo: $(SRCDIR)uncompr.c\n\t-@mkdir objs 2>/dev/null || test -d objs\n\t$(CC) $(SFLAGS) $(ZINC) -DPIC -c -o objs/uncompr.o $(SRCDIR)uncompr.c\n\t-@mv objs/uncompr.o $@\n\ngzclose.lo: $(SRCDIR)gzclose.c\n\t-@mkdir objs 2>/dev/null || test -d objs\n\t$(CC) $(SFLAGS) $(ZINC) -DPIC -c -o objs/gzclose.o $(SRCDIR)gzclose.c\n\t-@mv objs/gzclose.o $@\n\ngzlib.lo: $(SRCDIR)gzlib.c\n\t-@mkdir objs 2>/dev/null || test -d objs\n\t$(CC) $(SFLAGS) $(ZINC) -DPIC -c -o objs/gzlib.o $(SRCDIR)gzlib.c\n\t-@mv objs/gzlib.o $@\n\ngzread.lo: $(SRCDIR)gzread.c\n\t-@mkdir objs 2>/dev/null || test -d objs\n\t$(CC) $(SFLAGS) $(ZINC) -DPIC -c -o objs/gzread.o $(SRCDIR)gzread.c\n\t-@mv objs/gzread.o $@\n\ngzwrite.lo: $(SRCDIR)gzwrite.c\n\t-@mkdir objs 2>/dev/null || test -d objs\n\t$(CC) $(SFLAGS) $(ZINC) -DPIC -c -o objs/gzwrite.o $(SRCDIR)gzwrite.c\n\t-@mv objs/gzwrite.o $@\n\n\nplacebo $(SHAREDLIBV): $(PIC_OBJS) libz.a\n\t$(LDSHARED) $(SFLAGS) -o $@ $(PIC_OBJS) $(LDSHAREDLIBC) $(LDFLAGS)\n\trm -f $(SHAREDLIB) $(SHAREDLIBM)\n\tln -s $@ $(SHAREDLIB)\n\tln -s $@ $(SHAREDLIBM)\n\t-@rmdir objs\n\nexample$(EXE): example.o $(STATICLIB)\n\t$(CC) $(CFLAGS) $(LDFLAGS) -o $@ example.o $(TEST_LIBS)\n\nminigzip$(EXE): minigzip.o $(STATICLIB)\n\t$(CC) $(CFLAGS) $(LDFLAGS) -o $@ minigzip.o $(TEST_LIBS)\n\nexamplesh$(EXE): example.o $(SHAREDLIBV)\n\t$(CC) $(CFLAGS) -o $@ example.o $(LDFLAGS) -L. $(SHAREDLIBV)\n\nminigzipsh$(EXE): minigzip.o $(SHAREDLIBV)\n\t$(CC) $(CFLAGS) -o $@ minigzip.o $(LDFLAGS) -L. $(SHAREDLIBV)\n\nexample64$(EXE): example64.o $(STATICLIB)\n\t$(CC) $(CFLAGS) $(LDFLAGS) -o $@ example64.o $(TEST_LIBS)\n\nminigzip64$(EXE): minigzip64.o $(STATICLIB)\n\t$(CC) $(CFLAGS) $(LDFLAGS) -o $@ minigzip64.o $(TEST_LIBS)\n\ninstall-libs: $(LIBS)\n\t-@if [ ! -d $(DESTDIR)$(exec_prefix)  ]; then mkdir -p $(DESTDIR)$(exec_prefix); fi\n\t-@if [ ! -d $(DESTDIR)$(libdir)       ]; then mkdir -p $(DESTDIR)$(libdir); fi\n\t-@if [ ! -d $(DESTDIR)$(sharedlibdir) ]; then mkdir -p $(DESTDIR)$(sharedlibdir); fi\n\t-@if [ ! -d $(DESTDIR)$(man3dir)      ]; then mkdir -p $(DESTDIR)$(man3dir); fi\n\t-@if [ ! -d $(DESTDIR)$(pkgconfigdir) ]; then mkdir -p $(DESTDIR)$(pkgconfigdir); fi\n\trm -f $(DESTDIR)$(libdir)/$(STATICLIB)\n\tcp $(STATICLIB) $(DESTDIR)$(libdir)\n\tchmod 644 $(DESTDIR)$(libdir)/$(STATICLIB)\n\t-@($(RANLIB) $(DESTDIR)$(libdir)/libz.a || true) >/dev/null 2>&1\n\t-@if test -n \"$(SHAREDLIBV)\"; then \\\n\t  rm -f $(DESTDIR)$(sharedlibdir)/$(SHAREDLIBV); \\\n\t  cp $(SHAREDLIBV) $(DESTDIR)$(sharedlibdir); \\\n\t  echo \"cp $(SHAREDLIBV) $(DESTDIR)$(sharedlibdir)\"; \\\n\t  chmod 755 $(DESTDIR)$(sharedlibdir)/$(SHAREDLIBV); \\\n\t  echo \"chmod 755 $(DESTDIR)$(sharedlibdir)/$(SHAREDLIBV)\"; \\\n\t  rm -f $(DESTDIR)$(sharedlibdir)/$(SHAREDLIB) $(DESTDIR)$(sharedlibdir)/$(SHAREDLIBM); \\\n\t  ln -s $(SHAREDLIBV) $(DESTDIR)$(sharedlibdir)/$(SHAREDLIB); \\\n\t  ln -s $(SHAREDLIBV) $(DESTDIR)$(sharedlibdir)/$(SHAREDLIBM); \\\n\t  ($(LDCONFIG) || true)  >/dev/null 2>&1; \\\n\tfi\n\trm -f $(DESTDIR)$(man3dir)/zlib.3\n\tcp $(SRCDIR)zlib.3 $(DESTDIR)$(man3dir)\n\tchmod 644 $(DESTDIR)$(man3dir)/zlib.3\n\trm -f $(DESTDIR)$(pkgconfigdir)/zlib.pc\n\tcp zlib.pc $(DESTDIR)$(pkgconfigdir)\n\tchmod 644 $(DESTDIR)$(pkgconfigdir)/zlib.pc\n# The ranlib in install is needed on NeXTSTEP which checks file times\n# ldconfig is for Linux\n\ninstall: install-libs\n\t-@if [ ! -d $(DESTDIR)$(includedir)   ]; then mkdir -p $(DESTDIR)$(includedir); fi\n\trm -f $(DESTDIR)$(includedir)/zlib.h $(DESTDIR)$(includedir)/zconf.h\n\tcp $(SRCDIR)zlib.h zconf.h $(DESTDIR)$(includedir)\n\tchmod 644 $(DESTDIR)$(includedir)/zlib.h $(DESTDIR)$(includedir)/zconf.h\n\nuninstall:\n\tcd $(DESTDIR)$(includedir) && rm -f zlib.h zconf.h\n\tcd $(DESTDIR)$(libdir) && rm -f libz.a; \\\n\tif test -n \"$(SHAREDLIBV)\" -a -f $(SHAREDLIBV); then \\\n\t  rm -f $(SHAREDLIBV) $(SHAREDLIB) $(SHAREDLIBM); \\\n\tfi\n\tcd $(DESTDIR)$(man3dir) && rm -f zlib.3\n\tcd $(DESTDIR)$(pkgconfigdir) && rm -f zlib.pc\n\ndocs: zlib.3.pdf\n\nzlib.3.pdf: $(SRCDIR)zlib.3\n\tgroff -mandoc -f H -T ps $(SRCDIR)zlib.3 | ps2pdf - $@\n\nzconf.h.cmakein: $(SRCDIR)zconf.h.in\n\t-@ TEMPFILE=zconfh_$$; \\\n\techo \"/#define ZCONF_H/ a\\\\\\\\\\n#cmakedefine Z_PREFIX\\\\\\\\\\n#cmakedefine Z_HAVE_UNISTD_H\\n\" >> $$TEMPFILE &&\\\n\tsed -f $$TEMPFILE $(SRCDIR)zconf.h.in > $@ &&\\\n\ttouch -r $(SRCDIR)zconf.h.in $@ &&\\\n\trm $$TEMPFILE\n\nzconf: $(SRCDIR)zconf.h.in\n\tcp -p $(SRCDIR)zconf.h.in zconf.h\n\nminizip-test: static\n\tcd contrib/minizip && { CC=\"$(CC)\" CFLAGS=\"$(CFLAGS)\" $(MAKE) test ; cd ../.. ; }\n\nminizip-clean:\n\tcd contrib/minizip && { $(MAKE) clean ; cd ../.. ; }\n\nmostlyclean: clean\nclean: minizip-clean\n\trm -f *.o *.lo *~ \\\n\t   example$(EXE) minigzip$(EXE) examplesh$(EXE) minigzipsh$(EXE) \\\n\t   example64$(EXE) minigzip64$(EXE) \\\n\t   infcover \\\n\t   libz.* foo.gz so_locations \\\n\t   _match.s maketree contrib/infback9/*.o\n\trm -rf objs\n\trm -f *.gcda *.gcno *.gcov\n\trm -f contrib/infback9/*.gcda contrib/infback9/*.gcno contrib/infback9/*.gcov\n\nmaintainer-clean: distclean\ndistclean: clean zconf zconf.h.cmakein\n\trm -f Makefile zlib.pc configure.log\n\t-@rm -f .DS_Store\n\t@if [ -f Makefile.in ]; then \\\n\tprintf 'all:\\n\\t-@echo \"Please use ./configure first.  Thank you.\"\\n' > Makefile ; \\\n\tprintf '\\ndistclean:\\n\\tmake -f Makefile.in distclean\\n' >> Makefile ; \\\n\ttouch -r $(SRCDIR)Makefile.in Makefile ; fi\n\ntags:\n\tetags $(SRCDIR)*.[ch]\n\nadler32.o: $(SRCDIR)zutil.h $(SRCDIR)zlib.h zconf.h\nzutil.o: $(SRCDIR)zutil.h $(SRCDIR)zlib.h zconf.h $(SRCDIR)gzguts.h\ngzclose.o gzlib.o gzread.o gzwrite.o: $(SRCDIR)zlib.h zconf.h $(SRCDIR)gzguts.h\ncompress.o example.o minigzip.o uncompr.o: $(SRCDIR)zlib.h zconf.h\ncrc32.o: $(SRCDIR)zutil.h $(SRCDIR)zlib.h zconf.h $(SRCDIR)crc32.h\ndeflate.o: $(SRCDIR)deflate.h $(SRCDIR)zutil.h $(SRCDIR)zlib.h zconf.h\ninfback.o inflate.o: $(SRCDIR)zutil.h $(SRCDIR)zlib.h zconf.h $(SRCDIR)inftrees.h $(SRCDIR)inflate.h $(SRCDIR)inffast.h $(SRCDIR)inffixed.h\ninffast.o: $(SRCDIR)zutil.h $(SRCDIR)zlib.h zconf.h $(SRCDIR)inftrees.h $(SRCDIR)inflate.h $(SRCDIR)inffast.h\ninftrees.o: $(SRCDIR)zutil.h $(SRCDIR)zlib.h zconf.h $(SRCDIR)inftrees.h\ntrees.o: $(SRCDIR)deflate.h $(SRCDIR)zutil.h $(SRCDIR)zlib.h zconf.h $(SRCDIR)trees.h\n\nadler32.lo: $(SRCDIR)zutil.h $(SRCDIR)zlib.h zconf.h\nzutil.lo: $(SRCDIR)zutil.h $(SRCDIR)zlib.h zconf.h $(SRCDIR)gzguts.h\ngzclose.lo gzlib.lo gzread.lo gzwrite.lo: $(SRCDIR)zlib.h zconf.h $(SRCDIR)gzguts.h\ncompress.lo example.lo minigzip.lo uncompr.lo: $(SRCDIR)zlib.h zconf.h\ncrc32.lo: $(SRCDIR)zutil.h $(SRCDIR)zlib.h zconf.h $(SRCDIR)crc32.h\ndeflate.lo: $(SRCDIR)deflate.h $(SRCDIR)zutil.h $(SRCDIR)zlib.h zconf.h\ninfback.lo inflate.lo: $(SRCDIR)zutil.h $(SRCDIR)zlib.h zconf.h $(SRCDIR)inftrees.h $(SRCDIR)inflate.h $(SRCDIR)inffast.h $(SRCDIR)inffixed.h\ninffast.lo: $(SRCDIR)zutil.h $(SRCDIR)zlib.h zconf.h $(SRCDIR)inftrees.h $(SRCDIR)inflate.h $(SRCDIR)inffast.h\ninftrees.lo: $(SRCDIR)zutil.h $(SRCDIR)zlib.h zconf.h $(SRCDIR)inftrees.h\ntrees.lo: $(SRCDIR)deflate.h $(SRCDIR)zutil.h $(SRCDIR)zlib.h zconf.h $(SRCDIR)trees.h\n"
        },
        {
          "name": "README",
          "type": "blob",
          "size": 5.150390625,
          "content": "ZLIB DATA COMPRESSION LIBRARY\n\nzlib 1.3.1.1 is a general purpose data compression library.  All the code is\nthread safe.  The data format used by the zlib library is described by RFCs\n(Request for Comments) 1950 to 1952 in the files\nhttp://tools.ietf.org/html/rfc1950 (zlib format), rfc1951 (deflate format) and\nrfc1952 (gzip format).\n\nAll functions of the compression library are documented in the file zlib.h\n(volunteer to write man pages welcome, contact zlib@gzip.org).  A usage example\nof the library is given in the file test/example.c which also tests that\nthe library is working correctly.  Another example is given in the file\ntest/minigzip.c.  The compression library itself is composed of all source\nfiles in the root directory.\n\nTo compile all files and run the test program, follow the instructions given at\nthe top of Makefile.in.  In short \"./configure; make test\", and if that goes\nwell, \"make install\" should work for most flavors of Unix.  For Windows, use\none of the special makefiles in win32/ or contrib/vstudio/ .  For VMS, use\nmake_vms.com.\n\nQuestions about zlib should be sent to <zlib@gzip.org>, or to Gilles Vollant\n<info@winimage.com> for the Windows DLL version.  The zlib home page is\nhttp://zlib.net/ .  Before reporting a problem, please check this site to\nverify that you have the latest version of zlib; otherwise get the latest\nversion and check whether the problem still exists or not.\n\nPLEASE read the zlib FAQ http://zlib.net/zlib_faq.html before asking for help.\n\nMark Nelson <markn@ieee.org> wrote an article about zlib for the Jan.  1997\nissue of Dr.  Dobb's Journal; a copy of the article is available at\nhttps://marknelson.us/posts/1997/01/01/zlib-engine.html .\n\nThe changes made in version 1.3.1.1 are documented in the file ChangeLog.\n\nUnsupported third party contributions are provided in directory contrib/ .\n\nzlib is available in Java using the java.util.zip package. Follow the API\nDocumentation link at: https://docs.oracle.com/search/?q=java.util.zip .\n\nA Perl interface to zlib and bzip2 written by Paul Marquess <pmqs@cpan.org>\ncan be found at https://github.com/pmqs/IO-Compress .\n\nA Python interface to zlib written by A.M. Kuchling <amk@amk.ca> is\navailable in Python 1.5 and later versions, see\nhttp://docs.python.org/library/zlib.html .\n\nzlib is built into tcl: http://wiki.tcl.tk/4610 .\n\nAn experimental package to read and write files in .zip format, written on top\nof zlib by Gilles Vollant <info@winimage.com>, is available in the\ncontrib/minizip directory of zlib.\n\n\nNotes for some targets:\n\n- For Windows DLL versions, please see win32/DLL_FAQ.txt\n\n- For 64-bit Irix, deflate.c must be compiled without any optimization. With\n  -O, one libpng test fails. The test works in 32 bit mode (with the -n32\n  compiler flag). The compiler bug has been reported to SGI.\n\n- zlib doesn't work with gcc 2.6.3 on a DEC 3000/300LX under OSF/1 2.1 it works\n  when compiled with cc.\n\n- On Digital Unix 4.0D (formerly OSF/1) on AlphaServer, the cc option -std1 is\n  necessary to get gzprintf working correctly. This is done by configure.\n\n- zlib doesn't work on HP-UX 9.05 with some versions of /bin/cc. It works with\n  other compilers. Use \"make test\" to check your compiler.\n\n- For PalmOs, see http://palmzlib.sourceforge.net/\n\n\nAcknowledgments:\n\n  The deflate format used by zlib was defined by Phil Katz.  The deflate and\n  zlib specifications were written by L.  Peter Deutsch.  Thanks to all the\n  people who reported problems and suggested various improvements in zlib; they\n  are too numerous to cite here.\n\nCopyright notice:\n\n (C) 1995-2024 Jean-loup Gailly and Mark Adler\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n\n  Jean-loup Gailly        Mark Adler\n  jloup@gzip.org          madler@alumni.caltech.edu\n\nIf you use the zlib library in a product, we would appreciate *not* receiving\nlengthy legal documents to sign.  The sources are provided for free but without\nwarranty of any kind.  The library has been entirely written by Jean-loup\nGailly and Mark Adler; it does not include third-party code.  We make all\ncontributions to and distributions of this project solely in our personal\ncapacity, and are not conveying any rights to any intellectual property of\nany third parties.\n\nIf you redistribute modified sources, we would appreciate that you include in\nthe file ChangeLog history information documenting your changes.  Please read\nthe FAQ for more information on the distribution of modified source versions.\n"
        },
        {
          "name": "adler32.c",
          "type": "blob",
          "size": 4.84765625,
          "content": "/* adler32.c -- compute the Adler-32 checksum of a data stream\n * Copyright (C) 1995-2011, 2016 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n/* @(#) $Id$ */\n\n#include \"zutil.h\"\n\n#define BASE 65521U     /* largest prime smaller than 65536 */\n#define NMAX 5552\n/* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1 */\n\n#define DO1(buf,i)  {adler += (buf)[i]; sum2 += adler;}\n#define DO2(buf,i)  DO1(buf,i); DO1(buf,i+1);\n#define DO4(buf,i)  DO2(buf,i); DO2(buf,i+2);\n#define DO8(buf,i)  DO4(buf,i); DO4(buf,i+4);\n#define DO16(buf)   DO8(buf,0); DO8(buf,8);\n\n/* use NO_DIVIDE if your processor does not do division in hardware --\n   try it both ways to see which is faster */\n#ifdef NO_DIVIDE\n/* note that this assumes BASE is 65521, where 65536 % 65521 == 15\n   (thank you to John Reiser for pointing this out) */\n#  define CHOP(a) \\\n    do { \\\n        unsigned long tmp = a >> 16; \\\n        a &= 0xffffUL; \\\n        a += (tmp << 4) - tmp; \\\n    } while (0)\n#  define MOD28(a) \\\n    do { \\\n        CHOP(a); \\\n        if (a >= BASE) a -= BASE; \\\n    } while (0)\n#  define MOD(a) \\\n    do { \\\n        CHOP(a); \\\n        MOD28(a); \\\n    } while (0)\n#  define MOD63(a) \\\n    do { /* this assumes a is not negative */ \\\n        z_off64_t tmp = a >> 32; \\\n        a &= 0xffffffffL; \\\n        a += (tmp << 8) - (tmp << 5) + tmp; \\\n        tmp = a >> 16; \\\n        a &= 0xffffL; \\\n        a += (tmp << 4) - tmp; \\\n        tmp = a >> 16; \\\n        a &= 0xffffL; \\\n        a += (tmp << 4) - tmp; \\\n        if (a >= BASE) a -= BASE; \\\n    } while (0)\n#else\n#  define MOD(a) a %= BASE\n#  define MOD28(a) a %= BASE\n#  define MOD63(a) a %= BASE\n#endif\n\n/* ========================================================================= */\nuLong ZEXPORT adler32_z(uLong adler, const Bytef *buf, z_size_t len) {\n    unsigned long sum2;\n    unsigned n;\n\n    /* split Adler-32 into component sums */\n    sum2 = (adler >> 16) & 0xffff;\n    adler &= 0xffff;\n\n    /* in case user likes doing a byte at a time, keep it fast */\n    if (len == 1) {\n        adler += buf[0];\n        if (adler >= BASE)\n            adler -= BASE;\n        sum2 += adler;\n        if (sum2 >= BASE)\n            sum2 -= BASE;\n        return adler | (sum2 << 16);\n    }\n\n    /* initial Adler-32 value (deferred check for len == 1 speed) */\n    if (buf == Z_NULL)\n        return 1L;\n\n    /* in case short lengths are provided, keep it somewhat fast */\n    if (len < 16) {\n        while (len--) {\n            adler += *buf++;\n            sum2 += adler;\n        }\n        if (adler >= BASE)\n            adler -= BASE;\n        MOD28(sum2);            /* only added so many BASE's */\n        return adler | (sum2 << 16);\n    }\n\n    /* do length NMAX blocks -- requires just one modulo operation */\n    while (len >= NMAX) {\n        len -= NMAX;\n        n = NMAX / 16;          /* NMAX is divisible by 16 */\n        do {\n            DO16(buf);          /* 16 sums unrolled */\n            buf += 16;\n        } while (--n);\n        MOD(adler);\n        MOD(sum2);\n    }\n\n    /* do remaining bytes (less than NMAX, still just one modulo) */\n    if (len) {                  /* avoid modulos if none remaining */\n        while (len >= 16) {\n            len -= 16;\n            DO16(buf);\n            buf += 16;\n        }\n        while (len--) {\n            adler += *buf++;\n            sum2 += adler;\n        }\n        MOD(adler);\n        MOD(sum2);\n    }\n\n    /* return recombined sums */\n    return adler | (sum2 << 16);\n}\n\n/* ========================================================================= */\nuLong ZEXPORT adler32(uLong adler, const Bytef *buf, uInt len) {\n    return adler32_z(adler, buf, len);\n}\n\n/* ========================================================================= */\nlocal uLong adler32_combine_(uLong adler1, uLong adler2, z_off64_t len2) {\n    unsigned long sum1;\n    unsigned long sum2;\n    unsigned rem;\n\n    /* for negative len, return invalid adler32 as a clue for debugging */\n    if (len2 < 0)\n        return 0xffffffffUL;\n\n    /* the derivation of this formula is left as an exercise for the reader */\n    MOD63(len2);                /* assumes len2 >= 0 */\n    rem = (unsigned)len2;\n    sum1 = adler1 & 0xffff;\n    sum2 = rem * sum1;\n    MOD(sum2);\n    sum1 += (adler2 & 0xffff) + BASE - 1;\n    sum2 += ((adler1 >> 16) & 0xffff) + ((adler2 >> 16) & 0xffff) + BASE - rem;\n    if (sum1 >= BASE) sum1 -= BASE;\n    if (sum1 >= BASE) sum1 -= BASE;\n    if (sum2 >= ((unsigned long)BASE << 1)) sum2 -= ((unsigned long)BASE << 1);\n    if (sum2 >= BASE) sum2 -= BASE;\n    return sum1 | (sum2 << 16);\n}\n\n/* ========================================================================= */\nuLong ZEXPORT adler32_combine(uLong adler1, uLong adler2, z_off_t len2) {\n    return adler32_combine_(adler1, adler2, len2);\n}\n\nuLong ZEXPORT adler32_combine64(uLong adler1, uLong adler2, z_off64_t len2) {\n    return adler32_combine_(adler1, adler2, len2);\n}\n"
        },
        {
          "name": "amiga",
          "type": "tree",
          "content": null
        },
        {
          "name": "compress.c",
          "type": "blob",
          "size": 2.5517578125,
          "content": "/* compress.c -- compress a memory buffer\n * Copyright (C) 1995-2005, 2014, 2016 Jean-loup Gailly, Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n/* @(#) $Id$ */\n\n#define ZLIB_INTERNAL\n#include \"zlib.h\"\n\n/* ===========================================================================\n     Compresses the source buffer into the destination buffer. The level\n   parameter has the same meaning as in deflateInit.  sourceLen is the byte\n   length of the source buffer. Upon entry, destLen is the total size of the\n   destination buffer, which must be at least 0.1% larger than sourceLen plus\n   12 bytes. Upon exit, destLen is the actual size of the compressed buffer.\n\n     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough\n   memory, Z_BUF_ERROR if there was not enough room in the output buffer,\n   Z_STREAM_ERROR if the level parameter is invalid.\n*/\nint ZEXPORT compress2(Bytef *dest, uLongf *destLen, const Bytef *source,\n                      uLong sourceLen, int level) {\n    z_stream stream;\n    int err;\n    const uInt max = (uInt)-1;\n    uLong left;\n\n    left = *destLen;\n    *destLen = 0;\n\n    stream.zalloc = (alloc_func)0;\n    stream.zfree = (free_func)0;\n    stream.opaque = (voidpf)0;\n\n    err = deflateInit(&stream, level);\n    if (err != Z_OK) return err;\n\n    stream.next_out = dest;\n    stream.avail_out = 0;\n    stream.next_in = (z_const Bytef *)source;\n    stream.avail_in = 0;\n\n    do {\n        if (stream.avail_out == 0) {\n            stream.avail_out = left > (uLong)max ? max : (uInt)left;\n            left -= stream.avail_out;\n        }\n        if (stream.avail_in == 0) {\n            stream.avail_in = sourceLen > (uLong)max ? max : (uInt)sourceLen;\n            sourceLen -= stream.avail_in;\n        }\n        err = deflate(&stream, sourceLen ? Z_NO_FLUSH : Z_FINISH);\n    } while (err == Z_OK);\n\n    *destLen = stream.total_out;\n    deflateEnd(&stream);\n    return err == Z_STREAM_END ? Z_OK : err;\n}\n\n/* ===========================================================================\n */\nint ZEXPORT compress(Bytef *dest, uLongf *destLen, const Bytef *source,\n                     uLong sourceLen) {\n    return compress2(dest, destLen, source, sourceLen, Z_DEFAULT_COMPRESSION);\n}\n\n/* ===========================================================================\n     If the default memLevel or windowBits for deflateInit() is changed, then\n   this function needs to be updated.\n */\nuLong ZEXPORT compressBound(uLong sourceLen) {\n    return sourceLen + (sourceLen >> 12) + (sourceLen >> 14) +\n           (sourceLen >> 25) + 13;\n}\n"
        },
        {
          "name": "configure",
          "type": "blob",
          "size": 27.630859375,
          "content": "#!/bin/sh\n# configure script for zlib.\n#\n# Normally configure builds both a static and a shared library.\n# If you want to build just a static library, use: ./configure --static\n#\n# To impose specific compiler or flags or install directory, use for example:\n#    prefix=$HOME CC=cc CFLAGS=\"-O4\" ./configure\n# or for csh/tcsh users:\n#    (setenv prefix $HOME; setenv CC cc; setenv CFLAGS \"-O4\"; ./configure)\n\n# Incorrect settings of CC or CFLAGS may prevent creating a shared library.\n# If you have problems, try without defining CC and CFLAGS before reporting\n# an error.\n\n# start off configure.log\necho -------------------- >> configure.log\necho $0 $* >> configure.log\ndate >> configure.log\n\n# get source directory\nSRCDIR=`dirname $0`\nif test $SRCDIR = \".\"; then\n    ZINC=\"\"\n    ZINCOUT=\"-I.\"\n    SRCDIR=\"\"\nelse\n    ZINC='-I. -include zconf.h'\n    ZINCOUT='-I. -I$(SRCDIR)'\n    SRCDIR=\"$SRCDIR/\"\nfi\n\n# set command prefix for cross-compilation\nif [ -n \"${CHOST}\" ]; then\n    uname=${CHOST}\n    mname=${CHOST}\n    CROSS_PREFIX=\"${CHOST}-\"\nelse\n    mname=`(uname -a || echo unknown) 2>/dev/null`\nfi\n\n# destination name for static library\nSTATICLIB=libz.a\n\n# extract zlib version numbers from zlib.h\nVER=`sed -n -e '/VERSION \"/s/.*\"\\(.*\\)\".*/\\1/p' < ${SRCDIR}zlib.h`\nVER3=`echo ${VER}|sed -n -e 's/\\([0-9]\\{1,\\}\\(\\\\.[0-9]\\{1,\\}\\)\\{1,2\\}\\).*/\\1/p'`\nVER1=`echo ${VER}|sed -n -e 's/\\([0-9]\\{1,\\}\\)\\\\..*/\\1/p'`\n\n# establish commands for library building\nif \"${CROSS_PREFIX}ar\" --version >/dev/null 2>/dev/null || test $? -lt 126; then\n    AR=${AR-\"${CROSS_PREFIX}ar\"}\n    test -n \"${CROSS_PREFIX}\" && echo Using ${AR} | tee -a configure.log\nelse\n    AR=${AR-\"ar\"}\n    test -n \"${CROSS_PREFIX}\" && echo Using ${AR} | tee -a configure.log\nfi\nARFLAGS=${ARFLAGS-\"rc\"}\nif \"${CROSS_PREFIX}ranlib\" --version >/dev/null 2>/dev/null || test $? -lt 126; then\n    RANLIB=${RANLIB-\"${CROSS_PREFIX}ranlib\"}\n    test -n \"${CROSS_PREFIX}\" && echo Using ${RANLIB} | tee -a configure.log\nelse\n    RANLIB=${RANLIB-\"ranlib\"}\nfi\nif \"${CROSS_PREFIX}nm\" --version >/dev/null 2>/dev/null || test $? -lt 126; then\n    NM=${NM-\"${CROSS_PREFIX}nm\"}\n    test -n \"${CROSS_PREFIX}\" && echo Using ${NM} | tee -a configure.log\nelse\n    NM=${NM-\"nm\"}\nfi\n\n# set defaults before processing command line options\nLDCONFIG=${LDCONFIG-\"ldconfig\"}\nLDSHAREDLIBC=\"${LDSHAREDLIBC--lc}\"\nARCHS=\nprefix=${prefix-/usr/local}\nexec_prefix=${exec_prefix-'${prefix}'}\nlibdir=${libdir-'${exec_prefix}/lib'}\nsharedlibdir=${sharedlibdir-'${libdir}'}\nincludedir=${includedir-'${prefix}/include'}\nmandir=${mandir-'${prefix}/share/man'}\nshared_ext='.so'\nshared=1\nsolo=0\ncover=0\nzprefix=0\nzconst=0\nbuild64=0\ngcc=0\nwarn=0\ndebug=0\naddress=0\nmemory=0\nunknown=0\nold_cc=\"$CC\"\nold_cflags=\"$CFLAGS\"\nOBJC='$(OBJZ) $(OBJG)'\nPIC_OBJC='$(PIC_OBJZ) $(PIC_OBJG)'\n\n# leave this script, optionally in a bad way\nleave()\n{\n  if test \"$*\" != \"0\"; then\n    echo \"** $0 aborting.\" | tee -a configure.log\n  fi\n  rm -rf $test.[co] $test $test$shared_ext $test.gcno $test.dSYM ./--version\n  echo -------------------- >> configure.log\n  echo >> configure.log\n  echo >> configure.log\n  exit $1\n}\n\n# process command line options\nwhile test $# -ge 1\ndo\ncase \"$1\" in\n    -h* | --help)\n      echo 'usage:' | tee -a configure.log\n      echo '  configure [--const] [--zprefix] [--prefix=PREFIX]  [--eprefix=EXPREFIX]' | tee -a configure.log\n      echo '    [--static] [--64] [--libdir=LIBDIR] [--sharedlibdir=LIBDIR]' | tee -a configure.log\n      echo '    [--includedir=INCLUDEDIR] [--archs=\"-arch i386 -arch x86_64\"]' | tee -a configure.log\n        exit 0 ;;\n    -p*=* | --prefix=*) prefix=`echo $1 | sed 's/.*=//'`; shift ;;\n    -e*=* | --eprefix=*) exec_prefix=`echo $1 | sed 's/.*=//'`; shift ;;\n    -l*=* | --libdir=*) libdir=`echo $1 | sed 's/.*=//'`; shift ;;\n    --sharedlibdir=*) sharedlibdir=`echo $1 | sed 's/.*=//'`; shift ;;\n    -i*=* | --includedir=*) includedir=`echo $1 | sed 's/.*=//'`;shift ;;\n    -u*=* | --uname=*) uname=`echo $1 | sed 's/.*=//'`;shift ;;\n    -p* | --prefix) prefix=\"$2\"; shift; shift ;;\n    -e* | --eprefix) exec_prefix=\"$2\"; shift; shift ;;\n    -l* | --libdir) libdir=\"$2\"; shift; shift ;;\n    -i* | --includedir) includedir=\"$2\"; shift; shift ;;\n    -s* | --shared | --enable-shared) shared=1; shift ;;\n    -t | --static) shared=0; shift ;;\n    --solo) solo=1; shift ;;\n    --cover) cover=1; shift ;;\n    -z* | --zprefix) zprefix=1; shift ;;\n    -6* | --64) build64=1; shift ;;\n    -a*=* | --archs=*) ARCHS=`echo $1 | sed 's/.*=//'`; shift ;;\n    --sysconfdir=*) echo \"ignored option: --sysconfdir\" | tee -a configure.log; shift ;;\n    --localstatedir=*) echo \"ignored option: --localstatedir\" | tee -a configure.log; shift ;;\n    -c* | --const) zconst=1; shift ;;\n    -w* | --warn) warn=1; shift ;;\n    -d* | --debug) debug=1; shift ;;\n    --sanitize) address=1; shift ;;\n    --address) address=1; shift ;;\n    --memory) memory=1; shift ;;\n    *) unknown=1; echo \"unknown option ignored: $1\" | tee -a configure.log; shift;;\n    esac\ndone\nif test $unknown -eq 1; then\n  echo \"$0 --help for help\" | tee -a configure.log\nfi\n\n# temporary file name\ntest=ztest$$\n\n# put arguments in log, also put test file in log if used in arguments\nshow()\n{\n  case \"$*\" in\n    *$test.c*)\n      echo === $test.c === >> configure.log\n      cat $test.c >> configure.log\n      echo === >> configure.log;;\n  esac\n  echo $* >> configure.log\n}\n\n# check for gcc vs. cc and set compile and link flags based on the system identified by uname\ncat > $test.c <<EOF\nextern int getchar();\nint hello() {return getchar();}\nEOF\n\nif test -z \"$CC\"; then\n  echo Checking for ${CROSS_PREFIX}gcc... | tee -a configure.log\n  if ${CROSS_PREFIX}gcc -v >/dev/null 2>&1; then\n    cc=${CROSS_PREFIX}gcc\n  else\n    cc=${CROSS_PREFIX}cc\n  fi\nelse\n  cc=${CC}\nfi\n\ncase \"$cc\" in\n  *gcc*) gcc=1 ;;\n  *clang*) gcc=1 ;;\nesac\ncase `$cc -v 2>&1` in\n  *gcc*) gcc=1 ;;\n  *clang*) gcc=1 ;;\nesac\n\nshow $cc -c $test.c\nif test \"$gcc\" -eq 1 && ($cc -c $test.c) >> configure.log 2>&1; then\n  echo ... using gcc >> configure.log\n  CC=\"$cc\"\n  CFLAGS=\"${CFLAGS--O3} -fPIC\"\n  SFLAGS=\"${CFLAGS--O3}\"\n  if test \"$ARCHS\"; then\n    CFLAGS=\"${CFLAGS} ${ARCHS}\"\n    LDFLAGS=\"${LDFLAGS} ${ARCHS}\"\n  fi\n  if test $build64 -eq 1; then\n    CFLAGS=\"${CFLAGS} -m64\"\n    SFLAGS=\"${SFLAGS} -m64\"\n  fi\n  if test \"$warn\" -eq 1; then\n    if test \"$zconst\" -eq 1; then\n      CFLAGS=\"${CFLAGS} -Wall -Wextra -Wcast-qual -DZLIB_CONST\"\n    else\n      CFLAGS=\"${CFLAGS} -Wall -Wextra\"\n    fi\n  fi\n  if test $address -eq 1; then\n    CFLAGS=\"${CFLAGS} -g -fsanitize=address -fno-omit-frame-pointer\"\n  fi\n  if test $memory -eq 1; then\n    CFLAGS=\"${CFLAGS} -g -fsanitize=memory -fno-omit-frame-pointer\"\n  fi\n  if test $debug -eq 1; then\n    CFLAGS=\"${CFLAGS} -DZLIB_DEBUG\"\n    SFLAGS=\"${SFLAGS} -DZLIB_DEBUG\"\n  fi\n  if test -z \"$uname\"; then\n    uname=`(uname -s || echo unknown) 2>/dev/null`\n  fi\n  case \"$uname\" in\n  Linux* | linux* | *-linux* | GNU | GNU/* | solaris* | Haiku)\n        case \"$mname\" in\n        *sparc*)\n            LDFLAGS=\"${LDFLAGS} -Wl,--no-warn-rwx-segments\" ;;\n        esac\n        LDSHARED=${LDSHARED-\"$cc -shared -Wl,-soname,libz.so.1,--version-script,${SRCDIR}zlib.map\"} ;;\n  *BSD | *bsd* | DragonFly)\n        LDSHARED=${LDSHARED-\"$cc -shared -Wl,-soname,libz.so.1,--version-script,${SRCDIR}zlib.map\"}\n        LDCONFIG=\"ldconfig -m\" ;;\n  CYGWIN* | Cygwin* | cygwin* | *-cygwin* | OS/2*)\n        EXE='.exe' ;;\n  MINGW* | mingw* | *-mingw*)\n        rm -f $test.[co] $test $test$shared_ext\n        echo \"If this doesn't work for you, try win32/Makefile.gcc.\" | tee -a configure.log\n        LDSHARED=${LDSHARED-\"$cc -shared\"}\n        LDSHAREDLIBC=\"\"\n        EXE='.exe' ;;\n  QNX*) # This is for QNX6. I suppose that the QNX rule below is for QNX2,QNX4\n        # (alain.bonnefoy@icbt.com)\n        LDSHARED=${LDSHARED-\"$cc -shared -Wl,-hlibz.so.1\"} ;;\n  HP-UX*)\n        LDSHARED=${LDSHARED-\"$cc -shared $SFLAGS\"}\n        case `(uname -m || echo unknown) 2>/dev/null` in\n        ia64)\n            shared_ext='.so'\n            SHAREDLIB='libz.so' ;;\n        *)\n            shared_ext='.sl'\n            SHAREDLIB='libz.sl' ;;\n        esac ;;\n  AIX*)\n        LDSHARED=${LDSHARED-\"$cc -shared\"}\n        LDFLAGS=\"${LDFLAGS} -Wl,-brtl\" ;;\n  Darwin* | darwin* | *-darwin*)\n        shared_ext='.dylib'\n        SHAREDLIB=libz$shared_ext\n        SHAREDLIBV=libz.$VER$shared_ext\n        SHAREDLIBM=libz.$VER1$shared_ext\n        LDSHARED=${LDSHARED-\"$cc -dynamiclib -install_name $libdir/$SHAREDLIBM -compatibility_version $VER1 -current_version $VER3\"}\n        if \"${CROSS_PREFIX}libtool\" -V 2>&1 | grep Apple > /dev/null; then\n            AR=\"${CROSS_PREFIX}libtool\"\n        elif libtool -V 2>&1 | grep Apple > /dev/null; then\n            AR=\"libtool\"\n        else\n            AR=\"/usr/bin/libtool\"\n        fi\n        ARFLAGS=\"-o\" ;;\n  *)\n        LDSHARED=${LDSHARED-\"$cc -shared\"} ;;\n  esac\nelse\n  # find system name and corresponding cc options\n  CC=${CC-cc}\n  gcc=0\n  echo ... using $CC >> configure.log\n  if test -z \"$uname\"; then\n    uname=`(uname -sr || echo unknown) 2>/dev/null`\n  fi\n  case \"$uname\" in\n  HP-UX*)    SFLAGS=${CFLAGS-\"-O +z\"}\n             CFLAGS=${CFLAGS-\"-O\"}\n#            LDSHARED=${LDSHARED-\"ld -b +vnocompatwarnings\"}\n             LDSHARED=${LDSHARED-\"ld -b\"}\n         case `(uname -m || echo unknown) 2>/dev/null` in\n         ia64)\n             shared_ext='.so'\n             SHAREDLIB='libz.so' ;;\n         *)\n             shared_ext='.sl'\n             SHAREDLIB='libz.sl' ;;\n         esac ;;\n  IRIX*)     SFLAGS=${CFLAGS-\"-ansi -O2 -rpath .\"}\n             CFLAGS=${CFLAGS-\"-ansi -O2\"}\n             LDSHARED=${LDSHARED-\"cc -shared -Wl,-soname,libz.so.1\"} ;;\n  OSF1\\ V4*) SFLAGS=${CFLAGS-\"-O -std1\"}\n             CFLAGS=${CFLAGS-\"-O -std1\"}\n             LDFLAGS=\"${LDFLAGS} -Wl,-rpath,.\"\n             LDSHARED=${LDSHARED-\"cc -shared  -Wl,-soname,libz.so -Wl,-msym -Wl,-rpath,$(libdir) -Wl,-set_version,${VER}:1.0\"} ;;\n  OSF1*)     SFLAGS=${CFLAGS-\"-O -std1\"}\n             CFLAGS=${CFLAGS-\"-O -std1\"}\n             LDSHARED=${LDSHARED-\"cc -shared -Wl,-soname,libz.so.1\"} ;;\n  QNX*)      SFLAGS=${CFLAGS-\"-4 -O\"}\n             CFLAGS=${CFLAGS-\"-4 -O\"}\n             LDSHARED=${LDSHARED-\"cc\"}\n             RANLIB=${RANLIB-\"true\"}\n             AR=\"cc\"\n             ARFLAGS=\"-A\" ;;\n  SCO_SV\\ 3.2*) SFLAGS=${CFLAGS-\"-O3 -dy -KPIC \"}\n             CFLAGS=${CFLAGS-\"-O3\"}\n             LDSHARED=${LDSHARED-\"cc -dy -KPIC -G\"} ;;\n  SunOS\\ 5* | solaris*)\n         LDSHARED=${LDSHARED-\"cc -G -h libz$shared_ext.$VER1\"}\n         SFLAGS=${CFLAGS-\"-fast -KPIC\"}\n         CFLAGS=${CFLAGS-\"-fast\"}\n         if test $build64 -eq 1; then\n             # old versions of SunPRO/Workshop/Studio don't support -m64,\n             # but newer ones do.  Check for it.\n             flag64=`$CC -flags | egrep -- '^-m64'`\n             if test x\"$flag64\" != x\"\" ; then\n                 CFLAGS=\"${CFLAGS} -m64\"\n                 SFLAGS=\"${SFLAGS} -m64\"\n             else\n                 case `(uname -m || echo unknown) 2>/dev/null` in\n                   i86*)\n                     SFLAGS=\"$SFLAGS -xarch=amd64\"\n                     CFLAGS=\"$CFLAGS -xarch=amd64\" ;;\n                   *)\n                     SFLAGS=\"$SFLAGS -xarch=v9\"\n                     CFLAGS=\"$CFLAGS -xarch=v9\" ;;\n                 esac\n             fi\n         fi\n         if test -n \"$ZINC\"; then\n             ZINC='-I- -I. -I$(SRCDIR)'\n         fi\n         ;;\n  SunOS\\ 4*) SFLAGS=${CFLAGS-\"-O2 -PIC\"}\n             CFLAGS=${CFLAGS-\"-O2\"}\n             LDSHARED=${LDSHARED-\"ld\"} ;;\n  SunStudio\\ 9*) SFLAGS=${CFLAGS-\"-fast -xcode=pic32 -xtarget=ultra3 -xarch=v9b\"}\n             CFLAGS=${CFLAGS-\"-fast -xtarget=ultra3 -xarch=v9b\"}\n             LDSHARED=${LDSHARED-\"cc -xarch=v9b\"} ;;\n  UNIX_System_V\\ 4.2.0)\n             SFLAGS=${CFLAGS-\"-KPIC -O\"}\n             CFLAGS=${CFLAGS-\"-O\"}\n             LDSHARED=${LDSHARED-\"cc -G\"} ;;\n  UNIX_SV\\ 4.2MP)\n             SFLAGS=${CFLAGS-\"-Kconform_pic -O\"}\n             CFLAGS=${CFLAGS-\"-O\"}\n             LDSHARED=${LDSHARED-\"cc -G\"} ;;\n  OpenUNIX\\ 5)\n             SFLAGS=${CFLAGS-\"-KPIC -O\"}\n             CFLAGS=${CFLAGS-\"-O\"}\n             LDSHARED=${LDSHARED-\"cc -G\"} ;;\n  AIX*)  # Courtesy of dbakker@arrayasolutions.com\n             SFLAGS=${CFLAGS-\"-O -qmaxmem=8192\"}\n             CFLAGS=${CFLAGS-\"-O -qmaxmem=8192\"}\n             LDSHARED=${LDSHARED-\"xlc -G\"} ;;\n  # send working options for other systems to zlib@gzip.org\n  *)         SFLAGS=${CFLAGS-\"-O\"}\n             CFLAGS=${CFLAGS-\"-O\"}\n             LDSHARED=${LDSHARED-\"cc -shared\"} ;;\n  esac\nfi\n\n# destination names for shared library if not defined above\nSHAREDLIB=${SHAREDLIB-\"libz$shared_ext\"}\nSHAREDLIBV=${SHAREDLIBV-\"libz$shared_ext.$VER\"}\nSHAREDLIBM=${SHAREDLIBM-\"libz$shared_ext.$VER1\"}\n\necho >> configure.log\n\n# define functions for testing compiler and library characteristics and logging the results\n\ncat > $test.c <<EOF\n#error error\nEOF\nif ($CC -c $CFLAGS $test.c) 2>/dev/null; then\n  try()\n  {\n    show $*\n    test \"`( $* ) 2>&1 | tee -a configure.log`\" = \"\"\n  }\n  echo - using any output from compiler to indicate an error >> configure.log\nelse\n  try()\n  {\n    show $*\n    got=`( $* ) 2>&1`\n    ret=$?\n    if test \"$got\" != \"\"; then\n      printf \"%s\\n\" \"$got\" >> configure.log\n    fi\n    if test $ret -ne 0; then\n      echo \"(exit code \"$ret\")\" >> configure.log\n    fi\n    return $ret\n  }\nfi\n\ntryboth()\n{\n  show $*\n  got=`( $* ) 2>&1`\n  ret=$?\n  if test \"$got\" != \"\"; then\n    printf \"%s\\n\" \"$got\" >> configure.log\n  fi\n  if test $ret -ne 0; then\n    echo \"(exit code \"$ret\")\" >> configure.log\n    return $ret\n  fi\n  test \"$got\" = \"\"\n}\n\ncat > $test.c << EOF\nint foo() { return 0; }\nEOF\necho \"Checking for obsessive-compulsive compiler options...\" >> configure.log\nif try $CC -c $CFLAGS $test.c; then\n  :\nelse\n  echo \"Compiler error reporting is too harsh for $0 (perhaps remove -Werror).\" | tee -a configure.log\n  leave 1\nfi\n\necho >> configure.log\n\n# see if shared library build supported\ncat > $test.c <<EOF\nextern int getchar();\nint hello() {return getchar();}\nEOF\nif test $shared -eq 1; then\n  echo Checking for shared library support... | tee -a configure.log\n  # we must test in two steps (cc then ld), required at least on SunOS 4.x\n  if try $CC -c $SFLAGS $test.c &&\n     try $LDSHARED $SFLAGS -o $test$shared_ext $test.o; then\n    echo Building shared library $SHAREDLIBV with $CC. | tee -a configure.log\n  elif test -z \"$old_cc\" -a -z \"$old_cflags\"; then\n    echo No shared library support. | tee -a configure.log\n    shared=0;\n  else\n    echo 'No shared library support; try without defining CC and CFLAGS' | tee -a configure.log\n    shared=0;\n  fi\nfi\nif test $shared -eq 0; then\n  LDSHARED=\"$CC\"\n  ALL=\"static\"\n  TEST=\"all teststatic\"\n  SHAREDLIB=\"\"\n  SHAREDLIBV=\"\"\n  SHAREDLIBM=\"\"\n  echo Building static library $STATICLIB version $VER with $CC. | tee -a configure.log\nelse\n  ALL=\"static shared\"\n  TEST=\"all teststatic testshared\"\nfi\n\necho >> configure.log\n\n# check for size_t\ncat > $test.c <<EOF\n#include <stdio.h>\n#include <stdlib.h>\nsize_t dummy = 0;\nEOF\nif try $CC -c $CFLAGS $test.c; then\n  echo \"Checking for size_t... Yes.\" | tee -a configure.log\nelse\n  echo \"Checking for size_t... No.\" | tee -a configure.log\n  # find a size_t integer type\n  # check for long long\n  cat > $test.c << EOF\nlong long dummy = 0;\nEOF\n  if try $CC -c $CFLAGS $test.c; then\n    echo \"Checking for long long... Yes.\" | tee -a configure.log\n    cat > $test.c <<EOF\n#include <stdio.h>\nint main(void) {\n    if (sizeof(void *) <= sizeof(int)) puts(\"int\");\n    else if (sizeof(void *) <= sizeof(long)) puts(\"long\");\n    else puts(\"z_longlong\");\n    return 0;\n}\nEOF\n  else\n    echo \"Checking for long long... No.\" | tee -a configure.log\n    cat > $test.c <<EOF\n#include <stdio.h>\nint main(void) {\n    if (sizeof(void *) <= sizeof(int)) puts(\"int\");\n    else puts(\"long\");\n    return 0;\n}\nEOF\n  fi\n  if try $CC $CFLAGS -o $test $test.c; then\n    sizet=`./$test`\n    echo \"Checking for a pointer-size integer type...\" $sizet\".\" | tee -a configure.log\n    CFLAGS=\"${CFLAGS} -DNO_SIZE_T=${sizet}\"\n    SFLAGS=\"${SFLAGS} -DNO_SIZE_T=${sizet}\"\n  else\n    echo \"Checking for a pointer-size integer type... not found.\" | tee -a configure.log\n  fi\nfi\n\necho >> configure.log\n\n# check for large file support, and if none, check for fseeko()\ncat > $test.c <<EOF\n#include <sys/types.h>\noff64_t dummy = 0;\nEOF\nif try $CC -c $CFLAGS -D_LARGEFILE64_SOURCE=1 $test.c; then\n  CFLAGS=\"${CFLAGS} -D_LARGEFILE64_SOURCE=1\"\n  SFLAGS=\"${SFLAGS} -D_LARGEFILE64_SOURCE=1\"\n  ALL=\"${ALL} all64\"\n  TEST=\"${TEST} test64\"\n  echo \"Checking for off64_t... Yes.\" | tee -a configure.log\n  echo \"Checking for fseeko... Yes.\" | tee -a configure.log\nelse\n  echo \"Checking for off64_t... No.\" | tee -a configure.log\n  echo >> configure.log\n  cat > $test.c <<EOF\n#include <stdio.h>\nint main(void) {\n  fseeko(NULL, 0, 0);\n  return 0;\n}\nEOF\n  if try $CC $CFLAGS -o $test $test.c; then\n    echo \"Checking for fseeko... Yes.\" | tee -a configure.log\n  else\n    CFLAGS=\"${CFLAGS} -DNO_FSEEKO\"\n    SFLAGS=\"${SFLAGS} -DNO_FSEEKO\"\n    echo \"Checking for fseeko... No.\" | tee -a configure.log\n  fi\nfi\n\necho >> configure.log\n\n# check for strerror() for use by gz* functions\ncat > $test.c <<EOF\n#include <string.h>\n#include <errno.h>\nint main() { return strlen(strerror(errno)); }\nEOF\nif try $CC $CFLAGS -o $test $test.c; then\n  echo \"Checking for strerror... Yes.\" | tee -a configure.log\nelse\n  CFLAGS=\"${CFLAGS} -DNO_STRERROR\"\n  SFLAGS=\"${SFLAGS} -DNO_STRERROR\"\n  echo \"Checking for strerror... No.\" | tee -a configure.log\nfi\n\n# copy clean zconf.h for subsequent edits\ncp -p ${SRCDIR}zconf.h.in zconf.h\n\necho >> configure.log\n\n# check for unistd.h and save result in zconf.h\ncat > $test.c <<EOF\n#include <unistd.h>\nint main() { return 0; }\nEOF\nif try $CC -c $CFLAGS $test.c; then\n  sed < zconf.h \"/^#ifdef HAVE_UNISTD_H.* may be/s/def HAVE_UNISTD_H\\(.*\\) may be/ 1\\1 was/\" > zconf.temp.h\n  mv zconf.temp.h zconf.h\n  echo \"Checking for unistd.h... Yes.\" | tee -a configure.log\nelse\n  echo \"Checking for unistd.h... No.\" | tee -a configure.log\nfi\n\necho >> configure.log\n\n# check for stdarg.h and save result in zconf.h\ncat > $test.c <<EOF\n#include <stdarg.h>\nint main() { return 0; }\nEOF\nif try $CC -c $CFLAGS $test.c; then\n  sed < zconf.h \"/^#ifdef HAVE_STDARG_H.* may be/s/def HAVE_STDARG_H\\(.*\\) may be/ 1\\1 was/\" > zconf.temp.h\n  mv zconf.temp.h zconf.h\n  echo \"Checking for stdarg.h... Yes.\" | tee -a configure.log\nelse\n  echo \"Checking for stdarg.h... No.\" | tee -a configure.log\nfi\n\n# if the z_ prefix was requested, save that in zconf.h\nif test $zprefix -eq 1; then\n  sed < zconf.h \"/#ifdef Z_PREFIX.* may be/s/def Z_PREFIX\\(.*\\) may be/ 1\\1 was/\" > zconf.temp.h\n  mv zconf.temp.h zconf.h\n  echo >> configure.log\n  echo \"Using z_ prefix on all symbols.\" | tee -a configure.log\nfi\n\n# if --solo compilation was requested, save that in zconf.h and remove gz stuff from object lists\nif test $solo -eq 1; then\n  sed '/#define ZCONF_H/a\\\n#define Z_SOLO\n\n' < zconf.h > zconf.temp.h\n  mv zconf.temp.h zconf.h\nOBJC='$(OBJZ)'\nPIC_OBJC='$(PIC_OBJZ)'\nfi\n\n# if code coverage testing was requested, use older gcc if defined, e.g. \"gcc-4.2\" on Mac OS X\nif test $cover -eq 1; then\n  CFLAGS=\"${CFLAGS} -fprofile-arcs -ftest-coverage\"\n  if test -n \"$GCC_CLASSIC\"; then\n    CC=$GCC_CLASSIC\n  fi\nfi\n\necho >> configure.log\n\n# conduct a series of tests to resolve eight possible cases of using \"vs\" or \"s\" printf functions\n# (using stdarg or not), with or without \"n\" (proving size of buffer), and with or without a\n# return value.  The most secure result is vsnprintf() with a return value.  snprintf() with a\n# return value is secure as well, but then gzprintf() will be limited to 20 arguments.\ncat > $test.c <<EOF\n#include <stdio.h>\n#include <stdarg.h>\n#include \"zconf.h\"\nint main()\n{\n#ifndef STDC\n  choke me\n#endif\n  return 0;\n}\nEOF\nif try $CC -c $CFLAGS $test.c; then\n  echo \"Checking whether to use vs[n]printf() or s[n]printf()... using vs[n]printf().\" | tee -a configure.log\n\n  echo >> configure.log\n  cat > $test.c <<EOF\n#include <stdio.h>\n#include <stdarg.h>\nint mytest(const char *fmt, ...)\n{\n  char buf[20];\n  va_list ap;\n  va_start(ap, fmt);\n  vsnprintf(buf, sizeof(buf), fmt, ap);\n  va_end(ap);\n  return 0;\n}\nint main()\n{\n  return (mytest(\"Hello%d\\n\", 1));\n}\nEOF\n  if try $CC $CFLAGS -o $test $test.c; then\n    echo \"Checking for vsnprintf() in stdio.h... Yes.\" | tee -a configure.log\n\n    echo >> configure.log\n    cat >$test.c <<EOF\n#include <stdio.h>\n#include <stdarg.h>\nint mytest(const char *fmt, ...)\n{\n  int n;\n  char buf[20];\n  va_list ap;\n  va_start(ap, fmt);\n  n = vsnprintf(buf, sizeof(buf), fmt, ap);\n  va_end(ap);\n  return n;\n}\nint main()\n{\n  return (mytest(\"Hello%d\\n\", 1));\n}\nEOF\n\n    if try $CC -c $CFLAGS $test.c; then\n      echo \"Checking for return value of vsnprintf()... Yes.\" | tee -a configure.log\n    else\n      CFLAGS=\"$CFLAGS -DHAS_vsnprintf_void\"\n      SFLAGS=\"$SFLAGS -DHAS_vsnprintf_void\"\n      echo \"Checking for return value of vsnprintf()... No.\" | tee -a configure.log\n      echo \"  WARNING: apparently vsnprintf() does not return a value. zlib\" | tee -a configure.log\n      echo \"  can build but will be open to possible string-format security\" | tee -a configure.log\n      echo \"  vulnerabilities.\" | tee -a configure.log\n    fi\n  else\n    CFLAGS=\"$CFLAGS -DNO_vsnprintf\"\n    SFLAGS=\"$SFLAGS -DNO_vsnprintf\"\n    echo \"Checking for vsnprintf() in stdio.h... No.\" | tee -a configure.log\n    echo \"  WARNING: vsnprintf() not found, falling back to vsprintf(). zlib\" | tee -a configure.log\n    echo \"  can build but will be open to possible buffer-overflow security\" | tee -a configure.log\n    echo \"  vulnerabilities.\" | tee -a configure.log\n\n    echo >> configure.log\n    cat >$test.c <<EOF\n#include <stdio.h>\n#include <stdarg.h>\nint mytest(const char *fmt, ...)\n{\n  int n;\n  char buf[20];\n  va_list ap;\n  va_start(ap, fmt);\n  n = vsprintf(buf, fmt, ap);\n  va_end(ap);\n  return n;\n}\nint main()\n{\n  return (mytest(\"Hello%d\\n\", 1));\n}\nEOF\n\n    if try $CC -c $CFLAGS $test.c; then\n      echo \"Checking for return value of vsprintf()... Yes.\" | tee -a configure.log\n    else\n      CFLAGS=\"$CFLAGS -DHAS_vsprintf_void\"\n      SFLAGS=\"$SFLAGS -DHAS_vsprintf_void\"\n      echo \"Checking for return value of vsprintf()... No.\" | tee -a configure.log\n      echo \"  WARNING: apparently vsprintf() does not return a value. zlib\" | tee -a configure.log\n      echo \"  can build but will be open to possible string-format security\" | tee -a configure.log\n      echo \"  vulnerabilities.\" | tee -a configure.log\n    fi\n  fi\nelse\n  echo \"Checking whether to use vs[n]printf() or s[n]printf()... using s[n]printf().\" | tee -a configure.log\n\n  echo >> configure.log\n  cat >$test.c <<EOF\n#include <stdio.h>\nint mytest()\n{\n  char buf[20];\n  snprintf(buf, sizeof(buf), \"%s\", \"foo\");\n  return 0;\n}\nint main()\n{\n  return (mytest());\n}\nEOF\n\n  if try $CC $CFLAGS -o $test $test.c; then\n    echo \"Checking for snprintf() in stdio.h... Yes.\" | tee -a configure.log\n\n    echo >> configure.log\n    cat >$test.c <<EOF\n#include <stdio.h>\nint mytest()\n{\n  char buf[20];\n  return snprintf(buf, sizeof(buf), \"%s\", \"foo\");\n}\nint main()\n{\n  return (mytest());\n}\nEOF\n\n    if try $CC -c $CFLAGS $test.c; then\n      echo \"Checking for return value of snprintf()... Yes.\" | tee -a configure.log\n    else\n      CFLAGS=\"$CFLAGS -DHAS_snprintf_void\"\n      SFLAGS=\"$SFLAGS -DHAS_snprintf_void\"\n      echo \"Checking for return value of snprintf()... No.\" | tee -a configure.log\n      echo \"  WARNING: apparently snprintf() does not return a value. zlib\" | tee -a configure.log\n      echo \"  can build but will be open to possible string-format security\" | tee -a configure.log\n      echo \"  vulnerabilities.\" | tee -a configure.log\n    fi\n  else\n    CFLAGS=\"$CFLAGS -DNO_snprintf\"\n    SFLAGS=\"$SFLAGS -DNO_snprintf\"\n    echo \"Checking for snprintf() in stdio.h... No.\" | tee -a configure.log\n    echo \"  WARNING: snprintf() not found, falling back to sprintf(). zlib\" | tee -a configure.log\n    echo \"  can build but will be open to possible buffer-overflow security\" | tee -a configure.log\n    echo \"  vulnerabilities.\" | tee -a configure.log\n\n    echo >> configure.log\n    cat >$test.c <<EOF\n#include <stdio.h>\nint mytest()\n{\n  char buf[20];\n  return sprintf(buf, \"%s\", \"foo\");\n}\nint main()\n{\n  return (mytest());\n}\nEOF\n\n    if try $CC -c $CFLAGS $test.c; then\n      echo \"Checking for return value of sprintf()... Yes.\" | tee -a configure.log\n    else\n      CFLAGS=\"$CFLAGS -DHAS_sprintf_void\"\n      SFLAGS=\"$SFLAGS -DHAS_sprintf_void\"\n      echo \"Checking for return value of sprintf()... No.\" | tee -a configure.log\n      echo \"  WARNING: apparently sprintf() does not return a value. zlib\" | tee -a configure.log\n      echo \"  can build but will be open to possible string-format security\" | tee -a configure.log\n      echo \"  vulnerabilities.\" | tee -a configure.log\n    fi\n  fi\nfi\n\n# see if we can hide zlib internal symbols that are linked between separate source files\nif test \"$gcc\" -eq 1; then\n  echo >> configure.log\n  cat > $test.c <<EOF\n#define ZLIB_INTERNAL __attribute__((visibility (\"hidden\")))\nint ZLIB_INTERNAL foo;\nint main()\n{\n  return 0;\n}\nEOF\n  if tryboth $CC -c $CFLAGS $test.c; then\n    CFLAGS=\"$CFLAGS -DHAVE_HIDDEN\"\n    SFLAGS=\"$SFLAGS -DHAVE_HIDDEN\"\n    echo \"Checking for attribute(visibility) support... Yes.\" | tee -a configure.log\n  else\n    echo \"Checking for attribute(visibility) support... No.\" | tee -a configure.log\n  fi\nfi\n\n# show the results in the log\necho >> configure.log\necho ALL = $ALL >> configure.log\necho AR = $AR >> configure.log\necho ARFLAGS = $ARFLAGS >> configure.log\necho CC = $CC >> configure.log\necho CFLAGS = $CFLAGS >> configure.log\necho CPP = $CPP >> configure.log\necho EXE = $EXE >> configure.log\necho LDCONFIG = $LDCONFIG >> configure.log\necho LDFLAGS = $LDFLAGS >> configure.log\necho LDSHARED = $LDSHARED >> configure.log\necho LDSHAREDLIBC = $LDSHAREDLIBC >> configure.log\necho OBJC = $OBJC >> configure.log\necho PIC_OBJC = $PIC_OBJC >> configure.log\necho RANLIB = $RANLIB >> configure.log\necho SFLAGS = $SFLAGS >> configure.log\necho SHAREDLIB = $SHAREDLIB >> configure.log\necho SHAREDLIBM = $SHAREDLIBM >> configure.log\necho SHAREDLIBV = $SHAREDLIBV >> configure.log\necho STATICLIB = $STATICLIB >> configure.log\necho TEST = $TEST >> configure.log\necho VER = $VER >> configure.log\necho SRCDIR = $SRCDIR >> configure.log\necho exec_prefix = $exec_prefix >> configure.log\necho includedir = $includedir >> configure.log\necho libdir = $libdir >> configure.log\necho mandir = $mandir >> configure.log\necho prefix = $prefix >> configure.log\necho sharedlibdir = $sharedlibdir >> configure.log\necho uname = $uname >> configure.log\n\n# update Makefile with the configure results\nsed < ${SRCDIR}Makefile.in \"\n/^CC *=/s#=.*#=$CC#\n/^CFLAGS *=/s#=.*#=$CFLAGS#\n/^SFLAGS *=/s#=.*#=$SFLAGS#\n/^LDFLAGS *=/s#=.*#=$LDFLAGS#\n/^LDSHARED *=/s#=.*#=$LDSHARED#\n/^CPP *=/s#=.*#=$CPP#\n/^STATICLIB *=/s#=.*#=$STATICLIB#\n/^SHAREDLIB *=/s#=.*#=$SHAREDLIB#\n/^SHAREDLIBV *=/s#=.*#=$SHAREDLIBV#\n/^SHAREDLIBM *=/s#=.*#=$SHAREDLIBM#\n/^AR *=/s#=.*#=$AR#\n/^ARFLAGS *=/s#=.*#=$ARFLAGS#\n/^RANLIB *=/s#=.*#=$RANLIB#\n/^LDCONFIG *=/s#=.*#=$LDCONFIG#\n/^LDSHAREDLIBC *=/s#=.*#=$LDSHAREDLIBC#\n/^EXE *=/s#=.*#=$EXE#\n/^SRCDIR *=/s#=.*#=$SRCDIR#\n/^ZINC *=/s#=.*#=$ZINC#\n/^ZINCOUT *=/s#=.*#=$ZINCOUT#\n/^prefix *=/s#=.*#=$prefix#\n/^exec_prefix *=/s#=.*#=$exec_prefix#\n/^libdir *=/s#=.*#=$libdir#\n/^sharedlibdir *=/s#=.*#=$sharedlibdir#\n/^includedir *=/s#=.*#=$includedir#\n/^mandir *=/s#=.*#=$mandir#\n/^OBJC *=/s#=.*#= $OBJC#\n/^PIC_OBJC *=/s#=.*#= $PIC_OBJC#\n/^all: */s#:.*#: $ALL#\n/^test: */s#:.*#: $TEST#\n\" > Makefile\n\n# create zlib.pc with the configure results\nsed < ${SRCDIR}zlib.pc.in \"\n/^CC *=/s#=.*#=$CC#\n/^CFLAGS *=/s#=.*#=$CFLAGS#\n/^CPP *=/s#=.*#=$CPP#\n/^LDSHARED *=/s#=.*#=$LDSHARED#\n/^STATICLIB *=/s#=.*#=$STATICLIB#\n/^SHAREDLIB *=/s#=.*#=$SHAREDLIB#\n/^SHAREDLIBV *=/s#=.*#=$SHAREDLIBV#\n/^SHAREDLIBM *=/s#=.*#=$SHAREDLIBM#\n/^AR *=/s#=.*#=$AR#\n/^ARFLAGS *=/s#=.*#=$ARFLAGS#\n/^RANLIB *=/s#=.*#=$RANLIB#\n/^EXE *=/s#=.*#=$EXE#\n/^prefix *=/s#=.*#=$prefix#\n/^exec_prefix *=/s#=.*#=$exec_prefix#\n/^libdir *=/s#=.*#=$libdir#\n/^sharedlibdir *=/s#=.*#=$sharedlibdir#\n/^includedir *=/s#=.*#=$includedir#\n/^mandir *=/s#=.*#=$mandir#\n/^LDFLAGS *=/s#=.*#=$LDFLAGS#\n\" | sed -e \"\ns/\\@VERSION\\@/$VER/g;\n\" > zlib.pc\n\n# done\nleave 0\n"
        },
        {
          "name": "contrib",
          "type": "tree",
          "content": null
        },
        {
          "name": "crc32.c",
          "type": "blob",
          "size": 30.8642578125,
          "content": "/* crc32.c -- compute the CRC-32 of a data stream\n * Copyright (C) 1995-2022 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n *\n * This interleaved implementation of a CRC makes use of pipelined multiple\n * arithmetic-logic units, commonly found in modern CPU cores. It is due to\n * Kadatch and Jenkins (2010). See doc/crc-doc.1.0.pdf in this distribution.\n */\n\n/* @(#) $Id$ */\n\n/*\n  Note on the use of DYNAMIC_CRC_TABLE: there is no mutex or semaphore\n  protection on the static variables used to control the first-use generation\n  of the crc tables. Therefore, if you #define DYNAMIC_CRC_TABLE, you should\n  first call get_crc_table() to initialize the tables before allowing more than\n  one thread to use crc32().\n\n  MAKECRCH can be #defined to write out crc32.h. A main() routine is also\n  produced, so that this one source file can be compiled to an executable.\n */\n\n#ifdef MAKECRCH\n#  include <stdio.h>\n#  ifndef DYNAMIC_CRC_TABLE\n#    define DYNAMIC_CRC_TABLE\n#  endif /* !DYNAMIC_CRC_TABLE */\n#endif /* MAKECRCH */\n\n#include \"zutil.h\"      /* for Z_U4, Z_U8, z_crc_t, and FAR definitions */\n\n /*\n  A CRC of a message is computed on N braids of words in the message, where\n  each word consists of W bytes (4 or 8). If N is 3, for example, then three\n  running sparse CRCs are calculated respectively on each braid, at these\n  indices in the array of words: 0, 3, 6, ..., 1, 4, 7, ..., and 2, 5, 8, ...\n  This is done starting at a word boundary, and continues until as many blocks\n  of N * W bytes as are available have been processed. The results are combined\n  into a single CRC at the end. For this code, N must be in the range 1..6 and\n  W must be 4 or 8. The upper limit on N can be increased if desired by adding\n  more #if blocks, extending the patterns apparent in the code. In addition,\n  crc32.h would need to be regenerated, if the maximum N value is increased.\n\n  N and W are chosen empirically by benchmarking the execution time on a given\n  processor. The choices for N and W below were based on testing on Intel Kaby\n  Lake i7, AMD Ryzen 7, ARM Cortex-A57, Sparc64-VII, PowerPC POWER9, and MIPS64\n  Octeon II processors. The Intel, AMD, and ARM processors were all fastest\n  with N=5, W=8. The Sparc, PowerPC, and MIPS64 were all fastest at N=5, W=4.\n  They were all tested with either gcc or clang, all using the -O3 optimization\n  level. Your mileage may vary.\n */\n\n/* Define N */\n#ifdef Z_TESTN\n#  define N Z_TESTN\n#else\n#  define N 5\n#endif\n#if N < 1 || N > 6\n#  error N must be in 1..6\n#endif\n\n/*\n  z_crc_t must be at least 32 bits. z_word_t must be at least as long as\n  z_crc_t. It is assumed here that z_word_t is either 32 bits or 64 bits, and\n  that bytes are eight bits.\n */\n\n/*\n  Define W and the associated z_word_t type. If W is not defined, then a\n  braided calculation is not used, and the associated tables and code are not\n  compiled.\n */\n#ifdef Z_TESTW\n#  if Z_TESTW-1 != -1\n#    define W Z_TESTW\n#  endif\n#else\n#  ifdef MAKECRCH\n#    define W 8         /* required for MAKECRCH */\n#  else\n#    if defined(__x86_64__) || defined(__aarch64__)\n#      define W 8\n#    else\n#      define W 4\n#    endif\n#  endif\n#endif\n#ifdef W\n#  if W == 8 && defined(Z_U8)\n     typedef Z_U8 z_word_t;\n#  elif defined(Z_U4)\n#    undef W\n#    define W 4\n     typedef Z_U4 z_word_t;\n#  else\n#    undef W\n#  endif\n#endif\n\n/* If available, use the ARM processor CRC32 instruction. */\n#if defined(__aarch64__) && defined(__ARM_FEATURE_CRC32) && W == 8\n#  define ARMCRC32\n#endif\n\n#if defined(W) && (!defined(ARMCRC32) || defined(DYNAMIC_CRC_TABLE))\n/*\n  Swap the bytes in a z_word_t to convert between little and big endian. Any\n  self-respecting compiler will optimize this to a single machine byte-swap\n  instruction, if one is available. This assumes that word_t is either 32 bits\n  or 64 bits.\n */\nlocal z_word_t byte_swap(z_word_t word) {\n#  if W == 8\n    return\n        (word & 0xff00000000000000) >> 56 |\n        (word & 0xff000000000000) >> 40 |\n        (word & 0xff0000000000) >> 24 |\n        (word & 0xff00000000) >> 8 |\n        (word & 0xff000000) << 8 |\n        (word & 0xff0000) << 24 |\n        (word & 0xff00) << 40 |\n        (word & 0xff) << 56;\n#  else   /* W == 4 */\n    return\n        (word & 0xff000000) >> 24 |\n        (word & 0xff0000) >> 8 |\n        (word & 0xff00) << 8 |\n        (word & 0xff) << 24;\n#  endif\n}\n#endif\n\n#ifdef DYNAMIC_CRC_TABLE\n/* =========================================================================\n * Table of powers of x for combining CRC-32s, filled in by make_crc_table()\n * below.\n */\n   local z_crc_t FAR x2n_table[32];\n#else\n/* =========================================================================\n * Tables for byte-wise and braided CRC-32 calculations, and a table of powers\n * of x for combining CRC-32s, all made by make_crc_table().\n */\n#  include \"crc32.h\"\n#endif\n\n/* CRC polynomial. */\n#define POLY 0xedb88320         /* p(x) reflected, with x^32 implied */\n\n/*\n  Return a(x) multiplied by b(x) modulo p(x), where p(x) is the CRC polynomial,\n  reflected. For speed, this requires that a not be zero.\n */\nlocal z_crc_t multmodp(z_crc_t a, z_crc_t b) {\n    z_crc_t m, p;\n\n    m = (z_crc_t)1 << 31;\n    p = 0;\n    for (;;) {\n        if (a & m) {\n            p ^= b;\n            if ((a & (m - 1)) == 0)\n                break;\n        }\n        m >>= 1;\n        b = b & 1 ? (b >> 1) ^ POLY : b >> 1;\n    }\n    return p;\n}\n\n/*\n  Return x^(n * 2^k) modulo p(x). Requires that x2n_table[] has been\n  initialized.\n */\nlocal z_crc_t x2nmodp(z_off64_t n, unsigned k) {\n    z_crc_t p;\n\n    p = (z_crc_t)1 << 31;           /* x^0 == 1 */\n    while (n) {\n        if (n & 1)\n            p = multmodp(x2n_table[k & 31], p);\n        n >>= 1;\n        k++;\n    }\n    return p;\n}\n\n#ifdef DYNAMIC_CRC_TABLE\n/* =========================================================================\n * Build the tables for byte-wise and braided CRC-32 calculations, and a table\n * of powers of x for combining CRC-32s.\n */\nlocal z_crc_t FAR crc_table[256];\n#ifdef W\n   local z_word_t FAR crc_big_table[256];\n   local z_crc_t FAR crc_braid_table[W][256];\n   local z_word_t FAR crc_braid_big_table[W][256];\n   local void braid(z_crc_t [][256], z_word_t [][256], int, int);\n#endif\n#ifdef MAKECRCH\n   local void write_table(FILE *, const z_crc_t FAR *, int);\n   local void write_table32hi(FILE *, const z_word_t FAR *, int);\n   local void write_table64(FILE *, const z_word_t FAR *, int);\n#endif /* MAKECRCH */\n\n/*\n  Define a once() function depending on the availability of atomics. If this is\n  compiled with DYNAMIC_CRC_TABLE defined, and if CRCs will be computed in\n  multiple threads, and if atomics are not available, then get_crc_table() must\n  be called to initialize the tables and must return before any threads are\n  allowed to compute or combine CRCs.\n */\n\n/* Definition of once functionality. */\ntypedef struct once_s once_t;\n\n/* Check for the availability of atomics. */\n#if defined(__STDC__) && __STDC_VERSION__ >= 201112L && \\\n    !defined(__STDC_NO_ATOMICS__)\n\n#include <stdatomic.h>\n\n/* Structure for once(), which must be initialized with ONCE_INIT. */\nstruct once_s {\n    atomic_flag begun;\n    atomic_int done;\n};\n#define ONCE_INIT {ATOMIC_FLAG_INIT, 0}\n\n/*\n  Run the provided init() function exactly once, even if multiple threads\n  invoke once() at the same time. The state must be a once_t initialized with\n  ONCE_INIT.\n */\nlocal void once(once_t *state, void (*init)(void)) {\n    if (!atomic_load(&state->done)) {\n        if (atomic_flag_test_and_set(&state->begun))\n            while (!atomic_load(&state->done))\n                ;\n        else {\n            init();\n            atomic_store(&state->done, 1);\n        }\n    }\n}\n\n#else   /* no atomics */\n\n/* Structure for once(), which must be initialized with ONCE_INIT. */\nstruct once_s {\n    volatile int begun;\n    volatile int done;\n};\n#define ONCE_INIT {0, 0}\n\n/* Test and set. Alas, not atomic, but tries to minimize the period of\n   vulnerability. */\nlocal int test_and_set(int volatile *flag) {\n    int was;\n\n    was = *flag;\n    *flag = 1;\n    return was;\n}\n\n/* Run the provided init() function once. This is not thread-safe. */\nlocal void once(once_t *state, void (*init)(void)) {\n    if (!state->done) {\n        if (test_and_set(&state->begun))\n            while (!state->done)\n                ;\n        else {\n            init();\n            state->done = 1;\n        }\n    }\n}\n\n#endif\n\n/* State for once(). */\nlocal once_t made = ONCE_INIT;\n\n/*\n  Generate tables for a byte-wise 32-bit CRC calculation on the polynomial:\n  x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.\n\n  Polynomials over GF(2) are represented in binary, one bit per coefficient,\n  with the lowest powers in the most significant bit. Then adding polynomials\n  is just exclusive-or, and multiplying a polynomial by x is a right shift by\n  one. If we call the above polynomial p, and represent a byte as the\n  polynomial q, also with the lowest power in the most significant bit (so the\n  byte 0xb1 is the polynomial x^7+x^3+x^2+1), then the CRC is (q*x^32) mod p,\n  where a mod b means the remainder after dividing a by b.\n\n  This calculation is done using the shift-register method of multiplying and\n  taking the remainder. The register is initialized to zero, and for each\n  incoming bit, x^32 is added mod p to the register if the bit is a one (where\n  x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by x\n  (which is shifting right by one and adding x^32 mod p if the bit shifted out\n  is a one). We start with the highest power (least significant bit) of q and\n  repeat for all eight bits of q.\n\n  The table is simply the CRC of all possible eight bit values. This is all the\n  information needed to generate CRCs on data a byte at a time for all\n  combinations of CRC register values and incoming bytes.\n */\n\nlocal void make_crc_table(void) {\n    unsigned i, j, n;\n    z_crc_t p;\n\n    /* initialize the CRC of bytes tables */\n    for (i = 0; i < 256; i++) {\n        p = i;\n        for (j = 0; j < 8; j++)\n            p = p & 1 ? (p >> 1) ^ POLY : p >> 1;\n        crc_table[i] = p;\n#ifdef W\n        crc_big_table[i] = byte_swap(p);\n#endif\n    }\n\n    /* initialize the x^2^n mod p(x) table */\n    p = (z_crc_t)1 << 30;         /* x^1 */\n    x2n_table[0] = p;\n    for (n = 1; n < 32; n++)\n        x2n_table[n] = p = multmodp(p, p);\n\n#ifdef W\n    /* initialize the braiding tables -- needs x2n_table[] */\n    braid(crc_braid_table, crc_braid_big_table, N, W);\n#endif\n\n#ifdef MAKECRCH\n    {\n        /*\n          The crc32.h header file contains tables for both 32-bit and 64-bit\n          z_word_t's, and so requires a 64-bit type be available. In that case,\n          z_word_t must be defined to be 64-bits. This code then also generates\n          and writes out the tables for the case that z_word_t is 32 bits.\n         */\n#if !defined(W) || W != 8\n#  error Need a 64-bit integer type in order to generate crc32.h.\n#endif\n        FILE *out;\n        int k, n;\n        z_crc_t ltl[8][256];\n        z_word_t big[8][256];\n\n        out = fopen(\"crc32.h\", \"w\");\n        if (out == NULL) return;\n\n        /* write out little-endian CRC table to crc32.h */\n        fprintf(out,\n            \"/* crc32.h -- tables for rapid CRC calculation\\n\"\n            \" * Generated automatically by crc32.c\\n */\\n\"\n            \"\\n\"\n            \"local const z_crc_t FAR crc_table[] = {\\n\"\n            \"    \");\n        write_table(out, crc_table, 256);\n        fprintf(out,\n            \"};\\n\");\n\n        /* write out big-endian CRC table for 64-bit z_word_t to crc32.h */\n        fprintf(out,\n            \"\\n\"\n            \"#ifdef W\\n\"\n            \"\\n\"\n            \"#if W == 8\\n\"\n            \"\\n\"\n            \"local const z_word_t FAR crc_big_table[] = {\\n\"\n            \"    \");\n        write_table64(out, crc_big_table, 256);\n        fprintf(out,\n            \"};\\n\");\n\n        /* write out big-endian CRC table for 32-bit z_word_t to crc32.h */\n        fprintf(out,\n            \"\\n\"\n            \"#else /* W == 4 */\\n\"\n            \"\\n\"\n            \"local const z_word_t FAR crc_big_table[] = {\\n\"\n            \"    \");\n        write_table32hi(out, crc_big_table, 256);\n        fprintf(out,\n            \"};\\n\"\n            \"\\n\"\n            \"#endif\\n\");\n\n        /* write out braid tables for each value of N */\n        for (n = 1; n <= 6; n++) {\n            fprintf(out,\n            \"\\n\"\n            \"#if N == %d\\n\", n);\n\n            /* compute braid tables for this N and 64-bit word_t */\n            braid(ltl, big, n, 8);\n\n            /* write out braid tables for 64-bit z_word_t to crc32.h */\n            fprintf(out,\n            \"\\n\"\n            \"#if W == 8\\n\"\n            \"\\n\"\n            \"local const z_crc_t FAR crc_braid_table[][256] = {\\n\");\n            for (k = 0; k < 8; k++) {\n                fprintf(out, \"   {\");\n                write_table(out, ltl[k], 256);\n                fprintf(out, \"}%s\", k < 7 ? \",\\n\" : \"\");\n            }\n            fprintf(out,\n            \"};\\n\"\n            \"\\n\"\n            \"local const z_word_t FAR crc_braid_big_table[][256] = {\\n\");\n            for (k = 0; k < 8; k++) {\n                fprintf(out, \"   {\");\n                write_table64(out, big[k], 256);\n                fprintf(out, \"}%s\", k < 7 ? \",\\n\" : \"\");\n            }\n            fprintf(out,\n            \"};\\n\");\n\n            /* compute braid tables for this N and 32-bit word_t */\n            braid(ltl, big, n, 4);\n\n            /* write out braid tables for 32-bit z_word_t to crc32.h */\n            fprintf(out,\n            \"\\n\"\n            \"#else /* W == 4 */\\n\"\n            \"\\n\"\n            \"local const z_crc_t FAR crc_braid_table[][256] = {\\n\");\n            for (k = 0; k < 4; k++) {\n                fprintf(out, \"   {\");\n                write_table(out, ltl[k], 256);\n                fprintf(out, \"}%s\", k < 3 ? \",\\n\" : \"\");\n            }\n            fprintf(out,\n            \"};\\n\"\n            \"\\n\"\n            \"local const z_word_t FAR crc_braid_big_table[][256] = {\\n\");\n            for (k = 0; k < 4; k++) {\n                fprintf(out, \"   {\");\n                write_table32hi(out, big[k], 256);\n                fprintf(out, \"}%s\", k < 3 ? \",\\n\" : \"\");\n            }\n            fprintf(out,\n            \"};\\n\"\n            \"\\n\"\n            \"#endif\\n\"\n            \"\\n\"\n            \"#endif\\n\");\n        }\n        fprintf(out,\n            \"\\n\"\n            \"#endif\\n\");\n\n        /* write out zeros operator table to crc32.h */\n        fprintf(out,\n            \"\\n\"\n            \"local const z_crc_t FAR x2n_table[] = {\\n\"\n            \"    \");\n        write_table(out, x2n_table, 32);\n        fprintf(out,\n            \"};\\n\");\n        fclose(out);\n    }\n#endif /* MAKECRCH */\n}\n\n#ifdef MAKECRCH\n\n/*\n   Write the 32-bit values in table[0..k-1] to out, five per line in\n   hexadecimal separated by commas.\n */\nlocal void write_table(FILE *out, const z_crc_t FAR *table, int k) {\n    int n;\n\n    for (n = 0; n < k; n++)\n        fprintf(out, \"%s0x%08lx%s\", n == 0 || n % 5 ? \"\" : \"    \",\n                (unsigned long)(table[n]),\n                n == k - 1 ? \"\" : (n % 5 == 4 ? \",\\n\" : \", \"));\n}\n\n/*\n   Write the high 32-bits of each value in table[0..k-1] to out, five per line\n   in hexadecimal separated by commas.\n */\nlocal void write_table32hi(FILE *out, const z_word_t FAR *table, int k) {\n    int n;\n\n    for (n = 0; n < k; n++)\n        fprintf(out, \"%s0x%08lx%s\", n == 0 || n % 5 ? \"\" : \"    \",\n                (unsigned long)(table[n] >> 32),\n                n == k - 1 ? \"\" : (n % 5 == 4 ? \",\\n\" : \", \"));\n}\n\n/*\n  Write the 64-bit values in table[0..k-1] to out, three per line in\n  hexadecimal separated by commas. This assumes that if there is a 64-bit\n  type, then there is also a long long integer type, and it is at least 64\n  bits. If not, then the type cast and format string can be adjusted\n  accordingly.\n */\nlocal void write_table64(FILE *out, const z_word_t FAR *table, int k) {\n    int n;\n\n    for (n = 0; n < k; n++)\n        fprintf(out, \"%s0x%016llx%s\", n == 0 || n % 3 ? \"\" : \"    \",\n                (unsigned long long)(table[n]),\n                n == k - 1 ? \"\" : (n % 3 == 2 ? \",\\n\" : \", \"));\n}\n\n/* Actually do the deed. */\nint main(void) {\n    make_crc_table();\n    return 0;\n}\n\n#endif /* MAKECRCH */\n\n#ifdef W\n/*\n  Generate the little and big-endian braid tables for the given n and z_word_t\n  size w. Each array must have room for w blocks of 256 elements.\n */\nlocal void braid(z_crc_t ltl[][256], z_word_t big[][256], int n, int w) {\n    int k;\n    z_crc_t i, p, q;\n    for (k = 0; k < w; k++) {\n        p = x2nmodp((n * w + 3 - k) << 3, 0);\n        ltl[k][0] = 0;\n        big[w - 1 - k][0] = 0;\n        for (i = 1; i < 256; i++) {\n            ltl[k][i] = q = multmodp(i << 24, p);\n            big[w - 1 - k][i] = byte_swap(q);\n        }\n    }\n}\n#endif\n\n#endif /* DYNAMIC_CRC_TABLE */\n\n/* =========================================================================\n * This function can be used by asm versions of crc32(), and to force the\n * generation of the CRC tables in a threaded application.\n */\nconst z_crc_t FAR * ZEXPORT get_crc_table(void) {\n#ifdef DYNAMIC_CRC_TABLE\n    once(&made, make_crc_table);\n#endif /* DYNAMIC_CRC_TABLE */\n    return (const z_crc_t FAR *)crc_table;\n}\n\n/* =========================================================================\n * Use ARM machine instructions if available. This will compute the CRC about\n * ten times faster than the braided calculation. This code does not check for\n * the presence of the CRC instruction at run time. __ARM_FEATURE_CRC32 will\n * only be defined if the compilation specifies an ARM processor architecture\n * that has the instructions. For example, compiling with -march=armv8.1-a or\n * -march=armv8-a+crc, or -march=native if the compile machine has the crc32\n * instructions.\n */\n#ifdef ARMCRC32\n\n/*\n   Constants empirically determined to maximize speed. These values are from\n   measurements on a Cortex-A57. Your mileage may vary.\n */\n#define Z_BATCH 3990                /* number of words in a batch */\n#define Z_BATCH_ZEROS 0xa10d3d0c    /* computed from Z_BATCH = 3990 */\n#define Z_BATCH_MIN 800             /* fewest words in a final batch */\n\nunsigned long ZEXPORT crc32_z(unsigned long crc, const unsigned char FAR *buf,\n                              z_size_t len) {\n    z_crc_t val;\n    z_word_t crc1, crc2;\n    const z_word_t *word;\n    z_word_t val0, val1, val2;\n    z_size_t last, last2, i;\n    z_size_t num;\n\n    /* Return initial CRC, if requested. */\n    if (buf == Z_NULL) return 0;\n\n#ifdef DYNAMIC_CRC_TABLE\n    once(&made, make_crc_table);\n#endif /* DYNAMIC_CRC_TABLE */\n\n    /* Pre-condition the CRC */\n    crc = (~crc) & 0xffffffff;\n\n    /* Compute the CRC up to a word boundary. */\n    while (len && ((z_size_t)buf & 7) != 0) {\n        len--;\n        val = *buf++;\n        __asm__ volatile(\"crc32b %w0, %w0, %w1\" : \"+r\"(crc) : \"r\"(val));\n    }\n\n    /* Prepare to compute the CRC on full 64-bit words word[0..num-1]. */\n    word = (z_word_t const *)buf;\n    num = len >> 3;\n    len &= 7;\n\n    /* Do three interleaved CRCs to realize the throughput of one crc32x\n       instruction per cycle. Each CRC is calculated on Z_BATCH words. The\n       three CRCs are combined into a single CRC after each set of batches. */\n    while (num >= 3 * Z_BATCH) {\n        crc1 = 0;\n        crc2 = 0;\n        for (i = 0; i < Z_BATCH; i++) {\n            val0 = word[i];\n            val1 = word[i + Z_BATCH];\n            val2 = word[i + 2 * Z_BATCH];\n            __asm__ volatile(\"crc32x %w0, %w0, %x1\" : \"+r\"(crc) : \"r\"(val0));\n            __asm__ volatile(\"crc32x %w0, %w0, %x1\" : \"+r\"(crc1) : \"r\"(val1));\n            __asm__ volatile(\"crc32x %w0, %w0, %x1\" : \"+r\"(crc2) : \"r\"(val2));\n        }\n        word += 3 * Z_BATCH;\n        num -= 3 * Z_BATCH;\n        crc = multmodp(Z_BATCH_ZEROS, crc) ^ crc1;\n        crc = multmodp(Z_BATCH_ZEROS, crc) ^ crc2;\n    }\n\n    /* Do one last smaller batch with the remaining words, if there are enough\n       to pay for the combination of CRCs. */\n    last = num / 3;\n    if (last >= Z_BATCH_MIN) {\n        last2 = last << 1;\n        crc1 = 0;\n        crc2 = 0;\n        for (i = 0; i < last; i++) {\n            val0 = word[i];\n            val1 = word[i + last];\n            val2 = word[i + last2];\n            __asm__ volatile(\"crc32x %w0, %w0, %x1\" : \"+r\"(crc) : \"r\"(val0));\n            __asm__ volatile(\"crc32x %w0, %w0, %x1\" : \"+r\"(crc1) : \"r\"(val1));\n            __asm__ volatile(\"crc32x %w0, %w0, %x1\" : \"+r\"(crc2) : \"r\"(val2));\n        }\n        word += 3 * last;\n        num -= 3 * last;\n        val = x2nmodp(last, 6);\n        crc = multmodp(val, crc) ^ crc1;\n        crc = multmodp(val, crc) ^ crc2;\n    }\n\n    /* Compute the CRC on any remaining words. */\n    for (i = 0; i < num; i++) {\n        val0 = word[i];\n        __asm__ volatile(\"crc32x %w0, %w0, %x1\" : \"+r\"(crc) : \"r\"(val0));\n    }\n    word += num;\n\n    /* Complete the CRC on any remaining bytes. */\n    buf = (const unsigned char FAR *)word;\n    while (len) {\n        len--;\n        val = *buf++;\n        __asm__ volatile(\"crc32b %w0, %w0, %w1\" : \"+r\"(crc) : \"r\"(val));\n    }\n\n    /* Return the CRC, post-conditioned. */\n    return crc ^ 0xffffffff;\n}\n\n#else\n\n#ifdef W\n\n/*\n  Return the CRC of the W bytes in the word_t data, taking the\n  least-significant byte of the word as the first byte of data, without any pre\n  or post conditioning. This is used to combine the CRCs of each braid.\n */\nlocal z_crc_t crc_word(z_word_t data) {\n    int k;\n    for (k = 0; k < W; k++)\n        data = (data >> 8) ^ crc_table[data & 0xff];\n    return (z_crc_t)data;\n}\n\nlocal z_word_t crc_word_big(z_word_t data) {\n    int k;\n    for (k = 0; k < W; k++)\n        data = (data << 8) ^\n            crc_big_table[(data >> ((W - 1) << 3)) & 0xff];\n    return data;\n}\n\n#endif\n\n/* ========================================================================= */\nunsigned long ZEXPORT crc32_z(unsigned long crc, const unsigned char FAR *buf,\n                              z_size_t len) {\n    /* Return initial CRC, if requested. */\n    if (buf == Z_NULL) return 0;\n\n#ifdef DYNAMIC_CRC_TABLE\n    once(&made, make_crc_table);\n#endif /* DYNAMIC_CRC_TABLE */\n\n    /* Pre-condition the CRC */\n    crc = (~crc) & 0xffffffff;\n\n#ifdef W\n\n    /* If provided enough bytes, do a braided CRC calculation. */\n    if (len >= N * W + W - 1) {\n        z_size_t blks;\n        z_word_t const *words;\n        unsigned endian;\n        int k;\n\n        /* Compute the CRC up to a z_word_t boundary. */\n        while (len && ((z_size_t)buf & (W - 1)) != 0) {\n            len--;\n            crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];\n        }\n\n        /* Compute the CRC on as many N z_word_t blocks as are available. */\n        blks = len / (N * W);\n        len -= blks * N * W;\n        words = (z_word_t const *)buf;\n\n        /* Do endian check at execution time instead of compile time, since ARM\n           processors can change the endianness at execution time. If the\n           compiler knows what the endianness will be, it can optimize out the\n           check and the unused branch. */\n        endian = 1;\n        if (*(unsigned char *)&endian) {\n            /* Little endian. */\n\n            z_crc_t crc0;\n            z_word_t word0;\n#if N > 1\n            z_crc_t crc1;\n            z_word_t word1;\n#if N > 2\n            z_crc_t crc2;\n            z_word_t word2;\n#if N > 3\n            z_crc_t crc3;\n            z_word_t word3;\n#if N > 4\n            z_crc_t crc4;\n            z_word_t word4;\n#if N > 5\n            z_crc_t crc5;\n            z_word_t word5;\n#endif\n#endif\n#endif\n#endif\n#endif\n\n            /* Initialize the CRC for each braid. */\n            crc0 = crc;\n#if N > 1\n            crc1 = 0;\n#if N > 2\n            crc2 = 0;\n#if N > 3\n            crc3 = 0;\n#if N > 4\n            crc4 = 0;\n#if N > 5\n            crc5 = 0;\n#endif\n#endif\n#endif\n#endif\n#endif\n\n            /*\n              Process the first blks-1 blocks, computing the CRCs on each braid\n              independently.\n             */\n            while (--blks) {\n                /* Load the word for each braid into registers. */\n                word0 = crc0 ^ words[0];\n#if N > 1\n                word1 = crc1 ^ words[1];\n#if N > 2\n                word2 = crc2 ^ words[2];\n#if N > 3\n                word3 = crc3 ^ words[3];\n#if N > 4\n                word4 = crc4 ^ words[4];\n#if N > 5\n                word5 = crc5 ^ words[5];\n#endif\n#endif\n#endif\n#endif\n#endif\n                words += N;\n\n                /* Compute and update the CRC for each word. The loop should\n                   get unrolled. */\n                crc0 = crc_braid_table[0][word0 & 0xff];\n#if N > 1\n                crc1 = crc_braid_table[0][word1 & 0xff];\n#if N > 2\n                crc2 = crc_braid_table[0][word2 & 0xff];\n#if N > 3\n                crc3 = crc_braid_table[0][word3 & 0xff];\n#if N > 4\n                crc4 = crc_braid_table[0][word4 & 0xff];\n#if N > 5\n                crc5 = crc_braid_table[0][word5 & 0xff];\n#endif\n#endif\n#endif\n#endif\n#endif\n                for (k = 1; k < W; k++) {\n                    crc0 ^= crc_braid_table[k][(word0 >> (k << 3)) & 0xff];\n#if N > 1\n                    crc1 ^= crc_braid_table[k][(word1 >> (k << 3)) & 0xff];\n#if N > 2\n                    crc2 ^= crc_braid_table[k][(word2 >> (k << 3)) & 0xff];\n#if N > 3\n                    crc3 ^= crc_braid_table[k][(word3 >> (k << 3)) & 0xff];\n#if N > 4\n                    crc4 ^= crc_braid_table[k][(word4 >> (k << 3)) & 0xff];\n#if N > 5\n                    crc5 ^= crc_braid_table[k][(word5 >> (k << 3)) & 0xff];\n#endif\n#endif\n#endif\n#endif\n#endif\n                }\n            }\n\n            /*\n              Process the last block, combining the CRCs of the N braids at the\n              same time.\n             */\n            crc = crc_word(crc0 ^ words[0]);\n#if N > 1\n            crc = crc_word(crc1 ^ words[1] ^ crc);\n#if N > 2\n            crc = crc_word(crc2 ^ words[2] ^ crc);\n#if N > 3\n            crc = crc_word(crc3 ^ words[3] ^ crc);\n#if N > 4\n            crc = crc_word(crc4 ^ words[4] ^ crc);\n#if N > 5\n            crc = crc_word(crc5 ^ words[5] ^ crc);\n#endif\n#endif\n#endif\n#endif\n#endif\n            words += N;\n        }\n        else {\n            /* Big endian. */\n\n            z_word_t crc0, word0, comb;\n#if N > 1\n            z_word_t crc1, word1;\n#if N > 2\n            z_word_t crc2, word2;\n#if N > 3\n            z_word_t crc3, word3;\n#if N > 4\n            z_word_t crc4, word4;\n#if N > 5\n            z_word_t crc5, word5;\n#endif\n#endif\n#endif\n#endif\n#endif\n\n            /* Initialize the CRC for each braid. */\n            crc0 = byte_swap(crc);\n#if N > 1\n            crc1 = 0;\n#if N > 2\n            crc2 = 0;\n#if N > 3\n            crc3 = 0;\n#if N > 4\n            crc4 = 0;\n#if N > 5\n            crc5 = 0;\n#endif\n#endif\n#endif\n#endif\n#endif\n\n            /*\n              Process the first blks-1 blocks, computing the CRCs on each braid\n              independently.\n             */\n            while (--blks) {\n                /* Load the word for each braid into registers. */\n                word0 = crc0 ^ words[0];\n#if N > 1\n                word1 = crc1 ^ words[1];\n#if N > 2\n                word2 = crc2 ^ words[2];\n#if N > 3\n                word3 = crc3 ^ words[3];\n#if N > 4\n                word4 = crc4 ^ words[4];\n#if N > 5\n                word5 = crc5 ^ words[5];\n#endif\n#endif\n#endif\n#endif\n#endif\n                words += N;\n\n                /* Compute and update the CRC for each word. The loop should\n                   get unrolled. */\n                crc0 = crc_braid_big_table[0][word0 & 0xff];\n#if N > 1\n                crc1 = crc_braid_big_table[0][word1 & 0xff];\n#if N > 2\n                crc2 = crc_braid_big_table[0][word2 & 0xff];\n#if N > 3\n                crc3 = crc_braid_big_table[0][word3 & 0xff];\n#if N > 4\n                crc4 = crc_braid_big_table[0][word4 & 0xff];\n#if N > 5\n                crc5 = crc_braid_big_table[0][word5 & 0xff];\n#endif\n#endif\n#endif\n#endif\n#endif\n                for (k = 1; k < W; k++) {\n                    crc0 ^= crc_braid_big_table[k][(word0 >> (k << 3)) & 0xff];\n#if N > 1\n                    crc1 ^= crc_braid_big_table[k][(word1 >> (k << 3)) & 0xff];\n#if N > 2\n                    crc2 ^= crc_braid_big_table[k][(word2 >> (k << 3)) & 0xff];\n#if N > 3\n                    crc3 ^= crc_braid_big_table[k][(word3 >> (k << 3)) & 0xff];\n#if N > 4\n                    crc4 ^= crc_braid_big_table[k][(word4 >> (k << 3)) & 0xff];\n#if N > 5\n                    crc5 ^= crc_braid_big_table[k][(word5 >> (k << 3)) & 0xff];\n#endif\n#endif\n#endif\n#endif\n#endif\n                }\n            }\n\n            /*\n              Process the last block, combining the CRCs of the N braids at the\n              same time.\n             */\n            comb = crc_word_big(crc0 ^ words[0]);\n#if N > 1\n            comb = crc_word_big(crc1 ^ words[1] ^ comb);\n#if N > 2\n            comb = crc_word_big(crc2 ^ words[2] ^ comb);\n#if N > 3\n            comb = crc_word_big(crc3 ^ words[3] ^ comb);\n#if N > 4\n            comb = crc_word_big(crc4 ^ words[4] ^ comb);\n#if N > 5\n            comb = crc_word_big(crc5 ^ words[5] ^ comb);\n#endif\n#endif\n#endif\n#endif\n#endif\n            words += N;\n            crc = byte_swap(comb);\n        }\n\n        /*\n          Update the pointer to the remaining bytes to process.\n         */\n        buf = (unsigned char const *)words;\n    }\n\n#endif /* W */\n\n    /* Complete the computation of the CRC on any remaining bytes. */\n    while (len >= 8) {\n        len -= 8;\n        crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];\n        crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];\n        crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];\n        crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];\n        crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];\n        crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];\n        crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];\n        crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];\n    }\n    while (len) {\n        len--;\n        crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];\n    }\n\n    /* Return the CRC, post-conditioned. */\n    return crc ^ 0xffffffff;\n}\n\n#endif\n\n/* ========================================================================= */\nunsigned long ZEXPORT crc32(unsigned long crc, const unsigned char FAR *buf,\n                            uInt len) {\n    return crc32_z(crc, buf, len);\n}\n\n/* ========================================================================= */\nuLong ZEXPORT crc32_combine64(uLong crc1, uLong crc2, z_off64_t len2) {\n#ifdef DYNAMIC_CRC_TABLE\n    once(&made, make_crc_table);\n#endif /* DYNAMIC_CRC_TABLE */\n    return multmodp(x2nmodp(len2, 3), crc1) ^ (crc2 & 0xffffffff);\n}\n\n/* ========================================================================= */\nuLong ZEXPORT crc32_combine(uLong crc1, uLong crc2, z_off_t len2) {\n    return crc32_combine64(crc1, crc2, (z_off64_t)len2);\n}\n\n/* ========================================================================= */\nuLong ZEXPORT crc32_combine_gen64(z_off64_t len2) {\n#ifdef DYNAMIC_CRC_TABLE\n    once(&made, make_crc_table);\n#endif /* DYNAMIC_CRC_TABLE */\n    return x2nmodp(len2, 3);\n}\n\n/* ========================================================================= */\nuLong ZEXPORT crc32_combine_gen(z_off_t len2) {\n    return crc32_combine_gen64((z_off64_t)len2);\n}\n\n/* ========================================================================= */\nuLong ZEXPORT crc32_combine_op(uLong crc1, uLong crc2, uLong op) {\n    return multmodp(op, crc1) ^ (crc2 & 0xffffffff);\n}\n"
        },
        {
          "name": "crc32.h",
          "type": "blob",
          "size": 577.8798828125,
          "content": "/* crc32.h -- tables for rapid CRC calculation\n * Generated automatically by crc32.c\n */\n\nlocal const z_crc_t FAR crc_table[] = {\n    0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419,\n    0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4,\n    0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07,\n    0x90bf1d91, 0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de,\n    0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856,\n    0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,\n    0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4,\n    0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,\n    0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3,\n    0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a,\n    0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599,\n    0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,\n    0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190,\n    0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f,\n    0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f934, 0x9609a88e,\n    0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,\n    0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed,\n    0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,\n    0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3,\n    0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2,\n    0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a,\n    0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5,\n    0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010,\n    0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,\n    0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17,\n    0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6,\n    0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615,\n    0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8,\n    0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, 0xf00f9344,\n    0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,\n    0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a,\n    0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,\n    0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1,\n    0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c,\n    0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef,\n    0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,\n    0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe,\n    0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31,\n    0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c,\n    0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,\n    0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b,\n    0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,\n    0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1,\n    0x18b74777, 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c,\n    0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278,\n    0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7,\n    0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66,\n    0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,\n    0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605,\n    0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8,\n    0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b,\n    0x2d02ef8d};\n\n#ifdef W\n\n#if W == 8\n\nlocal const z_word_t FAR crc_big_table[] = {\n    0x0000000000000000, 0x9630077700000000, 0x2c610eee00000000,\n    0xba51099900000000, 0x19c46d0700000000, 0x8ff46a7000000000,\n    0x35a563e900000000, 0xa395649e00000000, 0x3288db0e00000000,\n    0xa4b8dc7900000000, 0x1ee9d5e000000000, 0x88d9d29700000000,\n    0x2b4cb60900000000, 0xbd7cb17e00000000, 0x072db8e700000000,\n    0x911dbf9000000000, 0x6410b71d00000000, 0xf220b06a00000000,\n    0x4871b9f300000000, 0xde41be8400000000, 0x7dd4da1a00000000,\n    0xebe4dd6d00000000, 0x51b5d4f400000000, 0xc785d38300000000,\n    0x56986c1300000000, 0xc0a86b6400000000, 0x7af962fd00000000,\n    0xecc9658a00000000, 0x4f5c011400000000, 0xd96c066300000000,\n    0x633d0ffa00000000, 0xf50d088d00000000, 0xc8206e3b00000000,\n    0x5e10694c00000000, 0xe44160d500000000, 0x727167a200000000,\n    0xd1e4033c00000000, 0x47d4044b00000000, 0xfd850dd200000000,\n    0x6bb50aa500000000, 0xfaa8b53500000000, 0x6c98b24200000000,\n    0xd6c9bbdb00000000, 0x40f9bcac00000000, 0xe36cd83200000000,\n    0x755cdf4500000000, 0xcf0dd6dc00000000, 0x593dd1ab00000000,\n    0xac30d92600000000, 0x3a00de5100000000, 0x8051d7c800000000,\n    0x1661d0bf00000000, 0xb5f4b42100000000, 0x23c4b35600000000,\n    0x9995bacf00000000, 0x0fa5bdb800000000, 0x9eb8022800000000,\n    0x0888055f00000000, 0xb2d90cc600000000, 0x24e90bb100000000,\n    0x877c6f2f00000000, 0x114c685800000000, 0xab1d61c100000000,\n    0x3d2d66b600000000, 0x9041dc7600000000, 0x0671db0100000000,\n    0xbc20d29800000000, 0x2a10d5ef00000000, 0x8985b17100000000,\n    0x1fb5b60600000000, 0xa5e4bf9f00000000, 0x33d4b8e800000000,\n    0xa2c9077800000000, 0x34f9000f00000000, 0x8ea8099600000000,\n    0x18980ee100000000, 0xbb0d6a7f00000000, 0x2d3d6d0800000000,\n    0x976c649100000000, 0x015c63e600000000, 0xf4516b6b00000000,\n    0x62616c1c00000000, 0xd830658500000000, 0x4e0062f200000000,\n    0xed95066c00000000, 0x7ba5011b00000000, 0xc1f4088200000000,\n    0x57c40ff500000000, 0xc6d9b06500000000, 0x50e9b71200000000,\n    0xeab8be8b00000000, 0x7c88b9fc00000000, 0xdf1ddd6200000000,\n    0x492dda1500000000, 0xf37cd38c00000000, 0x654cd4fb00000000,\n    0x5861b24d00000000, 0xce51b53a00000000, 0x7400bca300000000,\n    0xe230bbd400000000, 0x41a5df4a00000000, 0xd795d83d00000000,\n    0x6dc4d1a400000000, 0xfbf4d6d300000000, 0x6ae9694300000000,\n    0xfcd96e3400000000, 0x468867ad00000000, 0xd0b860da00000000,\n    0x732d044400000000, 0xe51d033300000000, 0x5f4c0aaa00000000,\n    0xc97c0ddd00000000, 0x3c71055000000000, 0xaa41022700000000,\n    0x10100bbe00000000, 0x86200cc900000000, 0x25b5685700000000,\n    0xb3856f2000000000, 0x09d466b900000000, 0x9fe461ce00000000,\n    0x0ef9de5e00000000, 0x98c9d92900000000, 0x2298d0b000000000,\n    0xb4a8d7c700000000, 0x173db35900000000, 0x810db42e00000000,\n    0x3b5cbdb700000000, 0xad6cbac000000000, 0x2083b8ed00000000,\n    0xb6b3bf9a00000000, 0x0ce2b60300000000, 0x9ad2b17400000000,\n    0x3947d5ea00000000, 0xaf77d29d00000000, 0x1526db0400000000,\n    0x8316dc7300000000, 0x120b63e300000000, 0x843b649400000000,\n    0x3e6a6d0d00000000, 0xa85a6a7a00000000, 0x0bcf0ee400000000,\n    0x9dff099300000000, 0x27ae000a00000000, 0xb19e077d00000000,\n    0x44930ff000000000, 0xd2a3088700000000, 0x68f2011e00000000,\n    0xfec2066900000000, 0x5d5762f700000000, 0xcb67658000000000,\n    0x71366c1900000000, 0xe7066b6e00000000, 0x761bd4fe00000000,\n    0xe02bd38900000000, 0x5a7ada1000000000, 0xcc4add6700000000,\n    0x6fdfb9f900000000, 0xf9efbe8e00000000, 0x43beb71700000000,\n    0xd58eb06000000000, 0xe8a3d6d600000000, 0x7e93d1a100000000,\n    0xc4c2d83800000000, 0x52f2df4f00000000, 0xf167bbd100000000,\n    0x6757bca600000000, 0xdd06b53f00000000, 0x4b36b24800000000,\n    0xda2b0dd800000000, 0x4c1b0aaf00000000, 0xf64a033600000000,\n    0x607a044100000000, 0xc3ef60df00000000, 0x55df67a800000000,\n    0xef8e6e3100000000, 0x79be694600000000, 0x8cb361cb00000000,\n    0x1a8366bc00000000, 0xa0d26f2500000000, 0x36e2685200000000,\n    0x95770ccc00000000, 0x03470bbb00000000, 0xb916022200000000,\n    0x2f26055500000000, 0xbe3bbac500000000, 0x280bbdb200000000,\n    0x925ab42b00000000, 0x046ab35c00000000, 0xa7ffd7c200000000,\n    0x31cfd0b500000000, 0x8b9ed92c00000000, 0x1daede5b00000000,\n    0xb0c2649b00000000, 0x26f263ec00000000, 0x9ca36a7500000000,\n    0x0a936d0200000000, 0xa906099c00000000, 0x3f360eeb00000000,\n    0x8567077200000000, 0x1357000500000000, 0x824abf9500000000,\n    0x147ab8e200000000, 0xae2bb17b00000000, 0x381bb60c00000000,\n    0x9b8ed29200000000, 0x0dbed5e500000000, 0xb7efdc7c00000000,\n    0x21dfdb0b00000000, 0xd4d2d38600000000, 0x42e2d4f100000000,\n    0xf8b3dd6800000000, 0x6e83da1f00000000, 0xcd16be8100000000,\n    0x5b26b9f600000000, 0xe177b06f00000000, 0x7747b71800000000,\n    0xe65a088800000000, 0x706a0fff00000000, 0xca3b066600000000,\n    0x5c0b011100000000, 0xff9e658f00000000, 0x69ae62f800000000,\n    0xd3ff6b6100000000, 0x45cf6c1600000000, 0x78e20aa000000000,\n    0xeed20dd700000000, 0x5483044e00000000, 0xc2b3033900000000,\n    0x612667a700000000, 0xf71660d000000000, 0x4d47694900000000,\n    0xdb776e3e00000000, 0x4a6ad1ae00000000, 0xdc5ad6d900000000,\n    0x660bdf4000000000, 0xf03bd83700000000, 0x53aebca900000000,\n    0xc59ebbde00000000, 0x7fcfb24700000000, 0xe9ffb53000000000,\n    0x1cf2bdbd00000000, 0x8ac2baca00000000, 0x3093b35300000000,\n    0xa6a3b42400000000, 0x0536d0ba00000000, 0x9306d7cd00000000,\n    0x2957de5400000000, 0xbf67d92300000000, 0x2e7a66b300000000,\n    0xb84a61c400000000, 0x021b685d00000000, 0x942b6f2a00000000,\n    0x37be0bb400000000, 0xa18e0cc300000000, 0x1bdf055a00000000,\n    0x8def022d00000000};\n\n#else /* W == 4 */\n\nlocal const z_word_t FAR crc_big_table[] = {\n    0x00000000, 0x96300777, 0x2c610eee, 0xba510999, 0x19c46d07,\n    0x8ff46a70, 0x35a563e9, 0xa395649e, 0x3288db0e, 0xa4b8dc79,\n    0x1ee9d5e0, 0x88d9d297, 0x2b4cb609, 0xbd7cb17e, 0x072db8e7,\n    0x911dbf90, 0x6410b71d, 0xf220b06a, 0x4871b9f3, 0xde41be84,\n    0x7dd4da1a, 0xebe4dd6d, 0x51b5d4f4, 0xc785d383, 0x56986c13,\n    0xc0a86b64, 0x7af962fd, 0xecc9658a, 0x4f5c0114, 0xd96c0663,\n    0x633d0ffa, 0xf50d088d, 0xc8206e3b, 0x5e10694c, 0xe44160d5,\n    0x727167a2, 0xd1e4033c, 0x47d4044b, 0xfd850dd2, 0x6bb50aa5,\n    0xfaa8b535, 0x6c98b242, 0xd6c9bbdb, 0x40f9bcac, 0xe36cd832,\n    0x755cdf45, 0xcf0dd6dc, 0x593dd1ab, 0xac30d926, 0x3a00de51,\n    0x8051d7c8, 0x1661d0bf, 0xb5f4b421, 0x23c4b356, 0x9995bacf,\n    0x0fa5bdb8, 0x9eb80228, 0x0888055f, 0xb2d90cc6, 0x24e90bb1,\n    0x877c6f2f, 0x114c6858, 0xab1d61c1, 0x3d2d66b6, 0x9041dc76,\n    0x0671db01, 0xbc20d298, 0x2a10d5ef, 0x8985b171, 0x1fb5b606,\n    0xa5e4bf9f, 0x33d4b8e8, 0xa2c90778, 0x34f9000f, 0x8ea80996,\n    0x18980ee1, 0xbb0d6a7f, 0x2d3d6d08, 0x976c6491, 0x015c63e6,\n    0xf4516b6b, 0x62616c1c, 0xd8306585, 0x4e0062f2, 0xed95066c,\n    0x7ba5011b, 0xc1f40882, 0x57c40ff5, 0xc6d9b065, 0x50e9b712,\n    0xeab8be8b, 0x7c88b9fc, 0xdf1ddd62, 0x492dda15, 0xf37cd38c,\n    0x654cd4fb, 0x5861b24d, 0xce51b53a, 0x7400bca3, 0xe230bbd4,\n    0x41a5df4a, 0xd795d83d, 0x6dc4d1a4, 0xfbf4d6d3, 0x6ae96943,\n    0xfcd96e34, 0x468867ad, 0xd0b860da, 0x732d0444, 0xe51d0333,\n    0x5f4c0aaa, 0xc97c0ddd, 0x3c710550, 0xaa410227, 0x10100bbe,\n    0x86200cc9, 0x25b56857, 0xb3856f20, 0x09d466b9, 0x9fe461ce,\n    0x0ef9de5e, 0x98c9d929, 0x2298d0b0, 0xb4a8d7c7, 0x173db359,\n    0x810db42e, 0x3b5cbdb7, 0xad6cbac0, 0x2083b8ed, 0xb6b3bf9a,\n    0x0ce2b603, 0x9ad2b174, 0x3947d5ea, 0xaf77d29d, 0x1526db04,\n    0x8316dc73, 0x120b63e3, 0x843b6494, 0x3e6a6d0d, 0xa85a6a7a,\n    0x0bcf0ee4, 0x9dff0993, 0x27ae000a, 0xb19e077d, 0x44930ff0,\n    0xd2a30887, 0x68f2011e, 0xfec20669, 0x5d5762f7, 0xcb676580,\n    0x71366c19, 0xe7066b6e, 0x761bd4fe, 0xe02bd389, 0x5a7ada10,\n    0xcc4add67, 0x6fdfb9f9, 0xf9efbe8e, 0x43beb717, 0xd58eb060,\n    0xe8a3d6d6, 0x7e93d1a1, 0xc4c2d838, 0x52f2df4f, 0xf167bbd1,\n    0x6757bca6, 0xdd06b53f, 0x4b36b248, 0xda2b0dd8, 0x4c1b0aaf,\n    0xf64a0336, 0x607a0441, 0xc3ef60df, 0x55df67a8, 0xef8e6e31,\n    0x79be6946, 0x8cb361cb, 0x1a8366bc, 0xa0d26f25, 0x36e26852,\n    0x95770ccc, 0x03470bbb, 0xb9160222, 0x2f260555, 0xbe3bbac5,\n    0x280bbdb2, 0x925ab42b, 0x046ab35c, 0xa7ffd7c2, 0x31cfd0b5,\n    0x8b9ed92c, 0x1daede5b, 0xb0c2649b, 0x26f263ec, 0x9ca36a75,\n    0x0a936d02, 0xa906099c, 0x3f360eeb, 0x85670772, 0x13570005,\n    0x824abf95, 0x147ab8e2, 0xae2bb17b, 0x381bb60c, 0x9b8ed292,\n    0x0dbed5e5, 0xb7efdc7c, 0x21dfdb0b, 0xd4d2d386, 0x42e2d4f1,\n    0xf8b3dd68, 0x6e83da1f, 0xcd16be81, 0x5b26b9f6, 0xe177b06f,\n    0x7747b718, 0xe65a0888, 0x706a0fff, 0xca3b0666, 0x5c0b0111,\n    0xff9e658f, 0x69ae62f8, 0xd3ff6b61, 0x45cf6c16, 0x78e20aa0,\n    0xeed20dd7, 0x5483044e, 0xc2b30339, 0x612667a7, 0xf71660d0,\n    0x4d476949, 0xdb776e3e, 0x4a6ad1ae, 0xdc5ad6d9, 0x660bdf40,\n    0xf03bd837, 0x53aebca9, 0xc59ebbde, 0x7fcfb247, 0xe9ffb530,\n    0x1cf2bdbd, 0x8ac2baca, 0x3093b353, 0xa6a3b424, 0x0536d0ba,\n    0x9306d7cd, 0x2957de54, 0xbf67d923, 0x2e7a66b3, 0xb84a61c4,\n    0x021b685d, 0x942b6f2a, 0x37be0bb4, 0xa18e0cc3, 0x1bdf055a,\n    0x8def022d};\n\n#endif\n\n#if N == 1\n\n#if W == 8\n\nlocal const z_crc_t FAR crc_braid_table[][256] = {\n   {0x00000000, 0xccaa009e, 0x4225077d, 0x8e8f07e3, 0x844a0efa,\n    0x48e00e64, 0xc66f0987, 0x0ac50919, 0xd3e51bb5, 0x1f4f1b2b,\n    0x91c01cc8, 0x5d6a1c56, 0x57af154f, 0x9b0515d1, 0x158a1232,\n    0xd92012ac, 0x7cbb312b, 0xb01131b5, 0x3e9e3656, 0xf23436c8,\n    0xf8f13fd1, 0x345b3f4f, 0xbad438ac, 0x767e3832, 0xaf5e2a9e,\n    0x63f42a00, 0xed7b2de3, 0x21d12d7d, 0x2b142464, 0xe7be24fa,\n    0x69312319, 0xa59b2387, 0xf9766256, 0x35dc62c8, 0xbb53652b,\n    0x77f965b5, 0x7d3c6cac, 0xb1966c32, 0x3f196bd1, 0xf3b36b4f,\n    0x2a9379e3, 0xe639797d, 0x68b67e9e, 0xa41c7e00, 0xaed97719,\n    0x62737787, 0xecfc7064, 0x205670fa, 0x85cd537d, 0x496753e3,\n    0xc7e85400, 0x0b42549e, 0x01875d87, 0xcd2d5d19, 0x43a25afa,\n    0x8f085a64, 0x562848c8, 0x9a824856, 0x140d4fb5, 0xd8a74f2b,\n    0xd2624632, 0x1ec846ac, 0x9047414f, 0x5ced41d1, 0x299dc2ed,\n    0xe537c273, 0x6bb8c590, 0xa712c50e, 0xadd7cc17, 0x617dcc89,\n    0xeff2cb6a, 0x2358cbf4, 0xfa78d958, 0x36d2d9c6, 0xb85dde25,\n    0x74f7debb, 0x7e32d7a2, 0xb298d73c, 0x3c17d0df, 0xf0bdd041,\n    0x5526f3c6, 0x998cf358, 0x1703f4bb, 0xdba9f425, 0xd16cfd3c,\n    0x1dc6fda2, 0x9349fa41, 0x5fe3fadf, 0x86c3e873, 0x4a69e8ed,\n    0xc4e6ef0e, 0x084cef90, 0x0289e689, 0xce23e617, 0x40ace1f4,\n    0x8c06e16a, 0xd0eba0bb, 0x1c41a025, 0x92cea7c6, 0x5e64a758,\n    0x54a1ae41, 0x980baedf, 0x1684a93c, 0xda2ea9a2, 0x030ebb0e,\n    0xcfa4bb90, 0x412bbc73, 0x8d81bced, 0x8744b5f4, 0x4beeb56a,\n    0xc561b289, 0x09cbb217, 0xac509190, 0x60fa910e, 0xee7596ed,\n    0x22df9673, 0x281a9f6a, 0xe4b09ff4, 0x6a3f9817, 0xa6959889,\n    0x7fb58a25, 0xb31f8abb, 0x3d908d58, 0xf13a8dc6, 0xfbff84df,\n    0x37558441, 0xb9da83a2, 0x7570833c, 0x533b85da, 0x9f918544,\n    0x111e82a7, 0xddb48239, 0xd7718b20, 0x1bdb8bbe, 0x95548c5d,\n    0x59fe8cc3, 0x80de9e6f, 0x4c749ef1, 0xc2fb9912, 0x0e51998c,\n    0x04949095, 0xc83e900b, 0x46b197e8, 0x8a1b9776, 0x2f80b4f1,\n    0xe32ab46f, 0x6da5b38c, 0xa10fb312, 0xabcaba0b, 0x6760ba95,\n    0xe9efbd76, 0x2545bde8, 0xfc65af44, 0x30cfafda, 0xbe40a839,\n    0x72eaa8a7, 0x782fa1be, 0xb485a120, 0x3a0aa6c3, 0xf6a0a65d,\n    0xaa4de78c, 0x66e7e712, 0xe868e0f1, 0x24c2e06f, 0x2e07e976,\n    0xe2ade9e8, 0x6c22ee0b, 0xa088ee95, 0x79a8fc39, 0xb502fca7,\n    0x3b8dfb44, 0xf727fbda, 0xfde2f2c3, 0x3148f25d, 0xbfc7f5be,\n    0x736df520, 0xd6f6d6a7, 0x1a5cd639, 0x94d3d1da, 0x5879d144,\n    0x52bcd85d, 0x9e16d8c3, 0x1099df20, 0xdc33dfbe, 0x0513cd12,\n    0xc9b9cd8c, 0x4736ca6f, 0x8b9ccaf1, 0x8159c3e8, 0x4df3c376,\n    0xc37cc495, 0x0fd6c40b, 0x7aa64737, 0xb60c47a9, 0x3883404a,\n    0xf42940d4, 0xfeec49cd, 0x32464953, 0xbcc94eb0, 0x70634e2e,\n    0xa9435c82, 0x65e95c1c, 0xeb665bff, 0x27cc5b61, 0x2d095278,\n    0xe1a352e6, 0x6f2c5505, 0xa386559b, 0x061d761c, 0xcab77682,\n    0x44387161, 0x889271ff, 0x825778e6, 0x4efd7878, 0xc0727f9b,\n    0x0cd87f05, 0xd5f86da9, 0x19526d37, 0x97dd6ad4, 0x5b776a4a,\n    0x51b26353, 0x9d1863cd, 0x1397642e, 0xdf3d64b0, 0x83d02561,\n    0x4f7a25ff, 0xc1f5221c, 0x0d5f2282, 0x079a2b9b, 0xcb302b05,\n    0x45bf2ce6, 0x89152c78, 0x50353ed4, 0x9c9f3e4a, 0x121039a9,\n    0xdeba3937, 0xd47f302e, 0x18d530b0, 0x965a3753, 0x5af037cd,\n    0xff6b144a, 0x33c114d4, 0xbd4e1337, 0x71e413a9, 0x7b211ab0,\n    0xb78b1a2e, 0x39041dcd, 0xf5ae1d53, 0x2c8e0fff, 0xe0240f61,\n    0x6eab0882, 0xa201081c, 0xa8c40105, 0x646e019b, 0xeae10678,\n    0x264b06e6},\n   {0x00000000, 0xa6770bb4, 0x979f1129, 0x31e81a9d, 0xf44f2413,\n    0x52382fa7, 0x63d0353a, 0xc5a73e8e, 0x33ef4e67, 0x959845d3,\n    0xa4705f4e, 0x020754fa, 0xc7a06a74, 0x61d761c0, 0x503f7b5d,\n    0xf64870e9, 0x67de9cce, 0xc1a9977a, 0xf0418de7, 0x56368653,\n    0x9391b8dd, 0x35e6b369, 0x040ea9f4, 0xa279a240, 0x5431d2a9,\n    0xf246d91d, 0xc3aec380, 0x65d9c834, 0xa07ef6ba, 0x0609fd0e,\n    0x37e1e793, 0x9196ec27, 0xcfbd399c, 0x69ca3228, 0x582228b5,\n    0xfe552301, 0x3bf21d8f, 0x9d85163b, 0xac6d0ca6, 0x0a1a0712,\n    0xfc5277fb, 0x5a257c4f, 0x6bcd66d2, 0xcdba6d66, 0x081d53e8,\n    0xae6a585c, 0x9f8242c1, 0x39f54975, 0xa863a552, 0x0e14aee6,\n    0x3ffcb47b, 0x998bbfcf, 0x5c2c8141, 0xfa5b8af5, 0xcbb39068,\n    0x6dc49bdc, 0x9b8ceb35, 0x3dfbe081, 0x0c13fa1c, 0xaa64f1a8,\n    0x6fc3cf26, 0xc9b4c492, 0xf85cde0f, 0x5e2bd5bb, 0x440b7579,\n    0xe27c7ecd, 0xd3946450, 0x75e36fe4, 0xb044516a, 0x16335ade,\n    0x27db4043, 0x81ac4bf7, 0x77e43b1e, 0xd19330aa, 0xe07b2a37,\n    0x460c2183, 0x83ab1f0d, 0x25dc14b9, 0x14340e24, 0xb2430590,\n    0x23d5e9b7, 0x85a2e203, 0xb44af89e, 0x123df32a, 0xd79acda4,\n    0x71edc610, 0x4005dc8d, 0xe672d739, 0x103aa7d0, 0xb64dac64,\n    0x87a5b6f9, 0x21d2bd4d, 0xe47583c3, 0x42028877, 0x73ea92ea,\n    0xd59d995e, 0x8bb64ce5, 0x2dc14751, 0x1c295dcc, 0xba5e5678,\n    0x7ff968f6, 0xd98e6342, 0xe86679df, 0x4e11726b, 0xb8590282,\n    0x1e2e0936, 0x2fc613ab, 0x89b1181f, 0x4c162691, 0xea612d25,\n    0xdb8937b8, 0x7dfe3c0c, 0xec68d02b, 0x4a1fdb9f, 0x7bf7c102,\n    0xdd80cab6, 0x1827f438, 0xbe50ff8c, 0x8fb8e511, 0x29cfeea5,\n    0xdf879e4c, 0x79f095f8, 0x48188f65, 0xee6f84d1, 0x2bc8ba5f,\n    0x8dbfb1eb, 0xbc57ab76, 0x1a20a0c2, 0x8816eaf2, 0x2e61e146,\n    0x1f89fbdb, 0xb9fef06f, 0x7c59cee1, 0xda2ec555, 0xebc6dfc8,\n    0x4db1d47c, 0xbbf9a495, 0x1d8eaf21, 0x2c66b5bc, 0x8a11be08,\n    0x4fb68086, 0xe9c18b32, 0xd82991af, 0x7e5e9a1b, 0xefc8763c,\n    0x49bf7d88, 0x78576715, 0xde206ca1, 0x1b87522f, 0xbdf0599b,\n    0x8c184306, 0x2a6f48b2, 0xdc27385b, 0x7a5033ef, 0x4bb82972,\n    0xedcf22c6, 0x28681c48, 0x8e1f17fc, 0xbff70d61, 0x198006d5,\n    0x47abd36e, 0xe1dcd8da, 0xd034c247, 0x7643c9f3, 0xb3e4f77d,\n    0x1593fcc9, 0x247be654, 0x820cede0, 0x74449d09, 0xd23396bd,\n    0xe3db8c20, 0x45ac8794, 0x800bb91a, 0x267cb2ae, 0x1794a833,\n    0xb1e3a387, 0x20754fa0, 0x86024414, 0xb7ea5e89, 0x119d553d,\n    0xd43a6bb3, 0x724d6007, 0x43a57a9a, 0xe5d2712e, 0x139a01c7,\n    0xb5ed0a73, 0x840510ee, 0x22721b5a, 0xe7d525d4, 0x41a22e60,\n    0x704a34fd, 0xd63d3f49, 0xcc1d9f8b, 0x6a6a943f, 0x5b828ea2,\n    0xfdf58516, 0x3852bb98, 0x9e25b02c, 0xafcdaab1, 0x09baa105,\n    0xfff2d1ec, 0x5985da58, 0x686dc0c5, 0xce1acb71, 0x0bbdf5ff,\n    0xadcafe4b, 0x9c22e4d6, 0x3a55ef62, 0xabc30345, 0x0db408f1,\n    0x3c5c126c, 0x9a2b19d8, 0x5f8c2756, 0xf9fb2ce2, 0xc813367f,\n    0x6e643dcb, 0x982c4d22, 0x3e5b4696, 0x0fb35c0b, 0xa9c457bf,\n    0x6c636931, 0xca146285, 0xfbfc7818, 0x5d8b73ac, 0x03a0a617,\n    0xa5d7ada3, 0x943fb73e, 0x3248bc8a, 0xf7ef8204, 0x519889b0,\n    0x6070932d, 0xc6079899, 0x304fe870, 0x9638e3c4, 0xa7d0f959,\n    0x01a7f2ed, 0xc400cc63, 0x6277c7d7, 0x539fdd4a, 0xf5e8d6fe,\n    0x647e3ad9, 0xc209316d, 0xf3e12bf0, 0x55962044, 0x90311eca,\n    0x3646157e, 0x07ae0fe3, 0xa1d90457, 0x579174be, 0xf1e67f0a,\n    0xc00e6597, 0x66796e23, 0xa3de50ad, 0x05a95b19, 0x34414184,\n    0x92364a30},\n   {0x00000000, 0xcb5cd3a5, 0x4dc8a10b, 0x869472ae, 0x9b914216,\n    0x50cd91b3, 0xd659e31d, 0x1d0530b8, 0xec53826d, 0x270f51c8,\n    0xa19b2366, 0x6ac7f0c3, 0x77c2c07b, 0xbc9e13de, 0x3a0a6170,\n    0xf156b2d5, 0x03d6029b, 0xc88ad13e, 0x4e1ea390, 0x85427035,\n    0x9847408d, 0x531b9328, 0xd58fe186, 0x1ed33223, 0xef8580f6,\n    0x24d95353, 0xa24d21fd, 0x6911f258, 0x7414c2e0, 0xbf481145,\n    0x39dc63eb, 0xf280b04e, 0x07ac0536, 0xccf0d693, 0x4a64a43d,\n    0x81387798, 0x9c3d4720, 0x57619485, 0xd1f5e62b, 0x1aa9358e,\n    0xebff875b, 0x20a354fe, 0xa6372650, 0x6d6bf5f5, 0x706ec54d,\n    0xbb3216e8, 0x3da66446, 0xf6fab7e3, 0x047a07ad, 0xcf26d408,\n    0x49b2a6a6, 0x82ee7503, 0x9feb45bb, 0x54b7961e, 0xd223e4b0,\n    0x197f3715, 0xe82985c0, 0x23755665, 0xa5e124cb, 0x6ebdf76e,\n    0x73b8c7d6, 0xb8e41473, 0x3e7066dd, 0xf52cb578, 0x0f580a6c,\n    0xc404d9c9, 0x4290ab67, 0x89cc78c2, 0x94c9487a, 0x5f959bdf,\n    0xd901e971, 0x125d3ad4, 0xe30b8801, 0x28575ba4, 0xaec3290a,\n    0x659ffaaf, 0x789aca17, 0xb3c619b2, 0x35526b1c, 0xfe0eb8b9,\n    0x0c8e08f7, 0xc7d2db52, 0x4146a9fc, 0x8a1a7a59, 0x971f4ae1,\n    0x5c439944, 0xdad7ebea, 0x118b384f, 0xe0dd8a9a, 0x2b81593f,\n    0xad152b91, 0x6649f834, 0x7b4cc88c, 0xb0101b29, 0x36846987,\n    0xfdd8ba22, 0x08f40f5a, 0xc3a8dcff, 0x453cae51, 0x8e607df4,\n    0x93654d4c, 0x58399ee9, 0xdeadec47, 0x15f13fe2, 0xe4a78d37,\n    0x2ffb5e92, 0xa96f2c3c, 0x6233ff99, 0x7f36cf21, 0xb46a1c84,\n    0x32fe6e2a, 0xf9a2bd8f, 0x0b220dc1, 0xc07ede64, 0x46eaacca,\n    0x8db67f6f, 0x90b34fd7, 0x5bef9c72, 0xdd7beedc, 0x16273d79,\n    0xe7718fac, 0x2c2d5c09, 0xaab92ea7, 0x61e5fd02, 0x7ce0cdba,\n    0xb7bc1e1f, 0x31286cb1, 0xfa74bf14, 0x1eb014d8, 0xd5ecc77d,\n    0x5378b5d3, 0x98246676, 0x852156ce, 0x4e7d856b, 0xc8e9f7c5,\n    0x03b52460, 0xf2e396b5, 0x39bf4510, 0xbf2b37be, 0x7477e41b,\n    0x6972d4a3, 0xa22e0706, 0x24ba75a8, 0xefe6a60d, 0x1d661643,\n    0xd63ac5e6, 0x50aeb748, 0x9bf264ed, 0x86f75455, 0x4dab87f0,\n    0xcb3ff55e, 0x006326fb, 0xf135942e, 0x3a69478b, 0xbcfd3525,\n    0x77a1e680, 0x6aa4d638, 0xa1f8059d, 0x276c7733, 0xec30a496,\n    0x191c11ee, 0xd240c24b, 0x54d4b0e5, 0x9f886340, 0x828d53f8,\n    0x49d1805d, 0xcf45f2f3, 0x04192156, 0xf54f9383, 0x3e134026,\n    0xb8873288, 0x73dbe12d, 0x6eded195, 0xa5820230, 0x2316709e,\n    0xe84aa33b, 0x1aca1375, 0xd196c0d0, 0x5702b27e, 0x9c5e61db,\n    0x815b5163, 0x4a0782c6, 0xcc93f068, 0x07cf23cd, 0xf6999118,\n    0x3dc542bd, 0xbb513013, 0x700de3b6, 0x6d08d30e, 0xa65400ab,\n    0x20c07205, 0xeb9ca1a0, 0x11e81eb4, 0xdab4cd11, 0x5c20bfbf,\n    0x977c6c1a, 0x8a795ca2, 0x41258f07, 0xc7b1fda9, 0x0ced2e0c,\n    0xfdbb9cd9, 0x36e74f7c, 0xb0733dd2, 0x7b2fee77, 0x662adecf,\n    0xad760d6a, 0x2be27fc4, 0xe0beac61, 0x123e1c2f, 0xd962cf8a,\n    0x5ff6bd24, 0x94aa6e81, 0x89af5e39, 0x42f38d9c, 0xc467ff32,\n    0x0f3b2c97, 0xfe6d9e42, 0x35314de7, 0xb3a53f49, 0x78f9ecec,\n    0x65fcdc54, 0xaea00ff1, 0x28347d5f, 0xe368aefa, 0x16441b82,\n    0xdd18c827, 0x5b8cba89, 0x90d0692c, 0x8dd55994, 0x46898a31,\n    0xc01df89f, 0x0b412b3a, 0xfa1799ef, 0x314b4a4a, 0xb7df38e4,\n    0x7c83eb41, 0x6186dbf9, 0xaada085c, 0x2c4e7af2, 0xe712a957,\n    0x15921919, 0xdececabc, 0x585ab812, 0x93066bb7, 0x8e035b0f,\n    0x455f88aa, 0xc3cbfa04, 0x089729a1, 0xf9c19b74, 0x329d48d1,\n    0xb4093a7f, 0x7f55e9da, 0x6250d962, 0xa90c0ac7, 0x2f987869,\n    0xe4c4abcc},\n   {0x00000000, 0x3d6029b0, 0x7ac05360, 0x47a07ad0, 0xf580a6c0,\n    0xc8e08f70, 0x8f40f5a0, 0xb220dc10, 0x30704bc1, 0x0d106271,\n    0x4ab018a1, 0x77d03111, 0xc5f0ed01, 0xf890c4b1, 0xbf30be61,\n    0x825097d1, 0x60e09782, 0x5d80be32, 0x1a20c4e2, 0x2740ed52,\n    0x95603142, 0xa80018f2, 0xefa06222, 0xd2c04b92, 0x5090dc43,\n    0x6df0f5f3, 0x2a508f23, 0x1730a693, 0xa5107a83, 0x98705333,\n    0xdfd029e3, 0xe2b00053, 0xc1c12f04, 0xfca106b4, 0xbb017c64,\n    0x866155d4, 0x344189c4, 0x0921a074, 0x4e81daa4, 0x73e1f314,\n    0xf1b164c5, 0xccd14d75, 0x8b7137a5, 0xb6111e15, 0x0431c205,\n    0x3951ebb5, 0x7ef19165, 0x4391b8d5, 0xa121b886, 0x9c419136,\n    0xdbe1ebe6, 0xe681c256, 0x54a11e46, 0x69c137f6, 0x2e614d26,\n    0x13016496, 0x9151f347, 0xac31daf7, 0xeb91a027, 0xd6f18997,\n    0x64d15587, 0x59b17c37, 0x1e1106e7, 0x23712f57, 0x58f35849,\n    0x659371f9, 0x22330b29, 0x1f532299, 0xad73fe89, 0x9013d739,\n    0xd7b3ade9, 0xead38459, 0x68831388, 0x55e33a38, 0x124340e8,\n    0x2f236958, 0x9d03b548, 0xa0639cf8, 0xe7c3e628, 0xdaa3cf98,\n    0x3813cfcb, 0x0573e67b, 0x42d39cab, 0x7fb3b51b, 0xcd93690b,\n    0xf0f340bb, 0xb7533a6b, 0x8a3313db, 0x0863840a, 0x3503adba,\n    0x72a3d76a, 0x4fc3feda, 0xfde322ca, 0xc0830b7a, 0x872371aa,\n    0xba43581a, 0x9932774d, 0xa4525efd, 0xe3f2242d, 0xde920d9d,\n    0x6cb2d18d, 0x51d2f83d, 0x167282ed, 0x2b12ab5d, 0xa9423c8c,\n    0x9422153c, 0xd3826fec, 0xeee2465c, 0x5cc29a4c, 0x61a2b3fc,\n    0x2602c92c, 0x1b62e09c, 0xf9d2e0cf, 0xc4b2c97f, 0x8312b3af,\n    0xbe729a1f, 0x0c52460f, 0x31326fbf, 0x7692156f, 0x4bf23cdf,\n    0xc9a2ab0e, 0xf4c282be, 0xb362f86e, 0x8e02d1de, 0x3c220dce,\n    0x0142247e, 0x46e25eae, 0x7b82771e, 0xb1e6b092, 0x8c869922,\n    0xcb26e3f2, 0xf646ca42, 0x44661652, 0x79063fe2, 0x3ea64532,\n    0x03c66c82, 0x8196fb53, 0xbcf6d2e3, 0xfb56a833, 0xc6368183,\n    0x74165d93, 0x49767423, 0x0ed60ef3, 0x33b62743, 0xd1062710,\n    0xec660ea0, 0xabc67470, 0x96a65dc0, 0x248681d0, 0x19e6a860,\n    0x5e46d2b0, 0x6326fb00, 0xe1766cd1, 0xdc164561, 0x9bb63fb1,\n    0xa6d61601, 0x14f6ca11, 0x2996e3a1, 0x6e369971, 0x5356b0c1,\n    0x70279f96, 0x4d47b626, 0x0ae7ccf6, 0x3787e546, 0x85a73956,\n    0xb8c710e6, 0xff676a36, 0xc2074386, 0x4057d457, 0x7d37fde7,\n    0x3a978737, 0x07f7ae87, 0xb5d77297, 0x88b75b27, 0xcf1721f7,\n    0xf2770847, 0x10c70814, 0x2da721a4, 0x6a075b74, 0x576772c4,\n    0xe547aed4, 0xd8278764, 0x9f87fdb4, 0xa2e7d404, 0x20b743d5,\n    0x1dd76a65, 0x5a7710b5, 0x67173905, 0xd537e515, 0xe857cca5,\n    0xaff7b675, 0x92979fc5, 0xe915e8db, 0xd475c16b, 0x93d5bbbb,\n    0xaeb5920b, 0x1c954e1b, 0x21f567ab, 0x66551d7b, 0x5b3534cb,\n    0xd965a31a, 0xe4058aaa, 0xa3a5f07a, 0x9ec5d9ca, 0x2ce505da,\n    0x11852c6a, 0x562556ba, 0x6b457f0a, 0x89f57f59, 0xb49556e9,\n    0xf3352c39, 0xce550589, 0x7c75d999, 0x4115f029, 0x06b58af9,\n    0x3bd5a349, 0xb9853498, 0x84e51d28, 0xc34567f8, 0xfe254e48,\n    0x4c059258, 0x7165bbe8, 0x36c5c138, 0x0ba5e888, 0x28d4c7df,\n    0x15b4ee6f, 0x521494bf, 0x6f74bd0f, 0xdd54611f, 0xe03448af,\n    0xa794327f, 0x9af41bcf, 0x18a48c1e, 0x25c4a5ae, 0x6264df7e,\n    0x5f04f6ce, 0xed242ade, 0xd044036e, 0x97e479be, 0xaa84500e,\n    0x4834505d, 0x755479ed, 0x32f4033d, 0x0f942a8d, 0xbdb4f69d,\n    0x80d4df2d, 0xc774a5fd, 0xfa148c4d, 0x78441b9c, 0x4524322c,\n    0x028448fc, 0x3fe4614c, 0x8dc4bd5c, 0xb0a494ec, 0xf704ee3c,\n    0xca64c78c},\n   {0x00000000, 0xb8bc6765, 0xaa09c88b, 0x12b5afee, 0x8f629757,\n    0x37def032, 0x256b5fdc, 0x9dd738b9, 0xc5b428ef, 0x7d084f8a,\n    0x6fbde064, 0xd7018701, 0x4ad6bfb8, 0xf26ad8dd, 0xe0df7733,\n    0x58631056, 0x5019579f, 0xe8a530fa, 0xfa109f14, 0x42acf871,\n    0xdf7bc0c8, 0x67c7a7ad, 0x75720843, 0xcdce6f26, 0x95ad7f70,\n    0x2d111815, 0x3fa4b7fb, 0x8718d09e, 0x1acfe827, 0xa2738f42,\n    0xb0c620ac, 0x087a47c9, 0xa032af3e, 0x188ec85b, 0x0a3b67b5,\n    0xb28700d0, 0x2f503869, 0x97ec5f0c, 0x8559f0e2, 0x3de59787,\n    0x658687d1, 0xdd3ae0b4, 0xcf8f4f5a, 0x7733283f, 0xeae41086,\n    0x525877e3, 0x40edd80d, 0xf851bf68, 0xf02bf8a1, 0x48979fc4,\n    0x5a22302a, 0xe29e574f, 0x7f496ff6, 0xc7f50893, 0xd540a77d,\n    0x6dfcc018, 0x359fd04e, 0x8d23b72b, 0x9f9618c5, 0x272a7fa0,\n    0xbafd4719, 0x0241207c, 0x10f48f92, 0xa848e8f7, 0x9b14583d,\n    0x23a83f58, 0x311d90b6, 0x89a1f7d3, 0x1476cf6a, 0xaccaa80f,\n    0xbe7f07e1, 0x06c36084, 0x5ea070d2, 0xe61c17b7, 0xf4a9b859,\n    0x4c15df3c, 0xd1c2e785, 0x697e80e0, 0x7bcb2f0e, 0xc377486b,\n    0xcb0d0fa2, 0x73b168c7, 0x6104c729, 0xd9b8a04c, 0x446f98f5,\n    0xfcd3ff90, 0xee66507e, 0x56da371b, 0x0eb9274d, 0xb6054028,\n    0xa4b0efc6, 0x1c0c88a3, 0x81dbb01a, 0x3967d77f, 0x2bd27891,\n    0x936e1ff4, 0x3b26f703, 0x839a9066, 0x912f3f88, 0x299358ed,\n    0xb4446054, 0x0cf80731, 0x1e4da8df, 0xa6f1cfba, 0xfe92dfec,\n    0x462eb889, 0x549b1767, 0xec277002, 0x71f048bb, 0xc94c2fde,\n    0xdbf98030, 0x6345e755, 0x6b3fa09c, 0xd383c7f9, 0xc1366817,\n    0x798a0f72, 0xe45d37cb, 0x5ce150ae, 0x4e54ff40, 0xf6e89825,\n    0xae8b8873, 0x1637ef16, 0x048240f8, 0xbc3e279d, 0x21e91f24,\n    0x99557841, 0x8be0d7af, 0x335cb0ca, 0xed59b63b, 0x55e5d15e,\n    0x47507eb0, 0xffec19d5, 0x623b216c, 0xda874609, 0xc832e9e7,\n    0x708e8e82, 0x28ed9ed4, 0x9051f9b1, 0x82e4565f, 0x3a58313a,\n    0xa78f0983, 0x1f336ee6, 0x0d86c108, 0xb53aa66d, 0xbd40e1a4,\n    0x05fc86c1, 0x1749292f, 0xaff54e4a, 0x322276f3, 0x8a9e1196,\n    0x982bbe78, 0x2097d91d, 0x78f4c94b, 0xc048ae2e, 0xd2fd01c0,\n    0x6a4166a5, 0xf7965e1c, 0x4f2a3979, 0x5d9f9697, 0xe523f1f2,\n    0x4d6b1905, 0xf5d77e60, 0xe762d18e, 0x5fdeb6eb, 0xc2098e52,\n    0x7ab5e937, 0x680046d9, 0xd0bc21bc, 0x88df31ea, 0x3063568f,\n    0x22d6f961, 0x9a6a9e04, 0x07bda6bd, 0xbf01c1d8, 0xadb46e36,\n    0x15080953, 0x1d724e9a, 0xa5ce29ff, 0xb77b8611, 0x0fc7e174,\n    0x9210d9cd, 0x2aacbea8, 0x38191146, 0x80a57623, 0xd8c66675,\n    0x607a0110, 0x72cfaefe, 0xca73c99b, 0x57a4f122, 0xef189647,\n    0xfdad39a9, 0x45115ecc, 0x764dee06, 0xcef18963, 0xdc44268d,\n    0x64f841e8, 0xf92f7951, 0x41931e34, 0x5326b1da, 0xeb9ad6bf,\n    0xb3f9c6e9, 0x0b45a18c, 0x19f00e62, 0xa14c6907, 0x3c9b51be,\n    0x842736db, 0x96929935, 0x2e2efe50, 0x2654b999, 0x9ee8defc,\n    0x8c5d7112, 0x34e11677, 0xa9362ece, 0x118a49ab, 0x033fe645,\n    0xbb838120, 0xe3e09176, 0x5b5cf613, 0x49e959fd, 0xf1553e98,\n    0x6c820621, 0xd43e6144, 0xc68bceaa, 0x7e37a9cf, 0xd67f4138,\n    0x6ec3265d, 0x7c7689b3, 0xc4caeed6, 0x591dd66f, 0xe1a1b10a,\n    0xf3141ee4, 0x4ba87981, 0x13cb69d7, 0xab770eb2, 0xb9c2a15c,\n    0x017ec639, 0x9ca9fe80, 0x241599e5, 0x36a0360b, 0x8e1c516e,\n    0x866616a7, 0x3eda71c2, 0x2c6fde2c, 0x94d3b949, 0x090481f0,\n    0xb1b8e695, 0xa30d497b, 0x1bb12e1e, 0x43d23e48, 0xfb6e592d,\n    0xe9dbf6c3, 0x516791a6, 0xccb0a91f, 0x740cce7a, 0x66b96194,\n    0xde0506f1},\n   {0x00000000, 0x01c26a37, 0x0384d46e, 0x0246be59, 0x0709a8dc,\n    0x06cbc2eb, 0x048d7cb2, 0x054f1685, 0x0e1351b8, 0x0fd13b8f,\n    0x0d9785d6, 0x0c55efe1, 0x091af964, 0x08d89353, 0x0a9e2d0a,\n    0x0b5c473d, 0x1c26a370, 0x1de4c947, 0x1fa2771e, 0x1e601d29,\n    0x1b2f0bac, 0x1aed619b, 0x18abdfc2, 0x1969b5f5, 0x1235f2c8,\n    0x13f798ff, 0x11b126a6, 0x10734c91, 0x153c5a14, 0x14fe3023,\n    0x16b88e7a, 0x177ae44d, 0x384d46e0, 0x398f2cd7, 0x3bc9928e,\n    0x3a0bf8b9, 0x3f44ee3c, 0x3e86840b, 0x3cc03a52, 0x3d025065,\n    0x365e1758, 0x379c7d6f, 0x35dac336, 0x3418a901, 0x3157bf84,\n    0x3095d5b3, 0x32d36bea, 0x331101dd, 0x246be590, 0x25a98fa7,\n    0x27ef31fe, 0x262d5bc9, 0x23624d4c, 0x22a0277b, 0x20e69922,\n    0x2124f315, 0x2a78b428, 0x2bbade1f, 0x29fc6046, 0x283e0a71,\n    0x2d711cf4, 0x2cb376c3, 0x2ef5c89a, 0x2f37a2ad, 0x709a8dc0,\n    0x7158e7f7, 0x731e59ae, 0x72dc3399, 0x7793251c, 0x76514f2b,\n    0x7417f172, 0x75d59b45, 0x7e89dc78, 0x7f4bb64f, 0x7d0d0816,\n    0x7ccf6221, 0x798074a4, 0x78421e93, 0x7a04a0ca, 0x7bc6cafd,\n    0x6cbc2eb0, 0x6d7e4487, 0x6f38fade, 0x6efa90e9, 0x6bb5866c,\n    0x6a77ec5b, 0x68315202, 0x69f33835, 0x62af7f08, 0x636d153f,\n    0x612bab66, 0x60e9c151, 0x65a6d7d4, 0x6464bde3, 0x662203ba,\n    0x67e0698d, 0x48d7cb20, 0x4915a117, 0x4b531f4e, 0x4a917579,\n    0x4fde63fc, 0x4e1c09cb, 0x4c5ab792, 0x4d98dda5, 0x46c49a98,\n    0x4706f0af, 0x45404ef6, 0x448224c1, 0x41cd3244, 0x400f5873,\n    0x4249e62a, 0x438b8c1d, 0x54f16850, 0x55330267, 0x5775bc3e,\n    0x56b7d609, 0x53f8c08c, 0x523aaabb, 0x507c14e2, 0x51be7ed5,\n    0x5ae239e8, 0x5b2053df, 0x5966ed86, 0x58a487b1, 0x5deb9134,\n    0x5c29fb03, 0x5e6f455a, 0x5fad2f6d, 0xe1351b80, 0xe0f771b7,\n    0xe2b1cfee, 0xe373a5d9, 0xe63cb35c, 0xe7fed96b, 0xe5b86732,\n    0xe47a0d05, 0xef264a38, 0xeee4200f, 0xeca29e56, 0xed60f461,\n    0xe82fe2e4, 0xe9ed88d3, 0xebab368a, 0xea695cbd, 0xfd13b8f0,\n    0xfcd1d2c7, 0xfe976c9e, 0xff5506a9, 0xfa1a102c, 0xfbd87a1b,\n    0xf99ec442, 0xf85cae75, 0xf300e948, 0xf2c2837f, 0xf0843d26,\n    0xf1465711, 0xf4094194, 0xf5cb2ba3, 0xf78d95fa, 0xf64fffcd,\n    0xd9785d60, 0xd8ba3757, 0xdafc890e, 0xdb3ee339, 0xde71f5bc,\n    0xdfb39f8b, 0xddf521d2, 0xdc374be5, 0xd76b0cd8, 0xd6a966ef,\n    0xd4efd8b6, 0xd52db281, 0xd062a404, 0xd1a0ce33, 0xd3e6706a,\n    0xd2241a5d, 0xc55efe10, 0xc49c9427, 0xc6da2a7e, 0xc7184049,\n    0xc25756cc, 0xc3953cfb, 0xc1d382a2, 0xc011e895, 0xcb4dafa8,\n    0xca8fc59f, 0xc8c97bc6, 0xc90b11f1, 0xcc440774, 0xcd866d43,\n    0xcfc0d31a, 0xce02b92d, 0x91af9640, 0x906dfc77, 0x922b422e,\n    0x93e92819, 0x96a63e9c, 0x976454ab, 0x9522eaf2, 0x94e080c5,\n    0x9fbcc7f8, 0x9e7eadcf, 0x9c381396, 0x9dfa79a1, 0x98b56f24,\n    0x99770513, 0x9b31bb4a, 0x9af3d17d, 0x8d893530, 0x8c4b5f07,\n    0x8e0de15e, 0x8fcf8b69, 0x8a809dec, 0x8b42f7db, 0x89044982,\n    0x88c623b5, 0x839a6488, 0x82580ebf, 0x801eb0e6, 0x81dcdad1,\n    0x8493cc54, 0x8551a663, 0x8717183a, 0x86d5720d, 0xa9e2d0a0,\n    0xa820ba97, 0xaa6604ce, 0xaba46ef9, 0xaeeb787c, 0xaf29124b,\n    0xad6fac12, 0xacadc625, 0xa7f18118, 0xa633eb2f, 0xa4755576,\n    0xa5b73f41, 0xa0f829c4, 0xa13a43f3, 0xa37cfdaa, 0xa2be979d,\n    0xb5c473d0, 0xb40619e7, 0xb640a7be, 0xb782cd89, 0xb2cddb0c,\n    0xb30fb13b, 0xb1490f62, 0xb08b6555, 0xbbd72268, 0xba15485f,\n    0xb853f606, 0xb9919c31, 0xbcde8ab4, 0xbd1ce083, 0xbf5a5eda,\n    0xbe9834ed},\n   {0x00000000, 0x191b3141, 0x32366282, 0x2b2d53c3, 0x646cc504,\n    0x7d77f445, 0x565aa786, 0x4f4196c7, 0xc8d98a08, 0xd1c2bb49,\n    0xfaefe88a, 0xe3f4d9cb, 0xacb54f0c, 0xb5ae7e4d, 0x9e832d8e,\n    0x87981ccf, 0x4ac21251, 0x53d92310, 0x78f470d3, 0x61ef4192,\n    0x2eaed755, 0x37b5e614, 0x1c98b5d7, 0x05838496, 0x821b9859,\n    0x9b00a918, 0xb02dfadb, 0xa936cb9a, 0xe6775d5d, 0xff6c6c1c,\n    0xd4413fdf, 0xcd5a0e9e, 0x958424a2, 0x8c9f15e3, 0xa7b24620,\n    0xbea97761, 0xf1e8e1a6, 0xe8f3d0e7, 0xc3de8324, 0xdac5b265,\n    0x5d5daeaa, 0x44469feb, 0x6f6bcc28, 0x7670fd69, 0x39316bae,\n    0x202a5aef, 0x0b07092c, 0x121c386d, 0xdf4636f3, 0xc65d07b2,\n    0xed705471, 0xf46b6530, 0xbb2af3f7, 0xa231c2b6, 0x891c9175,\n    0x9007a034, 0x179fbcfb, 0x0e848dba, 0x25a9de79, 0x3cb2ef38,\n    0x73f379ff, 0x6ae848be, 0x41c51b7d, 0x58de2a3c, 0xf0794f05,\n    0xe9627e44, 0xc24f2d87, 0xdb541cc6, 0x94158a01, 0x8d0ebb40,\n    0xa623e883, 0xbf38d9c2, 0x38a0c50d, 0x21bbf44c, 0x0a96a78f,\n    0x138d96ce, 0x5ccc0009, 0x45d73148, 0x6efa628b, 0x77e153ca,\n    0xbabb5d54, 0xa3a06c15, 0x888d3fd6, 0x91960e97, 0xded79850,\n    0xc7cca911, 0xece1fad2, 0xf5facb93, 0x7262d75c, 0x6b79e61d,\n    0x4054b5de, 0x594f849f, 0x160e1258, 0x0f152319, 0x243870da,\n    0x3d23419b, 0x65fd6ba7, 0x7ce65ae6, 0x57cb0925, 0x4ed03864,\n    0x0191aea3, 0x188a9fe2, 0x33a7cc21, 0x2abcfd60, 0xad24e1af,\n    0xb43fd0ee, 0x9f12832d, 0x8609b26c, 0xc94824ab, 0xd05315ea,\n    0xfb7e4629, 0xe2657768, 0x2f3f79f6, 0x362448b7, 0x1d091b74,\n    0x04122a35, 0x4b53bcf2, 0x52488db3, 0x7965de70, 0x607eef31,\n    0xe7e6f3fe, 0xfefdc2bf, 0xd5d0917c, 0xcccba03d, 0x838a36fa,\n    0x9a9107bb, 0xb1bc5478, 0xa8a76539, 0x3b83984b, 0x2298a90a,\n    0x09b5fac9, 0x10aecb88, 0x5fef5d4f, 0x46f46c0e, 0x6dd93fcd,\n    0x74c20e8c, 0xf35a1243, 0xea412302, 0xc16c70c1, 0xd8774180,\n    0x9736d747, 0x8e2de606, 0xa500b5c5, 0xbc1b8484, 0x71418a1a,\n    0x685abb5b, 0x4377e898, 0x5a6cd9d9, 0x152d4f1e, 0x0c367e5f,\n    0x271b2d9c, 0x3e001cdd, 0xb9980012, 0xa0833153, 0x8bae6290,\n    0x92b553d1, 0xddf4c516, 0xc4eff457, 0xefc2a794, 0xf6d996d5,\n    0xae07bce9, 0xb71c8da8, 0x9c31de6b, 0x852aef2a, 0xca6b79ed,\n    0xd37048ac, 0xf85d1b6f, 0xe1462a2e, 0x66de36e1, 0x7fc507a0,\n    0x54e85463, 0x4df36522, 0x02b2f3e5, 0x1ba9c2a4, 0x30849167,\n    0x299fa026, 0xe4c5aeb8, 0xfdde9ff9, 0xd6f3cc3a, 0xcfe8fd7b,\n    0x80a96bbc, 0x99b25afd, 0xb29f093e, 0xab84387f, 0x2c1c24b0,\n    0x350715f1, 0x1e2a4632, 0x07317773, 0x4870e1b4, 0x516bd0f5,\n    0x7a468336, 0x635db277, 0xcbfad74e, 0xd2e1e60f, 0xf9ccb5cc,\n    0xe0d7848d, 0xaf96124a, 0xb68d230b, 0x9da070c8, 0x84bb4189,\n    0x03235d46, 0x1a386c07, 0x31153fc4, 0x280e0e85, 0x674f9842,\n    0x7e54a903, 0x5579fac0, 0x4c62cb81, 0x8138c51f, 0x9823f45e,\n    0xb30ea79d, 0xaa1596dc, 0xe554001b, 0xfc4f315a, 0xd7626299,\n    0xce7953d8, 0x49e14f17, 0x50fa7e56, 0x7bd72d95, 0x62cc1cd4,\n    0x2d8d8a13, 0x3496bb52, 0x1fbbe891, 0x06a0d9d0, 0x5e7ef3ec,\n    0x4765c2ad, 0x6c48916e, 0x7553a02f, 0x3a1236e8, 0x230907a9,\n    0x0824546a, 0x113f652b, 0x96a779e4, 0x8fbc48a5, 0xa4911b66,\n    0xbd8a2a27, 0xf2cbbce0, 0xebd08da1, 0xc0fdde62, 0xd9e6ef23,\n    0x14bce1bd, 0x0da7d0fc, 0x268a833f, 0x3f91b27e, 0x70d024b9,\n    0x69cb15f8, 0x42e6463b, 0x5bfd777a, 0xdc656bb5, 0xc57e5af4,\n    0xee530937, 0xf7483876, 0xb809aeb1, 0xa1129ff0, 0x8a3fcc33,\n    0x9324fd72},\n   {0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419,\n    0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4,\n    0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07,\n    0x90bf1d91, 0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de,\n    0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856,\n    0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,\n    0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4,\n    0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,\n    0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3,\n    0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a,\n    0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599,\n    0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,\n    0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190,\n    0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f,\n    0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f934, 0x9609a88e,\n    0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,\n    0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed,\n    0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,\n    0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3,\n    0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2,\n    0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a,\n    0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5,\n    0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010,\n    0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,\n    0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17,\n    0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6,\n    0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615,\n    0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8,\n    0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, 0xf00f9344,\n    0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,\n    0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a,\n    0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,\n    0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1,\n    0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c,\n    0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef,\n    0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,\n    0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe,\n    0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31,\n    0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c,\n    0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,\n    0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b,\n    0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,\n    0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1,\n    0x18b74777, 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c,\n    0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278,\n    0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7,\n    0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66,\n    0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,\n    0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605,\n    0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8,\n    0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b,\n    0x2d02ef8d}};\n\nlocal const z_word_t FAR crc_braid_big_table[][256] = {\n   {0x0000000000000000, 0x9630077700000000, 0x2c610eee00000000,\n    0xba51099900000000, 0x19c46d0700000000, 0x8ff46a7000000000,\n    0x35a563e900000000, 0xa395649e00000000, 0x3288db0e00000000,\n    0xa4b8dc7900000000, 0x1ee9d5e000000000, 0x88d9d29700000000,\n    0x2b4cb60900000000, 0xbd7cb17e00000000, 0x072db8e700000000,\n    0x911dbf9000000000, 0x6410b71d00000000, 0xf220b06a00000000,\n    0x4871b9f300000000, 0xde41be8400000000, 0x7dd4da1a00000000,\n    0xebe4dd6d00000000, 0x51b5d4f400000000, 0xc785d38300000000,\n    0x56986c1300000000, 0xc0a86b6400000000, 0x7af962fd00000000,\n    0xecc9658a00000000, 0x4f5c011400000000, 0xd96c066300000000,\n    0x633d0ffa00000000, 0xf50d088d00000000, 0xc8206e3b00000000,\n    0x5e10694c00000000, 0xe44160d500000000, 0x727167a200000000,\n    0xd1e4033c00000000, 0x47d4044b00000000, 0xfd850dd200000000,\n    0x6bb50aa500000000, 0xfaa8b53500000000, 0x6c98b24200000000,\n    0xd6c9bbdb00000000, 0x40f9bcac00000000, 0xe36cd83200000000,\n    0x755cdf4500000000, 0xcf0dd6dc00000000, 0x593dd1ab00000000,\n    0xac30d92600000000, 0x3a00de5100000000, 0x8051d7c800000000,\n    0x1661d0bf00000000, 0xb5f4b42100000000, 0x23c4b35600000000,\n    0x9995bacf00000000, 0x0fa5bdb800000000, 0x9eb8022800000000,\n    0x0888055f00000000, 0xb2d90cc600000000, 0x24e90bb100000000,\n    0x877c6f2f00000000, 0x114c685800000000, 0xab1d61c100000000,\n    0x3d2d66b600000000, 0x9041dc7600000000, 0x0671db0100000000,\n    0xbc20d29800000000, 0x2a10d5ef00000000, 0x8985b17100000000,\n    0x1fb5b60600000000, 0xa5e4bf9f00000000, 0x33d4b8e800000000,\n    0xa2c9077800000000, 0x34f9000f00000000, 0x8ea8099600000000,\n    0x18980ee100000000, 0xbb0d6a7f00000000, 0x2d3d6d0800000000,\n    0x976c649100000000, 0x015c63e600000000, 0xf4516b6b00000000,\n    0x62616c1c00000000, 0xd830658500000000, 0x4e0062f200000000,\n    0xed95066c00000000, 0x7ba5011b00000000, 0xc1f4088200000000,\n    0x57c40ff500000000, 0xc6d9b06500000000, 0x50e9b71200000000,\n    0xeab8be8b00000000, 0x7c88b9fc00000000, 0xdf1ddd6200000000,\n    0x492dda1500000000, 0xf37cd38c00000000, 0x654cd4fb00000000,\n    0x5861b24d00000000, 0xce51b53a00000000, 0x7400bca300000000,\n    0xe230bbd400000000, 0x41a5df4a00000000, 0xd795d83d00000000,\n    0x6dc4d1a400000000, 0xfbf4d6d300000000, 0x6ae9694300000000,\n    0xfcd96e3400000000, 0x468867ad00000000, 0xd0b860da00000000,\n    0x732d044400000000, 0xe51d033300000000, 0x5f4c0aaa00000000,\n    0xc97c0ddd00000000, 0x3c71055000000000, 0xaa41022700000000,\n    0x10100bbe00000000, 0x86200cc900000000, 0x25b5685700000000,\n    0xb3856f2000000000, 0x09d466b900000000, 0x9fe461ce00000000,\n    0x0ef9de5e00000000, 0x98c9d92900000000, 0x2298d0b000000000,\n    0xb4a8d7c700000000, 0x173db35900000000, 0x810db42e00000000,\n    0x3b5cbdb700000000, 0xad6cbac000000000, 0x2083b8ed00000000,\n    0xb6b3bf9a00000000, 0x0ce2b60300000000, 0x9ad2b17400000000,\n    0x3947d5ea00000000, 0xaf77d29d00000000, 0x1526db0400000000,\n    0x8316dc7300000000, 0x120b63e300000000, 0x843b649400000000,\n    0x3e6a6d0d00000000, 0xa85a6a7a00000000, 0x0bcf0ee400000000,\n    0x9dff099300000000, 0x27ae000a00000000, 0xb19e077d00000000,\n    0x44930ff000000000, 0xd2a3088700000000, 0x68f2011e00000000,\n    0xfec2066900000000, 0x5d5762f700000000, 0xcb67658000000000,\n    0x71366c1900000000, 0xe7066b6e00000000, 0x761bd4fe00000000,\n    0xe02bd38900000000, 0x5a7ada1000000000, 0xcc4add6700000000,\n    0x6fdfb9f900000000, 0xf9efbe8e00000000, 0x43beb71700000000,\n    0xd58eb06000000000, 0xe8a3d6d600000000, 0x7e93d1a100000000,\n    0xc4c2d83800000000, 0x52f2df4f00000000, 0xf167bbd100000000,\n    0x6757bca600000000, 0xdd06b53f00000000, 0x4b36b24800000000,\n    0xda2b0dd800000000, 0x4c1b0aaf00000000, 0xf64a033600000000,\n    0x607a044100000000, 0xc3ef60df00000000, 0x55df67a800000000,\n    0xef8e6e3100000000, 0x79be694600000000, 0x8cb361cb00000000,\n    0x1a8366bc00000000, 0xa0d26f2500000000, 0x36e2685200000000,\n    0x95770ccc00000000, 0x03470bbb00000000, 0xb916022200000000,\n    0x2f26055500000000, 0xbe3bbac500000000, 0x280bbdb200000000,\n    0x925ab42b00000000, 0x046ab35c00000000, 0xa7ffd7c200000000,\n    0x31cfd0b500000000, 0x8b9ed92c00000000, 0x1daede5b00000000,\n    0xb0c2649b00000000, 0x26f263ec00000000, 0x9ca36a7500000000,\n    0x0a936d0200000000, 0xa906099c00000000, 0x3f360eeb00000000,\n    0x8567077200000000, 0x1357000500000000, 0x824abf9500000000,\n    0x147ab8e200000000, 0xae2bb17b00000000, 0x381bb60c00000000,\n    0x9b8ed29200000000, 0x0dbed5e500000000, 0xb7efdc7c00000000,\n    0x21dfdb0b00000000, 0xd4d2d38600000000, 0x42e2d4f100000000,\n    0xf8b3dd6800000000, 0x6e83da1f00000000, 0xcd16be8100000000,\n    0x5b26b9f600000000, 0xe177b06f00000000, 0x7747b71800000000,\n    0xe65a088800000000, 0x706a0fff00000000, 0xca3b066600000000,\n    0x5c0b011100000000, 0xff9e658f00000000, 0x69ae62f800000000,\n    0xd3ff6b6100000000, 0x45cf6c1600000000, 0x78e20aa000000000,\n    0xeed20dd700000000, 0x5483044e00000000, 0xc2b3033900000000,\n    0x612667a700000000, 0xf71660d000000000, 0x4d47694900000000,\n    0xdb776e3e00000000, 0x4a6ad1ae00000000, 0xdc5ad6d900000000,\n    0x660bdf4000000000, 0xf03bd83700000000, 0x53aebca900000000,\n    0xc59ebbde00000000, 0x7fcfb24700000000, 0xe9ffb53000000000,\n    0x1cf2bdbd00000000, 0x8ac2baca00000000, 0x3093b35300000000,\n    0xa6a3b42400000000, 0x0536d0ba00000000, 0x9306d7cd00000000,\n    0x2957de5400000000, 0xbf67d92300000000, 0x2e7a66b300000000,\n    0xb84a61c400000000, 0x021b685d00000000, 0x942b6f2a00000000,\n    0x37be0bb400000000, 0xa18e0cc300000000, 0x1bdf055a00000000,\n    0x8def022d00000000},\n   {0x0000000000000000, 0x41311b1900000000, 0x8262363200000000,\n    0xc3532d2b00000000, 0x04c56c6400000000, 0x45f4777d00000000,\n    0x86a75a5600000000, 0xc796414f00000000, 0x088ad9c800000000,\n    0x49bbc2d100000000, 0x8ae8effa00000000, 0xcbd9f4e300000000,\n    0x0c4fb5ac00000000, 0x4d7eaeb500000000, 0x8e2d839e00000000,\n    0xcf1c988700000000, 0x5112c24a00000000, 0x1023d95300000000,\n    0xd370f47800000000, 0x9241ef6100000000, 0x55d7ae2e00000000,\n    0x14e6b53700000000, 0xd7b5981c00000000, 0x9684830500000000,\n    0x59981b8200000000, 0x18a9009b00000000, 0xdbfa2db000000000,\n    0x9acb36a900000000, 0x5d5d77e600000000, 0x1c6c6cff00000000,\n    0xdf3f41d400000000, 0x9e0e5acd00000000, 0xa224849500000000,\n    0xe3159f8c00000000, 0x2046b2a700000000, 0x6177a9be00000000,\n    0xa6e1e8f100000000, 0xe7d0f3e800000000, 0x2483dec300000000,\n    0x65b2c5da00000000, 0xaaae5d5d00000000, 0xeb9f464400000000,\n    0x28cc6b6f00000000, 0x69fd707600000000, 0xae6b313900000000,\n    0xef5a2a2000000000, 0x2c09070b00000000, 0x6d381c1200000000,\n    0xf33646df00000000, 0xb2075dc600000000, 0x715470ed00000000,\n    0x30656bf400000000, 0xf7f32abb00000000, 0xb6c231a200000000,\n    0x75911c8900000000, 0x34a0079000000000, 0xfbbc9f1700000000,\n    0xba8d840e00000000, 0x79dea92500000000, 0x38efb23c00000000,\n    0xff79f37300000000, 0xbe48e86a00000000, 0x7d1bc54100000000,\n    0x3c2ade5800000000, 0x054f79f000000000, 0x447e62e900000000,\n    0x872d4fc200000000, 0xc61c54db00000000, 0x018a159400000000,\n    0x40bb0e8d00000000, 0x83e823a600000000, 0xc2d938bf00000000,\n    0x0dc5a03800000000, 0x4cf4bb2100000000, 0x8fa7960a00000000,\n    0xce968d1300000000, 0x0900cc5c00000000, 0x4831d74500000000,\n    0x8b62fa6e00000000, 0xca53e17700000000, 0x545dbbba00000000,\n    0x156ca0a300000000, 0xd63f8d8800000000, 0x970e969100000000,\n    0x5098d7de00000000, 0x11a9ccc700000000, 0xd2fae1ec00000000,\n    0x93cbfaf500000000, 0x5cd7627200000000, 0x1de6796b00000000,\n    0xdeb5544000000000, 0x9f844f5900000000, 0x58120e1600000000,\n    0x1923150f00000000, 0xda70382400000000, 0x9b41233d00000000,\n    0xa76bfd6500000000, 0xe65ae67c00000000, 0x2509cb5700000000,\n    0x6438d04e00000000, 0xa3ae910100000000, 0xe29f8a1800000000,\n    0x21cca73300000000, 0x60fdbc2a00000000, 0xafe124ad00000000,\n    0xeed03fb400000000, 0x2d83129f00000000, 0x6cb2098600000000,\n    0xab2448c900000000, 0xea1553d000000000, 0x29467efb00000000,\n    0x687765e200000000, 0xf6793f2f00000000, 0xb748243600000000,\n    0x741b091d00000000, 0x352a120400000000, 0xf2bc534b00000000,\n    0xb38d485200000000, 0x70de657900000000, 0x31ef7e6000000000,\n    0xfef3e6e700000000, 0xbfc2fdfe00000000, 0x7c91d0d500000000,\n    0x3da0cbcc00000000, 0xfa368a8300000000, 0xbb07919a00000000,\n    0x7854bcb100000000, 0x3965a7a800000000, 0x4b98833b00000000,\n    0x0aa9982200000000, 0xc9fab50900000000, 0x88cbae1000000000,\n    0x4f5def5f00000000, 0x0e6cf44600000000, 0xcd3fd96d00000000,\n    0x8c0ec27400000000, 0x43125af300000000, 0x022341ea00000000,\n    0xc1706cc100000000, 0x804177d800000000, 0x47d7369700000000,\n    0x06e62d8e00000000, 0xc5b500a500000000, 0x84841bbc00000000,\n    0x1a8a417100000000, 0x5bbb5a6800000000, 0x98e8774300000000,\n    0xd9d96c5a00000000, 0x1e4f2d1500000000, 0x5f7e360c00000000,\n    0x9c2d1b2700000000, 0xdd1c003e00000000, 0x120098b900000000,\n    0x533183a000000000, 0x9062ae8b00000000, 0xd153b59200000000,\n    0x16c5f4dd00000000, 0x57f4efc400000000, 0x94a7c2ef00000000,\n    0xd596d9f600000000, 0xe9bc07ae00000000, 0xa88d1cb700000000,\n    0x6bde319c00000000, 0x2aef2a8500000000, 0xed796bca00000000,\n    0xac4870d300000000, 0x6f1b5df800000000, 0x2e2a46e100000000,\n    0xe136de6600000000, 0xa007c57f00000000, 0x6354e85400000000,\n    0x2265f34d00000000, 0xe5f3b20200000000, 0xa4c2a91b00000000,\n    0x6791843000000000, 0x26a09f2900000000, 0xb8aec5e400000000,\n    0xf99fdefd00000000, 0x3accf3d600000000, 0x7bfde8cf00000000,\n    0xbc6ba98000000000, 0xfd5ab29900000000, 0x3e099fb200000000,\n    0x7f3884ab00000000, 0xb0241c2c00000000, 0xf115073500000000,\n    0x32462a1e00000000, 0x7377310700000000, 0xb4e1704800000000,\n    0xf5d06b5100000000, 0x3683467a00000000, 0x77b25d6300000000,\n    0x4ed7facb00000000, 0x0fe6e1d200000000, 0xccb5ccf900000000,\n    0x8d84d7e000000000, 0x4a1296af00000000, 0x0b238db600000000,\n    0xc870a09d00000000, 0x8941bb8400000000, 0x465d230300000000,\n    0x076c381a00000000, 0xc43f153100000000, 0x850e0e2800000000,\n    0x42984f6700000000, 0x03a9547e00000000, 0xc0fa795500000000,\n    0x81cb624c00000000, 0x1fc5388100000000, 0x5ef4239800000000,\n    0x9da70eb300000000, 0xdc9615aa00000000, 0x1b0054e500000000,\n    0x5a314ffc00000000, 0x996262d700000000, 0xd85379ce00000000,\n    0x174fe14900000000, 0x567efa5000000000, 0x952dd77b00000000,\n    0xd41ccc6200000000, 0x138a8d2d00000000, 0x52bb963400000000,\n    0x91e8bb1f00000000, 0xd0d9a00600000000, 0xecf37e5e00000000,\n    0xadc2654700000000, 0x6e91486c00000000, 0x2fa0537500000000,\n    0xe836123a00000000, 0xa907092300000000, 0x6a54240800000000,\n    0x2b653f1100000000, 0xe479a79600000000, 0xa548bc8f00000000,\n    0x661b91a400000000, 0x272a8abd00000000, 0xe0bccbf200000000,\n    0xa18dd0eb00000000, 0x62defdc000000000, 0x23efe6d900000000,\n    0xbde1bc1400000000, 0xfcd0a70d00000000, 0x3f838a2600000000,\n    0x7eb2913f00000000, 0xb924d07000000000, 0xf815cb6900000000,\n    0x3b46e64200000000, 0x7a77fd5b00000000, 0xb56b65dc00000000,\n    0xf45a7ec500000000, 0x370953ee00000000, 0x763848f700000000,\n    0xb1ae09b800000000, 0xf09f12a100000000, 0x33cc3f8a00000000,\n    0x72fd249300000000},\n   {0x0000000000000000, 0x376ac20100000000, 0x6ed4840300000000,\n    0x59be460200000000, 0xdca8090700000000, 0xebc2cb0600000000,\n    0xb27c8d0400000000, 0x85164f0500000000, 0xb851130e00000000,\n    0x8f3bd10f00000000, 0xd685970d00000000, 0xe1ef550c00000000,\n    0x64f91a0900000000, 0x5393d80800000000, 0x0a2d9e0a00000000,\n    0x3d475c0b00000000, 0x70a3261c00000000, 0x47c9e41d00000000,\n    0x1e77a21f00000000, 0x291d601e00000000, 0xac0b2f1b00000000,\n    0x9b61ed1a00000000, 0xc2dfab1800000000, 0xf5b5691900000000,\n    0xc8f2351200000000, 0xff98f71300000000, 0xa626b11100000000,\n    0x914c731000000000, 0x145a3c1500000000, 0x2330fe1400000000,\n    0x7a8eb81600000000, 0x4de47a1700000000, 0xe0464d3800000000,\n    0xd72c8f3900000000, 0x8e92c93b00000000, 0xb9f80b3a00000000,\n    0x3cee443f00000000, 0x0b84863e00000000, 0x523ac03c00000000,\n    0x6550023d00000000, 0x58175e3600000000, 0x6f7d9c3700000000,\n    0x36c3da3500000000, 0x01a9183400000000, 0x84bf573100000000,\n    0xb3d5953000000000, 0xea6bd33200000000, 0xdd01113300000000,\n    0x90e56b2400000000, 0xa78fa92500000000, 0xfe31ef2700000000,\n    0xc95b2d2600000000, 0x4c4d622300000000, 0x7b27a02200000000,\n    0x2299e62000000000, 0x15f3242100000000, 0x28b4782a00000000,\n    0x1fdeba2b00000000, 0x4660fc2900000000, 0x710a3e2800000000,\n    0xf41c712d00000000, 0xc376b32c00000000, 0x9ac8f52e00000000,\n    0xada2372f00000000, 0xc08d9a7000000000, 0xf7e7587100000000,\n    0xae591e7300000000, 0x9933dc7200000000, 0x1c25937700000000,\n    0x2b4f517600000000, 0x72f1177400000000, 0x459bd57500000000,\n    0x78dc897e00000000, 0x4fb64b7f00000000, 0x16080d7d00000000,\n    0x2162cf7c00000000, 0xa474807900000000, 0x931e427800000000,\n    0xcaa0047a00000000, 0xfdcac67b00000000, 0xb02ebc6c00000000,\n    0x87447e6d00000000, 0xdefa386f00000000, 0xe990fa6e00000000,\n    0x6c86b56b00000000, 0x5bec776a00000000, 0x0252316800000000,\n    0x3538f36900000000, 0x087faf6200000000, 0x3f156d6300000000,\n    0x66ab2b6100000000, 0x51c1e96000000000, 0xd4d7a66500000000,\n    0xe3bd646400000000, 0xba03226600000000, 0x8d69e06700000000,\n    0x20cbd74800000000, 0x17a1154900000000, 0x4e1f534b00000000,\n    0x7975914a00000000, 0xfc63de4f00000000, 0xcb091c4e00000000,\n    0x92b75a4c00000000, 0xa5dd984d00000000, 0x989ac44600000000,\n    0xaff0064700000000, 0xf64e404500000000, 0xc124824400000000,\n    0x4432cd4100000000, 0x73580f4000000000, 0x2ae6494200000000,\n    0x1d8c8b4300000000, 0x5068f15400000000, 0x6702335500000000,\n    0x3ebc755700000000, 0x09d6b75600000000, 0x8cc0f85300000000,\n    0xbbaa3a5200000000, 0xe2147c5000000000, 0xd57ebe5100000000,\n    0xe839e25a00000000, 0xdf53205b00000000, 0x86ed665900000000,\n    0xb187a45800000000, 0x3491eb5d00000000, 0x03fb295c00000000,\n    0x5a456f5e00000000, 0x6d2fad5f00000000, 0x801b35e100000000,\n    0xb771f7e000000000, 0xeecfb1e200000000, 0xd9a573e300000000,\n    0x5cb33ce600000000, 0x6bd9fee700000000, 0x3267b8e500000000,\n    0x050d7ae400000000, 0x384a26ef00000000, 0x0f20e4ee00000000,\n    0x569ea2ec00000000, 0x61f460ed00000000, 0xe4e22fe800000000,\n    0xd388ede900000000, 0x8a36abeb00000000, 0xbd5c69ea00000000,\n    0xf0b813fd00000000, 0xc7d2d1fc00000000, 0x9e6c97fe00000000,\n    0xa90655ff00000000, 0x2c101afa00000000, 0x1b7ad8fb00000000,\n    0x42c49ef900000000, 0x75ae5cf800000000, 0x48e900f300000000,\n    0x7f83c2f200000000, 0x263d84f000000000, 0x115746f100000000,\n    0x944109f400000000, 0xa32bcbf500000000, 0xfa958df700000000,\n    0xcdff4ff600000000, 0x605d78d900000000, 0x5737bad800000000,\n    0x0e89fcda00000000, 0x39e33edb00000000, 0xbcf571de00000000,\n    0x8b9fb3df00000000, 0xd221f5dd00000000, 0xe54b37dc00000000,\n    0xd80c6bd700000000, 0xef66a9d600000000, 0xb6d8efd400000000,\n    0x81b22dd500000000, 0x04a462d000000000, 0x33cea0d100000000,\n    0x6a70e6d300000000, 0x5d1a24d200000000, 0x10fe5ec500000000,\n    0x27949cc400000000, 0x7e2adac600000000, 0x494018c700000000,\n    0xcc5657c200000000, 0xfb3c95c300000000, 0xa282d3c100000000,\n    0x95e811c000000000, 0xa8af4dcb00000000, 0x9fc58fca00000000,\n    0xc67bc9c800000000, 0xf1110bc900000000, 0x740744cc00000000,\n    0x436d86cd00000000, 0x1ad3c0cf00000000, 0x2db902ce00000000,\n    0x4096af9100000000, 0x77fc6d9000000000, 0x2e422b9200000000,\n    0x1928e99300000000, 0x9c3ea69600000000, 0xab54649700000000,\n    0xf2ea229500000000, 0xc580e09400000000, 0xf8c7bc9f00000000,\n    0xcfad7e9e00000000, 0x9613389c00000000, 0xa179fa9d00000000,\n    0x246fb59800000000, 0x1305779900000000, 0x4abb319b00000000,\n    0x7dd1f39a00000000, 0x3035898d00000000, 0x075f4b8c00000000,\n    0x5ee10d8e00000000, 0x698bcf8f00000000, 0xec9d808a00000000,\n    0xdbf7428b00000000, 0x8249048900000000, 0xb523c68800000000,\n    0x88649a8300000000, 0xbf0e588200000000, 0xe6b01e8000000000,\n    0xd1dadc8100000000, 0x54cc938400000000, 0x63a6518500000000,\n    0x3a18178700000000, 0x0d72d58600000000, 0xa0d0e2a900000000,\n    0x97ba20a800000000, 0xce0466aa00000000, 0xf96ea4ab00000000,\n    0x7c78ebae00000000, 0x4b1229af00000000, 0x12ac6fad00000000,\n    0x25c6adac00000000, 0x1881f1a700000000, 0x2feb33a600000000,\n    0x765575a400000000, 0x413fb7a500000000, 0xc429f8a000000000,\n    0xf3433aa100000000, 0xaafd7ca300000000, 0x9d97bea200000000,\n    0xd073c4b500000000, 0xe71906b400000000, 0xbea740b600000000,\n    0x89cd82b700000000, 0x0cdbcdb200000000, 0x3bb10fb300000000,\n    0x620f49b100000000, 0x55658bb000000000, 0x6822d7bb00000000,\n    0x5f4815ba00000000, 0x06f653b800000000, 0x319c91b900000000,\n    0xb48adebc00000000, 0x83e01cbd00000000, 0xda5e5abf00000000,\n    0xed3498be00000000},\n   {0x0000000000000000, 0x6567bcb800000000, 0x8bc809aa00000000,\n    0xeeafb51200000000, 0x5797628f00000000, 0x32f0de3700000000,\n    0xdc5f6b2500000000, 0xb938d79d00000000, 0xef28b4c500000000,\n    0x8a4f087d00000000, 0x64e0bd6f00000000, 0x018701d700000000,\n    0xb8bfd64a00000000, 0xddd86af200000000, 0x3377dfe000000000,\n    0x5610635800000000, 0x9f57195000000000, 0xfa30a5e800000000,\n    0x149f10fa00000000, 0x71f8ac4200000000, 0xc8c07bdf00000000,\n    0xada7c76700000000, 0x4308727500000000, 0x266fcecd00000000,\n    0x707fad9500000000, 0x1518112d00000000, 0xfbb7a43f00000000,\n    0x9ed0188700000000, 0x27e8cf1a00000000, 0x428f73a200000000,\n    0xac20c6b000000000, 0xc9477a0800000000, 0x3eaf32a000000000,\n    0x5bc88e1800000000, 0xb5673b0a00000000, 0xd00087b200000000,\n    0x6938502f00000000, 0x0c5fec9700000000, 0xe2f0598500000000,\n    0x8797e53d00000000, 0xd187866500000000, 0xb4e03add00000000,\n    0x5a4f8fcf00000000, 0x3f28337700000000, 0x8610e4ea00000000,\n    0xe377585200000000, 0x0dd8ed4000000000, 0x68bf51f800000000,\n    0xa1f82bf000000000, 0xc49f974800000000, 0x2a30225a00000000,\n    0x4f579ee200000000, 0xf66f497f00000000, 0x9308f5c700000000,\n    0x7da740d500000000, 0x18c0fc6d00000000, 0x4ed09f3500000000,\n    0x2bb7238d00000000, 0xc518969f00000000, 0xa07f2a2700000000,\n    0x1947fdba00000000, 0x7c20410200000000, 0x928ff41000000000,\n    0xf7e848a800000000, 0x3d58149b00000000, 0x583fa82300000000,\n    0xb6901d3100000000, 0xd3f7a18900000000, 0x6acf761400000000,\n    0x0fa8caac00000000, 0xe1077fbe00000000, 0x8460c30600000000,\n    0xd270a05e00000000, 0xb7171ce600000000, 0x59b8a9f400000000,\n    0x3cdf154c00000000, 0x85e7c2d100000000, 0xe0807e6900000000,\n    0x0e2fcb7b00000000, 0x6b4877c300000000, 0xa20f0dcb00000000,\n    0xc768b17300000000, 0x29c7046100000000, 0x4ca0b8d900000000,\n    0xf5986f4400000000, 0x90ffd3fc00000000, 0x7e5066ee00000000,\n    0x1b37da5600000000, 0x4d27b90e00000000, 0x284005b600000000,\n    0xc6efb0a400000000, 0xa3880c1c00000000, 0x1ab0db8100000000,\n    0x7fd7673900000000, 0x9178d22b00000000, 0xf41f6e9300000000,\n    0x03f7263b00000000, 0x66909a8300000000, 0x883f2f9100000000,\n    0xed58932900000000, 0x546044b400000000, 0x3107f80c00000000,\n    0xdfa84d1e00000000, 0xbacff1a600000000, 0xecdf92fe00000000,\n    0x89b82e4600000000, 0x67179b5400000000, 0x027027ec00000000,\n    0xbb48f07100000000, 0xde2f4cc900000000, 0x3080f9db00000000,\n    0x55e7456300000000, 0x9ca03f6b00000000, 0xf9c783d300000000,\n    0x176836c100000000, 0x720f8a7900000000, 0xcb375de400000000,\n    0xae50e15c00000000, 0x40ff544e00000000, 0x2598e8f600000000,\n    0x73888bae00000000, 0x16ef371600000000, 0xf840820400000000,\n    0x9d273ebc00000000, 0x241fe92100000000, 0x4178559900000000,\n    0xafd7e08b00000000, 0xcab05c3300000000, 0x3bb659ed00000000,\n    0x5ed1e55500000000, 0xb07e504700000000, 0xd519ecff00000000,\n    0x6c213b6200000000, 0x094687da00000000, 0xe7e932c800000000,\n    0x828e8e7000000000, 0xd49eed2800000000, 0xb1f9519000000000,\n    0x5f56e48200000000, 0x3a31583a00000000, 0x83098fa700000000,\n    0xe66e331f00000000, 0x08c1860d00000000, 0x6da63ab500000000,\n    0xa4e140bd00000000, 0xc186fc0500000000, 0x2f29491700000000,\n    0x4a4ef5af00000000, 0xf376223200000000, 0x96119e8a00000000,\n    0x78be2b9800000000, 0x1dd9972000000000, 0x4bc9f47800000000,\n    0x2eae48c000000000, 0xc001fdd200000000, 0xa566416a00000000,\n    0x1c5e96f700000000, 0x79392a4f00000000, 0x97969f5d00000000,\n    0xf2f123e500000000, 0x05196b4d00000000, 0x607ed7f500000000,\n    0x8ed162e700000000, 0xebb6de5f00000000, 0x528e09c200000000,\n    0x37e9b57a00000000, 0xd946006800000000, 0xbc21bcd000000000,\n    0xea31df8800000000, 0x8f56633000000000, 0x61f9d62200000000,\n    0x049e6a9a00000000, 0xbda6bd0700000000, 0xd8c101bf00000000,\n    0x366eb4ad00000000, 0x5309081500000000, 0x9a4e721d00000000,\n    0xff29cea500000000, 0x11867bb700000000, 0x74e1c70f00000000,\n    0xcdd9109200000000, 0xa8beac2a00000000, 0x4611193800000000,\n    0x2376a58000000000, 0x7566c6d800000000, 0x10017a6000000000,\n    0xfeaecf7200000000, 0x9bc973ca00000000, 0x22f1a45700000000,\n    0x479618ef00000000, 0xa939adfd00000000, 0xcc5e114500000000,\n    0x06ee4d7600000000, 0x6389f1ce00000000, 0x8d2644dc00000000,\n    0xe841f86400000000, 0x51792ff900000000, 0x341e934100000000,\n    0xdab1265300000000, 0xbfd69aeb00000000, 0xe9c6f9b300000000,\n    0x8ca1450b00000000, 0x620ef01900000000, 0x07694ca100000000,\n    0xbe519b3c00000000, 0xdb36278400000000, 0x3599929600000000,\n    0x50fe2e2e00000000, 0x99b9542600000000, 0xfcdee89e00000000,\n    0x12715d8c00000000, 0x7716e13400000000, 0xce2e36a900000000,\n    0xab498a1100000000, 0x45e63f0300000000, 0x208183bb00000000,\n    0x7691e0e300000000, 0x13f65c5b00000000, 0xfd59e94900000000,\n    0x983e55f100000000, 0x2106826c00000000, 0x44613ed400000000,\n    0xaace8bc600000000, 0xcfa9377e00000000, 0x38417fd600000000,\n    0x5d26c36e00000000, 0xb389767c00000000, 0xd6eecac400000000,\n    0x6fd61d5900000000, 0x0ab1a1e100000000, 0xe41e14f300000000,\n    0x8179a84b00000000, 0xd769cb1300000000, 0xb20e77ab00000000,\n    0x5ca1c2b900000000, 0x39c67e0100000000, 0x80fea99c00000000,\n    0xe599152400000000, 0x0b36a03600000000, 0x6e511c8e00000000,\n    0xa716668600000000, 0xc271da3e00000000, 0x2cde6f2c00000000,\n    0x49b9d39400000000, 0xf081040900000000, 0x95e6b8b100000000,\n    0x7b490da300000000, 0x1e2eb11b00000000, 0x483ed24300000000,\n    0x2d596efb00000000, 0xc3f6dbe900000000, 0xa691675100000000,\n    0x1fa9b0cc00000000, 0x7ace0c7400000000, 0x9461b96600000000,\n    0xf10605de00000000},\n   {0x0000000000000000, 0xb029603d00000000, 0x6053c07a00000000,\n    0xd07aa04700000000, 0xc0a680f500000000, 0x708fe0c800000000,\n    0xa0f5408f00000000, 0x10dc20b200000000, 0xc14b703000000000,\n    0x7162100d00000000, 0xa118b04a00000000, 0x1131d07700000000,\n    0x01edf0c500000000, 0xb1c490f800000000, 0x61be30bf00000000,\n    0xd197508200000000, 0x8297e06000000000, 0x32be805d00000000,\n    0xe2c4201a00000000, 0x52ed402700000000, 0x4231609500000000,\n    0xf21800a800000000, 0x2262a0ef00000000, 0x924bc0d200000000,\n    0x43dc905000000000, 0xf3f5f06d00000000, 0x238f502a00000000,\n    0x93a6301700000000, 0x837a10a500000000, 0x3353709800000000,\n    0xe329d0df00000000, 0x5300b0e200000000, 0x042fc1c100000000,\n    0xb406a1fc00000000, 0x647c01bb00000000, 0xd455618600000000,\n    0xc489413400000000, 0x74a0210900000000, 0xa4da814e00000000,\n    0x14f3e17300000000, 0xc564b1f100000000, 0x754dd1cc00000000,\n    0xa537718b00000000, 0x151e11b600000000, 0x05c2310400000000,\n    0xb5eb513900000000, 0x6591f17e00000000, 0xd5b8914300000000,\n    0x86b821a100000000, 0x3691419c00000000, 0xe6ebe1db00000000,\n    0x56c281e600000000, 0x461ea15400000000, 0xf637c16900000000,\n    0x264d612e00000000, 0x9664011300000000, 0x47f3519100000000,\n    0xf7da31ac00000000, 0x27a091eb00000000, 0x9789f1d600000000,\n    0x8755d16400000000, 0x377cb15900000000, 0xe706111e00000000,\n    0x572f712300000000, 0x4958f35800000000, 0xf971936500000000,\n    0x290b332200000000, 0x9922531f00000000, 0x89fe73ad00000000,\n    0x39d7139000000000, 0xe9adb3d700000000, 0x5984d3ea00000000,\n    0x8813836800000000, 0x383ae35500000000, 0xe840431200000000,\n    0x5869232f00000000, 0x48b5039d00000000, 0xf89c63a000000000,\n    0x28e6c3e700000000, 0x98cfa3da00000000, 0xcbcf133800000000,\n    0x7be6730500000000, 0xab9cd34200000000, 0x1bb5b37f00000000,\n    0x0b6993cd00000000, 0xbb40f3f000000000, 0x6b3a53b700000000,\n    0xdb13338a00000000, 0x0a84630800000000, 0xbaad033500000000,\n    0x6ad7a37200000000, 0xdafec34f00000000, 0xca22e3fd00000000,\n    0x7a0b83c000000000, 0xaa71238700000000, 0x1a5843ba00000000,\n    0x4d77329900000000, 0xfd5e52a400000000, 0x2d24f2e300000000,\n    0x9d0d92de00000000, 0x8dd1b26c00000000, 0x3df8d25100000000,\n    0xed82721600000000, 0x5dab122b00000000, 0x8c3c42a900000000,\n    0x3c15229400000000, 0xec6f82d300000000, 0x5c46e2ee00000000,\n    0x4c9ac25c00000000, 0xfcb3a26100000000, 0x2cc9022600000000,\n    0x9ce0621b00000000, 0xcfe0d2f900000000, 0x7fc9b2c400000000,\n    0xafb3128300000000, 0x1f9a72be00000000, 0x0f46520c00000000,\n    0xbf6f323100000000, 0x6f15927600000000, 0xdf3cf24b00000000,\n    0x0eaba2c900000000, 0xbe82c2f400000000, 0x6ef862b300000000,\n    0xded1028e00000000, 0xce0d223c00000000, 0x7e24420100000000,\n    0xae5ee24600000000, 0x1e77827b00000000, 0x92b0e6b100000000,\n    0x2299868c00000000, 0xf2e326cb00000000, 0x42ca46f600000000,\n    0x5216664400000000, 0xe23f067900000000, 0x3245a63e00000000,\n    0x826cc60300000000, 0x53fb968100000000, 0xe3d2f6bc00000000,\n    0x33a856fb00000000, 0x838136c600000000, 0x935d167400000000,\n    0x2374764900000000, 0xf30ed60e00000000, 0x4327b63300000000,\n    0x102706d100000000, 0xa00e66ec00000000, 0x7074c6ab00000000,\n    0xc05da69600000000, 0xd081862400000000, 0x60a8e61900000000,\n    0xb0d2465e00000000, 0x00fb266300000000, 0xd16c76e100000000,\n    0x614516dc00000000, 0xb13fb69b00000000, 0x0116d6a600000000,\n    0x11caf61400000000, 0xa1e3962900000000, 0x7199366e00000000,\n    0xc1b0565300000000, 0x969f277000000000, 0x26b6474d00000000,\n    0xf6cce70a00000000, 0x46e5873700000000, 0x5639a78500000000,\n    0xe610c7b800000000, 0x366a67ff00000000, 0x864307c200000000,\n    0x57d4574000000000, 0xe7fd377d00000000, 0x3787973a00000000,\n    0x87aef70700000000, 0x9772d7b500000000, 0x275bb78800000000,\n    0xf72117cf00000000, 0x470877f200000000, 0x1408c71000000000,\n    0xa421a72d00000000, 0x745b076a00000000, 0xc472675700000000,\n    0xd4ae47e500000000, 0x648727d800000000, 0xb4fd879f00000000,\n    0x04d4e7a200000000, 0xd543b72000000000, 0x656ad71d00000000,\n    0xb510775a00000000, 0x0539176700000000, 0x15e537d500000000,\n    0xa5cc57e800000000, 0x75b6f7af00000000, 0xc59f979200000000,\n    0xdbe815e900000000, 0x6bc175d400000000, 0xbbbbd59300000000,\n    0x0b92b5ae00000000, 0x1b4e951c00000000, 0xab67f52100000000,\n    0x7b1d556600000000, 0xcb34355b00000000, 0x1aa365d900000000,\n    0xaa8a05e400000000, 0x7af0a5a300000000, 0xcad9c59e00000000,\n    0xda05e52c00000000, 0x6a2c851100000000, 0xba56255600000000,\n    0x0a7f456b00000000, 0x597ff58900000000, 0xe95695b400000000,\n    0x392c35f300000000, 0x890555ce00000000, 0x99d9757c00000000,\n    0x29f0154100000000, 0xf98ab50600000000, 0x49a3d53b00000000,\n    0x983485b900000000, 0x281de58400000000, 0xf86745c300000000,\n    0x484e25fe00000000, 0x5892054c00000000, 0xe8bb657100000000,\n    0x38c1c53600000000, 0x88e8a50b00000000, 0xdfc7d42800000000,\n    0x6feeb41500000000, 0xbf94145200000000, 0x0fbd746f00000000,\n    0x1f6154dd00000000, 0xaf4834e000000000, 0x7f3294a700000000,\n    0xcf1bf49a00000000, 0x1e8ca41800000000, 0xaea5c42500000000,\n    0x7edf646200000000, 0xcef6045f00000000, 0xde2a24ed00000000,\n    0x6e0344d000000000, 0xbe79e49700000000, 0x0e5084aa00000000,\n    0x5d50344800000000, 0xed79547500000000, 0x3d03f43200000000,\n    0x8d2a940f00000000, 0x9df6b4bd00000000, 0x2ddfd48000000000,\n    0xfda574c700000000, 0x4d8c14fa00000000, 0x9c1b447800000000,\n    0x2c32244500000000, 0xfc48840200000000, 0x4c61e43f00000000,\n    0x5cbdc48d00000000, 0xec94a4b000000000, 0x3cee04f700000000,\n    0x8cc764ca00000000},\n   {0x0000000000000000, 0xa5d35ccb00000000, 0x0ba1c84d00000000,\n    0xae72948600000000, 0x1642919b00000000, 0xb391cd5000000000,\n    0x1de359d600000000, 0xb830051d00000000, 0x6d8253ec00000000,\n    0xc8510f2700000000, 0x66239ba100000000, 0xc3f0c76a00000000,\n    0x7bc0c27700000000, 0xde139ebc00000000, 0x70610a3a00000000,\n    0xd5b256f100000000, 0x9b02d60300000000, 0x3ed18ac800000000,\n    0x90a31e4e00000000, 0x3570428500000000, 0x8d40479800000000,\n    0x28931b5300000000, 0x86e18fd500000000, 0x2332d31e00000000,\n    0xf68085ef00000000, 0x5353d92400000000, 0xfd214da200000000,\n    0x58f2116900000000, 0xe0c2147400000000, 0x451148bf00000000,\n    0xeb63dc3900000000, 0x4eb080f200000000, 0x3605ac0700000000,\n    0x93d6f0cc00000000, 0x3da4644a00000000, 0x9877388100000000,\n    0x20473d9c00000000, 0x8594615700000000, 0x2be6f5d100000000,\n    0x8e35a91a00000000, 0x5b87ffeb00000000, 0xfe54a32000000000,\n    0x502637a600000000, 0xf5f56b6d00000000, 0x4dc56e7000000000,\n    0xe81632bb00000000, 0x4664a63d00000000, 0xe3b7faf600000000,\n    0xad077a0400000000, 0x08d426cf00000000, 0xa6a6b24900000000,\n    0x0375ee8200000000, 0xbb45eb9f00000000, 0x1e96b75400000000,\n    0xb0e423d200000000, 0x15377f1900000000, 0xc08529e800000000,\n    0x6556752300000000, 0xcb24e1a500000000, 0x6ef7bd6e00000000,\n    0xd6c7b87300000000, 0x7314e4b800000000, 0xdd66703e00000000,\n    0x78b52cf500000000, 0x6c0a580f00000000, 0xc9d904c400000000,\n    0x67ab904200000000, 0xc278cc8900000000, 0x7a48c99400000000,\n    0xdf9b955f00000000, 0x71e901d900000000, 0xd43a5d1200000000,\n    0x01880be300000000, 0xa45b572800000000, 0x0a29c3ae00000000,\n    0xaffa9f6500000000, 0x17ca9a7800000000, 0xb219c6b300000000,\n    0x1c6b523500000000, 0xb9b80efe00000000, 0xf7088e0c00000000,\n    0x52dbd2c700000000, 0xfca9464100000000, 0x597a1a8a00000000,\n    0xe14a1f9700000000, 0x4499435c00000000, 0xeaebd7da00000000,\n    0x4f388b1100000000, 0x9a8adde000000000, 0x3f59812b00000000,\n    0x912b15ad00000000, 0x34f8496600000000, 0x8cc84c7b00000000,\n    0x291b10b000000000, 0x8769843600000000, 0x22bad8fd00000000,\n    0x5a0ff40800000000, 0xffdca8c300000000, 0x51ae3c4500000000,\n    0xf47d608e00000000, 0x4c4d659300000000, 0xe99e395800000000,\n    0x47ecadde00000000, 0xe23ff11500000000, 0x378da7e400000000,\n    0x925efb2f00000000, 0x3c2c6fa900000000, 0x99ff336200000000,\n    0x21cf367f00000000, 0x841c6ab400000000, 0x2a6efe3200000000,\n    0x8fbda2f900000000, 0xc10d220b00000000, 0x64de7ec000000000,\n    0xcaacea4600000000, 0x6f7fb68d00000000, 0xd74fb39000000000,\n    0x729cef5b00000000, 0xdcee7bdd00000000, 0x793d271600000000,\n    0xac8f71e700000000, 0x095c2d2c00000000, 0xa72eb9aa00000000,\n    0x02fde56100000000, 0xbacde07c00000000, 0x1f1ebcb700000000,\n    0xb16c283100000000, 0x14bf74fa00000000, 0xd814b01e00000000,\n    0x7dc7ecd500000000, 0xd3b5785300000000, 0x7666249800000000,\n    0xce56218500000000, 0x6b857d4e00000000, 0xc5f7e9c800000000,\n    0x6024b50300000000, 0xb596e3f200000000, 0x1045bf3900000000,\n    0xbe372bbf00000000, 0x1be4777400000000, 0xa3d4726900000000,\n    0x06072ea200000000, 0xa875ba2400000000, 0x0da6e6ef00000000,\n    0x4316661d00000000, 0xe6c53ad600000000, 0x48b7ae5000000000,\n    0xed64f29b00000000, 0x5554f78600000000, 0xf087ab4d00000000,\n    0x5ef53fcb00000000, 0xfb26630000000000, 0x2e9435f100000000,\n    0x8b47693a00000000, 0x2535fdbc00000000, 0x80e6a17700000000,\n    0x38d6a46a00000000, 0x9d05f8a100000000, 0x33776c2700000000,\n    0x96a430ec00000000, 0xee111c1900000000, 0x4bc240d200000000,\n    0xe5b0d45400000000, 0x4063889f00000000, 0xf8538d8200000000,\n    0x5d80d14900000000, 0xf3f245cf00000000, 0x5621190400000000,\n    0x83934ff500000000, 0x2640133e00000000, 0x883287b800000000,\n    0x2de1db7300000000, 0x95d1de6e00000000, 0x300282a500000000,\n    0x9e70162300000000, 0x3ba34ae800000000, 0x7513ca1a00000000,\n    0xd0c096d100000000, 0x7eb2025700000000, 0xdb615e9c00000000,\n    0x63515b8100000000, 0xc682074a00000000, 0x68f093cc00000000,\n    0xcd23cf0700000000, 0x189199f600000000, 0xbd42c53d00000000,\n    0x133051bb00000000, 0xb6e30d7000000000, 0x0ed3086d00000000,\n    0xab0054a600000000, 0x0572c02000000000, 0xa0a19ceb00000000,\n    0xb41ee81100000000, 0x11cdb4da00000000, 0xbfbf205c00000000,\n    0x1a6c7c9700000000, 0xa25c798a00000000, 0x078f254100000000,\n    0xa9fdb1c700000000, 0x0c2eed0c00000000, 0xd99cbbfd00000000,\n    0x7c4fe73600000000, 0xd23d73b000000000, 0x77ee2f7b00000000,\n    0xcfde2a6600000000, 0x6a0d76ad00000000, 0xc47fe22b00000000,\n    0x61acbee000000000, 0x2f1c3e1200000000, 0x8acf62d900000000,\n    0x24bdf65f00000000, 0x816eaa9400000000, 0x395eaf8900000000,\n    0x9c8df34200000000, 0x32ff67c400000000, 0x972c3b0f00000000,\n    0x429e6dfe00000000, 0xe74d313500000000, 0x493fa5b300000000,\n    0xececf97800000000, 0x54dcfc6500000000, 0xf10fa0ae00000000,\n    0x5f7d342800000000, 0xfaae68e300000000, 0x821b441600000000,\n    0x27c818dd00000000, 0x89ba8c5b00000000, 0x2c69d09000000000,\n    0x9459d58d00000000, 0x318a894600000000, 0x9ff81dc000000000,\n    0x3a2b410b00000000, 0xef9917fa00000000, 0x4a4a4b3100000000,\n    0xe438dfb700000000, 0x41eb837c00000000, 0xf9db866100000000,\n    0x5c08daaa00000000, 0xf27a4e2c00000000, 0x57a912e700000000,\n    0x1919921500000000, 0xbccacede00000000, 0x12b85a5800000000,\n    0xb76b069300000000, 0x0f5b038e00000000, 0xaa885f4500000000,\n    0x04facbc300000000, 0xa129970800000000, 0x749bc1f900000000,\n    0xd1489d3200000000, 0x7f3a09b400000000, 0xdae9557f00000000,\n    0x62d9506200000000, 0xc70a0ca900000000, 0x6978982f00000000,\n    0xccabc4e400000000},\n   {0x0000000000000000, 0xb40b77a600000000, 0x29119f9700000000,\n    0x9d1ae83100000000, 0x13244ff400000000, 0xa72f385200000000,\n    0x3a35d06300000000, 0x8e3ea7c500000000, 0x674eef3300000000,\n    0xd345989500000000, 0x4e5f70a400000000, 0xfa54070200000000,\n    0x746aa0c700000000, 0xc061d76100000000, 0x5d7b3f5000000000,\n    0xe97048f600000000, 0xce9cde6700000000, 0x7a97a9c100000000,\n    0xe78d41f000000000, 0x5386365600000000, 0xddb8919300000000,\n    0x69b3e63500000000, 0xf4a90e0400000000, 0x40a279a200000000,\n    0xa9d2315400000000, 0x1dd946f200000000, 0x80c3aec300000000,\n    0x34c8d96500000000, 0xbaf67ea000000000, 0x0efd090600000000,\n    0x93e7e13700000000, 0x27ec969100000000, 0x9c39bdcf00000000,\n    0x2832ca6900000000, 0xb528225800000000, 0x012355fe00000000,\n    0x8f1df23b00000000, 0x3b16859d00000000, 0xa60c6dac00000000,\n    0x12071a0a00000000, 0xfb7752fc00000000, 0x4f7c255a00000000,\n    0xd266cd6b00000000, 0x666dbacd00000000, 0xe8531d0800000000,\n    0x5c586aae00000000, 0xc142829f00000000, 0x7549f53900000000,\n    0x52a563a800000000, 0xe6ae140e00000000, 0x7bb4fc3f00000000,\n    0xcfbf8b9900000000, 0x41812c5c00000000, 0xf58a5bfa00000000,\n    0x6890b3cb00000000, 0xdc9bc46d00000000, 0x35eb8c9b00000000,\n    0x81e0fb3d00000000, 0x1cfa130c00000000, 0xa8f164aa00000000,\n    0x26cfc36f00000000, 0x92c4b4c900000000, 0x0fde5cf800000000,\n    0xbbd52b5e00000000, 0x79750b4400000000, 0xcd7e7ce200000000,\n    0x506494d300000000, 0xe46fe37500000000, 0x6a5144b000000000,\n    0xde5a331600000000, 0x4340db2700000000, 0xf74bac8100000000,\n    0x1e3be47700000000, 0xaa3093d100000000, 0x372a7be000000000,\n    0x83210c4600000000, 0x0d1fab8300000000, 0xb914dc2500000000,\n    0x240e341400000000, 0x900543b200000000, 0xb7e9d52300000000,\n    0x03e2a28500000000, 0x9ef84ab400000000, 0x2af33d1200000000,\n    0xa4cd9ad700000000, 0x10c6ed7100000000, 0x8ddc054000000000,\n    0x39d772e600000000, 0xd0a73a1000000000, 0x64ac4db600000000,\n    0xf9b6a58700000000, 0x4dbdd22100000000, 0xc38375e400000000,\n    0x7788024200000000, 0xea92ea7300000000, 0x5e999dd500000000,\n    0xe54cb68b00000000, 0x5147c12d00000000, 0xcc5d291c00000000,\n    0x78565eba00000000, 0xf668f97f00000000, 0x42638ed900000000,\n    0xdf7966e800000000, 0x6b72114e00000000, 0x820259b800000000,\n    0x36092e1e00000000, 0xab13c62f00000000, 0x1f18b18900000000,\n    0x9126164c00000000, 0x252d61ea00000000, 0xb83789db00000000,\n    0x0c3cfe7d00000000, 0x2bd068ec00000000, 0x9fdb1f4a00000000,\n    0x02c1f77b00000000, 0xb6ca80dd00000000, 0x38f4271800000000,\n    0x8cff50be00000000, 0x11e5b88f00000000, 0xa5eecf2900000000,\n    0x4c9e87df00000000, 0xf895f07900000000, 0x658f184800000000,\n    0xd1846fee00000000, 0x5fbac82b00000000, 0xebb1bf8d00000000,\n    0x76ab57bc00000000, 0xc2a0201a00000000, 0xf2ea168800000000,\n    0x46e1612e00000000, 0xdbfb891f00000000, 0x6ff0feb900000000,\n    0xe1ce597c00000000, 0x55c52eda00000000, 0xc8dfc6eb00000000,\n    0x7cd4b14d00000000, 0x95a4f9bb00000000, 0x21af8e1d00000000,\n    0xbcb5662c00000000, 0x08be118a00000000, 0x8680b64f00000000,\n    0x328bc1e900000000, 0xaf9129d800000000, 0x1b9a5e7e00000000,\n    0x3c76c8ef00000000, 0x887dbf4900000000, 0x1567577800000000,\n    0xa16c20de00000000, 0x2f52871b00000000, 0x9b59f0bd00000000,\n    0x0643188c00000000, 0xb2486f2a00000000, 0x5b3827dc00000000,\n    0xef33507a00000000, 0x7229b84b00000000, 0xc622cfed00000000,\n    0x481c682800000000, 0xfc171f8e00000000, 0x610df7bf00000000,\n    0xd506801900000000, 0x6ed3ab4700000000, 0xdad8dce100000000,\n    0x47c234d000000000, 0xf3c9437600000000, 0x7df7e4b300000000,\n    0xc9fc931500000000, 0x54e67b2400000000, 0xe0ed0c8200000000,\n    0x099d447400000000, 0xbd9633d200000000, 0x208cdbe300000000,\n    0x9487ac4500000000, 0x1ab90b8000000000, 0xaeb27c2600000000,\n    0x33a8941700000000, 0x87a3e3b100000000, 0xa04f752000000000,\n    0x1444028600000000, 0x895eeab700000000, 0x3d559d1100000000,\n    0xb36b3ad400000000, 0x07604d7200000000, 0x9a7aa54300000000,\n    0x2e71d2e500000000, 0xc7019a1300000000, 0x730aedb500000000,\n    0xee10058400000000, 0x5a1b722200000000, 0xd425d5e700000000,\n    0x602ea24100000000, 0xfd344a7000000000, 0x493f3dd600000000,\n    0x8b9f1dcc00000000, 0x3f946a6a00000000, 0xa28e825b00000000,\n    0x1685f5fd00000000, 0x98bb523800000000, 0x2cb0259e00000000,\n    0xb1aacdaf00000000, 0x05a1ba0900000000, 0xecd1f2ff00000000,\n    0x58da855900000000, 0xc5c06d6800000000, 0x71cb1ace00000000,\n    0xfff5bd0b00000000, 0x4bfecaad00000000, 0xd6e4229c00000000,\n    0x62ef553a00000000, 0x4503c3ab00000000, 0xf108b40d00000000,\n    0x6c125c3c00000000, 0xd8192b9a00000000, 0x56278c5f00000000,\n    0xe22cfbf900000000, 0x7f3613c800000000, 0xcb3d646e00000000,\n    0x224d2c9800000000, 0x96465b3e00000000, 0x0b5cb30f00000000,\n    0xbf57c4a900000000, 0x3169636c00000000, 0x856214ca00000000,\n    0x1878fcfb00000000, 0xac738b5d00000000, 0x17a6a00300000000,\n    0xa3add7a500000000, 0x3eb73f9400000000, 0x8abc483200000000,\n    0x0482eff700000000, 0xb089985100000000, 0x2d93706000000000,\n    0x999807c600000000, 0x70e84f3000000000, 0xc4e3389600000000,\n    0x59f9d0a700000000, 0xedf2a70100000000, 0x63cc00c400000000,\n    0xd7c7776200000000, 0x4add9f5300000000, 0xfed6e8f500000000,\n    0xd93a7e6400000000, 0x6d3109c200000000, 0xf02be1f300000000,\n    0x4420965500000000, 0xca1e319000000000, 0x7e15463600000000,\n    0xe30fae0700000000, 0x5704d9a100000000, 0xbe74915700000000,\n    0x0a7fe6f100000000, 0x97650ec000000000, 0x236e796600000000,\n    0xad50dea300000000, 0x195ba90500000000, 0x8441413400000000,\n    0x304a369200000000},\n   {0x0000000000000000, 0x9e00aacc00000000, 0x7d07254200000000,\n    0xe3078f8e00000000, 0xfa0e4a8400000000, 0x640ee04800000000,\n    0x87096fc600000000, 0x1909c50a00000000, 0xb51be5d300000000,\n    0x2b1b4f1f00000000, 0xc81cc09100000000, 0x561c6a5d00000000,\n    0x4f15af5700000000, 0xd115059b00000000, 0x32128a1500000000,\n    0xac1220d900000000, 0x2b31bb7c00000000, 0xb53111b000000000,\n    0x56369e3e00000000, 0xc83634f200000000, 0xd13ff1f800000000,\n    0x4f3f5b3400000000, 0xac38d4ba00000000, 0x32387e7600000000,\n    0x9e2a5eaf00000000, 0x002af46300000000, 0xe32d7bed00000000,\n    0x7d2dd12100000000, 0x6424142b00000000, 0xfa24bee700000000,\n    0x1923316900000000, 0x87239ba500000000, 0x566276f900000000,\n    0xc862dc3500000000, 0x2b6553bb00000000, 0xb565f97700000000,\n    0xac6c3c7d00000000, 0x326c96b100000000, 0xd16b193f00000000,\n    0x4f6bb3f300000000, 0xe379932a00000000, 0x7d7939e600000000,\n    0x9e7eb66800000000, 0x007e1ca400000000, 0x1977d9ae00000000,\n    0x8777736200000000, 0x6470fcec00000000, 0xfa70562000000000,\n    0x7d53cd8500000000, 0xe353674900000000, 0x0054e8c700000000,\n    0x9e54420b00000000, 0x875d870100000000, 0x195d2dcd00000000,\n    0xfa5aa24300000000, 0x645a088f00000000, 0xc848285600000000,\n    0x5648829a00000000, 0xb54f0d1400000000, 0x2b4fa7d800000000,\n    0x324662d200000000, 0xac46c81e00000000, 0x4f41479000000000,\n    0xd141ed5c00000000, 0xedc29d2900000000, 0x73c237e500000000,\n    0x90c5b86b00000000, 0x0ec512a700000000, 0x17ccd7ad00000000,\n    0x89cc7d6100000000, 0x6acbf2ef00000000, 0xf4cb582300000000,\n    0x58d978fa00000000, 0xc6d9d23600000000, 0x25de5db800000000,\n    0xbbdef77400000000, 0xa2d7327e00000000, 0x3cd798b200000000,\n    0xdfd0173c00000000, 0x41d0bdf000000000, 0xc6f3265500000000,\n    0x58f38c9900000000, 0xbbf4031700000000, 0x25f4a9db00000000,\n    0x3cfd6cd100000000, 0xa2fdc61d00000000, 0x41fa499300000000,\n    0xdffae35f00000000, 0x73e8c38600000000, 0xede8694a00000000,\n    0x0eefe6c400000000, 0x90ef4c0800000000, 0x89e6890200000000,\n    0x17e623ce00000000, 0xf4e1ac4000000000, 0x6ae1068c00000000,\n    0xbba0ebd000000000, 0x25a0411c00000000, 0xc6a7ce9200000000,\n    0x58a7645e00000000, 0x41aea15400000000, 0xdfae0b9800000000,\n    0x3ca9841600000000, 0xa2a92eda00000000, 0x0ebb0e0300000000,\n    0x90bba4cf00000000, 0x73bc2b4100000000, 0xedbc818d00000000,\n    0xf4b5448700000000, 0x6ab5ee4b00000000, 0x89b261c500000000,\n    0x17b2cb0900000000, 0x909150ac00000000, 0x0e91fa6000000000,\n    0xed9675ee00000000, 0x7396df2200000000, 0x6a9f1a2800000000,\n    0xf49fb0e400000000, 0x17983f6a00000000, 0x899895a600000000,\n    0x258ab57f00000000, 0xbb8a1fb300000000, 0x588d903d00000000,\n    0xc68d3af100000000, 0xdf84fffb00000000, 0x4184553700000000,\n    0xa283dab900000000, 0x3c83707500000000, 0xda853b5300000000,\n    0x4485919f00000000, 0xa7821e1100000000, 0x3982b4dd00000000,\n    0x208b71d700000000, 0xbe8bdb1b00000000, 0x5d8c549500000000,\n    0xc38cfe5900000000, 0x6f9ede8000000000, 0xf19e744c00000000,\n    0x1299fbc200000000, 0x8c99510e00000000, 0x9590940400000000,\n    0x0b903ec800000000, 0xe897b14600000000, 0x76971b8a00000000,\n    0xf1b4802f00000000, 0x6fb42ae300000000, 0x8cb3a56d00000000,\n    0x12b30fa100000000, 0x0bbacaab00000000, 0x95ba606700000000,\n    0x76bdefe900000000, 0xe8bd452500000000, 0x44af65fc00000000,\n    0xdaafcf3000000000, 0x39a840be00000000, 0xa7a8ea7200000000,\n    0xbea12f7800000000, 0x20a185b400000000, 0xc3a60a3a00000000,\n    0x5da6a0f600000000, 0x8ce74daa00000000, 0x12e7e76600000000,\n    0xf1e068e800000000, 0x6fe0c22400000000, 0x76e9072e00000000,\n    0xe8e9ade200000000, 0x0bee226c00000000, 0x95ee88a000000000,\n    0x39fca87900000000, 0xa7fc02b500000000, 0x44fb8d3b00000000,\n    0xdafb27f700000000, 0xc3f2e2fd00000000, 0x5df2483100000000,\n    0xbef5c7bf00000000, 0x20f56d7300000000, 0xa7d6f6d600000000,\n    0x39d65c1a00000000, 0xdad1d39400000000, 0x44d1795800000000,\n    0x5dd8bc5200000000, 0xc3d8169e00000000, 0x20df991000000000,\n    0xbedf33dc00000000, 0x12cd130500000000, 0x8ccdb9c900000000,\n    0x6fca364700000000, 0xf1ca9c8b00000000, 0xe8c3598100000000,\n    0x76c3f34d00000000, 0x95c47cc300000000, 0x0bc4d60f00000000,\n    0x3747a67a00000000, 0xa9470cb600000000, 0x4a40833800000000,\n    0xd44029f400000000, 0xcd49ecfe00000000, 0x5349463200000000,\n    0xb04ec9bc00000000, 0x2e4e637000000000, 0x825c43a900000000,\n    0x1c5ce96500000000, 0xff5b66eb00000000, 0x615bcc2700000000,\n    0x7852092d00000000, 0xe652a3e100000000, 0x05552c6f00000000,\n    0x9b5586a300000000, 0x1c761d0600000000, 0x8276b7ca00000000,\n    0x6171384400000000, 0xff71928800000000, 0xe678578200000000,\n    0x7878fd4e00000000, 0x9b7f72c000000000, 0x057fd80c00000000,\n    0xa96df8d500000000, 0x376d521900000000, 0xd46add9700000000,\n    0x4a6a775b00000000, 0x5363b25100000000, 0xcd63189d00000000,\n    0x2e64971300000000, 0xb0643ddf00000000, 0x6125d08300000000,\n    0xff257a4f00000000, 0x1c22f5c100000000, 0x82225f0d00000000,\n    0x9b2b9a0700000000, 0x052b30cb00000000, 0xe62cbf4500000000,\n    0x782c158900000000, 0xd43e355000000000, 0x4a3e9f9c00000000,\n    0xa939101200000000, 0x3739bade00000000, 0x2e307fd400000000,\n    0xb030d51800000000, 0x53375a9600000000, 0xcd37f05a00000000,\n    0x4a146bff00000000, 0xd414c13300000000, 0x37134ebd00000000,\n    0xa913e47100000000, 0xb01a217b00000000, 0x2e1a8bb700000000,\n    0xcd1d043900000000, 0x531daef500000000, 0xff0f8e2c00000000,\n    0x610f24e000000000, 0x8208ab6e00000000, 0x1c0801a200000000,\n    0x0501c4a800000000, 0x9b016e6400000000, 0x7806e1ea00000000,\n    0xe6064b2600000000}};\n\n#else /* W == 4 */\n\nlocal const z_crc_t FAR crc_braid_table[][256] = {\n   {0x00000000, 0xb8bc6765, 0xaa09c88b, 0x12b5afee, 0x8f629757,\n    0x37def032, 0x256b5fdc, 0x9dd738b9, 0xc5b428ef, 0x7d084f8a,\n    0x6fbde064, 0xd7018701, 0x4ad6bfb8, 0xf26ad8dd, 0xe0df7733,\n    0x58631056, 0x5019579f, 0xe8a530fa, 0xfa109f14, 0x42acf871,\n    0xdf7bc0c8, 0x67c7a7ad, 0x75720843, 0xcdce6f26, 0x95ad7f70,\n    0x2d111815, 0x3fa4b7fb, 0x8718d09e, 0x1acfe827, 0xa2738f42,\n    0xb0c620ac, 0x087a47c9, 0xa032af3e, 0x188ec85b, 0x0a3b67b5,\n    0xb28700d0, 0x2f503869, 0x97ec5f0c, 0x8559f0e2, 0x3de59787,\n    0x658687d1, 0xdd3ae0b4, 0xcf8f4f5a, 0x7733283f, 0xeae41086,\n    0x525877e3, 0x40edd80d, 0xf851bf68, 0xf02bf8a1, 0x48979fc4,\n    0x5a22302a, 0xe29e574f, 0x7f496ff6, 0xc7f50893, 0xd540a77d,\n    0x6dfcc018, 0x359fd04e, 0x8d23b72b, 0x9f9618c5, 0x272a7fa0,\n    0xbafd4719, 0x0241207c, 0x10f48f92, 0xa848e8f7, 0x9b14583d,\n    0x23a83f58, 0x311d90b6, 0x89a1f7d3, 0x1476cf6a, 0xaccaa80f,\n    0xbe7f07e1, 0x06c36084, 0x5ea070d2, 0xe61c17b7, 0xf4a9b859,\n    0x4c15df3c, 0xd1c2e785, 0x697e80e0, 0x7bcb2f0e, 0xc377486b,\n    0xcb0d0fa2, 0x73b168c7, 0x6104c729, 0xd9b8a04c, 0x446f98f5,\n    0xfcd3ff90, 0xee66507e, 0x56da371b, 0x0eb9274d, 0xb6054028,\n    0xa4b0efc6, 0x1c0c88a3, 0x81dbb01a, 0x3967d77f, 0x2bd27891,\n    0x936e1ff4, 0x3b26f703, 0x839a9066, 0x912f3f88, 0x299358ed,\n    0xb4446054, 0x0cf80731, 0x1e4da8df, 0xa6f1cfba, 0xfe92dfec,\n    0x462eb889, 0x549b1767, 0xec277002, 0x71f048bb, 0xc94c2fde,\n    0xdbf98030, 0x6345e755, 0x6b3fa09c, 0xd383c7f9, 0xc1366817,\n    0x798a0f72, 0xe45d37cb, 0x5ce150ae, 0x4e54ff40, 0xf6e89825,\n    0xae8b8873, 0x1637ef16, 0x048240f8, 0xbc3e279d, 0x21e91f24,\n    0x99557841, 0x8be0d7af, 0x335cb0ca, 0xed59b63b, 0x55e5d15e,\n    0x47507eb0, 0xffec19d5, 0x623b216c, 0xda874609, 0xc832e9e7,\n    0x708e8e82, 0x28ed9ed4, 0x9051f9b1, 0x82e4565f, 0x3a58313a,\n    0xa78f0983, 0x1f336ee6, 0x0d86c108, 0xb53aa66d, 0xbd40e1a4,\n    0x05fc86c1, 0x1749292f, 0xaff54e4a, 0x322276f3, 0x8a9e1196,\n    0x982bbe78, 0x2097d91d, 0x78f4c94b, 0xc048ae2e, 0xd2fd01c0,\n    0x6a4166a5, 0xf7965e1c, 0x4f2a3979, 0x5d9f9697, 0xe523f1f2,\n    0x4d6b1905, 0xf5d77e60, 0xe762d18e, 0x5fdeb6eb, 0xc2098e52,\n    0x7ab5e937, 0x680046d9, 0xd0bc21bc, 0x88df31ea, 0x3063568f,\n    0x22d6f961, 0x9a6a9e04, 0x07bda6bd, 0xbf01c1d8, 0xadb46e36,\n    0x15080953, 0x1d724e9a, 0xa5ce29ff, 0xb77b8611, 0x0fc7e174,\n    0x9210d9cd, 0x2aacbea8, 0x38191146, 0x80a57623, 0xd8c66675,\n    0x607a0110, 0x72cfaefe, 0xca73c99b, 0x57a4f122, 0xef189647,\n    0xfdad39a9, 0x45115ecc, 0x764dee06, 0xcef18963, 0xdc44268d,\n    0x64f841e8, 0xf92f7951, 0x41931e34, 0x5326b1da, 0xeb9ad6bf,\n    0xb3f9c6e9, 0x0b45a18c, 0x19f00e62, 0xa14c6907, 0x3c9b51be,\n    0x842736db, 0x96929935, 0x2e2efe50, 0x2654b999, 0x9ee8defc,\n    0x8c5d7112, 0x34e11677, 0xa9362ece, 0x118a49ab, 0x033fe645,\n    0xbb838120, 0xe3e09176, 0x5b5cf613, 0x49e959fd, 0xf1553e98,\n    0x6c820621, 0xd43e6144, 0xc68bceaa, 0x7e37a9cf, 0xd67f4138,\n    0x6ec3265d, 0x7c7689b3, 0xc4caeed6, 0x591dd66f, 0xe1a1b10a,\n    0xf3141ee4, 0x4ba87981, 0x13cb69d7, 0xab770eb2, 0xb9c2a15c,\n    0x017ec639, 0x9ca9fe80, 0x241599e5, 0x36a0360b, 0x8e1c516e,\n    0x866616a7, 0x3eda71c2, 0x2c6fde2c, 0x94d3b949, 0x090481f0,\n    0xb1b8e695, 0xa30d497b, 0x1bb12e1e, 0x43d23e48, 0xfb6e592d,\n    0xe9dbf6c3, 0x516791a6, 0xccb0a91f, 0x740cce7a, 0x66b96194,\n    0xde0506f1},\n   {0x00000000, 0x01c26a37, 0x0384d46e, 0x0246be59, 0x0709a8dc,\n    0x06cbc2eb, 0x048d7cb2, 0x054f1685, 0x0e1351b8, 0x0fd13b8f,\n    0x0d9785d6, 0x0c55efe1, 0x091af964, 0x08d89353, 0x0a9e2d0a,\n    0x0b5c473d, 0x1c26a370, 0x1de4c947, 0x1fa2771e, 0x1e601d29,\n    0x1b2f0bac, 0x1aed619b, 0x18abdfc2, 0x1969b5f5, 0x1235f2c8,\n    0x13f798ff, 0x11b126a6, 0x10734c91, 0x153c5a14, 0x14fe3023,\n    0x16b88e7a, 0x177ae44d, 0x384d46e0, 0x398f2cd7, 0x3bc9928e,\n    0x3a0bf8b9, 0x3f44ee3c, 0x3e86840b, 0x3cc03a52, 0x3d025065,\n    0x365e1758, 0x379c7d6f, 0x35dac336, 0x3418a901, 0x3157bf84,\n    0x3095d5b3, 0x32d36bea, 0x331101dd, 0x246be590, 0x25a98fa7,\n    0x27ef31fe, 0x262d5bc9, 0x23624d4c, 0x22a0277b, 0x20e69922,\n    0x2124f315, 0x2a78b428, 0x2bbade1f, 0x29fc6046, 0x283e0a71,\n    0x2d711cf4, 0x2cb376c3, 0x2ef5c89a, 0x2f37a2ad, 0x709a8dc0,\n    0x7158e7f7, 0x731e59ae, 0x72dc3399, 0x7793251c, 0x76514f2b,\n    0x7417f172, 0x75d59b45, 0x7e89dc78, 0x7f4bb64f, 0x7d0d0816,\n    0x7ccf6221, 0x798074a4, 0x78421e93, 0x7a04a0ca, 0x7bc6cafd,\n    0x6cbc2eb0, 0x6d7e4487, 0x6f38fade, 0x6efa90e9, 0x6bb5866c,\n    0x6a77ec5b, 0x68315202, 0x69f33835, 0x62af7f08, 0x636d153f,\n    0x612bab66, 0x60e9c151, 0x65a6d7d4, 0x6464bde3, 0x662203ba,\n    0x67e0698d, 0x48d7cb20, 0x4915a117, 0x4b531f4e, 0x4a917579,\n    0x4fde63fc, 0x4e1c09cb, 0x4c5ab792, 0x4d98dda5, 0x46c49a98,\n    0x4706f0af, 0x45404ef6, 0x448224c1, 0x41cd3244, 0x400f5873,\n    0x4249e62a, 0x438b8c1d, 0x54f16850, 0x55330267, 0x5775bc3e,\n    0x56b7d609, 0x53f8c08c, 0x523aaabb, 0x507c14e2, 0x51be7ed5,\n    0x5ae239e8, 0x5b2053df, 0x5966ed86, 0x58a487b1, 0x5deb9134,\n    0x5c29fb03, 0x5e6f455a, 0x5fad2f6d, 0xe1351b80, 0xe0f771b7,\n    0xe2b1cfee, 0xe373a5d9, 0xe63cb35c, 0xe7fed96b, 0xe5b86732,\n    0xe47a0d05, 0xef264a38, 0xeee4200f, 0xeca29e56, 0xed60f461,\n    0xe82fe2e4, 0xe9ed88d3, 0xebab368a, 0xea695cbd, 0xfd13b8f0,\n    0xfcd1d2c7, 0xfe976c9e, 0xff5506a9, 0xfa1a102c, 0xfbd87a1b,\n    0xf99ec442, 0xf85cae75, 0xf300e948, 0xf2c2837f, 0xf0843d26,\n    0xf1465711, 0xf4094194, 0xf5cb2ba3, 0xf78d95fa, 0xf64fffcd,\n    0xd9785d60, 0xd8ba3757, 0xdafc890e, 0xdb3ee339, 0xde71f5bc,\n    0xdfb39f8b, 0xddf521d2, 0xdc374be5, 0xd76b0cd8, 0xd6a966ef,\n    0xd4efd8b6, 0xd52db281, 0xd062a404, 0xd1a0ce33, 0xd3e6706a,\n    0xd2241a5d, 0xc55efe10, 0xc49c9427, 0xc6da2a7e, 0xc7184049,\n    0xc25756cc, 0xc3953cfb, 0xc1d382a2, 0xc011e895, 0xcb4dafa8,\n    0xca8fc59f, 0xc8c97bc6, 0xc90b11f1, 0xcc440774, 0xcd866d43,\n    0xcfc0d31a, 0xce02b92d, 0x91af9640, 0x906dfc77, 0x922b422e,\n    0x93e92819, 0x96a63e9c, 0x976454ab, 0x9522eaf2, 0x94e080c5,\n    0x9fbcc7f8, 0x9e7eadcf, 0x9c381396, 0x9dfa79a1, 0x98b56f24,\n    0x99770513, 0x9b31bb4a, 0x9af3d17d, 0x8d893530, 0x8c4b5f07,\n    0x8e0de15e, 0x8fcf8b69, 0x8a809dec, 0x8b42f7db, 0x89044982,\n    0x88c623b5, 0x839a6488, 0x82580ebf, 0x801eb0e6, 0x81dcdad1,\n    0x8493cc54, 0x8551a663, 0x8717183a, 0x86d5720d, 0xa9e2d0a0,\n    0xa820ba97, 0xaa6604ce, 0xaba46ef9, 0xaeeb787c, 0xaf29124b,\n    0xad6fac12, 0xacadc625, 0xa7f18118, 0xa633eb2f, 0xa4755576,\n    0xa5b73f41, 0xa0f829c4, 0xa13a43f3, 0xa37cfdaa, 0xa2be979d,\n    0xb5c473d0, 0xb40619e7, 0xb640a7be, 0xb782cd89, 0xb2cddb0c,\n    0xb30fb13b, 0xb1490f62, 0xb08b6555, 0xbbd72268, 0xba15485f,\n    0xb853f606, 0xb9919c31, 0xbcde8ab4, 0xbd1ce083, 0xbf5a5eda,\n    0xbe9834ed},\n   {0x00000000, 0x191b3141, 0x32366282, 0x2b2d53c3, 0x646cc504,\n    0x7d77f445, 0x565aa786, 0x4f4196c7, 0xc8d98a08, 0xd1c2bb49,\n    0xfaefe88a, 0xe3f4d9cb, 0xacb54f0c, 0xb5ae7e4d, 0x9e832d8e,\n    0x87981ccf, 0x4ac21251, 0x53d92310, 0x78f470d3, 0x61ef4192,\n    0x2eaed755, 0x37b5e614, 0x1c98b5d7, 0x05838496, 0x821b9859,\n    0x9b00a918, 0xb02dfadb, 0xa936cb9a, 0xe6775d5d, 0xff6c6c1c,\n    0xd4413fdf, 0xcd5a0e9e, 0x958424a2, 0x8c9f15e3, 0xa7b24620,\n    0xbea97761, 0xf1e8e1a6, 0xe8f3d0e7, 0xc3de8324, 0xdac5b265,\n    0x5d5daeaa, 0x44469feb, 0x6f6bcc28, 0x7670fd69, 0x39316bae,\n    0x202a5aef, 0x0b07092c, 0x121c386d, 0xdf4636f3, 0xc65d07b2,\n    0xed705471, 0xf46b6530, 0xbb2af3f7, 0xa231c2b6, 0x891c9175,\n    0x9007a034, 0x179fbcfb, 0x0e848dba, 0x25a9de79, 0x3cb2ef38,\n    0x73f379ff, 0x6ae848be, 0x41c51b7d, 0x58de2a3c, 0xf0794f05,\n    0xe9627e44, 0xc24f2d87, 0xdb541cc6, 0x94158a01, 0x8d0ebb40,\n    0xa623e883, 0xbf38d9c2, 0x38a0c50d, 0x21bbf44c, 0x0a96a78f,\n    0x138d96ce, 0x5ccc0009, 0x45d73148, 0x6efa628b, 0x77e153ca,\n    0xbabb5d54, 0xa3a06c15, 0x888d3fd6, 0x91960e97, 0xded79850,\n    0xc7cca911, 0xece1fad2, 0xf5facb93, 0x7262d75c, 0x6b79e61d,\n    0x4054b5de, 0x594f849f, 0x160e1258, 0x0f152319, 0x243870da,\n    0x3d23419b, 0x65fd6ba7, 0x7ce65ae6, 0x57cb0925, 0x4ed03864,\n    0x0191aea3, 0x188a9fe2, 0x33a7cc21, 0x2abcfd60, 0xad24e1af,\n    0xb43fd0ee, 0x9f12832d, 0x8609b26c, 0xc94824ab, 0xd05315ea,\n    0xfb7e4629, 0xe2657768, 0x2f3f79f6, 0x362448b7, 0x1d091b74,\n    0x04122a35, 0x4b53bcf2, 0x52488db3, 0x7965de70, 0x607eef31,\n    0xe7e6f3fe, 0xfefdc2bf, 0xd5d0917c, 0xcccba03d, 0x838a36fa,\n    0x9a9107bb, 0xb1bc5478, 0xa8a76539, 0x3b83984b, 0x2298a90a,\n    0x09b5fac9, 0x10aecb88, 0x5fef5d4f, 0x46f46c0e, 0x6dd93fcd,\n    0x74c20e8c, 0xf35a1243, 0xea412302, 0xc16c70c1, 0xd8774180,\n    0x9736d747, 0x8e2de606, 0xa500b5c5, 0xbc1b8484, 0x71418a1a,\n    0x685abb5b, 0x4377e898, 0x5a6cd9d9, 0x152d4f1e, 0x0c367e5f,\n    0x271b2d9c, 0x3e001cdd, 0xb9980012, 0xa0833153, 0x8bae6290,\n    0x92b553d1, 0xddf4c516, 0xc4eff457, 0xefc2a794, 0xf6d996d5,\n    0xae07bce9, 0xb71c8da8, 0x9c31de6b, 0x852aef2a, 0xca6b79ed,\n    0xd37048ac, 0xf85d1b6f, 0xe1462a2e, 0x66de36e1, 0x7fc507a0,\n    0x54e85463, 0x4df36522, 0x02b2f3e5, 0x1ba9c2a4, 0x30849167,\n    0x299fa026, 0xe4c5aeb8, 0xfdde9ff9, 0xd6f3cc3a, 0xcfe8fd7b,\n    0x80a96bbc, 0x99b25afd, 0xb29f093e, 0xab84387f, 0x2c1c24b0,\n    0x350715f1, 0x1e2a4632, 0x07317773, 0x4870e1b4, 0x516bd0f5,\n    0x7a468336, 0x635db277, 0xcbfad74e, 0xd2e1e60f, 0xf9ccb5cc,\n    0xe0d7848d, 0xaf96124a, 0xb68d230b, 0x9da070c8, 0x84bb4189,\n    0x03235d46, 0x1a386c07, 0x31153fc4, 0x280e0e85, 0x674f9842,\n    0x7e54a903, 0x5579fac0, 0x4c62cb81, 0x8138c51f, 0x9823f45e,\n    0xb30ea79d, 0xaa1596dc, 0xe554001b, 0xfc4f315a, 0xd7626299,\n    0xce7953d8, 0x49e14f17, 0x50fa7e56, 0x7bd72d95, 0x62cc1cd4,\n    0x2d8d8a13, 0x3496bb52, 0x1fbbe891, 0x06a0d9d0, 0x5e7ef3ec,\n    0x4765c2ad, 0x6c48916e, 0x7553a02f, 0x3a1236e8, 0x230907a9,\n    0x0824546a, 0x113f652b, 0x96a779e4, 0x8fbc48a5, 0xa4911b66,\n    0xbd8a2a27, 0xf2cbbce0, 0xebd08da1, 0xc0fdde62, 0xd9e6ef23,\n    0x14bce1bd, 0x0da7d0fc, 0x268a833f, 0x3f91b27e, 0x70d024b9,\n    0x69cb15f8, 0x42e6463b, 0x5bfd777a, 0xdc656bb5, 0xc57e5af4,\n    0xee530937, 0xf7483876, 0xb809aeb1, 0xa1129ff0, 0x8a3fcc33,\n    0x9324fd72},\n   {0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419,\n    0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4,\n    0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07,\n    0x90bf1d91, 0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de,\n    0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856,\n    0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,\n    0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4,\n    0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,\n    0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3,\n    0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a,\n    0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599,\n    0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,\n    0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190,\n    0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f,\n    0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f934, 0x9609a88e,\n    0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,\n    0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed,\n    0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,\n    0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3,\n    0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2,\n    0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a,\n    0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5,\n    0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010,\n    0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,\n    0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17,\n    0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6,\n    0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615,\n    0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8,\n    0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, 0xf00f9344,\n    0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,\n    0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a,\n    0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,\n    0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1,\n    0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c,\n    0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef,\n    0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,\n    0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe,\n    0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31,\n    0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c,\n    0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,\n    0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b,\n    0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,\n    0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1,\n    0x18b74777, 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c,\n    0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278,\n    0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7,\n    0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66,\n    0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,\n    0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605,\n    0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8,\n    0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b,\n    0x2d02ef8d}};\n\nlocal const z_word_t FAR crc_braid_big_table[][256] = {\n   {0x00000000, 0x96300777, 0x2c610eee, 0xba510999, 0x19c46d07,\n    0x8ff46a70, 0x35a563e9, 0xa395649e, 0x3288db0e, 0xa4b8dc79,\n    0x1ee9d5e0, 0x88d9d297, 0x2b4cb609, 0xbd7cb17e, 0x072db8e7,\n    0x911dbf90, 0x6410b71d, 0xf220b06a, 0x4871b9f3, 0xde41be84,\n    0x7dd4da1a, 0xebe4dd6d, 0x51b5d4f4, 0xc785d383, 0x56986c13,\n    0xc0a86b64, 0x7af962fd, 0xecc9658a, 0x4f5c0114, 0xd96c0663,\n    0x633d0ffa, 0xf50d088d, 0xc8206e3b, 0x5e10694c, 0xe44160d5,\n    0x727167a2, 0xd1e4033c, 0x47d4044b, 0xfd850dd2, 0x6bb50aa5,\n    0xfaa8b535, 0x6c98b242, 0xd6c9bbdb, 0x40f9bcac, 0xe36cd832,\n    0x755cdf45, 0xcf0dd6dc, 0x593dd1ab, 0xac30d926, 0x3a00de51,\n    0x8051d7c8, 0x1661d0bf, 0xb5f4b421, 0x23c4b356, 0x9995bacf,\n    0x0fa5bdb8, 0x9eb80228, 0x0888055f, 0xb2d90cc6, 0x24e90bb1,\n    0x877c6f2f, 0x114c6858, 0xab1d61c1, 0x3d2d66b6, 0x9041dc76,\n    0x0671db01, 0xbc20d298, 0x2a10d5ef, 0x8985b171, 0x1fb5b606,\n    0xa5e4bf9f, 0x33d4b8e8, 0xa2c90778, 0x34f9000f, 0x8ea80996,\n    0x18980ee1, 0xbb0d6a7f, 0x2d3d6d08, 0x976c6491, 0x015c63e6,\n    0xf4516b6b, 0x62616c1c, 0xd8306585, 0x4e0062f2, 0xed95066c,\n    0x7ba5011b, 0xc1f40882, 0x57c40ff5, 0xc6d9b065, 0x50e9b712,\n    0xeab8be8b, 0x7c88b9fc, 0xdf1ddd62, 0x492dda15, 0xf37cd38c,\n    0x654cd4fb, 0x5861b24d, 0xce51b53a, 0x7400bca3, 0xe230bbd4,\n    0x41a5df4a, 0xd795d83d, 0x6dc4d1a4, 0xfbf4d6d3, 0x6ae96943,\n    0xfcd96e34, 0x468867ad, 0xd0b860da, 0x732d0444, 0xe51d0333,\n    0x5f4c0aaa, 0xc97c0ddd, 0x3c710550, 0xaa410227, 0x10100bbe,\n    0x86200cc9, 0x25b56857, 0xb3856f20, 0x09d466b9, 0x9fe461ce,\n    0x0ef9de5e, 0x98c9d929, 0x2298d0b0, 0xb4a8d7c7, 0x173db359,\n    0x810db42e, 0x3b5cbdb7, 0xad6cbac0, 0x2083b8ed, 0xb6b3bf9a,\n    0x0ce2b603, 0x9ad2b174, 0x3947d5ea, 0xaf77d29d, 0x1526db04,\n    0x8316dc73, 0x120b63e3, 0x843b6494, 0x3e6a6d0d, 0xa85a6a7a,\n    0x0bcf0ee4, 0x9dff0993, 0x27ae000a, 0xb19e077d, 0x44930ff0,\n    0xd2a30887, 0x68f2011e, 0xfec20669, 0x5d5762f7, 0xcb676580,\n    0x71366c19, 0xe7066b6e, 0x761bd4fe, 0xe02bd389, 0x5a7ada10,\n    0xcc4add67, 0x6fdfb9f9, 0xf9efbe8e, 0x43beb717, 0xd58eb060,\n    0xe8a3d6d6, 0x7e93d1a1, 0xc4c2d838, 0x52f2df4f, 0xf167bbd1,\n    0x6757bca6, 0xdd06b53f, 0x4b36b248, 0xda2b0dd8, 0x4c1b0aaf,\n    0xf64a0336, 0x607a0441, 0xc3ef60df, 0x55df67a8, 0xef8e6e31,\n    0x79be6946, 0x8cb361cb, 0x1a8366bc, 0xa0d26f25, 0x36e26852,\n    0x95770ccc, 0x03470bbb, 0xb9160222, 0x2f260555, 0xbe3bbac5,\n    0x280bbdb2, 0x925ab42b, 0x046ab35c, 0xa7ffd7c2, 0x31cfd0b5,\n    0x8b9ed92c, 0x1daede5b, 0xb0c2649b, 0x26f263ec, 0x9ca36a75,\n    0x0a936d02, 0xa906099c, 0x3f360eeb, 0x85670772, 0x13570005,\n    0x824abf95, 0x147ab8e2, 0xae2bb17b, 0x381bb60c, 0x9b8ed292,\n    0x0dbed5e5, 0xb7efdc7c, 0x21dfdb0b, 0xd4d2d386, 0x42e2d4f1,\n    0xf8b3dd68, 0x6e83da1f, 0xcd16be81, 0x5b26b9f6, 0xe177b06f,\n    0x7747b718, 0xe65a0888, 0x706a0fff, 0xca3b0666, 0x5c0b0111,\n    0xff9e658f, 0x69ae62f8, 0xd3ff6b61, 0x45cf6c16, 0x78e20aa0,\n    0xeed20dd7, 0x5483044e, 0xc2b30339, 0x612667a7, 0xf71660d0,\n    0x4d476949, 0xdb776e3e, 0x4a6ad1ae, 0xdc5ad6d9, 0x660bdf40,\n    0xf03bd837, 0x53aebca9, 0xc59ebbde, 0x7fcfb247, 0xe9ffb530,\n    0x1cf2bdbd, 0x8ac2baca, 0x3093b353, 0xa6a3b424, 0x0536d0ba,\n    0x9306d7cd, 0x2957de54, 0xbf67d923, 0x2e7a66b3, 0xb84a61c4,\n    0x021b685d, 0x942b6f2a, 0x37be0bb4, 0xa18e0cc3, 0x1bdf055a,\n    0x8def022d},\n   {0x00000000, 0x41311b19, 0x82623632, 0xc3532d2b, 0x04c56c64,\n    0x45f4777d, 0x86a75a56, 0xc796414f, 0x088ad9c8, 0x49bbc2d1,\n    0x8ae8effa, 0xcbd9f4e3, 0x0c4fb5ac, 0x4d7eaeb5, 0x8e2d839e,\n    0xcf1c9887, 0x5112c24a, 0x1023d953, 0xd370f478, 0x9241ef61,\n    0x55d7ae2e, 0x14e6b537, 0xd7b5981c, 0x96848305, 0x59981b82,\n    0x18a9009b, 0xdbfa2db0, 0x9acb36a9, 0x5d5d77e6, 0x1c6c6cff,\n    0xdf3f41d4, 0x9e0e5acd, 0xa2248495, 0xe3159f8c, 0x2046b2a7,\n    0x6177a9be, 0xa6e1e8f1, 0xe7d0f3e8, 0x2483dec3, 0x65b2c5da,\n    0xaaae5d5d, 0xeb9f4644, 0x28cc6b6f, 0x69fd7076, 0xae6b3139,\n    0xef5a2a20, 0x2c09070b, 0x6d381c12, 0xf33646df, 0xb2075dc6,\n    0x715470ed, 0x30656bf4, 0xf7f32abb, 0xb6c231a2, 0x75911c89,\n    0x34a00790, 0xfbbc9f17, 0xba8d840e, 0x79dea925, 0x38efb23c,\n    0xff79f373, 0xbe48e86a, 0x7d1bc541, 0x3c2ade58, 0x054f79f0,\n    0x447e62e9, 0x872d4fc2, 0xc61c54db, 0x018a1594, 0x40bb0e8d,\n    0x83e823a6, 0xc2d938bf, 0x0dc5a038, 0x4cf4bb21, 0x8fa7960a,\n    0xce968d13, 0x0900cc5c, 0x4831d745, 0x8b62fa6e, 0xca53e177,\n    0x545dbbba, 0x156ca0a3, 0xd63f8d88, 0x970e9691, 0x5098d7de,\n    0x11a9ccc7, 0xd2fae1ec, 0x93cbfaf5, 0x5cd76272, 0x1de6796b,\n    0xdeb55440, 0x9f844f59, 0x58120e16, 0x1923150f, 0xda703824,\n    0x9b41233d, 0xa76bfd65, 0xe65ae67c, 0x2509cb57, 0x6438d04e,\n    0xa3ae9101, 0xe29f8a18, 0x21cca733, 0x60fdbc2a, 0xafe124ad,\n    0xeed03fb4, 0x2d83129f, 0x6cb20986, 0xab2448c9, 0xea1553d0,\n    0x29467efb, 0x687765e2, 0xf6793f2f, 0xb7482436, 0x741b091d,\n    0x352a1204, 0xf2bc534b, 0xb38d4852, 0x70de6579, 0x31ef7e60,\n    0xfef3e6e7, 0xbfc2fdfe, 0x7c91d0d5, 0x3da0cbcc, 0xfa368a83,\n    0xbb07919a, 0x7854bcb1, 0x3965a7a8, 0x4b98833b, 0x0aa99822,\n    0xc9fab509, 0x88cbae10, 0x4f5def5f, 0x0e6cf446, 0xcd3fd96d,\n    0x8c0ec274, 0x43125af3, 0x022341ea, 0xc1706cc1, 0x804177d8,\n    0x47d73697, 0x06e62d8e, 0xc5b500a5, 0x84841bbc, 0x1a8a4171,\n    0x5bbb5a68, 0x98e87743, 0xd9d96c5a, 0x1e4f2d15, 0x5f7e360c,\n    0x9c2d1b27, 0xdd1c003e, 0x120098b9, 0x533183a0, 0x9062ae8b,\n    0xd153b592, 0x16c5f4dd, 0x57f4efc4, 0x94a7c2ef, 0xd596d9f6,\n    0xe9bc07ae, 0xa88d1cb7, 0x6bde319c, 0x2aef2a85, 0xed796bca,\n    0xac4870d3, 0x6f1b5df8, 0x2e2a46e1, 0xe136de66, 0xa007c57f,\n    0x6354e854, 0x2265f34d, 0xe5f3b202, 0xa4c2a91b, 0x67918430,\n    0x26a09f29, 0xb8aec5e4, 0xf99fdefd, 0x3accf3d6, 0x7bfde8cf,\n    0xbc6ba980, 0xfd5ab299, 0x3e099fb2, 0x7f3884ab, 0xb0241c2c,\n    0xf1150735, 0x32462a1e, 0x73773107, 0xb4e17048, 0xf5d06b51,\n    0x3683467a, 0x77b25d63, 0x4ed7facb, 0x0fe6e1d2, 0xccb5ccf9,\n    0x8d84d7e0, 0x4a1296af, 0x0b238db6, 0xc870a09d, 0x8941bb84,\n    0x465d2303, 0x076c381a, 0xc43f1531, 0x850e0e28, 0x42984f67,\n    0x03a9547e, 0xc0fa7955, 0x81cb624c, 0x1fc53881, 0x5ef42398,\n    0x9da70eb3, 0xdc9615aa, 0x1b0054e5, 0x5a314ffc, 0x996262d7,\n    0xd85379ce, 0x174fe149, 0x567efa50, 0x952dd77b, 0xd41ccc62,\n    0x138a8d2d, 0x52bb9634, 0x91e8bb1f, 0xd0d9a006, 0xecf37e5e,\n    0xadc26547, 0x6e91486c, 0x2fa05375, 0xe836123a, 0xa9070923,\n    0x6a542408, 0x2b653f11, 0xe479a796, 0xa548bc8f, 0x661b91a4,\n    0x272a8abd, 0xe0bccbf2, 0xa18dd0eb, 0x62defdc0, 0x23efe6d9,\n    0xbde1bc14, 0xfcd0a70d, 0x3f838a26, 0x7eb2913f, 0xb924d070,\n    0xf815cb69, 0x3b46e642, 0x7a77fd5b, 0xb56b65dc, 0xf45a7ec5,\n    0x370953ee, 0x763848f7, 0xb1ae09b8, 0xf09f12a1, 0x33cc3f8a,\n    0x72fd2493},\n   {0x00000000, 0x376ac201, 0x6ed48403, 0x59be4602, 0xdca80907,\n    0xebc2cb06, 0xb27c8d04, 0x85164f05, 0xb851130e, 0x8f3bd10f,\n    0xd685970d, 0xe1ef550c, 0x64f91a09, 0x5393d808, 0x0a2d9e0a,\n    0x3d475c0b, 0x70a3261c, 0x47c9e41d, 0x1e77a21f, 0x291d601e,\n    0xac0b2f1b, 0x9b61ed1a, 0xc2dfab18, 0xf5b56919, 0xc8f23512,\n    0xff98f713, 0xa626b111, 0x914c7310, 0x145a3c15, 0x2330fe14,\n    0x7a8eb816, 0x4de47a17, 0xe0464d38, 0xd72c8f39, 0x8e92c93b,\n    0xb9f80b3a, 0x3cee443f, 0x0b84863e, 0x523ac03c, 0x6550023d,\n    0x58175e36, 0x6f7d9c37, 0x36c3da35, 0x01a91834, 0x84bf5731,\n    0xb3d59530, 0xea6bd332, 0xdd011133, 0x90e56b24, 0xa78fa925,\n    0xfe31ef27, 0xc95b2d26, 0x4c4d6223, 0x7b27a022, 0x2299e620,\n    0x15f32421, 0x28b4782a, 0x1fdeba2b, 0x4660fc29, 0x710a3e28,\n    0xf41c712d, 0xc376b32c, 0x9ac8f52e, 0xada2372f, 0xc08d9a70,\n    0xf7e75871, 0xae591e73, 0x9933dc72, 0x1c259377, 0x2b4f5176,\n    0x72f11774, 0x459bd575, 0x78dc897e, 0x4fb64b7f, 0x16080d7d,\n    0x2162cf7c, 0xa4748079, 0x931e4278, 0xcaa0047a, 0xfdcac67b,\n    0xb02ebc6c, 0x87447e6d, 0xdefa386f, 0xe990fa6e, 0x6c86b56b,\n    0x5bec776a, 0x02523168, 0x3538f369, 0x087faf62, 0x3f156d63,\n    0x66ab2b61, 0x51c1e960, 0xd4d7a665, 0xe3bd6464, 0xba032266,\n    0x8d69e067, 0x20cbd748, 0x17a11549, 0x4e1f534b, 0x7975914a,\n    0xfc63de4f, 0xcb091c4e, 0x92b75a4c, 0xa5dd984d, 0x989ac446,\n    0xaff00647, 0xf64e4045, 0xc1248244, 0x4432cd41, 0x73580f40,\n    0x2ae64942, 0x1d8c8b43, 0x5068f154, 0x67023355, 0x3ebc7557,\n    0x09d6b756, 0x8cc0f853, 0xbbaa3a52, 0xe2147c50, 0xd57ebe51,\n    0xe839e25a, 0xdf53205b, 0x86ed6659, 0xb187a458, 0x3491eb5d,\n    0x03fb295c, 0x5a456f5e, 0x6d2fad5f, 0x801b35e1, 0xb771f7e0,\n    0xeecfb1e2, 0xd9a573e3, 0x5cb33ce6, 0x6bd9fee7, 0x3267b8e5,\n    0x050d7ae4, 0x384a26ef, 0x0f20e4ee, 0x569ea2ec, 0x61f460ed,\n    0xe4e22fe8, 0xd388ede9, 0x8a36abeb, 0xbd5c69ea, 0xf0b813fd,\n    0xc7d2d1fc, 0x9e6c97fe, 0xa90655ff, 0x2c101afa, 0x1b7ad8fb,\n    0x42c49ef9, 0x75ae5cf8, 0x48e900f3, 0x7f83c2f2, 0x263d84f0,\n    0x115746f1, 0x944109f4, 0xa32bcbf5, 0xfa958df7, 0xcdff4ff6,\n    0x605d78d9, 0x5737bad8, 0x0e89fcda, 0x39e33edb, 0xbcf571de,\n    0x8b9fb3df, 0xd221f5dd, 0xe54b37dc, 0xd80c6bd7, 0xef66a9d6,\n    0xb6d8efd4, 0x81b22dd5, 0x04a462d0, 0x33cea0d1, 0x6a70e6d3,\n    0x5d1a24d2, 0x10fe5ec5, 0x27949cc4, 0x7e2adac6, 0x494018c7,\n    0xcc5657c2, 0xfb3c95c3, 0xa282d3c1, 0x95e811c0, 0xa8af4dcb,\n    0x9fc58fca, 0xc67bc9c8, 0xf1110bc9, 0x740744cc, 0x436d86cd,\n    0x1ad3c0cf, 0x2db902ce, 0x4096af91, 0x77fc6d90, 0x2e422b92,\n    0x1928e993, 0x9c3ea696, 0xab546497, 0xf2ea2295, 0xc580e094,\n    0xf8c7bc9f, 0xcfad7e9e, 0x9613389c, 0xa179fa9d, 0x246fb598,\n    0x13057799, 0x4abb319b, 0x7dd1f39a, 0x3035898d, 0x075f4b8c,\n    0x5ee10d8e, 0x698bcf8f, 0xec9d808a, 0xdbf7428b, 0x82490489,\n    0xb523c688, 0x88649a83, 0xbf0e5882, 0xe6b01e80, 0xd1dadc81,\n    0x54cc9384, 0x63a65185, 0x3a181787, 0x0d72d586, 0xa0d0e2a9,\n    0x97ba20a8, 0xce0466aa, 0xf96ea4ab, 0x7c78ebae, 0x4b1229af,\n    0x12ac6fad, 0x25c6adac, 0x1881f1a7, 0x2feb33a6, 0x765575a4,\n    0x413fb7a5, 0xc429f8a0, 0xf3433aa1, 0xaafd7ca3, 0x9d97bea2,\n    0xd073c4b5, 0xe71906b4, 0xbea740b6, 0x89cd82b7, 0x0cdbcdb2,\n    0x3bb10fb3, 0x620f49b1, 0x55658bb0, 0x6822d7bb, 0x5f4815ba,\n    0x06f653b8, 0x319c91b9, 0xb48adebc, 0x83e01cbd, 0xda5e5abf,\n    0xed3498be},\n   {0x00000000, 0x6567bcb8, 0x8bc809aa, 0xeeafb512, 0x5797628f,\n    0x32f0de37, 0xdc5f6b25, 0xb938d79d, 0xef28b4c5, 0x8a4f087d,\n    0x64e0bd6f, 0x018701d7, 0xb8bfd64a, 0xddd86af2, 0x3377dfe0,\n    0x56106358, 0x9f571950, 0xfa30a5e8, 0x149f10fa, 0x71f8ac42,\n    0xc8c07bdf, 0xada7c767, 0x43087275, 0x266fcecd, 0x707fad95,\n    0x1518112d, 0xfbb7a43f, 0x9ed01887, 0x27e8cf1a, 0x428f73a2,\n    0xac20c6b0, 0xc9477a08, 0x3eaf32a0, 0x5bc88e18, 0xb5673b0a,\n    0xd00087b2, 0x6938502f, 0x0c5fec97, 0xe2f05985, 0x8797e53d,\n    0xd1878665, 0xb4e03add, 0x5a4f8fcf, 0x3f283377, 0x8610e4ea,\n    0xe3775852, 0x0dd8ed40, 0x68bf51f8, 0xa1f82bf0, 0xc49f9748,\n    0x2a30225a, 0x4f579ee2, 0xf66f497f, 0x9308f5c7, 0x7da740d5,\n    0x18c0fc6d, 0x4ed09f35, 0x2bb7238d, 0xc518969f, 0xa07f2a27,\n    0x1947fdba, 0x7c204102, 0x928ff410, 0xf7e848a8, 0x3d58149b,\n    0x583fa823, 0xb6901d31, 0xd3f7a189, 0x6acf7614, 0x0fa8caac,\n    0xe1077fbe, 0x8460c306, 0xd270a05e, 0xb7171ce6, 0x59b8a9f4,\n    0x3cdf154c, 0x85e7c2d1, 0xe0807e69, 0x0e2fcb7b, 0x6b4877c3,\n    0xa20f0dcb, 0xc768b173, 0x29c70461, 0x4ca0b8d9, 0xf5986f44,\n    0x90ffd3fc, 0x7e5066ee, 0x1b37da56, 0x4d27b90e, 0x284005b6,\n    0xc6efb0a4, 0xa3880c1c, 0x1ab0db81, 0x7fd76739, 0x9178d22b,\n    0xf41f6e93, 0x03f7263b, 0x66909a83, 0x883f2f91, 0xed589329,\n    0x546044b4, 0x3107f80c, 0xdfa84d1e, 0xbacff1a6, 0xecdf92fe,\n    0x89b82e46, 0x67179b54, 0x027027ec, 0xbb48f071, 0xde2f4cc9,\n    0x3080f9db, 0x55e74563, 0x9ca03f6b, 0xf9c783d3, 0x176836c1,\n    0x720f8a79, 0xcb375de4, 0xae50e15c, 0x40ff544e, 0x2598e8f6,\n    0x73888bae, 0x16ef3716, 0xf8408204, 0x9d273ebc, 0x241fe921,\n    0x41785599, 0xafd7e08b, 0xcab05c33, 0x3bb659ed, 0x5ed1e555,\n    0xb07e5047, 0xd519ecff, 0x6c213b62, 0x094687da, 0xe7e932c8,\n    0x828e8e70, 0xd49eed28, 0xb1f95190, 0x5f56e482, 0x3a31583a,\n    0x83098fa7, 0xe66e331f, 0x08c1860d, 0x6da63ab5, 0xa4e140bd,\n    0xc186fc05, 0x2f294917, 0x4a4ef5af, 0xf3762232, 0x96119e8a,\n    0x78be2b98, 0x1dd99720, 0x4bc9f478, 0x2eae48c0, 0xc001fdd2,\n    0xa566416a, 0x1c5e96f7, 0x79392a4f, 0x97969f5d, 0xf2f123e5,\n    0x05196b4d, 0x607ed7f5, 0x8ed162e7, 0xebb6de5f, 0x528e09c2,\n    0x37e9b57a, 0xd9460068, 0xbc21bcd0, 0xea31df88, 0x8f566330,\n    0x61f9d622, 0x049e6a9a, 0xbda6bd07, 0xd8c101bf, 0x366eb4ad,\n    0x53090815, 0x9a4e721d, 0xff29cea5, 0x11867bb7, 0x74e1c70f,\n    0xcdd91092, 0xa8beac2a, 0x46111938, 0x2376a580, 0x7566c6d8,\n    0x10017a60, 0xfeaecf72, 0x9bc973ca, 0x22f1a457, 0x479618ef,\n    0xa939adfd, 0xcc5e1145, 0x06ee4d76, 0x6389f1ce, 0x8d2644dc,\n    0xe841f864, 0x51792ff9, 0x341e9341, 0xdab12653, 0xbfd69aeb,\n    0xe9c6f9b3, 0x8ca1450b, 0x620ef019, 0x07694ca1, 0xbe519b3c,\n    0xdb362784, 0x35999296, 0x50fe2e2e, 0x99b95426, 0xfcdee89e,\n    0x12715d8c, 0x7716e134, 0xce2e36a9, 0xab498a11, 0x45e63f03,\n    0x208183bb, 0x7691e0e3, 0x13f65c5b, 0xfd59e949, 0x983e55f1,\n    0x2106826c, 0x44613ed4, 0xaace8bc6, 0xcfa9377e, 0x38417fd6,\n    0x5d26c36e, 0xb389767c, 0xd6eecac4, 0x6fd61d59, 0x0ab1a1e1,\n    0xe41e14f3, 0x8179a84b, 0xd769cb13, 0xb20e77ab, 0x5ca1c2b9,\n    0x39c67e01, 0x80fea99c, 0xe5991524, 0x0b36a036, 0x6e511c8e,\n    0xa7166686, 0xc271da3e, 0x2cde6f2c, 0x49b9d394, 0xf0810409,\n    0x95e6b8b1, 0x7b490da3, 0x1e2eb11b, 0x483ed243, 0x2d596efb,\n    0xc3f6dbe9, 0xa6916751, 0x1fa9b0cc, 0x7ace0c74, 0x9461b966,\n    0xf10605de}};\n\n#endif\n\n#endif\n\n#if N == 2\n\n#if W == 8\n\nlocal const z_crc_t FAR crc_braid_table[][256] = {\n   {0x00000000, 0xae689191, 0x87a02563, 0x29c8b4f2, 0xd4314c87,\n    0x7a59dd16, 0x539169e4, 0xfdf9f875, 0x73139f4f, 0xdd7b0ede,\n    0xf4b3ba2c, 0x5adb2bbd, 0xa722d3c8, 0x094a4259, 0x2082f6ab,\n    0x8eea673a, 0xe6273e9e, 0x484faf0f, 0x61871bfd, 0xcfef8a6c,\n    0x32167219, 0x9c7ee388, 0xb5b6577a, 0x1bdec6eb, 0x9534a1d1,\n    0x3b5c3040, 0x129484b2, 0xbcfc1523, 0x4105ed56, 0xef6d7cc7,\n    0xc6a5c835, 0x68cd59a4, 0x173f7b7d, 0xb957eaec, 0x909f5e1e,\n    0x3ef7cf8f, 0xc30e37fa, 0x6d66a66b, 0x44ae1299, 0xeac68308,\n    0x642ce432, 0xca4475a3, 0xe38cc151, 0x4de450c0, 0xb01da8b5,\n    0x1e753924, 0x37bd8dd6, 0x99d51c47, 0xf11845e3, 0x5f70d472,\n    0x76b86080, 0xd8d0f111, 0x25290964, 0x8b4198f5, 0xa2892c07,\n    0x0ce1bd96, 0x820bdaac, 0x2c634b3d, 0x05abffcf, 0xabc36e5e,\n    0x563a962b, 0xf85207ba, 0xd19ab348, 0x7ff222d9, 0x2e7ef6fa,\n    0x8016676b, 0xa9ded399, 0x07b64208, 0xfa4fba7d, 0x54272bec,\n    0x7def9f1e, 0xd3870e8f, 0x5d6d69b5, 0xf305f824, 0xdacd4cd6,\n    0x74a5dd47, 0x895c2532, 0x2734b4a3, 0x0efc0051, 0xa09491c0,\n    0xc859c864, 0x663159f5, 0x4ff9ed07, 0xe1917c96, 0x1c6884e3,\n    0xb2001572, 0x9bc8a180, 0x35a03011, 0xbb4a572b, 0x1522c6ba,\n    0x3cea7248, 0x9282e3d9, 0x6f7b1bac, 0xc1138a3d, 0xe8db3ecf,\n    0x46b3af5e, 0x39418d87, 0x97291c16, 0xbee1a8e4, 0x10893975,\n    0xed70c100, 0x43185091, 0x6ad0e463, 0xc4b875f2, 0x4a5212c8,\n    0xe43a8359, 0xcdf237ab, 0x639aa63a, 0x9e635e4f, 0x300bcfde,\n    0x19c37b2c, 0xb7abeabd, 0xdf66b319, 0x710e2288, 0x58c6967a,\n    0xf6ae07eb, 0x0b57ff9e, 0xa53f6e0f, 0x8cf7dafd, 0x229f4b6c,\n    0xac752c56, 0x021dbdc7, 0x2bd50935, 0x85bd98a4, 0x784460d1,\n    0xd62cf140, 0xffe445b2, 0x518cd423, 0x5cfdedf4, 0xf2957c65,\n    0xdb5dc897, 0x75355906, 0x88cca173, 0x26a430e2, 0x0f6c8410,\n    0xa1041581, 0x2fee72bb, 0x8186e32a, 0xa84e57d8, 0x0626c649,\n    0xfbdf3e3c, 0x55b7afad, 0x7c7f1b5f, 0xd2178ace, 0xbadad36a,\n    0x14b242fb, 0x3d7af609, 0x93126798, 0x6eeb9fed, 0xc0830e7c,\n    0xe94bba8e, 0x47232b1f, 0xc9c94c25, 0x67a1ddb4, 0x4e696946,\n    0xe001f8d7, 0x1df800a2, 0xb3909133, 0x9a5825c1, 0x3430b450,\n    0x4bc29689, 0xe5aa0718, 0xcc62b3ea, 0x620a227b, 0x9ff3da0e,\n    0x319b4b9f, 0x1853ff6d, 0xb63b6efc, 0x38d109c6, 0x96b99857,\n    0xbf712ca5, 0x1119bd34, 0xece04541, 0x4288d4d0, 0x6b406022,\n    0xc528f1b3, 0xade5a817, 0x038d3986, 0x2a458d74, 0x842d1ce5,\n    0x79d4e490, 0xd7bc7501, 0xfe74c1f3, 0x501c5062, 0xdef63758,\n    0x709ea6c9, 0x5956123b, 0xf73e83aa, 0x0ac77bdf, 0xa4afea4e,\n    0x8d675ebc, 0x230fcf2d, 0x72831b0e, 0xdceb8a9f, 0xf5233e6d,\n    0x5b4baffc, 0xa6b25789, 0x08dac618, 0x211272ea, 0x8f7ae37b,\n    0x01908441, 0xaff815d0, 0x8630a122, 0x285830b3, 0xd5a1c8c6,\n    0x7bc95957, 0x5201eda5, 0xfc697c34, 0x94a42590, 0x3accb401,\n    0x130400f3, 0xbd6c9162, 0x40956917, 0xeefdf886, 0xc7354c74,\n    0x695ddde5, 0xe7b7badf, 0x49df2b4e, 0x60179fbc, 0xce7f0e2d,\n    0x3386f658, 0x9dee67c9, 0xb426d33b, 0x1a4e42aa, 0x65bc6073,\n    0xcbd4f1e2, 0xe21c4510, 0x4c74d481, 0xb18d2cf4, 0x1fe5bd65,\n    0x362d0997, 0x98459806, 0x16afff3c, 0xb8c76ead, 0x910fda5f,\n    0x3f674bce, 0xc29eb3bb, 0x6cf6222a, 0x453e96d8, 0xeb560749,\n    0x839b5eed, 0x2df3cf7c, 0x043b7b8e, 0xaa53ea1f, 0x57aa126a,\n    0xf9c283fb, 0xd00a3709, 0x7e62a698, 0xf088c1a2, 0x5ee05033,\n    0x7728e4c1, 0xd9407550, 0x24b98d25, 0x8ad11cb4, 0xa319a846,\n    0x0d7139d7},\n   {0x00000000, 0xb9fbdbe8, 0xa886b191, 0x117d6a79, 0x8a7c6563,\n    0x3387be8b, 0x22fad4f2, 0x9b010f1a, 0xcf89cc87, 0x7672176f,\n    0x670f7d16, 0xdef4a6fe, 0x45f5a9e4, 0xfc0e720c, 0xed731875,\n    0x5488c39d, 0x44629f4f, 0xfd9944a7, 0xece42ede, 0x551ff536,\n    0xce1efa2c, 0x77e521c4, 0x66984bbd, 0xdf639055, 0x8beb53c8,\n    0x32108820, 0x236de259, 0x9a9639b1, 0x019736ab, 0xb86ced43,\n    0xa911873a, 0x10ea5cd2, 0x88c53e9e, 0x313ee576, 0x20438f0f,\n    0x99b854e7, 0x02b95bfd, 0xbb428015, 0xaa3fea6c, 0x13c43184,\n    0x474cf219, 0xfeb729f1, 0xefca4388, 0x56319860, 0xcd30977a,\n    0x74cb4c92, 0x65b626eb, 0xdc4dfd03, 0xcca7a1d1, 0x755c7a39,\n    0x64211040, 0xdddacba8, 0x46dbc4b2, 0xff201f5a, 0xee5d7523,\n    0x57a6aecb, 0x032e6d56, 0xbad5b6be, 0xaba8dcc7, 0x1253072f,\n    0x89520835, 0x30a9d3dd, 0x21d4b9a4, 0x982f624c, 0xcafb7b7d,\n    0x7300a095, 0x627dcaec, 0xdb861104, 0x40871e1e, 0xf97cc5f6,\n    0xe801af8f, 0x51fa7467, 0x0572b7fa, 0xbc896c12, 0xadf4066b,\n    0x140fdd83, 0x8f0ed299, 0x36f50971, 0x27886308, 0x9e73b8e0,\n    0x8e99e432, 0x37623fda, 0x261f55a3, 0x9fe48e4b, 0x04e58151,\n    0xbd1e5ab9, 0xac6330c0, 0x1598eb28, 0x411028b5, 0xf8ebf35d,\n    0xe9969924, 0x506d42cc, 0xcb6c4dd6, 0x7297963e, 0x63eafc47,\n    0xda1127af, 0x423e45e3, 0xfbc59e0b, 0xeab8f472, 0x53432f9a,\n    0xc8422080, 0x71b9fb68, 0x60c49111, 0xd93f4af9, 0x8db78964,\n    0x344c528c, 0x253138f5, 0x9ccae31d, 0x07cbec07, 0xbe3037ef,\n    0xaf4d5d96, 0x16b6867e, 0x065cdaac, 0xbfa70144, 0xaeda6b3d,\n    0x1721b0d5, 0x8c20bfcf, 0x35db6427, 0x24a60e5e, 0x9d5dd5b6,\n    0xc9d5162b, 0x702ecdc3, 0x6153a7ba, 0xd8a87c52, 0x43a97348,\n    0xfa52a8a0, 0xeb2fc2d9, 0x52d41931, 0x4e87f0bb, 0xf77c2b53,\n    0xe601412a, 0x5ffa9ac2, 0xc4fb95d8, 0x7d004e30, 0x6c7d2449,\n    0xd586ffa1, 0x810e3c3c, 0x38f5e7d4, 0x29888dad, 0x90735645,\n    0x0b72595f, 0xb28982b7, 0xa3f4e8ce, 0x1a0f3326, 0x0ae56ff4,\n    0xb31eb41c, 0xa263de65, 0x1b98058d, 0x80990a97, 0x3962d17f,\n    0x281fbb06, 0x91e460ee, 0xc56ca373, 0x7c97789b, 0x6dea12e2,\n    0xd411c90a, 0x4f10c610, 0xf6eb1df8, 0xe7967781, 0x5e6dac69,\n    0xc642ce25, 0x7fb915cd, 0x6ec47fb4, 0xd73fa45c, 0x4c3eab46,\n    0xf5c570ae, 0xe4b81ad7, 0x5d43c13f, 0x09cb02a2, 0xb030d94a,\n    0xa14db333, 0x18b668db, 0x83b767c1, 0x3a4cbc29, 0x2b31d650,\n    0x92ca0db8, 0x8220516a, 0x3bdb8a82, 0x2aa6e0fb, 0x935d3b13,\n    0x085c3409, 0xb1a7efe1, 0xa0da8598, 0x19215e70, 0x4da99ded,\n    0xf4524605, 0xe52f2c7c, 0x5cd4f794, 0xc7d5f88e, 0x7e2e2366,\n    0x6f53491f, 0xd6a892f7, 0x847c8bc6, 0x3d87502e, 0x2cfa3a57,\n    0x9501e1bf, 0x0e00eea5, 0xb7fb354d, 0xa6865f34, 0x1f7d84dc,\n    0x4bf54741, 0xf20e9ca9, 0xe373f6d0, 0x5a882d38, 0xc1892222,\n    0x7872f9ca, 0x690f93b3, 0xd0f4485b, 0xc01e1489, 0x79e5cf61,\n    0x6898a518, 0xd1637ef0, 0x4a6271ea, 0xf399aa02, 0xe2e4c07b,\n    0x5b1f1b93, 0x0f97d80e, 0xb66c03e6, 0xa711699f, 0x1eeab277,\n    0x85ebbd6d, 0x3c106685, 0x2d6d0cfc, 0x9496d714, 0x0cb9b558,\n    0xb5426eb0, 0xa43f04c9, 0x1dc4df21, 0x86c5d03b, 0x3f3e0bd3,\n    0x2e4361aa, 0x97b8ba42, 0xc33079df, 0x7acba237, 0x6bb6c84e,\n    0xd24d13a6, 0x494c1cbc, 0xf0b7c754, 0xe1caad2d, 0x583176c5,\n    0x48db2a17, 0xf120f1ff, 0xe05d9b86, 0x59a6406e, 0xc2a74f74,\n    0x7b5c949c, 0x6a21fee5, 0xd3da250d, 0x8752e690, 0x3ea93d78,\n    0x2fd45701, 0x962f8ce9, 0x0d2e83f3, 0xb4d5581b, 0xa5a83262,\n    0x1c53e98a},\n   {0x00000000, 0x9d0fe176, 0xe16ec4ad, 0x7c6125db, 0x19ac8f1b,\n    0x84a36e6d, 0xf8c24bb6, 0x65cdaac0, 0x33591e36, 0xae56ff40,\n    0xd237da9b, 0x4f383bed, 0x2af5912d, 0xb7fa705b, 0xcb9b5580,\n    0x5694b4f6, 0x66b23c6c, 0xfbbddd1a, 0x87dcf8c1, 0x1ad319b7,\n    0x7f1eb377, 0xe2115201, 0x9e7077da, 0x037f96ac, 0x55eb225a,\n    0xc8e4c32c, 0xb485e6f7, 0x298a0781, 0x4c47ad41, 0xd1484c37,\n    0xad2969ec, 0x3026889a, 0xcd6478d8, 0x506b99ae, 0x2c0abc75,\n    0xb1055d03, 0xd4c8f7c3, 0x49c716b5, 0x35a6336e, 0xa8a9d218,\n    0xfe3d66ee, 0x63328798, 0x1f53a243, 0x825c4335, 0xe791e9f5,\n    0x7a9e0883, 0x06ff2d58, 0x9bf0cc2e, 0xabd644b4, 0x36d9a5c2,\n    0x4ab88019, 0xd7b7616f, 0xb27acbaf, 0x2f752ad9, 0x53140f02,\n    0xce1bee74, 0x988f5a82, 0x0580bbf4, 0x79e19e2f, 0xe4ee7f59,\n    0x8123d599, 0x1c2c34ef, 0x604d1134, 0xfd42f042, 0x41b9f7f1,\n    0xdcb61687, 0xa0d7335c, 0x3dd8d22a, 0x581578ea, 0xc51a999c,\n    0xb97bbc47, 0x24745d31, 0x72e0e9c7, 0xefef08b1, 0x938e2d6a,\n    0x0e81cc1c, 0x6b4c66dc, 0xf64387aa, 0x8a22a271, 0x172d4307,\n    0x270bcb9d, 0xba042aeb, 0xc6650f30, 0x5b6aee46, 0x3ea74486,\n    0xa3a8a5f0, 0xdfc9802b, 0x42c6615d, 0x1452d5ab, 0x895d34dd,\n    0xf53c1106, 0x6833f070, 0x0dfe5ab0, 0x90f1bbc6, 0xec909e1d,\n    0x719f7f6b, 0x8cdd8f29, 0x11d26e5f, 0x6db34b84, 0xf0bcaaf2,\n    0x95710032, 0x087ee144, 0x741fc49f, 0xe91025e9, 0xbf84911f,\n    0x228b7069, 0x5eea55b2, 0xc3e5b4c4, 0xa6281e04, 0x3b27ff72,\n    0x4746daa9, 0xda493bdf, 0xea6fb345, 0x77605233, 0x0b0177e8,\n    0x960e969e, 0xf3c33c5e, 0x6eccdd28, 0x12adf8f3, 0x8fa21985,\n    0xd936ad73, 0x44394c05, 0x385869de, 0xa55788a8, 0xc09a2268,\n    0x5d95c31e, 0x21f4e6c5, 0xbcfb07b3, 0x8373efe2, 0x1e7c0e94,\n    0x621d2b4f, 0xff12ca39, 0x9adf60f9, 0x07d0818f, 0x7bb1a454,\n    0xe6be4522, 0xb02af1d4, 0x2d2510a2, 0x51443579, 0xcc4bd40f,\n    0xa9867ecf, 0x34899fb9, 0x48e8ba62, 0xd5e75b14, 0xe5c1d38e,\n    0x78ce32f8, 0x04af1723, 0x99a0f655, 0xfc6d5c95, 0x6162bde3,\n    0x1d039838, 0x800c794e, 0xd698cdb8, 0x4b972cce, 0x37f60915,\n    0xaaf9e863, 0xcf3442a3, 0x523ba3d5, 0x2e5a860e, 0xb3556778,\n    0x4e17973a, 0xd318764c, 0xaf795397, 0x3276b2e1, 0x57bb1821,\n    0xcab4f957, 0xb6d5dc8c, 0x2bda3dfa, 0x7d4e890c, 0xe041687a,\n    0x9c204da1, 0x012facd7, 0x64e20617, 0xf9ede761, 0x858cc2ba,\n    0x188323cc, 0x28a5ab56, 0xb5aa4a20, 0xc9cb6ffb, 0x54c48e8d,\n    0x3109244d, 0xac06c53b, 0xd067e0e0, 0x4d680196, 0x1bfcb560,\n    0x86f35416, 0xfa9271cd, 0x679d90bb, 0x02503a7b, 0x9f5fdb0d,\n    0xe33efed6, 0x7e311fa0, 0xc2ca1813, 0x5fc5f965, 0x23a4dcbe,\n    0xbeab3dc8, 0xdb669708, 0x4669767e, 0x3a0853a5, 0xa707b2d3,\n    0xf1930625, 0x6c9ce753, 0x10fdc288, 0x8df223fe, 0xe83f893e,\n    0x75306848, 0x09514d93, 0x945eace5, 0xa478247f, 0x3977c509,\n    0x4516e0d2, 0xd81901a4, 0xbdd4ab64, 0x20db4a12, 0x5cba6fc9,\n    0xc1b58ebf, 0x97213a49, 0x0a2edb3f, 0x764ffee4, 0xeb401f92,\n    0x8e8db552, 0x13825424, 0x6fe371ff, 0xf2ec9089, 0x0fae60cb,\n    0x92a181bd, 0xeec0a466, 0x73cf4510, 0x1602efd0, 0x8b0d0ea6,\n    0xf76c2b7d, 0x6a63ca0b, 0x3cf77efd, 0xa1f89f8b, 0xdd99ba50,\n    0x40965b26, 0x255bf1e6, 0xb8541090, 0xc435354b, 0x593ad43d,\n    0x691c5ca7, 0xf413bdd1, 0x8872980a, 0x157d797c, 0x70b0d3bc,\n    0xedbf32ca, 0x91de1711, 0x0cd1f667, 0x5a454291, 0xc74aa3e7,\n    0xbb2b863c, 0x2624674a, 0x43e9cd8a, 0xdee62cfc, 0xa2870927,\n    0x3f88e851},\n   {0x00000000, 0xdd96d985, 0x605cb54b, 0xbdca6cce, 0xc0b96a96,\n    0x1d2fb313, 0xa0e5dfdd, 0x7d730658, 0x5a03d36d, 0x87950ae8,\n    0x3a5f6626, 0xe7c9bfa3, 0x9abab9fb, 0x472c607e, 0xfae60cb0,\n    0x2770d535, 0xb407a6da, 0x69917f5f, 0xd45b1391, 0x09cdca14,\n    0x74becc4c, 0xa92815c9, 0x14e27907, 0xc974a082, 0xee0475b7,\n    0x3392ac32, 0x8e58c0fc, 0x53ce1979, 0x2ebd1f21, 0xf32bc6a4,\n    0x4ee1aa6a, 0x937773ef, 0xb37e4bf5, 0x6ee89270, 0xd322febe,\n    0x0eb4273b, 0x73c72163, 0xae51f8e6, 0x139b9428, 0xce0d4dad,\n    0xe97d9898, 0x34eb411d, 0x89212dd3, 0x54b7f456, 0x29c4f20e,\n    0xf4522b8b, 0x49984745, 0x940e9ec0, 0x0779ed2f, 0xdaef34aa,\n    0x67255864, 0xbab381e1, 0xc7c087b9, 0x1a565e3c, 0xa79c32f2,\n    0x7a0aeb77, 0x5d7a3e42, 0x80ece7c7, 0x3d268b09, 0xe0b0528c,\n    0x9dc354d4, 0x40558d51, 0xfd9fe19f, 0x2009381a, 0xbd8d91ab,\n    0x601b482e, 0xddd124e0, 0x0047fd65, 0x7d34fb3d, 0xa0a222b8,\n    0x1d684e76, 0xc0fe97f3, 0xe78e42c6, 0x3a189b43, 0x87d2f78d,\n    0x5a442e08, 0x27372850, 0xfaa1f1d5, 0x476b9d1b, 0x9afd449e,\n    0x098a3771, 0xd41ceef4, 0x69d6823a, 0xb4405bbf, 0xc9335de7,\n    0x14a58462, 0xa96fe8ac, 0x74f93129, 0x5389e41c, 0x8e1f3d99,\n    0x33d55157, 0xee4388d2, 0x93308e8a, 0x4ea6570f, 0xf36c3bc1,\n    0x2efae244, 0x0ef3da5e, 0xd36503db, 0x6eaf6f15, 0xb339b690,\n    0xce4ab0c8, 0x13dc694d, 0xae160583, 0x7380dc06, 0x54f00933,\n    0x8966d0b6, 0x34acbc78, 0xe93a65fd, 0x944963a5, 0x49dfba20,\n    0xf415d6ee, 0x29830f6b, 0xbaf47c84, 0x6762a501, 0xdaa8c9cf,\n    0x073e104a, 0x7a4d1612, 0xa7dbcf97, 0x1a11a359, 0xc7877adc,\n    0xe0f7afe9, 0x3d61766c, 0x80ab1aa2, 0x5d3dc327, 0x204ec57f,\n    0xfdd81cfa, 0x40127034, 0x9d84a9b1, 0xa06a2517, 0x7dfcfc92,\n    0xc036905c, 0x1da049d9, 0x60d34f81, 0xbd459604, 0x008ffaca,\n    0xdd19234f, 0xfa69f67a, 0x27ff2fff, 0x9a354331, 0x47a39ab4,\n    0x3ad09cec, 0xe7464569, 0x5a8c29a7, 0x871af022, 0x146d83cd,\n    0xc9fb5a48, 0x74313686, 0xa9a7ef03, 0xd4d4e95b, 0x094230de,\n    0xb4885c10, 0x691e8595, 0x4e6e50a0, 0x93f88925, 0x2e32e5eb,\n    0xf3a43c6e, 0x8ed73a36, 0x5341e3b3, 0xee8b8f7d, 0x331d56f8,\n    0x13146ee2, 0xce82b767, 0x7348dba9, 0xaede022c, 0xd3ad0474,\n    0x0e3bddf1, 0xb3f1b13f, 0x6e6768ba, 0x4917bd8f, 0x9481640a,\n    0x294b08c4, 0xf4ddd141, 0x89aed719, 0x54380e9c, 0xe9f26252,\n    0x3464bbd7, 0xa713c838, 0x7a8511bd, 0xc74f7d73, 0x1ad9a4f6,\n    0x67aaa2ae, 0xba3c7b2b, 0x07f617e5, 0xda60ce60, 0xfd101b55,\n    0x2086c2d0, 0x9d4cae1e, 0x40da779b, 0x3da971c3, 0xe03fa846,\n    0x5df5c488, 0x80631d0d, 0x1de7b4bc, 0xc0716d39, 0x7dbb01f7,\n    0xa02dd872, 0xdd5ede2a, 0x00c807af, 0xbd026b61, 0x6094b2e4,\n    0x47e467d1, 0x9a72be54, 0x27b8d29a, 0xfa2e0b1f, 0x875d0d47,\n    0x5acbd4c2, 0xe701b80c, 0x3a976189, 0xa9e01266, 0x7476cbe3,\n    0xc9bca72d, 0x142a7ea8, 0x695978f0, 0xb4cfa175, 0x0905cdbb,\n    0xd493143e, 0xf3e3c10b, 0x2e75188e, 0x93bf7440, 0x4e29adc5,\n    0x335aab9d, 0xeecc7218, 0x53061ed6, 0x8e90c753, 0xae99ff49,\n    0x730f26cc, 0xcec54a02, 0x13539387, 0x6e2095df, 0xb3b64c5a,\n    0x0e7c2094, 0xd3eaf911, 0xf49a2c24, 0x290cf5a1, 0x94c6996f,\n    0x495040ea, 0x342346b2, 0xe9b59f37, 0x547ff3f9, 0x89e92a7c,\n    0x1a9e5993, 0xc7088016, 0x7ac2ecd8, 0xa754355d, 0xda273305,\n    0x07b1ea80, 0xba7b864e, 0x67ed5fcb, 0x409d8afe, 0x9d0b537b,\n    0x20c13fb5, 0xfd57e630, 0x8024e068, 0x5db239ed, 0xe0785523,\n    0x3dee8ca6},\n   {0x00000000, 0x9ba54c6f, 0xec3b9e9f, 0x779ed2f0, 0x03063b7f,\n    0x98a37710, 0xef3da5e0, 0x7498e98f, 0x060c76fe, 0x9da93a91,\n    0xea37e861, 0x7192a40e, 0x050a4d81, 0x9eaf01ee, 0xe931d31e,\n    0x72949f71, 0x0c18edfc, 0x97bda193, 0xe0237363, 0x7b863f0c,\n    0x0f1ed683, 0x94bb9aec, 0xe325481c, 0x78800473, 0x0a149b02,\n    0x91b1d76d, 0xe62f059d, 0x7d8a49f2, 0x0912a07d, 0x92b7ec12,\n    0xe5293ee2, 0x7e8c728d, 0x1831dbf8, 0x83949797, 0xf40a4567,\n    0x6faf0908, 0x1b37e087, 0x8092ace8, 0xf70c7e18, 0x6ca93277,\n    0x1e3dad06, 0x8598e169, 0xf2063399, 0x69a37ff6, 0x1d3b9679,\n    0x869eda16, 0xf10008e6, 0x6aa54489, 0x14293604, 0x8f8c7a6b,\n    0xf812a89b, 0x63b7e4f4, 0x172f0d7b, 0x8c8a4114, 0xfb1493e4,\n    0x60b1df8b, 0x122540fa, 0x89800c95, 0xfe1ede65, 0x65bb920a,\n    0x11237b85, 0x8a8637ea, 0xfd18e51a, 0x66bda975, 0x3063b7f0,\n    0xabc6fb9f, 0xdc58296f, 0x47fd6500, 0x33658c8f, 0xa8c0c0e0,\n    0xdf5e1210, 0x44fb5e7f, 0x366fc10e, 0xadca8d61, 0xda545f91,\n    0x41f113fe, 0x3569fa71, 0xaeccb61e, 0xd95264ee, 0x42f72881,\n    0x3c7b5a0c, 0xa7de1663, 0xd040c493, 0x4be588fc, 0x3f7d6173,\n    0xa4d82d1c, 0xd346ffec, 0x48e3b383, 0x3a772cf2, 0xa1d2609d,\n    0xd64cb26d, 0x4de9fe02, 0x3971178d, 0xa2d45be2, 0xd54a8912,\n    0x4eefc57d, 0x28526c08, 0xb3f72067, 0xc469f297, 0x5fccbef8,\n    0x2b545777, 0xb0f11b18, 0xc76fc9e8, 0x5cca8587, 0x2e5e1af6,\n    0xb5fb5699, 0xc2658469, 0x59c0c806, 0x2d582189, 0xb6fd6de6,\n    0xc163bf16, 0x5ac6f379, 0x244a81f4, 0xbfefcd9b, 0xc8711f6b,\n    0x53d45304, 0x274cba8b, 0xbce9f6e4, 0xcb772414, 0x50d2687b,\n    0x2246f70a, 0xb9e3bb65, 0xce7d6995, 0x55d825fa, 0x2140cc75,\n    0xbae5801a, 0xcd7b52ea, 0x56de1e85, 0x60c76fe0, 0xfb62238f,\n    0x8cfcf17f, 0x1759bd10, 0x63c1549f, 0xf86418f0, 0x8ffaca00,\n    0x145f866f, 0x66cb191e, 0xfd6e5571, 0x8af08781, 0x1155cbee,\n    0x65cd2261, 0xfe686e0e, 0x89f6bcfe, 0x1253f091, 0x6cdf821c,\n    0xf77ace73, 0x80e41c83, 0x1b4150ec, 0x6fd9b963, 0xf47cf50c,\n    0x83e227fc, 0x18476b93, 0x6ad3f4e2, 0xf176b88d, 0x86e86a7d,\n    0x1d4d2612, 0x69d5cf9d, 0xf27083f2, 0x85ee5102, 0x1e4b1d6d,\n    0x78f6b418, 0xe353f877, 0x94cd2a87, 0x0f6866e8, 0x7bf08f67,\n    0xe055c308, 0x97cb11f8, 0x0c6e5d97, 0x7efac2e6, 0xe55f8e89,\n    0x92c15c79, 0x09641016, 0x7dfcf999, 0xe659b5f6, 0x91c76706,\n    0x0a622b69, 0x74ee59e4, 0xef4b158b, 0x98d5c77b, 0x03708b14,\n    0x77e8629b, 0xec4d2ef4, 0x9bd3fc04, 0x0076b06b, 0x72e22f1a,\n    0xe9476375, 0x9ed9b185, 0x057cfdea, 0x71e41465, 0xea41580a,\n    0x9ddf8afa, 0x067ac695, 0x50a4d810, 0xcb01947f, 0xbc9f468f,\n    0x273a0ae0, 0x53a2e36f, 0xc807af00, 0xbf997df0, 0x243c319f,\n    0x56a8aeee, 0xcd0de281, 0xba933071, 0x21367c1e, 0x55ae9591,\n    0xce0bd9fe, 0xb9950b0e, 0x22304761, 0x5cbc35ec, 0xc7197983,\n    0xb087ab73, 0x2b22e71c, 0x5fba0e93, 0xc41f42fc, 0xb381900c,\n    0x2824dc63, 0x5ab04312, 0xc1150f7d, 0xb68bdd8d, 0x2d2e91e2,\n    0x59b6786d, 0xc2133402, 0xb58de6f2, 0x2e28aa9d, 0x489503e8,\n    0xd3304f87, 0xa4ae9d77, 0x3f0bd118, 0x4b933897, 0xd03674f8,\n    0xa7a8a608, 0x3c0dea67, 0x4e997516, 0xd53c3979, 0xa2a2eb89,\n    0x3907a7e6, 0x4d9f4e69, 0xd63a0206, 0xa1a4d0f6, 0x3a019c99,\n    0x448dee14, 0xdf28a27b, 0xa8b6708b, 0x33133ce4, 0x478bd56b,\n    0xdc2e9904, 0xabb04bf4, 0x3015079b, 0x428198ea, 0xd924d485,\n    0xaeba0675, 0x351f4a1a, 0x4187a395, 0xda22effa, 0xadbc3d0a,\n    0x36197165},\n   {0x00000000, 0xc18edfc0, 0x586cb9c1, 0x99e26601, 0xb0d97382,\n    0x7157ac42, 0xe8b5ca43, 0x293b1583, 0xbac3e145, 0x7b4d3e85,\n    0xe2af5884, 0x23218744, 0x0a1a92c7, 0xcb944d07, 0x52762b06,\n    0x93f8f4c6, 0xaef6c4cb, 0x6f781b0b, 0xf69a7d0a, 0x3714a2ca,\n    0x1e2fb749, 0xdfa16889, 0x46430e88, 0x87cdd148, 0x1435258e,\n    0xd5bbfa4e, 0x4c599c4f, 0x8dd7438f, 0xa4ec560c, 0x656289cc,\n    0xfc80efcd, 0x3d0e300d, 0x869c8fd7, 0x47125017, 0xdef03616,\n    0x1f7ee9d6, 0x3645fc55, 0xf7cb2395, 0x6e294594, 0xafa79a54,\n    0x3c5f6e92, 0xfdd1b152, 0x6433d753, 0xa5bd0893, 0x8c861d10,\n    0x4d08c2d0, 0xd4eaa4d1, 0x15647b11, 0x286a4b1c, 0xe9e494dc,\n    0x7006f2dd, 0xb1882d1d, 0x98b3389e, 0x593de75e, 0xc0df815f,\n    0x01515e9f, 0x92a9aa59, 0x53277599, 0xcac51398, 0x0b4bcc58,\n    0x2270d9db, 0xe3fe061b, 0x7a1c601a, 0xbb92bfda, 0xd64819ef,\n    0x17c6c62f, 0x8e24a02e, 0x4faa7fee, 0x66916a6d, 0xa71fb5ad,\n    0x3efdd3ac, 0xff730c6c, 0x6c8bf8aa, 0xad05276a, 0x34e7416b,\n    0xf5699eab, 0xdc528b28, 0x1ddc54e8, 0x843e32e9, 0x45b0ed29,\n    0x78bedd24, 0xb93002e4, 0x20d264e5, 0xe15cbb25, 0xc867aea6,\n    0x09e97166, 0x900b1767, 0x5185c8a7, 0xc27d3c61, 0x03f3e3a1,\n    0x9a1185a0, 0x5b9f5a60, 0x72a44fe3, 0xb32a9023, 0x2ac8f622,\n    0xeb4629e2, 0x50d49638, 0x915a49f8, 0x08b82ff9, 0xc936f039,\n    0xe00de5ba, 0x21833a7a, 0xb8615c7b, 0x79ef83bb, 0xea17777d,\n    0x2b99a8bd, 0xb27bcebc, 0x73f5117c, 0x5ace04ff, 0x9b40db3f,\n    0x02a2bd3e, 0xc32c62fe, 0xfe2252f3, 0x3fac8d33, 0xa64eeb32,\n    0x67c034f2, 0x4efb2171, 0x8f75feb1, 0x169798b0, 0xd7194770,\n    0x44e1b3b6, 0x856f6c76, 0x1c8d0a77, 0xdd03d5b7, 0xf438c034,\n    0x35b61ff4, 0xac5479f5, 0x6ddaa635, 0x77e1359f, 0xb66fea5f,\n    0x2f8d8c5e, 0xee03539e, 0xc738461d, 0x06b699dd, 0x9f54ffdc,\n    0x5eda201c, 0xcd22d4da, 0x0cac0b1a, 0x954e6d1b, 0x54c0b2db,\n    0x7dfba758, 0xbc757898, 0x25971e99, 0xe419c159, 0xd917f154,\n    0x18992e94, 0x817b4895, 0x40f59755, 0x69ce82d6, 0xa8405d16,\n    0x31a23b17, 0xf02ce4d7, 0x63d41011, 0xa25acfd1, 0x3bb8a9d0,\n    0xfa367610, 0xd30d6393, 0x1283bc53, 0x8b61da52, 0x4aef0592,\n    0xf17dba48, 0x30f36588, 0xa9110389, 0x689fdc49, 0x41a4c9ca,\n    0x802a160a, 0x19c8700b, 0xd846afcb, 0x4bbe5b0d, 0x8a3084cd,\n    0x13d2e2cc, 0xd25c3d0c, 0xfb67288f, 0x3ae9f74f, 0xa30b914e,\n    0x62854e8e, 0x5f8b7e83, 0x9e05a143, 0x07e7c742, 0xc6691882,\n    0xef520d01, 0x2edcd2c1, 0xb73eb4c0, 0x76b06b00, 0xe5489fc6,\n    0x24c64006, 0xbd242607, 0x7caaf9c7, 0x5591ec44, 0x941f3384,\n    0x0dfd5585, 0xcc738a45, 0xa1a92c70, 0x6027f3b0, 0xf9c595b1,\n    0x384b4a71, 0x11705ff2, 0xd0fe8032, 0x491ce633, 0x889239f3,\n    0x1b6acd35, 0xdae412f5, 0x430674f4, 0x8288ab34, 0xabb3beb7,\n    0x6a3d6177, 0xf3df0776, 0x3251d8b6, 0x0f5fe8bb, 0xced1377b,\n    0x5733517a, 0x96bd8eba, 0xbf869b39, 0x7e0844f9, 0xe7ea22f8,\n    0x2664fd38, 0xb59c09fe, 0x7412d63e, 0xedf0b03f, 0x2c7e6fff,\n    0x05457a7c, 0xc4cba5bc, 0x5d29c3bd, 0x9ca71c7d, 0x2735a3a7,\n    0xe6bb7c67, 0x7f591a66, 0xbed7c5a6, 0x97ecd025, 0x56620fe5,\n    0xcf8069e4, 0x0e0eb624, 0x9df642e2, 0x5c789d22, 0xc59afb23,\n    0x041424e3, 0x2d2f3160, 0xeca1eea0, 0x754388a1, 0xb4cd5761,\n    0x89c3676c, 0x484db8ac, 0xd1afdead, 0x1021016d, 0x391a14ee,\n    0xf894cb2e, 0x6176ad2f, 0xa0f872ef, 0x33008629, 0xf28e59e9,\n    0x6b6c3fe8, 0xaae2e028, 0x83d9f5ab, 0x42572a6b, 0xdbb54c6a,\n    0x1a3b93aa},\n   {0x00000000, 0xefc26b3e, 0x04f5d03d, 0xeb37bb03, 0x09eba07a,\n    0xe629cb44, 0x0d1e7047, 0xe2dc1b79, 0x13d740f4, 0xfc152bca,\n    0x172290c9, 0xf8e0fbf7, 0x1a3ce08e, 0xf5fe8bb0, 0x1ec930b3,\n    0xf10b5b8d, 0x27ae81e8, 0xc86cead6, 0x235b51d5, 0xcc993aeb,\n    0x2e452192, 0xc1874aac, 0x2ab0f1af, 0xc5729a91, 0x3479c11c,\n    0xdbbbaa22, 0x308c1121, 0xdf4e7a1f, 0x3d926166, 0xd2500a58,\n    0x3967b15b, 0xd6a5da65, 0x4f5d03d0, 0xa09f68ee, 0x4ba8d3ed,\n    0xa46ab8d3, 0x46b6a3aa, 0xa974c894, 0x42437397, 0xad8118a9,\n    0x5c8a4324, 0xb348281a, 0x587f9319, 0xb7bdf827, 0x5561e35e,\n    0xbaa38860, 0x51943363, 0xbe56585d, 0x68f38238, 0x8731e906,\n    0x6c065205, 0x83c4393b, 0x61182242, 0x8eda497c, 0x65edf27f,\n    0x8a2f9941, 0x7b24c2cc, 0x94e6a9f2, 0x7fd112f1, 0x901379cf,\n    0x72cf62b6, 0x9d0d0988, 0x763ab28b, 0x99f8d9b5, 0x9eba07a0,\n    0x71786c9e, 0x9a4fd79d, 0x758dbca3, 0x9751a7da, 0x7893cce4,\n    0x93a477e7, 0x7c661cd9, 0x8d6d4754, 0x62af2c6a, 0x89989769,\n    0x665afc57, 0x8486e72e, 0x6b448c10, 0x80733713, 0x6fb15c2d,\n    0xb9148648, 0x56d6ed76, 0xbde15675, 0x52233d4b, 0xb0ff2632,\n    0x5f3d4d0c, 0xb40af60f, 0x5bc89d31, 0xaac3c6bc, 0x4501ad82,\n    0xae361681, 0x41f47dbf, 0xa32866c6, 0x4cea0df8, 0xa7ddb6fb,\n    0x481fddc5, 0xd1e70470, 0x3e256f4e, 0xd512d44d, 0x3ad0bf73,\n    0xd80ca40a, 0x37cecf34, 0xdcf97437, 0x333b1f09, 0xc2304484,\n    0x2df22fba, 0xc6c594b9, 0x2907ff87, 0xcbdbe4fe, 0x24198fc0,\n    0xcf2e34c3, 0x20ec5ffd, 0xf6498598, 0x198beea6, 0xf2bc55a5,\n    0x1d7e3e9b, 0xffa225e2, 0x10604edc, 0xfb57f5df, 0x14959ee1,\n    0xe59ec56c, 0x0a5cae52, 0xe16b1551, 0x0ea97e6f, 0xec756516,\n    0x03b70e28, 0xe880b52b, 0x0742de15, 0xe6050901, 0x09c7623f,\n    0xe2f0d93c, 0x0d32b202, 0xefeea97b, 0x002cc245, 0xeb1b7946,\n    0x04d91278, 0xf5d249f5, 0x1a1022cb, 0xf12799c8, 0x1ee5f2f6,\n    0xfc39e98f, 0x13fb82b1, 0xf8cc39b2, 0x170e528c, 0xc1ab88e9,\n    0x2e69e3d7, 0xc55e58d4, 0x2a9c33ea, 0xc8402893, 0x278243ad,\n    0xccb5f8ae, 0x23779390, 0xd27cc81d, 0x3dbea323, 0xd6891820,\n    0x394b731e, 0xdb976867, 0x34550359, 0xdf62b85a, 0x30a0d364,\n    0xa9580ad1, 0x469a61ef, 0xadaddaec, 0x426fb1d2, 0xa0b3aaab,\n    0x4f71c195, 0xa4467a96, 0x4b8411a8, 0xba8f4a25, 0x554d211b,\n    0xbe7a9a18, 0x51b8f126, 0xb364ea5f, 0x5ca68161, 0xb7913a62,\n    0x5853515c, 0x8ef68b39, 0x6134e007, 0x8a035b04, 0x65c1303a,\n    0x871d2b43, 0x68df407d, 0x83e8fb7e, 0x6c2a9040, 0x9d21cbcd,\n    0x72e3a0f3, 0x99d41bf0, 0x761670ce, 0x94ca6bb7, 0x7b080089,\n    0x903fbb8a, 0x7ffdd0b4, 0x78bf0ea1, 0x977d659f, 0x7c4ade9c,\n    0x9388b5a2, 0x7154aedb, 0x9e96c5e5, 0x75a17ee6, 0x9a6315d8,\n    0x6b684e55, 0x84aa256b, 0x6f9d9e68, 0x805ff556, 0x6283ee2f,\n    0x8d418511, 0x66763e12, 0x89b4552c, 0x5f118f49, 0xb0d3e477,\n    0x5be45f74, 0xb426344a, 0x56fa2f33, 0xb938440d, 0x520fff0e,\n    0xbdcd9430, 0x4cc6cfbd, 0xa304a483, 0x48331f80, 0xa7f174be,\n    0x452d6fc7, 0xaaef04f9, 0x41d8bffa, 0xae1ad4c4, 0x37e20d71,\n    0xd820664f, 0x3317dd4c, 0xdcd5b672, 0x3e09ad0b, 0xd1cbc635,\n    0x3afc7d36, 0xd53e1608, 0x24354d85, 0xcbf726bb, 0x20c09db8,\n    0xcf02f686, 0x2ddeedff, 0xc21c86c1, 0x292b3dc2, 0xc6e956fc,\n    0x104c8c99, 0xff8ee7a7, 0x14b95ca4, 0xfb7b379a, 0x19a72ce3,\n    0xf66547dd, 0x1d52fcde, 0xf29097e0, 0x039bcc6d, 0xec59a753,\n    0x076e1c50, 0xe8ac776e, 0x0a706c17, 0xe5b20729, 0x0e85bc2a,\n    0xe147d714},\n   {0x00000000, 0x177b1443, 0x2ef62886, 0x398d3cc5, 0x5dec510c,\n    0x4a97454f, 0x731a798a, 0x64616dc9, 0xbbd8a218, 0xaca3b65b,\n    0x952e8a9e, 0x82559edd, 0xe634f314, 0xf14fe757, 0xc8c2db92,\n    0xdfb9cfd1, 0xacc04271, 0xbbbb5632, 0x82366af7, 0x954d7eb4,\n    0xf12c137d, 0xe657073e, 0xdfda3bfb, 0xc8a12fb8, 0x1718e069,\n    0x0063f42a, 0x39eec8ef, 0x2e95dcac, 0x4af4b165, 0x5d8fa526,\n    0x640299e3, 0x73798da0, 0x82f182a3, 0x958a96e0, 0xac07aa25,\n    0xbb7cbe66, 0xdf1dd3af, 0xc866c7ec, 0xf1ebfb29, 0xe690ef6a,\n    0x392920bb, 0x2e5234f8, 0x17df083d, 0x00a41c7e, 0x64c571b7,\n    0x73be65f4, 0x4a335931, 0x5d484d72, 0x2e31c0d2, 0x394ad491,\n    0x00c7e854, 0x17bcfc17, 0x73dd91de, 0x64a6859d, 0x5d2bb958,\n    0x4a50ad1b, 0x95e962ca, 0x82927689, 0xbb1f4a4c, 0xac645e0f,\n    0xc80533c6, 0xdf7e2785, 0xe6f31b40, 0xf1880f03, 0xde920307,\n    0xc9e91744, 0xf0642b81, 0xe71f3fc2, 0x837e520b, 0x94054648,\n    0xad887a8d, 0xbaf36ece, 0x654aa11f, 0x7231b55c, 0x4bbc8999,\n    0x5cc79dda, 0x38a6f013, 0x2fdde450, 0x1650d895, 0x012bccd6,\n    0x72524176, 0x65295535, 0x5ca469f0, 0x4bdf7db3, 0x2fbe107a,\n    0x38c50439, 0x014838fc, 0x16332cbf, 0xc98ae36e, 0xdef1f72d,\n    0xe77ccbe8, 0xf007dfab, 0x9466b262, 0x831da621, 0xba909ae4,\n    0xadeb8ea7, 0x5c6381a4, 0x4b1895e7, 0x7295a922, 0x65eebd61,\n    0x018fd0a8, 0x16f4c4eb, 0x2f79f82e, 0x3802ec6d, 0xe7bb23bc,\n    0xf0c037ff, 0xc94d0b3a, 0xde361f79, 0xba5772b0, 0xad2c66f3,\n    0x94a15a36, 0x83da4e75, 0xf0a3c3d5, 0xe7d8d796, 0xde55eb53,\n    0xc92eff10, 0xad4f92d9, 0xba34869a, 0x83b9ba5f, 0x94c2ae1c,\n    0x4b7b61cd, 0x5c00758e, 0x658d494b, 0x72f65d08, 0x169730c1,\n    0x01ec2482, 0x38611847, 0x2f1a0c04, 0x6655004f, 0x712e140c,\n    0x48a328c9, 0x5fd83c8a, 0x3bb95143, 0x2cc24500, 0x154f79c5,\n    0x02346d86, 0xdd8da257, 0xcaf6b614, 0xf37b8ad1, 0xe4009e92,\n    0x8061f35b, 0x971ae718, 0xae97dbdd, 0xb9eccf9e, 0xca95423e,\n    0xddee567d, 0xe4636ab8, 0xf3187efb, 0x97791332, 0x80020771,\n    0xb98f3bb4, 0xaef42ff7, 0x714de026, 0x6636f465, 0x5fbbc8a0,\n    0x48c0dce3, 0x2ca1b12a, 0x3bdaa569, 0x025799ac, 0x152c8def,\n    0xe4a482ec, 0xf3df96af, 0xca52aa6a, 0xdd29be29, 0xb948d3e0,\n    0xae33c7a3, 0x97befb66, 0x80c5ef25, 0x5f7c20f4, 0x480734b7,\n    0x718a0872, 0x66f11c31, 0x029071f8, 0x15eb65bb, 0x2c66597e,\n    0x3b1d4d3d, 0x4864c09d, 0x5f1fd4de, 0x6692e81b, 0x71e9fc58,\n    0x15889191, 0x02f385d2, 0x3b7eb917, 0x2c05ad54, 0xf3bc6285,\n    0xe4c776c6, 0xdd4a4a03, 0xca315e40, 0xae503389, 0xb92b27ca,\n    0x80a61b0f, 0x97dd0f4c, 0xb8c70348, 0xafbc170b, 0x96312bce,\n    0x814a3f8d, 0xe52b5244, 0xf2504607, 0xcbdd7ac2, 0xdca66e81,\n    0x031fa150, 0x1464b513, 0x2de989d6, 0x3a929d95, 0x5ef3f05c,\n    0x4988e41f, 0x7005d8da, 0x677ecc99, 0x14074139, 0x037c557a,\n    0x3af169bf, 0x2d8a7dfc, 0x49eb1035, 0x5e900476, 0x671d38b3,\n    0x70662cf0, 0xafdfe321, 0xb8a4f762, 0x8129cba7, 0x9652dfe4,\n    0xf233b22d, 0xe548a66e, 0xdcc59aab, 0xcbbe8ee8, 0x3a3681eb,\n    0x2d4d95a8, 0x14c0a96d, 0x03bbbd2e, 0x67dad0e7, 0x70a1c4a4,\n    0x492cf861, 0x5e57ec22, 0x81ee23f3, 0x969537b0, 0xaf180b75,\n    0xb8631f36, 0xdc0272ff, 0xcb7966bc, 0xf2f45a79, 0xe58f4e3a,\n    0x96f6c39a, 0x818dd7d9, 0xb800eb1c, 0xaf7bff5f, 0xcb1a9296,\n    0xdc6186d5, 0xe5ecba10, 0xf297ae53, 0x2d2e6182, 0x3a5575c1,\n    0x03d84904, 0x14a35d47, 0x70c2308e, 0x67b924cd, 0x5e341808,\n    0x494f0c4b}};\n\nlocal const z_word_t FAR crc_braid_big_table[][256] = {\n   {0x0000000000000000, 0x43147b1700000000, 0x8628f62e00000000,\n    0xc53c8d3900000000, 0x0c51ec5d00000000, 0x4f45974a00000000,\n    0x8a791a7300000000, 0xc96d616400000000, 0x18a2d8bb00000000,\n    0x5bb6a3ac00000000, 0x9e8a2e9500000000, 0xdd9e558200000000,\n    0x14f334e600000000, 0x57e74ff100000000, 0x92dbc2c800000000,\n    0xd1cfb9df00000000, 0x7142c0ac00000000, 0x3256bbbb00000000,\n    0xf76a368200000000, 0xb47e4d9500000000, 0x7d132cf100000000,\n    0x3e0757e600000000, 0xfb3bdadf00000000, 0xb82fa1c800000000,\n    0x69e0181700000000, 0x2af4630000000000, 0xefc8ee3900000000,\n    0xacdc952e00000000, 0x65b1f44a00000000, 0x26a58f5d00000000,\n    0xe399026400000000, 0xa08d797300000000, 0xa382f18200000000,\n    0xe0968a9500000000, 0x25aa07ac00000000, 0x66be7cbb00000000,\n    0xafd31ddf00000000, 0xecc766c800000000, 0x29fbebf100000000,\n    0x6aef90e600000000, 0xbb20293900000000, 0xf834522e00000000,\n    0x3d08df1700000000, 0x7e1ca40000000000, 0xb771c56400000000,\n    0xf465be7300000000, 0x3159334a00000000, 0x724d485d00000000,\n    0xd2c0312e00000000, 0x91d44a3900000000, 0x54e8c70000000000,\n    0x17fcbc1700000000, 0xde91dd7300000000, 0x9d85a66400000000,\n    0x58b92b5d00000000, 0x1bad504a00000000, 0xca62e99500000000,\n    0x8976928200000000, 0x4c4a1fbb00000000, 0x0f5e64ac00000000,\n    0xc63305c800000000, 0x85277edf00000000, 0x401bf3e600000000,\n    0x030f88f100000000, 0x070392de00000000, 0x4417e9c900000000,\n    0x812b64f000000000, 0xc23f1fe700000000, 0x0b527e8300000000,\n    0x4846059400000000, 0x8d7a88ad00000000, 0xce6ef3ba00000000,\n    0x1fa14a6500000000, 0x5cb5317200000000, 0x9989bc4b00000000,\n    0xda9dc75c00000000, 0x13f0a63800000000, 0x50e4dd2f00000000,\n    0x95d8501600000000, 0xd6cc2b0100000000, 0x7641527200000000,\n    0x3555296500000000, 0xf069a45c00000000, 0xb37ddf4b00000000,\n    0x7a10be2f00000000, 0x3904c53800000000, 0xfc38480100000000,\n    0xbf2c331600000000, 0x6ee38ac900000000, 0x2df7f1de00000000,\n    0xe8cb7ce700000000, 0xabdf07f000000000, 0x62b2669400000000,\n    0x21a61d8300000000, 0xe49a90ba00000000, 0xa78eebad00000000,\n    0xa481635c00000000, 0xe795184b00000000, 0x22a9957200000000,\n    0x61bdee6500000000, 0xa8d08f0100000000, 0xebc4f41600000000,\n    0x2ef8792f00000000, 0x6dec023800000000, 0xbc23bbe700000000,\n    0xff37c0f000000000, 0x3a0b4dc900000000, 0x791f36de00000000,\n    0xb07257ba00000000, 0xf3662cad00000000, 0x365aa19400000000,\n    0x754eda8300000000, 0xd5c3a3f000000000, 0x96d7d8e700000000,\n    0x53eb55de00000000, 0x10ff2ec900000000, 0xd9924fad00000000,\n    0x9a8634ba00000000, 0x5fbab98300000000, 0x1caec29400000000,\n    0xcd617b4b00000000, 0x8e75005c00000000, 0x4b498d6500000000,\n    0x085df67200000000, 0xc130971600000000, 0x8224ec0100000000,\n    0x4718613800000000, 0x040c1a2f00000000, 0x4f00556600000000,\n    0x0c142e7100000000, 0xc928a34800000000, 0x8a3cd85f00000000,\n    0x4351b93b00000000, 0x0045c22c00000000, 0xc5794f1500000000,\n    0x866d340200000000, 0x57a28ddd00000000, 0x14b6f6ca00000000,\n    0xd18a7bf300000000, 0x929e00e400000000, 0x5bf3618000000000,\n    0x18e71a9700000000, 0xdddb97ae00000000, 0x9ecfecb900000000,\n    0x3e4295ca00000000, 0x7d56eedd00000000, 0xb86a63e400000000,\n    0xfb7e18f300000000, 0x3213799700000000, 0x7107028000000000,\n    0xb43b8fb900000000, 0xf72ff4ae00000000, 0x26e04d7100000000,\n    0x65f4366600000000, 0xa0c8bb5f00000000, 0xe3dcc04800000000,\n    0x2ab1a12c00000000, 0x69a5da3b00000000, 0xac99570200000000,\n    0xef8d2c1500000000, 0xec82a4e400000000, 0xaf96dff300000000,\n    0x6aaa52ca00000000, 0x29be29dd00000000, 0xe0d348b900000000,\n    0xa3c733ae00000000, 0x66fbbe9700000000, 0x25efc58000000000,\n    0xf4207c5f00000000, 0xb734074800000000, 0x72088a7100000000,\n    0x311cf16600000000, 0xf871900200000000, 0xbb65eb1500000000,\n    0x7e59662c00000000, 0x3d4d1d3b00000000, 0x9dc0644800000000,\n    0xded41f5f00000000, 0x1be8926600000000, 0x58fce97100000000,\n    0x9191881500000000, 0xd285f30200000000, 0x17b97e3b00000000,\n    0x54ad052c00000000, 0x8562bcf300000000, 0xc676c7e400000000,\n    0x034a4add00000000, 0x405e31ca00000000, 0x893350ae00000000,\n    0xca272bb900000000, 0x0f1ba68000000000, 0x4c0fdd9700000000,\n    0x4803c7b800000000, 0x0b17bcaf00000000, 0xce2b319600000000,\n    0x8d3f4a8100000000, 0x44522be500000000, 0x074650f200000000,\n    0xc27addcb00000000, 0x816ea6dc00000000, 0x50a11f0300000000,\n    0x13b5641400000000, 0xd689e92d00000000, 0x959d923a00000000,\n    0x5cf0f35e00000000, 0x1fe4884900000000, 0xdad8057000000000,\n    0x99cc7e6700000000, 0x3941071400000000, 0x7a557c0300000000,\n    0xbf69f13a00000000, 0xfc7d8a2d00000000, 0x3510eb4900000000,\n    0x7604905e00000000, 0xb3381d6700000000, 0xf02c667000000000,\n    0x21e3dfaf00000000, 0x62f7a4b800000000, 0xa7cb298100000000,\n    0xe4df529600000000, 0x2db233f200000000, 0x6ea648e500000000,\n    0xab9ac5dc00000000, 0xe88ebecb00000000, 0xeb81363a00000000,\n    0xa8954d2d00000000, 0x6da9c01400000000, 0x2ebdbb0300000000,\n    0xe7d0da6700000000, 0xa4c4a17000000000, 0x61f82c4900000000,\n    0x22ec575e00000000, 0xf323ee8100000000, 0xb037959600000000,\n    0x750b18af00000000, 0x361f63b800000000, 0xff7202dc00000000,\n    0xbc6679cb00000000, 0x795af4f200000000, 0x3a4e8fe500000000,\n    0x9ac3f69600000000, 0xd9d78d8100000000, 0x1ceb00b800000000,\n    0x5fff7baf00000000, 0x96921acb00000000, 0xd58661dc00000000,\n    0x10baece500000000, 0x53ae97f200000000, 0x82612e2d00000000,\n    0xc175553a00000000, 0x0449d80300000000, 0x475da31400000000,\n    0x8e30c27000000000, 0xcd24b96700000000, 0x0818345e00000000,\n    0x4b0c4f4900000000},\n   {0x0000000000000000, 0x3e6bc2ef00000000, 0x3dd0f50400000000,\n    0x03bb37eb00000000, 0x7aa0eb0900000000, 0x44cb29e600000000,\n    0x47701e0d00000000, 0x791bdce200000000, 0xf440d71300000000,\n    0xca2b15fc00000000, 0xc990221700000000, 0xf7fbe0f800000000,\n    0x8ee03c1a00000000, 0xb08bfef500000000, 0xb330c91e00000000,\n    0x8d5b0bf100000000, 0xe881ae2700000000, 0xd6ea6cc800000000,\n    0xd5515b2300000000, 0xeb3a99cc00000000, 0x9221452e00000000,\n    0xac4a87c100000000, 0xaff1b02a00000000, 0x919a72c500000000,\n    0x1cc1793400000000, 0x22aabbdb00000000, 0x21118c3000000000,\n    0x1f7a4edf00000000, 0x6661923d00000000, 0x580a50d200000000,\n    0x5bb1673900000000, 0x65daa5d600000000, 0xd0035d4f00000000,\n    0xee689fa000000000, 0xedd3a84b00000000, 0xd3b86aa400000000,\n    0xaaa3b64600000000, 0x94c874a900000000, 0x9773434200000000,\n    0xa91881ad00000000, 0x24438a5c00000000, 0x1a2848b300000000,\n    0x19937f5800000000, 0x27f8bdb700000000, 0x5ee3615500000000,\n    0x6088a3ba00000000, 0x6333945100000000, 0x5d5856be00000000,\n    0x3882f36800000000, 0x06e9318700000000, 0x0552066c00000000,\n    0x3b39c48300000000, 0x4222186100000000, 0x7c49da8e00000000,\n    0x7ff2ed6500000000, 0x41992f8a00000000, 0xccc2247b00000000,\n    0xf2a9e69400000000, 0xf112d17f00000000, 0xcf79139000000000,\n    0xb662cf7200000000, 0x88090d9d00000000, 0x8bb23a7600000000,\n    0xb5d9f89900000000, 0xa007ba9e00000000, 0x9e6c787100000000,\n    0x9dd74f9a00000000, 0xa3bc8d7500000000, 0xdaa7519700000000,\n    0xe4cc937800000000, 0xe777a49300000000, 0xd91c667c00000000,\n    0x54476d8d00000000, 0x6a2caf6200000000, 0x6997988900000000,\n    0x57fc5a6600000000, 0x2ee7868400000000, 0x108c446b00000000,\n    0x1337738000000000, 0x2d5cb16f00000000, 0x488614b900000000,\n    0x76edd65600000000, 0x7556e1bd00000000, 0x4b3d235200000000,\n    0x3226ffb000000000, 0x0c4d3d5f00000000, 0x0ff60ab400000000,\n    0x319dc85b00000000, 0xbcc6c3aa00000000, 0x82ad014500000000,\n    0x811636ae00000000, 0xbf7df44100000000, 0xc66628a300000000,\n    0xf80dea4c00000000, 0xfbb6dda700000000, 0xc5dd1f4800000000,\n    0x7004e7d100000000, 0x4e6f253e00000000, 0x4dd412d500000000,\n    0x73bfd03a00000000, 0x0aa40cd800000000, 0x34cfce3700000000,\n    0x3774f9dc00000000, 0x091f3b3300000000, 0x844430c200000000,\n    0xba2ff22d00000000, 0xb994c5c600000000, 0x87ff072900000000,\n    0xfee4dbcb00000000, 0xc08f192400000000, 0xc3342ecf00000000,\n    0xfd5fec2000000000, 0x988549f600000000, 0xa6ee8b1900000000,\n    0xa555bcf200000000, 0x9b3e7e1d00000000, 0xe225a2ff00000000,\n    0xdc4e601000000000, 0xdff557fb00000000, 0xe19e951400000000,\n    0x6cc59ee500000000, 0x52ae5c0a00000000, 0x51156be100000000,\n    0x6f7ea90e00000000, 0x166575ec00000000, 0x280eb70300000000,\n    0x2bb580e800000000, 0x15de420700000000, 0x010905e600000000,\n    0x3f62c70900000000, 0x3cd9f0e200000000, 0x02b2320d00000000,\n    0x7ba9eeef00000000, 0x45c22c0000000000, 0x46791beb00000000,\n    0x7812d90400000000, 0xf549d2f500000000, 0xcb22101a00000000,\n    0xc89927f100000000, 0xf6f2e51e00000000, 0x8fe939fc00000000,\n    0xb182fb1300000000, 0xb239ccf800000000, 0x8c520e1700000000,\n    0xe988abc100000000, 0xd7e3692e00000000, 0xd4585ec500000000,\n    0xea339c2a00000000, 0x932840c800000000, 0xad43822700000000,\n    0xaef8b5cc00000000, 0x9093772300000000, 0x1dc87cd200000000,\n    0x23a3be3d00000000, 0x201889d600000000, 0x1e734b3900000000,\n    0x676897db00000000, 0x5903553400000000, 0x5ab862df00000000,\n    0x64d3a03000000000, 0xd10a58a900000000, 0xef619a4600000000,\n    0xecdaadad00000000, 0xd2b16f4200000000, 0xabaab3a000000000,\n    0x95c1714f00000000, 0x967a46a400000000, 0xa811844b00000000,\n    0x254a8fba00000000, 0x1b214d5500000000, 0x189a7abe00000000,\n    0x26f1b85100000000, 0x5fea64b300000000, 0x6181a65c00000000,\n    0x623a91b700000000, 0x5c51535800000000, 0x398bf68e00000000,\n    0x07e0346100000000, 0x045b038a00000000, 0x3a30c16500000000,\n    0x432b1d8700000000, 0x7d40df6800000000, 0x7efbe88300000000,\n    0x40902a6c00000000, 0xcdcb219d00000000, 0xf3a0e37200000000,\n    0xf01bd49900000000, 0xce70167600000000, 0xb76bca9400000000,\n    0x8900087b00000000, 0x8abb3f9000000000, 0xb4d0fd7f00000000,\n    0xa10ebf7800000000, 0x9f657d9700000000, 0x9cde4a7c00000000,\n    0xa2b5889300000000, 0xdbae547100000000, 0xe5c5969e00000000,\n    0xe67ea17500000000, 0xd815639a00000000, 0x554e686b00000000,\n    0x6b25aa8400000000, 0x689e9d6f00000000, 0x56f55f8000000000,\n    0x2fee836200000000, 0x1185418d00000000, 0x123e766600000000,\n    0x2c55b48900000000, 0x498f115f00000000, 0x77e4d3b000000000,\n    0x745fe45b00000000, 0x4a3426b400000000, 0x332ffa5600000000,\n    0x0d4438b900000000, 0x0eff0f5200000000, 0x3094cdbd00000000,\n    0xbdcfc64c00000000, 0x83a404a300000000, 0x801f334800000000,\n    0xbe74f1a700000000, 0xc76f2d4500000000, 0xf904efaa00000000,\n    0xfabfd84100000000, 0xc4d41aae00000000, 0x710de23700000000,\n    0x4f6620d800000000, 0x4cdd173300000000, 0x72b6d5dc00000000,\n    0x0bad093e00000000, 0x35c6cbd100000000, 0x367dfc3a00000000,\n    0x08163ed500000000, 0x854d352400000000, 0xbb26f7cb00000000,\n    0xb89dc02000000000, 0x86f602cf00000000, 0xffedde2d00000000,\n    0xc1861cc200000000, 0xc23d2b2900000000, 0xfc56e9c600000000,\n    0x998c4c1000000000, 0xa7e78eff00000000, 0xa45cb91400000000,\n    0x9a377bfb00000000, 0xe32ca71900000000, 0xdd4765f600000000,\n    0xdefc521d00000000, 0xe09790f200000000, 0x6dcc9b0300000000,\n    0x53a759ec00000000, 0x501c6e0700000000, 0x6e77ace800000000,\n    0x176c700a00000000, 0x2907b2e500000000, 0x2abc850e00000000,\n    0x14d747e100000000},\n   {0x0000000000000000, 0xc0df8ec100000000, 0xc1b96c5800000000,\n    0x0166e29900000000, 0x8273d9b000000000, 0x42ac577100000000,\n    0x43cab5e800000000, 0x83153b2900000000, 0x45e1c3ba00000000,\n    0x853e4d7b00000000, 0x8458afe200000000, 0x4487212300000000,\n    0xc7921a0a00000000, 0x074d94cb00000000, 0x062b765200000000,\n    0xc6f4f89300000000, 0xcbc4f6ae00000000, 0x0b1b786f00000000,\n    0x0a7d9af600000000, 0xcaa2143700000000, 0x49b72f1e00000000,\n    0x8968a1df00000000, 0x880e434600000000, 0x48d1cd8700000000,\n    0x8e25351400000000, 0x4efabbd500000000, 0x4f9c594c00000000,\n    0x8f43d78d00000000, 0x0c56eca400000000, 0xcc89626500000000,\n    0xcdef80fc00000000, 0x0d300e3d00000000, 0xd78f9c8600000000,\n    0x1750124700000000, 0x1636f0de00000000, 0xd6e97e1f00000000,\n    0x55fc453600000000, 0x9523cbf700000000, 0x9445296e00000000,\n    0x549aa7af00000000, 0x926e5f3c00000000, 0x52b1d1fd00000000,\n    0x53d7336400000000, 0x9308bda500000000, 0x101d868c00000000,\n    0xd0c2084d00000000, 0xd1a4ead400000000, 0x117b641500000000,\n    0x1c4b6a2800000000, 0xdc94e4e900000000, 0xddf2067000000000,\n    0x1d2d88b100000000, 0x9e38b39800000000, 0x5ee73d5900000000,\n    0x5f81dfc000000000, 0x9f5e510100000000, 0x59aaa99200000000,\n    0x9975275300000000, 0x9813c5ca00000000, 0x58cc4b0b00000000,\n    0xdbd9702200000000, 0x1b06fee300000000, 0x1a601c7a00000000,\n    0xdabf92bb00000000, 0xef1948d600000000, 0x2fc6c61700000000,\n    0x2ea0248e00000000, 0xee7faa4f00000000, 0x6d6a916600000000,\n    0xadb51fa700000000, 0xacd3fd3e00000000, 0x6c0c73ff00000000,\n    0xaaf88b6c00000000, 0x6a2705ad00000000, 0x6b41e73400000000,\n    0xab9e69f500000000, 0x288b52dc00000000, 0xe854dc1d00000000,\n    0xe9323e8400000000, 0x29edb04500000000, 0x24ddbe7800000000,\n    0xe40230b900000000, 0xe564d22000000000, 0x25bb5ce100000000,\n    0xa6ae67c800000000, 0x6671e90900000000, 0x67170b9000000000,\n    0xa7c8855100000000, 0x613c7dc200000000, 0xa1e3f30300000000,\n    0xa085119a00000000, 0x605a9f5b00000000, 0xe34fa47200000000,\n    0x23902ab300000000, 0x22f6c82a00000000, 0xe22946eb00000000,\n    0x3896d45000000000, 0xf8495a9100000000, 0xf92fb80800000000,\n    0x39f036c900000000, 0xbae50de000000000, 0x7a3a832100000000,\n    0x7b5c61b800000000, 0xbb83ef7900000000, 0x7d7717ea00000000,\n    0xbda8992b00000000, 0xbcce7bb200000000, 0x7c11f57300000000,\n    0xff04ce5a00000000, 0x3fdb409b00000000, 0x3ebda20200000000,\n    0xfe622cc300000000, 0xf35222fe00000000, 0x338dac3f00000000,\n    0x32eb4ea600000000, 0xf234c06700000000, 0x7121fb4e00000000,\n    0xb1fe758f00000000, 0xb098971600000000, 0x704719d700000000,\n    0xb6b3e14400000000, 0x766c6f8500000000, 0x770a8d1c00000000,\n    0xb7d503dd00000000, 0x34c038f400000000, 0xf41fb63500000000,\n    0xf57954ac00000000, 0x35a6da6d00000000, 0x9f35e17700000000,\n    0x5fea6fb600000000, 0x5e8c8d2f00000000, 0x9e5303ee00000000,\n    0x1d4638c700000000, 0xdd99b60600000000, 0xdcff549f00000000,\n    0x1c20da5e00000000, 0xdad422cd00000000, 0x1a0bac0c00000000,\n    0x1b6d4e9500000000, 0xdbb2c05400000000, 0x58a7fb7d00000000,\n    0x987875bc00000000, 0x991e972500000000, 0x59c119e400000000,\n    0x54f117d900000000, 0x942e991800000000, 0x95487b8100000000,\n    0x5597f54000000000, 0xd682ce6900000000, 0x165d40a800000000,\n    0x173ba23100000000, 0xd7e42cf000000000, 0x1110d46300000000,\n    0xd1cf5aa200000000, 0xd0a9b83b00000000, 0x107636fa00000000,\n    0x93630dd300000000, 0x53bc831200000000, 0x52da618b00000000,\n    0x9205ef4a00000000, 0x48ba7df100000000, 0x8865f33000000000,\n    0x890311a900000000, 0x49dc9f6800000000, 0xcac9a44100000000,\n    0x0a162a8000000000, 0x0b70c81900000000, 0xcbaf46d800000000,\n    0x0d5bbe4b00000000, 0xcd84308a00000000, 0xcce2d21300000000,\n    0x0c3d5cd200000000, 0x8f2867fb00000000, 0x4ff7e93a00000000,\n    0x4e910ba300000000, 0x8e4e856200000000, 0x837e8b5f00000000,\n    0x43a1059e00000000, 0x42c7e70700000000, 0x821869c600000000,\n    0x010d52ef00000000, 0xc1d2dc2e00000000, 0xc0b43eb700000000,\n    0x006bb07600000000, 0xc69f48e500000000, 0x0640c62400000000,\n    0x072624bd00000000, 0xc7f9aa7c00000000, 0x44ec915500000000,\n    0x84331f9400000000, 0x8555fd0d00000000, 0x458a73cc00000000,\n    0x702ca9a100000000, 0xb0f3276000000000, 0xb195c5f900000000,\n    0x714a4b3800000000, 0xf25f701100000000, 0x3280fed000000000,\n    0x33e61c4900000000, 0xf339928800000000, 0x35cd6a1b00000000,\n    0xf512e4da00000000, 0xf474064300000000, 0x34ab888200000000,\n    0xb7beb3ab00000000, 0x77613d6a00000000, 0x7607dff300000000,\n    0xb6d8513200000000, 0xbbe85f0f00000000, 0x7b37d1ce00000000,\n    0x7a51335700000000, 0xba8ebd9600000000, 0x399b86bf00000000,\n    0xf944087e00000000, 0xf822eae700000000, 0x38fd642600000000,\n    0xfe099cb500000000, 0x3ed6127400000000, 0x3fb0f0ed00000000,\n    0xff6f7e2c00000000, 0x7c7a450500000000, 0xbca5cbc400000000,\n    0xbdc3295d00000000, 0x7d1ca79c00000000, 0xa7a3352700000000,\n    0x677cbbe600000000, 0x661a597f00000000, 0xa6c5d7be00000000,\n    0x25d0ec9700000000, 0xe50f625600000000, 0xe46980cf00000000,\n    0x24b60e0e00000000, 0xe242f69d00000000, 0x229d785c00000000,\n    0x23fb9ac500000000, 0xe324140400000000, 0x60312f2d00000000,\n    0xa0eea1ec00000000, 0xa188437500000000, 0x6157cdb400000000,\n    0x6c67c38900000000, 0xacb84d4800000000, 0xaddeafd100000000,\n    0x6d01211000000000, 0xee141a3900000000, 0x2ecb94f800000000,\n    0x2fad766100000000, 0xef72f8a000000000, 0x2986003300000000,\n    0xe9598ef200000000, 0xe83f6c6b00000000, 0x28e0e2aa00000000,\n    0xabf5d98300000000, 0x6b2a574200000000, 0x6a4cb5db00000000,\n    0xaa933b1a00000000},\n   {0x0000000000000000, 0x6f4ca59b00000000, 0x9f9e3bec00000000,\n    0xf0d29e7700000000, 0x7f3b060300000000, 0x1077a39800000000,\n    0xe0a53def00000000, 0x8fe9987400000000, 0xfe760c0600000000,\n    0x913aa99d00000000, 0x61e837ea00000000, 0x0ea4927100000000,\n    0x814d0a0500000000, 0xee01af9e00000000, 0x1ed331e900000000,\n    0x719f947200000000, 0xfced180c00000000, 0x93a1bd9700000000,\n    0x637323e000000000, 0x0c3f867b00000000, 0x83d61e0f00000000,\n    0xec9abb9400000000, 0x1c4825e300000000, 0x7304807800000000,\n    0x029b140a00000000, 0x6dd7b19100000000, 0x9d052fe600000000,\n    0xf2498a7d00000000, 0x7da0120900000000, 0x12ecb79200000000,\n    0xe23e29e500000000, 0x8d728c7e00000000, 0xf8db311800000000,\n    0x9797948300000000, 0x67450af400000000, 0x0809af6f00000000,\n    0x87e0371b00000000, 0xe8ac928000000000, 0x187e0cf700000000,\n    0x7732a96c00000000, 0x06ad3d1e00000000, 0x69e1988500000000,\n    0x993306f200000000, 0xf67fa36900000000, 0x79963b1d00000000,\n    0x16da9e8600000000, 0xe60800f100000000, 0x8944a56a00000000,\n    0x0436291400000000, 0x6b7a8c8f00000000, 0x9ba812f800000000,\n    0xf4e4b76300000000, 0x7b0d2f1700000000, 0x14418a8c00000000,\n    0xe49314fb00000000, 0x8bdfb16000000000, 0xfa40251200000000,\n    0x950c808900000000, 0x65de1efe00000000, 0x0a92bb6500000000,\n    0x857b231100000000, 0xea37868a00000000, 0x1ae518fd00000000,\n    0x75a9bd6600000000, 0xf0b7633000000000, 0x9ffbc6ab00000000,\n    0x6f2958dc00000000, 0x0065fd4700000000, 0x8f8c653300000000,\n    0xe0c0c0a800000000, 0x10125edf00000000, 0x7f5efb4400000000,\n    0x0ec16f3600000000, 0x618dcaad00000000, 0x915f54da00000000,\n    0xfe13f14100000000, 0x71fa693500000000, 0x1eb6ccae00000000,\n    0xee6452d900000000, 0x8128f74200000000, 0x0c5a7b3c00000000,\n    0x6316dea700000000, 0x93c440d000000000, 0xfc88e54b00000000,\n    0x73617d3f00000000, 0x1c2dd8a400000000, 0xecff46d300000000,\n    0x83b3e34800000000, 0xf22c773a00000000, 0x9d60d2a100000000,\n    0x6db24cd600000000, 0x02fee94d00000000, 0x8d17713900000000,\n    0xe25bd4a200000000, 0x12894ad500000000, 0x7dc5ef4e00000000,\n    0x086c522800000000, 0x6720f7b300000000, 0x97f269c400000000,\n    0xf8becc5f00000000, 0x7757542b00000000, 0x181bf1b000000000,\n    0xe8c96fc700000000, 0x8785ca5c00000000, 0xf61a5e2e00000000,\n    0x9956fbb500000000, 0x698465c200000000, 0x06c8c05900000000,\n    0x8921582d00000000, 0xe66dfdb600000000, 0x16bf63c100000000,\n    0x79f3c65a00000000, 0xf4814a2400000000, 0x9bcdefbf00000000,\n    0x6b1f71c800000000, 0x0453d45300000000, 0x8bba4c2700000000,\n    0xe4f6e9bc00000000, 0x142477cb00000000, 0x7b68d25000000000,\n    0x0af7462200000000, 0x65bbe3b900000000, 0x95697dce00000000,\n    0xfa25d85500000000, 0x75cc402100000000, 0x1a80e5ba00000000,\n    0xea527bcd00000000, 0x851ede5600000000, 0xe06fc76000000000,\n    0x8f2362fb00000000, 0x7ff1fc8c00000000, 0x10bd591700000000,\n    0x9f54c16300000000, 0xf01864f800000000, 0x00cafa8f00000000,\n    0x6f865f1400000000, 0x1e19cb6600000000, 0x71556efd00000000,\n    0x8187f08a00000000, 0xeecb551100000000, 0x6122cd6500000000,\n    0x0e6e68fe00000000, 0xfebcf68900000000, 0x91f0531200000000,\n    0x1c82df6c00000000, 0x73ce7af700000000, 0x831ce48000000000,\n    0xec50411b00000000, 0x63b9d96f00000000, 0x0cf57cf400000000,\n    0xfc27e28300000000, 0x936b471800000000, 0xe2f4d36a00000000,\n    0x8db876f100000000, 0x7d6ae88600000000, 0x12264d1d00000000,\n    0x9dcfd56900000000, 0xf28370f200000000, 0x0251ee8500000000,\n    0x6d1d4b1e00000000, 0x18b4f67800000000, 0x77f853e300000000,\n    0x872acd9400000000, 0xe866680f00000000, 0x678ff07b00000000,\n    0x08c355e000000000, 0xf811cb9700000000, 0x975d6e0c00000000,\n    0xe6c2fa7e00000000, 0x898e5fe500000000, 0x795cc19200000000,\n    0x1610640900000000, 0x99f9fc7d00000000, 0xf6b559e600000000,\n    0x0667c79100000000, 0x692b620a00000000, 0xe459ee7400000000,\n    0x8b154bef00000000, 0x7bc7d59800000000, 0x148b700300000000,\n    0x9b62e87700000000, 0xf42e4dec00000000, 0x04fcd39b00000000,\n    0x6bb0760000000000, 0x1a2fe27200000000, 0x756347e900000000,\n    0x85b1d99e00000000, 0xeafd7c0500000000, 0x6514e47100000000,\n    0x0a5841ea00000000, 0xfa8adf9d00000000, 0x95c67a0600000000,\n    0x10d8a45000000000, 0x7f9401cb00000000, 0x8f469fbc00000000,\n    0xe00a3a2700000000, 0x6fe3a25300000000, 0x00af07c800000000,\n    0xf07d99bf00000000, 0x9f313c2400000000, 0xeeaea85600000000,\n    0x81e20dcd00000000, 0x713093ba00000000, 0x1e7c362100000000,\n    0x9195ae5500000000, 0xfed90bce00000000, 0x0e0b95b900000000,\n    0x6147302200000000, 0xec35bc5c00000000, 0x837919c700000000,\n    0x73ab87b000000000, 0x1ce7222b00000000, 0x930eba5f00000000,\n    0xfc421fc400000000, 0x0c9081b300000000, 0x63dc242800000000,\n    0x1243b05a00000000, 0x7d0f15c100000000, 0x8ddd8bb600000000,\n    0xe2912e2d00000000, 0x6d78b65900000000, 0x023413c200000000,\n    0xf2e68db500000000, 0x9daa282e00000000, 0xe803954800000000,\n    0x874f30d300000000, 0x779daea400000000, 0x18d10b3f00000000,\n    0x9738934b00000000, 0xf87436d000000000, 0x08a6a8a700000000,\n    0x67ea0d3c00000000, 0x1675994e00000000, 0x79393cd500000000,\n    0x89eba2a200000000, 0xe6a7073900000000, 0x694e9f4d00000000,\n    0x06023ad600000000, 0xf6d0a4a100000000, 0x999c013a00000000,\n    0x14ee8d4400000000, 0x7ba228df00000000, 0x8b70b6a800000000,\n    0xe43c133300000000, 0x6bd58b4700000000, 0x04992edc00000000,\n    0xf44bb0ab00000000, 0x9b07153000000000, 0xea98814200000000,\n    0x85d424d900000000, 0x7506baae00000000, 0x1a4a1f3500000000,\n    0x95a3874100000000, 0xfaef22da00000000, 0x0a3dbcad00000000,\n    0x6571193600000000},\n   {0x0000000000000000, 0x85d996dd00000000, 0x4bb55c6000000000,\n    0xce6ccabd00000000, 0x966ab9c000000000, 0x13b32f1d00000000,\n    0xdddfe5a000000000, 0x5806737d00000000, 0x6dd3035a00000000,\n    0xe80a958700000000, 0x26665f3a00000000, 0xa3bfc9e700000000,\n    0xfbb9ba9a00000000, 0x7e602c4700000000, 0xb00ce6fa00000000,\n    0x35d5702700000000, 0xdaa607b400000000, 0x5f7f916900000000,\n    0x91135bd400000000, 0x14cacd0900000000, 0x4cccbe7400000000,\n    0xc91528a900000000, 0x0779e21400000000, 0x82a074c900000000,\n    0xb77504ee00000000, 0x32ac923300000000, 0xfcc0588e00000000,\n    0x7919ce5300000000, 0x211fbd2e00000000, 0xa4c62bf300000000,\n    0x6aaae14e00000000, 0xef73779300000000, 0xf54b7eb300000000,\n    0x7092e86e00000000, 0xbefe22d300000000, 0x3b27b40e00000000,\n    0x6321c77300000000, 0xe6f851ae00000000, 0x28949b1300000000,\n    0xad4d0dce00000000, 0x98987de900000000, 0x1d41eb3400000000,\n    0xd32d218900000000, 0x56f4b75400000000, 0x0ef2c42900000000,\n    0x8b2b52f400000000, 0x4547984900000000, 0xc09e0e9400000000,\n    0x2fed790700000000, 0xaa34efda00000000, 0x6458256700000000,\n    0xe181b3ba00000000, 0xb987c0c700000000, 0x3c5e561a00000000,\n    0xf2329ca700000000, 0x77eb0a7a00000000, 0x423e7a5d00000000,\n    0xc7e7ec8000000000, 0x098b263d00000000, 0x8c52b0e000000000,\n    0xd454c39d00000000, 0x518d554000000000, 0x9fe19ffd00000000,\n    0x1a38092000000000, 0xab918dbd00000000, 0x2e481b6000000000,\n    0xe024d1dd00000000, 0x65fd470000000000, 0x3dfb347d00000000,\n    0xb822a2a000000000, 0x764e681d00000000, 0xf397fec000000000,\n    0xc6428ee700000000, 0x439b183a00000000, 0x8df7d28700000000,\n    0x082e445a00000000, 0x5028372700000000, 0xd5f1a1fa00000000,\n    0x1b9d6b4700000000, 0x9e44fd9a00000000, 0x71378a0900000000,\n    0xf4ee1cd400000000, 0x3a82d66900000000, 0xbf5b40b400000000,\n    0xe75d33c900000000, 0x6284a51400000000, 0xace86fa900000000,\n    0x2931f97400000000, 0x1ce4895300000000, 0x993d1f8e00000000,\n    0x5751d53300000000, 0xd28843ee00000000, 0x8a8e309300000000,\n    0x0f57a64e00000000, 0xc13b6cf300000000, 0x44e2fa2e00000000,\n    0x5edaf30e00000000, 0xdb0365d300000000, 0x156faf6e00000000,\n    0x90b639b300000000, 0xc8b04ace00000000, 0x4d69dc1300000000,\n    0x830516ae00000000, 0x06dc807300000000, 0x3309f05400000000,\n    0xb6d0668900000000, 0x78bcac3400000000, 0xfd653ae900000000,\n    0xa563499400000000, 0x20badf4900000000, 0xeed615f400000000,\n    0x6b0f832900000000, 0x847cf4ba00000000, 0x01a5626700000000,\n    0xcfc9a8da00000000, 0x4a103e0700000000, 0x12164d7a00000000,\n    0x97cfdba700000000, 0x59a3111a00000000, 0xdc7a87c700000000,\n    0xe9aff7e000000000, 0x6c76613d00000000, 0xa21aab8000000000,\n    0x27c33d5d00000000, 0x7fc54e2000000000, 0xfa1cd8fd00000000,\n    0x3470124000000000, 0xb1a9849d00000000, 0x17256aa000000000,\n    0x92fcfc7d00000000, 0x5c9036c000000000, 0xd949a01d00000000,\n    0x814fd36000000000, 0x049645bd00000000, 0xcafa8f0000000000,\n    0x4f2319dd00000000, 0x7af669fa00000000, 0xff2fff2700000000,\n    0x3143359a00000000, 0xb49aa34700000000, 0xec9cd03a00000000,\n    0x694546e700000000, 0xa7298c5a00000000, 0x22f01a8700000000,\n    0xcd836d1400000000, 0x485afbc900000000, 0x8636317400000000,\n    0x03efa7a900000000, 0x5be9d4d400000000, 0xde30420900000000,\n    0x105c88b400000000, 0x95851e6900000000, 0xa0506e4e00000000,\n    0x2589f89300000000, 0xebe5322e00000000, 0x6e3ca4f300000000,\n    0x363ad78e00000000, 0xb3e3415300000000, 0x7d8f8bee00000000,\n    0xf8561d3300000000, 0xe26e141300000000, 0x67b782ce00000000,\n    0xa9db487300000000, 0x2c02deae00000000, 0x7404add300000000,\n    0xf1dd3b0e00000000, 0x3fb1f1b300000000, 0xba68676e00000000,\n    0x8fbd174900000000, 0x0a64819400000000, 0xc4084b2900000000,\n    0x41d1ddf400000000, 0x19d7ae8900000000, 0x9c0e385400000000,\n    0x5262f2e900000000, 0xd7bb643400000000, 0x38c813a700000000,\n    0xbd11857a00000000, 0x737d4fc700000000, 0xf6a4d91a00000000,\n    0xaea2aa6700000000, 0x2b7b3cba00000000, 0xe517f60700000000,\n    0x60ce60da00000000, 0x551b10fd00000000, 0xd0c2862000000000,\n    0x1eae4c9d00000000, 0x9b77da4000000000, 0xc371a93d00000000,\n    0x46a83fe000000000, 0x88c4f55d00000000, 0x0d1d638000000000,\n    0xbcb4e71d00000000, 0x396d71c000000000, 0xf701bb7d00000000,\n    0x72d82da000000000, 0x2ade5edd00000000, 0xaf07c80000000000,\n    0x616b02bd00000000, 0xe4b2946000000000, 0xd167e44700000000,\n    0x54be729a00000000, 0x9ad2b82700000000, 0x1f0b2efa00000000,\n    0x470d5d8700000000, 0xc2d4cb5a00000000, 0x0cb801e700000000,\n    0x8961973a00000000, 0x6612e0a900000000, 0xe3cb767400000000,\n    0x2da7bcc900000000, 0xa87e2a1400000000, 0xf078596900000000,\n    0x75a1cfb400000000, 0xbbcd050900000000, 0x3e1493d400000000,\n    0x0bc1e3f300000000, 0x8e18752e00000000, 0x4074bf9300000000,\n    0xc5ad294e00000000, 0x9dab5a3300000000, 0x1872ccee00000000,\n    0xd61e065300000000, 0x53c7908e00000000, 0x49ff99ae00000000,\n    0xcc260f7300000000, 0x024ac5ce00000000, 0x8793531300000000,\n    0xdf95206e00000000, 0x5a4cb6b300000000, 0x94207c0e00000000,\n    0x11f9ead300000000, 0x242c9af400000000, 0xa1f50c2900000000,\n    0x6f99c69400000000, 0xea40504900000000, 0xb246233400000000,\n    0x379fb5e900000000, 0xf9f37f5400000000, 0x7c2ae98900000000,\n    0x93599e1a00000000, 0x168008c700000000, 0xd8ecc27a00000000,\n    0x5d3554a700000000, 0x053327da00000000, 0x80eab10700000000,\n    0x4e867bba00000000, 0xcb5fed6700000000, 0xfe8a9d4000000000,\n    0x7b530b9d00000000, 0xb53fc12000000000, 0x30e657fd00000000,\n    0x68e0248000000000, 0xed39b25d00000000, 0x235578e000000000,\n    0xa68cee3d00000000},\n   {0x0000000000000000, 0x76e10f9d00000000, 0xadc46ee100000000,\n    0xdb25617c00000000, 0x1b8fac1900000000, 0x6d6ea38400000000,\n    0xb64bc2f800000000, 0xc0aacd6500000000, 0x361e593300000000,\n    0x40ff56ae00000000, 0x9bda37d200000000, 0xed3b384f00000000,\n    0x2d91f52a00000000, 0x5b70fab700000000, 0x80559bcb00000000,\n    0xf6b4945600000000, 0x6c3cb26600000000, 0x1addbdfb00000000,\n    0xc1f8dc8700000000, 0xb719d31a00000000, 0x77b31e7f00000000,\n    0x015211e200000000, 0xda77709e00000000, 0xac967f0300000000,\n    0x5a22eb5500000000, 0x2cc3e4c800000000, 0xf7e685b400000000,\n    0x81078a2900000000, 0x41ad474c00000000, 0x374c48d100000000,\n    0xec6929ad00000000, 0x9a88263000000000, 0xd87864cd00000000,\n    0xae996b5000000000, 0x75bc0a2c00000000, 0x035d05b100000000,\n    0xc3f7c8d400000000, 0xb516c74900000000, 0x6e33a63500000000,\n    0x18d2a9a800000000, 0xee663dfe00000000, 0x9887326300000000,\n    0x43a2531f00000000, 0x35435c8200000000, 0xf5e991e700000000,\n    0x83089e7a00000000, 0x582dff0600000000, 0x2eccf09b00000000,\n    0xb444d6ab00000000, 0xc2a5d93600000000, 0x1980b84a00000000,\n    0x6f61b7d700000000, 0xafcb7ab200000000, 0xd92a752f00000000,\n    0x020f145300000000, 0x74ee1bce00000000, 0x825a8f9800000000,\n    0xf4bb800500000000, 0x2f9ee17900000000, 0x597feee400000000,\n    0x99d5238100000000, 0xef342c1c00000000, 0x34114d6000000000,\n    0x42f042fd00000000, 0xf1f7b94100000000, 0x8716b6dc00000000,\n    0x5c33d7a000000000, 0x2ad2d83d00000000, 0xea78155800000000,\n    0x9c991ac500000000, 0x47bc7bb900000000, 0x315d742400000000,\n    0xc7e9e07200000000, 0xb108efef00000000, 0x6a2d8e9300000000,\n    0x1ccc810e00000000, 0xdc664c6b00000000, 0xaa8743f600000000,\n    0x71a2228a00000000, 0x07432d1700000000, 0x9dcb0b2700000000,\n    0xeb2a04ba00000000, 0x300f65c600000000, 0x46ee6a5b00000000,\n    0x8644a73e00000000, 0xf0a5a8a300000000, 0x2b80c9df00000000,\n    0x5d61c64200000000, 0xabd5521400000000, 0xdd345d8900000000,\n    0x06113cf500000000, 0x70f0336800000000, 0xb05afe0d00000000,\n    0xc6bbf19000000000, 0x1d9e90ec00000000, 0x6b7f9f7100000000,\n    0x298fdd8c00000000, 0x5f6ed21100000000, 0x844bb36d00000000,\n    0xf2aabcf000000000, 0x3200719500000000, 0x44e17e0800000000,\n    0x9fc41f7400000000, 0xe92510e900000000, 0x1f9184bf00000000,\n    0x69708b2200000000, 0xb255ea5e00000000, 0xc4b4e5c300000000,\n    0x041e28a600000000, 0x72ff273b00000000, 0xa9da464700000000,\n    0xdf3b49da00000000, 0x45b36fea00000000, 0x3352607700000000,\n    0xe877010b00000000, 0x9e960e9600000000, 0x5e3cc3f300000000,\n    0x28ddcc6e00000000, 0xf3f8ad1200000000, 0x8519a28f00000000,\n    0x73ad36d900000000, 0x054c394400000000, 0xde69583800000000,\n    0xa88857a500000000, 0x68229ac000000000, 0x1ec3955d00000000,\n    0xc5e6f42100000000, 0xb307fbbc00000000, 0xe2ef738300000000,\n    0x940e7c1e00000000, 0x4f2b1d6200000000, 0x39ca12ff00000000,\n    0xf960df9a00000000, 0x8f81d00700000000, 0x54a4b17b00000000,\n    0x2245bee600000000, 0xd4f12ab000000000, 0xa210252d00000000,\n    0x7935445100000000, 0x0fd44bcc00000000, 0xcf7e86a900000000,\n    0xb99f893400000000, 0x62bae84800000000, 0x145be7d500000000,\n    0x8ed3c1e500000000, 0xf832ce7800000000, 0x2317af0400000000,\n    0x55f6a09900000000, 0x955c6dfc00000000, 0xe3bd626100000000,\n    0x3898031d00000000, 0x4e790c8000000000, 0xb8cd98d600000000,\n    0xce2c974b00000000, 0x1509f63700000000, 0x63e8f9aa00000000,\n    0xa34234cf00000000, 0xd5a33b5200000000, 0x0e865a2e00000000,\n    0x786755b300000000, 0x3a97174e00000000, 0x4c7618d300000000,\n    0x975379af00000000, 0xe1b2763200000000, 0x2118bb5700000000,\n    0x57f9b4ca00000000, 0x8cdcd5b600000000, 0xfa3dda2b00000000,\n    0x0c894e7d00000000, 0x7a6841e000000000, 0xa14d209c00000000,\n    0xd7ac2f0100000000, 0x1706e26400000000, 0x61e7edf900000000,\n    0xbac28c8500000000, 0xcc23831800000000, 0x56aba52800000000,\n    0x204aaab500000000, 0xfb6fcbc900000000, 0x8d8ec45400000000,\n    0x4d24093100000000, 0x3bc506ac00000000, 0xe0e067d000000000,\n    0x9601684d00000000, 0x60b5fc1b00000000, 0x1654f38600000000,\n    0xcd7192fa00000000, 0xbb909d6700000000, 0x7b3a500200000000,\n    0x0ddb5f9f00000000, 0xd6fe3ee300000000, 0xa01f317e00000000,\n    0x1318cac200000000, 0x65f9c55f00000000, 0xbedca42300000000,\n    0xc83dabbe00000000, 0x089766db00000000, 0x7e76694600000000,\n    0xa553083a00000000, 0xd3b207a700000000, 0x250693f100000000,\n    0x53e79c6c00000000, 0x88c2fd1000000000, 0xfe23f28d00000000,\n    0x3e893fe800000000, 0x4868307500000000, 0x934d510900000000,\n    0xe5ac5e9400000000, 0x7f2478a400000000, 0x09c5773900000000,\n    0xd2e0164500000000, 0xa40119d800000000, 0x64abd4bd00000000,\n    0x124adb2000000000, 0xc96fba5c00000000, 0xbf8eb5c100000000,\n    0x493a219700000000, 0x3fdb2e0a00000000, 0xe4fe4f7600000000,\n    0x921f40eb00000000, 0x52b58d8e00000000, 0x2454821300000000,\n    0xff71e36f00000000, 0x8990ecf200000000, 0xcb60ae0f00000000,\n    0xbd81a19200000000, 0x66a4c0ee00000000, 0x1045cf7300000000,\n    0xd0ef021600000000, 0xa60e0d8b00000000, 0x7d2b6cf700000000,\n    0x0bca636a00000000, 0xfd7ef73c00000000, 0x8b9ff8a100000000,\n    0x50ba99dd00000000, 0x265b964000000000, 0xe6f15b2500000000,\n    0x901054b800000000, 0x4b3535c400000000, 0x3dd43a5900000000,\n    0xa75c1c6900000000, 0xd1bd13f400000000, 0x0a98728800000000,\n    0x7c797d1500000000, 0xbcd3b07000000000, 0xca32bfed00000000,\n    0x1117de9100000000, 0x67f6d10c00000000, 0x9142455a00000000,\n    0xe7a34ac700000000, 0x3c862bbb00000000, 0x4a67242600000000,\n    0x8acde94300000000, 0xfc2ce6de00000000, 0x270987a200000000,\n    0x51e8883f00000000},\n   {0x0000000000000000, 0xe8dbfbb900000000, 0x91b186a800000000,\n    0x796a7d1100000000, 0x63657c8a00000000, 0x8bbe873300000000,\n    0xf2d4fa2200000000, 0x1a0f019b00000000, 0x87cc89cf00000000,\n    0x6f17727600000000, 0x167d0f6700000000, 0xfea6f4de00000000,\n    0xe4a9f54500000000, 0x0c720efc00000000, 0x751873ed00000000,\n    0x9dc3885400000000, 0x4f9f624400000000, 0xa74499fd00000000,\n    0xde2ee4ec00000000, 0x36f51f5500000000, 0x2cfa1ece00000000,\n    0xc421e57700000000, 0xbd4b986600000000, 0x559063df00000000,\n    0xc853eb8b00000000, 0x2088103200000000, 0x59e26d2300000000,\n    0xb139969a00000000, 0xab36970100000000, 0x43ed6cb800000000,\n    0x3a8711a900000000, 0xd25cea1000000000, 0x9e3ec58800000000,\n    0x76e53e3100000000, 0x0f8f432000000000, 0xe754b89900000000,\n    0xfd5bb90200000000, 0x158042bb00000000, 0x6cea3faa00000000,\n    0x8431c41300000000, 0x19f24c4700000000, 0xf129b7fe00000000,\n    0x8843caef00000000, 0x6098315600000000, 0x7a9730cd00000000,\n    0x924ccb7400000000, 0xeb26b66500000000, 0x03fd4ddc00000000,\n    0xd1a1a7cc00000000, 0x397a5c7500000000, 0x4010216400000000,\n    0xa8cbdadd00000000, 0xb2c4db4600000000, 0x5a1f20ff00000000,\n    0x23755dee00000000, 0xcbaea65700000000, 0x566d2e0300000000,\n    0xbeb6d5ba00000000, 0xc7dca8ab00000000, 0x2f07531200000000,\n    0x3508528900000000, 0xddd3a93000000000, 0xa4b9d42100000000,\n    0x4c622f9800000000, 0x7d7bfbca00000000, 0x95a0007300000000,\n    0xecca7d6200000000, 0x041186db00000000, 0x1e1e874000000000,\n    0xf6c57cf900000000, 0x8faf01e800000000, 0x6774fa5100000000,\n    0xfab7720500000000, 0x126c89bc00000000, 0x6b06f4ad00000000,\n    0x83dd0f1400000000, 0x99d20e8f00000000, 0x7109f53600000000,\n    0x0863882700000000, 0xe0b8739e00000000, 0x32e4998e00000000,\n    0xda3f623700000000, 0xa3551f2600000000, 0x4b8ee49f00000000,\n    0x5181e50400000000, 0xb95a1ebd00000000, 0xc03063ac00000000,\n    0x28eb981500000000, 0xb528104100000000, 0x5df3ebf800000000,\n    0x249996e900000000, 0xcc426d5000000000, 0xd64d6ccb00000000,\n    0x3e96977200000000, 0x47fcea6300000000, 0xaf2711da00000000,\n    0xe3453e4200000000, 0x0b9ec5fb00000000, 0x72f4b8ea00000000,\n    0x9a2f435300000000, 0x802042c800000000, 0x68fbb97100000000,\n    0x1191c46000000000, 0xf94a3fd900000000, 0x6489b78d00000000,\n    0x8c524c3400000000, 0xf538312500000000, 0x1de3ca9c00000000,\n    0x07eccb0700000000, 0xef3730be00000000, 0x965d4daf00000000,\n    0x7e86b61600000000, 0xacda5c0600000000, 0x4401a7bf00000000,\n    0x3d6bdaae00000000, 0xd5b0211700000000, 0xcfbf208c00000000,\n    0x2764db3500000000, 0x5e0ea62400000000, 0xb6d55d9d00000000,\n    0x2b16d5c900000000, 0xc3cd2e7000000000, 0xbaa7536100000000,\n    0x527ca8d800000000, 0x4873a94300000000, 0xa0a852fa00000000,\n    0xd9c22feb00000000, 0x3119d45200000000, 0xbbf0874e00000000,\n    0x532b7cf700000000, 0x2a4101e600000000, 0xc29afa5f00000000,\n    0xd895fbc400000000, 0x304e007d00000000, 0x49247d6c00000000,\n    0xa1ff86d500000000, 0x3c3c0e8100000000, 0xd4e7f53800000000,\n    0xad8d882900000000, 0x4556739000000000, 0x5f59720b00000000,\n    0xb78289b200000000, 0xcee8f4a300000000, 0x26330f1a00000000,\n    0xf46fe50a00000000, 0x1cb41eb300000000, 0x65de63a200000000,\n    0x8d05981b00000000, 0x970a998000000000, 0x7fd1623900000000,\n    0x06bb1f2800000000, 0xee60e49100000000, 0x73a36cc500000000,\n    0x9b78977c00000000, 0xe212ea6d00000000, 0x0ac911d400000000,\n    0x10c6104f00000000, 0xf81debf600000000, 0x817796e700000000,\n    0x69ac6d5e00000000, 0x25ce42c600000000, 0xcd15b97f00000000,\n    0xb47fc46e00000000, 0x5ca43fd700000000, 0x46ab3e4c00000000,\n    0xae70c5f500000000, 0xd71ab8e400000000, 0x3fc1435d00000000,\n    0xa202cb0900000000, 0x4ad930b000000000, 0x33b34da100000000,\n    0xdb68b61800000000, 0xc167b78300000000, 0x29bc4c3a00000000,\n    0x50d6312b00000000, 0xb80dca9200000000, 0x6a51208200000000,\n    0x828adb3b00000000, 0xfbe0a62a00000000, 0x133b5d9300000000,\n    0x09345c0800000000, 0xe1efa7b100000000, 0x9885daa000000000,\n    0x705e211900000000, 0xed9da94d00000000, 0x054652f400000000,\n    0x7c2c2fe500000000, 0x94f7d45c00000000, 0x8ef8d5c700000000,\n    0x66232e7e00000000, 0x1f49536f00000000, 0xf792a8d600000000,\n    0xc68b7c8400000000, 0x2e50873d00000000, 0x573afa2c00000000,\n    0xbfe1019500000000, 0xa5ee000e00000000, 0x4d35fbb700000000,\n    0x345f86a600000000, 0xdc847d1f00000000, 0x4147f54b00000000,\n    0xa99c0ef200000000, 0xd0f673e300000000, 0x382d885a00000000,\n    0x222289c100000000, 0xcaf9727800000000, 0xb3930f6900000000,\n    0x5b48f4d000000000, 0x89141ec000000000, 0x61cfe57900000000,\n    0x18a5986800000000, 0xf07e63d100000000, 0xea71624a00000000,\n    0x02aa99f300000000, 0x7bc0e4e200000000, 0x931b1f5b00000000,\n    0x0ed8970f00000000, 0xe6036cb600000000, 0x9f6911a700000000,\n    0x77b2ea1e00000000, 0x6dbdeb8500000000, 0x8566103c00000000,\n    0xfc0c6d2d00000000, 0x14d7969400000000, 0x58b5b90c00000000,\n    0xb06e42b500000000, 0xc9043fa400000000, 0x21dfc41d00000000,\n    0x3bd0c58600000000, 0xd30b3e3f00000000, 0xaa61432e00000000,\n    0x42bab89700000000, 0xdf7930c300000000, 0x37a2cb7a00000000,\n    0x4ec8b66b00000000, 0xa6134dd200000000, 0xbc1c4c4900000000,\n    0x54c7b7f000000000, 0x2dadcae100000000, 0xc576315800000000,\n    0x172adb4800000000, 0xfff120f100000000, 0x869b5de000000000,\n    0x6e40a65900000000, 0x744fa7c200000000, 0x9c945c7b00000000,\n    0xe5fe216a00000000, 0x0d25dad300000000, 0x90e6528700000000,\n    0x783da93e00000000, 0x0157d42f00000000, 0xe98c2f9600000000,\n    0xf3832e0d00000000, 0x1b58d5b400000000, 0x6232a8a500000000,\n    0x8ae9531c00000000},\n   {0x0000000000000000, 0x919168ae00000000, 0x6325a08700000000,\n    0xf2b4c82900000000, 0x874c31d400000000, 0x16dd597a00000000,\n    0xe469915300000000, 0x75f8f9fd00000000, 0x4f9f137300000000,\n    0xde0e7bdd00000000, 0x2cbab3f400000000, 0xbd2bdb5a00000000,\n    0xc8d322a700000000, 0x59424a0900000000, 0xabf6822000000000,\n    0x3a67ea8e00000000, 0x9e3e27e600000000, 0x0faf4f4800000000,\n    0xfd1b876100000000, 0x6c8aefcf00000000, 0x1972163200000000,\n    0x88e37e9c00000000, 0x7a57b6b500000000, 0xebc6de1b00000000,\n    0xd1a1349500000000, 0x40305c3b00000000, 0xb284941200000000,\n    0x2315fcbc00000000, 0x56ed054100000000, 0xc77c6def00000000,\n    0x35c8a5c600000000, 0xa459cd6800000000, 0x7d7b3f1700000000,\n    0xecea57b900000000, 0x1e5e9f9000000000, 0x8fcff73e00000000,\n    0xfa370ec300000000, 0x6ba6666d00000000, 0x9912ae4400000000,\n    0x0883c6ea00000000, 0x32e42c6400000000, 0xa37544ca00000000,\n    0x51c18ce300000000, 0xc050e44d00000000, 0xb5a81db000000000,\n    0x2439751e00000000, 0xd68dbd3700000000, 0x471cd59900000000,\n    0xe34518f100000000, 0x72d4705f00000000, 0x8060b87600000000,\n    0x11f1d0d800000000, 0x6409292500000000, 0xf598418b00000000,\n    0x072c89a200000000, 0x96bde10c00000000, 0xacda0b8200000000,\n    0x3d4b632c00000000, 0xcfffab0500000000, 0x5e6ec3ab00000000,\n    0x2b963a5600000000, 0xba0752f800000000, 0x48b39ad100000000,\n    0xd922f27f00000000, 0xfaf67e2e00000000, 0x6b67168000000000,\n    0x99d3dea900000000, 0x0842b60700000000, 0x7dba4ffa00000000,\n    0xec2b275400000000, 0x1e9fef7d00000000, 0x8f0e87d300000000,\n    0xb5696d5d00000000, 0x24f805f300000000, 0xd64ccdda00000000,\n    0x47dda57400000000, 0x32255c8900000000, 0xa3b4342700000000,\n    0x5100fc0e00000000, 0xc09194a000000000, 0x64c859c800000000,\n    0xf559316600000000, 0x07edf94f00000000, 0x967c91e100000000,\n    0xe384681c00000000, 0x721500b200000000, 0x80a1c89b00000000,\n    0x1130a03500000000, 0x2b574abb00000000, 0xbac6221500000000,\n    0x4872ea3c00000000, 0xd9e3829200000000, 0xac1b7b6f00000000,\n    0x3d8a13c100000000, 0xcf3edbe800000000, 0x5eafb34600000000,\n    0x878d413900000000, 0x161c299700000000, 0xe4a8e1be00000000,\n    0x7539891000000000, 0x00c170ed00000000, 0x9150184300000000,\n    0x63e4d06a00000000, 0xf275b8c400000000, 0xc812524a00000000,\n    0x59833ae400000000, 0xab37f2cd00000000, 0x3aa69a6300000000,\n    0x4f5e639e00000000, 0xdecf0b3000000000, 0x2c7bc31900000000,\n    0xbdeaabb700000000, 0x19b366df00000000, 0x88220e7100000000,\n    0x7a96c65800000000, 0xeb07aef600000000, 0x9eff570b00000000,\n    0x0f6e3fa500000000, 0xfddaf78c00000000, 0x6c4b9f2200000000,\n    0x562c75ac00000000, 0xc7bd1d0200000000, 0x3509d52b00000000,\n    0xa498bd8500000000, 0xd160447800000000, 0x40f12cd600000000,\n    0xb245e4ff00000000, 0x23d48c5100000000, 0xf4edfd5c00000000,\n    0x657c95f200000000, 0x97c85ddb00000000, 0x0659357500000000,\n    0x73a1cc8800000000, 0xe230a42600000000, 0x10846c0f00000000,\n    0x811504a100000000, 0xbb72ee2f00000000, 0x2ae3868100000000,\n    0xd8574ea800000000, 0x49c6260600000000, 0x3c3edffb00000000,\n    0xadafb75500000000, 0x5f1b7f7c00000000, 0xce8a17d200000000,\n    0x6ad3daba00000000, 0xfb42b21400000000, 0x09f67a3d00000000,\n    0x9867129300000000, 0xed9feb6e00000000, 0x7c0e83c000000000,\n    0x8eba4be900000000, 0x1f2b234700000000, 0x254cc9c900000000,\n    0xb4dda16700000000, 0x4669694e00000000, 0xd7f801e000000000,\n    0xa200f81d00000000, 0x339190b300000000, 0xc125589a00000000,\n    0x50b4303400000000, 0x8996c24b00000000, 0x1807aae500000000,\n    0xeab362cc00000000, 0x7b220a6200000000, 0x0edaf39f00000000,\n    0x9f4b9b3100000000, 0x6dff531800000000, 0xfc6e3bb600000000,\n    0xc609d13800000000, 0x5798b99600000000, 0xa52c71bf00000000,\n    0x34bd191100000000, 0x4145e0ec00000000, 0xd0d4884200000000,\n    0x2260406b00000000, 0xb3f128c500000000, 0x17a8e5ad00000000,\n    0x86398d0300000000, 0x748d452a00000000, 0xe51c2d8400000000,\n    0x90e4d47900000000, 0x0175bcd700000000, 0xf3c174fe00000000,\n    0x62501c5000000000, 0x5837f6de00000000, 0xc9a69e7000000000,\n    0x3b12565900000000, 0xaa833ef700000000, 0xdf7bc70a00000000,\n    0x4eeaafa400000000, 0xbc5e678d00000000, 0x2dcf0f2300000000,\n    0x0e1b837200000000, 0x9f8aebdc00000000, 0x6d3e23f500000000,\n    0xfcaf4b5b00000000, 0x8957b2a600000000, 0x18c6da0800000000,\n    0xea72122100000000, 0x7be37a8f00000000, 0x4184900100000000,\n    0xd015f8af00000000, 0x22a1308600000000, 0xb330582800000000,\n    0xc6c8a1d500000000, 0x5759c97b00000000, 0xa5ed015200000000,\n    0x347c69fc00000000, 0x9025a49400000000, 0x01b4cc3a00000000,\n    0xf300041300000000, 0x62916cbd00000000, 0x1769954000000000,\n    0x86f8fdee00000000, 0x744c35c700000000, 0xe5dd5d6900000000,\n    0xdfbab7e700000000, 0x4e2bdf4900000000, 0xbc9f176000000000,\n    0x2d0e7fce00000000, 0x58f6863300000000, 0xc967ee9d00000000,\n    0x3bd326b400000000, 0xaa424e1a00000000, 0x7360bc6500000000,\n    0xe2f1d4cb00000000, 0x10451ce200000000, 0x81d4744c00000000,\n    0xf42c8db100000000, 0x65bde51f00000000, 0x97092d3600000000,\n    0x0698459800000000, 0x3cffaf1600000000, 0xad6ec7b800000000,\n    0x5fda0f9100000000, 0xce4b673f00000000, 0xbbb39ec200000000,\n    0x2a22f66c00000000, 0xd8963e4500000000, 0x490756eb00000000,\n    0xed5e9b8300000000, 0x7ccff32d00000000, 0x8e7b3b0400000000,\n    0x1fea53aa00000000, 0x6a12aa5700000000, 0xfb83c2f900000000,\n    0x09370ad000000000, 0x98a6627e00000000, 0xa2c188f000000000,\n    0x3350e05e00000000, 0xc1e4287700000000, 0x507540d900000000,\n    0x258db92400000000, 0xb41cd18a00000000, 0x46a819a300000000,\n    0xd739710d00000000}};\n\n#else /* W == 4 */\n\nlocal const z_crc_t FAR crc_braid_table[][256] = {\n   {0x00000000, 0xccaa009e, 0x4225077d, 0x8e8f07e3, 0x844a0efa,\n    0x48e00e64, 0xc66f0987, 0x0ac50919, 0xd3e51bb5, 0x1f4f1b2b,\n    0x91c01cc8, 0x5d6a1c56, 0x57af154f, 0x9b0515d1, 0x158a1232,\n    0xd92012ac, 0x7cbb312b, 0xb01131b5, 0x3e9e3656, 0xf23436c8,\n    0xf8f13fd1, 0x345b3f4f, 0xbad438ac, 0x767e3832, 0xaf5e2a9e,\n    0x63f42a00, 0xed7b2de3, 0x21d12d7d, 0x2b142464, 0xe7be24fa,\n    0x69312319, 0xa59b2387, 0xf9766256, 0x35dc62c8, 0xbb53652b,\n    0x77f965b5, 0x7d3c6cac, 0xb1966c32, 0x3f196bd1, 0xf3b36b4f,\n    0x2a9379e3, 0xe639797d, 0x68b67e9e, 0xa41c7e00, 0xaed97719,\n    0x62737787, 0xecfc7064, 0x205670fa, 0x85cd537d, 0x496753e3,\n    0xc7e85400, 0x0b42549e, 0x01875d87, 0xcd2d5d19, 0x43a25afa,\n    0x8f085a64, 0x562848c8, 0x9a824856, 0x140d4fb5, 0xd8a74f2b,\n    0xd2624632, 0x1ec846ac, 0x9047414f, 0x5ced41d1, 0x299dc2ed,\n    0xe537c273, 0x6bb8c590, 0xa712c50e, 0xadd7cc17, 0x617dcc89,\n    0xeff2cb6a, 0x2358cbf4, 0xfa78d958, 0x36d2d9c6, 0xb85dde25,\n    0x74f7debb, 0x7e32d7a2, 0xb298d73c, 0x3c17d0df, 0xf0bdd041,\n    0x5526f3c6, 0x998cf358, 0x1703f4bb, 0xdba9f425, 0xd16cfd3c,\n    0x1dc6fda2, 0x9349fa41, 0x5fe3fadf, 0x86c3e873, 0x4a69e8ed,\n    0xc4e6ef0e, 0x084cef90, 0x0289e689, 0xce23e617, 0x40ace1f4,\n    0x8c06e16a, 0xd0eba0bb, 0x1c41a025, 0x92cea7c6, 0x5e64a758,\n    0x54a1ae41, 0x980baedf, 0x1684a93c, 0xda2ea9a2, 0x030ebb0e,\n    0xcfa4bb90, 0x412bbc73, 0x8d81bced, 0x8744b5f4, 0x4beeb56a,\n    0xc561b289, 0x09cbb217, 0xac509190, 0x60fa910e, 0xee7596ed,\n    0x22df9673, 0x281a9f6a, 0xe4b09ff4, 0x6a3f9817, 0xa6959889,\n    0x7fb58a25, 0xb31f8abb, 0x3d908d58, 0xf13a8dc6, 0xfbff84df,\n    0x37558441, 0xb9da83a2, 0x7570833c, 0x533b85da, 0x9f918544,\n    0x111e82a7, 0xddb48239, 0xd7718b20, 0x1bdb8bbe, 0x95548c5d,\n    0x59fe8cc3, 0x80de9e6f, 0x4c749ef1, 0xc2fb9912, 0x0e51998c,\n    0x04949095, 0xc83e900b, 0x46b197e8, 0x8a1b9776, 0x2f80b4f1,\n    0xe32ab46f, 0x6da5b38c, 0xa10fb312, 0xabcaba0b, 0x6760ba95,\n    0xe9efbd76, 0x2545bde8, 0xfc65af44, 0x30cfafda, 0xbe40a839,\n    0x72eaa8a7, 0x782fa1be, 0xb485a120, 0x3a0aa6c3, 0xf6a0a65d,\n    0xaa4de78c, 0x66e7e712, 0xe868e0f1, 0x24c2e06f, 0x2e07e976,\n    0xe2ade9e8, 0x6c22ee0b, 0xa088ee95, 0x79a8fc39, 0xb502fca7,\n    0x3b8dfb44, 0xf727fbda, 0xfde2f2c3, 0x3148f25d, 0xbfc7f5be,\n    0x736df520, 0xd6f6d6a7, 0x1a5cd639, 0x94d3d1da, 0x5879d144,\n    0x52bcd85d, 0x9e16d8c3, 0x1099df20, 0xdc33dfbe, 0x0513cd12,\n    0xc9b9cd8c, 0x4736ca6f, 0x8b9ccaf1, 0x8159c3e8, 0x4df3c376,\n    0xc37cc495, 0x0fd6c40b, 0x7aa64737, 0xb60c47a9, 0x3883404a,\n    0xf42940d4, 0xfeec49cd, 0x32464953, 0xbcc94eb0, 0x70634e2e,\n    0xa9435c82, 0x65e95c1c, 0xeb665bff, 0x27cc5b61, 0x2d095278,\n    0xe1a352e6, 0x6f2c5505, 0xa386559b, 0x061d761c, 0xcab77682,\n    0x44387161, 0x889271ff, 0x825778e6, 0x4efd7878, 0xc0727f9b,\n    0x0cd87f05, 0xd5f86da9, 0x19526d37, 0x97dd6ad4, 0x5b776a4a,\n    0x51b26353, 0x9d1863cd, 0x1397642e, 0xdf3d64b0, 0x83d02561,\n    0x4f7a25ff, 0xc1f5221c, 0x0d5f2282, 0x079a2b9b, 0xcb302b05,\n    0x45bf2ce6, 0x89152c78, 0x50353ed4, 0x9c9f3e4a, 0x121039a9,\n    0xdeba3937, 0xd47f302e, 0x18d530b0, 0x965a3753, 0x5af037cd,\n    0xff6b144a, 0x33c114d4, 0xbd4e1337, 0x71e413a9, 0x7b211ab0,\n    0xb78b1a2e, 0x39041dcd, 0xf5ae1d53, 0x2c8e0fff, 0xe0240f61,\n    0x6eab0882, 0xa201081c, 0xa8c40105, 0x646e019b, 0xeae10678,\n    0x264b06e6},\n   {0x00000000, 0xa6770bb4, 0x979f1129, 0x31e81a9d, 0xf44f2413,\n    0x52382fa7, 0x63d0353a, 0xc5a73e8e, 0x33ef4e67, 0x959845d3,\n    0xa4705f4e, 0x020754fa, 0xc7a06a74, 0x61d761c0, 0x503f7b5d,\n    0xf64870e9, 0x67de9cce, 0xc1a9977a, 0xf0418de7, 0x56368653,\n    0x9391b8dd, 0x35e6b369, 0x040ea9f4, 0xa279a240, 0x5431d2a9,\n    0xf246d91d, 0xc3aec380, 0x65d9c834, 0xa07ef6ba, 0x0609fd0e,\n    0x37e1e793, 0x9196ec27, 0xcfbd399c, 0x69ca3228, 0x582228b5,\n    0xfe552301, 0x3bf21d8f, 0x9d85163b, 0xac6d0ca6, 0x0a1a0712,\n    0xfc5277fb, 0x5a257c4f, 0x6bcd66d2, 0xcdba6d66, 0x081d53e8,\n    0xae6a585c, 0x9f8242c1, 0x39f54975, 0xa863a552, 0x0e14aee6,\n    0x3ffcb47b, 0x998bbfcf, 0x5c2c8141, 0xfa5b8af5, 0xcbb39068,\n    0x6dc49bdc, 0x9b8ceb35, 0x3dfbe081, 0x0c13fa1c, 0xaa64f1a8,\n    0x6fc3cf26, 0xc9b4c492, 0xf85cde0f, 0x5e2bd5bb, 0x440b7579,\n    0xe27c7ecd, 0xd3946450, 0x75e36fe4, 0xb044516a, 0x16335ade,\n    0x27db4043, 0x81ac4bf7, 0x77e43b1e, 0xd19330aa, 0xe07b2a37,\n    0x460c2183, 0x83ab1f0d, 0x25dc14b9, 0x14340e24, 0xb2430590,\n    0x23d5e9b7, 0x85a2e203, 0xb44af89e, 0x123df32a, 0xd79acda4,\n    0x71edc610, 0x4005dc8d, 0xe672d739, 0x103aa7d0, 0xb64dac64,\n    0x87a5b6f9, 0x21d2bd4d, 0xe47583c3, 0x42028877, 0x73ea92ea,\n    0xd59d995e, 0x8bb64ce5, 0x2dc14751, 0x1c295dcc, 0xba5e5678,\n    0x7ff968f6, 0xd98e6342, 0xe86679df, 0x4e11726b, 0xb8590282,\n    0x1e2e0936, 0x2fc613ab, 0x89b1181f, 0x4c162691, 0xea612d25,\n    0xdb8937b8, 0x7dfe3c0c, 0xec68d02b, 0x4a1fdb9f, 0x7bf7c102,\n    0xdd80cab6, 0x1827f438, 0xbe50ff8c, 0x8fb8e511, 0x29cfeea5,\n    0xdf879e4c, 0x79f095f8, 0x48188f65, 0xee6f84d1, 0x2bc8ba5f,\n    0x8dbfb1eb, 0xbc57ab76, 0x1a20a0c2, 0x8816eaf2, 0x2e61e146,\n    0x1f89fbdb, 0xb9fef06f, 0x7c59cee1, 0xda2ec555, 0xebc6dfc8,\n    0x4db1d47c, 0xbbf9a495, 0x1d8eaf21, 0x2c66b5bc, 0x8a11be08,\n    0x4fb68086, 0xe9c18b32, 0xd82991af, 0x7e5e9a1b, 0xefc8763c,\n    0x49bf7d88, 0x78576715, 0xde206ca1, 0x1b87522f, 0xbdf0599b,\n    0x8c184306, 0x2a6f48b2, 0xdc27385b, 0x7a5033ef, 0x4bb82972,\n    0xedcf22c6, 0x28681c48, 0x8e1f17fc, 0xbff70d61, 0x198006d5,\n    0x47abd36e, 0xe1dcd8da, 0xd034c247, 0x7643c9f3, 0xb3e4f77d,\n    0x1593fcc9, 0x247be654, 0x820cede0, 0x74449d09, 0xd23396bd,\n    0xe3db8c20, 0x45ac8794, 0x800bb91a, 0x267cb2ae, 0x1794a833,\n    0xb1e3a387, 0x20754fa0, 0x86024414, 0xb7ea5e89, 0x119d553d,\n    0xd43a6bb3, 0x724d6007, 0x43a57a9a, 0xe5d2712e, 0x139a01c7,\n    0xb5ed0a73, 0x840510ee, 0x22721b5a, 0xe7d525d4, 0x41a22e60,\n    0x704a34fd, 0xd63d3f49, 0xcc1d9f8b, 0x6a6a943f, 0x5b828ea2,\n    0xfdf58516, 0x3852bb98, 0x9e25b02c, 0xafcdaab1, 0x09baa105,\n    0xfff2d1ec, 0x5985da58, 0x686dc0c5, 0xce1acb71, 0x0bbdf5ff,\n    0xadcafe4b, 0x9c22e4d6, 0x3a55ef62, 0xabc30345, 0x0db408f1,\n    0x3c5c126c, 0x9a2b19d8, 0x5f8c2756, 0xf9fb2ce2, 0xc813367f,\n    0x6e643dcb, 0x982c4d22, 0x3e5b4696, 0x0fb35c0b, 0xa9c457bf,\n    0x6c636931, 0xca146285, 0xfbfc7818, 0x5d8b73ac, 0x03a0a617,\n    0xa5d7ada3, 0x943fb73e, 0x3248bc8a, 0xf7ef8204, 0x519889b0,\n    0x6070932d, 0xc6079899, 0x304fe870, 0x9638e3c4, 0xa7d0f959,\n    0x01a7f2ed, 0xc400cc63, 0x6277c7d7, 0x539fdd4a, 0xf5e8d6fe,\n    0x647e3ad9, 0xc209316d, 0xf3e12bf0, 0x55962044, 0x90311eca,\n    0x3646157e, 0x07ae0fe3, 0xa1d90457, 0x579174be, 0xf1e67f0a,\n    0xc00e6597, 0x66796e23, 0xa3de50ad, 0x05a95b19, 0x34414184,\n    0x92364a30},\n   {0x00000000, 0xcb5cd3a5, 0x4dc8a10b, 0x869472ae, 0x9b914216,\n    0x50cd91b3, 0xd659e31d, 0x1d0530b8, 0xec53826d, 0x270f51c8,\n    0xa19b2366, 0x6ac7f0c3, 0x77c2c07b, 0xbc9e13de, 0x3a0a6170,\n    0xf156b2d5, 0x03d6029b, 0xc88ad13e, 0x4e1ea390, 0x85427035,\n    0x9847408d, 0x531b9328, 0xd58fe186, 0x1ed33223, 0xef8580f6,\n    0x24d95353, 0xa24d21fd, 0x6911f258, 0x7414c2e0, 0xbf481145,\n    0x39dc63eb, 0xf280b04e, 0x07ac0536, 0xccf0d693, 0x4a64a43d,\n    0x81387798, 0x9c3d4720, 0x57619485, 0xd1f5e62b, 0x1aa9358e,\n    0xebff875b, 0x20a354fe, 0xa6372650, 0x6d6bf5f5, 0x706ec54d,\n    0xbb3216e8, 0x3da66446, 0xf6fab7e3, 0x047a07ad, 0xcf26d408,\n    0x49b2a6a6, 0x82ee7503, 0x9feb45bb, 0x54b7961e, 0xd223e4b0,\n    0x197f3715, 0xe82985c0, 0x23755665, 0xa5e124cb, 0x6ebdf76e,\n    0x73b8c7d6, 0xb8e41473, 0x3e7066dd, 0xf52cb578, 0x0f580a6c,\n    0xc404d9c9, 0x4290ab67, 0x89cc78c2, 0x94c9487a, 0x5f959bdf,\n    0xd901e971, 0x125d3ad4, 0xe30b8801, 0x28575ba4, 0xaec3290a,\n    0x659ffaaf, 0x789aca17, 0xb3c619b2, 0x35526b1c, 0xfe0eb8b9,\n    0x0c8e08f7, 0xc7d2db52, 0x4146a9fc, 0x8a1a7a59, 0x971f4ae1,\n    0x5c439944, 0xdad7ebea, 0x118b384f, 0xe0dd8a9a, 0x2b81593f,\n    0xad152b91, 0x6649f834, 0x7b4cc88c, 0xb0101b29, 0x36846987,\n    0xfdd8ba22, 0x08f40f5a, 0xc3a8dcff, 0x453cae51, 0x8e607df4,\n    0x93654d4c, 0x58399ee9, 0xdeadec47, 0x15f13fe2, 0xe4a78d37,\n    0x2ffb5e92, 0xa96f2c3c, 0x6233ff99, 0x7f36cf21, 0xb46a1c84,\n    0x32fe6e2a, 0xf9a2bd8f, 0x0b220dc1, 0xc07ede64, 0x46eaacca,\n    0x8db67f6f, 0x90b34fd7, 0x5bef9c72, 0xdd7beedc, 0x16273d79,\n    0xe7718fac, 0x2c2d5c09, 0xaab92ea7, 0x61e5fd02, 0x7ce0cdba,\n    0xb7bc1e1f, 0x31286cb1, 0xfa74bf14, 0x1eb014d8, 0xd5ecc77d,\n    0x5378b5d3, 0x98246676, 0x852156ce, 0x4e7d856b, 0xc8e9f7c5,\n    0x03b52460, 0xf2e396b5, 0x39bf4510, 0xbf2b37be, 0x7477e41b,\n    0x6972d4a3, 0xa22e0706, 0x24ba75a8, 0xefe6a60d, 0x1d661643,\n    0xd63ac5e6, 0x50aeb748, 0x9bf264ed, 0x86f75455, 0x4dab87f0,\n    0xcb3ff55e, 0x006326fb, 0xf135942e, 0x3a69478b, 0xbcfd3525,\n    0x77a1e680, 0x6aa4d638, 0xa1f8059d, 0x276c7733, 0xec30a496,\n    0x191c11ee, 0xd240c24b, 0x54d4b0e5, 0x9f886340, 0x828d53f8,\n    0x49d1805d, 0xcf45f2f3, 0x04192156, 0xf54f9383, 0x3e134026,\n    0xb8873288, 0x73dbe12d, 0x6eded195, 0xa5820230, 0x2316709e,\n    0xe84aa33b, 0x1aca1375, 0xd196c0d0, 0x5702b27e, 0x9c5e61db,\n    0x815b5163, 0x4a0782c6, 0xcc93f068, 0x07cf23cd, 0xf6999118,\n    0x3dc542bd, 0xbb513013, 0x700de3b6, 0x6d08d30e, 0xa65400ab,\n    0x20c07205, 0xeb9ca1a0, 0x11e81eb4, 0xdab4cd11, 0x5c20bfbf,\n    0x977c6c1a, 0x8a795ca2, 0x41258f07, 0xc7b1fda9, 0x0ced2e0c,\n    0xfdbb9cd9, 0x36e74f7c, 0xb0733dd2, 0x7b2fee77, 0x662adecf,\n    0xad760d6a, 0x2be27fc4, 0xe0beac61, 0x123e1c2f, 0xd962cf8a,\n    0x5ff6bd24, 0x94aa6e81, 0x89af5e39, 0x42f38d9c, 0xc467ff32,\n    0x0f3b2c97, 0xfe6d9e42, 0x35314de7, 0xb3a53f49, 0x78f9ecec,\n    0x65fcdc54, 0xaea00ff1, 0x28347d5f, 0xe368aefa, 0x16441b82,\n    0xdd18c827, 0x5b8cba89, 0x90d0692c, 0x8dd55994, 0x46898a31,\n    0xc01df89f, 0x0b412b3a, 0xfa1799ef, 0x314b4a4a, 0xb7df38e4,\n    0x7c83eb41, 0x6186dbf9, 0xaada085c, 0x2c4e7af2, 0xe712a957,\n    0x15921919, 0xdececabc, 0x585ab812, 0x93066bb7, 0x8e035b0f,\n    0x455f88aa, 0xc3cbfa04, 0x089729a1, 0xf9c19b74, 0x329d48d1,\n    0xb4093a7f, 0x7f55e9da, 0x6250d962, 0xa90c0ac7, 0x2f987869,\n    0xe4c4abcc},\n   {0x00000000, 0x3d6029b0, 0x7ac05360, 0x47a07ad0, 0xf580a6c0,\n    0xc8e08f70, 0x8f40f5a0, 0xb220dc10, 0x30704bc1, 0x0d106271,\n    0x4ab018a1, 0x77d03111, 0xc5f0ed01, 0xf890c4b1, 0xbf30be61,\n    0x825097d1, 0x60e09782, 0x5d80be32, 0x1a20c4e2, 0x2740ed52,\n    0x95603142, 0xa80018f2, 0xefa06222, 0xd2c04b92, 0x5090dc43,\n    0x6df0f5f3, 0x2a508f23, 0x1730a693, 0xa5107a83, 0x98705333,\n    0xdfd029e3, 0xe2b00053, 0xc1c12f04, 0xfca106b4, 0xbb017c64,\n    0x866155d4, 0x344189c4, 0x0921a074, 0x4e81daa4, 0x73e1f314,\n    0xf1b164c5, 0xccd14d75, 0x8b7137a5, 0xb6111e15, 0x0431c205,\n    0x3951ebb5, 0x7ef19165, 0x4391b8d5, 0xa121b886, 0x9c419136,\n    0xdbe1ebe6, 0xe681c256, 0x54a11e46, 0x69c137f6, 0x2e614d26,\n    0x13016496, 0x9151f347, 0xac31daf7, 0xeb91a027, 0xd6f18997,\n    0x64d15587, 0x59b17c37, 0x1e1106e7, 0x23712f57, 0x58f35849,\n    0x659371f9, 0x22330b29, 0x1f532299, 0xad73fe89, 0x9013d739,\n    0xd7b3ade9, 0xead38459, 0x68831388, 0x55e33a38, 0x124340e8,\n    0x2f236958, 0x9d03b548, 0xa0639cf8, 0xe7c3e628, 0xdaa3cf98,\n    0x3813cfcb, 0x0573e67b, 0x42d39cab, 0x7fb3b51b, 0xcd93690b,\n    0xf0f340bb, 0xb7533a6b, 0x8a3313db, 0x0863840a, 0x3503adba,\n    0x72a3d76a, 0x4fc3feda, 0xfde322ca, 0xc0830b7a, 0x872371aa,\n    0xba43581a, 0x9932774d, 0xa4525efd, 0xe3f2242d, 0xde920d9d,\n    0x6cb2d18d, 0x51d2f83d, 0x167282ed, 0x2b12ab5d, 0xa9423c8c,\n    0x9422153c, 0xd3826fec, 0xeee2465c, 0x5cc29a4c, 0x61a2b3fc,\n    0x2602c92c, 0x1b62e09c, 0xf9d2e0cf, 0xc4b2c97f, 0x8312b3af,\n    0xbe729a1f, 0x0c52460f, 0x31326fbf, 0x7692156f, 0x4bf23cdf,\n    0xc9a2ab0e, 0xf4c282be, 0xb362f86e, 0x8e02d1de, 0x3c220dce,\n    0x0142247e, 0x46e25eae, 0x7b82771e, 0xb1e6b092, 0x8c869922,\n    0xcb26e3f2, 0xf646ca42, 0x44661652, 0x79063fe2, 0x3ea64532,\n    0x03c66c82, 0x8196fb53, 0xbcf6d2e3, 0xfb56a833, 0xc6368183,\n    0x74165d93, 0x49767423, 0x0ed60ef3, 0x33b62743, 0xd1062710,\n    0xec660ea0, 0xabc67470, 0x96a65dc0, 0x248681d0, 0x19e6a860,\n    0x5e46d2b0, 0x6326fb00, 0xe1766cd1, 0xdc164561, 0x9bb63fb1,\n    0xa6d61601, 0x14f6ca11, 0x2996e3a1, 0x6e369971, 0x5356b0c1,\n    0x70279f96, 0x4d47b626, 0x0ae7ccf6, 0x3787e546, 0x85a73956,\n    0xb8c710e6, 0xff676a36, 0xc2074386, 0x4057d457, 0x7d37fde7,\n    0x3a978737, 0x07f7ae87, 0xb5d77297, 0x88b75b27, 0xcf1721f7,\n    0xf2770847, 0x10c70814, 0x2da721a4, 0x6a075b74, 0x576772c4,\n    0xe547aed4, 0xd8278764, 0x9f87fdb4, 0xa2e7d404, 0x20b743d5,\n    0x1dd76a65, 0x5a7710b5, 0x67173905, 0xd537e515, 0xe857cca5,\n    0xaff7b675, 0x92979fc5, 0xe915e8db, 0xd475c16b, 0x93d5bbbb,\n    0xaeb5920b, 0x1c954e1b, 0x21f567ab, 0x66551d7b, 0x5b3534cb,\n    0xd965a31a, 0xe4058aaa, 0xa3a5f07a, 0x9ec5d9ca, 0x2ce505da,\n    0x11852c6a, 0x562556ba, 0x6b457f0a, 0x89f57f59, 0xb49556e9,\n    0xf3352c39, 0xce550589, 0x7c75d999, 0x4115f029, 0x06b58af9,\n    0x3bd5a349, 0xb9853498, 0x84e51d28, 0xc34567f8, 0xfe254e48,\n    0x4c059258, 0x7165bbe8, 0x36c5c138, 0x0ba5e888, 0x28d4c7df,\n    0x15b4ee6f, 0x521494bf, 0x6f74bd0f, 0xdd54611f, 0xe03448af,\n    0xa794327f, 0x9af41bcf, 0x18a48c1e, 0x25c4a5ae, 0x6264df7e,\n    0x5f04f6ce, 0xed242ade, 0xd044036e, 0x97e479be, 0xaa84500e,\n    0x4834505d, 0x755479ed, 0x32f4033d, 0x0f942a8d, 0xbdb4f69d,\n    0x80d4df2d, 0xc774a5fd, 0xfa148c4d, 0x78441b9c, 0x4524322c,\n    0x028448fc, 0x3fe4614c, 0x8dc4bd5c, 0xb0a494ec, 0xf704ee3c,\n    0xca64c78c}};\n\nlocal const z_word_t FAR crc_braid_big_table[][256] = {\n   {0x00000000, 0xb029603d, 0x6053c07a, 0xd07aa047, 0xc0a680f5,\n    0x708fe0c8, 0xa0f5408f, 0x10dc20b2, 0xc14b7030, 0x7162100d,\n    0xa118b04a, 0x1131d077, 0x01edf0c5, 0xb1c490f8, 0x61be30bf,\n    0xd1975082, 0x8297e060, 0x32be805d, 0xe2c4201a, 0x52ed4027,\n    0x42316095, 0xf21800a8, 0x2262a0ef, 0x924bc0d2, 0x43dc9050,\n    0xf3f5f06d, 0x238f502a, 0x93a63017, 0x837a10a5, 0x33537098,\n    0xe329d0df, 0x5300b0e2, 0x042fc1c1, 0xb406a1fc, 0x647c01bb,\n    0xd4556186, 0xc4894134, 0x74a02109, 0xa4da814e, 0x14f3e173,\n    0xc564b1f1, 0x754dd1cc, 0xa537718b, 0x151e11b6, 0x05c23104,\n    0xb5eb5139, 0x6591f17e, 0xd5b89143, 0x86b821a1, 0x3691419c,\n    0xe6ebe1db, 0x56c281e6, 0x461ea154, 0xf637c169, 0x264d612e,\n    0x96640113, 0x47f35191, 0xf7da31ac, 0x27a091eb, 0x9789f1d6,\n    0x8755d164, 0x377cb159, 0xe706111e, 0x572f7123, 0x4958f358,\n    0xf9719365, 0x290b3322, 0x9922531f, 0x89fe73ad, 0x39d71390,\n    0xe9adb3d7, 0x5984d3ea, 0x88138368, 0x383ae355, 0xe8404312,\n    0x5869232f, 0x48b5039d, 0xf89c63a0, 0x28e6c3e7, 0x98cfa3da,\n    0xcbcf1338, 0x7be67305, 0xab9cd342, 0x1bb5b37f, 0x0b6993cd,\n    0xbb40f3f0, 0x6b3a53b7, 0xdb13338a, 0x0a846308, 0xbaad0335,\n    0x6ad7a372, 0xdafec34f, 0xca22e3fd, 0x7a0b83c0, 0xaa712387,\n    0x1a5843ba, 0x4d773299, 0xfd5e52a4, 0x2d24f2e3, 0x9d0d92de,\n    0x8dd1b26c, 0x3df8d251, 0xed827216, 0x5dab122b, 0x8c3c42a9,\n    0x3c152294, 0xec6f82d3, 0x5c46e2ee, 0x4c9ac25c, 0xfcb3a261,\n    0x2cc90226, 0x9ce0621b, 0xcfe0d2f9, 0x7fc9b2c4, 0xafb31283,\n    0x1f9a72be, 0x0f46520c, 0xbf6f3231, 0x6f159276, 0xdf3cf24b,\n    0x0eaba2c9, 0xbe82c2f4, 0x6ef862b3, 0xded1028e, 0xce0d223c,\n    0x7e244201, 0xae5ee246, 0x1e77827b, 0x92b0e6b1, 0x2299868c,\n    0xf2e326cb, 0x42ca46f6, 0x52166644, 0xe23f0679, 0x3245a63e,\n    0x826cc603, 0x53fb9681, 0xe3d2f6bc, 0x33a856fb, 0x838136c6,\n    0x935d1674, 0x23747649, 0xf30ed60e, 0x4327b633, 0x102706d1,\n    0xa00e66ec, 0x7074c6ab, 0xc05da696, 0xd0818624, 0x60a8e619,\n    0xb0d2465e, 0x00fb2663, 0xd16c76e1, 0x614516dc, 0xb13fb69b,\n    0x0116d6a6, 0x11caf614, 0xa1e39629, 0x7199366e, 0xc1b05653,\n    0x969f2770, 0x26b6474d, 0xf6cce70a, 0x46e58737, 0x5639a785,\n    0xe610c7b8, 0x366a67ff, 0x864307c2, 0x57d45740, 0xe7fd377d,\n    0x3787973a, 0x87aef707, 0x9772d7b5, 0x275bb788, 0xf72117cf,\n    0x470877f2, 0x1408c710, 0xa421a72d, 0x745b076a, 0xc4726757,\n    0xd4ae47e5, 0x648727d8, 0xb4fd879f, 0x04d4e7a2, 0xd543b720,\n    0x656ad71d, 0xb510775a, 0x05391767, 0x15e537d5, 0xa5cc57e8,\n    0x75b6f7af, 0xc59f9792, 0xdbe815e9, 0x6bc175d4, 0xbbbbd593,\n    0x0b92b5ae, 0x1b4e951c, 0xab67f521, 0x7b1d5566, 0xcb34355b,\n    0x1aa365d9, 0xaa8a05e4, 0x7af0a5a3, 0xcad9c59e, 0xda05e52c,\n    0x6a2c8511, 0xba562556, 0x0a7f456b, 0x597ff589, 0xe95695b4,\n    0x392c35f3, 0x890555ce, 0x99d9757c, 0x29f01541, 0xf98ab506,\n    0x49a3d53b, 0x983485b9, 0x281de584, 0xf86745c3, 0x484e25fe,\n    0x5892054c, 0xe8bb6571, 0x38c1c536, 0x88e8a50b, 0xdfc7d428,\n    0x6feeb415, 0xbf941452, 0x0fbd746f, 0x1f6154dd, 0xaf4834e0,\n    0x7f3294a7, 0xcf1bf49a, 0x1e8ca418, 0xaea5c425, 0x7edf6462,\n    0xcef6045f, 0xde2a24ed, 0x6e0344d0, 0xbe79e497, 0x0e5084aa,\n    0x5d503448, 0xed795475, 0x3d03f432, 0x8d2a940f, 0x9df6b4bd,\n    0x2ddfd480, 0xfda574c7, 0x4d8c14fa, 0x9c1b4478, 0x2c322445,\n    0xfc488402, 0x4c61e43f, 0x5cbdc48d, 0xec94a4b0, 0x3cee04f7,\n    0x8cc764ca},\n   {0x00000000, 0xa5d35ccb, 0x0ba1c84d, 0xae729486, 0x1642919b,\n    0xb391cd50, 0x1de359d6, 0xb830051d, 0x6d8253ec, 0xc8510f27,\n    0x66239ba1, 0xc3f0c76a, 0x7bc0c277, 0xde139ebc, 0x70610a3a,\n    0xd5b256f1, 0x9b02d603, 0x3ed18ac8, 0x90a31e4e, 0x35704285,\n    0x8d404798, 0x28931b53, 0x86e18fd5, 0x2332d31e, 0xf68085ef,\n    0x5353d924, 0xfd214da2, 0x58f21169, 0xe0c21474, 0x451148bf,\n    0xeb63dc39, 0x4eb080f2, 0x3605ac07, 0x93d6f0cc, 0x3da4644a,\n    0x98773881, 0x20473d9c, 0x85946157, 0x2be6f5d1, 0x8e35a91a,\n    0x5b87ffeb, 0xfe54a320, 0x502637a6, 0xf5f56b6d, 0x4dc56e70,\n    0xe81632bb, 0x4664a63d, 0xe3b7faf6, 0xad077a04, 0x08d426cf,\n    0xa6a6b249, 0x0375ee82, 0xbb45eb9f, 0x1e96b754, 0xb0e423d2,\n    0x15377f19, 0xc08529e8, 0x65567523, 0xcb24e1a5, 0x6ef7bd6e,\n    0xd6c7b873, 0x7314e4b8, 0xdd66703e, 0x78b52cf5, 0x6c0a580f,\n    0xc9d904c4, 0x67ab9042, 0xc278cc89, 0x7a48c994, 0xdf9b955f,\n    0x71e901d9, 0xd43a5d12, 0x01880be3, 0xa45b5728, 0x0a29c3ae,\n    0xaffa9f65, 0x17ca9a78, 0xb219c6b3, 0x1c6b5235, 0xb9b80efe,\n    0xf7088e0c, 0x52dbd2c7, 0xfca94641, 0x597a1a8a, 0xe14a1f97,\n    0x4499435c, 0xeaebd7da, 0x4f388b11, 0x9a8adde0, 0x3f59812b,\n    0x912b15ad, 0x34f84966, 0x8cc84c7b, 0x291b10b0, 0x87698436,\n    0x22bad8fd, 0x5a0ff408, 0xffdca8c3, 0x51ae3c45, 0xf47d608e,\n    0x4c4d6593, 0xe99e3958, 0x47ecadde, 0xe23ff115, 0x378da7e4,\n    0x925efb2f, 0x3c2c6fa9, 0x99ff3362, 0x21cf367f, 0x841c6ab4,\n    0x2a6efe32, 0x8fbda2f9, 0xc10d220b, 0x64de7ec0, 0xcaacea46,\n    0x6f7fb68d, 0xd74fb390, 0x729cef5b, 0xdcee7bdd, 0x793d2716,\n    0xac8f71e7, 0x095c2d2c, 0xa72eb9aa, 0x02fde561, 0xbacde07c,\n    0x1f1ebcb7, 0xb16c2831, 0x14bf74fa, 0xd814b01e, 0x7dc7ecd5,\n    0xd3b57853, 0x76662498, 0xce562185, 0x6b857d4e, 0xc5f7e9c8,\n    0x6024b503, 0xb596e3f2, 0x1045bf39, 0xbe372bbf, 0x1be47774,\n    0xa3d47269, 0x06072ea2, 0xa875ba24, 0x0da6e6ef, 0x4316661d,\n    0xe6c53ad6, 0x48b7ae50, 0xed64f29b, 0x5554f786, 0xf087ab4d,\n    0x5ef53fcb, 0xfb266300, 0x2e9435f1, 0x8b47693a, 0x2535fdbc,\n    0x80e6a177, 0x38d6a46a, 0x9d05f8a1, 0x33776c27, 0x96a430ec,\n    0xee111c19, 0x4bc240d2, 0xe5b0d454, 0x4063889f, 0xf8538d82,\n    0x5d80d149, 0xf3f245cf, 0x56211904, 0x83934ff5, 0x2640133e,\n    0x883287b8, 0x2de1db73, 0x95d1de6e, 0x300282a5, 0x9e701623,\n    0x3ba34ae8, 0x7513ca1a, 0xd0c096d1, 0x7eb20257, 0xdb615e9c,\n    0x63515b81, 0xc682074a, 0x68f093cc, 0xcd23cf07, 0x189199f6,\n    0xbd42c53d, 0x133051bb, 0xb6e30d70, 0x0ed3086d, 0xab0054a6,\n    0x0572c020, 0xa0a19ceb, 0xb41ee811, 0x11cdb4da, 0xbfbf205c,\n    0x1a6c7c97, 0xa25c798a, 0x078f2541, 0xa9fdb1c7, 0x0c2eed0c,\n    0xd99cbbfd, 0x7c4fe736, 0xd23d73b0, 0x77ee2f7b, 0xcfde2a66,\n    0x6a0d76ad, 0xc47fe22b, 0x61acbee0, 0x2f1c3e12, 0x8acf62d9,\n    0x24bdf65f, 0x816eaa94, 0x395eaf89, 0x9c8df342, 0x32ff67c4,\n    0x972c3b0f, 0x429e6dfe, 0xe74d3135, 0x493fa5b3, 0xececf978,\n    0x54dcfc65, 0xf10fa0ae, 0x5f7d3428, 0xfaae68e3, 0x821b4416,\n    0x27c818dd, 0x89ba8c5b, 0x2c69d090, 0x9459d58d, 0x318a8946,\n    0x9ff81dc0, 0x3a2b410b, 0xef9917fa, 0x4a4a4b31, 0xe438dfb7,\n    0x41eb837c, 0xf9db8661, 0x5c08daaa, 0xf27a4e2c, 0x57a912e7,\n    0x19199215, 0xbccacede, 0x12b85a58, 0xb76b0693, 0x0f5b038e,\n    0xaa885f45, 0x04facbc3, 0xa1299708, 0x749bc1f9, 0xd1489d32,\n    0x7f3a09b4, 0xdae9557f, 0x62d95062, 0xc70a0ca9, 0x6978982f,\n    0xccabc4e4},\n   {0x00000000, 0xb40b77a6, 0x29119f97, 0x9d1ae831, 0x13244ff4,\n    0xa72f3852, 0x3a35d063, 0x8e3ea7c5, 0x674eef33, 0xd3459895,\n    0x4e5f70a4, 0xfa540702, 0x746aa0c7, 0xc061d761, 0x5d7b3f50,\n    0xe97048f6, 0xce9cde67, 0x7a97a9c1, 0xe78d41f0, 0x53863656,\n    0xddb89193, 0x69b3e635, 0xf4a90e04, 0x40a279a2, 0xa9d23154,\n    0x1dd946f2, 0x80c3aec3, 0x34c8d965, 0xbaf67ea0, 0x0efd0906,\n    0x93e7e137, 0x27ec9691, 0x9c39bdcf, 0x2832ca69, 0xb5282258,\n    0x012355fe, 0x8f1df23b, 0x3b16859d, 0xa60c6dac, 0x12071a0a,\n    0xfb7752fc, 0x4f7c255a, 0xd266cd6b, 0x666dbacd, 0xe8531d08,\n    0x5c586aae, 0xc142829f, 0x7549f539, 0x52a563a8, 0xe6ae140e,\n    0x7bb4fc3f, 0xcfbf8b99, 0x41812c5c, 0xf58a5bfa, 0x6890b3cb,\n    0xdc9bc46d, 0x35eb8c9b, 0x81e0fb3d, 0x1cfa130c, 0xa8f164aa,\n    0x26cfc36f, 0x92c4b4c9, 0x0fde5cf8, 0xbbd52b5e, 0x79750b44,\n    0xcd7e7ce2, 0x506494d3, 0xe46fe375, 0x6a5144b0, 0xde5a3316,\n    0x4340db27, 0xf74bac81, 0x1e3be477, 0xaa3093d1, 0x372a7be0,\n    0x83210c46, 0x0d1fab83, 0xb914dc25, 0x240e3414, 0x900543b2,\n    0xb7e9d523, 0x03e2a285, 0x9ef84ab4, 0x2af33d12, 0xa4cd9ad7,\n    0x10c6ed71, 0x8ddc0540, 0x39d772e6, 0xd0a73a10, 0x64ac4db6,\n    0xf9b6a587, 0x4dbdd221, 0xc38375e4, 0x77880242, 0xea92ea73,\n    0x5e999dd5, 0xe54cb68b, 0x5147c12d, 0xcc5d291c, 0x78565eba,\n    0xf668f97f, 0x42638ed9, 0xdf7966e8, 0x6b72114e, 0x820259b8,\n    0x36092e1e, 0xab13c62f, 0x1f18b189, 0x9126164c, 0x252d61ea,\n    0xb83789db, 0x0c3cfe7d, 0x2bd068ec, 0x9fdb1f4a, 0x02c1f77b,\n    0xb6ca80dd, 0x38f42718, 0x8cff50be, 0x11e5b88f, 0xa5eecf29,\n    0x4c9e87df, 0xf895f079, 0x658f1848, 0xd1846fee, 0x5fbac82b,\n    0xebb1bf8d, 0x76ab57bc, 0xc2a0201a, 0xf2ea1688, 0x46e1612e,\n    0xdbfb891f, 0x6ff0feb9, 0xe1ce597c, 0x55c52eda, 0xc8dfc6eb,\n    0x7cd4b14d, 0x95a4f9bb, 0x21af8e1d, 0xbcb5662c, 0x08be118a,\n    0x8680b64f, 0x328bc1e9, 0xaf9129d8, 0x1b9a5e7e, 0x3c76c8ef,\n    0x887dbf49, 0x15675778, 0xa16c20de, 0x2f52871b, 0x9b59f0bd,\n    0x0643188c, 0xb2486f2a, 0x5b3827dc, 0xef33507a, 0x7229b84b,\n    0xc622cfed, 0x481c6828, 0xfc171f8e, 0x610df7bf, 0xd5068019,\n    0x6ed3ab47, 0xdad8dce1, 0x47c234d0, 0xf3c94376, 0x7df7e4b3,\n    0xc9fc9315, 0x54e67b24, 0xe0ed0c82, 0x099d4474, 0xbd9633d2,\n    0x208cdbe3, 0x9487ac45, 0x1ab90b80, 0xaeb27c26, 0x33a89417,\n    0x87a3e3b1, 0xa04f7520, 0x14440286, 0x895eeab7, 0x3d559d11,\n    0xb36b3ad4, 0x07604d72, 0x9a7aa543, 0x2e71d2e5, 0xc7019a13,\n    0x730aedb5, 0xee100584, 0x5a1b7222, 0xd425d5e7, 0x602ea241,\n    0xfd344a70, 0x493f3dd6, 0x8b9f1dcc, 0x3f946a6a, 0xa28e825b,\n    0x1685f5fd, 0x98bb5238, 0x2cb0259e, 0xb1aacdaf, 0x05a1ba09,\n    0xecd1f2ff, 0x58da8559, 0xc5c06d68, 0x71cb1ace, 0xfff5bd0b,\n    0x4bfecaad, 0xd6e4229c, 0x62ef553a, 0x4503c3ab, 0xf108b40d,\n    0x6c125c3c, 0xd8192b9a, 0x56278c5f, 0xe22cfbf9, 0x7f3613c8,\n    0xcb3d646e, 0x224d2c98, 0x96465b3e, 0x0b5cb30f, 0xbf57c4a9,\n    0x3169636c, 0x856214ca, 0x1878fcfb, 0xac738b5d, 0x17a6a003,\n    0xa3add7a5, 0x3eb73f94, 0x8abc4832, 0x0482eff7, 0xb0899851,\n    0x2d937060, 0x999807c6, 0x70e84f30, 0xc4e33896, 0x59f9d0a7,\n    0xedf2a701, 0x63cc00c4, 0xd7c77762, 0x4add9f53, 0xfed6e8f5,\n    0xd93a7e64, 0x6d3109c2, 0xf02be1f3, 0x44209655, 0xca1e3190,\n    0x7e154636, 0xe30fae07, 0x5704d9a1, 0xbe749157, 0x0a7fe6f1,\n    0x97650ec0, 0x236e7966, 0xad50dea3, 0x195ba905, 0x84414134,\n    0x304a3692},\n   {0x00000000, 0x9e00aacc, 0x7d072542, 0xe3078f8e, 0xfa0e4a84,\n    0x640ee048, 0x87096fc6, 0x1909c50a, 0xb51be5d3, 0x2b1b4f1f,\n    0xc81cc091, 0x561c6a5d, 0x4f15af57, 0xd115059b, 0x32128a15,\n    0xac1220d9, 0x2b31bb7c, 0xb53111b0, 0x56369e3e, 0xc83634f2,\n    0xd13ff1f8, 0x4f3f5b34, 0xac38d4ba, 0x32387e76, 0x9e2a5eaf,\n    0x002af463, 0xe32d7bed, 0x7d2dd121, 0x6424142b, 0xfa24bee7,\n    0x19233169, 0x87239ba5, 0x566276f9, 0xc862dc35, 0x2b6553bb,\n    0xb565f977, 0xac6c3c7d, 0x326c96b1, 0xd16b193f, 0x4f6bb3f3,\n    0xe379932a, 0x7d7939e6, 0x9e7eb668, 0x007e1ca4, 0x1977d9ae,\n    0x87777362, 0x6470fcec, 0xfa705620, 0x7d53cd85, 0xe3536749,\n    0x0054e8c7, 0x9e54420b, 0x875d8701, 0x195d2dcd, 0xfa5aa243,\n    0x645a088f, 0xc8482856, 0x5648829a, 0xb54f0d14, 0x2b4fa7d8,\n    0x324662d2, 0xac46c81e, 0x4f414790, 0xd141ed5c, 0xedc29d29,\n    0x73c237e5, 0x90c5b86b, 0x0ec512a7, 0x17ccd7ad, 0x89cc7d61,\n    0x6acbf2ef, 0xf4cb5823, 0x58d978fa, 0xc6d9d236, 0x25de5db8,\n    0xbbdef774, 0xa2d7327e, 0x3cd798b2, 0xdfd0173c, 0x41d0bdf0,\n    0xc6f32655, 0x58f38c99, 0xbbf40317, 0x25f4a9db, 0x3cfd6cd1,\n    0xa2fdc61d, 0x41fa4993, 0xdffae35f, 0x73e8c386, 0xede8694a,\n    0x0eefe6c4, 0x90ef4c08, 0x89e68902, 0x17e623ce, 0xf4e1ac40,\n    0x6ae1068c, 0xbba0ebd0, 0x25a0411c, 0xc6a7ce92, 0x58a7645e,\n    0x41aea154, 0xdfae0b98, 0x3ca98416, 0xa2a92eda, 0x0ebb0e03,\n    0x90bba4cf, 0x73bc2b41, 0xedbc818d, 0xf4b54487, 0x6ab5ee4b,\n    0x89b261c5, 0x17b2cb09, 0x909150ac, 0x0e91fa60, 0xed9675ee,\n    0x7396df22, 0x6a9f1a28, 0xf49fb0e4, 0x17983f6a, 0x899895a6,\n    0x258ab57f, 0xbb8a1fb3, 0x588d903d, 0xc68d3af1, 0xdf84fffb,\n    0x41845537, 0xa283dab9, 0x3c837075, 0xda853b53, 0x4485919f,\n    0xa7821e11, 0x3982b4dd, 0x208b71d7, 0xbe8bdb1b, 0x5d8c5495,\n    0xc38cfe59, 0x6f9ede80, 0xf19e744c, 0x1299fbc2, 0x8c99510e,\n    0x95909404, 0x0b903ec8, 0xe897b146, 0x76971b8a, 0xf1b4802f,\n    0x6fb42ae3, 0x8cb3a56d, 0x12b30fa1, 0x0bbacaab, 0x95ba6067,\n    0x76bdefe9, 0xe8bd4525, 0x44af65fc, 0xdaafcf30, 0x39a840be,\n    0xa7a8ea72, 0xbea12f78, 0x20a185b4, 0xc3a60a3a, 0x5da6a0f6,\n    0x8ce74daa, 0x12e7e766, 0xf1e068e8, 0x6fe0c224, 0x76e9072e,\n    0xe8e9ade2, 0x0bee226c, 0x95ee88a0, 0x39fca879, 0xa7fc02b5,\n    0x44fb8d3b, 0xdafb27f7, 0xc3f2e2fd, 0x5df24831, 0xbef5c7bf,\n    0x20f56d73, 0xa7d6f6d6, 0x39d65c1a, 0xdad1d394, 0x44d17958,\n    0x5dd8bc52, 0xc3d8169e, 0x20df9910, 0xbedf33dc, 0x12cd1305,\n    0x8ccdb9c9, 0x6fca3647, 0xf1ca9c8b, 0xe8c35981, 0x76c3f34d,\n    0x95c47cc3, 0x0bc4d60f, 0x3747a67a, 0xa9470cb6, 0x4a408338,\n    0xd44029f4, 0xcd49ecfe, 0x53494632, 0xb04ec9bc, 0x2e4e6370,\n    0x825c43a9, 0x1c5ce965, 0xff5b66eb, 0x615bcc27, 0x7852092d,\n    0xe652a3e1, 0x05552c6f, 0x9b5586a3, 0x1c761d06, 0x8276b7ca,\n    0x61713844, 0xff719288, 0xe6785782, 0x7878fd4e, 0x9b7f72c0,\n    0x057fd80c, 0xa96df8d5, 0x376d5219, 0xd46add97, 0x4a6a775b,\n    0x5363b251, 0xcd63189d, 0x2e649713, 0xb0643ddf, 0x6125d083,\n    0xff257a4f, 0x1c22f5c1, 0x82225f0d, 0x9b2b9a07, 0x052b30cb,\n    0xe62cbf45, 0x782c1589, 0xd43e3550, 0x4a3e9f9c, 0xa9391012,\n    0x3739bade, 0x2e307fd4, 0xb030d518, 0x53375a96, 0xcd37f05a,\n    0x4a146bff, 0xd414c133, 0x37134ebd, 0xa913e471, 0xb01a217b,\n    0x2e1a8bb7, 0xcd1d0439, 0x531daef5, 0xff0f8e2c, 0x610f24e0,\n    0x8208ab6e, 0x1c0801a2, 0x0501c4a8, 0x9b016e64, 0x7806e1ea,\n    0xe6064b26}};\n\n#endif\n\n#endif\n\n#if N == 3\n\n#if W == 8\n\nlocal const z_crc_t FAR crc_braid_table[][256] = {\n   {0x00000000, 0x81256527, 0xd93bcc0f, 0x581ea928, 0x69069e5f,\n    0xe823fb78, 0xb03d5250, 0x31183777, 0xd20d3cbe, 0x53285999,\n    0x0b36f0b1, 0x8a139596, 0xbb0ba2e1, 0x3a2ec7c6, 0x62306eee,\n    0xe3150bc9, 0x7f6b7f3d, 0xfe4e1a1a, 0xa650b332, 0x2775d615,\n    0x166de162, 0x97488445, 0xcf562d6d, 0x4e73484a, 0xad664383,\n    0x2c4326a4, 0x745d8f8c, 0xf578eaab, 0xc460dddc, 0x4545b8fb,\n    0x1d5b11d3, 0x9c7e74f4, 0xfed6fe7a, 0x7ff39b5d, 0x27ed3275,\n    0xa6c85752, 0x97d06025, 0x16f50502, 0x4eebac2a, 0xcfcec90d,\n    0x2cdbc2c4, 0xadfea7e3, 0xf5e00ecb, 0x74c56bec, 0x45dd5c9b,\n    0xc4f839bc, 0x9ce69094, 0x1dc3f5b3, 0x81bd8147, 0x0098e460,\n    0x58864d48, 0xd9a3286f, 0xe8bb1f18, 0x699e7a3f, 0x3180d317,\n    0xb0a5b630, 0x53b0bdf9, 0xd295d8de, 0x8a8b71f6, 0x0bae14d1,\n    0x3ab623a6, 0xbb934681, 0xe38defa9, 0x62a88a8e, 0x26dcfab5,\n    0xa7f99f92, 0xffe736ba, 0x7ec2539d, 0x4fda64ea, 0xceff01cd,\n    0x96e1a8e5, 0x17c4cdc2, 0xf4d1c60b, 0x75f4a32c, 0x2dea0a04,\n    0xaccf6f23, 0x9dd75854, 0x1cf23d73, 0x44ec945b, 0xc5c9f17c,\n    0x59b78588, 0xd892e0af, 0x808c4987, 0x01a92ca0, 0x30b11bd7,\n    0xb1947ef0, 0xe98ad7d8, 0x68afb2ff, 0x8bbab936, 0x0a9fdc11,\n    0x52817539, 0xd3a4101e, 0xe2bc2769, 0x6399424e, 0x3b87eb66,\n    0xbaa28e41, 0xd80a04cf, 0x592f61e8, 0x0131c8c0, 0x8014ade7,\n    0xb10c9a90, 0x3029ffb7, 0x6837569f, 0xe91233b8, 0x0a073871,\n    0x8b225d56, 0xd33cf47e, 0x52199159, 0x6301a62e, 0xe224c309,\n    0xba3a6a21, 0x3b1f0f06, 0xa7617bf2, 0x26441ed5, 0x7e5ab7fd,\n    0xff7fd2da, 0xce67e5ad, 0x4f42808a, 0x175c29a2, 0x96794c85,\n    0x756c474c, 0xf449226b, 0xac578b43, 0x2d72ee64, 0x1c6ad913,\n    0x9d4fbc34, 0xc551151c, 0x4474703b, 0x4db9f56a, 0xcc9c904d,\n    0x94823965, 0x15a75c42, 0x24bf6b35, 0xa59a0e12, 0xfd84a73a,\n    0x7ca1c21d, 0x9fb4c9d4, 0x1e91acf3, 0x468f05db, 0xc7aa60fc,\n    0xf6b2578b, 0x779732ac, 0x2f899b84, 0xaeacfea3, 0x32d28a57,\n    0xb3f7ef70, 0xebe94658, 0x6acc237f, 0x5bd41408, 0xdaf1712f,\n    0x82efd807, 0x03cabd20, 0xe0dfb6e9, 0x61fad3ce, 0x39e47ae6,\n    0xb8c11fc1, 0x89d928b6, 0x08fc4d91, 0x50e2e4b9, 0xd1c7819e,\n    0xb36f0b10, 0x324a6e37, 0x6a54c71f, 0xeb71a238, 0xda69954f,\n    0x5b4cf068, 0x03525940, 0x82773c67, 0x616237ae, 0xe0475289,\n    0xb859fba1, 0x397c9e86, 0x0864a9f1, 0x8941ccd6, 0xd15f65fe,\n    0x507a00d9, 0xcc04742d, 0x4d21110a, 0x153fb822, 0x941add05,\n    0xa502ea72, 0x24278f55, 0x7c39267d, 0xfd1c435a, 0x1e094893,\n    0x9f2c2db4, 0xc732849c, 0x4617e1bb, 0x770fd6cc, 0xf62ab3eb,\n    0xae341ac3, 0x2f117fe4, 0x6b650fdf, 0xea406af8, 0xb25ec3d0,\n    0x337ba6f7, 0x02639180, 0x8346f4a7, 0xdb585d8f, 0x5a7d38a8,\n    0xb9683361, 0x384d5646, 0x6053ff6e, 0xe1769a49, 0xd06ead3e,\n    0x514bc819, 0x09556131, 0x88700416, 0x140e70e2, 0x952b15c5,\n    0xcd35bced, 0x4c10d9ca, 0x7d08eebd, 0xfc2d8b9a, 0xa43322b2,\n    0x25164795, 0xc6034c5c, 0x4726297b, 0x1f388053, 0x9e1de574,\n    0xaf05d203, 0x2e20b724, 0x763e1e0c, 0xf71b7b2b, 0x95b3f1a5,\n    0x14969482, 0x4c883daa, 0xcdad588d, 0xfcb56ffa, 0x7d900add,\n    0x258ea3f5, 0xa4abc6d2, 0x47becd1b, 0xc69ba83c, 0x9e850114,\n    0x1fa06433, 0x2eb85344, 0xaf9d3663, 0xf7839f4b, 0x76a6fa6c,\n    0xead88e98, 0x6bfdebbf, 0x33e34297, 0xb2c627b0, 0x83de10c7,\n    0x02fb75e0, 0x5ae5dcc8, 0xdbc0b9ef, 0x38d5b226, 0xb9f0d701,\n    0xe1ee7e29, 0x60cb1b0e, 0x51d32c79, 0xd0f6495e, 0x88e8e076,\n    0x09cd8551},\n   {0x00000000, 0x9b73ead4, 0xed96d3e9, 0x76e5393d, 0x005ca193,\n    0x9b2f4b47, 0xedca727a, 0x76b998ae, 0x00b94326, 0x9bcaa9f2,\n    0xed2f90cf, 0x765c7a1b, 0x00e5e2b5, 0x9b960861, 0xed73315c,\n    0x7600db88, 0x0172864c, 0x9a016c98, 0xece455a5, 0x7797bf71,\n    0x012e27df, 0x9a5dcd0b, 0xecb8f436, 0x77cb1ee2, 0x01cbc56a,\n    0x9ab82fbe, 0xec5d1683, 0x772efc57, 0x019764f9, 0x9ae48e2d,\n    0xec01b710, 0x77725dc4, 0x02e50c98, 0x9996e64c, 0xef73df71,\n    0x740035a5, 0x02b9ad0b, 0x99ca47df, 0xef2f7ee2, 0x745c9436,\n    0x025c4fbe, 0x992fa56a, 0xefca9c57, 0x74b97683, 0x0200ee2d,\n    0x997304f9, 0xef963dc4, 0x74e5d710, 0x03978ad4, 0x98e46000,\n    0xee01593d, 0x7572b3e9, 0x03cb2b47, 0x98b8c193, 0xee5df8ae,\n    0x752e127a, 0x032ec9f2, 0x985d2326, 0xeeb81a1b, 0x75cbf0cf,\n    0x03726861, 0x980182b5, 0xeee4bb88, 0x7597515c, 0x05ca1930,\n    0x9eb9f3e4, 0xe85ccad9, 0x732f200d, 0x0596b8a3, 0x9ee55277,\n    0xe8006b4a, 0x7373819e, 0x05735a16, 0x9e00b0c2, 0xe8e589ff,\n    0x7396632b, 0x052ffb85, 0x9e5c1151, 0xe8b9286c, 0x73cac2b8,\n    0x04b89f7c, 0x9fcb75a8, 0xe92e4c95, 0x725da641, 0x04e43eef,\n    0x9f97d43b, 0xe972ed06, 0x720107d2, 0x0401dc5a, 0x9f72368e,\n    0xe9970fb3, 0x72e4e567, 0x045d7dc9, 0x9f2e971d, 0xe9cbae20,\n    0x72b844f4, 0x072f15a8, 0x9c5cff7c, 0xeab9c641, 0x71ca2c95,\n    0x0773b43b, 0x9c005eef, 0xeae567d2, 0x71968d06, 0x0796568e,\n    0x9ce5bc5a, 0xea008567, 0x71736fb3, 0x07caf71d, 0x9cb91dc9,\n    0xea5c24f4, 0x712fce20, 0x065d93e4, 0x9d2e7930, 0xebcb400d,\n    0x70b8aad9, 0x06013277, 0x9d72d8a3, 0xeb97e19e, 0x70e40b4a,\n    0x06e4d0c2, 0x9d973a16, 0xeb72032b, 0x7001e9ff, 0x06b87151,\n    0x9dcb9b85, 0xeb2ea2b8, 0x705d486c, 0x0b943260, 0x90e7d8b4,\n    0xe602e189, 0x7d710b5d, 0x0bc893f3, 0x90bb7927, 0xe65e401a,\n    0x7d2daace, 0x0b2d7146, 0x905e9b92, 0xe6bba2af, 0x7dc8487b,\n    0x0b71d0d5, 0x90023a01, 0xe6e7033c, 0x7d94e9e8, 0x0ae6b42c,\n    0x91955ef8, 0xe77067c5, 0x7c038d11, 0x0aba15bf, 0x91c9ff6b,\n    0xe72cc656, 0x7c5f2c82, 0x0a5ff70a, 0x912c1dde, 0xe7c924e3,\n    0x7cbace37, 0x0a035699, 0x9170bc4d, 0xe7958570, 0x7ce66fa4,\n    0x09713ef8, 0x9202d42c, 0xe4e7ed11, 0x7f9407c5, 0x092d9f6b,\n    0x925e75bf, 0xe4bb4c82, 0x7fc8a656, 0x09c87dde, 0x92bb970a,\n    0xe45eae37, 0x7f2d44e3, 0x0994dc4d, 0x92e73699, 0xe4020fa4,\n    0x7f71e570, 0x0803b8b4, 0x93705260, 0xe5956b5d, 0x7ee68189,\n    0x085f1927, 0x932cf3f3, 0xe5c9cace, 0x7eba201a, 0x08bafb92,\n    0x93c91146, 0xe52c287b, 0x7e5fc2af, 0x08e65a01, 0x9395b0d5,\n    0xe57089e8, 0x7e03633c, 0x0e5e2b50, 0x952dc184, 0xe3c8f8b9,\n    0x78bb126d, 0x0e028ac3, 0x95716017, 0xe394592a, 0x78e7b3fe,\n    0x0ee76876, 0x959482a2, 0xe371bb9f, 0x7802514b, 0x0ebbc9e5,\n    0x95c82331, 0xe32d1a0c, 0x785ef0d8, 0x0f2cad1c, 0x945f47c8,\n    0xe2ba7ef5, 0x79c99421, 0x0f700c8f, 0x9403e65b, 0xe2e6df66,\n    0x799535b2, 0x0f95ee3a, 0x94e604ee, 0xe2033dd3, 0x7970d707,\n    0x0fc94fa9, 0x94baa57d, 0xe25f9c40, 0x792c7694, 0x0cbb27c8,\n    0x97c8cd1c, 0xe12df421, 0x7a5e1ef5, 0x0ce7865b, 0x97946c8f,\n    0xe17155b2, 0x7a02bf66, 0x0c0264ee, 0x97718e3a, 0xe194b707,\n    0x7ae75dd3, 0x0c5ec57d, 0x972d2fa9, 0xe1c81694, 0x7abbfc40,\n    0x0dc9a184, 0x96ba4b50, 0xe05f726d, 0x7b2c98b9, 0x0d950017,\n    0x96e6eac3, 0xe003d3fe, 0x7b70392a, 0x0d70e2a2, 0x96030876,\n    0xe0e6314b, 0x7b95db9f, 0x0d2c4331, 0x965fa9e5, 0xe0ba90d8,\n    0x7bc97a0c},\n   {0x00000000, 0x172864c0, 0x2e50c980, 0x3978ad40, 0x5ca19300,\n    0x4b89f7c0, 0x72f15a80, 0x65d93e40, 0xb9432600, 0xae6b42c0,\n    0x9713ef80, 0x803b8b40, 0xe5e2b500, 0xf2cad1c0, 0xcbb27c80,\n    0xdc9a1840, 0xa9f74a41, 0xbedf2e81, 0x87a783c1, 0x908fe701,\n    0xf556d941, 0xe27ebd81, 0xdb0610c1, 0xcc2e7401, 0x10b46c41,\n    0x079c0881, 0x3ee4a5c1, 0x29ccc101, 0x4c15ff41, 0x5b3d9b81,\n    0x624536c1, 0x756d5201, 0x889f92c3, 0x9fb7f603, 0xa6cf5b43,\n    0xb1e73f83, 0xd43e01c3, 0xc3166503, 0xfa6ec843, 0xed46ac83,\n    0x31dcb4c3, 0x26f4d003, 0x1f8c7d43, 0x08a41983, 0x6d7d27c3,\n    0x7a554303, 0x432dee43, 0x54058a83, 0x2168d882, 0x3640bc42,\n    0x0f381102, 0x181075c2, 0x7dc94b82, 0x6ae12f42, 0x53998202,\n    0x44b1e6c2, 0x982bfe82, 0x8f039a42, 0xb67b3702, 0xa15353c2,\n    0xc48a6d82, 0xd3a20942, 0xeadaa402, 0xfdf2c0c2, 0xca4e23c7,\n    0xdd664707, 0xe41eea47, 0xf3368e87, 0x96efb0c7, 0x81c7d407,\n    0xb8bf7947, 0xaf971d87, 0x730d05c7, 0x64256107, 0x5d5dcc47,\n    0x4a75a887, 0x2fac96c7, 0x3884f207, 0x01fc5f47, 0x16d43b87,\n    0x63b96986, 0x74910d46, 0x4de9a006, 0x5ac1c4c6, 0x3f18fa86,\n    0x28309e46, 0x11483306, 0x066057c6, 0xdafa4f86, 0xcdd22b46,\n    0xf4aa8606, 0xe382e2c6, 0x865bdc86, 0x9173b846, 0xa80b1506,\n    0xbf2371c6, 0x42d1b104, 0x55f9d5c4, 0x6c817884, 0x7ba91c44,\n    0x1e702204, 0x095846c4, 0x3020eb84, 0x27088f44, 0xfb929704,\n    0xecbaf3c4, 0xd5c25e84, 0xc2ea3a44, 0xa7330404, 0xb01b60c4,\n    0x8963cd84, 0x9e4ba944, 0xeb26fb45, 0xfc0e9f85, 0xc57632c5,\n    0xd25e5605, 0xb7876845, 0xa0af0c85, 0x99d7a1c5, 0x8effc505,\n    0x5265dd45, 0x454db985, 0x7c3514c5, 0x6b1d7005, 0x0ec44e45,\n    0x19ec2a85, 0x209487c5, 0x37bce305, 0x4fed41cf, 0x58c5250f,\n    0x61bd884f, 0x7695ec8f, 0x134cd2cf, 0x0464b60f, 0x3d1c1b4f,\n    0x2a347f8f, 0xf6ae67cf, 0xe186030f, 0xd8feae4f, 0xcfd6ca8f,\n    0xaa0ff4cf, 0xbd27900f, 0x845f3d4f, 0x9377598f, 0xe61a0b8e,\n    0xf1326f4e, 0xc84ac20e, 0xdf62a6ce, 0xbabb988e, 0xad93fc4e,\n    0x94eb510e, 0x83c335ce, 0x5f592d8e, 0x4871494e, 0x7109e40e,\n    0x662180ce, 0x03f8be8e, 0x14d0da4e, 0x2da8770e, 0x3a8013ce,\n    0xc772d30c, 0xd05ab7cc, 0xe9221a8c, 0xfe0a7e4c, 0x9bd3400c,\n    0x8cfb24cc, 0xb583898c, 0xa2abed4c, 0x7e31f50c, 0x691991cc,\n    0x50613c8c, 0x4749584c, 0x2290660c, 0x35b802cc, 0x0cc0af8c,\n    0x1be8cb4c, 0x6e85994d, 0x79adfd8d, 0x40d550cd, 0x57fd340d,\n    0x32240a4d, 0x250c6e8d, 0x1c74c3cd, 0x0b5ca70d, 0xd7c6bf4d,\n    0xc0eedb8d, 0xf99676cd, 0xeebe120d, 0x8b672c4d, 0x9c4f488d,\n    0xa537e5cd, 0xb21f810d, 0x85a36208, 0x928b06c8, 0xabf3ab88,\n    0xbcdbcf48, 0xd902f108, 0xce2a95c8, 0xf7523888, 0xe07a5c48,\n    0x3ce04408, 0x2bc820c8, 0x12b08d88, 0x0598e948, 0x6041d708,\n    0x7769b3c8, 0x4e111e88, 0x59397a48, 0x2c542849, 0x3b7c4c89,\n    0x0204e1c9, 0x152c8509, 0x70f5bb49, 0x67dddf89, 0x5ea572c9,\n    0x498d1609, 0x95170e49, 0x823f6a89, 0xbb47c7c9, 0xac6fa309,\n    0xc9b69d49, 0xde9ef989, 0xe7e654c9, 0xf0ce3009, 0x0d3cf0cb,\n    0x1a14940b, 0x236c394b, 0x34445d8b, 0x519d63cb, 0x46b5070b,\n    0x7fcdaa4b, 0x68e5ce8b, 0xb47fd6cb, 0xa357b20b, 0x9a2f1f4b,\n    0x8d077b8b, 0xe8de45cb, 0xfff6210b, 0xc68e8c4b, 0xd1a6e88b,\n    0xa4cbba8a, 0xb3e3de4a, 0x8a9b730a, 0x9db317ca, 0xf86a298a,\n    0xef424d4a, 0xd63ae00a, 0xc11284ca, 0x1d889c8a, 0x0aa0f84a,\n    0x33d8550a, 0x24f031ca, 0x41290f8a, 0x56016b4a, 0x6f79c60a,\n    0x7851a2ca},\n   {0x00000000, 0x9fda839e, 0xe4c4017d, 0x7b1e82e3, 0x12f904bb,\n    0x8d238725, 0xf63d05c6, 0x69e78658, 0x25f20976, 0xba288ae8,\n    0xc136080b, 0x5eec8b95, 0x370b0dcd, 0xa8d18e53, 0xd3cf0cb0,\n    0x4c158f2e, 0x4be412ec, 0xd43e9172, 0xaf201391, 0x30fa900f,\n    0x591d1657, 0xc6c795c9, 0xbdd9172a, 0x220394b4, 0x6e161b9a,\n    0xf1cc9804, 0x8ad21ae7, 0x15089979, 0x7cef1f21, 0xe3359cbf,\n    0x982b1e5c, 0x07f19dc2, 0x97c825d8, 0x0812a646, 0x730c24a5,\n    0xecd6a73b, 0x85312163, 0x1aeba2fd, 0x61f5201e, 0xfe2fa380,\n    0xb23a2cae, 0x2de0af30, 0x56fe2dd3, 0xc924ae4d, 0xa0c32815,\n    0x3f19ab8b, 0x44072968, 0xdbddaaf6, 0xdc2c3734, 0x43f6b4aa,\n    0x38e83649, 0xa732b5d7, 0xced5338f, 0x510fb011, 0x2a1132f2,\n    0xb5cbb16c, 0xf9de3e42, 0x6604bddc, 0x1d1a3f3f, 0x82c0bca1,\n    0xeb273af9, 0x74fdb967, 0x0fe33b84, 0x9039b81a, 0xf4e14df1,\n    0x6b3bce6f, 0x10254c8c, 0x8fffcf12, 0xe618494a, 0x79c2cad4,\n    0x02dc4837, 0x9d06cba9, 0xd1134487, 0x4ec9c719, 0x35d745fa,\n    0xaa0dc664, 0xc3ea403c, 0x5c30c3a2, 0x272e4141, 0xb8f4c2df,\n    0xbf055f1d, 0x20dfdc83, 0x5bc15e60, 0xc41bddfe, 0xadfc5ba6,\n    0x3226d838, 0x49385adb, 0xd6e2d945, 0x9af7566b, 0x052dd5f5,\n    0x7e335716, 0xe1e9d488, 0x880e52d0, 0x17d4d14e, 0x6cca53ad,\n    0xf310d033, 0x63296829, 0xfcf3ebb7, 0x87ed6954, 0x1837eaca,\n    0x71d06c92, 0xee0aef0c, 0x95146def, 0x0aceee71, 0x46db615f,\n    0xd901e2c1, 0xa21f6022, 0x3dc5e3bc, 0x542265e4, 0xcbf8e67a,\n    0xb0e66499, 0x2f3ce707, 0x28cd7ac5, 0xb717f95b, 0xcc097bb8,\n    0x53d3f826, 0x3a347e7e, 0xa5eefde0, 0xdef07f03, 0x412afc9d,\n    0x0d3f73b3, 0x92e5f02d, 0xe9fb72ce, 0x7621f150, 0x1fc67708,\n    0x801cf496, 0xfb027675, 0x64d8f5eb, 0x32b39da3, 0xad691e3d,\n    0xd6779cde, 0x49ad1f40, 0x204a9918, 0xbf901a86, 0xc48e9865,\n    0x5b541bfb, 0x174194d5, 0x889b174b, 0xf38595a8, 0x6c5f1636,\n    0x05b8906e, 0x9a6213f0, 0xe17c9113, 0x7ea6128d, 0x79578f4f,\n    0xe68d0cd1, 0x9d938e32, 0x02490dac, 0x6bae8bf4, 0xf474086a,\n    0x8f6a8a89, 0x10b00917, 0x5ca58639, 0xc37f05a7, 0xb8618744,\n    0x27bb04da, 0x4e5c8282, 0xd186011c, 0xaa9883ff, 0x35420061,\n    0xa57bb87b, 0x3aa13be5, 0x41bfb906, 0xde653a98, 0xb782bcc0,\n    0x28583f5e, 0x5346bdbd, 0xcc9c3e23, 0x8089b10d, 0x1f533293,\n    0x644db070, 0xfb9733ee, 0x9270b5b6, 0x0daa3628, 0x76b4b4cb,\n    0xe96e3755, 0xee9faa97, 0x71452909, 0x0a5babea, 0x95812874,\n    0xfc66ae2c, 0x63bc2db2, 0x18a2af51, 0x87782ccf, 0xcb6da3e1,\n    0x54b7207f, 0x2fa9a29c, 0xb0732102, 0xd994a75a, 0x464e24c4,\n    0x3d50a627, 0xa28a25b9, 0xc652d052, 0x598853cc, 0x2296d12f,\n    0xbd4c52b1, 0xd4abd4e9, 0x4b715777, 0x306fd594, 0xafb5560a,\n    0xe3a0d924, 0x7c7a5aba, 0x0764d859, 0x98be5bc7, 0xf159dd9f,\n    0x6e835e01, 0x159ddce2, 0x8a475f7c, 0x8db6c2be, 0x126c4120,\n    0x6972c3c3, 0xf6a8405d, 0x9f4fc605, 0x0095459b, 0x7b8bc778,\n    0xe45144e6, 0xa844cbc8, 0x379e4856, 0x4c80cab5, 0xd35a492b,\n    0xbabdcf73, 0x25674ced, 0x5e79ce0e, 0xc1a34d90, 0x519af58a,\n    0xce407614, 0xb55ef4f7, 0x2a847769, 0x4363f131, 0xdcb972af,\n    0xa7a7f04c, 0x387d73d2, 0x7468fcfc, 0xebb27f62, 0x90acfd81,\n    0x0f767e1f, 0x6691f847, 0xf94b7bd9, 0x8255f93a, 0x1d8f7aa4,\n    0x1a7ee766, 0x85a464f8, 0xfebae61b, 0x61606585, 0x0887e3dd,\n    0x975d6043, 0xec43e2a0, 0x7399613e, 0x3f8cee10, 0xa0566d8e,\n    0xdb48ef6d, 0x44926cf3, 0x2d75eaab, 0xb2af6935, 0xc9b1ebd6,\n    0x566b6848},\n   {0x00000000, 0x65673b46, 0xcace768c, 0xafa94dca, 0x4eedeb59,\n    0x2b8ad01f, 0x84239dd5, 0xe144a693, 0x9ddbd6b2, 0xf8bcedf4,\n    0x5715a03e, 0x32729b78, 0xd3363deb, 0xb65106ad, 0x19f84b67,\n    0x7c9f7021, 0xe0c6ab25, 0x85a19063, 0x2a08dda9, 0x4f6fe6ef,\n    0xae2b407c, 0xcb4c7b3a, 0x64e536f0, 0x01820db6, 0x7d1d7d97,\n    0x187a46d1, 0xb7d30b1b, 0xd2b4305d, 0x33f096ce, 0x5697ad88,\n    0xf93ee042, 0x9c59db04, 0x1afc500b, 0x7f9b6b4d, 0xd0322687,\n    0xb5551dc1, 0x5411bb52, 0x31768014, 0x9edfcdde, 0xfbb8f698,\n    0x872786b9, 0xe240bdff, 0x4de9f035, 0x288ecb73, 0xc9ca6de0,\n    0xacad56a6, 0x03041b6c, 0x6663202a, 0xfa3afb2e, 0x9f5dc068,\n    0x30f48da2, 0x5593b6e4, 0xb4d71077, 0xd1b02b31, 0x7e1966fb,\n    0x1b7e5dbd, 0x67e12d9c, 0x028616da, 0xad2f5b10, 0xc8486056,\n    0x290cc6c5, 0x4c6bfd83, 0xe3c2b049, 0x86a58b0f, 0x35f8a016,\n    0x509f9b50, 0xff36d69a, 0x9a51eddc, 0x7b154b4f, 0x1e727009,\n    0xb1db3dc3, 0xd4bc0685, 0xa82376a4, 0xcd444de2, 0x62ed0028,\n    0x078a3b6e, 0xe6ce9dfd, 0x83a9a6bb, 0x2c00eb71, 0x4967d037,\n    0xd53e0b33, 0xb0593075, 0x1ff07dbf, 0x7a9746f9, 0x9bd3e06a,\n    0xfeb4db2c, 0x511d96e6, 0x347aada0, 0x48e5dd81, 0x2d82e6c7,\n    0x822bab0d, 0xe74c904b, 0x060836d8, 0x636f0d9e, 0xccc64054,\n    0xa9a17b12, 0x2f04f01d, 0x4a63cb5b, 0xe5ca8691, 0x80adbdd7,\n    0x61e91b44, 0x048e2002, 0xab276dc8, 0xce40568e, 0xb2df26af,\n    0xd7b81de9, 0x78115023, 0x1d766b65, 0xfc32cdf6, 0x9955f6b0,\n    0x36fcbb7a, 0x539b803c, 0xcfc25b38, 0xaaa5607e, 0x050c2db4,\n    0x606b16f2, 0x812fb061, 0xe4488b27, 0x4be1c6ed, 0x2e86fdab,\n    0x52198d8a, 0x377eb6cc, 0x98d7fb06, 0xfdb0c040, 0x1cf466d3,\n    0x79935d95, 0xd63a105f, 0xb35d2b19, 0x6bf1402c, 0x0e967b6a,\n    0xa13f36a0, 0xc4580de6, 0x251cab75, 0x407b9033, 0xefd2ddf9,\n    0x8ab5e6bf, 0xf62a969e, 0x934dadd8, 0x3ce4e012, 0x5983db54,\n    0xb8c77dc7, 0xdda04681, 0x72090b4b, 0x176e300d, 0x8b37eb09,\n    0xee50d04f, 0x41f99d85, 0x249ea6c3, 0xc5da0050, 0xa0bd3b16,\n    0x0f1476dc, 0x6a734d9a, 0x16ec3dbb, 0x738b06fd, 0xdc224b37,\n    0xb9457071, 0x5801d6e2, 0x3d66eda4, 0x92cfa06e, 0xf7a89b28,\n    0x710d1027, 0x146a2b61, 0xbbc366ab, 0xdea45ded, 0x3fe0fb7e,\n    0x5a87c038, 0xf52e8df2, 0x9049b6b4, 0xecd6c695, 0x89b1fdd3,\n    0x2618b019, 0x437f8b5f, 0xa23b2dcc, 0xc75c168a, 0x68f55b40,\n    0x0d926006, 0x91cbbb02, 0xf4ac8044, 0x5b05cd8e, 0x3e62f6c8,\n    0xdf26505b, 0xba416b1d, 0x15e826d7, 0x708f1d91, 0x0c106db0,\n    0x697756f6, 0xc6de1b3c, 0xa3b9207a, 0x42fd86e9, 0x279abdaf,\n    0x8833f065, 0xed54cb23, 0x5e09e03a, 0x3b6edb7c, 0x94c796b6,\n    0xf1a0adf0, 0x10e40b63, 0x75833025, 0xda2a7def, 0xbf4d46a9,\n    0xc3d23688, 0xa6b50dce, 0x091c4004, 0x6c7b7b42, 0x8d3fddd1,\n    0xe858e697, 0x47f1ab5d, 0x2296901b, 0xbecf4b1f, 0xdba87059,\n    0x74013d93, 0x116606d5, 0xf022a046, 0x95459b00, 0x3aecd6ca,\n    0x5f8bed8c, 0x23149dad, 0x4673a6eb, 0xe9daeb21, 0x8cbdd067,\n    0x6df976f4, 0x089e4db2, 0xa7370078, 0xc2503b3e, 0x44f5b031,\n    0x21928b77, 0x8e3bc6bd, 0xeb5cfdfb, 0x0a185b68, 0x6f7f602e,\n    0xc0d62de4, 0xa5b116a2, 0xd92e6683, 0xbc495dc5, 0x13e0100f,\n    0x76872b49, 0x97c38dda, 0xf2a4b69c, 0x5d0dfb56, 0x386ac010,\n    0xa4331b14, 0xc1542052, 0x6efd6d98, 0x0b9a56de, 0xeadef04d,\n    0x8fb9cb0b, 0x201086c1, 0x4577bd87, 0x39e8cda6, 0x5c8ff6e0,\n    0xf326bb2a, 0x9641806c, 0x770526ff, 0x12621db9, 0xbdcb5073,\n    0xd8ac6b35},\n   {0x00000000, 0xd7e28058, 0x74b406f1, 0xa35686a9, 0xe9680de2,\n    0x3e8a8dba, 0x9ddc0b13, 0x4a3e8b4b, 0x09a11d85, 0xde439ddd,\n    0x7d151b74, 0xaaf79b2c, 0xe0c91067, 0x372b903f, 0x947d1696,\n    0x439f96ce, 0x13423b0a, 0xc4a0bb52, 0x67f63dfb, 0xb014bda3,\n    0xfa2a36e8, 0x2dc8b6b0, 0x8e9e3019, 0x597cb041, 0x1ae3268f,\n    0xcd01a6d7, 0x6e57207e, 0xb9b5a026, 0xf38b2b6d, 0x2469ab35,\n    0x873f2d9c, 0x50ddadc4, 0x26847614, 0xf166f64c, 0x523070e5,\n    0x85d2f0bd, 0xcfec7bf6, 0x180efbae, 0xbb587d07, 0x6cbafd5f,\n    0x2f256b91, 0xf8c7ebc9, 0x5b916d60, 0x8c73ed38, 0xc64d6673,\n    0x11afe62b, 0xb2f96082, 0x651be0da, 0x35c64d1e, 0xe224cd46,\n    0x41724bef, 0x9690cbb7, 0xdcae40fc, 0x0b4cc0a4, 0xa81a460d,\n    0x7ff8c655, 0x3c67509b, 0xeb85d0c3, 0x48d3566a, 0x9f31d632,\n    0xd50f5d79, 0x02eddd21, 0xa1bb5b88, 0x7659dbd0, 0x4d08ec28,\n    0x9aea6c70, 0x39bcead9, 0xee5e6a81, 0xa460e1ca, 0x73826192,\n    0xd0d4e73b, 0x07366763, 0x44a9f1ad, 0x934b71f5, 0x301df75c,\n    0xe7ff7704, 0xadc1fc4f, 0x7a237c17, 0xd975fabe, 0x0e977ae6,\n    0x5e4ad722, 0x89a8577a, 0x2afed1d3, 0xfd1c518b, 0xb722dac0,\n    0x60c05a98, 0xc396dc31, 0x14745c69, 0x57ebcaa7, 0x80094aff,\n    0x235fcc56, 0xf4bd4c0e, 0xbe83c745, 0x6961471d, 0xca37c1b4,\n    0x1dd541ec, 0x6b8c9a3c, 0xbc6e1a64, 0x1f389ccd, 0xc8da1c95,\n    0x82e497de, 0x55061786, 0xf650912f, 0x21b21177, 0x622d87b9,\n    0xb5cf07e1, 0x16998148, 0xc17b0110, 0x8b458a5b, 0x5ca70a03,\n    0xfff18caa, 0x28130cf2, 0x78cea136, 0xaf2c216e, 0x0c7aa7c7,\n    0xdb98279f, 0x91a6acd4, 0x46442c8c, 0xe512aa25, 0x32f02a7d,\n    0x716fbcb3, 0xa68d3ceb, 0x05dbba42, 0xd2393a1a, 0x9807b151,\n    0x4fe53109, 0xecb3b7a0, 0x3b5137f8, 0x9a11d850, 0x4df35808,\n    0xeea5dea1, 0x39475ef9, 0x7379d5b2, 0xa49b55ea, 0x07cdd343,\n    0xd02f531b, 0x93b0c5d5, 0x4452458d, 0xe704c324, 0x30e6437c,\n    0x7ad8c837, 0xad3a486f, 0x0e6ccec6, 0xd98e4e9e, 0x8953e35a,\n    0x5eb16302, 0xfde7e5ab, 0x2a0565f3, 0x603beeb8, 0xb7d96ee0,\n    0x148fe849, 0xc36d6811, 0x80f2fedf, 0x57107e87, 0xf446f82e,\n    0x23a47876, 0x699af33d, 0xbe787365, 0x1d2ef5cc, 0xcacc7594,\n    0xbc95ae44, 0x6b772e1c, 0xc821a8b5, 0x1fc328ed, 0x55fda3a6,\n    0x821f23fe, 0x2149a557, 0xf6ab250f, 0xb534b3c1, 0x62d63399,\n    0xc180b530, 0x16623568, 0x5c5cbe23, 0x8bbe3e7b, 0x28e8b8d2,\n    0xff0a388a, 0xafd7954e, 0x78351516, 0xdb6393bf, 0x0c8113e7,\n    0x46bf98ac, 0x915d18f4, 0x320b9e5d, 0xe5e91e05, 0xa67688cb,\n    0x71940893, 0xd2c28e3a, 0x05200e62, 0x4f1e8529, 0x98fc0571,\n    0x3baa83d8, 0xec480380, 0xd7193478, 0x00fbb420, 0xa3ad3289,\n    0x744fb2d1, 0x3e71399a, 0xe993b9c2, 0x4ac53f6b, 0x9d27bf33,\n    0xdeb829fd, 0x095aa9a5, 0xaa0c2f0c, 0x7deeaf54, 0x37d0241f,\n    0xe032a447, 0x436422ee, 0x9486a2b6, 0xc45b0f72, 0x13b98f2a,\n    0xb0ef0983, 0x670d89db, 0x2d330290, 0xfad182c8, 0x59870461,\n    0x8e658439, 0xcdfa12f7, 0x1a1892af, 0xb94e1406, 0x6eac945e,\n    0x24921f15, 0xf3709f4d, 0x502619e4, 0x87c499bc, 0xf19d426c,\n    0x267fc234, 0x8529449d, 0x52cbc4c5, 0x18f54f8e, 0xcf17cfd6,\n    0x6c41497f, 0xbba3c927, 0xf83c5fe9, 0x2fdedfb1, 0x8c885918,\n    0x5b6ad940, 0x1154520b, 0xc6b6d253, 0x65e054fa, 0xb202d4a2,\n    0xe2df7966, 0x353df93e, 0x966b7f97, 0x4189ffcf, 0x0bb77484,\n    0xdc55f4dc, 0x7f037275, 0xa8e1f22d, 0xeb7e64e3, 0x3c9ce4bb,\n    0x9fca6212, 0x4828e24a, 0x02166901, 0xd5f4e959, 0x76a26ff0,\n    0xa140efa8},\n   {0x00000000, 0xef52b6e1, 0x05d46b83, 0xea86dd62, 0x0ba8d706,\n    0xe4fa61e7, 0x0e7cbc85, 0xe12e0a64, 0x1751ae0c, 0xf80318ed,\n    0x1285c58f, 0xfdd7736e, 0x1cf9790a, 0xf3abcfeb, 0x192d1289,\n    0xf67fa468, 0x2ea35c18, 0xc1f1eaf9, 0x2b77379b, 0xc425817a,\n    0x250b8b1e, 0xca593dff, 0x20dfe09d, 0xcf8d567c, 0x39f2f214,\n    0xd6a044f5, 0x3c269997, 0xd3742f76, 0x325a2512, 0xdd0893f3,\n    0x378e4e91, 0xd8dcf870, 0x5d46b830, 0xb2140ed1, 0x5892d3b3,\n    0xb7c06552, 0x56ee6f36, 0xb9bcd9d7, 0x533a04b5, 0xbc68b254,\n    0x4a17163c, 0xa545a0dd, 0x4fc37dbf, 0xa091cb5e, 0x41bfc13a,\n    0xaeed77db, 0x446baab9, 0xab391c58, 0x73e5e428, 0x9cb752c9,\n    0x76318fab, 0x9963394a, 0x784d332e, 0x971f85cf, 0x7d9958ad,\n    0x92cbee4c, 0x64b44a24, 0x8be6fcc5, 0x616021a7, 0x8e329746,\n    0x6f1c9d22, 0x804e2bc3, 0x6ac8f6a1, 0x859a4040, 0xba8d7060,\n    0x55dfc681, 0xbf591be3, 0x500bad02, 0xb125a766, 0x5e771187,\n    0xb4f1cce5, 0x5ba37a04, 0xaddcde6c, 0x428e688d, 0xa808b5ef,\n    0x475a030e, 0xa674096a, 0x4926bf8b, 0xa3a062e9, 0x4cf2d408,\n    0x942e2c78, 0x7b7c9a99, 0x91fa47fb, 0x7ea8f11a, 0x9f86fb7e,\n    0x70d44d9f, 0x9a5290fd, 0x7500261c, 0x837f8274, 0x6c2d3495,\n    0x86abe9f7, 0x69f95f16, 0x88d75572, 0x6785e393, 0x8d033ef1,\n    0x62518810, 0xe7cbc850, 0x08997eb1, 0xe21fa3d3, 0x0d4d1532,\n    0xec631f56, 0x0331a9b7, 0xe9b774d5, 0x06e5c234, 0xf09a665c,\n    0x1fc8d0bd, 0xf54e0ddf, 0x1a1cbb3e, 0xfb32b15a, 0x146007bb,\n    0xfee6dad9, 0x11b46c38, 0xc9689448, 0x263a22a9, 0xccbcffcb,\n    0x23ee492a, 0xc2c0434e, 0x2d92f5af, 0xc71428cd, 0x28469e2c,\n    0xde393a44, 0x316b8ca5, 0xdbed51c7, 0x34bfe726, 0xd591ed42,\n    0x3ac35ba3, 0xd04586c1, 0x3f173020, 0xae6be681, 0x41395060,\n    0xabbf8d02, 0x44ed3be3, 0xa5c33187, 0x4a918766, 0xa0175a04,\n    0x4f45ece5, 0xb93a488d, 0x5668fe6c, 0xbcee230e, 0x53bc95ef,\n    0xb2929f8b, 0x5dc0296a, 0xb746f408, 0x581442e9, 0x80c8ba99,\n    0x6f9a0c78, 0x851cd11a, 0x6a4e67fb, 0x8b606d9f, 0x6432db7e,\n    0x8eb4061c, 0x61e6b0fd, 0x97991495, 0x78cba274, 0x924d7f16,\n    0x7d1fc9f7, 0x9c31c393, 0x73637572, 0x99e5a810, 0x76b71ef1,\n    0xf32d5eb1, 0x1c7fe850, 0xf6f93532, 0x19ab83d3, 0xf88589b7,\n    0x17d73f56, 0xfd51e234, 0x120354d5, 0xe47cf0bd, 0x0b2e465c,\n    0xe1a89b3e, 0x0efa2ddf, 0xefd427bb, 0x0086915a, 0xea004c38,\n    0x0552fad9, 0xdd8e02a9, 0x32dcb448, 0xd85a692a, 0x3708dfcb,\n    0xd626d5af, 0x3974634e, 0xd3f2be2c, 0x3ca008cd, 0xcadfaca5,\n    0x258d1a44, 0xcf0bc726, 0x205971c7, 0xc1777ba3, 0x2e25cd42,\n    0xc4a31020, 0x2bf1a6c1, 0x14e696e1, 0xfbb42000, 0x1132fd62,\n    0xfe604b83, 0x1f4e41e7, 0xf01cf706, 0x1a9a2a64, 0xf5c89c85,\n    0x03b738ed, 0xece58e0c, 0x0663536e, 0xe931e58f, 0x081fefeb,\n    0xe74d590a, 0x0dcb8468, 0xe2993289, 0x3a45caf9, 0xd5177c18,\n    0x3f91a17a, 0xd0c3179b, 0x31ed1dff, 0xdebfab1e, 0x3439767c,\n    0xdb6bc09d, 0x2d1464f5, 0xc246d214, 0x28c00f76, 0xc792b997,\n    0x26bcb3f3, 0xc9ee0512, 0x2368d870, 0xcc3a6e91, 0x49a02ed1,\n    0xa6f29830, 0x4c744552, 0xa326f3b3, 0x4208f9d7, 0xad5a4f36,\n    0x47dc9254, 0xa88e24b5, 0x5ef180dd, 0xb1a3363c, 0x5b25eb5e,\n    0xb4775dbf, 0x555957db, 0xba0be13a, 0x508d3c58, 0xbfdf8ab9,\n    0x670372c9, 0x8851c428, 0x62d7194a, 0x8d85afab, 0x6caba5cf,\n    0x83f9132e, 0x697fce4c, 0x862d78ad, 0x7052dcc5, 0x9f006a24,\n    0x7586b746, 0x9ad401a7, 0x7bfa0bc3, 0x94a8bd22, 0x7e2e6040,\n    0x917cd6a1},\n   {0x00000000, 0x87a6cb43, 0xd43c90c7, 0x539a5b84, 0x730827cf,\n    0xf4aeec8c, 0xa734b708, 0x20927c4b, 0xe6104f9e, 0x61b684dd,\n    0x322cdf59, 0xb58a141a, 0x95186851, 0x12bea312, 0x4124f896,\n    0xc68233d5, 0x1751997d, 0x90f7523e, 0xc36d09ba, 0x44cbc2f9,\n    0x6459beb2, 0xe3ff75f1, 0xb0652e75, 0x37c3e536, 0xf141d6e3,\n    0x76e71da0, 0x257d4624, 0xa2db8d67, 0x8249f12c, 0x05ef3a6f,\n    0x567561eb, 0xd1d3aaa8, 0x2ea332fa, 0xa905f9b9, 0xfa9fa23d,\n    0x7d39697e, 0x5dab1535, 0xda0dde76, 0x899785f2, 0x0e314eb1,\n    0xc8b37d64, 0x4f15b627, 0x1c8feda3, 0x9b2926e0, 0xbbbb5aab,\n    0x3c1d91e8, 0x6f87ca6c, 0xe821012f, 0x39f2ab87, 0xbe5460c4,\n    0xedce3b40, 0x6a68f003, 0x4afa8c48, 0xcd5c470b, 0x9ec61c8f,\n    0x1960d7cc, 0xdfe2e419, 0x58442f5a, 0x0bde74de, 0x8c78bf9d,\n    0xaceac3d6, 0x2b4c0895, 0x78d65311, 0xff709852, 0x5d4665f4,\n    0xdae0aeb7, 0x897af533, 0x0edc3e70, 0x2e4e423b, 0xa9e88978,\n    0xfa72d2fc, 0x7dd419bf, 0xbb562a6a, 0x3cf0e129, 0x6f6abaad,\n    0xe8cc71ee, 0xc85e0da5, 0x4ff8c6e6, 0x1c629d62, 0x9bc45621,\n    0x4a17fc89, 0xcdb137ca, 0x9e2b6c4e, 0x198da70d, 0x391fdb46,\n    0xbeb91005, 0xed234b81, 0x6a8580c2, 0xac07b317, 0x2ba17854,\n    0x783b23d0, 0xff9de893, 0xdf0f94d8, 0x58a95f9b, 0x0b33041f,\n    0x8c95cf5c, 0x73e5570e, 0xf4439c4d, 0xa7d9c7c9, 0x207f0c8a,\n    0x00ed70c1, 0x874bbb82, 0xd4d1e006, 0x53772b45, 0x95f51890,\n    0x1253d3d3, 0x41c98857, 0xc66f4314, 0xe6fd3f5f, 0x615bf41c,\n    0x32c1af98, 0xb56764db, 0x64b4ce73, 0xe3120530, 0xb0885eb4,\n    0x372e95f7, 0x17bce9bc, 0x901a22ff, 0xc380797b, 0x4426b238,\n    0x82a481ed, 0x05024aae, 0x5698112a, 0xd13eda69, 0xf1aca622,\n    0x760a6d61, 0x259036e5, 0xa236fda6, 0xba8ccbe8, 0x3d2a00ab,\n    0x6eb05b2f, 0xe916906c, 0xc984ec27, 0x4e222764, 0x1db87ce0,\n    0x9a1eb7a3, 0x5c9c8476, 0xdb3a4f35, 0x88a014b1, 0x0f06dff2,\n    0x2f94a3b9, 0xa83268fa, 0xfba8337e, 0x7c0ef83d, 0xaddd5295,\n    0x2a7b99d6, 0x79e1c252, 0xfe470911, 0xded5755a, 0x5973be19,\n    0x0ae9e59d, 0x8d4f2ede, 0x4bcd1d0b, 0xcc6bd648, 0x9ff18dcc,\n    0x1857468f, 0x38c53ac4, 0xbf63f187, 0xecf9aa03, 0x6b5f6140,\n    0x942ff912, 0x13893251, 0x401369d5, 0xc7b5a296, 0xe727dedd,\n    0x6081159e, 0x331b4e1a, 0xb4bd8559, 0x723fb68c, 0xf5997dcf,\n    0xa603264b, 0x21a5ed08, 0x01379143, 0x86915a00, 0xd50b0184,\n    0x52adcac7, 0x837e606f, 0x04d8ab2c, 0x5742f0a8, 0xd0e43beb,\n    0xf07647a0, 0x77d08ce3, 0x244ad767, 0xa3ec1c24, 0x656e2ff1,\n    0xe2c8e4b2, 0xb152bf36, 0x36f47475, 0x1666083e, 0x91c0c37d,\n    0xc25a98f9, 0x45fc53ba, 0xe7caae1c, 0x606c655f, 0x33f63edb,\n    0xb450f598, 0x94c289d3, 0x13644290, 0x40fe1914, 0xc758d257,\n    0x01dae182, 0x867c2ac1, 0xd5e67145, 0x5240ba06, 0x72d2c64d,\n    0xf5740d0e, 0xa6ee568a, 0x21489dc9, 0xf09b3761, 0x773dfc22,\n    0x24a7a7a6, 0xa3016ce5, 0x839310ae, 0x0435dbed, 0x57af8069,\n    0xd0094b2a, 0x168b78ff, 0x912db3bc, 0xc2b7e838, 0x4511237b,\n    0x65835f30, 0xe2259473, 0xb1bfcff7, 0x361904b4, 0xc9699ce6,\n    0x4ecf57a5, 0x1d550c21, 0x9af3c762, 0xba61bb29, 0x3dc7706a,\n    0x6e5d2bee, 0xe9fbe0ad, 0x2f79d378, 0xa8df183b, 0xfb4543bf,\n    0x7ce388fc, 0x5c71f4b7, 0xdbd73ff4, 0x884d6470, 0x0febaf33,\n    0xde38059b, 0x599eced8, 0x0a04955c, 0x8da25e1f, 0xad302254,\n    0x2a96e917, 0x790cb293, 0xfeaa79d0, 0x38284a05, 0xbf8e8146,\n    0xec14dac2, 0x6bb21181, 0x4b206dca, 0xcc86a689, 0x9f1cfd0d,\n    0x18ba364e}};\n\nlocal const z_word_t FAR crc_braid_big_table[][256] = {\n   {0x0000000000000000, 0x43cba68700000000, 0xc7903cd400000000,\n    0x845b9a5300000000, 0xcf27087300000000, 0x8cecaef400000000,\n    0x08b734a700000000, 0x4b7c922000000000, 0x9e4f10e600000000,\n    0xdd84b66100000000, 0x59df2c3200000000, 0x1a148ab500000000,\n    0x5168189500000000, 0x12a3be1200000000, 0x96f8244100000000,\n    0xd53382c600000000, 0x7d99511700000000, 0x3e52f79000000000,\n    0xba096dc300000000, 0xf9c2cb4400000000, 0xb2be596400000000,\n    0xf175ffe300000000, 0x752e65b000000000, 0x36e5c33700000000,\n    0xe3d641f100000000, 0xa01de77600000000, 0x24467d2500000000,\n    0x678ddba200000000, 0x2cf1498200000000, 0x6f3aef0500000000,\n    0xeb61755600000000, 0xa8aad3d100000000, 0xfa32a32e00000000,\n    0xb9f905a900000000, 0x3da29ffa00000000, 0x7e69397d00000000,\n    0x3515ab5d00000000, 0x76de0dda00000000, 0xf285978900000000,\n    0xb14e310e00000000, 0x647db3c800000000, 0x27b6154f00000000,\n    0xa3ed8f1c00000000, 0xe026299b00000000, 0xab5abbbb00000000,\n    0xe8911d3c00000000, 0x6cca876f00000000, 0x2f0121e800000000,\n    0x87abf23900000000, 0xc46054be00000000, 0x403bceed00000000,\n    0x03f0686a00000000, 0x488cfa4a00000000, 0x0b475ccd00000000,\n    0x8f1cc69e00000000, 0xccd7601900000000, 0x19e4e2df00000000,\n    0x5a2f445800000000, 0xde74de0b00000000, 0x9dbf788c00000000,\n    0xd6c3eaac00000000, 0x95084c2b00000000, 0x1153d67800000000,\n    0x529870ff00000000, 0xf465465d00000000, 0xb7aee0da00000000,\n    0x33f57a8900000000, 0x703edc0e00000000, 0x3b424e2e00000000,\n    0x7889e8a900000000, 0xfcd272fa00000000, 0xbf19d47d00000000,\n    0x6a2a56bb00000000, 0x29e1f03c00000000, 0xadba6a6f00000000,\n    0xee71cce800000000, 0xa50d5ec800000000, 0xe6c6f84f00000000,\n    0x629d621c00000000, 0x2156c49b00000000, 0x89fc174a00000000,\n    0xca37b1cd00000000, 0x4e6c2b9e00000000, 0x0da78d1900000000,\n    0x46db1f3900000000, 0x0510b9be00000000, 0x814b23ed00000000,\n    0xc280856a00000000, 0x17b307ac00000000, 0x5478a12b00000000,\n    0xd0233b7800000000, 0x93e89dff00000000, 0xd8940fdf00000000,\n    0x9b5fa95800000000, 0x1f04330b00000000, 0x5ccf958c00000000,\n    0x0e57e57300000000, 0x4d9c43f400000000, 0xc9c7d9a700000000,\n    0x8a0c7f2000000000, 0xc170ed0000000000, 0x82bb4b8700000000,\n    0x06e0d1d400000000, 0x452b775300000000, 0x9018f59500000000,\n    0xd3d3531200000000, 0x5788c94100000000, 0x14436fc600000000,\n    0x5f3ffde600000000, 0x1cf45b6100000000, 0x98afc13200000000,\n    0xdb6467b500000000, 0x73ceb46400000000, 0x300512e300000000,\n    0xb45e88b000000000, 0xf7952e3700000000, 0xbce9bc1700000000,\n    0xff221a9000000000, 0x7b7980c300000000, 0x38b2264400000000,\n    0xed81a48200000000, 0xae4a020500000000, 0x2a11985600000000,\n    0x69da3ed100000000, 0x22a6acf100000000, 0x616d0a7600000000,\n    0xe536902500000000, 0xa6fd36a200000000, 0xe8cb8cba00000000,\n    0xab002a3d00000000, 0x2f5bb06e00000000, 0x6c9016e900000000,\n    0x27ec84c900000000, 0x6427224e00000000, 0xe07cb81d00000000,\n    0xa3b71e9a00000000, 0x76849c5c00000000, 0x354f3adb00000000,\n    0xb114a08800000000, 0xf2df060f00000000, 0xb9a3942f00000000,\n    0xfa6832a800000000, 0x7e33a8fb00000000, 0x3df80e7c00000000,\n    0x9552ddad00000000, 0xd6997b2a00000000, 0x52c2e17900000000,\n    0x110947fe00000000, 0x5a75d5de00000000, 0x19be735900000000,\n    0x9de5e90a00000000, 0xde2e4f8d00000000, 0x0b1dcd4b00000000,\n    0x48d66bcc00000000, 0xcc8df19f00000000, 0x8f46571800000000,\n    0xc43ac53800000000, 0x87f163bf00000000, 0x03aaf9ec00000000,\n    0x40615f6b00000000, 0x12f92f9400000000, 0x5132891300000000,\n    0xd569134000000000, 0x96a2b5c700000000, 0xddde27e700000000,\n    0x9e15816000000000, 0x1a4e1b3300000000, 0x5985bdb400000000,\n    0x8cb63f7200000000, 0xcf7d99f500000000, 0x4b2603a600000000,\n    0x08eda52100000000, 0x4391370100000000, 0x005a918600000000,\n    0x84010bd500000000, 0xc7caad5200000000, 0x6f607e8300000000,\n    0x2cabd80400000000, 0xa8f0425700000000, 0xeb3be4d000000000,\n    0xa04776f000000000, 0xe38cd07700000000, 0x67d74a2400000000,\n    0x241ceca300000000, 0xf12f6e6500000000, 0xb2e4c8e200000000,\n    0x36bf52b100000000, 0x7574f43600000000, 0x3e08661600000000,\n    0x7dc3c09100000000, 0xf9985ac200000000, 0xba53fc4500000000,\n    0x1caecae700000000, 0x5f656c6000000000, 0xdb3ef63300000000,\n    0x98f550b400000000, 0xd389c29400000000, 0x9042641300000000,\n    0x1419fe4000000000, 0x57d258c700000000, 0x82e1da0100000000,\n    0xc12a7c8600000000, 0x4571e6d500000000, 0x06ba405200000000,\n    0x4dc6d27200000000, 0x0e0d74f500000000, 0x8a56eea600000000,\n    0xc99d482100000000, 0x61379bf000000000, 0x22fc3d7700000000,\n    0xa6a7a72400000000, 0xe56c01a300000000, 0xae10938300000000,\n    0xeddb350400000000, 0x6980af5700000000, 0x2a4b09d000000000,\n    0xff788b1600000000, 0xbcb32d9100000000, 0x38e8b7c200000000,\n    0x7b23114500000000, 0x305f836500000000, 0x739425e200000000,\n    0xf7cfbfb100000000, 0xb404193600000000, 0xe69c69c900000000,\n    0xa557cf4e00000000, 0x210c551d00000000, 0x62c7f39a00000000,\n    0x29bb61ba00000000, 0x6a70c73d00000000, 0xee2b5d6e00000000,\n    0xade0fbe900000000, 0x78d3792f00000000, 0x3b18dfa800000000,\n    0xbf4345fb00000000, 0xfc88e37c00000000, 0xb7f4715c00000000,\n    0xf43fd7db00000000, 0x70644d8800000000, 0x33afeb0f00000000,\n    0x9b0538de00000000, 0xd8ce9e5900000000, 0x5c95040a00000000,\n    0x1f5ea28d00000000, 0x542230ad00000000, 0x17e9962a00000000,\n    0x93b20c7900000000, 0xd079aafe00000000, 0x054a283800000000,\n    0x46818ebf00000000, 0xc2da14ec00000000, 0x8111b26b00000000,\n    0xca6d204b00000000, 0x89a686cc00000000, 0x0dfd1c9f00000000,\n    0x4e36ba1800000000},\n   {0x0000000000000000, 0xe1b652ef00000000, 0x836bd40500000000,\n    0x62dd86ea00000000, 0x06d7a80b00000000, 0xe761fae400000000,\n    0x85bc7c0e00000000, 0x640a2ee100000000, 0x0cae511700000000,\n    0xed1803f800000000, 0x8fc5851200000000, 0x6e73d7fd00000000,\n    0x0a79f91c00000000, 0xebcfabf300000000, 0x89122d1900000000,\n    0x68a47ff600000000, 0x185ca32e00000000, 0xf9eaf1c100000000,\n    0x9b37772b00000000, 0x7a8125c400000000, 0x1e8b0b2500000000,\n    0xff3d59ca00000000, 0x9de0df2000000000, 0x7c568dcf00000000,\n    0x14f2f23900000000, 0xf544a0d600000000, 0x9799263c00000000,\n    0x762f74d300000000, 0x12255a3200000000, 0xf39308dd00000000,\n    0x914e8e3700000000, 0x70f8dcd800000000, 0x30b8465d00000000,\n    0xd10e14b200000000, 0xb3d3925800000000, 0x5265c0b700000000,\n    0x366fee5600000000, 0xd7d9bcb900000000, 0xb5043a5300000000,\n    0x54b268bc00000000, 0x3c16174a00000000, 0xdda045a500000000,\n    0xbf7dc34f00000000, 0x5ecb91a000000000, 0x3ac1bf4100000000,\n    0xdb77edae00000000, 0xb9aa6b4400000000, 0x581c39ab00000000,\n    0x28e4e57300000000, 0xc952b79c00000000, 0xab8f317600000000,\n    0x4a39639900000000, 0x2e334d7800000000, 0xcf851f9700000000,\n    0xad58997d00000000, 0x4ceecb9200000000, 0x244ab46400000000,\n    0xc5fce68b00000000, 0xa721606100000000, 0x4697328e00000000,\n    0x229d1c6f00000000, 0xc32b4e8000000000, 0xa1f6c86a00000000,\n    0x40409a8500000000, 0x60708dba00000000, 0x81c6df5500000000,\n    0xe31b59bf00000000, 0x02ad0b5000000000, 0x66a725b100000000,\n    0x8711775e00000000, 0xe5ccf1b400000000, 0x047aa35b00000000,\n    0x6cdedcad00000000, 0x8d688e4200000000, 0xefb508a800000000,\n    0x0e035a4700000000, 0x6a0974a600000000, 0x8bbf264900000000,\n    0xe962a0a300000000, 0x08d4f24c00000000, 0x782c2e9400000000,\n    0x999a7c7b00000000, 0xfb47fa9100000000, 0x1af1a87e00000000,\n    0x7efb869f00000000, 0x9f4dd47000000000, 0xfd90529a00000000,\n    0x1c26007500000000, 0x74827f8300000000, 0x95342d6c00000000,\n    0xf7e9ab8600000000, 0x165ff96900000000, 0x7255d78800000000,\n    0x93e3856700000000, 0xf13e038d00000000, 0x1088516200000000,\n    0x50c8cbe700000000, 0xb17e990800000000, 0xd3a31fe200000000,\n    0x32154d0d00000000, 0x561f63ec00000000, 0xb7a9310300000000,\n    0xd574b7e900000000, 0x34c2e50600000000, 0x5c669af000000000,\n    0xbdd0c81f00000000, 0xdf0d4ef500000000, 0x3ebb1c1a00000000,\n    0x5ab132fb00000000, 0xbb07601400000000, 0xd9dae6fe00000000,\n    0x386cb41100000000, 0x489468c900000000, 0xa9223a2600000000,\n    0xcbffbccc00000000, 0x2a49ee2300000000, 0x4e43c0c200000000,\n    0xaff5922d00000000, 0xcd2814c700000000, 0x2c9e462800000000,\n    0x443a39de00000000, 0xa58c6b3100000000, 0xc751eddb00000000,\n    0x26e7bf3400000000, 0x42ed91d500000000, 0xa35bc33a00000000,\n    0xc18645d000000000, 0x2030173f00000000, 0x81e66bae00000000,\n    0x6050394100000000, 0x028dbfab00000000, 0xe33bed4400000000,\n    0x8731c3a500000000, 0x6687914a00000000, 0x045a17a000000000,\n    0xe5ec454f00000000, 0x8d483ab900000000, 0x6cfe685600000000,\n    0x0e23eebc00000000, 0xef95bc5300000000, 0x8b9f92b200000000,\n    0x6a29c05d00000000, 0x08f446b700000000, 0xe942145800000000,\n    0x99bac88000000000, 0x780c9a6f00000000, 0x1ad11c8500000000,\n    0xfb674e6a00000000, 0x9f6d608b00000000, 0x7edb326400000000,\n    0x1c06b48e00000000, 0xfdb0e66100000000, 0x9514999700000000,\n    0x74a2cb7800000000, 0x167f4d9200000000, 0xf7c91f7d00000000,\n    0x93c3319c00000000, 0x7275637300000000, 0x10a8e59900000000,\n    0xf11eb77600000000, 0xb15e2df300000000, 0x50e87f1c00000000,\n    0x3235f9f600000000, 0xd383ab1900000000, 0xb78985f800000000,\n    0x563fd71700000000, 0x34e251fd00000000, 0xd554031200000000,\n    0xbdf07ce400000000, 0x5c462e0b00000000, 0x3e9ba8e100000000,\n    0xdf2dfa0e00000000, 0xbb27d4ef00000000, 0x5a91860000000000,\n    0x384c00ea00000000, 0xd9fa520500000000, 0xa9028edd00000000,\n    0x48b4dc3200000000, 0x2a695ad800000000, 0xcbdf083700000000,\n    0xafd526d600000000, 0x4e63743900000000, 0x2cbef2d300000000,\n    0xcd08a03c00000000, 0xa5acdfca00000000, 0x441a8d2500000000,\n    0x26c70bcf00000000, 0xc771592000000000, 0xa37b77c100000000,\n    0x42cd252e00000000, 0x2010a3c400000000, 0xc1a6f12b00000000,\n    0xe196e61400000000, 0x0020b4fb00000000, 0x62fd321100000000,\n    0x834b60fe00000000, 0xe7414e1f00000000, 0x06f71cf000000000,\n    0x642a9a1a00000000, 0x859cc8f500000000, 0xed38b70300000000,\n    0x0c8ee5ec00000000, 0x6e53630600000000, 0x8fe531e900000000,\n    0xebef1f0800000000, 0x0a594de700000000, 0x6884cb0d00000000,\n    0x893299e200000000, 0xf9ca453a00000000, 0x187c17d500000000,\n    0x7aa1913f00000000, 0x9b17c3d000000000, 0xff1ded3100000000,\n    0x1eabbfde00000000, 0x7c76393400000000, 0x9dc06bdb00000000,\n    0xf564142d00000000, 0x14d246c200000000, 0x760fc02800000000,\n    0x97b992c700000000, 0xf3b3bc2600000000, 0x1205eec900000000,\n    0x70d8682300000000, 0x916e3acc00000000, 0xd12ea04900000000,\n    0x3098f2a600000000, 0x5245744c00000000, 0xb3f326a300000000,\n    0xd7f9084200000000, 0x364f5aad00000000, 0x5492dc4700000000,\n    0xb5248ea800000000, 0xdd80f15e00000000, 0x3c36a3b100000000,\n    0x5eeb255b00000000, 0xbf5d77b400000000, 0xdb57595500000000,\n    0x3ae10bba00000000, 0x583c8d5000000000, 0xb98adfbf00000000,\n    0xc972036700000000, 0x28c4518800000000, 0x4a19d76200000000,\n    0xabaf858d00000000, 0xcfa5ab6c00000000, 0x2e13f98300000000,\n    0x4cce7f6900000000, 0xad782d8600000000, 0xc5dc527000000000,\n    0x246a009f00000000, 0x46b7867500000000, 0xa701d49a00000000,\n    0xc30bfa7b00000000, 0x22bda89400000000, 0x40602e7e00000000,\n    0xa1d67c9100000000},\n   {0x0000000000000000, 0x5880e2d700000000, 0xf106b47400000000,\n    0xa98656a300000000, 0xe20d68e900000000, 0xba8d8a3e00000000,\n    0x130bdc9d00000000, 0x4b8b3e4a00000000, 0x851da10900000000,\n    0xdd9d43de00000000, 0x741b157d00000000, 0x2c9bf7aa00000000,\n    0x6710c9e000000000, 0x3f902b3700000000, 0x96167d9400000000,\n    0xce969f4300000000, 0x0a3b421300000000, 0x52bba0c400000000,\n    0xfb3df66700000000, 0xa3bd14b000000000, 0xe8362afa00000000,\n    0xb0b6c82d00000000, 0x19309e8e00000000, 0x41b07c5900000000,\n    0x8f26e31a00000000, 0xd7a601cd00000000, 0x7e20576e00000000,\n    0x26a0b5b900000000, 0x6d2b8bf300000000, 0x35ab692400000000,\n    0x9c2d3f8700000000, 0xc4addd5000000000, 0x1476842600000000,\n    0x4cf666f100000000, 0xe570305200000000, 0xbdf0d28500000000,\n    0xf67beccf00000000, 0xaefb0e1800000000, 0x077d58bb00000000,\n    0x5ffdba6c00000000, 0x916b252f00000000, 0xc9ebc7f800000000,\n    0x606d915b00000000, 0x38ed738c00000000, 0x73664dc600000000,\n    0x2be6af1100000000, 0x8260f9b200000000, 0xdae01b6500000000,\n    0x1e4dc63500000000, 0x46cd24e200000000, 0xef4b724100000000,\n    0xb7cb909600000000, 0xfc40aedc00000000, 0xa4c04c0b00000000,\n    0x0d461aa800000000, 0x55c6f87f00000000, 0x9b50673c00000000,\n    0xc3d085eb00000000, 0x6a56d34800000000, 0x32d6319f00000000,\n    0x795d0fd500000000, 0x21dded0200000000, 0x885bbba100000000,\n    0xd0db597600000000, 0x28ec084d00000000, 0x706cea9a00000000,\n    0xd9eabc3900000000, 0x816a5eee00000000, 0xcae160a400000000,\n    0x9261827300000000, 0x3be7d4d000000000, 0x6367360700000000,\n    0xadf1a94400000000, 0xf5714b9300000000, 0x5cf71d3000000000,\n    0x0477ffe700000000, 0x4ffcc1ad00000000, 0x177c237a00000000,\n    0xbefa75d900000000, 0xe67a970e00000000, 0x22d74a5e00000000,\n    0x7a57a88900000000, 0xd3d1fe2a00000000, 0x8b511cfd00000000,\n    0xc0da22b700000000, 0x985ac06000000000, 0x31dc96c300000000,\n    0x695c741400000000, 0xa7caeb5700000000, 0xff4a098000000000,\n    0x56cc5f2300000000, 0x0e4cbdf400000000, 0x45c783be00000000,\n    0x1d47616900000000, 0xb4c137ca00000000, 0xec41d51d00000000,\n    0x3c9a8c6b00000000, 0x641a6ebc00000000, 0xcd9c381f00000000,\n    0x951cdac800000000, 0xde97e48200000000, 0x8617065500000000,\n    0x2f9150f600000000, 0x7711b22100000000, 0xb9872d6200000000,\n    0xe107cfb500000000, 0x4881991600000000, 0x10017bc100000000,\n    0x5b8a458b00000000, 0x030aa75c00000000, 0xaa8cf1ff00000000,\n    0xf20c132800000000, 0x36a1ce7800000000, 0x6e212caf00000000,\n    0xc7a77a0c00000000, 0x9f2798db00000000, 0xd4aca69100000000,\n    0x8c2c444600000000, 0x25aa12e500000000, 0x7d2af03200000000,\n    0xb3bc6f7100000000, 0xeb3c8da600000000, 0x42badb0500000000,\n    0x1a3a39d200000000, 0x51b1079800000000, 0x0931e54f00000000,\n    0xa0b7b3ec00000000, 0xf837513b00000000, 0x50d8119a00000000,\n    0x0858f34d00000000, 0xa1dea5ee00000000, 0xf95e473900000000,\n    0xb2d5797300000000, 0xea559ba400000000, 0x43d3cd0700000000,\n    0x1b532fd000000000, 0xd5c5b09300000000, 0x8d45524400000000,\n    0x24c304e700000000, 0x7c43e63000000000, 0x37c8d87a00000000,\n    0x6f483aad00000000, 0xc6ce6c0e00000000, 0x9e4e8ed900000000,\n    0x5ae3538900000000, 0x0263b15e00000000, 0xabe5e7fd00000000,\n    0xf365052a00000000, 0xb8ee3b6000000000, 0xe06ed9b700000000,\n    0x49e88f1400000000, 0x11686dc300000000, 0xdffef28000000000,\n    0x877e105700000000, 0x2ef846f400000000, 0x7678a42300000000,\n    0x3df39a6900000000, 0x657378be00000000, 0xccf52e1d00000000,\n    0x9475ccca00000000, 0x44ae95bc00000000, 0x1c2e776b00000000,\n    0xb5a821c800000000, 0xed28c31f00000000, 0xa6a3fd5500000000,\n    0xfe231f8200000000, 0x57a5492100000000, 0x0f25abf600000000,\n    0xc1b334b500000000, 0x9933d66200000000, 0x30b580c100000000,\n    0x6835621600000000, 0x23be5c5c00000000, 0x7b3ebe8b00000000,\n    0xd2b8e82800000000, 0x8a380aff00000000, 0x4e95d7af00000000,\n    0x1615357800000000, 0xbf9363db00000000, 0xe713810c00000000,\n    0xac98bf4600000000, 0xf4185d9100000000, 0x5d9e0b3200000000,\n    0x051ee9e500000000, 0xcb8876a600000000, 0x9308947100000000,\n    0x3a8ec2d200000000, 0x620e200500000000, 0x29851e4f00000000,\n    0x7105fc9800000000, 0xd883aa3b00000000, 0x800348ec00000000,\n    0x783419d700000000, 0x20b4fb0000000000, 0x8932ada300000000,\n    0xd1b24f7400000000, 0x9a39713e00000000, 0xc2b993e900000000,\n    0x6b3fc54a00000000, 0x33bf279d00000000, 0xfd29b8de00000000,\n    0xa5a95a0900000000, 0x0c2f0caa00000000, 0x54afee7d00000000,\n    0x1f24d03700000000, 0x47a432e000000000, 0xee22644300000000,\n    0xb6a2869400000000, 0x720f5bc400000000, 0x2a8fb91300000000,\n    0x8309efb000000000, 0xdb890d6700000000, 0x9002332d00000000,\n    0xc882d1fa00000000, 0x6104875900000000, 0x3984658e00000000,\n    0xf712facd00000000, 0xaf92181a00000000, 0x06144eb900000000,\n    0x5e94ac6e00000000, 0x151f922400000000, 0x4d9f70f300000000,\n    0xe419265000000000, 0xbc99c48700000000, 0x6c429df100000000,\n    0x34c27f2600000000, 0x9d44298500000000, 0xc5c4cb5200000000,\n    0x8e4ff51800000000, 0xd6cf17cf00000000, 0x7f49416c00000000,\n    0x27c9a3bb00000000, 0xe95f3cf800000000, 0xb1dfde2f00000000,\n    0x1859888c00000000, 0x40d96a5b00000000, 0x0b52541100000000,\n    0x53d2b6c600000000, 0xfa54e06500000000, 0xa2d402b200000000,\n    0x6679dfe200000000, 0x3ef93d3500000000, 0x977f6b9600000000,\n    0xcfff894100000000, 0x8474b70b00000000, 0xdcf455dc00000000,\n    0x7572037f00000000, 0x2df2e1a800000000, 0xe3647eeb00000000,\n    0xbbe49c3c00000000, 0x1262ca9f00000000, 0x4ae2284800000000,\n    0x0169160200000000, 0x59e9f4d500000000, 0xf06fa27600000000,\n    0xa8ef40a100000000},\n   {0x0000000000000000, 0x463b676500000000, 0x8c76ceca00000000,\n    0xca4da9af00000000, 0x59ebed4e00000000, 0x1fd08a2b00000000,\n    0xd59d238400000000, 0x93a644e100000000, 0xb2d6db9d00000000,\n    0xf4edbcf800000000, 0x3ea0155700000000, 0x789b723200000000,\n    0xeb3d36d300000000, 0xad0651b600000000, 0x674bf81900000000,\n    0x21709f7c00000000, 0x25abc6e000000000, 0x6390a18500000000,\n    0xa9dd082a00000000, 0xefe66f4f00000000, 0x7c402bae00000000,\n    0x3a7b4ccb00000000, 0xf036e56400000000, 0xb60d820100000000,\n    0x977d1d7d00000000, 0xd1467a1800000000, 0x1b0bd3b700000000,\n    0x5d30b4d200000000, 0xce96f03300000000, 0x88ad975600000000,\n    0x42e03ef900000000, 0x04db599c00000000, 0x0b50fc1a00000000,\n    0x4d6b9b7f00000000, 0x872632d000000000, 0xc11d55b500000000,\n    0x52bb115400000000, 0x1480763100000000, 0xdecddf9e00000000,\n    0x98f6b8fb00000000, 0xb986278700000000, 0xffbd40e200000000,\n    0x35f0e94d00000000, 0x73cb8e2800000000, 0xe06dcac900000000,\n    0xa656adac00000000, 0x6c1b040300000000, 0x2a20636600000000,\n    0x2efb3afa00000000, 0x68c05d9f00000000, 0xa28df43000000000,\n    0xe4b6935500000000, 0x7710d7b400000000, 0x312bb0d100000000,\n    0xfb66197e00000000, 0xbd5d7e1b00000000, 0x9c2de16700000000,\n    0xda16860200000000, 0x105b2fad00000000, 0x566048c800000000,\n    0xc5c60c2900000000, 0x83fd6b4c00000000, 0x49b0c2e300000000,\n    0x0f8ba58600000000, 0x16a0f83500000000, 0x509b9f5000000000,\n    0x9ad636ff00000000, 0xdced519a00000000, 0x4f4b157b00000000,\n    0x0970721e00000000, 0xc33ddbb100000000, 0x8506bcd400000000,\n    0xa47623a800000000, 0xe24d44cd00000000, 0x2800ed6200000000,\n    0x6e3b8a0700000000, 0xfd9dcee600000000, 0xbba6a98300000000,\n    0x71eb002c00000000, 0x37d0674900000000, 0x330b3ed500000000,\n    0x753059b000000000, 0xbf7df01f00000000, 0xf946977a00000000,\n    0x6ae0d39b00000000, 0x2cdbb4fe00000000, 0xe6961d5100000000,\n    0xa0ad7a3400000000, 0x81dde54800000000, 0xc7e6822d00000000,\n    0x0dab2b8200000000, 0x4b904ce700000000, 0xd836080600000000,\n    0x9e0d6f6300000000, 0x5440c6cc00000000, 0x127ba1a900000000,\n    0x1df0042f00000000, 0x5bcb634a00000000, 0x9186cae500000000,\n    0xd7bdad8000000000, 0x441be96100000000, 0x02208e0400000000,\n    0xc86d27ab00000000, 0x8e5640ce00000000, 0xaf26dfb200000000,\n    0xe91db8d700000000, 0x2350117800000000, 0x656b761d00000000,\n    0xf6cd32fc00000000, 0xb0f6559900000000, 0x7abbfc3600000000,\n    0x3c809b5300000000, 0x385bc2cf00000000, 0x7e60a5aa00000000,\n    0xb42d0c0500000000, 0xf2166b6000000000, 0x61b02f8100000000,\n    0x278b48e400000000, 0xedc6e14b00000000, 0xabfd862e00000000,\n    0x8a8d195200000000, 0xccb67e3700000000, 0x06fbd79800000000,\n    0x40c0b0fd00000000, 0xd366f41c00000000, 0x955d937900000000,\n    0x5f103ad600000000, 0x192b5db300000000, 0x2c40f16b00000000,\n    0x6a7b960e00000000, 0xa0363fa100000000, 0xe60d58c400000000,\n    0x75ab1c2500000000, 0x33907b4000000000, 0xf9ddd2ef00000000,\n    0xbfe6b58a00000000, 0x9e962af600000000, 0xd8ad4d9300000000,\n    0x12e0e43c00000000, 0x54db835900000000, 0xc77dc7b800000000,\n    0x8146a0dd00000000, 0x4b0b097200000000, 0x0d306e1700000000,\n    0x09eb378b00000000, 0x4fd050ee00000000, 0x859df94100000000,\n    0xc3a69e2400000000, 0x5000dac500000000, 0x163bbda000000000,\n    0xdc76140f00000000, 0x9a4d736a00000000, 0xbb3dec1600000000,\n    0xfd068b7300000000, 0x374b22dc00000000, 0x717045b900000000,\n    0xe2d6015800000000, 0xa4ed663d00000000, 0x6ea0cf9200000000,\n    0x289ba8f700000000, 0x27100d7100000000, 0x612b6a1400000000,\n    0xab66c3bb00000000, 0xed5da4de00000000, 0x7efbe03f00000000,\n    0x38c0875a00000000, 0xf28d2ef500000000, 0xb4b6499000000000,\n    0x95c6d6ec00000000, 0xd3fdb18900000000, 0x19b0182600000000,\n    0x5f8b7f4300000000, 0xcc2d3ba200000000, 0x8a165cc700000000,\n    0x405bf56800000000, 0x0660920d00000000, 0x02bbcb9100000000,\n    0x4480acf400000000, 0x8ecd055b00000000, 0xc8f6623e00000000,\n    0x5b5026df00000000, 0x1d6b41ba00000000, 0xd726e81500000000,\n    0x911d8f7000000000, 0xb06d100c00000000, 0xf656776900000000,\n    0x3c1bdec600000000, 0x7a20b9a300000000, 0xe986fd4200000000,\n    0xafbd9a2700000000, 0x65f0338800000000, 0x23cb54ed00000000,\n    0x3ae0095e00000000, 0x7cdb6e3b00000000, 0xb696c79400000000,\n    0xf0ada0f100000000, 0x630be41000000000, 0x2530837500000000,\n    0xef7d2ada00000000, 0xa9464dbf00000000, 0x8836d2c300000000,\n    0xce0db5a600000000, 0x04401c0900000000, 0x427b7b6c00000000,\n    0xd1dd3f8d00000000, 0x97e658e800000000, 0x5dabf14700000000,\n    0x1b90962200000000, 0x1f4bcfbe00000000, 0x5970a8db00000000,\n    0x933d017400000000, 0xd506661100000000, 0x46a022f000000000,\n    0x009b459500000000, 0xcad6ec3a00000000, 0x8ced8b5f00000000,\n    0xad9d142300000000, 0xeba6734600000000, 0x21ebdae900000000,\n    0x67d0bd8c00000000, 0xf476f96d00000000, 0xb24d9e0800000000,\n    0x780037a700000000, 0x3e3b50c200000000, 0x31b0f54400000000,\n    0x778b922100000000, 0xbdc63b8e00000000, 0xfbfd5ceb00000000,\n    0x685b180a00000000, 0x2e607f6f00000000, 0xe42dd6c000000000,\n    0xa216b1a500000000, 0x83662ed900000000, 0xc55d49bc00000000,\n    0x0f10e01300000000, 0x492b877600000000, 0xda8dc39700000000,\n    0x9cb6a4f200000000, 0x56fb0d5d00000000, 0x10c06a3800000000,\n    0x141b33a400000000, 0x522054c100000000, 0x986dfd6e00000000,\n    0xde569a0b00000000, 0x4df0deea00000000, 0x0bcbb98f00000000,\n    0xc186102000000000, 0x87bd774500000000, 0xa6cde83900000000,\n    0xe0f68f5c00000000, 0x2abb26f300000000, 0x6c80419600000000,\n    0xff26057700000000, 0xb91d621200000000, 0x7350cbbd00000000,\n    0x356bacd800000000},\n   {0x0000000000000000, 0x9e83da9f00000000, 0x7d01c4e400000000,\n    0xe3821e7b00000000, 0xbb04f91200000000, 0x2587238d00000000,\n    0xc6053df600000000, 0x5886e76900000000, 0x7609f22500000000,\n    0xe88a28ba00000000, 0x0b0836c100000000, 0x958bec5e00000000,\n    0xcd0d0b3700000000, 0x538ed1a800000000, 0xb00ccfd300000000,\n    0x2e8f154c00000000, 0xec12e44b00000000, 0x72913ed400000000,\n    0x911320af00000000, 0x0f90fa3000000000, 0x57161d5900000000,\n    0xc995c7c600000000, 0x2a17d9bd00000000, 0xb494032200000000,\n    0x9a1b166e00000000, 0x0498ccf100000000, 0xe71ad28a00000000,\n    0x7999081500000000, 0x211fef7c00000000, 0xbf9c35e300000000,\n    0x5c1e2b9800000000, 0xc29df10700000000, 0xd825c89700000000,\n    0x46a6120800000000, 0xa5240c7300000000, 0x3ba7d6ec00000000,\n    0x6321318500000000, 0xfda2eb1a00000000, 0x1e20f56100000000,\n    0x80a32ffe00000000, 0xae2c3ab200000000, 0x30afe02d00000000,\n    0xd32dfe5600000000, 0x4dae24c900000000, 0x1528c3a000000000,\n    0x8bab193f00000000, 0x6829074400000000, 0xf6aadddb00000000,\n    0x34372cdc00000000, 0xaab4f64300000000, 0x4936e83800000000,\n    0xd7b532a700000000, 0x8f33d5ce00000000, 0x11b00f5100000000,\n    0xf232112a00000000, 0x6cb1cbb500000000, 0x423edef900000000,\n    0xdcbd046600000000, 0x3f3f1a1d00000000, 0xa1bcc08200000000,\n    0xf93a27eb00000000, 0x67b9fd7400000000, 0x843be30f00000000,\n    0x1ab8399000000000, 0xf14de1f400000000, 0x6fce3b6b00000000,\n    0x8c4c251000000000, 0x12cfff8f00000000, 0x4a4918e600000000,\n    0xd4cac27900000000, 0x3748dc0200000000, 0xa9cb069d00000000,\n    0x874413d100000000, 0x19c7c94e00000000, 0xfa45d73500000000,\n    0x64c60daa00000000, 0x3c40eac300000000, 0xa2c3305c00000000,\n    0x41412e2700000000, 0xdfc2f4b800000000, 0x1d5f05bf00000000,\n    0x83dcdf2000000000, 0x605ec15b00000000, 0xfedd1bc400000000,\n    0xa65bfcad00000000, 0x38d8263200000000, 0xdb5a384900000000,\n    0x45d9e2d600000000, 0x6b56f79a00000000, 0xf5d52d0500000000,\n    0x1657337e00000000, 0x88d4e9e100000000, 0xd0520e8800000000,\n    0x4ed1d41700000000, 0xad53ca6c00000000, 0x33d010f300000000,\n    0x2968296300000000, 0xb7ebf3fc00000000, 0x5469ed8700000000,\n    0xcaea371800000000, 0x926cd07100000000, 0x0cef0aee00000000,\n    0xef6d149500000000, 0x71eece0a00000000, 0x5f61db4600000000,\n    0xc1e201d900000000, 0x22601fa200000000, 0xbce3c53d00000000,\n    0xe465225400000000, 0x7ae6f8cb00000000, 0x9964e6b000000000,\n    0x07e73c2f00000000, 0xc57acd2800000000, 0x5bf917b700000000,\n    0xb87b09cc00000000, 0x26f8d35300000000, 0x7e7e343a00000000,\n    0xe0fdeea500000000, 0x037ff0de00000000, 0x9dfc2a4100000000,\n    0xb3733f0d00000000, 0x2df0e59200000000, 0xce72fbe900000000,\n    0x50f1217600000000, 0x0877c61f00000000, 0x96f41c8000000000,\n    0x757602fb00000000, 0xebf5d86400000000, 0xa39db33200000000,\n    0x3d1e69ad00000000, 0xde9c77d600000000, 0x401fad4900000000,\n    0x18994a2000000000, 0x861a90bf00000000, 0x65988ec400000000,\n    0xfb1b545b00000000, 0xd594411700000000, 0x4b179b8800000000,\n    0xa89585f300000000, 0x36165f6c00000000, 0x6e90b80500000000,\n    0xf013629a00000000, 0x13917ce100000000, 0x8d12a67e00000000,\n    0x4f8f577900000000, 0xd10c8de600000000, 0x328e939d00000000,\n    0xac0d490200000000, 0xf48bae6b00000000, 0x6a0874f400000000,\n    0x898a6a8f00000000, 0x1709b01000000000, 0x3986a55c00000000,\n    0xa7057fc300000000, 0x448761b800000000, 0xda04bb2700000000,\n    0x82825c4e00000000, 0x1c0186d100000000, 0xff8398aa00000000,\n    0x6100423500000000, 0x7bb87ba500000000, 0xe53ba13a00000000,\n    0x06b9bf4100000000, 0x983a65de00000000, 0xc0bc82b700000000,\n    0x5e3f582800000000, 0xbdbd465300000000, 0x233e9ccc00000000,\n    0x0db1898000000000, 0x9332531f00000000, 0x70b04d6400000000,\n    0xee3397fb00000000, 0xb6b5709200000000, 0x2836aa0d00000000,\n    0xcbb4b47600000000, 0x55376ee900000000, 0x97aa9fee00000000,\n    0x0929457100000000, 0xeaab5b0a00000000, 0x7428819500000000,\n    0x2cae66fc00000000, 0xb22dbc6300000000, 0x51afa21800000000,\n    0xcf2c788700000000, 0xe1a36dcb00000000, 0x7f20b75400000000,\n    0x9ca2a92f00000000, 0x022173b000000000, 0x5aa794d900000000,\n    0xc4244e4600000000, 0x27a6503d00000000, 0xb9258aa200000000,\n    0x52d052c600000000, 0xcc53885900000000, 0x2fd1962200000000,\n    0xb1524cbd00000000, 0xe9d4abd400000000, 0x7757714b00000000,\n    0x94d56f3000000000, 0x0a56b5af00000000, 0x24d9a0e300000000,\n    0xba5a7a7c00000000, 0x59d8640700000000, 0xc75bbe9800000000,\n    0x9fdd59f100000000, 0x015e836e00000000, 0xe2dc9d1500000000,\n    0x7c5f478a00000000, 0xbec2b68d00000000, 0x20416c1200000000,\n    0xc3c3726900000000, 0x5d40a8f600000000, 0x05c64f9f00000000,\n    0x9b45950000000000, 0x78c78b7b00000000, 0xe64451e400000000,\n    0xc8cb44a800000000, 0x56489e3700000000, 0xb5ca804c00000000,\n    0x2b495ad300000000, 0x73cfbdba00000000, 0xed4c672500000000,\n    0x0ece795e00000000, 0x904da3c100000000, 0x8af59a5100000000,\n    0x147640ce00000000, 0xf7f45eb500000000, 0x6977842a00000000,\n    0x31f1634300000000, 0xaf72b9dc00000000, 0x4cf0a7a700000000,\n    0xd2737d3800000000, 0xfcfc687400000000, 0x627fb2eb00000000,\n    0x81fdac9000000000, 0x1f7e760f00000000, 0x47f8916600000000,\n    0xd97b4bf900000000, 0x3af9558200000000, 0xa47a8f1d00000000,\n    0x66e77e1a00000000, 0xf864a48500000000, 0x1be6bafe00000000,\n    0x8565606100000000, 0xdde3870800000000, 0x43605d9700000000,\n    0xa0e243ec00000000, 0x3e61997300000000, 0x10ee8c3f00000000,\n    0x8e6d56a000000000, 0x6def48db00000000, 0xf36c924400000000,\n    0xabea752d00000000, 0x3569afb200000000, 0xd6ebb1c900000000,\n    0x48686b5600000000},\n   {0x0000000000000000, 0xc064281700000000, 0x80c9502e00000000,\n    0x40ad783900000000, 0x0093a15c00000000, 0xc0f7894b00000000,\n    0x805af17200000000, 0x403ed96500000000, 0x002643b900000000,\n    0xc0426bae00000000, 0x80ef139700000000, 0x408b3b8000000000,\n    0x00b5e2e500000000, 0xc0d1caf200000000, 0x807cb2cb00000000,\n    0x40189adc00000000, 0x414af7a900000000, 0x812edfbe00000000,\n    0xc183a78700000000, 0x01e78f9000000000, 0x41d956f500000000,\n    0x81bd7ee200000000, 0xc11006db00000000, 0x01742ecc00000000,\n    0x416cb41000000000, 0x81089c0700000000, 0xc1a5e43e00000000,\n    0x01c1cc2900000000, 0x41ff154c00000000, 0x819b3d5b00000000,\n    0xc136456200000000, 0x01526d7500000000, 0xc3929f8800000000,\n    0x03f6b79f00000000, 0x435bcfa600000000, 0x833fe7b100000000,\n    0xc3013ed400000000, 0x036516c300000000, 0x43c86efa00000000,\n    0x83ac46ed00000000, 0xc3b4dc3100000000, 0x03d0f42600000000,\n    0x437d8c1f00000000, 0x8319a40800000000, 0xc3277d6d00000000,\n    0x0343557a00000000, 0x43ee2d4300000000, 0x838a055400000000,\n    0x82d8682100000000, 0x42bc403600000000, 0x0211380f00000000,\n    0xc275101800000000, 0x824bc97d00000000, 0x422fe16a00000000,\n    0x0282995300000000, 0xc2e6b14400000000, 0x82fe2b9800000000,\n    0x429a038f00000000, 0x02377bb600000000, 0xc25353a100000000,\n    0x826d8ac400000000, 0x4209a2d300000000, 0x02a4daea00000000,\n    0xc2c0f2fd00000000, 0xc7234eca00000000, 0x074766dd00000000,\n    0x47ea1ee400000000, 0x878e36f300000000, 0xc7b0ef9600000000,\n    0x07d4c78100000000, 0x4779bfb800000000, 0x871d97af00000000,\n    0xc7050d7300000000, 0x0761256400000000, 0x47cc5d5d00000000,\n    0x87a8754a00000000, 0xc796ac2f00000000, 0x07f2843800000000,\n    0x475ffc0100000000, 0x873bd41600000000, 0x8669b96300000000,\n    0x460d917400000000, 0x06a0e94d00000000, 0xc6c4c15a00000000,\n    0x86fa183f00000000, 0x469e302800000000, 0x0633481100000000,\n    0xc657600600000000, 0x864ffada00000000, 0x462bd2cd00000000,\n    0x0686aaf400000000, 0xc6e282e300000000, 0x86dc5b8600000000,\n    0x46b8739100000000, 0x06150ba800000000, 0xc67123bf00000000,\n    0x04b1d14200000000, 0xc4d5f95500000000, 0x8478816c00000000,\n    0x441ca97b00000000, 0x0422701e00000000, 0xc446580900000000,\n    0x84eb203000000000, 0x448f082700000000, 0x049792fb00000000,\n    0xc4f3baec00000000, 0x845ec2d500000000, 0x443aeac200000000,\n    0x040433a700000000, 0xc4601bb000000000, 0x84cd638900000000,\n    0x44a94b9e00000000, 0x45fb26eb00000000, 0x859f0efc00000000,\n    0xc53276c500000000, 0x05565ed200000000, 0x456887b700000000,\n    0x850cafa000000000, 0xc5a1d79900000000, 0x05c5ff8e00000000,\n    0x45dd655200000000, 0x85b94d4500000000, 0xc514357c00000000,\n    0x05701d6b00000000, 0x454ec40e00000000, 0x852aec1900000000,\n    0xc587942000000000, 0x05e3bc3700000000, 0xcf41ed4f00000000,\n    0x0f25c55800000000, 0x4f88bd6100000000, 0x8fec957600000000,\n    0xcfd24c1300000000, 0x0fb6640400000000, 0x4f1b1c3d00000000,\n    0x8f7f342a00000000, 0xcf67aef600000000, 0x0f0386e100000000,\n    0x4faefed800000000, 0x8fcad6cf00000000, 0xcff40faa00000000,\n    0x0f9027bd00000000, 0x4f3d5f8400000000, 0x8f59779300000000,\n    0x8e0b1ae600000000, 0x4e6f32f100000000, 0x0ec24ac800000000,\n    0xcea662df00000000, 0x8e98bbba00000000, 0x4efc93ad00000000,\n    0x0e51eb9400000000, 0xce35c38300000000, 0x8e2d595f00000000,\n    0x4e49714800000000, 0x0ee4097100000000, 0xce80216600000000,\n    0x8ebef80300000000, 0x4edad01400000000, 0x0e77a82d00000000,\n    0xce13803a00000000, 0x0cd372c700000000, 0xccb75ad000000000,\n    0x8c1a22e900000000, 0x4c7e0afe00000000, 0x0c40d39b00000000,\n    0xcc24fb8c00000000, 0x8c8983b500000000, 0x4cedaba200000000,\n    0x0cf5317e00000000, 0xcc91196900000000, 0x8c3c615000000000,\n    0x4c58494700000000, 0x0c66902200000000, 0xcc02b83500000000,\n    0x8cafc00c00000000, 0x4ccbe81b00000000, 0x4d99856e00000000,\n    0x8dfdad7900000000, 0xcd50d54000000000, 0x0d34fd5700000000,\n    0x4d0a243200000000, 0x8d6e0c2500000000, 0xcdc3741c00000000,\n    0x0da75c0b00000000, 0x4dbfc6d700000000, 0x8ddbeec000000000,\n    0xcd7696f900000000, 0x0d12beee00000000, 0x4d2c678b00000000,\n    0x8d484f9c00000000, 0xcde537a500000000, 0x0d811fb200000000,\n    0x0862a38500000000, 0xc8068b9200000000, 0x88abf3ab00000000,\n    0x48cfdbbc00000000, 0x08f102d900000000, 0xc8952ace00000000,\n    0x883852f700000000, 0x485c7ae000000000, 0x0844e03c00000000,\n    0xc820c82b00000000, 0x888db01200000000, 0x48e9980500000000,\n    0x08d7416000000000, 0xc8b3697700000000, 0x881e114e00000000,\n    0x487a395900000000, 0x4928542c00000000, 0x894c7c3b00000000,\n    0xc9e1040200000000, 0x09852c1500000000, 0x49bbf57000000000,\n    0x89dfdd6700000000, 0xc972a55e00000000, 0x09168d4900000000,\n    0x490e179500000000, 0x896a3f8200000000, 0xc9c747bb00000000,\n    0x09a36fac00000000, 0x499db6c900000000, 0x89f99ede00000000,\n    0xc954e6e700000000, 0x0930cef000000000, 0xcbf03c0d00000000,\n    0x0b94141a00000000, 0x4b396c2300000000, 0x8b5d443400000000,\n    0xcb639d5100000000, 0x0b07b54600000000, 0x4baacd7f00000000,\n    0x8bcee56800000000, 0xcbd67fb400000000, 0x0bb257a300000000,\n    0x4b1f2f9a00000000, 0x8b7b078d00000000, 0xcb45dee800000000,\n    0x0b21f6ff00000000, 0x4b8c8ec600000000, 0x8be8a6d100000000,\n    0x8abacba400000000, 0x4adee3b300000000, 0x0a739b8a00000000,\n    0xca17b39d00000000, 0x8a296af800000000, 0x4a4d42ef00000000,\n    0x0ae03ad600000000, 0xca8412c100000000, 0x8a9c881d00000000,\n    0x4af8a00a00000000, 0x0a55d83300000000, 0xca31f02400000000,\n    0x8a0f294100000000, 0x4a6b015600000000, 0x0ac6796f00000000,\n    0xcaa2517800000000},\n   {0x0000000000000000, 0xd4ea739b00000000, 0xe9d396ed00000000,\n    0x3d39e57600000000, 0x93a15c0000000000, 0x474b2f9b00000000,\n    0x7a72caed00000000, 0xae98b97600000000, 0x2643b90000000000,\n    0xf2a9ca9b00000000, 0xcf902fed00000000, 0x1b7a5c7600000000,\n    0xb5e2e50000000000, 0x6108969b00000000, 0x5c3173ed00000000,\n    0x88db007600000000, 0x4c86720100000000, 0x986c019a00000000,\n    0xa555e4ec00000000, 0x71bf977700000000, 0xdf272e0100000000,\n    0x0bcd5d9a00000000, 0x36f4b8ec00000000, 0xe21ecb7700000000,\n    0x6ac5cb0100000000, 0xbe2fb89a00000000, 0x83165dec00000000,\n    0x57fc2e7700000000, 0xf964970100000000, 0x2d8ee49a00000000,\n    0x10b701ec00000000, 0xc45d727700000000, 0x980ce50200000000,\n    0x4ce6969900000000, 0x71df73ef00000000, 0xa535007400000000,\n    0x0badb90200000000, 0xdf47ca9900000000, 0xe27e2fef00000000,\n    0x36945c7400000000, 0xbe4f5c0200000000, 0x6aa52f9900000000,\n    0x579ccaef00000000, 0x8376b97400000000, 0x2dee000200000000,\n    0xf904739900000000, 0xc43d96ef00000000, 0x10d7e57400000000,\n    0xd48a970300000000, 0x0060e49800000000, 0x3d5901ee00000000,\n    0xe9b3727500000000, 0x472bcb0300000000, 0x93c1b89800000000,\n    0xaef85dee00000000, 0x7a122e7500000000, 0xf2c92e0300000000,\n    0x26235d9800000000, 0x1b1ab8ee00000000, 0xcff0cb7500000000,\n    0x6168720300000000, 0xb582019800000000, 0x88bbe4ee00000000,\n    0x5c51977500000000, 0x3019ca0500000000, 0xe4f3b99e00000000,\n    0xd9ca5ce800000000, 0x0d202f7300000000, 0xa3b8960500000000,\n    0x7752e59e00000000, 0x4a6b00e800000000, 0x9e81737300000000,\n    0x165a730500000000, 0xc2b0009e00000000, 0xff89e5e800000000,\n    0x2b63967300000000, 0x85fb2f0500000000, 0x51115c9e00000000,\n    0x6c28b9e800000000, 0xb8c2ca7300000000, 0x7c9fb80400000000,\n    0xa875cb9f00000000, 0x954c2ee900000000, 0x41a65d7200000000,\n    0xef3ee40400000000, 0x3bd4979f00000000, 0x06ed72e900000000,\n    0xd207017200000000, 0x5adc010400000000, 0x8e36729f00000000,\n    0xb30f97e900000000, 0x67e5e47200000000, 0xc97d5d0400000000,\n    0x1d972e9f00000000, 0x20aecbe900000000, 0xf444b87200000000,\n    0xa8152f0700000000, 0x7cff5c9c00000000, 0x41c6b9ea00000000,\n    0x952cca7100000000, 0x3bb4730700000000, 0xef5e009c00000000,\n    0xd267e5ea00000000, 0x068d967100000000, 0x8e56960700000000,\n    0x5abce59c00000000, 0x678500ea00000000, 0xb36f737100000000,\n    0x1df7ca0700000000, 0xc91db99c00000000, 0xf4245cea00000000,\n    0x20ce2f7100000000, 0xe4935d0600000000, 0x30792e9d00000000,\n    0x0d40cbeb00000000, 0xd9aab87000000000, 0x7732010600000000,\n    0xa3d8729d00000000, 0x9ee197eb00000000, 0x4a0be47000000000,\n    0xc2d0e40600000000, 0x163a979d00000000, 0x2b0372eb00000000,\n    0xffe9017000000000, 0x5171b80600000000, 0x859bcb9d00000000,\n    0xb8a22eeb00000000, 0x6c485d7000000000, 0x6032940b00000000,\n    0xb4d8e79000000000, 0x89e102e600000000, 0x5d0b717d00000000,\n    0xf393c80b00000000, 0x2779bb9000000000, 0x1a405ee600000000,\n    0xceaa2d7d00000000, 0x46712d0b00000000, 0x929b5e9000000000,\n    0xafa2bbe600000000, 0x7b48c87d00000000, 0xd5d0710b00000000,\n    0x013a029000000000, 0x3c03e7e600000000, 0xe8e9947d00000000,\n    0x2cb4e60a00000000, 0xf85e959100000000, 0xc56770e700000000,\n    0x118d037c00000000, 0xbf15ba0a00000000, 0x6bffc99100000000,\n    0x56c62ce700000000, 0x822c5f7c00000000, 0x0af75f0a00000000,\n    0xde1d2c9100000000, 0xe324c9e700000000, 0x37ceba7c00000000,\n    0x9956030a00000000, 0x4dbc709100000000, 0x708595e700000000,\n    0xa46fe67c00000000, 0xf83e710900000000, 0x2cd4029200000000,\n    0x11ede7e400000000, 0xc507947f00000000, 0x6b9f2d0900000000,\n    0xbf755e9200000000, 0x824cbbe400000000, 0x56a6c87f00000000,\n    0xde7dc80900000000, 0x0a97bb9200000000, 0x37ae5ee400000000,\n    0xe3442d7f00000000, 0x4ddc940900000000, 0x9936e79200000000,\n    0xa40f02e400000000, 0x70e5717f00000000, 0xb4b8030800000000,\n    0x6052709300000000, 0x5d6b95e500000000, 0x8981e67e00000000,\n    0x27195f0800000000, 0xf3f32c9300000000, 0xcecac9e500000000,\n    0x1a20ba7e00000000, 0x92fbba0800000000, 0x4611c99300000000,\n    0x7b282ce500000000, 0xafc25f7e00000000, 0x015ae60800000000,\n    0xd5b0959300000000, 0xe88970e500000000, 0x3c63037e00000000,\n    0x502b5e0e00000000, 0x84c12d9500000000, 0xb9f8c8e300000000,\n    0x6d12bb7800000000, 0xc38a020e00000000, 0x1760719500000000,\n    0x2a5994e300000000, 0xfeb3e77800000000, 0x7668e70e00000000,\n    0xa282949500000000, 0x9fbb71e300000000, 0x4b51027800000000,\n    0xe5c9bb0e00000000, 0x3123c89500000000, 0x0c1a2de300000000,\n    0xd8f05e7800000000, 0x1cad2c0f00000000, 0xc8475f9400000000,\n    0xf57ebae200000000, 0x2194c97900000000, 0x8f0c700f00000000,\n    0x5be6039400000000, 0x66dfe6e200000000, 0xb235957900000000,\n    0x3aee950f00000000, 0xee04e69400000000, 0xd33d03e200000000,\n    0x07d7707900000000, 0xa94fc90f00000000, 0x7da5ba9400000000,\n    0x409c5fe200000000, 0x94762c7900000000, 0xc827bb0c00000000,\n    0x1ccdc89700000000, 0x21f42de100000000, 0xf51e5e7a00000000,\n    0x5b86e70c00000000, 0x8f6c949700000000, 0xb25571e100000000,\n    0x66bf027a00000000, 0xee64020c00000000, 0x3a8e719700000000,\n    0x07b794e100000000, 0xd35de77a00000000, 0x7dc55e0c00000000,\n    0xa92f2d9700000000, 0x9416c8e100000000, 0x40fcbb7a00000000,\n    0x84a1c90d00000000, 0x504bba9600000000, 0x6d725fe000000000,\n    0xb9982c7b00000000, 0x1700950d00000000, 0xc3eae69600000000,\n    0xfed303e000000000, 0x2a39707b00000000, 0xa2e2700d00000000,\n    0x7608039600000000, 0x4b31e6e000000000, 0x9fdb957b00000000,\n    0x31432c0d00000000, 0xe5a95f9600000000, 0xd890bae000000000,\n    0x0c7ac97b00000000},\n   {0x0000000000000000, 0x2765258100000000, 0x0fcc3bd900000000,\n    0x28a91e5800000000, 0x5f9e066900000000, 0x78fb23e800000000,\n    0x50523db000000000, 0x7737183100000000, 0xbe3c0dd200000000,\n    0x9959285300000000, 0xb1f0360b00000000, 0x9695138a00000000,\n    0xe1a20bbb00000000, 0xc6c72e3a00000000, 0xee6e306200000000,\n    0xc90b15e300000000, 0x3d7f6b7f00000000, 0x1a1a4efe00000000,\n    0x32b350a600000000, 0x15d6752700000000, 0x62e16d1600000000,\n    0x4584489700000000, 0x6d2d56cf00000000, 0x4a48734e00000000,\n    0x834366ad00000000, 0xa426432c00000000, 0x8c8f5d7400000000,\n    0xabea78f500000000, 0xdcdd60c400000000, 0xfbb8454500000000,\n    0xd3115b1d00000000, 0xf4747e9c00000000, 0x7afed6fe00000000,\n    0x5d9bf37f00000000, 0x7532ed2700000000, 0x5257c8a600000000,\n    0x2560d09700000000, 0x0205f51600000000, 0x2aaceb4e00000000,\n    0x0dc9cecf00000000, 0xc4c2db2c00000000, 0xe3a7fead00000000,\n    0xcb0ee0f500000000, 0xec6bc57400000000, 0x9b5cdd4500000000,\n    0xbc39f8c400000000, 0x9490e69c00000000, 0xb3f5c31d00000000,\n    0x4781bd8100000000, 0x60e4980000000000, 0x484d865800000000,\n    0x6f28a3d900000000, 0x181fbbe800000000, 0x3f7a9e6900000000,\n    0x17d3803100000000, 0x30b6a5b000000000, 0xf9bdb05300000000,\n    0xded895d200000000, 0xf6718b8a00000000, 0xd114ae0b00000000,\n    0xa623b63a00000000, 0x814693bb00000000, 0xa9ef8de300000000,\n    0x8e8aa86200000000, 0xb5fadc2600000000, 0x929ff9a700000000,\n    0xba36e7ff00000000, 0x9d53c27e00000000, 0xea64da4f00000000,\n    0xcd01ffce00000000, 0xe5a8e19600000000, 0xc2cdc41700000000,\n    0x0bc6d1f400000000, 0x2ca3f47500000000, 0x040aea2d00000000,\n    0x236fcfac00000000, 0x5458d79d00000000, 0x733df21c00000000,\n    0x5b94ec4400000000, 0x7cf1c9c500000000, 0x8885b75900000000,\n    0xafe092d800000000, 0x87498c8000000000, 0xa02ca90100000000,\n    0xd71bb13000000000, 0xf07e94b100000000, 0xd8d78ae900000000,\n    0xffb2af6800000000, 0x36b9ba8b00000000, 0x11dc9f0a00000000,\n    0x3975815200000000, 0x1e10a4d300000000, 0x6927bce200000000,\n    0x4e42996300000000, 0x66eb873b00000000, 0x418ea2ba00000000,\n    0xcf040ad800000000, 0xe8612f5900000000, 0xc0c8310100000000,\n    0xe7ad148000000000, 0x909a0cb100000000, 0xb7ff293000000000,\n    0x9f56376800000000, 0xb83312e900000000, 0x7138070a00000000,\n    0x565d228b00000000, 0x7ef43cd300000000, 0x5991195200000000,\n    0x2ea6016300000000, 0x09c324e200000000, 0x216a3aba00000000,\n    0x060f1f3b00000000, 0xf27b61a700000000, 0xd51e442600000000,\n    0xfdb75a7e00000000, 0xdad27fff00000000, 0xade567ce00000000,\n    0x8a80424f00000000, 0xa2295c1700000000, 0x854c799600000000,\n    0x4c476c7500000000, 0x6b2249f400000000, 0x438b57ac00000000,\n    0x64ee722d00000000, 0x13d96a1c00000000, 0x34bc4f9d00000000,\n    0x1c1551c500000000, 0x3b70744400000000, 0x6af5b94d00000000,\n    0x4d909ccc00000000, 0x6539829400000000, 0x425ca71500000000,\n    0x356bbf2400000000, 0x120e9aa500000000, 0x3aa784fd00000000,\n    0x1dc2a17c00000000, 0xd4c9b49f00000000, 0xf3ac911e00000000,\n    0xdb058f4600000000, 0xfc60aac700000000, 0x8b57b2f600000000,\n    0xac32977700000000, 0x849b892f00000000, 0xa3feacae00000000,\n    0x578ad23200000000, 0x70eff7b300000000, 0x5846e9eb00000000,\n    0x7f23cc6a00000000, 0x0814d45b00000000, 0x2f71f1da00000000,\n    0x07d8ef8200000000, 0x20bdca0300000000, 0xe9b6dfe000000000,\n    0xced3fa6100000000, 0xe67ae43900000000, 0xc11fc1b800000000,\n    0xb628d98900000000, 0x914dfc0800000000, 0xb9e4e25000000000,\n    0x9e81c7d100000000, 0x100b6fb300000000, 0x376e4a3200000000,\n    0x1fc7546a00000000, 0x38a271eb00000000, 0x4f9569da00000000,\n    0x68f04c5b00000000, 0x4059520300000000, 0x673c778200000000,\n    0xae37626100000000, 0x895247e000000000, 0xa1fb59b800000000,\n    0x869e7c3900000000, 0xf1a9640800000000, 0xd6cc418900000000,\n    0xfe655fd100000000, 0xd9007a5000000000, 0x2d7404cc00000000,\n    0x0a11214d00000000, 0x22b83f1500000000, 0x05dd1a9400000000,\n    0x72ea02a500000000, 0x558f272400000000, 0x7d26397c00000000,\n    0x5a431cfd00000000, 0x9348091e00000000, 0xb42d2c9f00000000,\n    0x9c8432c700000000, 0xbbe1174600000000, 0xccd60f7700000000,\n    0xebb32af600000000, 0xc31a34ae00000000, 0xe47f112f00000000,\n    0xdf0f656b00000000, 0xf86a40ea00000000, 0xd0c35eb200000000,\n    0xf7a67b3300000000, 0x8091630200000000, 0xa7f4468300000000,\n    0x8f5d58db00000000, 0xa8387d5a00000000, 0x613368b900000000,\n    0x46564d3800000000, 0x6eff536000000000, 0x499a76e100000000,\n    0x3ead6ed000000000, 0x19c84b5100000000, 0x3161550900000000,\n    0x1604708800000000, 0xe2700e1400000000, 0xc5152b9500000000,\n    0xedbc35cd00000000, 0xcad9104c00000000, 0xbdee087d00000000,\n    0x9a8b2dfc00000000, 0xb22233a400000000, 0x9547162500000000,\n    0x5c4c03c600000000, 0x7b29264700000000, 0x5380381f00000000,\n    0x74e51d9e00000000, 0x03d205af00000000, 0x24b7202e00000000,\n    0x0c1e3e7600000000, 0x2b7b1bf700000000, 0xa5f1b39500000000,\n    0x8294961400000000, 0xaa3d884c00000000, 0x8d58adcd00000000,\n    0xfa6fb5fc00000000, 0xdd0a907d00000000, 0xf5a38e2500000000,\n    0xd2c6aba400000000, 0x1bcdbe4700000000, 0x3ca89bc600000000,\n    0x1401859e00000000, 0x3364a01f00000000, 0x4453b82e00000000,\n    0x63369daf00000000, 0x4b9f83f700000000, 0x6cfaa67600000000,\n    0x988ed8ea00000000, 0xbfebfd6b00000000, 0x9742e33300000000,\n    0xb027c6b200000000, 0xc710de8300000000, 0xe075fb0200000000,\n    0xc8dce55a00000000, 0xefb9c0db00000000, 0x26b2d53800000000,\n    0x01d7f0b900000000, 0x297eeee100000000, 0x0e1bcb6000000000,\n    0x792cd35100000000, 0x5e49f6d000000000, 0x76e0e88800000000,\n    0x5185cd0900000000}};\n\n#else /* W == 4 */\n\nlocal const z_crc_t FAR crc_braid_table[][256] = {\n   {0x00000000, 0x9ba54c6f, 0xec3b9e9f, 0x779ed2f0, 0x03063b7f,\n    0x98a37710, 0xef3da5e0, 0x7498e98f, 0x060c76fe, 0x9da93a91,\n    0xea37e861, 0x7192a40e, 0x050a4d81, 0x9eaf01ee, 0xe931d31e,\n    0x72949f71, 0x0c18edfc, 0x97bda193, 0xe0237363, 0x7b863f0c,\n    0x0f1ed683, 0x94bb9aec, 0xe325481c, 0x78800473, 0x0a149b02,\n    0x91b1d76d, 0xe62f059d, 0x7d8a49f2, 0x0912a07d, 0x92b7ec12,\n    0xe5293ee2, 0x7e8c728d, 0x1831dbf8, 0x83949797, 0xf40a4567,\n    0x6faf0908, 0x1b37e087, 0x8092ace8, 0xf70c7e18, 0x6ca93277,\n    0x1e3dad06, 0x8598e169, 0xf2063399, 0x69a37ff6, 0x1d3b9679,\n    0x869eda16, 0xf10008e6, 0x6aa54489, 0x14293604, 0x8f8c7a6b,\n    0xf812a89b, 0x63b7e4f4, 0x172f0d7b, 0x8c8a4114, 0xfb1493e4,\n    0x60b1df8b, 0x122540fa, 0x89800c95, 0xfe1ede65, 0x65bb920a,\n    0x11237b85, 0x8a8637ea, 0xfd18e51a, 0x66bda975, 0x3063b7f0,\n    0xabc6fb9f, 0xdc58296f, 0x47fd6500, 0x33658c8f, 0xa8c0c0e0,\n    0xdf5e1210, 0x44fb5e7f, 0x366fc10e, 0xadca8d61, 0xda545f91,\n    0x41f113fe, 0x3569fa71, 0xaeccb61e, 0xd95264ee, 0x42f72881,\n    0x3c7b5a0c, 0xa7de1663, 0xd040c493, 0x4be588fc, 0x3f7d6173,\n    0xa4d82d1c, 0xd346ffec, 0x48e3b383, 0x3a772cf2, 0xa1d2609d,\n    0xd64cb26d, 0x4de9fe02, 0x3971178d, 0xa2d45be2, 0xd54a8912,\n    0x4eefc57d, 0x28526c08, 0xb3f72067, 0xc469f297, 0x5fccbef8,\n    0x2b545777, 0xb0f11b18, 0xc76fc9e8, 0x5cca8587, 0x2e5e1af6,\n    0xb5fb5699, 0xc2658469, 0x59c0c806, 0x2d582189, 0xb6fd6de6,\n    0xc163bf16, 0x5ac6f379, 0x244a81f4, 0xbfefcd9b, 0xc8711f6b,\n    0x53d45304, 0x274cba8b, 0xbce9f6e4, 0xcb772414, 0x50d2687b,\n    0x2246f70a, 0xb9e3bb65, 0xce7d6995, 0x55d825fa, 0x2140cc75,\n    0xbae5801a, 0xcd7b52ea, 0x56de1e85, 0x60c76fe0, 0xfb62238f,\n    0x8cfcf17f, 0x1759bd10, 0x63c1549f, 0xf86418f0, 0x8ffaca00,\n    0x145f866f, 0x66cb191e, 0xfd6e5571, 0x8af08781, 0x1155cbee,\n    0x65cd2261, 0xfe686e0e, 0x89f6bcfe, 0x1253f091, 0x6cdf821c,\n    0xf77ace73, 0x80e41c83, 0x1b4150ec, 0x6fd9b963, 0xf47cf50c,\n    0x83e227fc, 0x18476b93, 0x6ad3f4e2, 0xf176b88d, 0x86e86a7d,\n    0x1d4d2612, 0x69d5cf9d, 0xf27083f2, 0x85ee5102, 0x1e4b1d6d,\n    0x78f6b418, 0xe353f877, 0x94cd2a87, 0x0f6866e8, 0x7bf08f67,\n    0xe055c308, 0x97cb11f8, 0x0c6e5d97, 0x7efac2e6, 0xe55f8e89,\n    0x92c15c79, 0x09641016, 0x7dfcf999, 0xe659b5f6, 0x91c76706,\n    0x0a622b69, 0x74ee59e4, 0xef4b158b, 0x98d5c77b, 0x03708b14,\n    0x77e8629b, 0xec4d2ef4, 0x9bd3fc04, 0x0076b06b, 0x72e22f1a,\n    0xe9476375, 0x9ed9b185, 0x057cfdea, 0x71e41465, 0xea41580a,\n    0x9ddf8afa, 0x067ac695, 0x50a4d810, 0xcb01947f, 0xbc9f468f,\n    0x273a0ae0, 0x53a2e36f, 0xc807af00, 0xbf997df0, 0x243c319f,\n    0x56a8aeee, 0xcd0de281, 0xba933071, 0x21367c1e, 0x55ae9591,\n    0xce0bd9fe, 0xb9950b0e, 0x22304761, 0x5cbc35ec, 0xc7197983,\n    0xb087ab73, 0x2b22e71c, 0x5fba0e93, 0xc41f42fc, 0xb381900c,\n    0x2824dc63, 0x5ab04312, 0xc1150f7d, 0xb68bdd8d, 0x2d2e91e2,\n    0x59b6786d, 0xc2133402, 0xb58de6f2, 0x2e28aa9d, 0x489503e8,\n    0xd3304f87, 0xa4ae9d77, 0x3f0bd118, 0x4b933897, 0xd03674f8,\n    0xa7a8a608, 0x3c0dea67, 0x4e997516, 0xd53c3979, 0xa2a2eb89,\n    0x3907a7e6, 0x4d9f4e69, 0xd63a0206, 0xa1a4d0f6, 0x3a019c99,\n    0x448dee14, 0xdf28a27b, 0xa8b6708b, 0x33133ce4, 0x478bd56b,\n    0xdc2e9904, 0xabb04bf4, 0x3015079b, 0x428198ea, 0xd924d485,\n    0xaeba0675, 0x351f4a1a, 0x4187a395, 0xda22effa, 0xadbc3d0a,\n    0x36197165},\n   {0x00000000, 0xc18edfc0, 0x586cb9c1, 0x99e26601, 0xb0d97382,\n    0x7157ac42, 0xe8b5ca43, 0x293b1583, 0xbac3e145, 0x7b4d3e85,\n    0xe2af5884, 0x23218744, 0x0a1a92c7, 0xcb944d07, 0x52762b06,\n    0x93f8f4c6, 0xaef6c4cb, 0x6f781b0b, 0xf69a7d0a, 0x3714a2ca,\n    0x1e2fb749, 0xdfa16889, 0x46430e88, 0x87cdd148, 0x1435258e,\n    0xd5bbfa4e, 0x4c599c4f, 0x8dd7438f, 0xa4ec560c, 0x656289cc,\n    0xfc80efcd, 0x3d0e300d, 0x869c8fd7, 0x47125017, 0xdef03616,\n    0x1f7ee9d6, 0x3645fc55, 0xf7cb2395, 0x6e294594, 0xafa79a54,\n    0x3c5f6e92, 0xfdd1b152, 0x6433d753, 0xa5bd0893, 0x8c861d10,\n    0x4d08c2d0, 0xd4eaa4d1, 0x15647b11, 0x286a4b1c, 0xe9e494dc,\n    0x7006f2dd, 0xb1882d1d, 0x98b3389e, 0x593de75e, 0xc0df815f,\n    0x01515e9f, 0x92a9aa59, 0x53277599, 0xcac51398, 0x0b4bcc58,\n    0x2270d9db, 0xe3fe061b, 0x7a1c601a, 0xbb92bfda, 0xd64819ef,\n    0x17c6c62f, 0x8e24a02e, 0x4faa7fee, 0x66916a6d, 0xa71fb5ad,\n    0x3efdd3ac, 0xff730c6c, 0x6c8bf8aa, 0xad05276a, 0x34e7416b,\n    0xf5699eab, 0xdc528b28, 0x1ddc54e8, 0x843e32e9, 0x45b0ed29,\n    0x78bedd24, 0xb93002e4, 0x20d264e5, 0xe15cbb25, 0xc867aea6,\n    0x09e97166, 0x900b1767, 0x5185c8a7, 0xc27d3c61, 0x03f3e3a1,\n    0x9a1185a0, 0x5b9f5a60, 0x72a44fe3, 0xb32a9023, 0x2ac8f622,\n    0xeb4629e2, 0x50d49638, 0x915a49f8, 0x08b82ff9, 0xc936f039,\n    0xe00de5ba, 0x21833a7a, 0xb8615c7b, 0x79ef83bb, 0xea17777d,\n    0x2b99a8bd, 0xb27bcebc, 0x73f5117c, 0x5ace04ff, 0x9b40db3f,\n    0x02a2bd3e, 0xc32c62fe, 0xfe2252f3, 0x3fac8d33, 0xa64eeb32,\n    0x67c034f2, 0x4efb2171, 0x8f75feb1, 0x169798b0, 0xd7194770,\n    0x44e1b3b6, 0x856f6c76, 0x1c8d0a77, 0xdd03d5b7, 0xf438c034,\n    0x35b61ff4, 0xac5479f5, 0x6ddaa635, 0x77e1359f, 0xb66fea5f,\n    0x2f8d8c5e, 0xee03539e, 0xc738461d, 0x06b699dd, 0x9f54ffdc,\n    0x5eda201c, 0xcd22d4da, 0x0cac0b1a, 0x954e6d1b, 0x54c0b2db,\n    0x7dfba758, 0xbc757898, 0x25971e99, 0xe419c159, 0xd917f154,\n    0x18992e94, 0x817b4895, 0x40f59755, 0x69ce82d6, 0xa8405d16,\n    0x31a23b17, 0xf02ce4d7, 0x63d41011, 0xa25acfd1, 0x3bb8a9d0,\n    0xfa367610, 0xd30d6393, 0x1283bc53, 0x8b61da52, 0x4aef0592,\n    0xf17dba48, 0x30f36588, 0xa9110389, 0x689fdc49, 0x41a4c9ca,\n    0x802a160a, 0x19c8700b, 0xd846afcb, 0x4bbe5b0d, 0x8a3084cd,\n    0x13d2e2cc, 0xd25c3d0c, 0xfb67288f, 0x3ae9f74f, 0xa30b914e,\n    0x62854e8e, 0x5f8b7e83, 0x9e05a143, 0x07e7c742, 0xc6691882,\n    0xef520d01, 0x2edcd2c1, 0xb73eb4c0, 0x76b06b00, 0xe5489fc6,\n    0x24c64006, 0xbd242607, 0x7caaf9c7, 0x5591ec44, 0x941f3384,\n    0x0dfd5585, 0xcc738a45, 0xa1a92c70, 0x6027f3b0, 0xf9c595b1,\n    0x384b4a71, 0x11705ff2, 0xd0fe8032, 0x491ce633, 0x889239f3,\n    0x1b6acd35, 0xdae412f5, 0x430674f4, 0x8288ab34, 0xabb3beb7,\n    0x6a3d6177, 0xf3df0776, 0x3251d8b6, 0x0f5fe8bb, 0xced1377b,\n    0x5733517a, 0x96bd8eba, 0xbf869b39, 0x7e0844f9, 0xe7ea22f8,\n    0x2664fd38, 0xb59c09fe, 0x7412d63e, 0xedf0b03f, 0x2c7e6fff,\n    0x05457a7c, 0xc4cba5bc, 0x5d29c3bd, 0x9ca71c7d, 0x2735a3a7,\n    0xe6bb7c67, 0x7f591a66, 0xbed7c5a6, 0x97ecd025, 0x56620fe5,\n    0xcf8069e4, 0x0e0eb624, 0x9df642e2, 0x5c789d22, 0xc59afb23,\n    0x041424e3, 0x2d2f3160, 0xeca1eea0, 0x754388a1, 0xb4cd5761,\n    0x89c3676c, 0x484db8ac, 0xd1afdead, 0x1021016d, 0x391a14ee,\n    0xf894cb2e, 0x6176ad2f, 0xa0f872ef, 0x33008629, 0xf28e59e9,\n    0x6b6c3fe8, 0xaae2e028, 0x83d9f5ab, 0x42572a6b, 0xdbb54c6a,\n    0x1a3b93aa},\n   {0x00000000, 0xefc26b3e, 0x04f5d03d, 0xeb37bb03, 0x09eba07a,\n    0xe629cb44, 0x0d1e7047, 0xe2dc1b79, 0x13d740f4, 0xfc152bca,\n    0x172290c9, 0xf8e0fbf7, 0x1a3ce08e, 0xf5fe8bb0, 0x1ec930b3,\n    0xf10b5b8d, 0x27ae81e8, 0xc86cead6, 0x235b51d5, 0xcc993aeb,\n    0x2e452192, 0xc1874aac, 0x2ab0f1af, 0xc5729a91, 0x3479c11c,\n    0xdbbbaa22, 0x308c1121, 0xdf4e7a1f, 0x3d926166, 0xd2500a58,\n    0x3967b15b, 0xd6a5da65, 0x4f5d03d0, 0xa09f68ee, 0x4ba8d3ed,\n    0xa46ab8d3, 0x46b6a3aa, 0xa974c894, 0x42437397, 0xad8118a9,\n    0x5c8a4324, 0xb348281a, 0x587f9319, 0xb7bdf827, 0x5561e35e,\n    0xbaa38860, 0x51943363, 0xbe56585d, 0x68f38238, 0x8731e906,\n    0x6c065205, 0x83c4393b, 0x61182242, 0x8eda497c, 0x65edf27f,\n    0x8a2f9941, 0x7b24c2cc, 0x94e6a9f2, 0x7fd112f1, 0x901379cf,\n    0x72cf62b6, 0x9d0d0988, 0x763ab28b, 0x99f8d9b5, 0x9eba07a0,\n    0x71786c9e, 0x9a4fd79d, 0x758dbca3, 0x9751a7da, 0x7893cce4,\n    0x93a477e7, 0x7c661cd9, 0x8d6d4754, 0x62af2c6a, 0x89989769,\n    0x665afc57, 0x8486e72e, 0x6b448c10, 0x80733713, 0x6fb15c2d,\n    0xb9148648, 0x56d6ed76, 0xbde15675, 0x52233d4b, 0xb0ff2632,\n    0x5f3d4d0c, 0xb40af60f, 0x5bc89d31, 0xaac3c6bc, 0x4501ad82,\n    0xae361681, 0x41f47dbf, 0xa32866c6, 0x4cea0df8, 0xa7ddb6fb,\n    0x481fddc5, 0xd1e70470, 0x3e256f4e, 0xd512d44d, 0x3ad0bf73,\n    0xd80ca40a, 0x37cecf34, 0xdcf97437, 0x333b1f09, 0xc2304484,\n    0x2df22fba, 0xc6c594b9, 0x2907ff87, 0xcbdbe4fe, 0x24198fc0,\n    0xcf2e34c3, 0x20ec5ffd, 0xf6498598, 0x198beea6, 0xf2bc55a5,\n    0x1d7e3e9b, 0xffa225e2, 0x10604edc, 0xfb57f5df, 0x14959ee1,\n    0xe59ec56c, 0x0a5cae52, 0xe16b1551, 0x0ea97e6f, 0xec756516,\n    0x03b70e28, 0xe880b52b, 0x0742de15, 0xe6050901, 0x09c7623f,\n    0xe2f0d93c, 0x0d32b202, 0xefeea97b, 0x002cc245, 0xeb1b7946,\n    0x04d91278, 0xf5d249f5, 0x1a1022cb, 0xf12799c8, 0x1ee5f2f6,\n    0xfc39e98f, 0x13fb82b1, 0xf8cc39b2, 0x170e528c, 0xc1ab88e9,\n    0x2e69e3d7, 0xc55e58d4, 0x2a9c33ea, 0xc8402893, 0x278243ad,\n    0xccb5f8ae, 0x23779390, 0xd27cc81d, 0x3dbea323, 0xd6891820,\n    0x394b731e, 0xdb976867, 0x34550359, 0xdf62b85a, 0x30a0d364,\n    0xa9580ad1, 0x469a61ef, 0xadaddaec, 0x426fb1d2, 0xa0b3aaab,\n    0x4f71c195, 0xa4467a96, 0x4b8411a8, 0xba8f4a25, 0x554d211b,\n    0xbe7a9a18, 0x51b8f126, 0xb364ea5f, 0x5ca68161, 0xb7913a62,\n    0x5853515c, 0x8ef68b39, 0x6134e007, 0x8a035b04, 0x65c1303a,\n    0x871d2b43, 0x68df407d, 0x83e8fb7e, 0x6c2a9040, 0x9d21cbcd,\n    0x72e3a0f3, 0x99d41bf0, 0x761670ce, 0x94ca6bb7, 0x7b080089,\n    0x903fbb8a, 0x7ffdd0b4, 0x78bf0ea1, 0x977d659f, 0x7c4ade9c,\n    0x9388b5a2, 0x7154aedb, 0x9e96c5e5, 0x75a17ee6, 0x9a6315d8,\n    0x6b684e55, 0x84aa256b, 0x6f9d9e68, 0x805ff556, 0x6283ee2f,\n    0x8d418511, 0x66763e12, 0x89b4552c, 0x5f118f49, 0xb0d3e477,\n    0x5be45f74, 0xb426344a, 0x56fa2f33, 0xb938440d, 0x520fff0e,\n    0xbdcd9430, 0x4cc6cfbd, 0xa304a483, 0x48331f80, 0xa7f174be,\n    0x452d6fc7, 0xaaef04f9, 0x41d8bffa, 0xae1ad4c4, 0x37e20d71,\n    0xd820664f, 0x3317dd4c, 0xdcd5b672, 0x3e09ad0b, 0xd1cbc635,\n    0x3afc7d36, 0xd53e1608, 0x24354d85, 0xcbf726bb, 0x20c09db8,\n    0xcf02f686, 0x2ddeedff, 0xc21c86c1, 0x292b3dc2, 0xc6e956fc,\n    0x104c8c99, 0xff8ee7a7, 0x14b95ca4, 0xfb7b379a, 0x19a72ce3,\n    0xf66547dd, 0x1d52fcde, 0xf29097e0, 0x039bcc6d, 0xec59a753,\n    0x076e1c50, 0xe8ac776e, 0x0a706c17, 0xe5b20729, 0x0e85bc2a,\n    0xe147d714},\n   {0x00000000, 0x177b1443, 0x2ef62886, 0x398d3cc5, 0x5dec510c,\n    0x4a97454f, 0x731a798a, 0x64616dc9, 0xbbd8a218, 0xaca3b65b,\n    0x952e8a9e, 0x82559edd, 0xe634f314, 0xf14fe757, 0xc8c2db92,\n    0xdfb9cfd1, 0xacc04271, 0xbbbb5632, 0x82366af7, 0x954d7eb4,\n    0xf12c137d, 0xe657073e, 0xdfda3bfb, 0xc8a12fb8, 0x1718e069,\n    0x0063f42a, 0x39eec8ef, 0x2e95dcac, 0x4af4b165, 0x5d8fa526,\n    0x640299e3, 0x73798da0, 0x82f182a3, 0x958a96e0, 0xac07aa25,\n    0xbb7cbe66, 0xdf1dd3af, 0xc866c7ec, 0xf1ebfb29, 0xe690ef6a,\n    0x392920bb, 0x2e5234f8, 0x17df083d, 0x00a41c7e, 0x64c571b7,\n    0x73be65f4, 0x4a335931, 0x5d484d72, 0x2e31c0d2, 0x394ad491,\n    0x00c7e854, 0x17bcfc17, 0x73dd91de, 0x64a6859d, 0x5d2bb958,\n    0x4a50ad1b, 0x95e962ca, 0x82927689, 0xbb1f4a4c, 0xac645e0f,\n    0xc80533c6, 0xdf7e2785, 0xe6f31b40, 0xf1880f03, 0xde920307,\n    0xc9e91744, 0xf0642b81, 0xe71f3fc2, 0x837e520b, 0x94054648,\n    0xad887a8d, 0xbaf36ece, 0x654aa11f, 0x7231b55c, 0x4bbc8999,\n    0x5cc79dda, 0x38a6f013, 0x2fdde450, 0x1650d895, 0x012bccd6,\n    0x72524176, 0x65295535, 0x5ca469f0, 0x4bdf7db3, 0x2fbe107a,\n    0x38c50439, 0x014838fc, 0x16332cbf, 0xc98ae36e, 0xdef1f72d,\n    0xe77ccbe8, 0xf007dfab, 0x9466b262, 0x831da621, 0xba909ae4,\n    0xadeb8ea7, 0x5c6381a4, 0x4b1895e7, 0x7295a922, 0x65eebd61,\n    0x018fd0a8, 0x16f4c4eb, 0x2f79f82e, 0x3802ec6d, 0xe7bb23bc,\n    0xf0c037ff, 0xc94d0b3a, 0xde361f79, 0xba5772b0, 0xad2c66f3,\n    0x94a15a36, 0x83da4e75, 0xf0a3c3d5, 0xe7d8d796, 0xde55eb53,\n    0xc92eff10, 0xad4f92d9, 0xba34869a, 0x83b9ba5f, 0x94c2ae1c,\n    0x4b7b61cd, 0x5c00758e, 0x658d494b, 0x72f65d08, 0x169730c1,\n    0x01ec2482, 0x38611847, 0x2f1a0c04, 0x6655004f, 0x712e140c,\n    0x48a328c9, 0x5fd83c8a, 0x3bb95143, 0x2cc24500, 0x154f79c5,\n    0x02346d86, 0xdd8da257, 0xcaf6b614, 0xf37b8ad1, 0xe4009e92,\n    0x8061f35b, 0x971ae718, 0xae97dbdd, 0xb9eccf9e, 0xca95423e,\n    0xddee567d, 0xe4636ab8, 0xf3187efb, 0x97791332, 0x80020771,\n    0xb98f3bb4, 0xaef42ff7, 0x714de026, 0x6636f465, 0x5fbbc8a0,\n    0x48c0dce3, 0x2ca1b12a, 0x3bdaa569, 0x025799ac, 0x152c8def,\n    0xe4a482ec, 0xf3df96af, 0xca52aa6a, 0xdd29be29, 0xb948d3e0,\n    0xae33c7a3, 0x97befb66, 0x80c5ef25, 0x5f7c20f4, 0x480734b7,\n    0x718a0872, 0x66f11c31, 0x029071f8, 0x15eb65bb, 0x2c66597e,\n    0x3b1d4d3d, 0x4864c09d, 0x5f1fd4de, 0x6692e81b, 0x71e9fc58,\n    0x15889191, 0x02f385d2, 0x3b7eb917, 0x2c05ad54, 0xf3bc6285,\n    0xe4c776c6, 0xdd4a4a03, 0xca315e40, 0xae503389, 0xb92b27ca,\n    0x80a61b0f, 0x97dd0f4c, 0xb8c70348, 0xafbc170b, 0x96312bce,\n    0x814a3f8d, 0xe52b5244, 0xf2504607, 0xcbdd7ac2, 0xdca66e81,\n    0x031fa150, 0x1464b513, 0x2de989d6, 0x3a929d95, 0x5ef3f05c,\n    0x4988e41f, 0x7005d8da, 0x677ecc99, 0x14074139, 0x037c557a,\n    0x3af169bf, 0x2d8a7dfc, 0x49eb1035, 0x5e900476, 0x671d38b3,\n    0x70662cf0, 0xafdfe321, 0xb8a4f762, 0x8129cba7, 0x9652dfe4,\n    0xf233b22d, 0xe548a66e, 0xdcc59aab, 0xcbbe8ee8, 0x3a3681eb,\n    0x2d4d95a8, 0x14c0a96d, 0x03bbbd2e, 0x67dad0e7, 0x70a1c4a4,\n    0x492cf861, 0x5e57ec22, 0x81ee23f3, 0x969537b0, 0xaf180b75,\n    0xb8631f36, 0xdc0272ff, 0xcb7966bc, 0xf2f45a79, 0xe58f4e3a,\n    0x96f6c39a, 0x818dd7d9, 0xb800eb1c, 0xaf7bff5f, 0xcb1a9296,\n    0xdc6186d5, 0xe5ecba10, 0xf297ae53, 0x2d2e6182, 0x3a5575c1,\n    0x03d84904, 0x14a35d47, 0x70c2308e, 0x67b924cd, 0x5e341808,\n    0x494f0c4b}};\n\nlocal const z_word_t FAR crc_braid_big_table[][256] = {\n   {0x00000000, 0x43147b17, 0x8628f62e, 0xc53c8d39, 0x0c51ec5d,\n    0x4f45974a, 0x8a791a73, 0xc96d6164, 0x18a2d8bb, 0x5bb6a3ac,\n    0x9e8a2e95, 0xdd9e5582, 0x14f334e6, 0x57e74ff1, 0x92dbc2c8,\n    0xd1cfb9df, 0x7142c0ac, 0x3256bbbb, 0xf76a3682, 0xb47e4d95,\n    0x7d132cf1, 0x3e0757e6, 0xfb3bdadf, 0xb82fa1c8, 0x69e01817,\n    0x2af46300, 0xefc8ee39, 0xacdc952e, 0x65b1f44a, 0x26a58f5d,\n    0xe3990264, 0xa08d7973, 0xa382f182, 0xe0968a95, 0x25aa07ac,\n    0x66be7cbb, 0xafd31ddf, 0xecc766c8, 0x29fbebf1, 0x6aef90e6,\n    0xbb202939, 0xf834522e, 0x3d08df17, 0x7e1ca400, 0xb771c564,\n    0xf465be73, 0x3159334a, 0x724d485d, 0xd2c0312e, 0x91d44a39,\n    0x54e8c700, 0x17fcbc17, 0xde91dd73, 0x9d85a664, 0x58b92b5d,\n    0x1bad504a, 0xca62e995, 0x89769282, 0x4c4a1fbb, 0x0f5e64ac,\n    0xc63305c8, 0x85277edf, 0x401bf3e6, 0x030f88f1, 0x070392de,\n    0x4417e9c9, 0x812b64f0, 0xc23f1fe7, 0x0b527e83, 0x48460594,\n    0x8d7a88ad, 0xce6ef3ba, 0x1fa14a65, 0x5cb53172, 0x9989bc4b,\n    0xda9dc75c, 0x13f0a638, 0x50e4dd2f, 0x95d85016, 0xd6cc2b01,\n    0x76415272, 0x35552965, 0xf069a45c, 0xb37ddf4b, 0x7a10be2f,\n    0x3904c538, 0xfc384801, 0xbf2c3316, 0x6ee38ac9, 0x2df7f1de,\n    0xe8cb7ce7, 0xabdf07f0, 0x62b26694, 0x21a61d83, 0xe49a90ba,\n    0xa78eebad, 0xa481635c, 0xe795184b, 0x22a99572, 0x61bdee65,\n    0xa8d08f01, 0xebc4f416, 0x2ef8792f, 0x6dec0238, 0xbc23bbe7,\n    0xff37c0f0, 0x3a0b4dc9, 0x791f36de, 0xb07257ba, 0xf3662cad,\n    0x365aa194, 0x754eda83, 0xd5c3a3f0, 0x96d7d8e7, 0x53eb55de,\n    0x10ff2ec9, 0xd9924fad, 0x9a8634ba, 0x5fbab983, 0x1caec294,\n    0xcd617b4b, 0x8e75005c, 0x4b498d65, 0x085df672, 0xc1309716,\n    0x8224ec01, 0x47186138, 0x040c1a2f, 0x4f005566, 0x0c142e71,\n    0xc928a348, 0x8a3cd85f, 0x4351b93b, 0x0045c22c, 0xc5794f15,\n    0x866d3402, 0x57a28ddd, 0x14b6f6ca, 0xd18a7bf3, 0x929e00e4,\n    0x5bf36180, 0x18e71a97, 0xdddb97ae, 0x9ecfecb9, 0x3e4295ca,\n    0x7d56eedd, 0xb86a63e4, 0xfb7e18f3, 0x32137997, 0x71070280,\n    0xb43b8fb9, 0xf72ff4ae, 0x26e04d71, 0x65f43666, 0xa0c8bb5f,\n    0xe3dcc048, 0x2ab1a12c, 0x69a5da3b, 0xac995702, 0xef8d2c15,\n    0xec82a4e4, 0xaf96dff3, 0x6aaa52ca, 0x29be29dd, 0xe0d348b9,\n    0xa3c733ae, 0x66fbbe97, 0x25efc580, 0xf4207c5f, 0xb7340748,\n    0x72088a71, 0x311cf166, 0xf8719002, 0xbb65eb15, 0x7e59662c,\n    0x3d4d1d3b, 0x9dc06448, 0xded41f5f, 0x1be89266, 0x58fce971,\n    0x91918815, 0xd285f302, 0x17b97e3b, 0x54ad052c, 0x8562bcf3,\n    0xc676c7e4, 0x034a4add, 0x405e31ca, 0x893350ae, 0xca272bb9,\n    0x0f1ba680, 0x4c0fdd97, 0x4803c7b8, 0x0b17bcaf, 0xce2b3196,\n    0x8d3f4a81, 0x44522be5, 0x074650f2, 0xc27addcb, 0x816ea6dc,\n    0x50a11f03, 0x13b56414, 0xd689e92d, 0x959d923a, 0x5cf0f35e,\n    0x1fe48849, 0xdad80570, 0x99cc7e67, 0x39410714, 0x7a557c03,\n    0xbf69f13a, 0xfc7d8a2d, 0x3510eb49, 0x7604905e, 0xb3381d67,\n    0xf02c6670, 0x21e3dfaf, 0x62f7a4b8, 0xa7cb2981, 0xe4df5296,\n    0x2db233f2, 0x6ea648e5, 0xab9ac5dc, 0xe88ebecb, 0xeb81363a,\n    0xa8954d2d, 0x6da9c014, 0x2ebdbb03, 0xe7d0da67, 0xa4c4a170,\n    0x61f82c49, 0x22ec575e, 0xf323ee81, 0xb0379596, 0x750b18af,\n    0x361f63b8, 0xff7202dc, 0xbc6679cb, 0x795af4f2, 0x3a4e8fe5,\n    0x9ac3f696, 0xd9d78d81, 0x1ceb00b8, 0x5fff7baf, 0x96921acb,\n    0xd58661dc, 0x10baece5, 0x53ae97f2, 0x82612e2d, 0xc175553a,\n    0x0449d803, 0x475da314, 0x8e30c270, 0xcd24b967, 0x0818345e,\n    0x4b0c4f49},\n   {0x00000000, 0x3e6bc2ef, 0x3dd0f504, 0x03bb37eb, 0x7aa0eb09,\n    0x44cb29e6, 0x47701e0d, 0x791bdce2, 0xf440d713, 0xca2b15fc,\n    0xc9902217, 0xf7fbe0f8, 0x8ee03c1a, 0xb08bfef5, 0xb330c91e,\n    0x8d5b0bf1, 0xe881ae27, 0xd6ea6cc8, 0xd5515b23, 0xeb3a99cc,\n    0x9221452e, 0xac4a87c1, 0xaff1b02a, 0x919a72c5, 0x1cc17934,\n    0x22aabbdb, 0x21118c30, 0x1f7a4edf, 0x6661923d, 0x580a50d2,\n    0x5bb16739, 0x65daa5d6, 0xd0035d4f, 0xee689fa0, 0xedd3a84b,\n    0xd3b86aa4, 0xaaa3b646, 0x94c874a9, 0x97734342, 0xa91881ad,\n    0x24438a5c, 0x1a2848b3, 0x19937f58, 0x27f8bdb7, 0x5ee36155,\n    0x6088a3ba, 0x63339451, 0x5d5856be, 0x3882f368, 0x06e93187,\n    0x0552066c, 0x3b39c483, 0x42221861, 0x7c49da8e, 0x7ff2ed65,\n    0x41992f8a, 0xccc2247b, 0xf2a9e694, 0xf112d17f, 0xcf791390,\n    0xb662cf72, 0x88090d9d, 0x8bb23a76, 0xb5d9f899, 0xa007ba9e,\n    0x9e6c7871, 0x9dd74f9a, 0xa3bc8d75, 0xdaa75197, 0xe4cc9378,\n    0xe777a493, 0xd91c667c, 0x54476d8d, 0x6a2caf62, 0x69979889,\n    0x57fc5a66, 0x2ee78684, 0x108c446b, 0x13377380, 0x2d5cb16f,\n    0x488614b9, 0x76edd656, 0x7556e1bd, 0x4b3d2352, 0x3226ffb0,\n    0x0c4d3d5f, 0x0ff60ab4, 0x319dc85b, 0xbcc6c3aa, 0x82ad0145,\n    0x811636ae, 0xbf7df441, 0xc66628a3, 0xf80dea4c, 0xfbb6dda7,\n    0xc5dd1f48, 0x7004e7d1, 0x4e6f253e, 0x4dd412d5, 0x73bfd03a,\n    0x0aa40cd8, 0x34cfce37, 0x3774f9dc, 0x091f3b33, 0x844430c2,\n    0xba2ff22d, 0xb994c5c6, 0x87ff0729, 0xfee4dbcb, 0xc08f1924,\n    0xc3342ecf, 0xfd5fec20, 0x988549f6, 0xa6ee8b19, 0xa555bcf2,\n    0x9b3e7e1d, 0xe225a2ff, 0xdc4e6010, 0xdff557fb, 0xe19e9514,\n    0x6cc59ee5, 0x52ae5c0a, 0x51156be1, 0x6f7ea90e, 0x166575ec,\n    0x280eb703, 0x2bb580e8, 0x15de4207, 0x010905e6, 0x3f62c709,\n    0x3cd9f0e2, 0x02b2320d, 0x7ba9eeef, 0x45c22c00, 0x46791beb,\n    0x7812d904, 0xf549d2f5, 0xcb22101a, 0xc89927f1, 0xf6f2e51e,\n    0x8fe939fc, 0xb182fb13, 0xb239ccf8, 0x8c520e17, 0xe988abc1,\n    0xd7e3692e, 0xd4585ec5, 0xea339c2a, 0x932840c8, 0xad438227,\n    0xaef8b5cc, 0x90937723, 0x1dc87cd2, 0x23a3be3d, 0x201889d6,\n    0x1e734b39, 0x676897db, 0x59035534, 0x5ab862df, 0x64d3a030,\n    0xd10a58a9, 0xef619a46, 0xecdaadad, 0xd2b16f42, 0xabaab3a0,\n    0x95c1714f, 0x967a46a4, 0xa811844b, 0x254a8fba, 0x1b214d55,\n    0x189a7abe, 0x26f1b851, 0x5fea64b3, 0x6181a65c, 0x623a91b7,\n    0x5c515358, 0x398bf68e, 0x07e03461, 0x045b038a, 0x3a30c165,\n    0x432b1d87, 0x7d40df68, 0x7efbe883, 0x40902a6c, 0xcdcb219d,\n    0xf3a0e372, 0xf01bd499, 0xce701676, 0xb76bca94, 0x8900087b,\n    0x8abb3f90, 0xb4d0fd7f, 0xa10ebf78, 0x9f657d97, 0x9cde4a7c,\n    0xa2b58893, 0xdbae5471, 0xe5c5969e, 0xe67ea175, 0xd815639a,\n    0x554e686b, 0x6b25aa84, 0x689e9d6f, 0x56f55f80, 0x2fee8362,\n    0x1185418d, 0x123e7666, 0x2c55b489, 0x498f115f, 0x77e4d3b0,\n    0x745fe45b, 0x4a3426b4, 0x332ffa56, 0x0d4438b9, 0x0eff0f52,\n    0x3094cdbd, 0xbdcfc64c, 0x83a404a3, 0x801f3348, 0xbe74f1a7,\n    0xc76f2d45, 0xf904efaa, 0xfabfd841, 0xc4d41aae, 0x710de237,\n    0x4f6620d8, 0x4cdd1733, 0x72b6d5dc, 0x0bad093e, 0x35c6cbd1,\n    0x367dfc3a, 0x08163ed5, 0x854d3524, 0xbb26f7cb, 0xb89dc020,\n    0x86f602cf, 0xffedde2d, 0xc1861cc2, 0xc23d2b29, 0xfc56e9c6,\n    0x998c4c10, 0xa7e78eff, 0xa45cb914, 0x9a377bfb, 0xe32ca719,\n    0xdd4765f6, 0xdefc521d, 0xe09790f2, 0x6dcc9b03, 0x53a759ec,\n    0x501c6e07, 0x6e77ace8, 0x176c700a, 0x2907b2e5, 0x2abc850e,\n    0x14d747e1},\n   {0x00000000, 0xc0df8ec1, 0xc1b96c58, 0x0166e299, 0x8273d9b0,\n    0x42ac5771, 0x43cab5e8, 0x83153b29, 0x45e1c3ba, 0x853e4d7b,\n    0x8458afe2, 0x44872123, 0xc7921a0a, 0x074d94cb, 0x062b7652,\n    0xc6f4f893, 0xcbc4f6ae, 0x0b1b786f, 0x0a7d9af6, 0xcaa21437,\n    0x49b72f1e, 0x8968a1df, 0x880e4346, 0x48d1cd87, 0x8e253514,\n    0x4efabbd5, 0x4f9c594c, 0x8f43d78d, 0x0c56eca4, 0xcc896265,\n    0xcdef80fc, 0x0d300e3d, 0xd78f9c86, 0x17501247, 0x1636f0de,\n    0xd6e97e1f, 0x55fc4536, 0x9523cbf7, 0x9445296e, 0x549aa7af,\n    0x926e5f3c, 0x52b1d1fd, 0x53d73364, 0x9308bda5, 0x101d868c,\n    0xd0c2084d, 0xd1a4ead4, 0x117b6415, 0x1c4b6a28, 0xdc94e4e9,\n    0xddf20670, 0x1d2d88b1, 0x9e38b398, 0x5ee73d59, 0x5f81dfc0,\n    0x9f5e5101, 0x59aaa992, 0x99752753, 0x9813c5ca, 0x58cc4b0b,\n    0xdbd97022, 0x1b06fee3, 0x1a601c7a, 0xdabf92bb, 0xef1948d6,\n    0x2fc6c617, 0x2ea0248e, 0xee7faa4f, 0x6d6a9166, 0xadb51fa7,\n    0xacd3fd3e, 0x6c0c73ff, 0xaaf88b6c, 0x6a2705ad, 0x6b41e734,\n    0xab9e69f5, 0x288b52dc, 0xe854dc1d, 0xe9323e84, 0x29edb045,\n    0x24ddbe78, 0xe40230b9, 0xe564d220, 0x25bb5ce1, 0xa6ae67c8,\n    0x6671e909, 0x67170b90, 0xa7c88551, 0x613c7dc2, 0xa1e3f303,\n    0xa085119a, 0x605a9f5b, 0xe34fa472, 0x23902ab3, 0x22f6c82a,\n    0xe22946eb, 0x3896d450, 0xf8495a91, 0xf92fb808, 0x39f036c9,\n    0xbae50de0, 0x7a3a8321, 0x7b5c61b8, 0xbb83ef79, 0x7d7717ea,\n    0xbda8992b, 0xbcce7bb2, 0x7c11f573, 0xff04ce5a, 0x3fdb409b,\n    0x3ebda202, 0xfe622cc3, 0xf35222fe, 0x338dac3f, 0x32eb4ea6,\n    0xf234c067, 0x7121fb4e, 0xb1fe758f, 0xb0989716, 0x704719d7,\n    0xb6b3e144, 0x766c6f85, 0x770a8d1c, 0xb7d503dd, 0x34c038f4,\n    0xf41fb635, 0xf57954ac, 0x35a6da6d, 0x9f35e177, 0x5fea6fb6,\n    0x5e8c8d2f, 0x9e5303ee, 0x1d4638c7, 0xdd99b606, 0xdcff549f,\n    0x1c20da5e, 0xdad422cd, 0x1a0bac0c, 0x1b6d4e95, 0xdbb2c054,\n    0x58a7fb7d, 0x987875bc, 0x991e9725, 0x59c119e4, 0x54f117d9,\n    0x942e9918, 0x95487b81, 0x5597f540, 0xd682ce69, 0x165d40a8,\n    0x173ba231, 0xd7e42cf0, 0x1110d463, 0xd1cf5aa2, 0xd0a9b83b,\n    0x107636fa, 0x93630dd3, 0x53bc8312, 0x52da618b, 0x9205ef4a,\n    0x48ba7df1, 0x8865f330, 0x890311a9, 0x49dc9f68, 0xcac9a441,\n    0x0a162a80, 0x0b70c819, 0xcbaf46d8, 0x0d5bbe4b, 0xcd84308a,\n    0xcce2d213, 0x0c3d5cd2, 0x8f2867fb, 0x4ff7e93a, 0x4e910ba3,\n    0x8e4e8562, 0x837e8b5f, 0x43a1059e, 0x42c7e707, 0x821869c6,\n    0x010d52ef, 0xc1d2dc2e, 0xc0b43eb7, 0x006bb076, 0xc69f48e5,\n    0x0640c624, 0x072624bd, 0xc7f9aa7c, 0x44ec9155, 0x84331f94,\n    0x8555fd0d, 0x458a73cc, 0x702ca9a1, 0xb0f32760, 0xb195c5f9,\n    0x714a4b38, 0xf25f7011, 0x3280fed0, 0x33e61c49, 0xf3399288,\n    0x35cd6a1b, 0xf512e4da, 0xf4740643, 0x34ab8882, 0xb7beb3ab,\n    0x77613d6a, 0x7607dff3, 0xb6d85132, 0xbbe85f0f, 0x7b37d1ce,\n    0x7a513357, 0xba8ebd96, 0x399b86bf, 0xf944087e, 0xf822eae7,\n    0x38fd6426, 0xfe099cb5, 0x3ed61274, 0x3fb0f0ed, 0xff6f7e2c,\n    0x7c7a4505, 0xbca5cbc4, 0xbdc3295d, 0x7d1ca79c, 0xa7a33527,\n    0x677cbbe6, 0x661a597f, 0xa6c5d7be, 0x25d0ec97, 0xe50f6256,\n    0xe46980cf, 0x24b60e0e, 0xe242f69d, 0x229d785c, 0x23fb9ac5,\n    0xe3241404, 0x60312f2d, 0xa0eea1ec, 0xa1884375, 0x6157cdb4,\n    0x6c67c389, 0xacb84d48, 0xaddeafd1, 0x6d012110, 0xee141a39,\n    0x2ecb94f8, 0x2fad7661, 0xef72f8a0, 0x29860033, 0xe9598ef2,\n    0xe83f6c6b, 0x28e0e2aa, 0xabf5d983, 0x6b2a5742, 0x6a4cb5db,\n    0xaa933b1a},\n   {0x00000000, 0x6f4ca59b, 0x9f9e3bec, 0xf0d29e77, 0x7f3b0603,\n    0x1077a398, 0xe0a53def, 0x8fe99874, 0xfe760c06, 0x913aa99d,\n    0x61e837ea, 0x0ea49271, 0x814d0a05, 0xee01af9e, 0x1ed331e9,\n    0x719f9472, 0xfced180c, 0x93a1bd97, 0x637323e0, 0x0c3f867b,\n    0x83d61e0f, 0xec9abb94, 0x1c4825e3, 0x73048078, 0x029b140a,\n    0x6dd7b191, 0x9d052fe6, 0xf2498a7d, 0x7da01209, 0x12ecb792,\n    0xe23e29e5, 0x8d728c7e, 0xf8db3118, 0x97979483, 0x67450af4,\n    0x0809af6f, 0x87e0371b, 0xe8ac9280, 0x187e0cf7, 0x7732a96c,\n    0x06ad3d1e, 0x69e19885, 0x993306f2, 0xf67fa369, 0x79963b1d,\n    0x16da9e86, 0xe60800f1, 0x8944a56a, 0x04362914, 0x6b7a8c8f,\n    0x9ba812f8, 0xf4e4b763, 0x7b0d2f17, 0x14418a8c, 0xe49314fb,\n    0x8bdfb160, 0xfa402512, 0x950c8089, 0x65de1efe, 0x0a92bb65,\n    0x857b2311, 0xea37868a, 0x1ae518fd, 0x75a9bd66, 0xf0b76330,\n    0x9ffbc6ab, 0x6f2958dc, 0x0065fd47, 0x8f8c6533, 0xe0c0c0a8,\n    0x10125edf, 0x7f5efb44, 0x0ec16f36, 0x618dcaad, 0x915f54da,\n    0xfe13f141, 0x71fa6935, 0x1eb6ccae, 0xee6452d9, 0x8128f742,\n    0x0c5a7b3c, 0x6316dea7, 0x93c440d0, 0xfc88e54b, 0x73617d3f,\n    0x1c2dd8a4, 0xecff46d3, 0x83b3e348, 0xf22c773a, 0x9d60d2a1,\n    0x6db24cd6, 0x02fee94d, 0x8d177139, 0xe25bd4a2, 0x12894ad5,\n    0x7dc5ef4e, 0x086c5228, 0x6720f7b3, 0x97f269c4, 0xf8becc5f,\n    0x7757542b, 0x181bf1b0, 0xe8c96fc7, 0x8785ca5c, 0xf61a5e2e,\n    0x9956fbb5, 0x698465c2, 0x06c8c059, 0x8921582d, 0xe66dfdb6,\n    0x16bf63c1, 0x79f3c65a, 0xf4814a24, 0x9bcdefbf, 0x6b1f71c8,\n    0x0453d453, 0x8bba4c27, 0xe4f6e9bc, 0x142477cb, 0x7b68d250,\n    0x0af74622, 0x65bbe3b9, 0x95697dce, 0xfa25d855, 0x75cc4021,\n    0x1a80e5ba, 0xea527bcd, 0x851ede56, 0xe06fc760, 0x8f2362fb,\n    0x7ff1fc8c, 0x10bd5917, 0x9f54c163, 0xf01864f8, 0x00cafa8f,\n    0x6f865f14, 0x1e19cb66, 0x71556efd, 0x8187f08a, 0xeecb5511,\n    0x6122cd65, 0x0e6e68fe, 0xfebcf689, 0x91f05312, 0x1c82df6c,\n    0x73ce7af7, 0x831ce480, 0xec50411b, 0x63b9d96f, 0x0cf57cf4,\n    0xfc27e283, 0x936b4718, 0xe2f4d36a, 0x8db876f1, 0x7d6ae886,\n    0x12264d1d, 0x9dcfd569, 0xf28370f2, 0x0251ee85, 0x6d1d4b1e,\n    0x18b4f678, 0x77f853e3, 0x872acd94, 0xe866680f, 0x678ff07b,\n    0x08c355e0, 0xf811cb97, 0x975d6e0c, 0xe6c2fa7e, 0x898e5fe5,\n    0x795cc192, 0x16106409, 0x99f9fc7d, 0xf6b559e6, 0x0667c791,\n    0x692b620a, 0xe459ee74, 0x8b154bef, 0x7bc7d598, 0x148b7003,\n    0x9b62e877, 0xf42e4dec, 0x04fcd39b, 0x6bb07600, 0x1a2fe272,\n    0x756347e9, 0x85b1d99e, 0xeafd7c05, 0x6514e471, 0x0a5841ea,\n    0xfa8adf9d, 0x95c67a06, 0x10d8a450, 0x7f9401cb, 0x8f469fbc,\n    0xe00a3a27, 0x6fe3a253, 0x00af07c8, 0xf07d99bf, 0x9f313c24,\n    0xeeaea856, 0x81e20dcd, 0x713093ba, 0x1e7c3621, 0x9195ae55,\n    0xfed90bce, 0x0e0b95b9, 0x61473022, 0xec35bc5c, 0x837919c7,\n    0x73ab87b0, 0x1ce7222b, 0x930eba5f, 0xfc421fc4, 0x0c9081b3,\n    0x63dc2428, 0x1243b05a, 0x7d0f15c1, 0x8ddd8bb6, 0xe2912e2d,\n    0x6d78b659, 0x023413c2, 0xf2e68db5, 0x9daa282e, 0xe8039548,\n    0x874f30d3, 0x779daea4, 0x18d10b3f, 0x9738934b, 0xf87436d0,\n    0x08a6a8a7, 0x67ea0d3c, 0x1675994e, 0x79393cd5, 0x89eba2a2,\n    0xe6a70739, 0x694e9f4d, 0x06023ad6, 0xf6d0a4a1, 0x999c013a,\n    0x14ee8d44, 0x7ba228df, 0x8b70b6a8, 0xe43c1333, 0x6bd58b47,\n    0x04992edc, 0xf44bb0ab, 0x9b071530, 0xea988142, 0x85d424d9,\n    0x7506baae, 0x1a4a1f35, 0x95a38741, 0xfaef22da, 0x0a3dbcad,\n    0x65711936}};\n\n#endif\n\n#endif\n\n#if N == 4\n\n#if W == 8\n\nlocal const z_crc_t FAR crc_braid_table[][256] = {\n   {0x00000000, 0xf1da05aa, 0x38c50d15, 0xc91f08bf, 0x718a1a2a,\n    0x80501f80, 0x494f173f, 0xb8951295, 0xe3143454, 0x12ce31fe,\n    0xdbd13941, 0x2a0b3ceb, 0x929e2e7e, 0x63442bd4, 0xaa5b236b,\n    0x5b8126c1, 0x1d596ee9, 0xec836b43, 0x259c63fc, 0xd4466656,\n    0x6cd374c3, 0x9d097169, 0x541679d6, 0xa5cc7c7c, 0xfe4d5abd,\n    0x0f975f17, 0xc68857a8, 0x37525202, 0x8fc74097, 0x7e1d453d,\n    0xb7024d82, 0x46d84828, 0x3ab2ddd2, 0xcb68d878, 0x0277d0c7,\n    0xf3add56d, 0x4b38c7f8, 0xbae2c252, 0x73fdcaed, 0x8227cf47,\n    0xd9a6e986, 0x287cec2c, 0xe163e493, 0x10b9e139, 0xa82cf3ac,\n    0x59f6f606, 0x90e9feb9, 0x6133fb13, 0x27ebb33b, 0xd631b691,\n    0x1f2ebe2e, 0xeef4bb84, 0x5661a911, 0xa7bbacbb, 0x6ea4a404,\n    0x9f7ea1ae, 0xc4ff876f, 0x352582c5, 0xfc3a8a7a, 0x0de08fd0,\n    0xb5759d45, 0x44af98ef, 0x8db09050, 0x7c6a95fa, 0x7565bba4,\n    0x84bfbe0e, 0x4da0b6b1, 0xbc7ab31b, 0x04efa18e, 0xf535a424,\n    0x3c2aac9b, 0xcdf0a931, 0x96718ff0, 0x67ab8a5a, 0xaeb482e5,\n    0x5f6e874f, 0xe7fb95da, 0x16219070, 0xdf3e98cf, 0x2ee49d65,\n    0x683cd54d, 0x99e6d0e7, 0x50f9d858, 0xa123ddf2, 0x19b6cf67,\n    0xe86ccacd, 0x2173c272, 0xd0a9c7d8, 0x8b28e119, 0x7af2e4b3,\n    0xb3edec0c, 0x4237e9a6, 0xfaa2fb33, 0x0b78fe99, 0xc267f626,\n    0x33bdf38c, 0x4fd76676, 0xbe0d63dc, 0x77126b63, 0x86c86ec9,\n    0x3e5d7c5c, 0xcf8779f6, 0x06987149, 0xf74274e3, 0xacc35222,\n    0x5d195788, 0x94065f37, 0x65dc5a9d, 0xdd494808, 0x2c934da2,\n    0xe58c451d, 0x145640b7, 0x528e089f, 0xa3540d35, 0x6a4b058a,\n    0x9b910020, 0x230412b5, 0xd2de171f, 0x1bc11fa0, 0xea1b1a0a,\n    0xb19a3ccb, 0x40403961, 0x895f31de, 0x78853474, 0xc01026e1,\n    0x31ca234b, 0xf8d52bf4, 0x090f2e5e, 0xeacb7748, 0x1b1172e2,\n    0xd20e7a5d, 0x23d47ff7, 0x9b416d62, 0x6a9b68c8, 0xa3846077,\n    0x525e65dd, 0x09df431c, 0xf80546b6, 0x311a4e09, 0xc0c04ba3,\n    0x78555936, 0x898f5c9c, 0x40905423, 0xb14a5189, 0xf79219a1,\n    0x06481c0b, 0xcf5714b4, 0x3e8d111e, 0x8618038b, 0x77c20621,\n    0xbedd0e9e, 0x4f070b34, 0x14862df5, 0xe55c285f, 0x2c4320e0,\n    0xdd99254a, 0x650c37df, 0x94d63275, 0x5dc93aca, 0xac133f60,\n    0xd079aa9a, 0x21a3af30, 0xe8bca78f, 0x1966a225, 0xa1f3b0b0,\n    0x5029b51a, 0x9936bda5, 0x68ecb80f, 0x336d9ece, 0xc2b79b64,\n    0x0ba893db, 0xfa729671, 0x42e784e4, 0xb33d814e, 0x7a2289f1,\n    0x8bf88c5b, 0xcd20c473, 0x3cfac1d9, 0xf5e5c966, 0x043fcccc,\n    0xbcaade59, 0x4d70dbf3, 0x846fd34c, 0x75b5d6e6, 0x2e34f027,\n    0xdfeef58d, 0x16f1fd32, 0xe72bf898, 0x5fbeea0d, 0xae64efa7,\n    0x677be718, 0x96a1e2b2, 0x9faeccec, 0x6e74c946, 0xa76bc1f9,\n    0x56b1c453, 0xee24d6c6, 0x1ffed36c, 0xd6e1dbd3, 0x273bde79,\n    0x7cbaf8b8, 0x8d60fd12, 0x447ff5ad, 0xb5a5f007, 0x0d30e292,\n    0xfceae738, 0x35f5ef87, 0xc42fea2d, 0x82f7a205, 0x732da7af,\n    0xba32af10, 0x4be8aaba, 0xf37db82f, 0x02a7bd85, 0xcbb8b53a,\n    0x3a62b090, 0x61e39651, 0x903993fb, 0x59269b44, 0xa8fc9eee,\n    0x10698c7b, 0xe1b389d1, 0x28ac816e, 0xd97684c4, 0xa51c113e,\n    0x54c61494, 0x9dd91c2b, 0x6c031981, 0xd4960b14, 0x254c0ebe,\n    0xec530601, 0x1d8903ab, 0x4608256a, 0xb7d220c0, 0x7ecd287f,\n    0x8f172dd5, 0x37823f40, 0xc6583aea, 0x0f473255, 0xfe9d37ff,\n    0xb8457fd7, 0x499f7a7d, 0x808072c2, 0x715a7768, 0xc9cf65fd,\n    0x38156057, 0xf10a68e8, 0x00d06d42, 0x5b514b83, 0xaa8b4e29,\n    0x63944696, 0x924e433c, 0x2adb51a9, 0xdb015403, 0x121e5cbc,\n    0xe3c45916},\n   {0x00000000, 0x0ee7e8d1, 0x1dcfd1a2, 0x13283973, 0x3b9fa344,\n    0x35784b95, 0x265072e6, 0x28b79a37, 0x773f4688, 0x79d8ae59,\n    0x6af0972a, 0x64177ffb, 0x4ca0e5cc, 0x42470d1d, 0x516f346e,\n    0x5f88dcbf, 0xee7e8d10, 0xe09965c1, 0xf3b15cb2, 0xfd56b463,\n    0xd5e12e54, 0xdb06c685, 0xc82efff6, 0xc6c91727, 0x9941cb98,\n    0x97a62349, 0x848e1a3a, 0x8a69f2eb, 0xa2de68dc, 0xac39800d,\n    0xbf11b97e, 0xb1f651af, 0x078c1c61, 0x096bf4b0, 0x1a43cdc3,\n    0x14a42512, 0x3c13bf25, 0x32f457f4, 0x21dc6e87, 0x2f3b8656,\n    0x70b35ae9, 0x7e54b238, 0x6d7c8b4b, 0x639b639a, 0x4b2cf9ad,\n    0x45cb117c, 0x56e3280f, 0x5804c0de, 0xe9f29171, 0xe71579a0,\n    0xf43d40d3, 0xfadaa802, 0xd26d3235, 0xdc8adae4, 0xcfa2e397,\n    0xc1450b46, 0x9ecdd7f9, 0x902a3f28, 0x8302065b, 0x8de5ee8a,\n    0xa55274bd, 0xabb59c6c, 0xb89da51f, 0xb67a4dce, 0x0f1838c2,\n    0x01ffd013, 0x12d7e960, 0x1c3001b1, 0x34879b86, 0x3a607357,\n    0x29484a24, 0x27afa2f5, 0x78277e4a, 0x76c0969b, 0x65e8afe8,\n    0x6b0f4739, 0x43b8dd0e, 0x4d5f35df, 0x5e770cac, 0x5090e47d,\n    0xe166b5d2, 0xef815d03, 0xfca96470, 0xf24e8ca1, 0xdaf91696,\n    0xd41efe47, 0xc736c734, 0xc9d12fe5, 0x9659f35a, 0x98be1b8b,\n    0x8b9622f8, 0x8571ca29, 0xadc6501e, 0xa321b8cf, 0xb00981bc,\n    0xbeee696d, 0x089424a3, 0x0673cc72, 0x155bf501, 0x1bbc1dd0,\n    0x330b87e7, 0x3dec6f36, 0x2ec45645, 0x2023be94, 0x7fab622b,\n    0x714c8afa, 0x6264b389, 0x6c835b58, 0x4434c16f, 0x4ad329be,\n    0x59fb10cd, 0x571cf81c, 0xe6eaa9b3, 0xe80d4162, 0xfb257811,\n    0xf5c290c0, 0xdd750af7, 0xd392e226, 0xc0badb55, 0xce5d3384,\n    0x91d5ef3b, 0x9f3207ea, 0x8c1a3e99, 0x82fdd648, 0xaa4a4c7f,\n    0xa4ada4ae, 0xb7859ddd, 0xb962750c, 0x1e307184, 0x10d79955,\n    0x03ffa026, 0x0d1848f7, 0x25afd2c0, 0x2b483a11, 0x38600362,\n    0x3687ebb3, 0x690f370c, 0x67e8dfdd, 0x74c0e6ae, 0x7a270e7f,\n    0x52909448, 0x5c777c99, 0x4f5f45ea, 0x41b8ad3b, 0xf04efc94,\n    0xfea91445, 0xed812d36, 0xe366c5e7, 0xcbd15fd0, 0xc536b701,\n    0xd61e8e72, 0xd8f966a3, 0x8771ba1c, 0x899652cd, 0x9abe6bbe,\n    0x9459836f, 0xbcee1958, 0xb209f189, 0xa121c8fa, 0xafc6202b,\n    0x19bc6de5, 0x175b8534, 0x0473bc47, 0x0a945496, 0x2223cea1,\n    0x2cc42670, 0x3fec1f03, 0x310bf7d2, 0x6e832b6d, 0x6064c3bc,\n    0x734cfacf, 0x7dab121e, 0x551c8829, 0x5bfb60f8, 0x48d3598b,\n    0x4634b15a, 0xf7c2e0f5, 0xf9250824, 0xea0d3157, 0xe4ead986,\n    0xcc5d43b1, 0xc2baab60, 0xd1929213, 0xdf757ac2, 0x80fda67d,\n    0x8e1a4eac, 0x9d3277df, 0x93d59f0e, 0xbb620539, 0xb585ede8,\n    0xa6add49b, 0xa84a3c4a, 0x11284946, 0x1fcfa197, 0x0ce798e4,\n    0x02007035, 0x2ab7ea02, 0x245002d3, 0x37783ba0, 0x399fd371,\n    0x66170fce, 0x68f0e71f, 0x7bd8de6c, 0x753f36bd, 0x5d88ac8a,\n    0x536f445b, 0x40477d28, 0x4ea095f9, 0xff56c456, 0xf1b12c87,\n    0xe29915f4, 0xec7efd25, 0xc4c96712, 0xca2e8fc3, 0xd906b6b0,\n    0xd7e15e61, 0x886982de, 0x868e6a0f, 0x95a6537c, 0x9b41bbad,\n    0xb3f6219a, 0xbd11c94b, 0xae39f038, 0xa0de18e9, 0x16a45527,\n    0x1843bdf6, 0x0b6b8485, 0x058c6c54, 0x2d3bf663, 0x23dc1eb2,\n    0x30f427c1, 0x3e13cf10, 0x619b13af, 0x6f7cfb7e, 0x7c54c20d,\n    0x72b32adc, 0x5a04b0eb, 0x54e3583a, 0x47cb6149, 0x492c8998,\n    0xf8dad837, 0xf63d30e6, 0xe5150995, 0xebf2e144, 0xc3457b73,\n    0xcda293a2, 0xde8aaad1, 0xd06d4200, 0x8fe59ebf, 0x8102766e,\n    0x922a4f1d, 0x9ccda7cc, 0xb47a3dfb, 0xba9dd52a, 0xa9b5ec59,\n    0xa7520488},\n   {0x00000000, 0x3c60e308, 0x78c1c610, 0x44a12518, 0xf1838c20,\n    0xcde36f28, 0x89424a30, 0xb522a938, 0x38761e01, 0x0416fd09,\n    0x40b7d811, 0x7cd73b19, 0xc9f59221, 0xf5957129, 0xb1345431,\n    0x8d54b739, 0x70ec3c02, 0x4c8cdf0a, 0x082dfa12, 0x344d191a,\n    0x816fb022, 0xbd0f532a, 0xf9ae7632, 0xc5ce953a, 0x489a2203,\n    0x74fac10b, 0x305be413, 0x0c3b071b, 0xb919ae23, 0x85794d2b,\n    0xc1d86833, 0xfdb88b3b, 0xe1d87804, 0xddb89b0c, 0x9919be14,\n    0xa5795d1c, 0x105bf424, 0x2c3b172c, 0x689a3234, 0x54fad13c,\n    0xd9ae6605, 0xe5ce850d, 0xa16fa015, 0x9d0f431d, 0x282dea25,\n    0x144d092d, 0x50ec2c35, 0x6c8ccf3d, 0x91344406, 0xad54a70e,\n    0xe9f58216, 0xd595611e, 0x60b7c826, 0x5cd72b2e, 0x18760e36,\n    0x2416ed3e, 0xa9425a07, 0x9522b90f, 0xd1839c17, 0xede37f1f,\n    0x58c1d627, 0x64a1352f, 0x20001037, 0x1c60f33f, 0x18c1f649,\n    0x24a11541, 0x60003059, 0x5c60d351, 0xe9427a69, 0xd5229961,\n    0x9183bc79, 0xade35f71, 0x20b7e848, 0x1cd70b40, 0x58762e58,\n    0x6416cd50, 0xd1346468, 0xed548760, 0xa9f5a278, 0x95954170,\n    0x682dca4b, 0x544d2943, 0x10ec0c5b, 0x2c8cef53, 0x99ae466b,\n    0xa5cea563, 0xe16f807b, 0xdd0f6373, 0x505bd44a, 0x6c3b3742,\n    0x289a125a, 0x14faf152, 0xa1d8586a, 0x9db8bb62, 0xd9199e7a,\n    0xe5797d72, 0xf9198e4d, 0xc5796d45, 0x81d8485d, 0xbdb8ab55,\n    0x089a026d, 0x34fae165, 0x705bc47d, 0x4c3b2775, 0xc16f904c,\n    0xfd0f7344, 0xb9ae565c, 0x85ceb554, 0x30ec1c6c, 0x0c8cff64,\n    0x482dda7c, 0x744d3974, 0x89f5b24f, 0xb5955147, 0xf134745f,\n    0xcd549757, 0x78763e6f, 0x4416dd67, 0x00b7f87f, 0x3cd71b77,\n    0xb183ac4e, 0x8de34f46, 0xc9426a5e, 0xf5228956, 0x4000206e,\n    0x7c60c366, 0x38c1e67e, 0x04a10576, 0x3183ec92, 0x0de30f9a,\n    0x49422a82, 0x7522c98a, 0xc00060b2, 0xfc6083ba, 0xb8c1a6a2,\n    0x84a145aa, 0x09f5f293, 0x3595119b, 0x71343483, 0x4d54d78b,\n    0xf8767eb3, 0xc4169dbb, 0x80b7b8a3, 0xbcd75bab, 0x416fd090,\n    0x7d0f3398, 0x39ae1680, 0x05cef588, 0xb0ec5cb0, 0x8c8cbfb8,\n    0xc82d9aa0, 0xf44d79a8, 0x7919ce91, 0x45792d99, 0x01d80881,\n    0x3db8eb89, 0x889a42b1, 0xb4faa1b9, 0xf05b84a1, 0xcc3b67a9,\n    0xd05b9496, 0xec3b779e, 0xa89a5286, 0x94fab18e, 0x21d818b6,\n    0x1db8fbbe, 0x5919dea6, 0x65793dae, 0xe82d8a97, 0xd44d699f,\n    0x90ec4c87, 0xac8caf8f, 0x19ae06b7, 0x25cee5bf, 0x616fc0a7,\n    0x5d0f23af, 0xa0b7a894, 0x9cd74b9c, 0xd8766e84, 0xe4168d8c,\n    0x513424b4, 0x6d54c7bc, 0x29f5e2a4, 0x159501ac, 0x98c1b695,\n    0xa4a1559d, 0xe0007085, 0xdc60938d, 0x69423ab5, 0x5522d9bd,\n    0x1183fca5, 0x2de31fad, 0x29421adb, 0x1522f9d3, 0x5183dccb,\n    0x6de33fc3, 0xd8c196fb, 0xe4a175f3, 0xa00050eb, 0x9c60b3e3,\n    0x113404da, 0x2d54e7d2, 0x69f5c2ca, 0x559521c2, 0xe0b788fa,\n    0xdcd76bf2, 0x98764eea, 0xa416ade2, 0x59ae26d9, 0x65cec5d1,\n    0x216fe0c9, 0x1d0f03c1, 0xa82daaf9, 0x944d49f1, 0xd0ec6ce9,\n    0xec8c8fe1, 0x61d838d8, 0x5db8dbd0, 0x1919fec8, 0x25791dc0,\n    0x905bb4f8, 0xac3b57f0, 0xe89a72e8, 0xd4fa91e0, 0xc89a62df,\n    0xf4fa81d7, 0xb05ba4cf, 0x8c3b47c7, 0x3919eeff, 0x05790df7,\n    0x41d828ef, 0x7db8cbe7, 0xf0ec7cde, 0xcc8c9fd6, 0x882dbace,\n    0xb44d59c6, 0x016ff0fe, 0x3d0f13f6, 0x79ae36ee, 0x45ced5e6,\n    0xb8765edd, 0x8416bdd5, 0xc0b798cd, 0xfcd77bc5, 0x49f5d2fd,\n    0x759531f5, 0x313414ed, 0x0d54f7e5, 0x800040dc, 0xbc60a3d4,\n    0xf8c186cc, 0xc4a165c4, 0x7183ccfc, 0x4de32ff4, 0x09420aec,\n    0x3522e9e4},\n   {0x00000000, 0x6307d924, 0xc60fb248, 0xa5086b6c, 0x576e62d1,\n    0x3469bbf5, 0x9161d099, 0xf26609bd, 0xaedcc5a2, 0xcddb1c86,\n    0x68d377ea, 0x0bd4aece, 0xf9b2a773, 0x9ab57e57, 0x3fbd153b,\n    0x5cbacc1f, 0x86c88d05, 0xe5cf5421, 0x40c73f4d, 0x23c0e669,\n    0xd1a6efd4, 0xb2a136f0, 0x17a95d9c, 0x74ae84b8, 0x281448a7,\n    0x4b139183, 0xee1bfaef, 0x8d1c23cb, 0x7f7a2a76, 0x1c7df352,\n    0xb975983e, 0xda72411a, 0xd6e01c4b, 0xb5e7c56f, 0x10efae03,\n    0x73e87727, 0x818e7e9a, 0xe289a7be, 0x4781ccd2, 0x248615f6,\n    0x783cd9e9, 0x1b3b00cd, 0xbe336ba1, 0xdd34b285, 0x2f52bb38,\n    0x4c55621c, 0xe95d0970, 0x8a5ad054, 0x5028914e, 0x332f486a,\n    0x96272306, 0xf520fa22, 0x0746f39f, 0x64412abb, 0xc14941d7,\n    0xa24e98f3, 0xfef454ec, 0x9df38dc8, 0x38fbe6a4, 0x5bfc3f80,\n    0xa99a363d, 0xca9def19, 0x6f958475, 0x0c925d51, 0x76b13ed7,\n    0x15b6e7f3, 0xb0be8c9f, 0xd3b955bb, 0x21df5c06, 0x42d88522,\n    0xe7d0ee4e, 0x84d7376a, 0xd86dfb75, 0xbb6a2251, 0x1e62493d,\n    0x7d659019, 0x8f0399a4, 0xec044080, 0x490c2bec, 0x2a0bf2c8,\n    0xf079b3d2, 0x937e6af6, 0x3676019a, 0x5571d8be, 0xa717d103,\n    0xc4100827, 0x6118634b, 0x021fba6f, 0x5ea57670, 0x3da2af54,\n    0x98aac438, 0xfbad1d1c, 0x09cb14a1, 0x6acccd85, 0xcfc4a6e9,\n    0xacc37fcd, 0xa051229c, 0xc356fbb8, 0x665e90d4, 0x055949f0,\n    0xf73f404d, 0x94389969, 0x3130f205, 0x52372b21, 0x0e8de73e,\n    0x6d8a3e1a, 0xc8825576, 0xab858c52, 0x59e385ef, 0x3ae45ccb,\n    0x9fec37a7, 0xfcebee83, 0x2699af99, 0x459e76bd, 0xe0961dd1,\n    0x8391c4f5, 0x71f7cd48, 0x12f0146c, 0xb7f87f00, 0xd4ffa624,\n    0x88456a3b, 0xeb42b31f, 0x4e4ad873, 0x2d4d0157, 0xdf2b08ea,\n    0xbc2cd1ce, 0x1924baa2, 0x7a236386, 0xed627dae, 0x8e65a48a,\n    0x2b6dcfe6, 0x486a16c2, 0xba0c1f7f, 0xd90bc65b, 0x7c03ad37,\n    0x1f047413, 0x43beb80c, 0x20b96128, 0x85b10a44, 0xe6b6d360,\n    0x14d0dadd, 0x77d703f9, 0xd2df6895, 0xb1d8b1b1, 0x6baaf0ab,\n    0x08ad298f, 0xada542e3, 0xcea29bc7, 0x3cc4927a, 0x5fc34b5e,\n    0xfacb2032, 0x99ccf916, 0xc5763509, 0xa671ec2d, 0x03798741,\n    0x607e5e65, 0x921857d8, 0xf11f8efc, 0x5417e590, 0x37103cb4,\n    0x3b8261e5, 0x5885b8c1, 0xfd8dd3ad, 0x9e8a0a89, 0x6cec0334,\n    0x0febda10, 0xaae3b17c, 0xc9e46858, 0x955ea447, 0xf6597d63,\n    0x5351160f, 0x3056cf2b, 0xc230c696, 0xa1371fb2, 0x043f74de,\n    0x6738adfa, 0xbd4aece0, 0xde4d35c4, 0x7b455ea8, 0x1842878c,\n    0xea248e31, 0x89235715, 0x2c2b3c79, 0x4f2ce55d, 0x13962942,\n    0x7091f066, 0xd5999b0a, 0xb69e422e, 0x44f84b93, 0x27ff92b7,\n    0x82f7f9db, 0xe1f020ff, 0x9bd34379, 0xf8d49a5d, 0x5ddcf131,\n    0x3edb2815, 0xccbd21a8, 0xafbaf88c, 0x0ab293e0, 0x69b54ac4,\n    0x350f86db, 0x56085fff, 0xf3003493, 0x9007edb7, 0x6261e40a,\n    0x01663d2e, 0xa46e5642, 0xc7698f66, 0x1d1bce7c, 0x7e1c1758,\n    0xdb147c34, 0xb813a510, 0x4a75acad, 0x29727589, 0x8c7a1ee5,\n    0xef7dc7c1, 0xb3c70bde, 0xd0c0d2fa, 0x75c8b996, 0x16cf60b2,\n    0xe4a9690f, 0x87aeb02b, 0x22a6db47, 0x41a10263, 0x4d335f32,\n    0x2e348616, 0x8b3ced7a, 0xe83b345e, 0x1a5d3de3, 0x795ae4c7,\n    0xdc528fab, 0xbf55568f, 0xe3ef9a90, 0x80e843b4, 0x25e028d8,\n    0x46e7f1fc, 0xb481f841, 0xd7862165, 0x728e4a09, 0x1189932d,\n    0xcbfbd237, 0xa8fc0b13, 0x0df4607f, 0x6ef3b95b, 0x9c95b0e6,\n    0xff9269c2, 0x5a9a02ae, 0x399ddb8a, 0x65271795, 0x0620ceb1,\n    0xa328a5dd, 0xc02f7cf9, 0x32497544, 0x514eac60, 0xf446c70c,\n    0x97411e28},\n   {0x00000000, 0x01b5fd1d, 0x036bfa3a, 0x02de0727, 0x06d7f474,\n    0x07620969, 0x05bc0e4e, 0x0409f353, 0x0dafe8e8, 0x0c1a15f5,\n    0x0ec412d2, 0x0f71efcf, 0x0b781c9c, 0x0acde181, 0x0813e6a6,\n    0x09a61bbb, 0x1b5fd1d0, 0x1aea2ccd, 0x18342bea, 0x1981d6f7,\n    0x1d8825a4, 0x1c3dd8b9, 0x1ee3df9e, 0x1f562283, 0x16f03938,\n    0x1745c425, 0x159bc302, 0x142e3e1f, 0x1027cd4c, 0x11923051,\n    0x134c3776, 0x12f9ca6b, 0x36bfa3a0, 0x370a5ebd, 0x35d4599a,\n    0x3461a487, 0x306857d4, 0x31ddaac9, 0x3303adee, 0x32b650f3,\n    0x3b104b48, 0x3aa5b655, 0x387bb172, 0x39ce4c6f, 0x3dc7bf3c,\n    0x3c724221, 0x3eac4506, 0x3f19b81b, 0x2de07270, 0x2c558f6d,\n    0x2e8b884a, 0x2f3e7557, 0x2b378604, 0x2a827b19, 0x285c7c3e,\n    0x29e98123, 0x204f9a98, 0x21fa6785, 0x232460a2, 0x22919dbf,\n    0x26986eec, 0x272d93f1, 0x25f394d6, 0x244669cb, 0x6d7f4740,\n    0x6ccaba5d, 0x6e14bd7a, 0x6fa14067, 0x6ba8b334, 0x6a1d4e29,\n    0x68c3490e, 0x6976b413, 0x60d0afa8, 0x616552b5, 0x63bb5592,\n    0x620ea88f, 0x66075bdc, 0x67b2a6c1, 0x656ca1e6, 0x64d95cfb,\n    0x76209690, 0x77956b8d, 0x754b6caa, 0x74fe91b7, 0x70f762e4,\n    0x71429ff9, 0x739c98de, 0x722965c3, 0x7b8f7e78, 0x7a3a8365,\n    0x78e48442, 0x7951795f, 0x7d588a0c, 0x7ced7711, 0x7e337036,\n    0x7f868d2b, 0x5bc0e4e0, 0x5a7519fd, 0x58ab1eda, 0x591ee3c7,\n    0x5d171094, 0x5ca2ed89, 0x5e7ceaae, 0x5fc917b3, 0x566f0c08,\n    0x57daf115, 0x5504f632, 0x54b10b2f, 0x50b8f87c, 0x510d0561,\n    0x53d30246, 0x5266ff5b, 0x409f3530, 0x412ac82d, 0x43f4cf0a,\n    0x42413217, 0x4648c144, 0x47fd3c59, 0x45233b7e, 0x4496c663,\n    0x4d30ddd8, 0x4c8520c5, 0x4e5b27e2, 0x4feedaff, 0x4be729ac,\n    0x4a52d4b1, 0x488cd396, 0x49392e8b, 0xdafe8e80, 0xdb4b739d,\n    0xd99574ba, 0xd82089a7, 0xdc297af4, 0xdd9c87e9, 0xdf4280ce,\n    0xdef77dd3, 0xd7516668, 0xd6e49b75, 0xd43a9c52, 0xd58f614f,\n    0xd186921c, 0xd0336f01, 0xd2ed6826, 0xd358953b, 0xc1a15f50,\n    0xc014a24d, 0xc2caa56a, 0xc37f5877, 0xc776ab24, 0xc6c35639,\n    0xc41d511e, 0xc5a8ac03, 0xcc0eb7b8, 0xcdbb4aa5, 0xcf654d82,\n    0xced0b09f, 0xcad943cc, 0xcb6cbed1, 0xc9b2b9f6, 0xc80744eb,\n    0xec412d20, 0xedf4d03d, 0xef2ad71a, 0xee9f2a07, 0xea96d954,\n    0xeb232449, 0xe9fd236e, 0xe848de73, 0xe1eec5c8, 0xe05b38d5,\n    0xe2853ff2, 0xe330c2ef, 0xe73931bc, 0xe68ccca1, 0xe452cb86,\n    0xe5e7369b, 0xf71efcf0, 0xf6ab01ed, 0xf47506ca, 0xf5c0fbd7,\n    0xf1c90884, 0xf07cf599, 0xf2a2f2be, 0xf3170fa3, 0xfab11418,\n    0xfb04e905, 0xf9daee22, 0xf86f133f, 0xfc66e06c, 0xfdd31d71,\n    0xff0d1a56, 0xfeb8e74b, 0xb781c9c0, 0xb63434dd, 0xb4ea33fa,\n    0xb55fcee7, 0xb1563db4, 0xb0e3c0a9, 0xb23dc78e, 0xb3883a93,\n    0xba2e2128, 0xbb9bdc35, 0xb945db12, 0xb8f0260f, 0xbcf9d55c,\n    0xbd4c2841, 0xbf922f66, 0xbe27d27b, 0xacde1810, 0xad6be50d,\n    0xafb5e22a, 0xae001f37, 0xaa09ec64, 0xabbc1179, 0xa962165e,\n    0xa8d7eb43, 0xa171f0f8, 0xa0c40de5, 0xa21a0ac2, 0xa3aff7df,\n    0xa7a6048c, 0xa613f991, 0xa4cdfeb6, 0xa57803ab, 0x813e6a60,\n    0x808b977d, 0x8255905a, 0x83e06d47, 0x87e99e14, 0x865c6309,\n    0x8482642e, 0x85379933, 0x8c918288, 0x8d247f95, 0x8ffa78b2,\n    0x8e4f85af, 0x8a4676fc, 0x8bf38be1, 0x892d8cc6, 0x889871db,\n    0x9a61bbb0, 0x9bd446ad, 0x990a418a, 0x98bfbc97, 0x9cb64fc4,\n    0x9d03b2d9, 0x9fddb5fe, 0x9e6848e3, 0x97ce5358, 0x967bae45,\n    0x94a5a962, 0x9510547f, 0x9119a72c, 0x90ac5a31, 0x92725d16,\n    0x93c7a00b},\n   {0x00000000, 0x6e8c1b41, 0xdd183682, 0xb3942dc3, 0x61416b45,\n    0x0fcd7004, 0xbc595dc7, 0xd2d54686, 0xc282d68a, 0xac0ecdcb,\n    0x1f9ae008, 0x7116fb49, 0xa3c3bdcf, 0xcd4fa68e, 0x7edb8b4d,\n    0x1057900c, 0x5e74ab55, 0x30f8b014, 0x836c9dd7, 0xede08696,\n    0x3f35c010, 0x51b9db51, 0xe22df692, 0x8ca1edd3, 0x9cf67ddf,\n    0xf27a669e, 0x41ee4b5d, 0x2f62501c, 0xfdb7169a, 0x933b0ddb,\n    0x20af2018, 0x4e233b59, 0xbce956aa, 0xd2654deb, 0x61f16028,\n    0x0f7d7b69, 0xdda83def, 0xb32426ae, 0x00b00b6d, 0x6e3c102c,\n    0x7e6b8020, 0x10e79b61, 0xa373b6a2, 0xcdffade3, 0x1f2aeb65,\n    0x71a6f024, 0xc232dde7, 0xacbec6a6, 0xe29dfdff, 0x8c11e6be,\n    0x3f85cb7d, 0x5109d03c, 0x83dc96ba, 0xed508dfb, 0x5ec4a038,\n    0x3048bb79, 0x201f2b75, 0x4e933034, 0xfd071df7, 0x938b06b6,\n    0x415e4030, 0x2fd25b71, 0x9c4676b2, 0xf2ca6df3, 0xa2a3ab15,\n    0xcc2fb054, 0x7fbb9d97, 0x113786d6, 0xc3e2c050, 0xad6edb11,\n    0x1efaf6d2, 0x7076ed93, 0x60217d9f, 0x0ead66de, 0xbd394b1d,\n    0xd3b5505c, 0x016016da, 0x6fec0d9b, 0xdc782058, 0xb2f43b19,\n    0xfcd70040, 0x925b1b01, 0x21cf36c2, 0x4f432d83, 0x9d966b05,\n    0xf31a7044, 0x408e5d87, 0x2e0246c6, 0x3e55d6ca, 0x50d9cd8b,\n    0xe34de048, 0x8dc1fb09, 0x5f14bd8f, 0x3198a6ce, 0x820c8b0d,\n    0xec80904c, 0x1e4afdbf, 0x70c6e6fe, 0xc352cb3d, 0xadded07c,\n    0x7f0b96fa, 0x11878dbb, 0xa213a078, 0xcc9fbb39, 0xdcc82b35,\n    0xb2443074, 0x01d01db7, 0x6f5c06f6, 0xbd894070, 0xd3055b31,\n    0x609176f2, 0x0e1d6db3, 0x403e56ea, 0x2eb24dab, 0x9d266068,\n    0xf3aa7b29, 0x217f3daf, 0x4ff326ee, 0xfc670b2d, 0x92eb106c,\n    0x82bc8060, 0xec309b21, 0x5fa4b6e2, 0x3128ada3, 0xe3fdeb25,\n    0x8d71f064, 0x3ee5dda7, 0x5069c6e6, 0x9e36506b, 0xf0ba4b2a,\n    0x432e66e9, 0x2da27da8, 0xff773b2e, 0x91fb206f, 0x226f0dac,\n    0x4ce316ed, 0x5cb486e1, 0x32389da0, 0x81acb063, 0xef20ab22,\n    0x3df5eda4, 0x5379f6e5, 0xe0eddb26, 0x8e61c067, 0xc042fb3e,\n    0xaecee07f, 0x1d5acdbc, 0x73d6d6fd, 0xa103907b, 0xcf8f8b3a,\n    0x7c1ba6f9, 0x1297bdb8, 0x02c02db4, 0x6c4c36f5, 0xdfd81b36,\n    0xb1540077, 0x638146f1, 0x0d0d5db0, 0xbe997073, 0xd0156b32,\n    0x22df06c1, 0x4c531d80, 0xffc73043, 0x914b2b02, 0x439e6d84,\n    0x2d1276c5, 0x9e865b06, 0xf00a4047, 0xe05dd04b, 0x8ed1cb0a,\n    0x3d45e6c9, 0x53c9fd88, 0x811cbb0e, 0xef90a04f, 0x5c048d8c,\n    0x328896cd, 0x7cabad94, 0x1227b6d5, 0xa1b39b16, 0xcf3f8057,\n    0x1deac6d1, 0x7366dd90, 0xc0f2f053, 0xae7eeb12, 0xbe297b1e,\n    0xd0a5605f, 0x63314d9c, 0x0dbd56dd, 0xdf68105b, 0xb1e40b1a,\n    0x027026d9, 0x6cfc3d98, 0x3c95fb7e, 0x5219e03f, 0xe18dcdfc,\n    0x8f01d6bd, 0x5dd4903b, 0x33588b7a, 0x80cca6b9, 0xee40bdf8,\n    0xfe172df4, 0x909b36b5, 0x230f1b76, 0x4d830037, 0x9f5646b1,\n    0xf1da5df0, 0x424e7033, 0x2cc26b72, 0x62e1502b, 0x0c6d4b6a,\n    0xbff966a9, 0xd1757de8, 0x03a03b6e, 0x6d2c202f, 0xdeb80dec,\n    0xb03416ad, 0xa06386a1, 0xceef9de0, 0x7d7bb023, 0x13f7ab62,\n    0xc122ede4, 0xafaef6a5, 0x1c3adb66, 0x72b6c027, 0x807cadd4,\n    0xeef0b695, 0x5d649b56, 0x33e88017, 0xe13dc691, 0x8fb1ddd0,\n    0x3c25f013, 0x52a9eb52, 0x42fe7b5e, 0x2c72601f, 0x9fe64ddc,\n    0xf16a569d, 0x23bf101b, 0x4d330b5a, 0xfea72699, 0x902b3dd8,\n    0xde080681, 0xb0841dc0, 0x03103003, 0x6d9c2b42, 0xbf496dc4,\n    0xd1c57685, 0x62515b46, 0x0cdd4007, 0x1c8ad00b, 0x7206cb4a,\n    0xc192e689, 0xaf1efdc8, 0x7dcbbb4e, 0x1347a00f, 0xa0d38dcc,\n    0xce5f968d},\n   {0x00000000, 0xe71da697, 0x154a4b6f, 0xf257edf8, 0x2a9496de,\n    0xcd893049, 0x3fdeddb1, 0xd8c37b26, 0x55292dbc, 0xb2348b2b,\n    0x406366d3, 0xa77ec044, 0x7fbdbb62, 0x98a01df5, 0x6af7f00d,\n    0x8dea569a, 0xaa525b78, 0x4d4ffdef, 0xbf181017, 0x5805b680,\n    0x80c6cda6, 0x67db6b31, 0x958c86c9, 0x7291205e, 0xff7b76c4,\n    0x1866d053, 0xea313dab, 0x0d2c9b3c, 0xd5efe01a, 0x32f2468d,\n    0xc0a5ab75, 0x27b80de2, 0x8fd5b0b1, 0x68c81626, 0x9a9ffbde,\n    0x7d825d49, 0xa541266f, 0x425c80f8, 0xb00b6d00, 0x5716cb97,\n    0xdafc9d0d, 0x3de13b9a, 0xcfb6d662, 0x28ab70f5, 0xf0680bd3,\n    0x1775ad44, 0xe52240bc, 0x023fe62b, 0x2587ebc9, 0xc29a4d5e,\n    0x30cda0a6, 0xd7d00631, 0x0f137d17, 0xe80edb80, 0x1a593678,\n    0xfd4490ef, 0x70aec675, 0x97b360e2, 0x65e48d1a, 0x82f92b8d,\n    0x5a3a50ab, 0xbd27f63c, 0x4f701bc4, 0xa86dbd53, 0xc4da6723,\n    0x23c7c1b4, 0xd1902c4c, 0x368d8adb, 0xee4ef1fd, 0x0953576a,\n    0xfb04ba92, 0x1c191c05, 0x91f34a9f, 0x76eeec08, 0x84b901f0,\n    0x63a4a767, 0xbb67dc41, 0x5c7a7ad6, 0xae2d972e, 0x493031b9,\n    0x6e883c5b, 0x89959acc, 0x7bc27734, 0x9cdfd1a3, 0x441caa85,\n    0xa3010c12, 0x5156e1ea, 0xb64b477d, 0x3ba111e7, 0xdcbcb770,\n    0x2eeb5a88, 0xc9f6fc1f, 0x11358739, 0xf62821ae, 0x047fcc56,\n    0xe3626ac1, 0x4b0fd792, 0xac127105, 0x5e459cfd, 0xb9583a6a,\n    0x619b414c, 0x8686e7db, 0x74d10a23, 0x93ccacb4, 0x1e26fa2e,\n    0xf93b5cb9, 0x0b6cb141, 0xec7117d6, 0x34b26cf0, 0xd3afca67,\n    0x21f8279f, 0xc6e58108, 0xe15d8cea, 0x06402a7d, 0xf417c785,\n    0x130a6112, 0xcbc91a34, 0x2cd4bca3, 0xde83515b, 0x399ef7cc,\n    0xb474a156, 0x536907c1, 0xa13eea39, 0x46234cae, 0x9ee03788,\n    0x79fd911f, 0x8baa7ce7, 0x6cb7da70, 0x52c5c807, 0xb5d86e90,\n    0x478f8368, 0xa09225ff, 0x78515ed9, 0x9f4cf84e, 0x6d1b15b6,\n    0x8a06b321, 0x07ece5bb, 0xe0f1432c, 0x12a6aed4, 0xf5bb0843,\n    0x2d787365, 0xca65d5f2, 0x3832380a, 0xdf2f9e9d, 0xf897937f,\n    0x1f8a35e8, 0xedddd810, 0x0ac07e87, 0xd20305a1, 0x351ea336,\n    0xc7494ece, 0x2054e859, 0xadbebec3, 0x4aa31854, 0xb8f4f5ac,\n    0x5fe9533b, 0x872a281d, 0x60378e8a, 0x92606372, 0x757dc5e5,\n    0xdd1078b6, 0x3a0dde21, 0xc85a33d9, 0x2f47954e, 0xf784ee68,\n    0x109948ff, 0xe2cea507, 0x05d30390, 0x8839550a, 0x6f24f39d,\n    0x9d731e65, 0x7a6eb8f2, 0xa2adc3d4, 0x45b06543, 0xb7e788bb,\n    0x50fa2e2c, 0x774223ce, 0x905f8559, 0x620868a1, 0x8515ce36,\n    0x5dd6b510, 0xbacb1387, 0x489cfe7f, 0xaf8158e8, 0x226b0e72,\n    0xc576a8e5, 0x3721451d, 0xd03ce38a, 0x08ff98ac, 0xefe23e3b,\n    0x1db5d3c3, 0xfaa87554, 0x961faf24, 0x710209b3, 0x8355e44b,\n    0x644842dc, 0xbc8b39fa, 0x5b969f6d, 0xa9c17295, 0x4edcd402,\n    0xc3368298, 0x242b240f, 0xd67cc9f7, 0x31616f60, 0xe9a21446,\n    0x0ebfb2d1, 0xfce85f29, 0x1bf5f9be, 0x3c4df45c, 0xdb5052cb,\n    0x2907bf33, 0xce1a19a4, 0x16d96282, 0xf1c4c415, 0x039329ed,\n    0xe48e8f7a, 0x6964d9e0, 0x8e797f77, 0x7c2e928f, 0x9b333418,\n    0x43f04f3e, 0xa4ede9a9, 0x56ba0451, 0xb1a7a2c6, 0x19ca1f95,\n    0xfed7b902, 0x0c8054fa, 0xeb9df26d, 0x335e894b, 0xd4432fdc,\n    0x2614c224, 0xc10964b3, 0x4ce33229, 0xabfe94be, 0x59a97946,\n    0xbeb4dfd1, 0x6677a4f7, 0x816a0260, 0x733def98, 0x9420490f,\n    0xb39844ed, 0x5485e27a, 0xa6d20f82, 0x41cfa915, 0x990cd233,\n    0x7e1174a4, 0x8c46995c, 0x6b5b3fcb, 0xe6b16951, 0x01accfc6,\n    0xf3fb223e, 0x14e684a9, 0xcc25ff8f, 0x2b385918, 0xd96fb4e0,\n    0x3e721277},\n   {0x00000000, 0xa58b900e, 0x9066265d, 0x35edb653, 0xfbbd4afb,\n    0x5e36daf5, 0x6bdb6ca6, 0xce50fca8, 0x2c0b93b7, 0x898003b9,\n    0xbc6db5ea, 0x19e625e4, 0xd7b6d94c, 0x723d4942, 0x47d0ff11,\n    0xe25b6f1f, 0x5817276e, 0xfd9cb760, 0xc8710133, 0x6dfa913d,\n    0xa3aa6d95, 0x0621fd9b, 0x33cc4bc8, 0x9647dbc6, 0x741cb4d9,\n    0xd19724d7, 0xe47a9284, 0x41f1028a, 0x8fa1fe22, 0x2a2a6e2c,\n    0x1fc7d87f, 0xba4c4871, 0xb02e4edc, 0x15a5ded2, 0x20486881,\n    0x85c3f88f, 0x4b930427, 0xee189429, 0xdbf5227a, 0x7e7eb274,\n    0x9c25dd6b, 0x39ae4d65, 0x0c43fb36, 0xa9c86b38, 0x67989790,\n    0xc213079e, 0xf7feb1cd, 0x527521c3, 0xe83969b2, 0x4db2f9bc,\n    0x785f4fef, 0xddd4dfe1, 0x13842349, 0xb60fb347, 0x83e20514,\n    0x2669951a, 0xc432fa05, 0x61b96a0b, 0x5454dc58, 0xf1df4c56,\n    0x3f8fb0fe, 0x9a0420f0, 0xafe996a3, 0x0a6206ad, 0xbb2d9bf9,\n    0x1ea60bf7, 0x2b4bbda4, 0x8ec02daa, 0x4090d102, 0xe51b410c,\n    0xd0f6f75f, 0x757d6751, 0x9726084e, 0x32ad9840, 0x07402e13,\n    0xa2cbbe1d, 0x6c9b42b5, 0xc910d2bb, 0xfcfd64e8, 0x5976f4e6,\n    0xe33abc97, 0x46b12c99, 0x735c9aca, 0xd6d70ac4, 0x1887f66c,\n    0xbd0c6662, 0x88e1d031, 0x2d6a403f, 0xcf312f20, 0x6ababf2e,\n    0x5f57097d, 0xfadc9973, 0x348c65db, 0x9107f5d5, 0xa4ea4386,\n    0x0161d388, 0x0b03d525, 0xae88452b, 0x9b65f378, 0x3eee6376,\n    0xf0be9fde, 0x55350fd0, 0x60d8b983, 0xc553298d, 0x27084692,\n    0x8283d69c, 0xb76e60cf, 0x12e5f0c1, 0xdcb50c69, 0x793e9c67,\n    0x4cd32a34, 0xe958ba3a, 0x5314f24b, 0xf69f6245, 0xc372d416,\n    0x66f94418, 0xa8a9b8b0, 0x0d2228be, 0x38cf9eed, 0x9d440ee3,\n    0x7f1f61fc, 0xda94f1f2, 0xef7947a1, 0x4af2d7af, 0x84a22b07,\n    0x2129bb09, 0x14c40d5a, 0xb14f9d54, 0xad2a31b3, 0x08a1a1bd,\n    0x3d4c17ee, 0x98c787e0, 0x56977b48, 0xf31ceb46, 0xc6f15d15,\n    0x637acd1b, 0x8121a204, 0x24aa320a, 0x11478459, 0xb4cc1457,\n    0x7a9ce8ff, 0xdf1778f1, 0xeafacea2, 0x4f715eac, 0xf53d16dd,\n    0x50b686d3, 0x655b3080, 0xc0d0a08e, 0x0e805c26, 0xab0bcc28,\n    0x9ee67a7b, 0x3b6dea75, 0xd936856a, 0x7cbd1564, 0x4950a337,\n    0xecdb3339, 0x228bcf91, 0x87005f9f, 0xb2ede9cc, 0x176679c2,\n    0x1d047f6f, 0xb88fef61, 0x8d625932, 0x28e9c93c, 0xe6b93594,\n    0x4332a59a, 0x76df13c9, 0xd35483c7, 0x310fecd8, 0x94847cd6,\n    0xa169ca85, 0x04e25a8b, 0xcab2a623, 0x6f39362d, 0x5ad4807e,\n    0xff5f1070, 0x45135801, 0xe098c80f, 0xd5757e5c, 0x70feee52,\n    0xbeae12fa, 0x1b2582f4, 0x2ec834a7, 0x8b43a4a9, 0x6918cbb6,\n    0xcc935bb8, 0xf97eedeb, 0x5cf57de5, 0x92a5814d, 0x372e1143,\n    0x02c3a710, 0xa748371e, 0x1607aa4a, 0xb38c3a44, 0x86618c17,\n    0x23ea1c19, 0xedbae0b1, 0x483170bf, 0x7ddcc6ec, 0xd85756e2,\n    0x3a0c39fd, 0x9f87a9f3, 0xaa6a1fa0, 0x0fe18fae, 0xc1b17306,\n    0x643ae308, 0x51d7555b, 0xf45cc555, 0x4e108d24, 0xeb9b1d2a,\n    0xde76ab79, 0x7bfd3b77, 0xb5adc7df, 0x102657d1, 0x25cbe182,\n    0x8040718c, 0x621b1e93, 0xc7908e9d, 0xf27d38ce, 0x57f6a8c0,\n    0x99a65468, 0x3c2dc466, 0x09c07235, 0xac4be23b, 0xa629e496,\n    0x03a27498, 0x364fc2cb, 0x93c452c5, 0x5d94ae6d, 0xf81f3e63,\n    0xcdf28830, 0x6879183e, 0x8a227721, 0x2fa9e72f, 0x1a44517c,\n    0xbfcfc172, 0x719f3dda, 0xd414add4, 0xe1f91b87, 0x44728b89,\n    0xfe3ec3f8, 0x5bb553f6, 0x6e58e5a5, 0xcbd375ab, 0x05838903,\n    0xa008190d, 0x95e5af5e, 0x306e3f50, 0xd235504f, 0x77bec041,\n    0x42537612, 0xe7d8e61c, 0x29881ab4, 0x8c038aba, 0xb9ee3ce9,\n    0x1c65ace7}};\n\nlocal const z_word_t FAR crc_braid_big_table[][256] = {\n   {0x0000000000000000, 0x0e908ba500000000, 0x5d26669000000000,\n    0x53b6ed3500000000, 0xfb4abdfb00000000, 0xf5da365e00000000,\n    0xa66cdb6b00000000, 0xa8fc50ce00000000, 0xb7930b2c00000000,\n    0xb903808900000000, 0xeab56dbc00000000, 0xe425e61900000000,\n    0x4cd9b6d700000000, 0x42493d7200000000, 0x11ffd04700000000,\n    0x1f6f5be200000000, 0x6e27175800000000, 0x60b79cfd00000000,\n    0x330171c800000000, 0x3d91fa6d00000000, 0x956daaa300000000,\n    0x9bfd210600000000, 0xc84bcc3300000000, 0xc6db479600000000,\n    0xd9b41c7400000000, 0xd72497d100000000, 0x84927ae400000000,\n    0x8a02f14100000000, 0x22fea18f00000000, 0x2c6e2a2a00000000,\n    0x7fd8c71f00000000, 0x71484cba00000000, 0xdc4e2eb000000000,\n    0xd2dea51500000000, 0x8168482000000000, 0x8ff8c38500000000,\n    0x2704934b00000000, 0x299418ee00000000, 0x7a22f5db00000000,\n    0x74b27e7e00000000, 0x6bdd259c00000000, 0x654dae3900000000,\n    0x36fb430c00000000, 0x386bc8a900000000, 0x9097986700000000,\n    0x9e0713c200000000, 0xcdb1fef700000000, 0xc321755200000000,\n    0xb26939e800000000, 0xbcf9b24d00000000, 0xef4f5f7800000000,\n    0xe1dfd4dd00000000, 0x4923841300000000, 0x47b30fb600000000,\n    0x1405e28300000000, 0x1a95692600000000, 0x05fa32c400000000,\n    0x0b6ab96100000000, 0x58dc545400000000, 0x564cdff100000000,\n    0xfeb08f3f00000000, 0xf020049a00000000, 0xa396e9af00000000,\n    0xad06620a00000000, 0xf99b2dbb00000000, 0xf70ba61e00000000,\n    0xa4bd4b2b00000000, 0xaa2dc08e00000000, 0x02d1904000000000,\n    0x0c411be500000000, 0x5ff7f6d000000000, 0x51677d7500000000,\n    0x4e08269700000000, 0x4098ad3200000000, 0x132e400700000000,\n    0x1dbecba200000000, 0xb5429b6c00000000, 0xbbd210c900000000,\n    0xe864fdfc00000000, 0xe6f4765900000000, 0x97bc3ae300000000,\n    0x992cb14600000000, 0xca9a5c7300000000, 0xc40ad7d600000000,\n    0x6cf6871800000000, 0x62660cbd00000000, 0x31d0e18800000000,\n    0x3f406a2d00000000, 0x202f31cf00000000, 0x2ebfba6a00000000,\n    0x7d09575f00000000, 0x7399dcfa00000000, 0xdb658c3400000000,\n    0xd5f5079100000000, 0x8643eaa400000000, 0x88d3610100000000,\n    0x25d5030b00000000, 0x2b4588ae00000000, 0x78f3659b00000000,\n    0x7663ee3e00000000, 0xde9fbef000000000, 0xd00f355500000000,\n    0x83b9d86000000000, 0x8d2953c500000000, 0x9246082700000000,\n    0x9cd6838200000000, 0xcf606eb700000000, 0xc1f0e51200000000,\n    0x690cb5dc00000000, 0x679c3e7900000000, 0x342ad34c00000000,\n    0x3aba58e900000000, 0x4bf2145300000000, 0x45629ff600000000,\n    0x16d472c300000000, 0x1844f96600000000, 0xb0b8a9a800000000,\n    0xbe28220d00000000, 0xed9ecf3800000000, 0xe30e449d00000000,\n    0xfc611f7f00000000, 0xf2f194da00000000, 0xa14779ef00000000,\n    0xafd7f24a00000000, 0x072ba28400000000, 0x09bb292100000000,\n    0x5a0dc41400000000, 0x549d4fb100000000, 0xb3312aad00000000,\n    0xbda1a10800000000, 0xee174c3d00000000, 0xe087c79800000000,\n    0x487b975600000000, 0x46eb1cf300000000, 0x155df1c600000000,\n    0x1bcd7a6300000000, 0x04a2218100000000, 0x0a32aa2400000000,\n    0x5984471100000000, 0x5714ccb400000000, 0xffe89c7a00000000,\n    0xf17817df00000000, 0xa2cefaea00000000, 0xac5e714f00000000,\n    0xdd163df500000000, 0xd386b65000000000, 0x80305b6500000000,\n    0x8ea0d0c000000000, 0x265c800e00000000, 0x28cc0bab00000000,\n    0x7b7ae69e00000000, 0x75ea6d3b00000000, 0x6a8536d900000000,\n    0x6415bd7c00000000, 0x37a3504900000000, 0x3933dbec00000000,\n    0x91cf8b2200000000, 0x9f5f008700000000, 0xcce9edb200000000,\n    0xc279661700000000, 0x6f7f041d00000000, 0x61ef8fb800000000,\n    0x3259628d00000000, 0x3cc9e92800000000, 0x9435b9e600000000,\n    0x9aa5324300000000, 0xc913df7600000000, 0xc78354d300000000,\n    0xd8ec0f3100000000, 0xd67c849400000000, 0x85ca69a100000000,\n    0x8b5ae20400000000, 0x23a6b2ca00000000, 0x2d36396f00000000,\n    0x7e80d45a00000000, 0x70105fff00000000, 0x0158134500000000,\n    0x0fc898e000000000, 0x5c7e75d500000000, 0x52eefe7000000000,\n    0xfa12aebe00000000, 0xf482251b00000000, 0xa734c82e00000000,\n    0xa9a4438b00000000, 0xb6cb186900000000, 0xb85b93cc00000000,\n    0xebed7ef900000000, 0xe57df55c00000000, 0x4d81a59200000000,\n    0x43112e3700000000, 0x10a7c30200000000, 0x1e3748a700000000,\n    0x4aaa071600000000, 0x443a8cb300000000, 0x178c618600000000,\n    0x191cea2300000000, 0xb1e0baed00000000, 0xbf70314800000000,\n    0xecc6dc7d00000000, 0xe25657d800000000, 0xfd390c3a00000000,\n    0xf3a9879f00000000, 0xa01f6aaa00000000, 0xae8fe10f00000000,\n    0x0673b1c100000000, 0x08e33a6400000000, 0x5b55d75100000000,\n    0x55c55cf400000000, 0x248d104e00000000, 0x2a1d9beb00000000,\n    0x79ab76de00000000, 0x773bfd7b00000000, 0xdfc7adb500000000,\n    0xd157261000000000, 0x82e1cb2500000000, 0x8c71408000000000,\n    0x931e1b6200000000, 0x9d8e90c700000000, 0xce387df200000000,\n    0xc0a8f65700000000, 0x6854a69900000000, 0x66c42d3c00000000,\n    0x3572c00900000000, 0x3be24bac00000000, 0x96e429a600000000,\n    0x9874a20300000000, 0xcbc24f3600000000, 0xc552c49300000000,\n    0x6dae945d00000000, 0x633e1ff800000000, 0x3088f2cd00000000,\n    0x3e18796800000000, 0x2177228a00000000, 0x2fe7a92f00000000,\n    0x7c51441a00000000, 0x72c1cfbf00000000, 0xda3d9f7100000000,\n    0xd4ad14d400000000, 0x871bf9e100000000, 0x898b724400000000,\n    0xf8c33efe00000000, 0xf653b55b00000000, 0xa5e5586e00000000,\n    0xab75d3cb00000000, 0x0389830500000000, 0x0d1908a000000000,\n    0x5eafe59500000000, 0x503f6e3000000000, 0x4f5035d200000000,\n    0x41c0be7700000000, 0x1276534200000000, 0x1ce6d8e700000000,\n    0xb41a882900000000, 0xba8a038c00000000, 0xe93ceeb900000000,\n    0xe7ac651c00000000},\n   {0x0000000000000000, 0x97a61de700000000, 0x6f4b4a1500000000,\n    0xf8ed57f200000000, 0xde96942a00000000, 0x493089cd00000000,\n    0xb1ddde3f00000000, 0x267bc3d800000000, 0xbc2d295500000000,\n    0x2b8b34b200000000, 0xd366634000000000, 0x44c07ea700000000,\n    0x62bbbd7f00000000, 0xf51da09800000000, 0x0df0f76a00000000,\n    0x9a56ea8d00000000, 0x785b52aa00000000, 0xeffd4f4d00000000,\n    0x171018bf00000000, 0x80b6055800000000, 0xa6cdc68000000000,\n    0x316bdb6700000000, 0xc9868c9500000000, 0x5e20917200000000,\n    0xc4767bff00000000, 0x53d0661800000000, 0xab3d31ea00000000,\n    0x3c9b2c0d00000000, 0x1ae0efd500000000, 0x8d46f23200000000,\n    0x75aba5c000000000, 0xe20db82700000000, 0xb1b0d58f00000000,\n    0x2616c86800000000, 0xdefb9f9a00000000, 0x495d827d00000000,\n    0x6f2641a500000000, 0xf8805c4200000000, 0x006d0bb000000000,\n    0x97cb165700000000, 0x0d9dfcda00000000, 0x9a3be13d00000000,\n    0x62d6b6cf00000000, 0xf570ab2800000000, 0xd30b68f000000000,\n    0x44ad751700000000, 0xbc4022e500000000, 0x2be63f0200000000,\n    0xc9eb872500000000, 0x5e4d9ac200000000, 0xa6a0cd3000000000,\n    0x3106d0d700000000, 0x177d130f00000000, 0x80db0ee800000000,\n    0x7836591a00000000, 0xef9044fd00000000, 0x75c6ae7000000000,\n    0xe260b39700000000, 0x1a8de46500000000, 0x8d2bf98200000000,\n    0xab503a5a00000000, 0x3cf627bd00000000, 0xc41b704f00000000,\n    0x53bd6da800000000, 0x2367dac400000000, 0xb4c1c72300000000,\n    0x4c2c90d100000000, 0xdb8a8d3600000000, 0xfdf14eee00000000,\n    0x6a57530900000000, 0x92ba04fb00000000, 0x051c191c00000000,\n    0x9f4af39100000000, 0x08ecee7600000000, 0xf001b98400000000,\n    0x67a7a46300000000, 0x41dc67bb00000000, 0xd67a7a5c00000000,\n    0x2e972dae00000000, 0xb931304900000000, 0x5b3c886e00000000,\n    0xcc9a958900000000, 0x3477c27b00000000, 0xa3d1df9c00000000,\n    0x85aa1c4400000000, 0x120c01a300000000, 0xeae1565100000000,\n    0x7d474bb600000000, 0xe711a13b00000000, 0x70b7bcdc00000000,\n    0x885aeb2e00000000, 0x1ffcf6c900000000, 0x3987351100000000,\n    0xae2128f600000000, 0x56cc7f0400000000, 0xc16a62e300000000,\n    0x92d70f4b00000000, 0x057112ac00000000, 0xfd9c455e00000000,\n    0x6a3a58b900000000, 0x4c419b6100000000, 0xdbe7868600000000,\n    0x230ad17400000000, 0xb4accc9300000000, 0x2efa261e00000000,\n    0xb95c3bf900000000, 0x41b16c0b00000000, 0xd61771ec00000000,\n    0xf06cb23400000000, 0x67caafd300000000, 0x9f27f82100000000,\n    0x0881e5c600000000, 0xea8c5de100000000, 0x7d2a400600000000,\n    0x85c717f400000000, 0x12610a1300000000, 0x341ac9cb00000000,\n    0xa3bcd42c00000000, 0x5b5183de00000000, 0xccf79e3900000000,\n    0x56a174b400000000, 0xc107695300000000, 0x39ea3ea100000000,\n    0xae4c234600000000, 0x8837e09e00000000, 0x1f91fd7900000000,\n    0xe77caa8b00000000, 0x70dab76c00000000, 0x07c8c55200000000,\n    0x906ed8b500000000, 0x68838f4700000000, 0xff2592a000000000,\n    0xd95e517800000000, 0x4ef84c9f00000000, 0xb6151b6d00000000,\n    0x21b3068a00000000, 0xbbe5ec0700000000, 0x2c43f1e000000000,\n    0xd4aea61200000000, 0x4308bbf500000000, 0x6573782d00000000,\n    0xf2d565ca00000000, 0x0a38323800000000, 0x9d9e2fdf00000000,\n    0x7f9397f800000000, 0xe8358a1f00000000, 0x10d8dded00000000,\n    0x877ec00a00000000, 0xa10503d200000000, 0x36a31e3500000000,\n    0xce4e49c700000000, 0x59e8542000000000, 0xc3bebead00000000,\n    0x5418a34a00000000, 0xacf5f4b800000000, 0x3b53e95f00000000,\n    0x1d282a8700000000, 0x8a8e376000000000, 0x7263609200000000,\n    0xe5c57d7500000000, 0xb67810dd00000000, 0x21de0d3a00000000,\n    0xd9335ac800000000, 0x4e95472f00000000, 0x68ee84f700000000,\n    0xff48991000000000, 0x07a5cee200000000, 0x9003d30500000000,\n    0x0a55398800000000, 0x9df3246f00000000, 0x651e739d00000000,\n    0xf2b86e7a00000000, 0xd4c3ada200000000, 0x4365b04500000000,\n    0xbb88e7b700000000, 0x2c2efa5000000000, 0xce23427700000000,\n    0x59855f9000000000, 0xa168086200000000, 0x36ce158500000000,\n    0x10b5d65d00000000, 0x8713cbba00000000, 0x7ffe9c4800000000,\n    0xe85881af00000000, 0x720e6b2200000000, 0xe5a876c500000000,\n    0x1d45213700000000, 0x8ae33cd000000000, 0xac98ff0800000000,\n    0x3b3ee2ef00000000, 0xc3d3b51d00000000, 0x5475a8fa00000000,\n    0x24af1f9600000000, 0xb309027100000000, 0x4be4558300000000,\n    0xdc42486400000000, 0xfa398bbc00000000, 0x6d9f965b00000000,\n    0x9572c1a900000000, 0x02d4dc4e00000000, 0x988236c300000000,\n    0x0f242b2400000000, 0xf7c97cd600000000, 0x606f613100000000,\n    0x4614a2e900000000, 0xd1b2bf0e00000000, 0x295fe8fc00000000,\n    0xbef9f51b00000000, 0x5cf44d3c00000000, 0xcb5250db00000000,\n    0x33bf072900000000, 0xa4191ace00000000, 0x8262d91600000000,\n    0x15c4c4f100000000, 0xed29930300000000, 0x7a8f8ee400000000,\n    0xe0d9646900000000, 0x777f798e00000000, 0x8f922e7c00000000,\n    0x1834339b00000000, 0x3e4ff04300000000, 0xa9e9eda400000000,\n    0x5104ba5600000000, 0xc6a2a7b100000000, 0x951fca1900000000,\n    0x02b9d7fe00000000, 0xfa54800c00000000, 0x6df29deb00000000,\n    0x4b895e3300000000, 0xdc2f43d400000000, 0x24c2142600000000,\n    0xb36409c100000000, 0x2932e34c00000000, 0xbe94feab00000000,\n    0x4679a95900000000, 0xd1dfb4be00000000, 0xf7a4776600000000,\n    0x60026a8100000000, 0x98ef3d7300000000, 0x0f49209400000000,\n    0xed4498b300000000, 0x7ae2855400000000, 0x820fd2a600000000,\n    0x15a9cf4100000000, 0x33d20c9900000000, 0xa474117e00000000,\n    0x5c99468c00000000, 0xcb3f5b6b00000000, 0x5169b1e600000000,\n    0xc6cfac0100000000, 0x3e22fbf300000000, 0xa984e61400000000,\n    0x8fff25cc00000000, 0x1859382b00000000, 0xe0b46fd900000000,\n    0x7712723e00000000},\n   {0x0000000000000000, 0x411b8c6e00000000, 0x823618dd00000000,\n    0xc32d94b300000000, 0x456b416100000000, 0x0470cd0f00000000,\n    0xc75d59bc00000000, 0x8646d5d200000000, 0x8ad682c200000000,\n    0xcbcd0eac00000000, 0x08e09a1f00000000, 0x49fb167100000000,\n    0xcfbdc3a300000000, 0x8ea64fcd00000000, 0x4d8bdb7e00000000,\n    0x0c90571000000000, 0x55ab745e00000000, 0x14b0f83000000000,\n    0xd79d6c8300000000, 0x9686e0ed00000000, 0x10c0353f00000000,\n    0x51dbb95100000000, 0x92f62de200000000, 0xd3eda18c00000000,\n    0xdf7df69c00000000, 0x9e667af200000000, 0x5d4bee4100000000,\n    0x1c50622f00000000, 0x9a16b7fd00000000, 0xdb0d3b9300000000,\n    0x1820af2000000000, 0x593b234e00000000, 0xaa56e9bc00000000,\n    0xeb4d65d200000000, 0x2860f16100000000, 0x697b7d0f00000000,\n    0xef3da8dd00000000, 0xae2624b300000000, 0x6d0bb00000000000,\n    0x2c103c6e00000000, 0x20806b7e00000000, 0x619be71000000000,\n    0xa2b673a300000000, 0xe3adffcd00000000, 0x65eb2a1f00000000,\n    0x24f0a67100000000, 0xe7dd32c200000000, 0xa6c6beac00000000,\n    0xfffd9de200000000, 0xbee6118c00000000, 0x7dcb853f00000000,\n    0x3cd0095100000000, 0xba96dc8300000000, 0xfb8d50ed00000000,\n    0x38a0c45e00000000, 0x79bb483000000000, 0x752b1f2000000000,\n    0x3430934e00000000, 0xf71d07fd00000000, 0xb6068b9300000000,\n    0x30405e4100000000, 0x715bd22f00000000, 0xb276469c00000000,\n    0xf36dcaf200000000, 0x15aba3a200000000, 0x54b02fcc00000000,\n    0x979dbb7f00000000, 0xd686371100000000, 0x50c0e2c300000000,\n    0x11db6ead00000000, 0xd2f6fa1e00000000, 0x93ed767000000000,\n    0x9f7d216000000000, 0xde66ad0e00000000, 0x1d4b39bd00000000,\n    0x5c50b5d300000000, 0xda16600100000000, 0x9b0dec6f00000000,\n    0x582078dc00000000, 0x193bf4b200000000, 0x4000d7fc00000000,\n    0x011b5b9200000000, 0xc236cf2100000000, 0x832d434f00000000,\n    0x056b969d00000000, 0x44701af300000000, 0x875d8e4000000000,\n    0xc646022e00000000, 0xcad6553e00000000, 0x8bcdd95000000000,\n    0x48e04de300000000, 0x09fbc18d00000000, 0x8fbd145f00000000,\n    0xcea6983100000000, 0x0d8b0c8200000000, 0x4c9080ec00000000,\n    0xbffd4a1e00000000, 0xfee6c67000000000, 0x3dcb52c300000000,\n    0x7cd0dead00000000, 0xfa960b7f00000000, 0xbb8d871100000000,\n    0x78a013a200000000, 0x39bb9fcc00000000, 0x352bc8dc00000000,\n    0x743044b200000000, 0xb71dd00100000000, 0xf6065c6f00000000,\n    0x704089bd00000000, 0x315b05d300000000, 0xf276916000000000,\n    0xb36d1d0e00000000, 0xea563e4000000000, 0xab4db22e00000000,\n    0x6860269d00000000, 0x297baaf300000000, 0xaf3d7f2100000000,\n    0xee26f34f00000000, 0x2d0b67fc00000000, 0x6c10eb9200000000,\n    0x6080bc8200000000, 0x219b30ec00000000, 0xe2b6a45f00000000,\n    0xa3ad283100000000, 0x25ebfde300000000, 0x64f0718d00000000,\n    0xa7dde53e00000000, 0xe6c6695000000000, 0x6b50369e00000000,\n    0x2a4bbaf000000000, 0xe9662e4300000000, 0xa87da22d00000000,\n    0x2e3b77ff00000000, 0x6f20fb9100000000, 0xac0d6f2200000000,\n    0xed16e34c00000000, 0xe186b45c00000000, 0xa09d383200000000,\n    0x63b0ac8100000000, 0x22ab20ef00000000, 0xa4edf53d00000000,\n    0xe5f6795300000000, 0x26dbede000000000, 0x67c0618e00000000,\n    0x3efb42c000000000, 0x7fe0ceae00000000, 0xbccd5a1d00000000,\n    0xfdd6d67300000000, 0x7b9003a100000000, 0x3a8b8fcf00000000,\n    0xf9a61b7c00000000, 0xb8bd971200000000, 0xb42dc00200000000,\n    0xf5364c6c00000000, 0x361bd8df00000000, 0x770054b100000000,\n    0xf146816300000000, 0xb05d0d0d00000000, 0x737099be00000000,\n    0x326b15d000000000, 0xc106df2200000000, 0x801d534c00000000,\n    0x4330c7ff00000000, 0x022b4b9100000000, 0x846d9e4300000000,\n    0xc576122d00000000, 0x065b869e00000000, 0x47400af000000000,\n    0x4bd05de000000000, 0x0acbd18e00000000, 0xc9e6453d00000000,\n    0x88fdc95300000000, 0x0ebb1c8100000000, 0x4fa090ef00000000,\n    0x8c8d045c00000000, 0xcd96883200000000, 0x94adab7c00000000,\n    0xd5b6271200000000, 0x169bb3a100000000, 0x57803fcf00000000,\n    0xd1c6ea1d00000000, 0x90dd667300000000, 0x53f0f2c000000000,\n    0x12eb7eae00000000, 0x1e7b29be00000000, 0x5f60a5d000000000,\n    0x9c4d316300000000, 0xdd56bd0d00000000, 0x5b1068df00000000,\n    0x1a0be4b100000000, 0xd926700200000000, 0x983dfc6c00000000,\n    0x7efb953c00000000, 0x3fe0195200000000, 0xfccd8de100000000,\n    0xbdd6018f00000000, 0x3b90d45d00000000, 0x7a8b583300000000,\n    0xb9a6cc8000000000, 0xf8bd40ee00000000, 0xf42d17fe00000000,\n    0xb5369b9000000000, 0x761b0f2300000000, 0x3700834d00000000,\n    0xb146569f00000000, 0xf05ddaf100000000, 0x33704e4200000000,\n    0x726bc22c00000000, 0x2b50e16200000000, 0x6a4b6d0c00000000,\n    0xa966f9bf00000000, 0xe87d75d100000000, 0x6e3ba00300000000,\n    0x2f202c6d00000000, 0xec0db8de00000000, 0xad1634b000000000,\n    0xa18663a000000000, 0xe09defce00000000, 0x23b07b7d00000000,\n    0x62abf71300000000, 0xe4ed22c100000000, 0xa5f6aeaf00000000,\n    0x66db3a1c00000000, 0x27c0b67200000000, 0xd4ad7c8000000000,\n    0x95b6f0ee00000000, 0x569b645d00000000, 0x1780e83300000000,\n    0x91c63de100000000, 0xd0ddb18f00000000, 0x13f0253c00000000,\n    0x52eba95200000000, 0x5e7bfe4200000000, 0x1f60722c00000000,\n    0xdc4de69f00000000, 0x9d566af100000000, 0x1b10bf2300000000,\n    0x5a0b334d00000000, 0x9926a7fe00000000, 0xd83d2b9000000000,\n    0x810608de00000000, 0xc01d84b000000000, 0x0330100300000000,\n    0x422b9c6d00000000, 0xc46d49bf00000000, 0x8576c5d100000000,\n    0x465b516200000000, 0x0740dd0c00000000, 0x0bd08a1c00000000,\n    0x4acb067200000000, 0x89e692c100000000, 0xc8fd1eaf00000000,\n    0x4ebbcb7d00000000, 0x0fa0471300000000, 0xcc8dd3a000000000,\n    0x8d965fce00000000},\n   {0x0000000000000000, 0x1dfdb50100000000, 0x3afa6b0300000000,\n    0x2707de0200000000, 0x74f4d70600000000, 0x6909620700000000,\n    0x4e0ebc0500000000, 0x53f3090400000000, 0xe8e8af0d00000000,\n    0xf5151a0c00000000, 0xd212c40e00000000, 0xcfef710f00000000,\n    0x9c1c780b00000000, 0x81e1cd0a00000000, 0xa6e6130800000000,\n    0xbb1ba60900000000, 0xd0d15f1b00000000, 0xcd2cea1a00000000,\n    0xea2b341800000000, 0xf7d6811900000000, 0xa425881d00000000,\n    0xb9d83d1c00000000, 0x9edfe31e00000000, 0x8322561f00000000,\n    0x3839f01600000000, 0x25c4451700000000, 0x02c39b1500000000,\n    0x1f3e2e1400000000, 0x4ccd271000000000, 0x5130921100000000,\n    0x76374c1300000000, 0x6bcaf91200000000, 0xa0a3bf3600000000,\n    0xbd5e0a3700000000, 0x9a59d43500000000, 0x87a4613400000000,\n    0xd457683000000000, 0xc9aadd3100000000, 0xeead033300000000,\n    0xf350b63200000000, 0x484b103b00000000, 0x55b6a53a00000000,\n    0x72b17b3800000000, 0x6f4cce3900000000, 0x3cbfc73d00000000,\n    0x2142723c00000000, 0x0645ac3e00000000, 0x1bb8193f00000000,\n    0x7072e02d00000000, 0x6d8f552c00000000, 0x4a888b2e00000000,\n    0x57753e2f00000000, 0x0486372b00000000, 0x197b822a00000000,\n    0x3e7c5c2800000000, 0x2381e92900000000, 0x989a4f2000000000,\n    0x8567fa2100000000, 0xa260242300000000, 0xbf9d912200000000,\n    0xec6e982600000000, 0xf1932d2700000000, 0xd694f32500000000,\n    0xcb69462400000000, 0x40477f6d00000000, 0x5dbaca6c00000000,\n    0x7abd146e00000000, 0x6740a16f00000000, 0x34b3a86b00000000,\n    0x294e1d6a00000000, 0x0e49c36800000000, 0x13b4766900000000,\n    0xa8afd06000000000, 0xb552656100000000, 0x9255bb6300000000,\n    0x8fa80e6200000000, 0xdc5b076600000000, 0xc1a6b26700000000,\n    0xe6a16c6500000000, 0xfb5cd96400000000, 0x9096207600000000,\n    0x8d6b957700000000, 0xaa6c4b7500000000, 0xb791fe7400000000,\n    0xe462f77000000000, 0xf99f427100000000, 0xde989c7300000000,\n    0xc365297200000000, 0x787e8f7b00000000, 0x65833a7a00000000,\n    0x4284e47800000000, 0x5f79517900000000, 0x0c8a587d00000000,\n    0x1177ed7c00000000, 0x3670337e00000000, 0x2b8d867f00000000,\n    0xe0e4c05b00000000, 0xfd19755a00000000, 0xda1eab5800000000,\n    0xc7e31e5900000000, 0x9410175d00000000, 0x89eda25c00000000,\n    0xaeea7c5e00000000, 0xb317c95f00000000, 0x080c6f5600000000,\n    0x15f1da5700000000, 0x32f6045500000000, 0x2f0bb15400000000,\n    0x7cf8b85000000000, 0x61050d5100000000, 0x4602d35300000000,\n    0x5bff665200000000, 0x30359f4000000000, 0x2dc82a4100000000,\n    0x0acff44300000000, 0x1732414200000000, 0x44c1484600000000,\n    0x593cfd4700000000, 0x7e3b234500000000, 0x63c6964400000000,\n    0xd8dd304d00000000, 0xc520854c00000000, 0xe2275b4e00000000,\n    0xffdaee4f00000000, 0xac29e74b00000000, 0xb1d4524a00000000,\n    0x96d38c4800000000, 0x8b2e394900000000, 0x808efeda00000000,\n    0x9d734bdb00000000, 0xba7495d900000000, 0xa78920d800000000,\n    0xf47a29dc00000000, 0xe9879cdd00000000, 0xce8042df00000000,\n    0xd37df7de00000000, 0x686651d700000000, 0x759be4d600000000,\n    0x529c3ad400000000, 0x4f618fd500000000, 0x1c9286d100000000,\n    0x016f33d000000000, 0x2668edd200000000, 0x3b9558d300000000,\n    0x505fa1c100000000, 0x4da214c000000000, 0x6aa5cac200000000,\n    0x77587fc300000000, 0x24ab76c700000000, 0x3956c3c600000000,\n    0x1e511dc400000000, 0x03aca8c500000000, 0xb8b70ecc00000000,\n    0xa54abbcd00000000, 0x824d65cf00000000, 0x9fb0d0ce00000000,\n    0xcc43d9ca00000000, 0xd1be6ccb00000000, 0xf6b9b2c900000000,\n    0xeb4407c800000000, 0x202d41ec00000000, 0x3dd0f4ed00000000,\n    0x1ad72aef00000000, 0x072a9fee00000000, 0x54d996ea00000000,\n    0x492423eb00000000, 0x6e23fde900000000, 0x73de48e800000000,\n    0xc8c5eee100000000, 0xd5385be000000000, 0xf23f85e200000000,\n    0xefc230e300000000, 0xbc3139e700000000, 0xa1cc8ce600000000,\n    0x86cb52e400000000, 0x9b36e7e500000000, 0xf0fc1ef700000000,\n    0xed01abf600000000, 0xca0675f400000000, 0xd7fbc0f500000000,\n    0x8408c9f100000000, 0x99f57cf000000000, 0xbef2a2f200000000,\n    0xa30f17f300000000, 0x1814b1fa00000000, 0x05e904fb00000000,\n    0x22eedaf900000000, 0x3f136ff800000000, 0x6ce066fc00000000,\n    0x711dd3fd00000000, 0x561a0dff00000000, 0x4be7b8fe00000000,\n    0xc0c981b700000000, 0xdd3434b600000000, 0xfa33eab400000000,\n    0xe7ce5fb500000000, 0xb43d56b100000000, 0xa9c0e3b000000000,\n    0x8ec73db200000000, 0x933a88b300000000, 0x28212eba00000000,\n    0x35dc9bbb00000000, 0x12db45b900000000, 0x0f26f0b800000000,\n    0x5cd5f9bc00000000, 0x41284cbd00000000, 0x662f92bf00000000,\n    0x7bd227be00000000, 0x1018deac00000000, 0x0de56bad00000000,\n    0x2ae2b5af00000000, 0x371f00ae00000000, 0x64ec09aa00000000,\n    0x7911bcab00000000, 0x5e1662a900000000, 0x43ebd7a800000000,\n    0xf8f071a100000000, 0xe50dc4a000000000, 0xc20a1aa200000000,\n    0xdff7afa300000000, 0x8c04a6a700000000, 0x91f913a600000000,\n    0xb6fecda400000000, 0xab0378a500000000, 0x606a3e8100000000,\n    0x7d978b8000000000, 0x5a90558200000000, 0x476de08300000000,\n    0x149ee98700000000, 0x09635c8600000000, 0x2e64828400000000,\n    0x3399378500000000, 0x8882918c00000000, 0x957f248d00000000,\n    0xb278fa8f00000000, 0xaf854f8e00000000, 0xfc76468a00000000,\n    0xe18bf38b00000000, 0xc68c2d8900000000, 0xdb71988800000000,\n    0xb0bb619a00000000, 0xad46d49b00000000, 0x8a410a9900000000,\n    0x97bcbf9800000000, 0xc44fb69c00000000, 0xd9b2039d00000000,\n    0xfeb5dd9f00000000, 0xe348689e00000000, 0x5853ce9700000000,\n    0x45ae7b9600000000, 0x62a9a59400000000, 0x7f54109500000000,\n    0x2ca7199100000000, 0x315aac9000000000, 0x165d729200000000,\n    0x0ba0c79300000000},\n   {0x0000000000000000, 0x24d9076300000000, 0x48b20fc600000000,\n    0x6c6b08a500000000, 0xd1626e5700000000, 0xf5bb693400000000,\n    0x99d0619100000000, 0xbd0966f200000000, 0xa2c5dcae00000000,\n    0x861cdbcd00000000, 0xea77d36800000000, 0xceaed40b00000000,\n    0x73a7b2f900000000, 0x577eb59a00000000, 0x3b15bd3f00000000,\n    0x1fccba5c00000000, 0x058dc88600000000, 0x2154cfe500000000,\n    0x4d3fc74000000000, 0x69e6c02300000000, 0xd4efa6d100000000,\n    0xf036a1b200000000, 0x9c5da91700000000, 0xb884ae7400000000,\n    0xa748142800000000, 0x8391134b00000000, 0xeffa1bee00000000,\n    0xcb231c8d00000000, 0x762a7a7f00000000, 0x52f37d1c00000000,\n    0x3e9875b900000000, 0x1a4172da00000000, 0x4b1ce0d600000000,\n    0x6fc5e7b500000000, 0x03aeef1000000000, 0x2777e87300000000,\n    0x9a7e8e8100000000, 0xbea789e200000000, 0xd2cc814700000000,\n    0xf615862400000000, 0xe9d93c7800000000, 0xcd003b1b00000000,\n    0xa16b33be00000000, 0x85b234dd00000000, 0x38bb522f00000000,\n    0x1c62554c00000000, 0x70095de900000000, 0x54d05a8a00000000,\n    0x4e91285000000000, 0x6a482f3300000000, 0x0623279600000000,\n    0x22fa20f500000000, 0x9ff3460700000000, 0xbb2a416400000000,\n    0xd74149c100000000, 0xf3984ea200000000, 0xec54f4fe00000000,\n    0xc88df39d00000000, 0xa4e6fb3800000000, 0x803ffc5b00000000,\n    0x3d369aa900000000, 0x19ef9dca00000000, 0x7584956f00000000,\n    0x515d920c00000000, 0xd73eb17600000000, 0xf3e7b61500000000,\n    0x9f8cbeb000000000, 0xbb55b9d300000000, 0x065cdf2100000000,\n    0x2285d84200000000, 0x4eeed0e700000000, 0x6a37d78400000000,\n    0x75fb6dd800000000, 0x51226abb00000000, 0x3d49621e00000000,\n    0x1990657d00000000, 0xa499038f00000000, 0x804004ec00000000,\n    0xec2b0c4900000000, 0xc8f20b2a00000000, 0xd2b379f000000000,\n    0xf66a7e9300000000, 0x9a01763600000000, 0xbed8715500000000,\n    0x03d117a700000000, 0x270810c400000000, 0x4b63186100000000,\n    0x6fba1f0200000000, 0x7076a55e00000000, 0x54afa23d00000000,\n    0x38c4aa9800000000, 0x1c1dadfb00000000, 0xa114cb0900000000,\n    0x85cdcc6a00000000, 0xe9a6c4cf00000000, 0xcd7fc3ac00000000,\n    0x9c2251a000000000, 0xb8fb56c300000000, 0xd4905e6600000000,\n    0xf049590500000000, 0x4d403ff700000000, 0x6999389400000000,\n    0x05f2303100000000, 0x212b375200000000, 0x3ee78d0e00000000,\n    0x1a3e8a6d00000000, 0x765582c800000000, 0x528c85ab00000000,\n    0xef85e35900000000, 0xcb5ce43a00000000, 0xa737ec9f00000000,\n    0x83eeebfc00000000, 0x99af992600000000, 0xbd769e4500000000,\n    0xd11d96e000000000, 0xf5c4918300000000, 0x48cdf77100000000,\n    0x6c14f01200000000, 0x007ff8b700000000, 0x24a6ffd400000000,\n    0x3b6a458800000000, 0x1fb342eb00000000, 0x73d84a4e00000000,\n    0x57014d2d00000000, 0xea082bdf00000000, 0xced12cbc00000000,\n    0xa2ba241900000000, 0x8663237a00000000, 0xae7d62ed00000000,\n    0x8aa4658e00000000, 0xe6cf6d2b00000000, 0xc2166a4800000000,\n    0x7f1f0cba00000000, 0x5bc60bd900000000, 0x37ad037c00000000,\n    0x1374041f00000000, 0x0cb8be4300000000, 0x2861b92000000000,\n    0x440ab18500000000, 0x60d3b6e600000000, 0xdddad01400000000,\n    0xf903d77700000000, 0x9568dfd200000000, 0xb1b1d8b100000000,\n    0xabf0aa6b00000000, 0x8f29ad0800000000, 0xe342a5ad00000000,\n    0xc79ba2ce00000000, 0x7a92c43c00000000, 0x5e4bc35f00000000,\n    0x3220cbfa00000000, 0x16f9cc9900000000, 0x093576c500000000,\n    0x2dec71a600000000, 0x4187790300000000, 0x655e7e6000000000,\n    0xd857189200000000, 0xfc8e1ff100000000, 0x90e5175400000000,\n    0xb43c103700000000, 0xe561823b00000000, 0xc1b8855800000000,\n    0xadd38dfd00000000, 0x890a8a9e00000000, 0x3403ec6c00000000,\n    0x10daeb0f00000000, 0x7cb1e3aa00000000, 0x5868e4c900000000,\n    0x47a45e9500000000, 0x637d59f600000000, 0x0f16515300000000,\n    0x2bcf563000000000, 0x96c630c200000000, 0xb21f37a100000000,\n    0xde743f0400000000, 0xfaad386700000000, 0xe0ec4abd00000000,\n    0xc4354dde00000000, 0xa85e457b00000000, 0x8c87421800000000,\n    0x318e24ea00000000, 0x1557238900000000, 0x793c2b2c00000000,\n    0x5de52c4f00000000, 0x4229961300000000, 0x66f0917000000000,\n    0x0a9b99d500000000, 0x2e429eb600000000, 0x934bf84400000000,\n    0xb792ff2700000000, 0xdbf9f78200000000, 0xff20f0e100000000,\n    0x7943d39b00000000, 0x5d9ad4f800000000, 0x31f1dc5d00000000,\n    0x1528db3e00000000, 0xa821bdcc00000000, 0x8cf8baaf00000000,\n    0xe093b20a00000000, 0xc44ab56900000000, 0xdb860f3500000000,\n    0xff5f085600000000, 0x933400f300000000, 0xb7ed079000000000,\n    0x0ae4616200000000, 0x2e3d660100000000, 0x42566ea400000000,\n    0x668f69c700000000, 0x7cce1b1d00000000, 0x58171c7e00000000,\n    0x347c14db00000000, 0x10a513b800000000, 0xadac754a00000000,\n    0x8975722900000000, 0xe51e7a8c00000000, 0xc1c77def00000000,\n    0xde0bc7b300000000, 0xfad2c0d000000000, 0x96b9c87500000000,\n    0xb260cf1600000000, 0x0f69a9e400000000, 0x2bb0ae8700000000,\n    0x47dba62200000000, 0x6302a14100000000, 0x325f334d00000000,\n    0x1686342e00000000, 0x7aed3c8b00000000, 0x5e343be800000000,\n    0xe33d5d1a00000000, 0xc7e45a7900000000, 0xab8f52dc00000000,\n    0x8f5655bf00000000, 0x909aefe300000000, 0xb443e88000000000,\n    0xd828e02500000000, 0xfcf1e74600000000, 0x41f881b400000000,\n    0x652186d700000000, 0x094a8e7200000000, 0x2d93891100000000,\n    0x37d2fbcb00000000, 0x130bfca800000000, 0x7f60f40d00000000,\n    0x5bb9f36e00000000, 0xe6b0959c00000000, 0xc26992ff00000000,\n    0xae029a5a00000000, 0x8adb9d3900000000, 0x9517276500000000,\n    0xb1ce200600000000, 0xdda528a300000000, 0xf97c2fc000000000,\n    0x4475493200000000, 0x60ac4e5100000000, 0x0cc746f400000000,\n    0x281e419700000000},\n   {0x0000000000000000, 0x08e3603c00000000, 0x10c6c17800000000,\n    0x1825a14400000000, 0x208c83f100000000, 0x286fe3cd00000000,\n    0x304a428900000000, 0x38a922b500000000, 0x011e763800000000,\n    0x09fd160400000000, 0x11d8b74000000000, 0x193bd77c00000000,\n    0x2192f5c900000000, 0x297195f500000000, 0x315434b100000000,\n    0x39b7548d00000000, 0x023cec7000000000, 0x0adf8c4c00000000,\n    0x12fa2d0800000000, 0x1a194d3400000000, 0x22b06f8100000000,\n    0x2a530fbd00000000, 0x3276aef900000000, 0x3a95cec500000000,\n    0x03229a4800000000, 0x0bc1fa7400000000, 0x13e45b3000000000,\n    0x1b073b0c00000000, 0x23ae19b900000000, 0x2b4d798500000000,\n    0x3368d8c100000000, 0x3b8bb8fd00000000, 0x0478d8e100000000,\n    0x0c9bb8dd00000000, 0x14be199900000000, 0x1c5d79a500000000,\n    0x24f45b1000000000, 0x2c173b2c00000000, 0x34329a6800000000,\n    0x3cd1fa5400000000, 0x0566aed900000000, 0x0d85cee500000000,\n    0x15a06fa100000000, 0x1d430f9d00000000, 0x25ea2d2800000000,\n    0x2d094d1400000000, 0x352cec5000000000, 0x3dcf8c6c00000000,\n    0x0644349100000000, 0x0ea754ad00000000, 0x1682f5e900000000,\n    0x1e6195d500000000, 0x26c8b76000000000, 0x2e2bd75c00000000,\n    0x360e761800000000, 0x3eed162400000000, 0x075a42a900000000,\n    0x0fb9229500000000, 0x179c83d100000000, 0x1f7fe3ed00000000,\n    0x27d6c15800000000, 0x2f35a16400000000, 0x3710002000000000,\n    0x3ff3601c00000000, 0x49f6c11800000000, 0x4115a12400000000,\n    0x5930006000000000, 0x51d3605c00000000, 0x697a42e900000000,\n    0x619922d500000000, 0x79bc839100000000, 0x715fe3ad00000000,\n    0x48e8b72000000000, 0x400bd71c00000000, 0x582e765800000000,\n    0x50cd166400000000, 0x686434d100000000, 0x608754ed00000000,\n    0x78a2f5a900000000, 0x7041959500000000, 0x4bca2d6800000000,\n    0x43294d5400000000, 0x5b0cec1000000000, 0x53ef8c2c00000000,\n    0x6b46ae9900000000, 0x63a5cea500000000, 0x7b806fe100000000,\n    0x73630fdd00000000, 0x4ad45b5000000000, 0x42373b6c00000000,\n    0x5a129a2800000000, 0x52f1fa1400000000, 0x6a58d8a100000000,\n    0x62bbb89d00000000, 0x7a9e19d900000000, 0x727d79e500000000,\n    0x4d8e19f900000000, 0x456d79c500000000, 0x5d48d88100000000,\n    0x55abb8bd00000000, 0x6d029a0800000000, 0x65e1fa3400000000,\n    0x7dc45b7000000000, 0x75273b4c00000000, 0x4c906fc100000000,\n    0x44730ffd00000000, 0x5c56aeb900000000, 0x54b5ce8500000000,\n    0x6c1cec3000000000, 0x64ff8c0c00000000, 0x7cda2d4800000000,\n    0x74394d7400000000, 0x4fb2f58900000000, 0x475195b500000000,\n    0x5f7434f100000000, 0x579754cd00000000, 0x6f3e767800000000,\n    0x67dd164400000000, 0x7ff8b70000000000, 0x771bd73c00000000,\n    0x4eac83b100000000, 0x464fe38d00000000, 0x5e6a42c900000000,\n    0x568922f500000000, 0x6e20004000000000, 0x66c3607c00000000,\n    0x7ee6c13800000000, 0x7605a10400000000, 0x92ec833100000000,\n    0x9a0fe30d00000000, 0x822a424900000000, 0x8ac9227500000000,\n    0xb26000c000000000, 0xba8360fc00000000, 0xa2a6c1b800000000,\n    0xaa45a18400000000, 0x93f2f50900000000, 0x9b11953500000000,\n    0x8334347100000000, 0x8bd7544d00000000, 0xb37e76f800000000,\n    0xbb9d16c400000000, 0xa3b8b78000000000, 0xab5bd7bc00000000,\n    0x90d06f4100000000, 0x98330f7d00000000, 0x8016ae3900000000,\n    0x88f5ce0500000000, 0xb05cecb000000000, 0xb8bf8c8c00000000,\n    0xa09a2dc800000000, 0xa8794df400000000, 0x91ce197900000000,\n    0x992d794500000000, 0x8108d80100000000, 0x89ebb83d00000000,\n    0xb1429a8800000000, 0xb9a1fab400000000, 0xa1845bf000000000,\n    0xa9673bcc00000000, 0x96945bd000000000, 0x9e773bec00000000,\n    0x86529aa800000000, 0x8eb1fa9400000000, 0xb618d82100000000,\n    0xbefbb81d00000000, 0xa6de195900000000, 0xae3d796500000000,\n    0x978a2de800000000, 0x9f694dd400000000, 0x874cec9000000000,\n    0x8faf8cac00000000, 0xb706ae1900000000, 0xbfe5ce2500000000,\n    0xa7c06f6100000000, 0xaf230f5d00000000, 0x94a8b7a000000000,\n    0x9c4bd79c00000000, 0x846e76d800000000, 0x8c8d16e400000000,\n    0xb424345100000000, 0xbcc7546d00000000, 0xa4e2f52900000000,\n    0xac01951500000000, 0x95b6c19800000000, 0x9d55a1a400000000,\n    0x857000e000000000, 0x8d9360dc00000000, 0xb53a426900000000,\n    0xbdd9225500000000, 0xa5fc831100000000, 0xad1fe32d00000000,\n    0xdb1a422900000000, 0xd3f9221500000000, 0xcbdc835100000000,\n    0xc33fe36d00000000, 0xfb96c1d800000000, 0xf375a1e400000000,\n    0xeb5000a000000000, 0xe3b3609c00000000, 0xda04341100000000,\n    0xd2e7542d00000000, 0xcac2f56900000000, 0xc221955500000000,\n    0xfa88b7e000000000, 0xf26bd7dc00000000, 0xea4e769800000000,\n    0xe2ad16a400000000, 0xd926ae5900000000, 0xd1c5ce6500000000,\n    0xc9e06f2100000000, 0xc1030f1d00000000, 0xf9aa2da800000000,\n    0xf1494d9400000000, 0xe96cecd000000000, 0xe18f8cec00000000,\n    0xd838d86100000000, 0xd0dbb85d00000000, 0xc8fe191900000000,\n    0xc01d792500000000, 0xf8b45b9000000000, 0xf0573bac00000000,\n    0xe8729ae800000000, 0xe091fad400000000, 0xdf629ac800000000,\n    0xd781faf400000000, 0xcfa45bb000000000, 0xc7473b8c00000000,\n    0xffee193900000000, 0xf70d790500000000, 0xef28d84100000000,\n    0xe7cbb87d00000000, 0xde7cecf000000000, 0xd69f8ccc00000000,\n    0xceba2d8800000000, 0xc6594db400000000, 0xfef06f0100000000,\n    0xf6130f3d00000000, 0xee36ae7900000000, 0xe6d5ce4500000000,\n    0xdd5e76b800000000, 0xd5bd168400000000, 0xcd98b7c000000000,\n    0xc57bd7fc00000000, 0xfdd2f54900000000, 0xf531957500000000,\n    0xed14343100000000, 0xe5f7540d00000000, 0xdc40008000000000,\n    0xd4a360bc00000000, 0xcc86c1f800000000, 0xc465a1c400000000,\n    0xfccc837100000000, 0xf42fe34d00000000, 0xec0a420900000000,\n    0xe4e9223500000000},\n   {0x0000000000000000, 0xd1e8e70e00000000, 0xa2d1cf1d00000000,\n    0x7339281300000000, 0x44a39f3b00000000, 0x954b783500000000,\n    0xe672502600000000, 0x379ab72800000000, 0x88463f7700000000,\n    0x59aed87900000000, 0x2a97f06a00000000, 0xfb7f176400000000,\n    0xcce5a04c00000000, 0x1d0d474200000000, 0x6e346f5100000000,\n    0xbfdc885f00000000, 0x108d7eee00000000, 0xc16599e000000000,\n    0xb25cb1f300000000, 0x63b456fd00000000, 0x542ee1d500000000,\n    0x85c606db00000000, 0xf6ff2ec800000000, 0x2717c9c600000000,\n    0x98cb419900000000, 0x4923a69700000000, 0x3a1a8e8400000000,\n    0xebf2698a00000000, 0xdc68dea200000000, 0x0d8039ac00000000,\n    0x7eb911bf00000000, 0xaf51f6b100000000, 0x611c8c0700000000,\n    0xb0f46b0900000000, 0xc3cd431a00000000, 0x1225a41400000000,\n    0x25bf133c00000000, 0xf457f43200000000, 0x876edc2100000000,\n    0x56863b2f00000000, 0xe95ab37000000000, 0x38b2547e00000000,\n    0x4b8b7c6d00000000, 0x9a639b6300000000, 0xadf92c4b00000000,\n    0x7c11cb4500000000, 0x0f28e35600000000, 0xdec0045800000000,\n    0x7191f2e900000000, 0xa07915e700000000, 0xd3403df400000000,\n    0x02a8dafa00000000, 0x35326dd200000000, 0xe4da8adc00000000,\n    0x97e3a2cf00000000, 0x460b45c100000000, 0xf9d7cd9e00000000,\n    0x283f2a9000000000, 0x5b06028300000000, 0x8aeee58d00000000,\n    0xbd7452a500000000, 0x6c9cb5ab00000000, 0x1fa59db800000000,\n    0xce4d7ab600000000, 0xc238180f00000000, 0x13d0ff0100000000,\n    0x60e9d71200000000, 0xb101301c00000000, 0x869b873400000000,\n    0x5773603a00000000, 0x244a482900000000, 0xf5a2af2700000000,\n    0x4a7e277800000000, 0x9b96c07600000000, 0xe8afe86500000000,\n    0x39470f6b00000000, 0x0eddb84300000000, 0xdf355f4d00000000,\n    0xac0c775e00000000, 0x7de4905000000000, 0xd2b566e100000000,\n    0x035d81ef00000000, 0x7064a9fc00000000, 0xa18c4ef200000000,\n    0x9616f9da00000000, 0x47fe1ed400000000, 0x34c736c700000000,\n    0xe52fd1c900000000, 0x5af3599600000000, 0x8b1bbe9800000000,\n    0xf822968b00000000, 0x29ca718500000000, 0x1e50c6ad00000000,\n    0xcfb821a300000000, 0xbc8109b000000000, 0x6d69eebe00000000,\n    0xa324940800000000, 0x72cc730600000000, 0x01f55b1500000000,\n    0xd01dbc1b00000000, 0xe7870b3300000000, 0x366fec3d00000000,\n    0x4556c42e00000000, 0x94be232000000000, 0x2b62ab7f00000000,\n    0xfa8a4c7100000000, 0x89b3646200000000, 0x585b836c00000000,\n    0x6fc1344400000000, 0xbe29d34a00000000, 0xcd10fb5900000000,\n    0x1cf81c5700000000, 0xb3a9eae600000000, 0x62410de800000000,\n    0x117825fb00000000, 0xc090c2f500000000, 0xf70a75dd00000000,\n    0x26e292d300000000, 0x55dbbac000000000, 0x84335dce00000000,\n    0x3befd59100000000, 0xea07329f00000000, 0x993e1a8c00000000,\n    0x48d6fd8200000000, 0x7f4c4aaa00000000, 0xaea4ada400000000,\n    0xdd9d85b700000000, 0x0c7562b900000000, 0x8471301e00000000,\n    0x5599d71000000000, 0x26a0ff0300000000, 0xf748180d00000000,\n    0xc0d2af2500000000, 0x113a482b00000000, 0x6203603800000000,\n    0xb3eb873600000000, 0x0c370f6900000000, 0xdddfe86700000000,\n    0xaee6c07400000000, 0x7f0e277a00000000, 0x4894905200000000,\n    0x997c775c00000000, 0xea455f4f00000000, 0x3badb84100000000,\n    0x94fc4ef000000000, 0x4514a9fe00000000, 0x362d81ed00000000,\n    0xe7c566e300000000, 0xd05fd1cb00000000, 0x01b736c500000000,\n    0x728e1ed600000000, 0xa366f9d800000000, 0x1cba718700000000,\n    0xcd52968900000000, 0xbe6bbe9a00000000, 0x6f83599400000000,\n    0x5819eebc00000000, 0x89f109b200000000, 0xfac821a100000000,\n    0x2b20c6af00000000, 0xe56dbc1900000000, 0x34855b1700000000,\n    0x47bc730400000000, 0x9654940a00000000, 0xa1ce232200000000,\n    0x7026c42c00000000, 0x031fec3f00000000, 0xd2f70b3100000000,\n    0x6d2b836e00000000, 0xbcc3646000000000, 0xcffa4c7300000000,\n    0x1e12ab7d00000000, 0x29881c5500000000, 0xf860fb5b00000000,\n    0x8b59d34800000000, 0x5ab1344600000000, 0xf5e0c2f700000000,\n    0x240825f900000000, 0x57310dea00000000, 0x86d9eae400000000,\n    0xb1435dcc00000000, 0x60abbac200000000, 0x139292d100000000,\n    0xc27a75df00000000, 0x7da6fd8000000000, 0xac4e1a8e00000000,\n    0xdf77329d00000000, 0x0e9fd59300000000, 0x390562bb00000000,\n    0xe8ed85b500000000, 0x9bd4ada600000000, 0x4a3c4aa800000000,\n    0x4649281100000000, 0x97a1cf1f00000000, 0xe498e70c00000000,\n    0x3570000200000000, 0x02eab72a00000000, 0xd302502400000000,\n    0xa03b783700000000, 0x71d39f3900000000, 0xce0f176600000000,\n    0x1fe7f06800000000, 0x6cded87b00000000, 0xbd363f7500000000,\n    0x8aac885d00000000, 0x5b446f5300000000, 0x287d474000000000,\n    0xf995a04e00000000, 0x56c456ff00000000, 0x872cb1f100000000,\n    0xf41599e200000000, 0x25fd7eec00000000, 0x1267c9c400000000,\n    0xc38f2eca00000000, 0xb0b606d900000000, 0x615ee1d700000000,\n    0xde82698800000000, 0x0f6a8e8600000000, 0x7c53a69500000000,\n    0xadbb419b00000000, 0x9a21f6b300000000, 0x4bc911bd00000000,\n    0x38f039ae00000000, 0xe918dea000000000, 0x2755a41600000000,\n    0xf6bd431800000000, 0x85846b0b00000000, 0x546c8c0500000000,\n    0x63f63b2d00000000, 0xb21edc2300000000, 0xc127f43000000000,\n    0x10cf133e00000000, 0xaf139b6100000000, 0x7efb7c6f00000000,\n    0x0dc2547c00000000, 0xdc2ab37200000000, 0xebb0045a00000000,\n    0x3a58e35400000000, 0x4961cb4700000000, 0x98892c4900000000,\n    0x37d8daf800000000, 0xe6303df600000000, 0x950915e500000000,\n    0x44e1f2eb00000000, 0x737b45c300000000, 0xa293a2cd00000000,\n    0xd1aa8ade00000000, 0x00426dd000000000, 0xbf9ee58f00000000,\n    0x6e76028100000000, 0x1d4f2a9200000000, 0xcca7cd9c00000000,\n    0xfb3d7ab400000000, 0x2ad59dba00000000, 0x59ecb5a900000000,\n    0x880452a700000000},\n   {0x0000000000000000, 0xaa05daf100000000, 0x150dc53800000000,\n    0xbf081fc900000000, 0x2a1a8a7100000000, 0x801f508000000000,\n    0x3f174f4900000000, 0x951295b800000000, 0x543414e300000000,\n    0xfe31ce1200000000, 0x4139d1db00000000, 0xeb3c0b2a00000000,\n    0x7e2e9e9200000000, 0xd42b446300000000, 0x6b235baa00000000,\n    0xc126815b00000000, 0xe96e591d00000000, 0x436b83ec00000000,\n    0xfc639c2500000000, 0x566646d400000000, 0xc374d36c00000000,\n    0x6971099d00000000, 0xd679165400000000, 0x7c7ccca500000000,\n    0xbd5a4dfe00000000, 0x175f970f00000000, 0xa85788c600000000,\n    0x0252523700000000, 0x9740c78f00000000, 0x3d451d7e00000000,\n    0x824d02b700000000, 0x2848d84600000000, 0xd2ddb23a00000000,\n    0x78d868cb00000000, 0xc7d0770200000000, 0x6dd5adf300000000,\n    0xf8c7384b00000000, 0x52c2e2ba00000000, 0xedcafd7300000000,\n    0x47cf278200000000, 0x86e9a6d900000000, 0x2cec7c2800000000,\n    0x93e463e100000000, 0x39e1b91000000000, 0xacf32ca800000000,\n    0x06f6f65900000000, 0xb9fee99000000000, 0x13fb336100000000,\n    0x3bb3eb2700000000, 0x91b631d600000000, 0x2ebe2e1f00000000,\n    0x84bbf4ee00000000, 0x11a9615600000000, 0xbbacbba700000000,\n    0x04a4a46e00000000, 0xaea17e9f00000000, 0x6f87ffc400000000,\n    0xc582253500000000, 0x7a8a3afc00000000, 0xd08fe00d00000000,\n    0x459d75b500000000, 0xef98af4400000000, 0x5090b08d00000000,\n    0xfa956a7c00000000, 0xa4bb657500000000, 0x0ebebf8400000000,\n    0xb1b6a04d00000000, 0x1bb37abc00000000, 0x8ea1ef0400000000,\n    0x24a435f500000000, 0x9bac2a3c00000000, 0x31a9f0cd00000000,\n    0xf08f719600000000, 0x5a8aab6700000000, 0xe582b4ae00000000,\n    0x4f876e5f00000000, 0xda95fbe700000000, 0x7090211600000000,\n    0xcf983edf00000000, 0x659de42e00000000, 0x4dd53c6800000000,\n    0xe7d0e69900000000, 0x58d8f95000000000, 0xf2dd23a100000000,\n    0x67cfb61900000000, 0xcdca6ce800000000, 0x72c2732100000000,\n    0xd8c7a9d000000000, 0x19e1288b00000000, 0xb3e4f27a00000000,\n    0x0cecedb300000000, 0xa6e9374200000000, 0x33fba2fa00000000,\n    0x99fe780b00000000, 0x26f667c200000000, 0x8cf3bd3300000000,\n    0x7666d74f00000000, 0xdc630dbe00000000, 0x636b127700000000,\n    0xc96ec88600000000, 0x5c7c5d3e00000000, 0xf67987cf00000000,\n    0x4971980600000000, 0xe37442f700000000, 0x2252c3ac00000000,\n    0x8857195d00000000, 0x375f069400000000, 0x9d5adc6500000000,\n    0x084849dd00000000, 0xa24d932c00000000, 0x1d458ce500000000,\n    0xb740561400000000, 0x9f088e5200000000, 0x350d54a300000000,\n    0x8a054b6a00000000, 0x2000919b00000000, 0xb512042300000000,\n    0x1f17ded200000000, 0xa01fc11b00000000, 0x0a1a1bea00000000,\n    0xcb3c9ab100000000, 0x6139404000000000, 0xde315f8900000000,\n    0x7434857800000000, 0xe12610c000000000, 0x4b23ca3100000000,\n    0xf42bd5f800000000, 0x5e2e0f0900000000, 0x4877cbea00000000,\n    0xe272111b00000000, 0x5d7a0ed200000000, 0xf77fd42300000000,\n    0x626d419b00000000, 0xc8689b6a00000000, 0x776084a300000000,\n    0xdd655e5200000000, 0x1c43df0900000000, 0xb64605f800000000,\n    0x094e1a3100000000, 0xa34bc0c000000000, 0x3659557800000000,\n    0x9c5c8f8900000000, 0x2354904000000000, 0x89514ab100000000,\n    0xa11992f700000000, 0x0b1c480600000000, 0xb41457cf00000000,\n    0x1e118d3e00000000, 0x8b03188600000000, 0x2106c27700000000,\n    0x9e0eddbe00000000, 0x340b074f00000000, 0xf52d861400000000,\n    0x5f285ce500000000, 0xe020432c00000000, 0x4a2599dd00000000,\n    0xdf370c6500000000, 0x7532d69400000000, 0xca3ac95d00000000,\n    0x603f13ac00000000, 0x9aaa79d000000000, 0x30afa32100000000,\n    0x8fa7bce800000000, 0x25a2661900000000, 0xb0b0f3a100000000,\n    0x1ab5295000000000, 0xa5bd369900000000, 0x0fb8ec6800000000,\n    0xce9e6d3300000000, 0x649bb7c200000000, 0xdb93a80b00000000,\n    0x719672fa00000000, 0xe484e74200000000, 0x4e813db300000000,\n    0xf189227a00000000, 0x5b8cf88b00000000, 0x73c420cd00000000,\n    0xd9c1fa3c00000000, 0x66c9e5f500000000, 0xcccc3f0400000000,\n    0x59deaabc00000000, 0xf3db704d00000000, 0x4cd36f8400000000,\n    0xe6d6b57500000000, 0x27f0342e00000000, 0x8df5eedf00000000,\n    0x32fdf11600000000, 0x98f82be700000000, 0x0deabe5f00000000,\n    0xa7ef64ae00000000, 0x18e77b6700000000, 0xb2e2a19600000000,\n    0xecccae9f00000000, 0x46c9746e00000000, 0xf9c16ba700000000,\n    0x53c4b15600000000, 0xc6d624ee00000000, 0x6cd3fe1f00000000,\n    0xd3dbe1d600000000, 0x79de3b2700000000, 0xb8f8ba7c00000000,\n    0x12fd608d00000000, 0xadf57f4400000000, 0x07f0a5b500000000,\n    0x92e2300d00000000, 0x38e7eafc00000000, 0x87eff53500000000,\n    0x2dea2fc400000000, 0x05a2f78200000000, 0xafa72d7300000000,\n    0x10af32ba00000000, 0xbaaae84b00000000, 0x2fb87df300000000,\n    0x85bda70200000000, 0x3ab5b8cb00000000, 0x90b0623a00000000,\n    0x5196e36100000000, 0xfb93399000000000, 0x449b265900000000,\n    0xee9efca800000000, 0x7b8c691000000000, 0xd189b3e100000000,\n    0x6e81ac2800000000, 0xc48476d900000000, 0x3e111ca500000000,\n    0x9414c65400000000, 0x2b1cd99d00000000, 0x8119036c00000000,\n    0x140b96d400000000, 0xbe0e4c2500000000, 0x010653ec00000000,\n    0xab03891d00000000, 0x6a25084600000000, 0xc020d2b700000000,\n    0x7f28cd7e00000000, 0xd52d178f00000000, 0x403f823700000000,\n    0xea3a58c600000000, 0x5532470f00000000, 0xff379dfe00000000,\n    0xd77f45b800000000, 0x7d7a9f4900000000, 0xc272808000000000,\n    0x68775a7100000000, 0xfd65cfc900000000, 0x5760153800000000,\n    0xe8680af100000000, 0x426dd00000000000, 0x834b515b00000000,\n    0x294e8baa00000000, 0x9646946300000000, 0x3c434e9200000000,\n    0xa951db2a00000000, 0x035401db00000000, 0xbc5c1e1200000000,\n    0x1659c4e300000000}};\n\n#else /* W == 4 */\n\nlocal const z_crc_t FAR crc_braid_table[][256] = {\n   {0x00000000, 0xae689191, 0x87a02563, 0x29c8b4f2, 0xd4314c87,\n    0x7a59dd16, 0x539169e4, 0xfdf9f875, 0x73139f4f, 0xdd7b0ede,\n    0xf4b3ba2c, 0x5adb2bbd, 0xa722d3c8, 0x094a4259, 0x2082f6ab,\n    0x8eea673a, 0xe6273e9e, 0x484faf0f, 0x61871bfd, 0xcfef8a6c,\n    0x32167219, 0x9c7ee388, 0xb5b6577a, 0x1bdec6eb, 0x9534a1d1,\n    0x3b5c3040, 0x129484b2, 0xbcfc1523, 0x4105ed56, 0xef6d7cc7,\n    0xc6a5c835, 0x68cd59a4, 0x173f7b7d, 0xb957eaec, 0x909f5e1e,\n    0x3ef7cf8f, 0xc30e37fa, 0x6d66a66b, 0x44ae1299, 0xeac68308,\n    0x642ce432, 0xca4475a3, 0xe38cc151, 0x4de450c0, 0xb01da8b5,\n    0x1e753924, 0x37bd8dd6, 0x99d51c47, 0xf11845e3, 0x5f70d472,\n    0x76b86080, 0xd8d0f111, 0x25290964, 0x8b4198f5, 0xa2892c07,\n    0x0ce1bd96, 0x820bdaac, 0x2c634b3d, 0x05abffcf, 0xabc36e5e,\n    0x563a962b, 0xf85207ba, 0xd19ab348, 0x7ff222d9, 0x2e7ef6fa,\n    0x8016676b, 0xa9ded399, 0x07b64208, 0xfa4fba7d, 0x54272bec,\n    0x7def9f1e, 0xd3870e8f, 0x5d6d69b5, 0xf305f824, 0xdacd4cd6,\n    0x74a5dd47, 0x895c2532, 0x2734b4a3, 0x0efc0051, 0xa09491c0,\n    0xc859c864, 0x663159f5, 0x4ff9ed07, 0xe1917c96, 0x1c6884e3,\n    0xb2001572, 0x9bc8a180, 0x35a03011, 0xbb4a572b, 0x1522c6ba,\n    0x3cea7248, 0x9282e3d9, 0x6f7b1bac, 0xc1138a3d, 0xe8db3ecf,\n    0x46b3af5e, 0x39418d87, 0x97291c16, 0xbee1a8e4, 0x10893975,\n    0xed70c100, 0x43185091, 0x6ad0e463, 0xc4b875f2, 0x4a5212c8,\n    0xe43a8359, 0xcdf237ab, 0x639aa63a, 0x9e635e4f, 0x300bcfde,\n    0x19c37b2c, 0xb7abeabd, 0xdf66b319, 0x710e2288, 0x58c6967a,\n    0xf6ae07eb, 0x0b57ff9e, 0xa53f6e0f, 0x8cf7dafd, 0x229f4b6c,\n    0xac752c56, 0x021dbdc7, 0x2bd50935, 0x85bd98a4, 0x784460d1,\n    0xd62cf140, 0xffe445b2, 0x518cd423, 0x5cfdedf4, 0xf2957c65,\n    0xdb5dc897, 0x75355906, 0x88cca173, 0x26a430e2, 0x0f6c8410,\n    0xa1041581, 0x2fee72bb, 0x8186e32a, 0xa84e57d8, 0x0626c649,\n    0xfbdf3e3c, 0x55b7afad, 0x7c7f1b5f, 0xd2178ace, 0xbadad36a,\n    0x14b242fb, 0x3d7af609, 0x93126798, 0x6eeb9fed, 0xc0830e7c,\n    0xe94bba8e, 0x47232b1f, 0xc9c94c25, 0x67a1ddb4, 0x4e696946,\n    0xe001f8d7, 0x1df800a2, 0xb3909133, 0x9a5825c1, 0x3430b450,\n    0x4bc29689, 0xe5aa0718, 0xcc62b3ea, 0x620a227b, 0x9ff3da0e,\n    0x319b4b9f, 0x1853ff6d, 0xb63b6efc, 0x38d109c6, 0x96b99857,\n    0xbf712ca5, 0x1119bd34, 0xece04541, 0x4288d4d0, 0x6b406022,\n    0xc528f1b3, 0xade5a817, 0x038d3986, 0x2a458d74, 0x842d1ce5,\n    0x79d4e490, 0xd7bc7501, 0xfe74c1f3, 0x501c5062, 0xdef63758,\n    0x709ea6c9, 0x5956123b, 0xf73e83aa, 0x0ac77bdf, 0xa4afea4e,\n    0x8d675ebc, 0x230fcf2d, 0x72831b0e, 0xdceb8a9f, 0xf5233e6d,\n    0x5b4baffc, 0xa6b25789, 0x08dac618, 0x211272ea, 0x8f7ae37b,\n    0x01908441, 0xaff815d0, 0x8630a122, 0x285830b3, 0xd5a1c8c6,\n    0x7bc95957, 0x5201eda5, 0xfc697c34, 0x94a42590, 0x3accb401,\n    0x130400f3, 0xbd6c9162, 0x40956917, 0xeefdf886, 0xc7354c74,\n    0x695ddde5, 0xe7b7badf, 0x49df2b4e, 0x60179fbc, 0xce7f0e2d,\n    0x3386f658, 0x9dee67c9, 0xb426d33b, 0x1a4e42aa, 0x65bc6073,\n    0xcbd4f1e2, 0xe21c4510, 0x4c74d481, 0xb18d2cf4, 0x1fe5bd65,\n    0x362d0997, 0x98459806, 0x16afff3c, 0xb8c76ead, 0x910fda5f,\n    0x3f674bce, 0xc29eb3bb, 0x6cf6222a, 0x453e96d8, 0xeb560749,\n    0x839b5eed, 0x2df3cf7c, 0x043b7b8e, 0xaa53ea1f, 0x57aa126a,\n    0xf9c283fb, 0xd00a3709, 0x7e62a698, 0xf088c1a2, 0x5ee05033,\n    0x7728e4c1, 0xd9407550, 0x24b98d25, 0x8ad11cb4, 0xa319a846,\n    0x0d7139d7},\n   {0x00000000, 0xb9fbdbe8, 0xa886b191, 0x117d6a79, 0x8a7c6563,\n    0x3387be8b, 0x22fad4f2, 0x9b010f1a, 0xcf89cc87, 0x7672176f,\n    0x670f7d16, 0xdef4a6fe, 0x45f5a9e4, 0xfc0e720c, 0xed731875,\n    0x5488c39d, 0x44629f4f, 0xfd9944a7, 0xece42ede, 0x551ff536,\n    0xce1efa2c, 0x77e521c4, 0x66984bbd, 0xdf639055, 0x8beb53c8,\n    0x32108820, 0x236de259, 0x9a9639b1, 0x019736ab, 0xb86ced43,\n    0xa911873a, 0x10ea5cd2, 0x88c53e9e, 0x313ee576, 0x20438f0f,\n    0x99b854e7, 0x02b95bfd, 0xbb428015, 0xaa3fea6c, 0x13c43184,\n    0x474cf219, 0xfeb729f1, 0xefca4388, 0x56319860, 0xcd30977a,\n    0x74cb4c92, 0x65b626eb, 0xdc4dfd03, 0xcca7a1d1, 0x755c7a39,\n    0x64211040, 0xdddacba8, 0x46dbc4b2, 0xff201f5a, 0xee5d7523,\n    0x57a6aecb, 0x032e6d56, 0xbad5b6be, 0xaba8dcc7, 0x1253072f,\n    0x89520835, 0x30a9d3dd, 0x21d4b9a4, 0x982f624c, 0xcafb7b7d,\n    0x7300a095, 0x627dcaec, 0xdb861104, 0x40871e1e, 0xf97cc5f6,\n    0xe801af8f, 0x51fa7467, 0x0572b7fa, 0xbc896c12, 0xadf4066b,\n    0x140fdd83, 0x8f0ed299, 0x36f50971, 0x27886308, 0x9e73b8e0,\n    0x8e99e432, 0x37623fda, 0x261f55a3, 0x9fe48e4b, 0x04e58151,\n    0xbd1e5ab9, 0xac6330c0, 0x1598eb28, 0x411028b5, 0xf8ebf35d,\n    0xe9969924, 0x506d42cc, 0xcb6c4dd6, 0x7297963e, 0x63eafc47,\n    0xda1127af, 0x423e45e3, 0xfbc59e0b, 0xeab8f472, 0x53432f9a,\n    0xc8422080, 0x71b9fb68, 0x60c49111, 0xd93f4af9, 0x8db78964,\n    0x344c528c, 0x253138f5, 0x9ccae31d, 0x07cbec07, 0xbe3037ef,\n    0xaf4d5d96, 0x16b6867e, 0x065cdaac, 0xbfa70144, 0xaeda6b3d,\n    0x1721b0d5, 0x8c20bfcf, 0x35db6427, 0x24a60e5e, 0x9d5dd5b6,\n    0xc9d5162b, 0x702ecdc3, 0x6153a7ba, 0xd8a87c52, 0x43a97348,\n    0xfa52a8a0, 0xeb2fc2d9, 0x52d41931, 0x4e87f0bb, 0xf77c2b53,\n    0xe601412a, 0x5ffa9ac2, 0xc4fb95d8, 0x7d004e30, 0x6c7d2449,\n    0xd586ffa1, 0x810e3c3c, 0x38f5e7d4, 0x29888dad, 0x90735645,\n    0x0b72595f, 0xb28982b7, 0xa3f4e8ce, 0x1a0f3326, 0x0ae56ff4,\n    0xb31eb41c, 0xa263de65, 0x1b98058d, 0x80990a97, 0x3962d17f,\n    0x281fbb06, 0x91e460ee, 0xc56ca373, 0x7c97789b, 0x6dea12e2,\n    0xd411c90a, 0x4f10c610, 0xf6eb1df8, 0xe7967781, 0x5e6dac69,\n    0xc642ce25, 0x7fb915cd, 0x6ec47fb4, 0xd73fa45c, 0x4c3eab46,\n    0xf5c570ae, 0xe4b81ad7, 0x5d43c13f, 0x09cb02a2, 0xb030d94a,\n    0xa14db333, 0x18b668db, 0x83b767c1, 0x3a4cbc29, 0x2b31d650,\n    0x92ca0db8, 0x8220516a, 0x3bdb8a82, 0x2aa6e0fb, 0x935d3b13,\n    0x085c3409, 0xb1a7efe1, 0xa0da8598, 0x19215e70, 0x4da99ded,\n    0xf4524605, 0xe52f2c7c, 0x5cd4f794, 0xc7d5f88e, 0x7e2e2366,\n    0x6f53491f, 0xd6a892f7, 0x847c8bc6, 0x3d87502e, 0x2cfa3a57,\n    0x9501e1bf, 0x0e00eea5, 0xb7fb354d, 0xa6865f34, 0x1f7d84dc,\n    0x4bf54741, 0xf20e9ca9, 0xe373f6d0, 0x5a882d38, 0xc1892222,\n    0x7872f9ca, 0x690f93b3, 0xd0f4485b, 0xc01e1489, 0x79e5cf61,\n    0x6898a518, 0xd1637ef0, 0x4a6271ea, 0xf399aa02, 0xe2e4c07b,\n    0x5b1f1b93, 0x0f97d80e, 0xb66c03e6, 0xa711699f, 0x1eeab277,\n    0x85ebbd6d, 0x3c106685, 0x2d6d0cfc, 0x9496d714, 0x0cb9b558,\n    0xb5426eb0, 0xa43f04c9, 0x1dc4df21, 0x86c5d03b, 0x3f3e0bd3,\n    0x2e4361aa, 0x97b8ba42, 0xc33079df, 0x7acba237, 0x6bb6c84e,\n    0xd24d13a6, 0x494c1cbc, 0xf0b7c754, 0xe1caad2d, 0x583176c5,\n    0x48db2a17, 0xf120f1ff, 0xe05d9b86, 0x59a6406e, 0xc2a74f74,\n    0x7b5c949c, 0x6a21fee5, 0xd3da250d, 0x8752e690, 0x3ea93d78,\n    0x2fd45701, 0x962f8ce9, 0x0d2e83f3, 0xb4d5581b, 0xa5a83262,\n    0x1c53e98a},\n   {0x00000000, 0x9d0fe176, 0xe16ec4ad, 0x7c6125db, 0x19ac8f1b,\n    0x84a36e6d, 0xf8c24bb6, 0x65cdaac0, 0x33591e36, 0xae56ff40,\n    0xd237da9b, 0x4f383bed, 0x2af5912d, 0xb7fa705b, 0xcb9b5580,\n    0x5694b4f6, 0x66b23c6c, 0xfbbddd1a, 0x87dcf8c1, 0x1ad319b7,\n    0x7f1eb377, 0xe2115201, 0x9e7077da, 0x037f96ac, 0x55eb225a,\n    0xc8e4c32c, 0xb485e6f7, 0x298a0781, 0x4c47ad41, 0xd1484c37,\n    0xad2969ec, 0x3026889a, 0xcd6478d8, 0x506b99ae, 0x2c0abc75,\n    0xb1055d03, 0xd4c8f7c3, 0x49c716b5, 0x35a6336e, 0xa8a9d218,\n    0xfe3d66ee, 0x63328798, 0x1f53a243, 0x825c4335, 0xe791e9f5,\n    0x7a9e0883, 0x06ff2d58, 0x9bf0cc2e, 0xabd644b4, 0x36d9a5c2,\n    0x4ab88019, 0xd7b7616f, 0xb27acbaf, 0x2f752ad9, 0x53140f02,\n    0xce1bee74, 0x988f5a82, 0x0580bbf4, 0x79e19e2f, 0xe4ee7f59,\n    0x8123d599, 0x1c2c34ef, 0x604d1134, 0xfd42f042, 0x41b9f7f1,\n    0xdcb61687, 0xa0d7335c, 0x3dd8d22a, 0x581578ea, 0xc51a999c,\n    0xb97bbc47, 0x24745d31, 0x72e0e9c7, 0xefef08b1, 0x938e2d6a,\n    0x0e81cc1c, 0x6b4c66dc, 0xf64387aa, 0x8a22a271, 0x172d4307,\n    0x270bcb9d, 0xba042aeb, 0xc6650f30, 0x5b6aee46, 0x3ea74486,\n    0xa3a8a5f0, 0xdfc9802b, 0x42c6615d, 0x1452d5ab, 0x895d34dd,\n    0xf53c1106, 0x6833f070, 0x0dfe5ab0, 0x90f1bbc6, 0xec909e1d,\n    0x719f7f6b, 0x8cdd8f29, 0x11d26e5f, 0x6db34b84, 0xf0bcaaf2,\n    0x95710032, 0x087ee144, 0x741fc49f, 0xe91025e9, 0xbf84911f,\n    0x228b7069, 0x5eea55b2, 0xc3e5b4c4, 0xa6281e04, 0x3b27ff72,\n    0x4746daa9, 0xda493bdf, 0xea6fb345, 0x77605233, 0x0b0177e8,\n    0x960e969e, 0xf3c33c5e, 0x6eccdd28, 0x12adf8f3, 0x8fa21985,\n    0xd936ad73, 0x44394c05, 0x385869de, 0xa55788a8, 0xc09a2268,\n    0x5d95c31e, 0x21f4e6c5, 0xbcfb07b3, 0x8373efe2, 0x1e7c0e94,\n    0x621d2b4f, 0xff12ca39, 0x9adf60f9, 0x07d0818f, 0x7bb1a454,\n    0xe6be4522, 0xb02af1d4, 0x2d2510a2, 0x51443579, 0xcc4bd40f,\n    0xa9867ecf, 0x34899fb9, 0x48e8ba62, 0xd5e75b14, 0xe5c1d38e,\n    0x78ce32f8, 0x04af1723, 0x99a0f655, 0xfc6d5c95, 0x6162bde3,\n    0x1d039838, 0x800c794e, 0xd698cdb8, 0x4b972cce, 0x37f60915,\n    0xaaf9e863, 0xcf3442a3, 0x523ba3d5, 0x2e5a860e, 0xb3556778,\n    0x4e17973a, 0xd318764c, 0xaf795397, 0x3276b2e1, 0x57bb1821,\n    0xcab4f957, 0xb6d5dc8c, 0x2bda3dfa, 0x7d4e890c, 0xe041687a,\n    0x9c204da1, 0x012facd7, 0x64e20617, 0xf9ede761, 0x858cc2ba,\n    0x188323cc, 0x28a5ab56, 0xb5aa4a20, 0xc9cb6ffb, 0x54c48e8d,\n    0x3109244d, 0xac06c53b, 0xd067e0e0, 0x4d680196, 0x1bfcb560,\n    0x86f35416, 0xfa9271cd, 0x679d90bb, 0x02503a7b, 0x9f5fdb0d,\n    0xe33efed6, 0x7e311fa0, 0xc2ca1813, 0x5fc5f965, 0x23a4dcbe,\n    0xbeab3dc8, 0xdb669708, 0x4669767e, 0x3a0853a5, 0xa707b2d3,\n    0xf1930625, 0x6c9ce753, 0x10fdc288, 0x8df223fe, 0xe83f893e,\n    0x75306848, 0x09514d93, 0x945eace5, 0xa478247f, 0x3977c509,\n    0x4516e0d2, 0xd81901a4, 0xbdd4ab64, 0x20db4a12, 0x5cba6fc9,\n    0xc1b58ebf, 0x97213a49, 0x0a2edb3f, 0x764ffee4, 0xeb401f92,\n    0x8e8db552, 0x13825424, 0x6fe371ff, 0xf2ec9089, 0x0fae60cb,\n    0x92a181bd, 0xeec0a466, 0x73cf4510, 0x1602efd0, 0x8b0d0ea6,\n    0xf76c2b7d, 0x6a63ca0b, 0x3cf77efd, 0xa1f89f8b, 0xdd99ba50,\n    0x40965b26, 0x255bf1e6, 0xb8541090, 0xc435354b, 0x593ad43d,\n    0x691c5ca7, 0xf413bdd1, 0x8872980a, 0x157d797c, 0x70b0d3bc,\n    0xedbf32ca, 0x91de1711, 0x0cd1f667, 0x5a454291, 0xc74aa3e7,\n    0xbb2b863c, 0x2624674a, 0x43e9cd8a, 0xdee62cfc, 0xa2870927,\n    0x3f88e851},\n   {0x00000000, 0xdd96d985, 0x605cb54b, 0xbdca6cce, 0xc0b96a96,\n    0x1d2fb313, 0xa0e5dfdd, 0x7d730658, 0x5a03d36d, 0x87950ae8,\n    0x3a5f6626, 0xe7c9bfa3, 0x9abab9fb, 0x472c607e, 0xfae60cb0,\n    0x2770d535, 0xb407a6da, 0x69917f5f, 0xd45b1391, 0x09cdca14,\n    0x74becc4c, 0xa92815c9, 0x14e27907, 0xc974a082, 0xee0475b7,\n    0x3392ac32, 0x8e58c0fc, 0x53ce1979, 0x2ebd1f21, 0xf32bc6a4,\n    0x4ee1aa6a, 0x937773ef, 0xb37e4bf5, 0x6ee89270, 0xd322febe,\n    0x0eb4273b, 0x73c72163, 0xae51f8e6, 0x139b9428, 0xce0d4dad,\n    0xe97d9898, 0x34eb411d, 0x89212dd3, 0x54b7f456, 0x29c4f20e,\n    0xf4522b8b, 0x49984745, 0x940e9ec0, 0x0779ed2f, 0xdaef34aa,\n    0x67255864, 0xbab381e1, 0xc7c087b9, 0x1a565e3c, 0xa79c32f2,\n    0x7a0aeb77, 0x5d7a3e42, 0x80ece7c7, 0x3d268b09, 0xe0b0528c,\n    0x9dc354d4, 0x40558d51, 0xfd9fe19f, 0x2009381a, 0xbd8d91ab,\n    0x601b482e, 0xddd124e0, 0x0047fd65, 0x7d34fb3d, 0xa0a222b8,\n    0x1d684e76, 0xc0fe97f3, 0xe78e42c6, 0x3a189b43, 0x87d2f78d,\n    0x5a442e08, 0x27372850, 0xfaa1f1d5, 0x476b9d1b, 0x9afd449e,\n    0x098a3771, 0xd41ceef4, 0x69d6823a, 0xb4405bbf, 0xc9335de7,\n    0x14a58462, 0xa96fe8ac, 0x74f93129, 0x5389e41c, 0x8e1f3d99,\n    0x33d55157, 0xee4388d2, 0x93308e8a, 0x4ea6570f, 0xf36c3bc1,\n    0x2efae244, 0x0ef3da5e, 0xd36503db, 0x6eaf6f15, 0xb339b690,\n    0xce4ab0c8, 0x13dc694d, 0xae160583, 0x7380dc06, 0x54f00933,\n    0x8966d0b6, 0x34acbc78, 0xe93a65fd, 0x944963a5, 0x49dfba20,\n    0xf415d6ee, 0x29830f6b, 0xbaf47c84, 0x6762a501, 0xdaa8c9cf,\n    0x073e104a, 0x7a4d1612, 0xa7dbcf97, 0x1a11a359, 0xc7877adc,\n    0xe0f7afe9, 0x3d61766c, 0x80ab1aa2, 0x5d3dc327, 0x204ec57f,\n    0xfdd81cfa, 0x40127034, 0x9d84a9b1, 0xa06a2517, 0x7dfcfc92,\n    0xc036905c, 0x1da049d9, 0x60d34f81, 0xbd459604, 0x008ffaca,\n    0xdd19234f, 0xfa69f67a, 0x27ff2fff, 0x9a354331, 0x47a39ab4,\n    0x3ad09cec, 0xe7464569, 0x5a8c29a7, 0x871af022, 0x146d83cd,\n    0xc9fb5a48, 0x74313686, 0xa9a7ef03, 0xd4d4e95b, 0x094230de,\n    0xb4885c10, 0x691e8595, 0x4e6e50a0, 0x93f88925, 0x2e32e5eb,\n    0xf3a43c6e, 0x8ed73a36, 0x5341e3b3, 0xee8b8f7d, 0x331d56f8,\n    0x13146ee2, 0xce82b767, 0x7348dba9, 0xaede022c, 0xd3ad0474,\n    0x0e3bddf1, 0xb3f1b13f, 0x6e6768ba, 0x4917bd8f, 0x9481640a,\n    0x294b08c4, 0xf4ddd141, 0x89aed719, 0x54380e9c, 0xe9f26252,\n    0x3464bbd7, 0xa713c838, 0x7a8511bd, 0xc74f7d73, 0x1ad9a4f6,\n    0x67aaa2ae, 0xba3c7b2b, 0x07f617e5, 0xda60ce60, 0xfd101b55,\n    0x2086c2d0, 0x9d4cae1e, 0x40da779b, 0x3da971c3, 0xe03fa846,\n    0x5df5c488, 0x80631d0d, 0x1de7b4bc, 0xc0716d39, 0x7dbb01f7,\n    0xa02dd872, 0xdd5ede2a, 0x00c807af, 0xbd026b61, 0x6094b2e4,\n    0x47e467d1, 0x9a72be54, 0x27b8d29a, 0xfa2e0b1f, 0x875d0d47,\n    0x5acbd4c2, 0xe701b80c, 0x3a976189, 0xa9e01266, 0x7476cbe3,\n    0xc9bca72d, 0x142a7ea8, 0x695978f0, 0xb4cfa175, 0x0905cdbb,\n    0xd493143e, 0xf3e3c10b, 0x2e75188e, 0x93bf7440, 0x4e29adc5,\n    0x335aab9d, 0xeecc7218, 0x53061ed6, 0x8e90c753, 0xae99ff49,\n    0x730f26cc, 0xcec54a02, 0x13539387, 0x6e2095df, 0xb3b64c5a,\n    0x0e7c2094, 0xd3eaf911, 0xf49a2c24, 0x290cf5a1, 0x94c6996f,\n    0x495040ea, 0x342346b2, 0xe9b59f37, 0x547ff3f9, 0x89e92a7c,\n    0x1a9e5993, 0xc7088016, 0x7ac2ecd8, 0xa754355d, 0xda273305,\n    0x07b1ea80, 0xba7b864e, 0x67ed5fcb, 0x409d8afe, 0x9d0b537b,\n    0x20c13fb5, 0xfd57e630, 0x8024e068, 0x5db239ed, 0xe0785523,\n    0x3dee8ca6}};\n\nlocal const z_word_t FAR crc_braid_big_table[][256] = {\n   {0x00000000, 0x85d996dd, 0x4bb55c60, 0xce6ccabd, 0x966ab9c0,\n    0x13b32f1d, 0xdddfe5a0, 0x5806737d, 0x6dd3035a, 0xe80a9587,\n    0x26665f3a, 0xa3bfc9e7, 0xfbb9ba9a, 0x7e602c47, 0xb00ce6fa,\n    0x35d57027, 0xdaa607b4, 0x5f7f9169, 0x91135bd4, 0x14cacd09,\n    0x4cccbe74, 0xc91528a9, 0x0779e214, 0x82a074c9, 0xb77504ee,\n    0x32ac9233, 0xfcc0588e, 0x7919ce53, 0x211fbd2e, 0xa4c62bf3,\n    0x6aaae14e, 0xef737793, 0xf54b7eb3, 0x7092e86e, 0xbefe22d3,\n    0x3b27b40e, 0x6321c773, 0xe6f851ae, 0x28949b13, 0xad4d0dce,\n    0x98987de9, 0x1d41eb34, 0xd32d2189, 0x56f4b754, 0x0ef2c429,\n    0x8b2b52f4, 0x45479849, 0xc09e0e94, 0x2fed7907, 0xaa34efda,\n    0x64582567, 0xe181b3ba, 0xb987c0c7, 0x3c5e561a, 0xf2329ca7,\n    0x77eb0a7a, 0x423e7a5d, 0xc7e7ec80, 0x098b263d, 0x8c52b0e0,\n    0xd454c39d, 0x518d5540, 0x9fe19ffd, 0x1a380920, 0xab918dbd,\n    0x2e481b60, 0xe024d1dd, 0x65fd4700, 0x3dfb347d, 0xb822a2a0,\n    0x764e681d, 0xf397fec0, 0xc6428ee7, 0x439b183a, 0x8df7d287,\n    0x082e445a, 0x50283727, 0xd5f1a1fa, 0x1b9d6b47, 0x9e44fd9a,\n    0x71378a09, 0xf4ee1cd4, 0x3a82d669, 0xbf5b40b4, 0xe75d33c9,\n    0x6284a514, 0xace86fa9, 0x2931f974, 0x1ce48953, 0x993d1f8e,\n    0x5751d533, 0xd28843ee, 0x8a8e3093, 0x0f57a64e, 0xc13b6cf3,\n    0x44e2fa2e, 0x5edaf30e, 0xdb0365d3, 0x156faf6e, 0x90b639b3,\n    0xc8b04ace, 0x4d69dc13, 0x830516ae, 0x06dc8073, 0x3309f054,\n    0xb6d06689, 0x78bcac34, 0xfd653ae9, 0xa5634994, 0x20badf49,\n    0xeed615f4, 0x6b0f8329, 0x847cf4ba, 0x01a56267, 0xcfc9a8da,\n    0x4a103e07, 0x12164d7a, 0x97cfdba7, 0x59a3111a, 0xdc7a87c7,\n    0xe9aff7e0, 0x6c76613d, 0xa21aab80, 0x27c33d5d, 0x7fc54e20,\n    0xfa1cd8fd, 0x34701240, 0xb1a9849d, 0x17256aa0, 0x92fcfc7d,\n    0x5c9036c0, 0xd949a01d, 0x814fd360, 0x049645bd, 0xcafa8f00,\n    0x4f2319dd, 0x7af669fa, 0xff2fff27, 0x3143359a, 0xb49aa347,\n    0xec9cd03a, 0x694546e7, 0xa7298c5a, 0x22f01a87, 0xcd836d14,\n    0x485afbc9, 0x86363174, 0x03efa7a9, 0x5be9d4d4, 0xde304209,\n    0x105c88b4, 0x95851e69, 0xa0506e4e, 0x2589f893, 0xebe5322e,\n    0x6e3ca4f3, 0x363ad78e, 0xb3e34153, 0x7d8f8bee, 0xf8561d33,\n    0xe26e1413, 0x67b782ce, 0xa9db4873, 0x2c02deae, 0x7404add3,\n    0xf1dd3b0e, 0x3fb1f1b3, 0xba68676e, 0x8fbd1749, 0x0a648194,\n    0xc4084b29, 0x41d1ddf4, 0x19d7ae89, 0x9c0e3854, 0x5262f2e9,\n    0xd7bb6434, 0x38c813a7, 0xbd11857a, 0x737d4fc7, 0xf6a4d91a,\n    0xaea2aa67, 0x2b7b3cba, 0xe517f607, 0x60ce60da, 0x551b10fd,\n    0xd0c28620, 0x1eae4c9d, 0x9b77da40, 0xc371a93d, 0x46a83fe0,\n    0x88c4f55d, 0x0d1d6380, 0xbcb4e71d, 0x396d71c0, 0xf701bb7d,\n    0x72d82da0, 0x2ade5edd, 0xaf07c800, 0x616b02bd, 0xe4b29460,\n    0xd167e447, 0x54be729a, 0x9ad2b827, 0x1f0b2efa, 0x470d5d87,\n    0xc2d4cb5a, 0x0cb801e7, 0x8961973a, 0x6612e0a9, 0xe3cb7674,\n    0x2da7bcc9, 0xa87e2a14, 0xf0785969, 0x75a1cfb4, 0xbbcd0509,\n    0x3e1493d4, 0x0bc1e3f3, 0x8e18752e, 0x4074bf93, 0xc5ad294e,\n    0x9dab5a33, 0x1872ccee, 0xd61e0653, 0x53c7908e, 0x49ff99ae,\n    0xcc260f73, 0x024ac5ce, 0x87935313, 0xdf95206e, 0x5a4cb6b3,\n    0x94207c0e, 0x11f9ead3, 0x242c9af4, 0xa1f50c29, 0x6f99c694,\n    0xea405049, 0xb2462334, 0x379fb5e9, 0xf9f37f54, 0x7c2ae989,\n    0x93599e1a, 0x168008c7, 0xd8ecc27a, 0x5d3554a7, 0x053327da,\n    0x80eab107, 0x4e867bba, 0xcb5fed67, 0xfe8a9d40, 0x7b530b9d,\n    0xb53fc120, 0x30e657fd, 0x68e02480, 0xed39b25d, 0x235578e0,\n    0xa68cee3d},\n   {0x00000000, 0x76e10f9d, 0xadc46ee1, 0xdb25617c, 0x1b8fac19,\n    0x6d6ea384, 0xb64bc2f8, 0xc0aacd65, 0x361e5933, 0x40ff56ae,\n    0x9bda37d2, 0xed3b384f, 0x2d91f52a, 0x5b70fab7, 0x80559bcb,\n    0xf6b49456, 0x6c3cb266, 0x1addbdfb, 0xc1f8dc87, 0xb719d31a,\n    0x77b31e7f, 0x015211e2, 0xda77709e, 0xac967f03, 0x5a22eb55,\n    0x2cc3e4c8, 0xf7e685b4, 0x81078a29, 0x41ad474c, 0x374c48d1,\n    0xec6929ad, 0x9a882630, 0xd87864cd, 0xae996b50, 0x75bc0a2c,\n    0x035d05b1, 0xc3f7c8d4, 0xb516c749, 0x6e33a635, 0x18d2a9a8,\n    0xee663dfe, 0x98873263, 0x43a2531f, 0x35435c82, 0xf5e991e7,\n    0x83089e7a, 0x582dff06, 0x2eccf09b, 0xb444d6ab, 0xc2a5d936,\n    0x1980b84a, 0x6f61b7d7, 0xafcb7ab2, 0xd92a752f, 0x020f1453,\n    0x74ee1bce, 0x825a8f98, 0xf4bb8005, 0x2f9ee179, 0x597feee4,\n    0x99d52381, 0xef342c1c, 0x34114d60, 0x42f042fd, 0xf1f7b941,\n    0x8716b6dc, 0x5c33d7a0, 0x2ad2d83d, 0xea781558, 0x9c991ac5,\n    0x47bc7bb9, 0x315d7424, 0xc7e9e072, 0xb108efef, 0x6a2d8e93,\n    0x1ccc810e, 0xdc664c6b, 0xaa8743f6, 0x71a2228a, 0x07432d17,\n    0x9dcb0b27, 0xeb2a04ba, 0x300f65c6, 0x46ee6a5b, 0x8644a73e,\n    0xf0a5a8a3, 0x2b80c9df, 0x5d61c642, 0xabd55214, 0xdd345d89,\n    0x06113cf5, 0x70f03368, 0xb05afe0d, 0xc6bbf190, 0x1d9e90ec,\n    0x6b7f9f71, 0x298fdd8c, 0x5f6ed211, 0x844bb36d, 0xf2aabcf0,\n    0x32007195, 0x44e17e08, 0x9fc41f74, 0xe92510e9, 0x1f9184bf,\n    0x69708b22, 0xb255ea5e, 0xc4b4e5c3, 0x041e28a6, 0x72ff273b,\n    0xa9da4647, 0xdf3b49da, 0x45b36fea, 0x33526077, 0xe877010b,\n    0x9e960e96, 0x5e3cc3f3, 0x28ddcc6e, 0xf3f8ad12, 0x8519a28f,\n    0x73ad36d9, 0x054c3944, 0xde695838, 0xa88857a5, 0x68229ac0,\n    0x1ec3955d, 0xc5e6f421, 0xb307fbbc, 0xe2ef7383, 0x940e7c1e,\n    0x4f2b1d62, 0x39ca12ff, 0xf960df9a, 0x8f81d007, 0x54a4b17b,\n    0x2245bee6, 0xd4f12ab0, 0xa210252d, 0x79354451, 0x0fd44bcc,\n    0xcf7e86a9, 0xb99f8934, 0x62bae848, 0x145be7d5, 0x8ed3c1e5,\n    0xf832ce78, 0x2317af04, 0x55f6a099, 0x955c6dfc, 0xe3bd6261,\n    0x3898031d, 0x4e790c80, 0xb8cd98d6, 0xce2c974b, 0x1509f637,\n    0x63e8f9aa, 0xa34234cf, 0xd5a33b52, 0x0e865a2e, 0x786755b3,\n    0x3a97174e, 0x4c7618d3, 0x975379af, 0xe1b27632, 0x2118bb57,\n    0x57f9b4ca, 0x8cdcd5b6, 0xfa3dda2b, 0x0c894e7d, 0x7a6841e0,\n    0xa14d209c, 0xd7ac2f01, 0x1706e264, 0x61e7edf9, 0xbac28c85,\n    0xcc238318, 0x56aba528, 0x204aaab5, 0xfb6fcbc9, 0x8d8ec454,\n    0x4d240931, 0x3bc506ac, 0xe0e067d0, 0x9601684d, 0x60b5fc1b,\n    0x1654f386, 0xcd7192fa, 0xbb909d67, 0x7b3a5002, 0x0ddb5f9f,\n    0xd6fe3ee3, 0xa01f317e, 0x1318cac2, 0x65f9c55f, 0xbedca423,\n    0xc83dabbe, 0x089766db, 0x7e766946, 0xa553083a, 0xd3b207a7,\n    0x250693f1, 0x53e79c6c, 0x88c2fd10, 0xfe23f28d, 0x3e893fe8,\n    0x48683075, 0x934d5109, 0xe5ac5e94, 0x7f2478a4, 0x09c57739,\n    0xd2e01645, 0xa40119d8, 0x64abd4bd, 0x124adb20, 0xc96fba5c,\n    0xbf8eb5c1, 0x493a2197, 0x3fdb2e0a, 0xe4fe4f76, 0x921f40eb,\n    0x52b58d8e, 0x24548213, 0xff71e36f, 0x8990ecf2, 0xcb60ae0f,\n    0xbd81a192, 0x66a4c0ee, 0x1045cf73, 0xd0ef0216, 0xa60e0d8b,\n    0x7d2b6cf7, 0x0bca636a, 0xfd7ef73c, 0x8b9ff8a1, 0x50ba99dd,\n    0x265b9640, 0xe6f15b25, 0x901054b8, 0x4b3535c4, 0x3dd43a59,\n    0xa75c1c69, 0xd1bd13f4, 0x0a987288, 0x7c797d15, 0xbcd3b070,\n    0xca32bfed, 0x1117de91, 0x67f6d10c, 0x9142455a, 0xe7a34ac7,\n    0x3c862bbb, 0x4a672426, 0x8acde943, 0xfc2ce6de, 0x270987a2,\n    0x51e8883f},\n   {0x00000000, 0xe8dbfbb9, 0x91b186a8, 0x796a7d11, 0x63657c8a,\n    0x8bbe8733, 0xf2d4fa22, 0x1a0f019b, 0x87cc89cf, 0x6f177276,\n    0x167d0f67, 0xfea6f4de, 0xe4a9f545, 0x0c720efc, 0x751873ed,\n    0x9dc38854, 0x4f9f6244, 0xa74499fd, 0xde2ee4ec, 0x36f51f55,\n    0x2cfa1ece, 0xc421e577, 0xbd4b9866, 0x559063df, 0xc853eb8b,\n    0x20881032, 0x59e26d23, 0xb139969a, 0xab369701, 0x43ed6cb8,\n    0x3a8711a9, 0xd25cea10, 0x9e3ec588, 0x76e53e31, 0x0f8f4320,\n    0xe754b899, 0xfd5bb902, 0x158042bb, 0x6cea3faa, 0x8431c413,\n    0x19f24c47, 0xf129b7fe, 0x8843caef, 0x60983156, 0x7a9730cd,\n    0x924ccb74, 0xeb26b665, 0x03fd4ddc, 0xd1a1a7cc, 0x397a5c75,\n    0x40102164, 0xa8cbdadd, 0xb2c4db46, 0x5a1f20ff, 0x23755dee,\n    0xcbaea657, 0x566d2e03, 0xbeb6d5ba, 0xc7dca8ab, 0x2f075312,\n    0x35085289, 0xddd3a930, 0xa4b9d421, 0x4c622f98, 0x7d7bfbca,\n    0x95a00073, 0xecca7d62, 0x041186db, 0x1e1e8740, 0xf6c57cf9,\n    0x8faf01e8, 0x6774fa51, 0xfab77205, 0x126c89bc, 0x6b06f4ad,\n    0x83dd0f14, 0x99d20e8f, 0x7109f536, 0x08638827, 0xe0b8739e,\n    0x32e4998e, 0xda3f6237, 0xa3551f26, 0x4b8ee49f, 0x5181e504,\n    0xb95a1ebd, 0xc03063ac, 0x28eb9815, 0xb5281041, 0x5df3ebf8,\n    0x249996e9, 0xcc426d50, 0xd64d6ccb, 0x3e969772, 0x47fcea63,\n    0xaf2711da, 0xe3453e42, 0x0b9ec5fb, 0x72f4b8ea, 0x9a2f4353,\n    0x802042c8, 0x68fbb971, 0x1191c460, 0xf94a3fd9, 0x6489b78d,\n    0x8c524c34, 0xf5383125, 0x1de3ca9c, 0x07eccb07, 0xef3730be,\n    0x965d4daf, 0x7e86b616, 0xacda5c06, 0x4401a7bf, 0x3d6bdaae,\n    0xd5b02117, 0xcfbf208c, 0x2764db35, 0x5e0ea624, 0xb6d55d9d,\n    0x2b16d5c9, 0xc3cd2e70, 0xbaa75361, 0x527ca8d8, 0x4873a943,\n    0xa0a852fa, 0xd9c22feb, 0x3119d452, 0xbbf0874e, 0x532b7cf7,\n    0x2a4101e6, 0xc29afa5f, 0xd895fbc4, 0x304e007d, 0x49247d6c,\n    0xa1ff86d5, 0x3c3c0e81, 0xd4e7f538, 0xad8d8829, 0x45567390,\n    0x5f59720b, 0xb78289b2, 0xcee8f4a3, 0x26330f1a, 0xf46fe50a,\n    0x1cb41eb3, 0x65de63a2, 0x8d05981b, 0x970a9980, 0x7fd16239,\n    0x06bb1f28, 0xee60e491, 0x73a36cc5, 0x9b78977c, 0xe212ea6d,\n    0x0ac911d4, 0x10c6104f, 0xf81debf6, 0x817796e7, 0x69ac6d5e,\n    0x25ce42c6, 0xcd15b97f, 0xb47fc46e, 0x5ca43fd7, 0x46ab3e4c,\n    0xae70c5f5, 0xd71ab8e4, 0x3fc1435d, 0xa202cb09, 0x4ad930b0,\n    0x33b34da1, 0xdb68b618, 0xc167b783, 0x29bc4c3a, 0x50d6312b,\n    0xb80dca92, 0x6a512082, 0x828adb3b, 0xfbe0a62a, 0x133b5d93,\n    0x09345c08, 0xe1efa7b1, 0x9885daa0, 0x705e2119, 0xed9da94d,\n    0x054652f4, 0x7c2c2fe5, 0x94f7d45c, 0x8ef8d5c7, 0x66232e7e,\n    0x1f49536f, 0xf792a8d6, 0xc68b7c84, 0x2e50873d, 0x573afa2c,\n    0xbfe10195, 0xa5ee000e, 0x4d35fbb7, 0x345f86a6, 0xdc847d1f,\n    0x4147f54b, 0xa99c0ef2, 0xd0f673e3, 0x382d885a, 0x222289c1,\n    0xcaf97278, 0xb3930f69, 0x5b48f4d0, 0x89141ec0, 0x61cfe579,\n    0x18a59868, 0xf07e63d1, 0xea71624a, 0x02aa99f3, 0x7bc0e4e2,\n    0x931b1f5b, 0x0ed8970f, 0xe6036cb6, 0x9f6911a7, 0x77b2ea1e,\n    0x6dbdeb85, 0x8566103c, 0xfc0c6d2d, 0x14d79694, 0x58b5b90c,\n    0xb06e42b5, 0xc9043fa4, 0x21dfc41d, 0x3bd0c586, 0xd30b3e3f,\n    0xaa61432e, 0x42bab897, 0xdf7930c3, 0x37a2cb7a, 0x4ec8b66b,\n    0xa6134dd2, 0xbc1c4c49, 0x54c7b7f0, 0x2dadcae1, 0xc5763158,\n    0x172adb48, 0xfff120f1, 0x869b5de0, 0x6e40a659, 0x744fa7c2,\n    0x9c945c7b, 0xe5fe216a, 0x0d25dad3, 0x90e65287, 0x783da93e,\n    0x0157d42f, 0xe98c2f96, 0xf3832e0d, 0x1b58d5b4, 0x6232a8a5,\n    0x8ae9531c},\n   {0x00000000, 0x919168ae, 0x6325a087, 0xf2b4c829, 0x874c31d4,\n    0x16dd597a, 0xe4699153, 0x75f8f9fd, 0x4f9f1373, 0xde0e7bdd,\n    0x2cbab3f4, 0xbd2bdb5a, 0xc8d322a7, 0x59424a09, 0xabf68220,\n    0x3a67ea8e, 0x9e3e27e6, 0x0faf4f48, 0xfd1b8761, 0x6c8aefcf,\n    0x19721632, 0x88e37e9c, 0x7a57b6b5, 0xebc6de1b, 0xd1a13495,\n    0x40305c3b, 0xb2849412, 0x2315fcbc, 0x56ed0541, 0xc77c6def,\n    0x35c8a5c6, 0xa459cd68, 0x7d7b3f17, 0xecea57b9, 0x1e5e9f90,\n    0x8fcff73e, 0xfa370ec3, 0x6ba6666d, 0x9912ae44, 0x0883c6ea,\n    0x32e42c64, 0xa37544ca, 0x51c18ce3, 0xc050e44d, 0xb5a81db0,\n    0x2439751e, 0xd68dbd37, 0x471cd599, 0xe34518f1, 0x72d4705f,\n    0x8060b876, 0x11f1d0d8, 0x64092925, 0xf598418b, 0x072c89a2,\n    0x96bde10c, 0xacda0b82, 0x3d4b632c, 0xcfffab05, 0x5e6ec3ab,\n    0x2b963a56, 0xba0752f8, 0x48b39ad1, 0xd922f27f, 0xfaf67e2e,\n    0x6b671680, 0x99d3dea9, 0x0842b607, 0x7dba4ffa, 0xec2b2754,\n    0x1e9fef7d, 0x8f0e87d3, 0xb5696d5d, 0x24f805f3, 0xd64ccdda,\n    0x47dda574, 0x32255c89, 0xa3b43427, 0x5100fc0e, 0xc09194a0,\n    0x64c859c8, 0xf5593166, 0x07edf94f, 0x967c91e1, 0xe384681c,\n    0x721500b2, 0x80a1c89b, 0x1130a035, 0x2b574abb, 0xbac62215,\n    0x4872ea3c, 0xd9e38292, 0xac1b7b6f, 0x3d8a13c1, 0xcf3edbe8,\n    0x5eafb346, 0x878d4139, 0x161c2997, 0xe4a8e1be, 0x75398910,\n    0x00c170ed, 0x91501843, 0x63e4d06a, 0xf275b8c4, 0xc812524a,\n    0x59833ae4, 0xab37f2cd, 0x3aa69a63, 0x4f5e639e, 0xdecf0b30,\n    0x2c7bc319, 0xbdeaabb7, 0x19b366df, 0x88220e71, 0x7a96c658,\n    0xeb07aef6, 0x9eff570b, 0x0f6e3fa5, 0xfddaf78c, 0x6c4b9f22,\n    0x562c75ac, 0xc7bd1d02, 0x3509d52b, 0xa498bd85, 0xd1604478,\n    0x40f12cd6, 0xb245e4ff, 0x23d48c51, 0xf4edfd5c, 0x657c95f2,\n    0x97c85ddb, 0x06593575, 0x73a1cc88, 0xe230a426, 0x10846c0f,\n    0x811504a1, 0xbb72ee2f, 0x2ae38681, 0xd8574ea8, 0x49c62606,\n    0x3c3edffb, 0xadafb755, 0x5f1b7f7c, 0xce8a17d2, 0x6ad3daba,\n    0xfb42b214, 0x09f67a3d, 0x98671293, 0xed9feb6e, 0x7c0e83c0,\n    0x8eba4be9, 0x1f2b2347, 0x254cc9c9, 0xb4dda167, 0x4669694e,\n    0xd7f801e0, 0xa200f81d, 0x339190b3, 0xc125589a, 0x50b43034,\n    0x8996c24b, 0x1807aae5, 0xeab362cc, 0x7b220a62, 0x0edaf39f,\n    0x9f4b9b31, 0x6dff5318, 0xfc6e3bb6, 0xc609d138, 0x5798b996,\n    0xa52c71bf, 0x34bd1911, 0x4145e0ec, 0xd0d48842, 0x2260406b,\n    0xb3f128c5, 0x17a8e5ad, 0x86398d03, 0x748d452a, 0xe51c2d84,\n    0x90e4d479, 0x0175bcd7, 0xf3c174fe, 0x62501c50, 0x5837f6de,\n    0xc9a69e70, 0x3b125659, 0xaa833ef7, 0xdf7bc70a, 0x4eeaafa4,\n    0xbc5e678d, 0x2dcf0f23, 0x0e1b8372, 0x9f8aebdc, 0x6d3e23f5,\n    0xfcaf4b5b, 0x8957b2a6, 0x18c6da08, 0xea721221, 0x7be37a8f,\n    0x41849001, 0xd015f8af, 0x22a13086, 0xb3305828, 0xc6c8a1d5,\n    0x5759c97b, 0xa5ed0152, 0x347c69fc, 0x9025a494, 0x01b4cc3a,\n    0xf3000413, 0x62916cbd, 0x17699540, 0x86f8fdee, 0x744c35c7,\n    0xe5dd5d69, 0xdfbab7e7, 0x4e2bdf49, 0xbc9f1760, 0x2d0e7fce,\n    0x58f68633, 0xc967ee9d, 0x3bd326b4, 0xaa424e1a, 0x7360bc65,\n    0xe2f1d4cb, 0x10451ce2, 0x81d4744c, 0xf42c8db1, 0x65bde51f,\n    0x97092d36, 0x06984598, 0x3cffaf16, 0xad6ec7b8, 0x5fda0f91,\n    0xce4b673f, 0xbbb39ec2, 0x2a22f66c, 0xd8963e45, 0x490756eb,\n    0xed5e9b83, 0x7ccff32d, 0x8e7b3b04, 0x1fea53aa, 0x6a12aa57,\n    0xfb83c2f9, 0x09370ad0, 0x98a6627e, 0xa2c188f0, 0x3350e05e,\n    0xc1e42877, 0x507540d9, 0x258db924, 0xb41cd18a, 0x46a819a3,\n    0xd739710d}};\n\n#endif\n\n#endif\n\n#if N == 5\n\n#if W == 8\n\nlocal const z_crc_t FAR crc_braid_table[][256] = {\n   {0x00000000, 0xaf449247, 0x85f822cf, 0x2abcb088, 0xd08143df,\n    0x7fc5d198, 0x55796110, 0xfa3df357, 0x7a7381ff, 0xd53713b8,\n    0xff8ba330, 0x50cf3177, 0xaaf2c220, 0x05b65067, 0x2f0ae0ef,\n    0x804e72a8, 0xf4e703fe, 0x5ba391b9, 0x711f2131, 0xde5bb376,\n    0x24664021, 0x8b22d266, 0xa19e62ee, 0x0edaf0a9, 0x8e948201,\n    0x21d01046, 0x0b6ca0ce, 0xa4283289, 0x5e15c1de, 0xf1515399,\n    0xdbede311, 0x74a97156, 0x32bf01bd, 0x9dfb93fa, 0xb7472372,\n    0x1803b135, 0xe23e4262, 0x4d7ad025, 0x67c660ad, 0xc882f2ea,\n    0x48cc8042, 0xe7881205, 0xcd34a28d, 0x627030ca, 0x984dc39d,\n    0x370951da, 0x1db5e152, 0xb2f17315, 0xc6580243, 0x691c9004,\n    0x43a0208c, 0xece4b2cb, 0x16d9419c, 0xb99dd3db, 0x93216353,\n    0x3c65f114, 0xbc2b83bc, 0x136f11fb, 0x39d3a173, 0x96973334,\n    0x6caac063, 0xc3ee5224, 0xe952e2ac, 0x461670eb, 0x657e037a,\n    0xca3a913d, 0xe08621b5, 0x4fc2b3f2, 0xb5ff40a5, 0x1abbd2e2,\n    0x3007626a, 0x9f43f02d, 0x1f0d8285, 0xb04910c2, 0x9af5a04a,\n    0x35b1320d, 0xcf8cc15a, 0x60c8531d, 0x4a74e395, 0xe53071d2,\n    0x91990084, 0x3edd92c3, 0x1461224b, 0xbb25b00c, 0x4118435b,\n    0xee5cd11c, 0xc4e06194, 0x6ba4f3d3, 0xebea817b, 0x44ae133c,\n    0x6e12a3b4, 0xc15631f3, 0x3b6bc2a4, 0x942f50e3, 0xbe93e06b,\n    0x11d7722c, 0x57c102c7, 0xf8859080, 0xd2392008, 0x7d7db24f,\n    0x87404118, 0x2804d35f, 0x02b863d7, 0xadfcf190, 0x2db28338,\n    0x82f6117f, 0xa84aa1f7, 0x070e33b0, 0xfd33c0e7, 0x527752a0,\n    0x78cbe228, 0xd78f706f, 0xa3260139, 0x0c62937e, 0x26de23f6,\n    0x899ab1b1, 0x73a742e6, 0xdce3d0a1, 0xf65f6029, 0x591bf26e,\n    0xd95580c6, 0x76111281, 0x5cada209, 0xf3e9304e, 0x09d4c319,\n    0xa690515e, 0x8c2ce1d6, 0x23687391, 0xcafc06f4, 0x65b894b3,\n    0x4f04243b, 0xe040b67c, 0x1a7d452b, 0xb539d76c, 0x9f8567e4,\n    0x30c1f5a3, 0xb08f870b, 0x1fcb154c, 0x3577a5c4, 0x9a333783,\n    0x600ec4d4, 0xcf4a5693, 0xe5f6e61b, 0x4ab2745c, 0x3e1b050a,\n    0x915f974d, 0xbbe327c5, 0x14a7b582, 0xee9a46d5, 0x41ded492,\n    0x6b62641a, 0xc426f65d, 0x446884f5, 0xeb2c16b2, 0xc190a63a,\n    0x6ed4347d, 0x94e9c72a, 0x3bad556d, 0x1111e5e5, 0xbe5577a2,\n    0xf8430749, 0x5707950e, 0x7dbb2586, 0xd2ffb7c1, 0x28c24496,\n    0x8786d6d1, 0xad3a6659, 0x027ef41e, 0x823086b6, 0x2d7414f1,\n    0x07c8a479, 0xa88c363e, 0x52b1c569, 0xfdf5572e, 0xd749e7a6,\n    0x780d75e1, 0x0ca404b7, 0xa3e096f0, 0x895c2678, 0x2618b43f,\n    0xdc254768, 0x7361d52f, 0x59dd65a7, 0xf699f7e0, 0x76d78548,\n    0xd993170f, 0xf32fa787, 0x5c6b35c0, 0xa656c697, 0x091254d0,\n    0x23aee458, 0x8cea761f, 0xaf82058e, 0x00c697c9, 0x2a7a2741,\n    0x853eb506, 0x7f034651, 0xd047d416, 0xfafb649e, 0x55bff6d9,\n    0xd5f18471, 0x7ab51636, 0x5009a6be, 0xff4d34f9, 0x0570c7ae,\n    0xaa3455e9, 0x8088e561, 0x2fcc7726, 0x5b650670, 0xf4219437,\n    0xde9d24bf, 0x71d9b6f8, 0x8be445af, 0x24a0d7e8, 0x0e1c6760,\n    0xa158f527, 0x2116878f, 0x8e5215c8, 0xa4eea540, 0x0baa3707,\n    0xf197c450, 0x5ed35617, 0x746fe69f, 0xdb2b74d8, 0x9d3d0433,\n    0x32799674, 0x18c526fc, 0xb781b4bb, 0x4dbc47ec, 0xe2f8d5ab,\n    0xc8446523, 0x6700f764, 0xe74e85cc, 0x480a178b, 0x62b6a703,\n    0xcdf23544, 0x37cfc613, 0x988b5454, 0xb237e4dc, 0x1d73769b,\n    0x69da07cd, 0xc69e958a, 0xec222502, 0x4366b745, 0xb95b4412,\n    0x161fd655, 0x3ca366dd, 0x93e7f49a, 0x13a98632, 0xbced1475,\n    0x9651a4fd, 0x391536ba, 0xc328c5ed, 0x6c6c57aa, 0x46d0e722,\n    0xe9947565},\n   {0x00000000, 0x4e890ba9, 0x9d121752, 0xd39b1cfb, 0xe15528e5,\n    0xafdc234c, 0x7c473fb7, 0x32ce341e, 0x19db578b, 0x57525c22,\n    0x84c940d9, 0xca404b70, 0xf88e7f6e, 0xb60774c7, 0x659c683c,\n    0x2b156395, 0x33b6af16, 0x7d3fa4bf, 0xaea4b844, 0xe02db3ed,\n    0xd2e387f3, 0x9c6a8c5a, 0x4ff190a1, 0x01789b08, 0x2a6df89d,\n    0x64e4f334, 0xb77fefcf, 0xf9f6e466, 0xcb38d078, 0x85b1dbd1,\n    0x562ac72a, 0x18a3cc83, 0x676d5e2c, 0x29e45585, 0xfa7f497e,\n    0xb4f642d7, 0x863876c9, 0xc8b17d60, 0x1b2a619b, 0x55a36a32,\n    0x7eb609a7, 0x303f020e, 0xe3a41ef5, 0xad2d155c, 0x9fe32142,\n    0xd16a2aeb, 0x02f13610, 0x4c783db9, 0x54dbf13a, 0x1a52fa93,\n    0xc9c9e668, 0x8740edc1, 0xb58ed9df, 0xfb07d276, 0x289cce8d,\n    0x6615c524, 0x4d00a6b1, 0x0389ad18, 0xd012b1e3, 0x9e9bba4a,\n    0xac558e54, 0xe2dc85fd, 0x31479906, 0x7fce92af, 0xcedabc58,\n    0x8053b7f1, 0x53c8ab0a, 0x1d41a0a3, 0x2f8f94bd, 0x61069f14,\n    0xb29d83ef, 0xfc148846, 0xd701ebd3, 0x9988e07a, 0x4a13fc81,\n    0x049af728, 0x3654c336, 0x78ddc89f, 0xab46d464, 0xe5cfdfcd,\n    0xfd6c134e, 0xb3e518e7, 0x607e041c, 0x2ef70fb5, 0x1c393bab,\n    0x52b03002, 0x812b2cf9, 0xcfa22750, 0xe4b744c5, 0xaa3e4f6c,\n    0x79a55397, 0x372c583e, 0x05e26c20, 0x4b6b6789, 0x98f07b72,\n    0xd67970db, 0xa9b7e274, 0xe73ee9dd, 0x34a5f526, 0x7a2cfe8f,\n    0x48e2ca91, 0x066bc138, 0xd5f0ddc3, 0x9b79d66a, 0xb06cb5ff,\n    0xfee5be56, 0x2d7ea2ad, 0x63f7a904, 0x51399d1a, 0x1fb096b3,\n    0xcc2b8a48, 0x82a281e1, 0x9a014d62, 0xd48846cb, 0x07135a30,\n    0x499a5199, 0x7b546587, 0x35dd6e2e, 0xe64672d5, 0xa8cf797c,\n    0x83da1ae9, 0xcd531140, 0x1ec80dbb, 0x50410612, 0x628f320c,\n    0x2c0639a5, 0xff9d255e, 0xb1142ef7, 0x46c47ef1, 0x084d7558,\n    0xdbd669a3, 0x955f620a, 0xa7915614, 0xe9185dbd, 0x3a834146,\n    0x740a4aef, 0x5f1f297a, 0x119622d3, 0xc20d3e28, 0x8c843581,\n    0xbe4a019f, 0xf0c30a36, 0x235816cd, 0x6dd11d64, 0x7572d1e7,\n    0x3bfbda4e, 0xe860c6b5, 0xa6e9cd1c, 0x9427f902, 0xdaaef2ab,\n    0x0935ee50, 0x47bce5f9, 0x6ca9866c, 0x22208dc5, 0xf1bb913e,\n    0xbf329a97, 0x8dfcae89, 0xc375a520, 0x10eeb9db, 0x5e67b272,\n    0x21a920dd, 0x6f202b74, 0xbcbb378f, 0xf2323c26, 0xc0fc0838,\n    0x8e750391, 0x5dee1f6a, 0x136714c3, 0x38727756, 0x76fb7cff,\n    0xa5606004, 0xebe96bad, 0xd9275fb3, 0x97ae541a, 0x443548e1,\n    0x0abc4348, 0x121f8fcb, 0x5c968462, 0x8f0d9899, 0xc1849330,\n    0xf34aa72e, 0xbdc3ac87, 0x6e58b07c, 0x20d1bbd5, 0x0bc4d840,\n    0x454dd3e9, 0x96d6cf12, 0xd85fc4bb, 0xea91f0a5, 0xa418fb0c,\n    0x7783e7f7, 0x390aec5e, 0x881ec2a9, 0xc697c900, 0x150cd5fb,\n    0x5b85de52, 0x694bea4c, 0x27c2e1e5, 0xf459fd1e, 0xbad0f6b7,\n    0x91c59522, 0xdf4c9e8b, 0x0cd78270, 0x425e89d9, 0x7090bdc7,\n    0x3e19b66e, 0xed82aa95, 0xa30ba13c, 0xbba86dbf, 0xf5216616,\n    0x26ba7aed, 0x68337144, 0x5afd455a, 0x14744ef3, 0xc7ef5208,\n    0x896659a1, 0xa2733a34, 0xecfa319d, 0x3f612d66, 0x71e826cf,\n    0x432612d1, 0x0daf1978, 0xde340583, 0x90bd0e2a, 0xef739c85,\n    0xa1fa972c, 0x72618bd7, 0x3ce8807e, 0x0e26b460, 0x40afbfc9,\n    0x9334a332, 0xddbda89b, 0xf6a8cb0e, 0xb821c0a7, 0x6bbadc5c,\n    0x2533d7f5, 0x17fde3eb, 0x5974e842, 0x8aeff4b9, 0xc466ff10,\n    0xdcc53393, 0x924c383a, 0x41d724c1, 0x0f5e2f68, 0x3d901b76,\n    0x731910df, 0xa0820c24, 0xee0b078d, 0xc51e6418, 0x8b976fb1,\n    0x580c734a, 0x168578e3, 0x244b4cfd, 0x6ac24754, 0xb9595baf,\n    0xf7d05006},\n   {0x00000000, 0x8d88fde2, 0xc060fd85, 0x4de80067, 0x5bb0fd4b,\n    0xd63800a9, 0x9bd000ce, 0x1658fd2c, 0xb761fa96, 0x3ae90774,\n    0x77010713, 0xfa89faf1, 0xecd107dd, 0x6159fa3f, 0x2cb1fa58,\n    0xa13907ba, 0xb5b2f36d, 0x383a0e8f, 0x75d20ee8, 0xf85af30a,\n    0xee020e26, 0x638af3c4, 0x2e62f3a3, 0xa3ea0e41, 0x02d309fb,\n    0x8f5bf419, 0xc2b3f47e, 0x4f3b099c, 0x5963f4b0, 0xd4eb0952,\n    0x99030935, 0x148bf4d7, 0xb014e09b, 0x3d9c1d79, 0x70741d1e,\n    0xfdfce0fc, 0xeba41dd0, 0x662ce032, 0x2bc4e055, 0xa64c1db7,\n    0x07751a0d, 0x8afde7ef, 0xc715e788, 0x4a9d1a6a, 0x5cc5e746,\n    0xd14d1aa4, 0x9ca51ac3, 0x112de721, 0x05a613f6, 0x882eee14,\n    0xc5c6ee73, 0x484e1391, 0x5e16eebd, 0xd39e135f, 0x9e761338,\n    0x13feeeda, 0xb2c7e960, 0x3f4f1482, 0x72a714e5, 0xff2fe907,\n    0xe977142b, 0x64ffe9c9, 0x2917e9ae, 0xa49f144c, 0xbb58c777,\n    0x36d03a95, 0x7b383af2, 0xf6b0c710, 0xe0e83a3c, 0x6d60c7de,\n    0x2088c7b9, 0xad003a5b, 0x0c393de1, 0x81b1c003, 0xcc59c064,\n    0x41d13d86, 0x5789c0aa, 0xda013d48, 0x97e93d2f, 0x1a61c0cd,\n    0x0eea341a, 0x8362c9f8, 0xce8ac99f, 0x4302347d, 0x555ac951,\n    0xd8d234b3, 0x953a34d4, 0x18b2c936, 0xb98bce8c, 0x3403336e,\n    0x79eb3309, 0xf463ceeb, 0xe23b33c7, 0x6fb3ce25, 0x225bce42,\n    0xafd333a0, 0x0b4c27ec, 0x86c4da0e, 0xcb2cda69, 0x46a4278b,\n    0x50fcdaa7, 0xdd742745, 0x909c2722, 0x1d14dac0, 0xbc2ddd7a,\n    0x31a52098, 0x7c4d20ff, 0xf1c5dd1d, 0xe79d2031, 0x6a15ddd3,\n    0x27fdddb4, 0xaa752056, 0xbefed481, 0x33762963, 0x7e9e2904,\n    0xf316d4e6, 0xe54e29ca, 0x68c6d428, 0x252ed44f, 0xa8a629ad,\n    0x099f2e17, 0x8417d3f5, 0xc9ffd392, 0x44772e70, 0x522fd35c,\n    0xdfa72ebe, 0x924f2ed9, 0x1fc7d33b, 0xadc088af, 0x2048754d,\n    0x6da0752a, 0xe02888c8, 0xf67075e4, 0x7bf88806, 0x36108861,\n    0xbb987583, 0x1aa17239, 0x97298fdb, 0xdac18fbc, 0x5749725e,\n    0x41118f72, 0xcc997290, 0x817172f7, 0x0cf98f15, 0x18727bc2,\n    0x95fa8620, 0xd8128647, 0x559a7ba5, 0x43c28689, 0xce4a7b6b,\n    0x83a27b0c, 0x0e2a86ee, 0xaf138154, 0x229b7cb6, 0x6f737cd1,\n    0xe2fb8133, 0xf4a37c1f, 0x792b81fd, 0x34c3819a, 0xb94b7c78,\n    0x1dd46834, 0x905c95d6, 0xddb495b1, 0x503c6853, 0x4664957f,\n    0xcbec689d, 0x860468fa, 0x0b8c9518, 0xaab592a2, 0x273d6f40,\n    0x6ad56f27, 0xe75d92c5, 0xf1056fe9, 0x7c8d920b, 0x3165926c,\n    0xbced6f8e, 0xa8669b59, 0x25ee66bb, 0x680666dc, 0xe58e9b3e,\n    0xf3d66612, 0x7e5e9bf0, 0x33b69b97, 0xbe3e6675, 0x1f0761cf,\n    0x928f9c2d, 0xdf679c4a, 0x52ef61a8, 0x44b79c84, 0xc93f6166,\n    0x84d76101, 0x095f9ce3, 0x16984fd8, 0x9b10b23a, 0xd6f8b25d,\n    0x5b704fbf, 0x4d28b293, 0xc0a04f71, 0x8d484f16, 0x00c0b2f4,\n    0xa1f9b54e, 0x2c7148ac, 0x619948cb, 0xec11b529, 0xfa494805,\n    0x77c1b5e7, 0x3a29b580, 0xb7a14862, 0xa32abcb5, 0x2ea24157,\n    0x634a4130, 0xeec2bcd2, 0xf89a41fe, 0x7512bc1c, 0x38fabc7b,\n    0xb5724199, 0x144b4623, 0x99c3bbc1, 0xd42bbba6, 0x59a34644,\n    0x4ffbbb68, 0xc273468a, 0x8f9b46ed, 0x0213bb0f, 0xa68caf43,\n    0x2b0452a1, 0x66ec52c6, 0xeb64af24, 0xfd3c5208, 0x70b4afea,\n    0x3d5caf8d, 0xb0d4526f, 0x11ed55d5, 0x9c65a837, 0xd18da850,\n    0x5c0555b2, 0x4a5da89e, 0xc7d5557c, 0x8a3d551b, 0x07b5a8f9,\n    0x133e5c2e, 0x9eb6a1cc, 0xd35ea1ab, 0x5ed65c49, 0x488ea165,\n    0xc5065c87, 0x88ee5ce0, 0x0566a102, 0xa45fa6b8, 0x29d75b5a,\n    0x643f5b3d, 0xe9b7a6df, 0xffef5bf3, 0x7267a611, 0x3f8fa676,\n    0xb2075b94},\n   {0x00000000, 0x80f0171f, 0xda91287f, 0x5a613f60, 0x6e5356bf,\n    0xeea341a0, 0xb4c27ec0, 0x343269df, 0xdca6ad7e, 0x5c56ba61,\n    0x06378501, 0x86c7921e, 0xb2f5fbc1, 0x3205ecde, 0x6864d3be,\n    0xe894c4a1, 0x623c5cbd, 0xe2cc4ba2, 0xb8ad74c2, 0x385d63dd,\n    0x0c6f0a02, 0x8c9f1d1d, 0xd6fe227d, 0x560e3562, 0xbe9af1c3,\n    0x3e6ae6dc, 0x640bd9bc, 0xe4fbcea3, 0xd0c9a77c, 0x5039b063,\n    0x0a588f03, 0x8aa8981c, 0xc478b97a, 0x4488ae65, 0x1ee99105,\n    0x9e19861a, 0xaa2befc5, 0x2adbf8da, 0x70bac7ba, 0xf04ad0a5,\n    0x18de1404, 0x982e031b, 0xc24f3c7b, 0x42bf2b64, 0x768d42bb,\n    0xf67d55a4, 0xac1c6ac4, 0x2cec7ddb, 0xa644e5c7, 0x26b4f2d8,\n    0x7cd5cdb8, 0xfc25daa7, 0xc817b378, 0x48e7a467, 0x12869b07,\n    0x92768c18, 0x7ae248b9, 0xfa125fa6, 0xa07360c6, 0x208377d9,\n    0x14b11e06, 0x94410919, 0xce203679, 0x4ed02166, 0x538074b5,\n    0xd37063aa, 0x89115cca, 0x09e14bd5, 0x3dd3220a, 0xbd233515,\n    0xe7420a75, 0x67b21d6a, 0x8f26d9cb, 0x0fd6ced4, 0x55b7f1b4,\n    0xd547e6ab, 0xe1758f74, 0x6185986b, 0x3be4a70b, 0xbb14b014,\n    0x31bc2808, 0xb14c3f17, 0xeb2d0077, 0x6bdd1768, 0x5fef7eb7,\n    0xdf1f69a8, 0x857e56c8, 0x058e41d7, 0xed1a8576, 0x6dea9269,\n    0x378bad09, 0xb77bba16, 0x8349d3c9, 0x03b9c4d6, 0x59d8fbb6,\n    0xd928eca9, 0x97f8cdcf, 0x1708dad0, 0x4d69e5b0, 0xcd99f2af,\n    0xf9ab9b70, 0x795b8c6f, 0x233ab30f, 0xa3caa410, 0x4b5e60b1,\n    0xcbae77ae, 0x91cf48ce, 0x113f5fd1, 0x250d360e, 0xa5fd2111,\n    0xff9c1e71, 0x7f6c096e, 0xf5c49172, 0x7534866d, 0x2f55b90d,\n    0xafa5ae12, 0x9b97c7cd, 0x1b67d0d2, 0x4106efb2, 0xc1f6f8ad,\n    0x29623c0c, 0xa9922b13, 0xf3f31473, 0x7303036c, 0x47316ab3,\n    0xc7c17dac, 0x9da042cc, 0x1d5055d3, 0xa700e96a, 0x27f0fe75,\n    0x7d91c115, 0xfd61d60a, 0xc953bfd5, 0x49a3a8ca, 0x13c297aa,\n    0x933280b5, 0x7ba64414, 0xfb56530b, 0xa1376c6b, 0x21c77b74,\n    0x15f512ab, 0x950505b4, 0xcf643ad4, 0x4f942dcb, 0xc53cb5d7,\n    0x45cca2c8, 0x1fad9da8, 0x9f5d8ab7, 0xab6fe368, 0x2b9ff477,\n    0x71fecb17, 0xf10edc08, 0x199a18a9, 0x996a0fb6, 0xc30b30d6,\n    0x43fb27c9, 0x77c94e16, 0xf7395909, 0xad586669, 0x2da87176,\n    0x63785010, 0xe388470f, 0xb9e9786f, 0x39196f70, 0x0d2b06af,\n    0x8ddb11b0, 0xd7ba2ed0, 0x574a39cf, 0xbfdefd6e, 0x3f2eea71,\n    0x654fd511, 0xe5bfc20e, 0xd18dabd1, 0x517dbcce, 0x0b1c83ae,\n    0x8bec94b1, 0x01440cad, 0x81b41bb2, 0xdbd524d2, 0x5b2533cd,\n    0x6f175a12, 0xefe74d0d, 0xb586726d, 0x35766572, 0xdde2a1d3,\n    0x5d12b6cc, 0x077389ac, 0x87839eb3, 0xb3b1f76c, 0x3341e073,\n    0x6920df13, 0xe9d0c80c, 0xf4809ddf, 0x74708ac0, 0x2e11b5a0,\n    0xaee1a2bf, 0x9ad3cb60, 0x1a23dc7f, 0x4042e31f, 0xc0b2f400,\n    0x282630a1, 0xa8d627be, 0xf2b718de, 0x72470fc1, 0x4675661e,\n    0xc6857101, 0x9ce44e61, 0x1c14597e, 0x96bcc162, 0x164cd67d,\n    0x4c2de91d, 0xccddfe02, 0xf8ef97dd, 0x781f80c2, 0x227ebfa2,\n    0xa28ea8bd, 0x4a1a6c1c, 0xcaea7b03, 0x908b4463, 0x107b537c,\n    0x24493aa3, 0xa4b92dbc, 0xfed812dc, 0x7e2805c3, 0x30f824a5,\n    0xb00833ba, 0xea690cda, 0x6a991bc5, 0x5eab721a, 0xde5b6505,\n    0x843a5a65, 0x04ca4d7a, 0xec5e89db, 0x6cae9ec4, 0x36cfa1a4,\n    0xb63fb6bb, 0x820ddf64, 0x02fdc87b, 0x589cf71b, 0xd86ce004,\n    0x52c47818, 0xd2346f07, 0x88555067, 0x08a54778, 0x3c972ea7,\n    0xbc6739b8, 0xe60606d8, 0x66f611c7, 0x8e62d566, 0x0e92c279,\n    0x54f3fd19, 0xd403ea06, 0xe03183d9, 0x60c194c6, 0x3aa0aba6,\n    0xba50bcb9},\n   {0x00000000, 0x9570d495, 0xf190af6b, 0x64e07bfe, 0x38505897,\n    0xad208c02, 0xc9c0f7fc, 0x5cb02369, 0x70a0b12e, 0xe5d065bb,\n    0x81301e45, 0x1440cad0, 0x48f0e9b9, 0xdd803d2c, 0xb96046d2,\n    0x2c109247, 0xe141625c, 0x7431b6c9, 0x10d1cd37, 0x85a119a2,\n    0xd9113acb, 0x4c61ee5e, 0x288195a0, 0xbdf14135, 0x91e1d372,\n    0x049107e7, 0x60717c19, 0xf501a88c, 0xa9b18be5, 0x3cc15f70,\n    0x5821248e, 0xcd51f01b, 0x19f3c2f9, 0x8c83166c, 0xe8636d92,\n    0x7d13b907, 0x21a39a6e, 0xb4d34efb, 0xd0333505, 0x4543e190,\n    0x695373d7, 0xfc23a742, 0x98c3dcbc, 0x0db30829, 0x51032b40,\n    0xc473ffd5, 0xa093842b, 0x35e350be, 0xf8b2a0a5, 0x6dc27430,\n    0x09220fce, 0x9c52db5b, 0xc0e2f832, 0x55922ca7, 0x31725759,\n    0xa40283cc, 0x8812118b, 0x1d62c51e, 0x7982bee0, 0xecf26a75,\n    0xb042491c, 0x25329d89, 0x41d2e677, 0xd4a232e2, 0x33e785f2,\n    0xa6975167, 0xc2772a99, 0x5707fe0c, 0x0bb7dd65, 0x9ec709f0,\n    0xfa27720e, 0x6f57a69b, 0x434734dc, 0xd637e049, 0xb2d79bb7,\n    0x27a74f22, 0x7b176c4b, 0xee67b8de, 0x8a87c320, 0x1ff717b5,\n    0xd2a6e7ae, 0x47d6333b, 0x233648c5, 0xb6469c50, 0xeaf6bf39,\n    0x7f866bac, 0x1b661052, 0x8e16c4c7, 0xa2065680, 0x37768215,\n    0x5396f9eb, 0xc6e62d7e, 0x9a560e17, 0x0f26da82, 0x6bc6a17c,\n    0xfeb675e9, 0x2a14470b, 0xbf64939e, 0xdb84e860, 0x4ef43cf5,\n    0x12441f9c, 0x8734cb09, 0xe3d4b0f7, 0x76a46462, 0x5ab4f625,\n    0xcfc422b0, 0xab24594e, 0x3e548ddb, 0x62e4aeb2, 0xf7947a27,\n    0x937401d9, 0x0604d54c, 0xcb552557, 0x5e25f1c2, 0x3ac58a3c,\n    0xafb55ea9, 0xf3057dc0, 0x6675a955, 0x0295d2ab, 0x97e5063e,\n    0xbbf59479, 0x2e8540ec, 0x4a653b12, 0xdf15ef87, 0x83a5ccee,\n    0x16d5187b, 0x72356385, 0xe745b710, 0x67cf0be4, 0xf2bfdf71,\n    0x965fa48f, 0x032f701a, 0x5f9f5373, 0xcaef87e6, 0xae0ffc18,\n    0x3b7f288d, 0x176fbaca, 0x821f6e5f, 0xe6ff15a1, 0x738fc134,\n    0x2f3fe25d, 0xba4f36c8, 0xdeaf4d36, 0x4bdf99a3, 0x868e69b8,\n    0x13febd2d, 0x771ec6d3, 0xe26e1246, 0xbede312f, 0x2baee5ba,\n    0x4f4e9e44, 0xda3e4ad1, 0xf62ed896, 0x635e0c03, 0x07be77fd,\n    0x92cea368, 0xce7e8001, 0x5b0e5494, 0x3fee2f6a, 0xaa9efbff,\n    0x7e3cc91d, 0xeb4c1d88, 0x8fac6676, 0x1adcb2e3, 0x466c918a,\n    0xd31c451f, 0xb7fc3ee1, 0x228cea74, 0x0e9c7833, 0x9becaca6,\n    0xff0cd758, 0x6a7c03cd, 0x36cc20a4, 0xa3bcf431, 0xc75c8fcf,\n    0x522c5b5a, 0x9f7dab41, 0x0a0d7fd4, 0x6eed042a, 0xfb9dd0bf,\n    0xa72df3d6, 0x325d2743, 0x56bd5cbd, 0xc3cd8828, 0xefdd1a6f,\n    0x7aadcefa, 0x1e4db504, 0x8b3d6191, 0xd78d42f8, 0x42fd966d,\n    0x261ded93, 0xb36d3906, 0x54288e16, 0xc1585a83, 0xa5b8217d,\n    0x30c8f5e8, 0x6c78d681, 0xf9080214, 0x9de879ea, 0x0898ad7f,\n    0x24883f38, 0xb1f8ebad, 0xd5189053, 0x406844c6, 0x1cd867af,\n    0x89a8b33a, 0xed48c8c4, 0x78381c51, 0xb569ec4a, 0x201938df,\n    0x44f94321, 0xd18997b4, 0x8d39b4dd, 0x18496048, 0x7ca91bb6,\n    0xe9d9cf23, 0xc5c95d64, 0x50b989f1, 0x3459f20f, 0xa129269a,\n    0xfd9905f3, 0x68e9d166, 0x0c09aa98, 0x99797e0d, 0x4ddb4cef,\n    0xd8ab987a, 0xbc4be384, 0x293b3711, 0x758b1478, 0xe0fbc0ed,\n    0x841bbb13, 0x116b6f86, 0x3d7bfdc1, 0xa80b2954, 0xcceb52aa,\n    0x599b863f, 0x052ba556, 0x905b71c3, 0xf4bb0a3d, 0x61cbdea8,\n    0xac9a2eb3, 0x39eafa26, 0x5d0a81d8, 0xc87a554d, 0x94ca7624,\n    0x01baa2b1, 0x655ad94f, 0xf02a0dda, 0xdc3a9f9d, 0x494a4b08,\n    0x2daa30f6, 0xb8dae463, 0xe46ac70a, 0x711a139f, 0x15fa6861,\n    0x808abcf4},\n   {0x00000000, 0xcf9e17c8, 0x444d29d1, 0x8bd33e19, 0x889a53a2,\n    0x4704446a, 0xccd77a73, 0x03496dbb, 0xca45a105, 0x05dbb6cd,\n    0x8e0888d4, 0x41969f1c, 0x42dff2a7, 0x8d41e56f, 0x0692db76,\n    0xc90cccbe, 0x4ffa444b, 0x80645383, 0x0bb76d9a, 0xc4297a52,\n    0xc76017e9, 0x08fe0021, 0x832d3e38, 0x4cb329f0, 0x85bfe54e,\n    0x4a21f286, 0xc1f2cc9f, 0x0e6cdb57, 0x0d25b6ec, 0xc2bba124,\n    0x49689f3d, 0x86f688f5, 0x9ff48896, 0x506a9f5e, 0xdbb9a147,\n    0x1427b68f, 0x176edb34, 0xd8f0ccfc, 0x5323f2e5, 0x9cbde52d,\n    0x55b12993, 0x9a2f3e5b, 0x11fc0042, 0xde62178a, 0xdd2b7a31,\n    0x12b56df9, 0x996653e0, 0x56f84428, 0xd00eccdd, 0x1f90db15,\n    0x9443e50c, 0x5bddf2c4, 0x58949f7f, 0x970a88b7, 0x1cd9b6ae,\n    0xd347a166, 0x1a4b6dd8, 0xd5d57a10, 0x5e064409, 0x919853c1,\n    0x92d13e7a, 0x5d4f29b2, 0xd69c17ab, 0x19020063, 0xe498176d,\n    0x2b0600a5, 0xa0d53ebc, 0x6f4b2974, 0x6c0244cf, 0xa39c5307,\n    0x284f6d1e, 0xe7d17ad6, 0x2eddb668, 0xe143a1a0, 0x6a909fb9,\n    0xa50e8871, 0xa647e5ca, 0x69d9f202, 0xe20acc1b, 0x2d94dbd3,\n    0xab625326, 0x64fc44ee, 0xef2f7af7, 0x20b16d3f, 0x23f80084,\n    0xec66174c, 0x67b52955, 0xa82b3e9d, 0x6127f223, 0xaeb9e5eb,\n    0x256adbf2, 0xeaf4cc3a, 0xe9bda181, 0x2623b649, 0xadf08850,\n    0x626e9f98, 0x7b6c9ffb, 0xb4f28833, 0x3f21b62a, 0xf0bfa1e2,\n    0xf3f6cc59, 0x3c68db91, 0xb7bbe588, 0x7825f240, 0xb1293efe,\n    0x7eb72936, 0xf564172f, 0x3afa00e7, 0x39b36d5c, 0xf62d7a94,\n    0x7dfe448d, 0xb2605345, 0x3496dbb0, 0xfb08cc78, 0x70dbf261,\n    0xbf45e5a9, 0xbc0c8812, 0x73929fda, 0xf841a1c3, 0x37dfb60b,\n    0xfed37ab5, 0x314d6d7d, 0xba9e5364, 0x750044ac, 0x76492917,\n    0xb9d73edf, 0x320400c6, 0xfd9a170e, 0x1241289b, 0xdddf3f53,\n    0x560c014a, 0x99921682, 0x9adb7b39, 0x55456cf1, 0xde9652e8,\n    0x11084520, 0xd804899e, 0x179a9e56, 0x9c49a04f, 0x53d7b787,\n    0x509eda3c, 0x9f00cdf4, 0x14d3f3ed, 0xdb4de425, 0x5dbb6cd0,\n    0x92257b18, 0x19f64501, 0xd66852c9, 0xd5213f72, 0x1abf28ba,\n    0x916c16a3, 0x5ef2016b, 0x97fecdd5, 0x5860da1d, 0xd3b3e404,\n    0x1c2df3cc, 0x1f649e77, 0xd0fa89bf, 0x5b29b7a6, 0x94b7a06e,\n    0x8db5a00d, 0x422bb7c5, 0xc9f889dc, 0x06669e14, 0x052ff3af,\n    0xcab1e467, 0x4162da7e, 0x8efccdb6, 0x47f00108, 0x886e16c0,\n    0x03bd28d9, 0xcc233f11, 0xcf6a52aa, 0x00f44562, 0x8b277b7b,\n    0x44b96cb3, 0xc24fe446, 0x0dd1f38e, 0x8602cd97, 0x499cda5f,\n    0x4ad5b7e4, 0x854ba02c, 0x0e989e35, 0xc10689fd, 0x080a4543,\n    0xc794528b, 0x4c476c92, 0x83d97b5a, 0x809016e1, 0x4f0e0129,\n    0xc4dd3f30, 0x0b4328f8, 0xf6d93ff6, 0x3947283e, 0xb2941627,\n    0x7d0a01ef, 0x7e436c54, 0xb1dd7b9c, 0x3a0e4585, 0xf590524d,\n    0x3c9c9ef3, 0xf302893b, 0x78d1b722, 0xb74fa0ea, 0xb406cd51,\n    0x7b98da99, 0xf04be480, 0x3fd5f348, 0xb9237bbd, 0x76bd6c75,\n    0xfd6e526c, 0x32f045a4, 0x31b9281f, 0xfe273fd7, 0x75f401ce,\n    0xba6a1606, 0x7366dab8, 0xbcf8cd70, 0x372bf369, 0xf8b5e4a1,\n    0xfbfc891a, 0x34629ed2, 0xbfb1a0cb, 0x702fb703, 0x692db760,\n    0xa6b3a0a8, 0x2d609eb1, 0xe2fe8979, 0xe1b7e4c2, 0x2e29f30a,\n    0xa5facd13, 0x6a64dadb, 0xa3681665, 0x6cf601ad, 0xe7253fb4,\n    0x28bb287c, 0x2bf245c7, 0xe46c520f, 0x6fbf6c16, 0xa0217bde,\n    0x26d7f32b, 0xe949e4e3, 0x629adafa, 0xad04cd32, 0xae4da089,\n    0x61d3b741, 0xea008958, 0x259e9e90, 0xec92522e, 0x230c45e6,\n    0xa8df7bff, 0x67416c37, 0x6408018c, 0xab961644, 0x2045285d,\n    0xefdb3f95},\n   {0x00000000, 0x24825136, 0x4904a26c, 0x6d86f35a, 0x920944d8,\n    0xb68b15ee, 0xdb0de6b4, 0xff8fb782, 0xff638ff1, 0xdbe1dec7,\n    0xb6672d9d, 0x92e57cab, 0x6d6acb29, 0x49e89a1f, 0x246e6945,\n    0x00ec3873, 0x25b619a3, 0x01344895, 0x6cb2bbcf, 0x4830eaf9,\n    0xb7bf5d7b, 0x933d0c4d, 0xfebbff17, 0xda39ae21, 0xdad59652,\n    0xfe57c764, 0x93d1343e, 0xb7536508, 0x48dcd28a, 0x6c5e83bc,\n    0x01d870e6, 0x255a21d0, 0x4b6c3346, 0x6fee6270, 0x0268912a,\n    0x26eac01c, 0xd965779e, 0xfde726a8, 0x9061d5f2, 0xb4e384c4,\n    0xb40fbcb7, 0x908ded81, 0xfd0b1edb, 0xd9894fed, 0x2606f86f,\n    0x0284a959, 0x6f025a03, 0x4b800b35, 0x6eda2ae5, 0x4a587bd3,\n    0x27de8889, 0x035cd9bf, 0xfcd36e3d, 0xd8513f0b, 0xb5d7cc51,\n    0x91559d67, 0x91b9a514, 0xb53bf422, 0xd8bd0778, 0xfc3f564e,\n    0x03b0e1cc, 0x2732b0fa, 0x4ab443a0, 0x6e361296, 0x96d8668c,\n    0xb25a37ba, 0xdfdcc4e0, 0xfb5e95d6, 0x04d12254, 0x20537362,\n    0x4dd58038, 0x6957d10e, 0x69bbe97d, 0x4d39b84b, 0x20bf4b11,\n    0x043d1a27, 0xfbb2ada5, 0xdf30fc93, 0xb2b60fc9, 0x96345eff,\n    0xb36e7f2f, 0x97ec2e19, 0xfa6add43, 0xdee88c75, 0x21673bf7,\n    0x05e56ac1, 0x6863999b, 0x4ce1c8ad, 0x4c0df0de, 0x688fa1e8,\n    0x050952b2, 0x218b0384, 0xde04b406, 0xfa86e530, 0x9700166a,\n    0xb382475c, 0xddb455ca, 0xf93604fc, 0x94b0f7a6, 0xb032a690,\n    0x4fbd1112, 0x6b3f4024, 0x06b9b37e, 0x223be248, 0x22d7da3b,\n    0x06558b0d, 0x6bd37857, 0x4f512961, 0xb0de9ee3, 0x945ccfd5,\n    0xf9da3c8f, 0xdd586db9, 0xf8024c69, 0xdc801d5f, 0xb106ee05,\n    0x9584bf33, 0x6a0b08b1, 0x4e895987, 0x230faadd, 0x078dfbeb,\n    0x0761c398, 0x23e392ae, 0x4e6561f4, 0x6ae730c2, 0x95688740,\n    0xb1ead676, 0xdc6c252c, 0xf8ee741a, 0xf6c1cb59, 0xd2439a6f,\n    0xbfc56935, 0x9b473803, 0x64c88f81, 0x404adeb7, 0x2dcc2ded,\n    0x094e7cdb, 0x09a244a8, 0x2d20159e, 0x40a6e6c4, 0x6424b7f2,\n    0x9bab0070, 0xbf295146, 0xd2afa21c, 0xf62df32a, 0xd377d2fa,\n    0xf7f583cc, 0x9a737096, 0xbef121a0, 0x417e9622, 0x65fcc714,\n    0x087a344e, 0x2cf86578, 0x2c145d0b, 0x08960c3d, 0x6510ff67,\n    0x4192ae51, 0xbe1d19d3, 0x9a9f48e5, 0xf719bbbf, 0xd39bea89,\n    0xbdadf81f, 0x992fa929, 0xf4a95a73, 0xd02b0b45, 0x2fa4bcc7,\n    0x0b26edf1, 0x66a01eab, 0x42224f9d, 0x42ce77ee, 0x664c26d8,\n    0x0bcad582, 0x2f4884b4, 0xd0c73336, 0xf4456200, 0x99c3915a,\n    0xbd41c06c, 0x981be1bc, 0xbc99b08a, 0xd11f43d0, 0xf59d12e6,\n    0x0a12a564, 0x2e90f452, 0x43160708, 0x6794563e, 0x67786e4d,\n    0x43fa3f7b, 0x2e7ccc21, 0x0afe9d17, 0xf5712a95, 0xd1f37ba3,\n    0xbc7588f9, 0x98f7d9cf, 0x6019add5, 0x449bfce3, 0x291d0fb9,\n    0x0d9f5e8f, 0xf210e90d, 0xd692b83b, 0xbb144b61, 0x9f961a57,\n    0x9f7a2224, 0xbbf87312, 0xd67e8048, 0xf2fcd17e, 0x0d7366fc,\n    0x29f137ca, 0x4477c490, 0x60f595a6, 0x45afb476, 0x612de540,\n    0x0cab161a, 0x2829472c, 0xd7a6f0ae, 0xf324a198, 0x9ea252c2,\n    0xba2003f4, 0xbacc3b87, 0x9e4e6ab1, 0xf3c899eb, 0xd74ac8dd,\n    0x28c57f5f, 0x0c472e69, 0x61c1dd33, 0x45438c05, 0x2b759e93,\n    0x0ff7cfa5, 0x62713cff, 0x46f36dc9, 0xb97cda4b, 0x9dfe8b7d,\n    0xf0787827, 0xd4fa2911, 0xd4161162, 0xf0944054, 0x9d12b30e,\n    0xb990e238, 0x461f55ba, 0x629d048c, 0x0f1bf7d6, 0x2b99a6e0,\n    0x0ec38730, 0x2a41d606, 0x47c7255c, 0x6345746a, 0x9ccac3e8,\n    0xb84892de, 0xd5ce6184, 0xf14c30b2, 0xf1a008c1, 0xd52259f7,\n    0xb8a4aaad, 0x9c26fb9b, 0x63a94c19, 0x472b1d2f, 0x2aadee75,\n    0x0e2fbf43},\n   {0x00000000, 0x36f290f3, 0x6de521e6, 0x5b17b115, 0xdbca43cc,\n    0xed38d33f, 0xb62f622a, 0x80ddf2d9, 0x6ce581d9, 0x5a17112a,\n    0x0100a03f, 0x37f230cc, 0xb72fc215, 0x81dd52e6, 0xdacae3f3,\n    0xec387300, 0xd9cb03b2, 0xef399341, 0xb42e2254, 0x82dcb2a7,\n    0x0201407e, 0x34f3d08d, 0x6fe46198, 0x5916f16b, 0xb52e826b,\n    0x83dc1298, 0xd8cba38d, 0xee39337e, 0x6ee4c1a7, 0x58165154,\n    0x0301e041, 0x35f370b2, 0x68e70125, 0x5e1591d6, 0x050220c3,\n    0x33f0b030, 0xb32d42e9, 0x85dfd21a, 0xdec8630f, 0xe83af3fc,\n    0x040280fc, 0x32f0100f, 0x69e7a11a, 0x5f1531e9, 0xdfc8c330,\n    0xe93a53c3, 0xb22de2d6, 0x84df7225, 0xb12c0297, 0x87de9264,\n    0xdcc92371, 0xea3bb382, 0x6ae6415b, 0x5c14d1a8, 0x070360bd,\n    0x31f1f04e, 0xddc9834e, 0xeb3b13bd, 0xb02ca2a8, 0x86de325b,\n    0x0603c082, 0x30f15071, 0x6be6e164, 0x5d147197, 0xd1ce024a,\n    0xe73c92b9, 0xbc2b23ac, 0x8ad9b35f, 0x0a044186, 0x3cf6d175,\n    0x67e16060, 0x5113f093, 0xbd2b8393, 0x8bd91360, 0xd0cea275,\n    0xe63c3286, 0x66e1c05f, 0x501350ac, 0x0b04e1b9, 0x3df6714a,\n    0x080501f8, 0x3ef7910b, 0x65e0201e, 0x5312b0ed, 0xd3cf4234,\n    0xe53dd2c7, 0xbe2a63d2, 0x88d8f321, 0x64e08021, 0x521210d2,\n    0x0905a1c7, 0x3ff73134, 0xbf2ac3ed, 0x89d8531e, 0xd2cfe20b,\n    0xe43d72f8, 0xb929036f, 0x8fdb939c, 0xd4cc2289, 0xe23eb27a,\n    0x62e340a3, 0x5411d050, 0x0f066145, 0x39f4f1b6, 0xd5cc82b6,\n    0xe33e1245, 0xb829a350, 0x8edb33a3, 0x0e06c17a, 0x38f45189,\n    0x63e3e09c, 0x5511706f, 0x60e200dd, 0x5610902e, 0x0d07213b,\n    0x3bf5b1c8, 0xbb284311, 0x8ddad3e2, 0xd6cd62f7, 0xe03ff204,\n    0x0c078104, 0x3af511f7, 0x61e2a0e2, 0x57103011, 0xd7cdc2c8,\n    0xe13f523b, 0xba28e32e, 0x8cda73dd, 0x78ed02d5, 0x4e1f9226,\n    0x15082333, 0x23fab3c0, 0xa3274119, 0x95d5d1ea, 0xcec260ff,\n    0xf830f00c, 0x1408830c, 0x22fa13ff, 0x79eda2ea, 0x4f1f3219,\n    0xcfc2c0c0, 0xf9305033, 0xa227e126, 0x94d571d5, 0xa1260167,\n    0x97d49194, 0xccc32081, 0xfa31b072, 0x7aec42ab, 0x4c1ed258,\n    0x1709634d, 0x21fbf3be, 0xcdc380be, 0xfb31104d, 0xa026a158,\n    0x96d431ab, 0x1609c372, 0x20fb5381, 0x7bece294, 0x4d1e7267,\n    0x100a03f0, 0x26f89303, 0x7def2216, 0x4b1db2e5, 0xcbc0403c,\n    0xfd32d0cf, 0xa62561da, 0x90d7f129, 0x7cef8229, 0x4a1d12da,\n    0x110aa3cf, 0x27f8333c, 0xa725c1e5, 0x91d75116, 0xcac0e003,\n    0xfc3270f0, 0xc9c10042, 0xff3390b1, 0xa42421a4, 0x92d6b157,\n    0x120b438e, 0x24f9d37d, 0x7fee6268, 0x491cf29b, 0xa524819b,\n    0x93d61168, 0xc8c1a07d, 0xfe33308e, 0x7eeec257, 0x481c52a4,\n    0x130be3b1, 0x25f97342, 0xa923009f, 0x9fd1906c, 0xc4c62179,\n    0xf234b18a, 0x72e94353, 0x441bd3a0, 0x1f0c62b5, 0x29fef246,\n    0xc5c68146, 0xf33411b5, 0xa823a0a0, 0x9ed13053, 0x1e0cc28a,\n    0x28fe5279, 0x73e9e36c, 0x451b739f, 0x70e8032d, 0x461a93de,\n    0x1d0d22cb, 0x2bffb238, 0xab2240e1, 0x9dd0d012, 0xc6c76107,\n    0xf035f1f4, 0x1c0d82f4, 0x2aff1207, 0x71e8a312, 0x471a33e1,\n    0xc7c7c138, 0xf13551cb, 0xaa22e0de, 0x9cd0702d, 0xc1c401ba,\n    0xf7369149, 0xac21205c, 0x9ad3b0af, 0x1a0e4276, 0x2cfcd285,\n    0x77eb6390, 0x4119f363, 0xad218063, 0x9bd31090, 0xc0c4a185,\n    0xf6363176, 0x76ebc3af, 0x4019535c, 0x1b0ee249, 0x2dfc72ba,\n    0x180f0208, 0x2efd92fb, 0x75ea23ee, 0x4318b31d, 0xc3c541c4,\n    0xf537d137, 0xae206022, 0x98d2f0d1, 0x74ea83d1, 0x42181322,\n    0x190fa237, 0x2ffd32c4, 0xaf20c01d, 0x99d250ee, 0xc2c5e1fb,\n    0xf4377108}};\n\nlocal const z_word_t FAR crc_braid_big_table[][256] = {\n   {0x0000000000000000, 0xf390f23600000000, 0xe621e56d00000000,\n    0x15b1175b00000000, 0xcc43cadb00000000, 0x3fd338ed00000000,\n    0x2a622fb600000000, 0xd9f2dd8000000000, 0xd981e56c00000000,\n    0x2a11175a00000000, 0x3fa0000100000000, 0xcc30f23700000000,\n    0x15c22fb700000000, 0xe652dd8100000000, 0xf3e3cada00000000,\n    0x007338ec00000000, 0xb203cbd900000000, 0x419339ef00000000,\n    0x54222eb400000000, 0xa7b2dc8200000000, 0x7e40010200000000,\n    0x8dd0f33400000000, 0x9861e46f00000000, 0x6bf1165900000000,\n    0x6b822eb500000000, 0x9812dc8300000000, 0x8da3cbd800000000,\n    0x7e3339ee00000000, 0xa7c1e46e00000000, 0x5451165800000000,\n    0x41e0010300000000, 0xb270f33500000000, 0x2501e76800000000,\n    0xd691155e00000000, 0xc320020500000000, 0x30b0f03300000000,\n    0xe9422db300000000, 0x1ad2df8500000000, 0x0f63c8de00000000,\n    0xfcf33ae800000000, 0xfc80020400000000, 0x0f10f03200000000,\n    0x1aa1e76900000000, 0xe931155f00000000, 0x30c3c8df00000000,\n    0xc3533ae900000000, 0xd6e22db200000000, 0x2572df8400000000,\n    0x97022cb100000000, 0x6492de8700000000, 0x7123c9dc00000000,\n    0x82b33bea00000000, 0x5b41e66a00000000, 0xa8d1145c00000000,\n    0xbd60030700000000, 0x4ef0f13100000000, 0x4e83c9dd00000000,\n    0xbd133beb00000000, 0xa8a22cb000000000, 0x5b32de8600000000,\n    0x82c0030600000000, 0x7150f13000000000, 0x64e1e66b00000000,\n    0x9771145d00000000, 0x4a02ced100000000, 0xb9923ce700000000,\n    0xac232bbc00000000, 0x5fb3d98a00000000, 0x8641040a00000000,\n    0x75d1f63c00000000, 0x6060e16700000000, 0x93f0135100000000,\n    0x93832bbd00000000, 0x6013d98b00000000, 0x75a2ced000000000,\n    0x86323ce600000000, 0x5fc0e16600000000, 0xac50135000000000,\n    0xb9e1040b00000000, 0x4a71f63d00000000, 0xf801050800000000,\n    0x0b91f73e00000000, 0x1e20e06500000000, 0xedb0125300000000,\n    0x3442cfd300000000, 0xc7d23de500000000, 0xd2632abe00000000,\n    0x21f3d88800000000, 0x2180e06400000000, 0xd210125200000000,\n    0xc7a1050900000000, 0x3431f73f00000000, 0xedc32abf00000000,\n    0x1e53d88900000000, 0x0be2cfd200000000, 0xf8723de400000000,\n    0x6f0329b900000000, 0x9c93db8f00000000, 0x8922ccd400000000,\n    0x7ab23ee200000000, 0xa340e36200000000, 0x50d0115400000000,\n    0x4561060f00000000, 0xb6f1f43900000000, 0xb682ccd500000000,\n    0x45123ee300000000, 0x50a329b800000000, 0xa333db8e00000000,\n    0x7ac1060e00000000, 0x8951f43800000000, 0x9ce0e36300000000,\n    0x6f70115500000000, 0xdd00e26000000000, 0x2e90105600000000,\n    0x3b21070d00000000, 0xc8b1f53b00000000, 0x114328bb00000000,\n    0xe2d3da8d00000000, 0xf762cdd600000000, 0x04f23fe000000000,\n    0x0481070c00000000, 0xf711f53a00000000, 0xe2a0e26100000000,\n    0x1130105700000000, 0xc8c2cdd700000000, 0x3b523fe100000000,\n    0x2ee328ba00000000, 0xdd73da8c00000000, 0xd502ed7800000000,\n    0x26921f4e00000000, 0x3323081500000000, 0xc0b3fa2300000000,\n    0x194127a300000000, 0xead1d59500000000, 0xff60c2ce00000000,\n    0x0cf030f800000000, 0x0c83081400000000, 0xff13fa2200000000,\n    0xeaa2ed7900000000, 0x19321f4f00000000, 0xc0c0c2cf00000000,\n    0x335030f900000000, 0x26e127a200000000, 0xd571d59400000000,\n    0x670126a100000000, 0x9491d49700000000, 0x8120c3cc00000000,\n    0x72b031fa00000000, 0xab42ec7a00000000, 0x58d21e4c00000000,\n    0x4d63091700000000, 0xbef3fb2100000000, 0xbe80c3cd00000000,\n    0x4d1031fb00000000, 0x58a126a000000000, 0xab31d49600000000,\n    0x72c3091600000000, 0x8153fb2000000000, 0x94e2ec7b00000000,\n    0x67721e4d00000000, 0xf0030a1000000000, 0x0393f82600000000,\n    0x1622ef7d00000000, 0xe5b21d4b00000000, 0x3c40c0cb00000000,\n    0xcfd032fd00000000, 0xda6125a600000000, 0x29f1d79000000000,\n    0x2982ef7c00000000, 0xda121d4a00000000, 0xcfa30a1100000000,\n    0x3c33f82700000000, 0xe5c125a700000000, 0x1651d79100000000,\n    0x03e0c0ca00000000, 0xf07032fc00000000, 0x4200c1c900000000,\n    0xb19033ff00000000, 0xa42124a400000000, 0x57b1d69200000000,\n    0x8e430b1200000000, 0x7dd3f92400000000, 0x6862ee7f00000000,\n    0x9bf21c4900000000, 0x9b8124a500000000, 0x6811d69300000000,\n    0x7da0c1c800000000, 0x8e3033fe00000000, 0x57c2ee7e00000000,\n    0xa4521c4800000000, 0xb1e30b1300000000, 0x4273f92500000000,\n    0x9f0023a900000000, 0x6c90d19f00000000, 0x7921c6c400000000,\n    0x8ab134f200000000, 0x5343e97200000000, 0xa0d31b4400000000,\n    0xb5620c1f00000000, 0x46f2fe2900000000, 0x4681c6c500000000,\n    0xb51134f300000000, 0xa0a023a800000000, 0x5330d19e00000000,\n    0x8ac20c1e00000000, 0x7952fe2800000000, 0x6ce3e97300000000,\n    0x9f731b4500000000, 0x2d03e87000000000, 0xde931a4600000000,\n    0xcb220d1d00000000, 0x38b2ff2b00000000, 0xe14022ab00000000,\n    0x12d0d09d00000000, 0x0761c7c600000000, 0xf4f135f000000000,\n    0xf4820d1c00000000, 0x0712ff2a00000000, 0x12a3e87100000000,\n    0xe1331a4700000000, 0x38c1c7c700000000, 0xcb5135f100000000,\n    0xdee022aa00000000, 0x2d70d09c00000000, 0xba01c4c100000000,\n    0x499136f700000000, 0x5c2021ac00000000, 0xafb0d39a00000000,\n    0x76420e1a00000000, 0x85d2fc2c00000000, 0x9063eb7700000000,\n    0x63f3194100000000, 0x638021ad00000000, 0x9010d39b00000000,\n    0x85a1c4c000000000, 0x763136f600000000, 0xafc3eb7600000000,\n    0x5c53194000000000, 0x49e20e1b00000000, 0xba72fc2d00000000,\n    0x08020f1800000000, 0xfb92fd2e00000000, 0xee23ea7500000000,\n    0x1db3184300000000, 0xc441c5c300000000, 0x37d137f500000000,\n    0x226020ae00000000, 0xd1f0d29800000000, 0xd183ea7400000000,\n    0x2213184200000000, 0x37a20f1900000000, 0xc432fd2f00000000,\n    0x1dc020af00000000, 0xee50d29900000000, 0xfbe1c5c200000000,\n    0x087137f400000000},\n   {0x0000000000000000, 0x3651822400000000, 0x6ca2044900000000,\n    0x5af3866d00000000, 0xd844099200000000, 0xee158bb600000000,\n    0xb4e60ddb00000000, 0x82b78fff00000000, 0xf18f63ff00000000,\n    0xc7dee1db00000000, 0x9d2d67b600000000, 0xab7ce59200000000,\n    0x29cb6a6d00000000, 0x1f9ae84900000000, 0x45696e2400000000,\n    0x7338ec0000000000, 0xa319b62500000000, 0x9548340100000000,\n    0xcfbbb26c00000000, 0xf9ea304800000000, 0x7b5dbfb700000000,\n    0x4d0c3d9300000000, 0x17ffbbfe00000000, 0x21ae39da00000000,\n    0x5296d5da00000000, 0x64c757fe00000000, 0x3e34d19300000000,\n    0x086553b700000000, 0x8ad2dc4800000000, 0xbc835e6c00000000,\n    0xe670d80100000000, 0xd0215a2500000000, 0x46336c4b00000000,\n    0x7062ee6f00000000, 0x2a91680200000000, 0x1cc0ea2600000000,\n    0x9e7765d900000000, 0xa826e7fd00000000, 0xf2d5619000000000,\n    0xc484e3b400000000, 0xb7bc0fb400000000, 0x81ed8d9000000000,\n    0xdb1e0bfd00000000, 0xed4f89d900000000, 0x6ff8062600000000,\n    0x59a9840200000000, 0x035a026f00000000, 0x350b804b00000000,\n    0xe52ada6e00000000, 0xd37b584a00000000, 0x8988de2700000000,\n    0xbfd95c0300000000, 0x3d6ed3fc00000000, 0x0b3f51d800000000,\n    0x51ccd7b500000000, 0x679d559100000000, 0x14a5b99100000000,\n    0x22f43bb500000000, 0x7807bdd800000000, 0x4e563ffc00000000,\n    0xcce1b00300000000, 0xfab0322700000000, 0xa043b44a00000000,\n    0x9612366e00000000, 0x8c66d89600000000, 0xba375ab200000000,\n    0xe0c4dcdf00000000, 0xd6955efb00000000, 0x5422d10400000000,\n    0x6273532000000000, 0x3880d54d00000000, 0x0ed1576900000000,\n    0x7de9bb6900000000, 0x4bb8394d00000000, 0x114bbf2000000000,\n    0x271a3d0400000000, 0xa5adb2fb00000000, 0x93fc30df00000000,\n    0xc90fb6b200000000, 0xff5e349600000000, 0x2f7f6eb300000000,\n    0x192eec9700000000, 0x43dd6afa00000000, 0x758ce8de00000000,\n    0xf73b672100000000, 0xc16ae50500000000, 0x9b99636800000000,\n    0xadc8e14c00000000, 0xdef00d4c00000000, 0xe8a18f6800000000,\n    0xb252090500000000, 0x84038b2100000000, 0x06b404de00000000,\n    0x30e586fa00000000, 0x6a16009700000000, 0x5c4782b300000000,\n    0xca55b4dd00000000, 0xfc0436f900000000, 0xa6f7b09400000000,\n    0x90a632b000000000, 0x1211bd4f00000000, 0x24403f6b00000000,\n    0x7eb3b90600000000, 0x48e23b2200000000, 0x3bdad72200000000,\n    0x0d8b550600000000, 0x5778d36b00000000, 0x6129514f00000000,\n    0xe39edeb000000000, 0xd5cf5c9400000000, 0x8f3cdaf900000000,\n    0xb96d58dd00000000, 0x694c02f800000000, 0x5f1d80dc00000000,\n    0x05ee06b100000000, 0x33bf849500000000, 0xb1080b6a00000000,\n    0x8759894e00000000, 0xddaa0f2300000000, 0xebfb8d0700000000,\n    0x98c3610700000000, 0xae92e32300000000, 0xf461654e00000000,\n    0xc230e76a00000000, 0x4087689500000000, 0x76d6eab100000000,\n    0x2c256cdc00000000, 0x1a74eef800000000, 0x59cbc1f600000000,\n    0x6f9a43d200000000, 0x3569c5bf00000000, 0x0338479b00000000,\n    0x818fc86400000000, 0xb7de4a4000000000, 0xed2dcc2d00000000,\n    0xdb7c4e0900000000, 0xa844a20900000000, 0x9e15202d00000000,\n    0xc4e6a64000000000, 0xf2b7246400000000, 0x7000ab9b00000000,\n    0x465129bf00000000, 0x1ca2afd200000000, 0x2af32df600000000,\n    0xfad277d300000000, 0xcc83f5f700000000, 0x9670739a00000000,\n    0xa021f1be00000000, 0x22967e4100000000, 0x14c7fc6500000000,\n    0x4e347a0800000000, 0x7865f82c00000000, 0x0b5d142c00000000,\n    0x3d0c960800000000, 0x67ff106500000000, 0x51ae924100000000,\n    0xd3191dbe00000000, 0xe5489f9a00000000, 0xbfbb19f700000000,\n    0x89ea9bd300000000, 0x1ff8adbd00000000, 0x29a92f9900000000,\n    0x735aa9f400000000, 0x450b2bd000000000, 0xc7bca42f00000000,\n    0xf1ed260b00000000, 0xab1ea06600000000, 0x9d4f224200000000,\n    0xee77ce4200000000, 0xd8264c6600000000, 0x82d5ca0b00000000,\n    0xb484482f00000000, 0x3633c7d000000000, 0x006245f400000000,\n    0x5a91c39900000000, 0x6cc041bd00000000, 0xbce11b9800000000,\n    0x8ab099bc00000000, 0xd0431fd100000000, 0xe6129df500000000,\n    0x64a5120a00000000, 0x52f4902e00000000, 0x0807164300000000,\n    0x3e56946700000000, 0x4d6e786700000000, 0x7b3ffa4300000000,\n    0x21cc7c2e00000000, 0x179dfe0a00000000, 0x952a71f500000000,\n    0xa37bf3d100000000, 0xf98875bc00000000, 0xcfd9f79800000000,\n    0xd5ad196000000000, 0xe3fc9b4400000000, 0xb90f1d2900000000,\n    0x8f5e9f0d00000000, 0x0de910f200000000, 0x3bb892d600000000,\n    0x614b14bb00000000, 0x571a969f00000000, 0x24227a9f00000000,\n    0x1273f8bb00000000, 0x48807ed600000000, 0x7ed1fcf200000000,\n    0xfc66730d00000000, 0xca37f12900000000, 0x90c4774400000000,\n    0xa695f56000000000, 0x76b4af4500000000, 0x40e52d6100000000,\n    0x1a16ab0c00000000, 0x2c47292800000000, 0xaef0a6d700000000,\n    0x98a124f300000000, 0xc252a29e00000000, 0xf40320ba00000000,\n    0x873bccba00000000, 0xb16a4e9e00000000, 0xeb99c8f300000000,\n    0xddc84ad700000000, 0x5f7fc52800000000, 0x692e470c00000000,\n    0x33ddc16100000000, 0x058c434500000000, 0x939e752b00000000,\n    0xa5cff70f00000000, 0xff3c716200000000, 0xc96df34600000000,\n    0x4bda7cb900000000, 0x7d8bfe9d00000000, 0x277878f000000000,\n    0x1129fad400000000, 0x621116d400000000, 0x544094f000000000,\n    0x0eb3129d00000000, 0x38e290b900000000, 0xba551f4600000000,\n    0x8c049d6200000000, 0xd6f71b0f00000000, 0xe0a6992b00000000,\n    0x3087c30e00000000, 0x06d6412a00000000, 0x5c25c74700000000,\n    0x6a74456300000000, 0xe8c3ca9c00000000, 0xde9248b800000000,\n    0x8461ced500000000, 0xb2304cf100000000, 0xc108a0f100000000,\n    0xf75922d500000000, 0xadaaa4b800000000, 0x9bfb269c00000000,\n    0x194ca96300000000, 0x2f1d2b4700000000, 0x75eead2a00000000,\n    0x43bf2f0e00000000},\n   {0x0000000000000000, 0xc8179ecf00000000, 0xd1294d4400000000,\n    0x193ed38b00000000, 0xa2539a8800000000, 0x6a44044700000000,\n    0x737ad7cc00000000, 0xbb6d490300000000, 0x05a145ca00000000,\n    0xcdb6db0500000000, 0xd488088e00000000, 0x1c9f964100000000,\n    0xa7f2df4200000000, 0x6fe5418d00000000, 0x76db920600000000,\n    0xbecc0cc900000000, 0x4b44fa4f00000000, 0x8353648000000000,\n    0x9a6db70b00000000, 0x527a29c400000000, 0xe91760c700000000,\n    0x2100fe0800000000, 0x383e2d8300000000, 0xf029b34c00000000,\n    0x4ee5bf8500000000, 0x86f2214a00000000, 0x9fccf2c100000000,\n    0x57db6c0e00000000, 0xecb6250d00000000, 0x24a1bbc200000000,\n    0x3d9f684900000000, 0xf588f68600000000, 0x9688f49f00000000,\n    0x5e9f6a5000000000, 0x47a1b9db00000000, 0x8fb6271400000000,\n    0x34db6e1700000000, 0xfcccf0d800000000, 0xe5f2235300000000,\n    0x2de5bd9c00000000, 0x9329b15500000000, 0x5b3e2f9a00000000,\n    0x4200fc1100000000, 0x8a1762de00000000, 0x317a2bdd00000000,\n    0xf96db51200000000, 0xe053669900000000, 0x2844f85600000000,\n    0xddcc0ed000000000, 0x15db901f00000000, 0x0ce5439400000000,\n    0xc4f2dd5b00000000, 0x7f9f945800000000, 0xb7880a9700000000,\n    0xaeb6d91c00000000, 0x66a147d300000000, 0xd86d4b1a00000000,\n    0x107ad5d500000000, 0x0944065e00000000, 0xc153989100000000,\n    0x7a3ed19200000000, 0xb2294f5d00000000, 0xab179cd600000000,\n    0x6300021900000000, 0x6d1798e400000000, 0xa500062b00000000,\n    0xbc3ed5a000000000, 0x74294b6f00000000, 0xcf44026c00000000,\n    0x07539ca300000000, 0x1e6d4f2800000000, 0xd67ad1e700000000,\n    0x68b6dd2e00000000, 0xa0a143e100000000, 0xb99f906a00000000,\n    0x71880ea500000000, 0xcae547a600000000, 0x02f2d96900000000,\n    0x1bcc0ae200000000, 0xd3db942d00000000, 0x265362ab00000000,\n    0xee44fc6400000000, 0xf77a2fef00000000, 0x3f6db12000000000,\n    0x8400f82300000000, 0x4c1766ec00000000, 0x5529b56700000000,\n    0x9d3e2ba800000000, 0x23f2276100000000, 0xebe5b9ae00000000,\n    0xf2db6a2500000000, 0x3accf4ea00000000, 0x81a1bde900000000,\n    0x49b6232600000000, 0x5088f0ad00000000, 0x989f6e6200000000,\n    0xfb9f6c7b00000000, 0x3388f2b400000000, 0x2ab6213f00000000,\n    0xe2a1bff000000000, 0x59ccf6f300000000, 0x91db683c00000000,\n    0x88e5bbb700000000, 0x40f2257800000000, 0xfe3e29b100000000,\n    0x3629b77e00000000, 0x2f1764f500000000, 0xe700fa3a00000000,\n    0x5c6db33900000000, 0x947a2df600000000, 0x8d44fe7d00000000,\n    0x455360b200000000, 0xb0db963400000000, 0x78cc08fb00000000,\n    0x61f2db7000000000, 0xa9e545bf00000000, 0x12880cbc00000000,\n    0xda9f927300000000, 0xc3a141f800000000, 0x0bb6df3700000000,\n    0xb57ad3fe00000000, 0x7d6d4d3100000000, 0x64539eba00000000,\n    0xac44007500000000, 0x1729497600000000, 0xdf3ed7b900000000,\n    0xc600043200000000, 0x0e179afd00000000, 0x9b28411200000000,\n    0x533fdfdd00000000, 0x4a010c5600000000, 0x8216929900000000,\n    0x397bdb9a00000000, 0xf16c455500000000, 0xe85296de00000000,\n    0x2045081100000000, 0x9e8904d800000000, 0x569e9a1700000000,\n    0x4fa0499c00000000, 0x87b7d75300000000, 0x3cda9e5000000000,\n    0xf4cd009f00000000, 0xedf3d31400000000, 0x25e44ddb00000000,\n    0xd06cbb5d00000000, 0x187b259200000000, 0x0145f61900000000,\n    0xc95268d600000000, 0x723f21d500000000, 0xba28bf1a00000000,\n    0xa3166c9100000000, 0x6b01f25e00000000, 0xd5cdfe9700000000,\n    0x1dda605800000000, 0x04e4b3d300000000, 0xccf32d1c00000000,\n    0x779e641f00000000, 0xbf89fad000000000, 0xa6b7295b00000000,\n    0x6ea0b79400000000, 0x0da0b58d00000000, 0xc5b72b4200000000,\n    0xdc89f8c900000000, 0x149e660600000000, 0xaff32f0500000000,\n    0x67e4b1ca00000000, 0x7eda624100000000, 0xb6cdfc8e00000000,\n    0x0801f04700000000, 0xc0166e8800000000, 0xd928bd0300000000,\n    0x113f23cc00000000, 0xaa526acf00000000, 0x6245f40000000000,\n    0x7b7b278b00000000, 0xb36cb94400000000, 0x46e44fc200000000,\n    0x8ef3d10d00000000, 0x97cd028600000000, 0x5fda9c4900000000,\n    0xe4b7d54a00000000, 0x2ca04b8500000000, 0x359e980e00000000,\n    0xfd8906c100000000, 0x43450a0800000000, 0x8b5294c700000000,\n    0x926c474c00000000, 0x5a7bd98300000000, 0xe116908000000000,\n    0x29010e4f00000000, 0x303fddc400000000, 0xf828430b00000000,\n    0xf63fd9f600000000, 0x3e28473900000000, 0x271694b200000000,\n    0xef010a7d00000000, 0x546c437e00000000, 0x9c7bddb100000000,\n    0x85450e3a00000000, 0x4d5290f500000000, 0xf39e9c3c00000000,\n    0x3b8902f300000000, 0x22b7d17800000000, 0xeaa04fb700000000,\n    0x51cd06b400000000, 0x99da987b00000000, 0x80e44bf000000000,\n    0x48f3d53f00000000, 0xbd7b23b900000000, 0x756cbd7600000000,\n    0x6c526efd00000000, 0xa445f03200000000, 0x1f28b93100000000,\n    0xd73f27fe00000000, 0xce01f47500000000, 0x06166aba00000000,\n    0xb8da667300000000, 0x70cdf8bc00000000, 0x69f32b3700000000,\n    0xa1e4b5f800000000, 0x1a89fcfb00000000, 0xd29e623400000000,\n    0xcba0b1bf00000000, 0x03b72f7000000000, 0x60b72d6900000000,\n    0xa8a0b3a600000000, 0xb19e602d00000000, 0x7989fee200000000,\n    0xc2e4b7e100000000, 0x0af3292e00000000, 0x13cdfaa500000000,\n    0xdbda646a00000000, 0x651668a300000000, 0xad01f66c00000000,\n    0xb43f25e700000000, 0x7c28bb2800000000, 0xc745f22b00000000,\n    0x0f526ce400000000, 0x166cbf6f00000000, 0xde7b21a000000000,\n    0x2bf3d72600000000, 0xe3e449e900000000, 0xfada9a6200000000,\n    0x32cd04ad00000000, 0x89a04dae00000000, 0x41b7d36100000000,\n    0x588900ea00000000, 0x909e9e2500000000, 0x2e5292ec00000000,\n    0xe6450c2300000000, 0xff7bdfa800000000, 0x376c416700000000,\n    0x8c01086400000000, 0x441696ab00000000, 0x5d28452000000000,\n    0x953fdbef00000000},\n   {0x0000000000000000, 0x95d4709500000000, 0x6baf90f100000000,\n    0xfe7be06400000000, 0x9758503800000000, 0x028c20ad00000000,\n    0xfcf7c0c900000000, 0x6923b05c00000000, 0x2eb1a07000000000,\n    0xbb65d0e500000000, 0x451e308100000000, 0xd0ca401400000000,\n    0xb9e9f04800000000, 0x2c3d80dd00000000, 0xd24660b900000000,\n    0x4792102c00000000, 0x5c6241e100000000, 0xc9b6317400000000,\n    0x37cdd11000000000, 0xa219a18500000000, 0xcb3a11d900000000,\n    0x5eee614c00000000, 0xa095812800000000, 0x3541f1bd00000000,\n    0x72d3e19100000000, 0xe707910400000000, 0x197c716000000000,\n    0x8ca801f500000000, 0xe58bb1a900000000, 0x705fc13c00000000,\n    0x8e24215800000000, 0x1bf051cd00000000, 0xf9c2f31900000000,\n    0x6c16838c00000000, 0x926d63e800000000, 0x07b9137d00000000,\n    0x6e9aa32100000000, 0xfb4ed3b400000000, 0x053533d000000000,\n    0x90e1434500000000, 0xd773536900000000, 0x42a723fc00000000,\n    0xbcdcc39800000000, 0x2908b30d00000000, 0x402b035100000000,\n    0xd5ff73c400000000, 0x2b8493a000000000, 0xbe50e33500000000,\n    0xa5a0b2f800000000, 0x3074c26d00000000, 0xce0f220900000000,\n    0x5bdb529c00000000, 0x32f8e2c000000000, 0xa72c925500000000,\n    0x5957723100000000, 0xcc8302a400000000, 0x8b11128800000000,\n    0x1ec5621d00000000, 0xe0be827900000000, 0x756af2ec00000000,\n    0x1c4942b000000000, 0x899d322500000000, 0x77e6d24100000000,\n    0xe232a2d400000000, 0xf285e73300000000, 0x675197a600000000,\n    0x992a77c200000000, 0x0cfe075700000000, 0x65ddb70b00000000,\n    0xf009c79e00000000, 0x0e7227fa00000000, 0x9ba6576f00000000,\n    0xdc34474300000000, 0x49e037d600000000, 0xb79bd7b200000000,\n    0x224fa72700000000, 0x4b6c177b00000000, 0xdeb867ee00000000,\n    0x20c3878a00000000, 0xb517f71f00000000, 0xaee7a6d200000000,\n    0x3b33d64700000000, 0xc548362300000000, 0x509c46b600000000,\n    0x39bff6ea00000000, 0xac6b867f00000000, 0x5210661b00000000,\n    0xc7c4168e00000000, 0x805606a200000000, 0x1582763700000000,\n    0xebf9965300000000, 0x7e2de6c600000000, 0x170e569a00000000,\n    0x82da260f00000000, 0x7ca1c66b00000000, 0xe975b6fe00000000,\n    0x0b47142a00000000, 0x9e9364bf00000000, 0x60e884db00000000,\n    0xf53cf44e00000000, 0x9c1f441200000000, 0x09cb348700000000,\n    0xf7b0d4e300000000, 0x6264a47600000000, 0x25f6b45a00000000,\n    0xb022c4cf00000000, 0x4e5924ab00000000, 0xdb8d543e00000000,\n    0xb2aee46200000000, 0x277a94f700000000, 0xd901749300000000,\n    0x4cd5040600000000, 0x572555cb00000000, 0xc2f1255e00000000,\n    0x3c8ac53a00000000, 0xa95eb5af00000000, 0xc07d05f300000000,\n    0x55a9756600000000, 0xabd2950200000000, 0x3e06e59700000000,\n    0x7994f5bb00000000, 0xec40852e00000000, 0x123b654a00000000,\n    0x87ef15df00000000, 0xeecca58300000000, 0x7b18d51600000000,\n    0x8563357200000000, 0x10b745e700000000, 0xe40bcf6700000000,\n    0x71dfbff200000000, 0x8fa45f9600000000, 0x1a702f0300000000,\n    0x73539f5f00000000, 0xe687efca00000000, 0x18fc0fae00000000,\n    0x8d287f3b00000000, 0xcaba6f1700000000, 0x5f6e1f8200000000,\n    0xa115ffe600000000, 0x34c18f7300000000, 0x5de23f2f00000000,\n    0xc8364fba00000000, 0x364dafde00000000, 0xa399df4b00000000,\n    0xb8698e8600000000, 0x2dbdfe1300000000, 0xd3c61e7700000000,\n    0x46126ee200000000, 0x2f31debe00000000, 0xbae5ae2b00000000,\n    0x449e4e4f00000000, 0xd14a3eda00000000, 0x96d82ef600000000,\n    0x030c5e6300000000, 0xfd77be0700000000, 0x68a3ce9200000000,\n    0x01807ece00000000, 0x94540e5b00000000, 0x6a2fee3f00000000,\n    0xfffb9eaa00000000, 0x1dc93c7e00000000, 0x881d4ceb00000000,\n    0x7666ac8f00000000, 0xe3b2dc1a00000000, 0x8a916c4600000000,\n    0x1f451cd300000000, 0xe13efcb700000000, 0x74ea8c2200000000,\n    0x33789c0e00000000, 0xa6acec9b00000000, 0x58d70cff00000000,\n    0xcd037c6a00000000, 0xa420cc3600000000, 0x31f4bca300000000,\n    0xcf8f5cc700000000, 0x5a5b2c5200000000, 0x41ab7d9f00000000,\n    0xd47f0d0a00000000, 0x2a04ed6e00000000, 0xbfd09dfb00000000,\n    0xd6f32da700000000, 0x43275d3200000000, 0xbd5cbd5600000000,\n    0x2888cdc300000000, 0x6f1addef00000000, 0xfacead7a00000000,\n    0x04b54d1e00000000, 0x91613d8b00000000, 0xf8428dd700000000,\n    0x6d96fd4200000000, 0x93ed1d2600000000, 0x06396db300000000,\n    0x168e285400000000, 0x835a58c100000000, 0x7d21b8a500000000,\n    0xe8f5c83000000000, 0x81d6786c00000000, 0x140208f900000000,\n    0xea79e89d00000000, 0x7fad980800000000, 0x383f882400000000,\n    0xadebf8b100000000, 0x539018d500000000, 0xc644684000000000,\n    0xaf67d81c00000000, 0x3ab3a88900000000, 0xc4c848ed00000000,\n    0x511c387800000000, 0x4aec69b500000000, 0xdf38192000000000,\n    0x2143f94400000000, 0xb49789d100000000, 0xddb4398d00000000,\n    0x4860491800000000, 0xb61ba97c00000000, 0x23cfd9e900000000,\n    0x645dc9c500000000, 0xf189b95000000000, 0x0ff2593400000000,\n    0x9a2629a100000000, 0xf30599fd00000000, 0x66d1e96800000000,\n    0x98aa090c00000000, 0x0d7e799900000000, 0xef4cdb4d00000000,\n    0x7a98abd800000000, 0x84e34bbc00000000, 0x11373b2900000000,\n    0x78148b7500000000, 0xedc0fbe000000000, 0x13bb1b8400000000,\n    0x866f6b1100000000, 0xc1fd7b3d00000000, 0x54290ba800000000,\n    0xaa52ebcc00000000, 0x3f869b5900000000, 0x56a52b0500000000,\n    0xc3715b9000000000, 0x3d0abbf400000000, 0xa8decb6100000000,\n    0xb32e9aac00000000, 0x26faea3900000000, 0xd8810a5d00000000,\n    0x4d557ac800000000, 0x2476ca9400000000, 0xb1a2ba0100000000,\n    0x4fd95a6500000000, 0xda0d2af000000000, 0x9d9f3adc00000000,\n    0x084b4a4900000000, 0xf630aa2d00000000, 0x63e4dab800000000,\n    0x0ac76ae400000000, 0x9f131a7100000000, 0x6168fa1500000000,\n    0xf4bc8a8000000000},\n   {0x0000000000000000, 0x1f17f08000000000, 0x7f2891da00000000,\n    0x603f615a00000000, 0xbf56536e00000000, 0xa041a3ee00000000,\n    0xc07ec2b400000000, 0xdf69323400000000, 0x7eada6dc00000000,\n    0x61ba565c00000000, 0x0185370600000000, 0x1e92c78600000000,\n    0xc1fbf5b200000000, 0xdeec053200000000, 0xbed3646800000000,\n    0xa1c494e800000000, 0xbd5c3c6200000000, 0xa24bcce200000000,\n    0xc274adb800000000, 0xdd635d3800000000, 0x020a6f0c00000000,\n    0x1d1d9f8c00000000, 0x7d22fed600000000, 0x62350e5600000000,\n    0xc3f19abe00000000, 0xdce66a3e00000000, 0xbcd90b6400000000,\n    0xa3cefbe400000000, 0x7ca7c9d000000000, 0x63b0395000000000,\n    0x038f580a00000000, 0x1c98a88a00000000, 0x7ab978c400000000,\n    0x65ae884400000000, 0x0591e91e00000000, 0x1a86199e00000000,\n    0xc5ef2baa00000000, 0xdaf8db2a00000000, 0xbac7ba7000000000,\n    0xa5d04af000000000, 0x0414de1800000000, 0x1b032e9800000000,\n    0x7b3c4fc200000000, 0x642bbf4200000000, 0xbb428d7600000000,\n    0xa4557df600000000, 0xc46a1cac00000000, 0xdb7dec2c00000000,\n    0xc7e544a600000000, 0xd8f2b42600000000, 0xb8cdd57c00000000,\n    0xa7da25fc00000000, 0x78b317c800000000, 0x67a4e74800000000,\n    0x079b861200000000, 0x188c769200000000, 0xb948e27a00000000,\n    0xa65f12fa00000000, 0xc66073a000000000, 0xd977832000000000,\n    0x061eb11400000000, 0x1909419400000000, 0x793620ce00000000,\n    0x6621d04e00000000, 0xb574805300000000, 0xaa6370d300000000,\n    0xca5c118900000000, 0xd54be10900000000, 0x0a22d33d00000000,\n    0x153523bd00000000, 0x750a42e700000000, 0x6a1db26700000000,\n    0xcbd9268f00000000, 0xd4ced60f00000000, 0xb4f1b75500000000,\n    0xabe647d500000000, 0x748f75e100000000, 0x6b98856100000000,\n    0x0ba7e43b00000000, 0x14b014bb00000000, 0x0828bc3100000000,\n    0x173f4cb100000000, 0x77002deb00000000, 0x6817dd6b00000000,\n    0xb77eef5f00000000, 0xa8691fdf00000000, 0xc8567e8500000000,\n    0xd7418e0500000000, 0x76851aed00000000, 0x6992ea6d00000000,\n    0x09ad8b3700000000, 0x16ba7bb700000000, 0xc9d3498300000000,\n    0xd6c4b90300000000, 0xb6fbd85900000000, 0xa9ec28d900000000,\n    0xcfcdf89700000000, 0xd0da081700000000, 0xb0e5694d00000000,\n    0xaff299cd00000000, 0x709babf900000000, 0x6f8c5b7900000000,\n    0x0fb33a2300000000, 0x10a4caa300000000, 0xb1605e4b00000000,\n    0xae77aecb00000000, 0xce48cf9100000000, 0xd15f3f1100000000,\n    0x0e360d2500000000, 0x1121fda500000000, 0x711e9cff00000000,\n    0x6e096c7f00000000, 0x7291c4f500000000, 0x6d86347500000000,\n    0x0db9552f00000000, 0x12aea5af00000000, 0xcdc7979b00000000,\n    0xd2d0671b00000000, 0xb2ef064100000000, 0xadf8f6c100000000,\n    0x0c3c622900000000, 0x132b92a900000000, 0x7314f3f300000000,\n    0x6c03037300000000, 0xb36a314700000000, 0xac7dc1c700000000,\n    0xcc42a09d00000000, 0xd355501d00000000, 0x6ae900a700000000,\n    0x75fef02700000000, 0x15c1917d00000000, 0x0ad661fd00000000,\n    0xd5bf53c900000000, 0xcaa8a34900000000, 0xaa97c21300000000,\n    0xb580329300000000, 0x1444a67b00000000, 0x0b5356fb00000000,\n    0x6b6c37a100000000, 0x747bc72100000000, 0xab12f51500000000,\n    0xb405059500000000, 0xd43a64cf00000000, 0xcb2d944f00000000,\n    0xd7b53cc500000000, 0xc8a2cc4500000000, 0xa89dad1f00000000,\n    0xb78a5d9f00000000, 0x68e36fab00000000, 0x77f49f2b00000000,\n    0x17cbfe7100000000, 0x08dc0ef100000000, 0xa9189a1900000000,\n    0xb60f6a9900000000, 0xd6300bc300000000, 0xc927fb4300000000,\n    0x164ec97700000000, 0x095939f700000000, 0x696658ad00000000,\n    0x7671a82d00000000, 0x1050786300000000, 0x0f4788e300000000,\n    0x6f78e9b900000000, 0x706f193900000000, 0xaf062b0d00000000,\n    0xb011db8d00000000, 0xd02ebad700000000, 0xcf394a5700000000,\n    0x6efddebf00000000, 0x71ea2e3f00000000, 0x11d54f6500000000,\n    0x0ec2bfe500000000, 0xd1ab8dd100000000, 0xcebc7d5100000000,\n    0xae831c0b00000000, 0xb194ec8b00000000, 0xad0c440100000000,\n    0xb21bb48100000000, 0xd224d5db00000000, 0xcd33255b00000000,\n    0x125a176f00000000, 0x0d4de7ef00000000, 0x6d7286b500000000,\n    0x7265763500000000, 0xd3a1e2dd00000000, 0xccb6125d00000000,\n    0xac89730700000000, 0xb39e838700000000, 0x6cf7b1b300000000,\n    0x73e0413300000000, 0x13df206900000000, 0x0cc8d0e900000000,\n    0xdf9d80f400000000, 0xc08a707400000000, 0xa0b5112e00000000,\n    0xbfa2e1ae00000000, 0x60cbd39a00000000, 0x7fdc231a00000000,\n    0x1fe3424000000000, 0x00f4b2c000000000, 0xa130262800000000,\n    0xbe27d6a800000000, 0xde18b7f200000000, 0xc10f477200000000,\n    0x1e66754600000000, 0x017185c600000000, 0x614ee49c00000000,\n    0x7e59141c00000000, 0x62c1bc9600000000, 0x7dd64c1600000000,\n    0x1de92d4c00000000, 0x02feddcc00000000, 0xdd97eff800000000,\n    0xc2801f7800000000, 0xa2bf7e2200000000, 0xbda88ea200000000,\n    0x1c6c1a4a00000000, 0x037beaca00000000, 0x63448b9000000000,\n    0x7c537b1000000000, 0xa33a492400000000, 0xbc2db9a400000000,\n    0xdc12d8fe00000000, 0xc305287e00000000, 0xa524f83000000000,\n    0xba3308b000000000, 0xda0c69ea00000000, 0xc51b996a00000000,\n    0x1a72ab5e00000000, 0x05655bde00000000, 0x655a3a8400000000,\n    0x7a4dca0400000000, 0xdb895eec00000000, 0xc49eae6c00000000,\n    0xa4a1cf3600000000, 0xbbb63fb600000000, 0x64df0d8200000000,\n    0x7bc8fd0200000000, 0x1bf79c5800000000, 0x04e06cd800000000,\n    0x1878c45200000000, 0x076f34d200000000, 0x6750558800000000,\n    0x7847a50800000000, 0xa72e973c00000000, 0xb83967bc00000000,\n    0xd80606e600000000, 0xc711f66600000000, 0x66d5628e00000000,\n    0x79c2920e00000000, 0x19fdf35400000000, 0x06ea03d400000000,\n    0xd98331e000000000, 0xc694c16000000000, 0xa6aba03a00000000,\n    0xb9bc50ba00000000},\n   {0x0000000000000000, 0xe2fd888d00000000, 0x85fd60c000000000,\n    0x6700e84d00000000, 0x4bfdb05b00000000, 0xa90038d600000000,\n    0xce00d09b00000000, 0x2cfd581600000000, 0x96fa61b700000000,\n    0x7407e93a00000000, 0x1307017700000000, 0xf1fa89fa00000000,\n    0xdd07d1ec00000000, 0x3ffa596100000000, 0x58fab12c00000000,\n    0xba0739a100000000, 0x6df3b2b500000000, 0x8f0e3a3800000000,\n    0xe80ed27500000000, 0x0af35af800000000, 0x260e02ee00000000,\n    0xc4f38a6300000000, 0xa3f3622e00000000, 0x410eeaa300000000,\n    0xfb09d30200000000, 0x19f45b8f00000000, 0x7ef4b3c200000000,\n    0x9c093b4f00000000, 0xb0f4635900000000, 0x5209ebd400000000,\n    0x3509039900000000, 0xd7f48b1400000000, 0x9be014b000000000,\n    0x791d9c3d00000000, 0x1e1d747000000000, 0xfce0fcfd00000000,\n    0xd01da4eb00000000, 0x32e02c6600000000, 0x55e0c42b00000000,\n    0xb71d4ca600000000, 0x0d1a750700000000, 0xefe7fd8a00000000,\n    0x88e715c700000000, 0x6a1a9d4a00000000, 0x46e7c55c00000000,\n    0xa41a4dd100000000, 0xc31aa59c00000000, 0x21e72d1100000000,\n    0xf613a60500000000, 0x14ee2e8800000000, 0x73eec6c500000000,\n    0x91134e4800000000, 0xbdee165e00000000, 0x5f139ed300000000,\n    0x3813769e00000000, 0xdaeefe1300000000, 0x60e9c7b200000000,\n    0x82144f3f00000000, 0xe514a77200000000, 0x07e92fff00000000,\n    0x2b1477e900000000, 0xc9e9ff6400000000, 0xaee9172900000000,\n    0x4c149fa400000000, 0x77c758bb00000000, 0x953ad03600000000,\n    0xf23a387b00000000, 0x10c7b0f600000000, 0x3c3ae8e000000000,\n    0xdec7606d00000000, 0xb9c7882000000000, 0x5b3a00ad00000000,\n    0xe13d390c00000000, 0x03c0b18100000000, 0x64c059cc00000000,\n    0x863dd14100000000, 0xaac0895700000000, 0x483d01da00000000,\n    0x2f3de99700000000, 0xcdc0611a00000000, 0x1a34ea0e00000000,\n    0xf8c9628300000000, 0x9fc98ace00000000, 0x7d34024300000000,\n    0x51c95a5500000000, 0xb334d2d800000000, 0xd4343a9500000000,\n    0x36c9b21800000000, 0x8cce8bb900000000, 0x6e33033400000000,\n    0x0933eb7900000000, 0xebce63f400000000, 0xc7333be200000000,\n    0x25ceb36f00000000, 0x42ce5b2200000000, 0xa033d3af00000000,\n    0xec274c0b00000000, 0x0edac48600000000, 0x69da2ccb00000000,\n    0x8b27a44600000000, 0xa7dafc5000000000, 0x452774dd00000000,\n    0x22279c9000000000, 0xc0da141d00000000, 0x7add2dbc00000000,\n    0x9820a53100000000, 0xff204d7c00000000, 0x1dddc5f100000000,\n    0x31209de700000000, 0xd3dd156a00000000, 0xb4ddfd2700000000,\n    0x562075aa00000000, 0x81d4febe00000000, 0x6329763300000000,\n    0x04299e7e00000000, 0xe6d416f300000000, 0xca294ee500000000,\n    0x28d4c66800000000, 0x4fd42e2500000000, 0xad29a6a800000000,\n    0x172e9f0900000000, 0xf5d3178400000000, 0x92d3ffc900000000,\n    0x702e774400000000, 0x5cd32f5200000000, 0xbe2ea7df00000000,\n    0xd92e4f9200000000, 0x3bd3c71f00000000, 0xaf88c0ad00000000,\n    0x4d75482000000000, 0x2a75a06d00000000, 0xc88828e000000000,\n    0xe47570f600000000, 0x0688f87b00000000, 0x6188103600000000,\n    0x837598bb00000000, 0x3972a11a00000000, 0xdb8f299700000000,\n    0xbc8fc1da00000000, 0x5e72495700000000, 0x728f114100000000,\n    0x907299cc00000000, 0xf772718100000000, 0x158ff90c00000000,\n    0xc27b721800000000, 0x2086fa9500000000, 0x478612d800000000,\n    0xa57b9a5500000000, 0x8986c24300000000, 0x6b7b4ace00000000,\n    0x0c7ba28300000000, 0xee862a0e00000000, 0x548113af00000000,\n    0xb67c9b2200000000, 0xd17c736f00000000, 0x3381fbe200000000,\n    0x1f7ca3f400000000, 0xfd812b7900000000, 0x9a81c33400000000,\n    0x787c4bb900000000, 0x3468d41d00000000, 0xd6955c9000000000,\n    0xb195b4dd00000000, 0x53683c5000000000, 0x7f95644600000000,\n    0x9d68eccb00000000, 0xfa68048600000000, 0x18958c0b00000000,\n    0xa292b5aa00000000, 0x406f3d2700000000, 0x276fd56a00000000,\n    0xc5925de700000000, 0xe96f05f100000000, 0x0b928d7c00000000,\n    0x6c92653100000000, 0x8e6fedbc00000000, 0x599b66a800000000,\n    0xbb66ee2500000000, 0xdc66066800000000, 0x3e9b8ee500000000,\n    0x1266d6f300000000, 0xf09b5e7e00000000, 0x979bb63300000000,\n    0x75663ebe00000000, 0xcf61071f00000000, 0x2d9c8f9200000000,\n    0x4a9c67df00000000, 0xa861ef5200000000, 0x849cb74400000000,\n    0x66613fc900000000, 0x0161d78400000000, 0xe39c5f0900000000,\n    0xd84f981600000000, 0x3ab2109b00000000, 0x5db2f8d600000000,\n    0xbf4f705b00000000, 0x93b2284d00000000, 0x714fa0c000000000,\n    0x164f488d00000000, 0xf4b2c00000000000, 0x4eb5f9a100000000,\n    0xac48712c00000000, 0xcb48996100000000, 0x29b511ec00000000,\n    0x054849fa00000000, 0xe7b5c17700000000, 0x80b5293a00000000,\n    0x6248a1b700000000, 0xb5bc2aa300000000, 0x5741a22e00000000,\n    0x30414a6300000000, 0xd2bcc2ee00000000, 0xfe419af800000000,\n    0x1cbc127500000000, 0x7bbcfa3800000000, 0x994172b500000000,\n    0x23464b1400000000, 0xc1bbc39900000000, 0xa6bb2bd400000000,\n    0x4446a35900000000, 0x68bbfb4f00000000, 0x8a4673c200000000,\n    0xed469b8f00000000, 0x0fbb130200000000, 0x43af8ca600000000,\n    0xa152042b00000000, 0xc652ec6600000000, 0x24af64eb00000000,\n    0x08523cfd00000000, 0xeaafb47000000000, 0x8daf5c3d00000000,\n    0x6f52d4b000000000, 0xd555ed1100000000, 0x37a8659c00000000,\n    0x50a88dd100000000, 0xb255055c00000000, 0x9ea85d4a00000000,\n    0x7c55d5c700000000, 0x1b553d8a00000000, 0xf9a8b50700000000,\n    0x2e5c3e1300000000, 0xcca1b69e00000000, 0xaba15ed300000000,\n    0x495cd65e00000000, 0x65a18e4800000000, 0x875c06c500000000,\n    0xe05cee8800000000, 0x02a1660500000000, 0xb8a65fa400000000,\n    0x5a5bd72900000000, 0x3d5b3f6400000000, 0xdfa6b7e900000000,\n    0xf35befff00000000, 0x11a6677200000000, 0x76a68f3f00000000,\n    0x945b07b200000000},\n   {0x0000000000000000, 0xa90b894e00000000, 0x5217129d00000000,\n    0xfb1c9bd300000000, 0xe52855e100000000, 0x4c23dcaf00000000,\n    0xb73f477c00000000, 0x1e34ce3200000000, 0x8b57db1900000000,\n    0x225c525700000000, 0xd940c98400000000, 0x704b40ca00000000,\n    0x6e7f8ef800000000, 0xc77407b600000000, 0x3c689c6500000000,\n    0x9563152b00000000, 0x16afb63300000000, 0xbfa43f7d00000000,\n    0x44b8a4ae00000000, 0xedb32de000000000, 0xf387e3d200000000,\n    0x5a8c6a9c00000000, 0xa190f14f00000000, 0x089b780100000000,\n    0x9df86d2a00000000, 0x34f3e46400000000, 0xcfef7fb700000000,\n    0x66e4f6f900000000, 0x78d038cb00000000, 0xd1dbb18500000000,\n    0x2ac72a5600000000, 0x83cca31800000000, 0x2c5e6d6700000000,\n    0x8555e42900000000, 0x7e497ffa00000000, 0xd742f6b400000000,\n    0xc976388600000000, 0x607db1c800000000, 0x9b612a1b00000000,\n    0x326aa35500000000, 0xa709b67e00000000, 0x0e023f3000000000,\n    0xf51ea4e300000000, 0x5c152dad00000000, 0x4221e39f00000000,\n    0xeb2a6ad100000000, 0x1036f10200000000, 0xb93d784c00000000,\n    0x3af1db5400000000, 0x93fa521a00000000, 0x68e6c9c900000000,\n    0xc1ed408700000000, 0xdfd98eb500000000, 0x76d207fb00000000,\n    0x8dce9c2800000000, 0x24c5156600000000, 0xb1a6004d00000000,\n    0x18ad890300000000, 0xe3b112d000000000, 0x4aba9b9e00000000,\n    0x548e55ac00000000, 0xfd85dce200000000, 0x0699473100000000,\n    0xaf92ce7f00000000, 0x58bcdace00000000, 0xf1b7538000000000,\n    0x0aabc85300000000, 0xa3a0411d00000000, 0xbd948f2f00000000,\n    0x149f066100000000, 0xef839db200000000, 0x468814fc00000000,\n    0xd3eb01d700000000, 0x7ae0889900000000, 0x81fc134a00000000,\n    0x28f79a0400000000, 0x36c3543600000000, 0x9fc8dd7800000000,\n    0x64d446ab00000000, 0xcddfcfe500000000, 0x4e136cfd00000000,\n    0xe718e5b300000000, 0x1c047e6000000000, 0xb50ff72e00000000,\n    0xab3b391c00000000, 0x0230b05200000000, 0xf92c2b8100000000,\n    0x5027a2cf00000000, 0xc544b7e400000000, 0x6c4f3eaa00000000,\n    0x9753a57900000000, 0x3e582c3700000000, 0x206ce20500000000,\n    0x89676b4b00000000, 0x727bf09800000000, 0xdb7079d600000000,\n    0x74e2b7a900000000, 0xdde93ee700000000, 0x26f5a53400000000,\n    0x8ffe2c7a00000000, 0x91cae24800000000, 0x38c16b0600000000,\n    0xc3ddf0d500000000, 0x6ad6799b00000000, 0xffb56cb000000000,\n    0x56bee5fe00000000, 0xada27e2d00000000, 0x04a9f76300000000,\n    0x1a9d395100000000, 0xb396b01f00000000, 0x488a2bcc00000000,\n    0xe181a28200000000, 0x624d019a00000000, 0xcb4688d400000000,\n    0x305a130700000000, 0x99519a4900000000, 0x8765547b00000000,\n    0x2e6edd3500000000, 0xd57246e600000000, 0x7c79cfa800000000,\n    0xe91ada8300000000, 0x401153cd00000000, 0xbb0dc81e00000000,\n    0x1206415000000000, 0x0c328f6200000000, 0xa539062c00000000,\n    0x5e259dff00000000, 0xf72e14b100000000, 0xf17ec44600000000,\n    0x58754d0800000000, 0xa369d6db00000000, 0x0a625f9500000000,\n    0x145691a700000000, 0xbd5d18e900000000, 0x4641833a00000000,\n    0xef4a0a7400000000, 0x7a291f5f00000000, 0xd322961100000000,\n    0x283e0dc200000000, 0x8135848c00000000, 0x9f014abe00000000,\n    0x360ac3f000000000, 0xcd16582300000000, 0x641dd16d00000000,\n    0xe7d1727500000000, 0x4edafb3b00000000, 0xb5c660e800000000,\n    0x1ccde9a600000000, 0x02f9279400000000, 0xabf2aeda00000000,\n    0x50ee350900000000, 0xf9e5bc4700000000, 0x6c86a96c00000000,\n    0xc58d202200000000, 0x3e91bbf100000000, 0x979a32bf00000000,\n    0x89aefc8d00000000, 0x20a575c300000000, 0xdbb9ee1000000000,\n    0x72b2675e00000000, 0xdd20a92100000000, 0x742b206f00000000,\n    0x8f37bbbc00000000, 0x263c32f200000000, 0x3808fcc000000000,\n    0x9103758e00000000, 0x6a1fee5d00000000, 0xc314671300000000,\n    0x5677723800000000, 0xff7cfb7600000000, 0x046060a500000000,\n    0xad6be9eb00000000, 0xb35f27d900000000, 0x1a54ae9700000000,\n    0xe148354400000000, 0x4843bc0a00000000, 0xcb8f1f1200000000,\n    0x6284965c00000000, 0x99980d8f00000000, 0x309384c100000000,\n    0x2ea74af300000000, 0x87acc3bd00000000, 0x7cb0586e00000000,\n    0xd5bbd12000000000, 0x40d8c40b00000000, 0xe9d34d4500000000,\n    0x12cfd69600000000, 0xbbc45fd800000000, 0xa5f091ea00000000,\n    0x0cfb18a400000000, 0xf7e7837700000000, 0x5eec0a3900000000,\n    0xa9c21e8800000000, 0x00c997c600000000, 0xfbd50c1500000000,\n    0x52de855b00000000, 0x4cea4b6900000000, 0xe5e1c22700000000,\n    0x1efd59f400000000, 0xb7f6d0ba00000000, 0x2295c59100000000,\n    0x8b9e4cdf00000000, 0x7082d70c00000000, 0xd9895e4200000000,\n    0xc7bd907000000000, 0x6eb6193e00000000, 0x95aa82ed00000000,\n    0x3ca10ba300000000, 0xbf6da8bb00000000, 0x166621f500000000,\n    0xed7aba2600000000, 0x4471336800000000, 0x5a45fd5a00000000,\n    0xf34e741400000000, 0x0852efc700000000, 0xa159668900000000,\n    0x343a73a200000000, 0x9d31faec00000000, 0x662d613f00000000,\n    0xcf26e87100000000, 0xd112264300000000, 0x7819af0d00000000,\n    0x830534de00000000, 0x2a0ebd9000000000, 0x859c73ef00000000,\n    0x2c97faa100000000, 0xd78b617200000000, 0x7e80e83c00000000,\n    0x60b4260e00000000, 0xc9bfaf4000000000, 0x32a3349300000000,\n    0x9ba8bddd00000000, 0x0ecba8f600000000, 0xa7c021b800000000,\n    0x5cdcba6b00000000, 0xf5d7332500000000, 0xebe3fd1700000000,\n    0x42e8745900000000, 0xb9f4ef8a00000000, 0x10ff66c400000000,\n    0x9333c5dc00000000, 0x3a384c9200000000, 0xc124d74100000000,\n    0x682f5e0f00000000, 0x761b903d00000000, 0xdf10197300000000,\n    0x240c82a000000000, 0x8d070bee00000000, 0x18641ec500000000,\n    0xb16f978b00000000, 0x4a730c5800000000, 0xe378851600000000,\n    0xfd4c4b2400000000, 0x5447c26a00000000, 0xaf5b59b900000000,\n    0x0650d0f700000000},\n   {0x0000000000000000, 0x479244af00000000, 0xcf22f88500000000,\n    0x88b0bc2a00000000, 0xdf4381d000000000, 0x98d1c57f00000000,\n    0x1061795500000000, 0x57f33dfa00000000, 0xff81737a00000000,\n    0xb81337d500000000, 0x30a38bff00000000, 0x7731cf5000000000,\n    0x20c2f2aa00000000, 0x6750b60500000000, 0xefe00a2f00000000,\n    0xa8724e8000000000, 0xfe03e7f400000000, 0xb991a35b00000000,\n    0x31211f7100000000, 0x76b35bde00000000, 0x2140662400000000,\n    0x66d2228b00000000, 0xee629ea100000000, 0xa9f0da0e00000000,\n    0x0182948e00000000, 0x4610d02100000000, 0xcea06c0b00000000,\n    0x893228a400000000, 0xdec1155e00000000, 0x995351f100000000,\n    0x11e3eddb00000000, 0x5671a97400000000, 0xbd01bf3200000000,\n    0xfa93fb9d00000000, 0x722347b700000000, 0x35b1031800000000,\n    0x62423ee200000000, 0x25d07a4d00000000, 0xad60c66700000000,\n    0xeaf282c800000000, 0x4280cc4800000000, 0x051288e700000000,\n    0x8da234cd00000000, 0xca30706200000000, 0x9dc34d9800000000,\n    0xda51093700000000, 0x52e1b51d00000000, 0x1573f1b200000000,\n    0x430258c600000000, 0x04901c6900000000, 0x8c20a04300000000,\n    0xcbb2e4ec00000000, 0x9c41d91600000000, 0xdbd39db900000000,\n    0x5363219300000000, 0x14f1653c00000000, 0xbc832bbc00000000,\n    0xfb116f1300000000, 0x73a1d33900000000, 0x3433979600000000,\n    0x63c0aa6c00000000, 0x2452eec300000000, 0xace252e900000000,\n    0xeb70164600000000, 0x7a037e6500000000, 0x3d913aca00000000,\n    0xb52186e000000000, 0xf2b3c24f00000000, 0xa540ffb500000000,\n    0xe2d2bb1a00000000, 0x6a62073000000000, 0x2df0439f00000000,\n    0x85820d1f00000000, 0xc21049b000000000, 0x4aa0f59a00000000,\n    0x0d32b13500000000, 0x5ac18ccf00000000, 0x1d53c86000000000,\n    0x95e3744a00000000, 0xd27130e500000000, 0x8400999100000000,\n    0xc392dd3e00000000, 0x4b22611400000000, 0x0cb025bb00000000,\n    0x5b43184100000000, 0x1cd15cee00000000, 0x9461e0c400000000,\n    0xd3f3a46b00000000, 0x7b81eaeb00000000, 0x3c13ae4400000000,\n    0xb4a3126e00000000, 0xf33156c100000000, 0xa4c26b3b00000000,\n    0xe3502f9400000000, 0x6be093be00000000, 0x2c72d71100000000,\n    0xc702c15700000000, 0x809085f800000000, 0x082039d200000000,\n    0x4fb27d7d00000000, 0x1841408700000000, 0x5fd3042800000000,\n    0xd763b80200000000, 0x90f1fcad00000000, 0x3883b22d00000000,\n    0x7f11f68200000000, 0xf7a14aa800000000, 0xb0330e0700000000,\n    0xe7c033fd00000000, 0xa052775200000000, 0x28e2cb7800000000,\n    0x6f708fd700000000, 0x390126a300000000, 0x7e93620c00000000,\n    0xf623de2600000000, 0xb1b19a8900000000, 0xe642a77300000000,\n    0xa1d0e3dc00000000, 0x29605ff600000000, 0x6ef21b5900000000,\n    0xc68055d900000000, 0x8112117600000000, 0x09a2ad5c00000000,\n    0x4e30e9f300000000, 0x19c3d40900000000, 0x5e5190a600000000,\n    0xd6e12c8c00000000, 0x9173682300000000, 0xf406fcca00000000,\n    0xb394b86500000000, 0x3b24044f00000000, 0x7cb640e000000000,\n    0x2b457d1a00000000, 0x6cd739b500000000, 0xe467859f00000000,\n    0xa3f5c13000000000, 0x0b878fb000000000, 0x4c15cb1f00000000,\n    0xc4a5773500000000, 0x8337339a00000000, 0xd4c40e6000000000,\n    0x93564acf00000000, 0x1be6f6e500000000, 0x5c74b24a00000000,\n    0x0a051b3e00000000, 0x4d975f9100000000, 0xc527e3bb00000000,\n    0x82b5a71400000000, 0xd5469aee00000000, 0x92d4de4100000000,\n    0x1a64626b00000000, 0x5df626c400000000, 0xf584684400000000,\n    0xb2162ceb00000000, 0x3aa690c100000000, 0x7d34d46e00000000,\n    0x2ac7e99400000000, 0x6d55ad3b00000000, 0xe5e5111100000000,\n    0xa27755be00000000, 0x490743f800000000, 0x0e95075700000000,\n    0x8625bb7d00000000, 0xc1b7ffd200000000, 0x9644c22800000000,\n    0xd1d6868700000000, 0x59663aad00000000, 0x1ef47e0200000000,\n    0xb686308200000000, 0xf114742d00000000, 0x79a4c80700000000,\n    0x3e368ca800000000, 0x69c5b15200000000, 0x2e57f5fd00000000,\n    0xa6e749d700000000, 0xe1750d7800000000, 0xb704a40c00000000,\n    0xf096e0a300000000, 0x78265c8900000000, 0x3fb4182600000000,\n    0x684725dc00000000, 0x2fd5617300000000, 0xa765dd5900000000,\n    0xe0f799f600000000, 0x4885d77600000000, 0x0f1793d900000000,\n    0x87a72ff300000000, 0xc0356b5c00000000, 0x97c656a600000000,\n    0xd054120900000000, 0x58e4ae2300000000, 0x1f76ea8c00000000,\n    0x8e0582af00000000, 0xc997c60000000000, 0x41277a2a00000000,\n    0x06b53e8500000000, 0x5146037f00000000, 0x16d447d000000000,\n    0x9e64fbfa00000000, 0xd9f6bf5500000000, 0x7184f1d500000000,\n    0x3616b57a00000000, 0xbea6095000000000, 0xf9344dff00000000,\n    0xaec7700500000000, 0xe95534aa00000000, 0x61e5888000000000,\n    0x2677cc2f00000000, 0x7006655b00000000, 0x379421f400000000,\n    0xbf249dde00000000, 0xf8b6d97100000000, 0xaf45e48b00000000,\n    0xe8d7a02400000000, 0x60671c0e00000000, 0x27f558a100000000,\n    0x8f87162100000000, 0xc815528e00000000, 0x40a5eea400000000,\n    0x0737aa0b00000000, 0x50c497f100000000, 0x1756d35e00000000,\n    0x9fe66f7400000000, 0xd8742bdb00000000, 0x33043d9d00000000,\n    0x7496793200000000, 0xfc26c51800000000, 0xbbb481b700000000,\n    0xec47bc4d00000000, 0xabd5f8e200000000, 0x236544c800000000,\n    0x64f7006700000000, 0xcc854ee700000000, 0x8b170a4800000000,\n    0x03a7b66200000000, 0x4435f2cd00000000, 0x13c6cf3700000000,\n    0x54548b9800000000, 0xdce437b200000000, 0x9b76731d00000000,\n    0xcd07da6900000000, 0x8a959ec600000000, 0x022522ec00000000,\n    0x45b7664300000000, 0x12445bb900000000, 0x55d61f1600000000,\n    0xdd66a33c00000000, 0x9af4e79300000000, 0x3286a91300000000,\n    0x7514edbc00000000, 0xfda4519600000000, 0xba36153900000000,\n    0xedc528c300000000, 0xaa576c6c00000000, 0x22e7d04600000000,\n    0x657594e900000000}};\n\n#else /* W == 4 */\n\nlocal const z_crc_t FAR crc_braid_table[][256] = {\n   {0x00000000, 0x65673b46, 0xcace768c, 0xafa94dca, 0x4eedeb59,\n    0x2b8ad01f, 0x84239dd5, 0xe144a693, 0x9ddbd6b2, 0xf8bcedf4,\n    0x5715a03e, 0x32729b78, 0xd3363deb, 0xb65106ad, 0x19f84b67,\n    0x7c9f7021, 0xe0c6ab25, 0x85a19063, 0x2a08dda9, 0x4f6fe6ef,\n    0xae2b407c, 0xcb4c7b3a, 0x64e536f0, 0x01820db6, 0x7d1d7d97,\n    0x187a46d1, 0xb7d30b1b, 0xd2b4305d, 0x33f096ce, 0x5697ad88,\n    0xf93ee042, 0x9c59db04, 0x1afc500b, 0x7f9b6b4d, 0xd0322687,\n    0xb5551dc1, 0x5411bb52, 0x31768014, 0x9edfcdde, 0xfbb8f698,\n    0x872786b9, 0xe240bdff, 0x4de9f035, 0x288ecb73, 0xc9ca6de0,\n    0xacad56a6, 0x03041b6c, 0x6663202a, 0xfa3afb2e, 0x9f5dc068,\n    0x30f48da2, 0x5593b6e4, 0xb4d71077, 0xd1b02b31, 0x7e1966fb,\n    0x1b7e5dbd, 0x67e12d9c, 0x028616da, 0xad2f5b10, 0xc8486056,\n    0x290cc6c5, 0x4c6bfd83, 0xe3c2b049, 0x86a58b0f, 0x35f8a016,\n    0x509f9b50, 0xff36d69a, 0x9a51eddc, 0x7b154b4f, 0x1e727009,\n    0xb1db3dc3, 0xd4bc0685, 0xa82376a4, 0xcd444de2, 0x62ed0028,\n    0x078a3b6e, 0xe6ce9dfd, 0x83a9a6bb, 0x2c00eb71, 0x4967d037,\n    0xd53e0b33, 0xb0593075, 0x1ff07dbf, 0x7a9746f9, 0x9bd3e06a,\n    0xfeb4db2c, 0x511d96e6, 0x347aada0, 0x48e5dd81, 0x2d82e6c7,\n    0x822bab0d, 0xe74c904b, 0x060836d8, 0x636f0d9e, 0xccc64054,\n    0xa9a17b12, 0x2f04f01d, 0x4a63cb5b, 0xe5ca8691, 0x80adbdd7,\n    0x61e91b44, 0x048e2002, 0xab276dc8, 0xce40568e, 0xb2df26af,\n    0xd7b81de9, 0x78115023, 0x1d766b65, 0xfc32cdf6, 0x9955f6b0,\n    0x36fcbb7a, 0x539b803c, 0xcfc25b38, 0xaaa5607e, 0x050c2db4,\n    0x606b16f2, 0x812fb061, 0xe4488b27, 0x4be1c6ed, 0x2e86fdab,\n    0x52198d8a, 0x377eb6cc, 0x98d7fb06, 0xfdb0c040, 0x1cf466d3,\n    0x79935d95, 0xd63a105f, 0xb35d2b19, 0x6bf1402c, 0x0e967b6a,\n    0xa13f36a0, 0xc4580de6, 0x251cab75, 0x407b9033, 0xefd2ddf9,\n    0x8ab5e6bf, 0xf62a969e, 0x934dadd8, 0x3ce4e012, 0x5983db54,\n    0xb8c77dc7, 0xdda04681, 0x72090b4b, 0x176e300d, 0x8b37eb09,\n    0xee50d04f, 0x41f99d85, 0x249ea6c3, 0xc5da0050, 0xa0bd3b16,\n    0x0f1476dc, 0x6a734d9a, 0x16ec3dbb, 0x738b06fd, 0xdc224b37,\n    0xb9457071, 0x5801d6e2, 0x3d66eda4, 0x92cfa06e, 0xf7a89b28,\n    0x710d1027, 0x146a2b61, 0xbbc366ab, 0xdea45ded, 0x3fe0fb7e,\n    0x5a87c038, 0xf52e8df2, 0x9049b6b4, 0xecd6c695, 0x89b1fdd3,\n    0x2618b019, 0x437f8b5f, 0xa23b2dcc, 0xc75c168a, 0x68f55b40,\n    0x0d926006, 0x91cbbb02, 0xf4ac8044, 0x5b05cd8e, 0x3e62f6c8,\n    0xdf26505b, 0xba416b1d, 0x15e826d7, 0x708f1d91, 0x0c106db0,\n    0x697756f6, 0xc6de1b3c, 0xa3b9207a, 0x42fd86e9, 0x279abdaf,\n    0x8833f065, 0xed54cb23, 0x5e09e03a, 0x3b6edb7c, 0x94c796b6,\n    0xf1a0adf0, 0x10e40b63, 0x75833025, 0xda2a7def, 0xbf4d46a9,\n    0xc3d23688, 0xa6b50dce, 0x091c4004, 0x6c7b7b42, 0x8d3fddd1,\n    0xe858e697, 0x47f1ab5d, 0x2296901b, 0xbecf4b1f, 0xdba87059,\n    0x74013d93, 0x116606d5, 0xf022a046, 0x95459b00, 0x3aecd6ca,\n    0x5f8bed8c, 0x23149dad, 0x4673a6eb, 0xe9daeb21, 0x8cbdd067,\n    0x6df976f4, 0x089e4db2, 0xa7370078, 0xc2503b3e, 0x44f5b031,\n    0x21928b77, 0x8e3bc6bd, 0xeb5cfdfb, 0x0a185b68, 0x6f7f602e,\n    0xc0d62de4, 0xa5b116a2, 0xd92e6683, 0xbc495dc5, 0x13e0100f,\n    0x76872b49, 0x97c38dda, 0xf2a4b69c, 0x5d0dfb56, 0x386ac010,\n    0xa4331b14, 0xc1542052, 0x6efd6d98, 0x0b9a56de, 0xeadef04d,\n    0x8fb9cb0b, 0x201086c1, 0x4577bd87, 0x39e8cda6, 0x5c8ff6e0,\n    0xf326bb2a, 0x9641806c, 0x770526ff, 0x12621db9, 0xbdcb5073,\n    0xd8ac6b35},\n   {0x00000000, 0xd7e28058, 0x74b406f1, 0xa35686a9, 0xe9680de2,\n    0x3e8a8dba, 0x9ddc0b13, 0x4a3e8b4b, 0x09a11d85, 0xde439ddd,\n    0x7d151b74, 0xaaf79b2c, 0xe0c91067, 0x372b903f, 0x947d1696,\n    0x439f96ce, 0x13423b0a, 0xc4a0bb52, 0x67f63dfb, 0xb014bda3,\n    0xfa2a36e8, 0x2dc8b6b0, 0x8e9e3019, 0x597cb041, 0x1ae3268f,\n    0xcd01a6d7, 0x6e57207e, 0xb9b5a026, 0xf38b2b6d, 0x2469ab35,\n    0x873f2d9c, 0x50ddadc4, 0x26847614, 0xf166f64c, 0x523070e5,\n    0x85d2f0bd, 0xcfec7bf6, 0x180efbae, 0xbb587d07, 0x6cbafd5f,\n    0x2f256b91, 0xf8c7ebc9, 0x5b916d60, 0x8c73ed38, 0xc64d6673,\n    0x11afe62b, 0xb2f96082, 0x651be0da, 0x35c64d1e, 0xe224cd46,\n    0x41724bef, 0x9690cbb7, 0xdcae40fc, 0x0b4cc0a4, 0xa81a460d,\n    0x7ff8c655, 0x3c67509b, 0xeb85d0c3, 0x48d3566a, 0x9f31d632,\n    0xd50f5d79, 0x02eddd21, 0xa1bb5b88, 0x7659dbd0, 0x4d08ec28,\n    0x9aea6c70, 0x39bcead9, 0xee5e6a81, 0xa460e1ca, 0x73826192,\n    0xd0d4e73b, 0x07366763, 0x44a9f1ad, 0x934b71f5, 0x301df75c,\n    0xe7ff7704, 0xadc1fc4f, 0x7a237c17, 0xd975fabe, 0x0e977ae6,\n    0x5e4ad722, 0x89a8577a, 0x2afed1d3, 0xfd1c518b, 0xb722dac0,\n    0x60c05a98, 0xc396dc31, 0x14745c69, 0x57ebcaa7, 0x80094aff,\n    0x235fcc56, 0xf4bd4c0e, 0xbe83c745, 0x6961471d, 0xca37c1b4,\n    0x1dd541ec, 0x6b8c9a3c, 0xbc6e1a64, 0x1f389ccd, 0xc8da1c95,\n    0x82e497de, 0x55061786, 0xf650912f, 0x21b21177, 0x622d87b9,\n    0xb5cf07e1, 0x16998148, 0xc17b0110, 0x8b458a5b, 0x5ca70a03,\n    0xfff18caa, 0x28130cf2, 0x78cea136, 0xaf2c216e, 0x0c7aa7c7,\n    0xdb98279f, 0x91a6acd4, 0x46442c8c, 0xe512aa25, 0x32f02a7d,\n    0x716fbcb3, 0xa68d3ceb, 0x05dbba42, 0xd2393a1a, 0x9807b151,\n    0x4fe53109, 0xecb3b7a0, 0x3b5137f8, 0x9a11d850, 0x4df35808,\n    0xeea5dea1, 0x39475ef9, 0x7379d5b2, 0xa49b55ea, 0x07cdd343,\n    0xd02f531b, 0x93b0c5d5, 0x4452458d, 0xe704c324, 0x30e6437c,\n    0x7ad8c837, 0xad3a486f, 0x0e6ccec6, 0xd98e4e9e, 0x8953e35a,\n    0x5eb16302, 0xfde7e5ab, 0x2a0565f3, 0x603beeb8, 0xb7d96ee0,\n    0x148fe849, 0xc36d6811, 0x80f2fedf, 0x57107e87, 0xf446f82e,\n    0x23a47876, 0x699af33d, 0xbe787365, 0x1d2ef5cc, 0xcacc7594,\n    0xbc95ae44, 0x6b772e1c, 0xc821a8b5, 0x1fc328ed, 0x55fda3a6,\n    0x821f23fe, 0x2149a557, 0xf6ab250f, 0xb534b3c1, 0x62d63399,\n    0xc180b530, 0x16623568, 0x5c5cbe23, 0x8bbe3e7b, 0x28e8b8d2,\n    0xff0a388a, 0xafd7954e, 0x78351516, 0xdb6393bf, 0x0c8113e7,\n    0x46bf98ac, 0x915d18f4, 0x320b9e5d, 0xe5e91e05, 0xa67688cb,\n    0x71940893, 0xd2c28e3a, 0x05200e62, 0x4f1e8529, 0x98fc0571,\n    0x3baa83d8, 0xec480380, 0xd7193478, 0x00fbb420, 0xa3ad3289,\n    0x744fb2d1, 0x3e71399a, 0xe993b9c2, 0x4ac53f6b, 0x9d27bf33,\n    0xdeb829fd, 0x095aa9a5, 0xaa0c2f0c, 0x7deeaf54, 0x37d0241f,\n    0xe032a447, 0x436422ee, 0x9486a2b6, 0xc45b0f72, 0x13b98f2a,\n    0xb0ef0983, 0x670d89db, 0x2d330290, 0xfad182c8, 0x59870461,\n    0x8e658439, 0xcdfa12f7, 0x1a1892af, 0xb94e1406, 0x6eac945e,\n    0x24921f15, 0xf3709f4d, 0x502619e4, 0x87c499bc, 0xf19d426c,\n    0x267fc234, 0x8529449d, 0x52cbc4c5, 0x18f54f8e, 0xcf17cfd6,\n    0x6c41497f, 0xbba3c927, 0xf83c5fe9, 0x2fdedfb1, 0x8c885918,\n    0x5b6ad940, 0x1154520b, 0xc6b6d253, 0x65e054fa, 0xb202d4a2,\n    0xe2df7966, 0x353df93e, 0x966b7f97, 0x4189ffcf, 0x0bb77484,\n    0xdc55f4dc, 0x7f037275, 0xa8e1f22d, 0xeb7e64e3, 0x3c9ce4bb,\n    0x9fca6212, 0x4828e24a, 0x02166901, 0xd5f4e959, 0x76a26ff0,\n    0xa140efa8},\n   {0x00000000, 0xef52b6e1, 0x05d46b83, 0xea86dd62, 0x0ba8d706,\n    0xe4fa61e7, 0x0e7cbc85, 0xe12e0a64, 0x1751ae0c, 0xf80318ed,\n    0x1285c58f, 0xfdd7736e, 0x1cf9790a, 0xf3abcfeb, 0x192d1289,\n    0xf67fa468, 0x2ea35c18, 0xc1f1eaf9, 0x2b77379b, 0xc425817a,\n    0x250b8b1e, 0xca593dff, 0x20dfe09d, 0xcf8d567c, 0x39f2f214,\n    0xd6a044f5, 0x3c269997, 0xd3742f76, 0x325a2512, 0xdd0893f3,\n    0x378e4e91, 0xd8dcf870, 0x5d46b830, 0xb2140ed1, 0x5892d3b3,\n    0xb7c06552, 0x56ee6f36, 0xb9bcd9d7, 0x533a04b5, 0xbc68b254,\n    0x4a17163c, 0xa545a0dd, 0x4fc37dbf, 0xa091cb5e, 0x41bfc13a,\n    0xaeed77db, 0x446baab9, 0xab391c58, 0x73e5e428, 0x9cb752c9,\n    0x76318fab, 0x9963394a, 0x784d332e, 0x971f85cf, 0x7d9958ad,\n    0x92cbee4c, 0x64b44a24, 0x8be6fcc5, 0x616021a7, 0x8e329746,\n    0x6f1c9d22, 0x804e2bc3, 0x6ac8f6a1, 0x859a4040, 0xba8d7060,\n    0x55dfc681, 0xbf591be3, 0x500bad02, 0xb125a766, 0x5e771187,\n    0xb4f1cce5, 0x5ba37a04, 0xaddcde6c, 0x428e688d, 0xa808b5ef,\n    0x475a030e, 0xa674096a, 0x4926bf8b, 0xa3a062e9, 0x4cf2d408,\n    0x942e2c78, 0x7b7c9a99, 0x91fa47fb, 0x7ea8f11a, 0x9f86fb7e,\n    0x70d44d9f, 0x9a5290fd, 0x7500261c, 0x837f8274, 0x6c2d3495,\n    0x86abe9f7, 0x69f95f16, 0x88d75572, 0x6785e393, 0x8d033ef1,\n    0x62518810, 0xe7cbc850, 0x08997eb1, 0xe21fa3d3, 0x0d4d1532,\n    0xec631f56, 0x0331a9b7, 0xe9b774d5, 0x06e5c234, 0xf09a665c,\n    0x1fc8d0bd, 0xf54e0ddf, 0x1a1cbb3e, 0xfb32b15a, 0x146007bb,\n    0xfee6dad9, 0x11b46c38, 0xc9689448, 0x263a22a9, 0xccbcffcb,\n    0x23ee492a, 0xc2c0434e, 0x2d92f5af, 0xc71428cd, 0x28469e2c,\n    0xde393a44, 0x316b8ca5, 0xdbed51c7, 0x34bfe726, 0xd591ed42,\n    0x3ac35ba3, 0xd04586c1, 0x3f173020, 0xae6be681, 0x41395060,\n    0xabbf8d02, 0x44ed3be3, 0xa5c33187, 0x4a918766, 0xa0175a04,\n    0x4f45ece5, 0xb93a488d, 0x5668fe6c, 0xbcee230e, 0x53bc95ef,\n    0xb2929f8b, 0x5dc0296a, 0xb746f408, 0x581442e9, 0x80c8ba99,\n    0x6f9a0c78, 0x851cd11a, 0x6a4e67fb, 0x8b606d9f, 0x6432db7e,\n    0x8eb4061c, 0x61e6b0fd, 0x97991495, 0x78cba274, 0x924d7f16,\n    0x7d1fc9f7, 0x9c31c393, 0x73637572, 0x99e5a810, 0x76b71ef1,\n    0xf32d5eb1, 0x1c7fe850, 0xf6f93532, 0x19ab83d3, 0xf88589b7,\n    0x17d73f56, 0xfd51e234, 0x120354d5, 0xe47cf0bd, 0x0b2e465c,\n    0xe1a89b3e, 0x0efa2ddf, 0xefd427bb, 0x0086915a, 0xea004c38,\n    0x0552fad9, 0xdd8e02a9, 0x32dcb448, 0xd85a692a, 0x3708dfcb,\n    0xd626d5af, 0x3974634e, 0xd3f2be2c, 0x3ca008cd, 0xcadfaca5,\n    0x258d1a44, 0xcf0bc726, 0x205971c7, 0xc1777ba3, 0x2e25cd42,\n    0xc4a31020, 0x2bf1a6c1, 0x14e696e1, 0xfbb42000, 0x1132fd62,\n    0xfe604b83, 0x1f4e41e7, 0xf01cf706, 0x1a9a2a64, 0xf5c89c85,\n    0x03b738ed, 0xece58e0c, 0x0663536e, 0xe931e58f, 0x081fefeb,\n    0xe74d590a, 0x0dcb8468, 0xe2993289, 0x3a45caf9, 0xd5177c18,\n    0x3f91a17a, 0xd0c3179b, 0x31ed1dff, 0xdebfab1e, 0x3439767c,\n    0xdb6bc09d, 0x2d1464f5, 0xc246d214, 0x28c00f76, 0xc792b997,\n    0x26bcb3f3, 0xc9ee0512, 0x2368d870, 0xcc3a6e91, 0x49a02ed1,\n    0xa6f29830, 0x4c744552, 0xa326f3b3, 0x4208f9d7, 0xad5a4f36,\n    0x47dc9254, 0xa88e24b5, 0x5ef180dd, 0xb1a3363c, 0x5b25eb5e,\n    0xb4775dbf, 0x555957db, 0xba0be13a, 0x508d3c58, 0xbfdf8ab9,\n    0x670372c9, 0x8851c428, 0x62d7194a, 0x8d85afab, 0x6caba5cf,\n    0x83f9132e, 0x697fce4c, 0x862d78ad, 0x7052dcc5, 0x9f006a24,\n    0x7586b746, 0x9ad401a7, 0x7bfa0bc3, 0x94a8bd22, 0x7e2e6040,\n    0x917cd6a1},\n   {0x00000000, 0x87a6cb43, 0xd43c90c7, 0x539a5b84, 0x730827cf,\n    0xf4aeec8c, 0xa734b708, 0x20927c4b, 0xe6104f9e, 0x61b684dd,\n    0x322cdf59, 0xb58a141a, 0x95186851, 0x12bea312, 0x4124f896,\n    0xc68233d5, 0x1751997d, 0x90f7523e, 0xc36d09ba, 0x44cbc2f9,\n    0x6459beb2, 0xe3ff75f1, 0xb0652e75, 0x37c3e536, 0xf141d6e3,\n    0x76e71da0, 0x257d4624, 0xa2db8d67, 0x8249f12c, 0x05ef3a6f,\n    0x567561eb, 0xd1d3aaa8, 0x2ea332fa, 0xa905f9b9, 0xfa9fa23d,\n    0x7d39697e, 0x5dab1535, 0xda0dde76, 0x899785f2, 0x0e314eb1,\n    0xc8b37d64, 0x4f15b627, 0x1c8feda3, 0x9b2926e0, 0xbbbb5aab,\n    0x3c1d91e8, 0x6f87ca6c, 0xe821012f, 0x39f2ab87, 0xbe5460c4,\n    0xedce3b40, 0x6a68f003, 0x4afa8c48, 0xcd5c470b, 0x9ec61c8f,\n    0x1960d7cc, 0xdfe2e419, 0x58442f5a, 0x0bde74de, 0x8c78bf9d,\n    0xaceac3d6, 0x2b4c0895, 0x78d65311, 0xff709852, 0x5d4665f4,\n    0xdae0aeb7, 0x897af533, 0x0edc3e70, 0x2e4e423b, 0xa9e88978,\n    0xfa72d2fc, 0x7dd419bf, 0xbb562a6a, 0x3cf0e129, 0x6f6abaad,\n    0xe8cc71ee, 0xc85e0da5, 0x4ff8c6e6, 0x1c629d62, 0x9bc45621,\n    0x4a17fc89, 0xcdb137ca, 0x9e2b6c4e, 0x198da70d, 0x391fdb46,\n    0xbeb91005, 0xed234b81, 0x6a8580c2, 0xac07b317, 0x2ba17854,\n    0x783b23d0, 0xff9de893, 0xdf0f94d8, 0x58a95f9b, 0x0b33041f,\n    0x8c95cf5c, 0x73e5570e, 0xf4439c4d, 0xa7d9c7c9, 0x207f0c8a,\n    0x00ed70c1, 0x874bbb82, 0xd4d1e006, 0x53772b45, 0x95f51890,\n    0x1253d3d3, 0x41c98857, 0xc66f4314, 0xe6fd3f5f, 0x615bf41c,\n    0x32c1af98, 0xb56764db, 0x64b4ce73, 0xe3120530, 0xb0885eb4,\n    0x372e95f7, 0x17bce9bc, 0x901a22ff, 0xc380797b, 0x4426b238,\n    0x82a481ed, 0x05024aae, 0x5698112a, 0xd13eda69, 0xf1aca622,\n    0x760a6d61, 0x259036e5, 0xa236fda6, 0xba8ccbe8, 0x3d2a00ab,\n    0x6eb05b2f, 0xe916906c, 0xc984ec27, 0x4e222764, 0x1db87ce0,\n    0x9a1eb7a3, 0x5c9c8476, 0xdb3a4f35, 0x88a014b1, 0x0f06dff2,\n    0x2f94a3b9, 0xa83268fa, 0xfba8337e, 0x7c0ef83d, 0xaddd5295,\n    0x2a7b99d6, 0x79e1c252, 0xfe470911, 0xded5755a, 0x5973be19,\n    0x0ae9e59d, 0x8d4f2ede, 0x4bcd1d0b, 0xcc6bd648, 0x9ff18dcc,\n    0x1857468f, 0x38c53ac4, 0xbf63f187, 0xecf9aa03, 0x6b5f6140,\n    0x942ff912, 0x13893251, 0x401369d5, 0xc7b5a296, 0xe727dedd,\n    0x6081159e, 0x331b4e1a, 0xb4bd8559, 0x723fb68c, 0xf5997dcf,\n    0xa603264b, 0x21a5ed08, 0x01379143, 0x86915a00, 0xd50b0184,\n    0x52adcac7, 0x837e606f, 0x04d8ab2c, 0x5742f0a8, 0xd0e43beb,\n    0xf07647a0, 0x77d08ce3, 0x244ad767, 0xa3ec1c24, 0x656e2ff1,\n    0xe2c8e4b2, 0xb152bf36, 0x36f47475, 0x1666083e, 0x91c0c37d,\n    0xc25a98f9, 0x45fc53ba, 0xe7caae1c, 0x606c655f, 0x33f63edb,\n    0xb450f598, 0x94c289d3, 0x13644290, 0x40fe1914, 0xc758d257,\n    0x01dae182, 0x867c2ac1, 0xd5e67145, 0x5240ba06, 0x72d2c64d,\n    0xf5740d0e, 0xa6ee568a, 0x21489dc9, 0xf09b3761, 0x773dfc22,\n    0x24a7a7a6, 0xa3016ce5, 0x839310ae, 0x0435dbed, 0x57af8069,\n    0xd0094b2a, 0x168b78ff, 0x912db3bc, 0xc2b7e838, 0x4511237b,\n    0x65835f30, 0xe2259473, 0xb1bfcff7, 0x361904b4, 0xc9699ce6,\n    0x4ecf57a5, 0x1d550c21, 0x9af3c762, 0xba61bb29, 0x3dc7706a,\n    0x6e5d2bee, 0xe9fbe0ad, 0x2f79d378, 0xa8df183b, 0xfb4543bf,\n    0x7ce388fc, 0x5c71f4b7, 0xdbd73ff4, 0x884d6470, 0x0febaf33,\n    0xde38059b, 0x599eced8, 0x0a04955c, 0x8da25e1f, 0xad302254,\n    0x2a96e917, 0x790cb293, 0xfeaa79d0, 0x38284a05, 0xbf8e8146,\n    0xec14dac2, 0x6bb21181, 0x4b206dca, 0xcc86a689, 0x9f1cfd0d,\n    0x18ba364e}};\n\nlocal const z_word_t FAR crc_braid_big_table[][256] = {\n   {0x00000000, 0x43cba687, 0xc7903cd4, 0x845b9a53, 0xcf270873,\n    0x8cecaef4, 0x08b734a7, 0x4b7c9220, 0x9e4f10e6, 0xdd84b661,\n    0x59df2c32, 0x1a148ab5, 0x51681895, 0x12a3be12, 0x96f82441,\n    0xd53382c6, 0x7d995117, 0x3e52f790, 0xba096dc3, 0xf9c2cb44,\n    0xb2be5964, 0xf175ffe3, 0x752e65b0, 0x36e5c337, 0xe3d641f1,\n    0xa01de776, 0x24467d25, 0x678ddba2, 0x2cf14982, 0x6f3aef05,\n    0xeb617556, 0xa8aad3d1, 0xfa32a32e, 0xb9f905a9, 0x3da29ffa,\n    0x7e69397d, 0x3515ab5d, 0x76de0dda, 0xf2859789, 0xb14e310e,\n    0x647db3c8, 0x27b6154f, 0xa3ed8f1c, 0xe026299b, 0xab5abbbb,\n    0xe8911d3c, 0x6cca876f, 0x2f0121e8, 0x87abf239, 0xc46054be,\n    0x403bceed, 0x03f0686a, 0x488cfa4a, 0x0b475ccd, 0x8f1cc69e,\n    0xccd76019, 0x19e4e2df, 0x5a2f4458, 0xde74de0b, 0x9dbf788c,\n    0xd6c3eaac, 0x95084c2b, 0x1153d678, 0x529870ff, 0xf465465d,\n    0xb7aee0da, 0x33f57a89, 0x703edc0e, 0x3b424e2e, 0x7889e8a9,\n    0xfcd272fa, 0xbf19d47d, 0x6a2a56bb, 0x29e1f03c, 0xadba6a6f,\n    0xee71cce8, 0xa50d5ec8, 0xe6c6f84f, 0x629d621c, 0x2156c49b,\n    0x89fc174a, 0xca37b1cd, 0x4e6c2b9e, 0x0da78d19, 0x46db1f39,\n    0x0510b9be, 0x814b23ed, 0xc280856a, 0x17b307ac, 0x5478a12b,\n    0xd0233b78, 0x93e89dff, 0xd8940fdf, 0x9b5fa958, 0x1f04330b,\n    0x5ccf958c, 0x0e57e573, 0x4d9c43f4, 0xc9c7d9a7, 0x8a0c7f20,\n    0xc170ed00, 0x82bb4b87, 0x06e0d1d4, 0x452b7753, 0x9018f595,\n    0xd3d35312, 0x5788c941, 0x14436fc6, 0x5f3ffde6, 0x1cf45b61,\n    0x98afc132, 0xdb6467b5, 0x73ceb464, 0x300512e3, 0xb45e88b0,\n    0xf7952e37, 0xbce9bc17, 0xff221a90, 0x7b7980c3, 0x38b22644,\n    0xed81a482, 0xae4a0205, 0x2a119856, 0x69da3ed1, 0x22a6acf1,\n    0x616d0a76, 0xe5369025, 0xa6fd36a2, 0xe8cb8cba, 0xab002a3d,\n    0x2f5bb06e, 0x6c9016e9, 0x27ec84c9, 0x6427224e, 0xe07cb81d,\n    0xa3b71e9a, 0x76849c5c, 0x354f3adb, 0xb114a088, 0xf2df060f,\n    0xb9a3942f, 0xfa6832a8, 0x7e33a8fb, 0x3df80e7c, 0x9552ddad,\n    0xd6997b2a, 0x52c2e179, 0x110947fe, 0x5a75d5de, 0x19be7359,\n    0x9de5e90a, 0xde2e4f8d, 0x0b1dcd4b, 0x48d66bcc, 0xcc8df19f,\n    0x8f465718, 0xc43ac538, 0x87f163bf, 0x03aaf9ec, 0x40615f6b,\n    0x12f92f94, 0x51328913, 0xd5691340, 0x96a2b5c7, 0xddde27e7,\n    0x9e158160, 0x1a4e1b33, 0x5985bdb4, 0x8cb63f72, 0xcf7d99f5,\n    0x4b2603a6, 0x08eda521, 0x43913701, 0x005a9186, 0x84010bd5,\n    0xc7caad52, 0x6f607e83, 0x2cabd804, 0xa8f04257, 0xeb3be4d0,\n    0xa04776f0, 0xe38cd077, 0x67d74a24, 0x241ceca3, 0xf12f6e65,\n    0xb2e4c8e2, 0x36bf52b1, 0x7574f436, 0x3e086616, 0x7dc3c091,\n    0xf9985ac2, 0xba53fc45, 0x1caecae7, 0x5f656c60, 0xdb3ef633,\n    0x98f550b4, 0xd389c294, 0x90426413, 0x1419fe40, 0x57d258c7,\n    0x82e1da01, 0xc12a7c86, 0x4571e6d5, 0x06ba4052, 0x4dc6d272,\n    0x0e0d74f5, 0x8a56eea6, 0xc99d4821, 0x61379bf0, 0x22fc3d77,\n    0xa6a7a724, 0xe56c01a3, 0xae109383, 0xeddb3504, 0x6980af57,\n    0x2a4b09d0, 0xff788b16, 0xbcb32d91, 0x38e8b7c2, 0x7b231145,\n    0x305f8365, 0x739425e2, 0xf7cfbfb1, 0xb4041936, 0xe69c69c9,\n    0xa557cf4e, 0x210c551d, 0x62c7f39a, 0x29bb61ba, 0x6a70c73d,\n    0xee2b5d6e, 0xade0fbe9, 0x78d3792f, 0x3b18dfa8, 0xbf4345fb,\n    0xfc88e37c, 0xb7f4715c, 0xf43fd7db, 0x70644d88, 0x33afeb0f,\n    0x9b0538de, 0xd8ce9e59, 0x5c95040a, 0x1f5ea28d, 0x542230ad,\n    0x17e9962a, 0x93b20c79, 0xd079aafe, 0x054a2838, 0x46818ebf,\n    0xc2da14ec, 0x8111b26b, 0xca6d204b, 0x89a686cc, 0x0dfd1c9f,\n    0x4e36ba18},\n   {0x00000000, 0xe1b652ef, 0x836bd405, 0x62dd86ea, 0x06d7a80b,\n    0xe761fae4, 0x85bc7c0e, 0x640a2ee1, 0x0cae5117, 0xed1803f8,\n    0x8fc58512, 0x6e73d7fd, 0x0a79f91c, 0xebcfabf3, 0x89122d19,\n    0x68a47ff6, 0x185ca32e, 0xf9eaf1c1, 0x9b37772b, 0x7a8125c4,\n    0x1e8b0b25, 0xff3d59ca, 0x9de0df20, 0x7c568dcf, 0x14f2f239,\n    0xf544a0d6, 0x9799263c, 0x762f74d3, 0x12255a32, 0xf39308dd,\n    0x914e8e37, 0x70f8dcd8, 0x30b8465d, 0xd10e14b2, 0xb3d39258,\n    0x5265c0b7, 0x366fee56, 0xd7d9bcb9, 0xb5043a53, 0x54b268bc,\n    0x3c16174a, 0xdda045a5, 0xbf7dc34f, 0x5ecb91a0, 0x3ac1bf41,\n    0xdb77edae, 0xb9aa6b44, 0x581c39ab, 0x28e4e573, 0xc952b79c,\n    0xab8f3176, 0x4a396399, 0x2e334d78, 0xcf851f97, 0xad58997d,\n    0x4ceecb92, 0x244ab464, 0xc5fce68b, 0xa7216061, 0x4697328e,\n    0x229d1c6f, 0xc32b4e80, 0xa1f6c86a, 0x40409a85, 0x60708dba,\n    0x81c6df55, 0xe31b59bf, 0x02ad0b50, 0x66a725b1, 0x8711775e,\n    0xe5ccf1b4, 0x047aa35b, 0x6cdedcad, 0x8d688e42, 0xefb508a8,\n    0x0e035a47, 0x6a0974a6, 0x8bbf2649, 0xe962a0a3, 0x08d4f24c,\n    0x782c2e94, 0x999a7c7b, 0xfb47fa91, 0x1af1a87e, 0x7efb869f,\n    0x9f4dd470, 0xfd90529a, 0x1c260075, 0x74827f83, 0x95342d6c,\n    0xf7e9ab86, 0x165ff969, 0x7255d788, 0x93e38567, 0xf13e038d,\n    0x10885162, 0x50c8cbe7, 0xb17e9908, 0xd3a31fe2, 0x32154d0d,\n    0x561f63ec, 0xb7a93103, 0xd574b7e9, 0x34c2e506, 0x5c669af0,\n    0xbdd0c81f, 0xdf0d4ef5, 0x3ebb1c1a, 0x5ab132fb, 0xbb076014,\n    0xd9dae6fe, 0x386cb411, 0x489468c9, 0xa9223a26, 0xcbffbccc,\n    0x2a49ee23, 0x4e43c0c2, 0xaff5922d, 0xcd2814c7, 0x2c9e4628,\n    0x443a39de, 0xa58c6b31, 0xc751eddb, 0x26e7bf34, 0x42ed91d5,\n    0xa35bc33a, 0xc18645d0, 0x2030173f, 0x81e66bae, 0x60503941,\n    0x028dbfab, 0xe33bed44, 0x8731c3a5, 0x6687914a, 0x045a17a0,\n    0xe5ec454f, 0x8d483ab9, 0x6cfe6856, 0x0e23eebc, 0xef95bc53,\n    0x8b9f92b2, 0x6a29c05d, 0x08f446b7, 0xe9421458, 0x99bac880,\n    0x780c9a6f, 0x1ad11c85, 0xfb674e6a, 0x9f6d608b, 0x7edb3264,\n    0x1c06b48e, 0xfdb0e661, 0x95149997, 0x74a2cb78, 0x167f4d92,\n    0xf7c91f7d, 0x93c3319c, 0x72756373, 0x10a8e599, 0xf11eb776,\n    0xb15e2df3, 0x50e87f1c, 0x3235f9f6, 0xd383ab19, 0xb78985f8,\n    0x563fd717, 0x34e251fd, 0xd5540312, 0xbdf07ce4, 0x5c462e0b,\n    0x3e9ba8e1, 0xdf2dfa0e, 0xbb27d4ef, 0x5a918600, 0x384c00ea,\n    0xd9fa5205, 0xa9028edd, 0x48b4dc32, 0x2a695ad8, 0xcbdf0837,\n    0xafd526d6, 0x4e637439, 0x2cbef2d3, 0xcd08a03c, 0xa5acdfca,\n    0x441a8d25, 0x26c70bcf, 0xc7715920, 0xa37b77c1, 0x42cd252e,\n    0x2010a3c4, 0xc1a6f12b, 0xe196e614, 0x0020b4fb, 0x62fd3211,\n    0x834b60fe, 0xe7414e1f, 0x06f71cf0, 0x642a9a1a, 0x859cc8f5,\n    0xed38b703, 0x0c8ee5ec, 0x6e536306, 0x8fe531e9, 0xebef1f08,\n    0x0a594de7, 0x6884cb0d, 0x893299e2, 0xf9ca453a, 0x187c17d5,\n    0x7aa1913f, 0x9b17c3d0, 0xff1ded31, 0x1eabbfde, 0x7c763934,\n    0x9dc06bdb, 0xf564142d, 0x14d246c2, 0x760fc028, 0x97b992c7,\n    0xf3b3bc26, 0x1205eec9, 0x70d86823, 0x916e3acc, 0xd12ea049,\n    0x3098f2a6, 0x5245744c, 0xb3f326a3, 0xd7f90842, 0x364f5aad,\n    0x5492dc47, 0xb5248ea8, 0xdd80f15e, 0x3c36a3b1, 0x5eeb255b,\n    0xbf5d77b4, 0xdb575955, 0x3ae10bba, 0x583c8d50, 0xb98adfbf,\n    0xc9720367, 0x28c45188, 0x4a19d762, 0xabaf858d, 0xcfa5ab6c,\n    0x2e13f983, 0x4cce7f69, 0xad782d86, 0xc5dc5270, 0x246a009f,\n    0x46b78675, 0xa701d49a, 0xc30bfa7b, 0x22bda894, 0x40602e7e,\n    0xa1d67c91},\n   {0x00000000, 0x5880e2d7, 0xf106b474, 0xa98656a3, 0xe20d68e9,\n    0xba8d8a3e, 0x130bdc9d, 0x4b8b3e4a, 0x851da109, 0xdd9d43de,\n    0x741b157d, 0x2c9bf7aa, 0x6710c9e0, 0x3f902b37, 0x96167d94,\n    0xce969f43, 0x0a3b4213, 0x52bba0c4, 0xfb3df667, 0xa3bd14b0,\n    0xe8362afa, 0xb0b6c82d, 0x19309e8e, 0x41b07c59, 0x8f26e31a,\n    0xd7a601cd, 0x7e20576e, 0x26a0b5b9, 0x6d2b8bf3, 0x35ab6924,\n    0x9c2d3f87, 0xc4addd50, 0x14768426, 0x4cf666f1, 0xe5703052,\n    0xbdf0d285, 0xf67beccf, 0xaefb0e18, 0x077d58bb, 0x5ffdba6c,\n    0x916b252f, 0xc9ebc7f8, 0x606d915b, 0x38ed738c, 0x73664dc6,\n    0x2be6af11, 0x8260f9b2, 0xdae01b65, 0x1e4dc635, 0x46cd24e2,\n    0xef4b7241, 0xb7cb9096, 0xfc40aedc, 0xa4c04c0b, 0x0d461aa8,\n    0x55c6f87f, 0x9b50673c, 0xc3d085eb, 0x6a56d348, 0x32d6319f,\n    0x795d0fd5, 0x21dded02, 0x885bbba1, 0xd0db5976, 0x28ec084d,\n    0x706cea9a, 0xd9eabc39, 0x816a5eee, 0xcae160a4, 0x92618273,\n    0x3be7d4d0, 0x63673607, 0xadf1a944, 0xf5714b93, 0x5cf71d30,\n    0x0477ffe7, 0x4ffcc1ad, 0x177c237a, 0xbefa75d9, 0xe67a970e,\n    0x22d74a5e, 0x7a57a889, 0xd3d1fe2a, 0x8b511cfd, 0xc0da22b7,\n    0x985ac060, 0x31dc96c3, 0x695c7414, 0xa7caeb57, 0xff4a0980,\n    0x56cc5f23, 0x0e4cbdf4, 0x45c783be, 0x1d476169, 0xb4c137ca,\n    0xec41d51d, 0x3c9a8c6b, 0x641a6ebc, 0xcd9c381f, 0x951cdac8,\n    0xde97e482, 0x86170655, 0x2f9150f6, 0x7711b221, 0xb9872d62,\n    0xe107cfb5, 0x48819916, 0x10017bc1, 0x5b8a458b, 0x030aa75c,\n    0xaa8cf1ff, 0xf20c1328, 0x36a1ce78, 0x6e212caf, 0xc7a77a0c,\n    0x9f2798db, 0xd4aca691, 0x8c2c4446, 0x25aa12e5, 0x7d2af032,\n    0xb3bc6f71, 0xeb3c8da6, 0x42badb05, 0x1a3a39d2, 0x51b10798,\n    0x0931e54f, 0xa0b7b3ec, 0xf837513b, 0x50d8119a, 0x0858f34d,\n    0xa1dea5ee, 0xf95e4739, 0xb2d57973, 0xea559ba4, 0x43d3cd07,\n    0x1b532fd0, 0xd5c5b093, 0x8d455244, 0x24c304e7, 0x7c43e630,\n    0x37c8d87a, 0x6f483aad, 0xc6ce6c0e, 0x9e4e8ed9, 0x5ae35389,\n    0x0263b15e, 0xabe5e7fd, 0xf365052a, 0xb8ee3b60, 0xe06ed9b7,\n    0x49e88f14, 0x11686dc3, 0xdffef280, 0x877e1057, 0x2ef846f4,\n    0x7678a423, 0x3df39a69, 0x657378be, 0xccf52e1d, 0x9475ccca,\n    0x44ae95bc, 0x1c2e776b, 0xb5a821c8, 0xed28c31f, 0xa6a3fd55,\n    0xfe231f82, 0x57a54921, 0x0f25abf6, 0xc1b334b5, 0x9933d662,\n    0x30b580c1, 0x68356216, 0x23be5c5c, 0x7b3ebe8b, 0xd2b8e828,\n    0x8a380aff, 0x4e95d7af, 0x16153578, 0xbf9363db, 0xe713810c,\n    0xac98bf46, 0xf4185d91, 0x5d9e0b32, 0x051ee9e5, 0xcb8876a6,\n    0x93089471, 0x3a8ec2d2, 0x620e2005, 0x29851e4f, 0x7105fc98,\n    0xd883aa3b, 0x800348ec, 0x783419d7, 0x20b4fb00, 0x8932ada3,\n    0xd1b24f74, 0x9a39713e, 0xc2b993e9, 0x6b3fc54a, 0x33bf279d,\n    0xfd29b8de, 0xa5a95a09, 0x0c2f0caa, 0x54afee7d, 0x1f24d037,\n    0x47a432e0, 0xee226443, 0xb6a28694, 0x720f5bc4, 0x2a8fb913,\n    0x8309efb0, 0xdb890d67, 0x9002332d, 0xc882d1fa, 0x61048759,\n    0x3984658e, 0xf712facd, 0xaf92181a, 0x06144eb9, 0x5e94ac6e,\n    0x151f9224, 0x4d9f70f3, 0xe4192650, 0xbc99c487, 0x6c429df1,\n    0x34c27f26, 0x9d442985, 0xc5c4cb52, 0x8e4ff518, 0xd6cf17cf,\n    0x7f49416c, 0x27c9a3bb, 0xe95f3cf8, 0xb1dfde2f, 0x1859888c,\n    0x40d96a5b, 0x0b525411, 0x53d2b6c6, 0xfa54e065, 0xa2d402b2,\n    0x6679dfe2, 0x3ef93d35, 0x977f6b96, 0xcfff8941, 0x8474b70b,\n    0xdcf455dc, 0x7572037f, 0x2df2e1a8, 0xe3647eeb, 0xbbe49c3c,\n    0x1262ca9f, 0x4ae22848, 0x01691602, 0x59e9f4d5, 0xf06fa276,\n    0xa8ef40a1},\n   {0x00000000, 0x463b6765, 0x8c76ceca, 0xca4da9af, 0x59ebed4e,\n    0x1fd08a2b, 0xd59d2384, 0x93a644e1, 0xb2d6db9d, 0xf4edbcf8,\n    0x3ea01557, 0x789b7232, 0xeb3d36d3, 0xad0651b6, 0x674bf819,\n    0x21709f7c, 0x25abc6e0, 0x6390a185, 0xa9dd082a, 0xefe66f4f,\n    0x7c402bae, 0x3a7b4ccb, 0xf036e564, 0xb60d8201, 0x977d1d7d,\n    0xd1467a18, 0x1b0bd3b7, 0x5d30b4d2, 0xce96f033, 0x88ad9756,\n    0x42e03ef9, 0x04db599c, 0x0b50fc1a, 0x4d6b9b7f, 0x872632d0,\n    0xc11d55b5, 0x52bb1154, 0x14807631, 0xdecddf9e, 0x98f6b8fb,\n    0xb9862787, 0xffbd40e2, 0x35f0e94d, 0x73cb8e28, 0xe06dcac9,\n    0xa656adac, 0x6c1b0403, 0x2a206366, 0x2efb3afa, 0x68c05d9f,\n    0xa28df430, 0xe4b69355, 0x7710d7b4, 0x312bb0d1, 0xfb66197e,\n    0xbd5d7e1b, 0x9c2de167, 0xda168602, 0x105b2fad, 0x566048c8,\n    0xc5c60c29, 0x83fd6b4c, 0x49b0c2e3, 0x0f8ba586, 0x16a0f835,\n    0x509b9f50, 0x9ad636ff, 0xdced519a, 0x4f4b157b, 0x0970721e,\n    0xc33ddbb1, 0x8506bcd4, 0xa47623a8, 0xe24d44cd, 0x2800ed62,\n    0x6e3b8a07, 0xfd9dcee6, 0xbba6a983, 0x71eb002c, 0x37d06749,\n    0x330b3ed5, 0x753059b0, 0xbf7df01f, 0xf946977a, 0x6ae0d39b,\n    0x2cdbb4fe, 0xe6961d51, 0xa0ad7a34, 0x81dde548, 0xc7e6822d,\n    0x0dab2b82, 0x4b904ce7, 0xd8360806, 0x9e0d6f63, 0x5440c6cc,\n    0x127ba1a9, 0x1df0042f, 0x5bcb634a, 0x9186cae5, 0xd7bdad80,\n    0x441be961, 0x02208e04, 0xc86d27ab, 0x8e5640ce, 0xaf26dfb2,\n    0xe91db8d7, 0x23501178, 0x656b761d, 0xf6cd32fc, 0xb0f65599,\n    0x7abbfc36, 0x3c809b53, 0x385bc2cf, 0x7e60a5aa, 0xb42d0c05,\n    0xf2166b60, 0x61b02f81, 0x278b48e4, 0xedc6e14b, 0xabfd862e,\n    0x8a8d1952, 0xccb67e37, 0x06fbd798, 0x40c0b0fd, 0xd366f41c,\n    0x955d9379, 0x5f103ad6, 0x192b5db3, 0x2c40f16b, 0x6a7b960e,\n    0xa0363fa1, 0xe60d58c4, 0x75ab1c25, 0x33907b40, 0xf9ddd2ef,\n    0xbfe6b58a, 0x9e962af6, 0xd8ad4d93, 0x12e0e43c, 0x54db8359,\n    0xc77dc7b8, 0x8146a0dd, 0x4b0b0972, 0x0d306e17, 0x09eb378b,\n    0x4fd050ee, 0x859df941, 0xc3a69e24, 0x5000dac5, 0x163bbda0,\n    0xdc76140f, 0x9a4d736a, 0xbb3dec16, 0xfd068b73, 0x374b22dc,\n    0x717045b9, 0xe2d60158, 0xa4ed663d, 0x6ea0cf92, 0x289ba8f7,\n    0x27100d71, 0x612b6a14, 0xab66c3bb, 0xed5da4de, 0x7efbe03f,\n    0x38c0875a, 0xf28d2ef5, 0xb4b64990, 0x95c6d6ec, 0xd3fdb189,\n    0x19b01826, 0x5f8b7f43, 0xcc2d3ba2, 0x8a165cc7, 0x405bf568,\n    0x0660920d, 0x02bbcb91, 0x4480acf4, 0x8ecd055b, 0xc8f6623e,\n    0x5b5026df, 0x1d6b41ba, 0xd726e815, 0x911d8f70, 0xb06d100c,\n    0xf6567769, 0x3c1bdec6, 0x7a20b9a3, 0xe986fd42, 0xafbd9a27,\n    0x65f03388, 0x23cb54ed, 0x3ae0095e, 0x7cdb6e3b, 0xb696c794,\n    0xf0ada0f1, 0x630be410, 0x25308375, 0xef7d2ada, 0xa9464dbf,\n    0x8836d2c3, 0xce0db5a6, 0x04401c09, 0x427b7b6c, 0xd1dd3f8d,\n    0x97e658e8, 0x5dabf147, 0x1b909622, 0x1f4bcfbe, 0x5970a8db,\n    0x933d0174, 0xd5066611, 0x46a022f0, 0x009b4595, 0xcad6ec3a,\n    0x8ced8b5f, 0xad9d1423, 0xeba67346, 0x21ebdae9, 0x67d0bd8c,\n    0xf476f96d, 0xb24d9e08, 0x780037a7, 0x3e3b50c2, 0x31b0f544,\n    0x778b9221, 0xbdc63b8e, 0xfbfd5ceb, 0x685b180a, 0x2e607f6f,\n    0xe42dd6c0, 0xa216b1a5, 0x83662ed9, 0xc55d49bc, 0x0f10e013,\n    0x492b8776, 0xda8dc397, 0x9cb6a4f2, 0x56fb0d5d, 0x10c06a38,\n    0x141b33a4, 0x522054c1, 0x986dfd6e, 0xde569a0b, 0x4df0deea,\n    0x0bcbb98f, 0xc1861020, 0x87bd7745, 0xa6cde839, 0xe0f68f5c,\n    0x2abb26f3, 0x6c804196, 0xff260577, 0xb91d6212, 0x7350cbbd,\n    0x356bacd8}};\n\n#endif\n\n#endif\n\n#if N == 6\n\n#if W == 8\n\nlocal const z_crc_t FAR crc_braid_table[][256] = {\n   {0x00000000, 0x3db1ecdc, 0x7b63d9b8, 0x46d23564, 0xf6c7b370,\n    0xcb765fac, 0x8da46ac8, 0xb0158614, 0x36fe60a1, 0x0b4f8c7d,\n    0x4d9db919, 0x702c55c5, 0xc039d3d1, 0xfd883f0d, 0xbb5a0a69,\n    0x86ebe6b5, 0x6dfcc142, 0x504d2d9e, 0x169f18fa, 0x2b2ef426,\n    0x9b3b7232, 0xa68a9eee, 0xe058ab8a, 0xdde94756, 0x5b02a1e3,\n    0x66b34d3f, 0x2061785b, 0x1dd09487, 0xadc51293, 0x9074fe4f,\n    0xd6a6cb2b, 0xeb1727f7, 0xdbf98284, 0xe6486e58, 0xa09a5b3c,\n    0x9d2bb7e0, 0x2d3e31f4, 0x108fdd28, 0x565de84c, 0x6bec0490,\n    0xed07e225, 0xd0b60ef9, 0x96643b9d, 0xabd5d741, 0x1bc05155,\n    0x2671bd89, 0x60a388ed, 0x5d126431, 0xb60543c6, 0x8bb4af1a,\n    0xcd669a7e, 0xf0d776a2, 0x40c2f0b6, 0x7d731c6a, 0x3ba1290e,\n    0x0610c5d2, 0x80fb2367, 0xbd4acfbb, 0xfb98fadf, 0xc6291603,\n    0x763c9017, 0x4b8d7ccb, 0x0d5f49af, 0x30eea573, 0x6c820349,\n    0x5133ef95, 0x17e1daf1, 0x2a50362d, 0x9a45b039, 0xa7f45ce5,\n    0xe1266981, 0xdc97855d, 0x5a7c63e8, 0x67cd8f34, 0x211fba50,\n    0x1cae568c, 0xacbbd098, 0x910a3c44, 0xd7d80920, 0xea69e5fc,\n    0x017ec20b, 0x3ccf2ed7, 0x7a1d1bb3, 0x47acf76f, 0xf7b9717b,\n    0xca089da7, 0x8cdaa8c3, 0xb16b441f, 0x3780a2aa, 0x0a314e76,\n    0x4ce37b12, 0x715297ce, 0xc14711da, 0xfcf6fd06, 0xba24c862,\n    0x879524be, 0xb77b81cd, 0x8aca6d11, 0xcc185875, 0xf1a9b4a9,\n    0x41bc32bd, 0x7c0dde61, 0x3adfeb05, 0x076e07d9, 0x8185e16c,\n    0xbc340db0, 0xfae638d4, 0xc757d408, 0x7742521c, 0x4af3bec0,\n    0x0c218ba4, 0x31906778, 0xda87408f, 0xe736ac53, 0xa1e49937,\n    0x9c5575eb, 0x2c40f3ff, 0x11f11f23, 0x57232a47, 0x6a92c69b,\n    0xec79202e, 0xd1c8ccf2, 0x971af996, 0xaaab154a, 0x1abe935e,\n    0x270f7f82, 0x61dd4ae6, 0x5c6ca63a, 0xd9040692, 0xe4b5ea4e,\n    0xa267df2a, 0x9fd633f6, 0x2fc3b5e2, 0x1272593e, 0x54a06c5a,\n    0x69118086, 0xeffa6633, 0xd24b8aef, 0x9499bf8b, 0xa9285357,\n    0x193dd543, 0x248c399f, 0x625e0cfb, 0x5fefe027, 0xb4f8c7d0,\n    0x89492b0c, 0xcf9b1e68, 0xf22af2b4, 0x423f74a0, 0x7f8e987c,\n    0x395cad18, 0x04ed41c4, 0x8206a771, 0xbfb74bad, 0xf9657ec9,\n    0xc4d49215, 0x74c11401, 0x4970f8dd, 0x0fa2cdb9, 0x32132165,\n    0x02fd8416, 0x3f4c68ca, 0x799e5dae, 0x442fb172, 0xf43a3766,\n    0xc98bdbba, 0x8f59eede, 0xb2e80202, 0x3403e4b7, 0x09b2086b,\n    0x4f603d0f, 0x72d1d1d3, 0xc2c457c7, 0xff75bb1b, 0xb9a78e7f,\n    0x841662a3, 0x6f014554, 0x52b0a988, 0x14629cec, 0x29d37030,\n    0x99c6f624, 0xa4771af8, 0xe2a52f9c, 0xdf14c340, 0x59ff25f5,\n    0x644ec929, 0x229cfc4d, 0x1f2d1091, 0xaf389685, 0x92897a59,\n    0xd45b4f3d, 0xe9eaa3e1, 0xb58605db, 0x8837e907, 0xcee5dc63,\n    0xf35430bf, 0x4341b6ab, 0x7ef05a77, 0x38226f13, 0x059383cf,\n    0x8378657a, 0xbec989a6, 0xf81bbcc2, 0xc5aa501e, 0x75bfd60a,\n    0x480e3ad6, 0x0edc0fb2, 0x336de36e, 0xd87ac499, 0xe5cb2845,\n    0xa3191d21, 0x9ea8f1fd, 0x2ebd77e9, 0x130c9b35, 0x55deae51,\n    0x686f428d, 0xee84a438, 0xd33548e4, 0x95e77d80, 0xa856915c,\n    0x18431748, 0x25f2fb94, 0x6320cef0, 0x5e91222c, 0x6e7f875f,\n    0x53ce6b83, 0x151c5ee7, 0x28adb23b, 0x98b8342f, 0xa509d8f3,\n    0xe3dbed97, 0xde6a014b, 0x5881e7fe, 0x65300b22, 0x23e23e46,\n    0x1e53d29a, 0xae46548e, 0x93f7b852, 0xd5258d36, 0xe89461ea,\n    0x0383461d, 0x3e32aac1, 0x78e09fa5, 0x45517379, 0xf544f56d,\n    0xc8f519b1, 0x8e272cd5, 0xb396c009, 0x357d26bc, 0x08ccca60,\n    0x4e1eff04, 0x73af13d8, 0xc3ba95cc, 0xfe0b7910, 0xb8d94c74,\n    0x8568a0a8},\n   {0x00000000, 0x69790b65, 0xd2f216ca, 0xbb8b1daf, 0x7e952bd5,\n    0x17ec20b0, 0xac673d1f, 0xc51e367a, 0xfd2a57aa, 0x94535ccf,\n    0x2fd84160, 0x46a14a05, 0x83bf7c7f, 0xeac6771a, 0x514d6ab5,\n    0x383461d0, 0x2125a915, 0x485ca270, 0xf3d7bfdf, 0x9aaeb4ba,\n    0x5fb082c0, 0x36c989a5, 0x8d42940a, 0xe43b9f6f, 0xdc0ffebf,\n    0xb576f5da, 0x0efde875, 0x6784e310, 0xa29ad56a, 0xcbe3de0f,\n    0x7068c3a0, 0x1911c8c5, 0x424b522a, 0x2b32594f, 0x90b944e0,\n    0xf9c04f85, 0x3cde79ff, 0x55a7729a, 0xee2c6f35, 0x87556450,\n    0xbf610580, 0xd6180ee5, 0x6d93134a, 0x04ea182f, 0xc1f42e55,\n    0xa88d2530, 0x1306389f, 0x7a7f33fa, 0x636efb3f, 0x0a17f05a,\n    0xb19cedf5, 0xd8e5e690, 0x1dfbd0ea, 0x7482db8f, 0xcf09c620,\n    0xa670cd45, 0x9e44ac95, 0xf73da7f0, 0x4cb6ba5f, 0x25cfb13a,\n    0xe0d18740, 0x89a88c25, 0x3223918a, 0x5b5a9aef, 0x8496a454,\n    0xedefaf31, 0x5664b29e, 0x3f1db9fb, 0xfa038f81, 0x937a84e4,\n    0x28f1994b, 0x4188922e, 0x79bcf3fe, 0x10c5f89b, 0xab4ee534,\n    0xc237ee51, 0x0729d82b, 0x6e50d34e, 0xd5dbcee1, 0xbca2c584,\n    0xa5b30d41, 0xccca0624, 0x77411b8b, 0x1e3810ee, 0xdb262694,\n    0xb25f2df1, 0x09d4305e, 0x60ad3b3b, 0x58995aeb, 0x31e0518e,\n    0x8a6b4c21, 0xe3124744, 0x260c713e, 0x4f757a5b, 0xf4fe67f4,\n    0x9d876c91, 0xc6ddf67e, 0xafa4fd1b, 0x142fe0b4, 0x7d56ebd1,\n    0xb848ddab, 0xd131d6ce, 0x6abacb61, 0x03c3c004, 0x3bf7a1d4,\n    0x528eaab1, 0xe905b71e, 0x807cbc7b, 0x45628a01, 0x2c1b8164,\n    0x97909ccb, 0xfee997ae, 0xe7f85f6b, 0x8e81540e, 0x350a49a1,\n    0x5c7342c4, 0x996d74be, 0xf0147fdb, 0x4b9f6274, 0x22e66911,\n    0x1ad208c1, 0x73ab03a4, 0xc8201e0b, 0xa159156e, 0x64472314,\n    0x0d3e2871, 0xb6b535de, 0xdfcc3ebb, 0xd25c4ee9, 0xbb25458c,\n    0x00ae5823, 0x69d75346, 0xacc9653c, 0xc5b06e59, 0x7e3b73f6,\n    0x17427893, 0x2f761943, 0x460f1226, 0xfd840f89, 0x94fd04ec,\n    0x51e33296, 0x389a39f3, 0x8311245c, 0xea682f39, 0xf379e7fc,\n    0x9a00ec99, 0x218bf136, 0x48f2fa53, 0x8deccc29, 0xe495c74c,\n    0x5f1edae3, 0x3667d186, 0x0e53b056, 0x672abb33, 0xdca1a69c,\n    0xb5d8adf9, 0x70c69b83, 0x19bf90e6, 0xa2348d49, 0xcb4d862c,\n    0x90171cc3, 0xf96e17a6, 0x42e50a09, 0x2b9c016c, 0xee823716,\n    0x87fb3c73, 0x3c7021dc, 0x55092ab9, 0x6d3d4b69, 0x0444400c,\n    0xbfcf5da3, 0xd6b656c6, 0x13a860bc, 0x7ad16bd9, 0xc15a7676,\n    0xa8237d13, 0xb132b5d6, 0xd84bbeb3, 0x63c0a31c, 0x0ab9a879,\n    0xcfa79e03, 0xa6de9566, 0x1d5588c9, 0x742c83ac, 0x4c18e27c,\n    0x2561e919, 0x9eeaf4b6, 0xf793ffd3, 0x328dc9a9, 0x5bf4c2cc,\n    0xe07fdf63, 0x8906d406, 0x56caeabd, 0x3fb3e1d8, 0x8438fc77,\n    0xed41f712, 0x285fc168, 0x4126ca0d, 0xfaadd7a2, 0x93d4dcc7,\n    0xabe0bd17, 0xc299b672, 0x7912abdd, 0x106ba0b8, 0xd57596c2,\n    0xbc0c9da7, 0x07878008, 0x6efe8b6d, 0x77ef43a8, 0x1e9648cd,\n    0xa51d5562, 0xcc645e07, 0x097a687d, 0x60036318, 0xdb887eb7,\n    0xb2f175d2, 0x8ac51402, 0xe3bc1f67, 0x583702c8, 0x314e09ad,\n    0xf4503fd7, 0x9d2934b2, 0x26a2291d, 0x4fdb2278, 0x1481b897,\n    0x7df8b3f2, 0xc673ae5d, 0xaf0aa538, 0x6a149342, 0x036d9827,\n    0xb8e68588, 0xd19f8eed, 0xe9abef3d, 0x80d2e458, 0x3b59f9f7,\n    0x5220f292, 0x973ec4e8, 0xfe47cf8d, 0x45ccd222, 0x2cb5d947,\n    0x35a41182, 0x5cdd1ae7, 0xe7560748, 0x8e2f0c2d, 0x4b313a57,\n    0x22483132, 0x99c32c9d, 0xf0ba27f8, 0xc88e4628, 0xa1f74d4d,\n    0x1a7c50e2, 0x73055b87, 0xb61b6dfd, 0xdf626698, 0x64e97b37,\n    0x0d907052},\n   {0x00000000, 0x7fc99b93, 0xff933726, 0x805aacb5, 0x2457680d,\n    0x5b9ef39e, 0xdbc45f2b, 0xa40dc4b8, 0x48aed01a, 0x37674b89,\n    0xb73de73c, 0xc8f47caf, 0x6cf9b817, 0x13302384, 0x936a8f31,\n    0xeca314a2, 0x915da034, 0xee943ba7, 0x6ece9712, 0x11070c81,\n    0xb50ac839, 0xcac353aa, 0x4a99ff1f, 0x3550648c, 0xd9f3702e,\n    0xa63aebbd, 0x26604708, 0x59a9dc9b, 0xfda41823, 0x826d83b0,\n    0x02372f05, 0x7dfeb496, 0xf9ca4629, 0x8603ddba, 0x0659710f,\n    0x7990ea9c, 0xdd9d2e24, 0xa254b5b7, 0x220e1902, 0x5dc78291,\n    0xb1649633, 0xcead0da0, 0x4ef7a115, 0x313e3a86, 0x9533fe3e,\n    0xeafa65ad, 0x6aa0c918, 0x1569528b, 0x6897e61d, 0x175e7d8e,\n    0x9704d13b, 0xe8cd4aa8, 0x4cc08e10, 0x33091583, 0xb353b936,\n    0xcc9a22a5, 0x20393607, 0x5ff0ad94, 0xdfaa0121, 0xa0639ab2,\n    0x046e5e0a, 0x7ba7c599, 0xfbfd692c, 0x8434f2bf, 0x28e58a13,\n    0x572c1180, 0xd776bd35, 0xa8bf26a6, 0x0cb2e21e, 0x737b798d,\n    0xf321d538, 0x8ce84eab, 0x604b5a09, 0x1f82c19a, 0x9fd86d2f,\n    0xe011f6bc, 0x441c3204, 0x3bd5a997, 0xbb8f0522, 0xc4469eb1,\n    0xb9b82a27, 0xc671b1b4, 0x462b1d01, 0x39e28692, 0x9def422a,\n    0xe226d9b9, 0x627c750c, 0x1db5ee9f, 0xf116fa3d, 0x8edf61ae,\n    0x0e85cd1b, 0x714c5688, 0xd5419230, 0xaa8809a3, 0x2ad2a516,\n    0x551b3e85, 0xd12fcc3a, 0xaee657a9, 0x2ebcfb1c, 0x5175608f,\n    0xf578a437, 0x8ab13fa4, 0x0aeb9311, 0x75220882, 0x99811c20,\n    0xe64887b3, 0x66122b06, 0x19dbb095, 0xbdd6742d, 0xc21fefbe,\n    0x4245430b, 0x3d8cd898, 0x40726c0e, 0x3fbbf79d, 0xbfe15b28,\n    0xc028c0bb, 0x64250403, 0x1bec9f90, 0x9bb63325, 0xe47fa8b6,\n    0x08dcbc14, 0x77152787, 0xf74f8b32, 0x888610a1, 0x2c8bd419,\n    0x53424f8a, 0xd318e33f, 0xacd178ac, 0x51cb1426, 0x2e028fb5,\n    0xae582300, 0xd191b893, 0x759c7c2b, 0x0a55e7b8, 0x8a0f4b0d,\n    0xf5c6d09e, 0x1965c43c, 0x66ac5faf, 0xe6f6f31a, 0x993f6889,\n    0x3d32ac31, 0x42fb37a2, 0xc2a19b17, 0xbd680084, 0xc096b412,\n    0xbf5f2f81, 0x3f058334, 0x40cc18a7, 0xe4c1dc1f, 0x9b08478c,\n    0x1b52eb39, 0x649b70aa, 0x88386408, 0xf7f1ff9b, 0x77ab532e,\n    0x0862c8bd, 0xac6f0c05, 0xd3a69796, 0x53fc3b23, 0x2c35a0b0,\n    0xa801520f, 0xd7c8c99c, 0x57926529, 0x285bfeba, 0x8c563a02,\n    0xf39fa191, 0x73c50d24, 0x0c0c96b7, 0xe0af8215, 0x9f661986,\n    0x1f3cb533, 0x60f52ea0, 0xc4f8ea18, 0xbb31718b, 0x3b6bdd3e,\n    0x44a246ad, 0x395cf23b, 0x469569a8, 0xc6cfc51d, 0xb9065e8e,\n    0x1d0b9a36, 0x62c201a5, 0xe298ad10, 0x9d513683, 0x71f22221,\n    0x0e3bb9b2, 0x8e611507, 0xf1a88e94, 0x55a54a2c, 0x2a6cd1bf,\n    0xaa367d0a, 0xd5ffe699, 0x792e9e35, 0x06e705a6, 0x86bda913,\n    0xf9743280, 0x5d79f638, 0x22b06dab, 0xa2eac11e, 0xdd235a8d,\n    0x31804e2f, 0x4e49d5bc, 0xce137909, 0xb1dae29a, 0x15d72622,\n    0x6a1ebdb1, 0xea441104, 0x958d8a97, 0xe8733e01, 0x97baa592,\n    0x17e00927, 0x682992b4, 0xcc24560c, 0xb3edcd9f, 0x33b7612a,\n    0x4c7efab9, 0xa0ddee1b, 0xdf147588, 0x5f4ed93d, 0x208742ae,\n    0x848a8616, 0xfb431d85, 0x7b19b130, 0x04d02aa3, 0x80e4d81c,\n    0xff2d438f, 0x7f77ef3a, 0x00be74a9, 0xa4b3b011, 0xdb7a2b82,\n    0x5b208737, 0x24e91ca4, 0xc84a0806, 0xb7839395, 0x37d93f20,\n    0x4810a4b3, 0xec1d600b, 0x93d4fb98, 0x138e572d, 0x6c47ccbe,\n    0x11b97828, 0x6e70e3bb, 0xee2a4f0e, 0x91e3d49d, 0x35ee1025,\n    0x4a278bb6, 0xca7d2703, 0xb5b4bc90, 0x5917a832, 0x26de33a1,\n    0xa6849f14, 0xd94d0487, 0x7d40c03f, 0x02895bac, 0x82d3f719,\n    0xfd1a6c8a},\n   {0x00000000, 0xa396284c, 0x9c5d56d9, 0x3fcb7e95, 0xe3cbabf3,\n    0x405d83bf, 0x7f96fd2a, 0xdc00d566, 0x1ce651a7, 0xbf7079eb,\n    0x80bb077e, 0x232d2f32, 0xff2dfa54, 0x5cbbd218, 0x6370ac8d,\n    0xc0e684c1, 0x39cca34e, 0x9a5a8b02, 0xa591f597, 0x0607dddb,\n    0xda0708bd, 0x799120f1, 0x465a5e64, 0xe5cc7628, 0x252af2e9,\n    0x86bcdaa5, 0xb977a430, 0x1ae18c7c, 0xc6e1591a, 0x65777156,\n    0x5abc0fc3, 0xf92a278f, 0x7399469c, 0xd00f6ed0, 0xefc41045,\n    0x4c523809, 0x9052ed6f, 0x33c4c523, 0x0c0fbbb6, 0xaf9993fa,\n    0x6f7f173b, 0xcce93f77, 0xf32241e2, 0x50b469ae, 0x8cb4bcc8,\n    0x2f229484, 0x10e9ea11, 0xb37fc25d, 0x4a55e5d2, 0xe9c3cd9e,\n    0xd608b30b, 0x759e9b47, 0xa99e4e21, 0x0a08666d, 0x35c318f8,\n    0x965530b4, 0x56b3b475, 0xf5259c39, 0xcaeee2ac, 0x6978cae0,\n    0xb5781f86, 0x16ee37ca, 0x2925495f, 0x8ab36113, 0xe7328d38,\n    0x44a4a574, 0x7b6fdbe1, 0xd8f9f3ad, 0x04f926cb, 0xa76f0e87,\n    0x98a47012, 0x3b32585e, 0xfbd4dc9f, 0x5842f4d3, 0x67898a46,\n    0xc41fa20a, 0x181f776c, 0xbb895f20, 0x844221b5, 0x27d409f9,\n    0xdefe2e76, 0x7d68063a, 0x42a378af, 0xe13550e3, 0x3d358585,\n    0x9ea3adc9, 0xa168d35c, 0x02fefb10, 0xc2187fd1, 0x618e579d,\n    0x5e452908, 0xfdd30144, 0x21d3d422, 0x8245fc6e, 0xbd8e82fb,\n    0x1e18aab7, 0x94abcba4, 0x373de3e8, 0x08f69d7d, 0xab60b531,\n    0x77606057, 0xd4f6481b, 0xeb3d368e, 0x48ab1ec2, 0x884d9a03,\n    0x2bdbb24f, 0x1410ccda, 0xb786e496, 0x6b8631f0, 0xc81019bc,\n    0xf7db6729, 0x544d4f65, 0xad6768ea, 0x0ef140a6, 0x313a3e33,\n    0x92ac167f, 0x4eacc319, 0xed3aeb55, 0xd2f195c0, 0x7167bd8c,\n    0xb181394d, 0x12171101, 0x2ddc6f94, 0x8e4a47d8, 0x524a92be,\n    0xf1dcbaf2, 0xce17c467, 0x6d81ec2b, 0x15141c31, 0xb682347d,\n    0x89494ae8, 0x2adf62a4, 0xf6dfb7c2, 0x55499f8e, 0x6a82e11b,\n    0xc914c957, 0x09f24d96, 0xaa6465da, 0x95af1b4f, 0x36393303,\n    0xea39e665, 0x49afce29, 0x7664b0bc, 0xd5f298f0, 0x2cd8bf7f,\n    0x8f4e9733, 0xb085e9a6, 0x1313c1ea, 0xcf13148c, 0x6c853cc0,\n    0x534e4255, 0xf0d86a19, 0x303eeed8, 0x93a8c694, 0xac63b801,\n    0x0ff5904d, 0xd3f5452b, 0x70636d67, 0x4fa813f2, 0xec3e3bbe,\n    0x668d5aad, 0xc51b72e1, 0xfad00c74, 0x59462438, 0x8546f15e,\n    0x26d0d912, 0x191ba787, 0xba8d8fcb, 0x7a6b0b0a, 0xd9fd2346,\n    0xe6365dd3, 0x45a0759f, 0x99a0a0f9, 0x3a3688b5, 0x05fdf620,\n    0xa66bde6c, 0x5f41f9e3, 0xfcd7d1af, 0xc31caf3a, 0x608a8776,\n    0xbc8a5210, 0x1f1c7a5c, 0x20d704c9, 0x83412c85, 0x43a7a844,\n    0xe0318008, 0xdffafe9d, 0x7c6cd6d1, 0xa06c03b7, 0x03fa2bfb,\n    0x3c31556e, 0x9fa77d22, 0xf2269109, 0x51b0b945, 0x6e7bc7d0,\n    0xcdedef9c, 0x11ed3afa, 0xb27b12b6, 0x8db06c23, 0x2e26446f,\n    0xeec0c0ae, 0x4d56e8e2, 0x729d9677, 0xd10bbe3b, 0x0d0b6b5d,\n    0xae9d4311, 0x91563d84, 0x32c015c8, 0xcbea3247, 0x687c1a0b,\n    0x57b7649e, 0xf4214cd2, 0x282199b4, 0x8bb7b1f8, 0xb47ccf6d,\n    0x17eae721, 0xd70c63e0, 0x749a4bac, 0x4b513539, 0xe8c71d75,\n    0x34c7c813, 0x9751e05f, 0xa89a9eca, 0x0b0cb686, 0x81bfd795,\n    0x2229ffd9, 0x1de2814c, 0xbe74a900, 0x62747c66, 0xc1e2542a,\n    0xfe292abf, 0x5dbf02f3, 0x9d598632, 0x3ecfae7e, 0x0104d0eb,\n    0xa292f8a7, 0x7e922dc1, 0xdd04058d, 0xe2cf7b18, 0x41595354,\n    0xb87374db, 0x1be55c97, 0x242e2202, 0x87b80a4e, 0x5bb8df28,\n    0xf82ef764, 0xc7e589f1, 0x6473a1bd, 0xa495257c, 0x07030d30,\n    0x38c873a5, 0x9b5e5be9, 0x475e8e8f, 0xe4c8a6c3, 0xdb03d856,\n    0x7895f01a},\n   {0x00000000, 0x2a283862, 0x545070c4, 0x7e7848a6, 0xa8a0e188,\n    0x8288d9ea, 0xfcf0914c, 0xd6d8a92e, 0x8a30c551, 0xa018fd33,\n    0xde60b595, 0xf4488df7, 0x229024d9, 0x08b81cbb, 0x76c0541d,\n    0x5ce86c7f, 0xcf108ce3, 0xe538b481, 0x9b40fc27, 0xb168c445,\n    0x67b06d6b, 0x4d985509, 0x33e01daf, 0x19c825cd, 0x452049b2,\n    0x6f0871d0, 0x11703976, 0x3b580114, 0xed80a83a, 0xc7a89058,\n    0xb9d0d8fe, 0x93f8e09c, 0x45501f87, 0x6f7827e5, 0x11006f43,\n    0x3b285721, 0xedf0fe0f, 0xc7d8c66d, 0xb9a08ecb, 0x9388b6a9,\n    0xcf60dad6, 0xe548e2b4, 0x9b30aa12, 0xb1189270, 0x67c03b5e,\n    0x4de8033c, 0x33904b9a, 0x19b873f8, 0x8a409364, 0xa068ab06,\n    0xde10e3a0, 0xf438dbc2, 0x22e072ec, 0x08c84a8e, 0x76b00228,\n    0x5c983a4a, 0x00705635, 0x2a586e57, 0x542026f1, 0x7e081e93,\n    0xa8d0b7bd, 0x82f88fdf, 0xfc80c779, 0xd6a8ff1b, 0x8aa03f0e,\n    0xa088076c, 0xdef04fca, 0xf4d877a8, 0x2200de86, 0x0828e6e4,\n    0x7650ae42, 0x5c789620, 0x0090fa5f, 0x2ab8c23d, 0x54c08a9b,\n    0x7ee8b2f9, 0xa8301bd7, 0x821823b5, 0xfc606b13, 0xd6485371,\n    0x45b0b3ed, 0x6f988b8f, 0x11e0c329, 0x3bc8fb4b, 0xed105265,\n    0xc7386a07, 0xb94022a1, 0x93681ac3, 0xcf8076bc, 0xe5a84ede,\n    0x9bd00678, 0xb1f83e1a, 0x67209734, 0x4d08af56, 0x3370e7f0,\n    0x1958df92, 0xcff02089, 0xe5d818eb, 0x9ba0504d, 0xb188682f,\n    0x6750c101, 0x4d78f963, 0x3300b1c5, 0x192889a7, 0x45c0e5d8,\n    0x6fe8ddba, 0x1190951c, 0x3bb8ad7e, 0xed600450, 0xc7483c32,\n    0xb9307494, 0x93184cf6, 0x00e0ac6a, 0x2ac89408, 0x54b0dcae,\n    0x7e98e4cc, 0xa8404de2, 0x82687580, 0xfc103d26, 0xd6380544,\n    0x8ad0693b, 0xa0f85159, 0xde8019ff, 0xf4a8219d, 0x227088b3,\n    0x0858b0d1, 0x7620f877, 0x5c08c015, 0xce31785d, 0xe419403f,\n    0x9a610899, 0xb04930fb, 0x669199d5, 0x4cb9a1b7, 0x32c1e911,\n    0x18e9d173, 0x4401bd0c, 0x6e29856e, 0x1051cdc8, 0x3a79f5aa,\n    0xeca15c84, 0xc68964e6, 0xb8f12c40, 0x92d91422, 0x0121f4be,\n    0x2b09ccdc, 0x5571847a, 0x7f59bc18, 0xa9811536, 0x83a92d54,\n    0xfdd165f2, 0xd7f95d90, 0x8b1131ef, 0xa139098d, 0xdf41412b,\n    0xf5697949, 0x23b1d067, 0x0999e805, 0x77e1a0a3, 0x5dc998c1,\n    0x8b6167da, 0xa1495fb8, 0xdf31171e, 0xf5192f7c, 0x23c18652,\n    0x09e9be30, 0x7791f696, 0x5db9cef4, 0x0151a28b, 0x2b799ae9,\n    0x5501d24f, 0x7f29ea2d, 0xa9f14303, 0x83d97b61, 0xfda133c7,\n    0xd7890ba5, 0x4471eb39, 0x6e59d35b, 0x10219bfd, 0x3a09a39f,\n    0xecd10ab1, 0xc6f932d3, 0xb8817a75, 0x92a94217, 0xce412e68,\n    0xe469160a, 0x9a115eac, 0xb03966ce, 0x66e1cfe0, 0x4cc9f782,\n    0x32b1bf24, 0x18998746, 0x44914753, 0x6eb97f31, 0x10c13797,\n    0x3ae90ff5, 0xec31a6db, 0xc6199eb9, 0xb861d61f, 0x9249ee7d,\n    0xcea18202, 0xe489ba60, 0x9af1f2c6, 0xb0d9caa4, 0x6601638a,\n    0x4c295be8, 0x3251134e, 0x18792b2c, 0x8b81cbb0, 0xa1a9f3d2,\n    0xdfd1bb74, 0xf5f98316, 0x23212a38, 0x0909125a, 0x77715afc,\n    0x5d59629e, 0x01b10ee1, 0x2b993683, 0x55e17e25, 0x7fc94647,\n    0xa911ef69, 0x8339d70b, 0xfd419fad, 0xd769a7cf, 0x01c158d4,\n    0x2be960b6, 0x55912810, 0x7fb91072, 0xa961b95c, 0x8349813e,\n    0xfd31c998, 0xd719f1fa, 0x8bf19d85, 0xa1d9a5e7, 0xdfa1ed41,\n    0xf589d523, 0x23517c0d, 0x0979446f, 0x77010cc9, 0x5d2934ab,\n    0xced1d437, 0xe4f9ec55, 0x9a81a4f3, 0xb0a99c91, 0x667135bf,\n    0x4c590ddd, 0x3221457b, 0x18097d19, 0x44e11166, 0x6ec92904,\n    0x10b161a2, 0x3a9959c0, 0xec41f0ee, 0xc669c88c, 0xb811802a,\n    0x9239b848},\n   {0x00000000, 0x4713f6fb, 0x8e27edf6, 0xc9341b0d, 0xc73eddad,\n    0x802d2b56, 0x4919305b, 0x0e0ac6a0, 0x550cbd1b, 0x121f4be0,\n    0xdb2b50ed, 0x9c38a616, 0x923260b6, 0xd521964d, 0x1c158d40,\n    0x5b067bbb, 0xaa197a36, 0xed0a8ccd, 0x243e97c0, 0x632d613b,\n    0x6d27a79b, 0x2a345160, 0xe3004a6d, 0xa413bc96, 0xff15c72d,\n    0xb80631d6, 0x71322adb, 0x3621dc20, 0x382b1a80, 0x7f38ec7b,\n    0xb60cf776, 0xf11f018d, 0x8f43f22d, 0xc85004d6, 0x01641fdb,\n    0x4677e920, 0x487d2f80, 0x0f6ed97b, 0xc65ac276, 0x8149348d,\n    0xda4f4f36, 0x9d5cb9cd, 0x5468a2c0, 0x137b543b, 0x1d71929b,\n    0x5a626460, 0x93567f6d, 0xd4458996, 0x255a881b, 0x62497ee0,\n    0xab7d65ed, 0xec6e9316, 0xe26455b6, 0xa577a34d, 0x6c43b840,\n    0x2b504ebb, 0x70563500"
        },
        {
          "name": "deflate.c",
          "type": "blob",
          "size": 80.2109375,
          "content": "/* deflate.c -- compress data using the deflation algorithm\n * Copyright (C) 1995-2024 Jean-loup Gailly and Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n/*\n *  ALGORITHM\n *\n *      The \"deflation\" process depends on being able to identify portions\n *      of the input text which are identical to earlier input (within a\n *      sliding window trailing behind the input currently being processed).\n *\n *      The most straightforward technique turns out to be the fastest for\n *      most input files: try all possible matches and select the longest.\n *      The key feature of this algorithm is that insertions into the string\n *      dictionary are very simple and thus fast, and deletions are avoided\n *      completely. Insertions are performed at each input character, whereas\n *      string matches are performed only when the previous match ends. So it\n *      is preferable to spend more time in matches to allow very fast string\n *      insertions and avoid deletions. The matching algorithm for small\n *      strings is inspired from that of Rabin & Karp. A brute force approach\n *      is used to find longer strings when a small match has been found.\n *      A similar algorithm is used in comic (by Jan-Mark Wams) and freeze\n *      (by Leonid Broukhis).\n *         A previous version of this file used a more sophisticated algorithm\n *      (by Fiala and Greene) which is guaranteed to run in linear amortized\n *      time, but has a larger average cost, uses more memory and is patented.\n *      However the F&G algorithm may be faster for some highly redundant\n *      files if the parameter max_chain_length (described below) is too large.\n *\n *  ACKNOWLEDGEMENTS\n *\n *      The idea of lazy evaluation of matches is due to Jan-Mark Wams, and\n *      I found it in 'freeze' written by Leonid Broukhis.\n *      Thanks to many people for bug reports and testing.\n *\n *  REFERENCES\n *\n *      Deutsch, L.P.,\"DEFLATE Compressed Data Format Specification\".\n *      Available in http://tools.ietf.org/html/rfc1951\n *\n *      A description of the Rabin and Karp algorithm is given in the book\n *         \"Algorithms\" by R. Sedgewick, Addison-Wesley, p252.\n *\n *      Fiala,E.R., and Greene,D.H.\n *         Data Compression with Finite Windows, Comm.ACM, 32,4 (1989) 490-595\n *\n */\n\n/* @(#) $Id$ */\n\n#include \"deflate.h\"\n\nconst char deflate_copyright[] =\n   \" deflate 1.3.1.1 Copyright 1995-2024 Jean-loup Gailly and Mark Adler \";\n/*\n  If you use the zlib library in a product, an acknowledgment is welcome\n  in the documentation of your product. If for some reason you cannot\n  include such an acknowledgment, I would appreciate that you keep this\n  copyright string in the executable of your product.\n */\n\ntypedef enum {\n    need_more,      /* block not completed, need more input or more output */\n    block_done,     /* block flush performed */\n    finish_started, /* finish started, need only more output at next deflate */\n    finish_done     /* finish done, accept no more input or output */\n} block_state;\n\ntypedef block_state (*compress_func)(deflate_state *s, int flush);\n/* Compression function. Returns the block state after the call. */\n\nlocal block_state deflate_stored(deflate_state *s, int flush);\nlocal block_state deflate_fast(deflate_state *s, int flush);\n#ifndef FASTEST\nlocal block_state deflate_slow(deflate_state *s, int flush);\n#endif\nlocal block_state deflate_rle(deflate_state *s, int flush);\nlocal block_state deflate_huff(deflate_state *s, int flush);\n\n/* ===========================================================================\n * Local data\n */\n\n#define NIL 0\n/* Tail of hash chains */\n\n#ifndef TOO_FAR\n#  define TOO_FAR 4096\n#endif\n/* Matches of length 3 are discarded if their distance exceeds TOO_FAR */\n\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\n * the desired pack level (0..9). The values given below have been tuned to\n * exclude worst case performance for pathological files. Better values may be\n * found for specific files.\n */\ntypedef struct config_s {\n   ush good_length; /* reduce lazy search above this match length */\n   ush max_lazy;    /* do not perform lazy search above this match length */\n   ush nice_length; /* quit search above this match length */\n   ush max_chain;\n   compress_func func;\n} config;\n\n#ifdef FASTEST\nlocal const config configuration_table[2] = {\n/*      good lazy nice chain */\n/* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */\n/* 1 */ {4,    4,  8,    4, deflate_fast}}; /* max speed, no lazy matches */\n#else\nlocal const config configuration_table[10] = {\n/*      good lazy nice chain */\n/* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */\n/* 1 */ {4,    4,  8,    4, deflate_fast}, /* max speed, no lazy matches */\n/* 2 */ {4,    5, 16,    8, deflate_fast},\n/* 3 */ {4,    6, 32,   32, deflate_fast},\n\n/* 4 */ {4,    4, 16,   16, deflate_slow},  /* lazy matches */\n/* 5 */ {8,   16, 32,   32, deflate_slow},\n/* 6 */ {8,   16, 128, 128, deflate_slow},\n/* 7 */ {8,   32, 128, 256, deflate_slow},\n/* 8 */ {32, 128, 258, 1024, deflate_slow},\n/* 9 */ {32, 258, 258, 4096, deflate_slow}}; /* max compression */\n#endif\n\n/* Note: the deflate() code requires max_lazy >= MIN_MATCH and max_chain >= 4\n * For deflate_fast() (levels <= 3) good is ignored and lazy has a different\n * meaning.\n */\n\n/* rank Z_BLOCK between Z_NO_FLUSH and Z_PARTIAL_FLUSH */\n#define RANK(f) (((f) * 2) - ((f) > 4 ? 9 : 0))\n\n/* ===========================================================================\n * Update a hash value with the given input byte\n * IN  assertion: all calls to UPDATE_HASH are made with consecutive input\n *    characters, so that a running hash key can be computed from the previous\n *    key instead of complete recalculation each time.\n */\n#define UPDATE_HASH(s,h,c) (h = (((h) << s->hash_shift) ^ (c)) & s->hash_mask)\n\n\n/* ===========================================================================\n * Insert string str in the dictionary and set match_head to the previous head\n * of the hash chain (the most recent string with same hash key). Return\n * the previous length of the hash chain.\n * If this file is compiled with -DFASTEST, the compression level is forced\n * to 1, and no hash chains are maintained.\n * IN  assertion: all calls to INSERT_STRING are made with consecutive input\n *    characters and the first MIN_MATCH bytes of str are valid (except for\n *    the last MIN_MATCH-1 bytes of the input file).\n */\n#ifdef FASTEST\n#define INSERT_STRING(s, str, match_head) \\\n   (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \\\n    match_head = s->head[s->ins_h], \\\n    s->head[s->ins_h] = (Pos)(str))\n#else\n#define INSERT_STRING(s, str, match_head) \\\n   (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \\\n    match_head = s->prev[(str) & s->w_mask] = s->head[s->ins_h], \\\n    s->head[s->ins_h] = (Pos)(str))\n#endif\n\n/* ===========================================================================\n * Initialize the hash table (avoiding 64K overflow for 16 bit systems).\n * prev[] will be initialized on the fly.\n */\n#define CLEAR_HASH(s) \\\n    do { \\\n        s->head[s->hash_size - 1] = NIL; \\\n        zmemzero((Bytef *)s->head, \\\n                 (unsigned)(s->hash_size - 1)*sizeof(*s->head)); \\\n    } while (0)\n\n/* ===========================================================================\n * Slide the hash table when sliding the window down (could be avoided with 32\n * bit values at the expense of memory usage). We slide even when level == 0 to\n * keep the hash table consistent if we switch back to level > 0 later.\n */\n#if defined(__has_feature)\n#  if __has_feature(memory_sanitizer)\n     __attribute__((no_sanitize(\"memory\")))\n#  endif\n#endif\nlocal void slide_hash(deflate_state *s) {\n    unsigned n, m;\n    Posf *p;\n    uInt wsize = s->w_size;\n\n    n = s->hash_size;\n    p = &s->head[n];\n    do {\n        m = *--p;\n        *p = (Pos)(m >= wsize ? m - wsize : NIL);\n    } while (--n);\n    n = wsize;\n#ifndef FASTEST\n    p = &s->prev[n];\n    do {\n        m = *--p;\n        *p = (Pos)(m >= wsize ? m - wsize : NIL);\n        /* If n is not on any hash chain, prev[n] is garbage but\n         * its value will never be used.\n         */\n    } while (--n);\n#endif\n}\n\n/* ===========================================================================\n * Read a new buffer from the current input stream, update the adler32\n * and total number of bytes read.  All deflate() input goes through\n * this function so some applications may wish to modify it to avoid\n * allocating a large strm->next_in buffer and copying from it.\n * (See also flush_pending()).\n */\nlocal unsigned read_buf(z_streamp strm, Bytef *buf, unsigned size) {\n    unsigned len = strm->avail_in;\n\n    if (len > size) len = size;\n    if (len == 0) return 0;\n\n    strm->avail_in  -= len;\n\n    zmemcpy(buf, strm->next_in, len);\n    if (strm->state->wrap == 1) {\n        strm->adler = adler32(strm->adler, buf, len);\n    }\n#ifdef GZIP\n    else if (strm->state->wrap == 2) {\n        strm->adler = crc32(strm->adler, buf, len);\n    }\n#endif\n    strm->next_in  += len;\n    strm->total_in += len;\n\n    return len;\n}\n\n/* ===========================================================================\n * Fill the window when the lookahead becomes insufficient.\n * Updates strstart and lookahead.\n *\n * IN assertion: lookahead < MIN_LOOKAHEAD\n * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n *    At least one byte has been read, or avail_in == 0; reads are\n *    performed for at least two bytes (required for the zip translate_eol\n *    option -- not supported here).\n */\nlocal void fill_window(deflate_state *s) {\n    unsigned n;\n    unsigned more;    /* Amount of free space at the end of the window. */\n    uInt wsize = s->w_size;\n\n    Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n\n    do {\n        more = (unsigned)(s->window_size -(ulg)s->lookahead -(ulg)s->strstart);\n\n        /* Deal with !@#$% 64K limit: */\n        if (sizeof(int) <= 2) {\n            if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n                more = wsize;\n\n            } else if (more == (unsigned)(-1)) {\n                /* Very unlikely, but possible on 16 bit machine if\n                 * strstart == 0 && lookahead == 1 (input done a byte at time)\n                 */\n                more--;\n            }\n        }\n\n        /* If the window is almost full and there is insufficient lookahead,\n         * move the upper half to the lower one to make room in the upper half.\n         */\n        if (s->strstart >= wsize + MAX_DIST(s)) {\n\n            zmemcpy(s->window, s->window + wsize, (unsigned)wsize - more);\n            s->match_start -= wsize;\n            s->strstart    -= wsize; /* we now have strstart >= MAX_DIST */\n            s->block_start -= (long) wsize;\n            if (s->insert > s->strstart)\n                s->insert = s->strstart;\n            slide_hash(s);\n            more += wsize;\n        }\n        if (s->strm->avail_in == 0) break;\n\n        /* If there was no sliding:\n         *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n         *    more == window_size - lookahead - strstart\n         * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n         * => more >= window_size - 2*WSIZE + 2\n         * In the BIG_MEM or MMAP case (not yet supported),\n         *   window_size == input_size + MIN_LOOKAHEAD  &&\n         *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n         * Otherwise, window_size == 2*WSIZE so more >= 2.\n         * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n         */\n        Assert(more >= 2, \"more < 2\");\n\n        n = read_buf(s->strm, s->window + s->strstart + s->lookahead, more);\n        s->lookahead += n;\n\n        /* Initialize the hash value now that we have some input: */\n        if (s->lookahead + s->insert >= MIN_MATCH) {\n            uInt str = s->strstart - s->insert;\n            s->ins_h = s->window[str];\n            UPDATE_HASH(s, s->ins_h, s->window[str + 1]);\n#if MIN_MATCH != 3\n            Call UPDATE_HASH() MIN_MATCH-3 more times\n#endif\n            while (s->insert) {\n                UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]);\n#ifndef FASTEST\n                s->prev[str & s->w_mask] = s->head[s->ins_h];\n#endif\n                s->head[s->ins_h] = (Pos)str;\n                str++;\n                s->insert--;\n                if (s->lookahead + s->insert < MIN_MATCH)\n                    break;\n            }\n        }\n        /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n         * but this is not important since only literal bytes will be emitted.\n         */\n\n    } while (s->lookahead < MIN_LOOKAHEAD && s->strm->avail_in != 0);\n\n    /* If the WIN_INIT bytes after the end of the current data have never been\n     * written, then zero those bytes in order to avoid memory check reports of\n     * the use of uninitialized (or uninitialised as Julian writes) bytes by\n     * the longest match routines.  Update the high water mark for the next\n     * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n     * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n     */\n    if (s->high_water < s->window_size) {\n        ulg curr = s->strstart + (ulg)(s->lookahead);\n        ulg init;\n\n        if (s->high_water < curr) {\n            /* Previous high water mark below current data -- zero WIN_INIT\n             * bytes or up to end of window, whichever is less.\n             */\n            init = s->window_size - curr;\n            if (init > WIN_INIT)\n                init = WIN_INIT;\n            zmemzero(s->window + curr, (unsigned)init);\n            s->high_water = curr + init;\n        }\n        else if (s->high_water < (ulg)curr + WIN_INIT) {\n            /* High water mark at or above current data, but below current data\n             * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n             * to end of window, whichever is less.\n             */\n            init = (ulg)curr + WIN_INIT - s->high_water;\n            if (init > s->window_size - s->high_water)\n                init = s->window_size - s->high_water;\n            zmemzero(s->window + s->high_water, (unsigned)init);\n            s->high_water += init;\n        }\n    }\n\n    Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n           \"not enough room for search\");\n}\n\n/* ========================================================================= */\nint ZEXPORT deflateInit_(z_streamp strm, int level, const char *version,\n                         int stream_size) {\n    return deflateInit2_(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL,\n                         Z_DEFAULT_STRATEGY, version, stream_size);\n    /* To do: ignore strm->next_in if we use it as window */\n}\n\n/* ========================================================================= */\nint ZEXPORT deflateInit2_(z_streamp strm, int level, int method,\n                          int windowBits, int memLevel, int strategy,\n                          const char *version, int stream_size) {\n    deflate_state *s;\n    int wrap = 1;\n    static const char my_version[] = ZLIB_VERSION;\n\n    if (version == Z_NULL || version[0] != my_version[0] ||\n        stream_size != sizeof(z_stream)) {\n        return Z_VERSION_ERROR;\n    }\n    if (strm == Z_NULL) return Z_STREAM_ERROR;\n\n    strm->msg = Z_NULL;\n    if (strm->zalloc == (alloc_func)0) {\n#ifdef Z_SOLO\n        return Z_STREAM_ERROR;\n#else\n        strm->zalloc = zcalloc;\n        strm->opaque = (voidpf)0;\n#endif\n    }\n    if (strm->zfree == (free_func)0)\n#ifdef Z_SOLO\n        return Z_STREAM_ERROR;\n#else\n        strm->zfree = zcfree;\n#endif\n\n#ifdef FASTEST\n    if (level != 0) level = 1;\n#else\n    if (level == Z_DEFAULT_COMPRESSION) level = 6;\n#endif\n\n    if (windowBits < 0) { /* suppress zlib wrapper */\n        wrap = 0;\n        if (windowBits < -15)\n            return Z_STREAM_ERROR;\n        windowBits = -windowBits;\n    }\n#ifdef GZIP\n    else if (windowBits > 15) {\n        wrap = 2;       /* write gzip wrapper instead */\n        windowBits -= 16;\n    }\n#endif\n    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED ||\n        windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||\n        strategy < 0 || strategy > Z_FIXED || (windowBits == 8 && wrap != 1)) {\n        return Z_STREAM_ERROR;\n    }\n    if (windowBits == 8) windowBits = 9;  /* until 256-byte window bug fixed */\n    s = (deflate_state *) ZALLOC(strm, 1, sizeof(deflate_state));\n    if (s == Z_NULL) return Z_MEM_ERROR;\n    strm->state = (struct internal_state FAR *)s;\n    s->strm = strm;\n    s->status = INIT_STATE;     /* to pass state test in deflateReset() */\n\n    s->wrap = wrap;\n    s->gzhead = Z_NULL;\n    s->w_bits = (uInt)windowBits;\n    s->w_size = 1 << s->w_bits;\n    s->w_mask = s->w_size - 1;\n\n    s->hash_bits = (uInt)memLevel + 7;\n    s->hash_size = 1 << s->hash_bits;\n    s->hash_mask = s->hash_size - 1;\n    s->hash_shift =  ((s->hash_bits + MIN_MATCH-1) / MIN_MATCH);\n\n    s->window = (Bytef *) ZALLOC(strm, s->w_size, 2*sizeof(Byte));\n    s->prev   = (Posf *)  ZALLOC(strm, s->w_size, sizeof(Pos));\n    s->head   = (Posf *)  ZALLOC(strm, s->hash_size, sizeof(Pos));\n\n    s->high_water = 0;      /* nothing written to s->window yet */\n\n    s->lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */\n\n    /* We overlay pending_buf and sym_buf. This works since the average size\n     * for length/distance pairs over any compressed block is assured to be 31\n     * bits or less.\n     *\n     * Analysis: The longest fixed codes are a length code of 8 bits plus 5\n     * extra bits, for lengths 131 to 257. The longest fixed distance codes are\n     * 5 bits plus 13 extra bits, for distances 16385 to 32768. The longest\n     * possible fixed-codes length/distance pair is then 31 bits total.\n     *\n     * sym_buf starts one-fourth of the way into pending_buf. So there are\n     * three bytes in sym_buf for every four bytes in pending_buf. Each symbol\n     * in sym_buf is three bytes -- two for the distance and one for the\n     * literal/length. As each symbol is consumed, the pointer to the next\n     * sym_buf value to read moves forward three bytes. From that symbol, up to\n     * 31 bits are written to pending_buf. The closest the written pending_buf\n     * bits gets to the next sym_buf symbol to read is just before the last\n     * code is written. At that time, 31*(n - 2) bits have been written, just\n     * after 24*(n - 2) bits have been consumed from sym_buf. sym_buf starts at\n     * 8*n bits into pending_buf. (Note that the symbol buffer fills when n - 1\n     * symbols are written.) The closest the writing gets to what is unread is\n     * then n + 14 bits. Here n is lit_bufsize, which is 16384 by default, and\n     * can range from 128 to 32768.\n     *\n     * Therefore, at a minimum, there are 142 bits of space between what is\n     * written and what is read in the overlain buffers, so the symbols cannot\n     * be overwritten by the compressed data. That space is actually 139 bits,\n     * due to the three-bit fixed-code block header.\n     *\n     * That covers the case where either Z_FIXED is specified, forcing fixed\n     * codes, or when the use of fixed codes is chosen, because that choice\n     * results in a smaller compressed block than dynamic codes. That latter\n     * condition then assures that the above analysis also covers all dynamic\n     * blocks. A dynamic-code block will only be chosen to be emitted if it has\n     * fewer bits than a fixed-code block would for the same set of symbols.\n     * Therefore its average symbol length is assured to be less than 31. So\n     * the compressed data for a dynamic block also cannot overwrite the\n     * symbols from which it is being constructed.\n     */\n\n    s->pending_buf = (uchf *) ZALLOC(strm, s->lit_bufsize, LIT_BUFS);\n    s->pending_buf_size = (ulg)s->lit_bufsize * 4;\n\n    if (s->window == Z_NULL || s->prev == Z_NULL || s->head == Z_NULL ||\n        s->pending_buf == Z_NULL) {\n        s->status = FINISH_STATE;\n        strm->msg = ERR_MSG(Z_MEM_ERROR);\n        deflateEnd (strm);\n        return Z_MEM_ERROR;\n    }\n#ifdef LIT_MEM\n    s->d_buf = (ushf *)(s->pending_buf + (s->lit_bufsize << 1));\n    s->l_buf = s->pending_buf + (s->lit_bufsize << 2);\n    s->sym_end = s->lit_bufsize - 1;\n#else\n    s->sym_buf = s->pending_buf + s->lit_bufsize;\n    s->sym_end = (s->lit_bufsize - 1) * 3;\n#endif\n    /* We avoid equality with lit_bufsize*3 because of wraparound at 64K\n     * on 16 bit machines and because stored blocks are restricted to\n     * 64K-1 bytes.\n     */\n\n    s->level = level;\n    s->strategy = strategy;\n    s->method = (Byte)method;\n\n    return deflateReset(strm);\n}\n\n/* =========================================================================\n * Check for a valid deflate stream state. Return 0 if ok, 1 if not.\n */\nlocal int deflateStateCheck(z_streamp strm) {\n    deflate_state *s;\n    if (strm == Z_NULL ||\n        strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0)\n        return 1;\n    s = strm->state;\n    if (s == Z_NULL || s->strm != strm || (s->status != INIT_STATE &&\n#ifdef GZIP\n                                           s->status != GZIP_STATE &&\n#endif\n                                           s->status != EXTRA_STATE &&\n                                           s->status != NAME_STATE &&\n                                           s->status != COMMENT_STATE &&\n                                           s->status != HCRC_STATE &&\n                                           s->status != BUSY_STATE &&\n                                           s->status != FINISH_STATE))\n        return 1;\n    return 0;\n}\n\n/* ========================================================================= */\nint ZEXPORT deflateSetDictionary(z_streamp strm, const Bytef *dictionary,\n                                 uInt  dictLength) {\n    deflate_state *s;\n    uInt str, n;\n    int wrap;\n    unsigned avail;\n    z_const unsigned char *next;\n\n    if (deflateStateCheck(strm) || dictionary == Z_NULL)\n        return Z_STREAM_ERROR;\n    s = strm->state;\n    wrap = s->wrap;\n    if (wrap == 2 || (wrap == 1 && s->status != INIT_STATE) || s->lookahead)\n        return Z_STREAM_ERROR;\n\n    /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n    if (wrap == 1)\n        strm->adler = adler32(strm->adler, dictionary, dictLength);\n    s->wrap = 0;                    /* avoid computing Adler-32 in read_buf */\n\n    /* if dictionary would fill window, just replace the history */\n    if (dictLength >= s->w_size) {\n        if (wrap == 0) {            /* already empty otherwise */\n            CLEAR_HASH(s);\n            s->strstart = 0;\n            s->block_start = 0L;\n            s->insert = 0;\n        }\n        dictionary += dictLength - s->w_size;  /* use the tail */\n        dictLength = s->w_size;\n    }\n\n    /* insert dictionary into window and hash */\n    avail = strm->avail_in;\n    next = strm->next_in;\n    strm->avail_in = dictLength;\n    strm->next_in = (z_const Bytef *)dictionary;\n    fill_window(s);\n    while (s->lookahead >= MIN_MATCH) {\n        str = s->strstart;\n        n = s->lookahead - (MIN_MATCH-1);\n        do {\n            UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]);\n#ifndef FASTEST\n            s->prev[str & s->w_mask] = s->head[s->ins_h];\n#endif\n            s->head[s->ins_h] = (Pos)str;\n            str++;\n        } while (--n);\n        s->strstart = str;\n        s->lookahead = MIN_MATCH-1;\n        fill_window(s);\n    }\n    s->strstart += s->lookahead;\n    s->block_start = (long)s->strstart;\n    s->insert = s->lookahead;\n    s->lookahead = 0;\n    s->match_length = s->prev_length = MIN_MATCH-1;\n    s->match_available = 0;\n    strm->next_in = next;\n    strm->avail_in = avail;\n    s->wrap = wrap;\n    return Z_OK;\n}\n\n/* ========================================================================= */\nint ZEXPORT deflateGetDictionary(z_streamp strm, Bytef *dictionary,\n                                 uInt *dictLength) {\n    deflate_state *s;\n    uInt len;\n\n    if (deflateStateCheck(strm))\n        return Z_STREAM_ERROR;\n    s = strm->state;\n    len = s->strstart + s->lookahead;\n    if (len > s->w_size)\n        len = s->w_size;\n    if (dictionary != Z_NULL && len)\n        zmemcpy(dictionary, s->window + s->strstart + s->lookahead - len, len);\n    if (dictLength != Z_NULL)\n        *dictLength = len;\n    return Z_OK;\n}\n\n/* ========================================================================= */\nint ZEXPORT deflateResetKeep(z_streamp strm) {\n    deflate_state *s;\n\n    if (deflateStateCheck(strm)) {\n        return Z_STREAM_ERROR;\n    }\n\n    strm->total_in = strm->total_out = 0;\n    strm->msg = Z_NULL; /* use zfree if we ever allocate msg dynamically */\n    strm->data_type = Z_UNKNOWN;\n\n    s = (deflate_state *)strm->state;\n    s->pending = 0;\n    s->pending_out = s->pending_buf;\n\n    if (s->wrap < 0) {\n        s->wrap = -s->wrap; /* was made negative by deflate(..., Z_FINISH); */\n    }\n    s->status =\n#ifdef GZIP\n        s->wrap == 2 ? GZIP_STATE :\n#endif\n        INIT_STATE;\n    strm->adler =\n#ifdef GZIP\n        s->wrap == 2 ? crc32(0L, Z_NULL, 0) :\n#endif\n        adler32(0L, Z_NULL, 0);\n    s->last_flush = -2;\n\n    _tr_init(s);\n\n    return Z_OK;\n}\n\n/* ===========================================================================\n * Initialize the \"longest match\" routines for a new zlib stream\n */\nlocal void lm_init(deflate_state *s) {\n    s->window_size = (ulg)2L*s->w_size;\n\n    CLEAR_HASH(s);\n\n    /* Set the default configuration parameters:\n     */\n    s->max_lazy_match   = configuration_table[s->level].max_lazy;\n    s->good_match       = configuration_table[s->level].good_length;\n    s->nice_match       = configuration_table[s->level].nice_length;\n    s->max_chain_length = configuration_table[s->level].max_chain;\n\n    s->strstart = 0;\n    s->block_start = 0L;\n    s->lookahead = 0;\n    s->insert = 0;\n    s->match_length = s->prev_length = MIN_MATCH-1;\n    s->match_available = 0;\n    s->ins_h = 0;\n}\n\n/* ========================================================================= */\nint ZEXPORT deflateReset(z_streamp strm) {\n    int ret;\n\n    ret = deflateResetKeep(strm);\n    if (ret == Z_OK)\n        lm_init(strm->state);\n    return ret;\n}\n\n/* ========================================================================= */\nint ZEXPORT deflateSetHeader(z_streamp strm, gz_headerp head) {\n    if (deflateStateCheck(strm) || strm->state->wrap != 2)\n        return Z_STREAM_ERROR;\n    strm->state->gzhead = head;\n    return Z_OK;\n}\n\n/* ========================================================================= */\nint ZEXPORT deflatePending(z_streamp strm, unsigned *pending, int *bits) {\n    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;\n    if (pending != Z_NULL)\n        *pending = strm->state->pending;\n    if (bits != Z_NULL)\n        *bits = strm->state->bi_valid;\n    return Z_OK;\n}\n\n/* ========================================================================= */\nint ZEXPORT deflateUsed(z_streamp strm, int *bits) {\n    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;\n    if (bits != Z_NULL)\n        *bits = strm->state->bi_used;\n    return Z_OK;\n}\n\n/* ========================================================================= */\nint ZEXPORT deflatePrime(z_streamp strm, int bits, int value) {\n    deflate_state *s;\n    int put;\n\n    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;\n    s = strm->state;\n#ifdef LIT_MEM\n    if (bits < 0 || bits > 16 ||\n        (uchf *)s->d_buf < s->pending_out + ((Buf_size + 7) >> 3))\n        return Z_BUF_ERROR;\n#else\n    if (bits < 0 || bits > 16 ||\n        s->sym_buf < s->pending_out + ((Buf_size + 7) >> 3))\n        return Z_BUF_ERROR;\n#endif\n    do {\n        put = Buf_size - s->bi_valid;\n        if (put > bits)\n            put = bits;\n        s->bi_buf |= (ush)((value & ((1 << put) - 1)) << s->bi_valid);\n        s->bi_valid += put;\n        _tr_flush_bits(s);\n        value >>= put;\n        bits -= put;\n    } while (bits);\n    return Z_OK;\n}\n\n/* ========================================================================= */\nint ZEXPORT deflateParams(z_streamp strm, int level, int strategy) {\n    deflate_state *s;\n    compress_func func;\n\n    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;\n    s = strm->state;\n\n#ifdef FASTEST\n    if (level != 0) level = 1;\n#else\n    if (level == Z_DEFAULT_COMPRESSION) level = 6;\n#endif\n    if (level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {\n        return Z_STREAM_ERROR;\n    }\n    func = configuration_table[s->level].func;\n\n    if ((strategy != s->strategy || func != configuration_table[level].func) &&\n        s->last_flush != -2) {\n        /* Flush the last buffer: */\n        int err = deflate(strm, Z_BLOCK);\n        if (err == Z_STREAM_ERROR)\n            return err;\n        if (strm->avail_in || (s->strstart - s->block_start) + s->lookahead)\n            return Z_BUF_ERROR;\n    }\n    if (s->level != level) {\n        if (s->level == 0 && s->matches != 0) {\n            if (s->matches == 1)\n                slide_hash(s);\n            else\n                CLEAR_HASH(s);\n            s->matches = 0;\n        }\n        s->level = level;\n        s->max_lazy_match   = configuration_table[level].max_lazy;\n        s->good_match       = configuration_table[level].good_length;\n        s->nice_match       = configuration_table[level].nice_length;\n        s->max_chain_length = configuration_table[level].max_chain;\n    }\n    s->strategy = strategy;\n    return Z_OK;\n}\n\n/* ========================================================================= */\nint ZEXPORT deflateTune(z_streamp strm, int good_length, int max_lazy,\n                        int nice_length, int max_chain) {\n    deflate_state *s;\n\n    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;\n    s = strm->state;\n    s->good_match = (uInt)good_length;\n    s->max_lazy_match = (uInt)max_lazy;\n    s->nice_match = nice_length;\n    s->max_chain_length = (uInt)max_chain;\n    return Z_OK;\n}\n\n/* =========================================================================\n * For the default windowBits of 15 and memLevel of 8, this function returns a\n * close to exact, as well as small, upper bound on the compressed size. This\n * is an expansion of ~0.03%, plus a small constant.\n *\n * For any setting other than those defaults for windowBits and memLevel, one\n * of two worst case bounds is returned. This is at most an expansion of ~4% or\n * ~13%, plus a small constant.\n *\n * Both the 0.03% and 4% derive from the overhead of stored blocks. The first\n * one is for stored blocks of 16383 bytes (memLevel == 8), whereas the second\n * is for stored blocks of 127 bytes (the worst case memLevel == 1). The\n * expansion results from five bytes of header for each stored block.\n *\n * The larger expansion of 13% results from a window size less than or equal to\n * the symbols buffer size (windowBits <= memLevel + 7). In that case some of\n * the data being compressed may have slid out of the sliding window, impeding\n * a stored block from being emitted. Then the only choice is a fixed or\n * dynamic block, where a fixed block limits the maximum expansion to 9 bits\n * per 8-bit byte, plus 10 bits for every block. The smallest block size for\n * which this can occur is 255 (memLevel == 2).\n *\n * Shifts are used to approximate divisions, for speed.\n */\nuLong ZEXPORT deflateBound(z_streamp strm, uLong sourceLen) {\n    deflate_state *s;\n    uLong fixedlen, storelen, wraplen;\n\n    /* upper bound for fixed blocks with 9-bit literals and length 255\n       (memLevel == 2, which is the lowest that may not use stored blocks) --\n       ~13% overhead plus a small constant */\n    fixedlen = sourceLen + (sourceLen >> 3) + (sourceLen >> 8) +\n               (sourceLen >> 9) + 4;\n\n    /* upper bound for stored blocks with length 127 (memLevel == 1) --\n       ~4% overhead plus a small constant */\n    storelen = sourceLen + (sourceLen >> 5) + (sourceLen >> 7) +\n               (sourceLen >> 11) + 7;\n\n    /* if can't get parameters, return larger bound plus a wrapper */\n    if (deflateStateCheck(strm))\n        return (fixedlen > storelen ? fixedlen : storelen) + 18;\n\n    /* compute wrapper length */\n    s = strm->state;\n    switch (s->wrap < 0 ? -s->wrap : s->wrap) {\n    case 0:                                 /* raw deflate */\n        wraplen = 0;\n        break;\n    case 1:                                 /* zlib wrapper */\n        wraplen = 6 + (s->strstart ? 4 : 0);\n        break;\n#ifdef GZIP\n    case 2:                                 /* gzip wrapper */\n        wraplen = 18;\n        if (s->gzhead != Z_NULL) {          /* user-supplied gzip header */\n            Bytef *str;\n            if (s->gzhead->extra != Z_NULL)\n                wraplen += 2 + s->gzhead->extra_len;\n            str = s->gzhead->name;\n            if (str != Z_NULL)\n                do {\n                    wraplen++;\n                } while (*str++);\n            str = s->gzhead->comment;\n            if (str != Z_NULL)\n                do {\n                    wraplen++;\n                } while (*str++);\n            if (s->gzhead->hcrc)\n                wraplen += 2;\n        }\n        break;\n#endif\n    default:                                /* for compiler happiness */\n        wraplen = 18;\n    }\n\n    /* if not default parameters, return one of the conservative bounds */\n    if (s->w_bits != 15 || s->hash_bits != 8 + 7)\n        return (s->w_bits <= s->hash_bits && s->level ? fixedlen : storelen) +\n               wraplen;\n\n    /* default settings: return tight bound for that case -- ~0.03% overhead\n       plus a small constant */\n    return sourceLen + (sourceLen >> 12) + (sourceLen >> 14) +\n           (sourceLen >> 25) + 13 - 6 + wraplen;\n}\n\n/* =========================================================================\n * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n * IN assertion: the stream state is correct and there is enough room in\n * pending_buf.\n */\nlocal void putShortMSB(deflate_state *s, uInt b) {\n    put_byte(s, (Byte)(b >> 8));\n    put_byte(s, (Byte)(b & 0xff));\n}\n\n/* =========================================================================\n * Flush as much pending output as possible. All deflate() output, except for\n * some deflate_stored() output, goes through this function so some\n * applications may wish to modify it to avoid allocating a large\n * strm->next_out buffer and copying into it. (See also read_buf()).\n */\nlocal void flush_pending(z_streamp strm) {\n    unsigned len;\n    deflate_state *s = strm->state;\n\n    _tr_flush_bits(s);\n    len = s->pending;\n    if (len > strm->avail_out) len = strm->avail_out;\n    if (len == 0) return;\n\n    zmemcpy(strm->next_out, s->pending_out, len);\n    strm->next_out  += len;\n    s->pending_out  += len;\n    strm->total_out += len;\n    strm->avail_out -= len;\n    s->pending      -= len;\n    if (s->pending == 0) {\n        s->pending_out = s->pending_buf;\n    }\n}\n\n/* ===========================================================================\n * Update the header CRC with the bytes s->pending_buf[beg..s->pending - 1].\n */\n#define HCRC_UPDATE(beg) \\\n    do { \\\n        if (s->gzhead->hcrc && s->pending > (beg)) \\\n            strm->adler = crc32(strm->adler, s->pending_buf + (beg), \\\n                                s->pending - (beg)); \\\n    } while (0)\n\n/* ========================================================================= */\nint ZEXPORT deflate(z_streamp strm, int flush) {\n    int old_flush; /* value of flush param for previous deflate call */\n    deflate_state *s;\n\n    if (deflateStateCheck(strm) || flush > Z_BLOCK || flush < 0) {\n        return Z_STREAM_ERROR;\n    }\n    s = strm->state;\n\n    if (strm->next_out == Z_NULL ||\n        (strm->avail_in != 0 && strm->next_in == Z_NULL) ||\n        (s->status == FINISH_STATE && flush != Z_FINISH)) {\n        ERR_RETURN(strm, Z_STREAM_ERROR);\n    }\n    if (strm->avail_out == 0) ERR_RETURN(strm, Z_BUF_ERROR);\n\n    old_flush = s->last_flush;\n    s->last_flush = flush;\n\n    /* Flush as much pending output as possible */\n    if (s->pending != 0) {\n        flush_pending(strm);\n        if (strm->avail_out == 0) {\n            /* Since avail_out is 0, deflate will be called again with\n             * more output space, but possibly with both pending and\n             * avail_in equal to zero. There won't be anything to do,\n             * but this is not an error situation so make sure we\n             * return OK instead of BUF_ERROR at next call of deflate:\n             */\n            s->last_flush = -1;\n            return Z_OK;\n        }\n\n    /* Make sure there is something to do and avoid duplicate consecutive\n     * flushes. For repeated and useless calls with Z_FINISH, we keep\n     * returning Z_STREAM_END instead of Z_BUF_ERROR.\n     */\n    } else if (strm->avail_in == 0 && RANK(flush) <= RANK(old_flush) &&\n               flush != Z_FINISH) {\n        ERR_RETURN(strm, Z_BUF_ERROR);\n    }\n\n    /* User must not provide more input after the first FINISH: */\n    if (s->status == FINISH_STATE && strm->avail_in != 0) {\n        ERR_RETURN(strm, Z_BUF_ERROR);\n    }\n\n    /* Write the header */\n    if (s->status == INIT_STATE && s->wrap == 0)\n        s->status = BUSY_STATE;\n    if (s->status == INIT_STATE) {\n        /* zlib header */\n        uInt header = (Z_DEFLATED + ((s->w_bits - 8) << 4)) << 8;\n        uInt level_flags;\n\n        if (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2)\n            level_flags = 0;\n        else if (s->level < 6)\n            level_flags = 1;\n        else if (s->level == 6)\n            level_flags = 2;\n        else\n            level_flags = 3;\n        header |= (level_flags << 6);\n        if (s->strstart != 0) header |= PRESET_DICT;\n        header += 31 - (header % 31);\n\n        putShortMSB(s, header);\n\n        /* Save the adler32 of the preset dictionary: */\n        if (s->strstart != 0) {\n            putShortMSB(s, (uInt)(strm->adler >> 16));\n            putShortMSB(s, (uInt)(strm->adler & 0xffff));\n        }\n        strm->adler = adler32(0L, Z_NULL, 0);\n        s->status = BUSY_STATE;\n\n        /* Compression must start with an empty pending buffer */\n        flush_pending(strm);\n        if (s->pending != 0) {\n            s->last_flush = -1;\n            return Z_OK;\n        }\n    }\n#ifdef GZIP\n    if (s->status == GZIP_STATE) {\n        /* gzip header */\n        strm->adler = crc32(0L, Z_NULL, 0);\n        put_byte(s, 31);\n        put_byte(s, 139);\n        put_byte(s, 8);\n        if (s->gzhead == Z_NULL) {\n            put_byte(s, 0);\n            put_byte(s, 0);\n            put_byte(s, 0);\n            put_byte(s, 0);\n            put_byte(s, 0);\n            put_byte(s, s->level == 9 ? 2 :\n                     (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?\n                      4 : 0));\n            put_byte(s, OS_CODE);\n            s->status = BUSY_STATE;\n\n            /* Compression must start with an empty pending buffer */\n            flush_pending(strm);\n            if (s->pending != 0) {\n                s->last_flush = -1;\n                return Z_OK;\n            }\n        }\n        else {\n            put_byte(s, (s->gzhead->text ? 1 : 0) +\n                     (s->gzhead->hcrc ? 2 : 0) +\n                     (s->gzhead->extra == Z_NULL ? 0 : 4) +\n                     (s->gzhead->name == Z_NULL ? 0 : 8) +\n                     (s->gzhead->comment == Z_NULL ? 0 : 16)\n                     );\n            put_byte(s, (Byte)(s->gzhead->time & 0xff));\n            put_byte(s, (Byte)((s->gzhead->time >> 8) & 0xff));\n            put_byte(s, (Byte)((s->gzhead->time >> 16) & 0xff));\n            put_byte(s, (Byte)((s->gzhead->time >> 24) & 0xff));\n            put_byte(s, s->level == 9 ? 2 :\n                     (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?\n                      4 : 0));\n            put_byte(s, s->gzhead->os & 0xff);\n            if (s->gzhead->extra != Z_NULL) {\n                put_byte(s, s->gzhead->extra_len & 0xff);\n                put_byte(s, (s->gzhead->extra_len >> 8) & 0xff);\n            }\n            if (s->gzhead->hcrc)\n                strm->adler = crc32(strm->adler, s->pending_buf,\n                                    s->pending);\n            s->gzindex = 0;\n            s->status = EXTRA_STATE;\n        }\n    }\n    if (s->status == EXTRA_STATE) {\n        if (s->gzhead->extra != Z_NULL) {\n            ulg beg = s->pending;   /* start of bytes to update crc */\n            uInt left = (s->gzhead->extra_len & 0xffff) - s->gzindex;\n            while (s->pending + left > s->pending_buf_size) {\n                uInt copy = s->pending_buf_size - s->pending;\n                zmemcpy(s->pending_buf + s->pending,\n                        s->gzhead->extra + s->gzindex, copy);\n                s->pending = s->pending_buf_size;\n                HCRC_UPDATE(beg);\n                s->gzindex += copy;\n                flush_pending(strm);\n                if (s->pending != 0) {\n                    s->last_flush = -1;\n                    return Z_OK;\n                }\n                beg = 0;\n                left -= copy;\n            }\n            zmemcpy(s->pending_buf + s->pending,\n                    s->gzhead->extra + s->gzindex, left);\n            s->pending += left;\n            HCRC_UPDATE(beg);\n            s->gzindex = 0;\n        }\n        s->status = NAME_STATE;\n    }\n    if (s->status == NAME_STATE) {\n        if (s->gzhead->name != Z_NULL) {\n            ulg beg = s->pending;   /* start of bytes to update crc */\n            int val;\n            do {\n                if (s->pending == s->pending_buf_size) {\n                    HCRC_UPDATE(beg);\n                    flush_pending(strm);\n                    if (s->pending != 0) {\n                        s->last_flush = -1;\n                        return Z_OK;\n                    }\n                    beg = 0;\n                }\n                val = s->gzhead->name[s->gzindex++];\n                put_byte(s, val);\n            } while (val != 0);\n            HCRC_UPDATE(beg);\n            s->gzindex = 0;\n        }\n        s->status = COMMENT_STATE;\n    }\n    if (s->status == COMMENT_STATE) {\n        if (s->gzhead->comment != Z_NULL) {\n            ulg beg = s->pending;   /* start of bytes to update crc */\n            int val;\n            do {\n                if (s->pending == s->pending_buf_size) {\n                    HCRC_UPDATE(beg);\n                    flush_pending(strm);\n                    if (s->pending != 0) {\n                        s->last_flush = -1;\n                        return Z_OK;\n                    }\n                    beg = 0;\n                }\n                val = s->gzhead->comment[s->gzindex++];\n                put_byte(s, val);\n            } while (val != 0);\n            HCRC_UPDATE(beg);\n        }\n        s->status = HCRC_STATE;\n    }\n    if (s->status == HCRC_STATE) {\n        if (s->gzhead->hcrc) {\n            if (s->pending + 2 > s->pending_buf_size) {\n                flush_pending(strm);\n                if (s->pending != 0) {\n                    s->last_flush = -1;\n                    return Z_OK;\n                }\n            }\n            put_byte(s, (Byte)(strm->adler & 0xff));\n            put_byte(s, (Byte)((strm->adler >> 8) & 0xff));\n            strm->adler = crc32(0L, Z_NULL, 0);\n        }\n        s->status = BUSY_STATE;\n\n        /* Compression must start with an empty pending buffer */\n        flush_pending(strm);\n        if (s->pending != 0) {\n            s->last_flush = -1;\n            return Z_OK;\n        }\n    }\n#endif\n\n    /* Start a new block or continue the current one.\n     */\n    if (strm->avail_in != 0 || s->lookahead != 0 ||\n        (flush != Z_NO_FLUSH && s->status != FINISH_STATE)) {\n        block_state bstate;\n\n        bstate = s->level == 0 ? deflate_stored(s, flush) :\n                 s->strategy == Z_HUFFMAN_ONLY ? deflate_huff(s, flush) :\n                 s->strategy == Z_RLE ? deflate_rle(s, flush) :\n                 (*(configuration_table[s->level].func))(s, flush);\n\n        if (bstate == finish_started || bstate == finish_done) {\n            s->status = FINISH_STATE;\n        }\n        if (bstate == need_more || bstate == finish_started) {\n            if (strm->avail_out == 0) {\n                s->last_flush = -1; /* avoid BUF_ERROR next call, see above */\n            }\n            return Z_OK;\n            /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n             * of deflate should use the same flush parameter to make sure\n             * that the flush is complete. So we don't have to output an\n             * empty block here, this will be done at next call. This also\n             * ensures that for a very small output buffer, we emit at most\n             * one empty block.\n             */\n        }\n        if (bstate == block_done) {\n            if (flush == Z_PARTIAL_FLUSH) {\n                _tr_align(s);\n            } else if (flush != Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */\n                _tr_stored_block(s, (char*)0, 0L, 0);\n                /* For a full flush, this empty block will be recognized\n                 * as a special marker by inflate_sync().\n                 */\n                if (flush == Z_FULL_FLUSH) {\n                    CLEAR_HASH(s);             /* forget history */\n                    if (s->lookahead == 0) {\n                        s->strstart = 0;\n                        s->block_start = 0L;\n                        s->insert = 0;\n                    }\n                }\n            }\n            flush_pending(strm);\n            if (strm->avail_out == 0) {\n              s->last_flush = -1; /* avoid BUF_ERROR at next call, see above */\n              return Z_OK;\n            }\n        }\n    }\n\n    if (flush != Z_FINISH) return Z_OK;\n    if (s->wrap <= 0) return Z_STREAM_END;\n\n    /* Write the trailer */\n#ifdef GZIP\n    if (s->wrap == 2) {\n        put_byte(s, (Byte)(strm->adler & 0xff));\n        put_byte(s, (Byte)((strm->adler >> 8) & 0xff));\n        put_byte(s, (Byte)((strm->adler >> 16) & 0xff));\n        put_byte(s, (Byte)((strm->adler >> 24) & 0xff));\n        put_byte(s, (Byte)(strm->total_in & 0xff));\n        put_byte(s, (Byte)((strm->total_in >> 8) & 0xff));\n        put_byte(s, (Byte)((strm->total_in >> 16) & 0xff));\n        put_byte(s, (Byte)((strm->total_in >> 24) & 0xff));\n    }\n    else\n#endif\n    {\n        putShortMSB(s, (uInt)(strm->adler >> 16));\n        putShortMSB(s, (uInt)(strm->adler & 0xffff));\n    }\n    flush_pending(strm);\n    /* If avail_out is zero, the application will call deflate again\n     * to flush the rest.\n     */\n    if (s->wrap > 0) s->wrap = -s->wrap; /* write the trailer only once! */\n    return s->pending != 0 ? Z_OK : Z_STREAM_END;\n}\n\n/* ========================================================================= */\nint ZEXPORT deflateEnd(z_streamp strm) {\n    int status;\n\n    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;\n\n    status = strm->state->status;\n\n    /* Deallocate in reverse order of allocations: */\n    TRY_FREE(strm, strm->state->pending_buf);\n    TRY_FREE(strm, strm->state->head);\n    TRY_FREE(strm, strm->state->prev);\n    TRY_FREE(strm, strm->state->window);\n\n    ZFREE(strm, strm->state);\n    strm->state = Z_NULL;\n\n    return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;\n}\n\n/* =========================================================================\n * Copy the source state to the destination state.\n * To simplify the source, this is not supported for 16-bit MSDOS (which\n * doesn't have enough memory anyway to duplicate compression states).\n */\nint ZEXPORT deflateCopy(z_streamp dest, z_streamp source) {\n#ifdef MAXSEG_64K\n    (void)dest;\n    (void)source;\n    return Z_STREAM_ERROR;\n#else\n    deflate_state *ds;\n    deflate_state *ss;\n\n\n    if (deflateStateCheck(source) || dest == Z_NULL) {\n        return Z_STREAM_ERROR;\n    }\n\n    ss = source->state;\n\n    zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));\n\n    ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));\n    if (ds == Z_NULL) return Z_MEM_ERROR;\n    dest->state = (struct internal_state FAR *) ds;\n    zmemcpy((voidpf)ds, (voidpf)ss, sizeof(deflate_state));\n    ds->strm = dest;\n\n    ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));\n    ds->prev   = (Posf *)  ZALLOC(dest, ds->w_size, sizeof(Pos));\n    ds->head   = (Posf *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));\n    ds->pending_buf = (uchf *) ZALLOC(dest, ds->lit_bufsize, LIT_BUFS);\n\n    if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL ||\n        ds->pending_buf == Z_NULL) {\n        deflateEnd (dest);\n        return Z_MEM_ERROR;\n    }\n    /* following zmemcpy do not work for 16-bit MSDOS */\n    zmemcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(Byte));\n    zmemcpy((voidpf)ds->prev, (voidpf)ss->prev, ds->w_size * sizeof(Pos));\n    zmemcpy((voidpf)ds->head, (voidpf)ss->head, ds->hash_size * sizeof(Pos));\n    zmemcpy(ds->pending_buf, ss->pending_buf, ds->lit_bufsize * LIT_BUFS);\n\n    ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);\n#ifdef LIT_MEM\n    ds->d_buf = (ushf *)(ds->pending_buf + (ds->lit_bufsize << 1));\n    ds->l_buf = ds->pending_buf + (ds->lit_bufsize << 2);\n#else\n    ds->sym_buf = ds->pending_buf + ds->lit_bufsize;\n#endif\n\n    ds->l_desc.dyn_tree = ds->dyn_ltree;\n    ds->d_desc.dyn_tree = ds->dyn_dtree;\n    ds->bl_desc.dyn_tree = ds->bl_tree;\n\n    return Z_OK;\n#endif /* MAXSEG_64K */\n}\n\n#ifndef FASTEST\n/* ===========================================================================\n * Set match_start to the longest match starting at the given string and\n * return its length. Matches shorter or equal to prev_length are discarded,\n * in which case the result is equal to prev_length and match_start is\n * garbage.\n * IN assertions: cur_match is the head of the hash chain for the current\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n * OUT assertion: the match length is not greater than s->lookahead.\n */\nlocal uInt longest_match(deflate_state *s, IPos cur_match) {\n    unsigned chain_length = s->max_chain_length;/* max hash chain length */\n    register Bytef *scan = s->window + s->strstart; /* current string */\n    register Bytef *match;                      /* matched string */\n    register int len;                           /* length of current match */\n    int best_len = (int)s->prev_length;         /* best match length so far */\n    int nice_match = s->nice_match;             /* stop if match long enough */\n    IPos limit = s->strstart > (IPos)MAX_DIST(s) ?\n        s->strstart - (IPos)MAX_DIST(s) : NIL;\n    /* Stop when cur_match becomes <= limit. To simplify the code,\n     * we prevent matches with the string of window index 0.\n     */\n    Posf *prev = s->prev;\n    uInt wmask = s->w_mask;\n\n#ifdef UNALIGNED_OK\n    /* Compare two bytes at a time. Note: this is not always beneficial.\n     * Try with and without -DUNALIGNED_OK to check.\n     */\n    register Bytef *strend = s->window + s->strstart + MAX_MATCH - 1;\n    register ush scan_start = *(ushf*)scan;\n    register ush scan_end   = *(ushf*)(scan + best_len - 1);\n#else\n    register Bytef *strend = s->window + s->strstart + MAX_MATCH;\n    register Byte scan_end1  = scan[best_len - 1];\n    register Byte scan_end   = scan[best_len];\n#endif\n\n    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n     * It is easy to get rid of this optimization if necessary.\n     */\n    Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n    /* Do not waste too much time if we already have a good match: */\n    if (s->prev_length >= s->good_match) {\n        chain_length >>= 2;\n    }\n    /* Do not look for matches beyond the end of the input. This is necessary\n     * to make deflate deterministic.\n     */\n    if ((uInt)nice_match > s->lookahead) nice_match = (int)s->lookahead;\n\n    Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n           \"need lookahead\");\n\n    do {\n        Assert(cur_match < s->strstart, \"no future\");\n        match = s->window + cur_match;\n\n        /* Skip to next match if the match length cannot increase\n         * or if the match length is less than 2.  Note that the checks below\n         * for insufficient lookahead only occur occasionally for performance\n         * reasons.  Therefore uninitialized memory will be accessed, and\n         * conditional jumps will be made that depend on those values.\n         * However the length of the match is limited to the lookahead, so\n         * the output of deflate is not affected by the uninitialized values.\n         */\n#if (defined(UNALIGNED_OK) && MAX_MATCH == 258)\n        /* This code assumes sizeof(unsigned short) == 2. Do not use\n         * UNALIGNED_OK if your compiler uses a different size.\n         */\n        if (*(ushf*)(match + best_len - 1) != scan_end ||\n            *(ushf*)match != scan_start) continue;\n\n        /* It is not necessary to compare scan[2] and match[2] since they are\n         * always equal when the other bytes match, given that the hash keys\n         * are equal and that HASH_BITS >= 8. Compare 2 bytes at a time at\n         * strstart + 3, + 5, up to strstart + 257. We check for insufficient\n         * lookahead only every 4th comparison; the 128th check will be made\n         * at strstart + 257. If MAX_MATCH-2 is not a multiple of 8, it is\n         * necessary to put more guard bytes at the end of the window, or\n         * to check more often for insufficient lookahead.\n         */\n        Assert(scan[2] == match[2], \"scan[2]?\");\n        scan++, match++;\n        do {\n        } while (*(ushf*)(scan += 2) == *(ushf*)(match += 2) &&\n                 *(ushf*)(scan += 2) == *(ushf*)(match += 2) &&\n                 *(ushf*)(scan += 2) == *(ushf*)(match += 2) &&\n                 *(ushf*)(scan += 2) == *(ushf*)(match += 2) &&\n                 scan < strend);\n        /* The funny \"do {}\" generates better code on most compilers */\n\n        /* Here, scan <= window + strstart + 257 */\n        Assert(scan <= s->window + (unsigned)(s->window_size - 1),\n               \"wild scan\");\n        if (*scan == *match) scan++;\n\n        len = (MAX_MATCH - 1) - (int)(strend - scan);\n        scan = strend - (MAX_MATCH-1);\n\n#else /* UNALIGNED_OK */\n\n        if (match[best_len]     != scan_end  ||\n            match[best_len - 1] != scan_end1 ||\n            *match              != *scan     ||\n            *++match            != scan[1])      continue;\n\n        /* The check at best_len - 1 can be removed because it will be made\n         * again later. (This heuristic is not always a win.)\n         * It is not necessary to compare scan[2] and match[2] since they\n         * are always equal when the other bytes match, given that\n         * the hash keys are equal and that HASH_BITS >= 8.\n         */\n        scan += 2, match++;\n        Assert(*scan == *match, \"match[2]?\");\n\n        /* We check for insufficient lookahead only every 8th comparison;\n         * the 256th check will be made at strstart + 258.\n         */\n        do {\n        } while (*++scan == *++match && *++scan == *++match &&\n                 *++scan == *++match && *++scan == *++match &&\n                 *++scan == *++match && *++scan == *++match &&\n                 *++scan == *++match && *++scan == *++match &&\n                 scan < strend);\n\n        Assert(scan <= s->window + (unsigned)(s->window_size - 1),\n               \"wild scan\");\n\n        len = MAX_MATCH - (int)(strend - scan);\n        scan = strend - MAX_MATCH;\n\n#endif /* UNALIGNED_OK */\n\n        if (len > best_len) {\n            s->match_start = cur_match;\n            best_len = len;\n            if (len >= nice_match) break;\n#ifdef UNALIGNED_OK\n            scan_end = *(ushf*)(scan + best_len - 1);\n#else\n            scan_end1  = scan[best_len - 1];\n            scan_end   = scan[best_len];\n#endif\n        }\n    } while ((cur_match = prev[cur_match & wmask]) > limit\n             && --chain_length != 0);\n\n    if ((uInt)best_len <= s->lookahead) return (uInt)best_len;\n    return s->lookahead;\n}\n\n#else /* FASTEST */\n\n/* ---------------------------------------------------------------------------\n * Optimized version for FASTEST only\n */\nlocal uInt longest_match(deflate_state *s, IPos cur_match) {\n    register Bytef *scan = s->window + s->strstart; /* current string */\n    register Bytef *match;                       /* matched string */\n    register int len;                           /* length of current match */\n    register Bytef *strend = s->window + s->strstart + MAX_MATCH;\n\n    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n     * It is easy to get rid of this optimization if necessary.\n     */\n    Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n    Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n           \"need lookahead\");\n\n    Assert(cur_match < s->strstart, \"no future\");\n\n    match = s->window + cur_match;\n\n    /* Return failure if the match length is less than 2:\n     */\n    if (match[0] != scan[0] || match[1] != scan[1]) return MIN_MATCH-1;\n\n    /* The check at best_len - 1 can be removed because it will be made\n     * again later. (This heuristic is not always a win.)\n     * It is not necessary to compare scan[2] and match[2] since they\n     * are always equal when the other bytes match, given that\n     * the hash keys are equal and that HASH_BITS >= 8.\n     */\n    scan += 2, match += 2;\n    Assert(*scan == *match, \"match[2]?\");\n\n    /* We check for insufficient lookahead only every 8th comparison;\n     * the 256th check will be made at strstart + 258.\n     */\n    do {\n    } while (*++scan == *++match && *++scan == *++match &&\n             *++scan == *++match && *++scan == *++match &&\n             *++scan == *++match && *++scan == *++match &&\n             *++scan == *++match && *++scan == *++match &&\n             scan < strend);\n\n    Assert(scan <= s->window + (unsigned)(s->window_size - 1), \"wild scan\");\n\n    len = MAX_MATCH - (int)(strend - scan);\n\n    if (len < MIN_MATCH) return MIN_MATCH - 1;\n\n    s->match_start = cur_match;\n    return (uInt)len <= s->lookahead ? (uInt)len : s->lookahead;\n}\n\n#endif /* FASTEST */\n\n#ifdef ZLIB_DEBUG\n\n#define EQUAL 0\n/* result of memcmp for equal strings */\n\n/* ===========================================================================\n * Check that the match at match_start is indeed a match.\n */\nlocal void check_match(deflate_state *s, IPos start, IPos match, int length) {\n    /* check that the match is indeed a match */\n    Bytef *back = s->window + (int)match, *here = s->window + start;\n    IPos len = length;\n    if (match == (IPos)-1) {\n        /* match starts one byte before the current window -- just compare the\n           subsequent length-1 bytes */\n        back++;\n        here++;\n        len--;\n    }\n    if (zmemcmp(back, here, len) != EQUAL) {\n        fprintf(stderr, \" start %u, match %d, length %d\\n\",\n                start, (int)match, length);\n        do {\n            fprintf(stderr, \"(%02x %02x)\", *back++, *here++);\n        } while (--len != 0);\n        z_error(\"invalid match\");\n    }\n    if (z_verbose > 1) {\n        fprintf(stderr,\"\\\\[%d,%d]\", start - match, length);\n        do { putc(s->window[start++], stderr); } while (--length != 0);\n    }\n}\n#else\n#  define check_match(s, start, match, length)\n#endif /* ZLIB_DEBUG */\n\n/* ===========================================================================\n * Flush the current block, with given end-of-file flag.\n * IN assertion: strstart is set to the end of the current match.\n */\n#define FLUSH_BLOCK_ONLY(s, last) { \\\n   _tr_flush_block(s, (s->block_start >= 0L ? \\\n                   (charf *)&s->window[(unsigned)s->block_start] : \\\n                   (charf *)Z_NULL), \\\n                (ulg)((long)s->strstart - s->block_start), \\\n                (last)); \\\n   s->block_start = s->strstart; \\\n   flush_pending(s->strm); \\\n   Tracev((stderr,\"[FLUSH]\")); \\\n}\n\n/* Same but force premature exit if necessary. */\n#define FLUSH_BLOCK(s, last) { \\\n   FLUSH_BLOCK_ONLY(s, last); \\\n   if (s->strm->avail_out == 0) return (last) ? finish_started : need_more; \\\n}\n\n/* Maximum stored block length in deflate format (not including header). */\n#define MAX_STORED 65535\n\n/* Minimum of a and b. */\n#define MIN(a, b) ((a) > (b) ? (b) : (a))\n\n/* ===========================================================================\n * Copy without compression as much as possible from the input stream, return\n * the current block state.\n *\n * In case deflateParams() is used to later switch to a non-zero compression\n * level, s->matches (otherwise unused when storing) keeps track of the number\n * of hash table slides to perform. If s->matches is 1, then one hash table\n * slide will be done when switching. If s->matches is 2, the maximum value\n * allowed here, then the hash table will be cleared, since two or more slides\n * is the same as a clear.\n *\n * deflate_stored() is written to minimize the number of times an input byte is\n * copied. It is most efficient with large input and output buffers, which\n * maximizes the opportunities to have a single copy from next_in to next_out.\n */\nlocal block_state deflate_stored(deflate_state *s, int flush) {\n    /* Smallest worthy block size when not flushing or finishing. By default\n     * this is 32K. This can be as small as 507 bytes for memLevel == 1. For\n     * large input and output buffers, the stored block size will be larger.\n     */\n    unsigned min_block = MIN(s->pending_buf_size - 5, s->w_size);\n\n    /* Copy as many min_block or larger stored blocks directly to next_out as\n     * possible. If flushing, copy the remaining available input to next_out as\n     * stored blocks, if there is enough space.\n     */\n    int last = 0;\n    unsigned len, left, have;\n    unsigned used = s->strm->avail_in;\n    do {\n        /* Set len to the maximum size block that we can copy directly with the\n         * available input data and output space. Set left to how much of that\n         * would be copied from what's left in the window.\n         */\n        len = MAX_STORED;       /* maximum deflate stored block length */\n        have = (s->bi_valid + 42) >> 3;         /* number of header bytes */\n        if (s->strm->avail_out < have)          /* need room for header */\n            break;\n            /* maximum stored block length that will fit in avail_out: */\n        have = s->strm->avail_out - have;\n        left = s->strstart - s->block_start;    /* bytes left in window */\n        if (len > (ulg)left + s->strm->avail_in)\n            len = left + s->strm->avail_in;     /* limit len to the input */\n        if (len > have)\n            len = have;                         /* limit len to the output */\n\n        /* If the stored block would be less than min_block in length, or if\n         * unable to copy all of the available input when flushing, then try\n         * copying to the window and the pending buffer instead. Also don't\n         * write an empty block when flushing -- deflate() does that.\n         */\n        if (len < min_block && ((len == 0 && flush != Z_FINISH) ||\n                                flush == Z_NO_FLUSH ||\n                                len != left + s->strm->avail_in))\n            break;\n\n        /* Make a dummy stored block in pending to get the header bytes,\n         * including any pending bits. This also updates the debugging counts.\n         */\n        last = flush == Z_FINISH && len == left + s->strm->avail_in ? 1 : 0;\n        _tr_stored_block(s, (char *)0, 0L, last);\n\n        /* Replace the lengths in the dummy stored block with len. */\n        s->pending_buf[s->pending - 4] = (Bytef)len;\n        s->pending_buf[s->pending - 3] = (Bytef)(len >> 8);\n        s->pending_buf[s->pending - 2] = (Bytef)~len;\n        s->pending_buf[s->pending - 1] = (Bytef)(~len >> 8);\n\n        /* Write the stored block header bytes. */\n        flush_pending(s->strm);\n\n#ifdef ZLIB_DEBUG\n        /* Update debugging counts for the data about to be copied. */\n        s->compressed_len += len << 3;\n        s->bits_sent += len << 3;\n#endif\n\n        /* Copy uncompressed bytes from the window to next_out. */\n        if (left) {\n            if (left > len)\n                left = len;\n            zmemcpy(s->strm->next_out, s->window + s->block_start, left);\n            s->strm->next_out += left;\n            s->strm->avail_out -= left;\n            s->strm->total_out += left;\n            s->block_start += left;\n            len -= left;\n        }\n\n        /* Copy uncompressed bytes directly from next_in to next_out, updating\n         * the check value.\n         */\n        if (len) {\n            read_buf(s->strm, s->strm->next_out, len);\n            s->strm->next_out += len;\n            s->strm->avail_out -= len;\n            s->strm->total_out += len;\n        }\n    } while (last == 0);\n\n    /* Update the sliding window with the last s->w_size bytes of the copied\n     * data, or append all of the copied data to the existing window if less\n     * than s->w_size bytes were copied. Also update the number of bytes to\n     * insert in the hash tables, in the event that deflateParams() switches to\n     * a non-zero compression level.\n     */\n    used -= s->strm->avail_in;      /* number of input bytes directly copied */\n    if (used) {\n        /* If any input was used, then no unused input remains in the window,\n         * therefore s->block_start == s->strstart.\n         */\n        if (used >= s->w_size) {    /* supplant the previous history */\n            s->matches = 2;         /* clear hash */\n            zmemcpy(s->window, s->strm->next_in - s->w_size, s->w_size);\n            s->strstart = s->w_size;\n            s->insert = s->strstart;\n        }\n        else {\n            if (s->window_size - s->strstart <= used) {\n                /* Slide the window down. */\n                s->strstart -= s->w_size;\n                zmemcpy(s->window, s->window + s->w_size, s->strstart);\n                if (s->matches < 2)\n                    s->matches++;   /* add a pending slide_hash() */\n                if (s->insert > s->strstart)\n                    s->insert = s->strstart;\n            }\n            zmemcpy(s->window + s->strstart, s->strm->next_in - used, used);\n            s->strstart += used;\n            s->insert += MIN(used, s->w_size - s->insert);\n        }\n        s->block_start = s->strstart;\n    }\n    if (s->high_water < s->strstart)\n        s->high_water = s->strstart;\n\n    /* If the last block was written to next_out, then done. */\n    if (last) {\n        s->bi_used = 8;\n        return finish_done;\n    }\n\n    /* If flushing and all input has been consumed, then done. */\n    if (flush != Z_NO_FLUSH && flush != Z_FINISH &&\n        s->strm->avail_in == 0 && (long)s->strstart == s->block_start)\n        return block_done;\n\n    /* Fill the window with any remaining input. */\n    have = s->window_size - s->strstart;\n    if (s->strm->avail_in > have && s->block_start >= (long)s->w_size) {\n        /* Slide the window down. */\n        s->block_start -= s->w_size;\n        s->strstart -= s->w_size;\n        zmemcpy(s->window, s->window + s->w_size, s->strstart);\n        if (s->matches < 2)\n            s->matches++;           /* add a pending slide_hash() */\n        have += s->w_size;          /* more space now */\n        if (s->insert > s->strstart)\n            s->insert = s->strstart;\n    }\n    if (have > s->strm->avail_in)\n        have = s->strm->avail_in;\n    if (have) {\n        read_buf(s->strm, s->window + s->strstart, have);\n        s->strstart += have;\n        s->insert += MIN(have, s->w_size - s->insert);\n    }\n    if (s->high_water < s->strstart)\n        s->high_water = s->strstart;\n\n    /* There was not enough avail_out to write a complete worthy or flushed\n     * stored block to next_out. Write a stored block to pending instead, if we\n     * have enough input for a worthy block, or if flushing and there is enough\n     * room for the remaining input as a stored block in the pending buffer.\n     */\n    have = (s->bi_valid + 42) >> 3;         /* number of header bytes */\n        /* maximum stored block length that will fit in pending: */\n    have = MIN(s->pending_buf_size - have, MAX_STORED);\n    min_block = MIN(have, s->w_size);\n    left = s->strstart - s->block_start;\n    if (left >= min_block ||\n        ((left || flush == Z_FINISH) && flush != Z_NO_FLUSH &&\n         s->strm->avail_in == 0 && left <= have)) {\n        len = MIN(left, have);\n        last = flush == Z_FINISH && s->strm->avail_in == 0 &&\n               len == left ? 1 : 0;\n        _tr_stored_block(s, (charf *)s->window + s->block_start, len, last);\n        s->block_start += len;\n        flush_pending(s->strm);\n    }\n\n    /* We've done all we can with the available input and output. */\n    if (last)\n        s->bi_used = 8;\n    return last ? finish_started : need_more;\n}\n\n/* ===========================================================================\n * Compress as much as possible from the input stream, return the current\n * block state.\n * This function does not perform lazy evaluation of matches and inserts\n * new strings in the dictionary only for unmatched strings or for short\n * matches. It is used only for the fast compression options.\n */\nlocal block_state deflate_fast(deflate_state *s, int flush) {\n    IPos hash_head;       /* head of the hash chain */\n    int bflush;           /* set if current block must be flushed */\n\n    for (;;) {\n        /* Make sure that we always have enough lookahead, except\n         * at the end of the input file. We need MAX_MATCH bytes\n         * for the next match, plus MIN_MATCH bytes to insert the\n         * string following the next match.\n         */\n        if (s->lookahead < MIN_LOOKAHEAD) {\n            fill_window(s);\n            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {\n                return need_more;\n            }\n            if (s->lookahead == 0) break; /* flush the current block */\n        }\n\n        /* Insert the string window[strstart .. strstart + 2] in the\n         * dictionary, and set hash_head to the head of the hash chain:\n         */\n        hash_head = NIL;\n        if (s->lookahead >= MIN_MATCH) {\n            INSERT_STRING(s, s->strstart, hash_head);\n        }\n\n        /* Find the longest match, discarding those <= prev_length.\n         * At this point we have always match_length < MIN_MATCH\n         */\n        if (hash_head != NIL && s->strstart - hash_head <= MAX_DIST(s)) {\n            /* To simplify the code, we prevent matches with the string\n             * of window index 0 (in particular we have to avoid a match\n             * of the string with itself at the start of the input file).\n             */\n            s->match_length = longest_match (s, hash_head);\n            /* longest_match() sets match_start */\n        }\n        if (s->match_length >= MIN_MATCH) {\n            check_match(s, s->strstart, s->match_start, s->match_length);\n\n            _tr_tally_dist(s, s->strstart - s->match_start,\n                           s->match_length - MIN_MATCH, bflush);\n\n            s->lookahead -= s->match_length;\n\n            /* Insert new strings in the hash table only if the match length\n             * is not too large. This saves time but degrades compression.\n             */\n#ifndef FASTEST\n            if (s->match_length <= s->max_insert_length &&\n                s->lookahead >= MIN_MATCH) {\n                s->match_length--; /* string at strstart already in table */\n                do {\n                    s->strstart++;\n                    INSERT_STRING(s, s->strstart, hash_head);\n                    /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n                     * always MIN_MATCH bytes ahead.\n                     */\n                } while (--s->match_length != 0);\n                s->strstart++;\n            } else\n#endif\n            {\n                s->strstart += s->match_length;\n                s->match_length = 0;\n                s->ins_h = s->window[s->strstart];\n                UPDATE_HASH(s, s->ins_h, s->window[s->strstart + 1]);\n#if MIN_MATCH != 3\n                Call UPDATE_HASH() MIN_MATCH-3 more times\n#endif\n                /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n                 * matter since it will be recomputed at next deflate call.\n                 */\n            }\n        } else {\n            /* No match, output a literal byte */\n            Tracevv((stderr,\"%c\", s->window[s->strstart]));\n            _tr_tally_lit(s, s->window[s->strstart], bflush);\n            s->lookahead--;\n            s->strstart++;\n        }\n        if (bflush) FLUSH_BLOCK(s, 0);\n    }\n    s->insert = s->strstart < MIN_MATCH-1 ? s->strstart : MIN_MATCH-1;\n    if (flush == Z_FINISH) {\n        FLUSH_BLOCK(s, 1);\n        return finish_done;\n    }\n    if (s->sym_next)\n        FLUSH_BLOCK(s, 0);\n    return block_done;\n}\n\n#ifndef FASTEST\n/* ===========================================================================\n * Same as above, but achieves better compression. We use a lazy\n * evaluation for matches: a match is finally adopted only if there is\n * no better match at the next window position.\n */\nlocal block_state deflate_slow(deflate_state *s, int flush) {\n    IPos hash_head;          /* head of hash chain */\n    int bflush;              /* set if current block must be flushed */\n\n    /* Process the input block. */\n    for (;;) {\n        /* Make sure that we always have enough lookahead, except\n         * at the end of the input file. We need MAX_MATCH bytes\n         * for the next match, plus MIN_MATCH bytes to insert the\n         * string following the next match.\n         */\n        if (s->lookahead < MIN_LOOKAHEAD) {\n            fill_window(s);\n            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {\n                return need_more;\n            }\n            if (s->lookahead == 0) break; /* flush the current block */\n        }\n\n        /* Insert the string window[strstart .. strstart + 2] in the\n         * dictionary, and set hash_head to the head of the hash chain:\n         */\n        hash_head = NIL;\n        if (s->lookahead >= MIN_MATCH) {\n            INSERT_STRING(s, s->strstart, hash_head);\n        }\n\n        /* Find the longest match, discarding those <= prev_length.\n         */\n        s->prev_length = s->match_length, s->prev_match = s->match_start;\n        s->match_length = MIN_MATCH-1;\n\n        if (hash_head != NIL && s->prev_length < s->max_lazy_match &&\n            s->strstart - hash_head <= MAX_DIST(s)) {\n            /* To simplify the code, we prevent matches with the string\n             * of window index 0 (in particular we have to avoid a match\n             * of the string with itself at the start of the input file).\n             */\n            s->match_length = longest_match (s, hash_head);\n            /* longest_match() sets match_start */\n\n            if (s->match_length <= 5 && (s->strategy == Z_FILTERED\n#if TOO_FAR <= 32767\n                || (s->match_length == MIN_MATCH &&\n                    s->strstart - s->match_start > TOO_FAR)\n#endif\n                )) {\n\n                /* If prev_match is also MIN_MATCH, match_start is garbage\n                 * but we will ignore the current match anyway.\n                 */\n                s->match_length = MIN_MATCH-1;\n            }\n        }\n        /* If there was a match at the previous step and the current\n         * match is not better, output the previous match:\n         */\n        if (s->prev_length >= MIN_MATCH && s->match_length <= s->prev_length) {\n            uInt max_insert = s->strstart + s->lookahead - MIN_MATCH;\n            /* Do not insert strings in hash table beyond this. */\n\n            check_match(s, s->strstart - 1, s->prev_match, s->prev_length);\n\n            _tr_tally_dist(s, s->strstart - 1 - s->prev_match,\n                           s->prev_length - MIN_MATCH, bflush);\n\n            /* Insert in hash table all strings up to the end of the match.\n             * strstart - 1 and strstart are already inserted. If there is not\n             * enough lookahead, the last two strings are not inserted in\n             * the hash table.\n             */\n            s->lookahead -= s->prev_length - 1;\n            s->prev_length -= 2;\n            do {\n                if (++s->strstart <= max_insert) {\n                    INSERT_STRING(s, s->strstart, hash_head);\n                }\n            } while (--s->prev_length != 0);\n            s->match_available = 0;\n            s->match_length = MIN_MATCH-1;\n            s->strstart++;\n\n            if (bflush) FLUSH_BLOCK(s, 0);\n\n        } else if (s->match_available) {\n            /* If there was no match at the previous position, output a\n             * single literal. If there was a match but the current match\n             * is longer, truncate the previous match to a single literal.\n             */\n            Tracevv((stderr,\"%c\", s->window[s->strstart - 1]));\n            _tr_tally_lit(s, s->window[s->strstart - 1], bflush);\n            if (bflush) {\n                FLUSH_BLOCK_ONLY(s, 0);\n            }\n            s->strstart++;\n            s->lookahead--;\n            if (s->strm->avail_out == 0) return need_more;\n        } else {\n            /* There is no previous match to compare with, wait for\n             * the next step to decide.\n             */\n            s->match_available = 1;\n            s->strstart++;\n            s->lookahead--;\n        }\n    }\n    Assert (flush != Z_NO_FLUSH, \"no flush?\");\n    if (s->match_available) {\n        Tracevv((stderr,\"%c\", s->window[s->strstart - 1]));\n        _tr_tally_lit(s, s->window[s->strstart - 1], bflush);\n        s->match_available = 0;\n    }\n    s->insert = s->strstart < MIN_MATCH-1 ? s->strstart : MIN_MATCH-1;\n    if (flush == Z_FINISH) {\n        FLUSH_BLOCK(s, 1);\n        return finish_done;\n    }\n    if (s->sym_next)\n        FLUSH_BLOCK(s, 0);\n    return block_done;\n}\n#endif /* FASTEST */\n\n/* ===========================================================================\n * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n * deflate switches away from Z_RLE.)\n */\nlocal block_state deflate_rle(deflate_state *s, int flush) {\n    int bflush;             /* set if current block must be flushed */\n    uInt prev;              /* byte at distance one to match */\n    Bytef *scan, *strend;   /* scan goes up to strend for length of run */\n\n    for (;;) {\n        /* Make sure that we always have enough lookahead, except\n         * at the end of the input file. We need MAX_MATCH bytes\n         * for the longest run, plus one for the unrolled loop.\n         */\n        if (s->lookahead <= MAX_MATCH) {\n            fill_window(s);\n            if (s->lookahead <= MAX_MATCH && flush == Z_NO_FLUSH) {\n                return need_more;\n            }\n            if (s->lookahead == 0) break; /* flush the current block */\n        }\n\n        /* See how many times the previous byte repeats */\n        s->match_length = 0;\n        if (s->lookahead >= MIN_MATCH && s->strstart > 0) {\n            scan = s->window + s->strstart - 1;\n            prev = *scan;\n            if (prev == *++scan && prev == *++scan && prev == *++scan) {\n                strend = s->window + s->strstart + MAX_MATCH;\n                do {\n                } while (prev == *++scan && prev == *++scan &&\n                         prev == *++scan && prev == *++scan &&\n                         prev == *++scan && prev == *++scan &&\n                         prev == *++scan && prev == *++scan &&\n                         scan < strend);\n                s->match_length = MAX_MATCH - (uInt)(strend - scan);\n                if (s->match_length > s->lookahead)\n                    s->match_length = s->lookahead;\n            }\n            Assert(scan <= s->window + (uInt)(s->window_size - 1),\n                   \"wild scan\");\n        }\n\n        /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n        if (s->match_length >= MIN_MATCH) {\n            check_match(s, s->strstart, s->strstart - 1, s->match_length);\n\n            _tr_tally_dist(s, 1, s->match_length - MIN_MATCH, bflush);\n\n            s->lookahead -= s->match_length;\n            s->strstart += s->match_length;\n            s->match_length = 0;\n        } else {\n            /* No match, output a literal byte */\n            Tracevv((stderr,\"%c\", s->window[s->strstart]));\n            _tr_tally_lit(s, s->window[s->strstart], bflush);\n            s->lookahead--;\n            s->strstart++;\n        }\n        if (bflush) FLUSH_BLOCK(s, 0);\n    }\n    s->insert = 0;\n    if (flush == Z_FINISH) {\n        FLUSH_BLOCK(s, 1);\n        return finish_done;\n    }\n    if (s->sym_next)\n        FLUSH_BLOCK(s, 0);\n    return block_done;\n}\n\n/* ===========================================================================\n * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n * (It will be regenerated if this run of deflate switches away from Huffman.)\n */\nlocal block_state deflate_huff(deflate_state *s, int flush) {\n    int bflush;             /* set if current block must be flushed */\n\n    for (;;) {\n        /* Make sure that we have a literal to write. */\n        if (s->lookahead == 0) {\n            fill_window(s);\n            if (s->lookahead == 0) {\n                if (flush == Z_NO_FLUSH)\n                    return need_more;\n                break;      /* flush the current block */\n            }\n        }\n\n        /* Output a literal byte */\n        s->match_length = 0;\n        Tracevv((stderr,\"%c\", s->window[s->strstart]));\n        _tr_tally_lit(s, s->window[s->strstart], bflush);\n        s->lookahead--;\n        s->strstart++;\n        if (bflush) FLUSH_BLOCK(s, 0);\n    }\n    s->insert = 0;\n    if (flush == Z_FINISH) {\n        FLUSH_BLOCK(s, 1);\n        return finish_done;\n    }\n    if (s->sym_next)\n        FLUSH_BLOCK(s, 0);\n    return block_done;\n}\n"
        },
        {
          "name": "deflate.h",
          "type": "blob",
          "size": 13.7978515625,
          "content": "/* deflate.h -- internal compression state\n * Copyright (C) 1995-2024 Jean-loup Gailly\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n/* WARNING: this file should *not* be used by applications. It is\n   part of the implementation of the compression library and is\n   subject to change. Applications should only use zlib.h.\n */\n\n/* @(#) $Id$ */\n\n#ifndef DEFLATE_H\n#define DEFLATE_H\n\n#include \"zutil.h\"\n\n/* define NO_GZIP when compiling if you want to disable gzip header and\n   trailer creation by deflate().  NO_GZIP would be used to avoid linking in\n   the crc code when it is not needed.  For shared libraries, gzip encoding\n   should be left enabled. */\n#ifndef NO_GZIP\n#  define GZIP\n#endif\n\n/* define LIT_MEM to slightly increase the speed of deflate (order 1% to 2%) at\n   the cost of a larger memory footprint */\n/* #define LIT_MEM */\n\n/* ===========================================================================\n * Internal compression state.\n */\n\n#define LENGTH_CODES 29\n/* number of length codes, not counting the special END_BLOCK code */\n\n#define LITERALS  256\n/* number of literal bytes 0..255 */\n\n#define L_CODES (LITERALS+1+LENGTH_CODES)\n/* number of Literal or Length codes, including the END_BLOCK code */\n\n#define D_CODES   30\n/* number of distance codes */\n\n#define BL_CODES  19\n/* number of codes used to transfer the bit lengths */\n\n#define HEAP_SIZE (2*L_CODES+1)\n/* maximum heap size */\n\n#define MAX_BITS 15\n/* All codes must not exceed MAX_BITS bits */\n\n#define Buf_size 16\n/* size of bit buffer in bi_buf */\n\n#define INIT_STATE    42    /* zlib header -> BUSY_STATE */\n#ifdef GZIP\n#  define GZIP_STATE  57    /* gzip header -> BUSY_STATE | EXTRA_STATE */\n#endif\n#define EXTRA_STATE   69    /* gzip extra block -> NAME_STATE */\n#define NAME_STATE    73    /* gzip file name -> COMMENT_STATE */\n#define COMMENT_STATE 91    /* gzip comment -> HCRC_STATE */\n#define HCRC_STATE   103    /* gzip header CRC -> BUSY_STATE */\n#define BUSY_STATE   113    /* deflate -> FINISH_STATE */\n#define FINISH_STATE 666    /* stream complete */\n/* Stream status */\n\n\n/* Data structure describing a single value and its code string. */\ntypedef struct ct_data_s {\n    union {\n        ush  freq;       /* frequency count */\n        ush  code;       /* bit string */\n    } fc;\n    union {\n        ush  dad;        /* father node in Huffman tree */\n        ush  len;        /* length of bit string */\n    } dl;\n} FAR ct_data;\n\n#define Freq fc.freq\n#define Code fc.code\n#define Dad  dl.dad\n#define Len  dl.len\n\ntypedef struct static_tree_desc_s  static_tree_desc;\n\ntypedef struct tree_desc_s {\n    ct_data *dyn_tree;           /* the dynamic tree */\n    int     max_code;            /* largest code with non zero frequency */\n    const static_tree_desc *stat_desc;  /* the corresponding static tree */\n} FAR tree_desc;\n\ntypedef ush Pos;\ntypedef Pos FAR Posf;\ntypedef unsigned IPos;\n\n/* A Pos is an index in the character window. We use short instead of int to\n * save space in the various tables. IPos is used only for parameter passing.\n */\n\ntypedef struct internal_state {\n    z_streamp strm;      /* pointer back to this zlib stream */\n    int   status;        /* as the name implies */\n    Bytef *pending_buf;  /* output still pending */\n    ulg   pending_buf_size; /* size of pending_buf */\n    Bytef *pending_out;  /* next pending byte to output to the stream */\n    ulg   pending;       /* nb of bytes in the pending buffer */\n    int   wrap;          /* bit 0 true for zlib, bit 1 true for gzip */\n    gz_headerp  gzhead;  /* gzip header information to write */\n    ulg   gzindex;       /* where in extra, name, or comment */\n    Byte  method;        /* can only be DEFLATED */\n    int   last_flush;    /* value of flush param for previous deflate call */\n\n                /* used by deflate.c: */\n\n    uInt  w_size;        /* LZ77 window size (32K by default) */\n    uInt  w_bits;        /* log2(w_size)  (8..16) */\n    uInt  w_mask;        /* w_size - 1 */\n\n    Bytef *window;\n    /* Sliding window. Input bytes are read into the second half of the window,\n     * and move to the first half later to keep a dictionary of at least wSize\n     * bytes. With this organization, matches are limited to a distance of\n     * wSize-MAX_MATCH bytes, but this ensures that IO is always\n     * performed with a length multiple of the block size. Also, it limits\n     * the window size to 64K, which is quite useful on MSDOS.\n     * To do: use the user input buffer as sliding window.\n     */\n\n    ulg window_size;\n    /* Actual size of window: 2*wSize, except when the user input buffer\n     * is directly used as sliding window.\n     */\n\n    Posf *prev;\n    /* Link to older string with same hash index. To limit the size of this\n     * array to 64K, this link is maintained only for the last 32K strings.\n     * An index in this array is thus a window index modulo 32K.\n     */\n\n    Posf *head; /* Heads of the hash chains or NIL. */\n\n    uInt  ins_h;          /* hash index of string to be inserted */\n    uInt  hash_size;      /* number of elements in hash table */\n    uInt  hash_bits;      /* log2(hash_size) */\n    uInt  hash_mask;      /* hash_size-1 */\n\n    uInt  hash_shift;\n    /* Number of bits by which ins_h must be shifted at each input\n     * step. It must be such that after MIN_MATCH steps, the oldest\n     * byte no longer takes part in the hash key, that is:\n     *   hash_shift * MIN_MATCH >= hash_bits\n     */\n\n    long block_start;\n    /* Window position at the beginning of the current output block. Gets\n     * negative when the window is moved backwards.\n     */\n\n    uInt match_length;           /* length of best match */\n    IPos prev_match;             /* previous match */\n    int match_available;         /* set if previous match exists */\n    uInt strstart;               /* start of string to insert */\n    uInt match_start;            /* start of matching string */\n    uInt lookahead;              /* number of valid bytes ahead in window */\n\n    uInt prev_length;\n    /* Length of the best match at previous step. Matches not greater than this\n     * are discarded. This is used in the lazy match evaluation.\n     */\n\n    uInt max_chain_length;\n    /* To speed up deflation, hash chains are never searched beyond this\n     * length.  A higher limit improves compression ratio but degrades the\n     * speed.\n     */\n\n    uInt max_lazy_match;\n    /* Attempt to find a better match only when the current match is strictly\n     * smaller than this value. This mechanism is used only for compression\n     * levels >= 4.\n     */\n#   define max_insert_length  max_lazy_match\n    /* Insert new strings in the hash table only if the match length is not\n     * greater than this length. This saves time but degrades compression.\n     * max_insert_length is used only for compression levels <= 3.\n     */\n\n    int level;    /* compression level (1..9) */\n    int strategy; /* favor or force Huffman coding*/\n\n    uInt good_match;\n    /* Use a faster search when the previous match is longer than this */\n\n    int nice_match; /* Stop searching when current match exceeds this */\n\n                /* used by trees.c: */\n    /* Didn't use ct_data typedef below to suppress compiler warning */\n    struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n    struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n    struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n\n    struct tree_desc_s l_desc;               /* desc. for literal tree */\n    struct tree_desc_s d_desc;               /* desc. for distance tree */\n    struct tree_desc_s bl_desc;              /* desc. for bit length tree */\n\n    ush bl_count[MAX_BITS+1];\n    /* number of codes at each bit length for an optimal tree */\n\n    int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n    int heap_len;               /* number of elements in the heap */\n    int heap_max;               /* element of largest frequency */\n    /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n     * The same heap array is used to build all trees.\n     */\n\n    uch depth[2*L_CODES+1];\n    /* Depth of each subtree used as tie breaker for trees of equal frequency\n     */\n\n#ifdef LIT_MEM\n#   define LIT_BUFS 5\n    ushf *d_buf;          /* buffer for distances */\n    uchf *l_buf;          /* buffer for literals/lengths */\n#else\n#   define LIT_BUFS 4\n    uchf *sym_buf;        /* buffer for distances and literals/lengths */\n#endif\n\n    uInt  lit_bufsize;\n    /* Size of match buffer for literals/lengths.  There are 4 reasons for\n     * limiting lit_bufsize to 64K:\n     *   - frequencies can be kept in 16 bit counters\n     *   - if compression is not successful for the first block, all input\n     *     data is still in the window so we can still emit a stored block even\n     *     when input comes from standard input.  (This can also be done for\n     *     all blocks if lit_bufsize is not greater than 32K.)\n     *   - if compression is not successful for a file smaller than 64K, we can\n     *     even emit a stored file instead of a stored block (saving 5 bytes).\n     *     This is applicable only for zip (not gzip or zlib).\n     *   - creating new Huffman trees less frequently may not provide fast\n     *     adaptation to changes in the input data statistics. (Take for\n     *     example a binary file with poorly compressible code followed by\n     *     a highly compressible string table.) Smaller buffer sizes give\n     *     fast adaptation but have of course the overhead of transmitting\n     *     trees more frequently.\n     *   - I can't count above 4\n     */\n\n    uInt sym_next;      /* running index in symbol buffer */\n    uInt sym_end;       /* symbol table full when sym_next reaches this */\n\n    ulg opt_len;        /* bit length of current block with optimal trees */\n    ulg static_len;     /* bit length of current block with static trees */\n    uInt matches;       /* number of string matches in current block */\n    uInt insert;        /* bytes at end of window left to insert */\n\n#ifdef ZLIB_DEBUG\n    ulg compressed_len; /* total bit length of compressed file mod 2^32 */\n    ulg bits_sent;      /* bit length of compressed data sent mod 2^32 */\n#endif\n\n    ush bi_buf;\n    /* Output buffer. bits are inserted starting at the bottom (least\n     * significant bits).\n     */\n    int bi_valid;\n    /* Number of valid bits in bi_buf.  All bits above the last valid bit\n     * are always zero.\n     */\n    int bi_used;\n    /* Last number of used bits when going to a byte boundary.\n     */\n\n    ulg high_water;\n    /* High water mark offset in window for initialized bytes -- bytes above\n     * this are set to zero in order to avoid memory check warnings when\n     * longest match routines access bytes past the input.  This is then\n     * updated to the new high water mark.\n     */\n\n} FAR deflate_state;\n\n/* Output a byte on the stream.\n * IN assertion: there is enough room in pending_buf.\n */\n#define put_byte(s, c) {s->pending_buf[s->pending++] = (Bytef)(c);}\n\n\n#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)\n/* Minimum amount of lookahead, except at the end of the input file.\n * See deflate.c for comments about the MIN_MATCH+1.\n */\n\n#define MAX_DIST(s)  ((s)->w_size-MIN_LOOKAHEAD)\n/* In order to simplify the code, particularly on 16 bit machines, match\n * distances are limited to MAX_DIST instead of WSIZE.\n */\n\n#define WIN_INIT MAX_MATCH\n/* Number of bytes after end of data in window to initialize in order to avoid\n   memory checker errors from longest match routines */\n\n        /* in trees.c */\nvoid ZLIB_INTERNAL _tr_init(deflate_state *s);\nint ZLIB_INTERNAL _tr_tally(deflate_state *s, unsigned dist, unsigned lc);\nvoid ZLIB_INTERNAL _tr_flush_block(deflate_state *s, charf *buf,\n                                   ulg stored_len, int last);\nvoid ZLIB_INTERNAL _tr_flush_bits(deflate_state *s);\nvoid ZLIB_INTERNAL _tr_align(deflate_state *s);\nvoid ZLIB_INTERNAL _tr_stored_block(deflate_state *s, charf *buf,\n                                    ulg stored_len, int last);\n\n#define d_code(dist) \\\n   ((dist) < 256 ? _dist_code[dist] : _dist_code[256+((dist)>>7)])\n/* Mapping from a distance to a distance code. dist is the distance - 1 and\n * must not have side effects. _dist_code[256] and _dist_code[257] are never\n * used.\n */\n\n#ifndef ZLIB_DEBUG\n/* Inline versions of _tr_tally for speed: */\n\n#if defined(GEN_TREES_H) || !defined(STDC)\n  extern uch ZLIB_INTERNAL _length_code[];\n  extern uch ZLIB_INTERNAL _dist_code[];\n#else\n  extern const uch ZLIB_INTERNAL _length_code[];\n  extern const uch ZLIB_INTERNAL _dist_code[];\n#endif\n\n#ifdef LIT_MEM\n# define _tr_tally_lit(s, c, flush) \\\n  { uch cc = (c); \\\n    s->d_buf[s->sym_next] = 0; \\\n    s->l_buf[s->sym_next++] = cc; \\\n    s->dyn_ltree[cc].Freq++; \\\n    flush = (s->sym_next == s->sym_end); \\\n   }\n# define _tr_tally_dist(s, distance, length, flush) \\\n  { uch len = (uch)(length); \\\n    ush dist = (ush)(distance); \\\n    s->d_buf[s->sym_next] = dist; \\\n    s->l_buf[s->sym_next++] = len; \\\n    dist--; \\\n    s->dyn_ltree[_length_code[len]+LITERALS+1].Freq++; \\\n    s->dyn_dtree[d_code(dist)].Freq++; \\\n    flush = (s->sym_next == s->sym_end); \\\n  }\n#else\n# define _tr_tally_lit(s, c, flush) \\\n  { uch cc = (c); \\\n    s->sym_buf[s->sym_next++] = 0; \\\n    s->sym_buf[s->sym_next++] = 0; \\\n    s->sym_buf[s->sym_next++] = cc; \\\n    s->dyn_ltree[cc].Freq++; \\\n    flush = (s->sym_next == s->sym_end); \\\n   }\n# define _tr_tally_dist(s, distance, length, flush) \\\n  { uch len = (uch)(length); \\\n    ush dist = (ush)(distance); \\\n    s->sym_buf[s->sym_next++] = (uch)dist; \\\n    s->sym_buf[s->sym_next++] = (uch)(dist >> 8); \\\n    s->sym_buf[s->sym_next++] = len; \\\n    dist--; \\\n    s->dyn_ltree[_length_code[len]+LITERALS+1].Freq++; \\\n    s->dyn_dtree[d_code(dist)].Freq++; \\\n    flush = (s->sym_next == s->sym_end); \\\n  }\n#endif\n#else\n# define _tr_tally_lit(s, c, flush) flush = _tr_tally(s, 0, c)\n# define _tr_tally_dist(s, distance, length, flush) \\\n              flush = _tr_tally(s, distance, length)\n#endif\n\n#endif /* DEFLATE_H */\n"
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "gzclose.c",
          "type": "blob",
          "size": 0.65234375,
          "content": "/* gzclose.c -- zlib gzclose() function\n * Copyright (C) 2004, 2010 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n#include \"gzguts.h\"\n\n/* gzclose() is in a separate file so that it is linked in only if it is used.\n   That way the other gzclose functions can be used instead to avoid linking in\n   unneeded compression or decompression routines. */\nint ZEXPORT gzclose(gzFile file) {\n#ifndef NO_GZCOMPRESS\n    gz_statep state;\n\n    if (file == NULL)\n        return Z_STREAM_ERROR;\n    state = (gz_statep)file;\n\n    return state->mode == GZ_READ ? gzclose_r(file) : gzclose_w(file);\n#else\n    return gzclose_r(file);\n#endif\n}\n"
        },
        {
          "name": "gzguts.h",
          "type": "blob",
          "size": 6.8330078125,
          "content": "/* gzguts.h -- zlib internal header definitions for gz* operations\n * Copyright (C) 2004-2024 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n#ifdef _LARGEFILE64_SOURCE\n#  ifndef _LARGEFILE_SOURCE\n#    define _LARGEFILE_SOURCE 1\n#  endif\n#  undef _FILE_OFFSET_BITS\n#  undef _TIME_BITS\n#endif\n\n#ifdef HAVE_HIDDEN\n#  define ZLIB_INTERNAL __attribute__((visibility (\"hidden\")))\n#else\n#  define ZLIB_INTERNAL\n#endif\n\n#if defined(_WIN32)\n#  ifndef WIN32_LEAN_AND_MEAN\n#    define WIN32_LEAN_AND_MEAN\n#  endif\n#  ifndef _CRT_SECURE_NO_WARNINGS\n#    define _CRT_SECURE_NO_WARNINGS\n#  endif\n#  ifndef _CRT_NONSTDC_NO_DEPRECATE\n#    define _CRT_NONSTDC_NO_DEPRECATE\n#  endif\n#endif\n\n#include <stdio.h>\n#include \"zlib.h\"\n#ifdef STDC\n#  include <string.h>\n#  include <stdlib.h>\n#  include <limits.h>\n#endif\n\n#ifndef _POSIX_C_SOURCE\n#  define _POSIX_C_SOURCE 200112L\n#endif\n#include <fcntl.h>\n\n#ifdef _WIN32\n#  include <stddef.h>\n#endif\n\n#if defined(__TURBOC__) || defined(_MSC_VER) || defined(_WIN32)\n#  include <io.h>\n#  include <sys/stat.h>\n#endif\n\n#if defined(_WIN32) && !defined(WIDECHAR)\n#  define WIDECHAR\n#endif\n\n#ifdef NO_DEFLATE       /* for compatibility with old definition */\n#  define NO_GZCOMPRESS\n#endif\n\n#if defined(STDC99) || (defined(__TURBOC__) && __TURBOC__ >= 0x550)\n#  ifndef HAVE_VSNPRINTF\n#    define HAVE_VSNPRINTF\n#  endif\n#endif\n\n#if defined(__CYGWIN__)\n#  ifndef HAVE_VSNPRINTF\n#    define HAVE_VSNPRINTF\n#  endif\n#endif\n\n#if defined(MSDOS) && defined(__BORLANDC__) && (BORLANDC > 0x410)\n#  ifndef HAVE_VSNPRINTF\n#    define HAVE_VSNPRINTF\n#  endif\n#endif\n\n#ifndef HAVE_VSNPRINTF\n#  if !defined(NO_vsnprintf) && \\\n      (defined(MSDOS) || defined(__TURBOC__) || defined(__SASC) || \\\n       defined(VMS) || defined(__OS400) || defined(__MVS__))\n/* vsnprintf may exist on some MS-DOS compilers (DJGPP?),\n   but for now we just assume it doesn't. */\n#    define NO_vsnprintf\n#  endif\n#  ifdef WIN32\n/* In Win32, vsnprintf is available as the \"non-ANSI\" _vsnprintf. */\n#    if !defined(_MSC_VER) || ( defined(_MSC_VER) && _MSC_VER < 1500 )\n#      ifndef vsnprintf\n#        define vsnprintf _vsnprintf\n#      endif\n#    endif\n#  elif !defined(__STDC_VERSION__) || __STDC_VERSION__-0 < 199901L\n/* Otherwise if C89/90, assume no C99 snprintf() or vsnprintf() */\n#    ifndef NO_snprintf\n#      define NO_snprintf\n#    endif\n#    ifndef NO_vsnprintf\n#      define NO_vsnprintf\n#    endif\n#  endif\n#endif\n\n/* unlike snprintf (which is required in C99), _snprintf does not guarantee\n   null termination of the result -- however this is only used in gzlib.c where\n   the result is assured to fit in the space provided */\n#if defined(_MSC_VER) && _MSC_VER < 1900\n#  define snprintf _snprintf\n#endif\n\n#ifndef local\n#  define local static\n#endif\n/* since \"static\" is used to mean two completely different things in C, we\n   define \"local\" for the non-static meaning of \"static\", for readability\n   (compile with -Dlocal if your debugger can't find static symbols) */\n\n/* gz* functions always use library allocation functions */\n#ifndef STDC\n  extern voidp  malloc(uInt size);\n  extern void   free(voidpf ptr);\n#endif\n\n/* get errno and strerror definition */\n#if defined UNDER_CE\n#  include <windows.h>\n#  define zstrerror() gz_strwinerror((DWORD)GetLastError())\n#else\n#  ifndef NO_STRERROR\n#    include <errno.h>\n#    define zstrerror() strerror(errno)\n#  else\n#    define zstrerror() \"stdio error (consult errno)\"\n#  endif\n#endif\n\n/* provide prototypes for these when building zlib without LFS */\n#if !defined(_LARGEFILE64_SOURCE) || _LFS64_LARGEFILE-0 == 0\n    ZEXTERN gzFile ZEXPORT gzopen64(const char *, const char *);\n    ZEXTERN z_off64_t ZEXPORT gzseek64(gzFile, z_off64_t, int);\n    ZEXTERN z_off64_t ZEXPORT gztell64(gzFile);\n    ZEXTERN z_off64_t ZEXPORT gzoffset64(gzFile);\n#endif\n\n/* default memLevel */\n#if MAX_MEM_LEVEL >= 8\n#  define DEF_MEM_LEVEL 8\n#else\n#  define DEF_MEM_LEVEL  MAX_MEM_LEVEL\n#endif\n\n/* default i/o buffer size -- double this for output when reading (this and\n   twice this must be able to fit in an unsigned type) */\n#define GZBUFSIZE 8192\n\n/* gzip modes, also provide a little integrity check on the passed structure */\n#define GZ_NONE 0\n#define GZ_READ 7247\n#define GZ_WRITE 31153\n#define GZ_APPEND 1     /* mode set to GZ_WRITE after the file is opened */\n\n/* values for gz_state how */\n#define LOOK 0      /* look for a gzip header */\n#define COPY 1      /* copy input directly */\n#define GZIP 2      /* decompress a gzip stream */\n\n/* internal gzip file state data structure */\ntypedef struct {\n        /* exposed contents for gzgetc() macro */\n    struct gzFile_s x;      /* \"x\" for exposed */\n                            /* x.have: number of bytes available at x.next */\n                            /* x.next: next output data to deliver or write */\n                            /* x.pos: current position in uncompressed data */\n        /* used for both reading and writing */\n    int mode;               /* see gzip modes above */\n    int fd;                 /* file descriptor */\n    char *path;             /* path or fd for error messages */\n    unsigned size;          /* buffer size, zero if not allocated yet */\n    unsigned want;          /* requested buffer size, default is GZBUFSIZE */\n    unsigned char *in;      /* input buffer (double-sized when writing) */\n    unsigned char *out;     /* output buffer (double-sized when reading) */\n    int direct;             /* 0 if processing gzip, 1 if transparent */\n        /* just for reading */\n    int how;                /* 0: get header, 1: copy, 2: decompress */\n    z_off64_t start;        /* where the gzip data started, for rewinding */\n    int eof;                /* true if end of input file reached */\n    int past;               /* true if read requested past end */\n        /* just for writing */\n    int level;              /* compression level */\n    int strategy;           /* compression strategy */\n    int reset;              /* true if a reset is pending after a Z_FINISH */\n        /* seek request */\n    z_off64_t skip;         /* amount to skip (already rewound if backwards) */\n    int seek;               /* true if seek request pending */\n        /* error information */\n    int err;                /* error code */\n    char *msg;              /* error message */\n        /* zlib inflate or deflate stream */\n    z_stream strm;          /* stream structure in-place (not a pointer) */\n} gz_state;\ntypedef gz_state FAR *gz_statep;\n\n/* shared functions */\nvoid ZLIB_INTERNAL gz_error(gz_statep, int, const char *);\n#if defined UNDER_CE\nchar ZLIB_INTERNAL *gz_strwinerror(DWORD error);\n#endif\n\n/* GT_OFF(x), where x is an unsigned value, is true if x > maximum z_off64_t\n   value -- needed when comparing unsigned to z_off64_t, which is signed\n   (possible z_off64_t types off_t, off64_t, and long are all signed) */\nunsigned ZLIB_INTERNAL gz_intmax(void);\n#define GT_OFF(x) (sizeof(int) == sizeof(z_off64_t) && (x) > gz_intmax())\n"
        },
        {
          "name": "gzlib.c",
          "type": "blob",
          "size": 16.005859375,
          "content": "/* gzlib.c -- zlib functions common to reading and writing gzip files\n * Copyright (C) 2004-2024 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n#include \"gzguts.h\"\n\n#if defined(__DJGPP__)\n#  define LSEEK llseek\n#elif defined(_WIN32) && !defined(__BORLANDC__) && !defined(UNDER_CE)\n#  define LSEEK _lseeki64\n#elif defined(_LARGEFILE64_SOURCE) && _LFS64_LARGEFILE-0\n#  define LSEEK lseek64\n#else\n#  define LSEEK lseek\n#endif\n\n#if defined UNDER_CE\n\n/* Map the Windows error number in ERROR to a locale-dependent error message\n   string and return a pointer to it.  Typically, the values for ERROR come\n   from GetLastError.\n\n   The string pointed to shall not be modified by the application, but may be\n   overwritten by a subsequent call to gz_strwinerror\n\n   The gz_strwinerror function does not change the current setting of\n   GetLastError. */\nchar ZLIB_INTERNAL *gz_strwinerror(DWORD error) {\n    static char buf[1024];\n\n    wchar_t *msgbuf;\n    DWORD lasterr = GetLastError();\n    DWORD chars = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM\n        | FORMAT_MESSAGE_ALLOCATE_BUFFER,\n        NULL,\n        error,\n        0, /* Default language */\n        (LPVOID)&msgbuf,\n        0,\n        NULL);\n    if (chars != 0) {\n        /* If there is an \\r\\n appended, zap it.  */\n        if (chars >= 2\n            && msgbuf[chars - 2] == '\\r' && msgbuf[chars - 1] == '\\n') {\n            chars -= 2;\n            msgbuf[chars] = 0;\n        }\n\n        if (chars > sizeof (buf) - 1) {\n            chars = sizeof (buf) - 1;\n            msgbuf[chars] = 0;\n        }\n\n        wcstombs(buf, msgbuf, chars + 1);       // assumes buf is big enough\n        LocalFree(msgbuf);\n    }\n    else {\n        sprintf(buf, \"unknown win32 error (%ld)\", error);\n    }\n\n    SetLastError(lasterr);\n    return buf;\n}\n\n#endif /* UNDER_CE */\n\n/* Reset gzip file state */\nlocal void gz_reset(gz_statep state) {\n    state->x.have = 0;              /* no output data available */\n    if (state->mode == GZ_READ) {   /* for reading ... */\n        state->eof = 0;             /* not at end of file */\n        state->past = 0;            /* have not read past end yet */\n        state->how = LOOK;          /* look for gzip header */\n    }\n    else                            /* for writing ... */\n        state->reset = 0;           /* no deflateReset pending */\n    state->seek = 0;                /* no seek request pending */\n    gz_error(state, Z_OK, NULL);    /* clear error */\n    state->x.pos = 0;               /* no uncompressed data yet */\n    state->strm.avail_in = 0;       /* no input data yet */\n}\n\n/* Open a gzip file either by name or file descriptor. */\nlocal gzFile gz_open(const void *path, int fd, const char *mode) {\n    gz_statep state;\n    z_size_t len;\n    int oflag;\n#ifdef O_CLOEXEC\n    int cloexec = 0;\n#endif\n#ifdef O_EXCL\n    int exclusive = 0;\n#endif\n\n    /* check input */\n    if (path == NULL)\n        return NULL;\n\n    /* allocate gzFile structure to return */\n    state = (gz_statep)malloc(sizeof(gz_state));\n    if (state == NULL)\n        return NULL;\n    state->size = 0;            /* no buffers allocated yet */\n    state->want = GZBUFSIZE;    /* requested buffer size */\n    state->msg = NULL;          /* no error message yet */\n\n    /* interpret mode */\n    state->mode = GZ_NONE;\n    state->level = Z_DEFAULT_COMPRESSION;\n    state->strategy = Z_DEFAULT_STRATEGY;\n    state->direct = 0;\n    while (*mode) {\n        if (*mode >= '0' && *mode <= '9')\n            state->level = *mode - '0';\n        else\n            switch (*mode) {\n            case 'r':\n                state->mode = GZ_READ;\n                break;\n#ifndef NO_GZCOMPRESS\n            case 'w':\n                state->mode = GZ_WRITE;\n                break;\n            case 'a':\n                state->mode = GZ_APPEND;\n                break;\n#endif\n            case '+':       /* can't read and write at the same time */\n                free(state);\n                return NULL;\n            case 'b':       /* ignore -- will request binary anyway */\n                break;\n#ifdef O_CLOEXEC\n            case 'e':\n                cloexec = 1;\n                break;\n#endif\n#ifdef O_EXCL\n            case 'x':\n                exclusive = 1;\n                break;\n#endif\n            case 'f':\n                state->strategy = Z_FILTERED;\n                break;\n            case 'h':\n                state->strategy = Z_HUFFMAN_ONLY;\n                break;\n            case 'R':\n                state->strategy = Z_RLE;\n                break;\n            case 'F':\n                state->strategy = Z_FIXED;\n                break;\n            case 'T':\n                state->direct = 1;\n                break;\n            default:        /* could consider as an error, but just ignore */\n                ;\n            }\n        mode++;\n    }\n\n    /* must provide an \"r\", \"w\", or \"a\" */\n    if (state->mode == GZ_NONE) {\n        free(state);\n        return NULL;\n    }\n\n    /* can't force transparent read */\n    if (state->mode == GZ_READ) {\n        if (state->direct) {\n            free(state);\n            return NULL;\n        }\n        state->direct = 1;      /* for empty file */\n    }\n\n    /* save the path name for error messages */\n#ifdef WIDECHAR\n    if (fd == -2)\n        len = wcstombs(NULL, path, 0);\n    else\n#endif\n        len = strlen((const char *)path);\n    state->path = (char *)malloc(len + 1);\n    if (state->path == NULL) {\n        free(state);\n        return NULL;\n    }\n#ifdef WIDECHAR\n    if (fd == -2) {\n        if (len)\n            wcstombs(state->path, path, len + 1);\n        else\n            *(state->path) = 0;\n    }\n    else\n#endif\n    {\n#if !defined(NO_snprintf) && !defined(NO_vsnprintf)\n        (void)snprintf(state->path, len + 1, \"%s\", (const char *)path);\n#else\n        strcpy(state->path, path);\n#endif\n    }\n\n    /* compute the flags for open() */\n    oflag =\n#ifdef O_LARGEFILE\n        O_LARGEFILE |\n#endif\n#ifdef O_BINARY\n        O_BINARY |\n#endif\n#ifdef O_CLOEXEC\n        (cloexec ? O_CLOEXEC : 0) |\n#endif\n        (state->mode == GZ_READ ?\n         O_RDONLY :\n         (O_WRONLY | O_CREAT |\n#ifdef O_EXCL\n          (exclusive ? O_EXCL : 0) |\n#endif\n          (state->mode == GZ_WRITE ?\n           O_TRUNC :\n           O_APPEND)));\n\n    /* open the file with the appropriate flags (or just use fd) */\n    if (fd == -1)\n        state->fd = open((const char *)path, oflag, 0666);\n#ifdef WIDECHAR\n    else if (fd == -2)\n        state->fd = _wopen(path, oflag, _S_IREAD | _S_IWRITE);\n#endif\n    else\n        state->fd = fd;\n    if (state->fd == -1) {\n        free(state->path);\n        free(state);\n        return NULL;\n    }\n    if (state->mode == GZ_APPEND) {\n        LSEEK(state->fd, 0, SEEK_END);  /* so gzoffset() is correct */\n        state->mode = GZ_WRITE;         /* simplify later checks */\n    }\n\n    /* save the current position for rewinding (only if reading) */\n    if (state->mode == GZ_READ) {\n        state->start = LSEEK(state->fd, 0, SEEK_CUR);\n        if (state->start == -1) state->start = 0;\n    }\n\n    /* initialize stream */\n    gz_reset(state);\n\n    /* return stream */\n    return (gzFile)state;\n}\n\n/* -- see zlib.h -- */\ngzFile ZEXPORT gzopen(const char *path, const char *mode) {\n    return gz_open(path, -1, mode);\n}\n\n/* -- see zlib.h -- */\ngzFile ZEXPORT gzopen64(const char *path, const char *mode) {\n    return gz_open(path, -1, mode);\n}\n\n/* -- see zlib.h -- */\ngzFile ZEXPORT gzdopen(int fd, const char *mode) {\n    char *path;         /* identifier for error messages */\n    gzFile gz;\n\n    if (fd == -1 || (path = (char *)malloc(7 + 3 * sizeof(int))) == NULL)\n        return NULL;\n#if !defined(NO_snprintf) && !defined(NO_vsnprintf)\n    (void)snprintf(path, 7 + 3 * sizeof(int), \"<fd:%d>\", fd);\n#else\n    sprintf(path, \"<fd:%d>\", fd);   /* for debugging */\n#endif\n    gz = gz_open(path, fd, mode);\n    free(path);\n    return gz;\n}\n\n/* -- see zlib.h -- */\n#ifdef WIDECHAR\ngzFile ZEXPORT gzopen_w(const wchar_t *path, const char *mode) {\n    return gz_open(path, -2, mode);\n}\n#endif\n\n/* -- see zlib.h -- */\nint ZEXPORT gzbuffer(gzFile file, unsigned size) {\n    gz_statep state;\n\n    /* get internal structure and check integrity */\n    if (file == NULL)\n        return -1;\n    state = (gz_statep)file;\n    if (state->mode != GZ_READ && state->mode != GZ_WRITE)\n        return -1;\n\n    /* make sure we haven't already allocated memory */\n    if (state->size != 0)\n        return -1;\n\n    /* check and set requested size */\n    if ((size << 1) < size)\n        return -1;              /* need to be able to double it */\n    if (size < 8)\n        size = 8;               /* needed to behave well with flushing */\n    state->want = size;\n    return 0;\n}\n\n/* -- see zlib.h -- */\nint ZEXPORT gzrewind(gzFile file) {\n    gz_statep state;\n\n    /* get internal structure */\n    if (file == NULL)\n        return -1;\n    state = (gz_statep)file;\n\n    /* check that we're reading and that there's no error */\n    if (state->mode != GZ_READ ||\n            (state->err != Z_OK && state->err != Z_BUF_ERROR))\n        return -1;\n\n    /* back up and start over */\n    if (LSEEK(state->fd, state->start, SEEK_SET) == -1)\n        return -1;\n    gz_reset(state);\n    return 0;\n}\n\n/* -- see zlib.h -- */\nz_off64_t ZEXPORT gzseek64(gzFile file, z_off64_t offset, int whence) {\n    unsigned n;\n    z_off64_t ret;\n    gz_statep state;\n\n    /* get internal structure and check integrity */\n    if (file == NULL)\n        return -1;\n    state = (gz_statep)file;\n    if (state->mode != GZ_READ && state->mode != GZ_WRITE)\n        return -1;\n\n    /* check that there's no error */\n    if (state->err != Z_OK && state->err != Z_BUF_ERROR)\n        return -1;\n\n    /* can only seek from start or relative to current position */\n    if (whence != SEEK_SET && whence != SEEK_CUR)\n        return -1;\n\n    /* normalize offset to a SEEK_CUR specification */\n    if (whence == SEEK_SET)\n        offset -= state->x.pos;\n    else if (state->seek)\n        offset += state->skip;\n    state->seek = 0;\n\n    /* if within raw area while reading, just go there */\n    if (state->mode == GZ_READ && state->how == COPY &&\n            state->x.pos + offset >= 0) {\n        ret = LSEEK(state->fd, offset - (z_off64_t)state->x.have, SEEK_CUR);\n        if (ret == -1)\n            return -1;\n        state->x.have = 0;\n        state->eof = 0;\n        state->past = 0;\n        state->seek = 0;\n        gz_error(state, Z_OK, NULL);\n        state->strm.avail_in = 0;\n        state->x.pos += offset;\n        return state->x.pos;\n    }\n\n    /* calculate skip amount, rewinding if needed for back seek when reading */\n    if (offset < 0) {\n        if (state->mode != GZ_READ)         /* writing -- can't go backwards */\n            return -1;\n        offset += state->x.pos;\n        if (offset < 0)                     /* before start of file! */\n            return -1;\n        if (gzrewind(file) == -1)           /* rewind, then skip to offset */\n            return -1;\n    }\n\n    /* if reading, skip what's in output buffer (one less gzgetc() check) */\n    if (state->mode == GZ_READ) {\n        n = GT_OFF(state->x.have) || (z_off64_t)state->x.have > offset ?\n            (unsigned)offset : state->x.have;\n        state->x.have -= n;\n        state->x.next += n;\n        state->x.pos += n;\n        offset -= n;\n    }\n\n    /* request skip (if not zero) */\n    if (offset) {\n        state->seek = 1;\n        state->skip = offset;\n    }\n    return state->x.pos + offset;\n}\n\n/* -- see zlib.h -- */\nz_off_t ZEXPORT gzseek(gzFile file, z_off_t offset, int whence) {\n    z_off64_t ret;\n\n    ret = gzseek64(file, (z_off64_t)offset, whence);\n    return ret == (z_off_t)ret ? (z_off_t)ret : -1;\n}\n\n/* -- see zlib.h -- */\nz_off64_t ZEXPORT gztell64(gzFile file) {\n    gz_statep state;\n\n    /* get internal structure and check integrity */\n    if (file == NULL)\n        return -1;\n    state = (gz_statep)file;\n    if (state->mode != GZ_READ && state->mode != GZ_WRITE)\n        return -1;\n\n    /* return position */\n    return state->x.pos + (state->seek ? state->skip : 0);\n}\n\n/* -- see zlib.h -- */\nz_off_t ZEXPORT gztell(gzFile file) {\n    z_off64_t ret;\n\n    ret = gztell64(file);\n    return ret == (z_off_t)ret ? (z_off_t)ret : -1;\n}\n\n/* -- see zlib.h -- */\nz_off64_t ZEXPORT gzoffset64(gzFile file) {\n    z_off64_t offset;\n    gz_statep state;\n\n    /* get internal structure and check integrity */\n    if (file == NULL)\n        return -1;\n    state = (gz_statep)file;\n    if (state->mode != GZ_READ && state->mode != GZ_WRITE)\n        return -1;\n\n    /* compute and return effective offset in file */\n    offset = LSEEK(state->fd, 0, SEEK_CUR);\n    if (offset == -1)\n        return -1;\n    if (state->mode == GZ_READ)             /* reading */\n        offset -= state->strm.avail_in;     /* don't count buffered input */\n    return offset;\n}\n\n/* -- see zlib.h -- */\nz_off_t ZEXPORT gzoffset(gzFile file) {\n    z_off64_t ret;\n\n    ret = gzoffset64(file);\n    return ret == (z_off_t)ret ? (z_off_t)ret : -1;\n}\n\n/* -- see zlib.h -- */\nint ZEXPORT gzeof(gzFile file) {\n    gz_statep state;\n\n    /* get internal structure and check integrity */\n    if (file == NULL)\n        return 0;\n    state = (gz_statep)file;\n    if (state->mode != GZ_READ && state->mode != GZ_WRITE)\n        return 0;\n\n    /* return end-of-file state */\n    return state->mode == GZ_READ ? state->past : 0;\n}\n\n/* -- see zlib.h -- */\nconst char * ZEXPORT gzerror(gzFile file, int *errnum) {\n    gz_statep state;\n\n    /* get internal structure and check integrity */\n    if (file == NULL)\n        return NULL;\n    state = (gz_statep)file;\n    if (state->mode != GZ_READ && state->mode != GZ_WRITE)\n        return NULL;\n\n    /* return error information */\n    if (errnum != NULL)\n        *errnum = state->err;\n    return state->err == Z_MEM_ERROR ? \"out of memory\" :\n                                       (state->msg == NULL ? \"\" : state->msg);\n}\n\n/* -- see zlib.h -- */\nvoid ZEXPORT gzclearerr(gzFile file) {\n    gz_statep state;\n\n    /* get internal structure and check integrity */\n    if (file == NULL)\n        return;\n    state = (gz_statep)file;\n    if (state->mode != GZ_READ && state->mode != GZ_WRITE)\n        return;\n\n    /* clear error and end-of-file */\n    if (state->mode == GZ_READ) {\n        state->eof = 0;\n        state->past = 0;\n    }\n    gz_error(state, Z_OK, NULL);\n}\n\n/* Create an error message in allocated memory and set state->err and\n   state->msg accordingly.  Free any previous error message already there.  Do\n   not try to free or allocate space if the error is Z_MEM_ERROR (out of\n   memory).  Simply save the error message as a static string.  If there is an\n   allocation failure constructing the error message, then convert the error to\n   out of memory. */\nvoid ZLIB_INTERNAL gz_error(gz_statep state, int err, const char *msg) {\n    /* free previously allocated message and clear */\n    if (state->msg != NULL) {\n        if (state->err != Z_MEM_ERROR)\n            free(state->msg);\n        state->msg = NULL;\n    }\n\n    /* if fatal, set state->x.have to 0 so that the gzgetc() macro fails */\n    if (err != Z_OK && err != Z_BUF_ERROR)\n        state->x.have = 0;\n\n    /* set error code, and if no message, then done */\n    state->err = err;\n    if (msg == NULL)\n        return;\n\n    /* for an out of memory error, return literal string when requested */\n    if (err == Z_MEM_ERROR)\n        return;\n\n    /* construct error message with path */\n    if ((state->msg = (char *)malloc(strlen(state->path) + strlen(msg) + 3)) ==\n            NULL) {\n        state->err = Z_MEM_ERROR;\n        return;\n    }\n#if !defined(NO_snprintf) && !defined(NO_vsnprintf)\n    (void)snprintf(state->msg, strlen(state->path) + strlen(msg) + 3,\n                   \"%s%s%s\", state->path, \": \", msg);\n#else\n    strcpy(state->msg, state->path);\n    strcat(state->msg, \": \");\n    strcat(state->msg, msg);\n#endif\n}\n\n/* portably return maximum value for an int (when limits.h presumed not\n   available) -- we need to do this to cover cases where 2's complement not\n   used, since C standard permits 1's complement and sign-bit representations,\n   otherwise we could just use ((unsigned)-1) >> 1 */\nunsigned ZLIB_INTERNAL gz_intmax(void) {\n#ifdef INT_MAX\n    return INT_MAX;\n#else\n    unsigned p = 1, q;\n    do {\n        q = p;\n        p <<= 1;\n        p++;\n    } while (p > q);\n    return q >> 1;\n#endif\n}\n"
        },
        {
          "name": "gzread.c",
          "type": "blob",
          "size": 19.4755859375,
          "content": "/* gzread.c -- zlib functions for reading gzip files\n * Copyright (C) 2004-2017 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n#include \"gzguts.h\"\n\n/* Use read() to load a buffer -- return -1 on error, otherwise 0.  Read from\n   state->fd, and update state->eof, state->err, and state->msg as appropriate.\n   This function needs to loop on read(), since read() is not guaranteed to\n   read the number of bytes requested, depending on the type of descriptor. */\nlocal int gz_load(gz_statep state, unsigned char *buf, unsigned len,\n                  unsigned *have) {\n    int ret;\n    unsigned get, max = ((unsigned)-1 >> 2) + 1;\n\n    *have = 0;\n    do {\n        get = len - *have;\n        if (get > max)\n            get = max;\n        ret = read(state->fd, buf + *have, get);\n        if (ret <= 0)\n            break;\n        *have += (unsigned)ret;\n    } while (*have < len);\n    if (ret < 0) {\n        gz_error(state, Z_ERRNO, zstrerror());\n        return -1;\n    }\n    if (ret == 0)\n        state->eof = 1;\n    return 0;\n}\n\n/* Load up input buffer and set eof flag if last data loaded -- return -1 on\n   error, 0 otherwise.  Note that the eof flag is set when the end of the input\n   file is reached, even though there may be unused data in the buffer.  Once\n   that data has been used, no more attempts will be made to read the file.\n   If strm->avail_in != 0, then the current data is moved to the beginning of\n   the input buffer, and then the remainder of the buffer is loaded with the\n   available data from the input file. */\nlocal int gz_avail(gz_statep state) {\n    unsigned got;\n    z_streamp strm = &(state->strm);\n\n    if (state->err != Z_OK && state->err != Z_BUF_ERROR)\n        return -1;\n    if (state->eof == 0) {\n        if (strm->avail_in) {       /* copy what's there to the start */\n            unsigned char *p = state->in;\n            unsigned const char *q = strm->next_in;\n            unsigned n = strm->avail_in;\n            do {\n                *p++ = *q++;\n            } while (--n);\n        }\n        if (gz_load(state, state->in + strm->avail_in,\n                    state->size - strm->avail_in, &got) == -1)\n            return -1;\n        strm->avail_in += got;\n        strm->next_in = state->in;\n    }\n    return 0;\n}\n\n/* Look for gzip header, set up for inflate or copy.  state->x.have must be 0.\n   If this is the first time in, allocate required memory.  state->how will be\n   left unchanged if there is no more input data available, will be set to COPY\n   if there is no gzip header and direct copying will be performed, or it will\n   be set to GZIP for decompression.  If direct copying, then leftover input\n   data from the input buffer will be copied to the output buffer.  In that\n   case, all further file reads will be directly to either the output buffer or\n   a user buffer.  If decompressing, the inflate state will be initialized.\n   gz_look() will return 0 on success or -1 on failure. */\nlocal int gz_look(gz_statep state) {\n    z_streamp strm = &(state->strm);\n\n    /* allocate read buffers and inflate memory */\n    if (state->size == 0) {\n        /* allocate buffers */\n        state->in = (unsigned char *)malloc(state->want);\n        state->out = (unsigned char *)malloc(state->want << 1);\n        if (state->in == NULL || state->out == NULL) {\n            free(state->out);\n            free(state->in);\n            gz_error(state, Z_MEM_ERROR, \"out of memory\");\n            return -1;\n        }\n        state->size = state->want;\n\n        /* allocate inflate memory */\n        state->strm.zalloc = Z_NULL;\n        state->strm.zfree = Z_NULL;\n        state->strm.opaque = Z_NULL;\n        state->strm.avail_in = 0;\n        state->strm.next_in = Z_NULL;\n        if (inflateInit2(&(state->strm), 15 + 16) != Z_OK) {    /* gunzip */\n            free(state->out);\n            free(state->in);\n            state->size = 0;\n            gz_error(state, Z_MEM_ERROR, \"out of memory\");\n            return -1;\n        }\n    }\n\n    /* get at least the magic bytes in the input buffer */\n    if (strm->avail_in < 2) {\n        if (gz_avail(state) == -1)\n            return -1;\n        if (strm->avail_in == 0)\n            return 0;\n    }\n\n    /* look for gzip magic bytes -- if there, do gzip decoding (note: there is\n       a logical dilemma here when considering the case of a partially written\n       gzip file, to wit, if a single 31 byte is written, then we cannot tell\n       whether this is a single-byte file, or just a partially written gzip\n       file -- for here we assume that if a gzip file is being written, then\n       the header will be written in a single operation, so that reading a\n       single byte is sufficient indication that it is not a gzip file) */\n    if (strm->avail_in > 1 &&\n            strm->next_in[0] == 31 && strm->next_in[1] == 139) {\n        inflateReset(strm);\n        state->how = GZIP;\n        state->direct = 0;\n        return 0;\n    }\n\n    /* no gzip header -- if we were decoding gzip before, then this is trailing\n       garbage.  Ignore the trailing garbage and finish. */\n    if (state->direct == 0) {\n        strm->avail_in = 0;\n        state->eof = 1;\n        state->x.have = 0;\n        return 0;\n    }\n\n    /* doing raw i/o, copy any leftover input to output -- this assumes that\n       the output buffer is larger than the input buffer, which also assures\n       space for gzungetc() */\n    state->x.next = state->out;\n    memcpy(state->x.next, strm->next_in, strm->avail_in);\n    state->x.have = strm->avail_in;\n    strm->avail_in = 0;\n    state->how = COPY;\n    state->direct = 1;\n    return 0;\n}\n\n/* Decompress from input to the provided next_out and avail_out in the state.\n   On return, state->x.have and state->x.next point to the just decompressed\n   data.  If the gzip stream completes, state->how is reset to LOOK to look for\n   the next gzip stream or raw data, once state->x.have is depleted.  Returns 0\n   on success, -1 on failure. */\nlocal int gz_decomp(gz_statep state) {\n    int ret = Z_OK;\n    unsigned had;\n    z_streamp strm = &(state->strm);\n\n    /* fill output buffer up to end of deflate stream */\n    had = strm->avail_out;\n    do {\n        /* get more input for inflate() */\n        if (strm->avail_in == 0 && gz_avail(state) == -1)\n            return -1;\n        if (strm->avail_in == 0) {\n            gz_error(state, Z_BUF_ERROR, \"unexpected end of file\");\n            break;\n        }\n\n        /* decompress and handle errors */\n        ret = inflate(strm, Z_NO_FLUSH);\n        if (ret == Z_STREAM_ERROR || ret == Z_NEED_DICT) {\n            gz_error(state, Z_STREAM_ERROR,\n                     \"internal error: inflate stream corrupt\");\n            return -1;\n        }\n        if (ret == Z_MEM_ERROR) {\n            gz_error(state, Z_MEM_ERROR, \"out of memory\");\n            return -1;\n        }\n        if (ret == Z_DATA_ERROR) {              /* deflate stream invalid */\n            gz_error(state, Z_DATA_ERROR,\n                     strm->msg == NULL ? \"compressed data error\" : strm->msg);\n            return -1;\n        }\n    } while (strm->avail_out && ret != Z_STREAM_END);\n\n    /* update available output */\n    state->x.have = had - strm->avail_out;\n    state->x.next = strm->next_out - state->x.have;\n\n    /* if the gzip stream completed successfully, look for another */\n    if (ret == Z_STREAM_END)\n        state->how = LOOK;\n\n    /* good decompression */\n    return 0;\n}\n\n/* Fetch data and put it in the output buffer.  Assumes state->x.have is 0.\n   Data is either copied from the input file or decompressed from the input\n   file depending on state->how.  If state->how is LOOK, then a gzip header is\n   looked for to determine whether to copy or decompress.  Returns -1 on error,\n   otherwise 0.  gz_fetch() will leave state->how as COPY or GZIP unless the\n   end of the input file has been reached and all data has been processed.  */\nlocal int gz_fetch(gz_statep state) {\n    z_streamp strm = &(state->strm);\n\n    do {\n        switch(state->how) {\n        case LOOK:      /* -> LOOK, COPY (only if never GZIP), or GZIP */\n            if (gz_look(state) == -1)\n                return -1;\n            if (state->how == LOOK)\n                return 0;\n            break;\n        case COPY:      /* -> COPY */\n            if (gz_load(state, state->out, state->size << 1, &(state->x.have))\n                    == -1)\n                return -1;\n            state->x.next = state->out;\n            return 0;\n        case GZIP:      /* -> GZIP or LOOK (if end of gzip stream) */\n            strm->avail_out = state->size << 1;\n            strm->next_out = state->out;\n            if (gz_decomp(state) == -1)\n                return -1;\n        }\n    } while (state->x.have == 0 && (!state->eof || strm->avail_in));\n    return 0;\n}\n\n/* Skip len uncompressed bytes of output.  Return -1 on error, 0 on success. */\nlocal int gz_skip(gz_statep state, z_off64_t len) {\n    unsigned n;\n\n    /* skip over len bytes or reach end-of-file, whichever comes first */\n    while (len)\n        /* skip over whatever is in output buffer */\n        if (state->x.have) {\n            n = GT_OFF(state->x.have) || (z_off64_t)state->x.have > len ?\n                (unsigned)len : state->x.have;\n            state->x.have -= n;\n            state->x.next += n;\n            state->x.pos += n;\n            len -= n;\n        }\n\n        /* output buffer empty -- return if we're at the end of the input */\n        else if (state->eof && state->strm.avail_in == 0)\n            break;\n\n        /* need more data to skip -- load up output buffer */\n        else {\n            /* get more output, looking for header if required */\n            if (gz_fetch(state) == -1)\n                return -1;\n        }\n    return 0;\n}\n\n/* Read len bytes into buf from file, or less than len up to the end of the\n   input.  Return the number of bytes read.  If zero is returned, either the\n   end of file was reached, or there was an error.  state->err must be\n   consulted in that case to determine which. */\nlocal z_size_t gz_read(gz_statep state, voidp buf, z_size_t len) {\n    z_size_t got;\n    unsigned n;\n\n    /* if len is zero, avoid unnecessary operations */\n    if (len == 0)\n        return 0;\n\n    /* process a skip request */\n    if (state->seek) {\n        state->seek = 0;\n        if (gz_skip(state, state->skip) == -1)\n            return 0;\n    }\n\n    /* get len bytes to buf, or less than len if at the end */\n    got = 0;\n    do {\n        /* set n to the maximum amount of len that fits in an unsigned int */\n        n = (unsigned)-1;\n        if (n > len)\n            n = (unsigned)len;\n\n        /* first just try copying data from the output buffer */\n        if (state->x.have) {\n            if (state->x.have < n)\n                n = state->x.have;\n            memcpy(buf, state->x.next, n);\n            state->x.next += n;\n            state->x.have -= n;\n        }\n\n        /* output buffer empty -- return if we're at the end of the input */\n        else if (state->eof && state->strm.avail_in == 0) {\n            state->past = 1;        /* tried to read past end */\n            break;\n        }\n\n        /* need output data -- for small len or new stream load up our output\n           buffer */\n        else if (state->how == LOOK || n < (state->size << 1)) {\n            /* get more output, looking for header if required */\n            if (gz_fetch(state) == -1)\n                return 0;\n            continue;       /* no progress yet -- go back to copy above */\n            /* the copy above assures that we will leave with space in the\n               output buffer, allowing at least one gzungetc() to succeed */\n        }\n\n        /* large len -- read directly into user buffer */\n        else if (state->how == COPY) {      /* read directly */\n            if (gz_load(state, (unsigned char *)buf, n, &n) == -1)\n                return 0;\n        }\n\n        /* large len -- decompress directly into user buffer */\n        else {  /* state->how == GZIP */\n            state->strm.avail_out = n;\n            state->strm.next_out = (unsigned char *)buf;\n            if (gz_decomp(state) == -1)\n                return 0;\n            n = state->x.have;\n            state->x.have = 0;\n        }\n\n        /* update progress */\n        len -= n;\n        buf = (char *)buf + n;\n        got += n;\n        state->x.pos += n;\n    } while (len);\n\n    /* return number of bytes read into user buffer */\n    return got;\n}\n\n/* -- see zlib.h -- */\nint ZEXPORT gzread(gzFile file, voidp buf, unsigned len) {\n    gz_statep state;\n\n    /* get internal structure */\n    if (file == NULL)\n        return -1;\n    state = (gz_statep)file;\n\n    /* check that we're reading and that there's no (serious) error */\n    if (state->mode != GZ_READ ||\n            (state->err != Z_OK && state->err != Z_BUF_ERROR))\n        return -1;\n\n    /* since an int is returned, make sure len fits in one, otherwise return\n       with an error (this avoids a flaw in the interface) */\n    if ((int)len < 0) {\n        gz_error(state, Z_STREAM_ERROR, \"request does not fit in an int\");\n        return -1;\n    }\n\n    /* read len or fewer bytes to buf */\n    len = (unsigned)gz_read(state, buf, len);\n\n    /* check for an error */\n    if (len == 0 && state->err != Z_OK && state->err != Z_BUF_ERROR)\n        return -1;\n\n    /* return the number of bytes read (this is assured to fit in an int) */\n    return (int)len;\n}\n\n/* -- see zlib.h -- */\nz_size_t ZEXPORT gzfread(voidp buf, z_size_t size, z_size_t nitems,\n                         gzFile file) {\n    z_size_t len;\n    gz_statep state;\n\n    /* get internal structure */\n    if (file == NULL)\n        return 0;\n    state = (gz_statep)file;\n\n    /* check that we're reading and that there's no (serious) error */\n    if (state->mode != GZ_READ ||\n            (state->err != Z_OK && state->err != Z_BUF_ERROR))\n        return 0;\n\n    /* compute bytes to read -- error on overflow */\n    len = nitems * size;\n    if (size && len / size != nitems) {\n        gz_error(state, Z_STREAM_ERROR, \"request does not fit in a size_t\");\n        return 0;\n    }\n\n    /* read len or fewer bytes to buf, return the number of full items read */\n    return len ? gz_read(state, buf, len) / size : 0;\n}\n\n/* -- see zlib.h -- */\n#ifdef Z_PREFIX_SET\n#  undef z_gzgetc\n#else\n#  undef gzgetc\n#endif\nint ZEXPORT gzgetc(gzFile file) {\n    unsigned char buf[1];\n    gz_statep state;\n\n    /* get internal structure */\n    if (file == NULL)\n        return -1;\n    state = (gz_statep)file;\n\n    /* check that we're reading and that there's no (serious) error */\n    if (state->mode != GZ_READ ||\n        (state->err != Z_OK && state->err != Z_BUF_ERROR))\n        return -1;\n\n    /* try output buffer (no need to check for skip request) */\n    if (state->x.have) {\n        state->x.have--;\n        state->x.pos++;\n        return *(state->x.next)++;\n    }\n\n    /* nothing there -- try gz_read() */\n    return gz_read(state, buf, 1) < 1 ? -1 : buf[0];\n}\n\nint ZEXPORT gzgetc_(gzFile file) {\n    return gzgetc(file);\n}\n\n/* -- see zlib.h -- */\nint ZEXPORT gzungetc(int c, gzFile file) {\n    gz_statep state;\n\n    /* get internal structure */\n    if (file == NULL)\n        return -1;\n    state = (gz_statep)file;\n\n    /* in case this was just opened, set up the input buffer */\n    if (state->mode == GZ_READ && state->how == LOOK && state->x.have == 0)\n        (void)gz_look(state);\n\n    /* check that we're reading and that there's no (serious) error */\n    if (state->mode != GZ_READ ||\n        (state->err != Z_OK && state->err != Z_BUF_ERROR))\n        return -1;\n\n    /* process a skip request */\n    if (state->seek) {\n        state->seek = 0;\n        if (gz_skip(state, state->skip) == -1)\n            return -1;\n    }\n\n    /* can't push EOF */\n    if (c < 0)\n        return -1;\n\n    /* if output buffer empty, put byte at end (allows more pushing) */\n    if (state->x.have == 0) {\n        state->x.have = 1;\n        state->x.next = state->out + (state->size << 1) - 1;\n        state->x.next[0] = (unsigned char)c;\n        state->x.pos--;\n        state->past = 0;\n        return c;\n    }\n\n    /* if no room, give up (must have already done a gzungetc()) */\n    if (state->x.have == (state->size << 1)) {\n        gz_error(state, Z_DATA_ERROR, \"out of room to push characters\");\n        return -1;\n    }\n\n    /* slide output data if needed and insert byte before existing data */\n    if (state->x.next == state->out) {\n        unsigned char *src = state->out + state->x.have;\n        unsigned char *dest = state->out + (state->size << 1);\n        while (src > state->out)\n            *--dest = *--src;\n        state->x.next = dest;\n    }\n    state->x.have++;\n    state->x.next--;\n    state->x.next[0] = (unsigned char)c;\n    state->x.pos--;\n    state->past = 0;\n    return c;\n}\n\n/* -- see zlib.h -- */\nchar * ZEXPORT gzgets(gzFile file, char *buf, int len) {\n    unsigned left, n;\n    char *str;\n    unsigned char *eol;\n    gz_statep state;\n\n    /* check parameters and get internal structure */\n    if (file == NULL || buf == NULL || len < 1)\n        return NULL;\n    state = (gz_statep)file;\n\n    /* check that we're reading and that there's no (serious) error */\n    if (state->mode != GZ_READ ||\n        (state->err != Z_OK && state->err != Z_BUF_ERROR))\n        return NULL;\n\n    /* process a skip request */\n    if (state->seek) {\n        state->seek = 0;\n        if (gz_skip(state, state->skip) == -1)\n            return NULL;\n    }\n\n    /* copy output bytes up to new line or len - 1, whichever comes first --\n       append a terminating zero to the string (we don't check for a zero in\n       the contents, let the user worry about that) */\n    str = buf;\n    left = (unsigned)len - 1;\n    if (left) do {\n        /* assure that something is in the output buffer */\n        if (state->x.have == 0 && gz_fetch(state) == -1)\n            return NULL;                /* error */\n        if (state->x.have == 0) {       /* end of file */\n            state->past = 1;            /* read past end */\n            break;                      /* return what we have */\n        }\n\n        /* look for end-of-line in current output buffer */\n        n = state->x.have > left ? left : state->x.have;\n        eol = (unsigned char *)memchr(state->x.next, '\\n', n);\n        if (eol != NULL)\n            n = (unsigned)(eol - state->x.next) + 1;\n\n        /* copy through end-of-line, or remainder if not found */\n        memcpy(buf, state->x.next, n);\n        state->x.have -= n;\n        state->x.next += n;\n        state->x.pos += n;\n        left -= n;\n        buf += n;\n    } while (left && eol == NULL);\n\n    /* return terminated string, or if nothing, end of file */\n    if (buf == str)\n        return NULL;\n    buf[0] = 0;\n    return str;\n}\n\n/* -- see zlib.h -- */\nint ZEXPORT gzdirect(gzFile file) {\n    gz_statep state;\n\n    /* get internal structure */\n    if (file == NULL)\n        return 0;\n    state = (gz_statep)file;\n\n    /* if the state is not known, but we can find out, then do so (this is\n       mainly for right after a gzopen() or gzdopen()) */\n    if (state->mode == GZ_READ && state->how == LOOK && state->x.have == 0)\n        (void)gz_look(state);\n\n    /* return 1 if transparent, 0 if processing a gzip stream */\n    return state->direct;\n}\n\n/* -- see zlib.h -- */\nint ZEXPORT gzclose_r(gzFile file) {\n    int ret, err;\n    gz_statep state;\n\n    /* get internal structure */\n    if (file == NULL)\n        return Z_STREAM_ERROR;\n    state = (gz_statep)file;\n\n    /* check that we're reading */\n    if (state->mode != GZ_READ)\n        return Z_STREAM_ERROR;\n\n    /* free memory and close file */\n    if (state->size) {\n        inflateEnd(&(state->strm));\n        free(state->out);\n        free(state->in);\n    }\n    err = state->err == Z_BUF_ERROR ? Z_BUF_ERROR : Z_OK;\n    gz_error(state, Z_OK, NULL);\n    free(state->path);\n    ret = close(state->fd);\n    free(state);\n    return ret ? Z_ERRNO : err;\n}\n"
        },
        {
          "name": "gzwrite.c",
          "type": "blob",
          "size": 18.7861328125,
          "content": "/* gzwrite.c -- zlib functions for writing gzip files\n * Copyright (C) 2004-2019 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n#include \"gzguts.h\"\n\n/* Initialize state for writing a gzip file.  Mark initialization by setting\n   state->size to non-zero.  Return -1 on a memory allocation failure, or 0 on\n   success. */\nlocal int gz_init(gz_statep state) {\n    int ret;\n    z_streamp strm = &(state->strm);\n\n    /* allocate input buffer (double size for gzprintf) */\n    state->in = (unsigned char *)malloc(state->want << 1);\n    if (state->in == NULL) {\n        gz_error(state, Z_MEM_ERROR, \"out of memory\");\n        return -1;\n    }\n\n    /* only need output buffer and deflate state if compressing */\n    if (!state->direct) {\n        /* allocate output buffer */\n        state->out = (unsigned char *)malloc(state->want);\n        if (state->out == NULL) {\n            free(state->in);\n            gz_error(state, Z_MEM_ERROR, \"out of memory\");\n            return -1;\n        }\n\n        /* allocate deflate memory, set up for gzip compression */\n        strm->zalloc = Z_NULL;\n        strm->zfree = Z_NULL;\n        strm->opaque = Z_NULL;\n        ret = deflateInit2(strm, state->level, Z_DEFLATED,\n                           MAX_WBITS + 16, DEF_MEM_LEVEL, state->strategy);\n        if (ret != Z_OK) {\n            free(state->out);\n            free(state->in);\n            gz_error(state, Z_MEM_ERROR, \"out of memory\");\n            return -1;\n        }\n        strm->next_in = NULL;\n    }\n\n    /* mark state as initialized */\n    state->size = state->want;\n\n    /* initialize write buffer if compressing */\n    if (!state->direct) {\n        strm->avail_out = state->size;\n        strm->next_out = state->out;\n        state->x.next = strm->next_out;\n    }\n    return 0;\n}\n\n/* Compress whatever is at avail_in and next_in and write to the output file.\n   Return -1 if there is an error writing to the output file or if gz_init()\n   fails to allocate memory, otherwise 0.  flush is assumed to be a valid\n   deflate() flush value.  If flush is Z_FINISH, then the deflate() state is\n   reset to start a new gzip stream.  If gz->direct is true, then simply write\n   to the output file without compressing, and ignore flush. */\nlocal int gz_comp(gz_statep state, int flush) {\n    int ret, writ;\n    unsigned have, put, max = ((unsigned)-1 >> 2) + 1;\n    z_streamp strm = &(state->strm);\n\n    /* allocate memory if this is the first time through */\n    if (state->size == 0 && gz_init(state) == -1)\n        return -1;\n\n    /* write directly if requested */\n    if (state->direct) {\n        while (strm->avail_in) {\n            put = strm->avail_in > max ? max : strm->avail_in;\n            writ = write(state->fd, strm->next_in, put);\n            if (writ < 0) {\n                gz_error(state, Z_ERRNO, zstrerror());\n                return -1;\n            }\n            strm->avail_in -= (unsigned)writ;\n            strm->next_in += writ;\n        }\n        return 0;\n    }\n\n    /* check for a pending reset */\n    if (state->reset) {\n        /* don't start a new gzip member unless there is data to write */\n        if (strm->avail_in == 0)\n            return 0;\n        deflateReset(strm);\n        state->reset = 0;\n    }\n\n    /* run deflate() on provided input until it produces no more output */\n    ret = Z_OK;\n    do {\n        /* write out current buffer contents if full, or if flushing, but if\n           doing Z_FINISH then don't write until we get to Z_STREAM_END */\n        if (strm->avail_out == 0 || (flush != Z_NO_FLUSH &&\n            (flush != Z_FINISH || ret == Z_STREAM_END))) {\n            while (strm->next_out > state->x.next) {\n                put = strm->next_out - state->x.next > (int)max ? max :\n                      (unsigned)(strm->next_out - state->x.next);\n                writ = write(state->fd, state->x.next, put);\n                if (writ < 0) {\n                    gz_error(state, Z_ERRNO, zstrerror());\n                    return -1;\n                }\n                state->x.next += writ;\n            }\n            if (strm->avail_out == 0) {\n                strm->avail_out = state->size;\n                strm->next_out = state->out;\n                state->x.next = state->out;\n            }\n        }\n\n        /* compress */\n        have = strm->avail_out;\n        ret = deflate(strm, flush);\n        if (ret == Z_STREAM_ERROR) {\n            gz_error(state, Z_STREAM_ERROR,\n                      \"internal error: deflate stream corrupt\");\n            return -1;\n        }\n        have -= strm->avail_out;\n    } while (have);\n\n    /* if that completed a deflate stream, allow another to start */\n    if (flush == Z_FINISH)\n        state->reset = 1;\n\n    /* all done, no errors */\n    return 0;\n}\n\n/* Compress len zeros to output.  Return -1 on a write error or memory\n   allocation failure by gz_comp(), or 0 on success. */\nlocal int gz_zero(gz_statep state, z_off64_t len) {\n    int first;\n    unsigned n;\n    z_streamp strm = &(state->strm);\n\n    /* consume whatever's left in the input buffer */\n    if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)\n        return -1;\n\n    /* compress len zeros (len guaranteed > 0) */\n    first = 1;\n    while (len) {\n        n = GT_OFF(state->size) || (z_off64_t)state->size > len ?\n            (unsigned)len : state->size;\n        if (first) {\n            memset(state->in, 0, n);\n            first = 0;\n        }\n        strm->avail_in = n;\n        strm->next_in = state->in;\n        state->x.pos += n;\n        if (gz_comp(state, Z_NO_FLUSH) == -1)\n            return -1;\n        len -= n;\n    }\n    return 0;\n}\n\n/* Write len bytes from buf to file.  Return the number of bytes written.  If\n   the returned value is less than len, then there was an error. */\nlocal z_size_t gz_write(gz_statep state, voidpc buf, z_size_t len) {\n    z_size_t put = len;\n\n    /* if len is zero, avoid unnecessary operations */\n    if (len == 0)\n        return 0;\n\n    /* allocate memory if this is the first time through */\n    if (state->size == 0 && gz_init(state) == -1)\n        return 0;\n\n    /* check for seek request */\n    if (state->seek) {\n        state->seek = 0;\n        if (gz_zero(state, state->skip) == -1)\n            return 0;\n    }\n\n    /* for small len, copy to input buffer, otherwise compress directly */\n    if (len < state->size) {\n        /* copy to input buffer, compress when full */\n        do {\n            unsigned have, copy;\n\n            if (state->strm.avail_in == 0)\n                state->strm.next_in = state->in;\n            have = (unsigned)((state->strm.next_in + state->strm.avail_in) -\n                              state->in);\n            copy = state->size - have;\n            if (copy > len)\n                copy = (unsigned)len;\n            memcpy(state->in + have, buf, copy);\n            state->strm.avail_in += copy;\n            state->x.pos += copy;\n            buf = (const char *)buf + copy;\n            len -= copy;\n            if (len && gz_comp(state, Z_NO_FLUSH) == -1)\n                return 0;\n        } while (len);\n    }\n    else {\n        /* consume whatever's left in the input buffer */\n        if (state->strm.avail_in && gz_comp(state, Z_NO_FLUSH) == -1)\n            return 0;\n\n        /* directly compress user buffer to file */\n        state->strm.next_in = (z_const Bytef *)buf;\n        do {\n            unsigned n = (unsigned)-1;\n            if (n > len)\n                n = (unsigned)len;\n            state->strm.avail_in = n;\n            state->x.pos += n;\n            if (gz_comp(state, Z_NO_FLUSH) == -1)\n                return 0;\n            len -= n;\n        } while (len);\n    }\n\n    /* input was all buffered or compressed */\n    return put;\n}\n\n/* -- see zlib.h -- */\nint ZEXPORT gzwrite(gzFile file, voidpc buf, unsigned len) {\n    gz_statep state;\n\n    /* get internal structure */\n    if (file == NULL)\n        return 0;\n    state = (gz_statep)file;\n\n    /* check that we're writing and that there's no error */\n    if (state->mode != GZ_WRITE || state->err != Z_OK)\n        return 0;\n\n    /* since an int is returned, make sure len fits in one, otherwise return\n       with an error (this avoids a flaw in the interface) */\n    if ((int)len < 0) {\n        gz_error(state, Z_DATA_ERROR, \"requested length does not fit in int\");\n        return 0;\n    }\n\n    /* write len bytes from buf (the return value will fit in an int) */\n    return (int)gz_write(state, buf, len);\n}\n\n/* -- see zlib.h -- */\nz_size_t ZEXPORT gzfwrite(voidpc buf, z_size_t size, z_size_t nitems,\n                          gzFile file) {\n    z_size_t len;\n    gz_statep state;\n\n    /* get internal structure */\n    if (file == NULL)\n        return 0;\n    state = (gz_statep)file;\n\n    /* check that we're writing and that there's no error */\n    if (state->mode != GZ_WRITE || state->err != Z_OK)\n        return 0;\n\n    /* compute bytes to read -- error on overflow */\n    len = nitems * size;\n    if (size && len / size != nitems) {\n        gz_error(state, Z_STREAM_ERROR, \"request does not fit in a size_t\");\n        return 0;\n    }\n\n    /* write len bytes to buf, return the number of full items written */\n    return len ? gz_write(state, buf, len) / size : 0;\n}\n\n/* -- see zlib.h -- */\nint ZEXPORT gzputc(gzFile file, int c) {\n    unsigned have;\n    unsigned char buf[1];\n    gz_statep state;\n    z_streamp strm;\n\n    /* get internal structure */\n    if (file == NULL)\n        return -1;\n    state = (gz_statep)file;\n    strm = &(state->strm);\n\n    /* check that we're writing and that there's no error */\n    if (state->mode != GZ_WRITE || state->err != Z_OK)\n        return -1;\n\n    /* check for seek request */\n    if (state->seek) {\n        state->seek = 0;\n        if (gz_zero(state, state->skip) == -1)\n            return -1;\n    }\n\n    /* try writing to input buffer for speed (state->size == 0 if buffer not\n       initialized) */\n    if (state->size) {\n        if (strm->avail_in == 0)\n            strm->next_in = state->in;\n        have = (unsigned)((strm->next_in + strm->avail_in) - state->in);\n        if (have < state->size) {\n            state->in[have] = (unsigned char)c;\n            strm->avail_in++;\n            state->x.pos++;\n            return c & 0xff;\n        }\n    }\n\n    /* no room in buffer or not initialized, use gz_write() */\n    buf[0] = (unsigned char)c;\n    if (gz_write(state, buf, 1) != 1)\n        return -1;\n    return c & 0xff;\n}\n\n/* -- see zlib.h -- */\nint ZEXPORT gzputs(gzFile file, const char *s) {\n    z_size_t len, put;\n    gz_statep state;\n\n    /* get internal structure */\n    if (file == NULL)\n        return -1;\n    state = (gz_statep)file;\n\n    /* check that we're writing and that there's no error */\n    if (state->mode != GZ_WRITE || state->err != Z_OK)\n        return -1;\n\n    /* write string */\n    len = strlen(s);\n    if ((int)len < 0 || (unsigned)len != len) {\n        gz_error(state, Z_STREAM_ERROR, \"string length does not fit in int\");\n        return -1;\n    }\n    put = gz_write(state, s, len);\n    return put < len ? -1 : (int)len;\n}\n\n#if defined(STDC) || defined(Z_HAVE_STDARG_H)\n#include <stdarg.h>\n\n/* -- see zlib.h -- */\nint ZEXPORTVA gzvprintf(gzFile file, const char *format, va_list va) {\n    int len;\n    unsigned left;\n    char *next;\n    gz_statep state;\n    z_streamp strm;\n\n    /* get internal structure */\n    if (file == NULL)\n        return Z_STREAM_ERROR;\n    state = (gz_statep)file;\n    strm = &(state->strm);\n\n    /* check that we're writing and that there's no error */\n    if (state->mode != GZ_WRITE || state->err != Z_OK)\n        return Z_STREAM_ERROR;\n\n    /* make sure we have some buffer space */\n    if (state->size == 0 && gz_init(state) == -1)\n        return state->err;\n\n    /* check for seek request */\n    if (state->seek) {\n        state->seek = 0;\n        if (gz_zero(state, state->skip) == -1)\n            return state->err;\n    }\n\n    /* do the printf() into the input buffer, put length in len -- the input\n       buffer is double-sized just for this function, so there is guaranteed to\n       be state->size bytes available after the current contents */\n    if (strm->avail_in == 0)\n        strm->next_in = state->in;\n    next = (char *)(state->in + (strm->next_in - state->in) + strm->avail_in);\n    next[state->size - 1] = 0;\n#ifdef NO_vsnprintf\n#  ifdef HAS_vsprintf_void\n    (void)vsprintf(next, format, va);\n    for (len = 0; len < state->size; len++)\n        if (next[len] == 0) break;\n#  else\n    len = vsprintf(next, format, va);\n#  endif\n#else\n#  ifdef HAS_vsnprintf_void\n    (void)vsnprintf(next, state->size, format, va);\n    len = strlen(next);\n#  else\n    len = vsnprintf(next, state->size, format, va);\n#  endif\n#endif\n\n    /* check that printf() results fit in buffer */\n    if (len == 0 || (unsigned)len >= state->size || next[state->size - 1] != 0)\n        return 0;\n\n    /* update buffer and position, compress first half if past that */\n    strm->avail_in += (unsigned)len;\n    state->x.pos += len;\n    if (strm->avail_in >= state->size) {\n        left = strm->avail_in - state->size;\n        strm->avail_in = state->size;\n        if (gz_comp(state, Z_NO_FLUSH) == -1)\n            return state->err;\n        memmove(state->in, state->in + state->size, left);\n        strm->next_in = state->in;\n        strm->avail_in = left;\n    }\n    return len;\n}\n\nint ZEXPORTVA gzprintf(gzFile file, const char *format, ...) {\n    va_list va;\n    int ret;\n\n    va_start(va, format);\n    ret = gzvprintf(file, format, va);\n    va_end(va);\n    return ret;\n}\n\n#else /* !STDC && !Z_HAVE_STDARG_H */\n\n/* -- see zlib.h -- */\nint ZEXPORTVA gzprintf(gzFile file, const char *format, int a1, int a2, int a3,\n                       int a4, int a5, int a6, int a7, int a8, int a9, int a10,\n                       int a11, int a12, int a13, int a14, int a15, int a16,\n                       int a17, int a18, int a19, int a20) {\n    unsigned len, left;\n    char *next;\n    gz_statep state;\n    z_streamp strm;\n\n    /* get internal structure */\n    if (file == NULL)\n        return Z_STREAM_ERROR;\n    state = (gz_statep)file;\n    strm = &(state->strm);\n\n    /* check that can really pass pointer in ints */\n    if (sizeof(int) != sizeof(void *))\n        return Z_STREAM_ERROR;\n\n    /* check that we're writing and that there's no error */\n    if (state->mode != GZ_WRITE || state->err != Z_OK)\n        return Z_STREAM_ERROR;\n\n    /* make sure we have some buffer space */\n    if (state->size == 0 && gz_init(state) == -1)\n        return state->error;\n\n    /* check for seek request */\n    if (state->seek) {\n        state->seek = 0;\n        if (gz_zero(state, state->skip) == -1)\n            return state->error;\n    }\n\n    /* do the printf() into the input buffer, put length in len -- the input\n       buffer is double-sized just for this function, so there is guaranteed to\n       be state->size bytes available after the current contents */\n    if (strm->avail_in == 0)\n        strm->next_in = state->in;\n    next = (char *)(strm->next_in + strm->avail_in);\n    next[state->size - 1] = 0;\n#ifdef NO_snprintf\n#  ifdef HAS_sprintf_void\n    sprintf(next, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12,\n            a13, a14, a15, a16, a17, a18, a19, a20);\n    for (len = 0; len < size; len++)\n        if (next[len] == 0)\n            break;\n#  else\n    len = sprintf(next, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11,\n                  a12, a13, a14, a15, a16, a17, a18, a19, a20);\n#  endif\n#else\n#  ifdef HAS_snprintf_void\n    snprintf(next, state->size, format, a1, a2, a3, a4, a5, a6, a7, a8, a9,\n             a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);\n    len = strlen(next);\n#  else\n    len = snprintf(next, state->size, format, a1, a2, a3, a4, a5, a6, a7, a8,\n                   a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);\n#  endif\n#endif\n\n    /* check that printf() results fit in buffer */\n    if (len == 0 || len >= state->size || next[state->size - 1] != 0)\n        return 0;\n\n    /* update buffer and position, compress first half if past that */\n    strm->avail_in += len;\n    state->x.pos += len;\n    if (strm->avail_in >= state->size) {\n        left = strm->avail_in - state->size;\n        strm->avail_in = state->size;\n        if (gz_comp(state, Z_NO_FLUSH) == -1)\n            return state->err;\n        memmove(state->in, state->in + state->size, left);\n        strm->next_in = state->in;\n        strm->avail_in = left;\n    }\n    return (int)len;\n}\n\n#endif\n\n/* -- see zlib.h -- */\nint ZEXPORT gzflush(gzFile file, int flush) {\n    gz_statep state;\n\n    /* get internal structure */\n    if (file == NULL)\n        return Z_STREAM_ERROR;\n    state = (gz_statep)file;\n\n    /* check that we're writing and that there's no error */\n    if (state->mode != GZ_WRITE || state->err != Z_OK)\n        return Z_STREAM_ERROR;\n\n    /* check flush parameter */\n    if (flush < 0 || flush > Z_FINISH)\n        return Z_STREAM_ERROR;\n\n    /* check for seek request */\n    if (state->seek) {\n        state->seek = 0;\n        if (gz_zero(state, state->skip) == -1)\n            return state->err;\n    }\n\n    /* compress remaining data with requested flush */\n    (void)gz_comp(state, flush);\n    return state->err;\n}\n\n/* -- see zlib.h -- */\nint ZEXPORT gzsetparams(gzFile file, int level, int strategy) {\n    gz_statep state;\n    z_streamp strm;\n\n    /* get internal structure */\n    if (file == NULL)\n        return Z_STREAM_ERROR;\n    state = (gz_statep)file;\n    strm = &(state->strm);\n\n    /* check that we're writing and that there's no error */\n    if (state->mode != GZ_WRITE || state->err != Z_OK || state->direct)\n        return Z_STREAM_ERROR;\n\n    /* if no change is requested, then do nothing */\n    if (level == state->level && strategy == state->strategy)\n        return Z_OK;\n\n    /* check for seek request */\n    if (state->seek) {\n        state->seek = 0;\n        if (gz_zero(state, state->skip) == -1)\n            return state->err;\n    }\n\n    /* change compression parameters for subsequent input */\n    if (state->size) {\n        /* flush previous input with previous parameters before changing */\n        if (strm->avail_in && gz_comp(state, Z_BLOCK) == -1)\n            return state->err;\n        deflateParams(strm, level, strategy);\n    }\n    state->level = level;\n    state->strategy = strategy;\n    return Z_OK;\n}\n\n/* -- see zlib.h -- */\nint ZEXPORT gzclose_w(gzFile file) {\n    int ret = Z_OK;\n    gz_statep state;\n\n    /* get internal structure */\n    if (file == NULL)\n        return Z_STREAM_ERROR;\n    state = (gz_statep)file;\n\n    /* check that we're writing */\n    if (state->mode != GZ_WRITE)\n        return Z_STREAM_ERROR;\n\n    /* check for seek request */\n    if (state->seek) {\n        state->seek = 0;\n        if (gz_zero(state, state->skip) == -1)\n            ret = state->err;\n    }\n\n    /* flush, free memory, and close file */\n    if (gz_comp(state, Z_FINISH) == -1)\n        ret = state->err;\n    if (state->size) {\n        if (!state->direct) {\n            (void)deflateEnd(&(state->strm));\n            free(state->out);\n        }\n        free(state->in);\n    }\n    gz_error(state, Z_OK, NULL);\n    free(state->path);\n    if (close(state->fd) == -1)\n        ret = Z_ERRNO;\n    free(state);\n    return ret;\n}\n"
        },
        {
          "name": "infback.c",
          "type": "blob",
          "size": 22.2314453125,
          "content": "/* infback.c -- inflate using a call-back interface\n * Copyright (C) 1995-2022 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n/*\n   This code is largely copied from inflate.c.  Normally either infback.o or\n   inflate.o would be linked into an application--not both.  The interface\n   with inffast.c is retained so that optimized assembler-coded versions of\n   inflate_fast() can be used with either inflate.c or infback.c.\n */\n\n#include \"zutil.h\"\n#include \"inftrees.h\"\n#include \"inflate.h\"\n#include \"inffast.h\"\n\n/*\n   strm provides memory allocation functions in zalloc and zfree, or\n   Z_NULL to use the library memory allocation functions.\n\n   windowBits is in the range 8..15, and window is a user-supplied\n   window and output buffer that is 2**windowBits bytes.\n */\nint ZEXPORT inflateBackInit_(z_streamp strm, int windowBits,\n                             unsigned char FAR *window, const char *version,\n                             int stream_size) {\n    struct inflate_state FAR *state;\n\n    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||\n        stream_size != (int)(sizeof(z_stream)))\n        return Z_VERSION_ERROR;\n    if (strm == Z_NULL || window == Z_NULL ||\n        windowBits < 8 || windowBits > 15)\n        return Z_STREAM_ERROR;\n    strm->msg = Z_NULL;                 /* in case we return an error */\n    if (strm->zalloc == (alloc_func)0) {\n#ifdef Z_SOLO\n        return Z_STREAM_ERROR;\n#else\n        strm->zalloc = zcalloc;\n        strm->opaque = (voidpf)0;\n#endif\n    }\n    if (strm->zfree == (free_func)0)\n#ifdef Z_SOLO\n        return Z_STREAM_ERROR;\n#else\n    strm->zfree = zcfree;\n#endif\n    state = (struct inflate_state FAR *)ZALLOC(strm, 1,\n                                               sizeof(struct inflate_state));\n    if (state == Z_NULL) return Z_MEM_ERROR;\n    Tracev((stderr, \"inflate: allocated\\n\"));\n    strm->state = (struct internal_state FAR *)state;\n    state->dmax = 32768U;\n    state->wbits = (uInt)windowBits;\n    state->wsize = 1U << windowBits;\n    state->window = window;\n    state->wnext = 0;\n    state->whave = 0;\n    state->sane = 1;\n    return Z_OK;\n}\n\n/*\n   Return state with length and distance decoding tables and index sizes set to\n   fixed code decoding.  Normally this returns fixed tables from inffixed.h.\n   If BUILDFIXED is defined, then instead this routine builds the tables the\n   first time it's called, and returns those tables the first time and\n   thereafter.  This reduces the size of the code by about 2K bytes, in\n   exchange for a little execution time.  However, BUILDFIXED should not be\n   used for threaded applications, since the rewriting of the tables and virgin\n   may not be thread-safe.\n */\nlocal void fixedtables(struct inflate_state FAR *state) {\n#ifdef BUILDFIXED\n    static int virgin = 1;\n    static code *lenfix, *distfix;\n    static code fixed[544];\n\n    /* build fixed huffman tables if first call (may not be thread safe) */\n    if (virgin) {\n        unsigned sym, bits;\n        static code *next;\n\n        /* literal/length table */\n        sym = 0;\n        while (sym < 144) state->lens[sym++] = 8;\n        while (sym < 256) state->lens[sym++] = 9;\n        while (sym < 280) state->lens[sym++] = 7;\n        while (sym < 288) state->lens[sym++] = 8;\n        next = fixed;\n        lenfix = next;\n        bits = 9;\n        inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);\n\n        /* distance table */\n        sym = 0;\n        while (sym < 32) state->lens[sym++] = 5;\n        distfix = next;\n        bits = 5;\n        inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);\n\n        /* do this just once */\n        virgin = 0;\n    }\n#else /* !BUILDFIXED */\n#   include \"inffixed.h\"\n#endif /* BUILDFIXED */\n    state->lencode = lenfix;\n    state->lenbits = 9;\n    state->distcode = distfix;\n    state->distbits = 5;\n}\n\n/* Macros for inflateBack(): */\n\n/* Load returned state from inflate_fast() */\n#define LOAD() \\\n    do { \\\n        put = strm->next_out; \\\n        left = strm->avail_out; \\\n        next = strm->next_in; \\\n        have = strm->avail_in; \\\n        hold = state->hold; \\\n        bits = state->bits; \\\n    } while (0)\n\n/* Set state from registers for inflate_fast() */\n#define RESTORE() \\\n    do { \\\n        strm->next_out = put; \\\n        strm->avail_out = left; \\\n        strm->next_in = next; \\\n        strm->avail_in = have; \\\n        state->hold = hold; \\\n        state->bits = bits; \\\n    } while (0)\n\n/* Clear the input bit accumulator */\n#define INITBITS() \\\n    do { \\\n        hold = 0; \\\n        bits = 0; \\\n    } while (0)\n\n/* Assure that some input is available.  If input is requested, but denied,\n   then return a Z_BUF_ERROR from inflateBack(). */\n#define PULL() \\\n    do { \\\n        if (have == 0) { \\\n            have = in(in_desc, &next); \\\n            if (have == 0) { \\\n                next = Z_NULL; \\\n                ret = Z_BUF_ERROR; \\\n                goto inf_leave; \\\n            } \\\n        } \\\n    } while (0)\n\n/* Get a byte of input into the bit accumulator, or return from inflateBack()\n   with an error if there is no input available. */\n#define PULLBYTE() \\\n    do { \\\n        PULL(); \\\n        have--; \\\n        hold += (unsigned long)(*next++) << bits; \\\n        bits += 8; \\\n    } while (0)\n\n/* Assure that there are at least n bits in the bit accumulator.  If there is\n   not enough available input to do that, then return from inflateBack() with\n   an error. */\n#define NEEDBITS(n) \\\n    do { \\\n        while (bits < (unsigned)(n)) \\\n            PULLBYTE(); \\\n    } while (0)\n\n/* Return the low n bits of the bit accumulator (n < 16) */\n#define BITS(n) \\\n    ((unsigned)hold & ((1U << (n)) - 1))\n\n/* Remove n bits from the bit accumulator */\n#define DROPBITS(n) \\\n    do { \\\n        hold >>= (n); \\\n        bits -= (unsigned)(n); \\\n    } while (0)\n\n/* Remove zero to seven bits as needed to go to a byte boundary */\n#define BYTEBITS() \\\n    do { \\\n        hold >>= bits & 7; \\\n        bits -= bits & 7; \\\n    } while (0)\n\n/* Assure that some output space is available, by writing out the window\n   if it's full.  If the write fails, return from inflateBack() with a\n   Z_BUF_ERROR. */\n#define ROOM() \\\n    do { \\\n        if (left == 0) { \\\n            put = state->window; \\\n            left = state->wsize; \\\n            state->whave = left; \\\n            if (out(out_desc, put, left)) { \\\n                ret = Z_BUF_ERROR; \\\n                goto inf_leave; \\\n            } \\\n        } \\\n    } while (0)\n\n/*\n   strm provides the memory allocation functions and window buffer on input,\n   and provides information on the unused input on return.  For Z_DATA_ERROR\n   returns, strm will also provide an error message.\n\n   in() and out() are the call-back input and output functions.  When\n   inflateBack() needs more input, it calls in().  When inflateBack() has\n   filled the window with output, or when it completes with data in the\n   window, it calls out() to write out the data.  The application must not\n   change the provided input until in() is called again or inflateBack()\n   returns.  The application must not change the window/output buffer until\n   inflateBack() returns.\n\n   in() and out() are called with a descriptor parameter provided in the\n   inflateBack() call.  This parameter can be a structure that provides the\n   information required to do the read or write, as well as accumulated\n   information on the input and output such as totals and check values.\n\n   in() should return zero on failure.  out() should return non-zero on\n   failure.  If either in() or out() fails, than inflateBack() returns a\n   Z_BUF_ERROR.  strm->next_in can be checked for Z_NULL to see whether it\n   was in() or out() that caused in the error.  Otherwise,  inflateBack()\n   returns Z_STREAM_END on success, Z_DATA_ERROR for an deflate format\n   error, or Z_MEM_ERROR if it could not allocate memory for the state.\n   inflateBack() can also return Z_STREAM_ERROR if the input parameters\n   are not correct, i.e. strm is Z_NULL or the state was not initialized.\n */\nint ZEXPORT inflateBack(z_streamp strm, in_func in, void FAR *in_desc,\n                        out_func out, void FAR *out_desc) {\n    struct inflate_state FAR *state;\n    z_const unsigned char FAR *next;    /* next input */\n    unsigned char FAR *put;     /* next output */\n    unsigned have, left;        /* available input and output */\n    unsigned long hold;         /* bit buffer */\n    unsigned bits;              /* bits in bit buffer */\n    unsigned copy;              /* number of stored or match bytes to copy */\n    unsigned char FAR *from;    /* where to copy match bytes from */\n    code here;                  /* current decoding table entry */\n    code last;                  /* parent table entry */\n    unsigned len;               /* length to copy for repeats, bits to drop */\n    int ret;                    /* return code */\n    static const unsigned short order[19] = /* permutation of code lengths */\n        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};\n\n    /* Check that the strm exists and that the state was initialized */\n    if (strm == Z_NULL || strm->state == Z_NULL)\n        return Z_STREAM_ERROR;\n    state = (struct inflate_state FAR *)strm->state;\n\n    /* Reset the state */\n    strm->msg = Z_NULL;\n    state->mode = TYPE;\n    state->last = 0;\n    state->whave = 0;\n    next = strm->next_in;\n    have = next != Z_NULL ? strm->avail_in : 0;\n    hold = 0;\n    bits = 0;\n    put = state->window;\n    left = state->wsize;\n\n    /* Inflate until end of block marked as last */\n    for (;;)\n        switch (state->mode) {\n        case TYPE:\n            /* determine and dispatch block type */\n            if (state->last) {\n                BYTEBITS();\n                state->mode = DONE;\n                break;\n            }\n            NEEDBITS(3);\n            state->last = BITS(1);\n            DROPBITS(1);\n            switch (BITS(2)) {\n            case 0:                             /* stored block */\n                Tracev((stderr, \"inflate:     stored block%s\\n\",\n                        state->last ? \" (last)\" : \"\"));\n                state->mode = STORED;\n                break;\n            case 1:                             /* fixed block */\n                fixedtables(state);\n                Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n                        state->last ? \" (last)\" : \"\"));\n                state->mode = LEN;              /* decode codes */\n                break;\n            case 2:                             /* dynamic block */\n                Tracev((stderr, \"inflate:     dynamic codes block%s\\n\",\n                        state->last ? \" (last)\" : \"\"));\n                state->mode = TABLE;\n                break;\n            case 3:\n                strm->msg = (z_const char *)\"invalid block type\";\n                state->mode = BAD;\n            }\n            DROPBITS(2);\n            break;\n\n        case STORED:\n            /* get and verify stored block length */\n            BYTEBITS();                         /* go to byte boundary */\n            NEEDBITS(32);\n            if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {\n                strm->msg = (z_const char *)\"invalid stored block lengths\";\n                state->mode = BAD;\n                break;\n            }\n            state->length = (unsigned)hold & 0xffff;\n            Tracev((stderr, \"inflate:       stored length %u\\n\",\n                    state->length));\n            INITBITS();\n\n            /* copy stored block from input to output */\n            while (state->length != 0) {\n                copy = state->length;\n                PULL();\n                ROOM();\n                if (copy > have) copy = have;\n                if (copy > left) copy = left;\n                zmemcpy(put, next, copy);\n                have -= copy;\n                next += copy;\n                left -= copy;\n                put += copy;\n                state->length -= copy;\n            }\n            Tracev((stderr, \"inflate:       stored end\\n\"));\n            state->mode = TYPE;\n            break;\n\n        case TABLE:\n            /* get dynamic table entries descriptor */\n            NEEDBITS(14);\n            state->nlen = BITS(5) + 257;\n            DROPBITS(5);\n            state->ndist = BITS(5) + 1;\n            DROPBITS(5);\n            state->ncode = BITS(4) + 4;\n            DROPBITS(4);\n#ifndef PKZIP_BUG_WORKAROUND\n            if (state->nlen > 286 || state->ndist > 30) {\n                strm->msg = (z_const char *)\"too many length or distance symbols\";\n                state->mode = BAD;\n                break;\n            }\n#endif\n            Tracev((stderr, \"inflate:       table sizes ok\\n\"));\n\n            /* get code length code lengths (not a typo) */\n            state->have = 0;\n            while (state->have < state->ncode) {\n                NEEDBITS(3);\n                state->lens[order[state->have++]] = (unsigned short)BITS(3);\n                DROPBITS(3);\n            }\n            while (state->have < 19)\n                state->lens[order[state->have++]] = 0;\n            state->next = state->codes;\n            state->lencode = (code const FAR *)(state->next);\n            state->lenbits = 7;\n            ret = inflate_table(CODES, state->lens, 19, &(state->next),\n                                &(state->lenbits), state->work);\n            if (ret) {\n                strm->msg = (z_const char *)\"invalid code lengths set\";\n                state->mode = BAD;\n                break;\n            }\n            Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n\n            /* get length and distance code code lengths */\n            state->have = 0;\n            while (state->have < state->nlen + state->ndist) {\n                for (;;) {\n                    here = state->lencode[BITS(state->lenbits)];\n                    if ((unsigned)(here.bits) <= bits) break;\n                    PULLBYTE();\n                }\n                if (here.val < 16) {\n                    DROPBITS(here.bits);\n                    state->lens[state->have++] = here.val;\n                }\n                else {\n                    if (here.val == 16) {\n                        NEEDBITS(here.bits + 2);\n                        DROPBITS(here.bits);\n                        if (state->have == 0) {\n                            strm->msg = (z_const char *)\"invalid bit length repeat\";\n                            state->mode = BAD;\n                            break;\n                        }\n                        len = (unsigned)(state->lens[state->have - 1]);\n                        copy = 3 + BITS(2);\n                        DROPBITS(2);\n                    }\n                    else if (here.val == 17) {\n                        NEEDBITS(here.bits + 3);\n                        DROPBITS(here.bits);\n                        len = 0;\n                        copy = 3 + BITS(3);\n                        DROPBITS(3);\n                    }\n                    else {\n                        NEEDBITS(here.bits + 7);\n                        DROPBITS(here.bits);\n                        len = 0;\n                        copy = 11 + BITS(7);\n                        DROPBITS(7);\n                    }\n                    if (state->have + copy > state->nlen + state->ndist) {\n                        strm->msg = (z_const char *)\"invalid bit length repeat\";\n                        state->mode = BAD;\n                        break;\n                    }\n                    while (copy--)\n                        state->lens[state->have++] = (unsigned short)len;\n                }\n            }\n\n            /* handle error breaks in while */\n            if (state->mode == BAD) break;\n\n            /* check for end-of-block code (better have one) */\n            if (state->lens[256] == 0) {\n                strm->msg = (z_const char *)\"invalid code -- missing end-of-block\";\n                state->mode = BAD;\n                break;\n            }\n\n            /* build code tables -- note: do not change the lenbits or distbits\n               values here (9 and 6) without reading the comments in inftrees.h\n               concerning the ENOUGH constants, which depend on those values */\n            state->next = state->codes;\n            state->lencode = (code const FAR *)(state->next);\n            state->lenbits = 9;\n            ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),\n                                &(state->lenbits), state->work);\n            if (ret) {\n                strm->msg = (z_const char *)\"invalid literal/lengths set\";\n                state->mode = BAD;\n                break;\n            }\n            state->distcode = (code const FAR *)(state->next);\n            state->distbits = 6;\n            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,\n                            &(state->next), &(state->distbits), state->work);\n            if (ret) {\n                strm->msg = (z_const char *)\"invalid distances set\";\n                state->mode = BAD;\n                break;\n            }\n            Tracev((stderr, \"inflate:       codes ok\\n\"));\n            state->mode = LEN;\n                /* fallthrough */\n\n        case LEN:\n            /* use inflate_fast() if we have enough input and output */\n            if (have >= 6 && left >= 258) {\n                RESTORE();\n                if (state->whave < state->wsize)\n                    state->whave = state->wsize - left;\n                inflate_fast(strm, state->wsize);\n                LOAD();\n                break;\n            }\n\n            /* get a literal, length, or end-of-block code */\n            for (;;) {\n                here = state->lencode[BITS(state->lenbits)];\n                if ((unsigned)(here.bits) <= bits) break;\n                PULLBYTE();\n            }\n            if (here.op && (here.op & 0xf0) == 0) {\n                last = here;\n                for (;;) {\n                    here = state->lencode[last.val +\n                            (BITS(last.bits + last.op) >> last.bits)];\n                    if ((unsigned)(last.bits + here.bits) <= bits) break;\n                    PULLBYTE();\n                }\n                DROPBITS(last.bits);\n            }\n            DROPBITS(here.bits);\n            state->length = (unsigned)here.val;\n\n            /* process literal */\n            if (here.op == 0) {\n                Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n                        \"inflate:         literal '%c'\\n\" :\n                        \"inflate:         literal 0x%02x\\n\", here.val));\n                ROOM();\n                *put++ = (unsigned char)(state->length);\n                left--;\n                state->mode = LEN;\n                break;\n            }\n\n            /* process end of block */\n            if (here.op & 32) {\n                Tracevv((stderr, \"inflate:         end of block\\n\"));\n                state->mode = TYPE;\n                break;\n            }\n\n            /* invalid code */\n            if (here.op & 64) {\n                strm->msg = (z_const char *)\"invalid literal/length code\";\n                state->mode = BAD;\n                break;\n            }\n\n            /* length code -- get extra bits, if any */\n            state->extra = (unsigned)(here.op) & 15;\n            if (state->extra != 0) {\n                NEEDBITS(state->extra);\n                state->length += BITS(state->extra);\n                DROPBITS(state->extra);\n            }\n            Tracevv((stderr, \"inflate:         length %u\\n\", state->length));\n\n            /* get distance code */\n            for (;;) {\n                here = state->distcode[BITS(state->distbits)];\n                if ((unsigned)(here.bits) <= bits) break;\n                PULLBYTE();\n            }\n            if ((here.op & 0xf0) == 0) {\n                last = here;\n                for (;;) {\n                    here = state->distcode[last.val +\n                            (BITS(last.bits + last.op) >> last.bits)];\n                    if ((unsigned)(last.bits + here.bits) <= bits) break;\n                    PULLBYTE();\n                }\n                DROPBITS(last.bits);\n            }\n            DROPBITS(here.bits);\n            if (here.op & 64) {\n                strm->msg = (z_const char *)\"invalid distance code\";\n                state->mode = BAD;\n                break;\n            }\n            state->offset = (unsigned)here.val;\n\n            /* get distance extra bits, if any */\n            state->extra = (unsigned)(here.op) & 15;\n            if (state->extra != 0) {\n                NEEDBITS(state->extra);\n                state->offset += BITS(state->extra);\n                DROPBITS(state->extra);\n            }\n            if (state->offset > state->wsize - (state->whave < state->wsize ?\n                                                left : 0)) {\n                strm->msg = (z_const char *)\"invalid distance too far back\";\n                state->mode = BAD;\n                break;\n            }\n            Tracevv((stderr, \"inflate:         distance %u\\n\", state->offset));\n\n            /* copy match from window to output */\n            do {\n                ROOM();\n                copy = state->wsize - state->offset;\n                if (copy < left) {\n                    from = put + copy;\n                    copy = left - copy;\n                }\n                else {\n                    from = put - state->offset;\n                    copy = left;\n                }\n                if (copy > state->length) copy = state->length;\n                state->length -= copy;\n                left -= copy;\n                do {\n                    *put++ = *from++;\n                } while (--copy);\n            } while (state->length != 0);\n            break;\n\n        case DONE:\n            /* inflate stream terminated properly */\n            ret = Z_STREAM_END;\n            goto inf_leave;\n\n        case BAD:\n            ret = Z_DATA_ERROR;\n            goto inf_leave;\n\n        default:\n            /* can't happen, but makes compilers happy */\n            ret = Z_STREAM_ERROR;\n            goto inf_leave;\n        }\n\n    /* Write leftover output and return unused input */\n  inf_leave:\n    if (left < state->wsize) {\n        if (out(out_desc, state->window, state->wsize - left) &&\n            ret == Z_STREAM_END)\n            ret = Z_BUF_ERROR;\n    }\n    strm->next_in = next;\n    strm->avail_in = have;\n    return ret;\n}\n\nint ZEXPORT inflateBackEnd(z_streamp strm) {\n    if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)\n        return Z_STREAM_ERROR;\n    ZFREE(strm, strm->state);\n    strm->state = Z_NULL;\n    Tracev((stderr, \"inflate: end\\n\"));\n    return Z_OK;\n}\n"
        },
        {
          "name": "inffast.c",
          "type": "blob",
          "size": 12.65234375,
          "content": "/* inffast.c -- fast decoding\n * Copyright (C) 1995-2017 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n#include \"zutil.h\"\n#include \"inftrees.h\"\n#include \"inflate.h\"\n#include \"inffast.h\"\n\n#ifdef ASMINF\n#  pragma message(\"Assembler code may have bugs -- use at your own risk\")\n#else\n\n/*\n   Decode literal, length, and distance codes and write out the resulting\n   literal and match bytes until either not enough input or output is\n   available, an end-of-block is encountered, or a data error is encountered.\n   When large enough input and output buffers are supplied to inflate(), for\n   example, a 16K input buffer and a 64K output buffer, more than 95% of the\n   inflate execution time is spent in this routine.\n\n   Entry assumptions:\n\n        state->mode == LEN\n        strm->avail_in >= 6\n        strm->avail_out >= 258\n        start >= strm->avail_out\n        state->bits < 8\n\n   On return, state->mode is one of:\n\n        LEN -- ran out of enough output space or enough available input\n        TYPE -- reached end of block code, inflate() to interpret next block\n        BAD -- error in block data\n\n   Notes:\n\n    - The maximum input bits used by a length/distance pair is 15 bits for the\n      length code, 5 bits for the length extra, 15 bits for the distance code,\n      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.\n      Therefore if strm->avail_in >= 6, then there is enough input to avoid\n      checking for available input while decoding.\n\n    - The maximum bytes that a single length/distance pair can output is 258\n      bytes, which is the maximum length that can be coded.  inflate_fast()\n      requires strm->avail_out >= 258 for each loop to avoid checking for\n      output space.\n */\nvoid ZLIB_INTERNAL inflate_fast(z_streamp strm, unsigned start) {\n    struct inflate_state FAR *state;\n    z_const unsigned char FAR *in;      /* local strm->next_in */\n    z_const unsigned char FAR *last;    /* have enough input while in < last */\n    unsigned char FAR *out;     /* local strm->next_out */\n    unsigned char FAR *beg;     /* inflate()'s initial strm->next_out */\n    unsigned char FAR *end;     /* while out < end, enough space available */\n#ifdef INFLATE_STRICT\n    unsigned dmax;              /* maximum distance from zlib header */\n#endif\n    unsigned wsize;             /* window size or zero if not using window */\n    unsigned whave;             /* valid bytes in the window */\n    unsigned wnext;             /* window write index */\n    unsigned char FAR *window;  /* allocated sliding window, if wsize != 0 */\n    unsigned long hold;         /* local strm->hold */\n    unsigned bits;              /* local strm->bits */\n    code const FAR *lcode;      /* local strm->lencode */\n    code const FAR *dcode;      /* local strm->distcode */\n    unsigned lmask;             /* mask for first level of length codes */\n    unsigned dmask;             /* mask for first level of distance codes */\n    code const *here;           /* retrieved table entry */\n    unsigned op;                /* code bits, operation, extra bits, or */\n                                /*  window position, window bytes to copy */\n    unsigned len;               /* match length, unused bytes */\n    unsigned dist;              /* match distance */\n    unsigned char FAR *from;    /* where to copy match from */\n\n    /* copy state to local variables */\n    state = (struct inflate_state FAR *)strm->state;\n    in = strm->next_in;\n    last = in + (strm->avail_in - 5);\n    out = strm->next_out;\n    beg = out - (start - strm->avail_out);\n    end = out + (strm->avail_out - 257);\n#ifdef INFLATE_STRICT\n    dmax = state->dmax;\n#endif\n    wsize = state->wsize;\n    whave = state->whave;\n    wnext = state->wnext;\n    window = state->window;\n    hold = state->hold;\n    bits = state->bits;\n    lcode = state->lencode;\n    dcode = state->distcode;\n    lmask = (1U << state->lenbits) - 1;\n    dmask = (1U << state->distbits) - 1;\n\n    /* decode literals and length/distances until end-of-block or not enough\n       input data or output space */\n    do {\n        if (bits < 15) {\n            hold += (unsigned long)(*in++) << bits;\n            bits += 8;\n            hold += (unsigned long)(*in++) << bits;\n            bits += 8;\n        }\n        here = lcode + (hold & lmask);\n      dolen:\n        op = (unsigned)(here->bits);\n        hold >>= op;\n        bits -= op;\n        op = (unsigned)(here->op);\n        if (op == 0) {                          /* literal */\n            Tracevv((stderr, here->val >= 0x20 && here->val < 0x7f ?\n                    \"inflate:         literal '%c'\\n\" :\n                    \"inflate:         literal 0x%02x\\n\", here->val));\n            *out++ = (unsigned char)(here->val);\n        }\n        else if (op & 16) {                     /* length base */\n            len = (unsigned)(here->val);\n            op &= 15;                           /* number of extra bits */\n            if (op) {\n                if (bits < op) {\n                    hold += (unsigned long)(*in++) << bits;\n                    bits += 8;\n                }\n                len += (unsigned)hold & ((1U << op) - 1);\n                hold >>= op;\n                bits -= op;\n            }\n            Tracevv((stderr, \"inflate:         length %u\\n\", len));\n            if (bits < 15) {\n                hold += (unsigned long)(*in++) << bits;\n                bits += 8;\n                hold += (unsigned long)(*in++) << bits;\n                bits += 8;\n            }\n            here = dcode + (hold & dmask);\n          dodist:\n            op = (unsigned)(here->bits);\n            hold >>= op;\n            bits -= op;\n            op = (unsigned)(here->op);\n            if (op & 16) {                      /* distance base */\n                dist = (unsigned)(here->val);\n                op &= 15;                       /* number of extra bits */\n                if (bits < op) {\n                    hold += (unsigned long)(*in++) << bits;\n                    bits += 8;\n                    if (bits < op) {\n                        hold += (unsigned long)(*in++) << bits;\n                        bits += 8;\n                    }\n                }\n                dist += (unsigned)hold & ((1U << op) - 1);\n#ifdef INFLATE_STRICT\n                if (dist > dmax) {\n                    strm->msg = (z_const char *)\"invalid distance too far back\";\n                    state->mode = BAD;\n                    break;\n                }\n#endif\n                hold >>= op;\n                bits -= op;\n                Tracevv((stderr, \"inflate:         distance %u\\n\", dist));\n                op = (unsigned)(out - beg);     /* max distance in output */\n                if (dist > op) {                /* see if copy from window */\n                    op = dist - op;             /* distance back in window */\n                    if (op > whave) {\n                        if (state->sane) {\n                            strm->msg =\n                                (z_const char *)\"invalid distance too far back\";\n                            state->mode = BAD;\n                            break;\n                        }\n#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n                        if (len <= op - whave) {\n                            do {\n                                *out++ = 0;\n                            } while (--len);\n                            continue;\n                        }\n                        len -= op - whave;\n                        do {\n                            *out++ = 0;\n                        } while (--op > whave);\n                        if (op == 0) {\n                            from = out - dist;\n                            do {\n                                *out++ = *from++;\n                            } while (--len);\n                            continue;\n                        }\n#endif\n                    }\n                    from = window;\n                    if (wnext == 0) {           /* very common case */\n                        from += wsize - op;\n                        if (op < len) {         /* some from window */\n                            len -= op;\n                            do {\n                                *out++ = *from++;\n                            } while (--op);\n                            from = out - dist;  /* rest from output */\n                        }\n                    }\n                    else if (wnext < op) {      /* wrap around window */\n                        from += wsize + wnext - op;\n                        op -= wnext;\n                        if (op < len) {         /* some from end of window */\n                            len -= op;\n                            do {\n                                *out++ = *from++;\n                            } while (--op);\n                            from = window;\n                            if (wnext < len) {  /* some from start of window */\n                                op = wnext;\n                                len -= op;\n                                do {\n                                    *out++ = *from++;\n                                } while (--op);\n                                from = out - dist;      /* rest from output */\n                            }\n                        }\n                    }\n                    else {                      /* contiguous in window */\n                        from += wnext - op;\n                        if (op < len) {         /* some from window */\n                            len -= op;\n                            do {\n                                *out++ = *from++;\n                            } while (--op);\n                            from = out - dist;  /* rest from output */\n                        }\n                    }\n                    while (len > 2) {\n                        *out++ = *from++;\n                        *out++ = *from++;\n                        *out++ = *from++;\n                        len -= 3;\n                    }\n                    if (len) {\n                        *out++ = *from++;\n                        if (len > 1)\n                            *out++ = *from++;\n                    }\n                }\n                else {\n                    from = out - dist;          /* copy direct from output */\n                    do {                        /* minimum length is three */\n                        *out++ = *from++;\n                        *out++ = *from++;\n                        *out++ = *from++;\n                        len -= 3;\n                    } while (len > 2);\n                    if (len) {\n                        *out++ = *from++;\n                        if (len > 1)\n                            *out++ = *from++;\n                    }\n                }\n            }\n            else if ((op & 64) == 0) {          /* 2nd level distance code */\n                here = dcode + here->val + (hold & ((1U << op) - 1));\n                goto dodist;\n            }\n            else {\n                strm->msg = (z_const char *)\"invalid distance code\";\n                state->mode = BAD;\n                break;\n            }\n        }\n        else if ((op & 64) == 0) {              /* 2nd level length code */\n            here = lcode + here->val + (hold & ((1U << op) - 1));\n            goto dolen;\n        }\n        else if (op & 32) {                     /* end-of-block */\n            Tracevv((stderr, \"inflate:         end of block\\n\"));\n            state->mode = TYPE;\n            break;\n        }\n        else {\n            strm->msg = (z_const char *)\"invalid literal/length code\";\n            state->mode = BAD;\n            break;\n        }\n    } while (in < last && out < end);\n\n    /* return unused bytes (on entry, bits < 8, so in won't go too far back) */\n    len = bits >> 3;\n    in -= len;\n    bits -= len << 3;\n    hold &= (1U << bits) - 1;\n\n    /* update state and return */\n    strm->next_in = in;\n    strm->next_out = out;\n    strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));\n    strm->avail_out = (unsigned)(out < end ?\n                                 257 + (end - out) : 257 - (out - end));\n    state->hold = hold;\n    state->bits = bits;\n    return;\n}\n\n/*\n   inflate_fast() speedups that turned out slower (on a PowerPC G3 750CXe):\n   - Using bit fields for code structure\n   - Different op definition to avoid & for extra bits (do & for table bits)\n   - Three separate decoding do-loops for direct, window, and wnext == 0\n   - Special case for distance > 1 copies to do overlapped load and store copy\n   - Explicit branch predictions (based on measured branch probabilities)\n   - Deferring match copy and interspersed it with decoding subsequent codes\n   - Swapping literal/length else\n   - Swapping window/direct else\n   - Larger unrolled copy loops (three is about right)\n   - Moving len -= 3 statement into middle of loop\n */\n\n#endif /* !ASMINF */\n"
        },
        {
          "name": "inffast.h",
          "type": "blob",
          "size": 0.412109375,
          "content": "/* inffast.h -- header to use inffast.c\n * Copyright (C) 1995-2003, 2010 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n/* WARNING: this file should *not* be used by applications. It is\n   part of the implementation of the compression library and is\n   subject to change. Applications should only use zlib.h.\n */\n\nvoid ZLIB_INTERNAL inflate_fast(z_streamp strm, unsigned start);\n"
        },
        {
          "name": "inffixed.h",
          "type": "blob",
          "size": 6.18359375,
          "content": "    /* inffixed.h -- table for decoding fixed codes\n     * Generated automatically by makefixed().\n     */\n\n    /* WARNING: this file should *not* be used by applications.\n       It is part of the implementation of this library and is\n       subject to change. Applications should only use zlib.h.\n     */\n\n    static const code lenfix[512] = {\n        {96,7,0},{0,8,80},{0,8,16},{20,8,115},{18,7,31},{0,8,112},{0,8,48},\n        {0,9,192},{16,7,10},{0,8,96},{0,8,32},{0,9,160},{0,8,0},{0,8,128},\n        {0,8,64},{0,9,224},{16,7,6},{0,8,88},{0,8,24},{0,9,144},{19,7,59},\n        {0,8,120},{0,8,56},{0,9,208},{17,7,17},{0,8,104},{0,8,40},{0,9,176},\n        {0,8,8},{0,8,136},{0,8,72},{0,9,240},{16,7,4},{0,8,84},{0,8,20},\n        {21,8,227},{19,7,43},{0,8,116},{0,8,52},{0,9,200},{17,7,13},{0,8,100},\n        {0,8,36},{0,9,168},{0,8,4},{0,8,132},{0,8,68},{0,9,232},{16,7,8},\n        {0,8,92},{0,8,28},{0,9,152},{20,7,83},{0,8,124},{0,8,60},{0,9,216},\n        {18,7,23},{0,8,108},{0,8,44},{0,9,184},{0,8,12},{0,8,140},{0,8,76},\n        {0,9,248},{16,7,3},{0,8,82},{0,8,18},{21,8,163},{19,7,35},{0,8,114},\n        {0,8,50},{0,9,196},{17,7,11},{0,8,98},{0,8,34},{0,9,164},{0,8,2},\n        {0,8,130},{0,8,66},{0,9,228},{16,7,7},{0,8,90},{0,8,26},{0,9,148},\n        {20,7,67},{0,8,122},{0,8,58},{0,9,212},{18,7,19},{0,8,106},{0,8,42},\n        {0,9,180},{0,8,10},{0,8,138},{0,8,74},{0,9,244},{16,7,5},{0,8,86},\n        {0,8,22},{64,8,0},{19,7,51},{0,8,118},{0,8,54},{0,9,204},{17,7,15},\n        {0,8,102},{0,8,38},{0,9,172},{0,8,6},{0,8,134},{0,8,70},{0,9,236},\n        {16,7,9},{0,8,94},{0,8,30},{0,9,156},{20,7,99},{0,8,126},{0,8,62},\n        {0,9,220},{18,7,27},{0,8,110},{0,8,46},{0,9,188},{0,8,14},{0,8,142},\n        {0,8,78},{0,9,252},{96,7,0},{0,8,81},{0,8,17},{21,8,131},{18,7,31},\n        {0,8,113},{0,8,49},{0,9,194},{16,7,10},{0,8,97},{0,8,33},{0,9,162},\n        {0,8,1},{0,8,129},{0,8,65},{0,9,226},{16,7,6},{0,8,89},{0,8,25},\n        {0,9,146},{19,7,59},{0,8,121},{0,8,57},{0,9,210},{17,7,17},{0,8,105},\n        {0,8,41},{0,9,178},{0,8,9},{0,8,137},{0,8,73},{0,9,242},{16,7,4},\n        {0,8,85},{0,8,21},{16,8,258},{19,7,43},{0,8,117},{0,8,53},{0,9,202},\n        {17,7,13},{0,8,101},{0,8,37},{0,9,170},{0,8,5},{0,8,133},{0,8,69},\n        {0,9,234},{16,7,8},{0,8,93},{0,8,29},{0,9,154},{20,7,83},{0,8,125},\n        {0,8,61},{0,9,218},{18,7,23},{0,8,109},{0,8,45},{0,9,186},{0,8,13},\n        {0,8,141},{0,8,77},{0,9,250},{16,7,3},{0,8,83},{0,8,19},{21,8,195},\n        {19,7,35},{0,8,115},{0,8,51},{0,9,198},{17,7,11},{0,8,99},{0,8,35},\n        {0,9,166},{0,8,3},{0,8,131},{0,8,67},{0,9,230},{16,7,7},{0,8,91},\n        {0,8,27},{0,9,150},{20,7,67},{0,8,123},{0,8,59},{0,9,214},{18,7,19},\n        {0,8,107},{0,8,43},{0,9,182},{0,8,11},{0,8,139},{0,8,75},{0,9,246},\n        {16,7,5},{0,8,87},{0,8,23},{64,8,0},{19,7,51},{0,8,119},{0,8,55},\n        {0,9,206},{17,7,15},{0,8,103},{0,8,39},{0,9,174},{0,8,7},{0,8,135},\n        {0,8,71},{0,9,238},{16,7,9},{0,8,95},{0,8,31},{0,9,158},{20,7,99},\n        {0,8,127},{0,8,63},{0,9,222},{18,7,27},{0,8,111},{0,8,47},{0,9,190},\n        {0,8,15},{0,8,143},{0,8,79},{0,9,254},{96,7,0},{0,8,80},{0,8,16},\n        {20,8,115},{18,7,31},{0,8,112},{0,8,48},{0,9,193},{16,7,10},{0,8,96},\n        {0,8,32},{0,9,161},{0,8,0},{0,8,128},{0,8,64},{0,9,225},{16,7,6},\n        {0,8,88},{0,8,24},{0,9,145},{19,7,59},{0,8,120},{0,8,56},{0,9,209},\n        {17,7,17},{0,8,104},{0,8,40},{0,9,177},{0,8,8},{0,8,136},{0,8,72},\n        {0,9,241},{16,7,4},{0,8,84},{0,8,20},{21,8,227},{19,7,43},{0,8,116},\n        {0,8,52},{0,9,201},{17,7,13},{0,8,100},{0,8,36},{0,9,169},{0,8,4},\n        {0,8,132},{0,8,68},{0,9,233},{16,7,8},{0,8,92},{0,8,28},{0,9,153},\n        {20,7,83},{0,8,124},{0,8,60},{0,9,217},{18,7,23},{0,8,108},{0,8,44},\n        {0,9,185},{0,8,12},{0,8,140},{0,8,76},{0,9,249},{16,7,3},{0,8,82},\n        {0,8,18},{21,8,163},{19,7,35},{0,8,114},{0,8,50},{0,9,197},{17,7,11},\n        {0,8,98},{0,8,34},{0,9,165},{0,8,2},{0,8,130},{0,8,66},{0,9,229},\n        {16,7,7},{0,8,90},{0,8,26},{0,9,149},{20,7,67},{0,8,122},{0,8,58},\n        {0,9,213},{18,7,19},{0,8,106},{0,8,42},{0,9,181},{0,8,10},{0,8,138},\n        {0,8,74},{0,9,245},{16,7,5},{0,8,86},{0,8,22},{64,8,0},{19,7,51},\n        {0,8,118},{0,8,54},{0,9,205},{17,7,15},{0,8,102},{0,8,38},{0,9,173},\n        {0,8,6},{0,8,134},{0,8,70},{0,9,237},{16,7,9},{0,8,94},{0,8,30},\n        {0,9,157},{20,7,99},{0,8,126},{0,8,62},{0,9,221},{18,7,27},{0,8,110},\n        {0,8,46},{0,9,189},{0,8,14},{0,8,142},{0,8,78},{0,9,253},{96,7,0},\n        {0,8,81},{0,8,17},{21,8,131},{18,7,31},{0,8,113},{0,8,49},{0,9,195},\n        {16,7,10},{0,8,97},{0,8,33},{0,9,163},{0,8,1},{0,8,129},{0,8,65},\n        {0,9,227},{16,7,6},{0,8,89},{0,8,25},{0,9,147},{19,7,59},{0,8,121},\n        {0,8,57},{0,9,211},{17,7,17},{0,8,105},{0,8,41},{0,9,179},{0,8,9},\n        {0,8,137},{0,8,73},{0,9,243},{16,7,4},{0,8,85},{0,8,21},{16,8,258},\n        {19,7,43},{0,8,117},{0,8,53},{0,9,203},{17,7,13},{0,8,101},{0,8,37},\n        {0,9,171},{0,8,5},{0,8,133},{0,8,69},{0,9,235},{16,7,8},{0,8,93},\n        {0,8,29},{0,9,155},{20,7,83},{0,8,125},{0,8,61},{0,9,219},{18,7,23},\n        {0,8,109},{0,8,45},{0,9,187},{0,8,13},{0,8,141},{0,8,77},{0,9,251},\n        {16,7,3},{0,8,83},{0,8,19},{21,8,195},{19,7,35},{0,8,115},{0,8,51},\n        {0,9,199},{17,7,11},{0,8,99},{0,8,35},{0,9,167},{0,8,3},{0,8,131},\n        {0,8,67},{0,9,231},{16,7,7},{0,8,91},{0,8,27},{0,9,151},{20,7,67},\n        {0,8,123},{0,8,59},{0,9,215},{18,7,19},{0,8,107},{0,8,43},{0,9,183},\n        {0,8,11},{0,8,139},{0,8,75},{0,9,247},{16,7,5},{0,8,87},{0,8,23},\n        {64,8,0},{19,7,51},{0,8,119},{0,8,55},{0,9,207},{17,7,15},{0,8,103},\n        {0,8,39},{0,9,175},{0,8,7},{0,8,135},{0,8,71},{0,9,239},{16,7,9},\n        {0,8,95},{0,8,31},{0,9,159},{20,7,99},{0,8,127},{0,8,63},{0,9,223},\n        {18,7,27},{0,8,111},{0,8,47},{0,9,191},{0,8,15},{0,8,143},{0,8,79},\n        {0,9,255}\n    };\n\n    static const code distfix[32] = {\n        {16,5,1},{23,5,257},{19,5,17},{27,5,4097},{17,5,5},{25,5,1025},\n        {21,5,65},{29,5,16385},{16,5,3},{24,5,513},{20,5,33},{28,5,8193},\n        {18,5,9},{26,5,2049},{22,5,129},{64,5,0},{16,5,2},{23,5,385},\n        {19,5,25},{27,5,6145},{17,5,7},{25,5,1537},{21,5,97},{29,5,24577},\n        {16,5,4},{24,5,769},{20,5,49},{28,5,12289},{18,5,13},{26,5,3073},\n        {22,5,193},{64,5,0}\n    };\n"
        },
        {
          "name": "inflate.c",
          "type": "blob",
          "size": 54.3994140625,
          "content": "/* inflate.c -- zlib decompression\n * Copyright (C) 1995-2022 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n/*\n * Change history:\n *\n * 1.2.beta0    24 Nov 2002\n * - First version -- complete rewrite of inflate to simplify code, avoid\n *   creation of window when not needed, minimize use of window when it is\n *   needed, make inffast.c even faster, implement gzip decoding, and to\n *   improve code readability and style over the previous zlib inflate code\n *\n * 1.2.beta1    25 Nov 2002\n * - Use pointers for available input and output checking in inffast.c\n * - Remove input and output counters in inffast.c\n * - Change inffast.c entry and loop from avail_in >= 7 to >= 6\n * - Remove unnecessary second byte pull from length extra in inffast.c\n * - Unroll direct copy to three copies per loop in inffast.c\n *\n * 1.2.beta2    4 Dec 2002\n * - Change external routine names to reduce potential conflicts\n * - Correct filename to inffixed.h for fixed tables in inflate.c\n * - Make hbuf[] unsigned char to match parameter type in inflate.c\n * - Change strm->next_out[-state->offset] to *(strm->next_out - state->offset)\n *   to avoid negation problem on Alphas (64 bit) in inflate.c\n *\n * 1.2.beta3    22 Dec 2002\n * - Add comments on state->bits assertion in inffast.c\n * - Add comments on op field in inftrees.h\n * - Fix bug in reuse of allocated window after inflateReset()\n * - Remove bit fields--back to byte structure for speed\n * - Remove distance extra == 0 check in inflate_fast()--only helps for lengths\n * - Change post-increments to pre-increments in inflate_fast(), PPC biased?\n * - Add compile time option, POSTINC, to use post-increments instead (Intel?)\n * - Make MATCH copy in inflate() much faster for when inflate_fast() not used\n * - Use local copies of stream next and avail values, as well as local bit\n *   buffer and bit count in inflate()--for speed when inflate_fast() not used\n *\n * 1.2.beta4    1 Jan 2003\n * - Split ptr - 257 statements in inflate_table() to avoid compiler warnings\n * - Move a comment on output buffer sizes from inffast.c to inflate.c\n * - Add comments in inffast.c to introduce the inflate_fast() routine\n * - Rearrange window copies in inflate_fast() for speed and simplification\n * - Unroll last copy for window match in inflate_fast()\n * - Use local copies of window variables in inflate_fast() for speed\n * - Pull out common wnext == 0 case for speed in inflate_fast()\n * - Make op and len in inflate_fast() unsigned for consistency\n * - Add FAR to lcode and dcode declarations in inflate_fast()\n * - Simplified bad distance check in inflate_fast()\n * - Added inflateBackInit(), inflateBack(), and inflateBackEnd() in new\n *   source file infback.c to provide a call-back interface to inflate for\n *   programs like gzip and unzip -- uses window as output buffer to avoid\n *   window copying\n *\n * 1.2.beta5    1 Jan 2003\n * - Improved inflateBack() interface to allow the caller to provide initial\n *   input in strm.\n * - Fixed stored blocks bug in inflateBack()\n *\n * 1.2.beta6    4 Jan 2003\n * - Added comments in inffast.c on effectiveness of POSTINC\n * - Typecasting all around to reduce compiler warnings\n * - Changed loops from while (1) or do {} while (1) to for (;;), again to\n *   make compilers happy\n * - Changed type of window in inflateBackInit() to unsigned char *\n *\n * 1.2.beta7    27 Jan 2003\n * - Changed many types to unsigned or unsigned short to avoid warnings\n * - Added inflateCopy() function\n *\n * 1.2.0        9 Mar 2003\n * - Changed inflateBack() interface to provide separate opaque descriptors\n *   for the in() and out() functions\n * - Changed inflateBack() argument and in_func typedef to swap the length\n *   and buffer address return values for the input function\n * - Check next_in and next_out for Z_NULL on entry to inflate()\n *\n * The history for versions after 1.2.0 are in ChangeLog in zlib distribution.\n */\n\n#include \"zutil.h\"\n#include \"inftrees.h\"\n#include \"inflate.h\"\n#include \"inffast.h\"\n\n#ifdef MAKEFIXED\n#  ifndef BUILDFIXED\n#    define BUILDFIXED\n#  endif\n#endif\n\nlocal int inflateStateCheck(z_streamp strm) {\n    struct inflate_state FAR *state;\n    if (strm == Z_NULL ||\n        strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0)\n        return 1;\n    state = (struct inflate_state FAR *)strm->state;\n    if (state == Z_NULL || state->strm != strm ||\n        state->mode < HEAD || state->mode > SYNC)\n        return 1;\n    return 0;\n}\n\nint ZEXPORT inflateResetKeep(z_streamp strm) {\n    struct inflate_state FAR *state;\n\n    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;\n    state = (struct inflate_state FAR *)strm->state;\n    strm->total_in = strm->total_out = state->total = 0;\n    strm->msg = Z_NULL;\n    if (state->wrap)        /* to support ill-conceived Java test suite */\n        strm->adler = state->wrap & 1;\n    state->mode = HEAD;\n    state->last = 0;\n    state->havedict = 0;\n    state->flags = -1;\n    state->dmax = 32768U;\n    state->head = Z_NULL;\n    state->hold = 0;\n    state->bits = 0;\n    state->lencode = state->distcode = state->next = state->codes;\n    state->sane = 1;\n    state->back = -1;\n    Tracev((stderr, \"inflate: reset\\n\"));\n    return Z_OK;\n}\n\nint ZEXPORT inflateReset(z_streamp strm) {\n    struct inflate_state FAR *state;\n\n    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;\n    state = (struct inflate_state FAR *)strm->state;\n    state->wsize = 0;\n    state->whave = 0;\n    state->wnext = 0;\n    return inflateResetKeep(strm);\n}\n\nint ZEXPORT inflateReset2(z_streamp strm, int windowBits) {\n    int wrap;\n    struct inflate_state FAR *state;\n\n    /* get the state */\n    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;\n    state = (struct inflate_state FAR *)strm->state;\n\n    /* extract wrap request from windowBits parameter */\n    if (windowBits < 0) {\n        if (windowBits < -15)\n            return Z_STREAM_ERROR;\n        wrap = 0;\n        windowBits = -windowBits;\n    }\n    else {\n        wrap = (windowBits >> 4) + 5;\n#ifdef GUNZIP\n        if (windowBits < 48)\n            windowBits &= 15;\n#endif\n    }\n\n    /* set number of window bits, free window if different */\n    if (windowBits && (windowBits < 8 || windowBits > 15))\n        return Z_STREAM_ERROR;\n    if (state->window != Z_NULL && state->wbits != (unsigned)windowBits) {\n        ZFREE(strm, state->window);\n        state->window = Z_NULL;\n    }\n\n    /* update state and reset the rest of it */\n    state->wrap = wrap;\n    state->wbits = (unsigned)windowBits;\n    return inflateReset(strm);\n}\n\nint ZEXPORT inflateInit2_(z_streamp strm, int windowBits,\n                          const char *version, int stream_size) {\n    int ret;\n    struct inflate_state FAR *state;\n\n    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||\n        stream_size != (int)(sizeof(z_stream)))\n        return Z_VERSION_ERROR;\n    if (strm == Z_NULL) return Z_STREAM_ERROR;\n    strm->msg = Z_NULL;                 /* in case we return an error */\n    if (strm->zalloc == (alloc_func)0) {\n#ifdef Z_SOLO\n        return Z_STREAM_ERROR;\n#else\n        strm->zalloc = zcalloc;\n        strm->opaque = (voidpf)0;\n#endif\n    }\n    if (strm->zfree == (free_func)0)\n#ifdef Z_SOLO\n        return Z_STREAM_ERROR;\n#else\n        strm->zfree = zcfree;\n#endif\n    state = (struct inflate_state FAR *)\n            ZALLOC(strm, 1, sizeof(struct inflate_state));\n    if (state == Z_NULL) return Z_MEM_ERROR;\n    Tracev((stderr, \"inflate: allocated\\n\"));\n    strm->state = (struct internal_state FAR *)state;\n    state->strm = strm;\n    state->window = Z_NULL;\n    state->mode = HEAD;     /* to pass state test in inflateReset2() */\n    ret = inflateReset2(strm, windowBits);\n    if (ret != Z_OK) {\n        ZFREE(strm, state);\n        strm->state = Z_NULL;\n    }\n    return ret;\n}\n\nint ZEXPORT inflateInit_(z_streamp strm, const char *version,\n                         int stream_size) {\n    return inflateInit2_(strm, DEF_WBITS, version, stream_size);\n}\n\nint ZEXPORT inflatePrime(z_streamp strm, int bits, int value) {\n    struct inflate_state FAR *state;\n\n    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;\n    if (bits == 0)\n        return Z_OK;\n    state = (struct inflate_state FAR *)strm->state;\n    if (bits < 0) {\n        state->hold = 0;\n        state->bits = 0;\n        return Z_OK;\n    }\n    if (bits > 16 || state->bits + (uInt)bits > 32) return Z_STREAM_ERROR;\n    value &= (1L << bits) - 1;\n    state->hold += (unsigned)value << state->bits;\n    state->bits += (uInt)bits;\n    return Z_OK;\n}\n\n/*\n   Return state with length and distance decoding tables and index sizes set to\n   fixed code decoding.  Normally this returns fixed tables from inffixed.h.\n   If BUILDFIXED is defined, then instead this routine builds the tables the\n   first time it's called, and returns those tables the first time and\n   thereafter.  This reduces the size of the code by about 2K bytes, in\n   exchange for a little execution time.  However, BUILDFIXED should not be\n   used for threaded applications, since the rewriting of the tables and virgin\n   may not be thread-safe.\n */\nlocal void fixedtables(struct inflate_state FAR *state) {\n#ifdef BUILDFIXED\n    static int virgin = 1;\n    static code *lenfix, *distfix;\n    static code fixed[544];\n\n    /* build fixed huffman tables if first call (may not be thread safe) */\n    if (virgin) {\n        unsigned sym, bits;\n        static code *next;\n\n        /* literal/length table */\n        sym = 0;\n        while (sym < 144) state->lens[sym++] = 8;\n        while (sym < 256) state->lens[sym++] = 9;\n        while (sym < 280) state->lens[sym++] = 7;\n        while (sym < 288) state->lens[sym++] = 8;\n        next = fixed;\n        lenfix = next;\n        bits = 9;\n        inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);\n\n        /* distance table */\n        sym = 0;\n        while (sym < 32) state->lens[sym++] = 5;\n        distfix = next;\n        bits = 5;\n        inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);\n\n        /* do this just once */\n        virgin = 0;\n    }\n#else /* !BUILDFIXED */\n#   include \"inffixed.h\"\n#endif /* BUILDFIXED */\n    state->lencode = lenfix;\n    state->lenbits = 9;\n    state->distcode = distfix;\n    state->distbits = 5;\n}\n\n#ifdef MAKEFIXED\n#include <stdio.h>\n\n/*\n   Write out the inffixed.h that is #include'd above.  Defining MAKEFIXED also\n   defines BUILDFIXED, so the tables are built on the fly.  makefixed() writes\n   those tables to stdout, which would be piped to inffixed.h.  A small program\n   can simply call makefixed to do this:\n\n    void makefixed(void);\n\n    int main(void)\n    {\n        makefixed();\n        return 0;\n    }\n\n   Then that can be linked with zlib built with MAKEFIXED defined and run:\n\n    a.out > inffixed.h\n */\nvoid makefixed(void)\n{\n    unsigned low, size;\n    struct inflate_state state;\n\n    fixedtables(&state);\n    puts(\"    /* inffixed.h -- table for decoding fixed codes\");\n    puts(\"     * Generated automatically by makefixed().\");\n    puts(\"     */\");\n    puts(\"\");\n    puts(\"    /* WARNING: this file should *not* be used by applications.\");\n    puts(\"       It is part of the implementation of this library and is\");\n    puts(\"       subject to change. Applications should only use zlib.h.\");\n    puts(\"     */\");\n    puts(\"\");\n    size = 1U << 9;\n    printf(\"    static const code lenfix[%u] = {\", size);\n    low = 0;\n    for (;;) {\n        if ((low % 7) == 0) printf(\"\\n        \");\n        printf(\"{%u,%u,%d}\", (low & 127) == 99 ? 64 : state.lencode[low].op,\n               state.lencode[low].bits, state.lencode[low].val);\n        if (++low == size) break;\n        putchar(',');\n    }\n    puts(\"\\n    };\");\n    size = 1U << 5;\n    printf(\"\\n    static const code distfix[%u] = {\", size);\n    low = 0;\n    for (;;) {\n        if ((low % 6) == 0) printf(\"\\n        \");\n        printf(\"{%u,%u,%d}\", state.distcode[low].op, state.distcode[low].bits,\n               state.distcode[low].val);\n        if (++low == size) break;\n        putchar(',');\n    }\n    puts(\"\\n    };\");\n}\n#endif /* MAKEFIXED */\n\n/*\n   Update the window with the last wsize (normally 32K) bytes written before\n   returning.  If window does not exist yet, create it.  This is only called\n   when a window is already in use, or when output has been written during this\n   inflate call, but the end of the deflate stream has not been reached yet.\n   It is also called to create a window for dictionary data when a dictionary\n   is loaded.\n\n   Providing output buffers larger than 32K to inflate() should provide a speed\n   advantage, since only the last 32K of output is copied to the sliding window\n   upon return from inflate(), and since all distances after the first 32K of\n   output will fall in the output data, making match copies simpler and faster.\n   The advantage may be dependent on the size of the processor's data caches.\n */\nlocal int updatewindow(z_streamp strm, const Bytef *end, unsigned copy) {\n    struct inflate_state FAR *state;\n    unsigned dist;\n\n    state = (struct inflate_state FAR *)strm->state;\n\n    /* if it hasn't been done already, allocate space for the window */\n    if (state->window == Z_NULL) {\n        state->window = (unsigned char FAR *)\n                        ZALLOC(strm, 1U << state->wbits,\n                               sizeof(unsigned char));\n        if (state->window == Z_NULL) return 1;\n    }\n\n    /* if window not in use yet, initialize */\n    if (state->wsize == 0) {\n        state->wsize = 1U << state->wbits;\n        state->wnext = 0;\n        state->whave = 0;\n    }\n\n    /* copy state->wsize or less output bytes into the circular window */\n    if (copy >= state->wsize) {\n        zmemcpy(state->window, end - state->wsize, state->wsize);\n        state->wnext = 0;\n        state->whave = state->wsize;\n    }\n    else {\n        dist = state->wsize - state->wnext;\n        if (dist > copy) dist = copy;\n        zmemcpy(state->window + state->wnext, end - copy, dist);\n        copy -= dist;\n        if (copy) {\n            zmemcpy(state->window, end - copy, copy);\n            state->wnext = copy;\n            state->whave = state->wsize;\n        }\n        else {\n            state->wnext += dist;\n            if (state->wnext == state->wsize) state->wnext = 0;\n            if (state->whave < state->wsize) state->whave += dist;\n        }\n    }\n    return 0;\n}\n\n/* Macros for inflate(): */\n\n/* check function to use adler32() for zlib or crc32() for gzip */\n#ifdef GUNZIP\n#  define UPDATE_CHECK(check, buf, len) \\\n    (state->flags ? crc32(check, buf, len) : adler32(check, buf, len))\n#else\n#  define UPDATE_CHECK(check, buf, len) adler32(check, buf, len)\n#endif\n\n/* check macros for header crc */\n#ifdef GUNZIP\n#  define CRC2(check, word) \\\n    do { \\\n        hbuf[0] = (unsigned char)(word); \\\n        hbuf[1] = (unsigned char)((word) >> 8); \\\n        check = crc32(check, hbuf, 2); \\\n    } while (0)\n\n#  define CRC4(check, word) \\\n    do { \\\n        hbuf[0] = (unsigned char)(word); \\\n        hbuf[1] = (unsigned char)((word) >> 8); \\\n        hbuf[2] = (unsigned char)((word) >> 16); \\\n        hbuf[3] = (unsigned char)((word) >> 24); \\\n        check = crc32(check, hbuf, 4); \\\n    } while (0)\n#endif\n\n/* Load registers with state in inflate() for speed */\n#define LOAD() \\\n    do { \\\n        put = strm->next_out; \\\n        left = strm->avail_out; \\\n        next = strm->next_in; \\\n        have = strm->avail_in; \\\n        hold = state->hold; \\\n        bits = state->bits; \\\n    } while (0)\n\n/* Restore state from registers in inflate() */\n#define RESTORE() \\\n    do { \\\n        strm->next_out = put; \\\n        strm->avail_out = left; \\\n        strm->next_in = next; \\\n        strm->avail_in = have; \\\n        state->hold = hold; \\\n        state->bits = bits; \\\n    } while (0)\n\n/* Clear the input bit accumulator */\n#define INITBITS() \\\n    do { \\\n        hold = 0; \\\n        bits = 0; \\\n    } while (0)\n\n/* Get a byte of input into the bit accumulator, or return from inflate()\n   if there is no input available. */\n#define PULLBYTE() \\\n    do { \\\n        if (have == 0) goto inf_leave; \\\n        have--; \\\n        hold += (unsigned long)(*next++) << bits; \\\n        bits += 8; \\\n    } while (0)\n\n/* Assure that there are at least n bits in the bit accumulator.  If there is\n   not enough available input to do that, then return from inflate(). */\n#define NEEDBITS(n) \\\n    do { \\\n        while (bits < (unsigned)(n)) \\\n            PULLBYTE(); \\\n    } while (0)\n\n/* Return the low n bits of the bit accumulator (n < 16) */\n#define BITS(n) \\\n    ((unsigned)hold & ((1U << (n)) - 1))\n\n/* Remove n bits from the bit accumulator */\n#define DROPBITS(n) \\\n    do { \\\n        hold >>= (n); \\\n        bits -= (unsigned)(n); \\\n    } while (0)\n\n/* Remove zero to seven bits as needed to go to a byte boundary */\n#define BYTEBITS() \\\n    do { \\\n        hold >>= bits & 7; \\\n        bits -= bits & 7; \\\n    } while (0)\n\n/*\n   inflate() uses a state machine to process as much input data and generate as\n   much output data as possible before returning.  The state machine is\n   structured roughly as follows:\n\n    for (;;) switch (state) {\n    ...\n    case STATEn:\n        if (not enough input data or output space to make progress)\n            return;\n        ... make progress ...\n        state = STATEm;\n        break;\n    ...\n    }\n\n   so when inflate() is called again, the same case is attempted again, and\n   if the appropriate resources are provided, the machine proceeds to the\n   next state.  The NEEDBITS() macro is usually the way the state evaluates\n   whether it can proceed or should return.  NEEDBITS() does the return if\n   the requested bits are not available.  The typical use of the BITS macros\n   is:\n\n        NEEDBITS(n);\n        ... do something with BITS(n) ...\n        DROPBITS(n);\n\n   where NEEDBITS(n) either returns from inflate() if there isn't enough\n   input left to load n bits into the accumulator, or it continues.  BITS(n)\n   gives the low n bits in the accumulator.  When done, DROPBITS(n) drops\n   the low n bits off the accumulator.  INITBITS() clears the accumulator\n   and sets the number of available bits to zero.  BYTEBITS() discards just\n   enough bits to put the accumulator on a byte boundary.  After BYTEBITS()\n   and a NEEDBITS(8), then BITS(8) would return the next byte in the stream.\n\n   NEEDBITS(n) uses PULLBYTE() to get an available byte of input, or to return\n   if there is no input available.  The decoding of variable length codes uses\n   PULLBYTE() directly in order to pull just enough bytes to decode the next\n   code, and no more.\n\n   Some states loop until they get enough input, making sure that enough\n   state information is maintained to continue the loop where it left off\n   if NEEDBITS() returns in the loop.  For example, want, need, and keep\n   would all have to actually be part of the saved state in case NEEDBITS()\n   returns:\n\n    case STATEw:\n        while (want < need) {\n            NEEDBITS(n);\n            keep[want++] = BITS(n);\n            DROPBITS(n);\n        }\n        state = STATEx;\n    case STATEx:\n\n   As shown above, if the next state is also the next case, then the break\n   is omitted.\n\n   A state may also return if there is not enough output space available to\n   complete that state.  Those states are copying stored data, writing a\n   literal byte, and copying a matching string.\n\n   When returning, a \"goto inf_leave\" is used to update the total counters,\n   update the check value, and determine whether any progress has been made\n   during that inflate() call in order to return the proper return code.\n   Progress is defined as a change in either strm->avail_in or strm->avail_out.\n   When there is a window, goto inf_leave will update the window with the last\n   output written.  If a goto inf_leave occurs in the middle of decompression\n   and there is no window currently, goto inf_leave will create one and copy\n   output to the window for the next call of inflate().\n\n   In this implementation, the flush parameter of inflate() only affects the\n   return code (per zlib.h).  inflate() always writes as much as possible to\n   strm->next_out, given the space available and the provided input--the effect\n   documented in zlib.h of Z_SYNC_FLUSH.  Furthermore, inflate() always defers\n   the allocation of and copying into a sliding window until necessary, which\n   provides the effect documented in zlib.h for Z_FINISH when the entire input\n   stream available.  So the only thing the flush parameter actually does is:\n   when flush is set to Z_FINISH, inflate() cannot return Z_OK.  Instead it\n   will return Z_BUF_ERROR if it has not reached the end of the stream.\n */\n\nint ZEXPORT inflate(z_streamp strm, int flush) {\n    struct inflate_state FAR *state;\n    z_const unsigned char FAR *next;    /* next input */\n    unsigned char FAR *put;     /* next output */\n    unsigned have, left;        /* available input and output */\n    unsigned long hold;         /* bit buffer */\n    unsigned bits;              /* bits in bit buffer */\n    unsigned in, out;           /* save starting available input and output */\n    unsigned copy;              /* number of stored or match bytes to copy */\n    unsigned char FAR *from;    /* where to copy match bytes from */\n    code here;                  /* current decoding table entry */\n    code last;                  /* parent table entry */\n    unsigned len;               /* length to copy for repeats, bits to drop */\n    int ret;                    /* return code */\n#ifdef GUNZIP\n    unsigned char hbuf[4];      /* buffer for gzip header crc calculation */\n#endif\n    static const unsigned short order[19] = /* permutation of code lengths */\n        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};\n\n    if (inflateStateCheck(strm) || strm->next_out == Z_NULL ||\n        (strm->next_in == Z_NULL && strm->avail_in != 0))\n        return Z_STREAM_ERROR;\n\n    state = (struct inflate_state FAR *)strm->state;\n    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */\n    LOAD();\n    in = have;\n    out = left;\n    ret = Z_OK;\n    for (;;)\n        switch (state->mode) {\n        case HEAD:\n            if (state->wrap == 0) {\n                state->mode = TYPEDO;\n                break;\n            }\n            NEEDBITS(16);\n#ifdef GUNZIP\n            if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */\n                if (state->wbits == 0)\n                    state->wbits = 15;\n                state->check = crc32(0L, Z_NULL, 0);\n                CRC2(state->check, hold);\n                INITBITS();\n                state->mode = FLAGS;\n                break;\n            }\n            if (state->head != Z_NULL)\n                state->head->done = -1;\n            if (!(state->wrap & 1) ||   /* check if zlib header allowed */\n#else\n            if (\n#endif\n                ((BITS(8) << 8) + (hold >> 8)) % 31) {\n                strm->msg = (z_const char *)\"incorrect header check\";\n                state->mode = BAD;\n                break;\n            }\n            if (BITS(4) != Z_DEFLATED) {\n                strm->msg = (z_const char *)\"unknown compression method\";\n                state->mode = BAD;\n                break;\n            }\n            DROPBITS(4);\n            len = BITS(4) + 8;\n            if (state->wbits == 0)\n                state->wbits = len;\n            if (len > 15 || len > state->wbits) {\n                strm->msg = (z_const char *)\"invalid window size\";\n                state->mode = BAD;\n                break;\n            }\n            state->dmax = 1U << len;\n            state->flags = 0;               /* indicate zlib header */\n            Tracev((stderr, \"inflate:   zlib header ok\\n\"));\n            strm->adler = state->check = adler32(0L, Z_NULL, 0);\n            state->mode = hold & 0x200 ? DICTID : TYPE;\n            INITBITS();\n            break;\n#ifdef GUNZIP\n        case FLAGS:\n            NEEDBITS(16);\n            state->flags = (int)(hold);\n            if ((state->flags & 0xff) != Z_DEFLATED) {\n                strm->msg = (z_const char *)\"unknown compression method\";\n                state->mode = BAD;\n                break;\n            }\n            if (state->flags & 0xe000) {\n                strm->msg = (z_const char *)\"unknown header flags set\";\n                state->mode = BAD;\n                break;\n            }\n            if (state->head != Z_NULL)\n                state->head->text = (int)((hold >> 8) & 1);\n            if ((state->flags & 0x0200) && (state->wrap & 4))\n                CRC2(state->check, hold);\n            INITBITS();\n            state->mode = TIME;\n                /* fallthrough */\n        case TIME:\n            NEEDBITS(32);\n            if (state->head != Z_NULL)\n                state->head->time = hold;\n            if ((state->flags & 0x0200) && (state->wrap & 4))\n                CRC4(state->check, hold);\n            INITBITS();\n            state->mode = OS;\n                /* fallthrough */\n        case OS:\n            NEEDBITS(16);\n            if (state->head != Z_NULL) {\n                state->head->xflags = (int)(hold & 0xff);\n                state->head->os = (int)(hold >> 8);\n            }\n            if ((state->flags & 0x0200) && (state->wrap & 4))\n                CRC2(state->check, hold);\n            INITBITS();\n            state->mode = EXLEN;\n                /* fallthrough */\n        case EXLEN:\n            if (state->flags & 0x0400) {\n                NEEDBITS(16);\n                state->length = (unsigned)(hold);\n                if (state->head != Z_NULL)\n                    state->head->extra_len = (unsigned)hold;\n                if ((state->flags & 0x0200) && (state->wrap & 4))\n                    CRC2(state->check, hold);\n                INITBITS();\n            }\n            else if (state->head != Z_NULL)\n                state->head->extra = Z_NULL;\n            state->mode = EXTRA;\n                /* fallthrough */\n        case EXTRA:\n            if (state->flags & 0x0400) {\n                copy = state->length;\n                if (copy > have) copy = have;\n                if (copy) {\n                    if (state->head != Z_NULL &&\n                        state->head->extra != Z_NULL &&\n                        (len = state->head->extra_len - state->length) <\n                            state->head->extra_max) {\n                        zmemcpy(state->head->extra + len, next,\n                                len + copy > state->head->extra_max ?\n                                state->head->extra_max - len : copy);\n                    }\n                    if ((state->flags & 0x0200) && (state->wrap & 4))\n                        state->check = crc32(state->check, next, copy);\n                    have -= copy;\n                    next += copy;\n                    state->length -= copy;\n                }\n                if (state->length) goto inf_leave;\n            }\n            state->length = 0;\n            state->mode = NAME;\n                /* fallthrough */\n        case NAME:\n            if (state->flags & 0x0800) {\n                if (have == 0) goto inf_leave;\n                copy = 0;\n                do {\n                    len = (unsigned)(next[copy++]);\n                    if (state->head != Z_NULL &&\n                            state->head->name != Z_NULL &&\n                            state->length < state->head->name_max)\n                        state->head->name[state->length++] = (Bytef)len;\n                } while (len && copy < have);\n                if ((state->flags & 0x0200) && (state->wrap & 4))\n                    state->check = crc32(state->check, next, copy);\n                have -= copy;\n                next += copy;\n                if (len) goto inf_leave;\n            }\n            else if (state->head != Z_NULL)\n                state->head->name = Z_NULL;\n            state->length = 0;\n            state->mode = COMMENT;\n                /* fallthrough */\n        case COMMENT:\n            if (state->flags & 0x1000) {\n                if (have == 0) goto inf_leave;\n                copy = 0;\n                do {\n                    len = (unsigned)(next[copy++]);\n                    if (state->head != Z_NULL &&\n                            state->head->comment != Z_NULL &&\n                            state->length < state->head->comm_max)\n                        state->head->comment[state->length++] = (Bytef)len;\n                } while (len && copy < have);\n                if ((state->flags & 0x0200) && (state->wrap & 4))\n                    state->check = crc32(state->check, next, copy);\n                have -= copy;\n                next += copy;\n                if (len) goto inf_leave;\n            }\n            else if (state->head != Z_NULL)\n                state->head->comment = Z_NULL;\n            state->mode = HCRC;\n                /* fallthrough */\n        case HCRC:\n            if (state->flags & 0x0200) {\n                NEEDBITS(16);\n                if ((state->wrap & 4) && hold != (state->check & 0xffff)) {\n                    strm->msg = (z_const char *)\"header crc mismatch\";\n                    state->mode = BAD;\n                    break;\n                }\n                INITBITS();\n            }\n            if (state->head != Z_NULL) {\n                state->head->hcrc = (int)((state->flags >> 9) & 1);\n                state->head->done = 1;\n            }\n            strm->adler = state->check = crc32(0L, Z_NULL, 0);\n            state->mode = TYPE;\n            break;\n#endif\n        case DICTID:\n            NEEDBITS(32);\n            strm->adler = state->check = ZSWAP32(hold);\n            INITBITS();\n            state->mode = DICT;\n                /* fallthrough */\n        case DICT:\n            if (state->havedict == 0) {\n                RESTORE();\n                return Z_NEED_DICT;\n            }\n            strm->adler = state->check = adler32(0L, Z_NULL, 0);\n            state->mode = TYPE;\n                /* fallthrough */\n        case TYPE:\n            if (flush == Z_BLOCK || flush == Z_TREES) goto inf_leave;\n                /* fallthrough */\n        case TYPEDO:\n            if (state->last) {\n                BYTEBITS();\n                state->mode = CHECK;\n                break;\n            }\n            NEEDBITS(3);\n            state->last = BITS(1);\n            DROPBITS(1);\n            switch (BITS(2)) {\n            case 0:                             /* stored block */\n                Tracev((stderr, \"inflate:     stored block%s\\n\",\n                        state->last ? \" (last)\" : \"\"));\n                state->mode = STORED;\n                break;\n            case 1:                             /* fixed block */\n                fixedtables(state);\n                Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n                        state->last ? \" (last)\" : \"\"));\n                state->mode = LEN_;             /* decode codes */\n                if (flush == Z_TREES) {\n                    DROPBITS(2);\n                    goto inf_leave;\n                }\n                break;\n            case 2:                             /* dynamic block */\n                Tracev((stderr, \"inflate:     dynamic codes block%s\\n\",\n                        state->last ? \" (last)\" : \"\"));\n                state->mode = TABLE;\n                break;\n            case 3:\n                strm->msg = (z_const char *)\"invalid block type\";\n                state->mode = BAD;\n            }\n            DROPBITS(2);\n            break;\n        case STORED:\n            BYTEBITS();                         /* go to byte boundary */\n            NEEDBITS(32);\n            if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {\n                strm->msg = (z_const char *)\"invalid stored block lengths\";\n                state->mode = BAD;\n                break;\n            }\n            state->length = (unsigned)hold & 0xffff;\n            Tracev((stderr, \"inflate:       stored length %u\\n\",\n                    state->length));\n            INITBITS();\n            state->mode = COPY_;\n            if (flush == Z_TREES) goto inf_leave;\n                /* fallthrough */\n        case COPY_:\n            state->mode = COPY;\n                /* fallthrough */\n        case COPY:\n            copy = state->length;\n            if (copy) {\n                if (copy > have) copy = have;\n                if (copy > left) copy = left;\n                if (copy == 0) goto inf_leave;\n                zmemcpy(put, next, copy);\n                have -= copy;\n                next += copy;\n                left -= copy;\n                put += copy;\n                state->length -= copy;\n                break;\n            }\n            Tracev((stderr, \"inflate:       stored end\\n\"));\n            state->mode = TYPE;\n            break;\n        case TABLE:\n            NEEDBITS(14);\n            state->nlen = BITS(5) + 257;\n            DROPBITS(5);\n            state->ndist = BITS(5) + 1;\n            DROPBITS(5);\n            state->ncode = BITS(4) + 4;\n            DROPBITS(4);\n#ifndef PKZIP_BUG_WORKAROUND\n            if (state->nlen > 286 || state->ndist > 30) {\n                strm->msg = (z_const char *)\"too many length or distance symbols\";\n                state->mode = BAD;\n                break;\n            }\n#endif\n            Tracev((stderr, \"inflate:       table sizes ok\\n\"));\n            state->have = 0;\n            state->mode = LENLENS;\n                /* fallthrough */\n        case LENLENS:\n            while (state->have < state->ncode) {\n                NEEDBITS(3);\n                state->lens[order[state->have++]] = (unsigned short)BITS(3);\n                DROPBITS(3);\n            }\n            while (state->have < 19)\n                state->lens[order[state->have++]] = 0;\n            state->next = state->codes;\n            state->lencode = state->distcode = (const code FAR *)(state->next);\n            state->lenbits = 7;\n            ret = inflate_table(CODES, state->lens, 19, &(state->next),\n                                &(state->lenbits), state->work);\n            if (ret) {\n                strm->msg = (z_const char *)\"invalid code lengths set\";\n                state->mode = BAD;\n                break;\n            }\n            Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n            state->have = 0;\n            state->mode = CODELENS;\n                /* fallthrough */\n        case CODELENS:\n            while (state->have < state->nlen + state->ndist) {\n                for (;;) {\n                    here = state->lencode[BITS(state->lenbits)];\n                    if ((unsigned)(here.bits) <= bits) break;\n                    PULLBYTE();\n                }\n                if (here.val < 16) {\n                    DROPBITS(here.bits);\n                    state->lens[state->have++] = here.val;\n                }\n                else {\n                    if (here.val == 16) {\n                        NEEDBITS(here.bits + 2);\n                        DROPBITS(here.bits);\n                        if (state->have == 0) {\n                            strm->msg = (z_const char *)\"invalid bit length repeat\";\n                            state->mode = BAD;\n                            break;\n                        }\n                        len = state->lens[state->have - 1];\n                        copy = 3 + BITS(2);\n                        DROPBITS(2);\n                    }\n                    else if (here.val == 17) {\n                        NEEDBITS(here.bits + 3);\n                        DROPBITS(here.bits);\n                        len = 0;\n                        copy = 3 + BITS(3);\n                        DROPBITS(3);\n                    }\n                    else {\n                        NEEDBITS(here.bits + 7);\n                        DROPBITS(here.bits);\n                        len = 0;\n                        copy = 11 + BITS(7);\n                        DROPBITS(7);\n                    }\n                    if (state->have + copy > state->nlen + state->ndist) {\n                        strm->msg = (z_const char *)\"invalid bit length repeat\";\n                        state->mode = BAD;\n                        break;\n                    }\n                    while (copy--)\n                        state->lens[state->have++] = (unsigned short)len;\n                }\n            }\n\n            /* handle error breaks in while */\n            if (state->mode == BAD) break;\n\n            /* check for end-of-block code (better have one) */\n            if (state->lens[256] == 0) {\n                strm->msg = (z_const char *)\"invalid code -- missing end-of-block\";\n                state->mode = BAD;\n                break;\n            }\n\n            /* build code tables -- note: do not change the lenbits or distbits\n               values here (9 and 6) without reading the comments in inftrees.h\n               concerning the ENOUGH constants, which depend on those values */\n            state->next = state->codes;\n            state->lencode = (const code FAR *)(state->next);\n            state->lenbits = 9;\n            ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),\n                                &(state->lenbits), state->work);\n            if (ret) {\n                strm->msg = (z_const char *)\"invalid literal/lengths set\";\n                state->mode = BAD;\n                break;\n            }\n            state->distcode = (const code FAR *)(state->next);\n            state->distbits = 6;\n            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,\n                            &(state->next), &(state->distbits), state->work);\n            if (ret) {\n                strm->msg = (z_const char *)\"invalid distances set\";\n                state->mode = BAD;\n                break;\n            }\n            Tracev((stderr, \"inflate:       codes ok\\n\"));\n            state->mode = LEN_;\n            if (flush == Z_TREES) goto inf_leave;\n                /* fallthrough */\n        case LEN_:\n            state->mode = LEN;\n                /* fallthrough */\n        case LEN:\n            if (have >= 6 && left >= 258) {\n                RESTORE();\n                inflate_fast(strm, out);\n                LOAD();\n                if (state->mode == TYPE)\n                    state->back = -1;\n                break;\n            }\n            state->back = 0;\n            for (;;) {\n                here = state->lencode[BITS(state->lenbits)];\n                if ((unsigned)(here.bits) <= bits) break;\n                PULLBYTE();\n            }\n            if (here.op && (here.op & 0xf0) == 0) {\n                last = here;\n                for (;;) {\n                    here = state->lencode[last.val +\n                            (BITS(last.bits + last.op) >> last.bits)];\n                    if ((unsigned)(last.bits + here.bits) <= bits) break;\n                    PULLBYTE();\n                }\n                DROPBITS(last.bits);\n                state->back += last.bits;\n            }\n            DROPBITS(here.bits);\n            state->back += here.bits;\n            state->length = (unsigned)here.val;\n            if ((int)(here.op) == 0) {\n                Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n                        \"inflate:         literal '%c'\\n\" :\n                        \"inflate:         literal 0x%02x\\n\", here.val));\n                state->mode = LIT;\n                break;\n            }\n            if (here.op & 32) {\n                Tracevv((stderr, \"inflate:         end of block\\n\"));\n                state->back = -1;\n                state->mode = TYPE;\n                break;\n            }\n            if (here.op & 64) {\n                strm->msg = (z_const char *)\"invalid literal/length code\";\n                state->mode = BAD;\n                break;\n            }\n            state->extra = (unsigned)(here.op) & 15;\n            state->mode = LENEXT;\n                /* fallthrough */\n        case LENEXT:\n            if (state->extra) {\n                NEEDBITS(state->extra);\n                state->length += BITS(state->extra);\n                DROPBITS(state->extra);\n                state->back += state->extra;\n            }\n            Tracevv((stderr, \"inflate:         length %u\\n\", state->length));\n            state->was = state->length;\n            state->mode = DIST;\n                /* fallthrough */\n        case DIST:\n            for (;;) {\n                here = state->distcode[BITS(state->distbits)];\n                if ((unsigned)(here.bits) <= bits) break;\n                PULLBYTE();\n            }\n            if ((here.op & 0xf0) == 0) {\n                last = here;\n                for (;;) {\n                    here = state->distcode[last.val +\n                            (BITS(last.bits + last.op) >> last.bits)];\n                    if ((unsigned)(last.bits + here.bits) <= bits) break;\n                    PULLBYTE();\n                }\n                DROPBITS(last.bits);\n                state->back += last.bits;\n            }\n            DROPBITS(here.bits);\n            state->back += here.bits;\n            if (here.op & 64) {\n                strm->msg = (z_const char *)\"invalid distance code\";\n                state->mode = BAD;\n                break;\n            }\n            state->offset = (unsigned)here.val;\n            state->extra = (unsigned)(here.op) & 15;\n            state->mode = DISTEXT;\n                /* fallthrough */\n        case DISTEXT:\n            if (state->extra) {\n                NEEDBITS(state->extra);\n                state->offset += BITS(state->extra);\n                DROPBITS(state->extra);\n                state->back += state->extra;\n            }\n#ifdef INFLATE_STRICT\n            if (state->offset > state->dmax) {\n                strm->msg = (z_const char *)\"invalid distance too far back\";\n                state->mode = BAD;\n                break;\n            }\n#endif\n            Tracevv((stderr, \"inflate:         distance %u\\n\", state->offset));\n            state->mode = MATCH;\n                /* fallthrough */\n        case MATCH:\n            if (left == 0) goto inf_leave;\n            copy = out - left;\n            if (state->offset > copy) {         /* copy from window */\n                copy = state->offset - copy;\n                if (copy > state->whave) {\n                    if (state->sane) {\n                        strm->msg = (z_const char *)\"invalid distance too far back\";\n                        state->mode = BAD;\n                        break;\n                    }\n#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n                    Trace((stderr, \"inflate.c too far\\n\"));\n                    copy -= state->whave;\n                    if (copy > state->length) copy = state->length;\n                    if (copy > left) copy = left;\n                    left -= copy;\n                    state->length -= copy;\n                    do {\n                        *put++ = 0;\n                    } while (--copy);\n                    if (state->length == 0) state->mode = LEN;\n                    break;\n#endif\n                }\n                if (copy > state->wnext) {\n                    copy -= state->wnext;\n                    from = state->window + (state->wsize - copy);\n                }\n                else\n                    from = state->window + (state->wnext - copy);\n                if (copy > state->length) copy = state->length;\n            }\n            else {                              /* copy from output */\n                from = put - state->offset;\n                copy = state->length;\n            }\n            if (copy > left) copy = left;\n            left -= copy;\n            state->length -= copy;\n            do {\n                *put++ = *from++;\n            } while (--copy);\n            if (state->length == 0) state->mode = LEN;\n            break;\n        case LIT:\n            if (left == 0) goto inf_leave;\n            *put++ = (unsigned char)(state->length);\n            left--;\n            state->mode = LEN;\n            break;\n        case CHECK:\n            if (state->wrap) {\n                NEEDBITS(32);\n                out -= left;\n                strm->total_out += out;\n                state->total += out;\n                if ((state->wrap & 4) && out)\n                    strm->adler = state->check =\n                        UPDATE_CHECK(state->check, put - out, out);\n                out = left;\n                if ((state->wrap & 4) && (\n#ifdef GUNZIP\n                     state->flags ? hold :\n#endif\n                     ZSWAP32(hold)) != state->check) {\n                    strm->msg = (z_const char *)\"incorrect data check\";\n                    state->mode = BAD;\n                    break;\n                }\n                INITBITS();\n                Tracev((stderr, \"inflate:   check matches trailer\\n\"));\n            }\n#ifdef GUNZIP\n            state->mode = LENGTH;\n                /* fallthrough */\n        case LENGTH:\n            if (state->wrap && state->flags) {\n                NEEDBITS(32);\n                if ((state->wrap & 4) && hold != (state->total & 0xffffffff)) {\n                    strm->msg = (z_const char *)\"incorrect length check\";\n                    state->mode = BAD;\n                    break;\n                }\n                INITBITS();\n                Tracev((stderr, \"inflate:   length matches trailer\\n\"));\n            }\n#endif\n            state->mode = DONE;\n                /* fallthrough */\n        case DONE:\n            ret = Z_STREAM_END;\n            goto inf_leave;\n        case BAD:\n            ret = Z_DATA_ERROR;\n            goto inf_leave;\n        case MEM:\n            return Z_MEM_ERROR;\n        case SYNC:\n                /* fallthrough */\n        default:\n            return Z_STREAM_ERROR;\n        }\n\n    /*\n       Return from inflate(), updating the total counts and the check value.\n       If there was no progress during the inflate() call, return a buffer\n       error.  Call updatewindow() to create and/or update the window state.\n       Note: a memory error from inflate() is non-recoverable.\n     */\n  inf_leave:\n    RESTORE();\n    if (state->wsize || (out != strm->avail_out && state->mode < BAD &&\n            (state->mode < CHECK || flush != Z_FINISH)))\n        if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {\n            state->mode = MEM;\n            return Z_MEM_ERROR;\n        }\n    in -= strm->avail_in;\n    out -= strm->avail_out;\n    strm->total_in += in;\n    strm->total_out += out;\n    state->total += out;\n    if ((state->wrap & 4) && out)\n        strm->adler = state->check =\n            UPDATE_CHECK(state->check, strm->next_out - out, out);\n    strm->data_type = (int)state->bits + (state->last ? 64 : 0) +\n                      (state->mode == TYPE ? 128 : 0) +\n                      (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);\n    if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)\n        ret = Z_BUF_ERROR;\n    return ret;\n}\n\nint ZEXPORT inflateEnd(z_streamp strm) {\n    struct inflate_state FAR *state;\n    if (inflateStateCheck(strm))\n        return Z_STREAM_ERROR;\n    state = (struct inflate_state FAR *)strm->state;\n    if (state->window != Z_NULL) ZFREE(strm, state->window);\n    ZFREE(strm, strm->state);\n    strm->state = Z_NULL;\n    Tracev((stderr, \"inflate: end\\n\"));\n    return Z_OK;\n}\n\nint ZEXPORT inflateGetDictionary(z_streamp strm, Bytef *dictionary,\n                                 uInt *dictLength) {\n    struct inflate_state FAR *state;\n\n    /* check state */\n    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;\n    state = (struct inflate_state FAR *)strm->state;\n\n    /* copy dictionary */\n    if (state->whave && dictionary != Z_NULL) {\n        zmemcpy(dictionary, state->window + state->wnext,\n                state->whave - state->wnext);\n        zmemcpy(dictionary + state->whave - state->wnext,\n                state->window, state->wnext);\n    }\n    if (dictLength != Z_NULL)\n        *dictLength = state->whave;\n    return Z_OK;\n}\n\nint ZEXPORT inflateSetDictionary(z_streamp strm, const Bytef *dictionary,\n                                 uInt dictLength) {\n    struct inflate_state FAR *state;\n    unsigned long dictid;\n    int ret;\n\n    /* check state */\n    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;\n    state = (struct inflate_state FAR *)strm->state;\n    if (state->wrap != 0 && state->mode != DICT)\n        return Z_STREAM_ERROR;\n\n    /* check for correct dictionary identifier */\n    if (state->mode == DICT) {\n        dictid = adler32(0L, Z_NULL, 0);\n        dictid = adler32(dictid, dictionary, dictLength);\n        if (dictid != state->check)\n            return Z_DATA_ERROR;\n    }\n\n    /* copy dictionary to window using updatewindow(), which will amend the\n       existing dictionary if appropriate */\n    ret = updatewindow(strm, dictionary + dictLength, dictLength);\n    if (ret) {\n        state->mode = MEM;\n        return Z_MEM_ERROR;\n    }\n    state->havedict = 1;\n    Tracev((stderr, \"inflate:   dictionary set\\n\"));\n    return Z_OK;\n}\n\nint ZEXPORT inflateGetHeader(z_streamp strm, gz_headerp head) {\n    struct inflate_state FAR *state;\n\n    /* check state */\n    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;\n    state = (struct inflate_state FAR *)strm->state;\n    if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;\n\n    /* save header structure */\n    state->head = head;\n    head->done = 0;\n    return Z_OK;\n}\n\n/*\n   Search buf[0..len-1] for the pattern: 0, 0, 0xff, 0xff.  Return when found\n   or when out of input.  When called, *have is the number of pattern bytes\n   found in order so far, in 0..3.  On return *have is updated to the new\n   state.  If on return *have equals four, then the pattern was found and the\n   return value is how many bytes were read including the last byte of the\n   pattern.  If *have is less than four, then the pattern has not been found\n   yet and the return value is len.  In the latter case, syncsearch() can be\n   called again with more data and the *have state.  *have is initialized to\n   zero for the first call.\n */\nlocal unsigned syncsearch(unsigned FAR *have, const unsigned char FAR *buf,\n                          unsigned len) {\n    unsigned got;\n    unsigned next;\n\n    got = *have;\n    next = 0;\n    while (next < len && got < 4) {\n        if ((int)(buf[next]) == (got < 2 ? 0 : 0xff))\n            got++;\n        else if (buf[next])\n            got = 0;\n        else\n            got = 4 - got;\n        next++;\n    }\n    *have = got;\n    return next;\n}\n\nint ZEXPORT inflateSync(z_streamp strm) {\n    unsigned len;               /* number of bytes to look at or looked at */\n    int flags;                  /* temporary to save header status */\n    unsigned long in, out;      /* temporary to save total_in and total_out */\n    unsigned char buf[4];       /* to restore bit buffer to byte string */\n    struct inflate_state FAR *state;\n\n    /* check parameters */\n    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;\n    state = (struct inflate_state FAR *)strm->state;\n    if (strm->avail_in == 0 && state->bits < 8) return Z_BUF_ERROR;\n\n    /* if first time, start search in bit buffer */\n    if (state->mode != SYNC) {\n        state->mode = SYNC;\n        state->hold >>= state->bits & 7;\n        state->bits -= state->bits & 7;\n        len = 0;\n        while (state->bits >= 8) {\n            buf[len++] = (unsigned char)(state->hold);\n            state->hold >>= 8;\n            state->bits -= 8;\n        }\n        state->have = 0;\n        syncsearch(&(state->have), buf, len);\n    }\n\n    /* search available input */\n    len = syncsearch(&(state->have), strm->next_in, strm->avail_in);\n    strm->avail_in -= len;\n    strm->next_in += len;\n    strm->total_in += len;\n\n    /* return no joy or set up to restart inflate() on a new block */\n    if (state->have != 4) return Z_DATA_ERROR;\n    if (state->flags == -1)\n        state->wrap = 0;    /* if no header yet, treat as raw */\n    else\n        state->wrap &= ~4;  /* no point in computing a check value now */\n    flags = state->flags;\n    in = strm->total_in;  out = strm->total_out;\n    inflateReset(strm);\n    strm->total_in = in;  strm->total_out = out;\n    state->flags = flags;\n    state->mode = TYPE;\n    return Z_OK;\n}\n\n/*\n   Returns true if inflate is currently at the end of a block generated by\n   Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP\n   implementation to provide an additional safety check. PPP uses\n   Z_SYNC_FLUSH but removes the length bytes of the resulting empty stored\n   block. When decompressing, PPP checks that at the end of input packet,\n   inflate is waiting for these length bytes.\n */\nint ZEXPORT inflateSyncPoint(z_streamp strm) {\n    struct inflate_state FAR *state;\n\n    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;\n    state = (struct inflate_state FAR *)strm->state;\n    return state->mode == STORED && state->bits == 0;\n}\n\nint ZEXPORT inflateCopy(z_streamp dest, z_streamp source) {\n    struct inflate_state FAR *state;\n    struct inflate_state FAR *copy;\n    unsigned char FAR *window;\n    unsigned wsize;\n\n    /* check input */\n    if (inflateStateCheck(source) || dest == Z_NULL)\n        return Z_STREAM_ERROR;\n    state = (struct inflate_state FAR *)source->state;\n\n    /* allocate space */\n    copy = (struct inflate_state FAR *)\n           ZALLOC(source, 1, sizeof(struct inflate_state));\n    if (copy == Z_NULL) return Z_MEM_ERROR;\n    window = Z_NULL;\n    if (state->window != Z_NULL) {\n        window = (unsigned char FAR *)\n                 ZALLOC(source, 1U << state->wbits, sizeof(unsigned char));\n        if (window == Z_NULL) {\n            ZFREE(source, copy);\n            return Z_MEM_ERROR;\n        }\n    }\n\n    /* copy state */\n    zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));\n    zmemcpy((voidpf)copy, (voidpf)state, sizeof(struct inflate_state));\n    copy->strm = dest;\n    if (state->lencode >= state->codes &&\n        state->lencode <= state->codes + ENOUGH - 1) {\n        copy->lencode = copy->codes + (state->lencode - state->codes);\n        copy->distcode = copy->codes + (state->distcode - state->codes);\n    }\n    copy->next = copy->codes + (state->next - state->codes);\n    if (window != Z_NULL) {\n        wsize = 1U << state->wbits;\n        zmemcpy(window, state->window, wsize);\n    }\n    copy->window = window;\n    dest->state = (struct internal_state FAR *)copy;\n    return Z_OK;\n}\n\nint ZEXPORT inflateUndermine(z_streamp strm, int subvert) {\n    struct inflate_state FAR *state;\n\n    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;\n    state = (struct inflate_state FAR *)strm->state;\n#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n    state->sane = !subvert;\n    return Z_OK;\n#else\n    (void)subvert;\n    state->sane = 1;\n    return Z_DATA_ERROR;\n#endif\n}\n\nint ZEXPORT inflateValidate(z_streamp strm, int check) {\n    struct inflate_state FAR *state;\n\n    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;\n    state = (struct inflate_state FAR *)strm->state;\n    if (check && state->wrap)\n        state->wrap |= 4;\n    else\n        state->wrap &= ~4;\n    return Z_OK;\n}\n\nlong ZEXPORT inflateMark(z_streamp strm) {\n    struct inflate_state FAR *state;\n\n    if (inflateStateCheck(strm))\n        return -(1L << 16);\n    state = (struct inflate_state FAR *)strm->state;\n    return (long)(((unsigned long)((long)state->back)) << 16) +\n        (state->mode == COPY ? state->length :\n            (state->mode == MATCH ? state->was - state->length : 0));\n}\n\nunsigned long ZEXPORT inflateCodesUsed(z_streamp strm) {\n    struct inflate_state FAR *state;\n    if (inflateStateCheck(strm)) return (unsigned long)-1;\n    state = (struct inflate_state FAR *)strm->state;\n    return (unsigned long)(state->next - state->codes);\n}\n"
        },
        {
          "name": "inflate.h",
          "type": "blob",
          "size": 6.5263671875,
          "content": "/* inflate.h -- internal inflate state definition\n * Copyright (C) 1995-2019 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n/* WARNING: this file should *not* be used by applications. It is\n   part of the implementation of the compression library and is\n   subject to change. Applications should only use zlib.h.\n */\n\n/* define NO_GZIP when compiling if you want to disable gzip header and\n   trailer decoding by inflate().  NO_GZIP would be used to avoid linking in\n   the crc code when it is not needed.  For shared libraries, gzip decoding\n   should be left enabled. */\n#ifndef NO_GZIP\n#  define GUNZIP\n#endif\n\n/* Possible inflate modes between inflate() calls */\ntypedef enum {\n    HEAD = 16180,   /* i: waiting for magic header */\n    FLAGS,      /* i: waiting for method and flags (gzip) */\n    TIME,       /* i: waiting for modification time (gzip) */\n    OS,         /* i: waiting for extra flags and operating system (gzip) */\n    EXLEN,      /* i: waiting for extra length (gzip) */\n    EXTRA,      /* i: waiting for extra bytes (gzip) */\n    NAME,       /* i: waiting for end of file name (gzip) */\n    COMMENT,    /* i: waiting for end of comment (gzip) */\n    HCRC,       /* i: waiting for header crc (gzip) */\n    DICTID,     /* i: waiting for dictionary check value */\n    DICT,       /* waiting for inflateSetDictionary() call */\n        TYPE,       /* i: waiting for type bits, including last-flag bit */\n        TYPEDO,     /* i: same, but skip check to exit inflate on new block */\n        STORED,     /* i: waiting for stored size (length and complement) */\n        COPY_,      /* i/o: same as COPY below, but only first time in */\n        COPY,       /* i/o: waiting for input or output to copy stored block */\n        TABLE,      /* i: waiting for dynamic block table lengths */\n        LENLENS,    /* i: waiting for code length code lengths */\n        CODELENS,   /* i: waiting for length/lit and distance code lengths */\n            LEN_,       /* i: same as LEN below, but only first time in */\n            LEN,        /* i: waiting for length/lit/eob code */\n            LENEXT,     /* i: waiting for length extra bits */\n            DIST,       /* i: waiting for distance code */\n            DISTEXT,    /* i: waiting for distance extra bits */\n            MATCH,      /* o: waiting for output space to copy string */\n            LIT,        /* o: waiting for output space to write literal */\n    CHECK,      /* i: waiting for 32-bit check value */\n    LENGTH,     /* i: waiting for 32-bit length (gzip) */\n    DONE,       /* finished check, done -- remain here until reset */\n    BAD,        /* got a data error -- remain here until reset */\n    MEM,        /* got an inflate() memory error -- remain here until reset */\n    SYNC        /* looking for synchronization bytes to restart inflate() */\n} inflate_mode;\n\n/*\n    State transitions between above modes -\n\n    (most modes can go to BAD or MEM on error -- not shown for clarity)\n\n    Process header:\n        HEAD -> (gzip) or (zlib) or (raw)\n        (gzip) -> FLAGS -> TIME -> OS -> EXLEN -> EXTRA -> NAME -> COMMENT ->\n                  HCRC -> TYPE\n        (zlib) -> DICTID or TYPE\n        DICTID -> DICT -> TYPE\n        (raw) -> TYPEDO\n    Read deflate blocks:\n            TYPE -> TYPEDO -> STORED or TABLE or LEN_ or CHECK\n            STORED -> COPY_ -> COPY -> TYPE\n            TABLE -> LENLENS -> CODELENS -> LEN_\n            LEN_ -> LEN\n    Read deflate codes in fixed or dynamic block:\n                LEN -> LENEXT or LIT or TYPE\n                LENEXT -> DIST -> DISTEXT -> MATCH -> LEN\n                LIT -> LEN\n    Process trailer:\n        CHECK -> LENGTH -> DONE\n */\n\n/* State maintained between inflate() calls -- approximately 7K bytes, not\n   including the allocated sliding window, which is up to 32K bytes. */\nstruct inflate_state {\n    z_streamp strm;             /* pointer back to this zlib stream */\n    inflate_mode mode;          /* current inflate mode */\n    int last;                   /* true if processing last block */\n    int wrap;                   /* bit 0 true for zlib, bit 1 true for gzip,\n                                   bit 2 true to validate check value */\n    int havedict;               /* true if dictionary provided */\n    int flags;                  /* gzip header method and flags, 0 if zlib, or\n                                   -1 if raw or no header yet */\n    unsigned dmax;              /* zlib header max distance (INFLATE_STRICT) */\n    unsigned long check;        /* protected copy of check value */\n    unsigned long total;        /* protected copy of output count */\n    gz_headerp head;            /* where to save gzip header information */\n        /* sliding window */\n    unsigned wbits;             /* log base 2 of requested window size */\n    unsigned wsize;             /* window size or zero if not using window */\n    unsigned whave;             /* valid bytes in the window */\n    unsigned wnext;             /* window write index */\n    unsigned char FAR *window;  /* allocated sliding window, if needed */\n        /* bit accumulator */\n    unsigned long hold;         /* input bit accumulator */\n    unsigned bits;              /* number of bits in hold */\n        /* for string and stored block copying */\n    unsigned length;            /* literal or length of data to copy */\n    unsigned offset;            /* distance back to copy string from */\n        /* for table and code decoding */\n    unsigned extra;             /* extra bits needed */\n        /* fixed and dynamic code tables */\n    code const FAR *lencode;    /* starting table for length/literal codes */\n    code const FAR *distcode;   /* starting table for distance codes */\n    unsigned lenbits;           /* index bits for lencode */\n    unsigned distbits;          /* index bits for distcode */\n        /* dynamic table building */\n    unsigned ncode;             /* number of code length code lengths */\n    unsigned nlen;              /* number of length code lengths */\n    unsigned ndist;             /* number of distance code lengths */\n    unsigned have;              /* number of code lengths in lens[] */\n    code FAR *next;             /* next available space in codes[] */\n    unsigned short lens[320];   /* temporary storage for code lengths */\n    unsigned short work[288];   /* work area for code table building */\n    code codes[ENOUGH];         /* space for code tables */\n    int sane;                   /* if false, allow invalid distance too far */\n    int back;                   /* bits back of last unprocessed length/lit */\n    unsigned was;               /* initial length of match */\n};\n"
        },
        {
          "name": "inftrees.c",
          "type": "blob",
          "size": 12.720703125,
          "content": "/* inftrees.c -- generate Huffman trees for efficient decoding\n * Copyright (C) 1995-2024 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n#include \"zutil.h\"\n#include \"inftrees.h\"\n\n#define MAXBITS 15\n\nconst char inflate_copyright[] =\n   \" inflate 1.3.1.1 Copyright 1995-2024 Mark Adler \";\n/*\n  If you use the zlib library in a product, an acknowledgment is welcome\n  in the documentation of your product. If for some reason you cannot\n  include such an acknowledgment, I would appreciate that you keep this\n  copyright string in the executable of your product.\n */\n\n/*\n   Build a set of tables to decode the provided canonical Huffman code.\n   The code lengths are lens[0..codes-1].  The result starts at *table,\n   whose indices are 0..2^bits-1.  work is a writable array of at least\n   lens shorts, which is used as a work area.  type is the type of code\n   to be generated, CODES, LENS, or DISTS.  On return, zero is success,\n   -1 is an invalid code, and +1 means that ENOUGH isn't enough.  table\n   on return points to the next available entry's address.  bits is the\n   requested root table index bits, and on return it is the actual root\n   table index bits.  It will differ if the request is greater than the\n   longest code or if it is less than the shortest code.\n */\nint ZLIB_INTERNAL inflate_table(codetype type, unsigned short FAR *lens,\n                                unsigned codes, code FAR * FAR *table,\n                                unsigned FAR *bits, unsigned short FAR *work) {\n    unsigned len;               /* a code's length in bits */\n    unsigned sym;               /* index of code symbols */\n    unsigned min, max;          /* minimum and maximum code lengths */\n    unsigned root;              /* number of index bits for root table */\n    unsigned curr;              /* number of index bits for current table */\n    unsigned drop;              /* code bits to drop for sub-table */\n    int left;                   /* number of prefix codes available */\n    unsigned used;              /* code entries in table used */\n    unsigned huff;              /* Huffman code */\n    unsigned incr;              /* for incrementing code, index */\n    unsigned fill;              /* index for replicating entries */\n    unsigned low;               /* low bits for current root entry */\n    unsigned mask;              /* mask for low root bits */\n    code here;                  /* table entry for duplication */\n    code FAR *next;             /* next available space in table */\n    const unsigned short FAR *base;     /* base value table to use */\n    const unsigned short FAR *extra;    /* extra bits table to use */\n    unsigned match;             /* use base and extra for symbol >= match */\n    unsigned short count[MAXBITS+1];    /* number of codes of each length */\n    unsigned short offs[MAXBITS+1];     /* offsets in table for each length */\n    static const unsigned short lbase[31] = { /* Length codes 257..285 base */\n        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};\n    static const unsigned short lext[31] = { /* Length codes 257..285 extra */\n        16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,\n        19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 73, 200};\n    static const unsigned short dbase[32] = { /* Distance codes 0..29 base */\n        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n        8193, 12289, 16385, 24577, 0, 0};\n    static const unsigned short dext[32] = { /* Distance codes 0..29 extra */\n        16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,\n        23, 23, 24, 24, 25, 25, 26, 26, 27, 27,\n        28, 28, 29, 29, 64, 64};\n\n    /*\n       Process a set of code lengths to create a canonical Huffman code.  The\n       code lengths are lens[0..codes-1].  Each length corresponds to the\n       symbols 0..codes-1.  The Huffman code is generated by first sorting the\n       symbols by length from short to long, and retaining the symbol order\n       for codes with equal lengths.  Then the code starts with all zero bits\n       for the first code of the shortest length, and the codes are integer\n       increments for the same length, and zeros are appended as the length\n       increases.  For the deflate format, these bits are stored backwards\n       from their more natural integer increment ordering, and so when the\n       decoding tables are built in the large loop below, the integer codes\n       are incremented backwards.\n\n       This routine assumes, but does not check, that all of the entries in\n       lens[] are in the range 0..MAXBITS.  The caller must assure this.\n       1..MAXBITS is interpreted as that code length.  zero means that that\n       symbol does not occur in this code.\n\n       The codes are sorted by computing a count of codes for each length,\n       creating from that a table of starting indices for each length in the\n       sorted table, and then entering the symbols in order in the sorted\n       table.  The sorted table is work[], with that space being provided by\n       the caller.\n\n       The length counts are used for other purposes as well, i.e. finding\n       the minimum and maximum length codes, determining if there are any\n       codes at all, checking for a valid set of lengths, and looking ahead\n       at length counts to determine sub-table sizes when building the\n       decoding tables.\n     */\n\n    /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */\n    for (len = 0; len <= MAXBITS; len++)\n        count[len] = 0;\n    for (sym = 0; sym < codes; sym++)\n        count[lens[sym]]++;\n\n    /* bound code lengths, force root to be within code lengths */\n    root = *bits;\n    for (max = MAXBITS; max >= 1; max--)\n        if (count[max] != 0) break;\n    if (root > max) root = max;\n    if (max == 0) {                     /* no symbols to code at all */\n        here.op = (unsigned char)64;    /* invalid code marker */\n        here.bits = (unsigned char)1;\n        here.val = (unsigned short)0;\n        *(*table)++ = here;             /* make a table to force an error */\n        *(*table)++ = here;\n        *bits = 1;\n        return 0;     /* no symbols, but wait for decoding to report error */\n    }\n    for (min = 1; min < max; min++)\n        if (count[min] != 0) break;\n    if (root < min) root = min;\n\n    /* check for an over-subscribed or incomplete set of lengths */\n    left = 1;\n    for (len = 1; len <= MAXBITS; len++) {\n        left <<= 1;\n        left -= count[len];\n        if (left < 0) return -1;        /* over-subscribed */\n    }\n    if (left > 0 && (type == CODES || max != 1))\n        return -1;                      /* incomplete set */\n\n    /* generate offsets into symbol table for each length for sorting */\n    offs[1] = 0;\n    for (len = 1; len < MAXBITS; len++)\n        offs[len + 1] = offs[len] + count[len];\n\n    /* sort symbols by length, by symbol order within each length */\n    for (sym = 0; sym < codes; sym++)\n        if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;\n\n    /*\n       Create and fill in decoding tables.  In this loop, the table being\n       filled is at next and has curr index bits.  The code being used is huff\n       with length len.  That code is converted to an index by dropping drop\n       bits off of the bottom.  For codes where len is less than drop + curr,\n       those top drop + curr - len bits are incremented through all values to\n       fill the table with replicated entries.\n\n       root is the number of index bits for the root table.  When len exceeds\n       root, sub-tables are created pointed to by the root entry with an index\n       of the low root bits of huff.  This is saved in low to check for when a\n       new sub-table should be started.  drop is zero when the root table is\n       being filled, and drop is root when sub-tables are being filled.\n\n       When a new sub-table is needed, it is necessary to look ahead in the\n       code lengths to determine what size sub-table is needed.  The length\n       counts are used for this, and so count[] is decremented as codes are\n       entered in the tables.\n\n       used keeps track of how many table entries have been allocated from the\n       provided *table space.  It is checked for LENS and DIST tables against\n       the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in\n       the initial root table size constants.  See the comments in inftrees.h\n       for more information.\n\n       sym increments through all symbols, and the loop terminates when\n       all codes of length max, i.e. all codes, have been processed.  This\n       routine permits incomplete codes, so another loop after this one fills\n       in the rest of the decoding tables with invalid code markers.\n     */\n\n    /* set up for code type */\n    switch (type) {\n    case CODES:\n        base = extra = work;    /* dummy value--not used */\n        match = 20;\n        break;\n    case LENS:\n        base = lbase;\n        extra = lext;\n        match = 257;\n        break;\n    default:    /* DISTS */\n        base = dbase;\n        extra = dext;\n        match = 0;\n    }\n\n    /* initialize state for loop */\n    huff = 0;                   /* starting code */\n    sym = 0;                    /* starting code symbol */\n    len = min;                  /* starting code length */\n    next = *table;              /* current table to fill in */\n    curr = root;                /* current table index bits */\n    drop = 0;                   /* current bits to drop from code for index */\n    low = (unsigned)(-1);       /* trigger new sub-table when len > root */\n    used = 1U << root;          /* use root table entries */\n    mask = used - 1;            /* mask for comparing low */\n\n    /* check available table space */\n    if ((type == LENS && used > ENOUGH_LENS) ||\n        (type == DISTS && used > ENOUGH_DISTS))\n        return 1;\n\n    /* process all codes and make table entries */\n    for (;;) {\n        /* create table entry */\n        here.bits = (unsigned char)(len - drop);\n        if (work[sym] + 1U < match) {\n            here.op = (unsigned char)0;\n            here.val = work[sym];\n        }\n        else if (work[sym] >= match) {\n            here.op = (unsigned char)(extra[work[sym] - match]);\n            here.val = base[work[sym] - match];\n        }\n        else {\n            here.op = (unsigned char)(32 + 64);         /* end of block */\n            here.val = 0;\n        }\n\n        /* replicate for those indices with low len bits equal to huff */\n        incr = 1U << (len - drop);\n        fill = 1U << curr;\n        min = fill;                 /* save offset to next table */\n        do {\n            fill -= incr;\n            next[(huff >> drop) + fill] = here;\n        } while (fill != 0);\n\n        /* backwards increment the len-bit code huff */\n        incr = 1U << (len - 1);\n        while (huff & incr)\n            incr >>= 1;\n        if (incr != 0) {\n            huff &= incr - 1;\n            huff += incr;\n        }\n        else\n            huff = 0;\n\n        /* go to next symbol, update count, len */\n        sym++;\n        if (--(count[len]) == 0) {\n            if (len == max) break;\n            len = lens[work[sym]];\n        }\n\n        /* create new sub-table if needed */\n        if (len > root && (huff & mask) != low) {\n            /* if first time, transition to sub-tables */\n            if (drop == 0)\n                drop = root;\n\n            /* increment past last table */\n            next += min;            /* here min is 1 << curr */\n\n            /* determine length of next table */\n            curr = len - drop;\n            left = (int)(1 << curr);\n            while (curr + drop < max) {\n                left -= count[curr + drop];\n                if (left <= 0) break;\n                curr++;\n                left <<= 1;\n            }\n\n            /* check for enough space */\n            used += 1U << curr;\n            if ((type == LENS && used > ENOUGH_LENS) ||\n                (type == DISTS && used > ENOUGH_DISTS))\n                return 1;\n\n            /* point entry in root table to sub-table */\n            low = huff & mask;\n            (*table)[low].op = (unsigned char)curr;\n            (*table)[low].bits = (unsigned char)root;\n            (*table)[low].val = (unsigned short)(next - *table);\n        }\n    }\n\n    /* fill in remaining table entry if code is incomplete (guaranteed to have\n       at most one remaining entry, since if the code is incomplete, the\n       maximum code length that was allowed to get this far is one bit) */\n    if (huff != 0) {\n        here.op = (unsigned char)64;            /* invalid code marker */\n        here.bits = (unsigned char)(len - drop);\n        here.val = (unsigned short)0;\n        next[huff] = here;\n    }\n\n    /* set return parameters */\n    *table += used;\n    *bits = root;\n    return 0;\n}\n"
        },
        {
          "name": "inftrees.h",
          "type": "blob",
          "size": 2.8515625,
          "content": "/* inftrees.h -- header to use inftrees.c\n * Copyright (C) 1995-2005, 2010 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n/* WARNING: this file should *not* be used by applications. It is\n   part of the implementation of the compression library and is\n   subject to change. Applications should only use zlib.h.\n */\n\n/* Structure for decoding tables.  Each entry provides either the\n   information needed to do the operation requested by the code that\n   indexed that table entry, or it provides a pointer to another\n   table that indexes more bits of the code.  op indicates whether\n   the entry is a pointer to another table, a literal, a length or\n   distance, an end-of-block, or an invalid code.  For a table\n   pointer, the low four bits of op is the number of index bits of\n   that table.  For a length or distance, the low four bits of op\n   is the number of extra bits to get after the code.  bits is\n   the number of bits in this code or part of the code to drop off\n   of the bit buffer.  val is the actual byte to output in the case\n   of a literal, the base length or distance, or the offset from\n   the current table to the next table.  Each entry is four bytes. */\ntypedef struct {\n    unsigned char op;           /* operation, extra bits, table bits */\n    unsigned char bits;         /* bits in this part of the code */\n    unsigned short val;         /* offset in table or code value */\n} code;\n\n/* op values as set by inflate_table():\n    00000000 - literal\n    0000tttt - table link, tttt != 0 is the number of table index bits\n    0001eeee - length or distance, eeee is the number of extra bits\n    01100000 - end of block\n    01000000 - invalid code\n */\n\n/* Maximum size of the dynamic table.  The maximum number of code structures is\n   1444, which is the sum of 852 for literal/length codes and 592 for distance\n   codes.  These values were found by exhaustive searches using the program\n   examples/enough.c found in the zlib distribution.  The arguments to that\n   program are the number of symbols, the initial root table size, and the\n   maximum bit length of a code.  \"enough 286 9 15\" for literal/length codes\n   returns 852, and \"enough 30 6 15\" for distance codes returns 592. The\n   initial root table size (9 or 6) is found in the fifth argument of the\n   inflate_table() calls in inflate.c and infback.c.  If the root table size is\n   changed, then these maximum sizes would be need to be recalculated and\n   updated. */\n#define ENOUGH_LENS 852\n#define ENOUGH_DISTS 592\n#define ENOUGH (ENOUGH_LENS+ENOUGH_DISTS)\n\n/* Type of code to build for inflate_table() */\ntypedef enum {\n    CODES,\n    LENS,\n    DISTS\n} codetype;\n\nint ZLIB_INTERNAL inflate_table(codetype type, unsigned short FAR *lens,\n                                unsigned codes, code FAR * FAR *table,\n                                unsigned FAR *bits, unsigned short FAR *work);\n"
        },
        {
          "name": "make_vms.com",
          "type": "blob",
          "size": 25.78515625,
          "content": "$! make libz under VMS written by\n$! Martin P.J. Zinser\n$!\n$! In case of problems with the install you might contact me at\n$! zinser@zinser.no-ip.info(preferred) or\n$! martin.zinser@eurexchange.com (work)\n$!\n$! Make procedure history for Zlib\n$!\n$!------------------------------------------------------------------------------\n$! Version history\n$! 0.01 20060120 First version to receive a number\n$! 0.02 20061008 Adapt to new Makefile.in\n$! 0.03 20091224 Add support for large file check\n$! 0.04 20100110 Add new gzclose, gzlib, gzread, gzwrite\n$! 0.05 20100221 Exchange zlibdefs.h by zconf.h.in\n$! 0.06 20120111 Fix missing amiss_err, update zconf_h.in, fix new examples\n$!               subdir path, update module search in makefile.in\n$! 0.07 20120115 Triggered by work done by Alexey Chupahin completely redesigned\n$!               shared image creation\n$! 0.08 20120219 Make it work on VAX again, pre-load missing symbols to shared\n$!               image\n$! 0.09 20120305 SMS.  P1 sets builder (\"MMK\", \"MMS\", \" \" (built-in)).\n$!               \"\" -> automatic, preference: MMK, MMS, built-in.\n$!\n$ on error then goto err_exit\n$!\n$ true  = 1\n$ false = 0\n$ tmpnam = \"temp_\" + f$getjpi(\"\",\"pid\")\n$ tt = tmpnam + \".txt\"\n$ tc = tmpnam + \".c\"\n$ th = tmpnam + \".h\"\n$ define/nolog tconfig 'th'\n$ its_decc = false\n$ its_vaxc = false\n$ its_gnuc = false\n$ s_case   = False\n$!\n$! Setup variables holding \"config\" information\n$!\n$ Make    = \"''p1'\"\n$ name     = \"Zlib\"\n$ version  = \"?.?.?\"\n$ v_string = \"ZLIB_VERSION\"\n$ v_file   = \"zlib.h\"\n$ ccopt   = \"/include = []\"\n$ lopts   = \"\"\n$ dnsrl   = \"\"\n$ aconf_in_file = \"zconf.h.in#zconf.h_in#zconf_h.in\"\n$ conf_check_string = \"\"\n$ linkonly = false\n$ optfile  = name + \".opt\"\n$ mapfile  = name + \".map\"\n$ libdefs  = \"\"\n$ vax      = f$getsyi(\"HW_MODEL\").lt.1024\n$ axp      = f$getsyi(\"HW_MODEL\").ge.1024 .and. f$getsyi(\"HW_MODEL\").lt.4096\n$ ia64     = f$getsyi(\"HW_MODEL\").ge.4096\n$!\n$! 2012-03-05 SMS.\n$! Why is this needed?  And if it is needed, why not simply \".not. vax\"?\n$!\n$!!! if axp .or. ia64 then  set proc/parse=extended\n$!\n$ whoami = f$parse(f$environment(\"Procedure\"),,,,\"NO_CONCEAL\")\n$ mydef  = F$parse(whoami,,,\"DEVICE\")\n$ mydir  = f$parse(whoami,,,\"DIRECTORY\") - \"][\"\n$ myproc = f$parse(whoami,,,\"Name\") + f$parse(whoami,,,\"type\")\n$!\n$! Check for MMK/MMS\n$!\n$ if (Make .eqs. \"\")\n$ then\n$   If F$Search (\"Sys$System:MMS.EXE\") .nes. \"\" Then Make = \"MMS\"\n$   If F$Type (MMK) .eqs. \"STRING\" Then Make = \"MMK\"\n$ else\n$   Make = f$edit( Make, \"trim\")\n$ endif\n$!\n$ gosub find_version\n$!\n$  open/write topt tmp.opt\n$  open/write optf 'optfile'\n$!\n$ gosub check_opts\n$!\n$! Look for the compiler used\n$!\n$ gosub check_compiler\n$ close topt\n$ close optf\n$!\n$ if its_decc\n$ then\n$   ccopt = \"/prefix=all\" + ccopt\n$   if f$trnlnm(\"SYS\") .eqs. \"\"\n$   then\n$     if axp\n$     then\n$       define sys sys$library:\n$     else\n$       ccopt = \"/decc\" + ccopt\n$       define sys decc$library_include:\n$     endif\n$   endif\n$!\n$! 2012-03-05 SMS.\n$! Why /NAMES = AS_IS?  Why not simply \".not. vax\"?  And why not on VAX?\n$!\n$   if axp .or. ia64\n$   then\n$       ccopt = ccopt + \"/name=as_is/opt=(inline=speed)\"\n$       s_case = true\n$   endif\n$ endif\n$ if its_vaxc .or. its_gnuc\n$ then\n$    if f$trnlnm(\"SYS\").eqs.\"\" then define sys sys$library:\n$ endif\n$!\n$! Build a fake configure input header\n$!\n$ open/write conf_hin config.hin\n$ write conf_hin \"#undef _LARGEFILE64_SOURCE\"\n$ close conf_hin\n$!\n$!\n$ i = 0\n$FIND_ACONF:\n$ fname = f$element(i,\"#\",aconf_in_file)\n$ if fname .eqs. \"#\" then goto AMISS_ERR\n$ if f$search(fname) .eqs. \"\"\n$ then\n$   i = i + 1\n$   goto find_aconf\n$ endif\n$ open/read/err=aconf_err aconf_in 'fname'\n$ open/write aconf zconf.h\n$ACONF_LOOP:\n$ read/end_of_file=aconf_exit aconf_in line\n$ work = f$edit(line, \"compress,trim\")\n$ if f$extract(0,6,work) .nes. \"#undef\"\n$ then\n$   if f$extract(0,12,work) .nes. \"#cmakedefine\"\n$   then\n$       write aconf line\n$   endif\n$ else\n$   cdef = f$element(1,\" \",work)\n$   gosub check_config\n$ endif\n$ goto aconf_loop\n$ACONF_EXIT:\n$ write aconf \"\"\n$ write aconf \"/* VMS specifics added by make_vms.com: */\"\n$ write aconf \"#define VMS 1\"\n$ write aconf \"#include <unistd.h>\"\n$ write aconf \"#include <unixio.h>\"\n$ write aconf \"#ifdef _LARGEFILE\"\n$ write aconf \"# define off64_t __off64_t\"\n$ write aconf \"# define fopen64 fopen\"\n$ write aconf \"# define fseeko64 fseeko\"\n$ write aconf \"# define lseek64 lseek\"\n$ write aconf \"# define ftello64 ftell\"\n$ write aconf \"#endif\"\n$ write aconf \"#if !defined( __VAX) && (__CRTL_VER >= 70312000)\"\n$ write aconf \"# define HAVE_VSNPRINTF\"\n$ write aconf \"#endif\"\n$ close aconf_in\n$ close aconf\n$ if f$search(\"''th'\") .nes. \"\" then delete 'th';*\n$! Build the thing plain or with mms\n$!\n$ write sys$output \"Compiling Zlib sources ...\"\n$ if make.eqs.\"\"\n$ then\n$   if (f$search( \"example.obj;*\") .nes. \"\") then delete example.obj;*\n$   if (f$search( \"minigzip.obj;*\") .nes. \"\") then delete minigzip.obj;*\n$   CALL MAKE adler32.OBJ \"CC ''CCOPT' adler32\" -\n                adler32.c zlib.h zconf.h\n$   CALL MAKE compress.OBJ \"CC ''CCOPT' compress\" -\n                compress.c zlib.h zconf.h\n$   CALL MAKE crc32.OBJ \"CC ''CCOPT' crc32\" -\n                crc32.c zlib.h zconf.h\n$   CALL MAKE deflate.OBJ \"CC ''CCOPT' deflate\" -\n                deflate.c deflate.h zutil.h zlib.h zconf.h\n$   CALL MAKE gzclose.OBJ \"CC ''CCOPT' gzclose\" -\n                gzclose.c zutil.h zlib.h zconf.h\n$   CALL MAKE gzlib.OBJ \"CC ''CCOPT' gzlib\" -\n                gzlib.c zutil.h zlib.h zconf.h\n$   CALL MAKE gzread.OBJ \"CC ''CCOPT' gzread\" -\n                gzread.c zutil.h zlib.h zconf.h\n$   CALL MAKE gzwrite.OBJ \"CC ''CCOPT' gzwrite\" -\n                gzwrite.c zutil.h zlib.h zconf.h\n$   CALL MAKE infback.OBJ \"CC ''CCOPT' infback\" -\n                infback.c zutil.h inftrees.h inflate.h inffast.h inffixed.h\n$   CALL MAKE inffast.OBJ \"CC ''CCOPT' inffast\" -\n                inffast.c zutil.h zlib.h zconf.h inffast.h\n$   CALL MAKE inflate.OBJ \"CC ''CCOPT' inflate\" -\n                inflate.c zutil.h zlib.h zconf.h infblock.h\n$   CALL MAKE inftrees.OBJ \"CC ''CCOPT' inftrees\" -\n                inftrees.c zutil.h zlib.h zconf.h inftrees.h\n$   CALL MAKE trees.OBJ \"CC ''CCOPT' trees\" -\n                trees.c deflate.h zutil.h zlib.h zconf.h\n$   CALL MAKE uncompr.OBJ \"CC ''CCOPT' uncompr\" -\n                uncompr.c zlib.h zconf.h\n$   CALL MAKE zutil.OBJ \"CC ''CCOPT' zutil\" -\n                zutil.c zutil.h zlib.h zconf.h\n$   write sys$output \"Building Zlib ...\"\n$   CALL MAKE libz.OLB \"lib/crea libz.olb *.obj\" *.OBJ\n$   write sys$output \"Building example...\"\n$   CALL MAKE example.OBJ \"CC ''CCOPT' [.test]example\" -\n                [.test]example.c zlib.h zconf.h\n$   call make example.exe \"LINK example,libz.olb/lib\" example.obj libz.olb\n$   write sys$output \"Building minigzip...\"\n$   CALL MAKE minigzip.OBJ \"CC ''CCOPT' [.test]minigzip\" -\n              [.test]minigzip.c zlib.h zconf.h\n$   call make minigzip.exe -\n              \"LINK minigzip,libz.olb/lib\" -\n              minigzip.obj libz.olb\n$ else\n$   gosub crea_mms\n$   write sys$output \"Make ''name' ''version' with ''Make' \"\n$   'make'\n$ endif\n$!\n$! Create shareable image\n$!\n$ gosub crea_olist\n$ write sys$output \"Creating libzshr.exe\"\n$ call map_2_shopt 'mapfile' 'optfile'\n$ LINK_'lopts'/SHARE=libzshr.exe modules.opt/opt,'optfile'/opt\n$ write sys$output \"Zlib build completed\"\n$ delete/nolog tmp.opt;*\n$ exit\n$AMISS_ERR:\n$ write sys$output \"No source for config.hin found.\"\n$ write sys$output \"Tried any of ''aconf_in_file'\"\n$ goto err_exit\n$CC_ERR:\n$ write sys$output \"C compiler required to build ''name'\"\n$ goto err_exit\n$ERR_EXIT:\n$ set message/facil/ident/sever/text\n$ close/nolog optf\n$ close/nolog topt\n$ close/nolog aconf_in\n$ close/nolog aconf\n$ close/nolog out\n$ close/nolog min\n$ close/nolog mod\n$ close/nolog h_in\n$ write sys$output \"Exiting...\"\n$ exit 2\n$!\n$!\n$MAKE: SUBROUTINE   !SUBROUTINE TO CHECK DEPENDENCIES\n$ V = 'F$Verify(0)\n$! P1 = What we are trying to make\n$! P2 = Command to make it\n$! P3 - P8  What it depends on\n$\n$ If F$Search(P1) .Eqs. \"\" Then Goto Makeit\n$ Time = F$CvTime(F$File(P1,\"RDT\"))\n$arg=3\n$Loop:\n$       Argument = P'arg\n$       If Argument .Eqs. \"\" Then Goto Exit\n$       El=0\n$Loop2:\n$       File = F$Element(El,\" \",Argument)\n$       If File .Eqs. \" \" Then Goto Endl\n$       AFile = \"\"\n$Loop3:\n$       OFile = AFile\n$       AFile = F$Search(File)\n$       If AFile .Eqs. \"\" .Or. AFile .Eqs. OFile Then Goto NextEl\n$       If F$CvTime(F$File(AFile,\"RDT\")) .Ges. Time Then Goto Makeit\n$       Goto Loop3\n$NextEL:\n$       El = El + 1\n$       Goto Loop2\n$EndL:\n$ arg=arg+1\n$ If arg .Le. 8 Then Goto Loop\n$ Goto Exit\n$\n$Makeit:\n$ VV=F$VERIFY(0)\n$ write sys$output P2\n$ 'P2\n$ VV='F$Verify(VV)\n$Exit:\n$ If V Then Set Verify\n$ENDSUBROUTINE\n$!------------------------------------------------------------------------------\n$!\n$! Check command line options and set symbols accordingly\n$!\n$!------------------------------------------------------------------------------\n$! Version history\n$! 0.01 20041206 First version to receive a number\n$! 0.02 20060126 Add new \"HELP\" target\n$ CHECK_OPTS:\n$ i = 1\n$ OPT_LOOP:\n$ if i .lt. 9\n$ then\n$   cparm = f$edit(p'i',\"upcase\")\n$!\n$! Check if parameter actually contains something\n$!\n$   if f$edit(cparm,\"trim\") .nes. \"\"\n$   then\n$     if cparm .eqs. \"DEBUG\"\n$     then\n$       ccopt = ccopt + \"/noopt/deb\"\n$       lopts = lopts + \"/deb\"\n$     endif\n$     if f$locate(\"CCOPT=\",cparm) .lt. f$length(cparm)\n$     then\n$       start = f$locate(\"=\",cparm) + 1\n$       len   = f$length(cparm) - start\n$       ccopt = ccopt + f$extract(start,len,cparm)\n$       if f$locate(\"AS_IS\",f$edit(ccopt,\"UPCASE\")) .lt. f$length(ccopt) -\n          then s_case = true\n$     endif\n$     if cparm .eqs. \"LINK\" then linkonly = true\n$     if f$locate(\"LOPTS=\",cparm) .lt. f$length(cparm)\n$     then\n$       start = f$locate(\"=\",cparm) + 1\n$       len   = f$length(cparm) - start\n$       lopts = lopts + f$extract(start,len,cparm)\n$     endif\n$     if f$locate(\"CC=\",cparm) .lt. f$length(cparm)\n$     then\n$       start  = f$locate(\"=\",cparm) + 1\n$       len    = f$length(cparm) - start\n$       cc_com = f$extract(start,len,cparm)\n        if (cc_com .nes. \"DECC\") .and. -\n           (cc_com .nes. \"VAXC\") .and. -\n           (cc_com .nes. \"GNUC\")\n$       then\n$         write sys$output \"Unsupported compiler choice ''cc_com' ignored\"\n$         write sys$output \"Use DECC, VAXC, or GNUC instead\"\n$       else\n$         if cc_com .eqs. \"DECC\" then its_decc = true\n$         if cc_com .eqs. \"VAXC\" then its_vaxc = true\n$         if cc_com .eqs. \"GNUC\" then its_gnuc = true\n$       endif\n$     endif\n$     if f$locate(\"MAKE=\",cparm) .lt. f$length(cparm)\n$     then\n$       start  = f$locate(\"=\",cparm) + 1\n$       len    = f$length(cparm) - start\n$       mmks = f$extract(start,len,cparm)\n$       if (mmks .eqs. \"MMK\") .or. (mmks .eqs. \"MMS\")\n$       then\n$         make = mmks\n$       else\n$         write sys$output \"Unsupported make choice ''mmks' ignored\"\n$         write sys$output \"Use MMK or MMS instead\"\n$       endif\n$     endif\n$     if cparm .eqs. \"HELP\" then gosub bhelp\n$   endif\n$   i = i + 1\n$   goto opt_loop\n$ endif\n$ return\n$!------------------------------------------------------------------------------\n$!\n$! Look for the compiler used\n$!\n$! Version history\n$! 0.01 20040223 First version to receive a number\n$! 0.02 20040229 Save/set value of decc$no_rooted_search_lists\n$! 0.03 20060202 Extend handling of GNU C\n$! 0.04 20090402 Compaq -> hp\n$CHECK_COMPILER:\n$ if (.not. (its_decc .or. its_vaxc .or. its_gnuc))\n$ then\n$   its_decc = (f$search(\"SYS$SYSTEM:DECC$COMPILER.EXE\") .nes. \"\")\n$   its_vaxc = .not. its_decc .and. (F$Search(\"SYS$System:VAXC.Exe\") .nes. \"\")\n$   its_gnuc = .not. (its_decc .or. its_vaxc) .and. (f$trnlnm(\"gnu_cc\") .nes. \"\")\n$ endif\n$!\n$! Exit if no compiler available\n$!\n$ if (.not. (its_decc .or. its_vaxc .or. its_gnuc))\n$ then goto CC_ERR\n$ else\n$   if its_decc\n$   then\n$     write sys$output \"CC compiler check ... hp C\"\n$     if f$trnlnm(\"decc$no_rooted_search_lists\") .nes. \"\"\n$     then\n$       dnrsl = f$trnlnm(\"decc$no_rooted_search_lists\")\n$     endif\n$     define/nolog decc$no_rooted_search_lists 1\n$   else\n$     if its_vaxc then write sys$output \"CC compiler check ... VAX C\"\n$     if its_gnuc\n$     then\n$         write sys$output \"CC compiler check ... GNU C\"\n$         if f$trnlnm(topt) then write topt \"gnu_cc:[000000]gcclib.olb/lib\"\n$         if f$trnlnm(optf) then write optf \"gnu_cc:[000000]gcclib.olb/lib\"\n$         cc = \"gcc\"\n$     endif\n$     if f$trnlnm(topt) then write topt \"sys$share:vaxcrtl.exe/share\"\n$     if f$trnlnm(optf) then write optf \"sys$share:vaxcrtl.exe/share\"\n$   endif\n$ endif\n$ return\n$!------------------------------------------------------------------------------\n$!\n$! If MMS/MMK are available dump out the descrip.mms if required\n$!\n$CREA_MMS:\n$ write sys$output \"Creating descrip.mms...\"\n$ create descrip.mms\n$ open/append out descrip.mms\n$ copy sys$input: out\n$ deck\n# descrip.mms: MMS description file for building zlib on VMS\n# written by Martin P.J. Zinser\n# <zinser@zinser.no-ip.info or martin.zinser@eurexchange.com>\n\nOBJS = adler32.obj, compress.obj, crc32.obj, gzclose.obj, gzlib.obj\\\n       gzread.obj, gzwrite.obj, uncompr.obj, infback.obj\\\n       deflate.obj, trees.obj, zutil.obj, inflate.obj, \\\n       inftrees.obj, inffast.obj\n\n$ eod\n$ write out \"CFLAGS=\", ccopt\n$ write out \"LOPTS=\", lopts\n$ write out \"all : example.exe minigzip.exe libz.olb\"\n$ copy sys$input: out\n$ deck\n        @ write sys$output \" Example applications available\"\n\nlibz.olb : libz.olb($(OBJS))\n\t@ write sys$output \" libz available\"\n\nexample.exe : example.obj libz.olb\n              link $(LOPTS) example,libz.olb/lib\n\nminigzip.exe : minigzip.obj libz.olb\n              link $(LOPTS) minigzip,libz.olb/lib\n\nclean :\n\tdelete *.obj;*,libz.olb;*,*.opt;*,*.exe;*\n\n\n# Other dependencies.\nadler32.obj  : adler32.c zutil.h zlib.h zconf.h\ncompress.obj : compress.c zlib.h zconf.h\ncrc32.obj    : crc32.c zutil.h zlib.h zconf.h\ndeflate.obj  : deflate.c deflate.h zutil.h zlib.h zconf.h\nexample.obj  : [.test]example.c zlib.h zconf.h\ngzclose.obj  : gzclose.c zutil.h zlib.h zconf.h\ngzlib.obj    : gzlib.c zutil.h zlib.h zconf.h\ngzread.obj   : gzread.c zutil.h zlib.h zconf.h\ngzwrite.obj  : gzwrite.c zutil.h zlib.h zconf.h\ninffast.obj  : inffast.c zutil.h zlib.h zconf.h inftrees.h inffast.h\ninflate.obj  : inflate.c zutil.h zlib.h zconf.h\ninftrees.obj : inftrees.c zutil.h zlib.h zconf.h inftrees.h\nminigzip.obj : [.test]minigzip.c zlib.h zconf.h\ntrees.obj    : trees.c deflate.h zutil.h zlib.h zconf.h\nuncompr.obj  : uncompr.c zlib.h zconf.h\nzutil.obj    : zutil.c zutil.h zlib.h zconf.h\ninfback.obj  : infback.c zutil.h inftrees.h inflate.h inffast.h inffixed.h\n$ eod\n$ close out\n$ return\n$!------------------------------------------------------------------------------\n$!\n$! Read list of core library sources from makefile.in and create options\n$! needed to build shareable image\n$!\n$CREA_OLIST:\n$ open/read min makefile.in\n$ open/write mod modules.opt\n$ src_check_list = \"OBJZ =#OBJG =\"\n$MRLOOP:\n$ read/end=mrdone min rec\n$ i = 0\n$SRC_CHECK_LOOP:\n$ src_check = f$element(i, \"#\", src_check_list)\n$ i = i+1\n$ if src_check .eqs. \"#\" then goto mrloop\n$ if (f$extract(0,6,rec) .nes. src_check) then goto src_check_loop\n$ rec = rec - src_check\n$ gosub extra_filnam\n$ if (f$element(1,\"\\\",rec) .eqs. \"\\\") then goto mrloop\n$MRSLOOP:\n$ read/end=mrdone min rec\n$ gosub extra_filnam\n$ if (f$element(1,\"\\\",rec) .nes. \"\\\") then goto mrsloop\n$MRDONE:\n$ close min\n$ close mod\n$ return\n$!------------------------------------------------------------------------------\n$!\n$! Take record extracted in crea_olist and split it into single filenames\n$!\n$EXTRA_FILNAM:\n$ myrec = f$edit(rec - \"\\\", \"trim,compress\")\n$ i = 0\n$FELOOP:\n$ srcfil = f$element(i,\" \", myrec)\n$ if (srcfil .nes. \" \")\n$ then\n$   write mod f$parse(srcfil,,,\"NAME\"), \".obj\"\n$   i = i + 1\n$   goto feloop\n$ endif\n$ return\n$!------------------------------------------------------------------------------\n$!\n$! Find current Zlib version number\n$!\n$FIND_VERSION:\n$ open/read h_in 'v_file'\n$hloop:\n$ read/end=hdone h_in rec\n$ rec = f$edit(rec,\"TRIM\")\n$ if (f$extract(0,1,rec) .nes. \"#\") then goto hloop\n$ rec = f$edit(rec - \"#\", \"TRIM\")\n$ if f$element(0,\" \",rec) .nes. \"define\" then goto hloop\n$ if f$element(1,\" \",rec) .eqs. v_string\n$ then\n$   version = 'f$element(2,\" \",rec)'\n$   goto hdone\n$ endif\n$ goto hloop\n$hdone:\n$ close h_in\n$ return\n$!------------------------------------------------------------------------------\n$!\n$CHECK_CONFIG:\n$!\n$ in_ldef = f$locate(cdef,libdefs)\n$ if (in_ldef .lt. f$length(libdefs))\n$ then\n$   write aconf \"#define ''cdef' 1\"\n$   libdefs = f$extract(0,in_ldef,libdefs) + -\n              f$extract(in_ldef + f$length(cdef) + 1, -\n                        f$length(libdefs) - in_ldef - f$length(cdef) - 1, -\n                        libdefs)\n$ else\n$   if (f$type('cdef') .eqs. \"INTEGER\")\n$   then\n$     write aconf \"#define ''cdef' \", 'cdef'\n$   else\n$     if (f$type('cdef') .eqs. \"STRING\")\n$     then\n$       write aconf \"#define ''cdef' \", \"\"\"\", '''cdef'', \"\"\"\"\n$     else\n$       gosub check_cc_def\n$     endif\n$   endif\n$ endif\n$ return\n$!------------------------------------------------------------------------------\n$!\n$! Check if this is a define relating to the properties of the C/C++\n$! compiler\n$!\n$ CHECK_CC_DEF:\n$ if (cdef .eqs. \"_LARGEFILE64_SOURCE\")\n$ then\n$   copy sys$input: 'tc'\n$   deck\n#include \"tconfig\"\n#define _LARGEFILE\n#include <stdio.h>\n\nint main(){\nFILE *fp;\n  fp = fopen(\"temp.txt\",\"r\");\n  fseeko(fp,1,SEEK_SET);\n  fclose(fp);\n}\n\n$   eod\n$   test_inv = false\n$   comm_h = false\n$   gosub cc_prop_check\n$   return\n$ endif\n$ write aconf \"/* \", line, \" */\"\n$ return\n$!------------------------------------------------------------------------------\n$!\n$! Check for properties of C/C++ compiler\n$!\n$! Version history\n$! 0.01 20031020 First version to receive a number\n$! 0.02 20031022 Added logic for defines with value\n$! 0.03 20040309 Make sure local config file gets not deleted\n$! 0.04 20041230 Also write include for configure run\n$! 0.05 20050103 Add processing of \"comment defines\"\n$CC_PROP_CHECK:\n$ cc_prop = true\n$ is_need = false\n$ is_need = (f$extract(0,4,cdef) .eqs. \"NEED\") .or. (test_inv .eq. true)\n$ if f$search(th) .eqs. \"\" then create 'th'\n$ set message/nofac/noident/nosever/notext\n$ on error then continue\n$ cc 'tmpnam'\n$ if .not. ($status)  then cc_prop = false\n$ on error then continue\n$! The headers might lie about the capabilities of the RTL\n$ link 'tmpnam',tmp.opt/opt\n$ if .not. ($status)  then cc_prop = false\n$ set message/fac/ident/sever/text\n$ on error then goto err_exit\n$ delete/nolog 'tmpnam'.*;*/exclude='th'\n$ if (cc_prop .and. .not. is_need) .or. -\n     (.not. cc_prop .and. is_need)\n$ then\n$   write sys$output \"Checking for ''cdef'... yes\"\n$   if f$type('cdef_val'_yes) .nes. \"\"\n$   then\n$     if f$type('cdef_val'_yes) .eqs. \"INTEGER\" -\n         then call write_config f$fao(\"#define !AS !UL\",cdef,'cdef_val'_yes)\n$     if f$type('cdef_val'_yes) .eqs. \"STRING\" -\n         then call write_config f$fao(\"#define !AS !AS\",cdef,'cdef_val'_yes)\n$   else\n$     call write_config f$fao(\"#define !AS 1\",cdef)\n$   endif\n$   if (cdef .eqs. \"HAVE_FSEEKO\") .or. (cdef .eqs. \"_LARGE_FILES\") .or. -\n       (cdef .eqs. \"_LARGEFILE64_SOURCE\") then -\n      call write_config f$string(\"#define _LARGEFILE 1\")\n$ else\n$   write sys$output \"Checking for ''cdef'... no\"\n$   if (comm_h)\n$   then\n      call write_config f$fao(\"/* !AS */\",line)\n$   else\n$     if f$type('cdef_val'_no) .nes. \"\"\n$     then\n$       if f$type('cdef_val'_no) .eqs. \"INTEGER\" -\n           then call write_config f$fao(\"#define !AS !UL\",cdef,'cdef_val'_no)\n$       if f$type('cdef_val'_no) .eqs. \"STRING\" -\n           then call write_config f$fao(\"#define !AS !AS\",cdef,'cdef_val'_no)\n$     else\n$       call write_config f$fao(\"#undef !AS\",cdef)\n$     endif\n$   endif\n$ endif\n$ return\n$!------------------------------------------------------------------------------\n$!\n$! Check for properties of C/C++ compiler with multiple result values\n$!\n$! Version history\n$! 0.01 20040127 First version\n$! 0.02 20050103 Reconcile changes from cc_prop up to version 0.05\n$CC_MPROP_CHECK:\n$ cc_prop = true\n$ i    = 1\n$ idel = 1\n$ MT_LOOP:\n$ if f$type(result_'i') .eqs. \"STRING\"\n$ then\n$   set message/nofac/noident/nosever/notext\n$   on error then continue\n$   cc 'tmpnam'_'i'\n$   if .not. ($status)  then cc_prop = false\n$   on error then continue\n$! The headers might lie about the capabilities of the RTL\n$   link 'tmpnam'_'i',tmp.opt/opt\n$   if .not. ($status)  then cc_prop = false\n$   set message/fac/ident/sever/text\n$   on error then goto err_exit\n$   delete/nolog 'tmpnam'_'i'.*;*\n$   if (cc_prop)\n$   then\n$     write sys$output \"Checking for ''cdef'... \", mdef_'i'\n$     if f$type(mdef_'i') .eqs. \"INTEGER\" -\n         then call write_config f$fao(\"#define !AS !UL\",cdef,mdef_'i')\n$     if f$type('cdef_val'_yes) .eqs. \"STRING\" -\n         then call write_config f$fao(\"#define !AS !AS\",cdef,mdef_'i')\n$     goto msym_clean\n$   else\n$     i = i + 1\n$     goto mt_loop\n$   endif\n$ endif\n$ write sys$output \"Checking for ''cdef'... no\"\n$ call write_config f$fao(\"#undef !AS\",cdef)\n$ MSYM_CLEAN:\n$ if (idel .le. msym_max)\n$ then\n$   delete/sym mdef_'idel'\n$   idel = idel + 1\n$   goto msym_clean\n$ endif\n$ return\n$!------------------------------------------------------------------------------\n$!\n$! Write configuration to both permanent and temporary config file\n$!\n$! Version history\n$! 0.01 20031029 First version to receive a number\n$!\n$WRITE_CONFIG: SUBROUTINE\n$  write aconf 'p1'\n$  open/append confh 'th'\n$  write confh 'p1'\n$  close confh\n$ENDSUBROUTINE\n$!------------------------------------------------------------------------------\n$!\n$! Analyze the project map file and create the symbol vector for a shareable\n$! image from it\n$!\n$! Version history\n$! 0.01 20120128 First version\n$! 0.02 20120226 Add pre-load logic\n$!\n$ MAP_2_SHOPT: Subroutine\n$!\n$ SAY := \"WRITE_ SYS$OUTPUT\"\n$!\n$ IF F$SEARCH(\"''P1'\") .EQS. \"\"\n$ THEN\n$    SAY \"MAP_2_SHOPT-E-NOSUCHFILE:  Error, inputfile ''p1' not available\"\n$    goto exit_m2s\n$ ENDIF\n$ IF \"''P2'\" .EQS. \"\"\n$ THEN\n$    SAY \"MAP_2_SHOPT:  Error, no output file provided\"\n$    goto exit_m2s\n$ ENDIF\n$!\n$ module1 = \"deflate#deflateEnd#deflateInit_#deflateParams#deflateSetDictionary\"\n$ module2 = \"gzclose#gzerror#gzgetc#gzgets#gzopen#gzprintf#gzputc#gzputs#gzread\"\n$ module3 = \"gzseek#gztell#inflate#inflateEnd#inflateInit_#inflateSetDictionary\"\n$ module4 = \"inflateSync#uncompress#zlibVersion#compress\"\n$ open/read map 'p1\n$ if axp .or. ia64\n$ then\n$     open/write aopt a.opt\n$     open/write bopt b.opt\n$     write aopt \" CASE_SENSITIVE=YES\"\n$     write bopt \"SYMBOL_VECTOR= (-\"\n$     mod_sym_num = 1\n$ MOD_SYM_LOOP:\n$     if f$type(module'mod_sym_num') .nes. \"\"\n$     then\n$         mod_in = 0\n$ MOD_SYM_IN:\n$         shared_proc = f$element(mod_in, \"#\", module'mod_sym_num')\n$         if shared_proc .nes. \"#\"\n$         then\n$             write aopt f$fao(\" symbol_vector=(!AS/!AS=PROCEDURE)\",-\n        \t\t       f$edit(shared_proc,\"upcase\"),shared_proc)\n$             write bopt f$fao(\"!AS=PROCEDURE,-\",shared_proc)\n$             mod_in = mod_in + 1\n$             goto mod_sym_in\n$         endif\n$         mod_sym_num = mod_sym_num + 1\n$         goto mod_sym_loop\n$     endif\n$MAP_LOOP:\n$     read/end=map_end map line\n$     if (f$locate(\"{\",line).lt. f$length(line)) .or. -\n         (f$locate(\"global:\", line) .lt. f$length(line))\n$     then\n$         proc = true\n$         goto map_loop\n$     endif\n$     if f$locate(\"}\",line).lt. f$length(line) then proc = false\n$     if f$locate(\"local:\", line) .lt. f$length(line) then proc = false\n$     if proc\n$     then\n$         shared_proc = f$edit(line,\"collapse\")\n$         chop_semi = f$locate(\";\", shared_proc)\n$         if chop_semi .lt. f$length(shared_proc) then -\n              shared_proc = f$extract(0, chop_semi, shared_proc)\n$         write aopt f$fao(\" symbol_vector=(!AS/!AS=PROCEDURE)\",-\n        \t\t\t f$edit(shared_proc,\"upcase\"),shared_proc)\n$         write bopt f$fao(\"!AS=PROCEDURE,-\",shared_proc)\n$     endif\n$     goto map_loop\n$MAP_END:\n$     close/nolog aopt\n$     close/nolog bopt\n$     open/append libopt 'p2'\n$     open/read aopt a.opt\n$     open/read bopt b.opt\n$ALOOP:\n$     read/end=aloop_end aopt line\n$     write libopt line\n$     goto aloop\n$ALOOP_END:\n$     close/nolog aopt\n$     sv = \"\"\n$BLOOP:\n$     read/end=bloop_end bopt svn\n$     if (svn.nes.\"\")\n$     then\n$        if (sv.nes.\"\") then write libopt sv\n$        sv = svn\n$     endif\n$     goto bloop\n$BLOOP_END:\n$     write libopt f$extract(0,f$length(sv)-2,sv), \"-\"\n$     write libopt \")\"\n$     close/nolog bopt\n$     delete/nolog/noconf a.opt;*,b.opt;*\n$ else\n$     if vax\n$     then\n$     open/append libopt 'p2'\n$     mod_sym_num = 1\n$ VMOD_SYM_LOOP:\n$     if f$type(module'mod_sym_num') .nes. \"\"\n$     then\n$         mod_in = 0\n$ VMOD_SYM_IN:\n$         shared_proc = f$element(mod_in, \"#\", module'mod_sym_num')\n$         if shared_proc .nes. \"#\"\n$         then\n$     \t      write libopt f$fao(\"UNIVERSAL=!AS\",-\n      \t  \t\t\t     f$edit(shared_proc,\"upcase\"))\n$             mod_in = mod_in + 1\n$             goto vmod_sym_in\n$         endif\n$         mod_sym_num = mod_sym_num + 1\n$         goto vmod_sym_loop\n$     endif\n$VMAP_LOOP:\n$     \t  read/end=vmap_end map line\n$     \t  if (f$locate(\"{\",line).lt. f$length(line)) .or. -\n   \t      (f$locate(\"global:\", line) .lt. f$length(line))\n$     \t  then\n$     \t      proc = true\n$     \t      goto vmap_loop\n$     \t  endif\n$     \t  if f$locate(\"}\",line).lt. f$length(line) then proc = false\n$     \t  if f$locate(\"local:\", line) .lt. f$length(line) then proc = false\n$     \t  if proc\n$     \t  then\n$     \t      shared_proc = f$edit(line,\"collapse\")\n$     \t      chop_semi = f$locate(\";\", shared_proc)\n$     \t      if chop_semi .lt. f$length(shared_proc) then -\n      \t  \t  shared_proc = f$extract(0, chop_semi, shared_proc)\n$     \t      write libopt f$fao(\"UNIVERSAL=!AS\",-\n      \t  \t\t\t     f$edit(shared_proc,\"upcase\"))\n$     \t  endif\n$     \t  goto vmap_loop\n$VMAP_END:\n$     else\n$         write sys$output \"Unknown Architecture (Not VAX, AXP, or IA64)\"\n$         write sys$output \"No options file created\"\n$     endif\n$ endif\n$ EXIT_M2S:\n$ close/nolog map\n$ close/nolog libopt\n$ endsubroutine\n"
        },
        {
          "name": "msdos",
          "type": "tree",
          "content": null
        },
        {
          "name": "nintendods",
          "type": "tree",
          "content": null
        },
        {
          "name": "old",
          "type": "tree",
          "content": null
        },
        {
          "name": "os400",
          "type": "tree",
          "content": null
        },
        {
          "name": "qnx",
          "type": "tree",
          "content": null
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "treebuild.xml",
          "type": "blob",
          "size": 3.0703125,
          "content": "<?xml version=\"1.0\" ?>\n<package name=\"zlib\" version=\"1.3.1.1\">\n    <library name=\"zlib\" dlversion=\"1.3.1.1\" dlname=\"z\">\n\t<property name=\"description\"> zip compression library </property>\n\t<property name=\"include-target-dir\" value=\"$(@PACKAGE/install-includedir)\" />\n\n\t<!-- fixme: not implemented yet -->\n\t<property name=\"compiler/c/inline\" value=\"yes\" />\n\n\t<include-file name=\"zlib.h\" scope=\"public\" mode=\"644\" />\n\t<include-file name=\"zconf.h\" scope=\"public\" mode=\"644\" />\n\n\t<source name=\"adler32.c\">\n\t    <depend name=\"zlib.h\" />\n\t    <depend name=\"zconf.h\" />\n\t</source>\n\t<source name=\"compress.c\">\n\t    <depend name=\"zlib.h\" />\n\t    <depend name=\"zconf.h\" />\n\t</source>\n\t<source name=\"crc32.c\">\n\t    <depend name=\"zlib.h\" />\n\t    <depend name=\"zconf.h\" />\n\t    <depend name=\"crc32.h\" />\n\t</source>\n\t<source name=\"gzclose.c\">\n\t    <depend name=\"zlib.h\" />\n\t    <depend name=\"zconf.h\" />\n\t    <depend name=\"gzguts.h\" />\n\t</source>\n\t<source name=\"gzlib.c\">\n\t    <depend name=\"zlib.h\" />\n\t    <depend name=\"zconf.h\" />\n\t    <depend name=\"gzguts.h\" />\n\t</source>\n\t<source name=\"gzread.c\">\n\t    <depend name=\"zlib.h\" />\n\t    <depend name=\"zconf.h\" />\n\t    <depend name=\"gzguts.h\" />\n\t</source>\n\t<source name=\"gzwrite.c\">\n\t    <depend name=\"zlib.h\" />\n\t    <depend name=\"zconf.h\" />\n\t    <depend name=\"gzguts.h\" />\n\t</source>\n\t<source name=\"uncompr.c\">\n\t    <depend name=\"zlib.h\" />\n\t    <depend name=\"zconf.h\" />\n\t</source>\n\t<source name=\"deflate.c\">\n\t    <depend name=\"zlib.h\" />\n\t    <depend name=\"zconf.h\" />\n\t    <depend name=\"zutil.h\" />\n\t    <depend name=\"deflate.h\" />\n\t</source>\n\t<source name=\"trees.c\">\n\t    <depend name=\"zlib.h\" />\n\t    <depend name=\"zconf.h\" />\n\t    <depend name=\"zutil.h\" />\n\t    <depend name=\"deflate.h\" />\n\t    <depend name=\"trees.h\" />\n\t</source>\n\t<source name=\"zutil.c\">\n\t    <depend name=\"zlib.h\" />\n\t    <depend name=\"zconf.h\" />\n\t    <depend name=\"zutil.h\" />\n\t</source>\n\t<source name=\"inflate.c\">\n\t    <depend name=\"zlib.h\" />\n\t    <depend name=\"zconf.h\" />\n\t    <depend name=\"zutil.h\" />\n\t    <depend name=\"inftrees.h\" />\n\t    <depend name=\"inflate.h\" />\n\t    <depend name=\"inffast.h\" />\n\t</source>\n\t<source name=\"infback.c\">\n\t    <depend name=\"zlib.h\" />\n\t    <depend name=\"zconf.h\" />\n\t    <depend name=\"zutil.h\" />\n\t    <depend name=\"inftrees.h\" />\n\t    <depend name=\"inflate.h\" />\n\t    <depend name=\"inffast.h\" />\n\t</source>\n\t<source name=\"inftrees.c\">\n\t    <depend name=\"zlib.h\" />\n\t    <depend name=\"zconf.h\" />\n\t    <depend name=\"zutil.h\" />\n\t    <depend name=\"inftrees.h\" />\n\t</source>\n\t<source name=\"inffast.c\">\n\t    <depend name=\"zlib.h\" />\n\t    <depend name=\"zconf.h\" />\n\t    <depend name=\"zutil.h\" />\n\t    <depend name=\"inftrees.h\" />\n\t    <depend name=\"inflate.h\" />\n\t    <depend name=\"inffast.h\" />\n\t</source>\n    </library>\n</package>\n\n<!--\nCFLAGS=-O\n#CFLAGS=-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7\n#CFLAGS=-g -DZLIB_DEBUG\n#CFLAGS=-O3 -Wall -Wwrite-strings -Wpointer-arith -Wconversion \\\n#           -Wstrict-prototypes -Wmissing-prototypes\n\n# OBJA =\n# to use the asm code: make OBJA=match.o\n#\nmatch.o: match.S\n\t$(CPP) match.S > _match.s\n\t$(CC) -c _match.s\n\tmv _match.o match.o\n\trm -f _match.s\n-->\n"
        },
        {
          "name": "trees.c",
          "type": "blob",
          "size": 40.046875,
          "content": "/* trees.c -- output deflated data using Huffman coding\n * Copyright (C) 1995-2024 Jean-loup Gailly\n * detect_data_type() function provided freely by Cosmin Truta, 2006\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n/*\n *  ALGORITHM\n *\n *      The \"deflation\" process uses several Huffman trees. The more\n *      common source values are represented by shorter bit sequences.\n *\n *      Each code tree is stored in a compressed form which is itself\n * a Huffman encoding of the lengths of all the code strings (in\n * ascending order by source values).  The actual code strings are\n * reconstructed from the lengths in the inflate process, as described\n * in the deflate specification.\n *\n *  REFERENCES\n *\n *      Deutsch, L.P.,\"'Deflate' Compressed Data Format Specification\".\n *      Available in ftp.uu.net:/pub/archiving/zip/doc/deflate-1.1.doc\n *\n *      Storer, James A.\n *          Data Compression:  Methods and Theory, pp. 49-50.\n *          Computer Science Press, 1988.  ISBN 0-7167-8156-5.\n *\n *      Sedgewick, R.\n *          Algorithms, p290.\n *          Addison-Wesley, 1983. ISBN 0-201-06672-6.\n */\n\n/* @(#) $Id$ */\n\n/* #define GEN_TREES_H */\n\n#include \"deflate.h\"\n\n#ifdef ZLIB_DEBUG\n#  include <ctype.h>\n#endif\n\n/* ===========================================================================\n * Constants\n */\n\n#define MAX_BL_BITS 7\n/* Bit length codes must not exceed MAX_BL_BITS bits */\n\n#define END_BLOCK 256\n/* end of block literal code */\n\n#define REP_3_6      16\n/* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\n#define REPZ_3_10    17\n/* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\n#define REPZ_11_138  18\n/* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\nlocal const int extra_lbits[LENGTH_CODES] /* extra bits for each length code */\n   = {0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0};\n\nlocal const int extra_dbits[D_CODES] /* extra bits for each distance code */\n   = {0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};\n\nlocal const int extra_blbits[BL_CODES]/* extra bits for each bit length code */\n   = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7};\n\nlocal const uch bl_order[BL_CODES]\n   = {16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15};\n/* The lengths of the bit length codes are sent in order of decreasing\n * probability, to avoid transmitting the lengths for unused bit length codes.\n */\n\n/* ===========================================================================\n * Local data. These are initialized only once.\n */\n\n#define DIST_CODE_LEN  512 /* see definition of array dist_code below */\n\n#if defined(GEN_TREES_H) || !defined(STDC)\n/* non ANSI compilers may not accept trees.h */\n\nlocal ct_data static_ltree[L_CODES+2];\n/* The static literal tree. Since the bit lengths are imposed, there is no\n * need for the L_CODES extra codes used during heap construction. However\n * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n * below).\n */\n\nlocal ct_data static_dtree[D_CODES];\n/* The static distance tree. (Actually a trivial tree since all codes use\n * 5 bits.)\n */\n\nuch _dist_code[DIST_CODE_LEN];\n/* Distance codes. The first 256 values correspond to the distances\n * 3 .. 258, the last 256 values correspond to the top 8 bits of\n * the 15 bit distances.\n */\n\nuch _length_code[MAX_MATCH-MIN_MATCH+1];\n/* length code for each normalized match length (0 == MIN_MATCH) */\n\nlocal int base_length[LENGTH_CODES];\n/* First normalized length for each code (0 = MIN_MATCH) */\n\nlocal int base_dist[D_CODES];\n/* First normalized distance for each code (0 = distance of 1) */\n\n#else\n#  include \"trees.h\"\n#endif /* GEN_TREES_H */\n\nstruct static_tree_desc_s {\n    const ct_data *static_tree;  /* static tree or NULL */\n    const intf *extra_bits;      /* extra bits for each code or NULL */\n    int     extra_base;          /* base index for extra_bits */\n    int     elems;               /* max number of elements in the tree */\n    int     max_length;          /* max bit length for the codes */\n};\n\n#ifdef NO_INIT_GLOBAL_POINTERS\n#  define TCONST\n#else\n#  define TCONST const\n#endif\n\nlocal TCONST static_tree_desc static_l_desc =\n{static_ltree, extra_lbits, LITERALS+1, L_CODES, MAX_BITS};\n\nlocal TCONST static_tree_desc static_d_desc =\n{static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS};\n\nlocal TCONST static_tree_desc static_bl_desc =\n{(const ct_data *)0, extra_blbits, 0,   BL_CODES, MAX_BL_BITS};\n\n/* ===========================================================================\n * Output a short LSB first on the stream.\n * IN assertion: there is enough room in pendingBuf.\n */\n#define put_short(s, w) { \\\n    put_byte(s, (uch)((w) & 0xff)); \\\n    put_byte(s, (uch)((ush)(w) >> 8)); \\\n}\n\n/* ===========================================================================\n * Reverse the first len bits of a code, using straightforward code (a faster\n * method would use a table)\n * IN assertion: 1 <= len <= 15\n */\nlocal unsigned bi_reverse(unsigned code, int len) {\n    register unsigned res = 0;\n    do {\n        res |= code & 1;\n        code >>= 1, res <<= 1;\n    } while (--len > 0);\n    return res >> 1;\n}\n\n/* ===========================================================================\n * Flush the bit buffer, keeping at most 7 bits in it.\n */\nlocal void bi_flush(deflate_state *s) {\n    if (s->bi_valid == 16) {\n        put_short(s, s->bi_buf);\n        s->bi_buf = 0;\n        s->bi_valid = 0;\n    } else if (s->bi_valid >= 8) {\n        put_byte(s, (Byte)s->bi_buf);\n        s->bi_buf >>= 8;\n        s->bi_valid -= 8;\n    }\n}\n\n/* ===========================================================================\n * Flush the bit buffer and align the output on a byte boundary\n */\nlocal void bi_windup(deflate_state *s) {\n    if (s->bi_valid > 8) {\n        put_short(s, s->bi_buf);\n    } else if (s->bi_valid > 0) {\n        put_byte(s, (Byte)s->bi_buf);\n    }\n    s->bi_used = ((s->bi_valid - 1) & 7) + 1;\n    s->bi_buf = 0;\n    s->bi_valid = 0;\n#ifdef ZLIB_DEBUG\n    s->bits_sent = (s->bits_sent + 7) & ~7;\n#endif\n}\n\n/* ===========================================================================\n * Generate the codes for a given tree and bit counts (which need not be\n * optimal).\n * IN assertion: the array bl_count contains the bit length statistics for\n * the given tree and the field len is set for all tree elements.\n * OUT assertion: the field code is set for all tree elements of non\n *     zero code length.\n */\nlocal void gen_codes(ct_data *tree, int max_code, ushf *bl_count) {\n    ush next_code[MAX_BITS+1]; /* next code value for each bit length */\n    unsigned code = 0;         /* running code value */\n    int bits;                  /* bit index */\n    int n;                     /* code index */\n\n    /* The distribution counts are first used to generate the code values\n     * without bit reversal.\n     */\n    for (bits = 1; bits <= MAX_BITS; bits++) {\n        code = (code + bl_count[bits - 1]) << 1;\n        next_code[bits] = (ush)code;\n    }\n    /* Check that the bit counts in bl_count are consistent. The last code\n     * must be all ones.\n     */\n    Assert (code + bl_count[MAX_BITS] - 1 == (1 << MAX_BITS) - 1,\n            \"inconsistent bit counts\");\n    Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n    for (n = 0;  n <= max_code; n++) {\n        int len = tree[n].Len;\n        if (len == 0) continue;\n        /* Now reverse the bits */\n        tree[n].Code = (ush)bi_reverse(next_code[len]++, len);\n\n        Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n            n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len] - 1));\n    }\n}\n\n#ifdef GEN_TREES_H\nlocal void gen_trees_header(void);\n#endif\n\n#ifndef ZLIB_DEBUG\n#  define send_code(s, c, tree) send_bits(s, tree[c].Code, tree[c].Len)\n   /* Send a code of the given tree. c and tree must not have side effects */\n\n#else /* !ZLIB_DEBUG */\n#  define send_code(s, c, tree) \\\n     { if (z_verbose>2) fprintf(stderr,\"\\ncd %3d \",(c)); \\\n       send_bits(s, tree[c].Code, tree[c].Len); }\n#endif\n\n/* ===========================================================================\n * Send a value on a given number of bits.\n * IN assertion: length <= 16 and value fits in length bits.\n */\n#ifdef ZLIB_DEBUG\nlocal void send_bits(deflate_state *s, int value, int length) {\n    Tracevv((stderr,\" l %2d v %4x \", length, value));\n    Assert(length > 0 && length <= 15, \"invalid length\");\n    s->bits_sent += (ulg)length;\n\n    /* If not enough room in bi_buf, use (valid) bits from bi_buf and\n     * (16 - bi_valid) bits from value, leaving (width - (16 - bi_valid))\n     * unused bits in value.\n     */\n    if (s->bi_valid > (int)Buf_size - length) {\n        s->bi_buf |= (ush)value << s->bi_valid;\n        put_short(s, s->bi_buf);\n        s->bi_buf = (ush)value >> (Buf_size - s->bi_valid);\n        s->bi_valid += length - Buf_size;\n    } else {\n        s->bi_buf |= (ush)value << s->bi_valid;\n        s->bi_valid += length;\n    }\n}\n#else /* !ZLIB_DEBUG */\n\n#define send_bits(s, value, length) \\\n{ int len = length;\\\n  if (s->bi_valid > (int)Buf_size - len) {\\\n    int val = (int)value;\\\n    s->bi_buf |= (ush)val << s->bi_valid;\\\n    put_short(s, s->bi_buf);\\\n    s->bi_buf = (ush)val >> (Buf_size - s->bi_valid);\\\n    s->bi_valid += len - Buf_size;\\\n  } else {\\\n    s->bi_buf |= (ush)(value) << s->bi_valid;\\\n    s->bi_valid += len;\\\n  }\\\n}\n#endif /* ZLIB_DEBUG */\n\n\n/* the arguments must not have side effects */\n\n/* ===========================================================================\n * Initialize the various 'constant' tables.\n */\nlocal void tr_static_init(void) {\n#if defined(GEN_TREES_H) || !defined(STDC)\n    static int static_init_done = 0;\n    int n;        /* iterates over tree elements */\n    int bits;     /* bit counter */\n    int length;   /* length value */\n    int code;     /* code value */\n    int dist;     /* distance index */\n    ush bl_count[MAX_BITS+1];\n    /* number of codes at each bit length for an optimal tree */\n\n    if (static_init_done) return;\n\n    /* For some embedded targets, global variables are not initialized: */\n#ifdef NO_INIT_GLOBAL_POINTERS\n    static_l_desc.static_tree = static_ltree;\n    static_l_desc.extra_bits = extra_lbits;\n    static_d_desc.static_tree = static_dtree;\n    static_d_desc.extra_bits = extra_dbits;\n    static_bl_desc.extra_bits = extra_blbits;\n#endif\n\n    /* Initialize the mapping length (0..255) -> length code (0..28) */\n    length = 0;\n    for (code = 0; code < LENGTH_CODES-1; code++) {\n        base_length[code] = length;\n        for (n = 0; n < (1 << extra_lbits[code]); n++) {\n            _length_code[length++] = (uch)code;\n        }\n    }\n    Assert (length == 256, \"tr_static_init: length != 256\");\n    /* Note that the length 255 (match length 258) can be represented\n     * in two different ways: code 284 + 5 bits or code 285, so we\n     * overwrite length_code[255] to use the best encoding:\n     */\n    _length_code[length - 1] = (uch)code;\n\n    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n    dist = 0;\n    for (code = 0 ; code < 16; code++) {\n        base_dist[code] = dist;\n        for (n = 0; n < (1 << extra_dbits[code]); n++) {\n            _dist_code[dist++] = (uch)code;\n        }\n    }\n    Assert (dist == 256, \"tr_static_init: dist != 256\");\n    dist >>= 7; /* from now on, all distances are divided by 128 */\n    for ( ; code < D_CODES; code++) {\n        base_dist[code] = dist << 7;\n        for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {\n            _dist_code[256 + dist++] = (uch)code;\n        }\n    }\n    Assert (dist == 256, \"tr_static_init: 256 + dist != 512\");\n\n    /* Construct the codes of the static literal tree */\n    for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;\n    n = 0;\n    while (n <= 143) static_ltree[n++].Len = 8, bl_count[8]++;\n    while (n <= 255) static_ltree[n++].Len = 9, bl_count[9]++;\n    while (n <= 279) static_ltree[n++].Len = 7, bl_count[7]++;\n    while (n <= 287) static_ltree[n++].Len = 8, bl_count[8]++;\n    /* Codes 286 and 287 do not exist, but we must include them in the\n     * tree construction to get a canonical Huffman tree (longest code\n     * all ones)\n     */\n    gen_codes((ct_data *)static_ltree, L_CODES+1, bl_count);\n\n    /* The static distance tree is trivial: */\n    for (n = 0; n < D_CODES; n++) {\n        static_dtree[n].Len = 5;\n        static_dtree[n].Code = bi_reverse((unsigned)n, 5);\n    }\n    static_init_done = 1;\n\n#  ifdef GEN_TREES_H\n    gen_trees_header();\n#  endif\n#endif /* defined(GEN_TREES_H) || !defined(STDC) */\n}\n\n/* ===========================================================================\n * Generate the file trees.h describing the static trees.\n */\n#ifdef GEN_TREES_H\n#  ifndef ZLIB_DEBUG\n#    include <stdio.h>\n#  endif\n\n#  define SEPARATOR(i, last, width) \\\n      ((i) == (last)? \"\\n};\\n\\n\" :    \\\n       ((i) % (width) == (width) - 1 ? \",\\n\" : \", \"))\n\nvoid gen_trees_header(void) {\n    FILE *header = fopen(\"trees.h\", \"w\");\n    int i;\n\n    Assert (header != NULL, \"Can't open trees.h\");\n    fprintf(header,\n            \"/* header created automatically with -DGEN_TREES_H */\\n\\n\");\n\n    fprintf(header, \"local const ct_data static_ltree[L_CODES+2] = {\\n\");\n    for (i = 0; i < L_CODES+2; i++) {\n        fprintf(header, \"{{%3u},{%3u}}%s\", static_ltree[i].Code,\n                static_ltree[i].Len, SEPARATOR(i, L_CODES+1, 5));\n    }\n\n    fprintf(header, \"local const ct_data static_dtree[D_CODES] = {\\n\");\n    for (i = 0; i < D_CODES; i++) {\n        fprintf(header, \"{{%2u},{%2u}}%s\", static_dtree[i].Code,\n                static_dtree[i].Len, SEPARATOR(i, D_CODES-1, 5));\n    }\n\n    fprintf(header, \"const uch ZLIB_INTERNAL _dist_code[DIST_CODE_LEN] = {\\n\");\n    for (i = 0; i < DIST_CODE_LEN; i++) {\n        fprintf(header, \"%2u%s\", _dist_code[i],\n                SEPARATOR(i, DIST_CODE_LEN-1, 20));\n    }\n\n    fprintf(header,\n        \"const uch ZLIB_INTERNAL _length_code[MAX_MATCH-MIN_MATCH+1]= {\\n\");\n    for (i = 0; i < MAX_MATCH-MIN_MATCH+1; i++) {\n        fprintf(header, \"%2u%s\", _length_code[i],\n                SEPARATOR(i, MAX_MATCH-MIN_MATCH, 20));\n    }\n\n    fprintf(header, \"local const int base_length[LENGTH_CODES] = {\\n\");\n    for (i = 0; i < LENGTH_CODES; i++) {\n        fprintf(header, \"%1u%s\", base_length[i],\n                SEPARATOR(i, LENGTH_CODES-1, 20));\n    }\n\n    fprintf(header, \"local const int base_dist[D_CODES] = {\\n\");\n    for (i = 0; i < D_CODES; i++) {\n        fprintf(header, \"%5u%s\", base_dist[i],\n                SEPARATOR(i, D_CODES-1, 10));\n    }\n\n    fclose(header);\n}\n#endif /* GEN_TREES_H */\n\n/* ===========================================================================\n * Initialize a new block.\n */\nlocal void init_block(deflate_state *s) {\n    int n; /* iterates over tree elements */\n\n    /* Initialize the trees. */\n    for (n = 0; n < L_CODES;  n++) s->dyn_ltree[n].Freq = 0;\n    for (n = 0; n < D_CODES;  n++) s->dyn_dtree[n].Freq = 0;\n    for (n = 0; n < BL_CODES; n++) s->bl_tree[n].Freq = 0;\n\n    s->dyn_ltree[END_BLOCK].Freq = 1;\n    s->opt_len = s->static_len = 0L;\n    s->sym_next = s->matches = 0;\n}\n\n/* ===========================================================================\n * Initialize the tree data structures for a new zlib stream.\n */\nvoid ZLIB_INTERNAL _tr_init(deflate_state *s) {\n    tr_static_init();\n\n    s->l_desc.dyn_tree = s->dyn_ltree;\n    s->l_desc.stat_desc = &static_l_desc;\n\n    s->d_desc.dyn_tree = s->dyn_dtree;\n    s->d_desc.stat_desc = &static_d_desc;\n\n    s->bl_desc.dyn_tree = s->bl_tree;\n    s->bl_desc.stat_desc = &static_bl_desc;\n\n    s->bi_buf = 0;\n    s->bi_valid = 0;\n    s->bi_used = 0;\n#ifdef ZLIB_DEBUG\n    s->compressed_len = 0L;\n    s->bits_sent = 0L;\n#endif\n\n    /* Initialize the first block of the first file: */\n    init_block(s);\n}\n\n#define SMALLEST 1\n/* Index within the heap array of least frequent node in the Huffman tree */\n\n\n/* ===========================================================================\n * Remove the smallest element from the heap and recreate the heap with\n * one less element. Updates heap and heap_len.\n */\n#define pqremove(s, tree, top) \\\n{\\\n    top = s->heap[SMALLEST]; \\\n    s->heap[SMALLEST] = s->heap[s->heap_len--]; \\\n    pqdownheap(s, tree, SMALLEST); \\\n}\n\n/* ===========================================================================\n * Compares to subtrees, using the tree depth as tie breaker when\n * the subtrees have equal frequency. This minimizes the worst case length.\n */\n#define smaller(tree, n, m, depth) \\\n   (tree[n].Freq < tree[m].Freq || \\\n   (tree[n].Freq == tree[m].Freq && depth[n] <= depth[m]))\n\n/* ===========================================================================\n * Restore the heap property by moving down the tree starting at node k,\n * exchanging a node with the smallest of its two sons if necessary, stopping\n * when the heap property is re-established (each father smaller than its\n * two sons).\n */\nlocal void pqdownheap(deflate_state *s, ct_data *tree, int k) {\n    int v = s->heap[k];\n    int j = k << 1;  /* left son of k */\n    while (j <= s->heap_len) {\n        /* Set j to the smallest of the two sons: */\n        if (j < s->heap_len &&\n            smaller(tree, s->heap[j + 1], s->heap[j], s->depth)) {\n            j++;\n        }\n        /* Exit if v is smaller than both sons */\n        if (smaller(tree, v, s->heap[j], s->depth)) break;\n\n        /* Exchange v with the smallest son */\n        s->heap[k] = s->heap[j];  k = j;\n\n        /* And continue down the tree, setting j to the left son of k */\n        j <<= 1;\n    }\n    s->heap[k] = v;\n}\n\n/* ===========================================================================\n * Compute the optimal bit lengths for a tree and update the total bit length\n * for the current block.\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\n *    above are the tree nodes sorted by increasing frequency.\n * OUT assertions: the field len is set to the optimal bit length, the\n *     array bl_count contains the frequencies for each bit length.\n *     The length opt_len is updated; static_len is also updated if stree is\n *     not null.\n */\nlocal void gen_bitlen(deflate_state *s, tree_desc *desc) {\n    ct_data *tree        = desc->dyn_tree;\n    int max_code         = desc->max_code;\n    const ct_data *stree = desc->stat_desc->static_tree;\n    const intf *extra    = desc->stat_desc->extra_bits;\n    int base             = desc->stat_desc->extra_base;\n    int max_length       = desc->stat_desc->max_length;\n    int h;              /* heap index */\n    int n, m;           /* iterate over the tree elements */\n    int bits;           /* bit length */\n    int xbits;          /* extra bits */\n    ush f;              /* frequency */\n    int overflow = 0;   /* number of elements with bit length too large */\n\n    for (bits = 0; bits <= MAX_BITS; bits++) s->bl_count[bits] = 0;\n\n    /* In a first pass, compute the optimal bit lengths (which may\n     * overflow in the case of the bit length tree).\n     */\n    tree[s->heap[s->heap_max]].Len = 0; /* root of the heap */\n\n    for (h = s->heap_max + 1; h < HEAP_SIZE; h++) {\n        n = s->heap[h];\n        bits = tree[tree[n].Dad].Len + 1;\n        if (bits > max_length) bits = max_length, overflow++;\n        tree[n].Len = (ush)bits;\n        /* We overwrite tree[n].Dad which is no longer needed */\n\n        if (n > max_code) continue; /* not a leaf node */\n\n        s->bl_count[bits]++;\n        xbits = 0;\n        if (n >= base) xbits = extra[n - base];\n        f = tree[n].Freq;\n        s->opt_len += (ulg)f * (unsigned)(bits + xbits);\n        if (stree) s->static_len += (ulg)f * (unsigned)(stree[n].Len + xbits);\n    }\n    if (overflow == 0) return;\n\n    Tracev((stderr,\"\\nbit length overflow\\n\"));\n    /* This happens for example on obj2 and pic of the Calgary corpus */\n\n    /* Find the first bit length which could increase: */\n    do {\n        bits = max_length - 1;\n        while (s->bl_count[bits] == 0) bits--;\n        s->bl_count[bits]--;        /* move one leaf down the tree */\n        s->bl_count[bits + 1] += 2; /* move one overflow item as its brother */\n        s->bl_count[max_length]--;\n        /* The brother of the overflow item also moves one step up,\n         * but this does not affect bl_count[max_length]\n         */\n        overflow -= 2;\n    } while (overflow > 0);\n\n    /* Now recompute all bit lengths, scanning in increasing frequency.\n     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n     * lengths instead of fixing only the wrong ones. This idea is taken\n     * from 'ar' written by Haruhiko Okumura.)\n     */\n    for (bits = max_length; bits != 0; bits--) {\n        n = s->bl_count[bits];\n        while (n != 0) {\n            m = s->heap[--h];\n            if (m > max_code) continue;\n            if ((unsigned) tree[m].Len != (unsigned) bits) {\n                Tracev((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n                s->opt_len += ((ulg)bits - tree[m].Len) * tree[m].Freq;\n                tree[m].Len = (ush)bits;\n            }\n            n--;\n        }\n    }\n}\n\n#ifdef DUMP_BL_TREE\n#  include <stdio.h>\n#endif\n\n/* ===========================================================================\n * Construct one Huffman tree and assigns the code bit strings and lengths.\n * Update the total bit length for the current block.\n * IN assertion: the field freq is set for all tree elements.\n * OUT assertions: the fields len and code are set to the optimal bit length\n *     and corresponding code. The length opt_len is updated; static_len is\n *     also updated if stree is not null. The field max_code is set.\n */\nlocal void build_tree(deflate_state *s, tree_desc *desc) {\n    ct_data *tree         = desc->dyn_tree;\n    const ct_data *stree  = desc->stat_desc->static_tree;\n    int elems             = desc->stat_desc->elems;\n    int n, m;          /* iterate over heap elements */\n    int max_code = -1; /* largest code with non zero frequency */\n    int node;          /* new node being created */\n\n    /* Construct the initial heap, with least frequent element in\n     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n + 1].\n     * heap[0] is not used.\n     */\n    s->heap_len = 0, s->heap_max = HEAP_SIZE;\n\n    for (n = 0; n < elems; n++) {\n        if (tree[n].Freq != 0) {\n            s->heap[++(s->heap_len)] = max_code = n;\n            s->depth[n] = 0;\n        } else {\n            tree[n].Len = 0;\n        }\n    }\n\n    /* The pkzip format requires that at least one distance code exists,\n     * and that at least one bit should be sent even if there is only one\n     * possible code. So to avoid special checks later on we force at least\n     * two codes of non zero frequency.\n     */\n    while (s->heap_len < 2) {\n        node = s->heap[++(s->heap_len)] = (max_code < 2 ? ++max_code : 0);\n        tree[node].Freq = 1;\n        s->depth[node] = 0;\n        s->opt_len--; if (stree) s->static_len -= stree[node].Len;\n        /* node is 0 or 1 so it does not have extra bits */\n    }\n    desc->max_code = max_code;\n\n    /* The elements heap[heap_len/2 + 1 .. heap_len] are leaves of the tree,\n     * establish sub-heaps of increasing lengths:\n     */\n    for (n = s->heap_len/2; n >= 1; n--) pqdownheap(s, tree, n);\n\n    /* Construct the Huffman tree by repeatedly combining the least two\n     * frequent nodes.\n     */\n    node = elems;              /* next internal node of the tree */\n    do {\n        pqremove(s, tree, n);  /* n = node of least frequency */\n        m = s->heap[SMALLEST]; /* m = node of next least frequency */\n\n        s->heap[--(s->heap_max)] = n; /* keep the nodes sorted by frequency */\n        s->heap[--(s->heap_max)] = m;\n\n        /* Create a new node father of n and m */\n        tree[node].Freq = tree[n].Freq + tree[m].Freq;\n        s->depth[node] = (uch)((s->depth[n] >= s->depth[m] ?\n                                s->depth[n] : s->depth[m]) + 1);\n        tree[n].Dad = tree[m].Dad = (ush)node;\n#ifdef DUMP_BL_TREE\n        if (tree == s->bl_tree) {\n            fprintf(stderr,\"\\nnode %d(%d), sons %d(%d) %d(%d)\",\n                    node, tree[node].Freq, n, tree[n].Freq, m, tree[m].Freq);\n        }\n#endif\n        /* and insert the new node in the heap */\n        s->heap[SMALLEST] = node++;\n        pqdownheap(s, tree, SMALLEST);\n\n    } while (s->heap_len >= 2);\n\n    s->heap[--(s->heap_max)] = s->heap[SMALLEST];\n\n    /* At this point, the fields freq and dad are set. We can now\n     * generate the bit lengths.\n     */\n    gen_bitlen(s, (tree_desc *)desc);\n\n    /* The field len is now set, we can generate the bit codes */\n    gen_codes ((ct_data *)tree, max_code, s->bl_count);\n}\n\n/* ===========================================================================\n * Scan a literal or distance tree to determine the frequencies of the codes\n * in the bit length tree.\n */\nlocal void scan_tree(deflate_state *s, ct_data *tree, int max_code) {\n    int n;                     /* iterates over all tree elements */\n    int prevlen = -1;          /* last emitted length */\n    int curlen;                /* length of current code */\n    int nextlen = tree[0].Len; /* length of next code */\n    int count = 0;             /* repeat count of the current code */\n    int max_count = 7;         /* max repeat count */\n    int min_count = 4;         /* min repeat count */\n\n    if (nextlen == 0) max_count = 138, min_count = 3;\n    tree[max_code + 1].Len = (ush)0xffff; /* guard */\n\n    for (n = 0; n <= max_code; n++) {\n        curlen = nextlen; nextlen = tree[n + 1].Len;\n        if (++count < max_count && curlen == nextlen) {\n            continue;\n        } else if (count < min_count) {\n            s->bl_tree[curlen].Freq += (ush)count;\n        } else if (curlen != 0) {\n            if (curlen != prevlen) s->bl_tree[curlen].Freq++;\n            s->bl_tree[REP_3_6].Freq++;\n        } else if (count <= 10) {\n            s->bl_tree[REPZ_3_10].Freq++;\n        } else {\n            s->bl_tree[REPZ_11_138].Freq++;\n        }\n        count = 0; prevlen = curlen;\n        if (nextlen == 0) {\n            max_count = 138, min_count = 3;\n        } else if (curlen == nextlen) {\n            max_count = 6, min_count = 3;\n        } else {\n            max_count = 7, min_count = 4;\n        }\n    }\n}\n\n/* ===========================================================================\n * Send a literal or distance tree in compressed form, using the codes in\n * bl_tree.\n */\nlocal void send_tree(deflate_state *s, ct_data *tree, int max_code) {\n    int n;                     /* iterates over all tree elements */\n    int prevlen = -1;          /* last emitted length */\n    int curlen;                /* length of current code */\n    int nextlen = tree[0].Len; /* length of next code */\n    int count = 0;             /* repeat count of the current code */\n    int max_count = 7;         /* max repeat count */\n    int min_count = 4;         /* min repeat count */\n\n    /* tree[max_code + 1].Len = -1; */  /* guard already set */\n    if (nextlen == 0) max_count = 138, min_count = 3;\n\n    for (n = 0; n <= max_code; n++) {\n        curlen = nextlen; nextlen = tree[n + 1].Len;\n        if (++count < max_count && curlen == nextlen) {\n            continue;\n        } else if (count < min_count) {\n            do { send_code(s, curlen, s->bl_tree); } while (--count != 0);\n\n        } else if (curlen != 0) {\n            if (curlen != prevlen) {\n                send_code(s, curlen, s->bl_tree); count--;\n            }\n            Assert(count >= 3 && count <= 6, \" 3_6?\");\n            send_code(s, REP_3_6, s->bl_tree); send_bits(s, count - 3, 2);\n\n        } else if (count <= 10) {\n            send_code(s, REPZ_3_10, s->bl_tree); send_bits(s, count - 3, 3);\n\n        } else {\n            send_code(s, REPZ_11_138, s->bl_tree); send_bits(s, count - 11, 7);\n        }\n        count = 0; prevlen = curlen;\n        if (nextlen == 0) {\n            max_count = 138, min_count = 3;\n        } else if (curlen == nextlen) {\n            max_count = 6, min_count = 3;\n        } else {\n            max_count = 7, min_count = 4;\n        }\n    }\n}\n\n/* ===========================================================================\n * Construct the Huffman tree for the bit lengths and return the index in\n * bl_order of the last bit length code to send.\n */\nlocal int build_bl_tree(deflate_state *s) {\n    int max_blindex;  /* index of last bit length code of non zero freq */\n\n    /* Determine the bit length frequencies for literal and distance trees */\n    scan_tree(s, (ct_data *)s->dyn_ltree, s->l_desc.max_code);\n    scan_tree(s, (ct_data *)s->dyn_dtree, s->d_desc.max_code);\n\n    /* Build the bit length tree: */\n    build_tree(s, (tree_desc *)(&(s->bl_desc)));\n    /* opt_len now includes the length of the tree representations, except the\n     * lengths of the bit lengths codes and the 5 + 5 + 4 bits for the counts.\n     */\n\n    /* Determine the number of bit length codes to send. The pkzip format\n     * requires that at least 4 bit length codes be sent. (appnote.txt says\n     * 3 but the actual value used is 4.)\n     */\n    for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {\n        if (s->bl_tree[bl_order[max_blindex]].Len != 0) break;\n    }\n    /* Update opt_len to include the bit length tree and counts */\n    s->opt_len += 3*((ulg)max_blindex + 1) + 5 + 5 + 4;\n    Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n            s->opt_len, s->static_len));\n\n    return max_blindex;\n}\n\n/* ===========================================================================\n * Send the header for a block using dynamic Huffman trees: the counts, the\n * lengths of the bit length codes, the literal tree and the distance tree.\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n */\nlocal void send_all_trees(deflate_state *s, int lcodes, int dcodes,\n                          int blcodes) {\n    int rank;                    /* index in bl_order */\n\n    Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n    Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n            \"too many codes\");\n    Tracev((stderr, \"\\nbl counts: \"));\n    send_bits(s, lcodes - 257, 5);  /* not +255 as stated in appnote.txt */\n    send_bits(s, dcodes - 1,   5);\n    send_bits(s, blcodes - 4,  4);  /* not -3 as stated in appnote.txt */\n    for (rank = 0; rank < blcodes; rank++) {\n        Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n        send_bits(s, s->bl_tree[bl_order[rank]].Len, 3);\n    }\n    Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n\n    send_tree(s, (ct_data *)s->dyn_ltree, lcodes - 1);  /* literal tree */\n    Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n\n    send_tree(s, (ct_data *)s->dyn_dtree, dcodes - 1);  /* distance tree */\n    Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n}\n\n/* ===========================================================================\n * Send a stored block\n */\nvoid ZLIB_INTERNAL _tr_stored_block(deflate_state *s, charf *buf,\n                                    ulg stored_len, int last) {\n    send_bits(s, (STORED_BLOCK<<1) + last, 3);  /* send block type */\n    bi_windup(s);        /* align on byte boundary */\n    put_short(s, (ush)stored_len);\n    put_short(s, (ush)~stored_len);\n    if (stored_len)\n        zmemcpy(s->pending_buf + s->pending, (Bytef *)buf, stored_len);\n    s->pending += stored_len;\n#ifdef ZLIB_DEBUG\n    s->compressed_len = (s->compressed_len + 3 + 7) & (ulg)~7L;\n    s->compressed_len += (stored_len + 4) << 3;\n    s->bits_sent += 2*16;\n    s->bits_sent += stored_len << 3;\n#endif\n}\n\n/* ===========================================================================\n * Flush the bits in the bit buffer to pending output (leaves at most 7 bits)\n */\nvoid ZLIB_INTERNAL _tr_flush_bits(deflate_state *s) {\n    bi_flush(s);\n}\n\n/* ===========================================================================\n * Send one empty static block to give enough lookahead for inflate.\n * This takes 10 bits, of which 7 may remain in the bit buffer.\n */\nvoid ZLIB_INTERNAL _tr_align(deflate_state *s) {\n    send_bits(s, STATIC_TREES<<1, 3);\n    send_code(s, END_BLOCK, static_ltree);\n#ifdef ZLIB_DEBUG\n    s->compressed_len += 10L; /* 3 for block type, 7 for EOB */\n#endif\n    bi_flush(s);\n}\n\n/* ===========================================================================\n * Send the block data compressed using the given Huffman trees\n */\nlocal void compress_block(deflate_state *s, const ct_data *ltree,\n                          const ct_data *dtree) {\n    unsigned dist;      /* distance of matched string */\n    int lc;             /* match length or unmatched char (if dist == 0) */\n    unsigned sx = 0;    /* running index in symbol buffers */\n    unsigned code;      /* the code to send */\n    int extra;          /* number of extra bits to send */\n\n    if (s->sym_next != 0) do {\n#ifdef LIT_MEM\n        dist = s->d_buf[sx];\n        lc = s->l_buf[sx++];\n#else\n        dist = s->sym_buf[sx++] & 0xff;\n        dist += (unsigned)(s->sym_buf[sx++] & 0xff) << 8;\n        lc = s->sym_buf[sx++];\n#endif\n        if (dist == 0) {\n            send_code(s, lc, ltree); /* send a literal byte */\n            Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n        } else {\n            /* Here, lc is the match length - MIN_MATCH */\n            code = _length_code[lc];\n            send_code(s, code + LITERALS + 1, ltree);   /* send length code */\n            extra = extra_lbits[code];\n            if (extra != 0) {\n                lc -= base_length[code];\n                send_bits(s, lc, extra);       /* send the extra length bits */\n            }\n            dist--; /* dist is now the match distance - 1 */\n            code = d_code(dist);\n            Assert (code < D_CODES, \"bad d_code\");\n\n            send_code(s, code, dtree);       /* send the distance code */\n            extra = extra_dbits[code];\n            if (extra != 0) {\n                dist -= (unsigned)base_dist[code];\n                send_bits(s, dist, extra);   /* send the extra distance bits */\n            }\n        } /* literal or match pair ? */\n\n        /* Check for no overlay of pending_buf on needed symbols */\n#ifdef LIT_MEM\n        Assert(s->pending < 2 * (s->lit_bufsize + sx), \"pendingBuf overflow\");\n#else\n        Assert(s->pending < s->lit_bufsize + sx, \"pendingBuf overflow\");\n#endif\n\n    } while (sx < s->sym_next);\n\n    send_code(s, END_BLOCK, ltree);\n}\n\n/* ===========================================================================\n * Check if the data type is TEXT or BINARY, using the following algorithm:\n * - TEXT if the two conditions below are satisfied:\n *    a) There are no non-portable control characters belonging to the\n *       \"block list\" (0..6, 14..25, 28..31).\n *    b) There is at least one printable character belonging to the\n *       \"allow list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n * - BINARY otherwise.\n * - The following partially-portable control characters form a\n *   \"gray list\" that is ignored in this detection algorithm:\n *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n * IN assertion: the fields Freq of dyn_ltree are set.\n */\nlocal int detect_data_type(deflate_state *s) {\n    /* block_mask is the bit mask of block-listed bytes\n     * set bits 0..6, 14..25, and 28..31\n     * 0xf3ffc07f = binary 11110011111111111100000001111111\n     */\n    unsigned long block_mask = 0xf3ffc07fUL;\n    int n;\n\n    /* Check for non-textual (\"block-listed\") bytes. */\n    for (n = 0; n <= 31; n++, block_mask >>= 1)\n        if ((block_mask & 1) && (s->dyn_ltree[n].Freq != 0))\n            return Z_BINARY;\n\n    /* Check for textual (\"allow-listed\") bytes. */\n    if (s->dyn_ltree[9].Freq != 0 || s->dyn_ltree[10].Freq != 0\n            || s->dyn_ltree[13].Freq != 0)\n        return Z_TEXT;\n    for (n = 32; n < LITERALS; n++)\n        if (s->dyn_ltree[n].Freq != 0)\n            return Z_TEXT;\n\n    /* There are no \"block-listed\" or \"allow-listed\" bytes:\n     * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n     */\n    return Z_BINARY;\n}\n\n/* ===========================================================================\n * Determine the best encoding for the current block: dynamic trees, static\n * trees or store, and write out the encoded block.\n */\nvoid ZLIB_INTERNAL _tr_flush_block(deflate_state *s, charf *buf,\n                                   ulg stored_len, int last) {\n    ulg opt_lenb, static_lenb; /* opt_len and static_len in bytes */\n    int max_blindex = 0;  /* index of last bit length code of non zero freq */\n\n    /* Build the Huffman trees unless a stored block is forced */\n    if (s->level > 0) {\n\n        /* Check if the file is binary or text */\n        if (s->strm->data_type == Z_UNKNOWN)\n            s->strm->data_type = detect_data_type(s);\n\n        /* Construct the literal and distance trees */\n        build_tree(s, (tree_desc *)(&(s->l_desc)));\n        Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n                s->static_len));\n\n        build_tree(s, (tree_desc *)(&(s->d_desc)));\n        Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n                s->static_len));\n        /* At this point, opt_len and static_len are the total bit lengths of\n         * the compressed block data, excluding the tree representations.\n         */\n\n        /* Build the bit length tree for the above two trees, and get the index\n         * in bl_order of the last bit length code to send.\n         */\n        max_blindex = build_bl_tree(s);\n\n        /* Determine the best encoding. Compute the block lengths in bytes. */\n        opt_lenb = (s->opt_len + 3 + 7) >> 3;\n        static_lenb = (s->static_len + 3 + 7) >> 3;\n\n        Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n                opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n                s->sym_next / 3));\n\n#ifndef FORCE_STATIC\n        if (static_lenb <= opt_lenb || s->strategy == Z_FIXED)\n#endif\n            opt_lenb = static_lenb;\n\n    } else {\n        Assert(buf != (char*)0, \"lost buf\");\n        opt_lenb = static_lenb = stored_len + 5; /* force a stored block */\n    }\n\n#ifdef FORCE_STORED\n    if (buf != (char*)0) { /* force stored block */\n#else\n    if (stored_len + 4 <= opt_lenb && buf != (char*)0) {\n                       /* 4: two words for the lengths */\n#endif\n        /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n         * Otherwise we can't have processed more than WSIZE input bytes since\n         * the last block flush, because compression would have been\n         * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n         * transform a block into a stored block.\n         */\n        _tr_stored_block(s, buf, stored_len, last);\n\n    } else if (static_lenb == opt_lenb) {\n        send_bits(s, (STATIC_TREES<<1) + last, 3);\n        compress_block(s, (const ct_data *)static_ltree,\n                       (const ct_data *)static_dtree);\n#ifdef ZLIB_DEBUG\n        s->compressed_len += 3 + s->static_len;\n#endif\n    } else {\n        send_bits(s, (DYN_TREES<<1) + last, 3);\n        send_all_trees(s, s->l_desc.max_code + 1, s->d_desc.max_code + 1,\n                       max_blindex + 1);\n        compress_block(s, (const ct_data *)s->dyn_ltree,\n                       (const ct_data *)s->dyn_dtree);\n#ifdef ZLIB_DEBUG\n        s->compressed_len += 3 + s->opt_len;\n#endif\n    }\n    Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n    /* The above check is made mod 2^32, for files larger than 512 MB\n     * and uLong implemented on 32 bits.\n     */\n    init_block(s);\n\n    if (last) {\n        bi_windup(s);\n#ifdef ZLIB_DEBUG\n        s->compressed_len += 7;  /* align on byte boundary */\n#endif\n    }\n    Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len >> 3,\n           s->compressed_len - 7*last));\n}\n\n/* ===========================================================================\n * Save the match info and tally the frequency counts. Return true if\n * the current block must be flushed.\n */\nint ZLIB_INTERNAL _tr_tally(deflate_state *s, unsigned dist, unsigned lc) {\n#ifdef LIT_MEM\n    s->d_buf[s->sym_next] = (ush)dist;\n    s->l_buf[s->sym_next++] = (uch)lc;\n#else\n    s->sym_buf[s->sym_next++] = (uch)dist;\n    s->sym_buf[s->sym_next++] = (uch)(dist >> 8);\n    s->sym_buf[s->sym_next++] = (uch)lc;\n#endif\n    if (dist == 0) {\n        /* lc is the unmatched char */\n        s->dyn_ltree[lc].Freq++;\n    } else {\n        s->matches++;\n        /* Here, lc is the match length - MIN_MATCH */\n        dist--;             /* dist = match distance - 1 */\n        Assert((ush)dist < (ush)MAX_DIST(s) &&\n               (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n               (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n\n        s->dyn_ltree[_length_code[lc] + LITERALS + 1].Freq++;\n        s->dyn_dtree[d_code(dist)].Freq++;\n    }\n    return (s->sym_next == s->sym_end);\n}\n"
        },
        {
          "name": "trees.h",
          "type": "blob",
          "size": 8.2734375,
          "content": "/* header created automatically with -DGEN_TREES_H */\n\nlocal const ct_data static_ltree[L_CODES+2] = {\n{{ 12},{  8}}, {{140},{  8}}, {{ 76},{  8}}, {{204},{  8}}, {{ 44},{  8}},\n{{172},{  8}}, {{108},{  8}}, {{236},{  8}}, {{ 28},{  8}}, {{156},{  8}},\n{{ 92},{  8}}, {{220},{  8}}, {{ 60},{  8}}, {{188},{  8}}, {{124},{  8}},\n{{252},{  8}}, {{  2},{  8}}, {{130},{  8}}, {{ 66},{  8}}, {{194},{  8}},\n{{ 34},{  8}}, {{162},{  8}}, {{ 98},{  8}}, {{226},{  8}}, {{ 18},{  8}},\n{{146},{  8}}, {{ 82},{  8}}, {{210},{  8}}, {{ 50},{  8}}, {{178},{  8}},\n{{114},{  8}}, {{242},{  8}}, {{ 10},{  8}}, {{138},{  8}}, {{ 74},{  8}},\n{{202},{  8}}, {{ 42},{  8}}, {{170},{  8}}, {{106},{  8}}, {{234},{  8}},\n{{ 26},{  8}}, {{154},{  8}}, {{ 90},{  8}}, {{218},{  8}}, {{ 58},{  8}},\n{{186},{  8}}, {{122},{  8}}, {{250},{  8}}, {{  6},{  8}}, {{134},{  8}},\n{{ 70},{  8}}, {{198},{  8}}, {{ 38},{  8}}, {{166},{  8}}, {{102},{  8}},\n{{230},{  8}}, {{ 22},{  8}}, {{150},{  8}}, {{ 86},{  8}}, {{214},{  8}},\n{{ 54},{  8}}, {{182},{  8}}, {{118},{  8}}, {{246},{  8}}, {{ 14},{  8}},\n{{142},{  8}}, {{ 78},{  8}}, {{206},{  8}}, {{ 46},{  8}}, {{174},{  8}},\n{{110},{  8}}, {{238},{  8}}, {{ 30},{  8}}, {{158},{  8}}, {{ 94},{  8}},\n{{222},{  8}}, {{ 62},{  8}}, {{190},{  8}}, {{126},{  8}}, {{254},{  8}},\n{{  1},{  8}}, {{129},{  8}}, {{ 65},{  8}}, {{193},{  8}}, {{ 33},{  8}},\n{{161},{  8}}, {{ 97},{  8}}, {{225},{  8}}, {{ 17},{  8}}, {{145},{  8}},\n{{ 81},{  8}}, {{209},{  8}}, {{ 49},{  8}}, {{177},{  8}}, {{113},{  8}},\n{{241},{  8}}, {{  9},{  8}}, {{137},{  8}}, {{ 73},{  8}}, {{201},{  8}},\n{{ 41},{  8}}, {{169},{  8}}, {{105},{  8}}, {{233},{  8}}, {{ 25},{  8}},\n{{153},{  8}}, {{ 89},{  8}}, {{217},{  8}}, {{ 57},{  8}}, {{185},{  8}},\n{{121},{  8}}, {{249},{  8}}, {{  5},{  8}}, {{133},{  8}}, {{ 69},{  8}},\n{{197},{  8}}, {{ 37},{  8}}, {{165},{  8}}, {{101},{  8}}, {{229},{  8}},\n{{ 21},{  8}}, {{149},{  8}}, {{ 85},{  8}}, {{213},{  8}}, {{ 53},{  8}},\n{{181},{  8}}, {{117},{  8}}, {{245},{  8}}, {{ 13},{  8}}, {{141},{  8}},\n{{ 77},{  8}}, {{205},{  8}}, {{ 45},{  8}}, {{173},{  8}}, {{109},{  8}},\n{{237},{  8}}, {{ 29},{  8}}, {{157},{  8}}, {{ 93},{  8}}, {{221},{  8}},\n{{ 61},{  8}}, {{189},{  8}}, {{125},{  8}}, {{253},{  8}}, {{ 19},{  9}},\n{{275},{  9}}, {{147},{  9}}, {{403},{  9}}, {{ 83},{  9}}, {{339},{  9}},\n{{211},{  9}}, {{467},{  9}}, {{ 51},{  9}}, {{307},{  9}}, {{179},{  9}},\n{{435},{  9}}, {{115},{  9}}, {{371},{  9}}, {{243},{  9}}, {{499},{  9}},\n{{ 11},{  9}}, {{267},{  9}}, {{139},{  9}}, {{395},{  9}}, {{ 75},{  9}},\n{{331},{  9}}, {{203},{  9}}, {{459},{  9}}, {{ 43},{  9}}, {{299},{  9}},\n{{171},{  9}}, {{427},{  9}}, {{107},{  9}}, {{363},{  9}}, {{235},{  9}},\n{{491},{  9}}, {{ 27},{  9}}, {{283},{  9}}, {{155},{  9}}, {{411},{  9}},\n{{ 91},{  9}}, {{347},{  9}}, {{219},{  9}}, {{475},{  9}}, {{ 59},{  9}},\n{{315},{  9}}, {{187},{  9}}, {{443},{  9}}, {{123},{  9}}, {{379},{  9}},\n{{251},{  9}}, {{507},{  9}}, {{  7},{  9}}, {{263},{  9}}, {{135},{  9}},\n{{391},{  9}}, {{ 71},{  9}}, {{327},{  9}}, {{199},{  9}}, {{455},{  9}},\n{{ 39},{  9}}, {{295},{  9}}, {{167},{  9}}, {{423},{  9}}, {{103},{  9}},\n{{359},{  9}}, {{231},{  9}}, {{487},{  9}}, {{ 23},{  9}}, {{279},{  9}},\n{{151},{  9}}, {{407},{  9}}, {{ 87},{  9}}, {{343},{  9}}, {{215},{  9}},\n{{471},{  9}}, {{ 55},{  9}}, {{311},{  9}}, {{183},{  9}}, {{439},{  9}},\n{{119},{  9}}, {{375},{  9}}, {{247},{  9}}, {{503},{  9}}, {{ 15},{  9}},\n{{271},{  9}}, {{143},{  9}}, {{399},{  9}}, {{ 79},{  9}}, {{335},{  9}},\n{{207},{  9}}, {{463},{  9}}, {{ 47},{  9}}, {{303},{  9}}, {{175},{  9}},\n{{431},{  9}}, {{111},{  9}}, {{367},{  9}}, {{239},{  9}}, {{495},{  9}},\n{{ 31},{  9}}, {{287},{  9}}, {{159},{  9}}, {{415},{  9}}, {{ 95},{  9}},\n{{351},{  9}}, {{223},{  9}}, {{479},{  9}}, {{ 63},{  9}}, {{319},{  9}},\n{{191},{  9}}, {{447},{  9}}, {{127},{  9}}, {{383},{  9}}, {{255},{  9}},\n{{511},{  9}}, {{  0},{  7}}, {{ 64},{  7}}, {{ 32},{  7}}, {{ 96},{  7}},\n{{ 16},{  7}}, {{ 80},{  7}}, {{ 48},{  7}}, {{112},{  7}}, {{  8},{  7}},\n{{ 72},{  7}}, {{ 40},{  7}}, {{104},{  7}}, {{ 24},{  7}}, {{ 88},{  7}},\n{{ 56},{  7}}, {{120},{  7}}, {{  4},{  7}}, {{ 68},{  7}}, {{ 36},{  7}},\n{{100},{  7}}, {{ 20},{  7}}, {{ 84},{  7}}, {{ 52},{  7}}, {{116},{  7}},\n{{  3},{  8}}, {{131},{  8}}, {{ 67},{  8}}, {{195},{  8}}, {{ 35},{  8}},\n{{163},{  8}}, {{ 99},{  8}}, {{227},{  8}}\n};\n\nlocal const ct_data static_dtree[D_CODES] = {\n{{ 0},{ 5}}, {{16},{ 5}}, {{ 8},{ 5}}, {{24},{ 5}}, {{ 4},{ 5}},\n{{20},{ 5}}, {{12},{ 5}}, {{28},{ 5}}, {{ 2},{ 5}}, {{18},{ 5}},\n{{10},{ 5}}, {{26},{ 5}}, {{ 6},{ 5}}, {{22},{ 5}}, {{14},{ 5}},\n{{30},{ 5}}, {{ 1},{ 5}}, {{17},{ 5}}, {{ 9},{ 5}}, {{25},{ 5}},\n{{ 5},{ 5}}, {{21},{ 5}}, {{13},{ 5}}, {{29},{ 5}}, {{ 3},{ 5}},\n{{19},{ 5}}, {{11},{ 5}}, {{27},{ 5}}, {{ 7},{ 5}}, {{23},{ 5}}\n};\n\nconst uch ZLIB_INTERNAL _dist_code[DIST_CODE_LEN] = {\n 0,  1,  2,  3,  4,  4,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  8,\n 8,  8,  8,  8,  9,  9,  9,  9,  9,  9,  9,  9, 10, 10, 10, 10, 10, 10, 10, 10,\n10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13,\n13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15,\n15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,  0,  0, 16, 17,\n18, 18, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22,\n23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,\n26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27,\n27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,\n27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,\n28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,\n28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,\n28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,\n29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,\n29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,\n29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29\n};\n\nconst uch ZLIB_INTERNAL _length_code[MAX_MATCH-MIN_MATCH+1]= {\n 0,  1,  2,  3,  4,  5,  6,  7,  8,  8,  9,  9, 10, 10, 11, 11, 12, 12, 12, 12,\n13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16,\n17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19,\n19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22,\n22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23,\n23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26,\n26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,\n26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,\n27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28\n};\n\nlocal const int base_length[LENGTH_CODES] = {\n0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56,\n64, 80, 96, 112, 128, 160, 192, 224, 0\n};\n\nlocal const int base_dist[D_CODES] = {\n    0,     1,     2,     3,     4,     6,     8,    12,    16,    24,\n   32,    48,    64,    96,   128,   192,   256,   384,   512,   768,\n 1024,  1536,  2048,  3072,  4096,  6144,  8192, 12288, 16384, 24576\n};\n\n"
        },
        {
          "name": "uncompr.c",
          "type": "blob",
          "size": 2.8427734375,
          "content": "/* uncompr.c -- decompress a memory buffer\n * Copyright (C) 1995-2003, 2010, 2014, 2016 Jean-loup Gailly, Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n/* @(#) $Id$ */\n\n#define ZLIB_INTERNAL\n#include \"zlib.h\"\n\n/* ===========================================================================\n     Decompresses the source buffer into the destination buffer.  *sourceLen is\n   the byte length of the source buffer. Upon entry, *destLen is the total size\n   of the destination buffer, which must be large enough to hold the entire\n   uncompressed data. (The size of the uncompressed data must have been saved\n   previously by the compressor and transmitted to the decompressor by some\n   mechanism outside the scope of this compression library.) Upon exit,\n   *destLen is the size of the decompressed data and *sourceLen is the number\n   of source bytes consumed. Upon return, source + *sourceLen points to the\n   first unused input byte.\n\n     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not enough\n   memory, Z_BUF_ERROR if there was not enough room in the output buffer, or\n   Z_DATA_ERROR if the input data was corrupted, including if the input data is\n   an incomplete zlib stream.\n*/\nint ZEXPORT uncompress2(Bytef *dest, uLongf *destLen, const Bytef *source,\n                        uLong *sourceLen) {\n    z_stream stream;\n    int err;\n    const uInt max = (uInt)-1;\n    uLong len, left;\n    Byte buf[1];    /* for detection of incomplete stream when *destLen == 0 */\n\n    len = *sourceLen;\n    if (*destLen) {\n        left = *destLen;\n        *destLen = 0;\n    }\n    else {\n        left = 1;\n        dest = buf;\n    }\n\n    stream.next_in = (z_const Bytef *)source;\n    stream.avail_in = 0;\n    stream.zalloc = (alloc_func)0;\n    stream.zfree = (free_func)0;\n    stream.opaque = (voidpf)0;\n\n    err = inflateInit(&stream);\n    if (err != Z_OK) return err;\n\n    stream.next_out = dest;\n    stream.avail_out = 0;\n\n    do {\n        if (stream.avail_out == 0) {\n            stream.avail_out = left > (uLong)max ? max : (uInt)left;\n            left -= stream.avail_out;\n        }\n        if (stream.avail_in == 0) {\n            stream.avail_in = len > (uLong)max ? max : (uInt)len;\n            len -= stream.avail_in;\n        }\n        err = inflate(&stream, Z_NO_FLUSH);\n    } while (err == Z_OK);\n\n    *sourceLen -= len + stream.avail_in;\n    if (dest != buf)\n        *destLen = stream.total_out;\n    else if (stream.total_out && err == Z_BUF_ERROR)\n        left = 1;\n\n    inflateEnd(&stream);\n    return err == Z_STREAM_END ? Z_OK :\n           err == Z_NEED_DICT ? Z_DATA_ERROR  :\n           err == Z_BUF_ERROR && left + stream.avail_out ? Z_DATA_ERROR :\n           err;\n}\n\nint ZEXPORT uncompress(Bytef *dest, uLongf *destLen, const Bytef *source,\n                       uLong sourceLen) {\n    return uncompress2(dest, destLen, source, &sourceLen);\n}\n"
        },
        {
          "name": "watcom",
          "type": "tree",
          "content": null
        },
        {
          "name": "win32",
          "type": "tree",
          "content": null
        },
        {
          "name": "zconf.h",
          "type": "blob",
          "size": 16.22265625,
          "content": "/* zconf.h -- configuration of the zlib compression library\n * Copyright (C) 1995-2024 Jean-loup Gailly, Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n/* @(#) $Id$ */\n\n#ifndef ZCONF_H\n#define ZCONF_H\n\n/*\n * If you *really* need a unique prefix for all types and library functions,\n * compile with -DZ_PREFIX. The \"standard\" zlib should be compiled without it.\n * Even better than compiling with -DZ_PREFIX would be to use configure to set\n * this permanently in zconf.h using \"./configure --zprefix\".\n */\n#ifdef Z_PREFIX     /* may be set to #if 1 by ./configure */\n#  define Z_PREFIX_SET\n\n/* all linked symbols and init macros */\n#  define _dist_code            z__dist_code\n#  define _length_code          z__length_code\n#  define _tr_align             z__tr_align\n#  define _tr_flush_bits        z__tr_flush_bits\n#  define _tr_flush_block       z__tr_flush_block\n#  define _tr_init              z__tr_init\n#  define _tr_stored_block      z__tr_stored_block\n#  define _tr_tally             z__tr_tally\n#  define adler32               z_adler32\n#  define adler32_combine       z_adler32_combine\n#  define adler32_combine64     z_adler32_combine64\n#  define adler32_z             z_adler32_z\n#  ifndef Z_SOLO\n#    define compress              z_compress\n#    define compress2             z_compress2\n#    define compressBound         z_compressBound\n#  endif\n#  define crc32                 z_crc32\n#  define crc32_combine         z_crc32_combine\n#  define crc32_combine64       z_crc32_combine64\n#  define crc32_combine_gen     z_crc32_combine_gen\n#  define crc32_combine_gen64   z_crc32_combine_gen64\n#  define crc32_combine_op      z_crc32_combine_op\n#  define crc32_z               z_crc32_z\n#  define deflate               z_deflate\n#  define deflateBound          z_deflateBound\n#  define deflateCopy           z_deflateCopy\n#  define deflateEnd            z_deflateEnd\n#  define deflateGetDictionary  z_deflateGetDictionary\n#  define deflateInit           z_deflateInit\n#  define deflateInit2          z_deflateInit2\n#  define deflateInit2_         z_deflateInit2_\n#  define deflateInit_          z_deflateInit_\n#  define deflateParams         z_deflateParams\n#  define deflatePending        z_deflatePending\n#  define deflatePrime          z_deflatePrime\n#  define deflateReset          z_deflateReset\n#  define deflateResetKeep      z_deflateResetKeep\n#  define deflateSetDictionary  z_deflateSetDictionary\n#  define deflateSetHeader      z_deflateSetHeader\n#  define deflateTune           z_deflateTune\n#  define deflateUsed           z_deflateUsed\n#  define deflate_copyright     z_deflate_copyright\n#  define get_crc_table         z_get_crc_table\n#  ifndef Z_SOLO\n#    define gz_error              z_gz_error\n#    define gz_intmax             z_gz_intmax\n#    define gz_strwinerror        z_gz_strwinerror\n#    define gzbuffer              z_gzbuffer\n#    define gzclearerr            z_gzclearerr\n#    define gzclose               z_gzclose\n#    define gzclose_r             z_gzclose_r\n#    define gzclose_w             z_gzclose_w\n#    define gzdirect              z_gzdirect\n#    define gzdopen               z_gzdopen\n#    define gzeof                 z_gzeof\n#    define gzerror               z_gzerror\n#    define gzflush               z_gzflush\n#    define gzfread               z_gzfread\n#    define gzfwrite              z_gzfwrite\n#    define gzgetc                z_gzgetc\n#    define gzgetc_               z_gzgetc_\n#    define gzgets                z_gzgets\n#    define gzoffset              z_gzoffset\n#    define gzoffset64            z_gzoffset64\n#    define gzopen                z_gzopen\n#    define gzopen64              z_gzopen64\n#    ifdef _WIN32\n#      define gzopen_w              z_gzopen_w\n#    endif\n#    define gzprintf              z_gzprintf\n#    define gzputc                z_gzputc\n#    define gzputs                z_gzputs\n#    define gzread                z_gzread\n#    define gzrewind              z_gzrewind\n#    define gzseek                z_gzseek\n#    define gzseek64              z_gzseek64\n#    define gzsetparams           z_gzsetparams\n#    define gztell                z_gztell\n#    define gztell64              z_gztell64\n#    define gzungetc              z_gzungetc\n#    define gzvprintf             z_gzvprintf\n#    define gzwrite               z_gzwrite\n#  endif\n#  define inflate               z_inflate\n#  define inflateBack           z_inflateBack\n#  define inflateBackEnd        z_inflateBackEnd\n#  define inflateBackInit       z_inflateBackInit\n#  define inflateBackInit_      z_inflateBackInit_\n#  define inflateCodesUsed      z_inflateCodesUsed\n#  define inflateCopy           z_inflateCopy\n#  define inflateEnd            z_inflateEnd\n#  define inflateGetDictionary  z_inflateGetDictionary\n#  define inflateGetHeader      z_inflateGetHeader\n#  define inflateInit           z_inflateInit\n#  define inflateInit2          z_inflateInit2\n#  define inflateInit2_         z_inflateInit2_\n#  define inflateInit_          z_inflateInit_\n#  define inflateMark           z_inflateMark\n#  define inflatePrime          z_inflatePrime\n#  define inflateReset          z_inflateReset\n#  define inflateReset2         z_inflateReset2\n#  define inflateResetKeep      z_inflateResetKeep\n#  define inflateSetDictionary  z_inflateSetDictionary\n#  define inflateSync           z_inflateSync\n#  define inflateSyncPoint      z_inflateSyncPoint\n#  define inflateUndermine      z_inflateUndermine\n#  define inflateValidate       z_inflateValidate\n#  define inflate_copyright     z_inflate_copyright\n#  define inflate_fast          z_inflate_fast\n#  define inflate_table         z_inflate_table\n#  ifndef Z_SOLO\n#    define uncompress            z_uncompress\n#    define uncompress2           z_uncompress2\n#  endif\n#  define zError                z_zError\n#  ifndef Z_SOLO\n#    define zcalloc               z_zcalloc\n#    define zcfree                z_zcfree\n#  endif\n#  define zlibCompileFlags      z_zlibCompileFlags\n#  define zlibVersion           z_zlibVersion\n\n/* all zlib typedefs in zlib.h and zconf.h */\n#  define Byte                  z_Byte\n#  define Bytef                 z_Bytef\n#  define alloc_func            z_alloc_func\n#  define charf                 z_charf\n#  define free_func             z_free_func\n#  ifndef Z_SOLO\n#    define gzFile                z_gzFile\n#  endif\n#  define gz_header             z_gz_header\n#  define gz_headerp            z_gz_headerp\n#  define in_func               z_in_func\n#  define intf                  z_intf\n#  define out_func              z_out_func\n#  define uInt                  z_uInt\n#  define uIntf                 z_uIntf\n#  define uLong                 z_uLong\n#  define uLongf                z_uLongf\n#  define voidp                 z_voidp\n#  define voidpc                z_voidpc\n#  define voidpf                z_voidpf\n\n/* all zlib structs in zlib.h and zconf.h */\n#  define gz_header_s           z_gz_header_s\n#  define internal_state        z_internal_state\n\n#endif\n\n#if defined(__MSDOS__) && !defined(MSDOS)\n#  define MSDOS\n#endif\n#if (defined(OS_2) || defined(__OS2__)) && !defined(OS2)\n#  define OS2\n#endif\n#if defined(_WINDOWS) && !defined(WINDOWS)\n#  define WINDOWS\n#endif\n#if defined(_WIN32) || defined(_WIN32_WCE) || defined(__WIN32__)\n#  ifndef WIN32\n#    define WIN32\n#  endif\n#endif\n#if (defined(MSDOS) || defined(OS2) || defined(WINDOWS)) && !defined(WIN32)\n#  if !defined(__GNUC__) && !defined(__FLAT__) && !defined(__386__)\n#    ifndef SYS16BIT\n#      define SYS16BIT\n#    endif\n#  endif\n#endif\n\n/*\n * Compile with -DMAXSEG_64K if the alloc function cannot allocate more\n * than 64k bytes at a time (needed on systems with 16-bit int).\n */\n#ifdef SYS16BIT\n#  define MAXSEG_64K\n#endif\n#ifdef MSDOS\n#  define UNALIGNED_OK\n#endif\n\n#ifdef __STDC_VERSION__\n#  ifndef STDC\n#    define STDC\n#  endif\n#  if __STDC_VERSION__ >= 199901L\n#    ifndef STDC99\n#      define STDC99\n#    endif\n#  endif\n#endif\n#if !defined(STDC) && (defined(__STDC__) || defined(__cplusplus))\n#  define STDC\n#endif\n#if !defined(STDC) && (defined(__GNUC__) || defined(__BORLANDC__))\n#  define STDC\n#endif\n#if !defined(STDC) && (defined(MSDOS) || defined(WINDOWS) || defined(WIN32))\n#  define STDC\n#endif\n#if !defined(STDC) && (defined(OS2) || defined(__HOS_AIX__))\n#  define STDC\n#endif\n\n#if defined(__OS400__) && !defined(STDC)    /* iSeries (formerly AS/400). */\n#  define STDC\n#endif\n\n#ifndef STDC\n#  ifndef const /* cannot use !defined(STDC) && !defined(const) on Mac */\n#    define const       /* note: need a more gentle solution here */\n#  endif\n#endif\n\n#ifndef z_const\n#  ifdef ZLIB_CONST\n#    define z_const const\n#  else\n#    define z_const\n#  endif\n#endif\n\n#ifdef Z_SOLO\n#  ifdef _WIN64\n     typedef unsigned long long z_size_t;\n#  else\n     typedef unsigned long z_size_t;\n#  endif\n#else\n#  define z_longlong long long\n#  if defined(NO_SIZE_T)\n     typedef unsigned NO_SIZE_T z_size_t;\n#  elif defined(STDC)\n#    include <stddef.h>\n     typedef size_t z_size_t;\n#  else\n     typedef unsigned long z_size_t;\n#  endif\n#  undef z_longlong\n#endif\n\n/* Maximum value for memLevel in deflateInit2 */\n#ifndef MAX_MEM_LEVEL\n#  ifdef MAXSEG_64K\n#    define MAX_MEM_LEVEL 8\n#  else\n#    define MAX_MEM_LEVEL 9\n#  endif\n#endif\n\n/* Maximum value for windowBits in deflateInit2 and inflateInit2.\n * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files\n * created by gzip. (Files created by minigzip can still be extracted by\n * gzip.)\n */\n#ifndef MAX_WBITS\n#  define MAX_WBITS   15 /* 32K LZ77 window */\n#endif\n\n/* The memory requirements for deflate are (in bytes):\n            (1 << (windowBits+2)) +  (1 << (memLevel+9))\n that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)\n plus a few kilobytes for small objects. For example, if you want to reduce\n the default memory requirements from 256K to 128K, compile with\n     make CFLAGS=\"-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7\"\n Of course this will generally degrade compression (there's no free lunch).\n\n   The memory requirements for inflate are (in bytes) 1 << windowBits\n that is, 32K for windowBits=15 (default value) plus about 7 kilobytes\n for small objects.\n*/\n\n                        /* Type declarations */\n\n#ifndef OF /* function prototypes */\n#  ifdef STDC\n#    define OF(args)  args\n#  else\n#    define OF(args)  ()\n#  endif\n#endif\n\n/* The following definitions for FAR are needed only for MSDOS mixed\n * model programming (small or medium model with some far allocations).\n * This was tested only with MSC; for other MSDOS compilers you may have\n * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,\n * just define FAR to be empty.\n */\n#ifdef SYS16BIT\n#  if defined(M_I86SM) || defined(M_I86MM)\n     /* MSC small or medium model */\n#    define SMALL_MEDIUM\n#    ifdef _MSC_VER\n#      define FAR _far\n#    else\n#      define FAR far\n#    endif\n#  endif\n#  if (defined(__SMALL__) || defined(__MEDIUM__))\n     /* Turbo C small or medium model */\n#    define SMALL_MEDIUM\n#    ifdef __BORLANDC__\n#      define FAR _far\n#    else\n#      define FAR far\n#    endif\n#  endif\n#endif\n\n#if defined(WINDOWS) || defined(WIN32)\n   /* If building or using zlib as a DLL, define ZLIB_DLL.\n    * This is not mandatory, but it offers a little performance increase.\n    */\n#  ifdef ZLIB_DLL\n#    if defined(WIN32) && (!defined(__BORLANDC__) || (__BORLANDC__ >= 0x500))\n#      ifdef ZLIB_INTERNAL\n#        define ZEXTERN extern __declspec(dllexport)\n#      else\n#        define ZEXTERN extern __declspec(dllimport)\n#      endif\n#    endif\n#  endif  /* ZLIB_DLL */\n   /* If building or using zlib with the WINAPI/WINAPIV calling convention,\n    * define ZLIB_WINAPI.\n    * Caution: the standard ZLIB1.DLL is NOT compiled using ZLIB_WINAPI.\n    */\n#  ifdef ZLIB_WINAPI\n#    ifdef FAR\n#      undef FAR\n#    endif\n#    ifndef WIN32_LEAN_AND_MEAN\n#      define WIN32_LEAN_AND_MEAN\n#    endif\n#    include <windows.h>\n     /* No need for _export, use ZLIB.DEF instead. */\n     /* For complete Windows compatibility, use WINAPI, not __stdcall. */\n#    define ZEXPORT WINAPI\n#    ifdef WIN32\n#      define ZEXPORTVA WINAPIV\n#    else\n#      define ZEXPORTVA FAR CDECL\n#    endif\n#  endif\n#endif\n\n#if defined (__BEOS__)\n#  ifdef ZLIB_DLL\n#    ifdef ZLIB_INTERNAL\n#      define ZEXPORT   __declspec(dllexport)\n#      define ZEXPORTVA __declspec(dllexport)\n#    else\n#      define ZEXPORT   __declspec(dllimport)\n#      define ZEXPORTVA __declspec(dllimport)\n#    endif\n#  endif\n#endif\n\n#ifndef ZEXTERN\n#  define ZEXTERN extern\n#endif\n#ifndef ZEXPORT\n#  define ZEXPORT\n#endif\n#ifndef ZEXPORTVA\n#  define ZEXPORTVA\n#endif\n\n#ifndef FAR\n#  define FAR\n#endif\n\n#if !defined(__MACTYPES__)\ntypedef unsigned char  Byte;  /* 8 bits */\n#endif\ntypedef unsigned int   uInt;  /* 16 bits or more */\ntypedef unsigned long  uLong; /* 32 bits or more */\n\n#ifdef SMALL_MEDIUM\n   /* Borland C/C++ and some old MSC versions ignore FAR inside typedef */\n#  define Bytef Byte FAR\n#else\n   typedef Byte  FAR Bytef;\n#endif\ntypedef char  FAR charf;\ntypedef int   FAR intf;\ntypedef uInt  FAR uIntf;\ntypedef uLong FAR uLongf;\n\n#ifdef STDC\n   typedef void const *voidpc;\n   typedef void FAR   *voidpf;\n   typedef void       *voidp;\n#else\n   typedef Byte const *voidpc;\n   typedef Byte FAR   *voidpf;\n   typedef Byte       *voidp;\n#endif\n\n#if !defined(Z_U4) && !defined(Z_SOLO) && defined(STDC)\n#  include <limits.h>\n#  if (UINT_MAX == 0xffffffffUL)\n#    define Z_U4 unsigned\n#  elif (ULONG_MAX == 0xffffffffUL)\n#    define Z_U4 unsigned long\n#  elif (USHRT_MAX == 0xffffffffUL)\n#    define Z_U4 unsigned short\n#  endif\n#endif\n\n#ifdef Z_U4\n   typedef Z_U4 z_crc_t;\n#else\n   typedef unsigned long z_crc_t;\n#endif\n\n#ifdef HAVE_UNISTD_H    /* may be set to #if 1 by ./configure */\n#  define Z_HAVE_UNISTD_H\n#endif\n\n#ifdef HAVE_STDARG_H    /* may be set to #if 1 by ./configure */\n#  define Z_HAVE_STDARG_H\n#endif\n\n#ifdef STDC\n#  ifndef Z_SOLO\n#    include <sys/types.h>      /* for off_t */\n#  endif\n#endif\n\n#if defined(STDC) || defined(Z_HAVE_STDARG_H)\n#  ifndef Z_SOLO\n#    include <stdarg.h>         /* for va_list */\n#  endif\n#endif\n\n#ifdef _WIN32\n#  ifndef Z_SOLO\n#    include <stddef.h>         /* for wchar_t */\n#  endif\n#endif\n\n/* a little trick to accommodate both \"#define _LARGEFILE64_SOURCE\" and\n * \"#define _LARGEFILE64_SOURCE 1\" as requesting 64-bit operations, (even\n * though the former does not conform to the LFS document), but considering\n * both \"#undef _LARGEFILE64_SOURCE\" and \"#define _LARGEFILE64_SOURCE 0\" as\n * equivalently requesting no 64-bit operations\n */\n#if defined(_LARGEFILE64_SOURCE) && -_LARGEFILE64_SOURCE - -1 == 1\n#  undef _LARGEFILE64_SOURCE\n#endif\n\n#ifndef Z_HAVE_UNISTD_H\n#  if defined(__WATCOMC__) || defined(__GO32__) || \\\n      (defined(_LARGEFILE64_SOURCE) && !defined(_WIN32))\n#    define Z_HAVE_UNISTD_H\n#  endif\n#endif\n#ifndef Z_SOLO\n#  if defined(Z_HAVE_UNISTD_H)\n#    include <unistd.h>         /* for SEEK_*, off_t, and _LFS64_LARGEFILE */\n#    ifdef VMS\n#      include <unixio.h>       /* for off_t */\n#    endif\n#    ifndef z_off_t\n#      define z_off_t off_t\n#    endif\n#  endif\n#endif\n\n#if defined(_LFS64_LARGEFILE) && _LFS64_LARGEFILE-0\n#  define Z_LFS64\n#endif\n\n#if defined(_LARGEFILE64_SOURCE) && defined(Z_LFS64)\n#  define Z_LARGE64\n#endif\n\n#if defined(_FILE_OFFSET_BITS) && _FILE_OFFSET_BITS-0 == 64 && defined(Z_LFS64)\n#  define Z_WANT64\n#endif\n\n#if !defined(SEEK_SET) && !defined(Z_SOLO)\n#  define SEEK_SET        0       /* Seek from beginning of file.  */\n#  define SEEK_CUR        1       /* Seek from current position.  */\n#  define SEEK_END        2       /* Set file pointer to EOF plus \"offset\" */\n#endif\n\n#ifndef z_off_t\n#  define z_off_t long long\n#endif\n\n#if !defined(_WIN32) && defined(Z_LARGE64)\n#  define z_off64_t off64_t\n#elif defined(__MINGW32__)\n#  define z_off64_t long long\n#elif defined(_WIN32) && !defined(__GNUC__)\n#  define z_off64_t __int64\n#elif defined(__GO32__)\n#  define z_off64_t offset_t\n#else\n#  define z_off64_t z_off_t\n#endif\n\n/* MVS linker does not support external names larger than 8 bytes */\n#if defined(__MVS__)\n  #pragma map(deflateInit_,\"DEIN\")\n  #pragma map(deflateInit2_,\"DEIN2\")\n  #pragma map(deflateEnd,\"DEEND\")\n  #pragma map(deflateBound,\"DEBND\")\n  #pragma map(inflateInit_,\"ININ\")\n  #pragma map(inflateInit2_,\"ININ2\")\n  #pragma map(inflateEnd,\"INEND\")\n  #pragma map(inflateSync,\"INSY\")\n  #pragma map(inflateSetDictionary,\"INSEDI\")\n  #pragma map(compressBound,\"CMBND\")\n  #pragma map(inflate_table,\"INTABL\")\n  #pragma map(inflate_fast,\"INFA\")\n  #pragma map(inflate_copyright,\"INCOPY\")\n#endif\n\n#endif /* ZCONF_H */\n"
        },
        {
          "name": "zconf.h.cmakein",
          "type": "blob",
          "size": 16.2724609375,
          "content": "/* zconf.h -- configuration of the zlib compression library\n * Copyright (C) 1995-2024 Jean-loup Gailly, Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n/* @(#) $Id$ */\n\n#ifndef ZCONF_H\n#define ZCONF_H\n#cmakedefine Z_PREFIX\n#cmakedefine Z_HAVE_UNISTD_H\n\n/*\n * If you *really* need a unique prefix for all types and library functions,\n * compile with -DZ_PREFIX. The \"standard\" zlib should be compiled without it.\n * Even better than compiling with -DZ_PREFIX would be to use configure to set\n * this permanently in zconf.h using \"./configure --zprefix\".\n */\n#ifdef Z_PREFIX     /* may be set to #if 1 by ./configure */\n#  define Z_PREFIX_SET\n\n/* all linked symbols and init macros */\n#  define _dist_code            z__dist_code\n#  define _length_code          z__length_code\n#  define _tr_align             z__tr_align\n#  define _tr_flush_bits        z__tr_flush_bits\n#  define _tr_flush_block       z__tr_flush_block\n#  define _tr_init              z__tr_init\n#  define _tr_stored_block      z__tr_stored_block\n#  define _tr_tally             z__tr_tally\n#  define adler32               z_adler32\n#  define adler32_combine       z_adler32_combine\n#  define adler32_combine64     z_adler32_combine64\n#  define adler32_z             z_adler32_z\n#  ifndef Z_SOLO\n#    define compress              z_compress\n#    define compress2             z_compress2\n#    define compressBound         z_compressBound\n#  endif\n#  define crc32                 z_crc32\n#  define crc32_combine         z_crc32_combine\n#  define crc32_combine64       z_crc32_combine64\n#  define crc32_combine_gen     z_crc32_combine_gen\n#  define crc32_combine_gen64   z_crc32_combine_gen64\n#  define crc32_combine_op      z_crc32_combine_op\n#  define crc32_z               z_crc32_z\n#  define deflate               z_deflate\n#  define deflateBound          z_deflateBound\n#  define deflateCopy           z_deflateCopy\n#  define deflateEnd            z_deflateEnd\n#  define deflateGetDictionary  z_deflateGetDictionary\n#  define deflateInit           z_deflateInit\n#  define deflateInit2          z_deflateInit2\n#  define deflateInit2_         z_deflateInit2_\n#  define deflateInit_          z_deflateInit_\n#  define deflateParams         z_deflateParams\n#  define deflatePending        z_deflatePending\n#  define deflatePrime          z_deflatePrime\n#  define deflateReset          z_deflateReset\n#  define deflateResetKeep      z_deflateResetKeep\n#  define deflateSetDictionary  z_deflateSetDictionary\n#  define deflateSetHeader      z_deflateSetHeader\n#  define deflateTune           z_deflateTune\n#  define deflateUsed           z_deflateUsed\n#  define deflate_copyright     z_deflate_copyright\n#  define get_crc_table         z_get_crc_table\n#  ifndef Z_SOLO\n#    define gz_error              z_gz_error\n#    define gz_intmax             z_gz_intmax\n#    define gz_strwinerror        z_gz_strwinerror\n#    define gzbuffer              z_gzbuffer\n#    define gzclearerr            z_gzclearerr\n#    define gzclose               z_gzclose\n#    define gzclose_r             z_gzclose_r\n#    define gzclose_w             z_gzclose_w\n#    define gzdirect              z_gzdirect\n#    define gzdopen               z_gzdopen\n#    define gzeof                 z_gzeof\n#    define gzerror               z_gzerror\n#    define gzflush               z_gzflush\n#    define gzfread               z_gzfread\n#    define gzfwrite              z_gzfwrite\n#    define gzgetc                z_gzgetc\n#    define gzgetc_               z_gzgetc_\n#    define gzgets                z_gzgets\n#    define gzoffset              z_gzoffset\n#    define gzoffset64            z_gzoffset64\n#    define gzopen                z_gzopen\n#    define gzopen64              z_gzopen64\n#    ifdef _WIN32\n#      define gzopen_w              z_gzopen_w\n#    endif\n#    define gzprintf              z_gzprintf\n#    define gzputc                z_gzputc\n#    define gzputs                z_gzputs\n#    define gzread                z_gzread\n#    define gzrewind              z_gzrewind\n#    define gzseek                z_gzseek\n#    define gzseek64              z_gzseek64\n#    define gzsetparams           z_gzsetparams\n#    define gztell                z_gztell\n#    define gztell64              z_gztell64\n#    define gzungetc              z_gzungetc\n#    define gzvprintf             z_gzvprintf\n#    define gzwrite               z_gzwrite\n#  endif\n#  define inflate               z_inflate\n#  define inflateBack           z_inflateBack\n#  define inflateBackEnd        z_inflateBackEnd\n#  define inflateBackInit       z_inflateBackInit\n#  define inflateBackInit_      z_inflateBackInit_\n#  define inflateCodesUsed      z_inflateCodesUsed\n#  define inflateCopy           z_inflateCopy\n#  define inflateEnd            z_inflateEnd\n#  define inflateGetDictionary  z_inflateGetDictionary\n#  define inflateGetHeader      z_inflateGetHeader\n#  define inflateInit           z_inflateInit\n#  define inflateInit2          z_inflateInit2\n#  define inflateInit2_         z_inflateInit2_\n#  define inflateInit_          z_inflateInit_\n#  define inflateMark           z_inflateMark\n#  define inflatePrime          z_inflatePrime\n#  define inflateReset          z_inflateReset\n#  define inflateReset2         z_inflateReset2\n#  define inflateResetKeep      z_inflateResetKeep\n#  define inflateSetDictionary  z_inflateSetDictionary\n#  define inflateSync           z_inflateSync\n#  define inflateSyncPoint      z_inflateSyncPoint\n#  define inflateUndermine      z_inflateUndermine\n#  define inflateValidate       z_inflateValidate\n#  define inflate_copyright     z_inflate_copyright\n#  define inflate_fast          z_inflate_fast\n#  define inflate_table         z_inflate_table\n#  ifndef Z_SOLO\n#    define uncompress            z_uncompress\n#    define uncompress2           z_uncompress2\n#  endif\n#  define zError                z_zError\n#  ifndef Z_SOLO\n#    define zcalloc               z_zcalloc\n#    define zcfree                z_zcfree\n#  endif\n#  define zlibCompileFlags      z_zlibCompileFlags\n#  define zlibVersion           z_zlibVersion\n\n/* all zlib typedefs in zlib.h and zconf.h */\n#  define Byte                  z_Byte\n#  define Bytef                 z_Bytef\n#  define alloc_func            z_alloc_func\n#  define charf                 z_charf\n#  define free_func             z_free_func\n#  ifndef Z_SOLO\n#    define gzFile                z_gzFile\n#  endif\n#  define gz_header             z_gz_header\n#  define gz_headerp            z_gz_headerp\n#  define in_func               z_in_func\n#  define intf                  z_intf\n#  define out_func              z_out_func\n#  define uInt                  z_uInt\n#  define uIntf                 z_uIntf\n#  define uLong                 z_uLong\n#  define uLongf                z_uLongf\n#  define voidp                 z_voidp\n#  define voidpc                z_voidpc\n#  define voidpf                z_voidpf\n\n/* all zlib structs in zlib.h and zconf.h */\n#  define gz_header_s           z_gz_header_s\n#  define internal_state        z_internal_state\n\n#endif\n\n#if defined(__MSDOS__) && !defined(MSDOS)\n#  define MSDOS\n#endif\n#if (defined(OS_2) || defined(__OS2__)) && !defined(OS2)\n#  define OS2\n#endif\n#if defined(_WINDOWS) && !defined(WINDOWS)\n#  define WINDOWS\n#endif\n#if defined(_WIN32) || defined(_WIN32_WCE) || defined(__WIN32__)\n#  ifndef WIN32\n#    define WIN32\n#  endif\n#endif\n#if (defined(MSDOS) || defined(OS2) || defined(WINDOWS)) && !defined(WIN32)\n#  if !defined(__GNUC__) && !defined(__FLAT__) && !defined(__386__)\n#    ifndef SYS16BIT\n#      define SYS16BIT\n#    endif\n#  endif\n#endif\n\n/*\n * Compile with -DMAXSEG_64K if the alloc function cannot allocate more\n * than 64k bytes at a time (needed on systems with 16-bit int).\n */\n#ifdef SYS16BIT\n#  define MAXSEG_64K\n#endif\n#ifdef MSDOS\n#  define UNALIGNED_OK\n#endif\n\n#ifdef __STDC_VERSION__\n#  ifndef STDC\n#    define STDC\n#  endif\n#  if __STDC_VERSION__ >= 199901L\n#    ifndef STDC99\n#      define STDC99\n#    endif\n#  endif\n#endif\n#if !defined(STDC) && (defined(__STDC__) || defined(__cplusplus))\n#  define STDC\n#endif\n#if !defined(STDC) && (defined(__GNUC__) || defined(__BORLANDC__))\n#  define STDC\n#endif\n#if !defined(STDC) && (defined(MSDOS) || defined(WINDOWS) || defined(WIN32))\n#  define STDC\n#endif\n#if !defined(STDC) && (defined(OS2) || defined(__HOS_AIX__))\n#  define STDC\n#endif\n\n#if defined(__OS400__) && !defined(STDC)    /* iSeries (formerly AS/400). */\n#  define STDC\n#endif\n\n#ifndef STDC\n#  ifndef const /* cannot use !defined(STDC) && !defined(const) on Mac */\n#    define const       /* note: need a more gentle solution here */\n#  endif\n#endif\n\n#ifndef z_const\n#  ifdef ZLIB_CONST\n#    define z_const const\n#  else\n#    define z_const\n#  endif\n#endif\n\n#ifdef Z_SOLO\n#  ifdef _WIN64\n     typedef unsigned long long z_size_t;\n#  else\n     typedef unsigned long z_size_t;\n#  endif\n#else\n#  define z_longlong long long\n#  if defined(NO_SIZE_T)\n     typedef unsigned NO_SIZE_T z_size_t;\n#  elif defined(STDC)\n#    include <stddef.h>\n     typedef size_t z_size_t;\n#  else\n     typedef unsigned long z_size_t;\n#  endif\n#  undef z_longlong\n#endif\n\n/* Maximum value for memLevel in deflateInit2 */\n#ifndef MAX_MEM_LEVEL\n#  ifdef MAXSEG_64K\n#    define MAX_MEM_LEVEL 8\n#  else\n#    define MAX_MEM_LEVEL 9\n#  endif\n#endif\n\n/* Maximum value for windowBits in deflateInit2 and inflateInit2.\n * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files\n * created by gzip. (Files created by minigzip can still be extracted by\n * gzip.)\n */\n#ifndef MAX_WBITS\n#  define MAX_WBITS   15 /* 32K LZ77 window */\n#endif\n\n/* The memory requirements for deflate are (in bytes):\n            (1 << (windowBits+2)) +  (1 << (memLevel+9))\n that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)\n plus a few kilobytes for small objects. For example, if you want to reduce\n the default memory requirements from 256K to 128K, compile with\n     make CFLAGS=\"-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7\"\n Of course this will generally degrade compression (there's no free lunch).\n\n   The memory requirements for inflate are (in bytes) 1 << windowBits\n that is, 32K for windowBits=15 (default value) plus about 7 kilobytes\n for small objects.\n*/\n\n                        /* Type declarations */\n\n#ifndef OF /* function prototypes */\n#  ifdef STDC\n#    define OF(args)  args\n#  else\n#    define OF(args)  ()\n#  endif\n#endif\n\n/* The following definitions for FAR are needed only for MSDOS mixed\n * model programming (small or medium model with some far allocations).\n * This was tested only with MSC; for other MSDOS compilers you may have\n * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,\n * just define FAR to be empty.\n */\n#ifdef SYS16BIT\n#  if defined(M_I86SM) || defined(M_I86MM)\n     /* MSC small or medium model */\n#    define SMALL_MEDIUM\n#    ifdef _MSC_VER\n#      define FAR _far\n#    else\n#      define FAR far\n#    endif\n#  endif\n#  if (defined(__SMALL__) || defined(__MEDIUM__))\n     /* Turbo C small or medium model */\n#    define SMALL_MEDIUM\n#    ifdef __BORLANDC__\n#      define FAR _far\n#    else\n#      define FAR far\n#    endif\n#  endif\n#endif\n\n#if defined(WINDOWS) || defined(WIN32)\n   /* If building or using zlib as a DLL, define ZLIB_DLL.\n    * This is not mandatory, but it offers a little performance increase.\n    */\n#  ifdef ZLIB_DLL\n#    if defined(WIN32) && (!defined(__BORLANDC__) || (__BORLANDC__ >= 0x500))\n#      ifdef ZLIB_INTERNAL\n#        define ZEXTERN extern __declspec(dllexport)\n#      else\n#        define ZEXTERN extern __declspec(dllimport)\n#      endif\n#    endif\n#  endif  /* ZLIB_DLL */\n   /* If building or using zlib with the WINAPI/WINAPIV calling convention,\n    * define ZLIB_WINAPI.\n    * Caution: the standard ZLIB1.DLL is NOT compiled using ZLIB_WINAPI.\n    */\n#  ifdef ZLIB_WINAPI\n#    ifdef FAR\n#      undef FAR\n#    endif\n#    ifndef WIN32_LEAN_AND_MEAN\n#      define WIN32_LEAN_AND_MEAN\n#    endif\n#    include <windows.h>\n     /* No need for _export, use ZLIB.DEF instead. */\n     /* For complete Windows compatibility, use WINAPI, not __stdcall. */\n#    define ZEXPORT WINAPI\n#    ifdef WIN32\n#      define ZEXPORTVA WINAPIV\n#    else\n#      define ZEXPORTVA FAR CDECL\n#    endif\n#  endif\n#endif\n\n#if defined (__BEOS__)\n#  ifdef ZLIB_DLL\n#    ifdef ZLIB_INTERNAL\n#      define ZEXPORT   __declspec(dllexport)\n#      define ZEXPORTVA __declspec(dllexport)\n#    else\n#      define ZEXPORT   __declspec(dllimport)\n#      define ZEXPORTVA __declspec(dllimport)\n#    endif\n#  endif\n#endif\n\n#ifndef ZEXTERN\n#  define ZEXTERN extern\n#endif\n#ifndef ZEXPORT\n#  define ZEXPORT\n#endif\n#ifndef ZEXPORTVA\n#  define ZEXPORTVA\n#endif\n\n#ifndef FAR\n#  define FAR\n#endif\n\n#if !defined(__MACTYPES__)\ntypedef unsigned char  Byte;  /* 8 bits */\n#endif\ntypedef unsigned int   uInt;  /* 16 bits or more */\ntypedef unsigned long  uLong; /* 32 bits or more */\n\n#ifdef SMALL_MEDIUM\n   /* Borland C/C++ and some old MSC versions ignore FAR inside typedef */\n#  define Bytef Byte FAR\n#else\n   typedef Byte  FAR Bytef;\n#endif\ntypedef char  FAR charf;\ntypedef int   FAR intf;\ntypedef uInt  FAR uIntf;\ntypedef uLong FAR uLongf;\n\n#ifdef STDC\n   typedef void const *voidpc;\n   typedef void FAR   *voidpf;\n   typedef void       *voidp;\n#else\n   typedef Byte const *voidpc;\n   typedef Byte FAR   *voidpf;\n   typedef Byte       *voidp;\n#endif\n\n#if !defined(Z_U4) && !defined(Z_SOLO) && defined(STDC)\n#  include <limits.h>\n#  if (UINT_MAX == 0xffffffffUL)\n#    define Z_U4 unsigned\n#  elif (ULONG_MAX == 0xffffffffUL)\n#    define Z_U4 unsigned long\n#  elif (USHRT_MAX == 0xffffffffUL)\n#    define Z_U4 unsigned short\n#  endif\n#endif\n\n#ifdef Z_U4\n   typedef Z_U4 z_crc_t;\n#else\n   typedef unsigned long z_crc_t;\n#endif\n\n#ifdef HAVE_UNISTD_H    /* may be set to #if 1 by ./configure */\n#  define Z_HAVE_UNISTD_H\n#endif\n\n#ifdef HAVE_STDARG_H    /* may be set to #if 1 by ./configure */\n#  define Z_HAVE_STDARG_H\n#endif\n\n#ifdef STDC\n#  ifndef Z_SOLO\n#    include <sys/types.h>      /* for off_t */\n#  endif\n#endif\n\n#if defined(STDC) || defined(Z_HAVE_STDARG_H)\n#  ifndef Z_SOLO\n#    include <stdarg.h>         /* for va_list */\n#  endif\n#endif\n\n#ifdef _WIN32\n#  ifndef Z_SOLO\n#    include <stddef.h>         /* for wchar_t */\n#  endif\n#endif\n\n/* a little trick to accommodate both \"#define _LARGEFILE64_SOURCE\" and\n * \"#define _LARGEFILE64_SOURCE 1\" as requesting 64-bit operations, (even\n * though the former does not conform to the LFS document), but considering\n * both \"#undef _LARGEFILE64_SOURCE\" and \"#define _LARGEFILE64_SOURCE 0\" as\n * equivalently requesting no 64-bit operations\n */\n#if defined(_LARGEFILE64_SOURCE) && -_LARGEFILE64_SOURCE - -1 == 1\n#  undef _LARGEFILE64_SOURCE\n#endif\n\n#ifndef Z_HAVE_UNISTD_H\n#  if defined(__WATCOMC__) || defined(__GO32__) || \\\n      (defined(_LARGEFILE64_SOURCE) && !defined(_WIN32))\n#    define Z_HAVE_UNISTD_H\n#  endif\n#endif\n#ifndef Z_SOLO\n#  if defined(Z_HAVE_UNISTD_H)\n#    include <unistd.h>         /* for SEEK_*, off_t, and _LFS64_LARGEFILE */\n#    ifdef VMS\n#      include <unixio.h>       /* for off_t */\n#    endif\n#    ifndef z_off_t\n#      define z_off_t off_t\n#    endif\n#  endif\n#endif\n\n#if defined(_LFS64_LARGEFILE) && _LFS64_LARGEFILE-0\n#  define Z_LFS64\n#endif\n\n#if defined(_LARGEFILE64_SOURCE) && defined(Z_LFS64)\n#  define Z_LARGE64\n#endif\n\n#if defined(_FILE_OFFSET_BITS) && _FILE_OFFSET_BITS-0 == 64 && defined(Z_LFS64)\n#  define Z_WANT64\n#endif\n\n#if !defined(SEEK_SET) && !defined(Z_SOLO)\n#  define SEEK_SET        0       /* Seek from beginning of file.  */\n#  define SEEK_CUR        1       /* Seek from current position.  */\n#  define SEEK_END        2       /* Set file pointer to EOF plus \"offset\" */\n#endif\n\n#ifndef z_off_t\n#  define z_off_t long long\n#endif\n\n#if !defined(_WIN32) && defined(Z_LARGE64)\n#  define z_off64_t off64_t\n#elif defined(__MINGW32__)\n#  define z_off64_t long long\n#elif defined(_WIN32) && !defined(__GNUC__)\n#  define z_off64_t __int64\n#elif defined(__GO32__)\n#  define z_off64_t offset_t\n#else\n#  define z_off64_t z_off_t\n#endif\n\n/* MVS linker does not support external names larger than 8 bytes */\n#if defined(__MVS__)\n  #pragma map(deflateInit_,\"DEIN\")\n  #pragma map(deflateInit2_,\"DEIN2\")\n  #pragma map(deflateEnd,\"DEEND\")\n  #pragma map(deflateBound,\"DEBND\")\n  #pragma map(inflateInit_,\"ININ\")\n  #pragma map(inflateInit2_,\"ININ2\")\n  #pragma map(inflateEnd,\"INEND\")\n  #pragma map(inflateSync,\"INSY\")\n  #pragma map(inflateSetDictionary,\"INSEDI\")\n  #pragma map(compressBound,\"CMBND\")\n  #pragma map(inflate_table,\"INTABL\")\n  #pragma map(inflate_fast,\"INFA\")\n  #pragma map(inflate_copyright,\"INCOPY\")\n#endif\n\n#endif /* ZCONF_H */\n"
        },
        {
          "name": "zconf.h.in",
          "type": "blob",
          "size": 16.22265625,
          "content": "/* zconf.h -- configuration of the zlib compression library\n * Copyright (C) 1995-2024 Jean-loup Gailly, Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n/* @(#) $Id$ */\n\n#ifndef ZCONF_H\n#define ZCONF_H\n\n/*\n * If you *really* need a unique prefix for all types and library functions,\n * compile with -DZ_PREFIX. The \"standard\" zlib should be compiled without it.\n * Even better than compiling with -DZ_PREFIX would be to use configure to set\n * this permanently in zconf.h using \"./configure --zprefix\".\n */\n#ifdef Z_PREFIX     /* may be set to #if 1 by ./configure */\n#  define Z_PREFIX_SET\n\n/* all linked symbols and init macros */\n#  define _dist_code            z__dist_code\n#  define _length_code          z__length_code\n#  define _tr_align             z__tr_align\n#  define _tr_flush_bits        z__tr_flush_bits\n#  define _tr_flush_block       z__tr_flush_block\n#  define _tr_init              z__tr_init\n#  define _tr_stored_block      z__tr_stored_block\n#  define _tr_tally             z__tr_tally\n#  define adler32               z_adler32\n#  define adler32_combine       z_adler32_combine\n#  define adler32_combine64     z_adler32_combine64\n#  define adler32_z             z_adler32_z\n#  ifndef Z_SOLO\n#    define compress              z_compress\n#    define compress2             z_compress2\n#    define compressBound         z_compressBound\n#  endif\n#  define crc32                 z_crc32\n#  define crc32_combine         z_crc32_combine\n#  define crc32_combine64       z_crc32_combine64\n#  define crc32_combine_gen     z_crc32_combine_gen\n#  define crc32_combine_gen64   z_crc32_combine_gen64\n#  define crc32_combine_op      z_crc32_combine_op\n#  define crc32_z               z_crc32_z\n#  define deflate               z_deflate\n#  define deflateBound          z_deflateBound\n#  define deflateCopy           z_deflateCopy\n#  define deflateEnd            z_deflateEnd\n#  define deflateGetDictionary  z_deflateGetDictionary\n#  define deflateInit           z_deflateInit\n#  define deflateInit2          z_deflateInit2\n#  define deflateInit2_         z_deflateInit2_\n#  define deflateInit_          z_deflateInit_\n#  define deflateParams         z_deflateParams\n#  define deflatePending        z_deflatePending\n#  define deflatePrime          z_deflatePrime\n#  define deflateReset          z_deflateReset\n#  define deflateResetKeep      z_deflateResetKeep\n#  define deflateSetDictionary  z_deflateSetDictionary\n#  define deflateSetHeader      z_deflateSetHeader\n#  define deflateTune           z_deflateTune\n#  define deflateUsed           z_deflateUsed\n#  define deflate_copyright     z_deflate_copyright\n#  define get_crc_table         z_get_crc_table\n#  ifndef Z_SOLO\n#    define gz_error              z_gz_error\n#    define gz_intmax             z_gz_intmax\n#    define gz_strwinerror        z_gz_strwinerror\n#    define gzbuffer              z_gzbuffer\n#    define gzclearerr            z_gzclearerr\n#    define gzclose               z_gzclose\n#    define gzclose_r             z_gzclose_r\n#    define gzclose_w             z_gzclose_w\n#    define gzdirect              z_gzdirect\n#    define gzdopen               z_gzdopen\n#    define gzeof                 z_gzeof\n#    define gzerror               z_gzerror\n#    define gzflush               z_gzflush\n#    define gzfread               z_gzfread\n#    define gzfwrite              z_gzfwrite\n#    define gzgetc                z_gzgetc\n#    define gzgetc_               z_gzgetc_\n#    define gzgets                z_gzgets\n#    define gzoffset              z_gzoffset\n#    define gzoffset64            z_gzoffset64\n#    define gzopen                z_gzopen\n#    define gzopen64              z_gzopen64\n#    ifdef _WIN32\n#      define gzopen_w              z_gzopen_w\n#    endif\n#    define gzprintf              z_gzprintf\n#    define gzputc                z_gzputc\n#    define gzputs                z_gzputs\n#    define gzread                z_gzread\n#    define gzrewind              z_gzrewind\n#    define gzseek                z_gzseek\n#    define gzseek64              z_gzseek64\n#    define gzsetparams           z_gzsetparams\n#    define gztell                z_gztell\n#    define gztell64              z_gztell64\n#    define gzungetc              z_gzungetc\n#    define gzvprintf             z_gzvprintf\n#    define gzwrite               z_gzwrite\n#  endif\n#  define inflate               z_inflate\n#  define inflateBack           z_inflateBack\n#  define inflateBackEnd        z_inflateBackEnd\n#  define inflateBackInit       z_inflateBackInit\n#  define inflateBackInit_      z_inflateBackInit_\n#  define inflateCodesUsed      z_inflateCodesUsed\n#  define inflateCopy           z_inflateCopy\n#  define inflateEnd            z_inflateEnd\n#  define inflateGetDictionary  z_inflateGetDictionary\n#  define inflateGetHeader      z_inflateGetHeader\n#  define inflateInit           z_inflateInit\n#  define inflateInit2          z_inflateInit2\n#  define inflateInit2_         z_inflateInit2_\n#  define inflateInit_          z_inflateInit_\n#  define inflateMark           z_inflateMark\n#  define inflatePrime          z_inflatePrime\n#  define inflateReset          z_inflateReset\n#  define inflateReset2         z_inflateReset2\n#  define inflateResetKeep      z_inflateResetKeep\n#  define inflateSetDictionary  z_inflateSetDictionary\n#  define inflateSync           z_inflateSync\n#  define inflateSyncPoint      z_inflateSyncPoint\n#  define inflateUndermine      z_inflateUndermine\n#  define inflateValidate       z_inflateValidate\n#  define inflate_copyright     z_inflate_copyright\n#  define inflate_fast          z_inflate_fast\n#  define inflate_table         z_inflate_table\n#  ifndef Z_SOLO\n#    define uncompress            z_uncompress\n#    define uncompress2           z_uncompress2\n#  endif\n#  define zError                z_zError\n#  ifndef Z_SOLO\n#    define zcalloc               z_zcalloc\n#    define zcfree                z_zcfree\n#  endif\n#  define zlibCompileFlags      z_zlibCompileFlags\n#  define zlibVersion           z_zlibVersion\n\n/* all zlib typedefs in zlib.h and zconf.h */\n#  define Byte                  z_Byte\n#  define Bytef                 z_Bytef\n#  define alloc_func            z_alloc_func\n#  define charf                 z_charf\n#  define free_func             z_free_func\n#  ifndef Z_SOLO\n#    define gzFile                z_gzFile\n#  endif\n#  define gz_header             z_gz_header\n#  define gz_headerp            z_gz_headerp\n#  define in_func               z_in_func\n#  define intf                  z_intf\n#  define out_func              z_out_func\n#  define uInt                  z_uInt\n#  define uIntf                 z_uIntf\n#  define uLong                 z_uLong\n#  define uLongf                z_uLongf\n#  define voidp                 z_voidp\n#  define voidpc                z_voidpc\n#  define voidpf                z_voidpf\n\n/* all zlib structs in zlib.h and zconf.h */\n#  define gz_header_s           z_gz_header_s\n#  define internal_state        z_internal_state\n\n#endif\n\n#if defined(__MSDOS__) && !defined(MSDOS)\n#  define MSDOS\n#endif\n#if (defined(OS_2) || defined(__OS2__)) && !defined(OS2)\n#  define OS2\n#endif\n#if defined(_WINDOWS) && !defined(WINDOWS)\n#  define WINDOWS\n#endif\n#if defined(_WIN32) || defined(_WIN32_WCE) || defined(__WIN32__)\n#  ifndef WIN32\n#    define WIN32\n#  endif\n#endif\n#if (defined(MSDOS) || defined(OS2) || defined(WINDOWS)) && !defined(WIN32)\n#  if !defined(__GNUC__) && !defined(__FLAT__) && !defined(__386__)\n#    ifndef SYS16BIT\n#      define SYS16BIT\n#    endif\n#  endif\n#endif\n\n/*\n * Compile with -DMAXSEG_64K if the alloc function cannot allocate more\n * than 64k bytes at a time (needed on systems with 16-bit int).\n */\n#ifdef SYS16BIT\n#  define MAXSEG_64K\n#endif\n#ifdef MSDOS\n#  define UNALIGNED_OK\n#endif\n\n#ifdef __STDC_VERSION__\n#  ifndef STDC\n#    define STDC\n#  endif\n#  if __STDC_VERSION__ >= 199901L\n#    ifndef STDC99\n#      define STDC99\n#    endif\n#  endif\n#endif\n#if !defined(STDC) && (defined(__STDC__) || defined(__cplusplus))\n#  define STDC\n#endif\n#if !defined(STDC) && (defined(__GNUC__) || defined(__BORLANDC__))\n#  define STDC\n#endif\n#if !defined(STDC) && (defined(MSDOS) || defined(WINDOWS) || defined(WIN32))\n#  define STDC\n#endif\n#if !defined(STDC) && (defined(OS2) || defined(__HOS_AIX__))\n#  define STDC\n#endif\n\n#if defined(__OS400__) && !defined(STDC)    /* iSeries (formerly AS/400). */\n#  define STDC\n#endif\n\n#ifndef STDC\n#  ifndef const /* cannot use !defined(STDC) && !defined(const) on Mac */\n#    define const       /* note: need a more gentle solution here */\n#  endif\n#endif\n\n#ifndef z_const\n#  ifdef ZLIB_CONST\n#    define z_const const\n#  else\n#    define z_const\n#  endif\n#endif\n\n#ifdef Z_SOLO\n#  ifdef _WIN64\n     typedef unsigned long long z_size_t;\n#  else\n     typedef unsigned long z_size_t;\n#  endif\n#else\n#  define z_longlong long long\n#  if defined(NO_SIZE_T)\n     typedef unsigned NO_SIZE_T z_size_t;\n#  elif defined(STDC)\n#    include <stddef.h>\n     typedef size_t z_size_t;\n#  else\n     typedef unsigned long z_size_t;\n#  endif\n#  undef z_longlong\n#endif\n\n/* Maximum value for memLevel in deflateInit2 */\n#ifndef MAX_MEM_LEVEL\n#  ifdef MAXSEG_64K\n#    define MAX_MEM_LEVEL 8\n#  else\n#    define MAX_MEM_LEVEL 9\n#  endif\n#endif\n\n/* Maximum value for windowBits in deflateInit2 and inflateInit2.\n * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files\n * created by gzip. (Files created by minigzip can still be extracted by\n * gzip.)\n */\n#ifndef MAX_WBITS\n#  define MAX_WBITS   15 /* 32K LZ77 window */\n#endif\n\n/* The memory requirements for deflate are (in bytes):\n            (1 << (windowBits+2)) +  (1 << (memLevel+9))\n that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)\n plus a few kilobytes for small objects. For example, if you want to reduce\n the default memory requirements from 256K to 128K, compile with\n     make CFLAGS=\"-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7\"\n Of course this will generally degrade compression (there's no free lunch).\n\n   The memory requirements for inflate are (in bytes) 1 << windowBits\n that is, 32K for windowBits=15 (default value) plus about 7 kilobytes\n for small objects.\n*/\n\n                        /* Type declarations */\n\n#ifndef OF /* function prototypes */\n#  ifdef STDC\n#    define OF(args)  args\n#  else\n#    define OF(args)  ()\n#  endif\n#endif\n\n/* The following definitions for FAR are needed only for MSDOS mixed\n * model programming (small or medium model with some far allocations).\n * This was tested only with MSC; for other MSDOS compilers you may have\n * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,\n * just define FAR to be empty.\n */\n#ifdef SYS16BIT\n#  if defined(M_I86SM) || defined(M_I86MM)\n     /* MSC small or medium model */\n#    define SMALL_MEDIUM\n#    ifdef _MSC_VER\n#      define FAR _far\n#    else\n#      define FAR far\n#    endif\n#  endif\n#  if (defined(__SMALL__) || defined(__MEDIUM__))\n     /* Turbo C small or medium model */\n#    define SMALL_MEDIUM\n#    ifdef __BORLANDC__\n#      define FAR _far\n#    else\n#      define FAR far\n#    endif\n#  endif\n#endif\n\n#if defined(WINDOWS) || defined(WIN32)\n   /* If building or using zlib as a DLL, define ZLIB_DLL.\n    * This is not mandatory, but it offers a little performance increase.\n    */\n#  ifdef ZLIB_DLL\n#    if defined(WIN32) && (!defined(__BORLANDC__) || (__BORLANDC__ >= 0x500))\n#      ifdef ZLIB_INTERNAL\n#        define ZEXTERN extern __declspec(dllexport)\n#      else\n#        define ZEXTERN extern __declspec(dllimport)\n#      endif\n#    endif\n#  endif  /* ZLIB_DLL */\n   /* If building or using zlib with the WINAPI/WINAPIV calling convention,\n    * define ZLIB_WINAPI.\n    * Caution: the standard ZLIB1.DLL is NOT compiled using ZLIB_WINAPI.\n    */\n#  ifdef ZLIB_WINAPI\n#    ifdef FAR\n#      undef FAR\n#    endif\n#    ifndef WIN32_LEAN_AND_MEAN\n#      define WIN32_LEAN_AND_MEAN\n#    endif\n#    include <windows.h>\n     /* No need for _export, use ZLIB.DEF instead. */\n     /* For complete Windows compatibility, use WINAPI, not __stdcall. */\n#    define ZEXPORT WINAPI\n#    ifdef WIN32\n#      define ZEXPORTVA WINAPIV\n#    else\n#      define ZEXPORTVA FAR CDECL\n#    endif\n#  endif\n#endif\n\n#if defined (__BEOS__)\n#  ifdef ZLIB_DLL\n#    ifdef ZLIB_INTERNAL\n#      define ZEXPORT   __declspec(dllexport)\n#      define ZEXPORTVA __declspec(dllexport)\n#    else\n#      define ZEXPORT   __declspec(dllimport)\n#      define ZEXPORTVA __declspec(dllimport)\n#    endif\n#  endif\n#endif\n\n#ifndef ZEXTERN\n#  define ZEXTERN extern\n#endif\n#ifndef ZEXPORT\n#  define ZEXPORT\n#endif\n#ifndef ZEXPORTVA\n#  define ZEXPORTVA\n#endif\n\n#ifndef FAR\n#  define FAR\n#endif\n\n#if !defined(__MACTYPES__)\ntypedef unsigned char  Byte;  /* 8 bits */\n#endif\ntypedef unsigned int   uInt;  /* 16 bits or more */\ntypedef unsigned long  uLong; /* 32 bits or more */\n\n#ifdef SMALL_MEDIUM\n   /* Borland C/C++ and some old MSC versions ignore FAR inside typedef */\n#  define Bytef Byte FAR\n#else\n   typedef Byte  FAR Bytef;\n#endif\ntypedef char  FAR charf;\ntypedef int   FAR intf;\ntypedef uInt  FAR uIntf;\ntypedef uLong FAR uLongf;\n\n#ifdef STDC\n   typedef void const *voidpc;\n   typedef void FAR   *voidpf;\n   typedef void       *voidp;\n#else\n   typedef Byte const *voidpc;\n   typedef Byte FAR   *voidpf;\n   typedef Byte       *voidp;\n#endif\n\n#if !defined(Z_U4) && !defined(Z_SOLO) && defined(STDC)\n#  include <limits.h>\n#  if (UINT_MAX == 0xffffffffUL)\n#    define Z_U4 unsigned\n#  elif (ULONG_MAX == 0xffffffffUL)\n#    define Z_U4 unsigned long\n#  elif (USHRT_MAX == 0xffffffffUL)\n#    define Z_U4 unsigned short\n#  endif\n#endif\n\n#ifdef Z_U4\n   typedef Z_U4 z_crc_t;\n#else\n   typedef unsigned long z_crc_t;\n#endif\n\n#ifdef HAVE_UNISTD_H    /* may be set to #if 1 by ./configure */\n#  define Z_HAVE_UNISTD_H\n#endif\n\n#ifdef HAVE_STDARG_H    /* may be set to #if 1 by ./configure */\n#  define Z_HAVE_STDARG_H\n#endif\n\n#ifdef STDC\n#  ifndef Z_SOLO\n#    include <sys/types.h>      /* for off_t */\n#  endif\n#endif\n\n#if defined(STDC) || defined(Z_HAVE_STDARG_H)\n#  ifndef Z_SOLO\n#    include <stdarg.h>         /* for va_list */\n#  endif\n#endif\n\n#ifdef _WIN32\n#  ifndef Z_SOLO\n#    include <stddef.h>         /* for wchar_t */\n#  endif\n#endif\n\n/* a little trick to accommodate both \"#define _LARGEFILE64_SOURCE\" and\n * \"#define _LARGEFILE64_SOURCE 1\" as requesting 64-bit operations, (even\n * though the former does not conform to the LFS document), but considering\n * both \"#undef _LARGEFILE64_SOURCE\" and \"#define _LARGEFILE64_SOURCE 0\" as\n * equivalently requesting no 64-bit operations\n */\n#if defined(_LARGEFILE64_SOURCE) && -_LARGEFILE64_SOURCE - -1 == 1\n#  undef _LARGEFILE64_SOURCE\n#endif\n\n#ifndef Z_HAVE_UNISTD_H\n#  if defined(__WATCOMC__) || defined(__GO32__) || \\\n      (defined(_LARGEFILE64_SOURCE) && !defined(_WIN32))\n#    define Z_HAVE_UNISTD_H\n#  endif\n#endif\n#ifndef Z_SOLO\n#  if defined(Z_HAVE_UNISTD_H)\n#    include <unistd.h>         /* for SEEK_*, off_t, and _LFS64_LARGEFILE */\n#    ifdef VMS\n#      include <unixio.h>       /* for off_t */\n#    endif\n#    ifndef z_off_t\n#      define z_off_t off_t\n#    endif\n#  endif\n#endif\n\n#if defined(_LFS64_LARGEFILE) && _LFS64_LARGEFILE-0\n#  define Z_LFS64\n#endif\n\n#if defined(_LARGEFILE64_SOURCE) && defined(Z_LFS64)\n#  define Z_LARGE64\n#endif\n\n#if defined(_FILE_OFFSET_BITS) && _FILE_OFFSET_BITS-0 == 64 && defined(Z_LFS64)\n#  define Z_WANT64\n#endif\n\n#if !defined(SEEK_SET) && !defined(Z_SOLO)\n#  define SEEK_SET        0       /* Seek from beginning of file.  */\n#  define SEEK_CUR        1       /* Seek from current position.  */\n#  define SEEK_END        2       /* Set file pointer to EOF plus \"offset\" */\n#endif\n\n#ifndef z_off_t\n#  define z_off_t long long\n#endif\n\n#if !defined(_WIN32) && defined(Z_LARGE64)\n#  define z_off64_t off64_t\n#elif defined(__MINGW32__)\n#  define z_off64_t long long\n#elif defined(_WIN32) && !defined(__GNUC__)\n#  define z_off64_t __int64\n#elif defined(__GO32__)\n#  define z_off64_t offset_t\n#else\n#  define z_off64_t z_off_t\n#endif\n\n/* MVS linker does not support external names larger than 8 bytes */\n#if defined(__MVS__)\n  #pragma map(deflateInit_,\"DEIN\")\n  #pragma map(deflateInit2_,\"DEIN2\")\n  #pragma map(deflateEnd,\"DEEND\")\n  #pragma map(deflateBound,\"DEBND\")\n  #pragma map(inflateInit_,\"ININ\")\n  #pragma map(inflateInit2_,\"ININ2\")\n  #pragma map(inflateEnd,\"INEND\")\n  #pragma map(inflateSync,\"INSY\")\n  #pragma map(inflateSetDictionary,\"INSEDI\")\n  #pragma map(compressBound,\"CMBND\")\n  #pragma map(inflate_table,\"INTABL\")\n  #pragma map(inflate_fast,\"INFA\")\n  #pragma map(inflate_copyright,\"INCOPY\")\n#endif\n\n#endif /* ZCONF_H */\n"
        },
        {
          "name": "zlib.3",
          "type": "blob",
          "size": 4.3837890625,
          "content": ".TH ZLIB 3 \"xx Jan 2024\"\n.SH NAME\nzlib \\- compression/decompression library\n.SH SYNOPSIS\n[see\n.I zlib.h\nfor full description]\n.SH DESCRIPTION\nThe\n.I zlib\nlibrary is a general purpose data compression library.\nThe code is thread safe, assuming that the standard library functions\nused are thread safe, such as memory allocation routines.\nIt provides in-memory compression and decompression functions,\nincluding integrity checks of the uncompressed data.\nThis version of the library supports only one compression method (deflation)\nbut other algorithms may be added later\nwith the same stream interface.\n.LP\nCompression can be done in a single step if the buffers are large enough\nor can be done by repeated calls of the compression function.\nIn the latter case,\nthe application must provide more input and/or consume the output\n(providing more output space) before each call.\n.LP\nThe library also supports reading and writing files in\n.IR gzip (1)\n(.gz) format\nwith an interface similar to that of stdio.\n.LP\nThe library does not install any signal handler.\nThe decoder checks the consistency of the compressed data,\nso the library should never crash even in the case of corrupted input.\n.LP\nAll functions of the compression library are documented in the file\n.IR zlib.h .\nThe distribution source includes examples of use of the library\nin the files\n.I test/example.c\nand\n.IR test/minigzip.c,\nas well as other examples in the\n.IR examples/\ndirectory.\n.LP\nChanges to this version are documented in the file\n.I ChangeLog\nthat accompanies the source.\n.LP\n.I zlib\nis built in to many languages and operating systems, including but not limited to\nJava, Python, .NET, PHP, Perl, Ruby, Swift, and Go.\n.LP\nAn experimental package to read and write files in the .zip format,\nwritten on top of\n.I zlib\nby Gilles Vollant (info@winimage.com),\nis available at:\n.IP\nhttp://www.winimage.com/zLibDll/minizip.html\nand also in the\n.I contrib/minizip\ndirectory of the main\n.I zlib\nsource distribution.\n.SH \"SEE ALSO\"\nThe\n.I zlib\nweb site can be found at:\n.IP\nhttp://zlib.net/\n.LP\nThe data format used by the\n.I zlib\nlibrary is described by RFC\n(Request for Comments) 1950 to 1952 in the files:\n.IP\nhttp://tools.ietf.org/html/rfc1950 (for the zlib header and trailer format)\n.br\nhttp://tools.ietf.org/html/rfc1951 (for the deflate compressed data format)\n.br\nhttp://tools.ietf.org/html/rfc1952 (for the gzip header and trailer format)\n.LP\nMark Nelson wrote an article about\n.I zlib\nfor the Jan. 1997 issue of  Dr. Dobb's Journal;\na copy of the article is available at:\n.IP\nhttps://marknelson.us/posts/1997/01/01/zlib-engine.html\n.SH \"REPORTING PROBLEMS\"\nBefore reporting a problem,\nplease check the\n.I zlib\nweb site to verify that you have the latest version of\n.IR zlib ;\notherwise,\nobtain the latest version and see if the problem still exists.\nPlease read the\n.I zlib\nFAQ at:\n.IP\nhttp://zlib.net/zlib_faq.html\n.LP\nbefore asking for help.\nSend questions and/or comments to zlib@gzip.org,\nor (for the Windows DLL version) to Gilles Vollant (info@winimage.com).\n.SH AUTHORS AND LICENSE\nVersion 1.3.1.1\n.LP\nCopyright (C) 1995-2024 Jean-loup Gailly and Mark Adler\n.LP\nThis software is provided 'as-is', without any express or implied\nwarranty.  In no event will the authors be held liable for any damages\narising from the use of this software.\n.LP\nPermission is granted to anyone to use this software for any purpose,\nincluding commercial applications, and to alter it and redistribute it\nfreely, subject to the following restrictions:\n.LP\n.nr step 1 1\n.IP \\n[step]. 3\nThe origin of this software must not be misrepresented; you must not\nclaim that you wrote the original software. If you use this software\nin a product, an acknowledgment in the product documentation would be\nappreciated but is not required.\n.IP \\n+[step].\nAltered source versions must be plainly marked as such, and must not be\nmisrepresented as being the original software.\n.IP \\n+[step].\nThis notice may not be removed or altered from any source distribution.\n.LP\nJean-loup Gailly        Mark Adler\n.br\njloup@gzip.org          madler@alumni.caltech.edu\n.LP\nThe deflate format used by\n.I zlib\nwas defined by Phil Katz.\nThe deflate and\n.I zlib\nspecifications were written by L. Peter Deutsch.\nThanks to all the people who reported problems and suggested various\nimprovements in\n.IR zlib ;\nwho are too numerous to cite here.\n.LP\nUNIX manual page by R. P. C. Rodgers,\nU.S. National Library of Medicine (rodgers@nlm.nih.gov).\n.\\\" end of man page\n"
        },
        {
          "name": "zlib.3.pdf",
          "type": "blob",
          "size": 24.9248046875,
          "content": null
        },
        {
          "name": "zlib.h",
          "type": "blob",
          "size": 95.267578125,
          "content": "/* zlib.h -- interface of the 'zlib' general purpose compression library\n  version 1.3.1.1, January xxth, 2024\n\n  Copyright (C) 1995-2024 Jean-loup Gailly and Mark Adler\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n\n  Jean-loup Gailly        Mark Adler\n  jloup@gzip.org          madler@alumni.caltech.edu\n\n\n  The data format used by the zlib library is described by RFCs (Request for\n  Comments) 1950 to 1952 in the files http://tools.ietf.org/html/rfc1950\n  (zlib format), rfc1951 (deflate format) and rfc1952 (gzip format).\n*/\n\n#ifndef ZLIB_H\n#define ZLIB_H\n\n#include \"zconf.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define ZLIB_VERSION \"1.3.1.1-motley\"\n#define ZLIB_VERNUM 0x1311\n#define ZLIB_VER_MAJOR 1\n#define ZLIB_VER_MINOR 3\n#define ZLIB_VER_REVISION 1\n#define ZLIB_VER_SUBREVISION 1\n\n/*\n    The 'zlib' compression library provides in-memory compression and\n  decompression functions, including integrity checks of the uncompressed data.\n  This version of the library supports only one compression method (deflation)\n  but other algorithms will be added later and will have the same stream\n  interface.\n\n    Compression can be done in a single step if the buffers are large enough,\n  or can be done by repeated calls of the compression function.  In the latter\n  case, the application must provide more input and/or consume the output\n  (providing more output space) before each call.\n\n    The compressed data format used by default by the in-memory functions is\n  the zlib format, which is a zlib wrapper documented in RFC 1950, wrapped\n  around a deflate stream, which is itself documented in RFC 1951.\n\n    The library also supports reading and writing files in gzip (.gz) format\n  with an interface similar to that of stdio using the functions that start\n  with \"gz\".  The gzip format is different from the zlib format.  gzip is a\n  gzip wrapper, documented in RFC 1952, wrapped around a deflate stream.\n\n    This library can optionally read and write gzip and raw deflate streams in\n  memory as well.\n\n    The zlib format was designed to be compact and fast for use in memory\n  and on communications channels.  The gzip format was designed for single-\n  file compression on file systems, has a larger header than zlib to maintain\n  directory information, and uses a different, slower check method than zlib.\n\n    The library does not install any signal handler.  The decoder checks\n  the consistency of the compressed data, so the library should never crash\n  even in the case of corrupted input.\n*/\n\ntypedef voidpf (*alloc_func)(voidpf opaque, uInt items, uInt size);\ntypedef void   (*free_func)(voidpf opaque, voidpf address);\n\nstruct internal_state;\n\ntypedef struct z_stream_s {\n    z_const Bytef *next_in;     /* next input byte */\n    uInt     avail_in;  /* number of bytes available at next_in */\n    uLong    total_in;  /* total number of input bytes read so far */\n\n    Bytef    *next_out; /* next output byte will go here */\n    uInt     avail_out; /* remaining free space at next_out */\n    uLong    total_out; /* total number of bytes output so far */\n\n    z_const char *msg;  /* last error message, NULL if no error */\n    struct internal_state FAR *state; /* not visible by applications */\n\n    alloc_func zalloc;  /* used to allocate the internal state */\n    free_func  zfree;   /* used to free the internal state */\n    voidpf     opaque;  /* private data object passed to zalloc and zfree */\n\n    int     data_type;  /* best guess about the data type: binary or text\n                           for deflate, or the decoding state for inflate */\n    uLong   adler;      /* Adler-32 or CRC-32 value of the uncompressed data */\n    uLong   reserved;   /* reserved for future use */\n} z_stream;\n\ntypedef z_stream FAR *z_streamp;\n\n/*\n     gzip header information passed to and from zlib routines.  See RFC 1952\n  for more details on the meanings of these fields.\n*/\ntypedef struct gz_header_s {\n    int     text;       /* true if compressed data believed to be text */\n    uLong   time;       /* modification time */\n    int     xflags;     /* extra flags (not used when writing a gzip file) */\n    int     os;         /* operating system */\n    Bytef   *extra;     /* pointer to extra field or Z_NULL if none */\n    uInt    extra_len;  /* extra field length (valid if extra != Z_NULL) */\n    uInt    extra_max;  /* space at extra (only when reading header) */\n    Bytef   *name;      /* pointer to zero-terminated file name or Z_NULL */\n    uInt    name_max;   /* space at name (only when reading header) */\n    Bytef   *comment;   /* pointer to zero-terminated comment or Z_NULL */\n    uInt    comm_max;   /* space at comment (only when reading header) */\n    int     hcrc;       /* true if there was or will be a header crc */\n    int     done;       /* true when done reading gzip header (not used\n                           when writing a gzip file) */\n} gz_header;\n\ntypedef gz_header FAR *gz_headerp;\n\n/*\n     The application must update next_in and avail_in when avail_in has dropped\n   to zero.  It must update next_out and avail_out when avail_out has dropped\n   to zero.  The application must initialize zalloc, zfree and opaque before\n   calling the init function.  All other fields are set by the compression\n   library and must not be updated by the application.\n\n     The opaque value provided by the application will be passed as the first\n   parameter for calls of zalloc and zfree.  This can be useful for custom\n   memory management.  The compression library attaches no meaning to the\n   opaque value.\n\n     zalloc must return Z_NULL if there is not enough memory for the object.\n   If zlib is used in a multi-threaded application, zalloc and zfree must be\n   thread safe.  In that case, zlib is thread-safe.  When zalloc and zfree are\n   Z_NULL on entry to the initialization function, they are set to internal\n   routines that use the standard library functions malloc() and free().\n\n     On 16-bit systems, the functions zalloc and zfree must be able to allocate\n   exactly 65536 bytes, but will not be required to allocate more than this if\n   the symbol MAXSEG_64K is defined (see zconf.h).  WARNING: On MSDOS, pointers\n   returned by zalloc for objects of exactly 65536 bytes *must* have their\n   offset normalized to zero.  The default allocation function provided by this\n   library ensures this (see zutil.c).  To reduce memory requirements and avoid\n   any allocation of 64K objects, at the expense of compression ratio, compile\n   the library with -DMAX_WBITS=14 (see zconf.h).\n\n     The fields total_in and total_out can be used for statistics or progress\n   reports.  After compression, total_in holds the total size of the\n   uncompressed data and may be saved for use by the decompressor (particularly\n   if the decompressor wants to decompress everything in a single step).\n*/\n\n                        /* constants */\n\n#define Z_NO_FLUSH      0\n#define Z_PARTIAL_FLUSH 1\n#define Z_SYNC_FLUSH    2\n#define Z_FULL_FLUSH    3\n#define Z_FINISH        4\n#define Z_BLOCK         5\n#define Z_TREES         6\n/* Allowed flush values; see deflate() and inflate() below for details */\n\n#define Z_OK            0\n#define Z_STREAM_END    1\n#define Z_NEED_DICT     2\n#define Z_ERRNO        (-1)\n#define Z_STREAM_ERROR (-2)\n#define Z_DATA_ERROR   (-3)\n#define Z_MEM_ERROR    (-4)\n#define Z_BUF_ERROR    (-5)\n#define Z_VERSION_ERROR (-6)\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */\n\n#define Z_NO_COMPRESSION         0\n#define Z_BEST_SPEED             1\n#define Z_BEST_COMPRESSION       9\n#define Z_DEFAULT_COMPRESSION  (-1)\n/* compression levels */\n\n#define Z_FILTERED            1\n#define Z_HUFFMAN_ONLY        2\n#define Z_RLE                 3\n#define Z_FIXED               4\n#define Z_DEFAULT_STRATEGY    0\n/* compression strategy; see deflateInit2() below for details */\n\n#define Z_BINARY   0\n#define Z_TEXT     1\n#define Z_ASCII    Z_TEXT   /* for compatibility with 1.2.2 and earlier */\n#define Z_UNKNOWN  2\n/* Possible values of the data_type field for deflate() */\n\n#define Z_DEFLATED   8\n/* The deflate compression method (the only one supported in this version) */\n\n#define Z_NULL  0  /* for initializing zalloc, zfree, opaque */\n\n#define zlib_version zlibVersion()\n/* for compatibility with versions < 1.0.2 */\n\n\n                        /* basic functions */\n\nZEXTERN const char * ZEXPORT zlibVersion(void);\n/* The application can compare zlibVersion and ZLIB_VERSION for consistency.\n   If the first character differs, the library code actually used is not\n   compatible with the zlib.h header file used by the application.  This check\n   is automatically made by deflateInit and inflateInit.\n */\n\n/*\nZEXTERN int ZEXPORT deflateInit(z_streamp strm, int level);\n\n     Initializes the internal stream state for compression.  The fields\n   zalloc, zfree and opaque must be initialized before by the caller.  If\n   zalloc and zfree are set to Z_NULL, deflateInit updates them to use default\n   allocation functions.  total_in, total_out, adler, and msg are initialized.\n\n     The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:\n   1 gives best speed, 9 gives best compression, 0 gives no compression at all\n   (the input data is simply copied a block at a time).  Z_DEFAULT_COMPRESSION\n   requests a default compromise between speed and compression (currently\n   equivalent to level 6).\n\n     deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough\n   memory, Z_STREAM_ERROR if level is not a valid compression level, or\n   Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible\n   with the version assumed by the caller (ZLIB_VERSION).  msg is set to null\n   if there is no error message.  deflateInit does not perform any compression:\n   this will be done by deflate().\n*/\n\n\nZEXTERN int ZEXPORT deflate(z_streamp strm, int flush);\n/*\n    deflate compresses as much data as possible, and stops when the input\n  buffer becomes empty or the output buffer becomes full.  It may introduce\n  some output latency (reading input without producing any output) except when\n  forced to flush.\n\n    The detailed semantics are as follows.  deflate performs one or both of the\n  following actions:\n\n  - Compress more input starting at next_in and update next_in and avail_in\n    accordingly.  If not all input can be processed (because there is not\n    enough room in the output buffer), next_in and avail_in are updated and\n    processing will resume at this point for the next call of deflate().\n\n  - Generate more output starting at next_out and update next_out and avail_out\n    accordingly.  This action is forced if the parameter flush is non zero.\n    Forcing flush frequently degrades the compression ratio, so this parameter\n    should be set only when necessary.  Some output may be provided even if\n    flush is zero.\n\n    Before the call of deflate(), the application should ensure that at least\n  one of the actions is possible, by providing more input and/or consuming more\n  output, and updating avail_in or avail_out accordingly; avail_out should\n  never be zero before the call.  The application can consume the compressed\n  output when it wants, for example when the output buffer is full (avail_out\n  == 0), or after each call of deflate().  If deflate returns Z_OK and with\n  zero avail_out, it must be called again after making room in the output\n  buffer because there might be more output pending. See deflatePending(),\n  which can be used if desired to determine whether or not there is more output\n  in that case.\n\n    Normally the parameter flush is set to Z_NO_FLUSH, which allows deflate to\n  decide how much data to accumulate before producing output, in order to\n  maximize compression.\n\n    If the parameter flush is set to Z_SYNC_FLUSH, all pending output is\n  flushed to the output buffer and the output is aligned on a byte boundary, so\n  that the decompressor can get all input data available so far.  (In\n  particular avail_in is zero after the call if enough output space has been\n  provided before the call.) Flushing may degrade compression for some\n  compression algorithms and so it should be used only when necessary.  This\n  completes the current deflate block and follows it with an empty stored block\n  that is three bits plus filler bits to the next byte, followed by four bytes\n  (00 00 ff ff).\n\n    If flush is set to Z_PARTIAL_FLUSH, all pending output is flushed to the\n  output buffer, but the output is not aligned to a byte boundary.  All of the\n  input data so far will be available to the decompressor, as for Z_SYNC_FLUSH.\n  This completes the current deflate block and follows it with an empty fixed\n  codes block that is 10 bits long.  This assures that enough bytes are output\n  in order for the decompressor to finish the block before the empty fixed\n  codes block.\n\n    If flush is set to Z_BLOCK, a deflate block is completed and emitted, as\n  for Z_SYNC_FLUSH, but the output is not aligned on a byte boundary, and up to\n  seven bits of the current block are held to be written as the next byte after\n  the next deflate block is completed.  In this case, the decompressor may not\n  be provided enough bits at this point in order to complete decompression of\n  the data provided so far to the compressor.  It may need to wait for the next\n  block to be emitted.  This is for advanced applications that need to control\n  the emission of deflate blocks.\n\n    If flush is set to Z_FULL_FLUSH, all output is flushed as with\n  Z_SYNC_FLUSH, and the compression state is reset so that decompression can\n  restart from this point if previous compressed data has been damaged or if\n  random access is desired.  Using Z_FULL_FLUSH too often can seriously degrade\n  compression.\n\n    If deflate returns with avail_out == 0, this function must be called again\n  with the same value of the flush parameter and more output space (updated\n  avail_out), until the flush is complete (deflate returns with non-zero\n  avail_out).  In the case of a Z_FULL_FLUSH or Z_SYNC_FLUSH, make sure that\n  avail_out is greater than six when the flush marker begins, in order to avoid\n  repeated flush markers upon calling deflate() again when avail_out == 0.\n\n    If the parameter flush is set to Z_FINISH, pending input is processed,\n  pending output is flushed and deflate returns with Z_STREAM_END if there was\n  enough output space.  If deflate returns with Z_OK or Z_BUF_ERROR, this\n  function must be called again with Z_FINISH and more output space (updated\n  avail_out) but no more input data, until it returns with Z_STREAM_END or an\n  error.  After deflate has returned Z_STREAM_END, the only possible operations\n  on the stream are deflateReset or deflateEnd.\n\n    Z_FINISH can be used in the first deflate call after deflateInit if all the\n  compression is to be done in a single step.  In order to complete in one\n  call, avail_out must be at least the value returned by deflateBound (see\n  below).  Then deflate is guaranteed to return Z_STREAM_END.  If not enough\n  output space is provided, deflate will not return Z_STREAM_END, and it must\n  be called again as described above.\n\n    deflate() sets strm->adler to the Adler-32 checksum of all input read\n  so far (that is, total_in bytes).  If a gzip stream is being generated, then\n  strm->adler will be the CRC-32 checksum of the input read so far.  (See\n  deflateInit2 below.)\n\n    deflate() may update strm->data_type if it can make a good guess about\n  the input data type (Z_BINARY or Z_TEXT).  If in doubt, the data is\n  considered binary.  This field is only for information purposes and does not\n  affect the compression algorithm in any manner.\n\n    deflate() returns Z_OK if some progress has been made (more input\n  processed or more output produced), Z_STREAM_END if all input has been\n  consumed and all output has been produced (only when flush is set to\n  Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example\n  if next_in or next_out was Z_NULL or the state was inadvertently written over\n  by the application), or Z_BUF_ERROR if no progress is possible (for example\n  avail_in or avail_out was zero).  Note that Z_BUF_ERROR is not fatal, and\n  deflate() can be called again with more input and more output space to\n  continue compressing.\n*/\n\n\nZEXTERN int ZEXPORT deflateEnd(z_streamp strm);\n/*\n     All dynamically allocated data structures for this stream are freed.\n   This function discards any unprocessed input and does not flush any pending\n   output.\n\n     deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the\n   stream state was inconsistent, Z_DATA_ERROR if the stream was freed\n   prematurely (some input or output was discarded).  In the error case, msg\n   may be set but then points to a static string (which must not be\n   deallocated).\n*/\n\n\n/*\nZEXTERN int ZEXPORT inflateInit(z_streamp strm);\n\n     Initializes the internal stream state for decompression.  The fields\n   next_in, avail_in, zalloc, zfree and opaque must be initialized before by\n   the caller.  In the current version of inflate, the provided input is not\n   read or consumed.  The allocation of a sliding window will be deferred to\n   the first call of inflate (if the decompression does not complete on the\n   first call).  If zalloc and zfree are set to Z_NULL, inflateInit updates\n   them to use default allocation functions.  total_in, total_out, adler, and\n   msg are initialized.\n\n     inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough\n   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the\n   version assumed by the caller, or Z_STREAM_ERROR if the parameters are\n   invalid, such as a null pointer to the structure.  msg is set to null if\n   there is no error message.  inflateInit does not perform any decompression.\n   Actual decompression will be done by inflate().  So next_in, and avail_in,\n   next_out, and avail_out are unused and unchanged.  The current\n   implementation of inflateInit() does not process any header information --\n   that is deferred until inflate() is called.\n*/\n\n\nZEXTERN int ZEXPORT inflate(z_streamp strm, int flush);\n/*\n    inflate decompresses as much data as possible, and stops when the input\n  buffer becomes empty or the output buffer becomes full.  It may introduce\n  some output latency (reading input without producing any output) except when\n  forced to flush.\n\n  The detailed semantics are as follows.  inflate performs one or both of the\n  following actions:\n\n  - Decompress more input starting at next_in and update next_in and avail_in\n    accordingly.  If not all input can be processed (because there is not\n    enough room in the output buffer), then next_in and avail_in are updated\n    accordingly, and processing will resume at this point for the next call of\n    inflate().\n\n  - Generate more output starting at next_out and update next_out and avail_out\n    accordingly.  inflate() provides as much output as possible, until there is\n    no more input data or no more space in the output buffer (see below about\n    the flush parameter).\n\n    Before the call of inflate(), the application should ensure that at least\n  one of the actions is possible, by providing more input and/or consuming more\n  output, and updating the next_* and avail_* values accordingly.  If the\n  caller of inflate() does not provide both available input and available\n  output space, it is possible that there will be no progress made.  The\n  application can consume the uncompressed output when it wants, for example\n  when the output buffer is full (avail_out == 0), or after each call of\n  inflate().  If inflate returns Z_OK and with zero avail_out, it must be\n  called again after making room in the output buffer because there might be\n  more output pending.\n\n    The flush parameter of inflate() can be Z_NO_FLUSH, Z_SYNC_FLUSH, Z_FINISH,\n  Z_BLOCK, or Z_TREES.  Z_SYNC_FLUSH requests that inflate() flush as much\n  output as possible to the output buffer.  Z_BLOCK requests that inflate()\n  stop if and when it gets to the next deflate block boundary.  When decoding\n  the zlib or gzip format, this will cause inflate() to return immediately\n  after the header and before the first block.  When doing a raw inflate,\n  inflate() will go ahead and process the first block, and will return when it\n  gets to the end of that block, or when it runs out of data.\n\n    The Z_BLOCK option assists in appending to or combining deflate streams.\n  To assist in this, on return inflate() always sets strm->data_type to the\n  number of unused bits in the last byte taken from strm->next_in, plus 64 if\n  inflate() is currently decoding the last block in the deflate stream, plus\n  128 if inflate() returned immediately after decoding an end-of-block code or\n  decoding the complete header up to just before the first byte of the deflate\n  stream.  The end-of-block will not be indicated until all of the uncompressed\n  data from that block has been written to strm->next_out.  The number of\n  unused bits may in general be greater than seven, except when bit 7 of\n  data_type is set, in which case the number of unused bits will be less than\n  eight.  data_type is set as noted here every time inflate() returns for all\n  flush options, and so can be used to determine the amount of currently\n  consumed input in bits.\n\n    The Z_TREES option behaves as Z_BLOCK does, but it also returns when the\n  end of each deflate block header is reached, before any actual data in that\n  block is decoded.  This allows the caller to determine the length of the\n  deflate block header for later use in random access within a deflate block.\n  256 is added to the value of strm->data_type when inflate() returns\n  immediately after reaching the end of the deflate block header.\n\n    inflate() should normally be called until it returns Z_STREAM_END or an\n  error.  However if all decompression is to be performed in a single step (a\n  single call of inflate), the parameter flush should be set to Z_FINISH.  In\n  this case all pending input is processed and all pending output is flushed;\n  avail_out must be large enough to hold all of the uncompressed data for the\n  operation to complete.  (The size of the uncompressed data may have been\n  saved by the compressor for this purpose.)  The use of Z_FINISH is not\n  required to perform an inflation in one step.  However it may be used to\n  inform inflate that a faster approach can be used for the single inflate()\n  call.  Z_FINISH also informs inflate to not maintain a sliding window if the\n  stream completes, which reduces inflate's memory footprint.  If the stream\n  does not complete, either because not all of the stream is provided or not\n  enough output space is provided, then a sliding window will be allocated and\n  inflate() can be called again to continue the operation as if Z_NO_FLUSH had\n  been used.\n\n     In this implementation, inflate() always flushes as much output as\n  possible to the output buffer, and always uses the faster approach on the\n  first call.  So the effects of the flush parameter in this implementation are\n  on the return value of inflate() as noted below, when inflate() returns early\n  when Z_BLOCK or Z_TREES is used, and when inflate() avoids the allocation of\n  memory for a sliding window when Z_FINISH is used.\n\n     If a preset dictionary is needed after this call (see inflateSetDictionary\n  below), inflate sets strm->adler to the Adler-32 checksum of the dictionary\n  chosen by the compressor and returns Z_NEED_DICT; otherwise it sets\n  strm->adler to the Adler-32 checksum of all output produced so far (that is,\n  total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described\n  below.  At the end of the stream, inflate() checks that its computed Adler-32\n  checksum is equal to that saved by the compressor and returns Z_STREAM_END\n  only if the checksum is correct.\n\n    inflate() can decompress and check either zlib-wrapped or gzip-wrapped\n  deflate data.  The header type is detected automatically, if requested when\n  initializing with inflateInit2().  Any information contained in the gzip\n  header is not retained unless inflateGetHeader() is used.  When processing\n  gzip-wrapped deflate data, strm->adler32 is set to the CRC-32 of the output\n  produced so far.  The CRC-32 is checked against the gzip trailer, as is the\n  uncompressed length, modulo 2^32.\n\n    inflate() returns Z_OK if some progress has been made (more input processed\n  or more output produced), Z_STREAM_END if the end of the compressed data has\n  been reached and all uncompressed output has been produced, Z_NEED_DICT if a\n  preset dictionary is needed at this point, Z_DATA_ERROR if the input data was\n  corrupted (input stream not conforming to the zlib format or incorrect check\n  value, in which case strm->msg points to a string with a more specific\n  error), Z_STREAM_ERROR if the stream structure was inconsistent (for example\n  next_in or next_out was Z_NULL, or the state was inadvertently written over\n  by the application), Z_MEM_ERROR if there was not enough memory, Z_BUF_ERROR\n  if no progress was possible or if there was not enough room in the output\n  buffer when Z_FINISH is used.  Note that Z_BUF_ERROR is not fatal, and\n  inflate() can be called again with more input and more output space to\n  continue decompressing.  If Z_DATA_ERROR is returned, the application may\n  then call inflateSync() to look for a good compression block if a partial\n  recovery of the data is to be attempted.\n*/\n\n\nZEXTERN int ZEXPORT inflateEnd(z_streamp strm);\n/*\n     All dynamically allocated data structures for this stream are freed.\n   This function discards any unprocessed input and does not flush any pending\n   output.\n\n     inflateEnd returns Z_OK if success, or Z_STREAM_ERROR if the stream state\n   was inconsistent.\n*/\n\n\n                        /* Advanced functions */\n\n/*\n    The following functions are needed only in some special applications.\n*/\n\n/*\nZEXTERN int ZEXPORT deflateInit2(z_streamp strm,\n                                 int level,\n                                 int method,\n                                 int windowBits,\n                                 int memLevel,\n                                 int strategy);\n\n     This is another version of deflateInit with more compression options.  The\n   fields zalloc, zfree and opaque must be initialized before by the caller.\n\n     The method parameter is the compression method.  It must be Z_DEFLATED in\n   this version of the library.\n\n     The windowBits parameter is the base two logarithm of the window size\n   (the size of the history buffer).  It should be in the range 8..15 for this\n   version of the library.  Larger values of this parameter result in better\n   compression at the expense of memory usage.  The default value is 15 if\n   deflateInit is used instead.\n\n     For the current implementation of deflate(), a windowBits value of 8 (a\n   window size of 256 bytes) is not supported.  As a result, a request for 8\n   will result in 9 (a 512-byte window).  In that case, providing 8 to\n   inflateInit2() will result in an error when the zlib header with 9 is\n   checked against the initialization of inflate().  The remedy is to not use 8\n   with deflateInit2() with this initialization, or at least in that case use 9\n   with inflateInit2().\n\n     windowBits can also be -8..-15 for raw deflate.  In this case, -windowBits\n   determines the window size.  deflate() will then generate raw deflate data\n   with no zlib header or trailer, and will not compute a check value.\n\n     windowBits can also be greater than 15 for optional gzip encoding.  Add\n   16 to windowBits to write a simple gzip header and trailer around the\n   compressed data instead of a zlib wrapper.  The gzip header will have no\n   file name, no extra data, no comment, no modification time (set to zero), no\n   header crc, and the operating system will be set to the appropriate value,\n   if the operating system was determined at compile time.  If a gzip stream is\n   being written, strm->adler is a CRC-32 instead of an Adler-32.\n\n     For raw deflate or gzip encoding, a request for a 256-byte window is\n   rejected as invalid, since only the zlib header provides a means of\n   transmitting the window size to the decompressor.\n\n     The memLevel parameter specifies how much memory should be allocated\n   for the internal compression state.  memLevel=1 uses minimum memory but is\n   slow and reduces compression ratio; memLevel=9 uses maximum memory for\n   optimal speed.  The default value is 8.  See zconf.h for total memory usage\n   as a function of windowBits and memLevel.\n\n     The strategy parameter is used to tune the compression algorithm.  Use the\n   value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a\n   filter (or predictor), Z_RLE to limit match distances to one (run-length\n   encoding), or Z_HUFFMAN_ONLY to force Huffman encoding only (no string\n   matching).  Filtered data consists mostly of small values with a somewhat\n   random distribution, as produced by the PNG filters.  In this case, the\n   compression algorithm is tuned to compress them better.  The effect of\n   Z_FILTERED is to force more Huffman coding and less string matching than the\n   default; it is intermediate between Z_DEFAULT_STRATEGY and Z_HUFFMAN_ONLY.\n   Z_RLE is almost as fast as Z_HUFFMAN_ONLY, but should give better\n   compression for PNG image data than Huffman only.  The degree of string\n   matching from most to none is: Z_DEFAULT_STRATEGY, Z_FILTERED, Z_RLE, then\n   Z_HUFFMAN_ONLY. The strategy parameter affects the compression ratio but\n   never the correctness of the compressed output, even if it is not set\n   optimally for the given data.  Z_FIXED uses the default string matching, but\n   prevents the use of dynamic Huffman codes, allowing for a simpler decoder\n   for special applications.\n\n     deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough\n   memory, Z_STREAM_ERROR if any parameter is invalid (such as an invalid\n   method), or Z_VERSION_ERROR if the zlib library version (zlib_version) is\n   incompatible with the version assumed by the caller (ZLIB_VERSION).  msg is\n   set to null if there is no error message.  deflateInit2 does not perform any\n   compression: this will be done by deflate().\n*/\n\nZEXTERN int ZEXPORT deflateSetDictionary(z_streamp strm,\n                                         const Bytef *dictionary,\n                                         uInt  dictLength);\n/*\n     Initializes the compression dictionary from the given byte sequence\n   without producing any compressed output.  When using the zlib format, this\n   function must be called immediately after deflateInit, deflateInit2 or\n   deflateReset, and before any call of deflate.  When doing raw deflate, this\n   function must be called either before any call of deflate, or immediately\n   after the completion of a deflate block, i.e. after all input has been\n   consumed and all output has been delivered when using any of the flush\n   options Z_BLOCK, Z_PARTIAL_FLUSH, Z_SYNC_FLUSH, or Z_FULL_FLUSH.  The\n   compressor and decompressor must use exactly the same dictionary (see\n   inflateSetDictionary).\n\n     The dictionary should consist of strings (byte sequences) that are likely\n   to be encountered later in the data to be compressed, with the most commonly\n   used strings preferably put towards the end of the dictionary.  Using a\n   dictionary is most useful when the data to be compressed is short and can be\n   predicted with good accuracy; the data can then be compressed better than\n   with the default empty dictionary.\n\n     Depending on the size of the compression data structures selected by\n   deflateInit or deflateInit2, a part of the dictionary may in effect be\n   discarded, for example if the dictionary is larger than the window size\n   provided in deflateInit or deflateInit2.  Thus the strings most likely to be\n   useful should be put at the end of the dictionary, not at the front.  In\n   addition, the current implementation of deflate will use at most the window\n   size minus 262 bytes of the provided dictionary.\n\n     Upon return of this function, strm->adler is set to the Adler-32 value\n   of the dictionary; the decompressor may later use this value to determine\n   which dictionary has been used by the compressor.  (The Adler-32 value\n   applies to the whole dictionary even if only a subset of the dictionary is\n   actually used by the compressor.) If a raw deflate was requested, then the\n   Adler-32 value is not computed and strm->adler is not set.\n\n     deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a\n   parameter is invalid (e.g.  dictionary being Z_NULL) or the stream state is\n   inconsistent (for example if deflate has already been called for this stream\n   or if not at a block boundary for raw deflate).  deflateSetDictionary does\n   not perform any compression: this will be done by deflate().\n*/\n\nZEXTERN int ZEXPORT deflateGetDictionary(z_streamp strm,\n                                         Bytef *dictionary,\n                                         uInt  *dictLength);\n/*\n     Returns the sliding dictionary being maintained by deflate.  dictLength is\n   set to the number of bytes in the dictionary, and that many bytes are copied\n   to dictionary.  dictionary must have enough space, where 32768 bytes is\n   always enough.  If deflateGetDictionary() is called with dictionary equal to\n   Z_NULL, then only the dictionary length is returned, and nothing is copied.\n   Similarly, if dictLength is Z_NULL, then it is not set.\n\n     deflateGetDictionary() may return a length less than the window size, even\n   when more than the window size in input has been provided. It may return up\n   to 258 bytes less in that case, due to how zlib's implementation of deflate\n   manages the sliding window and lookahead for matches, where matches can be\n   up to 258 bytes long. If the application needs the last window-size bytes of\n   input, then that would need to be saved by the application outside of zlib.\n\n     deflateGetDictionary returns Z_OK on success, or Z_STREAM_ERROR if the\n   stream state is inconsistent.\n*/\n\nZEXTERN int ZEXPORT deflateCopy(z_streamp dest,\n                                z_streamp source);\n/*\n     Sets the destination stream as a complete copy of the source stream.\n\n     This function can be useful when several compression strategies will be\n   tried, for example when there are several ways of pre-processing the input\n   data with a filter.  The streams that will be discarded should then be freed\n   by calling deflateEnd.  Note that deflateCopy duplicates the internal\n   compression state which can be quite large, so this strategy is slow and can\n   consume lots of memory.\n\n     deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not\n   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent\n   (such as zalloc being Z_NULL).  msg is left unchanged in both source and\n   destination.\n*/\n\nZEXTERN int ZEXPORT deflateReset(z_streamp strm);\n/*\n     This function is equivalent to deflateEnd followed by deflateInit, but\n   does not free and reallocate the internal compression state.  The stream\n   will leave the compression level and any other attributes that may have been\n   set unchanged.  total_in, total_out, adler, and msg are initialized.\n\n     deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source\n   stream state was inconsistent (such as zalloc or state being Z_NULL).\n*/\n\nZEXTERN int ZEXPORT deflateParams(z_streamp strm,\n                                  int level,\n                                  int strategy);\n/*\n     Dynamically update the compression level and compression strategy.  The\n   interpretation of level and strategy is as in deflateInit2().  This can be\n   used to switch between compression and straight copy of the input data, or\n   to switch to a different kind of input data requiring a different strategy.\n   If the compression approach (which is a function of the level) or the\n   strategy is changed, and if there have been any deflate() calls since the\n   state was initialized or reset, then the input available so far is\n   compressed with the old level and strategy using deflate(strm, Z_BLOCK).\n   There are three approaches for the compression levels 0, 1..3, and 4..9\n   respectively.  The new level and strategy will take effect at the next call\n   of deflate().\n\n     If a deflate(strm, Z_BLOCK) is performed by deflateParams(), and it does\n   not have enough output space to complete, then the parameter change will not\n   take effect.  In this case, deflateParams() can be called again with the\n   same parameters and more output space to try again.\n\n     In order to assure a change in the parameters on the first try, the\n   deflate stream should be flushed using deflate() with Z_BLOCK or other flush\n   request until strm.avail_out is not zero, before calling deflateParams().\n   Then no more input data should be provided before the deflateParams() call.\n   If this is done, the old level and strategy will be applied to the data\n   compressed before deflateParams(), and the new level and strategy will be\n   applied to the data compressed after deflateParams().\n\n     deflateParams returns Z_OK on success, Z_STREAM_ERROR if the source stream\n   state was inconsistent or if a parameter was invalid, or Z_BUF_ERROR if\n   there was not enough output space to complete the compression of the\n   available input data before a change in the strategy or approach.  Note that\n   in the case of a Z_BUF_ERROR, the parameters are not changed.  A return\n   value of Z_BUF_ERROR is not fatal, in which case deflateParams() can be\n   retried with more output space.\n*/\n\nZEXTERN int ZEXPORT deflateTune(z_streamp strm,\n                                int good_length,\n                                int max_lazy,\n                                int nice_length,\n                                int max_chain);\n/*\n     Fine tune deflate's internal compression parameters.  This should only be\n   used by someone who understands the algorithm used by zlib's deflate for\n   searching for the best matching string, and even then only by the most\n   fanatic optimizer trying to squeeze out the last compressed bit for their\n   specific input data.  Read the deflate.c source code for the meaning of the\n   max_lazy, good_length, nice_length, and max_chain parameters.\n\n     deflateTune() can be called after deflateInit() or deflateInit2(), and\n   returns Z_OK on success, or Z_STREAM_ERROR for an invalid deflate stream.\n */\n\nZEXTERN uLong ZEXPORT deflateBound(z_streamp strm,\n                                   uLong sourceLen);\n/*\n     deflateBound() returns an upper bound on the compressed size after\n   deflation of sourceLen bytes.  It must be called after deflateInit() or\n   deflateInit2(), and after deflateSetHeader(), if used.  This would be used\n   to allocate an output buffer for deflation in a single pass, and so would be\n   called before deflate().  If that first deflate() call is provided the\n   sourceLen input bytes, an output buffer allocated to the size returned by\n   deflateBound(), and the flush value Z_FINISH, then deflate() is guaranteed\n   to return Z_STREAM_END.  Note that it is possible for the compressed size to\n   be larger than the value returned by deflateBound() if flush options other\n   than Z_FINISH or Z_NO_FLUSH are used.\n*/\n\nZEXTERN int ZEXPORT deflatePending(z_streamp strm,\n                                   unsigned *pending,\n                                   int *bits);\n/*\n     deflatePending() returns the number of bytes and bits of output that have\n   been generated, but not yet provided in the available output.  The bytes not\n   provided would be due to the available output space having being consumed.\n   The number of bits of output not provided are between 0 and 7, where they\n   await more bits to join them in order to fill out a full byte.  If pending\n   or bits are Z_NULL, then those values are not set.\n\n     deflatePending returns Z_OK if success, or Z_STREAM_ERROR if the source\n   stream state was inconsistent.\n */\n\nZEXTERN int ZEXPORT deflateUsed(z_streamp strm,\n                                int *bits);\n/*\n     deflateUsed() returns in *bits the most recent number of deflate bits used\n   in the last byte when flushing to a byte boundary. The result is in 1..8, or\n   0 if there has not yet been a flush. This helps determine the location of\n   the last bit of a deflate stream.\n\n     deflateUsed returns Z_OK if success, or Z_STREAM_ERROR if the source\n   stream state was inconsistent.\n */\n\nZEXTERN int ZEXPORT deflatePrime(z_streamp strm,\n                                 int bits,\n                                 int value);\n/*\n     deflatePrime() inserts bits in the deflate output stream.  The intent\n   is that this function is used to start off the deflate output with the bits\n   leftover from a previous deflate stream when appending to it.  As such, this\n   function can only be used for raw deflate, and must be used before the first\n   deflate() call after a deflateInit2() or deflateReset().  bits must be less\n   than or equal to 16, and that many of the least significant bits of value\n   will be inserted in the output.\n\n     deflatePrime returns Z_OK if success, Z_BUF_ERROR if there was not enough\n   room in the internal buffer to insert the bits, or Z_STREAM_ERROR if the\n   source stream state was inconsistent.\n*/\n\nZEXTERN int ZEXPORT deflateSetHeader(z_streamp strm,\n                                     gz_headerp head);\n/*\n     deflateSetHeader() provides gzip header information for when a gzip\n   stream is requested by deflateInit2().  deflateSetHeader() may be called\n   after deflateInit2() or deflateReset() and before the first call of\n   deflate().  The text, time, os, extra field, name, and comment information\n   in the provided gz_header structure are written to the gzip header (xflag is\n   ignored -- the extra flags are set according to the compression level).  The\n   caller must assure that, if not Z_NULL, name and comment are terminated with\n   a zero byte, and that if extra is not Z_NULL, that extra_len bytes are\n   available there.  If hcrc is true, a gzip header crc is included.  Note that\n   the current versions of the command-line version of gzip (up through version\n   1.3.x) do not support header crc's, and will report that it is a \"multi-part\n   gzip file\" and give up.\n\n     If deflateSetHeader is not used, the default gzip header has text false,\n   the time set to zero, and os set to the current operating system, with no\n   extra, name, or comment fields.  The gzip header is returned to the default\n   state by deflateReset().\n\n     deflateSetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source\n   stream state was inconsistent.\n*/\n\n/*\nZEXTERN int ZEXPORT inflateInit2(z_streamp strm,\n                                 int windowBits);\n\n     This is another version of inflateInit with an extra parameter.  The\n   fields next_in, avail_in, zalloc, zfree and opaque must be initialized\n   before by the caller.\n\n     The windowBits parameter is the base two logarithm of the maximum window\n   size (the size of the history buffer).  It should be in the range 8..15 for\n   this version of the library.  The default value is 15 if inflateInit is used\n   instead.  windowBits must be greater than or equal to the windowBits value\n   provided to deflateInit2() while compressing, or it must be equal to 15 if\n   deflateInit2() was not used.  If a compressed stream with a larger window\n   size is given as input, inflate() will return with the error code\n   Z_DATA_ERROR instead of trying to allocate a larger window.\n\n     windowBits can also be zero to request that inflate use the window size in\n   the zlib header of the compressed stream.\n\n     windowBits can also be -8..-15 for raw inflate.  In this case, -windowBits\n   determines the window size.  inflate() will then process raw deflate data,\n   not looking for a zlib or gzip header, not generating a check value, and not\n   looking for any check values for comparison at the end of the stream.  This\n   is for use with other formats that use the deflate compressed data format\n   such as zip.  Those formats provide their own check values.  If a custom\n   format is developed using the raw deflate format for compressed data, it is\n   recommended that a check value such as an Adler-32 or a CRC-32 be applied to\n   the uncompressed data as is done in the zlib, gzip, and zip formats.  For\n   most applications, the zlib format should be used as is.  Note that comments\n   above on the use in deflateInit2() applies to the magnitude of windowBits.\n\n     windowBits can also be greater than 15 for optional gzip decoding.  Add\n   32 to windowBits to enable zlib and gzip decoding with automatic header\n   detection, or add 16 to decode only the gzip format (the zlib format will\n   return a Z_DATA_ERROR).  If a gzip stream is being decoded, strm->adler is a\n   CRC-32 instead of an Adler-32.  Unlike the gunzip utility and gzread() (see\n   below), inflate() will *not* automatically decode concatenated gzip members.\n   inflate() will return Z_STREAM_END at the end of the gzip member.  The state\n   would need to be reset to continue decoding a subsequent gzip member.  This\n   *must* be done if there is more data after a gzip member, in order for the\n   decompression to be compliant with the gzip standard (RFC 1952).\n\n     inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough\n   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the\n   version assumed by the caller, or Z_STREAM_ERROR if the parameters are\n   invalid, such as a null pointer to the structure.  msg is set to null if\n   there is no error message.  inflateInit2 does not perform any decompression\n   apart from possibly reading the zlib header if present: actual decompression\n   will be done by inflate().  (So next_in and avail_in may be modified, but\n   next_out and avail_out are unused and unchanged.) The current implementation\n   of inflateInit2() does not process any header information -- that is\n   deferred until inflate() is called.\n*/\n\nZEXTERN int ZEXPORT inflateSetDictionary(z_streamp strm,\n                                         const Bytef *dictionary,\n                                         uInt  dictLength);\n/*\n     Initializes the decompression dictionary from the given uncompressed byte\n   sequence.  This function must be called immediately after a call of inflate,\n   if that call returned Z_NEED_DICT.  The dictionary chosen by the compressor\n   can be determined from the Adler-32 value returned by that call of inflate.\n   The compressor and decompressor must use exactly the same dictionary (see\n   deflateSetDictionary).  For raw inflate, this function can be called at any\n   time to set the dictionary.  If the provided dictionary is smaller than the\n   window and there is already data in the window, then the provided dictionary\n   will amend what's there.  The application must insure that the dictionary\n   that was used for compression is provided.\n\n     inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a\n   parameter is invalid (e.g.  dictionary being Z_NULL) or the stream state is\n   inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the\n   expected one (incorrect Adler-32 value).  inflateSetDictionary does not\n   perform any decompression: this will be done by subsequent calls of\n   inflate().\n*/\n\nZEXTERN int ZEXPORT inflateGetDictionary(z_streamp strm,\n                                         Bytef *dictionary,\n                                         uInt  *dictLength);\n/*\n     Returns the sliding dictionary being maintained by inflate.  dictLength is\n   set to the number of bytes in the dictionary, and that many bytes are copied\n   to dictionary.  dictionary must have enough space, where 32768 bytes is\n   always enough.  If inflateGetDictionary() is called with dictionary equal to\n   Z_NULL, then only the dictionary length is returned, and nothing is copied.\n   Similarly, if dictLength is Z_NULL, then it is not set.\n\n     inflateGetDictionary returns Z_OK on success, or Z_STREAM_ERROR if the\n   stream state is inconsistent.\n*/\n\nZEXTERN int ZEXPORT inflateSync(z_streamp strm);\n/*\n     Skips invalid compressed data until a possible full flush point (see above\n   for the description of deflate with Z_FULL_FLUSH) can be found, or until all\n   available input is skipped.  No output is provided.\n\n     inflateSync searches for a 00 00 FF FF pattern in the compressed data.\n   All full flush points have this pattern, but not all occurrences of this\n   pattern are full flush points.\n\n     inflateSync returns Z_OK if a possible full flush point has been found,\n   Z_BUF_ERROR if no more input was provided, Z_DATA_ERROR if no flush point\n   has been found, or Z_STREAM_ERROR if the stream structure was inconsistent.\n   In the success case, the application may save the current value of total_in\n   which indicates where valid compressed data was found.  In the error case,\n   the application may repeatedly call inflateSync, providing more input each\n   time, until success or end of the input data.\n*/\n\nZEXTERN int ZEXPORT inflateCopy(z_streamp dest,\n                                z_streamp source);\n/*\n     Sets the destination stream as a complete copy of the source stream.\n\n     This function can be useful when randomly accessing a large stream.  The\n   first pass through the stream can periodically record the inflate state,\n   allowing restarting inflate at those points when randomly accessing the\n   stream.\n\n     inflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not\n   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent\n   (such as zalloc being Z_NULL).  msg is left unchanged in both source and\n   destination.\n*/\n\nZEXTERN int ZEXPORT inflateReset(z_streamp strm);\n/*\n     This function is equivalent to inflateEnd followed by inflateInit,\n   but does not free and reallocate the internal decompression state.  The\n   stream will keep attributes that may have been set by inflateInit2.\n   total_in, total_out, adler, and msg are initialized.\n\n     inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source\n   stream state was inconsistent (such as zalloc or state being Z_NULL).\n*/\n\nZEXTERN int ZEXPORT inflateReset2(z_streamp strm,\n                                  int windowBits);\n/*\n     This function is the same as inflateReset, but it also permits changing\n   the wrap and window size requests.  The windowBits parameter is interpreted\n   the same as it is for inflateInit2.  If the window size is changed, then the\n   memory allocated for the window is freed, and the window will be reallocated\n   by inflate() if needed.\n\n     inflateReset2 returns Z_OK if success, or Z_STREAM_ERROR if the source\n   stream state was inconsistent (such as zalloc or state being Z_NULL), or if\n   the windowBits parameter is invalid.\n*/\n\nZEXTERN int ZEXPORT inflatePrime(z_streamp strm,\n                                 int bits,\n                                 int value);\n/*\n     This function inserts bits in the inflate input stream.  The intent is\n   that this function is used to start inflating at a bit position in the\n   middle of a byte.  The provided bits will be used before any bytes are used\n   from next_in.  This function should only be used with raw inflate, and\n   should be used before the first inflate() call after inflateInit2() or\n   inflateReset().  bits must be less than or equal to 16, and that many of the\n   least significant bits of value will be inserted in the input.\n\n     If bits is negative, then the input stream bit buffer is emptied.  Then\n   inflatePrime() can be called again to put bits in the buffer.  This is used\n   to clear out bits leftover after feeding inflate a block description prior\n   to feeding inflate codes.\n\n     inflatePrime returns Z_OK if success, or Z_STREAM_ERROR if the source\n   stream state was inconsistent.\n*/\n\nZEXTERN long ZEXPORT inflateMark(z_streamp strm);\n/*\n     This function returns two values, one in the lower 16 bits of the return\n   value, and the other in the remaining upper bits, obtained by shifting the\n   return value down 16 bits.  If the upper value is -1 and the lower value is\n   zero, then inflate() is currently decoding information outside of a block.\n   If the upper value is -1 and the lower value is non-zero, then inflate is in\n   the middle of a stored block, with the lower value equaling the number of\n   bytes from the input remaining to copy.  If the upper value is not -1, then\n   it is the number of bits back from the current bit position in the input of\n   the code (literal or length/distance pair) currently being processed.  In\n   that case the lower value is the number of bytes already emitted for that\n   code.\n\n     A code is being processed if inflate is waiting for more input to complete\n   decoding of the code, or if it has completed decoding but is waiting for\n   more output space to write the literal or match data.\n\n     inflateMark() is used to mark locations in the input data for random\n   access, which may be at bit positions, and to note those cases where the\n   output of a code may span boundaries of random access blocks.  The current\n   location in the input stream can be determined from avail_in and data_type\n   as noted in the description for the Z_BLOCK flush parameter for inflate.\n\n     inflateMark returns the value noted above, or -65536 if the provided\n   source stream state was inconsistent.\n*/\n\nZEXTERN int ZEXPORT inflateGetHeader(z_streamp strm,\n                                     gz_headerp head);\n/*\n     inflateGetHeader() requests that gzip header information be stored in the\n   provided gz_header structure.  inflateGetHeader() may be called after\n   inflateInit2() or inflateReset(), and before the first call of inflate().\n   As inflate() processes the gzip stream, head->done is zero until the header\n   is completed, at which time head->done is set to one.  If a zlib stream is\n   being decoded, then head->done is set to -1 to indicate that there will be\n   no gzip header information forthcoming.  Note that Z_BLOCK or Z_TREES can be\n   used to force inflate() to return immediately after header processing is\n   complete and before any actual data is decompressed.\n\n     The text, time, xflags, and os fields are filled in with the gzip header\n   contents.  hcrc is set to true if there is a header CRC.  (The header CRC\n   was valid if done is set to one.) If extra is not Z_NULL, then extra_max\n   contains the maximum number of bytes to write to extra.  Once done is true,\n   extra_len contains the actual extra field length, and extra contains the\n   extra field, or that field truncated if extra_max is less than extra_len.\n   If name is not Z_NULL, then up to name_max characters are written there,\n   terminated with a zero unless the length is greater than name_max.  If\n   comment is not Z_NULL, then up to comm_max characters are written there,\n   terminated with a zero unless the length is greater than comm_max.  When any\n   of extra, name, or comment are not Z_NULL and the respective field is not\n   present in the header, then that field is set to Z_NULL to signal its\n   absence.  This allows the use of deflateSetHeader() with the returned\n   structure to duplicate the header.  However if those fields are set to\n   allocated memory, then the application will need to save those pointers\n   elsewhere so that they can be eventually freed.\n\n     If inflateGetHeader is not used, then the header information is simply\n   discarded.  The header is always checked for validity, including the header\n   CRC if present.  inflateReset() will reset the process to discard the header\n   information.  The application would need to call inflateGetHeader() again to\n   retrieve the header from the next gzip stream.\n\n     inflateGetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source\n   stream state was inconsistent.\n*/\n\n/*\nZEXTERN int ZEXPORT inflateBackInit(z_streamp strm, int windowBits,\n                                    unsigned char FAR *window);\n\n     Initialize the internal stream state for decompression using inflateBack()\n   calls.  The fields zalloc, zfree and opaque in strm must be initialized\n   before the call.  If zalloc and zfree are Z_NULL, then the default library-\n   derived memory allocation routines are used.  windowBits is the base two\n   logarithm of the window size, in the range 8..15.  window is a caller\n   supplied buffer of that size.  Except for special applications where it is\n   assured that deflate was used with small window sizes, windowBits must be 15\n   and a 32K byte window must be supplied to be able to decompress general\n   deflate streams.\n\n     See inflateBack() for the usage of these routines.\n\n     inflateBackInit will return Z_OK on success, Z_STREAM_ERROR if any of\n   the parameters are invalid, Z_MEM_ERROR if the internal state could not be\n   allocated, or Z_VERSION_ERROR if the version of the library does not match\n   the version of the header file.\n*/\n\ntypedef unsigned (*in_func)(void FAR *,\n                            z_const unsigned char FAR * FAR *);\ntypedef int (*out_func)(void FAR *, unsigned char FAR *, unsigned);\n\nZEXTERN int ZEXPORT inflateBack(z_streamp strm,\n                                in_func in, void FAR *in_desc,\n                                out_func out, void FAR *out_desc);\n/*\n     inflateBack() does a raw inflate with a single call using a call-back\n   interface for input and output.  This is potentially more efficient than\n   inflate() for file i/o applications, in that it avoids copying between the\n   output and the sliding window by simply making the window itself the output\n   buffer.  inflate() can be faster on modern CPUs when used with large\n   buffers.  inflateBack() trusts the application to not change the output\n   buffer passed by the output function, at least until inflateBack() returns.\n\n     inflateBackInit() must be called first to allocate the internal state\n   and to initialize the state with the user-provided window buffer.\n   inflateBack() may then be used multiple times to inflate a complete, raw\n   deflate stream with each call.  inflateBackEnd() is then called to free the\n   allocated state.\n\n     A raw deflate stream is one with no zlib or gzip header or trailer.\n   This routine would normally be used in a utility that reads zip or gzip\n   files and writes out uncompressed files.  The utility would decode the\n   header and process the trailer on its own, hence this routine expects only\n   the raw deflate stream to decompress.  This is different from the default\n   behavior of inflate(), which expects a zlib header and trailer around the\n   deflate stream.\n\n     inflateBack() uses two subroutines supplied by the caller that are then\n   called by inflateBack() for input and output.  inflateBack() calls those\n   routines until it reads a complete deflate stream and writes out all of the\n   uncompressed data, or until it encounters an error.  The function's\n   parameters and return types are defined above in the in_func and out_func\n   typedefs.  inflateBack() will call in(in_desc, &buf) which should return the\n   number of bytes of provided input, and a pointer to that input in buf.  If\n   there is no input available, in() must return zero -- buf is ignored in that\n   case -- and inflateBack() will return a buffer error.  inflateBack() will\n   call out(out_desc, buf, len) to write the uncompressed data buf[0..len-1].\n   out() should return zero on success, or non-zero on failure.  If out()\n   returns non-zero, inflateBack() will return with an error.  Neither in() nor\n   out() are permitted to change the contents of the window provided to\n   inflateBackInit(), which is also the buffer that out() uses to write from.\n   The length written by out() will be at most the window size.  Any non-zero\n   amount of input may be provided by in().\n\n     For convenience, inflateBack() can be provided input on the first call by\n   setting strm->next_in and strm->avail_in.  If that input is exhausted, then\n   in() will be called.  Therefore strm->next_in must be initialized before\n   calling inflateBack().  If strm->next_in is Z_NULL, then in() will be called\n   immediately for input.  If strm->next_in is not Z_NULL, then strm->avail_in\n   must also be initialized, and then if strm->avail_in is not zero, input will\n   initially be taken from strm->next_in[0 ..  strm->avail_in - 1].\n\n     The in_desc and out_desc parameters of inflateBack() is passed as the\n   first parameter of in() and out() respectively when they are called.  These\n   descriptors can be optionally used to pass any information that the caller-\n   supplied in() and out() functions need to do their job.\n\n     On return, inflateBack() will set strm->next_in and strm->avail_in to\n   pass back any unused input that was provided by the last in() call.  The\n   return values of inflateBack() can be Z_STREAM_END on success, Z_BUF_ERROR\n   if in() or out() returned an error, Z_DATA_ERROR if there was a format error\n   in the deflate stream (in which case strm->msg is set to indicate the nature\n   of the error), or Z_STREAM_ERROR if the stream was not properly initialized.\n   In the case of Z_BUF_ERROR, an input or output error can be distinguished\n   using strm->next_in which will be Z_NULL only if in() returned an error.  If\n   strm->next_in is not Z_NULL, then the Z_BUF_ERROR was due to out() returning\n   non-zero.  (in() will always be called before out(), so strm->next_in is\n   assured to be defined if out() returns non-zero.)  Note that inflateBack()\n   cannot return Z_OK.\n*/\n\nZEXTERN int ZEXPORT inflateBackEnd(z_streamp strm);\n/*\n     All memory allocated by inflateBackInit() is freed.\n\n     inflateBackEnd() returns Z_OK on success, or Z_STREAM_ERROR if the stream\n   state was inconsistent.\n*/\n\nZEXTERN uLong ZEXPORT zlibCompileFlags(void);\n/* Return flags indicating compile-time options.\n\n    Type sizes, two bits each, 00 = 16 bits, 01 = 32, 10 = 64, 11 = other:\n     1.0: size of uInt\n     3.2: size of uLong\n     5.4: size of voidpf (pointer)\n     7.6: size of z_off_t\n\n    Compiler, assembler, and debug options:\n     8: ZLIB_DEBUG\n     9: ASMV or ASMINF -- use ASM code\n     10: ZLIB_WINAPI -- exported functions use the WINAPI calling convention\n     11: 0 (reserved)\n\n    One-time table building (smaller code, but not thread-safe if true):\n     12: BUILDFIXED -- build static block decoding tables when needed\n     13: DYNAMIC_CRC_TABLE -- build CRC calculation tables when needed\n     14,15: 0 (reserved)\n\n    Library content (indicates missing functionality):\n     16: NO_GZCOMPRESS -- gz* functions cannot compress (to avoid linking\n                          deflate code when not needed)\n     17: NO_GZIP -- deflate can't write gzip streams, and inflate can't detect\n                    and decode gzip streams (to avoid linking crc code)\n     18-19: 0 (reserved)\n\n    Operation variations (changes in library functionality):\n     20: PKZIP_BUG_WORKAROUND -- slightly more permissive inflate\n     21: FASTEST -- deflate algorithm with only one, lowest compression level\n     22,23: 0 (reserved)\n\n    The sprintf variant used by gzprintf (zero is best):\n     24: 0 = vs*, 1 = s* -- 1 means limited to 20 arguments after the format\n     25: 0 = *nprintf, 1 = *printf -- 1 means gzprintf() not secure!\n     26: 0 = returns value, 1 = void -- 1 means inferred string length returned\n\n    Remainder:\n     27-31: 0 (reserved)\n */\n\n#ifndef Z_SOLO\n\n                        /* utility functions */\n\n/*\n     The following utility functions are implemented on top of the basic\n   stream-oriented functions.  To simplify the interface, some default options\n   are assumed (compression level and memory usage, standard memory allocation\n   functions).  The source code of these utility functions can be modified if\n   you need special options.\n*/\n\nZEXTERN int ZEXPORT compress(Bytef *dest,   uLongf *destLen,\n                             const Bytef *source, uLong sourceLen);\n/*\n     Compresses the source buffer into the destination buffer.  sourceLen is\n   the byte length of the source buffer.  Upon entry, destLen is the total size\n   of the destination buffer, which must be at least the value returned by\n   compressBound(sourceLen).  Upon exit, destLen is the actual size of the\n   compressed data.  compress() is equivalent to compress2() with a level\n   parameter of Z_DEFAULT_COMPRESSION.\n\n     compress returns Z_OK if success, Z_MEM_ERROR if there was not\n   enough memory, Z_BUF_ERROR if there was not enough room in the output\n   buffer.\n*/\n\nZEXTERN int ZEXPORT compress2(Bytef *dest,   uLongf *destLen,\n                              const Bytef *source, uLong sourceLen,\n                              int level);\n/*\n     Compresses the source buffer into the destination buffer.  The level\n   parameter has the same meaning as in deflateInit.  sourceLen is the byte\n   length of the source buffer.  Upon entry, destLen is the total size of the\n   destination buffer, which must be at least the value returned by\n   compressBound(sourceLen).  Upon exit, destLen is the actual size of the\n   compressed data.\n\n     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough\n   memory, Z_BUF_ERROR if there was not enough room in the output buffer,\n   Z_STREAM_ERROR if the level parameter is invalid.\n*/\n\nZEXTERN uLong ZEXPORT compressBound(uLong sourceLen);\n/*\n     compressBound() returns an upper bound on the compressed size after\n   compress() or compress2() on sourceLen bytes.  It would be used before a\n   compress() or compress2() call to allocate the destination buffer.\n*/\n\nZEXTERN int ZEXPORT uncompress(Bytef *dest,   uLongf *destLen,\n                               const Bytef *source, uLong sourceLen);\n/*\n     Decompresses the source buffer into the destination buffer.  sourceLen is\n   the byte length of the source buffer.  Upon entry, destLen is the total size\n   of the destination buffer, which must be large enough to hold the entire\n   uncompressed data.  (The size of the uncompressed data must have been saved\n   previously by the compressor and transmitted to the decompressor by some\n   mechanism outside the scope of this compression library.) Upon exit, destLen\n   is the actual size of the uncompressed data.\n\n     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not\n   enough memory, Z_BUF_ERROR if there was not enough room in the output\n   buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete.  In\n   the case where there is not enough room, uncompress() will fill the output\n   buffer with the uncompressed data up to that point.\n*/\n\nZEXTERN int ZEXPORT uncompress2(Bytef *dest,   uLongf *destLen,\n                                const Bytef *source, uLong *sourceLen);\n/*\n     Same as uncompress, except that sourceLen is a pointer, where the\n   length of the source is *sourceLen.  On return, *sourceLen is the number of\n   source bytes consumed.\n*/\n\n                        /* gzip file access functions */\n\n/*\n     This library supports reading and writing files in gzip (.gz) format with\n   an interface similar to that of stdio, using the functions that start with\n   \"gz\".  The gzip format is different from the zlib format.  gzip is a gzip\n   wrapper, documented in RFC 1952, wrapped around a deflate stream.\n*/\n\ntypedef struct gzFile_s *gzFile;    /* semi-opaque gzip file descriptor */\n\n/*\nZEXTERN gzFile ZEXPORT gzopen(const char *path, const char *mode);\n\n     Open the gzip (.gz) file at path for reading and decompressing, or\n   compressing and writing.  The mode parameter is as in fopen (\"rb\" or \"wb\")\n   but can also include a compression level (\"wb9\") or a strategy: 'f' for\n   filtered data as in \"wb6f\", 'h' for Huffman-only compression as in \"wb1h\",\n   'R' for run-length encoding as in \"wb1R\", or 'F' for fixed code compression\n   as in \"wb9F\".  (See the description of deflateInit2 for more information\n   about the strategy parameter.)  'T' will request transparent writing or\n   appending with no compression and not using the gzip format.\n\n     \"a\" can be used instead of \"w\" to request that the gzip stream that will\n   be written be appended to the file.  \"+\" will result in an error, since\n   reading and writing to the same gzip file is not supported.  The addition of\n   \"x\" when writing will create the file exclusively, which fails if the file\n   already exists.  On systems that support it, the addition of \"e\" when\n   reading or writing will set the flag to close the file on an execve() call.\n\n     These functions, as well as gzip, will read and decode a sequence of gzip\n   streams in a file.  The append function of gzopen() can be used to create\n   such a file.  (Also see gzflush() for another way to do this.)  When\n   appending, gzopen does not test whether the file begins with a gzip stream,\n   nor does it look for the end of the gzip streams to begin appending.  gzopen\n   will simply append a gzip stream to the existing file.\n\n     gzopen can be used to read a file which is not in gzip format; in this\n   case gzread will directly read from the file without decompression.  When\n   reading, this will be detected automatically by looking for the magic two-\n   byte gzip header.\n\n     gzopen returns NULL if the file could not be opened, if there was\n   insufficient memory to allocate the gzFile state, or if an invalid mode was\n   specified (an 'r', 'w', or 'a' was not provided, or '+' was provided).\n   errno can be checked to determine if the reason gzopen failed was that the\n   file could not be opened.\n*/\n\nZEXTERN gzFile ZEXPORT gzdopen(int fd, const char *mode);\n/*\n     Associate a gzFile with the file descriptor fd.  File descriptors are\n   obtained from calls like open, dup, creat, pipe or fileno (if the file has\n   been previously opened with fopen).  The mode parameter is as in gzopen.\n\n     The next call of gzclose on the returned gzFile will also close the file\n   descriptor fd, just like fclose(fdopen(fd, mode)) closes the file descriptor\n   fd.  If you want to keep fd open, use fd = dup(fd_keep); gz = gzdopen(fd,\n   mode);.  The duplicated descriptor should be saved to avoid a leak, since\n   gzdopen does not close fd if it fails.  If you are using fileno() to get the\n   file descriptor from a FILE *, then you will have to use dup() to avoid\n   double-close()ing the file descriptor.  Both gzclose() and fclose() will\n   close the associated file descriptor, so they need to have different file\n   descriptors.\n\n     gzdopen returns NULL if there was insufficient memory to allocate the\n   gzFile state, if an invalid mode was specified (an 'r', 'w', or 'a' was not\n   provided, or '+' was provided), or if fd is -1.  The file descriptor is not\n   used until the next gz* read, write, seek, or close operation, so gzdopen\n   will not detect if fd is invalid (unless fd is -1).\n*/\n\nZEXTERN int ZEXPORT gzbuffer(gzFile file, unsigned size);\n/*\n     Set the internal buffer size used by this library's functions for file to\n   size.  The default buffer size is 8192 bytes.  This function must be called\n   after gzopen() or gzdopen(), and before any other calls that read or write\n   the file.  The buffer memory allocation is always deferred to the first read\n   or write.  Three times that size in buffer space is allocated.  A larger\n   buffer size of, for example, 64K or 128K bytes will noticeably increase the\n   speed of decompression (reading).\n\n     The new buffer size also affects the maximum length for gzprintf().\n\n     gzbuffer() returns 0 on success, or -1 on failure, such as being called\n   too late.\n*/\n\nZEXTERN int ZEXPORT gzsetparams(gzFile file, int level, int strategy);\n/*\n     Dynamically update the compression level and strategy for file.  See the\n   description of deflateInit2 for the meaning of these parameters. Previously\n   provided data is flushed before applying the parameter changes.\n\n     gzsetparams returns Z_OK if success, Z_STREAM_ERROR if the file was not\n   opened for writing, Z_ERRNO if there is an error writing the flushed data,\n   or Z_MEM_ERROR if there is a memory allocation error.\n*/\n\nZEXTERN int ZEXPORT gzread(gzFile file, voidp buf, unsigned len);\n/*\n     Read and decompress up to len uncompressed bytes from file into buf.  If\n   the input file is not in gzip format, gzread copies the given number of\n   bytes into the buffer directly from the file.\n\n     After reaching the end of a gzip stream in the input, gzread will continue\n   to read, looking for another gzip stream.  Any number of gzip streams may be\n   concatenated in the input file, and will all be decompressed by gzread().\n   If something other than a gzip stream is encountered after a gzip stream,\n   that remaining trailing garbage is ignored (and no error is returned).\n\n     gzread can be used to read a gzip file that is being concurrently written.\n   Upon reaching the end of the input, gzread will return with the available\n   data.  If the error code returned by gzerror is Z_OK or Z_BUF_ERROR, then\n   gzclearerr can be used to clear the end of file indicator in order to permit\n   gzread to be tried again.  Z_OK indicates that a gzip stream was completed\n   on the last gzread.  Z_BUF_ERROR indicates that the input file ended in the\n   middle of a gzip stream.  Note that gzread does not return -1 in the event\n   of an incomplete gzip stream.  This error is deferred until gzclose(), which\n   will return Z_BUF_ERROR if the last gzread ended in the middle of a gzip\n   stream.  Alternatively, gzerror can be used before gzclose to detect this\n   case.\n\n     gzread returns the number of uncompressed bytes actually read, less than\n   len for end of file, or -1 for error.  If len is too large to fit in an int,\n   then nothing is read, -1 is returned, and the error state is set to\n   Z_STREAM_ERROR.\n*/\n\nZEXTERN z_size_t ZEXPORT gzfread(voidp buf, z_size_t size, z_size_t nitems,\n                                 gzFile file);\n/*\n     Read and decompress up to nitems items of size size from file into buf,\n   otherwise operating as gzread() does.  This duplicates the interface of\n   stdio's fread(), with size_t request and return types.  If the library\n   defines size_t, then z_size_t is identical to size_t.  If not, then z_size_t\n   is an unsigned integer type that can contain a pointer.\n\n     gzfread() returns the number of full items read of size size, or zero if\n   the end of the file was reached and a full item could not be read, or if\n   there was an error.  gzerror() must be consulted if zero is returned in\n   order to determine if there was an error.  If the multiplication of size and\n   nitems overflows, i.e. the product does not fit in a z_size_t, then nothing\n   is read, zero is returned, and the error state is set to Z_STREAM_ERROR.\n\n     In the event that the end of file is reached and only a partial item is\n   available at the end, i.e. the remaining uncompressed data length is not a\n   multiple of size, then the final partial item is nevertheless read into buf\n   and the end-of-file flag is set.  The length of the partial item read is not\n   provided, but could be inferred from the result of gztell().  This behavior\n   is the same as the behavior of fread() implementations in common libraries,\n   but it prevents the direct use of gzfread() to read a concurrently written\n   file, resetting and retrying on end-of-file, when size is not 1.\n*/\n\nZEXTERN int ZEXPORT gzwrite(gzFile file, voidpc buf, unsigned len);\n/*\n     Compress and write the len uncompressed bytes at buf to file. gzwrite\n   returns the number of uncompressed bytes written or 0 in case of error.\n*/\n\nZEXTERN z_size_t ZEXPORT gzfwrite(voidpc buf, z_size_t size,\n                                  z_size_t nitems, gzFile file);\n/*\n     Compress and write nitems items of size size from buf to file, duplicating\n   the interface of stdio's fwrite(), with size_t request and return types.  If\n   the library defines size_t, then z_size_t is identical to size_t.  If not,\n   then z_size_t is an unsigned integer type that can contain a pointer.\n\n     gzfwrite() returns the number of full items written of size size, or zero\n   if there was an error.  If the multiplication of size and nitems overflows,\n   i.e. the product does not fit in a z_size_t, then nothing is written, zero\n   is returned, and the error state is set to Z_STREAM_ERROR.\n*/\n\nZEXTERN int ZEXPORTVA gzprintf(gzFile file, const char *format, ...);\n/*\n     Convert, format, compress, and write the arguments (...) to file under\n   control of the string format, as in fprintf.  gzprintf returns the number of\n   uncompressed bytes actually written, or a negative zlib error code in case\n   of error.  The number of uncompressed bytes written is limited to 8191, or\n   one less than the buffer size given to gzbuffer().  The caller should assure\n   that this limit is not exceeded.  If it is exceeded, then gzprintf() will\n   return an error (0) with nothing written.  In this case, there may also be a\n   buffer overflow with unpredictable consequences, which is possible only if\n   zlib was compiled with the insecure functions sprintf() or vsprintf(),\n   because the secure snprintf() or vsnprintf() functions were not available.\n   This can be determined using zlibCompileFlags().\n*/\n\nZEXTERN int ZEXPORT gzputs(gzFile file, const char *s);\n/*\n     Compress and write the given null-terminated string s to file, excluding\n   the terminating null character.\n\n     gzputs returns the number of characters written, or -1 in case of error.\n*/\n\nZEXTERN char * ZEXPORT gzgets(gzFile file, char *buf, int len);\n/*\n     Read and decompress bytes from file into buf, until len-1 characters are\n   read, or until a newline character is read and transferred to buf, or an\n   end-of-file condition is encountered.  If any characters are read or if len\n   is one, the string is terminated with a null character.  If no characters\n   are read due to an end-of-file or len is less than one, then the buffer is\n   left untouched.\n\n     gzgets returns buf which is a null-terminated string, or it returns NULL\n   for end-of-file or in case of error.  If there was an error, the contents at\n   buf are indeterminate.\n*/\n\nZEXTERN int ZEXPORT gzputc(gzFile file, int c);\n/*\n     Compress and write c, converted to an unsigned char, into file.  gzputc\n   returns the value that was written, or -1 in case of error.\n*/\n\nZEXTERN int ZEXPORT gzgetc(gzFile file);\n/*\n     Read and decompress one byte from file.  gzgetc returns this byte or -1\n   in case of end of file or error.  This is implemented as a macro for speed.\n   As such, it does not do all of the checking the other functions do.  I.e.\n   it does not check to see if file is NULL, nor whether the structure file\n   points to has been clobbered or not.\n*/\n\nZEXTERN int ZEXPORT gzungetc(int c, gzFile file);\n/*\n     Push c back onto the stream for file to be read as the first character on\n   the next read.  At least one character of push-back is always allowed.\n   gzungetc() returns the character pushed, or -1 on failure.  gzungetc() will\n   fail if c is -1, and may fail if a character has been pushed but not read\n   yet.  If gzungetc is used immediately after gzopen or gzdopen, at least the\n   output buffer size of pushed characters is allowed.  (See gzbuffer above.)\n   The pushed character will be discarded if the stream is repositioned with\n   gzseek() or gzrewind().\n*/\n\nZEXTERN int ZEXPORT gzflush(gzFile file, int flush);\n/*\n     Flush all pending output to file.  The parameter flush is as in the\n   deflate() function.  The return value is the zlib error number (see function\n   gzerror below).  gzflush is only permitted when writing.\n\n     If the flush parameter is Z_FINISH, the remaining data is written and the\n   gzip stream is completed in the output.  If gzwrite() is called again, a new\n   gzip stream will be started in the output.  gzread() is able to read such\n   concatenated gzip streams.\n\n     gzflush should be called only when strictly necessary because it will\n   degrade compression if called too often.\n*/\n\n/*\nZEXTERN z_off_t ZEXPORT gzseek(gzFile file,\n                               z_off_t offset, int whence);\n\n     Set the starting position to offset relative to whence for the next gzread\n   or gzwrite on file.  The offset represents a number of bytes in the\n   uncompressed data stream.  The whence parameter is defined as in lseek(2);\n   the value SEEK_END is not supported.\n\n     If the file is opened for reading, this function is emulated but can be\n   extremely slow.  If the file is opened for writing, only forward seeks are\n   supported; gzseek then compresses a sequence of zeroes up to the new\n   starting position.\n\n     gzseek returns the resulting offset location as measured in bytes from\n   the beginning of the uncompressed stream, or -1 in case of error, in\n   particular if the file is opened for writing and the new starting position\n   would be before the current position.\n*/\n\nZEXTERN int ZEXPORT    gzrewind(gzFile file);\n/*\n     Rewind file. This function is supported only for reading.\n\n     gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK_SET).\n*/\n\n/*\nZEXTERN z_off_t ZEXPORT    gztell(gzFile file);\n\n     Return the starting position for the next gzread or gzwrite on file.\n   This position represents a number of bytes in the uncompressed data stream,\n   and is zero when starting, even if appending or reading a gzip stream from\n   the middle of a file using gzdopen().\n\n     gztell(file) is equivalent to gzseek(file, 0L, SEEK_CUR)\n*/\n\n/*\nZEXTERN z_off_t ZEXPORT gzoffset(gzFile file);\n\n     Return the current compressed (actual) read or write offset of file.  This\n   offset includes the count of bytes that precede the gzip stream, for example\n   when appending or when using gzdopen() for reading.  When reading, the\n   offset does not include as yet unused buffered input.  This information can\n   be used for a progress indicator.  On error, gzoffset() returns -1.\n*/\n\nZEXTERN int ZEXPORT gzeof(gzFile file);\n/*\n     Return true (1) if the end-of-file indicator for file has been set while\n   reading, false (0) otherwise.  Note that the end-of-file indicator is set\n   only if the read tried to go past the end of the input, but came up short.\n   Therefore, just like feof(), gzeof() may return false even if there is no\n   more data to read, in the event that the last read request was for the exact\n   number of bytes remaining in the input file.  This will happen if the input\n   file size is an exact multiple of the buffer size.\n\n     If gzeof() returns true, then the read functions will return no more data,\n   unless the end-of-file indicator is reset by gzclearerr() and the input file\n   has grown since the previous end of file was detected.\n*/\n\nZEXTERN int ZEXPORT gzdirect(gzFile file);\n/*\n     Return true (1) if file is being copied directly while reading, or false\n   (0) if file is a gzip stream being decompressed.\n\n     If the input file is empty, gzdirect() will return true, since the input\n   does not contain a gzip stream.\n\n     If gzdirect() is used immediately after gzopen() or gzdopen() it will\n   cause buffers to be allocated to allow reading the file to determine if it\n   is a gzip file.  Therefore if gzbuffer() is used, it should be called before\n   gzdirect().\n\n     When writing, gzdirect() returns true (1) if transparent writing was\n   requested (\"wT\" for the gzopen() mode), or false (0) otherwise.  (Note:\n   gzdirect() is not needed when writing.  Transparent writing must be\n   explicitly requested, so the application already knows the answer.  When\n   linking statically, using gzdirect() will include all of the zlib code for\n   gzip file reading and decompression, which may not be desired.)\n*/\n\nZEXTERN int ZEXPORT    gzclose(gzFile file);\n/*\n     Flush all pending output for file, if necessary, close file and\n   deallocate the (de)compression state.  Note that once file is closed, you\n   cannot call gzerror with file, since its structures have been deallocated.\n   gzclose must not be called more than once on the same file, just as free\n   must not be called more than once on the same allocation.\n\n     gzclose will return Z_STREAM_ERROR if file is not valid, Z_ERRNO on a\n   file operation error, Z_MEM_ERROR if out of memory, Z_BUF_ERROR if the\n   last read ended in the middle of a gzip stream, or Z_OK on success.\n*/\n\nZEXTERN int ZEXPORT gzclose_r(gzFile file);\nZEXTERN int ZEXPORT gzclose_w(gzFile file);\n/*\n     Same as gzclose(), but gzclose_r() is only for use when reading, and\n   gzclose_w() is only for use when writing or appending.  The advantage to\n   using these instead of gzclose() is that they avoid linking in zlib\n   compression or decompression code that is not used when only reading or only\n   writing respectively.  If gzclose() is used, then both compression and\n   decompression code will be included the application when linking to a static\n   zlib library.\n*/\n\nZEXTERN const char * ZEXPORT gzerror(gzFile file, int *errnum);\n/*\n     Return the error message for the last error which occurred on file.\n   errnum is set to zlib error number.  If an error occurred in the file system\n   and not in the compression library, errnum is set to Z_ERRNO and the\n   application may consult errno to get the exact error code.\n\n     The application must not modify the returned string.  Future calls to\n   this function may invalidate the previously returned string.  If file is\n   closed, then the string previously returned by gzerror will no longer be\n   available.\n\n     gzerror() should be used to distinguish errors from end-of-file for those\n   functions above that do not distinguish those cases in their return values.\n*/\n\nZEXTERN void ZEXPORT gzclearerr(gzFile file);\n/*\n     Clear the error and end-of-file flags for file.  This is analogous to the\n   clearerr() function in stdio.  This is useful for continuing to read a gzip\n   file that is being written concurrently.\n*/\n\n#endif /* !Z_SOLO */\n\n                        /* checksum functions */\n\n/*\n     These functions are not related to compression but are exported\n   anyway because they might be useful in applications using the compression\n   library.\n*/\n\nZEXTERN uLong ZEXPORT adler32(uLong adler, const Bytef *buf, uInt len);\n/*\n     Update a running Adler-32 checksum with the bytes buf[0..len-1] and\n   return the updated checksum. An Adler-32 value is in the range of a 32-bit\n   unsigned integer. If buf is Z_NULL, this function returns the required\n   initial value for the checksum.\n\n     An Adler-32 checksum is almost as reliable as a CRC-32 but can be computed\n   much faster.\n\n   Usage example:\n\n     uLong adler = adler32(0L, Z_NULL, 0);\n\n     while (read_buffer(buffer, length) != EOF) {\n       adler = adler32(adler, buffer, length);\n     }\n     if (adler != original_adler) error();\n*/\n\nZEXTERN uLong ZEXPORT adler32_z(uLong adler, const Bytef *buf,\n                                z_size_t len);\n/*\n     Same as adler32(), but with a size_t length.\n*/\n\n/*\nZEXTERN uLong ZEXPORT adler32_combine(uLong adler1, uLong adler2,\n                                      z_off_t len2);\n\n     Combine two Adler-32 checksums into one.  For two sequences of bytes, seq1\n   and seq2 with lengths len1 and len2, Adler-32 checksums were calculated for\n   each, adler1 and adler2.  adler32_combine() returns the Adler-32 checksum of\n   seq1 and seq2 concatenated, requiring only adler1, adler2, and len2.  Note\n   that the z_off_t type (like off_t) is a signed integer.  If len2 is\n   negative, the result has no meaning or utility.\n*/\n\nZEXTERN uLong ZEXPORT crc32(uLong crc, const Bytef *buf, uInt len);\n/*\n     Update a running CRC-32 with the bytes buf[0..len-1] and return the\n   updated CRC-32. A CRC-32 value is in the range of a 32-bit unsigned integer.\n   If buf is Z_NULL, this function returns the required initial value for the\n   crc. Pre- and post-conditioning (one's complement) is performed within this\n   function so it shouldn't be done by the application.\n\n   Usage example:\n\n     uLong crc = crc32(0L, Z_NULL, 0);\n\n     while (read_buffer(buffer, length) != EOF) {\n       crc = crc32(crc, buffer, length);\n     }\n     if (crc != original_crc) error();\n*/\n\nZEXTERN uLong ZEXPORT crc32_z(uLong crc, const Bytef *buf,\n                              z_size_t len);\n/*\n     Same as crc32(), but with a size_t length.\n*/\n\n/*\nZEXTERN uLong ZEXPORT crc32_combine(uLong crc1, uLong crc2, z_off_t len2);\n\n     Combine two CRC-32 check values into one.  For two sequences of bytes,\n   seq1 and seq2 with lengths len1 and len2, CRC-32 check values were\n   calculated for each, crc1 and crc2.  crc32_combine() returns the CRC-32\n   check value of seq1 and seq2 concatenated, requiring only crc1, crc2, and\n   len2. len2 must be non-negative.\n*/\n\n/*\nZEXTERN uLong ZEXPORT crc32_combine_gen(z_off_t len2);\n\n     Return the operator corresponding to length len2, to be used with\n   crc32_combine_op(). len2 must be non-negative.\n*/\n\nZEXTERN uLong ZEXPORT crc32_combine_op(uLong crc1, uLong crc2, uLong op);\n/*\n     Give the same result as crc32_combine(), using op in place of len2. op is\n   is generated from len2 by crc32_combine_gen(). This will be faster than\n   crc32_combine() if the generated op is used more than once.\n*/\n\n\n                        /* various hacks, don't look :) */\n\n/* deflateInit and inflateInit are macros to allow checking the zlib version\n * and the compiler's view of z_stream:\n */\nZEXTERN int ZEXPORT deflateInit_(z_streamp strm, int level,\n                                 const char *version, int stream_size);\nZEXTERN int ZEXPORT inflateInit_(z_streamp strm,\n                                 const char *version, int stream_size);\nZEXTERN int ZEXPORT deflateInit2_(z_streamp strm, int  level, int  method,\n                                  int windowBits, int memLevel,\n                                  int strategy, const char *version,\n                                  int stream_size);\nZEXTERN int ZEXPORT inflateInit2_(z_streamp strm, int  windowBits,\n                                  const char *version, int stream_size);\nZEXTERN int ZEXPORT inflateBackInit_(z_streamp strm, int windowBits,\n                                     unsigned char FAR *window,\n                                     const char *version,\n                                     int stream_size);\n#ifdef Z_PREFIX_SET\n#  define z_deflateInit(strm, level) \\\n          deflateInit_((strm), (level), ZLIB_VERSION, (int)sizeof(z_stream))\n#  define z_inflateInit(strm) \\\n          inflateInit_((strm), ZLIB_VERSION, (int)sizeof(z_stream))\n#  define z_deflateInit2(strm, level, method, windowBits, memLevel, strategy) \\\n          deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\\\n                        (strategy), ZLIB_VERSION, (int)sizeof(z_stream))\n#  define z_inflateInit2(strm, windowBits) \\\n          inflateInit2_((strm), (windowBits), ZLIB_VERSION, \\\n                        (int)sizeof(z_stream))\n#  define z_inflateBackInit(strm, windowBits, window) \\\n          inflateBackInit_((strm), (windowBits), (window), \\\n                           ZLIB_VERSION, (int)sizeof(z_stream))\n#else\n#  define deflateInit(strm, level) \\\n          deflateInit_((strm), (level), ZLIB_VERSION, (int)sizeof(z_stream))\n#  define inflateInit(strm) \\\n          inflateInit_((strm), ZLIB_VERSION, (int)sizeof(z_stream))\n#  define deflateInit2(strm, level, method, windowBits, memLevel, strategy) \\\n          deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\\\n                        (strategy), ZLIB_VERSION, (int)sizeof(z_stream))\n#  define inflateInit2(strm, windowBits) \\\n          inflateInit2_((strm), (windowBits), ZLIB_VERSION, \\\n                        (int)sizeof(z_stream))\n#  define inflateBackInit(strm, windowBits, window) \\\n          inflateBackInit_((strm), (windowBits), (window), \\\n                           ZLIB_VERSION, (int)sizeof(z_stream))\n#endif\n\n#ifndef Z_SOLO\n\n/* gzgetc() macro and its supporting function and exposed data structure.  Note\n * that the real internal state is much larger than the exposed structure.\n * This abbreviated structure exposes just enough for the gzgetc() macro.  The\n * user should not mess with these exposed elements, since their names or\n * behavior could change in the future, perhaps even capriciously.  They can\n * only be used by the gzgetc() macro.  You have been warned.\n */\nstruct gzFile_s {\n    unsigned have;\n    unsigned char *next;\n    z_off64_t pos;\n};\nZEXTERN int ZEXPORT gzgetc_(gzFile file);       /* backward compatibility */\n#ifdef Z_PREFIX_SET\n#  undef z_gzgetc\n#  define z_gzgetc(g) \\\n          ((g)->have ? ((g)->have--, (g)->pos++, *((g)->next)++) : (gzgetc)(g))\n#else\n#  define gzgetc(g) \\\n          ((g)->have ? ((g)->have--, (g)->pos++, *((g)->next)++) : (gzgetc)(g))\n#endif\n\n/* provide 64-bit offset functions if _LARGEFILE64_SOURCE defined, and/or\n * change the regular functions to 64 bits if _FILE_OFFSET_BITS is 64 (if\n * both are true, the application gets the *64 functions, and the regular\n * functions are changed to 64 bits) -- in case these are set on systems\n * without large file support, _LFS64_LARGEFILE must also be true\n */\n#ifdef Z_LARGE64\n   ZEXTERN gzFile ZEXPORT gzopen64(const char *, const char *);\n   ZEXTERN z_off64_t ZEXPORT gzseek64(gzFile, z_off64_t, int);\n   ZEXTERN z_off64_t ZEXPORT gztell64(gzFile);\n   ZEXTERN z_off64_t ZEXPORT gzoffset64(gzFile);\n   ZEXTERN uLong ZEXPORT adler32_combine64(uLong, uLong, z_off64_t);\n   ZEXTERN uLong ZEXPORT crc32_combine64(uLong, uLong, z_off64_t);\n   ZEXTERN uLong ZEXPORT crc32_combine_gen64(z_off64_t);\n#endif\n\n#if !defined(ZLIB_INTERNAL) && defined(Z_WANT64)\n#  ifdef Z_PREFIX_SET\n#    define z_gzopen z_gzopen64\n#    define z_gzseek z_gzseek64\n#    define z_gztell z_gztell64\n#    define z_gzoffset z_gzoffset64\n#    define z_adler32_combine z_adler32_combine64\n#    define z_crc32_combine z_crc32_combine64\n#    define z_crc32_combine_gen z_crc32_combine_gen64\n#  else\n#    define gzopen gzopen64\n#    define gzseek gzseek64\n#    define gztell gztell64\n#    define gzoffset gzoffset64\n#    define adler32_combine adler32_combine64\n#    define crc32_combine crc32_combine64\n#    define crc32_combine_gen crc32_combine_gen64\n#  endif\n#  ifndef Z_LARGE64\n     ZEXTERN gzFile ZEXPORT gzopen64(const char *, const char *);\n     ZEXTERN z_off_t ZEXPORT gzseek64(gzFile, z_off_t, int);\n     ZEXTERN z_off_t ZEXPORT gztell64(gzFile);\n     ZEXTERN z_off_t ZEXPORT gzoffset64(gzFile);\n     ZEXTERN uLong ZEXPORT adler32_combine64(uLong, uLong, z_off64_t);\n     ZEXTERN uLong ZEXPORT crc32_combine64(uLong, uLong, z_off64_t);\n     ZEXTERN uLong ZEXPORT crc32_combine_gen64(z_off64_t);\n#  endif\n#else\n   ZEXTERN gzFile ZEXPORT gzopen(const char *, const char *);\n   ZEXTERN z_off_t ZEXPORT gzseek(gzFile, z_off_t, int);\n   ZEXTERN z_off_t ZEXPORT gztell(gzFile);\n   ZEXTERN z_off_t ZEXPORT gzoffset(gzFile);\n   ZEXTERN uLong ZEXPORT adler32_combine(uLong, uLong, z_off_t);\n   ZEXTERN uLong ZEXPORT crc32_combine(uLong, uLong, z_off_t);\n   ZEXTERN uLong ZEXPORT crc32_combine_gen(z_off_t);\n#endif\n\n#else /* Z_SOLO */\n\n   ZEXTERN uLong ZEXPORT adler32_combine(uLong, uLong, z_off_t);\n   ZEXTERN uLong ZEXPORT crc32_combine(uLong, uLong, z_off_t);\n   ZEXTERN uLong ZEXPORT crc32_combine_gen(z_off_t);\n\n#endif /* !Z_SOLO */\n\n/* undocumented functions */\nZEXTERN const char   * ZEXPORT zError(int);\nZEXTERN int            ZEXPORT inflateSyncPoint(z_streamp);\nZEXTERN const z_crc_t FAR * ZEXPORT get_crc_table(void);\nZEXTERN int            ZEXPORT inflateUndermine(z_streamp, int);\nZEXTERN int            ZEXPORT inflateValidate(z_streamp, int);\nZEXTERN unsigned long  ZEXPORT inflateCodesUsed(z_streamp);\nZEXTERN int            ZEXPORT inflateResetKeep(z_streamp);\nZEXTERN int            ZEXPORT deflateResetKeep(z_streamp);\n#if defined(_WIN32) && !defined(Z_SOLO)\nZEXTERN gzFile         ZEXPORT gzopen_w(const wchar_t *path,\n                                        const char *mode);\n#endif\n#if defined(STDC) || defined(Z_HAVE_STDARG_H)\n#  ifndef Z_SOLO\nZEXTERN int            ZEXPORTVA gzvprintf(gzFile file,\n                                           const char *format,\n                                           va_list va);\n#  endif\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* ZLIB_H */\n"
        },
        {
          "name": "zlib.map",
          "type": "blob",
          "size": 1.4599609375,
          "content": "ZLIB_1.2.0 {\n  global:\n    compressBound;\n    deflateBound;\n    inflateBack;\n    inflateBackEnd;\n    inflateBackInit_;\n    inflateCopy;\n  local:\n    deflate_copyright;\n    inflate_copyright;\n    inflate_fast;\n    inflate_table;\n    zcalloc;\n    zcfree;\n    z_errmsg;\n    gz_error;\n    gz_intmax;\n    _*;\n};\n\nZLIB_1.2.0.2 {\n    gzclearerr;\n    gzungetc;\n    zlibCompileFlags;\n} ZLIB_1.2.0;\n\nZLIB_1.2.0.8 {\n    deflatePrime;\n} ZLIB_1.2.0.2;\n\nZLIB_1.2.2 {\n    adler32_combine;\n    crc32_combine;\n    deflateSetHeader;\n    inflateGetHeader;\n} ZLIB_1.2.0.8;\n\nZLIB_1.2.2.3 {\n    deflateTune;\n    gzdirect;\n} ZLIB_1.2.2;\n\nZLIB_1.2.2.4 {\n    inflatePrime;\n} ZLIB_1.2.2.3;\n\nZLIB_1.2.3.3 {\n    adler32_combine64;\n    crc32_combine64;\n    gzopen64;\n    gzseek64;\n    gztell64;\n    inflateUndermine;\n} ZLIB_1.2.2.4;\n\nZLIB_1.2.3.4 {\n    inflateReset2;\n    inflateMark;\n} ZLIB_1.2.3.3;\n\nZLIB_1.2.3.5 {\n    gzbuffer;\n    gzoffset;\n    gzoffset64;\n    gzclose_r;\n    gzclose_w;\n} ZLIB_1.2.3.4;\n\nZLIB_1.2.5.1 {\n    deflatePending;\n} ZLIB_1.2.3.5;\n\nZLIB_1.2.5.2 {\n    deflateResetKeep;\n    gzgetc_;\n    inflateResetKeep;\n} ZLIB_1.2.5.1;\n\nZLIB_1.2.7.1 {\n    inflateGetDictionary;\n    gzvprintf;\n} ZLIB_1.2.5.2;\n\nZLIB_1.2.9 {\n    inflateCodesUsed;\n    inflateValidate;\n    uncompress2;\n    gzfread;\n    gzfwrite;\n    deflateGetDictionary;\n    adler32_z;\n    crc32_z;\n} ZLIB_1.2.7.1;\n\nZLIB_1.2.12 {\n\tcrc32_combine_gen;\n\tcrc32_combine_gen64;\n\tcrc32_combine_op;\n} ZLIB_1.2.9;\n\nZLIB_1.3.2 {\n\tdeflateUsed;\n} ZLIB_1.2.12;"
        },
        {
          "name": "zlib.pc.cmakein",
          "type": "blob",
          "size": 0.287109375,
          "content": "prefix=@CMAKE_INSTALL_PREFIX@\nexec_prefix=@CMAKE_INSTALL_PREFIX@\nlibdir=@INSTALL_LIB_DIR@\nsharedlibdir=@INSTALL_LIB_DIR@\nincludedir=@INSTALL_INC_DIR@\n\nName: zlib\nDescription: zlib compression library\nVersion: @VERSION@\n\nRequires:\nLibs: -L${libdir} -L${sharedlibdir} -lz\nCflags: -I${includedir}\n"
        },
        {
          "name": "zlib.pc.in",
          "type": "blob",
          "size": 0.248046875,
          "content": "prefix=@prefix@\nexec_prefix=@exec_prefix@\nlibdir=@libdir@\nsharedlibdir=@sharedlibdir@\nincludedir=@includedir@\n\nName: zlib\nDescription: zlib compression library\nVersion: @VERSION@\n\nRequires:\nLibs: -L${libdir} -L${sharedlibdir} -lz\nCflags: -I${includedir}\n"
        },
        {
          "name": "zutil.c",
          "type": "blob",
          "size": 7.0107421875,
          "content": "/* zutil.c -- target dependent utility functions for the compression library\n * Copyright (C) 1995-2017 Jean-loup Gailly\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n/* @(#) $Id$ */\n\n#include \"zutil.h\"\n#ifndef Z_SOLO\n#  include \"gzguts.h\"\n#endif\n\nz_const char * const z_errmsg[10] = {\n    (z_const char *)\"need dictionary\",     /* Z_NEED_DICT       2  */\n    (z_const char *)\"stream end\",          /* Z_STREAM_END      1  */\n    (z_const char *)\"\",                    /* Z_OK              0  */\n    (z_const char *)\"file error\",          /* Z_ERRNO         (-1) */\n    (z_const char *)\"stream error\",        /* Z_STREAM_ERROR  (-2) */\n    (z_const char *)\"data error\",          /* Z_DATA_ERROR    (-3) */\n    (z_const char *)\"insufficient memory\", /* Z_MEM_ERROR     (-4) */\n    (z_const char *)\"buffer error\",        /* Z_BUF_ERROR     (-5) */\n    (z_const char *)\"incompatible version\",/* Z_VERSION_ERROR (-6) */\n    (z_const char *)\"\"\n};\n\n\nconst char * ZEXPORT zlibVersion(void) {\n    return ZLIB_VERSION;\n}\n\nuLong ZEXPORT zlibCompileFlags(void) {\n    uLong flags;\n\n    flags = 0;\n    switch ((int)(sizeof(uInt))) {\n    case 2:     break;\n    case 4:     flags += 1;     break;\n    case 8:     flags += 2;     break;\n    default:    flags += 3;\n    }\n    switch ((int)(sizeof(uLong))) {\n    case 2:     break;\n    case 4:     flags += 1 << 2;        break;\n    case 8:     flags += 2 << 2;        break;\n    default:    flags += 3 << 2;\n    }\n    switch ((int)(sizeof(voidpf))) {\n    case 2:     break;\n    case 4:     flags += 1 << 4;        break;\n    case 8:     flags += 2 << 4;        break;\n    default:    flags += 3 << 4;\n    }\n    switch ((int)(sizeof(z_off_t))) {\n    case 2:     break;\n    case 4:     flags += 1 << 6;        break;\n    case 8:     flags += 2 << 6;        break;\n    default:    flags += 3 << 6;\n    }\n#ifdef ZLIB_DEBUG\n    flags += 1 << 8;\n#endif\n    /*\n#if defined(ASMV) || defined(ASMINF)\n    flags += 1 << 9;\n#endif\n     */\n#ifdef ZLIB_WINAPI\n    flags += 1 << 10;\n#endif\n#ifdef BUILDFIXED\n    flags += 1 << 12;\n#endif\n#ifdef DYNAMIC_CRC_TABLE\n    flags += 1 << 13;\n#endif\n#ifdef NO_GZCOMPRESS\n    flags += 1L << 16;\n#endif\n#ifdef NO_GZIP\n    flags += 1L << 17;\n#endif\n#ifdef PKZIP_BUG_WORKAROUND\n    flags += 1L << 20;\n#endif\n#ifdef FASTEST\n    flags += 1L << 21;\n#endif\n#if defined(STDC) || defined(Z_HAVE_STDARG_H)\n#  ifdef NO_vsnprintf\n    flags += 1L << 25;\n#    ifdef HAS_vsprintf_void\n    flags += 1L << 26;\n#    endif\n#  else\n#    ifdef HAS_vsnprintf_void\n    flags += 1L << 26;\n#    endif\n#  endif\n#else\n    flags += 1L << 24;\n#  ifdef NO_snprintf\n    flags += 1L << 25;\n#    ifdef HAS_sprintf_void\n    flags += 1L << 26;\n#    endif\n#  else\n#    ifdef HAS_snprintf_void\n    flags += 1L << 26;\n#    endif\n#  endif\n#endif\n    return flags;\n}\n\n#ifdef ZLIB_DEBUG\n#include <stdlib.h>\n#  ifndef verbose\n#    define verbose 0\n#  endif\nint ZLIB_INTERNAL z_verbose = verbose;\n\nvoid ZLIB_INTERNAL z_error(char *m) {\n    fprintf(stderr, \"%s\\n\", m);\n    exit(1);\n}\n#endif\n\n/* exported to allow conversion of error code to string for compress() and\n * uncompress()\n */\nconst char * ZEXPORT zError(int err) {\n    return ERR_MSG(err);\n}\n\n#if defined(_WIN32_WCE) && _WIN32_WCE < 0x800\n    /* The older Microsoft C Run-Time Library for Windows CE doesn't have\n     * errno.  We define it as a global variable to simplify porting.\n     * Its value is always 0 and should not be used.\n     */\n    int errno = 0;\n#endif\n\n#ifndef HAVE_MEMCPY\n\nvoid ZLIB_INTERNAL zmemcpy(Bytef* dest, const Bytef* source, uInt len) {\n    if (len == 0) return;\n    do {\n        *dest++ = *source++; /* ??? to be unrolled */\n    } while (--len != 0);\n}\n\nint ZLIB_INTERNAL zmemcmp(const Bytef* s1, const Bytef* s2, uInt len) {\n    uInt j;\n\n    for (j = 0; j < len; j++) {\n        if (s1[j] != s2[j]) return 2*(s1[j] > s2[j])-1;\n    }\n    return 0;\n}\n\nvoid ZLIB_INTERNAL zmemzero(Bytef* dest, uInt len) {\n    if (len == 0) return;\n    do {\n        *dest++ = 0;  /* ??? to be unrolled */\n    } while (--len != 0);\n}\n#endif\n\n#ifndef Z_SOLO\n\n#ifdef SYS16BIT\n\n#ifdef __TURBOC__\n/* Turbo C in 16-bit mode */\n\n#  define MY_ZCALLOC\n\n/* Turbo C malloc() does not allow dynamic allocation of 64K bytes\n * and farmalloc(64K) returns a pointer with an offset of 8, so we\n * must fix the pointer. Warning: the pointer must be put back to its\n * original form in order to free it, use zcfree().\n */\n\n#define MAX_PTR 10\n/* 10*64K = 640K */\n\nlocal int next_ptr = 0;\n\ntypedef struct ptr_table_s {\n    voidpf org_ptr;\n    voidpf new_ptr;\n} ptr_table;\n\nlocal ptr_table table[MAX_PTR];\n/* This table is used to remember the original form of pointers\n * to large buffers (64K). Such pointers are normalized with a zero offset.\n * Since MSDOS is not a preemptive multitasking OS, this table is not\n * protected from concurrent access. This hack doesn't work anyway on\n * a protected system like OS/2. Use Microsoft C instead.\n */\n\nvoidpf ZLIB_INTERNAL zcalloc(voidpf opaque, unsigned items, unsigned size) {\n    voidpf buf;\n    ulg bsize = (ulg)items*size;\n\n    (void)opaque;\n\n    /* If we allocate less than 65520 bytes, we assume that farmalloc\n     * will return a usable pointer which doesn't have to be normalized.\n     */\n    if (bsize < 65520L) {\n        buf = farmalloc(bsize);\n        if (*(ush*)&buf != 0) return buf;\n    } else {\n        buf = farmalloc(bsize + 16L);\n    }\n    if (buf == NULL || next_ptr >= MAX_PTR) return NULL;\n    table[next_ptr].org_ptr = buf;\n\n    /* Normalize the pointer to seg:0 */\n    *((ush*)&buf+1) += ((ush)((uch*)buf-0) + 15) >> 4;\n    *(ush*)&buf = 0;\n    table[next_ptr++].new_ptr = buf;\n    return buf;\n}\n\nvoid ZLIB_INTERNAL zcfree(voidpf opaque, voidpf ptr) {\n    int n;\n\n    (void)opaque;\n\n    if (*(ush*)&ptr != 0) { /* object < 64K */\n        farfree(ptr);\n        return;\n    }\n    /* Find the original pointer */\n    for (n = 0; n < next_ptr; n++) {\n        if (ptr != table[n].new_ptr) continue;\n\n        farfree(table[n].org_ptr);\n        while (++n < next_ptr) {\n            table[n-1] = table[n];\n        }\n        next_ptr--;\n        return;\n    }\n    Assert(0, \"zcfree: ptr not found\");\n}\n\n#endif /* __TURBOC__ */\n\n\n#ifdef M_I86\n/* Microsoft C in 16-bit mode */\n\n#  define MY_ZCALLOC\n\n#if (!defined(_MSC_VER) || (_MSC_VER <= 600))\n#  define _halloc  halloc\n#  define _hfree   hfree\n#endif\n\nvoidpf ZLIB_INTERNAL zcalloc(voidpf opaque, uInt items, uInt size) {\n    (void)opaque;\n    return _halloc((long)items, size);\n}\n\nvoid ZLIB_INTERNAL zcfree(voidpf opaque, voidpf ptr) {\n    (void)opaque;\n    _hfree(ptr);\n}\n\n#endif /* M_I86 */\n\n#endif /* SYS16BIT */\n\n\n#ifndef MY_ZCALLOC /* Any system without a special alloc function */\n\n#ifndef STDC\nextern voidp malloc(uInt size);\nextern voidp calloc(uInt items, uInt size);\nextern void free(voidpf ptr);\n#endif\n\nvoidpf ZLIB_INTERNAL zcalloc(voidpf opaque, unsigned items, unsigned size) {\n    (void)opaque;\n    return sizeof(uInt) > 2 ? (voidpf)malloc(items * size) :\n                              (voidpf)calloc(items, size);\n}\n\nvoid ZLIB_INTERNAL zcfree(voidpf opaque, voidpf ptr) {\n    (void)opaque;\n    free(ptr);\n}\n\n#endif /* MY_ZCALLOC */\n\n#endif /* !Z_SOLO */\n"
        },
        {
          "name": "zutil.h",
          "type": "blob",
          "size": 6.6376953125,
          "content": "/* zutil.h -- internal interface and configuration of the compression library\n * Copyright (C) 1995-2024 Jean-loup Gailly, Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n/* WARNING: this file should *not* be used by applications. It is\n   part of the implementation of the compression library and is\n   subject to change. Applications should only use zlib.h.\n */\n\n/* @(#) $Id$ */\n\n#ifndef ZUTIL_H\n#define ZUTIL_H\n\n#ifdef HAVE_HIDDEN\n#  define ZLIB_INTERNAL __attribute__((visibility (\"hidden\")))\n#else\n#  define ZLIB_INTERNAL\n#endif\n\n#include \"zlib.h\"\n\n#if defined(STDC) && !defined(Z_SOLO)\n#  if !(defined(_WIN32_WCE) && defined(_MSC_VER))\n#    include <stddef.h>\n#  endif\n#  include <string.h>\n#  include <stdlib.h>\n#endif\n\n#ifndef local\n#  define local static\n#endif\n/* since \"static\" is used to mean two completely different things in C, we\n   define \"local\" for the non-static meaning of \"static\", for readability\n   (compile with -Dlocal if your debugger can't find static symbols) */\n\ntypedef unsigned char  uch;\ntypedef uch FAR uchf;\ntypedef unsigned short ush;\ntypedef ush FAR ushf;\ntypedef unsigned long  ulg;\n\n#if !defined(Z_U8) && !defined(Z_SOLO) && defined(STDC)\n#  include <limits.h>\n#  if (ULONG_MAX == 0xffffffffffffffff)\n#    define Z_U8 unsigned long\n#  elif (ULLONG_MAX == 0xffffffffffffffff)\n#    define Z_U8 unsigned long long\n#  elif (ULONG_LONG_MAX == 0xffffffffffffffff)\n#    define Z_U8 unsigned long long\n#  elif (UINT_MAX == 0xffffffffffffffff)\n#    define Z_U8 unsigned\n#  endif\n#endif\n\nextern z_const char * const z_errmsg[10]; /* indexed by 2-zlib_error */\n/* (size given to avoid silly warnings with Visual C++) */\n\n#define ERR_MSG(err) z_errmsg[(err) < -6 || (err) > 2 ? 9 : 2 - (err)]\n\n#define ERR_RETURN(strm,err) \\\n  return (strm->msg = ERR_MSG(err), (err))\n/* To be used only when the state is known to be valid */\n\n        /* common constants */\n#if MAX_WBITS < 9 || MAX_WBITS > 15\n#  error MAX_WBITS must be in 9..15\n#endif\n#ifndef DEF_WBITS\n#  define DEF_WBITS MAX_WBITS\n#endif\n/* default windowBits for decompression. MAX_WBITS is for compression only */\n\n#if MAX_MEM_LEVEL >= 8\n#  define DEF_MEM_LEVEL 8\n#else\n#  define DEF_MEM_LEVEL  MAX_MEM_LEVEL\n#endif\n/* default memLevel */\n\n#define STORED_BLOCK 0\n#define STATIC_TREES 1\n#define DYN_TREES    2\n/* The three kinds of block type */\n\n#define MIN_MATCH  3\n#define MAX_MATCH  258\n/* The minimum and maximum match lengths */\n\n#define PRESET_DICT 0x20 /* preset dictionary flag in zlib header */\n\n        /* target dependencies */\n\n#if defined(MSDOS) || (defined(WINDOWS) && !defined(WIN32))\n#  define OS_CODE  0x00\n#  ifndef Z_SOLO\n#    if defined(__TURBOC__) || defined(__BORLANDC__)\n#      if (__STDC__ == 1) && (defined(__LARGE__) || defined(__COMPACT__))\n         /* Allow compilation with ANSI keywords only enabled */\n         void _Cdecl farfree( void *block );\n         void *_Cdecl farmalloc( unsigned long nbytes );\n#      else\n#        include <alloc.h>\n#      endif\n#    else /* MSC or DJGPP */\n#      include <malloc.h>\n#    endif\n#  endif\n#endif\n\n#ifdef AMIGA\n#  define OS_CODE  1\n#endif\n\n#if defined(VAXC) || defined(VMS)\n#  define OS_CODE  2\n#  define F_OPEN(name, mode) \\\n     fopen((name), (mode), \"mbc=60\", \"ctx=stm\", \"rfm=fix\", \"mrs=512\")\n#endif\n\n#ifdef __370__\n#  if __TARGET_LIB__ < 0x20000000\n#    define OS_CODE 4\n#  elif __TARGET_LIB__ < 0x40000000\n#    define OS_CODE 11\n#  else\n#    define OS_CODE 8\n#  endif\n#endif\n\n#if defined(ATARI) || defined(atarist)\n#  define OS_CODE  5\n#endif\n\n#ifdef OS2\n#  define OS_CODE  6\n#  if defined(M_I86) && !defined(Z_SOLO)\n#    include <malloc.h>\n#  endif\n#endif\n\n#if defined(MACOS)\n#  define OS_CODE  7\n#endif\n\n#if defined(__acorn) || defined(__riscos)\n#  define OS_CODE 13\n#endif\n\n#if defined(WIN32) && !defined(__CYGWIN__)\n#  define OS_CODE  10\n#endif\n\n#ifdef _BEOS_\n#  define OS_CODE  16\n#endif\n\n#ifdef __TOS_OS400__\n#  define OS_CODE 18\n#endif\n\n#ifdef __APPLE__\n#  define OS_CODE 19\n#endif\n\n#if defined(__BORLANDC__) && !defined(MSDOS)\n  #pragma warn -8004\n  #pragma warn -8008\n  #pragma warn -8066\n#endif\n\n/* provide prototypes for these when building zlib without LFS */\n#ifndef Z_LARGE64\n   ZEXTERN uLong ZEXPORT adler32_combine64(uLong, uLong, z_off64_t);\n   ZEXTERN uLong ZEXPORT crc32_combine64(uLong, uLong, z_off64_t);\n   ZEXTERN uLong ZEXPORT crc32_combine_gen64(z_off64_t);\n#endif\n\n        /* common defaults */\n\n#ifndef OS_CODE\n#  define OS_CODE  3     /* assume Unix */\n#endif\n\n#ifndef F_OPEN\n#  define F_OPEN(name, mode) fopen((name), (mode))\n#endif\n\n         /* functions */\n\n#if defined(pyr) || defined(Z_SOLO)\n#  define NO_MEMCPY\n#endif\n#if defined(SMALL_MEDIUM) && !defined(_MSC_VER) && !defined(__SC__)\n /* Use our own functions for small and medium model with MSC <= 5.0.\n  * You may have to use the same strategy for Borland C (untested).\n  * The __SC__ check is for Symantec.\n  */\n#  define NO_MEMCPY\n#endif\n#if defined(STDC) && !defined(HAVE_MEMCPY) && !defined(NO_MEMCPY)\n#  define HAVE_MEMCPY\n#endif\n#ifdef HAVE_MEMCPY\n#  ifdef SMALL_MEDIUM /* MSDOS small or medium model */\n#    define zmemcpy _fmemcpy\n#    define zmemcmp _fmemcmp\n#    define zmemzero(dest, len) _fmemset(dest, 0, len)\n#  else\n#    define zmemcpy memcpy\n#    define zmemcmp memcmp\n#    define zmemzero(dest, len) memset(dest, 0, len)\n#  endif\n#else\n   void ZLIB_INTERNAL zmemcpy(Bytef* dest, const Bytef* source, uInt len);\n   int ZLIB_INTERNAL zmemcmp(const Bytef* s1, const Bytef* s2, uInt len);\n   void ZLIB_INTERNAL zmemzero(Bytef* dest, uInt len);\n#endif\n\n/* Diagnostic functions */\n#ifdef ZLIB_DEBUG\n#  include <stdio.h>\n   extern int ZLIB_INTERNAL z_verbose;\n   extern void ZLIB_INTERNAL z_error(char *m);\n#  define Assert(cond,msg) {if(!(cond)) z_error(msg);}\n#  define Trace(x) {if (z_verbose>=0) fprintf x ;}\n#  define Tracev(x) {if (z_verbose>0) fprintf x ;}\n#  define Tracevv(x) {if (z_verbose>1) fprintf x ;}\n#  define Tracec(c,x) {if (z_verbose>0 && (c)) fprintf x ;}\n#  define Tracecv(c,x) {if (z_verbose>1 && (c)) fprintf x ;}\n#else\n#  define Assert(cond,msg)\n#  define Trace(x)\n#  define Tracev(x)\n#  define Tracevv(x)\n#  define Tracec(c,x)\n#  define Tracecv(c,x)\n#endif\n\n#ifndef Z_SOLO\n   voidpf ZLIB_INTERNAL zcalloc(voidpf opaque, unsigned items,\n                                unsigned size);\n   void ZLIB_INTERNAL zcfree(voidpf opaque, voidpf ptr);\n#endif\n\n#define ZALLOC(strm, items, size) \\\n           (*((strm)->zalloc))((strm)->opaque, (items), (size))\n#define ZFREE(strm, addr)  (*((strm)->zfree))((strm)->opaque, (voidpf)(addr))\n#define TRY_FREE(s, p) {if (p) ZFREE(s, p);}\n\n/* Reverse the bytes in a 32-bit value */\n#define ZSWAP32(q) ((((q) >> 24) & 0xff) + (((q) >> 8) & 0xff00) + \\\n                    (((q) & 0xff00) << 8) + (((q) & 0xff) << 24))\n\n#endif /* ZUTIL_H */\n"
        }
      ]
    }
  ]
}