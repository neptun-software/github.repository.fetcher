{
  "metadata": {
    "timestamp": 1736710286048,
    "page": 55,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjYw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "capstone-engine/capstone",
      "stars": 7718,
      "defaultBranch": "next",
      "files": [
        {
          "name": ".appveyor.yml",
          "type": "blob",
          "size": 0.259765625,
          "content": "version: 4.0-{build}\n\nos:\n  - Visual Studio 2015\n\nbefore_build:\n  - call \"C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\vcvarsall.bat\" amd64\n\nbuild_script:\n  - mkdir build\n  - cd build\n  - cmake -DCMAKE_BUILD_TYPE=RELEASE -G \"NMake Makefiles\" ..\n  - nmake\n\n"
        },
        {
          "name": ".clang-format",
          "type": "blob",
          "size": 3.267578125,
          "content": "# SPDX-License-Identifier: GPL-2.0\n#\n# clang-format configuration file. Intended for clang-format >= 11.\n#\n# For more information, see:\n#\n#   Documentation/process/clang-format.rst\n#   https://clang.llvm.org/docs/ClangFormat.html\n#   https://clang.llvm.org/docs/ClangFormatStyleOptions.html\n#\n---\nAccessModifierOffset: -4\nAlignAfterOpenBracket: Align\nAlignConsecutiveAssignments: false\nAlignConsecutiveDeclarations: false\nAlignEscapedNewlines: DontAlign\nAlignOperands: true\nAlignTrailingComments:\n  Kind: Always\n  OverEmptyLines: 2\nAllowAllParametersOfDeclarationOnNextLine: false\nAllowShortBlocksOnASingleLine: false\nAllowShortCaseLabelsOnASingleLine: false\nAllowShortFunctionsOnASingleLine: None\nAllowShortIfStatementsOnASingleLine: false\nAllowShortLoopsOnASingleLine: false\nAlwaysBreakAfterDefinitionReturnType: None\nAlwaysBreakAfterReturnType: None\nAlwaysBreakBeforeMultilineStrings: false\nAlwaysBreakTemplateDeclarations: false\nBinPackArguments: true\nBinPackParameters: true\nBraceWrapping:\n  AfterClass: false\n  AfterControlStatement: false\n  AfterEnum: false\n  AfterFunction: true\n  AfterNamespace: true\n  AfterObjCDeclaration: false\n  AfterStruct: false\n  AfterUnion: false\n  AfterExternBlock: false\n  BeforeCatch: false\n  BeforeElse: false\n  IndentBraces: false\n  SplitEmptyFunction: true\n  SplitEmptyRecord: true\n  SplitEmptyNamespace: true\nBreakBeforeBinaryOperators: None\nBreakBeforeBraces: Custom\nBreakBeforeInheritanceComma: false\nBreakBeforeTernaryOperators: false\nBreakConstructorInitializersBeforeComma: false\nBreakConstructorInitializers: BeforeComma\nBreakAfterJavaFieldAnnotations: false\nBreakStringLiterals: false\nColumnLimit: 80\nCommentPragmas: '^ IWYU pragma:'\nCompactNamespaces: false\nConstructorInitializerAllOnOneLineOrOnePerLine: false\nConstructorInitializerIndentWidth: 8\nContinuationIndentWidth: 8\nCpp11BracedListStyle: false\nDerivePointerAlignment: false\nDisableFormat: false\nExperimentalAutoDetectBinPacking: false\nFixNamespaceComments: false\n\nIncludeBlocks: Preserve\nIncludeCategories:\n  - Regex: '.*'\n    Priority: 1\nIncludeIsMainRegex: '(Test)?$'\nIndentCaseLabels: false\nIndentGotoLabels: false\nIndentPPDirectives: None\nIndentWidth: 8\nIndentWrappedFunctionNames: false\nJavaScriptQuotes: Leave\nJavaScriptWrapImports: true\nKeepEmptyLinesAtTheStartOfBlocks: false\nMacroBlockBegin: ''\nMacroBlockEnd: ''\nMaxEmptyLinesToKeep: 1\nNamespaceIndentation: None\nObjCBinPackProtocolList: Auto\nObjCBlockIndentWidth: 8\nObjCSpaceAfterProperty: true\nObjCSpaceBeforeProtocolList: true\n\n# Taken from git's rules\nPenaltyBreakAssignment: 10\nPenaltyBreakBeforeFirstCallParameter: 30\nPenaltyBreakComment: 10\nPenaltyBreakFirstLessLess: 0\nPenaltyBreakString: 10\nPenaltyExcessCharacter: 100\nPenaltyReturnTypeOnItsOwnLine: 60\n\nPointerAlignment: Right\nReflowComments: false\nSortIncludes: false\nSortUsingDeclarations: false\nSpaceAfterCStyleCast: false\nSpaceAfterTemplateKeyword: true\nSpaceBeforeAssignmentOperators: true\nSpaceBeforeCtorInitializerColon: true\nSpaceBeforeInheritanceColon: true\nSpaceBeforeParens: ControlStatementsExceptForEachMacros\nSpaceBeforeRangeBasedForLoopColon: true\nSpaceInEmptyParentheses: false\nSpacesBeforeTrailingComments: 1\nSpacesInAngles: false\nSpacesInContainerLiterals: false\nSpacesInCStyleCastParentheses: false\nSpacesInParentheses: false\nSpacesInSquareBrackets: false\nStandard: Cpp03\nTabWidth: 8\nUseTab: Always\n"
        },
        {
          "name": ".dockerignore",
          "type": "blob",
          "size": 0.224609375,
          "content": "# Ignore source control directories\n.git\n.svn\n\n# Ignore build directories\nbuild\ndist\n\n# Ignore dependency directories\nnode_modules\nvendor\n\n# Ignore temporary files\n*.log\n*.tmp\n\n# Ignore environment files\n.env\n\n# Ignore tests\ntests"
        },
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.2939453125,
          "content": "root = true\n\n[*]\nend_of_line = lf\ninsert_final_newline = true\n\n[*.{py,pyx,pxd}]\nindent_style = space\nindent_size = 4\n\n# Follow Linux kernel coding style\n[*.{c,h,cpp,hpp,inc}]\nindent_style = tab\nindent_size = 8\n\n# OCaml bindings\n[*.ml]\nindent_style = tab\nindent_size = 4\n\n[Makefile]\nindent_style = tab\n"
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.09375,
          "content": "/arch/**/*.inc linguist-language=C\n\n# Ensure shell scripts have LF line endings\n*.sh text eol=lf"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 2.142578125,
          "content": ".DS_Store\n\n# Object files\n*.o\n*.ko\n\n# Gcc dependency-tracking files\n*.d\n\n# Libraries\n*.lib\n*.a\n\n# Shared objects (inc. Windows DLLs)\n*.dll\n*.so\n*.so.*\n*.dylib\n\n# Executables\n*.exe\n*.out\n*.app\n\n# python\nbindings/python/build/\nbindings/python/capstone.egg-info/\nbindings/python/cstest_py/src/cstest_py.egg**\nbindings/cython/capstone.egg-info/\n*.pyc\n\n# java\nbindings/java/capstone.jar\n\n# ocaml\nbindings/ocaml/*.cmi\nbindings/ocaml/*.cmx\nbindings/ocaml/*.cmxa\nbindings/ocaml/*.mli\nbindings/ocaml/test\nbindings/ocaml/test_arm\nbindings/ocaml/test_aarch64\nbindings/ocaml/test_basic\nbindings/ocaml/test_mips\nbindings/ocaml/test_x86\nbindings/ocaml/test_detail\nbindings/ocaml/test_ppc\nbindings/ocaml/test_sparc\nbindings/ocaml/test_systemz\nbindings/ocaml/test_xcore\nbindings/ocaml/test_m680x\n\n\n# test binaries\ntests/test_basic\ntests/test_detail\ntests/test_iter\ntests/test_arm\ntests/test_aarch64\ntests/test_mips\ntests/test_x86\ntests/test_ppc\ntests/test_skipdata\ntests/test_sparc\ntests/test_systemz\ntests/test_xcore\ntests/test_tricore\ntests/*.static\ntests/test_customized_mnem\ntests/test_m68k\ntests/test_tms320c64x\ntests/test_m680x\ntests/test_evm\ntests/test_wasm\ntests/test_mos65xx\ntests/test_bpf\ntests/test_sh\ntests/test_riscv\ntests/test_sh\ntests/test_alpha\ntests/test_hppa\n\n# regress binaries\nsuite/regress/invalid_read_in_print_operand\n\n# vim tmp file\n*.swp\n*~\n\ncapstone.pc\n\n# local files\n_*\n\n# freebsd ports: generated file with \"make makesum\" command\npackages/freebsd/ports/devel/capstone/distinfo\n\n# VisualStudio\nProjectUpgradeLog.log\nDebug/\nRelease/\nipch/\nbuild*/\n*.sdf\n*.opensdf\n*.suo\n*.user\n*.backup\n*.VC.db\n*.VC.opendb\n.vscode/\n\n# CMake build directories\nbuild*/\n/build\n/out\n\n# Xcode\nxcode/Capstone.xcodeproj/xcuserdata\nxcode/Capstone.xcodeproj/project.xcworkspace/xcuserdata\n\n# IntelliJ IDEs\n.idea/\n\n# suite/\ncorpus-libFuzzer-capstone_fuzz_disasmnext-latest.zip\ntest_arm_regression\ntest_arm_regression.o\nfuzz_harness\ntest_iter_benchmark\ntest_file_benchmark\nfuzz_bindisasm\nfuzz_disasm\nfuzz_decode_platform\ncapstone_get_setup\nsuite/fuzz/corpus\n\n*.s\n\ncstool/cstool\n\n# android\nandroid-ndk-*\n\n# python virtual env\n.ven*/\n\n# Auto-sync files\nsuite/auto-sync/src/autosync.egg-info\n\n# clangd cache\n/.cache\n"
        },
        {
          "name": ".gitmodules",
          "type": "blob",
          "size": 0.154296875,
          "content": "[submodule \"suite/auto-sync/vendor/tree-sitter-cpp\"]\n\tpath = suite/auto-sync/vendor/tree-sitter-cpp\n\turl = https://github.com/tree-sitter/tree-sitter-cpp.git\n"
        },
        {
          "name": ".reuse",
          "type": "tree",
          "content": null
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 3.03125,
          "content": "language: cpp\nsudo: false\nbefore_install:\n        - export LD_LIBRARY_PATH=`pwd`/tests/:$LD_LIBRARY_PATH\nbefore_script:\n        - wget https://github.com/groundx/capstonefuzz/raw/master/corpus/corpus-libFuzzer-capstone_fuzz_disasmnext-latest.zip\n        - unzip -q corpus-libFuzzer-capstone_fuzz_disasmnext-latest.zip -d suite/fuzz\n        # TODO remove built in cmocka compile and use system cmocka (including brewfile) once xenial is default\n        - git clone https://git.cryptomilk.org/projects/cmocka.git suite/cstest/cmocka\n        - chmod +x suite/cstest/build_cstest.sh\n        - if [[ ${TRAVIS_OS_NAME} = linux ]]; then export PATH=\"/usr/lib/llvm-9/bin:${PATH}\"; fi\nscript:\n        - ./make.sh\n        - make check\n        - sudo make install\n        - if [[ \"$TRAVIS_OS_NAME\" == \"linux\" ]]; then cp libcapstone.so.* bindings/python/libcapstone.so; fi\n        - if [[ \"$TRAVIS_OS_NAME\" == \"osx\" ]]; then cp libcapstone.*.dylib bindings/python/libcapstone.dylib; fi\n        - if [[ \"$NOPYTEST\" != \"true\" ]]; then cd bindings/python && make check; cd ../..; fi\n        - if [[ \"$NOPYTEST\" != \"true\" ]]; then cd suite/cstest && ./build_cstest.sh; fi\n        - if [[ \"$NOPYTEST\" != \"true\" ]]; then python cstest_report.py -D -t build/cstest -d ../MC; fi\n        - if [[ \"$NOPYTEST\" != \"true\" ]]; then python cstest_report.py -D -t build/cstest -f issues.cs; fi\n        - if [ -n \"$QA_FUZZIT\" ]; then suite/fuzz/fuzzit.sh; fi\ncompiler:\n        - clang\n        - gcc\nos:\n        - linux\n        - osx\nmatrix:\n    include:\n        - name: xenial gcc\n          os: linux\n          dist: xenial\n          compiler: gcc\n          addons:\n            apt:\n              packages:\n                - libcmocka-dev\n        - name: xenial clang\n          os: linux\n          dist: xenial\n          compiler: clang\n          addons:\n            apt:\n              packages:\n                - libcmocka-dev\n        - name: fuzza\n          env: ASAN_OPTIONS=detect_leaks=0 CXXFLAGS=\"-DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION -fsanitize=address -fsanitize=fuzzer-no-link\" CFLAGS=\"-DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION -fsanitize=address -fsanitize=fuzzer-no-link\" LDFLAGS=\"-fsanitize=address\" NOPYTEST=true QA_FUZZIT=asan\n          compiler: clang\n          os: linux\n        - name: fuzzm\n          env: CXXFLAGS=\"-DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION -fsanitize=memory -fsanitize=fuzzer-no-link\" CFLAGS=\"-DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION -fsanitize=memory -fsanitize=fuzzer-no-link\" LDFLAGS=\"-fsanitize=memory\" NOPYTEST=true QA_FUZZIT=msan\n          compiler: clang\n          os: linux\n        - name: fuzzu\n          env: CXXFLAGS=\"-DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION -fsanitize=undefined -fsanitize=fuzzer-no-link\" CFLAGS=\"-DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION -fsanitize=undefined -fno-sanitize-recover=undefined,integer -fsanitize=fuzzer-no-link\" LDFLAGS=\"-fsanitize=undefined\" NOPYTEST=true QA_FUZZIT=ubsan\n          compiler: clang\n          os: linux\n\naddons:\n  apt:\n    sources:\n      - llvm-toolchain-trusty\n      - ubuntu-toolchain-r-test\n    packages:\n      - clang-9\n"
        },
        {
          "name": "BUILDING.md",
          "type": "blob",
          "size": 4.3232421875,
          "content": "# Building Capstone\n\nThis guide describes how to build Capstone with `CMake`.\n\n## Build commands\n\n**Unix**\n\n```bash\ncmake -B build -DCMAKE_BUILD_TYPE=Release # For debug build change \"Release\" to \"Debug\"\ncmake --build build\ncmake --install build --prefix \"<install-prefix>\"\n```\n\n**Windows**\n\n```bash\ncmake.exe -B build\ncmake.exe --build build --config Release # For debug build change \"Release\" to \"Debug\"\ncmake.exe --install build\n```\n\n## Tailor Capstone to your needs.\n\nEnable and disable options in the \"configure\" step (first `cmake` command from above).\nOptions are added with `-D<OPTION>=ON/OFF` or `-D<OPTION>=1/0`\n\n### Exclude architecture modules\n\nYou can build Capstone with only the architectures you need.\nBy default all are enabled.\n\n- `CAPSTONE_ARCHITECTURE_DEFAULT`: Whether all architectures are enabled by default.\n- `CAPSTONE_ARM_SUPPORT`: Support ARM.\n- `CAPSTONE_AARCH64_SUPPORT`: Support AARCH64.\n- `CAPSTONE_ALPHA_SUPPORT`: Support Alpha.\n- `CAPSTONE_HPPA_SUPPORT`: Support HPPA.\n- `CAPSTONE_LOONGARCH_SUPPORT`: Support LoongArch.\n- `CAPSTONE_M680X_SUPPORT`: Support M680X.\n- `CAPSTONE_M68K_SUPPORT`: Support M68K.\n- `CAPSTONE_MIPS_SUPPORT`: Support Mips.\n- `CAPSTONE_MOS65XX_SUPPORT`: Support MOS65XX.\n- `CAPSTONE_PPC_SUPPORT`: Support PPC.\n- `CAPSTONE_SPARC_SUPPORT`: Support Sparc.\n- `CAPSTONE_SYSTEMZ_SUPPORT`: Support SystemZ.\n- `CAPSTONE_XCORE_SUPPORT`: Support XCore.\n- `CAPSTONE_TRICORE_SUPPORT`: Support TriCore.\n- `CAPSTONE_X86_SUPPORT`: Support X86.\n- `CAPSTONE_TMS320C64X_SUPPORT`: Support TMS320C64X.\n- `CAPSTONE_M680X_SUPPORT`: Support M680X.\n- `CAPSTONE_EVM_SUPPORT`: Support EVM.\n- `CAPSTONE_WASM_SUPPORT`: Support Web Assembly.\n- `CAPSTONE_BPF_SUPPORT`: Support BPF.\n- `CAPSTONE_RISCV_SUPPORT`: Support RISCV.\n  \n### Module registration\n\nIf you're building a static library that you intend to link into multiple consumers,\nand they have differing architecture requirements, you may want `-DCAPSTONE_USE_ARCH_REGISTRATION=1`.\n\nIn your consumer code you can call `cs_arch_register_*()` to register the specific module for initialization.\n\nIn this way you only pay footprint size for the architectures you're actually using in each consumer,\nwithout having to compile Capstone multiple times.\n\n### Additional options\n\nCapstone allows some more customization via the following options:\n\n- `CAPSTONE_BUILD_SHARED_LIBS`: Build shared libraries.\n- `CAPSTONE_BUILD_STATIC_LIBS`: Build static libraries (`ON` by default).\n- `CAPSTONE_BUILD_STATIC_MSVC_RUNTIME`: (Windows only) - Build with static MSVC runtime. Always set if `CAPSTONE_BUILD_SHARED_LIBS=ON`.\n- `CAPSTONE_BUILD_CSTOOL`: Enable/disable build of `cstool`. Default is enabled if build runs from the repository root.\n- `CAPSTONE_USE_SYS_DYN_MEM`: change this to OFF to use your own dynamic memory management.\n- `CAPSTONE_BUILD_MACOS_THIN`: MacOS only. Disables universal2 build. So you only get the binary for you processor architecture.\n- `CAPSTONE_BUILD_DIET`: change this to ON to make the binaries more compact.\n- `CAPSTONE_X86_REDUCE`: change this to ON to make X86 binary smaller.\n- `CAPSTONE_X86_ATT_DISABLE`: change this to ON to disable AT&T syntax on x86.\n\nBy default, Capstone use system dynamic memory management, and both DIET and X86_REDUCE\nmodes are disabled. To use your own memory allocations, turn ON both DIET &\nX86_REDUCE, run \"cmake\" with: `-DCAPSTONE_USE_SYS_DYN_MEM=0`, `-DCAPSTONE_BUILD_DIET=1`, `-DCAPSTONE_X86_REDUCE=1`\n\n### Developer specific options\n\n- `CAPSTONE_DEBUG`: Change this to ON to enable extra debug assertions. Automatically enabled with `Debug` build.\n- `CAPSTONE_BUILD_CSTEST`: Build `cstest` in `suite/cstest/`. **Note:** `cstest` requires `libyaml` on your system. It attempts to build it from source otherwise.\n- `CMAKE_EXPORT_COMPILE_COMMANDS`: To export `compile_commands.json` for `clangd` and other language servers.\n- `ENABLE_ASAN`: Compiles Capstone with the address sanitizer.\n- `ENABLE_COVERAGE`: Generate coverage files.\n- `CAPSTONE_BUILD_LEGACY_TESTS`: Build some legacy integration tests.\n\n## Building cstest\n\n`cstest` is build together with Capstone by adding the flag `-DCAPSTONE_BUILD_CSTEST`.\n\nThe build requires `libyaml`. It is a fairly common package and should be provided by your package manager.\n\n_Note:_ Currently `cstest` us only supported on Linux.\n\nIf you run another operation system, please install `cstest_py`.\nSee `bindings/python/BUILDING.md` for instructions.\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 32.0712890625,
          "content": "# For MSVC_RUNTIME_LIBRARY\ncmake_minimum_required(VERSION 3.15)\n\nif(CMAKE_SOURCE_DIR STREQUAL CMAKE_BINARY_DIR)\n    message(FATAL_ERROR \"In-tree builds are not supported. Run CMake from a separate directory: cmake -B build\")\nendif()\n\nset(BUILD_RPATH_USE_ORIGIN true)\n\n# Detect whether capstone is compiled as top-level or a subdirectory\nset(PROJECT_IS_TOP_LEVEL OFF)\nif(CMAKE_CURRENT_SOURCE_DIR STREQUAL CMAKE_SOURCE_DIR)\n    set(PROJECT_IS_TOP_LEVEL ON)\n\n    # Enable folder support\n    set_property(GLOBAL PROPERTY USE_FOLDERS ON)\nendif()\n\n# https://cmake.org/cmake/help/latest/policy/CMP0042.html\ncmake_policy(SET CMP0042 NEW)\n\n# Check if VERSION is provided externally, otherwise default to 6.0.0\nif(NOT DEFINED PROJECT_VERSION)\n    set(PROJECT_VERSION \"6.0.0\")\nendif()\n\n# Extract the major, minor, and patch versions\nstring(REGEX MATCH \"^[0-9]+\\\\.[0-9]+\\\\.[0-9]+\" PROJECT_VERSION_BASE ${PROJECT_VERSION})\n\n# Set the project version without the pre-release identifier\nproject(capstone VERSION ${PROJECT_VERSION_BASE})\n\nset(UNIX_COMPILER_OPTIONS -Werror -Wall -Warray-bounds -Wshift-negative-value -Wreturn-type -Wformat -Wmissing-braces -Wunused-function -Warray-bounds -Wunused-variable -Wparentheses -Wint-in-bool-context -Wmisleading-indentation)\n\n# maybe-uninitialized is only supported by newer versions of GCC.\n# Unfortunately, it is pretty unreliable and reports wrong results.\n# So we disable it for all compilers versions which support it.\ninclude(CheckCCompilerFlag)\ncheck_c_compiler_flag(\"-Wno-maybe-uninitialized\" SUPPORTS_MU)\ncheck_c_compiler_flag(\"-Wshadow=local\" SUPPORTS_SHADOWING)\ncheck_c_compiler_flag(\"-Wsometimes-uninitialized\" SUPPORTS_SUNINIT)\n\nif (SUPPORTS_MU)\n    set(UNIX_COMPILER_OPTIONS ${UNIX_COMPILER_OPTIONS} -Wno-maybe-uninitialized)\nendif()\n\nif (SUPPORTS_SHADOWING)\n    set(UNIX_COMPILER_OPTIONS ${UNIX_COMPILER_OPTIONS} -Wshadow=local)\nendif()\n\nif (SUPPORTS_SUNINIT)\n    set(UNIX_COMPILER_OPTIONS ${UNIX_COMPILER_OPTIONS} -Wsometimes-uninitialized)\nendif()\n\nif (MSVC)\n    add_compile_options(/W1 /w14189)\nelse()\n    add_compile_options(${UNIX_COMPILER_OPTIONS})\nendif()\n\n\n# to configure the options specify them in the command line or change them in the cmake UI.\n# Don't edit the makefile!\noption(CAPSTONE_BUILD_SHARED_LIBS \"Build shared library\" OFF)\noption(CAPSTONE_BUILD_STATIC_LIBS \"Build static library\" ON)\noption(CAPSTONE_BUILD_STATIC_MSVC_RUNTIME \"Embed static MSVC runtime (Windows only). Always set if CAPSTONE_BUILD_SHARED_LIBS=ON\" ${CAPSTONE_BUILD_SHARED_LIBS})\noption(CAPSTONE_BUILD_MACOS_THIN \"Disable universal2 builds on macOS\" OFF)\noption(CAPSTONE_BUILD_DIET \"Build diet library\" OFF)\noption(CAPSTONE_BUILD_LEGACY_TESTS \"Build legacy tests\" ${PROJECT_IS_TOP_LEVEL})\noption(CAPSTONE_BUILD_CSTOOL \"Build cstool\" ${PROJECT_IS_TOP_LEVEL})\noption(CAPSTONE_BUILD_CSTEST \"Build cstest\" OFF)\noption(CAPSTONE_USE_DEFAULT_ALLOC \"Use default memory allocation functions\" ON)\noption(CAPSTONE_USE_ARCH_REGISTRATION \"Use explicit architecture registration\" OFF)\noption(CAPSTONE_ARCHITECTURE_DEFAULT \"Whether architectures are enabled by default\" ON)\noption(CAPSTONE_DEBUG \"Whether to enable extra debug assertions (enabled with CMAKE_BUILD_TYPE=Debug)\" OFF)\noption(CAPSTONE_INSTALL \"Generate install target\" ${PROJECT_IS_TOP_LEVEL})\noption(ENABLE_ASAN \"Enable address sanitizer\" OFF)\noption(ENABLE_COVERAGE \"Enable test coverage\" OFF)\n\nif (NOT CAPSTONE_BUILD_SHARED_LIBS AND NOT CAPSTONE_BUILD_STATIC_LIBS)\n    FATAL_ERROR(\"CAPSTONE_BUILD_SHARED_LIBS and CAPSTONE_BUILD_STATIC_LIBS are both unset. Nothing to build.\")\nendif()\n\nif (ENABLE_ASAN)\n    message(\"Enabling ASAN\")\n    add_definitions(-DASAN_ENABLED)\n    add_compile_options(-fsanitize=address,undefined)\n    add_link_options(-fsanitize=address,undefined)\nendif()\n\nif (ENABLE_COVERAGE)\n    message(\"Enabling COVERAGE\")\n    add_compile_options(--coverage)\n    add_link_options(--coverage)\nendif()\n\n# If building for OSX it's best to allow CMake to handle building both architectures\nif(APPLE AND NOT CAPSTONE_BUILD_MACOS_THIN)\n    set(CMAKE_OSX_ARCHITECTURES \"x86_64;arm64\")\nendif()\n\nset(SUPPORTED_ARCHITECTURES ARM AARCH64 M68K MIPS PPC SPARC SYSTEMZ XCORE X86 TMS320C64X M680X EVM MOS65XX WASM BPF RISCV SH TRICORE ALPHA HPPA LOONGARCH XTENSA)\nset(SUPPORTED_ARCHITECTURE_LABELS ARM AARCH64 M68K MIPS PowerPC Sparc SystemZ XCore x86 TMS320C64x M680x EVM MOS65XX WASM BPF RISCV SH TriCore Alpha HPPA LoongArch Xtensa)\n\n# If building for OSX it's best to allow CMake to handle building both architectures\nif(APPLE AND NOT CAPSTONE_BUILD_MACOS_THIN)\n    # The cibuildwheel on Github Actions sets this env variable\n    # with the architecture flags it wants to build for.\n    if(DEFINED ENV{ARCHFLAGS})\n        if(\"$ENV{ARCHFLAGS}\" STREQUAL \"-arch arm64 -arch x86_64\")\n            set(CMAKE_OSX_ARCHITECTURES \"x86_64;arm64\")\n        elseif(\"$ENV{ARCHFLAGS}\" STREQUAL \"-arch arm64\")\n            set(CMAKE_OSX_ARCHITECTURES \"arm64\")\n        elseif(\"$ENV{ARCHFLAGS}\" STREQUAL \"-arch x86_64\")\n            set(CMAKE_OSX_ARCHITECTURES \"x86_64\")\n        endif()\n    else()\n        set(CMAKE_OSX_ARCHITECTURES \"x86_64;arm64\")\n    endif()\nendif()\n\nlist(LENGTH SUPPORTED_ARCHITECTURES count)\nmath(EXPR count \"${count}-1\")\n# create options controlling whether support for a particular architecture is needed\nforeach(i RANGE ${count})\n    list(GET SUPPORTED_ARCHITECTURES ${i} supported_architecture)\n    list(GET SUPPORTED_ARCHITECTURE_LABELS ${i} supported_architecture_label)\n    option(\"CAPSTONE_${supported_architecture}_SUPPORT\" \"${supported_architecture_label} support\" ${CAPSTONE_ARCHITECTURE_DEFAULT})\nendforeach()\n\noption(CAPSTONE_X86_REDUCE \"x86 with reduce instruction sets to minimize library\" OFF)\noption(CAPSTONE_X86_ATT_DISABLE \"Disable x86 AT&T syntax\" OFF)\noption(CAPSTONE_OSXKERNEL_SUPPORT \"Support to embed Capstone into OS X Kernel extensions\" OFF)\n\nif(CAPSTONE_BUILD_DIET)\n    add_definitions(-DCAPSTONE_DIET)\nendif()\n\nif(CAPSTONE_USE_DEFAULT_ALLOC)\n    add_definitions(-DCAPSTONE_USE_SYS_DYN_MEM)\nendif()\n\nif(CAPSTONE_USE_ARCH_REGISTRATION)\n    add_definitions(-DCAPSTONE_USE_ARCH_REGISTRATION)\nelseif(CAPSTONE_ARCHITECTURE_DEFAULT)\n    # propagate architecture support variables to preprocessor\n    foreach(supported_architecture ${SUPPORTED_ARCHITECTURES})\n        set(option_name \"CAPSTONE_${supported_architecture}_SUPPORT\")\n        if(${option_name})\n            message(\"Enabling ${option_name}\")\n            add_definitions(\"-D${option_name}\")\n        endif()\n    endforeach()\nendif()\n\nif(CAPSTONE_X86_REDUCE)\n    add_definitions(-DCAPSTONE_X86_REDUCE)\nendif()\n\nif(CAPSTONE_X86_ATT_DISABLE)\n    add_definitions(-DCAPSTONE_X86_ATT_DISABLE)\nendif()\n\nif(CAPSTONE_DEBUG OR CMAKE_BUILD_TYPE STREQUAL \"Debug\")\n    add_definitions(-DCAPSTONE_DEBUG)\nendif()\n\n# Force static runtime libraries\nif(CAPSTONE_BUILD_STATIC_MSVC_RUNTIME)\n    set(CMAKE_MSVC_RUNTIME_LIBRARY \"MultiThreaded$<$<CONFIG:Debug>:Debug>\")\nendif()\n\n## sources\nset(SOURCES_ENGINE\n    cs.c\n    Mapping.c\n    MCInst.c\n    MCInstrDesc.c\n    MCInstPrinter.c\n    MCRegisterInfo.c\n    SStream.c\n    utils.c\n)\nset(HEADERS_ENGINE\n    cs_simple_types.h\n    cs_priv.h\n    LEB128.h\n    Mapping.h\n    MathExtras.h\n    MCDisassembler.h\n    MCFixedLenDisassembler.h\n    MCInst.h\n    MCInstrDesc.h\n    MCInstPrinter.h\n    MCRegisterInfo.h\n    SStream.h\n    utils.h\n)\n\nset(HEADERS_COMMON\n    include/capstone/aarch64.h\n    include/capstone/arm64.h\n    include/capstone/arm.h\n    include/capstone/capstone.h\n    include/capstone/cs_operand.h\n    include/capstone/evm.h\n    include/capstone/wasm.h\n    include/capstone/mips.h\n    include/capstone/ppc.h\n    include/capstone/x86.h\n    include/capstone/sparc.h\n    include/capstone/systemz.h\n    include/capstone/systemz_compatibility.h\n    include/capstone/xcore.h\n    include/capstone/m68k.h\n    include/capstone/tms320c64x.h\n    include/capstone/m680x.h\n    include/capstone/mos65xx.h\n    include/capstone/bpf.h\n    include/capstone/riscv.h\n    include/capstone/sh.h\n    include/capstone/tricore.h\n    include/capstone/platform.h\n    include/capstone/sh.h\n    include/capstone/alpha.h\n    include/capstone/hppa.h\n    include/capstone/loongarch.h\n    include/capstone/xtensa.h\n)\n\n## architecture support\nif(CAPSTONE_ARM_SUPPORT)\n    add_definitions(-DCAPSTONE_HAS_ARM)\n    set(SOURCES_ARM\n        arch/ARM/ARMBaseInfo.c\n        arch/ARM/ARMDisassembler.c\n        arch/ARM/ARMDisassemblerExtension.c\n        arch/ARM/ARMInstPrinter.c\n        arch/ARM/ARMMapping.c\n        arch/ARM/ARMModule.c\n    )\n    set(HEADERS_ARM\n        arch/ARM/ARMAddressingModes.h\n        arch/ARM/ARMBaseInfo.h\n        arch/ARM/ARMDisassemblerExtension.h\n        arch/ARM/ARMInstPrinter.h\n        arch/ARM/ARMLinkage.h\n        arch/ARM/ARMMapping.h\n        arch/ARM/ARMGenAsmWriter.inc\n        arch/ARM/ARMGenDisassemblerTables.inc\n        arch/ARM/ARMGenInstrInfo.inc\n        arch/ARM/ARMGenRegisterInfo.inc\n        arch/ARM/ARMGenSubtargetInfo.inc\n        arch/ARM/ARMGenCSFeatureName.inc\n        arch/ARM/ARMGenCSMappingInsn.inc\n        arch/ARM/ARMGenCSMappingInsnOp.inc\n        arch/ARM/ARMGenCSMappingInsnName.inc\n        arch/ARM/ARMGenSystemRegister.inc\n    )\nendif()\n\nif(CAPSTONE_AARCH64_SUPPORT)\n    add_definitions(-DCAPSTONE_HAS_AARCH64)\n    set(SOURCES_AARCH64\n        arch/AArch64/AArch64BaseInfo.c\n        arch/AArch64/AArch64Disassembler.c\n        arch/AArch64/AArch64DisassemblerExtension.c\n        arch/AArch64/AArch64InstPrinter.c\n        arch/AArch64/AArch64Mapping.c\n        arch/AArch64/AArch64Module.c\n    )\n    set(HEADERS_AARCH64\n        arch/AArch64/AArch64AddressingModes.h\n        arch/AArch64/AArch64BaseInfo.h\n        arch/AArch64/AArch64DisassemblerExtension.h\n        arch/AArch64/AArch64InstPrinter.h\n        arch/AArch64/AArch64Linkage.h\n        arch/AArch64/AArch64Mapping.h\n        arch/AArch64/AArch64GenAsmWriter.inc\n        arch/AArch64/AArch64GenDisassemblerTables.inc\n        arch/AArch64/AArch64GenInstrInfo.inc\n        arch/AArch64/AArch64GenRegisterInfo.inc\n        arch/AArch64/AArch64GenRegisterName.inc\n        arch/AArch64/AArch64GenSubtargetInfo.inc\n        arch/AArch64/AArch64GenSystemOperands.inc\n        arch/AArch64/AArch64GenCSMappingInsn.inc\n        arch/AArch64/AArch64GenCSMappingInsnName.inc\n        arch/AArch64/AArch64GenCSMappingInsnOp.inc\n    )\nendif()\n\nif(CAPSTONE_MIPS_SUPPORT)\n    add_definitions(-DCAPSTONE_HAS_MIPS)\n    set(SOURCES_MIPS\n        arch/Mips/MipsDisassembler.c\n        arch/Mips/MipsInstPrinter.c\n        arch/Mips/MipsMapping.c\n        arch/Mips/MipsModule.c\n    )\n    set(HEADERS_MIPS\n        arch/Mips/MipsDisassembler.h\n        arch/Mips/MipsGenAsmWriter.inc\n        arch/Mips/MipsGenDisassemblerTables.inc\n        arch/Mips/MipsGenInstrInfo.inc\n        arch/Mips/MipsGenRegisterInfo.inc\n        arch/Mips/MipsGenSubtargetInfo.inc\n        arch/Mips/MipsInstPrinter.h\n        arch/Mips/MipsMapping.h\n        arch/Mips/MipsMappingInsn.inc\n    )\n    set(HEADERS_MIPS\n        arch/Mips/MipsDisassembler.h\n        arch/Mips/MipsGenAsmWriter.inc\n        arch/Mips/MipsGenDisassemblerTables.inc\n        arch/Mips/MipsGenInstrInfo.inc\n        arch/Mips/MipsGenRegisterInfo.inc\n        arch/Mips/MipsGenSubtargetInfo.inc\n        arch/Mips/MipsInstPrinter.h\n        arch/Mips/MipsMapping.h\n    )\nendif()\n\nif(CAPSTONE_PPC_SUPPORT)\n    add_definitions(-DCAPSTONE_HAS_POWERPC)\n    set(SOURCES_PPC\n        arch/PowerPC/PPCDisassembler.c\n        arch/PowerPC/PPCInstPrinter.c\n        arch/PowerPC/PPCMapping.c\n        arch/PowerPC/PPCModule.c\n    )\n    set(HEADERS_PPC\n        arch/PowerPC/PPCInstrInfo.h\n        arch/PowerPC/PPCLinkage.h\n        arch/PowerPC/PPCMapping.h\n        arch/PowerPC/PPCMCTargetDesc.h\n        arch/PowerPC/PPCPredicates.h\n        arch/PowerPC/PPCRegisterInfo.h\n        arch/PowerPC/PPCGenAsmWriter.inc\n        arch/PowerPC/PPCGenCSFeatureName.inc\n        arch/PowerPC/PPCGenCSMappingInsn.inc\n        arch/PowerPC/PPCGenCSMappingInsnOp.inc\n        arch/PowerPC/PPCGenCSMappingInsnName.inc\n        arch/PowerPC/PPCGenCSOpGroup.inc\n        arch/PowerPC/PPCGenDisassemblerTables.inc\n        arch/PowerPC/PPCGenInstrInfo.inc\n        arch/PowerPC/PPCGenSubtargetInfo.inc\n        arch/PowerPC/PPCGenRegisterInfo.inc\n    )\nendif()\n\nif(CAPSTONE_X86_SUPPORT)\n    add_definitions(-DCAPSTONE_HAS_X86)\n    set(SOURCES_X86\n        arch/X86/X86Disassembler.c\n        arch/X86/X86DisassemblerDecoder.c\n        arch/X86/X86IntelInstPrinter.c\n        arch/X86/X86InstPrinterCommon.c\n        arch/X86/X86Mapping.c\n        arch/X86/X86Module.c\n    )\n    set(HEADERS_X86\n        arch/X86/X86BaseInfo.h\n        arch/X86/X86Disassembler.h\n        arch/X86/X86DisassemblerDecoder.h\n        arch/X86/X86DisassemblerDecoderCommon.h\n        arch/X86/X86GenAsmWriter.inc\n        arch/X86/X86GenAsmWriter1.inc\n        arch/X86/X86GenAsmWriter1_reduce.inc\n        arch/X86/X86GenAsmWriter_reduce.inc\n        arch/X86/X86GenDisassemblerTables.inc\n        arch/X86/X86GenDisassemblerTables_reduce.inc\n        arch/X86/X86GenInstrInfo.inc\n        arch/X86/X86GenInstrInfo_reduce.inc\n        arch/X86/X86GenRegisterInfo.inc\n        arch/X86/X86InstPrinter.h\n        arch/X86/X86Mapping.h\n        arch/X86/X86MappingInsn.inc\n        arch/X86/X86MappingInsnOp.inc\n        arch/X86/X86MappingInsnOp_reduce.inc\n        arch/X86/X86MappingInsn_reduce.inc\n    )\n    set(HEADERS_X86\n        arch/X86/X86BaseInfo.h\n        arch/X86/X86Disassembler.h\n        arch/X86/X86DisassemblerDecoder.h\n        arch/X86/X86DisassemblerDecoderCommon.h\n        arch/X86/X86GenAsmWriter.inc\n        arch/X86/X86GenAsmWriter1.inc\n        arch/X86/X86GenAsmWriter1_reduce.inc\n        arch/X86/X86GenAsmWriter_reduce.inc\n        arch/X86/X86GenDisassemblerTables.inc\n        arch/X86/X86GenDisassemblerTables_reduce.inc\n        arch/X86/X86GenInstrInfo.inc\n        arch/X86/X86GenInstrInfo_reduce.inc\n        arch/X86/X86GenRegisterInfo.inc\n        arch/X86/X86InstPrinter.h\n        arch/X86/X86Mapping.h\n    )\n    if(NOT CAPSTONE_BUILD_DIET)\n        set(SOURCES_X86 ${SOURCES_X86} arch/X86/X86ATTInstPrinter.c)\n    endif()\nendif()\n\nif(CAPSTONE_SPARC_SUPPORT)\n    add_definitions(-DCAPSTONE_HAS_SPARC)\n    set(SOURCES_SPARC\n        arch/Sparc/SparcDisassembler.c\n        arch/Sparc/SparcInstPrinter.c\n        arch/Sparc/SparcMapping.c\n        arch/Sparc/SparcModule.c\n    )\n    set(HEADERS_SPARC\n        arch/Sparc/Sparc.h\n        arch/Sparc/SparcDisassembler.h\n        arch/Sparc/SparcGenAsmWriter.inc\n        arch/Sparc/SparcGenDisassemblerTables.inc\n        arch/Sparc/SparcGenInstrInfo.inc\n        arch/Sparc/SparcGenRegisterInfo.inc\n        arch/Sparc/SparcGenSubtargetInfo.inc\n        arch/Sparc/SparcInstPrinter.h\n        arch/Sparc/SparcMapping.h\n        arch/Sparc/SparcMappingInsn.inc\n    )\nendif()\n\nif(CAPSTONE_SYSTEMZ_SUPPORT)\n    add_definitions(-DCAPSTONE_HAS_SYSTEMZ)\n    set(SOURCES_SYSTEMZ\n        arch/SystemZ/SystemZDisassembler.c\n        arch/SystemZ/SystemZDisassemblerExtension.c\n        arch/SystemZ/SystemZInstPrinter.c\n        arch/SystemZ/SystemZMapping.c\n        arch/SystemZ/SystemZModule.c\n        arch/SystemZ/SystemZMCTargetDesc.c\n    )\n    set(HEADERS_SYSTEMZ\n        arch/SystemZ/SystemZLinkage.h\n        arch/SystemZ/SystemZDisassemblerExtension.h\n        arch/SystemZ/SystemZInstPrinter.h\n        arch/SystemZ/SystemZMCTargetDesc.h\n        arch/SystemZ/SystemZMapping.h\n        arch/SystemZ/SystemZModule.h\n        arch/SystemZ/SystemZGenAsmWriter.inc\n        arch/SystemZ/SystemZGenCSAliasMnemMap.inc\n        arch/SystemZ/SystemZGenCSFeatureName.inc\n        arch/SystemZ/SystemZGenCSMappingInsn.inc\n        arch/SystemZ/SystemZGenCSMappingInsnName.inc\n        arch/SystemZ/SystemZGenCSMappingInsnOp.inc\n        arch/SystemZ/SystemZGenCSOpGroup.inc\n        arch/SystemZ/SystemZGenDisassemblerTables.inc\n        arch/SystemZ/SystemZGenInstrInfo.inc\n        arch/SystemZ/SystemZGenRegisterInfo.inc\n        arch/SystemZ/SystemZGenSubtargetInfo.inc\n    )\nendif()\n\nif(CAPSTONE_XCORE_SUPPORT)\n    add_definitions(-DCAPSTONE_HAS_XCORE)\n    set(SOURCES_XCORE\n        arch/XCore/XCoreDisassembler.c\n        arch/XCore/XCoreInstPrinter.c\n        arch/XCore/XCoreMapping.c\n        arch/XCore/XCoreModule.c\n    )\n    set(HEADERS_XCORE\n        arch/XCore/XCoreDisassembler.h\n        arch/XCore/XCoreGenAsmWriter.inc\n        arch/XCore/XCoreGenDisassemblerTables.inc\n        arch/XCore/XCoreGenInstrInfo.inc\n        arch/XCore/XCoreGenRegisterInfo.inc\n        arch/XCore/XCoreInstPrinter.h\n        arch/XCore/XCoreMapping.h\n        arch/XCore/XCoreMappingInsn.inc\n    )\nendif()\n\nif(CAPSTONE_M68K_SUPPORT)\n    add_definitions(-DCAPSTONE_HAS_M68K)\n    set(SOURCES_M68K\n        arch/M68K/M68KDisassembler.c\n        arch/M68K/M68KInstPrinter.c\n        arch/M68K/M68KModule.c\n    )\n    set(HEADERS_M68K\n        arch/M68K/M68KDisassembler.h\n    )\nendif()\n\nif(CAPSTONE_TMS320C64X_SUPPORT)\n    add_definitions(-DCAPSTONE_HAS_TMS320C64X)\n    set(SOURCES_TMS320C64X\n        arch/TMS320C64x/TMS320C64xDisassembler.c\n        arch/TMS320C64x/TMS320C64xInstPrinter.c\n        arch/TMS320C64x/TMS320C64xMapping.c\n        arch/TMS320C64x/TMS320C64xModule.c\n    )\n    set(HEADERS_TMS320C64X\n        arch/TMS320C64x/TMS320C64xDisassembler.h\n        arch/TMS320C64x/TMS320C64xGenAsmWriter.inc\n        arch/TMS320C64x/TMS320C64xGenDisassemblerTables.inc\n        arch/TMS320C64x/TMS320C64xGenInstrInfo.inc\n        arch/TMS320C64x/TMS320C64xGenRegisterInfo.inc\n        arch/TMS320C64x/TMS320C64xInstPrinter.h\n        arch/TMS320C64x/TMS320C64xMapping.h\n    )\nendif()\n\nif(CAPSTONE_M680X_SUPPORT)\n    add_definitions(-DCAPSTONE_HAS_M680X)\n    set(SOURCES_M680X\n        arch/M680X/M680XDisassembler.c\n        arch/M680X/M680XInstPrinter.c\n        arch/M680X/M680XModule.c\n    )\n    set(HEADERS_M680X\n        arch/M680X/M680XInstPrinter.h\n        arch/M680X/M680XDisassembler.h\n        arch/M680X/M680XDisassemblerInternals.h\n    )\nendif()\n\nif(CAPSTONE_EVM_SUPPORT)\n    add_definitions(-DCAPSTONE_HAS_EVM)\n    set(SOURCES_EVM\n        arch/EVM/EVMDisassembler.c\n        arch/EVM/EVMInstPrinter.c\n        arch/EVM/EVMMapping.c\n        arch/EVM/EVMModule.c\n    )\n    set(HEADERS_EVM\n        arch/EVM/EVMDisassembler.h\n        arch/EVM/EVMInstPrinter.h\n        arch/EVM/EVMMapping.h\n        arch/EVM/EVMMappingInsn.inc\n    )\nendif()\n\nif(CAPSTONE_WASM_SUPPORT)\n    add_definitions(-DCAPSTONE_HAS_WASM)\n    set(SOURCES_WASM\n        arch/WASM/WASMDisassembler.c\n        arch/WASM/WASMInstPrinter.c\n        arch/WASM/WASMMapping.c\n        arch/WASM/WASMModule.c\n    )\n    set(HEADERS_WASM\n        arch/WASM/WASMDisassembler.h\n        arch/WASM/WASMInstPrinter.h\n        arch/WASM/WASMMapping.h\n    )\nendif()\n\nif(CAPSTONE_MOS65XX_SUPPORT)\n    add_definitions(-DCAPSTONE_HAS_MOS65XX)\n    set(SOURCES_MOS65XX\n            arch/MOS65XX/MOS65XXModule.c\n            arch/MOS65XX/MOS65XXDisassembler.c)\n    set(HEADERS_SOURCES_MOS65XX\n            arch/MOS65XX/MOS65XXDisassembler.h\n    )\nendif()\n\nif(CAPSTONE_BPF_SUPPORT)\n    add_definitions(-DCAPSTONE_HAS_BPF)\n    set(SOURCES_BPF\n        arch/BPF/BPFDisassembler.c\n        arch/BPF/BPFInstPrinter.c\n        arch/BPF/BPFMapping.c\n        arch/BPF/BPFModule.c\n    )\n    set(HEADERS_BPF\n        arch/BPF/BPFConstants.h\n        arch/BPF/BPFDisassembler.h\n        arch/BPF/BPFInstPrinter.h\n        arch/BPF/BPFMapping.h\n        arch/BPF/BPFModule.h\n    )\nendif()\n\nif(CAPSTONE_RISCV_SUPPORT)\n    add_definitions(-DCAPSTONE_HAS_RISCV)\n    set(SOURCES_RISCV\n        arch/RISCV/RISCVDisassembler.c\n        arch/RISCV/RISCVInstPrinter.c\n        arch/RISCV/RISCVMapping.c\n        arch/RISCV/RISCVModule.c\n    )\n    set(HEADERS_RISCV\n        arch/RISCV/RISCVBaseInfo.h\n        arch/RISCV/RISCVDisassembler.h\n        arch/RISCV/RISCVInstPrinter.h\n        arch/RISCV/RISCVMapping.h\n        arch/RISCV/RISCVModule.h\n        arch/RISCV/RISCVGenAsmWriter.inc\n        arch/RISCV/RISCVGenDisassemblerTables.inc\n        arch/RISCV/RISCVGenInsnNameMaps.inc\n        arch/RISCV/RISCVGenInstrInfo.inc\n        arch/RISCV/RISCVGenRegisterInfo.inc\n        arch/RISCV/RISCVGenSubtargetInfo.inc\n        arch/RISCV/RISCVMappingInsn.inc\n        arch/RISCV/RISCVMappingInsnOp.inc\n    )\nendif()\n\nif(CAPSTONE_SH_SUPPORT)\n    add_definitions(-DCAPSTONE_HAS_SH)\n    set(SOURCES_SH\n        arch/SH/SHDisassembler.c\n        arch/SH/SHInstPrinter.c\n        arch/SH/SHModule.c\n    )\n    set(HEADERS_SH\n        arch/SH/SHDisassembler.h\n        arch/SH/SHInstPrinter.h\n        arch/SH/SHModule.h\n        arch/SH/SHInsnTable.inc\n    )\nendif()\n\nif (CAPSTONE_TRICORE_SUPPORT)\n    add_definitions(-DCAPSTONE_HAS_TRICORE)\n    set(SOURCES_TRICORE\n            arch/TriCore/TriCoreDisassembler.c\n            arch/TriCore/TriCoreInstPrinter.c\n            arch/TriCore/TriCoreMapping.c\n            arch/TriCore/TriCoreModule.c\n            )\n    set(HEADERS_TRICORE\n            arch/TriCore/TriCoreDisassembler.h\n            arch/TriCore/TriCoreLinkage.h\n            arch/TriCore/TriCoreGenAsmWriter.inc\n            arch/TriCore/TriCoreGenDisassemblerTables.inc\n            arch/TriCore/TriCoreGenInstrInfo.inc\n            arch/TriCore/TriCoreGenRegisterInfo.inc\n            arch/TriCore/TriCoreMapping.h\n            arch/TriCore/TriCoreModule.h\n            )\nendif ()\n\nif (CAPSTONE_ALPHA_SUPPORT)\n    add_definitions(-DCAPSTONE_HAS_ALPHA)\n    set(SOURCES_ALPHA\n            arch/Alpha/AlphaDisassembler.c\n            arch/Alpha/AlphaInstPrinter.c\n            arch/Alpha/AlphaMapping.c\n            arch/Alpha/AlphaModule.c\n            )\n    set(HEADERS_ALPHA\n            arch/Alpha/AlphaDisassembler.h\n            arch/Alpha/AlphaGenAsmWriter.inc\n            arch/Alpha/AlphaGenDisassemblerTables.inc\n            arch/Alpha/AlphaGenInstrInfo.inc\n            arch/Alpha/AlphaGenRegisterInfo.inc\n            arch/Alpha/AlphaLinkage.h\n            arch/Alpha/AlphaMapping.h\n            arch/Alpha/AlphaModule.h\n            arch/Alpha/AlphaGenCSMappingInsnOp.inc\n            arch/Alpha/AlphaGenCSMappingInsn.inc\n            arch/Alpha/AlphaGenCSMappingInsnName.inc\n            )\nendif ()\n\nif(CAPSTONE_HPPA_SUPPORT)\n    add_definitions(-DCAPSTONE_HAS_HPPA)\n    set(SOURCES_HPPA\n        arch/HPPA/HPPADisassembler.c\n        arch/HPPA/HPPAInstPrinter.c\n        arch/HPPA/HPPAMapping.c\n        arch/HPPA/HPPAModule.c\n    )\n    set(HEADERS_HPPA\n        arch/HPPA/HPPAConstants.h\n        arch/HPPA/HPPADisassembler.h\n        arch/HPPA/HPPAInstPrinter.h\n        arch/HPPA/HPPAMapping.h\n        arch/HPPA/HPPAModule.h\n    )\nendif()\n\nif (CAPSTONE_LOONGARCH_SUPPORT)\n    add_definitions(-DCAPSTONE_HAS_LOONGARCH)\n    set(SOURCES_LOONGARCH\n            arch/LoongArch/LoongArchDisassembler.c\n            arch/LoongArch/LoongArchDisassemblerExtension.c\n            arch/LoongArch/LoongArchInstPrinter.c\n            arch/LoongArch/LoongArchMapping.c\n            arch/LoongArch/LoongArchModule.c\n            )\n    set(HEADERS_LOONGARCH\n            arch/LoongArch/LoongArchInstPrinter.h\n            arch/LoongArch/LoongArchMapping.h\n            arch/LoongArch/LoongArchModule.h\n            arch/LoongArch/LoongArchLinkage.h\n            )\nendif ()\n\nif(CAPSTONE_XTENSA_SUPPORT)\n    add_definitions(-DCAPSTONE_HAS_XTENSA)\n    set(SOURCES_XTENSA\n        arch/Xtensa/XtensaDisassembler.c\n        arch/Xtensa/XtensaInstPrinter.c\n        arch/Xtensa/XtensaMapping.c\n        arch/Xtensa/XtensaModule.c\n    )\n    set(HEADERS_XTENSA\n        arch/Xtensa/XtensaDisassembler.h\n        arch/Xtensa/XtensaInstPrinter.h\n        arch/Xtensa/XtensaMapping.h\n        arch/Xtensa/XtensaModule.h\n    )\nendif()\n\nif (CAPSTONE_OSXKERNEL_SUPPORT)\n    add_definitions(-DCAPSTONE_HAS_OSXKERNEL)\nendif()\n\nset(ALL_SOURCES\n    ${SOURCES_ENGINE}\n    ${SOURCES_ARM}\n    ${SOURCES_AARCH64}\n    ${SOURCES_MIPS}\n    ${SOURCES_PPC}\n    ${SOURCES_X86}\n    ${SOURCES_SPARC}\n    ${SOURCES_SYSTEMZ}\n    ${SOURCES_XCORE}\n    ${SOURCES_M68K}\n    ${SOURCES_TMS320C64X}\n    ${SOURCES_M680X}\n    ${SOURCES_EVM}\n    ${SOURCES_WASM}\n    ${SOURCES_MOS65XX}\n    ${SOURCES_BPF}\n    ${SOURCES_RISCV}\n    ${SOURCES_SH}\n    ${SOURCES_TRICORE}\n    ${SOURCES_ALPHA}\n    ${SOURCES_HPPA}\n    ${SOURCES_LOONGARCH}\n    ${SOURCES_XTENSA}\n)\n\nset(ALL_HEADERS\n    ${HEADERS_COMMON}\n    ${HEADERS_ENGINE}\n    ${HEADERS_ARM}\n    ${HEADERS_AARCH64}\n    ${HEADERS_MIPS}\n    ${HEADERS_PPC}\n    ${HEADERS_X86}\n    ${HEADERS_SPARC}\n    ${HEADERS_SYSTEMZ}\n    ${HEADERS_XCORE}\n    ${HEADERS_M68K}\n    ${HEADERS_TMS320C64X}\n    ${HEADERS_M680X}\n    ${HEADERS_EVM}\n    ${HEADERS_WASM}\n    ${HEADERS_MOS65XX}\n    ${HEADERS_BPF}\n    ${HEADERS_RISCV}\n    ${HEADERS_SH}\n    ${HEADERS_TRICORE}\n    ${HEADERS_ALPHA}\n    ${HEADERS_HPPA}\n    ${HEADERS_LOONGARCH}\n    ${HEADERS_XTENSA}\n)\n\n## properties\n# version info\nset_property(GLOBAL PROPERTY VERSION ${PROJECT_VERSION})\n\n## targets\nadd_library(capstone OBJECT ${ALL_SOURCES} ${ALL_HEADERS})\nset_property(TARGET capstone PROPERTY C_STANDARD 99)\ntarget_include_directories(capstone PUBLIC\n    $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}/include>\n)\n\nif(CAPSTONE_BUILD_STATIC_LIBS)\n    add_library(capstone_static STATIC $<TARGET_OBJECTS:capstone>)\n    # Use normal capstone name. Otherwise we get libcapstone_static.a\n    set_target_properties(capstone_static PROPERTIES OUTPUT_NAME \"capstone\")\n    target_include_directories(capstone_static PUBLIC\n        $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}/include>\n    )\nendif()\n\nif(CAPSTONE_BUILD_SHARED_LIBS)\n    set_property(TARGET capstone PROPERTY POSITION_INDEPENDENT_CODE 1)\n    add_library(capstone_shared SHARED $<TARGET_OBJECTS:capstone>)\n    # Use normal capstone name. Otherwise we get libcapstone_shared.so\n    set_target_properties(capstone_shared PROPERTIES OUTPUT_NAME \"capstone\")\n    set_target_properties(capstone_shared PROPERTIES\n        VERSION ${PROJECT_VERSION}\n        SOVERSION ${PROJECT_VERSION_MAJOR}\n    )\n    target_include_directories(capstone_shared PUBLIC\n        $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}/include>\n    )\n    target_compile_definitions(capstone PUBLIC CAPSTONE_SHARED)\nendif()\n\n# Fuzzer if this is moved to it's own CMakeLists.txt (as it should be)\n# the OSS fuzzer build fails. And must be fixed.\n# Simply because it builds the fuzzer there again with hard-coded paths.\n# See: https://github.com/google/oss-fuzz/blob/master/projects/capstone/build.sh\n# and: https://github.com/capstone-engine/capstone/issues/2454\nadd_executable(fuzz_disasm ${PROJECT_SOURCE_DIR}/suite/fuzz/onefile.c ${PROJECT_SOURCE_DIR}/suite/fuzz/fuzz_disasm.c ${PROJECT_SOURCE_DIR}/suite/fuzz/platform.c)\ntarget_link_libraries(fuzz_disasm PRIVATE capstone)\n\nsource_group(\"Source\\\\Engine\" FILES ${SOURCES_ENGINE})\nsource_group(\"Source\\\\ARM\" FILES ${SOURCES_ARM})\nsource_group(\"Source\\\\AARCH64\" FILES ${SOURCES_AARCH64})\nsource_group(\"Source\\\\Mips\" FILES ${SOURCES_MIPS})\nsource_group(\"Source\\\\PowerPC\" FILES ${SOURCES_PPC})\nsource_group(\"Source\\\\Sparc\" FILES ${SOURCES_SPARC})\nsource_group(\"Source\\\\SystemZ\" FILES ${SOURCES_SYSTEMZ})\nsource_group(\"Source\\\\X86\" FILES ${SOURCES_X86})\nsource_group(\"Source\\\\XCore\" FILES ${SOURCES_XCORE})\nsource_group(\"Source\\\\M68K\" FILES ${SOURCES_M68K})\nsource_group(\"Source\\\\TMS320C64x\" FILES ${SOURCES_TMS320C64X})\nsource_group(\"Source\\\\M680X\" FILES ${SOURCES_M680X})\nsource_group(\"Source\\\\EVM\" FILES ${SOURCES_EVM})\nsource_group(\"Source\\\\WASM\" FILES ${SOURCES_WASM})\nsource_group(\"Source\\\\MOS65XX\" FILES ${SOURCES_MOS65XX})\nsource_group(\"Source\\\\BPF\" FILES ${SOURCES_BPF})\nsource_group(\"Source\\\\RISCV\" FILES ${SOURCES_RISCV})\nsource_group(\"Source\\\\SH\" FILES ${SOURCES_SH})\nsource_group(\"Source\\\\TriCore\" FILES ${SOURCES_TRICORE})\nsource_group(\"Source\\\\Alpha\" FILES ${SOURCES_ALPHA})\nsource_group(\"Source\\\\HPPA\" FILES ${SOURCES_HPPA})\nsource_group(\"Source\\\\LoongArch\" FILES ${SOURCES_LOONGARCH})\nsource_group(\"Source\\\\Xtensa\" FILES ${SOURCES_XTENSA})\n\nsource_group(\"Include\\\\Common\" FILES ${HEADERS_COMMON})\nsource_group(\"Include\\\\Engine\" FILES ${HEADERS_ENGINE})\nsource_group(\"Include\\\\ARM\" FILES ${HEADERS_ARM})\nsource_group(\"Include\\\\AARCH64\" FILES ${HEADERS_AARCH64})\nsource_group(\"Include\\\\Mips\" FILES ${HEADERS_MIPS})\nsource_group(\"Include\\\\PowerPC\" FILES ${HEADERS_PPC})\nsource_group(\"Include\\\\Sparc\" FILES ${HEADERS_SPARC})\nsource_group(\"Include\\\\SystemZ\" FILES ${HEADERS_SYSTEMZ})\nsource_group(\"Include\\\\X86\" FILES ${HEADERS_X86})\nsource_group(\"Include\\\\XCore\" FILES ${HEADERS_XCORE})\nsource_group(\"Include\\\\M68K\" FILES ${HEADERS_M68K})\nsource_group(\"Include\\\\TMS320C64x\" FILES ${HEADERS_TMS320C64X})\nsource_group(\"Include\\\\M680X\" FILES ${HEADERS_MC680X})\nsource_group(\"Include\\\\EVM\" FILES ${HEADERS_EVM})\nsource_group(\"Include\\\\WASM\" FILES ${HEADERS_WASM})\nsource_group(\"Include\\\\MOS65XX\" FILES ${HEADERS_MOS65XX})\nsource_group(\"Include\\\\BPF\" FILES ${HEADERS_BPF})\nsource_group(\"Include\\\\RISCV\" FILES ${HEADERS_RISCV})\nsource_group(\"Include\\\\SH\" FILES ${HEADERS_SH})\nsource_group(\"Include\\\\TriCore\" FILES ${HEADERS_TRICORE})\nsource_group(\"Include\\\\Alpha\" FILES ${HEADERS_ALPHA})\nsource_group(\"Include\\\\HPPA\" FILES ${HEADERS_HPPA})\nsource_group(\"Include\\\\LoongArch\" FILES ${HEADERS_LOONGARCH})\nsource_group(\"Include\\\\Xtensa\" FILES ${HEADERS_XTENSA})\n\n## installation\nif(CAPSTONE_INSTALL)\n    include(GNUInstallDirs)\n    install(FILES ${HEADERS_COMMON} DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/capstone)\n    install(FILES ${HEADERS_INC} DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/capstone/inc)\n\n    # Support absolute installation paths (discussion: https://github.com/NixOS/nixpkgs/issues/144170)\n    if(IS_ABSOLUTE ${CMAKE_INSTALL_LIBDIR})\n        set(CAPSTONE_PKGCONFIG_INSTALL_LIBDIR ${CMAKE_INSTALL_LIBDIR})\n        set(CAPSTONE_CMAKE_INSTALL_LIBDIR ${CMAKE_INSTALL_LIBDIR})\n    else()\n        set(CAPSTONE_PKGCONFIG_INSTALL_LIBDIR \"\\${prefix}/${CMAKE_INSTALL_LIBDIR}\")\n        set(CAPSTONE_CMAKE_INSTALL_LIBDIR \"\\${PACKAGE_PREFIX_DIR}/${CMAKE_INSTALL_LIBDIR}\")\n    endif()\n    if(IS_ABSOLUTE ${CMAKE_INSTALL_INCLUDEDIR})\n        set(CAPSTONE_PKGCONFIG_INSTALL_INCLUDEDIR ${CMAKE_INSTALL_INCLUDEDIR})\n        set(CAPSTONE_CMAKE_INSTALL_INCLUDEDIR ${CMAKE_INSTALL_INCLUDEDIR})\n    else()\n        set(CAPSTONE_PKGCONFIG_INSTALL_INCLUDEDIR \"\\${prefix}/${CMAKE_INSTALL_INCLUDEDIR}\")\n        set(CAPSTONE_CMAKE_INSTALL_INCLUDEDIR \"\\${PACKAGE_PREFIX_DIR}/${CMAKE_INSTALL_INCLUDEDIR}\")\n    endif()\n\n    configure_file(capstone.pc.in ${CMAKE_BINARY_DIR}/capstone.pc @ONLY)\n    install(FILES ${CMAKE_BINARY_DIR}/capstone.pc DESTINATION ${CMAKE_INSTALL_LIBDIR}/pkgconfig)\n\n    include(CMakePackageConfigHelpers)\n    set(CAPSTONE_CMAKE_CONFIG_INSTALL_DIR \"${CMAKE_INSTALL_LIBDIR}/cmake/capstone\")\n    configure_package_config_file(\n        capstone-config.cmake.in\n        ${CMAKE_CURRENT_BINARY_DIR}/capstone-config.cmake\n        INSTALL_DESTINATION ${CAPSTONE_CMAKE_CONFIG_INSTALL_DIR}\n    )\n    write_basic_package_version_file(\n        ${CMAKE_CURRENT_BINARY_DIR}/capstone-config-version.cmake\n        VERSION ${PROJECT_VERSION}\n        COMPATIBILITY SameMajorVersion\n    )\n\n    install(FILES\n        \"${CMAKE_CURRENT_BINARY_DIR}/capstone-config.cmake\"\n        \"${CMAKE_CURRENT_BINARY_DIR}/capstone-config-version.cmake\"\n        DESTINATION ${CAPSTONE_CMAKE_CONFIG_INSTALL_DIR}\n    )\n\n    if(CAPSTONE_BUILD_SHARED_LIBS)\n        set(LIB_INSTALL_TARGETS capstone_shared)\n    endif()\n\n    if (CAPSTONE_BUILD_STATIC_LIBS)\n        set(LIB_INSTALL_TARGETS ${LIB_INSTALL_TARGETS} capstone_static)\n    endif()\n\n    install(TARGETS ${LIB_INSTALL_TARGETS}\n        EXPORT capstone-targets\n        RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}\n        LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}\n        ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}\n        INCLUDES DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}\n    )\n\n    install(EXPORT capstone-targets\n            NAMESPACE capstone::\n            DESTINATION ${CAPSTONE_CMAKE_CONFIG_INSTALL_DIR}\n    )\n\n    # uninstall target\n    if(NOT TARGET UNINSTALL)\n        configure_file(\n            \"${CMAKE_CURRENT_SOURCE_DIR}/cmake_uninstall.cmake.in\"\n            \"${CMAKE_CURRENT_BINARY_DIR}/cmake_uninstall.cmake\"\n            IMMEDIATE @ONLY\n        )\n        add_custom_target(UNINSTALL COMMAND ${CMAKE_COMMAND} -P ${CMAKE_CURRENT_BINARY_DIR}/cmake_uninstall.cmake)\n        set_target_properties(UNINSTALL PROPERTIES\n            FOLDER CMakePredefinedTargets\n        )\n    endif()\nendif()\n\nif(CAPSTONE_BUILD_CSTOOL)\n    file(GLOB CSTOOL_SRC cstool/*.c)\n    add_executable(cstool ${CSTOOL_SRC})\n    target_link_libraries(cstool PRIVATE capstone)\n\n    if(CAPSTONE_INSTALL)\n        install(TARGETS cstool EXPORT capstone-targets DESTINATION ${CMAKE_INSTALL_BINDIR})\n    endif()\nendif()\n\nif(CAPSTONE_BUILD_CSTEST)\n    enable_testing()\n    set(CSTEST_DIR ${PROJECT_SOURCE_DIR}/suite/cstest)\n    add_subdirectory(${CSTEST_DIR})\n\n    # Integration and unit tests\n    set(TESTS_INTEGRATION_DIR ${PROJECT_SOURCE_DIR}/tests/integration)\n    add_subdirectory(${TESTS_INTEGRATION_DIR})\n    set(TESTS_UNIT_DIR ${PROJECT_SOURCE_DIR}/tests/unit)\n    add_subdirectory(${TESTS_UNIT_DIR})\nendif()\n"
        },
        {
          "name": "CMakePresets.json",
          "type": "blob",
          "size": 3.8671875,
          "content": "{\n  \"version\": 3,\n  \"configurePresets\": [\n    {\n      \"name\": \"locations-base\",\n      \"hidden\": true,\n      \"binaryDir\": \"${sourceDir}/build/${presetName}\",\n      \"installDir\": \"${sourceDir}/out/install/${presetName}\"\n    },\n    {\n      \"name\": \"warnings-base\",\n      \"hidden\": true,\n      \"warnings\": {\n        \"dev\": true,\n        \"deprecated\": true,\n        \"systemVars\": true\n      },\n      \"errors\": {\n        \"dev\": true,\n        \"deprecated\": false\n      }\n    },\n    {\n      \"name\": \"ninja\",\n      \"hidden\": true,\n      \"displayName\": \"Ninja\",\n      \"generator\": \"Ninja Multi-Config\",\n      \"cacheVariables\": {\n        \"CMAKE_DEFAULT_BUILD_TYPE\": \"Debug\"\n      }\n    },\n    {\n      \"name\": \"x64\",\n      \"hidden\": true,\n      \"architecture\": {\n        \"value\": \"x64\",\n        \"strategy\": \"external\"\n      }\n    },\n    {\n      \"name\": \"linux-x64\",\n      \"inherits\": [ \"ninja\", \"x64\", \"locations-base\", \"warnings-base\" ],\n      \"condition\": {\"type\": \"equals\", \"lhs\": \"${hostSystemName}\", \"rhs\": \"Linux\"}\n    },\n    {\n      \"name\": \"macos-x64\",\n      \"inherits\": [ \"ninja\", \"x64\", \"locations-base\", \"warnings-base\" ],\n      \"condition\": {\"type\": \"equals\", \"lhs\": \"${hostSystemName}\", \"rhs\": \"Darwin\"}\n    },\n    {\n      \"name\": \"windows-x64\",\n      \"inherits\": [ \"ninja\", \"x64\", \"locations-base\", \"warnings-base\" ],\n      \"condition\": {\"type\": \"equals\", \"lhs\": \"${hostSystemName}\", \"rhs\": \"Windows\"}\n    }\n  ],\n  \"buildPresets\": [\n    {\n      \"name\": \"build-linux\",\n      \"configurePreset\": \"linux-x64\",\n      \"nativeToolOptions\": [ \"-v\" ],\n      \"condition\": {\"type\": \"equals\", \"lhs\": \"${hostSystemName}\", \"rhs\": \"Linux\"}\n    },\n    {\n      \"name\": \"build-macos\",\n      \"configurePreset\": \"macos-x64\",\n      \"nativeToolOptions\": [ \"-v\" ],\n      \"condition\": {\"type\": \"equals\", \"lhs\": \"${hostSystemName}\", \"rhs\": \"Darwin\"}\n    },\n    {\n      \"name\": \"build-windows\",\n      \"configurePreset\": \"windows-x64\",\n      \"nativeToolOptions\": [ \"-v\" ],\n      \"condition\": {\"type\": \"equals\", \"lhs\": \"${hostSystemName}\", \"rhs\": \"Windows\"}\n    },\n    {\n      \"name\": \"build-linux-release\",\n      \"inherits\": \"build-linux\",\n      \"configuration\": \"Release\",\n      \"condition\": {\"type\": \"equals\", \"lhs\": \"${hostSystemName}\", \"rhs\": \"Linux\"}\n    },\n    {\n      \"name\": \"build-macos-release\",\n      \"inherits\": \"build-macos\",\n      \"configuration\": \"Release\",\n      \"condition\": {\"type\": \"equals\", \"lhs\": \"${hostSystemName}\", \"rhs\": \"Darwin\"}\n    },\n    {\n      \"name\": \"build-windows-release\",\n      \"inherits\": \"build-windows\",\n      \"configuration\": \"Release\",\n      \"condition\": {\"type\": \"equals\", \"lhs\": \"${hostSystemName}\", \"rhs\": \"Windows\"}\n    },\n    {\n      \"name\": \"install-linux\",\n      \"configurePreset\": \"linux-x64\",\n      \"inherits\": \"build-linux\",\n      \"targets\": [ \"install\" ],\n      \"condition\": {\"type\": \"equals\", \"lhs\": \"${hostSystemName}\", \"rhs\": \"Linux\"}\n    },\n    {\n      \"name\": \"install-macos\",\n      \"configurePreset\": \"macos-x64\",\n      \"inherits\": \"build-macos\",\n      \"targets\": [ \"install\" ],\n      \"condition\": {\"type\": \"equals\", \"lhs\": \"${hostSystemName}\", \"rhs\": \"Darwin\"}\n    },\n    {\n      \"name\": \"install-windows\",\n      \"configurePreset\": \"windows-x64\",\n      \"inherits\": \"build-windows\",\n      \"targets\": [ \"install\" ],\n      \"condition\": {\"type\": \"equals\", \"lhs\": \"${hostSystemName}\", \"rhs\": \"Windows\"}\n    },\n    {\n      \"name\": \"install-linux-release\",\n      \"inherits\": \"install-linux\",\n      \"configuration\": \"Release\",\n      \"condition\": {\"type\": \"equals\", \"lhs\": \"${hostSystemName}\", \"rhs\": \"Linux\"}\n    },\n    {\n      \"name\": \"install-macos-release\",\n      \"inherits\": \"install-macos\",\n      \"configuration\": \"Release\",\n      \"condition\": {\"type\": \"equals\", \"lhs\": \"${hostSystemName}\", \"rhs\": \"Darwin\"}\n    },\n    {\n      \"name\": \"install-windows-release\",\n      \"inherits\": \"install-windows\",\n      \"configuration\": \"Release\",\n      \"condition\": {\"type\": \"equals\", \"lhs\": \"${hostSystemName}\", \"rhs\": \"Windows\"}\n    }\n  ]\n}\n"
        },
        {
          "name": "COMPILE_MAKE.TXT",
          "type": "blob",
          "size": 5.990234375,
          "content": "\n# NOTICE\n\n> Please be aware that the Makefile build is deprecated.\n> Use cmake instead.\n\n<hr>\n\nThis documentation explains how to compile, install & run Capstone on MacOSX,\nLinux, *BSD & Solaris. We also show steps to cross-compile for Microsoft Windows.\n\nTo natively compile for Windows using Microsoft Visual Studio, see BUILDING.md.\n\nTo compile using CMake, see BUILDING.md.\n\nTo compile using XCode on MacOSX, see xcode/README.md.\n\nTo compile for Windows CE (a.k.a, Windows Embedded Compact), see windowsce/COMPILE.md.\n\n                        *-*-*-*-*-*\n\nCapstone requires no prerequisite packages, so it is easy to compile & install.\n\n\n\n(0) Tailor Capstone to your need.\n\n  Out of all architectures supported by Capstone, if you just need several\n  selected archs, choose the ones you want to compile in by editing \"config.mk\"\n  before going to next steps.\n\n  By default, all architectures are compiled.\n\n  The other way of customize Capstone without having to edit config.mk is to\n  pass the desired options on the commandline to ./make.sh. Currently,\n  Capstone supports 8 options, as followings.\n\n  - CAPSTONE_ARCHS: specify list of architectures to compiled in.\n  - CAPSTONE_USE_SYS_DYN_MEM: change this if you have your own dynamic memory management.\n  - CAPSTONE_DIET: use this to make the output binaries more compact.\n  - CAPSTONE_X86_REDUCE: another option to make X86 binary smaller.\n  - CAPSTONE_X86_ATT_DISABLE: disables AT&T syntax on x86.\n  - CAPSTONE_STATIC: build static library.\n  - CAPSTONE_SHARED: build dynamic (shared) library.\n  - CAPSTONE_DEBUG: enable debug build supporting assert().\n\n  By default, Capstone uses system dynamic memory management, both DIET and X86_REDUCE\n  modes are disable, and builds all the static & shared libraries.\n\n  To avoid editing config.mk for these customization, we can pass their values to\n  make.sh, as followings.\n\n  $ CAPSTONE_ARCHS=\"arm aarch64 x86\" CAPSTONE_USE_SYS_DYN_MEM=no CAPSTONE_DIET=yes CAPSTONE_X86_REDUCE=yes ./make.sh\n\n  NOTE: on commandline, put these values in front of ./make.sh, not after it.\n\n  For each option, refer to docs/README for more details.\n\n\n\n(1) Compile from source\n\n  On *nix (such as MacOSX, Linux, *BSD, Solaris):\n\n  - To compile for current platform, run:\n\n\t\t$ ./make.sh\n\n  - On 64-bit OS, run the command below to cross-compile Capstone for 32-bit binary:\n\n\t\t$ ./make.sh nix32\n\n\n\n(2) Install Capstone on *nix\n\n  To install Capstone, run:\n\n\t$ sudo ./make.sh install\n\n\tFor FreeBSD/OpenBSD, where sudo is unavailable, run:\n\n\t\t$ su; ./make.sh install\n\n  Users are then required to enter root password to copy Capstone into machine\n  system directories.\n\n  Afterwards, run ./tests/test* to see the tests disassembling sample code.\n\n\n  NOTE: The core framework installed by \"./make.sh install\" consist of\n  following files:\n\n\t/usr/include/capstone/arm.h\n\t/usr/include/capstone/arm64.h\n\t/usr/include/capstone/alpha.h\n\t/usr/include/capstone/bpf.h\n\t/usr/include/capstone/capstone.h\n\t/usr/include/capstone/evm.h\n\t/usr/include/capstone/hppa.h\n\t/usr/include/capstone/loongarch.h\n\t/usr/include/capstone/m680x.h\n\t/usr/include/capstone/m68k.h\n\t/usr/include/capstone/mips.h\n\t/usr/include/capstone/mos65xx.h\n\t/usr/include/capstone/platform.h\n\t/usr/include/capstone/ppc.h\n\t/usr/include/capstone/sparc.h\n\t/usr/include/capstone/systemz.h\n\t/usr/include/capstone/tms320c64x.h\n\t/usr/include/capstone/wasm.h\n\t/usr/include/capstone/x86.h\n\t/usr/include/capstone/xcore.h\n\t/usr/include/capstone/tricore.h\n\t/usr/lib/libcapstone.a\n\t/usr/lib/libcapstone.so (for Linux/*nix), or /usr/lib/libcapstone.dylib (OSX)\n\n\n\n(3) Cross-compile for Windows from *nix\n\n  To cross-compile for Windows, Linux & gcc-mingw-w64-i686 (and also gcc-mingw-w64-x86-64\n  for 64-bit binaries) are required.\n\n\t- To cross-compile Windows 32-bit binary, simply run:\n\n\t\t$ ./make.sh cross-win32\n\n\t- To cross-compile Windows 64-bit binary, run:\n\n\t\t$ ./make.sh cross-win64\n\n  Resulted files libcapstone.dll, libcapstone.dll.a & tests/test*.exe can then\n  be used on Windows machine.\n\n\n\n(4) Cross-compile for iOS from Mac OSX.\n\n  To cross-compile for iOS (iPhone/iPad/iPod), Mac OSX with XCode installed is required.\n\n\t- To cross-compile for ArmV7 (iPod 4, iPad 1/2/3, iPhone4, iPhone4S), run:\n\t\t$ ./make.sh ios_armv7\n\n\t- To cross-compile for ArmV7s (iPad 4, iPhone 5C, iPad mini), run:\n\t\t$ ./make.sh ios_armv7s\n\n\t- To cross-compile for Arm64 (iPhone 5S, iPad mini Retina, iPad Air), run:\n\t\t$ ./make.sh ios_arm64\n\n\t- To cross-compile for all iDevices (armv7 + armv7s + arm64), run:\n\t\t$ ./make.sh ios\n\n  Resulted files libcapstone.dylib, libcapstone.a & tests/test* can then\n  be used on iOS devices.\n\n\n\n(5) Cross-compile for Android\n\n  To cross-compile for Android (smartphone/tablet), Android NDK is required.\n  NOTE: Only ARM and AARCH64 are currently supported.\n\n\t$ NDK=/android/android-ndk-r10e ./make.sh cross-android arm\n  or\n\t$ NDK=/android/android-ndk-r10e ./make.sh cross-android arm64\n\n  Resulted files libcapstone.so, libcapstone.a & tests/test* can then\n  be used on Android devices.\n\n\n\n(6) Compile on Windows with Cygwin\n\n  To compile under Cygwin gcc-mingw-w64-i686 or x86_64-w64-mingw32 run:\n\n        - To compile Windows 32-bit binary under Cygwin, run:\n\n                $ ./make.sh cygwin-mingw32\n\n        - To compile Windows 64-bit binary under Cygwin, run:\n\n                $ ./make.sh cygwin-mingw64\n\n  Resulted files libcapstone.dll, libcapstone.dll.a & tests/test*.exe can then\n  be used on Windows machine.\n\n\n\n(7) By default, \"cc\" (default C compiler on the system) is used as compiler.\n\n\t- To use \"clang\" compiler instead, run the command below:\n\n\t\t$ ./make.sh clang\n\n\t- To use \"gcc\" compiler instead, run:\n\n\t\t$ ./make.sh gcc\n\n\n\n(8) To uninstall Capstone, run the command below:\n\n\t\t$ sudo ./make.sh uninstall\n\n\n\n(9) Language bindings\n\n  So far, Python, Ocaml & Java are supported by bindings in the main code.\n  Look for the bindings under directory bindings/, and refer to README file\n  of corresponding languages.\n\n  Community also provide bindings for C#, Go, Ruby, NodeJS, C++ & Vala. Links to\n  these can be found at address http://capstone-engine.org/download.html\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 4.27734375,
          "content": "Code structure\n--------------\n\nCapstone source is organized as followings.\n\n```\n.                   <- core engine + README.md + BUILDING.md etc\n├── arch            <- code handling disasm engine for each arch\n│   ├── AArch64     <- AArch64 engine\n│   ├── Alpha       <- Alpha engine\n│   ├── ARM         <- ARM engine\n│   ├── BPF         <- Berkeley Packet Filter engine\n│   ├── EVM         <- Ethereum engine\n│   ├── HPPA        <- HPPA engine\n│   ├── M680X       <- M680X engine\n│   ├── M68K        <- M68K engine\n│   ├── Mips        <- Mips engine\n│   ├── MOS65XX     <- MOS65XX engine\n│   ├── PowerPC     <- PowerPC engine\n│   ├── RISCV       <- RISCV engine\n│   ├── SH          <- SH engine\n│   ├── Sparc       <- Sparc engine\n│   ├── SystemZ     <- SystemZ engine\n│   ├── TMS320C64x  <- TMS320C64x engine\n│   ├── TriCore     <- TriCore engine\n│   └── WASM        <- WASM engine\n├── bindings        <- all bindings are under this dir\n│   ├── java        <- Java bindings\n│   ├── ocaml       <- Ocaml bindings\n│   └── python      <- Python bindings\n│       └── cstest  <- Testing tool for the Python bindings.\n├── suite           <- Several tools used for development\n│   ├── cstest      <- Testing tool to consume and check the test `yaml` files in `tests`\n│   ├── fuzz        <- Fuzzer\n│   └── auto-sync   <- The updater for Capstone modules\n├── contrib         <- Code contributed by community to help Capstone integration\n├── cstool          <- Cstool\n├── docs            <- Documentation\n├── include         <- API headers in C language (*.h)\n├── packages        <- Packages for Linux/OSX/BSD.\n├── windows         <- Windows support (for Windows kernel driver compile)\n├── tests           <- Unit and itegration tests\n└── xcode           <- Xcode support (for MacOSX compile)\n```\n\nBuilding\n--------\n\nFollow the instructions in [BUILDING.md](BUILDING.md) for how to compile and run test code.\n\nTesting\n-------\n\nGeneral testing docs are at [tests/README.md](tests/README.md).\n\nYou can test single instructions easily with the `cstool`.\nFor example:\n\n```bash\n$ cstool x32 \"90 91\"\n```\n\nUsing `cstool` is also the prefered way for debugging a single instruction.\n\n**Bindings**\n\nBindings currently have not equivalent to a `cstool`.\n\nThe Python bindings have `cstool` implemented.\n\nOther bindings are out-of-date for a while because of missing maintainers.\nThey only have legacy integration tests.\n\nPlease check the issues or open a new one if you intent to work on them or need them.\n\nCoding style\n------------\n- We provide a `.clang-format` for C code.\n- Python files should be formatted with `black`.\n\nSupport\n-------\n\n**Please always open an issue or leave a comment in one, before starting work on an architecture! We can give support and save you a lot of time.**\n\nUpdating an Architecture\n------------------------\n\nThe update tool for Capstone is called `Auto-Sync` and can be found in `suite/auto-sync`.\n\nNot all architectures are supported yet.\nRun `suite/auto-sync/Updater/ASUpdater.py -h` to get a list of currently supported architectures.\n\nThe documentation how to update with `Auto-Sync` or refactor an architecture module\ncan be found in [suite/auto-sync/README.md](suite/auto-sync/README.md).\n\nIf a module does not support `Auto-Sync` yet, it is highly recommended to refactor it\ninstead of attempting to update it manually.\nRefactoring will take less time and updates it during the procedure.\n\nThe one exception is `x86`. In LLVM we use several emitter backends to generate C code.\nOne of those LLVM backends (the `DecoderEmitter`) has two versions.\nOne for `x86` and another for all the other architectures.\nUntil now it was not worth it to refactoring this unique `x86` backend. So `x86` is not\nsupported currently.\n\nAdding an Architecture\n----------------------\n\nIf your architecture is supported in LLVM or one of its forks, you can use `Auto-Sync` to\nadd the new module.\nCheckout [suite/auto-sync/README.md](suite/auto-sync/README.md).\n\nOtherwise, you need to implement the disassembler on your own and make it work with the Capstone API.\n"
        },
        {
          "name": "CREDITS.TXT",
          "type": "blob",
          "size": 3.1826171875,
          "content": "This file credits all the contributors of the Capstone engine project.\n\nKey developers\n==============\nNguyen Anh Quynh <aquynh -at- gmail.com>\nChenxu Wu (kabeor) kabeor@qiling.io\n\n\nPast key developers\n===================\nTan Sheng Di <shengdi -at- coseinc.com>\n\t- Bindings: Ruby\n\nBen Nagy <ben -at- coseinc.com>\n\t- Bindings: Ruby, Go\n\nDang Hoang Vu <dang.hvu -at- gmail.com>\n\t- Bindings: Java\n\n\nBeta testers (in random order)\n==============================\nPancake\nVan Hauser\nFX of Phenoelit\nThe Grugq, The Grugq   <-- our hero for submitting the first ever patch!\nIsaac Dawson, Veracode Inc\nPatroklos Argyroudis, Census Inc. (http://census-labs.com)\nAttila Suszter\nLe Dinh Long\nNicolas Ruff\nGunther\nAlex Ionescu, Winsider Seminars & Solutions Inc.\nSnare\nDaniel Godas-Lopez\nJoshua J. Drake\nEdgar Barbosa\nRalf-Philipp Weinmann\nHugo Fortier\nJoxean Koret\nBruce Dang\nAndrew Dunham\n\n\nContributors (in no particular order)\n=====================================\n(Please let us know if you want to have your name here)\n\nOle André Vadla Ravnås (author of the 100th Pull-Request in our Github repo, thanks!)\nAxel \"0vercl0k\" Souchet (@0vercl0k) & Alex Ionescu: port to MSVC.\nDaniel Pistelli: Cmake support.\nPeter Hlavaty: integrate Capstone for Windows kernel drivers.\nGuillaume Jeanne: Ocaml binding.\nMartin Tofall, Obsidium Software: Optimize X86 performance & size + x86 encoding features.\nDavid Martínez Moreno & Hilko Bengen: Debian package.\nFélix Cloutier: Xcode project.\nBenoit Lecocq: OpenBSD package.\nChristophe Avoinne (Hlide): Improve memory management for better performance.\nMichael Cohen & Nguyen Tan Cong: Python module installer.\nAdel Gadllah, Francisco Alonso & Stefan Cornelius: RPM package.\nFelix Gröbert (Google): fuzz testing harness.\nXipiter LLC: Capstone logo redesigned.\nSatoshi Tanda: Support Windows kernel driver.\nTang Yuhang: cstool.\nAndrew Dutcher: better Python setup.\nRuben Boonen: PowerShell binding.\nDavid Zimmer: VB6 binding.\nPhilippe Antoine: Integration with oss-fuzz and various fixes.\nBui Dinh Cuong: Explicit registers accessed for Arm64.\nVincent Bénony: Explicit registers accessed for X86.\nAdel Gadllah, Francisco Alonso & Stefan Cornelius: RPM package.\nFelix Gröbert (Google): fuzz testing harness.\nDaniel Collin & Nicolas Planel: M68K architecture.\nPranith Kumar: Explicit registers accessed for Arm64.\nXipiter LLC: Capstone logo redesigned.\nSatoshi Tanda: Support Windows kernel driver.\nKoutheir Attouchi: Support for Windows CE.\nFotis Loukos: TMS320C64x architecture.\nWolfgang Schwotzer: M680X architecture.\nPhilippe Antoine: Integration with oss-fuzz and various fixes.\nStephen Eckels (stevemk14ebr): x86 encoding features\nTong Yu(Spike) & Kai Jern, Lau (xwings): WASM architecture.\nSebastian Macke: MOS65XX architecture\nIlya Leoshkevich: SystemZ architecture improvements.\nDo Minh Tuan: Regression testing tool (cstest)\ndavid942j: BPF (both classic and extended) architecture.\nfanfuqiang & citypw & porto703 : RISCV architecture.\nJosh \"blacktop\" Maine: Arm64 architecture improvements.\nFinn Wilkinson: AArch64 update to Armv9.2-a (SME + SVE2 support)\nBillow & Sidneyp: TriCore architecture.\nDmitry Sibirtsev: Alpha & HPPA architecture.\nJiajie Chen & Yanglin Xun: LoongArch architecture.\nBillow: Xtensa architecture.\n"
        },
        {
          "name": "ChangeLog",
          "type": "blob",
          "size": 53.7177734375,
          "content": "This file details the changelog of Capstone.\n\n-----------------------------\nVersion 6.0.0-Alpha2: November 24th, 2024\n\n## What's Changed\n* Update changelog for V6.0.0-Alpha1 by @kabeor in https://github.com/capstone-engine/capstone/pull/2493\n* Remove irrelevant changes. by @Rot127 in https://github.com/capstone-engine/capstone/pull/2495\n* Fixing UB santizer, `LITBASE` and assert errors. by @Rot127 in https://github.com/capstone-engine/capstone/pull/2499\n* Update labeler with Xtensa and v6 files. by @Rot127 in https://github.com/capstone-engine/capstone/pull/2500\n* Add hard asserts to all SStream functions and memset MCInst. by @Rot127 in https://github.com/capstone-engine/capstone/pull/2501\n* Only trigger on released action. by @Rot127 in https://github.com/capstone-engine/capstone/pull/2497\n* Fix cstest build with Ninja by @thestr4ng3r in https://github.com/capstone-engine/capstone/pull/2506\n* Tricore EA calculation by @Rot127 in https://github.com/capstone-engine/capstone/pull/2504\n* Update libcyaml dependency in cstest to 1.4.2 by @thestr4ng3r in https://github.com/capstone-engine/capstone/pull/2508\n* xtensa: Fix Branch Target by @imbillow in https://github.com/capstone-engine/capstone/pull/2516\n* Fix #2509. by @Rot127 in https://github.com/capstone-engine/capstone/pull/2510\n* AArch64: Replace vararg add_cs_detail by multiple concrete functions by @thestr4ng3r in https://github.com/capstone-engine/capstone/pull/2507\n* Fix stringop-truncation warning some compilers raise. by @Rot127 in https://github.com/capstone-engine/capstone/pull/2522\n* Adds ARM and AArch64 compatibility macros for the CC/VAS enums by @Rot127 in https://github.com/capstone-engine/capstone/pull/2525\n* Fix endianess issue during assignment. by @Rot127 in https://github.com/capstone-engine/capstone/pull/2528\n* This time actually fix big endian issue. by @Rot127 in https://github.com/capstone-engine/capstone/pull/2530\n* tricore: fixes #2474 by @imbillow in https://github.com/capstone-engine/capstone/pull/2523\n* Change CI to create Debian Package to Release by @AndrewQuijano in https://github.com/capstone-engine/capstone/pull/2521\n* Rename cmake build arguments by @Rot127 in https://github.com/capstone-engine/capstone/pull/2534\n* xtensa: update to espressif/llvm-project by @imbillow in https://github.com/capstone-engine/capstone/pull/2533\n* fix coverity by @imbillow in https://github.com/capstone-engine/capstone/pull/2546\n* Move debian package generation to a dispatch only workflow by @Rot127 in https://github.com/capstone-engine/capstone/pull/2543\n* Python package building rework by @Antelox in https://github.com/capstone-engine/capstone/pull/2538\n* Auto-Sync reproducability + ARM update by @Rot127 in https://github.com/capstone-engine/capstone/pull/2532\n* fix xtensa DecodeMR23RegisterClass and add tests for MAC16 instru… by @imbillow in https://github.com/capstone-engine/capstone/pull/2551\n* Prepare for update by @kabeor in https://github.com/capstone-engine/capstone/pull/2552\n\n## New Contributors\n* @AndrewQuijano made their first contribution in https://github.com/capstone-engine/capstone/pull/2521\n* @Antelox made their first contribution in https://github.com/capstone-engine/capstone/pull/2538\n\n**Full Changelog**: https://github.com/capstone-engine/capstone/compare/6.0.0-Alpha1...6.0.0-Alpha2\n\n\n-----------------------------\nVersion 6.0.0-Alpha1: September 30th, 2024\n\n## **Breaking Changes**\n\n- `ARM64` was renamed to `AArch64` everywhere (compatibility header is provided).\n- `SysZ` was renamed to `SystemZ` everywhere (compatibility header is provided).\n- Changes happened **especially to the PPC, ARM and AArch64 API**, as well as changes to enumeration values and stucts.\n\n**Please be sure to read the [release guide](https://github.com/capstone-engine/capstone/blob/next/docs/cs_v6_release_guide.md) carefully!**\nYou can find all the breaking changes and justifications for them!\n\n## What's New\n* LoongArch, HPPA and Alpha support added.\n* AArch64, SystemZ and Mips updated to LLVM 18.\n* NanoMips extension added.\n* ARM and PPC updated to LLVM 16.\n* Exotic PPC PairedSingle extension added.\n* Instruction formats for PPC, SystemZ and LoongArch added.\n* Instruction alias support added.\n* RISCV operand access information added.\n* Testing was rewritten from scratch.\n* All tests are run with the address sanitizer.\n* Several improvements to the API of the ARM, AArch64 and PPC modules.\n\nFor an exhaustive list, see the release guide at https://github.com/capstone-engine/capstone/blob/next/docs/cs_v6_release_guide.md\n\n## What's Changed\n* tricore: fix runtime errors of integer overflow by @imbillow in https://github.com/capstone-engine/capstone/pull/2204\n* [ARM] Add alias support by @Rot127 in https://github.com/capstone-engine/capstone/pull/2209\n* [TriCore] Replace one- and sign-extend with MathExtra.h functions. by @Rot127 in https://github.com/capstone-engine/capstone/pull/2212\n* [ARM] Add RET group to pop instructions which write to the PC. by @Rot127 in https://github.com/capstone-engine/capstone/pull/2216\n* V6 release guide by @Rot127 in https://github.com/capstone-engine/capstone/pull/2124\n* Fix broken disassembly of floating point immediates on big endian hosts by @huth in https://github.com/capstone-engine/capstone/pull/2222\n* Add Alpha architecture by @R33v0LT in https://github.com/capstone-engine/capstone/pull/2071\n* Ignore JetBrains based IDE data for clean PRs by @rickmark in https://github.com/capstone-engine/capstone/pull/2224\n* Add Big-endian mode for Alpha by @R33v0LT in https://github.com/capstone-engine/capstone/pull/2227\n* Fix typos in COMPILE_CMAKE.TXT by @kobykahane in https://github.com/capstone-engine/capstone/pull/2229\n* LIBDIRARCH does not propagate to Makefile by @YaSuenag in https://github.com/capstone-engine/capstone/pull/2214\n* Fix type punning in `AArch64_AM_isSVEMaskOfIdenticalElements` by @kazarmy in https://github.com/capstone-engine/capstone/pull/2237\n* Raise minimum requirement to VS2017 by @XVilka in https://github.com/capstone-engine/capstone/pull/2228\n* Update docs wit ASUpdater.py script by @Rot127 in https://github.com/capstone-engine/capstone/pull/2217\n* Add autolabeler GitHub Action by @XVilka in https://github.com/capstone-engine/capstone/pull/2239\n* By default compile as universal2 for macOS by @rickmark in https://github.com/capstone-engine/capstone/pull/2221\n* Use `union` in `AArch64_AM_isSVEMaskOfIdenticalElements` type punning fix by @kazarmy in https://github.com/capstone-engine/capstone/pull/2238\n* Fix #2234. by @Rot127 in https://github.com/capstone-engine/capstone/pull/2236\n* Remove comment stating support for multiple `clang-format` versions by @kazarmy in https://github.com/capstone-engine/capstone/pull/2242\n* Fix label assignment for LLVM generated files. by @Rot127 in https://github.com/capstone-engine/capstone/pull/2243\n* Constify Alpha and TriCore by @rth7680 in https://github.com/capstone-engine/capstone/pull/2245\n* Fix compilation with DIET + X86_REDUCE by @oleavr in https://github.com/capstone-engine/capstone/pull/2248\n* Fix warnings when building with CAPSTONE_DIET by @oleavr in https://github.com/capstone-engine/capstone/pull/2249\n* Fix MSVC warning overrides when using non-MSVC toolchains by @oleavr in https://github.com/capstone-engine/capstone/pull/2250\n* Add support for architecture registration by @oleavr in https://github.com/capstone-engine/capstone/pull/2252\n* auto-sync: Fix some tree-sitter queries by @kazarmy in https://github.com/capstone-engine/capstone/pull/2255\n* cstool: Fix ppc_br_hint comparison by @oleavr in https://github.com/capstone-engine/capstone/pull/2254\n* Fix crash on x86 when building with MSVC by @oleavr in https://github.com/capstone-engine/capstone/pull/2253\n* Fix regressions in custom memory allocator support by @oleavr in https://github.com/capstone-engine/capstone/pull/2251\n* Fix compilation with CAPSTONE_X86_REDUCE by @oleavr in https://github.com/capstone-engine/capstone/pull/2256\n* auto-sync BitCastStdArray.py: Transform to `union` instead by @kazarmy in https://github.com/capstone-engine/capstone/pull/2257\n* Make helper functions static to prevent multiple defintions. by @Rot127 in https://github.com/capstone-engine/capstone/pull/2266\n* Drop distutils in python binding by @Xeonacid in https://github.com/capstone-engine/capstone/pull/2271\n* Fix #2233 by @Rot127 in https://github.com/capstone-engine/capstone/pull/2267\n* Fix OOB read and wries by @Rot127 in https://github.com/capstone-engine/capstone/pull/2273\n* [AArch64] Fix incorrect alignment of labels. by @Rot127 in https://github.com/capstone-engine/capstone/pull/2277\n* Makefile: Improve Apple detection by @sevan in https://github.com/capstone-engine/capstone/pull/2263\n* [CMake] Architecture definition fix by @Rot127 in https://github.com/capstone-engine/capstone/pull/2272\n* Add issue and PR templates by @Rot127 in https://github.com/capstone-engine/capstone/pull/2294\n* Avoid random access values for operands in not-yet-specified instructions. by @mur47x111 in https://github.com/capstone-engine/capstone/pull/2259\n* Remove repetitive words by @majorteach in https://github.com/capstone-engine/capstone/pull/2297\n* Add HPPA(PA-RISC) architecture by @R33v0LT in https://github.com/capstone-engine/capstone/pull/2265\n* Fix invalid comparison with HPPA_OP_INVALID by @R33v0LT in https://github.com/capstone-engine/capstone/pull/2300\n* HPPA dissassembler fix unitialized variables errors by @R33v0LT in https://github.com/capstone-engine/capstone/pull/2309\n* [Auto-Sync] LLVM 18 update by @Rot127 in https://github.com/capstone-engine/capstone/pull/2296\n* chore: remove repetitive words by @careworry in https://github.com/capstone-engine/capstone/pull/2326\n* Fix cstool Makefile for non-C99-defaulting compilers by @thestr4ng3r in https://github.com/capstone-engine/capstone/pull/2315\n* check if decode[idx] is callable by @Ced2911 in https://github.com/capstone-engine/capstone/pull/2322\n* Add eBPF bswap16/32/64 instruction by @chengshuyi in https://github.com/capstone-engine/capstone/pull/2323\n* Add a clang-tidy checks and warnings by @Rot127 in https://github.com/capstone-engine/capstone/pull/2312\n* [next] Fix #2128 by adding missing mapping values. by @Rot127 in https://github.com/capstone-engine/capstone/pull/2335\n* Replace manually compile tree-sitter-cpp with their Python bindings. by @Rot127 in https://github.com/capstone-engine/capstone/pull/2337\n* [next] Fix #2079: Add missing 1 immediate to `rcl` by @Rot127 in https://github.com/capstone-engine/capstone/pull/2330\n* fix typos by @RainRat in https://github.com/capstone-engine/capstone/pull/2344\n* Fix pkgconfig file to make #include <capstone/capstone.h> work by @ret2libc in https://github.com/capstone-engine/capstone/pull/2307\n* Rewrite str_replace using snprintf for security and fix clang-tidy by @jiegec in https://github.com/capstone-engine/capstone/pull/2350\n* [next] Fix #2244: Don't apply pseudo-instr. offset to `vcmp` id by @Rot127 in https://github.com/capstone-engine/capstone/pull/2331\n* chore: fix typos by @xiaoxianBoy in https://github.com/capstone-engine/capstone/pull/2328\n* fix typos by @RainRat in https://github.com/capstone-engine/capstone/pull/2346\n* Replace non-standard 0b(...) literals by @thestr4ng3r in https://github.com/capstone-engine/capstone/pull/2314\n* README: Mention Alpha and HPPA by @XVilka in https://github.com/capstone-engine/capstone/pull/2357\n* Typo and tree-sitter init fix by @Rot127 in https://github.com/capstone-engine/capstone/pull/2358\n* Apply #2360 to next by @Rot127 in https://github.com/capstone-engine/capstone/pull/2361\n* Mapping - return NULL if compiled with DIET by @XVilka in https://github.com/capstone-engine/capstone/pull/2370\n* Fix Warning C4098: void returns value. by @Rot127 in https://github.com/capstone-engine/capstone/pull/2362\n* AArch64 compatibility header by @Rot127 in https://github.com/capstone-engine/capstone/pull/2321\n* Remove python2 leftovers by @twizmwazin in https://github.com/capstone-engine/capstone/pull/2378\n* Restructure auto-sync docs to have them more contained by @Rot127 in https://github.com/capstone-engine/capstone/pull/2355\n* Add test with ASAN enabled. by @Rot127 in https://github.com/capstone-engine/capstone/pull/2313\n* chore: fix some comments by @dufucun in https://github.com/capstone-engine/capstone/pull/2379\n* Use python3 as default interpreter for python scripts by @Rot127 in https://github.com/capstone-engine/capstone/pull/2390\n* fix typos by @RainRat in https://github.com/capstone-engine/capstone/pull/2387\n* Revert \"Remove python2 leftovers\" by @kabeor in https://github.com/capstone-engine/capstone/pull/2391\n* Initial auto-sync LoongArch support by @jiegec in https://github.com/capstone-engine/capstone/pull/2349\n* Python2 leftovers v2 by @twizmwazin in https://github.com/capstone-engine/capstone/pull/2395\n* AArch64 update to LLVM 18 by @Rot127 in https://github.com/capstone-engine/capstone/pull/2298\n* Add access support for RISC-V by @wxrdnx in https://github.com/capstone-engine/capstone/pull/2393\n* Constify three ARM and AArch64 variables by @rth7680 in https://github.com/capstone-engine/capstone/pull/2399\n* Python/remove deprecated packaging by @twizmwazin in https://github.com/capstone-engine/capstone/pull/2396\n* [PPC] Fix #2401 - incorrect operands in disassembled instructions by @valdaarhun in https://github.com/capstone-engine/capstone/pull/2403\n* [next] Fix typo in AArch64 Python binding by @david942j in https://github.com/capstone-engine/capstone/pull/2413\n* Add release wheel build workflow for all Python versions by @Rot127 in https://github.com/capstone-engine/capstone/pull/2414\n* [next] Fix unintended zero set in Sparc printInst by @david942j in https://github.com/capstone-engine/capstone/pull/2421\n* Fix CI fuzz job yml syntax by @Rot127 in https://github.com/capstone-engine/capstone/pull/2429\n* chore: fix some comments by @luozexuan in https://github.com/capstone-engine/capstone/pull/2432\n* Add Coverity workflow by @Rot127 in https://github.com/capstone-engine/capstone/pull/2437\n* [next] Updates and fixes to the Python wheel builder workflow by @Rot127 in https://github.com/capstone-engine/capstone/pull/2441\n* Add back support for relocatable packages by @mrexodia in https://github.com/capstone-engine/capstone/pull/2431\n* Fix 'make check' for python tests by @hamarituc in https://github.com/capstone-engine/capstone/pull/2439\n* Update and add labels by @Rot127 in https://github.com/capstone-engine/capstone/pull/2446\n* [next] Wheel build fixes: manylinux1, trigger upload on release, Linux AArch64... by @Rot127 in https://github.com/capstone-engine/capstone/pull/2444\n* Use any-glob for labeler. Otherwise it is not checked recursively. by @Rot127 in https://github.com/capstone-engine/capstone/pull/2450\n* Modern Testing by @Rot127 in https://github.com/capstone-engine/capstone/pull/2456\n* Some small fixes for capstone-next by @wargio in https://github.com/capstone-engine/capstone/pull/2460\n* Auto-Sync Mips by @wargio in https://github.com/capstone-engine/capstone/pull/2410\n* SystemZ Auto-Sync refactor by @Rot127 in https://github.com/capstone-engine/capstone/pull/2462\n* Coverity defects by @Rot127 in https://github.com/capstone-engine/capstone/pull/2469\n* [next] SH: Use bitwise OR with mask for sign extension by @lhsazevedo in https://github.com/capstone-engine/capstone/pull/2389\n* [next][SuperH] Fix missing setting detail->sh by @david942j in https://github.com/capstone-engine/capstone/pull/2466\n* Fix jumps and branches on a non-zero PC by @wargio in https://github.com/capstone-engine/capstone/pull/2479\n* Documentation updates by @Rot127 in https://github.com/capstone-engine/capstone/pull/2476\n* ARM fixes by @Rot127 in https://github.com/capstone-engine/capstone/pull/2477\n* AArch64 issues by @Rot127 in https://github.com/capstone-engine/capstone/pull/2473\n* Replace `assert` with `CS_ASSERT` in modules by @Rot127 in https://github.com/capstone-engine/capstone/pull/2478\n* Rename CS_OPT_NO_BRANCH_OFFSET and corresponding flag to better name. by @Rot127 in https://github.com/capstone-engine/capstone/pull/2482\n* Fix Coverity CID 509730: overflow before widen by @wargio in https://github.com/capstone-engine/capstone/pull/2486\n* Update sponsors and remove empty file. by @Rot127 in https://github.com/capstone-engine/capstone/pull/2485\n* Several small fixups by @Rot127 in https://github.com/capstone-engine/capstone/pull/2489\n* Xtensa Support by @imbillow in https://github.com/capstone-engine/capstone/pull/2380\n* LDR offset by @Rot127 in https://github.com/capstone-engine/capstone/pull/2487\n* SystemZ fixes by @Rot127 in https://github.com/capstone-engine/capstone/pull/2488\n* Be ready for V6-Alpha1 by @kabeor in https://github.com/capstone-engine/capstone/pull/2492\n\n## New Contributors\n* @R33v0LT made their first contribution in https://github.com/capstone-engine/capstone/pull/2071\n* @rickmark made their first contribution in https://github.com/capstone-engine/capstone/pull/2224\n* @kobykahane made their first contribution in https://github.com/capstone-engine/capstone/pull/2229\n* @YaSuenag made their first contribution in https://github.com/capstone-engine/capstone/pull/2214\n* @Xeonacid made their first contribution in https://github.com/capstone-engine/capstone/pull/2271\n* @sevan made their first contribution in https://github.com/capstone-engine/capstone/pull/2263\n* @majorteach made their first contribution in https://github.com/capstone-engine/capstone/pull/2297\n* @careworry made their first contribution in https://github.com/capstone-engine/capstone/pull/2326\n* @thestr4ng3r made their first contribution in https://github.com/capstone-engine/capstone/pull/2315\n* @Ced2911 made their first contribution in https://github.com/capstone-engine/capstone/pull/2322\n* @chengshuyi made their first contribution in https://github.com/capstone-engine/capstone/pull/2323\n* @RainRat made their first contribution in https://github.com/capstone-engine/capstone/pull/2344\n* @jiegec made their first contribution in https://github.com/capstone-engine/capstone/pull/2350\n* @xiaoxianBoy made their first contribution in https://github.com/capstone-engine/capstone/pull/2328\n* @dufucun made their first contribution in https://github.com/capstone-engine/capstone/pull/2379\n* @wxrdnx made their first contribution in https://github.com/capstone-engine/capstone/pull/2393\n* @valdaarhun made their first contribution in https://github.com/capstone-engine/capstone/pull/2403\n* @luozexuan made their first contribution in https://github.com/capstone-engine/capstone/pull/2432\n* @wargio made their first contribution in https://github.com/capstone-engine/capstone/pull/2460\n\n**Full Changelog**: https://github.com/capstone-engine/capstone/compare/5.0.3...6.0.0-Alpha1\n\n\n--------------------------------\nVersion 5.0.2: August 20th, 2024\n\n## What's Changed\n* [v5] Updates and fixes to the Python wheel builder workflow by @Rot127 in https://github.com/capstone-engine/capstone/pull/2440\n* Relocatable package v5 by @mrexodia in https://github.com/capstone-engine/capstone/pull/2447\n* [v5] Wheel build fixes: manylinux1, trigger upload on release, Linux AArch64 by @Rot127 in https://github.com/capstone-engine/capstone/pull/2443\n\n--------------------------------\nVersion 5.0.2: August 12th, 2024\n\n## What's Changed\n* [v5] Add meta-programming macros for ARM64/AArch64 name change to capstone.h by @Rot127 in https://github.com/capstone-engine/capstone/pull/2199\n* [v5] Add CS_aarch64 macro without parameter. by @Rot127 in https://github.com/capstone-engine/capstone/pull/2219\n* [v5] python: Fix definition of capstone syntax value option constants by @nmeum in https://github.com/capstone-engine/capstone/pull/2240\n* Constify TriCore by @rth7680 in https://github.com/capstone-engine/capstone/pull/2246\n* Revert constant value of CS_OP_MEM to `v5.0.1` by @Rot127 in https://github.com/capstone-engine/capstone/pull/2275\n* Do not use 0b prefix, not supported on old compilers by @trufae in https://github.com/capstone-engine/capstone/pull/2306\n* Update CMakeLists.txt version (See #2310) by @PerikiyoXD in https://github.com/capstone-engine/capstone/pull/2311\n* [v5] Fix #2128 by adding missing mapping values. by @Rot127 in https://github.com/capstone-engine/capstone/pull/2334\n* [v5] Fix #2079: Add missing 1 immediate to `rcl` by @Rot127 in https://github.com/capstone-engine/capstone/pull/2329\n* [v5] Fix incorrect ID mappings for PPC by @Rot127 in https://github.com/capstone-engine/capstone/pull/2333\n* [v5] Fix #2244: Don't apply pseudo-instr. offset to `vcmp` id by @Rot127 in https://github.com/capstone-engine/capstone/pull/2332\n* Fix comparison using narrow types in loop condition by @trufae in https://github.com/capstone-engine/capstone/pull/2360\n* SH: Use bitwise OR with mask for sign extension by @lhsazevedo in https://github.com/capstone-engine/capstone/pull/2371\n* Remove deprecated packaging and cython by @twizmwazin in https://github.com/capstone-engine/capstone/pull/2400\n* [v5] Fix typo in AArch64 Python binding by @david942j in https://github.com/capstone-engine/capstone/pull/2412\n* Backport python-publish.yml from next by @twizmwazin in https://github.com/capstone-engine/capstone/pull/2408\n* [v5] Add release wheel build workflow for all Python versions by @Rot127 in https://github.com/capstone-engine/capstone/pull/2415\n* [v5] Fix unintended zero set in Sparc printInst by @david942j in https://github.com/capstone-engine/capstone/pull/2420\n* [v5][arm] Consider SpecRegRBit on setting SYSREG by @david942j in https://github.com/capstone-engine/capstone/pull/2422\n* Prepare for release v5.0.2 by @kabeor in https://github.com/capstone-engine/capstone/pull/2425\n\n## New Contributors\n* @nmeum made their first contribution in https://github.com/capstone-engine/capstone/pull/2240\n* @PerikiyoXD made their first contribution in https://github.com/capstone-engine/capstone/pull/2311\n* @lhsazevedo made their first contribution in https://github.com/capstone-engine/capstone/pull/2371\n\n\n--------------------------------\nVersion 5.0.1: August 23rd, 2023\n\n## What's Changed\n\n* [ARM] Fix VFP feature check by @Rot127 in https://github.com/capstone-engine/capstone/pull/2090\n* Restore the ARM register naming from v4. by @gerph in https://github.com/capstone-engine/capstone/pull/2108\n* Use OS independent printf formatting. by @Rot127 in https://github.com/capstone-engine/capstone/pull/2109\n* Cherry-pick from next for v5.0.1 by @kabeor in https://github.com/capstone-engine/capstone/pull/2141\n  * Add Python bindings for WASM by @peace-maker https://github.com/capstone-engine/capstone/pull/2095\n  * Sync Python bindings for x86, m68k, and mos65xx by @peace-maker https://github.com/capstone-engine/capstone/pull/2100\n  * Add Python bindings for SH by @peace-maker https://github.com/capstone-engine/capstone/pull/2096\n  * Update Python binding constants by @peace-maker https://github.com/capstone-engine/capstone/pull/2097\n  * Fixing TriCore disasm instructions by @bkoppelmann https://github.com/capstone-engine/capstone/pull/2088\n  * allow absolute CMAKE_INSTALL_*DIR @chayleaf https://github.com/capstone-engine/capstone/pull/2134\n\n## New Contributors\n* @gerph made their first contribution in https://github.com/capstone-engine/capstone/pull/2108\n* @bkoppelmann made their first contribution in https://github.com/capstone-engine/capstone/pull/2088\n* @chayleaf made their first contribution in https://github.com/capstone-engine/capstone/pull/2134\n\n\n-----------------------------\nVersion 5.0.0: July 5th, 2023\n\n## What's Changed\n* [workflows] Remove deprecated image versions by @kabeor in https://github.com/capstone-engine/capstone/pull/2057\n* Fix capstone_test.c #2059 by @imbillow in https://github.com/capstone-engine/capstone/pull/2060\n* Support repz prefix on X86 ret instructions by @adamjseitz in https://github.com/capstone-engine/capstone/pull/2063\n* fix for msvc static lib, dll build error and warnings by @arkup in https://github.com/capstone-engine/capstone/pull/2061\n* use calloc for cs_insn instead of malloc by @ConnorRigby in https://github.com/capstone-engine/capstone/pull/1972\n* Fix access bug for TEST op by @melynx in https://github.com/capstone-engine/capstone/pull/1511\n* Update Cython bindings by @peace-maker in https://github.com/capstone-engine/capstone/pull/2068\n* Use Intel register syntax for Tricore by @XVilka in https://github.com/capstone-engine/capstone/pull/2067\n* Add `#` prefix to tricore imm operand by @imbillow in https://github.com/capstone-engine/capstone/pull/2070\n* Revert \"Mark cs_* as thread local to avoid race condition in multithreads\" by @oleavr in https://github.com/capstone-engine/capstone/pull/1933\n* Replace strncpy with memcpy to fix compiler warning. by @Rot127 in https://github.com/capstone-engine/capstone/pull/2075\n* Remove outdated and irrelevant TODO by @XVilka in https://github.com/capstone-engine/capstone/pull/2074\n\n## New Contributors\n* @arkup made their first contribution in https://github.com/capstone-engine/capstone/pull/2061\n* @ConnorRigby made their first contribution in https://github.com/capstone-engine/capstone/pull/1972\n* @melynx made their first contribution in https://github.com/capstone-engine/capstone/pull/1511\n\n\n---------------------------------\nVersion 5.0.0-rc4: June 18th, 2023\n\n## What's Changed\n* Fix TriCore test by @hamarituc in https://github.com/capstone-engine/capstone/pull/2049\n* [workflows] Fix python-publish issue by @kabeor in https://github.com/capstone-engine/capstone/pull/2050\n* Update version tag by @kabeor in https://github.com/capstone-engine/capstone/pull/2052\n* Release 5.0-rc4 by @kabeor in https://github.com/capstone-engine/capstone/pull/2051\n\n---------------------------------\nVersion 5.0.0-rc3: June 17th, 2023\n\nWhat's Changed:\n- update pkgconfig version by @kabeor in #1847\n- vb6 bindings: clarify license as Apache v2.0 by @dzzie in #1850\n- AArch64 SYS instruction operands by @adamjseitz in #1859\n- AArch64: fix missing VAS specifiers in aliased instructions by @adamjseitz in #1860\n- Add cstool in CMake Package Config + CMake Github Workflow by @theblackunknown in #1867\n- Fix pkgconfig not installed when CAPSTONE_BUILD_CSTOOL is false by @theblackunknown in #1870\n- AArch64 comprehensively add vas specifiers to aliased instructions by @adamjseitz in #1877\n- Fix pkg-config template by @hamarituc in #1878\n- Fix eBPF lddw opcode by @terorie in #1885\n- Add eBPF callx instruction by @terorie in #1886\n- Mark cs_* as thread local to avoid race condition in multithreads by @wtdcode in #1891\n- One semicolon is enough in C by @trufae in #1892\n- Add PowerPC paired-singles support by @terorie in #1898\n- Update the table for UD0 and UD1 with the latest llvm table by @junghee in #1863\n- Sync eBPF and PowerPC bindings by @terorie in #1900\n- Fix PPC insn names and psq displacement by @terorie in #1902\n- Fix -Werror build by @trufae in #1906\n- Remove outdated ctypes requirement by @jbott in #1910\n- Fix memory leak in testsuite by @hamarituc in #1919\n- PPC: fix out of bound memory access by @hamarituc in #1913\n- AArch64 armv9.2 update by @FinnWilkinson in #1907\n- m68k: Add support for the FNOP instruction by @huth in #1921\n- arm64: fix invalid free introduced in 662bb3f by @trufae in #1926\n- Fixed SME index alias printing issue. by @FinnWilkinson in #1925\n- Updated Arm64 python bindings after Armv9.2-a support. by @FinnWilkinson in #1932\n- ARM/AArch64: Add post-index to instruction info by @ZehMatt in #1937\n- Fix regressions in custom memory allocator support by @oleavr in #1934\n- cstool: support riscv compressed instruction disassemble by @rrwhx in #1940\n- Mention debug build option for cmake. by @Rot127 in #1942\n- cstool: avoid misaligned instructions in compressed riscv by @carenas in #1943\n- arm64: fix missing post_index by @HyperSine in #1944\n- Add CMAKE_EXPORT_COMPILE_COMMANDS to cmake build doc by @Rot127 in #1948\n- Fix potential array out of bounds by @mjunix in #1938\n- Add Renesas SuperH instructions support by @ysat0 in #1927\n- fix missing access field in arm64 java binding by @sunxingxing in #1959\n- Update python bindings to fix ARM in detail mode. by @wideglide in #1961\n- sh: add missing include for CMake install step by @SweetVishnya in #1964\n- Fix CITest && python binding issues by @kabeor in #1965\n- correct register accesses for ARM's sxtb/uxtb and similar instructions by @covanam in #1968\n- In x86: Fixed backward compatibility with C90 by @hasherezade in #1969\n- Fix for missing register usages on ARM64 authenticated branches (issue #1975) by - @stevielavern in #1976\n- AArch64: fixes register access flags for moves by @thomasdangl in #1974\n- [SH] Fix build warnings by @Rot127 in #1960\n- update CI ubuntu version by @kabeor in #1986\n- fix cstest Makefile by @imbillow in #1989\n- fix: compile error missing file cstool msvc/visual studio by @raigorx in #2000\n- Fix missing NOTRACK prefix by @junghee in #2002\n- Fix make builds with SH support by @trufae in #2006\n- Add missing architectures in the readme and sort them by @trufae in #2008\n- Add TriCore Architecture by @imbillow in #1973\n- Fix compilation warnings related to TriCore. by @imbillow in #2012\n- Fix SH build warnings. by @Rot127 in #2016\n- Tricore fix the negative call and jump by @imbillow in #2018\n- [SH] Fix warnings about unhandled switch cases by adding defaults. by @Rot127 in #2017\n- Tricore fix disp fill and ctest build by @imbillow in #2019\n- Fix disassemble of xor by @imbillow in #2023\n- Fix register accesses & operands of multiple ARMv8.3 PAC instructions by @stevielavern in - #2022\n- Add missing arm64 to Darwin LIBARCHS and remove dependencies tracking… by @gdbinit in #2024\n- Fix tricore compile warning by @imbillow in #2027\n- [PPC] Fix random branch hint and update_cr0 set up. by @Rot127 in #2028\n- Fix #2032 by @Rot127 in #2033\n- Add operands access support for TriCore by @imbillow in #2034\n- Hotfix for -DCAPSTONE_DIET build. by @Rot127 in #2038\n- Fix Python bindings after changes to cs_detail by @peace-maker in #2041\n- RISCV: Add call, int and branch_relative instruction groups by @peace-maker in #2007\n- Re-fix pkgconfig includedir/Cflags by @orlitzky in #2046\n\nNew Contributors:\n- @adamjseitz made their first contribution in #1859\n- @theblackunknown made their first contribution in #1867\n- @hamarituc made their first contribution in #1878\n- @terorie made their first contribution in #1885\n- @junghee made their first contribution in #1863\n- @jbott made their first contribution in #1910\n- @FinnWilkinson made their first contribution in #1907\n- @huth made their first contribution in #1921\n- @ZehMatt made their first contribution in #1937\n- @rrwhx made their first contribution in #1940\n- @Rot127 made their first contribution in #1942\n- @HyperSine made their first contribution in #1944\n- @mjunix made their first contribution in #1938\n- @ysat0 made their first contribution in #1927\n- @sunxingxing made their first contribution in #1959\n- @wideglide made their first contribution in #1961\n- @SweetVishnya made their first contribution in #1964\n- @covanam made their first contribution in #1968\n- @thomasdangl made their first contribution in #1974\n- @imbillow made their first contribution in #1989\n- @raigorx made their first contribution in #2000\n- @peace-maker made their first contribution in #2041\n- @orlitzky made their first contribution in #2046\n\n\n---------------------------------\nVersion 5.0.0-rc2: February 28th, 2022\n\nNew features:\n- None\n\nImprovements:\n- Fix for python publish build (#1844)\n- Modernize CMake and switch to CMake 3.15 (#1841)\n- Fix AArch64 ldapr detailed information (#1840)\n- Fix incorrect MI->ac_idx leading to wrong AArch64 InsnOp access printing (#1845)\n\nContributors:\n- stevielavern\n- mrexodia\n- kabeor\n\n---------------------------------\nVersion 5.0.0-rc1: February 27th, 2022\n\nNew features:\n- Add arch BPF (#1388)\n- Add arch RISCV (#1401)\n- Add arch WASM (#1359)\n- PyPI workflow (#1645)\n- Option to generate install target (#1698 #1700)\n- Swift binding (#1707)\n- Add CI Test support (#1797)\n- Add benchmark (#1811)\n\nImprovements:\n- Add fixups for aarch64 instructions (#1632 #1655)\n- Add fixups for x86 instructions (#1644 #1657 #1689 1751)\n- Add fixups for m68k instructions (#1663 #1709)\n- Add fixups for m680x instructions (#1695)\n- Add fixups for mips instructions (#1674)\n- Add fixups for mos65xx instructions (#1702)\n- Add fixups for systemz instructions (#1679)\n- Add fixups for risc-v instructions (#1682 #1690 #1691)\n- Add fixups for ppc instructions (#1687 #1688)\n- Add cmake config and export targets (#1637)\n- Fix issues in Makefiles (#1639)\n- Fix issues about cmake builds (#1649 #1659)\n- MSVC tooling updates (#1651)\n- Fix crash when using skipdata with NULL mnemonic(#1703)\n- Fix python only use ascii character (#1704)\n- Add support for aarch64 distributions (#1720)\n- Fix registry access for several versions of pop such as POPDS, POPSS, etc. (#1725)\n- Fix registry access on cmov instructions (#1727)\n- Fix -Wstringop-truncation warnings (#1730)\n- Fix always return the same type from regs_read (#1736)\n- Fix inconsistent behavior of Mips_option() (#1744)\n- Fix pythonic bug (#1745)\n- Fixes the (pip) Python Module build on FreeBSD (#1750)\n- Enable detection and build on all BSD systems (#1753)\n- Fix the displacement offset for moffset-encoded operands (#1754)\n- Update cmake_minimum_required to version 2.8.12 (#1756)\n- Fixed typos in compilation steps (#1762)\n- Fix build android (#1765)\n- Support disassembling bytes from memoryview (#1773)\n- Fixed library extension to build properly under CYGWIN (#1791)\n- Add Capstone Engine Documentation (#1794)\n- Fix eflags effects for adc/sbb (#1798)\n- Update x86 operand access information (#1801)\n- CI automatically build release tarball (#1802)\n- Don't format sstreams when there's nothing to format (#1805)\n- Fix warning about Unused variables (#1815)\n- Fix insn initialization when instruction have no operands or have a prefix (#1816)\n- Avoid abort() if x86 not supported (#1818)\n- Fix unterminated string regression (#1819)\n- Fixed incorrect operand access on x86 instruction vmovdqu (#1823)\n\nContributors:\n- ekilmer\n- mcmtroffaes\n- sh1r4s3\n- emoon\n- chfl4gs\n- heshpdx\n- hmoenck\n- cyanpencil\n- NicolasDerumigny\n- trofi\n- maximumspatium\n- junchao-loongson\n- carenas \n- notyourusualaccountname\n- rth7680\n- StalkR\n- aeflores\n- TobiasFaller\n- XVilka\n- meme\n- zydeco\n- catenacyber\n- michalsc\n- urbas\n- keenk\n- kazarmy\n- learn-more\n- veritas501\n- trufae\n- cederom\n- Quentin01\n- jranieri-grammatech\n- scribam\n- huettenhain\n- LBJ-the-GOAT\n- wheremyfoodat\n- Jaysonicc\n- huettenhain\n- syscl\n- bezita\n- Smartsmurf \n- tmfink\n- kazarmy\n- rofl0r\n- bSr43\n- wtdcode\n- dropTableUsers42\n- carenas\n- owlxiao\n- Mxz297\n- SpikeI\n- catenacyber\n- david942j\n- fanfuqiang\n- aquynh\n- kabeor\n\n\n---------------------------------\nVersion 4.0.2: May 8th, 2020\n\n[ Core ]\n\n- Windows kernel-mode driver support\n- Fix installation path on FreeBSD and DragonFly\n\n\n[ cstool ]\n\n- Add armv8, ppc32 & thumbv8 modes\n- Print instruction ID\n\n\n[ X86 ]\n\n- Support CS_OPT_UNSIGNED for ATT syntax\n- Fix operand size for some instructions\n- Fix LOCK prefixes\n- Recognize xacquire/xrelease prefix\n- Fix call/jmp access mode of mem operand\n- Add ENDBR32, ENDBR64 to reduce mode\n- Other minor fixes\n\n\n[ ARM64 ]\n\n- Support CS_OPT_UNSIGNED\n- Fix register access flags for memory instructions\n- Fix UMOV vess\n\n\n[ ARM ]\n\n- Update writeback for STR_POST_REG\n\n\n[ M68K ]\n\n- Store correct register value in op.reg_pair\n\n\n[ PowerPC ]\n\n- BDZLA is absolute branch\n\n\n[ SystemZ ]\n\n- Fix truncated 64bit imm operand\n- Fix base/index printing\n\n\n[ Python ]\n\n- Fix skipdata struct being destroyed\n- Add repr for capstone.CsInsn\n\n\n[ Java ]\n\n- Fix Java bindings to use pointers instead of longs\n\n\n[ Ocaml ]\n\n- Fix x86_op record\n\n\n---------------------------------\nVersion 4.0.1: January 10th, 2019\n\n\n[ Core ]\n\n- Fix some issues for packaging (Debian, Gentoo).\n- Better support for building with Mingw.\n- cstool has new option -s to turn on skipdata mode.\n- cstool -v now report build settings of the core.\n- Add suite/capstone_get_setup.c so users can integrate with their own code\n  to retrieve Capstone settings at build time.\n\n\n[ Arm ]\n\n- Fix 4.0 regression: the `tbh [r0, r1, lsl #1]` instruction sets the operand.shift.value back again (see #1317)\n- Remove ARM_REG_PC group for BX instruction.\n\n\n[ X86 ]\n\n- Fix: endbr32 and endbr64 instructions are now properly decoded in both CS_MODE_32 and CS_MODE_64  (#1129)\n\n\n[ M680X ]\n\n- Fix some issues reported by clang-analyzer (#1329).\n\n\n[ Python ]\n\n- Fix skipdata setup.\n- Add getter/setter for skipdata_mnem, skipdata_callback.\n\n\n---------------------------------\nVersion 4.0: December 18th, 2018\n\n\n[ Core ]\n\n- New APIs: cs_regs_access()\n- Add new options for cs_option(): CS_OPT_MNEMONIC & CS_OPT_UNSIGNED & CS_OPT_SYNTAX_MASM.\n- Various updates & bugfixes for all architectures.\n- Add 4 new architectures: EVM, M68K, M680X & TMS320C64x.\n- Add new group types: CS_GRP_PRIVILEGE & CS_GRP_BRANCH_RELATIVE.\n- Add new error types: CS_ERR_X86_MASM.\n\n\n[ X86 ]\n\n- Add XOP code condition type in x86_xop_cc.\n- Add some info on encoding to cs_x86 in cs_x86_encoding.\n- Add register flags update in cs_x86.{eflags, fpu_flags}\n- Change cs_x86.disp type from int32_t to int64_t.\n- Add new groups: X86_GRP_VM & X86_GRP_FPU.\n- Lots of new instructions (AVX)\n\n\n[ ARM64 ]\n\n- Add instruction ARM64_INS_NEGS & ARM64_INS_NGCS.\n\n\n[ Mips ]\n\n- Add mode CS_MODE_MIPS2.\n\n\n[ PPC ]\n\n- Change cs_ppc_op.imm type from int32_t to int64_t.\n- Add new groups: PPC_GRP_ICBT, PPC_GRP_P8ALTIVEC, PPC_GRP_P8VECTOR & PPC_GRP_QPX.\n- Lots of new instructions (QPX among them)\n\n\n[ Sparc ]\n\n- Change cs_sparc_op.imm type from int32_t to int64_t.\n\n\n[ Binding ]\n\n- New bindings: PowerShell & VB6\n\n\n---------------------------------\nVersion 3.0.5: July 18th, 2018\n\n\n[ Core ]\n\n- Fix the include path for Android builds when building cstool.\n- Add possibility to disable universal build for Mac OS.\n- cstool: Separate instruction bytes by spaces.\n- Fix code path of pkg-config in Cmake.\n- Update XCode project for XCode 9.1.\n- Add Cortex-M support to cstool.\n- Cmake forces to be build using MT with MSVC.\n- Better support for Mac OS kernel.\n\n\n[ X86 ]\n\n- Fix some issues in handling EVEX & VEX3 instructions.\n- Fix immediate operand for AND instruction in ATT mode.\n- Fix ATT syntax when imm operand is 0.\n- Better handle XACQUIRE/XRELEASE.\n- Fix imm operand of RETF.\n\n\n[ ARM ]\n\n- Fix an integer overflow bug.\n\n\n[ ARM64 ]\n\n- Bug fix for incorrect operand type in certain load/store instructions.\n\n\n[ Mips ]\n\n- Mode CS_MODE_MIPS32R6 automatically sets CS_MODE_32\n\n\n[ PPC ]\n\n- Fix endian check.\n\n\n[ Sparc ]\n\n- Fix an integer overflow bug.\n\n\n[ SystemZ ]\n\n- Fix an integer overflow bug.\n\n\n[ Python binding ]\n\n- Raise error on accessing irrelevant data fields if skipdata & detail modes are enable.\n\n\n---------------------------------\nVersion 3.0.5-rc3: July 31st, 2017\n\n\n[ Core ]\n\n- Fix compilation for MacOS kernel extension\n- cstool to support armbe and arm64be modes\n- Add nmake.bat for Windows build\n- Fix an integer overflow for Windows kernel driver\n- Support to embedded Capstone into MacOS kernel\n- cstool: fix mips64 mode\n- Fix a compiling error in MS Visual Studio 2015\n- Install pkgconfig file with CMake build\n- Fix SOVERSION property of CMake build\n- Properly handle switching to Endian mode at run-time for Arm, Arm64, Mips & Sparc\n- Fix MingW build\n- Better handle CMake installation for Linux 64bit\n\n\n[ X86 ]\n\n- Support BND prefix of Intel MPX extension\n- Correct operand size for CALL/JMP in 64bit mode with prefix 0x66\n- LOCK NOP is a valid instruction\n- Fix ATT syntax for instruction with zero offset segment register\n- LES/LDS are invalid in 64bit mode\n- Fix number of operands for some MOV instructions\n\n\n[ ARM ]\n\n- Fix POP reg to update SP register\n- Update flags for UADD8 instruction\n\n\n[ ARM64 ]\n\n- Better performance with new lookup table\n- Handle system registers added in ARMv8.1/2\n\n\n[ Java binding ]\n\n- Better handle input with invalid code\n\n\n[ Visual Basic binding ]\n\n- New binding\n\n---------------------------------\nVersion 3.0.5-rc2: March 2nd, 2017\n\n\n[ Core ]\n\n- Fix build for Visual Studio 2012\n- Fix X86_REL_ADDR macro\n- Add CS_VERSION_MAJOR, CS_VERSION_MINOR, CS_VERSION_EXTRA\n- Better support for embedding Capstone into Windows kernel drivers\n- Support to embedded Capstone into MacOS kernel\n- Support MacOS 10.11 and up\n- Better support for Cygwin\n- Support build packages for FreeBSD & DragonflyBSD\n- Add a command-line tool \"cstool\"\n- Properly handle switching to Endian mode at run-time for Arm, Arm64, Mips & Sparc\n\n\n[ X86 ]\n\n- Some random 16-bit code can be handled wrongly.\n- Remove abundant operand type X86_OP_FP\n- Fix instructions MOVQ, LOOP, LOOPE, LOOPNE, CALL/JMP rel16, REPNE LODSD, MOV *AX, MOFFS, FAR JMP/CALL\n- Add X86_REG_EFLAGS for STC and STD\n- Fix instruction attributes for SYSEXIT, MOVW, ROL, LGS, SLDT\n- Rename registers ST0-ST7 to be consistent with asm output\n\n\n[ ARM ]\n\n- Properly handle IT instruction\n- Fix LDRSB\n- Fix writeback for LDR\n- Fix Thumb BigEndian setup\n\n\n[ ARM64 ]\n\n- Fix arith extender\n- Fix writeback for LDR\n- Rename enum arm64_mrs_reg to arm64_sysreg\n\n\n[ PowerPC ]\n\n- Print 0 offset for memory operand\n\n\n[ Sparc ]\n\n- Fix POPC instruction\n\n\n[ Python binding ]\n\n- Better PyPy support\n- Add __version__\n- Better support for Python 3\n- Fix CS_SKIPDATA_CALLBACK prototype\n- Cast skipdata function inside binding to simplify the API\n\n\n[ Java binding ]\n\n- Better handle input with invalid code\n\n\n[ PowerShell ]\n\n- New binding\n\n---------------------------------\nVersion 3.0.4: July 15th, 2015\n\n\n[ Library ]\n\n- Improve cross-compile for Android using Android NDK.\n- Support cross-compile for AArch64 Android (with Linux GCC).\n- Removed osxkernel_inttypes.h that is incompatible with BSD license.\n- Make it possible to compile with CC having a space inside (like \"ccache gcc\").\n\n\n[ X86 ]\n\n- Fix a null pointer dereference bug on handling code with special prefixes.\n- Properly handle AL/AX/EAX operand for OUT instruction in AT&T syntax.\n- Print immediate operand in positive form in some algorithm instructions.\n- Properly decode some SSE instructions.\n\n\n[ PowerPC ]\n\n- Fixed a memory corruption bug.\n- Fixed a memory corruption bug for the engine built in DIET mode.\n\n\n[ Mips ]\n\n- Fixed instruction ID of SUBU instruction.\n- Fixed a memory corruption bug.\n\n\n[ Arm ]\n\n- Fixed a memory corruption bug on IT instruction.\n\n\n[ XCore ]\n\n- Fixed a memory corruption bug when instruction has a memory operand.\n\n\n[ Python ]\n\n- Support Virtualenv.\n- setup.py supports option --user if not in a virtualenv to allow for local usage.\n- Properly handle the destruction of Cs object in the case the shared library\n  was already unloaded.\n\n---------------------------------\nVersion 3.0.3: May 08th, 2015\n\n\n[ Library ]\n\n- Support to embed into Mac OS X kernel extensions.\n- Now it is possible to compile Capstone with older C compilers, such as\n  GCC 4.8 on Ubuntu 12.04.\n- Add \"test_iter\" to MSVC project.\n\n\n[ X86 ]\n\n- All shifted instructions SHL, SHR, SAL, SAR, RCL, RCR, ROL & ROR now support\n  $1 as first operand in *AT&T* syntax (so we have \"rcll $1, %edx\" instead of\n  \"rcll %edx\").\n- CMPXCHG16B is a valid instruction with LOCK prefix.\n- Fixed a segfault on the input of 0xF3.\n\n\n[ Arm ]\n\n- BLX instruction modifies PC & LR registers.\n\n\n[ Sparc ]\n\n- Improved displacement decoding for sparc banching instructions.\n\n\n[ Python binding ]\n\n- Fix for Cython so it can properly initialize.\n- X86Op.avx_zero_mask now has c_bool type, but not c_uint8 type.\n- Properly support compile with Cygwin & install binding (setup.py).\n\n---------------------------------\nVersion 3.0.2: March 11th, 2015\n\n\n[ Library ]\n\n- On *nix, only export symbols that are part of the API (instead of all\n  the internal symbols).\n\n\n[ X86 ]\n\n- Do not consider 0xF2 as REPNE prefix if it is a part of instruction encoding.\n- Fix implicit registers read/written & instruction groups of some instructions.\n- More flexible on the order of prefixes, so better handle some tricky\n  instructions.\n- REPNE prefix can go with STOS & MOVS instructions.\n- Fix a compilation bug for X86_REDUCE mode.\n- Fix operand size of instructions with operand PTR []\n\n\n[ Arm ]\n\n- Fix a bug where arm_op_mem.disp is wrongly calculated (in DETAIL mode).\n- Fix a bug on handling the If-Then block.\n\n\n[ Mips ]\n\n- Sanity check for the input size for MIPS64 mode.\n\n\n[ MSVC ]\n\n- Compile capstone.dll with static runtime MSVCR built in.\n\n\n[ Python binding ]\n\n- Fix a compiling issue of Cython binding with gcc 4.9.\n\n---------------------------------\nVersion 3.0.1: February 03rd, 2015\n\n[ X86 ]\n\n- Properly handle LOCK, REP, REPE & REPNE prefixes.\n- Handle undocumented immediates for SSE's (V)CMPPS/PD/SS/SD instructions.\n- Print LJUMP/LCALL without * as prefix for Intel syntax.\n- Handle REX prefix properly for segment/MMX related instructions (x86_64).\n- Instruction with length > 15 is consider invalid.\n- Handle some tricky encodings for instructions MOVSXD, FXCH, FCOM, FCOMP,\n  FSTP, FSTPNCE, NOP.\n- Handle some tricky code for some X86_64 instructions with REX prefix.\n- Add missing operands in detail mode for PUSH , POP , IN/OUT reg, reg\n- MOV32ms & MOV32sm should reference word rather than dword.\n\n\n[ Arm64 ]\n\n- BL & BLR instructions do not read SP register.\n- Print absolute (rather than relative) address for instructions B, BL,\n  CBNZ, ADR.\n\n\n[ Arm ]\n\n- Instructions ADC & SBC do not update flags.\n- BL & BLX do not read SP, but PC register.\n- Alias LDR instruction with operands [sp], 4 to POP.\n- Print immediate operand of MVN instruction in positive hexadecimal form.\n\n\n[ PowerPC ]\n\n- Fix some compilation bugs when DIET mode is enable.\n- Populate SLWI/SRWI instruction details with SH operand.\n\n\n[ Python binding ]\n\n- Fix a Cython bug when CsInsn.bytes returns a shorten array of bytes.\n- Fixed a memory leak for Cython disasm functions when we immaturely quit\n  the enumeration of disassembled instructions.\n- Fix a NULL memory access issue when SKIPDATA & Detail modes are enable\n  at the same time.\n- Fix a memory leaking bug when we stop enumeration over the disassembled\n  instructions prematurely.\n- Export generic operand types & groups (CS_OP_xxx & CS_GRP_xxx).\n\n---------------------------------\nVersion 3.0: November 19th, 2014\n\n[ API ]\n\n- New API: cs_disasm_iter & cs_malloc. See docs/README for tutorials.\n- Renamed cs_disasm_ex to cs_disasm (cs_disasm_ex is still supported, but\n  marked obsolete to be removed in future)\n- Support SKIPDATA mode, so Capstone can jump over unknown data and keep going\n  from the next legitimate instruction. See docs/README for tutorials.\n- More details provided in cs_detail struct for all architectures.\n- API version was bumped to 3.0.\n\n\n[ Bindings ]\n\n- Python binding supports Python3 (besides Python2).\n- Support Ocaml binding.\n- Java: add close() method to be used to deinitialize a Capstone object when\n  no longer use it.\n\n\n[ Architectures ]\n\n- New architectures: Sparc, SystemZ & XCore.\n- Important bugfixes for Arm, Arm64, Mips, PowerPC & X86.\n- Support more instructions for Arm, Arm64, Mips, PowerPC & X86.\n- Always expose absolute addresses rather than relative addresses (Arm, Arm64,\n  Mips, PPC, Sparc, X86).\n- Use common instruction operand types REG, IMM, MEM & FP across all\n  architectures (to enable cross-architecture analysis).\n- Use common instruction group types across all architectures (to enable\n  cross-architecture analysis).\n\n\n[ X86 ]\n\n- X86 engine is mature & handles all the malware tricks (that we are aware of).\n- Added a lot of new instructions (such as AVX512, 3DNow, etc).\n- Add prefix symbols X86_PREFIX_REP/REPNE/LOCK/CS/DS/SS/FS/GS/ES/OPSIZE/ADDRSIZE.\n- Print immediate in positive form & hexadecimal for AND/OR/XOR instructions.\n- More friendly disassembly for JMP16i (in the form segment:offset)\n\n\n[ Mips ]\n\n- Engine added supports for new hardware modes: Mips32R6 (CS_MODE_MIPS32R6) &\n  MipsGP64 (CS_MODE_MIPSGP64).\n- Removed the ABI-only mode CS_MODE_N64.\n- New modes CS_MODE_MIPS32 & CS_MODE_MIPS64 (to use instead of CS_MODE_32 &\n  CS_MODE_64).\n\n\n[ ARM ]\n\n- Support new mode CS_MODE_V8 for Armv8 A32 encodings.\n- Print immediate in positive form & hexadecimal for AND/ORR/EOR/BIC instructions\n\n\n[ ARM64 ]\n\n- Print immediate in hexadecimal for AND/ORR/EOR/TST instructions.\n\n\n[ PowerPC ]\n\n- Do not print a dot in front of absolute address.\n\n\n[ Other features ]\n\n- Support for Microsoft Visual Studio (so enable Windows native compilation).\n- Support CMake compilation.\n- Cross-compile for Android.\n- Build libraries/tests using XCode project\n- Much faster, while consuming less memory for all architectures.\n\n---------------------------------\nVersion 2.1.2: April 3rd, 2014\n\nThis is a stable release to fix some bugs deep in the core. There is no update\nto any architectures or bindings, so bindings version 2.1 can be used with this\nversion 2.1.2 just fine.\n\n[ Core changes]\n\n- Support cross-compilation for all iDevices (iPhone/iPad/iPod).\n- X86: do not print memory offset in negative form.\n- Fix a bug in X86 when Capstone cannot handle short instruction.\n- Print negative number above -9 without prefix 0x (arm64, mips, arm).\n- Correct the SONAME setup for library versioning (Linux, *BSD, Solaris).\n- Set library versioning for dylib of OSX.\n\n---------------------------------\nVersion 2.1.1: March 13th, 2014\n\nThis is a stable release to fix some bugs deep in the core. There is no update\nto any architectures or bindings, so bindings version 2.1 can be used with this\nversion 2.1.1 just fine.\n\n[ Core changes]\n\n- Fix a buffer overflow bug in Thumb mode (ARM). Some special input can\n  trigger this flaw.\n- Fix a crash issue when embedding Capstone into OSX kernel. This should\n  also enable Capstone to be embedded into other systems with limited stack\n  memory size such as Linux kernel or some firmwares.\n- Use a proper SONAME for library versioning (Linux).\n\n---------------------------------\nVersion 2.1: March 5th, 2014\n\n[ API changes ]\n\n- API version has been bumped to 2.1.\n- Change prototype of cs_close() to be able to invalidate closed handle.\n  See http://capstone-engine.org/version_2.1_API.html for more information.\n- Extend cs_support() to handle more query types, not only about supported\n  architectures. This change is backward compatible, however, so existent code\n  do not need to be modified to support this.\n- New query type CS_SUPPORT_DIET for cs_support() to ask about diet status of\n  the engine.\n- New error code CS_ERR_DIET to report errors about newly added diet mode.\n- New error code CS_ERR_VERSION to report issue of incompatible versions between\n  bindings & core engine.\n\n\n[ Core changes ]\n\n- On memory usage, Capstone uses about 40% less memory, while still faster\n  than version 2.0.\n- All architectures are much smaller: binaries size reduce at least 30%.\n  Especially, X86-only binary reduces from 1.9MB to just 720KB.\n- Support \"diet\" mode, in which engine size is further reduced (by around 40%)\n  for embedding purpose. The price to pay is that we have to sacrifice some\n  non-critical data fields. See http://capstone-engine.org/diet.html for more\n  details.\n\n\n[ Architectures ]\n\n- Update all 5 architectures to fix bugs.\n- PowerPC:\n\t- New instructions: FMR & MSYNC.\n- Mips:\n\t- New instruction: DLSA\n- X86:\n\t- Properly handle AVX-512 instructions.\n\t- New instructions: PSETPM, SALC, INT1, GETSEC.\n\t- Fix some memory leaking issues in case of prefixed instructions such\n\t  as LOCK, REP, REPNE.\n\n\n[ Python binding ]\n\n- Verify the core version at initialization time. Refuse to run if its version\n  is different from the core's version.\n- New API disasm_lite() added to Cs class. This light API only returns tuples of\n  (address, size, mnemonic, op_str), rather than list of CsInsn objects. This\n  improves performance by around 30% in some benchmarks.\n- New API version_bind() returns binding's version, which might differ from\n  the core's API version if the binding is out-of-date.\n- New API debug() returns information on Cython support, diet status & archs\n  compiled in.\n- Fixed some memory leaking bugs for Cython binding.\n- Fix a bug crashing Cython code when accessing @regs_read/regs_write/groups.\n- Support diet mode.\n\n\n[ Java binding ]\n\n- Fix some memory leaking bugs.\n- New API version() returns combined version.\n- Support diet mode.\n- Better support for detail option.\n\n\n[ Miscellaneous ]\n\n- make.sh now can uninstall the core engine. This is done with:\n\n\t$ sudo ./make.sh uninstall\n\n----------------------------------\nVersion 2.0: January 22nd, 2014\n\nRelease 2.0 deprecates version 1.0 and brings a lot of crucial changes.\n\n[ API changes ]\n\n- API version has been bumped to 2.0 (see cs_version() API)\n- New API cs_strerror(errno) returns a string describing error code given\n  in its only argument.\n- cs_version() now returns combined version encoding both major & minor versions.\n- New option CS_OPT_MODE allows to change engine’s mode at run-time with\n  cs_option().\n- New option CS_OPT_MEM allows to specify user-defined functions for dynamically\n  memory management used internally by Capstone. This is useful to embed Capstone\n  into special environments such as kernel or firmware.\n- New API cs_support() can be used to check if this lib supports a particular\n  architecture (this is necessary since we now allow to choose which architectures\n  to compile in).\n- The detail option is OFF by default now. To get detail information, it should be\n  explicitly turned ON. The details then can be accessed using cs_insn.detail\n  pointer (to newly added structure cs_detail)\n\n\n[ Core changes ]\n\n- On memory usage, Capstone uses much less memory, but a lot faster now.\n- User now can choose which architectures to be supported by modifying config.mk\n  before compiling/installing.\n\n\n[ Architectures ]\n\n- Arm\n     - Support Big-Endian mode (besides Little-Endian mode).\n     - Support friendly register, so instead of output sub \"r12,r11,0x14\",\n\t we have \"sub ip,fp,0x14\".\n- Arm64: support Big-Endian mode (besides Little-Endian mode).\n- PowerPC: newly added.\n- Mips: support friendly register, so instead of output \"srl $2,$1,0x1f\",\n     we have \"srl $v0,$at,0x1f\".\n- X86: bug fixes.\n\n\n[ Python binding ]\n\n- Python binding is vastly improved in performance: around 3 ~ 4 times faster\n  than in 1.0.\n- Cython support has been added, which can further speed up over the default\n  pure Python binding (up to 30% in some cases)\n- Function cs_disasm_quick() & Cs.disasm() now use generator (rather than a list)\n  to return successfully disassembled instructions. This improves the performance\n  and reduces memory usage.\n\n\n[ Java binding ]\n\n- Better performance & bug fixes.\n\n\n[ Miscellaneous ]\n\n- Fixed some installation issues with Gentoo Linux.\n- Capstone now can easily compile/install on all *nix, including Linux, OSX,\n  {Net, Free, Open}BSD & Solaris.\n\n----------------------------------\n[Version 1.0]: December 18th, 2013\n\n- Initial public release.\n\n"
        },
        {
          "name": "LEB128.h",
          "type": "blob",
          "size": 1.0546875,
          "content": "//===- llvm/Support/LEB128.h - [SU]LEB128 utility functions -----*- C++ -*-===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares some utility functions for encoding SLEB128 and\n// ULEB128 values.\n//\n//===----------------------------------------------------------------------===//\n\n/* Capstone Disassembly Engine */\n/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2019 */\n\n#ifndef CS_LLVM_SUPPORT_LEB128_H\n#define CS_LLVM_SUPPORT_LEB128_H\n\n#include \"include/capstone/capstone.h\"\n\n/// Utility function to decode a ULEB128 value.\nstatic inline uint64_t decodeULEB128(const uint8_t *p, unsigned *n)\n{\n\tconst uint8_t *orig_p = p;\n\tuint64_t Value = 0;\n\tunsigned Shift = 0;\n\tdo {\n\t\tValue += (uint64_t)(*p & 0x7f) << Shift;\n\t\tShift += 7;\n\t} while (*p++ >= 128);\n\tif (n)\n\t\t*n = (unsigned)(p - orig_p);\n\treturn Value;\n}\n\n#endif  // LLVM_SYSTEM_LEB128_H\n"
        },
        {
          "name": "LICENSES",
          "type": "tree",
          "content": null
        },
        {
          "name": "MCAsmInfo.h",
          "type": "blob",
          "size": 0.4423828125,
          "content": "// Copyright © 2024 Rot127 <unisono@quyllur.org>\n// SPDX-License-Identifier: BSD-3\n\n/// The equivalent of the MCAsmInfo class in LLVM.\n/// We save only some flags of the original class here.\n\n#ifndef CS_MCASMINFO_H\n#define CS_MCASMINFO_H\n\ntypedef enum {\n  SYSTEMZASMDIALECT_AD_ATT = 0,\n  SYSTEMZASMDIALECT_AD_HLASM = 1,\n} MCAsmInfoAssemblerDialect;\n\ntypedef struct {\n  MCAsmInfoAssemblerDialect assemblerDialect;\n} MCAsmInfo;\n\n#endif // CS_MCASMINFO_H\n"
        },
        {
          "name": "MCDisassembler.h",
          "type": "blob",
          "size": 0.279296875,
          "content": "/* Capstone Disassembly Engine */\n/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2019 */\n\n#ifndef CS_MCDISASSEMBLER_H\n#define CS_MCDISASSEMBLER_H\n\ntypedef enum DecodeStatus {\n\tMCDisassembler_Fail = 0,\n\tMCDisassembler_SoftFail = 1,\n\tMCDisassembler_Success = 3,\n} DecodeStatus;\n\n#endif\n\n"
        },
        {
          "name": "MCFixedLenDisassembler.h",
          "type": "blob",
          "size": 1.404296875,
          "content": "//===-- llvm/MC/MCFixedLenDisassembler.h - Decoder driver -------*- C++ -*-===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n// Fixed length disassembler decoder state machine driver.\n//===----------------------------------------------------------------------===//\n\n/* Capstone Disassembly Engine */\n/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2019 */\n\n#ifndef CS_LLVM_MC_MCFIXEDLENDISASSEMBLER_H\n#define CS_LLVM_MC_MCFIXEDLENDISASSEMBLER_H\n\n// Disassembler state machine opcodes.\nenum DecoderOps {\n\tMCD_OPC_ExtractField = 1, // OPC_ExtractField(uint8_t Start, uint8_t Len)\n\tMCD_OPC_FilterValue,      // OPC_FilterValue(uleb128 Val, uint16_t NumToSkip)\n\tMCD_OPC_CheckField,       // OPC_CheckField(uint8_t Start, uint8_t Len,\n\t\t\t\t\t\t\t  //                uleb128 Val, uint16_t NumToSkip)\n\tMCD_OPC_CheckPredicate,   // OPC_CheckPredicate(uleb128 PIdx, uint16_t NumToSkip)\n\tMCD_OPC_Decode,           // OPC_Decode(uleb128 Opcode, uleb128 DIdx)\n        MCD_OPC_TryDecode,        // OPC_TryDecode(uleb128 Opcode, uleb128 DIdx,\n                                  //               uint16_t NumToSkip)\t\n\tMCD_OPC_SoftFail,         // OPC_SoftFail(uleb128 PMask, uleb128 NMask)\n\tMCD_OPC_Fail              // OPC_Fail()\n};\n\n#endif\n"
        },
        {
          "name": "MCInst.c",
          "type": "blob",
          "size": 7.0419921875,
          "content": "/* Capstone Disassembly Engine */\n/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2019 */\n#if defined(CAPSTONE_HAS_OSXKERNEL)\n#include <Availability.h>\n#include <libkern/libkern.h>\n#else\n#include <stdio.h>\n#include <stdlib.h>\n#endif\n#include <string.h>\n#include <assert.h>\n\n#include \"MCInstrDesc.h\"\n#include \"MCInst.h\"\n#include \"utils.h\"\n\n#define MCINST_CACHE (ARR_SIZE(mcInst->Operands) - 1)\n\nvoid MCInst_Init(MCInst *inst, cs_arch arch)\n{\n\tmemset(inst, 0, sizeof(MCInst));\n\t// unnecessary to initialize in loop . its expensive and inst->size should be honored\n\tinst->Operands[0].Kind = kInvalid;\n\tinst->Operands[0].ImmVal = 0;\n\n\tinst->Opcode = 0;\n\tinst->OpcodePub = 0;\n\tinst->size = 0;\n\tinst->has_imm = false;\n\tinst->op1_size = 0;\n\tinst->ac_idx = 0;\n\tinst->popcode_adjust = 0;\n\tinst->assembly[0] = '\\0';\n\tinst->wasm_data.type = WASM_OP_INVALID;\n\tinst->xAcquireRelease = 0;\n\tfor (int i = 0; i < MAX_MC_OPS; ++i)\n\t\tinst->tied_op_idx[i] = -1;\n\tinst->isAliasInstr = false;\n\tinst->fillDetailOps = false;\n\tmemset(&inst->hppa_ext, 0, sizeof(inst->hppa_ext));\n\n\t// Set default assembly dialect.\n\tswitch (arch) {\n\tdefault:\n\t\tbreak;\n\tcase CS_ARCH_SYSTEMZ:\n\t\tinst->MAI.assemblerDialect = SYSTEMZASMDIALECT_AD_HLASM;\n\t\tbreak;\n\t}\n}\n\nvoid MCInst_clear(MCInst *inst)\n{\n\tinst->size = 0;\n}\n\n// does not free @Op\nvoid MCInst_insert0(MCInst *inst, int index, MCOperand *Op)\n{\n\tCS_ASSERT_RET(index < MAX_MC_OPS);\n\tint i;\n\n\tfor(i = inst->size; i > index; i--)\n\t\t//memcpy(&(inst->Operands[i]), &(inst->Operands[i-1]), sizeof(MCOperand));\n\t\tinst->Operands[i] = inst->Operands[i-1];\n\n\tinst->Operands[index] = *Op;\n\tinst->size++;\n}\n\nvoid MCInst_setOpcode(MCInst *inst, unsigned Op)\n{\n\tinst->Opcode = Op;\n}\n\nvoid MCInst_setOpcodePub(MCInst *inst, unsigned Op)\n{\n\tinst->OpcodePub = Op;\n}\n\nunsigned MCInst_getOpcode(const MCInst *inst)\n{\n\treturn inst->Opcode;\n}\n\nunsigned MCInst_getOpcodePub(const MCInst *inst)\n{\n\treturn inst->OpcodePub;\n}\n\nMCOperand *MCInst_getOperand(MCInst *inst, unsigned i)\n{\n\tassert(i < MAX_MC_OPS);\n\treturn &inst->Operands[i];\n}\n\nunsigned MCInst_getNumOperands(const MCInst *inst)\n{\n\treturn inst->size;\n}\n\n// This addOperand2 function doesn't free Op\nvoid MCInst_addOperand2(MCInst *inst, MCOperand *Op)\n{\n\tCS_ASSERT_RET(inst->size < MAX_MC_OPS);\n\tinst->Operands[inst->size] = *Op;\n\n\tinst->size++;\n}\n\nbool MCOperand_isValid(const MCOperand *op)\n{\n\treturn op->Kind != kInvalid;\n}\n\nbool MCOperand_isReg(const MCOperand *op)\n{\n\treturn op->Kind == kRegister || op->MachineOperandType == kRegister;\n}\n\nbool MCOperand_isImm(const MCOperand *op)\n{\n\treturn op->Kind == kImmediate || op->MachineOperandType == kImmediate;\n}\n\nbool MCOperand_isFPImm(const MCOperand *op)\n{\n\treturn op->Kind == kFPImmediate;\n}\n\nbool MCOperand_isDFPImm(const MCOperand *op)\n{\n\treturn op->Kind == kDFPImmediate;\n}\n\nbool MCOperand_isExpr(const MCOperand *op)\n{\n\treturn op->Kind == kExpr;\n}\n\nbool MCOperand_isInst(const MCOperand *op)\n{\n\treturn op->Kind == kInst;\n}\n\n/// getReg - Returns the register number.\nunsigned MCOperand_getReg(const MCOperand *op)\n{\n\treturn op->RegVal;\n}\n\n/// setReg - Set the register number.\nvoid MCOperand_setReg(MCOperand *op, unsigned Reg)\n{\n\top->RegVal = Reg;\n}\n\nint64_t MCOperand_getImm(const MCOperand *op)\n{\n\treturn op->ImmVal;\n}\n\nint64_t MCOperand_getExpr(const MCOperand *op)\n{\n\treturn op->ImmVal;\n}\n\nvoid MCOperand_setImm(MCOperand *op, int64_t Val)\n{\n\top->ImmVal = Val;\n}\n\ndouble MCOperand_getFPImm(const MCOperand *op)\n{\n\treturn op->FPImmVal;\n}\n\nvoid MCOperand_setFPImm(MCOperand *op, double Val)\n{\n\top->FPImmVal = Val;\n}\n\nMCOperand *MCOperand_CreateReg1(MCInst *mcInst, unsigned Reg)\n{\n\tMCOperand *op = &(mcInst->Operands[MCINST_CACHE]);\n\n\top->MachineOperandType = kRegister;\n\top->Kind = kRegister;\n\top->RegVal = Reg;\n\n\treturn op;\n}\n\nvoid MCOperand_CreateReg0(MCInst *mcInst, unsigned Reg)\n{\n\tMCOperand *op = &(mcInst->Operands[mcInst->size]);\n\tmcInst->size++;\n\n\top->MachineOperandType = kRegister;\n\top->Kind = kRegister;\n\top->RegVal = Reg;\n}\n\nMCOperand *MCOperand_CreateImm1(MCInst *mcInst, int64_t Val)\n{\n\tMCOperand *op = &(mcInst->Operands[MCINST_CACHE]);\n\n\top->MachineOperandType = kImmediate;\n\top->Kind = kImmediate;\n\top->ImmVal = Val;\n\n\treturn op;\n}\n\nvoid MCOperand_CreateImm0(MCInst *mcInst, int64_t Val)\n{\n\tassert(mcInst->size < MAX_MC_OPS);\n\tMCOperand *op = &(mcInst->Operands[mcInst->size]);\n\tmcInst->size++;\n\n\top->MachineOperandType = kImmediate;\n\top->Kind = kImmediate;\n\top->ImmVal = Val;\n}\n\n/// Check if any operand of the MCInstrDesc is predicable\nbool MCInst_isPredicable(const MCInstrDesc *MIDesc)\n{\n\tconst MCOperandInfo *OpInfo = MIDesc->OpInfo;\n\tunsigned NumOps = MIDesc->NumOperands;\n\tfor (unsigned i = 0; i < NumOps; ++i) {\n\t\tif (MCOperandInfo_isPredicate(&OpInfo[i])) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n/// Checks if tied operands exist in the instruction and sets\n/// - The writeback flag in detail\n/// - Saves the indices of the tied destination operands.\nvoid MCInst_handleWriteback(MCInst *MI, const MCInstrDesc *InstDescTable, unsigned tbl_size)\n{\n\tconst MCInstrDesc *InstDesc = NULL;\n\tconst MCOperandInfo *OpInfo = NULL;\n\tunsigned short NumOps = 0;\n\tInstDesc = MCInstrDesc_get(MCInst_getOpcode(MI), InstDescTable, tbl_size);\n\tOpInfo = InstDesc->OpInfo;\n\tNumOps = InstDesc->NumOperands;\n\n\tfor (unsigned i = 0; i < NumOps; ++i) {\n\t\tif (MCOperandInfo_isTiedToOp(&OpInfo[i])) {\n\t\t\tint idx = MCOperandInfo_getOperandConstraint(\n\t\t\t\tInstDesc, i,\n\t\t\t\tMCOI_TIED_TO);\n\n\t\t\tif (idx == -1)\n\t\t\t\tcontinue;\n\n\t\t\tif (i >= MAX_MC_OPS) {\n\t\t\t\tassert(0 &&\n\t\t\t\t       \"Maximum number of MC operands reached.\");\n\t\t\t}\n\t\t\tMI->tied_op_idx[i] = idx;\n\n\t\t\tif (MI->flat_insn->detail)\n\t\t\t\tMI->flat_insn->detail->writeback = true;\n\t\t}\n\t}\n}\n\n/// Check if operand with OpNum is tied by another operand\n/// (operand is tying destination).\nbool MCInst_opIsTied(const MCInst *MI, unsigned OpNum)\n{\n\tassert(OpNum < MAX_MC_OPS && \"Maximum number of MC operands exceeded.\");\n\tfor (int i = 0; i < MAX_MC_OPS; ++i) {\n\t\tif (MI->tied_op_idx[i] == OpNum)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\n/// Check if operand with OpNum is tying another operand\n/// (operand is tying src).\nbool MCInst_opIsTying(const MCInst *MI, unsigned OpNum)\n{\n\tassert(OpNum < MAX_MC_OPS && \"Maximum number of MC operands exceeded.\");\n\treturn MI->tied_op_idx[OpNum] != -1;\n}\n\n/// Returns the value of the @MCInst operand at index @OpNum.\nuint64_t MCInst_getOpVal(MCInst *MI, unsigned OpNum)\n{\n\tassert(OpNum < MAX_MC_OPS);\n\tMCOperand *op = MCInst_getOperand(MI, OpNum);\n\tif (MCOperand_isReg(op))\n\t\treturn MCOperand_getReg(op);\n\telse if (MCOperand_isImm(op))\n\t\treturn MCOperand_getImm(op);\n\telse\n\t\tassert(0 && \"Operand type not handled in this getter.\");\n\treturn MCOperand_getImm(op);\n}\n\nvoid MCInst_setIsAlias(MCInst *MI, bool Flag) {\n\tassert(MI);\n\tMI->isAliasInstr = Flag;\n\tMI->flat_insn->is_alias = Flag;\n}\n\n/// @brief Copies the relevant members of a temporary MCInst to\n/// the main MCInst. This is used if TryDecode was run on a temporary MCInst.\n/// @param MI The main MCInst\n/// @param TmpMI The temporary MCInst.\nvoid MCInst_updateWithTmpMI(MCInst *MI, MCInst *TmpMI) {\n\tMI->size = TmpMI->size;\n\tMI->Opcode = TmpMI->Opcode;\n\tassert(MI->size < MAX_MC_OPS);\n\tmemcpy(MI->Operands, TmpMI->Operands, sizeof(MI->Operands[0]) * MI->size);\n}\n"
        },
        {
          "name": "MCInst.h",
          "type": "blob",
          "size": 5.8271484375,
          "content": "//===-- llvm/MC/MCInst.h - MCInst class -------------------------*- C++ -*-===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains the declaration of the MCInst and MCOperand classes, which\n// is the basic representation used to represent low-level machine code\n// instructions.\n//\n//===----------------------------------------------------------------------===//\n\n/* Capstone Disassembly Engine */\n/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2019 */\n\n#ifndef CS_MCINST_H\n#define CS_MCINST_H\n\n#include \"include/capstone/capstone.h\"\n#include \"MCAsmInfo.h\"\n#include \"MCInstrDesc.h\"\n#include \"MCRegisterInfo.h\"\n\ntypedef struct MCInst MCInst;\ntypedef struct cs_struct cs_struct;\ntypedef struct MCOperand MCOperand;\ntypedef void MCExpr;\n\n/// MCOperand - Instances of this class represent operands of the MCInst class.\n/// This is a simple discriminated union.\nstruct MCOperand {\n\tenum {\n\t\tkInvalid = 0,  ///< Uninitialized.\n\t\tkRegister,     ///< Register operand.\n\t\tkImmediate,    ///< Immediate operand.\n\t\tkFPImmediate,  ///< Floating-point immediate operand.\n\t\tkDFPImmediate, ///< Double-Floating-point immediate operand.\n\t\tkExpr,\t       ///< Relocatable immediate operand.\n\t\tkInst\t       ///< Sub-instruction operand.\n\t} MachineOperandType;\n\tunsigned char Kind;\n\n\tunion {\n\t\tuint64_t RegVal;\n\t\tint64_t ImmVal;\n\t\tdouble FPImmVal;\n\t};\n};\n\nbool MCOperand_isValid(const MCOperand *op);\n\nbool MCOperand_isReg(const MCOperand *op);\n\nbool MCOperand_isImm(const MCOperand *op);\n\nbool MCOperand_isFPImm(const MCOperand *op);\n\nbool MCOperand_isDFPImm(const MCOperand *op);\n\nbool MCOperand_isExpr(const MCOperand *op);\n\nbool MCOperand_isInst(const MCOperand *op);\n\n/// getReg - Returns the register number.\nunsigned MCOperand_getReg(const MCOperand *op);\n\n/// setReg - Set the register number.\nvoid MCOperand_setReg(MCOperand *op, unsigned Reg);\n\nint64_t MCOperand_getImm(const MCOperand *op);\n\nvoid MCOperand_setImm(MCOperand *op, int64_t Val);\n\nint64_t MCOperand_getExpr(const MCOperand *op);\n\ndouble MCOperand_getFPImm(const MCOperand *op);\n\nvoid MCOperand_setFPImm(MCOperand *op, double Val);\n\nconst MCInst *MCOperand_getInst(const MCOperand *op);\n\nvoid MCOperand_setInst(MCOperand *op, const MCInst *Val);\n\n// create Reg operand in the next slot\nvoid MCOperand_CreateReg0(MCInst *inst, unsigned Reg);\n\n// create Reg operand use the last-unused slot\nMCOperand *MCOperand_CreateReg1(MCInst *inst, unsigned Reg);\n\n// create Imm operand in the next slot\nvoid MCOperand_CreateImm0(MCInst *inst, int64_t Val);\n\n// create Imm operand in the last-unused slot\nMCOperand *MCOperand_CreateImm1(MCInst *inst, int64_t Val);\n\n#define MAX_MC_OPS 48\n\n/// MCInst - Instances of this class represent a single low-level machine\n/// instruction.\nstruct MCInst {\n\tunsigned OpcodePub;  // public opcode (<arch>_INS_yyy in header files <arch>.h)\n\tuint8_t size;\t// number of operands\n\tbool has_imm;\t// indicate this instruction has an X86_OP_IMM operand - used for ATT syntax\n\tuint8_t op1_size; // size of 1st operand - for X86 Intel syntax\n\tunsigned Opcode;  // private opcode\n\tMCOperand Operands[MAX_MC_OPS];\n\tcs_insn *flat_insn;\t// insn to be exposed to public\n\tuint64_t address;\t// address of this insn\n\tcs_struct *csh;\t// save the main csh\n\tuint8_t x86opsize;\t// opsize for [mem] operand\n\n\t// These flags could be used to pass some info from one target subcomponent\n\t// to another, for example, from disassembler to asm printer. The values of\n\t// the flags have any sense on target level only (e.g. prefixes on x86).\n\tunsigned flags;\n\n\t// (Optional) instruction prefix, which can be up to 4 bytes.\n\t// A prefix byte gets value 0 when irrelevant.\n\t// This is copied from cs_x86 struct\n\tuint8_t x86_prefix[4];\n\tuint8_t imm_size;\t// immediate size for X86_OP_IMM operand\n\tbool writeback;\t\t// writeback for ARM\n\tint8_t tied_op_idx\n\t\t[MAX_MC_OPS]; ///< Tied operand indices. Index = Src op; Value: Dest op\n\t// operand access index for list of registers sharing the same access right (for ARM)\n\tuint8_t ac_idx;\n\tuint8_t popcode_adjust;   // Pseudo X86 instruction adjust\n\tchar assembly[8];\t// for special instruction, so that we don't need printer\n\tunsigned char evm_data[32];\t// for EVM PUSH operand\n\tcs_wasm_op wasm_data;    // for WASM operand\n\tMCRegisterInfo *MRI;\n\tuint8_t xAcquireRelease;   // X86 xacquire/xrelease\n\tbool isAliasInstr; // Flag if this MCInst is an alias.\n\tbool fillDetailOps; // If set, detail->operands gets filled.\n\thppa_ext hppa_ext;\t///< for HPPA operand. Contains info about modifiers and their effect on the instruction\n\tMCAsmInfo MAI; ///< The equivalent to MCAsmInfo in LLVM. It holds flags relevant for the asm style to print.\n};\n\nvoid MCInst_Init(MCInst *inst, cs_arch arch);\n\nvoid MCInst_clear(MCInst *inst);\n\n// do not free operand after inserting\nvoid MCInst_insert0(MCInst *inst, int index, MCOperand *Op);\n\nvoid MCInst_setOpcode(MCInst *inst, unsigned Op);\n\nunsigned MCInst_getOpcode(const MCInst*);\n\nvoid MCInst_setOpcodePub(MCInst *inst, unsigned Op);\n\nunsigned MCInst_getOpcodePub(const MCInst*);\n\nMCOperand *MCInst_getOperand(MCInst *inst, unsigned i);\n\nunsigned MCInst_getNumOperands(const MCInst *inst);\n\n// This addOperand2 function doesn't free Op\nvoid MCInst_addOperand2(MCInst *inst, MCOperand *Op);\n\nbool MCInst_isPredicable(const MCInstrDesc *MIDesc);\n\nvoid MCInst_handleWriteback(MCInst *MI, const MCInstrDesc *InstDescTable, unsigned tbl_size);\n\nbool MCInst_opIsTied(const MCInst *MI, unsigned OpNum);\n\nbool MCInst_opIsTying(const MCInst *MI, unsigned OpNum);\n\nuint64_t MCInst_getOpVal(MCInst *MI, unsigned OpNum);\n\nvoid MCInst_setIsAlias(MCInst *MI, bool Flag);\n\nstatic inline bool MCInst_isAlias(const MCInst *MI) {\n\treturn MI->isAliasInstr;\n}\n\nvoid MCInst_updateWithTmpMI(MCInst *MI, MCInst *TmpMI);\n\n#endif\n"
        },
        {
          "name": "MCInstPrinter.c",
          "type": "blob",
          "size": 7.8505859375,
          "content": "/* Capstone Disassembly Engine */\n/* By Rot127 <unisono@quyllur.org>, 2023 */\n\n#include \"MCInstPrinter.h\"\n#include \"cs_priv.h\"\n#include <capstone/platform.h>\n\nextern bool ARM_getFeatureBits(unsigned int mode, unsigned int feature);\nextern bool PPC_getFeatureBits(unsigned int mode, unsigned int feature);\nextern bool Mips_getFeatureBits(unsigned int mode, unsigned int feature);\nextern bool AArch64_getFeatureBits(unsigned int mode, unsigned int feature);\nextern bool TriCore_getFeatureBits(unsigned int mode, unsigned int feature);\n\nstatic bool testFeatureBits(const MCInst *MI, uint32_t Value)\n{\n\tassert(MI && MI->csh);\n\tswitch (MI->csh->arch) {\n\tdefault:\n\t\tassert(0 && \"Not implemented for current arch.\");\n\t\treturn false;\n#ifdef CAPSTONE_HAS_ARM\n\tcase CS_ARCH_ARM:\n\t\treturn ARM_getFeatureBits(MI->csh->mode, Value);\n#endif\n#ifdef CAPSTONE_HAS_POWERPC\n\tcase CS_ARCH_PPC:\n\t\treturn PPC_getFeatureBits(MI->csh->mode, Value);\n#endif\n#ifdef CAPSTONE_HAS_MIPS\n\tcase CS_ARCH_MIPS:\n\t\treturn Mips_getFeatureBits(MI->csh->mode, Value);\n#endif\n#ifdef CAPSTONE_HAS_AARCH64\n\tcase CS_ARCH_AARCH64:\n\t\treturn AArch64_getFeatureBits(MI->csh->mode, Value);\n#endif\n#ifdef CAPSTONE_HAS_TRICORE\n\tcase CS_ARCH_TRICORE:\n\t\treturn TriCore_getFeatureBits(MI->csh->mode, Value);\n#endif\n\t}\n}\n\nstatic bool matchAliasCondition(MCInst *MI, const MCRegisterInfo *MRI,\n\t\t\t\t\t\t\t\tunsigned *OpIdx, const AliasMatchingData *M,\n\t\t\t\t\t\t\t\tconst AliasPatternCond *C,\n\t\t\t\t\t\t\t\tbool *OrPredicateResult)\n{\n\t// Feature tests are special, they don't consume operands.\n\tif (C->Kind == AliasPatternCond_K_Feature)\n\t\treturn testFeatureBits(MI, C->Value);\n\tif (C->Kind == AliasPatternCond_K_NegFeature)\n\t\treturn !testFeatureBits(MI, C->Value);\n\t// For feature tests where just one feature is required in a list, set the\n\t// predicate result bit to whether the expression will return true, and only\n\t// return the real result at the end of list marker.\n\tif (C->Kind == AliasPatternCond_K_OrFeature) {\n\t\t*OrPredicateResult |= testFeatureBits(MI, C->Value);\n\t\treturn true;\n\t}\n\tif (C->Kind == AliasPatternCond_K_OrNegFeature) {\n\t\t*OrPredicateResult |= !(testFeatureBits(MI, C->Value));\n\t\treturn true;\n\t}\n\tif (C->Kind == AliasPatternCond_K_EndOrFeatures) {\n\t\tbool Res = *OrPredicateResult;\n\t\t*OrPredicateResult = false;\n\t\treturn Res;\n\t}\n\n\t// Get and consume an operand.\n\tMCOperand *Opnd = MCInst_getOperand(MI, *OpIdx);\n\t++(*OpIdx);\n\n\t// Check the specific condition for the operand.\n\tswitch (C->Kind) {\n\tdefault:\n\t\tassert(0 && \"invalid kind\");\n\tcase AliasPatternCond_K_Imm:\n\t\t// Operand must be a specific immediate.\n\t\treturn MCOperand_isImm(Opnd) &&\n\t\t\t   MCOperand_getImm(Opnd) == (int32_t)C->Value;\n\tcase AliasPatternCond_K_Reg:\n\t\t// Operand must be a specific register.\n\t\treturn MCOperand_isReg(Opnd) && MCOperand_getReg(Opnd) == C->Value;\n\tcase AliasPatternCond_K_TiedReg:\n\t\t// Operand must match the register of another operand.\n\t\treturn MCOperand_isReg(Opnd) &&\n\t\t\t   MCOperand_getReg(Opnd) ==\n\t\t\t\t   MCOperand_getReg(MCInst_getOperand(MI, C->Value));\n\tcase AliasPatternCond_K_RegClass:\n\t\t// Operand must be a register in this class. Value is a register class\n\t\t// id.\n\t\treturn MCOperand_isReg(Opnd) &&\n\t\t\t   MCRegisterClass_contains(\n\t\t\t\t   MCRegisterInfo_getRegClass(MRI, C->Value),\n\t\t\t\t   MCOperand_getReg(Opnd));\n\tcase AliasPatternCond_K_Custom:\n\t\t// Operand must match some custom criteria.\n\t\tassert(M->ValidateMCOperand && \"A custom validator should be set but isn't.\");\n\t\treturn M->ValidateMCOperand(Opnd, C->Value);\n\tcase AliasPatternCond_K_Ignore:\n\t\t// Operand can be anything.\n\t\treturn true;\n\tcase AliasPatternCond_K_Feature:\n\tcase AliasPatternCond_K_NegFeature:\n\tcase AliasPatternCond_K_OrFeature:\n\tcase AliasPatternCond_K_OrNegFeature:\n\tcase AliasPatternCond_K_EndOrFeatures:\n\t\tassert(0 && \"handled earlier\");\n\t}\n\treturn false;\n}\n\n/// Check if PatternsForOpcode is all zero.\nstatic inline bool validOpToPatter(const PatternsForOpcode *P)\n{\n\treturn !(P->Opcode == 0 && P->PatternStart == 0 && P->NumPatterns == 0);\n}\n\nconst char *matchAliasPatterns(MCInst *MI, const AliasMatchingData *M)\n{\n\t// TODO Rewrite to C\n\n\t// auto It = lower_bound(M.OpToPatterns, MI->getOpcode(),\n\t//                       [](const PatternsForOpcode &L, unsigned Opcode) {\n\t//                         return L.Opcode < Opcode;\n\t//                       });\n\t// if (It == M.OpToPatterns.end() || It->Opcode != MI->getOpcode())\n\t//   return nullptr;\n\n\t// Binary search by opcode. Return false if there are no aliases for this\n\t// opcode.\n\tunsigned MIOpcode = MI->Opcode;\n\tsize_t i = 0;\n\tuint32_t PatternOpcode = M->OpToPatterns[i].Opcode;\n\twhile (PatternOpcode < MIOpcode && validOpToPatter(&M->OpToPatterns[i]))\n\t\tPatternOpcode = M->OpToPatterns[++i].Opcode;\n\tif (PatternOpcode != MI->Opcode || !validOpToPatter(&M->OpToPatterns[i]))\n\t\treturn NULL;\n\n\t// // Try all patterns for this opcode.\n\tuint32_t AsmStrOffset = ~0U;\n\tconst AliasPattern *Patterns = M->Patterns + M->OpToPatterns[i].PatternStart;\n\tfor (const AliasPattern *P = Patterns;\n\t\tP != Patterns + M->OpToPatterns[i].NumPatterns; ++P) {\n\t\t// Check operand count first.\n\t\tif (MCInst_getNumOperands(MI) != P->NumOperands)\n\t\t\treturn NULL;\n\n\t\t// Test all conditions for this pattern.\n\t\tconst AliasPatternCond *Conds = M->PatternConds + P->AliasCondStart;\n\t\tunsigned OpIdx = 0;\n\t\tbool OrPredicateResult = false;\n\t\tbool allMatch = true;\n\t\tfor (const AliasPatternCond *C = Conds; C != Conds + P->NumConds; ++C) {\n\t\t\tif (!matchAliasCondition(MI, MI->MRI, &OpIdx, M, C, &OrPredicateResult)) {\n\t\t\t\tallMatch = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (allMatch) {\n\t\t\tAsmStrOffset = P->AsmStrOffset;\n\t\t\tbreak;\n\t\t}\n\t}\n\t// If no alias matched, don't print an alias.\n\tif (AsmStrOffset == ~0U)\n\t\treturn NULL;\n\n\t// Go to offset AsmStrOffset and use the null terminated string there. The\n\t// offset should point to the beginning of an alias string, so it should\n\t// either be zero or be preceded by a null byte.\n\treturn M->AsmStrings + AsmStrOffset;\n}\n\n// TODO Add functionality to toggle the flag.\nbool getUseMarkup(void) { return false; }\n\n/// Utility functions to make adding mark ups simpler.\nconst char *markup(const char *s)\n{\n\tstatic const char *no_markup = \"\";\n\tif (getUseMarkup())\n\t\treturn s;\n\telse\n\t\treturn no_markup;\n}\n\n// binary search for encoding in IndexType array\n// return -1 if not found, or index if found\nunsigned int binsearch_IndexTypeEncoding(const struct IndexType *index, size_t size, uint16_t encoding)\n{\n\t// binary searching since the index is sorted in encoding order\n\tsize_t left, right, m;\n\n\tright = size - 1;\n\n\tif (encoding < index[0].encoding || encoding > index[right].encoding)\n\t\t// not found\n\t\treturn -1;\n\n\tleft = 0;\n\n\twhile(left <= right) {\n\t\tm = (left + right) / 2;\n\t\tif (encoding == index[m].encoding) {\n\t\t\t// LLVM actually uses lower_bound for the index table search\n\t\t\t// Here we need to check if a previous entry is of the same encoding\n\t\t\t// and return the first one.\n\t\t\twhile (m > 0 && encoding == index[m - 1].encoding)\n\t\t\t\t--m;\n\t\t\treturn m;\n\t\t}\n\n\t\tif (encoding < index[m].encoding)\n\t\t\tright = m - 1;\n\t\telse\n\t\t\tleft = m + 1;\n\t}\n\n\t// not found\n\treturn -1;\n}\n\n// binary search for encoding in IndexTypeStr array\n// return -1 if not found, or index if found\nunsigned int binsearch_IndexTypeStrEncoding(const struct IndexTypeStr *index, size_t size, const char *name)\n{\n\t// binary searching since the index is sorted in encoding order\n\tsize_t left, right, m;\n\n\tright = size - 1;\n\n\tint str_left_cmp = strcmp(name, index[0].name);\n\tint str_right_cmp = strcmp(name, index[right].name);\n\tif (str_left_cmp < 0 || str_right_cmp > 0)\n\t\t// not found\n\t\treturn -1;\n\n\tleft = 0;\n\n\twhile(left <= right) {\n\t\tm = (left + right) / 2;\n\t\tif (strcmp(name, index[m].name) == 0) {\n\t\t\t// LLVM actually uses lower_bound for the index table search\n\t\t\t// Here we need to check if a previous entry is of the same encoding\n\t\t\t// and return the first one.\n\t\t\twhile (m > 0 && (strcmp(name, index[m - 1].name) == 0))\n\t\t\t\t--m;\n\t\t\treturn m;\n\t\t}\n\n\t\tif (strcmp(name, index[m].name) < 0)\n\t\t\tright = m - 1;\n\t\telse\n\t\t\tleft = m + 1;\n\t}\n\n\t// not found\n\treturn -1;\n}\n"
        },
        {
          "name": "MCInstPrinter.h",
          "type": "blob",
          "size": 2.6083984375,
          "content": "/* Capstone Disassembly Engine */\n/* By Rot127 <unisono@quyllur.org>, 2023 */\n\n#ifndef CS_MCINSTPRINTER_H\n#define CS_MCINSTPRINTER_H\n\n#include \"MCInst.h\"\n#include <assert.h>\n#include <capstone/platform.h>\n\n/// Returned by getMnemonic() of the AsmPrinters.\ntypedef struct {\n\tconst char *first; // Mnemonic\n\tuint64_t second;   // Bits\n} MnemonicBitsInfo;\n\n/// Map from opcode to pattern list by binary search.\ntypedef struct {\n\tuint32_t Opcode;\n\tuint16_t PatternStart;\n\tuint16_t NumPatterns;\n} PatternsForOpcode;\n\n/// Data for each alias pattern. Includes feature bits, string, number of\n/// operands, and a variadic list of conditions to check.\ntypedef struct {\n\tuint32_t AsmStrOffset;\n\tuint32_t AliasCondStart;\n\tuint8_t NumOperands;\n\tuint8_t NumConds;\n} AliasPattern;\n\ntypedef enum {\n\tAliasPatternCond_K_Feature,\t   // Match only if a feature is enabled.\n\tAliasPatternCond_K_NegFeature, // Match only if a feature is disabled.\n\tAliasPatternCond_K_OrFeature,  // Match only if one of a set of features is\n\t\t\t\t\t\t\t\t   // enabled.\n\tAliasPatternCond_K_OrNegFeature,  // Match only if one of a set of features\n\t\t\t\t\t\t\t\t\t // is disabled.\n\tAliasPatternCond_K_EndOrFeatures, // Note end of list of K_Or(Neg)?Features.\n\tAliasPatternCond_K_Ignore,\t\t  // Match any operand.\n\tAliasPatternCond_K_Reg,\t\t\t  // Match a specific register.\n\tAliasPatternCond_K_TiedReg,\t\t  // Match another already matched register.\n\tAliasPatternCond_K_Imm,\t\t\t  // Match a specific immediate.\n\tAliasPatternCond_K_RegClass,\t  // Match registers in a class.\n\tAliasPatternCond_K_Custom,\t\t  // Call custom matcher by index.\n} AliasPatternCond_CondKind;\n\ntypedef struct {\n\tAliasPatternCond_CondKind Kind;\n\tuint32_t Value;\n} AliasPatternCond;\n\ntypedef bool (*ValidateMCOperandFunc)(const MCOperand *MCOp, unsigned PredicateIndex);\n\n/// Tablegenerated data structures needed to match alias patterns.\ntypedef struct {\n\tconst PatternsForOpcode *OpToPatterns;\n\tconst AliasPattern *Patterns;\n\tconst AliasPatternCond *PatternConds;\n\tconst char *AsmStrings;\n\tconst ValidateMCOperandFunc ValidateMCOperand;\n} AliasMatchingData;\n\nconst char *matchAliasPatterns(MCInst *MI, const AliasMatchingData *M);\nbool getUseMarkup(void);\nconst char *markup(const char *s);\n\nstruct IndexType {\n\tuint16_t encoding;\n\tunsigned index;\n};\n\nstruct IndexTypeStr {\n\tconst char *name;\n\tunsigned index;\n};\n\n// binary search for encoding in IndexType array\n// return -1 if not found, or index if found\nunsigned int binsearch_IndexTypeEncoding(const struct IndexType *index, size_t size, uint16_t encoding);\nunsigned int binsearch_IndexTypeStrEncoding(const struct IndexTypeStr *index, size_t size, const char *name);\n\n#endif // CS_MCINSTPRINTER_H\n"
        },
        {
          "name": "MCInstrDesc.c",
          "type": "blob",
          "size": 1.505859375,
          "content": "/* Capstone Disassembly Engine */\n/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2019 */\n\n#include \"MCInstrDesc.h\"\n\n/// isPredicate - Set if this is one of the operands that made up of\n/// the predicate operand that controls an isPredicable() instruction.\nbool MCOperandInfo_isPredicate(const MCOperandInfo *m)\n{\n\treturn m->Flags & (1 << MCOI_Predicate);\n}\n\n/// isOptionalDef - Set if this operand is a optional def.\n///\nbool MCOperandInfo_isOptionalDef(const MCOperandInfo *m)\n{\n\treturn m->Flags & (1 << MCOI_OptionalDef);\n}\n\n/// Checks if operand is tied to another one.\nbool MCOperandInfo_isTiedToOp(const MCOperandInfo *m)\n{\n\tif (m->Constraints & (1 << MCOI_TIED_TO))\n\t\treturn true;\n\treturn false;\n}\n\n/// Returns the value of the specified operand constraint if\n/// it is present. Returns -1 if it is not present.\nint MCOperandInfo_getOperandConstraint(const MCInstrDesc *InstrDesc,\n\t\t\t\t       unsigned OpNum,\n\t\t\t\t       MCOI_OperandConstraint Constraint)\n{\n\tconst MCOperandInfo OpInfo = InstrDesc->OpInfo[OpNum];\n\tif (OpNum < InstrDesc->NumOperands &&\n\t    (OpInfo.Constraints & (1 << Constraint))) {\n\t\tunsigned ValuePos = 4 + Constraint * 4;\n\t\treturn (OpInfo.Constraints >> ValuePos) & 0xf;\n\t}\n\treturn -1;\n}\n\n/// Returns the instruction description for the given MCInst opcode.\n/// Function should be called like:\n/// MCInstrDesc_get(MCInst_getOpcode(MI), ARCHInstDesc, ARR_SIZE(ARCHInstDesc));\nconst MCInstrDesc *MCInstrDesc_get(unsigned opcode, const MCInstrDesc *table, unsigned tbl_size) {\n\treturn &table[tbl_size - 1 - opcode];\n}\n"
        },
        {
          "name": "MCInstrDesc.h",
          "type": "blob",
          "size": 5.4326171875,
          "content": "//===-- llvm/MC/MCInstrDesc.h - Instruction Descriptors -*- C++ -*-===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the MCOperandInfo and MCInstrDesc classes, which\n// are used to describe target instructions and their operands.\n//\n//===----------------------------------------------------------------------===//\n\n/* Capstone Disassembly Engine */\n/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2019 */\n\n#ifndef CS_LLVM_MC_MCINSTRDESC_H\n#define CS_LLVM_MC_MCINSTRDESC_H\n\n#include \"MCRegisterInfo.h\"\n#include \"capstone/platform.h\"\n\n//===----------------------------------------------------------------------===//\n// Machine Operand Flags and Description\n//===----------------------------------------------------------------------===//\n\n/// Operand constraints. These are encoded in 16 bits with one of the\n/// low-order 3 bits specifying that a constraint is present and the\n/// corresponding high-order hex digit specifying the constraint value.\n/// This allows for a maximum of 3 constraints.\ntypedef enum {\n\tMCOI_TIED_TO = 0,    // Operand tied to another operand.\n\tMCOI_EARLY_CLOBBER   // Operand is an early clobber register operand\n} MCOI_OperandConstraint;\n\n// Define a macro to produce each constraint value.\n#define CONSTRAINT_MCOI_TIED_TO(op) \\\n  ((1 << MCOI_TIED_TO) | ((op) << (4 + MCOI_TIED_TO * 4)))\n\n#define CONSTRAINT_MCOI_EARLY_CLOBBER \\\n  (1 << MCOI_EARLY_CLOBBER)\n\n/// OperandFlags - These are flags set on operands, but should be considered\n/// private, all access should go through the MCOperandInfo accessors.\n/// See the accessors for a description of what these are.\nenum MCOI_OperandFlags {\n\tMCOI_LookupPtrRegClass = 0,\n\tMCOI_Predicate,\n\tMCOI_OptionalDef\n};\n\n/// Operand Type - Operands are tagged with one of the values of this enum.\nenum MCOI_OperandType {\n\tMCOI_OPERAND_UNKNOWN = 0,\n\tMCOI_OPERAND_IMMEDIATE = 1,\n\tMCOI_OPERAND_REGISTER = 2,\n\tMCOI_OPERAND_MEMORY = 3,\n\tMCOI_OPERAND_PCREL = 4,\n\n\tMCOI_OPERAND_FIRST_GENERIC = 6,\n\tMCOI_OPERAND_GENERIC_0 = 6,\n\tMCOI_OPERAND_GENERIC_1 = 7,\n\tMCOI_OPERAND_GENERIC_2 = 8,\n\tMCOI_OPERAND_GENERIC_3 = 9,\n\tMCOI_OPERAND_GENERIC_4 = 10,\n\tMCOI_OPERAND_GENERIC_5 = 11,\n\tMCOI_OPERAND_LAST_GENERIC = 11,\n\n\tMCOI_OPERAND_FIRST_GENERIC_IMM = 12,\n\tMCOI_OPERAND_GENERIC_IMM_0 = 12,\n\tMCOI_OPERAND_LAST_GENERIC_IMM = 12,\n\n\tMCOI_OPERAND_FIRST_TARGET = 13,\n};\n\n\n/// MCOperandInfo - This holds information about one operand of a machine\n/// instruction, indicating the register class for register operands, etc.\n///\ntypedef struct MCOperandInfo {\n\t/// This specifies the register class enumeration of the operand\n\t/// if the operand is a register.  If isLookupPtrRegClass is set, then this is\n\t/// an index that is passed to TargetRegisterInfo::getPointerRegClass(x) to\n\t/// get a dynamic register class.\n\tint16_t RegClass;\n\n\t/// These are flags from the MCOI::OperandFlags enum.\n\tuint8_t Flags;\n\n\t/// Information about the type of the operand.\n\tuint8_t OperandType;\n\n\t/// The lower 3 bits are used to specify which constraints are set.\n\t/// The higher 13 bits are used to specify the value of constraints (4 bits each).\n\tuint16_t Constraints;\n\t/// Currently no other information.\n} MCOperandInfo;\n\n\n//===----------------------------------------------------------------------===//\n// Machine Instruction Flags and Description\n//===----------------------------------------------------------------------===//\n\n/// MCInstrDesc flags - These should be considered private to the\n/// implementation of the MCInstrDesc class. Clients should use the predicate\n/// methods on MCInstrDesc, not use these directly. These all correspond to\n/// bitfields in the MCInstrDesc::Flags field.\nenum {\n\tMCID_Variadic = 0,\n\tMCID_HasOptionalDef,\n\tMCID_Pseudo,\n\tMCID_Return,\n\tMCID_Call,\n\tMCID_Barrier,\n\tMCID_Terminator,\n\tMCID_Branch,\n\tMCID_IndirectBranch,\n\tMCID_Compare,\n\tMCID_MoveImm,\n\tMCID_MoveReg,\n\tMCID_Bitcast,\n\tMCID_Select,\n\tMCID_DelaySlot,\n\tMCID_FoldableAsLoad,\n\tMCID_MayLoad,\n\tMCID_MayStore,\n\tMCID_Predicable,\n\tMCID_NotDuplicable,\n\tMCID_UnmodeledSideEffects,\n\tMCID_Commutable,\n\tMCID_ConvertibleTo3Addr,\n\tMCID_UsesCustomInserter,\n\tMCID_HasPostISelHook,\n\tMCID_Rematerializable,\n\tMCID_CheapAsAMove,\n\tMCID_ExtraSrcRegAllocReq,\n\tMCID_ExtraDefRegAllocReq,\n\tMCID_RegSequence,\n\tMCID_ExtractSubreg,\n\tMCID_InsertSubreg,\n\tMCID_Convergent,\n\tMCID_Add,\n\tMCID_Trap,\n};\n\n/// MCInstrDesc - Describe properties that are true of each instruction in the\n/// target description file. This captures information about side effects,\n/// register use and many other things. There is one instance of this struct\n/// for each target instruction class, and the MachineInstr class points to\n/// this struct directly to describe itself.\ntypedef struct MCInstrDesc {\n\tunsigned char  NumOperands;   // Num of args (may be more if variable_ops)\n\tconst MCOperandInfo *OpInfo;   // 'NumOperands' entries about operands\n} MCInstrDesc;\n\nbool MCOperandInfo_isPredicate(const MCOperandInfo *m);\n\nbool MCOperandInfo_isOptionalDef(const MCOperandInfo *m);\n\nbool MCOperandInfo_isTiedToOp(const MCOperandInfo *m);\n\nint MCOperandInfo_getOperandConstraint(const MCInstrDesc *OpInfo,\n\t\t\t\t       unsigned OpNum,\n\t\t\t\t       MCOI_OperandConstraint Constraint);\nconst MCInstrDesc *MCInstrDesc_get(unsigned opcode,\n                                   const MCInstrDesc *table,\n                                   unsigned tbl_size);\n\n\n#endif\n"
        },
        {
          "name": "MCRegisterInfo.c",
          "type": "blob",
          "size": 3.7353515625,
          "content": "//=== MC/MCRegisterInfo.cpp - Target Register Description -------*- C++ -*-===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n//\n// This file implements MCRegisterInfo functions.\n//\n//===----------------------------------------------------------------------===//\n\n/* Capstone Disassembly Engine */\n/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2019 */\n\n#include \"MCRegisterInfo.h\"\n\n/// DiffListIterator - Base iterator class that can traverse the\n/// differentially encoded register and regunit lists in DiffLists.\n/// Don't use this class directly, use one of the specialized sub-classes\n/// defined below.\ntypedef struct DiffListIterator {\n\tuint16_t Val;\n\tconst MCPhysReg *List;\n} DiffListIterator;\n\nvoid MCRegisterInfo_InitMCRegisterInfo(MCRegisterInfo *RI,\n\t\tconst MCRegisterDesc *D, unsigned NR,\n\t\tunsigned RA, unsigned PC,\n\t\tconst MCRegisterClass *C, unsigned NC,\n\t\tuint16_t (*RURoots)[2], unsigned NRU,\n\t\tconst MCPhysReg *DL,\n\t\tconst char *Strings,\n\t\tconst uint16_t *SubIndices, unsigned NumIndices,\n\t\tconst uint16_t *RET)\n{\n\tRI->Desc = D;\n\tRI->NumRegs = NR;\n\tRI->RAReg = RA;\n\tRI->PCReg = PC;\n\tRI->Classes = C;\n\tRI->DiffLists = DL;\n\tRI->RegStrings = Strings;\n\tRI->NumClasses = NC;\n\tRI->RegUnitRoots = RURoots;\n\tRI->NumRegUnits = NRU;\n\tRI->SubRegIndices = SubIndices;\n\tRI->NumSubRegIndices = NumIndices;\n\tRI->RegEncodingTable = RET;\n}\n\nstatic void DiffListIterator_init(DiffListIterator *d, MCPhysReg InitVal, const MCPhysReg *DiffList)\n{\n\td->Val = InitVal;\n\td->List = DiffList;\n}\n\nstatic uint16_t DiffListIterator_getVal(DiffListIterator *d)\n{\n\treturn d->Val;\n}\n\nstatic bool DiffListIterator_next(DiffListIterator *d)\n{\n\tMCPhysReg D;\n\n\tif (d->List == 0)\n\t\treturn false;\n\n\tD = *d->List;\n\td->List++;\n\td->Val += D;\n\n\tif (!D)\n\t\td->List = 0;\n\n\treturn (D != 0);\n}\n\nstatic bool DiffListIterator_isValid(DiffListIterator *d)\n{\n\treturn (d->List != 0);\n}\n\nunsigned MCRegisterInfo_getMatchingSuperReg(const MCRegisterInfo *RI, unsigned Reg, unsigned SubIdx, const MCRegisterClass *RC)\n{\n\tDiffListIterator iter;\n\n\tif (Reg >= RI->NumRegs) {\n\t\treturn 0;\n\t}\n\n\tDiffListIterator_init(&iter, (MCPhysReg)Reg, RI->DiffLists + RI->Desc[Reg].SuperRegs);\n\tDiffListIterator_next(&iter);\n\n\twhile(DiffListIterator_isValid(&iter)) {\n\t\tuint16_t val = DiffListIterator_getVal(&iter);\n\t\tif (MCRegisterClass_contains(RC, val) && Reg ==  MCRegisterInfo_getSubReg(RI, val, SubIdx))\n\t\t\treturn val;\n\n\t\tDiffListIterator_next(&iter);\n\t}\n\n\treturn 0;\n}\n\nunsigned MCRegisterInfo_getSubReg(const MCRegisterInfo *RI, unsigned Reg, unsigned Idx)\n{\n\tDiffListIterator iter;\n\tconst uint16_t *SRI = RI->SubRegIndices + RI->Desc[Reg].SubRegIndices;\n\n\tDiffListIterator_init(&iter, (MCPhysReg)Reg, RI->DiffLists + RI->Desc[Reg].SubRegs);\n\tDiffListIterator_next(&iter);\n\n\twhile(DiffListIterator_isValid(&iter)) {\n\t\tif (*SRI == Idx)\n\t\t\treturn DiffListIterator_getVal(&iter);\n\t\tDiffListIterator_next(&iter);\n\t\t++SRI;\n\t}\n\n\treturn 0;\n}\n\nconst MCRegisterClass* MCRegisterInfo_getRegClass(const MCRegisterInfo *RI, unsigned i)\n{\n\t//assert(i < getNumRegClasses() && \"Register Class ID out of range\");\n\tif (i >= RI->NumClasses)\n\t\treturn 0;\n\treturn &(RI->Classes[i]);\n}\n\nbool MCRegisterClass_contains(const MCRegisterClass *c, unsigned Reg)\n{\n\tunsigned InByte = 0;\n\tunsigned Byte = 0;\n\n\t// Make sure that MCRegisterInfo_getRegClass didn't return 0\n\t// (for calls to GETREGCLASS_CONTAIN0)\n\tif(!c)\n\t\treturn false;\n\n\tInByte = Reg % 8;\n\tByte = Reg / 8;\n\n\tif (Byte >= c->RegSetSize)\n\t\treturn false;\n\n\treturn (c->RegSet[Byte] & (1 << InByte)) != 0;\n}\n\nunsigned MCRegisterClass_getRegister(const MCRegisterClass *c, unsigned RegNo) {\n    return c->RegsBegin[RegNo];\n}\n"
        },
        {
          "name": "MCRegisterInfo.h",
          "type": "blob",
          "size": 4.9072265625,
          "content": "//=== MC/MCRegisterInfo.h - Target Register Description ---------*- C++ -*-===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n//\n// This file describes an abstract interface used to get information about a\n// target machines register file.  This information is used for a variety of\n// purposed, especially register allocation.\n//\n//===----------------------------------------------------------------------===//\n\n/* Capstone Disassembly Engine */\n/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2019 */\n\n#ifndef CS_LLVM_MC_MCREGISTERINFO_H\n#define CS_LLVM_MC_MCREGISTERINFO_H\n\n#include \"capstone/platform.h\"\n#include \"SStream.h\"\n\n/// An unsigned integer type large enough to represent all physical registers,\n/// but not necessarily virtual registers.\ntypedef int16_t MCPhysReg;\ntypedef const MCPhysReg* iterator;\ntypedef uint16_t MCRegister;\n\ntypedef struct MCRegisterClass2 {\n\titerator RegsBegin;\n\tconst uint8_t *RegSet;\n\tuint8_t RegsSize;\n\tuint8_t RegSetSize;\n} MCRegisterClass2;\n\ntypedef struct MCRegisterClass {\n\titerator RegsBegin;\n\tconst uint8_t *RegSet;\n\tuint16_t RegSetSize;\n} MCRegisterClass;\n\n/// MCRegisterDesc - This record contains information about a particular\n/// register.  The SubRegs field is a zero terminated array of registers that\n/// are sub-registers of the specific register, e.g. AL, AH are sub-registers\n/// of AX. The SuperRegs field is a zero terminated array of registers that are\n/// super-registers of AX.\ntypedef struct MCRegisterDesc {\n\tuint32_t Name;      // Printable name for the reg (for debugging)\n\tuint32_t SubRegs;   // Sub-register set, described above\n\tuint32_t SuperRegs; // Super-register set, described above\n\n\t// Offset into MCRI::SubRegIndices of a list of sub-register indices for each\n\t// sub-register in SubRegs.\n\tuint32_t SubRegIndices;\n\n\t// RegUnits - Points to the list of register units. The low 4 bits holds the\n\t// Scale, the high bits hold an offset into DiffLists. See MCRegUnitIterator.\n\tuint32_t RegUnits;\n\n\t/// Index into list with lane mask sequences. The sequence contains a lanemask\n\t/// for every register unit.\n\tuint16_t RegUnitLaneMasks;\t// ???\n} MCRegisterDesc;\n\n/// MCRegisterInfo base class - We assume that the target defines a static\n/// array of MCRegisterDesc objects that represent all of the machine\n/// registers that the target has.  As such, we simply have to track a pointer\n/// to this array so that we can turn register number into a register\n/// descriptor.\n///\n/// Note this class is designed to be a base class of TargetRegisterInfo, which\n/// is the interface used by codegen. However, specific targets *should never*\n/// specialize this class. MCRegisterInfo should only contain getters to access\n/// TableGen generated physical register data. It must not be extended with\n/// virtual methods.\ntypedef struct MCRegisterInfo {\n\tconst MCRegisterDesc *Desc;                 // Pointer to the descriptor array\n\tunsigned NumRegs;                           // Number of entries in the array\n\tunsigned RAReg;                             // Return address register\n\tunsigned PCReg;                             // Program counter register\n\tconst MCRegisterClass *Classes;             // Pointer to the regclass array\n\tunsigned NumClasses;                        // Number of entries in the array\n\tunsigned NumRegUnits;                       // Number of regunits.\n\tuint16_t (*RegUnitRoots)[2];          // Pointer to regunit root table.\n\tconst MCPhysReg *DiffLists;                 // Pointer to the difflists array\n\t// const LaneBitmask *RegUnitMaskSequences;    // Pointer to lane mask sequences\n\tconst char *RegStrings;                     // Pointer to the string table.\n\t// const char *RegClassStrings;                // Pointer to the class strings.\n\tconst uint16_t *SubRegIndices;              // Pointer to the subreg lookup\n\t// array.\n\tunsigned NumSubRegIndices;                  // Number of subreg indices.\n\tconst uint16_t *RegEncodingTable;           // Pointer to array of register\n\t// encodings.\n} MCRegisterInfo;\n\nvoid MCRegisterInfo_InitMCRegisterInfo(MCRegisterInfo *RI,\n\t\tconst MCRegisterDesc *D, unsigned NR, unsigned RA,\n\t\tunsigned PC,\n\t\tconst MCRegisterClass *C, unsigned NC,\n\t\tuint16_t (*RURoots)[2],\n\t\tunsigned NRU,\n\t\tconst MCPhysReg *DL,\n\t\tconst char *Strings,\n\t\tconst uint16_t *SubIndices,\n\t\tunsigned NumIndices,\n\t\tconst uint16_t *RET);\n\nunsigned MCRegisterInfo_getMatchingSuperReg(const MCRegisterInfo *RI, unsigned Reg, unsigned SubIdx, const MCRegisterClass *RC);\n\nunsigned MCRegisterInfo_getSubReg(const MCRegisterInfo *RI, unsigned Reg, unsigned Idx);\n\nconst MCRegisterClass* MCRegisterInfo_getRegClass(const MCRegisterInfo *RI, unsigned i);\n\nbool MCRegisterClass_contains(const MCRegisterClass *c, unsigned Reg);\n\nunsigned MCRegisterClass_getRegister(const MCRegisterClass *c, unsigned i);\n\n#endif\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 16.3701171875,
          "content": "# Capstone Disassembly Engine\n# By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2014\n\ninclude config.mk\ninclude pkgconfig.mk\t# package version\ninclude functions.mk\n\n# Verbose output?\nV ?= 0\n\nOS := $(shell uname)\nifeq ($(OS),Darwin)\nLIBARCHS ?= x86_64 arm64\nPREFIX ?= /usr/local\nendif\n\nifeq ($(PKG_EXTRA),)\nPKG_VERSION = $(PKG_MAJOR).$(PKG_MINOR)\nelse\nPKG_VERSION = $(PKG_MAJOR).$(PKG_MINOR).$(PKG_EXTRA)\nendif\n\nifeq ($(CROSS),)\nRANLIB ?= ranlib\nelse ifeq ($(ANDROID), 1)\nCC = $(CROSS)/../../bin/clang\nAR = $(CROSS)/ar\nRANLIB = $(CROSS)/ranlib\nSTRIP = $(CROSS)/strip\nelse\nCC = $(CROSS)gcc\nAR = $(CROSS)ar\nRANLIB = $(CROSS)ranlib\nSTRIP = $(CROSS)strip\nendif\n\nifeq ($(OS),OS/390)\nRANLIB = touch\nendif\n\nifneq (,$(findstring yes,$(CAPSTONE_DIET)))\nCFLAGS ?= -Os\nCFLAGS += -DCAPSTONE_DIET\nelse\nCFLAGS ?= -O3\nendif\n\n# C99 has been enforced elsewhere like xcode\nCFLAGS += -std=gnu99\n\nifneq (,$(findstring yes,$(CAPSTONE_X86_ATT_DISABLE)))\nCFLAGS += -DCAPSTONE_X86_ATT_DISABLE\nendif\n\nifeq ($(CC),xlc)\nCFLAGS += -qcpluscmt -qkeyword=inline -qlanglvl=extc1x -Iinclude\nifneq ($(OS),OS/390)\nCFLAGS += -fPIC\nendif\nelse\nCFLAGS += -fPIC -Wall -Wwrite-strings -Wmissing-prototypes -Iinclude\nendif\n\nifeq ($(CAPSTONE_USE_SYS_DYN_MEM),yes)\nCFLAGS += -DCAPSTONE_USE_SYS_DYN_MEM\nendif\n\nifeq ($(CAPSTONE_HAS_OSXKERNEL), yes)\nCFLAGS += -DCAPSTONE_HAS_OSXKERNEL\nSDKROOT ?= $(shell xcodebuild -version -sdk macosx Path)\nCFLAGS += -mmacosx-version-min=10.5 \\\n\t\t  -isysroot$(SDKROOT) \\\n\t\t  -I$(SDKROOT)/System/Library/Frameworks/Kernel.framework/Headers \\\n\t\t  -mkernel \\\n\t\t  -fno-builtin\nendif\n\nPREFIX ?= /usr\nDESTDIR ?=\nifndef BUILDDIR\nBLDIR = .\nOBJDIR = .\nelse\nBLDIR = $(abspath $(BUILDDIR))\nOBJDIR = $(BLDIR)/obj\nendif\nINCDIR ?= $(PREFIX)/include\n\nUNAME_S := $(shell uname -s)\n\nLIBDIRARCH ?= lib\n# Uncomment the below line to installs x86_64 libs to lib64/ directory.\n# Or better, pass 'LIBDIRARCH=lib64' to 'make install/uninstall' via 'make.sh'.\n#LIBDIRARCH ?= lib64\nLIBDIR = $(DESTDIR)$(PREFIX)/$(LIBDIRARCH)\nBINDIR = $(DESTDIR)$(PREFIX)/bin\n\nLIBDATADIR = $(LIBDIR)\n\n# Don't redefine $LIBDATADIR when global environment variable\n# USE_GENERIC_LIBDATADIR is set. This is used by the pkgsrc framework.\n\nifndef USE_GENERIC_LIBDATADIR\nifeq ($(UNAME_S), FreeBSD)\nLIBDATADIR = $(DESTDIR)$(PREFIX)/libdata\nendif\nifeq ($(UNAME_S), DragonFly)\nLIBDATADIR = $(DESTDIR)$(PREFIX)/libdata\nendif\nendif\n\nINSTALL_BIN ?= install\nINSTALL_DATA ?= $(INSTALL_BIN) -m0644\nINSTALL_LIB ?= $(INSTALL_BIN) -m0755\n\nLIBNAME = capstone\n\n\nDEP_ARM =\nDEP_ARM += $(wildcard arch/ARM/ARM*.inc)\n\nLIBOBJ_ARM =\nifneq (,$(findstring arm,$(CAPSTONE_ARCHS)))\n\tCFLAGS += -DCAPSTONE_HAS_ARM\n\tLIBSRC_ARM += $(wildcard arch/ARM/ARM*.c)\n\tLIBOBJ_ARM += $(LIBSRC_ARM:%.c=$(OBJDIR)/%.o)\nendif\n\nDEP_AARCH64 =\nDEP_AARCH64 += $(wildcard arch/AArch64/AArch64*.inc)\n\nLIBOBJ_AARCH64 =\nifneq (,$(findstring aarch64,$(CAPSTONE_ARCHS)))\n\tCFLAGS += -DCAPSTONE_HAS_ARM64\n\tCFLAGS += -DCAPSTONE_HAS_AARCH64\n\tLIBSRC_AARCH64 += $(wildcard arch/AArch64/AArch64*.c)\n\tLIBOBJ_AARCH64 += $(LIBSRC_AARCH64:%.c=$(OBJDIR)/%.o)\nendif\n\n\nDEP_M68K =\nDEP_M68K += $(wildcard arch/M68K/M68K*.inc)\nDEP_M68K += $(wildcard arch/M68K/M68K*.h)\n\nLIBOBJ_M68K =\nifneq (,$(findstring m68k,$(CAPSTONE_ARCHS)))\n\tCFLAGS += -DCAPSTONE_HAS_M68K\n\tLIBSRC_M68K += $(wildcard arch/M68K/M68K*.c)\n\tLIBOBJ_M68K += $(LIBSRC_M68K:%.c=$(OBJDIR)/%.o)\nendif\n\nDEP_MIPS =\nDEP_MIPS += $(wildcard arch/Mips/Mips*.inc)\n\nLIBOBJ_MIPS =\nifneq (,$(findstring mips,$(CAPSTONE_ARCHS)))\n\tCFLAGS += -DCAPSTONE_HAS_MIPS\n\tLIBSRC_MIPS += $(wildcard arch/Mips/Mips*.c)\n\tLIBOBJ_MIPS += $(LIBSRC_MIPS:%.c=$(OBJDIR)/%.o)\nendif\n\nDEP_SH = $(wildcard arch/SH/SH*.inc)\n\nLIBOBJ_SH =\nifneq (,$(findstring sh,$(CAPSTONE_ARCHS)))\n\tCFLAGS += -DCAPSTONE_HAS_SH\n\tLIBSRC_SH += $(wildcard arch/SH/SH*.c)\n\tLIBOBJ_SH += $(LIBSRC_SH:%.c=$(OBJDIR)/%.o)\nendif\n\nDEP_PPC =\nDEP_PPC += $(wildcard arch/PowerPC/PPC*.inc)\n\nLIBOBJ_PPC =\nifneq (,$(findstring powerpc,$(CAPSTONE_ARCHS)))\n\tCFLAGS += -DCAPSTONE_HAS_POWERPC\n\tLIBSRC_PPC += $(wildcard arch/PowerPC/PPC*.c)\n\tLIBOBJ_PPC += $(LIBSRC_PPC:%.c=$(OBJDIR)/%.o)\nendif\n\n\nDEP_SPARC =\nDEP_SPARC += $(wildcard arch/Sparc/Sparc*.inc)\n\nLIBOBJ_SPARC =\nifneq (,$(findstring sparc,$(CAPSTONE_ARCHS)))\n\tCFLAGS += -DCAPSTONE_HAS_SPARC\n\tLIBSRC_SPARC += $(wildcard arch/Sparc/Sparc*.c)\n\tLIBOBJ_SPARC += $(LIBSRC_SPARC:%.c=$(OBJDIR)/%.o)\nendif\n\n\nDEP_SYSZ =\nDEP_SYSZ += $(wildcard arch/SystemZ/SystemZ*.inc)\n\nLIBOBJ_SYSZ =\nifneq (,$(findstring systemz,$(CAPSTONE_ARCHS)))\n\tCFLAGS += -DCAPSTONE_HAS_SYSZ\n\tLIBSRC_SYSZ += $(wildcard arch/SystemZ/SystemZ*.c)\n\tLIBOBJ_SYSZ += $(LIBSRC_SYSZ:%.c=$(OBJDIR)/%.o)\nendif\n\n\n# by default, we compile full X86 instruction sets\nX86_REDUCE =\nifneq (,$(findstring yes,$(CAPSTONE_X86_REDUCE)))\nX86_REDUCE = _reduce\nCFLAGS += -DCAPSTONE_X86_REDUCE -Os\nendif\n\n\nDEP_X86 =\nDEP_X86 += $(wildcard arch/X86/X86*.inc)\n\nLIBOBJ_X86 =\nifneq (,$(findstring x86,$(CAPSTONE_ARCHS)))\n\tCFLAGS += -DCAPSTONE_HAS_X86\n\tLIBOBJ_X86 += $(OBJDIR)/arch/X86/X86DisassemblerDecoder.o\n\tLIBOBJ_X86 += $(OBJDIR)/arch/X86/X86Disassembler.o\n\tLIBOBJ_X86 += $(OBJDIR)/arch/X86/X86InstPrinterCommon.o\n\tLIBOBJ_X86 += $(OBJDIR)/arch/X86/X86IntelInstPrinter.o\n# assembly syntax is irrelevant in Diet mode, when this info is suppressed\nifeq (,$(findstring yes,$(CAPSTONE_DIET)))\nifeq (,$(findstring yes,$(CAPSTONE_X86_ATT_DISABLE)))\n\tLIBOBJ_X86 += $(OBJDIR)/arch/X86/X86ATTInstPrinter.o\nendif\nendif\n\tLIBOBJ_X86 += $(OBJDIR)/arch/X86/X86Mapping.o\n\tLIBOBJ_X86 += $(OBJDIR)/arch/X86/X86Module.o\nendif\n\n\nDEP_XCORE =\nDEP_XCORE += $(wildcard arch/XCore/XCore*.inc)\n\nLIBOBJ_XCORE =\nifneq (,$(findstring xcore,$(CAPSTONE_ARCHS)))\n\tCFLAGS += -DCAPSTONE_HAS_XCORE\n\tLIBSRC_XCORE += $(wildcard arch/XCore/XCore*.c)\n\tLIBOBJ_XCORE += $(LIBSRC_XCORE:%.c=$(OBJDIR)/%.o)\nendif\n\n\nDEP_TMS320C64X =\nDEP_TMS320C64X += $(wildcard arch/TMS320C64x/TMS320C64x*.inc)\n\nLIBOBJ_TMS320C64X =\nifneq (,$(findstring tms320c64x,$(CAPSTONE_ARCHS)))\n\tCFLAGS += -DCAPSTONE_HAS_TMS320C64X\n\tLIBSRC_TMS320C64X += $(wildcard arch/TMS320C64x/TMS320C64x*.c)\n\tLIBOBJ_TMS320C64X += $(LIBSRC_TMS320C64X:%.c=$(OBJDIR)/%.o)\nendif\n\nDEP_M680X =\nDEP_M680X += $(wildcard arch/M680X/*.inc)\nDEP_M680X += $(wildcard arch/M680X/M680X*.h)\n\nLIBOBJ_M680X =\nifneq (,$(findstring m680x,$(CAPSTONE_ARCHS)))\n\tCFLAGS += -DCAPSTONE_HAS_M680X\n\tLIBSRC_M680X += $(wildcard arch/M680X/*.c)\n\tLIBOBJ_M680X += $(LIBSRC_M680X:%.c=$(OBJDIR)/%.o)\nendif\n\n\nDEP_EVM =\nDEP_EVM += $(wildcard arch/EVM/EVM*.inc)\n\nLIBOBJ_EVM =\nifneq (,$(findstring evm,$(CAPSTONE_ARCHS)))\n\tCFLAGS += -DCAPSTONE_HAS_EVM\n\tLIBSRC_EVM += $(wildcard arch/EVM/EVM*.c)\n\tLIBOBJ_EVM += $(LIBSRC_EVM:%.c=$(OBJDIR)/%.o)\nendif\n\nDEP_RISCV =\nDEP_RISCV += $(wildcard arch/RISCV/RISCV*.inc)\n\nLIBOBJ_RISCV =\nifneq (,$(findstring riscv,$(CAPSTONE_ARCHS)))\n\tCFLAGS += -DCAPSTONE_HAS_RISCV\n\tLIBSRC_RISCV += $(wildcard arch/RISCV/RISCV*.c)\n\tLIBOBJ_RISCV += $(LIBSRC_RISCV:%.c=$(OBJDIR)/%.o)\nendif\n\nDEP_WASM =\nDEP_WASM += $(wildcard arch/WASM/WASM*.inc)\n\nLIBOBJ_WASM =\nifneq (,$(findstring wasm,$(CAPSTONE_ARCHS)))\n\tCFLAGS += -DCAPSTONE_HAS_WASM\n\tLIBSRC_WASM += $(wildcard arch/WASM/WASM*.c)\n\tLIBOBJ_WASM += $(LIBSRC_WASM:%.c=$(OBJDIR)/%.o)\nendif\n\n\nDEP_MOS65XX =\nDEP_MOS65XX += $(wildcard arch/MOS65XX/MOS65XX*.inc)\n\nLIBOBJ_MOS65XX =\nifneq (,$(findstring mos65xx,$(CAPSTONE_ARCHS)))\n\tCFLAGS += -DCAPSTONE_HAS_MOS65XX\n\tLIBSRC_MOS65XX += $(wildcard arch/MOS65XX/MOS65XX*.c)\n\tLIBOBJ_MOS65XX += $(LIBSRC_MOS65XX:%.c=$(OBJDIR)/%.o)\nendif\n\n\nDEP_BPF =\nDEP_BPF += $(wildcard arch/BPF/BPF*.inc)\n\nLIBOBJ_BPF =\nifneq (,$(findstring bpf,$(CAPSTONE_ARCHS)))\n\tCFLAGS += -DCAPSTONE_HAS_BPF\n\tLIBSRC_BPF += $(wildcard arch/BPF/BPF*.c)\n\tLIBOBJ_BPF += $(LIBSRC_BPF:%.c=$(OBJDIR)/%.o)\nendif\n\nDEP_TRICORE =\nDEP_TRICORE +=$(wildcard arch/TriCore/TriCore*.inc)\n\nLIBOBJ_TRICORE =\nifneq (,$(findstring tricore,$(CAPSTONE_ARCHS)))\n\tCFLAGS += -DCAPSTONE_HAS_TRICORE\n\tLIBSRC_TRICORE += $(wildcard arch/TriCore/TriCore*.c)\n\tLIBOBJ_TRICORE += $(LIBSRC_TRICORE:%.c=$(OBJDIR)/%.o)\nendif\n\nDEP_ALPHA =\nDEP_ALPHA +=$(wildcard arch/Alpha/Alpha*.inc)\n\nLIBOBJ_ALPHA =\nifneq (,$(findstring alpha,$(CAPSTONE_ARCHS)))\n\tCFLAGS += -DCAPSTONE_HAS_ALPHA\n\tLIBSRC_ALPHA += $(wildcard arch/Alpha/Alpha*.c)\n\tLIBOBJ_ALPHA += $(LIBSRC_ALPHA:%.c=$(OBJDIR)/%.o)\nendif\n\nDEP_HPPA =\nDEP_HPPA += $(wildcard arch/HPPA/HPPA*.inc)\n\nLIBOBJ_HPPA =\nifneq (,$(findstring hppa,$(CAPSTONE_ARCHS)))\n\tCFLAGS += -DCAPSTONE_HAS_HPPA\n\tLIBSRC_HPPA += $(wildcard arch/HPPA/HPPA*.c)\n\tLIBOBJ_HPPA += $(LIBSRC_HPPA:%.c=$(OBJDIR)/%.o)\nendif\n\nDEP_LOONGARCH =\nDEP_LOONGARCH += $(wildcard arch/LoongArch/LoongArch*.inc)\n\nLIBOBJ_LOONGARCH =\nifneq (,$(findstring loongarch,$(CAPSTONE_ARCHS)))\n\tCFLAGS += -DCAPSTONE_HAS_LOONGARCH\n\tLIBSRC_LOONGARCH += $(wildcard arch/LoongArch/LoongArch*.c)\n\tLIBOBJ_LOONGARCH += $(LIBSRC_LOONGARCH:%.c=$(OBJDIR)/%.o)\nendif\n\nDEP_XTENSA =\nDEP_XTENSA += $(wildcard arch/Xtensa/Xtensa*.inc)\n\nLIBOBJ_XTENSA =\nifneq (,$(findstring xtensa,$(CAPSTONE_ARCHS)))\n\tCFLAGS += -DCAPSTONE_HAS_XTENSA\n\tLIBSRC_XTENSA += $(wildcard arch/Xtensa/Xtensa*.c)\n\tLIBOBJ_XTENSA += $(LIBSRC_XTENSA:%.c=$(OBJDIR)/%.o)\nendif\n\nLIBOBJ =\nLIBOBJ += $(OBJDIR)/cs.o $(OBJDIR)/utils.o $(OBJDIR)/SStream.o $(OBJDIR)/MCInstrDesc.o $(OBJDIR)/MCRegisterInfo.o $(OBJDIR)/MCInst.o $(OBJDIR)/MCInstPrinter.o $(OBJDIR)/Mapping.o\nLIBOBJ += $(LIBOBJ_ARM) $(LIBOBJ_AARCH64) $(LIBOBJ_M68K) $(LIBOBJ_MIPS) $(LIBOBJ_PPC) $(LIBOBJ_RISCV) $(LIBOBJ_SPARC) $(LIBOBJ_SYSZ) $(LIBOBJ_SH)\nLIBOBJ += $(LIBOBJ_X86) $(LIBOBJ_XCORE) $(LIBOBJ_TMS320C64X) $(LIBOBJ_M680X) $(LIBOBJ_EVM) $(LIBOBJ_MOS65XX) $(LIBOBJ_WASM) $(LIBOBJ_BPF)\nLIBOBJ += $(LIBOBJ_TRICORE) $(LIBOBJ_ALPHA) $(LIBOBJ_HPPA) $(LIBOBJ_LOONGARCH) $(LIBOBJ_XTENSA)\n\n\nifeq ($(PKG_EXTRA),)\nPKGCFGDIR = $(LIBDATADIR)/pkgconfig\nelse\nPKGCFGDIR ?= $(LIBDATADIR)/pkgconfig\nifeq ($(PKGCFGDIR),)\nPKGCFGDIR = $(LIBDATADIR)/pkgconfig\nendif\nendif\n\nAPI_MAJOR=$(shell echo `grep -e CS_API_MAJOR include/capstone/capstone.h | grep -v = | awk '{print $$3}'` | awk '{print $$1}')\nVERSION_EXT =\n\nIS_APPLE := $(shell $(CC) -dM -E - < /dev/null 2> /dev/null | grep __APPLE__ | wc -l | tr -d \" \")\nifeq ($(IS_APPLE),1)\n# on MacOS, do not build in Universal format by default\nMACOS_UNIVERSAL ?= no\nifeq ($(MACOS_UNIVERSAL),yes)\nCFLAGS += $(foreach arch,$(LIBARCHS),-arch $(arch))\nLDFLAGS += $(foreach arch,$(LIBARCHS),-arch $(arch))\nendif\nEXT = dylib\nVERSION_EXT = $(API_MAJOR).$(EXT)\n$(LIBNAME)_LDFLAGS += -dynamiclib -install_name lib$(LIBNAME).$(VERSION_EXT) -current_version $(PKG_MAJOR).$(PKG_MINOR).$(PKG_EXTRA) -compatibility_version $(PKG_MAJOR).$(PKG_MINOR)\nAR_EXT = a\n# Homebrew wants to make sure its formula does not disable FORTIFY_SOURCE\n# However, this is not really necessary because 'CAPSTONE_USE_SYS_DYN_MEM=yes' by default\nifneq ($(HOMEBREW_CAPSTONE),1)\nifneq ($(CAPSTONE_USE_SYS_DYN_MEM),yes)\n# remove string check because OSX kernel complains about missing symbols\nCFLAGS += -D_FORTIFY_SOURCE=0\nendif\nendif\nelse\nCFLAGS += $(foreach arch,$(LIBARCHS),-arch $(arch))\nLDFLAGS += $(foreach arch,$(LIBARCHS),-arch $(arch))\nifeq ($(OS), AIX)\n$(LIBNAME)_LDFLAGS += -qmkshrobj\nelse\n$(LIBNAME)_LDFLAGS += -shared\nendif\n# Cygwin?\nIS_CYGWIN := $(shell $(CC) -dumpmachine 2>/dev/null | grep -i cygwin | wc -l)\nifeq ($(IS_CYGWIN),1)\nEXT = dll\nAR_EXT = lib\n# Cygwin doesn't like -fPIC\nCFLAGS := $(CFLAGS:-fPIC=)\n# On Windows we need the shared library to be executable\nelse\n# mingw?\nIS_MINGW := $(shell $(CC) --version 2>/dev/null | grep -i \"\\(mingw\\|MSYS\\)\" | wc -l)\nifeq ($(IS_MINGW),1)\nEXT = dll\nAR_EXT = lib\n# mingw doesn't like -fPIC either\nCFLAGS := $(CFLAGS:-fPIC=)\n# On Windows we need the shared library to be executable\nelse\n# Linux, *BSD\nEXT = so\nVERSION_EXT = $(EXT).$(API_MAJOR)\nAR_EXT = a\n$(LIBNAME)_LDFLAGS += -Wl,-soname,lib$(LIBNAME).$(VERSION_EXT)\nendif\nendif\nendif\n\nifeq ($(CAPSTONE_SHARED),yes)\nifeq ($(IS_MINGW),1)\nLIBRARY = $(BLDIR)/$(LIBNAME).$(VERSION_EXT)\nelse ifeq ($(IS_CYGWIN),1)\nLIBRARY = $(BLDIR)/$(LIBNAME).$(EXT)\nelse\t# *nix\nLIBRARY = $(BLDIR)/lib$(LIBNAME).$(VERSION_EXT)\nCFLAGS += -fvisibility=hidden\nendif\nendif\n\nifeq ($(CAPSTONE_STATIC),yes)\nifeq ($(IS_MINGW),1)\nARCHIVE = $(BLDIR)/$(LIBNAME).$(AR_EXT)\nelse ifeq ($(IS_CYGWIN),1)\nARCHIVE = $(BLDIR)/$(LIBNAME).$(AR_EXT)\nelse\nARCHIVE = $(BLDIR)/lib$(LIBNAME).$(AR_EXT)\nendif\nendif\n\nPKGCFGF = $(BLDIR)/$(LIBNAME).pc\n\n.PHONY: all clean install uninstall dist\n\nall: $(LIBRARY) $(ARCHIVE) $(PKGCFGF)\nifeq (,$(findstring yes,$(CAPSTONE_BUILD_CORE_ONLY)))\n\t@V=$(V) CC=$(CC) $(MAKE) -C cstool\nendif\n\nifeq ($(CAPSTONE_SHARED),yes)\n$(LIBRARY): $(LIBOBJ)\nifeq ($(V),0)\n\t$(call log,LINK,$(@:$(BLDIR)/%=%))\n\t@$(create-library)\nelse\n\t$(create-library)\nendif\nendif\n\n$(LIBOBJ): config.mk\n\n$(LIBOBJ_ARM): $(DEP_ARM)\n$(LIBOBJ_AARCH64): $(DEP_AARCH64)\n$(LIBOBJ_M68K): $(DEP_M68K)\n$(LIBOBJ_MIPS): $(DEP_MIPS)\n$(LIBOBJ_PPC): $(DEP_PPC)\n$(LIBOBJ_SH): $(DEP_SH)\n$(LIBOBJ_SPARC): $(DEP_SPARC)\n$(LIBOBJ_SYSZ): $(DEP_SYSZ)\n$(LIBOBJ_X86): $(DEP_X86)\n$(LIBOBJ_XCORE): $(DEP_XCORE)\n$(LIBOBJ_TMS320C64X): $(DEP_TMS320C64X)\n$(LIBOBJ_M680X): $(DEP_M680X)\n$(LIBOBJ_EVM): $(DEP_EVM)\n$(LIBOBJ_RISCV): $(DEP_RISCV)\n$(LIBOBJ_WASM): $(DEP_WASM)\n$(LIBOBJ_MOS65XX): $(DEP_MOS65XX)\n$(LIBOBJ_BPF): $(DEP_BPF)\n$(LIBOBJ_TRICORE): $(DEP_TRICORE)\n$(LIBOBJ_ALPHA): $(DEP_ALPHA)\n$(LIBOBJ_HPPA): $(DEP_HPPA)\n$(LIBOBJ_LOONGARCH): $(DEP_LOONGARCH)\n$(LIBOBJ_XTENSA): $(DEP_XTENSA)\n\nifeq ($(CAPSTONE_STATIC),yes)\n$(ARCHIVE): $(LIBOBJ)\n\t@rm -f $(ARCHIVE)\nifeq ($(V),0)\n\t$(call log,AR,$(@:$(BLDIR)/%=%))\n\t@$(create-archive)\nelse\n\t$(create-archive)\nendif\nendif\n\n$(PKGCFGF):\nifeq ($(V),0)\n\t$(call log,GEN,$(@:$(BLDIR)/%=%))\n\t@$(generate-pkgcfg)\nelse\n\t$(generate-pkgcfg)\nendif\n\n# create a list of auto dependencies\nAUTODEPS:= $(patsubst %.o,%.d, $(LIBOBJ))\n\n# include by auto dependencies\n-include $(AUTODEPS)\n\ninstall: $(PKGCFGF) $(ARCHIVE) $(LIBRARY)\n\tmkdir -p $(LIBDIR)\n\t$(call install-library,$(LIBDIR))\nifeq ($(CAPSTONE_STATIC),yes)\n\t$(INSTALL_DATA) $(ARCHIVE) $(LIBDIR)\nendif\n\tmkdir -p $(DESTDIR)$(INCDIR)/$(LIBNAME)\n\t$(INSTALL_DATA) include/capstone/*.h $(DESTDIR)$(INCDIR)/$(LIBNAME)\n\tmkdir -p $(PKGCFGDIR)\n\t$(INSTALL_DATA) $(PKGCFGF) $(PKGCFGDIR)\nifeq (,$(findstring yes,$(CAPSTONE_BUILD_CORE_ONLY)))\n\tmkdir -p $(BINDIR)\n\t$(INSTALL_LIB) cstool/cstool $(BINDIR)\nendif\n\nuninstall:\n\trm -rf $(DESTDIR)$(INCDIR)/$(LIBNAME)\n\trm -f $(LIBDIR)/lib$(LIBNAME).*\n\trm -f $(PKGCFGDIR)/$(LIBNAME).pc\nifeq (,$(findstring yes,$(CAPSTONE_BUILD_CORE_ONLY)))\n\trm -f $(BINDIR)/cstool\nendif\n\nclean:\n\trm -f $(LIBOBJ)\n\trm -f $(BLDIR)/lib$(LIBNAME).* $(BLDIR)/$(LIBNAME).pc\n\trm -f $(PKGCFGF)\n\trm -f $(AUTODEPS)\n\t[ \"${ANDROID}\" = \"1\" ] && rm -rf android-ndk-* || true\n\nifeq (,$(findstring yes,$(CAPSTONE_BUILD_CORE_ONLY)))\n\t$(MAKE) -C cstool clean\n\t$(MAKE) -C suite/fuzz clean\nendif\n\nifdef BUILDDIR\n\trm -rf $(BUILDDIR)\nendif\n\nifeq (,$(findstring yes,$(CAPSTONE_BUILD_CORE_ONLY)))\n\t$(MAKE) -C bindings/python clean\n\t$(MAKE) -C bindings/java clean\n\t$(MAKE) -C bindings/ocaml clean\nendif\n\n\nTAG ?= HEAD\nifeq ($(TAG), HEAD)\nDIST_VERSION = latest\nelse\nDIST_VERSION = $(TAG)\nendif\n\ndist:\n\tgit archive --format=tar.gz --prefix=capstone-$(DIST_VERSION)/ $(TAG) > capstone-$(DIST_VERSION).tgz\n\tgit archive --format=zip --prefix=capstone-$(DIST_VERSION)/ $(TAG) > capstone-$(DIST_VERSION).zip\n\ncheckfuzz: fuzztest fuzzallcorp\n\nFUZZ_INPUTS = $(shell find suite/MC -type f -name '*.cs')\n\nbuildfuzz:\nifndef BUILDDIR\n\t$(MAKE) -C suite/fuzz\nelse\n\t$(MAKE) -C suite/fuzz BUILDDIR=$(BLDIR)\nendif\n\nfuzztest:\n\t./suite/fuzz/fuzz_disasm $(FUZZ_INPUTS)\n\nfuzzallcorp:\nifneq ($(wildcard suite/fuzz/corpus-libFuzzer-capstone_fuzz_disasmnext-latest),)\n\t./suite/fuzz/fuzz_bindisasm suite/fuzz/corpus-libFuzzer-capstone_fuzz_disasmnext-latest/ > fuzz_bindisasm.log || (tail -1 fuzz_bindisasm.log; false)\nelse\n\t@echo \"Skipping tests on whole corpus\"\nendif\n\n$(OBJDIR)/%.o: %.c\n\t@mkdir -p $(@D)\nifeq ($(V),0)\n\t$(call log,CC,$(@:$(OBJDIR)/%=%))\n\t@$(compile)\nelse\n\t$(compile)\nendif\n\n\nifeq ($(CAPSTONE_SHARED),yes)\ndefine install-library\n\t$(INSTALL_LIB) $(LIBRARY) $1\n\t$(if $(VERSION_EXT),\n\t\tcd $1 && \\\n\t\trm -f lib$(LIBNAME).$(EXT) && \\\n\t\tln -s lib$(LIBNAME).$(VERSION_EXT) lib$(LIBNAME).$(EXT))\nendef\nelse\ndefine install-library\nendef\nendif\n\nifeq ($(AR_FLAGS),)\nAR_FLAGS := q\nendif\n\ndefine create-archive\n\t$(AR) $(AR_FLAGS) $(ARCHIVE) $(LIBOBJ)\n\t$(RANLIB) $(ARCHIVE)\nendef\n\n\ndefine create-library\n\t$(CC) $(LDFLAGS) $($(LIBNAME)_LDFLAGS) $(LIBOBJ) -o $(LIBRARY)\nendef\n\n\ndefine generate-pkgcfg\n\tmkdir -p $(BLDIR)\n\techo 'Name: capstone' > $(PKGCFGF)\n\techo 'Description: Capstone disassembly engine' >> $(PKGCFGF)\n\techo 'Version: $(PKG_VERSION)' >> $(PKGCFGF)\n\techo 'libdir=$(LIBDIR)' >> $(PKGCFGF)\n\techo 'includedir=$(INCDIR)/capstone' >> $(PKGCFGF)\n\techo 'archive=$${libdir}/libcapstone.a' >> $(PKGCFGF)\n\techo 'Libs: -L$${libdir} -lcapstone' >> $(PKGCFGF)\n\techo 'Libs.private: -L$${libdir} -l:libcapstone.a' >> $(PKGCFGF)\n\techo 'Cflags: -I$${includedir}' >> $(PKGCFGF)\n\techo 'archs=${CAPSTONE_ARCHS}' >> $(PKGCFGF)\nendef\n"
        },
        {
          "name": "Mapping.c",
          "type": "blob",
          "size": 11.9404296875,
          "content": "/* Capstone Disassembly Engine */\n/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2019 */\n/*    Rot127 <unisono@quyllur.org>, 2022-2023 */\n\n#include \"Mapping.h\"\n#include \"capstone/capstone.h\"\n#include \"cs_priv.h\"\n#include \"utils.h\"\n\n// create a cache for fast id lookup\nstatic unsigned short *make_id2insn(const insn_map *insns, unsigned int size)\n{\n\t// NOTE: assume that the max id is always put at the end of insns array\n\tunsigned short max_id = insns[size - 1].id;\n\tunsigned int i;\n\n\tunsigned short *cache =\n\t\t(unsigned short *)cs_mem_calloc(max_id + 1, sizeof(*cache));\n\n\tfor (i = 1; i < size; i++)\n\t\tcache[insns[i].id] = i;\n\n\treturn cache;\n}\n\n// look for @id in @insns, given its size in @max. first time call will update\n// @cache. return 0 if not found\nunsigned short insn_find(const insn_map *insns, unsigned int max,\n\t\t\t unsigned int id, unsigned short **cache)\n{\n\tif (id > insns[max - 1].id)\n\t\treturn 0;\n\n\tif (*cache == NULL)\n\t\t*cache = make_id2insn(insns, max);\n\n\treturn (*cache)[id];\n}\n\n// Gives the id for the given @name if it is saved in @map.\n// Returns the id or -1 if not found.\nint name2id(const name_map *map, int max, const char *name)\n{\n\tCS_ASSERT_RET_VAL(map && name, -1);\n\tint i;\n\n\tfor (i = 0; i < max; i++) {\n\t\tif (!map[i].name) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (!strcmp(map[i].name, name)) {\n\t\t\treturn map[i].id;\n\t\t}\n\t}\n\n\t// nothing match\n\treturn -1;\n}\n\n// Gives the name for the given @id if it is saved in @map.\n// Returns the name or NULL if not found.\nconst char *id2name(const name_map *map, int max, const unsigned int id)\n{\n\tint i;\n\n\tfor (i = 0; i < max; i++) {\n\t\tif (map[i].id == id) {\n\t\t\treturn map[i].name;\n\t\t}\n\t}\n\n\t// nothing match\n\treturn NULL;\n}\n\n/// Adds a register to the implicit write register list.\n/// It will not add the same register twice.\nvoid map_add_implicit_write(MCInst *MI, uint32_t Reg)\n{\n\tif (!MI->flat_insn->detail)\n\t\treturn;\n\n\tuint16_t *regs_write = MI->flat_insn->detail->regs_write;\n\tfor (int i = 0; i < MAX_IMPL_W_REGS; ++i) {\n\t\tif (i == MI->flat_insn->detail->regs_write_count) {\n\t\t\tregs_write[i] = Reg;\n\t\t\tMI->flat_insn->detail->regs_write_count++;\n\t\t\treturn;\n\t\t}\n\t\tif (regs_write[i] == Reg)\n\t\t\treturn;\n\t}\n}\n\n/// Adds a register to the implicit read register list.\n/// It will not add the same register twice.\nvoid map_add_implicit_read(MCInst *MI, uint32_t Reg)\n{\n\tif (!MI->flat_insn->detail)\n\t\treturn;\n\n\tuint16_t *regs_read = MI->flat_insn->detail->regs_read;\n\tfor (int i = 0; i < MAX_IMPL_R_REGS; ++i) {\n\t\tif (i == MI->flat_insn->detail->regs_read_count) {\n\t\t\tregs_read[i] = Reg;\n\t\t\tMI->flat_insn->detail->regs_read_count++;\n\t\t\treturn;\n\t\t}\n\t\tif (regs_read[i] == Reg)\n\t\t\treturn;\n\t}\n}\n\n/// Removes a register from the implicit write register list.\nvoid map_remove_implicit_write(MCInst *MI, uint32_t Reg)\n{\n\tif (!MI->flat_insn->detail)\n\t\treturn;\n\n\tuint16_t *regs_write = MI->flat_insn->detail->regs_write;\n\tbool shorten_list = false;\n\tfor (int i = 0; i < MAX_IMPL_W_REGS; ++i) {\n\t\tif (shorten_list) {\n\t\t\tregs_write[i - 1] = regs_write[i];\n\t\t}\n\t\tif (i >= MI->flat_insn->detail->regs_write_count)\n\t\t\treturn;\n\n\t\tif (regs_write[i] == Reg) {\n\t\t\tMI->flat_insn->detail->regs_write_count--;\n\t\t\t// The register should exist only once in the list.\n\t\t\tCS_ASSERT_RET(!shorten_list);\n\t\t\tshorten_list = true;\n\t\t}\n\t}\n}\n\n/// Copies the implicit read registers of @imap to @MI->flat_insn.\n/// Already present registers will be preserved.\nvoid map_implicit_reads(MCInst *MI, const insn_map *imap)\n{\n#ifndef CAPSTONE_DIET\n\tif (!MI->flat_insn->detail)\n\t\treturn;\n\n\tcs_detail *detail = MI->flat_insn->detail;\n\tunsigned Opcode = MCInst_getOpcode(MI);\n\tunsigned i = 0;\n\tuint16_t reg = imap[Opcode].regs_use[i];\n\twhile (reg != 0) {\n\t\tif (i >= MAX_IMPL_R_REGS ||\n\t\t    detail->regs_read_count >= MAX_IMPL_R_REGS) {\n\t\t\tprintf(\"ERROR: Too many implicit read register defined in \"\n\t\t\t       \"instruction mapping.\\n\");\n\t\t\treturn;\n\t\t}\n\t\tdetail->regs_read[detail->regs_read_count++] = reg;\n\t\tif (i + 1 < MAX_IMPL_R_REGS) {\n\t\t\t// Select next one\n\t\t\treg = imap[Opcode].regs_use[++i];\n\t\t}\n\t}\n#endif // CAPSTONE_DIET\n}\n\n/// Copies the implicit write registers of @imap to @MI->flat_insn.\n/// Already present registers will be preserved.\nvoid map_implicit_writes(MCInst *MI, const insn_map *imap)\n{\n#ifndef CAPSTONE_DIET\n\tif (!MI->flat_insn->detail)\n\t\treturn;\n\n\tcs_detail *detail = MI->flat_insn->detail;\n\tunsigned Opcode = MCInst_getOpcode(MI);\n\tunsigned i = 0;\n\tuint16_t reg = imap[Opcode].regs_mod[i];\n\twhile (reg != 0) {\n\t\tif (i >= MAX_IMPL_W_REGS ||\n\t\t    detail->regs_write_count >= MAX_IMPL_W_REGS) {\n\t\t\tprintf(\"ERROR: Too many implicit write register defined in \"\n\t\t\t       \"instruction mapping.\\n\");\n\t\t\treturn;\n\t\t}\n\t\tdetail->regs_write[detail->regs_write_count++] = reg;\n\t\tif (i + 1 < MAX_IMPL_W_REGS) {\n\t\t\t// Select next one\n\t\t\treg = imap[Opcode].regs_mod[++i];\n\t\t}\n\t}\n#endif // CAPSTONE_DIET\n}\n\n/// Adds a given group to @MI->flat_insn.\n/// A group is never added twice.\nvoid add_group(MCInst *MI, unsigned /* arch_group */ group)\n{\n#ifndef CAPSTONE_DIET\n\tif (!MI->flat_insn->detail)\n\t\treturn;\n\n\tcs_detail *detail = MI->flat_insn->detail;\n\tif (detail->groups_count >= MAX_NUM_GROUPS) {\n\t\tprintf(\"ERROR: Too many groups defined.\\n\");\n\t\treturn;\n\t}\n\tfor (int i = 0; i < detail->groups_count; ++i) {\n\t\tif (detail->groups[i] == group) {\n\t\t\treturn;\n\t\t}\n\t}\n\tdetail->groups[detail->groups_count++] = group;\n#endif // CAPSTONE_DIET\n}\n\n/// Copies the groups from @imap to @MI->flat_insn.\n/// Already present groups will be preserved.\nvoid map_groups(MCInst *MI, const insn_map *imap)\n{\n#ifndef CAPSTONE_DIET\n\tif (!MI->flat_insn->detail)\n\t\treturn;\n\n\tcs_detail *detail = MI->flat_insn->detail;\n\tunsigned Opcode = MCInst_getOpcode(MI);\n\tunsigned i = 0;\n\tuint16_t group = imap[Opcode].groups[i];\n\twhile (group != 0) {\n\t\tif (detail->groups_count >= MAX_NUM_GROUPS) {\n\t\t\tprintf(\"ERROR: Too many groups defined in instruction mapping.\\n\");\n\t\t\treturn;\n\t\t}\n\t\tdetail->groups[detail->groups_count++] = group;\n\t\tgroup = imap[Opcode].groups[++i];\n\t}\n#endif // CAPSTONE_DIET\n}\n\n/// Returns the pointer to the supllementary information in\n/// the instruction mapping table @imap or NULL in case of failure.\nconst void *map_get_suppl_info(MCInst *MI, const insn_map *imap)\n{\n#ifndef CAPSTONE_DIET\n\tif (!MI->flat_insn->detail)\n\t\treturn NULL;\n\n\tunsigned Opcode = MCInst_getOpcode(MI);\n\treturn &imap[Opcode].suppl_info;\n#else\n\treturn NULL;\n#endif // CAPSTONE_DIET\n}\n\n// Search for the CS instruction id for the given @MC_Opcode in @imap.\n// return -1 if none is found.\nunsigned int find_cs_id(unsigned MC_Opcode, const insn_map *imap,\n\t\t\tunsigned imap_size)\n{\n\t// binary searching since the IDs are sorted in order\n\tunsigned int left, right, m;\n\tunsigned int max = imap_size;\n\n\tright = max - 1;\n\n\tif (MC_Opcode < imap[0].id || MC_Opcode > imap[right].id)\n\t\t// not found\n\t\treturn -1;\n\n\tleft = 0;\n\n\twhile (left <= right) {\n\t\tm = (left + right) / 2;\n\t\tif (MC_Opcode == imap[m].id) {\n\t\t\treturn m;\n\t\t}\n\n\t\tif (MC_Opcode < imap[m].id)\n\t\t\tright = m - 1;\n\t\telse\n\t\t\tleft = m + 1;\n\t}\n\n\treturn -1;\n}\n\n/// Sets the Capstone instruction id which maps to the @MI opcode.\n/// If no mapping is found the function returns and prints an error.\nvoid map_cs_id(MCInst *MI, const insn_map *imap, unsigned int imap_size)\n{\n\tunsigned int i = find_cs_id(MCInst_getOpcode(MI), imap, imap_size);\n\tif (i != -1) {\n\t\tMI->flat_insn->id = imap[i].mapid;\n\t\treturn;\n\t}\n\tprintf(\"ERROR: Could not find CS id for MCInst opcode: %d\\n\",\n\t       MCInst_getOpcode(MI));\n\treturn;\n}\n\n/// Returns the operand type information from the\n/// mapping table for instruction operands.\n/// Only usable by `auto-sync` archs!\nconst cs_op_type mapping_get_op_type(MCInst *MI, unsigned OpNum,\n\t\t\t\t     const map_insn_ops *insn_ops_map,\n\t\t\t\t     size_t map_size)\n{\n\tassert(MI);\n\tassert(MI->Opcode < map_size);\n\tassert(OpNum < sizeof(insn_ops_map[MI->Opcode].ops) /\n\t\t\t       sizeof(insn_ops_map[MI->Opcode].ops[0]));\n\n\treturn insn_ops_map[MI->Opcode].ops[OpNum].type;\n}\n\n/// Returns the operand access flags from the\n/// mapping table for instruction operands.\n/// Only usable by `auto-sync` archs!\nconst cs_ac_type mapping_get_op_access(MCInst *MI, unsigned OpNum,\n\t\t\t\t       const map_insn_ops *insn_ops_map,\n\t\t\t\t       size_t map_size)\n{\n\tassert(MI);\n\tassert(MI->Opcode < map_size);\n\tassert(OpNum < sizeof(insn_ops_map[MI->Opcode].ops) /\n\t\t\t       sizeof(insn_ops_map[MI->Opcode].ops[0]));\n\n\tcs_ac_type access = insn_ops_map[MI->Opcode].ops[OpNum].access;\n\tif (MCInst_opIsTied(MI, OpNum) || MCInst_opIsTying(MI, OpNum))\n\t\taccess |= (access == CS_AC_READ) ? CS_AC_WRITE : CS_AC_READ;\n\treturn access;\n}\n\n/// Returns the operand at detail->arch.operands[op_count + offset]\n/// Or NULL if detail is not set.\n#define DEFINE_get_detail_op(arch, ARCH) \\\n\tcs_##arch##_op *ARCH##_get_detail_op(MCInst *MI, int offset) \\\n\t{ \\\n\t\tif (!MI->flat_insn->detail) \\\n\t\t\treturn NULL; \\\n\t\tint OpIdx = MI->flat_insn->detail->arch.op_count + offset; \\\n\t\tassert(OpIdx >= 0 && OpIdx < MAX_MC_OPS); \\\n\t\treturn &MI->flat_insn->detail->arch.operands[OpIdx]; \\\n\t}\n\nDEFINE_get_detail_op(arm, ARM);\nDEFINE_get_detail_op(ppc, PPC);\nDEFINE_get_detail_op(tricore, TriCore);\nDEFINE_get_detail_op(aarch64, AArch64);\nDEFINE_get_detail_op(alpha, Alpha);\nDEFINE_get_detail_op(hppa, HPPA);\nDEFINE_get_detail_op(loongarch, LoongArch);\nDEFINE_get_detail_op(mips, Mips);\nDEFINE_get_detail_op(riscv, RISCV);\nDEFINE_get_detail_op(systemz, SystemZ);\nDEFINE_get_detail_op(xtensa, Xtensa);\nDEFINE_get_detail_op(bpf, BPF);\n\n/// Returns true if for this architecture the\n/// alias operands should be filled.\n/// TODO: Replace this with a proper option.\n/// \t\t\tSo it can be toggled between disas() calls.\nbool map_use_alias_details(const MCInst *MI) {\n\tassert(MI);\n\treturn (MI->csh->detail_opt & CS_OPT_ON) && !(MI->csh->detail_opt & CS_OPT_DETAIL_REAL);\n}\n\n/// Sets the setDetailOps flag to @p Val.\n/// If detail == NULLit refuses to set the flag to true.\nvoid map_set_fill_detail_ops(MCInst *MI, bool Val) {\n\tCS_ASSERT_RET(MI);\n\tif (!detail_is_set(MI)) {\n\t\tMI->fillDetailOps = false;\n\t\treturn;\n\t}\n\n\tMI->fillDetailOps = Val;\n}\n\n/// Sets the instruction alias flags and the given alias id.\nvoid map_set_is_alias_insn(MCInst *MI, bool Val, uint64_t Alias) {\n\tCS_ASSERT_RET(MI);\n\tMI->isAliasInstr = Val;\n\tMI->flat_insn->is_alias = Val;\n\tMI->flat_insn->alias_id = Alias;\n}\n\nstatic inline bool char_ends_mnem(const char c, cs_arch arch) {\n\tswitch (arch) {\n\tdefault:\n\t\treturn (!c || c == ' ' || c == '\\t' || c == '.');\n\tcase CS_ARCH_PPC:\n\t\treturn (!c || c == ' ' || c == '\\t');\n  }\n}\n\n/// Sets an alternative id for some instruction.\n/// Or -1 if it fails.\n/// You must add (<ARCH>_INS_ALIAS_BEGIN + 1) to the id to get the real id.\nvoid map_set_alias_id(MCInst *MI, const SStream *O, const name_map *alias_mnem_id_map, int map_size) {\n\tif (!MCInst_isAlias(MI))\n\t\treturn;\n\n\tchar alias_mnem[16] = { 0 };\n\tint i = 0, j = 0;\n\tconst char *asm_str_buf = O->buffer;\n\t// Skip spaces and tabs\n\twhile (is_blank_char(asm_str_buf[i])) {\n\t\tif (!asm_str_buf[i]) {\n\t\t\tMI->flat_insn->alias_id = -1;\n\t\t\treturn;\n\t\t}\n\t\t++i;\n\t}\n\tfor (; j < sizeof(alias_mnem) - 1; ++j, ++i) {\n\t\tif (char_ends_mnem(asm_str_buf[i], MI->csh->arch))\n\t\t\tbreak;\n\t\talias_mnem[j] = asm_str_buf[i];\n\t}\n\n\tMI->flat_insn->alias_id = name2id(alias_mnem_id_map, map_size, alias_mnem);\n}\n\n/// Does a binary search over the given map and searches for @id.\n/// If @id exists in @map, it sets @found to true and returns\n/// the value for the @id.\n/// Otherwise, @found is set to false and it returns UINT64_MAX.\n///\n/// Of course it assumes the map is sorted.\nuint64_t enum_map_bin_search(const cs_enum_id_map *map, size_t map_len,\n\t\t\t     const char *id, bool *found)\n{\n\tsize_t l = 0;\n\tsize_t r = map_len;\n\tsize_t id_len = strlen(id);\n\n\twhile (l <= r) {\n\t\tsize_t m = (l + r) / 2;\n\t\tsize_t j = 0;\n\t\tsize_t i = 0;\n\t\tsize_t entry_len = strlen(map[m].str);\n\n\t\twhile (j < entry_len && i < id_len && id[i] == map[m].str[j]) {\n\t\t\t++j, ++i;\n\t\t}\n\t\tif (i == id_len && j == entry_len) {\n\t\t\t*found = true;\n\t\t\treturn map[m].val;\n\t\t}\n\n\t\tif (id[i] < map[m].str[j]) {\n\t\t\tr = m - 1;\n\t\t} else if (id[i] > map[m].str[j]) {\n\t\t\tl = m + 1;\n\t\t}\n\t\tif ((m == 0 && id[i] < map[m].str[j]) || (l + r) / 2 >= map_len) {\n\t\t\t// Break before we go out of bounds.\n\t\t\tbreak;\n\t\t}\n\t}\n\t*found = false;\n\treturn UINT64_MAX;\n}\n\n"
        },
        {
          "name": "Mapping.h",
          "type": "blob",
          "size": 9.0341796875,
          "content": "/* Capstone Disassembly Engine */\n/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2019 */\n/*    Rot127 <unisono@quyllur.org>, 2022-2023 */\n\n#ifndef CS_MAPPING_H\n#define CS_MAPPING_H\n\n#if defined(CAPSTONE_HAS_OSXKERNEL)\n#include <libkern/libkern.h>\n#else\n#include \"include/capstone/capstone.h\"\n#include <stddef.h>\n#endif\n#include \"cs_priv.h\"\n#include <assert.h>\n#include <string.h>\n\n// map instruction to its characteristics\ntypedef struct insn_map {\n\tunsigned short id;\t\t    // The LLVM instruction id\n\tunsigned short mapid;\t\t    // The Capstone instruction id\n#ifndef CAPSTONE_DIET\n\tuint16_t regs_use[MAX_IMPL_R_REGS]; ///< list of implicit registers used by\n\t\t\t\t\t    ///< this instruction\n\tuint16_t regs_mod[MAX_IMPL_W_REGS]; ///< list of implicit registers modified\n\t\t\t\t\t    ///< by this instruction\n\tunsigned char groups\n\t\t[MAX_NUM_GROUPS]; ///< list of group this instruction belong to\n\tbool branch;\t\t  // branch instruction?\n\tbool indirect_branch;\t  // indirect branch instruction?\n\tunion {\n\t\tppc_suppl_info ppc;\n\t\tloongarch_suppl_info loongarch;\n\t\taarch64_suppl_info aarch64;\n\t\tsystemz_suppl_info systemz;\n\t\tarm_suppl_info arm;\n\t\txtensa_suppl_info xtensa;\n\t} suppl_info; // Supplementary information for each instruction.\n#endif\n} insn_map;\n\n// look for @id in @m, given its size in @max. first time call will update\n// @cache. return 0 if not found\nunsigned short insn_find(const insn_map *m, unsigned int max, unsigned int id,\n\t\t\t unsigned short **cache);\n\nunsigned int find_cs_id(unsigned MC_Opcode, const insn_map *imap,\n\t\t\tunsigned imap_size);\n\n#define MAX_NO_DATA_TYPES 16\n\n///< A LLVM<->CS Mapping entry of an MCOperand.\ntypedef struct {\n\tuint8_t /* cs_op_type */ type;\t ///< Operand type (e.g.: reg, imm, mem)\n\tuint8_t /* cs_ac_type */ access; ///< The access type (read, write)\n\tuint8_t\t\t\t\t /* cs_data_type */\n\t\tdtypes[MAX_NO_DATA_TYPES]; ///< List of op types. Terminated by\n\t\t\t\t\t   ///< CS_DATA_TYPE_LAST\n} mapping_op;\n\n#define MAX_NO_INSN_MAP_OPS 16\n\n///< MCOperands of an instruction.\ntypedef struct {\n\tmapping_op\n\t\tops[MAX_NO_INSN_MAP_OPS]; ///< NULL terminated array of insn_op.\n} map_insn_ops;\n\n/// Only usable by `auto-sync` archs!\nconst cs_op_type mapping_get_op_type(MCInst *MI, unsigned OpNum,\n\t\t\t\t     const map_insn_ops *insn_ops_map,\n\t\t\t\t     size_t map_size);\n\n/// Only usable by `auto-sync` archs!\nconst cs_ac_type mapping_get_op_access(MCInst *MI, unsigned OpNum,\n\t\t\t\t       const map_insn_ops *insn_ops_map,\n\t\t\t\t       size_t map_size);\n\n/// Macro for easier access of operand types from the map.\n/// Assumes the istruction operands map is called \"insn_operands\"\n/// Only usable by `auto-sync` archs!\n#ifndef CAPSTONE_DIET\n#define map_get_op_type(MI, OpNum) \\\n\tmapping_get_op_type(MI, OpNum, (const map_insn_ops *)insn_operands, \\\n\t\t\t    sizeof(insn_operands) / sizeof(insn_operands[0]))\n#else\n#define map_get_op_type(MI, OpNum) \\\n\tCS_OP_INVALID\n#endif\n\n/// Macro for easier access of operand access flags from the map.\n/// Assumes the istruction operands map is called \"insn_operands\"\n/// Only usable by `auto-sync` archs!\n#ifndef CAPSTONE_DIET\n#define map_get_op_access(MI, OpNum) \\\n\tmapping_get_op_access(MI, OpNum, (const map_insn_ops *)insn_operands, \\\n\t\t\t      sizeof(insn_operands) / \\\n\t\t\t\t      sizeof(insn_operands[0]))\n#else\n#define map_get_op_access(MI, OpNum) \\\n\tCS_AC_INVALID\n#endif\n\n///< Map for ids to their string\ntypedef struct name_map {\n\tunsigned int id;\n\tconst char *name;\n} name_map;\n\n// map a name to its ID\n// return 0 if not found\nint name2id(const name_map *map, int max, const char *name);\n\n// map ID to a name\n// return NULL if not found\nconst char *id2name(const name_map *map, int max, const unsigned int id);\n\nvoid map_add_implicit_write(MCInst *MI, uint32_t Reg);\nvoid map_add_implicit_read(MCInst *MI, uint32_t Reg);\nvoid map_remove_implicit_write(MCInst *MI, uint32_t Reg);\n\nvoid map_implicit_reads(MCInst *MI, const insn_map *imap);\n\nvoid map_implicit_writes(MCInst *MI, const insn_map *imap);\n\nvoid add_group(MCInst *MI, unsigned /* arch_group */ group);\n\nvoid map_groups(MCInst *MI, const insn_map *imap);\n\nvoid map_cs_id(MCInst *MI, const insn_map *imap, unsigned int imap_size);\n\nconst void *map_get_suppl_info(MCInst *MI, const insn_map *imap);\n\n#define DECL_get_detail_op(arch, ARCH) \\\n\tcs_##arch##_op *ARCH##_get_detail_op(MCInst *MI, int offset);\n\nDECL_get_detail_op(arm, ARM);\nDECL_get_detail_op(ppc, PPC);\nDECL_get_detail_op(tricore, TriCore);\nDECL_get_detail_op(aarch64, AArch64);\nDECL_get_detail_op(alpha, Alpha);\nDECL_get_detail_op(hppa, HPPA);\nDECL_get_detail_op(loongarch, LoongArch);\nDECL_get_detail_op(mips, Mips);\nDECL_get_detail_op(riscv, RISCV);\nDECL_get_detail_op(systemz, SystemZ);\nDECL_get_detail_op(xtensa, Xtensa);\nDECL_get_detail_op(bpf, BPF);\n\n/// Increments the detail->arch.op_count by one.\n#define DEFINE_inc_detail_op_count(arch, ARCH) \\\n\tstatic inline void ARCH##_inc_op_count(MCInst *MI) \\\n\t{ \\\n\t\tMI->flat_insn->detail->arch.op_count++; \\\n\t}\n\n/// Decrements the detail->arch.op_count by one.\n#define DEFINE_dec_detail_op_count(arch, ARCH) \\\n\tstatic inline void ARCH##_dec_op_count(MCInst *MI) \\\n\t{ \\\n\t\tMI->flat_insn->detail->arch.op_count--; \\\n\t}\n\nDEFINE_inc_detail_op_count(arm, ARM);\nDEFINE_dec_detail_op_count(arm, ARM);\nDEFINE_inc_detail_op_count(ppc, PPC);\nDEFINE_dec_detail_op_count(ppc, PPC);\nDEFINE_inc_detail_op_count(tricore, TriCore);\nDEFINE_dec_detail_op_count(tricore, TriCore);\nDEFINE_inc_detail_op_count(aarch64, AArch64);\nDEFINE_dec_detail_op_count(aarch64, AArch64);\nDEFINE_inc_detail_op_count(alpha, Alpha);\nDEFINE_dec_detail_op_count(alpha, Alpha);\nDEFINE_inc_detail_op_count(hppa, HPPA);\nDEFINE_dec_detail_op_count(hppa, HPPA);\nDEFINE_inc_detail_op_count(loongarch, LoongArch);\nDEFINE_dec_detail_op_count(loongarch, LoongArch);\nDEFINE_inc_detail_op_count(mips, Mips);\nDEFINE_dec_detail_op_count(mips, Mips);\nDEFINE_inc_detail_op_count(riscv, RISCV);\nDEFINE_dec_detail_op_count(riscv, RISCV);\nDEFINE_inc_detail_op_count(systemz, SystemZ);\nDEFINE_dec_detail_op_count(systemz, SystemZ);\nDEFINE_inc_detail_op_count(xtensa, Xtensa);\nDEFINE_dec_detail_op_count(xtensa, Xtensa);\nDEFINE_inc_detail_op_count(bpf, BPF);\nDEFINE_dec_detail_op_count(bpf, BPF);\n\n/// Returns true if a memory operand is currently edited.\nstatic inline bool doing_mem(const MCInst *MI)\n{\n\treturn MI->csh->doing_mem;\n}\n\n/// Sets the doing_mem flag to @status.\nstatic inline void set_doing_mem(const MCInst *MI, bool status)\n{\n\tMI->csh->doing_mem = status;\n}\n\n/// Returns detail->arch\n#define DEFINE_get_arch_detail(arch, ARCH) \\\n\tstatic inline cs_##arch *ARCH##_get_detail(const MCInst *MI) \\\n\t{ \\\n\t\tassert(MI && MI->flat_insn && MI->flat_insn->detail); \\\n\t\treturn &MI->flat_insn->detail->arch; \\\n\t}\n\nDEFINE_get_arch_detail(arm, ARM);\nDEFINE_get_arch_detail(ppc, PPC);\nDEFINE_get_arch_detail(tricore, TriCore);\nDEFINE_get_arch_detail(aarch64, AArch64);\nDEFINE_get_arch_detail(alpha, Alpha);\nDEFINE_get_arch_detail(hppa, HPPA);\nDEFINE_get_arch_detail(loongarch, LoongArch);\nDEFINE_get_arch_detail(mips, Mips);\nDEFINE_get_arch_detail(riscv, RISCV);\nDEFINE_get_arch_detail(systemz, SystemZ);\nDEFINE_get_arch_detail(xtensa, Xtensa);\nDEFINE_get_arch_detail(bpf, BPF);\n\n#define DEFINE_check_safe_inc(Arch, ARCH) \\\n\tstatic inline void Arch##_check_safe_inc(const MCInst *MI) { \\\n\t\tassert(Arch##_get_detail(MI)->op_count + 1 < NUM_##ARCH##_OPS); \\\n\t}\n\nDEFINE_check_safe_inc(ARM, ARM);\nDEFINE_check_safe_inc(PPC, PPC);\nDEFINE_check_safe_inc(TriCore, TRICORE);\nDEFINE_check_safe_inc(AArch64, AARCH64);\nDEFINE_check_safe_inc(Alpha, ALPHA);\nDEFINE_check_safe_inc(HPPA, HPPA);\nDEFINE_check_safe_inc(LoongArch, LOONGARCH);\nDEFINE_check_safe_inc(RISCV, RISCV);\nDEFINE_check_safe_inc(SystemZ, SYSTEMZ);\nDEFINE_check_safe_inc(Mips, MIPS);\nDEFINE_check_safe_inc(BPF, BPF);\n\nstatic inline bool detail_is_set(const MCInst *MI)\n{\n\tassert(MI && MI->flat_insn);\n\treturn MI->flat_insn->detail != NULL && MI->csh->detail_opt & CS_OPT_ON;\n}\n\nstatic inline cs_detail *get_detail(const MCInst *MI)\n{\n\tassert(MI && MI->flat_insn);\n\treturn MI->flat_insn->detail;\n}\n\n/// Returns if the given instruction is an alias instruction.\n#define RETURN_IF_INSN_IS_ALIAS(MI) \\\ndo { \\\n\tif (MI->isAliasInstr) \\\n\t\treturn; \\\n} while(0)\n\nvoid map_set_fill_detail_ops(MCInst *MI, bool Val);\n\nstatic inline bool map_fill_detail_ops(MCInst *MI) {\n\tassert(MI);\n\treturn MI->fillDetailOps;\n}\n\nvoid map_set_is_alias_insn(MCInst *MI, bool Val, uint64_t Alias);\n\nbool map_use_alias_details(const MCInst *MI);\n\nvoid map_set_alias_id(MCInst *MI, const SStream *O, const name_map *alias_mnem_id_map, int map_size);\n\n/// Mapping from Capstone enumeration identifiers and their values.\n///\n/// This map MUST BE sorted to allow binary searches.\n/// Please always ensure the map is sorted after you added a value.\n///\n/// You can sort the map with Python.\n/// Copy the map into a file and run:\n///\n/// ```python\n/// with open(\"/tmp/file_with_map_entries\") as f:\n///     text = f.readlines()\n///\n/// text.sort()\n/// print(''.join(text))\n/// ```\ntypedef struct {\n\tconst char *str; ///< The name of the enumeration identifier\n\tuint64_t val;\t ///< The value of the identifier\n} cs_enum_id_map;\n\nuint64_t enum_map_bin_search(const cs_enum_id_map *map, size_t map_len,\n\t\t\t     const char *id, bool *found);\n\n#endif // CS_MAPPING_H\n"
        },
        {
          "name": "MathExtras.h",
          "type": "blob",
          "size": 15.404296875,
          "content": "//===-- llvm/Support/MathExtras.h - Useful math functions -------*- C++ -*-===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains some functions that are useful for math stuff.\n//\n//===----------------------------------------------------------------------===//\n\n/* Capstone Disassembly Engine */\n/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2019 */\n\n#ifndef CS_LLVM_SUPPORT_MATHEXTRAS_H\n#define CS_LLVM_SUPPORT_MATHEXTRAS_H\n\n#if defined(_WIN32_WCE) && (_WIN32_WCE < 0x800)\n#include \"windowsce/intrin.h\"\n#elif defined(_MSC_VER)\n#include <intrin.h>\n#endif\n\n#ifndef __cplusplus\n#ifdef _MSC_VER\n#define inline /* inline */\n#endif\n#endif\n\n#include <limits.h>\n\n// NOTE: The following support functions use the _32/_64 extensions instead of\n// type overloading so that signed and unsigned integers can be used without\n// ambiguity.\n\n/// Hi_32 - This function returns the high 32 bits of a 64 bit value.\nstatic inline uint32_t Hi_32(uint64_t Value) {\n\treturn (uint32_t)(Value >> 32);\n}\n\n/// Lo_32 - This function returns the low 32 bits of a 64 bit value.\nstatic inline uint32_t Lo_32(uint64_t Value) {\n\treturn (uint32_t)(Value);\n}\n\n/// isUIntN - Checks if an unsigned integer fits into the given (dynamic)\n/// bit width.\nstatic inline bool isUIntN(unsigned N, uint64_t x) {\n\treturn x == (x & (~0ULL >> (64 - N)));\n}\n\n/// isIntN - Checks if an signed integer fits into the given (dynamic)\n/// bit width.\nstatic inline bool isIntN(unsigned N, int64_t x) {\n  return N >= 64 || (-(INT64_C(1)<<(N-1)) <= x && x < (INT64_C(1)<<(N-1)));\n}\n\n/// isMask_32 - This function returns true if the argument is a sequence of ones\n/// starting at the least significant bit with the remainder zero (32 bit\n/// version).   Ex. isMask_32(0x0000FFFFU) == true.\nstatic inline bool isMask_32(uint32_t Value) {\n\treturn Value && ((Value + 1) & Value) == 0;\n}\n\n/// isMask_64 - This function returns true if the argument is a sequence of ones\n/// starting at the least significant bit with the remainder zero (64 bit\n/// version).\nstatic inline bool isMask_64(uint64_t Value) {\n\treturn Value && ((Value + 1) & Value) == 0;\n}\n\n/// isShiftedMask_32 - This function returns true if the argument contains a\n/// sequence of ones with the remainder zero (32 bit version.)\n/// Ex. isShiftedMask_32(0x0000FF00U) == true.\nstatic inline bool isShiftedMask_32(uint32_t Value) {\n\treturn isMask_32((Value - 1) | Value);\n}\n\n/// isShiftedMask_64 - This function returns true if the argument contains a\n/// sequence of ones with the remainder zero (64 bit version.)\nstatic inline bool isShiftedMask_64(uint64_t Value) {\n\treturn isMask_64((Value - 1) | Value);\n}\n\n/// isPowerOf2_32 - This function returns true if the argument is a power of\n/// two > 0. Ex. isPowerOf2_32(0x00100000U) == true (32 bit edition.)\nstatic inline bool isPowerOf2_32(uint32_t Value) {\n\treturn Value && !(Value & (Value - 1));\n}\n\n/// CountLeadingZeros_32 - this function performs the platform optimal form of\n/// counting the number of zeros from the most significant bit to the first one\n/// bit.  Ex. CountLeadingZeros_32(0x00F000FF) == 8.\n/// Returns 32 if the word is zero.\nstatic inline unsigned CountLeadingZeros_32(uint32_t Value) {\n\tunsigned Count; // result\n#if __GNUC__ >= 4\n\t// PowerPC is defined for __builtin_clz(0)\n#if !defined(__ppc__) && !defined(__ppc64__)\n\tif (!Value) return 32;\n#endif\n\tCount = __builtin_clz(Value);\n#else\n\tunsigned Shift;\n\tif (!Value) return 32;\n\tCount = 0;\n\t// bisection method for count leading zeros\n\tfor (Shift = 32 >> 1; Shift; Shift >>= 1) {\n\t\tuint32_t Tmp = Value >> Shift;\n\t\tif (Tmp) {\n\t\t\tValue = Tmp;\n\t\t} else {\n\t\t\tCount |= Shift;\n\t\t}\n\t}\n#endif\n\treturn Count;\n}\n\n/// CountLeadingOnes_32 - this function performs the operation of\n/// counting the number of ones from the most significant bit to the first zero\n/// bit.  Ex. CountLeadingOnes_32(0xFF0FFF00) == 8.\n/// Returns 32 if the word is all ones.\nstatic inline unsigned CountLeadingOnes_32(uint32_t Value) {\n\treturn CountLeadingZeros_32(~Value);\n}\n\n/// CountLeadingZeros_64 - This function performs the platform optimal form\n/// of counting the number of zeros from the most significant bit to the first\n/// one bit (64 bit edition.)\n/// Returns 64 if the word is zero.\nstatic inline unsigned CountLeadingZeros_64(uint64_t Value) {\n\tunsigned Count; // result\n#if __GNUC__ >= 4\n\t// PowerPC is defined for __builtin_clzll(0)\n#if !defined(__ppc__) && !defined(__ppc64__)\n\tif (!Value) return 64;\n#endif\n\tCount = __builtin_clzll(Value);\n#else\n#ifndef _MSC_VER\n\tunsigned Shift;\n\tif (sizeof(long) == sizeof(int64_t))\n\t{\n\t\tif (!Value) return 64;\n\t\tCount = 0;\n\t\t// bisection method for count leading zeros\n\t\tfor (Shift = 64 >> 1; Shift; Shift >>= 1) {\n\t\t\tuint64_t Tmp = Value >> Shift;\n\t\t\tif (Tmp) {\n\t\t\t\tValue = Tmp;\n\t\t\t} else {\n\t\t\t\tCount |= Shift;\n\t\t\t}\n\t\t}\n\t}\n\telse\n#endif\n\t{\n\t\t// get hi portion\n\t\tuint32_t Hi = Hi_32(Value);\n\n\t\t// if some bits in hi portion\n\t\tif (Hi) {\n\t\t\t// leading zeros in hi portion plus all bits in lo portion\n\t\t\tCount = CountLeadingZeros_32(Hi);\n\t\t} else {\n\t\t\t// get lo portion\n\t\t\tuint32_t Lo = Lo_32(Value);\n\t\t\t// same as 32 bit value\n\t\t\tCount = CountLeadingZeros_32(Lo)+32;\n\t\t}\n\t}\n#endif\n\treturn Count;\n}\n\n/// CountLeadingOnes_64 - This function performs the operation\n/// of counting the number of ones from the most significant bit to the first\n/// zero bit (64 bit edition.)\n/// Returns 64 if the word is all ones.\nstatic inline unsigned CountLeadingOnes_64(uint64_t Value) {\n\treturn CountLeadingZeros_64(~Value);\n}\n\n/// CountTrailingZeros_32 - this function performs the platform optimal form of\n/// counting the number of zeros from the least significant bit to the first one\n/// bit.  Ex. CountTrailingZeros_32(0xFF00FF00) == 8.\n/// Returns 32 if the word is zero.\nstatic inline unsigned CountTrailingZeros_32(uint32_t Value) {\n#if __GNUC__ >= 4\n\treturn Value ? __builtin_ctz(Value) : 32;\n#else\n\tstatic const unsigned Mod37BitPosition[] = {\n\t\t32, 0, 1, 26, 2, 23, 27, 0, 3, 16, 24, 30, 28, 11, 0, 13,\n\t\t4, 7, 17, 0, 25, 22, 31, 15, 29, 10, 12, 6, 0, 21, 14, 9,\n\t\t5, 20, 8, 19, 18\n\t};\n\t// Replace \"-Value\" by \"1+~Value\" in the following commented code to avoid \n\t// MSVC warning C4146\n\t//    return Mod37BitPosition[(-Value & Value) % 37];\n\treturn Mod37BitPosition[((1 + ~Value) & Value) % 37];\n#endif\n}\n\n// Count trailing zeros as in:\n// https://graphics.stanford.edu/~seander/bithacks.html#ZerosOnRightParallel\nstatic inline unsigned CountTrailingZeros_8(uint8_t Value) {\n\tuint8_t c = 8;\n\tValue &= -((int8_t)Value);\n\tif (Value) c--;\n\tif (Value & 0x0F) c -= 4;\n\tif (Value & 0x33) c -= 2;\n\tif (Value & 0x55) c -= 1;\n\treturn c;\n}\n\n/// CountTrailingOnes_32 - this function performs the operation of\n/// counting the number of ones from the least significant bit to the first zero\n/// bit.  Ex. CountTrailingOnes_32(0x00FF00FF) == 8.\n/// Returns 32 if the word is all ones.\nstatic inline unsigned CountTrailingOnes_32(uint32_t Value) {\n\treturn CountTrailingZeros_32(~Value);\n}\n\n/// CountTrailingZeros_64 - This function performs the platform optimal form\n/// of counting the number of zeros from the least significant bit to the first\n/// one bit (64 bit edition.)\n/// Returns 64 if the word is zero.\nstatic inline unsigned CountTrailingZeros_64(uint64_t Value) {\n#if __GNUC__ >= 4\n\treturn Value ? __builtin_ctzll(Value) : 64;\n#else\n\tstatic const unsigned Mod67Position[] = {\n\t\t64, 0, 1, 39, 2, 15, 40, 23, 3, 12, 16, 59, 41, 19, 24, 54,\n\t\t4, 64, 13, 10, 17, 62, 60, 28, 42, 30, 20, 51, 25, 44, 55,\n\t\t47, 5, 32, 65, 38, 14, 22, 11, 58, 18, 53, 63, 9, 61, 27,\n\t\t29, 50, 43, 46, 31, 37, 21, 57, 52, 8, 26, 49, 45, 36, 56,\n\t\t7, 48, 35, 6, 34, 33, 0\n\t};\n\t// Replace \"-Value\" by \"1+~Value\" in the following commented code to avoid \n\t// MSVC warning C4146\n\t//    return Mod67Position[(-Value & Value) % 67];\n\treturn Mod67Position[((1 + ~Value) & Value) % 67];\n#endif\n}\n\n/// CountTrailingOnes_64 - This function performs the operation\n/// of counting the number of ones from the least significant bit to the first\n/// zero bit (64 bit edition.)\n/// Returns 64 if the word is all ones.\nstatic inline unsigned CountTrailingOnes_64(uint64_t Value) {\n\treturn CountTrailingZeros_64(~Value);\n}\n\n/// CountPopulation_32 - this function counts the number of set bits in a value.\n/// Ex. CountPopulation(0xF000F000) = 8\n/// Returns 0 if the word is zero.\nstatic inline unsigned CountPopulation_32(uint32_t Value) {\n#if __GNUC__ >= 4\n\treturn __builtin_popcount(Value);\n#else\n\tuint32_t v = Value - ((Value >> 1) & 0x55555555);\n\tv = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n\treturn (((v + (v >> 4)) & 0xF0F0F0F) * 0x1010101) >> 24;\n#endif\n}\n\n/// CountPopulation_64 - this function counts the number of set bits in a value,\n/// (64 bit edition.)\nstatic inline unsigned CountPopulation_64(uint64_t Value) {\n#if __GNUC__ >= 4\n\treturn __builtin_popcountll(Value);\n#else\n\tuint64_t v = Value - ((Value >> 1) & 0x5555555555555555ULL);\n\tv = (v & 0x3333333333333333ULL) + ((v >> 2) & 0x3333333333333333ULL);\n\tv = (v + (v >> 4)) & 0x0F0F0F0F0F0F0F0FULL;\n\treturn (uint64_t)((v * 0x0101010101010101ULL) >> 56);\n#endif\n}\n\n/// Log2_32 - This function returns the floor log base 2 of the specified value,\n/// UINT_MAX if the value is zero. (32 bit edition.)\n/// Ex. Log2_32(32) == 5, Log2_32(1) == 0, Log2_32(0) == -1, Log2_32(6) == 2\nstatic inline unsigned Log2_32(uint32_t Value) {\n\tif (Value == 0) {\n\t\treturn UINT_MAX;\n\t}\n\treturn 31 - CountLeadingZeros_32(Value);\n}\n\n/// Log2_64 - This function returns the floor log base 2 of the specified value,\n/// UINT_MAX if the value is zero. (64 bit edition.)\nstatic inline unsigned Log2_64(uint64_t Value) {\n\tif (Value == 0) {\n\t\treturn UINT32_MAX;\n\t}\n\treturn 63 - CountLeadingZeros_64(Value);\n}\n\n/// Log2_32_Ceil - This function returns the ceil log base 2 of the specified\n/// value, 32 if the value is zero. (32 bit edition).\n/// Ex. Log2_32_Ceil(32) == 5, Log2_32_Ceil(1) == 0, Log2_32_Ceil(6) == 3\nstatic inline unsigned Log2_32_Ceil(uint32_t Value) {\n\treturn 32-CountLeadingZeros_32(Value-1);\n}\n\n/// Log2_64_Ceil - This function returns the ceil log base 2 of the specified\n/// value, 64 if the value is zero. (64 bit edition.)\nstatic inline unsigned Log2_64_Ceil(uint64_t Value) {\n\treturn 64-CountLeadingZeros_64(Value-1);\n}\n\n/// GreatestCommonDivisor64 - Return the greatest common divisor of the two\n/// values using Euclid's algorithm.\nstatic inline uint64_t GreatestCommonDivisor64(uint64_t A, uint64_t B) {\n\twhile (B) {\n\t\tuint64_t T = B;\n\t\tB = A % B;\n\t\tA = T;\n\t}\n\treturn A;\n}\n\n/// BitsToDouble - This function takes a 64-bit integer and returns the bit\n/// equivalent double.\nstatic inline double BitsToDouble(uint64_t Bits) {\n\tunion {\n\t\tuint64_t L;\n\t\tdouble D;\n\t} T;\n\tT.L = Bits;\n\treturn T.D;\n}\n\n/// BitsToFloat - This function takes a 32-bit integer and returns the bit\n/// equivalent float.\nstatic inline float BitsToFloat(uint32_t Bits) {\n\tunion {\n\t\tuint32_t I;\n\t\tfloat F;\n\t} T;\n\tT.I = Bits;\n\treturn T.F;\n}\n\n/// DoubleToBits - This function takes a double and returns the bit\n/// equivalent 64-bit integer.  Note that copying doubles around\n/// changes the bits of NaNs on some hosts, notably x86, so this\n/// routine cannot be used if these bits are needed.\nstatic inline uint64_t DoubleToBits(double Double) {\n\tunion {\n\t\tuint64_t L;\n\t\tdouble D;\n\t} T;\n\tT.D = Double;\n\treturn T.L;\n}\n\n/// FloatToBits - This function takes a float and returns the bit\n/// equivalent 32-bit integer.  Note that copying floats around\n/// changes the bits of NaNs on some hosts, notably x86, so this\n/// routine cannot be used if these bits are needed.\nstatic inline uint32_t FloatToBits(float Float) {\n\tunion {\n\t\tuint32_t I;\n\t\tfloat F;\n\t} T;\n\tT.F = Float;\n\treturn T.I;\n}\n\n/// MinAlign - A and B are either alignments or offsets.  Return the minimum\n/// alignment that may be assumed after adding the two together.\nstatic inline uint64_t MinAlign(uint64_t A, uint64_t B) {\n\t// The largest power of 2 that divides both A and B.\n\t//\n\t// Replace \"-Value\" by \"1+~Value\" in the following commented code to avoid \n\t// MSVC warning C4146\n\t//    return (A | B) & -(A | B);\n\treturn (A | B) & (1 + ~(A | B));\n}\n\n/// NextPowerOf2 - Returns the next power of two (in 64-bits)\n/// that is strictly greater than A.  Returns zero on overflow.\nstatic inline uint64_t NextPowerOf2(uint64_t A) {\n\tA |= (A >> 1);\n\tA |= (A >> 2);\n\tA |= (A >> 4);\n\tA |= (A >> 8);\n\tA |= (A >> 16);\n\tA |= (A >> 32);\n\treturn A + 1;\n}\n\n/// Returns the next integer (mod 2**64) that is greater than or equal to\n/// \\p Value and is a multiple of \\p Align. \\p Align must be non-zero.\n///\n/// Examples:\n/// \\code\n///   RoundUpToAlignment(5, 8) = 8\n///   RoundUpToAlignment(17, 8) = 24\n///   RoundUpToAlignment(~0LL, 8) = 0\n/// \\endcode\nstatic inline uint64_t RoundUpToAlignment(uint64_t Value, uint64_t Align) {\n\treturn ((Value + Align - 1) / Align) * Align;\n}\n\n/// Returns the offset to the next integer (mod 2**64) that is greater than\n/// or equal to \\p Value and is a multiple of \\p Align. \\p Align must be\n/// non-zero.\nstatic inline uint64_t OffsetToAlignment(uint64_t Value, uint64_t Align) {\n\treturn RoundUpToAlignment(Value, Align) - Value;\n}\n\n/// abs64 - absolute value of a 64-bit int.  Not all environments support\n/// \"abs\" on whatever their name for the 64-bit int type is.  The absolute\n/// value of the largest negative number is undefined, as with \"abs\".\nstatic inline int64_t abs64(int64_t x) {\n\treturn (x < 0) ? -x : x;\n}\n\n/// \\brief Sign extend number in the bottom B bits of X to a 32-bit int.\n/// Requires 0 < B <= 32.\n/// Note that this implementation relies on right shift of signed\n/// integers being an arithmetic shift.\nstatic inline int32_t SignExtend32(uint32_t X, unsigned B) {\n\treturn (int32_t)(X << (32 - B)) >> (32 - B);\n}\n\n/// \\brief Sign extend number in the bottom B bits of X to a 64-bit int.\n/// Requires 0 < B <= 64.\n/// Note that this implementation relies on right shift of signed\n/// integers being an arithmetic shift.\nstatic inline int64_t SignExtend64(uint64_t X, unsigned B) {\n\treturn (int64_t)(X << (64 - B)) >> (64 - B);\n}\n\n/// \\brief Removes the rightmost bit of x and extends the field to the left with that\n/// bit to form a 64-bit quantity. The field is of size len\nstatic inline int64_t LowSignExtend64(uint64_t x, unsigned len) {\n    return (x >> 1) - ((x & 1) << (len - 1));\n}\n\n/// \\brief One extend number X starting at bit B and returns it as int32_t.\n/// Requires 0 < B <= 32.\nstatic inline int32_t OneExtend32(uint32_t X, unsigned B) {\n\treturn (~0U << B) | X;\n}\n\n/// \\brief One extend number X starting at bit B and returns it as int64_t.\n/// Requires 0 < B <= 64.\nstatic inline int64_t OneExtend64(uint64_t X, unsigned B) {\n\treturn (~0ULL << B) | X;\n}\n\n/// \\brief Count number of 0's from the most significant bit to the least\n///   stopping at the first 1.\n///\n/// Only unsigned integral types are allowed.\n///\n/// \\param ZB the behavior on an input of 0. Only ZB_Width and ZB_Undefined are\n///   valid arguments.\nstatic inline unsigned int countLeadingZeros(int x)\n{\n\tint i;\n\tconst unsigned bits = sizeof(x) * 8;\n\tunsigned count = bits;\n\n\tif (x < 0) {\n\t\treturn 0;\n\t}\n\tfor (i = bits; --i; ) {\n\t\tif (x == 0) break;\n\t\tcount--;\n\t\tx >>= 1;\n\t}\n\n\treturn count;\n}\n\n/// \\brief Get specified field from 32-bit instruction. Returns bits from the segment [from, to]\nstatic inline uint32_t get_insn_field(uint32_t insn, uint8_t from, uint8_t to) \n{\n\treturn insn >> (31 - to) & ((1 << (to - from + 1)) - 1);\n}\n\n/// \\brief Get specified bit from 32-bit instruction\nstatic inline uint32_t get_insn_bit(uint32_t insn, uint8_t bit) \n{\n\treturn get_insn_field(insn, bit, bit);\n}\n\n#endif\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.9541015625,
          "content": "Capstone Engine\n===============\n\n[![Build status](https://ci.appveyor.com/api/projects/status/a4wvbn89wu3pinas/branch/next?svg=true)](https://ci.appveyor.com/project/aquynh/capstone/branch/next)\n[![pypi package](https://badge.fury.io/py/capstone.svg)](https://pypi.python.org/pypi/capstone)\n[![pypi downloads](https://pepy.tech/badge/capstone)](https://pepy.tech/project/capstone)\n[![oss-fuzz Status](https://oss-fuzz-build-logs.storage.googleapis.com/badges/capstone.svg)](https://bugs.chromium.org/p/oss-fuzz/issues/list?sort=-opened&can=1&q=proj:capstone)\n\n> [!TIP]\n> Welcome to join our community group!\n> &ensp; [<img src=\"https://img.shields.io/badge/Telegram-2CA5E0?style=flat-squeare&logo=telegram&logoColor=white\" height=\"22\" />](https://t.me/CapstoneEngine)\n\nCapstone is a disassembly framework with the target of becoming the ultimate\ndisasm engine for binary analysis and reversing in the security community.\n\nCreated by Nguyen Anh Quynh, then developed and maintained by a small community,\nCapstone offers some unparalleled features:\n\n- Support multiple hardware architectures: ARM, AArch64, Alpha, BPF, Ethereum VM,\n  LoongArch, HP PA-RISC (HPPA), M68K, M680X, Mips, MOS65XX, PPC, RISC-V(rv32G/rv64G), SH,\n  Sparc, SystemZ, TMS320C64X, TriCore, Webassembly, XCore and X86 (16, 32, 64), Xtensa.\n\n- Having clean/simple/lightweight/intuitive architecture-neutral API.\n\n- Provide details on disassembled instruction (called “decomposer” by others).\n\n- Provide semantics of the disassembled instruction, such as list of implicit\n  registers read & written.\n\n- Implemented in pure C language, with lightweight bindings for Swift, D, Clojure, F#,\n  Common Lisp, Visual Basic, PHP, PowerShell, Emacs, Haskell, Perl, Python,\n  Ruby, C#, NodeJS, Java, GO, C++, OCaml, Lua, Rust, Delphi, Free Pascal & Vala\n  ready either in main code, or provided externally by the community).\n\n- Native support for all popular platforms: Windows, Mac OSX, iOS, Android,\n  Linux, \\*BSD, Solaris, etc.\n\n- Thread-safe by design.\n\n- Special support for embedding into firmware or OS kernel.\n\n- High performance & suitable for malware analysis (capable of handling various\n  X86 malware tricks).\n\n- Distributed under the open source BSD license.\n\nFurther information is available at https://www.capstone-engine.org\n\n\nCompile\n-------\n\nSee [BUILDING.md](BUILDING.md) file for how to compile and install Capstone.\n\n\nDocumentation\n-------------\n\n- Useful links and tutorials: [docs/README](docs/README)\n- Software architecture overview: [docs/ARCHITECTURE.md](docs/ARCHITECTURE.md)\n- Testing documentation: [tests/README.md](tests/README.md)\n- Updater (Auto-Sync) documentation: [suite/auto-sync/README.md](suite/auto-sync/README.md)\n\nContributing\n----\n\nSee [CONTRIBUTING.md](CONTRIBUTING.md) for an intro.\n\nFuzz\n----\n\nSee suite/fuzz/README.md for more information.\n\nLicense\n-------\n\nThis project is released under the BSD license. If you redistribute the binary\nor source code of Capstone, please attach file LICENSE.TXT with your products.\n"
        },
        {
          "name": "SPONSORS.TXT",
          "type": "blob",
          "size": 0.8681640625,
          "content": "* Version 6 - 2024\n\nRelease v6 was sponsored by RizinOrg (https://rizin.re)\n\n----------------------------\n* Version 5 - July 5th, 2023\n\nThe TriCore module in release v5 was sponsored by RizinOrg (https://rizin.re)\n\n------------------------------------\n* Version 4.0.1 - January 10th, 2019\n\nRelease 4.0.1 was sponsored by the following companies (in no particular order).\n\n- NowSecure: https://www.nowsecure.com\n- Verichains: https://verichains.io\n- Vsec: https://vsec.com.vn\n\n-----------------------------------\n* Version 4.0 - December 18th, 2018\n\nCapstone 4.0 version marks 5 years of the project!\nThis release was sponsored by the following companies (in no particular order).\n\n- Thinkst Canary: https://canary.tools\n- NowSecure: https://www.nowsecure.com\n- ECQ: https://e-cq.net\n- Senrio: https://senr.io\n- GracefulBits: https://gracefulbits.com\n- Catena Cyber: https://catenacyber.fr\n"
        },
        {
          "name": "SStream.c",
          "type": "blob",
          "size": 10.4794921875,
          "content": "/* Capstone Disassembly Engine */\n/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2019 */\n\n#include <stdarg.h>\n#if defined(CAPSTONE_HAS_OSXKERNEL)\n#include <Availability.h>\n#include <libkern/libkern.h>\n#include <i386/limits.h>\n#else\n#include <stdio.h>\n#include <limits.h>\n#endif\n#include <string.h>\n\n#include <capstone/platform.h>\n\n#include \"SStream.h\"\n#include \"cs_priv.h\"\n#include \"utils.h\"\n\nvoid SStream_Init(SStream *ss)\n{\n\tassert(ss);\n\tss->index = 0;\n\tmemset(ss->buffer, 0, sizeof(ss->buffer));\n\tss->is_closed = false;\n\tss->markup_stream = false;\n\tss->prefixed_by_markup = false;\n}\n\n/// Returns the a pointer to the internal string buffer of the stream.\n/// For reading only.\nconst char *SStream_rbuf(const SStream *ss) {\n\tassert(ss);\n\treturn ss->buffer;\n}\n\n/// Searches in the stream for the first (from the left) occurrence of @elem and replaces\n/// it with @repl. It returns the pointer *after* the replaced character\n/// or NULL if no character was replaced.\n///\n/// It will never replace the final \\0 byte in the stream buffer.\nconst char *SStream_replc(const SStream *ss, char elem, char repl) {\n\tassert(ss);\n\tchar *found = strchr(ss->buffer, elem);\n\tif (!found || found == ss->buffer + (SSTREAM_BUF_LEN - 1)) {\n\t\treturn NULL;\n\t}\n\t*found = repl;\n\tfound++;\n\treturn found;\n}\n\n/// Searches in the stream for the first (from the left) occurrence of @chr and replaces\n/// it with @rstr.\nvoid SStream_replc_str(SStream *ss, char chr, const char *rstr) {\n\tassert(ss && rstr);\n\tchar *found = strchr(ss->buffer, chr);\n\tif (!found || found == ss->buffer + (SSTREAM_BUF_LEN - 1)) {\n\t\treturn;\n\t}\n\tsize_t post_len = strlen(found + 1);\n\tsize_t buf_str_len = strlen(ss->buffer);\n\tsize_t repl_len = strlen(rstr);\n\tif (repl_len - 1 + buf_str_len >= SSTREAM_BUF_LEN) {\n\t\treturn;\n\t}\n\tmemmove(found + repl_len, found + 1, post_len);\n\tmemcpy(found, rstr, repl_len);\n\tss->index = strlen(ss->buffer);\n}\n\n/// Removes the space characters '\\t' and ' ' from the beginning of the stream buffer.\nvoid SStream_trimls(SStream *ss) {\n\tassert(ss);\n\tsize_t buf_off = 0;\n\t/// Remove leading spaces\n\twhile (ss->buffer[buf_off] == ' ' || ss->buffer[buf_off] == '\\t') {\n\t\tbuf_off++;\n\t}\n\tif (buf_off > 0) {\n\t\tmemmove(ss->buffer, ss->buffer + buf_off, SSTREAM_BUF_LEN - buf_off);\n\t\tss->index -= buf_off;\n\t}\n}\n\n/// Extract the mnemonic to @mnem_buf and the operand string into @op_str_buf from the stream buffer.\n/// The mnemonic is everything up until the first ' ' or '\\t' character.\n/// The operand string is everything after the first ' ' or '\\t' sequence.\nvoid SStream_extract_mnem_opstr(const SStream *ss, char *mnem_buf, size_t mnem_buf_size, char *op_str_buf, size_t op_str_buf_size) {\n\tassert(ss && mnem_buf && mnem_buf_size > 0 && op_str_buf && op_str_buf_size > 0);\n\tsize_t off = 0;\n\t// Copy all non space chars to as mnemonic.\n\twhile (ss->buffer[off] && ss->buffer[off] != ' ' && ss->buffer[off] != '\\t') {\n\t\tif (off < mnem_buf_size - 1) {\n\t\t\t// Only copy if there is space left.\n\t\t\tmnem_buf[off] = ss->buffer[off];\n\t\t}\n\t\toff++;\n\t}\n\tif (!ss->buffer[off]) {\n\t\treturn;\n\t}\n\n\t// Iterate until next non space char.\n\tdo {\n\t\toff++;\n\t} while (ss->buffer[off] && (ss->buffer[off] == ' ' || ss->buffer[off] == '\\t'));\n\n\tif (!ss->buffer[off]) {\n\t\treturn;\n\t}\n\n\t// Copy all follow up characters as op_str\n\tconst char *ss_op_str = ss->buffer + off;\n\toff = 0;\n\twhile (ss_op_str[off] && off < op_str_buf_size - 1) {\n\t\top_str_buf[off] = ss_op_str[off];\n\t\toff++;\n\t}\n}\n\n/// Empty the stream @ss to given @file (stdin/stderr).\n/// @file can be NULL. Then the buffer content is not emitted.\nvoid SStream_Flush(SStream *ss, FILE *file)\n{\n\tassert(ss);\n\tif (file) {\n\t\tfprintf(file, \"%s\\n\", ss->buffer);\n\t}\n\tSStream_Init(ss);\n}\n\n/**\n * Open the output stream. Every write attempt is accepted again.\n */\nvoid SStream_Open(SStream *ss) {\n\tassert(ss);\n\tss->is_closed = false;\n}\n\n/**\n * Closes the output stream. Every write attempt is ignored.\n */\nvoid SStream_Close(SStream *ss) {\n\tassert(ss);\n\tss->is_closed = true;\n}\n\n/**\n * Copy the string \\p s to the buffer of \\p ss and terminate it with a '\\\\0' byte.\n */\nvoid SStream_concat0(SStream *ss, const char *s)\n{\n#ifndef CAPSTONE_DIET\n\tassert(ss && s);\n\tSSTREAM_RETURN_IF_CLOSED(ss);\n\tif (s[0] == '\\0')\n\t\treturn;\n\tunsigned int len = (unsigned int) strlen(s);\n\n\tSSTREAM_OVERFLOW_CHECK(ss, len);\n\n\tmemcpy(ss->buffer + ss->index, s, len);\n\tss->index += len;\n\tss->buffer[ss->index] = '\\0';\n\tif (ss->markup_stream && ss->prefixed_by_markup) {\n\t\tSSTREAM_OVERFLOW_CHECK(ss, 1);\n\t\tss->buffer[ss->index] = '>';\n\t\tss->index += 1;\n\t\tss->buffer[ss->index] = '\\0';\n\t}\n#endif\n}\n\n/**\n * Copy the single char \\p c to the buffer of \\p ss.\n */\nvoid SStream_concat1(SStream *ss, const char c)\n{\n#ifndef CAPSTONE_DIET\n\tassert(ss);\n\tSSTREAM_RETURN_IF_CLOSED(ss);\n\tif (c == '\\0')\n\t\treturn;\n\n\tSSTREAM_OVERFLOW_CHECK(ss, 1);\n\n\tss->buffer[ss->index] = c;\n\tss->index++;\n\tss->buffer[ss->index] = '\\0';\n\tif (ss->markup_stream && ss->prefixed_by_markup) {\n\t\tSSTREAM_OVERFLOW_CHECK(ss, 1);\n\t\tss->buffer[ss->index] = '>';\n\t\tss->index++;\n\t}\n#endif\n}\n\n/**\n * Copy all strings given to the buffer of \\p ss according to formatting \\p fmt.\n */\nvoid SStream_concat(SStream *ss, const char *fmt, ...)\n{\n#ifndef CAPSTONE_DIET\n\tassert(ss && fmt);\n\tSSTREAM_RETURN_IF_CLOSED(ss);\n\tva_list ap;\n\tint ret;\n\n\tva_start(ap, fmt);\n\tret = cs_vsnprintf(ss->buffer + ss->index, sizeof(ss->buffer) - (ss->index + 1), fmt, ap);\n\tva_end(ap);\n\tss->index += ret;\n\tif (ss->markup_stream && ss->prefixed_by_markup) {\n\t\tSSTREAM_OVERFLOW_CHECK(ss, 1);\n\t\tss->buffer[ss->index] = '>';\n\t\tss->index += 1;\n\t}\n#endif\n}\n\n// print number with prefix #\nvoid printInt64Bang(SStream *ss, int64_t val)\n{\n\tassert(ss);\n\tSSTREAM_RETURN_IF_CLOSED(ss);\n\tSStream_concat1(ss, '#');\n\tprintInt64(ss, val);\n}\n\nvoid printUInt64Bang(SStream *ss, uint64_t val)\n{\n\tassert(ss);\n\tSSTREAM_RETURN_IF_CLOSED(ss);\n\tSStream_concat1(ss, '#');\n\tprintUInt64(ss, val);\n}\n\n// print number\nvoid printInt64(SStream *ss, int64_t val)\n{\n\tassert(ss);\n\tSSTREAM_RETURN_IF_CLOSED(ss);\n\tif (val >= 0) {\n\t\tif (val > HEX_THRESHOLD)\n\t\t\tSStream_concat(ss, \"0x%\"PRIx64, val);\n\t\telse\n\t\t\tSStream_concat(ss, \"%\"PRIu64, val);\n\t} else {\n\t\tif (val < -HEX_THRESHOLD) {\n\t\t\tif (val == INT64_MIN)\n\t\t\t\tSStream_concat(ss, \"-0x%\"PRIx64, (uint64_t) INT64_MAX + 1);\n\t\t\telse\n\t\t\t\tSStream_concat(ss, \"-0x%\"PRIx64, (uint64_t)-val);\n\t\t} else\n\t\t\tSStream_concat(ss, \"-%\"PRIu64, -val);\n\t}\n}\n\nvoid printUInt64(SStream *ss, uint64_t val)\n{\n\tassert(ss);\n\tSSTREAM_RETURN_IF_CLOSED(ss);\n\tif (val > HEX_THRESHOLD)\n\t\tSStream_concat(ss, \"0x%\"PRIx64, val);\n\telse\n\t\tSStream_concat(ss, \"%\"PRIu64, val);\n}\n\n// print number in decimal mode\nvoid printInt32BangDec(SStream *ss, int32_t val)\n{\n\tassert(ss);\n\tSSTREAM_RETURN_IF_CLOSED(ss);\n\tif (val >= 0)\n\t\tSStream_concat(ss, \"#%\" PRIu32, val);\n\telse {\n\t\tif (val == INT32_MIN)\n\t\t\tSStream_concat(ss, \"#-%\" PRIu32, val);\n\t\telse\n\t\t\tSStream_concat(ss, \"#-%\" PRIu32, (uint32_t)-val);\n\t}\n}\n\nvoid printInt32Bang(SStream *ss, int32_t val)\n{\n\tassert(ss);\n\tSSTREAM_RETURN_IF_CLOSED(ss);\n\tSStream_concat1(ss, '#');\n\tprintInt32(ss, val);\n}\n\nvoid printInt8(SStream *ss, int8_t val)\n{\n\tassert(ss);\n\tSSTREAM_RETURN_IF_CLOSED(ss);\n\tif (val >= 0) {\n\t\tif (val > HEX_THRESHOLD)\n\t\t\tSStream_concat(ss, \"0x%\" PRIx8, val);\n\t\telse\n\t\t\tSStream_concat(ss, \"%\" PRId8, val);\n\t} else {\n\t\tif (val < -HEX_THRESHOLD) {\n\t\t\tif (val == INT8_MIN)\n\t\t\t\tSStream_concat(ss, \"-0x%\" PRIx8, (uint8_t) INT8_MAX + 1);\n\t\t\telse\n\t\t\t\tSStream_concat(ss, \"-0x%\" PRIx8, (int8_t)-val);\n\t\t} else\n\t\t\tSStream_concat(ss, \"-%\" PRIu8, -val);\n\t}\n}\n\nvoid printInt16(SStream *ss, int16_t val)\n{\n\tassert(ss);\n\tSSTREAM_RETURN_IF_CLOSED(ss);\n\tif (val >= 0) {\n\t\tif (val > HEX_THRESHOLD)\n\t\t\tSStream_concat(ss, \"0x%\" PRIx16, val);\n\t\telse\n\t\t\tSStream_concat(ss, \"%\" PRId16, val);\n\t} else {\n\t\tif (val < -HEX_THRESHOLD) {\n\t\t\tif (val == INT16_MIN)\n\t\t\t\tSStream_concat(ss, \"-0x%\" PRIx16, (uint16_t) INT16_MAX + 1);\n\t\t\telse\n\t\t\t\tSStream_concat(ss, \"-0x%\" PRIx16, (int16_t)-val);\n\t\t} else\n\t\t\tSStream_concat(ss, \"-%\" PRIu16, -val);\n\t}\n}\n\nvoid printInt16HexOffset(SStream *ss, int16_t val)\n{\n\tassert(ss);\n\tSSTREAM_RETURN_IF_CLOSED(ss);\n\tif (val >= 0) {\n\t\tSStream_concat(ss, \"+0x%\" PRIx16, val);\n\t} else {\n\t\tif (val == INT16_MIN)\n\t\t\tSStream_concat(ss, \"-0x%\" PRIx16,\n\t\t\t\t       (uint16_t)INT16_MAX + 1);\n\t\telse\n\t\t\tSStream_concat(ss, \"-0x%\" PRIx16, (int16_t)-val);\n\t}\n}\n\n\nvoid printInt32(SStream *ss, int32_t val)\n{\n\tassert(ss);\n\tSSTREAM_RETURN_IF_CLOSED(ss);\n\tif (val >= 0) {\n\t\tif (val > HEX_THRESHOLD)\n\t\t\tSStream_concat(ss, \"0x%\" PRIx32, val);\n\t\telse\n\t\t\tSStream_concat(ss, \"%\" PRId32, val);\n\t} else {\n\t\tif (val < -HEX_THRESHOLD) {\n\t\t\tif (val == INT32_MIN)\n\t\t\t\tSStream_concat(ss, \"-0x%\" PRIx32, (uint32_t) INT32_MAX + 1);\n\t\t\telse\n\t\t\t\tSStream_concat(ss, \"-0x%\" PRIx32, (int32_t)-val);\n\t\t} else {\n\t\t\tSStream_concat(ss, \"-%\" PRIu32, (uint32_t)-val);\n\t\t}\n\t}\n}\n\nvoid printInt32HexOffset(SStream *ss, int32_t val)\n{\n\tassert(ss);\n\tSSTREAM_RETURN_IF_CLOSED(ss);\n\tif (val >= 0) {\n\t\tSStream_concat(ss, \"+0x%\" PRIx32, val);\n\t} else {\n\t\tif (val == INT32_MIN)\n\t\t\tSStream_concat(ss, \"-0x%\" PRIx32,\n\t\t\t\t       (uint32_t)INT32_MAX + 1);\n\t\telse\n\t\t\tSStream_concat(ss, \"-0x%\" PRIx32, (int32_t)-val);\n\t}\n}\n\nvoid printInt32Hex(SStream *ss, int32_t val)\n{\n\tassert(ss);\n\tSSTREAM_RETURN_IF_CLOSED(ss);\n\tif (val >= 0) {\n\t\tSStream_concat(ss, \"0x%\" PRIx32, val);\n\t} else {\n\t\tif (val == INT32_MIN)\n\t\t\tSStream_concat(ss, \"-0x%\" PRIx32,\n\t\t\t\t       (uint32_t)INT32_MAX + 1);\n\t\telse\n\t\t\tSStream_concat(ss, \"-0x%\" PRIx32, (int32_t)-val);\n\t}\n}\n\nvoid printUInt32Bang(SStream *ss, uint32_t val)\n{\n\tassert(ss);\n\tSSTREAM_RETURN_IF_CLOSED(ss);\n\tSStream_concat1(ss, '#');\n\tprintUInt32(ss, val);\n}\n\nvoid printUInt32(SStream *ss, uint32_t val)\n{\n\tassert(ss);\n\tSSTREAM_RETURN_IF_CLOSED(ss);\n\tif (val > HEX_THRESHOLD)\n\t\tSStream_concat(ss, \"0x%x\", val);\n\telse\n\t\tSStream_concat(ss, \"%u\", val);\n}\n\nvoid printFloat(SStream *ss, float val)\n{\n\tassert(ss);\n\tSSTREAM_RETURN_IF_CLOSED(ss);\n\tSStream_concat(ss, \"%e\", val);\n}\n\nvoid printFloatBang(SStream *ss, float val)\n{\n\tassert(ss);\n\tSSTREAM_RETURN_IF_CLOSED(ss);\n\tSStream_concat(ss, \"#%e\", val);\n}\n\nvoid printExpr(SStream *ss, uint64_t val)\n{\n\tassert(ss);\n\tSSTREAM_RETURN_IF_CLOSED(ss);\n\tSStream_concat(ss, \"%\"PRIu64, val);\n}\n\nSStream *markup_OS(SStream *OS, SStreamMarkup style) {\n\tassert(OS);\n\n\tif (OS->is_closed || !OS->markup_stream) {\n\t\treturn OS;\n\t}\n\tOS->markup_stream = false; // Disable temporarily.\n\tswitch (style) {\n\tdefault:\n\t\tSStream_concat0(OS, \"<UNKNOWN:\");\n\t\treturn OS;\n\tcase Markup_Immediate:\n\t\tSStream_concat0(OS, \"<imm:\");\n\t\tbreak;\n\tcase Markup_Register:\n\t\tSStream_concat0(OS, \"<reg:\");\n\t\tbreak;\n\tcase Markup_Target:\n\t\tSStream_concat0(OS, \"<tar:\");\n\t\tbreak;\n\tcase Markup_Memory:\n\t\tSStream_concat0(OS, \"<mem:\");\n\t\tbreak;\n\t}\n\tOS->markup_stream = true;\n\tOS->prefixed_by_markup = true;\n\treturn OS;\n}\n"
        },
        {
          "name": "SStream.h",
          "type": "blob",
          "size": 2.3134765625,
          "content": "/* Capstone Disassembly Engine */\n/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2019 */\n\n#ifndef CS_SSTREAM_H_\n#define CS_SSTREAM_H_\n\n#include \"include/capstone/platform.h\"\n#include <stdio.h>\n\ntypedef enum {\n\tMarkup_Immediate,\n\tMarkup_Register,\n\tMarkup_Target,\n\tMarkup_Memory,\n} SStreamMarkup;\n\n#define SSTREAM_BUF_LEN 512\n\ntypedef struct SStream {\n\tchar buffer[SSTREAM_BUF_LEN];\n\tint index;\n\tbool is_closed;\n\tbool markup_stream; ///< If true, markups to the stream are allowed.\n\tbool prefixed_by_markup; ///< Set after the stream wrote a markup for an operand.\n} SStream;\n\n#define SSTREAM_OVERFLOW_CHECK(OS, len) \\\ndo { \\\n\tif (OS->index + len + 1 > SSTREAM_BUF_LEN) { \\\n\t\tfprintf(stderr, \"Buffer overflow caught!\\n\"); \\\n\t\treturn; \\\n\t} \\\n} while(0)\n\n#define SSTREAM_RETURN_IF_CLOSED(OS) \\\ndo { \\\n\tif (OS->is_closed) \\\n\t\treturn; \\\n} while(0)\n\nvoid SStream_Init(SStream *ss);\n\nconst char *SStream_replc(const SStream *ss, char elem, char repl);\n\nvoid SStream_replc_str(SStream *ss, char chr, const char *rstr);\n\nconst char *SStream_rbuf(const SStream *ss);\n\nvoid SStream_extract_mnem_opstr(const SStream *ss, char *mnem_buf, size_t mnem_buf_size, char *op_str_buf, size_t op_str_buf_size);\n\nvoid SStream_trimls(SStream *ss);\n\nvoid SStream_Flush(SStream *ss, FILE *file);\n\nvoid SStream_Open(SStream *ss);\n\nvoid SStream_Close(SStream *ss);\n\nvoid SStream_concat(SStream *ss, const char *fmt, ...);\n\nvoid SStream_concat0(SStream *ss, const char *s);\n\nvoid SStream_concat1(SStream *ss, const char c);\n\nvoid printInt64Bang(SStream *O, int64_t val);\n\nvoid printUInt64Bang(SStream *O, uint64_t val);\n\nvoid printInt64(SStream *O, int64_t val);\nvoid printUInt64(SStream *O, uint64_t val);\n\nvoid printInt32Bang(SStream *O, int32_t val);\n\nvoid printInt8(SStream *O, int8_t val);\nvoid printInt16(SStream *O, int16_t val);\nvoid printInt16HexOffset(SStream *O, int16_t val);\n\nvoid printInt32(SStream *O, int32_t val);\nvoid printInt32Hex(SStream *ss, int32_t val);\nvoid printInt32HexOffset(SStream *ss, int32_t val);\n\nvoid printUInt32Bang(SStream *O, uint32_t val);\n\nvoid printUInt32(SStream *O, uint32_t val);\n\n// print number in decimal mode\nvoid printInt32BangDec(SStream *O, int32_t val);\n\nvoid printFloat(SStream *O, float val);\n\nvoid printFloatBang(SStream *O, float val);\n\nvoid printExpr(SStream *O, uint64_t val);\n\nSStream *markup_OS(SStream *OS, SStreamMarkup style);\n\n#endif\n"
        },
        {
          "name": "arch",
          "type": "tree",
          "content": null
        },
        {
          "name": "bindings",
          "type": "tree",
          "content": null
        },
        {
          "name": "capstone-config.cmake.in",
          "type": "blob",
          "size": 0.2119140625,
          "content": "@PACKAGE_INIT@\n\nset_and_check(capstone_INCLUDE_DIR \"@CAPSTONE_CMAKE_INSTALL_INCLUDEDIR@\")\nset_and_check(capstone_LIB_DIR \"@CAPSTONE_CMAKE_INSTALL_LIBDIR@\")\n\ninclude(\"${CMAKE_CURRENT_LIST_DIR}/capstone-targets.cmake\")\n"
        },
        {
          "name": "capstone.pc.in",
          "type": "blob",
          "size": 0.4638671875,
          "content": "prefix=@CMAKE_INSTALL_PREFIX@\nexec_prefix=${prefix}\nlibdir=@CAPSTONE_PKGCONFIG_INSTALL_LIBDIR@\nincludedir=@CAPSTONE_PKGCONFIG_INSTALL_INCLUDEDIR@\n\nName: capstone\nDescription: Capstone disassembly engine\nVersion: @PROJECT_VERSION_MAJOR@.@PROJECT_VERSION_MINOR@.@PROJECT_VERSION_PATCH@\nURL: https://www.capstone-engine.org/\narchive=${libdir}/libcapstone.a\nLibs: -L${libdir} -lcapstone\nLibs.private: -L${libdir} -l:libcapstone.a\nCflags: -I${includedir} -I${includedir}/capstone\n"
        },
        {
          "name": "cmake.sh",
          "type": "blob",
          "size": 1.2080078125,
          "content": "#!/bin/sh\n\n# Capstone disassembler engine (www.capstone-engine.org)\n# Build Capstone libs for specified architecture, or all if none is specified (libcapstone.so & libcapstone.a) on *nix with CMake & make\n# By Nguyen Anh Quynh, Jorn Vernee, 2019\n\nCMAKE_FLAGS=\"-DCMAKE_BUILD_TYPE=Release\"\n# Uncomment below line to compile in Diet mode\n# CMAKE_FLAGS+=\" -DCAPSTONE_BUILD_DIET=ON\"\n\ncase $1 in\n  ARM)\n    ARCH=ARM\n    ;;\n  ARM64)\n    ARCH=AARCH64\n    ;;\n  AARCH64)\n    ARCH=AARCH64\n    ;;\n  M68K)\n    ARCH=M68K\n    ;;\n  MIPS)\n    ARCH=MIPS\n    ;;\n  PowerPC)\n    ARCH=PPC\n    ;;\n  Sparc)\n    ARCH=SPARC\n    ;;\n  SystemZ)\n    ARCH=SYSTEMZ\n    ;;\n  XCore)\n    ARCH=XCORE\n    ;;\n  x86)\n    ARCH=X86\n    ;;\n  TMS320C64x)\n    ARCH=TMS320C64X\n    ;;\n  M680x)\n    ARCH=M680X\n    ;;\n  EVM)\n    ARCH=EVM\n    ;;\n  MOS65XX)\n    ARCH=MOS65XX\n    ;;\n  WASM)\n    ARCH=WASM\n    ;;\n  BPF)\n    ARCH=BPF\n    ;;\n  RISCV)\n    ARCH=RISCV\n    ;;\n  HPPA)\n    ARCH=HPPA\n    ;;\n  LOONGARCH)\n    ARCH=LOONGARCH\n    ;;\n  *)\n    ;;\nesac\n\nif [ -z \"${ARCH}\" ]; then\n  CMAKE_FLAGS=\"${CMAKE_FLAGS} -DCAPSTONE_ARCHITECTURE_DEFAULT=ON\"\nelse\n  CMAKE_FLAGS=\"${CMAKE_FLAGS} -DCAPSTONE_ARCHITECTURE_DEFAULT=OFF -DCAPSTONE_${ARCH}_SUPPORT=ON\"\nfi\n\ncmake ${CMAKE_FLAGS} ..\n\nmake -j8\n"
        },
        {
          "name": "cmake_uninstall.cmake.in",
          "type": "blob",
          "size": 0.89453125,
          "content": "if(NOT EXISTS \"@CMAKE_BINARY_DIR@/install_manifest.txt\")\n  message(FATAL_ERROR \"Cannot find install manifest: @CMAKE_BINARY_DIR@/install_manifest.txt\")\nendif()\n\nfile(READ \"@CMAKE_BINARY_DIR@/install_manifest.txt\" files)\nstring(REGEX REPLACE \"\\n\" \";\" files \"${files}\")\nforeach(file ${files})\n  message(STATUS \"Uninstalling $ENV{DESTDIR}${file}\")\n  if(IS_SYMLINK \"$ENV{DESTDIR}${file}\" OR EXISTS \"$ENV{DESTDIR}${file}\")\n    file(REMOVE_RECURSE $ENV{DESTDIR}${file})\n  else(IS_SYMLINK \"$ENV{DESTDIR}${file}\" OR EXISTS \"$ENV{DESTDIR}${file}\")\n    message(STATUS \"File $ENV{DESTDIR}${file} does not exist.\")\n  endif()\nendforeach()\n\nmessage(STATUS \"Uninstalling @CAPSTONE_CMAKE_INSTALL_INCLUDEDIR@/capstone\")\nfile(REMOVE_RECURSE @CAPSTONE_CMAKE_INSTALL_INCLUDEDIR@/capstone)\n\nmessage(STATUS \"Uninstalling @CAPSTONE_CMAKE_INSTALL_LIBDIR@/cmake/capstone\")\nfile(REMOVE_RECURSE @CAPSTONE_CMAKE_INSTALL_LIBDIR@/cmake/capstone)\n"
        },
        {
          "name": "config.mk",
          "type": "blob",
          "size": 3.3681640625,
          "content": "# This file contains all customized compile options for Capstone.\n# Consult COMPILE_MAKE.TXT & docs/README for details.\n\n################################################################################\n# Specify which archs you want to compile in. By default, we build all archs.\n\nCAPSTONE_ARCHS ?= arm aarch64 m68k mips powerpc sparc systemz x86 xcore tms320c64x m680x evm riscv mos65xx wasm bpf sh tricore alpha hppa loongarch xtensa\n\n\n################################################################################\n# Comment out the line below ('CAPSTONE_USE_SYS_DYN_MEM = yes'), or change it to\n# 'CAPSTONE_USE_SYS_DYN_MEM = no' if do NOT use malloc/calloc/realloc/free/\n# vsnprintf() provided by system for internal dynamic memory management.\n#\n# NOTE: in that case, specify your own malloc/calloc/realloc/free/vsnprintf()\n# functions in your program via API cs_option(), using CS_OPT_MEM option type.\n\nCAPSTONE_USE_SYS_DYN_MEM ?= yes\n\n\n################################################################################\n# Change 'CAPSTONE_DIET = no' to 'CAPSTONE_DIET = yes' to make the library\n# more compact: use less memory & smaller in binary size.\n# This setup will remove the @mnemonic & @op_str data, plus semantic information\n# such as @regs_read/write & @group. The amount of binary size reduced is\n# up to 50% in some individual archs.\n#\n# NOTE: we still keep all those related fields @mnemonic, @op_str, @regs_read,\n# @regs_write, @groups, etc in fields in cs_insn structure regardless, but they\n# will not be updated (i.e empty), thus become irrelevant.\n\nCAPSTONE_DIET ?= no\n\n\n################################################################################\n# Change 'CAPSTONE_X86_REDUCE = no' to 'CAPSTONE_X86_REDUCE = yes' to remove\n# non-critical instruction sets of X86, making the binary size smaller by ~60%.\n# This is desired in special cases, such as OS kernel, where these kind of\n# instructions are not used.\n#\n# The list of instruction sets to be removed includes:\n# - Floating Point Unit (FPU)\n# - MultiMedia eXtension (MMX)\n# - Streaming SIMD Extensions (SSE)\n# - 3DNow\n# - Advanced Vector Extensions (AVX)\n# - Fused Multiply Add Operations (FMA)\n# - eXtended Operations (XOP)\n# - Transactional Synchronization Extensions (TSX)\n#\n# Due to this removal, the related instructions are nolonger supported.\n#\n# By default, Capstone is compiled with 'CAPSTONE_X86_REDUCE = no',\n# thus supports complete X86 instructions.\n\nCAPSTONE_X86_REDUCE ?= no\n\n################################################################################\n# Change 'CAPSTONE_X86_ATT_DISABLE = no' to 'CAPSTONE_X86_ATT_DISABLE = yes' to\n# disable AT&T syntax on x86 to reduce library size.\n\nCAPSTONE_X86_ATT_DISABLE ?= no\n\n################################################################################\n# Change 'CAPSTONE_STATIC = yes' to 'CAPSTONE_STATIC = no' to avoid building\n# a static library.\n\nCAPSTONE_STATIC ?= yes\n\n\n################################################################################\n# Change 'CAPSTONE_SHARED = yes' to 'CAPSTONE_SHARED = no' to avoid building\n# a shared library.\n\nCAPSTONE_SHARED ?= yes\n\n################################################################################\n# Change 'CAPSTONE_HAS_OSXKERNEL = no' to 'CAPSTONE_HAS_OSXKERNEL = yes' to\n# enable OS X kernel embedding support. If 'CAPSTONE_USE_SYS_DYN_MEM = yes',\n# then kern_os_* functions are used for memory management.\n\nCAPSTONE_HAS_OSXKERNEL ?= no\n"
        },
        {
          "name": "contrib",
          "type": "tree",
          "content": null
        },
        {
          "name": "cs.c",
          "type": "blob",
          "size": 49.07421875,
          "content": "/* Capstone Disassembly Engine */\n/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2019 */\n\n#include \"SStream.h\"\n#if defined(CAPSTONE_HAS_OSXKERNEL)\n#include <Availability.h>\n#include <libkern/libkern.h>\n#else\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#endif\n\n#include <string.h>\n#include <capstone/capstone.h>\n\n#include \"utils.h\"\n#include \"MCRegisterInfo.h\"\n\n#if defined(_KERNEL_MODE)\n#include \"windows\\winkernel_mm.h\"\n#endif\n\n// Issue #681: Windows kernel does not support formatting float point\n#if defined(_KERNEL_MODE) && !defined(CAPSTONE_DIET)\n#if defined(CAPSTONE_HAS_ARM) || defined(CAPSTONE_HAS_AARCH64) || defined(CAPSTONE_HAS_M68K)\n#define CAPSTONE_STR_INTERNAL(x) #x\n#define CAPSTONE_STR(x) CAPSTONE_STR_INTERNAL(x)\n#define CAPSTONE_MSVC_WRANING_PREFIX __FILE__ \"(\"CAPSTONE_STR(__LINE__)\") : warning message : \"\n\n#pragma message(CAPSTONE_MSVC_WRANING_PREFIX \"Windows driver does not support full features for selected architecture(s). Define CAPSTONE_DIET to compile Capstone with only supported features. See issue #681 for details.\")\n\n#undef CAPSTONE_MSVC_WRANING_PREFIX\n#undef CAPSTONE_STR\n#undef CAPSTONE_STR_INTERNAL\n#endif\n#endif\t// defined(_KERNEL_MODE) && !defined(CAPSTONE_DIET)\n\n#if !defined(CAPSTONE_HAS_OSXKERNEL) && !defined(CAPSTONE_DIET) && !defined(_KERNEL_MODE)\n#define INSN_CACHE_SIZE 32\n#else\n// reduce stack variable size for kernel/firmware\n#define INSN_CACHE_SIZE 8\n#endif\n\n// default SKIPDATA mnemonic\n#ifndef CAPSTONE_DIET\n#define SKIPDATA_MNEM \".byte\"\n#else // No printing is available in diet mode\n#define SKIPDATA_MNEM NULL\n#endif\n\n#include \"arch/AArch64/AArch64Module.h\"\n#include \"arch/ARM/ARMModule.h\"\n#include \"arch/EVM/EVMModule.h\"\n#include \"arch/WASM/WASMModule.h\"\n#include \"arch/M680X/M680XModule.h\"\n#include \"arch/M68K/M68KModule.h\"\n#include \"arch/Mips/MipsModule.h\"\n#include \"arch/PowerPC/PPCModule.h\"\n#include \"arch/Sparc/SparcModule.h\"\n#include \"arch/SystemZ/SystemZModule.h\"\n#include \"arch/TMS320C64x/TMS320C64xModule.h\"\n#include \"arch/X86/X86Module.h\"\n#include \"arch/XCore/XCoreModule.h\"\n#include \"arch/RISCV/RISCVModule.h\"\n#include \"arch/MOS65XX/MOS65XXModule.h\"\n#include \"arch/BPF/BPFModule.h\"\n#include \"arch/SH/SHModule.h\"\n#include \"arch/TriCore/TriCoreModule.h\"\n#include \"arch/Alpha/AlphaModule.h\"\n#include \"arch/HPPA/HPPAModule.h\"\n#include \"arch/LoongArch/LoongArchModule.h\"\n#include \"arch/Xtensa/XtensaModule.h\"\n\ntypedef struct cs_arch_config {\n\t// constructor initialization\n\tcs_err (*arch_init)(cs_struct *);\n\t// support cs_option()\n\tcs_err (*arch_option)(cs_struct *, cs_opt_type, size_t value);\n\t// bitmask for finding disallowed modes for an arch:\n\t// to be called in cs_open()/cs_option()\n\tcs_mode arch_disallowed_mode_mask;\n} cs_arch_config;\n\n#define CS_ARCH_CONFIG_ARM \\\n\t{ \\\n\t\tARM_global_init, \\\n\t\tARM_option, \\\n\t\t~(CS_MODE_LITTLE_ENDIAN | CS_MODE_ARM | CS_MODE_V8 | CS_MODE_MCLASS | CS_MODE_THUMB | CS_MODE_BIG_ENDIAN), \\\n\t}\n#define CS_ARCH_CONFIG_AARCH64 \\\n\t{ \\\n\t\tAArch64_global_init, \\\n\t\tAArch64_option, \\\n\t\t~(CS_MODE_LITTLE_ENDIAN | CS_MODE_ARM | CS_MODE_BIG_ENDIAN), \\\n\t}\n#define CS_ARCH_CONFIG_MIPS \\\n\t{ \\\n\t\tMips_global_init, \\\n\t\tMips_option, \\\n\t\t~(CS_MODE_LITTLE_ENDIAN | \\\n\t\t\tCS_MODE_BIG_ENDIAN | \\\n\t\t\tCS_MODE_MIPS16 | \\\n\t\t\tCS_MODE_MIPS32 | \\\n\t\t\tCS_MODE_MIPS64 | \\\n\t\t\tCS_MODE_MICRO | \\\n\t\t\tCS_MODE_MIPS1 | \\\n\t\t\tCS_MODE_MIPS2 | \\\n\t\t\tCS_MODE_MIPS32R2 | \\\n\t\t\tCS_MODE_MIPS32R3 | \\\n\t\t\tCS_MODE_MIPS32R5 | \\\n\t\t\tCS_MODE_MIPS32R6 | \\\n\t\t\tCS_MODE_MIPS3 | \\\n\t\t\tCS_MODE_MIPS4 | \\\n\t\t\tCS_MODE_MIPS5 | \\\n\t\t\tCS_MODE_MIPS64R2 | \\\n\t\t\tCS_MODE_MIPS64R3 | \\\n\t\t\tCS_MODE_MIPS64R5 | \\\n\t\t\tCS_MODE_MIPS64R6 | \\\n\t\t\tCS_MODE_OCTEON | \\\n\t\t\tCS_MODE_OCTEONP | \\\n\t\t\tCS_MODE_NANOMIPS | \\\n\t\t\tCS_MODE_NMS1 | \\\n\t\t\tCS_MODE_I7200 | \\\n\t\t\tCS_MODE_MIPS_NOFLOAT | \\\n\t\t\tCS_MODE_MIPS_PTR64 \\\n\t\t\t), \\\n\t}\n#define CS_ARCH_CONFIG_X86 \\\n\t{ \\\n\t\tX86_global_init, \\\n\t\tX86_option, \\\n\t\t~(CS_MODE_LITTLE_ENDIAN | CS_MODE_32 | CS_MODE_64 | CS_MODE_16), \\\n\t}\n#define CS_ARCH_CONFIG_PPC \\\n\t{ \\\n\t\tPPC_global_init, \\\n\t\tPPC_option, \\\n\t\t~(CS_MODE_LITTLE_ENDIAN | CS_MODE_32 | CS_MODE_64 | CS_MODE_BIG_ENDIAN \\\n\t\t\t\t| CS_MODE_QPX | CS_MODE_PS | CS_MODE_BOOKE | CS_MODE_SPE \\\n\t\t\t\t| CS_MODE_AIX_OS | CS_MODE_PWR7 | CS_MODE_PWR8 | CS_MODE_PWR9 \\\n\t\t\t\t| CS_MODE_PWR10 | CS_MODE_PPC_ISA_FUTURE | CS_MODE_MSYNC | CS_MODE_MODERN_AIX_AS), \\\n\t}\n#define CS_ARCH_CONFIG_SPARC \\\n\t{ \\\n\t\tSparc_global_init, \\\n\t\tSparc_option, \\\n\t\t~(CS_MODE_BIG_ENDIAN | CS_MODE_V9), \\\n\t}\n#define CS_ARCH_CONFIG_SYSTEMZ \\\n\t{ \\\n\t\tSystemZ_global_init, \\\n\t\tSystemZ_option, \\\n\t\t~(CS_MODE_BIG_ENDIAN | \\\n\t\t\tCS_MODE_SYSTEMZ_ARCH8 | \\\n\t\t\tCS_MODE_SYSTEMZ_ARCH9 | \\\n\t\t\tCS_MODE_SYSTEMZ_ARCH10 | \\\n\t\t\tCS_MODE_SYSTEMZ_ARCH11 | \\\n\t\t\tCS_MODE_SYSTEMZ_ARCH12 | \\\n\t\t\tCS_MODE_SYSTEMZ_ARCH13 | \\\n\t\t\tCS_MODE_SYSTEMZ_ARCH14 | \\\n\t\t\tCS_MODE_SYSTEMZ_Z10 | \\\n\t\t\tCS_MODE_SYSTEMZ_Z196 | \\\n\t\t\tCS_MODE_SYSTEMZ_ZEC12 | \\\n\t\t\tCS_MODE_SYSTEMZ_Z13 | \\\n\t\t\tCS_MODE_SYSTEMZ_Z14 | \\\n\t\t\tCS_MODE_SYSTEMZ_Z15 | \\\n\t\t\tCS_MODE_SYSTEMZ_Z16 | \\\n\t\t\tCS_MODE_SYSTEMZ_GENERIC \\\n\t\t), \\\n\t}\n#define CS_ARCH_CONFIG_XCORE \\\n\t{ \\\n\t\tXCore_global_init, \\\n\t\tXCore_option, \\\n\t\t~(CS_MODE_BIG_ENDIAN), \\\n\t}\n#define CS_ARCH_CONFIG_M68K \\\n\t{ \\\n\t\tM68K_global_init, \\\n\t\tM68K_option, \\\n\t\t~(CS_MODE_BIG_ENDIAN | CS_MODE_M68K_000 | CS_MODE_M68K_010 | CS_MODE_M68K_020 \\\n\t\t\t\t| CS_MODE_M68K_030 | CS_MODE_M68K_040 | CS_MODE_M68K_060), \\\n\t}\n#define CS_ARCH_CONFIG_TMS320C64X \\\n\t{ \\\n\t\tTMS320C64x_global_init, \\\n\t\tTMS320C64x_option, \\\n\t\t~(CS_MODE_BIG_ENDIAN), \\\n\t}\n#define CS_ARCH_CONFIG_M680X \\\n\t{ \\\n\t\tM680X_global_init, \\\n\t\tM680X_option, \\\n\t\t~(CS_MODE_M680X_6301 | CS_MODE_M680X_6309 | CS_MODE_M680X_6800 \\\n\t\t\t\t| CS_MODE_M680X_6801 | CS_MODE_M680X_6805 | CS_MODE_M680X_6808 \\\n\t\t\t\t| CS_MODE_M680X_6809 | CS_MODE_M680X_6811 | CS_MODE_M680X_CPU12 \\\n\t\t\t\t| CS_MODE_M680X_HCS08), \\\n\t}\n#define CS_ARCH_CONFIG_EVM \\\n\t{ \\\n\t\tEVM_global_init, \\\n\t\tEVM_option, \\\n\t\t0, \\\n\t}\n#define CS_ARCH_CONFIG_MOS65XX \\\n\t{ \\\n\t\tMOS65XX_global_init, \\\n\t\tMOS65XX_option, \\\n\t\t~(CS_MODE_LITTLE_ENDIAN | CS_MODE_MOS65XX_6502 | CS_MODE_MOS65XX_65C02 \\\n\t\t\t\t| CS_MODE_MOS65XX_W65C02 | CS_MODE_MOS65XX_65816_LONG_MX), \\\n\t}\n#define CS_ARCH_CONFIG_WASM \\\n\t{ \\\n\t\tWASM_global_init, \\\n\t\tWASM_option, \\\n\t\t0, \\\n\t}\n#define CS_ARCH_CONFIG_BPF \\\n\t{ \\\n\t\tBPF_global_init, \\\n\t\tBPF_option, \\\n\t\t~(CS_MODE_LITTLE_ENDIAN | CS_MODE_BPF_CLASSIC | CS_MODE_BPF_EXTENDED \\\n\t\t\t\t| CS_MODE_BIG_ENDIAN), \\\n\t}\n#define CS_ARCH_CONFIG_RISCV \\\n\t{ \\\n\t\tRISCV_global_init, \\\n\t\tRISCV_option, \\\n\t\t~(CS_MODE_RISCV32 | CS_MODE_RISCV64 | CS_MODE_RISCVC), \\\n\t}\n#define CS_ARCH_CONFIG_SH \\\n\t{ \\\n\t\tSH_global_init, \\\n\t\tSH_option, \\\n\t\t~(CS_MODE_SH2 | CS_MODE_SH2A | CS_MODE_SH3 | \\\n\t\t  CS_MODE_SH4 | CS_MODE_SH4A | \\\n\t\t  CS_MODE_SHFPU | CS_MODE_SHDSP|CS_MODE_BIG_ENDIAN), \\\n\t}\n#define CS_ARCH_CONFIG_TRICORE \\\n\t{ \\\n\t\tTRICORE_global_init, \\\n\t\tTRICORE_option, \\\n\t\t~(CS_MODE_TRICORE_110 | CS_MODE_TRICORE_120 | CS_MODE_TRICORE_130 \\\n\t\t| CS_MODE_TRICORE_131 | CS_MODE_TRICORE_160 | CS_MODE_TRICORE_161 \\\n\t\t| CS_MODE_TRICORE_162 | CS_MODE_LITTLE_ENDIAN), \\\n\t}\n#define CS_ARCH_CONFIG_ALPHA \\\n\t{ \\\n\t\tALPHA_global_init, \\\n\t\tALPHA_option, \\\n\t\t~(CS_MODE_LITTLE_ENDIAN | CS_MODE_BIG_ENDIAN), \\\n\t}\n#define CS_ARCH_CONFIG_LOONGARCH \\\n\t{ \\\n\t\tLoongArch_global_init, \\\n\t\tLoongArch_option, \\\n\t\t~(CS_MODE_LITTLE_ENDIAN | CS_MODE_LOONGARCH32 | CS_MODE_LOONGARCH64), \\\n\t}\n#define CS_ARCH_CONFIG_XTENSA \\\n\t{ \\\n\t\tXtensa_global_init, \\\n\t\tXtensa_option, \\\n\t\t~(CS_MODE_XTENSA_ESP32 | CS_MODE_XTENSA_ESP32S2 | \\\n\t\t  CS_MODE_XTENSA_ESP8266), \\\n\t}\n\n#ifdef CAPSTONE_USE_ARCH_REGISTRATION\nstatic cs_arch_config arch_configs[MAX_ARCH];\nstatic uint32_t all_arch;\n#else\nstatic const cs_arch_config arch_configs[MAX_ARCH] = {\n#ifdef CAPSTONE_HAS_ARM\n\tCS_ARCH_CONFIG_ARM,\n#else\n\t{ NULL, NULL, 0 },\n#endif\n#ifdef CAPSTONE_HAS_AARCH64\n\tCS_ARCH_CONFIG_AARCH64,\n#else\n\t{ NULL, NULL, 0 },\n#endif\n#ifdef CAPSTONE_HAS_SYSTEMZ\n\tCS_ARCH_CONFIG_SYSTEMZ,\n#else\n\t{ NULL, NULL, 0 },\n#endif\n#ifdef CAPSTONE_HAS_MIPS\n\tCS_ARCH_CONFIG_MIPS,\n#else\n\t{ NULL, NULL, 0 },\n#endif\n#ifdef CAPSTONE_HAS_X86\n\tCS_ARCH_CONFIG_X86,\n#else\n\t{ NULL, NULL, 0 },\n#endif\n#ifdef CAPSTONE_HAS_POWERPC\n\tCS_ARCH_CONFIG_PPC,\n#else\n\t{ NULL, NULL, 0 },\n#endif\n#ifdef CAPSTONE_HAS_SPARC\n\tCS_ARCH_CONFIG_SPARC,\n#else\n\t{ NULL, NULL, 0 },\n#endif\n#ifdef CAPSTONE_HAS_XCORE\n\tCS_ARCH_CONFIG_XCORE,\n#else\n\t{ NULL, NULL, 0 },\n#endif\n#ifdef CAPSTONE_HAS_M68K\n\tCS_ARCH_CONFIG_M68K,\n#else\n\t{ NULL, NULL, 0 },\n#endif\n#ifdef CAPSTONE_HAS_TMS320C64X\n\tCS_ARCH_CONFIG_TMS320C64X,\n#else\n\t{ NULL, NULL, 0 },\n#endif\n#ifdef CAPSTONE_HAS_M680X\n\tCS_ARCH_CONFIG_M680X,\n#else\n\t{ NULL, NULL, 0 },\n#endif\n#ifdef CAPSTONE_HAS_EVM\n\tCS_ARCH_CONFIG_EVM,\n#else\n\t{ NULL, NULL, 0 },\n#endif\n#ifdef CAPSTONE_HAS_MOS65XX\n\tCS_ARCH_CONFIG_MOS65XX,\n#else\n\t{ NULL, NULL, 0 },\n#endif\n#ifdef CAPSTONE_HAS_WASM\n\tCS_ARCH_CONFIG_WASM,\n#else\n\t{ NULL, NULL, 0 },\n#endif\n#ifdef CAPSTONE_HAS_BPF\n\tCS_ARCH_CONFIG_BPF,\n#else\n\t{ NULL, NULL, 0 },\n#endif\n#ifdef CAPSTONE_HAS_RISCV\n\tCS_ARCH_CONFIG_RISCV,\n#else\n\t{ NULL, NULL, 0 },\n#endif\n#ifdef CAPSTONE_HAS_SH\n\tCS_ARCH_CONFIG_SH,\n#else\n\t{ NULL, NULL, 0 },\n#endif\n#ifdef CAPSTONE_HAS_TRICORE\n\tCS_ARCH_CONFIG_TRICORE,\n#else\n\t{ NULL, NULL, 0 },\n#endif\n#ifdef CAPSTONE_HAS_ALPHA\n\tCS_ARCH_CONFIG_ALPHA,\n#else\n\t{ NULL, NULL, 0 },\n#endif\n#ifdef CAPSTONE_HAS_HPPA\n\t{\n\t\tHPPA_global_init,\n\t\tHPPA_option,\n\t\t~(CS_MODE_LITTLE_ENDIAN | CS_MODE_BIG_ENDIAN | CS_MODE_HPPA_11 |\n\t\t  CS_MODE_HPPA_20 | CS_MODE_HPPA_20W),\n\t},\n#else\n\t{ NULL, NULL, 0 },\n#endif\n#ifdef CAPSTONE_HAS_LOONGARCH\n\tCS_ARCH_CONFIG_LOONGARCH,\n#else\n\t{ NULL, NULL, 0 },\n#endif\n#ifdef CAPSTONE_HAS_XTENSA\n\tCS_ARCH_CONFIG_XTENSA\n#else\n\t{ NULL, NULL, 0 },\n#endif\n};\n\n// bitmask of enabled architectures\nstatic const uint32_t all_arch = 0\n#ifdef CAPSTONE_HAS_ARM\n\t\t\t\t | (1 << CS_ARCH_ARM)\n#endif\n#if defined(CAPSTONE_HAS_AARCH64) || defined(CAPSTONE_HAS_ARM64)\n\t\t\t\t | (1 << CS_ARCH_AARCH64)\n#endif\n#ifdef CAPSTONE_HAS_MIPS\n\t\t\t\t | (1 << CS_ARCH_MIPS)\n#endif\n#ifdef CAPSTONE_HAS_X86\n\t\t\t\t | (1 << CS_ARCH_X86)\n#endif\n#ifdef CAPSTONE_HAS_POWERPC\n\t\t\t\t | (1 << CS_ARCH_PPC)\n#endif\n#ifdef CAPSTONE_HAS_SPARC\n\t\t\t\t | (1 << CS_ARCH_SPARC)\n#endif\n#ifdef CAPSTONE_HAS_SYSTEMZ\n\t\t\t\t | (1 << CS_ARCH_SYSTEMZ)\n#endif\n#ifdef CAPSTONE_HAS_XCORE\n\t\t\t\t | (1 << CS_ARCH_XCORE)\n#endif\n#ifdef CAPSTONE_HAS_M68K\n\t\t\t\t | (1 << CS_ARCH_M68K)\n#endif\n#ifdef CAPSTONE_HAS_TMS320C64X\n\t\t\t\t | (1 << CS_ARCH_TMS320C64X)\n#endif\n#ifdef CAPSTONE_HAS_M680X\n\t\t\t\t | (1 << CS_ARCH_M680X)\n#endif\n#ifdef CAPSTONE_HAS_EVM\n\t\t\t\t | (1 << CS_ARCH_EVM)\n#endif\n#ifdef CAPSTONE_HAS_MOS65XX\n\t\t\t\t | (1 << CS_ARCH_MOS65XX)\n#endif\n#ifdef CAPSTONE_HAS_WASM\n\t\t\t\t | (1 << CS_ARCH_WASM)\n#endif\n#ifdef CAPSTONE_HAS_BPF\n\t\t\t\t | (1 << CS_ARCH_BPF)\n#endif\n#ifdef CAPSTONE_HAS_RISCV\n\t\t\t\t | (1 << CS_ARCH_RISCV)\n#endif\n#ifdef CAPSTONE_HAS_SH\n\t\t\t\t | (1 << CS_ARCH_SH)\n#endif\n#ifdef CAPSTONE_HAS_TRICORE\n\t\t\t\t | (1 << CS_ARCH_TRICORE)\n#endif\n#ifdef CAPSTONE_HAS_ALPHA\n\t\t\t\t | (1 << CS_ARCH_ALPHA)\n#endif\n#ifdef CAPSTONE_HAS_HPPA\n\t\t\t\t | (1 << CS_ARCH_HPPA)\n#endif\n#ifdef CAPSTONE_HAS_LOONGARCH\n\t\t\t\t | (1 << CS_ARCH_LOONGARCH)\n#endif\n#ifdef CAPSTONE_HAS_XTENSA\n\t\t\t\t | (1 << CS_ARCH_XTENSA)\n#endif\n\t;\n#endif\n\n\n#if defined(CAPSTONE_USE_SYS_DYN_MEM)\n#if !defined(CAPSTONE_HAS_OSXKERNEL) && !defined(_KERNEL_MODE)\n// default\ncs_malloc_t cs_mem_malloc = malloc;\ncs_calloc_t cs_mem_calloc = calloc;\ncs_realloc_t cs_mem_realloc = realloc;\ncs_free_t cs_mem_free = free;\n#if defined(_WIN32_WCE)\ncs_vsnprintf_t cs_vsnprintf = _vsnprintf;\n#else\ncs_vsnprintf_t cs_vsnprintf = vsnprintf;\n#endif  // defined(_WIN32_WCE)\n\n#elif defined(_KERNEL_MODE)\n// Windows driver\ncs_malloc_t cs_mem_malloc = cs_winkernel_malloc;\ncs_calloc_t cs_mem_calloc = cs_winkernel_calloc;\ncs_realloc_t cs_mem_realloc = cs_winkernel_realloc;\ncs_free_t cs_mem_free = cs_winkernel_free;\ncs_vsnprintf_t cs_vsnprintf = cs_winkernel_vsnprintf;\n#else\n// OSX kernel\nextern void* kern_os_malloc(size_t size);\nextern void kern_os_free(void* addr);\nextern void* kern_os_realloc(void* addr, size_t nsize);\n\nstatic void* cs_kern_os_calloc(size_t num, size_t size)\n{\n\treturn kern_os_malloc(num * size); // malloc bzeroes the buffer\n}\n\ncs_malloc_t cs_mem_malloc = kern_os_malloc;\ncs_calloc_t cs_mem_calloc = cs_kern_os_calloc;\ncs_realloc_t cs_mem_realloc = kern_os_realloc;\ncs_free_t cs_mem_free = kern_os_free;\ncs_vsnprintf_t cs_vsnprintf = vsnprintf;\n#endif  // !defined(CAPSTONE_HAS_OSXKERNEL) && !defined(_KERNEL_MODE)\n#else\n// User-defined\ncs_malloc_t cs_mem_malloc = NULL;\ncs_calloc_t cs_mem_calloc = NULL;\ncs_realloc_t cs_mem_realloc = NULL;\ncs_free_t cs_mem_free = NULL;\ncs_vsnprintf_t cs_vsnprintf = NULL;\n\n#endif  // defined(CAPSTONE_USE_SYS_DYN_MEM)\n\nCAPSTONE_EXPORT\nunsigned int CAPSTONE_API cs_version(int *major, int *minor)\n{\n\tif (major != NULL && minor != NULL) {\n\t\t*major = CS_API_MAJOR;\n\t\t*minor = CS_API_MINOR;\n\t}\n\n\treturn (CS_API_MAJOR << 8) + CS_API_MINOR;\n}\n\n#define CS_ARCH_REGISTER(id) \\\n\tcs_arch_config cfg = CS_ARCH_CONFIG_##id; \\\n\tarch_configs[CS_ARCH_##id] = cfg; \\\n\tall_arch |= 1 << CS_ARCH_##id\n\nCAPSTONE_EXPORT\nvoid CAPSTONE_API cs_arch_register_arm(void)\n{\n#if defined(CAPSTONE_USE_ARCH_REGISTRATION) && defined(CAPSTONE_HAS_ARM)\n\tCS_ARCH_REGISTER(ARM);\n#endif\n}\n\nCAPSTONE_EXPORT\nvoid CAPSTONE_API cs_arch_register_aarch64(void)\n{\n#if defined(CAPSTONE_USE_ARCH_REGISTRATION) && defined(CAPSTONE_HAS_AARCH64)\n\tCS_ARCH_REGISTER(AARCH64);\n#endif\n}\n\nCAPSTONE_EXPORT\nvoid CAPSTONE_API cs_arch_register_mips(void)\n{\n#if defined(CAPSTONE_USE_ARCH_REGISTRATION) && defined(CAPSTONE_HAS_MIPS)\n\tCS_ARCH_REGISTER(MIPS);\n#endif\n}\n\nCAPSTONE_EXPORT\nvoid CAPSTONE_API cs_arch_register_x86(void)\n{\n#if defined(CAPSTONE_USE_ARCH_REGISTRATION) && defined(CAPSTONE_HAS_X86)\n\tCS_ARCH_REGISTER(X86);\n#endif\n}\n\nCAPSTONE_EXPORT\nvoid CAPSTONE_API cs_arch_register_powerpc(void)\n{\n#if defined(CAPSTONE_USE_ARCH_REGISTRATION) && defined(CAPSTONE_HAS_POWERPC)\n\tCS_ARCH_REGISTER(PPC);\n#endif\n}\n\nCAPSTONE_EXPORT\nvoid CAPSTONE_API cs_arch_register_sparc(void)\n{\n#if defined(CAPSTONE_USE_ARCH_REGISTRATION) && defined(CAPSTONE_HAS_SPARC)\n\tCS_ARCH_REGISTER(SPARC);\n#endif\n}\n\nCAPSTONE_EXPORT\nvoid CAPSTONE_API cs_arch_register_systemz(void)\n{\n#if defined(CAPSTONE_USE_ARCH_REGISTRATION) && defined(CAPSTONE_HAS_SYSTEMZ)\n\tCS_ARCH_REGISTER(SYSTEMZ);\n#endif\n}\n\nCAPSTONE_EXPORT\nvoid CAPSTONE_API cs_arch_register_xcore(void)\n{\n#if defined(CAPSTONE_USE_ARCH_REGISTRATION) && defined(CAPSTONE_HAS_XCORE)\n\tCS_ARCH_REGISTER(XCORE);\n#endif\n}\n\nCAPSTONE_EXPORT\nvoid CAPSTONE_API cs_arch_register_m68k(void)\n{\n#if defined(CAPSTONE_USE_ARCH_REGISTRATION) && defined(CAPSTONE_HAS_M68K)\n\tCS_ARCH_REGISTER(M68K);\n#endif\n}\n\nCAPSTONE_EXPORT\nvoid CAPSTONE_API cs_arch_register_tms320c64x(void)\n{\n#if defined(CAPSTONE_USE_ARCH_REGISTRATION) && defined(CAPSTONE_HAS_TMS320C64X)\n\tCS_ARCH_REGISTER(TMS320C64X);\n#endif\n}\n\nCAPSTONE_EXPORT\nvoid CAPSTONE_API cs_arch_register_m680x(void)\n{\n#if defined(CAPSTONE_USE_ARCH_REGISTRATION) && defined(CAPSTONE_HAS_M680X)\n\tCS_ARCH_REGISTER(M680X);\n#endif\n}\n\nCAPSTONE_EXPORT\nvoid CAPSTONE_API cs_arch_register_evm(void)\n{\n#if defined(CAPSTONE_USE_ARCH_REGISTRATION) && defined(CAPSTONE_HAS_EVM)\n\tCS_ARCH_REGISTER(EVM);\n#endif\n}\n\nCAPSTONE_EXPORT\nvoid CAPSTONE_API cs_arch_register_mos65xx(void)\n{\n#if defined(CAPSTONE_USE_ARCH_REGISTRATION) && defined(CAPSTONE_HAS_MOS65XX)\n\tCS_ARCH_REGISTER(MOS65XX);\n#endif\n}\n\nCAPSTONE_EXPORT\nvoid CAPSTONE_API cs_arch_register_wasm(void)\n{\n#if defined(CAPSTONE_USE_ARCH_REGISTRATION) && defined(CAPSTONE_HAS_WASM)\n\tCS_ARCH_REGISTER(WASM);\n#endif\n}\n\nCAPSTONE_EXPORT\nvoid CAPSTONE_API cs_arch_register_bpf(void)\n{\n#if defined(CAPSTONE_USE_ARCH_REGISTRATION) && defined(CAPSTONE_HAS_BPF)\n\tCS_ARCH_REGISTER(BPF);\n#endif\n}\n\nCAPSTONE_EXPORT\nvoid CAPSTONE_API cs_arch_register_riscv(void)\n{\n#if defined(CAPSTONE_USE_ARCH_REGISTRATION) && defined(CAPSTONE_HAS_RISCV)\n\tCS_ARCH_REGISTER(RISCV);\n#endif\n}\n\nCAPSTONE_EXPORT\nvoid CAPSTONE_API cs_arch_register_sh(void)\n{\n#if defined(CAPSTONE_USE_ARCH_REGISTRATION) && defined(CAPSTONE_HAS_SH)\n\tCS_ARCH_REGISTER(SH);\n#endif\n}\n\nCAPSTONE_EXPORT\nvoid CAPSTONE_API cs_arch_register_tricore(void)\n{\n#if defined(CAPSTONE_USE_ARCH_REGISTRATION) && defined(CAPSTONE_HAS_TRICORE)\n\tCS_ARCH_REGISTER(TRICORE);\n#endif\n}\n\nCAPSTONE_EXPORT\nvoid CAPSTONE_API cs_arch_register_alpha(void)\n{\n#if defined(CAPSTONE_USE_ARCH_REGISTRATION) && defined(CAPSTONE_HAS_ALPHA)\n\tCS_ARCH_REGISTER(ALPHA);\n#endif\n}\n\nCAPSTONE_EXPORT\nvoid CAPSTONE_API cs_arch_register_loongarch(void)\n{\n#if defined(CAPSTONE_USE_ARCH_REGISTRATION) && defined(CAPSTONE_HAS_LOONGARCH)\n\tCS_ARCH_REGISTER(LOONGARCH);\n#endif\n}\n\nCAPSTONE_EXPORT\nbool CAPSTONE_API cs_support(int query)\n{\n\tif (query == CS_ARCH_ALL)\n\t\treturn all_arch ==\n\t\t       ((1 << CS_ARCH_ARM) | (1 << CS_ARCH_AARCH64) |\n\t\t\t(1 << CS_ARCH_MIPS) | (1 << CS_ARCH_X86) |\n\t\t\t(1 << CS_ARCH_PPC) | (1 << CS_ARCH_SPARC) |\n\t\t\t(1 << CS_ARCH_SYSTEMZ) | (1 << CS_ARCH_XCORE) |\n\t\t\t(1 << CS_ARCH_M68K) | (1 << CS_ARCH_TMS320C64X) |\n\t\t\t(1 << CS_ARCH_M680X) | (1 << CS_ARCH_EVM) |\n\t\t\t(1 << CS_ARCH_RISCV) | (1 << CS_ARCH_MOS65XX) |\n\t\t\t(1 << CS_ARCH_WASM) | (1 << CS_ARCH_BPF) |\n\t\t\t(1 << CS_ARCH_SH) | (1 << CS_ARCH_TRICORE) |\n\t\t\t(1 << CS_ARCH_ALPHA) | (1 << CS_ARCH_HPPA) |\n\t\t\t(1 << CS_ARCH_LOONGARCH) | (1 << CS_ARCH_XTENSA));\n\n\tif ((unsigned int)query < CS_ARCH_MAX)\n\t\treturn all_arch & (1 << query);\n\n\tif (query == CS_SUPPORT_DIET) {\n#ifdef CAPSTONE_DIET\n\t\treturn true;\n#else\n\t\treturn false;\n#endif\n\t}\n\n\tif (query == CS_SUPPORT_X86_REDUCE) {\n#if defined(CAPSTONE_HAS_X86) && defined(CAPSTONE_X86_REDUCE)\n\t\treturn true;\n#else\n\t\treturn false;\n#endif\n\t}\n\n\t// unsupported query\n\treturn false;\n}\n\nCAPSTONE_EXPORT\ncs_err CAPSTONE_API cs_errno(csh handle)\n{\n\tstruct cs_struct *ud;\n\tif (!handle)\n\t\treturn CS_ERR_CSH;\n\n\tud = (struct cs_struct *)(uintptr_t)handle;\n\n\treturn ud->errnum;\n}\n\nCAPSTONE_EXPORT\nconst char * CAPSTONE_API cs_strerror(cs_err code)\n{\n\tswitch(code) {\n\t\tdefault:\n\t\t\treturn \"Unknown error code\";\n\t\tcase CS_ERR_OK:\n\t\t\treturn \"OK (CS_ERR_OK)\";\n\t\tcase CS_ERR_MEM:\n\t\t\treturn \"Out of memory (CS_ERR_MEM)\";\n\t\tcase CS_ERR_ARCH:\n\t\t\treturn \"Invalid/unsupported architecture(CS_ERR_ARCH)\";\n\t\tcase CS_ERR_HANDLE:\n\t\t\treturn \"Invalid handle (CS_ERR_HANDLE)\";\n\t\tcase CS_ERR_CSH:\n\t\t\treturn \"Invalid csh (CS_ERR_CSH)\";\n\t\tcase CS_ERR_MODE:\n\t\t\treturn \"Invalid mode (CS_ERR_MODE)\";\n\t\tcase CS_ERR_OPTION:\n\t\t\treturn \"Invalid option (CS_ERR_OPTION)\";\n\t\tcase CS_ERR_DETAIL:\n\t\t\treturn \"Details are unavailable (CS_ERR_DETAIL)\";\n\t\tcase CS_ERR_MEMSETUP:\n\t\t\treturn \"Dynamic memory management uninitialized (CS_ERR_MEMSETUP)\";\n\t\tcase CS_ERR_VERSION:\n\t\t\treturn \"Different API version between core & binding (CS_ERR_VERSION)\";\n\t\tcase CS_ERR_DIET:\n\t\t\treturn \"Information irrelevant in diet engine (CS_ERR_DIET)\";\n\t\tcase CS_ERR_SKIPDATA:\n\t\t\treturn \"Information irrelevant for 'data' instruction in SKIPDATA mode (CS_ERR_SKIPDATA)\";\n\t\tcase CS_ERR_X86_ATT:\n\t\t\treturn \"AT&T syntax is unavailable (CS_ERR_X86_ATT)\";\n\t\tcase CS_ERR_X86_INTEL:\n\t\t\treturn \"INTEL syntax is unavailable (CS_ERR_X86_INTEL)\";\n\t\tcase CS_ERR_X86_MASM:\n\t\t\treturn \"MASM syntax is unavailable (CS_ERR_X86_MASM)\";\n\t}\n}\n\nCAPSTONE_EXPORT\ncs_err CAPSTONE_API cs_open(cs_arch arch, cs_mode mode, csh *handle)\n{\n\tcs_err err;\n\tstruct cs_struct *ud = NULL;\n\tif (!cs_mem_malloc || !cs_mem_calloc || !cs_mem_realloc || !cs_mem_free || !cs_vsnprintf)\n\t\t// Error: before cs_open(), dynamic memory management must be initialized\n\t\t// with cs_option(CS_OPT_MEM)\n\t\treturn CS_ERR_MEMSETUP;\n\n\tif (arch < CS_ARCH_MAX && arch_configs[arch].arch_init) {\n\t\t// verify if requested mode is valid\n\t\tif (mode & arch_configs[arch].arch_disallowed_mode_mask) {\n\t\t\t*handle = 0;\n\t\t\treturn CS_ERR_MODE;\n\t\t}\n\n\t\tud = cs_mem_calloc(1, sizeof(*ud));\n\t\tif (!ud) {\n\t\t\t// memory insufficient\n\t\t\treturn CS_ERR_MEM;\n\t\t}\n\n\t\tud->errnum = CS_ERR_OK;\n\t\tud->arch = arch;\n\t\tud->mode = mode;\n\t\t// by default, do not break instruction into details\n\t\tud->detail_opt = CS_OPT_OFF;\n\t\tud->PrintBranchImmAsAddress = true;\n\n\t\t// default skipdata setup\n\t\tud->skipdata_setup.mnemonic = SKIPDATA_MNEM;\n\n\t\terr = arch_configs[ud->arch].arch_init(ud);\n\t\tif (err) {\n\t\t\tcs_mem_free(ud);\n\t\t\t*handle = 0;\n\t\t\treturn err;\n\t\t}\n\n\t\t*handle = (uintptr_t)ud;\n\n\t\treturn CS_ERR_OK;\n\t} else {\n\t\tcs_mem_free(ud);\n\t\t*handle = 0;\n\t\treturn CS_ERR_ARCH;\n\t}\n}\n\nCAPSTONE_EXPORT\ncs_err CAPSTONE_API cs_close(csh *handle)\n{\n\tstruct cs_struct *ud = NULL;\n\tstruct insn_mnem *next = NULL, *tmp = NULL;\n\n\tif (*handle == 0)\n\t\t// invalid handle\n\t\treturn CS_ERR_CSH;\n\n\tud = (struct cs_struct *)(*handle);\n\n\tif (ud->printer_info)\n\t\tcs_mem_free(ud->printer_info);\n\n\t// free the linked list of customized mnemonic\n\ttmp = ud->mnem_list;\n\twhile(tmp) {\n\t\tnext = tmp->next;\n\t\tcs_mem_free(tmp);\n\t\ttmp = next;\n\t}\n\n\tcs_mem_free(ud->insn_cache);\n\n\tmemset(ud, 0, sizeof(*ud));\n\tcs_mem_free(ud);\n\n\t// invalidate this handle by ZERO out its value.\n\t// this is to make sure it is unusable after cs_close()\n\t*handle = 0;\n\n\treturn CS_ERR_OK;\n}\n\n/// replace str1 in target with str2; target starts with str1\n/// output is put into result (which is array of char with size CS_MNEMONIC_SIZE)\n/// return 0 on success, -1 on failure\n#ifndef CAPSTONE_DIET\nstatic int str_replace(char *result, char *target, const char *str1, char *str2)\n{\n\tsize_t target_len = strlen(target);\n\tsize_t str1_len = strlen(str1);\n\tif (target_len < str1_len) {\n\t\treturn -1;\n\t}\n\n\t// only perform replacement if the output fits into result\n\tif (target_len - str1_len + strlen(str2) <= CS_MNEMONIC_SIZE - 1)  {\n\t\t// copy str2 to beginning of result\n\t\t// skip str1 - already replaced by str2\n\t\tsnprintf(result, CS_MNEMONIC_SIZE, \"%s%s\", str2, target + str1_len);\n\n\t\treturn 0;\n\t} else\n\t\treturn -1;\n}\n#endif\n\n// fill insn with mnemonic & operands info\nstatic void fill_insn(struct cs_struct *handle, cs_insn *insn, SStream *OS, MCInst *mci,\n\t\tPostPrinter_t postprinter, const uint8_t *code)\n{\n#ifndef CAPSTONE_DIET\n\tchar *sp;\n#endif\n\tSStream_trimls(OS);\n\tuint16_t copy_size = MIN(sizeof(insn->bytes), insn->size);\n\n\t// fill the instruction bytes.\n\t// we might skip some redundant bytes in front in the case of X86\n\tmemcpy(insn->bytes, code + insn->size - copy_size, copy_size);\n\tinsn->op_str[0] = '\\0';\n\tinsn->size = copy_size;\n\n\t// alias instruction might have ID saved in OpcodePub\n\tif (MCInst_getOpcodePub(mci))\n\t\tinsn->id = MCInst_getOpcodePub(mci);\n\n\t// post printer handles some corner cases (hacky)\n\tif (postprinter)\n\t\tpostprinter((csh)handle, insn, OS, mci);\n\n#ifndef CAPSTONE_DIET\n\tmemset(insn->mnemonic, '\\0', sizeof(insn->mnemonic));\n\tmemset(insn->op_str, '\\0', sizeof(insn->op_str));\n\tSStream_extract_mnem_opstr(OS, insn->mnemonic, sizeof(insn->mnemonic), insn->op_str, sizeof(insn->op_str));\n\tfor (sp = insn->mnemonic; *sp; sp++) {\n\t\tif (*sp == '|')\t// lock|rep prefix for x86\n\t\t\t*sp = ' ';\n\t}\n\n\t// we might have customized mnemonic\n\tif (handle->mnem_list) {\n\t\tstruct insn_mnem *tmp = handle->mnem_list;\n\t\twhile(tmp) {\n\t\t\tif (tmp->insn.id == insn->id) {\n\t\t\t\tchar str[CS_MNEMONIC_SIZE] = { 0 };\n\n\t\t\t\tif (!str_replace(str, insn->mnemonic, cs_insn_name((csh)handle, insn->id), tmp->insn.mnemonic)) {\n\t\t\t\t\t// copy result to mnemonic\n\t\t\t\t\tCS_ASSERT_RET(sizeof(insn->mnemonic) == sizeof(str));\n\t\t\t\t\t(void)memcpy(insn->mnemonic, str, sizeof(insn->mnemonic));\n\t\t\t\t\tinsn->mnemonic[sizeof(insn->mnemonic) - 1] = '\\0';\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttmp = tmp->next;\n\t\t}\n\t}\n#endif\n}\n\n// how many bytes will we skip when encountering data (CS_OPT_SKIPDATA)?\n// this very much depends on instruction alignment requirement of each arch.\nstatic uint8_t skipdata_size(cs_struct *handle)\n{\n\tswitch(handle->arch) {\n\t\tdefault:\n\t\t\t// should never reach\n\t\t\treturn (uint8_t)-1;\n\t\tcase CS_ARCH_ARM:\n\t\t\t// skip 2 bytes on Thumb mode.\n\t\t\tif (handle->mode & CS_MODE_THUMB)\n\t\t\t\treturn 2;\n\t\t\t// otherwise, skip 4 bytes\n\t\t\treturn 4;\n\t\tcase CS_ARCH_AARCH64:\n\t\tcase CS_ARCH_MIPS:\n\t\tcase CS_ARCH_PPC:\n\t\tcase CS_ARCH_SPARC:\n\t\t\t// skip 4 bytes\n\t\t\treturn 4;\n\t\tcase CS_ARCH_SYSTEMZ:\n\t\t\t// SystemZ instruction's length can be 2, 4 or 6 bytes,\n\t\t\t// so we just skip 2 bytes\n\t\t\treturn 2;\n\t\tcase CS_ARCH_X86:\n\t\t\t// X86 has no restriction on instruction alignment\n\t\t\treturn 1;\n\t\tcase CS_ARCH_XCORE:\n\t\t\t// XCore instruction's length can be 2 or 4 bytes,\n\t\t\t// so we just skip 2 bytes\n\t\t\treturn 2;\n\t\tcase CS_ARCH_M68K:\n\t\t\t// M68K has 2 bytes instruction alignment but contain multibyte instruction so we skip 2 bytes\n\t\t\treturn 2;\n\t\tcase CS_ARCH_TMS320C64X:\n\t\t\t// TMS320C64x alignment is 4.\n\t\t\treturn 4;\n\t\tcase CS_ARCH_M680X:\n\t\t\t// M680X alignment is 1.\n\t\t\treturn 1;\n\t\tcase CS_ARCH_EVM:\n\t\t\t// EVM alignment is 1.\n\t\t\treturn 1;\n\t\tcase CS_ARCH_WASM:\n\t\t\t//WASM alignment is 1\n\t\t\treturn 1;\n\t\tcase CS_ARCH_MOS65XX:\n\t\t\t// MOS65XX alignment is 1.\n\t\t\treturn 1;\n\t\tcase CS_ARCH_BPF:\n\t\t\t// both classic and extended BPF have alignment 8.\n\t\t\treturn 8;\n\t\tcase CS_ARCH_RISCV:\n\t\t\t// special compress mode\n\t\t\tif (handle->mode & CS_MODE_RISCVC)\n\t\t\t\treturn 2;\n\t\t\treturn 4;\n\t\tcase CS_ARCH_SH:\n\t\t\treturn 2;\n\t\tcase CS_ARCH_TRICORE:\n\t\t\t// TriCore instruction's length can be 2 or 4 bytes,\n\t\t\t// so we just skip 2 bytes\n\t\t\treturn 2;\n\t\tcase CS_ARCH_ALPHA:\n\t\t\t// Alpha alignment is 4.\n\t\t\treturn 4;\n\t\tcase CS_ARCH_HPPA:\n\t\t\t// Hppa alignment is 4.\n\t\t\treturn 4;\n\t\tcase CS_ARCH_LOONGARCH:\n\t\t\t// LoongArch alignment is 4.\n\t\t\treturn 4;\n\t}\n}\n\nCAPSTONE_EXPORT\ncs_err CAPSTONE_API cs_option(csh ud, cs_opt_type type, size_t value)\n{\n\tstruct cs_struct *handle;\n\tcs_opt_mnem *opt;\n\n\t// cs_option() can be called with NULL handle just for CS_OPT_MEM\n\t// This is supposed to be executed before all other APIs (even cs_open())\n\tif (type == CS_OPT_MEM) {\n\t\tcs_opt_mem *mem = (cs_opt_mem *)value;\n\n\t\tcs_mem_malloc = mem->malloc;\n\t\tcs_mem_calloc = mem->calloc;\n\t\tcs_mem_realloc = mem->realloc;\n\t\tcs_mem_free = mem->free;\n\t\tcs_vsnprintf = mem->vsnprintf;\n\n\t\treturn CS_ERR_OK;\n\t}\n\n\thandle = (struct cs_struct *)(uintptr_t)ud;\n\tif (!handle)\n\t\treturn CS_ERR_CSH;\n\n\tswitch(type) {\n\t\tdefault:\n\t\t\tbreak;\n\n\t\tcase CS_OPT_UNSIGNED:\n\t\t\thandle->imm_unsigned = (cs_opt_value)value;\n\t\t\treturn CS_ERR_OK;\n\n\t\tcase CS_OPT_DETAIL:\n\t\t\thandle->detail_opt |= (cs_opt_value)value;\n\t\t\treturn CS_ERR_OK;\n\n\t\tcase CS_OPT_SKIPDATA:\n\t\t\thandle->skipdata = (value == CS_OPT_ON);\n\t\t\tif (handle->skipdata) {\n\t\t\t\tif (handle->skipdata_size == 0) {\n\t\t\t\t\t// set the default skipdata size\n\t\t\t\t\thandle->skipdata_size = skipdata_size(handle);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn CS_ERR_OK;\n\n\t\tcase CS_OPT_SKIPDATA_SETUP:\n\t\t\tif (value) {\n\t\t\t\thandle->skipdata_setup = *((cs_opt_skipdata *)value);\n\t\t\t\tif (handle->skipdata_setup.mnemonic == NULL) {\n\t\t\t\t\thandle->skipdata_setup.mnemonic = SKIPDATA_MNEM;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn CS_ERR_OK;\n\n\t\tcase CS_OPT_MNEMONIC:\n\t\t\topt = (cs_opt_mnem *)value;\n\t\t\tif (opt->id) {\n\t\t\t\tif (opt->mnemonic) {\n\t\t\t\t\tstruct insn_mnem *tmp;\n\n\t\t\t\t\t// add new instruction, or replace existing instruction\n\t\t\t\t\t// 1. find if we already had this insn in the linked list\n\t\t\t\t\ttmp = handle->mnem_list;\n\t\t\t\t\twhile(tmp) {\n\t\t\t\t\t\tif (tmp->insn.id == opt->id) {\n\t\t\t\t\t\t\t// found this instruction, so replace its mnemonic\n\t\t\t\t\t\t\t(void)strncpy(tmp->insn.mnemonic, opt->mnemonic, sizeof(tmp->insn.mnemonic) - 1);\n\t\t\t\t\t\t\ttmp->insn.mnemonic[sizeof(tmp->insn.mnemonic) - 1] = '\\0';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmp = tmp->next;\n\t\t\t\t\t}\n\n\t\t\t\t\t// 2. add this instruction if we have not had it yet\n\t\t\t\t\tif (!tmp) {\n\t\t\t\t\t\ttmp = cs_mem_malloc(sizeof(*tmp));\n\t\t\t\t\t\ttmp->insn.id = opt->id;\n\t\t\t\t\t\t(void)strncpy(tmp->insn.mnemonic, opt->mnemonic, sizeof(tmp->insn.mnemonic) - 1);\n\t\t\t\t\t\ttmp->insn.mnemonic[sizeof(tmp->insn.mnemonic) - 1] = '\\0';\n\t\t\t\t\t\t// this new instruction is heading the list\n\t\t\t\t\t\ttmp->next = handle->mnem_list;\n\t\t\t\t\t\thandle->mnem_list = tmp;\n\t\t\t\t\t}\n\t\t\t\t\treturn CS_ERR_OK;\n\t\t\t\t} else {\n\t\t\t\t\tstruct insn_mnem *prev, *tmp;\n\n\t\t\t\t\t// we want to delete an existing instruction\n\t\t\t\t\t// iterate the list to find the instruction to remove it\n\t\t\t\t\ttmp = handle->mnem_list;\n\t\t\t\t\tprev = tmp;\n\t\t\t\t\twhile(tmp) {\n\t\t\t\t\t\tif (tmp->insn.id == opt->id) {\n\t\t\t\t\t\t\t// delete this instruction\n\t\t\t\t\t\t\tif (tmp == prev) {\n\t\t\t\t\t\t\t\t// head of the list\n\t\t\t\t\t\t\t\thandle->mnem_list = tmp->next;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tprev->next = tmp->next;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcs_mem_free(tmp);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprev = tmp;\n\t\t\t\t\t\ttmp = tmp->next;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn CS_ERR_OK;\n\n\t\tcase CS_OPT_MODE:\n\t\t\t// verify if requested mode is valid\n\t\t\tif (value & arch_configs[handle->arch].arch_disallowed_mode_mask) {\n\t\t\t\treturn CS_ERR_OPTION;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CS_OPT_ONLY_OFFSET_BRANCH:\n\t\t\thandle->PrintBranchImmAsAddress = value == CS_OPT_ON ? false : true;\n\t\t\treturn CS_ERR_OK;\n\t}\n\n\tif (!arch_configs[handle->arch].arch_option)\n\t\treturn CS_ERR_ARCH;\n\n\treturn arch_configs[handle->arch].arch_option(handle, type, value);\n}\n\n// generate @op_str for data instruction of SKIPDATA\n#ifndef CAPSTONE_DIET\nstatic void skipdata_opstr(char *opstr, const uint8_t *buffer, size_t size)\n{\n\tchar *p = opstr;\n\tint len;\n\tsize_t i;\n\tsize_t available = sizeof(((cs_insn*)NULL)->op_str);\n\n\tif (!size) {\n\t\topstr[0] = '\\0';\n\t\treturn;\n\t}\n\n\tlen = cs_snprintf(p, available, \"0x%02x\", buffer[0]);\n\tp+= len;\n\tavailable -= len;\n\n\tfor(i = 1; i < size; i++) {\n\t\tlen = cs_snprintf(p, available, \", 0x%02x\", buffer[i]);\n\t\tif (len < 0) {\n\t\t\tbreak;\n\t\t}\n\t\tif ((size_t)len > available - 1) {\n\t\t\tbreak;\n\t\t}\n\t\tp+= len;\n\t\tavailable -= len;\n\t}\n}\n#endif\n\n// dynamically allocate memory to contain disasm insn\n// NOTE: caller must free() the allocated memory itself to avoid memory leaking\nCAPSTONE_EXPORT\nsize_t CAPSTONE_API cs_disasm(csh ud, const uint8_t *buffer, size_t size, uint64_t offset, size_t count, cs_insn **insn)\n{\n\tstruct cs_struct *handle;\n\tMCInst mci;\n\tuint16_t insn_size;\n\tsize_t c = 0, i;\n\tunsigned int f = 0;\t// index of the next instruction in the cache\n\tcs_insn *insn_cache;\t// cache contains disassembled instructions\n\tvoid *total = NULL;\n\tsize_t total_size = 0;\t// total size of output buffer containing all insns\n\tbool r;\n\tvoid *tmp;\n\tsize_t skipdata_bytes;\n\tuint64_t offset_org; // save all the original info of the buffer\n\tsize_t size_org;\n\tconst uint8_t *buffer_org;\n\tunsigned int cache_size = INSN_CACHE_SIZE;\n\tsize_t next_offset;\n\n\thandle = (struct cs_struct *)(uintptr_t)ud;\n\tif (!handle) {\n\t\t// FIXME: how to handle this case:\n\t\t// handle->errnum = CS_ERR_HANDLE;\n\t\treturn 0;\n\t}\n\n\thandle->errnum = CS_ERR_OK;\n\n#ifdef CAPSTONE_USE_SYS_DYN_MEM\n\tif (count > 0 && count <= INSN_CACHE_SIZE)\n\t\tcache_size = (unsigned int) count;\n#endif\n\n\t// save the original offset for SKIPDATA\n\tbuffer_org = buffer;\n\toffset_org = offset;\n\tsize_org = size;\n\n\ttotal_size = sizeof(cs_insn) * cache_size;\n\ttotal = cs_mem_calloc(sizeof(cs_insn), cache_size);\n\tif (total == NULL) {\n\t\t// insufficient memory\n\t\thandle->errnum = CS_ERR_MEM;\n\t\treturn 0;\n\t}\n\n\tinsn_cache = total;\n\n\twhile (size > 0) {\n\t\tMCInst_Init(&mci, handle->arch);\n\t\tmci.csh = handle;\n\n\t\t// relative branches need to know the address & size of current insn\n\t\tmci.address = offset;\n\n\t\tif (handle->detail_opt) {\n\t\t\t// allocate memory for @detail pointer\n\t\t\tinsn_cache->detail =\n\t\t\t\tcs_mem_calloc(1, sizeof(cs_detail));\n\t\t} else {\n\t\t\tinsn_cache->detail = NULL;\n\t\t}\n\n\t\t// save all the information for non-detailed mode\n\t\tmci.flat_insn = insn_cache;\n\t\tmci.flat_insn->address = offset;\n#ifdef CAPSTONE_DIET\n\t\t// zero out mnemonic & op_str\n\t\tmci.flat_insn->mnemonic[0] = '\\0';\n\t\tmci.flat_insn->op_str[0] = '\\0';\n#endif\n\n\t\tr = handle->disasm(ud, buffer, size, &mci, &insn_size, offset, handle->getinsn_info);\n\t\tif (r) {\n\t\t\tSStream ss;\n\t\t\tSStream_Init(&ss);\n\n\t\t\tmci.flat_insn->size = insn_size;\n\n\t\t\t// map internal instruction opcode to public insn ID\n\n\t\t\thandle->insn_id(handle, insn_cache, mci.Opcode);\n\n\t\t\thandle->printer(&mci, &ss, handle->printer_info);\n\t\t\tfill_insn(handle, insn_cache, &ss, &mci, handle->post_printer, buffer);\n\n\t\t\t// adjust for pseudo opcode (X86)\n\t\t\tif (handle->arch == CS_ARCH_X86 && insn_cache->id != X86_INS_VCMP)\n\t\t\t\tinsn_cache->id += mci.popcode_adjust;\n\n\t\t\tnext_offset = insn_size;\n\t\t} else\t{\n\t\t\t// encounter a broken instruction\n\n\t\t\t// free memory of @detail pointer\n\t\t\tif (handle->detail_opt) {\n\t\t\t\tcs_mem_free(insn_cache->detail);\n\t\t\t}\n\n\t\t\t// if there is no request to skip data, or remaining data is too small,\n\t\t\t// then bail out\n\t\t\tif (!handle->skipdata || handle->skipdata_size > size)\n\t\t\t\tbreak;\n\n\t\t\tif (handle->skipdata_setup.callback) {\n\t\t\t\tskipdata_bytes = handle->skipdata_setup.callback(buffer_org, size_org,\n\t\t\t\t\t\t(size_t)(offset - offset_org), handle->skipdata_setup.user_data);\n\t\t\t\tif (skipdata_bytes > size)\n\t\t\t\t\t// remaining data is not enough\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (!skipdata_bytes)\n\t\t\t\t\t// user requested not to skip data, so bail out\n\t\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\tskipdata_bytes = handle->skipdata_size;\n\n\t\t\t// we have to skip some amount of data, depending on arch & mode\n\t\t\tinsn_cache->id = 0;\t// invalid ID for this \"data\" instruction\n\t\t\tinsn_cache->address = offset;\n\t\t\tinsn_cache->size = (uint16_t)skipdata_bytes;\n\t\t\tmemcpy(insn_cache->bytes, buffer, skipdata_bytes);\n#ifdef CAPSTONE_DIET\n\t\t\tinsn_cache->mnemonic[0] = '\\0';\n\t\t\tinsn_cache->op_str[0] = '\\0';\n#else\n\t\t\tstrncpy(insn_cache->mnemonic, handle->skipdata_setup.mnemonic,\n\t\t\t\t\tsizeof(insn_cache->mnemonic) - 1);\n\t\t\tskipdata_opstr(insn_cache->op_str, buffer, skipdata_bytes);\n#endif\n\t\t\tinsn_cache->detail = NULL;\n\n\t\t\tnext_offset = skipdata_bytes;\n\t\t}\n\n\t\t// one more instruction entering the cache\n\t\tf++;\n\n\t\t// one more instruction disassembled\n\t\tc++;\n\t\tif (count > 0 && c == count)\n\t\t\t// already got requested number of instructions\n\t\t\tbreak;\n\n\t\tif (f == cache_size) {\n\t\t\t// full cache, so expand the cache to contain incoming insns\n\t\t\tcache_size = cache_size * 8 / 5; // * 1.6 ~ golden ratio\n\t\t\ttotal_size += (sizeof(cs_insn) * cache_size);\n\t\t\ttmp = cs_mem_realloc(total, total_size);\n\t\t\tif (tmp == NULL) {\t// insufficient memory\n\t\t\t\tif (handle->detail_opt) {\n\t\t\t\t\tinsn_cache = (cs_insn *)total;\n\t\t\t\t\tfor (i = 0; i < c; i++, insn_cache++)\n\t\t\t\t\t\tcs_mem_free(insn_cache->detail);\n\t\t\t\t}\n\n\t\t\t\tcs_mem_free(total);\n\t\t\t\t*insn = NULL;\n\t\t\t\thandle->errnum = CS_ERR_MEM;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\ttotal = tmp;\n\t\t\t// continue to fill in the cache after the last instruction\n\t\t\tinsn_cache = (cs_insn *)((char *)total + sizeof(cs_insn) * c);\n\n\t\t\t// reset f back to 0, so we fill in the cache from beginning\n\t\t\tf = 0;\n\t\t} else\n\t\t\tinsn_cache++;\n\n\t\tbuffer += next_offset;\n\t\tsize -= next_offset;\n\t\toffset += next_offset;\n\t}\n\n\tif (!c) {\n\t\t// we did not disassemble any instruction\n\t\tcs_mem_free(total);\n\t\ttotal = NULL;\n\t} else if (f != cache_size) {\n\t\t// total did not fully use the last cache, so downsize it\n\t\ttmp = cs_mem_realloc(total, total_size - (cache_size - f) * sizeof(*insn_cache));\n\t\tif (tmp == NULL) {\t// insufficient memory\n\t\t\t// free all detail pointers\n\t\t\tif (handle->detail_opt) {\n\t\t\t\tinsn_cache = (cs_insn *)total;\n\t\t\t\tfor (i = 0; i < c; i++, insn_cache++)\n\t\t\t\t\tcs_mem_free(insn_cache->detail);\n\t\t\t}\n\n\t\t\tcs_mem_free(total);\n\t\t\t*insn = NULL;\n\n\t\t\thandle->errnum = CS_ERR_MEM;\n\t\t\treturn 0;\n\t\t}\n\n\t\ttotal = tmp;\n\t}\n\n\t*insn = total;\n\n\treturn c;\n}\n\nCAPSTONE_EXPORT\nvoid CAPSTONE_API cs_free(cs_insn *insn, size_t count)\n{\n\tsize_t i;\n\n\t// free all detail pointers\n\tfor (i = 0; i < count; i++)\n\t\tcs_mem_free(insn[i].detail);\n\n\t// then free pointer to cs_insn array\n\tcs_mem_free(insn);\n}\n\nCAPSTONE_EXPORT\ncs_insn * CAPSTONE_API cs_malloc(csh ud)\n{\n\tcs_insn *insn;\n\tstruct cs_struct *handle = (struct cs_struct *)(uintptr_t)ud;\n\n\tinsn = cs_mem_malloc(sizeof(cs_insn));\n\tif (!insn) {\n\t\t// insufficient memory\n\t\thandle->errnum = CS_ERR_MEM;\n\t\treturn NULL;\n\t} else {\n\t\tif (handle->detail_opt) {\n\t\t\t// allocate memory for @detail pointer\n\t\t\tinsn->detail = cs_mem_malloc(sizeof(cs_detail));\n\t\t\tif (insn->detail == NULL) {\t// insufficient memory\n\t\t\t\tcs_mem_free(insn);\n\t\t\t\thandle->errnum = CS_ERR_MEM;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else\n\t\t\tinsn->detail = NULL;\n\t}\n\n\treturn insn;\n}\n\n// iterator for instruction \"single-stepping\"\nCAPSTONE_EXPORT\nbool CAPSTONE_API cs_disasm_iter(csh ud, const uint8_t **code, size_t *size,\n\t\tuint64_t *address, cs_insn *insn)\n{\n\tstruct cs_struct *handle;\n\tuint16_t insn_size;\n\tMCInst mci;\n\tbool r;\n\n\thandle = (struct cs_struct *)(uintptr_t)ud;\n\tif (!handle) {\n\t\treturn false;\n\t}\n\n\thandle->errnum = CS_ERR_OK;\n\n\tMCInst_Init(&mci, handle->arch);\n\tmci.csh = handle;\n\n\t// relative branches need to know the address & size of current insn\n\tmci.address = *address;\n\n\t// save all the information for non-detailed mode\n\tmci.flat_insn = insn;\n\tmci.flat_insn->address = *address;\n#ifdef CAPSTONE_DIET\n\t// zero out mnemonic & op_str\n\tmci.flat_insn->mnemonic[0] = '\\0';\n\tmci.flat_insn->op_str[0] = '\\0';\n#endif\n\n\tr = handle->disasm(ud, *code, *size, &mci, &insn_size, *address, handle->getinsn_info);\n\tif (r) {\n\t\tSStream ss;\n\t\tSStream_Init(&ss);\n\n\t\tmci.flat_insn->size = insn_size;\n\n\t\t// map internal instruction opcode to public insn ID\n\t\thandle->insn_id(handle, insn, mci.Opcode);\n\n\t\thandle->printer(&mci, &ss, handle->printer_info);\n\n\t\tfill_insn(handle, insn, &ss, &mci, handle->post_printer, *code);\n\n\t\t// adjust for pseudo opcode (X86)\n\t\tif (handle->arch == CS_ARCH_X86)\n\t\t\tinsn->id += mci.popcode_adjust;\n\n\t\t*code += insn_size;\n\t\t*size -= insn_size;\n\t\t*address += insn_size;\n\t} else { \t// encounter a broken instruction\n\t\tsize_t skipdata_bytes;\n\n\t\t// if there is no request to skip data, or remaining data is too small,\n\t\t// then bail out\n\t\tif (!handle->skipdata || handle->skipdata_size > *size)\n\t\t\treturn false;\n\n\t\tif (handle->skipdata_setup.callback) {\n\t\t\tskipdata_bytes = handle->skipdata_setup.callback(*code, *size,\n\t\t\t\t\t0, handle->skipdata_setup.user_data);\n\t\t\tif (skipdata_bytes > *size)\n\t\t\t\t// remaining data is not enough\n\t\t\t\treturn false;\n\n\t\t\tif (!skipdata_bytes)\n\t\t\t\t// user requested not to skip data, so bail out\n\t\t\t\treturn false;\n\t\t} else\n\t\t\tskipdata_bytes = handle->skipdata_size;\n\n\t\t// we have to skip some amount of data, depending on arch & mode\n\t\tinsn->id = 0;\t// invalid ID for this \"data\" instruction\n\t\tinsn->address = *address;\n\t\tinsn->size = (uint16_t)skipdata_bytes;\n#ifdef CAPSTONE_DIET\n\t\tinsn->mnemonic[0] = '\\0';\n\t\tinsn->op_str[0] = '\\0';\n#else\n\t\tmemcpy(insn->bytes, *code, skipdata_bytes);\n\t\tstrncpy(insn->mnemonic, handle->skipdata_setup.mnemonic,\n\t\t\t\tsizeof(insn->mnemonic) - 1);\n\t\tskipdata_opstr(insn->op_str, *code, skipdata_bytes);\n#endif\n\n\t\t*code += skipdata_bytes;\n\t\t*size -= skipdata_bytes;\n\t\t*address += skipdata_bytes;\n\t}\n\n\treturn true;\n}\n\n// return friendly name of register in a string\nCAPSTONE_EXPORT\nconst char * CAPSTONE_API cs_reg_name(csh ud, unsigned int reg)\n{\n\tstruct cs_struct *handle = (struct cs_struct *)(uintptr_t)ud;\n\n\tif (!handle || handle->reg_name == NULL) {\n\t\treturn NULL;\n\t}\n\n\treturn handle->reg_name(ud, reg);\n}\n\nCAPSTONE_EXPORT\nconst char * CAPSTONE_API cs_insn_name(csh ud, unsigned int insn)\n{\n\tstruct cs_struct *handle = (struct cs_struct *)(uintptr_t)ud;\n\n\tif (!handle || handle->insn_name == NULL) {\n\t\treturn NULL;\n\t}\n\n\treturn handle->insn_name(ud, insn);\n}\n\nCAPSTONE_EXPORT\nconst char * CAPSTONE_API cs_group_name(csh ud, unsigned int group)\n{\n\tstruct cs_struct *handle = (struct cs_struct *)(uintptr_t)ud;\n\n\tif (!handle || handle->group_name == NULL) {\n\t\treturn NULL;\n\t}\n\n\treturn handle->group_name(ud, group);\n}\n\nCAPSTONE_EXPORT\nbool CAPSTONE_API cs_insn_group(csh ud, const cs_insn *insn, unsigned int group_id)\n{\n\tstruct cs_struct *handle;\n\tif (!ud)\n\t\treturn false;\n\n\thandle = (struct cs_struct *)(uintptr_t)ud;\n\n\tif (!handle->detail_opt) {\n\t\thandle->errnum = CS_ERR_DETAIL;\n\t\treturn false;\n\t}\n\n\tif (!insn->id) {\n\t\thandle->errnum = CS_ERR_SKIPDATA;\n\t\treturn false;\n\t}\n\n\tif (!insn->detail) {\n\t\thandle->errnum = CS_ERR_DETAIL;\n\t\treturn false;\n\t}\n\n\treturn arr_exist8(insn->detail->groups, insn->detail->groups_count, group_id);\n}\n\nCAPSTONE_EXPORT\nbool CAPSTONE_API cs_reg_read(csh ud, const cs_insn *insn, unsigned int reg_id)\n{\n\tstruct cs_struct *handle;\n\tif (!ud)\n\t\treturn false;\n\n\thandle = (struct cs_struct *)(uintptr_t)ud;\n\n\tif (!handle->detail_opt) {\n\t\thandle->errnum = CS_ERR_DETAIL;\n\t\treturn false;\n\t}\n\n\tif (!insn->id) {\n\t\thandle->errnum = CS_ERR_SKIPDATA;\n\t\treturn false;\n\t}\n\n\tif (!insn->detail) {\n\t\thandle->errnum = CS_ERR_DETAIL;\n\t\treturn false;\n\t}\n\n\treturn arr_exist(insn->detail->regs_read, insn->detail->regs_read_count, reg_id);\n}\n\nCAPSTONE_EXPORT\nbool CAPSTONE_API cs_reg_write(csh ud, const cs_insn *insn, unsigned int reg_id)\n{\n\tstruct cs_struct *handle;\n\tif (!ud)\n\t\treturn false;\n\n\thandle = (struct cs_struct *)(uintptr_t)ud;\n\n\tif (!handle->detail_opt) {\n\t\thandle->errnum = CS_ERR_DETAIL;\n\t\treturn false;\n\t}\n\n\tif (!insn->id) {\n\t\thandle->errnum = CS_ERR_SKIPDATA;\n\t\treturn false;\n\t}\n\n\tif (!insn->detail) {\n\t\thandle->errnum = CS_ERR_DETAIL;\n\t\treturn false;\n\t}\n\n\treturn arr_exist(insn->detail->regs_write, insn->detail->regs_write_count, reg_id);\n}\n\nCAPSTONE_EXPORT\nint CAPSTONE_API cs_op_count(csh ud, const cs_insn *insn, unsigned int op_type)\n{\n\tstruct cs_struct *handle;\n\tunsigned int count = 0, i;\n\tif (!ud)\n\t\treturn -1;\n\n\thandle = (struct cs_struct *)(uintptr_t)ud;\n\n\tif (!handle->detail_opt) {\n\t\thandle->errnum = CS_ERR_DETAIL;\n\t\treturn -1;\n\t}\n\n\tif (!insn->id) {\n\t\thandle->errnum = CS_ERR_SKIPDATA;\n\t\treturn -1;\n\t}\n\n\tif (!insn->detail) {\n\t\thandle->errnum = CS_ERR_DETAIL;\n\t\treturn -1;\n\t}\n\n\thandle->errnum = CS_ERR_OK;\n\n\tswitch (handle->arch) {\n\t\tdefault:\n\t\t\thandle->errnum = CS_ERR_HANDLE;\n\t\t\treturn -1;\n\t\tcase CS_ARCH_ARM:\n\t\t\tfor (i = 0; i < insn->detail->arm.op_count; i++)\n\t\t\t\tif (insn->detail->arm.operands[i].type == (arm_op_type)op_type)\n\t\t\t\t\tcount++;\n\t\t\tbreak;\n\t\tcase CS_ARCH_AARCH64:\n\t\t\tfor (i = 0; i < insn->detail->aarch64.op_count; i++)\n\t\t\t\tif (insn->detail->aarch64.operands[i].type == (aarch64_op_type)op_type)\n\t\t\t\t\tcount++;\n\t\t\tbreak;\n\t\tcase CS_ARCH_X86:\n\t\t\tfor (i = 0; i < insn->detail->x86.op_count; i++)\n\t\t\t\tif (insn->detail->x86.operands[i].type == (x86_op_type)op_type)\n\t\t\t\t\tcount++;\n\t\t\tbreak;\n\t\tcase CS_ARCH_MIPS:\n\t\t\tfor (i = 0; i < insn->detail->mips.op_count; i++)\n\t\t\t\tif (insn->detail->mips.operands[i].type == (mips_op_type)op_type)\n\t\t\t\t\tcount++;\n\t\t\tbreak;\n\t\tcase CS_ARCH_PPC:\n\t\t\tfor (i = 0; i < insn->detail->ppc.op_count; i++)\n\t\t\t\tif (insn->detail->ppc.operands[i].type == (ppc_op_type)op_type)\n\t\t\t\t\tcount++;\n\t\t\tbreak;\n\t\tcase CS_ARCH_SPARC:\n\t\t\tfor (i = 0; i < insn->detail->sparc.op_count; i++)\n\t\t\t\tif (insn->detail->sparc.operands[i].type == (sparc_op_type)op_type)\n\t\t\t\t\tcount++;\n\t\t\tbreak;\n\t\tcase CS_ARCH_SYSTEMZ:\n\t\t\tfor (i = 0; i < insn->detail->systemz.op_count; i++)\n\t\t\t\tif (insn->detail->systemz.operands[i].type == (systemz_op_type)op_type)\n\t\t\t\t\tcount++;\n\t\t\tbreak;\n\t\tcase CS_ARCH_XCORE:\n\t\t\tfor (i = 0; i < insn->detail->xcore.op_count; i++)\n\t\t\t\tif (insn->detail->xcore.operands[i].type == (xcore_op_type)op_type)\n\t\t\t\t\tcount++;\n\t\t\tbreak;\n\t\tcase CS_ARCH_M68K:\n\t\t\tfor (i = 0; i < insn->detail->m68k.op_count; i++)\n\t\t\t\tif (insn->detail->m68k.operands[i].type == (m68k_op_type)op_type)\n\t\t\t\t\tcount++;\n\t\t\tbreak;\n\t\tcase CS_ARCH_TMS320C64X:\n\t\t\tfor (i = 0; i < insn->detail->tms320c64x.op_count; i++)\n\t\t\t\tif (insn->detail->tms320c64x.operands[i].type == (tms320c64x_op_type)op_type)\n\t\t\t\t\tcount++;\n\t\t\tbreak;\n\t\tcase CS_ARCH_M680X:\n\t\t\tfor (i = 0; i < insn->detail->m680x.op_count; i++)\n\t\t\t\tif (insn->detail->m680x.operands[i].type == (m680x_op_type)op_type)\n\t\t\t\t\tcount++;\n\t\t\tbreak;\n\t\tcase CS_ARCH_EVM:\n\t\t\tbreak;\n\t\tcase CS_ARCH_MOS65XX:\n\t\t\tfor (i = 0; i < insn->detail->mos65xx.op_count; i++)\n\t\t\t\tif (insn->detail->mos65xx.operands[i].type == (mos65xx_op_type)op_type)\n\t\t\t\t\tcount++;\n\t\t\tbreak;\n\t\tcase CS_ARCH_WASM:\n\t\t\tfor (i = 0; i < insn->detail->wasm.op_count; i++)\n\t\t\t\tif (insn->detail->wasm.operands[i].type == (wasm_op_type)op_type)\n\t\t\t\t\tcount++;\n\t\t\tbreak;\n\t\tcase CS_ARCH_BPF:\n\t\t\tfor (i = 0; i < insn->detail->bpf.op_count; i++)\n\t\t\t\tif (insn->detail->bpf.operands[i].type == (bpf_op_type)op_type)\n\t\t\t\t\tcount++;\n\t\t\tbreak;\n\t\tcase CS_ARCH_RISCV:\n\t\t\tfor (i = 0; i < insn->detail->riscv.op_count; i++)\n\t\t\t\tif (insn->detail->riscv.operands[i].type == (riscv_op_type)op_type)\n\t\t\t\t\tcount++;\n\t\t\tbreak;\n\t\tcase CS_ARCH_TRICORE:\n\t\t\tfor (i = 0; i < insn->detail->tricore.op_count; i++)\n\t\t\t\tif (insn->detail->tricore.operands[i].type == (tricore_op_type)op_type)\n\t\t\t\t\tcount++;\n\t\t\tbreak;\n\t\tcase CS_ARCH_ALPHA:\n\t\t\tfor (i = 0; i < insn->detail->alpha.op_count; i++)\n\t\t\t\tif (insn->detail->alpha.operands[i].type == (alpha_op_type)op_type)\n\t\t\t\t\tcount++;\n\t\t\tbreak;\n\t\tcase CS_ARCH_HPPA:\n\t\t\tfor (i = 0; i < insn->detail->hppa.op_count; i++)\n\t\t\t\tif (insn->detail->hppa.operands[i].type == (hppa_op_type)op_type)\n\t\t\t\t\tcount++;\n\t\t\tbreak;\n\t\tcase CS_ARCH_LOONGARCH:\n\t\t\tfor (i = 0; i < insn->detail->loongarch.op_count; i++)\n\t\t\t\tif (insn->detail->loongarch.operands[i].type == (loongarch_op_type)op_type)\n\t\t\t\t\tcount++;\n\t\t\tbreak;\n\t}\n\n\treturn count;\n}\n\nCAPSTONE_EXPORT\nint CAPSTONE_API cs_op_index(csh ud, const cs_insn *insn, unsigned int op_type,\n\t\tunsigned int post)\n{\n\tstruct cs_struct *handle;\n\tunsigned int count = 0, i;\n\tif (!ud)\n\t\treturn -1;\n\n\thandle = (struct cs_struct *)(uintptr_t)ud;\n\n\tif (!handle->detail_opt) {\n\t\thandle->errnum = CS_ERR_DETAIL;\n\t\treturn -1;\n\t}\n\n\tif (!insn->id) {\n\t\thandle->errnum = CS_ERR_SKIPDATA;\n\t\treturn -1;\n\t}\n\n\tif (!insn->detail) {\n\t\thandle->errnum = CS_ERR_DETAIL;\n\t\treturn -1;\n\t}\n\n\thandle->errnum = CS_ERR_OK;\n\n\tswitch (handle->arch) {\n\t\tdefault:\n\t\t\thandle->errnum = CS_ERR_HANDLE;\n\t\t\treturn -1;\n\t\tcase CS_ARCH_ARM:\n\t\t\tfor (i = 0; i < insn->detail->arm.op_count; i++) {\n\t\t\t\tif (insn->detail->arm.operands[i].type == (arm_op_type)op_type)\n\t\t\t\t\tcount++;\n\t\t\t\tif (count == post)\n\t\t\t\t\treturn i;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CS_ARCH_AARCH64:\n\t\t\tfor (i = 0; i < insn->detail->aarch64.op_count; i++) {\n\t\t\t\tif (insn->detail->aarch64.operands[i].type == (aarch64_op_type)op_type)\n\t\t\t\t\tcount++;\n\t\t\t\tif (count == post)\n\t\t\t\t\treturn i;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CS_ARCH_X86:\n\t\t\tfor (i = 0; i < insn->detail->x86.op_count; i++) {\n\t\t\t\tif (insn->detail->x86.operands[i].type == (x86_op_type)op_type)\n\t\t\t\t\tcount++;\n\t\t\t\tif (count == post)\n\t\t\t\t\treturn i;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CS_ARCH_MIPS:\n\t\t\tfor (i = 0; i < insn->detail->mips.op_count; i++) {\n\t\t\t\tif (insn->detail->mips.operands[i].type == (mips_op_type)op_type)\n\t\t\t\t\tcount++;\n\t\t\t\tif (count == post)\n\t\t\t\t\treturn i;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CS_ARCH_PPC:\n\t\t\tfor (i = 0; i < insn->detail->ppc.op_count; i++) {\n\t\t\t\tif (insn->detail->ppc.operands[i].type == (ppc_op_type)op_type)\n\t\t\t\t\tcount++;\n\t\t\t\tif (count == post)\n\t\t\t\t\treturn i;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CS_ARCH_SPARC:\n\t\t\tfor (i = 0; i < insn->detail->sparc.op_count; i++) {\n\t\t\t\tif (insn->detail->sparc.operands[i].type == (sparc_op_type)op_type)\n\t\t\t\t\tcount++;\n\t\t\t\tif (count == post)\n\t\t\t\t\treturn i;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CS_ARCH_SYSTEMZ:\n\t\t\tfor (i = 0; i < insn->detail->systemz.op_count; i++) {\n\t\t\t\tif (insn->detail->systemz.operands[i].type == (systemz_op_type)op_type)\n\t\t\t\t\tcount++;\n\t\t\t\tif (count == post)\n\t\t\t\t\treturn i;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CS_ARCH_XCORE:\n\t\t\tfor (i = 0; i < insn->detail->xcore.op_count; i++) {\n\t\t\t\tif (insn->detail->xcore.operands[i].type == (xcore_op_type)op_type)\n\t\t\t\t\tcount++;\n\t\t\t\tif (count == post)\n\t\t\t\t\treturn i;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CS_ARCH_TRICORE:\n\t\t\tfor (i = 0; i < insn->detail->tricore.op_count; i++) {\n\t\t\t\tif (insn->detail->tricore.operands[i].type == (tricore_op_type)op_type)\n\t\t\t\t\tcount++;\n\t\t\t\tif (count == post)\n\t\t\t\t\treturn i;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CS_ARCH_M68K:\n\t\t\tfor (i = 0; i < insn->detail->m68k.op_count; i++) {\n\t\t\t\tif (insn->detail->m68k.operands[i].type == (m68k_op_type)op_type)\n\t\t\t\t\tcount++;\n\t\t\t\tif (count == post)\n\t\t\t\t\treturn i;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CS_ARCH_TMS320C64X:\n\t\t\tfor (i = 0; i < insn->detail->tms320c64x.op_count; i++) {\n\t\t\t\tif (insn->detail->tms320c64x.operands[i].type == (tms320c64x_op_type)op_type)\n\t\t\t\t\tcount++;\n\t\t\t\tif (count == post)\n\t\t\t\t\treturn i;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CS_ARCH_M680X:\n\t\t\tfor (i = 0; i < insn->detail->m680x.op_count; i++) {\n\t\t\t\tif (insn->detail->m680x.operands[i].type == (m680x_op_type)op_type)\n\t\t\t\t\tcount++;\n\t\t\t\tif (count == post)\n\t\t\t\t\treturn i;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CS_ARCH_EVM:\n#if 0\n\t\t\tfor (i = 0; i < insn->detail->evm.op_count; i++) {\n\t\t\t\tif (insn->detail->evm.operands[i].type == (evm_op_type)op_type)\n\t\t\t\t\tcount++;\n\t\t\t\tif (count == post)\n\t\t\t\t\treturn i;\n\t\t\t}\n#endif\n\t\t\tbreak;\n\t\tcase CS_ARCH_MOS65XX:\n\t\t\tfor (i = 0; i < insn->detail->mos65xx.op_count; i++) {\n\t\t\t\tif (insn->detail->mos65xx.operands[i].type == (mos65xx_op_type)op_type)\n\t\t\t\t\tcount++;\n\t\t\t\tif (count == post)\n\t\t\t\t\treturn i;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CS_ARCH_WASM:\n\t\t\tfor (i = 0; i < insn->detail->wasm.op_count; i++) {\n\t\t\t\tif (insn->detail->wasm.operands[i].type == (wasm_op_type)op_type)\n\t\t\t\t\tcount++;\n\t\t\t\tif (count == post)\n\t\t\t\t\treturn i;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CS_ARCH_BPF:\n\t\t\tfor (i = 0; i < insn->detail->bpf.op_count; i++) {\n\t\t\t\tif (insn->detail->bpf.operands[i].type == (bpf_op_type)op_type)\n\t\t\t\t\tcount++;\n\t\t\t\tif (count == post)\n\t\t\t\t\treturn i;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CS_ARCH_RISCV:\n\t\t\tfor (i = 0; i < insn->detail->riscv.op_count; i++) {\n\t\t\t\tif (insn->detail->riscv.operands[i].type == (riscv_op_type)op_type)\n\t\t\t\t\tcount++;\n\t\t\t\tif (count == post)\n\t\t\t\t\treturn i;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CS_ARCH_SH:\n\t\t\tfor (i = 0; i < insn->detail->sh.op_count; i++) {\n\t\t\t\tif (insn->detail->sh.operands[i].type == (sh_op_type)op_type)\n\t\t\t\t\tcount++;\n\t\t\t\tif (count == post)\n\t\t\t\t\treturn i;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CS_ARCH_ALPHA:\n\t\t\tfor (i = 0; i < insn->detail->alpha.op_count; i++) {\n\t\t\t\tif (insn->detail->alpha.operands[i].type == (alpha_op_type)op_type)\n\t\t\t\t\tcount++;\n\t\t\t\tif (count == post)\n\t\t\t\t\treturn i;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CS_ARCH_HPPA:\n\t\t\tfor (i = 0; i < insn->detail->hppa.op_count; i++) {\n\t\t\t\tif (insn->detail->hppa.operands[i].type == (hppa_op_type)op_type)\n\t\t\t\t\tcount++;\n\t\t\t\tif (count == post)\n\t\t\t\t\treturn i;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CS_ARCH_LOONGARCH:\n\t\t\tfor (i = 0; i < insn->detail->loongarch.op_count; i++) {\n\t\t\t\tif (insn->detail->loongarch.operands[i].type == (loongarch_op_type)op_type)\n\t\t\t\t\tcount++;\n\t\t\t\tif (count == post)\n\t\t\t\t\treturn i;\n\t\t\t}\n\t\t\tbreak;\n\t}\n\n\treturn -1;\n}\n\nCAPSTONE_EXPORT\ncs_err CAPSTONE_API cs_regs_access(csh ud, const cs_insn *insn,\n\t\tcs_regs regs_read, uint8_t *regs_read_count,\n\t\tcs_regs regs_write, uint8_t *regs_write_count)\n{\n\tstruct cs_struct *handle;\n\n\tif (!ud)\n\t\treturn CS_ERR_CSH;\n\n\thandle = (struct cs_struct *)(uintptr_t)ud;\n\n#ifdef CAPSTONE_DIET\n\t// This API does not work in DIET mode\n\thandle->errnum = CS_ERR_DIET;\n\treturn CS_ERR_DIET;\n#else\n\tif (!handle->detail_opt) {\n\t\thandle->errnum = CS_ERR_DETAIL;\n\t\treturn CS_ERR_DETAIL;\n\t}\n\n\tif (!insn->id) {\n\t\thandle->errnum = CS_ERR_SKIPDATA;\n\t\treturn CS_ERR_SKIPDATA;\n\t}\n\n\tif (!insn->detail) {\n\t\thandle->errnum = CS_ERR_DETAIL;\n\t\treturn CS_ERR_DETAIL;\n\t}\n\n\tif (handle->reg_access) {\n\t\thandle->reg_access(insn, regs_read, regs_read_count, regs_write, regs_write_count);\n\t} else {\n\t\t// this arch is unsupported yet\n\t\thandle->errnum = CS_ERR_ARCH;\n\t\treturn CS_ERR_ARCH;\n\t}\n\n\treturn CS_ERR_OK;\n#endif\n}\n"
        },
        {
          "name": "cs_priv.h",
          "type": "blob",
          "size": 4.2158203125,
          "content": "/* Capstone Disassembly Engine */\n/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2019 */\n\n#ifndef CS_PRIV_H\n#define CS_PRIV_H\n\n#ifdef CAPSTONE_DEBUG\n#include <assert.h>\n#endif\n#include <capstone/capstone.h>\n\n#include \"MCInst.h\"\n#include \"SStream.h\"\n\ntypedef void (*Printer_t)(MCInst *MI, SStream *OS, void *info);\n\n// function to be called after Printer_t\n// this is the best time to gather insn's characteristics\ntypedef void (*PostPrinter_t)(csh handle, cs_insn *, SStream *mnem, MCInst *mci);\n\ntypedef bool (*Disasm_t)(csh handle, const uint8_t *code, size_t code_len, MCInst *instr, uint16_t *size, uint64_t address, void *info);\n\ntypedef const char *(*GetName_t)(csh handle, unsigned int id);\n\ntypedef void (*GetID_t)(cs_struct *h, cs_insn *insn, unsigned int id);\n\n// return registers accessed by instruction\ntypedef void (*GetRegisterAccess_t)(const cs_insn *insn,\n\t\tcs_regs regs_read, uint8_t *regs_read_count,\n\t\tcs_regs regs_write, uint8_t *regs_write_count);\n\n// for ARM only\ntypedef struct ARM_ITBlock {\n\tunsigned char ITStates[8];\n\tunsigned int size;\n} ARM_ITBlock;\n\ntypedef struct ARM_VPTBlock {\n\tunsigned char VPTStates[8];\n\tunsigned int size;\n} ARM_VPTBlock;\n\n// Customize mnemonic for instructions with alternative name.\nstruct customized_mnem {\n\t// ID of instruction to be customized.\n\tunsigned int id;\n\t// Customized instruction mnemonic.\n\tchar mnemonic[CS_MNEMONIC_SIZE];\n};\n\nstruct insn_mnem {\n\tstruct customized_mnem insn;\n\tstruct insn_mnem *next;\t// linked list of customized mnemonics\n};\n\nstruct cs_struct {\n\tcs_arch arch;\n\tcs_mode mode;\n\tPrinter_t printer;\t// asm printer\n\tvoid *printer_info; // aux info for printer\n\tDisasm_t disasm;\t// disassembler\n\tvoid *getinsn_info; // auxiliary info for printer\n\tGetName_t reg_name;\n\tGetName_t insn_name;\n\tGetName_t group_name;\n\tGetID_t insn_id;\n\tPostPrinter_t post_printer;\n\tcs_err errnum;\n\tARM_ITBlock ITBlock;\t// for Arm only\n\tARM_VPTBlock VPTBlock;  // for ARM only\n\tbool PrintBranchImmAsAddress;\n\tbool ShowVSRNumsAsVR;\n\tcs_opt_value detail_opt, imm_unsigned;\n\tint syntax;\t// asm syntax for simple printer such as ARM, Mips & PPC\n\tbool doing_mem;\t// handling memory operand in InstPrinter code\n\tbool doing_SME_Index; // handling a SME instruction that has index\n\tunsigned short *insn_cache;\t// index caching for mapping.c\n\tbool skipdata;\t// set this to True if we skip data when disassembling\n\tuint8_t skipdata_size;\t// how many bytes to skip\n\tcs_opt_skipdata skipdata_setup;\t// user-defined skipdata setup\n\tconst uint8_t *regsize_map;\t// map to register size (x86-only for now)\n\tGetRegisterAccess_t reg_access;\n\tstruct insn_mnem *mnem_list;\t// linked list of customized instruction mnemonic\n\tuint32_t LITBASE; ///< The LITBASE register content. Bit 0 (LSB) indicatess if it is set. Bit[23:8] are the literal base address.\n};\n\n#define MAX_ARCH CS_ARCH_MAX\n\n// Returns a bool (0 or 1) whether big endian is enabled for a mode\n#define MODE_IS_BIG_ENDIAN(mode) (((mode) & CS_MODE_BIG_ENDIAN) != 0)\n\n/// Returns true of the 16bit flag is set.\n#define IS_16BIT(mode) ((mode & CS_MODE_16) != 0)\n/// Returns true of the 32bit flag is set.\n#define IS_32BIT(mode) ((mode & CS_MODE_32) != 0)\n/// Returns true of the 64bit flag is set.\n#define IS_64BIT(mode) ((mode & CS_MODE_64) != 0)\n\nextern cs_malloc_t cs_mem_malloc;\nextern cs_calloc_t cs_mem_calloc;\nextern cs_realloc_t cs_mem_realloc;\nextern cs_free_t cs_mem_free;\nextern cs_vsnprintf_t cs_vsnprintf;\n\n/// By defining CAPSTONE_DEBUG assertions can be used.\n/// For the release build the @expr is not included.\n#ifdef CAPSTONE_DEBUG\n#define CS_ASSERT(expr) assert(expr)\n#else\n#define CS_ASSERT(expr)\n#endif\n\n/// If compiled in debug mode it will assert(@expr).\n/// In the release build it will check the @expr and return @val if false.\n#ifdef CAPSTONE_DEBUG\n#define CS_ASSERT_RET_VAL(expr, val) assert(expr)\n#else\n#define CS_ASSERT_RET_VAL(expr, val) \\\ndo { \\\n\tif (!(expr)) { \\\n\t\tfprintf(stderr, \"Hit assert: \" #expr \"\\n\"); \\\n\t\treturn val; \\\n\t} \\\n} while(0)\n#endif\n\n/// If compiled in debug mode it will assert(@expr).\n/// In the release build it will check the @expr and return if false.\n#ifdef CAPSTONE_DEBUG\n#define CS_ASSERT_RET(expr) assert(expr)\n#else\n#define CS_ASSERT_RET(expr) \\\ndo { \\\n\tif (!(expr)) { \\\n\t\tfprintf(stderr, \"Hit assert: \" #expr \"\\n\"); \\\n\t\treturn; \\\n\t} \\\n} while(0)\n#endif\n\n#endif\n"
        },
        {
          "name": "cs_simple_types.h",
          "type": "blob",
          "size": 27.9306640625,
          "content": "/* Capstone Disassembly Engine, https://www.capstone-engine.org */\n/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2019 */\n/* By Rot127 <unisono@quyllur.org>, 2023 */\n\n/* This header file mirrors LLVMs MachineValueTypes.h. */\n\n#ifndef CS_SIMPLE_TYPES_H\n#define CS_SIMPLE_TYPES_H\n\n#include <assert.h>\n#include <stdbool.h>\n\ntypedef enum {\n\n\t// Simple value types that aren't explicitly part of this enumeration\n\t// are considered extended value types.\n\tCS_DATA_TYPE_INVALID_SIMPLE_VALUE_TYPE = 0,\n\n\t// If you change this numbering, you must change the values in\n\t// ValueTypes.td as well!\n\tCS_DATA_TYPE_Other = 1, // This is a non-standard value\n\tCS_DATA_TYPE_i1 = 2,\t// This is a 1 bit integer value\n\tCS_DATA_TYPE_i2 = 3,\t// This is a 2 bit integer value\n\tCS_DATA_TYPE_i4 = 4,\t// This is a 4 bit integer value\n\tCS_DATA_TYPE_i8 = 5,\t// This is an 8 bit integer value\n\tCS_DATA_TYPE_i16 = 6,\t// This is a 16 bit integer value\n\tCS_DATA_TYPE_i32 = 7,\t// This is a 32 bit integer value\n\tCS_DATA_TYPE_i64 = 8,\t// This is a 64 bit integer value\n\tCS_DATA_TYPE_i128 = 9,\t// This is a 128 bit integer value\n\n\tCS_DATA_TYPE_FIRST_INTEGER_VALUETYPE = CS_DATA_TYPE_i1,\n\tCS_DATA_TYPE_LAST_INTEGER_VALUETYPE = CS_DATA_TYPE_i128,\n\n\tCS_DATA_TYPE_bf16 = 10, // This is a 16 bit brain floating point value\n\tCS_DATA_TYPE_f16 = 11,\t// This is a 16 bit floating point value\n\tCS_DATA_TYPE_f32 = 12,\t// This is a 32 bit floating point value\n\tCS_DATA_TYPE_f64 = 13,\t// This is a 64 bit floating point value\n\tCS_DATA_TYPE_f80 = 14,\t// This is a 80 bit floating point value\n\tCS_DATA_TYPE_f128 = 15, // This is a 128 bit floating point value\n\tCS_DATA_TYPE_ppcf128 = 16, // This is a PPC 128-bit floating point value\n\n\tCS_DATA_TYPE_FIRST_FP_VALUETYPE = CS_DATA_TYPE_bf16,\n\tCS_DATA_TYPE_LAST_FP_VALUETYPE = CS_DATA_TYPE_ppcf128,\n\n\tCS_DATA_TYPE_v1i1 = 17,\t    //    1 x i1\n\tCS_DATA_TYPE_v2i1 = 18,\t    //    2 x i1\n\tCS_DATA_TYPE_v4i1 = 19,\t    //    4 x i1\n\tCS_DATA_TYPE_v8i1 = 20,\t    //    8 x i1\n\tCS_DATA_TYPE_v16i1 = 21,    //   16 x i1\n\tCS_DATA_TYPE_v32i1 = 22,    //   32 x i1\n\tCS_DATA_TYPE_v64i1 = 23,    //   64 x i1\n\tCS_DATA_TYPE_v128i1 = 24,   //  128 x i1\n\tCS_DATA_TYPE_v256i1 = 25,   //  256 x i1\n\tCS_DATA_TYPE_v512i1 = 26,   //  512 x i1\n\tCS_DATA_TYPE_v1024i1 = 27,  // 1024 x i1\n\tCS_DATA_TYPE_v2048i1 = 28,  // 2048 x i1\n\n\tCS_DATA_TYPE_v128i2 = 29,   //  128 x i2\n\tCS_DATA_TYPE_v256i2 = 30,   //  256 x i2\n\n\tCS_DATA_TYPE_v64i4 = 31,    //   64 x i4\n\tCS_DATA_TYPE_v128i4 = 32,   //  128 x i4\n\n\tCS_DATA_TYPE_v1i8 = 33,\t    //    1 x i8\n\tCS_DATA_TYPE_v2i8 = 34,\t    //    2 x i8\n\tCS_DATA_TYPE_v4i8 = 35,\t    //    4 x i8\n\tCS_DATA_TYPE_v8i8 = 36,\t    //    8 x i8\n\tCS_DATA_TYPE_v16i8 = 37,    //   16 x i8\n\tCS_DATA_TYPE_v32i8 = 38,    //   32 x i8\n\tCS_DATA_TYPE_v64i8 = 39,    //   64 x i8\n\tCS_DATA_TYPE_v128i8 = 40,   //  128 x i8\n\tCS_DATA_TYPE_v256i8 = 41,   //  256 x i8\n\tCS_DATA_TYPE_v512i8 = 42,   //  512 x i8\n\tCS_DATA_TYPE_v1024i8 = 43,  // 1024 x i8\n\n\tCS_DATA_TYPE_v1i16 = 44,    //   1 x i16\n\tCS_DATA_TYPE_v2i16 = 45,    //   2 x i16\n\tCS_DATA_TYPE_v3i16 = 46,    //   3 x i16\n\tCS_DATA_TYPE_v4i16 = 47,    //   4 x i16\n\tCS_DATA_TYPE_v8i16 = 48,    //   8 x i16\n\tCS_DATA_TYPE_v16i16 = 49,   //  16 x i16\n\tCS_DATA_TYPE_v32i16 = 50,   //  32 x i16\n\tCS_DATA_TYPE_v64i16 = 51,   //  64 x i16\n\tCS_DATA_TYPE_v128i16 = 52,  // 128 x i16\n\tCS_DATA_TYPE_v256i16 = 53,  // 256 x i16\n\tCS_DATA_TYPE_v512i16 = 54,  // 512 x i16\n\n\tCS_DATA_TYPE_v1i32 = 55,    //    1 x i32\n\tCS_DATA_TYPE_v2i32 = 56,    //    2 x i32\n\tCS_DATA_TYPE_v3i32 = 57,    //    3 x i32\n\tCS_DATA_TYPE_v4i32 = 58,    //    4 x i32\n\tCS_DATA_TYPE_v5i32 = 59,    //    5 x i32\n\tCS_DATA_TYPE_v6i32 = 60,    //    6 x i32\n\tCS_DATA_TYPE_v7i32 = 61,    //    7 x i32\n\tCS_DATA_TYPE_v8i32 = 62,    //    8 x i32\n\tCS_DATA_TYPE_v9i32 = 63,    //    9 x i32\n\tCS_DATA_TYPE_v10i32 = 64,   //   10 x i32\n\tCS_DATA_TYPE_v11i32 = 65,   //   11 x i32\n\tCS_DATA_TYPE_v12i32 = 66,   //   12 x i32\n\tCS_DATA_TYPE_v16i32 = 67,   //   16 x i32\n\tCS_DATA_TYPE_v32i32 = 68,   //   32 x i32\n\tCS_DATA_TYPE_v64i32 = 69,   //   64 x i32\n\tCS_DATA_TYPE_v128i32 = 70,  //  128 x i32\n\tCS_DATA_TYPE_v256i32 = 71,  //  256 x i32\n\tCS_DATA_TYPE_v512i32 = 72,  //  512 x i32\n\tCS_DATA_TYPE_v1024i32 = 73, // 1024 x i32\n\tCS_DATA_TYPE_v2048i32 = 74, // 2048 x i32\n\n\tCS_DATA_TYPE_v1i64 = 75,    //   1 x i64\n\tCS_DATA_TYPE_v2i64 = 76,    //   2 x i64\n\tCS_DATA_TYPE_v3i64 = 77,    //   3 x i64\n\tCS_DATA_TYPE_v4i64 = 78,    //   4 x i64\n\tCS_DATA_TYPE_v8i64 = 79,    //   8 x i64\n\tCS_DATA_TYPE_v16i64 = 80,   //  16 x i64\n\tCS_DATA_TYPE_v32i64 = 81,   //  32 x i64\n\tCS_DATA_TYPE_v64i64 = 82,   //  64 x i64\n\tCS_DATA_TYPE_v128i64 = 83,  // 128 x i64\n\tCS_DATA_TYPE_v256i64 = 84,  // 256 x i64\n\n\tCS_DATA_TYPE_v1i128 = 85,   //  1 x i128\n\n\tCS_DATA_TYPE_FIRST_INTEGER_FIXEDLEN_VECTOR_VALUETYPE =\n\t\tCS_DATA_TYPE_v1i1,\n\tCS_DATA_TYPE_LAST_INTEGER_FIXEDLEN_VECTOR_VALUETYPE =\n\t\tCS_DATA_TYPE_v1i128,\n\n\tCS_DATA_TYPE_v1f16 = 86,     //    1 x f16\n\tCS_DATA_TYPE_v2f16 = 87,     //    2 x f16\n\tCS_DATA_TYPE_v3f16 = 88,     //    3 x f16\n\tCS_DATA_TYPE_v4f16 = 89,     //    4 x f16\n\tCS_DATA_TYPE_v8f16 = 90,     //    8 x f16\n\tCS_DATA_TYPE_v16f16 = 91,    //   16 x f16\n\tCS_DATA_TYPE_v32f16 = 92,    //   32 x f16\n\tCS_DATA_TYPE_v64f16 = 93,    //   64 x f16\n\tCS_DATA_TYPE_v128f16 = 94,   //  128 x f16\n\tCS_DATA_TYPE_v256f16 = 95,   //  256 x f16\n\tCS_DATA_TYPE_v512f16 = 96,   //  512 x f16\n\n\tCS_DATA_TYPE_v2bf16 = 97,    //    2 x bf16\n\tCS_DATA_TYPE_v3bf16 = 98,    //    3 x bf16\n\tCS_DATA_TYPE_v4bf16 = 99,    //    4 x bf16\n\tCS_DATA_TYPE_v8bf16 = 100,   //    8 x bf16\n\tCS_DATA_TYPE_v16bf16 = 101,  //   16 x bf16\n\tCS_DATA_TYPE_v32bf16 = 102,  //   32 x bf16\n\tCS_DATA_TYPE_v64bf16 = 103,  //   64 x bf16\n\tCS_DATA_TYPE_v128bf16 = 104, //  128 x bf16\n\n\tCS_DATA_TYPE_v1f32 = 105,    //    1 x f32\n\tCS_DATA_TYPE_v2f32 = 106,    //    2 x f32\n\tCS_DATA_TYPE_v3f32 = 107,    //    3 x f32\n\tCS_DATA_TYPE_v4f32 = 108,    //    4 x f32\n\tCS_DATA_TYPE_v5f32 = 109,    //    5 x f32\n\tCS_DATA_TYPE_v6f32 = 110,    //    6 x f32\n\tCS_DATA_TYPE_v7f32 = 111,    //    7 x f32\n\tCS_DATA_TYPE_v8f32 = 112,    //    8 x f32\n\tCS_DATA_TYPE_v9f32 = 113,    //    9 x f32\n\tCS_DATA_TYPE_v10f32 = 114,   //   10 x f32\n\tCS_DATA_TYPE_v11f32 = 115,   //   11 x f32\n\tCS_DATA_TYPE_v12f32 = 116,   //   12 x f32\n\tCS_DATA_TYPE_v16f32 = 117,   //   16 x f32\n\n\tCS_DATA_TYPE_v32f32 = 118,   //   32 x f32\n\tCS_DATA_TYPE_v64f32 = 119,   //   64 x f32\n\tCS_DATA_TYPE_v128f32 = 120,  //  128 x f32\n\tCS_DATA_TYPE_v256f32 = 121,  //  256 x f32\n\tCS_DATA_TYPE_v512f32 = 122,  //  512 x f32\n\tCS_DATA_TYPE_v1024f32 = 123, // 1024 x f32\n\tCS_DATA_TYPE_v2048f32 = 124, // 2048 x f32\n\n\tCS_DATA_TYPE_v1f64 = 125,    //    1 x f64\n\tCS_DATA_TYPE_v2f64 = 126,    //    2 x f64\n\tCS_DATA_TYPE_v3f64 = 127,    //    3 x f64\n\tCS_DATA_TYPE_v4f64 = 128,    //    4 x f64\n\tCS_DATA_TYPE_v8f64 = 129,    //    8 x f64\n\tCS_DATA_TYPE_v16f64 = 130,   //   16 x f64\n\tCS_DATA_TYPE_v32f64 = 131,   //   32 x f64\n\tCS_DATA_TYPE_v64f64 = 132,   //   64 x f64\n\tCS_DATA_TYPE_v128f64 = 133,  //  128 x f64\n\tCS_DATA_TYPE_v256f64 = 134,  //  256 x f64\n\n\tCS_DATA_TYPE_FIRST_FP_FIXEDLEN_VECTOR_VALUETYPE = CS_DATA_TYPE_v1f16,\n\tCS_DATA_TYPE_LAST_FP_FIXEDLEN_VECTOR_VALUETYPE = CS_DATA_TYPE_v256f64,\n\n\tCS_DATA_TYPE_FIRST_FIXEDLEN_VECTOR_VALUETYPE = CS_DATA_TYPE_v1i1,\n\tCS_DATA_TYPE_LAST_FIXEDLEN_VECTOR_VALUETYPE = CS_DATA_TYPE_v256f64,\n\n\tCS_DATA_TYPE_nxv1i1 = 135,   // n x  1 x i1\n\tCS_DATA_TYPE_nxv2i1 = 136,   // n x  2 x i1\n\tCS_DATA_TYPE_nxv4i1 = 137,   // n x  4 x i1\n\tCS_DATA_TYPE_nxv8i1 = 138,   // n x  8 x i1\n\tCS_DATA_TYPE_nxv16i1 = 139,  // n x 16 x i1\n\tCS_DATA_TYPE_nxv32i1 = 140,  // n x 32 x i1\n\tCS_DATA_TYPE_nxv64i1 = 141,  // n x 64 x i1\n\n\tCS_DATA_TYPE_nxv1i8 = 142,   // n x  1 x i8\n\tCS_DATA_TYPE_nxv2i8 = 143,   // n x  2 x i8\n\tCS_DATA_TYPE_nxv4i8 = 144,   // n x  4 x i8\n\tCS_DATA_TYPE_nxv8i8 = 145,   // n x  8 x i8\n\tCS_DATA_TYPE_nxv16i8 = 146,  // n x 16 x i8\n\tCS_DATA_TYPE_nxv32i8 = 147,  // n x 32 x i8\n\tCS_DATA_TYPE_nxv64i8 = 148,  // n x 64 x i8\n\n\tCS_DATA_TYPE_nxv1i16 = 149,  // n x  1 x i16\n\tCS_DATA_TYPE_nxv2i16 = 150,  // n x  2 x i16\n\tCS_DATA_TYPE_nxv4i16 = 151,  // n x  4 x i16\n\tCS_DATA_TYPE_nxv8i16 = 152,  // n x  8 x i16\n\tCS_DATA_TYPE_nxv16i16 = 153, // n x 16 x i16\n\tCS_DATA_TYPE_nxv32i16 = 154, // n x 32 x i16\n\n\tCS_DATA_TYPE_nxv1i32 = 155,  // n x  1 x i32\n\tCS_DATA_TYPE_nxv2i32 = 156,  // n x  2 x i32\n\tCS_DATA_TYPE_nxv4i32 = 157,  // n x  4 x i32\n\tCS_DATA_TYPE_nxv8i32 = 158,  // n x  8 x i32\n\tCS_DATA_TYPE_nxv16i32 = 159, // n x 16 x i32\n\tCS_DATA_TYPE_nxv32i32 = 160, // n x 32 x i32\n\n\tCS_DATA_TYPE_nxv1i64 = 161,  // n x  1 x i64\n\tCS_DATA_TYPE_nxv2i64 = 162,  // n x  2 x i64\n\tCS_DATA_TYPE_nxv4i64 = 163,  // n x  4 x i64\n\tCS_DATA_TYPE_nxv8i64 = 164,  // n x  8 x i64\n\tCS_DATA_TYPE_nxv16i64 = 165, // n x 16 x i64\n\tCS_DATA_TYPE_nxv32i64 = 166, // n x 32 x i64\n\n\tCS_DATA_TYPE_FIRST_INTEGER_SCALABLE_VECTOR_VALUETYPE =\n\t\tCS_DATA_TYPE_nxv1i1,\n\tCS_DATA_TYPE_LAST_INTEGER_SCALABLE_VECTOR_VALUETYPE =\n\t\tCS_DATA_TYPE_nxv32i64,\n\n\tCS_DATA_TYPE_nxv1f16 = 167,   // n x  1 x f16\n\tCS_DATA_TYPE_nxv2f16 = 168,   // n x  2 x f16\n\tCS_DATA_TYPE_nxv4f16 = 169,   // n x  4 x f16\n\tCS_DATA_TYPE_nxv8f16 = 170,   // n x  8 x f16\n\tCS_DATA_TYPE_nxv16f16 = 171,  // n x 16 x f16\n\tCS_DATA_TYPE_nxv32f16 = 172,  // n x 32 x f16\n\n\tCS_DATA_TYPE_nxv1bf16 = 173,  // n x  1 x bf16\n\tCS_DATA_TYPE_nxv2bf16 = 174,  // n x  2 x bf16\n\tCS_DATA_TYPE_nxv4bf16 = 175,  // n x  4 x bf16\n\tCS_DATA_TYPE_nxv8bf16 = 176,  // n x  8 x bf16\n\tCS_DATA_TYPE_nxv16bf16 = 177, // n x 16 x bf16\n\tCS_DATA_TYPE_nxv32bf16 = 178, // n x 32 x bf16\n\n\tCS_DATA_TYPE_nxv1f32 = 179,   // n x  1 x f32\n\tCS_DATA_TYPE_nxv2f32 = 180,   // n x  2 x f32\n\tCS_DATA_TYPE_nxv4f32 = 181,   // n x  4 x f32\n\tCS_DATA_TYPE_nxv8f32 = 182,   // n x  8 x f32\n\tCS_DATA_TYPE_nxv16f32 = 183,  // n x 16 x f32\n\n\tCS_DATA_TYPE_nxv1f64 = 184,   // n x  1 x f64\n\tCS_DATA_TYPE_nxv2f64 = 185,   // n x  2 x f64\n\tCS_DATA_TYPE_nxv4f64 = 186,   // n x  4 x f64\n\tCS_DATA_TYPE_nxv8f64 = 187,   // n x  8 x f64\n\n\tCS_DATA_TYPE_FIRST_FP_SCALABLE_VECTOR_VALUETYPE = CS_DATA_TYPE_nxv1f16,\n\tCS_DATA_TYPE_LAST_FP_SCALABLE_VECTOR_VALUETYPE = CS_DATA_TYPE_nxv8f64,\n\n\tCS_DATA_TYPE_FIRST_SCALABLE_VECTOR_VALUETYPE = CS_DATA_TYPE_nxv1i1,\n\tCS_DATA_TYPE_LAST_SCALABLE_VECTOR_VALUETYPE = CS_DATA_TYPE_nxv8f64,\n\n\tCS_DATA_TYPE_FIRST_VECTOR_VALUETYPE = CS_DATA_TYPE_v1i1,\n\tCS_DATA_TYPE_LAST_VECTOR_VALUETYPE = CS_DATA_TYPE_nxv8f64,\n\n\tCS_DATA_TYPE_x86mmx = 188, // This is an X86 MMX value\n\n\tCS_DATA_TYPE_Glue =\n\t\t189, // This glues nodes together during pre-RA sched\n\n\tCS_DATA_TYPE_isVoid = 190,  // This has no value\n\n\tCS_DATA_TYPE_Untyped = 191, // This value takes a register, but has\n\t// unspecified type.  The register class\n\t// will be determined by the opcode.\n\n\tCS_DATA_TYPE_funcref = 192,   // WebAssembly's funcref type\n\tCS_DATA_TYPE_externref = 193, // WebAssembly's externref type\n\tCS_DATA_TYPE_x86amx = 194,    // This is an X86 AMX value\n\tCS_DATA_TYPE_i64x8 = 195,     // 8 Consecutive GPRs (AArch64)\n\tCS_DATA_TYPE_aarch64svcount = 196,// AArch64, Value is of a scalable size\n\n\tCS_DATA_TYPE_FIRST_VALUETYPE =\n\t\t1,\t\t    // This is always the beginning of the list.\n\tCS_DATA_TYPE_LAST_VALUETYPE =\n\t\tCS_DATA_TYPE_i64x8, // This always remains at the end of the list.\n\tCS_DATA_TYPE_VALUETYPE_SIZE = CS_DATA_TYPE_LAST_VALUETYPE + 1,\n\n\t// This is the current maximum for LAST_VALUETYPE.\n\t// MVT::MAX_ALLOWED_VALUETYPE is used for asserts and to size bit vectors\n\t// This value must be a multiple of 32.\n\tCS_DATA_TYPE_MAX_ALLOWED_VALUETYPE = 224,\n\n\t// A value of type llvm::TokenTy\n\tCS_DATA_TYPE_token = 248,\n\n\t// This is MDNode or MDString.\n\tCS_DATA_TYPE_Metadata = 249,\n\n\t// An int value the size of the pointer of the current\n\t// target to any address space. This must only be used internal to\n\t// tblgen. Other than for overloading, we treat iPTRAny the same as iPTR.\n\tCS_DATA_TYPE_iPTRAny = 250,\n\n\t// A vector with any length and element size. This is used\n\t// for intrinsics that have overloadings based on vector types.\n\t// This is only for tblgen's consumption!\n\tCS_DATA_TYPE_vAny = 251,\n\n\t// Any floating-point or vector floating-point value. This is used\n\t// for intrinsics that have overloadings based on floating-point types.\n\t// This is only for tblgen's consumption!\n\tCS_DATA_TYPE_fAny = 252,\n\n\t// An integer or vector integer value of any bit width. This is\n\t// used for intrinsics that have overloadings based on integer bit widths.\n\t// This is only for tblgen's consumption!\n\tCS_DATA_TYPE_iAny = 253,\n\n\t// An int value the size of the pointer of the current\n\t// target.  This should only be used internal to tblgen!\n\tCS_DATA_TYPE_iPTR = 254,\n\n\t// Last element in enum.\n\tCS_DATA_TYPE_LAST = 255\n} cs_data_type;\n\n/// Return true if this is a valid simple valuetype.\nstatic inline bool isValid(cs_data_type SimpleTy)\n{\n\treturn (SimpleTy >= CS_DATA_TYPE_FIRST_VALUETYPE &&\n\t\tSimpleTy <= CS_DATA_TYPE_LAST_VALUETYPE);\n}\n\n/// Return true if this is a FP or a vector FP type.\nstatic inline bool isFloatingPoint(cs_data_type SimpleTy)\n{\n\treturn ((SimpleTy >= CS_DATA_TYPE_FIRST_FP_VALUETYPE &&\n\t\t SimpleTy <= CS_DATA_TYPE_LAST_FP_VALUETYPE) ||\n\t\t(SimpleTy >= CS_DATA_TYPE_FIRST_FP_FIXEDLEN_VECTOR_VALUETYPE &&\n\t\t SimpleTy <= CS_DATA_TYPE_LAST_FP_FIXEDLEN_VECTOR_VALUETYPE) ||\n\t\t(SimpleTy >= CS_DATA_TYPE_FIRST_FP_SCALABLE_VECTOR_VALUETYPE &&\n\t\t SimpleTy <= CS_DATA_TYPE_LAST_FP_SCALABLE_VECTOR_VALUETYPE));\n}\n\n/// Return true if this is an integer or a vector integer type.\nstatic inline bool isInteger(cs_data_type SimpleTy)\n{\n\treturn ((SimpleTy >= CS_DATA_TYPE_FIRST_INTEGER_VALUETYPE &&\n\t\t SimpleTy <= CS_DATA_TYPE_LAST_INTEGER_VALUETYPE) ||\n\t\t(SimpleTy >=\n\t\t\t CS_DATA_TYPE_FIRST_INTEGER_FIXEDLEN_VECTOR_VALUETYPE &&\n\t\t SimpleTy <=\n\t\t\t CS_DATA_TYPE_LAST_INTEGER_FIXEDLEN_VECTOR_VALUETYPE) ||\n\t\t(SimpleTy >=\n\t\t\t CS_DATA_TYPE_FIRST_INTEGER_SCALABLE_VECTOR_VALUETYPE &&\n\t\t SimpleTy <=\n\t\t\t CS_DATA_TYPE_LAST_INTEGER_SCALABLE_VECTOR_VALUETYPE));\n}\n\n/// Return true if this is an integer, not including vectors.\nstatic inline bool isScalarInteger(cs_data_type SimpleTy)\n{\n\treturn (SimpleTy >= CS_DATA_TYPE_FIRST_INTEGER_VALUETYPE &&\n\t\tSimpleTy <= CS_DATA_TYPE_LAST_INTEGER_VALUETYPE);\n}\n\n/// Return true if this is a vector value type.\nstatic inline bool isVector(cs_data_type SimpleTy)\n{\n\treturn (SimpleTy >= CS_DATA_TYPE_FIRST_VECTOR_VALUETYPE &&\n\t\tSimpleTy <= CS_DATA_TYPE_LAST_VECTOR_VALUETYPE);\n}\n\n/// Return true if this is a vector value type where the\n/// runtime length is machine dependent\nstatic inline bool isScalableVector(cs_data_type SimpleTy)\n{\n\treturn (SimpleTy >= CS_DATA_TYPE_FIRST_SCALABLE_VECTOR_VALUETYPE &&\n\t\tSimpleTy <= CS_DATA_TYPE_LAST_SCALABLE_VECTOR_VALUETYPE);\n}\n\nstatic inline bool isFixedLengthVector(cs_data_type SimpleTy)\n{\n\treturn (SimpleTy >= CS_DATA_TYPE_FIRST_FIXEDLEN_VECTOR_VALUETYPE &&\n\t\tSimpleTy <= CS_DATA_TYPE_LAST_FIXEDLEN_VECTOR_VALUETYPE);\n}\n\n/// Return true if this is a 16-bit vector type.\nstatic inline bool is16BitVector(cs_data_type SimpleTy)\n{\n\treturn (SimpleTy == CS_DATA_TYPE_v2i8 ||\n\t\tSimpleTy == CS_DATA_TYPE_v1i16 ||\n\t\tSimpleTy == CS_DATA_TYPE_v16i1 ||\n\t\tSimpleTy == CS_DATA_TYPE_v1f16);\n}\n\n/// Return true if this is a 32-bit vector type.\nstatic inline bool is32BitVector(cs_data_type SimpleTy)\n{\n\treturn (SimpleTy == CS_DATA_TYPE_v32i1 ||\n\t\tSimpleTy == CS_DATA_TYPE_v4i8 ||\n\t\tSimpleTy == CS_DATA_TYPE_v2i16 ||\n\t\tSimpleTy == CS_DATA_TYPE_v1i32 ||\n\t\tSimpleTy == CS_DATA_TYPE_v2f16 ||\n\t\tSimpleTy == CS_DATA_TYPE_v2bf16 ||\n\t\tSimpleTy == CS_DATA_TYPE_v1f32);\n}\n\n/// Return true if this is a 64-bit vector type.\nstatic inline bool is64BitVector(cs_data_type SimpleTy)\n{\n\treturn (SimpleTy == CS_DATA_TYPE_v64i1 ||\n\t\tSimpleTy == CS_DATA_TYPE_v8i8 ||\n\t\tSimpleTy == CS_DATA_TYPE_v4i16 ||\n\t\tSimpleTy == CS_DATA_TYPE_v2i32 ||\n\t\tSimpleTy == CS_DATA_TYPE_v1i64 ||\n\t\tSimpleTy == CS_DATA_TYPE_v4f16 ||\n\t\tSimpleTy == CS_DATA_TYPE_v4bf16 ||\n\t\tSimpleTy == CS_DATA_TYPE_v2f32 ||\n\t\tSimpleTy == CS_DATA_TYPE_v1f64);\n}\n\n/// Return true if this is a 128-bit vector type.\nstatic inline bool is128BitVector(cs_data_type SimpleTy)\n{\n\treturn (SimpleTy == CS_DATA_TYPE_v128i1 ||\n\t\tSimpleTy == CS_DATA_TYPE_v16i8 ||\n\t\tSimpleTy == CS_DATA_TYPE_v8i16 ||\n\t\tSimpleTy == CS_DATA_TYPE_v4i32 ||\n\t\tSimpleTy == CS_DATA_TYPE_v2i64 ||\n\t\tSimpleTy == CS_DATA_TYPE_v1i128 ||\n\t\tSimpleTy == CS_DATA_TYPE_v8f16 ||\n\t\tSimpleTy == CS_DATA_TYPE_v8bf16 ||\n\t\tSimpleTy == CS_DATA_TYPE_v4f32 ||\n\t\tSimpleTy == CS_DATA_TYPE_v2f64);\n}\n\n/// Return true if this is a 256-bit vector type.\nstatic inline bool is256BitVector(cs_data_type SimpleTy)\n{\n\treturn (SimpleTy == CS_DATA_TYPE_v16f16 ||\n\t\tSimpleTy == CS_DATA_TYPE_v16bf16 ||\n\t\tSimpleTy == CS_DATA_TYPE_v8f32 ||\n\t\tSimpleTy == CS_DATA_TYPE_v4f64 ||\n\t\tSimpleTy == CS_DATA_TYPE_v32i8 ||\n\t\tSimpleTy == CS_DATA_TYPE_v16i16 ||\n\t\tSimpleTy == CS_DATA_TYPE_v8i32 ||\n\t\tSimpleTy == CS_DATA_TYPE_v4i64 ||\n\t\tSimpleTy == CS_DATA_TYPE_v256i1 ||\n\t\tSimpleTy == CS_DATA_TYPE_v128i2 ||\n\t\tSimpleTy == CS_DATA_TYPE_v64i4);\n}\n\n/// Return true if this is a 512-bit vector type.\nstatic inline bool is512BitVector(cs_data_type SimpleTy)\n{\n\treturn (SimpleTy == CS_DATA_TYPE_v32f16 ||\n\t\tSimpleTy == CS_DATA_TYPE_v32bf16 ||\n\t\tSimpleTy == CS_DATA_TYPE_v16f32 ||\n\t\tSimpleTy == CS_DATA_TYPE_v8f64 ||\n\t\tSimpleTy == CS_DATA_TYPE_v512i1 ||\n\t\tSimpleTy == CS_DATA_TYPE_v256i2 ||\n\t\tSimpleTy == CS_DATA_TYPE_v128i4 ||\n\t\tSimpleTy == CS_DATA_TYPE_v64i8 ||\n\t\tSimpleTy == CS_DATA_TYPE_v32i16 ||\n\t\tSimpleTy == CS_DATA_TYPE_v16i32 ||\n\t\tSimpleTy == CS_DATA_TYPE_v8i64);\n}\n\n/// Return true if this is a 1024-bit vector type.\nstatic inline bool is1024BitVector(cs_data_type SimpleTy)\n{\n\treturn (SimpleTy == CS_DATA_TYPE_v1024i1 ||\n\t\tSimpleTy == CS_DATA_TYPE_v128i8 ||\n\t\tSimpleTy == CS_DATA_TYPE_v64i16 ||\n\t\tSimpleTy == CS_DATA_TYPE_v32i32 ||\n\t\tSimpleTy == CS_DATA_TYPE_v16i64 ||\n\t\tSimpleTy == CS_DATA_TYPE_v64f16 ||\n\t\tSimpleTy == CS_DATA_TYPE_v32f32 ||\n\t\tSimpleTy == CS_DATA_TYPE_v16f64 ||\n\t\tSimpleTy == CS_DATA_TYPE_v64bf16);\n}\n\n/// Return true if this is a 2048-bit vector type.\nstatic inline bool is2048BitVector(cs_data_type SimpleTy)\n{\n\treturn (SimpleTy == CS_DATA_TYPE_v256i8 ||\n\t\tSimpleTy == CS_DATA_TYPE_v128i16 ||\n\t\tSimpleTy == CS_DATA_TYPE_v64i32 ||\n\t\tSimpleTy == CS_DATA_TYPE_v32i64 ||\n\t\tSimpleTy == CS_DATA_TYPE_v128f16 ||\n\t\tSimpleTy == CS_DATA_TYPE_v64f32 ||\n\t\tSimpleTy == CS_DATA_TYPE_v32f64 ||\n\t\tSimpleTy == CS_DATA_TYPE_v128bf16 ||\n\t\tSimpleTy == CS_DATA_TYPE_v2048i1);\n}\n\nstatic inline cs_data_type getVectorElementType(cs_data_type SimpleTy)\n{\n\tswitch (SimpleTy) {\n\tdefault:\n\t\tassert(0 && \"Not a vector MVT!\");\n\tcase CS_DATA_TYPE_v1i1:\n\tcase CS_DATA_TYPE_v2i1:\n\tcase CS_DATA_TYPE_v4i1:\n\tcase CS_DATA_TYPE_v8i1:\n\tcase CS_DATA_TYPE_v16i1:\n\tcase CS_DATA_TYPE_v32i1:\n\tcase CS_DATA_TYPE_v64i1:\n\tcase CS_DATA_TYPE_v128i1:\n\tcase CS_DATA_TYPE_v256i1:\n\tcase CS_DATA_TYPE_v512i1:\n\tcase CS_DATA_TYPE_v1024i1:\n\tcase CS_DATA_TYPE_v2048i1:\n\tcase CS_DATA_TYPE_nxv1i1:\n\tcase CS_DATA_TYPE_nxv2i1:\n\tcase CS_DATA_TYPE_nxv4i1:\n\tcase CS_DATA_TYPE_nxv8i1:\n\tcase CS_DATA_TYPE_nxv16i1:\n\tcase CS_DATA_TYPE_nxv32i1:\n\tcase CS_DATA_TYPE_nxv64i1:\n\t\treturn CS_DATA_TYPE_i1;\n\tcase CS_DATA_TYPE_v128i2:\n\tcase CS_DATA_TYPE_v256i2:\n\t\treturn CS_DATA_TYPE_i2;\n\tcase CS_DATA_TYPE_v64i4:\n\tcase CS_DATA_TYPE_v128i4:\n\t\treturn CS_DATA_TYPE_i4;\n\tcase CS_DATA_TYPE_v1i8:\n\tcase CS_DATA_TYPE_v2i8:\n\tcase CS_DATA_TYPE_v4i8:\n\tcase CS_DATA_TYPE_v8i8:\n\tcase CS_DATA_TYPE_v16i8:\n\tcase CS_DATA_TYPE_v32i8:\n\tcase CS_DATA_TYPE_v64i8:\n\tcase CS_DATA_TYPE_v128i8:\n\tcase CS_DATA_TYPE_v256i8:\n\tcase CS_DATA_TYPE_v512i8:\n\tcase CS_DATA_TYPE_v1024i8:\n\tcase CS_DATA_TYPE_nxv1i8:\n\tcase CS_DATA_TYPE_nxv2i8:\n\tcase CS_DATA_TYPE_nxv4i8:\n\tcase CS_DATA_TYPE_nxv8i8:\n\tcase CS_DATA_TYPE_nxv16i8:\n\tcase CS_DATA_TYPE_nxv32i8:\n\tcase CS_DATA_TYPE_nxv64i8:\n\t\treturn CS_DATA_TYPE_i8;\n\tcase CS_DATA_TYPE_v1i16:\n\tcase CS_DATA_TYPE_v2i16:\n\tcase CS_DATA_TYPE_v3i16:\n\tcase CS_DATA_TYPE_v4i16:\n\tcase CS_DATA_TYPE_v8i16:\n\tcase CS_DATA_TYPE_v16i16:\n\tcase CS_DATA_TYPE_v32i16:\n\tcase CS_DATA_TYPE_v64i16:\n\tcase CS_DATA_TYPE_v128i16:\n\tcase CS_DATA_TYPE_v256i16:\n\tcase CS_DATA_TYPE_v512i16:\n\tcase CS_DATA_TYPE_nxv1i16:\n\tcase CS_DATA_TYPE_nxv2i16:\n\tcase CS_DATA_TYPE_nxv4i16:\n\tcase CS_DATA_TYPE_nxv8i16:\n\tcase CS_DATA_TYPE_nxv16i16:\n\tcase CS_DATA_TYPE_nxv32i16:\n\t\treturn CS_DATA_TYPE_i16;\n\tcase CS_DATA_TYPE_v1i32:\n\tcase CS_DATA_TYPE_v2i32:\n\tcase CS_DATA_TYPE_v3i32:\n\tcase CS_DATA_TYPE_v4i32:\n\tcase CS_DATA_TYPE_v5i32:\n\tcase CS_DATA_TYPE_v6i32:\n\tcase CS_DATA_TYPE_v7i32:\n\tcase CS_DATA_TYPE_v8i32:\n\tcase CS_DATA_TYPE_v9i32:\n\tcase CS_DATA_TYPE_v10i32:\n\tcase CS_DATA_TYPE_v11i32:\n\tcase CS_DATA_TYPE_v12i32:\n\tcase CS_DATA_TYPE_v16i32:\n\tcase CS_DATA_TYPE_v32i32:\n\tcase CS_DATA_TYPE_v64i32:\n\tcase CS_DATA_TYPE_v128i32:\n\tcase CS_DATA_TYPE_v256i32:\n\tcase CS_DATA_TYPE_v512i32:\n\tcase CS_DATA_TYPE_v1024i32:\n\tcase CS_DATA_TYPE_v2048i32:\n\tcase CS_DATA_TYPE_nxv1i32:\n\tcase CS_DATA_TYPE_nxv2i32:\n\tcase CS_DATA_TYPE_nxv4i32:\n\tcase CS_DATA_TYPE_nxv8i32:\n\tcase CS_DATA_TYPE_nxv16i32:\n\tcase CS_DATA_TYPE_nxv32i32:\n\t\treturn CS_DATA_TYPE_i32;\n\tcase CS_DATA_TYPE_v1i64:\n\tcase CS_DATA_TYPE_v2i64:\n\tcase CS_DATA_TYPE_v3i64:\n\tcase CS_DATA_TYPE_v4i64:\n\tcase CS_DATA_TYPE_v8i64:\n\tcase CS_DATA_TYPE_v16i64:\n\tcase CS_DATA_TYPE_v32i64:\n\tcase CS_DATA_TYPE_v64i64:\n\tcase CS_DATA_TYPE_v128i64:\n\tcase CS_DATA_TYPE_v256i64:\n\tcase CS_DATA_TYPE_nxv1i64:\n\tcase CS_DATA_TYPE_nxv2i64:\n\tcase CS_DATA_TYPE_nxv4i64:\n\tcase CS_DATA_TYPE_nxv8i64:\n\tcase CS_DATA_TYPE_nxv16i64:\n\tcase CS_DATA_TYPE_nxv32i64:\n\t\treturn CS_DATA_TYPE_i64;\n\tcase CS_DATA_TYPE_v1i128:\n\t\treturn CS_DATA_TYPE_i128;\n\tcase CS_DATA_TYPE_v1f16:\n\tcase CS_DATA_TYPE_v2f16:\n\tcase CS_DATA_TYPE_v3f16:\n\tcase CS_DATA_TYPE_v4f16:\n\tcase CS_DATA_TYPE_v8f16:\n\tcase CS_DATA_TYPE_v16f16:\n\tcase CS_DATA_TYPE_v32f16:\n\tcase CS_DATA_TYPE_v64f16:\n\tcase CS_DATA_TYPE_v128f16:\n\tcase CS_DATA_TYPE_v256f16:\n\tcase CS_DATA_TYPE_v512f16:\n\tcase CS_DATA_TYPE_nxv1f16:\n\tcase CS_DATA_TYPE_nxv2f16:\n\tcase CS_DATA_TYPE_nxv4f16:\n\tcase CS_DATA_TYPE_nxv8f16:\n\tcase CS_DATA_TYPE_nxv16f16:\n\tcase CS_DATA_TYPE_nxv32f16:\n\t\treturn CS_DATA_TYPE_f16;\n\tcase CS_DATA_TYPE_v2bf16:\n\tcase CS_DATA_TYPE_v3bf16:\n\tcase CS_DATA_TYPE_v4bf16:\n\tcase CS_DATA_TYPE_v8bf16:\n\tcase CS_DATA_TYPE_v16bf16:\n\tcase CS_DATA_TYPE_v32bf16:\n\tcase CS_DATA_TYPE_v64bf16:\n\tcase CS_DATA_TYPE_v128bf16:\n\tcase CS_DATA_TYPE_nxv1bf16:\n\tcase CS_DATA_TYPE_nxv2bf16:\n\tcase CS_DATA_TYPE_nxv4bf16:\n\tcase CS_DATA_TYPE_nxv8bf16:\n\tcase CS_DATA_TYPE_nxv16bf16:\n\tcase CS_DATA_TYPE_nxv32bf16:\n\t\treturn CS_DATA_TYPE_bf16;\n\tcase CS_DATA_TYPE_v1f32:\n\tcase CS_DATA_TYPE_v2f32:\n\tcase CS_DATA_TYPE_v3f32:\n\tcase CS_DATA_TYPE_v4f32:\n\tcase CS_DATA_TYPE_v5f32:\n\tcase CS_DATA_TYPE_v6f32:\n\tcase CS_DATA_TYPE_v7f32:\n\tcase CS_DATA_TYPE_v8f32:\n\tcase CS_DATA_TYPE_v9f32:\n\tcase CS_DATA_TYPE_v10f32:\n\tcase CS_DATA_TYPE_v11f32:\n\tcase CS_DATA_TYPE_v12f32:\n\tcase CS_DATA_TYPE_v16f32:\n\tcase CS_DATA_TYPE_v32f32:\n\tcase CS_DATA_TYPE_v64f32:\n\tcase CS_DATA_TYPE_v128f32:\n\tcase CS_DATA_TYPE_v256f32:\n\tcase CS_DATA_TYPE_v512f32:\n\tcase CS_DATA_TYPE_v1024f32:\n\tcase CS_DATA_TYPE_v2048f32:\n\tcase CS_DATA_TYPE_nxv1f32:\n\tcase CS_DATA_TYPE_nxv2f32:\n\tcase CS_DATA_TYPE_nxv4f32:\n\tcase CS_DATA_TYPE_nxv8f32:\n\tcase CS_DATA_TYPE_nxv16f32:\n\t\treturn CS_DATA_TYPE_f32;\n\tcase CS_DATA_TYPE_v1f64:\n\tcase CS_DATA_TYPE_v2f64:\n\tcase CS_DATA_TYPE_v3f64:\n\tcase CS_DATA_TYPE_v4f64:\n\tcase CS_DATA_TYPE_v8f64:\n\tcase CS_DATA_TYPE_v16f64:\n\tcase CS_DATA_TYPE_v32f64:\n\tcase CS_DATA_TYPE_v64f64:\n\tcase CS_DATA_TYPE_v128f64:\n\tcase CS_DATA_TYPE_v256f64:\n\tcase CS_DATA_TYPE_nxv1f64:\n\tcase CS_DATA_TYPE_nxv2f64:\n\tcase CS_DATA_TYPE_nxv4f64:\n\tcase CS_DATA_TYPE_nxv8f64:\n\t\treturn CS_DATA_TYPE_f64;\n\t}\n}\n\n/// Given a vector type, return the minimum number of elements it contains.\nstatic inline unsigned getVectorMinNumElements(cs_data_type SimpleTy)\n{\n\tswitch (SimpleTy) {\n\tdefault:\n\t\tassert(0 && \"Not a vector MVT!\");\n\tcase CS_DATA_TYPE_v2048i1:\n\tcase CS_DATA_TYPE_v2048i32:\n\tcase CS_DATA_TYPE_v2048f32:\n\t\treturn 2048;\n\tcase CS_DATA_TYPE_v1024i1:\n\tcase CS_DATA_TYPE_v1024i8:\n\tcase CS_DATA_TYPE_v1024i32:\n\tcase CS_DATA_TYPE_v1024f32:\n\t\treturn 1024;\n\tcase CS_DATA_TYPE_v512i1:\n\tcase CS_DATA_TYPE_v512i8:\n\tcase CS_DATA_TYPE_v512i16:\n\tcase CS_DATA_TYPE_v512i32:\n\tcase CS_DATA_TYPE_v512f16:\n\tcase CS_DATA_TYPE_v512f32:\n\t\treturn 512;\n\tcase CS_DATA_TYPE_v256i1:\n\tcase CS_DATA_TYPE_v256i2:\n\tcase CS_DATA_TYPE_v256i8:\n\tcase CS_DATA_TYPE_v256i16:\n\tcase CS_DATA_TYPE_v256f16:\n\tcase CS_DATA_TYPE_v256i32:\n\tcase CS_DATA_TYPE_v256i64:\n\tcase CS_DATA_TYPE_v256f32:\n\tcase CS_DATA_TYPE_v256f64:\n\t\treturn 256;\n\tcase CS_DATA_TYPE_v128i1:\n\tcase CS_DATA_TYPE_v128i2:\n\tcase CS_DATA_TYPE_v128i4:\n\tcase CS_DATA_TYPE_v128i8:\n\tcase CS_DATA_TYPE_v128i16:\n\tcase CS_DATA_TYPE_v128i32:\n\tcase CS_DATA_TYPE_v128i64:\n\tcase CS_DATA_TYPE_v128f16:\n\tcase CS_DATA_TYPE_v128bf16:\n\tcase CS_DATA_TYPE_v128f32:\n\tcase CS_DATA_TYPE_v128f64:\n\t\treturn 128;\n\tcase CS_DATA_TYPE_v64i1:\n\tcase CS_DATA_TYPE_v64i4:\n\tcase CS_DATA_TYPE_v64i8:\n\tcase CS_DATA_TYPE_v64i16:\n\tcase CS_DATA_TYPE_v64i32:\n\tcase CS_DATA_TYPE_v64i64:\n\tcase CS_DATA_TYPE_v64f16:\n\tcase CS_DATA_TYPE_v64bf16:\n\tcase CS_DATA_TYPE_v64f32:\n\tcase CS_DATA_TYPE_v64f64:\n\tcase CS_DATA_TYPE_nxv64i1:\n\tcase CS_DATA_TYPE_nxv64i8:\n\t\treturn 64;\n\tcase CS_DATA_TYPE_v32i1:\n\tcase CS_DATA_TYPE_v32i8:\n\tcase CS_DATA_TYPE_v32i16:\n\tcase CS_DATA_TYPE_v32i32:\n\tcase CS_DATA_TYPE_v32i64:\n\tcase CS_DATA_TYPE_v32f16:\n\tcase CS_DATA_TYPE_v32bf16:\n\tcase CS_DATA_TYPE_v32f32:\n\tcase CS_DATA_TYPE_v32f64:\n\tcase CS_DATA_TYPE_nxv32i1:\n\tcase CS_DATA_TYPE_nxv32i8:\n\tcase CS_DATA_TYPE_nxv32i16:\n\tcase CS_DATA_TYPE_nxv32i32:\n\tcase CS_DATA_TYPE_nxv32i64:\n\tcase CS_DATA_TYPE_nxv32f16:\n\tcase CS_DATA_TYPE_nxv32bf16:\n\t\treturn 32;\n\tcase CS_DATA_TYPE_v16i1:\n\tcase CS_DATA_TYPE_v16i8:\n\tcase CS_DATA_TYPE_v16i16:\n\tcase CS_DATA_TYPE_v16i32:\n\tcase CS_DATA_TYPE_v16i64:\n\tcase CS_DATA_TYPE_v16f16:\n\tcase CS_DATA_TYPE_v16bf16:\n\tcase CS_DATA_TYPE_v16f32:\n\tcase CS_DATA_TYPE_v16f64:\n\tcase CS_DATA_TYPE_nxv16i1:\n\tcase CS_DATA_TYPE_nxv16i8:\n\tcase CS_DATA_TYPE_nxv16i16:\n\tcase CS_DATA_TYPE_nxv16i32:\n\tcase CS_DATA_TYPE_nxv16i64:\n\tcase CS_DATA_TYPE_nxv16f16:\n\tcase CS_DATA_TYPE_nxv16bf16:\n\tcase CS_DATA_TYPE_nxv16f32:\n\t\treturn 16;\n\tcase CS_DATA_TYPE_v12i32:\n\tcase CS_DATA_TYPE_v12f32:\n\t\treturn 12;\n\tcase CS_DATA_TYPE_v11i32:\n\tcase CS_DATA_TYPE_v11f32:\n\t\treturn 11;\n\tcase CS_DATA_TYPE_v10i32:\n\tcase CS_DATA_TYPE_v10f32:\n\t\treturn 10;\n\tcase CS_DATA_TYPE_v9i32:\n\tcase CS_DATA_TYPE_v9f32:\n\t\treturn 9;\n\tcase CS_DATA_TYPE_v8i1:\n\tcase CS_DATA_TYPE_v8i8:\n\tcase CS_DATA_TYPE_v8i16:\n\tcase CS_DATA_TYPE_v8i32:\n\tcase CS_DATA_TYPE_v8i64:\n\tcase CS_DATA_TYPE_v8f16:\n\tcase CS_DATA_TYPE_v8bf16:\n\tcase CS_DATA_TYPE_v8f32:\n\tcase CS_DATA_TYPE_v8f64:\n\tcase CS_DATA_TYPE_nxv8i1:\n\tcase CS_DATA_TYPE_nxv8i8:\n\tcase CS_DATA_TYPE_nxv8i16:\n\tcase CS_DATA_TYPE_nxv8i32:\n\tcase CS_DATA_TYPE_nxv8i64:\n\tcase CS_DATA_TYPE_nxv8f16:\n\tcase CS_DATA_TYPE_nxv8bf16:\n\tcase CS_DATA_TYPE_nxv8f32:\n\tcase CS_DATA_TYPE_nxv8f64:\n\t\treturn 8;\n\tcase CS_DATA_TYPE_v7i32:\n\tcase CS_DATA_TYPE_v7f32:\n\t\treturn 7;\n\tcase CS_DATA_TYPE_v6i32:\n\tcase CS_DATA_TYPE_v6f32:\n\t\treturn 6;\n\tcase CS_DATA_TYPE_v5i32:\n\tcase CS_DATA_TYPE_v5f32:\n\t\treturn 5;\n\tcase CS_DATA_TYPE_v4i1:\n\tcase CS_DATA_TYPE_v4i8:\n\tcase CS_DATA_TYPE_v4i16:\n\tcase CS_DATA_TYPE_v4i32:\n\tcase CS_DATA_TYPE_v4i64:\n\tcase CS_DATA_TYPE_v4f16:\n\tcase CS_DATA_TYPE_v4bf16:\n\tcase CS_DATA_TYPE_v4f32:\n\tcase CS_DATA_TYPE_v4f64:\n\tcase CS_DATA_TYPE_nxv4i1:\n\tcase CS_DATA_TYPE_nxv4i8:\n\tcase CS_DATA_TYPE_nxv4i16:\n\tcase CS_DATA_TYPE_nxv4i32:\n\tcase CS_DATA_TYPE_nxv4i64:\n\tcase CS_DATA_TYPE_nxv4f16:\n\tcase CS_DATA_TYPE_nxv4bf16:\n\tcase CS_DATA_TYPE_nxv4f32:\n\tcase CS_DATA_TYPE_nxv4f64:\n\t\treturn 4;\n\tcase CS_DATA_TYPE_v3i16:\n\tcase CS_DATA_TYPE_v3i32:\n\tcase CS_DATA_TYPE_v3i64:\n\tcase CS_DATA_TYPE_v3f16:\n\tcase CS_DATA_TYPE_v3bf16:\n\tcase CS_DATA_TYPE_v3f32:\n\tcase CS_DATA_TYPE_v3f64:\n\t\treturn 3;\n\tcase CS_DATA_TYPE_v2i1:\n\tcase CS_DATA_TYPE_v2i8:\n\tcase CS_DATA_TYPE_v2i16:\n\tcase CS_DATA_TYPE_v2i32:\n\tcase CS_DATA_TYPE_v2i64:\n\tcase CS_DATA_TYPE_v2f16:\n\tcase CS_DATA_TYPE_v2bf16:\n\tcase CS_DATA_TYPE_v2f32:\n\tcase CS_DATA_TYPE_v2f64:\n\tcase CS_DATA_TYPE_nxv2i1:\n\tcase CS_DATA_TYPE_nxv2i8:\n\tcase CS_DATA_TYPE_nxv2i16:\n\tcase CS_DATA_TYPE_nxv2i32:\n\tcase CS_DATA_TYPE_nxv2i64:\n\tcase CS_DATA_TYPE_nxv2f16:\n\tcase CS_DATA_TYPE_nxv2bf16:\n\tcase CS_DATA_TYPE_nxv2f32:\n\tcase CS_DATA_TYPE_nxv2f64:\n\t\treturn 2;\n\tcase CS_DATA_TYPE_v1i1:\n\tcase CS_DATA_TYPE_v1i8:\n\tcase CS_DATA_TYPE_v1i16:\n\tcase CS_DATA_TYPE_v1i32:\n\tcase CS_DATA_TYPE_v1i64:\n\tcase CS_DATA_TYPE_v1i128:\n\tcase CS_DATA_TYPE_v1f16:\n\tcase CS_DATA_TYPE_v1f32:\n\tcase CS_DATA_TYPE_v1f64:\n\tcase CS_DATA_TYPE_nxv1i1:\n\tcase CS_DATA_TYPE_nxv1i8:\n\tcase CS_DATA_TYPE_nxv1i16:\n\tcase CS_DATA_TYPE_nxv1i32:\n\tcase CS_DATA_TYPE_nxv1i64:\n\tcase CS_DATA_TYPE_nxv1f16:\n\tcase CS_DATA_TYPE_nxv1bf16:\n\tcase CS_DATA_TYPE_nxv1f32:\n\tcase CS_DATA_TYPE_nxv1f64:\n\t\treturn 1;\n\t}\n}\n\n#endif // CS_SIMPLE_TYPES_H\n"
        },
        {
          "name": "cstool",
          "type": "tree",
          "content": null
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "functions.mk",
          "type": "blob",
          "size": 0.28515625,
          "content": "# Capstone Disassembly Engine\n# Common functions used by Makefile & tests/Makefile\n\ndefine compile\n\t$(ifeq ($(MACOS_UNIVERSAL),no),\n\t\t@$(CC) -MM -MP -MT $@ -MT $(@:.o=.d) $(CFLAGS) $< > $(@:.o=.d)\n\t)\n\t${CC} ${CFLAGS} -c $< -o $@\nendef\n\n\ndefine log\n\t@printf \"  %-7s %s\\n\" \"$(1)\" \"$(2)\"\nendef\n\n"
        },
        {
          "name": "include",
          "type": "tree",
          "content": null
        },
        {
          "name": "make.sh",
          "type": "blob",
          "size": 4.4130859375,
          "content": "#!/bin/sh\n\n# Capstone Disassembly Engine\n# By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2019\n\n# Note: to cross-compile \"nix32\" on Linux, package gcc-multilib is required.\n\nMAKE_JOBS=${MAKE_JOBS:-4}\n\n# build Android lib for only one supported architecture\nbuild_android() {\n  if [ -z \"$NDK\" ]; then\n    echo \"ERROR! Please set \\$NDK to point at your Android NDK directory.\"\n    exit 1\n  fi\n\n  HOSTOS=$(uname -s | tr 'LD' 'ld')\n  HOSTARCH=$(uname -m)\n\n  TARGARCH=\"$1\"\n  shift\n\n  case \"$TARGARCH\" in\n    arm)\n      [ -n \"$APILEVEL\" ] || APILEVEL=\"android-14\"  # default to ICS\n      CROSS=arm-linux-androideabi\n      ;;\n    arm64)\n      [ -n \"$APILEVEL\" ] || APILEVEL=\"android-21\"  # first with arm64\n      CROSS=aarch64-linux-android\n      ;;\n\n    *)\n      echo \"ERROR! Building for Android on $1 is not currently supported.\"\n      exit 1\n      ;;\n  esac\n\n  STANDALONE=`realpath android-ndk-${TARGARCH}-${APILEVEL}`\n\n  [ -d $STANDALONE ] || {\n      python ${NDK}/build/tools/make_standalone_toolchain.py \\\n             --arch ${TARGARCH} \\\n             --api ${APILEVEL##*-} \\\n             --install-dir ${STANDALONE}\n  }\n\n  ANDROID=1 CROSS=\"${STANDALONE}/${CROSS}/bin\" CFLAGS=\"--sysroot=${STANDALONE}/sysroot\" ${MAKE} $*\n}\n\n# build iOS lib for all iDevices, or only specific device\nbuild_iOS() {\n  IOS_SDK=`xcrun --sdk iphoneos --show-sdk-path`\n  IOS_CC=`xcrun --sdk iphoneos -f clang`\n  IOS_CFLAGS=\"-Os -Wimplicit -isysroot $IOS_SDK\"\n  IOS_LDFLAGS=\"-isysroot $IOS_SDK\"\n  if [ -z \"$1\" ]; then\n    # build for all iDevices\n    IOS_ARCHS=\"armv7 armv7s arm64\"\n  else\n    IOS_ARCHS=\"$1\"\n  fi\n  export CC=\"$IOS_CC\"\n  export LIBARCHS=\"$IOS_ARCHS\"\n  CFLAGS=\"$IOS_CFLAGS\" LDFLAGS=\"$IOS_LDFLAGS\" MACOS_UNIVERSAL=yes ${MAKE}\n}\n\ninstall() {\n  # Mac OSX needs to find the right directory for pkgconfig\n  if [ \"$UNAME\" = Darwin ]; then\n    # we are going to install into /usr/local, so remove old installs under /usr\n    rm -rf /usr/lib/libcapstone.*\n    rm -rf /usr/include/capstone\n    if [ \"${HOMEBREW_CAPSTONE}\" != 1 ]; then\n      # find the directory automatically, so we can support both Macport & Brew\n      export PKGCFGDIR=\"$(pkg-config --variable pc_path pkg-config | cut -d ':' -f 1)\"\n    fi\n    ${MAKE} install\n  else  # not OSX\n    test -d /usr/lib64 && export LIBDIRARCH=lib64\n    ${MAKE}\n    ${MAKE} install\n  fi\n}\n\nuninstall() {\n  # Mac OSX needs to find the right directory for pkgconfig\n  if [ \"$UNAME\" = \"Darwin\" ]; then\n    # find the directory automatically, so we can support both Macport & Brew\n    export PKGCFGDIR=\"$(pkg-config --variable pc_path pkg-config | cut -d ':' -f 1)\"\n    ${MAKE} uninstall\n  else  # not OSX\n    test -d /usr/lib64 && export LIBDIRARCH=lib64\n    ${MAKE} uninstall\n  fi\n}\n\nUNAME=\"${UNAME:-$(uname)}\"\n\nif [ \"$UNAME\" = SunOS ]; then\n  MAKE=\"${MAKE:-gmake}\"\n  export INSTALL_BIN=ginstall\n  export CC=gcc\nfi\n\nMAKE=\"${MAKE:-make}\"\n\nif echo \"$UNAME\" | grep -q BSD; then\n  MAKE=gmake\n  export PREFIX=/usr/local\nfi\n\nMAKE=\"$MAKE -j${MAKE_JOBS}\"\n\nTARGET=\"$1\"\n[ $# -gt 0 ] && shift\n\ncase \"$TARGET\" in\n  \"\" | \"default\" ) ${MAKE} \"$@\";;\n  \"debug\" ) \\\n      CAPSTONE_USE_SYS_DYN_MEM=yes \\\n      CAPSTONE_STATIC=yes \\\n      CFLAGS='-DCAPSTONE_DEBUG -O0 -g -fsanitize=address' \\\n      LDFLAGS='-fsanitize=address' \\\n      ${MAKE} \"$@\";;\n  \"install\" ) install;;\n  \"uninstall\" ) uninstall;;\n  \"nix32\" ) CFLAGS=-m32 LDFLAGS=-m32 ${MAKE} \"$@\";;\n  \"cross-win32\" ) CROSS=i686-w64-mingw32- ${MAKE} \"$@\";;\n  \"cross-win64\" ) CROSS=x86_64-w64-mingw32- ${MAKE} \"$@\";;\n  \"cygwin-mingw32\" ) CROSS=i686-pc-mingw32- ${MAKE} \"$@\";;\n  \"cygwin-mingw64\" ) CROSS=x86_64-w64-mingw32- ${MAKE} \"$@\";;\n  \"cross-android\" ) build_android \"$@\";;\n  \"cross-android64\" ) CROSS=aarch64-linux-gnu- ${MAKE} \"$@\";;\t# Linux cross build\n  \"clang\" ) CC=clang ${MAKE} \"$@\";;\n  \"gcc\" ) CC=gcc ${MAKE} \"$@\";;\n  \"ios\" ) build_iOS \"$@\";;\n  \"ios_armv7\" ) build_iOS armv7 \"$@\";;\n  \"ios_armv7s\" ) build_iOS armv7s \"$@\";;\n  \"ios_arm64\" ) build_iOS arm64 \"$@\";;\n  \"osx-kernel\" ) CAPSTONE_USE_SYS_DYN_MEM=yes \\\n      CAPSTONE_HAS_OSXKERNEL=yes \\\n      CAPSTONE_ARCHS=x86 \\\n      CAPSTONE_SHARED=no \\\n      CAPSTONE_BUILD_CORE_ONLY=yes \\\n      ${MAKE} \"$@\";;\n  \"mac-universal\" ) MACOS_UNIVERSAL=yes ${MAKE} \"$@\";;\n  \"mac-universal-no\" ) MACOS_UNIVERSAL=no ${MAKE} \"$@\";;\n  \"xlc31\" ) CC=xlc CFLAGS=-q31 LDFLAGS=-q31 ${MAKE} \"$@\";;\n  \"xlc32\" ) CC=xlc CFLAGS=-q32 LDFLAGS=-q32 ${MAKE} \"$@\";;\n  \"xlc64\" ) CC=xlc CFLAGS=-q64 LDFLAGS=-q64 ${MAKE} \"$@\";;\n  * )\n    echo \"Usage: $0 [\"$(grep '^  \"' $0 | cut -d '\"' -f 2 | tr \"\\\\n\" \"|\")\"]\"\n    exit 1;;\nesac\n"
        },
        {
          "name": "packages",
          "type": "tree",
          "content": null
        },
        {
          "name": "pkgconfig.mk",
          "type": "blob",
          "size": 0.2958984375,
          "content": "# Package version of Capstone for Makefile.\n# To be used to generate capstone.pc for pkg-config\n\n# version major & minor \nPKG_MAJOR = 6\nPKG_MINOR = 0\n\n# version bugfix level. Example: PKG_EXTRA = 1\nPKG_EXTRA = 0\n\n# version tag. Examples: rc1, b2, post1 - or just comment out for no tag\nPKG_TAG = alpha2\n"
        },
        {
          "name": "run-clang-tidy.sh",
          "type": "blob",
          "size": 1.931640625,
          "content": "#!/bin/sh\n\nif [ $# -ne 1 ] || [ \"$1\" = \"-h\" ] || [ \"$1\" = \"--help\" ]; then\n  echo \"$0 <build-path>\"\n  echo \"Set env var 'base_sha'  to upstream/next hash and 'head_sha' and your current HEAD hash.\"\n  exit 1\nfi\n\nif [ -z $base_sha ] || [ -z $head_sha ]; then\n  echo \"Set env var 'base_sha'  to upstream/next hash and 'head_sha' and your current HEAD hash.\"\n  exit 0\nfi\n\necho \"Running with version:\"\nclang-tidy --version\n\nBUILD_PATH=\"$1\"\n\ncheck_list=\"clang-analyzer-*,-clang-analyzer-cplusplus*,-clang-analyzer-optin.performance.Padding\"\n\nif $(hash clang-tidy-18); then\n  echo -e \"#############\\nProduced by\\n$(clang-tidy-18 --version)\\n#############\\n\\n\" > ct-warnings.txt\n  clang-tidy-18 $(find ./arch ./*.c -type f -iregex \".*\\.[c]\") -p \"$BUILD_PATH\" -checks=\"$check_list\" >> ct-warnings.txt\nelse\n  echo -e \"#############\\nProduced by\\n$(clang-tidy --version)\\n#############\\n\\n\" > ct-warnings.txt\n  clang-tidy $(find ./arch ./*.c -type f -iregex \".*\\.[c]\") -p \"$BUILD_PATH\" -checks=\"$check_list\" >> ct-warnings.txt\nfi\n\nif [ $? -ne 0 ]; then\n  echo \"clang-tidy failed\"\n  exit 1\nfi\n\ntmp=$(mktemp)\ngrep \": warning\" ct-warnings.txt | grep -oE \"^[/a-zA-Z0-9]*\\.[ch]\" | sort | uniq > $tmp\ntop_level=$(git rev-parse --show-toplevel)\n\necho \"\\n\\n###### REPORT\\n\\n\"\n\nchanged_files=$(git diff --name-only $base_sha..$head_sha)\nif [ $? -ne 0 ]; then\n  echo \"Failed to get changed files.\"\n  exit 1\nfi\n\nfaulty_files=\"\"\nfor modified in $changed_files; do\n  files_changed=1\n  full_path=\"$top_level/$modified\"\n  if grep -q \"$full_path\" $tmp; then\n    faulty_files=\"$faulty_files $modified\"\n    echo \"$full_path as warnings. Please fix them.\"\n    needs_fixes=1\n  fi\ndone\n\nif [ -z $files_changed ]; then\n  echo \"No files changed.\"\n  exit 0\nfi\n\nif [ -z $needs_fixes ]; then\n  echo \"None of the changed files has clang-tidy warnings.\"\n  exit 0\nfi\n\ncat ct-warnings.txt\n\necho -e \"\\n\\nclang-tidy warnings for: $faulty_files\\n\"\necho \"Please fix them. Or, if completely unrelated, let us know.\"\n\nexit 1\n"
        },
        {
          "name": "suite",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "utils.c",
          "type": "blob",
          "size": 6.49609375,
          "content": "/* Capstone Disassembly Engine */\n/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2019 */\n\n#if defined(CAPSTONE_HAS_OSXKERNEL)\n#include <Availability.h>\n#include <libkern/libkern.h>\n#else\n#include <stdlib.h>\n#endif\n#include <string.h>\n#include <ctype.h>\n\n#include \"utils.h\"\n\n// count number of positive members in a list.\n// NOTE: list must be guaranteed to end in 0\nunsigned int count_positive(const uint16_t *list)\n{\n\tunsigned int c;\n\n\tfor (c = 0; list[c] > 0; c++);\n\n\treturn c;\n}\n\n// count number of positive members in a list.\n// NOTE: list must be guaranteed to end in 0\nunsigned int count_positive8(const unsigned char *list)\n{\n\tunsigned int c;\n\n\tfor (c = 0; list[c] > 0; c++);\n\n\treturn c;\n}\n\nchar *cs_strdup(const char *str)\n{\n\tsize_t len = strlen(str) + 1;\n\tvoid *new = cs_mem_malloc(len);\n\n\tif (new == NULL)\n\t\treturn NULL;\n\n\treturn (char *)memmove(new, str, len);\n}\n\n// we need this since Windows doesn't have snprintf()\nint cs_snprintf(char *buffer, size_t size, const char *fmt, ...)\n{\n\tint ret;\n\n\tva_list ap;\n\tva_start(ap, fmt);\n\tret = cs_vsnprintf(buffer, size, fmt, ap);\n\tva_end(ap);\n\n\treturn ret;\n}\n\nbool arr_exist8(unsigned char *arr, unsigned char max, unsigned int id)\n{\n\tint i;\n\n\tfor (i = 0; i < max; i++) {\n\t\tif (arr[i] == id)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nbool arr_exist(uint16_t *arr, unsigned char max, unsigned int id)\n{\n\tint i;\n\n\tfor (i = 0; i < max; i++) {\n\t\tif (arr[i] == id)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/// @brief Checks if the @id is in the @table. @table has @table_size elements.\n/// @param table The table with the values to compare to.\n/// @param table_size The number elements in the table.\n/// @param id The identifier to search for in the table.\n/// @return True if @id is part of the @table, false otherwise.\nbool arr_exist_int(int *table, size_t table_size, int id)\n{\n\tint i;\n\tfor (i = 0; i < table_size; i++) {\n\t\tif (table[i] == id)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/// Reads 8 bytes in the endian order specified in MI->cs->mode.\nuint64_t readBytes64(MCInst *MI, const uint8_t *Bytes)\n{\n\tassert(MI && Bytes);\n\tuint64_t Insn;\n\tif (MODE_IS_BIG_ENDIAN(MI->csh->mode))\n\t\tInsn = ((uint64_t)Bytes[7] << 0) | ((uint64_t)Bytes[6] << 8) |\n\t\t       ((uint64_t)Bytes[5] << 16) | ((uint64_t)Bytes[4] << 24) |\n\t\t\t\t\t ((uint64_t)Bytes[3] << 32) | ((uint64_t)Bytes[2] << 40) |\n\t\t\t\t\t ((uint64_t)Bytes[1] << 48) | ((uint64_t)Bytes[0] << 56);\n\telse\n\t\tInsn = ((uint64_t)Bytes[7] << 56) | ((uint64_t)Bytes[6] << 48) |\n\t\t       ((uint64_t)Bytes[5] << 40) | ((uint64_t)Bytes[4] << 32) |\n\t\t\t\t\t ((uint64_t)Bytes[3] << 24) | ((uint64_t)Bytes[2] << 16) |\n\t\t\t\t\t ((uint64_t)Bytes[1] << 8) | ((uint64_t)Bytes[0] << 0);\n\treturn Insn;\n}\n\n/// Reads 6 bytes in the endian order specified in MI->cs->mode.\nuint64_t readBytes48(MCInst *MI, const uint8_t *Bytes)\n{\n\tassert(MI && Bytes);\n\tuint64_t Insn;\n\tif (MODE_IS_BIG_ENDIAN(MI->csh->mode))\n\t\tInsn = ((uint64_t)Bytes[5] << 0) | ((uint64_t)Bytes[4] << 8) |\n\t\t       ((uint64_t)Bytes[3] << 16) | ((uint64_t)Bytes[2] << 24) |\n\t\t\t\t\t ((uint64_t)Bytes[1] << 32) | ((uint64_t)Bytes[0] << 40);\n\telse\n\t\tInsn = ((uint64_t)Bytes[5] << 40) | ((uint64_t)Bytes[4] << 32) |\n\t\t\t\t\t ((uint64_t)Bytes[3] << 24) | ((uint64_t)Bytes[2] << 16) |\n\t\t\t\t\t ((uint64_t)Bytes[1] << 8) | ((uint64_t)Bytes[0] << 0);\n\treturn Insn;\n}\n\n/// Reads 4 bytes in the endian order specified in MI->cs->mode.\nuint32_t readBytes32(MCInst *MI, const uint8_t *Bytes)\n{\n\tassert(MI && Bytes);\n\tuint32_t Insn;\n\tif (MODE_IS_BIG_ENDIAN(MI->csh->mode))\n\t\tInsn = (Bytes[3] << 0) | (Bytes[2] << 8) | (Bytes[1] << 16) |\n\t\t       ((uint32_t)Bytes[0] << 24);\n\telse\n\t\tInsn = ((uint32_t)Bytes[3] << 24) | (Bytes[2] << 16) |\n\t\t       (Bytes[1] << 8) | (Bytes[0] << 0);\n\treturn Insn;\n}\n\n/// Reads 3 bytes in the endian order specified in MI->cs->mode.\nuint32_t readBytes24(MCInst *MI, const uint8_t *Bytes)\n{\n\tassert(MI && Bytes);\n\tuint32_t Insn;\n\tif (MODE_IS_BIG_ENDIAN(MI->csh->mode))\n\t\tInsn = (Bytes[2]) | (Bytes[1] << 8) |\n\t\t       ((uint32_t)Bytes[0] << 16);\n\telse\n\t\tInsn = (Bytes[2] << 16) | (Bytes[1] << 8) |\n\t\t       ((uint32_t)Bytes[0]);\n\treturn Insn;\n}\n\n/// Reads 2 bytes in the endian order specified in MI->cs->mode.\nuint16_t readBytes16(MCInst *MI, const uint8_t *Bytes)\n{\n\tassert(MI && Bytes);\n\tuint16_t Insn;\n\tif (MODE_IS_BIG_ENDIAN(MI->csh->mode))\n\t\tInsn = (Bytes[0] << 8) | Bytes[1];\n\telse\n\t\tInsn = (Bytes[1] << 8) | Bytes[0];\n\n\treturn Insn;\n}\n\n/// @brief Appends the string @p src to the string @p str. @p src is put to lower case.\n/// @param str The string to append to.\n/// @param str_size The length of @p str\n/// @param src The string to append.\n/// Does nothing if any of the given strings is NULL.\nvoid append_to_str_lower(char *str, size_t str_size, const char *src) {\n\tif (!str || !src) {\n\t\treturn;\n\t}\n\tchar *dest = strchr(str, '\\0');\n\tif (dest - str >= str_size) {\n\t\tassert(\"str_size does not match actual string length.\" && 0);\n\t\treturn;\n\t}\n\n\tint i = dest - str;\n\tfor (int j = 0; (i < str_size) && (j < strlen(src)); ++i, ++j) {\n\t\tstr[i] = tolower(src[j]);\n\t}\n\tstr[i] = '\\0';\n}\n\n/// @brief Appends the string @p src to the string @p dest.\n/// @p dest is can be a stack allocated buffer.\n///\n/// @param dest The string to append to.\n/// @param dest_buf_size Size of buffer @p str.\n/// @param src The string to append.\n/// Does nothing if any of the given strings is NULL.\nvoid str_append_no_realloc(char *dest, size_t dest_buf_size, const char *src) {\n\tif (!dest || !src) {\n\t\treturn;\n\t}\n\tif (strlen(dest) + strlen(src) + 1 > dest_buf_size) {\n\t\tprintf(\"str_size does not match actual string length.\\n\");\n\t\treturn;\n\t}\n\tstrncat(dest, src, dest_buf_size - strlen(dest));\n}\n\n\n/// Allocates memory of strlen(str_a) + strlen(str_b) + 1 chars\n/// and copies all strings into it as str_a + str_b\n/// str_a is passed to realloc and should not be used afterwards.\n/// Returns the concatenated string.\n/// Returns NULL in case of failure.\nchar *str_append(char *str_a, const char *str_b) {\n\tif (!str_a || !str_b) {\n\t\treturn NULL;\n\t}\n\tsize_t asize = strlen(str_a) + strlen(str_b) + 1;\n\tstr_a = realloc(str_a, asize);\n\tstrncat(str_a, str_b, asize - strlen(str_a));\n\treturn str_a;\n}\n\n/// Returns the given byte sequence @bytes as a string of the\n/// form: 0xXX,0xXX...\n/// Returns NULL in case of failure.\nchar *byte_seq_to_str(uint8_t *bytes, size_t len)\n{\n\tif (!bytes) {\n\t\treturn NULL;\n\t}\n\tif (len == 0) {\n\t\treturn NULL;\n\t}\n\tchar single_byte[8] = { 0 };\n\tchar *s = calloc(sizeof(char), 32);\n\tfor (size_t i = 0; i < len; ++i) {\n\t\tcs_snprintf(single_byte, sizeof(single_byte), \"0x%02\" PRIx8 \"%s\",\n\t\t\t    bytes[i], i == len - 1 ? \"\" : \", \");\n\t\ts = str_append(s, single_byte);\n\t\tif (!s) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn s;\n}\n"
        },
        {
          "name": "utils.h",
          "type": "blob",
          "size": 1.859375,
          "content": "/* Capstone Disassembly Engine */\n/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2019 */\n\n#ifndef CS_UTILS_H\n#define CS_UTILS_H\n\n#include <stdint.h>\n#if defined(CAPSTONE_HAS_OSXKERNEL)\n#include <libkern/libkern.h>\n#else\n#include <stddef.h>\n#include \"include/capstone/capstone.h\"\n#endif\n#include \"cs_priv.h\"\n\n// threshold number, so above this number will be printed in hexa mode\n#define HEX_THRESHOLD 9\n\n// count number of positive members in a list.\n// NOTE: list must be guaranteed to end in 0\nunsigned int count_positive(const uint16_t *list);\nunsigned int count_positive8(const unsigned char *list);\n\n#define ARR_SIZE(a) (sizeof(a)/sizeof(a[0]))\n#define MATRIX_SIZE(a) (sizeof(a[0])/sizeof(a[0][0]))\n\nchar *cs_strdup(const char *str);\n\n#define MIN(x, y) ((x) < (y) ? (x) : (y))\n\n// we need this since Windows doesn't have snprintf()\nint cs_snprintf(char *buffer, size_t size, const char *fmt, ...);\n\n#define CS_AC_IGNORE (1 << 7)\n\n// check if an id is existent in an array\nbool arr_exist8(unsigned char *arr, unsigned char max, unsigned int id);\nbool arr_exist(uint16_t *arr, unsigned char max, unsigned int id);\nbool arr_exist_int(int *table, size_t table_size, int id);\n\nuint16_t readBytes16(MCInst *MI, const uint8_t *Bytes);\nuint32_t readBytes24(MCInst *MI, const uint8_t *Bytes);\nuint32_t readBytes32(MCInst *MI, const uint8_t *Bytes);\nuint64_t readBytes48(MCInst *MI, const uint8_t *Bytes);\nuint64_t readBytes64(MCInst *MI, const uint8_t *Bytes);\n\nvoid append_to_str_lower(char *str, size_t str_size, const char *src);\nvoid str_append_no_realloc(char *str, size_t str_buf_size, const char *src);\nchar *str_append(char *str_a, const char *str_b);\nstatic inline bool strings_match(const char *str0, const char *str1) { return strcmp(str0, str1) == 0; }\n\nstatic inline bool is_blank_char(const char c) {\n\treturn c == ' ' || c == '\\t';\n}\n\nchar *byte_seq_to_str(uint8_t *bytes, size_t len);\n#endif\n"
        },
        {
          "name": "windows",
          "type": "tree",
          "content": null
        },
        {
          "name": "windowsce",
          "type": "tree",
          "content": null
        },
        {
          "name": "xcode",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}