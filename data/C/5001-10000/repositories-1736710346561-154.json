{
  "metadata": {
    "timestamp": 1736710346561,
    "page": 154,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "tmate-io/tmate",
      "stars": 5729,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.234375,
          "content": "*.o\n*~\n*.diff\n*.patch\n*.core\ncore\ntags\n.deps/\ncompat/.dirstamp\naclocal.m4\nautom4te.cache/\nconfig.log\nconfig.status\netc/\ntmux\nMakefile\nMakefile.in\nconfigure\ntmate\ncscope.*\nctags\n*.log\ntmate.1.*\ndownloads/\next/\nlibssh-*/\nmsgpack-*/\nreleases/\n"
        },
        {
          "name": ".mailmap",
          "type": "blob",
          "size": 1.908203125,
          "content": "Bob Beck\t\t<beck@openbsd.org> beck <beck>\nClaudio Jeker\t\t<claudio@openbsd.org> claudio <claudio>\nIgor Sobrado\t\t<sobrado@openbsd.org> sobrado <sobrado>\nIngo Schwarze\t\t<schwarze@openbsd.org> schwarze <schwarze>\nJacek Masiulaniec\t<jacekm@openbsd.org> jacekm <jacekm>\nJason McIntyre\t\t<jmc@openbsd.org> jmc <jmc>\nJoel Sing\t\t<jsing@openbsd.org> jsing <jsing>\nJonathan Gray\t\t<jsg@openbsd.org> jsg <jsg>\nKenneth R Westerback\t<krw@openbsd.org> krw <krw>\nMarc Espie\t\t<espie@openbsd.org> espie <espie>\nMatthew Dempsky\t\t<matthew@openbsd.org> matthew <matthew>\nMatthias Kilian\t\t<kili@openbsd.org> kili <kili>\nMatthieu Herrb\t\t<matthieu@openbsd.org> matthieu <matthieu>\nMichael McConville\t<mmcc@openbsd.org> mmcc <mmcc>\nMiod Vallat\t\t<miod@openbsd.org> miod <miod>\nNicholas Marriott\t<nicholas.marriott@gmail.com> Nicholas Marriott <nicm@openbsd.org>\nNicholas Marriott\t<nicholas.marriott@gmail.com> nicm <nicm>\nNicholas Marriott\t<nicholas.marriott@gmail.com> no_author <no_author@example.org>\nOkan Demirmen\t\t<okan@openbsd.org> okan <okan>\nPhilip Guenther\t\t<guenther@openbsd.org> guenther <guenther>\nPierre-Yves Ritschard\t<pyr@openbsd.org> pyr <pyr>\nRay Lai\t\t\t<ray@openbsd.org> ray <ray>\nRyan McBride\t\t<mcbride@openbsd.org> mcbride <mcbride>\nSebastian Benoit\t<benno@openbsd.org> benno <benno>\nStefan Sperling\t\t<stsp@openbsd.org> stsp <stsp>\nStuart Henderson\t<sthen@openbsd.org> sthen <sthen>\nTed Unangst\t\t<tedu@openbsd.org> tedu <tedu>\nTheo de Raadt\t\t<deraadt@openbsd.org> Theo Deraadt <deraadt@openbsd.org>\nTheo de Raadt\t\t<deraadt@openbsd.org> deraadt <deraadt>\nThomas Adam\t\t<thomas@xteddy.org> Thomas <thomas@xteddy.org>\nThomas Adam\t\t<thomas@xteddy.org> Thomas Adam <thomas.adam@smoothwall.net>\nThomas Adam\t\t<thomas@xteddy.org> n6tadam <n6tadam@xteddy.org>\nTim van der Molen\t<tim@openbsd.org> tim <tim>\nTobias Stoeckmann\t<tobias@openbsd.org> tobias <tobias>\nTodd C Miller\t\t<millert@openbsd.org> millert <millert>\nWilliam Yodlowsky\t<william@openbsd.org> william <william>\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 1.0830078125,
          "content": "language: c\nservices:\n- docker\n\nmatrix:\n  include:\n  - arch: amd64\n    env: PLATFORM=amd64\n  - arch: amd64\n    env: PLATFORM=i386\n  - arch: arm64\n    env: PLATFORM=arm32v6\n  - arch: arm64\n    env: PLATFORM=arm32v7\n  - arch: arm64\n    env: PLATFORM=arm64v8\n  - arch: s390x\n    env: PLATFORM=s390x\n  - arch: ppc64le\n    env: PLATFORM=ppc64le\n\nscript:\n- 'docker build . --tag local-$PLATFORM/tmate-build --build-arg PLATFORM=$PLATFORM'\n# On arch=arm64, some directories are not setup correctly, and 'ruby -S gem\n# install dpl' required by the release push scripts fails.\n- 'if [ \"$TRAVIS_TAG\" ]; then sudo chown -R $USER: /var/lib/gems /usr/local/bin; fi'\n- 'if [ \"$TRAVIS_TAG\" ]; then ./build_static_release.sh $TRAVIS_TAG $PLATFORM; fi'\n\ndeploy:\n  provider: releases\n  api_key:\n    secure: T2109tjjOsrVLEpJZK/uxmO0AuDGXYFdN4AAsNTmVwu/W5dcX57Kk2TCgqDuLfD21iGGXP0U/OYHM06IfBDODBWCA9P8ASHYsenS7wIiFnvCEMbfzoAFyBMrXN2kNdM2+ho3aqc0xE2lQKOKDLxpGm5FZrzujscXXzxQjWBU5Hk=\n  skip_cleanup: true\n  overwrite: true\n  file_glob: true\n  file: releases/*.tar.*\n  on:\n    repo: tmate-io/tmate\n    branch: master\n    tags: true\n"
        },
        {
          "name": "CHANGES",
          "type": "blob",
          "size": 83.13671875,
          "content": "CHANGES FROM 2.0 to 2.1 18 October 2015\n\nIncompatible Changes\n====================\n\n* Mouse-mode has been rewritten.  There's now no longer options for:\n\t- mouse-resize-pane\n\t- mouse-select-pane\n\t- mouse-select-window\n\t- mode-mouse\n\n  Instead there is just one option:  'mouse' which turns on mouse support\n  entirely.\n* 'default-terminal' is now a session option.  Furthermore, if this is set\n  to 'screen-*' then emulate what screen does.  If italics are wanted, this\n  can be set to 'tmux' but this is still new and not necessarily supported\n  on all platforms with older ncurses installs.\n* The c0-* options for rate-limiting have been removed.  Instead, a backoff\n  approach is used.\n\nNormal Changes\n==============\n\n* New formats:\n\t- session_activity\n\t- window_linked\n\t- window_activity_format\n\t- session_alerts\n\t- session_last_attached\n\t- client_pid\n\t- pid\n* 'copy-selection', 'append-selection', 'start-named-buffer' now understand\n  an '-x' flag to prevent it exiting copying mode.\n* 'select-pane' now understands '-P' to set window/pane background colours.\n* 'renumber-windows' now understands windows which are unlinked.\n* 'bind' now understands multiple key tables.  Allows for key-chaining.\n* 'select-layout' understands '-o' to undo the last layout change.\n* The environment is updated when switching sessions as well as attaching.\n* 'select-pane' now understands '-M' for marking a pane.  This marked pane\n  can then be used with commands which understand src-pane specifiers\n  automatically.\n* If a session/window target is prefixed with '=' then only an exact match\n  is considered.\n* 'move-window' understands '-a'.\n* 'update-environment' understands '-E' when attach-session is used on an\n  already attached client.\n* 'show-environment' understands '-s' to output Bourne-compatible commands.\n* New option: 'history-file' to save/restore command prompt history.\n* Copy mode is exited if the history is cleared whilst in copy-mode.\n* 'copy-mode' learned '-e' to exit copy-mode when scrolling to end.\n\nCHANGES FROM 1.9a to 2.0 6 March 2015\n\nIncompatible Changes\n====================\n\n* The choose-list command has been removed.\n* 'terminal-overrides' is now a server option, not a session option.\n* 'message-limit' is now a server option, not a session option.\n* 'monitor-content' option has been removed.\n* 'pane_start_path' option has been removed.\n* The \"info\" mechanism which used to (for some commands) provide feedback\n  has been removed, and like other commands, they now produce nothing on\n  success.\n\nNormal Changes\n==============\n\n* tmux can now write an entry to utmp if the library 'utempter' is present\n  at compile time.\n* set-buffer learned append mode (-a), and a corresponding\n  'append-selection' command has been added to copy-mode.\n* choose-mode now has the following commands which can be bound:\n\t- start-of-list\n\t- end-of-list\n\t- top-line\n\t- bottom-line\n\n* choose-buffer now understands UTF-8.\n* Pane navigation has changed:\n\t- The old way of always using the top or left if the choice is ambiguous.\n\t- The new way of remembering the last used pane is annoying if the\n\t  layout is balanced and the leftmost is obvious to the user (because\n\t  clearly if we go right from the top-left in a tiled set of four we want\n\t  to end up in top-right, even if we were last using the bottom-right).\n\n      So instead, use a combination of both: if there is only one possible\n      pane alongside the current pane, move to it, otherwise choose the most\n      recently used of the choice.\n* 'set-buffer' can now be told to give names to buffers.\n* The 'new-session', 'new-window', 'split-window', and 'respawn-pane' commands\n  now understand multiple arguments and handle quoting problems correctly.\n* 'capture-pane' understands '-S-' to mean the start of the pane, and '-E-' to\n  mean the end of the pane.\n* Support for function keys beyond F12 has changed.  The following explains:\n\t- F13-F24 are S-F1 to S-F12\n\t- F25-F36 are C-F1 to C-F12\n\t- F37-F48 are C-S-F1 to C-S-F12\n\t- F49-F60 are M-F1 to M-F12\n\t- F61-F63 are M-S-F1 to M-S-F3\n\n Therefore, F13 becomes a binding of S-F1, etc.\n* Support using pane id as part of session or window specifier (so % means\n  session-of-%1 or window-of-%1) and window id as part of session\n  (so @1 means session-of-@1).\n* 'copy-pipe' command now understands formats via -F\n* 'if-shell'  command now understands formats via -F\n* 'split-window' and 'join-window' understand -b to create the pane to the left\n  or above the target pane.\n\nCHANGES FROM 1.9 to 1.9a 22 February 2014\n\nNOTE:  This is a bug-fix release to address some important bugs which just\nmissed the 1.9 deadline, but were found afterwards.\n\nNormal Changes\n==============\n\n* Fix crash due to uninitialized lastwp member of layout_cell\n* Fix -fg/-bg/-style with 256 colour terminals.  \n\nCHANGES FROM 1.8 to 1.9, 20 February 2014\n\nNOTE:  This release has bumped the tmux protocol version.  It is therefore\nadvised that the prior tmux server is restarted when this version of tmux is\ninstalled, to avoid protocol mismatch errors for newer clients trying to\ntalk to an older running tmux server.\n\nIncompatible Changes\n====================\n\n* 88 colour support has been removed.\n* 'default-path' has been removed.  The new-window command accepts '-c' to\n  cater for this.  The previous value of \".\" can be replaced with: 'neww -c\n  $PWD', the previous value of '' which meant current path of the pane can\n  be specified as:  'neww -c \"#{pane_current_path}\"'\n\nDeprecated Changes\n==================\n\n* The single format specifiers:  #A -> #Z (where defined) have been\n  deprecated and replaced with longer-named equivalents, as listed in the\n  FORMATS section of the tmux manpage.\n* The various foo-{fg,bg,attr} commands have been deprecated and replaced\n  with equivalent foo-style option instead.  Currently this is still\n  backwards-compatible, but will be removed over time.\n\nNormal Changes\n==============\n\n* A new environment variable TMUX_TMPDIR is now honoured, allowing the\n  socket directory to be set outside of TMPDIR (/tmp/ if not set).\n* If -s not given to swap-pane the current pane is assumed.\n* A #{pane_syncronized} format specifier has been added to be a conditional\n  format if a pane is in a syncronised mode (c.f. syncronize-panes)\n* Tmux now runs under Cygwin natively.\n* Formats can now be nested within each other and expanded accordingly.\n* Added 'automatic-rename-format' option to allow the automatic rename\n  mechanism to use something other than the default of\n  #{pane_current_command}.\n* new-session learnt '-c' to specify the starting directory for that session\n  and all subsequent windows therein.\n* The session name is now shown in the message printed to the terminal when\n  a session is detached.\n* Lots more format specifiers have been added.\n* Server race conditions have been fixed; in particular commands are not run\n  until after the configuration file is read completely.\n* Case insensitive searching in tmux's copy-mode is now possible.\n* attach-session and switch-client learnt the '-t' option to accept a window\n  and/or a pane to use.\n* Copy-mode is only exited if no selection is in progress.\n* Paste key in copy-mode is now possible to enter text from the clipboard.\n* status-interval set to '0' now works as intended.\n* tmux now supports 256 colours running under fbterm.\n* Many bug fixes!\n\nCHANGES FROM 1.7 to 1.8, 26 March 2013\n\nIncompatible Changes\n====================\n\n* layout redo/undo has been removed.\n\nNormal Changes\n==============\n\n* Add halfpage up/down bindings to copy mode.\n* Session choosing fixed to work with unattached sessions.\n* New window options window-status-last-{attr,bg,fg} to denote the last\n  window which was active.\n* Scrolling in copy-mode now scrolls the region without moving the mouse\n  cursor.\n* run-shell learnt '-t' to specify the pane to use when displaying output.\n* Support for middle-click pasting.\n* choose-tree learns '-u' to start uncollapsed.\n* select-window learnt '-T' to toggle to the last window if it's already\n  current.\n* New session option 'assume-paste-time' for pasting text versus key-binding\n  actions.\n* choose-* commands now work outside of an attached client.\n* Aliases are now shown for list-commands command.\n* Status learns about formats.\n* Free-form options can be set with set-option if prepended with an '@'\n  sign.\n* capture-pane learnt '-p' to send to stdout, and '-e' for capturing escape\n  sequences, and '-a' to capture the alternate screen, and '-P' to dump\n  pending output.\n* Many new formats added (client_session, client_last_session, etc.)\n* Control mode, which is a way for a client to send tmux commands.\n  Currently more useful to users of iterm2.\n* resize-pane learnt '-x' and '-y' for absolute pane sizing.\n* Config file loading now reports errors from all files which are loaded via\n  the 'source-file' command.\n* 'copy-pipe' mode command to copy selection and pipe the selection to a\n  command.\n* Panes can now emit focus notifications for certain applications\n  which use those.\n* run-shell and if-shell now accept formats.\n* resize-pane learnt '-Z' for zooming a pane temporarily.\n* new-session learnt '-A' to make it behave like attach-session.\n* set-option learnt '-o' to prevent setting an option which is already set.\n* capture-pane and show-options learns '-q' to silence errors.\n* New command 'wait-for' which blocks a client until woken up again.\n* Resizing panes will now reflow the text inside them.\n* Lots and lots of bug fixes, fixing memory-leaks, etc.\n* Various manpage improvements.\n\nCHANGES FROM 1.6 to 1.7, 13 October 2012\n\n* tmux configuration files now support line-continuation with a \"\\\" at the\n  end of a line.\n* New option status-position to move the status line to the top or bottom of\n  the screen.\n* Enforce history-limit option when clearing the screen.\n* Give each window a unique id, like panes but prefixed with @.\n* Add pane id to each pane in layout description (while still accepting\n  the old form).\n* Provide defined ways to set the various default-path possibilities: ~\n  for home directory, . for server start directory, - for session start\n  directory and empty for the pane's working directory (the default). All\n  can also be used as part of a relative path (eg -/foo). Also provide -c\n  flags to neww and splitw to override default-path setting.\n* Add -l flag to send-keys to send input literally (without translating\n  key names).\n* Allow a single option to be specified to show-options to show just that\n  option.\n* New command \"move-pane\" (like join-pane but allows the same window).\n* join-pane and move-pane commands learn \"-b\" option to place the pane to\n  the left or above.\n* Support for bracketed-paste mode.\n* Allow send-keys command to accept hex values.\n* Add locking around \"start-server\" to avoid race-conditions.\n* break-pane learns -P/-F arguments for display formatting.\n* set-option learns \"-q\" to make it quiet, and not print out anything.\n* copy mode learns \"wrap-search\" option.\n* Add a simple form of output rate limiting by counting the number of\n  certain C0 sequences (linefeeds, backspaces, carriage returns) and if it\n  exceeds a threshold (current default 250/millisecond), start to redraw\n  the pane every 100 milliseconds instead of making each change as it\n  comes. Two configuration options - c0-change-trigger and\n  c0-change-interval.\n* find-window learns new flags:  \"-C\", \"-N\", \"-T\" to match against either or\n  all of a window's content, name, or title.  Defaults to all three options\n  if none specified.\n* find-window automatically selects the appropriate pane for the found\n  matches.\n* show-environment can now accept one option to show that environment value.\n* Exit mouse mode when end-of-screen reached when scrolling with the mouse\n  wheel.\n* select-layout learns -u and -U for layout history stacks.\n* kill-window, detach-client, kill-session all  learn \"-a\" option for\n  killing all but the current thing specified.\n* move-window learns \"-r\" option to renumber window sequentially in a\n  session.\n* New session option \"renumber-windows\" to automatically renumber windows in\n  a session when a window is closed.  (see \"move-window -r\").\n* Only enter copy-mode on scroll up.\n* choose-* and list-* commands all use \"-F\" for format specifiers.\n* When spawning external commands, the value from the \"default-shell\" option\n  is now used, rather than assuming /bin/sh.\n* New choose-tree command to render window/sessions as a tree for selection.\n* display-message learns new format options.\n* For linked-windows across sessions, all flags for that window are now\n  cleared across sessions.\n* Lots and lots of bug fixes, fixing memory-leaks, etc.\n* Various manpage improvements.\n\nCHANGES FROM 1.5 TO 1.6, 23 January 2012\n\n* Extend the mode-mouse option to add a third choice which means the mouse\n  does not enter copy mode.\n* Add a -r flag to switch-client to toggle the client read-only flag.\n* Add pane-base-index option.\n* Support \\ for line continuation in the configuration file.\n* Framework for more powerful formatting of command output and use it for\n  list-{panes,windows,sessions}. This allows more descriptive replacements\n  (such as #{session_name}) and conditionals.\n* Mark dead panes with some text saying they are dead.\n* Reject $SHELL if it is not a full path.\n* Add -S option to refresh-client to redraw status line.\n* Add an else clause for if-shell.\n* Try to resolve relative paths for loadb and saveb (first, using client\n  working directory, if any, then default-path or session working directory).\n* Support for \\e[3J to clear the history and send the corresponding\n  terminfo code (E3) before locking.\n* When in copy mode, make repeat count indicate buffer to replace, if used.\n* Add screen*:XT to terminal-overrides for tmux-in-tmux.\n* Status-line message attributes added.\n* Move word-separators to be a session rather than window option.\n* Change the way the working directory for new processes is discovered. If\n  default-path isn't empty, it is used. Otherwise, if a new window is created\n  from the command-line, the working directory of the client is used. If not,\n  platform specific code is used to retrieve the current working directory\n  of the process in the active pane. If that fails, the directory where the\n  session was created is used, instead.\n* Do not change the current pane if both mouse-select-{pane,window} are\n  enabled.\n* Add \\033[s and \\033[u to save and restore cursor position.\n* Allow $HOME to be used as default-path.\n* Add CNL and CPL escape sequences.\n* Calculate last position correctly for UTF-8 wide characters.\n* Add an option allow-rename to disable the window rename escape sequence.\n* Attributes for each type of status-line alert (ie bell, content and\n  activity) added. Therefore, remove the superfluous options\n  window-status-alert-{attr,bg,fg}.\n* Add a -R flag to send-keys to reset the terminal.\n* Add strings to allow the aixterm bright colours to be used when\n  configuring colours.\n* Drop the ability to have a list of keys in the prefix in favour of two\n  separate options, prefix and prefix2.\n* Flag -2 added to send-prefix to send the secondary prefix key.\n* Show pane size in top right of display panes mode.\n* Some memory leaks plugged.\n* More command-prompt editing improvements.\n* Various manpage improvements.\n* More Vi mode improvements.\n\nCHANGES FROM 1.4 TO 1.5, 09 July 2011\n\n* Support xterm mouse modes 1002 and 1003.\n* Change from a per-session stack of buffers to one global stack. This renders\n  copy-buffer useless and makes buffer-limit now a server option.\n* Fix most-recently-used choice by avoiding reset the activity timer for\n  unattached sessions every second.\n* Add a -P option to new-window and split-window to print the new window or\n  pane index in target form (useful to pass it into other commands).\n* Handle a # at the end of a replacement string (such as status-left)\n  correctly.\n* Support for UTF-8 mouse input (\\033[1005h) which was added in xterm 262.\n  If the new mouse-utf8 option is on, UTF-8 mouse input is enabled for all\n  UTF-8 terminals. The option defaults to on if LANG etc are set in the same\n  manner as the utf8 option.\n* Support for HP-UX.\n* Accept colours of the hex form #ffffff and translate to the nearest from the\n  xterm(1) 256-colour set.\n* Clear the non-blocking IO flag (O_NONBLOCK) on the stdio file descriptors\n  before closing them (fixes things like \"tmux ls && cat\").\n* Use TMPDIR if set.\n* Fix next and previous session functions to actually work.\n* Support -x and -y for new-session to specify the initial size of the window\n  if created detached with -d.\n* Make bind-key accept characters with the top-bit-set and print them as octal.\n* Set $TMUX without the session when background jobs are run.\n* Simplify the way jobs work and drop the persist type, so all jobs are\n  fire-and-forget.\n* Accept tcgetattr/tcsetattr(3) failure, fixes problems with fatal() if the\n  terminal disappears while locked.\n* Add a -P option to detach to HUP the client's parent process (usually causing\n  it to exit as well).\n* Support passing through escape sequences to the underlying terminal by using\n  DCS with a \"tmux;\" prefix.\n* Prevent tiled producing a corrupt layout when only one column is needed.\n* Give each pane created in a tmux server a unique id (starting from 0), put it\n  in the TMUX_PANE environment variable and accept it as a target.\n* Allow a start and end line to be specified for capture-pane which may be\n  negative to capture part of the history.\n* Add -a and -s options to lsp to list all panes in the server or session\n  respectively. Likewise add -s to lsw.\n* Change -t on display-message to be target-pane for the #[A-Z] replacements\n  and add -c as target-client.\n* The attach-session command now prefers the most recently used unattached\n  session.\n* Add -s option to detach-client to detach all clients attached to a session.\n* Add -t to list-clients.\n* Change window with mouse wheel over status line if mouse-select-window is on.\n* When mode-mouse is on, automatically enter copy mode when the mouse is\n  dragged or the mouse wheel is used. Also exit copy mode when the mouse wheel\n  is scrolled off the bottom.\n* Provide #h character pair for short hostname (no domain).\n* Don't use strnvis(3) for the title as it breaks UTF-8.\n* Use the tsl and fsl terminfo(5) capabilities to update terminal title and\n  automatically fill them in on terminals with the XT capability (which means\n  their title setting is xterm-compatible).\n* Add a new option, mouse-resize-pane. When on, panes may be resized by\n  dragging their borders.\n* Fix crash by resetting last pane on {break,swap}-pane across windows.\n* Add three new copy-mode commands - select-line, copy-line, copy-end-of-line.\n* Support setting the xterm clipboard when copying from copy mode using the\n  xterm escape sequence for the purpose (if xterm is configured to allow it).\n* Support xterm(1) cursor colour change sequences through terminfo(5) Cc\n  (set) and Cr (reset) extensions.\n* Support DECSCUSR sequence to set the cursor style with two new terminfo(5)\n  extensions, Cs and Csr.\n* Make the command-prompt custom prompts recognize the status-left option\n  character pairs.\n* Add a respawn-pane command.\n* Add a couple of extra xterm-style keys that gnome terminal provides.\n* Allow the initial context on prompts to be set with the new -I option to\n  command-prompt. Include the current window and session name in the prompt\n  when renaming and add a new key binding ($) for rename session.\n* Option bell-on-alert added to trigger the terminal bell when there is an\n  alert.\n* Change the list-keys format so that it shows the keys using actual tmux\n  commands which should be able to be directly copied into the config file.\n* Show full targets for lsp/lsw -a.\n* Make confirm-before prompt customizable with -p option like command-prompt\n  and add the character pairs #W and #P to the default kill-{pane,window}\n  prompts.\n* Avoid sending data to suspended/locked clients.\n* Small memory leaks in error paths plugged.\n* Vi mode improvements.\n\nCHANGES FROM 1.3 TO 1.4, 27 December 2010\n\n* Window bell reporting fixed.\n* Show which pane is active in the list-panes output.\n* Backoff reworked.\n* Prevent the server from dying when switching into copy mode when already\n  in a different mode.\n* Reset running jobs when the status line is enabled or disabled.\n* Simplify xterm modifier detection.\n* Avoid crashing in copy mode if the screen size is too small for the\n  indicator.\n* Flags -n and -p added to switch-client.\n* Use UTF-8 line drawing characters on UTF-8 terminals, thus fixing some\n  terminals (eg putty) which disable the vt100 ACS mode switching sequences\n  in UTF-8 mode. On terminals without ACS, use ASCII equivalents.\n* New server option exit-unattached added.\n* New session option destroy-unattached added.\n* Fall back on normal session choice method if $TMUX exists but is invalid\n  rather than rejecting.\n* Mark repeating keys with \"(repeat)\" in the key list.\n* When removing a pane, don't change the active pane unless the active pane\n  is actually the one being removed.\n* New command last-pane added.\n* AIX fixes.\n* Flag -a added to unbind-key.\n* Add XAUTHORITY to update-environment.\n* More info regarding window and pane flags is now shown in list-*.\n* If VISUAL or EDITOR contains \"vi\" configure mode-keys and status-key to vi.\n* New window option monitor-silence and session option visual-silence added.\n* In the built-in layouts distribute the panes more evenly.\n* Set the default value of main-pane-width to 80 instead of 81.\n* Command-line flag -V added.\n* Instead of keeping a per-client prompt history make it global.\n* Fix rectangle copy to behave like emacs (the cursor is not part of the\n  selection on the right edge but on the left it is).\n* Flag -l added to switch-client.\n* Retrieve environment variables from the global environment rather than\n  getenv(3), thus allowing them to be updated during the configuration file.\n* New window options other-pane-{height,width} added.\n* More minor bugs fixed and manpage improvements.\n\nCHANGES FROM 1.2 TO 1.3, 18 July 2010\n\n* New input parser.\n* Flags to move through panes -UDLR added to select-pane.\n* Commands up-pane, and down-pane removed, since equivalent behaviour is now\n  available through the target flag (-t:+ and -t:-).\n* Jump-forward/backward in copy move (based on vi's F, and f commands).\n* Make paste-buffer accept a pane as a target.\n* Flag -a added to new-window to insert a window after an existing one, moving\n  windows up if necessary.\n* Merge more mode into copy mode.\n* Run job commands explicitly in the global environment (which can be modified\n  with setenv -g), rather than with the environment tmux started with.\n* Use the machine's hostname as the default title, instead of an empty string.\n* Prevent double free if the window option remain-on-exit is set. \n* Key string conversions rewritten.\n* Mark zombie windows as dead in the choose-window list.\n* Tiled layout added.\n* Signal handling reworked.\n* Reset SIGCHLD after fork to fix problems with some shells.\n* Select-prompt command removed. Therefore, bound ' to command-prompt -p index\n  \"select-window -t:%%\" by default.\n* Catch SIGHUP and terminate if running as a client, thus avoiding clients from\n  being left hanging around when, for instance, a SSH session is disconnected.\n* Solaris 9 fixes (such as adding compat {get,set}env(3) code).\n* Accept none instead of default for attributes.\n* Window options window-status-alert-{alert,bg,fg} added.\n* Flag -s added to the paste-buffer command to specify a custom separator.\n* Allow dragging to make a selection in copy mode if the mode-mouse option is\n  set.\n* Support the mouse scroll wheel.\n* Make pipe-pane accept special character sequences (eg #I).\n* Fix problems with window sizing when starting tmux from .xinitrc.\n* Give tmux sockets (but not the containing folder) group permissions.\n* Extend the target flags (ie -t) to accept an offset (for example -t:+2), and\n  make it wrap windows, and panes.\n* New command choose-buffer added.\n* New server option detach-on-destroy to set what happens to a client when the\n  session it is attached to is destroyed. If on (default), the client is\n  detached. Otherwise, the client is switched to the most recently active of\n  the remaining sessions.\n* The commands load-buffer, and save-buffer now accept a dash (-) as the file\n  to read from stdin, or write to stdout.\n* Custom layouts added.\n* Additional code reduction, bug fixes, and manpage enhancements.\n\nCHANGES FROM 1.1 TO 1.2, 10 March 2010\n\n* Switch to libevent.\n* Emulate the ri (reverse index) capability, ergo allowing tmux to at least\n  start on Sun consoles (TERM=sun, or sun-color).\n* Assign each entry a number, or lowercase letter in choose mode, and accept\n  that as a shortcut key.\n* Permit top-bit-set characters to be entered in the status line.\n* Mark no-prefix keys with (no prefix), rather than [] in list-keys.\n* New command show-messages (alias showmsgs), and new session option\n  message-limit, to show a per-client log of status lines messages up to the\n  number defined by message-limit.\n* Do not interpret #() for display-message to avoid leaking commands.\n* New window options window-status-format, and window-status-current-format to\n  control the format of each window in the status line.\n* Add a -p flag to display-message to print the output, instead of displaying\n  it in the status line.\n* Emulate il1, dl1, ich1 to run with vt100 feature set.\n* New command capture-pane (alias capturep) to copy the entire pane contents\n  to a paste buffer.\n* Avoid duplicating code by adding a -w flag to set-option, and show-options to\n  set, and show window options. The commands set-window-option, and\n  show-window-options are now aliases.\n* Panes can now be referred to as top, bottom, top-left, etc.\n* Add server-wide options, which can be set with set-option -s, and shown with\n  show-options -s.\n* New server option quiet (like -q from the command line).\n* New server option escape-time to set the timeout used to detect if escapes\n  are alone, part of a function key, or meta sequence.\n* New session options pane-active-border-bg, pane-active-border-fg,\n  pane-border-bg, and pane-border-fg to set pane colours.\n* Make split-window accept a pane target, instead of a window.\n* New command join-pane (alias joinp) to split, and move an existing pane into\n  the space (the opposite of break-pane), thus simplifying calls to\n  split-window, followed by move-window.\n* Permit S- prefix on keys for shift when the terminal/terminfo supports them.\n* Window targets (-t flag) can now refer to the last window (!), next (+), and\n  previous (-) window by number.\n* Mode keys to jump to the bottom/top of history, end of the next word, scroll\n  up/down, and reverse search in copy mode.\n* New session option display-panes-active-colour to display the active pane in\n  a different colour with the display-panes command.\n* Read the socket path from $TMUX if it's present, and -L, and -S are not\n  given.\n* Vi-style mode keys B, W, and E to navigate between words in copy mode.\n* Start in more mode when configuration file errors are detected.\n* Rectangle copy support added.\n* If attach-session was specified with the -r flag, make the client read-only.\n* Per-window alternate-screen option.\n* Make load-buffer work with FIFOs.\n* New window option word-separators to set the characters considered as word\n  separators in copy mode.\n* Permit keys in copy mode to be prefixed by a repeat count, entered with [1-9]\n  in vi mode, or M-[1-9] in emacs mode.\n* utf8 improvements.\n* As usual, additional code reduction, bug fixes, and manpage enhancements.\n\nCHANGES FROM 1.0 TO 1.1, 05 November 2009\n\n* New run-shell (alias run) command to run an external command without a\n  window, capture it's stdout, and send it to output mode.\n* Ability to define multiple prefix keys.\n* Internal locking mechanism removed. Instead, detach each client and run the\n  external command specified in the new session option lock-command (by default\n  lock -np), thus allowing the system password to be used.\n* set-password command, and -U command line flag removed per the above change.\n* Add support for -c command line flag to execute a shell command.\n* New lock-client (alias lockc), and lock-session (alias locks) commands to\n  lock a particular client, or all clients attached to a session.\n* Support C-n/C-p/C-v/M-v with emacs keys in choice mode.\n* Use : for goto line rather than g in vi mode. \n* Try to guess which client to use when no target client was specified. Finds\n  the current session, and if only one client is present, use it. Otherwise,\n  return the most recently used client.\n* Make C-Down/C-Up in copy mode scroll the screen down/up one line without\n  moving the cursor.\n* Scroll mode superseded by copy mode.\n* New synchronize-panes window option to send all input to all other panes in\n  the same window.\n* New lock-server session option to lock, when off (on by default), each\n  session when it has been idle for the lock-after-time setting. When on, the\n  entire server locks when all sessions have been idle for their individual\n  lock-after-time setting.\n* Add support for grouped sessions which have independent name, options,\n  current window, but where the linked windows are synchronized (ie creating,\n  killing windows are mirrored between the sessions). A grouped session may be\n  created by passing -t to new-session.\n* New mouse-select-pane session option to select the current pane with the\n  mouse.\n* Queue, and run commands in the background for if-shell, status-left,\n  status-right, and #() by starting each once every status-interval. Adds the\n  capability to call some programs which would previously cause the server to\n  hang (eg sleep/tmux). It also avoids running commands excessively (ie if used\n  multiple times, it will be run only once).\n* When a window is zombified and automatic-rename is on, append [dead] to the\n  name.\n* Split list-panes (alias lsp) off from list-windows.\n* New pipe-pane (alias pipep) to redirect a pane output to an external command.\n* Support for automatic-renames for Solaris.\n* Permit attributes to be turned off in #[] by prefixing with no (eg nobright).\n* Add H/M/L in vi mode, and M-R/M-r in emacs to move the cursor to the top,\n  middle, and bottom of the screen.\n* -a option added to kill-pane to kill all except current pane.\n* The -d command line flag is now gone (can be replaced by terminal-overrides).\n  Just use op/AX to detect default colours.\n* input/tty/utf8 improvements.\n* xterm-keys rewrite.\n* Additional code reduction, and bug fixes.\n\nCHANGES FROM 0.9 TO 1.0, 20 Sept 2009\n\n* Option to alter the format of the window title set by tmux.\n* Backoff for a while after multiple incorrect password attempts.\n* Quick display of pane numbers (C-b q).\n* Better choose-window, choose-session commands and a new choose-client command.\n* Option to request multiple responses when using command-prompt.\n* Improved environment handling.\n* Combine wrapped lines when pasting.\n* Option to override terminal settings (terminal-overrides).\n* Use the full range of ACS characters for drawing pane separator lines.\n* Customisable mode keys.\n* Status line colour options, with embedded colours in status-left/right, and\n  an option to centre the window list.\n* Much improved layouts, including both horizontal and vertical splitting.\n* Optional visual bell, activity and content indications.\n* Set the utf8 and status-utf8 options when the server is started with -u.\n* display-message command to show a message in the status line, by default some\n  information about the current window.\n* Improved current process detection on NetBSD.\n* unlink-window -k is now the same as kill-window.\n* attach-session now works from inside tmux.\n* A system-wide configuration file, /etc/tmux.conf.\n* A number of new commands in copy mode, including searching.\n* Panes are now specified using the target (-t) notation.\n* -t now accepts fnmatch(3) patterns and looks for prefixes.\n* Translate \\r into \\n when pasting.\n* Support for binding commands to keys without the prefix key\n* Support for alternate screen (terminfo smcup/rmcup).\n* Maintain data that goes off screen after reducing the window size, so it can\n  be restored when the size is increased again.\n* New if-shell command to test a shell command before running a tmux command.\n* tmux now works as the shell.\n* Man page reorganisation.\n* Many minor additions, much code tidying and several bug fixes.\n\nCHANGES FROM 0.8 TO 0.9, 01 July 2009\n\n* Major changes to build infrastructure: cleanup of makefiles and addition\n  of a configure script.\n* monitor-content window option to monitor a window for a specific fnmatch(3)\n  pattern. The find-window command also now accepts fnmatch(3) patterns.\n* previous-layout and select-layout commands, and a main-horizontal layout.\n* Recreate the server socket on SIGUSR1.\n* clear-history command.\n* Use ACS line drawing characters for pane separator lines.\n* UTF-8 improvements, and code to detect UTF-8 support by looking at\n  environment variables.\n* The resize-pane-up and resize-pane-down commands are now merged together\n  into a new resize-pane command with -U and -D flags.\n* confirm-before command to request a yes/no answer before executing dangerous\n  commands.\n* Status line bug fixes, support for UTF-8 (status-utf8 option), and a key to\n  paste from the paste buffer.\n* Support for some additional escape sequences and terminal features, including\n  better support for insert mode and tab stops.\n* Improved window resizing behaviour, modelled after xterm.\n* Some code reduction and a number of miscellaneous bug fixes.\n\n================================================================================\n\nOn 01 June 2009, tmux was imported into the OpenBSD base system. From this date\nonward changes are logged as part of the normal CVS commit message to either\nOpenBSD or SourceForge CVS. This file will be updated to contain a summary of\nmajor changes with each release, and to mention important configuration or\ncommand syntax changes during development.\n\nThe list of older changes is below.\n\n================================================================================\n\n21 May 2009\n\n* stat(2) files before trying to load them to avoid problems, for example\n  with \"source-file /dev/zero\".\n\n19 May 2009\n\n* Try to guess if the window is UTF-8 by outputting a three-byte UTF-8 wide\n  character and seeing how much the cursor moves. Currently tries to figure out\n  if this works by some stupid checks on the terminal, these need to be\n  rethought. Also might be better using a width 1 character rather than width 2.\n* If LANG contains \"UTF-8\", assume the terminal supports UTF-8, on the grounds\n  that anyone who configures it probably wants UTF-8. Not certain if this is\n  a perfect idea but let's see if it causes any problems.\n* New window option: monitor-content. Searches for a string in a window and if\n  it matches, highlight the status line.\n\n18 May 2009\n\n* main-horizontal layout and main-pane-height option to match vertical.\n* New window option main-pane-width to set the width of the large left pane with\n  main-vertical (was left-vertical) layout. \n* Lots of layout cleanup. manual layout is now manual-vertical.\n\n16 May 2009\n\n* select-layout command and a few default key bindings (M-0, M-1, M-2, M-9) to\n  select layouts.\n* Recreate server socket on SIGUSR1, per SF feature request 2792533.\n\n14 May 2009\n\n* Keys in status line (p in vi mode, M-y in emacs) to paste the first line\n  of the upper paste buffer. Suggested by Dan Colish.\n* clear-history command to clear a pane's history.\n* Don't force wrapping with \\n when asked, let the cursor code figure it out.\n  Should fix terminals which use this to detect line breaks.\n* Major cleanup and restructuring of build infrastructure. Still separate files\n  for GNU and BSD make, but they are now hugely simplified at the expense of\n  adding a configure script which must be run before make. Now build and\n  install with:\n\n\t$ ./configure && make && sudo make install\n\n04 May 2009\n\n* Use ACS line drawing characters for pane separator lines.\n\n30 April 2009\n\n* Support command sequences without a space before the semicolon, for example\n  \"neww; neww\" now works as well as \"neww ; neww\". \"neww;neww\" is still an\n  error.\n* previous-layout command.\n* Display the layout name in window lists.\n* Merge resize-pane-up and resize-pane-down into resize-pane with -U and -D\n  flags.\n\n29 April 2009\n\n* Get rid of compat/vis.* - only one function was used which is easily\n  replaced,and less compat code == good.\n\n27 April 2009\n\n* Avoid using the prompt history when the server is locked, and prevent any\n  input entered from being added to the client's prompt history.\n* New command, confirm-before (alias confirm), which asks for confirmation\n  before executing a command. Bound \"&\" and \"x\" by default to confirm-before\n  \"kill-window\" and confirm-before \"kill-pane\", respectively.\n\n23 April 2009\n\n* Support NEL, yet another way of making newline. Fixes the output from some\n  Gentoo packaging thing. Reported by someone on SF then logs that allowed a\n  fix sent by tcunha.\n* Use the xenl terminfo flag to detect early-wrap terminals like the FreeBSD\n  console. Many thanks for a very informative email from Christian Weisgerber.\n\n21 April 2009\n\n* tmux 0.8 released.\n\n17 April 2009\n\n* Remove the right number of characters from the buffer when escape then\n  a cursor key (or other key prefixed by \\033) is pressed. Reported by\n  Stuart Henderson.\n\n03 April 2009\n\n* rotate-window command. -U flag (default) for up, -D flag for down.\n\n02 April 2009\n\n* Change scroll/pane redraws to only redraw the single pane affected rather\n  than the entire window.\n* If redrawing the region would mean redrawing > half the pane, just schedule\n  to redraw the entire window. Also add a flag to skip updating the window any\n  further if it is scheduled to be redrawn. This has the effect of batching\n  multiple redraws together.\n\n01 April 2009\n\n* Basic horizontal splitting and layout management. Still some redraw and other\n  issues - particularly, don't mix with manual pane resizing, be careful when\n  viewing from multiple clients and don't expect shell windows to redraw very\n  well after the layout is changed; generally cycling the layout a few times\n  will fix most problems. Getting this in for testing while I think about how\n  to deal with manual mode.\n\n  Split window as normal and cycle the layouts with C-b space. Some of the\n  layouts will work better when swap-pane comes along.\n\n31 March 2009\n\n* AIX port, thanks to cmihai for access to a box. Only tested on 6.1 with xlc\n  10.1 (make sure CC is set). Needs GNU make and probably ncurses (didn't try\n  plain curses). Also won't build with DEBUG, so comment the FDEBUG=1 line in\n  GNUmakefile.\n* Draw a vertical line on the right when the window size is less than the\n  terminal size. This is partly to shake out any horizontal limit bugs on the\n  way to horizontal splitting/pane tiling. Currently a bit slow since it has to\n  do a lot of redrawing but hopefully that will improve as I get some better\n  ideas for how to do it.\n* Fix remaining problems with copy and paste and UTF-8.\n\n28 March 2009\n\n* Better UTF-8 support, including combined characters. Unicode data is now\n  stored as UTF-8 in a separate array, the code does a lookup into this every\n  time it gets to a UTF-8 cell. Zero width characters are just appended onto\n  the UTF-8 data for the previous cell. This also means that almost no bytes\n  extra are wasted non-Unicode data (yay).\n\n  Still some oddities, such as copy mode skips over wide characters in a\n  strange way, and the code could do with some tidying.\n* Key repeating is now a property of the key binding not of the command.\n  Repeat is turned on when the key is bound with the -r flag to bind-key.\n  next/previous-window no longer repeat by default as it turned out to annoy\n  me.\n\n27 March 2009\n\n* Clear using ED when redrawing the screen. I foolishly assumed using spaces\n  would be equivalent and terminals would pick up on this, but apparently not.\n  This fixes copy and paste in xterm/rxvt.\n* Sockets in /tmp are now created in a subdirectory named, tmux-UID, eg\n  tmux-1000. The default socket is thus /tmp/tmux-UID/default. To start a\n  separate server, the new -L command line option should be used: this creates\n  a socket in the same directory with a different name (\"-L main\" will create\n  socket called \"main\"). -S should only be used to place the socket outside\n  /tmp. This makes sockets a little more secure and a bit more convenient to\n  use multiple servers.\n\n21 March 2009\n\n* New session flag \"set-remain-on-exit\" to set remain-on-exit flag for new\n  windows created in that session (like \"remain-by-default\" used to do). Not\n  perfectly happy about this, but until I can think of a good way to introduce\n  it generically (maybe a set of options in the session) this will do. Fixes\n  SF request 2527847.\n\n07 March 2009\n\n* Support for 88 colour terminals.\n* break-pane command to create a new window using an existing pane.\n\n02 March 2009\n\n* Make escape key timer work properly so escape+key can be used without\n  lightning fast key presses.\n\n13 February 2009\n\n* Redo mode keys slightly more cleanly and apply them to command prompt\n  editing. vi or emacs mode is controlled by the session option status-keys.\n\n12 February 2009\n\n* Looking up argv[0] is expensive, so just use p_comm for the window name which\n  is good enough. Also increase name update time to 500 ms.\n\n11 February 2009\n\n* Only use ri when actually at the top of the screen; just move the cursor up\n  otherwise.\n* FreeBSD's console wraps lines at $COLUMNS - 1 rather than $COLUMNS (the\n  cursor can never be beyond $COLUMNS - 1) and does not appear to support\n  changing this behaviour, or any of the obvious possibilities (turning off\n  right margin wrapping, insert mode). This is irritating, most notably because\n  it impossible to write to the very bottom-right of the screen without\n  scrolling. To work around this, if built on FreeBSD and run with a \"cons\"\n  $TERM, the bottom-right cell on the screen is omitted.\n* Emulate scroll regions (slowly) to support the few terminals which don't have\n  it (some of which don't really have any excuse).\n\n10 February 2009\n\n* No longer redraw the status line every status-interval unless it has actually\n  changed.\n\n08 February 2009\n\n* Don't treat empty arguments (\"\") differently when parsing configuration\n  file/command prompt rather than command line.\n* tmux 0.7 released.\n\n03 February 2009\n\n* New command, copy-buffer (alias copyb), to copy a session paste buffer to\n  another session.\n\n01 February 2009\n\n* The character pair #(command) may now contain (escaped) right parenthesis.\n\n30 January 2009\n\n* . now bound to \"command-prompt 'move-window %%'\" by default, from joshe.\n\n29 January 2009\n\n* Window options to set status line fg, bg and attributes for a single\n  window. Options are: window-status-fg, window-status-bg,\n  window-status-attr. Set to \"default\" to use the session status colours.\n\n  This allows quite neat things like:\n\n\t$ cat ~/bin/xssh\n\t#!/bin/sh\n\n\tif [ ! -z \"$TMUX\" ]; then\n\tcase \"$1\" in\n    \tnatalya)\n\t        tmux setw window-status-fg red >/dev/null\n\t\t;;\n\tnatasha)\n        \ttmux setw window-status-fg yellow >/dev/null\n\t\t;;\n\tesac\n\tfi\n\tssh \"$@\"\n\t[ ! -z \"$TMUX\" ] && tmux setw -u window-status-fg >/dev/null\n\t$ alias ssh=\"~/bin/xssh\"\n\n* Support #(command) in status-left, and status-right, which is displayed as\n  the first line of command's output (e.g. set -g status-right\n  \"#(whoami)@#(hostname -s)\"). Commands with )s aren't supported.\n\n28 January 2009\n\n* Support mouse in copy mode to move cursor. Can't do anything else at the\n  moment until other mouse modes are handled.\n* Better support for at least the most common variant of mouse input: parse it\n  and adjust for different panes. Also support mouse in window/session choice\n  mode.\n\n27 January 2009\n\n* Bring back the fancy window titles with session/window names: it is easy to\n  work around problems with elinks (see FAQ).\n* -u flag to scroll-mode and copy-mode to start scrolled one page\n  up. scroll-mode -u is bound to prefix,page-up (ppage) by default.\n* Allow status, mode and message attributes to be changed by three new options:\n  status-attr, mode-attr, message-attr. A comma-separataed list is accepted\n  containing: bright, dim, underscore, blink, reverse, hidden, italics, for\n  example:\n\n\tset -g status-attr bright,blink\n\n  From Josh Elsasser, thanks!\n\n26 January 2009\n\n* Be more clever about picking the right process to create the window name.\n* Don't balls up the terminal on UTF-8 combined characters. Don't support them\n  properly either - they are just discarded for the moment.\n\n25 January 2009\n\n* load-buffer command\n\n23 January 2009\n\n* Use reverse colours rather than swapping fg and bg for message, mode and\n  status line. This makes these usable on black and white terminals.\n* Better error messages when creating a session or window fails.\n* Oops. Return non-zero on error. Reported by Will Maier.\n\n21 January 2009\n\n* Handle SIGTERM (and kill-server which uses it), a bit more neatly - tidy\n  up properly and print a nicer message. Same effect though :-).\n* new-window now supports -k to kill target window if it exists.\n* Bring back split-window -p and -l options to specify the height a percentage\n  or as a number of lines.\n* Make window and session choice modes allow you to choose items in vi keys\n  mode (doh!). As a side-effect, this makes enter copy selection (as well\n  as C-w/M-w) when using emacs keys in copy mode. Reported by merdely.\n\n20 January 2009\n\n* Darwin support for automatic-rename from joshe; Darwin doesn't seem to have\n  a sane method of getting argv[0] and searching for the precise insane way\n  is too frustrating, so this just uses the executable name.\n* Try to change the window title to match the command running it in. This is\n  done by reading argv[0] from the process group leader of the group that owns\n  the tty (tcgetpgrp()). This can't be done portably so some OS-dependent code\n  is introduced (ugh); OpenBSD, FreeBSD and Linux are supported at the moment.\n\n  A new window flag, automatic-rename, is available: if this is set to off, the\n  window name is not changed. Specifying a name with the new-window,\n  new-session or rename-window commands will automatically set this flag to off\n  for the window in question. To disable it entirely set the option to off\n  globally (setw -g automatic-rename off).\n\n19 January 2009\n\n* Fix various stupid issues when the status line is turned off. Grr.\n* Use reverse attributes for clock and cursor, otherwise they do not\n  appear on black and white terminals.\n* An error in a command sequence now stops execution of that sequence.\n  Internally, each command code now passes a return code back rather than\n  talking to the calling client (if any) directly.\n* attach-session now tries to start the server if it isn't already started - if\n  no sessions are created in .tmux.conf this will cause an error.\n* Clean up starting server by making initial client get a special socketpair.\n\n18 January 2009\n\n* Unbreak UTF-8.\n* -a flag to next-window and previous-window to select the next or previous\n  window with activity or bell. Bound to M-n and M-p.\n* find-window command to search window names, titles and visible content (but\n  not history) for a string. If only one is found, the window is selected\n  otherwise a choice list is shown. This (as with the other choice commands)\n  only works from a key. Bound to \"f\" by default.\n* Cleaned up command printing code, also enclose arguments with spaces in \"s.\n* Added command sequences. These are entered by separating each argument by a ;\n  argument (spaces on both sides), for example:\n\n\tlsk ; lsc\n\n  To use a literal ; as the argument prefix it with \\, for example:\n\n\tbind x lsk \\; lsc\n\n  Commands are executed from left to right. Also note that command sequences do\n  not support repeat-time repetition unless all commands making up the sequence\n  support it.\n* suspend-client command to suspend a client. Don't try to background it\n  though...\n* Mark attached sessions in sessions lists. Suggested by Simon Kuhnle.\n\n17 January 2009\n\n* tmux 0.6 released.\n\n15 January 2009\n\n* Support #H for hostname and #S for session name in status-left/right.\n* Two new commands, choose-window and choose-session which work only when bound\n  to a key and allow the window or session to be selected from a list. These\n  are now bound to \"w\" and \"s\" instead of the list commands.\n\n14 January 2009\n\n* Rework the prefix-time stuff. The option is now called repeat-time and\n  defaults to 500 ms. It only applies to a small subset of commands, currently:\n  up-pane, down-pane, next-window, previous-window, resize-pane-up,\n  resize-pane-down. These are the commands for which it is obviously useful,\n  having it for everything else was just bloody annoying.\n* The alt-up and alt-down keys now resize a pane by five lines at a time.\n* switch-pane is now select-pane and requires -p to select a pane. The\n  \"o\" key binding is changed to down-pane.\n* up-pane and down-pane commands, bound to arrow up and down by default.\n* Multiple vertical window splitting. Minimum pane size is four lines, an\n  (unhelpful) error will be shown if attempting to split a window with less\n  that eight lines. If the window is resized, as many panes are shown as can\n  fit without reducing them below four lines. There is (currently!) not a way\n  to show a hidden pane without making the window larger.\n\n  Note the -p and -l options to split-window are now gone, these may reappear\n  once I think them through again.\n* Server locking on inactivity (lock-after-time) is now disabled by default.\n\n13 January 2009\n\n* kill-pane command.\n\n12 January 2009\n\n* command-prompt now accepts a single argument, a template string. Any\n  occurrences of %% in this string are replaced by whatever is entered at the\n  prompt and the result is executed as a command. This allows things like (now\n  bound by default):\n\n  \t bind , command-prompt \"rename-window %%\"\n\n  Or my favourite:\n\n         bind x command-prompt \"split-window 'man %%'\"\n\n* Option to set prefix time, allowing multiple commands to be entered without\n  pressing the prefix key again, so long as they each typed within this time of\n  each other.\n* Yet more hacks for key handling. Think it is just about working now.\n* Two commands, resize-pane-up and resize-pane-down to resize a pane.\n* Make the window pane code handle panes of different sizes, and add a -l\n  and -p arguments to split-window to specify the new window size in lines\n  or as a percentage.\n\n11 January 2009\n\n* Vertical window splitting. Currently can only split a window into two panes.\n  New split-window command splits (bound to \") and switch-pane command (bound to\n  o) switches between panes.\n\n  close-pane, swap-pane commands are to follow. Also to come are pane resizing,\n  >2 panes, the ability to break a pane out to a full window and vice versa and\n  possibly horizontal splitting.\n\n  Panes are subelements of windows rather than being windows in their own\n  right. I tried to make them windows (so the splitting was at the session or\n  client level) but this rapidly became very complex and invasive. So in the\n  interests of having something working, I just made it so each window can have\n  two child processes instead of one (and it still took me 12 hours straight\n  coding). Now the concept is proven and much of the support code is there,\n  this may change in future if more flexibility is needed.\n* save-buffer command, from Tiago Cunha.\n\n10 January 2009\n\n* New option, lock-after-time. If there is no activity in the period specified\n  by this option (in seconds), tmux will lock the server. Default is 1800 (30\n  minutes), set to 0 to disable.\n* Server locking. Two new commands: set-password to set a password (a\n  preencrypted password may be specified with -c); and lock-server to lock the\n  server until the password is entered. Also an additional command line flag,\n  -U, to unlock from the shell. The default password is blank (any password\n  accepted). If specifying an encrypted password from encrypt(1) in .tmux.conf\n  with -c, don't forget to enclose it in single-quotes (') to prevent shell\n  variable expansion.\n* If a window is created from the command line, tmux will now use the same\n  current working directory for the new process. A new default-path option to\n  sets the working directory for processes created from keys or interactively\n  from the prompt.\n* New mode to display a large clock. Entered with clock-mode command (bound to\n  C-b t by default); two window options: clock-mode-colour and clock-mode-style\n  (12 or 24). This will probably be used as the basis for window locking.\n* New command, server-info, to show some server information and terminal\n  details.\n\n09 January 2009\n\n* Stop using ncurses variables and instead build a table of the codes we want\n  into an array for each terminal type. This makes the code a little more\n  untidy in places but gets rid of the awful global variables and calling\n  setterm all the time, and shoves all the ncurses-dependent mess into a single\n  file, tty-term.c. It also allows overriding single terminal codes, this is\n  used to fix rxvt on some platforms (where it is missing dch) and in future\n  may allow user customisation a la vim.\n* Update key handling code. Simplify, support ctrl properly and add a new\n  window option (xterm-keys) to output xterm key codes including ctrl and,\n  if available, alt and shift.\n\n08 January 2009\n\n* If built without DEBUG (the release versions), don't cause a fatal error if\n  the grid functions notice an input error, just log and ignore the\n  request. This might mean me getting shouted at less often when bugs kill\n  long-running sessions, at least in release versions.\n* Hopefully fix cursor out-of-bounds checking when writing to grid. When I\n  wrote the code I must have forgotten that the cursor can be one cell off the\n  right of the screen (yes, I know), so there were number of out-of-bounds/\n  overflow problems.\n\n07 January 2009\n\n* New flag to set and setw, -u, to unset an option (allowing it to inherit from)\n  the global options again.\n* Added more info messages for options changes.\n* A bit of tidying and reorganisation of options code.\n\n06 January 2009\n\n* Don't crash when backspacing if cursor is off the right of the screen,\n  reported by David Chisnall.\n* Complete words at any point inside command in prompt, also use option name\n  as well as command names.\n* Per-client prompt history of up to 100 items.\n* Use a splay tree for key bindings instead of an array. As a side-effect this\n  sorts them when listed.\n\n22 December 2008\n\n* Use the right keys for home and end.\n\n20 December 2008\n\n* Add vim mode for tmux configuration file to examples/, from Tiago Cunha.\n\n15 December 2008\n\n* New command, source-file (alias source), to load a configuration\n  file. Written by Tiago Cunha, many thanks.\n\n13 December 2008\n\n* Work around lack of dch. On Linux, the rxvt termcap doesn't have it (it is\n  lying, but we can't really start disbelieving termcaps...). This is a bit\n  horrible - I can see no way to do it without pretty much redrawing the whole\n  line, but it works...\n\n10 December 2008\n\n* glibc's getopt(3) is useless: it is not POSIX compliant without jumping\n  through non-portable hoops, and the method of resetting it is unclear (the\n  man page on my system says set optind to 1, but other sources say 0). So,\n  import OpenBSD's getopt_long.c into compat/ for use on Linux and use the\n  clearly documented optreset = optind = 1 method. This fixes some strange\n  issues with command parsing (getting the syntax wrong would prevent any\n  further commands being parsed).\n\n06 December 2008\n\n* Bring set/setw/show/showw into line with other commands. This means that by\n  default they now affect the current window (if any); the new -g flag must be\n  passed to set the global options. This changes the behaviour of set/show and\n  WILL BREAK CURRENT CONFIGURATIONS.\n\n  In summary, whether in the configuration file, the command prompt, or a key\n  binding, use -g to set a global option, use -t to specify a particular window\n  or session, or omit both to try and use the current window or session.\n\n  This makes set/show a bit of a pain but is the correct behaviour for\n  setw/showw and is the same as every other command, so we can put up with a\n  bit of pain for consistency.\n* Redo window options. They now work in the same way to session options with a\n  global options set. showw/setw commands now have similar syntax to show/set\n  (including the ability to use abbreviations).\n\n  PLEASE NOTE this includes the following configuration-breaking changes:\n\n  - remain-by-default is now GONE, use \"setw -g remain-on-exit\" to apply the\n    global window option instead;\n  - mode-keys is now a window option rather than session - use \"setw [-g]\n    mode-keys\" instead of set.\n\n  There are also some additions:\n\n  - message-fg and message-bg session options to control status line message\n    colours;\n  - mode-fg and mode-bg window options to set colours in window modes such as\n    copy mode.\n\n  The options code still a mess and now there is twice as much of it :-(.\n\n02 December 2008\n\n* Add support for including the window title in status-left or status-right\n  strings by including the character pair \"#T\". This may be prefixed with\n  a number to specify a maximum length, for example \"#24T\" to use at most\n  24 characters of the title.\n* Introduce two new options, status-left-length and status-right-length,\n  control the maximum length of left and right components of the status bar.\n* elinks (and possibly others) bypass the terminal and talk directly to X to\n  restore the window title when exiting. tmux can't know about this particular\n  bit of stupidity so the title ends up strange - the prefix isn't terribly\n  important and elinks is quite useful so just get rid of it.\n\n27 November 2008\n\n* Tweaks to support Dragonfly.\n\n17 November 2008\n\n* tmux 0.5 released.\n\n16 November 2008\n\n* New window option: \"utf8\"; this must be on (it is off by default) for UTF-8\n  to be parsed. The global/session option \"utf8-default\" controls the setting\n  for new windows.\n\n  This means that by default tmux does not handle UTF-8. To use UTF-8 by\n  default it is necessary to a) \"set utf8-default on\" in .tmux.conf b) start\n  tmux with -u on any terminal which support UTF-8.\n\n  It seems a bit unnecessary for this to be a per-window option but that is\n  the easiest way to do it, and it can't do any harm...\n* Enable default colours if op contains \\033[39;49m, based on a report from\n  fulvio ciriaco.\n\n12 November 2008\n\n* Keep stack of last windows rather than just most recent; based on a diff from\n  joshe.\n\n04 November 2008\n\n* Don't try to redraw status line when showing a prompt or message; if it does,\n  the status timer is never reset so it redraws on every loop. Spotted by\n  joshe.\n\n09 October 2008\n\n* Translate 256 colours into 16 if 256 is not available, same as screen does.\n* Better support for OSC command (only to set window title now), and also\n  support using APC for the same purpose (some Linux default shell profiles do\n  this).\n\n25 September 2008\n\n* Large internal rewrite to better support 256 colours and UTF-8. Screen data\n  is now stored as single two-way array of structures rather than as multiple\n  separate arrays. Also simplified a lot of code.\n\n  Only external changes are three new flags, -2, -d and -u, which force tmux to\n  assume the terminal supports 256 colours, default colours (useful for\n  xterm-256color which lacks the AX flag), or UTF-8 respectively.\n\n10 September 2008\n\n* Split off colour conversion code from screen code.\n\n09 September 2008\n\n* Initial UTF-8 support. A bit ugly and with a limit of 4096 UTF-8\n  characters per window.\n\n08 September 2008\n\n* 256 colour support. tmux attempts to autodetect the terminal by looking\n  both at what ncurses reports (usually wrong for xterm) and checking if\n  the TERM contains \"256col\". For xterm TERM=xterm-256color is needed (as\n  well as a build that support 256 colours); this seems to work for rxvt\n  as well. On non-256 colour terminals, high colours are translated to white\n  foreground and black background.\n\n28 August 2008\n\n* Support OS X/Darwin thanks to bsd-poll.c from OpenSSH. Also convert\n  from clock_gettime(2) to gettimeofday(2) as OS X doesn't support the\n  former; microsecond accuracy will have to be sufficient ;-).\n\n07 August 2008\n\n* Lose some unused/useless wrapper functions.\n\n25 July 2008\n\n* Shell variables may now be defined and used in configuration file. Define\n  variables with:\n\n\tVAR=1\n\n  And use with:\n\n        renamew ${VAR}\n\trenamew \"x${VAR}x\"\n\n Also some other fixes to make, for example, \"abc\"\"abc\" work similarly to\n the shell.\n\n24 July 2008\n\n* Finally lose inconsistently-used SCREEN_DEF* defines.\n* If cursor mode is on, switch the arrow keys from \\033[A to \\033OA.\n* Support the numeric keypad in both application and numbers mode. This is\n  different from screen which always keeps it in application mode.\n\n19 July 2008\n\n* Unbreak \"set status\" - tmux thought it was ambiguous, reported by rivo nurges.\n\n02 July 2008\n\n* Split vi and emacs mode keys into two tables and add an option (mode-keys)\n  to select between them. Default is emacs, use,\n\n     tmux set mode-keys vi\n\n  to change to vi.\n\n  vi mode uses space to start selection, enter to copy selection and escape\n  to clear selection.\n\n01 July 2008\n\n* Protocol versioning. Clients which identify as a different version from the\n  server will be rejected.\n* tmux 0.4 released.\n\n29 June 2008\n\n* Zombie windows. These are not closed when the child process dies. May be\n  set for a window with the new \"remain-on-exit\" option; the default setting\n  of this flag for new windows may be set with the \"remain-by-default\" session\n  option.\n\n  A window may be restarted with the respawn-window command:\n\n  \trespawn-window [-k] [command]\n\n  If -k is given, any existing process running in the window is killed;\n  if command is omitted, the same command as when the window was first\n  created is used.\n\n27 June 2008\n\n* Handle nonexistent session or client to -t properly.\n\n25 June 2008\n\n* select-prompt command to allow a window to be selected at a prompt. Only\n  windows in the current session may be selected. Bound to ' by default.\n  Suggested by merdely.\n* move-window command. Requested by merdely.\n* Support binding alt keys (prefixed with M-). Change default to use\n  C- for ctrl keys (^ is still accepted as an alternative).\n* Slim down default key bindings: support lowercase only.\n* Handle escaped keys properly (parse eg \\033b into a single key code) and\n  use this to change copy mode next/previous work to M-f and M-b to match\n  emacs.\n\n24 June 2008\n\n* Next word (C-n/w) and previous word (C-b/b) in copy mode.\n\n23 June 2008\n\n* list-commands command (alias lscm).\n* Split information about options into a table and use it to parse options\n  on input (allowing abbreviations) and to print them with show-options\n  (meaning that bell-action gets a proper string). This turned out a bit ugly\n  though :-/.\n\n22 June 2008\n\n* Do not translate black and white into default if the terminal supports\n  default colours. This was nice to force programs which didn't use default\n  colours to be properly transparent in rxvt/aterm windows with a background\n  image, but it causes trouble if someone redefines the default foreground and\n  background (to have black on white or something).\n\n21 June 2008\n\n* Naive tab completion in the command prompt. This only completes command\n  names if a) they are at the start of the text b) the cursor is at\n  the end of the text c) the text contains no spaces.\n* Only attempt to set the title where TERM looks like an xterm (contains\n  \"xterm\", \"rxvt\" or is \"screen\"). I hate this but I don't see a better way:\n  setting the title actually kills some other terminals pretty much dead.\n* Strip padding out of terminfo(5) strings. Currently the padding is just\n  ignored, this may need to be altered if there are any software terminals\n  out there that actually need it.\n\n20 June 2008\n\n* buffer-limit option to set maximum size of buffer stack. Default is 9.\n* Initial buffer improvements. Each session has a stack of buffers and each\n  buffer command takes a -b option to manipulate items on the stack. If -b\n  is omitted, the top entry is used. The following commands are currently\n  available:\n\n\tset-buffer [-b index] [-t target-session] string\n\tpaste-buffer [-d] [-b index] [-t target-window]\n\tdelete-buffer [-b index] [-t target-session]\n\tshow-buffers [-t target-session]\n\tshow-buffer [-b index] [-t target-session]\n\n  -d to paste-buffer deletes the buffer after pasting it.\n* New option, display-time, sets the time status line messages stay on screen\n  (unless a key is pressed). Set in milliseconds, default is 750 (0.75 seconds).\n  The timer is only checked every 100 ms or so.\n\n19 June 2008\n\n* Use \"status\" consistently for status line option, and prefix for \"prefix\" key\n  option.\n* Allow commands to be entered at a prompt. This is triggered with the\n  command-prompt command, bound to : by default.\n* Show status messages properly, without blocking the server.\n\n18 June 2008\n\n* New option, set-titles. On by default, this attempts to set the window title\n  using the \\e]2;...\\007 xterm code.\n\n  Note that elinks requires the STY environment variable (used by screen) to be\n  set before it will set the window title. So, if you want window titles set by\n  elinks, set STY before running it (any value will do). I can't do this for all\n  windows since setting it to an invalid value breaks screen.\n* Show arrows at either end of status line when scrolled if more windows\n  exist. Highlight the arrow if a hidden window has activity or bell.\n* Scroll the status line to show the current window if necessary. Also handle\n  windows smaller than needed better (show a blank status line instead of\n  hanging or crashing).\n\n17 June 2008\n\n* tmux 0.3 released.\n\n16 June 2008\n\n* Add some information messages when window options are changed, suggested by\n  Mike Erdely. Also add a -q command-line option to suppress them.\n* show-window-options (showw) command.\n\n15 June 2008\n\n* show-options (show) command to show one or all options.\n\n14 June 2008\n\n* New window options: force-width and force-height. This will force a window\n  to an arbitrary width and height (0 for the default unlimited). This is\n  neat for emacs which doesn't have a sensible way to force hard wrapping at 80\n  columns. Also, don't try to be clever and use clr_eol when redrawing the\n  whole screen, it causes trouble since the redraw functions are used to draw\n  the blank areas too.\n* Clear the blank area below windows properly when they are smaller than client,\n  also add an indicator line to show the vertical limit.\n* Don't die on empty strings in config file, reported by Will Maier.\n\n08 June 2008\n\n* Set socket mode +x if any sessions are attached and -x if not.\n\n07 June 2008\n\n* Make status-interval actually changeable.\n\n06 June 2008\n\n* New window option: aggressive-resize. Normally, windows are resized to the\n  size of the smallest attached session to which they are linked. This means a\n  window only changes size when sessions are detached or attached, or they are\n  linked or unlinked from a session. This flag changes a window to be the size\n  of the smallest attached session for which it is the current window - it is\n  resized every time a session changes to it or away from it. This is nice for\n  things that handle SIGWINCH well (like irssi) and bad for things like shells.\n* The server now exits when no sessions remain.\n* Fix bug with inserting characters with TERM=xterm-color.\n\n05 June 2008\n\n* Completely reorganise command parsing. Much more common code in cmd-generic.c\n  and a new way of specifying windows, clients or sessions. Now, most commands\n  take a -t argument, which specifies a client, a session, or a window target.\n  Clients and sessions are given alone (sessions are fnmatch(3)d and\n  clients currently not), windows are give by (client|session):index. For\n  example, if a user is in session \"1\" window 0 on /dev/ttypi, these should all\n  be equivalent:\n\n\ttmux renamew newname\t\t\t(current session and window)\n\ttmux renamew -t: newname\t\t(current session and window)\n\ttmux renamew -t:0 newname\t\t(current session, window 0)\n\ttmux renamew -t0 newname\t\t(current session, window 0)\n\ttmux renamew -t1:0 newname\t\t(session 1, window 0)\n\ttmux renamew -t1: newname\t\t(session 1's current window)\n\ttmux renamew -t/dev/ttypi newname\t(client /dev/ttypi's current\n\t\t\t\t\t\t session and window)\n\ttmux renamew -t/dev/ttypi: newname\t(client /dev/ttypi's current\n\t\t\t\t\t\t session and window)\n\ttmux renamew -t/dev/ttypi:0 newname\t(client /dev/ttypi's current\n\t\t\t\t\t\t session, window 0)\n\n  This does have some downsides, for example, having to use -t on selectw,\n\n\ttmux selectw -t7\n\n  is annoying. But then using non-flagged arguments would mean renaming the\n  current window would need to be something like:\n\n\ttmux renamew : newname\n\n  It might be better not to try and be so consistent; comments to the usual\n  address ;-).\n* Infrastructure for printing arguments in list-keys output. Easy ones only for\n  now.\n\n04 June 2008\n\n* Add some vi(1) key bindings in copy mode, and support binding ^[, ^\\, ^]\n  ^^ and ^_. Both from/prompted by Will Maier.\n* setw monitor-activity and set status without arguments now toggle the current\n  value; suggested by merdely.\n* New command set-window-option (alias setw) to set the single current window\n  option: monitor-activity to determine whether window activity is shown in\n  the status bar for that window (default off).\n* Change so active/bell windows are inverted in status line.\n* Activity monitoring - window with activity are marked in status line. No\n  way to disable this/filter windows yet.\n* Brought select-window command into line with everything else; it now uses\n  -i for the window index.\n* Strings to display on the left and right of the status bar may now be set\n  with the status-left and status-right options. These are passed through\n  strftime(3) before being displayed. The status bar is automatically updated\n  at an interval set by the status-interval option. The default is to display\n  nothing on the left and the date and time on the left; the default update\n  interval is 15 seconds.\n\n03 June 2008\n\n* Per session options. Setting options without specifying a session sets the\n  global options as normal (global options are inherited by all sessions);\n  passing -c or -s will set the option only for that session.\n* Because a client has a session attached, any command needing a session can\n  take a client and use its session. So, anything that used to accept -s now\n  accepts -c as well.\n* -s to specify session name now supports fnmatch(3) wildcards; if multiple\n  sessions are found, or if no -s is specified, the most newly created is used.\n* If no command is specified, assume new-session. As a byproduct, clean up\n  command default values into separate init functions.\n* kill-server command.\n\n02 June 2008\n\n* New command, start-server (alias \"start\"), to start the tmux server and do\n  nothing else. This is good if you have a configuration file which creates\n  windows or sessions (like me): in that case, starting the server the first\n  time tmux new is run is bad since it creates a new session and window (as\n  it is supposed to - starting the server is a side-effect).\n\n  Instead, I have a little script which does the equivalent of:\n\n  \ttmux has -s0 2>/dev/null || tmux start\n  \ttmux attach -d -s0\n\n  And I use it to start the server if necessary and attach to my primary\n  session.\n* Basic configuration file in ~/.tmux.conf or specified with -f. This is file\n  contains a set of tmux commands that are run the first time the server is\n  started. The configuration commands are executed before any others, so\n  if you have a configuration file that contains:\n\n\tnew -d\n\tneww -s0\n\n  And you do the following without an existing server running:\n\n\ttmux new\n\n  You will end up with two sessions, session 0 with two windows (created by\n  the configuration file) and your client attached to session 1 with one\n  window (created by the command-line command). I'm not completely happy with\n  this, it seems a little non-obvious, but I haven't yet decided what to do\n  about it.\n\n  There is no environment variable handling or other special stuff yet.\n\n  In the future, it might be nice to be able to have per-session configuration\n  settings, probably by having conditionals in the file (so you could, for\n  example, have commands to define a particular window layout that would only\n  be invoked if you called tmux new -smysession and mysession did not already\n  exist).\n* BIG CHANGE: -s and -c to specify session name and client name are now passed\n  after the command rather than before it. So, for example:\n\n\ttmux -s0 neww\n\n  Becomes:\n\n\ttmux neww -s0\n\n  This is to allow them to be used in the (forthcoming) configuration file\n  THIS WILL BREAK ANY CURRENT SCRIPTS OR ALIASES USING -s OR -c.\n\n01 June 2008\n\n* Bug fix: don't die if -k passed to link-window and the destination doesn't\n  exist.\n* New command, send-keys, will send a set of keys to a window.\n\n31 May 2008\n\n* Fix so tmux doesn't hang if the initial window fails for some reason. This\n  was highlighted by problems on Darwin, thanks to Elias Pipping for the report\n  and access to a test account. (tmux still won't work on Darwin since its\n  poll(2) is broken.)\n\n02 January 2008\n\n* Don't attempt to reset the tty on exit if it has been closed externally.\n\n06 December 2007\n\n* Restore checks for required termcap entries and add a few more obvious\n  emulations.\n* Another major reorganisation, this time of screen handling. A new set of\n  functions, screen_write_*, are now used to write to a screen and a tty\n  simultaneously. These are used by the input parser to update the base\n  window screen and also by the different modes which now interpose their own\n  screen.\n\n30 November 2007\n\n* Support \\ek...\\e\\ to set window name.\n\n27 November 2007\n\n* Enable/disable mouse when asked, if terminal claims to support it. Mouse\n  sequences are just passed through unaltered for the moment.\n* Big internal reorganisation. Rather than leaving control of the tty solely in\n  the client and piping all data through a socket to it, change so that the\n  server opens the tty again and reads and writes to it directly. This avoids\n  a lot of buffering and copying. Also reorganise the redrawing stuff so that\n  everything goes through screen_draw_* - this makes the code simpler, but\n  still needs broken up more, and all the ways of writing to screens should be\n  more consistent.\n\n26 November 2007\n\n* Rather than shifting up one line at a time once the history is full,\n  shift by 10% of the history each time. This is faster.\n* Add ^A and ^E to copy mode to move to start-of-line/end-of-line.\n\n24 November 2007\n\n* Support for alt charset mode (VT100 graphics characters).\n\n23 November 2007\n\n* Mostly complete copy & paste. Copy mode entered with C-b [ (copy-mode\n  command). In copy mode, arrow keys/page up/page down/hjkl/C-u/C-f navigate,\n  space or C-space starts selection, and enter or C-w copies and (important!)\n  exits copy mode. C-b ] (paste-buffer) pastes into current window. No\n  extra utility keys (bol/eol/clear selection/etc), only one single buffer,\n  and no buffer manipulation commands (clear/view/etc) yet. The code is also\n  fugly :-(.\n* history-limit option to set maximum history. Does not apply retroactively to\n  existing windows! Lines take up a variable amount of space, but a reasonable\n  guess for an 80-column terminal is 250 KB per 1000 lines (of history used,\n  an empty history takes no space).\n\n21 November 2007\n\n* Create every line as zero length and only expand it as data is written,\n  rather than creating at full size immediately.\n* Make command output (eg list-keys) go to a scrollable window similar to\n  scroll mode.\n* Redo screen redrawing so it is a) readable b) split into utility functions\n  that can be used outside screen.c. Use these to make scroll mode only\n  redraw what it has to which gets rid of irritating flickering status box and\n  makes it much faster.\n* Full line width memory and horizontal scrolling in history.\n* Initial support for scroll history. = to enter scrolling mode, and then\n  vi keys or up/down/pgup/pgdown to navigate. Q to exit. No horizontal history\n  yet (need per-line sizes) and a few kinks to be worked out (resizing while in\n  history mode will probably cause trouble).\n\n20 November 2007\n\n* Fix format string error with \"must specify a client\" message. Also\n  sprinkle some printflike tags.\n* tmux 0.1 released.\n\n17 November 2007\n\n* (nicm) Add -k option to link-window to kill target window if it exists.\n\n16 November 2007\n\n* (nicm) Split in-client display into two columns. This is a hack but not a lot\n  more so than that bit is already and it helps with lots of keys.\n* (nicm) switch-client command to switch client between different sessions. This\n  is pretty cool:\n\n\t$ tmux bind q switch 0\n\t$ tmux bind w switch 1\n\n  Then you can switch between sessions 0 and 1 with a key :-).\n* (nicm) Accept \"-c client-tty\" on command line to allow client manipulation\n  commands, and change detach-/refresh-session to detach-/refresh-client (this\n  loses the -a behaviour, but at some point -session versions may return, and\n  -c will allow fnmatch(3)).\n* (nicm) List available commands on ambiguous command.\n\n12 November 2007\n\n* (nicm) If the terminal supports default colours (AX present), force black\n  background and white foreground to default. This is useful on transparent\n  *terms for programs which don't do it themselves (like most(1)).\n* (nicm) Fill in the rest of the man page.\n* (nicm) kill-session command.\n\n09 November 2007\n\n* (nicm) C-space is now \"^ \" not \"^@\".\n* (nicm) Support tab (\\011).\n* (nicm) Initial man page outline.\n* (nicm) -V to show version.\n* (nicm) rename-session command.\n\n08 November 2007\n\n* (nicm) Check for required terminal capabilities on start.\n\n31 October 2007\n\n* (nicm) Linux port.\n\n30 October 2007\n\n* (nicm) swap-window command. Same as link-window but swaps windows.\n\n26 October 2007\n\n* (nicm) Saving scroll region on \\e7 causes problems with ncmpc so I guess\n  it is not required.\n* (nicm) unlink-window command.\n* (nicm) link-window command to link an existing window into another session\n  (or another index in the same session). Syntax:\n\n\ttmux -s dstname link-window [-i dstidx] srcname srcidx\n\n* (nicm) Redo window data structures. The global array remains, but each per-\n  session list is now a RB tree of winlink structures. This disassociates the\n  window index from the array size (allowing arbitrary indexes) which still\n  allowing windows to have multiple indexes.\n\n25 October 2007\n\n* (nicm) has-session command: checks if session exists.\n\n24 October 2007\n\n* (nicm) Support for \\e6n to request cursor position. resize(1) now works.\n* (nicm) Support for \\e7, \\e8 save/restore cursor and attribute sequences.\n  Currently don't save mode (probably should). Also change some cases where\n  out-of-bound values are ignored to limit them to within range (there are\n  others than need to be checked too).\n\n23 October 2007\n\n* (nicm) Lift limit on session name passed with -s.\n* (nicm) Show size in session/window lists.\n* (nicm) Pass tty up to server when client identifies and add a list-clients\n  command to list connected clients.\n\n20 October 2007\n\n* (nicm) Add default-command option and change default to be $SHELL rather than\n  $SHELL -l. Also try to read shell from passwd db if $SHELL isn't present.\n\n19 October 2007\n\n* (nicm) -n on new-session is now -s, and -n is now the initial window name.\n  This was documented but not implemented :-/.\n* (nicm) kill-window command, bound to & by default (because it should be hard\n  to hit accidently).\n* (nicm) bell-style option with three choices: \"none\" completely ignore bell;\n  \"any\" pass through a bell in any window to current; \"current\" ignore bells\n  except in current window. This applies only to the bell terminal signal,\n  the status bar always reflects any bells.\n* (nicm) Refresh session command.\n\n12 October 2007\n\n* (nicm) Add a warning if $TMUX exists on new/attach.\n* (nicm) send-prefix command. Bound to C-b by default.\n* (nicm) set status, status-fg, status-bg commands. fg and bg are as a number\n  from 0 to 8 or a string (\"red\", \"blue\", etc). status may be 1/0, on/off,\n  yes/no.\n* (nicm) Make status line mark window in yellow on bell.\n\n04 October 2007\n\n* (nicm) -d option to attach to detach all other clients on the same session.\n* (nicm) Partial resizing support. Still buggy. A C-b S and back sometimes fixes\n  it when it goes wonky.\n* (mxey) Added my tmux start script as an example (examples/start-tmux.sh).\n* (mxey) New sessions can now be given a command for their first window.\n* (mxey) Fixed usage statement for new-window.\n* (nicm) attach-session (can't believe I forgot it until now!) and list-windows\n  commands.\n* (nicm) rename-window and select-window commands.\n* (nicm) set-option command (alias set): \"tmux set-option prefix ^A\".\n* (nicm) Key binding and unbinding is back.\n\n03 October 2007\n\n* (nicm) {new,next,last,previous}-window.\n* (nicm) Rewrite command handling so commands are much more generic and the\n  same commands are used for command line and keys (although most will probably\n  need to check how they are called). Currently incomplete (only new/detach/ls\n  implemented). Change: -s is now passed before command again!\n* (nicm) String number arguments. So you can do: tmux bind ^Q create \"blah\".\n* (nicm) Key binding. tmux bind key command [argument] and tmux unbind key.\n  Key names are in a table in key-string.c, plus A is A, ^A is ctrl-A.\n  Possible commands are in cmd.c (look at cmd_bind_table).\n* (nicm) Move command parsing into the client. Also rename some messages and\n  tidy up a few bits. Lots more tidying up needed :-/.\n\n02 October 2007\n\n* (nicm) Redraw client status lines on rename.\n* (nicm) Error on ambiguous command.\n\n01 October 2007\n\n* (nicm) Restore window title handling.\n* (nicm) Simple uncustomisable status line with window list.\n\n30 September 2007\n\n* (nicm) Window info command for debugging, C-b I.\n\n29 September 2007\n\n* (nicm) Deleting/inserting lines should follow scrolling region. Fix.\n* (nicm) Allow creation of detached sessions: \"tmux new-session -d\".\n* (nicm) Permit error messages to be passed back for transient clients like\n  rename. Also make rename -i work.\n* (nicm) Pass through bell in any window to current.\n\n28 September 2007\n\n* (nicm) Major rewrite of input parser:\n\t- Lose the old weirdness in favour of a state machine.\n\t- Merge in parsing from screen.c.\n\t- Split key parsing off into a separate file.\n  This is step one towards hopefully allowing a status line. It requires\n  that we output data as if the terminal had one line less than it really does -\n  a serious problem when it comes to things like scrolling. This change\n  consolidates all the range checking and limiting together which should make\n  it easier.\n* (mxey) Added window renaming, like \"tmux rename [-s session] [-i index] name\"\n\n27 September 2007\n\n* Split \"tmux list\" into \"tmux list-sessions\" (ls) and \"list-windows\" (lsw).\n* New command session selection:\n\t- if name is specified, look for it and use it if it exists, otherwise\n\t  error\n\t- if no name specified, try the current session from $TMUX\n\t- if $TMUX doesn't exist, and there is only one session, use it,\n\t  otherwise error\n\n26 September 2007\n\n* Add command aliases, so \"ls\" is an alias for \"list\".\n* Rename some commands and alter syntax to take options after a la CVS. Also\n  change some flags. So:\n\n\ttmux -s/socket -nabc new\n\n  Becomes:\n\n\ttmux -S/socket new -sabc\n\n* Major tidy and split of client/server code.\n\n22 September 2007\n\n* Window list command (C-b W). Started by Maximilian Gass, finished by me.\n\n20 September 2007\n\n* Specify meta via environment variable (META).\n* Record last window and ^L key to switch to it. Largely from Maximilian Gass.\n* Reset ignored signals in child after forkpty, makes ^C work.\n* Wrap on next/previous. From Maximilian Gass.\n\n19 September 2007\n\n* Don't renumber windows on close.\n\n28 August 2007\n\n* Scrolling region (\\e[r) support.\n\n27 August 2007\n\n* Change screen.c to work more logically and hopefully fix heap corruption.\n\n09 July 2007\n\n* Initial import to CVS. Basic functions are working, albeit with a couple of\n  showstopper memory bugs and many missing features. Detaching, reattaching,\n  creating new sessions, listing sessions work acceptably for using with shells.\n  Simple curses programs (top, systat, tetris) and more complicated ones (mutt,\n  emacs) that don't require scrolling regions (ESC[r) mostly work fine\n  (including mutt, emacs). No status bar yet and no key remapping or other\n  customisation.\n"
        },
        {
          "name": "COPYING",
          "type": "blob",
          "size": 1.0869140625,
          "content": "THIS IS FOR INFORMATION ONLY, CODE IS UNDER THE LICENCE AT THE TOP OF ITS FILE.\n\nThe README, CHANGES, FAQ and TODO files are licensed under the ISC\nlicense. Files under examples/ remain copyright their authors unless otherwise\nstated in the file but permission has been received to distribute them with\ntmux. All other files have a license and copyright notice at their start,\ntypically:\n\nCopyright (c) <author>\n\nPermission to use, copy, modify, and distribute this software for any\npurpose with or without fee is hereby granted, provided that the above\ncopyright notice and this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\nWITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\nANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\nWHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\nIN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\nOUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 1.27734375,
          "content": "ARG PLATFORM=amd64\nFROM ${PLATFORM}/alpine:3.10 AS build\n\nWORKDIR /build\n\nRUN apk add --no-cache wget cmake make gcc g++ linux-headers zlib-dev openssl-dev \\\n            automake autoconf libevent-dev ncurses-dev msgpack-c-dev libexecinfo-dev \\\n            ncurses-static libexecinfo-static libevent-static msgpack-c ncurses-libs \\\n            libevent libexecinfo openssl zlib\n\nRUN set -ex; \\\n            mkdir -p /src/libssh/build; \\\n            cd /src; \\\n            wget -O libssh.tar.xz https://www.libssh.org/files/0.9/libssh-0.9.0.tar.xz; \\\n            tar -xf libssh.tar.xz -C /src/libssh --strip-components=1; \\\n            cd /src/libssh/build; \\\n            cmake -DCMAKE_INSTALL_PREFIX:PATH=/usr \\\n            -DWITH_SFTP=OFF -DWITH_SERVER=OFF -DWITH_PCAP=OFF \\\n            -DWITH_STATIC_LIB=ON -DWITH_GSSAPI=OFF ..; \\\n            make -j $(nproc); \\\n            make install\n\nCOPY compat ./compat\nCOPY *.c *.h autogen.sh Makefile.am configure.ac ./\n\nRUN ./autogen.sh && ./configure --enable-static\nRUN make -j $(nproc)\nRUN objcopy --only-keep-debug tmate tmate.symbols && chmod -x tmate.symbols && strip tmate\nRUN ./tmate -V\n\nFROM alpine:3.9\n\nRUN apk --no-cache add bash\nRUN mkdir /build\nENV PATH=/build:$PATH\nCOPY --from=build /build/tmate.symbols /build\nCOPY --from=build /build/tmate /build\n"
        },
        {
          "name": "FAQ",
          "type": "blob",
          "size": 18.203125,
          "content": "tmux frequently asked questions\n\n******************************************************************************\n* PLEASE NOTE: most display problems are due to incorrect TERM! Before       *\n* reporting problems make SURE that TERM settings are correct inside and     *\n* outside tmux.                                                              *\n*                                                                            *\n* Inside tmux TERM must be \"screen\" or similar (such as \"screen-256color\").  *\n* Don't bother reporting problems where it isn't!                            *\n*                                                                            *\n* Outside, it must match your terminal: particularly, use \"rxvt\" for rxvt    *\n* and derivatives.                                                           *\n******************************************************************************\n\n* How is tmux different from GNU screen?\n\ntmux and GNU screen have many similarities. Some of the main differences I am\naware of are (bearing in mind I haven't used screen for a few years now):\n\n- tmux uses a client-server model. Each server has single Unix domain socket in\n  /tmp and within one server there are multiple sessions which may be attached\n  to multiple clients (terminals).\n\n  This has advantages, notably: windows may be linked simultaneously to\n  multiple sessions; windows may be moved freely between sessions; and a client\n  may be switched between sessions easily (C-b D). There is one major\n  disadvantage: if the server crashes, game over, all sessions die. In\n  practice, however, tmux is quite stable and gets more so as people report any\n  bugs they hit :-).\n\n  This model is different from screen, where typically each new screen instance\n  is independent. tmux supports the same behaviour by using multiple servers\n  with the -L option but it is not typically recommended.\n\n- Different command interfaces. One of the goals of tmux is that the shell\n  should be easily usable as a scripting language - almost all tmux commands\n  can be used from the shell and behave identically whether used from the\n  shell, from a key binding or from the command prompt. Personally I also find\n  tmux's command interface much more consistent and clearer, but this is\n  subjective.\n\n- tmux calls window names (what you see in the status line) \"names\", screen\n  calls them \"titles\".\n\n- tmux has a multiple paste buffers. Not a major one but comes in handy quite a\n  lot.\n\n- tmux supports automatically renaming windows to the running application\n  without gross hacks using escape sequences. Its even on by default.\n\n- tmux has a choice of vi or emacs key layouts. Again, not major, but I use\n  emacs so if tmux did support only one key set it would be emacs and then all\n  the vi users would get humpy. Key bindings may be completely reconfigured in\n  any case.\n\n- tmux has an option to limit the window size.\n\n- tmux has search in windows (C-b f).\n\n- The window split (pane) model is different. tmux has two objects, windows and\n  panes; screen has just windows. This difference has several implications:\n\n  * In screen you can have a window appear in several layouts, in tmux a pane\n  can only be in one window (fixing this is a big todo item but quite\n  invasive).\n\n  * tmux layouts are immutable and do not get changed unless you modify them.\n\n  * In tmux, all panes are closed when you kill a window.\n\n  * tmux panes do not have individual names, titles and so on.\n\n  I think tmux's model is much easier to manage and navigate within a window,\n  but breaking panes off from and joining them to windows is more clumsy.\n\n  tmux also has support for preset pane layouts.\n\n- tmux's status line syntax is more readable and easier to use. I think it'd be\n  hard for anyone to argue with this. tmux doesn't support running a command\n  constantly and always using the last line of its output, commands must be run\n  again each time.\n\n- tmux has modern, easily extended code. Again hard to argue screen is better\n  if you have looked at the code.\n\n- tmux depends on libevent. I don't see this as a disadvantage: libevent is\n  small and portable, and on modern systems with current package management\n  systems dependencies are not an issue. libevent brings advantages in code\n  simplicity and performance.\n\n- screen allows the window to be bigger than the terminal and can pan around\n  it. tmux limits the size to the largest attached client. This is a big todo\n  item for tmux but it is not trivial.\n\n- screen has builtin serial and telnet support; this is bloat and is unlikely\n  to be added to tmux.\n\n- Environment handling is different.\n\n- tmux tends to be more demanding on the terminal so tends to show up terminal\n  and application bugs which screen does not.\n\n- screen has wider platform support, for example IRIX, and for odd terminals.\n\n* I found a bug! What do I do?\n\nCheck the latest version of tmux from Git to see if the problem is still\nreproducible.  Sometimes the length of time between releases means a lot of\nfixes can be sitting in Git and the problem might already be fixed.\n\nPlease send bug reports by email to nicholas.marriott@gmail.com or\ntmux-users@googlegroups.com. Please include as much of the following\ninformation as possible:\n\n- the version of tmux you are running;\n- the operating system you are using and its version;\n- the terminal emulator you are using and the TERM setting when tmux was\n  started;\n- a description of the problem;\n- if the problem is repeatable, the steps to repeat the problem;\n- for screen corruption issues, a screenshot and the output of \"infocmp $TERM\"\n  from outside tmux are often very useful.\n\n* Why doesn't tmux do $x?\n\nPlease send feature requests by email to tmux-users@googlegroups.com.\n\n* Why do you use the screen terminal description inside tmux? It sucks.\n\nIt is already widely available. It is planned to change to something else such\nas xterm-xfree86 at some point, if possible.\n\n* I don't see any colour in my terminal! Help!\n\nOn some platforms, common terminal descriptions such as xterm do not include\ncolour. screen ignores this, tmux does not. If the terminal emulator in use\nsupports colour, use a value for TERM which correctly lists this, such as\nxterm-color.\n\n* tmux freezes my terminal when I attach to a session. I even have to kill -9\n  the shell it was started from to recover!\n\nSome consoles really really don't like attempts to set the window title. Tell\ntmux not to do this by turning off the \"set-titles\" option (you can do this\nin .tmux.conf):\n\n     set -g set-titles off\n\nIf this doesn't fix it, send a bug report.\n\n* Why is C-b the prefix key? How do I change it?\n\nThe default key is C-b because the prototype of tmux was originally developed\ninside screen and C-b was chosen not to clash with the screen meta key. It\nalso has the advantage of not interfering with the use of C-a for start-of-line\nin emacs and the shell (although it does interfere with previous-character).\n\nChanging is simple: change the \"prefix-key\" option, and - if required - move\nthe binding of the \"send-prefix\" command from C-b (C-b C-b sends C-b by\ndefault) to the new key. For example:\n\n\tset -g prefix C-a\n\tunbind C-b\n\tbind C-a send-prefix\n\n* How do I use UTF-8?\n\nWhen running tmux in a UTF-8 capable terminal, UTF-8 must be turned on in tmux;\nas of release 0.9, tmux attempts to autodetect a UTF-8-capable terminal by\nchecking the LC_ALL, LC_CTYPE and LANG environment variables. list-clients may\nbe used to check if this is detected correctly; if not, the -u command-line\nflag may be specified when creating or attaching a client to a tmux session:\n\n\t$ tmux -u new\n\nSince the 1.0 release, tmux will turn on UTF-8 related options automatically\n(ie status-utf8, and utf8) if the above conditions are met.\n\n* How do I use a 256 colour terminal?\n\nProvided the underlying terminal supports 256 colours, it is usually sufficient\nto add the following to ~/.tmux.conf:\n\n\tset -g default-terminal \"screen-256color\"\n\nNote that some platforms do not support \"screen-256color\" (\"infocmp\nscreen-256color\" will return an error) - in this case see the next entry in\nthis FAQ.\n\ntmux attempts to detect a 256 colour terminal both by looking at the colors\nterminfo entry and by looking for the string \"256col\" in the TERM environment\nvariable.\n\nIf both these methods fail, the -2 flag may be passed to tmux when attaching\nto a session to indicate the terminal supports 256 colours.\n\n* vim or $otherprogram doesn't display 256 colours. What's up?\n\nSome programs attempt to detect the number of colours a terminal is capable of\nby checking the colors terminfo or Co termcap entry. However, this is not\nreliable, and in any case is missing from the \"screen\" terminal description\nused inside tmux.\n\nThere are two options (aside from using \"screen-256color\") to allow programs to\nrecognise they are running on a 256-colour terminal inside tmux:\n\n- Manually force the application to use 256 colours always or if TERM is set to\n  screen. For vim, you can do this by overriding the t_Co option, see\n  http://vim.wikia.com/wiki/256_colors_in_vim.\n- Creating a custom terminfo file that includes colors#256 in ~/.terminfo and\n  using it instead. These may be compiled with tic(1).\n\n* How do I make Ctrl-PgUp and Ctrl-PgDn work in vim?\n\ntmux supports passing through ctrl (and where supported by the client terminal,\nalt and shift) modifiers to function keys using xterm(1)-style key sequences.\nThis may be enabled per window, or globally with the tmux command:\n\n\tsetw -g xterm-keys on\n\nBecause the TERM variable inside tmux must be set to \"screen\", vim will not\nautomatically detect these keys are available; however, the appropriate key\nsequences can be overridden in .vimrc using the following:\n\n\tif &term == \"screen\"\n\tset t_kN=^[[6;*~\n\tset t_kP=^[[5;*~\n\tendif\n\nAnd similarly for any other keys for which modifiers are desired.\n\nPlease note that the \"xterm-keys\" setting may affect other programs, in the\nsame way as running them in a standard xterm; for example most shells do not\nexpect to receive xterm(1)-style key sequences so this setting may prevent keys\nsuch as ctrl-left and ctrl-right working correctly. tmux also passes through\nthe ctrl (bit 5 set, for example ^[[5~ to ^[[5^) modifier in non-xterm(1) mode;\nit may be possible to configure vim to accept these, an example of how to do so\nwould be welcome.\n\nvim users may also want to set the \"ttyfast\" option inside tmux.\n\n* How do I make ctrl and shift arrow keys work in emacs?\n\nThe terminal-init-screen function in term/screen.el is called for new frames,\nbut it doesn't configure any function keys.\n\nIf the tmux xterm-keys option is on, it is enough to define the same keys as\nxterm. Add the following to init.el or .emacs to do this:\n\n(defadvice terminal-init-screen\n  ;; The advice is named `tmux', and is run before `terminal-init-screen' runs.\n  (before tmux activate)\n  ;; Docstring.  This describes the advice and is made available inside emacs;\n  ;; for example when doing C-h f terminal-init-screen RET\n  \"Apply xterm keymap, allowing use of keys passed through tmux.\"\n  ;; This is the elisp code that is run before `terminal-init-screen'.\n  (if (getenv \"TMUX\")\n    (let ((map (copy-keymap xterm-function-map)))\n    (set-keymap-parent map (keymap-parent input-decode-map))\n    (set-keymap-parent input-decode-map map))))\n\nAnd ensure .tmux.conf contains \"set -g xterm-keys on\".\n\nAlternatively, the screen.el file can be copied to the load path and\ncustomized.\n\n* Why doesn't elinks set the window title inside tmux?\n\nThere isn't a way to detect if a terminal supports setting the window title, so\nelinks attempts to guess by looking at the environment. Rather than looking for\nTERM=screen, it uses the STY variable to detect if it is running in screen;\ntmux does not use this so the check fails. A workaround is to set STY before\nrunning elinks.\n\nThe following shell function does this, and also clears the window title on\nexit (elinks, for some strange reason, sets it to the value of TERM):\n\n\telinks() {\n        \tSTY= `which elinks` $*\n\t        echo -ne \\\\033]0\\;\\\\007;\n\t}\n\n* What is the proper way to escape characters with #(command)?\n\nWhen using the #(command) construction to include the output from a command in\nthe status line, the command will be parsed twice. First, when it's read by the\nconfiguration file or the command-prompt parser, and second when the status\nline is being drawn and the command is passed to the shell. For example, to\necho the string \"(test)\" to the status line, either single or double quotes\ncould be used:\n\n\tset -g status-right \"#(echo \\\\\\\\(test\\\\\\\\))\"\n\tset -g status-right '#(echo \\\\\\(test\\\\\\))'\n\nIn both cases, the status-right option will be set to the string \"#(echo\n\\\\(test\\\\))\" and the command executed will be \"echo \\(test\\)\".\n\n* tmux uses too much CPU. What do I do?\n\nAutomatic window renaming may use a lot of CPU, particularly on slow computers:\nif this is a problem, turn it off with \"setw -g automatic-rename off\". If this\ndoesn't fix it, please report the problem.\n\n* I use PuTTY and my tmux window pane separators are all qqqqqqqqq's! \n\nPuTTY is using a character set translation that doesn't support ACS line\ndrawing. With a Unicode font, try setting PuTTY to use a different translation\non the Window -> Translation configuration page. For example, change UTF-8 to\nISO-8859-1 or CP437. It may also be necessary to adjust the way PuTTY treats\nline drawing characters in the lower part of the same configuration page.\n\n* What is the best way to display the load average? Why no #L?\n\nIt isn't possible to get the load average portably in code and it is preferable\nnot to add portability goop. The following works on at least Linux, *BSD and OS\nX:\n\nuptime|awk '{split(substr($0, index($0, \"load\")), a, \":\"); print a[2]}'\n\n* How do I attach the same session to multiple clients but with a different\n  current window, like screen -x?\n\nOne or more of the windows can be linked into multiple sessions manually with\nlink-window, or a grouped session with all the windows can be created with\nnew-session -t.\n\n* Ctrl and arrow keys doesn't work in putty! What do I do?\n\nputty inverts the sense of the cursor key mode on ctrl, which is a bit hard for\ntmux to detect properly. To get ctrl keys right, change the terminfo settings\nso kUP5 (Ctrl-Up etc) are the adjusted versions, and disable smkx/rmkx so tmux\ndoesn't change the mode. For example with this line in .tmux.conf (assuming you\nhave TERM set to xterm):\n\nset -g terminal-overrides \"xterm*:kLFT5=\\eOD:kRIT5=\\eOC:kUP5=\\eOA:kDN5=\\eOB:smkx@:rmkx@\"\n\nNote that this will only work in tmux 1.2 and above.\n\n* How can I blank the tmux window?\n\nGNU screen has a feature whereby it will blank the screen after a period of\ninactivity. To do the same thing in tmux, use the lock-command setting, for\nexample (with GNU bash):\n\nset -g lock-command 'tput civis && read -s -n1'\n\nThis will remove the cursor and tell the shell to quit once a key has been\npressed. For zsh, use \"read -s -k1\".\n\nIn addition, it's possible to have both blanking and locking (for instance via\nlock(1) or vlock(1)) by using the following:\n\nbind x set lock-command '/usr/bin/vlock' \\; lock-client \\; set lock-command 'tput civis && read -s -n1'\n\n* I don't see italics! Or less and vim show italics and reverse the wrong way round!\n\nGNU screen does not support italics and the \"screen\" terminfo description uses\nthe italics escape sequence incorrectly.\n\nAs of tmux 2.1, if default-terminal is set to \"screen\" or matches \"screen-*\",\ntmux will behave like screen and italics will be disabled.\n\nTo enable italics, create a new terminfo entry called \"tmux\" (some platforms\nmay already have this, you can check with \"infocmp tmux\"):\n\n\t$ cat <<EOF|tic -x -\n\ttmux|tmux terminal multiplexer,\n\t\tritm=\\E[23m, rmso=\\E[27m, sitm=\\E[3m, smso=\\E[7m, Ms@,\n\t\tuse=xterm+tmux, use=screen,\n\n\ttmux-256color|tmux with 256 colors,\n\t\tuse=xterm+256setaf, use=tmux,\n\tEOF\n\t$\n\nAnd tell tmux to use it in ~/.tmux.conf:\n\t\n\tset -g default-terminal \"tmux\"\n\nIf using urxvt, make sure you have an italics capable font enabled. for\nexample, add to ~/.Xdefaults:\n\n\turxvt.italicFont: xft:Bitstream Vera Sans Mono:italic:autohint=true\n\n* How can I make tmux use my terminal's scrollback buffer?\n\nNormally, tmux enables the terminal's \"alternate screen\". Most terminals (such\nas xterm) do not save scrollback for the alternate screen. You might prefer\ntmux to use the normal screen, so it uses your terminal's scrollback\nbuffer. This way, you can access the scrollback buffer as usual, for example\nusing the mouse wheel - although there is no guarantee output inside tmux will\nalways (or ever) be added to the scrollback.\n\nYou can make tmux use the normal screen by telling it that your terminal does\nnot have an alternate screen. Put the following in ~/.tmux.conf:\n\n        set -ga terminal-overrides ',xterm*:smcup@:rmcup@'\n\nAdjust if your $TERM does not start with xterm.\n\ntmux will still emulate the alternate screen for applications run under tmux,\nso you don't really lose anything with this setting. The only disadvantage is\nthat when you exit tmux, it will not restore whatever was there before you\nstarted.\n\n* How do I see the default configuration?\n\nShow the default session options by starting a new tmux server with no\nconfiguration file:\n\n        $ tmux -Lfoo -f/dev/null start\\; show -g\n\nOr the default window options:\n\n        $ tmux -Lfoo -f/dev/null start\\; show -gw\n\n* How do I copy a selection from tmux to the system's clipboard?\n\nWhen running in xterm(1), tmux can automatically send copied text to the\nclipboard. This is controlled by the set-clipboard option and also needs this\nX resource to be set:\n\n\tXTerm*disallowedWindowOps: 20,21,SetXprop\n\nFor rxvt-unicode (urxvt), there is an unofficial Perl extension here:\n\n        http://anti.teamidiot.de/static/nei/*/Code/urxvt/\n\nOtherwise a key binding for copy mode using xclip (or xsel) works:\n\n\tbind -temacs-copy C-y copy-pipe \"xclip -i >/dev/null\"\n\nOr for inside and outside copy mode with the prefix key:\n\n        bind C-y run -b \"tmux save-buffer - | xclip -i\"\n\nOn OS X, reattach-to-usernamespace lets pbcopy/pbpaste work:\n\n        https://github.com/ChrisJohnsen/tmux-MacOSX-pasteboard\n \n* Why do I see dots around a session when I attach to it?\n\ntmux limits the size of the window to the smallest attached session. If\nit didn't do this then it would be impossible to see the entire window.\nThe dots mark the size of the window tmux can display.\n\nTo avoid this, detach all other clients when attaching:\n\n\t$ tmux attach -d\n\nOr from inside tmux by detaching individual clients with C-b D or all\nusing:\n\n\tC-b : attach -d\n"
        },
        {
          "name": "Makefile.am",
          "type": "blob",
          "size": 5.546875,
          "content": "# Makefile.am\n\n# Obvious program stuff.\nbin_PROGRAMS = tmate\nCLEANFILES = tmate.1.mdoc tmate.1.man\n\n# Distribution tarball options.\nEXTRA_DIST = \\\n\tCHANGES FAQ README TODO COPYING example_tmux.conf compat/*.[ch] \\\n\tarray.h compat.h tmux.h osdep-*.c xmalloc.h mdoc2man.awk tmate.1\ndist-hook:\n\tmake clean\n\tgrep \"^#found_debug=\" configure\n\n# Preprocessor flags.\nCPPFLAGS += @XOPEN_DEFINES@ -DTMUX_CONF=\"\\\"$(sysconfdir)/tmux.conf\\\"\"\n\n# glibc as usual does things ass-backwards and hides useful things by default,\n# so everyone has to add this.\nif IS_GLIBC\nCFLAGS += -D_GNU_SOURCE\nendif\n\nif IS_LINUX\nCFLAGS += -rdynamic # for stack traces\nendif\n\n# Set flags for gcc.\nif IS_GCC\nCFLAGS += -std=gnu99 -O2\nif IS_DEBUG\nCFLAGS += -g\nCFLAGS += -Wno-long-long -Wall -W -Wnested-externs -Wformat=2\nCFLAGS += -Wmissing-prototypes -Wstrict-prototypes -Wmissing-declarations\nCFLAGS += -Wwrite-strings -Wshadow -Wpointer-arith -Wsign-compare\nCFLAGS += -Wundef -Wbad-function-cast -Winline\nCFLAGS += -Wno-pointer-sign -Wno-attributes\nCPPFLAGS += -DDEBUG\nendif\nif IS_COVERAGE\nCFLAGS += -g -O0 --coverage\nLDFLAGS += --coverage\nendif\nCPPFLAGS += -iquote.\nendif\n\nCFLAGS += -Wno-unused-parameter -Wno-unused-variable -Wno-null-pointer-arithmetic\nCFLAGS += -Wno-deprecated-declarations -Wno-format-nonliteral\n\n# Set flags for Solaris.\nif IS_SUNOS\nif IS_GCC\nCPPFLAGS += -D_XPG6 -D__EXTENSIONS__ -D_POSIX_PTHREAD_SEMANTICS\nelse\nCPPFLAGS += -D_XPG4_2 -D__EXTENSIONS__ -D_POSIX_PTHREAD_SEMANTICS\nendif\nendif\n\n# Set flags for Sun CC.\nif IS_SUNCC\nCFLAGS += -erroff=E_EMPTY_DECLARATION\nendif\n\n# Set _LINUX_SOURCE_COMPAT for AIX for malloc(0).\nif IS_AIX\nDEFS += -D_LINUX_SOURCE_COMPAT=1\nendif\n\n# List of sources.\ndist_tmate_SOURCES = \\\n\talerts.c \\\n\targuments.c \\\n\tattributes.c \\\n\tcfg.c \\\n\tclient.c \\\n\tcmd-attach-session.c \\\n\tcmd-bind-key.c \\\n\tcmd-break-pane.c \\\n\tcmd-capture-pane.c \\\n\tcmd-choose-buffer.c \\\n\tcmd-choose-client.c \\\n\tcmd-choose-tree.c \\\n\tcmd-clear-history.c \\\n\tcmd-command-prompt.c \\\n\tcmd-confirm-before.c \\\n\tcmd-copy-mode.c \\\n\tcmd-detach-client.c \\\n\tcmd-display-message.c \\\n\tcmd-display-panes.c \\\n\tcmd-find.c \\\n\tcmd-find-window.c \\\n\tcmd-if-shell.c \\\n\tcmd-join-pane.c \\\n\tcmd-kill-pane.c \\\n\tcmd-kill-server.c \\\n\tcmd-kill-session.c \\\n\tcmd-kill-window.c \\\n\tcmd-list-buffers.c \\\n\tcmd-list-clients.c \\\n\tcmd-list-keys.c \\\n\tcmd-list-panes.c \\\n\tcmd-list-sessions.c \\\n\tcmd-list-windows.c \\\n\tcmd-list.c \\\n\tcmd-load-buffer.c \\\n\tcmd-lock-server.c \\\n\tcmd-move-window.c \\\n\tcmd-new-session.c \\\n\tcmd-new-window.c \\\n\tcmd-paste-buffer.c \\\n\tcmd-pipe-pane.c \\\n\tcmd-queue.c \\\n\tcmd-refresh-client.c \\\n\tcmd-rename-session.c \\\n\tcmd-rename-window.c \\\n\tcmd-resize-pane.c \\\n\tcmd-respawn-pane.c \\\n\tcmd-respawn-window.c \\\n\tcmd-rotate-window.c \\\n\tcmd-run-shell.c \\\n\tcmd-save-buffer.c \\\n\tcmd-select-layout.c \\\n\tcmd-select-pane.c \\\n\tcmd-select-window.c \\\n\tcmd-send-keys.c \\\n\tcmd-set-buffer.c \\\n\tcmd-set-environment.c \\\n\tcmd-set-hook.c \\\n\tcmd-set-option.c \\\n\tcmd-show-environment.c \\\n\tcmd-show-messages.c \\\n\tcmd-show-options.c \\\n\tcmd-source-file.c \\\n\tcmd-split-window.c \\\n\tcmd-string.c \\\n\tcmd-swap-pane.c \\\n\tcmd-swap-window.c \\\n\tcmd-switch-client.c \\\n\tcmd-unbind-key.c \\\n\tcmd-wait-for.c \\\n\tcmd.c \\\n\tcolour.c \\\n\tcontrol.c \\\n\tcontrol-notify.c \\\n\tenviron.c \\\n\tformat.c \\\n\tgrid-view.c \\\n\tgrid.c \\\n\thooks.c \\\n\tinput-keys.c \\\n\tinput.c \\\n\tjob.c \\\n\tkey-bindings.c \\\n\tkey-string.c \\\n\tlayout-custom.c \\\n\tlayout-set.c \\\n\tlayout.c \\\n\tlog.c \\\n\tmode-key.c \\\n\tnames.c \\\n\tnotify.c \\\n\toptions-table.c \\\n\toptions.c \\\n\tpaste.c \\\n\tproc.c \\\n\tresize.c \\\n\tscreen-redraw.c \\\n\tscreen-write.c \\\n\tscreen.c \\\n\tserver-client.c \\\n\tserver-fn.c \\\n\tserver.c \\\n\tsession.c \\\n\tsignal.c \\\n\tstatus.c \\\n\tstyle.c \\\n\ttmate-debug.c \\\n\ttmate-ssh-client.c \\\n\ttmate-encoder.c \\\n\ttmate-decoder.c \\\n\ttmate-env.c \\\n\ttmate-msg.c \\\n\ttmate-msgpack.c \\\n\ttmate-session.c \\\n\ttmux.c \\\n\ttty-acs.c \\\n\ttty-keys.c \\\n\ttty-term.c \\\n\ttty.c \\\n\tutf8.c \\\n\twindow-choose.c \\\n\twindow-clock.c \\\n\twindow-copy.c \\\n\twindow.c \\\n\txmalloc.c \\\n\txterm-keys.c\nnodist_tmate_SOURCES = osdep-@PLATFORM@.c\n\n# Pile in all the compat/ stuff that is needed.\nif NO_FORKPTY\nnodist_tmate_SOURCES += compat/forkpty-@PLATFORM@.c\nendif\nif NO_IMSG\nnodist_tmate_SOURCES += compat/imsg.c compat/imsg-buffer.c\nendif\nif NO_CLOSEFROM\nnodist_tmate_SOURCES += compat/closefrom.c\nendif\nif NO_DAEMON\nnodist_tmate_SOURCES += compat/daemon.c\nendif\nif NO_SETENV\nnodist_tmate_SOURCES += compat/setenv.c\nendif\nif NO_STRLCAT\nnodist_tmate_SOURCES += compat/strlcat.c\nendif\nif NO_STRLCPY\nnodist_tmate_SOURCES += compat/strlcpy.c\nendif\nif NO_ASPRINTF\nnodist_tmate_SOURCES += compat/asprintf.c\nendif\nif NO_FGETLN\nnodist_tmate_SOURCES += compat/fgetln.c\nendif\nif NO_FPARSELN\nnodist_tmate_SOURCES += compat/fparseln.c\nendif\nif NO_GETOPT\nnodist_tmate_SOURCES += compat/getopt.c\nendif\nif NO_STRCASESTR\nnodist_tmate_SOURCES += compat/strcasestr.c\nendif\nif NO_STRSEP\nnodist_tmate_SOURCES += compat/strsep.c\nendif\nif NO_VIS\nnodist_tmate_SOURCES += compat/vis.c compat/unvis.c\nendif\nif NO_STRTONUM\nnodist_tmate_SOURCES += compat/strtonum.c\nendif\nif NO_B64_NTOP\nnodist_tmate_SOURCES += compat/b64_ntop.c\nendif\nif NO_CFMAKERAW\nnodist_tmate_SOURCES += compat/cfmakeraw.c\nendif\nif NO_OPENAT\nnodist_tmate_SOURCES += compat/openat.c\nendif\nif NO_REALLOCARRAY\nnodist_tmate_SOURCES += compat/reallocarray.c\nendif\n\n# Install tmate.1 in the right format.\ninstall-exec-hook:\n\tif test x@MANFORMAT@ = xmdoc; then \\\n\t\tsed -e \"s|@SYSCONFDIR@|$(sysconfdir)|g\" $(srcdir)/tmate.1 \\\n\t\t\t>$(srcdir)/tmate.1.mdoc; \\\n\telse \\\n\t\tsed -e \"s|@SYSCONFDIR@|$(sysconfdir)|g\" $(srcdir)/tmate.1| \\\n\t\t\t$(AWK) -f$(srcdir)/mdoc2man.awk >$(srcdir)/tmate.1.man; \\\n\tfi\n\t$(mkdir_p) $(DESTDIR)$(mandir)/man1\n\t$(INSTALL_DATA) $(srcdir)/tmate.1.@MANFORMAT@ \\\n\t\t$(DESTDIR)$(mandir)/man1/tmate.1\n"
        },
        {
          "name": "README",
          "type": "blob",
          "size": 2.0322265625,
          "content": "Welcome to tmux!\n\ntmux is a \"terminal multiplexer\", it enables a number of terminals (or windows)\nto be accessed and controlled from a single terminal. tmux is intended to be a\nsimple, modern, BSD-licensed alternative to programs such as GNU screen.\n\nThis release runs on OpenBSD, FreeBSD, NetBSD, Linux, OS X and Solaris.\n\ntmux depends on libevent 2.x. Download it from:\n\n\thttp://libevent.org\n\nTo build tmux from a release tarball, do:\n\n\t$ ./configure && make\n\t$ sudo make install\n\nTo get and build the latest from version control:\n\n\t$ git clone https://github.com/tmux/tmux.git\n\t$ cd tmux\n\t$ sh autogen.sh\n\t$ ./configure && make\n\nFor more information see http://git-scm.com. Patches should be sent by email to\nthe mailing list at tmux-users@googlegroups.com.\n\nFor documentation on using tmux, see the tmux.1 manpage. It can be viewed from\nthe source tree with:\n\n\t$ nroff -mdoc tmux.1|less\n\nSome common questions are answered in the FAQ file and a more extensive (but\nslightly out of date) guide is available in the OpenBSD FAQ at\nhttp://www.openbsd.org/faq/faq7.html#tmux. A rough todo list is in the TODO\nfile and an example configuration in example_tmux.conf.\n\nA vim(1) syntax file is available at:\n\n   https://github.com/keith/tmux.vim\n   https://raw.githubusercontent.com/keith/tmux.vim/master/syntax/tmux.vim\n\nAnd a bash(1) completion file at:\n\n   https://github.com/przepompownia/tmux-bash-completion\n\nFor debugging, running tmux with -v or -vv will generate server and client log\nfiles in the current directory.\n\ntmux mailing lists are available. For general discussion and bug reports:\n\n\thttps://groups.google.com/forum/#!forum/tmux-users\n\nAnd for Git commit emails:\n\n\thttps://groups.google.com/forum/#!forum/tmux-git\n\nBug reports, feature suggestions and especially code contributions are most\nwelcome. Please send by email to:\n\n\ttmux-users@googlegroups.com\n\nThis file and the CHANGES, FAQ, SYNCING and TODO files are licensed under the\nISC license. All other files have a license and copyright notice at their start.\n\n-- Nicholas Marriott <nicholas.marriott@gmail.com>\n"
        },
        {
          "name": "README-tmux",
          "type": "blob",
          "size": 1.994140625,
          "content": "Welcome to tmux!\n\ntmux is a \"terminal multiplexer\", it enables a number of terminals (or windows)\nto be accessed and controlled from a single terminal. tmux is intended to be a\nsimple, modern, BSD-licensed alternative to programs such as GNU screen.\n\nThis release runs on OpenBSD, FreeBSD, NetBSD, Linux, OS X and Solaris.\n\ntmux depends on libevent 2.x. Download it from:\n\n\thttp://www.monkey.org/~provos/libevent/\n\nTo build tmux from a release tarball, do:\n\n\t$ ./configure && make\n\t$ sudo make install\n\nTo get and build the latest from version control:\n\n\t$ git clone https://github.com/tmux/tmux.git\n\t$ cd tmux\n\t$ sh autogen.sh\n\t$ ./configure && make\n\nFor more information see http://git-scm.com. Patches should be sent by email to\nthe mailing list at tmux-users@googlegroups.com.\n\nFor documentation on using tmux, see the tmux.1 manpage. It can be viewed from\nthe source tree with:\n\n\t$ nroff -mdoc tmux.1|less\n\nSome common questions are answered in the FAQ file and a more extensive (but\nslightly out of date) guide is available in the OpenBSD FAQ at\nhttp://www.openbsd.org/faq/faq7.html#tmux. A rough todo list is in the TODO\nfile and some example configurations and a Vim syntax file are in the examples\ndirectory.\n\nFor debugging, running tmux with -v or -vv will generate server and client log\nfiles in the current directory.\n\ntmux mailing lists are available. For general discussion and bug reports:\n\n\thttps://groups.google.com/forum/#!forum/tmux-users\n\nAnd for Git commit emails:\n\n\thttps://groups.google.com/forum/#!forum/tmux-git\n\nBug reports, feature suggestions and especially code contributions are most\nwelcome. Please send by email to:\n\n\ttmux-users@googlegroups.com\n\nThis file and the CHANGES, FAQ, SYNCING and TODO files are licensed under\nthe ISC license. Files under examples/ remain copyright their authors unless\notherwise stated in the file but permission has been received to distribute\nthem with tmux. All other files have a license and copyright notice at their\nstart.\n\n-- Nicholas Marriott <nicholas.marriott@gmail.com>\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.181640625,
          "content": "tmate\n=====\n\nWhat is it?\n-----------\n\nTmate is a fork of tmux. It provides an instant pairing solution.\n\nLicense\n-------\n\ntmate is built on top of tmux. tmux and tmate are BSD-licensed.\n"
        },
        {
          "name": "SYNCING",
          "type": "blob",
          "size": 5.716796875,
          "content": "Preamble\n========\n\nTmux portable relies on  repositories \"tmux\" and \"tmux-openbsd\".\nHere's a description of them:\n\n* \"tmux\" is the portable version, the one which contains code for other\n  operating systems, and autotools, etc., which isn't found or needed in the\n  OpenBSD base system.\n\n* \"tmux-openbsd\" is the version of tmux in OpenBSD base system which provides\n  the basis of the portable tmux version.\n\nNote:  The \"tmux-openbsd\" repository is actually handled by \"git cvsimport\"\nrunning at 15 minute intervals, so a commit made to OpenBSD's tmux CVS\nrepository will take at least that long to appear in this git repository.\n(It might take longer, depending on the CVS mirror used to import the\nOpenBSD code).\n\nIf you've never used git before, git tracks meta-data about the committer\nand the author, as part of a commit, hence:\n\n% git config [--global] user.name \"Your name\"\n% git config [--global] user.email \"you@yourdomain.com\"\n\nNote that, if you already have this in the global ~/.gitconfig option, then\nthis will be used.  Setting this per-repository would involve not using the\n\"--global\" flag above.   If you wish to use the same credentials always,\npass the \"--global\" option, as shown.\n\nThis is a one-off operation once the repository has been cloned, assuming\nthis information has ever been set before.\n\nCloning repositories\n====================\n\nThis involves having both tmux and tmux-openbsd cloned, as in:\n\n% cd /some/where/useful\n% git clone https://github.com/tmux/tmux.git\n% git clone https://github.com/ThomasAdam/tmux-openbsd.git\n\nNote that you do not need additional checkouts to manage the sync -- an\nexisting clone of either repositories will suffice.  So if you already have\nthese checkouts existing, skip that.\n\nAdding in git-remotes\n=====================\n\nBecause the portable \"tmux\" git repository and the \"tmux-openbsd\"\nrepository do not inherently share any history between each other, the\nhistory has been faked between them.  This \"faking of history\" is something\nwhich has to be told to git for the purposes of comparing the \"tmux\" and\n\"tmux-openbsd\" repositories for syncing.  To do this, we must reference the\nclone of the \"tmux-openbsd\" repository from the \"tmux\" repository, as\nshown by the following command:\n\n% cd /path/to/tmux\n% git remote add obsd-tmux file:///path/to/tmux-openbsd\n\nSo that now, the remote \"obsd-tmux\" can be used to reference branches and\ncommits from the \"tmux-openbsd\" repository, but from the context of the\nportable \"tmux\" repository, which makes sense because it's the \"tmux\"\nrepository which will have the updates applied to them.\n\nFetching updates\n================\n\nTo ensure the latest commits from \"tmux-openbsd\" can be found from within\n\"tmux\", we have to ensure the \"master\" branch from \"tmux-openbsd\" is\nup-to-date first, and then reference that update in \"tmux\", as in:\n\n% cd /path/to/tmux-openbsd\n% git checkout master\n% git pull\n\nThen back in \"tmux\":\n\n% cd /path/to/tmux\n% git fetch obsd-tmux\n\nCreating the necessary branches\n===============================\n\nNow that \"tmux\" can see commits and branches from \"tmux-openbsd\" by way\nof the remote name \"obsd-tmux\", we can now create the master branch from\n\"tmux-openbsd\" in the \"tmux\" repository:\n\n% git checkout -b obsd-master obsd-tmux/master\n\nAdding in the fake history points\n================================= \n\nTo tie both the \"master\" branch from \"tmux\" and the \"obsd-master\"\nbranch from \"tmux-openbsd\" together, the fake history points added to the\n\"tmux\" repository need to be added.  To do this, we must add an\nadditional refspec line, as in:\n\n% cd /path/to/tmux\n% git config --add remote.origin.fetch '+refs/replace/*:refs/replace/*'\n% git fetch origin\n\nPerforming the Sync\n===================\n\nMake sure the \"master\" branch is checked out:\n\n% git checkout master\n\nThe following will show commits on OpenBSD not yet synched with \"tmux\":\n\n% git log master..obsd-master\n\nFrom there, merge the result in, fixing up any conflicts which might arise.\n\n% git merge obsd-master\n\nThen ensure things look correct by BULDING the result of that sync:\n\n% make clean && ./autogen.sh && ./configure && make\n\nCompare the git merge result with what's on origin/master -- that is, check\nwhich commits you're about to push:\n\n% git log origin/master..master\n\nAnd if happy:\n\n% git push origin master\n\nKeeping an eye on libutil in OpenBSD\n====================================\n\nA lot of the compat/ code in tmux comes from libutil, especially imsg.\nSometimes the API can change, etc., which might cause interesting problems\ntrying to run the portable version of tmux.  It's worth checking\nperiodically for any changes to libutil in OpenBSD and syncing those files\nto compat/ as and when appropriate.\n\nRelease tmux for next version\n=============================\n\n1. Comment the \"found_debug=yes\" line in configure.ac, since releases\n   don't have debugging enabled, otherwise make(1) aborts when\n   preparing the distribution.\n\n2. Update and commit README and CHANGES.  The former should be checked for\n   anything outdated and updated with a list of things that might break\n   upgrades and the latter should mention all the major changes since\n   the last version.\n\n3. Tag with:\n\n   % git tag -a 2.X\n\n   Where \"2.X\" is the next version.\n\n   Push the tag out with:\n\n   % git push 2.X\n\n4. Build the tarball with 'make dist'.\n\n5. Check the tarball.  If it's good, go here to select the tag just pushed:\n\n   https://github.com/tmux/tmux/tags\n\n   Click the \"Add release notes\", upload the tarball and add a link in the\n   description field to the CHANGES file.\n\n7. Clone the tmux.github.io repository, and change the RELEASE version in\n   the Makefile.  Commit it, and run 'make' to replace %%VERSION%%.  Push\n   the result out.\n\n8. Bump version in tmu/tmux.git configure.ac and uncomment \"found_debug=yes\" to\n   create a debug build by default.\n"
        },
        {
          "name": "TODO",
          "type": "blob",
          "size": 5.90234375,
          "content": "- command bits and pieces:\n\t* allow multiple targets: fnmatch for -t/-c, for example detach all\n\t  clients with -t*\n\t* add -c for new-session like new-window\n\t* ' and \" should be parsed the same (eg \"\\e\" vs '\\e') in config\n\t  and command prompt\n\t* last-pane across sessions\n\t* list-keys should quote output so that bindings can just be used in\n          config file as-is\n\n- make command sequences more usable\n\t* don't require space after ;\n\t* options for error handling: && and ||?\n\n- options bits and pieces:\n\t* set-remain-on-exit is a complete hack\n\t* way to set socket path from config file\n\n- format improvements:\n\t* option to quote format (#{q:session_name})\n\t* formats need conditions for >0 (for #P)\n\t* some way to pad # stuff with spaces\n\t* formats to show if a window is linked into multiple sessions, into\n\t  multiple attached sessions, and is the active window in multiple\n\t  attached sessions?\n\n- choose mode improvements:\n\t* choose-pane command (augment choose-tree to do this?)\n\t* choose-mode and copy-mode are very similar, make choose-mode a subset?\n\t* flag to choose-* for sort order\n\t* choose mode would be better per client than per window?\n\t* two choices (first one then second, for swap-pane and join-pane)\n\t* choose modes should ditch the key bindings and just have fixed keys, and\n          be more customized to their purpose (d to delete a buffer for choose-buffer,\n          a preview of buffer contents, etc)\n\n- improve monitor-*:\n\t* straighten out rules for multiple clients\n\t* think about what happens across sessions\n\t* monitor changes within a region\n\t* perhaps monitor /all/ panes in the window not just one\n\n- improve mouse support:\n\t* bind commands to mouse in different areas? \n\t* commands executed when clicking on a pattern (URL)\n\n- hooks!\n\n- warts on current naming:\n\t* display-time but message-fg/bg/attr\n\t* list-* vs show-*\n\t* split-window -> split-pane?\n\n- better UTF-8 support:\n\t* message display\n\t* prompt input\n\t* searching in copy mode\n\n- copy/paste improvements:\n\t* incremental searching\n\t* paste w/o trailing whitespace\n\t* command to toggle selection not to move it in copy-mode\n\t* regex searching\n\t* copy-pipe should have -x as well\n\t* copy mode key bindings should just be a standard key table, using\n          something like \"copy-mode start-selection\"; it could use\n          command-prompt for search, goto, etc:\n\n              bind -Temacs command-prompt -p'Search Up: ' 'copy-mode search-up %%'\n\n          it'd need a separate lookup, because modes are per-pane, perhaps a\n          table() cb to give the table name (\"vi\" or \"emacs\"). anything in the\n          table fires the command, anything not in the table is injected as a\n          key\n\t* searching in copy mode should unwrap lines, so if you seach for \"foobar\"\n          then it should be found even if it is now \"foo\\nbar\" (if the WRAP flag\n          is set on the line)\n\t* {} to go to next/previous blank line in copy mode\n\n- layout stuff\n\t* way to tag a layout as a number/name\n\t* maybe keep last layout + size around and if size reverts just put it\n\t  back\n\t* revamp layouts: they are too complicated, should be more closely\n\t  integrated, should support hints, layout sets should just be a\n\t  special case of custom layouts, and we should support panes that are\n\t  not attached to a cell at all. this could be the time to introduce\n\t  panelink to replace layout_cell\n\t* way to set hints/limits about pane size for resizing\n\t* panning over window (window larger than visible)\n\t* a mode where one application can cross two panes (ie x|y, width =\n\t  COLUMNS/2 but height = ROWS * 2)\n\t* general key to space cells out evenly (horiz or vert) within their\n\t  parent cell (could replace even-vert/even-horiz layouts)\n\t* separate active panes for different clients\n\n- terminfo bits\n\t* use a better termcap internally instead of screen, perhaps xterm\n\t* use screen-256color when started on 256 colour terminal?\n\n- code cleanup\n\t* instead of separate window and session options, just one master\n\t  options list with each option having a type (window or session), then\n\t  options on window, on session, and global. for window options we look\n\t  window->session->global, and for session we look session->global\n\t* the way pane, window, session destroy is handled is too complicated\n\t  and the distinction between session.c, window.c and server-fn.c\n\t  functions is not clear. could we just have kill_pane(),\n\t  kill_window(), unlink_window(), kill_session() that fix up all data\n\t  structures (flagging sessions as dead) and return a value to say\n\t  whether clients need to be checked for dead sessions? sort of like\n\t  session_detach now but more so. or some other scheme to make it\n\t  simpler and clearer? also would be nice to remove/rename server-fn.c\n\t* more readable way to work out the various things commands need to\n\t  know about the client, notably:\n\t\t- is this the config file? (cmdq->c == NULL)\n\t\t- is this a command client? (cmdq->c != NULL &&\n\t\t  cmdq->c->session == NULL)\n\t\t- is this a control client?\n\t\t- can i do stdin or stdout to this client?\n\t  or even guarantee that cmdq->c != NULL and provide a better way to\n\t  tell when in the config file - then we use cmdq->c if we need a\n\t  client w/o a session else cmd_current_client\n\t* optimize pane redraws, 20120318184853.GK10965@yelena.nicm.ath.cx\n\n- miscellaneous\n\t* way to keep a job running just read its last line of output for #()\n\t* link panes into multiple windows\n\t* live update: server started with -U connects to server, requests\n\t  sessions and windows, receives file descriptors\n\t* there are inconsistencies in what we get from old shell and what\n\t  comes from config for new sessions and windows. likewise, panes and\n\t  jobs and run-shell and lock command all start with slightly different\n\t  environments\n\t* multiline status line? separate command prompt and status line?\n\t* customizable command aliases\n\t* automatic pane logging\n\t* BCE? We are halfway there (output side is done for pane backgrounds),\n\t  just need to change how screen/grid handles erase\n"
        },
        {
          "name": "alerts.c",
          "type": "blob",
          "size": 6.8017578125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2015 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <event.h>\n\n#include \"tmux.h\"\n\nint\talerts_fired;\n\nvoid\talerts_timer(int, short, void *);\nint\talerts_enabled(struct window *, int);\nvoid\talerts_callback(int, short, void *);\nvoid\talerts_reset(struct window *);\n\nvoid\talerts_run_hook(struct session *, struct winlink *, int);\nint\talerts_check_all(struct session *, struct winlink *);\nint\talerts_check_bell(struct session *, struct winlink *);\nint\talerts_check_activity(struct session *, struct winlink *);\nint\talerts_check_silence(struct session *, struct winlink *);\nvoid\talerts_ring_bell(struct session *);\n\nvoid\nalerts_timer(__unused int fd, __unused short events, void *arg)\n{\n\tstruct window\t*w = arg;\n\n\tlog_debug(\"@%u alerts timer expired\", w->id);\n\talerts_reset(w);\n\talerts_queue(w, WINDOW_SILENCE);\n}\n\nvoid\nalerts_callback(__unused int fd, __unused short events, __unused void *arg)\n{\n\tstruct window\t*w;\n\tstruct session\t*s;\n\tstruct winlink\t*wl;\n\tint\t\t flags, alerts;\n\n\tRB_FOREACH(w, windows, &windows) {\n\t\tRB_FOREACH(s, sessions, &sessions) {\n\t\t\tRB_FOREACH(wl, winlinks, &s->windows) {\n\t\t\t\tif (wl->window != w)\n\t\t\t\t\tcontinue;\n\t\t\t\tflags = w->flags;\n\n\t\t\t\talerts = alerts_check_all(s, wl);\n\n\t\t\t\tlog_debug(\"%s:%d @%u alerts check, alerts %#x, \"\n\t\t\t\t    \"flags %#x\", s->name, wl->idx, w->id,\n\t\t\t\t    alerts, flags);\n\t\t\t}\n\t\t}\n\t}\n\talerts_fired = 0;\n}\n\nvoid\nalerts_run_hook(struct session *s, struct winlink *wl, int flags)\n{\n\tstruct cmd_find_state\t fs;\n\n\tif (cmd_find_from_winlink(&fs, s, wl) != 0)\n\t\treturn;\n\n\tif (flags & WINDOW_BELL)\n\t\thooks_run(s->hooks, NULL, &fs, \"alert-bell\");\n\tif (flags & WINDOW_SILENCE)\n\t\thooks_run(s->hooks, NULL, &fs, \"alert-silence\");\n\tif (flags & WINDOW_ACTIVITY)\n\t\thooks_run(s->hooks, NULL, &fs, \"alert-activity\");\n}\n\nint\nalerts_check_all(struct session *s, struct winlink *wl)\n{\n\tint\talerts;\n\n\talerts  = alerts_check_bell(s, wl);\n\talerts |= alerts_check_activity(s, wl);\n\talerts |= alerts_check_silence(s, wl);\n\tif (alerts != 0) {\n\t\talerts_run_hook(s, wl, alerts);\n\t\tserver_status_session(s);\n\t}\n\n\treturn (alerts);\n}\n\nvoid\nalerts_check_session(struct session *s)\n{\n\tstruct winlink\t*wl;\n\n\tRB_FOREACH(wl, winlinks, &s->windows)\n\t\talerts_check_all(s, wl);\n}\n\nint\nalerts_enabled(struct window *w, int flags)\n{\n\tif (flags & WINDOW_BELL)\n\t\treturn (1);\n\tif (flags & WINDOW_ACTIVITY) {\n\t\tif (options_get_number(w->options, \"monitor-activity\"))\n\t\t\treturn (1);\n\t}\n\tif (flags & WINDOW_SILENCE) {\n\t\tif (options_get_number(w->options, \"monitor-silence\") != 0)\n\t\t\treturn (1);\n\t}\n\treturn (0);\n}\n\nvoid\nalerts_reset_all(void)\n{\n\tstruct window\t*w;\n\n\tRB_FOREACH(w, windows, &windows)\n\t\talerts_reset(w);\n}\n\nvoid\nalerts_reset(struct window *w)\n{\n\tstruct timeval\ttv;\n\n\tw->flags &= ~WINDOW_SILENCE;\n\tevent_del(&w->alerts_timer);\n\n\ttimerclear(&tv);\n\ttv.tv_sec = options_get_number(w->options, \"monitor-silence\");\n\n\tlog_debug(\"@%u alerts timer reset %u\", w->id, (u_int)tv.tv_sec);\n\tif (tv.tv_sec != 0)\n\t\tevent_add(&w->alerts_timer, &tv);\n}\n\nvoid\nalerts_queue(struct window *w, int flags)\n{\n\tif (w->flags & WINDOW_ACTIVITY)\n\t\talerts_reset(w);\n\n\tif (!event_initialized(&w->alerts_timer))\n\t\tevtimer_set(&w->alerts_timer, alerts_timer, w);\n\n\tif (!alerts_fired) {\n\t\tw->flags |= flags;\n\t\tlog_debug(\"@%u alerts flags added %#x\", w->id, flags);\n\n\t\tif (alerts_enabled(w, flags)) {\n\t\t\tlog_debug(\"alerts check queued (by @%u)\", w->id);\n\t\t\tevent_once(-1, EV_TIMEOUT, alerts_callback, NULL, NULL);\n\t\t\talerts_fired = 1;\n\t\t}\n\t}\n}\n\nint\nalerts_check_bell(struct session *s, struct winlink *wl)\n{\n\tstruct client\t*c;\n\tstruct window\t*w = wl->window;\n\tint\t\t action, visual;\n\n\tif (!(w->flags & WINDOW_BELL))\n\t\treturn (0);\n\tif (s->curw != wl) {\n\t\twl->flags |= WINLINK_BELL;\n\t\tw->flags &= ~WINDOW_BELL;\n\t}\n\tif (s->curw->window == w)\n\t\tw->flags &= ~WINDOW_BELL;\n\n\taction = options_get_number(s->options, \"bell-action\");\n\tif (action == BELL_NONE)\n\t\treturn (0);\n\n\tvisual = options_get_number(s->options, \"visual-bell\");\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (c->session != s || c->flags & CLIENT_CONTROL)\n\t\t\tcontinue;\n\t\tif (!visual) {\n\t\t\tif ((action == BELL_CURRENT &&\n\t\t\t    c->session->curw->window == w) ||\n\t\t\t    (action == BELL_OTHER &&\n\t\t\t    c->session->curw->window != w) ||\n\t\t\t    action == BELL_ANY)\n\t\t\t\ttty_putcode(&c->tty, TTYC_BEL);\n\t\t\tcontinue;\n\t\t}\n\t\tif (action == BELL_CURRENT && c->session->curw->window == w)\n\t\t\tstatus_message_set(c, \"Bell in current window\");\n\t\telse if (action == BELL_ANY || (action == BELL_OTHER &&\n\t\t    c->session->curw->window != w))\n\t\t\tstatus_message_set(c, \"Bell in window %d\", wl->idx);\n\t}\n\n\treturn (WINDOW_BELL);\n}\n\nint\nalerts_check_activity(struct session *s, struct winlink *wl)\n{\n\tstruct client\t*c;\n\tstruct window\t*w = wl->window;\n\n\tif (s->curw->window == w)\n\t\tw->flags &= ~WINDOW_ACTIVITY;\n\n\tif (!(w->flags & WINDOW_ACTIVITY) || wl->flags & WINLINK_ACTIVITY)\n\t\treturn (0);\n\tif (s->curw == wl)\n\t\treturn (0);\n\n\tif (!options_get_number(w->options, \"monitor-activity\"))\n\t\treturn (0);\n\n\tif (options_get_number(s->options, \"bell-on-alert\"))\n\t\talerts_ring_bell(s);\n\twl->flags |= WINLINK_ACTIVITY;\n\n\tif (options_get_number(s->options, \"visual-activity\")) {\n\t\tTAILQ_FOREACH(c, &clients, entry) {\n\t\t\tif (c->session != s)\n\t\t\t\tcontinue;\n\t\t\tstatus_message_set(c, \"Activity in window %d\", wl->idx);\n\t\t}\n\t}\n\n\treturn (WINDOW_ACTIVITY);\n}\n\nint\nalerts_check_silence(struct session *s, struct winlink *wl)\n{\n\tstruct client\t*c;\n\tstruct window\t*w = wl->window;\n\n\tif (s->curw->window == w)\n\t\tw->flags &= ~WINDOW_SILENCE;\n\n\tif (!(w->flags & WINDOW_SILENCE) || wl->flags & WINLINK_SILENCE)\n\t\treturn (0);\n\tif (s->curw == wl)\n\t\treturn (0);\n\n\tif (options_get_number(w->options, \"monitor-silence\") == 0)\n\t\treturn (0);\n\n\tif (options_get_number(s->options, \"bell-on-alert\"))\n\t\talerts_ring_bell(s);\n\twl->flags |= WINLINK_SILENCE;\n\n\tif (options_get_number(s->options, \"visual-silence\")) {\n\t\tTAILQ_FOREACH(c, &clients, entry) {\n\t\t\tif (c->session != s)\n\t\t\t\tcontinue;\n\t\t\tstatus_message_set(c, \"Silence in window %d\", wl->idx);\n\t\t}\n\t}\n\n\treturn (WINDOW_SILENCE);\n}\n\nvoid\nalerts_ring_bell(struct session *s)\n{\n\tstruct client\t*c;\n\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (c->session == s && !(c->flags & CLIENT_CONTROL))\n\t\t\ttty_putcode(&c->tty, TTYC_BEL);\n\t}\n}\n"
        },
        {
          "name": "arguments.c",
          "type": "blob",
          "size": 5.375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2010 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\n/*\n * Manipulate command arguments.\n */\n\nstruct args_entry {\n\tu_char\t\t\t flag;\n\tchar\t\t\t*value;\n\tRB_ENTRY(args_entry)\t entry;\n};\n\nstruct args_entry\t*args_find(struct args *, u_char);\n\nRB_GENERATE(args_tree, args_entry, entry, args_cmp);\n\n/* Arguments tree comparison function. */\nint\nargs_cmp(struct args_entry *a1, struct args_entry *a2)\n{\n\treturn (a1->flag - a2->flag);\n}\n\n/* Create an arguments set with no flags. */\nstruct args *\nargs_create(int argc, ...)\n{\n\tstruct args\t*args;\n\tva_list\t\t ap;\n\tint\t\t i;\n\n\targs = xcalloc(1, sizeof *args);\n\n\targs->argc = argc;\n\tif (argc == 0)\n\t\targs->argv = NULL;\n\telse\n\t\targs->argv = xcalloc(argc, sizeof *args->argv);\n\n\tva_start(ap, argc);\n\tfor (i = 0; i < argc; i++)\n\t\targs->argv[i] = xstrdup(va_arg(ap, char *));\n\tva_end(ap);\n\n\treturn (args);\n}\n\n/* Find a flag in the arguments tree. */\nstruct args_entry *\nargs_find(struct args *args, u_char ch)\n{\n\tstruct args_entry\tentry;\n\n\tentry.flag = ch;\n\treturn (RB_FIND(args_tree, &args->tree, &entry));\n}\n\n/* Parse an argv and argc into a new argument set. */\nstruct args *\nargs_parse(const char *template, int argc, char **argv)\n{\n\tstruct args\t*args;\n\tint\t\t opt;\n\n\targs = xcalloc(1, sizeof *args);\n\n\toptreset = 1;\n\toptind = 1;\n\n\twhile ((opt = getopt(argc, argv, template)) != -1) {\n\t\tif (opt < 0)\n\t\t\tcontinue;\n\t\tif (opt == '?' || strchr(template, opt) == NULL) {\n\t\t\targs_free(args);\n\t\t\treturn (NULL);\n\t\t}\n\t\targs_set(args, opt, optarg);\n\t}\n\targc -= optind;\n\targv += optind;\n\n\targs->argc = argc;\n\targs->argv = cmd_copy_argv(argc, argv);\n\n\treturn (args);\n}\n\n/* Free an arguments set. */\nvoid\nargs_free(struct args *args)\n{\n\tstruct args_entry\t*entry;\n\tstruct args_entry\t*entry1;\n\n\tcmd_free_argv(args->argc, args->argv);\n\n\tRB_FOREACH_SAFE(entry, args_tree, &args->tree, entry1) {\n\t\tRB_REMOVE(args_tree, &args->tree, entry);\n\t\tfree(entry->value);\n\t\tfree(entry);\n\t}\n\n\tfree(args);\n}\n\n/* Add to string. */\nstatic void printflike(3, 4)\nargs_print_add(char **buf, size_t *len, const char *fmt, ...)\n{\n\tva_list  ap;\n\tchar\t*s;\n\tsize_t\t slen;\n\n\tva_start(ap, fmt);\n\tslen = xvasprintf(&s, fmt, ap);\n\tva_end(ap);\n\n\t*len += slen;\n\t*buf = xrealloc(*buf, *len);\n\n\tstrlcat(*buf, s, *len);\n\tfree(s);\n}\n\n/* Print a set of arguments. */\nchar *\nargs_print(struct args *args)\n{\n\tsize_t\t\t \t len;\n\tchar\t\t\t*buf;\n\tint\t\t\t i;\n\tstruct args_entry\t*entry;\n\n\tlen = 1;\n\tbuf = xcalloc(1, len);\n\n\t/* Process the flags first. */\n\tRB_FOREACH(entry, args_tree, &args->tree) {\n\t\tif (entry->value != NULL)\n\t\t\tcontinue;\n\n\t\tif (*buf == '\\0')\n\t\t\targs_print_add(&buf, &len, \"-\");\n\t\targs_print_add(&buf, &len, \"%c\", entry->flag);\n\t}\n\n\t/* Then the flags with arguments. */\n\tRB_FOREACH(entry, args_tree, &args->tree) {\n\t\tif (entry->value == NULL)\n\t\t\tcontinue;\n\n\t\tif (*buf != '\\0')\n\t\t\targs_print_add(&buf, &len, \" -%c \", entry->flag);\n\t\telse\n\t\t\targs_print_add(&buf, &len, \"-%c \", entry->flag);\n\t\tif (strchr(entry->value, ' ') != NULL)\n\t\t\targs_print_add(&buf, &len, \"\\\"%s\\\"\", entry->value);\n\t\telse\n\t\t\targs_print_add(&buf, &len, \"%s\", entry->value);\n\t}\n\n\t/* And finally the argument vector. */\n\tfor (i = 0; i < args->argc; i++) {\n\t\tif (*buf != '\\0')\n\t\t\targs_print_add(&buf, &len, \" \");\n\t\tif (strchr(args->argv[i], ' ') != NULL)\n\t\t\targs_print_add(&buf, &len, \"\\\"%s\\\"\", args->argv[i]);\n\t\telse\n\t\t\targs_print_add(&buf, &len, \"%s\", args->argv[i]);\n\t}\n\n\treturn (buf);\n}\n\n/* Return if an argument is present. */\nint\nargs_has(struct args *args, u_char ch)\n{\n\treturn (args_find(args, ch) == NULL ? 0 : 1);\n}\n\n/* Set argument value in the arguments tree. */\nvoid\nargs_set(struct args *args, u_char ch, const char *value)\n{\n\tstruct args_entry\t*entry;\n\n\t/* Replace existing argument. */\n\tif ((entry = args_find(args, ch)) != NULL) {\n\t\tfree(entry->value);\n\t\tentry->value = NULL;\n\t} else {\n\t\tentry = xcalloc(1, sizeof *entry);\n\t\tentry->flag = ch;\n\t\tRB_INSERT(args_tree, &args->tree, entry);\n\t}\n\n\tif (value != NULL)\n\t\tentry->value = xstrdup(value);\n}\n\n/* Get argument value. Will be NULL if it isn't present. */\nconst char *\nargs_get(struct args *args, u_char ch)\n{\n\tstruct args_entry\t*entry;\n\n\tif ((entry = args_find(args, ch)) == NULL)\n\t\treturn (NULL);\n\treturn (entry->value);\n}\n\n/* Convert an argument value to a number. */\nlong long\nargs_strtonum(struct args *args, u_char ch, long long minval, long long maxval,\n    char **cause)\n{\n\tconst char\t\t*errstr;\n\tlong long \t \t ll;\n\tstruct args_entry\t*entry;\n\n\tif ((entry = args_find(args, ch)) == NULL) {\n\t\t*cause = xstrdup(\"missing\");\n\t\treturn (0);\n\t}\n\n\tll = strtonum(entry->value, minval, maxval, &errstr);\n\tif (errstr != NULL) {\n\t\t*cause = xstrdup(errstr);\n\t\treturn (0);\n\t}\n\n\t*cause = NULL;\n\treturn (ll);\n}\n"
        },
        {
          "name": "array.h",
          "type": "blob",
          "size": 3.3984375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2006 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#ifndef ARRAY_H\n#define ARRAY_H\n\n#define ARRAY_INITIALIZER { NULL, 0, 0 }\n\n#define ARRAY_DECL(n, c)\t\t\t\t\t\t\\\n\tstruct n {\t\t\t\t\t\t\t\\\n\t\tc\t*list;\t\t\t\t\t\t\\\n\t\tu_int\t num;\t\t\t\t\t\t\\\n\t\tsize_t\t space;\t\t\t\t\t\t\\\n\t}\n\n#define ARRAY_ITEM(a, i) ((a)->list[i])\n#define ARRAY_ITEMSIZE(a) (sizeof *(a)->list)\n#define ARRAY_INITIALSPACE(a) (10 * ARRAY_ITEMSIZE(a))\n\n#define ARRAY_ENSURE(a, n) do {\t\t\t\t\t\t\\\n\tif (UINT_MAX - (n) < (a)->num)\t\t\t\t\t\\\n\t\tfatalx(\"number too big\");\t\t\t\t\\\n\tif (SIZE_MAX / ((a)->num + (n)) < ARRAY_ITEMSIZE(a))\t\t\\\n\t\tfatalx(\"size too big\");\t\t\t\t\t\\\n\tif ((a)->space == 0) {\t\t\t\t\t\t\\\n\t       \t(a)->space = ARRAY_INITIALSPACE(a);\t\t\t\\\n\t\t(a)->list = xrealloc((a)->list, (a)->space);\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\twhile ((a)->space <= ((a)->num + (n)) * ARRAY_ITEMSIZE(a)) {\t\\\n\t\t(a)->list = xreallocarray((a)->list, 2, (a)->space);\t\\\n\t\t(a)->space *= 2;\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\n#define ARRAY_EMPTY(a) (((void *) (a)) == NULL || (a)->num == 0)\n#define ARRAY_LENGTH(a) ((a)->num)\n#define ARRAY_DATA(a) ((a)->list)\n\n#define ARRAY_FIRST(a) ARRAY_ITEM(a, 0)\n#define ARRAY_LAST(a) ARRAY_ITEM(a, (a)->num - 1)\n\n#define ARRAY_INIT(a) do {\t\t\t\t\t\t\\\n\t(a)->num = 0;\t\t\t\t\t\t\t\\\n\t(a)->list = NULL;\t\t \t\t\t\t\\\n\t(a)->space = 0;\t\t\t\t\t\t\t\\\n} while (0)\n#define ARRAY_CLEAR(a) do {\t\t\t\t\t\t\\\n\t(a)->num = 0;\t\t\t\t\t\t\t\\\n} while (0)\n\n#define ARRAY_SET(a, i, s) do {\t\t\t\t\t\t\\\n\t(a)->list[i] = s;\t\t\t\t\t\t\\\n} while (0)\n\n#define ARRAY_ADD(a, s) do {\t\t\t\t\t\t\\\n\tARRAY_ENSURE(a, 1);\t\t\t\t\t\t\\\n\t(a)->list[(a)->num] = s;\t\t\t\t\t\\\n\t(a)->num++;\t\t\t\t\t\t\t\\\n} while (0)\n#define ARRAY_INSERT(a, i, s) do {\t\t\t\t\t\\\n\tARRAY_ENSURE(a, 1);\t\t\t\t\t\t\\\n\tif ((i) < (a)->num) {\t\t\t\t\t\t\\\n\t\tmemmove((a)->list + (i) + 1, (a)->list + (i), \t\t\\\n\t\t    ARRAY_ITEMSIZE(a) * ((a)->num - (i)));\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t(a)->list[i] = s;\t\t\t\t\t\t\\\n\t(a)->num++;\t\t\t\t\t\t\t\\\n} while (0)\n#define ARRAY_REMOVE(a, i) do {\t\t\t\t\t\t\\\n\tif ((i) < (a)->num - 1) {\t\t\t\t\t\\\n\t\tmemmove((a)->list + (i), (a)->list + (i) + 1, \t\t\\\n\t\t    ARRAY_ITEMSIZE(a) * ((a)->num - (i) - 1));\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t(a)->num--;\t\t\t\t\t\t\t\\\n\tif ((a)->num == 0)\t\t\t\t\t\t\\\n\t\tARRAY_FREE(a);\t\t\t\t\t\t\\\n} while (0)\n\n#define ARRAY_EXPAND(a, n) do {\t\t\t\t\t\t\\\n\tARRAY_ENSURE(a, n);\t\t\t\t\t\t\\\n\t(a)->num += n;\t\t\t\t\t\t\t\\\n} while (0)\n#define ARRAY_TRUNC(a, n) do {\t\t\t\t\t\t\\\n\tif ((a)->num > n)\t\t\t\t\t\t\\\n\t\t(a)->num -= n;\t\t\t\t       \t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\tARRAY_FREE(a);\t\t\t\t\t\t\\\n} while (0)\n\n#define ARRAY_CONCAT(a, b) do {\t\t\t\t\t\t\\\n\tARRAY_ENSURE(a, (b)->num);\t\t\t\t\t\\\n\tmemcpy((a)->list + (a)->num, (b)->list, (b)->num * ARRAY_ITEMSIZE(a)); \\\n\t(a)->num += (b)->num;\t\t\t\t\t\t\\\n} while (0)\n\n#define ARRAY_FREE(a) do {\t\t\t\t\t\t\\\n\tfree((a)->list);\t\t\t\t\t\t\\\n\tARRAY_INIT(a);\t\t\t\t\t\t\t\\\n} while (0)\n#define ARRAY_FREEALL(a) do {\t\t\t\t\t\t\\\n\tARRAY_FREE(a);\t\t\t\t\t\t\t\\\n\tfree(a);\t\t\t\t\t\t\t\\\n} while (0)\n\n#endif\n"
        },
        {
          "name": "attributes.c",
          "type": "blob",
          "size": 2.5498046875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Joshua Elsasser <josh@elsasser.org>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <string.h>\n\n#include \"tmux.h\"\n\nconst char *\nattributes_tostring(u_char attr)\n{\n\tstatic char\tbuf[128];\n\tsize_t\t\tlen;\n\n\tif (attr == 0)\n\t\treturn (\"none\");\n\n\tlen = xsnprintf(buf, sizeof buf, \"%s%s%s%s%s%s%s\",\n\t\tattr & GRID_ATTR_BRIGHT ? \"bright,\" : \"\",\n\t\tattr & GRID_ATTR_DIM ? \"dim,\" : \"\",\n\t\tattr & GRID_ATTR_UNDERSCORE ? \"underscore,\" : \"\",\n\t\tattr & GRID_ATTR_BLINK ? \"blink,\" : \"\",\n\t\tattr & GRID_ATTR_REVERSE ? \"reverse,\" : \"\",\n\t\tattr & GRID_ATTR_HIDDEN ? \"hidden,\" : \"\",\n\t\tattr & GRID_ATTR_ITALICS ? \"italics,\" : \"\");\n\tif (len > 0)\n\t\tbuf[len - 1] = '\\0';\n\n\treturn (buf);\n}\n\nint\nattributes_fromstring(const char *str)\n{\n\tconst char\tdelimiters[] = \" ,|\";\n\tu_char\t\tattr;\n\tsize_t\t\tend;\n\n\tif (*str == '\\0' || strcspn(str, delimiters) == 0)\n\t\treturn (-1);\n\tif (strchr(delimiters, str[strlen(str) - 1]) != NULL)\n\t\treturn (-1);\n\n\tif (strcasecmp(str, \"default\") == 0 || strcasecmp(str, \"none\") == 0)\n\t\treturn (0);\n\n\tattr = 0;\n\tdo {\n\t\tend = strcspn(str, delimiters);\n\t\tif ((end == 6 && strncasecmp(str, \"bright\", end) == 0) ||\n\t\t    (end == 4 && strncasecmp(str, \"bold\", end) == 0))\n\t\t\tattr |= GRID_ATTR_BRIGHT;\n\t\telse if (end == 3 && strncasecmp(str, \"dim\", end) == 0)\n\t\t\tattr |= GRID_ATTR_DIM;\n\t\telse if (end == 10 && strncasecmp(str, \"underscore\", end) == 0)\n\t\t\tattr |= GRID_ATTR_UNDERSCORE;\n\t\telse if (end == 5 && strncasecmp(str, \"blink\", end) == 0)\n\t\t\tattr |= GRID_ATTR_BLINK;\n\t\telse if (end == 7 && strncasecmp(str, \"reverse\", end) == 0)\n\t\t\tattr |= GRID_ATTR_REVERSE;\n\t\telse if (end == 6 && strncasecmp(str, \"hidden\", end) == 0)\n\t\t\tattr |= GRID_ATTR_HIDDEN;\n\t\telse if (end == 7 && strncasecmp(str, \"italics\", end) == 0)\n\t\t\tattr |= GRID_ATTR_ITALICS;\n\t\telse\n\t\t\treturn (-1);\n\t\tstr += end + strspn(str + end, delimiters);\n\t} while (*str != '\\0');\n\n\treturn (attr);\n}\n"
        },
        {
          "name": "autogen.sh",
          "type": "blob",
          "size": 0.3681640625,
          "content": "#!/bin/sh\n\nif [ \"x$(uname)\" = \"xOpenBSD\" ]; then\n\t[ -z \"$AUTOMAKE_VERSION\" ] && export AUTOMAKE_VERSION=1.10\n\t[ -z \"$AUTOCONF_VERSION\" ] && export AUTOCONF_VERSION=2.65\nfi\n\ndie()\n{\n    echo \"$@\" >&2\n    exit 1\n}\n\nmkdir -p etc\naclocal || die \"aclocal failed\"\nautomake --add-missing --force-missing --copy --foreign || die \"automake failed\"\nautoreconf || die \"autoreconf failed\"\n"
        },
        {
          "name": "build_static_release.sh",
          "type": "blob",
          "size": 0.939453125,
          "content": "#!/bin/bash\nset -eux\n\n# This is invoked by .travis.yml\n\nVERSION=$1\nPLATFORM=$2\n\nSRC_VERSION=`cat configure.ac | grep AC_INIT | sed -E 's/^AC_INIT\\(tmate, (.+)\\)$/\\1/'`\n\nif [ $SRC_VERSION != $VERSION ]; then\n  echo \"Version mismatch: $SRC_VERSION != $VERSION\"\n  exit 1\nfi\n\nRELEASE_NAME=tmate-$VERSION-static-linux-$PLATFORM\necho \"Building $RELEASE_NAME\"\n\ndocker build . --tag local-$PLATFORM/tmate-build --build-arg PLATFORM=$PLATFORM\n\nmkdir -p releases\ncd releases\n\nrm -rf $RELEASE_NAME\nmkdir -p $RELEASE_NAME\ndocker run --rm local-$PLATFORM/tmate-build cat /build/tmate > $RELEASE_NAME/tmate\nchmod +x $RELEASE_NAME/tmate\ntar -cf - $RELEASE_NAME | xz > tmate-$VERSION-static-linux-$PLATFORM.tar.xz\n\nrm -rf $RELEASE_NAME-symbols\nmkdir -p $RELEASE_NAME-symbols\ndocker run --rm local-$PLATFORM/tmate-build cat /build/tmate.symbols > $RELEASE_NAME-symbols/tmate.symbols\ntar -cf - $RELEASE_NAME-symbols | xz > dbg-symbols-tmate-$VERSION-static-linux-$PLATFORM.tar.xz\n"
        },
        {
          "name": "cfg.c",
          "type": "blob",
          "size": 5.0908203125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2008 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <ctype.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n#include \"tmate.h\"\n\nchar\t\t *cfg_file;\n#ifdef TMATE\nchar\t\t *tmate_cfg_file;\n#endif\nstruct cmd_q\t *cfg_cmd_q;\nint\t\t  cfg_finished;\nint\t\t  cfg_references;\nchar\t\t**cfg_causes;\nu_int\t\t  cfg_ncauses;\nstruct client\t *cfg_client;\n\nvoid\tcfg_default_done(struct cmd_q *);\n\nvoid\nset_cfg_file(const char *path)\n{\n\tfree(cfg_file);\n\tcfg_file = xstrdup(path);\n}\n\nvoid\nstart_cfg(void)\n{\n\tchar\t\t*cause = NULL;\n\tconst char\t*home;\n\n\tcfg_cmd_q = cmdq_new(NULL);\n\tcfg_cmd_q->emptyfn = cfg_default_done;\n\n\tcfg_finished = 0;\n\tcfg_references = 1;\n\n\tcfg_client = TAILQ_FIRST(&clients);\n\tif (cfg_client != NULL)\n\t\tcfg_client->references++;\n\n\tif (access(TMUX_CONF, R_OK) == 0) {\n\t\tif (load_cfg(TMUX_CONF, cfg_cmd_q, &cause) == -1)\n\t\t\tcfg_add_cause(\"%s: %s\", TMUX_CONF, cause);\n\t} else if (errno != ENOENT)\n\t\tcfg_add_cause(\"%s: %s\", TMUX_CONF, strerror(errno));\n\n\tif (cfg_file == NULL && (home = find_home()) != NULL) {\n\t\txasprintf(&cfg_file, \"%s/.tmate.conf\", home);\n\t\tif (access(cfg_file, R_OK) != 0 && errno == ENOENT) {\n\t\t\tfree(cfg_file);\n\t\t\tcfg_file = NULL;\n\t\t}\n\t}\n\tif (cfg_file != NULL && load_cfg(cfg_file, cfg_cmd_q, &cause) == -1)\n\t\tcfg_add_cause(\"%s: %s\", cfg_file, cause);\n\tfree(cause);\n\n\tcmdq_continue(cfg_cmd_q);\n}\n\nint\nload_cfg(const char *path, struct cmd_q *cmdq, char **cause)\n{\n\tFILE\t\t*f;\n\tchar\t\t delim[3] = { '\\\\', '\\\\', '\\0' };\n\tu_int\t\t found;\n\tsize_t\t\t line = 0;\n\tchar\t\t*buf, *cause1, *p;\n\tstruct cmd_list\t*cmdlist;\n\n\tlog_debug(\"loading %s\", path);\n\tif ((f = fopen(path, \"rb\")) == NULL) {\n\t\txasprintf(cause, \"%s: %s\", path, strerror(errno));\n\t\treturn (-1);\n\t}\n\n\tfound = 0;\n\twhile ((buf = fparseln(f, NULL, &line, delim, 0)) != NULL) {\n\t\tlog_debug(\"%s: %s\", path, buf);\n\n\t\t/* Skip empty lines. */\n\t\tp = buf;\n\t\twhile (isspace((u_char) *p))\n\t\t\tp++;\n\t\tif (*p == '\\0') {\n\t\t\tfree(buf);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Parse and run the command. */\n\t\tif (cmd_string_parse(p, &cmdlist, path, line, &cause1) != 0) {\n\t\t\tfree(buf);\n\t\t\tif (cause1 == NULL)\n\t\t\t\tcontinue;\n\t\t\tcfg_add_cause(\"%s:%zu: %s\", path, line, cause1);\n\t\t\tfree(cause1);\n\t\t\tcontinue;\n\t\t}\n\t\tfree(buf);\n\n\t\tif (cmdlist == NULL)\n\t\t\tcontinue;\n\t\tcmdq_append(cmdq, cmdlist, NULL);\n\t\tcmd_list_free(cmdlist);\n\t\tfound++;\n\t}\n\tfclose(f);\n\n\treturn (found);\n}\n\nstatic void print_cfg_errors(void)\n{\n\tu_int i;\n\n\tfor (i = 0; i < cfg_ncauses; i++) {\n\t\ttmate_info(\"%s\", cfg_causes[i]);\n\t\tfree(cfg_causes[i]);\n\t}\n\n\tfree(cfg_causes);\n\tcfg_causes = NULL;\n\tcfg_ncauses = 0;\n}\n\nvoid\ncfg_default_done(__unused struct cmd_q *cmdq)\n{\n\tif (--cfg_references != 0)\n\t\treturn;\n\tcfg_finished = 1;\n\n#ifdef TMATE\n\t/* We do it this late, this way, CLI options take precedence over cfg file */\n\ttmate_load_cli_options();\n\n\ttmate_session_start();\n\tif (tmate_foreground && cfg_ncauses) {\n\t\tprint_cfg_errors();\n\t\texit(1);\n\t}\n#endif\n\n\tif (!RB_EMPTY(&sessions))\n\t\tcfg_show_causes(RB_MIN(sessions, &sessions));\n\n\tcmdq_free(cfg_cmd_q);\n\tcfg_cmd_q = NULL;\n\n\tif (cfg_client != NULL) {\n\t\t/*\n\t\t * The client command queue starts with client_exit set to 1 so\n\t\t * only continue if not empty (that is, we have been delayed\n\t\t * during configuration parsing for long enough that the\n\t\t * MSG_COMMAND has arrived), else the client will exit before\n\t\t * the MSG_COMMAND which might tell it not to.\n\t\t */\n\t\tif (!TAILQ_EMPTY(&cfg_client->cmdq->queue))\n\t\t\tcmdq_continue(cfg_client->cmdq);\n\t\tserver_client_unref(cfg_client);\n\t\tcfg_client = NULL;\n\t}\n}\n\nvoid\ncfg_add_cause(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tchar\t*msg;\n\n\tva_start(ap, fmt);\n\txvasprintf(&msg, fmt, ap);\n\tva_end(ap);\n\n\tcfg_ncauses++;\n\tcfg_causes = xreallocarray(cfg_causes, cfg_ncauses, sizeof *cfg_causes);\n\tcfg_causes[cfg_ncauses - 1] = msg;\n}\n\nvoid\ncfg_print_causes(struct cmd_q *cmdq)\n{\n\tu_int\t i;\n\n\tfor (i = 0; i < cfg_ncauses; i++) {\n\t\tcmdq_print(cmdq, \"%s\", cfg_causes[i]);\n\t\tfree(cfg_causes[i]);\n\t}\n\n\tfree(cfg_causes);\n\tcfg_causes = NULL;\n\tcfg_ncauses = 0;\n}\n\nvoid\ncfg_show_causes(struct session *s)\n{\n\tstruct window_pane\t*wp;\n\tu_int\t\t\t i;\n\n\tif (s == NULL || cfg_ncauses == 0)\n\t\treturn;\n\twp = s->curw->window->active;\n\n\twindow_pane_set_mode(wp, &window_copy_mode);\n\twindow_copy_init_for_output(wp);\n\tfor (i = 0; i < cfg_ncauses; i++) {\n\t\twindow_copy_add(wp, \"%s\", cfg_causes[i]);\n\t\tfree(cfg_causes[i]);\n\t}\n\n\tfree(cfg_causes);\n\tcfg_causes = NULL;\n\tcfg_ncauses = 0;\n}\n"
        },
        {
          "name": "client.c",
          "type": "blob",
          "size": 19.3955078125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/file.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n\n#include <errno.h>\n#include <event.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n#include \"tmate.h\"\n\nstruct tmuxproc\t*client_proc;\nstruct tmuxpeer\t*client_peer;\nint\t\t client_flags;\nstruct event\t client_stdin;\nenum {\n\tCLIENT_EXIT_NONE,\n\tCLIENT_EXIT_DETACHED,\n\tCLIENT_EXIT_DETACHED_HUP,\n\tCLIENT_EXIT_LOST_TTY,\n\tCLIENT_EXIT_TERMINATED,\n\tCLIENT_EXIT_LOST_SERVER,\n\tCLIENT_EXIT_EXITED,\n\tCLIENT_EXIT_SERVER_EXITED,\n} client_exitreason = CLIENT_EXIT_NONE;\nint\t\t client_exitval;\nenum msgtype\t client_exittype;\nconst char\t*client_exitsession;\nint\t\t client_attached;\n\n__dead void\tclient_exec(const char *,const char *);\nint\t\tclient_get_lock(char *);\nint\t\tclient_connect(struct event_base *, const char *, int);\nvoid\t\tclient_send_identify(const char *, const char *);\nvoid\t\tclient_stdin_callback(int, short, void *);\nvoid\t\tclient_write(int, const char *, size_t);\nvoid\t\tclient_signal(int);\nvoid\t\tclient_dispatch(struct imsg *, void *);\nvoid\t\tclient_dispatch_attached(struct imsg *);\nvoid\t\tclient_dispatch_wait(struct imsg *, const char *);\nconst char     *client_exit_message(void);\n\n/*\n * Get server create lock. If already held then server start is happening in\n * another client, so block until the lock is released and return -2 to\n * retry. Return -1 on failure to continue and start the server anyway.\n */\nint\nclient_get_lock(char *lockfile)\n{\n\tint lockfd;\n\n\tlog_debug(\"lock file is %s\", lockfile);\n\n\tif ((lockfd = open(lockfile, O_WRONLY|O_CREAT, 0600)) == -1) {\n\t\tlog_debug(\"open failed: %s\", strerror(errno));\n\t\treturn (-1);\n\t}\n\n\tif (flock(lockfd, LOCK_EX|LOCK_NB) == -1) {\n\t\tlog_debug(\"flock failed: %s\", strerror(errno));\n\t\tif (errno != EAGAIN)\n\t\t\treturn (lockfd);\n\t\twhile (flock(lockfd, LOCK_EX) == -1 && errno == EINTR)\n\t\t\t/* nothing */;\n\t\tclose(lockfd);\n\t\treturn (-2);\n\t}\n\tlog_debug(\"flock succeeded\");\n\n\treturn (lockfd);\n}\n\n/* Connect client to server. */\nint\nclient_connect(struct event_base *base, const char *path, int start_server)\n{\n\tstruct sockaddr_un\tsa;\n\tsize_t\t\t\tsize;\n\tint\t\t\tfd, lockfd = -1, locked = 0;\n\tchar\t\t       *lockfile = NULL;\n\n\tmemset(&sa, 0, sizeof sa);\n\tsa.sun_family = AF_UNIX;\n\tsize = strlcpy(sa.sun_path, path, sizeof sa.sun_path);\n\tif (size >= sizeof sa.sun_path) {\n\t\terrno = ENAMETOOLONG;\n\t\treturn (-1);\n\t}\n\tlog_debug(\"socket is %s\", path);\n\nretry:\n\tif ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)\n\t\treturn (-1);\n\n\tlog_debug(\"trying connect\");\n\tif (connect(fd, (struct sockaddr *)&sa, sizeof sa) == -1) {\n\t\tlog_debug(\"connect failed: %s\", strerror(errno));\n\t\tif (errno != ECONNREFUSED && errno != ENOENT)\n\t\t\tgoto failed;\n\t\tif (!start_server)\n\t\t\tgoto failed;\n\t\tclose(fd);\n\n\t\tif (!locked) {\n\t\t\txasprintf(&lockfile, \"%s.lock\", path);\n\t\t\tif ((lockfd = client_get_lock(lockfile)) < 0) {\n\t\t\t\tlog_debug(\"didn't get lock (%d)\", lockfd);\n\n\t\t\t\tfree(lockfile);\n\t\t\t\tlockfile = NULL;\n\n\t\t\t\tif (lockfd == -2)\n\t\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\tlog_debug(\"got lock (%d)\", lockfd);\n\n\t\t\t/*\n\t\t\t * Always retry at least once, even if we got the lock,\n\t\t\t * because another client could have taken the lock,\n\t\t\t * started the server and released the lock between our\n\t\t\t * connect() and flock().\n\t\t\t */\n\t\t\tlocked = 1;\n\t\t\tgoto retry;\n\t\t}\n\n\t\tif (lockfd >= 0 && unlink(path) != 0 && errno != ENOENT) {\n\t\t\tfree(lockfile);\n\t\t\tclose(lockfd);\n\t\t\treturn (-1);\n\t\t}\n\t\tfd = server_start(base, lockfd, lockfile);\n\t}\n\n\tif (locked && lockfd >= 0) {\n\t\tfree(lockfile);\n\t\tclose(lockfd);\n\t}\n\tsetblocking(fd, 0);\n\treturn (fd);\n\nfailed:\n\tif (locked) {\n\t\tfree(lockfile);\n\t\tclose(lockfd);\n\t}\n\tclose(fd);\n\treturn (-1);\n}\n\n/* Get exit string from reason number. */\nconst char *\nclient_exit_message(void)\n{\n\tstatic char msg[256];\n\n\tswitch (client_exitreason) {\n\tcase CLIENT_EXIT_NONE:\n\t\tbreak;\n\tcase CLIENT_EXIT_DETACHED:\n\t\tif (client_exitsession != NULL) {\n\t\t\txsnprintf(msg, sizeof msg, \"detached \"\n\t\t\t    \"(from session %s)\", client_exitsession);\n\t\t\treturn (msg);\n\t\t}\n\t\treturn (\"detached\");\n\tcase CLIENT_EXIT_DETACHED_HUP:\n\t\tif (client_exitsession != NULL) {\n\t\t\txsnprintf(msg, sizeof msg, \"detached and SIGHUP \"\n\t\t\t    \"(from session %s)\", client_exitsession);\n\t\t\treturn (msg);\n\t\t}\n\t\treturn (\"detached and SIGHUP\");\n\tcase CLIENT_EXIT_LOST_TTY:\n\t\treturn (\"lost tty\");\n\tcase CLIENT_EXIT_TERMINATED:\n\t\treturn (\"terminated\");\n\tcase CLIENT_EXIT_LOST_SERVER:\n\t\treturn (\"lost server\");\n\tcase CLIENT_EXIT_EXITED:\n\t\treturn (\"exited\");\n\tcase CLIENT_EXIT_SERVER_EXITED:\n\t\treturn (\"server exited\");\n\t}\n\treturn (\"unknown reason\");\n}\n\n#ifdef TMATE\nextern const struct cmd_entry cmd_attach_session_entry;\nextern const struct cmd_entry cmd_new_session_entry;\n\n/* For foreground mode */\nstatic int __argc;\nstatic const char **__argv;\n#endif\n\nint run_headless_command(int argc, const char **argv, int flags, void (*err_callback)(const char *))\n{\n\tstruct cmd_q *cmd_q;\n\tstruct cmd_list *cmdlist;\n\tchar *cause;\n\tcmd_q = cmdq_new(NULL); /* No client */\n\n\tif ((cmdlist = cmd_list_parse(argc, (char **)argv, NULL, 0, &cause)) == NULL) {\n\t\tif (err_callback)\n\t\t\terr_callback(cause);\n\t\treturn -1;\n\t}\n\n\tcmdq_run(cmd_q, cmdlist, NULL);\n\tcmd_list_free(cmdlist);\n\tcmdq_free(cmd_q);\n\n\tif (flags & DEFER_ERRORS_CFG)\n\t\treturn 0;\n\n\t/* error messages land in cfg_causes */\n\tint ret = cfg_ncauses ? -1 : 0;\n\tfor (u_int i = 0; i < cfg_ncauses; i++) {\n\t\tif (err_callback)\n\t\t\terr_callback(cfg_causes[i]);\n\t\tfree(cfg_causes[i]);\n\t}\n\n\tfree(cfg_causes);\n\tcfg_causes = NULL;\n\tcfg_ncauses = 0;\n\n\treturn ret;\n}\n\nstatic void initial_client_cmd_err_callback(const char *cause)\n{\n\ttmate_info(\"%s\", cause);\n}\n\nvoid run_initial_client_cmd(void)\n{\n\tint argc = __argc;\n\tconst char **argv = __argv;\n\n\tconst char *default_argv[] = {\"new-session\"};\n\tif (argc == 0) {\n\t\targc = 1;\n\t\targv = default_argv;\n\t}\n\n\tif (run_headless_command(argc, argv, 0, initial_client_cmd_err_callback) < 0)\n\t\texit(1);\n}\n\n/* Client main loop. */\nint\nclient_main(struct event_base *base, int argc, char **argv, int flags,\n    const char *shellcmd)\n{\n\tstruct cmd\t\t*cmd;\n\tstruct cmd_list\t\t*cmdlist;\n\tstruct msg_command_data\t*data;\n\tint\t\t\t cmdflags, fd, i;\n\tconst char\t\t*ttynam, *cwd;\n\tpid_t\t\t\t ppid;\n\tenum msgtype\t\t msg;\n\tchar\t\t\t*cause, path[PATH_MAX];\n\tstruct termios\t\t tio, saved_tio;\n\tsize_t\t\t\t size;\n#ifdef TMATE\n\tint cant_nest = 0;\n\t__argc = argc;\n\t__argv = (const char **)argv;\n#endif\n\n\t/* Ignore SIGCHLD now or daemon() in the server will leave a zombie. */\n\tsignal(SIGCHLD, SIG_IGN);\n\n\t/* Save the flags. */\n\tclient_flags = flags;\n\n\t/* Set up the initial command. */\n\tcmdflags = 0;\n\tif (shellcmd != NULL) {\n\t\tmsg = MSG_SHELL;\n\t\tcmdflags = CMD_STARTSERVER;\n\t} else if (argc == 0) {\n\t\tmsg = MSG_COMMAND;\n\t\tcmdflags = CMD_STARTSERVER;\n#ifdef TMATE\n\tcant_nest = 1;\n#endif\n\t} else {\n\t\tmsg = MSG_COMMAND;\n\n\t\t/*\n\t\t * It sucks parsing the command string twice (in client and\n\t\t * later in server) but it is necessary to get the start server\n\t\t * flag.\n\t\t */\n\t\tcmdlist = cmd_list_parse(argc, argv, NULL, 0, &cause);\n\t\tif (cmdlist == NULL) {\n\t\t\tfprintf(stderr, \"%s\\n\", cause);\n\t\t\treturn (1);\n\t\t}\n\t\tcmdflags &= ~CMD_STARTSERVER;\n\t\tTAILQ_FOREACH(cmd, &cmdlist->list, qentry) {\n\t\t\tif (cmd->entry->flags & CMD_STARTSERVER)\n\t\t\t\tcmdflags |= CMD_STARTSERVER;\n\n#ifdef TMATE\n\t\t\tif (cmd->entry == &cmd_attach_session_entry ||\n\t\t\t    cmd->entry == &cmd_new_session_entry)\n\t\t\t\tcant_nest = 1;\n#endif\n\t\t}\n\t\tcmd_list_free(cmdlist);\n\t}\n\n#ifdef TMATE\n\tif (cant_nest && getenv(\"TMUX\")) {\n\t\tfprintf(stderr, \"sessions should be nested with care, \"\n\t\t\t\"unset $TMUX to force\\n\");\n\t\treturn (1);\n\t}\n#endif\n\n\t/* Create client process structure (starts logging). */\n\tclient_proc = proc_start(\"client\", base, 0, client_signal);\n\n\t/* Initialize the client socket and start the server. */\n\tfd = client_connect(base, socket_path, cmdflags & CMD_STARTSERVER);\n\tif (fd == -1) {\n\t\tif (errno == ECONNREFUSED) {\n\t\t\tfprintf(stderr, \"no server running on %s\\n\",\n\t\t\t    socket_path);\n\t\t} else {\n#ifdef TMATE\n\t\t\tif (errno == ENOENT)\n\t\t\t\tfprintf(stderr, \"You must specify a socket name with -S. For example: \\n\"\n\t\t\t\t\t        \"  tmate -S /tmp/tmate.sock new-session -d\\n\"\n\t\t\t\t\t        \"  tmate -S /tmp/tmate.sock wait tmate-ready\\n\");\n\t\t\telse\n#endif\n\t\t\tfprintf(stderr, \"error connecting to %s (%s)\\n\",\n\t\t\t    socket_path, strerror(errno));\n\t\t}\n\t\treturn (1);\n\t}\n\tclient_peer = proc_add_peer(client_proc, fd, client_dispatch,\n\t    (void *)shellcmd);\n\n\t/* Save these before pledge(). */\n\tif ((cwd = getcwd(path, sizeof path)) == NULL) {\n\t\tif ((cwd = find_home()) == NULL)\n\t\t\tcwd = \"/\";\n\t}\n\tif ((ttynam = ttyname(STDIN_FILENO)) == NULL)\n\t\tttynam = \"\";\n\n#ifdef __OpenBSD__\n\t/*\n\t * Drop privileges for client. \"proc exec\" is needed for -c and for\n\t * locking (which uses system(3)).\n\t *\n\t * \"tty\" is needed to restore termios(4) and also for some reason -CC\n\t * does not work properly without it (input is not recognised).\n\t *\n\t * \"sendfd\" is dropped later in client_dispatch_wait().\n\t */\n\tif (pledge(\"stdio unix sendfd proc exec tty\", NULL) != 0)\n\t\tfatal(\"pledge failed\");\n#endif\n\n\t/* Free stuff that is not used in the client. */\n\toptions_free(global_options);\n\toptions_free(global_s_options);\n\toptions_free(global_w_options);\n\tenviron_free(global_environ);\n\n\t/* Create stdin handler. */\n\tsetblocking(STDIN_FILENO, 0);\n\tevent_set(&client_stdin, STDIN_FILENO, EV_READ|EV_PERSIST,\n\t    client_stdin_callback, NULL);\n\tif (client_flags & CLIENT_CONTROLCONTROL) {\n\t\tif (tcgetattr(STDIN_FILENO, &saved_tio) != 0)\n\t\t\tfatal(\"tcgetattr failed\");\n\t\tcfmakeraw(&tio);\n\t\ttio.c_iflag = ICRNL|IXANY;\n\t\ttio.c_oflag = OPOST|ONLCR;\n#ifdef NOKERNINFO\n\t\ttio.c_lflag = NOKERNINFO;\n#endif\n\t\ttio.c_cflag = CREAD|CS8|HUPCL;\n\t\ttio.c_cc[VMIN] = 1;\n\t\ttio.c_cc[VTIME] = 0;\n\t\tcfsetispeed(&tio, cfgetispeed(&saved_tio));\n\t\tcfsetospeed(&tio, cfgetospeed(&saved_tio));\n\t\ttcsetattr(STDIN_FILENO, TCSANOW, &tio);\n\t}\n\n\t/* Send identify messages. */\n\tclient_send_identify(ttynam, cwd);\n\n\t/* Send first command. */\n\tif (msg == MSG_COMMAND) {\n\t\t/* How big is the command? */\n\t\tsize = 0;\n\t\tfor (i = 0; i < argc; i++)\n\t\t\tsize += strlen(argv[i]) + 1;\n\t\tdata = xmalloc((sizeof *data) + size);\n\n\t\t/* Prepare command for server. */\n\t\tdata->argc = argc;\n\t\tif (cmd_pack_argv(argc, argv, (char *)(data + 1), size) != 0) {\n\t\t\tfprintf(stderr, \"command too long\\n\");\n\t\t\tfree(data);\n\t\t\treturn (1);\n\t\t}\n\t\tsize += sizeof *data;\n\n\t\t/* Send the command. */\n\t\tif (proc_send(client_peer, msg, -1, data, size) != 0) {\n\t\t\tfprintf(stderr, \"failed to send command\\n\");\n\t\t\tfree(data);\n\t\t\treturn (1);\n\t\t}\n\t\tfree(data);\n\t} else if (msg == MSG_SHELL)\n\t\tproc_send(client_peer, msg, -1, NULL, 0);\n\n\t/* Start main loop. */\n\tproc_loop(client_proc, NULL);\n\n\t/* Print the exit message, if any, and exit. */\n\tif (client_attached) {\n\t\tif (client_exitreason != CLIENT_EXIT_NONE)\n\t\t\tprintf(\"[%s]\\n\", client_exit_message());\n\n\t\tppid = getppid();\n\t\tif (client_exittype == MSG_DETACHKILL && ppid > 1)\n\t\t\tkill(ppid, SIGHUP);\n\t} else if (client_flags & CLIENT_CONTROLCONTROL) {\n\t\tif (client_exitreason != CLIENT_EXIT_NONE)\n\t\t\tprintf(\"%%exit %s\\n\", client_exit_message());\n\t\telse\n\t\t\tprintf(\"%%exit\\n\");\n\t\tprintf(\"\\033\\\\\");\n\t\ttcsetattr(STDOUT_FILENO, TCSAFLUSH, &saved_tio);\n\t} else if (client_exitreason != CLIENT_EXIT_NONE)\n\t\tfprintf(stderr, \"%s\\n\", client_exit_message());\n\tsetblocking(STDIN_FILENO, 1);\n\treturn (client_exitval);\n}\n\n/* Send identify messages to server. */\nvoid\nclient_send_identify(const char *ttynam, const char *cwd)\n{\n\tconst char\t *s;\n\tchar\t\t**ss;\n\tsize_t\t\t  sslen;\n\tint\t\t  fd, flags = client_flags;\n\tpid_t\t\t  pid;\n\n\tproc_send(client_peer, MSG_IDENTIFY_FLAGS, -1, &flags, sizeof flags);\n\n\tif ((s = getenv(\"TERM\")) == NULL)\n\t\ts = \"\";\n\tproc_send(client_peer, MSG_IDENTIFY_TERM, -1, s, strlen(s) + 1);\n\n\tproc_send(client_peer, MSG_IDENTIFY_TTYNAME, -1, ttynam,\n\t    strlen(ttynam) + 1);\n\tproc_send(client_peer, MSG_IDENTIFY_CWD, -1, cwd, strlen(cwd) + 1);\n\n\tif ((fd = dup(STDIN_FILENO)) == -1)\n\t\tfatal(\"dup failed\");\n\tproc_send(client_peer, MSG_IDENTIFY_STDIN, fd, NULL, 0);\n\n\tpid = getpid();\n\tproc_send(client_peer, MSG_IDENTIFY_CLIENTPID, -1, &pid, sizeof pid);\n\n\tfor (ss = environ; *ss != NULL; ss++) {\n\t\tsslen = strlen(*ss) + 1;\n\t\tif (sslen > MAX_IMSGSIZE - IMSG_HEADER_SIZE)\n\t\t\tcontinue;\n\t\tproc_send(client_peer, MSG_IDENTIFY_ENVIRON, -1, *ss, sslen);\n\t}\n\n\tproc_send(client_peer, MSG_IDENTIFY_DONE, -1, NULL, 0);\n}\n\n/* Callback for client stdin read events. */\nvoid\nclient_stdin_callback(__unused int fd, __unused short events,\n    __unused void *arg)\n{\n\tstruct msg_stdin_data\tdata;\n\n\tdata.size = read(STDIN_FILENO, data.data, sizeof data.data);\n\tif (data.size < 0 && (errno == EINTR || errno == EAGAIN))\n\t\treturn;\n\n\tproc_send(client_peer, MSG_STDIN, -1, &data, sizeof data);\n\tif (data.size <= 0)\n\t\tevent_del(&client_stdin);\n}\n\n/* Force write to file descriptor. */\nvoid\nclient_write(int fd, const char *data, size_t size)\n{\n\tssize_t\tused;\n\n\twhile (size != 0) {\n\t\tused = write(fd, data, size);\n\t\tif (used == -1) {\n\t\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\t\tdata += used;\n\t\tsize -= used;\n\t}\n}\n\n/* Run command in shell; used for -c. */\n__dead void\nclient_exec(const char *shell, const char *shellcmd)\n{\n\tconst char\t*name, *ptr;\n\tchar\t\t*argv0;\n\n\tlog_debug(\"shell %s, command %s\", shell, shellcmd);\n\n\tptr = strrchr(shell, '/');\n\tif (ptr != NULL && *(ptr + 1) != '\\0')\n\t\tname = ptr + 1;\n\telse\n\t\tname = shell;\n\tif (client_flags & CLIENT_LOGIN)\n\t\txasprintf(&argv0, \"-%s\", name);\n\telse\n\t\txasprintf(&argv0, \"%s\", name);\n\tsetenv(\"SHELL\", shell, 1);\n\n\tsetblocking(STDIN_FILENO, 1);\n\tsetblocking(STDOUT_FILENO, 1);\n\tsetblocking(STDERR_FILENO, 1);\n\tclosefrom(STDERR_FILENO + 1);\n\n\texecl(shell, argv0, \"-c\", shellcmd, (char *) NULL);\n\tfatal(\"execl failed\");\n}\n\n/* Callback to handle signals in the client. */\nvoid\nclient_signal(int sig)\n{\n\tstruct sigaction sigact;\n\tint\t\t status;\n\n\tif (sig == SIGCHLD)\n\t\twaitpid(WAIT_ANY, &status, WNOHANG);\n\telse if (!client_attached) {\n\t\tif (sig == SIGTERM)\n\t\t\tproc_exit(client_proc);\n\t} else {\n\t\tswitch (sig) {\n\t\tcase SIGHUP:\n\t\t\tclient_exitreason = CLIENT_EXIT_LOST_TTY;\n\t\t\tclient_exitval = 1;\n\t\t\tproc_send(client_peer, MSG_EXITING, -1, NULL, 0);\n\t\t\tbreak;\n\t\tcase SIGTERM:\n\t\t\tclient_exitreason = CLIENT_EXIT_TERMINATED;\n\t\t\tclient_exitval = 1;\n\t\t\tproc_send(client_peer, MSG_EXITING, -1, NULL, 0);\n\t\t\tbreak;\n\t\tcase SIGWINCH:\n\t\t\tproc_send(client_peer, MSG_RESIZE, -1, NULL, 0);\n\t\t\tbreak;\n\t\tcase SIGCONT:\n\t\t\tmemset(&sigact, 0, sizeof sigact);\n\t\t\tsigemptyset(&sigact.sa_mask);\n\t\t\tsigact.sa_flags = SA_RESTART;\n\t\t\tsigact.sa_handler = SIG_IGN;\n\t\t\tif (sigaction(SIGTSTP, &sigact, NULL) != 0)\n\t\t\t\tfatal(\"sigaction failed\");\n\t\t\tproc_send(client_peer, MSG_WAKEUP, -1, NULL, 0);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/* Callback for client read events. */\nvoid\nclient_dispatch(struct imsg *imsg, void *arg)\n{\n\tif (imsg == NULL) {\n\t\tclient_exitreason = CLIENT_EXIT_LOST_SERVER;\n\t\tclient_exitval = 1;\n\t\tproc_exit(client_proc);\n\t\treturn;\n\t}\n\n\tif (client_attached)\n\t\tclient_dispatch_attached(imsg);\n\telse\n\t\tclient_dispatch_wait(imsg, arg);\n}\n\n/* Dispatch imsgs when in wait state (before MSG_READY). */\nvoid\nclient_dispatch_wait(struct imsg *imsg, const char *shellcmd)\n{\n\tchar\t\t\t*data;\n\tssize_t\t\t\t datalen;\n\tstruct msg_stdout_data\t stdoutdata;\n\tstruct msg_stderr_data\t stderrdata;\n\tint\t\t\t retval;\n#ifdef __OpenBSD__\n\tstatic int\t\t pledge_applied;\n\n\t/*\n\t * \"sendfd\" is no longer required once all of the identify messages\n\t * have been sent. We know the server won't send us anything until that\n\t * point (because we don't ask it to), so we can drop \"sendfd\" once we\n\t * get the first message from the server.\n\t */\n\tif (!pledge_applied) {\n\t\tif (pledge(\"stdio unix proc exec tty\", NULL) != 0)\n\t\t\tfatal(\"pledge failed\");\n\t\tpledge_applied = 1;\n\t};\n#endif\n\n\tdata = imsg->data;\n\tdatalen = imsg->hdr.len - IMSG_HEADER_SIZE;\n\n\tswitch (imsg->hdr.type) {\n\tcase MSG_EXIT:\n\tcase MSG_SHUTDOWN:\n\t\tif (datalen != sizeof retval && datalen != 0)\n\t\t\tfatalx(\"bad MSG_EXIT size\");\n\t\tif (datalen == sizeof retval) {\n\t\t\tmemcpy(&retval, data, sizeof retval);\n\t\t\tclient_exitval = retval;\n\t\t}\n\t\tproc_exit(client_proc);\n\t\tbreak;\n\tcase MSG_READY:\n\t\tif (datalen != 0)\n\t\t\tfatalx(\"bad MSG_READY size\");\n\n\t\tevent_del(&client_stdin);\n\t\tclient_attached = 1;\n\t\tproc_send(client_peer, MSG_RESIZE, -1, NULL, 0);\n\t\tbreak;\n\tcase MSG_STDIN:\n\t\tif (datalen != 0)\n\t\t\tfatalx(\"bad MSG_STDIN size\");\n\n\t\tevent_add(&client_stdin, NULL);\n\t\tbreak;\n\tcase MSG_STDOUT:\n\t\tif (datalen != sizeof stdoutdata)\n\t\t\tfatalx(\"bad MSG_STDOUT size\");\n\t\tmemcpy(&stdoutdata, data, sizeof stdoutdata);\n\n\t\tclient_write(STDOUT_FILENO, stdoutdata.data,\n\t\t    stdoutdata.size);\n\t\tbreak;\n\tcase MSG_STDERR:\n\t\tif (datalen != sizeof stderrdata)\n\t\t\tfatalx(\"bad MSG_STDERR size\");\n\t\tmemcpy(&stderrdata, data, sizeof stderrdata);\n\n\t\tclient_write(STDERR_FILENO, stderrdata.data,\n\t\t    stderrdata.size);\n\t\tbreak;\n\tcase MSG_VERSION:\n\t\tif (datalen != 0)\n\t\t\tfatalx(\"bad MSG_VERSION size\");\n\n\t\tfprintf(stderr, \"protocol version mismatch \"\n\t\t    \"(client %d, server %u)\\n\", PROTOCOL_VERSION,\n\t\t    imsg->hdr.peerid & 0xff);\n\t\tclient_exitval = 1;\n\t\tproc_exit(client_proc);\n\t\tbreak;\n\tcase MSG_SHELL:\n\t\tif (datalen == 0 || data[datalen - 1] != '\\0')\n\t\t\tfatalx(\"bad MSG_SHELL string\");\n\n\t\tclear_signals(0);\n\t\tclient_exec(data, shellcmd);\n\t\t/* NOTREACHED */\n\tcase MSG_DETACH:\n\tcase MSG_DETACHKILL:\n\t\tproc_send(client_peer, MSG_EXITING, -1, NULL, 0);\n\t\tbreak;\n\tcase MSG_EXITED:\n\t\tproc_exit(client_proc);\n\t\tbreak;\n\t}\n}\n\n/* Dispatch imsgs in attached state (after MSG_READY). */\nvoid\nclient_dispatch_attached(struct imsg *imsg)\n{\n\tstruct sigaction\t sigact;\n\tchar\t\t\t*data;\n\tssize_t\t\t\t datalen;\n\n\tdata = imsg->data;\n\tdatalen = imsg->hdr.len - IMSG_HEADER_SIZE;\n\n\tswitch (imsg->hdr.type) {\n\tcase MSG_DETACH:\n\tcase MSG_DETACHKILL:\n\t\tif (datalen == 0 || data[datalen - 1] != '\\0')\n\t\t\tfatalx(\"bad MSG_DETACH string\");\n\n\t\tclient_exitsession = xstrdup(data);\n\t\tclient_exittype = imsg->hdr.type;\n\t\tif (imsg->hdr.type == MSG_DETACHKILL)\n\t\t\tclient_exitreason = CLIENT_EXIT_DETACHED_HUP;\n\t\telse\n\t\t\tclient_exitreason = CLIENT_EXIT_DETACHED;\n\t\tproc_send(client_peer, MSG_EXITING, -1, NULL, 0);\n\t\tbreak;\n\tcase MSG_EXIT:\n\t\tif (datalen != 0 && datalen != sizeof (int))\n\t\t\tfatalx(\"bad MSG_EXIT size\");\n\n\t\tproc_send(client_peer, MSG_EXITING, -1, NULL, 0);\n\t\tclient_exitreason = CLIENT_EXIT_EXITED;\n\t\tbreak;\n\tcase MSG_EXITED:\n\t\tif (datalen != 0)\n\t\t\tfatalx(\"bad MSG_EXITED size\");\n\n\t\tproc_exit(client_proc);\n\t\tbreak;\n\tcase MSG_SHUTDOWN:\n\t\tif (datalen != 0)\n\t\t\tfatalx(\"bad MSG_SHUTDOWN size\");\n\n\t\tproc_send(client_peer, MSG_EXITING, -1, NULL, 0);\n\t\tclient_exitreason = CLIENT_EXIT_SERVER_EXITED;\n\t\tclient_exitval = 1;\n\t\tbreak;\n\tcase MSG_SUSPEND:\n\t\tif (datalen != 0)\n\t\t\tfatalx(\"bad MSG_SUSPEND size\");\n\n\t\tmemset(&sigact, 0, sizeof sigact);\n\t\tsigemptyset(&sigact.sa_mask);\n\t\tsigact.sa_flags = SA_RESTART;\n\t\tsigact.sa_handler = SIG_DFL;\n\t\tif (sigaction(SIGTSTP, &sigact, NULL) != 0)\n\t\t\tfatal(\"sigaction failed\");\n\t\tkill(getpid(), SIGTSTP);\n\t\tbreak;\n\tcase MSG_LOCK:\n\t\tif (datalen == 0 || data[datalen - 1] != '\\0')\n\t\t\tfatalx(\"bad MSG_LOCK string\");\n\n\t\tsystem(data);\n\t\tproc_send(client_peer, MSG_UNLOCK, -1, NULL, 0);\n\t\tbreak;\n\t}\n}\n"
        },
        {
          "name": "cmd-attach-session.c",
          "type": "blob",
          "size": 4.201171875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <errno.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\n/*\n * Attach existing session to the current terminal.\n */\n\nenum cmd_retval\tcmd_attach_session_exec(struct cmd *, struct cmd_q *);\n\nconst struct cmd_entry cmd_attach_session_entry = {\n\t.name = \"attach-session\",\n\t.alias = \"attach\",\n\n\t.args = { \"c:dErt:\", 0, 0 },\n\t.usage = \"[-dEr] [-c working-directory] \" CMD_TARGET_SESSION_USAGE,\n\n\t.tflag = CMD_SESSION_WITHPANE,\n\n\t.flags = CMD_STARTSERVER,\n\t.exec = cmd_attach_session_exec\n};\n\nenum cmd_retval\ncmd_attach_session(struct cmd_q *cmdq, int dflag, int rflag, const char *cflag,\n    int Eflag)\n{\n\tstruct session\t\t*s = cmdq->state.tflag.s;\n\tstruct client\t\t*c = cmdq->client, *c_loop;\n\tstruct winlink\t\t*wl = cmdq->state.tflag.wl;\n\tstruct window_pane\t*wp = cmdq->state.tflag.wp;\n\tconst char\t\t*update;\n\tchar\t\t\t*cause, *cwd;\n\tstruct format_tree\t*ft;\n\n\tif (RB_EMPTY(&sessions)) {\n\t\tcmdq_error(cmdq, \"no sessions\");\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\tif (c == NULL)\n\t\treturn (CMD_RETURN_NORMAL);\n\tif (server_client_check_nested(c)) {\n\t\tcmdq_error(cmdq, \"sessions should be nested with care, \"\n\t\t    \"unset $TMUX to force\");\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\tif (wl != NULL) {\n\t\tif (wp != NULL)\n\t\t\twindow_set_active_pane(wp->window, wp);\n\t\tsession_set_current(s, wl);\n\t}\n\n\tif (cflag != NULL) {\n\t\tft = format_create(cmdq, 0);\n\t\tformat_defaults(ft, c, s, wl, wp);\n\t\tcwd = format_expand(ft, cflag);\n\t\tformat_free(ft);\n\n\t\tfree((void *)s->cwd);\n\t\ts->cwd = cwd;\n\t}\n\n\tif (c->session != NULL) {\n\t\tif (dflag) {\n\t\t\tTAILQ_FOREACH(c_loop, &clients, entry) {\n\t\t\t\tif (c_loop->session != s || c == c_loop)\n\t\t\t\t\tcontinue;\n\t\t\t\tserver_client_detach(c_loop, MSG_DETACH);\n\t\t\t}\n\t\t}\n\n\t\tif (!Eflag) {\n\t\t\tupdate = options_get_string(s->options,\n\t\t\t    \"update-environment\");\n\t\t\tenviron_update(update, c->environ, s->environ);\n\t\t}\n\n\t\tc->session = s;\n\t\tserver_client_set_key_table(c, NULL);\n\t\tstatus_timer_start(c);\n\t\tnotify_attached_session_changed(c);\n\t\tsession_update_activity(s, NULL);\n\t\tgettimeofday(&s->last_attached_time, NULL);\n\t\tserver_redraw_client(c);\n\t\ts->curw->flags &= ~WINLINK_ALERTFLAGS;\n\t} else {\n\t\tif (server_client_open(c, &cause) != 0) {\n\t\t\tcmdq_error(cmdq, \"open terminal failed: %s\", cause);\n\t\t\tfree(cause);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\n\t\tif (rflag)\n\t\t\tc->flags |= CLIENT_READONLY;\n\n\t\tif (dflag) {\n\t\t\tTAILQ_FOREACH(c_loop, &clients, entry) {\n\t\t\t\tif (c_loop->session != s || c == c_loop)\n\t\t\t\t\tcontinue;\n\t\t\t\tserver_client_detach(c_loop, MSG_DETACH);\n\t\t\t}\n\t\t}\n\n\t\tif (!Eflag) {\n\t\t\tupdate = options_get_string(s->options,\n\t\t\t    \"update-environment\");\n\t\t\tenviron_update(update, c->environ, s->environ);\n\t\t}\n\n\t\tc->session = s;\n\t\tserver_client_set_key_table(c, NULL);\n\t\tstatus_timer_start(c);\n\t\tnotify_attached_session_changed(c);\n\t\tsession_update_activity(s, NULL);\n\t\tgettimeofday(&s->last_attached_time, NULL);\n\t\tserver_redraw_client(c);\n\t\ts->curw->flags &= ~WINLINK_ALERTFLAGS;\n\n\t\tif (~c->flags & CLIENT_CONTROL)\n\t\t\tproc_send(c->peer, MSG_READY, -1, NULL, 0);\n\t\thooks_run(c->session->hooks, c, NULL, \"client-attached\");\n\t\tcmdq->client_exit = 0;\n\t}\n\trecalculate_sizes();\n\talerts_check_session(s);\n\tserver_update_socket();\n\n\treturn (CMD_RETURN_NORMAL);\n}\n\nenum cmd_retval\ncmd_attach_session_exec(struct cmd *self, struct cmd_q *cmdq)\n{\n\tstruct args\t*args = self->args;\n\n\treturn (cmd_attach_session(cmdq, args_has(args, 'd'),\n\t    args_has(args, 'r'), args_get(args, 'c'), args_has(args, 'E')));\n}\n"
        },
        {
          "name": "cmd-bind-key.c",
          "type": "blob",
          "size": 4.03515625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * Bind a key to a command, this recurses through cmd_*.\n */\n\nenum cmd_retval\t cmd_bind_key_exec(struct cmd *, struct cmd_q *);\n\nenum cmd_retval\t cmd_bind_key_mode_table(struct cmd *, struct cmd_q *,\n\t\t     key_code);\n\nconst struct cmd_entry cmd_bind_key_entry = {\n\t.name = \"bind-key\",\n\t.alias = \"bind\",\n\n\t.args = { \"cnrt:T:\", 1, -1 },\n\t.usage = \"[-cnr] [-t mode-table] [-T key-table] key command \"\n\t\t \"[arguments]\",\n\n\t.flags = 0,\n\t.exec = cmd_bind_key_exec\n};\n\nenum cmd_retval\ncmd_bind_key_exec(struct cmd *self, struct cmd_q *cmdq)\n{\n\tstruct args\t*args = self->args;\n\tchar\t\t*cause;\n\tstruct cmd_list\t*cmdlist;\n\tkey_code\t key;\n\tconst char\t*tablename;\n\n\tif (args_has(args, 't')) {\n\t\tif (args->argc != 2 && args->argc != 3) {\n\t\t\tcmdq_error(cmdq, \"not enough arguments\");\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t} else {\n\t\tif (args->argc < 2) {\n\t\t\tcmdq_error(cmdq, \"not enough arguments\");\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t}\n\n\tkey = key_string_lookup_string(args->argv[0]);\n\tif (key == KEYC_NONE || key == KEYC_UNKNOWN) {\n\t\tcmdq_error(cmdq, \"unknown key: %s\", args->argv[0]);\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\tif (args_has(args, 't'))\n\t\treturn (cmd_bind_key_mode_table(self, cmdq, key));\n\n\tif (args_has(args, 'T'))\n\t\ttablename = args_get(args, 'T');\n\telse if (args_has(args, 'n'))\n\t\ttablename = \"root\";\n\telse\n\t\ttablename = \"prefix\";\n\n\tcmdlist = cmd_list_parse(args->argc - 1, args->argv + 1, NULL, 0,\n\t    &cause);\n\tif (cmdlist == NULL) {\n\t\tcmdq_error(cmdq, \"%s\", cause);\n\t\tfree(cause);\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\tkey_bindings_add(tablename, key, args_has(args, 'r'), cmdlist);\n\treturn (CMD_RETURN_NORMAL);\n}\n\nenum cmd_retval\ncmd_bind_key_mode_table(struct cmd *self, struct cmd_q *cmdq, key_code key)\n{\n\tstruct args\t\t\t*args = self->args;\n\tconst char\t\t\t*tablename;\n\tconst struct mode_key_table\t*mtab;\n\tstruct mode_key_binding\t\t*mbind, mtmp;\n\tenum mode_key_cmd\t\t cmd;\n\tconst char\t\t\t*arg;\n\n\ttablename = args_get(args, 't');\n\tif ((mtab = mode_key_findtable(tablename)) == NULL) {\n\t\tcmdq_error(cmdq, \"unknown key table: %s\", tablename);\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\tcmd = mode_key_fromstring(mtab->cmdstr, args->argv[1]);\n\tif (cmd == MODEKEY_NONE) {\n\t\tcmdq_error(cmdq, \"unknown command: %s\", args->argv[1]);\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\tswitch (cmd) {\n\tcase MODEKEYCOPY_APPENDSELECTION:\n\tcase MODEKEYCOPY_COPYSELECTION:\n\tcase MODEKEYCOPY_STARTNAMEDBUFFER:\n\t\tif (args->argc == 2)\n\t\t\targ = NULL;\n\t\telse {\n\t\t\targ = args->argv[2];\n\t\t\tif (strcmp(arg, \"-x\") != 0) {\n\t\t\t\tcmdq_error(cmdq, \"unknown argument\");\n\t\t\t\treturn (CMD_RETURN_ERROR);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase MODEKEYCOPY_COPYPIPE:\n\t\tif (args->argc != 3) {\n\t\t\tcmdq_error(cmdq, \"no argument given\");\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\targ = args->argv[2];\n\t\tbreak;\n\tdefault:\n\t\tif (args->argc != 2) {\n\t\t\tcmdq_error(cmdq, \"no argument allowed\");\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\targ = NULL;\n\t\tbreak;\n\t}\n\n\tmtmp.key = key;\n\tmtmp.mode = !!args_has(args, 'c');\n\tif ((mbind = RB_FIND(mode_key_tree, mtab->tree, &mtmp)) == NULL) {\n\t\tmbind = xmalloc(sizeof *mbind);\n\t\tmbind->key = mtmp.key;\n\t\tmbind->mode = mtmp.mode;\n\t\tRB_INSERT(mode_key_tree, mtab->tree, mbind);\n\t}\n\tmbind->cmd = cmd;\n\tmbind->arg = arg != NULL ? xstrdup(arg) : NULL;\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-break-pane.c",
          "type": "blob",
          "size": 3.2099609375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n\n#include \"tmux.h\"\n\n/*\n * Break pane off into a window.\n */\n\n#define BREAK_PANE_TEMPLATE \"#{session_name}:#{window_index}.#{pane_index}\"\n\nenum cmd_retval\t cmd_break_pane_exec(struct cmd *, struct cmd_q *);\n\nconst struct cmd_entry cmd_break_pane_entry = {\n\t.name = \"break-pane\",\n\t.alias = \"breakp\",\n\n\t.args = { \"dPF:s:t:\", 0, 0 },\n\t.usage = \"[-dP] [-F format] [-s src-pane] [-t dst-window]\",\n\n\t.sflag = CMD_PANE,\n\t.tflag = CMD_WINDOW_INDEX,\n\n\t.flags = 0,\n\t.exec = cmd_break_pane_exec\n};\n\nenum cmd_retval\ncmd_break_pane_exec(struct cmd *self, struct cmd_q *cmdq)\n{\n#ifdef TMATE\n\tcmdq_error(cmdq, \"break pane is not supported with tmate\");\n\treturn (CMD_RETURN_ERROR);\n#else\n\tstruct args\t\t*args = self->args;\n\tstruct winlink\t\t*wl = cmdq->state.sflag.wl;\n\tstruct session\t\t*src_s = cmdq->state.sflag.s;\n\tstruct session\t\t*dst_s = cmdq->state.tflag.s;\n\tstruct window_pane\t*wp = cmdq->state.sflag.wp;\n\tstruct window\t\t*w = wl->window;\n\tchar\t\t\t*name;\n\tchar\t\t\t*cause;\n\tint\t\t\t idx = cmdq->state.tflag.idx;\n\tstruct format_tree\t*ft;\n\tconst char\t\t*template;\n\tchar\t\t\t*cp;\n\n\tif (idx != -1 && winlink_find_by_index(&dst_s->windows, idx) != NULL) {\n\t\tcmdq_error(cmdq, \"index %d already in use\", idx);\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\tif (window_count_panes(w) == 1) {\n\t\tcmdq_error(cmdq, \"can't break with only one pane\");\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\tserver_unzoom_window(w);\n\n\tTAILQ_REMOVE(&w->panes, wp, entry);\n\twindow_lost_pane(w, wp);\n\tlayout_close_pane(wp);\n\n\tw = wp->window = window_create1(dst_s->sx, dst_s->sy);\n\tTAILQ_INSERT_HEAD(&w->panes, wp, entry);\n\tw->active = wp;\n\tname = default_window_name(w);\n\twindow_set_name(w, name);\n\tfree(name);\n\tlayout_init(w, wp);\n\twp->flags |= PANE_CHANGED;\n\n\tif (idx == -1)\n\t\tidx = -1 - options_get_number(dst_s->options, \"base-index\");\n\twl = session_attach(dst_s, w, idx, &cause); /* can't fail */\n\tif (!args_has(self->args, 'd'))\n\t\tsession_select(dst_s, wl->idx);\n\n\tserver_redraw_session(src_s);\n\tif (src_s != dst_s)\n\t\tserver_redraw_session(dst_s);\n\tserver_status_session_group(src_s);\n\tif (src_s != dst_s)\n\t\tserver_status_session_group(dst_s);\n\n\tif (args_has(args, 'P')) {\n\t\tif ((template = args_get(args, 'F')) == NULL)\n\t\t\ttemplate = BREAK_PANE_TEMPLATE;\n\n\t\tft = format_create(cmdq, 0);\n\t\tformat_defaults(ft, cmdq->state.c, dst_s, wl, wp);\n\n\t\tcp = format_expand(ft, template);\n\t\tcmdq_print(cmdq, \"%s\", cp);\n\t\tfree(cp);\n\n\t\tformat_free(ft);\n\t}\n\treturn (CMD_RETURN_NORMAL);\n#endif\n}\n"
        },
        {
          "name": "cmd-capture-pane.c",
          "type": "blob",
          "size": 5.4560546875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Jonathan Alvarado <radobobo@users.sourceforge.net>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * Write the entire contents of a pane to a buffer or stdout.\n */\n\nenum cmd_retval\t cmd_capture_pane_exec(struct cmd *, struct cmd_q *);\n\nchar\t\t*cmd_capture_pane_append(char *, size_t *, char *, size_t);\nchar\t\t*cmd_capture_pane_pending(struct args *, struct window_pane *,\n\t\t     size_t *);\nchar\t\t*cmd_capture_pane_history(struct args *, struct cmd_q *,\n\t\t     struct window_pane *, size_t *);\n\nconst struct cmd_entry cmd_capture_pane_entry = {\n\t.name = \"capture-pane\",\n\t.alias = \"capturep\",\n\n\t.args = { \"ab:CeE:JpPqS:t:\", 0, 0 },\n\t.usage = \"[-aCeJpPq] \" CMD_BUFFER_USAGE \" [-E end-line] \"\n\t\t \"[-S start-line]\" CMD_TARGET_PANE_USAGE,\n\n\t.tflag = CMD_PANE,\n\n\t.flags = 0,\n\t.exec = cmd_capture_pane_exec\n};\n\nchar *\ncmd_capture_pane_append(char *buf, size_t *len, char *line, size_t linelen)\n{\n\tbuf = xrealloc(buf, *len + linelen + 1);\n\tmemcpy(buf + *len, line, linelen);\n\t*len += linelen;\n\treturn (buf);\n}\n\nchar *\ncmd_capture_pane_pending(struct args *args, struct window_pane *wp,\n    size_t *len)\n{\n\tstruct evbuffer\t*pending;\n\tchar\t\t*buf, *line, tmp[5];\n\tsize_t\t\t linelen;\n\tu_int\t\t i;\n\n\tpending = input_pending(wp);\n\tif (pending == NULL)\n\t\treturn (xstrdup(\"\"));\n\n\tline = EVBUFFER_DATA(pending);\n\tlinelen = EVBUFFER_LENGTH(pending);\n\n\tbuf = xstrdup(\"\");\n\tif (args_has(args, 'C')) {\n\t\tfor (i = 0; i < linelen; i++) {\n\t\t\tif (line[i] >= ' ') {\n\t\t\t\ttmp[0] = line[i];\n\t\t\t\ttmp[1] = '\\0';\n\t\t\t} else\n\t\t\t\txsnprintf(tmp, sizeof tmp, \"\\\\%03hho\", line[i]);\n\t\t\tbuf = cmd_capture_pane_append(buf, len, tmp,\n\t\t\t    strlen(tmp));\n\t\t}\n\t} else\n\t\tbuf = cmd_capture_pane_append(buf, len, line, linelen);\n\treturn (buf);\n}\n\nchar *\ncmd_capture_pane_history(struct args *args, struct cmd_q *cmdq,\n    struct window_pane *wp, size_t *len)\n{\n\tstruct grid\t\t*gd;\n\tconst struct grid_line\t*gl;\n\tstruct grid_cell\t*gc = NULL;\n\tint\t\t\t n, with_codes, escape_c0, join_lines;\n\tu_int\t\t\t i, sx, top, bottom, tmp;\n\tchar\t\t\t*cause, *buf, *line;\n\tconst char\t\t*Sflag, *Eflag;\n\tsize_t\t\t\t linelen;\n\n\tsx = screen_size_x(&wp->base);\n\tif (args_has(args, 'a')) {\n\t\tgd = wp->saved_grid;\n\t\tif (gd == NULL) {\n\t\t\tif (!args_has(args, 'q')) {\n\t\t\t\tcmdq_error(cmdq, \"no alternate screen\");\n\t\t\t\treturn (NULL);\n\t\t\t}\n\t\t\treturn (xstrdup(\"\"));\n\t\t}\n\t} else\n\t\tgd = wp->base.grid;\n\n\tSflag = args_get(args, 'S');\n\tif (Sflag != NULL && strcmp(Sflag, \"-\") == 0)\n\t\ttop = 0;\n\telse {\n\t\tn = args_strtonum(args, 'S', INT_MIN, SHRT_MAX, &cause);\n\t\tif (cause != NULL) {\n\t\t\ttop = gd->hsize;\n\t\t\tfree(cause);\n\t\t} else if (n < 0 && (u_int) -n > gd->hsize)\n\t\t\ttop = 0;\n\t\telse\n\t\t\ttop = gd->hsize + n;\n\t\tif (top > gd->hsize + gd->sy - 1)\n\t\t\ttop = gd->hsize + gd->sy - 1;\n\t}\n\n\tEflag = args_get(args, 'E');\n\tif (Eflag != NULL && strcmp(Eflag, \"-\") == 0)\n\t\tbottom = gd->hsize + gd->sy - 1;\n\telse {\n\t\tn = args_strtonum(args, 'E', INT_MIN, SHRT_MAX, &cause);\n\t\tif (cause != NULL) {\n\t\t\tbottom = gd->hsize + gd->sy - 1;\n\t\t\tfree(cause);\n\t\t} else if (n < 0 && (u_int) -n > gd->hsize)\n\t\t\tbottom = 0;\n\t\telse\n\t\t\tbottom = gd->hsize + n;\n\t\tif (bottom > gd->hsize + gd->sy - 1)\n\t\t\tbottom = gd->hsize + gd->sy - 1;\n\t}\n\n\tif (bottom < top) {\n\t\ttmp = bottom;\n\t\tbottom = top;\n\t\ttop = tmp;\n\t}\n\n\twith_codes = args_has(args, 'e');\n\tescape_c0 = args_has(args, 'C');\n\tjoin_lines = args_has(args, 'J');\n\n\tbuf = NULL;\n\tfor (i = top; i <= bottom; i++) {\n\t\tline = grid_string_cells(gd, 0, i, sx, &gc, with_codes,\n\t\t    escape_c0, !join_lines);\n\t\tlinelen = strlen(line);\n\n\t\tbuf = cmd_capture_pane_append(buf, len, line, linelen);\n\n\t\tgl = grid_peek_line(gd, i);\n\t\tif (!join_lines || !(gl->flags & GRID_LINE_WRAPPED))\n\t\t\tbuf[(*len)++] = '\\n';\n\n\t\tfree(line);\n\t}\n\treturn (buf);\n}\n\nenum cmd_retval\ncmd_capture_pane_exec(struct cmd *self, struct cmd_q *cmdq)\n{\n\tstruct args\t\t*args = self->args;\n\tstruct client\t\t*c;\n\tstruct window_pane\t*wp = cmdq->state.tflag.wp;\n\tchar\t\t\t*buf, *cause;\n\tconst char\t\t*bufname;\n\tsize_t\t\t\t len;\n\n\tlen = 0;\n\tif (args_has(args, 'P'))\n\t\tbuf = cmd_capture_pane_pending(args, wp, &len);\n\telse\n\t\tbuf = cmd_capture_pane_history(args, cmdq, wp, &len);\n\tif (buf == NULL)\n\t\treturn (CMD_RETURN_ERROR);\n\n\tif (args_has(args, 'p')) {\n\t\tc = cmdq->client;\n\t\tif (c == NULL ||\n\t\t    (c->session != NULL && !(c->flags & CLIENT_CONTROL))) {\n\t\t\tcmdq_error(cmdq, \"can't write to stdout\");\n\t\t\tfree(buf);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\tevbuffer_add(c->stdout_data, buf, len);\n\t\tfree(buf);\n\t\tif (args_has(args, 'P') && len > 0)\n\t\t    evbuffer_add(c->stdout_data, \"\\n\", 1);\n\t\tserver_client_push_stdout(c);\n\t} else {\n\t\tbufname = NULL;\n\t\tif (args_has(args, 'b'))\n\t\t\tbufname = args_get(args, 'b');\n\n\t\tif (paste_set(buf, len, bufname, &cause) != 0) {\n\t\t\tcmdq_error(cmdq, \"%s\", cause);\n\t\t\tfree(cause);\n\t\t\tfree(buf);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t}\n\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-choose-buffer.c",
          "type": "blob",
          "size": 2.6513671875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2010 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <ctype.h>\n#include <stdlib.h>\n\n#include \"tmux.h\"\n\n/*\n * Enter choice mode to choose a buffer.\n */\n\n#define CHOOSE_BUFFER_TEMPLATE\t\t\t\t\t\t\\\n\t\"#{buffer_name}: #{buffer_size} bytes: #{buffer_sample}\"\n\nenum cmd_retval\t cmd_choose_buffer_exec(struct cmd *, struct cmd_q *);\n\nconst struct cmd_entry cmd_choose_buffer_entry = {\n\t.name = \"choose-buffer\",\n\t.alias = NULL,\n\n\t.args = { \"F:t:\", 0, 1 },\n\t.usage = CMD_TARGET_WINDOW_USAGE \" [-F format] [template]\",\n\n\t.tflag = CMD_WINDOW,\n\n\t.flags = 0,\n\t.exec = cmd_choose_buffer_exec\n};\n\nenum cmd_retval\ncmd_choose_buffer_exec(struct cmd *self, struct cmd_q *cmdq)\n{\n\tstruct args\t\t\t*args = self->args;\n\tstruct client\t\t\t*c = cmdq->state.c;\n\tstruct winlink\t\t\t*wl = cmdq->state.tflag.wl;\n\tstruct window_choose_data\t*cdata;\n\tstruct paste_buffer\t\t*pb;\n\tchar\t\t\t\t*action, *action_data;\n\tconst char\t\t\t*template;\n\tu_int\t\t\t\t idx;\n\n\tif (c == NULL) {\n\t\tcmdq_error(cmdq, \"no client available\");\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\tif ((template = args_get(args, 'F')) == NULL)\n\t\ttemplate = CHOOSE_BUFFER_TEMPLATE;\n\n\tif (paste_get_top(NULL) == NULL)\n\t\treturn (CMD_RETURN_NORMAL);\n\n\tif (window_pane_set_mode(wl->window->active, &window_choose_mode) != 0)\n\t\treturn (CMD_RETURN_NORMAL);\n\n\tif (args->argc != 0)\n\t\taction = xstrdup(args->argv[0]);\n\telse\n\t\taction = xstrdup(\"paste-buffer -b '%%'\");\n\n\tidx = 0;\n\tpb = NULL;\n\twhile ((pb = paste_walk(pb)) != NULL) {\n\t\tcdata = window_choose_data_create(TREE_OTHER, c, c->session);\n\t\tcdata->idx = idx;\n\n\t\tcdata->ft_template = xstrdup(template);\n\t\tformat_defaults_paste_buffer(cdata->ft, pb);\n\n\t\txasprintf(&action_data, \"%s\", paste_buffer_name(pb));\n\t\tcdata->command = cmd_template_replace(action, action_data, 1);\n\t\tfree(action_data);\n\n\t\twindow_choose_add(wl->window->active, cdata);\n\t\tidx++;\n\t}\n\tfree(action);\n\n\twindow_choose_ready(wl->window->active, 0, NULL);\n\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-choose-client.c",
          "type": "blob",
          "size": 3.283203125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <ctype.h>\n#include <stdlib.h>\n\n#include \"tmux.h\"\n\n/*\n * Enter choice mode to choose a client.\n */\n\n#define CHOOSE_CLIENT_TEMPLATE\t\t\t\t\t\\\n\t\"#{client_tty}: #{session_name} \"\t\t\t\\\n\t\"[#{client_width}x#{client_height} #{client_termname}]\"\t\\\n\t\"#{?client_utf8, (utf8),}#{?client_readonly, (ro),} \"\t\\\n\t\"(last used #{t:client_activity})\"\n\nenum cmd_retval\t cmd_choose_client_exec(struct cmd *, struct cmd_q *);\n\nvoid\tcmd_choose_client_callback(struct window_choose_data *);\n\nconst struct cmd_entry cmd_choose_client_entry = {\n\t.name = \"choose-client\",\n\t.alias = NULL,\n\n\t.args = { \"F:t:\", 0, 1 },\n\t.usage = CMD_TARGET_WINDOW_USAGE \" [-F format] [template]\",\n\n\t.tflag = CMD_WINDOW,\n\n\t.flags = 0,\n\t.exec = cmd_choose_client_exec\n};\n\nstruct cmd_choose_client_data {\n\tstruct client\t*client;\n};\n\nenum cmd_retval\ncmd_choose_client_exec(struct cmd *self, struct cmd_q *cmdq)\n{\n\tstruct args\t\t\t*args = self->args;\n\tstruct client\t\t\t*c = cmdq->state.c;\n\tstruct client\t\t\t*c1;\n\tstruct window_choose_data\t*cdata;\n\tstruct winlink\t\t\t*wl = cmdq->state.tflag.wl;\n\tconst char\t\t\t*template;\n\tchar\t\t\t\t*action;\n\tu_int\t\t\t \t idx, cur;\n\n\tif (c == NULL) {\n\t\tcmdq_error(cmdq, \"no client available\");\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\tif (window_pane_set_mode(wl->window->active, &window_choose_mode) != 0)\n\t\treturn (CMD_RETURN_NORMAL);\n\n\tif ((template = args_get(args, 'F')) == NULL)\n\t\ttemplate = CHOOSE_CLIENT_TEMPLATE;\n\n\tif (args->argc != 0)\n\t\taction = xstrdup(args->argv[0]);\n\telse\n\t\taction = xstrdup(\"detach-client -t '%%'\");\n\n\tcur = idx = 0;\n\tTAILQ_FOREACH(c1, &clients, entry) {\n\t\tif (c1->session == NULL || c1->tty.path == NULL)\n\t\t\tcontinue;\n\t\tif (c1 == cmdq->client)\n\t\t\tcur = idx;\n\n\t\tcdata = window_choose_data_create(TREE_OTHER, c, c->session);\n\t\tcdata->idx = idx;\n\n\t\tcdata->ft_template = xstrdup(template);\n\t\tformat_add(cdata->ft, \"line\", \"%u\", idx);\n\t\tformat_defaults(cdata->ft, c1, NULL, NULL, NULL);\n\n\t\tcdata->command = cmd_template_replace(action, c1->tty.path, 1);\n\n\t\twindow_choose_add(wl->window->active, cdata);\n\n\t\tidx++;\n\t}\n\tfree(action);\n\n\twindow_choose_ready(wl->window->active, cur,\n\t    cmd_choose_client_callback);\n\n\treturn (CMD_RETURN_NORMAL);\n}\n\nvoid\ncmd_choose_client_callback(struct window_choose_data *cdata)\n{\n\tstruct client  \t*c;\n\tu_int\t\t idx;\n\n\tif (cdata == NULL)\n\t\treturn;\n\tif (cdata->start_client->flags & CLIENT_DEAD)\n\t\treturn;\n\n\tidx = 0;\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (idx == cdata->idx)\n\t\t\tbreak;\n\t\tidx++;\n\t}\n\tif (c == NULL || c->session == NULL)\n\t\treturn;\n\n\twindow_choose_data_run(cdata);\n}\n"
        },
        {
          "name": "cmd-choose-tree.c",
          "type": "blob",
          "size": 6.751953125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2012 Thomas Adam <thomas@xteddy.org>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <ctype.h>\n#include <stdlib.h>\n\n#include <string.h>\n\n#include \"tmux.h\"\n\n#define CMD_CHOOSE_TREE_WINDOW_ACTION \"select-window -t '%%'\"\n#define CMD_CHOOSE_TREE_SESSION_ACTION \"switch-client -t '%%'\"\n\n/*\n * Enter choice mode to choose a session and/or window.\n */\n\n#define CHOOSE_TREE_SESSION_TEMPLATE\t\t\t\t\\\n\t\"#{session_name}: #{session_windows} windows\"\t\t\\\n\t\"#{?session_grouped, (group ,}\"\t\t\t\t\\\n\t\"#{session_group}#{?session_grouped,),}\"\t\t\\\n\t\"#{?session_attached, (attached),}\"\n#define CHOOSE_TREE_WINDOW_TEMPLATE\t\t\t\t\\\n\t\"#{window_index}: #{window_name}#{window_flags} \"\t\\\n\t\"\\\"#{pane_title}\\\"\"\n\nenum cmd_retval\tcmd_choose_tree_exec(struct cmd *, struct cmd_q *);\n\nconst struct cmd_entry cmd_choose_tree_entry = {\n\t.name = \"choose-tree\",\n\t.alias = NULL,\n\n\t.args = { \"S:W:swub:c:t:\", 0, 1 },\n\t.usage = \"[-suw] [-b session-template] [-c window template] \"\n\t\t \"[-S format] [-W format] \" CMD_TARGET_WINDOW_USAGE,\n\n\t.tflag = CMD_WINDOW,\n\n\t.flags = 0,\n\t.exec = cmd_choose_tree_exec\n};\n\nconst struct cmd_entry cmd_choose_session_entry = {\n\t.name = \"choose-session\",\n\t.alias = NULL,\n\n\t.args = { \"F:t:\", 0, 1 },\n\t.usage = CMD_TARGET_WINDOW_USAGE \" [-F format] [template]\",\n\n\t.tflag = CMD_WINDOW,\n\n\t.flags = 0,\n\t.exec = cmd_choose_tree_exec\n};\n\nconst struct cmd_entry cmd_choose_window_entry = {\n\t.name = \"choose-window\",\n\t.alias = NULL,\n\n\t.args = { \"F:t:\", 0, 1 },\n\t.usage = CMD_TARGET_WINDOW_USAGE \"[-F format] [template]\",\n\n\t.tflag = CMD_WINDOW,\n\n\t.flags = 0,\n\t.exec = cmd_choose_tree_exec\n};\n\nenum cmd_retval\ncmd_choose_tree_exec(struct cmd *self, struct cmd_q *cmdq)\n{\n\tstruct args\t\t\t*args = self->args;\n\tstruct client\t\t\t*c = cmdq->state.c;\n\tstruct winlink\t\t\t*wl = cmdq->state.tflag.wl, *wm;\n\tstruct session\t\t\t*s = cmdq->state.tflag.s, *s2;\n\tstruct window_choose_data\t*wcd = NULL;\n\tconst char\t\t\t*ses_template, *win_template;\n\tchar\t\t\t\t*final_win_action, *cur_win_template;\n\tchar\t\t\t\t*final_win_template_middle;\n\tchar\t\t\t\t*final_win_template_last;\n\tconst char\t\t\t*ses_action, *win_action;\n\tu_int\t\t\t\t cur_win, idx_ses, win_ses, win_max;\n\tu_int\t\t\t\t wflag, sflag;\n\n\tses_template = win_template = NULL;\n\tses_action = win_action = NULL;\n\n\tif (c == NULL) {\n\t\tcmdq_error(cmdq, \"no client available\");\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\tif (window_pane_set_mode(wl->window->active, &window_choose_mode) != 0)\n\t\treturn (CMD_RETURN_NORMAL);\n\n\t/* Sort out which command this is. */\n\twflag = sflag = 0;\n\tif (self->entry == &cmd_choose_session_entry) {\n\t\tsflag = 1;\n\t\tif ((ses_template = args_get(args, 'F')) == NULL)\n\t\t\tses_template = CHOOSE_TREE_SESSION_TEMPLATE;\n\n\t\tif (args->argc != 0)\n\t\t\tses_action = args->argv[0];\n\t\telse\n\t\t\tses_action = CMD_CHOOSE_TREE_SESSION_ACTION;\n\t} else if (self->entry == &cmd_choose_window_entry) {\n\t\twflag = 1;\n\t\tif ((win_template = args_get(args, 'F')) == NULL)\n\t\t\twin_template = CHOOSE_TREE_WINDOW_TEMPLATE;\n\n\t\tif (args->argc != 0)\n\t\t\twin_action = args->argv[0];\n\t\telse\n\t\t\twin_action = CMD_CHOOSE_TREE_WINDOW_ACTION;\n\t} else {\n\t\twflag = args_has(args, 'w');\n\t\tsflag = args_has(args, 's');\n\n\t\tif ((ses_action = args_get(args, 'b')) == NULL)\n\t\t\tses_action = CMD_CHOOSE_TREE_SESSION_ACTION;\n\n\t\tif ((win_action = args_get(args, 'c')) == NULL)\n\t\t\twin_action = CMD_CHOOSE_TREE_WINDOW_ACTION;\n\n\t\tif ((ses_template = args_get(args, 'S')) == NULL)\n\t\t\tses_template = CHOOSE_TREE_SESSION_TEMPLATE;\n\n\t\tif ((win_template = args_get(args, 'W')) == NULL)\n\t\t\twin_template = CHOOSE_TREE_WINDOW_TEMPLATE;\n\t}\n\n\t/*\n\t * If not asking for windows and sessions, assume no \"-ws\" given and\n\t * hence display the entire tree outright.\n\t */\n\tif (!wflag && !sflag)\n\t\twflag = sflag = 1;\n\n\t/*\n\t * If we're drawing in tree mode, including sessions, then pad the\n\t * window template, otherwise just render the windows as a flat list\n\t * without any padding.\n\t */\n\tif (wflag && sflag) {\n\t\txasprintf(&final_win_template_middle,\n\t\t    \" \\001tq\\001> %s\", win_template);\n\t\txasprintf(&final_win_template_last,\n\t\t    \" \\001mq\\001> %s\", win_template);\n\t} else if (wflag) {\n\t\tfinal_win_template_middle = xstrdup(win_template);\n\t\tfinal_win_template_last = xstrdup(win_template);\n\t} else\n\t\tfinal_win_template_middle = final_win_template_last = NULL;\n\n\tidx_ses = cur_win = -1;\n\tRB_FOREACH(s2, sessions, &sessions) {\n\t\tidx_ses++;\n\n\t\t/*\n\t\t * If we're just choosing windows, jump straight there. Note\n\t\t * that this implies the current session, so only choose\n\t\t * windows when the session matches this one.\n\t\t */\n\t\tif (wflag && !sflag) {\n\t\t\tif (s != s2)\n\t\t\t\tcontinue;\n\t\t\tgoto windows_only;\n\t\t}\n\n\t\twcd = window_choose_add_session(wl->window->active,\n\t\t    c, s2, ses_template, ses_action, idx_ses);\n\n\t\t/* If we're just choosing sessions, skip choosing windows. */\n\t\tif (sflag && !wflag) {\n\t\t\tif (s == s2)\n\t\t\t\tcur_win = idx_ses;\n\t\t\tcontinue;\n\t\t}\nwindows_only:\n\t\twin_ses = win_max = -1;\n\t\tRB_FOREACH(wm, winlinks, &s2->windows)\n\t\t\twin_max++;\n\t\tRB_FOREACH(wm, winlinks, &s2->windows) {\n\t\t\twin_ses++;\n\t\t\tif (sflag && wflag)\n\t\t\t\tidx_ses++;\n\n\t\t\tif (wm == s2->curw && s == s2) {\n\t\t\t\tif (wflag && !sflag) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Then we're only counting windows.\n\t\t\t\t\t * So remember which is the current\n\t\t\t\t\t * window in the list.\n\t\t\t\t\t */\n\t\t\t\t\tcur_win = win_ses;\n\t\t\t\t} else\n\t\t\t\t\tcur_win = idx_ses;\n\t\t\t}\n\n\t\t\txasprintf(&final_win_action, \"%s %s %s\",\n\t\t\t    wcd != NULL ? wcd->command : \"\",\n\t\t\t    wcd != NULL ? \";\" : \"\", win_action);\n\n\t\t\tif (win_ses != win_max)\n\t\t\t\tcur_win_template = final_win_template_middle;\n\t\t\telse\n\t\t\t\tcur_win_template = final_win_template_last;\n\n\t\t\twindow_choose_add_window(wl->window->active,\n\t\t\t    c, s2, wm, cur_win_template,\n\t\t\t    final_win_action,\n\t\t\t    (wflag && !sflag) ? win_ses : idx_ses);\n\n\t\t\tfree(final_win_action);\n\t\t}\n\n\t\t/*\n\t\t * If we're just drawing windows, don't consider moving on to\n\t\t * other sessions as we only list windows in this session.\n\t\t */\n\t\tif (wflag && !sflag)\n\t\t\tbreak;\n\t}\n\tfree(final_win_template_middle);\n\tfree(final_win_template_last);\n\n\twindow_choose_ready(wl->window->active, cur_win, NULL);\n\n\tif (args_has(args, 'u')) {\n\t\twindow_choose_expand_all(wl->window->active);\n\t\twindow_choose_set_current(wl->window->active, cur_win);\n\t}\n\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-clear-history.c",
          "type": "blob",
          "size": 1.4892578125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include \"tmux.h\"\n\n/*\n * Clear pane history.\n */\n\nenum cmd_retval\t cmd_clear_history_exec(struct cmd *, struct cmd_q *);\n\nconst struct cmd_entry cmd_clear_history_entry = {\n\t.name = \"clear-history\",\n\t.alias = \"clearhist\",\n\n\t.args = { \"t:\", 0, 0 },\n\t.usage = CMD_TARGET_PANE_USAGE,\n\n\t.tflag = CMD_PANE,\n\n\t.flags = 0,\n\t.exec = cmd_clear_history_exec\n};\n\nenum cmd_retval\ncmd_clear_history_exec(__unused struct cmd *self, struct cmd_q *cmdq)\n{\n\tstruct window_pane\t*wp = cmdq->state.tflag.wp;\n\tstruct grid\t\t*gd;\n\n\tgd = cmdq->state.tflag.wp->base.grid;\n\n\tif (wp->mode == &window_copy_mode)\n\t\twindow_pane_reset_mode(wp);\n\tgrid_clear_history(gd);\n\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-command-prompt.c",
          "type": "blob",
          "size": 4.2314453125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2008 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <ctype.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\n#include \"tmux.h\"\n\n/*\n * Prompt for command in client.\n */\n\nenum cmd_retval\tcmd_command_prompt_exec(struct cmd *, struct cmd_q *);\n\nint\tcmd_command_prompt_callback(void *, const char *);\nvoid\tcmd_command_prompt_free(void *);\n\nconst struct cmd_entry cmd_command_prompt_entry = {\n\t.name = \"command-prompt\",\n\t.alias = NULL,\n\n\t.args = { \"I:p:t:\", 0, 1 },\n\t.usage = \"[-I inputs] [-p prompts] \" CMD_TARGET_CLIENT_USAGE \" \"\n\t\t \"[template]\",\n\n\t.tflag = CMD_CLIENT,\n\n\t.flags = 0,\n\t.exec = cmd_command_prompt_exec\n};\n\nstruct cmd_command_prompt_cdata {\n\tstruct client\t*c;\n\tchar\t\t*inputs;\n\tchar\t\t*next_input;\n\tchar\t\t*next_prompt;\n\tchar\t\t*prompts;\n\tchar\t\t*template;\n\tint\t\t idx;\n};\n\nenum cmd_retval\ncmd_command_prompt_exec(struct cmd *self, struct cmd_q *cmdq)\n{\n\tstruct args\t\t\t*args = self->args;\n\tconst char\t\t\t*inputs, *prompts;\n\tstruct cmd_command_prompt_cdata\t*cdata;\n\tstruct client\t\t\t*c = cmdq->state.c;\n\tchar\t\t\t\t*prompt, *ptr, *input = NULL;\n\tsize_t\t\t\t\t n;\n\n\tif (c->prompt_string != NULL)\n\t\treturn (CMD_RETURN_NORMAL);\n\n\tcdata = xmalloc(sizeof *cdata);\n\tcdata->c = c;\n\tcdata->idx = 1;\n\tcdata->inputs = NULL;\n\tcdata->next_input = NULL;\n\tcdata->next_prompt = NULL;\n\tcdata->prompts = NULL;\n\tcdata->template = NULL;\n\n\tif (args->argc != 0)\n\t\tcdata->template = xstrdup(args->argv[0]);\n\telse\n\t\tcdata->template = xstrdup(\"%1\");\n\n\tif ((prompts = args_get(args, 'p')) != NULL)\n\t\tcdata->prompts = xstrdup(prompts);\n\telse if (args->argc != 0) {\n\t\tn = strcspn(cdata->template, \" ,\");\n\t\txasprintf(&cdata->prompts, \"(%.*s) \", (int) n, cdata->template);\n\t} else\n\t\tcdata->prompts = xstrdup(\":\");\n\n\t/* Get first prompt. */\n\tcdata->next_prompt = cdata->prompts;\n\tptr = strsep(&cdata->next_prompt, \",\");\n\tif (prompts == NULL)\n\t\tprompt = xstrdup(ptr);\n\telse\n\t\txasprintf(&prompt, \"%s \", ptr);\n\n\t/* Get initial prompt input. */\n\tif ((inputs = args_get(args, 'I')) != NULL) {\n\t\tcdata->inputs = xstrdup(inputs);\n\t\tcdata->next_input = cdata->inputs;\n\t\tinput = strsep(&cdata->next_input, \",\");\n\t}\n\n\tstatus_prompt_set(c, prompt, input, cmd_command_prompt_callback,\n\t    cmd_command_prompt_free, cdata, 0);\n\tfree(prompt);\n\n\treturn (CMD_RETURN_NORMAL);\n}\n\nint\ncmd_command_prompt_callback(void *data, const char *s)\n{\n\tstruct cmd_command_prompt_cdata\t*cdata = data;\n\tstruct client\t\t\t*c = cdata->c;\n\tstruct cmd_list\t\t\t*cmdlist;\n\tchar\t\t\t\t*cause, *new_template, *prompt, *ptr;\n\tchar\t\t\t\t*input = NULL;\n\n\tif (s == NULL)\n\t\treturn (0);\n\n\tnew_template = cmd_template_replace(cdata->template, s, cdata->idx);\n\tfree(cdata->template);\n\tcdata->template = new_template;\n\n\t/*\n\t * Check if there are more prompts; if so, get its respective input\n\t * and update the prompt data.\n\t */\n\tif ((ptr = strsep(&cdata->next_prompt, \",\")) != NULL) {\n\t\txasprintf(&prompt, \"%s \", ptr);\n\t\tinput = strsep(&cdata->next_input, \",\");\n\t\tstatus_prompt_update(c, prompt, input);\n\n\t\tfree(prompt);\n\t\tcdata->idx++;\n\t\treturn (1);\n\t}\n\n\tif (cmd_string_parse(new_template, &cmdlist, NULL, 0, &cause) != 0) {\n\t\tif (cause != NULL) {\n\t\t\t*cause = toupper((u_char) *cause);\n\t\t\tstatus_message_set(c, \"%s\", cause);\n\t\t\tfree(cause);\n\t\t}\n\t\treturn (0);\n\t}\n\n\tcmdq_run(c->cmdq, cmdlist, NULL);\n\tcmd_list_free(cmdlist);\n\n\tif (c->prompt_callbackfn != (void *) &cmd_command_prompt_callback)\n\t\treturn (1);\n\treturn (0);\n}\n\nvoid\ncmd_command_prompt_free(void *data)\n{\n\tstruct cmd_command_prompt_cdata\t*cdata = data;\n\n\tfree(cdata->inputs);\n\tfree(cdata->prompts);\n\tfree(cdata->template);\n\tfree(cdata);\n}\n"
        },
        {
          "name": "cmd-confirm-before.c",
          "type": "blob",
          "size": 2.98828125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Tiago Cunha <me@tiagocunha.org>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <ctype.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * Asks for confirmation before executing a command.\n */\n\nenum cmd_retval\t cmd_confirm_before_exec(struct cmd *, struct cmd_q *);\n\nint\t\t cmd_confirm_before_callback(void *, const char *);\nvoid\t\t cmd_confirm_before_free(void *);\n\nconst struct cmd_entry cmd_confirm_before_entry = {\n\t.name = \"confirm-before\",\n\t.alias = \"confirm\",\n\n\t.args = { \"p:t:\", 1, 1 },\n\t.usage = \"[-p prompt] \" CMD_TARGET_CLIENT_USAGE \" command\",\n\n\t.tflag = CMD_CLIENT,\n\n\t.flags = 0,\n\t.exec = cmd_confirm_before_exec\n};\n\nstruct cmd_confirm_before_data {\n\tchar\t\t*cmd;\n\tstruct client\t*client;\n};\n\nenum cmd_retval\ncmd_confirm_before_exec(struct cmd *self, struct cmd_q *cmdq)\n{\n\tstruct args\t\t\t*args = self->args;\n\tstruct cmd_confirm_before_data\t*cdata;\n\tstruct client\t\t\t*c = cmdq->state.c;\n\tchar\t\t\t\t*cmd, *copy, *new_prompt, *ptr;\n\tconst char\t\t\t*prompt;\n\n\tif ((prompt = args_get(args, 'p')) != NULL)\n\t\txasprintf(&new_prompt, \"%s \", prompt);\n\telse {\n\t\tptr = copy = xstrdup(args->argv[0]);\n\t\tcmd = strsep(&ptr, \" \\t\");\n\t\txasprintf(&new_prompt, \"Confirm '%s'? (y/n) \", cmd);\n\t\tfree(copy);\n\t}\n\n\tcdata = xmalloc(sizeof *cdata);\n\tcdata->cmd = xstrdup(args->argv[0]);\n\n\tcdata->client = c;\n\tcdata->client->references++;\n\n\tstatus_prompt_set(c, new_prompt, NULL,\n\t    cmd_confirm_before_callback, cmd_confirm_before_free, cdata,\n\t    PROMPT_SINGLE);\n\n\tfree(new_prompt);\n\treturn (CMD_RETURN_NORMAL);\n}\n\nint\ncmd_confirm_before_callback(void *data, const char *s)\n{\n\tstruct cmd_confirm_before_data\t*cdata = data;\n\tstruct client\t\t\t*c = cdata->client;\n\tstruct cmd_list\t\t\t*cmdlist;\n\tchar\t\t\t\t*cause;\n\n\tif (c->flags & CLIENT_DEAD)\n\t\treturn (0);\n\n\tif (s == NULL || *s == '\\0')\n\t\treturn (0);\n\tif (tolower((u_char) s[0]) != 'y' || s[1] != '\\0')\n\t\treturn (0);\n\n\tif (cmd_string_parse(cdata->cmd, &cmdlist, NULL, 0, &cause) != 0) {\n\t\tif (cause != NULL) {\n\t\t\tcmdq_error(c->cmdq, \"%s\", cause);\n\t\t\tfree(cause);\n\t\t}\n\t\treturn (0);\n\t}\n\n\tcmdq_run(c->cmdq, cmdlist, NULL);\n\tcmd_list_free(cmdlist);\n\n\treturn (0);\n}\n\nvoid\ncmd_confirm_before_free(void *data)\n{\n\tstruct cmd_confirm_before_data\t*cdata = data;\n\tstruct client\t\t\t*c = cdata->client;\n\n\tserver_client_unref(c);\n\n\tfree(cdata->cmd);\n\tfree(cdata);\n}\n"
        },
        {
          "name": "cmd-copy-mode.c",
          "type": "blob",
          "size": 2.375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include \"tmux.h\"\n\n/*\n * Enter copy or clock mode.\n */\n\nenum cmd_retval\t cmd_copy_mode_exec(struct cmd *, struct cmd_q *);\n\nconst struct cmd_entry cmd_copy_mode_entry = {\n\t.name = \"copy-mode\",\n\t.alias = NULL,\n\n\t.args = { \"Met:u\", 0, 0 },\n\t.usage = \"[-Mu] \" CMD_TARGET_PANE_USAGE,\n\n\t.tflag = CMD_PANE,\n\n\t.flags = 0,\n\t.exec = cmd_copy_mode_exec\n};\n\nconst struct cmd_entry cmd_clock_mode_entry = {\n\t.name = \"clock-mode\",\n\t.alias = NULL,\n\n\t.args = { \"t:\", 0, 0 },\n\t.usage = CMD_TARGET_PANE_USAGE,\n\n\t.tflag = CMD_PANE,\n\n\t.flags = 0,\n\t.exec = cmd_copy_mode_exec\n};\n\nenum cmd_retval\ncmd_copy_mode_exec(struct cmd *self, struct cmd_q *cmdq)\n{\n\tstruct args\t\t*args = self->args;\n\tstruct client\t\t*c = cmdq->client;\n\tstruct session\t\t*s;\n\tstruct window_pane\t*wp = cmdq->state.tflag.wp;\n\n\tif (args_has(args, 'M')) {\n\t\tif ((wp = cmd_mouse_pane(&cmdq->item->mouse, &s, NULL)) == NULL)\n\t\t\treturn (CMD_RETURN_NORMAL);\n\t\tif (c == NULL || c->session != s)\n\t\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tif (self->entry == &cmd_clock_mode_entry) {\n\t\twindow_pane_set_mode(wp, &window_clock_mode);\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tif (wp->mode != &window_copy_mode) {\n\t\tif (window_pane_set_mode(wp, &window_copy_mode) != 0)\n\t\t\treturn (CMD_RETURN_NORMAL);\n\t\twindow_copy_init_from_pane(wp, args_has(self->args, 'e'));\n\t}\n\tif (args_has(args, 'M')) {\n\t\tif (wp->mode != NULL && wp->mode != &window_copy_mode)\n\t\t\treturn (CMD_RETURN_NORMAL);\n\t\twindow_copy_start_drag(c, &cmdq->item->mouse);\n\t}\n\tif (wp->mode == &window_copy_mode && args_has(self->args, 'u'))\n\t\twindow_copy_pageup(wp);\n\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-detach-client.c",
          "type": "blob",
          "size": 2.408203125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * Detach a client.\n */\n\nenum cmd_retval\t cmd_detach_client_exec(struct cmd *, struct cmd_q *);\n\nconst struct cmd_entry cmd_detach_client_entry = {\n\t.name = \"detach-client\",\n\t.alias = \"detach\",\n\n\t.args = { \"as:t:P\", 0, 0 },\n\t.usage = \"[-P] [-a] [-s target-session] \" CMD_TARGET_CLIENT_USAGE,\n\n\t.sflag = CMD_SESSION,\n\t.tflag = CMD_CLIENT,\n\n\t.flags = CMD_READONLY,\n\t.exec = cmd_detach_client_exec\n};\n\nconst struct cmd_entry cmd_suspend_client_entry = {\n\t.name = \"suspend-client\",\n\t.alias = \"suspendc\",\n\n\t.args = { \"t:\", 0, 0 },\n\t.usage = CMD_TARGET_CLIENT_USAGE,\n\n\t.tflag = CMD_CLIENT,\n\n\t.flags = 0,\n\t.exec = cmd_detach_client_exec\n};\n\nenum cmd_retval\ncmd_detach_client_exec(struct cmd *self, struct cmd_q *cmdq)\n{\n\tstruct args\t*args = self->args;\n\tstruct client\t*c = cmdq->state.c, *cloop;\n\tstruct session\t*s;\n\tenum msgtype\t msgtype;\n\n\tif (self->entry == &cmd_suspend_client_entry) {\n\t\ttty_stop_tty(&c->tty);\n\t\tc->flags |= CLIENT_SUSPENDED;\n\t\tproc_send(c->peer, MSG_SUSPEND, -1, NULL, 0);\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tif (args_has(args, 'P'))\n\t\tmsgtype = MSG_DETACHKILL;\n\telse\n\t\tmsgtype = MSG_DETACH;\n\n\tif (args_has(args, 's')) {\n\t\ts = cmdq->state.sflag.s;\n\t\tTAILQ_FOREACH(cloop, &clients, entry) {\n\t\t\tif (cloop->session == s)\n\t\t\t\tserver_client_detach(cloop, msgtype);\n\t\t}\n\t\treturn (CMD_RETURN_STOP);\n\t}\n\n\tif (args_has(args, 'a')) {\n\t\tTAILQ_FOREACH(cloop, &clients, entry) {\n\t\t\tif (cloop->session != NULL && cloop != c)\n\t\t\t\tserver_client_detach(cloop, msgtype);\n\t\t}\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tserver_client_detach(c, msgtype);\n\treturn (CMD_RETURN_STOP);\n}\n"
        },
        {
          "name": "cmd-display-message.c",
          "type": "blob",
          "size": 2.365234375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Tiago Cunha <me@tiagocunha.org>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <time.h>\n\n#include \"tmux.h\"\n\n/*\n * Displays a message in the status line.\n */\n\n#define DISPLAY_MESSAGE_TEMPLATE\t\t\t\\\n\t\"[#{session_name}] #{window_index}:\"\t\t\\\n\t\"#{window_name}, current pane #{pane_index} \"\t\\\n\t\"- (%H:%M %d-%b-%y)\"\n\nenum cmd_retval\t cmd_display_message_exec(struct cmd *, struct cmd_q *);\n\nconst struct cmd_entry cmd_display_message_entry = {\n\t.name = \"display-message\",\n\t.alias = \"display\",\n\n\t.args = { \"c:pt:F:\", 0, 1 },\n\t.usage = \"[-p] [-c target-client] [-F format] \"\n\t\t CMD_TARGET_PANE_USAGE \" [message]\",\n\n\t.cflag = CMD_CLIENT_CANFAIL,\n\t.tflag = CMD_PANE,\n\n\t.flags = 0,\n\t.exec = cmd_display_message_exec\n};\n\nenum cmd_retval\ncmd_display_message_exec(struct cmd *self, struct cmd_q *cmdq)\n{\n\tstruct args\t\t*args = self->args;\n\tstruct client\t\t*c = cmdq->state.c;\n\tstruct session\t\t*s = cmdq->state.tflag.s;\n\tstruct winlink\t\t*wl = cmdq->state.tflag.wl;\n\tstruct window_pane\t*wp = cmdq->state.tflag.wp;\n\tconst char\t\t*template;\n\tchar\t\t\t*msg;\n\tstruct format_tree\t*ft;\n\n\tif (args_has(args, 'F') && args->argc != 0) {\n\t\tcmdq_error(cmdq, \"only one of -F or argument must be given\");\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\ttemplate = args_get(args, 'F');\n\tif (args->argc != 0)\n\t\ttemplate = args->argv[0];\n\tif (template == NULL)\n\t\ttemplate = DISPLAY_MESSAGE_TEMPLATE;\n\n\tft = format_create(cmdq, 0);\n\tformat_defaults(ft, c, s, wl, wp);\n\n\tmsg = format_expand_time(ft, template, time(NULL));\n\tif (args_has(self->args, 'p'))\n\t\tcmdq_print(cmdq, \"%s\", msg);\n\telse\n\t\tstatus_message_set(c, \"%s\", msg);\n\tfree(msg);\n\tformat_free(ft);\n\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-display-panes.c",
          "type": "blob",
          "size": 1.3408203125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include \"tmux.h\"\n\n/*\n * Display panes on a client.\n */\n\nenum cmd_retval\t cmd_display_panes_exec(struct cmd *, struct cmd_q *);\n\nconst struct cmd_entry cmd_display_panes_entry = {\n\t.name = \"display-panes\",\n\t.alias = \"displayp\",\n\n\t.args = { \"t:\", 0, 0 },\n\t.usage = CMD_TARGET_CLIENT_USAGE,\n\n\t.tflag = CMD_CLIENT,\n\n\t.flags = 0,\n\t.exec = cmd_display_panes_exec\n};\n\nenum cmd_retval\ncmd_display_panes_exec(__unused struct cmd *self, struct cmd_q *cmdq)\n{\n\tserver_set_identify(cmdq->state.c);\n\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-find-window.c",
          "type": "blob",
          "size": 6.2216796875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <fnmatch.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * Find window containing text.\n */\n\n#define FIND_WINDOW_TEMPLATE\t\t\t\t\t\\\n\t\"#{window_index}: #{window_name} \"\t\t\t\\\n\t\"[#{window_width}x#{window_height}] \"\t\t\t\\\n\t\"(#{window_panes} panes) #{window_find_matches}\"\n\nenum cmd_retval\t cmd_find_window_exec(struct cmd *, struct cmd_q *);\n\nvoid\tcmd_find_window_callback(struct window_choose_data *);\n\n/* Flags for determining matching behavior. */\n#define CMD_FIND_WINDOW_BY_TITLE   0x1\n#define CMD_FIND_WINDOW_BY_CONTENT 0x2\n#define CMD_FIND_WINDOW_BY_NAME    0x4\n\n#define CMD_FIND_WINDOW_ALL\t\t\\\n\t(CMD_FIND_WINDOW_BY_TITLE |\t\\\n\t CMD_FIND_WINDOW_BY_CONTENT |\t\\\n\t CMD_FIND_WINDOW_BY_NAME)\n\nconst struct cmd_entry cmd_find_window_entry = {\n\t.name = \"find-window\",\n\t.alias = \"findw\",\n\n\t.args = { \"F:CNt:T\", 1, 4 },\n\t.usage = \"[-CNT] [-F format] \" CMD_TARGET_WINDOW_USAGE \" match-string\",\n\n\t.tflag = CMD_WINDOW,\n\n\t.flags = 0,\n\t.exec = cmd_find_window_exec\n};\n\nstruct cmd_find_window_data {\n\tstruct winlink\t*wl;\n\tchar\t\t*list_ctx;\n\tu_int\t\t pane_id;\n\tTAILQ_ENTRY(cmd_find_window_data) entry;\n};\nTAILQ_HEAD(cmd_find_window_list, cmd_find_window_data);\n\nu_int\tcmd_find_window_match_flags(struct args *);\nvoid\tcmd_find_window_match(struct cmd_find_window_list *, int,\n\t    struct winlink *, const char *, const char *);\n\nu_int\ncmd_find_window_match_flags(struct args *args)\n{\n\tu_int\tmatch_flags = 0;\n\n\t/* Turn on flags based on the options. */\n\tif (args_has(args, 'T'))\n\t\tmatch_flags |= CMD_FIND_WINDOW_BY_TITLE;\n\tif (args_has(args, 'C'))\n\t\tmatch_flags |= CMD_FIND_WINDOW_BY_CONTENT;\n\tif (args_has(args, 'N'))\n\t\tmatch_flags |= CMD_FIND_WINDOW_BY_NAME;\n\n\t/* If none of the flags were set, default to matching anything. */\n\tif (match_flags == 0)\n\t\tmatch_flags = CMD_FIND_WINDOW_ALL;\n\n\treturn (match_flags);\n}\n\nvoid\ncmd_find_window_match(struct cmd_find_window_list *find_list,\n    int match_flags, struct winlink *wl, const char *str,\n    const char *searchstr)\n{\n\tstruct cmd_find_window_data\t*find_data;\n\tstruct window_pane\t\t*wp;\n\tu_int\t\t\t\t i, line;\n\tchar\t\t\t\t*sres;\n\n\tfind_data = xcalloc(1, sizeof *find_data);\n\n\ti = 0;\n\tTAILQ_FOREACH(wp, &wl->window->panes, entry) {\n\t\ti++;\n\n\t\tif ((match_flags & CMD_FIND_WINDOW_BY_NAME) &&\n\t\t    fnmatch(searchstr, wl->window->name, 0) == 0) {\n\t\t\tfind_data->list_ctx = xstrdup(\"\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((match_flags & CMD_FIND_WINDOW_BY_TITLE) &&\n\t\t    fnmatch(searchstr, wp->base.title, 0) == 0) {\n\t\t\txasprintf(&find_data->list_ctx,\n\t\t\t    \"pane %u title: \\\"%s\\\"\", i - 1, wp->base.title);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (match_flags & CMD_FIND_WINDOW_BY_CONTENT &&\n\t\t    (sres = window_pane_search(wp, str, &line)) != NULL) {\n\t\t\txasprintf(&find_data->list_ctx,\n\t\t\t    \"pane %u line %u: \\\"%s\\\"\", i - 1, line + 1, sres);\n\t\t\tfree(sres);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (find_data->list_ctx != NULL) {\n\t\tfind_data->wl = wl;\n\t\tfind_data->pane_id = i - 1;\n\t\tTAILQ_INSERT_TAIL(find_list, find_data, entry);\n\t} else\n\t\tfree(find_data);\n}\n\nenum cmd_retval\ncmd_find_window_exec(struct cmd *self, struct cmd_q *cmdq)\n{\n\tstruct args\t\t\t*args = self->args;\n\tstruct client\t\t\t*c = cmdq->state.c;\n\tstruct window_choose_data\t*cdata;\n\tstruct session\t\t\t*s = cmdq->state.tflag.s;\n\tstruct winlink\t\t\t*wl = cmdq->state.tflag.wl, *wm;\n\tstruct cmd_find_window_list\t find_list;\n\tstruct cmd_find_window_data\t*find_data;\n\tstruct cmd_find_window_data\t*find_data1;\n\tchar\t\t\t\t*str, *searchstr;\n\tconst char\t\t\t*template;\n\tu_int\t\t\t\t i, match_flags;\n\n\tif (c == NULL) {\n\t\tcmdq_error(cmdq, \"no client available\");\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\tif ((template = args_get(args, 'F')) == NULL)\n\t\ttemplate = FIND_WINDOW_TEMPLATE;\n\n\tmatch_flags = cmd_find_window_match_flags(args);\n\tstr = args->argv[0];\n\n\tTAILQ_INIT(&find_list);\n\n\txasprintf(&searchstr, \"*%s*\", str);\n\tRB_FOREACH(wm, winlinks, &s->windows)\n\t    cmd_find_window_match(&find_list, match_flags, wm, str, searchstr);\n\tfree(searchstr);\n\n\tif (TAILQ_EMPTY(&find_list)) {\n\t\tcmdq_error(cmdq, \"no windows matching: %s\", str);\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\tif (TAILQ_NEXT(TAILQ_FIRST(&find_list), entry) == NULL) {\n\t\tif (session_select(s, TAILQ_FIRST(&find_list)->wl->idx) == 0)\n\t\t\tserver_redraw_session(s);\n\t\trecalculate_sizes();\n\t\tgoto out;\n\t}\n\n\tif (window_pane_set_mode(wl->window->active, &window_choose_mode) != 0)\n\t\tgoto out;\n\n\ti = 0;\n\tTAILQ_FOREACH(find_data, &find_list, entry) {\n\t\tcdata = window_choose_data_create(TREE_OTHER, c, c->session);\n\t\tcdata->idx = find_data->wl->idx;\n\t\tcdata->wl = find_data->wl;\n\n\t\tcdata->ft_template = xstrdup(template);\n\t\tcdata->pane_id = find_data->pane_id;\n\n\t\tformat_add(cdata->ft, \"line\", \"%u\", i);\n\t\tformat_add(cdata->ft, \"window_find_matches\", \"%s\",\n\t\t    find_data->list_ctx);\n\t\tformat_defaults(cdata->ft, NULL, s, find_data->wl, NULL);\n\n\t\twindow_choose_add(wl->window->active, cdata);\n\n\t\ti++;\n\t}\n\n\twindow_choose_ready(wl->window->active, 0, cmd_find_window_callback);\n\nout:\n\tTAILQ_FOREACH_SAFE(find_data, &find_list, entry, find_data1) {\n\t\tfree(find_data->list_ctx);\n\t\tTAILQ_REMOVE(&find_list, find_data, entry);\n\t\tfree(find_data);\n\t}\n\treturn (CMD_RETURN_NORMAL);\n}\n\nvoid\ncmd_find_window_callback(struct window_choose_data *cdata)\n{\n\tstruct session\t\t*s;\n\tstruct window_pane\t*wp;\n\n\tif (cdata == NULL)\n\t\treturn;\n\n\ts = cdata->start_session;\n\tif (!session_alive(s))\n\t\treturn;\n\n\twp = window_pane_at_index(cdata->wl->window, cdata->pane_id);\n\tif (wp != NULL && window_pane_visible(wp))\n\t\twindow_set_active_pane(cdata->wl->window, wp);\n\n\tif (session_select(s, cdata->idx) == 0) {\n\t\tserver_redraw_session(s);\n\t\trecalculate_sizes();\n\t}\n}\n"
        },
        {
          "name": "cmd-find.c",
          "type": "blob",
          "size": 29.646484375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2015 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <fnmatch.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\nstruct session\t*cmd_find_try_TMUX(struct client *, struct window *);\nint\t\t cmd_find_client_better(struct client *, struct client *);\nstruct client\t*cmd_find_best_client(struct client **, u_int);\nint\t\t cmd_find_session_better(struct session *, struct session *,\n\t\t     int);\nstruct session\t*cmd_find_best_session(struct session **, u_int, int);\nint\t\t cmd_find_best_session_with_window(struct cmd_find_state *);\nint\t\t cmd_find_best_winlink_with_window(struct cmd_find_state *);\n\nint\t\t cmd_find_current_session_with_client(struct cmd_find_state *);\nint\t\t cmd_find_current_session(struct cmd_find_state *);\nstruct client\t*cmd_find_current_client(struct cmd_q *);\n\nconst char\t*cmd_find_map_table(const char *[][2], const char *);\n\nint\tcmd_find_get_session(struct cmd_find_state *, const char *);\nint\tcmd_find_get_window(struct cmd_find_state *, const char *);\nint\tcmd_find_get_window_with_session(struct cmd_find_state *, const char *);\nint\tcmd_find_get_window_with_pane(struct cmd_find_state *);\nint\tcmd_find_get_pane(struct cmd_find_state *, const char *);\nint\tcmd_find_get_pane_with_session(struct cmd_find_state *, const char *);\nint\tcmd_find_get_pane_with_window(struct cmd_find_state *, const char *);\n\nconst char *cmd_find_session_table[][2] = {\n\t{ NULL, NULL }\n};\nconst char *cmd_find_window_table[][2] = {\n\t{ \"{start}\", \"^\" },\n\t{ \"{last}\", \"!\" },\n\t{ \"{end}\", \"$\" },\n\t{ \"{next}\", \"+\" },\n\t{ \"{previous}\", \"-\" },\n\t{ NULL, NULL }\n};\nconst char *cmd_find_pane_table[][2] = {\n\t{ \"{last}\", \"!\" },\n\t{ \"{next}\", \"+\" },\n\t{ \"{previous}\", \"-\" },\n\t{ \"{top}\", \"top\" },\n\t{ \"{bottom}\", \"bottom\" },\n\t{ \"{left}\", \"left\" },\n\t{ \"{right}\", \"right\" },\n\t{ \"{top-left}\", \"top-left\" },\n\t{ \"{top-right}\", \"top-right\" },\n\t{ \"{bottom-left}\", \"bottom-left\" },\n\t{ \"{bottom-right}\", \"bottom-right\" },\n\t{ \"{up-of}\", \"{up-of}\" },\n\t{ \"{down-of}\", \"{down-of}\" },\n\t{ \"{left-of}\", \"{left-of}\" },\n\t{ \"{right-of}\", \"{right-of}\" },\n\t{ NULL, NULL }\n};\n\n/* Get session from TMUX if present. */\nstruct session *\ncmd_find_try_TMUX(struct client *c, struct window *w)\n{\n\tstruct environ_entry\t*envent;\n\tchar\t\t\t tmp[256];\n\tlong long\t\t pid;\n\tu_int\t\t\t session;\n\tstruct session\t\t*s;\n\n\tenvent = environ_find(c->environ, \"TMUX\");\n\tif (envent == NULL)\n\t\treturn (NULL);\n\n\tif (sscanf(envent->value, \"%255[^,],%lld,%d\", tmp, &pid, &session) != 3)\n\t\treturn (NULL);\n\tif (pid != getpid())\n\t\treturn (NULL);\n\tlog_debug(\"client %p TMUX is %s (session @%u)\", c, envent->value,\n\t    session);\n\n\ts = session_find_by_id(session);\n\tif (s == NULL || (w != NULL && !session_has(s, w)))\n\t\treturn (NULL);\n\treturn (s);\n}\n\n/* Is this client better? */\nint\ncmd_find_client_better(struct client *c, struct client *than)\n{\n\tif (than == NULL)\n\t\treturn (1);\n\treturn (timercmp(&c->activity_time, &than->activity_time, >));\n}\n\n/* Find best client from a list, or all if list is NULL. */\nstruct client *\ncmd_find_best_client(struct client **clist, u_int csize)\n{\n\tstruct client\t*c_loop, *c;\n\tu_int\t\t i;\n\n\tc = NULL;\n\tif (clist != NULL) {\n\t\tfor (i = 0; i < csize; i++) {\n\t\t\tif (clist[i]->session == NULL)\n\t\t\t\tcontinue;\n\t\t\tif (cmd_find_client_better(clist[i], c))\n\t\t\t\tc = clist[i];\n\t\t}\n\t} else {\n\t\tTAILQ_FOREACH(c_loop, &clients, entry) {\n\t\t\tif (c_loop->session == NULL)\n\t\t\t\tcontinue;\n\t\t\tif (cmd_find_client_better(c_loop, c))\n\t\t\t\tc = c_loop;\n\t\t}\n\t}\n\treturn (c);\n}\n\n/* Is this session better? */\nint\ncmd_find_session_better(struct session *s, struct session *than, int flags)\n{\n\tint\tattached;\n\n\tif (than == NULL)\n\t\treturn (1);\n\tif (flags & CMD_FIND_PREFER_UNATTACHED) {\n\t\tattached = (~than->flags & SESSION_UNATTACHED);\n\t\tif (attached && (s->flags & SESSION_UNATTACHED))\n\t\t\treturn (1);\n\t\telse if (!attached && (~s->flags & SESSION_UNATTACHED))\n\t\t\treturn (0);\n\t}\n\treturn (timercmp(&s->activity_time, &than->activity_time, >));\n}\n\n/* Find best session from a list, or all if list is NULL. */\nstruct session *\ncmd_find_best_session(struct session **slist, u_int ssize, int flags)\n{\n\tstruct session\t *s_loop, *s;\n\tu_int\t\t  i;\n\n\ts = NULL;\n\tif (slist != NULL) {\n\t\tfor (i = 0; i < ssize; i++) {\n\t\t\tif (cmd_find_session_better(slist[i], s, flags))\n\t\t\t\ts = slist[i];\n\t\t}\n\t} else {\n\t\tRB_FOREACH(s_loop, sessions, &sessions) {\n\t\t\tif (cmd_find_session_better(s_loop, s, flags))\n\t\t\t\ts = s_loop;\n\t\t}\n\t}\n\treturn (s);\n}\n\n/* Find best session and winlink for window. */\nint\ncmd_find_best_session_with_window(struct cmd_find_state *fs)\n{\n\tstruct session\t**slist = NULL;\n\tu_int\t\t  ssize;\n\tstruct session\t *s;\n\n\tif (fs->cmdq != NULL && fs->cmdq->client != NULL) {\n\t\tfs->s = cmd_find_try_TMUX(fs->cmdq->client, fs->w);\n\t\tif (fs->s != NULL)\n\t\t\treturn (cmd_find_best_winlink_with_window(fs));\n\t}\n\n\tssize = 0;\n\tRB_FOREACH(s, sessions, &sessions) {\n\t\tif (!session_has(s, fs->w))\n\t\t\tcontinue;\n\t\tslist = xreallocarray(slist, ssize + 1, sizeof *slist);\n\t\tslist[ssize++] = s;\n\t}\n\tif (ssize == 0)\n\t\tgoto fail;\n\tfs->s = cmd_find_best_session(slist, ssize, fs->flags);\n\tif (fs->s == NULL)\n\t\tgoto fail;\n\tfree(slist);\n\treturn (cmd_find_best_winlink_with_window(fs));\n\nfail:\n\tfree(slist);\n\treturn (-1);\n}\n\n/*\n * Find the best winlink for a window (the current if it contains the pane,\n * otherwise the first).\n */\nint\ncmd_find_best_winlink_with_window(struct cmd_find_state *fs)\n{\n\tstruct winlink\t *wl, *wl_loop;\n\n\twl = NULL;\n\tif (fs->s->curw->window == fs->w)\n\t\twl = fs->s->curw;\n\telse {\n\t\tRB_FOREACH(wl_loop, winlinks, &fs->s->windows) {\n\t\t\tif (wl_loop->window == fs->w) {\n\t\t\t\twl = wl_loop;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (wl == NULL)\n\t\treturn (-1);\n\tfs->wl = wl;\n\tfs->idx = fs->wl->idx;\n\treturn (0);\n}\n\n/* Find current session when we have an unattached client. */\nint\ncmd_find_current_session_with_client(struct cmd_find_state *fs)\n{\n\tstruct window_pane\t*wp;\n\n\t/*\n\t * If this is running in a pane, we can use that to limit the list of\n\t * sessions to those containing that pane (we still use the current\n\t * window in the best session).\n\t */\n\tif (fs->cmdq != NULL && fs->cmdq->client->tty.path != NULL) {\n\t\tRB_FOREACH(wp, window_pane_tree, &all_window_panes) {\n\t\t\tif (strcmp(wp->tty, fs->cmdq->client->tty.path) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t} else\n\t\twp = NULL;\n\n\t/* Not running in a pane. We know nothing. Find the best session. */\n\tif (wp == NULL)\n\t\tgoto unknown_pane;\n\n\t/* Find the best session and winlink containing this pane. */\n\tfs->w = wp->window;\n\tif (cmd_find_best_session_with_window(fs) != 0) {\n\t\tif (wp != NULL) {\n\t\t\t/*\n\t\t\t * The window may have been destroyed but the pane\n\t\t\t * still on all_window_panes due to something else\n\t\t\t * holding a reference.\n\t\t\t */\n\t\t\tgoto unknown_pane;\n\t\t}\n\t\treturn (-1);\n\t}\n\n\t/* Use the current window and pane from this session. */\n\tfs->wl = fs->s->curw;\n\tfs->idx = fs->wl->idx;\n\tfs->w = fs->wl->window;\n\tfs->wp = fs->w->active;\n\n\treturn (0);\n\nunknown_pane:\n\tfs->s = NULL;\n\tif (fs->cmdq != NULL)\n\t\tfs->s = cmd_find_try_TMUX(fs->cmdq->client, NULL);\n\tif (fs->s == NULL)\n\t\tfs->s = cmd_find_best_session(NULL, 0, fs->flags);\n\tif (fs->s == NULL)\n\t\treturn (-1);\n\tfs->wl = fs->s->curw;\n\tfs->idx = fs->wl->idx;\n\tfs->w = fs->wl->window;\n\tfs->wp = fs->w->active;\n\n\treturn (0);\n}\n\n/*\n * Work out the best current state. If this function succeeds, the state is\n * guaranteed to be completely filled in.\n */\nint\ncmd_find_current_session(struct cmd_find_state *fs)\n{\n\t/* If we know the current client, use it. */\n\tif (fs->cmdq != NULL && fs->cmdq->client != NULL) {\n\t\tlog_debug(\"%s: have client %p%s\", __func__, fs->cmdq->client,\n\t\t    fs->cmdq->client->session == NULL ? \"\" : \" (with session)\");\n\t\tif (fs->cmdq->client->session == NULL)\n\t\t\treturn (cmd_find_current_session_with_client(fs));\n\t\tfs->s = fs->cmdq->client->session;\n\t\tfs->wl = fs->s->curw;\n\t\tfs->idx = fs->wl->idx;\n\t\tfs->w = fs->wl->window;\n\t\tfs->wp = fs->w->active;\n\t\treturn (0);\n\t}\n\n\t/* We know nothing, find the best session and client. */\n\tfs->s = cmd_find_best_session(NULL, 0, fs->flags);\n\tif (fs->s == NULL)\n\t\treturn (-1);\n\tfs->wl = fs->s->curw;\n\tfs->idx = fs->wl->idx;\n\tfs->w = fs->wl->window;\n\tfs->wp = fs->w->active;\n\n\treturn (0);\n}\n\n/* Work out the best current client. */\nstruct client *\ncmd_find_current_client(struct cmd_q *cmdq)\n{\n\tstruct cmd_find_state\t current;\n\tstruct session\t\t*s;\n\tstruct client\t\t*c, **clist = NULL;\n\tu_int\t\t \t csize;\n\n\t/* If the queue client has a session, use it. */\n\tif (cmdq->client != NULL && cmdq->client->session != NULL) {\n\t\tlog_debug(\"%s: using cmdq %p client %p\", __func__, cmdq,\n\t\t    cmdq->client);\n\t\treturn (cmdq->client);\n\t}\n\n\t/* Otherwise find the current session. */\n\tcmd_find_clear_state(&current, cmdq, 0);\n\tif (cmd_find_current_session(&current) != 0)\n\t\treturn (NULL);\n\n\t/* If it is attached, find the best of it's clients. */\n\ts = current.s;\n\tlog_debug(\"%s: current session $%u %s\", __func__, s->id, s->name);\n\tif (~s->flags & SESSION_UNATTACHED) {\n\t\tcsize = 0;\n\t\tTAILQ_FOREACH(c, &clients, entry) {\n\t\t\tif (c->session != s)\n\t\t\t\tcontinue;\n\t\t\tclist = xreallocarray(clist, csize + 1, sizeof *clist);\n\t\t\tclist[csize++] = c;\n\t\t}\n\t\tif (csize != 0) {\n\t\t\tc = cmd_find_best_client(clist, csize);\n\t\t\tif (c != NULL) {\n\t\t\t\tfree(clist);\n\t\t\t\treturn (c);\n\t\t\t}\n\t\t}\n\t\tfree(clist);\n\t}\n\n\t/* Otherwise pick best of all clients. */\n\treturn (cmd_find_best_client(NULL, 0));\n}\n\n/* Maps string in table. */\nconst char *\ncmd_find_map_table(const char *table[][2], const char *s)\n{\n\tu_int\ti;\n\n\tfor (i = 0; table[i][0] != NULL; i++) {\n\t\tif (strcmp(s, table[i][0]) == 0)\n\t\t\treturn (table[i][1]);\n\t}\n\treturn (s);\n}\n\n/* Find session from string. Fills in s. */\nint\ncmd_find_get_session(struct cmd_find_state *fs, const char *session)\n{\n\tstruct session\t*s, *s_loop;\n\tstruct client\t*c;\n\n\tlog_debug(\"%s: %s\", __func__, session);\n\n\t/* Check for session ids starting with $. */\n\tif (*session == '$') {\n\t\tfs->s = session_find_by_id_str(session);\n\t\tif (fs->s == NULL)\n\t\t\treturn (-1);\n\t\treturn (0);\n\t}\n\n\t/* Look for exactly this session. */\n\tfs->s = session_find(session);\n\tif (fs->s != NULL)\n\t\treturn (0);\n\n\t/* Look for as a client. */\n\tc = cmd_find_client(NULL, session, 1);\n\tif (c != NULL && c->session != NULL) {\n\t\tfs->s = c->session;\n\t\treturn (0);\n\t}\n\n\t/* Stop now if exact only. */\n\tif (fs->flags & CMD_FIND_EXACT_SESSION)\n\t\treturn (-1);\n\n\t/* Otherwise look for prefix. */\n\ts = NULL;\n\tRB_FOREACH(s_loop, sessions, &sessions) {\n\t\tif (strncmp(session, s_loop->name, strlen(session)) == 0) {\n\t\t\tif (s != NULL)\n\t\t\t\treturn (-1);\n\t\t\ts = s_loop;\n\t\t}\n\t}\n\tif (s != NULL) {\n\t\tfs->s = s;\n\t\treturn (0);\n\t}\n\n\t/* Then as a pattern. */\n\ts = NULL;\n\tRB_FOREACH(s_loop, sessions, &sessions) {\n\t\tif (fnmatch(session, s_loop->name, 0) == 0) {\n\t\t\tif (s != NULL)\n\t\t\t\treturn (-1);\n\t\t\ts = s_loop;\n\t\t}\n\t}\n\tif (s != NULL) {\n\t\tfs->s = s;\n\t\treturn (0);\n\t}\n\n\treturn (-1);\n}\n\n/* Find window from string. Fills in s, wl, w. */\nint\ncmd_find_get_window(struct cmd_find_state *fs, const char *window)\n{\n\tlog_debug(\"%s: %s\", __func__, window);\n\n\t/* Check for window ids starting with @. */\n\tif (*window == '@') {\n\t\tfs->w = window_find_by_id_str(window);\n\t\tif (fs->w == NULL)\n\t\t\treturn (-1);\n\t\treturn (cmd_find_best_session_with_window(fs));\n\t}\n\n\t/* Not a window id, so use the current session. */\n\tfs->s = fs->current->s;\n\n\t/* We now only need to find the winlink in this session. */\n\tif (cmd_find_get_window_with_session(fs, window) == 0)\n\t\treturn (0);\n\n\t/* Otherwise try as a session itself. */\n\tif (cmd_find_get_session(fs, window) == 0) {\n\t\tfs->wl = fs->s->curw;\n\t\tfs->w = fs->wl->window;\n\t\tif (~fs->flags & CMD_FIND_WINDOW_INDEX)\n\t\t\tfs->idx = fs->wl->idx;\n\t\treturn (0);\n\t}\n\n\treturn (-1);\n}\n\n/*\n * Find window from string, assuming it is in given session. Needs s, fills in\n * wl and w.\n */\nint\ncmd_find_get_window_with_session(struct cmd_find_state *fs, const char *window)\n{\n\tstruct winlink\t*wl;\n\tconst char\t*errstr;\n\tint\t\t idx, n, exact;\n\tstruct session\t*s;\n\n\tlog_debug(\"%s: %s\", __func__, window);\n\texact = (fs->flags & CMD_FIND_EXACT_WINDOW);\n\n\t/*\n\t * Start with the current window as the default. So if only an index is\n\t * found, the window will be the current.\n\t */\n\tfs->wl = fs->s->curw;\n\tfs->w = fs->wl->window;\n\n\t/* Check for window ids starting with @. */\n\tif (*window == '@') {\n\t\tfs->w = window_find_by_id_str(window);\n\t\tif (fs->w == NULL || !session_has(fs->s, fs->w))\n\t\t\treturn (-1);\n\t\treturn (cmd_find_best_winlink_with_window(fs));\n\t}\n\n\t/* Try as an offset. */\n\tif (!exact && (window[0] == '+' || window[0] == '-')) {\n\t\tif (window[1] != '\\0')\n\t\t\tn = strtonum(window + 1, 1, INT_MAX, NULL);\n\t\telse\n\t\t\tn = 1;\n\t\ts = fs->s;\n\t\tif (fs->flags & CMD_FIND_WINDOW_INDEX) {\n\t\t\tif (window[0] == '+') {\n\t\t\t\tif (INT_MAX - s->curw->idx < n)\n\t\t\t\t\treturn (-1);\n\t\t\t\tfs->idx = s->curw->idx + n;\n\t\t\t} else {\n\t\t\t\tif (n < s->curw->idx)\n\t\t\t\t\treturn (-1);\n\t\t\t\tfs->idx = s->curw->idx - n;\n\t\t\t}\n\t\t\treturn (0);\n\t\t}\n\t\tif (window[0] == '+')\n\t\t\tfs->wl = winlink_next_by_number(s->curw, s, n);\n\t\telse\n\t\t\tfs->wl = winlink_previous_by_number(s->curw, s, n);\n\t\tif (fs->wl != NULL) {\n\t\t\tfs->idx = fs->wl->idx;\n\t\t\tfs->w = fs->wl->window;\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\t/* Try special characters. */\n\tif (!exact) {\n\t\tif (strcmp(window, \"!\") == 0) {\n\t\t\tfs->wl = TAILQ_FIRST(&fs->s->lastw);\n\t\t\tif (fs->wl == NULL)\n\t\t\t\treturn (-1);\n\t\t\tfs->idx = fs->wl->idx;\n\t\t\tfs->w = fs->wl->window;\n\t\t\treturn (0);\n\t\t} else if (strcmp(window, \"^\") == 0) {\n\t\t\tfs->wl = RB_MIN(winlinks, &fs->s->windows);\n\t\t\tif (fs->wl == NULL)\n\t\t\t\treturn (-1);\n\t\t\tfs->idx = fs->wl->idx;\n\t\t\tfs->w = fs->wl->window;\n\t\t\treturn (0);\n\t\t} else if (strcmp(window, \"$\") == 0) {\n\t\t\tfs->wl = RB_MAX(winlinks, &fs->s->windows);\n\t\t\tif (fs->wl == NULL)\n\t\t\t\treturn (-1);\n\t\t\tfs->idx = fs->wl->idx;\n\t\t\tfs->w = fs->wl->window;\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\t/* First see if this is a valid window index in this session. */\n\tif (window[0] != '+' && window[0] != '-') {\n\t\tidx = strtonum(window, 0, INT_MAX, &errstr);\n\t\tif (errstr == NULL) {\n\t\t\tif (fs->flags & CMD_FIND_WINDOW_INDEX) {\n\t\t\t\tfs->idx = idx;\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tfs->wl = winlink_find_by_index(&fs->s->windows, idx);\n\t\t\tif (fs->wl != NULL) {\n\t\t\t\tfs->w = fs->wl->window;\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Look for exact matches, error if more than one. */\n\tfs->wl = NULL;\n\tRB_FOREACH(wl, winlinks, &fs->s->windows) {\n\t\tif (strcmp(window, wl->window->name) == 0) {\n\t\t\tif (fs->wl != NULL)\n\t\t\t\treturn (-1);\n\t\t\tfs->wl = wl;\n\t\t}\n\t}\n\tif (fs->wl != NULL) {\n\t\tfs->idx = fs->wl->idx;\n\t\tfs->w = fs->wl->window;\n\t\treturn (0);\n\t}\n\n\t/* Stop now if exact only. */\n\tif (exact)\n\t\treturn (-1);\n\n\t/* Try as the start of a window name, error if multiple. */\n\tfs->wl = NULL;\n\tRB_FOREACH(wl, winlinks, &fs->s->windows) {\n\t\tif (strncmp(window, wl->window->name, strlen(window)) == 0) {\n\t\t\tif (fs->wl != NULL)\n\t\t\t\treturn (-1);\n\t\t\tfs->wl = wl;\n\t\t}\n\t}\n\tif (fs->wl != NULL) {\n\t\tfs->idx = fs->wl->idx;\n\t\tfs->w = fs->wl->window;\n\t\treturn (0);\n\t}\n\n\t/* Now look for pattern matches, again error if multiple. */\n\tfs->wl = NULL;\n\tRB_FOREACH(wl, winlinks, &fs->s->windows) {\n\t\tif (fnmatch(window, wl->window->name, 0) == 0) {\n\t\t\tif (fs->wl != NULL)\n\t\t\t\treturn (-1);\n\t\t\tfs->wl = wl;\n\t\t}\n\t}\n\tif (fs->wl != NULL) {\n\t\tfs->idx = fs->wl->idx;\n\t\tfs->w = fs->wl->window;\n\t\treturn (0);\n\t}\n\n\treturn (-1);\n}\n\n/* Find window from given pane. Needs wp, fills in s and wl and w. */\nint\ncmd_find_get_window_with_pane(struct cmd_find_state *fs)\n{\n\tlog_debug(\"%s\", __func__);\n\n\tfs->w = fs->wp->window;\n\treturn (cmd_find_best_session_with_window(fs));\n}\n\n/* Find pane from string. Fills in s, wl, w, wp. */\nint\ncmd_find_get_pane(struct cmd_find_state *fs, const char *pane)\n{\n\tlog_debug(\"%s: %s\", __func__, pane);\n\n\t/* Check for pane ids starting with %. */\n\tif (*pane == '%') {\n\t\tfs->wp = window_pane_find_by_id_str(pane);\n\t\tif (fs->wp == NULL)\n\t\t\treturn (-1);\n\t\tfs->w = fs->wp->window;\n\t\treturn (cmd_find_best_session_with_window(fs));\n\t}\n\n\t/* Not a pane id, so try the current session and window. */\n\tfs->s = fs->current->s;\n\tfs->wl = fs->current->wl;\n\tfs->idx = fs->current->idx;\n\tfs->w = fs->current->w;\n\n\t/* We now only need to find the pane in this window. */\n\tif (cmd_find_get_pane_with_window(fs, pane) == 0)\n\t\treturn (0);\n\n\t/* Otherwise try as a window itself (this will also try as session). */\n\tif (cmd_find_get_window(fs, pane) == 0) {\n\t\tfs->wp = fs->w->active;\n\t\treturn (0);\n\t}\n\n\treturn (-1);\n}\n\n/*\n * Find pane from string, assuming it is in given session. Needs s, fills in wl\n * and w and wp.\n */\nint\ncmd_find_get_pane_with_session(struct cmd_find_state *fs, const char *pane)\n{\n\tlog_debug(\"%s: %s\", __func__, pane);\n\n\t/* Check for pane ids starting with %. */\n\tif (*pane == '%') {\n\t\tfs->wp = window_pane_find_by_id_str(pane);\n\t\tif (fs->wp == NULL)\n\t\t\treturn (-1);\n\t\tfs->w = fs->wp->window;\n\t\treturn (cmd_find_best_winlink_with_window(fs));\n\t}\n\n\t/* Otherwise use the current window. */\n\tfs->wl = fs->s->curw;\n\tfs->idx = fs->wl->idx;\n\tfs->w = fs->wl->window;\n\n\t/* Now we just need to look up the pane. */\n\treturn (cmd_find_get_pane_with_window(fs, pane));\n}\n\n/*\n * Find pane from string, assuming it is in the given window. Needs w, fills in\n * wp.\n */\nint\ncmd_find_get_pane_with_window(struct cmd_find_state *fs, const char *pane)\n{\n\tconst char\t\t*errstr;\n\tint\t\t\t idx;\n\tstruct window_pane\t*wp;\n\tu_int\t\t\t n;\n\n\tlog_debug(\"%s: %s\", __func__, pane);\n\n\t/* Check for pane ids starting with %. */\n\tif (*pane == '%') {\n\t\tfs->wp = window_pane_find_by_id_str(pane);\n\t\tif (fs->wp == NULL || fs->wp->window != fs->w)\n\t\t\treturn (-1);\n\t\treturn (0);\n\t}\n\n\t/* Try special characters. */\n\tif (strcmp(pane, \"!\") == 0) {\n\t\tif (fs->w->last == NULL)\n\t\t\treturn (-1);\n\t\tfs->wp = fs->w->last;\n\t\treturn (0);\n\t} else if (strcmp(pane, \"{up-of}\") == 0) {\n\t\tfs->wp = window_pane_find_up(fs->w->active);\n\t\tif (fs->wp == NULL)\n\t\t\treturn (-1);\n\t\treturn (0);\n\t} else if (strcmp(pane, \"{down-of}\") == 0) {\n\t\tfs->wp = window_pane_find_down(fs->w->active);\n\t\tif (fs->wp == NULL)\n\t\t\treturn (-1);\n\t\treturn (0);\n\t} else if (strcmp(pane, \"{left-of}\") == 0) {\n\t\tfs->wp = window_pane_find_left(fs->w->active);\n\t\tif (fs->wp == NULL)\n\t\t\treturn (-1);\n\t\treturn (0);\n\t} else if (strcmp(pane, \"{right-of}\") == 0) {\n\t\tfs->wp = window_pane_find_right(fs->w->active);\n\t\tif (fs->wp == NULL)\n\t\t\treturn (-1);\n\t\treturn (0);\n\t}\n\n\t/* Try as an offset. */\n\tif (pane[0] == '+' || pane[0] == '-') {\n\t\tif (pane[1] != '\\0')\n\t\t\tn = strtonum(pane + 1, 1, INT_MAX, NULL);\n\t\telse\n\t\t\tn = 1;\n\t\twp = fs->w->active;\n\t\tif (pane[0] == '+')\n\t\t\tfs->wp = window_pane_next_by_number(fs->w, wp, n);\n\t\telse\n\t\t\tfs->wp = window_pane_previous_by_number(fs->w, wp, n);\n\t\tif (fs->wp != NULL)\n\t\t\treturn (0);\n\t}\n\n\t/* Get pane by index. */\n\tidx = strtonum(pane, 0, INT_MAX, &errstr);\n\tif (errstr == NULL) {\n\t\tfs->wp = window_pane_at_index(fs->w, idx);\n\t\tif (fs->wp != NULL)\n\t\t\treturn (0);\n\t}\n\n\t/* Try as a description. */\n\tfs->wp = window_find_string(fs->w, pane);\n\tif (fs->wp != NULL)\n\t\treturn (0);\n\n\treturn (-1);\n}\n\n/* Clear state. */\nvoid\ncmd_find_clear_state(struct cmd_find_state *fs, struct cmd_q *cmdq, int flags)\n{\n\tmemset(fs, 0, sizeof *fs);\n\n\tfs->cmdq = cmdq;\n\tfs->flags = flags;\n\n\tfs->idx = -1;\n}\n\n/* Check if a state if valid. */\nint\ncmd_find_valid_state(struct cmd_find_state *fs)\n{\n\tstruct winlink\t*wl;\n\n\tif (fs->s == NULL || fs->wl == NULL || fs->w == NULL || fs->wp == NULL)\n\t\treturn (0);\n\n\tif (!session_alive(fs->s))\n\t\treturn (0);\n\n\tRB_FOREACH(wl, winlinks, &fs->s->windows) {\n\t\tif (wl->window == fs->w && wl == fs->wl)\n\t\t\tbreak;\n\t}\n\tif (wl == NULL)\n\t\treturn (0);\n\n\tif (fs->w != fs->wl->window)\n\t\treturn (0);\n\n\tif (!window_has_pane(fs->w, fs->wp))\n\t\treturn (0);\n\treturn (window_pane_visible(fs->wp));\n}\n\n/* Copy a state. */\nvoid\ncmd_find_copy_state(struct cmd_find_state *dst, struct cmd_find_state *src)\n{\n\tdst->s = src->s;\n\tdst->wl = src->wl;\n\tdst->idx = src->idx;\n\tdst->w = src->w;\n\tdst->wp = src->wp;\n}\n\n/* Log the result. */\nvoid\ncmd_find_log_state(const char *prefix, struct cmd_find_state *fs)\n{\n\tif (fs->s != NULL)\n\t\tlog_debug(\"%s: s=$%u\", prefix, fs->s->id);\n\telse\n\t\tlog_debug(\"%s: s=none\", prefix);\n\tif (fs->wl != NULL) {\n\t\tlog_debug(\"%s: wl=%u %d w=@%u %s\", prefix, fs->wl->idx,\n\t\t    fs->wl->window == fs->w, fs->w->id, fs->w->name);\n\t} else\n\t\tlog_debug(\"%s: wl=none\", prefix);\n\tif (fs->wp != NULL)\n\t\tlog_debug(\"%s: wp=%%%u\", prefix, fs->wp->id);\n\telse\n\t\tlog_debug(\"%s: wp=none\", prefix);\n\tif (fs->idx != -1)\n\t\tlog_debug(\"%s: idx=%d\", prefix, fs->idx);\n\telse\n\t\tlog_debug(\"%s: idx=none\", prefix);\n}\n\n/* Find state from a session. */\nint\ncmd_find_from_session(struct cmd_find_state *fs, struct session *s)\n{\n\tcmd_find_clear_state(fs, NULL, 0);\n\n\tfs->s = s;\n\tfs->wl = fs->s->curw;\n\tfs->w = fs->wl->window;\n\tfs->wp = fs->w->active;\n\n\tcmd_find_log_state(__func__, fs);\n\treturn (0);\n}\n\n/* Find state from a winlink. */\nint\ncmd_find_from_winlink(struct cmd_find_state *fs, struct session *s,\n    struct winlink *wl)\n{\n\tcmd_find_clear_state(fs, NULL, 0);\n\n\tfs->s = s;\n\tfs->wl = wl;\n\tfs->w = wl->window;\n\tfs->wp = wl->window->active;\n\n\tcmd_find_log_state(__func__, fs);\n\treturn (0);\n}\n\n/* Find state from a window. */\nint\ncmd_find_from_window(struct cmd_find_state *fs, struct window *w)\n{\n\tcmd_find_clear_state(fs, NULL, 0);\n\n\tfs->w = w;\n\tif (cmd_find_best_session_with_window(fs) != 0)\n\t\treturn (-1);\n\tif (cmd_find_best_winlink_with_window(fs) != 0)\n\t\treturn (-1);\n\n\tcmd_find_log_state(__func__, fs);\n\treturn (0);\n}\n\n/* Find state from a pane. */\nint\ncmd_find_from_pane(struct cmd_find_state *fs, struct window_pane *wp)\n{\n\tif (cmd_find_from_window(fs, wp->window) != 0)\n\t\treturn (-1);\n\tfs->wp = wp;\n\n\tcmd_find_log_state(__func__, fs);\n\treturn (0);\n}\n\n/* Find current state. */\nint\ncmd_find_current(struct cmd_find_state *fs, struct cmd_q *cmdq, int flags)\n{\n\tcmd_find_clear_state(fs, cmdq, flags);\n\tif (cmd_find_current_session(fs) != 0) {\n\t\tif (~flags & CMD_FIND_QUIET)\n\t\t\tcmdq_error(cmdq, \"no current session\");\n\t\treturn (-1);\n\t}\n\treturn (0);\n}\n\n/*\n * Split target into pieces and resolve for the given type. Fills in the given\n * state. Returns 0 on success or -1 on error.\n */\nint\ncmd_find_target(struct cmd_find_state *fs, struct cmd_find_state *current,\n    struct cmd_q *cmdq, const char *target, enum cmd_find_type type, int flags)\n{\n\tstruct mouse_event\t*m;\n\tchar\t\t\t*colon, *period, *copy = NULL;\n\tconst char\t\t*session, *window, *pane;\n\n\t/* Log the arguments. */\n\tif (target == NULL)\n\t\tlog_debug(\"%s: target none, type %d\", __func__, type);\n\telse\n\t\tlog_debug(\"%s: target %s, type %d\", __func__, target, type);\n\tlog_debug(\"%s: cmdq %p, flags %#x\", __func__, cmdq, flags);\n\n\t/* Clear new state. */\n\tcmd_find_clear_state(fs, cmdq, flags);\n\n\t/* Find current state. */\n\tif (server_check_marked() && (flags & CMD_FIND_DEFAULT_MARKED))\n\t\tfs->current = &marked_pane;\n\telse if (cmd_find_valid_state(&cmdq->current))\n\t\tfs->current = &cmdq->current;\n\telse\n\t\tfs->current = current;\n\n\t/* An empty or NULL target is the current. */\n\tif (target == NULL || *target == '\\0')\n\t\tgoto current;\n\n\t/* Mouse target is a plain = or {mouse}. */\n\tif (strcmp(target, \"=\") == 0 || strcmp(target, \"{mouse}\") == 0) {\n\t\tm = &cmdq->item->mouse;\n\t\tswitch (type) {\n\t\tcase CMD_FIND_PANE:\n\t\t\tfs->wp = cmd_mouse_pane(m, &fs->s, &fs->wl);\n\t\t\tif (fs->wp != NULL)\n\t\t\t\tfs->w = fs->wl->window;\n\t\t\tbreak;\n\t\tcase CMD_FIND_WINDOW:\n\t\tcase CMD_FIND_SESSION:\n\t\t\tfs->wl = cmd_mouse_window(m, &fs->s);\n\t\t\tif (fs->wl != NULL) {\n\t\t\t\tfs->w = fs->wl->window;\n\t\t\t\tfs->wp = fs->w->active;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (fs->wp == NULL) {\n\t\t\tif (~flags & CMD_FIND_QUIET)\n\t\t\t\tcmdq_error(cmdq, \"no mouse target\");\n\t\t\tgoto error;\n\t\t}\n\t\tgoto found;\n\t}\n\n\t/* Marked target is a plain ~ or {marked}. */\n\tif (strcmp(target, \"~\") == 0 || strcmp(target, \"{marked}\") == 0) {\n\t\tif (!server_check_marked()) {\n\t\t\tif (~flags & CMD_FIND_QUIET)\n\t\t\t\tcmdq_error(cmdq, \"no marked target\");\n\t\t\tgoto error;\n\t\t}\n\t\tcmd_find_copy_state(fs, &marked_pane);\n\t\tgoto found;\n\t}\n\n\t/* Find separators if they exist. */\n\tcopy = xstrdup(target);\n\tcolon = strchr(copy, ':');\n\tif (colon != NULL)\n\t\t*colon++ = '\\0';\n\tif (colon == NULL)\n\t\tperiod = strchr(copy, '.');\n\telse\n\t\tperiod = strchr(colon, '.');\n\tif (period != NULL)\n\t\t*period++ = '\\0';\n\n\t/* Set session, window and pane parts. */\n\tsession = window = pane = NULL;\n\tif (colon != NULL && period != NULL) {\n\t\tsession = copy;\n\t\twindow = colon;\n\t\tpane = period;\n\t} else if (colon != NULL && period == NULL) {\n\t\tsession = copy;\n\t\twindow = colon;\n\t} else if (colon == NULL && period != NULL) {\n\t\twindow = copy;\n\t\tpane = period;\n\t} else {\n\t\tif (*copy == '$')\n\t\t\tsession = copy;\n\t\telse if (*copy == '@')\n\t\t\twindow = copy;\n\t\telse if (*copy == '%')\n\t\t\tpane = copy;\n\t\telse {\n\t\t\tswitch (type) {\n\t\t\tcase CMD_FIND_SESSION:\n\t\t\t\tsession = copy;\n\t\t\t\tbreak;\n\t\t\tcase CMD_FIND_WINDOW:\n\t\t\t\twindow = copy;\n\t\t\t\tbreak;\n\t\t\tcase CMD_FIND_PANE:\n\t\t\t\tpane = copy;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Set exact match flags. */\n\tif (session != NULL && *session == '=') {\n\t\tsession++;\n\t\tfs->flags |= CMD_FIND_EXACT_SESSION;\n\t}\n\tif (window != NULL && *window == '=') {\n\t\twindow++;\n\t\tfs->flags |= CMD_FIND_EXACT_WINDOW;\n\t}\n\n\t/* Empty is the same as NULL. */\n\tif (session != NULL && *session == '\\0')\n\t\tsession = NULL;\n\tif (window != NULL && *window == '\\0')\n\t\twindow = NULL;\n\tif (pane != NULL && *pane == '\\0')\n\t\tpane = NULL;\n\n\t/* Map though conversion table. */\n\tif (session != NULL)\n\t\tsession = cmd_find_map_table(cmd_find_session_table, session);\n\tif (window != NULL)\n\t\twindow = cmd_find_map_table(cmd_find_window_table, window);\n\tif (pane != NULL)\n\t\tpane = cmd_find_map_table(cmd_find_pane_table, pane);\n\n\tlog_debug(\"target %s (flags %#x): session=%s, window=%s, pane=%s\",\n\t    target, flags, session == NULL ? \"none\" : session,\n\t    window == NULL ? \"none\" : window, pane == NULL ? \"none\" : pane);\n\n\t/* No pane is allowed if want an index. */\n\tif (pane != NULL && (flags & CMD_FIND_WINDOW_INDEX)) {\n\t\tif (~flags & CMD_FIND_QUIET)\n\t\t\tcmdq_error(cmdq, \"can't specify pane here\");\n\t\tgoto error;\n\t}\n\n\t/* If the session isn't NULL, look it up. */\n\tif (session != NULL) {\n\t\t/* This will fill in session. */\n\t\tif (cmd_find_get_session(fs, session) != 0)\n\t\t\tgoto no_session;\n\n\t\t/* If window and pane are NULL, use that session's current. */\n\t\tif (window == NULL && pane == NULL) {\n\t\t\tfs->wl = fs->s->curw;\n\t\t\tfs->idx = -1;\n\t\t\tfs->w = fs->wl->window;\n\t\t\tfs->wp = fs->w->active;\n\t\t\tgoto found;\n\t\t}\n\n\t\t/* If window is present but pane not, find window in session. */\n\t\tif (window != NULL && pane == NULL) {\n\t\t\t/* This will fill in winlink and window. */\n\t\t\tif (cmd_find_get_window_with_session(fs, window) != 0)\n\t\t\t\tgoto no_window;\n\t\t\tfs->wp = fs->wl->window->active;\n\t\t\tgoto found;\n\t\t}\n\n\t\t/* If pane is present but window not, find pane. */\n\t\tif (window == NULL && pane != NULL) {\n\t\t\t/* This will fill in winlink and window and pane. */\n\t\t\tif (cmd_find_get_pane_with_session(fs, pane) != 0)\n\t\t\t\tgoto no_pane;\n\t\t\tgoto found;\n\t\t}\n\n\t\t/*\n\t\t * If window and pane are present, find both in session. This\n\t\t * will fill in winlink and window.\n\t\t */\n\t\tif (cmd_find_get_window_with_session(fs, window) != 0)\n\t\t\tgoto no_window;\n\t\t/* This will fill in pane. */\n\t\tif (cmd_find_get_pane_with_window(fs, pane) != 0)\n\t\t\tgoto no_pane;\n\t\tgoto found;\n\t}\n\n\t/* No session. If window and pane, try them. */\n\tif (window != NULL && pane != NULL) {\n\t\t/* This will fill in session, winlink and window. */\n\t\tif (cmd_find_get_window(fs, window) != 0)\n\t\t\tgoto no_window;\n\t\t/* This will fill in pane. */\n\t\tif (cmd_find_get_pane_with_window(fs, pane) != 0)\n\t\t\tgoto no_pane;\n\t\tgoto found;\n\t}\n\n\t/* If just window is present, try it. */\n\tif (window != NULL && pane == NULL) {\n\t\t/* This will fill in session, winlink and window. */\n\t\tif (cmd_find_get_window(fs, window) != 0)\n\t\t\tgoto no_window;\n\t\tfs->wp = fs->wl->window->active;\n\t\tgoto found;\n\t}\n\n\t/* If just pane is present, try it. */\n\tif (window == NULL && pane != NULL) {\n\t\t/* This will fill in session, winlink, window and pane. */\n\t\tif (cmd_find_get_pane(fs, pane) != 0)\n\t\t\tgoto no_pane;\n\t\tgoto found;\n\t}\n\ncurrent:\n\t/* Use the current session. */\n\tcmd_find_copy_state(fs, fs->current);\n\tif (flags & CMD_FIND_WINDOW_INDEX)\n\t\tfs->idx = -1;\n\tgoto found;\n\nerror:\n\tfs->current = NULL;\n\tlog_debug(\"    error\");\n\n\tfree(copy);\n\treturn (-1);\n\nfound:\n\tfs->current = NULL;\n\tcmd_find_log_state(__func__, fs);\n\n\tfree(copy);\n\treturn (0);\n\nno_session:\n\tif (~flags & CMD_FIND_QUIET)\n\t\tcmdq_error(cmdq, \"can't find session %s\", session);\n\tgoto error;\n\nno_window:\n\tif (~flags & CMD_FIND_QUIET)\n\t\tcmdq_error(cmdq, \"can't find window %s\", window);\n\tgoto error;\n\nno_pane:\n\tif (~flags & CMD_FIND_QUIET)\n\t\tcmdq_error(cmdq, \"can't find pane %s\", pane);\n\tgoto error;\n}\n\n/* Find the target client or report an error and return NULL. */\nstruct client *\ncmd_find_client(struct cmd_q *cmdq, const char *target, int quiet)\n{\n\tstruct client\t*c;\n\tchar\t\t*copy;\n\tsize_t\t\t size;\n\tconst char\t*path;\n\n\t/* A NULL argument means the current client. */\n\tif (cmdq != NULL && target == NULL) {\n\t\tc = cmd_find_current_client(cmdq);\n\t\tif (c == NULL && !quiet)\n\t\t\tcmdq_error(cmdq, \"no current client\");\n\t\tlog_debug(\"%s: no target, return %p\", __func__, c);\n\t\treturn (c);\n\t}\n\tcopy = xstrdup(target);\n\n\t/* Trim a single trailing colon if any. */\n\tsize = strlen(copy);\n\tif (size != 0 && copy[size - 1] == ':')\n\t\tcopy[size - 1] = '\\0';\n\n\t/* Check path of each client. */\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (c->session == NULL || c->tty.path == NULL)\n\t\t\tcontinue;\n\t\tpath = c->tty.path;\n\n\t\t/* Try for exact match. */\n\t\tif (strcmp(copy, path) == 0)\n\t\t\tbreak;\n\n\t\t/* Try without leading /dev. */\n\t\tif (strncmp(path, _PATH_DEV, (sizeof _PATH_DEV) - 1) != 0)\n\t\t\tcontinue;\n\t\tif (strcmp(copy, path + (sizeof _PATH_DEV) - 1) == 0)\n\t\t\tbreak;\n\t}\n\n\t/* If no client found, report an error. */\n\tif (c == NULL && !quiet)\n\t\tcmdq_error(cmdq, \"can't find client %s\", copy);\n\n\tfree(copy);\n\tlog_debug(\"%s: target %s, return %p\", __func__, target, c);\n\treturn (c);\n}\n"
        },
        {
          "name": "cmd-if-shell.c",
          "type": "blob",
          "size": 4.6513671875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Tiago Cunha <me@tiagocunha.org>\n * Copyright (c) 2009 Nicholas Marriott <nicm@openbsd.org>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/wait.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * Executes a tmux command if a shell command returns true or false.\n */\n\nenum cmd_retval\t cmd_if_shell_exec(struct cmd *, struct cmd_q *);\n\nvoid\tcmd_if_shell_callback(struct job *);\nvoid\tcmd_if_shell_done(struct cmd_q *);\nvoid\tcmd_if_shell_free(void *);\n\nconst struct cmd_entry cmd_if_shell_entry = {\n\t.name = \"if-shell\",\n\t.alias = \"if\",\n\n\t.args = { \"bFt:\", 2, 3 },\n\t.usage = \"[-bF] \" CMD_TARGET_PANE_USAGE \" shell-command command \"\n\t\t \"[command]\",\n\n\t.tflag = CMD_PANE_CANFAIL,\n\n\t.flags = 0,\n\t.exec = cmd_if_shell_exec\n};\n\nstruct cmd_if_shell_data {\n\tchar\t\t\t*cmd_if;\n\tchar\t\t\t*cmd_else;\n\n\tstruct cmd_q\t\t*cmdq;\n\tstruct mouse_event\t mouse;\n\n\tint\t\t\t bflag;\n\tint\t\t\t references;\n};\n\nenum cmd_retval\ncmd_if_shell_exec(struct cmd *self, struct cmd_q *cmdq)\n{\n\tstruct args\t\t\t*args = self->args;\n\tstruct cmd_if_shell_data\t*cdata;\n\tchar\t\t\t\t*shellcmd, *cmd, *cause;\n\tstruct cmd_list\t\t\t*cmdlist;\n\tstruct session\t\t\t*s = cmdq->state.tflag.s;\n\tstruct winlink\t\t\t*wl = cmdq->state.tflag.wl;\n\tstruct window_pane\t\t*wp = cmdq->state.tflag.wp;\n\tstruct format_tree\t\t*ft;\n\tconst char\t\t\t*cwd;\n\n\tif (cmdq->client != NULL && cmdq->client->session == NULL)\n\t\tcwd = cmdq->client->cwd;\n\telse if (s != NULL)\n\t\tcwd = s->cwd;\n\telse\n\t\tcwd = NULL;\n\n\tft = format_create(cmdq, 0);\n\tformat_defaults(ft, NULL, s, wl, wp);\n\tshellcmd = format_expand(ft, args->argv[0]);\n\tformat_free(ft);\n\n\tif (args_has(args, 'F')) {\n\t\tcmd = NULL;\n\t\tif (*shellcmd != '0' && *shellcmd != '\\0')\n\t\t\tcmd = args->argv[1];\n\t\telse if (args->argc == 3)\n\t\t\tcmd = args->argv[2];\n\t\tfree(shellcmd);\n\t\tif (cmd == NULL)\n\t\t\treturn (CMD_RETURN_NORMAL);\n\t\tif (cmd_string_parse(cmd, &cmdlist, NULL, 0, &cause) != 0) {\n\t\t\tif (cause != NULL) {\n\t\t\t\tcmdq_error(cmdq, \"%s\", cause);\n\t\t\t\tfree(cause);\n\t\t\t}\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\tcmdq_run(cmdq, cmdlist, &cmdq->item->mouse);\n\t\tcmd_list_free(cmdlist);\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tcdata = xmalloc(sizeof *cdata);\n\n\tcdata->cmd_if = xstrdup(args->argv[1]);\n\tif (args->argc == 3)\n\t\tcdata->cmd_else = xstrdup(args->argv[2]);\n\telse\n\t\tcdata->cmd_else = NULL;\n\n\tcdata->bflag = args_has(args, 'b');\n\n\tcdata->cmdq = cmdq;\n\tmemcpy(&cdata->mouse, &cmdq->item->mouse, sizeof cdata->mouse);\n\tcmdq->references++;\n\n\tcdata->references = 1;\n\tjob_run(shellcmd, s, cwd, cmd_if_shell_callback, cmd_if_shell_free,\n\t    cdata);\n\tfree(shellcmd);\n\n\tif (cdata->bflag)\n\t\treturn (CMD_RETURN_NORMAL);\n\treturn (CMD_RETURN_WAIT);\n}\n\nvoid\ncmd_if_shell_callback(struct job *job)\n{\n\tstruct cmd_if_shell_data\t*cdata = job->data;\n\tstruct cmd_q\t\t\t*cmdq = cdata->cmdq, *cmdq1;\n\tstruct cmd_list\t\t\t*cmdlist;\n\tchar\t\t\t\t*cause, *cmd;\n\n\tif (cmdq->flags & CMD_Q_DEAD)\n\t\treturn;\n\n\tif (!WIFEXITED(job->status) || WEXITSTATUS(job->status) != 0)\n\t\tcmd = cdata->cmd_else;\n\telse\n\t\tcmd = cdata->cmd_if;\n\tif (cmd == NULL)\n\t\treturn;\n\n\tif (cmd_string_parse(cmd, &cmdlist, NULL, 0, &cause) != 0) {\n\t\tif (cause != NULL) {\n\t\t\tcmdq_error(cmdq, \"%s\", cause);\n\t\t\tfree(cause);\n\t\t}\n\t\treturn;\n\t}\n\n\tcmdq1 = cmdq_new(cmdq->client);\n\tcmdq1->emptyfn = cmd_if_shell_done;\n\tcmdq1->data = cdata;\n\n\tcdata->references++;\n\tcmdq_run(cmdq1, cmdlist, &cdata->mouse);\n\tcmd_list_free(cmdlist);\n}\n\nvoid\ncmd_if_shell_done(struct cmd_q *cmdq1)\n{\n\tstruct cmd_if_shell_data\t*cdata = cmdq1->data;\n\tstruct cmd_q\t\t\t*cmdq = cdata->cmdq;\n\n\tif (cmdq1->client_exit >= 0)\n\t\tcmdq->client_exit = cmdq1->client_exit;\n\tcmdq_free(cmdq1);\n\n\tif (--cdata->references != 0)\n\t\treturn;\n\n\tif (!cmdq_free(cmdq) && !cdata->bflag)\n\t\tcmdq_continue(cmdq);\n\n\tfree(cdata->cmd_else);\n\tfree(cdata->cmd_if);\n\tfree(cdata);\n}\n\nvoid\ncmd_if_shell_free(void *data)\n{\n\tstruct cmd_if_shell_data\t*cdata = data;\n\tstruct cmd_q\t\t\t*cmdq = cdata->cmdq;\n\n\tif (--cdata->references != 0)\n\t\treturn;\n\n\tif (!cmdq_free(cmdq) && !cdata->bflag)\n\t\tcmdq_continue(cmdq);\n\n\tfree(cdata->cmd_else);\n\tfree(cdata->cmd_if);\n\tfree(cdata);\n}\n"
        },
        {
          "name": "cmd-join-pane.c",
          "type": "blob",
          "size": 4.2900390625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2011 George Nachman <tmux@georgester.com>\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\n/*\n * Join or move a pane into another (like split/swap/kill).\n */\n\nenum cmd_retval\t cmd_join_pane_exec(struct cmd *, struct cmd_q *);\n\nenum cmd_retval\t join_pane(struct cmd *, struct cmd_q *, int);\n\nconst struct cmd_entry cmd_join_pane_entry = {\n\t.name = \"join-pane\",\n\t.alias = \"joinp\",\n\n\t.args = { \"bdhvp:l:s:t:\", 0, 0 },\n\t.usage = \"[-bdhv] [-p percentage|-l size] \" CMD_SRCDST_PANE_USAGE,\n\n\t.sflag = CMD_PANE_MARKED,\n\t.tflag = CMD_PANE,\n\n\t.flags = 0,\n\t.exec = cmd_join_pane_exec\n};\n\nconst struct cmd_entry cmd_move_pane_entry = {\n\t.name = \"move-pane\",\n\t.alias = \"movep\",\n\n\t.args = { \"bdhvp:l:s:t:\", 0, 0 },\n\t.usage = \"[-bdhv] [-p percentage|-l size] \" CMD_SRCDST_PANE_USAGE,\n\n\t.sflag = CMD_PANE,\n\t.tflag = CMD_PANE,\n\n\t.flags = 0,\n\t.exec = cmd_join_pane_exec\n};\n\nenum cmd_retval\ncmd_join_pane_exec(struct cmd *self, struct cmd_q *cmdq)\n{\n\treturn (join_pane(self, cmdq, self->entry == &cmd_join_pane_entry));\n}\n\nenum cmd_retval\njoin_pane(struct cmd *self, struct cmd_q *cmdq, int not_same_window)\n{\n#ifdef TMATE\n\tcmdq_error(cmdq, \"join pane is not supported with tmate\");\n\treturn (CMD_RETURN_ERROR);\n#else\n\tstruct args\t\t*args = self->args;\n\tstruct session\t\t*dst_s;\n\tstruct winlink\t\t*src_wl, *dst_wl;\n\tstruct window\t\t*src_w, *dst_w;\n\tstruct window_pane\t*src_wp, *dst_wp;\n\tchar\t\t\t*cause;\n\tint\t\t\t size, percentage, dst_idx;\n\tenum layout_type\t type;\n\tstruct layout_cell\t*lc;\n\n\tdst_s = cmdq->state.tflag.s;\n\tdst_wl = cmdq->state.tflag.wl;\n\tdst_wp = cmdq->state.tflag.wp;\n\tdst_w = dst_wl->window;\n\tdst_idx = dst_wl->idx;\n\tserver_unzoom_window(dst_w);\n\n\tsrc_wl = cmdq->state.sflag.wl;\n\tsrc_wp = cmdq->state.sflag.wp;\n\tsrc_w = src_wl->window;\n\tserver_unzoom_window(src_w);\n\n\tif (not_same_window && src_w == dst_w) {\n\t\tcmdq_error(cmdq, \"can't join a pane to its own window\");\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\tif (!not_same_window && src_wp == dst_wp) {\n\t\tcmdq_error(cmdq, \"source and target panes must be different\");\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\ttype = LAYOUT_TOPBOTTOM;\n\tif (args_has(args, 'h'))\n\t\ttype = LAYOUT_LEFTRIGHT;\n\n\tsize = -1;\n\tif (args_has(args, 'l')) {\n\t\tsize = args_strtonum(args, 'l', 0, INT_MAX, &cause);\n\t\tif (cause != NULL) {\n\t\t\tcmdq_error(cmdq, \"size %s\", cause);\n\t\t\tfree(cause);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t} else if (args_has(args, 'p')) {\n\t\tpercentage = args_strtonum(args, 'p', 0, 100, &cause);\n\t\tif (cause != NULL) {\n\t\t\tcmdq_error(cmdq, \"percentage %s\", cause);\n\t\t\tfree(cause);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\tif (type == LAYOUT_TOPBOTTOM)\n\t\t\tsize = (dst_wp->sy * percentage) / 100;\n\t\telse\n\t\t\tsize = (dst_wp->sx * percentage) / 100;\n\t}\n\tlc = layout_split_pane(dst_wp, type, size, args_has(args, 'b'));\n\tif (lc == NULL) {\n\t\tcmdq_error(cmdq, \"create pane failed: pane too small\");\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\tlayout_close_pane(src_wp);\n\n\twindow_lost_pane(src_w, src_wp);\n\tTAILQ_REMOVE(&src_w->panes, src_wp, entry);\n\n\tif (window_count_panes(src_w) == 0)\n\t\tserver_kill_window(src_w);\n\telse\n\t\tnotify_window_layout_changed(src_w);\n\n\tsrc_wp->window = dst_w;\n\tTAILQ_INSERT_AFTER(&dst_w->panes, dst_wp, src_wp, entry);\n\tlayout_assign_pane(lc, src_wp);\n\n\trecalculate_sizes();\n\n\tserver_redraw_window(src_w);\n\tserver_redraw_window(dst_w);\n\n\tif (!args_has(args, 'd')) {\n\t\twindow_set_active_pane(dst_w, src_wp);\n\t\tsession_select(dst_s, dst_idx);\n\t\tserver_redraw_session(dst_s);\n\t} else\n\t\tserver_status_session(dst_s);\n\n\tnotify_window_layout_changed(dst_w);\n\treturn (CMD_RETURN_NORMAL);\n#endif\n}\n"
        },
        {
          "name": "cmd-kill-pane.c",
          "type": "blob",
          "size": 1.912109375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n\n#include \"tmux.h\"\n\n/*\n * Kill pane.\n */\n\nenum cmd_retval\t cmd_kill_pane_exec(struct cmd *, struct cmd_q *);\n\nconst struct cmd_entry cmd_kill_pane_entry = {\n\t.name = \"kill-pane\",\n\t.alias = \"killp\",\n\n\t.args = { \"at:\", 0, 0 },\n\t.usage = \"[-a] \" CMD_TARGET_PANE_USAGE,\n\n\t.tflag = CMD_PANE,\n\n\t.flags = 0,\n\t.exec = cmd_kill_pane_exec\n};\n\nenum cmd_retval\ncmd_kill_pane_exec(struct cmd *self, struct cmd_q *cmdq)\n{\n\tstruct winlink\t\t*wl = cmdq->state.tflag.wl;\n\tstruct window_pane\t*loopwp, *tmpwp, *wp = cmdq->state.tflag.wp;\n\n\tserver_unzoom_window(wl->window);\n\n\tif (window_count_panes(wl->window) == 1) {\n\t\t/* Only one pane, kill the window. */\n\t\tserver_kill_window(wl->window);\n\t\trecalculate_sizes();\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tif (args_has(self->args, 'a')) {\n\t\tTAILQ_FOREACH_SAFE(loopwp, &wl->window->panes, entry, tmpwp) {\n\t\t\tif (loopwp == wp)\n\t\t\t\tcontinue;\n\t\t\tlayout_close_pane(loopwp);\n\t\t\twindow_remove_pane(wl->window, loopwp);\n\t\t}\n\t} else {\n\t\tlayout_close_pane(wp);\n\t\twindow_remove_pane(wl->window, wp);\n\t}\n\tserver_redraw_window(wl->window);\n\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-kill-server.c",
          "type": "blob",
          "size": 1.552734375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <signal.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\n/*\n * Kill the server and do nothing else.\n */\n\nenum cmd_retval\t cmd_kill_server_exec(struct cmd *, struct cmd_q *);\n\nconst struct cmd_entry cmd_kill_server_entry = {\n\t.name = \"kill-server\",\n\t.alias = NULL,\n\n\t.args = { \"\", 0, 0 },\n\t.usage = \"\",\n\n\t.flags = 0,\n\t.exec = cmd_kill_server_exec\n};\n\nconst struct cmd_entry cmd_start_server_entry = {\n\t.name = \"start-server\",\n\t.alias = \"start\",\n\n\t.args = { \"\", 0, 0 },\n\t.usage = \"\",\n\n\t.flags = CMD_STARTSERVER,\n\t.exec = cmd_kill_server_exec\n};\n\nenum cmd_retval\ncmd_kill_server_exec(struct cmd *self, __unused struct cmd_q *cmdq)\n{\n\tif (self->entry == &cmd_kill_server_entry)\n\t\tkill(getpid(), SIGTERM);\n\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-kill-session.c",
          "type": "blob",
          "size": 1.990234375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include \"tmux.h\"\n\n/*\n * Destroy session, detaching all clients attached to it and destroying any\n * windows linked only to this session.\n *\n * Note this deliberately has no alias to make it hard to hit by accident.\n */\n\nenum cmd_retval\t cmd_kill_session_exec(struct cmd *, struct cmd_q *);\n\nconst struct cmd_entry cmd_kill_session_entry = {\n\t.name = \"kill-session\",\n\t.alias = NULL,\n\n\t.args = { \"aCt:\", 0, 0 },\n\t.usage = \"[-aC] \" CMD_TARGET_SESSION_USAGE,\n\n\t.tflag = CMD_SESSION,\n\n\t.flags = 0,\n\t.exec = cmd_kill_session_exec\n};\n\nenum cmd_retval\ncmd_kill_session_exec(struct cmd *self, struct cmd_q *cmdq)\n{\n\tstruct args\t*args = self->args;\n\tstruct session\t*s, *sloop, *stmp;\n\tstruct winlink\t*wl;\n\n\ts = cmdq->state.tflag.s;\n\n\tif (args_has(args, 'C')) {\n\t\tRB_FOREACH(wl, winlinks, &s->windows) {\n\t\t\twl->window->flags &= ~WINDOW_ALERTFLAGS;\n\t\t\twl->flags &= ~WINLINK_ALERTFLAGS;\n\t\t}\n\t\tserver_redraw_session(s);\n\t} else if (args_has(args, 'a')) {\n\t\tRB_FOREACH_SAFE(sloop, sessions, &sessions, stmp) {\n\t\t\tif (sloop != s) {\n\t\t\t\tserver_destroy_session(sloop);\n\t\t\t\tsession_destroy(sloop);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tserver_destroy_session(s);\n\t\tsession_destroy(s);\n\t}\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-kill-window.c",
          "type": "blob",
          "size": 2.126953125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include \"tmux.h\"\n\n/*\n * Destroy window.\n */\n\nenum cmd_retval\t cmd_kill_window_exec(struct cmd *, struct cmd_q *);\n\nconst struct cmd_entry cmd_kill_window_entry = {\n\t.name = \"kill-window\",\n\t.alias = \"killw\",\n\n\t.args = { \"at:\", 0, 0 },\n\t.usage = \"[-a] \" CMD_TARGET_WINDOW_USAGE,\n\n\t.tflag = CMD_WINDOW,\n\n\t.flags = 0,\n\t.exec = cmd_kill_window_exec\n};\n\nconst struct cmd_entry cmd_unlink_window_entry = {\n\t.name = \"unlink-window\",\n\t.alias = \"unlinkw\",\n\n\t.args = { \"kt:\", 0, 0 },\n\t.usage = \"[-k] \" CMD_TARGET_WINDOW_USAGE,\n\n\t.tflag = CMD_WINDOW,\n\n\t.flags = 0,\n\t.exec = cmd_kill_window_exec\n};\n\nenum cmd_retval\ncmd_kill_window_exec(struct cmd *self, struct cmd_q *cmdq)\n{\n\tstruct args\t\t*args = self->args;\n\tstruct winlink\t\t*wl = cmdq->state.tflag.wl, *wl2, *wl3;\n\tstruct window\t\t*w = wl->window;\n\tstruct session\t\t*s = cmdq->state.tflag.s;\n\n\tif (self->entry == &cmd_unlink_window_entry) {\n\t\tif (!args_has(self->args, 'k') && !session_is_linked(s, w)) {\n\t\t\tcmdq_error(cmdq, \"window only linked to one session\");\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\tserver_unlink_window(s, wl);\n\t} else {\n\t\tif (args_has(args, 'a')) {\n\t\t\tRB_FOREACH_SAFE(wl2, winlinks, &s->windows, wl3) {\n\t\t\t\tif (wl != wl2)\n\t\t\t\t\tserver_kill_window(wl2->window);\n\t\t\t}\n\t\t} else\n\t\t\tserver_kill_window(wl->window);\n\t}\n\n\trecalculate_sizes();\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-list-buffers.c",
          "type": "blob",
          "size": 1.8154296875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * List paste buffers.\n */\n\n#define LIST_BUFFERS_TEMPLATE\t\t\t\t\t\t\\\n\t\"#{buffer_name}: #{buffer_size} bytes: \\\"#{buffer_sample}\\\"\"\n\nenum cmd_retval\t cmd_list_buffers_exec(struct cmd *, struct cmd_q *);\n\nconst struct cmd_entry cmd_list_buffers_entry = {\n\t.name = \"list-buffers\",\n\t.alias = \"lsb\",\n\n\t.args = { \"F:\", 0, 0 },\n\t.usage = \"[-F format]\",\n\n\t.flags = 0,\n\t.exec = cmd_list_buffers_exec\n};\n\nenum cmd_retval\ncmd_list_buffers_exec(struct cmd *self, struct cmd_q *cmdq)\n{\n\tstruct args\t\t*args = self->args;\n\tstruct paste_buffer\t*pb;\n\tstruct format_tree\t*ft;\n\tchar\t\t\t*line;\n\tconst char\t\t*template;\n\n\tif ((template = args_get(args, 'F')) == NULL)\n\t\ttemplate = LIST_BUFFERS_TEMPLATE;\n\n\tpb = NULL;\n\twhile ((pb = paste_walk(pb)) != NULL) {\n\t\tft = format_create(cmdq, 0);\n\t\tformat_defaults_paste_buffer(ft, pb);\n\n\t\tline = format_expand(ft, template);\n\t\tcmdq_print(cmdq, \"%s\", line);\n\t\tfree(line);\n\n\t\tformat_free(ft);\n\t}\n\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-list-clients.c",
          "type": "blob",
          "size": 2.1962890625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\n#include \"tmux.h\"\n\n/*\n * List all clients.\n */\n\n#define LIST_CLIENTS_TEMPLATE\t\t\t\t\t\\\n\t\"#{client_tty}: #{session_name} \"\t\t\t\\\n\t\"[#{client_width}x#{client_height} #{client_termname}]\"\t\\\n\t\"#{?client_utf8, (utf8),} #{?client_readonly, (ro),}\"\n\nenum cmd_retval\tcmd_list_clients_exec(struct cmd *, struct cmd_q *);\n\nconst struct cmd_entry cmd_list_clients_entry = {\n\t.name = \"list-clients\",\n\t.alias = \"lsc\",\n\n\t.args = { \"F:t:\", 0, 0 },\n\t.usage = \"[-F format] \" CMD_TARGET_SESSION_USAGE,\n\n\t.tflag = CMD_SESSION,\n\n\t.flags = CMD_READONLY,\n\t.exec = cmd_list_clients_exec\n};\n\nenum cmd_retval\ncmd_list_clients_exec(struct cmd *self, struct cmd_q *cmdq)\n{\n\tstruct args \t\t*args = self->args;\n\tstruct client\t\t*c;\n\tstruct session\t\t*s;\n\tstruct format_tree\t*ft;\n\tconst char\t\t*template;\n\tu_int\t\t\t idx;\n\tchar\t\t\t*line;\n\n\tif (args_has(args, 't'))\n\t\ts = cmdq->state.tflag.s;\n\telse\n\t\ts = NULL;\n\n\tif ((template = args_get(args, 'F')) == NULL)\n\t\ttemplate = LIST_CLIENTS_TEMPLATE;\n\n\tidx = 0;\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (c->session == NULL || (s != NULL && s != c->session))\n\t\t\tcontinue;\n\n\t\tft = format_create(cmdq, 0);\n\t\tformat_add(ft, \"line\", \"%u\", idx);\n\t\tformat_defaults(ft, c, NULL, NULL, NULL);\n\n\t\tline = format_expand(ft, template);\n\t\tcmdq_print(cmdq, \"%s\", line);\n\t\tfree(line);\n\n\t\tformat_free(ft);\n\n\t\tidx++;\n\t}\n\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-list-keys.c",
          "type": "blob",
          "size": 5.216796875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * List key bindings.\n */\n\nenum cmd_retval\t cmd_list_keys_exec(struct cmd *, struct cmd_q *);\n\nenum cmd_retval\t cmd_list_keys_table(struct cmd *, struct cmd_q *);\nenum cmd_retval\t cmd_list_keys_commands(struct cmd_q *);\n\nconst struct cmd_entry cmd_list_keys_entry = {\n\t.name = \"list-keys\",\n\t.alias = \"lsk\",\n\n\t.args = { \"t:T:\", 0, 0 },\n\t.usage = \"[-t mode-table] [-T key-table]\",\n\n\t.flags = CMD_STARTSERVER,\n\t.exec = cmd_list_keys_exec\n};\n\nconst struct cmd_entry cmd_list_commands_entry = {\n\t.name = \"list-commands\",\n\t.alias = \"lscm\",\n\n\t.args = { \"\", 0, 0 },\n\t.usage = \"\",\n\n\t.flags = CMD_STARTSERVER,\n\t.exec = cmd_list_keys_exec\n};\n\nenum cmd_retval\ncmd_list_keys_exec(struct cmd *self, struct cmd_q *cmdq)\n{\n\tstruct args\t\t*args = self->args;\n\tstruct key_table\t*table;\n\tstruct key_binding\t*bd;\n\tconst char\t\t*key, *tablename, *r;\n\tchar\t\t\t*cp, tmp[BUFSIZ];\n\tint\t\t\t repeat, width, tablewidth, keywidth;\n\n\tif (self->entry == &cmd_list_commands_entry)\n\t\treturn (cmd_list_keys_commands(cmdq));\n\n#ifdef TMATE\n\t/* XXX TODO Really nasty hack, we really need our own client instance... */\n\tstruct client fake_client;\n\tif (!cmdq->client) {\n\t\tcmdq->client = &fake_client;\n\t\tcmdq->client->flags = 0;\n\t\tcmdq->client->session = RB_MIN(sessions, &sessions);\n\t}\n#endif\n\n\tif (args_has(args, 't'))\n\t\treturn (cmd_list_keys_table(self, cmdq));\n\n\ttablename = args_get(args, 'T');\n\tif (tablename != NULL && key_bindings_get_table(tablename, 0) == NULL) {\n\t\tcmdq_error(cmdq, \"table %s doesn't exist\", tablename);\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\trepeat = 0;\n\ttablewidth = keywidth = 0;\n\tRB_FOREACH(table, key_tables, &key_tables) {\n\t\tif (tablename != NULL && strcmp(table->name, tablename) != 0)\n\t\t\tcontinue;\n\t\tRB_FOREACH(bd, key_bindings, &table->key_bindings) {\n\t\t\tkey = key_string_lookup_key(bd->key);\n\n\t\t\tif (bd->can_repeat)\n\t\t\t\trepeat = 1;\n\n\t\t\twidth = utf8_cstrwidth(table->name);\n\t\t\tif (width > tablewidth)\n\t\t\t\ttablewidth = width;\n\t\t\twidth = utf8_cstrwidth(key);\n\t\t\tif (width > keywidth)\n\t\t\t\tkeywidth = width;\n\t\t}\n\t}\n\n\tRB_FOREACH(table, key_tables, &key_tables) {\n\t\tif (tablename != NULL && strcmp(table->name, tablename) != 0)\n\t\t\tcontinue;\n\t\tRB_FOREACH(bd, key_bindings, &table->key_bindings) {\n\t\t\tkey = key_string_lookup_key(bd->key);\n\n\t\t\tif (!repeat)\n\t\t\t\tr = \"\";\n\t\t\telse if (bd->can_repeat)\n\t\t\t\tr = \"-r \";\n\t\t\telse\n\t\t\t\tr = \"   \";\n\t\t\txsnprintf(tmp, sizeof tmp, \"%s-T \", r);\n\n\t\t\tcp = utf8_padcstr(table->name, tablewidth);\n\t\t\tstrlcat(tmp, cp, sizeof tmp);\n\t\t\tstrlcat(tmp, \" \", sizeof tmp);\n\t\t\tfree(cp);\n\n\t\t\tcp = utf8_padcstr(key, keywidth);\n\t\t\tstrlcat(tmp, cp, sizeof tmp);\n\t\t\tstrlcat(tmp, \" \", sizeof tmp);\n\t\t\tfree(cp);\n\n\t\t\tcp = cmd_list_print(bd->cmdlist);\n\t\t\tstrlcat(tmp, cp, sizeof tmp);\n\t\t\tfree(cp);\n\n\t\t\tcmdq_print(cmdq, \"bind-key %s\", tmp);\n\t\t}\n\t}\n\n\treturn (CMD_RETURN_NORMAL);\n}\n\nenum cmd_retval\ncmd_list_keys_table(struct cmd *self, struct cmd_q *cmdq)\n{\n\tstruct args\t\t\t*args = self->args;\n\tconst char\t\t\t*tablename;\n\tconst struct mode_key_table\t*mtab;\n\tstruct mode_key_binding\t\t*mbind;\n\tconst char\t\t\t*key, *cmdstr, *mode;\n\tint\t\t\t \t width, keywidth, any_mode;\n\n\ttablename = args_get(args, 't');\n\tif ((mtab = mode_key_findtable(tablename)) == NULL) {\n\t\tcmdq_error(cmdq, \"unknown key table: %s\", tablename);\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\twidth = 0;\n\tany_mode = 0;\n\tRB_FOREACH(mbind, mode_key_tree, mtab->tree) {\n\t\tkey = key_string_lookup_key(mbind->key);\n\n\t\tif (mbind->mode != 0)\n\t\t\tany_mode = 1;\n\n\t\tkeywidth = strlen(key);\n\t\tif (keywidth > width)\n\t\t\twidth = keywidth;\n\t}\n\n\tRB_FOREACH(mbind, mode_key_tree, mtab->tree) {\n\t\tkey = key_string_lookup_key(mbind->key);\n\n\t\tmode = \"\";\n\t\tif (mbind->mode != 0)\n\t\t\tmode = \"c\";\n\t\tcmdstr = mode_key_tostring(mtab->cmdstr, mbind->cmd);\n\t\tif (cmdstr != NULL) {\n\t\t\tcmdq_print(cmdq, \"bind-key -%st %s%s %*s %s%s%s%s\",\n\t\t\t    mode, any_mode && *mode == '\\0' ? \" \" : \"\",\n\t\t\t    mtab->name, (int) width, key, cmdstr,\n\t\t\t    mbind->arg != NULL ? \" \\\"\" : \"\",\n\t\t\t    mbind->arg != NULL ? mbind->arg : \"\",\n\t\t\t    mbind->arg != NULL ? \"\\\"\": \"\");\n\t\t}\n\t}\n\n\treturn (CMD_RETURN_NORMAL);\n}\n\nenum cmd_retval\ncmd_list_keys_commands(struct cmd_q *cmdq)\n{\n\tconst struct cmd_entry\t**entryp;\n\tconst struct cmd_entry\t *entry;\n\n\tfor (entryp = cmd_table; *entryp != NULL; entryp++) {\n\t\tentry = *entryp;\n\t\tif (entry->alias == NULL) {\n\t\t\tcmdq_print(cmdq, \"%s %s\", entry->name, entry->usage);\n\t\t\tcontinue;\n\t\t}\n\t\tcmdq_print(cmdq, \"%s (%s) %s\", entry->name, entry->alias,\n\t\t    entry->usage);\n\t}\n\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-list-panes.c",
          "type": "blob",
          "size": 3.6298828125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n\n#include \"tmux.h\"\n\n/*\n * List panes on given window.\n */\n\nenum cmd_retval\t cmd_list_panes_exec(struct cmd *, struct cmd_q *);\n\nvoid\tcmd_list_panes_server(struct cmd *, struct cmd_q *);\nvoid\tcmd_list_panes_session(struct cmd *, struct session *, struct cmd_q *,\n\t    int);\nvoid\tcmd_list_panes_window(struct cmd *, struct session *, struct winlink *,\n\t    struct cmd_q *, int);\n\nconst struct cmd_entry cmd_list_panes_entry = {\n\t.name = \"list-panes\",\n\t.alias = \"lsp\",\n\n\t.args = { \"asF:t:\", 0, 0 },\n\t.usage = \"[-as] [-F format] \" CMD_TARGET_WINDOW_USAGE,\n\n\t.tflag = CMD_WINDOW,\n\n\t.flags = 0,\n\t.exec = cmd_list_panes_exec\n};\n\nenum cmd_retval\ncmd_list_panes_exec(struct cmd *self, struct cmd_q *cmdq)\n{\n\tstruct args\t*args = self->args;\n\tstruct session\t*s = cmdq->state.tflag.s;\n\tstruct winlink\t*wl = cmdq->state.tflag.wl;\n\n\tif (args_has(args, 'a'))\n\t\tcmd_list_panes_server(self, cmdq);\n\telse if (args_has(args, 's'))\n\t\tcmd_list_panes_session(self, s, cmdq, 1);\n\telse\n\t\tcmd_list_panes_window(self, s, wl, cmdq, 0);\n\n\treturn (CMD_RETURN_NORMAL);\n}\n\nvoid\ncmd_list_panes_server(struct cmd *self, struct cmd_q *cmdq)\n{\n\tstruct session\t*s;\n\n\tRB_FOREACH(s, sessions, &sessions)\n\t\tcmd_list_panes_session(self, s, cmdq, 2);\n}\n\nvoid\ncmd_list_panes_session(struct cmd *self, struct session *s, struct cmd_q *cmdq,\n    int type)\n{\n\tstruct winlink\t*wl;\n\n\tRB_FOREACH(wl, winlinks, &s->windows)\n\t\tcmd_list_panes_window(self, s, wl, cmdq, type);\n}\n\nvoid\ncmd_list_panes_window(struct cmd *self, struct session *s, struct winlink *wl,\n    struct cmd_q *cmdq, int type)\n{\n\tstruct args\t\t*args = self->args;\n\tstruct window_pane\t*wp;\n\tu_int\t\t\t n;\n\tstruct format_tree\t*ft;\n\tconst char\t\t*template;\n\tchar\t\t\t*line;\n\n\ttemplate = args_get(args, 'F');\n\tif (template == NULL) {\n\t\tswitch (type) {\n\t\tcase 0:\n\t\t\ttemplate = \"#{pane_index}: \"\n\t\t\t    \"[#{pane_width}x#{pane_height}] [history \"\n\t\t\t    \"#{history_size}/#{history_limit}, \"\n\t\t\t    \"#{history_bytes} bytes] #{pane_id}\"\n\t\t\t    \"#{?pane_active, (active),}#{?pane_dead, (dead),}\";\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\ttemplate = \"#{window_index}.#{pane_index}: \"\n\t\t\t    \"[#{pane_width}x#{pane_height}] [history \"\n\t\t\t    \"#{history_size}/#{history_limit}, \"\n\t\t\t    \"#{history_bytes} bytes] #{pane_id}\"\n\t\t\t    \"#{?pane_active, (active),}#{?pane_dead, (dead),}\";\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\ttemplate = \"#{session_name}:#{window_index}.\"\n\t\t\t    \"#{pane_index}: [#{pane_width}x#{pane_height}] \"\n\t\t\t    \"[history #{history_size}/#{history_limit}, \"\n\t\t\t    \"#{history_bytes} bytes] #{pane_id}\"\n\t\t\t    \"#{?pane_active, (active),}#{?pane_dead, (dead),}\";\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tn = 0;\n\tTAILQ_FOREACH(wp, &wl->window->panes, entry) {\n\t\tft = format_create(cmdq, 0);\n\t\tformat_add(ft, \"line\", \"%u\", n);\n\t\tformat_defaults(ft, NULL, s, wl, wp);\n\n\t\tline = format_expand(ft, template);\n\t\tcmdq_print(cmdq, \"%s\", line);\n\t\tfree(line);\n\n\t\tformat_free(ft);\n\t\tn++;\n\t}\n}\n"
        },
        {
          "name": "cmd-list-sessions.c",
          "type": "blob",
          "size": 2.0654296875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\n#include \"tmux.h\"\n\n/*\n * List all sessions.\n */\n\n#define LIST_SESSIONS_TEMPLATE\t\t\t\t\\\n\t\"#{session_name}: #{session_windows} windows \"\t\\\n\t\"(created #{t:session_created}) \"\t\t\\\n\t\"[#{session_width}x#{session_height}]\"\t\t\\\n\t\"#{?session_grouped, (group ,}\"\t\t\t\\\n\t\"#{session_group}#{?session_grouped,),}\"\t\\\n\t\"#{?session_attached, (attached),}\"\n\nenum cmd_retval\t cmd_list_sessions_exec(struct cmd *, struct cmd_q *);\n\nconst struct cmd_entry cmd_list_sessions_entry = {\n\t.name = \"list-sessions\",\n\t.alias = \"ls\",\n\n\t.args = { \"F:\", 0, 0 },\n\t.usage = \"[-F format]\",\n\n\t.flags = 0,\n\t.exec = cmd_list_sessions_exec\n};\n\nenum cmd_retval\ncmd_list_sessions_exec(struct cmd *self, struct cmd_q *cmdq)\n{\n\tstruct args\t\t*args = self->args;\n\tstruct session\t\t*s;\n\tu_int\t\t \t n;\n\tstruct format_tree\t*ft;\n\tconst char\t\t*template;\n\tchar\t\t\t*line;\n\n\tif ((template = args_get(args, 'F')) == NULL)\n\t\ttemplate = LIST_SESSIONS_TEMPLATE;\n\n\tn = 0;\n\tRB_FOREACH(s, sessions, &sessions) {\n\t\tft = format_create(cmdq, 0);\n\t\tformat_add(ft, \"line\", \"%u\", n);\n\t\tformat_defaults(ft, NULL, s, NULL, NULL);\n\n\t\tline = format_expand(ft, template);\n\t\tcmdq_print(cmdq, \"%s\", line);\n\t\tfree(line);\n\n\t\tformat_free(ft);\n\t\tn++;\n\t}\n\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-list-windows.c",
          "type": "blob",
          "size": 2.9736328125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\n/*\n * List windows on given session.\n */\n\n#define LIST_WINDOWS_TEMPLATE\t\t\t\t\t\\\n\t\"#{window_index}: #{window_name}#{window_flags} \"\t\\\n\t\"(#{window_panes} panes) \"\t\t\t\t\\\n\t\"[#{window_width}x#{window_height}] \"\t\t\t\\\n\t\"[layout #{window_layout}] #{window_id}\"\t\t\\\n\t\"#{?window_active, (active),}\";\n#define LIST_WINDOWS_WITH_SESSION_TEMPLATE\t\t\t\\\n\t\"#{session_name}:\"\t\t\t\t\t\\\n\t\"#{window_index}: #{window_name}#{window_flags} \"\t\\\n\t\"(#{window_panes} panes) \"\t\t\t\t\\\n\t\"[#{window_width}x#{window_height}] \"\n\nenum cmd_retval\t cmd_list_windows_exec(struct cmd *, struct cmd_q *);\n\nvoid\tcmd_list_windows_server(struct cmd *, struct cmd_q *);\nvoid\tcmd_list_windows_session(struct cmd *, struct session *,\n\t    struct cmd_q *, int);\n\nconst struct cmd_entry cmd_list_windows_entry = {\n\t.name = \"list-windows\",\n\t.alias = \"lsw\",\n\n\t.args = { \"F:at:\", 0, 0 },\n\t.usage = \"[-a] [-F format] \" CMD_TARGET_SESSION_USAGE,\n\n\t.tflag = CMD_SESSION,\n\n\t.flags = 0,\n\t.exec = cmd_list_windows_exec\n};\n\nenum cmd_retval\ncmd_list_windows_exec(struct cmd *self, struct cmd_q *cmdq)\n{\n\tstruct args\t*args = self->args;\n\n\tif (args_has(args, 'a'))\n\t\tcmd_list_windows_server(self, cmdq);\n\telse\n\t\tcmd_list_windows_session(self, cmdq->state.tflag.s, cmdq, 0);\n\n\treturn (CMD_RETURN_NORMAL);\n}\n\nvoid\ncmd_list_windows_server(struct cmd *self, struct cmd_q *cmdq)\n{\n\tstruct session\t*s;\n\n\tRB_FOREACH(s, sessions, &sessions)\n\t\tcmd_list_windows_session(self, s, cmdq, 1);\n}\n\nvoid\ncmd_list_windows_session(struct cmd *self, struct session *s,\n    struct cmd_q *cmdq, int type)\n{\n\tstruct args\t\t*args = self->args;\n\tstruct winlink\t\t*wl;\n\tu_int\t\t\tn;\n\tstruct format_tree\t*ft;\n\tconst char\t\t*template;\n\tchar\t\t\t*line;\n\n\ttemplate = args_get(args, 'F');\n\tif (template == NULL) {\n\t\tswitch (type) {\n\t\tcase 0:\n\t\t\ttemplate = LIST_WINDOWS_TEMPLATE;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\ttemplate = LIST_WINDOWS_WITH_SESSION_TEMPLATE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tn = 0;\n\tRB_FOREACH(wl, winlinks, &s->windows) {\n\t\tft = format_create(cmdq, 0);\n\t\tformat_add(ft, \"line\", \"%u\", n);\n\t\tformat_defaults(ft, NULL, s, wl, NULL);\n\n\t\tline = format_expand(ft, template);\n\t\tcmdq_print(cmdq, \"%s\", line);\n\t\tfree(line);\n\n\t\tformat_free(ft);\n\t\tn++;\n\t}\n}\n"
        },
        {
          "name": "cmd-list.c",
          "type": "blob",
          "size": 2.806640625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\nstruct cmd_list *\ncmd_list_parse(int argc, char **argv, const char *file, u_int line,\n    char **cause)\n{\n\tstruct cmd_list\t*cmdlist;\n\tstruct cmd\t*cmd;\n\tint\t\t i, lastsplit;\n\tsize_t\t\t arglen, new_argc;\n\tchar\t       **copy_argv, **new_argv;\n\n\tcopy_argv = cmd_copy_argv(argc, argv);\n\n\tcmdlist = xcalloc(1, sizeof *cmdlist);\n\tcmdlist->references = 1;\n\tTAILQ_INIT(&cmdlist->list);\n\n\tlastsplit = 0;\n\tfor (i = 0; i < argc; i++) {\n\t\targlen = strlen(copy_argv[i]);\n\t\tif (arglen == 0 || copy_argv[i][arglen - 1] != ';')\n\t\t\tcontinue;\n\t\tcopy_argv[i][arglen - 1] = '\\0';\n\n\t\tif (arglen > 1 && copy_argv[i][arglen - 2] == '\\\\') {\n\t\t\tcopy_argv[i][arglen - 2] = ';';\n\t\t\tcontinue;\n\t\t}\n\n\t\tnew_argc = i - lastsplit;\n\t\tnew_argv = copy_argv + lastsplit;\n\t\tif (arglen != 1)\n\t\t\tnew_argc++;\n\n\t\tcmd = cmd_parse(new_argc, new_argv, file, line, cause);\n\t\tif (cmd == NULL)\n\t\t\tgoto bad;\n\t\tTAILQ_INSERT_TAIL(&cmdlist->list, cmd, qentry);\n\n\t\tlastsplit = i + 1;\n\t}\n\n\tif (lastsplit != argc) {\n\t\tcmd = cmd_parse(argc - lastsplit, copy_argv + lastsplit,\n\t\t    file, line, cause);\n\t\tif (cmd == NULL)\n\t\t\tgoto bad;\n\t\tTAILQ_INSERT_TAIL(&cmdlist->list, cmd, qentry);\n\t}\n\n\tcmd_free_argv(argc, copy_argv);\n\treturn (cmdlist);\n\nbad:\n\tcmd_list_free(cmdlist);\n\tcmd_free_argv(argc, copy_argv);\n\treturn (NULL);\n}\n\nvoid\ncmd_list_free(struct cmd_list *cmdlist)\n{\n\tstruct cmd\t*cmd, *cmd1;\n\n\tif (--cmdlist->references != 0)\n\t\treturn;\n\n\tTAILQ_FOREACH_SAFE(cmd, &cmdlist->list, qentry, cmd1) {\n\t\tTAILQ_REMOVE(&cmdlist->list, cmd, qentry);\n\t\targs_free(cmd->args);\n\t\tfree(cmd->file);\n\t\tfree(cmd);\n\t}\n\n\tfree(cmdlist);\n}\n\nchar *\ncmd_list_print(struct cmd_list *cmdlist)\n{\n\tstruct cmd\t*cmd;\n\tchar\t\t*buf, *this;\n\tsize_t\t\t len;\n\n\tlen = 1;\n\tbuf = xcalloc(1, len);\n\n\tTAILQ_FOREACH(cmd, &cmdlist->list, qentry) {\n\t\tthis = cmd_print(cmd);\n\n\t\tlen += strlen(this) + 3;\n\t\tbuf = xrealloc(buf, len);\n\n\t\tstrlcat(buf, this, len);\n\t\tif (TAILQ_NEXT(cmd, qentry) != NULL)\n\t\t\tstrlcat(buf, \" ; \", len);\n\n\t\tfree(this);\n\t}\n\n\treturn (buf);\n}\n"
        },
        {
          "name": "cmd-load-buffer.c",
          "type": "blob",
          "size": 4.1025390625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Tiago Cunha <me@tiagocunha.org>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <errno.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\n/*\n * Loads a paste buffer from a file.\n */\n\nenum cmd_retval\t cmd_load_buffer_exec(struct cmd *, struct cmd_q *);\nvoid\t\t cmd_load_buffer_callback(struct client *, int, void *);\n\nconst struct cmd_entry cmd_load_buffer_entry = {\n\t.name = \"load-buffer\",\n\t.alias = \"loadb\",\n\n\t.args = { \"b:\", 1, 1 },\n\t.usage = CMD_BUFFER_USAGE \" path\",\n\n\t.flags = 0,\n\t.exec = cmd_load_buffer_exec\n};\n\nenum cmd_retval\ncmd_load_buffer_exec(struct cmd *self, struct cmd_q *cmdq)\n{\n\tstruct args\t*args = self->args;\n\tstruct client\t*c = cmdq->client;\n\tstruct session  *s;\n\tFILE\t\t*f;\n\tconst char\t*path, *bufname, *cwd;\n\tchar\t\t*pdata, *new_pdata, *cause, *file, resolved[PATH_MAX];\n\tsize_t\t\t psize;\n\tint\t\t ch, error;\n\n\tbufname = NULL;\n\tif (args_has(args, 'b'))\n\t\tbufname = args_get(args, 'b');\n\n\tpath = args->argv[0];\n\tif (strcmp(path, \"-\") == 0) {\n\t\terror = server_set_stdin_callback(c, cmd_load_buffer_callback,\n\t\t    (void *)bufname, &cause);\n\t\tif (error != 0) {\n\t\t\tcmdq_error(cmdq, \"%s: %s\", path, cause);\n\t\t\tfree(cause);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\treturn (CMD_RETURN_WAIT);\n\t}\n\n\tif (c != NULL && c->session == NULL && c->cwd != NULL)\n\t\tcwd = c->cwd;\n\telse if ((s = c->session) != NULL && s->cwd != NULL)\n\t\tcwd = s->cwd;\n\telse\n\t\tcwd = \".\";\n\n\tif (*path == '/')\n\t\tfile = xstrdup(path);\n\telse\n\t\txasprintf(&file, \"%s/%s\", cwd, path);\n\tif (realpath(file, resolved) == NULL &&\n\t    strlcpy(resolved, file, sizeof resolved) >= sizeof resolved) {\n\t\tcmdq_error(cmdq, \"%s: %s\", file, strerror(ENAMETOOLONG));\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\tf = fopen(resolved, \"rb\");\n\tfree(file);\n\tif (f == NULL) {\n\t\tcmdq_error(cmdq, \"%s: %s\", resolved, strerror(errno));\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\tpdata = NULL;\n\tpsize = 0;\n\twhile ((ch = getc(f)) != EOF) {\n\t\t/* Do not let the server die due to memory exhaustion. */\n\t\tif ((new_pdata = realloc(pdata, psize + 2)) == NULL) {\n\t\t\tcmdq_error(cmdq, \"realloc error: %s\", strerror(errno));\n\t\t\tgoto error;\n\t\t}\n\t\tpdata = new_pdata;\n\t\tpdata[psize++] = ch;\n\t}\n\tif (ferror(f)) {\n\t\tcmdq_error(cmdq, \"%s: read error\", resolved);\n\t\tgoto error;\n\t}\n\tif (pdata != NULL)\n\t\tpdata[psize] = '\\0';\n\n\tfclose(f);\n\n\tif (paste_set(pdata, psize, bufname, &cause) != 0) {\n\t\tcmdq_error(cmdq, \"%s\", cause);\n\t\tfree(pdata);\n\t\tfree(cause);\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\treturn (CMD_RETURN_NORMAL);\n\nerror:\n\tfree(pdata);\n\tif (f != NULL)\n\t\tfclose(f);\n\treturn (CMD_RETURN_ERROR);\n}\n\nvoid\ncmd_load_buffer_callback(struct client *c, int closed, void *data)\n{\n\tconst char\t*bufname = data;\n\tchar\t\t*pdata, *cause, *saved;\n\tsize_t\t\t psize;\n\n\tif (!closed)\n\t\treturn;\n\tc->stdin_callback = NULL;\n\n\tserver_client_unref(c);\n\tif (c->flags & CLIENT_DEAD)\n\t\treturn;\n\n\tpsize = EVBUFFER_LENGTH(c->stdin_data);\n\tif (psize == 0 || (pdata = malloc(psize + 1)) == NULL)\n\t\tgoto out;\n\n\tmemcpy(pdata, EVBUFFER_DATA(c->stdin_data), psize);\n\tpdata[psize] = '\\0';\n\tevbuffer_drain(c->stdin_data, psize);\n\n\tif (paste_set(pdata, psize, bufname, &cause) != 0) {\n\t\t/* No context so can't use server_client_msg_error. */\n\t\tif (~c->flags & CLIENT_UTF8) {\n\t\t\tsaved = cause;\n\t\t\tcause = utf8_sanitize(saved);\n\t\t\tfree(saved);\n\t\t}\n\t\tevbuffer_add_printf(c->stderr_data, \"%s\", cause);\n\t\tserver_client_push_stderr(c);\n\t\tfree(pdata);\n\t\tfree(cause);\n\t}\n\nout:\n\tcmdq_continue(c->cmdq);\n}\n"
        },
        {
          "name": "cmd-lock-server.c",
          "type": "blob",
          "size": 1.8916015625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2008 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include \"tmux.h\"\n\n/*\n * Lock commands.\n */\n\nenum cmd_retval\t cmd_lock_server_exec(struct cmd *, struct cmd_q *);\n\nconst struct cmd_entry cmd_lock_server_entry = {\n\t.name = \"lock-server\",\n\t.alias = \"lock\",\n\n\t.args = { \"\", 0, 0 },\n\t.usage = \"\",\n\n\t.flags = 0,\n\t.exec = cmd_lock_server_exec\n};\n\nconst struct cmd_entry cmd_lock_session_entry = {\n\t.name = \"lock-session\",\n\t.alias = \"locks\",\n\n\t.args = { \"t:\", 0, 0 },\n\t.usage = CMD_TARGET_SESSION_USAGE,\n\n\t.tflag = CMD_SESSION,\n\n\t.flags = 0,\n\t.exec = cmd_lock_server_exec\n};\n\nconst struct cmd_entry cmd_lock_client_entry = {\n\t.name = \"lock-client\",\n\t.alias = \"lockc\",\n\n\t.args = { \"t:\", 0, 0 },\n\t.usage = CMD_TARGET_CLIENT_USAGE,\n\n\t.tflag = CMD_CLIENT,\n\n\t.flags = 0,\n\t.exec = cmd_lock_server_exec\n};\n\nenum cmd_retval\ncmd_lock_server_exec(struct cmd *self, __unused struct cmd_q *cmdq)\n{\n\tif (self->entry == &cmd_lock_server_entry)\n\t\tserver_lock();\n\telse if (self->entry == &cmd_lock_session_entry)\n\t\tserver_lock_session(cmdq->state.tflag.s);\n\telse\n\t\tserver_lock_client(cmdq->state.c);\n\n\trecalculate_sizes();\n\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-move-window.c",
          "type": "blob",
          "size": 2.8935546875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2008 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n\n#include \"tmux.h\"\n\n/*\n * Move a window.\n */\n\nenum cmd_retval\t cmd_move_window_exec(struct cmd *, struct cmd_q *);\n\nconst struct cmd_entry cmd_move_window_entry = {\n\t.name = \"move-window\",\n\t.alias = \"movew\",\n\n\t.args = { \"adkrs:t:\", 0, 0 },\n\t.usage = \"[-dkr] \" CMD_SRCDST_WINDOW_USAGE,\n\n\t.sflag = CMD_WINDOW,\n\t.tflag = CMD_MOVEW_R,\n\n\t.flags = 0,\n\t.exec = cmd_move_window_exec\n};\n\nconst struct cmd_entry cmd_link_window_entry = {\n\t.name = \"link-window\",\n\t.alias = \"linkw\",\n\n\t.args = { \"adks:t:\", 0, 0 },\n\t.usage = \"[-dk] \" CMD_SRCDST_WINDOW_USAGE,\n\n\t.sflag = CMD_WINDOW,\n\t.tflag = CMD_WINDOW_INDEX,\n\n\t.flags = 0,\n\t.exec = cmd_move_window_exec\n};\n\nenum cmd_retval\ncmd_move_window_exec(struct cmd *self, struct cmd_q *cmdq)\n{\n#ifdef TMATE\n\tcmdq_error(cmdq, \"move window is not supported with tmate\");\n\treturn (CMD_RETURN_ERROR);\n#else\n\tstruct args\t*args = self->args;\n\tstruct session\t*src = cmdq->state.sflag.s;\n\tstruct session\t*dst = cmdq->state.tflag.s;\n\tstruct winlink\t*wl = cmdq->state.sflag.wl;\n\tchar\t\t*cause;\n\tint\t\t idx = cmdq->state.tflag.idx, kflag, dflag, sflag;\n\n\tkflag = args_has(self->args, 'k');\n\tdflag = args_has(self->args, 'd');\n\n\tif (args_has(args, 'r')) {\n\t\tsession_renumber_windows(dst);\n\t\trecalculate_sizes();\n\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tkflag = args_has(self->args, 'k');\n\tdflag = args_has(self->args, 'd');\n\tsflag = args_has(self->args, 's');\n\n\tif (args_has(self->args, 'a')) {\n\t\tif ((idx = winlink_shuffle_up(dst, dst->curw)) == -1)\n\t\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\tif (server_link_window(src, wl, dst, idx, kflag, !dflag,\n\t    &cause) != 0) {\n\t\tcmdq_error(cmdq, \"can't link window: %s\", cause);\n\t\tfree(cause);\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\tif (self->entry == &cmd_move_window_entry)\n\t\tserver_unlink_window(src, wl);\n\n\t/*\n\t * Renumber the winlinks in the src session only, the destination\n\t * session already has the correct winlink id to us, either\n\t * automatically or specified by -s.\n\t */\n\tif (!sflag && options_get_number(src->options, \"renumber-windows\"))\n\t\tsession_renumber_windows(src);\n\n\trecalculate_sizes();\n\n\treturn (CMD_RETURN_NORMAL);\n#endif\n}\n"
        },
        {
          "name": "cmd-new-session.c",
          "type": "blob",
          "size": 8.5,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <errno.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <string.h>\n#include <termios.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\n/*\n * Create a new session and attach to the current terminal unless -d is given.\n */\n\n#define NEW_SESSION_TEMPLATE \"#{session_name}:\"\n\nenum cmd_retval\t cmd_new_session_exec(struct cmd *, struct cmd_q *);\n\nconst struct cmd_entry cmd_new_session_entry = {\n\t.name = \"new-session\",\n\t.alias = \"new\",\n\n\t.args = { \"Ac:dDEF:n:Ps:t:x:y:\", 0, -1 },\n\t.usage = \"[-AdDEP] [-c start-directory] [-F format] [-n window-name] \"\n\t\t \"[-s session-name] \" CMD_TARGET_SESSION_USAGE \" [-x width] \"\n\t\t \"[-y height] [command]\",\n\n\t.tflag = CMD_SESSION_CANFAIL,\n\n\t.flags = CMD_STARTSERVER,\n\t.exec = cmd_new_session_exec\n};\n\nconst struct cmd_entry cmd_has_session_entry = {\n\t.name = \"has-session\",\n\t.alias = \"has\",\n\n\t.args = { \"t:\", 0, 0 },\n\t.usage = CMD_TARGET_SESSION_USAGE,\n\n\t.tflag = CMD_SESSION,\n\n\t.flags = 0,\n\t.exec = cmd_new_session_exec\n};\n\nenum cmd_retval\ncmd_new_session_exec(struct cmd *self, struct cmd_q *cmdq)\n{\n\tstruct args\t\t*args = self->args;\n\tstruct client\t\t*c = cmdq->client;\n\tstruct session\t\t*s, *as;\n\tstruct session\t\t*groupwith = cmdq->state.tflag.s;\n\tstruct window\t\t*w;\n\tstruct environ\t\t*env;\n\tstruct termios\t\t tio, *tiop;\n\tconst char\t\t*newname, *target, *update, *errstr, *template;\n\tconst char\t\t*path, *cwd, *to_free = NULL;\n\tchar\t\t       **argv, *cmd, *cause, *cp;\n\tint\t\t\t detached, already_attached, idx, argc;\n\tu_int\t\t\t sx, sy;\n\tstruct format_tree\t*ft;\n\tstruct environ_entry\t*envent;\n\n\tif (self->entry == &cmd_has_session_entry) {\n\t\t/*\n\t\t * cmd_prepare() will fail if the session cannot be found,\n\t\t * hence always return success here.\n\t\t */\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tif (args_has(args, 't') && (args->argc != 0 || args_has(args, 'n'))) {\n\t\tcmdq_error(cmdq, \"command or window name given with target\");\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\tnewname = args_get(args, 's');\n\tif (newname != NULL) {\n\t\tif (!session_check_name(newname)) {\n\t\t\tcmdq_error(cmdq, \"bad session name: %s\", newname);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\tif ((as = session_find(newname)) != NULL) {\n\t\t\tif (args_has(args, 'A')) {\n\t\t\t\t/*\n\t\t\t\t * This cmdq is now destined for\n\t\t\t\t * attach-session.  Because attach-session\n\t\t\t\t * will have already been prepared, copy this\n\t\t\t\t * session into its tflag so it can be used.\n\t\t\t\t */\n\t\t\t\tcmd_find_from_session(&cmdq->state.tflag, as);\n\t\t\t\treturn (cmd_attach_session(cmdq,\n\t\t\t\t    args_has(args, 'D'), 0, NULL,\n\t\t\t\t    args_has(args, 'E')));\n\t\t\t}\n\t\t\tcmdq_error(cmdq, \"duplicate session: %s\", newname);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t}\n\n\tif ((target = args_get(args, 't')) != NULL) {\n\t\tif (groupwith == NULL) {\n\t\t\tcmdq_error(cmdq, \"no such session: %s\", target);\n\t\t\tgoto error;\n\t\t}\n\t} else\n\t\tgroupwith = NULL;\n\n\t/* Set -d if no client. */\n\tdetached = args_has(args, 'd');\n\tif (c == NULL)\n\t\tdetached = 1;\n\n\tif (tmate_foreground)\n\t\tdetached = 1;\n\n\t/* Is this client already attached? */\n\talready_attached = 0;\n\tif (c != NULL && c->session != NULL)\n\t\talready_attached = 1;\n\n\t/* Get the new session working directory. */\n\tif (args_has(args, 'c')) {\n\t\tft = format_create(cmdq, 0);\n\t\tformat_defaults(ft, c, NULL, NULL, NULL);\n\t\tto_free = cwd = format_expand(ft, args_get(args, 'c'));\n\t\tformat_free(ft);\n\t} else if (c != NULL && c->session == NULL && c->cwd != NULL)\n\t\tcwd = c->cwd;\n\telse\n\t\tcwd = \".\";\n\n\t/*\n\t * If this is a new client, check for nesting and save the termios\n\t * settings (part of which is used for new windows in this session).\n\t *\n\t * tcgetattr() is used rather than using tty.tio since if the client is\n\t * detached, tty_open won't be called. It must be done before opening\n\t * the terminal as that calls tcsetattr() to prepare for tmux taking\n\t * over.\n\t */\n\tif (!detached && !already_attached && c->tty.fd != -1) {\n\t\tif (server_client_check_nested(cmdq->client)) {\n\t\t\tcmdq_error(cmdq, \"sessions should be nested with care, \"\n\t\t\t    \"unset $TMUX to force\");\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\tif (tcgetattr(c->tty.fd, &tio) != 0)\n\t\t\tfatal(\"tcgetattr failed\");\n\t\ttiop = &tio;\n\t} else\n\t\ttiop = NULL;\n\n\t/* Open the terminal if necessary. */\n\tif (!detached && !already_attached) {\n\t\tif (server_client_open(c, &cause) != 0) {\n\t\t\tcmdq_error(cmdq, \"open terminal failed: %s\", cause);\n\t\t\tfree(cause);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t/* Find new session size. */\n\tif (c != NULL) {\n\t\tsx = c->tty.sx;\n\t\tsy = c->tty.sy;\n\t} else {\n\t\tsx = 80;\n\t\tsy = 24;\n\t}\n\tif (detached && args_has(args, 'x')) {\n\t\tsx = strtonum(args_get(args, 'x'), 1, USHRT_MAX, &errstr);\n\t\tif (errstr != NULL) {\n\t\t\tcmdq_error(cmdq, \"width %s\", errstr);\n\t\t\tgoto error;\n\t\t}\n\t}\n\tif (detached && args_has(args, 'y')) {\n\t\tsy = strtonum(args_get(args, 'y'), 1, USHRT_MAX, &errstr);\n\t\tif (errstr != NULL) {\n\t\t\tcmdq_error(cmdq, \"height %s\", errstr);\n\t\t\tgoto error;\n\t\t}\n\t}\n\tif (sy > 0 && options_get_number(global_s_options, \"status\"))\n\t\tsy--;\n\tif (sx == 0)\n\t\tsx = 1;\n\tif (sy == 0)\n\t\tsy = 1;\n\n\t/* Figure out the command for the new window. */\n\targc = -1;\n\targv = NULL;\n\tif (!args_has(args, 't') && args->argc != 0) {\n\t\targc = args->argc;\n\t\targv = args->argv;\n\t} else if (groupwith == NULL) {\n\t\tcmd = options_get_string(global_s_options, \"default-command\");\n\t\tif (cmd != NULL && *cmd != '\\0') {\n\t\t\targc = 1;\n\t\t\targv = &cmd;\n\t\t} else {\n\t\t\targc = 0;\n\t\t\targv = NULL;\n\t\t}\n\t}\n\n\tpath = NULL;\n\tif (c != NULL && c->session == NULL)\n\t\tenvent = environ_find(c->environ, \"PATH\");\n\telse\n\t\tenvent = environ_find(global_environ, \"PATH\");\n\tif (envent != NULL)\n\t\tpath = envent->value;\n\n\t/* Construct the environment. */\n\tenv = environ_create();\n\tif (c != NULL && !args_has(args, 'E')) {\n\t\tupdate = options_get_string(global_s_options,\n\t\t    \"update-environment\");\n\t\tenviron_update(update, c->environ, env);\n\t}\n\n\t/* Create the new session. */\n\tidx = -1 - options_get_number(global_s_options, \"base-index\");\n\ts = session_create(newname, argc, argv, path, cwd, env, tiop, idx, sx,\n\t    sy, &cause);\n\tenviron_free(env);\n\tif (s == NULL) {\n\t\tcmdq_error(cmdq, \"create session failed: %s\", cause);\n\t\tfree(cause);\n\t\tgoto error;\n\t}\n\n\t/* Set the initial window name if one given. */\n\tif (argc >= 0 && args_has(args, 'n')) {\n\t\tw = s->curw->window;\n\t\twindow_set_name(w, args_get(args, 'n'));\n\t\toptions_set_number(w->options, \"automatic-rename\", 0);\n\t}\n\n\t/*\n\t * If a target session is given, this is to be part of a session group,\n\t * so add it to the group and synchronize.\n\t */\n\tif (groupwith != NULL) {\n\t\tsession_group_add(groupwith, s);\n\t\tsession_group_synchronize_to(s);\n\t\tsession_select(s, RB_MIN(winlinks, &s->windows)->idx);\n\t}\n\n\t/*\n\t * Set the client to the new session. If a command client exists, it is\n\t * taking this session and needs to get MSG_READY and stay around.\n\t */\n\tif (!detached) {\n\t\tif (!already_attached) {\n\t\t\tif (~c->flags & CLIENT_CONTROL)\n\t\t\t\tproc_send(c->peer, MSG_READY, -1, NULL, 0);\n\t\t} else if (c->session != NULL)\n\t\t\tc->last_session = c->session;\n\t\tc->session = s;\n\t\tserver_client_set_key_table(c, NULL);\n\t\tstatus_timer_start(c);\n\t\tnotify_attached_session_changed(c);\n\t\tsession_update_activity(s, NULL);\n\t\tgettimeofday(&s->last_attached_time, NULL);\n\t\tserver_redraw_client(c);\n\t}\n\trecalculate_sizes();\n\tserver_update_socket();\n\n\t/*\n\t * If there are still configuration file errors to display, put the new\n\t * session's current window into more mode and display them now.\n\t */\n\tif (cfg_finished)\n\t\tcfg_show_causes(s);\n\n\t/* Print if requested. */\n\tif (args_has(args, 'P')) {\n\t\tif ((template = args_get(args, 'F')) == NULL)\n\t\t\ttemplate = NEW_SESSION_TEMPLATE;\n\n\t\tft = format_create(cmdq, 0);\n\t\tformat_defaults(ft, c, s, NULL, NULL);\n\n\t\tcp = format_expand(ft, template);\n\t\tcmdq_print(cmdq, \"%s\", cp);\n\t\tfree(cp);\n\n\t\tformat_free(ft);\n\t}\n\n\tif (!detached)\n\t\tcmdq->client_exit = 0;\n\n\tif (to_free != NULL)\n\t\tfree((void *)to_free);\n\treturn (CMD_RETURN_NORMAL);\n\nerror:\n\tif (to_free != NULL)\n\t\tfree((void *)to_free);\n\treturn (CMD_RETURN_ERROR);\n}\n"
        },
        {
          "name": "cmd-new-window.c",
          "type": "blob",
          "size": 4.1025390625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <errno.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\n/*\n * Create a new window.\n */\n\n#define NEW_WINDOW_TEMPLATE \"#{session_name}:#{window_index}.#{pane_index}\"\n\nenum cmd_retval\tcmd_new_window_exec(struct cmd *, struct cmd_q *);\n\nconst struct cmd_entry cmd_new_window_entry = {\n\t.name = \"new-window\",\n\t.alias = \"neww\",\n\n\t.args = { \"ac:dF:kn:Pt:\", 0, -1 },\n\t.usage = \"[-adkP] [-c start-directory] [-F format] [-n window-name] \"\n\t\t CMD_TARGET_WINDOW_USAGE \" [command]\",\n\n\t.tflag = CMD_WINDOW_INDEX,\n\n\t.flags = 0,\n\t.exec = cmd_new_window_exec\n};\n\nenum cmd_retval\ncmd_new_window_exec(struct cmd *self, struct cmd_q *cmdq)\n{\n\tstruct args\t\t*args = self->args;\n\tstruct session\t\t*s = cmdq->state.tflag.s;\n\tstruct winlink\t\t*wl = cmdq->state.tflag.wl;\n\tstruct client\t\t*c = cmdq->state.c;\n\tint\t\t\t idx = cmdq->state.tflag.idx;\n\tconst char\t\t*cmd, *path, *template, *cwd, *to_free;\n\tchar\t\t       **argv, *cause, *cp;\n\tint\t\t\t argc, detached;\n\tstruct format_tree\t*ft;\n\tstruct environ_entry\t*envent;\n\n\tif (args_has(args, 'a')) {\n\t\tif ((idx = winlink_shuffle_up(s, wl)) == -1) {\n\t\t\tcmdq_error(cmdq, \"no free window indexes\");\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t}\n\tdetached = args_has(args, 'd');\n\n\tif (args->argc == 0) {\n\t\tcmd = options_get_string(s->options, \"default-command\");\n\t\tif (cmd != NULL && *cmd != '\\0') {\n\t\t\targc = 1;\n\t\t\targv = (char **)&cmd;\n\t\t} else {\n\t\t\targc = 0;\n\t\t\targv = NULL;\n\t\t}\n\t} else {\n\t\targc = args->argc;\n\t\targv = args->argv;\n\t}\n\n\tpath = NULL;\n\tif (cmdq->client != NULL && cmdq->client->session == NULL)\n\t\tenvent = environ_find(cmdq->client->environ, \"PATH\");\n\telse\n\t\tenvent = environ_find(s->environ, \"PATH\");\n\tif (envent != NULL)\n\t\tpath = envent->value;\n\n\tto_free = NULL;\n\tif (args_has(args, 'c')) {\n\t\tft = format_create(cmdq, 0);\n\t\tformat_defaults(ft, c, s, NULL, NULL);\n\t\tcwd = to_free = format_expand(ft, args_get(args, 'c'));\n\t\tformat_free(ft);\n\t} else if (cmdq->client != NULL && cmdq->client->session == NULL)\n\t\tcwd = cmdq->client->cwd;\n\telse\n\t\tcwd = s->cwd;\n\n\twl = NULL;\n\tif (idx != -1)\n\t\twl = winlink_find_by_index(&s->windows, idx);\n\tif (wl != NULL && args_has(args, 'k')) {\n\t\t/*\n\t\t * Can't use session_detach as it will destroy session if this\n\t\t * makes it empty.\n\t\t */\n\t\tnotify_window_unlinked(s, wl->window);\n\t\twl->flags &= ~WINLINK_ALERTFLAGS;\n\t\twinlink_stack_remove(&s->lastw, wl);\n\t\twinlink_remove(&s->windows, wl);\n\n\t\t/* Force select/redraw if current. */\n\t\tif (wl == s->curw) {\n\t\t\tdetached = 0;\n\t\t\ts->curw = NULL;\n\t\t}\n\t}\n\n\tif (idx == -1)\n\t\tidx = -1 - options_get_number(s->options, \"base-index\");\n\twl = session_new(s, args_get(args, 'n'), argc, argv, path, cwd, idx,\n\t\t&cause);\n\tif (wl == NULL) {\n\t\tcmdq_error(cmdq, \"create window failed: %s\", cause);\n\t\tfree(cause);\n\t\tgoto error;\n\t}\n\tif (!detached) {\n\t\tsession_select(s, wl->idx);\n\t\tserver_redraw_session_group(s);\n\t} else\n\t\tserver_status_session_group(s);\n\n\tif (args_has(args, 'P')) {\n\t\tif ((template = args_get(args, 'F')) == NULL)\n\t\t\ttemplate = NEW_WINDOW_TEMPLATE;\n\n\t\tft = format_create(cmdq, 0);\n\t\tformat_defaults(ft, c, s, wl, NULL);\n\n\t\tcp = format_expand(ft, template);\n\t\tcmdq_print(cmdq, \"%s\", cp);\n\t\tfree(cp);\n\n\t\tformat_free(ft);\n\t}\n\n\tif (to_free != NULL)\n\t\tfree((void *)to_free);\n\treturn (CMD_RETURN_NORMAL);\n\nerror:\n\tif (to_free != NULL)\n\t\tfree((void *)to_free);\n\treturn (CMD_RETURN_ERROR);\n}\n"
        },
        {
          "name": "cmd-paste-buffer.c",
          "type": "blob",
          "size": 2.8330078125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * Paste paste buffer if present.\n */\n\nenum cmd_retval\t cmd_paste_buffer_exec(struct cmd *, struct cmd_q *);\n\nvoid\tcmd_paste_buffer_filter(struct window_pane *,\n\t    const char *, size_t, const char *, int);\n\nconst struct cmd_entry cmd_paste_buffer_entry = {\n\t.name = \"paste-buffer\",\n\t.alias = \"pasteb\",\n\n\t.args = { \"db:prs:t:\", 0, 0 },\n\t.usage = \"[-dpr] [-s separator] \" CMD_BUFFER_USAGE \" \"\n\t\t CMD_TARGET_PANE_USAGE,\n\n\t.tflag = CMD_PANE,\n\n\t.flags = 0,\n\t.exec = cmd_paste_buffer_exec\n};\n\nenum cmd_retval\ncmd_paste_buffer_exec(struct cmd *self, struct cmd_q *cmdq)\n{\n\tstruct args\t\t*args = self->args;\n\tstruct window_pane\t*wp = cmdq->state.tflag.wp;\n\tstruct paste_buffer\t*pb;\n\tconst char\t\t*sepstr, *bufname, *bufdata, *bufend, *line;\n\tsize_t\t\t\t seplen, bufsize;\n\tint\t\t\t bracket = args_has(args, 'p');\n\n\tbufname = NULL;\n\tif (args_has(args, 'b'))\n\t\tbufname = args_get(args, 'b');\n\n\tif (bufname == NULL)\n\t\tpb = paste_get_top(NULL);\n\telse {\n\t\tpb = paste_get_name(bufname);\n\t\tif (pb == NULL) {\n\t\t\tcmdq_error(cmdq, \"no buffer %s\", bufname);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t}\n\n\tif (pb != NULL && ~wp->flags & PANE_INPUTOFF) {\n\t\tsepstr = args_get(args, 's');\n\t\tif (sepstr == NULL) {\n\t\t\tif (args_has(args, 'r'))\n\t\t\t\tsepstr = \"\\n\";\n\t\t\telse\n\t\t\t\tsepstr = \"\\r\";\n\t\t}\n\t\tseplen = strlen(sepstr);\n\n\t\tif (bracket && (wp->screen->mode & MODE_BRACKETPASTE))\n\t\t\tbufferevent_write(wp->event, \"\\033[200~\", 6);\n\n\t\tbufdata = paste_buffer_data(pb, &bufsize);\n\t\tbufend = bufdata + bufsize;\n\n\t\tfor (;;) {\n\t\t\tline = memchr(bufdata, '\\n', bufend - bufdata);\n\t\t\tif (line == NULL)\n\t\t\t\tbreak;\n\n\t\t\tbufferevent_write(wp->event, bufdata, line - bufdata);\n\t\t\tbufferevent_write(wp->event, sepstr, seplen);\n\n\t\t\tbufdata = line + 1;\n\t\t}\n\t\tif (bufdata != bufend)\n\t\t\tbufferevent_write(wp->event, bufdata, bufend - bufdata);\n\n\t\tif (bracket && (wp->screen->mode & MODE_BRACKETPASTE))\n\t\t\tbufferevent_write(wp->event, \"\\033[201~\", 6);\n\t}\n\n\tif (pb != NULL && args_has(args, 'd'))\n\t\tpaste_free(pb);\n\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-pipe-pane.c",
          "type": "blob",
          "size": 3.8955078125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/socket.h>\n\n#include <errno.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\n/*\n * Open pipe to redirect pane output. If already open, close first.\n */\n\nenum cmd_retval\t cmd_pipe_pane_exec(struct cmd *, struct cmd_q *);\n\nvoid\tcmd_pipe_pane_error_callback(struct bufferevent *, short, void *);\n\nconst struct cmd_entry cmd_pipe_pane_entry = {\n\t.name = \"pipe-pane\",\n\t.alias = \"pipep\",\n\n\t.args = { \"ot:\", 0, 1 },\n\t.usage = \"[-o] \" CMD_TARGET_PANE_USAGE \" [command]\",\n\n\t.tflag = CMD_PANE,\n\n\t.flags = 0,\n\t.exec = cmd_pipe_pane_exec\n};\n\nenum cmd_retval\ncmd_pipe_pane_exec(struct cmd *self, struct cmd_q *cmdq)\n{\n\tstruct args\t\t*args = self->args;\n\tstruct client\t\t*c = cmdq->state.c;\n\tstruct window_pane\t*wp = cmdq->state.tflag.wp;\n\tstruct session\t\t*s = cmdq->state.tflag.s;\n\tstruct winlink\t\t*wl = cmdq->state.tflag.wl;\n\tchar\t\t\t*cmd;\n\tint\t\t\t old_fd, pipe_fd[2], null_fd;\n\tstruct format_tree\t*ft;\n\n\t/* Destroy the old pipe. */\n\told_fd = wp->pipe_fd;\n\tif (wp->pipe_fd != -1) {\n\t\tbufferevent_free(wp->pipe_event);\n\t\tclose(wp->pipe_fd);\n\t\twp->pipe_fd = -1;\n\t}\n\n\t/* If no pipe command, that is enough. */\n\tif (args->argc == 0 || *args->argv[0] == '\\0')\n\t\treturn (CMD_RETURN_NORMAL);\n\n\t/*\n\t * With -o, only open the new pipe if there was no previous one. This\n\t * allows a pipe to be toggled with a single key, for example:\n\t *\n\t *\tbind ^p pipep -o 'cat >>~/output'\n\t */\n\tif (args_has(self->args, 'o') && old_fd != -1)\n\t\treturn (CMD_RETURN_NORMAL);\n\n\t/* Open the new pipe. */\n\tif (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, pipe_fd) != 0) {\n\t\tcmdq_error(cmdq, \"socketpair error: %s\", strerror(errno));\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\t/* Expand the command. */\n\tft = format_create(cmdq, 0);\n\tformat_defaults(ft, c, s, wl, wp);\n\tcmd = format_expand_time(ft, args->argv[0], time(NULL));\n\tformat_free(ft);\n\n\t/* Fork the child. */\n\tswitch (fork()) {\n\tcase -1:\n\t\tcmdq_error(cmdq, \"fork error: %s\", strerror(errno));\n\n\t\tfree(cmd);\n\t\treturn (CMD_RETURN_ERROR);\n\tcase 0:\n\t\t/* Child process. */\n\t\tclose(pipe_fd[0]);\n\t\tclear_signals(1);\n\n\t\tif (dup2(pipe_fd[1], STDIN_FILENO) == -1)\n\t\t\t_exit(1);\n\t\tif (pipe_fd[1] != STDIN_FILENO)\n\t\t\tclose(pipe_fd[1]);\n\n\t\tnull_fd = open(_PATH_DEVNULL, O_WRONLY, 0);\n\t\tif (dup2(null_fd, STDOUT_FILENO) == -1)\n\t\t\t_exit(1);\n\t\tif (dup2(null_fd, STDERR_FILENO) == -1)\n\t\t\t_exit(1);\n\t\tif (null_fd != STDOUT_FILENO && null_fd != STDERR_FILENO)\n\t\t\tclose(null_fd);\n\n\t\tclosefrom(STDERR_FILENO + 1);\n\n\t\texecl(_PATH_BSHELL, \"sh\", \"-c\", cmd, (char *) NULL);\n\t\t_exit(1);\n\tdefault:\n\t\t/* Parent process. */\n\t\tclose(pipe_fd[1]);\n\n\t\twp->pipe_fd = pipe_fd[0];\n\t\twp->pipe_off = EVBUFFER_LENGTH(wp->event->input);\n\n\t\twp->pipe_event = bufferevent_new(wp->pipe_fd,\n\t\t    NULL, NULL, cmd_pipe_pane_error_callback, wp);\n\t\tbufferevent_enable(wp->pipe_event, EV_WRITE);\n\n\t\tsetblocking(wp->pipe_fd, 0);\n\n\t\tfree(cmd);\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n}\n\nvoid\ncmd_pipe_pane_error_callback(__unused struct bufferevent *bufev,\n    __unused short what, void *data)\n{\n\tstruct window_pane\t*wp = data;\n\n\tbufferevent_free(wp->pipe_event);\n\tclose(wp->pipe_fd);\n\twp->pipe_fd = -1;\n}\n"
        },
        {
          "name": "cmd-queue.c",
          "type": "blob",
          "size": 6.6416015625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2013 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <ctype.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\n#include \"tmux.h\"\n#include \"tmate.h\"\n\nstatic enum cmd_retval\tcmdq_continue_one(struct cmd_q *);\n\n/* Create new command queue. */\nstruct cmd_q *\ncmdq_new(struct client *c)\n{\n\tstruct cmd_q\t*cmdq;\n\n\tcmdq = xcalloc(1, sizeof *cmdq);\n\tcmdq->references = 1;\n\tcmdq->flags = 0;\n\n\tcmdq->client = c;\n\tcmdq->client_exit = -1;\n\n\tTAILQ_INIT(&cmdq->queue);\n\tcmdq->item = NULL;\n\tcmdq->cmd = NULL;\n\n\tcmd_find_clear_state(&cmdq->current, NULL, 0);\n\tcmdq->parent = NULL;\n\n\treturn (cmdq);\n}\n\n/* Free command queue */\nint\ncmdq_free(struct cmd_q *cmdq)\n{\n\tif (--cmdq->references != 0) {\n\t\tif (cmdq->flags & CMD_Q_DEAD)\n\t\t\treturn (1);\n\t\treturn (0);\n\t}\n\n\tcmdq_flush(cmdq);\n\tfree(cmdq);\n\treturn (1);\n}\n\n/* Show message from command. */\nvoid\ncmdq_print(struct cmd_q *cmdq, const char *fmt, ...)\n{\n\tstruct client\t*c = cmdq->client;\n\tstruct window\t*w;\n\tva_list\t\t ap;\n\tchar\t\t*tmp, *msg;\n\n\tva_start(ap, fmt);\n\n\tif (c == NULL)\n\t\t/* nothing */;\n\telse if (c->session == NULL || (c->flags & CLIENT_CONTROL)) {\n\t\tif (~c->flags & CLIENT_UTF8) {\n\t\t\tvasprintf(&tmp, fmt, ap);\n\t\t\tmsg = utf8_sanitize(tmp);\n\t\t\tfree(tmp);\n\t\t\tevbuffer_add(c->stdout_data, msg, strlen(msg));\n\t\t\tfree(msg);\n\t\t} else\n\t\t\tevbuffer_add_vprintf(c->stdout_data, fmt, ap);\n\t\tevbuffer_add(c->stdout_data, \"\\n\", 1);\n\t\tserver_client_push_stdout(c);\n\t} else {\n\t\tw = c->session->curw->window;\n\t\tif (w->active->mode != &window_copy_mode) {\n\t\t\twindow_pane_reset_mode(w->active);\n\t\t\twindow_pane_set_mode(w->active, &window_copy_mode);\n\t\t\twindow_copy_init_for_output(w->active);\n#ifdef TMATE\n\t\t\ttmate_sync_copy_mode(w->active);\n#endif\n\t\t}\n\t\twindow_copy_vadd(w->active, fmt, ap);\n\t}\n\n\tva_end(ap);\n}\n\n/* Show error from command. */\nvoid\ncmdq_error(struct cmd_q *cmdq, const char *fmt, ...)\n{\n\tstruct client\t*c = cmdq->client;\n\tstruct cmd\t*cmd = cmdq->cmd;\n\tva_list\t\t ap;\n\tchar\t\t*msg;\n\tsize_t\t\t msglen;\n\tchar\t\t*tmp;\n\n\tva_start(ap, fmt);\n\tmsglen = xvasprintf(&msg, fmt, ap);\n\tva_end(ap);\n\n\tif (c == NULL)\n#ifdef TMATE\n\t\tif (cmd->file && cmd->line)\n\t\t\tcfg_add_cause(\"%s:%u: %s\", cmd->file, cmd->line, msg);\n\t\telse\n\t\t\tcfg_add_cause(\"%s\", msg);\n#else\n\t\tcfg_add_cause(\"%s:%u: %s\", cmd->file, cmd->line, msg);\n#endif\n\telse if (c->session == NULL || (c->flags & CLIENT_CONTROL)) {\n\t\tif (~c->flags & CLIENT_UTF8) {\n\t\t\ttmp = msg;\n\t\t\tmsg = utf8_sanitize(tmp);\n\t\t\tfree(tmp);\n\t\t\tmsglen = strlen(msg);\n\t\t}\n\t\tevbuffer_add(c->stderr_data, msg, msglen);\n\t\tevbuffer_add(c->stderr_data, \"\\n\", 1);\n\t\tserver_client_push_stderr(c);\n\t\tc->retval = 1;\n\t} else {\n\t\t*msg = toupper((u_char) *msg);\n\t\tstatus_message_set(c, \"%s\", msg);\n\t}\n\n\tfree(msg);\n}\n\n/* Print a guard line. */\nvoid\ncmdq_guard(struct cmd_q *cmdq, const char *guard, int flags)\n{\n\tstruct client\t*c = cmdq->client;\n\n\tif (c == NULL || !(c->flags & CLIENT_CONTROL))\n\t\treturn;\n\n\tevbuffer_add_printf(c->stdout_data, \"%%%s %ld %u %d\\n\", guard,\n\t    (long) cmdq->time, cmdq->number, flags);\n\tserver_client_push_stdout(c);\n}\n\n/* Add command list to queue and begin processing if needed. */\nvoid\ncmdq_run(struct cmd_q *cmdq, struct cmd_list *cmdlist, struct mouse_event *m)\n{\n\tcmdq_append(cmdq, cmdlist, m);\n\n\tif (cmdq->item == NULL) {\n\t\tcmdq->cmd = NULL;\n\t\tcmdq_continue(cmdq);\n\t}\n}\n\n/* Add command list to queue. */\nvoid\ncmdq_append(struct cmd_q *cmdq, struct cmd_list *cmdlist, struct mouse_event *m)\n{\n\tstruct cmd_q_item\t*item;\n\n\titem = xcalloc(1, sizeof *item);\n\titem->cmdlist = cmdlist;\n\tTAILQ_INSERT_TAIL(&cmdq->queue, item, qentry);\n\tcmdlist->references++;\n\n\tif (m != NULL)\n\t\tmemcpy(&item->mouse, m, sizeof item->mouse);\n\telse\n\t\titem->mouse.valid = 0;\n}\n\n/* Process one command. */\nstatic enum cmd_retval\ncmdq_continue_one(struct cmd_q *cmdq)\n{\n\tstruct cmd\t*cmd = cmdq->cmd;\n\tenum cmd_retval\t retval;\n\tchar\t\t*tmp;\n\tint\t\t flags = !!(cmd->flags & CMD_CONTROL);\n\n#ifdef TMATE\n\tif (tmate_should_replicate_cmd(cmd->entry))\n\t\ttmate_exec_cmd(cmd);\n#endif\n\n\ttmp = cmd_print(cmd);\n\tlog_debug(\"cmdq %p: %s\", cmdq, tmp);\n\tfree(tmp);\n\n\tcmdq->time = time(NULL);\n\tcmdq->number++;\n\n\tcmdq_guard(cmdq, \"begin\", flags);\n\n\tif (cmd_prepare_state(cmd, cmdq, NULL) != 0)\n\t\tgoto error;\n\tretval = cmd->entry->exec(cmd, cmdq);\n\tif (retval == CMD_RETURN_ERROR)\n\t\tgoto error;\n\n\tcmdq_guard(cmdq, \"end\", flags);\n\treturn (retval);\n\nerror:\n\tcmdq_guard(cmdq, \"error\", flags);\n\treturn (CMD_RETURN_ERROR);\n}\n\n/* Continue processing command queue. Returns 1 if finishes empty. */\nint\ncmdq_continue(struct cmd_q *cmdq)\n{\n\tstruct client\t\t*c = cmdq->client;\n\tstruct cmd_q_item\t*next;\n\tenum cmd_retval\t\t retval;\n\tint\t\t\t empty;\n\n\tcmdq->references++;\n\tnotify_disable();\n\n\tlog_debug(\"continuing cmdq %p: flags %#x, client %p\", cmdq, cmdq->flags,\n\t    c);\n\n\tempty = TAILQ_EMPTY(&cmdq->queue);\n\tif (empty)\n\t\tgoto empty;\n\n\tif (cmdq->item == NULL) {\n\t\tcmdq->item = TAILQ_FIRST(&cmdq->queue);\n\t\tcmdq->cmd = TAILQ_FIRST(&cmdq->item->cmdlist->list);\n\t} else\n\t\tcmdq->cmd = TAILQ_NEXT(cmdq->cmd, qentry);\n\n\tdo {\n\t\twhile (cmdq->cmd != NULL) {\n\t\t\tretval = cmdq_continue_one(cmdq);\n\t\t\tif (retval == CMD_RETURN_ERROR)\n\t\t\t\tbreak;\n\t\t\tif (retval == CMD_RETURN_WAIT)\n\t\t\t\tgoto out;\n\t\t\tif (retval == CMD_RETURN_STOP) {\n\t\t\t\tcmdq_flush(cmdq);\n\t\t\t\tgoto empty;\n\t\t\t}\n\t\t\tcmdq->cmd = TAILQ_NEXT(cmdq->cmd, qentry);\n\t\t}\n\t\tnext = TAILQ_NEXT(cmdq->item, qentry);\n\n\t\tTAILQ_REMOVE(&cmdq->queue, cmdq->item, qentry);\n\t\tcmd_list_free(cmdq->item->cmdlist);\n\t\tfree(cmdq->item);\n\n\t\tcmdq->item = next;\n\t\tif (cmdq->item != NULL)\n\t\t\tcmdq->cmd = TAILQ_FIRST(&cmdq->item->cmdlist->list);\n\t} while (cmdq->item != NULL);\n\nempty:\n\tif (cmdq->client_exit > 0)\n\t\tcmdq->client->flags |= CLIENT_EXIT;\n\tif (cmdq->emptyfn != NULL)\n\t\tcmdq->emptyfn(cmdq);\n\tempty = 1;\n\nout:\n\tnotify_enable();\n\tcmdq_free(cmdq);\n\n\treturn (empty);\n}\n\n/* Flush command queue. */\nvoid\ncmdq_flush(struct cmd_q *cmdq)\n{\n\tstruct cmd_q_item\t*item, *item1;\n\n\tTAILQ_FOREACH_SAFE(item, &cmdq->queue, qentry, item1) {\n\t\tTAILQ_REMOVE(&cmdq->queue, item, qentry);\n\t\tcmd_list_free(item->cmdlist);\n\t\tfree(item);\n\t}\n\tcmdq->item = NULL;\n}\n\n"
        },
        {
          "name": "cmd-refresh-client.c",
          "type": "blob",
          "size": 2.1630859375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include \"tmux.h\"\n\n/*\n * Refresh client.\n */\n\nenum cmd_retval\t cmd_refresh_client_exec(struct cmd *, struct cmd_q *);\n\nconst struct cmd_entry cmd_refresh_client_entry = {\n\t.name = \"refresh-client\",\n\t.alias = \"refresh\",\n\n\t.args = { \"C:St:\", 0, 0 },\n\t.usage = \"[-S] [-C size] \" CMD_TARGET_CLIENT_USAGE,\n\n\t.tflag = CMD_CLIENT,\n\n\t.flags = 0,\n\t.exec = cmd_refresh_client_exec\n};\n\nenum cmd_retval\ncmd_refresh_client_exec(struct cmd *self, struct cmd_q *cmdq)\n{\n\tstruct args\t*args = self->args;\n\tstruct client\t*c = cmdq->state.c;\n\tconst char\t*size;\n\tu_int\t\t w, h;\n\n\tif (args_has(args, 'C')) {\n\t\tif ((size = args_get(args, 'C')) == NULL) {\n\t\t\tcmdq_error(cmdq, \"missing size\");\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\tif (sscanf(size, \"%u,%u\", &w, &h) != 2) {\n\t\t\tcmdq_error(cmdq, \"bad size argument\");\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\tif (w < PANE_MINIMUM || w > 5000 ||\n\t\t    h < PANE_MINIMUM || h > 5000) {\n\t\t\tcmdq_error(cmdq, \"size too small or too big\");\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\tif (!(c->flags & CLIENT_CONTROL)) {\n\t\t\tcmdq_error(cmdq, \"not a control client\");\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\tif (tty_set_size(&c->tty, w, h))\n\t\t\trecalculate_sizes();\n\t} else if (args_has(args, 'S')) {\n\t\tc->flags |= CLIENT_STATUSFORCE;\n\t\tserver_status_client(c);\n\t} else {\n\t\tc->flags |= CLIENT_STATUSFORCE;\n\t\tserver_redraw_client(c);\n\t}\n\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-rename-session.c",
          "type": "blob",
          "size": 1.8583984375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n\n#include \"tmux.h\"\n\n/*\n * Change session name.\n */\n\nenum cmd_retval\t cmd_rename_session_exec(struct cmd *, struct cmd_q *);\n\nconst struct cmd_entry cmd_rename_session_entry = {\n\t.name = \"rename-session\",\n\t.alias = \"rename\",\n\n\t.args = { \"t:\", 1, 1 },\n\t.usage = CMD_TARGET_SESSION_USAGE \" new-name\",\n\n\t.tflag = CMD_SESSION,\n\n\t.flags = 0,\n\t.exec = cmd_rename_session_exec\n};\n\nenum cmd_retval\ncmd_rename_session_exec(struct cmd *self, struct cmd_q *cmdq)\n{\n\tstruct args\t*args = self->args;\n\tstruct session\t*s = cmdq->state.tflag.s;\n\tconst char\t*newname;\n\n\tnewname = args->argv[0];\n\tif (!session_check_name(newname)) {\n\t\tcmdq_error(cmdq, \"bad session name: %s\", newname);\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\tif (session_find(newname) != NULL) {\n\t\tcmdq_error(cmdq, \"duplicate session: %s\", newname);\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\tRB_REMOVE(sessions, &sessions, s);\n\tfree(s->name);\n\ts->name = xstrdup(newname);\n\tRB_INSERT(sessions, &sessions, s);\n\n\tserver_status_session(s);\n\tnotify_session_renamed(s);\n\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-rename-window.c",
          "type": "blob",
          "size": 1.5361328125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n\n#include \"tmux.h\"\n\n/*\n * Rename a window.\n */\n\nenum cmd_retval\t cmd_rename_window_exec(struct cmd *, struct cmd_q *);\n\nconst struct cmd_entry cmd_rename_window_entry = {\n\t.name = \"rename-window\",\n\t.alias = \"renamew\",\n\n\t.args = { \"t:\", 1, 1 },\n\t.usage = CMD_TARGET_WINDOW_USAGE \" new-name\",\n\n\t.tflag = CMD_WINDOW,\n\n\t.flags = 0,\n\t.exec = cmd_rename_window_exec\n};\n\nenum cmd_retval\ncmd_rename_window_exec(struct cmd *self, struct cmd_q *cmdq)\n{\n\tstruct args\t*args = self->args;\n\tstruct winlink\t*wl = cmdq->state.tflag.wl;\n\n\twindow_set_name(wl->window, args->argv[0]);\n\toptions_set_number(wl->window->options, \"automatic-rename\", 0);\n\n\tserver_status_window(wl->window);\n\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-resize-pane.c",
          "type": "blob",
          "size": 4.4443359375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n\n#include \"tmux.h\"\n\n/*\n * Increase or decrease pane size.\n */\n\nenum cmd_retval\t cmd_resize_pane_exec(struct cmd *, struct cmd_q *);\n\nvoid\tcmd_resize_pane_mouse_update(struct client *, struct mouse_event *);\n\nconst struct cmd_entry cmd_resize_pane_entry = {\n\t.name = \"resize-pane\",\n\t.alias = \"resizep\",\n\n\t.args = { \"DLMRt:Ux:y:Z\", 0, 1 },\n\t.usage = \"[-DLMRUZ] [-x width] [-y height] \" CMD_TARGET_PANE_USAGE \" \"\n\t\t \"[adjustment]\",\n\n\t.tflag = CMD_PANE,\n\n\t.flags = 0,\n\t.exec = cmd_resize_pane_exec\n};\n\nenum cmd_retval\ncmd_resize_pane_exec(struct cmd *self, struct cmd_q *cmdq)\n{\n\tstruct args\t\t*args = self->args;\n\tstruct window_pane\t*wp = cmdq->state.tflag.wp;\n\tstruct winlink\t\t*wl = cmdq->state.tflag.wl;\n\tstruct window\t\t*w = wl->window;\n\tstruct client\t\t*c = cmdq->client;\n\tstruct session\t\t*s = cmdq->state.tflag.s;\n\tconst char\t       \t*errstr;\n\tchar\t\t\t*cause;\n\tu_int\t\t\t adjust;\n\tint\t\t\t x, y;\n\n\tif (args_has(args, 'M')) {\n\t\tif (cmd_mouse_window(&cmdq->item->mouse, &s) == NULL)\n\t\t\treturn (CMD_RETURN_NORMAL);\n\t\tif (c == NULL || c->session != s)\n\t\t\treturn (CMD_RETURN_NORMAL);\n\t\tc->tty.mouse_drag_update = cmd_resize_pane_mouse_update;\n\t\tcmd_resize_pane_mouse_update(c, &cmdq->item->mouse);\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tif (args_has(args, 'Z')) {\n\t\tif (w->flags & WINDOW_ZOOMED)\n\t\t\twindow_unzoom(w);\n\t\telse\n\t\t\twindow_zoom(wp);\n\t\tserver_redraw_window(w);\n\t\tserver_status_window(w);\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\tserver_unzoom_window(w);\n\n\tif (args->argc == 0)\n\t\tadjust = 1;\n\telse {\n\t\tadjust = strtonum(args->argv[0], 1, INT_MAX, &errstr);\n\t\tif (errstr != NULL) {\n\t\t\tcmdq_error(cmdq, \"adjustment %s\", errstr);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t}\n\n\tif (args_has(self->args, 'x')) {\n\t\tx = args_strtonum(self->args, 'x', PANE_MINIMUM, INT_MAX,\n\t\t    &cause);\n\t\tif (cause != NULL) {\n\t\t\tcmdq_error(cmdq, \"width %s\", cause);\n\t\t\tfree(cause);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\tlayout_resize_pane_to(wp, LAYOUT_LEFTRIGHT, x);\n\t}\n\tif (args_has(self->args, 'y')) {\n\t\ty = args_strtonum(self->args, 'y', PANE_MINIMUM, INT_MAX,\n\t\t    &cause);\n\t\tif (cause != NULL) {\n\t\t\tcmdq_error(cmdq, \"height %s\", cause);\n\t\t\tfree(cause);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\tlayout_resize_pane_to(wp, LAYOUT_TOPBOTTOM, y);\n\t}\n\n\tif (args_has(self->args, 'L'))\n\t\tlayout_resize_pane(wp, LAYOUT_LEFTRIGHT, -adjust);\n\telse if (args_has(self->args, 'R'))\n\t\tlayout_resize_pane(wp, LAYOUT_LEFTRIGHT, adjust);\n\telse if (args_has(self->args, 'U'))\n\t\tlayout_resize_pane(wp, LAYOUT_TOPBOTTOM, -adjust);\n\telse if (args_has(self->args, 'D'))\n\t\tlayout_resize_pane(wp, LAYOUT_TOPBOTTOM, adjust);\n\tserver_redraw_window(wl->window);\n\n\treturn (CMD_RETURN_NORMAL);\n}\n\nvoid\ncmd_resize_pane_mouse_update(struct client *c, struct mouse_event *m)\n{\n\tstruct winlink\t\t*wl;\n\tstruct window_pane\t*wp;\n\tint\t\t\t found;\n\tu_int\t\t\t y, ly;\n\n\twl = cmd_mouse_window(m, NULL);\n\tif (wl == NULL) {\n\t\tc->tty.mouse_drag_update = NULL;\n\t\treturn;\n\t}\n\n\ty = m->y;\n\tif (m->statusat == 0 && y > 0)\n\t\ty--;\n\telse if (m->statusat > 0 && y >= (u_int)m->statusat)\n\t\ty = m->statusat - 1;\n\tly = m->ly;\n\tif (m->statusat == 0 && ly > 0)\n\t\tly--;\n\telse if (m->statusat > 0 && ly >= (u_int)m->statusat)\n\t\tly = m->statusat - 1;\n\n\tfound = 0;\n\tTAILQ_FOREACH(wp, &wl->window->panes, entry) {\n\t\tif (!window_pane_visible(wp))\n\t\t\tcontinue;\n\n\t\tif (wp->xoff + wp->sx == m->lx &&\n\t\t    wp->yoff <= 1 + ly && wp->yoff + wp->sy >= ly) {\n\t\t\tlayout_resize_pane(wp, LAYOUT_LEFTRIGHT, m->x - m->lx);\n\t\t\tfound = 1;\n\t\t}\n\t\tif (wp->yoff + wp->sy == ly &&\n\t\t    wp->xoff <= 1 + m->lx && wp->xoff + wp->sx >= m->lx) {\n\t\t\tlayout_resize_pane(wp, LAYOUT_TOPBOTTOM, y - ly);\n\t\t\tfound = 1;\n\t\t}\n\t}\n\tif (found)\n\t\tserver_redraw_window(wl->window);\n\telse\n\t\tc->tty.mouse_drag_update = NULL;\n}\n"
        },
        {
          "name": "cmd-respawn-pane.c",
          "type": "blob",
          "size": 2.6787109375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2008 Nicholas Marriott <nicholas.marriott@gmail.com>\n * Copyright (c) 2011 Marcel P. Partap <mpartap@gmx.net>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\n/*\n * Respawn a pane (restart the command). Kill existing if -k given.\n */\n\nenum cmd_retval\t cmd_respawn_pane_exec(struct cmd *, struct cmd_q *);\n\nconst struct cmd_entry cmd_respawn_pane_entry = {\n\t.name = \"respawn-pane\",\n\t.alias = \"respawnp\",\n\n\t.args = { \"kt:\", 0, -1 },\n\t.usage = \"[-k] \" CMD_TARGET_PANE_USAGE \" [command]\",\n\n\t.tflag = CMD_PANE,\n\n\t.flags = 0,\n\t.exec = cmd_respawn_pane_exec\n};\n\nenum cmd_retval\ncmd_respawn_pane_exec(struct cmd *self, struct cmd_q *cmdq)\n{\n\tstruct args\t\t*args = self->args;\n\tstruct winlink\t\t*wl = cmdq->state.tflag.wl;\n\tstruct window\t\t*w = wl->window;\n\tstruct window_pane\t*wp = cmdq->state.tflag.wp;\n\tstruct session\t\t*s = cmdq->state.tflag.s;\n\tstruct environ\t\t*env;\n\tconst char\t\t*path;\n\tchar\t\t\t*cause;\n\tu_int\t\t\t idx;\n\tstruct environ_entry\t*envent;\n\n\tif (!args_has(self->args, 'k') && wp->fd != -1) {\n\t\tif (window_pane_index(wp, &idx) != 0)\n\t\t\tfatalx(\"index not found\");\n\t\tcmdq_error(cmdq, \"pane still active: %s:%d.%u\",\n\t\t    s->name, wl->idx, idx);\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\tenv = environ_create();\n\tenviron_copy(global_environ, env);\n\tenviron_copy(s->environ, env);\n\tserver_fill_environ(s, env);\n\n\twindow_pane_reset_mode(wp);\n\tscreen_reinit(&wp->base);\n\tinput_init(wp);\n\n\tpath = NULL;\n\tif (cmdq->client != NULL && cmdq->client->session == NULL)\n\t\tenvent = environ_find(cmdq->client->environ, \"PATH\");\n\telse\n\t\tenvent = environ_find(s->environ, \"PATH\");\n\tif (envent != NULL)\n\t\tpath = envent->value;\n\n\tif (window_pane_spawn(wp, args->argc, args->argv, path, NULL, NULL, env,\n\t    s->tio, &cause) != 0) {\n\t\tcmdq_error(cmdq, \"respawn pane failed: %s\", cause);\n\t\tfree(cause);\n\t\tenviron_free(env);\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\twp->flags |= PANE_REDRAW;\n\tserver_status_window(w);\n\n\tenviron_free(env);\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-respawn-window.c",
          "type": "blob",
          "size": 2.8583984375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2008 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\n/*\n * Respawn a window (restart the command). Kill existing if -k given.\n */\n\nenum cmd_retval\t cmd_respawn_window_exec(struct cmd *, struct cmd_q *);\n\nconst struct cmd_entry cmd_respawn_window_entry = {\n\t.name = \"respawn-window\",\n\t.alias = \"respawnw\",\n\n\t.args = { \"kt:\", 0, -1 },\n\t.usage = \"[-k] \" CMD_TARGET_WINDOW_USAGE \" [command]\",\n\n\t.tflag = CMD_WINDOW,\n\n\t.flags = 0,\n\t.exec = cmd_respawn_window_exec\n};\n\nenum cmd_retval\ncmd_respawn_window_exec(struct cmd *self, struct cmd_q *cmdq)\n{\n\tstruct args\t\t*args = self->args;\n\tstruct session\t\t*s = cmdq->state.tflag.s;\n\tstruct winlink\t\t*wl = cmdq->state.tflag.wl;\n\tstruct window\t\t*w = wl->window;\n\tstruct window_pane\t*wp;\n\tstruct environ\t\t*env;\n\tconst char\t\t*path;\n\tchar\t\t \t*cause;\n\tstruct environ_entry\t*envent;\n\n\tif (!args_has(self->args, 'k')) {\n\t\tTAILQ_FOREACH(wp, &w->panes, entry) {\n\t\t\tif (wp->fd == -1)\n\t\t\t\tcontinue;\n\t\t\tcmdq_error(cmdq, \"window still active: %s:%d\", s->name,\n\t\t\t    wl->idx);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t}\n\n\tenv = environ_create();\n\tenviron_copy(global_environ, env);\n\tenviron_copy(s->environ, env);\n\tserver_fill_environ(s, env);\n\n\twp = TAILQ_FIRST(&w->panes);\n\tTAILQ_REMOVE(&w->panes, wp, entry);\n\tlayout_free(w);\n\twindow_destroy_panes(w);\n\tTAILQ_INSERT_HEAD(&w->panes, wp, entry);\n\twindow_pane_resize(wp, w->sx, w->sy);\n\n\tpath = NULL;\n\tif (cmdq->client != NULL && cmdq->client->session == NULL)\n\t\tenvent = environ_find(cmdq->client->environ, \"PATH\");\n\telse\n\t\tenvent = environ_find(s->environ, \"PATH\");\n\tif (envent != NULL)\n\t\tpath = envent->value;\n\n\tif (window_pane_spawn(wp, args->argc, args->argv, path, NULL, NULL, env,\n\t    s->tio, &cause) != 0) {\n\t\tcmdq_error(cmdq, \"respawn window failed: %s\", cause);\n\t\tfree(cause);\n\t\tenviron_free(env);\n\t\tserver_destroy_pane(wp, 0);\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\tlayout_init(w, wp);\n\twindow_pane_reset_mode(wp);\n\tscreen_reinit(&wp->base);\n\tinput_init(wp);\n\twindow_set_active_pane(w, wp);\n\n\trecalculate_sizes();\n\tserver_redraw_window(w);\n\n\tenviron_free(env);\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-rotate-window.c",
          "type": "blob",
          "size": 3.138671875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include \"tmux.h\"\n\n/*\n * Rotate the panes in a window.\n */\n\nenum cmd_retval\t cmd_rotate_window_exec(struct cmd *, struct cmd_q *);\n\nconst struct cmd_entry cmd_rotate_window_entry = {\n\t.name = \"rotate-window\",\n\t.alias = \"rotatew\",\n\n\t.args = { \"Dt:U\", 0, 0 },\n\t.usage = \"[-DU] \" CMD_TARGET_WINDOW_USAGE,\n\n\t.tflag = CMD_WINDOW,\n\n\t.flags = 0,\n\t.exec = cmd_rotate_window_exec\n};\n\nenum cmd_retval\ncmd_rotate_window_exec(struct cmd *self, struct cmd_q *cmdq)\n{\n\tstruct winlink\t\t*wl = cmdq->state.tflag.wl;\n\tstruct window\t\t*w = wl->window;\n\tstruct window_pane\t*wp, *wp2;\n\tstruct layout_cell\t*lc;\n\tu_int\t\t\t sx, sy, xoff, yoff;\n\n\tif (args_has(self->args, 'D')) {\n\t\twp = TAILQ_LAST(&w->panes, window_panes);\n\t\tTAILQ_REMOVE(&w->panes, wp, entry);\n\t\tTAILQ_INSERT_HEAD(&w->panes, wp, entry);\n\n\t\tlc = wp->layout_cell;\n\t\txoff = wp->xoff; yoff = wp->yoff;\n\t\tsx = wp->sx; sy = wp->sy;\n\t\tTAILQ_FOREACH(wp, &w->panes, entry) {\n\t\t\tif ((wp2 = TAILQ_NEXT(wp, entry)) == NULL)\n\t\t\t\tbreak;\n\t\t\twp->layout_cell = wp2->layout_cell;\n\t\t\tif (wp->layout_cell != NULL)\n\t\t\t\twp->layout_cell->wp = wp;\n\t\t\twp->xoff = wp2->xoff; wp->yoff = wp2->yoff;\n\t\t\twindow_pane_resize(wp, wp2->sx, wp2->sy);\n\t\t}\n\t\twp->layout_cell = lc;\n\t\tif (wp->layout_cell != NULL)\n\t\t\twp->layout_cell->wp = wp;\n\t\twp->xoff = xoff; wp->yoff = yoff;\n\t\twindow_pane_resize(wp, sx, sy);\n\n\t\tif ((wp = TAILQ_PREV(w->active, window_panes, entry)) == NULL)\n\t\t\twp = TAILQ_LAST(&w->panes, window_panes);\n\t\twindow_set_active_pane(w, wp);\n\t\tserver_redraw_window(w);\n\t} else {\n\t\twp = TAILQ_FIRST(&w->panes);\n\t\tTAILQ_REMOVE(&w->panes, wp, entry);\n\t\tTAILQ_INSERT_TAIL(&w->panes, wp, entry);\n\n\t\tlc = wp->layout_cell;\n\t\txoff = wp->xoff; yoff = wp->yoff;\n\t\tsx = wp->sx; sy = wp->sy;\n\t\tTAILQ_FOREACH_REVERSE(wp, &w->panes, window_panes, entry) {\n\t\t\tif ((wp2 = TAILQ_PREV(wp, window_panes, entry)) == NULL)\n\t\t\t\tbreak;\n\t\t\twp->layout_cell = wp2->layout_cell;\n\t\t\tif (wp->layout_cell != NULL)\n\t\t\t\twp->layout_cell->wp = wp;\n\t\t\twp->xoff = wp2->xoff; wp->yoff = wp2->yoff;\n\t\t\twindow_pane_resize(wp, wp2->sx, wp2->sy);\n\t\t}\n\t\twp->layout_cell = lc;\n\t\tif (wp->layout_cell != NULL)\n\t\t\twp->layout_cell->wp = wp;\n\t\twp->xoff = xoff; wp->yoff = yoff;\n\t\twindow_pane_resize(wp, sx, sy);\n\n\t\tif ((wp = TAILQ_NEXT(w->active, entry)) == NULL)\n\t\t\twp = TAILQ_FIRST(&w->panes);\n\t\twindow_set_active_pane(w, wp);\n\t\tserver_redraw_window(w);\n\t}\n\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-run-shell.c",
          "type": "blob",
          "size": 4.1494140625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Tiago Cunha <me@tiagocunha.org>\n * Copyright (c) 2009 Nicholas Marriott <nicm@openbsd.org>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/wait.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * Runs a command without a window.\n */\n\nenum cmd_retval\t cmd_run_shell_exec(struct cmd *, struct cmd_q *);\n\nvoid\tcmd_run_shell_callback(struct job *);\nvoid\tcmd_run_shell_free(void *);\nvoid\tcmd_run_shell_print(struct job *, const char *);\n\nconst struct cmd_entry cmd_run_shell_entry = {\n\t.name = \"run-shell\",\n\t.alias = \"run\",\n\n\t.args = { \"bt:\", 1, 1 },\n\t.usage = \"[-b] \" CMD_TARGET_PANE_USAGE \" shell-command\",\n\n\t.tflag = CMD_PANE_CANFAIL,\n\n\t.flags = 0,\n\t.exec = cmd_run_shell_exec\n};\n\nstruct cmd_run_shell_data {\n\tchar\t\t*cmd;\n\tstruct cmd_q\t*cmdq;\n\tint\t\t bflag;\n\tint\t\t wp_id;\n};\n\nvoid\ncmd_run_shell_print(struct job *job, const char *msg)\n{\n\tstruct cmd_run_shell_data\t*cdata = job->data;\n\tstruct window_pane\t\t*wp = NULL;\n\n\tif (cdata->wp_id != -1)\n\t\twp = window_pane_find_by_id(cdata->wp_id);\n\tif (wp == NULL) {\n\t\tcmdq_print(cdata->cmdq, \"%s\", msg);\n\t\treturn;\n\t}\n\n\tif (window_pane_set_mode(wp, &window_copy_mode) == 0)\n\t\twindow_copy_init_for_output(wp);\n\tif (wp->mode == &window_copy_mode)\n\t\twindow_copy_add(wp, \"%s\", msg);\n}\n\nenum cmd_retval\ncmd_run_shell_exec(struct cmd *self, struct cmd_q *cmdq)\n{\n\tstruct args\t\t\t*args = self->args;\n\tstruct cmd_run_shell_data\t*cdata;\n\tchar\t\t\t\t*shellcmd;\n\tstruct session\t\t\t*s = cmdq->state.tflag.s;\n\tstruct winlink\t\t\t*wl = cmdq->state.tflag.wl;\n\tstruct window_pane\t\t*wp = cmdq->state.tflag.wp;\n\tstruct format_tree\t\t*ft;\n\tconst char\t\t\t*cwd;\n\n\tif (cmdq->client != NULL && cmdq->client->session == NULL)\n\t\tcwd = cmdq->client->cwd;\n\telse if (s != NULL)\n\t\tcwd = s->cwd;\n\telse\n\t\tcwd = NULL;\n\tft = format_create(cmdq, 0);\n\tformat_defaults(ft, cmdq->state.c, s, wl, wp);\n\tshellcmd = format_expand(ft, args->argv[0]);\n\tformat_free(ft);\n\n\tcdata = xmalloc(sizeof *cdata);\n\tcdata->cmd = shellcmd;\n\tcdata->bflag = args_has(args, 'b');\n\tcdata->wp_id = wp != NULL ? (int) wp->id : -1;\n\n\tcdata->cmdq = cmdq;\n\tcmdq->references++;\n\n\tjob_run(shellcmd, s, cwd, cmd_run_shell_callback, cmd_run_shell_free,\n\t    cdata);\n\n\tif (cdata->bflag)\n\t\treturn (CMD_RETURN_NORMAL);\n\treturn (CMD_RETURN_WAIT);\n}\n\nvoid\ncmd_run_shell_callback(struct job *job)\n{\n\tstruct cmd_run_shell_data\t*cdata = job->data;\n\tstruct cmd_q\t\t\t*cmdq = cdata->cmdq;\n\tchar\t\t\t\t*cmd, *msg, *line;\n\tsize_t\t\t\t\t size;\n\tint\t\t\t\t retcode;\n\tu_int\t\t\t\t lines;\n\n\tif (cmdq->flags & CMD_Q_DEAD)\n\t\treturn;\n\tcmd = cdata->cmd;\n\n\tlines = 0;\n\tdo {\n\t\tif ((line = evbuffer_readline(job->event->input)) != NULL) {\n\t\t\tcmd_run_shell_print(job, line);\n\t\t\tfree(line);\n\t\t\tlines++;\n\t\t}\n\t} while (line != NULL);\n\n\tsize = EVBUFFER_LENGTH(job->event->input);\n\tif (size != 0) {\n\t\tline = xmalloc(size + 1);\n\t\tmemcpy(line, EVBUFFER_DATA(job->event->input), size);\n\t\tline[size] = '\\0';\n\n\t\tcmd_run_shell_print(job, line);\n\t\tlines++;\n\n\t\tfree(line);\n\t}\n\n\tmsg = NULL;\n\tif (WIFEXITED(job->status)) {\n\t\tif ((retcode = WEXITSTATUS(job->status)) != 0)\n\t\t\txasprintf(&msg, \"'%s' returned %d\", cmd, retcode);\n\t} else if (WIFSIGNALED(job->status)) {\n\t\tretcode = WTERMSIG(job->status);\n\t\txasprintf(&msg, \"'%s' terminated by signal %d\", cmd, retcode);\n\t}\n\tif (msg != NULL)\n\t\tcmd_run_shell_print(job, msg);\n\tfree(msg);\n}\n\nvoid\ncmd_run_shell_free(void *data)\n{\n\tstruct cmd_run_shell_data\t*cdata = data;\n\tstruct cmd_q\t\t\t*cmdq = cdata->cmdq;\n\n\tif (!cmdq_free(cmdq) && !cdata->bflag)\n\t\tcmdq_continue(cmdq);\n\n\tfree(cdata->cmd);\n\tfree(cdata);\n}\n"
        },
        {
          "name": "cmd-save-buffer.c",
          "type": "blob",
          "size": 3.9619140625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Tiago Cunha <me@tiagocunha.org>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/stat.h>\n\n#include <errno.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\n/*\n * Saves a paste buffer to a file.\n */\n\nenum cmd_retval\t cmd_save_buffer_exec(struct cmd *, struct cmd_q *);\n\nconst struct cmd_entry cmd_save_buffer_entry = {\n\t.name = \"save-buffer\",\n\t.alias = \"saveb\",\n\n\t.args = { \"ab:\", 1, 1 },\n\t.usage = \"[-a] \" CMD_BUFFER_USAGE \" path\",\n\n\t.flags = 0,\n\t.exec = cmd_save_buffer_exec\n};\n\nconst struct cmd_entry cmd_show_buffer_entry = {\n\t.name = \"show-buffer\",\n\t.alias = \"showb\",\n\n\t.args = { \"b:\", 0, 0 },\n\t.usage = CMD_BUFFER_USAGE,\n\n\t.flags = 0,\n\t.exec = cmd_save_buffer_exec\n};\n\nenum cmd_retval\ncmd_save_buffer_exec(struct cmd *self, struct cmd_q *cmdq)\n{\n\tstruct args\t\t*args = self->args;\n\tstruct client\t\t*c = cmdq->client;\n\tstruct session          *s;\n\tstruct paste_buffer\t*pb;\n\tconst char\t\t*path, *bufname, *bufdata, *start, *end, *cwd;\n\tconst char\t\t*flags;\n\tchar\t\t\t*msg, *file, resolved[PATH_MAX];\n\tsize_t\t\t\t size, used, msglen, bufsize;\n\tFILE\t\t\t*f;\n\n\tif (!args_has(args, 'b')) {\n\t\tif ((pb = paste_get_top(NULL)) == NULL) {\n\t\t\tcmdq_error(cmdq, \"no buffers\");\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t} else {\n\t\tbufname = args_get(args, 'b');\n\t\tpb = paste_get_name(bufname);\n\t\tif (pb == NULL) {\n\t\t\tcmdq_error(cmdq, \"no buffer %s\", bufname);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t}\n\tbufdata = paste_buffer_data(pb, &bufsize);\n\n\tif (self->entry == &cmd_show_buffer_entry)\n\t\tpath = \"-\";\n\telse\n\t\tpath = args->argv[0];\n\tif (strcmp(path, \"-\") == 0) {\n\t\tif (c == NULL) {\n\t\t\tcmdq_error(cmdq, \"can't write to stdout\");\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\tif (c->session == NULL || (c->flags & CLIENT_CONTROL))\n\t\t\tgoto do_stdout;\n\t\tgoto do_print;\n\t}\n\n\tif (c != NULL && c->session == NULL && c->cwd != NULL)\n\t\tcwd = c->cwd;\n\telse if ((s = c->session) != NULL && s->cwd != NULL)\n\t\tcwd = s->cwd;\n\telse\n\t\tcwd = \".\";\n\n\tflags = \"wb\";\n\tif (args_has(self->args, 'a'))\n\t\tflags = \"ab\";\n\n\tif (*path == '/')\n\t\tfile = xstrdup(path);\n\telse\n\t\txasprintf(&file, \"%s/%s\", cwd, path);\n\tif (realpath(file, resolved) == NULL &&\n\t    strlcpy(resolved, file, sizeof resolved) >= sizeof resolved) {\n\t\tcmdq_error(cmdq, \"%s: %s\", file, strerror(ENAMETOOLONG));\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\tf = fopen(resolved, flags);\n\tfree(file);\n\tif (f == NULL) {\n\t\tcmdq_error(cmdq, \"%s: %s\", resolved, strerror(errno));\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\tif (fwrite(bufdata, 1, bufsize, f) != bufsize) {\n\t\tcmdq_error(cmdq, \"%s: write error\", resolved);\n\t\tfclose(f);\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\tfclose(f);\n\n\treturn (CMD_RETURN_NORMAL);\n\ndo_stdout:\n\tevbuffer_add(c->stdout_data, bufdata, bufsize);\n\tserver_client_push_stdout(c);\n\treturn (CMD_RETURN_NORMAL);\n\ndo_print:\n\tif (bufsize > (INT_MAX / 4) - 1) {\n\t\tcmdq_error(cmdq, \"buffer too big\");\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\tmsg = NULL;\n\n\tused = 0;\n\twhile (used != bufsize) {\n\t\tstart = bufdata + used;\n\t\tend = memchr(start, '\\n', bufsize - used);\n\t\tif (end != NULL)\n\t\t\tsize = end - start;\n\t\telse\n\t\t\tsize = bufsize - used;\n\n\t\tmsglen = size * 4 + 1;\n\t\tmsg = xrealloc(msg, msglen);\n\n\t\tstrvisx(msg, start, size, VIS_OCTAL|VIS_TAB);\n\t\tcmdq_print(cmdq, \"%s\", msg);\n\n\t\tused += size + (end != NULL);\n\t}\n\n\tfree(msg);\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-select-layout.c",
          "type": "blob",
          "size": 3.0595703125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n\n#include \"tmux.h\"\n\n/*\n * Switch window to selected layout.\n */\n\nenum cmd_retval\t cmd_select_layout_exec(struct cmd *, struct cmd_q *);\n\nconst struct cmd_entry cmd_select_layout_entry = {\n\t.name = \"select-layout\",\n\t.alias = \"selectl\",\n\n\t.args = { \"nopt:\", 0, 1 },\n\t.usage = \"[-nop] \" CMD_TARGET_WINDOW_USAGE \" [layout-name]\",\n\n\t.tflag = CMD_WINDOW,\n\n\t.flags = 0,\n\t.exec = cmd_select_layout_exec\n};\n\nconst struct cmd_entry cmd_next_layout_entry = {\n\t.name = \"next-layout\",\n\t.alias = \"nextl\",\n\n\t.args = { \"t:\", 0, 0 },\n\t.usage = CMD_TARGET_WINDOW_USAGE,\n\n\t.tflag = CMD_WINDOW,\n\n\t.flags = 0,\n\t.exec = cmd_select_layout_exec\n};\n\nconst struct cmd_entry cmd_previous_layout_entry = {\n\t.name = \"previous-layout\",\n\t.alias = \"prevl\",\n\n\t.args = { \"t:\", 0, 0 },\n\t.usage = CMD_TARGET_WINDOW_USAGE,\n\n\t.tflag = CMD_WINDOW,\n\n\t.flags = 0,\n\t.exec = cmd_select_layout_exec\n};\n\nenum cmd_retval\ncmd_select_layout_exec(struct cmd *self, struct cmd_q *cmdq)\n{\n\tstruct args\t*args = self->args;\n\tstruct winlink\t*wl = cmdq->state.tflag.wl;\n\tstruct window\t*w;\n\tconst char\t*layoutname;\n\tchar\t\t*oldlayout;\n\tint\t\t next, previous, layout;\n\n\tw = wl->window;\n\tserver_unzoom_window(w);\n\n\tnext = self->entry == &cmd_next_layout_entry;\n\tif (args_has(args, 'n'))\n\t\tnext = 1;\n\tprevious = self->entry == &cmd_previous_layout_entry;\n\tif (args_has(args, 'p'))\n\t\tprevious = 1;\n\n\toldlayout = w->old_layout;\n\tw->old_layout = layout_dump(w->layout_root);\n\n\tif (next || previous) {\n\t\tif (next)\n\t\t\tlayout_set_next(w);\n\t\telse\n\t\t\tlayout_set_previous(w);\n\t\tgoto changed;\n\t}\n\n\tif (!args_has(args, 'o')) {\n\t\tif (args->argc == 0)\n\t\t\tlayout = w->lastlayout;\n\t\telse\n\t\t\tlayout = layout_set_lookup(args->argv[0]);\n\t\tif (layout != -1) {\n\t\t\tlayout_set_select(w, layout);\n\t\t\tgoto changed;\n\t\t}\n\t}\n\n\tif (args->argc != 0)\n\t\tlayoutname = args->argv[0];\n\telse if (args_has(args, 'o'))\n\t\tlayoutname = oldlayout;\n\telse\n\t\tlayoutname = NULL;\n\n\tif (layoutname != NULL) {\n\t\tif (layout_parse(w, layoutname) == -1) {\n\t\t\tcmdq_error(cmdq, \"can't set layout: %s\", layoutname);\n\t\t\tgoto error;\n\t\t}\n\t\tgoto changed;\n\t}\n\n\tfree(oldlayout);\n\treturn (CMD_RETURN_NORMAL);\n\nchanged:\n\tfree(oldlayout);\n\tserver_redraw_window(w);\n\treturn (CMD_RETURN_NORMAL);\n\nerror:\n\tfree(w->old_layout);\n\tw->old_layout = oldlayout;\n\treturn (CMD_RETURN_ERROR);\n}\n"
        },
        {
          "name": "cmd-select-pane.c",
          "type": "blob",
          "size": 4.3095703125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include \"tmux.h\"\n\n/*\n * Select pane.\n */\n\nenum cmd_retval\t cmd_select_pane_exec(struct cmd *, struct cmd_q *);\n\nconst struct cmd_entry cmd_select_pane_entry = {\n\t.name = \"select-pane\",\n\t.alias = \"selectp\",\n\n\t.args = { \"DdegLlMmP:Rt:U\", 0, 0 },\n\t.usage = \"[-DdegLlMmRU] [-P style] \" CMD_TARGET_PANE_USAGE,\n\n\t.tflag = CMD_PANE,\n\n\t.flags = 0,\n\t.exec = cmd_select_pane_exec\n};\n\nconst struct cmd_entry cmd_last_pane_entry = {\n\t.name = \"last-pane\",\n\t.alias = \"lastp\",\n\n\t.args = { \"det:\", 0, 0 },\n\t.usage = \"[-de] \" CMD_TARGET_WINDOW_USAGE,\n\n\t.tflag = CMD_WINDOW,\n\n\t.flags = 0,\n\t.exec = cmd_select_pane_exec\n};\n\nenum cmd_retval\ncmd_select_pane_exec(struct cmd *self, struct cmd_q *cmdq)\n{\n\tstruct args\t\t*args = self->args;\n\tstruct winlink\t\t*wl = cmdq->state.tflag.wl;\n\tstruct window\t\t*w = wl->window;\n\tstruct session\t\t*s = cmdq->state.tflag.s;\n\tstruct window_pane\t*wp = cmdq->state.tflag.wp, *lastwp, *markedwp;\n\tconst char\t\t*style;\n\n\tif (self->entry == &cmd_last_pane_entry || args_has(args, 'l')) {\n\n\t\tif (wl->window->last == NULL) {\n\t\t\tcmdq_error(cmdq, \"no last pane\");\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\n\t\tif (args_has(self->args, 'e'))\n\t\t\tw->last->flags &= ~PANE_INPUTOFF;\n\t\telse if (args_has(self->args, 'd'))\n\t\t\tw->last->flags |= PANE_INPUTOFF;\n\t\telse {\n\t\t\tserver_unzoom_window(w);\n\t\t\twindow_redraw_active_switch(w, w->last);\n\t\t\tif (window_set_active_pane(w, w->last)) {\n\t\t\t\tserver_status_window(w);\n\t\t\t\tserver_redraw_window_borders(w);\n\t\t\t}\n\t\t}\n\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tif (args_has(args, 'm') || args_has(args, 'M')) {\n\t\tif (args_has(args, 'm') && !window_pane_visible(wp))\n\t\t\treturn (CMD_RETURN_NORMAL);\n\t\tlastwp = marked_pane.wp;\n\n\t\tif (args_has(args, 'M') || server_is_marked(s, wl, wp))\n\t\t\tserver_clear_marked();\n\t\telse\n\t\t\tserver_set_marked(s, wl, wp);\n\t\tmarkedwp = marked_pane.wp;\n\n\t\tif (lastwp != NULL) {\n\t\t\tserver_redraw_window_borders(lastwp->window);\n\t\t\tserver_status_window(lastwp->window);\n\t\t}\n\t\tif (markedwp != NULL) {\n\t\t\tserver_redraw_window_borders(markedwp->window);\n\t\t\tserver_status_window(markedwp->window);\n\t\t}\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tif (args_has(self->args, 'P') || args_has(self->args, 'g')) {\n\t\tif (args_has(args, 'P')) {\n\t\t\tstyle = args_get(args, 'P');\n\t\t\tif (style_parse(&grid_default_cell, &wp->colgc,\n\t\t\t    style) == -1) {\n\t\t\t\tcmdq_error(cmdq, \"bad style: %s\", style);\n\t\t\t\treturn (CMD_RETURN_ERROR);\n\t\t\t}\n\t\t\twp->flags |= PANE_REDRAW;\n\t\t}\n\t\tif (args_has(self->args, 'g'))\n\t\t\tcmdq_print(cmdq, \"%s\", style_tostring(&wp->colgc));\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tif (args_has(self->args, 'L')) {\n\t\tserver_unzoom_window(wp->window);\n\t\twp = window_pane_find_left(wp);\n\t} else if (args_has(self->args, 'R')) {\n\t\tserver_unzoom_window(wp->window);\n\t\twp = window_pane_find_right(wp);\n\t} else if (args_has(self->args, 'U')) {\n\t\tserver_unzoom_window(wp->window);\n\t\twp = window_pane_find_up(wp);\n\t} else if (args_has(self->args, 'D')) {\n\t\tserver_unzoom_window(wp->window);\n\t\twp = window_pane_find_down(wp);\n\t}\n\tif (wp == NULL)\n\t\treturn (CMD_RETURN_NORMAL);\n\n\tif (args_has(self->args, 'e')) {\n\t\twp->flags &= ~PANE_INPUTOFF;\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\tif (args_has(self->args, 'd')) {\n\t\twp->flags |= PANE_INPUTOFF;\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tif (wp == w->active)\n\t\treturn (CMD_RETURN_NORMAL);\n\tserver_unzoom_window(wp->window);\n\tif (!window_pane_visible(wp)) {\n\t\tcmdq_error(cmdq, \"pane not visible\");\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\twindow_redraw_active_switch(w, wp);\n\tif (window_set_active_pane(w, wp)) {\n\t\tserver_status_window(w);\n\t\tserver_redraw_window_borders(w);\n\t}\n\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-select-window.c",
          "type": "blob",
          "size": 3.2978515625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n\n#include \"tmux.h\"\n\n/*\n * Select window by index.\n */\n\nenum cmd_retval\t cmd_select_window_exec(struct cmd *, struct cmd_q *);\n\nconst struct cmd_entry cmd_select_window_entry = {\n\t.name = \"select-window\",\n\t.alias = \"selectw\",\n\n\t.args = { \"lnpTt:\", 0, 0 },\n\t.usage = \"[-lnpT] \" CMD_TARGET_WINDOW_USAGE,\n\n\t.tflag = CMD_WINDOW,\n\n\t.flags = 0,\n\t.exec = cmd_select_window_exec\n};\n\nconst struct cmd_entry cmd_next_window_entry = {\n\t.name = \"next-window\",\n\t.alias = \"next\",\n\n\t.args = { \"at:\", 0, 0 },\n\t.usage = \"[-a] \" CMD_TARGET_SESSION_USAGE,\n\n\t.tflag = CMD_SESSION,\n\n\t.flags = 0,\n\t.exec = cmd_select_window_exec\n};\n\nconst struct cmd_entry cmd_previous_window_entry = {\n\t.name = \"previous-window\",\n\t.alias = \"prev\",\n\n\t.args = { \"at:\", 0, 0 },\n\t.usage = \"[-a] \" CMD_TARGET_SESSION_USAGE,\n\n\t.tflag = CMD_SESSION,\n\n\t.flags = 0,\n\t.exec = cmd_select_window_exec\n};\n\nconst struct cmd_entry cmd_last_window_entry = {\n\t.name = \"last-window\",\n\t.alias = \"last\",\n\n\t.args = { \"t:\", 0, 0 },\n\t.usage = CMD_TARGET_SESSION_USAGE,\n\n\t.tflag = CMD_SESSION,\n\n\t.flags = 0,\n\t.exec = cmd_select_window_exec\n};\n\nenum cmd_retval\ncmd_select_window_exec(struct cmd *self, struct cmd_q *cmdq)\n{\n\tstruct winlink\t*wl = cmdq->state.tflag.wl;\n\tstruct session\t*s = cmdq->state.tflag.s;\n\tint\t\t next, previous, last, activity;\n\n\tnext = self->entry == &cmd_next_window_entry;\n\tif (args_has(self->args, 'n'))\n\t\tnext = 1;\n\tprevious = self->entry == &cmd_previous_window_entry;\n\tif (args_has(self->args, 'p'))\n\t\tprevious = 1;\n\tlast = self->entry == &cmd_last_window_entry;\n\tif (args_has(self->args, 'l'))\n\t\tlast = 1;\n\n\tif (next || previous || last) {\n\t\tactivity = args_has(self->args, 'a');\n\t\tif (next) {\n\t\t\tif (session_next(s, activity) != 0) {\n\t\t\t\tcmdq_error(cmdq, \"no next window\");\n\t\t\t\treturn (CMD_RETURN_ERROR);\n\t\t\t}\n\t\t} else if (previous) {\n\t\t\tif (session_previous(s, activity) != 0) {\n\t\t\t\tcmdq_error(cmdq, \"no previous window\");\n\t\t\t\treturn (CMD_RETURN_ERROR);\n\t\t\t}\n\t\t} else {\n\t\t\tif (session_last(s) != 0) {\n\t\t\t\tcmdq_error(cmdq, \"no last window\");\n\t\t\t\treturn (CMD_RETURN_ERROR);\n\t\t\t}\n\t\t}\n\n\t\tserver_redraw_session(s);\n\t} else {\n\t\t/*\n\t\t * If -T and select-window is invoked on same window as\n\t\t * current, switch to previous window.\n\t\t */\n\t\tif (args_has(self->args, 'T') && wl == s->curw) {\n\t\t\tif (session_last(s) != 0) {\n\t\t\t\tcmdq_error(cmdq, \"no last window\");\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\tserver_redraw_session(s);\n\t\t} else if (session_select(s, wl->idx) == 0)\n\t\t\tserver_redraw_session(s);\n\t}\n\trecalculate_sizes();\n\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-send-keys.c",
          "type": "blob",
          "size": 2.685546875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2008 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * Send keys to client.\n */\n\nenum cmd_retval\t cmd_send_keys_exec(struct cmd *, struct cmd_q *);\n\nconst struct cmd_entry cmd_send_keys_entry = {\n\t.name = \"send-keys\",\n\t.alias = \"send\",\n\n\t.args = { \"lRMt:\", 0, -1 },\n\t.usage = \"[-lRM] \" CMD_TARGET_PANE_USAGE \" key ...\",\n\n\t.tflag = CMD_PANE,\n\n\t.flags = 0,\n\t.exec = cmd_send_keys_exec\n};\n\nconst struct cmd_entry cmd_send_prefix_entry = {\n\t.name = \"send-prefix\",\n\t.alias = NULL,\n\n\t.args = { \"2t:\", 0, 0 },\n\t.usage = \"[-2] \" CMD_TARGET_PANE_USAGE,\n\n\t.tflag = CMD_PANE,\n\n\t.flags = 0,\n\t.exec = cmd_send_keys_exec\n};\n\nenum cmd_retval\ncmd_send_keys_exec(struct cmd *self, struct cmd_q *cmdq)\n{\n\tstruct args\t\t*args = self->args;\n\tstruct window_pane\t*wp = cmdq->state.tflag.wp;\n\tstruct session\t\t*s = cmdq->state.tflag.s;\n\tstruct mouse_event\t*m = &cmdq->item->mouse;\n\tconst u_char\t\t*keystr;\n\tint\t\t\t i, literal;\n\tkey_code\t\t key;\n\n\tif (args_has(args, 'M')) {\n\t\twp = cmd_mouse_pane(m, &s, NULL);\n\t\tif (wp == NULL) {\n\t\t\tcmdq_error(cmdq, \"no mouse target\");\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\twindow_pane_key(wp, NULL, s, m->key, m);\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tif (self->entry == &cmd_send_prefix_entry) {\n\t\tif (args_has(args, '2'))\n\t\t\tkey = options_get_number(s->options, \"prefix2\");\n\t\telse\n\t\t\tkey = options_get_number(s->options, \"prefix\");\n\t\twindow_pane_key(wp, NULL, s, key, NULL);\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tif (args_has(args, 'R'))\n\t\tinput_reset(wp, 1);\n\n\tfor (i = 0; i < args->argc; i++) {\n\t\tliteral = args_has(args, 'l');\n\t\tif (!literal) {\n\t\t\tkey = key_string_lookup_string(args->argv[i]);\n\t\t\tif (key != KEYC_NONE && key != KEYC_UNKNOWN)\n\t\t\t\twindow_pane_key(wp, NULL, s, key, NULL);\n\t\t\telse\n\t\t\t\tliteral = 1;\n\t\t}\n\t\tif (literal) {\n\t\t\tfor (keystr = args->argv[i]; *keystr != '\\0'; keystr++)\n\t\t\t\twindow_pane_key(wp, NULL, s, *keystr, NULL);\n\t\t}\n\t}\n\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-set-buffer.c",
          "type": "blob",
          "size": 2.990234375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * Add, set, append to or delete a paste buffer.\n */\n\nenum cmd_retval\t cmd_set_buffer_exec(struct cmd *, struct cmd_q *);\n\nconst struct cmd_entry cmd_set_buffer_entry = {\n\t.name = \"set-buffer\",\n\t.alias = \"setb\",\n\n\t.args = { \"ab:n:\", 0, 1 },\n\t.usage = \"[-a] \" CMD_BUFFER_USAGE \" [-n new-buffer-name] data\",\n\n\t.flags = 0,\n\t.exec = cmd_set_buffer_exec\n};\n\nconst struct cmd_entry cmd_delete_buffer_entry = {\n\t.name = \"delete-buffer\",\n\t.alias = \"deleteb\",\n\n\t.args = { \"b:\", 0, 0 },\n\t.usage = CMD_BUFFER_USAGE,\n\n\t.flags = 0,\n\t.exec = cmd_set_buffer_exec\n};\n\nenum cmd_retval\ncmd_set_buffer_exec(struct cmd *self, struct cmd_q *cmdq)\n{\n\tstruct args\t\t*args = self->args;\n\tstruct paste_buffer\t*pb;\n\tchar\t\t\t*bufdata, *cause;\n\tconst char\t\t*bufname, *olddata;\n\tsize_t\t\t\t bufsize, newsize;\n\n\tbufname = args_get(args, 'b');\n\tif (bufname == NULL)\n\t\tpb = NULL;\n\telse\n\t\tpb = paste_get_name(bufname);\n\n\tif (self->entry == &cmd_delete_buffer_entry) {\n\t\tif (pb == NULL)\n\t\t\tpb = paste_get_top(&bufname);\n\t\tif (pb == NULL) {\n\t\t\tcmdq_error(cmdq, \"no buffer\");\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\tpaste_free(pb);\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tif (args_has(args, 'n')) {\n\t\tif (pb == NULL)\n\t\t\tpb = paste_get_top(&bufname);\n\t\tif (pb == NULL) {\n\t\t\tcmdq_error(cmdq, \"no buffer\");\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\tif (paste_rename(bufname, args_get(args, 'n'), &cause) != 0) {\n\t\t\tcmdq_error(cmdq, \"%s\", cause);\n\t\t\tfree(cause);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tif (args->argc != 1) {\n\t\tcmdq_error(cmdq, \"no data specified\");\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\tif ((newsize = strlen(args->argv[0])) == 0)\n\t\treturn (CMD_RETURN_NORMAL);\n\n\tbufsize = 0;\n\tbufdata = NULL;\n\n\tif (args_has(args, 'a') && pb != NULL) {\n\t\tolddata = paste_buffer_data(pb, &bufsize);\n\t\tbufdata = xmalloc(bufsize);\n\t\tmemcpy(bufdata, olddata, bufsize);\n\t}\n\n\tbufdata = xrealloc(bufdata, bufsize + newsize);\n\tmemcpy(bufdata + bufsize, args->argv[0], newsize);\n\tbufsize += newsize;\n\n\tif (paste_set(bufdata, bufsize, bufname, &cause) != 0) {\n\t\tcmdq_error(cmdq, \"%s\", cause);\n\t\tfree(bufdata);\n\t\tfree(cause);\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-set-environment.c",
          "type": "blob",
          "size": 2.59375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * Set an environment variable.\n */\n\nenum cmd_retval\t cmd_set_environment_exec(struct cmd *, struct cmd_q *);\n\nconst struct cmd_entry cmd_set_environment_entry = {\n\t.name = \"set-environment\",\n\t.alias = \"setenv\",\n\n\t.args = { \"grt:u\", 1, 2 },\n\t.usage = \"[-gru] \" CMD_TARGET_SESSION_USAGE \" name [value]\",\n\n\t.tflag = CMD_SESSION_CANFAIL,\n\n\t.flags = 0,\n\t.exec = cmd_set_environment_exec\n};\n\nenum cmd_retval\ncmd_set_environment_exec(struct cmd *self, struct cmd_q *cmdq)\n{\n\tstruct args\t*args = self->args;\n\tstruct environ\t*env;\n\tconst char\t*name, *value, *target;\n\n\tname = args->argv[0];\n\tif (*name == '\\0') {\n\t\tcmdq_error(cmdq, \"empty variable name\");\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\tif (strchr(name, '=') != NULL) {\n\t\tcmdq_error(cmdq, \"variable name contains =\");\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\tif (args->argc < 2)\n\t\tvalue = NULL;\n\telse\n\t\tvalue = args->argv[1];\n\n\tif (args_has(self->args, 'g'))\n\t\tenv = global_environ;\n\telse {\n\t\tif (cmdq->state.tflag.s == NULL) {\n\t\t\ttarget = args_get(args, 't');\n\t\t\tif (target != NULL)\n\t\t\t\tcmdq_error(cmdq, \"no such session: %s\", target);\n\t\t\telse\n\t\t\t\tcmdq_error(cmdq, \"no current session\");\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\tenv = cmdq->state.tflag.s->environ;\n\t}\n\n\tif (args_has(self->args, 'u')) {\n\t\tif (value != NULL) {\n\t\t\tcmdq_error(cmdq, \"can't specify a value with -u\");\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\tenviron_unset(env, name);\n\t} else if (args_has(self->args, 'r')) {\n\t\tif (value != NULL) {\n\t\t\tcmdq_error(cmdq, \"can't specify a value with -r\");\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\tenviron_clear(env, name);\n\t} else {\n\t\tif (value == NULL) {\n\t\t\tcmdq_error(cmdq, \"no value specified\");\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\tenviron_set(env, name, \"%s\", value);\n\t}\n\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-set-hook.c",
          "type": "blob",
          "size": 2.77734375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2012 Thomas Adam <thomas@xteddy.org>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * Set or show global or session hooks.\n */\n\nenum cmd_retval cmd_set_hook_exec(struct cmd *, struct cmd_q *);\n\nconst struct cmd_entry cmd_set_hook_entry = {\n\t.name = \"set-hook\",\n\t.alias = NULL,\n\n\t.args = { \"gt:u\", 1, 2 },\n\t.usage = \"[-gu] \" CMD_TARGET_SESSION_USAGE \" hook-name [command]\",\n\n\t.tflag = CMD_SESSION,\n\n\t.flags = 0,\n\t.exec = cmd_set_hook_exec\n};\n\nconst struct cmd_entry cmd_show_hooks_entry = {\n\t.name = \"show-hooks\",\n\t.alias = NULL,\n\n\t.args = { \"gt:\", 0, 1 },\n\t.usage = \"[-g] \" CMD_TARGET_SESSION_USAGE,\n\n\t.tflag = CMD_SESSION,\n\n\t.flags = 0,\n\t.exec = cmd_set_hook_exec\n};\n\nenum cmd_retval\ncmd_set_hook_exec(struct cmd *self, struct cmd_q *cmdq)\n{\n\tstruct args\t*args = self->args;\n\tstruct cmd_list\t*cmdlist;\n\tstruct hooks\t*hooks;\n\tstruct hook\t*hook;\n\tchar\t\t*cause, *tmp;\n\tconst char\t*name, *cmd;\n\n\tif (args_has(args, 'g'))\n\t\thooks = global_hooks;\n\telse\n\t\thooks = cmdq->state.tflag.s->hooks;\n\n\tif (self->entry == &cmd_show_hooks_entry) {\n\t\thook = hooks_first(hooks);\n\t\twhile (hook != NULL) {\n\t\t\ttmp = cmd_list_print(hook->cmdlist);\n\t\t\tcmdq_print(cmdq, \"%s -> %s\", hook->name, tmp);\n\t\t\tfree(tmp);\n\n\t\t\thook = hooks_next(hook);\n\t\t}\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tname = args->argv[0];\n\tif (*name == '\\0') {\n\t\tcmdq_error(cmdq, \"invalid hook name\");\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\tif (args->argc < 2)\n\t\tcmd = NULL;\n\telse\n\t\tcmd = args->argv[1];\n\n\tif (args_has(args, 'u')) {\n\t\tif (cmd != NULL) {\n\t\t\tcmdq_error(cmdq, \"command passed to unset hook: %s\",\n\t\t\t    name);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\thooks_remove(hooks, name);\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tif (cmd == NULL) {\n\t\tcmdq_error(cmdq, \"no command to set hook: %s\", name);\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\tif (cmd_string_parse(cmd, &cmdlist, NULL, 0, &cause) != 0) {\n\t\tif (cause != NULL) {\n\t\t\tcmdq_error(cmdq, \"%s\", cause);\n\t\t\tfree(cause);\n\t\t}\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\thooks_add(hooks, name, cmdlist);\n\tcmd_list_free(cmdlist);\n\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-set-option.c",
          "type": "blob",
          "size": 13.69140625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * Set an option.\n */\n\nenum cmd_retval\tcmd_set_option_exec(struct cmd *, struct cmd_q *);\n\nenum cmd_retval\tcmd_set_option_user(struct cmd *, struct cmd_q *,\n\t    const char *, const char *);\n\nint\tcmd_set_option_unset(struct cmd *, struct cmd_q *,\n\t    const struct options_table_entry *, struct options *,\n\t    const char *);\nint\tcmd_set_option_set(struct cmd *, struct cmd_q *,\n\t    const struct options_table_entry *, struct options *,\n\t    const char *);\n\nstruct options_entry *cmd_set_option_string(struct cmd *, struct cmd_q *,\n\t    const struct options_table_entry *, struct options *,\n\t    const char *);\nstruct options_entry *cmd_set_option_number(struct cmd *, struct cmd_q *,\n\t    const struct options_table_entry *, struct options *,\n\t    const char *);\nstruct options_entry *cmd_set_option_key(struct cmd *, struct cmd_q *,\n\t    const struct options_table_entry *, struct options *,\n\t    const char *);\nstruct options_entry *cmd_set_option_colour(struct cmd *, struct cmd_q *,\n\t    const struct options_table_entry *, struct options *,\n\t    const char *);\nstruct options_entry *cmd_set_option_attributes(struct cmd *, struct cmd_q *,\n\t    const struct options_table_entry *, struct options *,\n\t    const char *);\nstruct options_entry *cmd_set_option_flag(struct cmd *, struct cmd_q *,\n\t    const struct options_table_entry *, struct options *,\n\t    const char *);\nstruct options_entry *cmd_set_option_choice(struct cmd *, struct cmd_q *,\n\t    const struct options_table_entry *, struct options *,\n\t    const char *);\nstruct options_entry *cmd_set_option_style(struct cmd *, struct cmd_q *,\n\t    const struct options_table_entry *, struct options *,\n\t    const char *);\n\nconst struct cmd_entry cmd_set_option_entry = {\n\t.name = \"set-option\",\n\t.alias = \"set\",\n\n\t.args = { \"agoqst:uw\", 1, 2 },\n\t.usage = \"[-agosquw] [-t target-window] option [value]\",\n\n\t.tflag = CMD_WINDOW_CANFAIL,\n\n\t.flags = 0,\n\t.exec = cmd_set_option_exec\n};\n\nconst struct cmd_entry cmd_set_window_option_entry = {\n\t.name = \"set-window-option\",\n\t.alias = \"setw\",\n\n\t.args = { \"agoqt:u\", 1, 2 },\n\t.usage = \"[-agoqu] \" CMD_TARGET_WINDOW_USAGE \" option [value]\",\n\n\t.tflag = CMD_WINDOW_CANFAIL,\n\n\t.flags = 0,\n\t.exec = cmd_set_option_exec\n};\n\nenum cmd_retval\ncmd_set_option_exec(struct cmd *self, struct cmd_q *cmdq)\n{\n\tstruct args\t\t\t\t*args = self->args;\n\tstruct session\t\t\t\t*s = cmdq->state.tflag.s;\n\tstruct winlink\t\t\t\t*wl = cmdq->state.tflag.wl;\n\tstruct window\t\t\t\t*w;\n\tstruct client\t\t\t\t*c;\n\tconst struct options_table_entry\t*oe;\n\tstruct options\t\t\t\t*oo;\n\tconst char\t\t\t\t*optstr, *valstr, *target;\n\n\t/* Get the option name and value. */\n\toptstr = args->argv[0];\n\tif (*optstr == '\\0') {\n\t\tcmdq_error(cmdq, \"invalid option\");\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\tif (args->argc < 2)\n\t\tvalstr = NULL;\n\telse\n\t\tvalstr = args->argv[1];\n\n\t/* Is this a user option? */\n\tif (*optstr == '@')\n\t\treturn (cmd_set_option_user(self, cmdq, optstr, valstr));\n\n\t/* Find the option entry, try each table. */\n\toe = NULL;\n\tif (options_table_find(optstr, &oe) != 0) {\n\t\tif (!args_has(args, 'q')) {\n\t\t\tcmdq_error(cmdq, \"ambiguous option: %s\", optstr);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\tif (oe == NULL) {\n\t\tif (!args_has(args, 'q')) {\n\t\t\tcmdq_error(cmdq, \"unknown option: %s\", optstr);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\t/* Work out the tree from the scope of the option. */\n\tif (oe->scope == OPTIONS_TABLE_SERVER)\n\t\too = global_options;\n\telse if (oe->scope == OPTIONS_TABLE_WINDOW) {\n\t\tif (args_has(self->args, 'g'))\n\t\t\too = global_w_options;\n\t\telse if (wl == NULL) {\n\t\t\ttarget = args_get(args, 't');\n\t\t\tif (target != NULL) {\n\t\t\t\tcmdq_error(cmdq, \"no such window: %s\",\n\t\t\t\t    target);\n\t\t\t} else\n\t\t\t\tcmdq_error(cmdq, \"no current window\");\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t} else\n\t\t\too = wl->window->options;\n\t} else if (oe->scope == OPTIONS_TABLE_SESSION) {\n\t\tif (args_has(self->args, 'g'))\n\t\t\too = global_s_options;\n\t\telse if (s == NULL) {\n\t\t\ttarget = args_get(args, 't');\n\t\t\tif (target != NULL) {\n\t\t\t\tcmdq_error(cmdq, \"no such session: %s\",\n\t\t\t\t    target);\n\t\t\t} else\n\t\t\t\tcmdq_error(cmdq, \"no current session\");\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t} else\n\t\t\too = s->options;\n\t} else {\n\t\tcmdq_error(cmdq, \"unknown table\");\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\t/* Unset or set the option. */\n\tif (args_has(args, 'u')) {\n\t\tif (cmd_set_option_unset(self, cmdq, oe, oo, valstr) != 0)\n\t\t\treturn (CMD_RETURN_ERROR);\n\t} else {\n\t\tif (args_has(args, 'o') && options_find1(oo, optstr) != NULL) {\n\t\t\tif (!args_has(args, 'q')) {\n\t\t\t\tcmdq_error(cmdq, \"already set: %s\", optstr);\n\t\t\t\treturn (CMD_RETURN_ERROR);\n\t\t\t}\n\t\t\treturn (CMD_RETURN_NORMAL);\n\t\t}\n\t\tif (cmd_set_option_set(self, cmdq, oe, oo, valstr) != 0)\n\t\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\t/* Start or stop timers if necessary. */\n\tif (strcmp(oe->name, \"automatic-rename\") == 0) {\n\t\tRB_FOREACH(w, windows, &windows) {\n\t\t\tif (options_get_number(w->options, \"automatic-rename\"))\n\t\t\t\tw->active->flags |= PANE_CHANGED;\n\t\t}\n\t}\n\tif (strcmp(oe->name, \"key-table\") == 0) {\n\t\tTAILQ_FOREACH(c, &clients, entry)\n\t\t\tserver_client_set_key_table(c, NULL);\n\t}\n\tif (strcmp(oe->name, \"status\") == 0 ||\n\t    strcmp(oe->name, \"status-interval\") == 0)\n\t\tstatus_timer_start_all();\n\tif (strcmp(oe->name, \"monitor-silence\") == 0)\n\t\talerts_reset_all();\n\n\t/* Update sizes and redraw. May not need it but meh. */\n\trecalculate_sizes();\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (c->session != NULL)\n\t\t\tserver_redraw_client(c);\n\t}\n\n\treturn (CMD_RETURN_NORMAL);\n}\n\n/* Set user option. */\nenum cmd_retval\ncmd_set_option_user(struct cmd *self, struct cmd_q *cmdq, const char *optstr,\n    const char *valstr)\n{\n\tstruct args\t*args = self->args;\n\tstruct session\t*s = cmdq->state.tflag.s;\n\tstruct winlink\t*wl = cmdq->state.tflag.wl;\n\tstruct options\t*oo;\n\n\tif (args_has(args, 's'))\n\t\too = global_options;\n\telse if (args_has(self->args, 'w') ||\n\t    self->entry == &cmd_set_window_option_entry) {\n\t\tif (args_has(self->args, 'g'))\n\t\t\too = global_w_options;\n\t\telse\n\t\t\too = wl->window->options;\n\t} else {\n\t\tif (args_has(self->args, 'g'))\n\t\t\too = global_s_options;\n\t\telse\n\t\t\too = s->options;\n\t}\n\n\tif (args_has(args, 'u')) {\n\t\tif (options_find1(oo, optstr) == NULL) {\n\t\t\tif (!args_has(args, 'q')) {\n\t\t\t\tcmdq_error(cmdq, \"unknown option: %s\", optstr);\n\t\t\t\treturn (CMD_RETURN_ERROR);\n\t\t\t}\n\t\t\treturn (CMD_RETURN_NORMAL);\n\t\t}\n\t\tif (valstr != NULL) {\n\t\t\tcmdq_error(cmdq, \"value passed to unset option: %s\",\n\t\t\t    optstr);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\toptions_remove(oo, optstr);\n\t} else {\n\t\tif (valstr == NULL) {\n\t\t\tcmdq_error(cmdq, \"empty value\");\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\tif (args_has(args, 'o') && options_find1(oo, optstr) != NULL) {\n\t\t\tif (!args_has(args, 'q')) {\n\t\t\t\tcmdq_error(cmdq, \"already set: %s\", optstr);\n\t\t\t\treturn (CMD_RETURN_ERROR);\n\t\t\t}\n\t\t\treturn (CMD_RETURN_NORMAL);\n\t\t}\n\t\toptions_set_string(oo, optstr, \"%s\", valstr);\n\t}\n\treturn (CMD_RETURN_NORMAL);\n}\n\n/* Unset an option. */\nint\ncmd_set_option_unset(struct cmd *self, struct cmd_q *cmdq,\n    const struct options_table_entry *oe, struct options *oo,\n    const char *value)\n{\n\tstruct args\t*args = self->args;\n\n\tif (value != NULL) {\n\t\tcmdq_error(cmdq, \"value passed to unset option: %s\", oe->name);\n\t\treturn (-1);\n\t}\n\n\tif (args_has(args, 'g') || oo == global_options) {\n\t\tswitch (oe->type) {\n\t\tcase OPTIONS_TABLE_STRING:\n\t\t\toptions_set_string(oo, oe->name, \"%s\", oe->default_str);\n\t\t\tbreak;\n\t\tcase OPTIONS_TABLE_STYLE:\n\t\t\toptions_set_style(oo, oe->name, oe->default_str, 0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\toptions_set_number(oo, oe->name, oe->default_num);\n\t\t\tbreak;\n\t\t}\n\t} else\n\t\toptions_remove(oo, oe->name);\n\treturn (0);\n}\n\n/* Set an option. */\nint\ncmd_set_option_set(struct cmd *self, struct cmd_q *cmdq,\n    const struct options_table_entry *oe, struct options *oo,\n    const char *value)\n{\n\tstruct options_entry\t*o;\n\n\tswitch (oe->type) {\n\tcase OPTIONS_TABLE_FLAG:\n\tcase OPTIONS_TABLE_CHOICE:\n\t\tbreak;\n\tdefault:\n\t\tif (value == NULL) {\n\t\t\tcmdq_error(cmdq, \"empty value\");\n\t\t\treturn (-1);\n\t\t}\n\t}\n\n\to = NULL;\n\tswitch (oe->type) {\n\tcase OPTIONS_TABLE_STRING:\n\t\to = cmd_set_option_string(self, cmdq, oe, oo, value);\n\t\tbreak;\n\tcase OPTIONS_TABLE_NUMBER:\n\t\to = cmd_set_option_number(self, cmdq, oe, oo, value);\n\t\tbreak;\n\tcase OPTIONS_TABLE_KEY:\n\t\to = cmd_set_option_key(self, cmdq, oe, oo, value);\n\t\tbreak;\n\tcase OPTIONS_TABLE_COLOUR:\n\t\to = cmd_set_option_colour(self, cmdq, oe, oo, value);\n\t\tif (o != NULL)\n\t\t\tstyle_update_new(oo, o->name, oe->style);\n\t\tbreak;\n\tcase OPTIONS_TABLE_ATTRIBUTES:\n\t\to = cmd_set_option_attributes(self, cmdq, oe, oo, value);\n\t\tif (o != NULL)\n\t\t\tstyle_update_new(oo, o->name, oe->style);\n\t\tbreak;\n\tcase OPTIONS_TABLE_FLAG:\n\t\to = cmd_set_option_flag(self, cmdq, oe, oo, value);\n\t\tbreak;\n\tcase OPTIONS_TABLE_CHOICE:\n\t\to = cmd_set_option_choice(self, cmdq, oe, oo, value);\n\t\tbreak;\n\tcase OPTIONS_TABLE_STYLE:\n\t\to = cmd_set_option_style(self, cmdq, oe, oo, value);\n\t\tbreak;\n\t}\n\tif (o == NULL)\n\t\treturn (-1);\n\treturn (0);\n}\n\n/* Set a string option. */\nstruct options_entry *\ncmd_set_option_string(struct cmd *self, __unused struct cmd_q *cmdq,\n    const struct options_table_entry *oe, struct options *oo,\n    const char *value)\n{\n\tstruct args\t\t*args = self->args;\n\tstruct options_entry\t*o;\n\tchar\t\t\t*oldval, *newval;\n\n\tif (args_has(args, 'a')) {\n\t\toldval = options_get_string(oo, oe->name);\n\t\txasprintf(&newval, \"%s%s\", oldval, value);\n\t} else\n\t\tnewval = xstrdup(value);\n\n\to = options_set_string(oo, oe->name, \"%s\", newval);\n\n\tfree(newval);\n\treturn (o);\n}\n\n/* Set a number option. */\nstruct options_entry *\ncmd_set_option_number(__unused struct cmd *self, struct cmd_q *cmdq,\n    const struct options_table_entry *oe, struct options *oo,\n    const char *value)\n{\n\tlong long\t ll;\n\tconst char     \t*errstr;\n\n\tll = strtonum(value, oe->minimum, oe->maximum, &errstr);\n\tif (errstr != NULL) {\n\t\tcmdq_error(cmdq, \"value is %s: %s\", errstr, value);\n\t\treturn (NULL);\n\t}\n\n\treturn (options_set_number(oo, oe->name, ll));\n}\n\n/* Set a key option. */\nstruct options_entry *\ncmd_set_option_key(__unused struct cmd *self, struct cmd_q *cmdq,\n    const struct options_table_entry *oe, struct options *oo,\n    const char *value)\n{\n\tkey_code\tkey;\n\n\tkey = key_string_lookup_string(value);\n\tif (key == KEYC_UNKNOWN) {\n\t\tcmdq_error(cmdq, \"bad key: %s\", value);\n\t\treturn (NULL);\n\t}\n\n\treturn (options_set_number(oo, oe->name, key));\n}\n\n/* Set a colour option. */\nstruct options_entry *\ncmd_set_option_colour(__unused struct cmd *self, struct cmd_q *cmdq,\n    const struct options_table_entry *oe, struct options *oo,\n    const char *value)\n{\n\tint\tcolour;\n\n\tif ((colour = colour_fromstring(value)) == -1) {\n\t\tcmdq_error(cmdq, \"bad colour: %s\", value);\n\t\treturn (NULL);\n\t}\n\n\treturn (options_set_number(oo, oe->name, colour));\n}\n\n/* Set an attributes option. */\nstruct options_entry *\ncmd_set_option_attributes(__unused struct cmd *self, struct cmd_q *cmdq,\n    const struct options_table_entry *oe, struct options *oo,\n    const char *value)\n{\n\tint\tattr;\n\n\tif ((attr = attributes_fromstring(value)) == -1) {\n\t\tcmdq_error(cmdq, \"bad attributes: %s\", value);\n\t\treturn (NULL);\n\t}\n\n\treturn (options_set_number(oo, oe->name, attr));\n}\n\n/* Set a flag option. */\nstruct options_entry *\ncmd_set_option_flag(__unused struct cmd *self, struct cmd_q *cmdq,\n    const struct options_table_entry *oe, struct options *oo,\n    const char *value)\n{\n\tint\tflag;\n\n\tif (value == NULL || *value == '\\0')\n\t\tflag = !options_get_number(oo, oe->name);\n\telse {\n\t\tif ((value[0] == '1' && value[1] == '\\0') ||\n\t\t    strcasecmp(value, \"on\") == 0 ||\n\t\t    strcasecmp(value, \"yes\") == 0)\n\t\t\tflag = 1;\n\t\telse if ((value[0] == '0' && value[1] == '\\0') ||\n\t\t    strcasecmp(value, \"off\") == 0 ||\n\t\t    strcasecmp(value, \"no\") == 0)\n\t\t\tflag = 0;\n\t\telse {\n\t\t\tcmdq_error(cmdq, \"bad value: %s\", value);\n\t\t\treturn (NULL);\n\t\t}\n\t}\n\n\treturn (options_set_number(oo, oe->name, flag));\n}\n\n/* Set a choice option. */\nstruct options_entry *\ncmd_set_option_choice(__unused struct cmd *self, struct cmd_q *cmdq,\n    const struct options_table_entry *oe, struct options *oo,\n    const char *value)\n{\n\tconst char\t**choicep;\n\tint\t\t  n, choice = -1;\n\n\tif (value == NULL) {\n\t\tchoice = options_get_number(oo, oe->name);\n\t\tif (choice < 2)\n\t\t\tchoice = !choice;\n\t} else {\n\t\tn = 0;\n\t\tfor (choicep = oe->choices; *choicep != NULL; choicep++) {\n\t\t\tn++;\n\t\t\tif (strncmp(*choicep, value, strlen(value)) != 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (choice != -1) {\n\t\t\t\tcmdq_error(cmdq, \"ambiguous value: %s\", value);\n\t\t\t\treturn (NULL);\n\t\t\t}\n\t\t\tchoice = n - 1;\n\t\t}\n\t\tif (choice == -1) {\n\t\t\tcmdq_error(cmdq, \"unknown value: %s\", value);\n\t\t\treturn (NULL);\n\t\t}\n\t}\n\n\treturn (options_set_number(oo, oe->name, choice));\n}\n\n/* Set a style option. */\nstruct options_entry *\ncmd_set_option_style(struct cmd *self, struct cmd_q *cmdq,\n    const struct options_table_entry *oe, struct options *oo,\n    const char *value)\n{\n\tstruct args\t\t*args = self->args;\n\tstruct options_entry\t*o;\n\tint\t\t\t append;\n\n\tappend = args_has(args, 'a');\n\tif ((o = options_set_style(oo, oe->name, value, append)) == NULL) {\n\t\tcmdq_error(cmdq, \"bad style: %s\", value);\n\t\treturn (NULL);\n\t}\n\n\tstyle_update_old(oo, oe->name, &o->style);\n\treturn (o);\n}\n"
        },
        {
          "name": "cmd-show-environment.c",
          "type": "blob",
          "size": 3.470703125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * Show environment.\n */\n\nenum cmd_retval\tcmd_show_environment_exec(struct cmd *, struct cmd_q *);\n\nchar\t*cmd_show_environment_escape(struct environ_entry *);\nvoid\t cmd_show_environment_print(struct cmd *, struct cmd_q *,\n\t     struct environ_entry *);\n\nconst struct cmd_entry cmd_show_environment_entry = {\n\t.name = \"show-environment\",\n\t.alias = \"showenv\",\n\n\t.args = { \"gst:\", 0, 1 },\n\t.usage = \"[-gs] \" CMD_TARGET_SESSION_USAGE \" [name]\",\n\n\t.tflag = CMD_SESSION_CANFAIL,\n\n\t.flags = 0,\n\t.exec = cmd_show_environment_exec\n};\n\nchar *\ncmd_show_environment_escape(struct environ_entry *envent)\n{\n\tconst char\t*value = envent->value;\n\tchar\t\t c, *out, *ret;\n\n\tout = ret = xmalloc(strlen(value) * 2 + 1); /* at most twice the size */\n\twhile ((c = *value++) != '\\0') {\n\t\t/* POSIX interprets $ ` \" and \\ in double quotes. */\n\t\tif (c == '$' || c == '`' || c == '\"' || c == '\\\\')\n\t\t\t*out++ = '\\\\';\n\t\t*out++ = c;\n\t}\n\t*out = '\\0';\n\n\treturn (ret);\n}\n\nvoid\ncmd_show_environment_print(struct cmd *self, struct cmd_q *cmdq,\n    struct environ_entry *envent)\n{\n\tchar\t*escaped;\n\n\tif (!args_has(self->args, 's')) {\n\t\tif (envent->value != NULL)\n\t\t\tcmdq_print(cmdq, \"%s=%s\", envent->name, envent->value);\n\t\telse\n\t\t\tcmdq_print(cmdq, \"-%s\", envent->name);\n\t\treturn;\n\t}\n\n\tif (envent->value != NULL) {\n\t\tescaped = cmd_show_environment_escape(envent);\n\t\tcmdq_print(cmdq, \"%s=\\\"%s\\\"; export %s;\", envent->name, escaped,\n\t\t    envent->name);\n\t\tfree(escaped);\n\t} else\n\t\tcmdq_print(cmdq, \"unset %s;\", envent->name);\n}\n\nenum cmd_retval\ncmd_show_environment_exec(struct cmd *self, struct cmd_q *cmdq)\n{\n\tstruct args\t\t*args = self->args;\n\tstruct environ\t\t*env;\n\tstruct environ_entry\t*envent;\n\tconst char\t\t*target;\n\n\tif ((target = args_get(args, 't')) != NULL) {\n\t\tif (cmdq->state.tflag.s == NULL) {\n\t\t\tcmdq_error(cmdq, \"no such session: %s\", target);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t}\n\n\tif (args_has(self->args, 'g'))\n\t\tenv = global_environ;\n\telse {\n\t\tif (cmdq->state.tflag.s == NULL) {\n\t\t\ttarget = args_get(args, 't');\n\t\t\tif (target != NULL)\n\t\t\t\tcmdq_error(cmdq, \"no such session: %s\", target);\n\t\t\telse\n\t\t\t\tcmdq_error(cmdq, \"no current session\");\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\tenv = cmdq->state.tflag.s->environ;\n\t}\n\n\tif (args->argc != 0) {\n\t\tenvent = environ_find(env, args->argv[0]);\n\t\tif (envent == NULL) {\n\t\t\tcmdq_error(cmdq, \"unknown variable: %s\", args->argv[0]);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\tcmd_show_environment_print(self, cmdq, envent);\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tenvent = environ_first(env);\n\twhile (envent != NULL) {\n\t\tcmd_show_environment_print(self, cmdq, envent);\n\t\tenvent = environ_next(envent);\n\t}\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-show-messages.c",
          "type": "blob",
          "size": 3.025390625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\n/*\n * Show client message log.\n */\n\nenum cmd_retval\t cmd_show_messages_exec(struct cmd *, struct cmd_q *);\n\nconst struct cmd_entry cmd_show_messages_entry = {\n\t.name = \"show-messages\",\n\t.alias = \"showmsgs\",\n\n\t.args = { \"JTt:\", 0, 0 },\n\t.usage = \"[-JT] \" CMD_TARGET_CLIENT_USAGE,\n\n\t.tflag = CMD_CLIENT,\n\n\t.flags = 0,\n\t.exec = cmd_show_messages_exec\n};\n\nconst struct cmd_entry cmd_server_info_entry = {\n\t.name = \"server-info\",\n\t.alias = \"info\",\n\n\t.args = { \"\", 0, 0 },\n\t.usage = \"\",\n\n\t.flags = 0,\n\t.exec = cmd_show_messages_exec\n};\n\nint\tcmd_show_messages_terminals(struct cmd_q *, int);\nint\tcmd_show_messages_jobs(struct cmd_q *, int);\n\nint\ncmd_show_messages_terminals(struct cmd_q *cmdq, int blank)\n{\n\tstruct tty_term\t*term;\n\tu_int\t\t i, n;\n\n\tn = 0;\n\tLIST_FOREACH(term, &tty_terms, entry) {\n\t\tif (blank) {\n\t\t\tcmdq_print(cmdq, \"%s\", \"\");\n\t\t\tblank = 0;\n\t\t}\n\t\tcmdq_print(cmdq, \"Terminal %u: %s [references=%u, flags=0x%x]:\",\n\t\t    n, term->name, term->references, term->flags);\n\t\tn++;\n\t\tfor (i = 0; i < tty_term_ncodes(); i++)\n\t\t\tcmdq_print(cmdq, \"%s\", tty_term_describe(term, i));\n\t}\n\treturn (n != 0);\n}\n\nint\ncmd_show_messages_jobs(struct cmd_q *cmdq, int blank)\n{\n\tstruct job\t*job;\n\tu_int\t\t n;\n\n\tn = 0;\n\tLIST_FOREACH(job, &all_jobs, lentry) {\n\t\tif (blank) {\n\t\t\tcmdq_print(cmdq, \"%s\", \"\");\n\t\t\tblank = 0;\n\t\t}\n\t\tcmdq_print(cmdq, \"Job %u: %s [fd=%d, pid=%d, status=%d]\",\n\t\t    n, job->cmd, job->fd, job->pid, job->status);\n\t\tn++;\n\t}\n\treturn (n != 0);\n}\n\nenum cmd_retval\ncmd_show_messages_exec(struct cmd *self, struct cmd_q *cmdq)\n{\n\tstruct args\t\t*args = self->args;\n\tstruct client\t\t*c = cmdq->state.c;\n\tstruct message_entry\t*msg;\n\tchar\t\t\t*tim;\n\tint\t\t\t done, blank;\n\n\tdone = blank = 0;\n\tif (args_has(args, 'T') || self->entry == &cmd_server_info_entry) {\n\t\tblank = cmd_show_messages_terminals(cmdq, blank);\n\t\tdone = 1;\n\t}\n\tif (args_has(args, 'J') || self->entry == &cmd_server_info_entry) {\n\t\tcmd_show_messages_jobs(cmdq, blank);\n\t\tdone = 1;\n\t}\n\tif (done)\n\t\treturn (CMD_RETURN_NORMAL);\n\n\tTAILQ_FOREACH(msg, &c->message_log, entry) {\n\t\ttim = ctime(&msg->msg_time);\n\t\t*strchr(tim, '\\n') = '\\0';\n\n\t\tcmdq_print(cmdq, \"%s %s\", tim, msg->msg);\n\t}\n\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-show-options.c",
          "type": "blob",
          "size": 5.1689453125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * Show options.\n */\n\nenum cmd_retval\t cmd_show_options_exec(struct cmd *, struct cmd_q *);\n\nenum cmd_retval\tcmd_show_options_one(struct cmd *, struct cmd_q *,\n\t\t    struct options *, int);\nenum cmd_retval cmd_show_options_all(struct cmd *, struct cmd_q *,\n\t    \t    struct options *, enum options_table_scope);\n\nconst struct cmd_entry cmd_show_options_entry = {\n\t.name = \"show-options\",\n\t.alias = \"show\",\n\n\t.args = { \"gqst:vw\", 0, 1 },\n\t.usage = \"[-gqsvw] [-t target-session|target-window] [option]\",\n\n\t.tflag = CMD_WINDOW_CANFAIL,\n\n\t.flags = 0,\n\t.exec = cmd_show_options_exec\n};\n\nconst struct cmd_entry cmd_show_window_options_entry = {\n\t.name = \"show-window-options\",\n\t.alias = \"showw\",\n\n\t.args = { \"gvt:\", 0, 1 },\n\t.usage = \"[-gv] \" CMD_TARGET_WINDOW_USAGE \" [option]\",\n\n\t.tflag = CMD_WINDOW_CANFAIL,\n\n\t.flags = 0,\n\t.exec = cmd_show_options_exec\n};\n\nenum cmd_retval\ncmd_show_options_exec(struct cmd *self, struct cmd_q *cmdq)\n{\n\tstruct args\t\t\t*args = self->args;\n\tstruct session\t\t\t*s = cmdq->state.tflag.s;\n\tstruct winlink\t\t\t*wl = cmdq->state.tflag.wl;\n\tstruct options\t\t\t*oo;\n\tenum options_table_scope\t scope;\n\tint\t\t\t\t quiet;\n\tconst char\t\t\t*target;\n\n\tif (args_has(self->args, 's')) {\n\t\too = global_options;\n\t\tscope = OPTIONS_TABLE_SERVER;\n\t} else if (args_has(self->args, 'w') ||\n\t    self->entry == &cmd_show_window_options_entry) {\n\t\tscope = OPTIONS_TABLE_WINDOW;\n\t\tif (args_has(self->args, 'g'))\n\t\t\too = global_w_options;\n\t\telse if (wl == NULL) {\n\t\t\ttarget = args_get(args, 't');\n\t\t\tif (target != NULL) {\n\t\t\t\tcmdq_error(cmdq, \"no such window: %s\", target);\n\t\t\t} else\n\t\t\t\tcmdq_error(cmdq, \"no current window\");\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t} else\n\t\t\too = wl->window->options;\n\t} else {\n\t\tscope = OPTIONS_TABLE_SESSION;\n\t\tif (args_has(self->args, 'g'))\n\t\t\too = global_s_options;\n\t\telse if (s == NULL) {\n\t\t\ttarget = args_get(args, 't');\n\t\t\tif (target != NULL) {\n\t\t\t\tcmdq_error(cmdq, \"no such session: %s\", target);\n\t\t\t} else\n\t\t\t\tcmdq_error(cmdq, \"no current session\");\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t} else\n\t\t\too = s->options;\n\t}\n\n\tquiet = args_has(self->args, 'q');\n\tif (args->argc == 0)\n\t\treturn (cmd_show_options_all(self, cmdq, oo, scope));\n\telse\n\t\treturn (cmd_show_options_one(self, cmdq, oo, quiet));\n}\n\nenum cmd_retval\ncmd_show_options_one(struct cmd *self, struct cmd_q *cmdq,\n    struct options *oo, int quiet)\n{\n\tstruct args\t\t\t\t*args = self->args;\n\tconst char\t\t\t\t*name = args->argv[0];\n\tconst struct options_table_entry\t*oe;\n\tstruct options_entry\t\t\t*o;\n\tconst char\t\t\t\t*optval;\n\nretry:\n\tif (*name == '@') {\n\t\tif ((o = options_find1(oo, name)) == NULL) {\n\t\t\tif (quiet)\n\t\t\t\treturn (CMD_RETURN_NORMAL);\n\t\t\tcmdq_error(cmdq, \"unknown option: %s\", name);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\tif (args_has(self->args, 'v'))\n\t\t\tcmdq_print(cmdq, \"%s\", o->str);\n\t\telse\n\t\t\tcmdq_print(cmdq, \"%s \\\"%s\\\"\", o->name, o->str);\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\toe = NULL;\n\tif (options_table_find(name, &oe) != 0) {\n\t\tcmdq_error(cmdq, \"ambiguous option: %s\", name);\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\tif (oe == NULL) {\n\t\tif (quiet)\n\t\t\treturn (CMD_RETURN_NORMAL);\n\t\tcmdq_error(cmdq, \"unknown option: %s\", name);\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\tif (oe->style != NULL) {\n\t\tname = oe->style;\n\t\tgoto retry;\n\t}\n\tif ((o = options_find1(oo, oe->name)) == NULL)\n\t\treturn (CMD_RETURN_NORMAL);\n\toptval = options_table_print_entry(oe, o, args_has(self->args, 'v'));\n\tif (args_has(self->args, 'v'))\n\t\tcmdq_print(cmdq, \"%s\", optval);\n\telse\n\t\tcmdq_print(cmdq, \"%s %s\", oe->name, optval);\n\treturn (CMD_RETURN_NORMAL);\n}\n\nenum cmd_retval\ncmd_show_options_all(struct cmd *self, struct cmd_q *cmdq, struct options *oo,\n    enum options_table_scope scope)\n{\n\tconst struct options_table_entry\t*oe;\n\tstruct options_entry\t\t\t*o;\n\tconst char\t\t\t\t*optval;\n\tint\t\t\t\t\t vflag;\n\n\to = options_first(oo);\n\twhile (o != NULL) {\n\t\tif (*o->name == '@') {\n\t\t\tif (args_has(self->args, 'v'))\n\t\t\t\tcmdq_print(cmdq, \"%s\", o->str);\n\t\t\telse\n\t\t\t\tcmdq_print(cmdq, \"%s \\\"%s\\\"\", o->name, o->str);\n\t\t}\n\t\to = options_next(o);\n\t}\n\n\tvflag = args_has(self->args, 'v');\n\tfor (oe = options_table; oe->name != NULL; oe++) {\n\t\tif (oe->style != NULL || oe->scope != scope)\n\t\t\tcontinue;\n\t\tif ((o = options_find1(oo, oe->name)) == NULL)\n\t\t\tcontinue;\n\t\toptval = options_table_print_entry(oe, o, vflag);\n\t\tif (vflag)\n\t\t\tcmdq_print(cmdq, \"%s\", optval);\n\t\telse\n\t\t\tcmdq_print(cmdq, \"%s %s\", oe->name, optval);\n\t}\n\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-source-file.c",
          "type": "blob",
          "size": 2.1845703125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2008 Tiago Cunha <me@tiagocunha.org>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n\n#include \"tmux.h\"\n\n/*\n * Sources a configuration file.\n */\n\nenum cmd_retval\tcmd_source_file_exec(struct cmd *, struct cmd_q *);\n\nvoid\t\tcmd_source_file_done(struct cmd_q *);\n\nconst struct cmd_entry cmd_source_file_entry = {\n\t.name = \"source-file\",\n\t.alias = \"source\",\n\n\t.args = { \"\", 1, 1 },\n\t.usage = \"path\",\n\n\t.flags = 0,\n\t.exec = cmd_source_file_exec\n};\n\nenum cmd_retval\ncmd_source_file_exec(struct cmd *self, struct cmd_q *cmdq)\n{\n\tstruct args\t*args = self->args;\n\tstruct cmd_q\t*cmdq1;\n\tchar\t\t*cause;\n\n\tcmdq1 = cmdq_new(cmdq->client);\n\tcmdq1->emptyfn = cmd_source_file_done;\n\tcmdq1->data = cmdq;\n\n\tswitch (load_cfg(args->argv[0], cmdq1, &cause)) {\n\tcase -1:\n\t\tif (cfg_references == 0) {\n\t\t\tcmdq_free(cmdq1);\n\t\t\tcmdq_error(cmdq, \"%s\", cause);\n\t\t\tfree(cause);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\tcfg_add_cause(\"%s\", cause);\n\t\tfree(cause);\n\t\t/* FALLTHROUGH */\n\tcase 0:\n\t\tif (cfg_references == 0)\n\t\t\tcfg_print_causes(cmdq);\n\t\tcmdq_free(cmdq1);\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tcmdq->references++;\n\tcfg_references++;\n\n\tcmdq_continue(cmdq1);\n\treturn (CMD_RETURN_WAIT);\n}\n\nvoid\ncmd_source_file_done(struct cmd_q *cmdq1)\n{\n\tstruct cmd_q\t*cmdq = cmdq1->data;\n\n\tif (cmdq1->client_exit >= 0)\n\t\tcmdq->client_exit = cmdq1->client_exit;\n\n\tcmdq_free(cmdq1);\n\n\tcfg_references--;\n\n\tif (cmdq_free(cmdq))\n\t\treturn;\n\n\tif (cfg_references == 0)\n\t\tcfg_print_causes(cmdq);\n\tcmdq_continue(cmdq);\n}\n"
        },
        {
          "name": "cmd-split-window.c",
          "type": "blob",
          "size": 4.9404296875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <errno.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\n/*\n * Split a window (add a new pane).\n */\n\n#define SPLIT_WINDOW_TEMPLATE \"#{session_name}:#{window_index}.#{pane_index}\"\n\nenum cmd_retval\t cmd_split_window_exec(struct cmd *, struct cmd_q *);\n\nconst struct cmd_entry cmd_split_window_entry = {\n\t.name = \"split-window\",\n\t.alias = \"splitw\",\n\n\t.args = { \"bc:dF:l:hp:Pt:v\", 0, -1 },\n\t.usage = \"[-bdhvP] [-c start-directory] [-F format] \"\n\t\t \"[-p percentage|-l size] \" CMD_TARGET_PANE_USAGE \" [command]\",\n\n\t.tflag = CMD_PANE,\n\n\t.flags = 0,\n\t.exec = cmd_split_window_exec\n};\n\nenum cmd_retval\ncmd_split_window_exec(struct cmd *self, struct cmd_q *cmdq)\n{\n\tstruct args\t\t*args = self->args;\n\tstruct session\t\t*s = cmdq->state.tflag.s;\n\tstruct winlink\t\t*wl = cmdq->state.tflag.wl;\n\tstruct window\t\t*w = wl->window;\n\tstruct window_pane\t*wp = cmdq->state.tflag.wp, *new_wp = NULL;\n\tstruct environ\t\t*env;\n\tconst char\t\t*cmd, *path, *shell, *template, *cwd, *to_free;\n\tchar\t\t       **argv, *cause, *new_cause, *cp;\n\tu_int\t\t\t hlimit;\n\tint\t\t\t argc, size, percentage;\n\tenum layout_type\t type;\n\tstruct layout_cell\t*lc;\n\tstruct format_tree\t*ft;\n\tstruct environ_entry\t*envent;\n\n\tserver_unzoom_window(w);\n\n\tenv = environ_create();\n\tenviron_copy(global_environ, env);\n\tenviron_copy(s->environ, env);\n\tserver_fill_environ(s, env);\n\n\tif (args->argc == 0) {\n\t\tcmd = options_get_string(s->options, \"default-command\");\n\t\tif (cmd != NULL && *cmd != '\\0') {\n\t\t\targc = 1;\n\t\t\targv = (char **)&cmd;\n\t\t} else {\n\t\t\targc = 0;\n\t\t\targv = NULL;\n\t\t}\n\t} else {\n\t\targc = args->argc;\n\t\targv = args->argv;\n\t}\n\n\tto_free = NULL;\n\tif (args_has(args, 'c')) {\n\t\tft = format_create(cmdq, 0);\n\t\tformat_defaults(ft, cmdq->state.c, s, NULL, NULL);\n\t\tto_free = cwd = format_expand(ft, args_get(args, 'c'));\n\t\tformat_free(ft);\n\t} else if (cmdq->client != NULL && cmdq->client->session == NULL)\n\t\tcwd = cmdq->client->cwd;\n\telse\n\t\tcwd = s->cwd;\n\n\ttype = LAYOUT_TOPBOTTOM;\n\tif (args_has(args, 'h'))\n\t\ttype = LAYOUT_LEFTRIGHT;\n\n\tsize = -1;\n\tif (args_has(args, 'l')) {\n\t\tsize = args_strtonum(args, 'l', 0, INT_MAX, &cause);\n\t\tif (cause != NULL) {\n\t\t\txasprintf(&new_cause, \"size %s\", cause);\n\t\t\tfree(cause);\n\t\t\tcause = new_cause;\n\t\t\tgoto error;\n\t\t}\n\t} else if (args_has(args, 'p')) {\n\t\tpercentage = args_strtonum(args, 'p', 0, INT_MAX, &cause);\n\t\tif (cause != NULL) {\n\t\t\txasprintf(&new_cause, \"percentage %s\", cause);\n\t\t\tfree(cause);\n\t\t\tcause = new_cause;\n\t\t\tgoto error;\n\t\t}\n\t\tif (type == LAYOUT_TOPBOTTOM)\n\t\t\tsize = (wp->sy * percentage) / 100;\n\t\telse\n\t\t\tsize = (wp->sx * percentage) / 100;\n\t}\n\thlimit = options_get_number(s->options, \"history-limit\");\n\n\tshell = options_get_string(s->options, \"default-shell\");\n\tif (*shell == '\\0' || areshell(shell))\n\t\tshell = _PATH_BSHELL;\n\n\tlc = layout_split_pane(wp, type, size, args_has(args, 'b'));\n\tif (lc == NULL) {\n\t\tcause = xstrdup(\"pane too small\");\n\t\tgoto error;\n\t}\n\tnew_wp = window_add_pane(w, hlimit);\n\tlayout_assign_pane(lc, new_wp);\n\n\tpath = NULL;\n\tif (cmdq->client != NULL && cmdq->client->session == NULL)\n\t\tenvent = environ_find(cmdq->client->environ, \"PATH\");\n\telse\n\t\tenvent = environ_find(s->environ, \"PATH\");\n\tif (envent != NULL)\n\t\tpath = envent->value;\n\n\tif (window_pane_spawn(new_wp, argc, argv, path, shell, cwd, env,\n\t    s->tio, &cause) != 0)\n\t\tgoto error;\n\n\tserver_redraw_window(w);\n\n\tif (!args_has(args, 'd')) {\n\t\twindow_set_active_pane(w, new_wp);\n\t\tsession_select(s, wl->idx);\n\t\tserver_redraw_session(s);\n\t} else\n\t\tserver_status_session(s);\n\n\tenviron_free(env);\n\n\tif (args_has(args, 'P')) {\n\t\tif ((template = args_get(args, 'F')) == NULL)\n\t\t\ttemplate = SPLIT_WINDOW_TEMPLATE;\n\n\t\tft = format_create(cmdq, 0);\n\t\tformat_defaults(ft, cmdq->state.c, s, wl, new_wp);\n\n\t\tcp = format_expand(ft, template);\n\t\tcmdq_print(cmdq, \"%s\", cp);\n\t\tfree(cp);\n\n\t\tformat_free(ft);\n\t}\n\tnotify_window_layout_changed(w);\n\n\tif (to_free != NULL)\n\t\tfree((void *)to_free);\n\treturn (CMD_RETURN_NORMAL);\n\nerror:\n\tenviron_free(env);\n\tif (new_wp != NULL) {\n\t\tlayout_close_pane(new_wp);\n\t\twindow_remove_pane(w, new_wp);\n\t}\n\tcmdq_error(cmdq, \"create pane failed: %s\", cause);\n\tfree(cause);\n\n\tif (to_free != NULL)\n\t\tfree((void *)to_free);\n\treturn (CMD_RETURN_ERROR);\n}\n"
        },
        {
          "name": "cmd-string.c",
          "type": "blob",
          "size": 6.96484375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2008 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <errno.h>\n#include <pwd.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\n/*\n * Parse a command from a string.\n */\n\nint\t cmd_string_getc(const char *, size_t *);\nvoid\t cmd_string_ungetc(size_t *);\nvoid\t cmd_string_copy(char **, char *, size_t *);\nchar\t*cmd_string_string(const char *, size_t *, char, int);\nchar\t*cmd_string_variable(const char *, size_t *);\nchar\t*cmd_string_expand_tilde(const char *, size_t *);\n\nint\ncmd_string_getc(const char *s, size_t *p)\n{\n\tconst u_char\t*ucs = s;\n\n\tif (ucs[*p] == '\\0')\n\t\treturn (EOF);\n\treturn (ucs[(*p)++]);\n}\n\nvoid\ncmd_string_ungetc(size_t *p)\n{\n\t(*p)--;\n}\n\n/*\n * Parse command string. Returns -1 on error. If returning -1, cause is error\n * string, or NULL for empty command.\n */\nint\ncmd_string_parse(const char *s, struct cmd_list **cmdlist, const char *file,\n    u_int line, char **cause)\n{\n\tsize_t\t\tp;\n\tint\t\tch, i, argc, rval;\n\tchar\t      **argv, *buf, *t;\n\tconst char     *whitespace, *equals;\n\tsize_t\t\tlen;\n\n\targv = NULL;\n\targc = 0;\n\n\tbuf = NULL;\n\tlen = 0;\n\n\t*cause = NULL;\n\n\t*cmdlist = NULL;\n\trval = -1;\n\n\tp = 0;\n\tfor (;;) {\n\t\tch = cmd_string_getc(s, &p);\n\t\tswitch (ch) {\n\t\tcase '\\'':\n\t\t\tif ((t = cmd_string_string(s, &p, '\\'', 0)) == NULL)\n\t\t\t\tgoto error;\n\t\t\tcmd_string_copy(&buf, t, &len);\n\t\t\tbreak;\n\t\tcase '\"':\n\t\t\tif ((t = cmd_string_string(s, &p, '\"', 1)) == NULL)\n\t\t\t\tgoto error;\n\t\t\tcmd_string_copy(&buf, t, &len);\n\t\t\tbreak;\n\t\tcase '$':\n\t\t\tif ((t = cmd_string_variable(s, &p)) == NULL)\n\t\t\t\tgoto error;\n\t\t\tcmd_string_copy(&buf, t, &len);\n\t\t\tbreak;\n\t\tcase '#':\n\t\t\t/* Comment: discard rest of line. */\n\t\t\twhile ((ch = cmd_string_getc(s, &p)) != EOF)\n\t\t\t\t;\n\t\t\t/* FALLTHROUGH */\n\t\tcase EOF:\n\t\tcase ' ':\n\t\tcase '\\t':\n\t\t\tif (buf != NULL) {\n\t\t\t\tbuf = xrealloc(buf, len + 1);\n\t\t\t\tbuf[len] = '\\0';\n\n\t\t\t\targv = xreallocarray(argv, argc + 1,\n\t\t\t\t    sizeof *argv);\n\t\t\t\targv[argc++] = buf;\n\n\t\t\t\tbuf = NULL;\n\t\t\t\tlen = 0;\n\t\t\t}\n\n\t\t\tif (ch != EOF)\n\t\t\t\tbreak;\n\n\t\t\twhile (argc != 0) {\n\t\t\t\tequals = strchr(argv[0], '=');\n\t\t\t\twhitespace = argv[0] + strcspn(argv[0], \" \\t\");\n\t\t\t\tif (equals == NULL || equals > whitespace)\n\t\t\t\t\tbreak;\n\t\t\t\tenviron_put(global_environ, argv[0]);\n\t\t\t\targc--;\n\t\t\t\tmemmove(argv, argv + 1, argc * (sizeof *argv));\n\t\t\t}\n\t\t\tif (argc == 0)\n\t\t\t\tgoto out;\n\n\t\t\t*cmdlist = cmd_list_parse(argc, argv, file, line, cause);\n\t\t\tif (*cmdlist == NULL)\n\t\t\t\tgoto out;\n\n\t\t\trval = 0;\n\t\t\tgoto out;\n\t\tcase '~':\n\t\t\tif (buf == NULL) {\n\t\t\t\tt = cmd_string_expand_tilde(s, &p);\n\t\t\t\tif (t == NULL)\n\t\t\t\t\tgoto error;\n\t\t\t\tcmd_string_copy(&buf, t, &len);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* FALLTHROUGH */\n\t\tdefault:\n\t\t\tif (len >= SIZE_MAX - 2)\n\t\t\t\tgoto error;\n\n\t\t\tbuf = xrealloc(buf, len + 1);\n\t\t\tbuf[len++] = ch;\n\t\t\tbreak;\n\t\t}\n\t}\n\nerror:\n\txasprintf(cause, \"invalid or unknown command: %s\", s);\n\nout:\n\tfree(buf);\n\n\tif (argv != NULL) {\n\t\tfor (i = 0; i < argc; i++)\n\t\t\tfree(argv[i]);\n\t\tfree(argv);\n\t}\n\n\treturn (rval);\n}\n\nvoid\ncmd_string_copy(char **dst, char *src, size_t *len)\n{\n\tsize_t srclen;\n\n\tsrclen = strlen(src);\n\n\t*dst = xrealloc(*dst, *len + srclen + 1);\n\tstrlcpy(*dst + *len, src, srclen + 1);\n\n\t*len += srclen;\n\tfree(src);\n}\n\nchar *\ncmd_string_string(const char *s, size_t *p, char endch, int esc)\n{\n\tint\tch;\n\tchar   *buf, *t;\n\tsize_t\tlen;\n\n\tbuf = NULL;\n\tlen = 0;\n\n\twhile ((ch = cmd_string_getc(s, p)) != endch) {\n\t\tswitch (ch) {\n\t\tcase EOF:\n\t\t\tgoto error;\n\t\tcase '\\\\':\n\t\t\tif (!esc)\n\t\t\t\tbreak;\n\t\t\tswitch (ch = cmd_string_getc(s, p)) {\n\t\t\tcase EOF:\n\t\t\t\tgoto error;\n\t\t\tcase 'e':\n\t\t\t\tch = '\\033';\n\t\t\t\tbreak;\n\t\t\tcase 'r':\n\t\t\t\tch = '\\r';\n\t\t\t\tbreak;\n\t\t\tcase 'n':\n\t\t\t\tch = '\\n';\n\t\t\t\tbreak;\n\t\t\tcase 't':\n\t\t\t\tch = '\\t';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '$':\n\t\t\tif (!esc)\n\t\t\t\tbreak;\n\t\t\tif ((t = cmd_string_variable(s, p)) == NULL)\n\t\t\t\tgoto error;\n\t\t\tcmd_string_copy(&buf, t, &len);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (len >= SIZE_MAX - 2)\n\t\t\tgoto error;\n\t\tbuf = xrealloc(buf, len + 1);\n\t\tbuf[len++] = ch;\n\t}\n\n\tbuf = xrealloc(buf, len + 1);\n\tbuf[len] = '\\0';\n\treturn (buf);\n\nerror:\n\tfree(buf);\n\treturn (NULL);\n}\n\nchar *\ncmd_string_variable(const char *s, size_t *p)\n{\n\tint\t\t\tch, fch;\n\tchar\t\t       *buf, *t;\n\tsize_t\t\t\tlen;\n\tstruct environ_entry   *envent;\n\n#define cmd_string_first(ch) ((ch) == '_' || \\\n\t((ch) >= 'a' && (ch) <= 'z') || ((ch) >= 'A' && (ch) <= 'Z'))\n#define cmd_string_other(ch) ((ch) == '_' || \\\n\t((ch) >= 'a' && (ch) <= 'z') || ((ch) >= 'A' && (ch) <= 'Z') || \\\n\t((ch) >= '0' && (ch) <= '9'))\n\n\tbuf = NULL;\n\tlen = 0;\n\n\tfch = EOF;\n\tswitch (ch = cmd_string_getc(s, p)) {\n\tcase EOF:\n\t\tgoto error;\n\tcase '{':\n\t\tfch = '{';\n\n\t\tch = cmd_string_getc(s, p);\n\t\tif (!cmd_string_first(ch))\n\t\t\tgoto error;\n\t\t/* FALLTHROUGH */\n\tdefault:\n\t\tif (!cmd_string_first(ch)) {\n\t\t\txasprintf(&t, \"$%c\", ch);\n\t\t\treturn (t);\n\t\t}\n\n\t\tbuf = xrealloc(buf, len + 1);\n\t\tbuf[len++] = ch;\n\n\t\tfor (;;) {\n\t\t\tch = cmd_string_getc(s, p);\n\t\t\tif (ch == EOF || !cmd_string_other(ch))\n\t\t\t\tbreak;\n\t\t\telse {\n\t\t\t\tif (len >= SIZE_MAX - 3)\n\t\t\t\t\tgoto error;\n\t\t\t\tbuf = xrealloc(buf, len + 1);\n\t\t\t\tbuf[len++] = ch;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (fch == '{' && ch != '}')\n\t\tgoto error;\n\tif (ch != EOF && fch != '{')\n\t\tcmd_string_ungetc(p); /* ch */\n\n\tbuf = xrealloc(buf, len + 1);\n\tbuf[len] = '\\0';\n\n\tenvent = environ_find(global_environ, buf);\n\tfree(buf);\n\tif (envent == NULL)\n\t\treturn (xstrdup(\"\"));\n#ifdef TMATE\n\tif (envent->value == NULL)\n\t\treturn (xstrdup(\"\"));\n#endif\n\treturn (xstrdup(envent->value));\n\nerror:\n\tfree(buf);\n\treturn (NULL);\n}\n\nchar *\ncmd_string_expand_tilde(const char *s, size_t *p)\n{\n\tstruct passwd\t\t*pw;\n\tstruct environ_entry\t*envent;\n\tchar\t\t\t*home, *path, *user, *cp;\n\tint\t\t\t last;\n\n\thome = NULL;\n\n\tlast = cmd_string_getc(s, p);\n\tif (last == EOF || last == '/' || last == ' '|| last == '\\t') {\n\t\tenvent = environ_find(global_environ, \"HOME\");\n\t\tif (envent != NULL && *envent->value != '\\0')\n\t\t\thome = envent->value;\n\t\telse if ((pw = getpwuid(getuid())) != NULL)\n\t\t\thome = pw->pw_dir;\n\t} else {\n\t\tcmd_string_ungetc(p);\n\n\t\tcp = user = xmalloc(strlen(s));\n\t\tfor (;;) {\n\t\t\tlast = cmd_string_getc(s, p);\n\t\t\tif (last == EOF || last == '/' || last == ' '|| last == '\\t')\n\t\t\t\tbreak;\n\t\t\t*cp++ = last;\n\t\t}\n\t\t*cp = '\\0';\n\n\t\tif ((pw = getpwnam(user)) != NULL)\n\t\t\thome = pw->pw_dir;\n\t\tfree(user);\n\t}\n\n\tif (home == NULL)\n\t\treturn (NULL);\n\n\tif (last != EOF)\n\t\txasprintf(&path, \"%s%c\", home, last);\n\telse\n\t\txasprintf(&path, \"%s\", home);\n\treturn (path);\n}\n"
        },
        {
          "name": "cmd-swap-pane.c",
          "type": "blob",
          "size": 3.6162109375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n\n#include \"tmux.h\"\n\n/*\n * Swap two panes.\n */\n\nenum cmd_retval\t cmd_swap_pane_exec(struct cmd *, struct cmd_q *);\n\nconst struct cmd_entry cmd_swap_pane_entry = {\n\t.name = \"swap-pane\",\n\t.alias = \"swapp\",\n\n\t.args = { \"dDs:t:U\", 0, 0 },\n\t.usage = \"[-dDU] \" CMD_SRCDST_PANE_USAGE,\n\n\t.sflag = CMD_PANE_MARKED,\n\t.tflag = CMD_PANE,\n\n\t.flags = 0,\n\t.exec = cmd_swap_pane_exec\n};\n\nenum cmd_retval\ncmd_swap_pane_exec(struct cmd *self, struct cmd_q *cmdq)\n{\n\tstruct window\t\t*src_w, *dst_w;\n\tstruct window_pane\t*tmp_wp, *src_wp, *dst_wp;\n\tstruct layout_cell\t*src_lc, *dst_lc;\n\tu_int\t\t\t sx, sy, xoff, yoff;\n\n\tdst_w = cmdq->state.tflag.wl->window;\n\tdst_wp = cmdq->state.tflag.wp;\n\tsrc_w = cmdq->state.sflag.wl->window;\n\tsrc_wp = cmdq->state.sflag.wp;\n\tserver_unzoom_window(dst_w);\n\n\tif (args_has(self->args, 'D')) {\n\t\tsrc_w = dst_w;\n\t\tsrc_wp = TAILQ_NEXT(dst_wp, entry);\n\t\tif (src_wp == NULL)\n\t\t\tsrc_wp = TAILQ_FIRST(&dst_w->panes);\n\t} else if (args_has(self->args, 'U')) {\n\t\tsrc_w = dst_w;\n\t\tsrc_wp = TAILQ_PREV(dst_wp, window_panes, entry);\n\t\tif (src_wp == NULL)\n\t\t\tsrc_wp = TAILQ_LAST(&dst_w->panes, window_panes);\n\t}\n\tserver_unzoom_window(src_w);\n\n#ifdef TMATE\n\tif (src_w != dst_w) {\n\t\tcmdq_error(cmdq, \"swap pane on different window is not supported with tmate\");\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n#endif\n\n\tif (src_wp == dst_wp)\n\t\treturn (CMD_RETURN_NORMAL);\n\n\ttmp_wp = TAILQ_PREV(dst_wp, window_panes, entry);\n\tTAILQ_REMOVE(&dst_w->panes, dst_wp, entry);\n\tTAILQ_REPLACE(&src_w->panes, src_wp, dst_wp, entry);\n\tif (tmp_wp == src_wp)\n\t\ttmp_wp = dst_wp;\n\tif (tmp_wp == NULL)\n\t\tTAILQ_INSERT_HEAD(&dst_w->panes, src_wp, entry);\n\telse\n\t\tTAILQ_INSERT_AFTER(&dst_w->panes, tmp_wp, src_wp, entry);\n\n\tsrc_lc = src_wp->layout_cell;\n\tdst_lc = dst_wp->layout_cell;\n\tsrc_lc->wp = dst_wp;\n\tdst_wp->layout_cell = src_lc;\n\tdst_lc->wp = src_wp;\n\tsrc_wp->layout_cell = dst_lc;\n\n\tsrc_wp->window = dst_w;\n\tdst_wp->window = src_w;\n\n\tsx = src_wp->sx; sy = src_wp->sy;\n\txoff = src_wp->xoff; yoff = src_wp->yoff;\n\tsrc_wp->xoff = dst_wp->xoff; src_wp->yoff = dst_wp->yoff;\n\twindow_pane_resize(src_wp, dst_wp->sx, dst_wp->sy);\n\tdst_wp->xoff = xoff; dst_wp->yoff = yoff;\n\twindow_pane_resize(dst_wp, sx, sy);\n\n\tif (!args_has(self->args, 'd')) {\n\t\tif (src_w != dst_w) {\n\t\t\twindow_set_active_pane(src_w, dst_wp);\n\t\t\twindow_set_active_pane(dst_w, src_wp);\n\t\t} else {\n\t\t\ttmp_wp = dst_wp;\n\t\t\tif (!window_pane_visible(tmp_wp))\n\t\t\t\ttmp_wp = src_wp;\n\t\t\twindow_set_active_pane(src_w, tmp_wp);\n\t\t}\n\t} else {\n\t\tif (src_w->active == src_wp)\n\t\t\twindow_set_active_pane(src_w, dst_wp);\n\t\tif (dst_w->active == dst_wp)\n\t\t\twindow_set_active_pane(dst_w, src_wp);\n\t}\n\tif (src_w != dst_w) {\n\t\tif (src_w->last == src_wp)\n\t\t\tsrc_w->last = NULL;\n\t\tif (dst_w->last == dst_wp)\n\t\t\tdst_w->last = NULL;\n\t}\n\tserver_redraw_window(src_w);\n\tserver_redraw_window(dst_w);\n\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-swap-window.c",
          "type": "blob",
          "size": 2.396484375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n\n#include \"tmux.h\"\n\n/*\n * Swap one window with another.\n */\n\nenum cmd_retval\tcmd_swap_window_exec(struct cmd *, struct cmd_q *);\n\nconst struct cmd_entry cmd_swap_window_entry = {\n\t.name = \"swap-window\",\n\t.alias = \"swapw\",\n\n\t.args = { \"ds:t:\", 0, 0 },\n\t.usage = \"[-d] \" CMD_SRCDST_WINDOW_USAGE,\n\n\t.sflag = CMD_WINDOW_MARKED,\n\t.tflag = CMD_WINDOW,\n\n\t.flags = 0,\n\t.exec = cmd_swap_window_exec\n};\n\nenum cmd_retval\ncmd_swap_window_exec(struct cmd *self, struct cmd_q *cmdq)\n{\n#ifdef TMATE\n\tcmdq_error(cmdq, \"swap window is not supported with tmate\");\n\treturn (CMD_RETURN_ERROR);\n#else\n\tstruct session\t\t*src, *dst;\n\tstruct session_group\t*sg_src, *sg_dst;\n\tstruct winlink\t\t*wl_src, *wl_dst;\n\tstruct window\t\t*w;\n\n\twl_src = cmdq->state.sflag.wl;\n\tsrc = cmdq->state.sflag.s;\n\tsg_src = session_group_find(src);\n\n\twl_dst = cmdq->state.tflag.wl;\n\tdst = cmdq->state.tflag.s;\n\tsg_dst = session_group_find(dst);\n\n\tif (src != dst && sg_src != NULL && sg_dst != NULL &&\n\t    sg_src == sg_dst) {\n\t\tcmdq_error(cmdq, \"can't move window, sessions are grouped\");\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\tif (wl_dst->window == wl_src->window)\n\t\treturn (CMD_RETURN_NORMAL);\n\n\tw = wl_dst->window;\n\twl_dst->window = wl_src->window;\n\twl_src->window = w;\n\n\tif (!args_has(self->args, 'd')) {\n\t\tsession_select(dst, wl_dst->idx);\n\t\tif (src != dst)\n\t\t\tsession_select(src, wl_src->idx);\n\t}\n\tsession_group_synchronize_from(src);\n\tserver_redraw_session_group(src);\n\tif (src != dst) {\n\t\tsession_group_synchronize_from(dst);\n\t\tserver_redraw_session_group(dst);\n\t}\n\trecalculate_sizes();\n\n\treturn (CMD_RETURN_NORMAL);\n#endif\n}\n"
        },
        {
          "name": "cmd-switch-client.c",
          "type": "blob",
          "size": 3.40625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * Switch client to a different session.\n */\n\nenum cmd_retval\t cmd_switch_client_exec(struct cmd *, struct cmd_q *);\n\nconst struct cmd_entry cmd_switch_client_entry = {\n\t.name = \"switch-client\",\n\t.alias = \"switchc\",\n\n\t.args = { \"lc:Enpt:rT:\", 0, 0 },\n\t.usage = \"[-Elnpr] [-c target-client] [-t target-session] \"\n\t\t \"[-T key-table]\",\n\n\t.cflag = CMD_CLIENT,\n\t.tflag = CMD_SESSION_WITHPANE,\n\n\t.flags = CMD_READONLY,\n\t.exec = cmd_switch_client_exec\n};\n\nenum cmd_retval\ncmd_switch_client_exec(struct cmd *self, struct cmd_q *cmdq)\n{\n\tstruct args\t\t*args = self->args;\n\tstruct cmd_state\t*state = &cmdq->state;\n\tstruct client\t\t*c = state->c;\n\tstruct session\t\t*s = cmdq->state.tflag.s;\n\tstruct window_pane\t*wp;\n\tconst char\t\t*tablename, *update;\n\tstruct key_table\t*table;\n\n\tif (args_has(args, 'r'))\n\t\tc->flags ^= CLIENT_READONLY;\n\n\ttablename = args_get(args, 'T');\n\tif (tablename != NULL) {\n\t\ttable = key_bindings_get_table(tablename, 0);\n\t\tif (table == NULL) {\n\t\t\tcmdq_error(cmdq, \"table %s doesn't exist\", tablename);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\ttable->references++;\n\t\tkey_bindings_unref_table(c->keytable);\n\t\tc->keytable = table;\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tif (args_has(args, 'n')) {\n\t\tif ((s = session_next_session(c->session)) == NULL) {\n\t\t\tcmdq_error(cmdq, \"can't find next session\");\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t} else if (args_has(args, 'p')) {\n\t\tif ((s = session_previous_session(c->session)) == NULL) {\n\t\t\tcmdq_error(cmdq, \"can't find previous session\");\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t} else if (args_has(args, 'l')) {\n\t\tif (c->last_session != NULL && session_alive(c->last_session))\n\t\t\ts = c->last_session;\n\t\telse\n\t\t\ts = NULL;\n\t\tif (s == NULL) {\n\t\t\tcmdq_error(cmdq, \"can't find last session\");\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t} else {\n\t\tif (cmdq->client == NULL)\n\t\t\treturn (CMD_RETURN_NORMAL);\n\t\tif (state->tflag.wl != NULL) {\n\t\t\twp = state->tflag.wp;\n\t\t\tif (wp != NULL)\n\t\t\t\twindow_set_active_pane(wp->window, wp);\n\t\t\tsession_set_current(s, state->tflag.wl);\n\t\t}\n\t}\n\n\tif (c != NULL && !args_has(args, 'E')) {\n\t\tupdate = options_get_string(s->options, \"update-environment\");\n\t\tenviron_update(update, c->environ, s->environ);\n\t}\n\n\tif (c->session != NULL && c->session != s)\n\t\tc->last_session = c->session;\n\tc->session = s;\n\tserver_client_set_key_table(c, NULL);\n\tstatus_timer_start(c);\n\tsession_update_activity(s, NULL);\n\tgettimeofday(&s->last_attached_time, NULL);\n\n\trecalculate_sizes();\n\tserver_check_unattached();\n\tserver_redraw_client(c);\n\ts->curw->flags &= ~WINLINK_ALERTFLAGS;\n\talerts_check_session(s);\n\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-unbind-key.c",
          "type": "blob",
          "size": 3.5185546875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n\n#include \"tmux.h\"\n\n/*\n * Unbind key from command.\n */\n\nenum cmd_retval\tcmd_unbind_key_exec(struct cmd *, struct cmd_q *);\nenum cmd_retval\tcmd_unbind_key_mode_table(struct cmd *, struct cmd_q *,\n\t\t    key_code);\n\nconst struct cmd_entry cmd_unbind_key_entry = {\n\t.name = \"unbind-key\",\n\t.alias = \"unbind\",\n\n\t.args = { \"acnt:T:\", 0, 1 },\n\t.usage = \"[-acn] [-t mode-table] [-T key-table] key\",\n\n\t.flags = 0,\n\t.exec = cmd_unbind_key_exec\n};\n\nenum cmd_retval\ncmd_unbind_key_exec(struct cmd *self, struct cmd_q *cmdq)\n{\n\tstruct args\t*args = self->args;\n\tkey_code\t key;\n\tconst char\t*tablename;\n\n\tif (!args_has(args, 'a')) {\n\t\tif (args->argc != 1) {\n\t\t\tcmdq_error(cmdq, \"missing key\");\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\tkey = key_string_lookup_string(args->argv[0]);\n\t\tif (key == KEYC_NONE || key == KEYC_UNKNOWN) {\n\t\t\tcmdq_error(cmdq, \"unknown key: %s\", args->argv[0]);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t} else {\n\t\tif (args->argc != 0) {\n\t\t\tcmdq_error(cmdq, \"key given with -a\");\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\tkey = KEYC_UNKNOWN;\n\t}\n\n\tif (args_has(args, 't'))\n\t\treturn (cmd_unbind_key_mode_table(self, cmdq, key));\n\n\tif (key == KEYC_UNKNOWN) {\n\t\ttablename = args_get(args, 'T');\n\t\tif (tablename == NULL) {\n\t\t\tkey_bindings_remove_table(\"root\");\n\t\t\tkey_bindings_remove_table(\"prefix\");\n\t\t\treturn (CMD_RETURN_NORMAL);\n\t\t}\n\t\tif (key_bindings_get_table(tablename, 0) == NULL) {\n\t\t\tcmdq_error(cmdq, \"table %s doesn't exist\", tablename);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t\tkey_bindings_remove_table(tablename);\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tif (args_has(args, 'T')) {\n\t\ttablename = args_get(args, 'T');\n\t\tif (key_bindings_get_table(tablename, 0) == NULL) {\n\t\t\tcmdq_error(cmdq, \"table %s doesn't exist\", tablename);\n\t\t\treturn (CMD_RETURN_ERROR);\n\t\t}\n\t} else if (args_has(args, 'n'))\n\t\ttablename = \"root\";\n\telse\n\t\ttablename = \"prefix\";\n\tkey_bindings_remove(tablename, key);\n\treturn (CMD_RETURN_NORMAL);\n}\n\nenum cmd_retval\ncmd_unbind_key_mode_table(struct cmd *self, struct cmd_q *cmdq, key_code key)\n{\n\tstruct args\t\t\t*args = self->args;\n\tconst char\t\t\t*tablename;\n\tconst struct mode_key_table\t*mtab;\n\tstruct mode_key_binding\t\t*mbind, mtmp;\n\n\ttablename = args_get(args, 't');\n\tif ((mtab = mode_key_findtable(tablename)) == NULL) {\n\t\tcmdq_error(cmdq, \"unknown key table: %s\", tablename);\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\tif (key == KEYC_UNKNOWN) {\n\t\twhile (!RB_EMPTY(mtab->tree)) {\n\t\t\tmbind = RB_ROOT(mtab->tree);\n\t\t\tRB_REMOVE(mode_key_tree, mtab->tree, mbind);\n\t\t\tfree(mbind);\n\t\t}\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\n\tmtmp.key = key;\n\tmtmp.mode = !!args_has(args, 'c');\n\tif ((mbind = RB_FIND(mode_key_tree, mtab->tree, &mtmp)) != NULL) {\n\t\tRB_REMOVE(mode_key_tree, mtab->tree, mbind);\n\t\tfree(mbind);\n\t}\n\treturn (CMD_RETURN_NORMAL);\n}\n"
        },
        {
          "name": "cmd-wait-for.c",
          "type": "blob",
          "size": 6.689453125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2013 Nicholas Marriott <nicholas.marriott@gmail.com>\n * Copyright (c) 2013 Thiago de Arruda <tpadilha84@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n#include \"tmate.h\"\n\n/*\n * Block or wake a client on a named wait channel.\n */\n\nenum cmd_retval cmd_wait_for_exec(struct cmd *, struct cmd_q *);\n\nconst struct cmd_entry cmd_wait_for_entry = {\n\t.name = \"wait-for\",\n\t.alias = \"wait\",\n\n\t.args = { \"LSU\", 1, 1 },\n\t.usage = \"[-L|-S|-U] channel\",\n\n\t.flags = 0,\n\t.exec = cmd_wait_for_exec\n};\n\nstruct wait_channel {\n\tconst char\t       *name;\n\tint\t\t\tlocked;\n\tint\t\t\twoken;\n\n\tTAILQ_HEAD(, cmd_q)\twaiters;\n\tTAILQ_HEAD(, cmd_q)\tlockers;\n\n\tRB_ENTRY(wait_channel)\tentry;\n};\nRB_HEAD(wait_channels, wait_channel);\nstruct wait_channels wait_channels = RB_INITIALIZER(wait_channels);\n\nint\twait_channel_cmp(struct wait_channel *, struct wait_channel *);\nRB_PROTOTYPE(wait_channels, wait_channel, entry, wait_channel_cmp);\nRB_GENERATE(wait_channels, wait_channel, entry, wait_channel_cmp);\n\nint\nwait_channel_cmp(struct wait_channel *wc1, struct wait_channel *wc2)\n{\n\treturn (strcmp(wc1->name, wc2->name));\n}\n\nenum cmd_retval\tcmd_wait_for_signal(struct cmd_q *, const char *,\n\t\t    struct wait_channel *);\nenum cmd_retval\tcmd_wait_for_wait(struct cmd_q *, const char *,\n\t\t    struct wait_channel *);\nenum cmd_retval\tcmd_wait_for_lock(struct cmd_q *, const char *,\n\t\t    struct wait_channel *);\nenum cmd_retval\tcmd_wait_for_unlock(struct cmd_q *, const char *,\n\t\t    struct wait_channel *);\n\nstruct wait_channel\t*cmd_wait_for_add(const char *);\nvoid\t\t\t cmd_wait_for_remove(struct wait_channel *wc);\n\nstruct wait_channel *\ncmd_wait_for_add(const char *name)\n{\n\tstruct wait_channel *wc;\n\n\twc = xmalloc(sizeof *wc);\n\twc->name = xstrdup(name);\n\n\twc->locked = 0;\n\twc->woken = 0;\n\n\tTAILQ_INIT(&wc->waiters);\n\tTAILQ_INIT(&wc->lockers);\n\n\tRB_INSERT(wait_channels, &wait_channels, wc);\n\n\tlog_debug(\"add wait channel %s\", wc->name);\n\n\treturn (wc);\n}\n\nvoid\ncmd_wait_for_remove(struct wait_channel *wc)\n{\n\tif (wc->locked)\n\t\treturn;\n\tif (!TAILQ_EMPTY(&wc->waiters) || !wc->woken)\n\t\treturn;\n\n\tlog_debug(\"remove wait channel %s\", wc->name);\n\n\tRB_REMOVE(wait_channels, &wait_channels, wc);\n\n\tfree((void *)wc->name);\n\tfree(wc);\n}\n\nenum cmd_retval\ncmd_wait_for_exec(struct cmd *self, struct cmd_q *cmdq)\n{\n\tstruct args     \t*args = self->args;\n\tconst char\t\t*name = args->argv[0];\n\tstruct wait_channel\t*wc, wc0;\n\n\twc0.name = name;\n\twc = RB_FIND(wait_channels, &wait_channels, &wc0);\n\n\tif (args_has(args, 'S'))\n\t\treturn (cmd_wait_for_signal(cmdq, name, wc));\n\tif (args_has(args, 'L'))\n\t\treturn (cmd_wait_for_lock(cmdq, name, wc));\n\tif (args_has(args, 'U'))\n\t\treturn (cmd_wait_for_unlock(cmdq, name, wc));\n\treturn (cmd_wait_for_wait(cmdq, name, wc));\n}\n\nenum cmd_retval\ncmd_wait_for_signal(__unused struct cmd_q *cmdq, const char *name,\n    struct wait_channel *wc)\n{\n\tstruct cmd_q\t*wq, *wq1;\n\n\tif (wc == NULL)\n\t\twc = cmd_wait_for_add(name);\n\n\tif (TAILQ_EMPTY(&wc->waiters) && !wc->woken) {\n\t\tlog_debug(\"signal wait channel %s, no waiters\", wc->name);\n\t\twc->woken = 1;\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\tlog_debug(\"signal wait channel %s, with waiters\", wc->name);\n\n\tTAILQ_FOREACH_SAFE(wq, &wc->waiters, waitentry, wq1) {\n\t\tTAILQ_REMOVE(&wc->waiters, wq, waitentry);\n\t\tif (!cmdq_free(wq))\n\t\t\tcmdq_continue(wq);\n\t}\n\n\tcmd_wait_for_remove(wc);\n\treturn (CMD_RETURN_NORMAL);\n}\n\n#ifdef TMATE\nvoid signal_waiting_clients(const char *name)\n{\n\tstruct wait_channel\t*wc, wc0;\n\tstruct cmd_q\t*wq, *wq1;\n\n\twc0.name = name;\n\twc = RB_FIND(wait_channels, &wait_channels, &wc0);\n\n\tif (wc == NULL || TAILQ_EMPTY(&wc->waiters)) {\n\t\treturn;\n\t}\n\n\tTAILQ_FOREACH_SAFE(wq, &wc->waiters, waitentry, wq1) {\n\t\tTAILQ_REMOVE(&wc->waiters, wq, waitentry);\n\t\tif (!cmdq_free(wq))\n\t\t\tcmdq_continue(wq);\n\t}\n\n\tif (!wc->locked) {\n\t\tRB_REMOVE(wait_channels, &wait_channels, wc);\n\t\tfree((void*) wc->name);\n\t\tfree(wc);\n\t}\n}\n#endif\n\nenum cmd_retval\ncmd_wait_for_wait(struct cmd_q *cmdq, const char *name,\n    struct wait_channel *wc)\n{\n\tstruct client\t*c = cmdq->client;\n\n#ifdef TMATE\n\tif (!strcmp(name, \"tmate-ready\") && tmate_session.tmate_env_ready)\n\t\treturn (CMD_RETURN_NORMAL);\n#endif\n\n\tif (c == NULL || c->session != NULL) {\n\t\tcmdq_error(cmdq, \"not able to wait\");\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\tif (wc == NULL)\n\t\twc = cmd_wait_for_add(name);\n\n\tif (wc->woken) {\n\t\tlog_debug(\"wait channel %s already woken (%p)\", wc->name, c);\n\t\tcmd_wait_for_remove(wc);\n\t\treturn (CMD_RETURN_NORMAL);\n\t}\n\tlog_debug(\"wait channel %s not woken (%p)\", wc->name, c);\n\n\tTAILQ_INSERT_TAIL(&wc->waiters, cmdq, waitentry);\n\tcmdq->references++;\n\n\treturn (CMD_RETURN_WAIT);\n}\n\nenum cmd_retval\ncmd_wait_for_lock(struct cmd_q *cmdq, const char *name,\n    struct wait_channel *wc)\n{\n\tif (cmdq->client == NULL || cmdq->client->session != NULL) {\n\t\tcmdq_error(cmdq, \"not able to lock\");\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\tif (wc == NULL)\n\t\twc = cmd_wait_for_add(name);\n\n\tif (wc->locked) {\n\t\tTAILQ_INSERT_TAIL(&wc->lockers, cmdq, waitentry);\n\t\tcmdq->references++;\n\t\treturn (CMD_RETURN_WAIT);\n\t}\n\twc->locked = 1;\n\n\treturn (CMD_RETURN_NORMAL);\n}\n\nenum cmd_retval\ncmd_wait_for_unlock(struct cmd_q *cmdq, const char *name,\n    struct wait_channel *wc)\n{\n\tstruct cmd_q\t*wq;\n\n\tif (wc == NULL || !wc->locked) {\n\t\tcmdq_error(cmdq, \"channel %s not locked\", name);\n\t\treturn (CMD_RETURN_ERROR);\n\t}\n\n\tif ((wq = TAILQ_FIRST(&wc->lockers)) != NULL) {\n\t\tTAILQ_REMOVE(&wc->lockers, wq, waitentry);\n\t\tif (!cmdq_free(wq))\n\t\t\tcmdq_continue(wq);\n\t} else {\n\t\twc->locked = 0;\n\t\tcmd_wait_for_remove(wc);\n\t}\n\n\treturn (CMD_RETURN_NORMAL);\n}\n\nvoid\ncmd_wait_for_flush(void)\n{\n\tstruct wait_channel\t*wc, *wc1;\n\tstruct cmd_q\t\t*wq, *wq1;\n\n\tRB_FOREACH_SAFE(wc, wait_channels, &wait_channels, wc1) {\n\t\tTAILQ_FOREACH_SAFE(wq, &wc->waiters, waitentry, wq1) {\n\t\t\tTAILQ_REMOVE(&wc->waiters, wq, waitentry);\n\t\t\tif (!cmdq_free(wq))\n\t\t\t\tcmdq_continue(wq);\n\t\t}\n\t\twc->woken = 1;\n\t\tTAILQ_FOREACH_SAFE(wq, &wc->lockers, waitentry, wq1) {\n\t\t\tTAILQ_REMOVE(&wc->lockers, wq, waitentry);\n\t\t\tif (!cmdq_free(wq))\n\t\t\t\tcmdq_continue(wq);\n\t\t}\n\t\twc->locked = 0;\n\t\tcmd_wait_for_remove(wc);\n\t}\n}\n"
        },
        {
          "name": "cmd.c",
          "type": "blob",
          "size": 17.455078125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/time.h>\n\n#include <fnmatch.h>\n#include <pwd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\nextern const struct cmd_entry cmd_attach_session_entry;\nextern const struct cmd_entry cmd_bind_key_entry;\nextern const struct cmd_entry cmd_break_pane_entry;\nextern const struct cmd_entry cmd_capture_pane_entry;\nextern const struct cmd_entry cmd_choose_buffer_entry;\nextern const struct cmd_entry cmd_choose_client_entry;\nextern const struct cmd_entry cmd_choose_session_entry;\nextern const struct cmd_entry cmd_choose_tree_entry;\nextern const struct cmd_entry cmd_choose_window_entry;\nextern const struct cmd_entry cmd_clear_history_entry;\nextern const struct cmd_entry cmd_clock_mode_entry;\nextern const struct cmd_entry cmd_command_prompt_entry;\nextern const struct cmd_entry cmd_confirm_before_entry;\nextern const struct cmd_entry cmd_copy_mode_entry;\nextern const struct cmd_entry cmd_delete_buffer_entry;\nextern const struct cmd_entry cmd_detach_client_entry;\nextern const struct cmd_entry cmd_display_message_entry;\nextern const struct cmd_entry cmd_display_panes_entry;\nextern const struct cmd_entry cmd_down_pane_entry;\nextern const struct cmd_entry cmd_find_window_entry;\nextern const struct cmd_entry cmd_has_session_entry;\nextern const struct cmd_entry cmd_if_shell_entry;\nextern const struct cmd_entry cmd_join_pane_entry;\nextern const struct cmd_entry cmd_kill_pane_entry;\nextern const struct cmd_entry cmd_kill_server_entry;\nextern const struct cmd_entry cmd_kill_session_entry;\nextern const struct cmd_entry cmd_kill_window_entry;\nextern const struct cmd_entry cmd_last_pane_entry;\nextern const struct cmd_entry cmd_last_window_entry;\nextern const struct cmd_entry cmd_link_window_entry;\nextern const struct cmd_entry cmd_list_buffers_entry;\nextern const struct cmd_entry cmd_list_clients_entry;\nextern const struct cmd_entry cmd_list_commands_entry;\nextern const struct cmd_entry cmd_list_keys_entry;\nextern const struct cmd_entry cmd_list_panes_entry;\nextern const struct cmd_entry cmd_list_sessions_entry;\nextern const struct cmd_entry cmd_list_windows_entry;\nextern const struct cmd_entry cmd_load_buffer_entry;\nextern const struct cmd_entry cmd_lock_client_entry;\nextern const struct cmd_entry cmd_lock_server_entry;\nextern const struct cmd_entry cmd_lock_session_entry;\nextern const struct cmd_entry cmd_move_pane_entry;\nextern const struct cmd_entry cmd_move_window_entry;\nextern const struct cmd_entry cmd_new_session_entry;\nextern const struct cmd_entry cmd_new_window_entry;\nextern const struct cmd_entry cmd_next_layout_entry;\nextern const struct cmd_entry cmd_next_window_entry;\nextern const struct cmd_entry cmd_paste_buffer_entry;\nextern const struct cmd_entry cmd_pipe_pane_entry;\nextern const struct cmd_entry cmd_previous_layout_entry;\nextern const struct cmd_entry cmd_previous_window_entry;\nextern const struct cmd_entry cmd_refresh_client_entry;\nextern const struct cmd_entry cmd_rename_session_entry;\nextern const struct cmd_entry cmd_rename_window_entry;\nextern const struct cmd_entry cmd_resize_pane_entry;\nextern const struct cmd_entry cmd_respawn_pane_entry;\nextern const struct cmd_entry cmd_respawn_window_entry;\nextern const struct cmd_entry cmd_rotate_window_entry;\nextern const struct cmd_entry cmd_run_shell_entry;\nextern const struct cmd_entry cmd_save_buffer_entry;\nextern const struct cmd_entry cmd_select_layout_entry;\nextern const struct cmd_entry cmd_select_pane_entry;\nextern const struct cmd_entry cmd_select_window_entry;\nextern const struct cmd_entry cmd_send_keys_entry;\nextern const struct cmd_entry cmd_send_prefix_entry;\nextern const struct cmd_entry cmd_server_info_entry;\nextern const struct cmd_entry cmd_set_buffer_entry;\nextern const struct cmd_entry cmd_set_environment_entry;\nextern const struct cmd_entry cmd_set_hook_entry;\nextern const struct cmd_entry cmd_set_option_entry;\nextern const struct cmd_entry cmd_set_window_option_entry;\nextern const struct cmd_entry cmd_show_buffer_entry;\nextern const struct cmd_entry cmd_show_environment_entry;\nextern const struct cmd_entry cmd_show_hooks_entry;\nextern const struct cmd_entry cmd_show_messages_entry;\nextern const struct cmd_entry cmd_show_options_entry;\nextern const struct cmd_entry cmd_show_window_options_entry;\nextern const struct cmd_entry cmd_source_file_entry;\nextern const struct cmd_entry cmd_split_window_entry;\nextern const struct cmd_entry cmd_start_server_entry;\nextern const struct cmd_entry cmd_suspend_client_entry;\nextern const struct cmd_entry cmd_swap_pane_entry;\nextern const struct cmd_entry cmd_swap_window_entry;\nextern const struct cmd_entry cmd_switch_client_entry;\nextern const struct cmd_entry cmd_unbind_key_entry;\nextern const struct cmd_entry cmd_unlink_window_entry;\nextern const struct cmd_entry cmd_up_pane_entry;\nextern const struct cmd_entry cmd_wait_for_entry;\n\nconst struct cmd_entry *cmd_table[] = {\n\t&cmd_attach_session_entry,\n\t&cmd_bind_key_entry,\n\t&cmd_break_pane_entry,\n\t&cmd_capture_pane_entry,\n\t&cmd_choose_buffer_entry,\n\t&cmd_choose_client_entry,\n\t&cmd_choose_session_entry,\n\t&cmd_choose_tree_entry,\n\t&cmd_choose_window_entry,\n\t&cmd_clear_history_entry,\n\t&cmd_clock_mode_entry,\n\t&cmd_command_prompt_entry,\n\t&cmd_confirm_before_entry,\n\t&cmd_copy_mode_entry,\n\t&cmd_delete_buffer_entry,\n\t&cmd_detach_client_entry,\n\t&cmd_display_message_entry,\n\t&cmd_display_panes_entry,\n\t&cmd_find_window_entry,\n\t&cmd_has_session_entry,\n\t&cmd_if_shell_entry,\n\t&cmd_join_pane_entry,\n\t&cmd_kill_pane_entry,\n\t&cmd_kill_server_entry,\n\t&cmd_kill_session_entry,\n\t&cmd_kill_window_entry,\n\t&cmd_last_pane_entry,\n\t&cmd_last_window_entry,\n\t&cmd_link_window_entry,\n\t&cmd_list_buffers_entry,\n\t&cmd_list_clients_entry,\n\t&cmd_list_commands_entry,\n\t&cmd_list_keys_entry,\n\t&cmd_list_panes_entry,\n\t&cmd_list_sessions_entry,\n\t&cmd_list_windows_entry,\n\t&cmd_load_buffer_entry,\n\t&cmd_lock_client_entry,\n\t&cmd_lock_server_entry,\n\t&cmd_lock_session_entry,\n\t&cmd_move_pane_entry,\n\t&cmd_move_window_entry,\n\t&cmd_new_session_entry,\n\t&cmd_new_window_entry,\n\t&cmd_next_layout_entry,\n\t&cmd_next_window_entry,\n\t&cmd_paste_buffer_entry,\n\t&cmd_pipe_pane_entry,\n\t&cmd_previous_layout_entry,\n\t&cmd_previous_window_entry,\n\t&cmd_refresh_client_entry,\n\t&cmd_rename_session_entry,\n\t&cmd_rename_window_entry,\n\t&cmd_resize_pane_entry,\n\t&cmd_respawn_pane_entry,\n\t&cmd_respawn_window_entry,\n\t&cmd_rotate_window_entry,\n\t&cmd_run_shell_entry,\n\t&cmd_save_buffer_entry,\n\t&cmd_select_layout_entry,\n\t&cmd_select_pane_entry,\n\t&cmd_select_window_entry,\n\t&cmd_send_keys_entry,\n\t&cmd_send_prefix_entry,\n\t&cmd_server_info_entry,\n\t&cmd_set_buffer_entry,\n\t&cmd_set_environment_entry,\n\t&cmd_set_hook_entry,\n\t&cmd_set_option_entry,\n\t&cmd_set_window_option_entry,\n\t&cmd_show_buffer_entry,\n\t&cmd_show_environment_entry,\n\t&cmd_show_hooks_entry,\n\t&cmd_show_messages_entry,\n\t&cmd_show_options_entry,\n\t&cmd_show_window_options_entry,\n\t&cmd_source_file_entry,\n\t&cmd_split_window_entry,\n\t&cmd_start_server_entry,\n\t&cmd_suspend_client_entry,\n\t&cmd_swap_pane_entry,\n\t&cmd_swap_window_entry,\n\t&cmd_switch_client_entry,\n\t&cmd_unbind_key_entry,\n\t&cmd_unlink_window_entry,\n\t&cmd_wait_for_entry,\n\tNULL\n};\n\nint\ncmd_pack_argv(int argc, char **argv, char *buf, size_t len)\n{\n\tsize_t\targlen;\n\tint\ti;\n\n\tif (argc == 0)\n\t\treturn (0);\n\n\t*buf = '\\0';\n\tfor (i = 0; i < argc; i++) {\n\t\tif (strlcpy(buf, argv[i], len) >= len)\n\t\t\treturn (-1);\n\t\targlen = strlen(argv[i]) + 1;\n\t\tbuf += arglen;\n\t\tlen -= arglen;\n\t}\n\n\treturn (0);\n}\n\nint\ncmd_unpack_argv(char *buf, size_t len, int argc, char ***argv)\n{\n\tint\ti;\n\tsize_t\targlen;\n\n\tif (argc == 0)\n\t\treturn (0);\n\t*argv = xcalloc(argc, sizeof **argv);\n\n\tbuf[len - 1] = '\\0';\n\tfor (i = 0; i < argc; i++) {\n\t\tif (len == 0) {\n\t\t\tcmd_free_argv(argc, *argv);\n\t\t\treturn (-1);\n\t\t}\n\n\t\targlen = strlen(buf) + 1;\n\t\t(*argv)[i] = xstrdup(buf);\n\t\tbuf += arglen;\n\t\tlen -= arglen;\n\t}\n\n\treturn (0);\n}\n\nchar **\ncmd_copy_argv(int argc, char **argv)\n{\n\tchar\t**new_argv;\n\tint\t  i;\n\n\tif (argc == 0)\n\t\treturn (NULL);\n\tnew_argv = xcalloc(argc + 1, sizeof *new_argv);\n\tfor (i = 0; i < argc; i++) {\n\t\tif (argv[i] != NULL)\n\t\t\tnew_argv[i] = xstrdup(argv[i]);\n\t}\n\treturn (new_argv);\n}\n\nvoid\ncmd_free_argv(int argc, char **argv)\n{\n\tint\ti;\n\n\tif (argc == 0)\n\t\treturn;\n\tfor (i = 0; i < argc; i++)\n\t\tfree(argv[i]);\n\tfree(argv);\n}\n\nchar *\ncmd_stringify_argv(int argc, char **argv)\n{\n\tchar\t*buf;\n\tint\t i;\n\tsize_t\t len;\n\n\tif (argc == 0)\n\t\treturn (xstrdup(\"\"));\n\n\tlen = 0;\n\tbuf = NULL;\n\n\tfor (i = 0; i < argc; i++) {\n\t\tlen += strlen(argv[i]) + 1;\n\t\tbuf = xrealloc(buf, len);\n\n\t\tif (i == 0)\n\t\t\t*buf = '\\0';\n\t\telse\n\t\t\tstrlcat(buf, \" \", len);\n\t\tstrlcat(buf, argv[i], len);\n\t}\n\treturn (buf);\n}\n\nstruct cmd *\ncmd_parse(int argc, char **argv, const char *file, u_int line, char **cause)\n{\n\tconst struct cmd_entry **entryp, *entry;\n\tstruct cmd\t\t*cmd;\n\tstruct args\t\t*args;\n\tchar\t\t\t s[BUFSIZ];\n\tint\t\t\t ambiguous = 0;\n\n\t*cause = NULL;\n\tif (argc == 0) {\n\t\txasprintf(cause, \"no command\");\n\t\treturn (NULL);\n\t}\n\n\tentry = NULL;\n\tfor (entryp = cmd_table; *entryp != NULL; entryp++) {\n\t\tif ((*entryp)->alias != NULL &&\n\t\t    strcmp((*entryp)->alias, argv[0]) == 0) {\n\t\t\tambiguous = 0;\n\t\t\tentry = *entryp;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (strncmp((*entryp)->name, argv[0], strlen(argv[0])) != 0)\n\t\t\tcontinue;\n\t\tif (entry != NULL)\n\t\t\tambiguous = 1;\n\t\tentry = *entryp;\n\n\t\t/* Bail now if an exact match. */\n\t\tif (strcmp(entry->name, argv[0]) == 0)\n\t\t\tbreak;\n\t}\n\tif (ambiguous)\n\t\tgoto ambiguous;\n\tif (entry == NULL) {\n\t\txasprintf(cause, \"unknown command: %s\", argv[0]);\n\t\treturn (NULL);\n\t}\n\n\targs = args_parse(entry->args.template, argc, argv);\n\tif (args == NULL)\n\t\tgoto usage;\n\tif (entry->args.lower != -1 && args->argc < entry->args.lower)\n\t\tgoto usage;\n\tif (entry->args.upper != -1 && args->argc > entry->args.upper)\n\t\tgoto usage;\n\n\tcmd = xcalloc(1, sizeof *cmd);\n\tcmd->entry = entry;\n\tcmd->args = args;\n\n\tif (file != NULL)\n\t\tcmd->file = xstrdup(file);\n\tcmd->line = line;\n\n\treturn (cmd);\n\nambiguous:\n\t*s = '\\0';\n\tfor (entryp = cmd_table; *entryp != NULL; entryp++) {\n\t\tif (strncmp((*entryp)->name, argv[0], strlen(argv[0])) != 0)\n\t\t\tcontinue;\n\t\tif (strlcat(s, (*entryp)->name, sizeof s) >= sizeof s)\n\t\t\tbreak;\n\t\tif (strlcat(s, \", \", sizeof s) >= sizeof s)\n\t\t\tbreak;\n\t}\n\ts[strlen(s) - 2] = '\\0';\n\txasprintf(cause, \"ambiguous command: %s, could be: %s\", argv[0], s);\n\treturn (NULL);\n\nusage:\n\tif (args != NULL)\n\t\targs_free(args);\n\txasprintf(cause, \"usage: %s %s\", entry->name, entry->usage);\n\treturn (NULL);\n}\n\nstatic int\ncmd_prepare_state_flag(char c, const char *target, enum cmd_entry_flag flag,\n    struct cmd_q *cmdq, struct cmd_q *parent)\n{\n\tint\t\t\t targetflags, error;\n\tstruct cmd_find_state\t*fs = NULL;\n\tstruct cmd_find_state\t*current = NULL;\n\tstruct cmd_find_state\t tmp;\n\n\tif (flag == CMD_NONE ||\n\t    flag == CMD_CLIENT ||\n\t    flag == CMD_CLIENT_CANFAIL)\n\t\treturn (0);\n\n\tif (c == 't')\n\t\tfs = &cmdq->state.tflag;\n\telse if (c == 's')\n\t\tfs = &cmdq->state.sflag;\n\n\tif (flag == CMD_SESSION_WITHPANE) {\n\t\tif (target != NULL && target[strcspn(target, \":.\")] != '\\0')\n\t\t\tflag = CMD_PANE;\n\t\telse\n\t\t\tflag = CMD_SESSION;\n\t}\n\n\ttargetflags = 0;\n\tswitch (flag) {\n\tcase CMD_SESSION:\n\tcase CMD_SESSION_CANFAIL:\n\tcase CMD_SESSION_PREFERUNATTACHED:\n\t\tif (flag == CMD_SESSION_CANFAIL)\n\t\t\ttargetflags |= CMD_FIND_QUIET;\n\t\tif (flag == CMD_SESSION_PREFERUNATTACHED)\n\t\t\ttargetflags |= CMD_FIND_PREFER_UNATTACHED;\n\t\tbreak;\n\tcase CMD_MOVEW_R:\n\t\tflag = CMD_WINDOW_INDEX;\n\t\t/* FALLTHROUGH */\n\tcase CMD_WINDOW:\n\tcase CMD_WINDOW_CANFAIL:\n\tcase CMD_WINDOW_MARKED:\n\tcase CMD_WINDOW_INDEX:\n\t\tif (flag == CMD_WINDOW_CANFAIL)\n\t\t\ttargetflags |= CMD_FIND_QUIET;\n\t\tif (flag == CMD_WINDOW_MARKED)\n\t\t\ttargetflags |= CMD_FIND_DEFAULT_MARKED;\n\t\tif (flag == CMD_WINDOW_INDEX)\n\t\t\ttargetflags |= CMD_FIND_WINDOW_INDEX;\n\t\tbreak;\n\tcase CMD_PANE:\n\tcase CMD_PANE_CANFAIL:\n\tcase CMD_PANE_MARKED:\n\t\tif (flag == CMD_PANE_CANFAIL)\n\t\t\ttargetflags |= CMD_FIND_QUIET;\n\t\tif (flag == CMD_PANE_MARKED)\n\t\t\ttargetflags |= CMD_FIND_DEFAULT_MARKED;\n\t\tbreak;\n\tdefault:\n\t\tfatalx(\"unknown %cflag %d\", c, flag);\n\t}\n\n\tlog_debug(\"%s: flag %c %d %#x\", __func__, c, flag, targetflags);\n\tif (parent != NULL) {\n\t\tif (c == 't')\n\t\t\tcurrent = &parent->state.tflag;\n\t\telse if (c == 's')\n\t\t\tcurrent = &parent->state.sflag;\n\t} else {\n\t\terror = cmd_find_current(&tmp, cmdq, targetflags);\n\t\tif (error != 0 && ~targetflags & CMD_FIND_QUIET)\n\t\t\treturn (-1);\n\t\tcurrent = &tmp;\n\t}\n\n\tswitch (flag) {\n\tcase CMD_NONE:\n\tcase CMD_CLIENT:\n\tcase CMD_CLIENT_CANFAIL:\n\t\treturn (0);\n\tcase CMD_SESSION:\n\tcase CMD_SESSION_CANFAIL:\n\tcase CMD_SESSION_PREFERUNATTACHED:\n\tcase CMD_SESSION_WITHPANE:\n\t\terror = cmd_find_target(fs, current, cmdq, target,\n\t\t    CMD_FIND_SESSION, targetflags);\n\t\tif (error != 0 && ~targetflags & CMD_FIND_QUIET)\n\t\t\treturn (-1);\n\t\tbreak;\n\tcase CMD_MOVEW_R:\n\t\terror = cmd_find_target(fs, current, cmdq, target,\n\t\t    CMD_FIND_SESSION, CMD_FIND_QUIET);\n\t\tif (error == 0)\n\t\t\tbreak;\n\t\t/* FALLTHROUGH */\n\tcase CMD_WINDOW:\n\tcase CMD_WINDOW_CANFAIL:\n\tcase CMD_WINDOW_MARKED:\n\tcase CMD_WINDOW_INDEX:\n\t\terror = cmd_find_target(fs, current, cmdq, target,\n\t\t    CMD_FIND_WINDOW, targetflags);\n\t\tif (error != 0 && ~targetflags & CMD_FIND_QUIET)\n\t\t\treturn (-1);\n\t\tbreak;\n\tcase CMD_PANE:\n\tcase CMD_PANE_CANFAIL:\n\tcase CMD_PANE_MARKED:\n\t\terror = cmd_find_target(fs, current, cmdq, target,\n\t\t    CMD_FIND_PANE, targetflags);\n\t\tif (error != 0 && ~targetflags & CMD_FIND_QUIET)\n\t\t\treturn (-1);\n\t\tbreak;\n\tdefault:\n\t\tfatalx(\"unknown %cflag %d\", c, flag);\n\t}\n\treturn (0);\n}\n\nint\ncmd_prepare_state(struct cmd *cmd, struct cmd_q *cmdq, struct cmd_q *parent)\n{\n\tconst struct cmd_entry\t\t*entry = cmd->entry;\n\tstruct cmd_state\t\t*state = &cmdq->state;\n\tchar\t\t\t\t*tmp;\n\tenum cmd_entry_flag\t\t flag;\n\tconst char\t\t\t*s;\n\tint\t\t\t\t error;\n\n\ttmp = cmd_print(cmd);\n\tlog_debug(\"preparing state for %s (client %p)\", tmp, cmdq->client);\n\tfree(tmp);\n\n\tstate->c = NULL;\n\tcmd_find_clear_state(&state->tflag, NULL, 0);\n\tcmd_find_clear_state(&state->sflag, NULL, 0);\n\n\tflag = cmd->entry->cflag;\n\tif (flag == CMD_NONE) {\n\t\tflag = cmd->entry->tflag;\n\t\tif (flag == CMD_CLIENT || flag == CMD_CLIENT_CANFAIL)\n\t\t\ts = args_get(cmd->args, 't');\n\t\telse\n\t\t\ts = NULL;\n\t} else\n\t\ts = args_get(cmd->args, 'c');\n\tswitch (flag) {\n\tcase CMD_CLIENT:\n\t\tstate->c = cmd_find_client(cmdq, s, 0);\n\t\tif (state->c == NULL)\n\t\t\treturn (-1);\n\t\tbreak;\n\tdefault:\n\t\tstate->c = cmd_find_client(cmdq, s, 1);\n\t\tbreak;\n\t}\n\n\ts = args_get(cmd->args, 't');\n\tlog_debug(\"preparing -t state: target %s\", s == NULL ? \"none\" : s);\n\n\terror = cmd_prepare_state_flag('t', s, entry->tflag, cmdq, parent);\n\tif (error != 0)\n\t\treturn (error);\n\n\ts = args_get(cmd->args, 's');\n\tlog_debug(\"preparing -s state: target %s\", s == NULL ? \"none\" : s);\n\n\terror = cmd_prepare_state_flag('s', s, entry->sflag, cmdq, parent);\n\tif (error != 0)\n\t\treturn (error);\n\n\treturn (0);\n}\n\nchar *\ncmd_print(struct cmd *cmd)\n{\n\tchar\t*out, *s;\n\n\ts = args_print(cmd->args);\n\tif (*s != '\\0')\n\t\txasprintf(&out, \"%s %s\", cmd->entry->name, s);\n\telse\n\t\tout = xstrdup(cmd->entry->name);\n\tfree(s);\n\n\treturn (out);\n}\n\n/* Adjust current mouse position for a pane. */\nint\ncmd_mouse_at(struct window_pane *wp, struct mouse_event *m, u_int *xp,\n    u_int *yp, int last)\n{\n\tu_int\tx, y;\n\n\tif (last) {\n\t\tx = m->lx;\n\t\ty = m->ly;\n\t} else {\n\t\tx = m->x;\n\t\ty = m->y;\n\t}\n\n\tif (m->statusat == 0 && y > 0)\n\t\ty--;\n\telse if (m->statusat > 0 && y >= (u_int)m->statusat)\n\t\ty = m->statusat - 1;\n\n\tif (x < wp->xoff || x >= wp->xoff + wp->sx)\n\t\treturn (-1);\n\tif (y < wp->yoff || y >= wp->yoff + wp->sy)\n\t\treturn (-1);\n\n\t*xp = x - wp->xoff;\n\t*yp = y - wp->yoff;\n\treturn (0);\n}\n\n/* Get current mouse window if any. */\nstruct winlink *\ncmd_mouse_window(struct mouse_event *m, struct session **sp)\n{\n\tstruct session\t*s;\n\tstruct window\t*w;\n\n\tif (!m->valid || m->s == -1 || m->w == -1)\n\t\treturn (NULL);\n\tif ((s = session_find_by_id(m->s)) == NULL)\n\t\treturn (NULL);\n\tif ((w = window_find_by_id(m->w)) == NULL)\n\t\treturn (NULL);\n\n\tif (sp != NULL)\n\t\t*sp = s;\n\treturn (winlink_find_by_window(&s->windows, w));\n}\n\n/* Get current mouse pane if any. */\nstruct window_pane *\ncmd_mouse_pane(struct mouse_event *m, struct session **sp,\n    struct winlink **wlp)\n{\n\tstruct winlink\t\t*wl;\n\tstruct window_pane     \t*wp;\n\n\tif ((wl = cmd_mouse_window(m, sp)) == NULL)\n\t\treturn (NULL);\n\tif ((wp = window_pane_find_by_id(m->wp)) == NULL)\n\t\treturn (NULL);\n\tif (!window_has_pane(wl->window, wp))\n\t\treturn (NULL);\n\n\tif (wlp != NULL)\n\t\t*wlp = wl;\n\treturn (wp);\n}\n\n/* Replace the first %% or %idx in template by s. */\nchar *\ncmd_template_replace(const char *template, const char *s, int idx)\n{\n\tchar\t\t ch, *buf;\n\tconst char\t*ptr;\n\tint\t\t replaced;\n\tsize_t\t\t len;\n\n\tif (strchr(template, '%') == NULL)\n\t\treturn (xstrdup(template));\n\n\tbuf = xmalloc(1);\n\t*buf = '\\0';\n\tlen = 0;\n\treplaced = 0;\n\n\tptr = template;\n\twhile (*ptr != '\\0') {\n\t\tswitch (ch = *ptr++) {\n\t\tcase '%':\n\t\t\tif (*ptr < '1' || *ptr > '9' || *ptr - '0' != idx) {\n\t\t\t\tif (*ptr != '%' || replaced)\n\t\t\t\t\tbreak;\n\t\t\t\treplaced = 1;\n\t\t\t}\n\t\t\tptr++;\n\n\t\t\tlen += strlen(s);\n\t\t\tbuf = xrealloc(buf, len + 1);\n\t\t\tstrlcat(buf, s, len + 1);\n\t\t\tcontinue;\n\t\t}\n\t\tbuf = xrealloc(buf, len + 2);\n\t\tbuf[len++] = ch;\n\t\tbuf[len] = '\\0';\n\t}\n\n\treturn (buf);\n}\n"
        },
        {
          "name": "colour.c",
          "type": "blob",
          "size": 19.2216796875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2008 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <ctype.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * Colour to string conversion functions. Bit 8 of the colour means it is one\n * of the 256 colour palette.\n */\n\nstruct colour_rgb {\n\tu_char  i;\n\tu_char\tr;\n\tu_char\tg;\n\tu_char\tb;\n};\n\nconst struct colour_rgb colour_from_256[] = {\n\t{   0, 0x00, 0x00, 0x00 }, {   1, 0x00, 0x00, 0x5f },\n\t{   2, 0x00, 0x00, 0x87 }, {   3, 0x00, 0x00, 0xaf },\n\t{   4, 0x00, 0x00, 0xd7 }, {   5, 0x00, 0x00, 0xff },\n\t{   6, 0x00, 0x5f, 0x00 }, {   7, 0x00, 0x5f, 0x5f },\n\t{   8, 0x00, 0x5f, 0x87 }, {   9, 0x00, 0x5f, 0xaf },\n\t{  10, 0x00, 0x5f, 0xd7 }, {  11, 0x00, 0x5f, 0xff },\n\t{  12, 0x00, 0x87, 0x00 }, {  13, 0x00, 0x87, 0x5f },\n\t{  14, 0x00, 0x87, 0x87 }, {  15, 0x00, 0x87, 0xaf },\n\t{  16, 0x00, 0x87, 0xd7 }, {  17, 0x00, 0x87, 0xff },\n\t{  18, 0x00, 0xaf, 0x00 }, {  19, 0x00, 0xaf, 0x5f },\n\t{  20, 0x00, 0xaf, 0x87 }, {  21, 0x00, 0xaf, 0xaf },\n\t{  22, 0x00, 0xaf, 0xd7 }, {  23, 0x00, 0xaf, 0xff },\n\t{  24, 0x00, 0xd7, 0x00 }, {  25, 0x00, 0xd7, 0x5f },\n\t{  26, 0x00, 0xd7, 0x87 }, {  27, 0x00, 0xd7, 0xaf },\n\t{  28, 0x00, 0xd7, 0xd7 }, {  29, 0x00, 0xd7, 0xff },\n\t{  30, 0x00, 0xff, 0x00 }, {  31, 0x00, 0xff, 0x5f },\n\t{  32, 0x00, 0xff, 0x87 }, {  33, 0x00, 0xff, 0xaf },\n\t{  34, 0x00, 0xff, 0xd7 }, {  35, 0x00, 0xff, 0xff },\n\t{  36, 0x5f, 0x00, 0x00 }, {  37, 0x5f, 0x00, 0x5f },\n\t{  38, 0x5f, 0x00, 0x87 }, {  39, 0x5f, 0x00, 0xaf },\n\t{  40, 0x5f, 0x00, 0xd7 }, {  41, 0x5f, 0x00, 0xff },\n\t{  42, 0x5f, 0x5f, 0x00 }, {  43, 0x5f, 0x5f, 0x5f },\n\t{  44, 0x5f, 0x5f, 0x87 }, {  45, 0x5f, 0x5f, 0xaf },\n\t{  46, 0x5f, 0x5f, 0xd7 }, {  47, 0x5f, 0x5f, 0xff },\n\t{  48, 0x5f, 0x87, 0x00 }, {  49, 0x5f, 0x87, 0x5f },\n\t{  50, 0x5f, 0x87, 0x87 }, {  51, 0x5f, 0x87, 0xaf },\n\t{  52, 0x5f, 0x87, 0xd7 }, {  53, 0x5f, 0x87, 0xff },\n\t{  54, 0x5f, 0xaf, 0x00 }, {  55, 0x5f, 0xaf, 0x5f },\n\t{  56, 0x5f, 0xaf, 0x87 }, {  57, 0x5f, 0xaf, 0xaf },\n\t{  58, 0x5f, 0xaf, 0xd7 }, {  59, 0x5f, 0xaf, 0xff },\n\t{  60, 0x5f, 0xd7, 0x00 }, {  61, 0x5f, 0xd7, 0x5f },\n\t{  62, 0x5f, 0xd7, 0x87 }, {  63, 0x5f, 0xd7, 0xaf },\n\t{  64, 0x5f, 0xd7, 0xd7 }, {  65, 0x5f, 0xd7, 0xff },\n\t{  66, 0x5f, 0xff, 0x00 }, {  67, 0x5f, 0xff, 0x5f },\n\t{  68, 0x5f, 0xff, 0x87 }, {  69, 0x5f, 0xff, 0xaf },\n\t{  70, 0x5f, 0xff, 0xd7 }, {  71, 0x5f, 0xff, 0xff },\n\t{  72, 0x87, 0x00, 0x00 }, {  73, 0x87, 0x00, 0x5f },\n\t{  74, 0x87, 0x00, 0x87 }, {  75, 0x87, 0x00, 0xaf },\n\t{  76, 0x87, 0x00, 0xd7 }, {  77, 0x87, 0x00, 0xff },\n\t{  78, 0x87, 0x5f, 0x00 }, {  79, 0x87, 0x5f, 0x5f },\n\t{  80, 0x87, 0x5f, 0x87 }, {  81, 0x87, 0x5f, 0xaf },\n\t{  82, 0x87, 0x5f, 0xd7 }, {  83, 0x87, 0x5f, 0xff },\n\t{  84, 0x87, 0x87, 0x00 }, {  85, 0x87, 0x87, 0x5f },\n\t{  86, 0x87, 0x87, 0x87 }, {  87, 0x87, 0x87, 0xaf },\n\t{  88, 0x87, 0x87, 0xd7 }, {  89, 0x87, 0x87, 0xff },\n\t{  90, 0x87, 0xaf, 0x00 }, {  91, 0x87, 0xaf, 0x5f },\n\t{  92, 0x87, 0xaf, 0x87 }, {  93, 0x87, 0xaf, 0xaf },\n\t{  94, 0x87, 0xaf, 0xd7 }, {  95, 0x87, 0xaf, 0xff },\n\t{  96, 0x87, 0xd7, 0x00 }, {  97, 0x87, 0xd7, 0x5f },\n\t{  98, 0x87, 0xd7, 0x87 }, {  99, 0x87, 0xd7, 0xaf },\n\t{ 100, 0x87, 0xd7, 0xd7 }, { 101, 0x87, 0xd7, 0xff },\n\t{ 102, 0x87, 0xff, 0x00 }, { 103, 0x87, 0xff, 0x5f },\n\t{ 104, 0x87, 0xff, 0x87 }, { 105, 0x87, 0xff, 0xaf },\n\t{ 106, 0x87, 0xff, 0xd7 }, { 107, 0x87, 0xff, 0xff },\n\t{ 108, 0xaf, 0x00, 0x00 }, { 109, 0xaf, 0x00, 0x5f },\n\t{ 110, 0xaf, 0x00, 0x87 }, { 111, 0xaf, 0x00, 0xaf },\n\t{ 112, 0xaf, 0x00, 0xd7 }, { 113, 0xaf, 0x00, 0xff },\n\t{ 114, 0xaf, 0x5f, 0x00 }, { 115, 0xaf, 0x5f, 0x5f },\n\t{ 116, 0xaf, 0x5f, 0x87 }, { 117, 0xaf, 0x5f, 0xaf },\n\t{ 118, 0xaf, 0x5f, 0xd7 }, { 119, 0xaf, 0x5f, 0xff },\n\t{ 120, 0xaf, 0x87, 0x00 }, { 121, 0xaf, 0x87, 0x5f },\n\t{ 122, 0xaf, 0x87, 0x87 }, { 123, 0xaf, 0x87, 0xaf },\n\t{ 124, 0xaf, 0x87, 0xd7 }, { 125, 0xaf, 0x87, 0xff },\n\t{ 126, 0xaf, 0xaf, 0x00 }, { 127, 0xaf, 0xaf, 0x5f },\n\t{ 128, 0xaf, 0xaf, 0x87 }, { 129, 0xaf, 0xaf, 0xaf },\n\t{ 130, 0xaf, 0xaf, 0xd7 }, { 131, 0xaf, 0xaf, 0xff },\n\t{ 132, 0xaf, 0xd7, 0x00 }, { 133, 0xaf, 0xd7, 0x5f },\n\t{ 134, 0xaf, 0xd7, 0x87 }, { 135, 0xaf, 0xd7, 0xaf },\n\t{ 136, 0xaf, 0xd7, 0xd7 }, { 137, 0xaf, 0xd7, 0xff },\n\t{ 138, 0xaf, 0xff, 0x00 }, { 139, 0xaf, 0xff, 0x5f },\n\t{ 140, 0xaf, 0xff, 0x87 }, { 141, 0xaf, 0xff, 0xaf },\n\t{ 142, 0xaf, 0xff, 0xd7 }, { 143, 0xaf, 0xff, 0xff },\n\t{ 144, 0xd7, 0x00, 0x00 }, { 145, 0xd7, 0x00, 0x5f },\n\t{ 146, 0xd7, 0x00, 0x87 }, { 147, 0xd7, 0x00, 0xaf },\n\t{ 148, 0xd7, 0x00, 0xd7 }, { 149, 0xd7, 0x00, 0xff },\n\t{ 150, 0xd7, 0x5f, 0x00 }, { 151, 0xd7, 0x5f, 0x5f },\n\t{ 152, 0xd7, 0x5f, 0x87 }, { 153, 0xd7, 0x5f, 0xaf },\n\t{ 154, 0xd7, 0x5f, 0xd7 }, { 155, 0xd7, 0x5f, 0xff },\n\t{ 156, 0xd7, 0x87, 0x00 }, { 157, 0xd7, 0x87, 0x5f },\n\t{ 158, 0xd7, 0x87, 0x87 }, { 159, 0xd7, 0x87, 0xaf },\n\t{ 160, 0xd7, 0x87, 0xd7 }, { 161, 0xd7, 0x87, 0xff },\n\t{ 162, 0xd7, 0xaf, 0x00 }, { 163, 0xd7, 0xaf, 0x5f },\n\t{ 164, 0xd7, 0xaf, 0x87 }, { 165, 0xd7, 0xaf, 0xaf },\n\t{ 166, 0xd7, 0xaf, 0xd7 }, { 167, 0xd7, 0xaf, 0xff },\n\t{ 168, 0xd7, 0xd7, 0x00 }, { 169, 0xd7, 0xd7, 0x5f },\n\t{ 170, 0xd7, 0xd7, 0x87 }, { 171, 0xd7, 0xd7, 0xaf },\n\t{ 172, 0xd7, 0xd7, 0xd7 }, { 173, 0xd7, 0xd7, 0xff },\n\t{ 174, 0xd7, 0xff, 0x00 }, { 175, 0xd7, 0xff, 0x5f },\n\t{ 176, 0xd7, 0xff, 0x87 }, { 177, 0xd7, 0xff, 0xaf },\n\t{ 178, 0xd7, 0xff, 0xd7 }, { 179, 0xd7, 0xff, 0xff },\n\t{ 180, 0xff, 0x00, 0x00 }, { 181, 0xff, 0x00, 0x5f },\n\t{ 182, 0xff, 0x00, 0x87 }, { 183, 0xff, 0x00, 0xaf },\n\t{ 184, 0xff, 0x00, 0xd7 }, { 185, 0xff, 0x00, 0xff },\n\t{ 186, 0xff, 0x5f, 0x00 }, { 187, 0xff, 0x5f, 0x5f },\n\t{ 188, 0xff, 0x5f, 0x87 }, { 189, 0xff, 0x5f, 0xaf },\n\t{ 190, 0xff, 0x5f, 0xd7 }, { 191, 0xff, 0x5f, 0xff },\n\t{ 192, 0xff, 0x87, 0x00 }, { 193, 0xff, 0x87, 0x5f },\n\t{ 194, 0xff, 0x87, 0x87 }, { 195, 0xff, 0x87, 0xaf },\n\t{ 196, 0xff, 0x87, 0xd7 }, { 197, 0xff, 0x87, 0xff },\n\t{ 198, 0xff, 0xaf, 0x00 }, { 199, 0xff, 0xaf, 0x5f },\n\t{ 200, 0xff, 0xaf, 0x87 }, { 201, 0xff, 0xaf, 0xaf },\n\t{ 202, 0xff, 0xaf, 0xd7 }, { 203, 0xff, 0xaf, 0xff },\n\t{ 204, 0xff, 0xd7, 0x00 }, { 205, 0xff, 0xd7, 0x5f },\n\t{ 206, 0xff, 0xd7, 0x87 }, { 207, 0xff, 0xd7, 0xaf },\n\t{ 208, 0xff, 0xd7, 0xd7 }, { 209, 0xff, 0xd7, 0xff },\n\t{ 210, 0xff, 0xff, 0x00 }, { 211, 0xff, 0xff, 0x5f },\n\t{ 212, 0xff, 0xff, 0x87 }, { 213, 0xff, 0xff, 0xaf },\n\t{ 214, 0xff, 0xff, 0xd7 }, { 215, 0xff, 0xff, 0xff },\n\t{ 216, 0x08, 0x08, 0x08 }, { 217, 0x12, 0x12, 0x12 },\n\t{ 218, 0x1c, 0x1c, 0x1c }, { 219, 0x26, 0x26, 0x26 },\n\t{ 220, 0x30, 0x30, 0x30 }, { 221, 0x3a, 0x3a, 0x3a },\n\t{ 222, 0x44, 0x44, 0x44 }, { 223, 0x4e, 0x4e, 0x4e },\n\t{ 224, 0x58, 0x58, 0x58 }, { 225, 0x62, 0x62, 0x62 },\n\t{ 226, 0x6c, 0x6c, 0x6c }, { 227, 0x76, 0x76, 0x76 },\n\t{ 228, 0x80, 0x80, 0x80 }, { 229, 0x8a, 0x8a, 0x8a },\n\t{ 230, 0x94, 0x94, 0x94 }, { 231, 0x9e, 0x9e, 0x9e },\n\t{ 232, 0xa8, 0xa8, 0xa8 }, { 233, 0xb2, 0xb2, 0xb2 },\n\t{ 234, 0xbc, 0xbc, 0xbc }, { 235, 0xc6, 0xc6, 0xc6 },\n\t{ 236, 0xd0, 0xd0, 0xd0 }, { 237, 0xda, 0xda, 0xda },\n\t{ 238, 0xe4, 0xe4, 0xe4 }, { 239, 0xee, 0xee, 0xee },\n};\nconst struct colour_rgb colour_to_256[] = {\n\t{   0, 0x00, 0x00, 0x00 }, {   1, 0x00, 0x00, 0x5f },\n\t{   2, 0x00, 0x00, 0x87 }, {   3, 0x00, 0x00, 0xaf },\n\t{   4, 0x00, 0x00, 0xd7 }, {   5, 0x00, 0x00, 0xff },\n\t{   6, 0x00, 0x5f, 0x00 }, {   7, 0x00, 0x5f, 0x5f },\n\t{   8, 0x00, 0x5f, 0x87 }, {   9, 0x00, 0x5f, 0xaf },\n\t{  10, 0x00, 0x5f, 0xd7 }, {  11, 0x00, 0x5f, 0xff },\n\t{  12, 0x00, 0x87, 0x00 }, {  13, 0x00, 0x87, 0x5f },\n\t{  14, 0x00, 0x87, 0x87 }, {  15, 0x00, 0x87, 0xaf },\n\t{  16, 0x00, 0x87, 0xd7 }, {  17, 0x00, 0x87, 0xff },\n\t{  18, 0x00, 0xaf, 0x00 }, {  19, 0x00, 0xaf, 0x5f },\n\t{  20, 0x00, 0xaf, 0x87 }, {  21, 0x00, 0xaf, 0xaf },\n\t{  22, 0x00, 0xaf, 0xd7 }, {  23, 0x00, 0xaf, 0xff },\n\t{  24, 0x00, 0xd7, 0x00 }, {  25, 0x00, 0xd7, 0x5f },\n\t{  26, 0x00, 0xd7, 0x87 }, {  27, 0x00, 0xd7, 0xaf },\n\t{  28, 0x00, 0xd7, 0xd7 }, {  29, 0x00, 0xd7, 0xff },\n\t{  30, 0x00, 0xff, 0x00 }, {  31, 0x00, 0xff, 0x5f },\n\t{  32, 0x00, 0xff, 0x87 }, {  33, 0x00, 0xff, 0xaf },\n\t{  34, 0x00, 0xff, 0xd7 }, {  35, 0x00, 0xff, 0xff },\n\t{ 216, 0x08, 0x08, 0x08 }, { 217, 0x12, 0x12, 0x12 },\n\t{ 218, 0x1c, 0x1c, 0x1c }, { 219, 0x26, 0x26, 0x26 },\n\t{ 220, 0x30, 0x30, 0x30 }, { 221, 0x3a, 0x3a, 0x3a },\n\t{ 222, 0x44, 0x44, 0x44 }, { 223, 0x4e, 0x4e, 0x4e },\n\t{ 224, 0x58, 0x58, 0x58 }, {  36, 0x5f, 0x00, 0x00 },\n\t{  37, 0x5f, 0x00, 0x5f }, {  38, 0x5f, 0x00, 0x87 },\n\t{  39, 0x5f, 0x00, 0xaf }, {  40, 0x5f, 0x00, 0xd7 },\n\t{  41, 0x5f, 0x00, 0xff }, {  42, 0x5f, 0x5f, 0x00 },\n\t{  43, 0x5f, 0x5f, 0x5f }, {  44, 0x5f, 0x5f, 0x87 },\n\t{  45, 0x5f, 0x5f, 0xaf }, {  46, 0x5f, 0x5f, 0xd7 },\n\t{  47, 0x5f, 0x5f, 0xff }, {  48, 0x5f, 0x87, 0x00 },\n\t{  49, 0x5f, 0x87, 0x5f }, {  50, 0x5f, 0x87, 0x87 },\n\t{  51, 0x5f, 0x87, 0xaf }, {  52, 0x5f, 0x87, 0xd7 },\n\t{  53, 0x5f, 0x87, 0xff }, {  54, 0x5f, 0xaf, 0x00 },\n\t{  55, 0x5f, 0xaf, 0x5f }, {  56, 0x5f, 0xaf, 0x87 },\n\t{  57, 0x5f, 0xaf, 0xaf }, {  58, 0x5f, 0xaf, 0xd7 },\n\t{  59, 0x5f, 0xaf, 0xff }, {  60, 0x5f, 0xd7, 0x00 },\n\t{  61, 0x5f, 0xd7, 0x5f }, {  62, 0x5f, 0xd7, 0x87 },\n\t{  63, 0x5f, 0xd7, 0xaf }, {  64, 0x5f, 0xd7, 0xd7 },\n\t{  65, 0x5f, 0xd7, 0xff }, {  66, 0x5f, 0xff, 0x00 },\n\t{  67, 0x5f, 0xff, 0x5f }, {  68, 0x5f, 0xff, 0x87 },\n\t{  69, 0x5f, 0xff, 0xaf }, {  70, 0x5f, 0xff, 0xd7 },\n\t{  71, 0x5f, 0xff, 0xff }, { 225, 0x62, 0x62, 0x62 },\n\t{ 226, 0x6c, 0x6c, 0x6c }, { 227, 0x76, 0x76, 0x76 },\n\t{ 228, 0x80, 0x80, 0x80 }, {  72, 0x87, 0x00, 0x00 },\n\t{  73, 0x87, 0x00, 0x5f }, {  74, 0x87, 0x00, 0x87 },\n\t{  75, 0x87, 0x00, 0xaf }, {  76, 0x87, 0x00, 0xd7 },\n\t{  77, 0x87, 0x00, 0xff }, {  78, 0x87, 0x5f, 0x00 },\n\t{  79, 0x87, 0x5f, 0x5f }, {  80, 0x87, 0x5f, 0x87 },\n\t{  81, 0x87, 0x5f, 0xaf }, {  82, 0x87, 0x5f, 0xd7 },\n\t{  83, 0x87, 0x5f, 0xff }, {  84, 0x87, 0x87, 0x00 },\n\t{  85, 0x87, 0x87, 0x5f }, {  86, 0x87, 0x87, 0x87 },\n\t{  87, 0x87, 0x87, 0xaf }, {  88, 0x87, 0x87, 0xd7 },\n\t{  89, 0x87, 0x87, 0xff }, {  90, 0x87, 0xaf, 0x00 },\n\t{  91, 0x87, 0xaf, 0x5f }, {  92, 0x87, 0xaf, 0x87 },\n\t{  93, 0x87, 0xaf, 0xaf }, {  94, 0x87, 0xaf, 0xd7 },\n\t{  95, 0x87, 0xaf, 0xff }, {  96, 0x87, 0xd7, 0x00 },\n\t{  97, 0x87, 0xd7, 0x5f }, {  98, 0x87, 0xd7, 0x87 },\n\t{  99, 0x87, 0xd7, 0xaf }, { 100, 0x87, 0xd7, 0xd7 },\n\t{ 101, 0x87, 0xd7, 0xff }, { 102, 0x87, 0xff, 0x00 },\n\t{ 103, 0x87, 0xff, 0x5f }, { 104, 0x87, 0xff, 0x87 },\n\t{ 105, 0x87, 0xff, 0xaf }, { 106, 0x87, 0xff, 0xd7 },\n\t{ 107, 0x87, 0xff, 0xff }, { 229, 0x8a, 0x8a, 0x8a },\n\t{ 230, 0x94, 0x94, 0x94 }, { 231, 0x9e, 0x9e, 0x9e },\n\t{ 232, 0xa8, 0xa8, 0xa8 }, { 108, 0xaf, 0x00, 0x00 },\n\t{ 109, 0xaf, 0x00, 0x5f }, { 110, 0xaf, 0x00, 0x87 },\n\t{ 111, 0xaf, 0x00, 0xaf }, { 112, 0xaf, 0x00, 0xd7 },\n\t{ 113, 0xaf, 0x00, 0xff }, { 114, 0xaf, 0x5f, 0x00 },\n\t{ 115, 0xaf, 0x5f, 0x5f }, { 116, 0xaf, 0x5f, 0x87 },\n\t{ 117, 0xaf, 0x5f, 0xaf }, { 118, 0xaf, 0x5f, 0xd7 },\n\t{ 119, 0xaf, 0x5f, 0xff }, { 120, 0xaf, 0x87, 0x00 },\n\t{ 121, 0xaf, 0x87, 0x5f }, { 122, 0xaf, 0x87, 0x87 },\n\t{ 123, 0xaf, 0x87, 0xaf }, { 124, 0xaf, 0x87, 0xd7 },\n\t{ 125, 0xaf, 0x87, 0xff }, { 126, 0xaf, 0xaf, 0x00 },\n\t{ 127, 0xaf, 0xaf, 0x5f }, { 128, 0xaf, 0xaf, 0x87 },\n\t{ 129, 0xaf, 0xaf, 0xaf }, { 130, 0xaf, 0xaf, 0xd7 },\n\t{ 131, 0xaf, 0xaf, 0xff }, { 132, 0xaf, 0xd7, 0x00 },\n\t{ 133, 0xaf, 0xd7, 0x5f }, { 134, 0xaf, 0xd7, 0x87 },\n\t{ 135, 0xaf, 0xd7, 0xaf }, { 136, 0xaf, 0xd7, 0xd7 },\n\t{ 137, 0xaf, 0xd7, 0xff }, { 138, 0xaf, 0xff, 0x00 },\n\t{ 139, 0xaf, 0xff, 0x5f }, { 140, 0xaf, 0xff, 0x87 },\n\t{ 141, 0xaf, 0xff, 0xaf }, { 142, 0xaf, 0xff, 0xd7 },\n\t{ 143, 0xaf, 0xff, 0xff }, { 233, 0xb2, 0xb2, 0xb2 },\n\t{ 234, 0xbc, 0xbc, 0xbc }, { 235, 0xc6, 0xc6, 0xc6 },\n\t{ 236, 0xd0, 0xd0, 0xd0 }, { 144, 0xd7, 0x00, 0x00 },\n\t{ 145, 0xd7, 0x00, 0x5f }, { 146, 0xd7, 0x00, 0x87 },\n\t{ 147, 0xd7, 0x00, 0xaf }, { 148, 0xd7, 0x00, 0xd7 },\n\t{ 149, 0xd7, 0x00, 0xff }, { 150, 0xd7, 0x5f, 0x00 },\n\t{ 151, 0xd7, 0x5f, 0x5f }, { 152, 0xd7, 0x5f, 0x87 },\n\t{ 153, 0xd7, 0x5f, 0xaf }, { 154, 0xd7, 0x5f, 0xd7 },\n\t{ 155, 0xd7, 0x5f, 0xff }, { 156, 0xd7, 0x87, 0x00 },\n\t{ 157, 0xd7, 0x87, 0x5f }, { 158, 0xd7, 0x87, 0x87 },\n\t{ 159, 0xd7, 0x87, 0xaf }, { 160, 0xd7, 0x87, 0xd7 },\n\t{ 161, 0xd7, 0x87, 0xff }, { 162, 0xd7, 0xaf, 0x00 },\n\t{ 163, 0xd7, 0xaf, 0x5f }, { 164, 0xd7, 0xaf, 0x87 },\n\t{ 165, 0xd7, 0xaf, 0xaf }, { 166, 0xd7, 0xaf, 0xd7 },\n\t{ 167, 0xd7, 0xaf, 0xff }, { 168, 0xd7, 0xd7, 0x00 },\n\t{ 169, 0xd7, 0xd7, 0x5f }, { 170, 0xd7, 0xd7, 0x87 },\n\t{ 171, 0xd7, 0xd7, 0xaf }, { 172, 0xd7, 0xd7, 0xd7 },\n\t{ 173, 0xd7, 0xd7, 0xff }, { 174, 0xd7, 0xff, 0x00 },\n\t{ 175, 0xd7, 0xff, 0x5f }, { 176, 0xd7, 0xff, 0x87 },\n\t{ 177, 0xd7, 0xff, 0xaf }, { 178, 0xd7, 0xff, 0xd7 },\n\t{ 179, 0xd7, 0xff, 0xff }, { 237, 0xda, 0xda, 0xda },\n\t{ 238, 0xe4, 0xe4, 0xe4 }, { 239, 0xee, 0xee, 0xee },\n\t{ 180, 0xff, 0x00, 0x00 }, { 181, 0xff, 0x00, 0x5f },\n\t{ 182, 0xff, 0x00, 0x87 }, { 183, 0xff, 0x00, 0xaf },\n\t{ 184, 0xff, 0x00, 0xd7 }, { 185, 0xff, 0x00, 0xff },\n\t{ 186, 0xff, 0x5f, 0x00 }, { 187, 0xff, 0x5f, 0x5f },\n\t{ 188, 0xff, 0x5f, 0x87 }, { 189, 0xff, 0x5f, 0xaf },\n\t{ 190, 0xff, 0x5f, 0xd7 }, { 191, 0xff, 0x5f, 0xff },\n\t{ 192, 0xff, 0x87, 0x00 }, { 193, 0xff, 0x87, 0x5f },\n\t{ 194, 0xff, 0x87, 0x87 }, { 195, 0xff, 0x87, 0xaf },\n\t{ 196, 0xff, 0x87, 0xd7 }, { 197, 0xff, 0x87, 0xff },\n\t{ 198, 0xff, 0xaf, 0x00 }, { 199, 0xff, 0xaf, 0x5f },\n\t{ 200, 0xff, 0xaf, 0x87 }, { 201, 0xff, 0xaf, 0xaf },\n\t{ 202, 0xff, 0xaf, 0xd7 }, { 203, 0xff, 0xaf, 0xff },\n\t{ 204, 0xff, 0xd7, 0x00 }, { 205, 0xff, 0xd7, 0x5f },\n\t{ 206, 0xff, 0xd7, 0x87 }, { 207, 0xff, 0xd7, 0xaf },\n\t{ 208, 0xff, 0xd7, 0xd7 }, { 209, 0xff, 0xd7, 0xff },\n\t{ 210, 0xff, 0xff, 0x00 }, { 211, 0xff, 0xff, 0x5f },\n\t{ 212, 0xff, 0xff, 0x87 }, { 213, 0xff, 0xff, 0xaf },\n\t{ 214, 0xff, 0xff, 0xd7 }, { 215, 0xff, 0xff, 0xff },\n};\n\nint\tcolour_cmp_rgb(const void *, const void *);\n\n/* Compare function for bsearch(). */\nint\ncolour_cmp_rgb(const void *lhs0, const void *rhs0)\n{\n\tconst struct colour_rgb *lhs = lhs0, *rhs = rhs0;\n\n\tif (lhs->r < rhs->r)\n\t\treturn (-1);\n\tif (lhs->r > rhs->r)\n\t\treturn (1);\n\n\tif (lhs->g < rhs->g)\n\t\treturn (-1);\n\tif (lhs->g > rhs->g)\n\t\treturn (1);\n\n\tif (lhs->b < rhs->b)\n\t\treturn (-1);\n\tif (lhs->b > rhs->b)\n\t\treturn (1);\n\n\treturn (0);\n}\n\n/* Work out the nearest colour from the 256 colour set. */\nint\ncolour_find_rgb(u_char r, u_char g, u_char b)\n{\n\tstruct colour_rgb\trgb = { .r = r, .g = g, .b = b }, *found;\n\tu_int\t\t\tdistance, lowest, colour, i;\n\tint\t\t\tdr, dg, db;\n\n\tfound = bsearch(&rgb, colour_to_256, nitems(colour_to_256),\n\t    sizeof colour_to_256[0], colour_cmp_rgb);\n\tif (found != NULL)\n\t\treturn (16 + found->i);\n\n\tcolour = 16;\n\tlowest = UINT_MAX;\n\tfor (i = 0; i < 240; i++) {\n\t\tdr = (int)colour_from_256[i].r - r;\n\t\tdg = (int)colour_from_256[i].g - g;\n\t\tdb = (int)colour_from_256[i].b - b;\n\n\t\tdistance = dr * dr + dg * dg + db * db;\n\t\tif (distance < lowest) {\n\t\t\tlowest = distance;\n\t\t\tcolour = 16 + i;\n\t\t}\n\t}\n\treturn (colour);\n}\n\n/* Set grid cell foreground colour. */\nvoid\ncolour_set_fg(struct grid_cell *gc, int c)\n{\n\tif (c & 0x100)\n\t\tgc->flags |= GRID_FLAG_FG256;\n\tgc->fg = c;\n}\n\n/* Set grid cell background colour. */\nvoid\ncolour_set_bg(struct grid_cell *gc, int c)\n{\n\tif (c & 0x100)\n\t\tgc->flags |= GRID_FLAG_BG256;\n\tgc->bg = c;\n}\n\n/* Convert colour to a string. */\nconst char *\ncolour_tostring(int c)\n{\n\tstatic char\ts[32];\n\n\tif (c & 0x100) {\n\t\txsnprintf(s, sizeof s, \"colour%d\", c & ~0x100);\n\t\treturn (s);\n\t}\n\n\tswitch (c) {\n\tcase 0:\n\t\treturn (\"black\");\n\tcase 1:\n\t\treturn (\"red\");\n\tcase 2:\n\t\treturn (\"green\");\n\tcase 3:\n\t\treturn (\"yellow\");\n\tcase 4:\n\t\treturn (\"blue\");\n\tcase 5:\n\t\treturn (\"magenta\");\n\tcase 6:\n\t\treturn (\"cyan\");\n\tcase 7:\n\t\treturn (\"white\");\n\tcase 8:\n\t\treturn (\"default\");\n\tcase 90:\n\t\treturn (\"brightblack\");\n\tcase 91:\n\t\treturn (\"brightred\");\n\tcase 92:\n\t\treturn (\"brightgreen\");\n\tcase 93:\n\t\treturn (\"brightyellow\");\n\tcase 94:\n\t\treturn (\"brightblue\");\n\tcase 95:\n\t\treturn (\"brightmagenta\");\n\tcase 96:\n\t\treturn (\"brightcyan\");\n\tcase 97:\n\t\treturn (\"brightwhite\");\n\t}\n\treturn (NULL);\n}\n\n/* Convert colour from string. */\nint\ncolour_fromstring(const char *s)\n{\n\tconst char\t*errstr;\n\tconst char\t*cp;\n\tint\t\t n;\n\tu_char\t\t r, g, b;\n\n\tif (*s == '#' && strlen(s) == 7) {\n\t\tfor (cp = s + 1; isxdigit((u_char) *cp); cp++)\n\t\t\t;\n\t\tif (*cp != '\\0')\n\t\t\treturn (-1);\n\t\tn = sscanf(s + 1, \"%2hhx%2hhx%2hhx\", &r, &g, &b);\n\t\tif (n != 3)\n\t\t\treturn (-1);\n\t\treturn (colour_find_rgb(r, g, b) | 0x100);\n\t}\n\n\tif (strncasecmp(s, \"colour\", (sizeof \"colour\") - 1) == 0) {\n\t\tn = strtonum(s + (sizeof \"colour\") - 1, 0, 255, &errstr);\n\t\tif (errstr != NULL)\n\t\t\treturn (-1);\n\t\treturn (n | 0x100);\n\t}\n\n\tif (strcasecmp(s, \"black\") == 0 || strcmp(s, \"0\") == 0)\n\t\treturn (0);\n\tif (strcasecmp(s, \"red\") == 0 || strcmp(s, \"1\") == 0)\n\t\treturn (1);\n\tif (strcasecmp(s, \"green\") == 0 || strcmp(s, \"2\") == 0)\n\t\treturn (2);\n\tif (strcasecmp(s, \"yellow\") == 0 || strcmp(s, \"3\") == 0)\n\t\treturn (3);\n\tif (strcasecmp(s, \"blue\") == 0 || strcmp(s, \"4\") == 0)\n\t\treturn (4);\n\tif (strcasecmp(s, \"magenta\") == 0 || strcmp(s, \"5\") == 0)\n\t\treturn (5);\n\tif (strcasecmp(s, \"cyan\") == 0 || strcmp(s, \"6\") == 0)\n\t\treturn (6);\n\tif (strcasecmp(s, \"white\") == 0 || strcmp(s, \"7\") == 0)\n\t\treturn (7);\n\tif (strcasecmp(s, \"default\") == 0 || strcmp(s, \"8\") == 0)\n\t\treturn (8);\n\tif (strcasecmp(s, \"brightblack\") == 0 || strcmp(s, \"90\") == 0)\n\t\treturn (90);\n\tif (strcasecmp(s, \"brightred\") == 0 || strcmp(s, \"91\") == 0)\n\t\treturn (91);\n\tif (strcasecmp(s, \"brightgreen\") == 0 || strcmp(s, \"92\") == 0)\n\t\treturn (92);\n\tif (strcasecmp(s, \"brightyellow\") == 0 || strcmp(s, \"93\") == 0)\n\t\treturn (93);\n\tif (strcasecmp(s, \"brightblue\") == 0 || strcmp(s, \"94\") == 0)\n\t\treturn (94);\n\tif (strcasecmp(s, \"brightmagenta\") == 0 || strcmp(s, \"95\") == 0)\n\t\treturn (95);\n\tif (strcasecmp(s, \"brightcyan\") == 0 || strcmp(s, \"96\") == 0)\n\t\treturn (96);\n\tif (strcasecmp(s, \"brightwhite\") == 0 || strcmp(s, \"97\") == 0)\n\t\treturn (97);\n\treturn (-1);\n}\n\n/* Convert 256 colour palette to 16. */\nu_char\ncolour_256to16(u_char c)\n{\n\tstatic const u_char table[256] = {\n\t\t 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,\n\t\t 0,  4,  4,  4, 12, 12,  2,  6,  4,  4, 12, 12,  2,  2,  6,  4,\n\t\t12, 12,  2,  2,  2,  6, 12, 12, 10, 10, 10, 10, 14, 12, 10, 10,\n\t\t10, 10, 10, 14,  1,  5,  4,  4, 12, 12,  3,  8,  4,  4, 12, 12,\n\t\t 2,  2,  6,  4, 12, 12,  2,  2,  2,  6, 12, 12, 10, 10, 10, 10,\n\t\t14, 12, 10, 10, 10, 10, 10, 14,  1,  1,  5,  4, 12, 12,  1,  1,\n\t\t 5,  4, 12, 12,  3,  3,  8,  4, 12, 12,  2,  2,  2,  6, 12, 12,\n\t\t10, 10, 10, 10, 14, 12, 10, 10, 10, 10, 10, 14,  1,  1,  1,  5,\n\t\t12, 12,  1,  1,  1,  5, 12, 12,  1,  1,  1,  5, 12, 12,  3,  3,\n\t\t 3,  7, 12, 12, 10, 10, 10, 10, 14, 12, 10, 10, 10, 10, 10, 14,\n\t\t 9,  9,  9,  9, 13, 12,  9,  9,  9,  9, 13, 12,  9,  9,  9,  9,\n\t\t13, 12,  9,  9,  9,  9, 13, 12, 11, 11, 11, 11,  7, 12, 10, 10,\n\t\t10, 10, 10, 14,  9,  9,  9,  9,  9, 13,  9,  9,  9,  9,  9, 13,\n\t\t 9,  9,  9,  9,  9, 13,  9,  9,  9,  9,  9, 13,  9,  9,  9,  9,\n\t\t 9, 13, 11, 11, 11, 11, 11, 15,  0,  0,  0,  0,  0,  0,  8,  8,\n\t\t 8,  8,  8,  8,  7,  7,  7,  7,  7,  7, 15, 15, 15, 15, 15, 15\n\t};\n\n\treturn (table[c]);\n}\n"
        },
        {
          "name": "compat.h",
          "type": "blob",
          "size": 6.16015625,
          "content": "/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#ifndef COMPAT_H\n#define COMPAT_H\n\n#ifndef __GNUC__\n#define __attribute__(a)\n#endif\n\n#ifndef __unused\n#define __unused __attribute__ ((__unused__))\n#endif\n#ifndef __dead\n#define __dead __attribute__ ((__noreturn__))\n#endif\n#ifndef __packed\n#define __packed __attribute__ ((__packed__))\n#endif\n\n#ifndef ECHOPRT\n#define ECHOPRT 0\n#endif\n\n#ifndef HAVE_BSD_TYPES\ntypedef uint8_t u_int8_t;\ntypedef uint16_t u_int16_t;\ntypedef uint32_t u_int32_t;\ntypedef uint64_t u_int64_t;\n#endif\n\n#ifndef HAVE_PATHS_H\n#define\t_PATH_BSHELL\t\"/bin/sh\"\n#define\t_PATH_TMP\t\"/tmp/\"\n#define _PATH_DEVNULL\t\"/dev/null\"\n#define _PATH_TTY\t\"/dev/tty\"\n#define _PATH_DEV\t\"/dev/\"\n#endif\n\n#ifdef HAVE_QUEUE_H\n#include <sys/queue.h>\n#else\n#include \"compat/queue.h\"\n#endif\n\n#ifdef HAVE_TREE_H\n#include <sys/tree.h>\n#else\n#include \"compat/tree.h\"\n#endif\n\n#ifdef HAVE_BITSTRING_H\n#include <bitstring.h>\n#else\n#include \"compat/bitstring.h\"\n#endif\n\n#ifdef HAVE_PATHS_H\n#include <paths.h>\n#endif\n\n#ifdef HAVE_FORKPTY\n#ifdef HAVE_LIBUTIL_H\n#include <libutil.h>\n#endif\n#ifdef HAVE_PTY_H\n#include <pty.h>\n#endif\n#ifdef HAVE_UTIL_H\n#include <util.h>\n#endif\n#endif\n\n#ifdef HAVE_VIS\n#include <vis.h>\n#else\n#include \"compat/vis.h\"\n#endif\n\n#ifdef HAVE_IMSG\n#include <imsg.h>\n#else\n#include \"compat/imsg.h\"\n#endif\n\n#ifdef HAVE_STDINT_H\n#include <stdint.h>\n#else\n#include <inttypes.h>\n#endif\n\n#ifdef BROKEN_CMSG_FIRSTHDR\n#undef CMSG_FIRSTHDR\n#define CMSG_FIRSTHDR(mhdr) \\\n\t((mhdr)->msg_controllen >= sizeof(struct cmsghdr) ? \\\n\t    (struct cmsghdr *)(mhdr)->msg_control :\t    \\\n\t    (struct cmsghdr *)NULL)\n#endif\n\n#ifndef CMSG_ALIGN\n#ifdef _CMSG_DATA_ALIGN\n#define CMSG_ALIGN _CMSG_DATA_ALIGN\n#else\n#define CMSG_ALIGN(len) (((len) + sizeof(long) - 1) & ~(sizeof(long) - 1))\n#endif\n#endif\n\n#ifndef CMSG_SPACE\n#define CMSG_SPACE(len) (CMSG_ALIGN(sizeof(struct cmsghdr)) + CMSG_ALIGN(len))\n#endif\n\n#ifndef CMSG_LEN\n#define CMSG_LEN(len) (CMSG_ALIGN(sizeof(struct cmsghdr)) + (len))\n#endif\n\n#ifndef O_DIRECTORY\n#define O_DIRECTORY 0\n#endif\n\n#ifndef INFTIM\n#define INFTIM -1\n#endif\n\n#ifndef WAIT_ANY\n#define WAIT_ANY -1\n#endif\n\n#ifndef SUN_LEN\n#define SUN_LEN(sun) (sizeof (sun)->sun_path)\n#endif\n\n#ifndef timercmp\n#define\ttimercmp(tvp, uvp, cmp)\t\t\t\t\t\t\\\n\t(((tvp)->tv_sec == (uvp)->tv_sec) ?\t\t\t\t\\\n\t    ((tvp)->tv_usec cmp (uvp)->tv_usec) :\t\t\t\\\n\t    ((tvp)->tv_sec cmp (uvp)->tv_sec))\n#endif\n\n#ifndef timeradd\n#define\ttimeradd(tvp, uvp, vvp)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\t(vvp)->tv_sec = (tvp)->tv_sec + (uvp)->tv_sec;\t\t\\\n\t\t(vvp)->tv_usec = (tvp)->tv_usec + (uvp)->tv_usec;\t\\\n\t\tif ((vvp)->tv_usec >= 1000000) {\t\t\t\\\n\t\t\t(vvp)->tv_sec++;\t\t\t\t\\\n\t\t\t(vvp)->tv_usec -= 1000000;\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n#endif\n\n#ifndef timersub\n#define timersub(tvp, uvp, vvp)                                         \\\n\tdo {                                                            \\\n\t\t(vvp)->tv_sec = (tvp)->tv_sec - (uvp)->tv_sec;          \\\n\t\t(vvp)->tv_usec = (tvp)->tv_usec - (uvp)->tv_usec;       \\\n\t\tif ((vvp)->tv_usec < 0) {                               \\\n\t\t\t(vvp)->tv_sec--;                                \\\n\t\t\t(vvp)->tv_usec += 1000000;                      \\\n\t\t}                                                       \\\n\t} while (0)\n#endif\n\n#ifndef TTY_NAME_MAX\n#define TTY_NAME_MAX 32\n#endif\n\n#ifndef HOST_NAME_MAX\n#define HOST_NAME_MAX 255\n#endif\n\n#ifndef HAVE_FLOCK\n#define LOCK_SH 0\n#define LOCK_EX 0\n#define LOCK_NB 0\n#define flock(fd, op) (0)\n#endif\n\n#ifndef HAVE_CLOSEFROM\n/* closefrom.c */\nvoid\tclosefrom(int);\n#endif\n\n#ifndef HAVE_STRCASESTR\n/* strcasestr.c */\nchar\t\t*strcasestr(const char *, const char *);\n#endif\n\n#ifndef HAVE_STRSEP\n/* strsep.c */\nchar\t\t*strsep(char **, const char *);\n#endif\n\n#ifndef HAVE_STRTONUM\n/* strtonum.c */\nlong long\t strtonum(const char *, long long, long long, const char **);\n#endif\n\n#ifndef HAVE_STRLCPY\n/* strlcpy.c */\nsize_t\t \t strlcpy(char *, const char *, size_t);\n#endif\n\n#ifndef HAVE_STRLCAT\n/* strlcat.c */\nsize_t\t \t strlcat(char *, const char *, size_t);\n#endif\n\n#ifndef HAVE_DAEMON\n/* daemon.c */\nint\t \t daemon(int, int);\n#endif\n\n#ifndef HAVE_B64_NTOP\n/* b64_ntop.c */\n#undef b64_ntop /* for Cygwin */\nint\t\t b64_ntop(const char *, size_t, char *, size_t);\n#endif\n\n#ifndef HAVE_FORKPTY\n/* forkpty.c */\n#include <sys/ioctl.h>\npid_t\t\t forkpty(int *, char *, struct termios *, struct winsize *);\n#endif\n\n#ifndef HAVE_ASPRINTF\n/* asprintf.c */\nint\t\t asprintf(char **, const char *, ...);\nint\t\t vasprintf(char **, const char *, va_list);\n#endif\n\n#ifndef HAVE_FGETLN\n/* fgetln.c */\nchar\t\t*fgetln(FILE *, size_t *);\n#endif\n\n#ifndef HAVE_FPARSELN\nchar\t\t*fparseln(FILE *, size_t *, size_t *, const char *, int);\n#endif\n\n#ifndef HAVE_SETENV\n/* setenv.c */\nint\t\t setenv(const char *, const char *, int);\nint\t\t unsetenv(const char *);\n#endif\n\n#ifndef HAVE_CFMAKERAW\n/* cfmakeraw.c */\nvoid\t\t cfmakeraw(struct termios *);\n#endif\n\n#ifndef HAVE_OPENAT\n/* openat.c */\n#define AT_FDCWD -100\nint\t\t openat(int, const char *, int, ...);\n#endif\n\n#ifndef HAVE_REALLOCARRAY\n/* reallocarray.c */\nvoid\t\t*reallocarray(void *, size_t, size_t size);\n#endif\n\n#ifdef HAVE_GETOPT\n#include <getopt.h>\n#else\n/* getopt.c */\nextern int\tBSDopterr;\nextern int\tBSDoptind;\nextern int\tBSDoptopt;\nextern int\tBSDoptreset;\nextern char    *BSDoptarg;\nint\tBSDgetopt(int, char *const *, const char *);\n#define getopt(ac, av, o)  BSDgetopt(ac, av, o)\n#define opterr             BSDopterr\n#define optind             BSDoptind\n#define optopt             BSDoptopt\n#define optreset           BSDoptreset\n#define optarg             BSDoptarg\n#endif\n\n#endif /* COMPAT_H */\n"
        },
        {
          "name": "compat",
          "type": "tree",
          "content": null
        },
        {
          "name": "configure.ac",
          "type": "blob",
          "size": 13.671875,
          "content": "# configure.ac\n\nAC_INIT(tmate, 2.4.0)\n\nAM_SILENT_RULES([yes])\nAC_CONFIG_AUX_DIR(etc)\nAM_INIT_AUTOMAKE([foreign subdir-objects])\n\nAC_CANONICAL_HOST\n\n# When CFLAGS isn't set at this stage and gcc is detected by the macro below,\n# autoconf will automatically use CFLAGS=\"-O2 -g\". Prevent that by using an\n# empty default.\n: ${CFLAGS=\"\"}\n\n# Set up the compiler in two different ways and say yes we may want to install.\nAC_PROG_CC\nAM_PROG_CC_C_O\nAC_PROG_CPP\nAC_PROG_EGREP\nAC_PROG_INSTALL\nPKG_PROG_PKG_CONFIG\n\n# Default tmux.conf goes in /etc not ${prefix}/etc.\ntest \"$sysconfdir\" = '${prefix}/etc' && sysconfdir=/etc\n\n# Is this --enable-debug?\nfound_debug=yes\nAC_ARG_ENABLE(\n\tdebug,\n\tAC_HELP_STRING(--enable-debug, enable debug build flags),\n\tfound_debug=$enable_debug\n)\nAM_CONDITIONAL(IS_DEBUG, test \"x$found_debug\" = xyes)\n\n# Is this --enable-coverage?\nAC_ARG_ENABLE(\n\tcoverage,\n\tAC_HELP_STRING(--enable-coverage, enable coverage build flags),\n\tfound_coverage=$enable_coverage\n)\nAM_CONDITIONAL(IS_COVERAGE, test \"x$found_coverage\" = xyes)\n\n# Is this a static build?\nAC_ARG_ENABLE(\n\tstatic,\n\tAC_HELP_STRING(--enable-static, create a static build),\n\tfound_static=$enable_static\n)\nif test \"x$found_static\" = xyes; then\n        # XXX Static build are only doable with the musl library\n\tPKG_CONFIG=\"pkg-config --static\"\n\n\tCFLAGS=\"$CFLAGS -flto\"\n\tLDFLAGS=\"$LDFLAGS -flto -static -no-pie\"\n\n\tPKG_CHECK_MODULES([ZLIB], [zlib], [\n\t\tCPPFLAGS=\"$ZLIB_CFLAGS $CPPFLAGS\"\n\t\tLIBS=\"$ZLIB_LIBS $LIBS\"\n\t ])\n\n\tPKG_CHECK_MODULES([LIBCRYPTO], [libcrypto], [\n\t\tCPPFLAGS=\"$LIBCRYPTO_CFLAGS $CPPFLAGS\"\n\t\tLIBS=\"$LIBCRYPTO_LIBS $LIBS\"\n\t])\nfi\n\n# Is this gcc?\nAM_CONDITIONAL(IS_GCC, test \"x$GCC\" = xyes)\n\n# Is this Sun CC?\nAC_EGREP_CPP(\n\tyes,\n\t[\n\t\t#ifdef __SUNPRO_C\n\t\tyes\n\t\t#endif\n\t],\n\tfound_suncc=yes,\n\tfound_suncc=no\n)\nAM_CONDITIONAL(IS_SUNCC, test \"x$found_suncc\" = xyes)\n\n# Is this glibc?\nAC_MSG_CHECKING(for glibc)\nAC_EGREP_CPP(\n\tyes,\n\t[\n\t\t#include <features.h>\n\t\t#ifdef __GLIBC__\n\t\tyes\n\t\t#endif\n\t],\n\tfound_glibc=yes,\n\tfound_glibc=no\n)\nAM_CONDITIONAL(IS_GLIBC, test \"x$found_glibc\" = xyes)\nAC_MSG_RESULT($found_glibc)\n\n# Check for various headers. Alternatives included from compat.h.\nAC_CHECK_HEADERS(\n\t[ \\\n\t\tbitstring.h \\\n\t\tcurses.h \\\n\t\tdirent.h \\\n\t\texecinfo.h \\\n\t\tfcntl.h \\\n\t\tinttypes.h \\\n\t\tlibutil.h \\\n\t\tncurses.h \\\n\t\tndir.h \\\n\t\tpaths.h \\\n\t\tpty.h \\\n\t\tstdint.h \\\n\t\tsys/dir.h \\\n\t\tsys/ndir.h \\\n\t\tsys/tree.h \\\n\t\tterm.h \\\n\t\tutil.h \\\n\t]\n)\n\n# Look for library needed for flock.\nAC_SEARCH_LIBS(flock, bsd)\n\n# Look for library needed for backtrace\nAC_SEARCH_LIBS(backtrace, execinfo)\n\n# Check for some functions that are replaced or omitted.\nAC_CHECK_FUNCS(\n\t[ \\\n\t\tbacktrace \\\n\t\tdirfd \\\n\t\tflock \\\n\t\tsetproctitle \\\n\t\tsysconf \\\n\t\tcfmakeraw \\\n\t]\n)\n\n# Look for clock_gettime. Must come before event_init.\nAC_SEARCH_LIBS(clock_gettime, rt)\n\n# Look for libevent.\nPKG_CHECK_MODULES(\n\tLIBEVENT,\n\tlibevent,\n\t[\n\t\tCPPFLAGS=\"$LIBEVENT_CFLAGS $CPPFLAGS\"\n\t\tLIBS=\"$LIBEVENT_LIBS $LIBS\"\n\t\tfound_libevent=yes\n\t],\n\t[\n\t\tAC_SEARCH_LIBS(\n\t\t\tevent_init,\n\t\t\t[event event-1.4 event2],\n\t\t\tfound_libevent=yes,\n\t\t\tfound_libevent=no\n\t\t)\n\t]\n)\nif test \"x$found_libevent\" = xno; then\n\tAC_MSG_ERROR(\"libevent not found\")\nfi\n\n# Look for ncurses\nPKG_CHECK_MODULES(\n\tLIBNCURSES,\n\tncurses,\n\t[\n\t\tCPPFLAGS=\"$LIBNCURSES_CFLAGS $CPPFLAGS\"\n\t\tLIBS=\"$LIBNCURSES_LIBS $LIBS\"\n\t\tfound_curses=yes\n\t],\n\t[\n\t\tAC_SEARCH_LIBS(\n\t\t\tsetupterm,\n\t\t\t[ncurses curses terminfo],\n\t\t\tfound_curses=yes,\n\t\t\tfound_curses=no\n\t\t)\n\t]\n)\nif test \"x$found_curses\" = xno; then\n\tAC_MSG_ERROR(\"curses not found\")\nfi\n\n# Look for utempter.\nAC_CHECK_HEADER(utempter.h, found_utempter=yes, found_utempter=no)\nif test \"x$found_utempter\" = xyes; then\n\tAC_SEARCH_LIBS(\n\t\tutempter_add_record,\n\t\tutempter,\n\t\tfound_utempter=yes,\n\t\tfound_utempter=no\n\t)\n\tif test \"x$found_utempter\" = xyes; then\n\t\tAC_DEFINE(HAVE_UTEMPTER)\n\tfi\nfi\n\nPKG_CHECK_MODULES(\n  MSGPACK,\n  msgpack >= 1.1.0,\n  [\n    CPPFLAGS=\"$MSGPACK_CFLAGS $CPPFLAGS\"\n    LIBS=\"$MSGPACK_LIBS $LIBS\"\n    found_msgpack=yes\n  ],\n  found_msgpack=no\n)\nif test \"x$found_msgpack\" = xno; then\n  AC_MSG_ERROR(\"msgpack >= 1.1.0 not found\")\nfi\n\nPKG_CHECK_MODULES(\n  LIBSSH,\n  libssh >= 0.8.4,\n  [\n    CPPFLAGS=\"$LIBSSH_CFLAGS $CPPFLAGS\"\n    LIBS=\"$LIBSSH_LIBS $LIBS\"\n    found_libssh=yes\n  ],\n  found_libssh=no\n)\nif test \"x$found_libssh\" = xno; then\n  AC_MSG_ERROR(\"libssh >= 0.8.4 not found\")\nfi\n\n# Check for b64_ntop.\nAC_MSG_CHECKING(for b64_ntop)\nAC_TRY_LINK(\n\t[\n\t\t#include <sys/types.h>\n\t\t#include <netinet/in.h>\n\t\t#include <resolv.h>\n\t],\n\t[b64_ntop(NULL, 0, NULL, 0);],\n\tfound_b64_ntop=yes,\n\tfound_b64_ntop=no\n)\nif test \"x$found_b64_ntop\" = xno; then\n\tAC_MSG_RESULT(no)\n\n\tAC_MSG_CHECKING(for b64_ntop with -lresolv)\n\tLIBS=\"$LIBS -lresolv\"\n\tAC_TRY_LINK(\n\t\t[\n\t\t\t#include <sys/types.h>\n\t\t\t#include <netinet/in.h>\n\t\t\t#include <resolv.h>\n\t\t],\n\t\t[b64_ntop(NULL, 0, NULL, 0);],\n\t\tfound_b64_ntop=yes,\n\t\tfound_b64_ntop=no\n\t)\n\tif test \"x$found_b64_ntop\" = xno; then\n\t\tAC_MSG_RESULT(no)\n\tfi\nfi\nif test \"x$found_b64_ntop\" = xyes; then\n\tAC_DEFINE(HAVE_B64_NTOP)\n\tAC_MSG_RESULT(yes)\nfi\nAM_CONDITIONAL(NO_B64_NTOP, [test \"x$found_b64_ntop\" = xno])\n\n# Look for networking libraries.\nAC_SEARCH_LIBS(inet_ntoa, nsl)\nAC_SEARCH_LIBS(socket, socket)\nAC_CHECK_LIB(xnet, socket)\n\n# Check for CMSG_DATA. Some platforms require _XOPEN_SOURCE_EXTENDED (for\n# example see xopen_networking(7) on HP-UX).\nXOPEN_DEFINES=\nAC_MSG_CHECKING(for CMSG_DATA)\nAC_EGREP_CPP(\n\tyes,\n\t[\n\t\t#include <sys/socket.h>\n\t\t#ifdef CMSG_DATA\n\t\tyes\n\t\t#endif\n\t],\n\tfound_cmsg_data=yes,\n\tfound_cmsg_data=no\n)\nAC_MSG_RESULT($found_cmsg_data)\nif test \"x$found_cmsg_data\" = xno; then\n\tAC_MSG_CHECKING(if CMSG_DATA needs _XOPEN_SOURCE_EXTENDED)\n\tAC_EGREP_CPP(\n\t\tyes,\n\t\t[\n\t\t\t#define _XOPEN_SOURCE 1\n\t\t\t#define _XOPEN_SOURCE_EXTENDED 1\n\t\t\t#include <sys/socket.h>\n\t\t\t#ifdef CMSG_DATA\n\t\t\tyes\n\t\t\t#endif\n\t\t],\n\t\tfound_cmsg_data=yes,\n\t\tfound_cmsg_data=no\n\t)\n\tAC_MSG_RESULT($found_cmsg_data)\n\tif test \"x$found_cmsg_data\" = xyes; then\n\t\tXOPEN_DEFINES=\"-D_XOPEN_SOURCE -D_XOPEN_SOURCE_EXTENDED\"\n\telse\n\t\tAC_MSG_ERROR(\"CMSG_DATA not found\")\n\tfi\nfi\nAC_SUBST(XOPEN_DEFINES)\n\n# Look for imsg in libutil. compat/imsg.c is linked by Makefile.am if missing.\nAC_SEARCH_LIBS(imsg_init, util, found_imsg_init=yes, found_imsg_init=no)\nif test \"x$found_imsg_init\" = xyes; then\n\tAC_DEFINE(HAVE_IMSG)\nfi\nAM_CONDITIONAL(NO_IMSG, [test \"x$found_imsg_init\" = xno])\n\n# Look for forkpty in libutil. compat/forkpty-*.c is linked if not found.\nAC_SEARCH_LIBS(forkpty, util, found_forkpty=yes, found_forkpty=no)\nif test \"x$found_forkpty\" = xyes; then\n\tAC_DEFINE(HAVE_FORKPTY)\nfi\nAM_CONDITIONAL(NO_FORKPTY, [test \"x$found_forkpty\" = xno])\n\n# Look for closefrom, compat/closefrom.c used if missing.\nAC_CHECK_FUNC(closefrom, found_closefrom=yes, found_closefrom=no)\nif test \"x$found_closefrom\" = xyes; then\n\tAC_DEFINE(HAVE_CLOSEFROM)\nfi\nAM_CONDITIONAL(NO_CLOSEFROM, [test \"x$found_closefrom\" = xno])\n\n# Look for daemon, compat/daemon.c used if missing.\nAC_CHECK_FUNC(daemon, found_daemon=yes, found_daemon=no)\nif test \"x$found_daemon\" = xyes; then\n\tAC_DEFINE(HAVE_DAEMON)\nfi\nAM_CONDITIONAL(NO_DAEMON, [test \"x$found_daemon\" = xno])\n\n# Look for setenv, compat/setenv.c used if missing.\nAC_CHECK_FUNC(setenv, found_setenv=yes, found_setenv=no)\nif test \"x$found_setenv\" = xyes; then\n\tAC_DEFINE(HAVE_SETENV)\nfi\nAM_CONDITIONAL(NO_SETENV, [test \"x$found_setenv\" = xno])\n\n# Look for strlcpy, compat/strlcpy.c used if missing.\nAC_CHECK_FUNC(strlcpy, found_strlcpy=yes, found_strlcpy=no)\nif test \"x$found_strlcpy\" = xyes; then\n\tAC_DEFINE(HAVE_STRLCPY)\nfi\nAM_CONDITIONAL(NO_STRLCPY, [test \"x$found_strlcpy\" = xno])\n\n# Look for strlcat, compat/strlcat.c used if missing.\nAC_CHECK_FUNC(strlcat, found_strlcat=yes, found_strlcat=no)\nif test \"x$found_strlcat\" = xyes; then\n\tAC_DEFINE(HAVE_STRLCAT)\nfi\nAM_CONDITIONAL(NO_STRLCAT, [test \"x$found_strlcat\" = xno])\n\n# Look for asprintf, compat/asprintf.c used if missing.\nAC_CHECK_FUNC(asprintf, found_asprintf=yes, found_asprintf=no)\nif test \"x$found_asprintf\" = xyes; then\n\tAC_DEFINE(HAVE_ASPRINTF)\nfi\nAM_CONDITIONAL(NO_ASPRINTF, [test \"x$found_asprintf\" = xno])\n\n# Look for fgetln, compat/fgetln.c used if missing.\nAC_CHECK_FUNC(fgetln, found_fgetln=yes, found_fgetln=no)\nif test \"x$found_fgetln\" = xyes; then\n\tAC_DEFINE(HAVE_FGETLN)\nfi\nAM_CONDITIONAL(NO_FGETLN, [test \"x$found_fgetln\" = xno])\n\n# Look for fparseln, compat/fparseln.c used if missing.\nAC_CHECK_FUNC(fparseln, found_fparseln=yes, found_fparseln=no)\nif test \"x$found_fparseln\" = xyes; then\n\tAC_DEFINE(HAVE_FPARSELN)\nfi\nAM_CONDITIONAL(NO_FPARSELN, [test \"x$found_fparseln\" = xno])\n\n# Look for strcasestr, compat/strcasestr.c used if missing.\nAC_CHECK_FUNC(strcasestr, found_strcasestr=yes, found_strcasestr=no)\nif test \"x$found_strcasestr\" = xyes; then\n\tAC_DEFINE(HAVE_STRCASESTR)\nfi\nAM_CONDITIONAL(NO_STRCASESTR, [test \"x$found_strcasestr\" = xno])\n\n# Look for strsep, compat/strsep.c used if missing.\nAC_CHECK_FUNC(strsep, found_strsep=yes, found_strsep=no)\nif test \"x$found_strsep\" = xyes; then\n\tAC_DEFINE(HAVE_STRSEP)\nfi\nAM_CONDITIONAL(NO_STRSEP, [test \"x$found_strsep\" = xno])\n\n# Look for strtonum, compat/strtonum.c used if missing.\nAC_CHECK_FUNC(strtonum, found_strtonum=yes, found_strtonum=no)\nif test \"x$found_strtonum\" = xyes; then\n\tAC_DEFINE(HAVE_STRTONUM)\nfi\nAM_CONDITIONAL(NO_STRTONUM, [test \"x$found_strtonum\" = xno])\n\n# Look for stravis, compat/{vis,unvis}.c used if missing.\nAC_CHECK_FUNC(stravis, found_stravis=yes, found_stravis=no)\nif test \"x$found_stravis\" = xyes; then\n\tAC_MSG_CHECKING(if strnvis is broken)\n\tAC_EGREP_HEADER([strnvis\\(char \\*, const char \\*, size_t, int\\)],\n\t\t\tvis.h,\n\t\t\tAC_MSG_RESULT(no),\n\t\t\t[found_stravis=no])\n\tif test \"x$found_stravis\" = xno; then\n\t\tAC_MSG_RESULT(yes)\n\tfi\nfi\nif test \"x$found_stravis\" = xyes; then\n\tAC_DEFINE(HAVE_VIS)\nfi\nAM_CONDITIONAL(NO_VIS, [test \"x$found_stravis\" = xno])\n\n# Look for cfmakeraw, compat/cfmakeraw.c used if missing.\nAC_CHECK_FUNC(cfmakeraw, found_cfmakeraw=yes, found_cfmakeraw=no)\nif test \"x$found_cfmakeraw\" = xyes; then\n\tAC_DEFINE(HAVE_CFMAKERAW)\nfi\nAM_CONDITIONAL(NO_CFMAKERAW, [test \"x$found_cfmakeraw\" = xno])\n\n# Look for openat, compat/openat.c used if missing.\nAC_CHECK_FUNC(openat, found_openat=yes, found_openat=no)\nif test \"x$found_openat\" = xyes; then\n\tAC_DEFINE(HAVE_OPENAT)\nfi\nAM_CONDITIONAL(NO_OPENAT, [test \"x$found_openat\" = xno])\n\n# Look for reallocarray, compat/reallocarray.c used if missing.\nAC_CHECK_FUNC(reallocarray, found_reallocarray=yes, found_reallocarray=no)\nif test \"x$found_reallocarray\" = xyes; then\n\tAC_DEFINE(HAVE_REALLOCARRAY)\nfi\nAM_CONDITIONAL(NO_REALLOCARRAY, [test \"x$found_reallocarray\" = xno])\n\n# Look for getopt. glibc's getopt does not enforce argument order and the ways\n# of making it do so are stupid, so just use our own instead.\nAC_CHECK_FUNC(getopt, found_getopt=yes, found_getopt=no)\nif test \"x$found_getopt\" != xno; then\t\n\tAC_CHECK_DECLS(\n\t\t[optarg, optind, optreset],\n\t\t,\n\t\tfound_getopt=no,\n\t\t[\n\t\t\t#include <unistd.h>\n\t\t]\n\t)\t\n\tif test \"x$found_getopt\" != xno; then\t\n\t\tAC_MSG_CHECKING(if system getopt should be avoided)\n\t\tif test \"x$found_glibc\" = xyes; then\n\t\t\tfound_getopt=no\n\t\t\tAC_MSG_RESULT(yes)\n\t\telse\n\t\t\tAC_MSG_RESULT(no)\n\t\t\tAC_DEFINE(HAVE_GETOPT)\n\t\tfi\n\tfi\nfi\nAM_CONDITIONAL(NO_GETOPT, [test \"x$found_getopt\" = xno])\n\n# Check for BSD-style integer types.\nAC_MSG_CHECKING(for BSD-style unsigned types)\nAC_COMPILE_IFELSE([AC_LANG_SOURCE(\n\t[\n\t\t#include <sys/types.h>\n\t\t#ifdef HAVE_STDINT_H\n\t\t#include <stdint.h>\n\t\t#else\n\t\t#include <inttypes.h>\n\t\t#endif\n\t\tint main(void)\n\t\t{ u_int8_t u8; u_int16_t u16; u_int32_t u32; u_int64_t u64; }\n\t])],\n\t[AC_DEFINE(HAVE_BSD_TYPES) AC_MSG_RESULT(yes)],\n\tAC_MSG_RESULT(no)\n)\n\n# Look for a suitable queue.h.\nAC_CHECK_DECL(\n\tTAILQ_PREV,\n\tfound_queue_h=yes,\n\tfound_queue_h=no,\n\t[#include <sys/queue.h>]\n)\nAC_CHECK_DECL(\n\tTAILQ_REPLACE,\n\t,\n\tfound_queue_h=no,\n\t[#include <sys/queue.h>]\n)\nif test \"x$found_queue_h\" = xyes; then\n\tAC_DEFINE(HAVE_QUEUE_H)\nfi\n\n# Look for __progname.\nAC_MSG_CHECKING(for __progname)\nAC_LINK_IFELSE([AC_LANG_SOURCE(\n\t[\n\t\t#include <stdio.h>\n\t\t#include <stdlib.h>\n\t\textern char *__progname;\n\t\tint main(void) {\n\t\t\tconst char *cp = __progname;\n\t\t\tprintf(\"%s\\n\", cp);\n\t\t\texit(0);\n\t\t}\n\t])],\n\t[AC_DEFINE(HAVE___PROGNAME) AC_MSG_RESULT(yes)],\n\tAC_MSG_RESULT(no)\n)\n\n# Look for fcntl(F_CLOSEM).\nAC_CHECK_DECL(\n\tF_CLOSEM,\n\tAC_DEFINE(HAVE_FCNTL_CLOSEM),\n\t,\n\t[#include <fcntl.h>]\n)\n\n# Look for /proc/$$.\nAC_MSG_CHECKING(for /proc/\\$\\$)\nif test -d /proc/$$; then\n\tAC_DEFINE(HAVE_PROC_PID)\n\tAC_MSG_RESULT(yes)\nelse\n\tAC_MSG_RESULT(no)\nfi\n\n# Man page defaults to mdoc.\nMANFORMAT=mdoc\nAC_SUBST(MANFORMAT)\n\n# Figure out the platform for osdep-*.c and forkpty-*.c.\nAC_MSG_CHECKING(platform)\ncase \"$host_os\" in\n\t*aix*)\n\t\tAC_MSG_RESULT(aix)\n\t\tPLATFORM=aix\n\t\t;;\n\t*darwin*)\n\t\tAC_MSG_RESULT(darwin)\n\t\tAC_DEFINE(BROKEN_CMSG_FIRSTHDR)\n\t\tPLATFORM=darwin\n\t\t;;\n\t*dragonfly*)\n\t\tAC_MSG_RESULT(dragonfly)\n\t\tPLATFORM=dragonfly\n\t\t;;\n\t*linux*)\n\t\tAC_MSG_RESULT(linux)\n\t\tPLATFORM=linux\n    AC_DEFINE(IS_LINUX)\n\t\t;;\n\t*freebsd*)\n\t\tAC_MSG_RESULT(freebsd)\n\t\tPLATFORM=freebsd\n\t\t;;\n\t*netbsd*)\n\t\tAC_MSG_RESULT(netbsd)\n\t\tPLATFORM=netbsd\n\t\t;;\n\t*openbsd*)\n\t\tAC_MSG_RESULT(openbsd)\n\t\tPLATFORM=openbsd\n\t\t;;\n\t*sunos*)\n\t\tAC_MSG_RESULT(sunos)\n\t\tPLATFORM=sunos\n\t\t;;\n\t*solaris*)\n\t\tAC_MSG_RESULT(sunos)\n\t\tPLATFORM=sunos\n\t\tMANFORMAT=man\n\t\t;;\n\t*hpux*)\n\t\tAC_MSG_RESULT(hpux)\n\t\tPLATFORM=hpux\n\t\t;;\n\t*cygwin*)\n\t\tAC_MSG_RESULT(cygwin)\n\t\tPLATFORM=cygwin\n\t\t;;\n\t*)\n\t\tAC_MSG_RESULT(unknown)\n\t\tPLATFORM=unknown\n\t\t;;\t\nesac\nAC_SUBST(PLATFORM)\nAM_CONDITIONAL(IS_AIX, test \"x$PLATFORM\" = xaix)\nAM_CONDITIONAL(IS_DARWIN, test \"x$PLATFORM\" = xdarwin)\nAM_CONDITIONAL(IS_DRAGONFLY, test \"x$PLATFORM\" = xdragonfly)\nAM_CONDITIONAL(IS_LINUX, test \"x$PLATFORM\" = xlinux)\nAM_CONDITIONAL(IS_FREEBSD, test \"x$PLATFORM\" = xfreebsd)\nAM_CONDITIONAL(IS_NETBSD, test \"x$PLATFORM\" = xnetbsd)\nAM_CONDITIONAL(IS_OPENBSD, test \"x$PLATFORM\" = xopenbsd)\nAM_CONDITIONAL(IS_SUNOS, test \"x$PLATFORM\" = xsunos)\nAM_CONDITIONAL(IS_HPUX, test \"x$PLATFORM\" = xhpux)\nAM_CONDITIONAL(IS_UNKNOWN, test \"x$PLATFORM\" = xunknown)\n\n# autoconf should create a Makefile.\nAC_OUTPUT(Makefile)\n"
        },
        {
          "name": "control-notify.c",
          "type": "blob",
          "size": 5.0068359375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2012 Nicholas Marriott <nicholas.marriott@gmail.com>\n * Copyright (c) 2012 George Nachman <tmux@georgester.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n\n#include \"tmux.h\"\n\n#define CONTROL_SHOULD_NOTIFY_CLIENT(c) \\\n\t((c) != NULL && ((c)->flags & CLIENT_CONTROL))\n\nvoid\ncontrol_notify_input(struct client *c, struct window_pane *wp,\n    struct evbuffer *input)\n{\n\tu_char\t\t*buf;\n\tsize_t\t\t len;\n\tstruct evbuffer *message;\n\tu_int\t\t i;\n\n\tif (c->session == NULL)\n\t    return;\n\n\tbuf = EVBUFFER_DATA(input);\n\tlen = EVBUFFER_LENGTH(input);\n\n\t/*\n\t * Only write input if the window pane is linked to a window belonging\n\t * to the client's session.\n\t */\n\tif (winlink_find_by_window(&c->session->windows, wp->window) != NULL) {\n\t\tmessage = evbuffer_new();\n\t\tevbuffer_add_printf(message, \"%%output %%%u \", wp->id);\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (buf[i] < ' ' || buf[i] == '\\\\')\n\t\t\t    evbuffer_add_printf(message, \"\\\\%03o\", buf[i]);\n\t\t\telse\n\t\t\t    evbuffer_add_printf(message, \"%c\", buf[i]);\n\t\t}\n\t\tcontrol_write_buffer(c, message);\n\t\tevbuffer_free(message);\n\t}\n}\n\nvoid\ncontrol_notify_window_layout_changed(struct window *w)\n{\n\tstruct client\t\t*c;\n\tstruct session\t\t*s;\n\tstruct format_tree\t*ft;\n\tstruct winlink\t\t*wl;\n\tconst char\t\t*template;\n\tchar\t\t\t*expanded;\n\n\ttemplate = \"%layout-change #{window_id} #{window_layout} \"\n\t    \"#{window_visible_layout} #{window_flags}\";\n\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (!CONTROL_SHOULD_NOTIFY_CLIENT(c) || c->session == NULL)\n\t\t\tcontinue;\n\t\ts = c->session;\n\n\t\tif (winlink_find_by_window_id(&s->windows, w->id) == NULL)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * When the last pane in a window is closed it won't have a\n\t\t * layout root and we don't need to inform the client about the\n\t\t * layout change because the whole window will go away soon.\n\t\t */\n\t\tif (w->layout_root == NULL)\n\t\t\tcontinue;\n\n\t\tft = format_create(NULL, 0);\n\t\twl = winlink_find_by_window(&s->windows, w);\n\t\tif (wl != NULL) {\n\t\t\tformat_defaults(ft, c, NULL, wl, NULL);\n\t\t\texpanded = format_expand(ft, template);\n\t\t\tcontrol_write(c, \"%s\", expanded);\n\t\t\tfree(expanded);\n\t\t}\n\t\tformat_free(ft);\n\t}\n}\n\nvoid\ncontrol_notify_window_unlinked(__unused struct session *s, struct window *w)\n{\n\tstruct client\t*c;\n\tstruct session\t*cs;\n\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (!CONTROL_SHOULD_NOTIFY_CLIENT(c) || c->session == NULL)\n\t\t\tcontinue;\n\t\tcs = c->session;\n\n\t\tif (winlink_find_by_window_id(&cs->windows, w->id) != NULL)\n\t\t\tcontrol_write(c, \"%%window-close @%u\", w->id);\n\t\telse\n\t\t\tcontrol_write(c, \"%%unlinked-window-close @%u\", w->id);\n\t}\n}\n\nvoid\ncontrol_notify_window_linked(__unused struct session *s, struct window *w)\n{\n\tstruct client\t*c;\n\tstruct session\t*cs;\n\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (!CONTROL_SHOULD_NOTIFY_CLIENT(c) || c->session == NULL)\n\t\t\tcontinue;\n\t\tcs = c->session;\n\n\t\tif (winlink_find_by_window_id(&cs->windows, w->id) != NULL)\n\t\t\tcontrol_write(c, \"%%window-add @%u\", w->id);\n\t\telse\n\t\t\tcontrol_write(c, \"%%unlinked-window-add @%u\", w->id);\n\t}\n}\n\nvoid\ncontrol_notify_window_renamed(struct window *w)\n{\n\tstruct client\t*c;\n\tstruct session\t*cs;\n\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (!CONTROL_SHOULD_NOTIFY_CLIENT(c) || c->session == NULL)\n\t\t\tcontinue;\n\t\tcs = c->session;\n\n\t\tif (winlink_find_by_window_id(&cs->windows, w->id) != NULL) {\n\t\t\tcontrol_write(c, \"%%window-renamed @%u %s\", w->id,\n\t\t\t    w->name);\n\t\t} else {\n\t\t\tcontrol_write(c, \"%%unlinked-window-renamed @%u %s\",\n\t\t\t    w->id, w->name);\n\t\t}\n\t}\n}\n\nvoid\ncontrol_notify_attached_session_changed(struct client *c)\n{\n\tstruct session\t*s;\n\n\tif (!CONTROL_SHOULD_NOTIFY_CLIENT(c) || c->session == NULL)\n\t\treturn;\n\ts = c->session;\n\n\tcontrol_write(c, \"%%session-changed $%u %s\", s->id, s->name);\n}\n\nvoid\ncontrol_notify_session_renamed(struct session *s)\n{\n\tstruct client\t*c;\n\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (!CONTROL_SHOULD_NOTIFY_CLIENT(c))\n\t\t\tcontinue;\n\n\t\tcontrol_write(c, \"%%session-renamed $%u %s\", s->id, s->name);\n\t}\n}\n\nvoid\ncontrol_notify_session_created(__unused struct session *s)\n{\n\tstruct client\t*c;\n\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (!CONTROL_SHOULD_NOTIFY_CLIENT(c))\n\t\t\tcontinue;\n\n\t\tcontrol_write(c, \"%%sessions-changed\");\n\t}\n}\n\nvoid\ncontrol_notify_session_close(__unused struct session *s)\n{\n\tstruct client\t*c;\n\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (!CONTROL_SHOULD_NOTIFY_CLIENT(c))\n\t\t\tcontinue;\n\n\t\tcontrol_write(c, \"%%sessions-changed\");\n\t}\n}\n"
        },
        {
          "name": "control.c",
          "type": "blob",
          "size": 2.3310546875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2012 Nicholas Marriott <nicholas.marriott@gmail.com>\n * Copyright (c) 2012 George Nachman <tmux@georgester.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <event.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\n#include \"tmux.h\"\n\n/* Write a line. */\nvoid\ncontrol_write(struct client *c, const char *fmt, ...)\n{\n\tva_list\t\t ap;\n\n\tva_start(ap, fmt);\n\tevbuffer_add_vprintf(c->stdout_data, fmt, ap);\n\tva_end(ap);\n\n\tevbuffer_add(c->stdout_data, \"\\n\", 1);\n\tserver_client_push_stdout(c);\n}\n\n/* Write a buffer, adding a terminal newline. Empties buffer. */\nvoid\ncontrol_write_buffer(struct client *c, struct evbuffer *buffer)\n{\n\tevbuffer_add_buffer(c->stdout_data, buffer);\n\tevbuffer_add(c->stdout_data, \"\\n\", 1);\n\tserver_client_push_stdout(c);\n}\n\n/* Control input callback. Read lines and fire commands. */\nvoid\ncontrol_callback(struct client *c, int closed, __unused void *data)\n{\n\tchar\t\t*line, *cause;\n\tstruct cmd_list\t*cmdlist;\n\tstruct cmd\t*cmd;\n\n\tif (closed)\n\t\tc->flags |= CLIENT_EXIT;\n\n\tfor (;;) {\n\t\tline = evbuffer_readln(c->stdin_data, NULL, EVBUFFER_EOL_LF);\n\t\tif (line == NULL)\n\t\t\tbreak;\n\t\tif (*line == '\\0') { /* empty line exit */\n\t\t\tc->flags |= CLIENT_EXIT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (cmd_string_parse(line, &cmdlist, NULL, 0, &cause) != 0) {\n\t\t\tc->cmdq->time = time(NULL);\n\t\t\tc->cmdq->number++;\n\n\t\t\tcmdq_guard(c->cmdq, \"begin\", 1);\n\t\t\tcontrol_write(c, \"parse error: %s\", cause);\n\t\t\tcmdq_guard(c->cmdq, \"error\", 1);\n\n\t\t\tfree(cause);\n\t\t} else {\n\t\t\tTAILQ_FOREACH(cmd, &cmdlist->list, qentry)\n\t\t\t\tcmd->flags |= CMD_CONTROL;\n\t\t\tcmdq_run(c->cmdq, cmdlist, NULL);\n\t\t\tcmd_list_free(cmdlist);\n\t\t}\n\n\t\tfree(line);\n\t}\n}\n"
        },
        {
          "name": "environ.c",
          "type": "blob",
          "size": 4.724609375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * Environment - manipulate a set of environment variables.\n */\n\nRB_HEAD(environ, environ_entry);\nint\tenviron_cmp(struct environ_entry *, struct environ_entry *);\nRB_PROTOTYPE(environ, environ_entry, entry, environ_cmp);\nRB_GENERATE(environ, environ_entry, entry, environ_cmp);\n\nint\nenviron_cmp(struct environ_entry *envent1, struct environ_entry *envent2)\n{\n\treturn (strcmp(envent1->name, envent2->name));\n}\n\n/* Initialise the environment. */\nstruct environ *\nenviron_create(void)\n{\n\tstruct environ\t*env;\n\n\tenv = xcalloc(1, sizeof *env);\n\tRB_INIT(env);\n\n\treturn (env);\n}\n\n/* Free an environment. */\nvoid\nenviron_free(struct environ *env)\n{\n\tstruct environ_entry\t*envent, *envent1;\n\n\tRB_FOREACH_SAFE(envent, environ, env, envent1) {\n\t\tRB_REMOVE(environ, env, envent);\n\t\tfree(envent->name);\n\t\tfree(envent->value);\n\t\tfree(envent);\n\t}\n\tfree(env);\n}\n\nstruct environ_entry *\nenviron_first(struct environ *env)\n{\n\treturn (RB_MIN(environ, env));\n}\n\nstruct environ_entry *\nenviron_next(struct environ_entry *envent)\n{\n\treturn (RB_NEXT(environ, env, envent));\n}\n\n/* Copy one environment into another. */\nvoid\nenviron_copy(struct environ *srcenv, struct environ *dstenv)\n{\n\tstruct environ_entry\t*envent;\n\n\tRB_FOREACH(envent, environ, srcenv) {\n\t\tif (envent->value == NULL)\n\t\t\tenviron_clear(dstenv, envent->name);\n\t\telse\n\t\t\tenviron_set(dstenv, envent->name, \"%s\", envent->value);\n\t}\n}\n\n/* Find an environment variable. */\nstruct environ_entry *\nenviron_find(struct environ *env, const char *name)\n{\n\tstruct environ_entry\tenvent;\n\n\tenvent.name = (char *) name;\n\treturn (RB_FIND(environ, env, &envent));\n}\n\n/* Set an environment variable. */\nvoid\nenviron_set(struct environ *env, const char *name, const char *fmt, ...)\n{\n\tstruct environ_entry\t*envent;\n\tva_list\t\t\t ap;\n\n\tva_start(ap, fmt);\n\tif ((envent = environ_find(env, name)) != NULL) {\n\t\tfree(envent->value);\n\t\txvasprintf(&envent->value, fmt, ap);\n\t} else {\n\t\tenvent = xmalloc(sizeof *envent);\n\t\tenvent->name = xstrdup(name);\n\t\txvasprintf(&envent->value, fmt, ap);\n\t\tRB_INSERT(environ, env, envent);\n\t}\n\tva_end(ap);\n}\n\n/* Clear an environment variable. */\nvoid\nenviron_clear(struct environ *env, const char *name)\n{\n\tstruct environ_entry\t*envent;\n\n\tif ((envent = environ_find(env, name)) != NULL) {\n\t\tfree(envent->value);\n\t\tenvent->value = NULL;\n\t} else {\n\t\tenvent = xmalloc(sizeof *envent);\n\t\tenvent->name = xstrdup(name);\n\t\tenvent->value = NULL;\n\t\tRB_INSERT(environ, env, envent);\n\t}\n}\n\n/* Set an environment variable from a NAME=VALUE string. */\nvoid\nenviron_put(struct environ *env, const char *var)\n{\n\tchar\t*name, *value;\n\n\tvalue = strchr(var, '=');\n\tif (value == NULL)\n\t\treturn;\n\tvalue++;\n\n\tname = xstrdup(var);\n\tname[strcspn(name, \"=\")] = '\\0';\n\n\tenviron_set(env, name, \"%s\", value);\n\tfree(name);\n}\n\n/* Unset an environment variable. */\nvoid\nenviron_unset(struct environ *env, const char *name)\n{\n\tstruct environ_entry\t*envent;\n\n\tif ((envent = environ_find(env, name)) == NULL)\n\t\treturn;\n\tRB_REMOVE(environ, env, envent);\n\tfree(envent->name);\n\tfree(envent->value);\n\tfree(envent);\n}\n\n/*\n * Copy a space-separated list of variables from a destination into a source\n * environment.\n */\nvoid\nenviron_update(const char *vars, struct environ *srcenv,\n    struct environ *dstenv)\n{\n\tstruct environ_entry\t*envent;\n\tchar\t\t\t*copyvars, *var, *next;\n\n\tcopyvars = next = xstrdup(vars);\n\twhile ((var = strsep(&next, \" \")) != NULL) {\n\t\tif ((envent = environ_find(srcenv, var)) == NULL)\n\t\t\tenviron_clear(dstenv, var);\n\t\telse\n\t\t\tenviron_set(dstenv, envent->name, \"%s\", envent->value);\n\t}\n\tfree(copyvars);\n}\n\n/* Push environment into the real environment - use after fork(). */\nvoid\nenviron_push(struct environ *env)\n{\n\tstruct environ_entry\t *envent;\n\tchar\t\t\t*v;\n\n\twhile (*environ != NULL) {\n\t\tv = xstrdup(*environ);\n\t\tv[strcspn(v, \"=\")] = '\\0';\n\n\t\tunsetenv(v);\n\t\tfree(v);\n\t}\n\n\tRB_FOREACH(envent, environ, env) {\n\t\tif (envent->value != NULL)\n\t\t\tsetenv(envent->name, envent->value, 1);\n\t}\n}\n"
        },
        {
          "name": "example_tmux.conf",
          "type": "blob",
          "size": 1.650390625,
          "content": "#\n# Example .tmux.conf\n#\n# By Nicholas Marriott. Public domain.\n#\n\n# Some tweaks to the status line\nset -g status-bg green\nset -g status-right \"%H:%M\"\nset -g window-status-current-attr \"underscore\"\n\n# No bells at all\nset -g bell-action none\n\n# Lock after 15 minutes\nset -g lock-after-time 1800\n\n# Keep windows around after they exit\nset -g remain-on-exit on\n\n# Turn on xterm-keys so that additional function keys get escape sequences\nset -g xterm-keys on\n\n# Change the prefix key to C-a\nset -g prefix C-a\nunbind C-b\nbind C-a send-prefix\n\n# Turn the mouse on, but without copy mode dragging\nset -g mouse on\nunbind -n MouseDrag1Pane\nunbind -temacs-copy MouseDrag1Pane\n\n# Some extra key bindings to select higher numbered windows\nbind F1 selectw -t:10\nbind F2 selectw -t:11\nbind F3 selectw -t:12\nbind F4 selectw -t:13\nbind F5 selectw -t:14\nbind F6 selectw -t:15\nbind F7 selectw -t:16\nbind F8 selectw -t:17\nbind F9 selectw -t:18\nbind F10 selectw -t:19\nbind F11 selectw -t:20\nbind F12 selectw -t:21\n\n# Keys to toggle monitoring activity in a window, and synchronize-panes\nbind m set monitor-activity\nbind y set synchronize-panes\\; display 'synchronize-panes #{?synchronize-panes,on,off}'\n\n# Keys to hide and show a window name from the status line\nbind '-' set window-status-format '#I'\\; set window-status-current-format '#I'\nbind '+' set window-status-format '#I:#W#F'\\; set window-status-current-format '#I:#W#F'\n\n# Create a single default session\nnew -d -s0 -nirssi 'exec irssi'\nset -t0:0 monitor-activity on\nset  -t0:0 aggressive-resize on\nneww -d -ntodo 'exec emacs ~/TODO'\nsetw -t0:1 aggressive-resize on\nneww -d -nmutt 'exec mutt'\nsetw -t0:2 aggressive-resize on\nneww -d\nneww -d\nneww -d\n"
        },
        {
          "name": "format.c",
          "type": "blob",
          "size": 29.1826171875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2011 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/wait.h>\n\n#include <ctype.h>\n#include <errno.h>\n#include <libgen.h>\n#include <netdb.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n#include \"tmate.h\"\n\n/*\n * Build a list of key-value pairs and use them to expand #{key} entries in a\n * string.\n */\n\nstruct format_entry;\ntypedef void (*format_cb)(struct format_tree *, struct format_entry *);\n\nvoid\t format_job_callback(struct job *);\nchar\t*format_job_get(struct format_tree *, const char *);\nvoid\t format_job_timer(int, short, void *);\n\nvoid\t format_cb_host(struct format_tree *, struct format_entry *);\nvoid\t format_cb_host_short(struct format_tree *, struct format_entry *);\nvoid\t format_cb_pid(struct format_tree *, struct format_entry *);\nvoid\t format_cb_session_alerts(struct format_tree *, struct format_entry *);\nvoid\t format_cb_window_layout(struct format_tree *, struct format_entry *);\nvoid\t format_cb_window_visible_layout(struct format_tree *,\n\t     struct format_entry *);\nvoid\t format_cb_start_command(struct format_tree *, struct format_entry *);\nvoid\t format_cb_current_command(struct format_tree *, struct format_entry *);\nvoid\t format_cb_current_path(struct format_tree *, struct format_entry *);\nvoid\t format_cb_history_bytes(struct format_tree *, struct format_entry *);\nvoid\t format_cb_pane_tabs(struct format_tree *, struct format_entry *);\n\nchar\t*format_find(struct format_tree *, const char *, int);\nvoid\t format_add_cb(struct format_tree *, const char *, format_cb);\nvoid\t format_add_tv(struct format_tree *, const char *, struct timeval *);\nint\t format_replace(struct format_tree *, const char *, size_t, char **,\n\t     size_t *, size_t *);\nchar\t*format_time_string(time_t);\n\nvoid\t format_defaults_pane_tabs(struct format_tree *, struct window_pane *);\nvoid\t format_defaults_session(struct format_tree *, struct session *);\nvoid\t format_defaults_client(struct format_tree *, struct client *);\nvoid\t format_defaults_winlink(struct format_tree *, struct session *,\n\t     struct winlink *);\n\n/* Entry in format job tree. */\nstruct format_job {\n\tconst char\t\t*cmd;\n\n\ttime_t\t\t\t last;\n\tchar\t\t\t*out;\n\n\tstruct job\t\t*job;\n\tint\t\t\t status;\n\n\tRB_ENTRY(format_job)\t entry;\n};\n\n/* Format job tree. */\nstruct event format_job_event;\nint\tformat_job_cmp(struct format_job *, struct format_job *);\nRB_HEAD(format_job_tree, format_job) format_jobs = RB_INITIALIZER();\nRB_PROTOTYPE(format_job_tree, format_job, entry, format_job_cmp);\nRB_GENERATE(format_job_tree, format_job, entry, format_job_cmp);\n\n/* Format job tree comparison function. */\nint\nformat_job_cmp(struct format_job *fj1, struct format_job *fj2)\n{\n\treturn (strcmp(fj1->cmd, fj2->cmd));\n}\n\n/* Format modifiers. */\n#define FORMAT_TIMESTRING 0x1\n#define FORMAT_BASENAME 0x2\n#define FORMAT_DIRNAME 0x4\n#define FORMAT_SUBSTITUTE 0x8\n\n/* Entry in format tree. */\nstruct format_entry {\n\tchar\t\t\t*key;\n\tchar\t\t\t*value;\n\ttime_t\t\t\t t;\n\tformat_cb\t\t cb;\n\tRB_ENTRY(format_entry)\t entry;\n};\n\n/* Format entry tree. */\nstruct format_tree {\n\tstruct window\t\t*w;\n\tstruct session\t\t*s;\n\tstruct window_pane\t*wp;\n\n\tint\t\t\t flags;\n\n\tRB_HEAD(format_entry_tree, format_entry) tree;\n};\nint\tformat_entry_cmp(struct format_entry *, struct format_entry *);\nRB_PROTOTYPE(format_entry_tree, format_entry, entry, format_entry_cmp);\nRB_GENERATE(format_entry_tree, format_entry, entry, format_entry_cmp);\n\n/* Format entry tree comparison function. */\nint\nformat_entry_cmp(struct format_entry *fe1, struct format_entry *fe2)\n{\n\treturn (strcmp(fe1->key, fe2->key));\n}\n\n/* Single-character uppercase aliases. */\nconst char *format_upper[] = {\n\tNULL,\t\t/* A */\n\tNULL,\t\t/* B */\n\tNULL,\t\t/* C */\n\t\"pane_id\",\t/* D */\n\tNULL,\t\t/* E */\n\t\"window_flags\",\t/* F */\n\tNULL,\t\t/* G */\n\t\"host\",\t\t/* H */\n\t\"window_index\",\t/* I */\n\tNULL,\t\t/* J */\n\tNULL,\t\t/* K */\n\tNULL,\t\t/* L */\n\tNULL,\t\t/* M */\n\tNULL,\t\t/* N */\n\tNULL,\t\t/* O */\n\t\"pane_index\",\t/* P */\n\tNULL,\t\t/* Q */\n\tNULL,\t\t/* R */\n\t\"session_name\",\t/* S */\n\t\"pane_title\",\t/* T */\n\tNULL,\t\t/* U */\n\tNULL,\t\t/* V */\n\t\"window_name\",\t/* W */\n\tNULL,\t\t/* X */\n\tNULL,\t\t/* Y */\n\tNULL \t\t/* Z */\n};\n\n/* Single-character lowercase aliases. */\nconst char *format_lower[] = {\n\tNULL,\t\t/* a */\n\tNULL,\t\t/* b */\n\tNULL,\t\t/* c */\n\tNULL,\t\t/* d */\n\tNULL,\t\t/* e */\n\tNULL,\t\t/* f */\n\tNULL,\t\t/* g */\n\t\"host_short\",\t/* h */\n\tNULL,\t\t/* i */\n\tNULL,\t\t/* j */\n\tNULL,\t\t/* k */\n\tNULL,\t\t/* l */\n\tNULL,\t\t/* m */\n\tNULL,\t\t/* n */\n\tNULL,\t\t/* o */\n\tNULL,\t\t/* p */\n\tNULL,\t\t/* q */\n\tNULL,\t\t/* r */\n\tNULL,\t\t/* s */\n\tNULL,\t\t/* t */\n\tNULL,\t\t/* u */\n\tNULL,\t\t/* v */\n\tNULL,\t\t/* w */\n\tNULL,\t\t/* x */\n\tNULL,\t\t/* y */\n\tNULL\t\t/* z */\n};\n\n/* Format job callback. */\nvoid\nformat_job_callback(struct job *job)\n{\n\tstruct format_job\t*fj = job->data;\n\tchar\t\t\t*line, *buf;\n\tsize_t\t\t\t len;\n\tstruct client\t\t*c;\n\n\tfj->job = NULL;\n\tfree(fj->out);\n\n\tbuf = NULL;\n\tif ((line = evbuffer_readline(job->event->input)) == NULL) {\n\t\tlen = EVBUFFER_LENGTH(job->event->input);\n\t\tbuf = xmalloc(len + 1);\n\t\tif (len != 0)\n\t\t\tmemcpy(buf, EVBUFFER_DATA(job->event->input), len);\n\t\tbuf[len] = '\\0';\n\t} else\n\t\tbuf = line;\n\tfj->out = buf;\n\n\tif (fj->status) {\n\t\tTAILQ_FOREACH(c, &clients, entry)\n\t\t    server_status_client(c);\n\t\tfj->status = 0;\n\t}\n\n\tlog_debug(\"%s: %s: %s\", __func__, fj->cmd, fj->out);\n}\n\n/* Find a job. */\nchar *\nformat_job_get(struct format_tree *ft, const char *cmd)\n{\n\tstruct format_job\tfj0, *fj;\n\ttime_t\t\t\tt;\n\n\tfj0.cmd = cmd;\n\tif ((fj = RB_FIND(format_job_tree, &format_jobs, &fj0)) == NULL) {\n\t\tfj = xcalloc(1, sizeof *fj);\n\t\tfj->cmd = xstrdup(cmd);\n\n\t\txasprintf(&fj->out, \"<'%s' not ready>\", fj->cmd);\n\n\t\tRB_INSERT(format_job_tree, &format_jobs, fj);\n\t}\n\n\tt = time(NULL);\n\tif (fj->job == NULL && ((ft->flags & FORMAT_FORCE) || fj->last != t)) {\n\t\tfj->job = job_run(fj->cmd, NULL, NULL, format_job_callback,\n\t\t    NULL, fj);\n\t\tif (fj->job == NULL) {\n\t\t\tfree(fj->out);\n\t\t\txasprintf(&fj->out, \"<'%s' didn't start>\", fj->cmd);\n\t\t}\n\t\tfj->last = t;\n\t}\n\n\tif (ft->flags & FORMAT_STATUS)\n\t\tfj->status = 1;\n\n\treturn (format_expand(ft, fj->out));\n}\n\n/* Remove old jobs. */\nvoid\nformat_job_timer(__unused int fd, __unused short events, __unused void *arg)\n{\n\tstruct format_job\t*fj, *fj1;\n\ttime_t\t\t\t now;\n\tstruct timeval\t\t tv = { .tv_sec = 60 };\n\n\tnow = time(NULL);\n\tRB_FOREACH_SAFE(fj, format_job_tree, &format_jobs, fj1) {\n\t\tif (fj->last > now || now - fj->last < 3600)\n\t\t\tcontinue;\n\t\tRB_REMOVE(format_job_tree, &format_jobs, fj);\n\n\t\tlog_debug(\"%s: %s\", __func__, fj->cmd);\n\n\t\tif (fj->job != NULL)\n\t\t\tjob_free(fj->job);\n\n\t\tfree((void *)fj->cmd);\n\t\tfree(fj->out);\n\n\t\tfree(fj);\n\t}\n\n\tevtimer_del(&format_job_event);\n\tevtimer_add(&format_job_event, &tv);\n}\n\n/* Callback for host. */\nvoid\nformat_cb_host(__unused struct format_tree *ft, struct format_entry *fe)\n{\n\tchar host[HOST_NAME_MAX + 1];\n\n\tif (gethostname(host, sizeof host) != 0)\n\t\tfe->value = xstrdup(\"\");\n\telse\n\t\tfe->value = xstrdup(host);\n}\n\n/* Callback for host_short. */\nvoid\nformat_cb_host_short(__unused struct format_tree *ft, struct format_entry *fe)\n{\n\tchar host[HOST_NAME_MAX + 1], *cp;\n\n\tif (gethostname(host, sizeof host) != 0)\n\t\tfe->value = xstrdup(\"\");\n\telse {\n\t\tif ((cp = strchr(host, '.')) != NULL)\n\t\t\t*cp = '\\0';\n\t\tfe->value = xstrdup(host);\n\t}\n}\n\n/* Callback for pid. */\nvoid\nformat_cb_pid(__unused struct format_tree *ft, struct format_entry *fe)\n{\n\txasprintf(&fe->value, \"%ld\", (long)getpid());\n}\n\n/* Callback for session_alerts. */\nvoid\nformat_cb_session_alerts(struct format_tree *ft, struct format_entry *fe)\n{\n\tstruct session\t*s = ft->s;\n\tstruct winlink\t*wl;\n\tchar\t\t alerts[256], tmp[16];\n\n\tif (s == NULL)\n\t\treturn;\n\n\t*alerts = '\\0';\n\tRB_FOREACH(wl, winlinks, &s->windows) {\n\t\tif ((wl->flags & WINLINK_ALERTFLAGS) == 0)\n\t\t\tcontinue;\n\t\txsnprintf(tmp, sizeof tmp, \"%u\", wl->idx);\n\n\t\tif (*alerts != '\\0')\n\t\t\tstrlcat(alerts, \",\", sizeof alerts);\n\t\tstrlcat(alerts, tmp, sizeof alerts);\n\t\tif (wl->flags & WINLINK_ACTIVITY)\n\t\t\tstrlcat(alerts, \"#\", sizeof alerts);\n\t\tif (wl->flags & WINLINK_BELL)\n\t\t\tstrlcat(alerts, \"!\", sizeof alerts);\n\t\tif (wl->flags & WINLINK_SILENCE)\n\t\t\tstrlcat(alerts, \"~\", sizeof alerts);\n\t}\n\tfe->value = xstrdup(alerts);\n}\n\n/* Callback for window_layout. */\nvoid\nformat_cb_window_layout(struct format_tree *ft, struct format_entry *fe)\n{\n\tstruct window\t*w = ft->w;\n\n\tif (w == NULL)\n\t\treturn;\n\n\tif (w->saved_layout_root != NULL)\n\t\tfe->value = layout_dump(w->saved_layout_root);\n\telse\n\t\tfe->value = layout_dump(w->layout_root);\n}\n\n/* Callback for window_visible_layout. */\nvoid\nformat_cb_window_visible_layout(struct format_tree *ft, struct format_entry *fe)\n{\n\tstruct window\t*w = ft->w;\n\n\tif (w == NULL)\n\t\treturn;\n\n\tfe->value = layout_dump(w->layout_root);\n}\n\n/* Callback for pane_start_command. */\nvoid\nformat_cb_start_command(struct format_tree *ft, struct format_entry *fe)\n{\n\tstruct window_pane\t*wp = ft->wp;\n\n\tif (wp == NULL)\n\t\treturn;\n\n\tfe->value = cmd_stringify_argv(wp->argc, wp->argv);\n}\n\n/* Callback for pane_current_command. */\nvoid\nformat_cb_current_command(struct format_tree *ft, struct format_entry *fe)\n{\n\tstruct window_pane\t*wp = ft->wp;\n\tchar\t\t\t*cmd;\n\n\tif (wp == NULL)\n\t\treturn;\n\n\tcmd = osdep_get_name(wp->fd, wp->tty);\n\tif (cmd == NULL || *cmd == '\\0') {\n\t\tfree(cmd);\n\t\tcmd = cmd_stringify_argv(wp->argc, wp->argv);\n\t\tif (cmd == NULL || *cmd == '\\0') {\n\t\t\tfree(cmd);\n\t\t\tcmd = xstrdup(wp->shell);\n\t\t}\n\t}\n\tfe->value = parse_window_name(cmd);\n\tfree(cmd);\n}\n\n/* Callback for pane_current_path. */\nvoid\nformat_cb_current_path(struct format_tree *ft, struct format_entry *fe)\n{\n\tstruct window_pane\t*wp = ft->wp;\n\tchar\t\t\t*cwd;\n\n\tif (wp == NULL)\n\t\treturn;\n\n\tcwd = osdep_get_cwd(wp->fd);\n\tif (cwd != NULL)\n\t\tfe->value = xstrdup(cwd);\n}\n\n/* Callback for history_bytes. */\nvoid\nformat_cb_history_bytes(struct format_tree *ft, struct format_entry *fe)\n{\n\tstruct window_pane\t*wp = ft->wp;\n\tstruct grid\t\t*gd;\n\tstruct grid_line\t*gl;\n\tunsigned long long\t size;\n\tu_int\t\t\t i;\n\n\tif (wp == NULL)\n\t\treturn;\n\tgd = wp->base.grid;\n\n\tsize = 0;\n\tfor (i = 0; i < gd->hsize; i++) {\n\t\tgl = &gd->linedata[i];\n\t\tsize += gl->cellsize * sizeof *gl->celldata;\n\t\tsize += gl->extdsize * sizeof *gl->extddata;\n\t}\n\tsize += gd->hsize * sizeof *gd->linedata;\n\n\txasprintf(&fe->value, \"%llu\", size);\n}\n\n/* Callback for pane_tabs. */\nvoid\nformat_cb_pane_tabs(struct format_tree *ft, struct format_entry *fe)\n{\n\tstruct window_pane\t*wp = ft->wp;\n\tstruct evbuffer\t\t*buffer;\n\tu_int\t\t\t i;\n\tint\t\t\t size;\n\n\tif (wp == NULL)\n\t\treturn;\n\n\tbuffer = evbuffer_new();\n\tfor (i = 0; i < wp->base.grid->sx; i++) {\n\t\tif (!bit_test(wp->base.tabs, i))\n\t\t\tcontinue;\n\n\t\tif (EVBUFFER_LENGTH(buffer) > 0)\n\t\t\tevbuffer_add(buffer, \",\", 1);\n\t\tevbuffer_add_printf(buffer, \"%u\", i);\n\t}\n\tsize = EVBUFFER_LENGTH(buffer);\n\txasprintf(&fe->value, \"%.*s\", size, EVBUFFER_DATA(buffer));\n\tevbuffer_free(buffer);\n}\n\n/* Create a new tree. */\nstruct format_tree *\nformat_create(struct cmd_q *cmdq, int flags)\n{\n\tstruct format_tree\t*ft;\n\n\tif (!event_initialized(&format_job_event)) {\n\t\tevtimer_set(&format_job_event, format_job_timer, NULL);\n\t\tformat_job_timer(-1, 0, NULL);\n\t}\n\n\tft = xcalloc(1, sizeof *ft);\n\tRB_INIT(&ft->tree);\n\tft->flags = flags;\n\n\tformat_add_cb(ft, \"host\", format_cb_host);\n\tformat_add_cb(ft, \"host_short\", format_cb_host_short);\n\tformat_add_cb(ft, \"pid\", format_cb_pid);\n\tformat_add(ft, \"socket_path\", \"%s\", socket_path);\n\tformat_add_tv(ft, \"start_time\", &start_time);\n\n\tif (cmdq != NULL && cmdq->cmd != NULL)\n\t\tformat_add(ft, \"command_name\", \"%s\", cmdq->cmd->entry->name);\n\n\treturn (ft);\n}\n\n/* Free a tree. */\nvoid\nformat_free(struct format_tree *ft)\n{\n\tstruct format_entry\t*fe, *fe1;\n\n\tRB_FOREACH_SAFE(fe, format_entry_tree, &ft->tree, fe1) {\n\t\tRB_REMOVE(format_entry_tree, &ft->tree, fe);\n\t\tfree(fe->value);\n\t\tfree(fe->key);\n\t\tfree(fe);\n\t}\n\n\tfree(ft);\n}\n\n/* Add a key-value pair. */\nvoid\nformat_add(struct format_tree *ft, const char *key, const char *fmt, ...)\n{\n\tstruct format_entry\t*fe;\n\tstruct format_entry\t*fe_now;\n\tva_list\t\t\t ap;\n\n\tfe = xmalloc(sizeof *fe);\n\tfe->key = xstrdup(key);\n\n\tfe_now = RB_INSERT(format_entry_tree, &ft->tree, fe);\n\tif (fe_now != NULL) {\n\t\tfree(fe->key);\n\t\tfree(fe);\n\t\tfree(fe_now->value);\n\t\tfe = fe_now;\n\t}\n\n\tfe->cb = NULL;\n\tfe->t = 0;\n\n\tva_start(ap, fmt);\n\txvasprintf(&fe->value, fmt, ap);\n\tva_end(ap);\n}\n\n/* Add a key and time. */\nvoid\nformat_add_tv(struct format_tree *ft, const char *key, struct timeval *tv)\n{\n\tstruct format_entry\t*fe;\n\tstruct format_entry\t*fe_now;\n\n\tfe = xmalloc(sizeof *fe);\n\tfe->key = xstrdup(key);\n\n\tfe_now = RB_INSERT(format_entry_tree, &ft->tree, fe);\n\tif (fe_now != NULL) {\n\t\tfree(fe->key);\n\t\tfree(fe);\n\t\tfree(fe_now->value);\n\t\tfe = fe_now;\n\t}\n\n\tfe->cb = NULL;\n\tfe->t = tv->tv_sec;\n\n\tfe->value = NULL;\n}\n\n/* Add a key and function. */\nvoid\nformat_add_cb(struct format_tree *ft, const char *key, format_cb cb)\n{\n\tstruct format_entry\t*fe;\n\tstruct format_entry\t*fe_now;\n\n\tfe = xmalloc(sizeof *fe);\n\tfe->key = xstrdup(key);\n\n\tfe_now = RB_INSERT(format_entry_tree, &ft->tree, fe);\n\tif (fe_now != NULL) {\n\t\tfree(fe->key);\n\t\tfree(fe);\n\t\tfree(fe_now->value);\n\t\tfe = fe_now;\n\t}\n\n\tfe->cb = cb;\n\tfe->t = 0;\n\n\tfe->value = NULL;\n}\n\n/* Find a format entry. */\nchar *\nformat_find(struct format_tree *ft, const char *key, int modifiers)\n{\n\tstruct format_entry\t*fe, fe_find;\n\tstruct options_entry\t*o;\n\tstruct environ_entry\t*envent;\n\tstatic char\t\t s[64];\n\tconst char\t\t*found;\n\tchar\t\t\t*copy, *saved;\n\n\tfound = NULL;\n\n\tif (~modifiers & FORMAT_TIMESTRING) {\n\t\to = options_find(global_options, key);\n\t\tif (o == NULL && ft->w != NULL)\n\t\t\to = options_find(ft->w->options, key);\n\t\tif (o == NULL)\n\t\t\to = options_find(global_w_options, key);\n\t\tif (o == NULL && ft->s != NULL)\n\t\t\to = options_find(ft->s->options, key);\n\t\tif (o == NULL)\n\t\t\to = options_find(global_s_options, key);\n\t\tif (o != NULL) {\n\t\t\tswitch (o->type) {\n\t\t\tcase OPTIONS_STRING:\n\t\t\t\tfound = o->str;\n\t\t\t\tgoto found;\n\t\t\tcase OPTIONS_NUMBER:\n\t\t\t\txsnprintf(s, sizeof s, \"%lld\", o->num);\n\t\t\t\tfound = s;\n\t\t\t\tgoto found;\n\t\t\tcase OPTIONS_STYLE:\n\t\t\t\tfound = style_tostring(&o->style);\n\t\t\t\tgoto found;\n\t\t\t}\n\t\t}\n\t}\n\n\tfe_find.key = (char *) key;\n\tfe = RB_FIND(format_entry_tree, &ft->tree, &fe_find);\n\tif (fe != NULL) {\n\t\tif (modifiers & FORMAT_TIMESTRING) {\n\t\t\tif (fe->t == 0)\n\t\t\t\treturn (NULL);\n\t\t\tctime_r(&fe->t, s);\n\t\t\ts[strcspn(s, \"\\n\")] = '\\0';\n\t\t\tfound = s;\n\t\t\tgoto found;\n\t\t}\n\t\tif (fe->t != 0) {\n\t\t\txsnprintf(s, sizeof s, \"%lld\", (long long)fe->t);\n\t\t\tfound = s;\n\t\t\tgoto found;\n\t\t}\n\t\tif (fe->value == NULL && fe->cb != NULL)\n\t\t\tfe->cb(ft, fe);\n\t\tfound = fe->value;\n\t\tgoto found;\n\t}\n\n\tif (~modifiers & FORMAT_TIMESTRING) {\n\t\tenvent = NULL;\n\t\tif (ft->s != NULL)\n\t\t\tenvent = environ_find(ft->s->environ, key);\n\t\tif (envent == NULL)\n\t\t\tenvent = environ_find(global_environ, key);\n\t\tif (envent != NULL) {\n\t\t\tfound = envent->value;\n\t\t\tgoto found;\n\t\t}\n\t}\n\n\treturn (NULL);\n\nfound:\n\tif (found == NULL)\n\t\treturn (NULL);\n\tcopy = xstrdup(found);\n\tif (modifiers & FORMAT_BASENAME) {\n\t\tsaved = copy;\n\t\tcopy = xstrdup(basename(saved));\n\t\tfree(saved);\n\t}\n\tif (modifiers & FORMAT_DIRNAME) {\n\t\tsaved = copy;\n\t\tcopy = xstrdup(dirname(saved));\n\t\tfree(saved);\n\t}\n\treturn (copy);\n}\n\n/*\n * Replace a key/value pair in buffer. #{blah} is expanded directly,\n * #{?blah,a,b} is replace with a if blah exists and is nonzero else b.\n */\nint\nformat_replace(struct format_tree *ft, const char *key, size_t keylen,\n    char **buf, size_t *len, size_t *off)\n{\n\tchar\t\t*copy, *copy0, *endptr, *ptr, *found, *new, *value;\n\tchar\t\t*from = NULL, *to = NULL;\n\tsize_t\t\t valuelen, newlen, fromlen, tolen, used;\n\tlong\t\t limit = 0;\n\tint\t\t modifiers = 0, brackets;\n\n\t/* Make a copy of the key. */\n\tcopy0 = copy = xmalloc(keylen + 1);\n\tmemcpy(copy, key, keylen);\n\tcopy[keylen] = '\\0';\n\n\t/* Is there a length limit or whatnot? */\n\tswitch (copy[0]) {\n\tcase '=':\n\t\terrno = 0;\n\t\tlimit = strtol(copy + 1, &endptr, 10);\n\t\tif (errno == ERANGE && (limit == LONG_MIN || limit == LONG_MAX))\n\t\t\tbreak;\n\t\tif (*endptr != ':')\n\t\t\tbreak;\n\t\tcopy = endptr + 1;\n\t\tbreak;\n\tcase 'b':\n\t\tif (copy[1] != ':')\n\t\t\tbreak;\n\t\tmodifiers |= FORMAT_BASENAME;\n\t\tcopy += 2;\n\t\tbreak;\n\tcase 'd':\n\t\tif (copy[1] != ':')\n\t\t\tbreak;\n\t\tmodifiers |= FORMAT_DIRNAME;\n\t\tcopy += 2;\n\t\tbreak;\n\tcase 't':\n\t\tif (copy[1] != ':')\n\t\t\tbreak;\n\t\tmodifiers |= FORMAT_TIMESTRING;\n\t\tcopy += 2;\n\t\tbreak;\n\tcase 's':\n\t\tif (copy[1] != '/')\n\t\t\tbreak;\n\t\tfrom = copy + 2;\n\t\tfor (copy = from; *copy != '\\0' && *copy != '/'; copy++)\n\t\t\t/* nothing */;\n\t\tif (copy[0] != '/' || copy == from) {\n\t\t\tcopy = copy0;\n\t\t\tbreak;\n\t\t}\n\t\tcopy[0] = '\\0';\n\t\tto = copy + 1;\n\t\tfor (copy = to; *copy != '\\0' && *copy != '/'; copy++)\n\t\t\t/* nothing */;\n\t\tif (copy[0] != '/' || copy[1] != ':') {\n\t\t\tcopy = copy0;\n\t\t\tbreak;\n\t\t}\n\t\tcopy[0] = '\\0';\n\n\t\tmodifiers |= FORMAT_SUBSTITUTE;\n\t\tcopy += 2;\n\t\tbreak;\n\t}\n\n\t/*\n\t * Is this a conditional? If so, check it exists and extract either the\n\t * first or second element. If not, look up the key directly.\n\t */\n\tif (*copy == '?') {\n\t\tptr = strchr(copy, ',');\n\t\tif (ptr == NULL)\n\t\t\tgoto fail;\n\t\t*ptr = '\\0';\n\n\t\tvalue = ptr + 1;\n\t\tfound = format_find(ft, copy + 1, modifiers);\n\n\t\tbrackets = 0;\n\t\tfor (ptr = ptr + 1; *ptr != '\\0'; ptr++) {\n\t\t\tif (*ptr == '{')\n\t\t\t\tbrackets++;\n\t\t\tif (*ptr == '}')\n\t\t\t\tbrackets--;\n\t\t\tif (*ptr == ',' && brackets == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (*ptr == '\\0')\n\t\t\tgoto fail;\n\n\t\tif (found != NULL && *found != '\\0' &&\n\t\t    (found[0] != '0' || found[1] != '\\0')) {\n\t\t\t*ptr = '\\0';\n\t\t} else\n\t\t\tvalue = ptr + 1;\n\t\tvalue = format_expand(ft, value);\n\t\tfree(found);\n\t} else {\n\t\tvalue = format_find(ft, copy, modifiers);\n\t\tif (value == NULL)\n\t\t\tvalue = xstrdup(\"\");\n\t}\n\n\t/* Perform substitution if any. */\n\tif (modifiers & FORMAT_SUBSTITUTE) {\n\t\tfromlen = strlen(from);\n\t\ttolen = strlen(to);\n\n\t\tnewlen = strlen(value) + 1;\n\t\tcopy = new = xmalloc(newlen);\n\t\tfor (ptr = value; *ptr != '\\0'; /* nothing */) {\n\t\t\tif (strncmp(ptr, from, fromlen) != 0) {\n\t\t\t\t*new++ = *ptr++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tused = new - copy;\n\n\t\t\tnewlen += tolen;\n\t\t\tcopy = xrealloc(copy, newlen);\n\n\t\t\tnew = copy + used;\n\t\t\tmemcpy(new, to, tolen);\n\n\t\t\tnew += tolen;\n\t\t\tptr += fromlen;\n\t\t}\n\t\t*new = '\\0';\n\t\tfree(value);\n\t\tvalue = copy;\n\t}\n\n\t/* Truncate the value if needed. */\n\tif (limit > 0) {\n\t\tnew = utf8_trimcstr(value, limit);\n\t\tfree(value);\n\t\tvalue = new;\n\t} else if (limit < 0) {\n\t\tnew = utf8_rtrimcstr(value, -limit);\n\t\tfree(value);\n\t\tvalue = new;\n\t}\n\n\t/* Expand the buffer and copy in the value. */\n\tvaluelen = strlen(value);\n\twhile (*len - *off < valuelen + 1) {\n\t\t*buf = xreallocarray(*buf, 2, *len);\n\t\t*len *= 2;\n\t}\n\tmemcpy(*buf + *off, value, valuelen);\n\t*off += valuelen;\n\n\tfree(value);\n\tfree(copy0);\n\treturn (0);\n\nfail:\n\tfree(copy0);\n\treturn (-1);\n}\n\n/* Expand keys in a template, passing through strftime first. */\nchar *\nformat_expand_time(struct format_tree *ft, const char *fmt, time_t t)\n{\n\tchar\t\t*tmp, *expanded;\n\tsize_t\t\t tmplen;\n\tstruct tm\t*tm;\n\n\tif (fmt == NULL || *fmt == '\\0')\n\t\treturn (xstrdup(\"\"));\n\n\ttm = localtime(&t);\n\n\ttmp = NULL;\n\ttmplen = strlen(fmt);\n\n\tdo {\n\t\ttmp = xreallocarray(tmp, 2, tmplen);\n\t\ttmplen *= 2;\n\t} while (strftime(tmp, tmplen, fmt, tm) == 0);\n\n\texpanded = format_expand(ft, tmp);\n\tfree(tmp);\n\n\treturn (expanded);\n}\n\n/* Expand keys in a template. */\nchar *\nformat_expand(struct format_tree *ft, const char *fmt)\n{\n\tchar\t\t*buf, *tmp, *cmd, *out;\n\tconst char\t*ptr, *s, *saved = fmt;\n\tsize_t\t\t off, len, n, outlen;\n\tint     \t ch, brackets;\n\n\tif (fmt == NULL)\n\t\treturn (xstrdup(\"\"));\n\n#ifdef TMATE\n\ttmate_format(ft);\n#endif\n\n\tlen = 64;\n\tbuf = xmalloc(len);\n\toff = 0;\n\n\twhile (*fmt != '\\0') {\n\t\tif (*fmt != '#') {\n\t\t\twhile (len - off < 2) {\n\t\t\t\tbuf = xreallocarray(buf, 2, len);\n\t\t\t\tlen *= 2;\n\t\t\t}\n\t\t\tbuf[off++] = *fmt++;\n\t\t\tcontinue;\n\t\t}\n\t\tfmt++;\n\n\t\tch = (u_char) *fmt++;\n\t\tswitch (ch) {\n\t\tcase '(':\n\t\t\tbrackets = 1;\n\t\t\tfor (ptr = fmt; *ptr != '\\0'; ptr++) {\n\t\t\t\tif (*ptr == '(')\n\t\t\t\t\tbrackets++;\n\t\t\t\tif (*ptr == ')' && --brackets == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (*ptr != ')' || brackets != 0)\n\t\t\t\tbreak;\n\t\t\tn = ptr - fmt;\n\n\t\t\ttmp = xmalloc(n + 1);\n\t\t\tmemcpy(tmp, fmt, n);\n\t\t\ttmp[n] = '\\0';\n\t\t\tcmd = format_expand(ft, tmp);\n\n\t\t\tout = format_job_get(ft, cmd);\n\t\t\toutlen = strlen(out);\n\n\t\t\tfree(cmd);\n\t\t\tfree(tmp);\n\n\t\t\twhile (len - off < outlen + 1) {\n\t\t\t\tbuf = xreallocarray(buf, 2, len);\n\t\t\t\tlen *= 2;\n\t\t\t}\n\t\t\tmemcpy(buf + off, out, outlen);\n\t\t\toff += outlen;\n\n\t\t\tfree(out);\n\n\t\t\tfmt += n + 1;\n\t\t\tcontinue;\n\t\tcase '{':\n\t\t\tbrackets = 1;\n\t\t\tfor (ptr = fmt; *ptr != '\\0'; ptr++) {\n\t\t\t\tif (*ptr == '{')\n\t\t\t\t\tbrackets++;\n\t\t\t\tif (*ptr == '}' && --brackets == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (*ptr != '}' || brackets != 0)\n\t\t\t\tbreak;\n\t\t\tn = ptr - fmt;\n\n\t\t\tif (format_replace(ft, fmt, n, &buf, &len, &off) != 0)\n\t\t\t\tbreak;\n\t\t\tfmt += n + 1;\n\t\t\tcontinue;\n\t\tcase '#':\n\t\t\twhile (len - off < 2) {\n\t\t\t\tbuf = xreallocarray(buf, 2, len);\n\t\t\t\tlen *= 2;\n\t\t\t}\n\t\t\tbuf[off++] = '#';\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\ts = NULL;\n\t\t\tif (ch >= 'A' && ch <= 'Z')\n\t\t\t\ts = format_upper[ch - 'A'];\n\t\t\telse if (ch >= 'a' && ch <= 'z')\n\t\t\t\ts = format_lower[ch - 'a'];\n\t\t\tif (s == NULL) {\n\t\t\t\twhile (len - off < 3) {\n\t\t\t\t\tbuf = xreallocarray(buf, 2, len);\n\t\t\t\t\tlen *= 2;\n\t\t\t\t}\n\t\t\t\tbuf[off++] = '#';\n\t\t\t\tbuf[off++] = ch;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tn = strlen(s);\n\t\t\tif (format_replace(ft, s, n, &buf, &len, &off) != 0)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbreak;\n\t}\n\tbuf[off] = '\\0';\n\n\tlog_debug(\"format '%s' -> '%s'\", saved, buf);\n\treturn (buf);\n}\n\n/* Set defaults for any of arguments that are not NULL. */\nvoid\nformat_defaults(struct format_tree *ft, struct client *c, struct session *s,\n    struct winlink *wl, struct window_pane *wp)\n{\n\tif (s == NULL && c != NULL)\n\t\ts = c->session;\n\tif (wl == NULL && s != NULL)\n\t\twl = s->curw;\n\tif (wp == NULL && wl != NULL)\n\t\twp = wl->window->active;\n\n\tif (c != NULL)\n\t\tformat_defaults_client(ft, c);\n\tif (s != NULL)\n\t\tformat_defaults_session(ft, s);\n\tif (s != NULL && wl != NULL)\n\t\tformat_defaults_winlink(ft, s, wl);\n\tif (wp != NULL)\n\t\tformat_defaults_pane(ft, wp);\n}\n\n/* Set default format keys for a session. */\nvoid\nformat_defaults_session(struct format_tree *ft, struct session *s)\n{\n\tstruct session_group\t*sg;\n\n\tft->s = s;\n\n\tformat_add(ft, \"session_name\", \"%s\", s->name);\n\tformat_add(ft, \"session_windows\", \"%u\", winlink_count(&s->windows));\n\tformat_add(ft, \"session_width\", \"%u\", s->sx);\n\tformat_add(ft, \"session_height\", \"%u\", s->sy);\n\tformat_add(ft, \"session_id\", \"$%u\", s->id);\n\n\tsg = session_group_find(s);\n\tformat_add(ft, \"session_grouped\", \"%d\", sg != NULL);\n\tif (sg != NULL)\n\t\tformat_add(ft, \"session_group\", \"%u\", session_group_index(sg));\n\n\tformat_add_tv(ft, \"session_created\", &s->creation_time);\n\tformat_add_tv(ft, \"session_last_attached\", &s->last_attached_time);\n\tformat_add_tv(ft, \"session_activity\", &s->activity_time);\n\n\tformat_add(ft, \"session_attached\", \"%u\", s->attached);\n\tformat_add(ft, \"session_many_attached\", \"%d\", s->attached > 1);\n\n\tformat_add_cb(ft, \"session_alerts\", format_cb_session_alerts);\n}\n\n/* Set default format keys for a client. */\nvoid\nformat_defaults_client(struct format_tree *ft, struct client *c)\n{\n\tstruct session\t*s;\n\tconst char\t*name;\n\n\tif (ft->s == NULL)\n\t\tft->s = c->session;\n\n\tformat_add(ft, \"client_pid\", \"%ld\", (long) c->pid);\n\tformat_add(ft, \"client_height\", \"%u\", c->tty.sy);\n\tformat_add(ft, \"client_width\", \"%u\", c->tty.sx);\n\tif (c->tty.path != NULL)\n\t\tformat_add(ft, \"client_tty\", \"%s\", c->tty.path);\n\tif (c->tty.termname != NULL)\n\t\tformat_add(ft, \"client_termname\", \"%s\", c->tty.termname);\n\tformat_add(ft, \"client_control_mode\", \"%d\",\n\t\t!!(c->flags & CLIENT_CONTROL));\n\n\tformat_add_tv(ft, \"client_created\", &c->creation_time);\n\tformat_add_tv(ft, \"client_activity\", &c->activity_time);\n\n\tname = server_client_get_key_table(c);\n\tif (strcmp(c->keytable->name, name) == 0)\n\t\tformat_add(ft, \"client_prefix\", \"%d\", 0);\n\telse\n\t\tformat_add(ft, \"client_prefix\", \"%d\", 1);\n\tformat_add(ft, \"client_key_table\", \"%s\", c->keytable->name);\n\n\tif (c->tty.flags & TTY_UTF8)\n\t\tformat_add(ft, \"client_utf8\", \"%d\", 1);\n\telse\n\t\tformat_add(ft, \"client_utf8\", \"%d\", 0);\n\n\tif (c->flags & CLIENT_READONLY)\n\t\tformat_add(ft, \"client_readonly\", \"%d\", 1);\n\telse\n\t\tformat_add(ft, \"client_readonly\", \"%d\", 0);\n\n\ts = c->session;\n\tif (s != NULL)\n\t\tformat_add(ft, \"client_session\", \"%s\", s->name);\n\ts = c->last_session;\n\tif (s != NULL && session_alive(s))\n\t\tformat_add(ft, \"client_last_session\", \"%s\", s->name);\n}\n\n/* Set default format keys for a window. */\nvoid\nformat_defaults_window(struct format_tree *ft, struct window *w)\n{\n\tft->w = w;\n\n\tformat_add_tv(ft, \"window_activity\", &w->activity_time);\n\tformat_add(ft, \"window_id\", \"@%u\", w->id);\n\tformat_add(ft, \"window_name\", \"%s\", w->name);\n\tformat_add(ft, \"window_width\", \"%u\", w->sx);\n\tformat_add(ft, \"window_height\", \"%u\", w->sy);\n\tformat_add_cb(ft, \"window_layout\", format_cb_window_layout);\n\tformat_add_cb(ft, \"window_visible_layout\",\n\t    format_cb_window_visible_layout);\n\tformat_add(ft, \"window_panes\", \"%u\", window_count_panes(w));\n\tformat_add(ft, \"window_zoomed_flag\", \"%d\",\n\t    !!(w->flags & WINDOW_ZOOMED));\n}\n\n/* Set default format keys for a winlink. */\nvoid\nformat_defaults_winlink(struct format_tree *ft, struct session *s,\n    struct winlink *wl)\n{\n\tstruct window\t*w = wl->window;\n\tchar\t\t*flags;\n\n\tif (ft->w == NULL)\n\t\tft->w = wl->window;\n\n\tflags = window_printable_flags(s, wl);\n\n\tformat_defaults_window(ft, w);\n\n\tformat_add(ft, \"window_index\", \"%d\", wl->idx);\n\tformat_add(ft, \"window_flags\", \"%s\", flags);\n\tformat_add(ft, \"window_active\", \"%d\", wl == s->curw);\n\n\tformat_add(ft, \"window_bell_flag\", \"%d\",\n\t    !!(wl->flags & WINLINK_BELL));\n\tformat_add(ft, \"window_activity_flag\", \"%d\",\n\t    !!(wl->flags & WINLINK_ACTIVITY));\n\tformat_add(ft, \"window_silence_flag\", \"%d\",\n\t    !!(wl->flags & WINLINK_SILENCE));\n\tformat_add(ft, \"window_last_flag\", \"%d\",\n\t    !!(wl == TAILQ_FIRST(&s->lastw)));\n\tformat_add(ft, \"window_linked\", \"%d\", session_is_linked(s, wl->window));\n\n\tfree(flags);\n}\n\n/* Set default format keys for a window pane. */\nvoid\nformat_defaults_pane(struct format_tree *ft, struct window_pane *wp)\n{\n\tstruct grid\t*gd = wp->base.grid;\n\tu_int\t\t idx;\n\tint  \t\t status, scroll_position;\n\n\tif (ft->w == NULL)\n\t\tft->w = wp->window;\n\tft->wp = wp;\n\n\tformat_add(ft, \"history_size\", \"%u\", gd->hsize);\n\tformat_add(ft, \"history_limit\", \"%u\", gd->hlimit);\n\tformat_add_cb(ft, \"history_bytes\", format_cb_history_bytes);\n\n\tif (window_pane_index(wp, &idx) != 0)\n\t\tfatalx(\"index not found\");\n\tformat_add(ft, \"pane_index\", \"%u\", idx);\n\n\tformat_add(ft, \"pane_width\", \"%u\", wp->sx);\n\tformat_add(ft, \"pane_height\", \"%u\", wp->sy);\n\tformat_add(ft, \"pane_title\", \"%s\", wp->base.title);\n\tformat_add(ft, \"pane_id\", \"%%%u\", wp->id);\n\tformat_add(ft, \"pane_active\", \"%d\", wp == wp->window->active);\n\tformat_add(ft, \"pane_input_off\", \"%d\", !!(wp->flags & PANE_INPUTOFF));\n\n\tstatus = wp->status;\n\tif (wp->fd == -1 && WIFEXITED(status))\n\t\tformat_add(ft, \"pane_dead_status\", \"%d\", WEXITSTATUS(status));\n\tformat_add(ft, \"pane_dead\", \"%d\", wp->fd == -1);\n\n\tif (window_pane_visible(wp)) {\n\t\tformat_add(ft, \"pane_left\", \"%u\", wp->xoff);\n\t\tformat_add(ft, \"pane_top\", \"%u\", wp->yoff);\n\t\tformat_add(ft, \"pane_right\", \"%u\", wp->xoff + wp->sx - 1);\n\t\tformat_add(ft, \"pane_bottom\", \"%u\", wp->yoff + wp->sy - 1);\n\t}\n\n\tformat_add(ft, \"pane_in_mode\", \"%d\", wp->screen != &wp->base);\n\tformat_add(ft, \"pane_synchronized\", \"%d\",\n\t    !!options_get_number(wp->window->options, \"synchronize-panes\"));\n\n\tformat_add(ft, \"pane_tty\", \"%s\", wp->tty);\n\tformat_add(ft, \"pane_pid\", \"%ld\", (long) wp->pid);\n\tformat_add_cb(ft, \"pane_start_command\", format_cb_start_command);\n\tformat_add_cb(ft, \"pane_current_command\", format_cb_current_command);\n\tformat_add_cb(ft, \"pane_current_path\", format_cb_current_path);\n\n\tformat_add(ft, \"cursor_x\", \"%u\", wp->base.cx);\n\tformat_add(ft, \"cursor_y\", \"%u\", wp->base.cy);\n\tformat_add(ft, \"scroll_region_upper\", \"%u\", wp->base.rupper);\n\tformat_add(ft, \"scroll_region_lower\", \"%u\", wp->base.rlower);\n\n\tscroll_position = window_copy_scroll_position(wp);\n\tif (scroll_position != -1)\n\t\tformat_add(ft, \"scroll_position\", \"%d\", scroll_position);\n\n\tformat_add(ft, \"alternate_on\", \"%d\", wp->saved_grid ? 1 : 0);\n\tformat_add(ft, \"alternate_saved_x\", \"%u\", wp->saved_cx);\n\tformat_add(ft, \"alternate_saved_y\", \"%u\", wp->saved_cy);\n\n\tformat_add(ft, \"cursor_flag\", \"%d\",\n\t    !!(wp->base.mode & MODE_CURSOR));\n\tformat_add(ft, \"insert_flag\", \"%d\",\n\t    !!(wp->base.mode & MODE_INSERT));\n\tformat_add(ft, \"keypad_cursor_flag\", \"%d\",\n\t    !!(wp->base.mode & MODE_KCURSOR));\n\tformat_add(ft, \"keypad_flag\", \"%d\",\n\t    !!(wp->base.mode & MODE_KKEYPAD));\n\tformat_add(ft, \"wrap_flag\", \"%d\",\n\t    !!(wp->base.mode & MODE_WRAP));\n\n\tformat_add(ft, \"mouse_any_flag\", \"%d\",\n\t    !!(wp->base.mode & (MODE_MOUSE_STANDARD|MODE_MOUSE_BUTTON)));\n\tformat_add(ft, \"mouse_standard_flag\", \"%d\",\n\t    !!(wp->base.mode & MODE_MOUSE_STANDARD));\n\tformat_add(ft, \"mouse_button_flag\", \"%d\",\n\t    !!(wp->base.mode & MODE_MOUSE_BUTTON));\n\n\tformat_add_cb(ft, \"pane_tabs\", format_cb_pane_tabs);\n}\n\n/* Set default format keys for paste buffer. */\nvoid\nformat_defaults_paste_buffer(struct format_tree *ft, struct paste_buffer *pb)\n{\n\tsize_t\t bufsize;\n\tchar\t*s;\n\n\tpaste_buffer_data(pb, &bufsize);\n\tformat_add(ft, \"buffer_size\", \"%zu\", bufsize);\n\tformat_add(ft, \"buffer_name\", \"%s\", paste_buffer_name(pb));\n\n\ts = paste_make_sample(pb);\n\tformat_add(ft, \"buffer_sample\", \"%s\", s);\n\tfree(s);\n}\n"
        },
        {
          "name": "grid-view.c",
          "type": "blob",
          "size": 4.7041015625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2008 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * Grid view functions. These work using coordinates relative to the visible\n * screen area.\n */\n\n#define grid_view_x(gd, x) (x)\n#define grid_view_y(gd, y) ((gd)->hsize + (y))\n\n/* Get cell. */\nvoid\ngrid_view_get_cell(struct grid *gd, u_int px, u_int py, struct grid_cell *gc)\n{\n\tgrid_get_cell(gd, grid_view_x(gd, px), grid_view_y(gd, py), gc);\n}\n\n/* Set cell. */\nvoid\ngrid_view_set_cell(struct grid *gd, u_int px, u_int py,\n    const struct grid_cell *gc)\n{\n\tgrid_set_cell(gd, grid_view_x(gd, px), grid_view_y(gd, py), gc);\n}\n\n/* Clear into history. */\nvoid\ngrid_view_clear_history(struct grid *gd)\n{\n\tstruct grid_line\t*gl;\n\tu_int\t\t\t yy, last;\n\n\t/* Find the last used line. */\n\tlast = 0;\n\tfor (yy = 0; yy < gd->sy; yy++) {\n\t\tgl = &gd->linedata[grid_view_y(gd, yy)];\n\t\tif (gl->cellsize != 0)\n\t\t\tlast = yy + 1;\n\t}\n\tif (last == 0)\n\t\treturn;\n\n\t/* Scroll the lines into the history. */\n\tfor (yy = 0; yy < last; yy++) {\n\t\tgrid_collect_history(gd);\n\t\tgrid_scroll_history(gd);\n\t}\n}\n\n/* Clear area. */\nvoid\ngrid_view_clear(struct grid *gd, u_int px, u_int py, u_int nx, u_int ny)\n{\n\tpx = grid_view_x(gd, px);\n\tpy = grid_view_y(gd, py);\n\n\tgrid_clear(gd, px, py, nx, ny);\n}\n\n/* Scroll region up. */\nvoid\ngrid_view_scroll_region_up(struct grid *gd, u_int rupper, u_int rlower)\n{\n\tif (gd->flags & GRID_HISTORY) {\n\t\tgrid_collect_history(gd);\n\t\tif (rupper == 0 && rlower == gd->sy - 1)\n\t\t\tgrid_scroll_history(gd);\n\t\telse {\n\t\t\trupper = grid_view_y(gd, rupper);\n\t\t\trlower = grid_view_y(gd, rlower);\n\t\t\tgrid_scroll_history_region(gd, rupper, rlower);\n\t\t}\n\t} else {\n\t\trupper = grid_view_y(gd, rupper);\n\t\trlower = grid_view_y(gd, rlower);\n\t\tgrid_move_lines(gd, rupper, rupper + 1, rlower - rupper);\n\t}\n}\n\n/* Scroll region down. */\nvoid\ngrid_view_scroll_region_down(struct grid *gd, u_int rupper, u_int rlower)\n{\n\trupper = grid_view_y(gd, rupper);\n\trlower = grid_view_y(gd, rlower);\n\n\tgrid_move_lines(gd, rupper + 1, rupper, rlower - rupper);\n}\n\n/* Insert lines. */\nvoid\ngrid_view_insert_lines(struct grid *gd, u_int py, u_int ny)\n{\n\tu_int\tsy;\n\n\tpy = grid_view_y(gd, py);\n\n\tsy = grid_view_y(gd, gd->sy);\n\n\tgrid_move_lines(gd, py + ny, py, sy - py - ny);\n}\n\n/* Insert lines in region. */\nvoid\ngrid_view_insert_lines_region(struct grid *gd, u_int rlower, u_int py,\n    u_int ny)\n{\n\tu_int\tny2;\n\n\trlower = grid_view_y(gd, rlower);\n\n\tpy = grid_view_y(gd, py);\n\n\tny2 = rlower + 1 - py - ny;\n\tgrid_move_lines(gd, rlower + 1 - ny2, py, ny2);\n\tgrid_clear(gd, 0, py + ny2, gd->sx, ny - ny2);\n}\n\n/* Delete lines. */\nvoid\ngrid_view_delete_lines(struct grid *gd, u_int py, u_int ny)\n{\n\tu_int\tsy;\n\n\tpy = grid_view_y(gd, py);\n\n\tsy = grid_view_y(gd, gd->sy);\n\n\tgrid_move_lines(gd, py, py + ny, sy - py - ny);\n\tgrid_clear(gd, 0, sy - ny, gd->sx, py + ny - (sy - ny));\n}\n\n/* Delete lines inside scroll region. */\nvoid\ngrid_view_delete_lines_region(struct grid *gd, u_int rlower, u_int py,\n    u_int ny)\n{\n\tu_int\tny2;\n\n\trlower = grid_view_y(gd, rlower);\n\n\tpy = grid_view_y(gd, py);\n\n\tny2 = rlower + 1 - py - ny;\n\tgrid_move_lines(gd, py, py + ny, ny2);\n\tgrid_clear(gd, 0, py + ny2, gd->sx, ny - ny2);\n}\n\n/* Insert characters. */\nvoid\ngrid_view_insert_cells(struct grid *gd, u_int px, u_int py, u_int nx)\n{\n\tu_int\tsx;\n\n\tpx = grid_view_x(gd, px);\n\tpy = grid_view_y(gd, py);\n\n\tsx = grid_view_x(gd, gd->sx);\n\n\tif (px == sx - 1)\n\t\tgrid_clear(gd, px, py, 1, 1);\n\telse\n\t\tgrid_move_cells(gd, px + nx, px, py, sx - px - nx);\n}\n\n/* Delete characters. */\nvoid\ngrid_view_delete_cells(struct grid *gd, u_int px, u_int py, u_int nx)\n{\n\tu_int\tsx;\n\n\tpx = grid_view_x(gd, px);\n\tpy = grid_view_y(gd, py);\n\n\tsx = grid_view_x(gd, gd->sx);\n\n\tgrid_move_cells(gd, px, px + nx, py, sx - px - nx);\n\tgrid_clear(gd, sx - nx, py, px + nx - (sx - nx), 1);\n}\n\n/* Convert cells into a string. */\nchar *\ngrid_view_string_cells(struct grid *gd, u_int px, u_int py, u_int nx)\n{\n\tpx = grid_view_x(gd, px);\n\tpy = grid_view_y(gd, py);\n\n\treturn (grid_string_cells(gd, px, py, nx, NULL, 0, 0, 0));\n}\n"
        },
        {
          "name": "grid.c",
          "type": "blob",
          "size": 20.2783203125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2008 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * Grid data. This is the basic data structure that represents what is shown on\n * screen.\n *\n * A grid is a grid of cells (struct grid_cell). Lines are not allocated until\n * cells in that line are written to. The grid is split into history and\n * viewable data with the history starting at row (line) 0 and extending to\n * (hsize - 1); from hsize to hsize + (sy - 1) is the viewable data. All\n * functions in this file work on absolute coordinates, grid-view.c has\n * functions which work on the screen data.\n */\n\n/* Default grid cell data. */\nconst struct grid_cell grid_default_cell = {\n\t0, 0, { .fg = 8 }, { .bg = 8 }, { { ' ' }, 0, 1, 1 }\n};\nconst struct grid_cell_entry grid_default_entry = {\n\t0, { .data = { 0, 8, 8, ' ' } }\n};\n\nint\tgrid_check_y(struct grid *, u_int);\n\nvoid\tgrid_reflow_copy(struct grid_line *, u_int, struct grid_line *l,\n\t    u_int, u_int);\nvoid\tgrid_reflow_join(struct grid *, u_int *, struct grid_line *, u_int);\nvoid\tgrid_reflow_split(struct grid *, u_int *, struct grid_line *, u_int,\n\t    u_int);\nvoid\tgrid_reflow_move(struct grid *, u_int *, struct grid_line *);\nsize_t\tgrid_string_cells_fg(const struct grid_cell *, int *);\nsize_t\tgrid_string_cells_bg(const struct grid_cell *, int *);\nvoid\tgrid_string_cells_code(const struct grid_cell *,\n\t    const struct grid_cell *, char *, size_t, int);\n\n/* Copy default into a cell. */\nstatic void\ngrid_clear_cell(struct grid *gd, u_int px, u_int py)\n{\n\tgd->linedata[py].celldata[px] = grid_default_entry;\n}\n\n/* Check grid y position. */\nint\ngrid_check_y(struct grid *gd, u_int py)\n{\n\tif ((py) >= (gd)->hsize + (gd)->sy) {\n\t\tlog_debug(\"y out of range: %u\", py);\n\t\treturn (-1);\n\t}\n\treturn (0);\n}\n\n/* Create a new grid. */\nstruct grid *\ngrid_create(u_int sx, u_int sy, u_int hlimit)\n{\n\tstruct grid\t*gd;\n\n\tgd = xmalloc(sizeof *gd);\n\tgd->sx = sx;\n\tgd->sy = sy;\n\n\tgd->flags = GRID_HISTORY;\n\n\tgd->hsize = 0;\n\tgd->hlimit = hlimit;\n\n\tgd->linedata = xcalloc(gd->sy, sizeof *gd->linedata);\n\n\treturn (gd);\n}\n\n/* Destroy grid. */\nvoid\ngrid_destroy(struct grid *gd)\n{\n\tstruct grid_line\t*gl;\n\tu_int\t\t\t yy;\n\n\tfor (yy = 0; yy < gd->hsize + gd->sy; yy++) {\n\t\tgl = &gd->linedata[yy];\n\t\tfree(gl->celldata);\n\t\tfree(gl->extddata);\n\t}\n\n\tfree(gd->linedata);\n\n\tfree(gd);\n}\n\n/* Compare grids. */\nint\ngrid_compare(struct grid *ga, struct grid *gb)\n{\n\tstruct grid_line\t*gla, *glb;\n\tstruct grid_cell\t gca, gcb;\n\tu_int\t\t\t xx, yy;\n\n\tif (ga->sx != gb->sx || ga->sy != gb->sy)\n\t\treturn (1);\n\n\tfor (yy = 0; yy < ga->sy; yy++) {\n\t\tgla = &ga->linedata[yy];\n\t\tglb = &gb->linedata[yy];\n\t\tif (gla->cellsize != glb->cellsize)\n\t\t\treturn (1);\n\t\tfor (xx = 0; xx < gla->cellsize; xx++) {\n\t\t\tgrid_get_cell(ga, xx, yy, &gca);\n\t\t\tgrid_get_cell(gb, xx, yy, &gcb);\n\t\t\tif (memcmp(&gca, &gcb, sizeof (struct grid_cell)) != 0)\n\t\t\t\treturn (1);\n\t\t}\n\t}\n\n\treturn (0);\n}\n\n/*\n * Collect lines from the history if at the limit. Free the top (oldest) 10%\n * and shift up.\n */\nvoid\ngrid_collect_history(struct grid *gd)\n{\n\tu_int\tyy;\n\n\tif (gd->hsize < gd->hlimit)\n\t\treturn;\n\n\tyy = gd->hlimit / 10;\n\tif (yy < 1)\n\t\tyy = 1;\n\n\tgrid_move_lines(gd, 0, yy, gd->hsize + gd->sy - yy);\n\tgd->hsize -= yy;\n}\n\n/*\n * Scroll the entire visible screen, moving one line into the history. Just\n * allocate a new line at the bottom and move the history size indicator.\n */\nvoid\ngrid_scroll_history(struct grid *gd)\n{\n\tu_int\tyy;\n\n\tyy = gd->hsize + gd->sy;\n\tgd->linedata = xreallocarray(gd->linedata, yy + 1,\n\t    sizeof *gd->linedata);\n\tmemset(&gd->linedata[yy], 0, sizeof gd->linedata[yy]);\n\n\tgd->hsize++;\n}\n\n/* Clear the history. */\nvoid\ngrid_clear_history(struct grid *gd)\n{\n\tgrid_clear_lines(gd, 0, gd->hsize);\n\tgrid_move_lines(gd, 0, gd->hsize, gd->sy);\n\n\tgd->hsize = 0;\n\tgd->linedata = xreallocarray(gd->linedata, gd->sy,\n\t    sizeof *gd->linedata);\n}\n\n/* Scroll a region up, moving the top line into the history. */\nvoid\ngrid_scroll_history_region(struct grid *gd, u_int upper, u_int lower)\n{\n\tstruct grid_line\t*gl_history, *gl_upper, *gl_lower;\n\tu_int\t\t\t yy;\n\n\t/* Create a space for a new line. */\n\tyy = gd->hsize + gd->sy;\n\tgd->linedata = xreallocarray(gd->linedata, yy + 1,\n\t    sizeof *gd->linedata);\n\n\t/* Move the entire screen down to free a space for this line. */\n\tgl_history = &gd->linedata[gd->hsize];\n\tmemmove(gl_history + 1, gl_history, gd->sy * sizeof *gl_history);\n\n\t/* Adjust the region and find its start and end. */\n\tupper++;\n\tgl_upper = &gd->linedata[upper];\n\tlower++;\n\tgl_lower = &gd->linedata[lower];\n\n\t/* Move the line into the history. */\n\tmemcpy(gl_history, gl_upper, sizeof *gl_history);\n\n\t/* Then move the region up and clear the bottom line. */\n\tmemmove(gl_upper, gl_upper + 1, (lower - upper) * sizeof *gl_upper);\n\tmemset(gl_lower, 0, sizeof *gl_lower);\n\n\t/* Move the history offset down over the line. */\n\tgd->hsize++;\n}\n\n/* Expand line to fit to cell. */\nvoid\ngrid_expand_line(struct grid *gd, u_int py, u_int sx)\n{\n\tstruct grid_line\t*gl;\n\tu_int\t\t\t xx;\n\n\tgl = &gd->linedata[py];\n\tif (sx <= gl->cellsize)\n\t\treturn;\n\n\tgl->celldata = xreallocarray(gl->celldata, sx, sizeof *gl->celldata);\n\tfor (xx = gl->cellsize; xx < sx; xx++)\n\t\tgrid_clear_cell(gd, xx, py);\n\tgl->cellsize = sx;\n}\n\n/* Peek at grid line. */\nconst struct grid_line *\ngrid_peek_line(struct grid *gd, u_int py)\n{\n\tif (grid_check_y(gd, py) != 0)\n\t\treturn (NULL);\n\treturn (&gd->linedata[py]);\n}\n\n/* Get cell for reading. */\nvoid\ngrid_get_cell(struct grid *gd, u_int px, u_int py, struct grid_cell *gc)\n{\n\tstruct grid_line\t*gl;\n\tstruct grid_cell_entry\t*gce;\n\n\tif (grid_check_y(gd, py) != 0 || px >= gd->linedata[py].cellsize) {\n\t\tmemcpy(gc, &grid_default_cell, sizeof *gc);\n\t\treturn;\n\t}\n\n\tgl = &gd->linedata[py];\n\tgce = &gl->celldata[px];\n\n\tif (gce->flags & GRID_FLAG_EXTENDED) {\n\t\tif (gce->offset >= gl->extdsize)\n\t\t\tmemcpy(gc, &grid_default_cell, sizeof *gc);\n\t\telse\n\t\t\tmemcpy(gc, &gl->extddata[gce->offset], sizeof *gc);\n\t\treturn;\n\t}\n\n\tgc->flags = gce->flags & ~GRID_FLAG_EXTENDED;\n\tgc->attr = gce->data.attr;\n\tgc->fg = gce->data.fg;\n\tgc->bg = gce->data.bg;\n\tutf8_set(&gc->data, gce->data.data);\n}\n\n/* Set cell at relative position. */\nvoid\ngrid_set_cell(struct grid *gd, u_int px, u_int py, const struct grid_cell *gc)\n{\n\tstruct grid_line\t*gl;\n\tstruct grid_cell_entry\t*gce;\n\tstruct grid_cell \t*gcp;\n\tint\t\t\t extended;\n\n\tif (grid_check_y(gd, py) != 0)\n\t\treturn;\n\n\tgrid_expand_line(gd, py, px + 1);\n\n\tgl = &gd->linedata[py];\n\tgce = &gl->celldata[px];\n\n\textended = (gce->flags & GRID_FLAG_EXTENDED);\n\tif (!extended && (gc->data.size != 1 || gc->data.width != 1))\n\t\textended = 1;\n\tif (!extended && (gc->flags & (GRID_FLAG_FGRGB|GRID_FLAG_BGRGB)))\n\t\textended = 1;\n\tif (extended) {\n\t\tif (~gce->flags & GRID_FLAG_EXTENDED) {\n\t\t\tgl->extddata = xreallocarray(gl->extddata,\n\t\t\t    gl->extdsize + 1, sizeof *gl->extddata);\n\t\t\tgce->offset = gl->extdsize++;\n\t\t\tgce->flags = gc->flags | GRID_FLAG_EXTENDED;\n\t\t}\n\n\t\tif (gce->offset >= gl->extdsize)\n\t\t\tfatalx(\"offset too big\");\n\t\tgcp = &gl->extddata[gce->offset];\n\t\tmemcpy(gcp, gc, sizeof *gcp);\n\t\treturn;\n\t}\n\n\tgce->flags = gc->flags & ~GRID_FLAG_EXTENDED;\n\tgce->data.attr = gc->attr;\n\tgce->data.fg = gc->fg;\n\tgce->data.bg = gc->bg;\n\tgce->data.data = gc->data.data[0];\n}\n\n/* Clear area. */\nvoid\ngrid_clear(struct grid *gd, u_int px, u_int py, u_int nx, u_int ny)\n{\n\tu_int\txx, yy;\n\n\tif (nx == 0 || ny == 0)\n\t\treturn;\n\n\tif (px == 0 && nx == gd->sx) {\n\t\tgrid_clear_lines(gd, py, ny);\n\t\treturn;\n\t}\n\n\tif (grid_check_y(gd, py) != 0)\n\t\treturn;\n\tif (grid_check_y(gd, py + ny - 1) != 0)\n\t\treturn;\n\n\tfor (yy = py; yy < py + ny; yy++) {\n\t\tif (px >= gd->linedata[yy].cellsize)\n\t\t\tcontinue;\n\t\tif (px + nx >= gd->linedata[yy].cellsize) {\n\t\t\tgd->linedata[yy].cellsize = px;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (xx = px; xx < px + nx; xx++) {\n\t\t\tif (xx >= gd->linedata[yy].cellsize)\n\t\t\t\tbreak;\n\t\t\tgrid_clear_cell(gd, xx, yy);\n\t\t}\n\t}\n}\n\n/* Clear lines. This just frees and truncates the lines. */\nvoid\ngrid_clear_lines(struct grid *gd, u_int py, u_int ny)\n{\n\tstruct grid_line\t*gl;\n\tu_int\t\t\t yy;\n\n\tif (ny == 0)\n\t\treturn;\n\n\tif (grid_check_y(gd, py) != 0)\n\t\treturn;\n\tif (grid_check_y(gd, py + ny - 1) != 0)\n\t\treturn;\n\n\tfor (yy = py; yy < py + ny; yy++) {\n\t\tgl = &gd->linedata[yy];\n\t\tfree(gl->celldata);\n\t\tfree(gl->extddata);\n\t\tmemset(gl, 0, sizeof *gl);\n\t}\n}\n\n/* Move a group of lines. */\nvoid\ngrid_move_lines(struct grid *gd, u_int dy, u_int py, u_int ny)\n{\n\tu_int\tyy;\n\n\tif (ny == 0 || py == dy)\n\t\treturn;\n\n\tif (grid_check_y(gd, py) != 0)\n\t\treturn;\n\tif (grid_check_y(gd, py + ny - 1) != 0)\n\t\treturn;\n\tif (grid_check_y(gd, dy) != 0)\n\t\treturn;\n\tif (grid_check_y(gd, dy + ny - 1) != 0)\n\t\treturn;\n\n\t/* Free any lines which are being replaced. */\n\tfor (yy = dy; yy < dy + ny; yy++) {\n\t\tif (yy >= py && yy < py + ny)\n\t\t\tcontinue;\n\t\tgrid_clear_lines(gd, yy, 1);\n\t}\n\n\tmemmove(&gd->linedata[dy], &gd->linedata[py],\n\t    ny * (sizeof *gd->linedata));\n\n\t/* Wipe any lines that have been moved (without freeing them). */\n\tfor (yy = py; yy < py + ny; yy++) {\n\t\tif (yy >= dy && yy < dy + ny)\n\t\t\tcontinue;\n\t\tmemset(&gd->linedata[yy], 0, sizeof gd->linedata[yy]);\n\t}\n}\n\n/* Move a group of cells. */\nvoid\ngrid_move_cells(struct grid *gd, u_int dx, u_int px, u_int py, u_int nx)\n{\n\tstruct grid_line\t*gl;\n\tu_int\t\t\t xx;\n\n\tif (nx == 0 || px == dx)\n\t\treturn;\n\n\tif (grid_check_y(gd, py) != 0)\n\t\treturn;\n\tgl = &gd->linedata[py];\n\n\tgrid_expand_line(gd, py, px + nx);\n\tgrid_expand_line(gd, py, dx + nx);\n\tmemmove(&gl->celldata[dx], &gl->celldata[px],\n\t    nx * sizeof *gl->celldata);\n\n\t/* Wipe any cells that have been moved. */\n\tfor (xx = px; xx < px + nx; xx++) {\n\t\tif (xx >= dx && xx < dx + nx)\n\t\t\tcontinue;\n\t\tgrid_clear_cell(gd, xx, py);\n\t}\n}\n\n/* Get ANSI foreground sequence. */\nsize_t\ngrid_string_cells_fg(const struct grid_cell *gc, int *values)\n{\n\tsize_t\tn;\n\n\tn = 0;\n\tif (gc->flags & GRID_FLAG_FG256) {\n\t\tvalues[n++] = 38;\n\t\tvalues[n++] = 5;\n\t\tvalues[n++] = gc->fg;\n\t} else if (gc->flags & GRID_FLAG_FGRGB) {\n\t\tvalues[n++] = 38;\n\t\tvalues[n++] = 2;\n\t\tvalues[n++] = gc->fg_rgb.r;\n\t\tvalues[n++] = gc->fg_rgb.g;\n\t\tvalues[n++] = gc->fg_rgb.b;\n\t} else {\n\t\tswitch (gc->fg) {\n\t\tcase 0:\n\t\tcase 1:\n\t\tcase 2:\n\t\tcase 3:\n\t\tcase 4:\n\t\tcase 5:\n\t\tcase 6:\n\t\tcase 7:\n\t\t\tvalues[n++] = gc->fg + 30;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tvalues[n++] = 39;\n\t\t\tbreak;\n\t\tcase 90:\n\t\tcase 91:\n\t\tcase 92:\n\t\tcase 93:\n\t\tcase 94:\n\t\tcase 95:\n\t\tcase 96:\n\t\tcase 97:\n\t\t\tvalues[n++] = gc->fg;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (n);\n}\n\n/* Get ANSI background sequence. */\nsize_t\ngrid_string_cells_bg(const struct grid_cell *gc, int *values)\n{\n\tsize_t\tn;\n\n\tn = 0;\n\tif (gc->flags & GRID_FLAG_BG256) {\n\t\tvalues[n++] = 48;\n\t\tvalues[n++] = 5;\n\t\tvalues[n++] = gc->bg;\n\t} else if (gc->flags & GRID_FLAG_BGRGB) {\n\t\tvalues[n++] = 48;\n\t\tvalues[n++] = 2;\n\t\tvalues[n++] = gc->bg_rgb.r;\n\t\tvalues[n++] = gc->bg_rgb.g;\n\t\tvalues[n++] = gc->bg_rgb.b;\n\t} else {\n\t\tswitch (gc->bg) {\n\t\tcase 0:\n\t\tcase 1:\n\t\tcase 2:\n\t\tcase 3:\n\t\tcase 4:\n\t\tcase 5:\n\t\tcase 6:\n\t\tcase 7:\n\t\t\tvalues[n++] = gc->bg + 40;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tvalues[n++] = 49;\n\t\t\tbreak;\n\t\tcase 100:\n\t\tcase 101:\n\t\tcase 102:\n\t\tcase 103:\n\t\tcase 104:\n\t\t\tcase 105:\n\t\tcase 106:\n\t\tcase 107:\n\t\t\tvalues[n++] = gc->bg - 10;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (n);\n}\n\n/*\n * Returns ANSI code to set particular attributes (colour, bold and so on)\n * given a current state. The output buffer must be able to hold at least 57\n * bytes.\n */\nvoid\ngrid_string_cells_code(const struct grid_cell *lastgc,\n    const struct grid_cell *gc, char *buf, size_t len, int escape_c0)\n{\n\tint\toldc[64], newc[64], s[128];\n\tsize_t\tnoldc, nnewc, n, i;\n\tu_int\tattr = gc->attr;\n\tu_int\tlastattr = lastgc->attr;\n\tchar\ttmp[64];\n\n\tstruct {\n\t\tu_int\tmask;\n\t\tu_int\tcode;\n\t} attrs[] = {\n\t\t{ GRID_ATTR_BRIGHT, 1 },\n\t\t{ GRID_ATTR_DIM, 2 },\n\t\t{ GRID_ATTR_ITALICS, 3 },\n\t\t{ GRID_ATTR_UNDERSCORE, 4 },\n\t\t{ GRID_ATTR_BLINK, 5 },\n\t\t{ GRID_ATTR_REVERSE, 7 },\n\t\t{ GRID_ATTR_HIDDEN, 8 }\n\t};\n\tn = 0;\n\n\t/* If any attribute is removed, begin with 0. */\n\tfor (i = 0; i < nitems(attrs); i++) {\n\t\tif (!(attr & attrs[i].mask) && (lastattr & attrs[i].mask)) {\n\t\t\ts[n++] = 0;\n\t\t\tlastattr &= GRID_ATTR_CHARSET;\n\t\t\tbreak;\n\t\t}\n\t}\n\t/* For each attribute that is newly set, add its code. */\n\tfor (i = 0; i < nitems(attrs); i++) {\n\t\tif ((attr & attrs[i].mask) && !(lastattr & attrs[i].mask))\n\t\t\ts[n++] = attrs[i].code;\n\t}\n\n\t/* If the foreground colour changed, append its parameters. */\n\tnnewc = grid_string_cells_fg(gc, newc);\n\tnoldc = grid_string_cells_fg(lastgc, oldc);\n\tif (nnewc != noldc || memcmp(newc, oldc, nnewc * sizeof newc[0]) != 0) {\n\t\tfor (i = 0; i < nnewc; i++)\n\t\t\ts[n++] = newc[i];\n\t}\n\n\t/* If the background colour changed, append its parameters. */\n\tnnewc = grid_string_cells_bg(gc, newc);\n\tnoldc = grid_string_cells_bg(lastgc, oldc);\n\tif (nnewc != noldc || memcmp(newc, oldc, nnewc * sizeof newc[0]) != 0) {\n\t\tfor (i = 0; i < nnewc; i++)\n\t\t\ts[n++] = newc[i];\n\t}\n\n\t/* If there are any parameters, append an SGR code. */\n\t*buf = '\\0';\n\tif (n > 0) {\n\t\tif (escape_c0)\n\t\t\tstrlcat(buf, \"\\\\033[\", len);\n\t\telse\n\t\t\tstrlcat(buf, \"\\033[\", len);\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tif (i + 1 < n)\n\t\t\t\txsnprintf(tmp, sizeof tmp, \"%d;\", s[i]);\n\t\t\telse\n\t\t\t\txsnprintf(tmp, sizeof tmp, \"%d\", s[i]);\n\t\t\tstrlcat(buf, tmp, len);\n\t\t}\n\t\tstrlcat(buf, \"m\", len);\n\t}\n\n\t/* Append shift in/shift out if needed. */\n\tif ((attr & GRID_ATTR_CHARSET) && !(lastattr & GRID_ATTR_CHARSET)) {\n\t\tif (escape_c0)\n\t\t\tstrlcat(buf, \"\\\\016\", len);  /* SO */\n\t\telse\n\t\t\tstrlcat(buf, \"\\016\", len);  /* SO */\n\t}\n\tif (!(attr & GRID_ATTR_CHARSET) && (lastattr & GRID_ATTR_CHARSET)) {\n\t\tif (escape_c0)\n\t\t\tstrlcat(buf, \"\\\\017\", len);  /* SI */\n\t\telse\n\t\t\tstrlcat(buf, \"\\017\", len);  /* SI */\n\t}\n}\n\n/* Convert cells into a string. */\nchar *\ngrid_string_cells(struct grid *gd, u_int px, u_int py, u_int nx,\n    struct grid_cell **lastgc, int with_codes, int escape_c0, int trim)\n{\n\tstruct grid_cell\t gc;\n\tstatic struct grid_cell\t lastgc1;\n\tconst char\t\t*data;\n\tchar\t\t\t*buf, code[128];\n\tsize_t\t\t\t len, off, size, codelen;\n\tu_int\t\t\t xx;\n\tconst struct grid_line\t*gl;\n\n\tif (lastgc != NULL && *lastgc == NULL) {\n\t\tmemcpy(&lastgc1, &grid_default_cell, sizeof lastgc1);\n\t\t*lastgc = &lastgc1;\n\t}\n\n\tlen = 128;\n\tbuf = xmalloc(len);\n\toff = 0;\n\n\tgl = grid_peek_line(gd, py);\n\tfor (xx = px; xx < px + nx; xx++) {\n\t\tif (gl == NULL || xx >= gl->cellsize)\n\t\t\tbreak;\n\t\tgrid_get_cell(gd, xx, py, &gc);\n\t\tif (gc.flags & GRID_FLAG_PADDING)\n\t\t\tcontinue;\n\n\t\tif (with_codes) {\n\t\t\tgrid_string_cells_code(*lastgc, &gc, code, sizeof code,\n\t\t\t    escape_c0);\n\t\t\tcodelen = strlen(code);\n\t\t\tmemcpy(*lastgc, &gc, sizeof **lastgc);\n\t\t} else\n\t\t\tcodelen = 0;\n\n\t\tdata = gc.data.data;\n\t\tsize = gc.data.size;\n\t\tif (escape_c0 && size == 1 && *data == '\\\\') {\n\t\t\tdata = \"\\\\\\\\\";\n\t\t\tsize = 2;\n\t\t}\n\n\t\twhile (len < off + size + codelen + 1) {\n\t\t\tbuf = xreallocarray(buf, 2, len);\n\t\t\tlen *= 2;\n\t\t}\n\n\t\tif (codelen != 0) {\n\t\t\tmemcpy(buf + off, code, codelen);\n\t\t\toff += codelen;\n\t\t}\n\t\tmemcpy(buf + off, data, size);\n\t\toff += size;\n\t}\n\n\tif (trim) {\n\t\twhile (off > 0 && buf[off - 1] == ' ')\n\t\t\toff--;\n\t}\n\tbuf[off] = '\\0';\n\n\treturn (buf);\n}\n\n/*\n * Duplicate a set of lines between two grids. If there aren't enough lines in\n * either source or destination, the number of lines is limited to the number\n * available.\n */\nvoid\ngrid_duplicate_lines(struct grid *dst, u_int dy, struct grid *src, u_int sy,\n    u_int ny)\n{\n\tstruct grid_line\t*dstl, *srcl;\n\tu_int\t\t\t yy;\n\n\tif (dy + ny > dst->hsize + dst->sy)\n\t\tny = dst->hsize + dst->sy - dy;\n\tif (sy + ny > src->hsize + src->sy)\n\t\tny = src->hsize + src->sy - sy;\n\tgrid_clear_lines(dst, dy, ny);\n\n\tfor (yy = 0; yy < ny; yy++) {\n\t\tsrcl = &src->linedata[sy];\n\t\tdstl = &dst->linedata[dy];\n\n\t\tmemcpy(dstl, srcl, sizeof *dstl);\n\t\tif (srcl->cellsize != 0) {\n\t\t\tdstl->celldata = xreallocarray(NULL,\n\t\t\t    srcl->cellsize, sizeof *dstl->celldata);\n\t\t\tmemcpy(dstl->celldata, srcl->celldata,\n\t\t\t    srcl->cellsize * sizeof *dstl->celldata);\n\t\t} else\n\t\t\tdstl->celldata = NULL;\n\n\t\tif (srcl->extdsize != 0) {\n\t\t\tdstl->extdsize = srcl->extdsize;\n\t\t\tdstl->extddata = xreallocarray(NULL, dstl->extdsize,\n\t\t\t    sizeof *dstl->extddata);\n\t\t\tmemcpy(dstl->extddata, srcl->extddata, dstl->extdsize *\n\t\t\t    sizeof *dstl->extddata);\n\t\t}\n\n\t\tsy++;\n\t\tdy++;\n\t}\n}\n\n/* Copy a section of a line. */\nvoid\ngrid_reflow_copy(struct grid_line *dst_gl, u_int to, struct grid_line *src_gl,\n    u_int from, u_int to_copy)\n{\n\tstruct grid_cell_entry\t*gce;\n\tu_int\t\t\t i, was;\n\n\tmemcpy(&dst_gl->celldata[to], &src_gl->celldata[from],\n\t    to_copy * sizeof *dst_gl->celldata);\n\n\tfor (i = to; i < to + to_copy; i++) {\n\t\tgce = &dst_gl->celldata[i];\n\t\tif (~gce->flags & GRID_FLAG_EXTENDED)\n\t\t\tcontinue;\n\t\twas = gce->offset;\n\n\t\tdst_gl->extddata = xreallocarray(dst_gl->extddata,\n\t\t    dst_gl->extdsize + 1, sizeof *dst_gl->extddata);\n\t\tgce->offset = dst_gl->extdsize++;\n\t\tmemcpy(&dst_gl->extddata[gce->offset], &src_gl->extddata[was],\n\t\t    sizeof *dst_gl->extddata);\n\t}\n}\n\n/* Join line data. */\nvoid\ngrid_reflow_join(struct grid *dst, u_int *py, struct grid_line *src_gl,\n    u_int new_x)\n{\n\tstruct grid_line\t*dst_gl = &dst->linedata[(*py) - 1];\n\tu_int\t\t\t left, to_copy, ox, nx;\n\n\t/* How much is left on the old line? */\n\tleft = new_x - dst_gl->cellsize;\n\n\t/* Work out how much to append. */\n\tto_copy = src_gl->cellsize;\n\tif (to_copy > left)\n\t\tto_copy = left;\n\tox = dst_gl->cellsize;\n\tnx = ox + to_copy;\n\n\t/* Resize the destination line. */\n\tdst_gl->celldata = xreallocarray(dst_gl->celldata, nx,\n\t    sizeof *dst_gl->celldata);\n\tdst_gl->cellsize = nx;\n\n\t/* Append as much as possible. */\n\tgrid_reflow_copy(dst_gl, ox, src_gl, 0, to_copy);\n\n\t/* If there is any left in the source, split it. */\n\tif (src_gl->cellsize > to_copy) {\n\t\tdst_gl->flags |= GRID_LINE_WRAPPED;\n\n\t\tsrc_gl->cellsize -= to_copy;\n\t\tgrid_reflow_split(dst, py, src_gl, new_x, to_copy);\n\t}\n}\n\n/* Split line data. */\nvoid\ngrid_reflow_split(struct grid *dst, u_int *py, struct grid_line *src_gl,\n    u_int new_x, u_int offset)\n{\n\tstruct grid_line\t*dst_gl = NULL;\n\tu_int\t\t\t to_copy;\n\n\t/* Loop and copy sections of the source line. */\n\twhile (src_gl->cellsize > 0) {\n\t\t/* Create new line. */\n\t\tif (*py >= dst->hsize + dst->sy)\n\t\t\tgrid_scroll_history(dst);\n\t\tdst_gl = &dst->linedata[*py];\n\t\t(*py)++;\n\n\t\t/* How much should we copy? */\n\t\tto_copy = new_x;\n\t\tif (to_copy > src_gl->cellsize)\n\t\t\tto_copy = src_gl->cellsize;\n\n\t\t/* Expand destination line. */\n\t\tdst_gl->celldata = xreallocarray(NULL, to_copy,\n\t\t    sizeof *dst_gl->celldata);\n\t\tdst_gl->cellsize = to_copy;\n\t\tdst_gl->flags |= GRID_LINE_WRAPPED;\n\n\t\t/* Copy the data. */\n\t\tgrid_reflow_copy(dst_gl, 0, src_gl, offset, to_copy);\n\n\t\t/* Move offset and reduce old line size. */\n\t\toffset += to_copy;\n\t\tsrc_gl->cellsize -= to_copy;\n\t}\n\n\t/* Last line is not wrapped. */\n\tif (dst_gl != NULL)\n\t\tdst_gl->flags &= ~GRID_LINE_WRAPPED;\n}\n\n/* Move line data. */\nvoid\ngrid_reflow_move(struct grid *dst, u_int *py, struct grid_line *src_gl)\n{\n\tstruct grid_line\t*dst_gl;\n\n\t/* Create new line. */\n\tif (*py >= dst->hsize + dst->sy)\n\t\tgrid_scroll_history(dst);\n\tdst_gl = &dst->linedata[*py];\n\t(*py)++;\n\n\t/* Copy the old line. */\n\tmemcpy(dst_gl, src_gl, sizeof *dst_gl);\n\tdst_gl->flags &= ~GRID_LINE_WRAPPED;\n\n\t/* Clear old line. */\n\tsrc_gl->celldata = NULL;\n\tsrc_gl->extddata = NULL;\n}\n\n/*\n * Reflow lines from src grid into dst grid of width new_x. Returns number of\n * lines fewer in the visible area. The source grid is destroyed.\n */\nu_int\ngrid_reflow(struct grid *dst, struct grid *src, u_int new_x)\n{\n\tu_int\t\t\t py, sy, line;\n\tint\t\t\t previous_wrapped;\n\tstruct grid_line\t*src_gl;\n\n\tpy = 0;\n\tsy = src->sy;\n\n\tprevious_wrapped = 0;\n\tfor (line = 0; line < sy + src->hsize; line++) {\n\t\tsrc_gl = src->linedata + line;\n\t\tif (!previous_wrapped) {\n\t\t\t/* Wasn't wrapped. If smaller, move to destination. */\n\t\t\tif (src_gl->cellsize <= new_x)\n\t\t\t\tgrid_reflow_move(dst, &py, src_gl);\n\t\t\telse\n\t\t\t\tgrid_reflow_split(dst, &py, src_gl, new_x, 0);\n\t\t} else {\n\t\t\t/* Previous was wrapped. Try to join. */\n\t\t\tgrid_reflow_join(dst, &py, src_gl, new_x);\n\t\t}\n\t\tprevious_wrapped = (src_gl->flags & GRID_LINE_WRAPPED);\n\t}\n\n\tgrid_destroy(src);\n\n\tif (py > sy)\n\t\treturn (0);\n\treturn (sy - py);\n}\n"
        },
        {
          "name": "hooks.c",
          "type": "blob",
          "size": 4.7685546875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2012 Thomas Adam <thomas@xteddy.org>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\nstruct hooks {\n\tRB_HEAD(hooks_tree, hook) tree;\n\tstruct hooks\t*parent;\n};\n\nstatic int\thooks_cmp(struct hook *, struct hook *);\nRB_PROTOTYPE(hooks_tree, hook, entry, hooks_cmp);\nRB_GENERATE(hooks_tree, hook, entry, hooks_cmp);\n\nstatic struct hook\t*hooks_find1(struct hooks *, const char *);\nstatic void\t\t hooks_free1(struct hooks *, struct hook *);\nstatic void\t\t hooks_emptyfn(struct cmd_q *);\n\nstatic int\nhooks_cmp(struct hook *hook1, struct hook *hook2)\n{\n\treturn (strcmp(hook1->name, hook2->name));\n}\n\nstruct hooks *\nhooks_get(struct session *s)\n{\n\tif (s != NULL)\n\t\treturn (s->hooks);\n\treturn (global_hooks);\n}\n\nstruct hooks *\nhooks_create(struct hooks *parent)\n{\n\tstruct hooks\t*hooks;\n\n\thooks = xcalloc(1, sizeof *hooks);\n\tRB_INIT(&hooks->tree);\n\thooks->parent = parent;\n\treturn (hooks);\n}\n\nstatic void\nhooks_free1(struct hooks *hooks, struct hook *hook)\n{\n\tRB_REMOVE(hooks_tree, &hooks->tree, hook);\n\tcmd_list_free(hook->cmdlist);\n\tfree((char *)hook->name);\n\tfree(hook);\n}\n\nvoid\nhooks_free(struct hooks *hooks)\n{\n\tstruct hook\t*hook, *hook1;\n\n\tRB_FOREACH_SAFE(hook, hooks_tree, &hooks->tree, hook1)\n\t\thooks_free1(hooks, hook);\n\tfree(hooks);\n}\n\nstruct hook *\nhooks_first(struct hooks *hooks)\n{\n\treturn (RB_MIN(hooks_tree, &hooks->tree));\n}\n\nstruct hook *\nhooks_next(struct hook *hook)\n{\n\treturn (RB_NEXT(hooks_tree, &hooks->tree, hook));\n}\n\nvoid\nhooks_add(struct hooks *hooks, const char *name, struct cmd_list *cmdlist)\n{\n\tstruct hook\t*hook;\n\n\tif ((hook = hooks_find1(hooks, name)) != NULL)\n\t\thooks_free1(hooks, hook);\n\n\thook = xcalloc(1, sizeof *hook);\n\thook->name = xstrdup(name);\n\thook->cmdlist = cmdlist;\n\thook->cmdlist->references++;\n\tRB_INSERT(hooks_tree, &hooks->tree, hook);\n}\n\nvoid\nhooks_remove(struct hooks *hooks, const char *name)\n{\n\tstruct hook\t*hook;\n\n\tif ((hook = hooks_find1(hooks, name)) != NULL)\n\t\thooks_free1(hooks, hook);\n}\n\nstatic struct hook *\nhooks_find1(struct hooks *hooks, const char *name)\n{\n\tstruct hook\thook;\n\n\thook.name = name;\n\treturn (RB_FIND(hooks_tree, &hooks->tree, &hook));\n}\n\nstruct hook *\nhooks_find(struct hooks *hooks, const char *name)\n{\n\tstruct hook\t hook0, *hook;\n\n\thook0.name = name;\n\thook = RB_FIND(hooks_tree, &hooks->tree, &hook0);\n\twhile (hook == NULL) {\n\t\thooks = hooks->parent;\n\t\tif (hooks == NULL)\n\t\t\tbreak;\n\t\thook = RB_FIND(hooks_tree, &hooks->tree, &hook0);\n\t}\n\treturn (hook);\n}\n\nstatic void\nhooks_emptyfn(struct cmd_q *hooks_cmdq)\n{\n\tstruct cmd_q\t*cmdq = hooks_cmdq->data;\n\n\tif (cmdq != NULL) {\n\t\tif (hooks_cmdq->client_exit >= 0)\n\t\t\tcmdq->client_exit = hooks_cmdq->client_exit;\n\t\tif (!cmdq_free(cmdq))\n\t\t\tcmdq_continue(cmdq);\n\t}\n\tcmdq_free(hooks_cmdq);\n}\n\nint\nhooks_run(struct hooks *hooks, struct client *c, struct cmd_find_state *fs,\n    const char *fmt, ...)\n{\n\tstruct hook\t*hook;\n\tstruct cmd_q\t*hooks_cmdq;\n\tva_list\t\t ap;\n\tchar\t\t*name;\n\n\tva_start(ap, fmt);\n\txvasprintf(&name, fmt, ap);\n\tva_end(ap);\n\n\thook = hooks_find(hooks, name);\n\tif (hook == NULL) {\n\t\tfree(name);\n\t\treturn (-1);\n\t}\n\tlog_debug(\"running hook %s\", name);\n\tfree(name);\n\n\thooks_cmdq = cmdq_new(c);\n\thooks_cmdq->flags |= CMD_Q_NOHOOKS;\n\n\tif (fs != NULL)\n\t\tcmd_find_copy_state(&hooks_cmdq->current, fs);\n\thooks_cmdq->parent = NULL;\n\n\tcmdq_run(hooks_cmdq, hook->cmdlist, NULL);\n\tcmdq_free(hooks_cmdq);\n\treturn (0);\n}\n\nint\nhooks_wait(struct hooks *hooks, struct cmd_q *cmdq, struct cmd_find_state *fs,\n    const char *fmt, ...)\n{\n\tstruct hook\t*hook;\n\tstruct cmd_q\t*hooks_cmdq;\n\tva_list\t\t ap;\n\tchar\t\t*name;\n\n\tva_start(ap, fmt);\n\txvasprintf(&name, fmt, ap);\n\tva_end(ap);\n\n\thook = hooks_find(hooks, name);\n\tif (hook == NULL) {\n\t\tfree(name);\n\t\treturn (-1);\n\t}\n\tlog_debug(\"running hook %s (parent %p)\", name, cmdq);\n\tfree(name);\n\n\thooks_cmdq = cmdq_new(cmdq->client);\n\thooks_cmdq->flags |= CMD_Q_NOHOOKS;\n\n\tif (fs != NULL)\n\t\tcmd_find_copy_state(&hooks_cmdq->current, fs);\n\thooks_cmdq->parent = cmdq;\n\n\thooks_cmdq->emptyfn = hooks_emptyfn;\n\thooks_cmdq->data = cmdq;\n\n\tif (cmdq != NULL)\n\t\tcmdq->references++;\n\tcmdq_run(hooks_cmdq, hook->cmdlist, NULL);\n\treturn (0);\n}\n"
        },
        {
          "name": "input-keys.c",
          "type": "blob",
          "size": 8.291015625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * This file is rather misleadingly named, it contains the code which takes a\n * key code and translates it into something suitable to be sent to the\n * application running in a pane (similar to input.c does in the other\n * direction with output).\n */\n\nvoid\t input_key_mouse(struct window_pane *, struct mouse_event *);\n\nstruct input_key_ent {\n\tkey_code\t key;\n\tconst char\t*data;\n\n\tint\t\t flags;\n#define INPUTKEY_KEYPAD 0x1\t/* keypad key */\n#define INPUTKEY_CURSOR 0x2\t/* cursor key */\n};\n\nconst struct input_key_ent input_keys[] = {\n\t/* Backspace key. */\n\t{ KEYC_BSPACE,\t\t\"\\177\",\t\t0 },\n\n\t/* Function keys. */\n\t{ KEYC_F1,\t\t\"\\033OP\",\t0 },\n\t{ KEYC_F2,\t\t\"\\033OQ\",\t0 },\n\t{ KEYC_F3,\t\t\"\\033OR\",\t0 },\n\t{ KEYC_F4,\t\t\"\\033OS\",\t0 },\n\t{ KEYC_F5,\t\t\"\\033[15~\",\t0 },\n\t{ KEYC_F6,\t\t\"\\033[17~\",\t0 },\n\t{ KEYC_F7,\t\t\"\\033[18~\",\t0 },\n\t{ KEYC_F8,\t\t\"\\033[19~\",\t0 },\n\t{ KEYC_F9,\t\t\"\\033[20~\",\t0 },\n\t{ KEYC_F10,\t\t\"\\033[21~\",\t0 },\n\t{ KEYC_F11,\t\t\"\\033[23~\",\t0 },\n\t{ KEYC_F12,\t\t\"\\033[24~\",\t0 },\n\t{ KEYC_F1|KEYC_SHIFT,\t\"\\033[25~\",\t0 },\n\t{ KEYC_F2|KEYC_SHIFT,\t\"\\033[26~\",\t0 },\n\t{ KEYC_F3|KEYC_SHIFT,\t\"\\033[28~\",\t0 },\n\t{ KEYC_F4|KEYC_SHIFT,\t\"\\033[29~\",\t0 },\n\t{ KEYC_F5|KEYC_SHIFT,\t\"\\033[31~\",\t0 },\n\t{ KEYC_F6|KEYC_SHIFT,\t\"\\033[32~\",\t0 },\n\t{ KEYC_F7|KEYC_SHIFT,\t\"\\033[33~\",\t0 },\n\t{ KEYC_F8|KEYC_SHIFT,\t\"\\033[34~\",\t0 },\n\t{ KEYC_IC,\t\t\"\\033[2~\",\t0 },\n\t{ KEYC_DC,\t\t\"\\033[3~\",\t0 },\n\t{ KEYC_HOME,\t\t\"\\033[1~\",\t0 },\n\t{ KEYC_END,\t\t\"\\033[4~\",\t0 },\n\t{ KEYC_NPAGE,\t\t\"\\033[6~\",\t0 },\n\t{ KEYC_PPAGE,\t\t\"\\033[5~\",\t0 },\n\t{ KEYC_BTAB,\t\t\"\\033[Z\",\t0 },\n\n\t/*\n\t * Arrow keys. Cursor versions must come first. The codes are toggled\n\t * between CSI and SS3 versions when ctrl is pressed.\n\t */\n\t{ KEYC_UP|KEYC_CTRL,\t\"\\033[A\",\tINPUTKEY_CURSOR },\n\t{ KEYC_DOWN|KEYC_CTRL,\t\"\\033[B\",\tINPUTKEY_CURSOR },\n\t{ KEYC_RIGHT|KEYC_CTRL,\t\"\\033[C\",\tINPUTKEY_CURSOR },\n\t{ KEYC_LEFT|KEYC_CTRL,\t\"\\033[D\",\tINPUTKEY_CURSOR },\n\n\t{ KEYC_UP,\t\t\"\\033OA\",\tINPUTKEY_CURSOR },\n\t{ KEYC_DOWN,\t\t\"\\033OB\",\tINPUTKEY_CURSOR },\n\t{ KEYC_RIGHT,\t\t\"\\033OC\",\tINPUTKEY_CURSOR },\n\t{ KEYC_LEFT,\t\t\"\\033OD\",\tINPUTKEY_CURSOR },\n\n\t{ KEYC_UP|KEYC_CTRL,\t\"\\033OA\",\t0 },\n\t{ KEYC_DOWN|KEYC_CTRL,\t\"\\033OB\",\t0 },\n\t{ KEYC_RIGHT|KEYC_CTRL,\t\"\\033OC\",\t0 },\n\t{ KEYC_LEFT|KEYC_CTRL,\t\"\\033OD\",\t0 },\n\n\t{ KEYC_UP,\t\t\"\\033[A\",\t0 },\n\t{ KEYC_DOWN,\t\t\"\\033[B\",\t0 },\n\t{ KEYC_RIGHT,\t\t\"\\033[C\",\t0 },\n\t{ KEYC_LEFT,\t\t\"\\033[D\",\t0 },\n\n\t/* Keypad keys. Keypad versions must come first. */\n\t{ KEYC_KP_SLASH,\t\"\\033Oo\",\tINPUTKEY_KEYPAD },\n\t{ KEYC_KP_STAR,\t\t\"\\033Oj\",\tINPUTKEY_KEYPAD },\n\t{ KEYC_KP_MINUS,\t\"\\033Om\",\tINPUTKEY_KEYPAD },\n\t{ KEYC_KP_SEVEN,\t\"\\033Ow\",\tINPUTKEY_KEYPAD },\n\t{ KEYC_KP_EIGHT,\t\"\\033Ox\",\tINPUTKEY_KEYPAD },\n\t{ KEYC_KP_NINE,\t\t\"\\033Oy\",\tINPUTKEY_KEYPAD },\n\t{ KEYC_KP_PLUS,\t\t\"\\033Ok\",\tINPUTKEY_KEYPAD },\n\t{ KEYC_KP_FOUR,\t\t\"\\033Ot\",\tINPUTKEY_KEYPAD },\n\t{ KEYC_KP_FIVE,\t\t\"\\033Ou\",\tINPUTKEY_KEYPAD },\n\t{ KEYC_KP_SIX,\t\t\"\\033Ov\",\tINPUTKEY_KEYPAD },\n\t{ KEYC_KP_ONE,\t\t\"\\033Oq\",\tINPUTKEY_KEYPAD },\n\t{ KEYC_KP_TWO,\t\t\"\\033Or\",\tINPUTKEY_KEYPAD },\n\t{ KEYC_KP_THREE,\t\"\\033Os\",\tINPUTKEY_KEYPAD },\n\t{ KEYC_KP_ENTER,\t\"\\033OM\",\tINPUTKEY_KEYPAD },\n\t{ KEYC_KP_ZERO,\t\t\"\\033Op\",\tINPUTKEY_KEYPAD },\n\t{ KEYC_KP_PERIOD,\t\"\\033On\",\tINPUTKEY_KEYPAD },\n\n\t{ KEYC_KP_SLASH,\t\"/\",\t\t0 },\n\t{ KEYC_KP_STAR,\t\t\"*\",\t\t0 },\n\t{ KEYC_KP_MINUS,\t\"-\",\t\t0 },\n\t{ KEYC_KP_SEVEN,\t\"7\",\t\t0 },\n\t{ KEYC_KP_EIGHT,\t\"8\",\t\t0 },\n\t{ KEYC_KP_NINE,\t\t\"9\",\t\t0 },\n\t{ KEYC_KP_PLUS,\t\t\"+\",\t\t0 },\n\t{ KEYC_KP_FOUR,\t\t\"4\",\t\t0 },\n\t{ KEYC_KP_FIVE,\t\t\"5\",\t\t0 },\n\t{ KEYC_KP_SIX,\t\t\"6\",\t\t0 },\n\t{ KEYC_KP_ONE,\t\t\"1\",\t\t0 },\n\t{ KEYC_KP_TWO,\t\t\"2\",\t\t0 },\n\t{ KEYC_KP_THREE,\t\"3\",\t\t0 },\n\t{ KEYC_KP_ENTER,\t\"\\n\",\t\t0 },\n\t{ KEYC_KP_ZERO,\t\t\"0\",\t\t0 },\n\t{ KEYC_KP_PERIOD,\t\".\",\t\t0 },\n};\n\n/* Split a character into two UTF-8 bytes. */\nstatic size_t\ninput_split2(u_int c, u_char *dst)\n{\n\tif (c > 0x7f) {\n\t\tdst[0] = (c >> 6) | 0xc0;\n\t\tdst[1] = (c & 0x3f) | 0x80;\n\t\treturn (2);\n\t}\n\tdst[0] = c;\n\treturn (1);\n}\n\n/* Translate a key code into an output key sequence. */\nvoid\ninput_key(struct window_pane *wp, key_code key, struct mouse_event *m)\n{\n\tconst struct input_key_ent\t*ike;\n\tu_int\t\t\t\t i;\n\tsize_t\t\t\t\t dlen;\n\tchar\t\t\t\t*out;\n\tkey_code\t\t\t justkey;\n\tstruct utf8_data\t\t ud;\n\n\tlog_debug(\"writing key 0x%llx (%s) to %%%u\", key,\n\t    key_string_lookup_key(key), wp->id);\n\n\t/* If this is a mouse key, pass off to mouse function. */\n\tif (KEYC_IS_MOUSE(key)) {\n\t\tif (m != NULL && m->wp != -1 && (u_int)m->wp == wp->id)\n\t\t\tinput_key_mouse(wp, m);\n\t\treturn;\n\t}\n\n\t/*\n\t * If this is a normal 7-bit key, just send it, with a leading escape\n\t * if necessary. If it is a UTF-8 key, split it and send it.\n\t */\n\tjustkey = (key & ~KEYC_ESCAPE);\n\tif (justkey <= 0x7f) {\n\t\tif (key & KEYC_ESCAPE)\n\t\t\tbufferevent_write(wp->event, \"\\033\", 1);\n\t\tud.data[0] = justkey;\n\t\tbufferevent_write(wp->event, &ud.data[0], 1);\n\t\treturn;\n\t}\n\tif (justkey > 0x7f && justkey < KEYC_BASE) {\n\t\tif (utf8_split(justkey, &ud) != UTF8_DONE)\n\t\t\treturn;\n\t\tif (key & KEYC_ESCAPE)\n\t\t\tbufferevent_write(wp->event, \"\\033\", 1);\n\t\tbufferevent_write(wp->event, ud.data, ud.size);\n\t\treturn;\n\t}\n\n\t/*\n\t * Then try to look this up as an xterm key, if the flag to output them\n\t * is set.\n\t */\n\tif (options_get_number(wp->window->options, \"xterm-keys\")) {\n\t\tif ((out = xterm_keys_lookup(key)) != NULL) {\n\t\t\tbufferevent_write(wp->event, out, strlen(out));\n\t\t\tfree(out);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Otherwise look the key up in the table. */\n\tfor (i = 0; i < nitems(input_keys); i++) {\n\t\tike = &input_keys[i];\n\n\t\tif ((ike->flags & INPUTKEY_KEYPAD) &&\n\t\t    !(wp->screen->mode & MODE_KKEYPAD))\n\t\t\tcontinue;\n\t\tif ((ike->flags & INPUTKEY_CURSOR) &&\n\t\t    !(wp->screen->mode & MODE_KCURSOR))\n\t\t\tcontinue;\n\n\t\tif ((key & KEYC_ESCAPE) && (ike->key | KEYC_ESCAPE) == key)\n\t\t\tbreak;\n\t\tif (ike->key == key)\n\t\t\tbreak;\n\t}\n\tif (i == nitems(input_keys)) {\n\t\tlog_debug(\"key 0x%llx missing\", key);\n\t\treturn;\n\t}\n\tdlen = strlen(ike->data);\n\tlog_debug(\"found key 0x%llx: \\\"%s\\\"\", key, ike->data);\n\n\t/* Prefix a \\033 for escape. */\n\tif (key & KEYC_ESCAPE)\n\t\tbufferevent_write(wp->event, \"\\033\", 1);\n\tbufferevent_write(wp->event, ike->data, dlen);\n}\n\n/* Translate mouse and output. */\nvoid\ninput_key_mouse(struct window_pane *wp, struct mouse_event *m)\n{\n\tchar\tbuf[40];\n\tsize_t\tlen;\n\tu_int\tx, y;\n\n\tif ((wp->screen->mode & ALL_MOUSE_MODES) == 0)\n\t\treturn;\n\tif (!window_pane_visible(wp))\n\t\treturn;\n\tif (cmd_mouse_at(wp, m, &x, &y, 0) != 0)\n\t\treturn;\n\n\t/* If this pane is not in button mode, discard motion events. */\n\tif (!(wp->screen->mode & MODE_MOUSE_BUTTON) && (m->b & MOUSE_MASK_DRAG))\n\t\treturn;\n\n\t/*\n\t * Use the SGR (1006) extension only if the application requested it\n\t * and the underlying terminal also sent the event in this format (this\n\t * is because an old style mouse release event cannot be converted into\n\t * the new SGR format, since the released button is unknown). Otherwise\n\t * pretend that tmux doesn't speak this extension, and fall back to the\n\t * UTF-8 (1005) extension if the application requested, or to the\n\t * legacy format.\n\t */\n\tif (m->sgr_type != ' ' && (wp->screen->mode & MODE_MOUSE_SGR)) {\n\t\tlen = xsnprintf(buf, sizeof buf, \"\\033[<%u;%u;%u%c\",\n\t\t    m->sgr_b, x + 1, y + 1, m->sgr_type);\n\t} else if (wp->screen->mode & MODE_MOUSE_UTF8) {\n\t\tif (m->b > 0x7ff - 32 || x > 0x7ff - 33 || y > 0x7ff - 33)\n\t\t\treturn;\n\t\tlen = xsnprintf(buf, sizeof buf, \"\\033[M\");\n\t\tlen += input_split2(m->b + 32, &buf[len]);\n\t\tlen += input_split2(x + 33, &buf[len]);\n\t\tlen += input_split2(y + 33, &buf[len]);\n\t} else {\n\t\tif (m->b > 223)\n\t\t\treturn;\n\t\tlen = xsnprintf(buf, sizeof buf, \"\\033[M\");\n\t\tbuf[len++] = m->b + 32;\n\t\tbuf[len++] = x + 33;\n\t\tbuf[len++] = y + 33;\n\t}\n\tlog_debug(\"writing mouse %.*s to %%%u\", (int)len, buf, wp->id);\n\tbufferevent_write(wp->event, buf, len);\n}\n"
        },
        {
          "name": "input.c",
          "type": "blob",
          "size": 46.23828125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\n#include \"tmux.h\"\n\n/*\n * Based on the description by Paul Williams at:\n *\n * http://vt100.net/emu/dec_ansi_parser\n *\n * With the following changes:\n *\n * - 7-bit only.\n *\n * - Support for UTF-8.\n *\n * - OSC (but not APC) may be terminated by \\007 as well as ST.\n *\n * - A state for APC similar to OSC. Some terminals appear to use this to set\n *   the title.\n *\n * - A state for the screen \\033k...\\033\\\\ sequence to rename a window. This is\n *   pretty stupid but not supporting it is more trouble than it is worth.\n *\n * - Special handling for ESC inside a DCS to allow arbitrary byte sequences to\n *   be passed to the underlying terminals.\n */\n\n/* Input parser cell. */\nstruct input_cell {\n\tstruct grid_cell\tcell;\n\tint\t\t\tset;\n\tint\t\t\tg0set;\t/* 1 if ACS */\n\tint\t\t\tg1set;\t/* 1 if ACS */\n};\n\n/* Input parser context. */\nstruct input_ctx {\n\tstruct window_pane     *wp;\n\tstruct screen_write_ctx ctx;\n\n\tstruct input_cell\tcell;\n\n\tstruct input_cell\told_cell;\n\tu_int \t\t\told_cx;\n\tu_int\t\t\told_cy;\n\n\tu_char\t\t\tinterm_buf[4];\n\tsize_t\t\t\tinterm_len;\n\n\tu_char\t\t\tparam_buf[64];\n\tsize_t\t\t\tparam_len;\n\n#define INPUT_BUF_START 32\n#define INPUT_BUF_LIMIT 1048576\n\tu_char\t\t       *input_buf;\n\tsize_t\t\t\tinput_len;\n\tsize_t\t\t\tinput_space;\n\n\tint\t\t\tparam_list[24];\t/* -1 not present */\n\tu_int\t\t\tparam_list_len;\n\n\tstruct utf8_data\tutf8data;\n\n\tint\t\t\tch;\n\tint\t\t\tflags;\n#define INPUT_DISCARD 0x1\n\n\tconst struct input_state *state;\n\n\t/*\n\t * All input received since we were last in the ground state. Sent to\n\t * control clients on connection.\n\t */\n\tstruct evbuffer\t \t*since_ground;\n};\n\n/* Helper functions. */\nstruct input_transition;\nint\tinput_split(struct input_ctx *);\nint\tinput_get(struct input_ctx *, u_int, int, int);\nvoid printflike(2, 3) input_reply(struct input_ctx *, const char *, ...);\nvoid\tinput_set_state(struct window_pane *, const struct input_transition *);\nvoid\tinput_reset_cell(struct input_ctx *);\n\n/* Transition entry/exit handlers. */\nvoid\tinput_clear(struct input_ctx *);\nvoid\tinput_ground(struct input_ctx *);\nvoid\tinput_enter_osc(struct input_ctx *);\nvoid\tinput_exit_osc(struct input_ctx *);\nvoid\tinput_enter_apc(struct input_ctx *);\nvoid\tinput_exit_apc(struct input_ctx *);\nvoid\tinput_enter_rename(struct input_ctx *);\nvoid\tinput_exit_rename(struct input_ctx *);\n\n/* Input state handlers. */\nint\tinput_print(struct input_ctx *);\nint\tinput_intermediate(struct input_ctx *);\nint\tinput_parameter(struct input_ctx *);\nint\tinput_input(struct input_ctx *);\nint\tinput_c0_dispatch(struct input_ctx *);\nint\tinput_esc_dispatch(struct input_ctx *);\nint\tinput_csi_dispatch(struct input_ctx *);\nvoid\tinput_csi_dispatch_rm(struct input_ctx *);\nvoid\tinput_csi_dispatch_rm_private(struct input_ctx *);\nvoid\tinput_csi_dispatch_sm(struct input_ctx *);\nvoid\tinput_csi_dispatch_sm_private(struct input_ctx *);\nvoid\tinput_csi_dispatch_winops(struct input_ctx *);\nvoid\tinput_csi_dispatch_sgr_256(struct input_ctx *, int, u_int *);\nvoid\tinput_csi_dispatch_sgr_rgb(struct input_ctx *, int, u_int *);\nvoid\tinput_csi_dispatch_sgr(struct input_ctx *);\nint\tinput_dcs_dispatch(struct input_ctx *);\nint\tinput_utf8_open(struct input_ctx *);\nint\tinput_utf8_add(struct input_ctx *);\nint\tinput_utf8_close(struct input_ctx *);\n\n/* Command table comparison function. */\nint\tinput_table_compare(const void *, const void *);\n\n/* Command table entry. */\nstruct input_table_entry {\n\tint\t\tch;\n\tconst char     *interm;\n\tint\t\ttype;\n};\n\n/* Escape commands. */\nenum input_esc_type {\n\tINPUT_ESC_DECALN,\n\tINPUT_ESC_DECKPAM,\n\tINPUT_ESC_DECKPNM,\n\tINPUT_ESC_DECRC,\n\tINPUT_ESC_DECSC,\n\tINPUT_ESC_HTS,\n\tINPUT_ESC_IND,\n\tINPUT_ESC_NEL,\n\tINPUT_ESC_RI,\n\tINPUT_ESC_RIS,\n\tINPUT_ESC_SCSG0_OFF,\n\tINPUT_ESC_SCSG0_ON,\n\tINPUT_ESC_SCSG1_OFF,\n\tINPUT_ESC_SCSG1_ON,\n};\n\n/* Escape command table. */\nconst struct input_table_entry input_esc_table[] = {\n\t{ '0', \"(\", INPUT_ESC_SCSG0_ON },\n\t{ '0', \")\", INPUT_ESC_SCSG1_ON },\n\t{ '7', \"\",  INPUT_ESC_DECSC },\n\t{ '8', \"\",  INPUT_ESC_DECRC },\n\t{ '8', \"#\", INPUT_ESC_DECALN },\n\t{ '=', \"\",  INPUT_ESC_DECKPAM },\n\t{ '>', \"\",  INPUT_ESC_DECKPNM },\n\t{ 'B', \"(\", INPUT_ESC_SCSG0_OFF },\n\t{ 'B', \")\", INPUT_ESC_SCSG1_OFF },\n\t{ 'D', \"\",  INPUT_ESC_IND },\n\t{ 'E', \"\",  INPUT_ESC_NEL },\n\t{ 'H', \"\",  INPUT_ESC_HTS },\n\t{ 'M', \"\",  INPUT_ESC_RI },\n\t{ 'c', \"\",  INPUT_ESC_RIS },\n};\n\n/* Control (CSI) commands. */\nenum input_csi_type {\n\tINPUT_CSI_CBT,\n\tINPUT_CSI_CNL,\n\tINPUT_CSI_CPL,\n\tINPUT_CSI_CUB,\n\tINPUT_CSI_CUD,\n\tINPUT_CSI_CUF,\n\tINPUT_CSI_CUP,\n\tINPUT_CSI_CUU,\n\tINPUT_CSI_DA,\n\tINPUT_CSI_DA_TWO,\n\tINPUT_CSI_DCH,\n\tINPUT_CSI_DECSCUSR,\n\tINPUT_CSI_DECSTBM,\n\tINPUT_CSI_DL,\n\tINPUT_CSI_DSR,\n\tINPUT_CSI_ECH,\n\tINPUT_CSI_ED,\n\tINPUT_CSI_EL,\n\tINPUT_CSI_HPA,\n\tINPUT_CSI_ICH,\n\tINPUT_CSI_IL,\n\tINPUT_CSI_RCP,\n\tINPUT_CSI_RM,\n\tINPUT_CSI_RM_PRIVATE,\n\tINPUT_CSI_SCP,\n\tINPUT_CSI_SGR,\n\tINPUT_CSI_SM,\n\tINPUT_CSI_SM_PRIVATE,\n\tINPUT_CSI_TBC,\n\tINPUT_CSI_VPA,\n\tINPUT_CSI_WINOPS,\n};\n\n/* Control (CSI) command table. */\nconst struct input_table_entry input_csi_table[] = {\n\t{ '@', \"\",  INPUT_CSI_ICH },\n\t{ 'A', \"\",  INPUT_CSI_CUU },\n\t{ 'B', \"\",  INPUT_CSI_CUD },\n\t{ 'C', \"\",  INPUT_CSI_CUF },\n\t{ 'D', \"\",  INPUT_CSI_CUB },\n\t{ 'E', \"\",  INPUT_CSI_CNL },\n\t{ 'F', \"\",  INPUT_CSI_CPL },\n\t{ 'G', \"\",  INPUT_CSI_HPA },\n\t{ 'H', \"\",  INPUT_CSI_CUP },\n\t{ 'J', \"\",  INPUT_CSI_ED },\n\t{ 'K', \"\",  INPUT_CSI_EL },\n\t{ 'L', \"\",  INPUT_CSI_IL },\n\t{ 'M', \"\",  INPUT_CSI_DL },\n\t{ 'P', \"\",  INPUT_CSI_DCH },\n\t{ 'X', \"\",  INPUT_CSI_ECH },\n\t{ 'Z', \"\",  INPUT_CSI_CBT },\n\t{ 'c', \"\",  INPUT_CSI_DA },\n\t{ 'c', \">\", INPUT_CSI_DA_TWO },\n\t{ 'd', \"\",  INPUT_CSI_VPA },\n\t{ 'f', \"\",  INPUT_CSI_CUP },\n\t{ 'g', \"\",  INPUT_CSI_TBC },\n\t{ 'h', \"\",  INPUT_CSI_SM },\n\t{ 'h', \"?\", INPUT_CSI_SM_PRIVATE },\n\t{ 'l', \"\",  INPUT_CSI_RM },\n\t{ 'l', \"?\", INPUT_CSI_RM_PRIVATE },\n\t{ 'm', \"\",  INPUT_CSI_SGR },\n\t{ 'n', \"\",  INPUT_CSI_DSR },\n\t{ 'q', \" \", INPUT_CSI_DECSCUSR },\n\t{ 'r', \"\",  INPUT_CSI_DECSTBM },\n\t{ 's', \"\",  INPUT_CSI_SCP },\n\t{ 't', \"\",  INPUT_CSI_WINOPS },\n\t{ 'u', \"\",  INPUT_CSI_RCP },\n};\n\n/* Input transition. */\nstruct input_transition {\n\tint\t\t\t\tfirst;\n\tint\t\t\t\tlast;\n\n\tint\t\t\t\t(*handler)(struct input_ctx *);\n\tconst struct input_state       *state;\n};\n\n/* Input state. */\nstruct input_state {\n\tconst char\t\t\t*name;\n\tvoid\t\t\t\t(*enter)(struct input_ctx *);\n\tvoid\t\t\t\t(*exit)(struct input_ctx *);\n\tconst struct input_transition\t*transitions;\n};\n\n/* State transitions available from all states. */\n#define INPUT_STATE_ANYWHERE \\\n\t{ 0x18, 0x18, input_c0_dispatch, &input_state_ground }, \\\n\t{ 0x1a, 0x1a, input_c0_dispatch, &input_state_ground }, \\\n\t{ 0x1b, 0x1b, NULL,\t\t &input_state_esc_enter }\n\n/* Forward declarations of state tables. */\nconst struct input_transition input_state_ground_table[];\nconst struct input_transition input_state_esc_enter_table[];\nconst struct input_transition input_state_esc_intermediate_table[];\nconst struct input_transition input_state_csi_enter_table[];\nconst struct input_transition input_state_csi_parameter_table[];\nconst struct input_transition input_state_csi_intermediate_table[];\nconst struct input_transition input_state_csi_ignore_table[];\nconst struct input_transition input_state_dcs_enter_table[];\nconst struct input_transition input_state_dcs_parameter_table[];\nconst struct input_transition input_state_dcs_intermediate_table[];\nconst struct input_transition input_state_dcs_handler_table[];\nconst struct input_transition input_state_dcs_escape_table[];\nconst struct input_transition input_state_dcs_ignore_table[];\nconst struct input_transition input_state_osc_string_table[];\nconst struct input_transition input_state_apc_string_table[];\nconst struct input_transition input_state_rename_string_table[];\nconst struct input_transition input_state_consume_st_table[];\nconst struct input_transition input_state_utf8_three_table[];\nconst struct input_transition input_state_utf8_two_table[];\nconst struct input_transition input_state_utf8_one_table[];\n\n/* ground state definition. */\nconst struct input_state input_state_ground = {\n\t\"ground\",\n\tinput_ground, NULL,\n\tinput_state_ground_table\n};\n\n/* esc_enter state definition. */\nconst struct input_state input_state_esc_enter = {\n\t\"esc_enter\",\n\tinput_clear, NULL,\n\tinput_state_esc_enter_table\n};\n\n/* esc_intermediate state definition. */\nconst struct input_state input_state_esc_intermediate = {\n\t\"esc_intermediate\",\n\tNULL, NULL,\n\tinput_state_esc_intermediate_table\n};\n\n/* csi_enter state definition. */\nconst struct input_state input_state_csi_enter = {\n\t\"csi_enter\",\n\tinput_clear, NULL,\n\tinput_state_csi_enter_table\n};\n\n/* csi_parameter state definition. */\nconst struct input_state input_state_csi_parameter = {\n\t\"csi_parameter\",\n\tNULL, NULL,\n\tinput_state_csi_parameter_table\n};\n\n/* csi_intermediate state definition. */\nconst struct input_state input_state_csi_intermediate = {\n\t\"csi_intermediate\",\n\tNULL, NULL,\n\tinput_state_csi_intermediate_table\n};\n\n/* csi_ignore state definition. */\nconst struct input_state input_state_csi_ignore = {\n\t\"csi_ignore\",\n\tNULL, NULL,\n\tinput_state_csi_ignore_table\n};\n\n/* dcs_enter state definition. */\nconst struct input_state input_state_dcs_enter = {\n\t\"dcs_enter\",\n\tinput_clear, NULL,\n\tinput_state_dcs_enter_table\n};\n\n/* dcs_parameter state definition. */\nconst struct input_state input_state_dcs_parameter = {\n\t\"dcs_parameter\",\n\tNULL, NULL,\n\tinput_state_dcs_parameter_table\n};\n\n/* dcs_intermediate state definition. */\nconst struct input_state input_state_dcs_intermediate = {\n\t\"dcs_intermediate\",\n\tNULL, NULL,\n\tinput_state_dcs_intermediate_table\n};\n\n/* dcs_handler state definition. */\nconst struct input_state input_state_dcs_handler = {\n\t\"dcs_handler\",\n\tNULL, NULL,\n\tinput_state_dcs_handler_table\n};\n\n/* dcs_escape state definition. */\nconst struct input_state input_state_dcs_escape = {\n\t\"dcs_escape\",\n\tNULL, NULL,\n\tinput_state_dcs_escape_table\n};\n\n/* dcs_ignore state definition. */\nconst struct input_state input_state_dcs_ignore = {\n\t\"dcs_ignore\",\n\tNULL, NULL,\n\tinput_state_dcs_ignore_table\n};\n\n/* osc_string state definition. */\nconst struct input_state input_state_osc_string = {\n\t\"osc_string\",\n\tinput_enter_osc, input_exit_osc,\n\tinput_state_osc_string_table\n};\n\n/* apc_string state definition. */\nconst struct input_state input_state_apc_string = {\n\t\"apc_string\",\n\tinput_enter_apc, input_exit_apc,\n\tinput_state_apc_string_table\n};\n\n/* rename_string state definition. */\nconst struct input_state input_state_rename_string = {\n\t\"rename_string\",\n\tinput_enter_rename, input_exit_rename,\n\tinput_state_rename_string_table\n};\n\n/* consume_st state definition. */\nconst struct input_state input_state_consume_st = {\n\t\"consume_st\",\n\tNULL, NULL,\n\tinput_state_consume_st_table\n};\n\n/* utf8_three state definition. */\nconst struct input_state input_state_utf8_three = {\n\t\"utf8_three\",\n\tNULL, NULL,\n\tinput_state_utf8_three_table\n};\n\n/* utf8_two state definition. */\nconst struct input_state input_state_utf8_two = {\n\t\"utf8_two\",\n\tNULL, NULL,\n\tinput_state_utf8_two_table\n};\n\n/* utf8_one state definition. */\nconst struct input_state input_state_utf8_one = {\n\t\"utf8_one\",\n\tNULL, NULL,\n\tinput_state_utf8_one_table\n};\n\n/* ground state table. */\nconst struct input_transition input_state_ground_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x17, input_c0_dispatch, NULL },\n\t{ 0x19, 0x19, input_c0_dispatch, NULL },\n\t{ 0x1c, 0x1f, input_c0_dispatch, NULL },\n\t{ 0x20, 0x7e, input_print,\t NULL },\n\t{ 0x7f, 0x7f, NULL,\t\t NULL },\n\t{ 0x80, 0xc1, NULL,\t\t NULL },\n\t{ 0xc2, 0xdf, input_utf8_open,\t &input_state_utf8_one },\n\t{ 0xe0, 0xef, input_utf8_open,\t &input_state_utf8_two },\n\t{ 0xf0, 0xf4, input_utf8_open,\t &input_state_utf8_three },\n\t{ 0xf5, 0xff, NULL,\t\t NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* esc_enter state table. */\nconst struct input_transition input_state_esc_enter_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x17, input_c0_dispatch,  NULL },\n\t{ 0x19, 0x19, input_c0_dispatch,  NULL },\n\t{ 0x1c, 0x1f, input_c0_dispatch,  NULL },\n\t{ 0x20, 0x2f, input_intermediate, &input_state_esc_intermediate },\n\t{ 0x30, 0x4f, input_esc_dispatch, &input_state_ground },\n\t{ 0x50, 0x50, NULL,\t\t  &input_state_dcs_enter },\n\t{ 0x51, 0x57, input_esc_dispatch, &input_state_ground },\n\t{ 0x58, 0x58, NULL,\t\t  &input_state_consume_st },\n\t{ 0x59, 0x59, input_esc_dispatch, &input_state_ground },\n\t{ 0x5a, 0x5a, input_esc_dispatch, &input_state_ground },\n\t{ 0x5b, 0x5b, NULL,\t\t  &input_state_csi_enter },\n\t{ 0x5c, 0x5c, input_esc_dispatch, &input_state_ground },\n\t{ 0x5d, 0x5d, NULL,\t\t  &input_state_osc_string },\n\t{ 0x5e, 0x5e, NULL,\t\t  &input_state_consume_st },\n\t{ 0x5f, 0x5f, NULL,\t\t  &input_state_apc_string },\n\t{ 0x60, 0x6a, input_esc_dispatch, &input_state_ground },\n\t{ 0x6b, 0x6b, NULL,\t\t  &input_state_rename_string },\n\t{ 0x6c, 0x7e, input_esc_dispatch, &input_state_ground },\n\t{ 0x7f, 0xff, NULL,\t\t  NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* esc_interm state table. */\nconst struct input_transition input_state_esc_intermediate_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x17, input_c0_dispatch,  NULL },\n\t{ 0x19, 0x19, input_c0_dispatch,  NULL },\n\t{ 0x1c, 0x1f, input_c0_dispatch,  NULL },\n\t{ 0x20, 0x2f, input_intermediate, NULL },\n\t{ 0x30, 0x7e, input_esc_dispatch, &input_state_ground },\n\t{ 0x7f, 0xff, NULL,\t\t  NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* csi_enter state table. */\nconst struct input_transition input_state_csi_enter_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x17, input_c0_dispatch,  NULL },\n\t{ 0x19, 0x19, input_c0_dispatch,  NULL },\n\t{ 0x1c, 0x1f, input_c0_dispatch,  NULL },\n\t{ 0x20, 0x2f, input_intermediate, &input_state_csi_intermediate },\n\t{ 0x30, 0x39, input_parameter,\t  &input_state_csi_parameter },\n\t{ 0x3a, 0x3a, NULL,\t\t  &input_state_csi_ignore },\n\t{ 0x3b, 0x3b, input_parameter,\t  &input_state_csi_parameter },\n\t{ 0x3c, 0x3f, input_intermediate, &input_state_csi_parameter },\n\t{ 0x40, 0x7e, input_csi_dispatch, &input_state_ground },\n\t{ 0x7f, 0xff, NULL,\t\t  NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* csi_parameter state table. */\nconst struct input_transition input_state_csi_parameter_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x17, input_c0_dispatch,  NULL },\n\t{ 0x19, 0x19, input_c0_dispatch,  NULL },\n\t{ 0x1c, 0x1f, input_c0_dispatch,  NULL },\n\t{ 0x20, 0x2f, input_intermediate, &input_state_csi_intermediate },\n\t{ 0x30, 0x39, input_parameter,\t  NULL },\n\t{ 0x3a, 0x3a, NULL,\t\t  &input_state_csi_ignore },\n\t{ 0x3b, 0x3b, input_parameter,\t  NULL },\n\t{ 0x3c, 0x3f, NULL,\t\t  &input_state_csi_ignore },\n\t{ 0x40, 0x7e, input_csi_dispatch, &input_state_ground },\n\t{ 0x7f, 0xff, NULL,\t\t  NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* csi_intermediate state table. */\nconst struct input_transition input_state_csi_intermediate_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x17, input_c0_dispatch,  NULL },\n\t{ 0x19, 0x19, input_c0_dispatch,  NULL },\n\t{ 0x1c, 0x1f, input_c0_dispatch,  NULL },\n\t{ 0x20, 0x2f, input_intermediate, NULL },\n\t{ 0x30, 0x3f, NULL,\t\t  &input_state_csi_ignore },\n\t{ 0x40, 0x7e, input_csi_dispatch, &input_state_ground },\n\t{ 0x7f, 0xff, NULL,\t\t  NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* csi_ignore state table. */\nconst struct input_transition input_state_csi_ignore_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x17, input_c0_dispatch, NULL },\n\t{ 0x19, 0x19, input_c0_dispatch, NULL },\n\t{ 0x1c, 0x1f, input_c0_dispatch, NULL },\n\t{ 0x20, 0x3f, NULL,\t\t NULL },\n\t{ 0x40, 0x7e, NULL,\t\t &input_state_ground },\n\t{ 0x7f, 0xff, NULL,\t\t NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* dcs_enter state table. */\nconst struct input_transition input_state_dcs_enter_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x17, NULL,\t\t  NULL },\n\t{ 0x19, 0x19, NULL,\t\t  NULL },\n\t{ 0x1c, 0x1f, NULL,\t\t  NULL },\n\t{ 0x20, 0x2f, input_intermediate, &input_state_dcs_intermediate },\n\t{ 0x30, 0x39, input_parameter,\t  &input_state_dcs_parameter },\n\t{ 0x3a, 0x3a, NULL,\t\t  &input_state_dcs_ignore },\n\t{ 0x3b, 0x3b, input_parameter,\t  &input_state_dcs_parameter },\n\t{ 0x3c, 0x3f, input_intermediate, &input_state_dcs_parameter },\n\t{ 0x40, 0x7e, input_input,\t  &input_state_dcs_handler },\n\t{ 0x7f, 0xff, NULL,\t\t  NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* dcs_parameter state table. */\nconst struct input_transition input_state_dcs_parameter_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x17, NULL,\t\t  NULL },\n\t{ 0x19, 0x19, NULL,\t\t  NULL },\n\t{ 0x1c, 0x1f, NULL,\t\t  NULL },\n\t{ 0x20, 0x2f, input_intermediate, &input_state_dcs_intermediate },\n\t{ 0x30, 0x39, input_parameter,\t  NULL },\n\t{ 0x3a, 0x3a, NULL,\t\t  &input_state_dcs_ignore },\n\t{ 0x3b, 0x3b, input_parameter,\t  NULL },\n\t{ 0x3c, 0x3f, NULL,\t\t  &input_state_dcs_ignore },\n\t{ 0x40, 0x7e, input_input,\t  &input_state_dcs_handler },\n\t{ 0x7f, 0xff, NULL,\t\t  NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* dcs_interm state table. */\nconst struct input_transition input_state_dcs_intermediate_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x17, NULL,\t\t  NULL },\n\t{ 0x19, 0x19, NULL,\t\t  NULL },\n\t{ 0x1c, 0x1f, NULL,\t\t  NULL },\n\t{ 0x20, 0x2f, input_intermediate, NULL },\n\t{ 0x30, 0x3f, NULL,\t\t  &input_state_dcs_ignore },\n\t{ 0x40, 0x7e, input_input,\t  &input_state_dcs_handler },\n\t{ 0x7f, 0xff, NULL,\t\t  NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* dcs_handler state table. */\nconst struct input_transition input_state_dcs_handler_table[] = {\n\t/* No INPUT_STATE_ANYWHERE */\n\n\t{ 0x00, 0x1a, input_input,  NULL },\n\t{ 0x1b, 0x1b, NULL,\t    &input_state_dcs_escape },\n\t{ 0x1c, 0xff, input_input,  NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* dcs_escape state table. */\nconst struct input_transition input_state_dcs_escape_table[] = {\n\t/* No INPUT_STATE_ANYWHERE */\n\n\t{ 0x00, 0x5b, input_input,\t  &input_state_dcs_handler },\n\t{ 0x5c, 0x5c, input_dcs_dispatch, &input_state_ground },\n\t{ 0x5d, 0xff, input_input,\t  &input_state_dcs_handler },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* dcs_ignore state table. */\nconst struct input_transition input_state_dcs_ignore_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x17, NULL,\t    NULL },\n\t{ 0x19, 0x19, NULL,\t    NULL },\n\t{ 0x1c, 0x1f, NULL,\t    NULL },\n\t{ 0x20, 0xff, NULL,\t    NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* osc_string state table. */\nconst struct input_transition input_state_osc_string_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x06, NULL,\t    NULL },\n\t{ 0x07, 0x07, NULL,\t    &input_state_ground },\n\t{ 0x08, 0x17, NULL,\t    NULL },\n\t{ 0x19, 0x19, NULL,\t    NULL },\n\t{ 0x1c, 0x1f, NULL,\t    NULL },\n\t{ 0x20, 0xff, input_input,  NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* apc_string state table. */\nconst struct input_transition input_state_apc_string_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x17, NULL,\t    NULL },\n\t{ 0x19, 0x19, NULL,\t    NULL },\n\t{ 0x1c, 0x1f, NULL,\t    NULL },\n\t{ 0x20, 0xff, input_input,  NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* rename_string state table. */\nconst struct input_transition input_state_rename_string_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x17, NULL,\t    NULL },\n\t{ 0x19, 0x19, NULL,\t    NULL },\n\t{ 0x1c, 0x1f, NULL,\t    NULL },\n\t{ 0x20, 0xff, input_input,  NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* consume_st state table. */\nconst struct input_transition input_state_consume_st_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x17, NULL,\t    NULL },\n\t{ 0x19, 0x19, NULL,\t    NULL },\n\t{ 0x1c, 0x1f, NULL,\t    NULL },\n\t{ 0x20, 0xff, NULL,\t    NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* utf8_three state table. */\nconst struct input_transition input_state_utf8_three_table[] = {\n\t/* No INPUT_STATE_ANYWHERE */\n\n\t{ 0x00, 0x7f, NULL,\t\t&input_state_ground },\n\t{ 0x80, 0xbf, input_utf8_add,\t&input_state_utf8_two },\n\t{ 0xc0, 0xff, NULL,\t\t&input_state_ground },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* utf8_two state table. */\nconst struct input_transition input_state_utf8_two_table[] = {\n\t/* No INPUT_STATE_ANYWHERE */\n\n\t{ 0x00, 0x7f, NULL,\t      &input_state_ground },\n\t{ 0x80, 0xbf, input_utf8_add, &input_state_utf8_one },\n\t{ 0xc0, 0xff, NULL,\t      &input_state_ground },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* utf8_one state table. */\nconst struct input_transition input_state_utf8_one_table[] = {\n\t/* No INPUT_STATE_ANYWHERE */\n\n\t{ 0x00, 0x7f, NULL,\t\t&input_state_ground },\n\t{ 0x80, 0xbf, input_utf8_close, &input_state_ground },\n\t{ 0xc0, 0xff, NULL,\t\t&input_state_ground },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* Input table compare. */\nint\ninput_table_compare(const void *key, const void *value)\n{\n\tconst struct input_ctx\t\t*ictx = key;\n\tconst struct input_table_entry\t*entry = value;\n\n\tif (ictx->ch != entry->ch)\n\t\treturn (ictx->ch - entry->ch);\n\treturn (strcmp(ictx->interm_buf, entry->interm));\n}\n\n/* Reset cell state to default. */\nvoid\ninput_reset_cell(struct input_ctx *ictx)\n{\n\tmemcpy(&ictx->cell.cell, &grid_default_cell, sizeof ictx->cell.cell);\n\tictx->cell.set = 0;\n\tictx->cell.g0set = ictx->cell.g1set = 0;\n\n\tmemcpy(&ictx->old_cell, &ictx->cell, sizeof ictx->old_cell);\n\tictx->old_cx = 0;\n\tictx->old_cy = 0;\n}\n\n/* Initialise input parser. */\nvoid\ninput_init(struct window_pane *wp)\n{\n\tstruct input_ctx\t*ictx;\n\n\tictx = wp->ictx = xcalloc(1, sizeof *ictx);\n\n\tictx->input_space = INPUT_BUF_START;\n\tictx->input_buf = xmalloc(INPUT_BUF_START);\n\n\tictx->since_ground = evbuffer_new();\n\n\tinput_reset(wp, 0);\n}\n\n/* Destroy input parser. */\nvoid\ninput_free(struct window_pane *wp)\n{\n\tstruct input_ctx\t*ictx = wp->ictx;\n\n\tfree(ictx->input_buf);\n\tevbuffer_free(ictx->since_ground);\n\n\tfree (ictx);\n\twp->ictx = NULL;\n}\n\n/* Reset input state and clear screen. */\nvoid\ninput_reset(struct window_pane *wp, int clear)\n{\n\tstruct input_ctx\t*ictx = wp->ictx;\n\n\tinput_reset_cell(ictx);\n\n\tif (clear) {\n\t\tif (wp->mode == NULL)\n\t\t\tscreen_write_start(&ictx->ctx, wp, &wp->base);\n\t\telse\n\t\t\tscreen_write_start(&ictx->ctx, NULL, &wp->base);\n\t\tscreen_write_reset(&ictx->ctx);\n\t\tscreen_write_stop(&ictx->ctx);\n\t}\n\n\t*ictx->interm_buf = '\\0';\n\tictx->interm_len = 0;\n\n\t*ictx->param_buf = '\\0';\n\tictx->param_len = 0;\n\n\t*ictx->input_buf = '\\0';\n\tictx->input_len = 0;\n\n\tictx->state = &input_state_ground;\n\tictx->flags = 0;\n}\n\n/* Return pending data. */\nstruct evbuffer *\ninput_pending(struct window_pane *wp)\n{\n\treturn (wp->ictx->since_ground);\n}\n\n/* Change input state. */\nvoid\ninput_set_state(struct window_pane *wp, const struct input_transition *itr)\n{\n\tstruct input_ctx\t*ictx = wp->ictx;\n\n\tif (ictx->state->exit != NULL)\n\t\tictx->state->exit(ictx);\n\tictx->state = itr->state;\n\tif (ictx->state->enter != NULL)\n\t\tictx->state->enter(ictx);\n}\n\n/* Parse input. */\nvoid\ninput_parse(struct window_pane *wp)\n{\n\tstruct input_ctx\t\t*ictx = wp->ictx;\n\tconst struct input_transition\t*itr;\n\tstruct evbuffer\t\t\t*evb = wp->event->input;\n\tu_char\t\t\t\t*buf;\n\tsize_t\t\t\t\t len, off;\n\n\tif (EVBUFFER_LENGTH(evb) == 0)\n\t\treturn;\n\n\twindow_update_activity(wp->window);\n\twp->flags |= PANE_CHANGED;\n\n\t/*\n\t * Open the screen. Use NULL wp if there is a mode set as don't want to\n\t * update the tty.\n\t */\n\tif (wp->mode == NULL)\n\t\tscreen_write_start(&ictx->ctx, wp, &wp->base);\n\telse\n\t\tscreen_write_start(&ictx->ctx, NULL, &wp->base);\n\tictx->wp = wp;\n\n\tbuf = EVBUFFER_DATA(evb);\n\tlen = EVBUFFER_LENGTH(evb);\n\tnotify_input(wp, evb);\n\toff = 0;\n\n\tlog_debug(\"%s: %%%u %s, %zu bytes: %.*s\", __func__, wp->id,\n\t    ictx->state->name, len, (int)len, buf);\n\n\t/* Parse the input. */\n\twhile (off < len) {\n\t\tictx->ch = buf[off++];\n\n\t\t/* Find the transition. */\n\t\titr = ictx->state->transitions;\n\t\twhile (itr->first != -1 && itr->last != -1) {\n\t\t\tif (ictx->ch >= itr->first && ictx->ch <= itr->last)\n\t\t\t\tbreak;\n\t\t\titr++;\n\t\t}\n\t\tif (itr->first == -1 || itr->last == -1) {\n\t\t\t/* No transition? Eh? */\n\t\t\tfatalx(\"no transition from state\");\n\t\t}\n\n\t\t/*\n\t\t * Execute the handler, if any. Don't switch state if it\n\t\t * returns non-zero.\n\t\t */\n\t\tif (itr->handler != NULL && itr->handler(ictx) != 0)\n\t\t\tcontinue;\n\n\t\t/* And switch state, if necessary. */\n\t\tif (itr->state != NULL)\n\t\t\tinput_set_state(wp, itr);\n\n\t\t/* If not in ground state, save input. */\n\t\tif (ictx->state != &input_state_ground)\n\t\t\tevbuffer_add(ictx->since_ground, &ictx->ch, 1);\n\t}\n\n\t/* Close the screen. */\n\tscreen_write_stop(&ictx->ctx);\n\n\tevbuffer_drain(evb, len);\n}\n\n/* Split the parameter list (if any). */\nint\ninput_split(struct input_ctx *ictx)\n\n{\n\tconst char\t*errstr;\n\tchar\t\t*ptr, *out;\n\tint\t\t n;\n\n\tictx->param_list_len = 0;\n\tif (ictx->param_len == 0)\n\t\treturn (0);\n\n\tptr = ictx->param_buf;\n\twhile ((out = strsep(&ptr, \";\")) != NULL) {\n\t\tif (*out == '\\0')\n\t\t\tn = -1;\n\t\telse {\n\t\t\tn = strtonum(out, 0, INT_MAX, &errstr);\n\t\t\tif (errstr != NULL)\n\t\t\t\treturn (-1);\n\t\t}\n\n\t\tictx->param_list[ictx->param_list_len++] = n;\n\t\tif (ictx->param_list_len == nitems(ictx->param_list))\n\t\t\treturn (-1);\n\t}\n\n\treturn (0);\n}\n\n/* Get an argument or return default value. */\nint\ninput_get(struct input_ctx *ictx, u_int validx, int minval, int defval)\n{\n\tint\tretval;\n\n\tif (validx >= ictx->param_list_len)\n\t    return (defval);\n\n\tretval = ictx->param_list[validx];\n\tif (retval == -1)\n\t\treturn (defval);\n\tif (retval < minval)\n\t\treturn (minval);\n\treturn (retval);\n}\n\n/* Reply to terminal query. */\nvoid\ninput_reply(struct input_ctx *ictx, const char *fmt, ...)\n{\n\tva_list\tap;\n\tchar   *reply;\n\n\tva_start(ap, fmt);\n\tvasprintf(&reply, fmt, ap);\n\tva_end(ap);\n\n\tbufferevent_write(ictx->wp->event, reply, strlen(reply));\n\tfree(reply);\n}\n\n/* Clear saved state. */\nvoid\ninput_clear(struct input_ctx *ictx)\n{\n\t*ictx->interm_buf = '\\0';\n\tictx->interm_len = 0;\n\n\t*ictx->param_buf = '\\0';\n\tictx->param_len = 0;\n\n\t*ictx->input_buf = '\\0';\n\tictx->input_len = 0;\n\n\tictx->flags &= ~INPUT_DISCARD;\n}\n\n/* Reset for ground state. */\nvoid\ninput_ground(struct input_ctx *ictx)\n{\n\tevbuffer_drain(ictx->since_ground, EVBUFFER_LENGTH(ictx->since_ground));\n\n\tif (ictx->input_space > INPUT_BUF_START) {\n\t\tictx->input_space = INPUT_BUF_START;\n\t\tictx->input_buf = xrealloc(ictx->input_buf, INPUT_BUF_START);\n\t}\n}\n\n/* Output this character to the screen. */\nint\ninput_print(struct input_ctx *ictx)\n{\n\tint\tset;\n\n\tset = ictx->cell.set == 0 ? ictx->cell.g0set : ictx->cell.g1set;\n\tif (set == 1)\n\t\tictx->cell.cell.attr |= GRID_ATTR_CHARSET;\n\telse\n\t\tictx->cell.cell.attr &= ~GRID_ATTR_CHARSET;\n\n\tutf8_set(&ictx->cell.cell.data, ictx->ch);\n\tscreen_write_cell(&ictx->ctx, &ictx->cell.cell);\n\n\tictx->cell.cell.attr &= ~GRID_ATTR_CHARSET;\n\n\treturn (0);\n}\n\n/* Collect intermediate string. */\nint\ninput_intermediate(struct input_ctx *ictx)\n{\n\tif (ictx->interm_len == (sizeof ictx->interm_buf) - 1)\n\t\tictx->flags |= INPUT_DISCARD;\n\telse {\n\t\tictx->interm_buf[ictx->interm_len++] = ictx->ch;\n\t\tictx->interm_buf[ictx->interm_len] = '\\0';\n\t}\n\n\treturn (0);\n}\n\n/* Collect parameter string. */\nint\ninput_parameter(struct input_ctx *ictx)\n{\n\tif (ictx->param_len == (sizeof ictx->param_buf) - 1)\n\t\tictx->flags |= INPUT_DISCARD;\n\telse {\n\t\tictx->param_buf[ictx->param_len++] = ictx->ch;\n\t\tictx->param_buf[ictx->param_len] = '\\0';\n\t}\n\n\treturn (0);\n}\n\n/* Collect input string. */\nint\ninput_input(struct input_ctx *ictx)\n{\n\tsize_t available;\n\n\tavailable = ictx->input_space;\n\twhile (ictx->input_len + 1 >= available) {\n\t\tavailable *= 2;\n\t\tif (available > INPUT_BUF_LIMIT) {\n\t\t\tictx->flags |= INPUT_DISCARD;\n\t\t\treturn (0);\n\t\t}\n\t\tictx->input_buf = xrealloc(ictx->input_buf, available);\n\t\tictx->input_space = available;\n\t}\n\tictx->input_buf[ictx->input_len++] = ictx->ch;\n\tictx->input_buf[ictx->input_len] = '\\0';\n\n\treturn (0);\n}\n\n/* Execute C0 control sequence. */\nint\ninput_c0_dispatch(struct input_ctx *ictx)\n{\n\tstruct screen_write_ctx\t*sctx = &ictx->ctx;\n\tstruct window_pane\t*wp = ictx->wp;\n\tstruct screen\t\t*s = sctx->s;\n\n\tlog_debug(\"%s: '%c'\", __func__, ictx->ch);\n\n\tswitch (ictx->ch) {\n\tcase '\\000':\t/* NUL */\n\t\tbreak;\n\tcase '\\007':\t/* BEL */\n\t\talerts_queue(wp->window, WINDOW_BELL);\n\t\tbreak;\n\tcase '\\010':\t/* BS */\n\t\tscreen_write_backspace(sctx);\n\t\tbreak;\n\tcase '\\011':\t/* HT */\n\t\t/* Don't tab beyond the end of the line. */\n\t\tif (s->cx >= screen_size_x(s) - 1)\n\t\t\tbreak;\n\n\t\t/* Find the next tab point, or use the last column if none. */\n\t\tdo {\n\t\t\ts->cx++;\n\t\t\tif (bit_test(s->tabs, s->cx))\n\t\t\t\tbreak;\n\t\t} while (s->cx < screen_size_x(s) - 1);\n\t\tbreak;\n\tcase '\\012':\t/* LF */\n\tcase '\\013':\t/* VT */\n\tcase '\\014':\t/* FF */\n\t\tscreen_write_linefeed(sctx, 0);\n\t\tbreak;\n\tcase '\\015':\t/* CR */\n\t\tscreen_write_carriagereturn(sctx);\n\t\tbreak;\n\tcase '\\016':\t/* SO */\n\t\tictx->cell.set = 1;\n\t\tbreak;\n\tcase '\\017':\t/* SI */\n\t\tictx->cell.set = 0;\n\t\tbreak;\n\tdefault:\n\t\tlog_debug(\"%s: unknown '%c'\", __func__, ictx->ch);\n\t\tbreak;\n\t}\n\n\treturn (0);\n}\n\n/* Execute escape sequence. */\nint\ninput_esc_dispatch(struct input_ctx *ictx)\n{\n\tstruct screen_write_ctx\t\t*sctx = &ictx->ctx;\n\tstruct screen\t\t\t*s = sctx->s;\n\tstruct input_table_entry\t*entry;\n\n\tif (ictx->flags & INPUT_DISCARD)\n\t\treturn (0);\n\tlog_debug(\"%s: '%c', %s\", __func__, ictx->ch, ictx->interm_buf);\n\n\tentry = bsearch(ictx, input_esc_table, nitems(input_esc_table),\n\t    sizeof input_esc_table[0], input_table_compare);\n\tif (entry == NULL) {\n\t\tlog_debug(\"%s: unknown '%c'\", __func__, ictx->ch);\n\t\treturn (0);\n\t}\n\n\tswitch (entry->type) {\n\tcase INPUT_ESC_RIS:\n\t\tinput_reset_cell(ictx);\n\t\tscreen_write_reset(sctx);\n\t\tbreak;\n\tcase INPUT_ESC_IND:\n\t\tscreen_write_linefeed(sctx, 0);\n\t\tbreak;\n\tcase INPUT_ESC_NEL:\n\t\tscreen_write_carriagereturn(sctx);\n\t\tscreen_write_linefeed(sctx, 0);\n\t\tbreak;\n\tcase INPUT_ESC_HTS:\n\t\tif (s->cx < screen_size_x(s))\n\t\t\tbit_set(s->tabs, s->cx);\n\t\tbreak;\n\tcase INPUT_ESC_RI:\n\t\tscreen_write_reverseindex(sctx);\n\t\tbreak;\n\tcase INPUT_ESC_DECKPAM:\n\t\tscreen_write_mode_set(sctx, MODE_KKEYPAD);\n\t\tbreak;\n\tcase INPUT_ESC_DECKPNM:\n\t\tscreen_write_mode_clear(sctx, MODE_KKEYPAD);\n\t\tbreak;\n\tcase INPUT_ESC_DECSC:\n\t\tmemcpy(&ictx->old_cell, &ictx->cell, sizeof ictx->old_cell);\n\t\tictx->old_cx = s->cx;\n\t\tictx->old_cy = s->cy;\n\t\tbreak;\n\tcase INPUT_ESC_DECRC:\n\t\tmemcpy(&ictx->cell, &ictx->old_cell, sizeof ictx->cell);\n\t\tscreen_write_cursormove(sctx, ictx->old_cx, ictx->old_cy);\n\t\tbreak;\n\tcase INPUT_ESC_DECALN:\n\t\tscreen_write_alignmenttest(sctx);\n\t\tbreak;\n\tcase INPUT_ESC_SCSG0_ON:\n\t\tictx->cell.g0set = 1;\n\t\tbreak;\n\tcase INPUT_ESC_SCSG0_OFF:\n\t\tictx->cell.g0set = 0;\n\t\tbreak;\n\tcase INPUT_ESC_SCSG1_ON:\n\t\tictx->cell.g1set = 1;\n\t\tbreak;\n\tcase INPUT_ESC_SCSG1_OFF:\n\t\tictx->cell.g1set = 0;\n\t\tbreak;\n\t}\n\n\treturn (0);\n}\n\n/* Execute control sequence. */\nint\ninput_csi_dispatch(struct input_ctx *ictx)\n{\n\tstruct screen_write_ctx\t       *sctx = &ictx->ctx;\n\tstruct screen\t\t       *s = sctx->s;\n\tstruct input_table_entry       *entry;\n\tint\t\t\t\tn, m;\n\tu_int\t\t\t\tcx;\n\n\tif (ictx->flags & INPUT_DISCARD)\n\t\treturn (0);\n\tif (input_split(ictx) != 0)\n\t\treturn (0);\n\tlog_debug(\"%s: '%c' \\\"%s\\\" \\\"%s\\\"\",\n\t    __func__, ictx->ch, ictx->interm_buf, ictx->param_buf);\n\n\tentry = bsearch(ictx, input_csi_table, nitems(input_csi_table),\n\t    sizeof input_csi_table[0], input_table_compare);\n\tif (entry == NULL) {\n\t\tlog_debug(\"%s: unknown '%c'\", __func__, ictx->ch);\n\t\treturn (0);\n\t}\n\n\tswitch (entry->type) {\n\tcase INPUT_CSI_CBT:\n\t\t/* Find the previous tab point, n times. */\n\t\tcx = s->cx;\n\t\tif (cx > screen_size_x(s) - 1)\n\t\t\tcx = screen_size_x(s) - 1;\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\twhile (cx > 0 && n-- > 0) {\n\t\t\tdo\n\t\t\t\tcx--;\n\t\t\twhile (cx > 0 && !bit_test(s->tabs, cx));\n\t\t}\n\t\ts->cx = cx;\n\t\tbreak;\n\tcase INPUT_CSI_CUB:\n\t\tscreen_write_cursorleft(sctx, input_get(ictx, 0, 1, 1));\n\t\tbreak;\n\tcase INPUT_CSI_CUD:\n\t\tscreen_write_cursordown(sctx, input_get(ictx, 0, 1, 1));\n\t\tbreak;\n\tcase INPUT_CSI_CUF:\n\t\tscreen_write_cursorright(sctx, input_get(ictx, 0, 1, 1));\n\t\tbreak;\n\tcase INPUT_CSI_CUP:\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tm = input_get(ictx, 1, 1, 1);\n\t\tscreen_write_cursormove(sctx, m - 1, n - 1);\n\t\tbreak;\n\tcase INPUT_CSI_WINOPS:\n\t\tinput_csi_dispatch_winops(ictx);\n\t\tbreak;\n\tcase INPUT_CSI_CUU:\n\t\tscreen_write_cursorup(sctx, input_get(ictx, 0, 1, 1));\n\t\tbreak;\n\tcase INPUT_CSI_CNL:\n\t\tscreen_write_carriagereturn(sctx);\n\t\tscreen_write_cursordown(sctx, input_get(ictx, 0, 1, 1));\n\t\tbreak;\n\tcase INPUT_CSI_CPL:\n\t\tscreen_write_carriagereturn(sctx);\n\t\tscreen_write_cursorup(sctx, input_get(ictx, 0, 1, 1));\n\t\tbreak;\n\tcase INPUT_CSI_DA:\n\t\tswitch (input_get(ictx, 0, 0, 0)) {\n\t\tcase 0:\n\t\t\tinput_reply(ictx, \"\\033[?1;2c\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_debug(\"%s: unknown '%c'\", __func__, ictx->ch);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase INPUT_CSI_DA_TWO:\n\t\tswitch (input_get(ictx, 0, 0, 0)) {\n\t\tcase 0:\n\t\t\tinput_reply(ictx, \"\\033[>84;0;0c\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_debug(\"%s: unknown '%c'\", __func__, ictx->ch);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase INPUT_CSI_ECH:\n\t\tscreen_write_clearcharacter(sctx, input_get(ictx, 0, 1, 1));\n\t\tbreak;\n\tcase INPUT_CSI_DCH:\n\t\tscreen_write_deletecharacter(sctx, input_get(ictx, 0, 1, 1));\n\t\tbreak;\n\tcase INPUT_CSI_DECSTBM:\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tm = input_get(ictx, 1, 1, screen_size_y(s));\n\t\tscreen_write_scrollregion(sctx, n - 1, m - 1);\n\t\tbreak;\n\tcase INPUT_CSI_DL:\n\t\tscreen_write_deleteline(sctx, input_get(ictx, 0, 1, 1));\n\t\tbreak;\n\tcase INPUT_CSI_DSR:\n\t\tswitch (input_get(ictx, 0, 0, 0)) {\n\t\tcase 5:\n\t\t\tinput_reply(ictx, \"\\033[0n\");\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tinput_reply(ictx, \"\\033[%u;%uR\", s->cy + 1, s->cx + 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_debug(\"%s: unknown '%c'\", __func__, ictx->ch);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase INPUT_CSI_ED:\n\t\tswitch (input_get(ictx, 0, 0, 0)) {\n\t\tcase 0:\n\t\t\tscreen_write_clearendofscreen(sctx);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tscreen_write_clearstartofscreen(sctx);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tscreen_write_clearscreen(sctx);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tswitch (input_get(ictx, 1, 0, 0)) {\n\t\t\tcase 0:\n\t\t\t\t/*\n\t\t\t\t * Linux console extension to clear history\n\t\t\t\t * (for example before locking the screen).\n\t\t\t\t */\n\t\t\t\tscreen_write_clearhistory(sctx);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_debug(\"%s: unknown '%c'\", __func__, ictx->ch);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase INPUT_CSI_EL:\n\t\tswitch (input_get(ictx, 0, 0, 0)) {\n\t\tcase 0:\n\t\t\tscreen_write_clearendofline(sctx);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tscreen_write_clearstartofline(sctx);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tscreen_write_clearline(sctx);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_debug(\"%s: unknown '%c'\", __func__, ictx->ch);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase INPUT_CSI_HPA:\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tscreen_write_cursormove(sctx, n - 1, s->cy);\n\t\tbreak;\n\tcase INPUT_CSI_ICH:\n\t\tscreen_write_insertcharacter(sctx, input_get(ictx, 0, 1, 1));\n\t\tbreak;\n\tcase INPUT_CSI_IL:\n\t\tscreen_write_insertline(sctx, input_get(ictx, 0, 1, 1));\n\t\tbreak;\n\tcase INPUT_CSI_RCP:\n\t\tmemcpy(&ictx->cell, &ictx->old_cell, sizeof ictx->cell);\n\t\tscreen_write_cursormove(sctx, ictx->old_cx, ictx->old_cy);\n\t\tbreak;\n\tcase INPUT_CSI_RM:\n\t\tinput_csi_dispatch_rm(ictx);\n\t\tbreak;\n\tcase INPUT_CSI_RM_PRIVATE:\n\t\tinput_csi_dispatch_rm_private(ictx);\n\t\tbreak;\n\tcase INPUT_CSI_SCP:\n\t\tmemcpy(&ictx->old_cell, &ictx->cell, sizeof ictx->old_cell);\n\t\tictx->old_cx = s->cx;\n\t\tictx->old_cy = s->cy;\n\t\tbreak;\n\tcase INPUT_CSI_SGR:\n\t\tinput_csi_dispatch_sgr(ictx);\n\t\tbreak;\n\tcase INPUT_CSI_SM:\n\t\tinput_csi_dispatch_sm(ictx);\n\t\tbreak;\n\tcase INPUT_CSI_SM_PRIVATE:\n\t\tinput_csi_dispatch_sm_private(ictx);\n\t\tbreak;\n\tcase INPUT_CSI_TBC:\n\t\tswitch (input_get(ictx, 0, 0, 0)) {\n\t\tcase 0:\n\t\t\tif (s->cx < screen_size_x(s))\n\t\t\t\tbit_clear(s->tabs, s->cx);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tbit_nclear(s->tabs, 0, screen_size_x(s) - 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_debug(\"%s: unknown '%c'\", __func__, ictx->ch);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase INPUT_CSI_VPA:\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tscreen_write_cursormove(sctx, s->cx, n - 1);\n\t\tbreak;\n\tcase INPUT_CSI_DECSCUSR:\n\t\tn = input_get(ictx, 0, 0, 0);\n\t\tscreen_set_cursor_style(s, n);\n\t\tbreak;\n\t}\n\n\treturn (0);\n}\n\n/* Handle CSI RM. */\nvoid\ninput_csi_dispatch_rm(struct input_ctx *ictx)\n{\n\tu_int\ti;\n\n\tfor (i = 0; i < ictx->param_list_len; i++) {\n\t\tswitch (input_get(ictx, i, 0, -1)) {\n\t\tcase 4:\t\t/* IRM */\n\t\t\tscreen_write_mode_clear(&ictx->ctx, MODE_INSERT);\n\t\t\tbreak;\n\t\tcase 34:\n\t\t\tscreen_write_mode_set(&ictx->ctx, MODE_BLINKING);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_debug(\"%s: unknown '%c'\", __func__, ictx->ch);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/* Handle CSI private RM. */\nvoid\ninput_csi_dispatch_rm_private(struct input_ctx *ictx)\n{\n\tstruct window_pane\t*wp = ictx->wp;\n\tu_int\t\t\t i;\n\n\tfor (i = 0; i < ictx->param_list_len; i++) {\n\t\tswitch (input_get(ictx, i, 0, -1)) {\n\t\tcase 1:\t\t/* DECCKM */\n\t\t\tscreen_write_mode_clear(&ictx->ctx, MODE_KCURSOR);\n\t\t\tbreak;\n\t\tcase 3:\t\t/* DECCOLM */\n\t\t\tscreen_write_cursormove(&ictx->ctx, 0, 0);\n\t\t\tscreen_write_clearscreen(&ictx->ctx);\n\t\t\tbreak;\n\t\tcase 7:\t\t/* DECAWM */\n\t\t\tscreen_write_mode_clear(&ictx->ctx, MODE_WRAP);\n\t\t\tbreak;\n\t\tcase 12:\n\t\t\tscreen_write_mode_clear(&ictx->ctx, MODE_BLINKING);\n\t\t\tbreak;\n\t\tcase 25:\t/* TCEM */\n\t\t\tscreen_write_mode_clear(&ictx->ctx, MODE_CURSOR);\n\t\t\tbreak;\n\t\tcase 1000:\n\t\tcase 1001:\n\t\tcase 1002:\n\t\t\tscreen_write_mode_clear(&ictx->ctx, ALL_MOUSE_MODES);\n\t\t\tbreak;\n\t\tcase 1004:\n\t\t\tscreen_write_mode_clear(&ictx->ctx, MODE_FOCUSON);\n\t\t\tbreak;\n\t\tcase 1005:\n\t\t\tscreen_write_mode_clear(&ictx->ctx, MODE_MOUSE_UTF8);\n\t\t\tbreak;\n\t\tcase 1006:\n\t\t\tscreen_write_mode_clear(&ictx->ctx, MODE_MOUSE_SGR);\n\t\t\tbreak;\n\t\tcase 47:\n\t\tcase 1047:\n\t\t\twindow_pane_alternate_off(wp, &ictx->cell.cell, 0);\n\t\t\tbreak;\n\t\tcase 1049:\n\t\t\twindow_pane_alternate_off(wp, &ictx->cell.cell, 1);\n\t\t\tbreak;\n\t\tcase 2004:\n\t\t\tscreen_write_mode_clear(&ictx->ctx, MODE_BRACKETPASTE);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_debug(\"%s: unknown '%c'\", __func__, ictx->ch);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/* Handle CSI SM. */\nvoid\ninput_csi_dispatch_sm(struct input_ctx *ictx)\n{\n\tu_int\ti;\n\n\tfor (i = 0; i < ictx->param_list_len; i++) {\n\t\tswitch (input_get(ictx, i, 0, -1)) {\n\t\tcase 4:\t\t/* IRM */\n\t\t\tscreen_write_mode_set(&ictx->ctx, MODE_INSERT);\n\t\t\tbreak;\n\t\tcase 34:\n\t\t\tscreen_write_mode_clear(&ictx->ctx, MODE_BLINKING);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_debug(\"%s: unknown '%c'\", __func__, ictx->ch);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/* Handle CSI private SM. */\nvoid\ninput_csi_dispatch_sm_private(struct input_ctx *ictx)\n{\n\tstruct window_pane\t*wp = ictx->wp;\n\tu_int\t\t\t i;\n\n\tfor (i = 0; i < ictx->param_list_len; i++) {\n\t\tswitch (input_get(ictx, i, 0, -1)) {\n\t\tcase 1:\t\t/* DECCKM */\n\t\t\tscreen_write_mode_set(&ictx->ctx, MODE_KCURSOR);\n\t\t\tbreak;\n\t\tcase 3:\t\t/* DECCOLM */\n\t\t\tscreen_write_cursormove(&ictx->ctx, 0, 0);\n\t\t\tscreen_write_clearscreen(&ictx->ctx);\n\t\t\tbreak;\n\t\tcase 7:\t\t/* DECAWM */\n\t\t\tscreen_write_mode_set(&ictx->ctx, MODE_WRAP);\n\t\t\tbreak;\n\t\tcase 12:\n\t\t\tscreen_write_mode_set(&ictx->ctx, MODE_BLINKING);\n\t\t\tbreak;\n\t\tcase 25:\t/* TCEM */\n\t\t\tscreen_write_mode_set(&ictx->ctx, MODE_CURSOR);\n\t\t\tbreak;\n\t\tcase 1000:\n\t\t\tscreen_write_mode_clear(&ictx->ctx, ALL_MOUSE_MODES);\n\t\t\tscreen_write_mode_set(&ictx->ctx, MODE_MOUSE_STANDARD);\n\t\t\tbreak;\n\t\tcase 1002:\n\t\t\tscreen_write_mode_clear(&ictx->ctx, ALL_MOUSE_MODES);\n\t\t\tscreen_write_mode_set(&ictx->ctx, MODE_MOUSE_BUTTON);\n\t\t\tbreak;\n\t\tcase 1004:\n\t\t\tif (ictx->ctx.s->mode & MODE_FOCUSON)\n\t\t\t\tbreak;\n\t\t\tscreen_write_mode_set(&ictx->ctx, MODE_FOCUSON);\n\t\t\twp->flags |= PANE_FOCUSPUSH; /* force update */\n\t\t\tbreak;\n\t\tcase 1005:\n\t\t\tscreen_write_mode_set(&ictx->ctx, MODE_MOUSE_UTF8);\n\t\t\tbreak;\n\t\tcase 1006:\n\t\t\tscreen_write_mode_set(&ictx->ctx, MODE_MOUSE_SGR);\n\t\t\tbreak;\n\t\tcase 47:\n\t\tcase 1047:\n\t\t\twindow_pane_alternate_on(wp, &ictx->cell.cell, 0);\n\t\t\tbreak;\n\t\tcase 1049:\n\t\t\twindow_pane_alternate_on(wp, &ictx->cell.cell, 1);\n\t\t\tbreak;\n\t\tcase 2004:\n\t\t\tscreen_write_mode_set(&ictx->ctx, MODE_BRACKETPASTE);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_debug(\"%s: unknown '%c'\", __func__, ictx->ch);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/* Handle CSI window operations. */\nvoid\ninput_csi_dispatch_winops(struct input_ctx *ictx)\n{\n\tstruct window_pane\t*wp = ictx->wp;\n\tint\t\t\t n, m;\n\n\tm = 0;\n\twhile ((n = input_get(ictx, m, 0, -1)) != -1) {\n\t\tswitch (n) {\n\t\tcase 1:\n\t\tcase 2:\n\t\tcase 5:\n\t\tcase 6:\n\t\tcase 7:\n\t\tcase 11:\n\t\tcase 13:\n\t\tcase 14:\n\t\tcase 19:\n\t\tcase 20:\n\t\tcase 21:\n\t\tcase 24:\n\t\t\tbreak;\n\t\tcase 3:\n\t\tcase 4:\n\t\tcase 8:\n\t\t\tm++;\n\t\t\tif (input_get(ictx, m, 0, -1) == -1)\n\t\t\t\treturn;\n\t\t\t/* FALLTHROUGH */\n\t\tcase 9:\n\t\tcase 10:\n\t\tcase 22:\n\t\tcase 23:\n\t\t\tm++;\n\t\t\tif (input_get(ictx, m, 0, -1) == -1)\n\t\t\t\treturn;\n\t\t\tbreak;\n\t\tcase 18:\n\t\t\tinput_reply(ictx, \"\\033[8;%u;%ut\", wp->sy, wp->sx);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_debug(\"%s: unknown '%c'\", __func__, ictx->ch);\n\t\t\tbreak;\n\t\t}\n\t\tm++;\n\t}\n}\n\n/* Handle CSI SGR for 256 colours. */\nvoid\ninput_csi_dispatch_sgr_256(struct input_ctx *ictx, int fgbg, u_int *i)\n{\n\tstruct grid_cell\t*gc = &ictx->cell.cell;\n\tint\t\t\t c;\n\n\t(*i)++;\n\tc = input_get(ictx, *i, 0, -1);\n\tif (c == -1) {\n\t\tif (fgbg == 38) {\n\t\t\tgc->flags &= ~(GRID_FLAG_FG256|GRID_FLAG_FGRGB);\n\t\t\tgc->fg = 8;\n\t\t} else if (fgbg == 48) {\n\t\t\tgc->flags &= ~(GRID_FLAG_BG256|GRID_FLAG_BGRGB);\n\t\t\tgc->bg = 8;\n\t\t}\n\t} else {\n\t\tif (fgbg == 38) {\n\t\t\tgc->flags |= GRID_FLAG_FG256;\n\t\t\tgc->flags &= ~GRID_FLAG_FGRGB;\n\t\t\tgc->fg = c;\n\t\t} else if (fgbg == 48) {\n\t\t\tgc->flags |= GRID_FLAG_BG256;\n\t\t\tgc->flags &= ~GRID_FLAG_BGRGB;\n\t\t\tgc->bg = c;\n\t\t}\n\t}\n}\n\n/* Handle CSI SGR for RGB colours. */\nvoid\ninput_csi_dispatch_sgr_rgb(struct input_ctx *ictx, int fgbg, u_int *i)\n{\n\tstruct grid_cell\t*gc = &ictx->cell.cell;\n\tint\t\t\t r, g, b;\n\n\t(*i)++;\n\tr = input_get(ictx, *i, 0, -1);\n\tif (r == -1 || r > 255)\n\t\treturn;\n\t(*i)++;\n\tg = input_get(ictx, *i, 0, -1);\n\tif (g == -1 || g > 255)\n\t\treturn;\n\t(*i)++;\n\tb = input_get(ictx, *i, 0, -1);\n\tif (b == -1 || b > 255)\n\t\treturn;\n\n\tif (fgbg == 38) {\n\t\tgc->flags &= ~GRID_FLAG_FG256;\n\t\tgc->flags |= GRID_FLAG_FGRGB;\n\t\tgc->fg_rgb.r = r;\n\t\tgc->fg_rgb.g = g;\n\t\tgc->fg_rgb.b = b;\n\t} else if (fgbg == 48) {\n\t\tgc->flags &= ~GRID_FLAG_BG256;\n\t\tgc->flags |= GRID_FLAG_BGRGB;\n\t\tgc->bg_rgb.r = r;\n\t\tgc->bg_rgb.g = g;\n\t\tgc->bg_rgb.b = b;\n\t}\n}\n\n/* Handle CSI SGR. */\nvoid\ninput_csi_dispatch_sgr(struct input_ctx *ictx)\n{\n\tstruct grid_cell\t*gc = &ictx->cell.cell;\n\tu_int\t\t\t i;\n\tint\t\t\t n;\n\n\tif (ictx->param_list_len == 0) {\n\t\tmemcpy(gc, &grid_default_cell, sizeof *gc);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < ictx->param_list_len; i++) {\n\t\tn = input_get(ictx, i, 0, 0);\n\n\t\tif (n == 38 || n == 48) {\n\t\t\ti++;\n\t\t\tswitch (input_get(ictx, i, 0, -1)) {\n\t\t\tcase 2:\n\t\t\t\tinput_csi_dispatch_sgr_rgb(ictx, n, &i);\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tinput_csi_dispatch_sgr_256(ictx, n, &i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (n) {\n\t\tcase 0:\n\t\tcase 10:\n\t\t\tmemcpy(gc, &grid_default_cell, sizeof *gc);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tgc->attr |= GRID_ATTR_BRIGHT;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tgc->attr |= GRID_ATTR_DIM;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tgc->attr |= GRID_ATTR_ITALICS;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tgc->attr |= GRID_ATTR_UNDERSCORE;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tgc->attr |= GRID_ATTR_BLINK;\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tgc->attr |= GRID_ATTR_REVERSE;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tgc->attr |= GRID_ATTR_HIDDEN;\n\t\t\tbreak;\n\t\tcase 22:\n\t\t\tgc->attr &= ~(GRID_ATTR_BRIGHT|GRID_ATTR_DIM);\n\t\t\tbreak;\n\t\tcase 23:\n\t\t\tgc->attr &= ~GRID_ATTR_ITALICS;\n\t\t\tbreak;\n\t\tcase 24:\n\t\t\tgc->attr &= ~GRID_ATTR_UNDERSCORE;\n\t\t\tbreak;\n\t\tcase 25:\n\t\t\tgc->attr &= ~GRID_ATTR_BLINK;\n\t\t\tbreak;\n\t\tcase 27:\n\t\t\tgc->attr &= ~GRID_ATTR_REVERSE;\n\t\t\tbreak;\n\t\tcase 30:\n\t\tcase 31:\n\t\tcase 32:\n\t\tcase 33:\n\t\tcase 34:\n\t\tcase 35:\n\t\tcase 36:\n\t\tcase 37:\n\t\t\tgc->flags &= ~(GRID_FLAG_FG256|GRID_FLAG_FGRGB);\n\t\t\tgc->fg = n - 30;\n\t\t\tbreak;\n\t\tcase 39:\n\t\t\tgc->flags &= ~(GRID_FLAG_FG256|GRID_FLAG_FGRGB);\n\t\t\tgc->fg = 8;\n\t\t\tbreak;\n\t\tcase 40:\n\t\tcase 41:\n\t\tcase 42:\n\t\tcase 43:\n\t\tcase 44:\n\t\tcase 45:\n\t\tcase 46:\n\t\tcase 47:\n\t\t\tgc->flags &= ~(GRID_FLAG_BG256|GRID_FLAG_BGRGB);\n\t\t\tgc->bg = n - 40;\n\t\t\tbreak;\n\t\tcase 49:\n\t\t\tgc->flags &= ~(GRID_FLAG_BG256|GRID_FLAG_BGRGB);\n\t\t\tgc->bg = 8;\n\t\t\tbreak;\n\t\tcase 90:\n\t\tcase 91:\n\t\tcase 92:\n\t\tcase 93:\n\t\tcase 94:\n\t\tcase 95:\n\t\tcase 96:\n\t\tcase 97:\n\t\t\tgc->flags &= ~(GRID_FLAG_FG256|GRID_FLAG_FGRGB);\n\t\t\tgc->fg = n;\n\t\t\tbreak;\n\t\tcase 100:\n\t\tcase 101:\n\t\tcase 102:\n\t\tcase 103:\n\t\tcase 104:\n\t\tcase 105:\n\t\tcase 106:\n\t\tcase 107:\n\t\t\tgc->flags &= ~(GRID_FLAG_BG256|GRID_FLAG_BGRGB);\n\t\t\tgc->bg = n - 10;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/* DCS terminator (ST) received. */\nint\ninput_dcs_dispatch(struct input_ctx *ictx)\n{\n\tconst char\tprefix[] = \"tmux;\";\n\tconst u_int\tprefix_len = (sizeof prefix) - 1;\n\n\tif (ictx->flags & INPUT_DISCARD)\n\t\treturn (0);\n\n\tlog_debug(\"%s: \\\"%s\\\"\", __func__, ictx->input_buf);\n\n\t/* Check for tmux prefix. */\n\tif (ictx->input_len >= prefix_len &&\n\t    strncmp(ictx->input_buf, prefix, prefix_len) == 0) {\n\t\tscreen_write_rawstring(&ictx->ctx,\n\t\t    ictx->input_buf + prefix_len, ictx->input_len - prefix_len);\n\t}\n\n\treturn (0);\n}\n\n/* OSC string started. */\nvoid\ninput_enter_osc(struct input_ctx *ictx)\n{\n\tlog_debug(\"%s\", __func__);\n\n\tinput_clear(ictx);\n}\n\n/* OSC terminator (ST) received. */\nvoid\ninput_exit_osc(struct input_ctx *ictx)\n{\n\tu_char\t*p = ictx->input_buf;\n\tu_int\t option;\n\n\tif (ictx->flags & INPUT_DISCARD)\n\t\treturn;\n\tif (ictx->input_len < 1 || *p < '0' || *p > '9')\n\t\treturn;\n\n\tlog_debug(\"%s: \\\"%s\\\"\", __func__, p);\n\n\toption = 0;\n\twhile (*p >= '0' && *p <= '9')\n\t\toption = option * 10 + *p++ - '0';\n\tif (*p == ';')\n\t\tp++;\n\n\tswitch (option) {\n\tcase 0:\n\tcase 2:\n\t\tscreen_set_title(ictx->ctx.s, p);\n\t\tserver_status_window(ictx->wp->window);\n\t\tbreak;\n\tcase 12:\n\t\tif (*p != '?') /* ? is colour request */\n\t\t\tscreen_set_cursor_colour(ictx->ctx.s, p);\n\t\tbreak;\n\tcase 112:\n\t\tif (*p == '\\0') /* no arguments allowed */\n\t\t\tscreen_set_cursor_colour(ictx->ctx.s, \"\");\n\t\tbreak;\n\tdefault:\n\t\tlog_debug(\"%s: unknown '%u'\", __func__, option);\n\t\tbreak;\n\t}\n}\n\n/* APC string started. */\nvoid\ninput_enter_apc(struct input_ctx *ictx)\n{\n\tlog_debug(\"%s\", __func__);\n\n\tinput_clear(ictx);\n}\n\n/* APC terminator (ST) received. */\nvoid\ninput_exit_apc(struct input_ctx *ictx)\n{\n\tif (ictx->flags & INPUT_DISCARD)\n\t\treturn;\n\tlog_debug(\"%s: \\\"%s\\\"\", __func__, ictx->input_buf);\n\n\tscreen_set_title(ictx->ctx.s, ictx->input_buf);\n\tserver_status_window(ictx->wp->window);\n}\n\n/* Rename string started. */\nvoid\ninput_enter_rename(struct input_ctx *ictx)\n{\n\tlog_debug(\"%s\", __func__);\n\n\tinput_clear(ictx);\n}\n\n/* Rename terminator (ST) received. */\nvoid\ninput_exit_rename(struct input_ctx *ictx)\n{\n\tif (ictx->flags & INPUT_DISCARD)\n\t\treturn;\n\tif (!options_get_number(ictx->wp->window->options, \"allow-rename\"))\n\t\treturn;\n\tlog_debug(\"%s: \\\"%s\\\"\", __func__, ictx->input_buf);\n\n\twindow_set_name(ictx->wp->window, ictx->input_buf);\n\toptions_set_number(ictx->wp->window->options, \"automatic-rename\", 0);\n\n\tserver_status_window(ictx->wp->window);\n}\n\n/* Open UTF-8 character. */\nint\ninput_utf8_open(struct input_ctx *ictx)\n{\n\tstruct utf8_data\t*ud = &ictx->utf8data;\n\n\tif (utf8_open(ud, ictx->ch) != UTF8_MORE)\n\t\tfatalx(\"UTF-8 open invalid %#x\", ictx->ch);\n\n\tlog_debug(\"%s %hhu\", __func__, ud->size);\n\n\treturn (0);\n}\n\n/* Append to UTF-8 character. */\nint\ninput_utf8_add(struct input_ctx *ictx)\n{\n\tstruct utf8_data\t*ud = &ictx->utf8data;\n\n\tif (utf8_append(ud, ictx->ch) != UTF8_MORE)\n\t\tfatalx(\"UTF-8 add invalid %#x\", ictx->ch);\n\n\tlog_debug(\"%s\", __func__);\n\n\treturn (0);\n}\n\n/* Close UTF-8 string. */\nint\ninput_utf8_close(struct input_ctx *ictx)\n{\n\tstruct utf8_data\t*ud = &ictx->utf8data;\n\n\tif (utf8_append(ud, ictx->ch) != UTF8_DONE) {\n\t\t/*\n\t\t * An error here could be invalid UTF-8 or it could be a\n\t\t * nonprintable character for which we can't get the\n\t\t * width. Drop it.\n\t\t */\n\t\treturn (0);\n\t}\n\n\tlog_debug(\"%s %hhu '%*s' (width %hhu)\", __func__, ud->size,\n\t    (int)ud->size, ud->data, ud->width);\n\n\tutf8_copy(&ictx->cell.cell.data, ud);\n\tscreen_write_cell(&ictx->ctx, &ictx->cell.cell);\n\n\treturn (0);\n}\n"
        },
        {
          "name": "job.c",
          "type": "blob",
          "size": 4.7041015625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/socket.h>\n\n#include <fcntl.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\n/*\n * Job scheduling. Run queued commands in the background and record their\n * output.\n */\n\nvoid\tjob_callback(struct bufferevent *, short, void *);\nvoid\tjob_write_callback(struct bufferevent *, void *);\n\n/* All jobs list. */\nstruct joblist\tall_jobs = LIST_HEAD_INITIALIZER(all_jobs);\n\n/* Start a job running, if it isn't already. */\nstruct job *\njob_run(const char *cmd, struct session *s, const char *cwd,\n    void (*callbackfn)(struct job *), void (*freefn)(void *), void *data)\n{\n\tstruct job\t*job;\n\tstruct environ\t*env;\n\tpid_t\t\t pid;\n\tint\t\t nullfd, out[2];\n\tconst char\t*home;\n\n\tif (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, out) != 0)\n\t\treturn (NULL);\n\n\tenv = environ_create();\n\tenviron_copy(global_environ, env);\n\tif (s != NULL)\n\t\tenviron_copy(s->environ, env);\n\tserver_fill_environ(s, env);\n\n\tswitch (pid = fork()) {\n\tcase -1:\n\t\tenviron_free(env);\n\t\tclose(out[0]);\n\t\tclose(out[1]);\n\t\treturn (NULL);\n\tcase 0:\t\t/* child */\n\t\tclear_signals(1);\n\n\t\tif (cwd == NULL || chdir(cwd) != 0) {\n\t\t\tif ((home = find_home()) == NULL || chdir(home) != 0)\n\t\t\t\tchdir(\"/\");\n\t\t}\n\n\t\tenviron_push(env);\n\t\tenviron_free(env);\n\n\t\tif (dup2(out[1], STDIN_FILENO) == -1)\n\t\t\tfatal(\"dup2 failed\");\n\t\tif (dup2(out[1], STDOUT_FILENO) == -1)\n\t\t\tfatal(\"dup2 failed\");\n\t\tif (out[1] != STDIN_FILENO && out[1] != STDOUT_FILENO)\n\t\t\tclose(out[1]);\n\t\tclose(out[0]);\n\n\t\tnullfd = open(_PATH_DEVNULL, O_RDWR, 0);\n\t\tif (nullfd < 0)\n\t\t\tfatal(\"open failed\");\n\t\tif (dup2(nullfd, STDERR_FILENO) == -1)\n\t\t\tfatal(\"dup2 failed\");\n\t\tif (nullfd != STDERR_FILENO)\n\t\t\tclose(nullfd);\n\n\t\tclosefrom(STDERR_FILENO + 1);\n\n\t\texecl(_PATH_BSHELL, \"sh\", \"-c\", cmd, (char *) NULL);\n\t\tfatal(\"execl failed\");\n\t}\n\n\t/* parent */\n\tenviron_free(env);\n\tclose(out[1]);\n\n\tjob = xmalloc(sizeof *job);\n\tjob->state = JOB_RUNNING;\n\n\tjob->cmd = xstrdup(cmd);\n\tjob->pid = pid;\n\tjob->status = 0;\n\n\tLIST_INSERT_HEAD(&all_jobs, job, lentry);\n\n\tjob->callbackfn = callbackfn;\n\tjob->freefn = freefn;\n\tjob->data = data;\n\n\tjob->fd = out[0];\n\tsetblocking(job->fd, 0);\n\n\tjob->event = bufferevent_new(job->fd, NULL, job_write_callback,\n\t    job_callback, job);\n\tbufferevent_enable(job->event, EV_READ|EV_WRITE);\n\n\tlog_debug(\"run job %p: %s, pid %ld\", job, job->cmd, (long) job->pid);\n\treturn (job);\n}\n\n/* Kill and free an individual job. */\nvoid\njob_free(struct job *job)\n{\n\tlog_debug(\"free job %p: %s\", job, job->cmd);\n\n\tLIST_REMOVE(job, lentry);\n\tfree(job->cmd);\n\n\tif (job->freefn != NULL && job->data != NULL)\n\t\tjob->freefn(job->data);\n\n\tif (job->pid != -1)\n\t\tkill(job->pid, SIGTERM);\n\tif (job->event != NULL)\n\t\tbufferevent_free(job->event);\n\tif (job->fd != -1)\n\t\tclose(job->fd);\n\n\tfree(job);\n}\n\n/* Called when output buffer falls below low watermark (default is 0). */\nvoid\njob_write_callback(__unused struct bufferevent *bufev, void *data)\n{\n\tstruct job\t*job = data;\n\tsize_t\t\t len = EVBUFFER_LENGTH(EVBUFFER_OUTPUT(job->event));\n\n\tlog_debug(\"job write %p: %s, pid %ld, output left %zu\", job, job->cmd,\n\t    (long) job->pid, len);\n\n\tif (len == 0) {\n\t\tshutdown(job->fd, SHUT_WR);\n\t\tbufferevent_disable(job->event, EV_WRITE);\n\t}\n}\n\n/* Job buffer error callback. */\nvoid\njob_callback(__unused struct bufferevent *bufev, __unused short events,\n    void *data)\n{\n\tstruct job\t*job = data;\n\n\tlog_debug(\"job error %p: %s, pid %ld\", job, job->cmd, (long) job->pid);\n\n\tif (job->state == JOB_DEAD) {\n\t\tif (job->callbackfn != NULL)\n\t\t\tjob->callbackfn(job);\n\t\tjob_free(job);\n\t} else {\n\t\tbufferevent_disable(job->event, EV_READ);\n\t\tjob->state = JOB_CLOSED;\n\t}\n}\n\n/* Job died (waitpid() returned its pid). */\nvoid\njob_died(struct job *job, int status)\n{\n\tlog_debug(\"job died %p: %s, pid %ld\", job, job->cmd, (long) job->pid);\n\n\tjob->status = status;\n\n\tif (job->state == JOB_CLOSED) {\n\t\tif (job->callbackfn != NULL)\n\t\t\tjob->callbackfn(job);\n\t\tjob_free(job);\n\t} else {\n\t\tjob->pid = -1;\n\t\tjob->state = JOB_DEAD;\n\t}\n}\n"
        },
        {
          "name": "key-bindings.c",
          "type": "blob",
          "size": 7.2724609375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <ctype.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\nRB_GENERATE(key_bindings, key_binding, entry, key_bindings_cmp);\nRB_GENERATE(key_tables, key_table, entry, key_table_cmp);\nstruct key_tables key_tables = RB_INITIALIZER(&key_tables);\n\nint\nkey_table_cmp(struct key_table *e1, struct key_table *e2)\n{\n\treturn (strcmp(e1->name, e2->name));\n}\n\nint\nkey_bindings_cmp(struct key_binding *bd1, struct key_binding *bd2)\n{\n\tif (bd1->key < bd2->key)\n\t\treturn (-1);\n\tif (bd1->key > bd2->key)\n\t\treturn (1);\n\treturn (0);\n}\n\nstruct key_table *\nkey_bindings_get_table(const char *name, int create)\n{\n\tstruct key_table\ttable_find, *table;\n\n\ttable_find.name = name;\n\ttable = RB_FIND(key_tables, &key_tables, &table_find);\n\tif (table != NULL || !create)\n\t\treturn (table);\n\n\ttable = xmalloc(sizeof *table);\n\ttable->name = xstrdup(name);\n\tRB_INIT(&table->key_bindings);\n\n\ttable->references = 1; /* one reference in key_tables */\n\tRB_INSERT(key_tables, &key_tables, table);\n\n\treturn (table);\n}\n\nvoid\nkey_bindings_unref_table(struct key_table *table)\n{\n\tstruct key_binding\t*bd;\n\tstruct key_binding\t*bd1;\n\n\tif (--table->references != 0)\n\t\treturn;\n\n\tRB_FOREACH_SAFE(bd, key_bindings, &table->key_bindings, bd1) {\n\t\tRB_REMOVE(key_bindings, &table->key_bindings, bd);\n\t\tcmd_list_free(bd->cmdlist);\n\t\tfree(bd);\n\t}\n\n\tfree((void *)table->name);\n\tfree(table);\n}\n\nvoid\nkey_bindings_add(const char *name, key_code key, int can_repeat,\n    struct cmd_list *cmdlist)\n{\n\tstruct key_table\t*table;\n\tstruct key_binding\t bd_find, *bd;\n\n\ttable = key_bindings_get_table(name, 1);\n\n\tbd_find.key = key;\n\tbd = RB_FIND(key_bindings, &table->key_bindings, &bd_find);\n\tif (bd != NULL) {\n\t\tRB_REMOVE(key_bindings, &table->key_bindings, bd);\n\t\tcmd_list_free(bd->cmdlist);\n\t\tfree(bd);\n\t}\n\n\tbd = xmalloc(sizeof *bd);\n\tbd->key = key;\n\tRB_INSERT(key_bindings, &table->key_bindings, bd);\n\n\tbd->can_repeat = can_repeat;\n\tbd->cmdlist = cmdlist;\n}\n\nvoid\nkey_bindings_remove(const char *name, key_code key)\n{\n\tstruct key_table\t*table;\n\tstruct key_binding\t bd_find, *bd;\n\n\ttable = key_bindings_get_table(name, 0);\n\tif (table == NULL)\n\t\treturn;\n\n\tbd_find.key = key;\n\tbd = RB_FIND(key_bindings, &table->key_bindings, &bd_find);\n\tif (bd == NULL)\n\t\treturn;\n\n\tRB_REMOVE(key_bindings, &table->key_bindings, bd);\n\tcmd_list_free(bd->cmdlist);\n\tfree(bd);\n\n\tif (RB_EMPTY(&table->key_bindings)) {\n\t\tRB_REMOVE(key_tables, &key_tables, table);\n\t\tkey_bindings_unref_table(table);\n\t}\n}\n\nvoid\nkey_bindings_remove_table(const char *name)\n{\n\tstruct key_table\t*table;\n\n\ttable = key_bindings_get_table(name, 0);\n\tif (table != NULL) {\n\t\tRB_REMOVE(key_tables, &key_tables, table);\n\t\tkey_bindings_unref_table(table);\n\t}\n}\n\nvoid\nkey_bindings_init(void)\n{\n\tstatic const char *defaults[] = {\n\t\t\"bind C-b send-prefix\",\n\t\t\"bind C-o rotate-window\",\n\t\t\"bind C-z suspend-client\",\n\t\t\"bind Space next-layout\",\n\t\t\"bind ! break-pane\",\n\t\t\"bind '\\\"' split-window\",\n\t\t\"bind '#' list-buffers\",\n\t\t\"bind '$' command-prompt -I'#S' \\\"rename-session '%%'\\\"\",\n\t\t\"bind % split-window -h\",\n\t\t\"bind & confirm-before -p\\\"kill-window #W? (y/n)\\\" kill-window\",\n\t\t\"bind \\\"'\\\" command-prompt -pindex \\\"select-window -t ':%%'\\\"\",\n\t\t\"bind ( switch-client -p\",\n\t\t\"bind ) switch-client -n\",\n\t\t\"bind , command-prompt -I'#W' \\\"rename-window '%%'\\\"\",\n\t\t\"bind - delete-buffer\",\n\t\t\"bind . command-prompt \\\"move-window -t '%%'\\\"\",\n\t\t\"bind 0 select-window -t:=0\",\n\t\t\"bind 1 select-window -t:=1\",\n\t\t\"bind 2 select-window -t:=2\",\n\t\t\"bind 3 select-window -t:=3\",\n\t\t\"bind 4 select-window -t:=4\",\n\t\t\"bind 5 select-window -t:=5\",\n\t\t\"bind 6 select-window -t:=6\",\n\t\t\"bind 7 select-window -t:=7\",\n\t\t\"bind 8 select-window -t:=8\",\n\t\t\"bind 9 select-window -t:=9\",\n\t\t\"bind : command-prompt\",\n\t\t\"bind \\\\; last-pane\",\n\t\t\"bind = choose-buffer\",\n\t\t\"bind ? list-keys\",\n\t\t\"bind D choose-client\",\n\t\t\"bind L switch-client -l\",\n\t\t\"bind M select-pane -M\",\n\t\t\"bind [ copy-mode\",\n\t\t\"bind ] paste-buffer\",\n\t\t\"bind c new-window\",\n\t\t\"bind d detach-client\",\n\t\t\"bind f command-prompt \\\"find-window '%%'\\\"\",\n\t\t\"bind i display-message\",\n\t\t\"bind l last-window\",\n\t\t\"bind m select-pane -m\",\n\t\t\"bind n next-window\",\n\t\t\"bind o select-pane -t:.+\",\n\t\t\"bind p previous-window\",\n\t\t\"bind q display-panes\",\n\t\t\"bind r refresh-client\",\n\t\t\"bind s choose-tree\",\n\t\t\"bind t clock-mode\",\n\t\t\"bind w choose-window\",\n\t\t\"bind x confirm-before -p\\\"kill-pane #P? (y/n)\\\" kill-pane\",\n\t\t\"bind z resize-pane -Z\",\n\t\t\"bind { swap-pane -U\",\n\t\t\"bind } swap-pane -D\",\n\t\t\"bind '~' show-messages\",\n\t\t\"bind PPage copy-mode -u\",\n\t\t\"bind -r Up select-pane -U\",\n\t\t\"bind -r Down select-pane -D\",\n\t\t\"bind -r Left select-pane -L\",\n\t\t\"bind -r Right select-pane -R\",\n\t\t\"bind M-1 select-layout even-horizontal\",\n\t\t\"bind M-2 select-layout even-vertical\",\n\t\t\"bind M-3 select-layout main-horizontal\",\n\t\t\"bind M-4 select-layout main-vertical\",\n\t\t\"bind M-5 select-layout tiled\",\n\t\t\"bind M-n next-window -a\",\n\t\t\"bind M-o rotate-window -D\",\n\t\t\"bind M-p previous-window -a\",\n\t\t\"bind -r M-Up resize-pane -U 5\",\n\t\t\"bind -r M-Down resize-pane -D 5\",\n\t\t\"bind -r M-Left resize-pane -L 5\",\n\t\t\"bind -r M-Right resize-pane -R 5\",\n\t\t\"bind -r C-Up resize-pane -U\",\n\t\t\"bind -r C-Down resize-pane -D\",\n\t\t\"bind -r C-Left resize-pane -L\",\n\t\t\"bind -r C-Right resize-pane -R\",\n\t\t\"bind -n MouseDown1Pane select-pane -t=\\\\; send-keys -M\",\n\t\t\"bind -n MouseDrag1Border resize-pane -M\",\n\t\t\"bind -n MouseDown1Status select-window -t=\",\n\t\t\"bind -n WheelDownStatus next-window\",\n\t\t\"bind -n WheelUpStatus previous-window\",\n\t\t\"bind -n MouseDrag1Pane if -Ft= '#{mouse_any_flag}' 'if -Ft= \\\"#{pane_in_mode}\\\" \\\"copy-mode -M\\\" \\\"send-keys -M\\\"' 'copy-mode -M'\",\n\t\t\"bind -n MouseDown3Pane if-shell -Ft= '#{mouse_any_flag}' 'select-pane -t=; send-keys -M' 'select-pane -mt='\",\n\t\t\"bind -n WheelUpPane if-shell -Ft= '#{mouse_any_flag}' 'send-keys -M' 'if -Ft= \\\"#{pane_in_mode}\\\" \\\"send-keys -M\\\" \\\"copy-mode -et=\\\"'\",\n\t};\n\tu_int\t\t i;\n\tstruct cmd_list\t*cmdlist;\n\tchar\t\t*cause;\n\tint\t\t error;\n\tstruct cmd_q\t*cmdq;\n\n\tcmdq = cmdq_new(NULL);\n\tfor (i = 0; i < nitems(defaults); i++) {\n\t\terror = cmd_string_parse(defaults[i], &cmdlist,\n\t\t    \"<default-keys>\", i, &cause);\n\t\tif (error != 0)\n\t\t\tfatalx(\"bad default key\");\n\t\tcmdq_run(cmdq, cmdlist, NULL);\n\t\tcmd_list_free(cmdlist);\n\t}\n\tcmdq_free(cmdq);\n}\n\nvoid\nkey_bindings_dispatch(struct key_binding *bd, struct client *c,\n    struct mouse_event *m)\n{\n\tstruct cmd\t*cmd;\n\tint\t\t readonly;\n\n\treadonly = 1;\n\tTAILQ_FOREACH(cmd, &bd->cmdlist->list, qentry) {\n\t\tif (!(cmd->entry->flags & CMD_READONLY))\n\t\t\treadonly = 0;\n\t}\n\tif (!readonly && (c->flags & CLIENT_READONLY)) {\n\t\tcmdq_error(c->cmdq, \"client is read-only\");\n\t\treturn;\n\t}\n\n\tcmdq_run(c->cmdq, bd->cmdlist, m);\n}\n"
        },
        {
          "name": "key-string.c",
          "type": "blob",
          "size": 7.3515625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <string.h>\n\n#include \"tmux.h\"\n\nstatic key_code\tkey_string_search_table(const char *);\nstatic key_code\tkey_string_get_modifiers(const char **);\n\nconst struct {\n\tconst char     *string;\n\tkey_code\tkey;\n} key_string_table[] = {\n\t/* Function keys. */\n\t{ \"F1\",\t\tKEYC_F1 },\n\t{ \"F2\",\t\tKEYC_F2 },\n\t{ \"F3\",\t\tKEYC_F3 },\n\t{ \"F4\",\t\tKEYC_F4 },\n\t{ \"F5\",\t\tKEYC_F5 },\n\t{ \"F6\",\t\tKEYC_F6 },\n\t{ \"F7\",\t\tKEYC_F7 },\n\t{ \"F8\",\t\tKEYC_F8 },\n\t{ \"F9\",\t\tKEYC_F9 },\n\t{ \"F10\",\tKEYC_F10 },\n\t{ \"F11\",\tKEYC_F11 },\n\t{ \"F12\",\tKEYC_F12 },\n\t{ \"IC\",\t\tKEYC_IC },\n\t{ \"DC\",\t\tKEYC_DC },\n\t{ \"Home\",\tKEYC_HOME },\n\t{ \"End\",\tKEYC_END },\n\t{ \"NPage\",\tKEYC_NPAGE },\n\t{ \"PageDown\",\tKEYC_NPAGE },\n\t{ \"PgDn\",\tKEYC_NPAGE },\n\t{ \"PPage\",\tKEYC_PPAGE },\n\t{ \"PageUp\",\tKEYC_PPAGE },\n\t{ \"PgUp\",\tKEYC_PPAGE },\n\t{ \"Tab\",\t'\\011' },\n\t{ \"BTab\",\tKEYC_BTAB },\n\t{ \"Space\",\t' ' },\n\t{ \"BSpace\",\tKEYC_BSPACE },\n\t{ \"Enter\",\t'\\r' },\n\t{ \"Escape\",\t'\\033' },\n\n\t/* Arrow keys. */\n\t{ \"Up\",\t\tKEYC_UP },\n\t{ \"Down\",\tKEYC_DOWN },\n\t{ \"Left\",\tKEYC_LEFT },\n\t{ \"Right\",\tKEYC_RIGHT },\n\n\t/* Numeric keypad. */\n\t{ \"KP/\", \tKEYC_KP_SLASH },\n\t{ \"KP*\",\tKEYC_KP_STAR },\n\t{ \"KP-\",\tKEYC_KP_MINUS },\n\t{ \"KP7\",\tKEYC_KP_SEVEN },\n\t{ \"KP8\",\tKEYC_KP_EIGHT },\n\t{ \"KP9\",\tKEYC_KP_NINE },\n\t{ \"KP+\",\tKEYC_KP_PLUS },\n\t{ \"KP4\",\tKEYC_KP_FOUR },\n\t{ \"KP5\",\tKEYC_KP_FIVE },\n\t{ \"KP6\",\tKEYC_KP_SIX },\n\t{ \"KP1\",\tKEYC_KP_ONE },\n\t{ \"KP2\",\tKEYC_KP_TWO },\n\t{ \"KP3\",\tKEYC_KP_THREE },\n\t{ \"KPEnter\",\tKEYC_KP_ENTER },\n\t{ \"KP0\",\tKEYC_KP_ZERO },\n\t{ \"KP.\",\tKEYC_KP_PERIOD },\n\n\t/* Mouse keys. */\n\tKEYC_MOUSE_STRING(MOUSEDOWN1, MouseDown1),\n\tKEYC_MOUSE_STRING(MOUSEDOWN2, MouseDown2),\n\tKEYC_MOUSE_STRING(MOUSEDOWN3, MouseDown3),\n\tKEYC_MOUSE_STRING(MOUSEUP1, MouseUp1),\n\tKEYC_MOUSE_STRING(MOUSEUP2, MouseUp2),\n\tKEYC_MOUSE_STRING(MOUSEUP3, MouseUp3),\n\tKEYC_MOUSE_STRING(MOUSEDRAG1, MouseDrag1),\n\tKEYC_MOUSE_STRING(MOUSEDRAG2, MouseDrag2),\n\tKEYC_MOUSE_STRING(MOUSEDRAG3, MouseDrag3),\n\tKEYC_MOUSE_STRING(MOUSEDRAGEND1, MouseDragEnd1),\n\tKEYC_MOUSE_STRING(MOUSEDRAGEND2, MouseDragEnd2),\n\tKEYC_MOUSE_STRING(MOUSEDRAGEND3, MouseDragEnd3),\n\tKEYC_MOUSE_STRING(WHEELUP, WheelUp),\n\tKEYC_MOUSE_STRING(WHEELDOWN, WheelDown),\n};\n\n/* Find key string in table. */\nstatic key_code\nkey_string_search_table(const char *string)\n{\n\tu_int\ti;\n\n\tfor (i = 0; i < nitems(key_string_table); i++) {\n\t\tif (strcasecmp(string, key_string_table[i].string) == 0)\n\t\t\treturn (key_string_table[i].key);\n\t}\n\treturn (KEYC_UNKNOWN);\n}\n\n/* Find modifiers. */\nstatic key_code\nkey_string_get_modifiers(const char **string)\n{\n\tkey_code\tmodifiers;\n\n\tmodifiers = 0;\n\twhile (((*string)[0] != '\\0') && (*string)[1] == '-') {\n\t\tswitch ((*string)[0]) {\n\t\tcase 'C':\n\t\tcase 'c':\n\t\t\tmodifiers |= KEYC_CTRL;\n\t\t\tbreak;\n\t\tcase 'M':\n\t\tcase 'm':\n\t\t\tmodifiers |= KEYC_ESCAPE;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\tcase 's':\n\t\t\tmodifiers |= KEYC_SHIFT;\n\t\t\tbreak;\n\t\t}\n\t\t*string += 2;\n\t}\n\treturn (modifiers);\n}\n\n/* Lookup a string and convert to a key value. */\nkey_code\nkey_string_lookup_string(const char *string)\n{\n\tstatic const char\t*other = \"!#()+,-.0123456789:;<=>?'\\r\\t\";\n\tkey_code\t\t key;\n\tu_short\t\t\t u;\n\tint\t\t\t size;\n\tkey_code\t\t modifiers;\n\tstruct utf8_data\t ud;\n\tu_int\t\t\t i;\n\tenum utf8_state\t\t more;\n\twchar_t\t\t\t wc;\n\n\t/* Is this no key? */\n\tif (strcasecmp(string, \"None\") == 0)\n\t\treturn (KEYC_NONE);\n\n\t/* Is this a hexadecimal value? */\n\tif (string[0] == '0' && string[1] == 'x') {\n\t        if (sscanf(string + 2, \"%hx%n\", &u, &size) != 1 || size > 4)\n\t                return (KEYC_UNKNOWN);\n\t        return (u);\n\t}\n\n\t/* Check for modifiers. */\n\tmodifiers = 0;\n\tif (string[0] == '^' && string[1] != '\\0') {\n\t\tmodifiers |= KEYC_CTRL;\n\t\tstring++;\n\t}\n\tmodifiers |= key_string_get_modifiers(&string);\n\tif (string[0] == '\\0')\n\t\treturn (KEYC_UNKNOWN);\n\n\t/* Is this a standard ASCII key? */\n\tif (string[1] == '\\0' && (u_char)string[0] <= 127) {\n\t\tkey = (u_char)string[0];\n\t\tif (key < 32 || key == 127)\n\t\t\treturn (KEYC_UNKNOWN);\n\t} else {\n\t\t/* Try as a UTF-8 key. */\n\t\tif ((more = utf8_open(&ud, (u_char)*string)) == UTF8_MORE) {\n\t\t\tif (strlen(string) != ud.size)\n\t\t\t\treturn (KEYC_UNKNOWN);\n\t\t\tfor (i = 1; i < ud.size; i++)\n\t\t\t\tmore = utf8_append(&ud, (u_char)string[i]);\n\t\t\tif (more != UTF8_DONE)\n\t\t\t\treturn (KEYC_UNKNOWN);\n\t\t\tif (utf8_combine(&ud, &wc) != UTF8_DONE)\n\t\t\t\treturn (KEYC_UNKNOWN);\n\t\t\treturn (wc | modifiers);\n\t\t}\n\n\t\t/* Otherwise look the key up in the table. */\n\t\tkey = key_string_search_table(string);\n\t\tif (key == KEYC_UNKNOWN)\n\t\t\treturn (KEYC_UNKNOWN);\n\t}\n\n\t/* Convert the standard control keys. */\n\tif (key < KEYC_BASE && (modifiers & KEYC_CTRL) && !strchr(other, key)) {\n\t\tif (key >= 97 && key <= 122)\n\t\t\tkey -= 96;\n\t\telse if (key >= 64 && key <= 95)\n\t\t\tkey -= 64;\n\t\telse if (key == 32)\n\t\t\tkey = 0;\n\t\telse if (key == 63)\n\t\t\tkey = KEYC_BSPACE;\n\t\telse\n\t\t\treturn (KEYC_UNKNOWN);\n\t\tmodifiers &= ~KEYC_CTRL;\n\t}\n\n\treturn (key | modifiers);\n}\n\n/* Convert a key code into string format, with prefix if necessary. */\nconst char *\nkey_string_lookup_key(key_code key)\n{\n\tstatic char\t\tout[24];\n\tchar\t\t\ttmp[8];\n\tu_int\t\t\ti;\n\tstruct utf8_data\tud;\n\n\t*out = '\\0';\n\n\t/* Handle no key. */\n\tif (key == KEYC_NONE)\n\t\treturn (\"None\");\n\n\t/* Handle special keys. */\n\tif (key == KEYC_UNKNOWN)\n\t\treturn (\"Unknown\");\n\tif (key == KEYC_MOUSE)\n\t\treturn (\"Mouse\");\n\n\t/*\n\t * Special case: display C-@ as C-Space. Could do this below in\n\t * the (key >= 0 && key <= 32), but this way we let it be found\n\t * in key_string_table, for the unlikely chance that we might\n\t * change its name.\n\t */\n\tif ((key & KEYC_MASK_KEY) == 0)\n\t    key = ' ' | KEYC_CTRL | (key & KEYC_MASK_MOD);\n\n\t/* Fill in the modifiers. */\n\tif (key & KEYC_CTRL)\n\t\tstrlcat(out, \"C-\", sizeof out);\n\tif (key & KEYC_ESCAPE)\n\t\tstrlcat(out, \"M-\", sizeof out);\n\tif (key & KEYC_SHIFT)\n\t\tstrlcat(out, \"S-\", sizeof out);\n\tkey &= KEYC_MASK_KEY;\n\n\t/* Try the key against the string table. */\n\tfor (i = 0; i < nitems(key_string_table); i++) {\n\t\tif (key == key_string_table[i].key)\n\t\t\tbreak;\n\t}\n\tif (i != nitems(key_string_table)) {\n\t\tstrlcat(out, key_string_table[i].string, sizeof out);\n\t\treturn (out);\n\t}\n\n\t/* Is this a UTF-8 key? */\n\tif (key > 127 && key < KEYC_BASE) {\n\t\tif (utf8_split(key, &ud) == UTF8_DONE) {\n\t\t\tmemcpy(out, ud.data, ud.size);\n\t\t\tout[ud.size] = '\\0';\n\t\t\treturn (out);\n\t\t}\n\t}\n\n\t/* Invalid keys are errors. */\n\tif (key == 127 || key > 255) {\n\t\tsnprintf(out, sizeof out, \"Invalid#%llx\", key);\n\t\treturn (out);\n\t}\n\n\t/* Check for standard or control key. */\n\tif (key <= 32) {\n\t\tif (key == 0 || key > 26)\n\t\t\txsnprintf(tmp, sizeof tmp, \"C-%c\", (int)(64 + key));\n\t\telse\n\t\t\txsnprintf(tmp, sizeof tmp, \"C-%c\", (int)(96 + key));\n\t} else if (key >= 32 && key <= 126) {\n\t\ttmp[0] = key;\n\t\ttmp[1] = '\\0';\n\t} else if (key >= 128)\n\t\txsnprintf(tmp, sizeof tmp, \"\\\\%llo\", key);\n\n\tstrlcat(out, tmp, sizeof out);\n\treturn (out);\n}\n"
        },
        {
          "name": "layout-custom.c",
          "type": "blob",
          "size": 6.4267578125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2010 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <ctype.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\nstruct layout_cell     *layout_find_bottomright(struct layout_cell *);\nu_short\t\t\tlayout_checksum(const char *);\nint\t\t\tlayout_append(struct layout_cell *, char *, size_t);\nstruct layout_cell     *layout_construct(struct layout_cell *, const char **);\nvoid\t\t\tlayout_assign(struct window_pane **, struct layout_cell *);\n\n/* Find the bottom-right cell. */\nstruct layout_cell *\nlayout_find_bottomright(struct layout_cell *lc)\n{\n\tif (lc->type == LAYOUT_WINDOWPANE)\n\t\treturn (lc);\n\tlc = TAILQ_LAST(&lc->cells, layout_cells);\n\treturn (layout_find_bottomright(lc));\n}\n\n/* Calculate layout checksum. */\nu_short\nlayout_checksum(const char *layout)\n{\n\tu_short\tcsum;\n\n\tcsum = 0;\n\tfor (; *layout != '\\0'; layout++) {\n\t\tcsum = (csum >> 1) + ((csum & 1) << 15);\n\t\tcsum += *layout;\n\t}\n\treturn (csum);\n}\n\n/* Dump layout as a string. */\nchar *\nlayout_dump(struct layout_cell *root)\n{\n\tchar\tlayout[BUFSIZ], *out;\n\n\t*layout = '\\0';\n\tif (layout_append(root, layout, sizeof layout) != 0)\n\t\treturn (NULL);\n\n\txasprintf(&out, \"%04x,%s\", layout_checksum(layout), layout);\n\treturn (out);\n}\n\n/* Append information for a single cell. */\nint\nlayout_append(struct layout_cell *lc, char *buf, size_t len)\n{\n\tstruct layout_cell     *lcchild;\n\tchar\t\t\ttmp[64];\n\tsize_t\t\t\ttmplen;\n\tconst char\t       *brackets = \"][\";\n\n\tif (len == 0)\n\t\treturn (-1);\n\n\tif (lc->wp != NULL) {\n\t\ttmplen = xsnprintf(tmp, sizeof tmp, \"%ux%u,%u,%u,%u\",\n\t\t    lc->sx, lc->sy, lc->xoff, lc->yoff, lc->wp->id);\n\t} else {\n\t\ttmplen = xsnprintf(tmp, sizeof tmp, \"%ux%u,%u,%u\",\n\t\t    lc->sx, lc->sy, lc->xoff, lc->yoff);\n\t}\n\tif (tmplen > (sizeof tmp) - 1)\n\t\treturn (-1);\n\tif (strlcat(buf, tmp, len) >= len)\n\t\treturn (-1);\n\n\tswitch (lc->type) {\n\tcase LAYOUT_LEFTRIGHT:\n\t\tbrackets = \"}{\";\n\t\t/* FALLTHROUGH */\n\tcase LAYOUT_TOPBOTTOM:\n\t\tif (strlcat(buf, &brackets[1], len) >= len)\n\t\t\treturn (-1);\n\t\tTAILQ_FOREACH(lcchild, &lc->cells, entry) {\n\t\t\tif (layout_append(lcchild, buf, len) != 0)\n\t\t\t\treturn (-1);\n\t\t\tif (strlcat(buf, \",\", len) >= len)\n\t\t\t\treturn (-1);\n\t\t}\n\t\tbuf[strlen(buf) - 1] = brackets[0];\n\t\tbreak;\n\tcase LAYOUT_WINDOWPANE:\n\t\tbreak;\n\t}\n\n\treturn (0);\n}\n\n/* Parse a layout string and arrange window as layout. */\nint\nlayout_parse(struct window *w, const char *layout)\n{\n\tstruct layout_cell\t*lc, *lcchild;\n\tstruct window_pane\t*wp;\n\tu_int\t\t\t npanes, ncells, sx, sy;\n\tu_short\t\t\t csum;\n\n\t/* Check validity. */\n\tif (sscanf(layout, \"%hx,\", &csum) != 1)\n\t\treturn (-1);\n\tlayout += 5;\n\tif (csum != layout_checksum(layout))\n\t\treturn (-1);\n\n\t/* Build the layout. */\n\tlc = layout_construct(NULL, &layout);\n\tif (lc == NULL)\n\t\treturn (-1);\n\tif (*layout != '\\0')\n\t\tgoto fail;\n\n\t/* Check this window will fit into the layout. */\n\tfor (;;) {\n\t\tnpanes = window_count_panes(w);\n\t\tncells = layout_count_cells(lc);\n\t\tif (npanes > ncells)\n\t\t\tgoto fail;\n\t\tif (npanes == ncells)\n\t\t\tbreak;\n\n\t\t/* Fewer panes than cells - close the bottom right. */\n\t\tlcchild = layout_find_bottomright(lc);\n\t\tlayout_destroy_cell(lcchild, &lc);\n\t}\n\n\t/* Save the old window size and resize to the layout size. */\n\tsx = w->sx; sy = w->sy;\n\twindow_resize(w, lc->sx, lc->sy);\n\n\t/* Destroy the old layout and swap to the new. */\n\tlayout_free_cell(w->layout_root);\n\tw->layout_root = lc;\n\n\t/* Assign the panes into the cells. */\n\twp = TAILQ_FIRST(&w->panes);\n\tlayout_assign(&wp, lc);\n\n\t/* Update pane offsets and sizes. */\n\tlayout_fix_offsets(lc);\n\tlayout_fix_panes(w, lc->sx, lc->sy);\n\n\t/* Then resize the layout back to the original window size. */\n\tlayout_resize(w, sx, sy);\n\twindow_resize(w, sx, sy);\n\n\tlayout_print_cell(lc, __func__, 0);\n\n\tnotify_window_layout_changed(w);\n\n\treturn (0);\n\nfail:\n\tlayout_free_cell(lc);\n\treturn (-1);\n}\n\n/* Assign panes into cells. */\nvoid\nlayout_assign(struct window_pane **wp, struct layout_cell *lc)\n{\n\tstruct layout_cell\t*lcchild;\n\n\tswitch (lc->type) {\n\tcase LAYOUT_WINDOWPANE:\n\t\tlayout_make_leaf(lc, *wp);\n\t\t*wp = TAILQ_NEXT(*wp, entry);\n\t\treturn;\n\tcase LAYOUT_LEFTRIGHT:\n\tcase LAYOUT_TOPBOTTOM:\n\t\tTAILQ_FOREACH(lcchild, &lc->cells, entry)\n\t\t\tlayout_assign(wp, lcchild);\n\t\treturn;\n\t}\n}\n\n/* Construct a cell from all or part of a layout tree. */\nstruct layout_cell *\nlayout_construct(struct layout_cell *lcparent, const char **layout)\n{\n\tstruct layout_cell     *lc, *lcchild;\n\tu_int\t\t\tsx, sy, xoff, yoff;\n\tconst char\t       *saved;\n\n\tif (!isdigit((u_char) **layout))\n\t\treturn (NULL);\n\tif (sscanf(*layout, \"%ux%u,%u,%u\", &sx, &sy, &xoff, &yoff) != 4)\n\t\treturn (NULL);\n\n\twhile (isdigit((u_char) **layout))\n\t\t(*layout)++;\n\tif (**layout != 'x')\n\t\treturn (NULL);\n\t(*layout)++;\n\twhile (isdigit((u_char) **layout))\n\t\t(*layout)++;\n\tif (**layout != ',')\n\t\treturn (NULL);\n\t(*layout)++;\n\twhile (isdigit((u_char) **layout))\n\t\t(*layout)++;\n\tif (**layout != ',')\n\t\treturn (NULL);\n\t(*layout)++;\n\twhile (isdigit((u_char) **layout))\n\t\t(*layout)++;\n\tif (**layout == ',') {\n\t\tsaved = *layout;\n\t\t(*layout)++;\n\t\twhile (isdigit((u_char) **layout))\n\t\t\t(*layout)++;\n\t\tif (**layout == 'x')\n\t\t\t*layout = saved;\n\t}\n\n\tlc = layout_create_cell(lcparent);\n\tlc->sx = sx;\n\tlc->sy = sy;\n\tlc->xoff = xoff;\n\tlc->yoff = yoff;\n\n\tswitch (**layout) {\n\tcase ',':\n\tcase '}':\n\tcase ']':\n\tcase '\\0':\n\t\treturn (lc);\n\tcase '{':\n\t\tlc->type = LAYOUT_LEFTRIGHT;\n\t\tbreak;\n\tcase '[':\n\t\tlc->type = LAYOUT_TOPBOTTOM;\n\t\tbreak;\n\tdefault:\n\t\tgoto fail;\n\t}\n\n\tdo {\n\t\t(*layout)++;\n\t\tlcchild = layout_construct(lc, layout);\n\t\tif (lcchild == NULL)\n\t\t\tgoto fail;\n\t\tTAILQ_INSERT_TAIL(&lc->cells, lcchild, entry);\n\t} while (**layout == ',');\n\n\tswitch (lc->type) {\n\tcase LAYOUT_LEFTRIGHT:\n\t\tif (**layout != '}')\n\t\t\tgoto fail;\n\t\tbreak;\n\tcase LAYOUT_TOPBOTTOM:\n\t\tif (**layout != ']')\n\t\t\tgoto fail;\n\t\tbreak;\n\tdefault:\n\t\tgoto fail;\n\t}\n\t(*layout)++;\n\n\treturn (lc);\n\nfail:\n\tlayout_free_cell(lc);\n\treturn (NULL);\n}\n"
        },
        {
          "name": "layout-set.c",
          "type": "blob",
          "size": 14.640625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * Set window layouts - predefined methods to arrange windows. These are\n * one-off and generate a layout tree.\n */\n\nvoid\tlayout_set_even_h(struct window *);\nvoid\tlayout_set_even_v(struct window *);\nvoid\tlayout_set_main_h(struct window *);\nvoid\tlayout_set_main_v(struct window *);\nvoid\tlayout_set_tiled(struct window *);\n\nconst struct {\n\tconst char\t*name;\n\tvoid\t      \t(*arrange)(struct window *);\n} layout_sets[] = {\n\t{ \"even-horizontal\", layout_set_even_h },\n\t{ \"even-vertical\", layout_set_even_v },\n\t{ \"main-horizontal\", layout_set_main_h },\n\t{ \"main-vertical\", layout_set_main_v },\n\t{ \"tiled\", layout_set_tiled },\n};\n\nint\nlayout_set_lookup(const char *name)\n{\n\tu_int\ti;\n\tint\tmatched = -1;\n\n\tfor (i = 0; i < nitems(layout_sets); i++) {\n\t\tif (strncmp(layout_sets[i].name, name, strlen(name)) == 0) {\n\t\t\tif (matched != -1)\t/* ambiguous */\n\t\t\t\treturn (-1);\n\t\t\tmatched = i;\n\t\t}\n\t}\n\n\treturn (matched);\n}\n\nu_int\nlayout_set_select(struct window *w, u_int layout)\n{\n\tif (layout > nitems(layout_sets) - 1)\n\t\tlayout = nitems(layout_sets) - 1;\n\n\tif (layout_sets[layout].arrange != NULL)\n\t\tlayout_sets[layout].arrange(w);\n\n\tw->lastlayout = layout;\n\treturn (layout);\n}\n\nu_int\nlayout_set_next(struct window *w)\n{\n\tu_int\tlayout;\n\n\tif (w->lastlayout == -1)\n\t\tlayout = 0;\n\telse {\n\t\tlayout = w->lastlayout + 1;\n\t\tif (layout > nitems(layout_sets) - 1)\n\t\t\tlayout = 0;\n\t}\n\n\tif (layout_sets[layout].arrange != NULL)\n\t\tlayout_sets[layout].arrange(w);\n\tw->lastlayout = layout;\n\treturn (layout);\n}\n\nu_int\nlayout_set_previous(struct window *w)\n{\n\tu_int\tlayout;\n\n\tif (w->lastlayout == -1)\n\t\tlayout = nitems(layout_sets) - 1;\n\telse {\n\t\tlayout = w->lastlayout;\n\t\tif (layout == 0)\n\t\t\tlayout = nitems(layout_sets) - 1;\n\t\telse\n\t\t\tlayout--;\n\t}\n\n\tif (layout_sets[layout].arrange != NULL)\n\t\tlayout_sets[layout].arrange(w);\n\tw->lastlayout = layout;\n\treturn (layout);\n}\n\nvoid\nlayout_set_even_h(struct window *w)\n{\n\tstruct window_pane\t*wp;\n\tstruct layout_cell\t*lc, *lcnew;\n\tu_int\t\t\t i, n, width, xoff;\n\n\tlayout_print_cell(w->layout_root, __func__, 1);\n\n\t/* Get number of panes. */\n\tn = window_count_panes(w);\n\tif (n <= 1)\n\t\treturn;\n\n\t/* How many can we fit? */\n\twidth = (w->sx - (n - 1)) / n;\n\tif (width < PANE_MINIMUM)\n\t\twidth = PANE_MINIMUM;\n\n\t/* Free the old root and construct a new. */\n\tlayout_free(w);\n\tlc = w->layout_root = layout_create_cell(NULL);\n\tlayout_set_size(lc, w->sx, w->sy, 0, 0);\n\tlayout_make_node(lc, LAYOUT_LEFTRIGHT);\n\n\t/* Build new leaf cells. */\n\ti = xoff = 0;\n\tTAILQ_FOREACH(wp, &w->panes, entry) {\n\t\t/* Create child cell. */\n\t\tlcnew = layout_create_cell(lc);\n\t\tlayout_set_size(lcnew, width, w->sy, xoff, 0);\n\t\tlayout_make_leaf(lcnew, wp);\n\t\tTAILQ_INSERT_TAIL(&lc->cells, lcnew, entry);\n\n\t\ti++;\n\t\txoff += width + 1;\n\t}\n\n\t/* Allocate any remaining space. */\n\tif (w->sx > xoff - 1) {\n\t\tlc = TAILQ_LAST(&lc->cells, layout_cells);\n\t\tlayout_resize_adjust(lc, LAYOUT_LEFTRIGHT, w->sx - (xoff - 1));\n\t}\n\n\t/* Fix cell offsets. */\n\tlayout_fix_offsets(lc);\n\tlayout_fix_panes(w, w->sx, w->sy);\n\n\tlayout_print_cell(w->layout_root, __func__, 1);\n\n\tserver_redraw_window(w);\n}\n\nvoid\nlayout_set_even_v(struct window *w)\n{\n\tstruct window_pane\t*wp;\n\tstruct layout_cell\t*lc, *lcnew;\n\tu_int\t\t\t i, n, height, yoff;\n\n\tlayout_print_cell(w->layout_root, __func__, 1);\n\n\t/* Get number of panes. */\n\tn = window_count_panes(w);\n\tif (n <= 1)\n\t\treturn;\n\n\t/* How many can we fit? */\n\theight = (w->sy - (n - 1)) / n;\n\tif (height < PANE_MINIMUM)\n\t\theight = PANE_MINIMUM;\n\n\t/* Free the old root and construct a new. */\n\tlayout_free(w);\n\tlc = w->layout_root = layout_create_cell(NULL);\n\tlayout_set_size(lc, w->sx, w->sy, 0, 0);\n\tlayout_make_node(lc, LAYOUT_TOPBOTTOM);\n\n\t/* Build new leaf cells. */\n\ti = yoff = 0;\n\tTAILQ_FOREACH(wp, &w->panes, entry) {\n\t\t/* Create child cell. */\n\t\tlcnew = layout_create_cell(lc);\n\t\tlayout_set_size(lcnew, w->sx, height, 0, yoff);\n\t\tlayout_make_leaf(lcnew, wp);\n\t\tTAILQ_INSERT_TAIL(&lc->cells, lcnew, entry);\n\n\t\ti++;\n\t\tyoff += height + 1;\n\t}\n\n\t/* Allocate any remaining space. */\n\tif (w->sy > yoff - 1) {\n\t\tlc = TAILQ_LAST(&lc->cells, layout_cells);\n\t\tlayout_resize_adjust(lc, LAYOUT_TOPBOTTOM, w->sy - (yoff - 1));\n\t}\n\n\t/* Fix cell offsets. */\n\tlayout_fix_offsets(lc);\n\tlayout_fix_panes(w, w->sx, w->sy);\n\n\tlayout_print_cell(w->layout_root, __func__, 1);\n\n\tserver_redraw_window(w);\n}\n\nvoid\nlayout_set_main_h(struct window *w)\n{\n\tstruct window_pane\t*wp;\n\tstruct layout_cell\t*lc, *lcmain, *lcrow, *lcchild;\n\tu_int\t\t\t n, mainheight, otherheight, width, height;\n\tu_int\t\t\t used, i, j, columns, rows, totalrows;\n\n\tlayout_print_cell(w->layout_root, __func__, 1);\n\n\t/* Get number of panes. */\n\tn = window_count_panes(w);\n\tif (n <= 1)\n\t\treturn;\n\tn--;\t/* take off main pane */\n\n\t/* How many rows and columns will be needed, not counting main? */\n\tcolumns = (w->sx + 1) / (PANE_MINIMUM + 1);\t/* maximum columns */\n\tif (columns == 0)\n\t\tcolumns = 1;\n\trows = 1 + (n - 1) / columns;\n\tcolumns = 1 + (n - 1) / rows;\n\twidth = (w->sx - (n - 1)) / columns;\n\n\t/* Get the main pane height and add one for separator line. */\n\tmainheight = options_get_number(w->options, \"main-pane-height\") + 1;\n\n\t/* Get the optional other pane height and add one for separator line. */\n\totherheight = options_get_number(w->options, \"other-pane-height\") + 1;\n\n\t/*\n\t * If an other pane height was specified, honour it so long as it\n\t * doesn't shrink the main height to less than the main-pane-height\n\t */\n\tif (otherheight > 1 && w->sy - otherheight > mainheight)\n\t\tmainheight = w->sy - otherheight;\n\tif (mainheight < PANE_MINIMUM + 1)\n\t\tmainheight = PANE_MINIMUM + 1;\n\n\t/* Try and make everything fit. */\n\ttotalrows = rows * (PANE_MINIMUM + 1) - 1;\n\tif (mainheight + totalrows > w->sy) {\n\t\tif (totalrows + PANE_MINIMUM + 1 > w->sy)\n\t\t\tmainheight = PANE_MINIMUM + 2;\n\t\telse\n\t\t\tmainheight = w->sy - totalrows;\n\t\theight = PANE_MINIMUM;\n\t} else\n\t\theight = (w->sy - mainheight - (rows - 1)) / rows;\n\n\t/* Free old tree and create a new root. */\n\tlayout_free(w);\n\tlc = w->layout_root = layout_create_cell(NULL);\n\tlayout_set_size(lc, w->sx, mainheight + rows * (height + 1) - 1, 0, 0);\n\tlayout_make_node(lc, LAYOUT_TOPBOTTOM);\n\n\t/* Create the main pane. */\n\tlcmain = layout_create_cell(lc);\n\tlayout_set_size(lcmain, w->sx, mainheight - 1, 0, 0);\n\tlayout_make_leaf(lcmain, TAILQ_FIRST(&w->panes));\n\tTAILQ_INSERT_TAIL(&lc->cells, lcmain, entry);\n\n\t/* Create a grid of the remaining cells. */\n\twp = TAILQ_NEXT(TAILQ_FIRST(&w->panes), entry);\n\tfor (j = 0; j < rows; j++) {\n\t\t/* If this is the last cell, all done. */\n\t\tif (wp == NULL)\n\t\t\tbreak;\n\n\t\t/* Create the new row. */\n\t\tlcrow = layout_create_cell(lc);\n\t\tlayout_set_size(lcrow, w->sx, height, 0, 0);\n\t\tTAILQ_INSERT_TAIL(&lc->cells, lcrow, entry);\n\n\t\t/* If only one column, just use the row directly. */\n\t\tif (columns == 1) {\n\t\t\tlayout_make_leaf(lcrow, wp);\n\t\t\twp = TAILQ_NEXT(wp, entry);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Add in the columns. */\n\t\tlayout_make_node(lcrow, LAYOUT_LEFTRIGHT);\n\t\tfor (i = 0; i < columns; i++) {\n\t\t\t/* Create and add a pane cell. */\n\t\t\tlcchild = layout_create_cell(lcrow);\n\t\t\tlayout_set_size(lcchild, width, height, 0, 0);\n\t\t\tlayout_make_leaf(lcchild, wp);\n\t\t\tTAILQ_INSERT_TAIL(&lcrow->cells, lcchild, entry);\n\n\t\t\t/* Move to the next cell. */\n\t\t\tif ((wp = TAILQ_NEXT(wp, entry)) == NULL)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Adjust the row to fit the full width if necessary. */\n\t\tif (i == columns)\n\t\t\ti--;\n\t\tused = ((i + 1) * (width + 1)) - 1;\n\t\tif (w->sx <= used)\n\t\t\tcontinue;\n\t\tlcchild = TAILQ_LAST(&lcrow->cells, layout_cells);\n\t\tlayout_resize_adjust(lcchild, LAYOUT_LEFTRIGHT, w->sx - used);\n\t}\n\n\t/* Adjust the last row height to fit if necessary. */\n\tused = mainheight + (rows * height) + rows - 1;\n\tif (w->sy > used) {\n\t\tlcrow = TAILQ_LAST(&lc->cells, layout_cells);\n\t\tlayout_resize_adjust(lcrow, LAYOUT_TOPBOTTOM, w->sy - used);\n\t}\n\n\t/* Fix cell offsets. */\n\tlayout_fix_offsets(lc);\n\tlayout_fix_panes(w, w->sx, w->sy);\n\n\tlayout_print_cell(w->layout_root, __func__, 1);\n\n\tserver_redraw_window(w);\n}\n\nvoid\nlayout_set_main_v(struct window *w)\n{\n\tstruct window_pane\t*wp;\n\tstruct layout_cell\t*lc, *lcmain, *lccolumn, *lcchild;\n\tu_int\t\t\t n, mainwidth, otherwidth, width, height;\n\tu_int\t\t\t used, i, j, columns, rows, totalcolumns;\n\n\tlayout_print_cell(w->layout_root, __func__, 1);\n\n\t/* Get number of panes. */\n\tn = window_count_panes(w);\n\tif (n <= 1)\n\t\treturn;\n\tn--;\t/* take off main pane */\n\n\t/* How many rows and columns will be needed, not counting main? */\n\trows = (w->sy + 1) / (PANE_MINIMUM + 1);\t/* maximum rows */\n\tif (rows == 0)\n\t\trows = 1;\n\tcolumns = 1 + (n - 1) / rows;\n\trows = 1 + (n - 1) / columns;\n\theight = (w->sy - (n - 1)) / rows;\n\n\t/* Get the main pane width and add one for separator line. */\n\tmainwidth = options_get_number(w->options, \"main-pane-width\") + 1;\n\n\t/* Get the optional other pane width and add one for separator line. */\n\totherwidth = options_get_number(w->options, \"other-pane-width\") + 1;\n\n\t/*\n\t * If an other pane width was specified, honour it so long as it\n\t * doesn't shrink the main width to less than the main-pane-width\n\t */\n\tif (otherwidth > 1 && w->sx - otherwidth > mainwidth)\n\t\tmainwidth = w->sx - otherwidth;\n\tif (mainwidth < PANE_MINIMUM + 1)\n\t\tmainwidth = PANE_MINIMUM + 1;\n\n\t/* Try and make everything fit. */\n\ttotalcolumns = columns * (PANE_MINIMUM + 1) - 1;\n\tif (mainwidth + totalcolumns > w->sx) {\n\t\tif (totalcolumns + PANE_MINIMUM + 1 > w->sx)\n\t\t\tmainwidth = PANE_MINIMUM + 2;\n\t\telse\n\t\t\tmainwidth = w->sx - totalcolumns;\n\t\twidth = PANE_MINIMUM;\n\t} else\n\t\twidth = (w->sx - mainwidth - (columns - 1)) / columns;\n\n\t/* Free old tree and create a new root. */\n\tlayout_free(w);\n\tlc = w->layout_root = layout_create_cell(NULL);\n\tlayout_set_size(lc, mainwidth + columns * (width + 1) - 1, w->sy, 0, 0);\n\tlayout_make_node(lc, LAYOUT_LEFTRIGHT);\n\n\t/* Create the main pane. */\n\tlcmain = layout_create_cell(lc);\n\tlayout_set_size(lcmain, mainwidth - 1, w->sy, 0, 0);\n\tlayout_make_leaf(lcmain, TAILQ_FIRST(&w->panes));\n\tTAILQ_INSERT_TAIL(&lc->cells, lcmain, entry);\n\n\t/* Create a grid of the remaining cells. */\n\twp = TAILQ_NEXT(TAILQ_FIRST(&w->panes), entry);\n\tfor (j = 0; j < columns; j++) {\n\t\t/* If this is the last cell, all done. */\n\t\tif (wp == NULL)\n\t\t\tbreak;\n\n\t\t/* Create the new column. */\n\t\tlccolumn = layout_create_cell(lc);\n\t\tlayout_set_size(lccolumn, width, w->sy, 0, 0);\n\t\tTAILQ_INSERT_TAIL(&lc->cells, lccolumn, entry);\n\n\t\t/* If only one row, just use the row directly. */\n\t\tif (rows == 1) {\n\t\t\tlayout_make_leaf(lccolumn, wp);\n\t\t\twp = TAILQ_NEXT(wp, entry);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Add in the rows. */\n\t\tlayout_make_node(lccolumn, LAYOUT_TOPBOTTOM);\n\t\tfor (i = 0; i < rows; i++) {\n\t\t\t/* Create and add a pane cell. */\n\t\t\tlcchild = layout_create_cell(lccolumn);\n\t\t\tlayout_set_size(lcchild, width, height, 0, 0);\n\t\t\tlayout_make_leaf(lcchild, wp);\n\t\t\tTAILQ_INSERT_TAIL(&lccolumn->cells, lcchild, entry);\n\n\t\t\t/* Move to the next cell. */\n\t\t\tif ((wp = TAILQ_NEXT(wp, entry)) == NULL)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Adjust the column to fit the full height if necessary. */\n\t\tif (i == rows)\n\t\t\ti--;\n\t\tused = ((i + 1) * (height + 1)) - 1;\n\t\tif (w->sy <= used)\n\t\t\tcontinue;\n\t\tlcchild = TAILQ_LAST(&lccolumn->cells, layout_cells);\n\t\tlayout_resize_adjust(lcchild, LAYOUT_TOPBOTTOM, w->sy - used);\n\t}\n\n\t/* Adjust the last column width to fit if necessary. */\n\tused = mainwidth + (columns * width) + columns - 1;\n\tif (w->sx > used) {\n\t\tlccolumn = TAILQ_LAST(&lc->cells, layout_cells);\n\t\tlayout_resize_adjust(lccolumn, LAYOUT_LEFTRIGHT, w->sx - used);\n\t}\n\n\t/* Fix cell offsets. */\n\tlayout_fix_offsets(lc);\n\tlayout_fix_panes(w, w->sx, w->sy);\n\n\tlayout_print_cell(w->layout_root, __func__, 1);\n\n\tserver_redraw_window(w);\n}\n\nvoid\nlayout_set_tiled(struct window *w)\n{\n\tstruct window_pane\t*wp;\n\tstruct layout_cell\t*lc, *lcrow, *lcchild;\n\tu_int\t\t\t n, width, height, used;\n\tu_int\t\t\t i, j, columns, rows;\n\n\tlayout_print_cell(w->layout_root, __func__, 1);\n\n\t/* Get number of panes. */\n\tn = window_count_panes(w);\n\tif (n <= 1)\n\t\treturn;\n\n\t/* How many rows and columns are wanted? */\n\trows = columns = 1;\n\twhile (rows * columns < n) {\n\t\trows++;\n\t\tif (rows * columns < n)\n\t\t\tcolumns++;\n\t}\n\n\t/* What width and height should they be? */\n\twidth = (w->sx - (columns - 1)) / columns;\n\tif (width < PANE_MINIMUM)\n\t\twidth = PANE_MINIMUM;\n\theight = (w->sy - (rows - 1)) / rows;\n\tif (height < PANE_MINIMUM)\n\t\theight = PANE_MINIMUM;\n\n\t/* Free old tree and create a new root. */\n\tlayout_free(w);\n\tlc = w->layout_root = layout_create_cell(NULL);\n\tlayout_set_size(lc, (width + 1) * columns - 1,\n\t    (height + 1) * rows - 1, 0, 0);\n\tlayout_make_node(lc, LAYOUT_TOPBOTTOM);\n\n\t/* Create a grid of the cells. */\n\twp = TAILQ_FIRST(&w->panes);\n\tfor (j = 0; j < rows; j++) {\n\t\t/* If this is the last cell, all done. */\n\t\tif (wp == NULL)\n\t\t\tbreak;\n\n\t\t/* Create the new row. */\n\t\tlcrow = layout_create_cell(lc);\n\t\tlayout_set_size(lcrow, w->sx, height, 0, 0);\n\t\tTAILQ_INSERT_TAIL(&lc->cells, lcrow, entry);\n\n\t\t/* If only one column, just use the row directly. */\n\t\tif (n - (j * columns) == 1 || columns == 1) {\n\t\t\tlayout_make_leaf(lcrow, wp);\n\t\t\twp = TAILQ_NEXT(wp, entry);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Add in the columns. */\n\t\tlayout_make_node(lcrow, LAYOUT_LEFTRIGHT);\n\t\tfor (i = 0; i < columns; i++) {\n\t\t\t/* Create and add a pane cell. */\n\t\t\tlcchild = layout_create_cell(lcrow);\n\t\t\tlayout_set_size(lcchild, width, height, 0, 0);\n\t\t\tlayout_make_leaf(lcchild, wp);\n\t\t\tTAILQ_INSERT_TAIL(&lcrow->cells, lcchild, entry);\n\n\t\t\t/* Move to the next cell. */\n\t\t\tif ((wp = TAILQ_NEXT(wp, entry)) == NULL)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Adjust the row and columns to fit the full width if\n\t\t * necessary.\n\t\t */\n\t\tif (i == columns)\n\t\t\ti--;\n\t\tused = ((i + 1) * (width + 1)) - 1;\n\t\tif (w->sx <= used)\n\t\t\tcontinue;\n\t\tlcchild = TAILQ_LAST(&lcrow->cells, layout_cells);\n\t\tlayout_resize_adjust(lcchild, LAYOUT_LEFTRIGHT, w->sx - used);\n\t}\n\n\t/* Adjust the last row height to fit if necessary. */\n\tused = (rows * height) + rows - 1;\n\tif (w->sy > used) {\n\t\tlcrow = TAILQ_LAST(&lc->cells, layout_cells);\n\t\tlayout_resize_adjust(lcrow, LAYOUT_TOPBOTTOM, w->sy - used);\n\t}\n\n\t/* Fix cell offsets. */\n\tlayout_fix_offsets(lc);\n\tlayout_fix_panes(w, w->sx, w->sy);\n\n\tlayout_print_cell(w->layout_root, __func__, 1);\n\n\tserver_redraw_window(w);\n}\n"
        },
        {
          "name": "layout.c",
          "type": "blob",
          "size": 17.8134765625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n\n#include \"tmux.h\"\n\n/*\n * The window layout is a tree of cells each of which can be one of: a\n * left-right container for a list of cells, a top-bottom container for a list\n * of cells, or a container for a window pane.\n *\n * Each window has a pointer to the root of its layout tree (containing its\n * panes), every pane has a pointer back to the cell containing it, and each\n * cell a pointer to its parent cell.\n */\n\nint\tlayout_resize_pane_grow(struct layout_cell *, enum layout_type, int);\nint\tlayout_resize_pane_shrink(struct layout_cell *, enum layout_type, int);\n\nstruct layout_cell *\nlayout_create_cell(struct layout_cell *lcparent)\n{\n\tstruct layout_cell\t*lc;\n\n\tlc = xmalloc(sizeof *lc);\n\tlc->type = LAYOUT_WINDOWPANE;\n\tlc->parent = lcparent;\n\n\tTAILQ_INIT(&lc->cells);\n\n\tlc->sx = UINT_MAX;\n\tlc->sy = UINT_MAX;\n\n\tlc->xoff = UINT_MAX;\n\tlc->yoff = UINT_MAX;\n\n\tlc->wp = NULL;\n\n\treturn (lc);\n}\n\nvoid\nlayout_free_cell(struct layout_cell *lc)\n{\n\tstruct layout_cell\t*lcchild;\n\n\tswitch (lc->type) {\n\tcase LAYOUT_LEFTRIGHT:\n\tcase LAYOUT_TOPBOTTOM:\n\t\twhile (!TAILQ_EMPTY(&lc->cells)) {\n\t\t\tlcchild = TAILQ_FIRST(&lc->cells);\n\t\t\tTAILQ_REMOVE(&lc->cells, lcchild, entry);\n\t\t\tlayout_free_cell(lcchild);\n\t\t}\n\t\tbreak;\n\tcase LAYOUT_WINDOWPANE:\n\t\tif (lc->wp != NULL)\n\t\t\tlc->wp->layout_cell = NULL;\n\t\tbreak;\n\t}\n\n\tfree(lc);\n}\n\nvoid\nlayout_print_cell(struct layout_cell *lc, const char *hdr, u_int n)\n{\n\tstruct layout_cell\t*lcchild;\n\n\tlog_debug(\"%s:%*s%p type %u [parent %p] wp=%p [%u,%u %ux%u]\", hdr, n,\n\t    \" \", lc, lc->type, lc->parent, lc->wp, lc->xoff, lc->yoff, lc->sx,\n\t    lc->sy);\n\tswitch (lc->type) {\n\tcase LAYOUT_LEFTRIGHT:\n\tcase LAYOUT_TOPBOTTOM:\n\t\tTAILQ_FOREACH(lcchild, &lc->cells, entry)\n\t\t    \tlayout_print_cell(lcchild, hdr, n + 1);\n\t\tbreak;\n\tcase LAYOUT_WINDOWPANE:\n\t\tbreak;\n\t}\n}\n\nvoid\nlayout_set_size(struct layout_cell *lc, u_int sx, u_int sy, u_int xoff,\n    u_int yoff)\n{\n\tlc->sx = sx;\n\tlc->sy = sy;\n\n\tlc->xoff = xoff;\n\tlc->yoff = yoff;\n}\n\nvoid\nlayout_make_leaf(struct layout_cell *lc, struct window_pane *wp)\n{\n\tlc->type = LAYOUT_WINDOWPANE;\n\n\tTAILQ_INIT(&lc->cells);\n\n\twp->layout_cell = lc;\n\tlc->wp = wp;\n}\n\nvoid\nlayout_make_node(struct layout_cell *lc, enum layout_type type)\n{\n\tif (type == LAYOUT_WINDOWPANE)\n\t\tfatalx(\"bad layout type\");\n\tlc->type = type;\n\n\tTAILQ_INIT(&lc->cells);\n\n\tif (lc->wp != NULL)\n\t\tlc->wp->layout_cell = NULL;\n\tlc->wp = NULL;\n}\n\n/* Fix cell offsets based on their sizes. */\nvoid\nlayout_fix_offsets(struct layout_cell *lc)\n{\n\tstruct layout_cell\t*lcchild;\n\tu_int\t\t\t xoff, yoff;\n\n\tif (lc->type == LAYOUT_LEFTRIGHT) {\n\t\txoff = lc->xoff;\n\t\tTAILQ_FOREACH(lcchild, &lc->cells, entry) {\n\t\t\tlcchild->xoff = xoff;\n\t\t\tlcchild->yoff = lc->yoff;\n\t\t\tif (lcchild->type != LAYOUT_WINDOWPANE)\n\t\t\t\tlayout_fix_offsets(lcchild);\n\t\t\txoff += lcchild->sx + 1;\n\t\t}\n\t} else {\n\t\tyoff = lc->yoff;\n\t\tTAILQ_FOREACH(lcchild, &lc->cells, entry) {\n\t\t\tlcchild->xoff = lc->xoff;\n\t\t\tlcchild->yoff = yoff;\n\t\t\tif (lcchild->type != LAYOUT_WINDOWPANE)\n\t\t\t\tlayout_fix_offsets(lcchild);\n\t\t\tyoff += lcchild->sy + 1;\n\t\t}\n\t}\n}\n\n/* Update pane offsets and sizes based on their cells. */\nvoid\nlayout_fix_panes(struct window *w, u_int wsx, u_int wsy)\n{\n\tstruct window_pane\t*wp;\n\tstruct layout_cell\t*lc;\n\tu_int\t\t\t sx, sy;\n\n\tTAILQ_FOREACH(wp, &w->panes, entry) {\n\t\tif ((lc = wp->layout_cell) == NULL)\n\t\t\tcontinue;\n\t\twp->xoff = lc->xoff;\n\t\twp->yoff = lc->yoff;\n\n\t\t/*\n\t\t * Layout cells are limited by the smallest size of other cells\n\t\t * within the same row or column; if this isn't the case\n\t\t * resizing becomes difficult.\n\t\t *\n\t\t * However, panes do not have to take up their entire cell, so\n\t\t * they can be cropped to the window edge if the layout\n\t\t * overflows and they are partly visible.\n\t\t *\n\t\t * This stops cells being hidden unnecessarily.\n\t\t */\n\n\t\t/*\n\t\t * Work out the horizontal size. If the pane is actually\n\t\t * outside the window or the entire pane is already visible,\n\t\t * don't crop.\n\t\t */\n\t\tif (lc->xoff >= wsx || lc->xoff + lc->sx < wsx)\n\t\t\tsx = lc->sx;\n\t\telse {\n\t\t\tsx = wsx - lc->xoff;\n\t\t\tif (sx < 1)\n\t\t\t\tsx = lc->sx;\n\t\t}\n\n\t\t/*\n\t\t * Similarly for the vertical size; the minimum vertical size\n\t\t * is two because scroll regions cannot be one line.\n\t\t */\n\t\tif (lc->yoff >= wsy || lc->yoff + lc->sy < wsy)\n\t\t\tsy = lc->sy;\n\t\telse {\n\t\t\tsy = wsy - lc->yoff;\n\t\t\tif (sy < 2)\n\t\t\t\tsy = lc->sy;\n\t\t}\n\n\t\twindow_pane_resize(wp, sx, sy);\n\t}\n}\n\n/* Count the number of available cells in a layout. */\nu_int\nlayout_count_cells(struct layout_cell *lc)\n{\n\tstruct layout_cell\t*lcchild;\n\tu_int\t\t\t n;\n\n\tswitch (lc->type) {\n\tcase LAYOUT_WINDOWPANE:\n\t\treturn (1);\n\tcase LAYOUT_LEFTRIGHT:\n\tcase LAYOUT_TOPBOTTOM:\n\t\tn = 0;\n\t\tTAILQ_FOREACH(lcchild, &lc->cells, entry)\n\t\t\tn += layout_count_cells(lcchild);\n\t\treturn (n);\n\tdefault:\n\t\tfatalx(\"bad layout type\");\n\t}\n}\n\n/* Calculate how much size is available to be removed from a cell. */\nu_int\nlayout_resize_check(struct layout_cell *lc, enum layout_type type)\n{\n\tstruct layout_cell\t*lcchild;\n\tu_int\t\t\t available, minimum;\n\n\tif (lc->type == LAYOUT_WINDOWPANE) {\n\t\t/* Space available in this cell only. */\n\t\tif (type == LAYOUT_LEFTRIGHT)\n\t\t\tavailable = lc->sx;\n\t\telse\n\t\t\tavailable = lc->sy;\n\n\t\tif (available > PANE_MINIMUM)\n\t\t\tavailable -= PANE_MINIMUM;\n\t\telse\n\t\t\tavailable = 0;\n\t} else if (lc->type == type) {\n\t\t/* Same type: total of available space in all child cells. */\n\t\tavailable = 0;\n\t\tTAILQ_FOREACH(lcchild, &lc->cells, entry)\n\t\t\tavailable += layout_resize_check(lcchild, type);\n\t} else {\n\t\t/* Different type: minimum of available space in child cells. */\n\t\tminimum = UINT_MAX;\n\t\tTAILQ_FOREACH(lcchild, &lc->cells, entry) {\n\t\t\tavailable = layout_resize_check(lcchild, type);\n\t\t\tif (available < minimum)\n\t\t\t\tminimum = available;\n\t\t}\n\t\tavailable = minimum;\n\t}\n\n\treturn (available);\n}\n\n/*\n * Adjust cell size evenly, including altering its children. This function\n * expects the change to have already been bounded to the space available.\n */\nvoid\nlayout_resize_adjust(struct layout_cell *lc, enum layout_type type, int change)\n{\n\tstruct layout_cell\t*lcchild;\n\n\t/* Adjust the cell size. */\n\tif (type == LAYOUT_LEFTRIGHT)\n\t\tlc->sx += change;\n\telse\n\t\tlc->sy += change;\n\n\t/* If this is a leaf cell, that is all that is necessary. */\n\tif (type == LAYOUT_WINDOWPANE)\n\t\treturn;\n\n\t/* Child cell runs in a different direction. */\n\tif (lc->type != type) {\n\t\tTAILQ_FOREACH(lcchild, &lc->cells, entry)\n\t\t\tlayout_resize_adjust(lcchild, type, change);\n\t\treturn;\n\t}\n\n\t/*\n\t * Child cell runs in the same direction. Adjust each child equally\n\t * until no further change is possible.\n\t */\n\twhile (change != 0) {\n\t\tTAILQ_FOREACH(lcchild, &lc->cells, entry) {\n\t\t\tif (change == 0)\n\t\t\t\tbreak;\n\t\t\tif (change > 0) {\n\t\t\t\tlayout_resize_adjust(lcchild, type, 1);\n\t\t\t\tchange--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (layout_resize_check(lcchild, type) > 0) {\n\t\t\t\tlayout_resize_adjust(lcchild, type, -1);\n\t\t\t\tchange++;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* Destroy a cell and redistribute the space. */\nvoid\nlayout_destroy_cell(struct layout_cell *lc, struct layout_cell **lcroot)\n{\n\tstruct layout_cell     *lcother, *lcparent;\n\n\t/*\n\t * If no parent, this is the last pane so window close is imminent and\n\t * there is no need to resize anything.\n\t */\n\tlcparent = lc->parent;\n\tif (lcparent == NULL) {\n\t\tlayout_free_cell(lc);\n\t\t*lcroot = NULL;\n\t\treturn;\n\t}\n\n\t/* Merge the space into the previous or next cell. */\n\tif (lc == TAILQ_FIRST(&lcparent->cells))\n\t\tlcother = TAILQ_NEXT(lc, entry);\n\telse\n\t\tlcother = TAILQ_PREV(lc, layout_cells, entry);\n\tif (lcparent->type == LAYOUT_LEFTRIGHT)\n\t\tlayout_resize_adjust(lcother, lcparent->type, lc->sx + 1);\n\telse\n\t\tlayout_resize_adjust(lcother, lcparent->type, lc->sy + 1);\n\n\t/* Remove this from the parent's list. */\n\tTAILQ_REMOVE(&lcparent->cells, lc, entry);\n\tlayout_free_cell(lc);\n\n\t/*\n\t * If the parent now has one cell, remove the parent from the tree and\n\t * replace it by that cell.\n\t */\n\tlc = TAILQ_FIRST(&lcparent->cells);\n\tif (TAILQ_NEXT(lc, entry) == NULL) {\n\t\tTAILQ_REMOVE(&lcparent->cells, lc, entry);\n\n\t\tlc->parent = lcparent->parent;\n\t\tif (lc->parent == NULL) {\n\t\t\tlc->xoff = 0; lc->yoff = 0;\n\t\t\t*lcroot = lc;\n\t\t} else\n\t\t\tTAILQ_REPLACE(&lc->parent->cells, lcparent, lc, entry);\n\n\t\tlayout_free_cell(lcparent);\n\t}\n}\n\nvoid\nlayout_init(struct window *w, struct window_pane *wp)\n{\n\tstruct layout_cell\t*lc;\n\n\tlc = w->layout_root = layout_create_cell(NULL);\n\tlayout_set_size(lc, w->sx, w->sy, 0, 0);\n\tlayout_make_leaf(lc, wp);\n\n\tlayout_fix_panes(w, w->sx, w->sy);\n}\n\nvoid\nlayout_free(struct window *w)\n{\n\tlayout_free_cell(w->layout_root);\n}\n\n/* Resize the entire layout after window resize. */\nvoid\nlayout_resize(struct window *w, u_int sx, u_int sy)\n{\n\tstruct layout_cell\t*lc = w->layout_root;\n\tint\t\t\t xlimit, ylimit, xchange, ychange;\n\n\t/*\n\t * Adjust horizontally. Do not attempt to reduce the layout lower than\n\t * the minimum (more than the amount returned by layout_resize_check).\n\t *\n\t * This can mean that the window size is smaller than the total layout\n\t * size: redrawing this is handled at a higher level, but it does leave\n\t * a problem with growing the window size here: if the current size is\n\t * < the minimum, growing proportionately by adding to each pane is\n\t * wrong as it would keep the layout size larger than the window size.\n\t * Instead, spread the difference between the minimum and the new size\n\t * out proportionately - this should leave the layout fitting the new\n\t * window size.\n\t */\n\txchange = sx - w->sx;\n\txlimit = layout_resize_check(lc, LAYOUT_LEFTRIGHT);\n\tif (xchange < 0 && xchange < -xlimit)\n\t\txchange = -xlimit;\n\tif (xlimit == 0) {\n\t\tif (sx <= lc->sx)\t/* lc->sx is minimum possible */\n\t\t\txchange = 0;\n\t\telse\n\t\t\txchange = sx - lc->sx;\n\t}\n\tif (xchange != 0)\n\t\tlayout_resize_adjust(lc, LAYOUT_LEFTRIGHT, xchange);\n\n\t/* Adjust vertically in a similar fashion. */\n\tychange = sy - w->sy;\n\tylimit = layout_resize_check(lc, LAYOUT_TOPBOTTOM);\n\tif (ychange < 0 && ychange < -ylimit)\n\t\tychange = -ylimit;\n\tif (ylimit == 0) {\n\t\tif (sy <= lc->sy)\t/* lc->sy is minimum possible */\n\t\t\tychange = 0;\n\t\telse\n\t\t\tychange = sy - lc->sy;\n\t}\n\tif (ychange != 0)\n\t\tlayout_resize_adjust(lc, LAYOUT_TOPBOTTOM, ychange);\n\n\t/* Fix cell offsets. */\n\tlayout_fix_offsets(lc);\n\tlayout_fix_panes(w, sx, sy);\n}\n\n/* Resize a pane to an absolute size. */\nvoid\nlayout_resize_pane_to(struct window_pane *wp, enum layout_type type,\n    u_int new_size)\n{\n\tstruct layout_cell     *lc, *lcparent;\n\tint\t\t\tchange, size;\n\n\tlc = wp->layout_cell;\n\n\t/* Find next parent of the same type. */\n\tlcparent = lc->parent;\n\twhile (lcparent != NULL && lcparent->type != type) {\n\t\tlc = lcparent;\n\t\tlcparent = lc->parent;\n\t}\n\tif (lcparent == NULL)\n\t\treturn;\n\n\t/* Work out the size adjustment. */\n\tif (type == LAYOUT_LEFTRIGHT)\n\t\tsize = lc->sx;\n\telse\n\t\tsize = lc->sy;\n\tif (lc == TAILQ_LAST(&lcparent->cells, layout_cells))\n\t\tchange = size - new_size;\n\telse\n\t\tchange = new_size - size;\n\n\t/* Resize the pane. */\n\tlayout_resize_pane(wp, type, change);\n}\n\n/* Resize a single pane within the layout. */\nvoid\nlayout_resize_pane(struct window_pane *wp, enum layout_type type, int change)\n{\n\tstruct layout_cell     *lc, *lcparent;\n\tint\t\t\tneeded, size;\n\n\tlc = wp->layout_cell;\n\n\t/* Find next parent of the same type. */\n\tlcparent = lc->parent;\n\twhile (lcparent != NULL && lcparent->type != type) {\n\t\tlc = lcparent;\n\t\tlcparent = lc->parent;\n\t}\n\tif (lcparent == NULL)\n\t\treturn;\n\n\t/* If this is the last cell, move back one. */\n\tif (lc == TAILQ_LAST(&lcparent->cells, layout_cells))\n\t\tlc = TAILQ_PREV(lc, layout_cells, entry);\n\n\t/* Grow or shrink the cell. */\n\tneeded = change;\n\twhile (needed != 0) {\n\t\tif (change > 0) {\n\t\t\tsize = layout_resize_pane_grow(lc, type, needed);\n\t\t\tneeded -= size;\n\t\t} else {\n\t\t\tsize = layout_resize_pane_shrink(lc, type, needed);\n\t\t\tneeded += size;\n\t\t}\n\n\t\tif (size == 0)\t/* no more change possible */\n\t\t\tbreak;\n\t}\n\n\t/* Fix cell offsets. */\n\tlayout_fix_offsets(wp->window->layout_root);\n\tlayout_fix_panes(wp->window, wp->window->sx, wp->window->sy);\n\tnotify_window_layout_changed(wp->window);\n}\n\n/* Helper function to grow pane. */\nint\nlayout_resize_pane_grow(struct layout_cell *lc, enum layout_type type,\n    int needed)\n{\n\tstruct layout_cell\t*lcadd, *lcremove;\n\tu_int\t\t\t size;\n\n\t/* Growing. Always add to the current cell. */\n\tlcadd = lc;\n\n\t/* Look towards the tail for a suitable cell for reduction. */\n\tlcremove = TAILQ_NEXT(lc, entry);\n\twhile (lcremove != NULL) {\n\t\tsize = layout_resize_check(lcremove, type);\n\t\tif (size > 0)\n\t\t\tbreak;\n\t\tlcremove = TAILQ_NEXT(lcremove, entry);\n\t}\n\n\t/* If none found, look towards the head. */\n\tif (lcremove == NULL) {\n\t\tlcremove = TAILQ_PREV(lc, layout_cells, entry);\n\t\twhile (lcremove != NULL) {\n\t\t\tsize = layout_resize_check(lcremove, type);\n\t\t\tif (size > 0)\n\t\t\t\tbreak;\n\t\t\tlcremove = TAILQ_PREV(lcremove, layout_cells, entry);\n\t\t}\n\t\tif (lcremove == NULL)\n\t\t\treturn (0);\n\t}\n\n\t/* Change the cells. */\n\tif (size > (u_int) needed)\n\t\tsize = needed;\n\tlayout_resize_adjust(lcadd, type, size);\n\tlayout_resize_adjust(lcremove, type, -size);\n\treturn (size);\n}\n\n/* Helper function to shrink pane. */\nint\nlayout_resize_pane_shrink(struct layout_cell *lc, enum layout_type type,\n    int needed)\n{\n\tstruct layout_cell\t*lcadd, *lcremove;\n\tu_int\t\t\t size;\n\n\t/* Shrinking. Find cell to remove from by walking towards head. */\n\tlcremove = lc;\n\tdo {\n\t\tsize = layout_resize_check(lcremove, type);\n\t\tif (size != 0)\n\t\t\tbreak;\n\t\tlcremove = TAILQ_PREV(lcremove, layout_cells, entry);\n\t} while (lcremove != NULL);\n\tif (lcremove == NULL)\n\t\treturn (0);\n\n\t/* And add onto the next cell (from the original cell). */\n\tlcadd = TAILQ_NEXT(lc, entry);\n\tif (lcadd == NULL)\n\t\treturn (0);\n\n\t/* Change the cells. */\n\tif (size > (u_int) -needed)\n\t\tsize = -needed;\n\tlayout_resize_adjust(lcadd, type, size);\n\tlayout_resize_adjust(lcremove, type, -size);\n\treturn (size);\n}\n\n/* Assign window pane to newly split cell. */\nvoid\nlayout_assign_pane(struct layout_cell *lc, struct window_pane *wp)\n{\n\tlayout_make_leaf(lc, wp);\n\tlayout_fix_panes(wp->window, wp->window->sx, wp->window->sy);\n}\n\n/*\n * Split a pane into two. size is a hint, or -1 for default half/half\n * split. This must be followed by layout_assign_pane before much else happens!\n **/\nstruct layout_cell *\nlayout_split_pane(struct window_pane *wp, enum layout_type type, int size,\n    int insert_before)\n{\n\tstruct layout_cell     *lc, *lcparent, *lcnew, *lc1, *lc2;\n\tu_int\t\t\tsx, sy, xoff, yoff, size1, size2;\n\n\tlc = wp->layout_cell;\n\n\t/* Copy the old cell size. */\n\tsx = lc->sx;\n\tsy = lc->sy;\n\txoff = lc->xoff;\n\tyoff = lc->yoff;\n\n\t/* Check there is enough space for the two new panes. */\n\tswitch (type) {\n\tcase LAYOUT_LEFTRIGHT:\n\t\tif (sx < PANE_MINIMUM * 2 + 1)\n\t\t\treturn (NULL);\n\t\tbreak;\n\tcase LAYOUT_TOPBOTTOM:\n\t\tif (sy < PANE_MINIMUM * 2 + 1)\n\t\t\treturn (NULL);\n\t\tbreak;\n\tdefault:\n\t\tfatalx(\"bad layout type\");\n\t}\n\n\tif (lc->parent != NULL && lc->parent->type == type) {\n\t\t/*\n\t\t * If the parent exists and is of the same type as the split,\n\t\t * create a new cell and insert it after this one.\n\t\t */\n\n\t\t/* Create the new child cell. */\n\t\tlcparent = lc->parent;\n\t\tlcnew = layout_create_cell(lcparent);\n\t\tif (insert_before)\n\t\t\tTAILQ_INSERT_BEFORE(lc, lcnew, entry);\n\t\telse\n\t\t\tTAILQ_INSERT_AFTER(&lcparent->cells, lc, lcnew, entry);\n\t} else {\n\t\t/*\n\t\t * Otherwise create a new parent and insert it.\n\t\t */\n\n\t\t/* Create and insert the replacement parent. */\n\t\tlcparent = layout_create_cell(lc->parent);\n\t\tlayout_make_node(lcparent, type);\n\t\tlayout_set_size(lcparent, sx, sy, xoff, yoff);\n\t\tif (lc->parent == NULL)\n\t\t\twp->window->layout_root = lcparent;\n\t\telse\n\t\t\tTAILQ_REPLACE(&lc->parent->cells, lc, lcparent, entry);\n\n\t\t/* Insert the old cell. */\n\t\tlc->parent = lcparent;\n\t\tTAILQ_INSERT_HEAD(&lcparent->cells, lc, entry);\n\n\t\t/* Create the new child cell. */\n\t\tlcnew = layout_create_cell(lcparent);\n\t\tif (insert_before)\n\t\t\tTAILQ_INSERT_HEAD(&lcparent->cells, lcnew, entry);\n\t\telse\n\t\t\tTAILQ_INSERT_TAIL(&lcparent->cells, lcnew, entry);\n\t}\n\tif (insert_before) {\n\t\tlc1 = lcnew;\n\t\tlc2 = lc;\n\t} else {\n\t\tlc1 = lc;\n\t\tlc2 = lcnew;\n\t}\n\n\t/* Set new cell sizes.  size is the target size or -1 for middle split,\n\t * size1 is the size of the top/left and size2 the bottom/right.\n\t */\n\tswitch (type) {\n\tcase LAYOUT_LEFTRIGHT:\n\t\tif (size < 0)\n\t\t\tsize2 = ((sx + 1) / 2) - 1;\n\t\telse if (insert_before)\n\t\t\tsize2 = sx - size - 1;\n\t\telse\n\t\t\tsize2 = size;\n\t\tif (size2 < PANE_MINIMUM)\n\t\t\tsize2 = PANE_MINIMUM;\n\t\telse if (size2 > sx - 2)\n\t\t\tsize2 = sx - 2;\n\t\tsize1 = sx - 1 - size2;\n\t\tlayout_set_size(lc1, size1, sy, xoff, yoff);\n\t\tlayout_set_size(lc2, size2, sy, xoff + lc1->sx + 1, yoff);\n\t\tbreak;\n\tcase LAYOUT_TOPBOTTOM:\n\t\tif (size < 0)\n\t\t\tsize2 = ((sy + 1) / 2) - 1;\n\t\telse if (insert_before)\n\t\t\tsize2 = sy - size - 1;\n\t\telse\n\t\t\tsize2 = size;\n\t\tif (size2 < PANE_MINIMUM)\n\t\t\tsize2 = PANE_MINIMUM;\n\t\telse if (size2 > sy - 2)\n\t\t\tsize2 = sy - 2;\n\t\tsize1 = sy - 1 - size2;\n\t\tlayout_set_size(lc1, sx, size1, xoff, yoff);\n\t\tlayout_set_size(lc2, sx, size2, xoff, yoff + lc1->sy + 1);\n\t\tbreak;\n\tdefault:\n\t\tfatalx(\"bad layout type\");\n\t}\n\n\t/* Assign the panes. */\n\tlayout_make_leaf(lc, wp);\n\n\treturn (lcnew);\n}\n\n/* Destroy the cell associated with a pane. */\nvoid\nlayout_close_pane(struct window_pane *wp)\n{\n\t/* Remove the cell. */\n\tlayout_destroy_cell(wp->layout_cell, &wp->window->layout_root);\n\n\t/* Fix pane offsets and sizes. */\n\tif (wp->window->layout_root != NULL) {\n\t\tlayout_fix_offsets(wp->window->layout_root);\n\t\tlayout_fix_panes(wp->window, wp->window->sx, wp->window->sy);\n\t}\n\tnotify_window_layout_changed(wp->window);\n}\n"
        },
        {
          "name": "log.c",
          "type": "blob",
          "size": 3.3662109375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\nstatic FILE\t*log_file;\nstatic int\t log_level;\n\nstatic void\t log_event_cb(int, const char *);\nstatic void\t log_vwrite(const char *, va_list);\n\nstatic int is_log_stdout(void)\n{\n\treturn fileno(log_file) <= 2;\n}\n\n/* Log callback for libevent. */\nstatic void\nlog_event_cb(__unused int severity, const char *msg)\n{\n\tlog_debug(\"%s\", msg);\n}\n\n/* Increment log level. */\nvoid\nlog_add_level(void)\n{\n\tlog_level++;\n}\n\n/* Get log level. */\nint\nlog_get_level(void)\n{\n\treturn (log_level);\n}\n\nvoid\nlog_open_fp(FILE *f)\n{\n\tif (log_file == f)\n\t\treturn;\n\n\tif (log_file != NULL && !is_log_stdout())\n\t\tfclose(log_file);\n\n\tlog_file = f;\n\n\tsetvbuf(log_file, NULL, _IOLBF, 0);\n\tevent_set_log_callback(log_event_cb);\n}\n\n/* Open logging to file. */\nvoid\nlog_open(const char *name)\n{\n\tchar\t*path;\n\n\tif (log_level == 0)\n\t\treturn;\n\n\txasprintf(&path, \"tmate-%s-%ld.log\", name, (long)getpid());\n\tFILE *f = fopen(path, \"w\");\n\tfree(path);\n\tif (f)\n\t\tlog_open_fp(f);\n}\n\n/* Close logging. */\nvoid\nlog_close(void)\n{\n\tif (log_file != NULL && !is_log_stdout())\n\t\tfclose(log_file);\n\tlog_file = NULL;\n\n\tevent_set_log_callback(NULL);\n}\n\n/* Write a log message. */\n__attribute__((__format__(__printf__, 1, 0)))\nstatic void\nlog_vwrite(const char *msg, va_list ap)\n{\n\tchar\t\t*fmt, *out;\n\tstruct timeval\t tv;\n\n\tif (log_file == NULL)\n\t\treturn;\n\n\tif (vasprintf(&fmt, msg, ap) == -1)\n\t\texit(1);\n\tif (stravis(&out, fmt, VIS_OCTAL|VIS_CSTYLE|VIS_TAB|VIS_NL) == -1)\n\t\texit(1);\n\n\tgettimeofday(&tv, NULL);\n\n\tif (is_log_stdout()) {\n\t\tif (fprintf(log_file, \"%s\\n\", out) == -1)\n\t\t\texit(1);\n\t} else {\n\t\tif (fprintf(log_file, \"%lld.%06d %s\\n\", (long long)tv.tv_sec,\n\t\t\t    (int)tv.tv_usec, out) == -1)\n\t\t\texit(1);\n\t}\n\n\tfflush(log_file);\n\n\tfree(out);\n\tfree(fmt);\n}\n\n/* Log a debug message. */\nvoid\nlog_emit(int level, const char *msg, ...)\n{\n\tva_list\tap;\n\n\tif (log_level < level)\n\t\treturn;\n\n\tva_start(ap, msg);\n\tlog_vwrite(msg, ap);\n\tva_end(ap);\n}\n\n/* Log a critical error with error string and die. */\n__attribute__((__format__(__printf__, 1, 0)))\n__dead void\nfatal(const char *msg, ...)\n{\n\tchar\t*fmt;\n\tva_list\t ap;\n\n\tva_start(ap, msg);\n\tif (asprintf(&fmt, \"fatal: %s: %s\", msg, strerror(errno)) == -1)\n\t\texit(1);\n\tmsg = fmt;\n\tlog_vwrite(msg, ap);\n\texit(1);\n}\n\n/* Log a critical error and die. */\n__attribute__((__format__(__printf__, 1, 0)))\n__dead void\nfatalx(const char *msg, ...)\n{\n\tchar\t*fmt;\n\tva_list\t ap;\n\n\tva_start(ap, msg);\n\tif (asprintf(&fmt, \"fatal: %s\", msg) == -1)\n\t\texit(1);\n\tmsg = fmt;\n\tlog_vwrite(msg, ap);\n\texit(1);\n}\n"
        },
        {
          "name": "logo",
          "type": "tree",
          "content": null
        },
        {
          "name": "mdoc2man.awk",
          "type": "blob",
          "size": 8.40625,
          "content": "#!/usr/bin/awk\n#\n# $Id: mdoc2man.awk,v 1.9 2009/10/24 00:52:42 dtucker Exp $\n#\n# Version history:\n#  v4+ Adapted for OpenSSH Portable (see cvs Id and history)\n#  v3, I put the program under a proper license\n#      Dan Nelson <dnelson@allantgroup.com> added .An, .Aq and fixed a typo\n#  v2, fixed to work on GNU awk --posix and MacOS X\n#  v1, first attempt, didn't work on MacOS X\n#\n# Copyright (c) 2003 Peter Stuge <stuge-mdoc2man@cdy.org>\n#\n# Permission to use, copy, modify, and distribute this software for any\n# purpose with or without fee is hereby granted, provided that the above\n# copyright notice and this permission notice appear in all copies.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n\nBEGIN {\n  optlist=0\n  oldoptlist=0\n  nospace=0\n  synopsis=0\n  reference=0\n  block=0\n  ext=0\n  extopt=0\n  literal=0\n  prenl=0\n  breakw=0\n  line=\"\"\n}\n\nfunction wtail() {\n  retval=\"\"\n  while(w<nwords) {\n    if(length(retval))\n      retval=retval OFS\n    retval=retval words[++w]\n  }\n  return retval\n}\n\nfunction add(str) {\n  for(;prenl;prenl--)\n    line=line \"\\n\"\n  line=line str\n}\n\n! /^\\./ {\n  for(;prenl;prenl--)\n    print \"\"\n  print\n  if(literal)\n    print \".br\"\n  next\n}\n\n/^\\.\\\\\"/ { next }\n\n{\n  option=0\n  parens=0\n  angles=0\n  sub(\"^\\\\.\",\"\")\n  nwords=split($0,words)\n  for(w=1;w<=nwords;w++) {\n    skip=0\n    if(match(words[w],\"^Li|Pf$\")) {\n      skip=1\n    } else if(match(words[w],\"^Xo$\")) {\n      skip=1\n      ext=1\n      if(length(line)&&!(match(line,\" $\")||prenl))\n\tadd(OFS)\n    } else if(match(words[w],\"^Xc$\")) {\n      skip=1\n      ext=0\n      if(!extopt)\n\tprenl++\n      w=nwords\n    } else if(match(words[w],\"^Bd$\")) {\n      skip=1\n      if(match(words[w+1],\"-literal\")) {\n\tliteral=1\n\tprenl++\n\tw=nwords\n      }\n    } else if(match(words[w],\"^Ed$\")) {\n      skip=1\n      literal=0\n    } else if(match(words[w],\"^Ns$\")) {\n      skip=1\n      if(!nospace)\n\tnospace=1\n      sub(\" $\",\"\",line)\n    } else if(match(words[w],\"^No$\")) {\n      skip=1\n      sub(\" $\",\"\",line)\n      add(words[++w])\n    } else if(match(words[w],\"^Dq$\")) {\n      skip=1\n      add(\"``\")\n      add(words[++w])\n      while(w<nwords&&!match(words[w+1],\"^[\\\\.,]\"))\n\tadd(OFS words[++w])\n      add(\"''\")\n      if(!nospace&&match(words[w+1],\"^[\\\\.,]\"))\n\tnospace=1\n    } else if(match(words[w],\"^Sq|Ql$\")) {\n      skip=1\n      add(\"`\" words[++w] \"'\")\n      if(!nospace&&match(words[w+1],\"^[\\\\.,]\"))\n\tnospace=1\n    } else if(match(words[w],\"^Oo$\")) {\n      skip=1\n      extopt=1\n      if(!nospace)\n\tnospace=1\n      add(\"[\")\n    } else if(match(words[w],\"^Oc$\")) {\n      skip=1\n      extopt=0\n      add(\"]\")\n    }\n    if(!skip) {\n      if(!nospace&&length(line)&&!(match(line,\" $\")||prenl))\n\tadd(OFS)\n      if(nospace==1)\n\tnospace=0\n    }\n    if(match(words[w],\"^Dd$\")) {\n      if(match(words[w+1],\"^\\\\$Mdocdate:\")) {\n        w++;\n        if(match(words[w+4],\"^\\\\$$\")) {\n          words[w+4] = \"\"\n        }\n      }\n      date=wtail()\n      next\n    } else if(match(words[w],\"^Dt$\")) {\n      id=wtail()\n      next\n    } else if(match(words[w],\"^Ux$\")) {\n      add(\"UNIX\")\n      skip=1\n    } else if(match(words[w],\"^Ox$\")) {\n      add(\"OpenBSD\")\n      skip=1\n    } else if(match(words[w],\"^Os$\")) {\n      add(\".TH \" id \" \\\"\" date \"\\\" \\\"\" wtail() \"\\\"\")\n    } else if(match(words[w],\"^Sh$\")) {\n      add(\".SH\")\n      synopsis=match(words[w+1],\"SYNOPSIS\")\n    } else if(match(words[w],\"^Xr$\")) {\n      add(\"\\\\fB\" words[++w] \"\\\\fP(\" words[++w] \")\" words[++w])\n    } else if(match(words[w],\"^Rs$\")) {\n      split(\"\",refauthors)\n      nrefauthors=0\n      reftitle=\"\"\n      refissue=\"\"\n      refdate=\"\"\n      refopt=\"\"\n      refreport=\"\"\n      reference=1\n      next\n    } else if(match(words[w],\"^Re$\")) {\n      prenl++\n      for(i=nrefauthors-1;i>0;i--) {\n\tadd(refauthors[i])\n\tif(i>1)\n\t  add(\", \")\n      }\n      if(nrefauthors>1)\n\tadd(\" and \")\n      if(nrefauthors>0)\n        add(refauthors[0] \", \")\n      add(\"\\\\fI\" reftitle \"\\\\fP\")\n      if(length(refissue))\n\tadd(\", \" refissue)\n      if(length(refreport)) {\n\tadd(\", \" refreport)\n      }\n      if(length(refdate))\n\tadd(\", \" refdate)\n      if(length(refopt))\n\tadd(\", \" refopt)\n      add(\".\")\n      reference=0\n    } else if(reference) {\n      if(match(words[w],\"^%A$\")) { refauthors[nrefauthors++]=wtail() }\n      if(match(words[w],\"^%T$\")) {\n\treftitle=wtail()\n\tsub(\"^\\\"\",\"\",reftitle)\n\tsub(\"\\\"$\",\"\",reftitle)\n      }\n      if(match(words[w],\"^%N$\")) { refissue=wtail() }\n      if(match(words[w],\"^%D$\")) { refdate=wtail() }\n      if(match(words[w],\"^%O$\")) { refopt=wtail() }\n      if(match(words[w],\"^%R$\")) { refreport=wtail() }\n    } else if(match(words[w],\"^Nm$\")) {\n      if(synopsis) {\n\tadd(\".br\")\n\tprenl++\n      }\n      n=words[++w]\n      if(!length(name))\n\tname=n\n      if(!length(n))\n\tn=name\n      add(\"\\\\fB\" n \"\\\\fP\")\n      if(!nospace&&match(words[w+1],\"^[\\\\.,]\"))\n\tnospace=1\n    } else if(match(words[w],\"^Nd$\")) {\n      add(\"\\\\- \" wtail())\n    } else if(match(words[w],\"^Fl$\")) {\n      add(\"\\\\fB\\\\-\" words[++w] \"\\\\fP\")\n      if(!nospace&&match(words[w+1],\"^[\\\\.,]\"))\n\tnospace=1\n    } else if(match(words[w],\"^Ar$\")) {\n      add(\"\\\\fI\")\n      if(w==nwords)\n\tadd(\"file ...\\\\fP\")\n      else {\n\tadd(words[++w] \"\\\\fP\")\n\twhile(match(words[w+1],\"^\\\\|$\"))\n\t  add(OFS words[++w] \" \\\\fI\" words[++w] \"\\\\fP\")\n      }\n      if(!nospace&&match(words[w+1],\"^[\\\\.,]\"))\n\tnospace=1\n    } else if(match(words[w],\"^Cm$\")) {\n      add(\"\\\\fB\" words[++w] \"\\\\fP\")\n      while(w<nwords&&match(words[w+1],\"^[\\\\.,:;)]\"))\n\tadd(words[++w])\n    } else if(match(words[w],\"^Op$\")) {\n      option=1\n      if(!nospace)\n\tnospace=1\n      add(\"[\")\n    } else if(match(words[w],\"^Pp$\")) {\n      prenl++\n    } else if(match(words[w],\"^An$\")) {\n      prenl++\n    } else if(match(words[w],\"^Ss$\")) {\n      add(\".SS\")\n    } else if(match(words[w],\"^Pa$\")&&!option) {\n      add(\"\\\\fI\")\n      w++\n      if(match(words[w],\"^\\\\.\"))\n\tadd(\"\\\\&\")\n      add(words[w] \"\\\\fP\")\n      while(w<nwords&&match(words[w+1],\"^[\\\\.,:;)]\"))\n\tadd(words[++w])\n    } else if(match(words[w],\"^Dv$\")) {\n      add(\".BR\")\n    } else if(match(words[w],\"^Em|Ev$\")) {\n      add(\".IR\")\n    } else if(match(words[w],\"^Pq$\")) {\n      add(\"(\")\n      nospace=1\n      parens=1\n    } else if(match(words[w],\"^Aq$\")) {\n      add(\"<\")\n      nospace=1\n      angles=1\n    } else if(match(words[w],\"^S[xy]$\")) {\n      add(\".B \" wtail())\n    } else if(match(words[w],\"^Ic$\")) {\n      plain=1\n      add(\"\\\\fB\")\n      while(w<nwords) {\n\tw++\n\tif(match(words[w],\"^Op$\")) {\n\t  w++\n\t  add(\"[\")\n\t  words[nwords]=words[nwords] \"]\"\n\t}\n\tif(match(words[w],\"^Ar$\")) {\n\t  add(\"\\\\fI\" words[++w] \"\\\\fP\")\n\t} else if(match(words[w],\"^[\\\\.,]\")) {\n\t  sub(\" $\",\"\",line)\n\t  if(plain) {\n\t    add(\"\\\\fP\")\n\t    plain=0\n\t  }\n\t  add(words[w])\n\t} else {\n\t  if(!plain) {\n\t    add(\"\\\\fB\")\n\t    plain=1\n\t  }\n\t  add(words[w])\n\t}\n\tif(!nospace)\n\t  add(OFS)\n      }\n      sub(\" $\",\"\",line)\n      if(plain)\n\tadd(\"\\\\fP\")\n    } else if(match(words[w],\"^Bl$\")) {\n      oldoptlist=optlist\n      if(match(words[w+1],\"-bullet\"))\n\toptlist=1\n      else if(match(words[w+1],\"-enum\")) {\n\toptlist=2\n\tenum=0\n      } else if(match(words[w+1],\"-tag\"))\n\toptlist=3\n      else if(match(words[w+1],\"-item\"))\n\toptlist=4\n      else if(match(words[w+1],\"-bullet\"))\n\toptlist=1\n      w=nwords\n    } else if(match(words[w],\"^El$\")) {\n      optlist=oldoptlist\n    } else if(match(words[w],\"^Bk$\")) {\n      if(match(words[w+1],\"-words\")) {\n\tw++\n\tbreakw=1\n      }\n    } else if(match(words[w],\"^Ek$\")) {\n      breakw=0\n    } else if(match(words[w],\"^It$\")&&optlist) {\n      if(optlist==1)\n\tadd(\".IP \\\\(bu\")\n      else if(optlist==2)\n\tadd(\".IP \" ++enum \".\")\n      else if(optlist==3) {\n\tadd(\".TP\")\n\tprenl++\n\tif(match(words[w+1],\"^Pa$|^Ev$\")) {\n\t  add(\".B\")\n\t  w++\n\t}\n      } else if(optlist==4)\n\tadd(\".IP\")\n    } else if(match(words[w],\"^Sm$\")) {\n      if(match(words[w+1],\"off\"))\n\tnospace=2\n      else if(match(words[w+1],\"on\"))\n\tnospace=0\n      w++\n    } else if(!skip) {\n      add(words[w])\n    }\n  }\n  if(match(line,\"^\\\\.[^a-zA-Z]\"))\n    sub(\"^\\\\.\",\"\",line)\n  if(parens)\n    add(\")\")\n  if(angles)\n    add(\">\")\n  if(option)\n    add(\"]\")\n  if(ext&&!extopt&&!match(line,\" $\"))\n    add(OFS)\n  if(!ext&&!extopt&&length(line)) {\n    print line\n    prenl=0\n    line=\"\"\n  }\n}\n"
        },
        {
          "name": "mode-key.c",
          "type": "blob",
          "size": 25.009765625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2008 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * Mode keys. These are the key bindings used when editing (status prompt), and\n * in the modes. They are split into two sets of three tables, one set of three\n * for vi and the other for emacs key bindings. The three tables are for\n * editing, for menu-like modes (choice, more), and for copy modes (copy,\n * scroll).\n *\n * The fixed tables of struct mode_key_entry below are the defaults: they are\n * built into a tree of struct mode_key_binding by mode_key_init_trees, which\n * can then be modified.\n *\n * vi command mode is handled by having a mode flag in the struct which allows\n * two sets of bindings to be swapped between. A couple of editing commands\n * (any matching MODEKEYEDIT_SWITCHMODE*) are special-cased to do this.\n */\n\n/* Entry in the default mode key tables. */\nstruct mode_key_entry {\n\tkey_code\t\tkey;\n\n\t/*\n\t * Editing mode for vi: 0 is edit mode, keys not in the table are\n\t * returned as MODEKEY_OTHER; 1 is command mode, keys not in the table\n\t * are returned as MODEKEY_NONE. This is also matched on, allowing some\n\t * keys to be bound in edit mode.\n\t */\n\tint\t\t\tmode;\n\tenum mode_key_cmd\tcmd;\n};\n\n/* Edit keys command strings. */\nconst struct mode_key_cmdstr mode_key_cmdstr_edit[] = {\n\t{ MODEKEYEDIT_BACKSPACE, \"backspace\" },\n\t{ MODEKEYEDIT_CANCEL, \"cancel\" },\n\t{ MODEKEYEDIT_COMPLETE, \"complete\" },\n\t{ MODEKEYEDIT_CURSORLEFT, \"cursor-left\" },\n\t{ MODEKEYEDIT_CURSORRIGHT, \"cursor-right\" },\n\t{ MODEKEYEDIT_DELETE, \"delete\" },\n\t{ MODEKEYEDIT_DELETELINE, \"delete-line\" },\n\t{ MODEKEYEDIT_DELETETOENDOFLINE, \"delete-end-of-line\" },\n\t{ MODEKEYEDIT_DELETEWORD, \"delete-word\" },\n\t{ MODEKEYEDIT_ENDOFLINE, \"end-of-line\" },\n\t{ MODEKEYEDIT_ENTER, \"enter\" },\n\t{ MODEKEYEDIT_HISTORYDOWN, \"history-down\" },\n\t{ MODEKEYEDIT_HISTORYUP, \"history-up\" },\n\t{ MODEKEYEDIT_NEXTSPACE, \"next-space\" },\n\t{ MODEKEYEDIT_NEXTSPACEEND, \"next-space-end\" },\n\t{ MODEKEYEDIT_NEXTWORD, \"next-word\" },\n\t{ MODEKEYEDIT_NEXTWORDEND, \"next-word-end\" },\n\t{ MODEKEYEDIT_PASTE, \"paste\" },\n\t{ MODEKEYEDIT_PREVIOUSSPACE, \"previous-space\" },\n\t{ MODEKEYEDIT_PREVIOUSWORD, \"previous-word\" },\n\t{ MODEKEYEDIT_STARTOFLINE, \"start-of-line\" },\n\t{ MODEKEYEDIT_SWITCHMODE, \"switch-mode\" },\n\t{ MODEKEYEDIT_SWITCHMODEAPPEND, \"switch-mode-append\" },\n\t{ MODEKEYEDIT_SWITCHMODEAPPENDLINE, \"switch-mode-append-line\" },\n\t{ MODEKEYEDIT_SWITCHMODEBEGINLINE, \"switch-mode-begin-line\" },\n\t{ MODEKEYEDIT_SWITCHMODECHANGELINE, \"switch-mode-change-line\" },\n\t{ MODEKEYEDIT_SWITCHMODESUBSTITUTE, \"switch-mode-substitute\" },\n\t{ MODEKEYEDIT_SWITCHMODESUBSTITUTELINE, \"switch-mode-substitute-line\" },\n\t{ MODEKEYEDIT_TRANSPOSECHARS, \"transpose-chars\" },\n\n\t{ 0, NULL }\n};\n\n/* Choice keys command strings. */\nconst struct mode_key_cmdstr mode_key_cmdstr_choice[] = {\n\t{ MODEKEYCHOICE_BACKSPACE, \"backspace\" },\n\t{ MODEKEYCHOICE_BOTTOMLINE, \"bottom-line\"},\n\t{ MODEKEYCHOICE_CANCEL, \"cancel\" },\n\t{ MODEKEYCHOICE_CHOOSE, \"choose\" },\n\t{ MODEKEYCHOICE_DOWN, \"down\" },\n\t{ MODEKEYCHOICE_ENDOFLIST, \"end-of-list\"},\n\t{ MODEKEYCHOICE_PAGEDOWN, \"page-down\" },\n\t{ MODEKEYCHOICE_PAGEUP, \"page-up\" },\n\t{ MODEKEYCHOICE_SCROLLDOWN, \"scroll-down\" },\n\t{ MODEKEYCHOICE_SCROLLUP, \"scroll-up\" },\n\t{ MODEKEYCHOICE_STARTNUMBERPREFIX, \"start-number-prefix\" },\n\t{ MODEKEYCHOICE_STARTOFLIST, \"start-of-list\"},\n\t{ MODEKEYCHOICE_TOPLINE, \"top-line\"},\n\t{ MODEKEYCHOICE_TREE_COLLAPSE, \"tree-collapse\" },\n\t{ MODEKEYCHOICE_TREE_COLLAPSE_ALL, \"tree-collapse-all\" },\n\t{ MODEKEYCHOICE_TREE_EXPAND, \"tree-expand\" },\n\t{ MODEKEYCHOICE_TREE_EXPAND_ALL, \"tree-expand-all\" },\n\t{ MODEKEYCHOICE_TREE_TOGGLE, \"tree-toggle\" },\n\t{ MODEKEYCHOICE_UP, \"up\" },\n\n\t{ 0, NULL }\n};\n\n/* Copy keys command strings. */\nconst struct mode_key_cmdstr mode_key_cmdstr_copy[] = {\n\t{ MODEKEYCOPY_APPENDSELECTION, \"append-selection\" },\n\t{ MODEKEYCOPY_BACKTOINDENTATION, \"back-to-indentation\" },\n\t{ MODEKEYCOPY_BOTTOMLINE, \"bottom-line\" },\n\t{ MODEKEYCOPY_CANCEL, \"cancel\" },\n\t{ MODEKEYCOPY_CLEARSELECTION, \"clear-selection\" },\n\t{ MODEKEYCOPY_COPYPIPE, \"copy-pipe\" },\n\t{ MODEKEYCOPY_COPYLINE, \"copy-line\" },\n\t{ MODEKEYCOPY_COPYENDOFLINE, \"copy-end-of-line\" },\n\t{ MODEKEYCOPY_COPYSELECTION, \"copy-selection\" },\n\t{ MODEKEYCOPY_DOWN, \"cursor-down\" },\n\t{ MODEKEYCOPY_ENDOFLINE, \"end-of-line\" },\n\t{ MODEKEYCOPY_GOTOLINE, \"goto-line\" },\n\t{ MODEKEYCOPY_HALFPAGEDOWN, \"halfpage-down\" },\n\t{ MODEKEYCOPY_HALFPAGEUP, \"halfpage-up\" },\n\t{ MODEKEYCOPY_HISTORYBOTTOM, \"history-bottom\" },\n\t{ MODEKEYCOPY_HISTORYTOP, \"history-top\" },\n\t{ MODEKEYCOPY_JUMP, \"jump-forward\" },\n\t{ MODEKEYCOPY_JUMPAGAIN, \"jump-again\" },\n\t{ MODEKEYCOPY_JUMPREVERSE, \"jump-reverse\" },\n\t{ MODEKEYCOPY_JUMPBACK, \"jump-backward\" },\n\t{ MODEKEYCOPY_JUMPTO, \"jump-to-forward\" },\n\t{ MODEKEYCOPY_JUMPTOBACK, \"jump-to-backward\" },\n\t{ MODEKEYCOPY_LEFT, \"cursor-left\" },\n\t{ MODEKEYCOPY_RECTANGLETOGGLE, \"rectangle-toggle\" },\n\t{ MODEKEYCOPY_MIDDLELINE, \"middle-line\" },\n\t{ MODEKEYCOPY_NEXTPAGE, \"page-down\" },\n\t{ MODEKEYCOPY_NEXTSPACE, \"next-space\" },\n\t{ MODEKEYCOPY_NEXTSPACEEND, \"next-space-end\" },\n\t{ MODEKEYCOPY_NEXTWORD, \"next-word\" },\n\t{ MODEKEYCOPY_NEXTWORDEND, \"next-word-end\" },\n\t{ MODEKEYCOPY_OTHEREND, \"other-end\" },\n\t{ MODEKEYCOPY_PREVIOUSPAGE, \"page-up\" },\n\t{ MODEKEYCOPY_PREVIOUSSPACE, \"previous-space\" },\n\t{ MODEKEYCOPY_PREVIOUSWORD, \"previous-word\" },\n\t{ MODEKEYCOPY_RIGHT, \"cursor-right\" },\n\t{ MODEKEYCOPY_SCROLLDOWN, \"scroll-down\" },\n\t{ MODEKEYCOPY_SCROLLUP, \"scroll-up\" },\n\t{ MODEKEYCOPY_SEARCHAGAIN, \"search-again\" },\n\t{ MODEKEYCOPY_SEARCHDOWN, \"search-forward\" },\n\t{ MODEKEYCOPY_SEARCHREVERSE, \"search-reverse\" },\n\t{ MODEKEYCOPY_SEARCHUP, \"search-backward\" },\n\t{ MODEKEYCOPY_SELECTLINE, \"select-line\" },\n\t{ MODEKEYCOPY_STARTNAMEDBUFFER, \"start-named-buffer\" },\n\t{ MODEKEYCOPY_STARTNUMBERPREFIX, \"start-number-prefix\" },\n\t{ MODEKEYCOPY_STARTOFLINE, \"start-of-line\" },\n\t{ MODEKEYCOPY_STARTSELECTION, \"begin-selection\" },\n\t{ MODEKEYCOPY_TOPLINE, \"top-line\" },\n\t{ MODEKEYCOPY_UP, \"cursor-up\" },\n\n\t{ 0, NULL }\n};\n\n/* vi editing keys. */\nconst struct mode_key_entry mode_key_vi_edit[] = {\n\t{ '\\003' /* C-c */,\t    0, MODEKEYEDIT_CANCEL },\n\t{ '\\010' /* C-h */,\t    0, MODEKEYEDIT_BACKSPACE },\n\t{ '\\011' /* Tab */,\t    0, MODEKEYEDIT_COMPLETE },\n\t{ '\\025' /* C-u */,\t    0, MODEKEYEDIT_DELETELINE },\n\t{ '\\027' /* C-w */,\t    0, MODEKEYEDIT_DELETEWORD },\n\t{ '\\033' /* Escape */,\t    0, MODEKEYEDIT_SWITCHMODE },\n\t{ '\\n',\t\t\t    0, MODEKEYEDIT_ENTER },\n\t{ '\\r',\t\t\t    0, MODEKEYEDIT_ENTER },\n\t{ KEYC_BSPACE,\t\t    0, MODEKEYEDIT_BACKSPACE },\n\t{ KEYC_DC,\t\t    0, MODEKEYEDIT_DELETE },\n\t{ KEYC_DOWN,\t\t    0, MODEKEYEDIT_HISTORYDOWN },\n\t{ KEYC_LEFT,\t\t    0, MODEKEYEDIT_CURSORLEFT },\n\t{ KEYC_RIGHT,\t\t    0, MODEKEYEDIT_CURSORRIGHT },\n\t{ KEYC_UP,\t\t    0, MODEKEYEDIT_HISTORYUP },\n\t{ KEYC_HOME,\t\t    0, MODEKEYEDIT_STARTOFLINE },\n\t{ KEYC_END,\t\t    0, MODEKEYEDIT_ENDOFLINE },\n\n\t{ '$',\t\t\t    1, MODEKEYEDIT_ENDOFLINE },\n\t{ '0',\t\t\t    1, MODEKEYEDIT_STARTOFLINE },\n\t{ 'A',\t\t\t    1, MODEKEYEDIT_SWITCHMODEAPPENDLINE },\n\t{ 'B',\t\t\t    1, MODEKEYEDIT_PREVIOUSSPACE },\n\t{ 'C',\t\t\t    1, MODEKEYEDIT_SWITCHMODECHANGELINE },\n\t{ 'D',\t\t\t    1, MODEKEYEDIT_DELETETOENDOFLINE },\n\t{ 'E',\t\t\t    1, MODEKEYEDIT_NEXTSPACEEND },\n\t{ 'I',\t\t\t    1, MODEKEYEDIT_SWITCHMODEBEGINLINE },\n\t{ 'S',\t\t\t    1, MODEKEYEDIT_SWITCHMODESUBSTITUTELINE },\n\t{ 'W',\t\t\t    1, MODEKEYEDIT_NEXTSPACE },\n\t{ 'X',\t\t\t    1, MODEKEYEDIT_BACKSPACE },\n\t{ '\\003' /* C-c */,\t    1, MODEKEYEDIT_CANCEL },\n\t{ '\\010' /* C-h */,\t    1, MODEKEYEDIT_BACKSPACE },\n\t{ '\\n',\t\t\t    1, MODEKEYEDIT_ENTER },\n\t{ '\\r',\t\t\t    1, MODEKEYEDIT_ENTER },\n\t{ '^',\t\t\t    1, MODEKEYEDIT_STARTOFLINE },\n\t{ 'a',\t\t\t    1, MODEKEYEDIT_SWITCHMODEAPPEND },\n\t{ 'b',\t\t\t    1, MODEKEYEDIT_PREVIOUSWORD },\n\t{ 'd',\t\t\t    1, MODEKEYEDIT_DELETELINE },\n\t{ 'e',\t\t\t    1, MODEKEYEDIT_NEXTWORDEND },\n\t{ 'h',\t\t\t    1, MODEKEYEDIT_CURSORLEFT },\n\t{ 'i',\t\t\t    1, MODEKEYEDIT_SWITCHMODE },\n\t{ 'j',\t\t\t    1, MODEKEYEDIT_HISTORYDOWN },\n\t{ 'k',\t\t\t    1, MODEKEYEDIT_HISTORYUP },\n\t{ 'l',\t\t\t    1, MODEKEYEDIT_CURSORRIGHT },\n\t{ 'p',\t\t\t    1, MODEKEYEDIT_PASTE },\n\t{ 's',\t\t\t    1, MODEKEYEDIT_SWITCHMODESUBSTITUTE },\n\t{ 'w',\t\t\t    1, MODEKEYEDIT_NEXTWORD },\n\t{ 'x',\t\t\t    1, MODEKEYEDIT_DELETE },\n\t{ KEYC_BSPACE,\t\t    1, MODEKEYEDIT_BACKSPACE },\n\t{ KEYC_DC,\t\t    1, MODEKEYEDIT_DELETE },\n\t{ KEYC_DOWN,\t\t    1, MODEKEYEDIT_HISTORYDOWN },\n\t{ KEYC_LEFT,\t\t    1, MODEKEYEDIT_CURSORLEFT },\n\t{ KEYC_RIGHT,\t\t    1, MODEKEYEDIT_CURSORRIGHT },\n\t{ KEYC_UP,\t\t    1, MODEKEYEDIT_HISTORYUP },\n\n\t{ 0,\t\t\t   -1, 0 }\n};\nstruct mode_key_tree mode_key_tree_vi_edit;\n\n/* vi choice selection keys. */\nconst struct mode_key_entry mode_key_vi_choice[] = {\n\t{ '0' | KEYC_ESCAPE,\t    0, MODEKEYCHOICE_STARTNUMBERPREFIX },\n\t{ '1' | KEYC_ESCAPE,\t    0, MODEKEYCHOICE_STARTNUMBERPREFIX },\n\t{ '2' | KEYC_ESCAPE,\t    0, MODEKEYCHOICE_STARTNUMBERPREFIX },\n\t{ '3' | KEYC_ESCAPE,\t    0, MODEKEYCHOICE_STARTNUMBERPREFIX },\n\t{ '4' | KEYC_ESCAPE,\t    0, MODEKEYCHOICE_STARTNUMBERPREFIX },\n\t{ '5' | KEYC_ESCAPE,\t    0, MODEKEYCHOICE_STARTNUMBERPREFIX },\n\t{ '6' | KEYC_ESCAPE,\t    0, MODEKEYCHOICE_STARTNUMBERPREFIX },\n\t{ '7' | KEYC_ESCAPE,\t    0, MODEKEYCHOICE_STARTNUMBERPREFIX },\n\t{ '8' | KEYC_ESCAPE,\t    0, MODEKEYCHOICE_STARTNUMBERPREFIX },\n\t{ '9' | KEYC_ESCAPE,\t    0, MODEKEYCHOICE_STARTNUMBERPREFIX },\n\t{ '\\002' /* C-b */,\t    0, MODEKEYCHOICE_PAGEUP },\n\t{ '\\003' /* C-c */,\t    0, MODEKEYCHOICE_CANCEL },\n\t{ '\\005' /* C-e */,\t    0, MODEKEYCHOICE_SCROLLDOWN },\n\t{ '\\006' /* C-f */,\t    0, MODEKEYCHOICE_PAGEDOWN },\n\t{ '\\031' /* C-y */,\t    0, MODEKEYCHOICE_SCROLLUP },\n\t{ '\\n',\t\t\t    0, MODEKEYCHOICE_CHOOSE },\n\t{ '\\r',\t\t\t    0, MODEKEYCHOICE_CHOOSE },\n\t{ 'j',\t\t\t    0, MODEKEYCHOICE_DOWN },\n\t{ 'k',\t\t\t    0, MODEKEYCHOICE_UP },\n\t{ 'q',\t\t\t    0, MODEKEYCHOICE_CANCEL },\n\t{ KEYC_HOME,                0, MODEKEYCHOICE_STARTOFLIST },\n\t{ 'g',                      0, MODEKEYCHOICE_STARTOFLIST },\n\t{ 'H',                      0, MODEKEYCHOICE_TOPLINE },\n\t{ 'L',                      0, MODEKEYCHOICE_BOTTOMLINE },\n\t{ 'G',                      0, MODEKEYCHOICE_ENDOFLIST },\n\t{ KEYC_END,                 0, MODEKEYCHOICE_ENDOFLIST },\n\t{ KEYC_BSPACE,\t\t    0, MODEKEYCHOICE_BACKSPACE },\n\t{ KEYC_DOWN | KEYC_CTRL,    0, MODEKEYCHOICE_SCROLLDOWN },\n\t{ KEYC_DOWN,\t\t    0, MODEKEYCHOICE_DOWN },\n\t{ KEYC_NPAGE,\t\t    0, MODEKEYCHOICE_PAGEDOWN },\n\t{ KEYC_PPAGE,\t\t    0, MODEKEYCHOICE_PAGEUP },\n\t{ KEYC_UP | KEYC_CTRL,\t    0, MODEKEYCHOICE_SCROLLUP },\n\t{ KEYC_UP,\t\t    0, MODEKEYCHOICE_UP },\n\t{ ' ',\t\t\t    0, MODEKEYCHOICE_TREE_TOGGLE },\n\t{ KEYC_LEFT,\t\t    0, MODEKEYCHOICE_TREE_COLLAPSE },\n\t{ KEYC_RIGHT,\t\t    0, MODEKEYCHOICE_TREE_EXPAND },\n\t{ KEYC_LEFT | KEYC_CTRL,    0, MODEKEYCHOICE_TREE_COLLAPSE_ALL },\n\t{ KEYC_RIGHT | KEYC_CTRL,   0, MODEKEYCHOICE_TREE_EXPAND_ALL },\n\t{ KEYC_MOUSEDOWN1_PANE,     0, MODEKEYCHOICE_CHOOSE },\n\t{ KEYC_MOUSEDOWN3_PANE,     0, MODEKEYCHOICE_TREE_TOGGLE },\n\t{ KEYC_WHEELUP_PANE,        0, MODEKEYCHOICE_UP },\n\t{ KEYC_WHEELDOWN_PANE,      0, MODEKEYCHOICE_DOWN },\n\n\t{ 0,\t\t\t   -1, 0 }\n};\nstruct mode_key_tree mode_key_tree_vi_choice;\n\n/* vi copy mode keys. */\nconst struct mode_key_entry mode_key_vi_copy[] = {\n\t{ ' ',\t\t\t    0, MODEKEYCOPY_STARTSELECTION },\n\t{ '\"',\t\t\t    0, MODEKEYCOPY_STARTNAMEDBUFFER },\n\t{ '$',\t\t\t    0, MODEKEYCOPY_ENDOFLINE },\n\t{ ',',\t\t\t    0, MODEKEYCOPY_JUMPREVERSE },\n\t{ ';',\t\t\t    0, MODEKEYCOPY_JUMPAGAIN },\n\t{ '/',\t\t\t    0, MODEKEYCOPY_SEARCHDOWN },\n\t{ '0',\t\t\t    0, MODEKEYCOPY_STARTOFLINE },\n\t{ '1',\t\t\t    0, MODEKEYCOPY_STARTNUMBERPREFIX },\n\t{ '2',\t\t\t    0, MODEKEYCOPY_STARTNUMBERPREFIX },\n\t{ '3',\t\t\t    0, MODEKEYCOPY_STARTNUMBERPREFIX },\n\t{ '4',\t\t\t    0, MODEKEYCOPY_STARTNUMBERPREFIX },\n\t{ '5',\t\t\t    0, MODEKEYCOPY_STARTNUMBERPREFIX },\n\t{ '6',\t\t\t    0, MODEKEYCOPY_STARTNUMBERPREFIX },\n\t{ '7',\t\t\t    0, MODEKEYCOPY_STARTNUMBERPREFIX },\n\t{ '8',\t\t\t    0, MODEKEYCOPY_STARTNUMBERPREFIX },\n\t{ '9',\t\t\t    0, MODEKEYCOPY_STARTNUMBERPREFIX },\n\t{ ':',\t\t\t    0, MODEKEYCOPY_GOTOLINE },\n\t{ '?',\t\t\t    0, MODEKEYCOPY_SEARCHUP },\n\t{ 'A',\t\t\t    0, MODEKEYCOPY_APPENDSELECTION },\n\t{ 'B',\t\t\t    0, MODEKEYCOPY_PREVIOUSSPACE },\n\t{ 'D',\t\t\t    0, MODEKEYCOPY_COPYENDOFLINE },\n\t{ 'E',\t\t\t    0, MODEKEYCOPY_NEXTSPACEEND },\n\t{ 'F',\t\t\t    0, MODEKEYCOPY_JUMPBACK },\n\t{ 'G',\t\t\t    0, MODEKEYCOPY_HISTORYBOTTOM },\n\t{ 'H',\t\t\t    0, MODEKEYCOPY_TOPLINE },\n\t{ 'J',\t\t\t    0, MODEKEYCOPY_SCROLLDOWN },\n\t{ 'K',\t\t\t    0, MODEKEYCOPY_SCROLLUP },\n\t{ 'L',\t\t\t    0, MODEKEYCOPY_BOTTOMLINE },\n\t{ 'M',\t\t\t    0, MODEKEYCOPY_MIDDLELINE },\n\t{ 'N',\t\t\t    0, MODEKEYCOPY_SEARCHREVERSE },\n\t{ 'T',\t\t\t    0, MODEKEYCOPY_JUMPTOBACK },\n\t{ 'V',\t\t\t    0, MODEKEYCOPY_SELECTLINE },\n\t{ 'W',\t\t\t    0, MODEKEYCOPY_NEXTSPACE },\n\t{ '\\002' /* C-b */,\t    0, MODEKEYCOPY_PREVIOUSPAGE },\n\t{ '\\003' /* C-c */,\t    0, MODEKEYCOPY_CANCEL },\n\t{ '\\004' /* C-d */,\t    0, MODEKEYCOPY_HALFPAGEDOWN },\n\t{ '\\005' /* C-e */,\t    0, MODEKEYCOPY_SCROLLDOWN },\n\t{ '\\006' /* C-f */,\t    0, MODEKEYCOPY_NEXTPAGE },\n\t{ '\\010' /* C-h */,\t    0, MODEKEYCOPY_LEFT },\n\t{ '\\025' /* C-u */,\t    0, MODEKEYCOPY_HALFPAGEUP },\n\t{ '\\031' /* C-y */,\t    0, MODEKEYCOPY_SCROLLUP },\n\t{ '\\033' /* Escape */,\t    0, MODEKEYCOPY_CLEARSELECTION },\n\t{ '\\n',\t\t\t    0, MODEKEYCOPY_COPYSELECTION },\n\t{ '\\r',\t\t\t    0, MODEKEYCOPY_COPYSELECTION },\n\t{ '^',\t\t\t    0, MODEKEYCOPY_BACKTOINDENTATION },\n\t{ 'b',\t\t\t    0, MODEKEYCOPY_PREVIOUSWORD },\n\t{ 'e',\t\t\t    0, MODEKEYCOPY_NEXTWORDEND },\n\t{ 'f',\t\t\t    0, MODEKEYCOPY_JUMP },\n\t{ 'g',\t\t\t    0, MODEKEYCOPY_HISTORYTOP },\n\t{ 'h',\t\t\t    0, MODEKEYCOPY_LEFT },\n\t{ 'j',\t\t\t    0, MODEKEYCOPY_DOWN },\n\t{ 'k',\t\t\t    0, MODEKEYCOPY_UP },\n\t{ 'l',\t\t\t    0, MODEKEYCOPY_RIGHT },\n\t{ 'n',\t\t\t    0, MODEKEYCOPY_SEARCHAGAIN },\n\t{ 'o',\t\t\t    0, MODEKEYCOPY_OTHEREND },\n\t{ 't',\t\t\t    0, MODEKEYCOPY_JUMPTO },\n\t{ 'q',\t\t\t    0, MODEKEYCOPY_CANCEL },\n\t{ 'v',\t\t\t    0, MODEKEYCOPY_RECTANGLETOGGLE },\n\t{ 'w',\t\t\t    0, MODEKEYCOPY_NEXTWORD },\n\t{ KEYC_BSPACE,\t\t    0, MODEKEYCOPY_LEFT },\n\t{ KEYC_DOWN | KEYC_CTRL,    0, MODEKEYCOPY_SCROLLDOWN },\n\t{ KEYC_DOWN,\t\t    0, MODEKEYCOPY_DOWN },\n\t{ KEYC_LEFT,\t\t    0, MODEKEYCOPY_LEFT },\n\t{ KEYC_NPAGE,\t\t    0, MODEKEYCOPY_NEXTPAGE },\n\t{ KEYC_PPAGE,\t\t    0, MODEKEYCOPY_PREVIOUSPAGE },\n\t{ KEYC_RIGHT,\t\t    0, MODEKEYCOPY_RIGHT },\n\t{ KEYC_UP | KEYC_CTRL,\t    0, MODEKEYCOPY_SCROLLUP },\n\t{ KEYC_UP,\t\t    0, MODEKEYCOPY_UP },\n\t{ KEYC_WHEELUP_PANE,        0, MODEKEYCOPY_SCROLLUP },\n\t{ KEYC_WHEELDOWN_PANE,      0, MODEKEYCOPY_SCROLLDOWN },\n\t{ KEYC_MOUSEDRAG1_PANE,     0, MODEKEYCOPY_STARTSELECTION },\n\t{ KEYC_MOUSEDRAGEND1_PANE,  0, MODEKEYCOPY_COPYSELECTION },\n\n\t{ 0,\t\t\t   -1, 0 }\n};\nstruct mode_key_tree mode_key_tree_vi_copy;\n\n/* emacs editing keys. */\nconst struct mode_key_entry mode_key_emacs_edit[] = {\n\t{ '\\001' /* C-a */,\t    0, MODEKEYEDIT_STARTOFLINE },\n\t{ '\\002' /* C-b */,\t    0, MODEKEYEDIT_CURSORLEFT },\n\t{ '\\003' /* C-c */,\t    0, MODEKEYEDIT_CANCEL },\n\t{ '\\004' /* C-d */,\t    0, MODEKEYEDIT_DELETE },\n\t{ '\\005' /* C-e */,\t    0, MODEKEYEDIT_ENDOFLINE },\n\t{ '\\006' /* C-f */,\t    0, MODEKEYEDIT_CURSORRIGHT },\n\t{ '\\010' /* C-H */,\t    0, MODEKEYEDIT_BACKSPACE },\n\t{ '\\011' /* Tab */,\t    0, MODEKEYEDIT_COMPLETE },\n\t{ '\\013' /* C-k */,\t    0, MODEKEYEDIT_DELETETOENDOFLINE },\n\t{ '\\016' /* C-n */,\t    0, MODEKEYEDIT_HISTORYDOWN },\n\t{ '\\020' /* C-p */,\t    0, MODEKEYEDIT_HISTORYUP },\n\t{ '\\024' /* C-t */,\t    0, MODEKEYEDIT_TRANSPOSECHARS },\n\t{ '\\025' /* C-u */,\t    0, MODEKEYEDIT_DELETELINE },\n\t{ '\\027' /* C-w */,\t    0, MODEKEYEDIT_DELETEWORD },\n\t{ '\\031' /* C-y */,\t    0, MODEKEYEDIT_PASTE },\n\t{ '\\033' /* Escape */,\t    0, MODEKEYEDIT_CANCEL },\n\t{ '\\n',\t\t\t    0, MODEKEYEDIT_ENTER },\n\t{ '\\r',\t\t\t    0, MODEKEYEDIT_ENTER },\n\t{ 'b' | KEYC_ESCAPE,\t    0, MODEKEYEDIT_PREVIOUSWORD },\n\t{ 'f' | KEYC_ESCAPE,\t    0, MODEKEYEDIT_NEXTWORDEND },\n\t{ 'm' | KEYC_ESCAPE,\t    0, MODEKEYEDIT_STARTOFLINE },\n\t{ KEYC_BSPACE,\t\t    0, MODEKEYEDIT_BACKSPACE },\n\t{ KEYC_DC,\t\t    0, MODEKEYEDIT_DELETE },\n\t{ KEYC_DOWN,\t\t    0, MODEKEYEDIT_HISTORYDOWN },\n\t{ KEYC_LEFT,\t\t    0, MODEKEYEDIT_CURSORLEFT },\n\t{ KEYC_RIGHT,\t\t    0, MODEKEYEDIT_CURSORRIGHT },\n\t{ KEYC_UP,\t\t    0, MODEKEYEDIT_HISTORYUP },\n\t{ KEYC_HOME,\t\t    0, MODEKEYEDIT_STARTOFLINE },\n\t{ KEYC_END,\t\t    0, MODEKEYEDIT_ENDOFLINE },\n\n\t{ 0,\t\t\t   -1, 0 }\n};\nstruct mode_key_tree mode_key_tree_emacs_edit;\n\n/* emacs choice selection keys. */\nconst struct mode_key_entry mode_key_emacs_choice[] = {\n\t{ '0' | KEYC_ESCAPE,\t    0, MODEKEYCHOICE_STARTNUMBERPREFIX },\n\t{ '1' | KEYC_ESCAPE,\t    0, MODEKEYCHOICE_STARTNUMBERPREFIX },\n\t{ '2' | KEYC_ESCAPE,\t    0, MODEKEYCHOICE_STARTNUMBERPREFIX },\n\t{ '3' | KEYC_ESCAPE,\t    0, MODEKEYCHOICE_STARTNUMBERPREFIX },\n\t{ '4' | KEYC_ESCAPE,\t    0, MODEKEYCHOICE_STARTNUMBERPREFIX },\n\t{ '5' | KEYC_ESCAPE,\t    0, MODEKEYCHOICE_STARTNUMBERPREFIX },\n\t{ '6' | KEYC_ESCAPE,\t    0, MODEKEYCHOICE_STARTNUMBERPREFIX },\n\t{ '7' | KEYC_ESCAPE,\t    0, MODEKEYCHOICE_STARTNUMBERPREFIX },\n\t{ '8' | KEYC_ESCAPE,\t    0, MODEKEYCHOICE_STARTNUMBERPREFIX },\n\t{ '9' | KEYC_ESCAPE,\t    0, MODEKEYCHOICE_STARTNUMBERPREFIX },\n\t{ '\\003' /* C-c */,\t    0, MODEKEYCHOICE_CANCEL },\n\t{ '\\016' /* C-n */,\t    0, MODEKEYCHOICE_DOWN },\n\t{ '\\020' /* C-p */,\t    0, MODEKEYCHOICE_UP },\n\t{ '\\026' /* C-v */,\t    0, MODEKEYCHOICE_PAGEDOWN },\n\t{ '\\033' /* Escape */,\t    0, MODEKEYCHOICE_CANCEL },\n\t{ '\\n',\t\t\t    0, MODEKEYCHOICE_CHOOSE },\n\t{ '\\r',\t\t\t    0, MODEKEYCHOICE_CHOOSE },\n\t{ 'q',\t\t\t    0, MODEKEYCHOICE_CANCEL },\n\t{ 'v' | KEYC_ESCAPE,\t    0, MODEKEYCHOICE_PAGEUP },\n\t{ KEYC_HOME,                0, MODEKEYCHOICE_STARTOFLIST },\n\t{ '<' | KEYC_ESCAPE,\t    0, MODEKEYCHOICE_STARTOFLIST },\n\t{ 'R' | KEYC_ESCAPE,\t    0, MODEKEYCHOICE_TOPLINE },\n\t{ '>' | KEYC_ESCAPE,\t    0, MODEKEYCHOICE_ENDOFLIST },\n\t{ KEYC_END,                 0, MODEKEYCHOICE_ENDOFLIST },\n\t{ KEYC_BSPACE,\t\t    0, MODEKEYCHOICE_BACKSPACE },\n\t{ KEYC_DOWN | KEYC_CTRL,    0, MODEKEYCHOICE_SCROLLDOWN },\n\t{ KEYC_DOWN,\t\t    0, MODEKEYCHOICE_DOWN },\n\t{ KEYC_NPAGE,\t\t    0, MODEKEYCHOICE_PAGEDOWN },\n\t{ KEYC_PPAGE,\t\t    0, MODEKEYCHOICE_PAGEUP },\n\t{ KEYC_UP | KEYC_CTRL,\t    0, MODEKEYCHOICE_SCROLLUP },\n\t{ KEYC_UP,\t\t    0, MODEKEYCHOICE_UP },\n\t{ ' ',\t\t\t    0, MODEKEYCHOICE_TREE_TOGGLE },\n\t{ KEYC_LEFT,\t\t    0, MODEKEYCHOICE_TREE_COLLAPSE },\n\t{ KEYC_RIGHT,\t\t    0, MODEKEYCHOICE_TREE_EXPAND },\n\t{ KEYC_LEFT | KEYC_CTRL,    0, MODEKEYCHOICE_TREE_COLLAPSE_ALL },\n\t{ KEYC_RIGHT | KEYC_CTRL,   0, MODEKEYCHOICE_TREE_EXPAND_ALL },\n\t{ KEYC_MOUSEDOWN1_PANE,     0, MODEKEYCHOICE_CHOOSE },\n\t{ KEYC_MOUSEDOWN3_PANE,     0, MODEKEYCHOICE_TREE_TOGGLE },\n\t{ KEYC_WHEELUP_PANE,        0, MODEKEYCHOICE_UP },\n\t{ KEYC_WHEELDOWN_PANE,      0, MODEKEYCHOICE_DOWN },\n\n\t{ 0,\t\t\t   -1, 0 }\n};\nstruct mode_key_tree mode_key_tree_emacs_choice;\n\n/* emacs copy mode keys. */\nconst struct mode_key_entry mode_key_emacs_copy[] = {\n\t{ ' ',\t\t\t    0, MODEKEYCOPY_NEXTPAGE },\n\t{ ',',\t\t\t    0, MODEKEYCOPY_JUMPREVERSE },\n\t{ ';',\t\t\t    0, MODEKEYCOPY_JUMPAGAIN },\n\t{ '1' | KEYC_ESCAPE,\t    0, MODEKEYCOPY_STARTNUMBERPREFIX },\n\t{ '2' | KEYC_ESCAPE,\t    0, MODEKEYCOPY_STARTNUMBERPREFIX },\n\t{ '3' | KEYC_ESCAPE,\t    0, MODEKEYCOPY_STARTNUMBERPREFIX },\n\t{ '4' | KEYC_ESCAPE,\t    0, MODEKEYCOPY_STARTNUMBERPREFIX },\n\t{ '5' | KEYC_ESCAPE,\t    0, MODEKEYCOPY_STARTNUMBERPREFIX },\n\t{ '6' | KEYC_ESCAPE,\t    0, MODEKEYCOPY_STARTNUMBERPREFIX },\n\t{ '7' | KEYC_ESCAPE,\t    0, MODEKEYCOPY_STARTNUMBERPREFIX },\n\t{ '8' | KEYC_ESCAPE,\t    0, MODEKEYCOPY_STARTNUMBERPREFIX },\n\t{ '9' | KEYC_ESCAPE,\t    0, MODEKEYCOPY_STARTNUMBERPREFIX },\n\t{ '<' | KEYC_ESCAPE,\t    0, MODEKEYCOPY_HISTORYTOP },\n\t{ '>' | KEYC_ESCAPE,\t    0, MODEKEYCOPY_HISTORYBOTTOM },\n\t{ 'F',\t\t\t    0, MODEKEYCOPY_JUMPBACK },\n\t{ 'N',\t\t\t    0, MODEKEYCOPY_SEARCHREVERSE },\n\t{ 'R' | KEYC_ESCAPE,\t    0, MODEKEYCOPY_TOPLINE },\n\t{ 'R',\t\t\t    0, MODEKEYCOPY_RECTANGLETOGGLE },\n\t{ 'T',\t\t\t    0, MODEKEYCOPY_JUMPTOBACK },\n\t{ '\\000' /* C-Space */,\t    0, MODEKEYCOPY_STARTSELECTION },\n\t{ '\\001' /* C-a */,\t    0, MODEKEYCOPY_STARTOFLINE },\n\t{ '\\002' /* C-b */,\t    0, MODEKEYCOPY_LEFT },\n\t{ '\\003' /* C-c */,\t    0, MODEKEYCOPY_CANCEL },\n\t{ '\\005' /* C-e */,\t    0, MODEKEYCOPY_ENDOFLINE },\n\t{ '\\006' /* C-f */,\t    0, MODEKEYCOPY_RIGHT },\n\t{ '\\007' /* C-g */,\t    0, MODEKEYCOPY_CLEARSELECTION },\n\t{ '\\013' /* C-k */,\t    0, MODEKEYCOPY_COPYENDOFLINE },\n\t{ '\\016' /* C-n */,\t    0, MODEKEYCOPY_DOWN },\n\t{ '\\020' /* C-p */,\t    0, MODEKEYCOPY_UP },\n\t{ '\\022' /* C-r */,\t    0, MODEKEYCOPY_SEARCHUP },\n\t{ '\\023' /* C-s */,\t    0, MODEKEYCOPY_SEARCHDOWN },\n\t{ '\\026' /* C-v */,\t    0, MODEKEYCOPY_NEXTPAGE },\n\t{ '\\027' /* C-w */,\t    0, MODEKEYCOPY_COPYSELECTION },\n\t{ '\\033' /* Escape */,\t    0, MODEKEYCOPY_CANCEL },\n\t{ 'b' | KEYC_ESCAPE,\t    0, MODEKEYCOPY_PREVIOUSWORD },\n\t{ 'f',\t\t\t    0, MODEKEYCOPY_JUMP },\n\t{ 'f' | KEYC_ESCAPE,\t    0, MODEKEYCOPY_NEXTWORDEND },\n\t{ 'g',\t\t\t    0, MODEKEYCOPY_GOTOLINE },\n\t{ 'm' | KEYC_ESCAPE,\t    0, MODEKEYCOPY_BACKTOINDENTATION },\n\t{ 'n',\t\t\t    0, MODEKEYCOPY_SEARCHAGAIN },\n\t{ 'q',\t\t\t    0, MODEKEYCOPY_CANCEL },\n\t{ 'r' | KEYC_ESCAPE,\t    0, MODEKEYCOPY_MIDDLELINE },\n\t{ 't',\t\t\t    0, MODEKEYCOPY_JUMPTO },\n\t{ 'v' | KEYC_ESCAPE,\t    0, MODEKEYCOPY_PREVIOUSPAGE },\n\t{ 'w' | KEYC_ESCAPE,\t    0, MODEKEYCOPY_COPYSELECTION },\n\t{ KEYC_DOWN | KEYC_CTRL,    0, MODEKEYCOPY_SCROLLDOWN },\n\t{ KEYC_DOWN | KEYC_ESCAPE,  0, MODEKEYCOPY_HALFPAGEDOWN },\n\t{ KEYC_DOWN,\t\t    0, MODEKEYCOPY_DOWN },\n\t{ KEYC_LEFT,\t\t    0, MODEKEYCOPY_LEFT },\n\t{ KEYC_NPAGE,\t\t    0, MODEKEYCOPY_NEXTPAGE },\n\t{ KEYC_PPAGE,\t\t    0, MODEKEYCOPY_PREVIOUSPAGE },\n\t{ KEYC_RIGHT,\t\t    0, MODEKEYCOPY_RIGHT },\n\t{ KEYC_UP | KEYC_CTRL,\t    0, MODEKEYCOPY_SCROLLUP },\n\t{ KEYC_UP | KEYC_ESCAPE,    0, MODEKEYCOPY_HALFPAGEUP },\n\t{ KEYC_UP,\t\t    0, MODEKEYCOPY_UP },\n\t{ KEYC_WHEELUP_PANE,        0, MODEKEYCOPY_SCROLLUP },\n\t{ KEYC_WHEELDOWN_PANE,      0, MODEKEYCOPY_SCROLLDOWN },\n\t{ KEYC_MOUSEDRAG1_PANE,     0, MODEKEYCOPY_STARTSELECTION },\n\t{ KEYC_MOUSEDRAGEND1_PANE,  0, MODEKEYCOPY_COPYSELECTION },\n\n\t{ 0,\t\t\t   -1, 0 }\n};\nstruct mode_key_tree mode_key_tree_emacs_copy;\n\n/* Table mapping key table names to default settings and trees. */\nconst struct mode_key_table mode_key_tables[] = {\n\t{ \"vi-edit\", mode_key_cmdstr_edit,\n\t  &mode_key_tree_vi_edit, mode_key_vi_edit },\n\t{ \"vi-choice\", mode_key_cmdstr_choice,\n\t  &mode_key_tree_vi_choice, mode_key_vi_choice },\n\t{ \"vi-copy\", mode_key_cmdstr_copy,\n\t  &mode_key_tree_vi_copy, mode_key_vi_copy },\n\t{ \"emacs-edit\", mode_key_cmdstr_edit,\n\t  &mode_key_tree_emacs_edit, mode_key_emacs_edit },\n\t{ \"emacs-choice\", mode_key_cmdstr_choice,\n\t  &mode_key_tree_emacs_choice, mode_key_emacs_choice },\n\t{ \"emacs-copy\", mode_key_cmdstr_copy,\n\t  &mode_key_tree_emacs_copy, mode_key_emacs_copy },\n\n\t{ NULL, NULL, NULL, NULL }\n};\n\nRB_GENERATE(mode_key_tree, mode_key_binding, entry, mode_key_cmp);\n\nint\nmode_key_cmp(struct mode_key_binding *mbind1, struct mode_key_binding *mbind2)\n{\n\tif (mbind1->mode < mbind2->mode)\n\t\treturn (-1);\n\tif (mbind1->mode > mbind2->mode)\n\t\treturn (1);\n\tif (mbind1->key < mbind2->key)\n\t\treturn (-1);\n\tif (mbind1->key > mbind2->key)\n\t\treturn (1);\n\treturn (0);\n}\n\nconst char *\nmode_key_tostring(const struct mode_key_cmdstr *cmdstr, enum mode_key_cmd cmd)\n{\n\tfor (; cmdstr->name != NULL; cmdstr++) {\n\t\tif (cmdstr->cmd == cmd)\n\t\t\treturn (cmdstr->name);\n\t}\n\treturn (NULL);\n}\n\nenum mode_key_cmd\nmode_key_fromstring(const struct mode_key_cmdstr *cmdstr, const char *name)\n{\n\tfor (; cmdstr->name != NULL; cmdstr++) {\n\t\tif (strcasecmp(cmdstr->name, name) == 0)\n\t\t\treturn (cmdstr->cmd);\n\t}\n\treturn (MODEKEY_NONE);\n}\n\nconst struct mode_key_table *\nmode_key_findtable(const char *name)\n{\n\tconst struct mode_key_table\t*mtab;\n\n\tfor (mtab = mode_key_tables; mtab->name != NULL; mtab++) {\n\t\tif (strcasecmp(name, mtab->name) == 0)\n\t\t\treturn (mtab);\n\t}\n\treturn (NULL);\n}\n\nvoid\nmode_key_init_trees(void)\n{\n\tconst struct mode_key_table\t*mtab;\n\tconst struct mode_key_entry\t*ment;\n\tstruct mode_key_binding\t\t*mbind;\n\n\tfor (mtab = mode_key_tables; mtab->name != NULL; mtab++) {\n\t\tRB_INIT(mtab->tree);\n\t\tfor (ment = mtab->table; ment->mode != -1; ment++) {\n\t\t\tmbind = xmalloc(sizeof *mbind);\n\t\t\tmbind->key = ment->key;\n\t\t\tmbind->mode = ment->mode;\n\t\t\tmbind->cmd = ment->cmd;\n\t\t\tmbind->arg = NULL;\n\t\t\tRB_INSERT(mode_key_tree, mtab->tree, mbind);\n\t\t}\n\t}\n}\n\nvoid\nmode_key_init(struct mode_key_data *mdata, struct mode_key_tree *mtree)\n{\n\tmdata->tree = mtree;\n\tmdata->mode = 0;\n}\n\nenum mode_key_cmd\nmode_key_lookup(struct mode_key_data *mdata, key_code key, const char **arg)\n{\n\tstruct mode_key_binding\t*mbind, mtmp;\n\n\tmtmp.key = key;\n\tmtmp.mode = mdata->mode;\n\tif ((mbind = RB_FIND(mode_key_tree, mdata->tree, &mtmp)) == NULL) {\n\t\tif (mdata->mode != 0)\n\t\t\treturn (MODEKEY_NONE);\n\t\treturn (MODEKEY_OTHER);\n\t}\n\n\tswitch (mbind->cmd) {\n\tcase MODEKEYEDIT_SWITCHMODE:\n\tcase MODEKEYEDIT_SWITCHMODEAPPEND:\n\tcase MODEKEYEDIT_SWITCHMODEAPPENDLINE:\n\tcase MODEKEYEDIT_SWITCHMODEBEGINLINE:\n\tcase MODEKEYEDIT_SWITCHMODECHANGELINE:\n\tcase MODEKEYEDIT_SWITCHMODESUBSTITUTE:\n\tcase MODEKEYEDIT_SWITCHMODESUBSTITUTELINE:\n\t\tmdata->mode = 1 - mdata->mode;\n\t\t/* FALLTHROUGH */\n\tdefault:\n\t\tif (arg != NULL)\n\t\t\t*arg = mbind->arg;\n\t\treturn (mbind->cmd);\n\t}\n}\n"
        },
        {
          "name": "names.c",
          "type": "blob",
          "size": 3.798828125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <ctype.h>\n#include <libgen.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\nvoid\tname_time_callback(int, short, void *);\nint\tname_time_expired(struct window *, struct timeval *);\n\nvoid\nname_time_callback(__unused int fd, __unused short events, void *arg)\n{\n\tstruct window\t*w = arg;\n\n\t/* The event loop will call check_window_name for us on the way out. */\n\tlog_debug(\"@%u name timer expired\", w->id);\n}\n\nint\nname_time_expired(struct window *w, struct timeval *tv)\n{\n\tstruct timeval\toffset;\n\n\ttimersub(tv, &w->name_time, &offset);\n\tif (offset.tv_sec != 0 || offset.tv_usec > NAME_INTERVAL)\n\t\treturn (0);\n\treturn (NAME_INTERVAL - offset.tv_usec);\n}\n\nvoid\ncheck_window_name(struct window *w)\n{\n\tstruct timeval\t tv, next;\n\tchar\t\t*name;\n\tint\t\t left;\n\n\tif (w->active == NULL)\n\t\treturn;\n\n\tif (!options_get_number(w->options, \"automatic-rename\"))\n\t\treturn;\n\n\tif (~w->active->flags & PANE_CHANGED) {\n\t\tlog_debug(\"@%u active pane not changed\", w->id);\n\t\treturn;\n\t}\n\tlog_debug(\"@%u active pane changed\", w->id);\n\n\tgettimeofday(&tv, NULL);\n\tleft = name_time_expired(w, &tv);\n\tif (left != 0) {\n\t\tif (!event_initialized(&w->name_event))\n\t\t\tevtimer_set(&w->name_event, name_time_callback, w);\n\t\tif (!evtimer_pending(&w->name_event, NULL)) {\n\t\t\tlog_debug(\"@%u name timer queued (%d left)\", w->id, left);\n\t\t\ttimerclear(&next);\n\t\t\tnext.tv_usec = left;\n\t\t\tevent_add(&w->name_event, &next);\n\t\t} else\n\t\t\tlog_debug(\"@%u name timer already queued (%d left)\", w->id, left);\n\t\treturn;\n\t}\n\tmemcpy(&w->name_time, &tv, sizeof w->name_time);\n\tif (event_initialized(&w->name_event))\n\t\tevtimer_del(&w->name_event);\n\n\tw->active->flags &= ~PANE_CHANGED;\n\n\tname = format_window_name(w);\n\tif (strcmp(name, w->name) != 0) {\n\t\tlog_debug(\"@%u new name %s (was %s)\", w->id, name, w->name);\n\t\twindow_set_name(w, name);\n\t\tserver_status_window(w);\n\t} else\n\t\tlog_debug(\"@%u name not changed (still %s)\", w->id, w->name);\n\n\tfree(name);\n}\n\nchar *\ndefault_window_name(struct window *w)\n{\n\tchar    *cmd, *s;\n\n\tcmd = cmd_stringify_argv(w->active->argc, w->active->argv);\n\tif (cmd != NULL && *cmd != '\\0')\n\t\ts = parse_window_name(cmd);\n\telse\n\t\ts = parse_window_name(w->active->shell);\n\tfree(cmd);\n\treturn (s);\n}\n\nchar *\nformat_window_name(struct window *w)\n{\n\tstruct format_tree\t*ft;\n\tchar\t\t\t*fmt, *name;\n\n\tft = format_create(NULL, 0);\n\tformat_defaults_window(ft, w);\n\tformat_defaults_pane(ft, w->active);\n\n\tfmt = options_get_string(w->options, \"automatic-rename-format\");\n\tname = format_expand(ft, fmt);\n\n\tformat_free(ft);\n\treturn (name);\n}\n\nchar *\nparse_window_name(const char *in)\n{\n\tchar\t*copy, *name, *ptr;\n\n\tname = copy = xstrdup(in);\n\tif (strncmp(name, \"exec \", (sizeof \"exec \") - 1) == 0)\n\t\tname = name + (sizeof \"exec \") - 1;\n\n\twhile (*name == ' ' || *name == '-')\n\t\tname++;\n\tif ((ptr = strchr(name, ' ')) != NULL)\n\t\t*ptr = '\\0';\n\n\tif (*name != '\\0') {\n\t\tptr = name + strlen(name) - 1;\n\t\twhile (ptr > name && !isalnum((u_char)*ptr))\n\t\t\t*ptr-- = '\\0';\n\t}\n\n\tif (*name == '/')\n\t\tname = basename(name);\n\tname = xstrdup(name);\n\tfree(copy);\n\treturn (name);\n}\n"
        },
        {
          "name": "notify.c",
          "type": "blob",
          "size": 4.41796875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2012 George Nachman <tmux@georgester.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n\n#include \"tmux.h\"\n\nenum notify_type {\n\tNOTIFY_WINDOW_LAYOUT_CHANGED,\n\tNOTIFY_WINDOW_UNLINKED,\n\tNOTIFY_WINDOW_LINKED,\n\tNOTIFY_WINDOW_RENAMED,\n\tNOTIFY_ATTACHED_SESSION_CHANGED,\n\tNOTIFY_SESSION_RENAMED,\n\tNOTIFY_SESSION_CREATED,\n\tNOTIFY_SESSION_CLOSED\n};\n\nstruct notify_entry {\n\tenum notify_type\t type;\n\n\tstruct client\t\t*client;\n\tstruct session\t\t*session;\n\tstruct window\t\t*window;\n\n\tTAILQ_ENTRY(notify_entry) entry;\n};\nTAILQ_HEAD(, notify_entry) notify_queue = TAILQ_HEAD_INITIALIZER(notify_queue);\nint\tnotify_enabled = 1;\n\nvoid\tnotify_drain(void);\nvoid\tnotify_add(enum notify_type, struct client *, struct session *,\n\t    struct window *);\n\nvoid\nnotify_enable(void)\n{\n\tnotify_enabled = 1;\n\tnotify_drain();\n}\n\nvoid\nnotify_disable(void)\n{\n\tnotify_enabled = 0;\n}\n\nvoid\nnotify_add(enum notify_type type, struct client *c, struct session *s,\n    struct window *w)\n{\n\tstruct notify_entry\t*ne;\n\n\tne = xcalloc(1, sizeof *ne);\n\tne->type = type;\n\tne->client = c;\n\tne->session = s;\n\tne->window = w;\n\tTAILQ_INSERT_TAIL(&notify_queue, ne, entry);\n\n\tif (c != NULL)\n\t\tc->references++;\n\tif (s != NULL)\n\t\ts->references++;\n\tif (w != NULL)\n\t\tw->references++;\n}\n\nvoid\nnotify_drain(void)\n{\n\tstruct notify_entry\t*ne, *ne1;\n\n\tif (!notify_enabled)\n\t\treturn;\n\n\tTAILQ_FOREACH_SAFE(ne, &notify_queue, entry, ne1) {\n\t\tswitch (ne->type) {\n\t\tcase NOTIFY_WINDOW_LAYOUT_CHANGED:\n\t\t\tcontrol_notify_window_layout_changed(ne->window);\n\t\t\tbreak;\n\t\tcase NOTIFY_WINDOW_UNLINKED:\n\t\t\tcontrol_notify_window_unlinked(ne->session, ne->window);\n\t\t\tbreak;\n\t\tcase NOTIFY_WINDOW_LINKED:\n\t\t\tcontrol_notify_window_linked(ne->session, ne->window);\n\t\t\tbreak;\n\t\tcase NOTIFY_WINDOW_RENAMED:\n\t\t\tcontrol_notify_window_renamed(ne->window);\n\t\t\tbreak;\n\t\tcase NOTIFY_ATTACHED_SESSION_CHANGED:\n\t\t\tcontrol_notify_attached_session_changed(ne->client);\n\t\t\tbreak;\n\t\tcase NOTIFY_SESSION_RENAMED:\n\t\t\tcontrol_notify_session_renamed(ne->session);\n\t\t\tbreak;\n\t\tcase NOTIFY_SESSION_CREATED:\n\t\t\tcontrol_notify_session_created(ne->session);\n\t\t\tbreak;\n\t\tcase NOTIFY_SESSION_CLOSED:\n\t\t\tcontrol_notify_session_close(ne->session);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ne->client != NULL)\n\t\t\tserver_client_unref(ne->client);\n\t\tif (ne->session != NULL)\n\t\t\tsession_unref(ne->session);\n\t\tif (ne->window != NULL)\n\t\t\twindow_remove_ref(ne->window);\n\n\t\tTAILQ_REMOVE(&notify_queue, ne, entry);\n\t\tfree(ne);\n\t}\n}\n\nvoid\nnotify_input(struct window_pane *wp, struct evbuffer *input)\n{\n\tstruct client\t*c;\n\n\t/*\n\t * notify_input() is not queued and only does anything when\n\t * notifications are enabled.\n\t */\n\tif (!notify_enabled)\n\t\treturn;\n\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (c->flags & CLIENT_CONTROL)\n\t\t\tcontrol_notify_input(c, wp, input);\n\t}\n}\n\nvoid\nnotify_window_layout_changed(struct window *w)\n{\n\tnotify_add(NOTIFY_WINDOW_LAYOUT_CHANGED, NULL, NULL, w);\n\tnotify_drain();\n}\n\nvoid\nnotify_window_unlinked(struct session *s, struct window *w)\n{\n\tnotify_add(NOTIFY_WINDOW_UNLINKED, NULL, s, w);\n\tnotify_drain();\n}\n\nvoid\nnotify_window_linked(struct session *s, struct window *w)\n{\n\tnotify_add(NOTIFY_WINDOW_LINKED, NULL, s, w);\n\tnotify_drain();\n}\n\nvoid\nnotify_window_renamed(struct window *w)\n{\n\tnotify_add(NOTIFY_WINDOW_RENAMED, NULL, NULL, w);\n\tnotify_drain();\n}\n\nvoid\nnotify_attached_session_changed(struct client *c)\n{\n\tnotify_add(NOTIFY_ATTACHED_SESSION_CHANGED, c, NULL, NULL);\n\tnotify_drain();\n}\n\nvoid\nnotify_session_renamed(struct session *s)\n{\n\tnotify_add(NOTIFY_SESSION_RENAMED, NULL, s, NULL);\n\tnotify_drain();\n}\n\nvoid\nnotify_session_created(struct session *s)\n{\n\tnotify_add(NOTIFY_SESSION_CREATED, NULL, s, NULL);\n\tnotify_drain();\n}\n\nvoid\nnotify_session_closed(struct session *s)\n{\n\tnotify_add(NOTIFY_SESSION_CLOSED, NULL, s, NULL);\n\tnotify_drain();\n}\n"
        },
        {
          "name": "options-table.c",
          "type": "blob",
          "size": 24.623046875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2011 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * This file has a tables with all the server, session and window\n * options. These tables are the master copy of the options with their real\n * (user-visible) types, range limits and default values. At start these are\n * copied into the runtime global options trees (which only has number and\n * string types). These tables are then used to look up the real type when the\n * user sets an option or its value needs to be shown.\n */\n\n/* Choice option type lists. */\nconst char *options_table_mode_keys_list[] = {\n\t\"emacs\", \"vi\", NULL\n};\nconst char *options_table_clock_mode_style_list[] = {\n\t\"12\", \"24\", NULL\n};\nconst char *options_table_status_keys_list[] = {\n\t\"emacs\", \"vi\", NULL\n};\nconst char *options_table_status_justify_list[] = {\n\t\"left\", \"centre\", \"right\", NULL\n};\nconst char *options_table_status_position_list[] = {\n\t\"top\", \"bottom\", NULL\n};\nconst char *options_table_bell_action_list[] = {\n\t\"none\", \"any\", \"current\", \"other\", NULL\n};\n\n/* Server options. */\nconst struct options_table_entry options_table[] = {\n\t{ .name = \"buffer-limit\",\n\t  .type = OPTIONS_TABLE_NUMBER,\n\t  .scope = OPTIONS_TABLE_SERVER,\n\t  .minimum = 1,\n\t  .maximum = INT_MAX,\n\t  .default_num = 20\n\t},\n\n\t{ .name = \"default-terminal\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_SERVER,\n#ifdef TMATE\n\t  .default_str = \"screen-256color\"\n#else\n\t  .default_str = \"screen\"\n#endif\n\t},\n\n\t{ .name = \"escape-time\",\n\t  .type = OPTIONS_TABLE_NUMBER,\n\t  .scope = OPTIONS_TABLE_SERVER,\n\t  .minimum = 0,\n\t  .maximum = INT_MAX,\n\t  .default_num = 500\n\t},\n\n\t{ .name = \"exit-unattached\",\n\t  .type = OPTIONS_TABLE_FLAG,\n\t  .scope = OPTIONS_TABLE_SERVER,\n\t  .default_num = 0\n\t},\n\n\t{ .name = \"focus-events\",\n\t  .type = OPTIONS_TABLE_FLAG,\n\t  .scope = OPTIONS_TABLE_SERVER,\n\t  .default_num = 0\n\t},\n\n\t{ .name = \"history-file\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_SERVER,\n\t  .default_str = \"\"\n\t},\n\n\t{ .name = \"message-limit\",\n\t  .type = OPTIONS_TABLE_NUMBER,\n\t  .scope = OPTIONS_TABLE_SERVER,\n\t  .minimum = 0,\n\t  .maximum = INT_MAX,\n#ifdef TMATE\n\t  .default_num = 500\n#else\n\t  .default_num = 100\n#endif\n\t},\n\n\t{ .name = \"quiet\",\n\t  .type = OPTIONS_TABLE_FLAG,\n\t  .scope = OPTIONS_TABLE_SERVER,\n\t  .default_num = 0\n\t},\n\n\t{ .name = \"set-clipboard\",\n\t  .type = OPTIONS_TABLE_FLAG,\n\t  .scope = OPTIONS_TABLE_SERVER,\n\t  .default_num = 1\n\t},\n\n\t{ .name = \"terminal-overrides\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_SERVER,\n\t  .default_str = \"xterm*:XT:Ms=\\\\E]52;%p1%s;%p2%s\\\\007\"\n\t                 \":Cs=\\\\E]12;%p1%s\\\\007:Cr=\\\\E]112\\\\007\"\n\t\t\t \":Ss=\\\\E[%p1%d q:Se=\\\\E[2 q,screen*:XT\"\n\t},\n\n\t{ .name = \"assume-paste-time\",\n\t  .type = OPTIONS_TABLE_NUMBER,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .minimum = 0,\n\t  .maximum = INT_MAX,\n\t  .default_num = 1,\n\t},\n\n\t{ .name = \"base-index\",\n\t  .type = OPTIONS_TABLE_NUMBER,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .minimum = 0,\n\t  .maximum = INT_MAX,\n\t  .default_num = 0\n\t},\n\n\t{ .name = \"bell-action\",\n\t  .type = OPTIONS_TABLE_CHOICE,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .choices = options_table_bell_action_list,\n\t  .default_num = BELL_ANY\n\t},\n\n\t{ .name = \"bell-on-alert\",\n\t  .type = OPTIONS_TABLE_FLAG,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_num = 0\n\t},\n\n\t{ .name = \"default-command\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_str = \"\"\n\t},\n\n\t{ .name = \"default-shell\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_str = _PATH_BSHELL\n\t},\n\n\t{ .name = \"destroy-unattached\",\n\t  .type = OPTIONS_TABLE_FLAG,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_num = 0\n\t},\n\n\t{ .name = \"detach-on-destroy\",\n\t  .type = OPTIONS_TABLE_FLAG,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_num = 1\n\t},\n\n\t{ .name = \"display-panes-active-colour\",\n\t  .type = OPTIONS_TABLE_COLOUR,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_num = 1\n\t},\n\n\t{ .name = \"display-panes-colour\",\n\t  .type = OPTIONS_TABLE_COLOUR,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_num = 4\n\t},\n\n\t{ .name = \"display-panes-time\",\n\t  .type = OPTIONS_TABLE_NUMBER,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .minimum = 1,\n\t  .maximum = INT_MAX,\n\t  .default_num = 1000\n\t},\n\n\t{ .name = \"display-time\",\n\t  .type = OPTIONS_TABLE_NUMBER,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .minimum = 0,\n\t  .maximum = INT_MAX,\n\t  .default_num = 750\n\t},\n\n\t{ .name = \"history-limit\",\n\t  .type = OPTIONS_TABLE_NUMBER,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .minimum = 0,\n\t  .maximum = INT_MAX,\n\t  .default_num = 2000\n\t},\n\n\t{ .name = \"key-table\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_str = \"root\"\n\t},\n\n\t{ .name = \"lock-after-time\",\n\t  .type = OPTIONS_TABLE_NUMBER,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .minimum = 0,\n\t  .maximum = INT_MAX,\n\t  .default_num = 0\n\t},\n\n\t{ .name = \"lock-command\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_str = \"lock -np\"\n\t},\n\n\t{ .name = \"message-attr\",\n\t  .type = OPTIONS_TABLE_ATTRIBUTES,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_num = 0,\n\t  .style = \"message-style\"\n\t},\n\n\t{ .name = \"message-bg\",\n\t  .type = OPTIONS_TABLE_COLOUR,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_num = 3,\n\t  .style = \"message-style\"\n\t},\n\n\t{ .name = \"message-command-attr\",\n\t  .type = OPTIONS_TABLE_ATTRIBUTES,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_num = 0,\n\t  .style = \"message-command-style\"\n\t},\n\n\t{ .name = \"message-command-bg\",\n\t  .type = OPTIONS_TABLE_COLOUR,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_num = 0,\n\t  .style = \"message-command-style\"\n\t},\n\n\t{ .name = \"message-command-fg\",\n\t  .type = OPTIONS_TABLE_COLOUR,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_num = 3,\n\t  .style = \"message-command-style\"\n\t},\n\n\t{ .name = \"message-command-style\",\n\t  .type = OPTIONS_TABLE_STYLE,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_str = \"bg=black,fg=yellow\"\n\t},\n\n\t{ .name = \"message-fg\",\n\t  .type = OPTIONS_TABLE_COLOUR,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_num = 0,\n\t  .style = \"message-style\"\n\t},\n\n\t{ .name = \"message-style\",\n\t  .type = OPTIONS_TABLE_STYLE,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_str = \"bg=yellow,fg=black\"\n\t},\n\n\t{ .name = \"mouse\",\n\t  .type = OPTIONS_TABLE_FLAG,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_num = 0\n\t},\n\n\t{ .name = \"prefix\",\n\t  .type = OPTIONS_TABLE_KEY,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_num = '\\002',\n\t},\n\n\t{ .name = \"prefix2\",\n\t  .type = OPTIONS_TABLE_KEY,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_num = KEYC_NONE,\n\t},\n\n\t{ .name = \"renumber-windows\",\n\t  .type = OPTIONS_TABLE_FLAG,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_num = 0\n\t},\n\n\t{ .name = \"repeat-time\",\n\t  .type = OPTIONS_TABLE_NUMBER,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .minimum = 0,\n\t  .maximum = SHRT_MAX,\n\t  .default_num = 500\n\t},\n\n\t{ .name = \"set-remain-on-exit\",\n\t  .type = OPTIONS_TABLE_FLAG,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_num = 0\n\t},\n\n\t{ .name = \"set-titles\",\n\t  .type = OPTIONS_TABLE_FLAG,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_num = 0\n\t},\n\n\t{ .name = \"set-titles-string\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_str = \"#S:#I:#W - \\\"#T\\\" #{session_alerts}\"\n\t},\n\n\t{ .name = \"status\",\n\t  .type = OPTIONS_TABLE_FLAG,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_num = 1\n\t},\n\n\t{ .name = \"status-attr\",\n\t  .type = OPTIONS_TABLE_ATTRIBUTES,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_num = 0,\n\t  .style = \"status-style\"\n\t},\n\n\t{ .name = \"status-bg\",\n\t  .type = OPTIONS_TABLE_COLOUR,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_num = 2,\n\t  .style = \"status-style\"\n\t},\n\n\t{ .name = \"status-fg\",\n\t  .type = OPTIONS_TABLE_COLOUR,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_num = 0,\n\t  .style = \"status-style\"\n\t},\n\n\t{ .name = \"status-interval\",\n\t  .type = OPTIONS_TABLE_NUMBER,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .minimum = 0,\n\t  .maximum = INT_MAX,\n\t  .default_num = 15\n\t},\n\n\t{ .name = \"status-justify\",\n\t  .type = OPTIONS_TABLE_CHOICE,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .choices = options_table_status_justify_list,\n\t  .default_num = 0\n\t},\n\n\t{ .name = \"status-keys\",\n\t  .type = OPTIONS_TABLE_CHOICE,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .choices = options_table_status_keys_list,\n\t  .default_num = MODEKEY_EMACS\n\t},\n\n\t{ .name = \"status-left\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_str = \"[#S] \"\n\t},\n\n\t{ .name = \"status-left-attr\",\n\t  .type = OPTIONS_TABLE_ATTRIBUTES,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_num = 0,\n\t  .style = \"status-left-style\"\n\t},\n\n\t{ .name = \"status-left-bg\",\n\t  .type = OPTIONS_TABLE_COLOUR,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_num = 8,\n\t  .style = \"status-left-style\"\n\t},\n\n\t{ .name = \"status-left-fg\",\n\t  .type = OPTIONS_TABLE_COLOUR,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_num = 8,\n\t  .style = \"status-left-style\"\n\t},\n\n\t{ .name = \"status-left-length\",\n\t  .type = OPTIONS_TABLE_NUMBER,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .minimum = 0,\n\t  .maximum = SHRT_MAX,\n\t  .default_num = 10\n\t},\n\n\t{ .name = \"status-left-style\",\n\t  .type = OPTIONS_TABLE_STYLE,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_str = \"default\"\n\t},\n\n\t{ .name = \"status-position\",\n\t  .type = OPTIONS_TABLE_CHOICE,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .choices = options_table_status_position_list,\n\t  .default_num = 1\n\t},\n\n\t{ .name = \"status-right\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_str = \" \\\"#{=21:pane_title}\\\" %H:%M %d-%b-%y\"\n\t},\n\n\t{ .name = \"status-right-attr\",\n\t  .type = OPTIONS_TABLE_ATTRIBUTES,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_num = 0,\n\t  .style = \"status-right-style\"\n\t},\n\n\t{ .name = \"status-right-bg\",\n\t  .type = OPTIONS_TABLE_COLOUR,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_num = 8,\n\t  .style = \"status-right-style\"\n\t},\n\n\t{ .name = \"status-right-fg\",\n\t  .type = OPTIONS_TABLE_COLOUR,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_num = 8,\n\t  .style = \"status-right-style\"\n\t},\n\n\t{ .name = \"status-right-length\",\n\t  .type = OPTIONS_TABLE_NUMBER,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .minimum = 0,\n\t  .maximum = SHRT_MAX,\n\t  .default_num = 40\n\t},\n\n\t{ .name = \"status-right-style\",\n\t  .type = OPTIONS_TABLE_STYLE,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_str = \"default\"\n\t},\n\n\t{ .name = \"status-style\",\n\t  .type = OPTIONS_TABLE_STYLE,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_str = \"bg=green,fg=black\"\n\t},\n\n\t{ .name = \"update-environment\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_str = \"DISPLAY SSH_ASKPASS SSH_AUTH_SOCK SSH_AGENT_PID \"\n\t                 \"SSH_CONNECTION WINDOWID XAUTHORITY\"\n\n\t},\n\n\t{ .name = \"visual-activity\",\n\t  .type = OPTIONS_TABLE_FLAG,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_num = 0\n\t},\n\n\t{ .name = \"visual-bell\",\n\t  .type = OPTIONS_TABLE_FLAG,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_num = 0\n\t},\n\n\t{ .name = \"visual-silence\",\n\t  .type = OPTIONS_TABLE_FLAG,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_num = 0\n\t},\n\n\t{ .name = \"word-separators\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .default_str = \" -_@\"\n\t},\n\n\t{ .name = \"aggressive-resize\",\n\t  .type = OPTIONS_TABLE_FLAG,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_num = 0\n\t},\n\n\t{ .name = \"allow-rename\",\n\t  .type = OPTIONS_TABLE_FLAG,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_num = 1\n\t},\n\n\t{ .name = \"alternate-screen\",\n\t  .type = OPTIONS_TABLE_FLAG,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_num = 1\n\t},\n\n\t{ .name = \"automatic-rename\",\n\t  .type = OPTIONS_TABLE_FLAG,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_num = 1\n\t},\n\n\t{ .name = \"automatic-rename-format\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_str = \"#{?pane_in_mode,[tmux],#{pane_current_command}}\"\n\t                 \"#{?pane_dead,[dead],}\"\n\t},\n\n\t{ .name = \"clock-mode-colour\",\n\t  .type = OPTIONS_TABLE_COLOUR,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_num = 4\n\t},\n\n\t{ .name = \"clock-mode-style\",\n\t  .type = OPTIONS_TABLE_CHOICE,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .choices = options_table_clock_mode_style_list,\n\t  .default_num = 1\n\t},\n\n\t{ .name = \"force-height\",\n\t  .type = OPTIONS_TABLE_NUMBER,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .minimum = 0,\n\t  .maximum = INT_MAX,\n\t  .default_num = 0\n\t},\n\n\t{ .name = \"force-width\",\n\t  .type = OPTIONS_TABLE_NUMBER,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .minimum = 0,\n\t  .maximum = INT_MAX,\n\t  .default_num = 0\n\t},\n\n\t{ .name = \"main-pane-height\",\n\t  .type = OPTIONS_TABLE_NUMBER,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .minimum = 1,\n\t  .maximum = INT_MAX,\n\t  .default_num = 24\n\t},\n\n\t{ .name = \"main-pane-width\",\n\t  .type = OPTIONS_TABLE_NUMBER,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .minimum = 1,\n\t  .maximum = INT_MAX,\n\t  .default_num = 80\n\t},\n\n\t{ .name = \"mode-attr\",\n\t  .type = OPTIONS_TABLE_ATTRIBUTES,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_num = 0,\n\t  .style = \"mode-style\"\n\t},\n\n\t{ .name = \"mode-bg\",\n\t  .type = OPTIONS_TABLE_COLOUR,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_num = 3,\n\t  .style = \"mode-style\"\n\t},\n\n\t{ .name = \"mode-fg\",\n\t  .type = OPTIONS_TABLE_COLOUR,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_num = 0,\n\t  .style = \"mode-style\"\n\t},\n\n\t{ .name = \"mode-keys\",\n\t  .type = OPTIONS_TABLE_CHOICE,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .choices = options_table_mode_keys_list,\n\t  .default_num = MODEKEY_EMACS\n\t},\n\n\t{ .name = \"mode-style\",\n\t  .type = OPTIONS_TABLE_STYLE,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_str = \"bg=yellow,fg=black\"\n\t},\n\n\t{ .name = \"monitor-activity\",\n\t  .type = OPTIONS_TABLE_FLAG,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_num = 0\n\t},\n\n\t{ .name = \"monitor-silence\",\n\t  .type = OPTIONS_TABLE_NUMBER,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .minimum = 0,\n\t  .maximum = INT_MAX,\n\t  .default_num = 0\n\t},\n\n\t{ .name = \"other-pane-height\",\n\t  .type = OPTIONS_TABLE_NUMBER,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .minimum = 0,\n\t  .maximum = INT_MAX,\n\t  .default_num = 0\n\t},\n\n\t{ .name = \"other-pane-width\",\n\t  .type = OPTIONS_TABLE_NUMBER,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .minimum = 0,\n\t  .maximum = INT_MAX,\n\t  .default_num = 0\n\t},\n\n\t{ .name = \"pane-active-border-bg\",\n\t  .type = OPTIONS_TABLE_COLOUR,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_num = 8,\n\t  .style = \"pane-active-border-style\"\n\t},\n\n\t{ .name = \"pane-active-border-fg\",\n\t  .type = OPTIONS_TABLE_COLOUR,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_num = 2,\n\t  .style = \"pane-active-border-style\"\n\t},\n\n\t{ .name = \"pane-active-border-style\",\n\t  .type = OPTIONS_TABLE_STYLE,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_str = \"fg=green\"\n\t},\n\n\t{ .name = \"pane-base-index\",\n\t  .type = OPTIONS_TABLE_NUMBER,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .minimum = 0,\n\t  .maximum = USHRT_MAX,\n\t  .default_num = 0\n\t},\n\n\t{ .name = \"pane-border-bg\",\n\t  .type = OPTIONS_TABLE_COLOUR,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_num = 8,\n\t  .style = \"pane-border-style\"\n\t},\n\n\t{ .name = \"pane-border-fg\",\n\t  .type = OPTIONS_TABLE_COLOUR,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_num = 8,\n\t  .style = \"pane-border-style\"\n\t},\n\n\t{ .name = \"pane-border-style\",\n\t  .type = OPTIONS_TABLE_STYLE,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_str = \"default\"\n\t},\n\n\t{ .name = \"remain-on-exit\",\n\t  .type = OPTIONS_TABLE_FLAG,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_num = 0\n\t},\n\n\t{ .name = \"synchronize-panes\",\n\t  .type = OPTIONS_TABLE_FLAG,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_num = 0\n\t},\n\n\t{ .name = \"window-active-style\",\n\t  .type = OPTIONS_TABLE_STYLE,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_str = \"default\"\n\t},\n\n\t{ .name = \"window-style\",\n\t  .type = OPTIONS_TABLE_STYLE,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_str = \"default\"\n\t},\n\n\t{ .name = \"window-status-activity-attr\",\n\t  .type = OPTIONS_TABLE_ATTRIBUTES,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_num = GRID_ATTR_REVERSE,\n\t  .style = \"window-status-activity-style\"\n\t},\n\n\t{ .name = \"window-status-activity-bg\",\n\t  .type = OPTIONS_TABLE_COLOUR,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_num = 8,\n\t  .style = \"window-status-activity-style\"\n\t},\n\n\t{ .name = \"window-status-activity-fg\",\n\t  .type = OPTIONS_TABLE_COLOUR,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_num = 8,\n\t  .style = \"window-status-activity-style\"\n\t},\n\n\t{ .name = \"window-status-activity-style\",\n\t  .type = OPTIONS_TABLE_STYLE,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_str = \"reverse\"\n\t},\n\n\t{ .name = \"window-status-attr\",\n\t  .type = OPTIONS_TABLE_ATTRIBUTES,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_num = 0,\n\t  .style = \"window-status-style\"\n\t},\n\n\t{ .name = \"window-status-bell-attr\",\n\t  .type = OPTIONS_TABLE_ATTRIBUTES,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_num = GRID_ATTR_REVERSE,\n\t  .style = \"window-status-bell-style\"\n\t},\n\n\t{ .name = \"window-status-bell-bg\",\n\t  .type = OPTIONS_TABLE_COLOUR,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_num = 8,\n\t  .style = \"window-status-bell-style\"\n\t},\n\n\t{ .name = \"window-status-bell-fg\",\n\t  .type = OPTIONS_TABLE_COLOUR,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_num = 8,\n\t  .style = \"window-status-bell-style\"\n\t},\n\n\t{ .name = \"window-status-bell-style\",\n\t  .type = OPTIONS_TABLE_STYLE,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_str = \"reverse\"\n\t},\n\n\t{ .name = \"window-status-bg\",\n\t  .type = OPTIONS_TABLE_COLOUR,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_num = 8,\n\t  .style = \"window-status-style\"\n\t},\n\n\t{ .name = \"window-status-current-attr\",\n\t  .type = OPTIONS_TABLE_ATTRIBUTES,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_num = 0,\n\t  .style = \"window-status-current-style\"\n\t},\n\n\t{ .name = \"window-status-current-bg\",\n\t  .type = OPTIONS_TABLE_COLOUR,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_num = 8,\n\t  .style = \"window-status-current-style\"\n\t},\n\n\t{ .name = \"window-status-current-fg\",\n\t  .type = OPTIONS_TABLE_COLOUR,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_num = 8,\n\t  .style = \"window-status-current-style\"\n\t},\n\n\t{ .name = \"window-status-current-format\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_str = \"#I:#W#{?window_flags,#{window_flags}, }\"\n\t},\n\n\t{ .name = \"window-status-current-style\",\n\t  .type = OPTIONS_TABLE_STYLE,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_str = \"default\"\n\t},\n\n\t{ .name = \"window-status-fg\",\n\t  .type = OPTIONS_TABLE_COLOUR,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_num = 8,\n\t  .style = \"window-status-style\"\n\t},\n\n\t{ .name = \"window-status-format\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_str = \"#I:#W#{?window_flags,#{window_flags}, }\"\n\t},\n\n\t{ .name = \"window-status-last-attr\",\n\t  .type = OPTIONS_TABLE_ATTRIBUTES,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_num = 0,\n\t  .style = \"window-status-last-style\"\n\t},\n\n\t{ .name = \"window-status-last-bg\",\n\t  .type = OPTIONS_TABLE_COLOUR,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_num = 8,\n\t  .style = \"window-status-last-style\"\n\t},\n\n\t{ .name = \"window-status-last-fg\",\n\t  .type = OPTIONS_TABLE_COLOUR,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_num = 8,\n\t  .style = \"window-status-last-style\"\n\t},\n\n\t{ .name = \"window-status-last-style\",\n\t  .type = OPTIONS_TABLE_STYLE,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_str = \"default\"\n\t},\n\n\t{ .name = \"window-status-separator\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_str = \" \"\n\t},\n\n\t{ .name = \"window-status-style\",\n\t  .type = OPTIONS_TABLE_STYLE,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_str = \"default\"\n\t},\n\n\t{ .name = \"wrap-search\",\n\t  .type = OPTIONS_TABLE_FLAG,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_num = 1\n\t},\n\n\t{ .name = \"xterm-keys\",\n\t  .type = OPTIONS_TABLE_FLAG,\n\t  .scope = OPTIONS_TABLE_WINDOW,\n\t  .default_num = 0\n\t},\n\n#ifdef TMATE\n\t{ .name = \"tmate-identity\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_SERVER,\n\t  .default_str = \"\"\n\t},\n\n\t{ .name = \"tmate-server-host\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_SERVER,\n\t  .default_str = \"ssh.tmate.io\"\n\t},\n\n\t{ .name = \"tmate-server-port\",\n\t  .type = OPTIONS_TABLE_NUMBER,\n\t  .scope = OPTIONS_TABLE_SERVER,\n\t  .minimum = 1,\n\t  .maximum = 65535,\n\t  .default_num = 22\n\t},\n\n\t{ .name = \"tmate-server-dsa-fingerprint\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_SERVER,\n\t  .default_str = \"obsolete\"\n\t},\n\n\t{ .name = \"tmate-server-rsa-fingerprint\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_SERVER,\n\t  .default_str = \"SHA256:Hthk2T/M/Ivqfk1YYUn5ijC2Att3+UPzD7Rn72P5VWs\"\n\t},\n\n\t{ .name = \"tmate-server-ecdsa-fingerprint\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_SERVER,\n\t  .default_str = \"SHA256:8GmKHYHEJ6n0TEdciHeEGkKOigQfCFuBULdt6vZIhDc\"\n\t},\n\n\t{ .name = \"tmate-server-ed25519-fingerprint\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_SERVER,\n\t  .default_str = \"SHA256:jfttvoypkHiQYUqUCwKeqd9d1fJj/ZiQlFOHVl6E9sI\"\n\t},\n\n\t{ .name = \"tmate-display-time\",\n\t  .type = OPTIONS_TABLE_NUMBER,\n\t  .scope = OPTIONS_TABLE_SESSION,\n\t  .minimum = 1,\n\t  .maximum = INT_MAX,\n\t  .default_num = 15000\n\t},\n\n\t{ .name = \"tmate-webhook-userdata\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_SERVER,\n\t  .default_str = \"\"\n\t},\n\n\t{ .name = \"tmate-webhook-url\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_SERVER,\n\t  .default_str = \"\"\n\t},\n\n\t{ .name = \"tmate-api-key\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_SERVER,\n\t  .default_str = \"\"\n\t},\n\n\t{ .name = \"tmate-session-name\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_SERVER,\n\t  .default_str = \"\"\n\t},\n\n\t{ .name = \"tmate-session-name-ro\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_SERVER,\n\t  .default_str = \"\"\n\t},\n\n\t{ .name = \"tmate-authorized-keys\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_SERVER,\n\t  .default_str = \"\"\n\t},\n\n\t{ .name = \"tmate-set\",\n\t  .type = OPTIONS_TABLE_STRING,\n\t  .scope = OPTIONS_TABLE_SERVER,\n\t  .default_str = \"\"\n\t},\n\n\t{ .name = \"tmate-foreground-restart\",\n\t  .type = OPTIONS_TABLE_NUMBER,\n\t  .scope = OPTIONS_TABLE_SERVER,\n\t  .minimum = 0,\n\t  .maximum = 1,\n\t  .default_num = 1\n\t},\n#endif\n\n\t{ .name = NULL }\n};\n\n/* Populate an options tree from a table. */\nvoid\noptions_table_populate_tree(enum options_table_scope scope, struct options *oo)\n{\n\tconst struct options_table_entry\t*oe;\n\n\tfor (oe = options_table; oe->name != NULL; oe++) {\n\t\tif (oe->scope == OPTIONS_TABLE_NONE)\n\t\t\tfatalx(\"no scope for %s\", oe->name);\n\t\tif (oe->scope != scope)\n\t\t\tcontinue;\n\t\tswitch (oe->type) {\n\t\tcase OPTIONS_TABLE_STRING:\n\t\t\toptions_set_string(oo, oe->name, \"%s\", oe->default_str);\n\t\t\tbreak;\n\t\tcase OPTIONS_TABLE_STYLE:\n\t\t\toptions_set_style(oo, oe->name, oe->default_str, 0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\toptions_set_number(oo, oe->name, oe->default_num);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/* Print an option using its type from the table. */\nconst char *\noptions_table_print_entry(const struct options_table_entry *oe,\n    struct options_entry *o, int no_quotes)\n{\n\tstatic char\t out[BUFSIZ];\n\tconst char\t*s;\n\n\t*out = '\\0';\n\tswitch (oe->type) {\n\tcase OPTIONS_TABLE_STRING:\n\t\tif (no_quotes)\n\t\t\txsnprintf(out, sizeof out, \"%s\", o->str);\n\t\telse\n\t\t\txsnprintf(out, sizeof out, \"\\\"%s\\\"\", o->str);\n\t\tbreak;\n\tcase OPTIONS_TABLE_NUMBER:\n\t\txsnprintf(out, sizeof out, \"%lld\", o->num);\n\t\tbreak;\n\tcase OPTIONS_TABLE_KEY:\n\t\txsnprintf(out, sizeof out, \"%s\",\n\t\t    key_string_lookup_key(o->num));\n\t\tbreak;\n\tcase OPTIONS_TABLE_COLOUR:\n\t\ts = colour_tostring(o->num);\n\t\txsnprintf(out, sizeof out, \"%s\", s);\n\t\tbreak;\n\tcase OPTIONS_TABLE_ATTRIBUTES:\n\t\ts = attributes_tostring(o->num);\n\t\txsnprintf(out, sizeof out, \"%s\", s);\n\t\tbreak;\n\tcase OPTIONS_TABLE_FLAG:\n\t\tif (o->num)\n\t\t\tstrlcpy(out, \"on\", sizeof out);\n\t\telse\n\t\t\tstrlcpy(out, \"off\", sizeof out);\n\t\tbreak;\n\tcase OPTIONS_TABLE_CHOICE:\n\t\ts = oe->choices[o->num];\n\t\txsnprintf(out, sizeof out, \"%s\", s);\n\t\tbreak;\n\tcase OPTIONS_TABLE_STYLE:\n\t\ts = style_tostring(&o->style);\n\t\txsnprintf(out, sizeof out, \"%s\", s);\n\t\tbreak;\n\t}\n\treturn (out);\n}\n\n/* Find an option. */\nint\noptions_table_find(const char *optstr, const struct options_table_entry **oe)\n{\n\tconst struct options_table_entry\t*oe_loop;\n\n\tfor (oe_loop = options_table; oe_loop->name != NULL; oe_loop++) {\n\t\tif (strncmp(oe_loop->name, optstr, strlen(optstr)) != 0)\n\t\t\tcontinue;\n\n\t\t/* If already found, ambiguous. */\n\t\tif (*oe != NULL)\n\t\t\treturn (-1);\n\t\t*oe = oe_loop;\n\n\t\t/* Bail now if an exact match. */\n\t\tif (strcmp(oe_loop->name, optstr) == 0)\n\t\t\tbreak;\n\t}\n\treturn (0);\n}\n"
        },
        {
          "name": "options.c",
          "type": "blob",
          "size": 5.2021484375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2008 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdarg.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * Option handling; each option has a name, type and value and is stored in\n * a red-black tree.\n */\n\nstruct options {\n\tRB_HEAD(options_tree, options_entry) tree;\n\tstruct options\t*parent;\n};\n\nstatic int\toptions_cmp(struct options_entry *, struct options_entry *);\nRB_PROTOTYPE(options_tree, options_entry, entry, options_cmp);\nRB_GENERATE(options_tree, options_entry, entry, options_cmp);\n\nstatic void\toptions_free1(struct options *, struct options_entry *);\n\nstatic int\noptions_cmp(struct options_entry *o1, struct options_entry *o2)\n{\n\treturn (strcmp(o1->name, o2->name));\n}\n\nstruct options *\noptions_create(struct options *parent)\n{\n\tstruct options\t*oo;\n\n\too = xcalloc(1, sizeof *oo);\n\tRB_INIT(&oo->tree);\n\too->parent = parent;\n\treturn (oo);\n}\n\nstatic void\noptions_free1(struct options *oo, struct options_entry *o)\n{\n\tRB_REMOVE(options_tree, &oo->tree, o);\n\tfree((char *)o->name);\n\tif (o->type == OPTIONS_STRING)\n\t\tfree(o->str);\n\tfree(o);\n}\n\nvoid\noptions_free(struct options *oo)\n{\n\tstruct options_entry\t*o, *o1;\n\n\tRB_FOREACH_SAFE (o, options_tree, &oo->tree, o1)\n\t\toptions_free1(oo, o);\n\tfree(oo);\n}\n\nstruct options_entry *\noptions_first(struct options *oo)\n{\n\treturn (RB_MIN(options_tree, &oo->tree));\n}\n\nstruct options_entry *\noptions_next(struct options_entry *o)\n{\n\treturn (RB_NEXT(options_tree, &oo->tree, o));\n}\n\nstruct options_entry *\noptions_find1(struct options *oo, const char *name)\n{\n\tstruct options_entry\tp;\n\n\tp.name = (char *)name;\n\treturn (RB_FIND(options_tree, &oo->tree, &p));\n}\n\nstruct options_entry *\noptions_find(struct options *oo, const char *name)\n{\n\tstruct options_entry\t*o, p;\n\n\tp.name = (char *)name;\n\to = RB_FIND(options_tree, &oo->tree, &p);\n\twhile (o == NULL) {\n\t\too = oo->parent;\n\t\tif (oo == NULL)\n\t\t\tbreak;\n\t\to = RB_FIND(options_tree, &oo->tree, &p);\n\t}\n\treturn (o);\n}\n\nvoid\noptions_remove(struct options *oo, const char *name)\n{\n\tstruct options_entry\t*o;\n\n\tif ((o = options_find1(oo, name)) != NULL)\n\t\toptions_free1(oo, o);\n}\n\nstruct options_entry *\noptions_set_string(struct options *oo, const char *name, const char *fmt, ...)\n{\n\tstruct options_entry\t*o;\n\tva_list\t\t\t ap;\n\n\tif ((o = options_find1(oo, name)) == NULL) {\n\t\to = xmalloc(sizeof *o);\n\t\to->name = xstrdup(name);\n\t\tRB_INSERT(options_tree, &oo->tree, o);\n\t\tmemcpy(&o->style, &grid_default_cell, sizeof o->style);\n\t} else if (o->type == OPTIONS_STRING)\n\t\tfree(o->str);\n\n\tva_start(ap, fmt);\n\to->type = OPTIONS_STRING;\n\txvasprintf(&o->str, fmt, ap);\n\tva_end(ap);\n\treturn (o);\n}\n\nchar *\noptions_get_string(struct options *oo, const char *name)\n{\n\tstruct options_entry\t*o;\n\n\tif ((o = options_find(oo, name)) == NULL)\n\t\tfatalx(\"missing option %s\", name);\n\tif (o->type != OPTIONS_STRING)\n\t\tfatalx(\"option %s not a string\", name);\n\treturn (o->str);\n}\n\nstruct options_entry *\noptions_set_number(struct options *oo, const char *name, long long value)\n{\n\tstruct options_entry\t*o;\n\n\tif ((o = options_find1(oo, name)) == NULL) {\n\t\to = xmalloc(sizeof *o);\n\t\to->name = xstrdup(name);\n\t\tRB_INSERT(options_tree, &oo->tree, o);\n\t\tmemcpy(&o->style, &grid_default_cell, sizeof o->style);\n\t} else if (o->type == OPTIONS_STRING)\n\t\tfree(o->str);\n\n\to->type = OPTIONS_NUMBER;\n\to->num = value;\n\treturn (o);\n}\n\nlong long\noptions_get_number(struct options *oo, const char *name)\n{\n\tstruct options_entry\t*o;\n\n\tif ((o = options_find(oo, name)) == NULL)\n\t\tfatalx(\"missing option %s\", name);\n\tif (o->type != OPTIONS_NUMBER)\n\t\tfatalx(\"option %s not a number\", name);\n\treturn (o->num);\n}\n\nstruct options_entry *\noptions_set_style(struct options *oo, const char *name, const char *value,\n    int append)\n{\n\tstruct options_entry\t*o;\n\tstruct grid_cell\t tmpgc;\n\n\to = options_find1(oo, name);\n\tif (o == NULL || !append)\n\t\tmemcpy(&tmpgc, &grid_default_cell, sizeof tmpgc);\n\telse\n\t\tmemcpy(&tmpgc, &o->style, sizeof tmpgc);\n\n\tif (style_parse(&grid_default_cell, &tmpgc, value) == -1)\n\t\treturn (NULL);\n\n\tif (o == NULL) {\n\t\to = xmalloc(sizeof *o);\n\t\to->name = xstrdup(name);\n\t\tRB_INSERT(options_tree, &oo->tree, o);\n\t} else if (o->type == OPTIONS_STRING)\n\t\tfree(o->str);\n\n\to->type = OPTIONS_STYLE;\n\tmemcpy(&o->style, &tmpgc, sizeof o->style);\n\treturn (o);\n}\n\nstruct grid_cell *\noptions_get_style(struct options *oo, const char *name)\n{\n\tstruct options_entry\t*o;\n\n\tif ((o = options_find(oo, name)) == NULL)\n\t\tfatalx(\"missing option %s\", name);\n\tif (o->type != OPTIONS_STYLE)\n\t\tfatalx(\"option %s not a style\", name);\n\treturn (&o->style);\n}\n"
        },
        {
          "name": "osdep-aix.c",
          "type": "blob",
          "size": 2.2197265625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2011 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/param.h>\n#include <sys/procfs.h>\n\n#include <stdlib.h>\n#include <string.h>\n#include <fcntl.h>\n\n#include \"tmux.h\"\n\nchar *\nosdep_get_name(__unused int fd, char *tty)\n{\n\tstruct psinfo\t p;\n\tchar\t\t*path;\n\tssize_t\t\t bytes;\n\tint\t\t f, ttyfd, retval;\n\tpid_t\t\t pgrp;\n\n\tif ((ttyfd = open(tty, O_RDONLY|O_NOCTTY)) == -1)\n\t\treturn (NULL);\n\n\tretval = ioctl(ttyfd, TIOCGPGRP, &pgrp);\n\tclose(ttyfd);\n\tif (retval == -1)\n\t\treturn (NULL);\n\n\txasprintf(&path, \"/proc/%u/psinfo\", (u_int) pgrp);\n\tf = open(path, O_RDONLY);\n\tfree(path);\n\tif (f < 0)\n\t\treturn (NULL);\n\n\tbytes = read(f, &p, sizeof(p));\n\tclose(f);\n\tif (bytes != sizeof(p))\n\t\treturn (NULL);\n\n\treturn (xstrdup(p.pr_fname));\n}\n\nchar *\nosdep_get_cwd(int fd)\n{\n\tstatic char      target[MAXPATHLEN + 1];\n\tchar            *path;\n\tconst char      *ttypath;\n\tssize_t          n;\n\tpid_t            pgrp;\n\tint              len, retval, ttyfd;\n\n\tif ((ttypath = ptsname(fd)) == NULL)\n\t\treturn (NULL);\n\tif ((ttyfd = open(ttypath, O_RDONLY|O_NOCTTY)) == -1)\n\t\treturn (NULL);\n\n\tretval = ioctl(ttyfd, TIOCGPGRP, &pgrp);\n\tclose(ttyfd);\n\tif (retval == -1)\n\t\treturn (NULL);\n\n\txasprintf(&path, \"/proc/%u/cwd\", (u_int) pgrp);\n\tn = readlink(path, target, MAXPATHLEN);\n\tfree(path);\n\tif (n > 0) {\n\t\ttarget[n] = '\\0';\n\t\tif ((len = strlen(target)) > 1 && target[len - 1] == '/')\n\t\t\ttarget[len - 1] = '\\0';\n\t\treturn (target);\n\t}\n\treturn (NULL);\n}\n\nstruct event_base *\nosdep_event_init(void)\n{\n\treturn (event_init());\n}\n"
        },
        {
          "name": "osdep-cygwin.c",
          "type": "blob",
          "size": 1.8759765625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/param.h>\n#include <sys/stat.h>\n\n#include <event.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\nchar *\nosdep_get_name(int fd, __unused char *tty)\n{\n\tFILE\t*f;\n\tchar\t*path, *buf;\n\tsize_t\t len;\n\tint\t ch;\n\tpid_t\t pgrp;\n\n\tif ((pgrp = tcgetpgrp(fd)) == -1)\n\t\treturn (NULL);\n\n\txasprintf(&path, \"/proc/%lld/cmdline\", (long long) pgrp);\n\tif ((f = fopen(path, \"r\")) == NULL) {\n\t\tfree(path);\n\t\treturn (NULL);\n\t}\n\tfree(path);\n\n\tlen = 0;\n\tbuf = NULL;\n\twhile ((ch = fgetc(f)) != EOF) {\n\t\tif (ch == '\\0')\n\t\t\tbreak;\n\t\tbuf = xrealloc(buf, len + 2);\n\t\tbuf[len++] = ch;\n\t}\n\tif (buf != NULL)\n\t\tbuf[len] = '\\0';\n\n\tfclose(f);\n\treturn (buf);\n}\n\nchar *\nosdep_get_cwd(int fd)\n{\n\tstatic char\t target[MAXPATHLEN + 1];\n\tchar\t\t*path;\n\tpid_t\t\t pgrp;\n\tssize_t\t\t n;\n\n\tif ((pgrp = tcgetpgrp(fd)) == -1)\n\t\treturn (NULL);\n\n\txasprintf(&path, \"/proc/%lld/cwd\", (long long) pgrp);\n\tn = readlink(path, target, MAXPATHLEN);\n\tfree(path);\n\tif (n > 0) {\n\t\ttarget[n] = '\\0';\n\t\treturn (target);\n\t}\n\treturn (NULL);\n}\n\nstruct event_base *\nosdep_event_init(void)\n{\n\treturn (event_init());\n}\n"
        },
        {
          "name": "osdep-darwin.c",
          "type": "blob",
          "size": 2.099609375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Joshua Elsasser <josh@elsasser.org>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <event.h>\n#include <libproc.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\nchar\t\t\t*osdep_get_name(int, char *);\nchar\t\t\t*osdep_get_cwd(int);\nstruct event_base\t*osdep_event_init(void);\n\n#ifndef __unused\n#define __unused __attribute__ ((__unused__))\n#endif\n\nchar *\nosdep_get_name(int fd, __unused char *tty)\n{\n\tstruct proc_bsdinfo\t\tbsdinfo;\n\tpid_t\t\t\t\tpgrp;\n\tint\t\t\t\tret;\n\n\tif ((pgrp = tcgetpgrp(fd)) == -1)\n\t\treturn (NULL);\n\n\tret = proc_pidinfo(pgrp, PROC_PIDTBSDINFO, 0,\n\t    &bsdinfo, sizeof bsdinfo);\n\tif (ret == sizeof bsdinfo && *bsdinfo.pbi_comm != '\\0')\n\t\treturn (strdup(bsdinfo.pbi_comm));\n\treturn (NULL);\n}\n\nchar *\nosdep_get_cwd(int fd)\n{\n\tstatic char\t\t\twd[PATH_MAX];\n\tstruct proc_vnodepathinfo\tpathinfo;\n\tpid_t\t\t\t\tpgrp;\n\tint\t\t\t\tret;\n\n\tif ((pgrp = tcgetpgrp(fd)) == -1)\n\t\treturn (NULL);\n\n\tret = proc_pidinfo(pgrp, PROC_PIDVNODEPATHINFO, 0,\n\t    &pathinfo, sizeof pathinfo);\n\tif (ret == sizeof pathinfo) {\n\t\tstrlcpy(wd, pathinfo.pvi_cdir.vip_path, sizeof wd);\n\t\treturn (wd);\n\t}\n\treturn (NULL);\n}\n\nstruct event_base *\nosdep_event_init(void)\n{\n\t/*\n\t * On OS X, kqueue and poll are both completely broken and don't\n\t * work on anything except socket file descriptors (yes, really).\n\t */\n\tsetenv(\"EVENT_NOKQUEUE\", \"1\", 1);\n\tsetenv(\"EVENT_NOPOLL\", \"1\", 1);\n\treturn (event_init());\n}\n"
        },
        {
          "name": "osdep-dragonfly.c",
          "type": "blob",
          "size": 2.9560546875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/sysctl.h>\n#include <sys/user.h>\n\n#include <err.h>\n#include <errno.h>\n#include <event.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\nstruct kinfo_proc\t*cmp_procs(struct kinfo_proc *, struct kinfo_proc *);\nchar\t\t\t*osdep_get_name(int, char *);\nchar\t\t\t*osdep_get_cwd(int);\nstruct event_base\t*osdep_event_init(void);\n\n#ifndef nitems\n#define nitems(_a) (sizeof((_a)) / sizeof((_a)[0]))\n#endif\n\n#define is_runnable(p) \\\n\t((p)->kp_stat == SACTIVE || (p)->kp_stat == SIDL)\n#define is_stopped(p) \\\n\t((p)->kp_stat == SSTOP || (p)->kp_stat == SZOMB)\n\nstruct kinfo_proc *\ncmp_procs(struct kinfo_proc *p1, struct kinfo_proc *p2)\n{\n\tif (is_runnable(p1) && !is_runnable(p2))\n\t\treturn (p1);\n\tif (!is_runnable(p1) && is_runnable(p2))\n\t\treturn (p2);\n\n\tif (is_stopped(p1) && !is_stopped(p2))\n\t\treturn (p1);\n\tif (!is_stopped(p1) && is_stopped(p2))\n\t\treturn (p2);\n\n\tif (strcmp(p1->kp_comm, p2->kp_comm) < 0)\n\t\treturn (p1);\n\tif (strcmp(p1->kp_comm, p2->kp_comm) > 0)\n\t\treturn (p2);\n\n\tif (p1->kp_pid > p2->kp_pid)\n\t\treturn (p1);\n\treturn (p2);\n}\n\nchar *\nosdep_get_name(int fd, char *tty)\n{\n\tint\t\t mib[4] = { CTL_KERN, KERN_PROC, KERN_PROC_PGRP, 0 };\n\tstruct stat\t sb;\n\tsize_t\t\t len;\n\tstruct kinfo_proc *buf, *newbuf, *bestp;\n\tu_int\t\t i;\n\tchar\t\t*name;\n\n\tbuf = NULL;\n\n\tif (stat(tty, &sb) == -1)\n\t\treturn (NULL);\n\tif ((mib[3] = tcgetpgrp(fd)) == -1)\n\t\treturn (NULL);\n\nretry:\n\tif (sysctl(mib, nitems(mib), NULL, &len, NULL, 0) == -1)\n\t\treturn (NULL);\n\tlen = (len * 5) / 4;\n\n\tif ((newbuf = realloc(buf, len)) == NULL)\n\t\tgoto error;\n\tbuf = newbuf;\n\n\tif (sysctl(mib, nitems(mib), buf, &len, NULL, 0) == -1) {\n\t\tif (errno == ENOMEM)\n\t\t\tgoto retry;\n\t\tgoto error;\n\t}\n\n\tbestp = NULL;\n\tfor (i = 0; i < len / sizeof (struct kinfo_proc); i++) {\n\t\tif (buf[i].kp_tdev != sb.st_rdev)\n\t\t\tcontinue;\n\t\tif (bestp == NULL)\n\t\t\tbestp = &buf[i];\n\t\telse\n\t\t\tbestp = cmp_procs(&buf[i], bestp);\n\t}\n\n\tname = NULL;\n\tif (bestp != NULL)\n\t\tname = strdup(bestp->kp_comm);\n\n\tfree(buf);\n\treturn (name);\n\nerror:\n\tfree(buf);\n\treturn (NULL);\n}\n\nchar *\nosdep_get_cwd(int fd)\n{\n\treturn (NULL);\n}\n\nstruct event_base *\nosdep_event_init(void)\n{\n\treturn (event_init());\n}\n"
        },
        {
          "name": "osdep-freebsd.c",
          "type": "blob",
          "size": 4.375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/param.h>\n#include <sys/proc.h>\n#include <sys/stat.h>\n#include <sys/sysctl.h>\n#include <sys/user.h>\n\n#include <err.h>\n#include <errno.h>\n#include <event.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <libutil.h>\n\nstruct kinfo_proc\t*cmp_procs(struct kinfo_proc *, struct kinfo_proc *);\nchar\t\t\t*osdep_get_name(int, char *);\nchar\t\t\t*osdep_get_cwd(int);\nstruct event_base\t*osdep_event_init(void);\n\n#ifndef nitems\n#define nitems(_a) (sizeof((_a)) / sizeof((_a)[0]))\n#endif\n\n#define is_runnable(p) \\\n\t((p)->ki_stat == SRUN || (p)->ki_stat == SIDL)\n#define is_stopped(p) \\\n\t((p)->ki_stat == SSTOP || (p)->ki_stat == SZOMB)\n\nstruct kinfo_proc *\ncmp_procs(struct kinfo_proc *p1, struct kinfo_proc *p2)\n{\n\tif (is_runnable(p1) && !is_runnable(p2))\n\t\treturn (p1);\n\tif (!is_runnable(p1) && is_runnable(p2))\n\t\treturn (p2);\n\n\tif (is_stopped(p1) && !is_stopped(p2))\n\t\treturn (p1);\n\tif (!is_stopped(p1) && is_stopped(p2))\n\t\treturn (p2);\n\n\tif (p1->ki_estcpu > p2->ki_estcpu)\n\t\treturn (p1);\n\tif (p1->ki_estcpu < p2->ki_estcpu)\n\t\treturn (p2);\n\n\tif (p1->ki_slptime < p2->ki_slptime)\n\t\treturn (p1);\n\tif (p1->ki_slptime > p2->ki_slptime)\n\t\treturn (p2);\n\n\tif (strcmp(p1->ki_comm, p2->ki_comm) < 0)\n\t\treturn (p1);\n\tif (strcmp(p1->ki_comm, p2->ki_comm) > 0)\n\t\treturn (p2);\n\n\tif (p1->ki_pid > p2->ki_pid)\n\t\treturn (p1);\n\treturn (p2);\n}\n\nchar *\nosdep_get_name(int fd, char *tty)\n{\n\tint\t\t mib[4] = { CTL_KERN, KERN_PROC, KERN_PROC_PGRP, 0 };\n\tstruct stat\t sb;\n\tsize_t\t\t len;\n\tstruct kinfo_proc *buf, *newbuf, *bestp;\n\tu_int\t\t i;\n\tchar\t\t*name;\n\n\tbuf = NULL;\n\n\tif (stat(tty, &sb) == -1)\n\t\treturn (NULL);\n\tif ((mib[3] = tcgetpgrp(fd)) == -1)\n\t\treturn (NULL);\n\nretry:\n\tif (sysctl(mib, nitems(mib), NULL, &len, NULL, 0) == -1)\n\t\treturn (NULL);\n\tlen = (len * 5) / 4;\n\n\tif ((newbuf = realloc(buf, len)) == NULL)\n\t\tgoto error;\n\tbuf = newbuf;\n\n\tif (sysctl(mib, nitems(mib), buf, &len, NULL, 0) == -1) {\n\t\tif (errno == ENOMEM)\n\t\t\tgoto retry;\n\t\tgoto error;\n\t}\n\n\tbestp = NULL;\n\tfor (i = 0; i < len / sizeof (struct kinfo_proc); i++) {\n\t\tif (buf[i].ki_tdev != sb.st_rdev)\n\t\t\tcontinue;\n\t\tif (bestp == NULL)\n\t\t\tbestp = &buf[i];\n\t\telse\n\t\t\tbestp = cmp_procs(&buf[i], bestp);\n\t}\n\n\tname = NULL;\n\tif (bestp != NULL)\n\t\tname = strdup(bestp->ki_comm);\n\n\tfree(buf);\n\treturn (name);\n\nerror:\n\tfree(buf);\n\treturn (NULL);\n}\n\nstatic char *\nosdep_get_cwd_fallback(int fd)\n{\n\tstatic char\t\t wd[PATH_MAX];\n\tstruct kinfo_file\t*info = NULL;\n\tpid_t\t\t\t pgrp;\n\tint\t\t\t nrecords, i;\n\n\tif ((pgrp = tcgetpgrp(fd)) == -1)\n\t\treturn (NULL);\n\n\tif ((info = kinfo_getfile(pgrp, &nrecords)) == NULL)\n\t\treturn (NULL);\n\n\tfor (i = 0; i < nrecords; i++) {\n\t\tif (info[i].kf_fd == KF_FD_TYPE_CWD) {\n\t\t\tstrlcpy(wd, info[i].kf_path, sizeof wd);\n\t\t\tfree(info);\n\t\t\treturn (wd);\n\t\t}\n\t}\n\n\tfree(info);\n\treturn (NULL);\n}\n\n#ifdef KERN_PROC_CWD\nchar *\nosdep_get_cwd(int fd)\n{\n\tstatic struct kinfo_file\tinfo;\n\tstatic int\t\t\tfallback;\n\tint\tname[] = { CTL_KERN, KERN_PROC, KERN_PROC_CWD, 0 };\n\tsize_t\tlen = sizeof info;\n\n\tif (fallback)\n\t\treturn (osdep_get_cwd_fallback(fd));\n\n\tif ((name[3] = tcgetpgrp(fd)) == -1)\n\t\treturn (NULL);\n\n\tif (sysctl(name, 4, &info, &len, NULL, 0) == -1) {\n\t\tif (errno == ENOENT) {\n\t\t\tfallback = 1;\n\t\t\treturn (osdep_get_cwd_fallback(fd));\n\t\t}\n\t\treturn (NULL);\n\t}\n\treturn (info.kf_path);\n}\n#else /* !KERN_PROC_CWD */\nchar *\nosdep_get_cwd(int fd)\n{\n\treturn (osdep_get_cwd_fallback(fd));\n}\n#endif /* KERN_PROC_CWD */\n\nstruct event_base *\nosdep_event_init(void)\n{\n\t/*\n\t * On some versions of FreeBSD, kqueue doesn't work properly on tty\n\t * file descriptors. This is fixed in recent FreeBSD versions.\n\t */\n\tsetenv(\"EVENT_NOKQUEUE\", \"1\", 1);\n\treturn (event_init());\n}\n"
        },
        {
          "name": "osdep-hpux.c",
          "type": "blob",
          "size": 1.0771484375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <event.h>\n\n#include \"tmux.h\"\n\nchar *\nosdep_get_name(__unused int fd, __unused char *tty)\n{\n\treturn (NULL);\n}\n\nchar *\nosdep_get_cwd(__unused int fd)\n{\n\treturn (NULL);\n}\n\nstruct event_base *\nosdep_event_init(void)\n{\n\treturn (event_init());\n}\n"
        },
        {
          "name": "osdep-linux.c",
          "type": "blob",
          "size": 2.162109375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n\n#include <event.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\nchar *\nosdep_get_name(int fd, __unused char *tty)\n{\n\tFILE\t*f;\n\tchar\t*path, *buf;\n\tsize_t\t len;\n\tint\t ch;\n\tpid_t\t pgrp;\n\n\tif ((pgrp = tcgetpgrp(fd)) == -1)\n\t\treturn (NULL);\n\n\txasprintf(&path, \"/proc/%lld/cmdline\", (long long) pgrp);\n\tif ((f = fopen(path, \"r\")) == NULL) {\n\t\tfree(path);\n\t\treturn (NULL);\n\t}\n\tfree(path);\n\n\tlen = 0;\n\tbuf = NULL;\n\twhile ((ch = fgetc(f)) != EOF) {\n\t\tif (ch == '\\0')\n\t\t\tbreak;\n\t\tbuf = xrealloc(buf, len + 2);\n\t\tbuf[len++] = ch;\n\t}\n\tif (buf != NULL)\n\t\tbuf[len] = '\\0';\n\n\tfclose(f);\n\treturn (buf);\n}\n\nchar *\nosdep_get_cwd(int fd)\n{\n\tstatic char\t target[MAXPATHLEN + 1];\n\tchar\t\t*path;\n\tpid_t\t\t pgrp, sid;\n\tssize_t\t\t n;\n\n\tif ((pgrp = tcgetpgrp(fd)) == -1)\n\t\treturn (NULL);\n\n\txasprintf(&path, \"/proc/%lld/cwd\", (long long) pgrp);\n\tn = readlink(path, target, MAXPATHLEN);\n\tfree(path);\n\n\tif (n == -1 && ioctl(fd, TIOCGSID, &sid) != -1) {\n\t\txasprintf(&path, \"/proc/%lld/cwd\", (long long) sid);\n\t\tn = readlink(path, target, MAXPATHLEN);\n\t\tfree(path);\n\t}\n\n\tif (n > 0) {\n\t\ttarget[n] = '\\0';\n\t\treturn (target);\n\t}\n\treturn (NULL);\n}\n\nstruct event_base *\nosdep_event_init(void)\n{\n\t/* On Linux, epoll doesn't work on /dev/null (yes, really). */\n\tsetenv(\"EVENT_NOEPOLL\", \"1\", 1);\n\treturn (event_init());\n}\n"
        },
        {
          "name": "osdep-netbsd.c",
          "type": "blob",
          "size": 3.0732421875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/param.h>\n#include <sys/proc.h>\n#include <sys/stat.h>\n#include <sys/sysctl.h>\n\n#include <errno.h>\n#include <event.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#define is_runnable(p) \\\n        ((p)->p_stat == LSRUN || (p)->p_stat == SIDL)\n#define is_stopped(p) \\\n        ((p)->p_stat == SSTOP || (p)->p_stat == SZOMB)\n\nstruct kinfo_proc2\t*cmp_procs(struct kinfo_proc2 *, struct kinfo_proc2 *);\nchar\t\t\t*osdep_get_name(int, char *);\nchar\t\t\t*osdep_get_cwd(int);\nstruct event_base\t*osdep_event_init(void);\n\nstruct kinfo_proc2 *\ncmp_procs(struct kinfo_proc2 *p1, struct kinfo_proc2 *p2)\n{\n\tif (is_runnable(p1) && !is_runnable(p2))\n\t\treturn (p1);\n\tif (!is_runnable(p1) && is_runnable(p2))\n\t\treturn (p2);\n\n\tif (is_stopped(p1) && !is_stopped(p2))\n\t\treturn (p1);\n\tif (!is_stopped(p1) && is_stopped(p2))\n\t\treturn (p2);\n\n\tif (p1->p_estcpu > p2->p_estcpu)\n\t\treturn (p1);\n\tif (p1->p_estcpu < p2->p_estcpu)\n\t\treturn (p2);\n\n\tif (p1->p_slptime < p2->p_slptime)\n\t\treturn (p1);\n\tif (p1->p_slptime > p2->p_slptime)\n\t\treturn (p2);\n\n\tif (p1->p_pid > p2->p_pid)\n\t\treturn (p1);\n\treturn (p2);\n}\n\nchar *\nosdep_get_name(int fd, __unused char *tty)\n{\n\tint\t\t mib[6];\n\tstruct stat\t sb;\n\tsize_t\t\t len, i;\n\tstruct kinfo_proc2 *buf, *newbuf, *bestp;\n\tchar\t\t*name;\n\n\tif (stat(tty, &sb) == -1)\n\t\treturn (NULL);\n\tif ((mib[3] = tcgetpgrp(fd)) == -1)\n\t\treturn (NULL);\n\n\tbuf = NULL;\n\tlen = sizeof(bestp);\n\tmib[0] = CTL_KERN;\n\tmib[1] = KERN_PROC2;\n\tmib[2] = KERN_PROC_PGRP;\n\tmib[4] = sizeof (*buf);\n\tmib[5] = 0;\n\nretry:\n\tif (sysctl(mib, __arraycount(mib), NULL, &len, NULL, 0) == -1)\n\t\treturn (NULL);\n\n\tif ((newbuf = realloc(buf, len * sizeof (*buf))) == NULL)\n\t\tgoto error;\n\tbuf = newbuf;\n\n\tmib[5] = len / sizeof(*buf);\n\tif (sysctl(mib, __arraycount(mib), buf, &len, NULL, 0) == -1) {\n\t\tif (errno == ENOMEM)\n\t\t\tgoto retry; /* possible infinite loop? */\n\t\tgoto error;\n\t}\n\n\tbestp = NULL;\n\tfor (i = 0; i < len / sizeof (*buf); i++) {\n\t\tif (buf[i].p_tdev != sb.st_rdev)\n\t\t\tcontinue;\n\t\tif (bestp == NULL)\n\t\t\tbestp = &buf[i];\n\t\telse\n\t\t\tbestp = cmp_procs(&buf[i], bestp);\n\t}\n\n\tname = NULL;\n\tif (bestp != NULL)\n\t\tname = strdup(bestp->p_comm);\n\n\tfree(buf);\n\treturn (name);\n\nerror:\n\tfree(buf);\n\treturn (NULL);\n}\n\nchar *\nosdep_get_cwd(int fd)\n{\n\treturn (NULL);\n}\n\nstruct event_base *\nosdep_event_init(void)\n{\n\treturn (event_init());\n}\n"
        },
        {
          "name": "osdep-openbsd.c",
          "type": "blob",
          "size": 3.625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/param.h>\t/* MAXCOMLEN */\n#include <sys/types.h>\n#include <sys/proc.h>\n#include <sys/sysctl.h>\n#include <sys/stat.h>\n\n#include <errno.h>\n#include <event.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#ifndef nitems\n#define nitems(_a) (sizeof((_a)) / sizeof((_a)[0]))\n#endif\n\n#define is_runnable(p) \\\n\t((p)->p_stat == SRUN || (p)->p_stat == SIDL || (p)->p_stat == SONPROC)\n#define is_stopped(p) \\\n\t((p)->p_stat == SSTOP || (p)->p_stat == SDEAD)\n\nstruct kinfo_proc\t*cmp_procs(struct kinfo_proc *, struct kinfo_proc *);\nchar\t\t\t*osdep_get_name(int, char *);\nchar\t\t\t*osdep_get_cwd(int);\nstruct event_base\t*osdep_event_init(void);\n\nstruct kinfo_proc *\ncmp_procs(struct kinfo_proc *p1, struct kinfo_proc *p2)\n{\n\tif (is_runnable(p1) && !is_runnable(p2))\n\t\treturn (p1);\n\tif (!is_runnable(p1) && is_runnable(p2))\n\t\treturn (p2);\n\n\tif (is_stopped(p1) && !is_stopped(p2))\n\t\treturn (p1);\n\tif (!is_stopped(p1) && is_stopped(p2))\n\t\treturn (p2);\n\n\tif (p1->p_estcpu > p2->p_estcpu)\n\t\treturn (p1);\n\tif (p1->p_estcpu < p2->p_estcpu)\n\t\treturn (p2);\n\n\tif (p1->p_slptime < p2->p_slptime)\n\t\treturn (p1);\n\tif (p1->p_slptime > p2->p_slptime)\n\t\treturn (p2);\n\n\tif ((p1->p_flag & P_SINTR) && !(p2->p_flag & P_SINTR))\n\t\treturn (p1);\n\tif (!(p1->p_flag & P_SINTR) && (p2->p_flag & P_SINTR))\n\t\treturn (p2);\n\n\tif (strcmp(p1->p_comm, p2->p_comm) < 0)\n\t\treturn (p1);\n\tif (strcmp(p1->p_comm, p2->p_comm) > 0)\n\t\treturn (p2);\n\n\tif (p1->p_pid > p2->p_pid)\n\t\treturn (p1);\n\treturn (p2);\n}\n\nchar *\nosdep_get_name(int fd, char *tty)\n{\n\tint\t\t mib[6] = { CTL_KERN, KERN_PROC, KERN_PROC_PGRP, 0,\n\t\t\t\t    sizeof(struct kinfo_proc), 0 };\n\tstruct stat\t sb;\n\tsize_t\t\t len;\n\tstruct kinfo_proc *buf, *newbuf, *bestp;\n\tu_int\t\t i;\n\tchar\t\t*name;\n\n\tbuf = NULL;\n\n\tif (stat(tty, &sb) == -1)\n\t\treturn (NULL);\n\tif ((mib[3] = tcgetpgrp(fd)) == -1)\n\t\treturn (NULL);\n\nretry:\n\tif (sysctl(mib, nitems(mib), NULL, &len, NULL, 0) == -1)\n\t\tgoto error;\n\tlen = (len * 5) / 4;\n\n\tif ((newbuf = realloc(buf, len)) == NULL)\n\t\tgoto error;\n\tbuf = newbuf;\n\n\tmib[5] = (int)(len / sizeof(struct kinfo_proc));\n\tif (sysctl(mib, nitems(mib), buf, &len, NULL, 0) == -1) {\n\t\tif (errno == ENOMEM)\n\t\t\tgoto retry;\n\t\tgoto error;\n\t}\n\n\tbestp = NULL;\n\tfor (i = 0; i < len / sizeof (struct kinfo_proc); i++) {\n\t\tif ((dev_t)buf[i].p_tdev != sb.st_rdev)\n\t\t\tcontinue;\n\t\tif (bestp == NULL)\n\t\t\tbestp = &buf[i];\n\t\telse\n\t\t\tbestp = cmp_procs(&buf[i], bestp);\n\t}\n\n\tname = NULL;\n\tif (bestp != NULL)\n\t\tname = strdup(bestp->p_comm);\n\n\tfree(buf);\n\treturn (name);\n\nerror:\n\tfree(buf);\n\treturn (NULL);\n}\n\nchar *\nosdep_get_cwd(int fd)\n{\n\tint\t\tname[] = { CTL_KERN, KERN_PROC_CWD, 0 };\n\tstatic char\tpath[MAXPATHLEN];\n\tsize_t\t\tpathlen = sizeof path;\n\n\tif ((name[2] = tcgetpgrp(fd)) == -1)\n\t\treturn (NULL);\n\tif (sysctl(name, 3, path, &pathlen, NULL, 0) != 0)\n\t\treturn (NULL);\n\treturn (path);\n}\n\nstruct event_base *\nosdep_event_init(void)\n{\n\treturn (event_init());\n}\n"
        },
        {
          "name": "osdep-sunos.c",
          "type": "blob",
          "size": 2.1689453125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Todd Carson <toc@daybefore.net>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/stat.h>\n\n#include <event.h>\n#include <fcntl.h>\n#include <procfs.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\nchar *\nosdep_get_name(int fd, char *tty)\n{\n\tstruct psinfo\t p;\n\tstruct stat\t st;\n\tchar\t\t*path;\n\tssize_t\t\t bytes;\n\tint\t\t f;\n\tpid_t\t\t pgrp;\n\n\tif ((f = open(tty, O_RDONLY)) < 0)\n\t\treturn (NULL);\n\n\tif (fstat(f, &st) != 0 || ioctl(f, TIOCGPGRP, &pgrp) != 0) {\n\t\tclose(f);\n\t\treturn (NULL);\n\t}\n\tclose(f);\n\n\txasprintf(&path, \"/proc/%u/psinfo\", (u_int) pgrp);\n\tf = open(path, O_RDONLY);\n\tfree(path);\n\tif (f < 0)\n\t\treturn (NULL);\n\n\tbytes = read(f, &p, sizeof(p));\n\tclose(f);\n\tif (bytes != sizeof(p))\n\t\treturn (NULL);\n\n\tif (p.pr_ttydev != st.st_rdev)\n\t\treturn (NULL);\n\n\treturn (xstrdup(p.pr_fname));\n}\n\nchar *\nosdep_get_cwd(int fd)\n{\n\tstatic char\t target[MAXPATHLEN + 1];\n\tchar\t\t*path;\n\tconst char\t*ttypath;\n\tssize_t\t\t n;\n\tpid_t\t\t pgrp;\n\tint\t\t retval, ttyfd;\n\n\tif ((ttypath = ptsname(fd)) == NULL)\n\t\treturn (NULL);\n\tif ((ttyfd = open(ttypath, O_RDONLY|O_NOCTTY)) == -1)\n\t\treturn (NULL);\n\n\tretval = ioctl(ttyfd, TIOCGPGRP, &pgrp);\n\tclose(ttyfd);\n\tif (retval == -1)\n\t\treturn (NULL);\n\n\txasprintf(&path, \"/proc/%u/path/cwd\", (u_int) pgrp);\n\tn = readlink(path, target, MAXPATHLEN);\n\tfree(path);\n\tif (n > 0) {\n\t\ttarget[n] = '\\0';\n\t\treturn (target);\n\t}\n\treturn (NULL);\n}\n\nstruct event_base *\nosdep_event_init(void)\n{\n\treturn (event_init());\n}\n"
        },
        {
          "name": "osdep-unknown.c",
          "type": "blob",
          "size": 1.068359375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <event.h>\n\n#include \"tmux.h\"\n\nchar *\nosdep_get_name(__unused int fd, __unused char *tty)\n{\n\treturn (NULL);\n}\n\nchar *\nosdep_get_cwd(int fd)\n{\n\treturn (NULL);\n}\n\nstruct event_base *\nosdep_event_init(void)\n{\n\treturn (event_init());\n}\n"
        },
        {
          "name": "paste.c",
          "type": "blob",
          "size": 6.3505859375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/time.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * Set of paste buffers. Note that paste buffer data is not necessarily a C\n * string!\n */\n\nstruct paste_buffer {\n\tchar\t\t*data;\n\tsize_t\t\t size;\n\n\tchar\t\t*name;\n\tint\t\t automatic;\n\tu_int\t\t order;\n\n\tRB_ENTRY(paste_buffer) name_entry;\n\tRB_ENTRY(paste_buffer) time_entry;\n};\n\nu_int\tpaste_next_index;\nu_int\tpaste_next_order;\nu_int\tpaste_num_automatic;\nRB_HEAD(paste_name_tree, paste_buffer) paste_by_name;\nRB_HEAD(paste_time_tree, paste_buffer) paste_by_time;\n\nint paste_cmp_names(const struct paste_buffer *, const struct paste_buffer *);\nRB_PROTOTYPE(paste_name_tree, paste_buffer, name_entry, paste_cmp_names);\nRB_GENERATE(paste_name_tree, paste_buffer, name_entry, paste_cmp_names);\n\nint paste_cmp_times(const struct paste_buffer *, const struct paste_buffer *);\nRB_PROTOTYPE(paste_time_tree, paste_buffer, time_entry, paste_cmp_times);\nRB_GENERATE(paste_time_tree, paste_buffer, time_entry, paste_cmp_times);\n\nint\npaste_cmp_names(const struct paste_buffer *a, const struct paste_buffer *b)\n{\n\treturn (strcmp(a->name, b->name));\n}\n\nint\npaste_cmp_times(const struct paste_buffer *a, const struct paste_buffer *b)\n{\n\tif (a->order > b->order)\n\t\treturn (-1);\n\tif (a->order < b->order)\n\t\treturn (1);\n\treturn (0);\n}\n\n/* Get paste buffer name. */\nconst char *\npaste_buffer_name(struct paste_buffer *pb)\n{\n\treturn (pb->name);\n}\n\n/* Get paste buffer data. */\nconst char *\npaste_buffer_data(struct paste_buffer *pb, size_t *size)\n{\n\tif (size != NULL)\n\t\t*size = pb->size;\n\treturn (pb->data);\n}\n\n/* Walk paste buffers by name. */\nstruct paste_buffer *\npaste_walk(struct paste_buffer *pb)\n{\n\tif (pb == NULL)\n\t\treturn (RB_MIN(paste_time_tree, &paste_by_time));\n\treturn (RB_NEXT(paste_time_tree, &paste_by_time, pb));\n}\n\n/* Get the most recent automatic buffer. */\nstruct paste_buffer *\npaste_get_top(const char **name)\n{\n\tstruct paste_buffer\t*pb;\n\n\tpb = RB_MIN(paste_time_tree, &paste_by_time);\n\tif (pb == NULL)\n\t\treturn (NULL);\n\tif (name != NULL)\n\t\t*name = pb->name;\n\treturn (pb);\n}\n\n/* Get a paste buffer by name. */\nstruct paste_buffer *\npaste_get_name(const char *name)\n{\n\tstruct paste_buffer\tpbfind;\n\n\tif (name == NULL || *name == '\\0')\n\t\treturn (NULL);\n\n\tpbfind.name = (char *)name;\n\treturn (RB_FIND(paste_name_tree, &paste_by_name, &pbfind));\n}\n\n/* Free a paste buffer. */\nvoid\npaste_free(struct paste_buffer *pb)\n{\n\tRB_REMOVE(paste_name_tree, &paste_by_name, pb);\n\tRB_REMOVE(paste_time_tree, &paste_by_time, pb);\n\tif (pb->automatic)\n\t\tpaste_num_automatic--;\n\n\tfree(pb->data);\n\tfree(pb->name);\n\tfree(pb);\n}\n\n/*\n * Add an automatic buffer, freeing the oldest automatic item if at limit. Note\n * that the caller is responsible for allocating data.\n */\nvoid\npaste_add(char *data, size_t size)\n{\n\tstruct paste_buffer\t*pb, *pb1;\n\tu_int\t\t\t limit;\n\n\tif (size == 0)\n\t\treturn;\n\n\tlimit = options_get_number(global_options, \"buffer-limit\");\n\tRB_FOREACH_REVERSE_SAFE(pb, paste_time_tree, &paste_by_time, pb1) {\n\t\tif (paste_num_automatic < limit)\n\t\t\tbreak;\n\t\tif (pb->automatic)\n\t\t\tpaste_free(pb);\n\t}\n\n\tpb = xmalloc(sizeof *pb);\n\n\tpb->name = NULL;\n\tdo {\n\t\tfree(pb->name);\n\t\txasprintf(&pb->name, \"buffer%04u\", paste_next_index);\n\t\tpaste_next_index++;\n\t} while (paste_get_name(pb->name) != NULL);\n\n\tpb->data = data;\n\tpb->size = size;\n\n\tpb->automatic = 1;\n\tpaste_num_automatic++;\n\n\tpb->order = paste_next_order++;\n\tRB_INSERT(paste_name_tree, &paste_by_name, pb);\n\tRB_INSERT(paste_time_tree, &paste_by_time, pb);\n}\n\n/* Rename a paste buffer. */\nint\npaste_rename(const char *oldname, const char *newname, char **cause)\n{\n\tstruct paste_buffer\t*pb, *pb_new;\n\n\tif (cause != NULL)\n\t\t*cause = NULL;\n\n\tif (oldname == NULL || *oldname == '\\0') {\n\t\tif (cause != NULL)\n\t\t\t*cause = xstrdup(\"no buffer\");\n\t\treturn (-1);\n\t}\n\tif (newname == NULL || *newname == '\\0') {\n\t\tif (cause != NULL)\n\t\t\t*cause = xstrdup(\"new name is empty\");\n\t\treturn (-1);\n\t}\n\n\tpb = paste_get_name(oldname);\n\tif (pb == NULL) {\n\t\tif (cause != NULL)\n\t\t\txasprintf(cause, \"no buffer %s\", oldname);\n\t\treturn (-1);\n\t}\n\n\tpb_new = paste_get_name(newname);\n\tif (pb_new != NULL) {\n\t\tif (cause != NULL)\n\t\t\txasprintf(cause, \"buffer %s already exists\", newname);\n\t\treturn (-1);\n\t}\n\n\tRB_REMOVE(paste_name_tree, &paste_by_name, pb);\n\n\tfree(pb->name);\n\tpb->name = xstrdup(newname);\n\n\tif (pb->automatic)\n\t\tpaste_num_automatic--;\n\tpb->automatic = 0;\n\n\tRB_INSERT(paste_name_tree, &paste_by_name, pb);\n\n\treturn (0);\n}\n\n/*\n * Add or replace an item in the store. Note that the caller is responsible for\n * allocating data.\n */\nint\npaste_set(char *data, size_t size, const char *name, char **cause)\n{\n\tstruct paste_buffer\t*pb, *old;\n\n\tif (cause != NULL)\n\t\t*cause = NULL;\n\n\tif (size == 0) {\n\t\tfree(data);\n\t\treturn (0);\n\t}\n\tif (name == NULL) {\n\t\tpaste_add(data, size);\n\t\treturn (0);\n\t}\n\n\tif (*name == '\\0') {\n\t\tif (cause != NULL)\n\t\t\t*cause = xstrdup(\"empty buffer name\");\n\t\treturn (-1);\n\t}\n\n\tpb = xmalloc(sizeof *pb);\n\n\tpb->name = xstrdup(name);\n\n\tpb->data = data;\n\tpb->size = size;\n\n\tpb->automatic = 0;\n\tpb->order = paste_next_order++;\n\n\tif ((old = paste_get_name(name)) != NULL)\n\t\tpaste_free(old);\n\n\tRB_INSERT(paste_name_tree, &paste_by_name, pb);\n\tRB_INSERT(paste_time_tree, &paste_by_time, pb);\n\n\treturn (0);\n}\n\n/* Convert start of buffer into a nice string. */\nchar *\npaste_make_sample(struct paste_buffer *pb)\n{\n\tchar\t\t*buf;\n\tsize_t\t\t len, used;\n\tconst int\t flags = VIS_OCTAL|VIS_TAB|VIS_NL;\n\tconst size_t\t width = 200;\n\n\tlen = pb->size;\n\tif (len > width)\n\t\tlen = width;\n\tbuf = xreallocarray(NULL, len, 4 + 4);\n\n\tused = utf8_strvis(buf, pb->data, len, flags);\n\tif (pb->size > width || used > width)\n\t\tstrlcpy(buf + width, \"...\", 4);\n\treturn (buf);\n}\n"
        },
        {
          "name": "presentations",
          "type": "tree",
          "content": null
        },
        {
          "name": "proc.c",
          "type": "blob",
          "size": 5.6494140625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2015 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/uio.h>\n#include <sys/utsname.h>\n\n#include <errno.h>\n#include <event.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\nstruct tmuxproc {\n\tconst char\t *name;\n\tint\t\t  exit;\n\n\tvoid\t\t(*signalcb)(int);\n};\n\nstruct tmuxpeer {\n\tstruct tmuxproc\t*parent;\n\n\tstruct imsgbuf\t ibuf;\n\tstruct event\t event;\n\n\tint\t\t flags;\n#define PEER_BAD 0x1\n\n\tvoid\t\t(*dispatchcb)(struct imsg *, void *);\n\tvoid\t\t*arg;\n};\n\nstatic int\tpeer_check_version(struct tmuxpeer *, struct imsg *);\nstatic void\tproc_update_event(struct tmuxpeer *);\n\nstatic void\nproc_event_cb(__unused int fd, short events, void *arg)\n{\n\tstruct tmuxpeer\t*peer = arg;\n\tssize_t\t\t n;\n\tstruct imsg\t imsg;\n\n\tif (!(peer->flags & PEER_BAD) && (events & EV_READ)) {\n\t\tif (((n = imsg_read(&peer->ibuf)) == -1 && errno != EAGAIN) ||\n\t\t    n == 0) {\n\t\t\tpeer->dispatchcb(NULL, peer->arg);\n\t\t\treturn;\n\t\t}\n\t\tfor (;;) {\n\t\t\tif ((n = imsg_get(&peer->ibuf, &imsg)) == -1) {\n\t\t\t\tpeer->dispatchcb(NULL, peer->arg);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tlog_debug(\"peer %p message %d\", peer, imsg.hdr.type);\n\n\t\t\tif (peer_check_version(peer, &imsg) != 0) {\n\t\t\t\tif (imsg.fd != -1)\n\t\t\t\t\tclose(imsg.fd);\n\t\t\t\timsg_free(&imsg);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tpeer->dispatchcb(&imsg, peer->arg);\n\t\t\timsg_free(&imsg);\n\t\t}\n\t}\n\n\tif (events & EV_WRITE) {\n\t\tif (msgbuf_write(&peer->ibuf.w) <= 0 && errno != EAGAIN) {\n\t\t\tpeer->dispatchcb(NULL, peer->arg);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif ((peer->flags & PEER_BAD) && peer->ibuf.w.queued == 0) {\n\t\tpeer->dispatchcb(NULL, peer->arg);\n\t\treturn;\n\t}\n\n\tproc_update_event(peer);\n}\n\nstatic void\nproc_signal_cb(int signo, __unused short events, void *arg)\n{\n\tstruct tmuxproc\t*tp = arg;\n\n\ttp->signalcb(signo);\n}\n\nstatic int\npeer_check_version(struct tmuxpeer *peer, struct imsg *imsg)\n{\n\tint\tversion;\n\n\tversion = imsg->hdr.peerid & 0xff;\n\tif (imsg->hdr.type != MSG_VERSION && version != PROTOCOL_VERSION) {\n\t\tlog_debug(\"peer %p bad version %d\", peer, version);\n\n\t\tproc_send(peer, MSG_VERSION, -1, NULL, 0);\n\t\tpeer->flags |= PEER_BAD;\n\n\t\treturn (-1);\n\t}\n\treturn (0);\n}\n\nstatic void\nproc_update_event(struct tmuxpeer *peer)\n{\n\tshort\tevents;\n\n\tevent_del(&peer->event);\n\n\tevents = EV_READ;\n\tif (peer->ibuf.w.queued > 0)\n\t\tevents |= EV_WRITE;\n\tevent_set(&peer->event, peer->ibuf.fd, events, proc_event_cb, peer);\n\n\tevent_add(&peer->event, NULL);\n}\n\nint\nproc_send(struct tmuxpeer *peer, enum msgtype type, int fd, const void *buf,\n    size_t len)\n{\n\tstruct imsgbuf\t*ibuf = &peer->ibuf;\n\tvoid\t\t*vp = (void *)buf;\n\tint\t\t retval;\n\n\tif (peer->flags & PEER_BAD)\n\t\treturn (-1);\n\tlog_debug(\"sending message %d to peer %p (%zu bytes)\", type, peer, len);\n\n\tretval = imsg_compose(ibuf, type, PROTOCOL_VERSION, -1, fd, vp, len);\n\tif (retval != 1)\n\t\treturn (-1);\n\tproc_update_event(peer);\n\treturn (0);\n}\n\nint\nproc_send_s(struct tmuxpeer *peer, enum msgtype type, const char *s)\n{\n\treturn (proc_send(peer, type, -1, s, strlen(s) + 1));\n}\n\nstruct tmuxproc *\nproc_start(const char *name, struct event_base *base, int forkflag,\n    void (*signalcb)(int))\n{\n\tstruct tmuxproc\t*tp;\n\tstruct utsname\t u;\n\n\tif (forkflag && !tmate_foreground) {\n\t\tswitch (fork()) {\n\t\tcase -1:\n\t\t\tfatal(\"fork failed\");\n\t\tcase 0:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn (NULL);\n\t\t}\n\t\tif (daemon(1, 0) != 0)\n\t\t\tfatal(\"daemon failed\");\n\n\t\tclear_signals(0);\n\t\tif (event_reinit(base) != 0)\n\t\t\tfatalx(\"event_reinit failed\");\n\t}\n\n\tif (tmate_foreground) {\n\t\tif (forkflag)\n\t\t\tclear_signals(0);\n\t\tlog_open_fp(stdout);\n\t} else {\n\t\tlog_open(name);\n\t}\n\n#ifdef HAVE_SETPROCTITLE\n\tsetproctitle(\"%s (%s)\", name, socket_path);\n#endif\n\n\tif (uname(&u) < 0)\n\t\tmemset(&u, 0, sizeof u);\n\n\tlog_debug(\"%s started (%ld): socket %s, protocol %d\", name,\n\t    (long)getpid(), socket_path, PROTOCOL_VERSION);\n\tlog_debug(\"on %s %s %s; libevent %s (%s)\", u.sysname, u.release,\n\t    u.version, event_get_version(), event_get_method());\n\n\ttp = xcalloc(1, sizeof *tp);\n\ttp->name = xstrdup(name);\n\n\ttp->signalcb = signalcb;\n\tset_signals(proc_signal_cb, tp);\n\n\treturn (tp);\n}\n\nvoid\nproc_loop(struct tmuxproc *tp, int (*loopcb)(void))\n{\n\tlog_debug(\"%s loop enter\", tp->name);\n\tdo\n\t\tevent_loop(EVLOOP_ONCE);\n\twhile (!tp->exit && (loopcb == NULL || !loopcb ()));\n\tlog_debug(\"%s loop exit\", tp->name);\n}\n\nvoid\nproc_exit(struct tmuxproc *tp)\n{\n\ttp->exit = 1;\n}\n\nstruct tmuxpeer *\nproc_add_peer(struct tmuxproc *tp, int fd,\n    void (*dispatchcb)(struct imsg *, void *), void *arg)\n{\n\tstruct tmuxpeer\t*peer;\n\n\tpeer = xcalloc(1, sizeof *peer);\n\tpeer->parent = tp;\n\n\tpeer->dispatchcb = dispatchcb;\n\tpeer->arg = arg;\n\n\timsg_init(&peer->ibuf, fd);\n\tevent_set(&peer->event, fd, EV_READ, proc_event_cb, peer);\n\n\tlog_debug(\"add peer %p: %d (%p)\", peer, fd, arg);\n\n\tproc_update_event(peer);\n\treturn (peer);\n}\n\nvoid\nproc_remove_peer(struct tmuxpeer *peer)\n{\n\tlog_debug(\"remove peer %p\", peer);\n\n\tevent_del(&peer->event);\n\timsg_clear(&peer->ibuf);\n\n\tclose(peer->ibuf.fd);\n\tfree(peer);\n}\n\nvoid\nproc_kill_peer(struct tmuxpeer *peer)\n{\n\tpeer->flags |= PEER_BAD;\n}\n"
        },
        {
          "name": "resize.c",
          "type": "blob",
          "size": 4.7744140625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <string.h>\n\n#include \"tmux.h\"\n#include \"tmate.h\"\n\n/*\n * Recalculate window and session sizes.\n *\n * Every session has the size of the smallest client it is attached to and\n * every window the size of the smallest session it is attached to.\n *\n * So, when a client is resized or a session attached to or detached from a\n * client, the window sizes must be recalculated. For each session, find the\n * smallest client it is attached to, and resize it to that size. Then for\n * every window, find the smallest session it is attached to, resize it to that\n * size and clear and redraw every client with it as the current window.\n *\n * This is quite inefficient - better/additional data structures are needed\n * to make it better.\n *\n * As a side effect, this function updates the SESSION_UNATTACHED flag. This\n * flag is necessary to make sure unattached sessions do not limit the size of\n * windows that are attached both to them and to other (attached) sessions.\n */\n\nvoid\nrecalculate_sizes(void)\n{\n\tstruct session\t\t*s;\n\tstruct client\t\t*c;\n\tstruct window\t\t*w;\n\tstruct window_pane\t*wp;\n\tu_int\t\t\t ssx, ssy, has, limit;\n\tint\t\t\t flag, has_status, is_zoomed, forced;\n#ifdef TMATE\n\tint tmate_sx = tmate_session.min_sx;\n\tint tmate_sy = tmate_session.min_sy;\n#endif\n\n\tRB_FOREACH(s, sessions, &sessions) {\n\t\thas_status = options_get_number(s->options, \"status\");\n\n\t\ts->attached = 0;\n\t\tssx = ssy = UINT_MAX;\n\t\tTAILQ_FOREACH(c, &clients, entry) {\n\t\t\tif (c->flags & CLIENT_SUSPENDED)\n\t\t\t\tcontinue;\n\t\t\tif (c->session == s) {\n#ifdef TMATE\n\t\t\t\tif (c->flags & CLIENT_FORCE_STATUS)\n\t\t\t\t\thas_status = 1;\n#endif\n\t\t\t\tif (c->tty.sx < ssx)\n\t\t\t\t\tssx = c->tty.sx;\n\t\t\t\tif (has_status &&\n\t\t\t\t    !(c->flags & CLIENT_CONTROL) &&\n\t\t\t\t    c->tty.sy > 1 && c->tty.sy - 1 < ssy)\n\t\t\t\t\tssy = c->tty.sy - 1;\n\t\t\t\telse if (c->tty.sy < ssy)\n\t\t\t\t\tssy = c->tty.sy;\n\t\t\t\ts->attached++;\n\t\t\t}\n\t\t}\n\n#ifdef TMATE\n\t\t/* We assume a single session */\n\t\tif (tmate_sx > 0 && tmate_sy > 0) {\n\t\t\tif ((u_int)tmate_sx < ssx)\n\t\t\t\tssx = tmate_sx;\n\t\t\tif ((u_int)tmate_sy < ssy)\n\t\t\t\tssy = tmate_sy;\n\t\t}\n#endif\n\n\t\tif (ssx == UINT_MAX || ssy == UINT_MAX) {\n\t\t\ts->flags |= SESSION_UNATTACHED;\n\t\t\tcontinue;\n\t\t}\n\t\ts->flags &= ~SESSION_UNATTACHED;\n\n\t\tif (has_status && ssy == 0)\n\t\t\tssy = 1;\n\n\t\tif (s->sx == ssx && s->sy == ssy)\n\t\t\tcontinue;\n\n\t\tlog_debug(\"session size %u,%u (was %u,%u)\", ssx, ssy, s->sx,\n\t\t    s->sy);\n\n\t\ts->sx = ssx;\n\t\ts->sy = ssy;\n\t}\n\n\tRB_FOREACH(w, windows, &windows) {\n\t\tif (w->active == NULL)\n\t\t\tcontinue;\n\t\tflag = options_get_number(w->options, \"aggressive-resize\");\n\n\t\tssx = ssy = UINT_MAX;\n\t\tRB_FOREACH(s, sessions, &sessions) {\n\t\t\tif (s->flags & SESSION_UNATTACHED)\n\t\t\t\tcontinue;\n\t\t\tif (flag)\n\t\t\t\thas = s->curw->window == w;\n\t\t\telse\n\t\t\t\thas = session_has(s, w);\n\t\t\tif (has) {\n\t\t\t\tif (s->sx < ssx)\n\t\t\t\t\tssx = s->sx;\n\t\t\t\tif (s->sy < ssy)\n\t\t\t\t\tssy = s->sy;\n\t\t\t}\n\t\t}\n\t\tif (ssx == UINT_MAX || ssy == UINT_MAX)\n\t\t\tcontinue;\n\n\t\tforced = 0;\n\t\tlimit = options_get_number(w->options, \"force-width\");\n\t\tif (limit >= PANE_MINIMUM && ssx > limit) {\n\t\t\tssx = limit;\n\t\t\tforced |= WINDOW_FORCEWIDTH;\n\t\t}\n\t\tlimit = options_get_number(w->options, \"force-height\");\n\t\tif (limit >= PANE_MINIMUM && ssy > limit) {\n\t\t\tssy = limit;\n\t\t\tforced |= WINDOW_FORCEHEIGHT;\n\t\t}\n\n\t\tif (w->sx == ssx && w->sy == ssy)\n\t\t\tcontinue;\n\t\tlog_debug(\"window size %u,%u (was %u,%u)\", ssx, ssy, w->sx,\n\t\t    w->sy);\n\n\t\tw->flags &= ~(WINDOW_FORCEWIDTH|WINDOW_FORCEHEIGHT);\n\t\tw->flags |= forced;\n\n\t\tis_zoomed = w->flags & WINDOW_ZOOMED;\n\t\tif (is_zoomed)\n\t\t\twindow_unzoom(w);\n\t\tlayout_resize(w, ssx, ssy);\n\t\twindow_resize(w, ssx, ssy);\n\t\tif (is_zoomed && window_pane_visible(w->active))\n\t\t\twindow_zoom(w->active);\n\n\t\t/*\n\t\t * If the current pane is now not visible, move to the next\n\t\t * that is.\n\t\t */\n\t\twp = w->active;\n\t\twhile (!window_pane_visible(w->active)) {\n\t\t\tw->active = TAILQ_PREV(w->active, window_panes, entry);\n\t\t\tif (w->active == NULL)\n\t\t\t\tw->active = TAILQ_LAST(&w->panes, window_panes);\n\t\t\tif (w->active == wp)\n\t\t\t       break;\n\t\t}\n\n\t\tserver_redraw_window(w);\n\t\tnotify_window_layout_changed(w);\n\t}\n}\n"
        },
        {
          "name": "screen-redraw.c",
          "type": "blob",
          "size": 12.0517578125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <string.h>\n\n#include \"tmux.h\"\n\nint\tscreen_redraw_cell_border1(struct window_pane *, u_int, u_int);\nint\tscreen_redraw_cell_border(struct client *, u_int, u_int);\nint\tscreen_redraw_check_cell(struct client *, u_int, u_int,\n\t    struct window_pane **);\nint\tscreen_redraw_check_is(u_int, u_int, int, struct window *,\n\t    struct window_pane *, struct window_pane *);\n\nvoid\tscreen_redraw_draw_borders(struct client *, int, u_int);\nvoid\tscreen_redraw_draw_panes(struct client *, u_int);\nvoid\tscreen_redraw_draw_status(struct client *, u_int);\nvoid\tscreen_redraw_draw_number(struct client *, struct window_pane *, u_int);\n\n#define CELL_INSIDE 0\n#define CELL_LEFTRIGHT 1\n#define CELL_TOPBOTTOM 2\n#define CELL_TOPLEFT 3\n#define CELL_TOPRIGHT 4\n#define CELL_BOTTOMLEFT 5\n#define CELL_BOTTOMRIGHT 6\n#define CELL_TOPJOIN 7\n#define CELL_BOTTOMJOIN 8\n#define CELL_LEFTJOIN 9\n#define CELL_RIGHTJOIN 10\n#define CELL_JOIN 11\n#define CELL_OUTSIDE 12\n\n#define CELL_BORDERS \" xqlkmjwvtun~\"\n\n/* Check if cell is on the border of a particular pane. */\nint\nscreen_redraw_cell_border1(struct window_pane *wp, u_int px, u_int py)\n{\n\t/* Inside pane. */\n\tif (px >= wp->xoff && px < wp->xoff + wp->sx &&\n\t    py >= wp->yoff && py < wp->yoff + wp->sy)\n\t\treturn (0);\n\n\t/* Left/right borders. */\n\tif ((wp->yoff == 0 || py >= wp->yoff - 1) && py <= wp->yoff + wp->sy) {\n\t\tif (wp->xoff != 0 && px == wp->xoff - 1)\n\t\t\treturn (1);\n\t\tif (px == wp->xoff + wp->sx)\n\t\t\treturn (1);\n\t}\n\n\t/* Top/bottom borders. */\n\tif ((wp->xoff == 0 || px >= wp->xoff - 1) && px <= wp->xoff + wp->sx) {\n\t\tif (wp->yoff != 0 && py == wp->yoff - 1)\n\t\t\treturn (1);\n\t\tif (py == wp->yoff + wp->sy)\n\t\t\treturn (1);\n\t}\n\n\t/* Outside pane. */\n\treturn (-1);\n}\n\n/* Check if a cell is on the pane border. */\nint\nscreen_redraw_cell_border(struct client *c, u_int px, u_int py)\n{\n\tstruct window\t\t*w = c->session->curw->window;\n\tstruct window_pane\t*wp;\n\tint\t\t\t retval;\n\n\t/* Check all the panes. */\n\tTAILQ_FOREACH(wp, &w->panes, entry) {\n\t\tif (!window_pane_visible(wp))\n\t\t\tcontinue;\n\t\tif ((retval = screen_redraw_cell_border1(wp, px, py)) != -1)\n\t\t\treturn (retval);\n\t}\n\n\treturn (0);\n}\n\n/* Check if cell inside a pane. */\nint\nscreen_redraw_check_cell(struct client *c, u_int px, u_int py,\n    struct window_pane **wpp)\n{\n\tstruct window\t\t*w = c->session->curw->window;\n\tstruct window_pane\t*wp;\n\tint\t\t\t borders;\n\n\tif (px > w->sx || py > w->sy)\n\t\treturn (CELL_OUTSIDE);\n\n\tTAILQ_FOREACH(wp, &w->panes, entry) {\n\t\tif (!window_pane_visible(wp))\n\t\t\tcontinue;\n\t\t*wpp = wp;\n\n\t\t/* If outside the pane and its border, skip it. */\n\t\tif ((wp->xoff != 0 && px < wp->xoff - 1) ||\n\t\t    px > wp->xoff + wp->sx ||\n\t\t    (wp->yoff != 0 && py < wp->yoff - 1) ||\n\t\t    py > wp->yoff + wp->sy)\n\t\t\tcontinue;\n\n\t\t/* If definitely inside, return so. */\n\t\tif (!screen_redraw_cell_border(c, px, py))\n\t\t\treturn (CELL_INSIDE);\n\n\t\t/*\n\t\t * Construct a bitmask of whether the cells to the left (bit\n\t\t * 4), right, top, and bottom (bit 1) of this cell are borders.\n\t\t */\n\t\tborders = 0;\n\t\tif (px == 0 || screen_redraw_cell_border(c, px - 1, py))\n\t\t\tborders |= 8;\n\t\tif (px <= w->sx && screen_redraw_cell_border(c, px + 1, py))\n\t\t\tborders |= 4;\n\t\tif (py == 0 || screen_redraw_cell_border(c, px, py - 1))\n\t\t\tborders |= 2;\n\t\tif (py <= w->sy && screen_redraw_cell_border(c, px, py + 1))\n\t\t\tborders |= 1;\n\n\t\t/*\n\t\t * Figure out what kind of border this cell is. Only one bit\n\t\t * set doesn't make sense (can't have a border cell with no\n\t\t * others connected).\n\t\t */\n\t\tswitch (borders) {\n\t\tcase 15:\t/* 1111, left right top bottom */\n\t\t\treturn (CELL_JOIN);\n\t\tcase 14:\t/* 1110, left right top */\n\t\t\treturn (CELL_BOTTOMJOIN);\n\t\tcase 13:\t/* 1101, left right bottom */\n\t\t\treturn (CELL_TOPJOIN);\n\t\tcase 12:\t/* 1100, left right */\n\t\t\treturn (CELL_TOPBOTTOM);\n\t\tcase 11:\t/* 1011, left top bottom */\n\t\t\treturn (CELL_RIGHTJOIN);\n\t\tcase 10:\t/* 1010, left top */\n\t\t\treturn (CELL_BOTTOMRIGHT);\n\t\tcase 9:\t\t/* 1001, left bottom */\n\t\t\treturn (CELL_TOPRIGHT);\n\t\tcase 7:\t\t/* 0111, right top bottom */\n\t\t\treturn (CELL_LEFTJOIN);\n\t\tcase 6:\t\t/* 0110, right top */\n\t\t\treturn (CELL_BOTTOMLEFT);\n\t\tcase 5:\t\t/* 0101, right bottom */\n\t\t\treturn (CELL_TOPLEFT);\n\t\tcase 3:\t\t/* 0011, top bottom */\n\t\t\treturn (CELL_LEFTRIGHT);\n\t\t}\n\t}\n\n\t*wpp = NULL;\n\treturn (CELL_OUTSIDE);\n}\n\n/* Check if the border of a particular pane. */\nint\nscreen_redraw_check_is(u_int px, u_int py, int type, struct window *w,\n    struct window_pane *wantwp, struct window_pane *wp)\n{\n\t/* Is this off the active pane border? */\n\tif (screen_redraw_cell_border1(wantwp, px, py) != 1)\n\t\treturn (0);\n\n\t/* If there are more than two panes, that's enough. */\n\tif (window_count_panes(w) != 2)\n\t\treturn (1);\n\n\t/* Else if the cell is not a border cell, forget it. */\n\tif (wp == NULL || (type == CELL_OUTSIDE || type == CELL_INSIDE))\n\t\treturn (1);\n\n\t/* Check if the pane covers the whole width. */\n\tif (wp->xoff == 0 && wp->sx == w->sx) {\n\t\t/* This can either be the top pane or the bottom pane. */\n\t\tif (wp->yoff == 0) { /* top pane */\n\t\t\tif (wp == wantwp)\n\t\t\t\treturn (px <= wp->sx / 2);\n\t\t\treturn (px > wp->sx / 2);\n\t\t}\n\t\treturn (0);\n\t}\n\n\t/* Check if the pane covers the whole height. */\n\tif (wp->yoff == 0 && wp->sy == w->sy) {\n\t\t/* This can either be the left pane or the right pane. */\n\t\tif (wp->xoff == 0) { /* left pane */\n\t\t\tif (wp == wantwp)\n\t\t\t\treturn (py <= wp->sy / 2);\n\t\t\treturn (py > wp->sy / 2);\n\t\t}\n\t\treturn (0);\n\t}\n\n\treturn (type);\n}\n\n/* Redraw entire screen. */\nvoid\nscreen_redraw_screen(struct client *c, int draw_panes, int draw_status,\n    int draw_borders)\n{\n\tstruct options\t*oo = c->session->options;\n\tstruct tty\t*tty = &c->tty;\n\tu_int\t\t top;\n\tint\t \t status, spos;\n\n\t/* Suspended clients should not be updated. */\n\tif (c->flags & CLIENT_SUSPENDED)\n\t\treturn;\n\n\t/* Get status line, er, status. */\n\tspos = options_get_number(oo, \"status-position\");\n\tif (c->message_string != NULL || c->prompt_string != NULL)\n\t\tstatus = 1;\n\telse\n\t\tstatus = options_get_number(oo, \"status\");\n\ttop = 0;\n\tif (status && spos == 0)\n\t\ttop = 1;\n\tif (!status)\n\t\tdraw_status = 0;\n\n\tif (draw_borders)\n\t\tscreen_redraw_draw_borders(c, status, top);\n\tif (draw_panes)\n\t\tscreen_redraw_draw_panes(c, top);\n\tif (draw_status)\n\t\tscreen_redraw_draw_status(c, top);\n\ttty_reset(tty);\n}\n\n/* Draw a single pane. */\nvoid\nscreen_redraw_pane(struct client *c, struct window_pane *wp)\n{\n\tu_int\ti, yoff;\n\n\tif (!window_pane_visible(wp))\n\t\treturn;\n\n\tyoff = wp->yoff;\n\tif (status_at_line(c) == 0)\n\t\tyoff++;\n\n\tfor (i = 0; i < wp->sy; i++)\n\t\ttty_draw_pane(&c->tty, wp, i, wp->xoff, yoff);\n\ttty_reset(&c->tty);\n}\n\n/* Draw the borders. */\nvoid\nscreen_redraw_draw_borders(struct client *c, int status, u_int top)\n{\n\tstruct session\t\t*s = c->session;\n\tstruct window\t\t*w = s->curw->window;\n\tstruct options\t\t*oo = w->options;\n\tstruct tty\t\t*tty = &c->tty;\n\tstruct window_pane\t*wp = NULL;\n\tstruct grid_cell\t m_active_gc, active_gc, m_other_gc, other_gc;\n\tstruct grid_cell\t msg_gc;\n\tu_int\t\t \t i, j, type, msgx = 0, msgy = 0;\n\tint\t\t\t active, small, flags;\n\tchar\t\t\t msg[256];\n\tconst char\t\t*tmp;\n\tsize_t\t\t\t msglen = 0;\n\n\tsmall = (tty->sy - status + top > w->sy) || (tty->sx > w->sx);\n\tif (small) {\n\t\tflags = w->flags & (WINDOW_FORCEWIDTH|WINDOW_FORCEHEIGHT);\n\t\tif (flags == (WINDOW_FORCEWIDTH|WINDOW_FORCEHEIGHT))\n\t\t\ttmp = \"force-width, force-height\";\n\t\telse if (flags == WINDOW_FORCEWIDTH)\n\t\t\ttmp = \"force-width\";\n\t\telse if (flags == WINDOW_FORCEHEIGHT)\n\t\t\ttmp = \"force-height\";\n\t\telse\n\t\t\ttmp = \"a smaller client\";\n\t\txsnprintf(msg, sizeof msg, \"(size %ux%u from %s)\",\n\t\t    w->sx, w->sy, tmp);\n\t\tmsglen = strlen(msg);\n\n\t\tif (tty->sy - 1 - status + top > w->sy && tty->sx >= msglen) {\n\t\t\tmsgx = tty->sx - msglen;\n\t\t\tmsgy = tty->sy - 1 - status + top;\n\t\t} else if (tty->sx - w->sx > msglen) {\n\t\t\tmsgx = tty->sx - msglen;\n\t\t\tmsgy = tty->sy - 1 - status + top;\n\t\t} else\n\t\t\tsmall = 0;\n\t}\n\n\tstyle_apply(&other_gc, oo, \"pane-border-style\");\n\tstyle_apply(&active_gc, oo, \"pane-active-border-style\");\n\tactive_gc.attr = other_gc.attr = GRID_ATTR_CHARSET;\n\n\tmemcpy(&m_other_gc, &other_gc, sizeof m_other_gc);\n\tm_other_gc.attr ^= GRID_ATTR_REVERSE;\n\tmemcpy(&m_active_gc, &active_gc, sizeof m_active_gc);\n\tm_active_gc.attr ^= GRID_ATTR_REVERSE;\n\n\tfor (j = 0; j < tty->sy - status; j++) {\n\t\tfor (i = 0; i < tty->sx; i++) {\n\t\t\ttype = screen_redraw_check_cell(c, i, j, &wp);\n\t\t\tif (type == CELL_INSIDE)\n\t\t\t\tcontinue;\n\t\t\tif (type == CELL_OUTSIDE && small &&\n\t\t\t    i > msgx && j == msgy)\n\t\t\t\tcontinue;\n\t\t\tactive = screen_redraw_check_is(i, j, type, w,\n\t\t\t    w->active, wp);\n\t\t\tif (server_is_marked(s, s->curw, marked_pane.wp) &&\n\t\t\t    screen_redraw_check_is(i, j, type, w,\n\t\t\t    marked_pane.wp, wp)) {\n\t\t\t\tif (active)\n\t\t\t\t\ttty_attributes(tty, &m_active_gc, NULL);\n\t\t\t\telse\n\t\t\t\t\ttty_attributes(tty, &m_other_gc, NULL);\n\t\t\t} else if (active)\n\t\t\t\ttty_attributes(tty, &active_gc, NULL);\n\t\t\telse\n\t\t\t\ttty_attributes(tty, &other_gc, NULL);\n\t\t\ttty_cursor(tty, i, top + j);\n\t\t\ttty_putc(tty, CELL_BORDERS[type]);\n\t\t}\n\t}\n\n\tif (small) {\n\t\tmemcpy(&msg_gc, &grid_default_cell, sizeof msg_gc);\n\t\ttty_attributes(tty, &msg_gc, NULL);\n\t\ttty_cursor(tty, msgx, msgy);\n\t\ttty_puts(tty, msg);\n\t}\n}\n\n/* Draw the panes. */\nvoid\nscreen_redraw_draw_panes(struct client *c, u_int top)\n{\n\tstruct window\t\t*w = c->session->curw->window;\n\tstruct tty\t\t*tty = &c->tty;\n\tstruct window_pane\t*wp;\n\tu_int\t\t \t i;\n\n\tTAILQ_FOREACH(wp, &w->panes, entry) {\n\t\tif (!window_pane_visible(wp))\n\t\t\tcontinue;\n\t\tfor (i = 0; i < wp->sy; i++)\n\t\t\ttty_draw_pane(tty, wp, i, wp->xoff, top + wp->yoff);\n\t\tif (c->flags & CLIENT_IDENTIFY)\n\t\t\tscreen_redraw_draw_number(c, wp, top);\n\t}\n}\n\n/* Draw the status line. */\nvoid\nscreen_redraw_draw_status(struct client *c, u_int top)\n{\n\tstruct tty\t*tty = &c->tty;\n\n\tif (top)\n\t\ttty_draw_line(tty, NULL, &c->status, 0, 0, 0);\n\telse\n\t\ttty_draw_line(tty, NULL, &c->status, 0, 0, tty->sy - 1);\n}\n\n/* Draw number on a pane. */\nvoid\nscreen_redraw_draw_number(struct client *c, struct window_pane *wp, u_int top)\n{\n\tstruct tty\t\t*tty = &c->tty;\n\tstruct session\t\t*s = c->session;\n\tstruct options\t\t*oo = s->options;\n\tstruct window\t\t*w = wp->window;\n\tstruct grid_cell\t gc;\n\tu_int\t\t\t idx, px, py, i, j, xoff, yoff;\n\tint\t\t\t colour, active_colour;\n\tchar\t\t\t buf[16], *ptr;\n\tsize_t\t\t\t len;\n\n\tif (window_pane_index(wp, &idx) != 0)\n\t\tfatalx(\"index not found\");\n\tlen = xsnprintf(buf, sizeof buf, \"%u\", idx);\n\n\tif (wp->sx < len)\n\t\treturn;\n\tcolour = options_get_number(oo, \"display-panes-colour\");\n\tactive_colour = options_get_number(oo, \"display-panes-active-colour\");\n\n\tpx = wp->sx / 2; py = wp->sy / 2;\n\txoff = wp->xoff; yoff = wp->yoff;\n\n\tif (top)\n\t\tyoff++;\n\n\tif (wp->sx < len * 6 || wp->sy < 5) {\n\t\ttty_cursor(tty, xoff + px - len / 2, yoff + py);\n\t\tgoto draw_text;\n\t}\n\n\tpx -= len * 3;\n\tpy -= 2;\n\n\tmemcpy(&gc, &grid_default_cell, sizeof gc);\n\tif (w->active == wp)\n\t\tcolour_set_bg(&gc, active_colour);\n\telse\n\t\tcolour_set_bg(&gc, colour);\n\ttty_attributes(tty, &gc, wp);\n\tfor (ptr = buf; *ptr != '\\0'; ptr++) {\n\t\tif (*ptr < '0' || *ptr > '9')\n\t\t\tcontinue;\n\t\tidx = *ptr - '0';\n\n\t\tfor (j = 0; j < 5; j++) {\n\t\t\tfor (i = px; i < px + 5; i++) {\n\t\t\t\ttty_cursor(tty, xoff + i, yoff + py + j);\n\t\t\t\tif (window_clock_table[idx][j][i - px])\n\t\t\t\t\ttty_putc(tty, ' ');\n\t\t\t}\n\t\t}\n\t\tpx += 6;\n\t}\n\n\tlen = xsnprintf(buf, sizeof buf, \"%ux%u\", wp->sx, wp->sy);\n\tif (wp->sx < len || wp->sy < 6)\n\t\treturn;\n\ttty_cursor(tty, xoff + wp->sx - len, yoff);\n\ndraw_text:\n\tmemcpy(&gc, &grid_default_cell, sizeof gc);\n\tif (w->active == wp)\n\t\tcolour_set_fg(&gc, active_colour);\n\telse\n\t\tcolour_set_fg(&gc, colour);\n\ttty_attributes(tty, &gc, wp);\n\ttty_puts(tty, buf);\n\n\ttty_cursor(tty, 0, 0);\n}\n"
        },
        {
          "name": "screen-write.c",
          "type": "blob",
          "size": 23.7080078125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\nvoid\tscreen_write_initctx(struct screen_write_ctx *, struct tty_ctx *, int);\nvoid\tscreen_write_overwrite(struct screen_write_ctx *, u_int);\nint\tscreen_write_combine(struct screen_write_ctx *,\n\t    const struct utf8_data *);\n\n/* Initialise writing with a window. */\nvoid\nscreen_write_start(struct screen_write_ctx *ctx, struct window_pane *wp,\n    struct screen *s)\n{\n\tctx->wp = wp;\n\tif (wp != NULL && s == NULL)\n\t\tctx->s = wp->screen;\n\telse\n\t\tctx->s = s;\n}\n\n/* Finish writing. */\nvoid\nscreen_write_stop(__unused struct screen_write_ctx *ctx)\n{\n}\n\n/* Reset screen state. */\nvoid\nscreen_write_reset(struct screen_write_ctx *ctx)\n{\n\tstruct screen\t*s = ctx->s;\n\n\tscreen_reset_tabs(s);\n\tscreen_write_scrollregion(ctx, 0, screen_size_y(s) - 1);\n\n\ts->mode &= ~(MODE_INSERT|MODE_KCURSOR|MODE_KKEYPAD|MODE_FOCUSON);\n\ts->mode &= ~(ALL_MOUSE_MODES|MODE_MOUSE_UTF8|MODE_MOUSE_SGR);\n\n\tscreen_write_clearscreen(ctx);\n\tscreen_write_cursormove(ctx, 0, 0);\n}\n\n/* Write character. */\nvoid\nscreen_write_putc(struct screen_write_ctx *ctx, struct grid_cell *gc,\n    u_char ch)\n{\n\tutf8_set(&gc->data, ch);\n\tscreen_write_cell(ctx, gc);\n}\n\n/* Calculate string length, with embedded formatting. */\nsize_t\nscreen_write_cstrlen(const char *fmt, ...)\n{\n\tva_list\tap;\n\tchar   *msg, *msg2, *ptr, *ptr2;\n\tsize_t\tsize;\n\n\tva_start(ap, fmt);\n\txvasprintf(&msg, fmt, ap);\n\tva_end(ap);\n\tmsg2 = xmalloc(strlen(msg) + 1);\n\n\tptr = msg;\n\tptr2 = msg2;\n\twhile (*ptr != '\\0') {\n\t\tif (ptr[0] == '#' && ptr[1] == '[') {\n\t\t\twhile (*ptr != ']' && *ptr != '\\0')\n\t\t\t\tptr++;\n\t\t\tif (*ptr == ']')\n\t\t\t\tptr++;\n\t\t\tcontinue;\n\t\t}\n\t\t*ptr2++ = *ptr++;\n\t}\n\t*ptr2 = '\\0';\n\n\tsize = screen_write_strlen(\"%s\", msg2);\n\n\tfree(msg);\n\tfree(msg2);\n\n\treturn (size);\n}\n\n/* Calculate string length. */\nsize_t\nscreen_write_strlen(const char *fmt, ...)\n{\n\tva_list\t\t\tap;\n\tchar   \t       \t       *msg;\n\tstruct utf8_data\tud;\n\tu_char \t      \t       *ptr;\n\tsize_t\t\t\tleft, size = 0;\n\tenum utf8_state\t\tmore;\n\n\tva_start(ap, fmt);\n\txvasprintf(&msg, fmt, ap);\n\tva_end(ap);\n\n\tptr = msg;\n\twhile (*ptr != '\\0') {\n\t\tif (*ptr > 0x7f && utf8_open(&ud, *ptr) == UTF8_MORE) {\n\t\t\tptr++;\n\n\t\t\tleft = strlen(ptr);\n\t\t\tif (left < (size_t)ud.size - 1)\n\t\t\t\tbreak;\n\t\t\twhile ((more = utf8_append(&ud, *ptr)) == UTF8_MORE)\n\t\t\t\tptr++;\n\t\t\tptr++;\n\n\t\t\tif (more == UTF8_DONE)\n\t\t\t\tsize += ud.width;\n\t\t} else {\n\t\t\tif (*ptr > 0x1f && *ptr < 0x7f)\n\t\t\t\tsize++;\n\t\t\tptr++;\n\t\t}\n\t}\n\n\tfree(msg);\n\treturn (size);\n}\n\n/* Write simple string (no UTF-8 or maximum length). */\nvoid\nscreen_write_puts(struct screen_write_ctx *ctx, struct grid_cell *gc,\n    const char *fmt, ...)\n{\n\tva_list\tap;\n\n\tva_start(ap, fmt);\n\tscreen_write_vnputs(ctx, -1, gc, fmt, ap);\n\tva_end(ap);\n}\n\n/* Write string with length limit (-1 for unlimited). */\nvoid\nscreen_write_nputs(struct screen_write_ctx *ctx, ssize_t maxlen,\n    struct grid_cell *gc, const char *fmt, ...)\n{\n\tva_list\tap;\n\n\tva_start(ap, fmt);\n\tscreen_write_vnputs(ctx, maxlen, gc, fmt, ap);\n\tva_end(ap);\n}\n\nvoid\nscreen_write_vnputs(struct screen_write_ctx *ctx, ssize_t maxlen,\n    struct grid_cell *gc, const char *fmt, va_list ap)\n{\n\tchar   \t\t       *msg;\n\tstruct utf8_data\tud;\n\tu_char \t\t       *ptr;\n\tsize_t\t\t \tleft, size = 0;\n\tenum utf8_state\t\tmore;\n\n\txvasprintf(&msg, fmt, ap);\n\n\tptr = msg;\n\twhile (*ptr != '\\0') {\n\t\tif (*ptr > 0x7f && utf8_open(&ud, *ptr) == UTF8_MORE) {\n\t\t\tptr++;\n\n\t\t\tleft = strlen(ptr);\n\t\t\tif (left < (size_t)ud.size - 1)\n\t\t\t\tbreak;\n\t\t\twhile ((more = utf8_append(&ud, *ptr)) == UTF8_MORE)\n\t\t\t\tptr++;\n\t\t\tptr++;\n\n\t\t\tif (more == UTF8_DONE) {\n\t\t\t\tif (maxlen > 0 &&\n\t\t\t\t    size + ud.width > (size_t) maxlen) {\n\t\t\t\t\twhile (size < (size_t) maxlen) {\n\t\t\t\t\t\tscreen_write_putc(ctx, gc, ' ');\n\t\t\t\t\t\tsize++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsize += ud.width;\n\n\t\t\t\tutf8_copy(&gc->data, &ud);\n\t\t\t\tscreen_write_cell(ctx, gc);\n\t\t\t}\n\t\t} else {\n\t\t\tif (maxlen > 0 && size + 1 > (size_t) maxlen)\n\t\t\t\tbreak;\n\n\t\t\tif (*ptr == '\\001')\n\t\t\t\tgc->attr ^= GRID_ATTR_CHARSET;\n\t\t\telse if (*ptr > 0x1f && *ptr < 0x7f) {\n\t\t\t\tsize++;\n\t\t\t\tscreen_write_putc(ctx, gc, *ptr);\n\t\t\t}\n\t\t\tptr++;\n\t\t}\n\t}\n\n\tfree(msg);\n}\n\n/* Write string, similar to nputs, but with embedded formatting (#[]). */\nvoid\nscreen_write_cnputs(struct screen_write_ctx *ctx, ssize_t maxlen,\n    struct grid_cell *gc, const char *fmt, ...)\n{\n\tstruct grid_cell\t lgc;\n\tstruct utf8_data\t ud;\n\tva_list\t\t\t ap;\n\tchar\t\t\t*msg;\n\tu_char \t\t\t*ptr, *last;\n\tsize_t\t\t\t left, size = 0;\n\tenum utf8_state\t\t more;\n\n\tva_start(ap, fmt);\n\txvasprintf(&msg, fmt, ap);\n\tva_end(ap);\n\n\tmemcpy(&lgc, gc, sizeof lgc);\n\n\tptr = msg;\n\twhile (*ptr != '\\0') {\n\t\tif (ptr[0] == '#' && ptr[1] == '[') {\n\t\t\tptr += 2;\n\t\t\tlast = ptr + strcspn(ptr, \"]\");\n\t\t\tif (*last == '\\0') {\n\t\t\t\t/* No ]. Not much point in doing anything. */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*last = '\\0';\n\n\t\t\tstyle_parse(gc, &lgc, ptr);\n\t\t\tptr = last + 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (*ptr > 0x7f && utf8_open(&ud, *ptr) == UTF8_MORE) {\n\t\t\tptr++;\n\n\t\t\tleft = strlen(ptr);\n\t\t\tif (left < (size_t)ud.size - 1)\n\t\t\t\tbreak;\n\t\t\twhile ((more = utf8_append(&ud, *ptr)) == UTF8_MORE)\n\t\t\t\tptr++;\n\t\t\tptr++;\n\n\t\t\tif (more == UTF8_DONE) {\n\t\t\t\tif (maxlen > 0 &&\n\t\t\t\t    size + ud.width > (size_t) maxlen) {\n\t\t\t\t\twhile (size < (size_t) maxlen) {\n\t\t\t\t\t\tscreen_write_putc(ctx, gc, ' ');\n\t\t\t\t\t\tsize++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsize += ud.width;\n\n\t\t\t\tutf8_copy(&lgc.data, &ud);\n\t\t\t\tscreen_write_cell(ctx, &lgc);\n\t\t\t}\n\t\t} else {\n\t\t\tif (maxlen > 0 && size + 1 > (size_t) maxlen)\n\t\t\t\tbreak;\n\n\t\t\tif (*ptr > 0x1f && *ptr < 0x7f) {\n\t\t\t\tsize++;\n\t\t\t\tscreen_write_putc(ctx, &lgc, *ptr);\n\t\t\t}\n\t\t\tptr++;\n\t\t}\n\t}\n\n\tfree(msg);\n}\n\n/* Copy from another screen. */\nvoid\nscreen_write_copy(struct screen_write_ctx *ctx,\n    struct screen *src, u_int px, u_int py, u_int nx, u_int ny)\n{\n\tstruct screen\t\t*s = ctx->s;\n\tstruct grid\t\t*gd = src->grid;\n\tstruct grid_line\t*gl;\n\tstruct grid_cell\t gc;\n\tu_int\t\t \t xx, yy, cx, cy, ax, bx;\n\n\tcx = s->cx;\n\tcy = s->cy;\n\tfor (yy = py; yy < py + ny; yy++) {\n\t\tgl = &gd->linedata[yy];\n\t\tif (yy < gd->hsize + gd->sy) {\n\t\t\t/*\n\t\t\t * Find start and end position and copy between\n\t\t\t * them. Limit to the real end of the line then use a\n\t\t\t * clear EOL only if copying to the end, otherwise\n\t\t\t * could overwrite whatever is there already.\n\t\t\t */\n\t\t\tif (px > gl->cellsize)\n\t\t\t\tax = gl->cellsize;\n\t\t\telse\n\t\t\t\tax = px;\n\t\t\tif (px + nx == gd->sx && px + nx > gl->cellsize)\n\t\t\t\tbx = gl->cellsize;\n\t\t\telse\n\t\t\t\tbx = px + nx;\n\n\t\t\tfor (xx = ax; xx < bx; xx++) {\n\t\t\t\tgrid_get_cell(gd, xx, yy, &gc);\n\t\t\t\tscreen_write_cell(ctx, &gc);\n\t\t\t}\n\t\t\tif (px + nx == gd->sx && px + nx > gl->cellsize)\n\t\t\t\tscreen_write_clearendofline(ctx);\n\t\t} else\n\t\t\tscreen_write_clearline(ctx);\n\t\tcy++;\n\t\tscreen_write_cursormove(ctx, cx, cy);\n\t}\n}\n\n/* Set up context for TTY command. */\nvoid\nscreen_write_initctx(struct screen_write_ctx *ctx, struct tty_ctx *ttyctx,\n    int save_last)\n{\n\tstruct screen\t\t*s = ctx->s;\n\tstruct grid\t\t*gd = s->grid;\n\tstruct grid_cell\t gc;\n\tu_int\t\t\t xx;\n\n\tttyctx->wp = ctx->wp;\n\n\tttyctx->ocx = s->cx;\n\tttyctx->ocy = s->cy;\n\n\tttyctx->orlower = s->rlower;\n\tttyctx->orupper = s->rupper;\n\n\tif (!save_last)\n\t\treturn;\n\n\t/* Save the last cell on the screen. */\n\tmemcpy(&gc, &grid_default_cell, sizeof gc);\n\tfor (xx = 1; xx <= screen_size_x(s); xx++) {\n\t\tgrid_view_get_cell(gd, screen_size_x(s) - xx, s->cy, &gc);\n\t\tif (~gc.flags & GRID_FLAG_PADDING)\n\t\t\tbreak;\n\t}\n\tttyctx->last_width = xx;\n\tmemcpy(&ttyctx->last_cell, &gc, sizeof ttyctx->last_cell);\n}\n\n/* Set a mode. */\nvoid\nscreen_write_mode_set(struct screen_write_ctx *ctx, int mode)\n{\n\tstruct screen\t*s = ctx->s;\n\n\ts->mode |= mode;\n}\n\n/* Clear a mode. */\nvoid\nscreen_write_mode_clear(struct screen_write_ctx *ctx, int mode)\n{\n\tstruct screen\t*s = ctx->s;\n\n\ts->mode &= ~mode;\n}\n\n/* Cursor up by ny. */\nvoid\nscreen_write_cursorup(struct screen_write_ctx *ctx, u_int ny)\n{\n\tstruct screen\t*s = ctx->s;\n\n\tif (ny == 0)\n\t\tny = 1;\n\n\tif (s->cy < s->rupper) {\n\t\t/* Above region. */\n\t\tif (ny > s->cy)\n\t\t\tny = s->cy;\n\t} else {\n\t\t/* Below region. */\n\t\tif (ny > s->cy - s->rupper)\n\t\t\tny = s->cy - s->rupper;\n\t}\n\tif (s->cx == screen_size_x(s))\n\t    s->cx--;\n\tif (ny == 0)\n\t\treturn;\n\n\ts->cy -= ny;\n}\n\n/* Cursor down by ny. */\nvoid\nscreen_write_cursordown(struct screen_write_ctx *ctx, u_int ny)\n{\n\tstruct screen\t*s = ctx->s;\n\n\tif (ny == 0)\n\t\tny = 1;\n\n\tif (s->cy > s->rlower) {\n\t\t/* Below region. */\n\t\tif (ny > screen_size_y(s) - 1 - s->cy)\n\t\t\tny = screen_size_y(s) - 1 - s->cy;\n\t} else {\n\t\t/* Above region. */\n\t\tif (ny > s->rlower - s->cy)\n\t\t\tny = s->rlower - s->cy;\n\t}\n\tif (s->cx == screen_size_x(s))\n\t    s->cx--;\n\tif (ny == 0)\n\t\treturn;\n\n\ts->cy += ny;\n}\n\n/* Cursor right by nx.  */\nvoid\nscreen_write_cursorright(struct screen_write_ctx *ctx, u_int nx)\n{\n\tstruct screen\t*s = ctx->s;\n\n\tif (nx == 0)\n\t\tnx = 1;\n\n\tif (nx > screen_size_x(s) - 1 - s->cx)\n\t\tnx = screen_size_x(s) - 1 - s->cx;\n\tif (nx == 0)\n\t\treturn;\n\n\ts->cx += nx;\n}\n\n/* Cursor left by nx. */\nvoid\nscreen_write_cursorleft(struct screen_write_ctx *ctx, u_int nx)\n{\n\tstruct screen\t*s = ctx->s;\n\n\tif (nx == 0)\n\t\tnx = 1;\n\n\tif (nx > s->cx)\n\t\tnx = s->cx;\n\tif (nx == 0)\n\t\treturn;\n\n\ts->cx -= nx;\n}\n\n/* Backspace; cursor left unless at start of wrapped line when can move up. */\nvoid\nscreen_write_backspace(struct screen_write_ctx *ctx)\n{\n\tstruct screen\t\t*s = ctx->s;\n\tstruct grid_line\t*gl;\n\n\tif (s->cx == 0) {\n\t\tif (s->cy == 0)\n\t\t\treturn;\n\t\tgl = &s->grid->linedata[s->grid->hsize + s->cy - 1];\n\t\tif (gl->flags & GRID_LINE_WRAPPED) {\n\t\t\ts->cy--;\n\t\t\ts->cx = screen_size_x(s) - 1;\n\t\t}\n\t} else\n\t\ts->cx--;\n}\n\n/* VT100 alignment test. */\nvoid\nscreen_write_alignmenttest(struct screen_write_ctx *ctx)\n{\n\tstruct screen\t\t*s = ctx->s;\n\tstruct tty_ctx\t \t ttyctx;\n\tstruct grid_cell       \t gc;\n\tu_int\t\t\t xx, yy;\n\n\tscreen_write_initctx(ctx, &ttyctx, 0);\n\n\tmemcpy(&gc, &grid_default_cell, sizeof gc);\n\tutf8_set(&gc.data, 'E');\n\n\tfor (yy = 0; yy < screen_size_y(s); yy++) {\n\t\tfor (xx = 0; xx < screen_size_x(s); xx++)\n\t\t\tgrid_view_set_cell(s->grid, xx, yy, &gc);\n\t}\n\n\ts->cx = 0;\n\ts->cy = 0;\n\n\ts->rupper = 0;\n\n\ts->rlower = screen_size_y(s) - 1;\n\n\ttty_write(tty_cmd_alignmenttest, &ttyctx);\n}\n\n/* Insert nx characters. */\nvoid\nscreen_write_insertcharacter(struct screen_write_ctx *ctx, u_int nx)\n{\n\tstruct screen\t*s = ctx->s;\n\tstruct tty_ctx\t ttyctx;\n\n\tif (nx == 0)\n\t\tnx = 1;\n\n\tif (nx > screen_size_x(s) - s->cx)\n\t\tnx = screen_size_x(s) - s->cx;\n\tif (nx == 0)\n\t\treturn;\n\n\tscreen_write_initctx(ctx, &ttyctx, 0);\n\n\tif (s->cx <= screen_size_x(s) - 1)\n\t\tgrid_view_insert_cells(s->grid, s->cx, s->cy, nx);\n\n\tttyctx.num = nx;\n\ttty_write(tty_cmd_insertcharacter, &ttyctx);\n}\n\n/* Delete nx characters. */\nvoid\nscreen_write_deletecharacter(struct screen_write_ctx *ctx, u_int nx)\n{\n\tstruct screen\t*s = ctx->s;\n\tstruct tty_ctx\t ttyctx;\n\n\tif (nx == 0)\n\t\tnx = 1;\n\n\tif (nx > screen_size_x(s) - s->cx)\n\t\tnx = screen_size_x(s) - s->cx;\n\tif (nx == 0)\n\t\treturn;\n\n\tscreen_write_initctx(ctx, &ttyctx, 0);\n\n\tif (s->cx <= screen_size_x(s) - 1)\n\t\tgrid_view_delete_cells(s->grid, s->cx, s->cy, nx);\n\n\tttyctx.num = nx;\n\ttty_write(tty_cmd_deletecharacter, &ttyctx);\n}\n\n/* Clear nx characters. */\nvoid\nscreen_write_clearcharacter(struct screen_write_ctx *ctx, u_int nx)\n{\n\tstruct screen\t*s = ctx->s;\n\tstruct tty_ctx\t ttyctx;\n\n\tif (nx == 0)\n\t\tnx = 1;\n\n\tif (nx > screen_size_x(s) - s->cx)\n\t\tnx = screen_size_x(s) - s->cx;\n\tif (nx == 0)\n\t\treturn;\n\n\tscreen_write_initctx(ctx, &ttyctx, 0);\n\n\tif (s->cx <= screen_size_x(s) - 1)\n\t\tgrid_view_clear(s->grid, s->cx, s->cy, nx, 1);\n\n\tttyctx.num = nx;\n\ttty_write(tty_cmd_clearcharacter, &ttyctx);\n}\n\n/* Insert ny lines. */\nvoid\nscreen_write_insertline(struct screen_write_ctx *ctx, u_int ny)\n{\n\tstruct screen\t*s = ctx->s;\n\tstruct tty_ctx\t ttyctx;\n\n\tif (ny == 0)\n\t\tny = 1;\n\n\tif (s->cy < s->rupper || s->cy > s->rlower) {\n\t\tif (ny > screen_size_y(s) - s->cy)\n\t\t\tny = screen_size_y(s) - s->cy;\n\t\tif (ny == 0)\n\t\t\treturn;\n\n\t\tscreen_write_initctx(ctx, &ttyctx, 0);\n\n\t\tgrid_view_insert_lines(s->grid, s->cy, ny);\n\n\t\tttyctx.num = ny;\n\t\ttty_write(tty_cmd_insertline, &ttyctx);\n\t\treturn;\n\t}\n\n\tif (ny > s->rlower + 1 - s->cy)\n\t\tny = s->rlower + 1 - s->cy;\n\tif (ny == 0)\n\t\treturn;\n\n\tscreen_write_initctx(ctx, &ttyctx, 0);\n\n\tif (s->cy < s->rupper || s->cy > s->rlower)\n\t\tgrid_view_insert_lines(s->grid, s->cy, ny);\n\telse\n\t\tgrid_view_insert_lines_region(s->grid, s->rlower, s->cy, ny);\n\n\tttyctx.num = ny;\n\ttty_write(tty_cmd_insertline, &ttyctx);\n}\n\n/* Delete ny lines. */\nvoid\nscreen_write_deleteline(struct screen_write_ctx *ctx, u_int ny)\n{\n\tstruct screen\t*s = ctx->s;\n\tstruct tty_ctx\t ttyctx;\n\n\tif (ny == 0)\n\t\tny = 1;\n\n\tif (s->cy < s->rupper || s->cy > s->rlower) {\n\t\tif (ny > screen_size_y(s) - s->cy)\n\t\t\tny = screen_size_y(s) - s->cy;\n\t\tif (ny == 0)\n\t\t\treturn;\n\n\t\tscreen_write_initctx(ctx, &ttyctx, 0);\n\n\t\tgrid_view_delete_lines(s->grid, s->cy, ny);\n\n\t\tttyctx.num = ny;\n\t\ttty_write(tty_cmd_deleteline, &ttyctx);\n\t\treturn;\n\t}\n\n\tif (ny > s->rlower + 1 - s->cy)\n\t\tny = s->rlower + 1 - s->cy;\n\tif (ny == 0)\n\t\treturn;\n\n\tscreen_write_initctx(ctx, &ttyctx, 0);\n\n\tif (s->cy < s->rupper || s->cy > s->rlower)\n\t\tgrid_view_delete_lines(s->grid, s->cy, ny);\n\telse\n\t\tgrid_view_delete_lines_region(s->grid, s->rlower, s->cy, ny);\n\n\tttyctx.num = ny;\n\ttty_write(tty_cmd_deleteline, &ttyctx);\n}\n\n/* Clear line at cursor. */\nvoid\nscreen_write_clearline(struct screen_write_ctx *ctx)\n{\n\tstruct screen\t*s = ctx->s;\n\tstruct tty_ctx\t ttyctx;\n\n\tscreen_write_initctx(ctx, &ttyctx, 0);\n\n\tgrid_view_clear(s->grid, 0, s->cy, screen_size_x(s), 1);\n\n\ttty_write(tty_cmd_clearline, &ttyctx);\n}\n\n/* Clear to end of line from cursor. */\nvoid\nscreen_write_clearendofline(struct screen_write_ctx *ctx)\n{\n\tstruct screen\t*s = ctx->s;\n\tstruct tty_ctx\t ttyctx;\n\tu_int\t\t sx;\n\n\tscreen_write_initctx(ctx, &ttyctx, 0);\n\n\tsx = screen_size_x(s);\n\n\tif (s->cx <= sx - 1)\n\t\tgrid_view_clear(s->grid, s->cx, s->cy, sx - s->cx, 1);\n\n\ttty_write(tty_cmd_clearendofline, &ttyctx);\n}\n\n/* Clear to start of line from cursor. */\nvoid\nscreen_write_clearstartofline(struct screen_write_ctx *ctx)\n{\n\tstruct screen\t*s = ctx->s;\n\tstruct tty_ctx\t ttyctx;\n\tu_int\t\t sx;\n\n\tscreen_write_initctx(ctx, &ttyctx, 0);\n\n\tsx = screen_size_x(s);\n\n\tif (s->cx > sx - 1)\n\t\tgrid_view_clear(s->grid, 0, s->cy, sx, 1);\n\telse\n\t\tgrid_view_clear(s->grid, 0, s->cy, s->cx + 1, 1);\n\n\ttty_write(tty_cmd_clearstartofline, &ttyctx);\n}\n\n/* Move cursor to px,py.  */\nvoid\nscreen_write_cursormove(struct screen_write_ctx *ctx, u_int px, u_int py)\n{\n\tstruct screen\t*s = ctx->s;\n\n\tif (px > screen_size_x(s) - 1)\n\t\tpx = screen_size_x(s) - 1;\n\tif (py > screen_size_y(s) - 1)\n\t\tpy = screen_size_y(s) - 1;\n\n\ts->cx = px;\n\ts->cy = py;\n}\n\n/* Reverse index (up with scroll).  */\nvoid\nscreen_write_reverseindex(struct screen_write_ctx *ctx)\n{\n\tstruct screen\t*s = ctx->s;\n\tstruct tty_ctx\t ttyctx;\n\n\tscreen_write_initctx(ctx, &ttyctx, 0);\n\n\tif (s->cy == s->rupper)\n\t\tgrid_view_scroll_region_down(s->grid, s->rupper, s->rlower);\n\telse if (s->cy > 0)\n\t\ts->cy--;\n\n\ttty_write(tty_cmd_reverseindex, &ttyctx);\n}\n\n/* Set scroll region. */\nvoid\nscreen_write_scrollregion(struct screen_write_ctx *ctx, u_int rupper,\n    u_int rlower)\n{\n\tstruct screen\t*s = ctx->s;\n\n\tif (rupper > screen_size_y(s) - 1)\n\t\trupper = screen_size_y(s) - 1;\n\tif (rlower > screen_size_y(s) - 1)\n\t\trlower = screen_size_y(s) - 1;\n\tif (rupper >= rlower)\t/* cannot be one line */\n\t\treturn;\n\n\t/* Cursor moves to top-left. */\n\ts->cx = 0;\n\ts->cy = 0;\n\n\ts->rupper = rupper;\n\ts->rlower = rlower;\n}\n\n/* Line feed. */\nvoid\nscreen_write_linefeed(struct screen_write_ctx *ctx, int wrapped)\n{\n\tstruct screen\t\t*s = ctx->s;\n\tstruct grid_line\t*gl;\n\tstruct tty_ctx\t \t ttyctx;\n\n\tscreen_write_initctx(ctx, &ttyctx, 0);\n\n\tgl = &s->grid->linedata[s->grid->hsize + s->cy];\n\tif (wrapped)\n\t\tgl->flags |= GRID_LINE_WRAPPED;\n\telse\n\t\tgl->flags &= ~GRID_LINE_WRAPPED;\n\n\tif (s->cy == s->rlower)\n\t\tgrid_view_scroll_region_up(s->grid, s->rupper, s->rlower);\n\telse if (s->cy < screen_size_y(s) - 1)\n\t\ts->cy++;\n\n\tttyctx.num = wrapped;\n\ttty_write(tty_cmd_linefeed, &ttyctx);\n}\n\n/* Carriage return (cursor to start of line). */\nvoid\nscreen_write_carriagereturn(struct screen_write_ctx *ctx)\n{\n\tstruct screen\t*s = ctx->s;\n\n\ts->cx = 0;\n}\n\n/* Clear to end of screen from cursor. */\nvoid\nscreen_write_clearendofscreen(struct screen_write_ctx *ctx)\n{\n\tstruct screen\t*s = ctx->s;\n\tstruct tty_ctx\t ttyctx;\n\tu_int\t\t sx, sy;\n\n\tscreen_write_initctx(ctx, &ttyctx, 0);\n\n\tsx = screen_size_x(s);\n\tsy = screen_size_y(s);\n\n\t/* Scroll into history if it is enabled and clearing entire screen. */\n\tif (s->cy == 0 && s->grid->flags & GRID_HISTORY)\n\t\tgrid_view_clear_history(s->grid);\n\telse {\n\t\tif (s->cx <= sx - 1)\n\t\t\tgrid_view_clear(s->grid, s->cx, s->cy, sx - s->cx, 1);\n\t\tgrid_view_clear(s->grid, 0, s->cy + 1, sx, sy - (s->cy + 1));\n\t}\n\n\ttty_write(tty_cmd_clearendofscreen, &ttyctx);\n}\n\n/* Clear to start of screen. */\nvoid\nscreen_write_clearstartofscreen(struct screen_write_ctx *ctx)\n{\n\tstruct screen\t*s = ctx->s;\n\tstruct tty_ctx\t ttyctx;\n\tu_int\t\t sx;\n\n\tscreen_write_initctx(ctx, &ttyctx, 0);\n\n\tsx = screen_size_x(s);\n\n\tif (s->cy > 0)\n\t\tgrid_view_clear(s->grid, 0, 0, sx, s->cy);\n\tif (s->cx > sx - 1)\n\t\tgrid_view_clear(s->grid, 0, s->cy, sx, 1);\n\telse\n\t\tgrid_view_clear(s->grid, 0, s->cy, s->cx + 1, 1);\n\n\ttty_write(tty_cmd_clearstartofscreen, &ttyctx);\n}\n\n/* Clear entire screen. */\nvoid\nscreen_write_clearscreen(struct screen_write_ctx *ctx)\n{\n\tstruct screen\t*s = ctx->s;\n\tstruct tty_ctx\t ttyctx;\n\tu_int\t\t sx = screen_size_x(s);\n\tu_int\t\t sy = screen_size_y(s);\n\n\tscreen_write_initctx(ctx, &ttyctx, 0);\n\n\t/* Scroll into history if it is enabled. */\n\tif (s->grid->flags & GRID_HISTORY)\n\t\tgrid_view_clear_history(s->grid);\n\telse\n\t\tgrid_view_clear(s->grid, 0, 0, sx, sy);\n\n\ttty_write(tty_cmd_clearscreen, &ttyctx);\n}\n\n/* Clear entire history. */\nvoid\nscreen_write_clearhistory(struct screen_write_ctx *ctx)\n{\n\tstruct screen\t*s = ctx->s;\n\tstruct grid\t*gd = s->grid;\n\n\tgrid_move_lines(gd, 0, gd->hsize, gd->sy);\n\tgd->hsize = 0;\n}\n\n/* Write cell data. */\nvoid\nscreen_write_cell(struct screen_write_ctx *ctx, const struct grid_cell *gc)\n{\n\tstruct screen\t\t*s = ctx->s;\n\tstruct grid\t\t*gd = s->grid;\n\tstruct tty_ctx\t\t ttyctx;\n\tu_int\t\t \t width, xx, last;\n\tstruct grid_cell \t tmp_gc;\n\tint\t\t\t insert;\n\n\t/* Ignore padding. */\n\tif (gc->flags & GRID_FLAG_PADDING)\n\t\treturn;\n\twidth = gc->data.width;\n\n\t/*\n\t * If this is a wide character and there is no room on the screen, for\n\t * the entire character, don't print it.\n\t */\n\tif (!(s->mode & MODE_WRAP)\n\t    && (width > 1 && (width > screen_size_x(s) ||\n\t\t(s->cx != screen_size_x(s)\n\t\t && s->cx > screen_size_x(s) - width))))\n\t\treturn;\n\n\t/*\n\t * If the width is zero, combine onto the previous character, if\n\t * there is space.\n\t */\n\tif (width == 0) {\n\t\tif (screen_write_combine(ctx, &gc->data) == 0) {\n\t\t\tscreen_write_initctx(ctx, &ttyctx, 0);\n\t\t\ttty_write(tty_cmd_utf8character, &ttyctx);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* Initialise the redraw context, saving the last cell. */\n\tscreen_write_initctx(ctx, &ttyctx, 1);\n\n\t/* If in insert mode, make space for the cells. */\n\tif ((s->mode & MODE_INSERT) && s->cx <= screen_size_x(s) - width) {\n\t\txx = screen_size_x(s) - s->cx - width;\n\t\tgrid_move_cells(s->grid, s->cx + width, s->cx, s->cy, xx);\n\t\tinsert = 1;\n\t} else\n\t\tinsert = 0;\n\n\t/* Check this will fit on the current line and wrap if not. */\n\tif ((s->mode & MODE_WRAP) && s->cx > screen_size_x(s) - width) {\n\t\tscreen_write_linefeed(ctx, 1);\n\t\ts->cx = 0;\t/* carriage return */\n\t}\n\n\t/* Sanity check cursor position. */\n\tif (s->cx > screen_size_x(s) - width || s->cy > screen_size_y(s) - 1)\n\t\treturn;\n\n\t/* Handle overwriting of UTF-8 characters. */\n\tscreen_write_overwrite(ctx, width);\n\n\t/*\n\t * If the new character is UTF-8 wide, fill in padding cells. Have\n\t * already ensured there is enough room.\n\t */\n\tmemcpy(&tmp_gc, &grid_default_cell, sizeof tmp_gc);\n\ttmp_gc.flags |= GRID_FLAG_PADDING;\n\ttmp_gc.data.width = 0;\n\tfor (xx = s->cx + 1; xx < s->cx + width; xx++)\n\t\tgrid_view_set_cell(gd, xx, s->cy, &tmp_gc);\n\n\t/* Set the cell. */\n\tgrid_view_set_cell(gd, s->cx, s->cy, gc);\n\n\t/*\n\t * Move the cursor. If not wrapping, stick at the last character and\n\t * replace it.\n\t */\n\tlast = !(s->mode & MODE_WRAP);\n\tif (s->cx <= screen_size_x(s) - last - width)\n\t\ts->cx += width;\n\telse\n\t\ts->cx = screen_size_x(s) - last;\n\n\t/* Draw to the screen if necessary. */\n\tif (insert) {\n\t\tttyctx.num = width;\n\t\ttty_write(tty_cmd_insertcharacter, &ttyctx);\n\t}\n\tif (screen_check_selection(s, s->cx - width, s->cy)) {\n\t\tmemcpy(&tmp_gc, &s->sel.cell, sizeof tmp_gc);\n\t\tutf8_copy(&tmp_gc.data, &gc->data);\n\t\ttmp_gc.attr = tmp_gc.attr & ~GRID_ATTR_CHARSET;\n\t\ttmp_gc.attr |= gc->attr & GRID_ATTR_CHARSET;\n\t\ttmp_gc.flags = gc->flags;\n\t\ttmp_gc.flags &= ~(GRID_FLAG_FGRGB|GRID_FLAG_BGRGB);\n\t\ttmp_gc.flags &= ~(GRID_FLAG_FG256|GRID_FLAG_BG256);\n\t\ttmp_gc.flags |= s->sel.cell.flags &\n\t\t    (GRID_FLAG_FG256|GRID_FLAG_BG256);\n\t\tttyctx.cell = &tmp_gc;\n\t\ttty_write(tty_cmd_cell, &ttyctx);\n\t} else {\n\t\tttyctx.cell = gc;\n\t\ttty_write(tty_cmd_cell, &ttyctx);\n\t}\n}\n\n/* Combine a UTF-8 zero-width character onto the previous. */\nint\nscreen_write_combine(struct screen_write_ctx *ctx, const struct utf8_data *ud)\n{\n\tstruct screen\t\t*s = ctx->s;\n\tstruct grid\t\t*gd = s->grid;\n\tstruct grid_cell\t gc;\n\n\t/* Can't combine if at 0. */\n\tif (s->cx == 0)\n\t\treturn (-1);\n\n\t/* Empty data is out. */\n\tif (ud->size == 0)\n\t\tfatalx(\"UTF-8 data empty\");\n\n\t/* Retrieve the previous cell. */\n\tgrid_view_get_cell(gd, s->cx - 1, s->cy, &gc);\n\n\t/* Check there is enough space. */\n\tif (gc.data.size + ud->size > sizeof gc.data.data)\n\t\treturn (-1);\n\n\t/* Append the data. */\n\tmemcpy(gc.data.data + gc.data.size, ud->data, ud->size);\n\tgc.data.size += ud->size;\n\n\t/* Set the new cell. */\n\tgrid_view_set_cell(gd, s->cx - 1, s->cy, &gc);\n\n\treturn (0);\n}\n\n/*\n * UTF-8 wide characters are a bit of an annoyance. They take up more than one\n * cell on the screen, so following cells must not be drawn by marking them as\n * padding.\n *\n * So far, so good. The problem is, when overwriting a padding cell, or a UTF-8\n * character, it is necessary to also overwrite any other cells which covered\n * by the same character.\n */\nvoid\nscreen_write_overwrite(struct screen_write_ctx *ctx, u_int width)\n{\n\tstruct screen\t\t*s = ctx->s;\n\tstruct grid\t\t*gd = s->grid;\n\tstruct grid_cell\t gc;\n\tu_int\t\t\t xx;\n\n\tgrid_view_get_cell(gd, s->cx, s->cy, &gc);\n\tif (gc.flags & GRID_FLAG_PADDING) {\n\t\t/*\n\t\t * A padding cell, so clear any following and leading padding\n\t\t * cells back to the character. Don't overwrite the current\n\t\t * cell as that happens later anyway.\n\t\t */\n\t\txx = s->cx + 1;\n\t\twhile (--xx > 0) {\n\t\t\tgrid_view_get_cell(gd, xx, s->cy, &gc);\n\t\t\tif (~gc.flags & GRID_FLAG_PADDING)\n\t\t\t\tbreak;\n\t\t\tgrid_view_set_cell(gd, xx, s->cy, &grid_default_cell);\n\t\t}\n\n\t\t/* Overwrite the character at the start of this padding. */\n\t\tgrid_view_set_cell(gd, xx, s->cy, &grid_default_cell);\n\t}\n\n\t/*\n\t * Overwrite any padding cells that belong to a UTF-8 character\n\t * we'll be overwriting with the current character.\n\t */\n\txx = s->cx + width - 1;\n\twhile (++xx < screen_size_x(s)) {\n\t\tgrid_view_get_cell(gd, xx, s->cy, &gc);\n\t\tif (~gc.flags & GRID_FLAG_PADDING)\n\t\t\tbreak;\n\t\tgrid_view_set_cell(gd, xx, s->cy, &grid_default_cell);\n\t}\n}\n\nvoid\nscreen_write_setselection(struct screen_write_ctx *ctx, u_char *str, u_int len)\n{\n\tstruct tty_ctx\tttyctx;\n\n\tscreen_write_initctx(ctx, &ttyctx, 0);\n\tttyctx.ptr = str;\n\tttyctx.num = len;\n\n\ttty_write(tty_cmd_setselection, &ttyctx);\n}\n\nvoid\nscreen_write_rawstring(struct screen_write_ctx *ctx, u_char *str, u_int len)\n{\n\tstruct tty_ctx\t\t ttyctx;\n\n\tscreen_write_initctx(ctx, &ttyctx, 0);\n\tttyctx.ptr = str;\n\tttyctx.num = len;\n\n\ttty_write(tty_cmd_rawstring, &ttyctx);\n}\n"
        },
        {
          "name": "screen.c",
          "type": "blob",
          "size": 8.2119140625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\nvoid\tscreen_resize_x(struct screen *, u_int);\nvoid\tscreen_resize_y(struct screen *, u_int);\n\n/* Create a new screen. */\nvoid\nscreen_init(struct screen *s, u_int sx, u_int sy, u_int hlimit)\n{\n\ts->grid = grid_create(sx, sy, hlimit);\n\ts->title = xstrdup(\"\");\n\n\ts->cstyle = 0;\n\ts->ccolour = xstrdup(\"\");\n\ts->tabs = NULL;\n\n\tscreen_reinit(s);\n}\n\n/* Reinitialise screen. */\nvoid\nscreen_reinit(struct screen *s)\n{\n\ts->cx = 0;\n\ts->cy = 0;\n\n\ts->rupper = 0;\n\ts->rlower = screen_size_y(s) - 1;\n\n\ts->mode = MODE_CURSOR | MODE_WRAP;\n\n\tscreen_reset_tabs(s);\n\n\tgrid_clear_lines(s->grid, s->grid->hsize, s->grid->sy);\n\n\tscreen_clear_selection(s);\n}\n\n/* Destroy a screen. */\nvoid\nscreen_free(struct screen *s)\n{\n\tfree(s->tabs);\n\tfree(s->title);\n\tfree(s->ccolour);\n\tgrid_destroy(s->grid);\n}\n\n/* Reset tabs to default, eight spaces apart. */\nvoid\nscreen_reset_tabs(struct screen *s)\n{\n\tu_int\ti;\n\n\tfree(s->tabs);\n\n\tif ((s->tabs = bit_alloc(screen_size_x(s))) == NULL)\n\t\tfatal(\"bit_alloc failed\");\n\tfor (i = 8; i < screen_size_x(s); i += 8)\n\t\tbit_set(s->tabs, i);\n}\n\n/* Set screen cursor style. */\nvoid\nscreen_set_cursor_style(struct screen *s, u_int style)\n{\n\tif (style <= 6)\n\t\ts->cstyle = style;\n}\n\n/* Set screen cursor colour. */\nvoid\nscreen_set_cursor_colour(struct screen *s, const char *colour)\n{\n\tfree(s->ccolour);\n\ts->ccolour = xstrdup(colour);\n}\n\n/* Set screen title. */\nvoid\nscreen_set_title(struct screen *s, const char *title)\n{\n\tfree(s->title);\n\ts->title = xstrdup(title);\n}\n\n/* Resize screen. */\nvoid\nscreen_resize(struct screen *s, u_int sx, u_int sy, int reflow)\n{\n\tif (sx < 1)\n\t\tsx = 1;\n\tif (sy < 1)\n\t\tsy = 1;\n\n\tif (sx != screen_size_x(s)) {\n\t\tscreen_resize_x(s, sx);\n\n\t\t/*\n\t\t * It is unclear what should happen to tabs on resize. xterm\n\t\t * seems to try and maintain them, rxvt resets them. Resetting\n\t\t * is simpler and more reliable so let's do that.\n\t\t */\n\t\tscreen_reset_tabs(s);\n\t}\n\n\tif (sy != screen_size_y(s))\n\t\tscreen_resize_y(s, sy);\n\n\tif (reflow)\n\t\tscreen_reflow(s, sx);\n}\n\nvoid\nscreen_resize_x(struct screen *s, u_int sx)\n{\n\tstruct grid\t\t*gd = s->grid;\n\n\tif (sx == 0)\n\t\tfatalx(\"zero size\");\n\n\t/*\n\t * Treat resizing horizontally simply: just ensure the cursor is\n\t * on-screen and change the size. Don't bother to truncate any lines -\n\t * then the data should be accessible if the size is then incrased.\n\t *\n\t * The only potential wrinkle is if UTF-8 double-width characters are\n\t * left in the last column, but UTF-8 terminals should deal with this\n\t * sanely.\n\t */\n\tif (s->cx >= sx)\n\t\ts->cx = sx - 1;\n\tgd->sx = sx;\n}\n\nvoid\nscreen_resize_y(struct screen *s, u_int sy)\n{\n\tstruct grid\t*gd = s->grid;\n\tu_int\t\t needed, available, oldy, i;\n\n\tif (sy == 0)\n\t\tfatalx(\"zero size\");\n\toldy = screen_size_y(s);\n\n\t/*\n\t * When resizing:\n\t *\n\t * If the height is decreasing, delete lines from the bottom until\n\t * hitting the cursor, then push lines from the top into the history.\n\t *\n\t * When increasing, pull as many lines as possible from the history to\n\t * the top, then fill the remaining with blanks at the bottom.\n\t */\n\n\t/* Size decreasing. */\n\tif (sy < oldy) {\n\t\tneeded = oldy - sy;\n\n\t\t/* Delete as many lines as possible from the bottom. */\n\t\tavailable = oldy - 1 - s->cy;\n\t\tif (available > 0) {\n\t\t\tif (available > needed)\n\t\t\t\tavailable = needed;\n\t\t\tgrid_view_delete_lines(gd, oldy - available, available);\n\t\t}\n\t\tneeded -= available;\n\n\t\t/*\n\t\t * Now just increase the history size, if possible, to take\n\t\t * over the lines which are left. If history is off, delete\n\t\t * lines from the top.\n\t\t */\n\t\tavailable = s->cy;\n\t\tif (gd->flags & GRID_HISTORY)\n\t\t\tgd->hsize += needed;\n\t\telse if (needed > 0 && available > 0) {\n\t\t\tif (available > needed)\n\t\t\t\tavailable = needed;\n\t\t\tgrid_view_delete_lines(gd, 0, available);\n\t\t}\n\t\ts->cy -= needed;\n\t}\n\n\t/* Resize line arrays. */\n\tgd->linedata = xreallocarray(gd->linedata, gd->hsize + sy,\n\t    sizeof *gd->linedata);\n\n\t/* Size increasing. */\n\tif (sy > oldy) {\n\t\tneeded = sy - oldy;\n\n\t\t/*\n\t\t * Try to pull as much as possible out of the history, if is\n\t\t * is enabled.\n\t\t */\n\t\tavailable = gd->hsize;\n\t\tif (gd->flags & GRID_HISTORY && available > 0) {\n\t\t\tif (available > needed)\n\t\t\t\tavailable = needed;\n\t\t\tgd->hsize -= available;\n\t\t\ts->cy += available;\n\t\t} else\n\t\t\tavailable = 0;\n\t\tneeded -= available;\n\n\t\t/* Then fill the rest in with blanks. */\n\t\tfor (i = gd->hsize + sy - needed; i < gd->hsize + sy; i++)\n\t\t\tmemset(&gd->linedata[i], 0, sizeof gd->linedata[i]);\n\t}\n\n\t/* Set the new size, and reset the scroll region. */\n\tgd->sy = sy;\n\ts->rupper = 0;\n\ts->rlower = screen_size_y(s) - 1;\n}\n\n/* Set selection. */\nvoid\nscreen_set_selection(struct screen *s, u_int sx, u_int sy,\n    u_int ex, u_int ey, u_int rectflag, struct grid_cell *gc)\n{\n\tstruct screen_sel\t*sel = &s->sel;\n\n\tmemcpy(&sel->cell, gc, sizeof sel->cell);\n\tsel->flag = 1;\n\tsel->rectflag = rectflag;\n\n\tsel->sx = sx; sel->sy = sy;\n\tsel->ex = ex; sel->ey = ey;\n}\n\n/* Clear selection. */\nvoid\nscreen_clear_selection(struct screen *s)\n{\n\tstruct screen_sel\t*sel = &s->sel;\n\n\tsel->flag = 0;\n\tsel->lineflag = LINE_SEL_NONE;\n}\n\n/* Check if cell in selection. */\nint\nscreen_check_selection(struct screen *s, u_int px, u_int py)\n{\n\tstruct screen_sel\t*sel = &s->sel;\n\tu_int\t\t\t xx;\n\n\tif (!sel->flag)\n\t\treturn (0);\n\n\tif (sel->rectflag) {\n\t\tif (sel->sy < sel->ey) {\n\t\t\t/* start line < end line -- downward selection. */\n\t\t\tif (py < sel->sy || py > sel->ey)\n\t\t\t\treturn (0);\n\t\t} else if (sel->sy > sel->ey) {\n\t\t\t/* start line > end line -- upward selection. */\n\t\t\tif (py > sel->sy || py < sel->ey)\n\t\t\t\treturn (0);\n\t\t} else {\n\t\t\t/* starting line == ending line. */\n\t\t\tif (py != sel->sy)\n\t\t\t\treturn (0);\n\t\t}\n\n\t\t/*\n\t\t * Need to include the selection start row, but not the cursor\n\t\t * row, which means the selection changes depending on which\n\t\t * one is on the left.\n\t\t */\n\t\tif (sel->ex < sel->sx) {\n\t\t\t/* Cursor (ex) is on the left. */\n\t\t\tif (px < sel->ex)\n\t\t\t\treturn (0);\n\n\t\t\tif (px > sel->sx)\n\t\t\t\treturn (0);\n\t\t} else {\n\t\t\t/* Selection start (sx) is on the left. */\n\t\t\tif (px < sel->sx)\n\t\t\t\treturn (0);\n\n\t\t\tif (px > sel->ex)\n\t\t\t\treturn (0);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Like emacs, keep the top-left-most character, and drop the\n\t\t * bottom-right-most, regardless of copy direction.\n\t\t */\n\t\tif (sel->sy < sel->ey) {\n\t\t\t/* starting line < ending line -- downward selection. */\n\t\t\tif (py < sel->sy || py > sel->ey)\n\t\t\t\treturn (0);\n\n\t\t\tif (py == sel->sy && px < sel->sx)\n\t\t\t\treturn (0);\n\n\t\t\tif (py == sel->ey && px > sel->ex)\n\t\t\t\treturn (0);\n\t\t} else if (sel->sy > sel->ey) {\n\t\t\t/* starting line > ending line -- upward selection. */\n\t\t\tif (py > sel->sy || py < sel->ey)\n\t\t\t\treturn (0);\n\n\t\t\tif (py == sel->ey && px < sel->ex)\n\t\t\t\treturn (0);\n\n\t\t\tif (sel->modekeys == MODEKEY_EMACS)\n\t\t\t\txx = sel->sx - 1;\n\t\t\telse\n\t\t\t\txx = sel->sx;\n\t\t\tif (py == sel->sy && px > xx)\n\t\t\t\treturn (0);\n\t\t} else {\n\t\t\t/* starting line == ending line. */\n\t\t\tif (py != sel->sy)\n\t\t\t\treturn (0);\n\n\t\t\tif (sel->ex < sel->sx) {\n\t\t\t\t/* cursor (ex) is on the left */\n\t\t\t\tif (sel->modekeys == MODEKEY_EMACS)\n\t\t\t\t\txx = sel->sx - 1;\n\t\t\t\telse\n\t\t\t\t\txx = sel->sx;\n\t\t\t\tif (px > xx || px < sel->ex)\n\t\t\t\t\treturn (0);\n\t\t\t} else {\n\t\t\t\t/* selection start (sx) is on the left */\n\t\t\t\tif (px < sel->sx || px > sel->ex)\n\t\t\t\t\treturn (0);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (1);\n}\n\n/* Reflow wrapped lines. */\nvoid\nscreen_reflow(struct screen *s, u_int new_x)\n{\n\tstruct grid\t*old = s->grid;\n\tu_int\t\t change;\n\n\ts->grid = grid_create(old->sx, old->sy, old->hlimit);\n\n\tchange = grid_reflow(s->grid, old, new_x);\n\tif (change < s->cy)\n\t\ts->cy -= change;\n\telse\n\t\ts->cy = 0;\n}\n"
        },
        {
          "name": "server-client.c",
          "type": "blob",
          "size": 32.8359375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n\n#include <errno.h>\n#include <event.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n#include \"tmate.h\"\n\nvoid\t\tserver_client_free(int, short, void *);\nvoid\t\tserver_client_check_focus(struct window_pane *);\nvoid\t\tserver_client_check_resize(struct window_pane *);\nkey_code\tserver_client_check_mouse(struct client *);\nvoid\t\tserver_client_repeat_timer(int, short, void *);\nvoid\t\tserver_client_check_exit(struct client *);\nvoid\t\tserver_client_check_redraw(struct client *);\nvoid\t\tserver_client_set_title(struct client *);\nvoid\t\tserver_client_reset_state(struct client *);\nint\t\tserver_client_assume_paste(struct session *);\n\nvoid\t\tserver_client_dispatch(struct imsg *, void *);\nvoid\t\tserver_client_dispatch_command(struct client *, struct imsg *);\nvoid\t\tserver_client_dispatch_identify(struct client *, struct imsg *);\nvoid\t\tserver_client_dispatch_shell(struct client *);\n\n/* Check if this client is inside this server. */\nint\nserver_client_check_nested(struct client *c)\n{\n\tstruct environ_entry\t*envent;\n\tstruct window_pane\t*wp;\n\n\tif (c->tty.path == NULL)\n\t\treturn (0);\n\n\tenvent = environ_find(c->environ, \"TMUX\");\n\tif (envent == NULL || *envent->value == '\\0')\n\t\treturn (0);\n\n\tRB_FOREACH(wp, window_pane_tree, &all_window_panes) {\n\t\tif (strcmp(wp->tty, c->tty.path) == 0)\n\t\t\treturn (1);\n\t}\n\treturn (0);\n}\n\n/* Set client key table. */\nvoid\nserver_client_set_key_table(struct client *c, const char *name)\n{\n\tif (name == NULL)\n\t\tname = server_client_get_key_table(c);\n\n\tkey_bindings_unref_table(c->keytable);\n\tc->keytable = key_bindings_get_table(name, 1);\n\tc->keytable->references++;\n}\n\n/* Get default key table. */\nconst char *\nserver_client_get_key_table(struct client *c)\n{\n\tstruct session\t*s = c->session;\n\tconst char\t*name;\n\n\tif (s == NULL)\n\t\treturn (\"root\");\n\n\tname = options_get_string(s->options, \"key-table\");\n\tif (*name == '\\0')\n\t\treturn (\"root\");\n\treturn (name);\n}\n\n/* Create a new client. */\nvoid\nserver_client_create(int fd)\n{\n\tstruct client\t*c;\n\n\tsetblocking(fd, 0);\n\n\tc = xcalloc(1, sizeof *c);\n\tc->references = 1;\n\tc->peer = proc_add_peer(server_proc, fd, server_client_dispatch, c);\n\n\tif (gettimeofday(&c->creation_time, NULL) != 0)\n\t\tfatal(\"gettimeofday failed\");\n\tmemcpy(&c->activity_time, &c->creation_time, sizeof c->activity_time);\n\n\tc->environ = environ_create();\n\n\tc->fd = -1;\n\tc->cwd = NULL;\n\n\tc->cmdq = cmdq_new(c);\n\tc->cmdq->client_exit = 1;\n\n\tc->stdin_data = evbuffer_new();\n\tc->stdout_data = evbuffer_new();\n\tc->stderr_data = evbuffer_new();\n\n\tc->tty.fd = -1;\n\tc->title = NULL;\n\n\tc->session = NULL;\n\tc->last_session = NULL;\n\tc->tty.sx = 80;\n\tc->tty.sy = 24;\n\n\tscreen_init(&c->status, c->tty.sx, 1, 0);\n\n\tc->message_string = NULL;\n\tTAILQ_INIT(&c->message_log);\n\n\tc->prompt_string = NULL;\n\tc->prompt_buffer = NULL;\n\tc->prompt_index = 0;\n\n\tc->flags |= CLIENT_FOCUSED;\n\n\tc->keytable = key_bindings_get_table(\"root\", 1);\n\tc->keytable->references++;\n\n\tevtimer_set(&c->repeat_timer, server_client_repeat_timer, c);\n\n\tTAILQ_INSERT_TAIL(&clients, c, entry);\n\tlog_debug(\"new client %p\", c);\n}\n\n/* Open client terminal if needed. */\nint\nserver_client_open(struct client *c, char **cause)\n{\n\tif (c->flags & CLIENT_CONTROL)\n\t\treturn (0);\n\n\tif (strcmp(c->ttyname, \"/dev/tty\") == 0) {\n\t\t*cause = xstrdup(\"can't use /dev/tty\");\n\t\treturn (-1);\n\t}\n\n\tif (!(c->flags & CLIENT_TERMINAL)) {\n\t\t*cause = xstrdup(\"not a terminal\");\n\t\treturn (-1);\n\t}\n\n\tif (tty_open(&c->tty, cause) != 0)\n\t\treturn (-1);\n\n\treturn (0);\n}\n\n/* Lost a client. */\nvoid\nserver_client_lost(struct client *c)\n{\n\tstruct message_entry\t*msg, *msg1;\n\n\tc->flags |= CLIENT_DEAD;\n\n\tstatus_prompt_clear(c);\n\tstatus_message_clear(c);\n\n\tif (c->stdin_callback != NULL)\n\t\tc->stdin_callback(c, 1, c->stdin_callback_data);\n\n\tTAILQ_REMOVE(&clients, c, entry);\n\tlog_debug(\"lost client %p\", c);\n\n\t/*\n\t * If CLIENT_TERMINAL hasn't been set, then tty_init hasn't been called\n\t * and tty_free might close an unrelated fd.\n\t */\n\tif (c->flags & CLIENT_TERMINAL)\n\t\ttty_free(&c->tty);\n\tfree(c->ttyname);\n\tfree(c->term);\n\n\tevbuffer_free(c->stdin_data);\n\tevbuffer_free(c->stdout_data);\n\tif (c->stderr_data != c->stdout_data)\n\t\tevbuffer_free(c->stderr_data);\n\n\tif (event_initialized(&c->status_timer))\n\t\tevtimer_del(&c->status_timer);\n\tscreen_free(&c->status);\n\n\tfree(c->title);\n\tfree((void *)c->cwd);\n\n\tevtimer_del(&c->repeat_timer);\n\n\tkey_bindings_unref_table(c->keytable);\n\n\tif (event_initialized(&c->identify_timer))\n\t\tevtimer_del(&c->identify_timer);\n\n\tfree(c->message_string);\n\tif (event_initialized(&c->message_timer))\n\t\tevtimer_del(&c->message_timer);\n\tTAILQ_FOREACH_SAFE(msg, &c->message_log, entry, msg1) {\n\t\tfree(msg->msg);\n\t\tTAILQ_REMOVE(&c->message_log, msg, entry);\n\t\tfree(msg);\n\t}\n\n\tfree(c->prompt_string);\n\tfree(c->prompt_buffer);\n\n\tc->cmdq->flags |= CMD_Q_DEAD;\n\tcmdq_free(c->cmdq);\n\tc->cmdq = NULL;\n\n\tenviron_free(c->environ);\n\n\tproc_remove_peer(c->peer);\n\tc->peer = NULL;\n\n\tserver_client_unref(c);\n\n\tserver_add_accept(0); /* may be more file descriptors now */\n\n\trecalculate_sizes();\n\tserver_check_unattached();\n\tserver_update_socket();\n}\n\n/* Remove reference from a client. */\nvoid\nserver_client_unref(struct client *c)\n{\n\tlog_debug(\"unref client %p (%d references)\", c, c->references);\n\n\tc->references--;\n\tif (c->references == 0)\n\t\tevent_once(-1, EV_TIMEOUT, server_client_free, c, NULL);\n}\n\n/* Free dead client. */\nvoid\nserver_client_free(__unused int fd, __unused short events, void *arg)\n{\n\tstruct client\t*c = arg;\n\n\tlog_debug(\"free client %p (%d references)\", c, c->references);\n\n\tif (c->references == 0)\n\t\tfree(c);\n}\n\n/* Detach a client. */\nvoid\nserver_client_detach(struct client *c, enum msgtype msgtype)\n{\n\tstruct session\t*s = c->session;\n\n\tif (s == NULL)\n\t\treturn;\n\n\thooks_run(c->session->hooks, c, NULL, \"client-detached\");\n\tproc_send_s(c->peer, msgtype, s->name);\n}\n\n/* Check for mouse keys. */\nkey_code\nserver_client_check_mouse(struct client *c)\n{\n\tstruct session\t\t\t\t*s = c->session;\n\tstruct mouse_event\t\t\t*m = &c->tty.mouse;\n\tstruct window\t\t\t\t*w;\n\tstruct window_pane\t\t\t*wp;\n\tenum { NOTYPE, DOWN, UP, DRAG, WHEEL }\t type = NOTYPE;\n\tenum { NOWHERE, PANE, STATUS, BORDER }\t where = NOWHERE;\n\tu_int\t\t\t\t\t x, y, b;\n\tkey_code\t\t\t\t key;\n\n\tlog_debug(\"mouse %02x at %u,%u (last %u,%u) (%d)\", m->b, m->x, m->y,\n\t    m->lx, m->ly, c->tty.mouse_drag_flag);\n\n\t/* What type of event is this? */\n\tif (MOUSE_DRAG(m->b)) {\n\t\ttype = DRAG;\n\t\tif (c->tty.mouse_drag_flag) {\n\t\t\tx = m->x, y = m->y, b = m->b;\n\t\t\tlog_debug(\"drag update at %u,%u\", x, y);\n\t\t} else {\n\t\t\tx = m->lx, y = m->ly, b = m->lb;\n\t\t\tlog_debug(\"drag start at %u,%u\", x, y);\n\t\t}\n\t} else if (MOUSE_WHEEL(m->b)) {\n\t\ttype = WHEEL;\n\t\tx = m->x, y = m->y, b = m->b;\n\t\tlog_debug(\"wheel at %u,%u\", x, y);\n\t} else if (MOUSE_BUTTONS(m->b) == 3) {\n\t\ttype = UP;\n\t\tx = m->x, y = m->y, b = m->lb;\n\t\tlog_debug(\"up at %u,%u\", x, y);\n\t} else {\n\t\ttype = DOWN;\n\t\tx = m->x, y = m->y, b = m->b;\n\t\tlog_debug(\"down at %u,%u\", x, y);\n\t}\n\tif (type == NOTYPE)\n\t\treturn (KEYC_UNKNOWN);\n\n\t/* Always save the session. */\n\tm->s = s->id;\n\n\t/* Is this on the status line? */\n\tm->statusat = status_at_line(c);\n\tif (m->statusat != -1 && y == (u_int)m->statusat) {\n\t\tw = status_get_window_at(c, x);\n\t\tif (w == NULL)\n\t\t\treturn (KEYC_UNKNOWN);\n\t\tm->w = w->id;\n\t\twhere = STATUS;\n\t} else\n\t\tm->w = -1;\n\n\t/* Not on status line. Adjust position and check for border or pane. */\n\tif (where == NOWHERE) {\n\t\tif (m->statusat == 0 && y > 0)\n\t\t\ty--;\n\t\telse if (m->statusat > 0 && y >= (u_int)m->statusat)\n\t\t\ty = m->statusat - 1;\n\n\t\tTAILQ_FOREACH(wp, &s->curw->window->panes, entry) {\n\t\t\tif ((wp->xoff + wp->sx == x &&\n\t\t\t    wp->yoff <= 1 + y &&\n\t\t\t    wp->yoff + wp->sy >= y) ||\n\t\t\t    (wp->yoff + wp->sy == y &&\n\t\t\t    wp->xoff <= 1 + x &&\n\t\t\t    wp->xoff + wp->sx >= x))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (wp != NULL)\n\t\t\twhere = BORDER;\n\t\telse {\n\t\t\twp = window_get_active_at(s->curw->window, x, y);\n\t\t\tif (wp != NULL) {\n\t\t\t\twhere = PANE;\n\t\t\t\tlog_debug(\"mouse at %u,%u is on pane %%%u\",\n\t\t\t\t    x, y, wp->id);\n\t\t\t}\n\t\t}\n\t\tif (where == NOWHERE)\n\t\t\treturn (KEYC_UNKNOWN);\n\t\tm->wp = wp->id;\n\t\tm->w = wp->window->id;\n\t} else\n\t\tm->wp = -1;\n\n\t/* Stop dragging if needed. */\n\tif (type != DRAG && c->tty.mouse_drag_flag) {\n\t\tif (c->tty.mouse_drag_release != NULL)\n\t\t\tc->tty.mouse_drag_release(c, m);\n\n\t\tc->tty.mouse_drag_update = NULL;\n\t\tc->tty.mouse_drag_release = NULL;\n\n\t\t/*\n\t\t * End a mouse drag by passing a MouseDragEnd key corresponding\n\t\t * to the button that started the drag.\n\t\t */\n\t\tswitch (c->tty.mouse_drag_flag) {\n\t\tcase 1:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND1_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND1_STATUS;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND1_BORDER;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND2_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND2_STATUS;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND2_BORDER;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND3_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND3_STATUS;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_MOUSEDRAGEND3_BORDER;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tkey = KEYC_MOUSE;\n\t\t\tbreak;\n\t\t}\n\t\tc->tty.mouse_drag_flag = 0;\n\n\t\treturn (key);\n\t}\n\n\t/* Convert to a key binding. */\n\tkey = KEYC_UNKNOWN;\n\tswitch (type) {\n\tcase NOTYPE:\n\t\tbreak;\n\tcase DRAG:\n\t\tif (c->tty.mouse_drag_update != NULL)\n\t\t\tc->tty.mouse_drag_update(c, m);\n\t\telse {\n\t\t\tswitch (MOUSE_BUTTONS(b)) {\n\t\t\tcase 0:\n\t\t\t\tif (where == PANE)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG1_PANE;\n\t\t\t\tif (where == STATUS)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG1_STATUS;\n\t\t\t\tif (where == BORDER)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG1_BORDER;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tif (where == PANE)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG2_PANE;\n\t\t\t\tif (where == STATUS)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG2_STATUS;\n\t\t\t\tif (where == BORDER)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG2_BORDER;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tif (where == PANE)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG3_PANE;\n\t\t\t\tif (where == STATUS)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG3_STATUS;\n\t\t\t\tif (where == BORDER)\n\t\t\t\t\tkey = KEYC_MOUSEDRAG3_BORDER;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Begin a drag by setting the flag to a non-zero value that\n\t\t * corresponds to the mouse button in use.\n\t\t */\n\t\tc->tty.mouse_drag_flag = MOUSE_BUTTONS(b) + 1;\n\t\tbreak;\n\tcase WHEEL:\n\t\tif (MOUSE_BUTTONS(b) == MOUSE_WHEEL_UP) {\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_WHEELUP_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_WHEELUP_STATUS;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_WHEELUP_BORDER;\n\t\t} else {\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_WHEELDOWN_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_WHEELDOWN_STATUS;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_WHEELDOWN_BORDER;\n\t\t}\n\t\tbreak;\n\tcase UP:\n\t\tswitch (MOUSE_BUTTONS(b)) {\n\t\tcase 0:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_MOUSEUP1_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_MOUSEUP1_STATUS;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_MOUSEUP1_BORDER;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_MOUSEUP2_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_MOUSEUP2_STATUS;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_MOUSEUP2_BORDER;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_MOUSEUP3_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_MOUSEUP3_STATUS;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_MOUSEUP3_BORDER;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase DOWN:\n\t\tswitch (MOUSE_BUTTONS(b)) {\n\t\tcase 0:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_MOUSEDOWN1_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_MOUSEDOWN1_STATUS;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_MOUSEDOWN1_BORDER;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_MOUSEDOWN2_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_MOUSEDOWN2_STATUS;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_MOUSEDOWN2_BORDER;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (where == PANE)\n\t\t\t\tkey = KEYC_MOUSEDOWN3_PANE;\n\t\t\tif (where == STATUS)\n\t\t\t\tkey = KEYC_MOUSEDOWN3_STATUS;\n\t\t\tif (where == BORDER)\n\t\t\t\tkey = KEYC_MOUSEDOWN3_BORDER;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\tif (key == KEYC_UNKNOWN)\n\t\treturn (KEYC_UNKNOWN);\n\n\t/* Apply modifiers if any. */\n\tif (b & MOUSE_MASK_META)\n\t\tkey |= KEYC_ESCAPE;\n\tif (b & MOUSE_MASK_CTRL)\n\t\tkey |= KEYC_CTRL;\n\tif (b & MOUSE_MASK_SHIFT)\n\t\tkey |= KEYC_SHIFT;\n\n\treturn (key);\n}\n\n/* Is this fast enough to probably be a paste? */\nint\nserver_client_assume_paste(struct session *s)\n{\n\tstruct timeval\ttv;\n\tint\t\tt;\n\n\tif ((t = options_get_number(s->options, \"assume-paste-time\")) == 0)\n\t\treturn (0);\n\n\ttimersub(&s->activity_time, &s->last_activity_time, &tv);\n\tif (tv.tv_sec == 0 && tv.tv_usec < t * 1000) {\n\t\tlog_debug(\"session %s pasting (flag %d)\", s->name,\n\t\t    !!(s->flags & SESSION_PASTING));\n\t\tif (s->flags & SESSION_PASTING)\n\t\t\treturn (1);\n\t\ts->flags |= SESSION_PASTING;\n\t\treturn (0);\n\t}\n\tlog_debug(\"session %s not pasting\", s->name);\n\ts->flags &= ~SESSION_PASTING;\n\treturn (0);\n}\n\n/* Handle data key input from client. */\nvoid\nserver_client_handle_key(struct client *c, key_code key)\n{\n\tstruct mouse_event\t*m = &c->tty.mouse;\n\tstruct session\t\t*s = c->session;\n\tstruct window\t\t*w;\n\tstruct window_pane\t*wp;\n\tstruct timeval\t\t tv;\n\tstruct key_table\t*table;\n\tstruct key_binding\t bd_find, *bd;\n\tint\t\t\t xtimeout;\n\n\t/* Check the client is good to accept input. */\n\tif (s == NULL || (c->flags & (CLIENT_DEAD|CLIENT_SUSPENDED)) != 0)\n\t\treturn;\n\tw = s->curw->window;\n\n\t/* Update the activity timer. */\n\tif (gettimeofday(&c->activity_time, NULL) != 0)\n\t\tfatal(\"gettimeofday failed\");\n\tsession_update_activity(s, &c->activity_time);\n\n\t/* Number keys jump to pane in identify mode. */\n\tif (c->flags & CLIENT_IDENTIFY && key >= '0' && key <= '9') {\n\t\tif (c->flags & CLIENT_READONLY)\n\t\t\treturn;\n\t\twindow_unzoom(w);\n\t\twp = window_pane_at_index(w, key - '0');\n\t\tif (wp != NULL && window_pane_visible(wp))\n\t\t\twindow_set_active_pane(w, wp);\n\t\tserver_clear_identify(c);\n\t\treturn;\n\t}\n\n\t/* Handle status line. */\n\tif (!(c->flags & CLIENT_READONLY)) {\n#ifdef TMATE\n\t\tif (!(c->flags & CLIENT_FORCE_STATUS))\n#endif\n\t\tstatus_message_clear(c);\n\t\tserver_clear_identify(c);\n\t}\n\tif (c->prompt_string != NULL) {\n\t\tif (!(c->flags & CLIENT_READONLY))\n\t\t\tstatus_prompt_key(c, key);\n\t\treturn;\n\t}\n\n\t/* Check for mouse keys. */\n\tif (key == KEYC_MOUSE) {\n\t\tif (c->flags & CLIENT_READONLY)\n\t\t\treturn;\n\t\tkey = server_client_check_mouse(c);\n\t\tif (key == KEYC_UNKNOWN)\n\t\t\treturn;\n\n\t\tm->valid = 1;\n\t\tm->key = key;\n\n\t\tif (!options_get_number(s->options, \"mouse\"))\n\t\t\tgoto forward;\n\t} else\n\t\tm->valid = 0;\n\n\t/* Treat everything as a regular key when pasting is detected. */\n\tif (!KEYC_IS_MOUSE(key) && server_client_assume_paste(s))\n\t\tgoto forward;\n\nretry:\n\t/* Try to see if there is a key binding in the current table. */\n\tbd_find.key = key;\n\tbd = RB_FIND(key_bindings, &c->keytable->key_bindings, &bd_find);\n\tif (bd != NULL) {\n\t\t/*\n\t\t * Key was matched in this table. If currently repeating but a\n\t\t * non-repeating binding was found, stop repeating and try\n\t\t * again in the root table.\n\t\t */\n\t\tif ((c->flags & CLIENT_REPEAT) && !bd->can_repeat) {\n\t\t\tserver_client_set_key_table(c, NULL);\n\t\t\tc->flags &= ~CLIENT_REPEAT;\n\t\t\tserver_status_client(c);\n\t\t\tgoto retry;\n\t\t}\n\n\t\t/*\n\t\t * Take a reference to this table to make sure the key binding\n\t\t * doesn't disappear.\n\t\t */\n\t\ttable = c->keytable;\n\t\ttable->references++;\n\n\t\t/*\n\t\t * If this is a repeating key, start the timer. Otherwise reset\n\t\t * the client back to the root table.\n\t\t */\n\t\txtimeout = options_get_number(s->options, \"repeat-time\");\n\t\tif (xtimeout != 0 && bd->can_repeat) {\n\t\t\tc->flags |= CLIENT_REPEAT;\n\n\t\t\ttv.tv_sec = xtimeout / 1000;\n\t\t\ttv.tv_usec = (xtimeout % 1000) * 1000L;\n\t\t\tevtimer_del(&c->repeat_timer);\n\t\t\tevtimer_add(&c->repeat_timer, &tv);\n\t\t} else {\n\t\t\tc->flags &= ~CLIENT_REPEAT;\n\t\t\tserver_client_set_key_table(c, NULL);\n\t\t}\n\t\tserver_status_client(c);\n\n\t\t/* Dispatch the key binding. */\n\t\tkey_bindings_dispatch(bd, c, m);\n\t\tkey_bindings_unref_table(table);\n\t\treturn;\n\t}\n\n\t/*\n\t * No match in this table. If repeating, switch the client back to the\n\t * root table and try again.\n\t */\n\tif (c->flags & CLIENT_REPEAT) {\n\t\tserver_client_set_key_table(c, NULL);\n\t\tc->flags &= ~CLIENT_REPEAT;\n\t\tserver_status_client(c);\n\t\tgoto retry;\n\t}\n\n\t/* If no match and we're not in the root table, that's it. */\n\tif (strcmp(c->keytable->name, server_client_get_key_table(c)) != 0) {\n\t\tserver_client_set_key_table(c, NULL);\n\t\tserver_status_client(c);\n\t\treturn;\n\t}\n\n\t/*\n\t * No match, but in the root table. Prefix switches to the prefix table\n\t * and everything else is passed through.\n\t */\n\tif (key == (key_code)options_get_number(s->options, \"prefix\") ||\n\t    key == (key_code)options_get_number(s->options, \"prefix2\")) {\n\t\tserver_client_set_key_table(c, \"prefix\");\n\t\tserver_status_client(c);\n\t\treturn;\n\t}\n\nforward:\n\tif (c->flags & CLIENT_READONLY)\n\t\treturn;\n\tif (KEYC_IS_MOUSE(key))\n\t\twp = cmd_mouse_pane(m, NULL, NULL);\n\telse\n\t\twp = w->active;\n\tif (wp != NULL)\n\t\twindow_pane_key(wp, c, s, key, m);\n}\n\n/* Client functions that need to happen every loop. */\nvoid\nserver_client_loop(void)\n{\n\tstruct client\t\t*c;\n\tstruct window\t\t*w;\n\tstruct window_pane\t*wp;\n#ifdef TMATE\n\tint tmate_should_sync_layout = 0;\n#endif\n\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tserver_client_check_exit(c);\n\t\tif (c->session != NULL) {\n\t\t\tserver_client_check_redraw(c);\n\t\t\tserver_client_reset_state(c);\n\t\t}\n\t}\n\n\t/*\n\t * Any windows will have been redrawn as part of clients, so clear\n\t * their flags now. Also check pane focus and resize.\n\t */\n\tRB_FOREACH(w, windows, &windows) {\n#ifdef TMATE\n\t\tif (w->flags & WINDOW_REDRAW)\n\t\t\ttmate_should_sync_layout = 1;\n\t\tif (w->tmate_last_sync_active_pane != w->active)\n\t\t\ttmate_should_sync_layout = 1;\n#endif\n\n\t\tw->flags &= ~WINDOW_REDRAW;\n\t\tTAILQ_FOREACH(wp, &w->panes, entry) {\n\t\t\tif (wp->fd != -1) {\n\t\t\t\tserver_client_check_focus(wp);\n\t\t\t\tserver_client_check_resize(wp);\n\t\t\t}\n\t\t\twp->flags &= ~PANE_REDRAW;\n\t\t}\n\t\tcheck_window_name(w);\n\t}\n\n#ifdef TMATE\n\tif (tmate_should_sync_layout)\n\t\ttmate_sync_layout();\n#endif\n}\n\n/* Check if pane should be resized. */\nvoid\nserver_client_check_resize(struct window_pane *wp)\n{\n\tstruct winsize\tws;\n\n\tif (!(wp->flags & PANE_RESIZE))\n\t\treturn;\n\n\tmemset(&ws, 0, sizeof ws);\n\tws.ws_col = wp->sx;\n\tws.ws_row = wp->sy;\n\n\tif (ioctl(wp->fd, TIOCSWINSZ, &ws) == -1) {\n#ifdef __sun\n\t\t/*\n\t\t * Some versions of Solaris apparently can return an error when\n\t\t * resizing; don't know why this happens, can't reproduce on\n\t\t * other platforms and ignoring it doesn't seem to cause any\n\t\t * issues.\n\t\t */\n\t\tif (errno != EINVAL && errno != ENXIO)\n#endif\n\t\tfatal(\"ioctl failed\");\n\t}\n\n\twp->flags &= ~PANE_RESIZE;\n}\n\n/* Check whether pane should be focused. */\nvoid\nserver_client_check_focus(struct window_pane *wp)\n{\n\tstruct client\t*c;\n\tint\t\t push;\n\n\t/* Are focus events off? */\n\tif (!options_get_number(global_options, \"focus-events\"))\n\t\treturn;\n\n\t/* Do we need to push the focus state? */\n\tpush = wp->flags & PANE_FOCUSPUSH;\n\twp->flags &= ~PANE_FOCUSPUSH;\n\n\t/* If we don't care about focus, forget it. */\n\tif (!(wp->base.mode & MODE_FOCUSON))\n\t\treturn;\n\n\t/* If we're not the active pane in our window, we're not focused. */\n\tif (wp->window->active != wp)\n\t\tgoto not_focused;\n\n\t/* If we're in a mode, we're not focused. */\n\tif (wp->screen != &wp->base)\n\t\tgoto not_focused;\n\n\t/*\n\t * If our window is the current window in any focused clients with an\n\t * attached session, we're focused.\n\t */\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (c->session == NULL || !(c->flags & CLIENT_FOCUSED))\n\t\t\tcontinue;\n\t\tif (c->session->flags & SESSION_UNATTACHED)\n\t\t\tcontinue;\n\n\t\tif (c->session->curw->window == wp->window)\n\t\t\tgoto focused;\n\t}\n\nnot_focused:\n\tif (push || (wp->flags & PANE_FOCUSED))\n\t\tbufferevent_write(wp->event, \"\\033[O\", 3);\n\twp->flags &= ~PANE_FOCUSED;\n\treturn;\n\nfocused:\n\tif (push || !(wp->flags & PANE_FOCUSED))\n\t\tbufferevent_write(wp->event, \"\\033[I\", 3);\n\twp->flags |= PANE_FOCUSED;\n}\n\n/*\n * Update cursor position and mode settings. The scroll region and attributes\n * are cleared when idle (waiting for an event) as this is the most likely time\n * a user may interrupt tmux, for example with ~^Z in ssh(1). This is a\n * compromise between excessive resets and likelihood of an interrupt.\n *\n * tty_region/tty_reset/tty_update_mode already take care of not resetting\n * things that are already in their default state.\n */\nvoid\nserver_client_reset_state(struct client *c)\n{\n\tstruct window\t\t*w = c->session->curw->window;\n\tstruct window_pane\t*wp = w->active;\n\tstruct screen\t\t*s = wp->screen;\n\tstruct options\t\t*oo = c->session->options;\n\tint\t\t\t status, mode, o;\n\n\tif (c->flags & CLIENT_SUSPENDED)\n\t\treturn;\n\n\tif (c->flags & CLIENT_CONTROL)\n\t\treturn;\n\n\ttty_region(&c->tty, 0, c->tty.sy - 1);\n\n\tstatus = options_get_number(oo, \"status\");\n#ifdef TMATE\n\tif (c->flags & CLIENT_FORCE_STATUS)\n\t\tstatus = 1;\n#endif\n\tif (!window_pane_visible(wp) || wp->yoff + s->cy >= c->tty.sy - status)\n\t\ttty_cursor(&c->tty, 0, 0);\n\telse {\n\t\to = status && options_get_number(oo, \"status-position\") == 0;\n\t\ttty_cursor(&c->tty, wp->xoff + s->cx, o + wp->yoff + s->cy);\n\t}\n\n\t/*\n\t * Set mouse mode if requested. To support dragging, always use button\n\t * mode.\n\t */\n\tmode = s->mode;\n\tif (options_get_number(oo, \"mouse\"))\n\t\tmode = (mode & ~ALL_MOUSE_MODES) | MODE_MOUSE_BUTTON;\n\n\t/* Set the terminal mode and reset attributes. */\n\ttty_update_mode(&c->tty, mode, s);\n\ttty_reset(&c->tty);\n}\n\n/* Repeat time callback. */\nvoid\nserver_client_repeat_timer(__unused int fd, __unused short events, void *data)\n{\n\tstruct client\t*c = data;\n\n\tif (c->flags & CLIENT_REPEAT) {\n\t\tserver_client_set_key_table(c, NULL);\n\t\tc->flags &= ~CLIENT_REPEAT;\n\t\tserver_status_client(c);\n\t}\n}\n\n/* Check if client should be exited. */\nvoid\nserver_client_check_exit(struct client *c)\n{\n\tif (!(c->flags & CLIENT_EXIT))\n\t\treturn;\n\n\tif (EVBUFFER_LENGTH(c->stdin_data) != 0)\n\t\treturn;\n\tif (EVBUFFER_LENGTH(c->stdout_data) != 0)\n\t\treturn;\n\tif (EVBUFFER_LENGTH(c->stderr_data) != 0)\n\t\treturn;\n\n\tproc_send(c->peer, MSG_EXIT, -1, &c->retval, sizeof c->retval);\n\tc->flags &= ~CLIENT_EXIT;\n}\n\n/* Check for client redraws. */\nvoid\nserver_client_check_redraw(struct client *c)\n{\n\tstruct session\t\t*s = c->session;\n\tstruct tty\t\t*tty = &c->tty;\n\tstruct window_pane\t*wp;\n\tint\t\t \t flags, redraw;\n\n\tif (c->flags & (CLIENT_CONTROL|CLIENT_SUSPENDED))\n\t\treturn;\n\n\tif (c->flags & (CLIENT_REDRAW|CLIENT_STATUS)) {\n\t\tif (options_get_number(s->options, \"set-titles\"))\n\t\t\tserver_client_set_title(c);\n\n\t\tif (c->message_string != NULL)\n\t\t\tredraw = status_message_redraw(c);\n\t\telse if (c->prompt_string != NULL)\n\t\t\tredraw = status_prompt_redraw(c);\n\t\telse\n\t\t\tredraw = status_redraw(c);\n\t\tif (!redraw)\n\t\t\tc->flags &= ~CLIENT_STATUS;\n\t}\n\n\tflags = tty->flags & (TTY_FREEZE|TTY_NOCURSOR);\n\ttty->flags = (tty->flags & ~TTY_FREEZE) | TTY_NOCURSOR;\n\n\tif (c->flags & CLIENT_REDRAW) {\n\t\ttty_update_mode(tty, tty->mode, NULL);\n\t\tscreen_redraw_screen(c, 1, 1, 1);\n\t\tc->flags &= ~(CLIENT_STATUS|CLIENT_BORDERS);\n\t} else if (c->flags & CLIENT_REDRAWWINDOW) {\n\t\ttty_update_mode(tty, tty->mode, NULL);\n\t\tTAILQ_FOREACH(wp, &c->session->curw->window->panes, entry)\n\t\t\tscreen_redraw_pane(c, wp);\n\t\tc->flags &= ~CLIENT_REDRAWWINDOW;\n\t} else {\n\t\tTAILQ_FOREACH(wp, &c->session->curw->window->panes, entry) {\n\t\t\tif (wp->flags & PANE_REDRAW) {\n\t\t\t\ttty_update_mode(tty, tty->mode, NULL);\n\t\t\t\tscreen_redraw_pane(c, wp);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (c->flags & CLIENT_BORDERS) {\n\t\ttty_update_mode(tty, tty->mode, NULL);\n\t\tscreen_redraw_screen(c, 0, 0, 1);\n\t}\n\n\tif (c->flags & CLIENT_STATUS) {\n\t\ttty_update_mode(tty, tty->mode, NULL);\n\t\tscreen_redraw_screen(c, 0, 1, 0);\n\t}\n\n\ttty->flags = (tty->flags & ~(TTY_FREEZE|TTY_NOCURSOR)) | flags;\n\ttty_update_mode(tty, tty->mode, NULL);\n\n\tc->flags &= ~(CLIENT_REDRAW|CLIENT_BORDERS|CLIENT_STATUS|\n\t    CLIENT_STATUSFORCE);\n}\n\n/* Set client title. */\nvoid\nserver_client_set_title(struct client *c)\n{\n\tstruct session\t\t*s = c->session;\n\tconst char\t\t*template;\n\tchar\t\t\t*title;\n\tstruct format_tree\t*ft;\n\n\ttemplate = options_get_string(s->options, \"set-titles-string\");\n\n\tft = format_create(NULL, 0);\n\tformat_defaults(ft, c, NULL, NULL, NULL);\n\n\ttitle = format_expand_time(ft, template, time(NULL));\n\tif (c->title == NULL || strcmp(title, c->title) != 0) {\n\t\tfree(c->title);\n\t\tc->title = xstrdup(title);\n\t\ttty_set_title(&c->tty, c->title);\n\t}\n\tfree(title);\n\n\tformat_free(ft);\n}\n\n/* Dispatch message from client. */\nvoid\nserver_client_dispatch(struct imsg *imsg, void *arg)\n{\n\tstruct client\t\t*c = arg;\n\tstruct msg_stdin_data\t stdindata;\n\tconst char\t\t*data;\n\tssize_t\t\t\t datalen;\n\tstruct session\t\t*s;\n\n\tif (c->flags & CLIENT_DEAD)\n\t\treturn;\n\n\tif (imsg == NULL) {\n\t\tserver_client_lost(c);\n\t\treturn;\n\t}\n\n\tdata = imsg->data;\n\tdatalen = imsg->hdr.len - IMSG_HEADER_SIZE;\n\n\tswitch (imsg->hdr.type) {\n\tcase MSG_IDENTIFY_FLAGS:\n\tcase MSG_IDENTIFY_TERM:\n\tcase MSG_IDENTIFY_TTYNAME:\n\tcase MSG_IDENTIFY_CWD:\n\tcase MSG_IDENTIFY_STDIN:\n\tcase MSG_IDENTIFY_ENVIRON:\n\tcase MSG_IDENTIFY_CLIENTPID:\n\tcase MSG_IDENTIFY_DONE:\n\t\tserver_client_dispatch_identify(c, imsg);\n\t\tbreak;\n\tcase MSG_COMMAND:\n\t\tserver_client_dispatch_command(c, imsg);\n\t\tbreak;\n\tcase MSG_STDIN:\n\t\tif (datalen != sizeof stdindata)\n\t\t\tfatalx(\"bad MSG_STDIN size\");\n\t\tmemcpy(&stdindata, data, sizeof stdindata);\n\n\t\tif (c->stdin_callback == NULL)\n\t\t\tbreak;\n\t\tif (stdindata.size <= 0)\n\t\t\tc->stdin_closed = 1;\n\t\telse {\n\t\t\tevbuffer_add(c->stdin_data, stdindata.data,\n\t\t\t    stdindata.size);\n\t\t}\n\t\tc->stdin_callback(c, c->stdin_closed,\n\t\t    c->stdin_callback_data);\n\t\tbreak;\n\tcase MSG_RESIZE:\n\t\tif (datalen != 0)\n\t\t\tfatalx(\"bad MSG_RESIZE size\");\n\n\t\tif (c->flags & CLIENT_CONTROL)\n\t\t\tbreak;\n\t\tif (tty_resize(&c->tty)) {\n\t\t\trecalculate_sizes();\n\t\t\tserver_redraw_client(c);\n\t\t}\n\t\tif (c->session != NULL)\n\t\t\thooks_run(c->session->hooks, c, NULL, \"client-resized\");\n\t\tbreak;\n\tcase MSG_EXITING:\n\t\tif (datalen != 0)\n\t\t\tfatalx(\"bad MSG_EXITING size\");\n\n\t\tc->session = NULL;\n\t\ttty_close(&c->tty);\n\t\tproc_send(c->peer, MSG_EXITED, -1, NULL, 0);\n\t\tbreak;\n\tcase MSG_WAKEUP:\n\tcase MSG_UNLOCK:\n\t\tif (datalen != 0)\n\t\t\tfatalx(\"bad MSG_WAKEUP size\");\n\n\t\tif (!(c->flags & CLIENT_SUSPENDED))\n\t\t\tbreak;\n\t\tc->flags &= ~CLIENT_SUSPENDED;\n\n\t\tif (c->tty.fd == -1) /* exited in the meantime */\n\t\t\tbreak;\n\t\ts = c->session;\n\n\t\tif (gettimeofday(&c->activity_time, NULL) != 0)\n\t\t\tfatal(\"gettimeofday failed\");\n\t\tif (s != NULL)\n\t\t\tsession_update_activity(s, &c->activity_time);\n\n\t\ttty_start_tty(&c->tty);\n\t\tserver_redraw_client(c);\n\t\trecalculate_sizes();\n\t\tbreak;\n\tcase MSG_SHELL:\n\t\tif (datalen != 0)\n\t\t\tfatalx(\"bad MSG_SHELL size\");\n\n\t\tserver_client_dispatch_shell(c);\n\t\tbreak;\n\t}\n}\n\n/* Handle command message. */\nvoid\nserver_client_dispatch_command(struct client *c, struct imsg *imsg)\n{\n\tstruct msg_command_data\t  data;\n\tchar\t\t\t *buf;\n\tsize_t\t\t\t  len;\n\tstruct cmd_list\t\t *cmdlist = NULL;\n\tint\t\t\t  argc;\n\tchar\t\t\t**argv, *cause;\n\n\tif (imsg->hdr.len - IMSG_HEADER_SIZE < sizeof data)\n\t\tfatalx(\"bad MSG_COMMAND size\");\n\tmemcpy(&data, imsg->data, sizeof data);\n\n\tbuf = (char *)imsg->data + sizeof data;\n\tlen = imsg->hdr.len  - IMSG_HEADER_SIZE - sizeof data;\n\tif (len > 0 && buf[len - 1] != '\\0')\n\t\tfatalx(\"bad MSG_COMMAND string\");\n\n\targc = data.argc;\n\tif (cmd_unpack_argv(buf, len, argc, &argv) != 0) {\n\t\tcmdq_error(c->cmdq, \"command too long\");\n\t\tgoto error;\n\t}\n\n\tif (argc == 0) {\n\t\targc = 1;\n\t\targv = xcalloc(1, sizeof *argv);\n\t\t*argv = xstrdup(\"new-session\");\n\t}\n\n\tif ((cmdlist = cmd_list_parse(argc, argv, NULL, 0, &cause)) == NULL) {\n\t\tcmdq_error(c->cmdq, \"%s\", cause);\n\t\tcmd_free_argv(argc, argv);\n\t\tgoto error;\n\t}\n\tcmd_free_argv(argc, argv);\n\n\tif (c != cfg_client || cfg_finished)\n\t\tcmdq_run(c->cmdq, cmdlist, NULL);\n\telse\n\t\tcmdq_append(c->cmdq, cmdlist, NULL);\n\tcmd_list_free(cmdlist);\n\treturn;\n\nerror:\n\tif (cmdlist != NULL)\n\t\tcmd_list_free(cmdlist);\n\n\tc->flags |= CLIENT_EXIT;\n}\n\n/* Handle identify message. */\nvoid\nserver_client_dispatch_identify(struct client *c, struct imsg *imsg)\n{\n\tconst char\t*data, *home;\n\tsize_t\t \t datalen;\n\tint\t\t flags;\n\n\tif (c->flags & CLIENT_IDENTIFIED)\n\t\tfatalx(\"out-of-order identify message\");\n\n\tdata = imsg->data;\n\tdatalen = imsg->hdr.len - IMSG_HEADER_SIZE;\n\n\tswitch (imsg->hdr.type)\t{\n\tcase MSG_IDENTIFY_FLAGS:\n\t\tif (datalen != sizeof flags)\n\t\t\tfatalx(\"bad MSG_IDENTIFY_FLAGS size\");\n\t\tmemcpy(&flags, data, sizeof flags);\n\t\tc->flags |= flags;\n\t\tlog_debug(\"client %p IDENTIFY_FLAGS %#x\", c, flags);\n\t\tbreak;\n\tcase MSG_IDENTIFY_TERM:\n\t\tif (datalen == 0 || data[datalen - 1] != '\\0')\n\t\t\tfatalx(\"bad MSG_IDENTIFY_TERM string\");\n\t\tc->term = xstrdup(data);\n\t\tlog_debug(\"client %p IDENTIFY_TERM %s\", c, data);\n\t\tbreak;\n\tcase MSG_IDENTIFY_TTYNAME:\n\t\tif (datalen == 0 || data[datalen - 1] != '\\0')\n\t\t\tfatalx(\"bad MSG_IDENTIFY_TTYNAME string\");\n\t\tc->ttyname = xstrdup(data);\n\t\tlog_debug(\"client %p IDENTIFY_TTYNAME %s\", c, data);\n\t\tbreak;\n\tcase MSG_IDENTIFY_CWD:\n\t\tif (datalen == 0 || data[datalen - 1] != '\\0')\n\t\t\tfatalx(\"bad MSG_IDENTIFY_CWD string\");\n\t\tif (access(data, X_OK) == 0)\n\t\t\tc->cwd = xstrdup(data);\n\t\telse if ((home = find_home()) != NULL)\n\t\t\tc->cwd = xstrdup(home);\n\t\telse\n\t\t\tc->cwd = xstrdup(\"/\");\n\t\tlog_debug(\"client %p IDENTIFY_CWD %s\", c, data);\n\t\tbreak;\n\tcase MSG_IDENTIFY_STDIN:\n\t\tif (datalen != 0)\n\t\t\tfatalx(\"bad MSG_IDENTIFY_STDIN size\");\n\t\tc->fd = imsg->fd;\n\t\tlog_debug(\"client %p IDENTIFY_STDIN %d\", c, imsg->fd);\n\t\tbreak;\n\tcase MSG_IDENTIFY_ENVIRON:\n\t\tif (datalen == 0 || data[datalen - 1] != '\\0')\n\t\t\tfatalx(\"bad MSG_IDENTIFY_ENVIRON string\");\n\t\tif (strchr(data, '=') != NULL)\n\t\t\tenviron_put(c->environ, data);\n\t\tlog_debug(\"client %p IDENTIFY_ENVIRON %s\", c, data);\n\t\tbreak;\n\tcase MSG_IDENTIFY_CLIENTPID:\n\t\tif (datalen != sizeof c->pid)\n\t\t\tfatalx(\"bad MSG_IDENTIFY_CLIENTPID size\");\n\t\tmemcpy(&c->pid, data, sizeof c->pid);\n\t\tlog_debug(\"client %p IDENTIFY_CLIENTPID %ld\", c, (long)c->pid);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (imsg->hdr.type != MSG_IDENTIFY_DONE)\n\t\treturn;\n\tc->flags |= CLIENT_IDENTIFIED;\n\n#ifdef __CYGWIN__\n\tc->fd = open(c->ttyname, O_RDWR|O_NOCTTY);\n#endif\n\n\tif (c->flags & CLIENT_CONTROL) {\n\t\tc->stdin_callback = control_callback;\n\n\t\tevbuffer_free(c->stderr_data);\n\t\tc->stderr_data = c->stdout_data;\n\n\t\tif (c->flags & CLIENT_CONTROLCONTROL)\n\t\t\tevbuffer_add_printf(c->stdout_data, \"\\033P1000p\");\n\t\tproc_send(c->peer, MSG_STDIN, -1, NULL, 0);\n\n\t\tc->tty.fd = -1;\n\n\t\tclose(c->fd);\n\t\tc->fd = -1;\n\n\t\treturn;\n\t}\n\n\tif (c->fd == -1)\n\t\treturn;\n\tif (tty_init(&c->tty, c, c->fd, c->term) != 0) {\n\t\tclose(c->fd);\n\t\tc->fd = -1;\n\t\treturn;\n\t}\n\tif (c->flags & CLIENT_UTF8)\n\t\tc->tty.flags |= TTY_UTF8;\n\tif (c->flags & CLIENT_256COLOURS)\n\t\tc->tty.term_flags |= TERM_256COLOURS;\n\n\ttty_resize(&c->tty);\n\n\tif (!(c->flags & CLIENT_CONTROL))\n\t\tc->flags |= CLIENT_TERMINAL;\n}\n\n/* Handle shell message. */\nvoid\nserver_client_dispatch_shell(struct client *c)\n{\n\tconst char\t*shell;\n\n\tshell = options_get_string(global_s_options, \"default-shell\");\n\tif (*shell == '\\0' || areshell(shell))\n\t\tshell = _PATH_BSHELL;\n\tproc_send_s(c->peer, MSG_SHELL, shell);\n\n\tproc_kill_peer(c->peer);\n}\n\n/* Event callback to push more stdout data if any left. */\nstatic void\nserver_client_stdout_cb(__unused int fd, __unused short events, void *arg)\n{\n\tstruct client\t*c = arg;\n\n\tif (~c->flags & CLIENT_DEAD)\n\t\tserver_client_push_stdout(c);\n\tserver_client_unref(c);\n}\n\n/* Push stdout to client if possible. */\nvoid\nserver_client_push_stdout(struct client *c)\n{\n\tstruct msg_stdout_data data;\n\tsize_t                 sent, left;\n\n\tleft = EVBUFFER_LENGTH(c->stdout_data);\n\twhile (left != 0) {\n\t\tsent = left;\n\t\tif (sent > sizeof data.data)\n\t\t\tsent = sizeof data.data;\n\t\tmemcpy(data.data, EVBUFFER_DATA(c->stdout_data), sent);\n\t\tdata.size = sent;\n\n\t\tif (proc_send(c->peer, MSG_STDOUT, -1, &data, sizeof data) != 0)\n\t\t\tbreak;\n\t\tevbuffer_drain(c->stdout_data, sent);\n\n\t\tleft = EVBUFFER_LENGTH(c->stdout_data);\n\t\tlog_debug(\"%s: client %p, sent %zu, left %zu\", __func__, c,\n\t\t    sent, left);\n\t}\n\tif (left != 0) {\n\t\tc->references++;\n\t\tevent_once(-1, EV_TIMEOUT, server_client_stdout_cb, c, NULL);\n\t\tlog_debug(\"%s: client %p, queued\", __func__, c);\n\t}\n}\n\n/* Event callback to push more stderr data if any left. */\nstatic void\nserver_client_stderr_cb(__unused int fd, __unused short events, void *arg)\n{\n\tstruct client\t*c = arg;\n\n\tif (~c->flags & CLIENT_DEAD)\n\t\tserver_client_push_stderr(c);\n\tserver_client_unref(c);\n}\n\n/* Push stderr to client if possible. */\nvoid\nserver_client_push_stderr(struct client *c)\n{\n\tstruct msg_stderr_data data;\n\tsize_t                 sent, left;\n\n\tif (c->stderr_data == c->stdout_data) {\n\t\tserver_client_push_stdout(c);\n\t\treturn;\n\t}\n\n\tleft = EVBUFFER_LENGTH(c->stderr_data);\n\twhile (left != 0) {\n\t\tsent = left;\n\t\tif (sent > sizeof data.data)\n\t\t\tsent = sizeof data.data;\n\t\tmemcpy(data.data, EVBUFFER_DATA(c->stderr_data), sent);\n\t\tdata.size = sent;\n\n\t\tif (proc_send(c->peer, MSG_STDERR, -1, &data, sizeof data) != 0)\n\t\t\tbreak;\n\t\tevbuffer_drain(c->stderr_data, sent);\n\n\t\tleft = EVBUFFER_LENGTH(c->stderr_data);\n\t\tlog_debug(\"%s: client %p, sent %zu, left %zu\", __func__, c,\n\t\t    sent, left);\n\t}\n\tif (left != 0) {\n\t\tc->references++;\n\t\tevent_once(-1, EV_TIMEOUT, server_client_stderr_cb, c, NULL);\n\t\tlog_debug(\"%s: client %p, queued\", __func__, c);\n\t}\n}\n"
        },
        {
          "name": "server-fn.c",
          "type": "blob",
          "size": 10.576171875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/uio.h>\n\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\nstruct session *server_next_session(struct session *);\nvoid\t\tserver_callback_identify(int, short, void *);\n\nvoid\nserver_fill_environ(struct session *s, struct environ *env)\n{\n\tchar\t*term;\n\tu_int\t idx;\n\tlong\t pid;\n\n\tif (s != NULL) {\n\t\tterm = options_get_string(global_options, \"default-terminal\");\n\t\tenviron_set(env, \"TERM\", \"%s\", term);\n\n\t\tidx = s->id;\n\t} else\n\t\tidx = (u_int)-1;\n\tpid = getpid();\n\tenviron_set(env, \"TMUX\", \"%s,%ld,%u\", socket_path, pid, idx);\n}\n\nvoid\nserver_redraw_client(struct client *c)\n{\n\tc->flags |= CLIENT_REDRAW;\n}\n\nvoid\nserver_status_client(struct client *c)\n{\n\tc->flags |= CLIENT_STATUS;\n}\n\nvoid\nserver_redraw_session(struct session *s)\n{\n\tstruct client\t*c;\n\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (c->session == s)\n\t\t\tserver_redraw_client(c);\n\t}\n}\n\nvoid\nserver_redraw_session_group(struct session *s)\n{\n\tstruct session_group\t*sg;\n\n\tif ((sg = session_group_find(s)) == NULL)\n\t\tserver_redraw_session(s);\n\telse {\n\t\tTAILQ_FOREACH(s, &sg->sessions, gentry)\n\t\t\tserver_redraw_session(s);\n\t}\n}\n\nvoid\nserver_status_session(struct session *s)\n{\n\tstruct client\t*c;\n\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (c->session == s)\n\t\t\tserver_status_client(c);\n\t}\n}\n\nvoid\nserver_status_session_group(struct session *s)\n{\n\tstruct session_group\t*sg;\n\n\tif ((sg = session_group_find(s)) == NULL)\n\t\tserver_status_session(s);\n\telse {\n\t\tTAILQ_FOREACH(s, &sg->sessions, gentry)\n\t\t\tserver_status_session(s);\n\t}\n}\n\nvoid\nserver_redraw_window(struct window *w)\n{\n\tstruct client\t*c;\n\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (c->session != NULL && c->session->curw->window == w)\n\t\t\tserver_redraw_client(c);\n\t}\n\tw->flags |= WINDOW_REDRAW;\n}\n\nvoid\nserver_redraw_window_borders(struct window *w)\n{\n\tstruct client\t*c;\n\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (c->session != NULL && c->session->curw->window == w)\n\t\t\tc->flags |= CLIENT_BORDERS;\n\t}\n}\n\nvoid\nserver_status_window(struct window *w)\n{\n\tstruct session\t*s;\n\n\t/*\n\t * This is slightly different. We want to redraw the status line of any\n\t * clients containing this window rather than anywhere it is the\n\t * current window.\n\t */\n\n\tRB_FOREACH(s, sessions, &sessions) {\n\t\tif (session_has(s, w))\n\t\t\tserver_status_session(s);\n\t}\n}\n\nvoid\nserver_lock(void)\n{\n\tstruct client\t*c;\n\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (c->session != NULL)\n\t\t\tserver_lock_client(c);\n\t}\n}\n\nvoid\nserver_lock_session(struct session *s)\n{\n\tstruct client\t*c;\n\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (c->session == s)\n\t\t\tserver_lock_client(c);\n\t}\n}\n\nvoid\nserver_lock_client(struct client *c)\n{\n\tconst char\t*cmd;\n\n\tif (c->flags & CLIENT_CONTROL)\n\t\treturn;\n\n\tif (c->flags & CLIENT_SUSPENDED)\n\t\treturn;\n\n\tcmd = options_get_string(c->session->options, \"lock-command\");\n\tif (strlen(cmd) + 1 > MAX_IMSGSIZE - IMSG_HEADER_SIZE)\n\t\treturn;\n\n\ttty_stop_tty(&c->tty);\n\ttty_raw(&c->tty, tty_term_string(c->tty.term, TTYC_SMCUP));\n\ttty_raw(&c->tty, tty_term_string(c->tty.term, TTYC_CLEAR));\n\ttty_raw(&c->tty, tty_term_string(c->tty.term, TTYC_E3));\n\n\tc->flags |= CLIENT_SUSPENDED;\n\tproc_send_s(c->peer, MSG_LOCK, cmd);\n}\n\nvoid\nserver_kill_window(struct window *w)\n{\n\tstruct session\t\t*s, *next_s, *target_s;\n\tstruct session_group\t*sg;\n\tstruct winlink\t\t*wl;\n\n\tnext_s = RB_MIN(sessions, &sessions);\n\twhile (next_s != NULL) {\n\t\ts = next_s;\n\t\tnext_s = RB_NEXT(sessions, &sessions, s);\n\n\t\tif (!session_has(s, w))\n\t\t\tcontinue;\n\t\tserver_unzoom_window(w);\n\t\twhile ((wl = winlink_find_by_window(&s->windows, w)) != NULL) {\n\t\t\tif (session_detach(s, wl)) {\n\t\t\t\tserver_destroy_session_group(s);\n\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\tserver_redraw_session_group(s);\n\t\t}\n\n\t\tif (options_get_number(s->options, \"renumber-windows\")) {\n\t\t\tif ((sg = session_group_find(s)) != NULL) {\n\t\t\t\tTAILQ_FOREACH(target_s, &sg->sessions, gentry)\n\t\t\t\t\tsession_renumber_windows(target_s);\n\t\t\t} else\n\t\t\t\tsession_renumber_windows(s);\n\t\t}\n\t}\n\trecalculate_sizes();\n}\n\nint\nserver_link_window(struct session *src, struct winlink *srcwl,\n    struct session *dst, int dstidx, int killflag, int selectflag,\n    char **cause)\n{\n\tstruct winlink\t\t*dstwl;\n\tstruct session_group\t*srcsg, *dstsg;\n\n\tsrcsg = session_group_find(src);\n\tdstsg = session_group_find(dst);\n\tif (src != dst && srcsg != NULL && dstsg != NULL && srcsg == dstsg) {\n\t\txasprintf(cause, \"sessions are grouped\");\n\t\treturn (-1);\n\t}\n\n\tdstwl = NULL;\n\tif (dstidx != -1)\n\t\tdstwl = winlink_find_by_index(&dst->windows, dstidx);\n\tif (dstwl != NULL) {\n\t\tif (dstwl->window == srcwl->window) {\n\t\t\txasprintf(cause, \"same index: %d\", dstidx);\n\t\t\treturn (-1);\n\t\t}\n\t\tif (killflag) {\n\t\t\t/*\n\t\t\t * Can't use session_detach as it will destroy session\n\t\t\t * if this makes it empty.\n\t\t\t */\n\t\t\tnotify_window_unlinked(dst, dstwl->window);\n\t\t\tdstwl->flags &= ~WINLINK_ALERTFLAGS;\n\t\t\twinlink_stack_remove(&dst->lastw, dstwl);\n\t\t\twinlink_remove(&dst->windows, dstwl);\n\n\t\t\t/* Force select/redraw if current. */\n\t\t\tif (dstwl == dst->curw) {\n\t\t\t\tselectflag = 1;\n\t\t\t\tdst->curw = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dstidx == -1)\n\t\tdstidx = -1 - options_get_number(dst->options, \"base-index\");\n\tdstwl = session_attach(dst, srcwl->window, dstidx, cause);\n\tif (dstwl == NULL)\n\t\treturn (-1);\n\n\tif (selectflag)\n\t\tsession_select(dst, dstwl->idx);\n\tserver_redraw_session_group(dst);\n\n\treturn (0);\n}\n\nvoid\nserver_unlink_window(struct session *s, struct winlink *wl)\n{\n\tif (session_detach(s, wl))\n\t\tserver_destroy_session_group(s);\n\telse\n\t\tserver_redraw_session_group(s);\n}\n\nvoid\nserver_destroy_pane(struct window_pane *wp, int hooks)\n{\n\tstruct window\t\t*w = wp->window;\n\tint\t\t\t old_fd;\n\tstruct screen_write_ctx\t ctx;\n\tstruct grid_cell\t gc;\n\tstruct cmd_find_state\t fs;\n\n\told_fd = wp->fd;\n\tif (wp->fd != -1) {\n#ifdef HAVE_UTEMPTER\n\t\tutempter_remove_record(wp->fd);\n#endif\n\t\tbufferevent_free(wp->event);\n\t\tclose(wp->fd);\n\t\twp->fd = -1;\n\t}\n\n\tif (options_get_number(w->options, \"remain-on-exit\")) {\n\t\tif (old_fd == -1)\n\t\t\treturn;\n\t\tscreen_write_start(&ctx, wp, &wp->base);\n\t\tscreen_write_scrollregion(&ctx, 0, screen_size_y(ctx.s) - 1);\n\t\tscreen_write_cursormove(&ctx, 0, screen_size_y(ctx.s) - 1);\n\t\tscreen_write_linefeed(&ctx, 1);\n\t\tmemcpy(&gc, &grid_default_cell, sizeof gc);\n\t\tgc.attr |= GRID_ATTR_BRIGHT;\n\t\tscreen_write_puts(&ctx, &gc, \"Pane is dead\");\n\t\tscreen_write_stop(&ctx);\n\t\twp->flags |= PANE_REDRAW;\n\n\t\tif (hooks && cmd_find_from_pane(&fs, wp) == 0)\n\t\t\thooks_run(hooks_get(fs.s), NULL, &fs, \"pane-died\");\n\t\treturn;\n\t}\n\n\tserver_unzoom_window(w);\n\tlayout_close_pane(wp);\n\twindow_remove_pane(w, wp);\n\n\tif (hooks && cmd_find_from_window(&fs, w) == 0)\n\t\thooks_run(hooks_get(fs.s), NULL, &fs, \"pane-exited\");\n\n\tif (TAILQ_EMPTY(&w->panes))\n\t\tserver_kill_window(w);\n\telse\n\t\tserver_redraw_window(w);\n}\n\nvoid\nserver_destroy_session_group(struct session *s)\n{\n\tstruct session_group\t*sg;\n\tstruct session\t\t*s1;\n\n\tif ((sg = session_group_find(s)) == NULL)\n\t\tserver_destroy_session(s);\n\telse {\n\t\tTAILQ_FOREACH_SAFE(s, &sg->sessions, gentry, s1) {\n\t\t\tserver_destroy_session(s);\n\t\t\tsession_destroy(s);\n\t\t}\n\t}\n}\n\nstruct session *\nserver_next_session(struct session *s)\n{\n\tstruct session *s_loop, *s_out;\n\n\ts_out = NULL;\n\tRB_FOREACH(s_loop, sessions, &sessions) {\n\t\tif (s_loop == s)\n\t\t\tcontinue;\n\t\tif (s_out == NULL ||\n\t\t    timercmp(&s_loop->activity_time, &s_out->activity_time, <))\n\t\t\ts_out = s_loop;\n\t}\n\treturn (s_out);\n}\n\nvoid\nserver_destroy_session(struct session *s)\n{\n\tstruct client\t*c;\n\tstruct session\t*s_new;\n\n\tif (!options_get_number(s->options, \"detach-on-destroy\"))\n\t\ts_new = server_next_session(s);\n\telse\n\t\ts_new = NULL;\n\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (c->session != s)\n\t\t\tcontinue;\n\t\tif (s_new == NULL) {\n\t\t\tc->session = NULL;\n\t\t\tc->flags |= CLIENT_EXIT;\n\t\t} else {\n\t\t\tc->last_session = NULL;\n\t\t\tc->session = s_new;\n\t\t\tserver_client_set_key_table(c, NULL);\n\t\t\tstatus_timer_start(c);\n\t\t\tnotify_attached_session_changed(c);\n\t\t\tsession_update_activity(s_new, NULL);\n\t\t\tgettimeofday(&s_new->last_attached_time, NULL);\n\t\t\tserver_redraw_client(c);\n\t\t\talerts_check_session(s_new);\n\t\t}\n\t}\n\trecalculate_sizes();\n}\n\nvoid\nserver_check_unattached(void)\n{\n\tstruct session\t*s;\n\n\t/*\n\t * If any sessions are no longer attached and have destroy-unattached\n\t * set, collect them.\n\t */\n\tRB_FOREACH(s, sessions, &sessions) {\n\t\tif (!(s->flags & SESSION_UNATTACHED))\n\t\t\tcontinue;\n\t\tif (options_get_number (s->options, \"destroy-unattached\"))\n\t\t\tsession_destroy(s);\n\t}\n}\n\nvoid\nserver_set_identify(struct client *c)\n{\n\tstruct timeval\ttv;\n\tint\t\tdelay;\n\n\tdelay = options_get_number(c->session->options, \"display-panes-time\");\n\ttv.tv_sec = delay / 1000;\n\ttv.tv_usec = (delay % 1000) * 1000L;\n\n\tif (event_initialized(&c->identify_timer))\n\t\tevtimer_del(&c->identify_timer);\n\tevtimer_set(&c->identify_timer, server_callback_identify, c);\n\tevtimer_add(&c->identify_timer, &tv);\n\n\tc->flags |= CLIENT_IDENTIFY;\n\tc->tty.flags |= (TTY_FREEZE|TTY_NOCURSOR);\n\tserver_redraw_client(c);\n}\n\nvoid\nserver_clear_identify(struct client *c)\n{\n\tif (c->flags & CLIENT_IDENTIFY) {\n\t\tc->flags &= ~CLIENT_IDENTIFY;\n\t\tc->tty.flags &= ~(TTY_FREEZE|TTY_NOCURSOR);\n\t\tserver_redraw_client(c);\n\t}\n}\n\nvoid\nserver_callback_identify(__unused int fd, __unused short events, void *data)\n{\n\tstruct client\t*c = data;\n\n\tserver_clear_identify(c);\n}\n\n/* Set stdin callback. */\nint\nserver_set_stdin_callback(struct client *c, void (*cb)(struct client *, int,\n    void *), void *cb_data, char **cause)\n{\n\tif (c == NULL || c->session != NULL) {\n\t\t*cause = xstrdup(\"no client with stdin\");\n\t\treturn (-1);\n\t}\n\tif (c->flags & CLIENT_TERMINAL) {\n\t\t*cause = xstrdup(\"stdin is a tty\");\n\t\treturn (-1);\n\t}\n\tif (c->stdin_callback != NULL) {\n\t\t*cause = xstrdup(\"stdin in use\");\n\t\treturn (-1);\n\t}\n\n\tc->stdin_callback_data = cb_data;\n\tc->stdin_callback = cb;\n\n\tc->references++;\n\n\tif (c->stdin_closed)\n\t\tc->stdin_callback(c, 1, c->stdin_callback_data);\n\n\tproc_send(c->peer, MSG_STDIN, -1, NULL, 0);\n\n\treturn (0);\n}\n\nvoid\nserver_unzoom_window(struct window *w)\n{\n\tif (window_unzoom(w) == 0) {\n\t\tserver_redraw_window(w);\n\t\tserver_status_window(w);\n\t}\n}\n"
        },
        {
          "name": "server.c",
          "type": "blob",
          "size": 9.3857421875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n\n#include <errno.h>\n#include <event.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <termios.h>\n#include <time.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n#include \"tmate.h\"\n\n/*\n * Main server functions.\n */\n\nstruct clients\t\t clients;\n\nstruct tmuxproc\t\t*server_proc;\nint\t\t\t server_fd;\nint\t\t\t server_exit;\nstruct event\t\t server_ev_accept;\n\nstruct cmd_find_state\t marked_pane;\n\nint\tserver_create_socket(void);\nint\tserver_loop(void);\nint\tserver_should_exit(void);\nvoid\tserver_send_exit(void);\nvoid\tserver_accept(int, short, void *);\nvoid\tserver_signal(int);\nvoid\tserver_child_signal(void);\nvoid\tserver_child_exited(pid_t, int);\nvoid\tserver_child_stopped(pid_t, int);\n\n/* Set marked pane. */\nvoid\nserver_set_marked(struct session *s, struct winlink *wl, struct window_pane *wp)\n{\n\tcmd_find_clear_state(&marked_pane, NULL, 0);\n\tmarked_pane.s = s;\n\tmarked_pane.wl = wl;\n\tmarked_pane.w = wl->window;\n\tmarked_pane.wp = wp;\n}\n\n/* Clear marked pane. */\nvoid\nserver_clear_marked(void)\n{\n\tcmd_find_clear_state(&marked_pane, NULL, 0);\n}\n\n/* Is this the marked pane? */\nint\nserver_is_marked(struct session *s, struct winlink *wl, struct window_pane *wp)\n{\n\tif (s == NULL || wl == NULL || wp == NULL)\n\t\treturn (0);\n\tif (marked_pane.s != s || marked_pane.wl != wl)\n\t\treturn (0);\n\tif (marked_pane.wp != wp)\n\t\treturn (0);\n\treturn (server_check_marked());\n}\n\n/* Check if the marked pane is still valid. */\nint\nserver_check_marked(void)\n{\n\treturn (cmd_find_valid_state(&marked_pane));\n}\n\n/* Create server socket. */\nint\nserver_create_socket(void)\n{\n\tstruct sockaddr_un\tsa;\n\tsize_t\t\t\tsize;\n\tmode_t\t\t\tmask;\n\tint\t\t\tfd;\n\n\tmemset(&sa, 0, sizeof sa);\n\tsa.sun_family = AF_UNIX;\n\tsize = strlcpy(sa.sun_path, socket_path, sizeof sa.sun_path);\n\tif (size >= sizeof sa.sun_path) {\n\t\terrno = ENAMETOOLONG;\n\t\treturn (-1);\n\t}\n\tunlink(sa.sun_path);\n\n\tif ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)\n\t\treturn (-1);\n\n\tmask = umask(S_IXUSR|S_IXGRP|S_IRWXO);\n\tif (bind(fd, (struct sockaddr *) &sa, sizeof(sa)) == -1)\n\t\treturn (-1);\n\tumask(mask);\n\n\tif (listen(fd, 16) == -1)\n\t\treturn (-1);\n\tsetblocking(fd, 0);\n\n\treturn (fd);\n}\n\n#ifdef TMATE\nstatic void tmate_set_editor_mode(void)\n{\n\tswitch (options_get_number(global_s_options, \"status-keys\")) {\n\t\tcase MODEKEY_EMACS: tmate_exec_cmd_args(4, (const char *[]){\"set-option\", \"-g\", \"status-keys\", \"emacs\"}); break;\n\t\tcase MODEKEY_VI:    tmate_exec_cmd_args(4, (const char *[]){\"set-option\", \"-g\", \"status-keys\", \"vi\"}); break;\n\t}\n\n\tswitch (options_get_number(global_w_options, \"mode-keys\")) {\n\t\tcase MODEKEY_EMACS: tmate_exec_cmd_args(4, (const char *[]){\"set-window-option\", \"-g\", \"status-keys\", \"emacs\"}); break;\n\t\tcase MODEKEY_VI:    tmate_exec_cmd_args(4, (const char *[]){\"set-window-option\", \"-g\", \"status-keys\", \"vi\"}); break;\n\t}\n}\n#endif\n\n/* Fork new server. */\nint\nserver_start(struct event_base *base, int lockfd, char *lockfile)\n{\n\tint\tpair[2];\n\n\tif (!tmate_foreground)\n\t\tif (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, pair) != 0)\n\t\t\tfatal(\"socketpair failed\");\n\n\tserver_proc = proc_start(\"server\", base, 1, server_signal);\n\tif (server_proc == NULL) {\n\t\tclose(pair[1]);\n\t\treturn (pair[0]);\n\t}\n\n\tclose(pair[0]);\n\n\tif (log_get_level() > 3)\n\t\ttty_create_log();\n\n#ifdef __OpenBSD__\n\tif (pledge(\"stdio rpath wpath cpath fattr unix getpw recvfd proc exec \"\n\t    \"tty ps\", NULL) != 0)\n\t\tfatal(\"pledge failed\");\n#endif\n\n\tRB_INIT(&windows);\n\tRB_INIT(&all_window_panes);\n\tTAILQ_INIT(&clients);\n\tRB_INIT(&sessions);\n\tTAILQ_INIT(&session_groups);\n\tmode_key_init_trees();\n\n#ifdef TMATE\n\ttmate_session_init(base);\n#endif\n\n\tkey_bindings_init();\n\n\tgettimeofday(&start_time, NULL);\n\n\tserver_fd = server_create_socket();\n\tif (server_fd == -1)\n\t\tfatal(\"couldn't create socket\");\n\tserver_update_socket();\n\tif (!tmate_foreground)\n\t\tserver_client_create(pair[1]);\n\n\tif (lockfd >= 0) {\n\t\tunlink(lockfile);\n\t\tfree(lockfile);\n\t\tclose(lockfd);\n\t}\n\n#ifdef TMATE\n\ttmate_set_editor_mode();\n#endif\n\tstart_cfg();\n\n\tstatus_prompt_load_history();\n\n\tserver_add_accept(0);\n\n\tif (tmate_foreground)\n\t\trun_initial_client_cmd();\n\n\tproc_loop(server_proc, server_loop);\n\tstatus_prompt_save_history();\n#ifdef TMATE\n\tunlink(socket_path);\n#endif\n\n\texit(0);\n}\n\n/* Server loop callback. */\nint\nserver_loop(void)\n{\n\tstruct client\t*c;\n\n\tserver_client_loop();\n\n\tif (!options_get_number(global_options, \"exit-unattached\")) {\n\t\tif (!RB_EMPTY(&sessions))\n\t\t\treturn (0);\n\t}\n\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (c->session != NULL)\n\t\t\treturn (0);\n\t}\n\n\t/*\n\t * No attached clients therefore want to exit - flush any waiting\n\t * clients but don't actually exit until they've gone.\n\t */\n\tcmd_wait_for_flush();\n\tif (!TAILQ_EMPTY(&clients))\n\t\treturn (0);\n\n\treturn (1);\n}\n\n/* Exit the server by killing all clients and windows. */\nvoid\nserver_send_exit(void)\n{\n\tstruct client\t*c, *c1;\n\tstruct session\t*s, *s1;\n\n\tcmd_wait_for_flush();\n\n\tTAILQ_FOREACH_SAFE(c, &clients, entry, c1) {\n\t\tif (c->flags & CLIENT_SUSPENDED)\n\t\t\tserver_client_lost(c);\n\t\telse\n\t\t\tproc_send(c->peer, MSG_SHUTDOWN, -1, NULL, 0);\n\t\tc->session = NULL;\n\t}\n\n\tRB_FOREACH_SAFE(s, sessions, &sessions, s1)\n\t\tsession_destroy(s);\n}\n\n/* Update socket execute permissions based on whether sessions are attached. */\nvoid\nserver_update_socket(void)\n{\n\tstruct session\t*s;\n\tstatic int\t last = -1;\n\tint\t\t n, mode;\n\tstruct stat      sb;\n\n\tn = 0;\n\tRB_FOREACH(s, sessions, &sessions) {\n\t\tif (!(s->flags & SESSION_UNATTACHED)) {\n\t\t\tn++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (n != last) {\n\t\tlast = n;\n\n\t\tif (stat(socket_path, &sb) != 0)\n\t\t\treturn;\n\t\tmode = sb.st_mode;\n\t\tif (n != 0) {\n\t\t\tif (mode & S_IRUSR)\n\t\t\t\tmode |= S_IXUSR;\n\t\t\tif (mode & S_IRGRP)\n\t\t\t\tmode |= S_IXGRP;\n\t\t\tif (mode & S_IROTH)\n\t\t\t\tmode |= S_IXOTH;\n\t\t} else\n\t\t\tmode &= ~(S_IXUSR|S_IXGRP|S_IXOTH);\n\t\tchmod(socket_path, mode);\n\t}\n}\n\n/* Callback for server socket. */\nvoid\nserver_accept(int fd, short events, __unused void *data)\n{\n\tstruct sockaddr_storage\tsa;\n\tsocklen_t\t\tslen = sizeof sa;\n\tint\t\t\tnewfd;\n\n\tserver_add_accept(0);\n\tif (!(events & EV_READ))\n\t\treturn;\n\n\tnewfd = accept(fd, (struct sockaddr *) &sa, &slen);\n\tif (newfd == -1) {\n\t\tif (errno == EAGAIN || errno == EINTR || errno == ECONNABORTED)\n\t\t\treturn;\n\t\tif (errno == ENFILE || errno == EMFILE) {\n\t\t\t/* Delete and don't try again for 1 second. */\n\t\t\tserver_add_accept(1);\n\t\t\treturn;\n\t\t}\n\t\tfatal(\"accept failed\");\n\t}\n\tif (server_exit) {\n\t\tclose(newfd);\n\t\treturn;\n\t}\n\tserver_client_create(newfd);\n}\n\n/*\n * Add accept event. If timeout is nonzero, add as a timeout instead of a read\n * event - used to backoff when running out of file descriptors.\n */\nvoid\nserver_add_accept(int timeout)\n{\n\tstruct timeval tv = { timeout, 0 };\n\n\tif (event_initialized(&server_ev_accept))\n\t\tevent_del(&server_ev_accept);\n\n\tif (timeout == 0) {\n\t\tevent_set(&server_ev_accept, server_fd, EV_READ, server_accept,\n\t\t    NULL);\n\t\tevent_add(&server_ev_accept, NULL);\n\t} else {\n\t\tevent_set(&server_ev_accept, server_fd, EV_TIMEOUT,\n\t\t    server_accept, NULL);\n\t\tevent_add(&server_ev_accept, &tv);\n\t}\n}\n\n/* Signal handler. */\nvoid\nserver_signal(int sig)\n{\n\tint\tfd;\n\n\tswitch (sig) {\n\tcase SIGINT:\n\tcase SIGTERM:\n\t\tserver_exit = 1;\n\t\tserver_send_exit();\n\t\tbreak;\n\tcase SIGCHLD:\n\t\tserver_child_signal();\n\t\tbreak;\n\tcase SIGUSR1:\n\t\tevent_del(&server_ev_accept);\n\t\tfd = server_create_socket();\n\t\tif (fd != -1) {\n\t\t\tclose(server_fd);\n\t\t\tserver_fd = fd;\n\t\t\tserver_update_socket();\n\t\t}\n\t\tserver_add_accept(0);\n\t\tbreak;\n\t}\n}\n\n/* Handle SIGCHLD. */\nvoid\nserver_child_signal(void)\n{\n\tint\t status;\n\tpid_t\t pid;\n\n\tfor (;;) {\n\t\tswitch (pid = waitpid(WAIT_ANY, &status, WNOHANG|WUNTRACED)) {\n\t\tcase -1:\n\t\t\tif (errno == ECHILD)\n\t\t\t\treturn;\n\t\t\tfatal(\"waitpid failed\");\n\t\tcase 0:\n\t\t\treturn;\n\t\t}\n\t\tif (WIFSTOPPED(status))\n\t\t\tserver_child_stopped(pid, status);\n\t\telse if (WIFEXITED(status) || WIFSIGNALED(status))\n\t\t\tserver_child_exited(pid, status);\n\t}\n}\n\n/* Handle exited children. */\nvoid\nserver_child_exited(pid_t pid, int status)\n{\n\tstruct window\t\t*w, *w1;\n\tstruct window_pane\t*wp;\n\tstruct job\t\t*job;\n\n\tRB_FOREACH_SAFE(w, windows, &windows, w1) {\n\t\tTAILQ_FOREACH(wp, &w->panes, entry) {\n\t\t\tif (wp->pid == pid) {\n\t\t\t\twp->status = status;\n\t\t\t\tserver_destroy_pane(wp, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tLIST_FOREACH(job, &all_jobs, lentry) {\n\t\tif (pid == job->pid) {\n\t\t\tjob_died(job, status);\t/* might free job */\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/* Handle stopped children. */\nvoid\nserver_child_stopped(pid_t pid, int status)\n{\n\tstruct window\t\t*w;\n\tstruct window_pane\t*wp;\n\n\tif (WSTOPSIG(status) == SIGTTIN || WSTOPSIG(status) == SIGTTOU)\n\t\treturn;\n\n\tRB_FOREACH(w, windows, &windows) {\n\t\tTAILQ_FOREACH(wp, &w->panes, entry) {\n\t\t\tif (wp->pid == pid) {\n\t\t\t\tif (killpg(pid, SIGCONT) != 0)\n\t\t\t\t\tkill(pid, SIGCONT);\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "session.c",
          "type": "blob",
          "size": 17.8916015625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/time.h>\n\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <time.h>\n\n#include \"tmux.h\"\n#include \"tmate.h\"\n\nstruct sessions\tsessions;\nu_int\t\tnext_session_id;\nstruct session_groups session_groups;\n\nvoid\tsession_free(int, short, void *);\n\nvoid\tsession_lock_timer(int, short, void *);\n\nstruct winlink *session_next_alert(struct winlink *);\nstruct winlink *session_previous_alert(struct winlink *);\n\nRB_GENERATE(sessions, session, entry, session_cmp);\n\nint\nsession_cmp(struct session *s1, struct session *s2)\n{\n\treturn (strcmp(s1->name, s2->name));\n}\n\n/*\n * Find if session is still alive. This is true if it is still on the global\n * sessions list.\n */\nint\nsession_alive(struct session *s)\n{\n\tstruct session *s_loop;\n\n\tRB_FOREACH(s_loop, sessions, &sessions) {\n\t\tif (s_loop == s)\n\t\t\treturn (1);\n\t}\n\treturn (0);\n}\n\n/* Find session by name. */\nstruct session *\nsession_find(const char *name)\n{\n\tstruct session\ts;\n\n\ts.name = (char *) name;\n\treturn (RB_FIND(sessions, &sessions, &s));\n}\n\n/* Find session by id parsed from a string. */\nstruct session *\nsession_find_by_id_str(const char *s)\n{\n\tconst char\t*errstr;\n\tu_int\t\t id;\n\n\tif (*s != '$')\n\t\treturn (NULL);\n\n\tid = strtonum(s + 1, 0, UINT_MAX, &errstr);\n\tif (errstr != NULL)\n\t\treturn (NULL);\n\treturn (session_find_by_id(id));\n}\n\n/* Find session by id. */\nstruct session *\nsession_find_by_id(u_int id)\n{\n\tstruct session\t*s;\n\n\tRB_FOREACH(s, sessions, &sessions) {\n\t\tif (s->id == id)\n\t\t\treturn (s);\n\t}\n\treturn (NULL);\n}\n\n/* Create a new session. */\nstruct session *\nsession_create(const char *name, int argc, char **argv, const char *path,\n    const char *cwd, struct environ *env, struct termios *tio, int idx,\n    u_int sx, u_int sy, char **cause)\n{\n\tstruct session\t*s;\n\tstruct winlink\t*wl;\n\n#ifdef TMATE\n\tif (next_session_id != 0) {\n\t\txasprintf(cause, \"multi sessions is not supported with tmate\");\n\t\treturn NULL;\n\t}\n#endif\n\n\ts = xcalloc(1, sizeof *s);\n\ts->references = 1;\n\ts->flags = 0;\n\n\ts->cwd = xstrdup(cwd);\n\n\ts->curw = NULL;\n\tTAILQ_INIT(&s->lastw);\n\tRB_INIT(&s->windows);\n\n\ts->environ = environ_create();\n\tif (env != NULL)\n\t\tenviron_copy(env, s->environ);\n\n\ts->options = options_create(global_s_options);\n\ts->hooks = hooks_create(global_hooks);\n\n\ts->tio = NULL;\n\tif (tio != NULL) {\n\t\ts->tio = xmalloc(sizeof *s->tio);\n\t\tmemcpy(s->tio, tio, sizeof *s->tio);\n\t}\n\n\ts->sx = sx;\n\ts->sy = sy;\n\n\tif (name != NULL) {\n\t\ts->name = xstrdup(name);\n\t\ts->id = next_session_id++;\n\t} else {\n\t\ts->name = NULL;\n\t\tdo {\n\t\t\ts->id = next_session_id++;\n\t\t\tfree(s->name);\n\t\t\txasprintf(&s->name, \"%u\", s->id);\n\t\t} while (RB_FIND(sessions, &sessions, s) != NULL);\n\t}\n\tRB_INSERT(sessions, &sessions, s);\n\n\tlog_debug(\"new session %s $%u\", s->name, s->id);\n\n\tif (gettimeofday(&s->creation_time, NULL) != 0)\n\t\tfatal(\"gettimeofday failed\");\n\tsession_update_activity(s, &s->creation_time);\n\n\tif (argc >= 0) {\n\t\twl = session_new(s, NULL, argc, argv, path, cwd, idx, cause);\n\t\tif (wl == NULL) {\n\t\t\tsession_destroy(s);\n\t\t\treturn (NULL);\n\t\t}\n\t\tsession_select(s, RB_ROOT(&s->windows)->idx);\n\t}\n\n\tlog_debug(\"session %s created\", s->name);\n\tnotify_session_created(s);\n\n\treturn (s);\n}\n\n/* Remove a reference from a session. */\nvoid\nsession_unref(struct session *s)\n{\n\tlog_debug(\"session %s has %d references\", s->name, s->references);\n\n\ts->references--;\n\tif (s->references == 0)\n\t\tevent_once(-1, EV_TIMEOUT, session_free, s, NULL);\n}\n\n/* Free session. */\nvoid\nsession_free(__unused int fd, __unused short events, void *arg)\n{\n\tstruct session\t*s = arg;\n\n\tlog_debug(\"session %s freed (%d references)\", s->name, s->references);\n\n\tif (s->references == 0) {\n\t\tenviron_free(s->environ);\n\n\t\toptions_free(s->options);\n\t\thooks_free(s->hooks);\n\n\t\tfree(s->name);\n\t\tfree(s);\n\t}\n}\n\nstatic void maybe_restart_session(void)\n{\n\tint fg_restart = options_get_number(global_options, \"tmate-foreground-restart\");\n\tif (!fg_restart)\n\t\treturn;\n\n\t/*\n\t * throttle restarts. This is a blocking sleep. It's\n\t * simpler than using a timer, but fairly harmless\n\t * from a blocking perspective.\n\t */\n\tusleep(500*1000);\n\tnext_session_id = 0;\n\trun_initial_client_cmd();\n\n\ttmate_info(\"Session shell restarted\");\n\n\tstruct session *s;\n\ts = RB_MIN(sessions, &sessions);\n\tif (!s)\n\t\treturn;\n\n\tstruct window_pane *wp;\n\twp = s->curw->window->active;\n\twindow_pane_set_mode(wp, &window_copy_mode);\n\twindow_copy_init_for_output(wp);\n\twindow_copy_add(wp, \"%s\", \"Session shell restarted\");\n\twindow_copy_add(wp, \"%s\", \"Note: press the following sequence to disconnect from SSH: <Enter>~.\");\n}\n\n/* Destroy a session. */\nvoid\nsession_destroy(struct session *s)\n{\n\tstruct winlink\t*wl;\n\n\tlog_debug(\"session %s destroyed\", s->name);\n\n\tRB_REMOVE(sessions, &sessions, s);\n\tnotify_session_closed(s);\n\n\tfree(s->tio);\n\n\tif (event_initialized(&s->lock_timer))\n\t\tevent_del(&s->lock_timer);\n\n\tsession_group_remove(s);\n\n\twhile (!TAILQ_EMPTY(&s->lastw))\n\t\twinlink_stack_remove(&s->lastw, TAILQ_FIRST(&s->lastw));\n\twhile (!RB_EMPTY(&s->windows)) {\n\t\twl = RB_ROOT(&s->windows);\n\t\tnotify_window_unlinked(s, wl->window);\n\t\twinlink_remove(&s->windows, wl);\n\t}\n\n\tfree((void *)s->cwd);\n\n\tsession_unref(s);\n\n#ifdef TMATE\n\tif (tmate_foreground && !server_exit) {\n\t\tmaybe_restart_session();\n\t} else {\n\t\ttmate_info(\"Session closed\");\n\t\ttmate_write_fin();\n\t}\n#endif\n}\n\n/* Check a session name is valid: not empty and no colons or periods. */\nint\nsession_check_name(const char *name)\n{\n\treturn (*name != '\\0' && name[strcspn(name, \":.\")] == '\\0');\n}\n\n/* Lock session if it has timed out. */\nvoid\nsession_lock_timer(__unused int fd, __unused short events, void *arg)\n{\n\tstruct session\t*s = arg;\n\n\tif (s->flags & SESSION_UNATTACHED)\n\t\treturn;\n\n\tlog_debug(\"session %s locked, activity time %lld\", s->name,\n\t    (long long)s->activity_time.tv_sec);\n\n\tserver_lock_session(s);\n\trecalculate_sizes();\n}\n\n/* Update activity time. */\nvoid\nsession_update_activity(struct session *s, struct timeval *from)\n{\n\tstruct timeval\t*last = &s->last_activity_time;\n\tstruct timeval\t tv;\n\n\tmemcpy(last, &s->activity_time, sizeof *last);\n\tif (from == NULL)\n\t\tgettimeofday(&s->activity_time, NULL);\n\telse\n\t\tmemcpy(&s->activity_time, from, sizeof s->activity_time);\n\n\tlog_debug(\"session %s activity %lld.%06d (last %lld.%06d)\", s->name,\n\t    (long long)s->activity_time.tv_sec, (int)s->activity_time.tv_usec,\n\t    (long long)last->tv_sec, (int)last->tv_usec);\n\n\tif (evtimer_initialized(&s->lock_timer))\n\t\tevtimer_del(&s->lock_timer);\n\telse\n\t\tevtimer_set(&s->lock_timer, session_lock_timer, s);\n\n\tif (~s->flags & SESSION_UNATTACHED) {\n\t\ttimerclear(&tv);\n\t\ttv.tv_sec = options_get_number(s->options, \"lock-after-time\");\n\t\tif (tv.tv_sec != 0)\n\t\t\tevtimer_add(&s->lock_timer, &tv);\n\t}\n}\n\n/* Find the next usable session. */\nstruct session *\nsession_next_session(struct session *s)\n{\n\tstruct session *s2;\n\n\tif (RB_EMPTY(&sessions) || !session_alive(s))\n\t\treturn (NULL);\n\n\ts2 = RB_NEXT(sessions, &sessions, s);\n\tif (s2 == NULL)\n\t\ts2 = RB_MIN(sessions, &sessions);\n\tif (s2 == s)\n\t\treturn (NULL);\n\treturn (s2);\n}\n\n/* Find the previous usable session. */\nstruct session *\nsession_previous_session(struct session *s)\n{\n\tstruct session *s2;\n\n\tif (RB_EMPTY(&sessions) || !session_alive(s))\n\t\treturn (NULL);\n\n\ts2 = RB_PREV(sessions, &sessions, s);\n\tif (s2 == NULL)\n\t\ts2 = RB_MAX(sessions, &sessions);\n\tif (s2 == s)\n\t\treturn (NULL);\n\treturn (s2);\n}\n\n/* Create a new window on a session. */\nstruct winlink *\nsession_new(struct session *s, const char *name, int argc, char **argv,\n    const char *path, const char *cwd, int idx, char **cause)\n{\n\tstruct window\t*w;\n\tstruct winlink\t*wl;\n\tstruct environ\t*env;\n\tconst char\t*shell;\n\tu_int\t\t hlimit;\n\n\tif ((wl = winlink_add(&s->windows, idx)) == NULL) {\n\t\txasprintf(cause, \"index in use: %d\", idx);\n\t\treturn (NULL);\n\t}\n\n\tenv = environ_create();\n\tenviron_copy(global_environ, env);\n\tenviron_copy(s->environ, env);\n\tserver_fill_environ(s, env);\n\n\tshell = options_get_string(s->options, \"default-shell\");\n\tif (*shell == '\\0' || areshell(shell))\n\t\tshell = _PATH_BSHELL;\n\n\thlimit = options_get_number(s->options, \"history-limit\");\n\tw = window_create(name, argc, argv, path, shell, cwd, env, s->tio,\n\t    s->sx, s->sy, hlimit, cause);\n\tif (w == NULL) {\n\t\twinlink_remove(&s->windows, wl);\n\t\tenviron_free(env);\n\t\treturn (NULL);\n\t}\n\twinlink_set_window(wl, w);\n\tnotify_window_linked(s, w);\n\tenviron_free(env);\n\n\tif (options_get_number(s->options, \"set-remain-on-exit\"))\n\t\toptions_set_number(w->options, \"remain-on-exit\", 1);\n\n\tsession_group_synchronize_from(s);\n\treturn (wl);\n}\n\n/* Attach a window to a session. */\nstruct winlink *\nsession_attach(struct session *s, struct window *w, int idx, char **cause)\n{\n\tstruct winlink\t*wl;\n\n\tif ((wl = winlink_add(&s->windows, idx)) == NULL) {\n\t\txasprintf(cause, \"index in use: %d\", idx);\n\t\treturn (NULL);\n\t}\n\twinlink_set_window(wl, w);\n\tnotify_window_linked(s, w);\n\n#ifdef TMATE\n\ttmate_sync_layout();\n#endif\n\n\tsession_group_synchronize_from(s);\n\treturn (wl);\n}\n\n/* Detach a window from a session. */\nint\nsession_detach(struct session *s, struct winlink *wl)\n{\n\tif (s->curw == wl &&\n\t    session_last(s) != 0 && session_previous(s, 0) != 0)\n\t\tsession_next(s, 0);\n\n\twl->flags &= ~WINLINK_ALERTFLAGS;\n\tnotify_window_unlinked(s, wl->window);\n\twinlink_stack_remove(&s->lastw, wl);\n\twinlink_remove(&s->windows, wl);\n\n#ifdef TMATE\n\ttmate_sync_layout();\n#endif\n\n\tsession_group_synchronize_from(s);\n\tif (RB_EMPTY(&s->windows)) {\n\t\tsession_destroy(s);\n\t\treturn (1);\n\t}\n\treturn (0);\n}\n\n/* Return if session has window. */\nint\nsession_has(struct session *s, struct window *w)\n{\n\tstruct winlink\t*wl;\n\n\tRB_FOREACH(wl, winlinks, &s->windows) {\n\t\tif (wl->window == w)\n\t\t\treturn (1);\n\t}\n\treturn (0);\n}\n\n/*\n * Return 1 if a window is linked outside this session (not including session\n * groups). The window must be in this session!\n */\nint\nsession_is_linked(struct session *s, struct window *w)\n{\n\tstruct session_group\t*sg;\n\n\tif ((sg = session_group_find(s)) != NULL)\n\t\treturn (w->references != session_group_count(sg));\n\treturn (w->references != 1);\n}\n\nstruct winlink *\nsession_next_alert(struct winlink *wl)\n{\n\twhile (wl != NULL) {\n\t\tif (wl->flags & WINLINK_ALERTFLAGS)\n\t\t\tbreak;\n\t\twl = winlink_next(wl);\n\t}\n\treturn (wl);\n}\n\n/* Move session to next window. */\nint\nsession_next(struct session *s, int alert)\n{\n\tstruct winlink\t*wl;\n\n\tif (s->curw == NULL)\n\t\treturn (-1);\n\n\twl = winlink_next(s->curw);\n\tif (alert)\n\t\twl = session_next_alert(wl);\n\tif (wl == NULL) {\n\t\twl = RB_MIN(winlinks, &s->windows);\n\t\tif (alert && ((wl = session_next_alert(wl)) == NULL))\n\t\t\treturn (-1);\n\t}\n\treturn (session_set_current(s, wl));\n}\n\nstruct winlink *\nsession_previous_alert(struct winlink *wl)\n{\n\twhile (wl != NULL) {\n\t\tif (wl->flags & WINLINK_ALERTFLAGS)\n\t\t\tbreak;\n\t\twl = winlink_previous(wl);\n\t}\n\treturn (wl);\n}\n\n/* Move session to previous window. */\nint\nsession_previous(struct session *s, int alert)\n{\n\tstruct winlink\t*wl;\n\n\tif (s->curw == NULL)\n\t\treturn (-1);\n\n\twl = winlink_previous(s->curw);\n\tif (alert)\n\t\twl = session_previous_alert(wl);\n\tif (wl == NULL) {\n\t\twl = RB_MAX(winlinks, &s->windows);\n\t\tif (alert && (wl = session_previous_alert(wl)) == NULL)\n\t\t\treturn (-1);\n\t}\n\treturn (session_set_current(s, wl));\n}\n\n/* Move session to specific window. */\nint\nsession_select(struct session *s, int idx)\n{\n\tstruct winlink\t*wl;\n\n\twl = winlink_find_by_index(&s->windows, idx);\n\treturn (session_set_current(s, wl));\n}\n\n/* Move session to last used window. */\nint\nsession_last(struct session *s)\n{\n\tstruct winlink\t*wl;\n\n\twl = TAILQ_FIRST(&s->lastw);\n\tif (wl == NULL)\n\t\treturn (-1);\n\tif (wl == s->curw)\n\t\treturn (1);\n\n\treturn (session_set_current(s, wl));\n}\n\n/* Set current winlink to wl .*/\nint\nsession_set_current(struct session *s, struct winlink *wl)\n{\n\tif (wl == NULL)\n\t\treturn (-1);\n\tif (wl == s->curw)\n\t\treturn (1);\n\n\twinlink_stack_remove(&s->lastw, wl);\n\twinlink_stack_push(&s->lastw, s->curw);\n\ts->curw = wl;\n\twinlink_clear_flags(wl);\n\n#ifdef TMATE\n\ttmate_sync_layout();\n#endif\n\n\twindow_update_activity(wl->window);\n\treturn (0);\n}\n\n/* Find the session group containing a session. */\nstruct session_group *\nsession_group_find(struct session *target)\n{\n\tstruct session_group\t*sg;\n\tstruct session\t\t*s;\n\n\tTAILQ_FOREACH(sg, &session_groups, entry) {\n\t\tTAILQ_FOREACH(s, &sg->sessions, gentry) {\n\t\t\tif (s == target)\n\t\t\t\treturn (sg);\n\t\t}\n\t}\n\treturn (NULL);\n}\n\n/* Find session group index. */\nu_int\nsession_group_index(struct session_group *sg)\n{\n\tstruct session_group   *sg2;\n\tu_int\t\t\ti;\n\n\ti = 0;\n\tTAILQ_FOREACH(sg2, &session_groups, entry) {\n\t\tif (sg == sg2)\n\t\t\treturn (i);\n\t\ti++;\n\t}\n\n\tfatalx(\"session group not found\");\n\tfor(;;);\n}\n\n/*\n * Add a session to the session group containing target, creating it if\n * necessary.\n */\nvoid\nsession_group_add(struct session *target, struct session *s)\n{\n\tstruct session_group\t*sg;\n\n\tif ((sg = session_group_find(target)) == NULL) {\n\t\tsg = xmalloc(sizeof *sg);\n\t\tTAILQ_INSERT_TAIL(&session_groups, sg, entry);\n\t\tTAILQ_INIT(&sg->sessions);\n\t\tTAILQ_INSERT_TAIL(&sg->sessions, target, gentry);\n\t}\n\tTAILQ_INSERT_TAIL(&sg->sessions, s, gentry);\n}\n\n/* Remove a session from its group and destroy the group if empty. */\nvoid\nsession_group_remove(struct session *s)\n{\n\tstruct session_group\t*sg;\n\n\tif ((sg = session_group_find(s)) == NULL)\n\t\treturn;\n\tTAILQ_REMOVE(&sg->sessions, s, gentry);\n\tif (TAILQ_NEXT(TAILQ_FIRST(&sg->sessions), gentry) == NULL)\n\t\tTAILQ_REMOVE(&sg->sessions, TAILQ_FIRST(&sg->sessions), gentry);\n\tif (TAILQ_EMPTY(&sg->sessions)) {\n\t\tTAILQ_REMOVE(&session_groups, sg, entry);\n\t\tfree(sg);\n\t}\n}\n\n/* Count number of sessions in session group. */\nu_int\nsession_group_count(struct session_group *sg)\n{\n\tstruct session\t*s;\n\tu_int\t\t n;\n\n\tn = 0;\n\tTAILQ_FOREACH(s, &sg->sessions, gentry)\n\t    n++;\n\treturn (n);\n}\n\n/* Synchronize a session to its session group. */\nvoid\nsession_group_synchronize_to(struct session *s)\n{\n\tstruct session_group\t*sg;\n\tstruct session\t\t*target;\n\n\tif ((sg = session_group_find(s)) == NULL)\n\t\treturn;\n\n\ttarget = NULL;\n\tTAILQ_FOREACH(target, &sg->sessions, gentry) {\n\t\tif (target != s)\n\t\t\tbreak;\n\t}\n\tsession_group_synchronize1(target, s);\n}\n\n/* Synchronize a session group to a session. */\nvoid\nsession_group_synchronize_from(struct session *target)\n{\n\tstruct session_group\t*sg;\n\tstruct session\t\t*s;\n\n\tif ((sg = session_group_find(target)) == NULL)\n\t\treturn;\n\n\tTAILQ_FOREACH(s, &sg->sessions, gentry) {\n\t\tif (s != target)\n\t\t\tsession_group_synchronize1(target, s);\n\t}\n}\n\n/*\n * Synchronize a session with a target session. This means destroying all\n * winlinks then recreating them, then updating the current window, last window\n * stack and alerts.\n */\nvoid\nsession_group_synchronize1(struct session *target, struct session *s)\n{\n\tstruct winlinks\t\t old_windows, *ww;\n\tstruct winlink_stack\t old_lastw;\n\tstruct winlink\t\t*wl, *wl2;\n\n\t/* Don't do anything if the session is empty (it'll be destroyed). */\n\tww = &target->windows;\n\tif (RB_EMPTY(ww))\n\t\treturn;\n\n\t/* If the current window has vanished, move to the next now. */\n\tif (s->curw != NULL &&\n\t    winlink_find_by_index(ww, s->curw->idx) == NULL &&\n\t    session_last(s) != 0 && session_previous(s, 0) != 0)\n\t\tsession_next(s, 0);\n\n\t/* Save the old pointer and reset it. */\n\tmemcpy(&old_windows, &s->windows, sizeof old_windows);\n\tRB_INIT(&s->windows);\n\n\t/* Link all the windows from the target. */\n\tRB_FOREACH(wl, winlinks, ww) {\n\t\twl2 = winlink_add(&s->windows, wl->idx);\n\t\twinlink_set_window(wl2, wl->window);\n\t\tnotify_window_linked(s, wl2->window);\n\t\twl2->flags |= wl->flags & WINLINK_ALERTFLAGS;\n\t}\n\n\t/* Fix up the current window. */\n\tif (s->curw != NULL)\n\t\ts->curw = winlink_find_by_index(&s->windows, s->curw->idx);\n\telse\n\t\ts->curw = winlink_find_by_index(&s->windows, target->curw->idx);\n\n\t/* Fix up the last window stack. */\n\tmemcpy(&old_lastw, &s->lastw, sizeof old_lastw);\n\tTAILQ_INIT(&s->lastw);\n\tTAILQ_FOREACH(wl, &old_lastw, sentry) {\n\t\twl2 = winlink_find_by_index(&s->windows, wl->idx);\n\t\tif (wl2 != NULL)\n\t\t\tTAILQ_INSERT_TAIL(&s->lastw, wl2, sentry);\n\t}\n\n\t/* Then free the old winlinks list. */\n\twhile (!RB_EMPTY(&old_windows)) {\n\t\twl = RB_ROOT(&old_windows);\n\t\twl2 = winlink_find_by_window_id(&s->windows, wl->window->id);\n\t\tif (wl2 == NULL)\n\t\t\tnotify_window_unlinked(s, wl->window);\n\t\twinlink_remove(&old_windows, wl);\n\t}\n}\n\n/* Renumber the windows across winlinks attached to a specific session. */\nvoid\nsession_renumber_windows(struct session *s)\n{\n\tstruct winlink\t\t*wl, *wl1, *wl_new;\n\tstruct winlinks\t\t old_wins;\n\tstruct winlink_stack\t old_lastw;\n\tint\t\t\t new_idx, new_curw_idx;\n\n\t/* Save and replace old window list. */\n\tmemcpy(&old_wins, &s->windows, sizeof old_wins);\n\tRB_INIT(&s->windows);\n\n\t/* Start renumbering from the base-index if it's set. */\n\tnew_idx = options_get_number(s->options, \"base-index\");\n\tnew_curw_idx = 0;\n\n\t/* Go through the winlinks and assign new indexes. */\n\tRB_FOREACH(wl, winlinks, &old_wins) {\n\t\twl_new = winlink_add(&s->windows, new_idx);\n\t\twinlink_set_window(wl_new, wl->window);\n\t\twl_new->flags |= wl->flags & WINLINK_ALERTFLAGS;\n\n\t\tif (wl == s->curw)\n\t\t\tnew_curw_idx = wl_new->idx;\n\n\t\tnew_idx++;\n\t}\n\n\t/* Fix the stack of last windows now. */\n\tmemcpy(&old_lastw, &s->lastw, sizeof old_lastw);\n\tTAILQ_INIT(&s->lastw);\n\tTAILQ_FOREACH(wl, &old_lastw, sentry) {\n\t\twl_new = winlink_find_by_window(&s->windows, wl->window);\n\t\tif (wl_new != NULL)\n\t\t\tTAILQ_INSERT_TAIL(&s->lastw, wl_new, sentry);\n\t}\n\n\t/* Set the current window. */\n\ts->curw = winlink_find_by_index(&s->windows, new_curw_idx);\n\n\t/* Free the old winlinks (reducing window references too). */\n\tRB_FOREACH_SAFE(wl, winlinks, &old_wins, wl1)\n\t\twinlink_remove(&old_wins, wl);\n}\n"
        },
        {
          "name": "signal.c",
          "type": "blob",
          "size": 3.5107421875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n * Copyright (c) 2010 Romain Francoise <rfrancoise@debian.org>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <string.h>\n#include <signal.h>\n\n#include \"tmux.h\"\n\nstruct event\tev_sigint;\nstruct event\tev_sighup;\nstruct event\tev_sigchld;\nstruct event\tev_sigcont;\nstruct event\tev_sigterm;\nstruct event\tev_sigusr1;\nstruct event\tev_sigwinch;\n\nvoid\nset_signals(void (*handler)(int, short, void *), void *arg)\n{\n\tstruct sigaction\tsigact;\n\n\tmemset(&sigact, 0, sizeof sigact);\n\tsigemptyset(&sigact.sa_mask);\n\tsigact.sa_flags = SA_RESTART;\n\tsigact.sa_handler = SIG_IGN;\n#ifndef TMATE\n\tif (sigaction(SIGINT, &sigact, NULL) != 0)\n\t\tfatal(\"sigaction failed\");\n#endif\n\tif (sigaction(SIGPIPE, &sigact, NULL) != 0)\n\t\tfatal(\"sigaction failed\");\n\tif (sigaction(SIGUSR2, &sigact, NULL) != 0)\n\t\tfatal(\"sigaction failed\");\n#ifndef TMATE\n\tif (sigaction(SIGTSTP, &sigact, NULL) != 0)\n\t\tfatal(\"sigaction failed\");\n#endif\n\n#ifdef TMATE\n\tsignal_set(&ev_sigint, SIGINT, handler, arg);\n\tsignal_add(&ev_sigint, NULL);\n#endif\n\tsignal_set(&ev_sighup, SIGHUP, handler, arg);\n\tsignal_add(&ev_sighup, NULL);\n\tsignal_set(&ev_sigchld, SIGCHLD, handler, arg);\n\tsignal_add(&ev_sigchld, NULL);\n\tsignal_set(&ev_sigcont, SIGCONT, handler, arg);\n\tsignal_add(&ev_sigcont, NULL);\n\tsignal_set(&ev_sigterm, SIGTERM, handler, arg);\n\tsignal_add(&ev_sigterm, NULL);\n\tsignal_set(&ev_sigusr1, SIGUSR1, handler, arg);\n\tsignal_add(&ev_sigusr1, NULL);\n\tsignal_set(&ev_sigwinch, SIGWINCH, handler, arg);\n\tsignal_add(&ev_sigwinch, NULL);\n}\n\nvoid\nclear_signals(int after_fork)\n{\n\tstruct sigaction\tsigact;\n\n\tmemset(&sigact, 0, sizeof sigact);\n\tsigemptyset(&sigact.sa_mask);\n\tsigact.sa_flags = SA_RESTART;\n\tsigact.sa_handler = SIG_DFL;\n#ifndef TMATE\n\tif (sigaction(SIGINT, &sigact, NULL) != 0)\n\t\tfatal(\"sigaction failed\");\n#endif\n\tif (sigaction(SIGPIPE, &sigact, NULL) != 0)\n\t\tfatal(\"sigaction failed\");\n\tif (sigaction(SIGUSR2, &sigact, NULL) != 0)\n\t\tfatal(\"sigaction failed\");\n#ifndef TMATE\n\tif (sigaction(SIGTSTP, &sigact, NULL) != 0)\n\t\tfatal(\"sigaction failed\");\n#endif\n\n\tif (after_fork) {\n#ifdef TMATE\n\t\tif (sigaction(SIGINT, &sigact, NULL) != 0)\n\t\t\tfatal(\"sigaction failed\");\n#endif\n\t\tif (sigaction(SIGHUP, &sigact, NULL) != 0)\n\t\t\tfatal(\"sigaction failed\");\n\t\tif (sigaction(SIGCHLD, &sigact, NULL) != 0)\n\t\t\tfatal(\"sigaction failed\");\n\t\tif (sigaction(SIGCONT, &sigact, NULL) != 0)\n\t\t\tfatal(\"sigaction failed\");\n\t\tif (sigaction(SIGTERM, &sigact, NULL) != 0)\n\t\t\tfatal(\"sigaction failed\");\n\t\tif (sigaction(SIGUSR1, &sigact, NULL) != 0)\n\t\t\tfatal(\"sigaction failed\");\n\t\tif (sigaction(SIGWINCH, &sigact, NULL) != 0)\n\t\t\tfatal(\"sigaction failed\");\n\t} else {\n\t\tevent_del(&ev_sigint);\n\t\tevent_del(&ev_sighup);\n\t\tevent_del(&ev_sigchld);\n\t\tevent_del(&ev_sigcont);\n\t\tevent_del(&ev_sigterm);\n\t\tevent_del(&ev_sigusr1);\n\t\tevent_del(&ev_sigwinch);\n\t}\n}\n"
        },
        {
          "name": "status.c",
          "type": "blob",
          "size": 33.361328125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/time.h>\n\n#include <errno.h>\n#include <limits.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n#include \"tmate.h\"\n\nchar   *status_redraw_get_left(struct client *, time_t, struct grid_cell *,\n\t    size_t *);\nchar   *status_redraw_get_right(struct client *, time_t, struct grid_cell *,\n\t    size_t *);\nchar   *status_print(struct client *, struct winlink *, time_t,\n\t    struct grid_cell *);\nchar   *status_replace(struct client *, struct winlink *, const char *, time_t);\nvoid\tstatus_message_callback(int, short, void *);\nvoid\tstatus_timer_callback(int, short, void *);\n\nconst char *status_prompt_up_history(u_int *);\nconst char *status_prompt_down_history(u_int *);\nvoid\tstatus_prompt_add_history(const char *);\n\nconst char **status_prompt_complete_list(u_int *, const char *);\nchar   *status_prompt_complete_prefix(const char **, u_int);\nchar   *status_prompt_complete(struct session *, const char *);\n\nchar   *status_prompt_find_history_file(void);\n\n/* Status prompt history. */\n#define PROMPT_HISTORY 100\nchar\t**status_prompt_hlist;\nu_int\t  status_prompt_hsize;\n\n/* Find the history file to load/save from/to. */\nchar *\nstatus_prompt_find_history_file(void)\n{\n\tconst char\t*home, *history_file;\n\tchar\t\t*path;\n\n\thistory_file = options_get_string(global_options, \"history-file\");\n\tif (*history_file == '\\0')\n\t\treturn (NULL);\n\tif (*history_file == '/')\n\t\treturn (xstrdup(history_file));\n\n\tif (history_file[0] != '~' || history_file[1] != '/')\n\t\treturn (NULL);\n\tif ((home = find_home()) == NULL)\n\t\treturn (NULL);\n\txasprintf(&path, \"%s%s\", home, history_file + 1);\n\treturn (path);\n}\n\n/* Load status prompt history from file. */\nvoid\nstatus_prompt_load_history(void)\n{\n\tFILE\t*f;\n\tchar\t*history_file, *line, *tmp;\n\tsize_t\t length;\n\n\tif ((history_file = status_prompt_find_history_file()) == NULL)\n\t\treturn;\n\tlog_debug(\"loading history from %s\", history_file);\n\n\tf = fopen(history_file, \"r\");\n\tif (f == NULL) {\n\t\tlog_debug(\"%s: %s\", history_file, strerror(errno));\n\t\tfree(history_file);\n\t\treturn;\n\t}\n\tfree(history_file);\n\n\tfor (;;) {\n\t\tif ((line = fgetln(f, &length)) == NULL)\n\t\t\tbreak;\n\n\t\tif (length > 0) {\n\t\t\tif (line[length - 1] == '\\n') {\n\t\t\t\tline[length - 1] = '\\0';\n\t\t\t\tstatus_prompt_add_history(line);\n\t\t\t} else {\n\t\t\t\ttmp = xmalloc(length + 1);\n\t\t\t\tmemcpy(tmp, line, length);\n\t\t\t\ttmp[length] = '\\0';\n\t\t\t\tstatus_prompt_add_history(tmp);\n\t\t\t\tfree(tmp);\n\t\t\t}\n\t\t}\n\t}\n\tfclose(f);\n}\n\n/* Save status prompt history to file. */\nvoid\nstatus_prompt_save_history(void)\n{\n\tFILE\t*f;\n\tu_int\t i;\n\tchar\t*history_file;\n\n\tif ((history_file = status_prompt_find_history_file()) == NULL)\n\t\treturn;\n\tlog_debug(\"saving history to %s\", history_file);\n\n\tf = fopen(history_file, \"w\");\n\tif (f == NULL) {\n\t\tlog_debug(\"%s: %s\", history_file, strerror(errno));\n\t\tfree(history_file);\n\t\treturn;\n\t}\n\tfree(history_file);\n\n\tfor (i = 0; i < status_prompt_hsize; i++) {\n\t\tfputs(status_prompt_hlist[i], f);\n\t\tfputc('\\n', f);\n\t}\n\tfclose(f);\n\n}\n\n/* Status timer callback. */\nvoid\nstatus_timer_callback(__unused int fd, __unused short events, void *arg)\n{\n\tstruct client\t*c = arg;\n\tstruct session\t*s = c->session;\n\tstruct timeval\t tv;\n\n\tevtimer_del(&c->status_timer);\n\n\tif (s == NULL)\n\t\treturn;\n\n\tif (c->message_string == NULL && c->prompt_string == NULL)\n\t\tc->flags |= CLIENT_STATUS;\n\n\ttimerclear(&tv);\n\ttv.tv_sec = options_get_number(s->options, \"status-interval\");\n\n\tif (tv.tv_sec != 0)\n\t\tevtimer_add(&c->status_timer, &tv);\n\tlog_debug(\"client %p, status interval %d\", c, (int)tv.tv_sec);\n}\n\n/* Start status timer for client. */\nvoid\nstatus_timer_start(struct client *c)\n{\n\tstruct session\t*s = c->session;\n\n\tif (event_initialized(&c->status_timer))\n\t\tevtimer_del(&c->status_timer);\n\telse\n\t\tevtimer_set(&c->status_timer, status_timer_callback, c);\n\n\tif (s != NULL && options_get_number(s->options, \"status\"))\n\t\tstatus_timer_callback(-1, 0, c);\n}\n\n/* Start status timer for all clients. */\nvoid\nstatus_timer_start_all(void)\n{\n\tstruct client\t*c;\n\n\tTAILQ_FOREACH(c, &clients, entry)\n\t\tstatus_timer_start(c);\n}\n\n/* Get screen line of status line. -1 means off. */\nint\nstatus_at_line(struct client *c)\n{\n\tstruct session\t*s = c->session;\n\n\tif (!options_get_number(s->options, \"status\"))\n\t\treturn (-1);\n\n\tif (options_get_number(s->options, \"status-position\") == 0)\n\t\treturn (0);\n\treturn (c->tty.sy - 1);\n}\n\n/* Retrieve options for left string. */\nchar *\nstatus_redraw_get_left(struct client *c, time_t t, struct grid_cell *gc,\n    size_t *size)\n{\n\tstruct session\t*s = c->session;\n\tconst char\t*template;\n\tchar\t\t*left;\n\tsize_t\t\t leftlen;\n\n\tstyle_apply_update(gc, s->options, \"status-left-style\");\n\n\ttemplate = options_get_string(s->options, \"status-left\");\n\tleft = status_replace(c, NULL, template, t);\n\n\t*size = options_get_number(s->options, \"status-left-length\");\n\tleftlen = screen_write_cstrlen(\"%s\", left);\n\tif (leftlen < *size)\n\t\t*size = leftlen;\n\treturn (left);\n}\n\n/* Retrieve options for right string. */\nchar *\nstatus_redraw_get_right(struct client *c, time_t t, struct grid_cell *gc,\n    size_t *size)\n{\n\tstruct session\t*s = c->session;\n\tconst char\t*template;\n\tchar\t\t*right;\n\tsize_t\t\t rightlen;\n\n\tstyle_apply_update(gc, s->options, \"status-right-style\");\n\n\ttemplate = options_get_string(s->options, \"status-right\");\n\tright = status_replace(c, NULL, template, t);\n\n\t*size = options_get_number(s->options, \"status-right-length\");\n\trightlen = screen_write_cstrlen(\"%s\", right);\n\tif (rightlen < *size)\n\t\t*size = rightlen;\n\treturn (right);\n}\n\n/* Get window at window list position. */\nstruct window *\nstatus_get_window_at(struct client *c, u_int x)\n{\n\tstruct session\t*s = c->session;\n\tstruct winlink\t*wl;\n\tstruct options\t*oo;\n\tsize_t\t\t len;\n\n\tx += c->wlmouse;\n\tRB_FOREACH(wl, winlinks, &s->windows) {\n\t\too = wl->window->options;\n\t\tlen = strlen(options_get_string(oo, \"window-status-separator\"));\n\n\t\tif (x < wl->status_width)\n\t\t\treturn (wl->window);\n\t\tx -= wl->status_width + len;\n\t}\n\treturn (NULL);\n}\n\n/* Draw status for client on the last lines of given context. */\nint\nstatus_redraw(struct client *c)\n{\n\tstruct screen_write_ctx\tctx;\n\tstruct session\t       *s = c->session;\n\tstruct winlink\t       *wl;\n\tstruct screen\t\told_status, window_list;\n\tstruct grid_cell\tstdgc, lgc, rgc, gc;\n\tstruct options\t       *oo;\n\ttime_t\t\t\tt;\n\tchar\t\t       *left, *right, *sep;\n\tu_int\t\t\toffset, needed;\n\tu_int\t\t\twlstart, wlwidth, wlavailable, wloffset, wlsize;\n\tsize_t\t\t\tllen, rlen, seplen;\n\tint\t\t\tlarrow, rarrow;\n\n\t/* No status line? */\n\tif (c->tty.sy == 0 || !options_get_number(s->options, \"status\"))\n#ifdef TMATE\n\t\tif (c->tty.sy == 0 || !(c->flags & CLIENT_FORCE_STATUS))\n#endif\n\t\treturn (1);\n\tleft = right = NULL;\n\tlarrow = rarrow = 0;\n\n\t/* Store current time. */\n\tt = time(NULL);\n\n\t/* Set up default colour. */\n\tstyle_apply(&stdgc, s->options, \"status-style\");\n\n\t/* Create the target screen. */\n\tmemcpy(&old_status, &c->status, sizeof old_status);\n\tscreen_init(&c->status, c->tty.sx, 1, 0);\n\tscreen_write_start(&ctx, NULL, &c->status);\n\tfor (offset = 0; offset < c->tty.sx; offset++)\n\t\tscreen_write_putc(&ctx, &stdgc, ' ');\n\tscreen_write_stop(&ctx);\n\n\t/* If the height is one line, blank status line. */\n\tif (c->tty.sy <= 1)\n\t\tgoto out;\n\n\t/* Work out left and right strings. */\n\tmemcpy(&lgc, &stdgc, sizeof lgc);\n\tleft = status_redraw_get_left(c, t, &lgc, &llen);\n\tmemcpy(&rgc, &stdgc, sizeof rgc);\n\tright = status_redraw_get_right(c, t, &rgc, &rlen);\n\n#ifdef TMATE\n\ttmate_status(left, right);\n#endif\n\n\t/*\n\t * Figure out how much space we have for the window list. If there\n\t * isn't enough space, just show a blank status line.\n\t */\n\tneeded = 0;\n\tif (llen != 0)\n\t\tneeded += llen;\n\tif (rlen != 0)\n\t\tneeded += rlen;\n\tif (c->tty.sx == 0 || c->tty.sx <= needed)\n\t\tgoto out;\n\twlavailable = c->tty.sx - needed;\n\n\t/* Calculate the total size needed for the window list. */\n\twlstart = wloffset = wlwidth = 0;\n\tRB_FOREACH(wl, winlinks, &s->windows) {\n\t\tfree(wl->status_text);\n\t\tmemcpy(&wl->status_cell, &stdgc, sizeof wl->status_cell);\n\t\twl->status_text = status_print(c, wl, t, &wl->status_cell);\n\t\twl->status_width = screen_write_cstrlen(\"%s\", wl->status_text);\n\n\t\tif (wl == s->curw)\n\t\t\twloffset = wlwidth;\n\n\t\too = wl->window->options;\n\t\tsep = options_get_string(oo, \"window-status-separator\");\n\t\tseplen = screen_write_strlen(\"%s\", sep);\n\t\twlwidth += wl->status_width + seplen;\n\t}\n\n\t/* Create a new screen for the window list. */\n\tscreen_init(&window_list, wlwidth, 1, 0);\n\n\t/* And draw the window list into it. */\n\tscreen_write_start(&ctx, NULL, &window_list);\n\tRB_FOREACH(wl, winlinks, &s->windows) {\n\t\tscreen_write_cnputs(&ctx, -1, &wl->status_cell, \"%s\",\n\t\t    wl->status_text);\n\n\t\too = wl->window->options;\n\t\tsep = options_get_string(oo, \"window-status-separator\");\n\t\tscreen_write_nputs(&ctx, -1, &stdgc, \"%s\", sep);\n\t}\n\tscreen_write_stop(&ctx);\n\n\t/* If there is enough space for the total width, skip to draw now. */\n\tif (wlwidth <= wlavailable)\n\t\tgoto draw;\n\n\t/* Find size of current window text. */\n\twlsize = s->curw->status_width;\n\n\t/*\n\t * If the current window is already on screen, good to draw from the\n\t * start and just leave off the end.\n\t */\n\tif (wloffset + wlsize < wlavailable) {\n\t\tif (wlavailable > 0) {\n\t\t\trarrow = 1;\n\t\t\twlavailable--;\n\t\t}\n\t\twlwidth = wlavailable;\n\t} else {\n\t\t/*\n\t\t * Work out how many characters we need to omit from the\n\t\t * start. There are wlavailable characters to fill, and\n\t\t * wloffset + wlsize must be the last. So, the start character\n\t\t * is wloffset + wlsize - wlavailable.\n\t\t */\n\t\tif (wlavailable > 0) {\n\t\t\tlarrow = 1;\n\t\t\twlavailable--;\n\t\t}\n\n\t\twlstart = wloffset + wlsize - wlavailable;\n\t\tif (wlavailable > 0 && wlwidth > wlstart + wlavailable + 1) {\n\t\t\trarrow = 1;\n\t\t\twlstart++;\n\t\t\twlavailable--;\n\t\t}\n\t\twlwidth = wlavailable;\n\t}\n\n\t/* Bail if anything is now too small too. */\n\tif (wlwidth == 0 || wlavailable == 0) {\n\t\tscreen_free(&window_list);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Now the start position is known, work out the state of the left and\n\t * right arrows.\n\t */\n\toffset = 0;\n\tRB_FOREACH(wl, winlinks, &s->windows) {\n\t\tif (wl->flags & WINLINK_ALERTFLAGS &&\n\t\t    larrow == 1 && offset < wlstart)\n\t\t\tlarrow = -1;\n\n\t\toffset += wl->status_width;\n\n\t\tif (wl->flags & WINLINK_ALERTFLAGS &&\n\t\t    rarrow == 1 && offset > wlstart + wlwidth)\n\t\t\trarrow = -1;\n\t}\n\ndraw:\n\t/* Begin drawing. */\n\tscreen_write_start(&ctx, NULL, &c->status);\n\n\t/* Draw the left string and arrow. */\n\tscreen_write_cursormove(&ctx, 0, 0);\n\tif (llen != 0)\n\t\tscreen_write_cnputs(&ctx, llen, &lgc, \"%s\", left);\n\tif (larrow != 0) {\n\t\tmemcpy(&gc, &stdgc, sizeof gc);\n\t\tif (larrow == -1)\n\t\t\tgc.attr ^= GRID_ATTR_REVERSE;\n\t\tscreen_write_putc(&ctx, &gc, '<');\n\t}\n\n\t/* Draw the right string and arrow. */\n\tif (rarrow != 0) {\n\t\tscreen_write_cursormove(&ctx, c->tty.sx - rlen - 1, 0);\n\t\tmemcpy(&gc, &stdgc, sizeof gc);\n\t\tif (rarrow == -1)\n\t\t\tgc.attr ^= GRID_ATTR_REVERSE;\n\t\tscreen_write_putc(&ctx, &gc, '>');\n\t} else\n\t\tscreen_write_cursormove(&ctx, c->tty.sx - rlen, 0);\n\tif (rlen != 0)\n\t\tscreen_write_cnputs(&ctx, rlen, &rgc, \"%s\", right);\n\n\t/* Figure out the offset for the window list. */\n\tif (llen != 0)\n\t\twloffset = llen;\n\telse\n\t\twloffset = 0;\n\tif (wlwidth < wlavailable) {\n\t\tswitch (options_get_number(s->options, \"status-justify\")) {\n\t\tcase 1:\t/* centred */\n\t\t\twloffset += (wlavailable - wlwidth) / 2;\n\t\t\tbreak;\n\t\tcase 2:\t/* right */\n\t\t\twloffset += (wlavailable - wlwidth);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (larrow != 0)\n\t\twloffset++;\n\n\t/* Copy the window list. */\n\tc->wlmouse = -wloffset + wlstart;\n\tscreen_write_cursormove(&ctx, wloffset, 0);\n\tscreen_write_copy(&ctx, &window_list, wlstart, 0, wlwidth, 1);\n\tscreen_free(&window_list);\n\n\tscreen_write_stop(&ctx);\n\nout:\n\tfree(left);\n\tfree(right);\n\n\tif (grid_compare(c->status.grid, old_status.grid) == 0) {\n\t\tscreen_free(&old_status);\n\t\treturn (0);\n\t}\n\tscreen_free(&old_status);\n\treturn (1);\n}\n\n/* Replace special sequences in fmt. */\nchar *\nstatus_replace(struct client *c, struct winlink *wl, const char *fmt, time_t t)\n{\n\tstruct format_tree\t*ft;\n\tchar\t\t\t*expanded;\n\n\tif (fmt == NULL)\n\t\treturn (xstrdup(\"\"));\n\n\tif (c->flags & CLIENT_STATUSFORCE)\n\t\tft = format_create(NULL, FORMAT_STATUS|FORMAT_FORCE);\n\telse\n\t\tft = format_create(NULL, FORMAT_STATUS);\n\tformat_defaults(ft, c, NULL, wl, NULL);\n\n\texpanded = format_expand_time(ft, fmt, t);\n\n\tformat_free(ft);\n\treturn (expanded);\n}\n\n/* Return winlink status line entry and adjust gc as necessary. */\nchar *\nstatus_print(struct client *c, struct winlink *wl, time_t t,\n    struct grid_cell *gc)\n{\n\tstruct options\t*oo = wl->window->options;\n\tstruct session\t*s = c->session;\n\tconst char\t*fmt;\n\tchar   \t\t*text;\n\n\tstyle_apply_update(gc, oo, \"window-status-style\");\n\tfmt = options_get_string(oo, \"window-status-format\");\n\tif (wl == s->curw) {\n\t\tstyle_apply_update(gc, oo, \"window-status-current-style\");\n\t\tfmt = options_get_string(oo, \"window-status-current-format\");\n\t}\n\tif (wl == TAILQ_FIRST(&s->lastw))\n\t\tstyle_apply_update(gc, oo, \"window-status-last-style\");\n\n\tif (wl->flags & WINLINK_BELL)\n\t\tstyle_apply_update(gc, oo, \"window-status-bell-style\");\n\telse if (wl->flags & (WINLINK_ACTIVITY|WINLINK_SILENCE))\n\t\tstyle_apply_update(gc, oo, \"window-status-activity-style\");\n\n\ttext = status_replace(c, wl, fmt, t);\n\treturn (text);\n}\n\n/* Set a status line message. */\nvoid\nstatus_message_set(struct client *c, const char *fmt, ...)\n{\n\tstruct timeval\t\t tv;\n\tstruct message_entry\t*msg, *msg1;\n\tva_list\t\t\t ap;\n\tint\t\t\t delay;\n\tu_int\t\t\t limit;\n\n\tlimit = options_get_number(global_options, \"message-limit\");\n\n\tstatus_prompt_clear(c);\n\tstatus_message_clear(c);\n\n\tva_start(ap, fmt);\n\txvasprintf(&c->message_string, fmt, ap);\n\tva_end(ap);\n\n\tmsg = xcalloc(1, sizeof *msg);\n\tmsg->msg_time = time(NULL);\n\tmsg->msg_num = c->message_next++;\n\tmsg->msg = xstrdup(c->message_string);\n\tTAILQ_INSERT_TAIL(&c->message_log, msg, entry);\n\n\tTAILQ_FOREACH_SAFE(msg, &c->message_log, entry, msg1) {\n\t\tif (msg->msg_num + limit >= c->message_next)\n\t\t\tbreak;\n\t\tfree(msg->msg);\n\t\tTAILQ_REMOVE(&c->message_log, msg, entry);\n\t\tfree(msg);\n\t}\n\n\tdelay = options_get_number(c->session->options, \"display-time\");\n\tif (delay > 0) {\n\t\ttv.tv_sec = delay / 1000;\n\t\ttv.tv_usec = (delay % 1000) * 1000L;\n\n\t\tif (event_initialized(&c->message_timer))\n\t\t\tevtimer_del(&c->message_timer);\n\t\tevtimer_set(&c->message_timer, status_message_callback, c);\n\t\tevtimer_add(&c->message_timer, &tv);\n\t}\n\n\tc->tty.flags |= (TTY_NOCURSOR|TTY_FREEZE);\n\tc->flags |= CLIENT_STATUS;\n}\n\n/* Clear status line message. */\nvoid\nstatus_message_clear(struct client *c)\n{\n\tif (c->message_string == NULL)\n\t\treturn;\n\n\tfree(c->message_string);\n\tc->message_string = NULL;\n\n\tc->tty.flags &= ~(TTY_NOCURSOR|TTY_FREEZE);\n#ifdef TMATE\n\tif (c->flags & CLIENT_FORCE_STATUS) {\n\t\tc->flags &= ~CLIENT_FORCE_STATUS;\n\t\trecalculate_sizes();\n\t}\n#endif\n\tc->flags |= CLIENT_REDRAW; /* screen was frozen and may have changed */\n\n\tscreen_reinit(&c->status);\n}\n\n/* Clear status line message after timer expires. */\nvoid\nstatus_message_callback(__unused int fd, __unused short event, void *data)\n{\n\tstruct client\t*c = data;\n\n\tstatus_message_clear(c);\n}\n\n/* Draw client message on status line of present else on last line. */\nint\nstatus_message_redraw(struct client *c)\n{\n\tstruct screen_write_ctx\t\tctx;\n\tstruct session\t\t       *s = c->session;\n\tstruct screen\t\t        old_status;\n\tsize_t\t\t\t        len;\n\tstruct grid_cell\t\tgc;\n\n\tif (c->tty.sx == 0 || c->tty.sy == 0)\n\t\treturn (0);\n\tmemcpy(&old_status, &c->status, sizeof old_status);\n\tscreen_init(&c->status, c->tty.sx, 1, 0);\n\n\tlen = screen_write_strlen(\"%s\", c->message_string);\n\tif (len > c->tty.sx)\n\t\tlen = c->tty.sx;\n\n\tstyle_apply(&gc, s->options, \"message-style\");\n\n\tscreen_write_start(&ctx, NULL, &c->status);\n\n\tscreen_write_cursormove(&ctx, 0, 0);\n\tscreen_write_nputs(&ctx, len, &gc, \"%s\", c->message_string);\n\tfor (; len < c->tty.sx; len++)\n\t\tscreen_write_putc(&ctx, &gc, ' ');\n\n\tscreen_write_stop(&ctx);\n\n\tif (grid_compare(c->status.grid, old_status.grid) == 0) {\n\t\tscreen_free(&old_status);\n\t\treturn (0);\n\t}\n\tscreen_free(&old_status);\n\treturn (1);\n}\n\n/* Enable status line prompt. */\nvoid\nstatus_prompt_set(struct client *c, const char *msg, const char *input,\n    int (*callbackfn)(void *, const char *), void (*freefn)(void *),\n    void *data, int flags)\n{\n\tstruct format_tree\t*ft;\n\tint\t\t\t keys;\n\ttime_t\t\t\t t;\n\n\tft = format_create(NULL, 0);\n\tformat_defaults(ft, c, NULL, NULL, NULL);\n\tt = time(NULL);\n\n\tstatus_message_clear(c);\n\tstatus_prompt_clear(c);\n\n\tc->prompt_string = format_expand_time(ft, msg, t);\n\n\tc->prompt_buffer = format_expand_time(ft, input, t);\n\tc->prompt_index = strlen(c->prompt_buffer);\n\n\tc->prompt_callbackfn = callbackfn;\n\tc->prompt_freefn = freefn;\n\tc->prompt_data = data;\n\n\tc->prompt_hindex = 0;\n\n\tc->prompt_flags = flags;\n\n\tkeys = options_get_number(c->session->options, \"status-keys\");\n\tif (keys == MODEKEY_EMACS)\n\t\tmode_key_init(&c->prompt_mdata, &mode_key_tree_emacs_edit);\n\telse\n\t\tmode_key_init(&c->prompt_mdata, &mode_key_tree_vi_edit);\n\n\tc->tty.flags |= (TTY_NOCURSOR|TTY_FREEZE);\n\tc->flags |= CLIENT_STATUS;\n\n\tformat_free(ft);\n}\n\n/* Remove status line prompt. */\nvoid\nstatus_prompt_clear(struct client *c)\n{\n\tif (c->prompt_string == NULL)\n\t\treturn;\n\n\tif (c->prompt_freefn != NULL && c->prompt_data != NULL)\n\t\tc->prompt_freefn(c->prompt_data);\n\n\tfree(c->prompt_string);\n\tc->prompt_string = NULL;\n\n\tfree(c->prompt_buffer);\n\tc->prompt_buffer = NULL;\n\n\tc->tty.flags &= ~(TTY_NOCURSOR|TTY_FREEZE);\n\tc->flags |= CLIENT_REDRAW; /* screen was frozen and may have changed */\n\n\tscreen_reinit(&c->status);\n}\n\n/* Update status line prompt with a new prompt string. */\nvoid\nstatus_prompt_update(struct client *c, const char *msg, const char *input)\n{\n\tstruct format_tree\t*ft;\n\ttime_t\t\t\t t;\n\n\tft = format_create(NULL, 0);\n\tformat_defaults(ft, c, NULL, NULL, NULL);\n\tt = time(NULL);\n\n\tfree(c->prompt_string);\n\tc->prompt_string = format_expand_time(ft, msg, t);\n\n\tfree(c->prompt_buffer);\n\tc->prompt_buffer = format_expand_time(ft, input, t);\n\tc->prompt_index = strlen(c->prompt_buffer);\n\n\tc->prompt_hindex = 0;\n\n\tc->flags |= CLIENT_STATUS;\n\n\tformat_free(ft);\n}\n\n/* Draw client prompt on status line of present else on last line. */\nint\nstatus_prompt_redraw(struct client *c)\n{\n\tstruct screen_write_ctx\t\tctx;\n\tstruct session\t\t       *s = c->session;\n\tstruct screen\t\t        old_status;\n\tsize_t\t\t\t        i, size, left, len, off;\n\tstruct grid_cell\t\tgc;\n\n\tif (c->tty.sx == 0 || c->tty.sy == 0)\n\t\treturn (0);\n\tmemcpy(&old_status, &c->status, sizeof old_status);\n\tscreen_init(&c->status, c->tty.sx, 1, 0);\n\n\tlen = screen_write_strlen(\"%s\", c->prompt_string);\n\tif (len > c->tty.sx)\n\t\tlen = c->tty.sx;\n\toff = 0;\n\n\t/* Change colours for command mode. */\n\tif (c->prompt_mdata.mode == 1)\n\t\tstyle_apply(&gc, s->options, \"message-command-style\");\n\telse\n\t\tstyle_apply(&gc, s->options, \"message-style\");\n\n\tscreen_write_start(&ctx, NULL, &c->status);\n\n\tscreen_write_cursormove(&ctx, 0, 0);\n\tscreen_write_nputs(&ctx, len, &gc, \"%s\", c->prompt_string);\n\n\tleft = c->tty.sx - len;\n\tif (left != 0) {\n\t\tsize = screen_write_strlen(\"%s\", c->prompt_buffer);\n\t\tif (c->prompt_index >= left) {\n\t\t\toff = c->prompt_index - left + 1;\n\t\t\tif (c->prompt_index == size)\n\t\t\t\tleft--;\n\t\t\tsize = left;\n\t\t}\n\t\tscreen_write_nputs(&ctx, left, &gc, \"%s\", c->prompt_buffer +\n\t\t    off);\n\n\t\tfor (i = len + size; i < c->tty.sx; i++)\n\t\t\tscreen_write_putc(&ctx, &gc, ' ');\n\t}\n\n\tscreen_write_stop(&ctx);\n\n\t/* Apply fake cursor. */\n\toff = len + c->prompt_index - off;\n\tgrid_view_get_cell(c->status.grid, off, 0, &gc);\n\tgc.attr ^= GRID_ATTR_REVERSE;\n\tgrid_view_set_cell(c->status.grid, off, 0, &gc);\n\n\tif (grid_compare(c->status.grid, old_status.grid) == 0) {\n\t\tscreen_free(&old_status);\n\t\treturn (0);\n\t}\n\tscreen_free(&old_status);\n\treturn (1);\n}\n\n/* Handle keys in prompt. */\nvoid\nstatus_prompt_key(struct client *c, key_code key)\n{\n\tstruct session\t\t*sess = c->session;\n\tstruct options\t\t*oo = sess->options;\n\tstruct paste_buffer\t*pb;\n\tchar\t\t\t*s, *first, *last, word[64], swapc;\n\tconst char\t\t*histstr, *bufdata, *wsep = NULL;\n\tu_char\t\t\t ch;\n\tsize_t\t\t\t size, n, off, idx, bufsize;\n\n\tsize = strlen(c->prompt_buffer);\n\tswitch (mode_key_lookup(&c->prompt_mdata, key, NULL)) {\n\tcase MODEKEYEDIT_CURSORLEFT:\n\t\tif (c->prompt_index > 0) {\n\t\t\tc->prompt_index--;\n\t\t\tc->flags |= CLIENT_STATUS;\n\t\t}\n\t\tbreak;\n\tcase MODEKEYEDIT_SWITCHMODE:\n\t\tc->flags |= CLIENT_STATUS;\n\t\tbreak;\n\tcase MODEKEYEDIT_SWITCHMODEAPPEND:\n\t\tc->flags |= CLIENT_STATUS;\n\t\t/* FALLTHROUGH */\n\tcase MODEKEYEDIT_CURSORRIGHT:\n\t\tif (c->prompt_index < size) {\n\t\t\tc->prompt_index++;\n\t\t\tc->flags |= CLIENT_STATUS;\n\t\t}\n\t\tbreak;\n\tcase MODEKEYEDIT_SWITCHMODEBEGINLINE:\n\t\tc->flags |= CLIENT_STATUS;\n\t\t/* FALLTHROUGH */\n\tcase MODEKEYEDIT_STARTOFLINE:\n\t\tif (c->prompt_index != 0) {\n\t\t\tc->prompt_index = 0;\n\t\t\tc->flags |= CLIENT_STATUS;\n\t\t}\n\t\tbreak;\n\tcase MODEKEYEDIT_SWITCHMODEAPPENDLINE:\n\t\tc->flags |= CLIENT_STATUS;\n\t\t/* FALLTHROUGH */\n\tcase MODEKEYEDIT_ENDOFLINE:\n\t\tif (c->prompt_index != size) {\n\t\t\tc->prompt_index = size;\n\t\t\tc->flags |= CLIENT_STATUS;\n\t\t}\n\t\tbreak;\n\tcase MODEKEYEDIT_COMPLETE:\n\t\tif (*c->prompt_buffer == '\\0')\n\t\t\tbreak;\n\n\t\tidx = c->prompt_index;\n\t\tif (idx != 0)\n\t\t\tidx--;\n\n\t\t/* Find the word we are in. */\n\t\tfirst = c->prompt_buffer + idx;\n\t\twhile (first > c->prompt_buffer && *first != ' ')\n\t\t\tfirst--;\n\t\twhile (*first == ' ')\n\t\t\tfirst++;\n\t\tlast = c->prompt_buffer + idx;\n\t\twhile (*last != '\\0' && *last != ' ')\n\t\t\tlast++;\n\t\twhile (*last == ' ')\n\t\t\tlast--;\n\t\tif (*last != '\\0')\n\t\t\tlast++;\n\t\tif (last <= first ||\n\t\t    ((size_t) (last - first)) > (sizeof word) - 1)\n\t\t\tbreak;\n\t\tmemcpy(word, first, last - first);\n\t\tword[last - first] = '\\0';\n\n\t\t/* And try to complete it. */\n\t\tif ((s = status_prompt_complete(sess, word)) == NULL)\n\t\t\tbreak;\n\n\t\t/* Trim out word. */\n\t\tn = size - (last - c->prompt_buffer) + 1; /* with \\0 */\n\t\tmemmove(first, last, n);\n\t\tsize -= last - first;\n\n\t\t/* Insert the new word. */\n\t\tsize += strlen(s);\n\t\toff = first - c->prompt_buffer;\n\t\tc->prompt_buffer = xrealloc(c->prompt_buffer, size + 1);\n\t\tfirst = c->prompt_buffer + off;\n\t\tmemmove(first + strlen(s), first, n);\n\t\tmemcpy(first, s, strlen(s));\n\n\t\tc->prompt_index = (first - c->prompt_buffer) + strlen(s);\n\t\tfree(s);\n\n\t\tc->flags |= CLIENT_STATUS;\n\t\tbreak;\n\tcase MODEKEYEDIT_BACKSPACE:\n\t\tif (c->prompt_index != 0) {\n\t\t\tif (c->prompt_index == size)\n\t\t\t\tc->prompt_buffer[--c->prompt_index] = '\\0';\n\t\t\telse {\n\t\t\t\tmemmove(c->prompt_buffer + c->prompt_index - 1,\n\t\t\t\t    c->prompt_buffer + c->prompt_index,\n\t\t\t\t    size + 1 - c->prompt_index);\n\t\t\t\tc->prompt_index--;\n\t\t\t}\n\t\t\tc->flags |= CLIENT_STATUS;\n\t\t}\n\t\tbreak;\n\tcase MODEKEYEDIT_DELETE:\n\tcase MODEKEYEDIT_SWITCHMODESUBSTITUTE:\n\t\tif (c->prompt_index != size) {\n\t\t\tmemmove(c->prompt_buffer + c->prompt_index,\n\t\t\t    c->prompt_buffer + c->prompt_index + 1,\n\t\t\t    size + 1 - c->prompt_index);\n\t\t\tc->flags |= CLIENT_STATUS;\n\t\t}\n\t\tbreak;\n\tcase MODEKEYEDIT_DELETELINE:\n\tcase MODEKEYEDIT_SWITCHMODESUBSTITUTELINE:\n\t\t*c->prompt_buffer = '\\0';\n\t\tc->prompt_index = 0;\n\t\tc->flags |= CLIENT_STATUS;\n\t\tbreak;\n\tcase MODEKEYEDIT_DELETETOENDOFLINE:\n\tcase MODEKEYEDIT_SWITCHMODECHANGELINE:\n\t\tif (c->prompt_index < size) {\n\t\t\tc->prompt_buffer[c->prompt_index] = '\\0';\n\t\t\tc->flags |= CLIENT_STATUS;\n\t\t}\n\t\tbreak;\n\tcase MODEKEYEDIT_DELETEWORD:\n\t\twsep = options_get_string(oo, \"word-separators\");\n\t\tidx = c->prompt_index;\n\n\t\t/* Find a non-separator. */\n\t\twhile (idx != 0) {\n\t\t\tidx--;\n\t\t\tif (!strchr(wsep, c->prompt_buffer[idx]))\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Find the separator at the beginning of the word. */\n\t\twhile (idx != 0) {\n\t\t\tidx--;\n\t\t\tif (strchr(wsep, c->prompt_buffer[idx])) {\n\t\t\t\t/* Go back to the word. */\n\t\t\t\tidx++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tmemmove(c->prompt_buffer + idx,\n\t\t    c->prompt_buffer + c->prompt_index,\n\t\t    size + 1 - c->prompt_index);\n\t\tmemset(c->prompt_buffer + size - (c->prompt_index - idx),\n\t\t    '\\0', c->prompt_index - idx);\n\t\tc->prompt_index = idx;\n\t\tc->flags |= CLIENT_STATUS;\n\t\tbreak;\n\tcase MODEKEYEDIT_NEXTSPACE:\n\t\twsep = \" \";\n\t\t/* FALLTHROUGH */\n\tcase MODEKEYEDIT_NEXTWORD:\n\t\tif (wsep == NULL)\n\t\t\twsep = options_get_string(oo, \"word-separators\");\n\n\t\t/* Find a separator. */\n\t\twhile (c->prompt_index != size) {\n\t\t\tc->prompt_index++;\n\t\t\tif (strchr(wsep, c->prompt_buffer[c->prompt_index]))\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Find the word right after the separation. */\n\t\twhile (c->prompt_index != size) {\n\t\t\tc->prompt_index++;\n\t\t\tif (!strchr(wsep, c->prompt_buffer[c->prompt_index]))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tc->flags |= CLIENT_STATUS;\n\t\tbreak;\n\tcase MODEKEYEDIT_NEXTSPACEEND:\n\t\twsep = \" \";\n\t\t/* FALLTHROUGH */\n\tcase MODEKEYEDIT_NEXTWORDEND:\n\t\tif (wsep == NULL)\n\t\t\twsep = options_get_string(oo, \"word-separators\");\n\n\t\t/* Find a word. */\n\t\twhile (c->prompt_index != size) {\n\t\t\tc->prompt_index++;\n\t\t\tif (!strchr(wsep, c->prompt_buffer[c->prompt_index]))\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Find the separator at the end of the word. */\n\t\twhile (c->prompt_index != size) {\n\t\t\tc->prompt_index++;\n\t\t\tif (strchr(wsep, c->prompt_buffer[c->prompt_index]))\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Back up to the end-of-word like vi. */\n\t\tif (options_get_number(oo, \"status-keys\") == MODEKEY_VI &&\n\t\t    c->prompt_index != 0)\n\t\t\tc->prompt_index--;\n\n\t\tc->flags |= CLIENT_STATUS;\n\t\tbreak;\n\tcase MODEKEYEDIT_PREVIOUSSPACE:\n\t\twsep = \" \";\n\t\t/* FALLTHROUGH */\n\tcase MODEKEYEDIT_PREVIOUSWORD:\n\t\tif (wsep == NULL)\n\t\t\twsep = options_get_string(oo, \"word-separators\");\n\n\t\t/* Find a non-separator. */\n\t\twhile (c->prompt_index != 0) {\n\t\t\tc->prompt_index--;\n\t\t\tif (!strchr(wsep, c->prompt_buffer[c->prompt_index]))\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Find the separator at the beginning of the word. */\n\t\twhile (c->prompt_index != 0) {\n\t\t\tc->prompt_index--;\n\t\t\tif (strchr(wsep, c->prompt_buffer[c->prompt_index])) {\n\t\t\t\t/* Go back to the word. */\n\t\t\t\tc->prompt_index++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tc->flags |= CLIENT_STATUS;\n\t\tbreak;\n\tcase MODEKEYEDIT_HISTORYUP:\n\t\thiststr = status_prompt_up_history(&c->prompt_hindex);\n\t\tif (histstr == NULL)\n\t\t\tbreak;\n\t\tfree(c->prompt_buffer);\n\t\tc->prompt_buffer = xstrdup(histstr);\n\t\tc->prompt_index = strlen(c->prompt_buffer);\n\t\tc->flags |= CLIENT_STATUS;\n\t\tbreak;\n\tcase MODEKEYEDIT_HISTORYDOWN:\n\t\thiststr = status_prompt_down_history(&c->prompt_hindex);\n\t\tif (histstr == NULL)\n\t\t\tbreak;\n\t\tfree(c->prompt_buffer);\n\t\tc->prompt_buffer = xstrdup(histstr);\n\t\tc->prompt_index = strlen(c->prompt_buffer);\n\t\tc->flags |= CLIENT_STATUS;\n\t\tbreak;\n\tcase MODEKEYEDIT_PASTE:\n\t\tif ((pb = paste_get_top(NULL)) == NULL)\n\t\t\tbreak;\n\t\tbufdata = paste_buffer_data(pb, &bufsize);\n\t\tfor (n = 0; n < bufsize; n++) {\n\t\t\tch = (u_char)bufdata[n];\n\t\t\tif (ch < 32 || ch == 127)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tc->prompt_buffer = xrealloc(c->prompt_buffer, size + n + 1);\n\t\tif (c->prompt_index == size) {\n\t\t\tmemcpy(c->prompt_buffer + c->prompt_index, bufdata, n);\n\t\t\tc->prompt_index += n;\n\t\t\tc->prompt_buffer[c->prompt_index] = '\\0';\n\t\t} else {\n\t\t\tmemmove(c->prompt_buffer + c->prompt_index + n,\n\t\t\t    c->prompt_buffer + c->prompt_index,\n\t\t\t    size + 1 - c->prompt_index);\n\t\t\tmemcpy(c->prompt_buffer + c->prompt_index, bufdata, n);\n\t\t\tc->prompt_index += n;\n\t\t}\n\n\t\tc->flags |= CLIENT_STATUS;\n\t\tbreak;\n\tcase MODEKEYEDIT_TRANSPOSECHARS:\n\t\tidx = c->prompt_index;\n\t\tif (idx < size)\n\t\t\tidx++;\n\t\tif (idx >= 2) {\n\t\t\tswapc = c->prompt_buffer[idx - 2];\n\t\t\tc->prompt_buffer[idx - 2] = c->prompt_buffer[idx - 1];\n\t\t\tc->prompt_buffer[idx - 1] = swapc;\n\t\t\tc->prompt_index = idx;\n\t\t\tc->flags |= CLIENT_STATUS;\n\t\t}\n\t\tbreak;\n\tcase MODEKEYEDIT_ENTER:\n\t\tif (*c->prompt_buffer != '\\0')\n\t\t\tstatus_prompt_add_history(c->prompt_buffer);\n\t\tif (c->prompt_callbackfn(c->prompt_data, c->prompt_buffer) == 0)\n\t\t\tstatus_prompt_clear(c);\n\t\tbreak;\n\tcase MODEKEYEDIT_CANCEL:\n\t\tif (c->prompt_callbackfn(c->prompt_data, NULL) == 0)\n\t\t\tstatus_prompt_clear(c);\n\t\tbreak;\n\tcase MODEKEY_OTHER:\n\t\tif (key <= 0x1f || key >= 0x7f)\n\t\t\tbreak;\n\t\tc->prompt_buffer = xrealloc(c->prompt_buffer, size + 2);\n\n\t\tif (c->prompt_index == size) {\n\t\t\tc->prompt_buffer[c->prompt_index++] = key;\n\t\t\tc->prompt_buffer[c->prompt_index] = '\\0';\n\t\t} else {\n\t\t\tmemmove(c->prompt_buffer + c->prompt_index + 1,\n\t\t\t    c->prompt_buffer + c->prompt_index,\n\t\t\t    size + 1 - c->prompt_index);\n\t\t\tc->prompt_buffer[c->prompt_index++] = key;\n\t\t}\n\n\t\tif (c->prompt_flags & PROMPT_SINGLE) {\n\t\t\tif (c->prompt_callbackfn(c->prompt_data,\n\t\t\t    c->prompt_buffer) == 0)\n\t\t\t\tstatus_prompt_clear(c);\n\t\t}\n\n\t\tc->flags |= CLIENT_STATUS;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n/* Get previous line from the history. */\nconst char *\nstatus_prompt_up_history(u_int *idx)\n{\n\t/*\n\t * History runs from 0 to size - 1. Index is from 0 to size. Zero is\n\t * empty.\n\t */\n\n\tif (status_prompt_hsize == 0 || *idx == status_prompt_hsize)\n\t\treturn (NULL);\n\t(*idx)++;\n\treturn (status_prompt_hlist[status_prompt_hsize - *idx]);\n}\n\n/* Get next line from the history. */\nconst char *\nstatus_prompt_down_history(u_int *idx)\n{\n\tif (status_prompt_hsize == 0 || *idx == 0)\n\t\treturn (\"\");\n\t(*idx)--;\n\tif (*idx == 0)\n\t\treturn (\"\");\n\treturn (status_prompt_hlist[status_prompt_hsize - *idx]);\n}\n\n/* Add line to the history. */\nvoid\nstatus_prompt_add_history(const char *line)\n{\n\tsize_t\tsize;\n\n\tif (status_prompt_hsize > 0 &&\n\t    strcmp(status_prompt_hlist[status_prompt_hsize - 1], line) == 0)\n\t\treturn;\n\n\tif (status_prompt_hsize == PROMPT_HISTORY) {\n\t\tfree(status_prompt_hlist[0]);\n\n\t\tsize = (PROMPT_HISTORY - 1) * sizeof *status_prompt_hlist;\n\t\tmemmove(&status_prompt_hlist[0], &status_prompt_hlist[1], size);\n\n\t\tstatus_prompt_hlist[status_prompt_hsize - 1] = xstrdup(line);\n\t\treturn;\n\t}\n\n\tstatus_prompt_hlist = xreallocarray(status_prompt_hlist,\n\t    status_prompt_hsize + 1, sizeof *status_prompt_hlist);\n\tstatus_prompt_hlist[status_prompt_hsize++] = xstrdup(line);\n}\n\n/* Build completion list. */\nconst char **\nstatus_prompt_complete_list(u_int *size, const char *s)\n{\n\tconst char\t\t\t\t**list = NULL, **layout;\n\tconst struct cmd_entry\t\t\t**cmdent;\n\tconst struct options_table_entry\t *oe;\n\tconst char\t\t\t\t *layouts[] = {\n\t\t\"even-horizontal\", \"even-vertical\", \"main-horizontal\",\n\t\t\"main-vertical\", \"tiled\", NULL\n\t};\n\n\t*size = 0;\n\tfor (cmdent = cmd_table; *cmdent != NULL; cmdent++) {\n\t\tif (strncmp((*cmdent)->name, s, strlen(s)) == 0) {\n\t\t\tlist = xreallocarray(list, (*size) + 1, sizeof *list);\n\t\t\tlist[(*size)++] = (*cmdent)->name;\n\t\t}\n\t}\n\tfor (oe = options_table; oe->name != NULL; oe++) {\n\t\tif (strncmp(oe->name, s, strlen(s)) == 0) {\n\t\t\tlist = xreallocarray(list, (*size) + 1, sizeof *list);\n\t\t\tlist[(*size)++] = oe->name;\n\t\t}\n\t}\n\tfor (layout = layouts; *layout != NULL; layout++) {\n\t\tif (strncmp(*layout, s, strlen(s)) == 0) {\n\t\t\tlist = xreallocarray(list, (*size) + 1, sizeof *list);\n\t\t\tlist[(*size)++] = *layout;\n\t\t}\n\t}\n\treturn (list);\n}\n\n/* Find longest prefix. */\nchar *\nstatus_prompt_complete_prefix(const char **list, u_int size)\n{\n\tchar\t *out;\n\tu_int\t  i;\n\tsize_t\t  j;\n\n\tout = xstrdup(list[0]);\n\tfor (i = 1; i < size; i++) {\n\t\tj = strlen(list[i]);\n\t\tif (j > strlen(out))\n\t\t\tj = strlen(out);\n\t\tfor (; j > 0; j--) {\n\t\t\tif (out[j - 1] != list[i][j - 1])\n\t\t\t\tout[j - 1] = '\\0';\n\t\t}\n\t}\n\treturn (out);\n}\n\n/* Complete word. */\nchar *\nstatus_prompt_complete(struct session *sess, const char *s)\n{\n\tconst char\t**list = NULL, *colon;\n\tu_int\t\t  size = 0, i;\n\tstruct session\t *s_loop;\n\tstruct winlink\t *wl;\n\tstruct window\t *w;\n\tchar\t\t *copy, *out, *tmp;\n\n\tif (*s == '\\0')\n\t\treturn (NULL);\n\tout = NULL;\n\n\tif (strncmp(s, \"-t\", 2) != 0 && strncmp(s, \"-s\", 2) != 0) {\n\t\tlist = status_prompt_complete_list(&size, s);\n\t\tif (size == 0)\n\t\t\tout = NULL;\n\t\telse if (size == 1)\n\t\t\txasprintf(&out, \"%s \", list[0]);\n\t\telse\n\t\t\tout = status_prompt_complete_prefix(list, size);\n\t\tfree(list);\n\t\treturn (out);\n\t}\n\tcopy = xstrdup(s);\n\n\tcolon = \":\";\n\tif (copy[strlen(copy) - 1] == ':')\n\t\tcopy[strlen(copy) - 1] = '\\0';\n\telse\n\t\tcolon = \"\";\n\ts = copy + 2;\n\n\tRB_FOREACH(s_loop, sessions, &sessions) {\n\t\tif (strncmp(s_loop->name, s, strlen(s)) == 0) {\n\t\t\tlist = xreallocarray(list, size + 2, sizeof *list);\n\t\t\tlist[size++] = s_loop->name;\n\t\t}\n\t}\n\tif (size == 1) {\n\t\tout = xstrdup(list[0]);\n\t\tif (session_find(list[0]) != NULL)\n\t\t\tcolon = \":\";\n\t} else if (size != 0)\n\t\tout = status_prompt_complete_prefix(list, size);\n\tif (out != NULL) {\n\t\txasprintf(&tmp, \"-%c%s%s\", copy[1], out, colon);\n\t\tout = tmp;\n\t\tgoto found;\n\t}\n\n\tcolon = \"\";\n\tif (*s == ':') {\n\t\tRB_FOREACH(wl, winlinks, &sess->windows) {\n\t\t\txasprintf(&tmp, \":%s\", wl->window->name);\n\t\t\tif (strncmp(tmp, s, strlen(s)) == 0){\n\t\t\t\tlist = xreallocarray(list, size + 1,\n\t\t\t\t    sizeof *list);\n\t\t\t\tlist[size++] = tmp;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfree(tmp);\n\n\t\t\txasprintf(&tmp, \":%d\", wl->idx);\n\t\t\tif (strncmp(tmp, s, strlen(s)) == 0) {\n\t\t\t\tlist = xreallocarray(list, size + 1,\n\t\t\t\t    sizeof *list);\n\t\t\t\tlist[size++] = tmp;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfree(tmp);\n\t\t}\n\t} else {\n\t\tRB_FOREACH(s_loop, sessions, &sessions) {\n\t\t\tRB_FOREACH(wl, winlinks, &s_loop->windows) {\n\t\t\t\tw = wl->window;\n\n\t\t\t\txasprintf(&tmp, \"%s:%s\", s_loop->name, w->name);\n\t\t\t\tif (strncmp(tmp, s, strlen(s)) == 0) {\n\t\t\t\t\tlist = xreallocarray(list, size + 1,\n\t\t\t\t\t    sizeof *list);\n\t\t\t\t\tlist[size++] = tmp;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfree(tmp);\n\n\t\t\t\txasprintf(&tmp, \"%s:%d\", s_loop->name, wl->idx);\n\t\t\t\tif (strncmp(tmp, s, strlen(s)) == 0) {\n\t\t\t\t\tlist = xreallocarray(list, size + 1,\n\t\t\t\t\t    sizeof *list);\n\t\t\t\t\tlist[size++] = tmp;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfree(tmp);\n\t\t\t}\n\t\t}\n\t}\n\tif (size == 1) {\n\t\tout = xstrdup(list[0]);\n\t\tcolon = \" \";\n\t} else if (size != 0)\n\t\tout = status_prompt_complete_prefix(list, size);\n\tif (out != NULL) {\n\t\txasprintf(&tmp, \"-%c%s%s\", copy[1], out, colon);\n\t\tout = tmp;\n\t}\n\n\tfor (i = 0; i < size; i++)\n\t\tfree((void *)list[i]);\n\nfound:\n\tfree(copy);\n\tfree(list);\n\treturn (out);\n}\n"
        },
        {
          "name": "style.c",
          "type": "blob",
          "size": 6.5087890625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n * Copyright (c) 2014 Tiago Cunha <tcunha@users.sourceforge.net>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <string.h>\n\n#include \"tmux.h\"\n\n/* Parse an embedded style of the form \"fg=colour,bg=colour,bright,...\". */\nint\nstyle_parse(const struct grid_cell *defgc, struct grid_cell *gc,\n    const char *in)\n{\n\tstruct grid_cell\tsavedgc;\n\tconst char\t\tdelimiters[] = \" ,\";\n\tchar\t\t\ttmp[32];\n\tint\t\t\tval;\n\tsize_t\t\t\tend;\n\tu_char\t\t\tfg, bg, attr, flags;\n\n\tif (*in == '\\0')\n\t\treturn (0);\n\tif (strchr(delimiters, in[strlen(in) - 1]) != NULL)\n\t\treturn (-1);\n\tmemcpy(&savedgc, gc, sizeof savedgc);\n\n\tfg = gc->fg;\n\tbg = gc->bg;\n\tattr = gc->attr;\n\tflags = gc->flags;\n\tdo {\n\t\tend = strcspn(in, delimiters);\n\t\tif (end > (sizeof tmp) - 1)\n\t\t\tgoto error;\n\t\tmemcpy(tmp, in, end);\n\t\ttmp[end] = '\\0';\n\n\t\tif (strcasecmp(tmp, \"default\") == 0) {\n\t\t\tfg = defgc->fg;\n\t\t\tbg = defgc->bg;\n\t\t\tattr = defgc->attr;\n\t\t\tflags &= ~(GRID_FLAG_FG256|GRID_FLAG_BG256);\n\t\t\tflags |=\n\t\t\t    defgc->flags & (GRID_FLAG_FG256|GRID_FLAG_BG256);\n\t\t} else if (end > 3 && strncasecmp(tmp + 1, \"g=\", 2) == 0) {\n\t\t\tif ((val = colour_fromstring(tmp + 3)) == -1)\n\t\t\t\tgoto error;\n\t\t\tif (*in == 'f' || *in == 'F') {\n\t\t\t\tif (val != 8) {\n\t\t\t\t\tif (val & 0x100) {\n\t\t\t\t\t\tflags |= GRID_FLAG_FG256;\n\t\t\t\t\t\tval &= ~0x100;\n\t\t\t\t\t} else\n\t\t\t\t\t\tflags &= ~GRID_FLAG_FG256;\n\t\t\t\t\tfg = val;\n\t\t\t\t} else {\n\t\t\t\t\tfg = defgc->fg;\n\t\t\t\t\tflags &= ~GRID_FLAG_FG256;\n\t\t\t\t\tflags |= defgc->flags & GRID_FLAG_FG256;\n\t\t\t\t}\n\t\t\t} else if (*in == 'b' || *in == 'B') {\n\t\t\t\tif (val != 8) {\n\t\t\t\t\tif (val & 0x100) {\n\t\t\t\t\t\tflags |= GRID_FLAG_BG256;\n\t\t\t\t\t\tval &= ~0x100;\n\t\t\t\t\t} else\n\t\t\t\t\t\tflags &= ~GRID_FLAG_BG256;\n\t\t\t\t\tbg = val;\n\t\t\t\t} else {\n\t\t\t\t\tbg = defgc->bg;\n\t\t\t\t\tflags &= ~GRID_FLAG_BG256;\n\t\t\t\t\tflags |= defgc->flags & GRID_FLAG_BG256;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tgoto error;\n\t\t} else if (strcasecmp(tmp, \"none\") == 0)\n\t\t\tattr = 0;\n\t\telse if (end > 2 && strncasecmp(tmp, \"no\", 2) == 0) {\n\t\t\tif ((val = attributes_fromstring(tmp + 2)) == -1)\n\t\t\t\tgoto error;\n\t\t\tattr &= ~val;\n\t\t} else {\n\t\t\tif ((val = attributes_fromstring(tmp)) == -1)\n\t\t\t\tgoto error;\n\t\t\tattr |= val;\n\t\t}\n\n\t\tin += end + strspn(in + end, delimiters);\n\t} while (*in != '\\0');\n\tgc->fg = fg;\n\tgc->bg = bg;\n\tgc->attr = attr;\n\tgc->flags = flags;\n\n\treturn (0);\n\nerror:\n\tmemcpy(gc, &savedgc, sizeof *gc);\n\treturn (-1);\n}\n\n/* Convert style to a string. */\nconst char *\nstyle_tostring(struct grid_cell *gc)\n{\n\tint\t\t c, off = 0, comma = 0;\n\tstatic char\t s[256];\n\n\t*s = '\\0';\n\n\tif (gc->fg != 8 || gc->flags & GRID_FLAG_FG256) {\n\t\tif (gc->flags & GRID_FLAG_FG256)\n\t\t\tc = gc->fg | 0x100;\n\t\telse\n\t\t\tc = gc->fg;\n\t\toff += xsnprintf(s, sizeof s, \"fg=%s\", colour_tostring(c));\n\t\tcomma = 1;\n\t}\n\n\tif (gc->bg != 8 || gc->flags & GRID_FLAG_BG256) {\n\t\tif (gc->flags & GRID_FLAG_BG256)\n\t\t\tc = gc->bg | 0x100;\n\t\telse\n\t\t\tc = gc->bg;\n\t\toff += xsnprintf(s + off, sizeof s - off, \"%sbg=%s\",\n\t\t    comma ? \",\" : \"\", colour_tostring(c));\n\t\tcomma = 1;\n\t}\n\n\tif (gc->attr != 0 && gc->attr != GRID_ATTR_CHARSET) {\n\t\txsnprintf(s + off, sizeof s - off, \"%s%s\",\n\t\t    comma ? \",\" : \"\", attributes_tostring(gc->attr));\n\t}\n\n\tif (*s == '\\0')\n\t\treturn (\"default\");\n\treturn (s);\n}\n\n/* Synchronize new -style option with the old one. */\nvoid\nstyle_update_new(struct options *oo, const char *name, const char *newname)\n{\n\tint\t\t\t value;\n\tstruct grid_cell\t*gc;\n\tstruct options_entry\t*o;\n\n\t/* It's a colour or attribute, but with no -style equivalent. */\n\tif (newname == NULL)\n\t\treturn;\n\n\to = options_find1(oo, newname);\n\tif (o == NULL)\n\t\to = options_set_style(oo, newname, \"default\", 0);\n\tgc = &o->style;\n\n\to = options_find1(oo, name);\n\tif (o == NULL)\n\t\to = options_set_number(oo, name, 8);\n\tvalue = o->num;\n\n\tif (strstr(name, \"-bg\") != NULL)\n\t\tcolour_set_bg(gc, value);\n\telse if (strstr(name, \"-fg\") != NULL)\n\t\tcolour_set_fg(gc, value);\n\telse if (strstr(name, \"-attr\") != NULL)\n\t\tgc->attr = value;\n}\n\n/* Synchronize all the old options with the new -style one. */\nvoid\nstyle_update_old(struct options *oo, const char *name, struct grid_cell *gc)\n{\n\tchar\tnewname[128];\n\tint\tc, size;\n\n\tsize = strrchr(name, '-') - name;\n\n\tif (gc->flags & GRID_FLAG_BG256)\n\t\tc = gc->bg | 0x100;\n\telse\n\t\tc = gc->bg;\n\txsnprintf(newname, sizeof newname, \"%.*s-bg\", size, name);\n\toptions_set_number(oo, newname, c);\n\n\tif (gc->flags & GRID_FLAG_FG256)\n\t\tc = gc->fg | 0x100;\n\telse\n\t\tc = gc->fg;\n\txsnprintf(newname, sizeof newname, \"%.*s-fg\", size, name);\n\toptions_set_number(oo, newname, c);\n\n\txsnprintf(newname, sizeof newname, \"%.*s-attr\", size, name);\n\toptions_set_number(oo, newname, gc->attr);\n}\n\n/* Apply a style. */\nvoid\nstyle_apply(struct grid_cell *gc, struct options *oo, const char *name)\n{\n\tstruct grid_cell\t*gcp;\n\n\tmemcpy(gc, &grid_default_cell, sizeof *gc);\n\tgcp = options_get_style(oo, name);\n\tif (gcp->flags & GRID_FLAG_FG256)\n\t\tcolour_set_fg(gc, gcp->fg | 0x100);\n\telse\n\t\tcolour_set_fg(gc, gcp->fg);\n\tif (gcp->flags & GRID_FLAG_BG256)\n\t\tcolour_set_bg(gc, gcp->bg | 0x100);\n\telse\n\t\tcolour_set_bg(gc, gcp->bg);\n\tgc->attr |= gcp->attr;\n}\n\n/* Apply a style, updating if default. */\nvoid\nstyle_apply_update(struct grid_cell *gc, struct options *oo, const char *name)\n{\n\tstruct grid_cell\t*gcp;\n\n\tgcp = options_get_style(oo, name);\n\tif (gcp->fg != 8 || gcp->flags & GRID_FLAG_FG256) {\n\t\tif (gcp->flags & GRID_FLAG_FG256)\n\t\t\tcolour_set_fg(gc, gcp->fg | 0x100);\n\t\telse\n\t\t\tcolour_set_fg(gc, gcp->fg);\n\t}\n\tif (gcp->bg != 8 || gcp->flags & GRID_FLAG_BG256) {\n\t\tif (gcp->flags & GRID_FLAG_BG256)\n\t\t\tcolour_set_bg(gc, gcp->bg | 0x100);\n\t\telse\n\t\t\tcolour_set_bg(gc, gcp->bg);\n\t}\n\tif (gcp->attr != 0)\n\t\tgc->attr |= gcp->attr;\n}\n\n/* Check if two styles are the same. */\nint\nstyle_equal(const struct grid_cell *gc1, const struct grid_cell *gc2)\n{\n\treturn gc1->fg == gc2->fg &&\n\t\tgc1->bg == gc2->bg &&\n\t\t(gc1->flags & ~GRID_FLAG_PADDING) ==\n\t\t(gc2->flags & ~GRID_FLAG_PADDING) &&\n\t\t(gc1->attr & ~GRID_ATTR_CHARSET) ==\n\t\t(gc2->attr & ~GRID_ATTR_CHARSET);\n}\n"
        },
        {
          "name": "tmate-debug.c",
          "type": "blob",
          "size": 2.0849609375,
          "content": "#ifdef HAVE_EXECINFO_H\n#include <execinfo.h>\n#endif\n#include <stdio.h>\n#include <stdlib.h>\n#include <regex.h>\n#include <signal.h>\n#include \"tmate.h\"\n\n#ifndef HAVE_BACKTRACE\n\nvoid tmate_print_stack_trace(void) {}\nvoid tmate_catch_sigsegv(void) {}\nvoid tmate_preload_trace_lib(void) {}\n\n#else\n\n#if DEBUG\n\nstatic int print_resolved_stack_frame(const char *frame)\n{\n\tchar file[100];\n\tchar cmd[200];\n\tchar output[300];\n\tchar address[20];\n\tchar *line;\n\tFILE *ps;\n\n\tstatic regex_t _regex;\n\tstatic regex_t *regex;\n\tregmatch_t matches[3];\n\n\tif (!regex) {\n\t\tif (regcomp(&_regex, \"(.+)\\\\(\\\\) \\\\[([^]]+)\\\\]\", REG_EXTENDED))\n\t\t\treturn -1;\n\t\tregex = &_regex;\n\t}\n\n\tif (regexec(regex, frame, 3, matches, 0))\n\t\treturn -1;\n\n\tmemcpy(file, &frame[matches[1].rm_so], matches[1].rm_eo - matches[1].rm_so);\n\tfile[matches[1].rm_eo - matches[1].rm_so] = 0;\n\n\tmemcpy(address, &frame[matches[2].rm_so], matches[2].rm_eo - matches[2].rm_so);\n\taddress[matches[2].rm_eo - matches[2].rm_so] = 0;\n\n\tsprintf(cmd, \"addr2line -e %s %s -f -p -s\", file, address);\n\n\tps = popen(cmd, \"r\");\n\tif (!ps)\n\t\treturn -1;\n\n\tline = fgets(output, sizeof(output), ps);\n\tpclose(ps);\n\n\tif (!line)\n\t\treturn -1;\n\n\tline[strlen(line)-1] = 0; /* remove \\n */\n\ttmate_debug(\"%s(%s) [%s]\", file, line, address);\n\treturn 0;\n}\n#endif\n\nvoid tmate_print_stack_trace(void)\n{\n\tvoid *array[20];\n\tsize_t size;\n\tchar **strings;\n\tsize_t i;\n\n\tsize = backtrace (array, 20);\n\tstrings = backtrace_symbols (array, size);\n\n\ttmate_info (\"============ %zd stack frames ============\", size);\n\n\tfor (i = 1; i < size; i++) {\n#if DEBUG\n\t\tif (print_resolved_stack_frame(strings[i]) < 0)\n#endif\n\t\t\ttmate_info(\"%s\", strings[i]);\n\t}\n\n\tfree (strings);\n}\n\nstatic void handle_crash(int sig)\n{\n\t/* TODO send stack trace to server */\n\tconst char *what = sig == SIGSEGV ? \"SIGSEGV\" : \"SIGABRT\";\n\ttmate_info(\"%s printing stack trace\", what);\n\ttmate_print_stack_trace();\n\n\t/* Reraise */\n\tsignal(sig, NULL);\n\tkill(getpid(), sig);\n}\n\nvoid tmate_catch_sigsegv(void)\n{\n\tsignal(SIGSEGV, handle_crash);\n\tsignal(SIGABRT, handle_crash);\n}\n\nvoid tmate_preload_trace_lib(void)\n{\n       void *array[1];\n       backtrace(array, 1);\n}\n\n#endif\n"
        },
        {
          "name": "tmate-decoder.c",
          "type": "blob",
          "size": 4.4150390625,
          "content": "#include \"tmate.h\"\n#include \"tmate-protocol.h\"\n\nstatic void handle_notify(__unused struct tmate_session *session,\n\t\t\t  struct tmate_unpacker *uk)\n{\n\tchar *msg = unpack_string(uk);\n\ttmate_status_message(\"%s\", msg);\n\tfree(msg);\n}\n\nstatic void handle_legacy_pane_key(__unused struct tmate_session *_session,\n\t\t\t\t   struct tmate_unpacker *uk)\n{\n\tstruct session *s;\n\tstruct window *w;\n\tstruct window_pane *wp;\n\n\tint key = unpack_int(uk);\n\n\ts = RB_MIN(sessions, &sessions);\n\tif (!s)\n\t\treturn;\n\n\tw = s->curw->window;\n\tif (!w)\n\t\treturn;\n\n\twp = w->active;\n\tif (!wp)\n\t\treturn;\n\n\twindow_pane_key(wp, NULL, s, key, NULL);\n}\n\nstatic struct window_pane *find_window_pane(struct session *s, int pane_id)\n{\n\tstruct window *w;\n\n\tif (pane_id != -1)\n\t\treturn window_pane_find_by_id(pane_id);\n\n\tw = s->curw->window;\n\tif (!w)\n\t\treturn NULL;\n\n\treturn w->active;\n}\n\nstatic void handle_pane_key(__unused struct tmate_session *_session,\n\t\t\t    struct tmate_unpacker *uk)\n{\n\tstruct session *s;\n\tstruct window_pane *wp;\n\n\tint pane_id = unpack_int(uk);\n\tkey_code key = unpack_int(uk);\n\n\ts = RB_MIN(sessions, &sessions);\n\tif (!s)\n\t\treturn;\n\n\twp = find_window_pane(s, pane_id);\n\tif (!wp)\n\t\treturn;\n\n\twindow_pane_key(wp, NULL, s, key, NULL);\n}\n\nstatic void handle_resize(struct tmate_session *session,\n\t\t\t  struct tmate_unpacker *uk)\n{\n\tsession->min_sx = unpack_int(uk);\n\tsession->min_sy = unpack_int(uk);\n\trecalculate_sizes();\n}\n\nextern char\t\t**cfg_causes;\nextern u_int\t\t  cfg_ncauses;\n\nstatic void handle_exec_cmd_str(__unused struct tmate_session *session,\n\t\t\t\tstruct tmate_unpacker *uk)\n{\n\tstruct cmd_q *cmd_q;\n\tstruct cmd_list *cmdlist;\n\tchar *cause;\n\tu_int i;\n\n\tint client_id = unpack_int(uk);\n\tchar *cmd_str = unpack_string(uk);\n\n\tif (cmd_string_parse(cmd_str, &cmdlist, NULL, 0, &cause) != 0) {\n\t\ttmate_failed_cmd(client_id, cause);\n\t\tfree(cause);\n\t\tgoto out;\n\t}\n\n\tcmd_q = cmdq_new(NULL);\n\tcmdq_run(cmd_q, cmdlist, NULL);\n\tcmd_list_free(cmdlist);\n\tcmdq_free(cmd_q);\n\n\t/* error messages land in cfg_causes */\n\tfor (i = 0; i < cfg_ncauses; i++) {\n\t\ttmate_failed_cmd(client_id, cfg_causes[i]);\n\t\tfree(cfg_causes[i]);\n\t}\n\n\tfree(cfg_causes);\n\tcfg_causes = NULL;\n\tcfg_ncauses = 0;\n\nout:\n\tfree(cmd_str);\n}\n\nstatic void handle_exec_cmd(__unused struct tmate_session *session,\n\t\t\t    struct tmate_unpacker *uk)\n{\n\tstruct cmd_q *cmd_q;\n\tstruct cmd_list *cmdlist;\n\tstruct cmd *cmd;\n\tchar *cause;\n\tu_int i;\n\tunsigned int argc;\n\tchar **argv;\n\n\tint client_id = unpack_int(uk);\n\n\targc = uk->argc;\n\targv = xmalloc(sizeof(char *) * argc);\n\tfor (i = 0; i < argc; i++)\n\t\targv[i] = unpack_string(uk);\n\n\tcmd = cmd_parse(argc, argv, NULL, 0, &cause);\n\tif (!cmd) {\n\t\ttmate_failed_cmd(client_id, cause);\n\t\tfree(cause);\n\t\tgoto out;\n\t}\n\n\tcmdlist = xcalloc(1, sizeof *cmdlist);\n\tcmdlist->references = 1;\n\tTAILQ_INIT(&cmdlist->list);\n\tTAILQ_INSERT_TAIL(&cmdlist->list, cmd, qentry);\n\n\tcmd_q = cmdq_new(NULL);\n\tcmdq_run(cmd_q, cmdlist, NULL);\n\tcmd_list_free(cmdlist);\n\tcmdq_free(cmd_q);\n\n\t/* error messages land in cfg_causes */\n\tfor (i = 0; i < cfg_ncauses; i++) {\n\t\ttmate_failed_cmd(client_id, cfg_causes[i]);\n\t\tfree(cfg_causes[i]);\n\t}\n\n\tfree(cfg_causes);\n\tcfg_causes = NULL;\n\tcfg_ncauses = 0;\n\nout:\n\tcmd_free_argv(argc, argv);\n}\n\nstatic void maybe_save_reconnection_data(struct tmate_session *session,\n\t\t\t\tconst char *name, const char *value)\n{\n\tif (!strcmp(name, \"tmate_reconnection_data\")) {\n\t\tfree(session->reconnection_data);\n\t\tsession->reconnection_data = xstrdup(value);\n\t}\n}\n\nstatic void handle_set_env(struct tmate_session *session,\n\t\t\t   struct tmate_unpacker *uk)\n{\n\tchar *name = unpack_string(uk);\n\tchar *value = unpack_string(uk);\n\n\ttmate_set_env(name, value);\n\tmaybe_save_reconnection_data(session, name, value);\n\n\tfree(name);\n\tfree(value);\n}\n\nstatic void handle_ready(struct tmate_session *session,\n\t\t\t __unused struct tmate_unpacker *uk)\n{\n\tsession->tmate_env_ready = 1;\n\tsignal_waiting_clients(\"tmate-ready\");\n}\n\nvoid tmate_dispatch_slave_message(struct tmate_session *session,\n\t\t\t\t  struct tmate_unpacker *uk)\n{\n\tint cmd = unpack_int(uk);\n\tswitch (cmd) {\n#define dispatch(c, f) case c: f(session, uk); break\n\tdispatch(TMATE_IN_NOTIFY,\t\thandle_notify);\n\tdispatch(TMATE_IN_LEGACY_PANE_KEY,\thandle_legacy_pane_key);\n\tdispatch(TMATE_IN_RESIZE,\t\thandle_resize);\n\tdispatch(TMATE_IN_EXEC_CMD_STR,\t\thandle_exec_cmd_str);\n\tdispatch(TMATE_IN_SET_ENV,\t\thandle_set_env);\n\tdispatch(TMATE_IN_READY,\t\thandle_ready);\n\tdispatch(TMATE_IN_PANE_KEY,\t\thandle_pane_key);\n\tdispatch(TMATE_IN_EXEC_CMD,\t\thandle_exec_cmd);\n\tdefault: tmate_info(\"Bad message type: %d\", cmd);\n\t}\n}\n"
        },
        {
          "name": "tmate-encoder.c",
          "type": "blob",
          "size": 10.06640625,
          "content": "#include <sys/utsname.h>\n#include \"tmate.h\"\n#include \"tmate-protocol.h\"\n#include \"window-copy.h\"\n\n#define pack(what, ...) _pack(&tmate_session.encoder, what, ##__VA_ARGS__)\n\nvoid tmate_write_header(void)\n{\n\tpack(array, 3);\n\tpack(int, TMATE_OUT_HEADER);\n\tpack(int, TMATE_PROTOCOL_VERSION);\n\tpack(string, VERSION);\n}\n\nvoid tmate_write_uname(void)\n{\n\tstruct utsname name;\n\tif (uname(&name) < 0) {\n\t\ttmate_debug(\"uname() failed\");\n\t\treturn;\n\t}\n\n\tpack(array, 6);\n\tpack(int, TMATE_OUT_UNAME);\n\tpack(string, name.sysname);\n\tpack(string, name.nodename);\n\tpack(string, name.release);\n\tpack(string, name.version);\n\tpack(string, name.machine);\n}\n\nvoid tmate_write_ready(void)\n{\n\tpack(array, 1);\n\tpack(int, TMATE_OUT_READY);\n}\n\nvoid tmate_sync_layout(void)\n{\n\tstruct session *s;\n\tstruct winlink *wl;\n\tstruct window *w;\n\tstruct window_pane *wp;\n\tint num_panes = 0;\n\tint num_windows = 0;\n\tint active_pane_id;\n\tint active_window_idx = -1;\n\n\t/*\n\t * TODO this can get a little heavy.\n\t * We are shipping the full layout whenever a window name changes,\n\t * that is, at every shell command.\n\t * Might be better to do something incremental.\n\t */\n\n\t/*\n\t * We only allow one session, it makes our lives easier.\n\t * Especially when the HTML5 client will come along.\n\t * We make no distinction between a winlink and its window except\n\t * that we send the winlink idx to draw the status bar properly.\n\t */\n\n\ts = RB_MIN(sessions, &sessions);\n\tif (!s)\n\t\treturn;\n\n\tnum_windows = 0;\n\tRB_FOREACH(wl, winlinks, &s->windows) {\n\t\tif (wl->window)\n\t\t\tnum_windows++;\n\t}\n\n\tif (!num_windows)\n\t\treturn;\n\n\tpack(array, 5);\n\tpack(int, TMATE_OUT_SYNC_LAYOUT);\n\n\tpack(int, s->sx);\n\tpack(int, s->sy);\n\n\tpack(array, num_windows);\n\tRB_FOREACH(wl, winlinks, &s->windows) {\n\t\tw = wl->window;\n\t\tif (!w)\n\t\t\tcontinue;\n\n\t\tw->tmate_last_sync_active_pane = NULL;\n\t\tactive_pane_id = -1;\n\n\t\tif (active_window_idx == -1)\n\t\t\tactive_window_idx = wl->idx;\n\n\t\tpack(array, 4);\n\t\tpack(int, wl->idx);\n\t\tpack(string, w->name);\n\n\t\tnum_panes = 0;\n\t\tTAILQ_FOREACH(wp, &w->panes, entry)\n\t\t\tnum_panes++;\n\n\t\tpack(array, num_panes);\n\t\tTAILQ_FOREACH(wp, &w->panes, entry) {\n\t\t\tpack(array, 5);\n\t\t\tpack(int, wp->id);\n\t\t\tpack(int, wp->sx);\n\t\t\tpack(int, wp->sy);\n\t\t\tpack(int, wp->xoff);\n\t\t\tpack(int, wp->yoff);\n\n\t\t\tif (wp == w->active) {\n\t\t\t\tw->tmate_last_sync_active_pane = wp;\n\t\t\t\tactive_pane_id = wp->id;\n\t\t\t}\n\n\t\t}\n\t\tpack(int, active_pane_id);\n\t}\n\n\tif (s->curw)\n\t\tactive_window_idx = s->curw->idx;\n\n\tpack(int, active_window_idx);\n}\n\n/* TODO add a buffer for pty_data ? */\n\n#define TMATE_MAX_PTY_SIZE (16*1024)\n\nvoid tmate_pty_data(struct window_pane *wp, const char *buf, size_t len)\n{\n\tsize_t to_write;\n\n\twhile (len > 0) {\n\t\tto_write = len < TMATE_MAX_PTY_SIZE ? len : TMATE_MAX_PTY_SIZE;\n\n\t\tpack(array, 3);\n\t\tpack(int, TMATE_OUT_PTY_DATA);\n\t\tpack(int, wp->id);\n\t\tpack(str, to_write);\n\t\tpack(str_body, buf, to_write);\n\n\t\tbuf += to_write;\n\t\tlen -= to_write;\n\t}\n}\n\nextern const struct cmd_entry cmd_bind_key_entry;\nextern const struct cmd_entry cmd_unbind_key_entry;\nextern const struct cmd_entry cmd_set_option_entry;\nextern const struct cmd_entry cmd_set_window_option_entry;\n\nstatic const struct cmd_entry *replicated_cmds[] = {\n\t&cmd_bind_key_entry,\n\t&cmd_unbind_key_entry,\n\t&cmd_set_option_entry,\n\t&cmd_set_window_option_entry,\n\tNULL\n};\n\nint tmate_should_replicate_cmd(const struct cmd_entry *cmd)\n{\n\tconst struct cmd_entry **ptr;\n\n\tfor (ptr = replicated_cmds; *ptr; ptr++)\n\t\tif (*ptr == cmd)\n\t\t\treturn 1;\n\treturn 0;\n}\n\n#define sc (&session->saved_tmux_cmds)\n#define SAVED_TMUX_CMD_INITIAL_SIZE 256\nstatic void __tmate_exec_cmd_args(int argc, const char **argv);\n\nstatic void append_saved_cmd(struct tmate_session *session,\n\t\t\t     int argc, const char **argv)\n{\n\tif (!sc->cmds) {\n\t\tsc->capacity = SAVED_TMUX_CMD_INITIAL_SIZE;\n\t\tsc->cmds = xmalloc(sizeof(*sc->cmds) * sc->capacity);\n\t\tsc->tail = 0;\n\t}\n\n\tif (sc->tail == sc->capacity) {\n\t\tsc->capacity *= 2;\n\t\tsc->cmds = xrealloc(sc->cmds, sizeof(*sc->cmds) * sc->capacity);\n\t}\n\n\tsc->cmds[sc->tail].argc = argc;\n\tsc->cmds[sc->tail].argv = cmd_copy_argv(argc, (char **)argv);\n\n\tsc->tail++;\n}\n\nstatic void replay_saved_cmd(struct tmate_session *session)\n{\n\tunsigned int i;\n\tfor (i = 0; i < sc->tail; i++)\n\t\t__tmate_exec_cmd_args(sc->cmds[i].argc, (const char **)sc->cmds[i].argv);\n}\n#undef sc\n\nstruct args_entry {\n\tu_char\t\t\t flag;\n\tchar\t\t\t*value;\n\tRB_ENTRY(args_entry)\t entry;\n};\n\nstatic void extract_cmd(struct cmd *cmd, int *_argc, char ***_argv)\n{\n\tstruct args_entry *entry;\n\tstruct args* args = cmd->args;\n\tint argc = 0;\n\tchar **argv;\n\tint next = 0, i;\n\n\targc++; /* cmd name */\n\tRB_FOREACH(entry, args_tree, &args->tree) {\n\t\targc++;\n\t\tif (entry->value != NULL)\n\t\t\targc++;\n\t}\n\targc += args->argc;\n\targv = xmalloc(sizeof(char *) * argc);\n\n\targv[next++] = xstrdup(cmd->entry->name);\n\n\tRB_FOREACH(entry, args_tree, &args->tree) {\n\t\txasprintf(&argv[next++], \"-%c\", entry->flag);\n\t\tif (entry->value != NULL)\n\t\t\targv[next++] = xstrdup(entry->value);\n\t}\n\n\tfor (i = 0; i < args->argc; i++)\n\t\targv[next++] = xstrdup(args->argv[i]);\n\n\t*_argc = argc;\n\t*_argv = argv;\n}\n\nstatic void __tmate_exec_cmd_args(int argc, const char **argv)\n{\n\tint i;\n\n\tpack(array, argc + 1);\n\tpack(int, TMATE_OUT_EXEC_CMD);\n\n\tfor (i = 0; i < argc; i++)\n\t\tpack(string, argv[i]);\n}\n\nvoid tmate_exec_cmd_args(int argc, const char **argv)\n{\n\t__tmate_exec_cmd_args(argc, argv);\n\tappend_saved_cmd(&tmate_session, argc, argv);\n}\n\nvoid tmate_set_val(const char *name, const char *value)\n{\n\tchar *buf;\n\txasprintf(&buf, \"%s=%s\", name, value);\n\ttmate_exec_cmd_args(3, (const char *[]){\"set-option\", \"tmate-set\", buf});\n\tfree(buf);\n}\n\nvoid tmate_exec_cmd(struct cmd *cmd)\n{\n\tint argc;\n\tchar **argv;\n\n\textract_cmd(cmd, &argc, &argv);\n\ttmate_exec_cmd_args(argc, (const char **)argv);\n\tcmd_free_argv(argc, argv);\n}\n\nvoid tmate_failed_cmd(int client_id, const char *cause)\n{\n\tpack(array, 3);\n\tpack(int, TMATE_OUT_FAILED_CMD);\n\tpack(int, client_id);\n\tpack(string, cause);\n}\n\nvoid tmate_status(const char *left, const char *right)\n{\n\tstatic char *old_left, *old_right;\n\n\tif (old_left  && !strcmp(old_left,  left) &&\n\t    old_right && !strcmp(old_right, right))\n\t\treturn;\n\n\tpack(array, 3);\n\tpack(int, TMATE_OUT_STATUS);\n\tpack(string, left);\n\tpack(string, right);\n\n\tfree(old_left);\n\tfree(old_right);\n\told_left = xstrdup(left);\n\told_right = xstrdup(right);\n}\n\nvoid tmate_sync_copy_mode(struct window_pane *wp)\n{\n\tstruct window_copy_mode_data *data = wp->modedata;\n\n\tpack(array, 3);\n\tpack(int, TMATE_OUT_SYNC_COPY_MODE);\n\n\tpack(int, wp->id);\n\n\tif (wp->mode != &window_copy_mode ||\n\t    data->inputtype == WINDOW_COPY_PASSWORD) {\n\t\tpack(array, 0);\n\t\treturn;\n\t}\n\tpack(array, 6);\n\tpack(int, data->backing == &wp->base);\n\n\tpack(int, data->oy);\n\tpack(int, data->cx);\n\tpack(int, data->cy);\n\n\tif (data->screen.sel.flag) {\n\t\tpack(array, 3);\n\t\tpack(int, data->selx);\n\t\tpack(int, -data->sely + screen_hsize(data->backing)\n\t\t\t\t      + screen_size_y(data->backing) - 1);\n\t\tpack(int, data->rectflag);\n\t} else\n\t\tpack(array, 0);\n\n\tif (data->inputprompt) {\n\t\tpack(array, 3);\n\t\tpack(int, data->inputtype);\n\t\tpack(string, data->inputprompt);\n\t\tpack(string, data->inputstr);\n\t} else\n\t\tpack(array, 0);\n}\n\nvoid tmate_write_copy_mode(struct window_pane *wp, const char *str)\n{\n\tpack(array, 3);\n\tpack(int, TMATE_OUT_WRITE_COPY_MODE);\n\tpack(int, wp->id);\n\tpack(string, str);\n}\n\nvoid tmate_write_fin(void)\n{\n\tpack(array, 1);\n\tpack(int, TMATE_OUT_FIN);\n}\n\nstatic void do_snapshot_grid(struct grid *grid, unsigned int max_history_lines)\n{\n\tstruct grid_line *line;\n\tstruct grid_cell gc;\n\tunsigned int line_i, i;\n\tunsigned int max_lines;\n\tsize_t str_len;\n\n\tmax_lines = max_history_lines + grid->sy;\n\n#define grid_num_lines(grid) (grid->hsize + grid->sy)\n\n\tif (grid_num_lines(grid) > max_lines)\n\t\tline_i = grid_num_lines(grid) - max_lines;\n\telse\n\t\tline_i = 0;\n\n\tpack(array, grid_num_lines(grid) - line_i);\n\tfor (; line_i < grid_num_lines(grid); line_i++) {\n\t\tline = &grid->linedata[line_i];\n\n\t\tpack(array, 2);\n\t\tstr_len = 0;\n\t\tfor (i = 0; i < line->cellsize; i++) {\n\t\t\tgrid_get_cell(grid, i, line_i, &gc);\n\t\t\tstr_len += gc.data.size;\n\t\t}\n\n\t\tpack(str, str_len);\n\t\tfor (i = 0; i < line->cellsize; i++) {\n\t\t\tgrid_get_cell(grid, i, line_i, &gc);\n\t\t\tpack(str_body, gc.data.data, gc.data.size);\n\t\t}\n\n\t\tpack(array, line->cellsize);\n\t\tfor (i = 0; i < line->cellsize; i++) {\n\t\t\tgrid_get_cell(grid, i, line_i, &gc);\n\t\t\tpack(unsigned_int, ((gc.flags << 24) |\n\t\t\t\t\t    (gc.attr  << 16) |\n\t\t\t\t\t    (gc.bg    << 8)  |\n\t\t\t\t\t     gc.fg        ));\n\t\t}\n\t}\n\n}\n\nstatic void do_snapshot_pane(struct window_pane *wp, unsigned int max_history_lines)\n{\n\tstruct screen *screen = &wp->base;\n\n\tpack(array, 4);\n\tpack(int, wp->id);\n\n\tpack(unsigned_int, screen->mode);\n\n\tpack(array, 3);\n\tpack(int, screen->cx);\n\tpack(int, screen->cy);\n\tdo_snapshot_grid(screen->grid, max_history_lines);\n\n\tif (wp->saved_grid) {\n\t\tpack(array, 3);\n\t\tpack(int, wp->saved_cx);\n\t\tpack(int, wp->saved_cy);\n\t\tdo_snapshot_grid(wp->saved_grid, max_history_lines);\n\t} else {\n\t\tpack(nil);\n\t}\n}\n\nstatic void tmate_send_session_snapshot(unsigned int max_history_lines)\n{\n\tstruct session *s;\n\tstruct winlink *wl;\n\tstruct window *w;\n\tstruct window_pane *pane;\n\tint num_panes;\n\n\tpack(array, 2);\n\tpack(int, TMATE_OUT_SNAPSHOT);\n\n\ts = RB_MIN(sessions, &sessions);\n\tif (!s)\n\t\ttmate_fatal(\"no session?\");\n\n\tnum_panes = 0;\n\tRB_FOREACH(wl, winlinks, &s->windows) {\n\t\tw = wl->window;\n\t\tif (!w)\n\t\t\tcontinue;\n\n\t\tTAILQ_FOREACH(pane, &w->panes, entry)\n\t\t\tnum_panes++;\n\t}\n\n\tpack(array, num_panes);\n\tRB_FOREACH(wl, winlinks, &s->windows) {\n\t\tw = wl->window;\n\t\tif (!w)\n\t\t\tcontinue;\n\n\t\tTAILQ_FOREACH(pane, &w->panes, entry)\n\t\t\tdo_snapshot_pane(pane, max_history_lines);\n\t}\n}\n\nstatic void tmate_send_reconnection_data(struct tmate_session *session)\n{\n\tif (!session->reconnection_data)\n\t\treturn;\n\n\tpack(array, 2);\n\tpack(int, TMATE_OUT_RECONNECT);\n\tpack(string, session->reconnection_data);\n}\n\n#define RECONNECTION_MAX_HISTORY_LINE 300\n\nvoid tmate_send_reconnection_state(struct tmate_session *session)\n{\n\t/* Start with a fresh encoder */\n\ttmate_encoder_destroy(&session->encoder);\n\ttmate_encoder_init(&session->encoder, NULL, session);\n\n\ttmate_write_header();\n\ttmate_send_reconnection_data(session);\n\treplay_saved_cmd(session);\n\t/* TODO send all option variables */\n\ttmate_write_uname();\n\ttmate_write_ready();\n\n\ttmate_sync_layout();\n\ttmate_send_session_snapshot(RECONNECTION_MAX_HISTORY_LINE);\n}\n"
        },
        {
          "name": "tmate-env.c",
          "type": "blob",
          "size": 0.75,
          "content": "#include \"tmate.h\"\n\nstruct tmate_env {\n\tTAILQ_ENTRY(tmate_env) entry;\n\tchar *name;\n\tchar *value;\n};\n\nTAILQ_HEAD(, tmate_env) tmate_env_list;\n\nvoid tmate_set_env(const char *name, const char *value)\n{\n\tstruct tmate_env *tmate_env;\n\n\tTAILQ_FOREACH(tmate_env, &tmate_env_list, entry) {\n\t\tif (!strcmp(tmate_env->name, name)) {\n\t\t\tfree(tmate_env->value);\n\t\t\ttmate_env->value = xstrdup(value);\n\t\t\treturn;\n\t\t}\n\t}\n\n\ttmate_env = xmalloc(sizeof(*tmate_env));\n\ttmate_env->name = xstrdup(name);\n\ttmate_env->value = xstrdup(value);\n\tTAILQ_INSERT_HEAD(&tmate_env_list, tmate_env, entry);\n}\n\nvoid tmate_format(struct format_tree *ft)\n{\n\tstruct tmate_env *tmate_env;\n\n\tTAILQ_FOREACH(tmate_env, &tmate_env_list, entry) {\n\t\tformat_add(ft, tmate_env->name, \"%s\", tmate_env->value);\n\t}\n}\n"
        },
        {
          "name": "tmate-msg.c",
          "type": "blob",
          "size": 2.0869140625,
          "content": "#include <time.h>\n#include \"tmate.h\"\n\nvoid status_message_callback(int, short, void *);\n\n/* Very similar to status.c:status_message_set */\n\nstatic void tmate_status_message_client(struct client *c, const char *message)\n{\n\tstruct timeval\t\t tv;\n\tstruct message_entry\t*msg, *msg1;\n\tint\t\t\t delay;\n\tu_int\t\t\t limit;\n\n\tlimit = options_get_number(global_options, \"message-limit\");\n\tdelay = options_get_number(c->session ? c->session->options : global_s_options,\n\t\t\t\t   \"tmate-display-time\");\n\n\tstatus_prompt_clear(c);\n\tstatus_message_clear(c);\n\n\txasprintf(&c->message_string, \"[tmate] %s\", message);\n\n\tmsg = xcalloc(1, sizeof *msg);\n\tmsg->msg_time = time(NULL);\n\tmsg->msg_num = c->message_next++;\n\tmsg->msg = xstrdup(c->message_string);\n\tTAILQ_INSERT_TAIL(&c->message_log, msg, entry);\n\n\tTAILQ_FOREACH_SAFE(msg, &c->message_log, entry, msg1) {\n\t\tif (msg->msg_num + limit >= c->message_next)\n\t\t\tbreak;\n\t\tfree(msg->msg);\n\t\tTAILQ_REMOVE(&c->message_log, msg, entry);\n\t\tfree(msg);\n\t}\n\n\tif (delay > 0) {\n\t\ttv.tv_sec = delay / 1000;\n\t\ttv.tv_usec = (delay % 1000) * 1000L;\n\n\t\tif (event_initialized(&c->message_timer))\n\t\t\tevtimer_del(&c->message_timer);\n\t\tevtimer_set(&c->message_timer, status_message_callback, c);\n\t\tevtimer_add(&c->message_timer, &tv);\n\t}\n\n\tc->flags |= CLIENT_STATUS | CLIENT_FORCE_STATUS;\n\n\trecalculate_sizes();\n}\n\nstatic void tmate_status_message_session(const char *message)\n{\n\tif (tmate_foreground)\n\t\treturn;\n\n\tstruct session *s;\n\ts = RB_MIN(sessions, &sessions);\n\tif (!s) {\n\t\tcfg_add_cause(\"%s\", message);\n\t\treturn;\n\t}\n\n\tstruct window_pane *wp;\n\twp = s->curw->window->active;\n\tif (wp->mode == &window_copy_mode)\n\t\twindow_copy_add(wp, \"%s\", message);\n}\n\nvoid __tmate_status_message(const char *fmt, va_list ap)\n{\n\tstruct client *c;\n\tchar *message;\n\n\txvasprintf(&message, fmt, ap);\n\ttmate_info(\"%s\", message);\n\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (c && !(c->flags & CLIENT_READONLY))\n\t\t\ttmate_status_message_client(c, message);\n\t}\n\n\ttmate_status_message_session(message);\n\n\tfree(message);\n}\n\nvoid tmate_status_message(const char *fmt, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\t__tmate_status_message(fmt, ap);\n\tva_end(ap);\n}\n"
        },
        {
          "name": "tmate-msgpack.c",
          "type": "blob",
          "size": 5.0234375,
          "content": "#include \"tmate.h\"\n#include \"tmate-protocol.h\"\n\nstatic void on_encoder_buffer_ready(__unused evutil_socket_t fd,\n\t\t\t\t    __unused short what, void *arg)\n{\n\tstruct tmate_encoder *encoder = arg;\n\n\tencoder->ev_active = false;\n\tif (encoder->ready_callback)\n\t\tencoder->ready_callback(encoder->userdata, encoder->buffer);\n}\n\nstatic int on_encoder_write(void *userdata, const char *buf, size_t len)\n{\n\tstruct tmate_encoder *encoder = userdata;\n\n\tif (evbuffer_add(encoder->buffer, buf, len) < 0)\n\t\ttmate_fatal(\"Cannot buffer encoded data\");\n\n\tif (!encoder->ev_active) {\n\t\tevent_active(encoder->ev_buffer, EV_READ, 0);\n\t\tencoder->ev_active = true;\n\t}\n\n\treturn 0;\n}\n\n/* Really sad hack, but we can get away with it */\n#define tmate_encoder_from_pk(pk) ((struct tmate_encoder *)pk)\n\nvoid msgpack_pack_string(msgpack_packer *pk, const char *str)\n{\n\tsize_t len = strlen(str);\n\n\tmsgpack_pack_str(pk, len);\n\tmsgpack_pack_str_body(pk, str, len);\n}\n\nvoid msgpack_pack_boolean(msgpack_packer *pk, bool value)\n{\n\tif (value)\n\t\tmsgpack_pack_true(pk);\n\telse\n\t\tmsgpack_pack_false(pk);\n}\n\nvoid tmate_encoder_init(struct tmate_encoder *encoder,\n\t\t\ttmate_encoder_write_cb *callback,\n\t\t\tvoid *userdata)\n{\n\tmsgpack_packer_init(&encoder->pk, encoder, &on_encoder_write);\n\tencoder->buffer = evbuffer_new();\n\tencoder->ready_callback = callback;\n\tencoder->userdata = userdata;\n\n\tif (!encoder->buffer)\n\t\ttmate_fatal(\"Can't allocate buffer\");\n\n\tencoder->ev_buffer = event_new(tmate_session.ev_base, -1,\n\t\tEV_READ | EV_PERSIST, on_encoder_buffer_ready, encoder);\n\tif (!encoder->ev_buffer)\n\t\ttmate_fatal(\"Can't allocate event\");\n\n\tevent_add(encoder->ev_buffer, NULL);\n\n\tencoder->ev_active = false;\n}\n\nvoid tmate_encoder_destroy(struct tmate_encoder *encoder)\n{\n\t/* encoder->pk doesn't need any cleanup */\n\tevbuffer_free(encoder->buffer);\n\tevent_del(encoder->ev_buffer);\n\tevent_free(encoder->ev_buffer);\n\tmemset(encoder, 0, sizeof(*encoder));\n}\n\nvoid tmate_encoder_set_ready_callback(struct tmate_encoder *encoder,\n\t\t\t\t      tmate_encoder_write_cb *callback,\n\t\t\t\t      void *userdata)\n{\n\tencoder->ready_callback = callback;\n\tencoder->userdata = userdata;\n\tif (encoder->ready_callback)\n\t\tencoder->ready_callback(encoder->userdata, encoder->buffer);\n}\n\nvoid tmate_decoder_error(void)\n{\n\t/* TODO Don't kill the session, disconnect */\n\ttmate_print_stack_trace();\n\ttmate_fatal(\"Received a bad message\");\n}\n\nvoid init_unpacker(struct tmate_unpacker *uk, msgpack_object obj)\n{\n\tif (obj.type != MSGPACK_OBJECT_ARRAY)\n\t\ttmate_decoder_error();\n\n\tuk->argv = obj.via.array.ptr;\n\tuk->argc = obj.via.array.size;\n}\n\nint64_t unpack_int(struct tmate_unpacker *uk)\n{\n\tint64_t val;\n\n\tif (uk->argc == 0)\n\t\ttmate_decoder_error();\n\n\tif (uk->argv[0].type != MSGPACK_OBJECT_POSITIVE_INTEGER &&\n\t    uk->argv[0].type != MSGPACK_OBJECT_NEGATIVE_INTEGER)\n\t\ttmate_decoder_error();\n\n\tval = uk->argv[0].via.i64;\n\n\tuk->argv++;\n\tuk->argc--;\n\n\treturn val;\n}\n\nbool unpack_bool(struct tmate_unpacker *uk)\n{\n\tbool val;\n\n\tif (uk->argc == 0)\n\t\ttmate_decoder_error();\n\n\tif (uk->argv[0].type != MSGPACK_OBJECT_BOOLEAN)\n\t\ttmate_decoder_error();\n\n\tval = uk->argv[0].via.boolean;\n\n\tuk->argv++;\n\tuk->argc--;\n\n\treturn val;\n}\n\nvoid unpack_buffer(struct tmate_unpacker *uk, const char **buf, size_t *len)\n{\n\tif (uk->argc == 0)\n\t\ttmate_decoder_error();\n\n\tif (uk->argv[0].type != MSGPACK_OBJECT_STR &&\n\t    uk->argv[0].type != MSGPACK_OBJECT_BIN)\n\t\ttmate_decoder_error();\n\n\t*len = uk->argv[0].via.str.size;\n\t*buf = uk->argv[0].via.str.ptr;\n\n\tuk->argv++;\n\tuk->argc--;\n}\n\nchar *unpack_string(struct tmate_unpacker *uk)\n{\n\tconst char *buf;\n\tchar *alloc_buf;\n\tsize_t len;\n\n\tunpack_buffer(uk, &buf, &len);\n\n\talloc_buf = xmalloc(len + 1);\n\tmemcpy(alloc_buf, buf, len);\n\talloc_buf[len] = '\\0';\n\n\treturn alloc_buf;\n}\n\nvoid unpack_array(struct tmate_unpacker *uk, struct tmate_unpacker *nested)\n{\n\tif (uk->argc == 0)\n\t\ttmate_decoder_error();\n\n\tinit_unpacker(nested, uk->argv[0]);\n\n\tuk->argv++;\n\tuk->argc--;\n}\n\n#define UNPACKER_RESERVE_SIZE 1024\n\nvoid tmate_decoder_init(struct tmate_decoder *decoder, tmate_decoder_reader *reader,\n\t\t\tvoid *userdata)\n{\n\tif (!msgpack_unpacker_init(&decoder->unpacker, UNPACKER_RESERVE_SIZE))\n\t\ttmate_fatal(\"Cannot initialize the unpacker\");\n\tdecoder->reader = reader;\n\tdecoder->userdata = userdata;\n}\n\nvoid tmate_decoder_destroy(struct tmate_decoder *decoder)\n{\n\tmsgpack_unpacker_destroy(&decoder->unpacker);\n\tmemset(decoder, 0, sizeof(*decoder));\n}\n\nvoid tmate_decoder_get_buffer(struct tmate_decoder *decoder,\n\t\t\t      char **buf, size_t *len)\n{\n\tif (!msgpack_unpacker_reserve_buffer(&decoder->unpacker, UNPACKER_RESERVE_SIZE))\n\t\ttmate_fatal(\"cannot expand decoder buffer\");\n\n\t*buf = msgpack_unpacker_buffer(&decoder->unpacker);\n\t*len = msgpack_unpacker_buffer_capacity(&decoder->unpacker);\n}\n\nvoid tmate_decoder_commit(struct tmate_decoder *decoder, size_t len)\n{\n\tstruct tmate_unpacker _uk, *uk = &_uk;\n\tmsgpack_unpacked result;\n\n\tmsgpack_unpacker_buffer_consumed(&decoder->unpacker, len);\n\n\tmsgpack_unpacked_init(&result);\n\twhile (msgpack_unpacker_next(&decoder->unpacker, &result)) {\n\t\tinit_unpacker(uk, result.data);\n\t\tdecoder->reader(decoder->userdata, uk);\n\t}\n\tmsgpack_unpacked_destroy(&result);\n}\n"
        },
        {
          "name": "tmate-protocol.h",
          "type": "blob",
          "size": 3.431640625,
          "content": "#ifndef TMATE_PROTOCOL_H\n#define TMATE_PROTOCOL_H\n\nenum tmate_control_out_msg_types {\n\tTMATE_CTL_HEADER,\n\tTMATE_CTL_DEAMON_OUT_MSG,\n\tTMATE_CTL_SNAPSHOT,\n\tTMATE_CTL_CLIENT_JOIN,\n\tTMATE_CTL_CLIENT_LEFT,\n\tTMATE_CTL_EXEC,\n\tTMATE_CTL_LATENCY,\n};\n\n/*\n[TMATE_CTL_HEADER, int: ctl_proto_version, string: ip_address, string: pubkey,\n                   string: session_token, string: session_token_ro, string: ssh_cmd_fmt]\n\t           string: client_version, int: client_protocol_version]\n[TMATE_CTL_DEAMON_OUT_MSG, object: msg]\n[TMATE_CTL_SNAPSHOT, [[int: pane_id, [int: cur_x, int: cur_y], int: mode,\n                       [[string: line_utf8, [int: char_attr, ...]], ...], ...], ...]]\n[TMATE_CTL_CLIENT_JOIN, int: client_id, string: ip_address, string: pubkey, boolean: readonly]\n[TMATE_CTL_CLIENT_LEFT, int: client_id]\n[TMATE_CTL_EXEC, string: username, string: ip_address, string: pubkey, string: command]\n[TMATE_CTL_LATENCY, int: client_id, int: latency_ms] // client_id == -1: tmate host\n*/\n\nenum tmate_control_in_msg_types {\n\tTMATE_CTL_DEAMON_FWD_MSG,\n\tTMATE_CTL_REQUEST_SNAPSHOT,\n\tTMATE_CTL_PANE_KEYS,\n\tTMATE_CTL_RESIZE,\n\tTMATE_CTL_EXEC_RESPONSE,\n\tTMATE_CTL_RENAME_SESSION,\n};\n\n/*\n[TMATE_CTL_DEAMON_FWD_MSG, object: msg]\n[TMATE_CTL_REQUEST_SNAPSHOT, int: max_history_lines]\n[TMATE_CTL_PANE_KEYS, int: pane_id, string: keys]\n[TMATE_CTL_RESIZE, int: sx, int: sy] // sx == -1: no clients\n[TMATE_CTL_EXEC_RESPONSE, int: exit_code, string: message]\n[TMATE_CTL_RENAME_SESSION, string: stoken, string: stoken_ro]\n*/\n\nenum tmate_daemon_out_msg_types {\n\tTMATE_OUT_HEADER,\n\tTMATE_OUT_SYNC_LAYOUT,\n\tTMATE_OUT_PTY_DATA,\n\tTMATE_OUT_EXEC_CMD_STR,\n\tTMATE_OUT_FAILED_CMD,\n\tTMATE_OUT_STATUS,\n\tTMATE_OUT_SYNC_COPY_MODE,\n\tTMATE_OUT_WRITE_COPY_MODE,\n\tTMATE_OUT_FIN,\n\tTMATE_OUT_READY,\n\tTMATE_OUT_RECONNECT,\n\tTMATE_OUT_SNAPSHOT,\n\tTMATE_OUT_EXEC_CMD,\n\tTMATE_OUT_UNAME,\n};\n\n/*\n[TMATE_OUT_HEADER, int: proto_version, string: version]\n[TMATE_OUT_SYNC_LAYOUT, [int: sx, int: sy, [[int: win_id, string: win_name,\n\t\t\t  [[int: pane_id, int: sx, int: sy, int: xoff, int: yoff], ...],\n\t\t\t  int: active_pane_id], ...], int: active_win_id]\n[TMATE_OUT_PTY_DATA, int: pane_id, binary: buffer]\n[TMATE_OUT_EXEC_CMD_STR, string: cmd]\n[TMATE_OUT_FAILED_CMD, int: client_id, string: cause]\n[TMATE_OUT_STATUS, string: left, string: right]\n[TMATE_OUT_SYNC_COPY_MODE, int: pane_id, [int: backing, int: oy, int: cx, int: cy,\n\t\t\t\t\t  [int: selx, int: sely, int: flags],\n\t\t\t\t\t  [int: type, string: input_prompt, string: input_str]])\n                                          // Any of the array can be []\n[TMATE_OUT_WRITE_COPY_MODE, int: pane_id, string: str]\n[TMATE_OUT_FIN]\n[TMATE_OUT_READY]\n[TMATE_OUT_RECONNECT, string: reconnection_data]\n[TMATE_OUT_SNAPSHOT, ...]\n[TMATE_OUT_EXEC_CMD, string: cmd_name, ...string: args]\n[TMATE_OUT_UNAME, string: name.sysname, string: name.nodename,\n                  string: name.release, string: name.version, string: name.machine]\n*/\n\nenum tmate_daemon_in_msg_types {\n\tTMATE_IN_NOTIFY,\n\tTMATE_IN_LEGACY_PANE_KEY,\n\tTMATE_IN_RESIZE,\n\tTMATE_IN_EXEC_CMD_STR,\n\tTMATE_IN_SET_ENV,\n\tTMATE_IN_READY,\n\tTMATE_IN_PANE_KEY,\n\tTMATE_IN_EXEC_CMD,\n};\n\n/*\n[TMATE_IN_NOTIFY, string: msg]\n[TMATE_IN_PANE_KEY, int: key]\n[TMATE_IN_RESIZE, int: sx, int: sy] // sx == -1: no clients\n[TMATE_IN_EXEC_CMD_STR, int: client_id, string: cmd]\n[TMATE_IN_SET_ENV, string: name, string: value]\n[TMATE_IN_READY]\n[TMATE_IN_PANE_KEY, int: pane_id, uint64 keycode] // pane_id == -1: active pane\n[TMATE_IN_EXEC_CMD, int: client_id, ...string: args]\n*/\n\n#endif\n"
        },
        {
          "name": "tmate-session.c",
          "type": "blob",
          "size": 6.7666015625,
          "content": "#include <event2/dns.h>\n#include <event2/util.h>\n#include <event2/event.h>\n\n#include <netinet/in.h>\n#include <sys/socket.h>\n\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\n#include \"tmate.h\"\n\n#define TMATE_DNS_RETRY_TIMEOUT 2\n#define TMATE_RECONNECT_RETRY_TIMEOUT 2\n\nstruct tmate_session tmate_session;\n\nstatic void lookup_and_connect(void);\n\nstatic void on_dns_retry(__unused evutil_socket_t fd, __unused short what,\n\t\t\t void *arg)\n{\n\tstruct tmate_session *session = arg;\n\n\tassert(session->ev_dns_retry);\n\tevent_free(session->ev_dns_retry);\n\tsession->ev_dns_retry = NULL;\n\n\tlookup_and_connect();\n}\n\nstatic void dns_cb(int errcode, struct evutil_addrinfo *addr, void *ptr)\n{\n\tstruct evutil_addrinfo *ai;\n\tconst char *host = ptr;\n\n\tevdns_base_free(tmate_session.ev_dnsbase, 0);\n\ttmate_session.ev_dnsbase = NULL;\n\n\tif (errcode) {\n\t\tstruct tmate_session *session = &tmate_session;\n\n\t\tif (session->ev_dns_retry)\n\t\t\treturn;\n\n\t\tstruct timeval tv = { .tv_sec = TMATE_DNS_RETRY_TIMEOUT, .tv_usec = 0 };\n\n\t\tsession->ev_dns_retry = evtimer_new(session->ev_base, on_dns_retry, session);\n\t\tif (!session->ev_dns_retry)\n\t\t\ttmate_fatal(\"out of memory\");\n\t\tevtimer_add(session->ev_dns_retry, &tv);\n\n\t\ttmate_status_message(\"%s lookup failure. Retrying in %d seconds (%s)\",\n\t\t\t\t     host, TMATE_DNS_RETRY_TIMEOUT,\n\t\t\t\t     evutil_gai_strerror(errcode));\n\t\treturn;\n\t}\n\n\ttmate_status_message(\"Connecting to %s...\", host);\n\n\tint i, num_clients = 0;\n\tfor (ai = addr; ai; ai = ai->ai_next)\n\t\tnum_clients++;\n\n\tstruct tmate_ssh_client *ssh_clients[num_clients];\n\n\tfor (ai = addr, i = 0; ai; ai = ai->ai_next, i++) {\n\t\tchar buf[128];\n\t\tconst char *ip = NULL;\n\t\tif (ai->ai_family == AF_INET) {\n\t\t\tstruct sockaddr_in *sin = (struct sockaddr_in *)ai->ai_addr;\n\t\t\tip = evutil_inet_ntop(AF_INET, &sin->sin_addr, buf, 128);\n\t\t} else if (ai->ai_family == AF_INET6) {\n\t\t\tstruct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)ai->ai_addr;\n\t\t\tip = evutil_inet_ntop(AF_INET6, &sin6->sin6_addr, buf, 128);\n\t\t}\n\n\t\tssh_clients[i] = tmate_ssh_client_alloc(&tmate_session, ip);\n\t}\n\n\tfor (i = 0; i < num_clients; i++)\n\t\tconnect_ssh_client(ssh_clients[i]);\n\n\tevutil_freeaddrinfo(addr);\n}\n\nstatic void lookup_and_connect(void)\n{\n\tstruct evutil_addrinfo hints;\n\tconst char *tmate_server_host;\n\n\tassert(!tmate_session.ev_dnsbase);\n\ttmate_session.ev_dnsbase = evdns_base_new(tmate_session.ev_base, 1);\n\tif (!tmate_session.ev_dnsbase)\n\t\ttmate_fatal(\"Cannot initialize the DNS lookup service\");\n\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = AF_UNSPEC;\n\thints.ai_flags = EVUTIL_AI_ADDRCONFIG;\n\thints.ai_socktype = SOCK_STREAM;\n\thints.ai_protocol = IPPROTO_TCP;\n\n\ttmate_server_host = options_get_string(global_options,\n\t\t\t\t\t       \"tmate-server-host\");\n\ttmate_debug(\"Looking up %s...\", tmate_server_host);\n\t(void)evdns_getaddrinfo(tmate_session.ev_dnsbase, tmate_server_host, NULL,\n\t\t\t\t&hints, dns_cb, (void *)tmate_server_host);\n}\n\nstatic void __tmate_session_init(struct tmate_session *session,\n\t\t\t\t struct event_base *base)\n{\n\tmemset(session, 0, sizeof(*session));\n\n\tsession->ev_base = base;\n\n\t/*\n\t * Early initialization of encoder because we need to parse\n\t * config files to get the server configs, but while we are parsing\n\t * config files, we need to buffer bind commands and all for the\n\t * slave.\n\t * Decoder is setup later.\n\t */\n\ttmate_encoder_init(&session->encoder, NULL, &tmate_session);\n\n\tsession->min_sx = -1;\n\tsession->min_sy = -1;\n\n\tTAILQ_INIT(&session->clients);\n}\n\nvoid tmate_session_init(struct event_base *base)\n{\n\t__tmate_session_init(&tmate_session, base);\n\ttmate_write_header();\n}\n\nstatic void send_authorized_keys(void)\n{\n\tchar *path;\n\tpath = options_get_string(global_options, \"tmate-authorized-keys\");\n\tif (strlen(path) == 0)\n\t\treturn;\n\n\tpath = xstrdup(path);\n\ttmate_info(\"Using %s for access control\", path);\n\n\tFILE *f;\n\tchar *line;\n\tsize_t len;\n\n\tif (path[0] == '~' && path[1] == '/') {\n\t\tconst char *home = find_home();\n\t\tif (home) {\n\t\t\tchar *new_path;\n\t\t\txasprintf(&new_path, \"%s%s\", home, &path[1]);\n\t\t\tfree(path);\n\t\t\tpath = new_path;\n\t\t}\n\t}\n\n\tif ((f = fopen(path, \"r\")) == NULL) {\n\t\tcfg_add_cause(\"%s: %s\", path, strerror(errno));\n\t\tfree(path);\n\t\treturn;\n\t}\n\n\twhile ((line = fparseln(f, &len, NULL, NULL, 0)) != NULL) {\n\t\tif (len == 0)\n\t\t\tcontinue;\n\t\ttmate_set_val(\"authorized_keys\", line);\n\t\tfree(line);\n\t}\n\n\tif (ferror(f))\n\t\tcfg_add_cause(\"%s: %s\", path, strerror(errno));\n\n\tfclose(f);\n\tfree(path);\n}\n\nvoid tmate_session_start(void)\n{\n\t/*\n\t * We split init and start because:\n\t * - We need to process the tmux config file during the connection as\n\t *   we are setting up the tmate identity.\n\t * - While we are parsing the config file, we need to be able to\n\t *   serialize it, and so we need a worker encoder.\n\t */\n\tif (tmate_foreground) {\n\t\ttmate_set_val(\"foreground\", \"true\");\n\t\ttmate_info(\"To connect to the session locally, run: tmate -S %s attach\", socket_path);\n\t} else {\n\t\tcfg_add_cause(\"%s\", \"Tip: if you wish to use tmate only for remote access, run: tmate -F\");\n\t\tcfg_add_cause(\"%s\", \"To see the following messages again, run in a tmate session: tmate show-messages\");\n\t\tcfg_add_cause(\"%s\", \"Press <q> or <ctrl-c> to continue\");\n\t\tcfg_add_cause(\"%s\", \"---------------------------------------------------------------------\");\n\t}\n\n\tsend_authorized_keys();\n\ttmate_write_uname();\n\ttmate_write_ready();\n\tlookup_and_connect();\n}\n\nstatic void on_reconnect_retry(__unused evutil_socket_t fd, __unused short what, void *arg)\n{\n\tstruct tmate_session *session = arg;\n\n\tassert(session->ev_connection_retry);\n\tevent_free(session->ev_connection_retry);\n\tsession->ev_connection_retry = NULL;\n\n\tif (session->last_server_ip) {\n\t\t/*\n\t\t * We have a previous server ip. Let's try that again first,\n\t\t * but then connect to any server if it fails again.\n\t\t */\n\t\tstruct tmate_ssh_client *c = tmate_ssh_client_alloc(session,\n\t\t\t\t\t\tsession->last_server_ip);\n\t\tconnect_ssh_client(c);\n\t\tfree(session->last_server_ip);\n\t\tsession->last_server_ip = NULL;\n\t} else {\n\t\tlookup_and_connect();\n\t}\n}\n\nvoid tmate_reconnect_session(struct tmate_session *session, const char *message)\n{\n\t/*\n\t * We no longer have an SSH connection. Time to reconnect.\n\t * We'll reuse some of the session information if we can,\n\t * and we'll try to reconnect to the same server if possible,\n\t * to avoid an SSH connection string change.\n\t */\n\tstruct timeval tv = { .tv_sec = TMATE_RECONNECT_RETRY_TIMEOUT, .tv_usec = 0 };\n\n\tif (session->ev_connection_retry)\n\t\treturn;\n\n\tsession->ev_connection_retry = evtimer_new(session->ev_base, on_reconnect_retry, session);\n\tif (!session->ev_connection_retry)\n\t\ttmate_fatal(\"out of memory\");\n\tevtimer_add(session->ev_connection_retry, &tv);\n\n\tif (message && !tmate_foreground)\n\t\ttmate_status_message(\"Reconnecting... (%s)\", message);\n\telse\n\t\ttmate_status_message(\"Reconnecting...\");\n\n\t/*\n\t * This says that we'll need to send a snapshot of the current state.\n\t */\n\tsession->reconnected = true;\n}\n"
        },
        {
          "name": "tmate-ssh-client.c",
          "type": "blob",
          "size": 14.953125,
          "content": "#include <sys/socket.h>\n#include <netinet/in.h>\n#include <netinet/tcp.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <event.h>\n#include <assert.h>\n\n#include \"tmate.h\"\n#include \"window-copy.h\"\n\nstatic void on_ssh_client_event(struct tmate_ssh_client *client);\nstatic void __on_ssh_client_event(evutil_socket_t fd, short what, void *arg);\n\nstatic void printflike(2, 3) kill_ssh_client(struct tmate_ssh_client *client,\n\t\t\t\t\t     const char *fmt, ...);\nstatic void printflike(2, 3) kill_ssh_client(struct tmate_ssh_client *client,\n\t\t\t\t\t\t  const char *fmt, ...);\n\nstatic void read_channel(struct tmate_ssh_client *client)\n{\n\tstruct tmate_decoder *decoder = &client->tmate_session->decoder;\n\tchar *buf;\n\tssize_t len;\n\n\tfor (;;) {\n\t\ttmate_decoder_get_buffer(decoder, &buf, &len);\n\t\tlen = ssh_channel_read_nonblocking(client->channel, buf, len, 0);\n\t\tif (len < 0) {\n\t\t\tkill_ssh_client(client, \"Error reading from channel: %s\",\n\t\t\t\t\tssh_get_error(client->session));\n\t\t\tbreak;\n\t\t}\n\n\t\tif (len == 0)\n\t\t\tbreak;\n\n\t\ttmate_decoder_commit(decoder, len);\n\t}\n}\n\nstatic void on_decoder_read(void *userdata, struct tmate_unpacker *uk)\n{\n\tstruct tmate_ssh_client *client = userdata;\n\ttmate_dispatch_slave_message(client->tmate_session, uk);\n}\n\nstatic void on_encoder_write(void *userdata, struct evbuffer *buffer)\n{\n\tstruct tmate_ssh_client *client = userdata;\n\tssize_t len, written;\n\tunsigned char *buf;\n\n\tif (!client->channel)\n\t\treturn;\n\n\tfor(;;) {\n\t\tlen = evbuffer_get_length(buffer);\n\t\tif (!len)\n\t\t\tbreak;\n\n\t\tbuf = evbuffer_pullup(buffer, -1);\n\n\t\twritten = ssh_channel_write(client->channel, buf, len);\n\t\tif (written < 0) {\n\t\t\tkill_ssh_client(client, \"Error writing to channel: %s\",\n\t\t\t\t\tssh_get_error(client->session));\n\t\t\tbreak;\n\t\t}\n\n\t\tevbuffer_drain(buffer, written);\n\t}\n}\n\nstatic void on_ssh_auth_server_complete(struct tmate_ssh_client *connected_client)\n{\n\t/*\n\t * The first ssh connection succeeded. Hopefully this one offers the\n\t * best latency. We can now kill the other ssh clients that are trying\n\t * to connect.\n\t */\n\tstruct tmate_session *session = connected_client->tmate_session;\n\tstruct tmate_ssh_client *client, *tmp_client;\n\n\tTAILQ_FOREACH_SAFE(client, &session->clients, node, tmp_client) {\n\t\tif (client == connected_client)\n\t\t\tcontinue;\n\n\t\tkill_ssh_client(client, NULL);\n\t}\n}\n\nstatic char *get_identity(void)\n{\n\tchar *identity;\n\n\tidentity = options_get_string(global_options, \"tmate-identity\");\n\tif (!strlen(identity))\n\t\treturn NULL;\n\n\tif (strchr(identity, '/'))\n\t\tidentity = xstrdup(identity);\n\telse\n\t\txasprintf(&identity, \"%%d/%s\", identity);\n\n\treturn identity;\n}\n\nstatic int passphrase_callback(__unused const char *prompt, char *buf, size_t len,\n\t\t\t       __unused int echo, __unused int verify, void *userdata)\n{\n\tstruct tmate_ssh_client *client = userdata;\n\n\tclient->tmate_session->need_passphrase = 1;\n\n\tif (client->tmate_session->passphrase)\n\t\tstrlcpy(buf, client->tmate_session->passphrase, len);\n\telse\n\t\tstrcpy(buf, \"\");\n\n\treturn 0;\n}\n\nstatic void on_passphrase_read(const char *passphrase, void *private)\n{\n\tstruct tmate_ssh_client *client = private;\n\n\tclient->tmate_session->passphrase = xstrdup(passphrase);\n\ton_ssh_client_event(client);\n}\n\nstatic void request_passphrase(struct tmate_ssh_client *client)\n{\n\tstruct window_pane *wp;\n\tstruct window_copy_mode_data *data;\n\n\t/*\n\t * We'll display the prompt on the first pane.\n\t * It doesn't make much sense, but it's simpler to reuse the copy mode\n\t * and its key parsing logic compared to rolling something on our own.\n\t */\n\twp = RB_MIN(window_pane_tree, &all_window_panes);\n\n\tif (wp->mode) {\n\t\tdata = wp->modedata;\n\t\tif (data->inputtype == WINDOW_COPY_PASSWORD) {\n\t\t\t/* We are already requesting the passphrase */\n\t\t\treturn;\n\t\t}\n\t\twindow_pane_reset_mode(wp);\n\t}\n\n\twindow_pane_set_mode(wp, &window_copy_mode);\n\twindow_copy_init_from_pane(wp, 0);\n\tdata = wp->modedata;\n\n\tdata->inputtype = WINDOW_COPY_PASSWORD;\n\tdata->inputprompt = \"SSH key passphrase\";\n\n\tmode_key_init(&data->mdata, &mode_key_tree_vi_edit);\n\n\twindow_copy_update_selection(wp, 1);\n\twindow_copy_redraw_screen(wp);\n\n\tdata->password_cb = on_passphrase_read;\n\tdata->password_cb_private = client;\n}\n\n#define KEEPALIVE_IDLE\t\t30\n#define KEEPALIVE_CNT\t\t4\n#define KEEPALIVE_INTVL\t\t11\n#define WRITE_TIMEOUT\t\t80\n\nstatic void tune_socket_opts(int fd)\n{\n#define SSO(level, optname, val) ({\t\t\t\t\t\t\t\\\n\tint _flag = val;\t\t\t\t\t\t\t\t\\\n\tif (setsockopt(fd, level, optname, &(_flag), sizeof(int)) < 0) {\t\t\\\n\t\t/* If the connection has been closed, we'll get EINVAL */\t\t\\\n\t\tif (errno != EINVAL)\t\t\t\t\t\t\t\\\n\t\t\ttmate_info(\"setsockopt(\" #level \", \" #optname \", %d) failed %s\", val, strerror(errno));\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\\\n})\n\n\tSSO(IPPROTO_IP, IP_TOS, 0x10); /* IPTOS_LOWDELAY */\n\tSSO(IPPROTO_TCP, TCP_NODELAY, 1);\n\tSSO(SOL_SOCKET, SO_KEEPALIVE, 1);\n#ifdef TCP_KEEPALIVE\n\t/*\n\t * The TCP_KEEPALIVE options enable to specify the amount of time, in\n\t * seconds, that the connection must be idle before keepalive probes\n\t * (if enabled) are sent.\n\t */\n\tSSO(IPPROTO_TCP, TCP_KEEPALIVE, KEEPALIVE_IDLE);\n#endif\n#ifdef TCP_KEEPIDLE\n\t/*\n\t * Same as TCP_KEEPALIVE, but on different systems\n\t */\n\tSSO(IPPROTO_TCP, TCP_KEEPIDLE, KEEPALIVE_IDLE);\n#endif\n#ifdef TCP_KEEPCNT\n\t/*\n\t * When keepalive probes are enabled, this option will set the number\n\t * of times a keepalive probe should be repeated if the peer is not\n\t * responding. After this many probes, the connection will be closed.\n\t */\n\tSSO(IPPROTO_TCP, TCP_KEEPCNT, KEEPALIVE_CNT);\n#endif\n#ifdef TCP_KEEPINTVL\n\t/*\n\t * When keepalive probes are enabled, this option will set the amount\n\t * of time in seconds between successive keepalives sent to probe an\n\t * unresponsive peer.\n\t */\n\tSSO(IPPROTO_TCP, TCP_KEEPINTVL, KEEPALIVE_INTVL);\n#endif\n#ifdef TCP_USER_TIMEOUT\n\t/*\n\t * This option takes an unsigned int as an argument.  When the\n\t * value is greater than 0, it specifies the maximum amount of\n\t * time in milliseconds that transmitted data may remain\n\t * unacknowledged before TCP will forcibly close the\n\t * corresponding connection and return ETIMEDOUT to the\n\t * application.\n\t */\n\tSSO(IPPROTO_TCP, TCP_USER_TIMEOUT, 1000*WRITE_TIMEOUT);\n#endif\n#undef SSO\n}\n\nstatic void init_conn_fd(struct tmate_ssh_client *client)\n{\n\tint fd;\n\n\tif (client->ev_ssh)\n\t\treturn;\n\n\tif ((fd = ssh_get_fd(client->session)) < 0)\n\t\treturn;\n\n\ttune_socket_opts(fd);\n\n\tclient->ev_ssh = event_new(client->tmate_session->ev_base, fd,\n\t\t\t\t   EV_READ | EV_PERSIST,\n\t\t\t\t   __on_ssh_client_event, client);\n\tif (!client->ev_ssh)\n\t\ttmate_fatal(\"out of memory\");\n\tevent_add(client->ev_ssh, NULL);\n}\n\nstatic void on_ssh_client_event(struct tmate_ssh_client *client)\n{\n\tssh_session session = client->session;\n\tssh_channel channel = client->channel;\n\n\tswitch (client->state) {\n\tcase SSH_INIT: {\n\t\tclient->session = session = ssh_new();\n\t\tif (!session) {\n\t\t\ttmate_fatal(\"cannot ssh_new()\");\n\t\t\treturn;\n\t\t}\n\n\t\tssh_set_callbacks(session, &client->ssh_callbacks);\n\n\t\tint verbosity = SSH_LOG_NOLOG + log_get_level();\n\t\tint port = options_get_number(global_options, \"tmate-server-port\");\n\n\t\tssh_set_blocking(session, 0);\n\t\tssh_options_set(session, SSH_OPTIONS_HOST, client->server_ip);\n\t\tssh_options_set(session, SSH_OPTIONS_LOG_VERBOSITY, &verbosity);\n\t\tssh_options_set(session, SSH_OPTIONS_PORT, &port);\n\t\tssh_options_set(session, SSH_OPTIONS_USER, \"tmate\");\n\t\tssh_options_set(session, SSH_OPTIONS_COMPRESSION, \"yes\");\n\n\t\tchar *identity;\n\t\tif ((identity = get_identity())) {\n\t\t\t/*\n\t\t\t * FIXME libssh will continue with the next set of\n\t\t\t * keys if the identity has a passphrase and the\n\t\t\t * regular one doesn't.\n\t\t\t */\n\t\t\tssh_options_set(session, SSH_OPTIONS_IDENTITY, identity);\n\n\t\t\t/* Do not use keys from ssh-agent. */\n\t\t\tunsetenv(\"SSH_AUTH_SOCK\");\n\t\t\tfree(identity);\n\t\t}\n\n\t\tclient->state = SSH_CONNECT;\n\t}\n\t// fall through\n\n\tcase SSH_CONNECT:\n\t\tswitch (ssh_connect(session)) {\n\t\tcase SSH_AGAIN:\n\t\t\tinit_conn_fd(client);\n\t\t\treturn;\n\t\tcase SSH_ERROR:\n\t\t\tkill_ssh_client(client, \"Error connecting: %s\",\n\t\t\t\t\tssh_get_error(session));\n\t\t\treturn;\n\t\tcase SSH_OK:\n\t\t\tinit_conn_fd(client);\n\n\t\t\ttmate_debug(\"Establishing connection to %s\", client->server_ip);\n\t\t\tclient->state = SSH_AUTH_SERVER;\n\t\t}\n\t\t// fall through\n\n\tcase SSH_AUTH_SERVER: {\n\t\tssh_key pubkey;\n\t\tenum ssh_keytypes_e key_type;\n\t\tunsigned char *hash;\n\t\tssize_t hash_len;\n\t\tchar *hash_str;\n\t\tconst char *server_hash_str;\n\t\tint match;\n\n#if LIBSSH_VERSION_INT >= SSH_VERSION_INT(0, 9, 0)\n\t\tif (ssh_get_server_publickey(session, &pubkey) < 0)\n\t\t\ttmate_fatal(\"ssh_get_server_publickey\");\n#else\n\t\tif (ssh_get_publickey(session, &pubkey) < 0)\n\t\t\ttmate_fatal(\"ssh_get_publickey\");\n#endif\n\n\t\tif (ssh_get_publickey_hash(pubkey, SSH_PUBLICKEY_HASH_SHA256,\n\t\t\t\t\t   &hash, &hash_len) < 0) {\n\t\t\tkill_ssh_client(client, \"Failed to get server fingerprint\");\n\t\t\treturn;\n\t\t}\n\n\t\thash_str = ssh_get_fingerprint_hash(SSH_PUBLICKEY_HASH_SHA256,\n\t\t\t\t\t\t    hash, hash_len);\n\t\tif (!hash_str)\n\t\t\ttmate_fatal(\"malloc failed\");\n\n\t\tkey_type = ssh_key_type(pubkey);\n\n\t\tswitch (key_type) {\n\t\tcase SSH_KEYTYPE_RSA:\n\t\t\tserver_hash_str = options_get_string(global_options,\n\t\t\t\t\t\t\"tmate-server-rsa-fingerprint\");\n\t\t\tbreak;\n\t\tcase SSH_KEYTYPE_ECDSA:\n#if LIBSSH_VERSION_INT >= SSH_VERSION_INT(0, 9, 0)\n\t\tcase SSH_KEYTYPE_ECDSA_P256:\n\t\tcase SSH_KEYTYPE_ECDSA_P384:\n\t\tcase SSH_KEYTYPE_ECDSA_P521:\n#endif\n\t\t\tserver_hash_str = options_get_string(global_options,\n\t\t\t\t\t\t\"tmate-server-ecdsa-fingerprint\");\n\t\t\tbreak;\n\t\tcase SSH_KEYTYPE_ED25519:\n\t\t\tserver_hash_str = options_get_string(global_options,\n\t\t\t\t\t\t\"tmate-server-ed25519-fingerprint\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tserver_hash_str = \"\";\n\t\t}\n\n\t\tmatch = !strcmp(hash_str, server_hash_str);\n\t\tif (!match) {\n\t\t\tkill_ssh_client(client, \"Server fingerprint not recognized: \"\n\t\t\t\t\"`%s', expected `%s'\", server_hash_str, hash_str);\n\t\t}\n\n\t\tssh_key_free(pubkey);\n\t\tssh_clean_pubkey_hash(&hash);\n\t\tfree(hash_str);\n\n\t\tif (!match)\n\t\t\treturn;\n\n\t\t/*\n\t\t * At this point, we abort other connection attempts to the\n\t\t * other tmate servers, since we have reached the fastest one.\n\t\t * We need to do it before we ask the user its passphrase,\n\t\t * otherwise the speed test would be biased.\n\t\t */\n\t\ttmate_debug(\"Connected to %s\", client->server_ip);\n\t\ton_ssh_auth_server_complete(client);\n\n\t\tclient->state = SSH_AUTH_CLIENT_NONE;\n\t}\n\t\t// fall through\n\n\tcase SSH_AUTH_CLIENT_NONE:\n\t\tswitch (ssh_userauth_none(session, NULL)) {\n\t\tcase SSH_AUTH_AGAIN:\n\t\t\treturn;\n\t\tcase SSH_AUTH_ERROR:\n\t\t\tkill_ssh_client(client, \"Auth error: %s\", ssh_get_error(session));\n\t\t\treturn;\n\t\tcase SSH_AUTH_SUCCESS:\n\t\t\ttmate_debug(\"Auth successful via none method\");\n\t\t\tclient->state = SSH_NEW_CHANNEL;\n\t\t\tgoto SSH_NEW_CHANNEL;\n\t\tcase SSH_AUTH_PARTIAL:\n\t\tcase SSH_AUTH_DENIED:\n\t\t\tclient->state = SSH_AUTH_CLIENT_PUBKEY;\n\t\t}\n\t\t// fall through\n\n\tcase SSH_AUTH_CLIENT_PUBKEY:\n\t\tclient->tried_passphrase = client->tmate_session->passphrase;\n\t\tswitch (ssh_userauth_publickey_auto(session, NULL, client->tried_passphrase)) {\n\t\tcase SSH_AUTH_AGAIN:\n\t\t\treturn;\n\t\tcase SSH_AUTH_PARTIAL:\n\t\tcase SSH_AUTH_INFO:\n\t\tcase SSH_AUTH_DENIED:\n\t\t\tif (client->tmate_session->need_passphrase) {\n\t\t\t\trequest_passphrase(client);\n\t\t\t} else {\n\t\t\t\tkill_ssh_client(client, \"SSH keys not found.\"\n\t\t\t\t\" Run 'ssh-keygen' to create keys.\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (client->tried_passphrase)\n\t\t\t\ttmate_status_message(\"Can't load SSH key.\"\n\t\t\t\t\" Try typing passphrase again in case of typo. ctrl-c to abort.\");\n\t\t\treturn;\n\t\tcase SSH_AUTH_ERROR:\n\t\t\tkill_ssh_client(client, \"Auth error: %s\", ssh_get_error(session));\n\t\t\treturn;\n\t\tcase SSH_AUTH_SUCCESS:\n\t\t\ttmate_debug(\"Auth successful with pubkey\");\n\t\t\tclient->state = SSH_NEW_CHANNEL;\n\t\t}\n\t\t// fall through\n\nSSH_NEW_CHANNEL:\n\tcase SSH_NEW_CHANNEL:\n\t\tclient->channel = channel = ssh_channel_new(session);\n\t\tif (!channel) {\n\t\t\ttmate_fatal(\"cannot ssh_channel_new()\");\n\t\t\treturn;\n\t\t}\n\t\tclient->state = SSH_OPEN_CHANNEL;\n\t\t// fall through\n\n\tcase SSH_OPEN_CHANNEL:\n\t\tswitch (ssh_channel_open_session(channel)) {\n\t\tcase SSH_AGAIN:\n\t\t\treturn;\n\t\tcase SSH_ERROR:\n\t\t\tkill_ssh_client(client, \"Error opening channel: %s\",\n\t\t\t\t\tssh_get_error(session));\n\t\t\treturn;\n\t\tcase SSH_OK:\n\t\t\ttmate_debug(\"Session opened, initializing tmate\");\n\t\t\tclient->state = SSH_BOOTSTRAP;\n\t\t}\n\t\t// fall through\n\n\tcase SSH_BOOTSTRAP:\n\t\tswitch (ssh_channel_request_subsystem(channel, \"tmate\")) {\n\t\tcase SSH_AGAIN:\n\t\t\treturn;\n\t\tcase SSH_ERROR:\n\t\t\tkill_ssh_client(client, \"Error initializing tmate: %s\",\n\t\t\t\t\tssh_get_error(session));\n\t\t\treturn;\n\t\tcase SSH_OK:\n\t\t\ttmate_debug(\"Ready\");\n\n\t\t\t/* Writes are now performed in a blocking fashion */\n\t\t\tssh_set_blocking(session, 1);\n\n\t\t\tclient->state = SSH_READY;\n\n\t\t\tif (client->tmate_session->reconnected)\n\t\t\t\ttmate_send_reconnection_state(client->tmate_session);\n\n\t\t\ttmate_encoder_set_ready_callback(&client->tmate_session->encoder,\n\t\t\t\t\t\t\t on_encoder_write, client);\n\t\t\ttmate_decoder_init(&client->tmate_session->decoder,\n\t\t\t\t\t   on_decoder_read, client);\n\n\t\t\tfree(client->tmate_session->last_server_ip);\n\t\t\tclient->tmate_session->last_server_ip = xstrdup(client->server_ip);\n\t\t}\n\t\t// fall through\n\n\tcase SSH_READY:\n\t\tread_channel(client);\n\t}\n}\n\nstatic void __on_ssh_client_event(__unused evutil_socket_t fd, __unused short what, void *arg)\n{\n\ton_ssh_client_event(arg);\n}\n\nstatic void kill_ssh_client(struct tmate_ssh_client *client,\n\t\t\t    const char *fmt, ...)\n{\n\tbool last_client;\n\tva_list ap;\n\tchar *message = NULL;\n\n\tTAILQ_REMOVE(&client->tmate_session->clients, client, node);\n\tlast_client = TAILQ_EMPTY(&client->tmate_session->clients);\n\n\tif (fmt && last_client) {\n\t\tva_start(ap, fmt);\n\t\txvasprintf(&message, fmt, ap);\n\t\tva_end(ap);\n\t\ttmate_status_message(\"%s\", message);\n\t}\n\n\ttmate_debug(\"SSH client killed (%s)\", client->server_ip);\n\n\tif (client->ev_ssh) {\n\t\tevent_del(client->ev_ssh);\n\t\tevent_free(client->ev_ssh);\n\t\tclient->ev_ssh = NULL;\n\t}\n\n\tif (client->state == SSH_READY) {\n\t\ttmate_encoder_set_ready_callback(&client->tmate_session->encoder, NULL, NULL);\n\t\ttmate_decoder_destroy(&client->tmate_session->decoder);\n\n\t\tclient->tmate_session->min_sx = -1;\n\t\tclient->tmate_session->min_sy = -1;\n\t\trecalculate_sizes();\n\t}\n\n\tif (client->session) {\n\t\t/* ssh_free() also frees the associated channels. */\n\t\tssh_free(client->session);\n\t\tclient->session = NULL;\n\t\tclient->channel = NULL;\n\t}\n\n\tif (last_client)\n\t\ttmate_reconnect_session(client->tmate_session, message);\n\n\tfree(client->server_ip);\n\tfree(client);\n}\n\nvoid connect_ssh_client(struct tmate_ssh_client *client)\n{\n\tassert(!client->session);\n\tclient->state = SSH_INIT;\n\ton_ssh_client_event(client);\n}\n\nstatic void ssh_log_function(int priority, const char *function,\n\t\t\t     const char *buffer, __unused void *userdata)\n{\n\ttmate_debug(\"[%d] [%s] %s\", priority, function, buffer);\n}\n\nstruct tmate_ssh_client *tmate_ssh_client_alloc(struct tmate_session *session,\n\t\t\t\t\t\tconst char *server_ip)\n \n{\n\tstruct tmate_ssh_client *client;\n\tclient = xmalloc(sizeof(*client));\n\tmemset(client, 0, sizeof(*client));\n\n\tssh_set_log_callback(ssh_log_function);\n\n\tmemset(&client->ssh_callbacks, 0, sizeof(client->ssh_callbacks));\n\tssh_callbacks_init(&client->ssh_callbacks);\n\tclient->ssh_callbacks.userdata = client;\n\tclient->ssh_callbacks.auth_function = passphrase_callback;\n\n\tclient->tmate_session = session;\n\tTAILQ_INSERT_TAIL(&session->clients, client, node);\n\n\tclient->server_ip = xstrdup(server_ip);\n\tclient->state = SSH_NONE;\n\tclient->session = NULL;\n\tclient->channel = NULL;\n\n\treturn client;\n}\n"
        },
        {
          "name": "tmate.1",
          "type": "blob",
          "size": 0.005859375,
          "content": "tmux.1"
        },
        {
          "name": "tmate.h",
          "type": "blob",
          "size": 6.3828125,
          "content": "#ifndef TMATE_H\n#define TMATE_H\n\n#include <sys/types.h>\n#include <msgpack.h>\n#include <libssh/libssh.h>\n#include <libssh/callbacks.h>\n#include <event.h>\n\n#include \"tmux.h\"\n\n#define tmate_debug(...) log_emit(LOG_DEBUG, __VA_ARGS__)\n#define tmate_info(...)  log_emit(LOG_INFO,  __VA_ARGS__)\n#define tmate_fatal(...) fatalx( __VA_ARGS__)\n\n/* tmate-msgpack.c */\n\ntypedef void tmate_encoder_write_cb(void *userdata, struct evbuffer *buffer);\n\nstruct tmate_encoder {\n\tmsgpack_packer pk;\n\ttmate_encoder_write_cb *ready_callback;\n\tvoid *userdata;\n\tstruct evbuffer *buffer;\n\tstruct event *ev_buffer;\n\tbool ev_active;\n};\n\nextern void tmate_encoder_init(struct tmate_encoder *encoder,\n\t\t\t       tmate_encoder_write_cb *callback,\n\t\t\t       void *userdata);\nextern void tmate_encoder_destroy(struct tmate_encoder *encoder);\nextern void tmate_encoder_set_ready_callback(struct tmate_encoder *encoder,\n\t\t\t\t\t     tmate_encoder_write_cb *callback,\n\t\t\t\t\t     void *userdata);\n\nextern void msgpack_pack_string(msgpack_packer *pk, const char *str);\nextern void msgpack_pack_boolean(msgpack_packer *pk, bool value);\n\n#define _pack(enc, what, ...) msgpack_pack_##what(&(enc)->pk, ##__VA_ARGS__)\n\nstruct tmate_unpacker;\nstruct tmate_decoder;\ntypedef void tmate_decoder_reader(void *userdata, struct tmate_unpacker *uk);\n\nstruct tmate_decoder {\n\tstruct msgpack_unpacker unpacker;\n\ttmate_decoder_reader *reader;\n\tvoid *userdata;\n};\n\nextern void tmate_decoder_init(struct tmate_decoder *decoder, tmate_decoder_reader *reader, void *userdata);\nextern void tmate_decoder_destroy(struct tmate_decoder *decoder);\nextern void tmate_decoder_get_buffer(struct tmate_decoder *decoder, char **buf, size_t *len);\nextern void tmate_decoder_commit(struct tmate_decoder *decoder, size_t len);\n\nstruct tmate_unpacker {\n\tint argc;\n\tmsgpack_object *argv;\n};\n\nextern void init_unpacker(struct tmate_unpacker *uk, msgpack_object obj);\nextern void tmate_decoder_error(void);\nextern int64_t unpack_int(struct tmate_unpacker *uk);\nextern bool unpack_bool(struct tmate_unpacker *uk);\nextern void unpack_buffer(struct tmate_unpacker *uk, const char **buf, size_t *len);\nextern char *unpack_string(struct tmate_unpacker *uk);\nextern void unpack_array(struct tmate_unpacker *uk, struct tmate_unpacker *nested);\n\n#define unpack_each(nested_uk, tmp_uk, uk)\t\t\t\t\t\t\\\n\tfor (unpack_array(uk, tmp_uk);\t\t\t\t\t\t\t\\\n\t     (tmp_uk)->argc > 0 && (init_unpacker(nested_uk, (tmp_uk)->argv[0]), 1);\t\\\n\t     (tmp_uk)->argv++, (tmp_uk)->argc--)\n\n/* tmate-encoder.c */\n\n#define TMATE_PROTOCOL_VERSION 6\n\nstruct tmate_session;\n\nextern void tmate_write_header(void);\nextern void tmate_write_uname(void);\nextern void tmate_write_ready(void);\nextern void tmate_sync_layout(void);\nextern void tmate_pty_data(struct window_pane *wp, const char *buf, size_t len);\nextern int tmate_should_replicate_cmd(const struct cmd_entry *cmd);\nextern void tmate_set_val(const char *name, const char *value);\nextern void tmate_exec_cmd_args(int argc, const char **argv);\nextern void tmate_exec_cmd(struct cmd *cmd);\nextern void tmate_failed_cmd(int client_id, const char *cause);\nextern void tmate_status(const char *left, const char *right);\nextern void tmate_sync_copy_mode(struct window_pane *wp);\nextern void tmate_write_copy_mode(struct window_pane *wp, const char *str);\nextern void tmate_write_fin(void);\nextern void tmate_send_reconnection_state(struct tmate_session *session);\n\n/* tmate-decoder.c */\n\nstruct tmate_session;\nextern void tmate_dispatch_slave_message(struct tmate_session *session,\n\t\t\t\t\t struct tmate_unpacker *uk);\n\n/* tmate-ssh-client.c */\n\nenum tmate_ssh_client_state_types {\n\tSSH_NONE,\n\tSSH_INIT,\n\tSSH_CONNECT,\n\tSSH_AUTH_SERVER,\n\tSSH_AUTH_CLIENT_NONE,\n\tSSH_AUTH_CLIENT_PUBKEY,\n\tSSH_NEW_CHANNEL,\n\tSSH_OPEN_CHANNEL,\n\tSSH_BOOTSTRAP,\n\tSSH_READY,\n};\n\nstruct tmate_ssh_client {\n\t/* XXX The \"session\" word is used for three things:\n\t * - the ssh session\n\t * - the tmate sesssion\n\t * - the tmux session\n\t * A tmux session is associated 1:1 with a tmate session.\n\t * An ssh session belongs to a tmate session, and a tmate session\n\t * has one ssh session, except during bootstrapping where\n\t * there is one ssh session per tmate server, and the first one wins.\n\t */\n\tstruct tmate_session *tmate_session;\n\tTAILQ_ENTRY(tmate_ssh_client) node;\n\n\tchar *server_ip;\n\n\tint state;\n\n\t/*\n\t * ssh_callbacks is allocated because the libssh API sucks (userdata\n\t * has to be in the struct itself).\n\t */\n\tstruct ssh_callbacks_struct ssh_callbacks;\n\tchar *tried_passphrase;\n\tssh_session session;\n\tssh_channel channel;\n\n\tstruct event *ev_ssh;\n};\nTAILQ_HEAD(tmate_ssh_clients, tmate_ssh_client);\n\nextern void connect_ssh_client(struct tmate_ssh_client *client);\nextern struct tmate_ssh_client *tmate_ssh_client_alloc(struct tmate_session *session,\n\t\t\t\t\t\t       const char *server_ip);\n\n/* tmate-session.c */\n\nstruct tmate_session {\n\tstruct event_base *ev_base;\n\tstruct evdns_base *ev_dnsbase;\n\tstruct event *ev_dns_retry;\n\n\tstruct tmate_encoder encoder;\n\tstruct tmate_decoder decoder;\n\n\t/* True when the slave has sent all the environment variables */\n\tint tmate_env_ready;\n\n\tint min_sx;\n\tint min_sy;\n\n\t/*\n\t * This list contains one connection per IP. The first connected\n\t * client wins, and saved in *client. When we have a winner, the\n\t * losers are disconnected and killed.\n\t */\n\tstruct tmate_ssh_clients clients;\n\tint need_passphrase;\n\tchar *passphrase;\n\n\tbool reconnected;\n\tstruct event *ev_connection_retry;\n\tchar *last_server_ip;\n\tchar *reconnection_data;\n\t/*\n\t * When we reconnect, instead of serializing the key bindings and\n\t * options, we replay all the tmux commands we replicated.\n\t * It may be a little innacurate to replicate the state, but\n\t * it's much easier.\n\t */\n\tstruct {\n\t\tunsigned int capacity;\n\t\tunsigned int tail;\n\t\tstruct {\n\t\t\tint argc;\n\t\t\tchar **argv;\n\t\t} *cmds;\n\t} saved_tmux_cmds;\n};\n\nextern struct tmate_session tmate_session;\nextern void tmate_session_init(struct event_base *base);\nextern void tmate_session_start(void);\nextern void tmate_reconnect_session(struct tmate_session *session, const char *message);\n\n/* tmate-debug.c */\nextern void tmate_print_stack_trace(void);\nextern void tmate_catch_sigsegv(void);\nextern void tmate_preload_trace_lib(void);\n\n/* tmate-msg.c */\n\nextern void __tmate_status_message(const char *fmt, va_list ap);\nextern void printflike(1, 2) tmate_status_message(const char *fmt, ...);\n\n/* tmate-env.c */\n\nextern int tmate_has_received_env(void);\nextern void tmate_set_env(const char *name, const char *value);\nextern void tmate_format(struct format_tree *ft);\n\n#endif\n"
        },
        {
          "name": "tmux.1",
          "type": "blob",
          "size": 100.486328125,
          "content": ".\\\" $OpenBSD$\n.\\\"\n.\\\" Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n.\\\"\n.\\\" Permission to use, copy, modify, and distribute this software for any\n.\\\" purpose with or without fee is hereby granted, provided that the above\n.\\\" copyright notice and this permission notice appear in all copies.\n.\\\"\n.\\\" THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n.\\\" WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n.\\\" ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n.\\\" WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n.\\\" IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n.\\\" OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n.\\\"\n.Dd $Mdocdate: March 25 2013 $\n.Dt TMATE 1\n.Os\n.Sh NAME\n.Nm tmate\n.Nd terminal multiplexer with instant terminal sharing\n.Sh SYNOPSIS\n.Nm tmate\n.Bk -words\n.Op show-messages\n.Op Fl 2CluvV\n.Op Fl c Ar shell-command\n.Op Fl f Ar file\n.Op Fl L Ar socket-name\n.Op Fl S Ar socket-path\n.Op Ar command Op Ar flags\n.Ek\n.Sh DESCRIPTION\n.Nm\nis a terminal multiplexer with instant terminal sharing:\nit enables a number of terminals to be created, accessed, and\ncontrolled from a single screen and be shared with another mates.\n.Nm\nmay be detached from a screen\nand continue running in the background,\nthen later reattached, like as a daemon.\n.Pp\n.Nm\nprovides an instant pairing solution, allowing you to share a terminal\nwith one or several teammates. Together with a voice call, it's almost like\npairing in person. The terminal sharing works by using SSH connections to\nbackend servers maintained by tmate upstream developers; teammates need to be\ngiven a randomly-generated token to be able to join a session.\n.Pp\n.Nm\nis a modified version of tmux, and uses the same configurations such as\nkeybindings, color schemes, etc.\n.Pp\nWhen\n.Nm\nis started it creates a new\n.Em session\nwith a single\n.Em window\nand displays it on screen.\nA status line at the bottom of the screen shows information\non the current session, such as ssh command to share with\nyour mate, and is used to enter interactive commands.\n.Pp\nA session is a single collection of\n.Em pseudo terminals\nunder the management of\n.Nm .\nEach session has one or more\nwindows linked to it.\nA window occupies the entire screen\nand may be split into rectangular panes,\neach of which is a separate pseudo terminal\n(the\n.Xr pty 4\nmanual page documents the technical details of pseudo terminals).\nAny number of\n.Nm\ninstances may connect to the same session,\nand any number of windows may be present in the same session.\nOnce all sessions are killed,\n.Nm\nexits.\n.Pp\nEach session is persistent and will survive accidental disconnection\n(such as\n.Xr ssh 1\nconnection timeout) or intentional detaching (with the\n.Ql C-b d\nkey strokes).\n.Nm\nmay be reattached using:\n.Pp\n.Dl $ tmate attach\n.Pp\nIn\n.Nm ,\na session is displayed on screen by a\n.Em client\nand all sessions are managed by a single\n.Em server .\nThe server and each client are separate processes which communicate through a\nsocket in\n.Pa /tmp .\n.Pp\nThe options are as follows:\n.Bl -tag -width \"XXXXXXXXXXXX\"\n.It Fl 2\nForce\n.Nm\nto assume the terminal supports 256 colours.\n.It Fl a Ar file\nLimit access to the public keys listed in the\n.Ar file\ngiven as argument.\n.It Fl C\nStart in control mode (see the\n.Sx CONTROL MODE\nsection).\nGiven twice\n.Xo ( Fl CC ) Xc\ndisables echo.\n.It Fl c Ar shell-command\nExecute\n.Ar shell-command\nusing the default shell.\nIf necessary, the\n.Nm\nserver will be started to retrieve the\n.Ic default-shell\noption.\nThis option is for compatibility with\n.Xr sh 1\nwhen\n.Nm\nis used as a login shell.\n.It Fl f Ar file\nSpecify an alternative configuration file.\nBy default,\n.Nm\nloads the system configuration file from\n.Pa @SYSCONFDIR@/tmux.conf ,\nif present, then looks for a user configuration file at\n.Pa ~/.tmux.conf\nand\n.Pa ~/.tmate.conf .\n.Pp\nThe configuration file is a set of\n.Nm\ncommands which are executed in sequence when the server is first started.\n.Nm\nloads configuration files once when the server process has started.\nThe\n.Ic source-file\ncommand may be used to load a file later.\n.Pp\n.Nm\nshows any error messages from commands in configuration files in the first\nsession created, and continues to process the rest of the configuration file.\n.It Fl L Ar socket-name\n.Nm\nstores the server socket in a directory under\n.Ev TMUX_TMPDIR\nor\n.Pa /tmp\nif it is unset.\nThe default socket is named\n.Em default .\nThis option allows a different socket name to be specified, allowing several\nindependent\n.Nm\nservers to be run.\nUnlike\n.Fl S\na full path is not necessary: the sockets are all created in the same\ndirectory.\n.Pp\nIf the socket is accidentally removed, the\n.Dv SIGUSR1\nsignal may be sent to the\n.Nm\nserver process to recreate it (note that this will fail if any parent\ndirectories are missing).\n.It Fl l\nBehave as a login shell.\nThis flag currently has no effect and is for compatibility with other shells\nwhen using\n.Nm\nas a login shell.\n.It Fl S Ar socket-path\nSpecify a full alternative path to the server socket.\nIf\n.Fl S\nis specified, the default socket directory is not used and any\n.Fl L\nflag is ignored.\n.It Fl u\n.Nm\nattempts to guess if the terminal is likely to support UTF-8 by checking the\nfirst of the\n.Ev LC_ALL ,\n.Ev LC_CTYPE\nand\n.Ev LANG\nenvironment variables to be set for the string \"UTF-8\".\nThis is not always correct: the\n.Fl u\nflag explicitly informs\n.Nm\nthat UTF-8 is supported.\n.Pp\nNote that\n.Nm\nitself always accepts UTF-8; this controls whether it will send UTF-8\ncharacters to the terminal it is running (if not, they are replaced by\n.Ql _ ) .\n.It Fl v\nRequest verbose logging.\nThis option may be specified multiple times for increasing verbosity.\nLog messages will be saved into\n.Pa tmux-client-PID.log\nand\n.Pa tmux-server-PID.log\nfiles in the current directory, where\n.Em PID\nis the PID of the server or client process.\n.It Fl V\nReport the\n.Nm\nversion.\n.It Ar command Op Ar flags\nThis specifies one of a set of commands used to control\n.Nm ,\nas described in the following sections.\nIf no commands are specified, the\n.Ic new-session\ncommand is assumed.\n.El\n.Sh KEY BINDINGS\n.Nm\nmay be controlled from an attached client by using a key combination of a\nprefix key,\n.Ql C-b\n(Ctrl-b) by default, followed by a command key.\n.Pp\nThe default command key bindings are:\n.Pp\n.Bl -tag -width \"XXXXXXXXXX\" -offset indent -compact\n.It C-b\nSend the prefix key (C-b) through to the application.\n.It C-o\nRotate the panes in the current window forwards.\n.It C-z\nSuspend the\n.Nm\nclient.\n.It !\nBreak the current pane out of the window.\n.It \\&\"\nSplit the current pane into two, top and bottom.\n.It #\nList all paste buffers.\n.It $\nRename the current session.\n.It %\nSplit the current pane into two, left and right.\n.It &\nKill the current window.\n.It '\nPrompt for a window index to select.\n.It \\&(\nSwitch the attached client to the previous session.\n.It \\&)\nSwitch the attached client to the next session.\n.It ,\nRename the current window.\n.It -\nDelete the most recently copied buffer of text.\n.It .\nPrompt for an index to move the current window.\n.It 0 to 9\nSelect windows 0 to 9.\n.It :\nEnter the\n.Nm\ncommand prompt.\n.It ;\nMove to the previously active pane.\n.It =\nChoose which buffer to paste interactively from a list.\n.It \\&?\nList all key bindings.\n.It D\nChoose a client to detach.\n.It L\nSwitch the attached client back to the last session.\n.It \\&[\nEnter copy mode to copy text or view the history.\n.It \\&]\nPaste the most recently copied buffer of text.\n.It c\nCreate a new window.\n.It d\nDetach the current client.\n.It f\nPrompt to search for text in open windows.\n.It i\nDisplay some information about the current window.\n.It l\nMove to the previously selected window.\n.It n\nChange to the next window.\n.It o\nSelect the next pane in the current window.\n.It p\nChange to the previous window.\n.It q\nBriefly display pane indexes.\n.It r\nForce redraw of the attached client.\n.It m\nMark the current pane (see\n.Ic select-pane\n.Fl m ) .\n.It M\nClear the marked pane.\n.It s\nSelect a new session for the attached client interactively.\n.It t\nShow the time.\n.It w\nChoose the current window interactively.\n.It x\nKill the current pane.\n.It z\nToggle zoom state of the current pane.\n.It {\nSwap the current pane with the previous pane.\n.It }\nSwap the current pane with the next pane.\n.It ~\nShow previous messages from\n.Nm ,\nif any.\n.It Page Up\nEnter copy mode and scroll one page up.\n.It Up, Down\n.It Left, Right\nChange to the pane above, below, to the left, or to the right of the current\npane.\n.It M-1 to M-5\nArrange panes in one of the five preset layouts: even-horizontal,\neven-vertical, main-horizontal, main-vertical, or tiled.\n.It Space\nArrange the current window in the next preset layout.\n.It M-n\nMove to the next window with a bell or activity marker.\n.It M-o\nRotate the panes in the current window backwards.\n.It M-p\nMove to the previous window with a bell or activity marker.\n.It C-Up, C-Down\n.It C-Left, C-Right\nResize the current pane in steps of one cell.\n.It M-Up, M-Down\n.It M-Left, M-Right\nResize the current pane in steps of five cells.\n.El\n.Pp\nKey bindings may be changed with the\n.Ic bind-key\nand\n.Ic unbind-key\ncommands.\n.Sh COMMANDS\nThis section contains a list of the commands supported by\n.Nm .\nMost commands accept the optional\n.Fl t\n(and sometimes\n.Fl s )\nargument with one of\n.Ar target-client ,\n.Ar target-session\n.Ar target-window ,\nor\n.Ar target-pane .\nThese specify the client, session, window or pane which a command should affect.\n.Pp\n.Ar target-client\nis the name of the\n.Xr pty 4\nfile to which the client is connected, for example either of\n.Pa /dev/ttyp1\nor\n.Pa ttyp1\nfor the client attached to\n.Pa /dev/ttyp1 .\nIf no client is specified,\n.Nm\nattempts to work out the client currently in use; if that fails, an error is\nreported.\nClients may be listed with the\n.Ic list-clients\ncommand.\n.Pp\n.Ar target-session\nis tried as, in order:\n.Bl -enum -offset Ds\n.It\nA session ID prefixed with a $.\n.It\nAn exact name of a session (as listed by the\n.Ic list-sessions\ncommand).\n.It\nThe start of a session name, for example\n.Ql mysess\nwould match a session named\n.Ql mysession .\n.It\nAn\n.Xr fnmatch 3\npattern which is matched against the session name.\n.El\n.Pp\nIf the session name is prefixed with an\n.Ql = ,\nonly an exact match is accepted (so\n.Ql =mysess\nwill only match exactly\n.Ql mysess ,\nnot\n.Ql mysession ) .\n.Pp\nIf a single session is found, it is used as the target session; multiple matches\nproduce an error.\nIf a session is omitted, the current session is used if available; if no\ncurrent session is available, the most recently used is chosen.\n.Pp\n.Ar target-window\n(or\n.Ar src-window\nor\n.Ar dst-window )\nspecifies a window in the form\n.Em session Ns \\&: Ns Em window .\n.Em session\nfollows the same rules as for\n.Ar target-session ,\nand\n.Em window\nis looked for in order as:\n.Bl -enum -offset Ds\n.It\nA special token, listed below.\n.It\nA window index, for example\n.Ql mysession:1\nis window 1 in session\n.Ql mysession .\n.It\nA window ID, such as @1.\n.It\nAn exact window name, such as\n.Ql mysession:mywindow .\n.It\nThe start of a window name, such as\n.Ql mysession:mywin .\n.It\nAs an\n.Xr fnmatch 3\npattern matched against the window name.\n.El\n.Pp\nLike sessions, a\n.Ql =\nprefix will do an exact match only.\nAn empty window name specifies the next unused index if appropriate (for\nexample the\n.Ic new-window\nand\n.Ic link-window\ncommands)\notherwise the current window in\n.Em session\nis chosen.\n.Pp\nThe following special tokens are available to indicate particular windows.\nEach has a single-character alternative form.\n.Bl -column \"XXXXXXXXXX\" \"X\"\n.It Sy \"Token\" Ta Sy \"\" Ta Sy \"Meaning\"\n.It Li \"{start}\" Ta \"^\" Ta \"The lowest-numbered window\"\n.It Li \"{end}\" Ta \"$\" Ta \"The highest-numbered window\"\n.It Li \"{last}\" Ta \"!\" Ta \"The last (previously current) window\"\n.It Li \"{next}\" Ta \"+\" Ta \"The next window by number\"\n.It Li \"{previous}\" Ta \"-\" Ta \"The previous window by number\"\n.El\n.Pp\n.Ar target-pane\n(or\n.Ar src-pane\nor\n.Ar dst-pane )\nmay be a pane ID or takes a similar form to\n.Ar target-window\nbut with the optional addition of a period followed by a pane index or pane ID,\nfor example:\n.Ql mysession:mywindow.1 .\nIf the pane index is omitted, the currently active pane in the specified\nwindow is used.\nThe following special tokens are available for the pane index:\n.Bl -column \"XXXXXXXXXXXXXX\" \"X\"\n.It Sy \"Token\" Ta Sy \"\" Ta Sy \"Meaning\"\n.It Li \"{last}\" Ta \"!\" Ta \"The last (previously active) pane\"\n.It Li \"{next}\" Ta \"+\" Ta \"The next pane by number\"\n.It Li \"{previous}\" Ta \"-\" Ta \"The previous pane by number\"\n.It Li \"{top}\" Ta \"\" Ta \"The top pane\"\n.It Li \"{bottom}\" Ta \"\" Ta \"The bottom pane\"\n.It Li \"{left}\" Ta \"\" Ta \"The leftmost pane\"\n.It Li \"{right}\" Ta \"\" Ta \"The rightmost pane\"\n.It Li \"{top-left}\" Ta \"\" Ta \"The top-left pane\"\n.It Li \"{top-right}\" Ta \"\" Ta \"The top-right pane\"\n.It Li \"{bottom-left}\" Ta \"\" Ta \"The bottom-left pane\"\n.It Li \"{bottom-right}\" Ta \"\" Ta \"The bottom-right pane\"\n.It Li \"{up-of}\" Ta \"\" Ta \"The pane above the active pane\"\n.It Li \"{down-of}\" Ta \"\" Ta \"The pane below the active pane\"\n.It Li \"{left-of}\" Ta \"\" Ta \"The pane to the left of the active pane\"\n.It Li \"{right-of}\" Ta \"\" Ta \"The pane to the right of the active pane\"\n.El\n.Pp\nThe tokens\n.Ql +\nand\n.Ql -\nmay be followed by an offset, for example:\n.Bd -literal -offset indent\nselect-window -t:+2\n.Ed\n.Pp\nIn addition,\n.Em target-session ,\n.Em target-window\nor\n.Em target-pane\nmay consist entirely of the token\n.Ql {mouse}\n(alternative form\n.Ql = )\nto specify the most recent mouse event\n(see the\n.Sx MOUSE SUPPORT\nsection)\nor\n.Ql {marked}\n(alternative form\n.Ql ~ )\nto specify the marked pane (see\n.Ic select-pane\n.Fl m ) .\n.Pp\nSessions, window and panes are each numbered with a unique ID; session IDs are\nprefixed with a\n.Ql $ ,\nwindows with a\n.Ql @ ,\nand panes with a\n.Ql % .\nThese are unique and are unchanged for the life of the session, window or pane\nin the\n.Nm\nserver.\nThe pane ID is passed to the child process of the pane in the\n.Ev TMUX_PANE\nenvironment variable.\nIDs may be displayed using the\n.Ql session_id ,\n.Ql window_id ,\nor\n.Ql pane_id\nformats (see the\n.Sx FORMATS\nsection) and the\n.Ic display-message ,\n.Ic list-sessions ,\n.Ic list-windows\nor\n.Ic list-panes\ncommands.\n.Pp\n.Ar shell-command\narguments are\n.Xr sh 1\ncommands.\nThis may be a single argument passed to the shell, for example:\n.Bd -literal -offset indent\nnew-window 'vi /etc/passwd'\n.Ed\n.Pp\nWill run:\n.Bd -literal -offset indent\n/bin/sh -c 'vi /etc/passwd'\n.Ed\n.Pp\nAdditionally, the\n.Ic new-window ,\n.Ic new-session ,\n.Ic split-window ,\n.Ic respawn-window\nand\n.Ic respawn-pane\ncommands allow\n.Ar shell-command\nto be given as multiple arguments and executed directly (without\n.Ql sh -c ) .\nThis can avoid issues with shell quoting.\nFor example:\n.Bd -literal -offset indent\n$ tmate new-window vi /etc/passwd\n.Ed\n.Pp\nWill run\n.Xr vi 1\ndirectly without invoking the shell.\n.Pp\n.Ar command\n.Op Ar arguments\nrefers to a\n.Nm\ncommand, passed with the command and arguments separately, for example:\n.Bd -literal -offset indent\nbind-key F1 set-window-option force-width 81\n.Ed\n.Pp\nOr if using\n.Xr sh 1 :\n.Bd -literal -offset indent\n$ tmate bind-key F1 set-window-option force-width 81\n.Ed\n.Pp\nMultiple commands may be specified together as part of a\n.Em command sequence .\nEach command should be separated by spaces and a semicolon;\ncommands are executed sequentially from left to right and\nlines ending with a backslash continue on to the next line,\nexcept when escaped by another backslash.\nA literal semicolon may be included by escaping it with a backslash (for\nexample, when specifying a command sequence to\n.Ic bind-key ) .\n.Pp\nExample\n.Nm\ncommands include:\n.Bd -literal -offset indent\nrefresh-client -t/dev/ttyp2\n\nrename-session -tfirst newname\n\nset-window-option -t:0 monitor-activity on\n\nnew-window ; split-window -d\n\nbind-key R source-file ~/.tmux.conf \\e; \\e\n\tdisplay-message \"source-file done\"\n.Ed\n.Pp\nOr from\n.Xr sh 1 :\n.Bd -literal -offset indent\n$ tmate kill-window -t :1\n\n$ tmate new-window \\e; split-window -d\n\n$ tmate new-session -d 'vi /etc/passwd' \\e; split-window -d \\e; attach\n.Ed\n.Sh CLIENTS AND SESSIONS\nThe\n.Nm\nserver manages clients, sessions, windows and panes.\nClients are attached to sessions to interact with them, either\nwhen they are created with the\n.Ic new-session\ncommand, or later with the\n.Ic attach-session\ncommand.\nEach session has one or more windows\n.Em linked\ninto it.\nWindows may be linked to multiple sessions and are made up of one or\nmore panes,\neach of which contains a pseudo terminal.\nCommands for creating, linking and otherwise manipulating windows\nare covered\nin the\n.Sx WINDOWS AND PANES\nsection.\n.Pp\nThe following commands are available to manage clients and sessions:\n.Bl -tag -width Ds\n.It Xo Ic attach-session\n.Op Fl dEr\n.Op Fl c Ar working-directory\n.Op Fl t Ar target-session\n.Xc\n.D1 (alias: Ic attach )\nIf run from outside\n.Nm ,\ncreate a new client in the current terminal and attach it to\n.Ar target-session .\nIf used from inside, switch the current client.\nIf\n.Fl d\nis specified, any other clients attached to the session are detached.\n.Fl r\nsignifies the client is read-only (only keys bound to the\n.Ic detach-client\nor\n.Ic switch-client\ncommands have any effect)\n.Pp\nIf no server is started,\n.Ic attach-session\nwill attempt to start it; this will fail unless sessions are created in the\nconfiguration file.\n.Pp\nThe\n.Ar target-session\nrules for\n.Ic attach-session\nare slightly adjusted: if\n.Nm\nneeds to select the most recently used session, it will prefer the most\nrecently used\n.Em unattached\nsession.\n.Pp\n.Fl c\nwill set the session working directory (used for new windows) to\n.Ar working-directory .\n.Pp\nIf\n.Fl E\nis used, the\n.Ic update-environment\noption will not be applied.\n.It Xo Ic detach-client\n.Op Fl aP\n.Op Fl s Ar target-session\n.Op Fl t Ar target-client\n.Xc\n.D1 (alias: Ic detach )\nDetach the current client if bound to a key, the client specified with\n.Fl t ,\nor all clients currently attached to the session specified by\n.Fl s .\nThe\n.Fl a\noption kills all but the client given with\n.Fl t .\nIf\n.Fl P\nis given, send SIGHUP to the parent process of the client, typically causing it\nto exit.\n.It Ic has-session Op Fl t Ar target-session\n.D1 (alias: Ic has )\nReport an error and exit with 1 if the specified session does not exist.\nIf it does exist, exit with 0.\n.It Ic kill-server\nKill the\n.Nm\nserver and clients and destroy all sessions.\n.It Xo Ic kill-session\n.Op Fl aC\n.Op Fl t Ar target-session\n.Xc\nDestroy the given session, closing any windows linked to it and no other\nsessions, and detaching all clients attached to it.\nIf\n.Fl a\nis given, all sessions but the specified one is killed.\nThe\n.Fl C\nflag clears alerts (bell, activity, or silence) in all windows linked to the\nsession.\n.It Xo Ic list-clients\n.Op Fl F Ar format\n.Op Fl t Ar target-session\n.Xc\n.D1 (alias: Ic lsc )\nList all clients attached to the server.\nFor the meaning of the\n.Fl F\nflag, see the\n.Sx FORMATS\nsection.\nIf\n.Ar target-session\nis specified, list only clients connected to that session.\n.It Ic list-commands\n.D1 (alias: Ic lscm )\nList the syntax of all commands supported by\n.Nm .\n.It Ic list-sessions Op Fl F Ar format\n.D1 (alias: Ic ls )\nList all sessions managed by the server.\nFor the meaning of the\n.Fl F\nflag, see the\n.Sx FORMATS\nsection.\n.It Ic lock-client Op Fl t Ar target-client\n.D1 (alias: Ic lockc )\nLock\n.Ar target-client ,\nsee the\n.Ic lock-server\ncommand.\n.It Ic lock-session Op Fl t Ar target-session\n.D1 (alias: Ic locks )\nLock all clients attached to\n.Ar target-session .\n.It Xo Ic new-session\n.Op Fl AdDEP\n.Op Fl c Ar start-directory\n.Op Fl F Ar format\n.Op Fl n Ar window-name\n.Op Fl s Ar session-name\n.Op Fl t Ar target-session\n.Op Fl x Ar width\n.Op Fl y Ar height\n.Op Ar shell-command\n.Xc\n.D1 (alias: Ic new )\nCreate a new session with name\n.Ar session-name .\n.Pp\nThe new session is attached to the current terminal unless\n.Fl d\nis given.\n.Ar window-name\nand\n.Ar shell-command\nare the name of and shell command to execute in the initial window.\nIf\n.Fl d\nis used,\n.Fl x\nand\n.Fl y\nspecify the size of the initial window (80 by 24 if not given).\n.Pp\nIf run from a terminal, any\n.Xr termios 4\nspecial characters are saved and used for new windows in the new session.\n.Pp\nThe\n.Fl A\nflag makes\n.Ic new-session\nbehave like\n.Ic attach-session\nif\n.Ar session-name\nalready exists; in this case,\n.Fl D\nbehaves like\n.Fl d\nto\n.Ic attach-session .\n.Pp\nIf\n.Fl t\nis given, the new session is\n.Em grouped\nwith\n.Ar target-session .\nThis means they share the same set of windows - all windows from\n.Ar target-session\nare linked to the new session, any new windows are linked to both sessions and\nany windows closed removed from both sessions.\nThe current and previous window and any session options remain independent and\neither session may be killed without affecting the other.\n.Fl n\nand\n.Ar shell-command\nare invalid if\n.Fl t\nis used.\n.Pp\nThe\n.Fl P\noption prints information about the new session after it has been created.\nBy default, it uses the format\n.Ql #{session_name}:\nbut a different format may be specified with\n.Fl F .\n.Pp\nIf\n.Fl E\nis used, the\n.Ic update-environment\noption will not be applied.\n.It Xo Ic refresh-client\n.Op Fl S\n.Op Fl t Ar target-client\n.Xc\n.D1 (alias: Ic refresh )\nRefresh the current client if bound to a key, or a single client if one is given\nwith\n.Fl t .\nIf\n.Fl S\nis specified, only update the client's status bar.\n.It Xo Ic rename-session\n.Op Fl t Ar target-session\n.Ar new-name\n.Xc\n.D1 (alias: Ic rename )\nRename the session to\n.Ar new-name .\n.It Xo Ic show-messages\n.Op Fl JT\n.Op Fl t Ar target-client\n.Xc\n.D1 (alias: Ic showmsgs )\nShow client messages or server information.\nAny messages displayed on the status line are saved in a per-client message\nlog, up to a maximum of the limit set by the\n.Ar message-limit\nserver option.\nWith\n.Fl t ,\ndisplay the log for\n.Ar target-client .\n.Fl J\nand\n.Fl T\nshow debugging information about jobs and terminals.\n.It Ic source-file Ar path\n.D1 (alias: Ic source )\nExecute commands from\n.Ar path .\n.It Ic start-server\n.D1 (alias: Ic start )\nStart the\n.Nm\nserver, if not already running, without creating any sessions.\n.It Xo Ic suspend-client\n.Op Fl t Ar target-client\n.Xc\n.D1 (alias: Ic suspendc )\nSuspend a client by sending\n.Dv SIGTSTP\n(tty stop).\n.It Xo Ic switch-client\n.Op Fl Elnpr\n.Op Fl c Ar target-client\n.Op Fl t Ar target-session\n.Op Fl T Ar key-table\n.Xc\n.D1 (alias: Ic switchc )\nSwitch the current session for client\n.Ar target-client\nto\n.Ar target-session .\nIf\n.Fl l ,\n.Fl n\nor\n.Fl p\nis used, the client is moved to the last, next or previous session\nrespectively.\n.Fl r\ntoggles whether a client is read-only (see the\n.Ic attach-session\ncommand).\n.Pp\nIf\n.Fl E\nis used,\n.Ic update-environment\noption will not be applied.\n.Pp\n.Fl T\nsets the client's key table; the next key from the client will be interpreted from\n.Ar key-table .\nThis may be used to configure multiple prefix keys, or to bind commands to\nsequences of keys.\nFor example, to make typing\n.Ql abc\nrun the\n.Ic list-keys\ncommand:\n.Bd -literal -offset indent\nbind-key -Ttable2 c list-keys\nbind-key -Ttable1 b switch-client -Ttable2\nbind-key -Troot   a switch-client -Ttable1\n.Ed\n.El\n.Sh WINDOWS AND PANES\nA\n.Nm\nwindow may be in one of several modes.\nThe default permits direct access to the terminal attached to the window.\nThe other is copy mode, which permits a section of a window or its\nhistory to be copied to a\n.Em paste buffer\nfor later insertion into another window.\nThis mode is entered with the\n.Ic copy-mode\ncommand, bound to\n.Ql \\&[\nby default.\nIt is also entered when a command that produces output, such as\n.Ic list-keys ,\nis executed from a key binding.\n.Pp\nThe keys available depend on whether emacs or vi mode is selected\n(see the\n.Ic mode-keys\noption).\nThe following keys are supported as appropriate for the mode:\n.Bl -column \"FunctionXXXXXXXXXXXXXXXXX\" \"viXXXXXXXXXX\" \"emacs\" -offset indent\n.It Sy \"Function\" Ta Sy \"vi\" Ta Sy \"emacs\"\n.It Li \"Append selection\" Ta \"A\" Ta \"\"\n.It Li \"Back to indentation\" Ta \"^\" Ta \"M-m\"\n.It Li \"Bottom of history\" Ta \"G\" Ta \"M-<\"\n.It Li \"Clear selection\" Ta \"Escape\" Ta \"C-g\"\n.It Li \"Copy selection\" Ta \"Enter\" Ta \"M-w\"\n.It Li \"Copy to named buffer\" Ta \\&\" Ta \"\"\n.It Li \"Cursor down\" Ta \"j\" Ta \"Down\"\n.It Li \"Cursor left\" Ta \"h\" Ta \"Left\"\n.It Li \"Cursor right\" Ta \"l\" Ta \"Right\"\n.It Li \"Cursor to bottom line\" Ta \"L\" Ta \"\"\n.It Li \"Cursor to middle line\" Ta \"M\" Ta \"M-r\"\n.It Li \"Cursor to top line\" Ta \"H\" Ta \"M-R\"\n.It Li \"Cursor up\" Ta \"k\" Ta \"Up\"\n.It Li \"Delete entire line\" Ta \"d\" Ta \"C-u\"\n.It Li \"Delete/Copy to end of line\" Ta \"D\" Ta \"C-k\"\n.It Li \"End of line\" Ta \"$\" Ta \"C-e\"\n.It Li \"Go to line\" Ta \":\" Ta \"g\"\n.It Li \"Half page down\" Ta \"C-d\" Ta \"M-Down\"\n.It Li \"Half page up\" Ta \"C-u\" Ta \"M-Up\"\n.It Li \"Jump again\" Ta \";\" Ta \";\"\n.It Li \"Jump again in reverse\" Ta \",\" Ta \",\"\n.It Li \"Jump backward\" Ta \"F\" Ta \"F\"\n.It Li \"Jump forward\" Ta \"f\" Ta \"f\"\n.It Li \"Jump to backward\" Ta \"T\" Ta \"\"\n.It Li \"Jump to forward\" Ta \"t\" Ta \"\"\n.It Li \"Next page\" Ta \"C-f\" Ta \"Page down\"\n.It Li \"Next space\" Ta \"W\" Ta \"\"\n.It Li \"Next space, end of word\" Ta \"E\" Ta \"\"\n.It Li \"Next word\" Ta \"w\" Ta \"\"\n.It Li \"Next word end\" Ta \"e\" Ta \"M-f\"\n.It Li \"Other end of selection\" Ta \"o\" Ta \"\"\n.It Li \"Paste buffer\" Ta \"p\" Ta \"C-y\"\n.It Li \"Previous page\" Ta \"C-b\" Ta \"Page up\"\n.It Li \"Previous space\" Ta \"B\" Ta \"\"\n.It Li \"Previous word\" Ta \"b\" Ta \"M-b\"\n.It Li \"Quit mode\" Ta \"q\" Ta \"Escape\"\n.It Li \"Rectangle toggle\" Ta \"v\" Ta \"R\"\n.It Li \"Scroll down\" Ta \"C-Down or C-e\" Ta \"C-Down\"\n.It Li \"Scroll up\" Ta \"C-Up or C-y\" Ta \"C-Up\"\n.It Li \"Search again\" Ta \"n\" Ta \"n\"\n.It Li \"Search again in reverse\" Ta \"N\" Ta \"N\"\n.It Li \"Search backward\" Ta \"?\" Ta \"C-r\"\n.It Li \"Search forward\" Ta \"/\" Ta \"C-s\"\n.It Li \"Select line\" Ta \"V\" Ta \"\"\n.It Li \"Start of line\" Ta \"0\" Ta \"C-a\"\n.It Li \"Start selection\" Ta \"Space\" Ta \"C-Space\"\n.It Li \"Top of history\" Ta \"g\" Ta \"M->\"\n.It Li \"Transpose characters\" Ta \"\" Ta \"C-t\"\n.El\n.Pp\nThe next and previous word keys use space and the\n.Ql - ,\n.Ql _\nand\n.Ql @\ncharacters as word delimiters by default, but this can be adjusted by\nsetting the\n.Em word-separators\nsession option.\nNext word moves to the start of the next word, next word end to the end of the\nnext word and previous word to the start of the previous word.\nThe three next and previous space keys work similarly but use a space alone as\nthe word separator.\n.Pp\nThe jump commands enable quick movement within a line.\nFor instance, typing\n.Ql f\nfollowed by\n.Ql /\nwill move the cursor to the next\n.Ql /\ncharacter on the current line.\nA\n.Ql \\&;\nwill then jump to the next occurrence.\n.Pp\nCommands in copy mode may be prefaced by an optional repeat count.\nWith vi key bindings, a prefix is entered using the number keys; with\nemacs, the Alt (meta) key and a number begins prefix entry.\nFor example, to move the cursor forward by ten words, use\n.Ql M-1 0 M-f\nin emacs mode, and\n.Ql 10w\nin vi.\n.Pp\nMode key bindings are defined in a set of named tables:\n.Em vi-edit\nand\n.Em emacs-edit\nfor keys used when line editing at the command prompt;\n.Em vi-choice\nand\n.Em emacs-choice\nfor keys used when choosing from lists (such as produced by the\n.Ic choose-window\ncommand); and\n.Em vi-copy\nand\n.Em emacs-copy\nused in copy mode.\nThe tables may be viewed with the\n.Ic list-keys\ncommand and keys modified or removed with\n.Ic bind-key\nand\n.Ic unbind-key .\nIf\n.Ic append-selection ,\n.Ic copy-selection ,\nor\n.Ic start-named-buffer\nare given the\n.Fl x\nflag,\n.Nm\nwill not exit copy mode after copying.\n.Ic copy-pipe\ncopies the selection and pipes it to a command.\nFor example the following will bind\n.Ql C-w\nnot to exit after copying and\n.Ql C-q\nto copy the selection into\n.Pa /tmp\nas well as the paste buffer:\n.Bd -literal -offset indent\nbind-key -temacs-copy C-w copy-selection -x\nbind-key -temacs-copy C-q copy-pipe \"cat >/tmp/out\"\n.Ed\n.Pp\nThe paste buffer key pastes the first line from the top paste buffer on the\nstack.\n.Pp\nThe synopsis for the\n.Ic copy-mode\ncommand is:\n.Bl -tag -width Ds\n.It Xo Ic copy-mode\n.Op Fl Meu\n.Op Fl t Ar target-pane\n.Xc\nEnter copy mode.\nThe\n.Fl u\noption scrolls one page up.\n.Fl M\nbegins a mouse drag (only valid if bound to a mouse key binding, see\n.Sx MOUSE SUPPORT ) .\n.Fl e\nspecifies that scrolling to the bottom of the history (to the visible screen)\nshould exit copy mode.\nWhile in copy mode, pressing a key other than those used for scrolling will\ndisable this behaviour.\nThis is intended to allow fast scrolling through a pane's history, for\nexample with:\n.Bd -literal -offset indent\nbind PageUp copy-mode -eu\n.Ed\n.El\n.Pp\nEach window displayed by\n.Nm\nmay be split into one or more\n.Em panes ;\neach pane takes up a certain area of the display and is a separate terminal.\nA window may be split into panes using the\n.Ic split-window\ncommand.\nWindows may be split horizontally (with the\n.Fl h\nflag) or vertically.\nPanes may be resized with the\n.Ic resize-pane\ncommand (bound to\n.Ql C-up ,\n.Ql C-down\n.Ql C-left\nand\n.Ql C-right\nby default), the current pane may be changed with the\n.Ic select-pane\ncommand and the\n.Ic rotate-window\nand\n.Ic swap-pane\ncommands may be used to swap panes without changing their position.\nPanes are numbered beginning from zero in the order they are created.\n.Pp\nA number of preset\n.Em layouts\nare available.\nThese may be selected with the\n.Ic select-layout\ncommand or cycled with\n.Ic next-layout\n(bound to\n.Ql Space\nby default); once a layout is chosen, panes within it may be moved and resized\nas normal.\n.Pp\nThe following layouts are supported:\n.Bl -tag -width Ds\n.It Ic even-horizontal\nPanes are spread out evenly from left to right across the window.\n.It Ic even-vertical\nPanes are spread evenly from top to bottom.\n.It Ic main-horizontal\nA large (main) pane is shown at the top of the window and the remaining panes\nare spread from left to right in the leftover space at the bottom.\nUse the\n.Em main-pane-height\nwindow option to specify the height of the top pane.\n.It Ic main-vertical\nSimilar to\n.Ic main-horizontal\nbut the large pane is placed on the left and the others spread from top to\nbottom along the right.\nSee the\n.Em main-pane-width\nwindow option.\n.It Ic tiled\nPanes are spread out as evenly as possible over the window in both rows and\ncolumns.\n.El\n.Pp\nIn addition,\n.Ic select-layout\nmay be used to apply a previously used layout - the\n.Ic list-windows\ncommand displays the layout of each window in a form suitable for use with\n.Ic select-layout .\nFor example:\n.Bd -literal -offset indent\n$ tmate list-windows\n0: ksh [159x48]\n    layout: bb62,159x48,0,0{79x48,0,0,79x48,80,0}\n$ tmate select-layout bb62,159x48,0,0{79x48,0,0,79x48,80,0}\n.Ed\n.Pp\n.Nm\nautomatically adjusts the size of the layout for the current window size.\nNote that a layout cannot be applied to a window with more panes than that\nfrom which the layout was originally defined.\n.Pp\nCommands related to windows and panes are as follows:\n.Bl -tag -width Ds\n.It Xo Ic break-pane\n.Op Fl dP\n.Op Fl F Ar format\n.Op Fl s Ar src-pane\n.Op Fl t Ar dst-window\n.Xc\n.D1 (alias: Ic breakp )\nBreak\n.Ar src-pane\noff from its containing window to make it the only pane in\n.Ar dst-window .\nIf\n.Fl d\nis given, the new window does not become the current window.\nThe\n.Fl P\noption prints information about the new window after it has been created.\nBy default, it uses the format\n.Ql #{session_name}:#{window_index}\nbut a different format may be specified with\n.Fl F .\n.It Xo Ic capture-pane\n.Op Fl aepPq\n.Op Fl b Ar buffer-name\n.Op Fl E Ar end-line\n.Op Fl S Ar start-line\n.Op Fl t Ar target-pane\n.Xc\n.D1 (alias: Ic capturep )\nCapture the contents of a pane.\nIf\n.Fl p\nis given, the output goes to stdout, otherwise to the buffer specified with\n.Fl b\nor a new buffer if omitted.\nIf\n.Fl a\nis given, the alternate screen is used, and the history is not accessible.\nIf no alternate screen exists, an error will be returned unless\n.Fl q\nis given.\nIf\n.Fl e\nis given, the output includes escape sequences for text and background\nattributes.\n.Fl C\nalso escapes non-printable characters as octal \\exxx.\n.Fl J\njoins wrapped lines and preserves trailing spaces at each line's end.\n.Fl P\ncaptures only any output that the pane has received that is the beginning of an\nas-yet incomplete escape sequence.\n.Pp\n.Fl S\nand\n.Fl E\nspecify the starting and ending line numbers, zero is the first line of the\nvisible pane and negative numbers are lines in the history.\n.Ql -\nto\n.Fl S\nis the start of the history and to\n.Fl E\nthe end of the visible pane.\nThe default is to capture only the visible contents of the pane.\n.It Xo\n.Ic choose-client\n.Op Fl F Ar format\n.Op Fl t Ar target-window\n.Op Ar template\n.Xc\nPut a window into client choice mode, allowing a client to be selected\ninteractively from a list.\nAfter a client is chosen,\n.Ql %%\nis replaced by the client\n.Xr pty 4\npath in\n.Ar template\nand the result executed as a command.\nIf\n.Ar template\nis not given, \"detach-client -t '%%'\" is used.\nFor the meaning of the\n.Fl F\nflag, see the\n.Sx FORMATS\nsection.\nThis command works only if at least one client is attached.\n.It Xo\n.Ic choose-session\n.Op Fl F Ar format\n.Op Fl t Ar target-window\n.Op Ar template\n.Xc\nPut a window into session choice mode, where a session may be selected\ninteractively from a list.\nWhen one is chosen,\n.Ql %%\nis replaced by the session name in\n.Ar template\nand the result executed as a command.\nIf\n.Ar template\nis not given, \"switch-client -t '%%'\" is used.\nFor the meaning of the\n.Fl F\nflag, see the\n.Sx FORMATS\nsection.\nThis command works only if at least one client is attached.\n.It Xo\n.Ic choose-tree\n.Op Fl suw\n.Op Fl b Ar session-template\n.Op Fl c Ar window-template\n.Op Fl S Ar format\n.Op Fl W Ar format\n.Op Fl t Ar target-window\n.Xc\nPut a window into tree choice mode, where either sessions or windows may be\nselected interactively from a list.\nBy default, windows belonging to a session are indented to show their\nrelationship to a session.\n.Pp\nNote that the\n.Ic choose-window\nand\n.Ic choose-session\ncommands are wrappers around\n.Ic choose-tree .\n.Pp\nIf\n.Fl s\nis given, will show sessions.\nIf\n.Fl w\nis given, will show windows.\n.Pp\nBy default, the tree is collapsed and sessions must be expanded to windows\nwith the right arrow key.\nThe\n.Fl u\noption will start with all sessions expanded instead.\n.Pp\nIf\n.Fl b\nis given, will override the default session command.\nNote that\n.Ql %%\ncan be used and will be replaced with the session name.\nThe default option if not specified is \"switch-client -t '%%'\".\nIf\n.Fl c\nis given, will override the default window command.\nLike\n.Fl b ,\n.Ql %%\ncan be used and will be replaced with the session name and window index.\nWhen a window is chosen from the list, the session command is run before the\nwindow command.\n.Pp\nIf\n.Fl S\nis given will display the specified format instead of the default session\nformat.\nIf\n.Fl W\nis given will display the specified format instead of the default window\nformat.\nFor the meaning of the\n.Fl s\nand\n.Fl w\noptions, see the\n.Sx FORMATS\nsection.\n.Pp\nThis command works only if at least one client is attached.\n.It Xo\n.Ic choose-window\n.Op Fl F Ar format\n.Op Fl t Ar target-window\n.Op Ar template\n.Xc\nPut a window into window choice mode, where a window may be chosen\ninteractively from a list.\nAfter a window is selected,\n.Ql %%\nis replaced by the session name and window index in\n.Ar template\nand the result executed as a command.\nIf\n.Ar template\nis not given, \"select-window -t '%%'\" is used.\nFor the meaning of the\n.Fl F\nflag, see the\n.Sx FORMATS\nsection.\nThis command works only if at least one client is attached.\n.It Ic display-panes Op Fl t Ar target-client\n.D1 (alias: Ic displayp )\nDisplay a visible indicator of each pane shown by\n.Ar target-client .\nSee the\n.Ic display-panes-time ,\n.Ic display-panes-colour ,\nand\n.Ic display-panes-active-colour\nsession options.\nWhile the indicator is on screen, a pane may be selected with the\n.Ql 0\nto\n.Ql 9\nkeys.\n.It Xo Ic find-window\n.Op Fl CNT\n.Op Fl F Ar format\n.Op Fl t Ar target-window\n.Ar match-string\n.Xc\n.D1 (alias: Ic findw )\nSearch for the\n.Xr fnmatch 3\npattern\n.Ar match-string\nin window names, titles, and visible content (but not history).\nThe flags control matching behavior:\n.Fl C\nmatches only visible window contents,\n.Fl N\nmatches only the window name and\n.Fl T\nmatches only the window title.\nThe default is\n.Fl CNT .\nIf only one window is matched, it'll be automatically selected,\notherwise a choice list is shown.\nFor the meaning of the\n.Fl F\nflag, see the\n.Sx FORMATS\nsection.\nThis command works only if at least one client is attached.\n.It Xo Ic join-pane\n.Op Fl bdhv\n.Oo Fl l\n.Ar size |\n.Fl p Ar percentage Oc\n.Op Fl s Ar src-pane\n.Op Fl t Ar dst-pane\n.Xc\n.D1 (alias: Ic joinp )\nLike\n.Ic split-window ,\nbut instead of splitting\n.Ar dst-pane\nand creating a new pane, split it and move\n.Ar src-pane\ninto the space.\nThis can be used to reverse\n.Ic break-pane .\nThe\n.Fl b\noption causes\n.Ar src-pane\nto be joined to left of or above\n.Ar dst-pane .\n.Pp\nIf\n.Fl s\nis omitted and a marked pane is present (see\n.Ic select-pane\n.Fl m ) ,\nthe marked pane is used rather than the current pane.\n.It Xo Ic kill-pane\n.Op Fl a\n.Op Fl t Ar target-pane\n.Xc\n.D1 (alias: Ic killp )\nDestroy the given pane.\nIf no panes remain in the containing window, it is also destroyed.\nThe\n.Fl a\noption kills all but the pane given with\n.Fl t .\n.It Xo Ic kill-window\n.Op Fl a\n.Op Fl t Ar target-window\n.Xc\n.D1 (alias: Ic killw )\nKill the current window or the window at\n.Ar target-window ,\nremoving it from any sessions to which it is linked.\nThe\n.Fl a\noption kills all but the window given with\n.Fl t .\n.It Xo Ic last-pane\n.Op Fl de\n.Op Fl t Ar target-window\n.Xc\n.D1 (alias: Ic lastp )\nSelect the last (previously selected) pane.\n.Fl e\nenables or\n.Fl d\ndisables input to the pane.\n.It Ic last-window Op Fl t Ar target-session\n.D1 (alias: Ic last )\nSelect the last (previously selected) window.\nIf no\n.Ar target-session\nis specified, select the last window of the current session.\n.It Xo Ic link-window\n.Op Fl adk\n.Op Fl s Ar src-window\n.Op Fl t Ar dst-window\n.Xc\n.D1 (alias: Ic linkw )\nLink the window at\n.Ar src-window\nto the specified\n.Ar dst-window .\nIf\n.Ar dst-window\nis specified and no such window exists, the\n.Ar src-window\nis linked there.\nWith\n.Fl a ,\nthe window is moved to the next index up (following windows\nare moved if necessary).\nIf\n.Fl k\nis given and\n.Ar dst-window\nexists, it is killed, otherwise an error is generated.\nIf\n.Fl d\nis given, the newly linked window is not selected.\n.It Xo Ic list-panes\n.Op Fl as\n.Op Fl F Ar format\n.Op Fl t Ar target\n.Xc\n.D1 (alias: Ic lsp )\nIf\n.Fl a\nis given,\n.Ar target\nis ignored and all panes on the server are listed.\nIf\n.Fl s\nis given,\n.Ar target\nis a session (or the current session).\nIf neither is given,\n.Ar target\nis a window (or the current window).\nFor the meaning of the\n.Fl F\nflag, see the\n.Sx FORMATS\nsection.\n.It Xo Ic list-windows\n.Op Fl a\n.Op Fl F Ar format\n.Op Fl t Ar target-session\n.Xc\n.D1 (alias: Ic lsw )\nIf\n.Fl a\nis given, list all windows on the server.\nOtherwise, list windows in the current session or in\n.Ar target-session .\nFor the meaning of the\n.Fl F\nflag, see the\n.Sx FORMATS\nsection.\n.It Xo Ic move-pane\n.Op Fl bdhv\n.Oo Fl l\n.Ar size |\n.Fl p Ar percentage Oc\n.Op Fl s Ar src-pane\n.Op Fl t Ar dst-pane\n.Xc\n.D1 (alias: Ic movep )\nLike\n.Ic join-pane ,\nbut\n.Ar src-pane\nand\n.Ar dst-pane\nmay belong to the same window.\n.It Xo Ic move-window\n.Op Fl ardk\n.Op Fl s Ar src-window\n.Op Fl t Ar dst-window\n.Xc\n.D1 (alias: Ic movew )\nThis is similar to\n.Ic link-window ,\nexcept the window at\n.Ar src-window\nis moved to\n.Ar dst-window .\nWith\n.Fl r ,\nall windows in the session are renumbered in sequential order, respecting\nthe\n.Ic base-index\noption.\n.It Xo Ic new-window\n.Op Fl adkP\n.Op Fl c Ar start-directory\n.Op Fl F Ar format\n.Op Fl n Ar window-name\n.Op Fl t Ar target-window\n.Op Ar shell-command\n.Xc\n.D1 (alias: Ic neww )\nCreate a new window.\nWith\n.Fl a ,\nthe new window is inserted at the next index up from the specified\n.Ar target-window ,\nmoving windows up if necessary,\notherwise\n.Ar target-window\nis the new window location.\n.Pp\nIf\n.Fl d\nis given, the session does not make the new window the current window.\n.Ar target-window\nrepresents the window to be created; if the target already exists an error is\nshown, unless the\n.Fl k\nflag is used, in which case it is destroyed.\n.Ar shell-command\nis the command to execute.\nIf\n.Ar shell-command\nis not specified, the value of the\n.Ic default-command\noption is used.\n.Fl c\nspecifies the working directory in which the new window is created.\n.Pp\nWhen the shell command completes, the window closes.\nSee the\n.Ic remain-on-exit\noption to change this behaviour.\n.Pp\nThe\n.Ev TERM\nenvironment variable must be set to\n.Dq screen\nfor all programs running\n.Em inside\n.Nm .\nNew windows will automatically have\n.Dq TERM=screen\nadded to their environment, but care must be taken not to reset this in shell\nstart-up files.\n.Pp\nThe\n.Fl P\noption prints information about the new window after it has been created.\nBy default, it uses the format\n.Ql #{session_name}:#{window_index}\nbut a different format may be specified with\n.Fl F .\n.It Ic next-layout Op Fl t Ar target-window\n.D1 (alias: Ic nextl )\nMove a window to the next layout and rearrange the panes to fit.\n.It Xo Ic next-window\n.Op Fl a\n.Op Fl t Ar target-session\n.Xc\n.D1 (alias: Ic next )\nMove to the next window in the session.\nIf\n.Fl a\nis used, move to the next window with an alert.\n.It Xo Ic pipe-pane\n.Op Fl o\n.Op Fl t Ar target-pane\n.Op Ar shell-command\n.Xc\n.D1 (alias: Ic pipep )\nPipe any output sent by the program in\n.Ar target-pane\nto a shell command.\nA pane may only be piped to one command at a time, any existing pipe is\nclosed before\n.Ar shell-command\nis executed.\nThe\n.Ar shell-command\nstring may contain the special character sequences supported by the\n.Ic status-left\noption.\nIf no\n.Ar shell-command\nis given, the current pipe (if any) is closed.\n.Pp\nThe\n.Fl o\noption only opens a new pipe if no previous pipe exists, allowing a pipe to\nbe toggled with a single key, for example:\n.Bd -literal -offset indent\nbind-key C-p pipe-pane -o 'cat >>~/output.#I-#P'\n.Ed\n.It Xo Ic previous-layout\n.Op Fl t Ar target-window\n.Xc\n.D1 (alias: Ic prevl )\nMove to the previous layout in the session.\n.It Xo Ic previous-window\n.Op Fl a\n.Op Fl t Ar target-session\n.Xc\n.D1 (alias: Ic prev )\nMove to the previous window in the session.\nWith\n.Fl a ,\nmove to the previous window with an alert.\n.It Xo Ic rename-window\n.Op Fl t Ar target-window\n.Ar new-name\n.Xc\n.D1 (alias: Ic renamew )\nRename the current window, or the window at\n.Ar target-window\nif specified, to\n.Ar new-name .\n.It Xo Ic resize-pane\n.Op Fl DLMRUZ\n.Op Fl t Ar target-pane\n.Op Fl x Ar width\n.Op Fl y Ar height\n.Op Ar adjustment\n.Xc\n.D1 (alias: Ic resizep )\nResize a pane, up, down, left or right by\n.Ar adjustment\nwith\n.Fl U ,\n.Fl D ,\n.Fl L\nor\n.Fl R ,\nor\nto an absolute size\nwith\n.Fl x\nor\n.Fl y .\nThe\n.Ar adjustment\nis given in lines or cells (the default is 1).\n.Pp\nWith\n.Fl Z ,\nthe active pane is toggled between zoomed (occupying the whole of the window)\nand unzoomed (its normal position in the layout).\n.Pp\n.Fl M\nbegins mouse resizing (only valid if bound to a mouse key binding, see\n.Sx MOUSE SUPPORT ) .\n.It Xo Ic respawn-pane\n.Op Fl k\n.Op Fl t Ar target-pane\n.Op Ar shell-command\n.Xc\n.D1 (alias: Ic respawnp )\nReactivate a pane in which the command has exited (see the\n.Ic remain-on-exit\nwindow option).\nIf\n.Ar shell-command\nis not given, the command used when the pane was created is executed.\nThe pane must be already inactive, unless\n.Fl k\nis given, in which case any existing command is killed.\n.It Xo Ic respawn-window\n.Op Fl k\n.Op Fl t Ar target-window\n.Op Ar shell-command\n.Xc\n.D1 (alias: Ic respawnw )\nReactivate a window in which the command has exited (see the\n.Ic remain-on-exit\nwindow option).\nIf\n.Ar shell-command\nis not given, the command used when the window was created is executed.\nThe window must be already inactive, unless\n.Fl k\nis given, in which case any existing command is killed.\n.It Xo Ic rotate-window\n.Op Fl DU\n.Op Fl t Ar target-window\n.Xc\n.D1 (alias: Ic rotatew )\nRotate the positions of the panes within a window, either upward (numerically\nlower) with\n.Fl U\nor downward (numerically higher).\n.It Xo Ic select-layout\n.Op Fl nop\n.Op Fl t Ar target-window\n.Op Ar layout-name\n.Xc\n.D1 (alias: Ic selectl )\nChoose a specific layout for a window.\nIf\n.Ar layout-name\nis not given, the last preset layout used (if any) is reapplied.\n.Fl n\nand\n.Fl p\nare equivalent to the\n.Ic next-layout\nand\n.Ic previous-layout\ncommands.\n.Fl o\napplies the last set layout if possible (undoes the most recent layout change).\n.It Xo Ic select-pane\n.Op Fl DdegLlMmRU\n.Op Fl P Ar style\n.Op Fl t Ar target-pane\n.Xc\n.D1 (alias: Ic selectp )\nMake pane\n.Ar target-pane\nthe active pane in window\n.Ar target-window ,\nor set its style (with\n.Fl P ) .\nIf one of\n.Fl D ,\n.Fl L ,\n.Fl R ,\nor\n.Fl U\nis used, respectively the pane below, to the left, to the right, or above the\ntarget pane is used.\n.Fl l\nis the same as using the\n.Ic last-pane\ncommand.\n.Fl e\nenables or\n.Fl d\ndisables input to the pane.\n.Pp\n.Fl m\nand\n.Fl M\nare used to set and clear the\n.Em marked pane .\nThere is one marked pane at a time, setting a new marked pane clears the last.\nThe marked pane is the default target for\n.Fl s\nto\n.Ic join-pane ,\n.Ic swap-pane\nand\n.Ic swap-window .\n.Pp\nEach pane has a style: by default the\n.Ic window-style\nand\n.Ic window-active-style\noptions are used,\n.Ic select-pane\n.Fl P\nsets the style for a single pane.\nFor example, to set the pane 1 background to red:\n.Bd -literal -offset indent\nselect-pane -t:.1 -P 'bg=red'\n.Ed\n.Pp\n.Fl g\nshows the current pane style.\n.It Xo Ic select-window\n.Op Fl lnpT\n.Op Fl t Ar target-window\n.Xc\n.D1 (alias: Ic selectw )\nSelect the window at\n.Ar target-window .\n.Fl l ,\n.Fl n\nand\n.Fl p\nare equivalent to the\n.Ic last-window ,\n.Ic next-window\nand\n.Ic previous-window\ncommands.\nIf\n.Fl T\nis given and the selected window is already the current window,\nthe command behaves like\n.Ic last-window .\n.It Xo Ic split-window\n.Op Fl bdhvP\n.Op Fl c Ar start-directory\n.Oo Fl l\n.Ar size |\n.Fl p Ar percentage Oc\n.Op Fl t Ar target-pane\n.Op Ar shell-command\n.Op Fl F Ar format\n.Xc\n.D1 (alias: Ic splitw )\nCreate a new pane by splitting\n.Ar target-pane :\n.Fl h\ndoes a horizontal split and\n.Fl v\na vertical split; if neither is specified,\n.Fl v\nis assumed.\nThe\n.Fl l\nand\n.Fl p\noptions specify the size of the new pane in lines (for vertical split) or in\ncells (for horizontal split), or as a percentage, respectively.\nThe\n.Fl b\noption causes the new pane to be created to the left of or above\n.Ar target-pane .\nAll other options have the same meaning as for the\n.Ic new-window\ncommand.\n.It Xo Ic swap-pane\n.Op Fl dDU\n.Op Fl s Ar src-pane\n.Op Fl t Ar dst-pane\n.Xc\n.D1 (alias: Ic swapp )\nSwap two panes.\nIf\n.Fl U\nis used and no source pane is specified with\n.Fl s ,\n.Ar dst-pane\nis swapped with the previous pane (before it numerically);\n.Fl D\nswaps with the next pane (after it numerically).\n.Fl d\ninstructs\n.Nm\nnot to change the active pane.\n.Pp\nIf\n.Fl s\nis omitted and a marked pane is present (see\n.Ic select-pane\n.Fl m ) ,\nthe marked pane is used rather than the current pane.\n.It Xo Ic swap-window\n.Op Fl d\n.Op Fl s Ar src-window\n.Op Fl t Ar dst-window\n.Xc\n.D1 (alias: Ic swapw )\nThis is similar to\n.Ic link-window ,\nexcept the source and destination windows are swapped.\nIt is an error if no window exists at\n.Ar src-window .\n.Pp\nLike\n.Ic swap-pane ,\nif\n.Fl s\nis omitted and a marked pane is present (see\n.Ic select-pane\n.Fl m ) ,\nthe window containing the marked pane is used rather than the current window.\n.It Xo Ic unlink-window\n.Op Fl k\n.Op Fl t Ar target-window\n.Xc\n.D1 (alias: Ic unlinkw )\nUnlink\n.Ar target-window .\nUnless\n.Fl k\nis given, a window may be unlinked only if it is linked to multiple sessions -\nwindows may not be linked to no sessions;\nif\n.Fl k\nis specified and the window is linked to only one session, it is unlinked and\ndestroyed.\n.El\n.Sh KEY BINDINGS\n.Nm\nallows a command to be bound to most keys, with or without a prefix key.\nWhen specifying keys, most represent themselves (for example\n.Ql A\nto\n.Ql Z ) .\nCtrl keys may be prefixed with\n.Ql C-\nor\n.Ql ^ ,\nand Alt (meta) with\n.Ql M- .\nIn addition, the following special key names are accepted:\n.Em Up ,\n.Em Down ,\n.Em Left ,\n.Em Right ,\n.Em BSpace ,\n.Em BTab ,\n.Em DC\n(Delete),\n.Em End ,\n.Em Enter ,\n.Em Escape ,\n.Em F1\nto\n.Em F12 ,\n.Em Home ,\n.Em IC\n(Insert),\n.Em NPage/PageDown/PgDn ,\n.Em PPage/PageUp/PgUp ,\n.Em Space ,\nand\n.Em Tab .\nNote that to bind the\n.Ql \\&\"\nor\n.Ql '\nkeys, quotation marks are necessary, for example:\n.Bd -literal -offset indent\nbind-key '\"' split-window\nbind-key \"'\" new-window\n.Ed\n.Pp\nCommands related to key bindings are as follows:\n.Bl -tag -width Ds\n.It Xo Ic bind-key\n.Op Fl cnr\n.Op Fl t Ar mode-table\n.Op Fl T Ar key-table\n.Ar key Ar command Op Ar arguments\n.Xc\n.D1 (alias: Ic bind )\nBind key\n.Ar key\nto\n.Ar command .\nKeys are bound in a key table.\nBy default (without -T), the key is bound in\nthe\n.Em prefix\nkey table.\nThis table is used for keys pressed after the prefix key (for example,\nby default\n.Ql c\nis bound to\n.Ic new-window\nin the\n.Em prefix\ntable, so\n.Ql C-b c\ncreates a new window).\nThe\n.Em root\ntable is used for keys pressed without the prefix key: binding\n.Ql c\nto\n.Ic new-window\nin the\n.Em root\ntable (not recommended) means a plain\n.Ql c\nwill create a new window.\n.Fl n\nis an alias\nfor\n.Fl T Ar root .\nKeys may also be bound in custom key tables and the\n.Ic switch-client\n.Fl T\ncommand used to switch to them from a key binding.\nThe\n.Fl r\nflag indicates this key may repeat, see the\n.Ic repeat-time\noption.\n.Pp\nIf\n.Fl t\nis present,\n.Ar key\nis bound in\n.Ar mode-table :\nthe binding for command mode with\n.Fl c\nor for normal mode without.\nSee the\n.Sx WINDOWS AND PANES\nsection and the\n.Ic list-keys\ncommand for information on mode key bindings.\n.Pp\nTo view the default bindings and possible commands, see the\n.Ic list-keys\ncommand.\n.It Xo Ic list-keys\n.Op Fl t Ar mode-table\n.Op Fl T Ar key-table\n.Xc\n.D1 (alias: Ic lsk )\nList all key bindings.\nWithout\n.Fl T\nall key tables are printed.\nWith\n.Fl T\nonly\n.Ar key-table .\n.Pp\nWith\n.Fl t ,\nthe key bindings in\n.Ar mode-table\nare listed; this may be one of:\n.Em vi-edit ,\n.Em emacs-edit ,\n.Em vi-choice ,\n.Em emacs-choice ,\n.Em vi-copy\nor\n.Em emacs-copy .\n.It Xo Ic send-keys\n.Op Fl lMR\n.Op Fl t Ar target-pane\n.Ar key Ar ...\n.Xc\n.D1 (alias: Ic send )\nSend a key or keys to a window.\nEach argument\n.Ar key\nis the name of the key (such as\n.Ql C-a\nor\n.Ql npage\n) to send; if the string is not recognised as a key, it is sent as a series of\ncharacters.\nThe\n.Fl l\nflag disables key name lookup and sends the keys literally.\nAll arguments are sent sequentially from first to last.\nThe\n.Fl R\nflag causes the terminal state to be reset.\n.Pp\n.Fl M\npasses through a mouse event (only valid if bound to a mouse key binding, see\n.Sx MOUSE SUPPORT ) .\n.It Xo Ic send-prefix\n.Op Fl 2\n.Op Fl t Ar target-pane\n.Xc\nSend the prefix key, or with\n.Fl 2\nthe secondary prefix key, to a window as if it was pressed.\n.It Xo Ic unbind-key\n.Op Fl acn\n.Op Fl t Ar mode-table\n.Op Fl T Ar key-table\n.Ar key\n.Xc\n.D1 (alias: Ic unbind )\nUnbind the command bound to\n.Ar key .\n.Fl c ,\n.Fl n ,\n.Fl T\nand\n.Fl t\nare the same as for\n.Ic bind-key .\nIf\n.Fl a\nis present, all key bindings are removed.\n.El\n.Sh OPTIONS\nThe appearance and behaviour of\n.Nm\nmay be modified by changing the value of various options.\nThere are three types of option:\n.Em server options ,\n.Em session options\nand\n.Em window options .\n.Pp\nThe\n.Nm\nserver has a set of global options which do not apply to any particular\nwindow or session.\nThese are altered with the\n.Ic set-option\n.Fl s\ncommand, or displayed with the\n.Ic show-options\n.Fl s\ncommand.\n.Pp\nIn addition, each individual session may have a set of session options, and\nthere is a separate set of global session options.\nSessions which do not have a particular option configured inherit the value\nfrom the global session options.\nSession options are set or unset with the\n.Ic set-option\ncommand and may be listed with the\n.Ic show-options\ncommand.\nThe available server and session options are listed under the\n.Ic set-option\ncommand.\n.Pp\nSimilarly, a set of window options is attached to each window, and there is\na set of global window options from which any unset options are inherited.\nWindow options are altered with the\n.Ic set-window-option\ncommand and can be listed with the\n.Ic show-window-options\ncommand.\nAll window options are documented with the\n.Ic set-window-option\ncommand.\n.Pp\n.Nm\nalso supports user options which are prefixed with a\n.Ql \\&@ .\nUser options may have any name, so long as they are prefixed with\n.Ql \\&@ ,\nand be set to any string.\nFor example:\n.Bd -literal -offset indent\n$ tmate setw -q @foo \"abc123\"\n$ tmate showw -v @foo\nabc123\n.Ed\n.Pp\nCommands which set options are as follows:\n.Bl -tag -width Ds\n.It Xo Ic set-option\n.Op Fl agoqsuw\n.Op Fl t Ar target-session | Ar target-window\n.Ar option Ar value\n.Xc\n.D1 (alias: Ic set )\nSet a window option with\n.Fl w\n(equivalent to the\n.Ic set-window-option\ncommand),\na server option with\n.Fl s ,\notherwise a session option.\nIf\n.Fl g\nis given, the global session or window option is set.\nThe\n.Fl u\nflag unsets an option, so a session inherits the option from the global\noptions (or with\n.Fl g ,\nrestores a global option to the default).\n.Pp\nThe\n.Fl o\nflag prevents setting an option that is already set and the\n.Fl q\nflag suppresses errors about unknown or ambiguous options.\n.Pp\nWith\n.Fl a ,\nand if the option expects a string or a style,\n.Ar value\nis appended to the existing setting.\nFor example:\n.Bd -literal -offset indent\nset -g status-left \"foo\"\nset -ag status-left \"bar\"\n.Ed\n.Pp\nWill result in\n.Ql foobar .\nAnd:\n.Bd -literal -offset indent\nset -g status-style \"bg=red\"\nset -ag status-style \"fg=blue\"\n.Ed\n.Pp\nWill result in a red background\n.Em and\nblue foreground.\nWithout\n.Fl a ,\nthe result would be the default background and a blue foreground.\n.Pp\nAvailable window options are listed under\n.Ic set-window-option .\n.Pp\n.Ar value\ndepends on the option and may be a number, a string, or a flag (on, off, or\nomitted to toggle).\n.Pp\nAvailable server options are:\n.Bl -tag -width Ds\n.It Ic buffer-limit Ar number\nSet the number of buffers; as new buffers are added to the top of the stack,\nold ones are removed from the bottom if necessary to maintain this maximum\nlength.\n.It Ic default-terminal Ar terminal\nSet the default terminal for new windows created in this session - the\ndefault value of the\n.Ev TERM\nenvironment variable.\nFor\n.Nm\nto work correctly, this\n.Em must\nbe set to\n.Ql screen ,\n.Ql tmux ,\n.Ql tmate\nor a derivative of them.\n.It Ic escape-time Ar time\nSet the time in milliseconds for which\n.Nm\nwaits after an escape is input to determine if it is part of a function or meta\nkey sequences.\nThe default is 500 milliseconds.\n.It Xo Ic exit-unattached\n.Op Ic on | off\n.Xc\nIf enabled, the server will exit when there are no attached clients.\n.It Xo Ic focus-events\n.Op Ic on | off\n.Xc\nWhen enabled, focus events are requested from the terminal if supported and\npassed through to applications running in\n.Nm .\nAttached clients should be detached and attached again after changing this\noption.\n.It Ic history-file Ar path\nIf not empty, a file to which\n.Nm\nwill write command prompt history on exit and load it from on start.\n.It Ic message-limit Ar number\nSet the number of error or information messages to save in the message log for\neach client.\nThe default is 100.\n.It Xo Ic set-clipboard\n.Op Ic on | off\n.Xc\nAttempt to set the terminal clipboard content using the\n\\ee]52;...\\e007\n.Xr xterm 1\nescape sequences.\nThis option is on by default if there is an\n.Em \\&Ms\nentry in the\n.Xr terminfo 5\ndescription for the client terminal.\nNote that this feature needs to be enabled in\n.Xr xterm 1\nby setting the resource:\n.Bd -literal -offset indent\ndisallowedWindowOps: 20,21,SetXprop\n.Ed\n.Pp\nOr changing this property from the\n.Xr xterm 1\ninteractive menu when required.\n.It Ic terminal-overrides Ar string\nContains a list of entries which override terminal descriptions read using\n.Xr terminfo 5 .\n.Ar string\nis a comma-separated list of items each a colon-separated string made up of a\nterminal type pattern (matched using\n.Xr fnmatch 3 )\nand a set of\n.Em name=value\nentries.\n.Pp\nFor example, to set the\n.Ql clear\n.Xr terminfo 5\nentry to\n.Ql \\ee[H\\ee[2J\nfor all terminal types and the\n.Ql dch1\nentry to\n.Ql \\ee[P\nfor the\n.Ql rxvt\nterminal type, the option could be set to the string:\n.Bd -literal -offset indent\n\"*:clear=\\ee[H\\ee[2J,rxvt:dch1=\\ee[P\"\n.Ed\n.Pp\nThe terminal entry value is passed through\n.Xr strunvis 3\nbefore interpretation.\nThe default value forcibly corrects the\n.Ql colors\nentry for terminals which support 256 colours:\n.Bd -literal -offset indent\n\"*256col*:colors=256,xterm*:XT\"\n.Ed\n.El\n.Pp\nAvailable session options are:\n.Bl -tag -width Ds\n.It Ic assume-paste-time Ar milliseconds\nIf keys are entered faster than one in\n.Ar milliseconds ,\nthey are assumed to have been pasted rather than typed and\n.Nm\nkey bindings are not processed.\nThe default is one millisecond and zero disables.\n.It Ic base-index Ar index\nSet the base index from which an unused index should be searched when a new\nwindow is created.\nThe default is zero.\n.It Xo Ic bell-action\n.Op Ic any | none | current | other\n.Xc\nSet action on window bell.\n.Ic any\nmeans a bell in any window linked to a session causes a bell in the current\nwindow of that session,\n.Ic none\nmeans all bells are ignored,\n.Ic current\nmeans only bells in windows other than the current window are ignored and\n.Ic other\nmeans bells in the current window are ignored but not those in other windows.\n.It Xo Ic bell-on-alert\n.Op Ic on | off\n.Xc\nIf on, ring the terminal bell when an alert\noccurs.\n.It Ic default-command Ar shell-command\nSet the command used for new windows (if not specified when the window is\ncreated) to\n.Ar shell-command ,\nwhich may be any\n.Xr sh 1\ncommand.\nThe default is an empty string, which instructs\n.Nm\nto create a login shell using the value of the\n.Ic default-shell\noption.\n.It Ic default-shell Ar path\nSpecify the default shell.\nThis is used as the login shell for new windows when the\n.Ic default-command\noption is set to empty, and must be the full path of the executable.\nWhen started\n.Nm\ntries to set a default value from the first suitable of the\n.Ev SHELL\nenvironment variable, the shell returned by\n.Xr getpwuid 3 ,\nor\n.Pa /bin/sh .\nThis option should be configured when\n.Nm\nis used as a login shell.\n.It Xo Ic destroy-unattached\n.Op Ic on | off\n.Xc\nIf enabled and the session is no longer attached to any clients, it is\ndestroyed.\n.It Xo Ic detach-on-destroy\n.Op Ic on | off\n.Xc\nIf on (the default), the client is detached when the session it is attached to\nis destroyed.\nIf off, the client is switched to the most recently active of the remaining\nsessions.\n.It Ic display-panes-active-colour Ar colour\nSet the colour used by the\n.Ic display-panes\ncommand to show the indicator for the active pane.\n.It Ic display-panes-colour Ar colour\nSet the colour used by the\n.Ic display-panes\ncommand to show the indicators for inactive panes.\n.It Ic display-panes-time Ar time\nSet the time in milliseconds for which the indicators shown by the\n.Ic display-panes\ncommand appear.\n.It Ic display-time Ar time\nSet the amount of time for which status line messages and other on-screen\nindicators are displayed.\nIf set to 0, messages and indicators are displayed until a key is pressed.\n.Ar time\nis in milliseconds.\n.It Ic history-limit Ar lines\nSet the maximum number of lines held in window history.\nThis setting applies only to new windows - existing window histories are not\nresized and retain the limit at the point they were created.\n.It Ic key-table Ar key-table\nSet the default key table to\n.Ar key-table\ninstead of\n.Em root .\n.It Ic lock-after-time Ar number\nLock the session (like the\n.Ic lock-session\ncommand) after\n.Ar number\nseconds of inactivity.\nThe default is not to lock (set to 0).\n.It Ic lock-command Ar shell-command\nCommand to run when locking each client.\nThe default is to run\n.Xr lock 1\nwith\n.Fl np .\n.It Ic message-command-style Ar style\nSet status line message command style, where\n.Ar style\nis a comma-separated list of characteristics to be specified.\n.Pp\nThese may be\n.Ql bg=colour\nto set the background colour,\n.Ql fg=colour\nto set the foreground colour, and a list of attributes as specified below.\n.Pp\nThe colour is one of:\n.Ic black ,\n.Ic red ,\n.Ic green ,\n.Ic yellow ,\n.Ic blue ,\n.Ic magenta ,\n.Ic cyan ,\n.Ic white ,\naixterm bright variants (if supported:\n.Ic brightred ,\n.Ic brightgreen ,\nand so on),\n.Ic colour0\nto\n.Ic colour255\nfrom the 256-colour set,\n.Ic default ,\nor a hexadecimal RGB string such as\n.Ql #ffffff ,\nwhich chooses the closest match from the default 256-colour set.\n.Pp\nThe attributes is either\n.Ic none\nor a comma-delimited list of one or more of:\n.Ic bright\n(or\n.Ic bold ) ,\n.Ic dim ,\n.Ic underscore ,\n.Ic blink ,\n.Ic reverse ,\n.Ic hidden ,\nor\n.Ic italics ,\nto turn an attribute on, or an attribute prefixed with\n.Ql no\nto turn one off.\n.Pp\nExamples are:\n.Bd -literal -offset indent\nfg=yellow,bold,underscore,blink\nbg=black,fg=default,noreverse\n.Ed\n.Pp\nWith the\n.Fl a\nflag to the\n.Ic set-option\ncommand the new style is added otherwise the existing style is replaced.\n.It Ic message-style Ar style\nSet status line message style.\nFor how to specify\n.Ar style ,\nsee the\n.Ic message-command-style\noption.\n.It Xo Ic mouse\n.Op Ic on | off\n.Xc\nIf on,\n.Nm\ncaptures the mouse and allows mouse events to be bound as key bindings.\nSee the\n.Sx MOUSE SUPPORT\nsection for details.\n.It Ic prefix Ar key\nSet the key accepted as a prefix key.\nIn addition to the standard keys described under\n.Sx KEY BINDINGS ,\n.Ic prefix\ncan be set to the special key\n.Ql None\nto set no prefix.\n.It Ic prefix2 Ar key\nSet a secondary key accepted as a prefix key.\nLike\n.Ic prefix ,\n.Ic prefix2\ncan be set to\n.Ql None .\n.It Xo Ic renumber-windows\n.Op Ic on | off\n.Xc\nIf on, when a window is closed in a session, automatically renumber the other\nwindows in numerical order.\nThis respects the\n.Ic base-index\noption if it has been set.\nIf off, do not renumber the windows.\n.It Ic repeat-time Ar time\nAllow multiple commands to be entered without pressing the prefix-key again\nin the specified\n.Ar time\nmilliseconds (the default is 500).\nWhether a key repeats may be set when it is bound using the\n.Fl r\nflag to\n.Ic bind-key .\nRepeat is enabled for the default keys bound to the\n.Ic resize-pane\ncommand.\n.It Xo Ic set-remain-on-exit\n.Op Ic on | off\n.Xc\nSet the\n.Ic remain-on-exit\nwindow option for any windows first created in this session.\nWhen this option is true, windows in which the running program has\nexited do not close, instead remaining open but inactivate.\nUse the\n.Ic respawn-window\ncommand to reactivate such a window, or the\n.Ic kill-window\ncommand to destroy it.\n.It Xo Ic set-titles\n.Op Ic on | off\n.Xc\nAttempt to set the client terminal title using the\n.Em tsl\nand\n.Em fsl\n.Xr terminfo 5\nentries if they exist.\n.Nm\nautomatically sets these to the \\ee]0;...\\e007 sequence if\nthe terminal appears to be\n.Xr xterm 1 .\nThis option is off by default.\n.It Ic set-titles-string Ar string\nString used to set the window title if\n.Ic set-titles\nis on.\nFormats are expanded, see the\n.Sx FORMATS\nsection.\n.It Xo Ic status\n.Op Ic on | off\n.Xc\nShow or hide the status line.\n.It Ic status-interval Ar interval\nUpdate the status bar every\n.Ar interval\nseconds.\nBy default, updates will occur every 15 seconds.\nA setting of zero disables redrawing at interval.\n.It Xo Ic status-justify\n.Op Ic left | centre | right\n.Xc\nSet the position of the window list component of the status line: left, centre\nor right justified.\n.It Xo Ic status-keys\n.Op Ic vi | emacs\n.Xc\nUse vi or emacs-style\nkey bindings in the status line, for example at the command prompt.\nThe default is emacs, unless the\n.Ev VISUAL\nor\n.Ev EDITOR\nenvironment variables are set and contain the string\n.Ql vi .\n.It Ic status-left Ar string\nDisplay\n.Ar string\n(by default the session name) to the left of the status bar.\n.Ar string\nwill be passed through\n.Xr strftime 3\nand formats (see\n.Sx FORMATS )\nwill be expanded.\nIt may also contain any of the following special character sequences:\n.Bl -column \"Character pair\" \"Replaced with\" -offset indent\n.It Sy \"Character pair\" Ta Sy \"Replaced with\"\n.It Li \"#[attributes]\" Ta \"Colour or attribute change\"\n.It Li \"##\" Ta \"A literal\" Ql #\n.El\n.Pp\nFor details on how the names and titles can be set see the\n.Sx \"NAMES AND TITLES\"\nsection.\nFor a list of allowed attributes see the\n.Ic message-command-style\noption.\n.Pp\nExamples are:\n.Bd -literal -offset indent\n#(sysctl vm.loadavg)\n#[fg=yellow,bold]#(apm -l)%%#[default] [#S]\n.Ed\n.Pp\nThe default is\n.Ql \"[#S] \" .\n.It Ic status-left-length Ar length\nSet the maximum\n.Ar length\nof the left component of the status bar.\nThe default is 10.\n.It Ic status-left-style Ar style\nSet the style of the left part of the status line.\nFor how to specify\n.Ar style ,\nsee the\n.Ic message-command-style\noption.\n.It Xo Ic status-position\n.Op Ic top | bottom\n.Xc\nSet the position of the status line.\n.It Ic status-right Ar string\nDisplay\n.Ar string\nto the right of the status bar.\nBy default, the current window title in double quotes, the date and the time\nare shown.\nAs with\n.Ic status-left ,\n.Ar string\nwill be passed to\n.Xr strftime 3\nand character pairs are replaced.\n.It Ic status-right-length Ar length\nSet the maximum\n.Ar length\nof the right component of the status bar.\nThe default is 40.\n.It Ic status-right-style Ar style\nSet the style of the right part of the status line.\nFor how to specify\n.Ar style ,\nsee the\n.Ic message-command-style\noption.\n.It Ic status-style Ar style\nSet status line style.\nFor how to specify\n.Ar style ,\nsee the\n.Ic message-command-style\noption.\n.It Ic update-environment Ar variables\nSet a space-separated string containing a list of environment variables to be\ncopied into the session environment when a new session is created or an\nexisting session is attached.\nAny variables that do not exist in the source environment are set to be\nremoved from the session environment (as if\n.Fl r\nwas given to the\n.Ic set-environment\ncommand).\nThe default is\n\"DISPLAY SSH_ASKPASS SSH_AUTH_SOCK SSH_AGENT_PID SSH_CONNECTION WINDOWID\nXAUTHORITY\".\n.It Xo Ic visual-activity\n.Op Ic on | off\n.Xc\nIf on, display a status line message when activity occurs in a window\nfor which the\n.Ic monitor-activity\nwindow option is enabled.\n.It Xo Ic visual-bell\n.Op Ic on | off\n.Xc\nIf this option is on, a message is shown on a bell instead of it being passed\nthrough to the terminal (which normally makes a sound).\nAlso see the\n.Ic bell-action\noption.\n.It Xo Ic visual-silence\n.Op Ic on | off\n.Xc\nIf\n.Ic monitor-silence\nis enabled, prints a message after the interval has expired on a given window.\n.It Ic word-separators Ar string\nSets the session's conception of what characters are considered word\nseparators, for the purposes of the next and previous word commands in\ncopy mode.\nThe default is\n.Ql \\ -_@ .\n.El\n.It Xo Ic set-window-option\n.Op Fl agoqu\n.Op Fl t Ar target-window\n.Ar option Ar value\n.Xc\n.D1 (alias: Ic setw )\nSet a window option.\nThe\n.Fl a ,\n.Fl g ,\n.Fl o ,\n.Fl q\nand\n.Fl u\nflags work similarly to the\n.Ic set-option\ncommand.\n.Pp\nSupported window options are:\n.Pp\n.Bl -tag -width Ds -compact\n.It Xo Ic aggressive-resize\n.Op Ic on | off\n.Xc\nAggressively resize the chosen window.\nThis means that\n.Nm\nwill resize the window to the size of the smallest session for which it is the\ncurrent window, rather than the smallest session to which it is attached.\nThe window may resize when the current window is changed on another sessions;\nthis option is good for full-screen programs which support\n.Dv SIGWINCH\nand poor for interactive programs such as shells.\n.Pp\n.It Xo Ic allow-rename\n.Op Ic on | off\n.Xc\nAllow programs to change the window name using a terminal escape\nsequence (\\eek...\\ee\\e\\e).\nThe default is on.\n.Pp\n.It Xo Ic alternate-screen\n.Op Ic on | off\n.Xc\nThis option configures whether programs running inside\n.Nm\nmay use the terminal alternate screen feature, which allows the\n.Em smcup\nand\n.Em rmcup\n.Xr terminfo 5\ncapabilities.\nThe alternate screen feature preserves the contents of the window when an\ninteractive application starts and restores it on exit, so that any output\nvisible before the application starts reappears unchanged after it exits.\nThe default is on.\n.Pp\n.It Xo Ic automatic-rename\n.Op Ic on | off\n.Xc\nControl automatic window renaming.\nWhen this setting is enabled,\n.Nm\nwill rename the window automatically using the format specified by\n.Ic automatic-rename-format .\nThis flag is automatically disabled for an individual window when a name\nis specified at creation with\n.Ic new-window\nor\n.Ic new-session ,\nor later with\n.Ic rename-window ,\nor with a terminal escape sequence.\nIt may be switched off globally with:\n.Bd -literal -offset indent\nset-window-option -g automatic-rename off\n.Ed\n.Pp\n.It Ic automatic-rename-format Ar format\nThe format (see\n.Sx FORMATS )\nused when the\n.Ic automatic-rename\noption is enabled.\n.Pp\n.It Ic clock-mode-colour Ar colour\nSet clock colour.\n.Pp\n.It Xo Ic clock-mode-style\n.Op Ic 12 | 24\n.Xc\nSet clock hour format.\n.Pp\n.It Ic force-height Ar height\n.It Ic force-width Ar width\nPrevent\n.Nm\nfrom resizing a window to greater than\n.Ar width\nor\n.Ar height .\nA value of zero restores the default unlimited setting.\n.Pp\n.It Ic main-pane-height Ar height\n.It Ic main-pane-width Ar width\nSet the width or height of the main (left or top) pane in the\n.Ic main-horizontal\nor\n.Ic main-vertical\nlayouts.\n.Pp\n.It Xo Ic mode-keys\n.Op Ic vi | emacs\n.Xc\nUse vi or emacs-style key bindings in copy and choice modes.\nAs with the\n.Ic status-keys\noption, the default is emacs, unless\n.Ev VISUAL\nor\n.Ev EDITOR\ncontains\n.Ql vi .\n.Pp\n.It Ic mode-style Ar style\nSet window modes style.\nFor how to specify\n.Ar style ,\nsee the\n.Ic message-command-style\noption.\n.Pp\n.It Xo Ic monitor-activity\n.Op Ic on | off\n.Xc\nMonitor for activity in the window.\nWindows with activity are highlighted in the status line.\n.Pp\n.It Xo Ic monitor-silence\n.Op Ic interval\n.Xc\nMonitor for silence (no activity) in the window within\n.Ic interval\nseconds.\nWindows that have been silent for the interval are highlighted in the\nstatus line.\nAn interval of zero disables the monitoring.\n.Pp\n.It Ic other-pane-height Ar height\nSet the height of the other panes (not the main pane) in the\n.Ic main-horizontal\nlayout.\nIf this option is set to 0 (the default), it will have no effect.\nIf both the\n.Ic main-pane-height\nand\n.Ic other-pane-height\noptions are set, the main pane will grow taller to make the other panes the\nspecified height, but will never shrink to do so.\n.Pp\n.It Ic other-pane-width Ar width\nLike\n.Ic other-pane-height ,\nbut set the width of other panes in the\n.Ic main-vertical\nlayout.\n.Pp\n.It Ic pane-active-border-style Ar style\nSet the pane border style for the currently active pane.\nFor how to specify\n.Ar style ,\nsee the\n.Ic message-command-style\noption.\nAttributes are ignored.\n.Pp\n.It Ic pane-base-index Ar index\nLike\n.Ic base-index ,\nbut set the starting index for pane numbers.\n.Pp\n.It Ic pane-border-style Ar style\nSet the pane border style for panes aside from the active pane.\nFor how to specify\n.Ar style ,\nsee the\n.Ic message-command-style\noption.\nAttributes are ignored.\n.Pp\n.It Xo Ic remain-on-exit\n.Op Ic on | off\n.Xc\nA window with this flag set is not destroyed when the program running in it\nexits.\nThe window may be reactivated with the\n.Ic respawn-window\ncommand.\n.Pp\n.It Xo Ic synchronize-panes\n.Op Ic on | off\n.Xc\nDuplicate input to any pane to all other panes in the same window (only\nfor panes that are not in any special mode).\n.Pp\n.It Ic window-active-style Ar style\nSet the style for the window's active pane.\nFor how to specify\n.Ar style ,\nsee the\n.Ic message-command-style\noption.\n.Pp\n.It Ic window-status-activity-style Ar style\nSet status line style for windows with an activity alert.\nFor how to specify\n.Ar style ,\nsee the\n.Ic message-command-style\noption.\n.Pp\n.It Ic window-status-bell-style Ar style\nSet status line style for windows with a bell alert.\nFor how to specify\n.Ar style ,\nsee the\n.Ic message-command-style\noption.\n.Pp\n.It Ic window-status-current-format Ar string\nLike\n.Ar window-status-format ,\nbut is the format used when the window is the current window.\n.Pp\n.It Ic window-status-current-style Ar style\nSet status line style for the currently active window.\nFor how to specify\n.Ar style ,\nsee the\n.Ic message-command-style\noption.\n.Pp\n.It Ic window-status-format Ar string\nSet the format in which the window is displayed in the status line window list.\nSee the\n.Ar status-left\noption for details of special character sequences available.\nThe default is\n.Ql #I:#W#F .\n.Pp\n.It Ic window-status-last-style Ar style\nSet status line style for the last active window.\nFor how to specify\n.Ar style ,\nsee the\n.Ic message-command-style\noption.\n.Pp\n.It Ic window-status-separator Ar string\nSets the separator drawn between windows in the status line.\nThe default is a single space character.\n.Pp\n.It Ic window-status-style Ar style\nSet status line style for a single window.\nFor how to specify\n.Ar style ,\nsee the\n.Ic message-command-style\noption.\n.Pp\n.It Ic window-style Ar style\nSet the default window style.\nFor how to specify\n.Ar style ,\nsee the\n.Ic message-command-style\noption.\n.Pp\n.It Xo Ic xterm-keys\n.Op Ic on | off\n.Xc\nIf this option is set,\n.Nm\nwill generate\n.Xr xterm 1 -style\nfunction key sequences; these have a number included to indicate modifiers such\nas Shift, Alt or Ctrl.\nThe default is off.\n.Pp\n.It Xo Ic wrap-search\n.Op Ic on | off\n.Xc\nIf this option is set, searches will wrap around the end of the pane contents.\nThe default is on.\n.El\n.It Xo Ic show-options\n.Op Fl gqsvw\n.Op Fl t Ar target-session | Ar target-window\n.Op Ar option\n.Xc\n.D1 (alias: Ic show )\nShow the window options (or a single window option if given) with\n.Fl w\n(equivalent to\n.Ic show-window-options ) ,\nthe server options with\n.Fl s ,\notherwise the session options for\n.Ar target session .\nGlobal session or window options are listed if\n.Fl g\nis used.\n.Fl v\nshows only the option value, not the name.\nIf\n.Fl q\nis set, no error will be returned if\n.Ar option\nis unset.\n.It Xo Ic show-window-options\n.Op Fl gv\n.Op Fl t Ar target-window\n.Op Ar option\n.Xc\n.D1 (alias: Ic showw )\nList the window options or a single option for\n.Ar target-window ,\nor the global window options if\n.Fl g\nis used.\n.Fl v\nshows only the option value, not the name.\n.El\n.Sh HOOKS\n.Nm\nallows commands to run on various triggers, called\n.Em hooks .\nEach hook has a\n.Em name .\nThe following hooks are available:\n.Bl -tag -width \"XXXXXXXXXXXXXXXX\"\n.It alert-activity\nRun when a window has activity.\nSee\n.Ic monitor-activity .\n.It alert-bell\nRun when a window has received a bell.\n.It alert-silence\nRun when a window has been silent.\nSee\n.Ic monitor-silence .\n.It client-attached\nRun when a client is attached.\n.It client-detached\nRun when a client is detached\n.It client-resized\nRun when a client is resized.\n.It pane-died\nRun when the program running in a pane exits, but\n.Ic remain-on-exit\nis on so the pane has not closed.\n.It pane-exited\nRun when the program running in a pane exits.\n.El\n.Pp\nHooks are managed with these commands:\n.Bl -tag -width Ds\n.It Xo Ic set-hook\n.Op Fl g\n.Op Fl t Ar target-session\n.Ar hook-name\n.Ar command\n.Xc\nSets hook\n.Ar hook-name\nto\n.Ar command .\nIf\n.Fl g\nis given,\n.Em hook-name\nis added to the global list of hooks, otherwise it is added to the session\nhooks (for\n.Ar target-session\nwith\n.Fl t ) .\nLike options, session hooks inherit from the global ones.\n.It Xo Ic show-hooks\n.Op Fl g\n.Op Fl t Ar target-session\n.Xc\nShows the global list of hooks with\n.Fl g ,\notherwise the session hooks.\n.El\n.Sh MOUSE SUPPORT\nIf the\n.Ic mouse\noption is on (the default is off),\n.Nm\nallows mouse events to be bound as keys.\nThe name of each key is made up of a mouse event (such as\n.Ql MouseUp1 )\nand a location suffix (one of\n.Ql Pane\nfor the contents of a pane,\n.Ql Border\nfor a pane border or\n.Ql Status\nfor the status line).\nThe following mouse events are available:\n.Bl -column \"MouseDown1\" \"MouseDrag1\" \"WheelDown\" -offset indent\n.It Li \"MouseDown1\" Ta \"MouseUp1\" Ta \"MouseDrag1\" Ta \"MouseDragEnd1\"\n.It Li \"MouseDown2\" Ta \"MouseUp2\" Ta \"MouseDrag2\" Ta \"MouseDragEnd2\"\n.It Li \"MouseDown3\" Ta \"MouseUp3\" Ta \"MouseDrag3\" Ta \"MouseDragEnd3\"\n.It Li \"WheelUp\" Ta \"WheelDown\" Ta \"\" Ta \"\"\n.El\n.Pp\nEach should be suffixed with a location, for example\n.Ql MouseDown1Status .\n.Pp\nThe special token\n.Ql {mouse}\nor\n.Ql =\nmay be used as\n.Ar target-window\nor\n.Ar target-pane\nin commands bound to mouse key bindings.\nIt resolves to the window or pane over which the mouse event took place\n(for example, the window in the status line over which button 1 was released for a\n.Ql MouseUp1Status\nbinding, or the pane over which the wheel was scrolled for a\n.Ql WheelDownPane\nbinding).\n.Pp\nThe\n.Ic send-keys\n.Fl M\nflag may be used to forward a mouse event to a pane.\n.Pp\nThe default key bindings allow the mouse to be used to select and resize panes,\nto copy text and to change window using the status line.\nThese take effect if the\n.Ic mouse\noption is turned on.\n.Sh FORMATS\nCertain commands accept the\n.Fl F\nflag with a\n.Ar format\nargument.\nThis is a string which controls the output format of the command.\nReplacement variables are enclosed in\n.Ql #{\nand\n.Ql } ,\nfor example\n.Ql #{session_name} .\nThe possible variables are listed in the table below, or the name of a\n.Nm\noption may be used for an option's value.\nSome variables have a shorter alias such as\n.Ql #S ,\nand\n.Ql ##\nis replaced by a single\n.Ql # .\n.Pp\nConditionals are available by prefixing with\n.Ql \\&?\nand separating two alternatives with a comma;\nif the specified variable exists and is not zero, the first alternative\nis chosen, otherwise the second is used.\nFor example\n.Ql #{?session_attached,attached,not attached}\nwill include the string\n.Ql attached\nif the session is attached and the string\n.Ql not attached\nif it is unattached, or\n.Ql #{?automatic-rename,yes,no}\nwill include\n.Ql yes\nif\n.Ic automatic-rename\nis enabled, or\n.Ql no\nif not.\n.Pp\nA limit may be placed on the length of the resultant string by prefixing it\nby an\n.Ql = ,\na number and a colon.\nPositive numbers count from the start of the string and negative from the end,\nso\n.Ql #{=5:pane_title}\nwill include at most the first 5 characters of the pane title, or\n.Ql #{=-5:pane_title}\nthe last 5 characters.\nPrefixing a time variable with\n.Ql t:\nwill convert it to a string, so if\n.Ql #{window_activity}\ngives\n.Ql 1445765102 ,\n.Ql #{t:window_activity}\ngives\n.Ql Sun Oct 25 09:25:02 2015 .\nThe\n.Ql b:\nand\n.Ql d:\nprefixes are\n.Xr basename 3\nand\n.Xr dirname 3\nof the variable respectively.\nA prefix of the form\n.Ql s/foo/bar/:\nwill substitute\n.Ql foo\nwith\n.Ql bar\nthroughout.\n.Pp\nIn addition, the first line of a shell command's output may be inserted using\n.Ql #() .\nFor example,\n.Ql #(uptime)\nwill insert the system's uptime.\nWhen constructing formats,\n.Nm\ndoes not wait for\n.Ql #()\ncommands to finish; instead, the previous result from running the same command is used,\nor a placeholder if the command has not been run before.\nCommands are executed with the\n.Nm\nglobal environment set (see the\n.Sx ENVIRONMENT\nsection).\n.Pp\nThe following variables are available, where appropriate:\n.Bl -column \"XXXXXXXXXXXXXXXXXXX\" \"XXXXX\"\n.It Sy \"Variable name\" Ta Sy \"Alias\" Ta Sy \"Replaced with\"\n.It Li \"alternate_on\" Ta \"\" Ta \"If pane is in alternate screen\"\n.It Li \"alternate_saved_x\" Ta \"\" Ta \"Saved cursor X in alternate screen\"\n.It Li \"alternate_saved_y\" Ta \"\" Ta \"Saved cursor Y in alternate screen\"\n.It Li \"buffer_sample\" Ta \"\" Ta \"Sample of start of buffer\"\n.It Li \"buffer_size\" Ta \"\" Ta \"Size of the specified buffer in bytes\"\n.It Li \"client_activity\" Ta \"\" Ta \"Integer time client last had activity\"\n.It Li \"client_created\" Ta \"\" Ta \"Integer time client created\"\n.It Li \"client_control_mode\" Ta \"\" Ta \"1 if client is in control mode\"\n.It Li \"client_height\" Ta \"\" Ta \"Height of client\"\n.It Li \"client_key_table\" Ta \"\" Ta \"Current key table\"\n.It Li \"client_last_session\" Ta \"\" Ta \"Name of the client's last session\"\n.It Li \"client_pid\" Ta \"\" Ta \"PID of client process\"\n.It Li \"client_prefix\" Ta \"\" Ta \"1 if prefix key has been pressed\"\n.It Li \"client_readonly\" Ta \"\" Ta \"1 if client is readonly\"\n.It Li \"client_session\" Ta \"\" Ta \"Name of the client's session\"\n.It Li \"client_termname\" Ta \"\" Ta \"Terminal name of client\"\n.It Li \"client_tty\" Ta \"\" Ta \"Pseudo terminal of client\"\n.It Li \"client_utf8\" Ta \"\" Ta \"1 if client supports utf8\"\n.It Li \"client_width\" Ta \"\" Ta \"Width of client\"\n.It Li \"command_name\" Ta \"\" Ta \"Name of command in use, if any\"\n.It Li \"cursor_flag\" Ta \"\" Ta \"Pane cursor flag\"\n.It Li \"cursor_x\" Ta \"\" Ta \"Cursor X position in pane\"\n.It Li \"cursor_y\" Ta \"\" Ta \"Cursor Y position in pane\"\n.It Li \"history_bytes\" Ta \"\" Ta \"Number of bytes in window history\"\n.It Li \"history_limit\" Ta \"\" Ta \"Maximum window history lines\"\n.It Li \"history_size\" Ta \"\" Ta \"Size of history in bytes\"\n.It Li \"host\" Ta \"#H\" Ta \"Hostname of local host\"\n.It Li \"host_short\" Ta \"#h\" Ta \"Hostname of local host (no domain name)\"\n.It Li \"insert_flag\" Ta \"\" Ta \"Pane insert flag\"\n.It Li \"keypad_cursor_flag\" Ta \"\" Ta \"Pane keypad cursor flag\"\n.It Li \"keypad_flag\" Ta \"\" Ta \"Pane keypad flag\"\n.It Li \"line\" Ta \"\" Ta \"Line number in the list\"\n.It Li \"mouse_any_flag\" Ta \"\" Ta \"Pane mouse any flag\"\n.It Li \"mouse_button_flag\" Ta \"\" Ta \"Pane mouse button flag\"\n.It Li \"mouse_standard_flag\" Ta \"\" Ta \"Pane mouse standard flag\"\n.It Li \"pane_active\" Ta \"\" Ta \"1 if active pane\"\n.It Li \"pane_bottom\" Ta \"\" Ta \"Bottom of pane\"\n.It Li \"pane_current_command\" Ta \"\" Ta \"Current command if available\"\n.It Li \"pane_current_path\" Ta \"\" Ta \"Current path if available\"\n.It Li \"pane_dead\" Ta \"\" Ta \"1 if pane is dead\"\n.It Li \"pane_dead_status\" Ta \"\" Ta \"Exit status of process in dead pane\"\n.It Li \"pane_height\" Ta \"\" Ta \"Height of pane\"\n.It Li \"pane_id\" Ta \"#D\" Ta \"Unique pane ID\"\n.It Li \"pane_in_mode\" Ta \"\" Ta \"If pane is in a mode\"\n.It Li \"pane_input_off\" Ta \"\" Ta \"If input to pane is disabled\"\n.It Li \"pane_index\" Ta \"#P\" Ta \"Index of pane\"\n.It Li \"pane_left\" Ta \"\" Ta \"Left of pane\"\n.It Li \"pane_pid\" Ta \"\" Ta \"PID of first process in pane\"\n.It Li \"pane_right\" Ta \"\" Ta \"Right of pane\"\n.It Li \"pane_start_command\" Ta \"\" Ta \"Command pane started with\"\n.It Li \"pane_synchronized\" Ta \"\" Ta \"If pane is synchronized\"\n.It Li \"pane_tabs\" Ta \"\" Ta \"Pane tab positions\"\n.It Li \"pane_title\" Ta \"#T\" Ta \"Title of pane\"\n.It Li \"pane_top\" Ta \"\" Ta \"Top of pane\"\n.It Li \"pane_tty\" Ta \"\" Ta \"Pseudo terminal of pane\"\n.It Li \"pane_width\" Ta \"\" Ta \"Width of pane\"\n.It Li \"pid\" Ta \"\"  Ta \"Server PID\"\n.It Li \"scroll_region_lower\" Ta \"\" Ta \"Bottom of scroll region in pane\"\n.It Li \"scroll_region_upper\" Ta \"\" Ta \"Top of scroll region in pane\"\n.It Li \"scroll_position\" Ta \"\" Ta \"Scroll position in copy mode\"\n.It Li \"session_alerts\" Ta \"\" Ta \"List of window indexes with alerts\"\n.It Li \"session_attached\" Ta \"\" Ta \"Number of clients session is attached to\"\n.It Li \"session_activity\" Ta \"\" Ta \"Integer time of session last activity\"\n.It Li \"session_created\" Ta \"\" Ta \"Integer time session created\"\n.It Li \"session_last_attached\" Ta \"\" Ta \"Integer time session last attached\"\n.It Li \"session_group\" Ta \"\" Ta \"Number of session group\"\n.It Li \"session_grouped\" Ta \"\" Ta \"1 if session in a group\"\n.It Li \"session_height\" Ta \"\" Ta \"Height of session\"\n.It Li \"session_id\" Ta \"\" Ta \"Unique session ID\"\n.It Li \"session_many_attached\" Ta \"\" Ta \"1 if multiple clients attached\"\n.It Li \"session_name\" Ta \"#S\" Ta \"Name of session\"\n.It Li \"session_width\" Ta \"\" Ta \"Width of session\"\n.It Li \"session_windows\" Ta \"\" Ta \"Number of windows in session\"\n.It Li \"socket_path\" Ta \"\" \"Server socket path\"\n.It Li \"start_time\" Ta \"\" Ta \"Server start time\"\n.It Li \"window_activity\" Ta \"\" Ta \"Integer time of window last activity\"\n.It Li \"window_active\" Ta \"\" Ta \"1 if window active\"\n.It Li \"window_bell_flag\" Ta \"\" Ta \"1 if window has bell\"\n.It Li \"window_find_matches\" Ta \"\" Ta \"Matched data from the find-window\"\n.It Li \"window_flags\" Ta \"#F\" Ta \"Window flags\"\n.It Li \"window_height\" Ta \"\" Ta \"Height of window\"\n.It Li \"window_id\" Ta \"\" Ta \"Unique window ID\"\n.It Li \"window_index\" Ta \"#I\" Ta \"Index of window\"\n.It Li \"window_last_flag\" Ta \"\" Ta \"1 if window is the last used\"\n.It Li \"window_layout\" Ta \"\" Ta \"Window layout description, ignoring zoomed window panes\"\n.It Li \"window_linked\" Ta \"\" Ta \"1 if window is linked across sessions\"\n.It Li \"window_name\" Ta \"#W\" Ta \"Name of window\"\n.It Li \"window_panes\" Ta \"\" Ta \"Number of panes in window\"\n.It Li \"window_silence_flag\" Ta \"\" Ta \"1 if window has silence alert\"\n.It Li \"window_visible_layout\" Ta \"\" Ta \"Window layout description, respecting zoomed window panes\"\n.It Li \"window_width\" Ta \"\" Ta \"Width of window\"\n.It Li \"window_zoomed_flag\" Ta \"\" Ta \"1 if window is zoomed\"\n.It Li \"wrap_flag\" Ta \"\" Ta \"Pane wrap flag\"\n.El\n.Sh NAMES AND TITLES\n.Nm\ndistinguishes between names and titles.\nWindows and sessions have names, which may be used to specify them in targets\nand are displayed in the status line and various lists: the name is the\n.Nm\nidentifier for a window or session.\nOnly panes have titles.\nA pane's title is typically set by the program running inside the pane and\nis not modified by\n.Nm .\nIt is the same mechanism used to set for example the\n.Xr xterm 1\nwindow title in an\n.Xr X 7\nwindow manager.\nWindows themselves do not have titles - a window's title is the title of its\nactive pane.\n.Nm\nitself may set the title of the terminal in which the client is running, see\nthe\n.Ic set-titles\noption.\n.Pp\nA session's name is set with the\n.Ic new-session\nand\n.Ic rename-session\ncommands.\nA window's name is set with one of:\n.Bl -enum -width Ds\n.It\nA command argument (such as\n.Fl n\nfor\n.Ic new-window\nor\n.Ic new-session ) .\n.It\nAn escape sequence:\n.Bd -literal -offset indent\n$ printf '\\e033kWINDOW_NAME\\e033\\e\\e'\n.Ed\n.It\nAutomatic renaming, which sets the name to the active command in the window's\nactive pane.\nSee the\n.Ic automatic-rename\noption.\n.El\n.Pp\nWhen a pane is first created, its title is the hostname.\nA pane's title can be set via the OSC title setting sequence, for example:\n.Bd -literal -offset indent\n$ printf '\\e033]2;My Title\\e033\\e\\e'\n.Ed\n.Sh ENVIRONMENT\nWhen the server is started,\n.Nm\ncopies the environment into the\n.Em global environment ;\nin addition, each session has a\n.Em session environment .\nWhen a window is created, the session and global environments are merged.\nIf a variable exists in both, the value from the session environment is used.\nThe result is the initial environment passed to the new process.\n.Pp\nThe\n.Ic update-environment\nsession option may be used to update the session environment from the client\nwhen a new session is created or an old reattached.\n.Nm\nalso initialises the\n.Ev TMUX\nvariable with some internal information to allow commands to be executed\nfrom inside, and the\n.Ev TERM\nvariable with the correct terminal setting of\n.Ql screen .\n.Pp\nCommands to alter and view the environment are:\n.Bl -tag -width Ds\n.It Xo Ic set-environment\n.Op Fl gru\n.Op Fl t Ar target-session\n.Ar name Op Ar value\n.Xc\n.D1 (alias: Ic setenv )\nSet or unset an environment variable.\nIf\n.Fl g\nis used, the change is made in the global environment; otherwise, it is applied\nto the session environment for\n.Ar target-session .\nThe\n.Fl u\nflag unsets a variable.\n.Fl r\nindicates the variable is to be removed from the environment before starting a\nnew process.\n.It Xo Ic show-environment\n.Op Fl gs\n.Op Fl t Ar target-session\n.Op Ar variable\n.Xc\n.D1 (alias: Ic showenv )\nDisplay the environment for\n.Ar target-session\nor the global environment with\n.Fl g .\nIf\n.Ar variable\nis omitted, all variables are shown.\nVariables removed from the environment are prefixed with\n.Ql - .\nIf\n.Fl s\nis used, the output is formatted as a set of Bourne shell commands.\n.El\n.Sh STATUS LINE\n.Nm\nincludes an optional status line which is displayed in the bottom line of each\nterminal.\nBy default, the status line is enabled (it may be disabled with the\n.Ic status\nsession option) and contains, from left-to-right: the name of the current\nsession in square brackets; the window list; the title of the active pane\nin double quotes; and the time and date.\n.Pp\nThe status line is made of three parts: configurable left and right sections\n(which may contain dynamic content such as the time or output from a shell\ncommand, see the\n.Ic status-left ,\n.Ic status-left-length ,\n.Ic status-right ,\nand\n.Ic status-right-length\noptions below), and a central window list.\nBy default, the window list shows the index, name and (if any) flag of the\nwindows present in the current session in ascending numerical order.\nIt may be customised with the\n.Ar window-status-format\nand\n.Ar window-status-current-format\noptions.\nThe flag is one of the following symbols appended to the window name:\n.Bl -column \"Symbol\" \"Meaning\" -offset indent\n.It Sy \"Symbol\" Ta Sy \"Meaning\"\n.It Li \"*\" Ta \"Denotes the current window.\"\n.It Li \"-\" Ta \"Marks the last window (previously selected).\"\n.It Li \"#\" Ta \"Window is monitored and activity has been detected.\"\n.It Li \"!\" Ta \"A bell has occurred in the window.\"\n.It Li \"~\" Ta \"The window has been silent for the monitor-silence interval.\"\n.It Li \"M\" Ta \"The window contains the marked pane.\"\n.It Li \"Z\" Ta \"The window's active pane is zoomed.\"\n.El\n.Pp\nThe # symbol relates to the\n.Ic monitor-activity\nwindow option.\nThe window name is printed in inverted colours if an alert (bell, activity or\nsilence) is present.\n.Pp\nThe colour and attributes of the status line may be configured, the entire\nstatus line using the\n.Ic status-style\nsession option and individual windows using the\n.Ic window-status-style\nwindow option.\n.Pp\nThe status line is automatically refreshed at interval if it has changed, the\ninterval may be controlled with the\n.Ic status-interval\nsession option.\n.Pp\nCommands related to the status line are as follows:\n.Bl -tag -width Ds\n.It Xo Ic command-prompt\n.Op Fl I Ar inputs\n.Op Fl p Ar prompts\n.Op Fl t Ar target-client\n.Op Ar template\n.Xc\nOpen the command prompt in a client.\nThis may be used from inside\n.Nm\nto execute commands interactively.\n.Pp\nIf\n.Ar template\nis specified, it is used as the command.\nIf present,\n.Fl I\nis a comma-separated list of the initial text for each prompt.\nIf\n.Fl p\nis given,\n.Ar prompts\nis a comma-separated list of prompts which are displayed in order; otherwise\na single prompt is displayed, constructed from\n.Ar template\nif it is present, or\n.Ql \\&:\nif not.\n.Pp\nBoth\n.Ar inputs\nand\n.Ar prompts\nmay contain the special character sequences supported by the\n.Ic status-left\noption.\n.Pp\nBefore the command is executed, the first occurrence of the string\n.Ql %%\nand all occurrences of\n.Ql %1\nare replaced by the response to the first prompt, the second\n.Ql %%\nand all\n.Ql %2\nare replaced with the response to the second prompt, and so on for further\nprompts.\nUp to nine prompt responses may be replaced\n.Po\n.Ql %1\nto\n.Ql %9\n.Pc .\n.It Xo Ic confirm-before\n.Op Fl p Ar prompt\n.Op Fl t Ar target-client\n.Ar command\n.Xc\n.D1 (alias: Ic confirm )\nAsk for confirmation before executing\n.Ar command .\nIf\n.Fl p\nis given,\n.Ar prompt\nis the prompt to display; otherwise a prompt is constructed from\n.Ar command .\nIt may contain the special character sequences supported by the\n.Ic status-left\noption.\n.Pp\nThis command works only from inside\n.Nm .\n.It Xo Ic display-message\n.Op Fl p\n.Op Fl c Ar target-client\n.Op Fl t Ar target-pane\n.Op Ar message\n.Xc\n.D1 (alias: Ic display )\nDisplay a message.\nIf\n.Fl p\nis given, the output is printed to stdout, otherwise it is displayed in the\n.Ar target-client\nstatus line.\nThe format of\n.Ar message\nis described in the\n.Sx FORMATS\nsection; information is taken from\n.Ar target-pane\nif\n.Fl t\nis given, otherwise the active pane for the session attached to\n.Ar target-client .\n.El\n.Sh BUFFERS\n.Nm\nmaintains a set of named\n.Em paste buffers .\nEach buffer may be either explicitly or automatically named.\nExplicitly named buffers are named when created with the\n.Ic set-buffer\nor\n.Ic load-buffer\ncommands, or by renaming an automatically named buffer with\n.Ic set-buffer\n.Fl n .\nAutomatically named buffers are given a name such as\n.Ql buffer0001 ,\n.Ql buffer0002\nand so on.\nWhen the\n.Ic buffer-limit\noption is reached, the oldest automatically named buffer is deleted.\nExplicitly named are not subject to\n.Ic buffer-limit\nand may be deleted with\n.Ic delete-buffer\ncommand.\n.Pp\nBuffers may be added using\n.Ic copy-mode\nor the\n.Ic set-buffer\nand\n.Ic load-buffer\ncommands, and pasted into a window using the\n.Ic paste-buffer\ncommand.\nIf a buffer command is used and no buffer is specified, the most\nrecently added automatically named buffer is assumed.\n.Pp\nA configurable history buffer is also maintained for each window.\nBy default, up to 2000 lines are kept; this can be altered with the\n.Ic history-limit\noption (see the\n.Ic set-option\ncommand above).\n.Pp\nThe buffer commands are as follows:\n.Bl -tag -width Ds\n.It Xo\n.Ic choose-buffer\n.Op Fl F Ar format\n.Op Fl t Ar target-window\n.Op Ar template\n.Xc\nPut a window into buffer choice mode, where a buffer may be chosen\ninteractively from a list.\nAfter a buffer is selected,\n.Ql %%\nis replaced by the buffer name in\n.Ar template\nand the result executed as a command.\nIf\n.Ar template\nis not given, \"paste-buffer -b '%%'\" is used.\nFor the meaning of the\n.Fl F\nflag, see the\n.Sx FORMATS\nsection.\nThis command works only if at least one client is attached.\n.It Ic clear-history Op Fl t Ar target-pane\n.D1 (alias: Ic clearhist )\nRemove and free the history for the specified pane.\n.It Ic delete-buffer Op Fl b Ar buffer-name\n.D1 (alias: Ic deleteb )\nDelete the buffer named\n.Ar buffer-name ,\nor the most recently added automatically named buffer if not specified.\n.It Xo Ic list-buffers\n.Op Fl F Ar format\n.Xc\n.D1 (alias: Ic lsb )\nList the global buffers.\nFor the meaning of the\n.Fl F\nflag, see the\n.Sx FORMATS\nsection.\n.It Xo Ic load-buffer\n.Op Fl b Ar buffer-name\n.Ar path\n.Xc\n.D1 (alias: Ic loadb )\nLoad the contents of the specified paste buffer from\n.Ar path .\n.It Xo Ic paste-buffer\n.Op Fl dpr\n.Op Fl b Ar buffer-name\n.Op Fl s Ar separator\n.Op Fl t Ar target-pane\n.Xc\n.D1 (alias: Ic pasteb )\nInsert the contents of a paste buffer into the specified pane.\nIf not specified, paste into the current one.\nWith\n.Fl d ,\nalso delete the paste buffer.\nWhen output, any linefeed (LF) characters in the paste buffer are replaced with\na separator, by default carriage return (CR).\nA custom separator may be specified using the\n.Fl s\nflag.\nThe\n.Fl r\nflag means to do no replacement (equivalent to a separator of LF).\nIf\n.Fl p\nis specified, paste bracket control codes are inserted around the\nbuffer if the application has requested bracketed paste mode.\n.It Xo Ic save-buffer\n.Op Fl a\n.Op Fl b Ar buffer-name\n.Ar path\n.Xc\n.D1 (alias: Ic saveb )\nSave the contents of the specified paste buffer to\n.Ar path .\nThe\n.Fl a\noption appends to rather than overwriting the file.\n.It Xo Ic set-buffer\n.Op Fl a\n.Op Fl b Ar buffer-name\n.Op Fl n Ar new-buffer-name\n.Ar data\n.Xc\n.D1 (alias: Ic setb )\nSet the contents of the specified buffer to\n.Ar data .\nThe\n.Fl a\noption appends to rather than overwriting the buffer.\nThe\n.Fl n\noption renames the buffer to\n.Ar new-buffer-name .\n.It Xo Ic show-buffer\n.Op Fl b Ar buffer-name\n.Xc\n.D1 (alias: Ic showb )\nDisplay the contents of the specified buffer.\n.El\n.Sh MISCELLANEOUS\nMiscellaneous commands are as follows:\n.Bl -tag -width Ds\n.It Ic clock-mode Op Fl t Ar target-pane\nDisplay a large clock.\n.It Xo Ic if-shell\n.Op Fl bF\n.Op Fl t Ar target-pane\n.Ar shell-command command\n.Op Ar command\n.Xc\n.D1 (alias: Ic if )\nExecute the first\n.Ar command\nif\n.Ar shell-command\nreturns success or the second\n.Ar command\notherwise.\nBefore being executed,\n.Ar shell-command\nis expanded using the rules specified in the\n.Sx FORMATS\nsection, including those relevant to\n.Ar target-pane .\nWith\n.Fl b ,\n.Ar shell-command\nis run in the background.\n.Pp\nIf\n.Fl F\nis given,\n.Ar shell-command\nis not executed but considered success if neither empty nor zero (after formats\nare expanded).\n.It Ic lock-server\n.D1 (alias: Ic lock )\nLock each client individually by running the command specified by the\n.Ic lock-command\noption.\n.It Xo Ic run-shell\n.Op Fl b\n.Op Fl t Ar target-pane\n.Ar shell-command\n.Xc\n.D1 (alias: Ic run )\nExecute\n.Ar shell-command\nin the background without creating a window.\nBefore being executed, shell-command is expanded using the rules specified in\nthe\n.Sx FORMATS\nsection.\nWith\n.Fl b ,\nthe command is run in the background.\nAfter it finishes, any output to stdout is displayed in copy mode (in the pane\nspecified by\n.Fl t\nor the current pane if omitted).\nIf the command doesn't return success, the exit status is also displayed.\n.It Xo Ic wait-for\n.Op Fl L | S | U\n.Ar channel\n.Xc\n.D1 (alias: Ic wait )\nWhen used without options, prevents the client from exiting until woken using\n.Ic wait-for\n.Fl S\nwith the same channel.\nWhen\n.Fl L\nis used, the channel is locked and any clients that try to lock the same\nchannel are made to wait until the channel is unlocked with\n.Ic wait-for\n.Fl U .\nThis command only works from outside\n.Nm .\n.El\n.Sh TERMINFO EXTENSIONS\n.Nm\nunderstands some unofficial extensions to\n.Xr terminfo 5 :\n.Bl -tag -width Ds\n.It Em Cs , Cr\nSet the cursor colour.\nThe first takes a single string argument and is used to set the colour;\nthe second takes no arguments and restores the default cursor colour.\nIf set, a sequence such as this may be used\nto change the cursor colour from inside\n.Nm :\n.Bd -literal -offset indent\n$ printf '\\e033]12;red\\e033\\e\\e'\n.Ed\n.It Em \\&Ss , Se\nSet or reset the cursor style.\nIf set, a sequence such as this may be used\nto change the cursor to an underline:\n.Bd -literal -offset indent\n$ printf '\\e033[4 q'\n.Ed\n.Pp\nIf\n.Em Se\nis not set, \\&Ss with argument 0 will be used to reset the cursor style instead.\n.It Em \\&Tc\nIndicate that the terminal supports the\n.Ql direct colour\nRGB escape sequence (for example, \\ee[38;2;255;255;255m).\n.It Em \\&Ms\nStore the current buffer in the host terminal's selection (clipboard).\nSee the\n.Em set-clipboard\noption above and the\n.Xr xterm 1\nman page.\n.El\n.Sh CONTROL MODE\n.Nm\noffers a textual interface called\n.Em control mode .\nThis allows applications to communicate with\n.Nm\nusing a simple text-only protocol.\n.Pp\nIn control mode, a client sends\n.Nm\ncommands or command sequences terminated by newlines on standard input.\nEach command will produce one block of output on standard output.\nAn output block consists of a\n.Em %begin\nline followed by the output (which may be empty).\nThe output block ends with a\n.Em %end\nor\n.Em %error .\n.Em %begin\nand matching\n.Em %end\nor\n.Em %error\nhave two arguments: an integer time (as seconds from epoch) and command number.\nFor example:\n.Bd -literal -offset indent\n%begin 1363006971 2\n0: ksh* (1 panes) [80x24] [layout b25f,80x24,0,0,2] @2 (active)\n%end 1363006971 2\n.Ed\n.Pp\nIn control mode,\n.Nm\noutputs notifications.\nA notification will never occur inside an output block.\n.Pp\nThe following notifications are defined:\n.Bl -tag -width Ds\n.It Ic %exit Op Ar reason\nThe\n.Nm\nclient is exiting immediately, either because it is not attached to any session\nor an error occurred.\nIf present,\n.Ar reason\ndescribes why the client exited.\n.It Ic %layout-change Ar window-id Ar window-layout Ar window-visible-layout Ar window-flags\nThe layout of a window with ID\n.Ar window-id\nchanged.\nThe new layout is\n.Ar window-layout .\nThe window's visible layout is\n.Ar window-visible-layout\nand the window flags are\n.Ar window-flags .\n.It Ic %output Ar pane-id Ar value\nA window pane produced output.\n.Ar value\nescapes non-printable characters and backslash as octal \\\\xxx.\n.It Ic %session-changed Ar session-id Ar name\nThe client is now attached to the session with ID\n.Ar session-id ,\nwhich is named\n.Ar name .\n.It Ic %session-renamed Ar name\nThe current session was renamed to\n.Ar name .\n.It Ic %sessions-changed\nA session was created or destroyed.\n.It Ic %unlinked-window-add Ar window-id\nThe window with ID\n.Ar window-id\nwas created but is not linked to the current session.\n.It Ic %window-add Ar window-id\nThe window with ID\n.Ar window-id\nwas linked to the current session.\n.It Ic %window-close Ar window-id\nThe window with ID\n.Ar window-id\nclosed.\n.It Ic %window-renamed Ar window-id Ar name\nThe window with ID\n.Ar window-id\nwas renamed to\n.Ar name .\n.El\n.Sh FILES\n.Bl -tag -width \"@SYSCONFDIR@/tmux.confXXX\" -compact\n.It Pa ~/.tmux.conf\nDefault\n.Nm\nconfiguration file.\n.It Pa @SYSCONFDIR@/tmux.conf\nSystem-wide configuration file.\n.El\n.Sh EXAMPLES\nTo create a new\n.Nm\nsession running\n.Xr vi 1 :\n.Pp\n.Dl $ tmate new-session vi\n.Pp\nMost commands have a shorter form, known as an alias.\nFor new-session, this is\n.Ic new :\n.Pp\n.Dl $ tmate new vi\n.Pp\nAlternatively, the shortest unambiguous form of a command is accepted.\nIf there are several options, they are listed:\n.Bd -literal -offset indent\n$ tmate n\nambiguous command: n, could be: new-session, new-window, next-window\n.Ed\n.Pp\nWithin an active session, a new window may be created by typing\n.Ql C-b c\n(Ctrl\nfollowed by the\n.Ql b\nkey\nfollowed by the\n.Ql c\nkey).\n.Pp\nWindows may be navigated with:\n.Ql C-b 0\n(to select window 0),\n.Ql C-b 1\n(to select window 1), and so on;\n.Ql C-b n\nto select the next window; and\n.Ql C-b p\nto select the previous window.\n.Pp\nA session may be detached using\n.Ql C-b d\n(or by an external event such as\n.Xr ssh 1\ndisconnection) and reattached with:\n.Pp\n.Dl $ tmate attach-session\n.Pp\nTyping\n.Ql C-b \\&?\nlists the current key bindings in the current window; up and down may be used\nto navigate the list or\n.Ql q\nto exit from it.\n.Pp\nCommands to be run when the\n.Nm\nserver is started may be placed in the\n.Pa ~/.tmux.conf\nconfiguration file.\nCommon examples include:\n.Pp\nChanging the default prefix key:\n.Bd -literal -offset indent\nset-option -g prefix C-a\nunbind-key C-b\nbind-key C-a send-prefix\n.Ed\n.Pp\nTurning the status line off, or changing its colour:\n.Bd -literal -offset indent\nset-option -g status off\nset-option -g status-style bg=blue\n.Ed\n.Pp\nSetting other options, such as the default command,\nor locking after 30 minutes of inactivity:\n.Bd -literal -offset indent\nset-option -g default-command \"exec /bin/ksh\"\nset-option -g lock-after-time 1800\n.Ed\n.Pp\nCreating new key bindings:\n.Bd -literal -offset indent\nbind-key b set-option status\nbind-key / command-prompt \"split-window 'exec man %%'\"\nbind-key S command-prompt \"new-window -n %1 'ssh %1'\"\n.Ed\n.Sh SEE ALSO\n.Xr pty 4\n.Sh AUTHORS\n.An Nicholas Marriott Aq Mt nicholas.marriott@gmail.com\n"
        },
        {
          "name": "tmux.c",
          "type": "blob",
          "size": 9.306640625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/stat.h>\n\n#include <err.h>\n#include <errno.h>\n#include <event.h>\n#include <fcntl.h>\n#include <getopt.h>\n#include <langinfo.h>\n#include <locale.h>\n#include <pwd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n#include \"tmate.h\"\n\nstruct options\t*global_options;\t/* server options */\nstruct options\t*global_s_options;\t/* session options */\nstruct options\t*global_w_options;\t/* window options */\nstruct environ\t*global_environ;\nstruct hooks\t*global_hooks;\n\nstruct timeval\t start_time;\nconst char\t*socket_path;\n\n__dead void\t usage(void);\nstatic char\t*make_label(const char *);\n\n#ifndef HAVE___PROGNAME\nchar      *__progname = (char *) \"tmate\";\n#endif\n\n#ifdef TMATE\nint tmate_foreground;\n#endif\n\n__dead void\nusage(void)\n{\n\tfprintf(stderr,\n\t    \"Usage: %s [options] [tmux-command [flags]]\\n\"\n\t    \"\\n\"\n\t    \"Basic options:\\n\"\n\t    \" -n <name>    specify the session token instead of getting a random one\\n\"\n\t    \" -r <name>    same, but for the read-only token\\n\"\n\t    \" -k <key>     specify an api-key, necessary for using named sessions on tmate.io\\n\"\n\t    \" -F           set the foreground mode, useful for setting remote access\\n\"\n\t    \" -f <path>    set the config file path\\n\"\n\t    \" -S <path>    set the socket path, useful to issue commands to a running tmate instance\\n\"\n\t    \" -a <path>    limit access to ssh public keys listed in provided file\\n\"\n\t    \" -v           set verbosity (can be repeated)\\n\"\n\t    \" -V           print version\\n\"\n\t    ,__progname);\n\texit(1);\n}\n\nconst char *\ngetshell(void)\n{\n\tstruct passwd\t*pw;\n\tconst char\t*shell;\n\n\tshell = getenv(\"SHELL\");\n\tif (checkshell(shell))\n\t\treturn (shell);\n\n\tpw = getpwuid(getuid());\n\tif (pw != NULL && checkshell(pw->pw_shell))\n\t\treturn (pw->pw_shell);\n\n\treturn (_PATH_BSHELL);\n}\n\nint\ncheckshell(const char *shell)\n{\n\tif (shell == NULL || *shell == '\\0' || *shell != '/')\n\t\treturn (0);\n\tif (areshell(shell))\n\t\treturn (0);\n\tif (access(shell, X_OK) != 0)\n\t\treturn (0);\n\treturn (1);\n}\n\nint\nareshell(const char *shell)\n{\n\tconst char\t*progname, *ptr;\n\n\tif ((ptr = strrchr(shell, '/')) != NULL)\n\t\tptr++;\n\telse\n\t\tptr = shell;\n\tprogname = __progname;\n\tif (*progname == '-')\n\t\tprogname++;\n\tif (strcmp(ptr, progname) == 0)\n\t\treturn (1);\n\treturn (0);\n}\n\nstatic char *\nmake_label(const char *label)\n{\n\tchar\t\t*base, resolved[PATH_MAX], *path, *s;\n\tstruct stat\t sb;\n\tu_int\t\t uid;\n\tint\t\t saved_errno;\n#ifdef TMATE\n\tint do_random_label = label == NULL;\n#endif\n\n\tif (label == NULL)\n\t\tlabel = \"default\";\n\n\tuid = getuid();\n\n\tif ((s = getenv(\"TMUX_TMPDIR\")) != NULL && *s != '\\0')\n\t\txasprintf(&base, \"%s/tmate-%u\", s, uid);\n\telse\n\t\txasprintf(&base, \"%s/tmate-%u\", _PATH_TMP, uid);\n\n\tif (mkdir(base, S_IRWXU) != 0 && errno != EEXIST)\n\t\tgoto fail;\n\n\tif (lstat(base, &sb) != 0)\n\t\tgoto fail;\n\tif (!S_ISDIR(sb.st_mode)) {\n\t\terrno = ENOTDIR;\n\t\tgoto fail;\n\t}\n\tif (sb.st_uid != uid || (sb.st_mode & S_IRWXO) != 0) {\n\t\terrno = EACCES;\n\t\tgoto fail;\n\t}\n\n#ifdef TMATE\n\tif (do_random_label)\n\t\tlabel = \"XXXXXX\";\n#endif\n\n\tif (realpath(base, resolved) == NULL)\n\t\tstrlcpy(resolved, base, sizeof resolved);\n\txasprintf(&path, \"%s/%s\", resolved, label);\n#ifdef TMATE\n\tif (do_random_label)\n\t\tmktemp(path);\n#endif\n\treturn (path);\n\nfail:\n\tsaved_errno = errno;\n\tfree(base);\n\terrno = saved_errno;\n\treturn (NULL);\n}\n\nvoid\nsetblocking(int fd, int state)\n{\n\tint mode;\n\n\tif ((mode = fcntl(fd, F_GETFL)) != -1) {\n\t\tif (!state)\n\t\t\tmode |= O_NONBLOCK;\n\t\telse\n\t\t\tmode &= ~O_NONBLOCK;\n\t\tfcntl(fd, F_SETFL, mode);\n\t}\n}\n\nconst char *\nfind_home(void)\n{\n\tstruct passwd\t\t*pw;\n\tstatic const char\t*home;\n\n\tif (home != NULL)\n\t\treturn (home);\n\n\thome = getenv(\"HOME\");\n\tif (home == NULL || *home == '\\0') {\n\t\tpw = getpwuid(getuid());\n\t\tif (pw != NULL)\n\t\t\thome = pw->pw_dir;\n\t\telse\n\t\t\thome = NULL;\n\t}\n\n\treturn (home);\n}\n\n#ifdef TMATE\nstatic char *api_key;\nstatic char *session_name;\nstatic char *session_name_ro;\nstatic char *authorized_keys;\n\nvoid tmate_load_cli_options(void)\n{\n#define SET_OPT(name, val) ({\\\n\tif (val) { \\\n\t\trun_headless_command(3, (const char *[]){\"set-option\", name, val}, DEFER_ERRORS_CFG, NULL); \\\n\t\tfree(val); \\\n\t\tval = NULL; \\\n\t} \\\n})\n\tSET_OPT(\"tmate-api-key\",         api_key);\n\tSET_OPT(\"tmate-session-name\",    session_name);\n\tSET_OPT(\"tmate-session-name-ro\", session_name_ro);\n\tSET_OPT(\"tmate-authorized-keys\", authorized_keys);\n#undef SET_OPT\n}\n#endif\n\nint\nmain(int argc, char **argv)\n{\n\tchar\t\t*path, *label, **var, tmp[PATH_MAX], *shellcmd = NULL;\n\tconst char\t*s;\n\tint\t\t opt, flags, keys;\n\n\tif (setlocale(LC_CTYPE, \"en_US.UTF-8\") == NULL &&\n\t    setlocale(LC_CTYPE, \"C.UTF-8\") == NULL) {\n\t\tif (setlocale(LC_CTYPE, \"\") == NULL)\n\t\t\terrx(1, \"invalid LC_ALL, LC_CTYPE or LANG\");\n\t\ts = nl_langinfo(CODESET);\n\t\tif (strcasecmp(s, \"UTF-8\") != 0 && strcasecmp(s, \"UTF8\") != 0)\n\t\t\terrx(1, \"need UTF-8 locale (LC_CTYPE) but have %s\", s);\n\t}\n\n\tsetlocale(LC_TIME, \"\");\n\ttzset();\n\n\tif (**argv == '-')\n\t\tflags = CLIENT_LOGIN;\n\telse\n\t\tflags = 0;\n\n#ifdef TMATE\n\ttmate_catch_sigsegv();\n\tflags |= CLIENT_256COLOURS | CLIENT_UTF8;\n#endif\n\n\tlabel = path = NULL;\n\twhile ((opt = getopt(argc, argv, \"h2c:CdFf:lL:qS:uUVvk:n:r:a:\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase '2':\n\t\t\tflags |= CLIENT_256COLOURS;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tfree(shellcmd);\n\t\t\tshellcmd = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tif (flags & CLIENT_CONTROL)\n\t\t\t\tflags |= CLIENT_CONTROLCONTROL;\n\t\t\telse\n\t\t\t\tflags |= CLIENT_CONTROL;\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tprintf(\"%s %s\\n\", __progname, VERSION);\n\t\t\texit(0);\n\t\tcase 'f':\n\t\t\tset_cfg_file(optarg);\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tflags |= CLIENT_LOGIN;\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\tfree(label);\n\t\t\tlabel = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tfree(path);\n\t\t\tpath = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tflags |= CLIENT_UTF8;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tlog_add_level();\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\ttmate_foreground = 1;\n\t\t\tlog_add_level();\n\t\t\tunsetenv(\"TMUX\");\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tapi_key = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tsession_name = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tsession_name_ro = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\tauthorized_keys = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\tdefault:\n\t\t\tusage();\n\t\t}\n\t}\n\targc -= optind;\n\targv += optind;\n\n\tif (shellcmd != NULL && argc != 0)\n\t\tusage();\n\n#ifdef __OpenBSD__\n\tif (pledge(\"stdio rpath wpath cpath flock fattr unix getpw sendfd \"\n\t    \"recvfd proc exec tty ps\", NULL) != 0)\n\t\terr(1, \"pledge\");\n#endif\n\n\t/*\n\t * tmux is a UTF-8 terminal, so if TMUX is set, assume UTF-8.\n\t * Otherwise, if the user has set LC_ALL, LC_CTYPE or LANG to contain\n\t * UTF-8, it is a safe assumption that either they are using a UTF-8\n\t * terminal, or if not they know that output from UTF-8-capable\n\t * programs may be wrong.\n\t */\n\tif (getenv(\"TMUX\") != NULL)\n\t\tflags |= CLIENT_UTF8;\n\telse {\n\t\ts = getenv(\"LC_ALL\");\n\t\tif (s == NULL || *s == '\\0')\n\t\t\ts = getenv(\"LC_CTYPE\");\n\t\tif (s == NULL || *s == '\\0')\n\t\t\ts = getenv(\"LANG\");\n\t\tif (s == NULL || *s == '\\0')\n\t\t\ts = \"\";\n\t\tif (strcasestr(s, \"UTF-8\") != NULL ||\n\t\t    strcasestr(s, \"UTF8\") != NULL)\n\t\t\tflags |= CLIENT_UTF8;\n\t}\n\n\tglobal_hooks = hooks_create(NULL);\n\n\tglobal_environ = environ_create();\n\tfor (var = environ; *var != NULL; var++)\n\t\tenviron_put(global_environ, *var);\n\tif (getcwd(tmp, sizeof tmp) != NULL)\n\t\tenviron_set(global_environ, \"PWD\", \"%s\", tmp);\n\n\tglobal_options = options_create(NULL);\n\toptions_table_populate_tree(OPTIONS_TABLE_SERVER, global_options);\n\n\tglobal_s_options = options_create(NULL);\n\toptions_table_populate_tree(OPTIONS_TABLE_SESSION, global_s_options);\n\toptions_set_string(global_s_options, \"default-shell\", \"%s\", getshell());\n\n\tglobal_w_options = options_create(NULL);\n\toptions_table_populate_tree(OPTIONS_TABLE_WINDOW, global_w_options);\n\n\t/* Override keys to vi if VISUAL or EDITOR are set. */\n\tif ((s = getenv(\"VISUAL\")) != NULL || (s = getenv(\"EDITOR\")) != NULL) {\n\t\tif (strrchr(s, '/') != NULL)\n\t\t\ts = strrchr(s, '/') + 1;\n\t\tif (strstr(s, \"vi\") != NULL)\n\t\t\tkeys = MODEKEY_VI;\n\t\telse\n\t\t\tkeys = MODEKEY_EMACS;\n\t\toptions_set_number(global_s_options, \"status-keys\", keys);\n\t\toptions_set_number(global_w_options, \"mode-keys\", keys);\n\t}\n\n\t/*\n\t * If socket is specified on the command-line with -S or -L, it is\n\t * used. Otherwise, $TMUX is checked and if that fails \"default\" is\n\t * used.\n\t */\n\tif (path == NULL && label == NULL) {\n\t\ts = getenv(\"TMUX\");\n\t\tif (s != NULL && *s != '\\0' && *s != ',') {\n\t\t\tpath = xstrdup(s);\n\t\t\tpath[strcspn (path, \",\")] = '\\0';\n\t\t}\n\t}\n\tif (path == NULL && (path = make_label(label)) == NULL) {\n\t\tfprintf(stderr, \"can't create socket: %s\\n\", strerror(errno));\n\t\texit(1);\n\t}\n\tsocket_path = path;\n\tfree(label);\n\n\t/* Pass control to the client. */\n\texit(client_main(event_init(), argc, argv, flags, shellcmd));\n}\n"
        },
        {
          "name": "tmux.h",
          "type": "blob",
          "size": 66.888671875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#ifndef TMUX_H\n#define TMUX_H\n\n#define TMATE\n\n#define PROTOCOL_VERSION 8\n\n#include <sys/time.h>\n#include <sys/uio.h>\n\n#include <event.h>\n#include <limits.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <termios.h>\n#include <wchar.h>\n\n#ifdef HAVE_UTEMPTER\n#include <utempter.h>\n#endif\n\n#include \"compat.h\"\n#include \"xmalloc.h\"\n\nextern char    *__progname;\nextern char   **environ;\n\nstruct client;\nstruct environ;\nstruct input_ctx;\nstruct mouse_event;\nstruct options;\nstruct session;\nstruct tmuxpeer;\nstruct tmuxproc;\n\n/* Default global configuration file. */\n#ifndef TMUX_CONF\n#define TMUX_CONF \"/etc/tmux.conf\"\n#endif\n\n/*\n * Minimum layout cell size, NOT including separator line. The scroll region\n * cannot be one line in height so this must be at least two.\n */\n#define PANE_MINIMUM 2\n\n/* Automatic name refresh interval, in microseconds. Must be < 1 second. */\n#define NAME_INTERVAL 500000\n\n/*\n * READ_SIZE is the maximum size of data to hold from a pty (the event high\n * watermark). READ_BACKOFF is the amount of data waiting to be output to a tty\n * before pty reads will be backed off. READ_TIME is how long to back off\n * before the next read (in microseconds) if a tty is above READ_BACKOFF.\n */\n#define READ_SIZE 1024\n#define READ_BACKOFF 512\n#define READ_TIME 100\n\n/* Attribute to make gcc check printf-like arguments. */\n#define printflike(a, b) __attribute__ ((format (printf, a, b)))\n\n/* Number of items in array. */\n#ifndef nitems\n#define nitems(_a) (sizeof((_a)) / sizeof((_a)[0]))\n#endif\n\n/* Bell option values. */\n#define BELL_NONE 0\n#define BELL_ANY 1\n#define BELL_CURRENT 2\n#define BELL_OTHER 3\n\n/* Special key codes. */\n#define KEYC_NONE 0xffff00000000ULL\n#define KEYC_UNKNOWN 0xfffe00000000ULL\n#define KEYC_BASE 0x100000000000ULL\n\n/* Key modifier bits. */\n#define KEYC_ESCAPE 0x200000000000ULL\n#define KEYC_CTRL   0x400000000000ULL\n#define KEYC_SHIFT  0x800000000000ULL\n\n/* Mask to obtain key w/o modifiers. */\n#define KEYC_MASK_MOD (KEYC_ESCAPE|KEYC_CTRL|KEYC_SHIFT)\n#define KEYC_MASK_KEY (~KEYC_MASK_MOD)\n\n/* Is this a mouse key? */\n#define KEYC_IS_MOUSE(key) (((key) & KEYC_MASK_KEY) >= KEYC_MOUSE &&\t\\\n    ((key) & KEYC_MASK_KEY) < KEYC_BSPACE)\n\n/* Mouse key codes. */\n#define KEYC_MOUSE_KEY(name)\t\t\t\t\\\n\tKEYC_ ## name ## _PANE,\t\t\t\t\\\n\tKEYC_ ## name ## _STATUS,\t\t\t\\\n\tKEYC_ ## name ## _BORDER\n#define KEYC_MOUSE_STRING(name, s)\t\t\t\\\n\t{ #s \"Pane\", KEYC_ ## name ## _PANE },\t\t\\\n\t{ #s \"Status\", KEYC_ ## name ## _STATUS },\t\\\n\t{ #s \"Border\", KEYC_ ## name ## _BORDER }\n\n/*\n * A single key. This can be ASCII or Unicode or one of the keys starting at\n * KEYC_BASE.\n */\ntypedef unsigned long long key_code;\n\n/* Special key codes. */\nenum {\n\t/* Focus events. */\n\tKEYC_FOCUS_IN = KEYC_BASE,\n\tKEYC_FOCUS_OUT,\n\n\t/* Mouse keys. */\n\tKEYC_MOUSE, /* unclassified mouse event */\n\tKEYC_MOUSE_KEY(MOUSEDOWN1),\n\tKEYC_MOUSE_KEY(MOUSEDOWN2),\n\tKEYC_MOUSE_KEY(MOUSEDOWN3),\n\tKEYC_MOUSE_KEY(MOUSEUP1),\n\tKEYC_MOUSE_KEY(MOUSEUP2),\n\tKEYC_MOUSE_KEY(MOUSEUP3),\n\tKEYC_MOUSE_KEY(MOUSEDRAG1),\n\tKEYC_MOUSE_KEY(MOUSEDRAG2),\n\tKEYC_MOUSE_KEY(MOUSEDRAG3),\n\tKEYC_MOUSE_KEY(MOUSEDRAGEND1),\n\tKEYC_MOUSE_KEY(MOUSEDRAGEND2),\n\tKEYC_MOUSE_KEY(MOUSEDRAGEND3),\n\tKEYC_MOUSE_KEY(WHEELUP),\n\tKEYC_MOUSE_KEY(WHEELDOWN),\n\n\t/* Backspace key. */\n\tKEYC_BSPACE,\n\n\t/* Function keys. */\n\tKEYC_F1,\n\tKEYC_F2,\n\tKEYC_F3,\n\tKEYC_F4,\n\tKEYC_F5,\n\tKEYC_F6,\n\tKEYC_F7,\n\tKEYC_F8,\n\tKEYC_F9,\n\tKEYC_F10,\n\tKEYC_F11,\n\tKEYC_F12,\n\tKEYC_IC,\n\tKEYC_DC,\n\tKEYC_HOME,\n\tKEYC_END,\n\tKEYC_NPAGE,\n\tKEYC_PPAGE,\n\tKEYC_BTAB,\n\n\t/* Arrow keys. */\n\tKEYC_UP,\n\tKEYC_DOWN,\n\tKEYC_LEFT,\n\tKEYC_RIGHT,\n\n\t/* Numeric keypad. */\n\tKEYC_KP_SLASH,\n\tKEYC_KP_STAR,\n\tKEYC_KP_MINUS,\n\tKEYC_KP_SEVEN,\n\tKEYC_KP_EIGHT,\n\tKEYC_KP_NINE,\n\tKEYC_KP_PLUS,\n\tKEYC_KP_FOUR,\n\tKEYC_KP_FIVE,\n\tKEYC_KP_SIX,\n\tKEYC_KP_ONE,\n\tKEYC_KP_TWO,\n\tKEYC_KP_THREE,\n\tKEYC_KP_ENTER,\n\tKEYC_KP_ZERO,\n\tKEYC_KP_PERIOD,\n};\n\n/* Termcap codes. */\nenum tty_code_code {\n\tTTYC_AX = 0,\n\tTTYC_ACSC,\t/* acs_chars, ac */\n\tTTYC_BCE,\t/* back_color_erase, ut */\n\tTTYC_BEL,\t/* bell, bl */\n\tTTYC_BLINK,\t/* enter_blink_mode, mb */\n\tTTYC_BOLD,\t/* enter_bold_mode, md */\n\tTTYC_CIVIS,\t/* cursor_invisible, vi */\n\tTTYC_CLEAR,\t/* clear_screen, cl */\n\tTTYC_CNORM,\t/* cursor_normal, ve */\n\tTTYC_COLORS,\t/* max_colors, Co */\n\tTTYC_CR,\t/* restore cursor colour, Cr */\n\tTTYC_CS,\t/* set cursor colour, Cs */\n\tTTYC_CSR,\t/* change_scroll_region, cs */\n\tTTYC_CUB,\t/* parm_left_cursor, LE */\n\tTTYC_CUB1,\t/* cursor_left, le */\n\tTTYC_CUD,\t/* parm_down_cursor, DO */\n\tTTYC_CUD1,\t/* cursor_down, do */\n\tTTYC_CUF,\t/* parm_right_cursor, RI */\n\tTTYC_CUF1,\t/* cursor_right, nd */\n\tTTYC_CUP,\t/* cursor_address, cm */\n\tTTYC_CUU,\t/* parm_up_cursor, UP */\n\tTTYC_CUU1,\t/* cursor_up, up */\n\tTTYC_CVVIS,\t/* cursor_visible, vs */\n\tTTYC_DCH,\t/* parm_dch, DC */\n\tTTYC_DCH1,\t/* delete_character, dc */\n\tTTYC_DIM,\t/* enter_dim_mode, mh */\n\tTTYC_DL,\t/* parm_delete_line, DL */\n\tTTYC_DL1,\t/* delete_line, dl */\n\tTTYC_E3,\n\tTTYC_ECH,\t/* erase_chars, ec */\n\tTTYC_EL,\t/* clr_eol, ce */\n\tTTYC_EL1,\t/* clr_bol, cb */\n\tTTYC_ENACS,\t/* ena_acs, eA */\n\tTTYC_FSL,\t/* from_status_line, fsl */\n\tTTYC_HOME,\t/* cursor_home, ho */\n\tTTYC_HPA,\t/* column_address, ch */\n\tTTYC_ICH,\t/* parm_ich, IC */\n\tTTYC_ICH1,\t/* insert_character, ic */\n\tTTYC_IL,\t/* parm_insert_line, IL */\n\tTTYC_IL1,\t/* insert_line, il */\n\tTTYC_INVIS,\t/* enter_secure_mode, mk */\n\tTTYC_IS1,\t/* init_1string, i1 */\n\tTTYC_IS2,\t/* init_2string, i2 */\n\tTTYC_IS3,\t/* init_3string, i3 */\n\tTTYC_KCBT,\t/* key_btab, kB */\n\tTTYC_KCUB1,\t/* key_left, kl */\n\tTTYC_KCUD1,\t/* key_down, kd */\n\tTTYC_KCUF1,\t/* key_right, kr */\n\tTTYC_KCUU1,\t/* key_up, ku */\n\tTTYC_KDC2,\n\tTTYC_KDC3,\n\tTTYC_KDC4,\n\tTTYC_KDC5,\n\tTTYC_KDC6,\n\tTTYC_KDC7,\n\tTTYC_KDCH1,\t/* key_dc, kD */\n\tTTYC_KDN2,\n\tTTYC_KDN3,\n\tTTYC_KDN4,\n\tTTYC_KDN5,\n\tTTYC_KDN6,\n\tTTYC_KDN7,\n\tTTYC_KEND,\t/* key_end, ke */\n\tTTYC_KEND2,\n\tTTYC_KEND3,\n\tTTYC_KEND4,\n\tTTYC_KEND5,\n\tTTYC_KEND6,\n\tTTYC_KEND7,\n\tTTYC_KF1,\n\tTTYC_KF10,\n\tTTYC_KF11,\n\tTTYC_KF12,\n\tTTYC_KF13,\n\tTTYC_KF14,\n\tTTYC_KF15,\n\tTTYC_KF16,\n\tTTYC_KF17,\n\tTTYC_KF18,\n\tTTYC_KF19,\n\tTTYC_KF2,\n\tTTYC_KF20,\n\tTTYC_KF21,\n\tTTYC_KF22,\n\tTTYC_KF23,\n\tTTYC_KF24,\n\tTTYC_KF25,\n\tTTYC_KF26,\n\tTTYC_KF27,\n\tTTYC_KF28,\n\tTTYC_KF29,\n\tTTYC_KF3,\n\tTTYC_KF30,\n\tTTYC_KF31,\n\tTTYC_KF32,\n\tTTYC_KF33,\n\tTTYC_KF34,\n\tTTYC_KF35,\n\tTTYC_KF36,\n\tTTYC_KF37,\n\tTTYC_KF38,\n\tTTYC_KF39,\n\tTTYC_KF4,\n\tTTYC_KF40,\n\tTTYC_KF41,\n\tTTYC_KF42,\n\tTTYC_KF43,\n\tTTYC_KF44,\n\tTTYC_KF45,\n\tTTYC_KF46,\n\tTTYC_KF47,\n\tTTYC_KF48,\n\tTTYC_KF49,\n\tTTYC_KF5,\n\tTTYC_KF50,\n\tTTYC_KF51,\n\tTTYC_KF52,\n\tTTYC_KF53,\n\tTTYC_KF54,\n\tTTYC_KF55,\n\tTTYC_KF56,\n\tTTYC_KF57,\n\tTTYC_KF58,\n\tTTYC_KF59,\n\tTTYC_KF6,\n\tTTYC_KF60,\n\tTTYC_KF61,\n\tTTYC_KF62,\n\tTTYC_KF63,\n\tTTYC_KF7,\n\tTTYC_KF8,\n\tTTYC_KF9,\n\tTTYC_KHOM2,\n\tTTYC_KHOM3,\n\tTTYC_KHOM4,\n\tTTYC_KHOM5,\n\tTTYC_KHOM6,\n\tTTYC_KHOM7,\n\tTTYC_KHOME,\t/* key_home, kh */\n\tTTYC_KIC2,\n\tTTYC_KIC3,\n\tTTYC_KIC4,\n\tTTYC_KIC5,\n\tTTYC_KIC6,\n\tTTYC_KIC7,\n\tTTYC_KICH1,\t/* key_ic, kI */\n\tTTYC_KLFT2,\n\tTTYC_KLFT3,\n\tTTYC_KLFT4,\n\tTTYC_KLFT5,\n\tTTYC_KLFT6,\n\tTTYC_KLFT7,\n\tTTYC_KMOUS,\t/* key_mouse, Km */\n\tTTYC_KNP,\t/* key_npage, kN */\n\tTTYC_KNXT2,\n\tTTYC_KNXT3,\n\tTTYC_KNXT4,\n\tTTYC_KNXT5,\n\tTTYC_KNXT6,\n\tTTYC_KNXT7,\n\tTTYC_KPP,\t/* key_ppage, kP */\n\tTTYC_KPRV2,\n\tTTYC_KPRV3,\n\tTTYC_KPRV4,\n\tTTYC_KPRV5,\n\tTTYC_KPRV6,\n\tTTYC_KPRV7,\n\tTTYC_KRIT2,\n\tTTYC_KRIT3,\n\tTTYC_KRIT4,\n\tTTYC_KRIT5,\n\tTTYC_KRIT6,\n\tTTYC_KRIT7,\n\tTTYC_KUP2,\n\tTTYC_KUP3,\n\tTTYC_KUP4,\n\tTTYC_KUP5,\n\tTTYC_KUP6,\n\tTTYC_KUP7,\n\tTTYC_MS,\t/* modify xterm(1) selection */\n\tTTYC_OP,\t/* orig_pair, op */\n\tTTYC_REV,\t/* enter_reverse_mode, mr */\n\tTTYC_RI,\t/* scroll_reverse, sr */\n\tTTYC_RMACS,\t/* exit_alt_charset_mode */\n\tTTYC_RMCUP,\t/* exit_ca_mode, te */\n\tTTYC_RMKX,\t/* keypad_local, ke */\n\tTTYC_SE,\t/* reset cursor style, Se */\n\tTTYC_SETAB,\t/* set_a_background, AB */\n\tTTYC_SETAF,\t/* set_a_foreground, AF */\n\tTTYC_SGR0,\t/* exit_attribute_mode, me */\n\tTTYC_SITM,\t/* enter_italics_mode, it */\n\tTTYC_SMACS,\t/* enter_alt_charset_mode, as */\n\tTTYC_SMCUP,\t/* enter_ca_mode, ti */\n\tTTYC_SMKX,\t/* keypad_xmit, ks */\n\tTTYC_SMSO,\t/* enter_standout_mode, so */\n\tTTYC_SMUL,\t/* enter_underline_mode, us */\n\tTTYC_SS,\t/* set cursor style, Ss */\n\tTTYC_TC,\t/* 24-bit \"true\" colour, Tc */\n\tTTYC_TSL,\t/* to_status_line, tsl */\n\tTTYC_VPA,\t/* row_address, cv */\n\tTTYC_XENL,\t/* eat_newline_glitch, xn */\n\tTTYC_XT,\t/* xterm(1)-compatible title, XT */\n};\n\n/* Message codes. */\nenum msgtype {\n\tMSG_VERSION = 12,\n\n\tMSG_IDENTIFY_FLAGS = 100,\n\tMSG_IDENTIFY_TERM,\n\tMSG_IDENTIFY_TTYNAME,\n\tMSG_IDENTIFY_OLDCWD, /* unused */\n\tMSG_IDENTIFY_STDIN,\n\tMSG_IDENTIFY_ENVIRON,\n\tMSG_IDENTIFY_DONE,\n\tMSG_IDENTIFY_CLIENTPID,\n\tMSG_IDENTIFY_CWD,\n\n\tMSG_COMMAND = 200,\n\tMSG_DETACH,\n\tMSG_DETACHKILL,\n\tMSG_EXIT,\n\tMSG_EXITED,\n\tMSG_EXITING,\n\tMSG_LOCK,\n\tMSG_READY,\n\tMSG_RESIZE,\n\tMSG_SHELL,\n\tMSG_SHUTDOWN,\n\tMSG_STDERR,\n\tMSG_STDIN,\n\tMSG_STDOUT,\n\tMSG_SUSPEND,\n\tMSG_UNLOCK,\n\tMSG_WAKEUP,\n};\n\n/*\n * Message data.\n *\n * Don't forget to bump PROTOCOL_VERSION if any of these change!\n */\nstruct msg_command_data {\n\tint\targc;\n}; /* followed by packed argv */\n\nstruct msg_stdin_data {\n\tssize_t\tsize;\n\tchar\tdata[BUFSIZ];\n};\n\nstruct msg_stdout_data {\n\tssize_t\tsize;\n\tchar\tdata[BUFSIZ];\n};\n\nstruct msg_stderr_data {\n\tssize_t\tsize;\n\tchar\tdata[BUFSIZ];\n};\n\n/* Mode key commands. */\nenum mode_key_cmd {\n\tMODEKEY_NONE,\n\tMODEKEY_OTHER,\n\n\t/* Editing keys. */\n\tMODEKEYEDIT_BACKSPACE,\n\tMODEKEYEDIT_CANCEL,\n\tMODEKEYEDIT_COMPLETE,\n\tMODEKEYEDIT_CURSORLEFT,\n\tMODEKEYEDIT_CURSORRIGHT,\n\tMODEKEYEDIT_DELETE,\n\tMODEKEYEDIT_DELETELINE,\n\tMODEKEYEDIT_DELETETOENDOFLINE,\n\tMODEKEYEDIT_DELETEWORD,\n\tMODEKEYEDIT_ENDOFLINE,\n\tMODEKEYEDIT_ENTER,\n\tMODEKEYEDIT_HISTORYDOWN,\n\tMODEKEYEDIT_HISTORYUP,\n\tMODEKEYEDIT_NEXTSPACE,\n\tMODEKEYEDIT_NEXTSPACEEND,\n\tMODEKEYEDIT_NEXTWORD,\n\tMODEKEYEDIT_NEXTWORDEND,\n\tMODEKEYEDIT_PASTE,\n\tMODEKEYEDIT_PREVIOUSSPACE,\n\tMODEKEYEDIT_PREVIOUSWORD,\n\tMODEKEYEDIT_STARTOFLINE,\n\tMODEKEYEDIT_SWITCHMODE,\n\tMODEKEYEDIT_SWITCHMODEAPPEND,\n\tMODEKEYEDIT_SWITCHMODEAPPENDLINE,\n\tMODEKEYEDIT_SWITCHMODEBEGINLINE,\n\tMODEKEYEDIT_SWITCHMODECHANGELINE,\n\tMODEKEYEDIT_SWITCHMODESUBSTITUTE,\n\tMODEKEYEDIT_SWITCHMODESUBSTITUTELINE,\n\tMODEKEYEDIT_TRANSPOSECHARS,\n\n\t/* Menu (choice) keys. */\n\tMODEKEYCHOICE_BACKSPACE,\n\tMODEKEYCHOICE_BOTTOMLINE,\n\tMODEKEYCHOICE_CANCEL,\n\tMODEKEYCHOICE_CHOOSE,\n\tMODEKEYCHOICE_DOWN,\n\tMODEKEYCHOICE_ENDOFLIST,\n\tMODEKEYCHOICE_PAGEDOWN,\n\tMODEKEYCHOICE_PAGEUP,\n\tMODEKEYCHOICE_SCROLLDOWN,\n\tMODEKEYCHOICE_SCROLLUP,\n\tMODEKEYCHOICE_STARTNUMBERPREFIX,\n\tMODEKEYCHOICE_STARTOFLIST,\n\tMODEKEYCHOICE_TOPLINE,\n\tMODEKEYCHOICE_TREE_COLLAPSE,\n\tMODEKEYCHOICE_TREE_COLLAPSE_ALL,\n\tMODEKEYCHOICE_TREE_EXPAND,\n\tMODEKEYCHOICE_TREE_EXPAND_ALL,\n\tMODEKEYCHOICE_TREE_TOGGLE,\n\tMODEKEYCHOICE_UP,\n\n\t/* Copy keys. */\n\tMODEKEYCOPY_APPENDSELECTION,\n\tMODEKEYCOPY_BACKTOINDENTATION,\n\tMODEKEYCOPY_BOTTOMLINE,\n\tMODEKEYCOPY_CANCEL,\n\tMODEKEYCOPY_CLEARSELECTION,\n\tMODEKEYCOPY_COPYPIPE,\n\tMODEKEYCOPY_COPYLINE,\n\tMODEKEYCOPY_COPYENDOFLINE,\n\tMODEKEYCOPY_COPYSELECTION,\n\tMODEKEYCOPY_DOWN,\n\tMODEKEYCOPY_ENDOFLINE,\n\tMODEKEYCOPY_GOTOLINE,\n\tMODEKEYCOPY_HALFPAGEDOWN,\n\tMODEKEYCOPY_HALFPAGEUP,\n\tMODEKEYCOPY_HISTORYBOTTOM,\n\tMODEKEYCOPY_HISTORYTOP,\n\tMODEKEYCOPY_JUMP,\n\tMODEKEYCOPY_JUMPAGAIN,\n\tMODEKEYCOPY_JUMPREVERSE,\n\tMODEKEYCOPY_JUMPBACK,\n\tMODEKEYCOPY_JUMPTO,\n\tMODEKEYCOPY_JUMPTOBACK,\n\tMODEKEYCOPY_LEFT,\n\tMODEKEYCOPY_MIDDLELINE,\n\tMODEKEYCOPY_NEXTPAGE,\n\tMODEKEYCOPY_NEXTSPACE,\n\tMODEKEYCOPY_NEXTSPACEEND,\n\tMODEKEYCOPY_NEXTWORD,\n\tMODEKEYCOPY_NEXTWORDEND,\n\tMODEKEYCOPY_OTHEREND,\n\tMODEKEYCOPY_PREVIOUSPAGE,\n\tMODEKEYCOPY_PREVIOUSSPACE,\n\tMODEKEYCOPY_PREVIOUSWORD,\n\tMODEKEYCOPY_RECTANGLETOGGLE,\n\tMODEKEYCOPY_RIGHT,\n\tMODEKEYCOPY_SCROLLDOWN,\n\tMODEKEYCOPY_SCROLLUP,\n\tMODEKEYCOPY_SEARCHAGAIN,\n\tMODEKEYCOPY_SEARCHDOWN,\n\tMODEKEYCOPY_SEARCHREVERSE,\n\tMODEKEYCOPY_SEARCHUP,\n\tMODEKEYCOPY_SELECTLINE,\n\tMODEKEYCOPY_STARTNAMEDBUFFER,\n\tMODEKEYCOPY_STARTNUMBERPREFIX,\n\tMODEKEYCOPY_STARTOFLINE,\n\tMODEKEYCOPY_STARTSELECTION,\n\tMODEKEYCOPY_TOPLINE,\n\tMODEKEYCOPY_UP,\n};\n\n/* Data required while mode keys are in use. */\nstruct mode_key_data {\n\tstruct mode_key_tree   *tree;\n\tint\t\t\tmode;\n};\n#define MODEKEY_EMACS 0\n#define MODEKEY_VI 1\n\n/* Binding between a key and a command. */\nstruct mode_key_binding {\n\tkey_code\t\t\t key;\n\n\tint\t\t\t\t mode;\n\tenum mode_key_cmd\t\t cmd;\n\tconst char\t\t\t*arg;\n\n\tRB_ENTRY(mode_key_binding)\t entry;\n};\nRB_HEAD(mode_key_tree, mode_key_binding);\n\n/* Command to string mapping. */\nstruct mode_key_cmdstr {\n\tenum mode_key_cmd\t cmd;\n\tconst char\t\t*name;\n};\n\n/* Named mode key table description. */\nstruct mode_key_entry;\nstruct mode_key_table {\n\tconst char\t\t\t*name;\n\tconst struct mode_key_cmdstr\t*cmdstr;\n\tstruct mode_key_tree\t\t*tree;\n\tconst struct mode_key_entry\t*table;\t/* default entries */\n};\n\n/* Modes. */\n#define MODE_CURSOR 0x1\n#define MODE_INSERT 0x2\n#define MODE_KCURSOR 0x4\n#define MODE_KKEYPAD 0x8\t/* set = application, clear = number */\n#define MODE_WRAP 0x10\t\t/* whether lines wrap */\n#define MODE_MOUSE_STANDARD 0x20\n#define MODE_MOUSE_BUTTON 0x40\n#define MODE_BLINKING 0x80\n#define MODE_MOUSE_UTF8 0x100\n#define MODE_MOUSE_SGR 0x200\n#define MODE_BRACKETPASTE 0x400\n#define MODE_FOCUSON 0x800\n\n#define ALL_MOUSE_MODES (MODE_MOUSE_STANDARD|MODE_MOUSE_BUTTON)\n\n/*\n * A single UTF-8 character. UTF8_SIZE must be big enough to hold at least one\n * combining character as well.\n*/\n#define UTF8_SIZE 9\nstruct utf8_data {\n\tu_char\tdata[UTF8_SIZE];\n\n\tu_char\thave;\n\tu_char\tsize;\n\n\tu_char\twidth;\t/* 0xff if invalid */\n} __packed;\nenum utf8_state {\n\tUTF8_MORE,\n\tUTF8_DONE,\n\tUTF8_ERROR\n};\n\n/* Grid attributes. */\n#define GRID_ATTR_BRIGHT 0x1\n#define GRID_ATTR_DIM 0x2\n#define GRID_ATTR_UNDERSCORE 0x4\n#define GRID_ATTR_BLINK 0x8\n#define GRID_ATTR_REVERSE 0x10\n#define GRID_ATTR_HIDDEN 0x20\n#define GRID_ATTR_ITALICS 0x40\n#define GRID_ATTR_CHARSET 0x80\t/* alternative character set */\n\n/* Grid flags. */\n#define GRID_FLAG_FG256 0x1\n#define GRID_FLAG_BG256 0x2\n#define GRID_FLAG_PADDING 0x4\n#define GRID_FLAG_EXTENDED 0x8\n#define GRID_FLAG_FGRGB 0x10\n#define GRID_FLAG_BGRGB 0x20\n\n/* Grid line flags. */\n#define GRID_LINE_WRAPPED 0x1\n\n/* Grid cell RGB colours. */\nstruct grid_cell_rgb {\n\tu_char\tr;\n\tu_char\tg;\n\tu_char\tb;\n};\n\n/* Grid cell data. */\nstruct grid_cell {\n\tu_char\t\t\tflags;\n\tu_char\t\t\tattr;\n\tunion {\n\t\tu_char\t\tfg;\n\t\tstruct grid_cell_rgb\tfg_rgb;\n\t};\n\tunion {\n\t\tu_char\t\tbg;\n\t\tstruct grid_cell_rgb\tbg_rgb;\n\t};\n\tstruct utf8_data\tdata;\n\n};\nstruct grid_cell_entry {\n\tu_char\t\t\tflags;\n\tunion {\n\t\tu_int\t\toffset;\n\t\tstruct {\n\t\t\tu_char\tattr;\n\t\t\tu_char\tfg;\n\t\t\tu_char\tbg;\n\t\t\tu_char\tdata;\n\t\t} data;\n\t};\n} __packed;\n\n/* Grid line. */\nstruct grid_line {\n\tu_int\t\t\t cellsize;\n\tstruct grid_cell_entry\t*celldata;\n\n\tu_int\t\t\t extdsize;\n\tstruct grid_cell\t*extddata;\n\n\tint\t\t\t flags;\n} __packed;\n\n/* Entire grid of cells. */\nstruct grid {\n\tint\t\t\t flags;\n#define GRID_HISTORY 0x1 /* scroll lines into history */\n\n\tu_int\t\t\t sx;\n\tu_int\t\t\t sy;\n\n\tu_int\t\t\t hsize;\n\tu_int\t\t\t hlimit;\n\n\tstruct grid_line\t*linedata;\n};\n\n/* Hook data structures. */\nstruct hook {\n\tconst char\t*name;\n\n\tstruct cmd_q\t*cmdq;\n\tstruct cmd_list\t*cmdlist;\n\n\tRB_ENTRY(hook)\t entry;\n};\n\n/* Option data structures. */\nstruct options_entry {\n\tconst char\t\t*name;\n\n\tenum {\n\t\tOPTIONS_STRING,\n\t\tOPTIONS_NUMBER,\n\t\tOPTIONS_STYLE\n\t} type;\n\n\tchar\t\t\t*str;\n\tlong long\t\t num;\n\tstruct grid_cell\t style;\n\n\tRB_ENTRY(options_entry) entry;\n};\n\n/* Scheduled job. */\nstruct job {\n\tenum {\n\t\tJOB_RUNNING,\n\t\tJOB_DEAD,\n\t\tJOB_CLOSED\n\t} state;\n\n\tchar\t\t*cmd;\n\tpid_t\t\t pid;\n\tint\t\t status;\n\n\tint\t\t fd;\n\tstruct bufferevent *event;\n\n\tvoid\t\t(*callbackfn)(struct job *);\n\tvoid\t\t(*freefn)(void *);\n\tvoid\t\t*data;\n\n\tLIST_ENTRY(job)\t lentry;\n};\nLIST_HEAD(joblist, job);\n\n/* Screen selection. */\nstruct screen_sel {\n\tint\t\t flag;\n\tint\t\t rectflag;\n\tenum {\n\t\tLINE_SEL_NONE,\n\t\tLINE_SEL_LEFT_RIGHT,\n\t\tLINE_SEL_RIGHT_LEFT,\n\t} lineflag;\n\n\tint\t\t modekeys;\n\n\tu_int\t\t sx;\n\tu_int\t\t sy;\n\n\tu_int\t\t ex;\n\tu_int\t\t ey;\n\n\tstruct grid_cell cell;\n};\n\n/* Virtual screen. */\nstruct screen {\n\tchar\t\t*title;\n\n\tstruct grid\t*grid;\t\t/* grid data */\n\n\tu_int\t\t cx;\t\t/* cursor x */\n\tu_int\t\t cy;\t\t/* cursor y */\n\n\tu_int\t\t cstyle;\t/* cursor style */\n\tchar\t\t*ccolour;\t/* cursor colour string */\n\n\tu_int\t\t rupper;\t/* scroll region top */\n\tu_int\t\t rlower;\t/* scroll region bottom */\n\n\tint\t\t mode;\n\n\tbitstr_t\t*tabs;\n\n\tstruct screen_sel sel;\n};\n\n/* Screen write context. */\nstruct screen_write_ctx {\n\tstruct window_pane *wp;\n\tstruct screen\t*s;\n};\n\n/* Screen size. */\n#define screen_size_x(s) ((s)->grid->sx)\n#define screen_size_y(s) ((s)->grid->sy)\n#define screen_hsize(s) ((s)->grid->hsize)\n#define screen_hlimit(s) ((s)->grid->hlimit)\n\n/*\n * Window mode. Windows can be in several modes and this is used to call the\n * right function to handle input and output.\n */\nstruct window_mode {\n\tstruct screen *(*init)(struct window_pane *);\n\tvoid\t(*free)(struct window_pane *);\n\tvoid\t(*resize)(struct window_pane *, u_int, u_int);\n\tvoid\t(*key)(struct window_pane *, struct client *, struct session *,\n\t\t    key_code, struct mouse_event *);\n};\n\n/* Structures for choose mode. */\nstruct window_choose_data {\n\tstruct client\t\t*start_client;\n\tstruct session\t\t*start_session;\n\n\tu_int\t\t\t idx;\n\tint\t\t\t type;\n#define TREE_OTHER 0x0\n#define TREE_WINDOW 0x1\n#define TREE_SESSION 0x2\n\n\tstruct session\t\t*tree_session; /* session of items in tree */\n\n\tstruct winlink\t\t*wl;\n\tint\t\t\t pane_id;\n\n\tchar\t\t\t*ft_template;\n\tstruct format_tree\t*ft;\n\n\tchar\t\t\t*command;\n};\n\n/* Child window structure. */\nstruct window_pane {\n\tu_int\t\t id;\n\tu_int\t\t active_point;\n\n\tstruct window\t*window;\n\n\tstruct layout_cell *layout_cell;\n\tstruct layout_cell *saved_layout_cell;\n\n\tu_int\t\t sx;\n\tu_int\t\t sy;\n\n\tu_int\t\t xoff;\n\tu_int\t\t yoff;\n\n\tint\t\t flags;\n#define PANE_REDRAW 0x1\n#define PANE_DROP 0x2\n#define PANE_FOCUSED 0x4\n#define PANE_RESIZE 0x8\n#define PANE_FOCUSPUSH 0x10\n#define PANE_INPUTOFF 0x20\n#define PANE_CHANGED 0x40\n\n\tint\t\t argc;\n\tchar\t       **argv;\n\tchar\t\t*shell;\n\tconst char\t*cwd;\n\n\tpid_t\t\t pid;\n\tchar\t\t tty[TTY_NAME_MAX];\n\tint\t\t status;\n\n\tint\t\t fd;\n\tstruct bufferevent *event;\n\tstruct event\t timer;\n\n\tstruct input_ctx *ictx;\n\n\tstruct grid_cell colgc;\n\n\tint\t\t pipe_fd;\n\tstruct bufferevent *pipe_event;\n\tsize_t\t\t pipe_off;\n\n#ifdef TMATE\n\tsize_t\t\t tmate_off;\n#endif\n\n\tstruct screen\t*screen;\n\tstruct screen\t base;\n\n\t/* Saved in alternative screen mode. */\n\tu_int\t\t saved_cx;\n\tu_int\t\t saved_cy;\n\tstruct grid\t*saved_grid;\n\tstruct grid_cell saved_cell;\n\n\tconst struct window_mode *mode;\n\tvoid\t\t*modedata;\n\n\tTAILQ_ENTRY(window_pane) entry;\n\tRB_ENTRY(window_pane) tree_entry;\n};\nTAILQ_HEAD(window_panes, window_pane);\nRB_HEAD(window_pane_tree, window_pane);\n\n/* Window structure. */\nstruct window {\n\tu_int\t\t id;\n\n\tchar\t\t*name;\n\tstruct event\t name_event;\n\tstruct timeval\t name_time;\n\n\tstruct event\t alerts_timer;\n\n\tstruct timeval\t activity_time;\n\n#ifdef TMATE\n\tstruct window_pane *tmate_last_sync_active_pane;\n#endif\n\tstruct window_pane *active;\n\tstruct window_pane *last;\n\tstruct window_panes panes;\n\n\tint\t\t lastlayout;\n\tstruct layout_cell *layout_root;\n\tstruct layout_cell *saved_layout_root;\n\tchar\t\t*old_layout;\n\n\tu_int\t\t sx;\n\tu_int\t\t sy;\n\n\tint\t\t flags;\n#define WINDOW_BELL 0x1\n#define WINDOW_ACTIVITY 0x2\n#define WINDOW_REDRAW 0x4\n#define WINDOW_SILENCE 0x8\n#define WINDOW_ZOOMED 0x1000\n#define WINDOW_FORCEWIDTH 0x2000\n#define WINDOW_FORCEHEIGHT 0x4000\n#define WINDOW_ALERTFLAGS (WINDOW_BELL|WINDOW_ACTIVITY|WINDOW_SILENCE)\n\n\tstruct options\t*options;\n\n\tu_int\t\t references;\n\n\tRB_ENTRY(window) entry;\n};\nRB_HEAD(windows, window);\n\n/* Entry on local window list. */\nstruct winlink {\n\tint\t\t idx;\n\tstruct window\t*window;\n\n\tsize_t\t\t status_width;\n\tstruct grid_cell status_cell;\n\tchar\t\t*status_text;\n\n\tint\t\t flags;\n#define WINLINK_BELL 0x1\n#define WINLINK_ACTIVITY 0x2\n#define WINLINK_SILENCE 0x4\n#define WINLINK_ALERTFLAGS (WINLINK_BELL|WINLINK_ACTIVITY|WINLINK_SILENCE)\n\n\tRB_ENTRY(winlink) entry;\n\tTAILQ_ENTRY(winlink) sentry;\n};\nRB_HEAD(winlinks, winlink);\nTAILQ_HEAD(winlink_stack, winlink);\n\n/* Layout direction. */\nenum layout_type {\n\tLAYOUT_LEFTRIGHT,\n\tLAYOUT_TOPBOTTOM,\n\tLAYOUT_WINDOWPANE\n};\n\n/* Layout cells queue. */\nTAILQ_HEAD(layout_cells, layout_cell);\n\n/* Layout cell. */\nstruct layout_cell {\n\tenum layout_type type;\n\n\tstruct layout_cell *parent;\n\n\tu_int\t\t sx;\n\tu_int\t\t sy;\n\n\tu_int\t\t xoff;\n\tu_int\t\t yoff;\n\n\tstruct window_pane *wp;\n\tstruct layout_cells cells;\n\n\tTAILQ_ENTRY(layout_cell) entry;\n};\n\n/* Environment variable. */\nstruct environ_entry {\n\tchar\t\t*name;\n\tchar\t\t*value;\n\n\tRB_ENTRY(environ_entry) entry;\n};\n\n/* Client session. */\nstruct session_group {\n\tTAILQ_HEAD(, session) sessions;\n\n\tTAILQ_ENTRY(session_group) entry;\n};\nTAILQ_HEAD(session_groups, session_group);\n\nstruct session {\n\tu_int\t\t id;\n\n\tchar\t\t*name;\n\tconst char\t*cwd;\n\n\tstruct timeval\t creation_time;\n\tstruct timeval\t last_attached_time;\n\tstruct timeval\t activity_time;\n\tstruct timeval\t last_activity_time;\n\n\tstruct event\t lock_timer;\n\n\tu_int\t\t sx;\n\tu_int\t\t sy;\n\n\tstruct winlink\t*curw;\n\tstruct winlink_stack lastw;\n\tstruct winlinks\t windows;\n\n\tstruct hooks\t*hooks;\n\tstruct options\t*options;\n\n#define SESSION_UNATTACHED 0x1\t/* not attached to any clients */\n#define SESSION_PASTING 0x2\n\tint\t\t flags;\n\n\tu_int\t\t attached;\n\n\tstruct termios\t*tio;\n\n\tstruct environ\t*environ;\n\n\tint\t\t references;\n\n\tTAILQ_ENTRY(session) gentry;\n\tRB_ENTRY(session)    entry;\n};\nRB_HEAD(sessions, session);\n\n/* Mouse button masks. */\n#define MOUSE_MASK_BUTTONS 3\n#define MOUSE_MASK_SHIFT 4\n#define MOUSE_MASK_META 8\n#define MOUSE_MASK_CTRL 16\n#define MOUSE_MASK_DRAG 32\n#define MOUSE_MASK_WHEEL 64\n\n/* Mouse wheel states. */\n#define MOUSE_WHEEL_UP 0\n#define MOUSE_WHEEL_DOWN 64\n\n/* Mouse helpers. */\n#define MOUSE_BUTTONS(b) ((b) & MOUSE_MASK_BUTTONS)\n#define MOUSE_WHEEL(b) ((b) & MOUSE_MASK_WHEEL)\n#define MOUSE_DRAG(b) ((b) & MOUSE_MASK_DRAG)\n#define MOUSE_RELEASE(b) (((b) & MOUSE_MASK_BUTTONS) == 3)\n\n/* Mouse input. */\nstruct mouse_event {\n\tint\t\tvalid;\n\n\tkey_code\tkey;\n\tint\t\tstatusat;\n\n\tu_int\t\tx;\n\tu_int\t\ty;\n\tu_int\t\tb;\n\n\tu_int\t\tlx;\n\tu_int\t\tly;\n\tu_int\t\tlb;\n\n\tint\t\ts;\n\tint\t\tw;\n\tint\t\twp;\n\n\tu_int\t\tsgr_type;\n\tu_int\t\tsgr_b;\n};\n\n/* TTY information. */\nstruct tty_key {\n\tchar\t\t ch;\n\tkey_code\t key;\n\n\tstruct tty_key\t*left;\n\tstruct tty_key\t*right;\n\n\tstruct tty_key\t*next;\n};\n\nstruct tty_code;\nstruct tty_term {\n\tchar\t\t*name;\n\tu_int\t\t references;\n\n\tchar\t\t acs[UCHAR_MAX + 1][2];\n\n\tstruct tty_code\t*codes;\n\n#define TERM_256COLOURS 0x1\n#define TERM_EARLYWRAP 0x2\n\tint\t\t flags;\n\n\tLIST_ENTRY(tty_term) entry;\n};\nLIST_HEAD(tty_terms, tty_term);\n\nstruct tty {\n\tstruct client\t*client;\n\tchar\t\t*path;\n\n\tu_int\t\t sx;\n\tu_int\t\t sy;\n\n\tu_int\t\t cx;\n\tu_int\t\t cy;\n\tu_int\t\t cstyle;\n\tchar\t\t*ccolour;\n\n\tint\t\t mode;\n\n\tu_int\t\t rlower;\n\tu_int\t\t rupper;\n\n\tchar\t\t*termname;\n\tstruct tty_term\t*term;\n\n\tint\t\t fd;\n\tstruct bufferevent *event;\n\n\tstruct termios\t tio;\n\n\tstruct grid_cell cell;\n\n#define TTY_NOCURSOR 0x1\n#define TTY_FREEZE 0x2\n#define TTY_TIMER 0x4\n#define TTY_UTF8 0x8\n#define TTY_STARTED 0x10\n#define TTY_OPENED 0x20\n#define TTY_FOCUS 0x40\n\tint\t\t flags;\n\n\tint\t\t term_flags;\n\n\tstruct mouse_event mouse;\n\tint\t\t mouse_drag_flag;\n\tvoid\t\t(*mouse_drag_update)(struct client *,\n\t\t\t    struct mouse_event *);\n\tvoid\t\t(*mouse_drag_release)(struct client *,\n\t\t\t    struct mouse_event *);\n\n\tstruct event\t key_timer;\n\tstruct tty_key\t*key_tree;\n};\n\n/* TTY command context. */\nstruct tty_ctx {\n\tstruct window_pane *wp;\n\n\tconst struct grid_cell *cell;\n\n\tu_int\t\t num;\n\tvoid\t\t*ptr;\n\n\t/*\n\t * Cursor and region position before the screen was updated - this is\n\t * where the command should be applied; the values in the screen have\n\t * already been updated.\n\t */\n\tu_int\t\t ocx;\n\tu_int\t\t ocy;\n\n\tu_int\t\t orupper;\n\tu_int\t\t orlower;\n\n\tu_int\t\t xoff;\n\tu_int\t\t yoff;\n\n\t/* Saved last cell on line. */\n\tstruct grid_cell last_cell;\n\tu_int\t\t last_width;\n};\n\n/* Saved message entry. */\nstruct message_entry {\n\tchar\t*msg;\n\tu_int\t msg_num;\n\ttime_t\t msg_time;\n\tTAILQ_ENTRY(message_entry) entry;\n};\n\n/* Client connection. */\nstruct client {\n\tstruct tmuxpeer\t*peer;\n\n\tpid_t\t\t pid;\n\tint\t\t fd;\n\tstruct event\t event;\n\tint\t\t retval;\n\n\tstruct timeval\t creation_time;\n\tstruct timeval\t activity_time;\n\n\tstruct environ\t*environ;\n\n\tchar\t\t*title;\n\tconst char\t*cwd;\n\n\tchar\t\t*term;\n\tchar\t\t*ttyname;\n\tstruct tty\t tty;\n\n\tvoid\t\t(*stdin_callback)(struct client *, int, void *);\n\tvoid\t\t*stdin_callback_data;\n\tstruct evbuffer\t*stdin_data;\n\tint\t\t stdin_closed;\n\tstruct evbuffer\t*stdout_data;\n\tstruct evbuffer\t*stderr_data;\n\n\tstruct event\t repeat_timer;\n\n\tstruct event\t status_timer;\n\tstruct screen\t status;\n\n#define CLIENT_TERMINAL 0x1\n#define CLIENT_LOGIN 0x2\n#define CLIENT_EXIT 0x4\n#define CLIENT_REDRAW 0x8\n#define CLIENT_STATUS 0x10\n#define CLIENT_REPEAT 0x20\n#define CLIENT_SUSPENDED 0x40\n/* 0x80 unused */\n#define CLIENT_IDENTIFY 0x100\n#define CLIENT_DEAD 0x200\n#define CLIENT_BORDERS 0x400\n#define CLIENT_READONLY 0x800\n#define CLIENT_REDRAWWINDOW 0x1000\n#define CLIENT_CONTROL 0x2000\n#define CLIENT_CONTROLCONTROL 0x4000\n#define CLIENT_FOCUSED 0x8000\n#define CLIENT_UTF8 0x10000\n#define CLIENT_256COLOURS 0x20000\n#define CLIENT_IDENTIFIED 0x40000\n#define CLIENT_STATUSFORCE 0x80000\n#ifdef TMATE\n/* TODO investigate if we can merge with CLIENT_STATUSFORCE */\n#define CLIENT_FORCE_STATUS 0x800000\n#endif\n\tint\t\t flags;\n\tstruct key_table *keytable;\n\n\tstruct event\t identify_timer;\n\n\tchar\t\t*message_string;\n\tstruct event\t message_timer;\n\tu_int\t\t message_next;\n\tTAILQ_HEAD(, message_entry) message_log;\n\n\tchar\t\t*prompt_string;\n\tchar\t\t*prompt_buffer;\n\tsize_t\t\t prompt_index;\n\tint\t\t (*prompt_callbackfn)(void *, const char *);\n\tvoid\t\t (*prompt_freefn)(void *);\n\tvoid\t\t*prompt_data;\n\tu_int\t\t prompt_hindex;\n\n#define PROMPT_SINGLE 0x1\n\tint\t\t prompt_flags;\n\n\tstruct mode_key_data prompt_mdata;\n\n\tstruct session\t*session;\n\tstruct session\t*last_session;\n\n\tint\t\t wlmouse;\n\n\tstruct cmd_q\t*cmdq;\n\tint\t\t references;\n\n\tTAILQ_ENTRY(client) entry;\n};\nTAILQ_HEAD(clients, client);\n\n/* Parsed arguments structures. */\nstruct args_entry;\nRB_HEAD(args_tree, args_entry);\nstruct args {\n\tstruct args_tree\t  tree;\n\tint\t\t\t  argc;\n\tchar\t\t\t**argv;\n};\n\n/* Command find structures. */\nenum cmd_find_type {\n\tCMD_FIND_PANE,\n\tCMD_FIND_WINDOW,\n\tCMD_FIND_SESSION,\n};\nstruct cmd_find_state {\n\tstruct cmd_q\t\t*cmdq;\n\tint\t\t\t flags;\n\tstruct cmd_find_state\t*current;\n\n\tstruct session          *s;\n\tstruct winlink          *wl;\n\tstruct window\t\t*w;\n\tstruct window_pane      *wp;\n\tint\t\t\t idx;\n};\n\n/* Command find flags. */\n#define CMD_FIND_PREFER_UNATTACHED 0x1\n#define CMD_FIND_QUIET 0x2\n#define CMD_FIND_WINDOW_INDEX 0x4\n#define CMD_FIND_DEFAULT_MARKED 0x8\n#define CMD_FIND_EXACT_SESSION 0x10\n#define CMD_FIND_EXACT_WINDOW 0x20\n\n/* Context for command being executed. */\nstruct cmd_state {\n\tstruct client\t\t*c;\n\tstruct cmd_find_state\t tflag;\n\tstruct cmd_find_state\t sflag;\n};\n\n/* Command and list of commands. */\nstruct cmd {\n\tconst struct cmd_entry\t*entry;\n\tstruct args\t\t*args;\n\n\tchar\t\t\t*file;\n\tu_int\t\t\t line;\n\n#define CMD_CONTROL 0x1\n\tint\t\t\t flags;\n\n\tTAILQ_ENTRY(cmd)\t qentry;\n};\n\nstruct cmd_list {\n\tint\t\t\t references;\n\tTAILQ_HEAD(, cmd)\t list;\n};\n\n/* Command return values. */\nenum cmd_retval {\n\tCMD_RETURN_ERROR = -1,\n\tCMD_RETURN_NORMAL = 0,\n\tCMD_RETURN_WAIT,\n\tCMD_RETURN_STOP\n};\n\n/* Command queue entry. */\nstruct cmd_q_item {\n\tstruct cmd_list\t\t*cmdlist;\n\n\tstruct mouse_event\t mouse;\n\n\tTAILQ_ENTRY(cmd_q_item)\t qentry;\n};\nTAILQ_HEAD(cmd_q_items, cmd_q_item);\n\n/* Command queue. */\nstruct cmd_q {\n\tint\t\t\t references;\n\tint\t\t\t flags;\n#define CMD_Q_DEAD 0x1\n#define CMD_Q_REENTRY 0x2\n#define CMD_Q_NOHOOKS 0x4\n\n\tstruct client\t\t*client;\n\tint\t\t\t client_exit;\n\n\tstruct cmd_q_items\t queue;\n\tstruct cmd_q_item\t*item;\n\tstruct cmd\t\t*cmd;\n\tstruct cmd_q\t\t*parent;\n\n\tstruct cmd_find_state\t current;\n\tstruct cmd_state\t state;\n\n\ttime_t\t\t\t time;\n\tu_int\t\t\t number;\n\n\tvoid\t\t\t (*emptyfn)(struct cmd_q *);\n\tvoid\t\t\t*data;\n\n\tTAILQ_ENTRY(cmd_q)\t waitentry;\n};\n\n/* Command -c, -t or -s flags. */\nenum cmd_entry_flag {\n\tCMD_NONE,\n\n\tCMD_CLIENT,\n\tCMD_CLIENT_CANFAIL,\n\n\tCMD_SESSION,\n\tCMD_SESSION_CANFAIL,\n\tCMD_SESSION_PREFERUNATTACHED,\n\tCMD_SESSION_WITHPANE,\n\n\tCMD_WINDOW,\n\tCMD_WINDOW_CANFAIL,\n\tCMD_WINDOW_MARKED,\n\tCMD_WINDOW_INDEX,\n\n\tCMD_PANE,\n\tCMD_PANE_CANFAIL,\n\tCMD_PANE_MARKED,\n\n\tCMD_MOVEW_R,\n};\n\n/* Command definition. */\nstruct cmd_entry {\n\tconst char\t\t*name;\n\tconst char\t\t*alias;\n\n\tstruct {\n\t\tconst char\t*template;\n\t\tint\t\t lower;\n\t\tint\t\t upper;\n\t} args;\n\tconst char\t\t*usage;\n\n\tenum cmd_entry_flag\t tflag;\n\tenum cmd_entry_flag\t sflag;\n\tenum cmd_entry_flag\t cflag;\n\n#define CMD_STARTSERVER 0x1\n#define CMD_READONLY 0x2\n\tint\t\t flags;\n\n\tenum cmd_retval\t\t (*exec)(struct cmd *, struct cmd_q *);\n};\n\n/* Key binding and key table. */\nstruct key_binding {\n\tkey_code\t\t key;\n\tstruct cmd_list\t\t*cmdlist;\n\tint\t\t\t can_repeat;\n\n\tRB_ENTRY(key_binding)\t entry;\n};\nRB_HEAD(key_bindings, key_binding);\n\nstruct key_table {\n\tconst char\t\t *name;\n\tstruct key_bindings\t key_bindings;\n\n\tu_int\t\t\t references;\n\n\tRB_ENTRY(key_table)\t entry;\n};\nRB_HEAD(key_tables, key_table);\n\n/*\n * Option table entries. The option table is the user-visible part of the\n * option, as opposed to the internal options (struct option) which are just\n * number or string.\n */\nenum options_table_type {\n\tOPTIONS_TABLE_STRING,\n\tOPTIONS_TABLE_NUMBER,\n\tOPTIONS_TABLE_KEY,\n\tOPTIONS_TABLE_COLOUR,\n\tOPTIONS_TABLE_ATTRIBUTES,\n\tOPTIONS_TABLE_FLAG,\n\tOPTIONS_TABLE_CHOICE,\n\tOPTIONS_TABLE_STYLE\n};\nenum options_table_scope {\n\tOPTIONS_TABLE_NONE,\n\tOPTIONS_TABLE_SERVER,\n\tOPTIONS_TABLE_SESSION,\n\tOPTIONS_TABLE_WINDOW,\n};\n\nstruct options_table_entry {\n\tconst char\t\t *name;\n\tenum options_table_type\t  type;\n\tenum options_table_scope  scope;\n\n\tu_int\t\t\t  minimum;\n\tu_int\t\t\t  maximum;\n\tconst char\t\t**choices;\n\n\tconst char\t\t *default_str;\n\tlong long\t\t  default_num;\n\n\tconst char\t\t *style;\n};\n\n/* Common command usages. */\n#define CMD_TARGET_PANE_USAGE \"[-t target-pane]\"\n#define CMD_TARGET_WINDOW_USAGE \"[-t target-window]\"\n#define CMD_TARGET_SESSION_USAGE \"[-t target-session]\"\n#define CMD_TARGET_CLIENT_USAGE \"[-t target-client]\"\n#define CMD_SRCDST_PANE_USAGE \"[-s src-pane] [-t dst-pane]\"\n#define CMD_SRCDST_WINDOW_USAGE \"[-s src-window] [-t dst-window]\"\n#define CMD_SRCDST_SESSION_USAGE \"[-s src-session] [-t dst-session]\"\n#define CMD_SRCDST_CLIENT_USAGE \"[-s src-client] [-t dst-client]\"\n#define CMD_BUFFER_USAGE \"[-b buffer-name]\"\n\n/* tmux.c */\nextern struct hooks\t*global_hooks;\nextern struct options\t*global_options;\nextern struct options\t*global_s_options;\nextern struct options\t*global_w_options;\nextern struct environ\t*global_environ;\nextern struct timeval\t start_time;\nextern const char\t*socket_path;\n#ifdef TMATE\nextern int tmate_foreground;\nvoid tmate_load_cli_options(void);\n#endif\nconst char\t*getshell(void);\nint\t\t checkshell(const char *);\nint\t\t areshell(const char *);\nvoid\t\t setblocking(int, int);\nconst char\t*find_home(void);\n\n/* proc.c */\nstruct imsg;\nint\tproc_send(struct tmuxpeer *, enum msgtype, int, const void *, size_t);\nint\tproc_send_s(struct tmuxpeer *, enum msgtype, const char *);\nstruct tmuxproc *proc_start(const char *, struct event_base *, int,\n\t    void (*)(int));\nvoid\tproc_loop(struct tmuxproc *, int (*)(void));\nvoid\tproc_exit(struct tmuxproc *);\nstruct tmuxpeer *proc_add_peer(struct tmuxproc *, int,\n\t    void (*)(struct imsg *, void *), void *);\nvoid\tproc_remove_peer(struct tmuxpeer *);\nvoid\tproc_kill_peer(struct tmuxpeer *);\n\n/* cfg.c */\nextern int cfg_finished;\nextern int cfg_references;\nextern struct client *cfg_client;\nextern char\t\t**cfg_causes;\nextern u_int\t\t  cfg_ncauses;\nvoid\t\t start_cfg(void);\nint\t\t load_cfg(const char *, struct cmd_q *, char **);\nvoid\t\t set_cfg_file(const char *);\nvoid printflike(1, 2) cfg_add_cause(const char *, ...);\nvoid\t\t cfg_print_causes(struct cmd_q *);\nvoid\t\t cfg_show_causes(struct session *);\n\n/* paste.c */\nstruct paste_buffer;\nconst char\t*paste_buffer_name(struct paste_buffer *);\nconst char\t*paste_buffer_data(struct paste_buffer *, size_t *);\nstruct paste_buffer *paste_walk(struct paste_buffer *);\nstruct paste_buffer *paste_get_top(const char **);\nstruct paste_buffer *paste_get_name(const char *);\nvoid\t\t paste_free(struct paste_buffer *);\nvoid\t\t paste_add(char *, size_t);\nint\t\t paste_rename(const char *, const char *, char **);\nint\t\t paste_set(char *, size_t, const char *, char **);\nchar\t\t*paste_make_sample(struct paste_buffer *);\n\n/* format.c */\n#define FORMAT_STATUS 0x1\n#define FORMAT_FORCE 0x2\nstruct format_tree;\nstruct format_tree *format_create(struct cmd_q *, int);\nvoid\t\t format_free(struct format_tree *);\nvoid printflike(3, 4) format_add(struct format_tree *, const char *,\n\t\t     const char *, ...);\nchar\t\t*format_expand_time(struct format_tree *, const char *, time_t);\nchar\t\t*format_expand(struct format_tree *, const char *);\nvoid\t\t format_defaults(struct format_tree *, struct client *,\n\t\t     struct session *, struct winlink *, struct window_pane *);\nvoid\t\t format_defaults_window(struct format_tree *, struct window *);\nvoid\t\t format_defaults_pane(struct format_tree *,\n\t\t     struct window_pane *);\nvoid\t\t format_defaults_paste_buffer(struct format_tree *,\n\t\t     struct paste_buffer *);\n\n/* hooks.c */\nstruct hook;\nstruct hooks \t*hooks_get(struct session *);\nstruct hooks\t*hooks_create(struct hooks *);\nvoid\t\t hooks_free(struct hooks *);\nstruct hook\t*hooks_first(struct hooks *);\nstruct hook\t*hooks_next(struct hook *);\nvoid\t\t hooks_add(struct hooks *, const char *, struct cmd_list *);\nvoid\t\t hooks_copy(struct hooks *, struct hooks *);\nvoid\t\t hooks_remove(struct hooks *, const char *);\nstruct hook\t*hooks_find(struct hooks *, const char *);\nint printflike(4, 5) hooks_run(struct hooks *, struct client *,\n\t\t    struct cmd_find_state *, const char *, ...);\nint printflike(4, 5) hooks_wait(struct hooks *, struct cmd_q *,\n\t\t    struct cmd_find_state *, const char *, ...);\n\n/* mode-key.c */\nextern const struct mode_key_table mode_key_tables[];\nextern struct mode_key_tree mode_key_tree_vi_edit;\nextern struct mode_key_tree mode_key_tree_vi_choice;\nextern struct mode_key_tree mode_key_tree_vi_copy;\nextern struct mode_key_tree mode_key_tree_emacs_edit;\nextern struct mode_key_tree mode_key_tree_emacs_choice;\nextern struct mode_key_tree mode_key_tree_emacs_copy;\nint\tmode_key_cmp(struct mode_key_binding *, struct mode_key_binding *);\nRB_PROTOTYPE(mode_key_tree, mode_key_binding, entry, mode_key_cmp);\nconst char *mode_key_tostring(const struct mode_key_cmdstr *,\n\t    enum mode_key_cmd);\nenum mode_key_cmd mode_key_fromstring(const struct mode_key_cmdstr *,\n\t    const char *);\nconst struct mode_key_table *mode_key_findtable(const char *);\nvoid\tmode_key_init_trees(void);\nvoid\tmode_key_init(struct mode_key_data *, struct mode_key_tree *);\nenum mode_key_cmd mode_key_lookup(struct mode_key_data *, key_code,\n\t    const char **);\n\n/* notify.c */\nvoid\tnotify_enable(void);\nvoid\tnotify_disable(void);\nvoid\tnotify_input(struct window_pane *, struct evbuffer *);\nvoid\tnotify_window_layout_changed(struct window *);\nvoid\tnotify_window_unlinked(struct session *, struct window *);\nvoid\tnotify_window_linked(struct session *, struct window *);\nvoid\tnotify_window_renamed(struct window *);\nvoid\tnotify_attached_session_changed(struct client *);\nvoid\tnotify_session_renamed(struct session *);\nvoid\tnotify_session_created(struct session *);\nvoid\tnotify_session_closed(struct session *);\n\n/* options.c */\nstruct options *options_create(struct options *);\nvoid\toptions_free(struct options *);\nstruct options_entry *options_first(struct options *);\nstruct options_entry *options_next(struct options_entry *);\nstruct options_entry *options_find1(struct options *, const char *);\nstruct options_entry *options_find(struct options *, const char *);\nvoid\toptions_remove(struct options *, const char *);\nstruct options_entry *printflike(3, 4) options_set_string(struct options *,\n\t    const char *, const char *, ...);\nchar   *options_get_string(struct options *, const char *);\nstruct options_entry *options_set_number(struct options *, const char *,\n\t    long long);\nlong long options_get_number(struct options *, const char *);\nstruct options_entry *options_set_style(struct options *, const char *,\n\t    const char *, int);\nstruct grid_cell *options_get_style(struct options *, const char *);\n\n/* options-table.c */\nextern const struct options_table_entry options_table[];\nvoid\toptions_table_populate_tree(enum options_table_scope, struct options *);\nconst char *options_table_print_entry(const struct options_table_entry *,\n\t    struct options_entry *, int);\nint\toptions_table_find(const char *, const struct options_table_entry **);\n\n/* job.c */\nextern struct joblist all_jobs;\nstruct job *job_run(const char *, struct session *, const char *,\n\t    void (*)(struct job *), void (*)(void *), void *);\nvoid\tjob_free(struct job *);\nvoid\tjob_died(struct job *, int);\n\n/* environ.c */\nstruct environ *environ_create(void);\nvoid\tenviron_free(struct environ *);\nstruct environ_entry *environ_first(struct environ *);\nstruct environ_entry *environ_next(struct environ_entry *);\nvoid\tenviron_copy(struct environ *, struct environ *);\nstruct environ_entry *environ_find(struct environ *, const char *);\nvoid printflike(3, 4) environ_set(struct environ *, const char *, const char *,\n\t    ...);\nvoid\tenviron_clear(struct environ *, const char *);\nvoid\tenviron_put(struct environ *, const char *);\nvoid\tenviron_unset(struct environ *, const char *);\nvoid\tenviron_update(const char *, struct environ *, struct environ *);\nvoid\tenviron_push(struct environ *);\n\n/* tty.c */\nvoid\ttty_create_log(void);\nvoid\ttty_init_termios(int, struct termios *, struct bufferevent *);\nvoid\ttty_raw(struct tty *, const char *);\nvoid\ttty_attributes(struct tty *, const struct grid_cell *,\n\t    const struct window_pane *);\nvoid\ttty_reset(struct tty *);\nvoid\ttty_region_pane(struct tty *, const struct tty_ctx *, u_int, u_int);\nvoid\ttty_region(struct tty *, u_int, u_int);\nvoid\ttty_cursor_pane(struct tty *, const struct tty_ctx *, u_int, u_int);\nvoid\ttty_cursor(struct tty *, u_int, u_int);\nvoid\ttty_putcode(struct tty *, enum tty_code_code);\nvoid\ttty_putcode1(struct tty *, enum tty_code_code, int);\nvoid\ttty_putcode2(struct tty *, enum tty_code_code, int, int);\nvoid\ttty_putcode_ptr1(struct tty *, enum tty_code_code, const void *);\nvoid\ttty_putcode_ptr2(struct tty *, enum tty_code_code, const void *,\n\t    const void *);\nvoid\ttty_puts(struct tty *, const char *);\nvoid\ttty_putc(struct tty *, u_char);\nvoid\ttty_putn(struct tty *, const void *, size_t, u_int);\nint\ttty_init(struct tty *, struct client *, int, char *);\nint\ttty_resize(struct tty *);\nint\ttty_set_size(struct tty *, u_int, u_int);\nvoid\ttty_start_tty(struct tty *);\nvoid\ttty_stop_tty(struct tty *);\nvoid\ttty_set_title(struct tty *, const char *);\nvoid\ttty_update_mode(struct tty *, int, struct screen *);\nvoid\ttty_force_cursor_colour(struct tty *, const char *);\nvoid\ttty_draw_pane(struct tty *, const struct window_pane *, u_int, u_int,\n\t    u_int);\nvoid\ttty_draw_line(struct tty *, const struct window_pane *, struct screen *,\n\t    u_int, u_int, u_int);\nint\ttty_open(struct tty *, char **);\nvoid\ttty_close(struct tty *);\nvoid\ttty_free(struct tty *);\nvoid\ttty_write(void (*)(struct tty *, const struct tty_ctx *),\n\t    struct tty_ctx *);\nint\ttty_client_ready(struct client *, struct window_pane *wp);\nvoid\ttty_cmd_alignmenttest(struct tty *, const struct tty_ctx *);\nvoid\ttty_cmd_cell(struct tty *, const struct tty_ctx *);\nvoid\ttty_cmd_clearendofline(struct tty *, const struct tty_ctx *);\nvoid\ttty_cmd_clearendofscreen(struct tty *, const struct tty_ctx *);\nvoid\ttty_cmd_clearline(struct tty *, const struct tty_ctx *);\nvoid\ttty_cmd_clearscreen(struct tty *, const struct tty_ctx *);\nvoid\ttty_cmd_clearstartofline(struct tty *, const struct tty_ctx *);\nvoid\ttty_cmd_clearstartofscreen(struct tty *, const struct tty_ctx *);\nvoid\ttty_cmd_deletecharacter(struct tty *, const struct tty_ctx *);\nvoid\ttty_cmd_clearcharacter(struct tty *, const struct tty_ctx *);\nvoid\ttty_cmd_deleteline(struct tty *, const struct tty_ctx *);\nvoid\ttty_cmd_erasecharacter(struct tty *, const struct tty_ctx *);\nvoid\ttty_cmd_insertcharacter(struct tty *, const struct tty_ctx *);\nvoid\ttty_cmd_insertline(struct tty *, const struct tty_ctx *);\nvoid\ttty_cmd_linefeed(struct tty *, const struct tty_ctx *);\nvoid\ttty_cmd_utf8character(struct tty *, const struct tty_ctx *);\nvoid\ttty_cmd_reverseindex(struct tty *, const struct tty_ctx *);\nvoid\ttty_cmd_setselection(struct tty *, const struct tty_ctx *);\nvoid\ttty_cmd_rawstring(struct tty *, const struct tty_ctx *);\n\n/* tty-term.c */\nextern struct tty_terms tty_terms;\nu_int\t\t tty_term_ncodes(void);\nstruct tty_term *tty_term_find(char *, int, char **);\nvoid\t\t tty_term_free(struct tty_term *);\nint\t\t tty_term_has(struct tty_term *, enum tty_code_code);\nconst char\t*tty_term_string(struct tty_term *, enum tty_code_code);\nconst char\t*tty_term_string1(struct tty_term *, enum tty_code_code, int);\nconst char\t*tty_term_string2(struct tty_term *, enum tty_code_code, int,\n\t\t     int);\nconst char\t*tty_term_ptr1(struct tty_term *, enum tty_code_code,\n\t\t     const void *);\nconst char\t*tty_term_ptr2(struct tty_term *, enum tty_code_code,\n\t\t     const void *, const void *);\nint\t\t tty_term_number(struct tty_term *, enum tty_code_code);\nint\t\t tty_term_flag(struct tty_term *, enum tty_code_code);\nconst char\t*tty_term_describe(struct tty_term *, enum tty_code_code);\n\n/* tty-acs.c */\nconst char\t*tty_acs_get(struct tty *, u_char);\n\n/* tty-keys.c */\nvoid\t\ttty_keys_build(struct tty *);\nvoid\t\ttty_keys_free(struct tty *);\nkey_code\ttty_keys_next(struct tty *);\n\n/* arguments.c */\nint\t\t args_cmp(struct args_entry *, struct args_entry *);\nRB_PROTOTYPE(args_tree, args_entry, entry, args_cmp);\nstruct args\t*args_create(int, ...);\nstruct args\t*args_parse(const char *, int, char **);\nvoid\t\t args_free(struct args *);\nchar\t\t*args_print(struct args *);\nint\t\t args_has(struct args *, u_char);\nvoid\t\t args_set(struct args *, u_char, const char *);\nconst char\t*args_get(struct args *, u_char);\nlong long\t args_strtonum(struct args *, u_char, long long, long long,\n\t\t     char **);\n\n/* cmd-find.c */\nint\t\t cmd_find_current(struct cmd_find_state *, struct cmd_q *,\n\t\t     int);\nint\t\t cmd_find_target(struct cmd_find_state *,\n\t\t     struct cmd_find_state *, struct cmd_q *, const char *,\n\t\t     enum cmd_find_type, int);\nstruct client\t*cmd_find_client(struct cmd_q *, const char *, int);\nvoid\t\t cmd_find_clear_state(struct cmd_find_state *, struct cmd_q *,\n\t\t     int);\nint\t\t cmd_find_valid_state(struct cmd_find_state *);\nvoid\t\t cmd_find_copy_state(struct cmd_find_state *,\n\t\t     struct cmd_find_state *);\nvoid\t\t cmd_find_log_state(const char *, struct cmd_find_state *);\nint\t\t cmd_find_from_session(struct cmd_find_state *,\n\t\t     struct session *);\nint\t\t cmd_find_from_winlink(struct cmd_find_state *,\n\t\t     struct session *, struct winlink *);\nint\t\t cmd_find_from_window(struct cmd_find_state *, struct window *);\nint\t\t cmd_find_from_pane(struct cmd_find_state *,\n\t\t     struct window_pane *);\n\n/* cmd.c */\nint\t\t cmd_pack_argv(int, char **, char *, size_t);\nint\t\t cmd_unpack_argv(char *, size_t, int, char ***);\nchar\t       **cmd_copy_argv(int, char **);\nvoid\t\t cmd_free_argv(int, char **);\nchar\t\t*cmd_stringify_argv(int, char **);\nstruct cmd\t*cmd_parse(int, char **, const char *, u_int, char **);\nint\t\t cmd_prepare_state(struct cmd *, struct cmd_q *,\n\t\t     struct cmd_q *);\nchar\t\t*cmd_print(struct cmd *);\nint\t\t cmd_mouse_at(struct window_pane *, struct mouse_event *,\n\t\t     u_int *, u_int *, int);\nstruct winlink\t*cmd_mouse_window(struct mouse_event *, struct session **);\nstruct window_pane *cmd_mouse_pane(struct mouse_event *, struct session **,\n\t\t     struct winlink **);\nchar\t\t*cmd_template_replace(const char *, const char *, int);\nextern const struct cmd_entry *cmd_table[];\n\n/* cmd-attach-session.c */\nenum cmd_retval\t cmd_attach_session(struct cmd_q *, int, int, const char *,\n    int);\n\n/* cmd-list.c */\nstruct cmd_list\t*cmd_list_parse(int, char **, const char *, u_int, char **);\nvoid\t\t cmd_list_free(struct cmd_list *);\nchar\t\t*cmd_list_print(struct cmd_list *);\n\n/* cmd-queue.c */\nstruct cmd_q\t*cmdq_new(struct client *);\nint\t\t cmdq_free(struct cmd_q *);\nvoid printflike(2, 3) cmdq_print(struct cmd_q *, const char *, ...);\nvoid printflike(2, 3) cmdq_error(struct cmd_q *, const char *, ...);\nvoid\t\t cmdq_guard(struct cmd_q *, const char *, int);\nvoid\t\t cmdq_run(struct cmd_q *, struct cmd_list *,\n\t\t     struct mouse_event *);\nvoid\t\t cmdq_append(struct cmd_q *, struct cmd_list *,\n\t\t     struct mouse_event *);\nint\t\t cmdq_continue(struct cmd_q *);\nvoid\t\t cmdq_flush(struct cmd_q *);\n\n/* cmd-string.c */\nint\tcmd_string_parse(const char *, struct cmd_list **, const char *,\n\t    u_int, char **);\n\n/* cmd-wait-for.c */\n#ifdef TMATE\nvoid signal_waiting_clients(const char *name);\n#endif\nvoid\tcmd_wait_for_flush(void);\n\n/* client.c */\n#define DEFER_ERRORS_CFG 1\nint run_headless_command(int argc, const char **argv, int flags, void (*err_callback)(const char *));\nvoid run_initial_client_cmd(void);\nint\tclient_main(struct event_base *, int, char **, int, const char *);\n\n/* key-bindings.c */\nRB_PROTOTYPE(key_bindings, key_binding, entry, key_bindings_cmp);\nRB_PROTOTYPE(key_tables, key_table, entry, key_table_cmp);\nextern struct key_tables key_tables;\nint\t key_table_cmp(struct key_table *, struct key_table *);\nint\t key_bindings_cmp(struct key_binding *, struct key_binding *);\nstruct key_table *key_bindings_get_table(const char *, int);\nvoid\t key_bindings_unref_table(struct key_table *);\nvoid\t key_bindings_add(const char *, key_code, int, struct cmd_list *);\nvoid\t key_bindings_remove(const char *, key_code);\nvoid\t key_bindings_remove_table(const char *);\nvoid\t key_bindings_init(void);\nvoid\t key_bindings_dispatch(struct key_binding *, struct client *,\n\t     struct mouse_event *);\n\n/* key-string.c */\nkey_code\t key_string_lookup_string(const char *);\nconst char\t*key_string_lookup_key(key_code);\n\n/* alerts.c */\nvoid\talerts_reset_all(void);\nvoid\talerts_queue(struct window *, int);\nvoid\talerts_check_session(struct session *);\n\n/* server.c */\nextern int server_exit;\nextern struct tmuxproc *server_proc;\nextern struct clients clients;\nextern struct cmd_find_state marked_pane;\nvoid\t server_set_marked(struct session *, struct winlink *,\n\t     struct window_pane *);\nvoid\t server_clear_marked(void);\nint\t server_is_marked(struct session *, struct winlink *,\n\t     struct window_pane *);\nint\t server_check_marked(void);\nint\t server_start(struct event_base *, int, char *);\nvoid\t server_update_socket(void);\nvoid\t server_add_accept(int);\n\n/* server-client.c */\nvoid\t server_client_set_key_table(struct client *, const char *);\nconst char *server_client_get_key_table(struct client *);\nint\t server_client_check_nested(struct client *);\nvoid\t server_client_handle_key(struct client *, key_code);\nvoid\t server_client_create(int);\nint\t server_client_open(struct client *, char **);\nvoid\t server_client_unref(struct client *);\nvoid\t server_client_lost(struct client *);\nvoid\t server_client_detach(struct client *, enum msgtype);\nvoid\t server_client_loop(void);\nvoid\t server_client_push_stdout(struct client *);\nvoid\t server_client_push_stderr(struct client *);\n\n/* server-fn.c */\nvoid\t server_fill_environ(struct session *, struct environ *);\nvoid\t server_redraw_client(struct client *);\nvoid\t server_status_client(struct client *);\nvoid\t server_redraw_session(struct session *);\nvoid\t server_redraw_session_group(struct session *);\nvoid\t server_status_session(struct session *);\nvoid\t server_status_session_group(struct session *);\nvoid\t server_redraw_window(struct window *);\nvoid\t server_redraw_window_borders(struct window *);\nvoid\t server_status_window(struct window *);\nvoid\t server_lock(void);\nvoid\t server_lock_session(struct session *);\nvoid\t server_lock_client(struct client *);\nvoid\t server_kill_window(struct window *);\nint\t server_link_window(struct session *,\n\t     struct winlink *, struct session *, int, int, int, char **);\nvoid\t server_unlink_window(struct session *, struct winlink *);\nvoid\t server_destroy_pane(struct window_pane *, int);\nvoid\t server_destroy_session_group(struct session *);\nvoid\t server_destroy_session(struct session *);\nvoid\t server_check_unattached(void);\nvoid\t server_set_identify(struct client *);\nvoid\t server_clear_identify(struct client *);\nint\t server_set_stdin_callback(struct client *, void (*)(struct client *,\n\t     int, void *), void *, char **);\nvoid\t server_unzoom_window(struct window *);\n\n/* status.c */\nvoid\t status_timer_start(struct client *);\nvoid\t status_timer_start_all(void);\nint\t status_at_line(struct client *);\nstruct window *status_get_window_at(struct client *, u_int);\nint\t status_redraw(struct client *);\nvoid printflike(2, 3) status_message_set(struct client *, const char *, ...);\nvoid\t status_message_clear(struct client *);\nint\t status_message_redraw(struct client *);\nvoid\t status_prompt_set(struct client *, const char *, const char *,\n\t     int (*)(void *, const char *), void (*)(void *), void *, int);\nvoid\t status_prompt_clear(struct client *);\nint\t status_prompt_redraw(struct client *);\nvoid\t status_prompt_key(struct client *, key_code);\nvoid\t status_prompt_update(struct client *, const char *, const char *);\nvoid\t status_prompt_load_history(void);\nvoid\t status_prompt_save_history(void);\n\n/* resize.c */\nvoid\t recalculate_sizes(void);\n\n/* input.c */\nvoid\t input_init(struct window_pane *);\nvoid\t input_free(struct window_pane *);\nvoid\t input_reset(struct window_pane *, int);\nstruct evbuffer *input_pending(struct window_pane *);\nvoid\t input_parse(struct window_pane *);\n\n/* input-key.c */\nvoid\t input_key(struct window_pane *, key_code, struct mouse_event *);\n\n/* xterm-keys.c */\nchar\t*xterm_keys_lookup(key_code);\nint\t xterm_keys_find(const char *, size_t, size_t *, key_code *);\n\n/* colour.c */\nint\t colour_find_rgb(u_char, u_char, u_char);\nvoid\t colour_set_fg(struct grid_cell *, int);\nvoid\t colour_set_bg(struct grid_cell *, int);\nconst char *colour_tostring(int);\nint\t colour_fromstring(const char *);\nu_char\t colour_256to16(u_char);\n\n/* attributes.c */\nconst char *attributes_tostring(u_char);\nint\t attributes_fromstring(const char *);\n\n/* grid.c */\nextern const struct grid_cell grid_default_cell;\nstruct grid *grid_create(u_int, u_int, u_int);\nvoid\t grid_destroy(struct grid *);\nint\t grid_compare(struct grid *, struct grid *);\nvoid\t grid_collect_history(struct grid *);\nvoid\t grid_scroll_history(struct grid *);\nvoid\t grid_scroll_history_region(struct grid *, u_int, u_int);\nvoid\t grid_clear_history(struct grid *);\nvoid\t grid_expand_line(struct grid *, u_int, u_int);\nconst struct grid_line *grid_peek_line(struct grid *, u_int);\nvoid\t grid_get_cell(struct grid *, u_int, u_int, struct grid_cell *);\nvoid\t grid_set_cell(struct grid *, u_int, u_int, const struct grid_cell *);\nvoid\t grid_clear(struct grid *, u_int, u_int, u_int, u_int);\nvoid\t grid_clear_lines(struct grid *, u_int, u_int);\nvoid\t grid_move_lines(struct grid *, u_int, u_int, u_int);\nvoid\t grid_move_cells(struct grid *, u_int, u_int, u_int, u_int);\nchar\t*grid_string_cells(struct grid *, u_int, u_int, u_int,\n\t     struct grid_cell **, int, int, int);\nvoid\t grid_duplicate_lines(struct grid *, u_int, struct grid *, u_int,\n\t     u_int);\nu_int\t grid_reflow(struct grid *, struct grid *, u_int);\n\n/* grid-view.c */\nvoid\t grid_view_get_cell(struct grid *, u_int, u_int, struct grid_cell *);\nvoid\t grid_view_set_cell(struct grid *, u_int, u_int,\n\t     const struct grid_cell *);\nvoid\t grid_view_clear_history(struct grid *);\nvoid\t grid_view_clear(struct grid *, u_int, u_int, u_int, u_int);\nvoid\t grid_view_scroll_region_up(struct grid *, u_int, u_int);\nvoid\t grid_view_scroll_region_down(struct grid *, u_int, u_int);\nvoid\t grid_view_insert_lines(struct grid *, u_int, u_int);\nvoid\t grid_view_insert_lines_region(struct grid *, u_int, u_int, u_int);\nvoid\t grid_view_delete_lines(struct grid *, u_int, u_int);\nvoid\t grid_view_delete_lines_region(struct grid *, u_int, u_int, u_int);\nvoid\t grid_view_insert_cells(struct grid *, u_int, u_int, u_int);\nvoid\t grid_view_delete_cells(struct grid *, u_int, u_int, u_int);\nchar\t*grid_view_string_cells(struct grid *, u_int, u_int, u_int);\n\n/* screen-write.c */\nvoid\t screen_write_start(struct screen_write_ctx *, struct window_pane *,\n\t     struct screen *);\nvoid\t screen_write_stop(struct screen_write_ctx *);\nvoid\t screen_write_reset(struct screen_write_ctx *);\nsize_t printflike(1, 2) screen_write_cstrlen(const char *, ...);\nvoid printflike(4, 5) screen_write_cnputs(struct screen_write_ctx *,\n\t     ssize_t, struct grid_cell *, const char *, ...);\nsize_t printflike(1, 2) screen_write_strlen(const char *, ...);\nvoid printflike(3, 4) screen_write_puts(struct screen_write_ctx *,\n\t     struct grid_cell *, const char *, ...);\nvoid printflike(4, 5) screen_write_nputs(struct screen_write_ctx *,\n\t     ssize_t, struct grid_cell *, const char *, ...);\nvoid\t screen_write_vnputs(struct screen_write_ctx *, ssize_t,\n\t     struct grid_cell *, const char *, va_list);\nvoid\t screen_write_putc(struct screen_write_ctx *, struct grid_cell *,\n\t     u_char);\nvoid\t screen_write_copy(struct screen_write_ctx *, struct screen *, u_int,\n\t     u_int, u_int, u_int);\nvoid\t screen_write_backspace(struct screen_write_ctx *);\nvoid\t screen_write_mode_set(struct screen_write_ctx *, int);\nvoid\t screen_write_mode_clear(struct screen_write_ctx *, int);\nvoid\t screen_write_cursorup(struct screen_write_ctx *, u_int);\nvoid\t screen_write_cursordown(struct screen_write_ctx *, u_int);\nvoid\t screen_write_cursorright(struct screen_write_ctx *, u_int);\nvoid\t screen_write_cursorleft(struct screen_write_ctx *, u_int);\nvoid\t screen_write_alignmenttest(struct screen_write_ctx *);\nvoid\t screen_write_insertcharacter(struct screen_write_ctx *, u_int);\nvoid\t screen_write_deletecharacter(struct screen_write_ctx *, u_int);\nvoid\t screen_write_clearcharacter(struct screen_write_ctx *, u_int);\nvoid\t screen_write_insertline(struct screen_write_ctx *, u_int);\nvoid\t screen_write_deleteline(struct screen_write_ctx *, u_int);\nvoid\t screen_write_clearline(struct screen_write_ctx *);\nvoid\t screen_write_clearendofline(struct screen_write_ctx *);\nvoid\t screen_write_clearstartofline(struct screen_write_ctx *);\nvoid\t screen_write_cursormove(struct screen_write_ctx *, u_int, u_int);\nvoid\t screen_write_reverseindex(struct screen_write_ctx *);\nvoid\t screen_write_scrollregion(struct screen_write_ctx *, u_int, u_int);\nvoid\t screen_write_linefeed(struct screen_write_ctx *, int);\nvoid\t screen_write_carriagereturn(struct screen_write_ctx *);\nvoid\t screen_write_clearendofscreen(struct screen_write_ctx *);\nvoid\t screen_write_clearstartofscreen(struct screen_write_ctx *);\nvoid\t screen_write_clearscreen(struct screen_write_ctx *);\nvoid\t screen_write_clearhistory(struct screen_write_ctx *);\nvoid\t screen_write_cell(struct screen_write_ctx *, const struct grid_cell *);\nvoid\t screen_write_setselection(struct screen_write_ctx *, u_char *, u_int);\nvoid\t screen_write_rawstring(struct screen_write_ctx *, u_char *, u_int);\n\n/* screen-redraw.c */\nvoid\t screen_redraw_screen(struct client *, int, int, int);\nvoid\t screen_redraw_pane(struct client *, struct window_pane *);\n\n/* screen.c */\nvoid\t screen_init(struct screen *, u_int, u_int, u_int);\nvoid\t screen_reinit(struct screen *);\nvoid\t screen_free(struct screen *);\nvoid\t screen_reset_tabs(struct screen *);\nvoid\t screen_set_cursor_style(struct screen *, u_int);\nvoid\t screen_set_cursor_colour(struct screen *, const char *);\nvoid\t screen_set_title(struct screen *, const char *);\nvoid\t screen_resize(struct screen *, u_int, u_int, int);\nvoid\t screen_set_selection(struct screen *,\n\t     u_int, u_int, u_int, u_int, u_int, struct grid_cell *);\nvoid\t screen_clear_selection(struct screen *);\nint\t screen_check_selection(struct screen *, u_int, u_int);\nvoid\t screen_reflow(struct screen *, u_int);\n\n/* window.c */\nextern struct windows windows;\nextern struct window_pane_tree all_window_panes;\nint\t\t window_cmp(struct window *, struct window *);\nRB_PROTOTYPE(windows, window, entry, window_cmp);\nint\t\t winlink_cmp(struct winlink *, struct winlink *);\nRB_PROTOTYPE(winlinks, winlink, entry, winlink_cmp);\nint\t\t window_pane_cmp(struct window_pane *, struct window_pane *);\nRB_PROTOTYPE(window_pane_tree, window_pane, tree_entry, window_pane_cmp);\nstruct winlink\t*winlink_find_by_index(struct winlinks *, int);\nstruct winlink\t*winlink_find_by_window(struct winlinks *, struct window *);\nstruct winlink\t*winlink_find_by_window_id(struct winlinks *, u_int);\nint\t\t winlink_next_index(struct winlinks *, int);\nu_int\t\t winlink_count(struct winlinks *);\nstruct winlink\t*winlink_add(struct winlinks *, int);\nvoid\t\t winlink_set_window(struct winlink *, struct window *);\nvoid\t\t winlink_remove(struct winlinks *, struct winlink *);\nstruct winlink\t*winlink_next(struct winlink *);\nstruct winlink\t*winlink_previous(struct winlink *);\nstruct winlink\t*winlink_next_by_number(struct winlink *, struct session *,\n\t\t     int);\nstruct winlink\t*winlink_previous_by_number(struct winlink *, struct session *,\n\t\t     int);\nvoid\t\t winlink_stack_push(struct winlink_stack *, struct winlink *);\nvoid\t\t winlink_stack_remove(struct winlink_stack *, struct winlink *);\nstruct window\t*window_find_by_id_str(const char *);\nstruct window\t*window_find_by_id(u_int);\nvoid\t\t window_update_activity(struct window *);\nstruct window\t*window_create1(u_int, u_int);\nstruct window\t*window_create(const char *, int, char **, const char *,\n\t\t     const char *, const char *, struct environ *,\n\t\t     struct termios *, u_int, u_int, u_int, char **);\nvoid\t\t window_destroy(struct window *);\nstruct window_pane *window_get_active_at(struct window *, u_int, u_int);\nstruct window_pane *window_find_string(struct window *, const char *);\nint\t\t window_has_pane(struct window *, struct window_pane *);\nint\t\t window_set_active_pane(struct window *, struct window_pane *);\nvoid\t\t window_redraw_active_switch(struct window *,\n\t\t     struct window_pane *);\nstruct window_pane *window_add_pane(struct window *, u_int);\nvoid\t\t window_resize(struct window *, u_int, u_int);\nint\t\t window_zoom(struct window_pane *);\nint\t\t window_unzoom(struct window *);\nvoid\t\t window_lost_pane(struct window *, struct window_pane *);\nvoid\t\t window_remove_pane(struct window *, struct window_pane *);\nstruct window_pane *window_pane_at_index(struct window *, u_int);\nstruct window_pane *window_pane_next_by_number(struct window *,\n\t\t\tstruct window_pane *, u_int);\nstruct window_pane *window_pane_previous_by_number(struct window *,\n\t\t\tstruct window_pane *, u_int);\nint\t\t window_pane_index(struct window_pane *, u_int *);\nu_int\t\t window_count_panes(struct window *);\nvoid\t\t window_destroy_panes(struct window *);\nstruct window_pane *window_pane_find_by_id_str(const char *);\nstruct window_pane *window_pane_find_by_id(u_int);\nstruct window_pane *window_pane_create(struct window *, u_int, u_int, u_int);\nvoid\t\t window_pane_destroy(struct window_pane *);\nint\t\t window_pane_spawn(struct window_pane *, int, char **,\n\t\t     const char *, const char *, const char *, struct environ *,\n\t\t     struct termios *, char **);\nvoid\t\t window_pane_resize(struct window_pane *, u_int, u_int);\nvoid\t\t window_pane_alternate_on(struct window_pane *,\n\t\t     struct grid_cell *, int);\nvoid\t\t window_pane_alternate_off(struct window_pane *,\n\t\t     struct grid_cell *, int);\nint\t\t window_pane_set_mode(struct window_pane *,\n\t\t     const struct window_mode *);\nvoid\t\t window_pane_reset_mode(struct window_pane *);\nvoid\t\t window_pane_key(struct window_pane *, struct client *,\n\t\t     struct session *, key_code, struct mouse_event *);\nint\t\t window_pane_visible(struct window_pane *);\nchar\t\t*window_pane_search(struct window_pane *, const char *,\n\t\t     u_int *);\nchar\t\t*window_printable_flags(struct session *, struct winlink *);\nstruct window_pane *window_pane_find_up(struct window_pane *);\nstruct window_pane *window_pane_find_down(struct window_pane *);\nstruct window_pane *window_pane_find_left(struct window_pane *);\nstruct window_pane *window_pane_find_right(struct window_pane *);\nvoid\t\t window_set_name(struct window *, const char *);\nvoid\t\t window_remove_ref(struct window *);\nvoid\t\t winlink_clear_flags(struct winlink *);\nint\t\t winlink_shuffle_up(struct session *, struct winlink *);\n\n/* layout.c */\nu_int\t\t layout_count_cells(struct layout_cell *);\nstruct layout_cell *layout_create_cell(struct layout_cell *);\nvoid\t\t layout_free_cell(struct layout_cell *);\nvoid\t\t layout_print_cell(struct layout_cell *, const char *, u_int);\nvoid\t\t layout_destroy_cell(struct layout_cell *,\n\t\t     struct layout_cell **);\nvoid\t\t layout_set_size(struct layout_cell *, u_int, u_int, u_int,\n\t\t     u_int);\nvoid\t\t layout_make_leaf(struct layout_cell *, struct window_pane *);\nvoid\t\t layout_make_node(struct layout_cell *, enum layout_type);\nvoid\t\t layout_fix_offsets(struct layout_cell *);\nvoid\t\t layout_fix_panes(struct window *, u_int, u_int);\nu_int\t\t layout_resize_check(struct layout_cell *, enum layout_type);\nvoid\t\t layout_resize_adjust(struct layout_cell *, enum layout_type,\n\t\t     int);\nvoid\t\t layout_init(struct window *, struct window_pane *);\nvoid\t\t layout_free(struct window *);\nvoid\t\t layout_resize(struct window *, u_int, u_int);\nvoid\t\t layout_resize_pane(struct window_pane *, enum layout_type,\n\t\t     int);\nvoid\t\t layout_resize_pane_to(struct window_pane *, enum layout_type,\n\t\t     u_int);\nvoid\t\t layout_assign_pane(struct layout_cell *, struct window_pane *);\nstruct layout_cell *layout_split_pane(struct window_pane *, enum layout_type,\n\t\t     int, int);\nvoid\t\t layout_close_pane(struct window_pane *);\n\n/* layout-custom.c */\nchar\t\t*layout_dump(struct layout_cell *);\nint\t\t layout_parse(struct window *, const char *);\n\n/* layout-set.c */\nint\t\t layout_set_lookup(const char *);\nu_int\t\t layout_set_select(struct window *, u_int);\nu_int\t\t layout_set_next(struct window *);\nu_int\t\t layout_set_previous(struct window *);\n\n/* window-clock.c */\nextern const struct window_mode window_clock_mode;\nextern const char window_clock_table[14][5][5];\n\n/* window-copy.c */\nextern const struct window_mode window_copy_mode;\nvoid\t\t window_copy_init_from_pane(struct window_pane *, int);\nvoid\t\t window_copy_init_for_output(struct window_pane *);\nvoid printflike(2, 3) window_copy_add(struct window_pane *, const char *, ...);\nvoid\t\t window_copy_vadd(struct window_pane *, const char *, va_list);\nvoid\t\t window_copy_pageup(struct window_pane *);\nvoid\t\t window_copy_start_drag(struct client *, struct mouse_event *);\nint\t\t window_copy_scroll_position(struct window_pane *);\n\n/* window-choose.c */\nextern const struct window_mode window_choose_mode;\nvoid\t\t window_choose_add(struct window_pane *,\n\t\t\t struct window_choose_data *);\nvoid\t\t window_choose_ready(struct window_pane *,\n\t\t     u_int, void (*)(struct window_choose_data *));\nstruct window_choose_data\t*window_choose_data_create (int,\n\t\t     struct client *, struct session *);\nvoid\twindow_choose_data_free(struct window_choose_data *);\nvoid\twindow_choose_data_run(struct window_choose_data *);\nstruct window_choose_data\t*window_choose_add_window(struct window_pane *,\n\t\t\tstruct client *, struct session *, struct winlink *,\n\t\t\tconst char *, const char *, u_int);\nstruct window_choose_data\t*window_choose_add_session(struct window_pane *,\n\t\t\tstruct client *, struct session *, const char *,\n\t\t\tconst char *, u_int);\nvoid\twindow_choose_expand_all(struct window_pane *);\nvoid\twindow_choose_collapse_all(struct window_pane *);\nvoid\twindow_choose_set_current(struct window_pane *, u_int);\n\n/* names.c */\nvoid\t check_window_name(struct window *);\nchar\t*default_window_name(struct window *);\nchar\t*format_window_name(struct window *);\nchar\t*parse_window_name(const char *);\n\n/* signal.c */\nvoid\tset_signals(void(*)(int, short, void *), void *);\nvoid\tclear_signals(int);\n\n/* control.c */\nvoid\tcontrol_callback(struct client *, int, void *);\nvoid printflike(2, 3) control_write(struct client *, const char *, ...);\nvoid\tcontrol_write_buffer(struct client *, struct evbuffer *);\n\n/* control-notify.c */\nvoid\tcontrol_notify_input(struct client *, struct window_pane *,\n\t    struct evbuffer *);\nvoid\tcontrol_notify_window_layout_changed(struct window *);\nvoid\tcontrol_notify_window_unlinked(struct session *, struct window *);\nvoid\tcontrol_notify_window_linked(struct session *, struct window *);\nvoid\tcontrol_notify_window_renamed(struct window *);\nvoid\tcontrol_notify_attached_session_changed(struct client *);\nvoid\tcontrol_notify_session_renamed(struct session *);\nvoid\tcontrol_notify_session_created(struct session *);\nvoid\tcontrol_notify_session_close(struct session *);\n\n/* session.c */\nextern struct sessions sessions;\nextern struct session_groups session_groups;\nint\tsession_cmp(struct session *, struct session *);\nRB_PROTOTYPE(sessions, session, entry, session_cmp);\nint\t\t session_alive(struct session *);\nstruct session\t*session_find(const char *);\nstruct session\t*session_find_by_id_str(const char *);\nstruct session\t*session_find_by_id(u_int);\nstruct session\t*session_create(const char *, int, char **, const char *,\n\t\t     const char *, struct environ *, struct termios *, int,\n\t\t     u_int, u_int, char **);\nvoid\t\t session_destroy(struct session *);\nvoid\t\t session_unref(struct session *);\nint\t\t session_check_name(const char *);\nvoid\t\t session_update_activity(struct session *, struct timeval *);\nstruct session\t*session_next_session(struct session *);\nstruct session\t*session_previous_session(struct session *);\nstruct winlink\t*session_new(struct session *, const char *, int, char **,\n\t\t     const char *, const char *, int, char **);\nstruct winlink\t*session_attach(struct session *, struct window *, int,\n\t\t     char **);\nint\t\t session_detach(struct session *, struct winlink *);\nint\t\t session_has(struct session *, struct window *);\nint\t\t session_is_linked(struct session *, struct window *);\nint\t\t session_next(struct session *, int);\nint\t\t session_previous(struct session *, int);\nint\t\t session_select(struct session *, int);\nint\t\t session_last(struct session *);\nint\t\t session_set_current(struct session *, struct winlink *);\nstruct session_group *session_group_find(struct session *);\nu_int\t\t session_group_index(struct session_group *);\nvoid\t\t session_group_add(struct session *, struct session *);\nvoid\t\t session_group_remove(struct session *);\nu_int\t\t session_group_count(struct session_group *);\nvoid\t\t session_group_synchronize_to(struct session *);\nvoid\t\t session_group_synchronize_from(struct session *);\nvoid\t\t session_group_synchronize1(struct session *, struct session *);\nvoid\t\t session_renumber_windows(struct session *);\n\n/* utf8.c */\nvoid\t\t utf8_set(struct utf8_data *, u_char);\nvoid\t\t utf8_copy(struct utf8_data *, const struct utf8_data *);\nenum utf8_state\t utf8_open(struct utf8_data *, u_char);\nenum utf8_state\t utf8_append(struct utf8_data *, u_char);\nenum utf8_state\t utf8_combine(const struct utf8_data *, wchar_t *);\nenum utf8_state\t utf8_split(wchar_t, struct utf8_data *);\nint\t\t utf8_strvis(char *, const char *, size_t, int);\nchar\t\t*utf8_sanitize(const char *);\nstruct utf8_data *utf8_fromcstr(const char *);\nchar\t\t*utf8_tocstr(struct utf8_data *);\nu_int\t\t utf8_cstrwidth(const char *);\nchar\t\t*utf8_rtrimcstr(const char *, u_int);\nchar\t\t*utf8_trimcstr(const char *, u_int);\nchar\t\t*utf8_padcstr(const char *, u_int);\n\n/* osdep-*.c */\nchar\t\t*osdep_get_name(int, char *);\nchar\t\t*osdep_get_cwd(int);\nstruct event_base *osdep_event_init(void);\n\n/* log.c */\nvoid\tlog_add_level(void);\nint\tlog_get_level(void);\nvoid\tlog_open_fp(FILE *f);\nvoid\tlog_open(const char *);\nvoid\tlog_close(void);\n#define LOG_ERROR\t0\n#define LOG_INFO\t1\n#define LOG_DEBUG\t2\n#define log_debug(...) log_emit(LOG_DEBUG+1, __VA_ARGS__)\nvoid printflike(2, 3) log_emit(int level, const char *, ...);\n__dead void printflike(1, 2) fatal(const char *, ...);\n__dead void printflike(1, 2) fatalx(const char *, ...);\n\n/* style.c */\nint\t\t style_parse(const struct grid_cell *,\n\t\t     struct grid_cell *, const char *);\nconst char\t*style_tostring(struct grid_cell *);\nvoid\t\t style_update_new(struct options *, const char *, const char *);\nvoid\t\t style_update_old(struct options *, const char *,\n\t\t     struct grid_cell *);\nvoid\t\t style_apply(struct grid_cell *, struct options *,\n\t\t     const char *);\nvoid\t\t style_apply_update(struct grid_cell *, struct options *,\n\t\t     const char *);\nint\t\t style_equal(const struct grid_cell *,\n\t\t     const struct grid_cell *);\n\n#endif /* TMUX_H */\n"
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        },
        {
          "name": "tty-acs.c",
          "type": "blob",
          "size": 3.2578125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2010 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n\n#include \"tmux.h\"\n\nint\ttty_acs_cmp(const void *, const void *);\n\n/* Table mapping ACS entries to UTF-8. */\nstruct tty_acs_entry {\n\tu_char\t \t key;\n\tconst char\t*string;\n};\nconst struct tty_acs_entry tty_acs_table[] = {\n\t{ '+', \"\\342\\206\\222\" },\t/* arrow pointing right */\n\t{ ',', \"\\342\\206\\220\" },\t/* arrow pointing left */\n\t{ '-', \"\\342\\206\\221\" },\t/* arrow pointing up */\n\t{ '.', \"\\342\\206\\223\" },\t/* arrow pointing down */\n\t{ '0', \"\\342\\226\\256\" },\t/* solid square block */\n\t{ '`', \"\\342\\227\\206\" },\t/* diamond */\n\t{ 'a', \"\\342\\226\\222\" },\t/* checker board (stipple) */\n\t{ 'f', \"\\302\\260\" },\t\t/* degree symbol */\n\t{ 'g', \"\\302\\261\" },\t\t/* plus/minus */\n\t{ 'h', \"\\342\\226\\222\" },\t/* board of squares */\n\t{ 'i', \"\\342\\230\\203\" },\t/* lantern symbol */\n\t{ 'j', \"\\342\\224\\230\" },\t/* lower right corner */\n\t{ 'k', \"\\342\\224\\220\" },\t/* upper right corner */\n\t{ 'l', \"\\342\\224\\214\" },\t/* upper left corner */\n\t{ 'm', \"\\342\\224\\224\" },\t/* lower left corner */\n\t{ 'n', \"\\342\\224\\274\" },\t/* large plus or crossover */\n\t{ 'o', \"\\342\\216\\272\" },\t/* scan line 1 */\n\t{ 'p', \"\\342\\216\\273\" },\t/* scan line 3 */\n\t{ 'q', \"\\342\\224\\200\" },\t/* horizontal line */\n\t{ 'r', \"\\342\\216\\274\" },\t/* scan line 7 */\n\t{ 's', \"\\342\\216\\275\" },\t/* scan line 9 */\n\t{ 't', \"\\342\\224\\234\" },\t/* tee pointing right */\n\t{ 'u', \"\\342\\224\\244\" },\t/* tee pointing left */\n\t{ 'v', \"\\342\\224\\264\" },\t/* tee pointing up */\n\t{ 'w', \"\\342\\224\\254\" },\t/* tee pointing down */\n\t{ 'x', \"\\342\\224\\202\" },\t/* vertical line */\n\t{ 'y', \"\\342\\211\\244\" },\t/* less-than-or-equal-to */\n\t{ 'z', \"\\342\\211\\245\" },\t/* greater-than-or-equal-to */\n\t{ '{', \"\\317\\200\" },   \t\t/* greek pi */\n\t{ '|', \"\\342\\211\\240\" },\t/* not-equal */\n\t{ '}', \"\\302\\243\" },\t\t/* UK pound sign */\n\t{ '~', \"\\302\\267\" }\t\t/* bullet */\n};\n\nint\ntty_acs_cmp(const void *key, const void *value)\n{\n\tconst struct tty_acs_entry\t*entry = value;\n\tu_char\t\t\t\t ch;\n\n\tch = *(u_char *) key;\n\treturn (ch - entry->key);\n}\n\n/* Retrieve ACS to output as a string. */\nconst char *\ntty_acs_get(struct tty *tty, u_char ch)\n{\n\tstruct tty_acs_entry *entry;\n\n\t/* If not a UTF-8 terminal, use the ACS set. */\n\tif (tty != NULL && !(tty->flags & TTY_UTF8)) {\n\t\tif (tty->term->acs[ch][0] == '\\0')\n\t\t\treturn (NULL);\n\t\treturn (&tty->term->acs[ch][0]);\n\t}\n\n\t/* Otherwise look up the UTF-8 translation. */\n\tentry = bsearch(&ch,\n\t    tty_acs_table, nitems(tty_acs_table), sizeof tty_acs_table[0],\n\t    tty_acs_cmp);\n\tif (entry == NULL)\n\t\treturn (NULL);\n\treturn (entry->string);\n}\n"
        },
        {
          "name": "tty-keys.c",
          "type": "blob",
          "size": 20.8701171875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/time.h>\n\n#include <limits.h>\n#include <stdlib.h>\n#include <string.h>\n#include <termios.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\n/*\n * Handle keys input from the outside terminal. tty_default_*_keys[] are a base\n * table of supported keys which are looked up in terminfo(5) and translated\n * into a ternary tree.\n */\n\nvoid\t\ttty_keys_add1(struct tty_key **, const char *, key_code);\nvoid\t\ttty_keys_add(struct tty *, const char *, key_code);\nvoid\t\ttty_keys_free1(struct tty_key *);\nstruct tty_key *tty_keys_find1(struct tty_key *, const char *, size_t,\n\t\t    size_t *);\nstruct tty_key *tty_keys_find(struct tty *, const char *, size_t, size_t *);\nvoid\t\ttty_keys_callback(int, short, void *);\nint\t\ttty_keys_mouse(struct tty *, const char *, size_t, size_t *);\n\n/* Default raw keys. */\nstruct tty_default_key_raw {\n\tconst char\t       *string;\n\tkey_code\t \tkey;\n};\nconst struct tty_default_key_raw tty_default_raw_keys[] = {\n\t/*\n\t * Numeric keypad. Just use the vt100 escape sequences here and always\n\t * put the terminal into keypad_xmit mode. Translation of numbers\n\t * mode/applications mode is done in input-keys.c.\n\t */\n\t{ \"\\033Oo\", KEYC_KP_SLASH },\n\t{ \"\\033Oj\", KEYC_KP_STAR },\n\t{ \"\\033Om\", KEYC_KP_MINUS },\n\t{ \"\\033Ow\", KEYC_KP_SEVEN },\n\t{ \"\\033Ox\", KEYC_KP_EIGHT },\n\t{ \"\\033Oy\", KEYC_KP_NINE },\n\t{ \"\\033Ok\", KEYC_KP_PLUS },\n\t{ \"\\033Ot\", KEYC_KP_FOUR },\n\t{ \"\\033Ou\", KEYC_KP_FIVE },\n\t{ \"\\033Ov\", KEYC_KP_SIX },\n\t{ \"\\033Oq\", KEYC_KP_ONE },\n\t{ \"\\033Or\", KEYC_KP_TWO },\n\t{ \"\\033Os\", KEYC_KP_THREE },\n\t{ \"\\033OM\", KEYC_KP_ENTER },\n\t{ \"\\033Op\", KEYC_KP_ZERO },\n\t{ \"\\033On\", KEYC_KP_PERIOD },\n\n\t/* Arrow keys. */\n\t{ \"\\033OA\", KEYC_UP },\n\t{ \"\\033OB\", KEYC_DOWN },\n\t{ \"\\033OC\", KEYC_RIGHT },\n\t{ \"\\033OD\", KEYC_LEFT },\n\n\t{ \"\\033[A\", KEYC_UP },\n\t{ \"\\033[B\", KEYC_DOWN },\n\t{ \"\\033[C\", KEYC_RIGHT },\n\t{ \"\\033[D\", KEYC_LEFT },\n\n\t/* Other (xterm) \"cursor\" keys. */\n\t{ \"\\033OH\", KEYC_HOME },\n\t{ \"\\033OF\", KEYC_END },\n\n\t{ \"\\033[H\", KEYC_HOME },\n\t{ \"\\033[F\", KEYC_END },\n\n\t/* rxvt-style arrow + modifier keys. */\n\t{ \"\\033Oa\", KEYC_UP|KEYC_CTRL },\n\t{ \"\\033Ob\", KEYC_DOWN|KEYC_CTRL },\n\t{ \"\\033Oc\", KEYC_RIGHT|KEYC_CTRL },\n\t{ \"\\033Od\", KEYC_LEFT|KEYC_CTRL },\n\n\t{ \"\\033[a\", KEYC_UP|KEYC_SHIFT },\n\t{ \"\\033[b\", KEYC_DOWN|KEYC_SHIFT },\n\t{ \"\\033[c\", KEYC_RIGHT|KEYC_SHIFT },\n\t{ \"\\033[d\", KEYC_LEFT|KEYC_SHIFT },\n\n\t/* rxvt-style function + modifier keys (C = ^, S = $, C-S = @). */\n\t{ \"\\033[11^\", KEYC_F1|KEYC_CTRL },\n\t{ \"\\033[12^\", KEYC_F2|KEYC_CTRL },\n\t{ \"\\033[13^\", KEYC_F3|KEYC_CTRL },\n\t{ \"\\033[14^\", KEYC_F4|KEYC_CTRL },\n\t{ \"\\033[15^\", KEYC_F5|KEYC_CTRL },\n\t{ \"\\033[17^\", KEYC_F6|KEYC_CTRL },\n\t{ \"\\033[18^\", KEYC_F7|KEYC_CTRL },\n\t{ \"\\033[19^\", KEYC_F8|KEYC_CTRL },\n\t{ \"\\033[20^\", KEYC_F9|KEYC_CTRL },\n\t{ \"\\033[21^\", KEYC_F10|KEYC_CTRL },\n\t{ \"\\033[23^\", KEYC_F11|KEYC_CTRL },\n\t{ \"\\033[24^\", KEYC_F12|KEYC_CTRL },\n\t{ \"\\033[2^\", KEYC_IC|KEYC_CTRL },\n\t{ \"\\033[3^\", KEYC_DC|KEYC_CTRL },\n\t{ \"\\033[7^\", KEYC_HOME|KEYC_CTRL },\n\t{ \"\\033[8^\", KEYC_END|KEYC_CTRL },\n\t{ \"\\033[6^\", KEYC_NPAGE|KEYC_CTRL },\n\t{ \"\\033[5^\", KEYC_PPAGE|KEYC_CTRL },\n\n\t{ \"\\033[11$\", KEYC_F1|KEYC_SHIFT },\n\t{ \"\\033[12$\", KEYC_F2|KEYC_SHIFT },\n\t{ \"\\033[13$\", KEYC_F3|KEYC_SHIFT },\n\t{ \"\\033[14$\", KEYC_F4|KEYC_SHIFT },\n\t{ \"\\033[15$\", KEYC_F5|KEYC_SHIFT },\n\t{ \"\\033[17$\", KEYC_F6|KEYC_SHIFT },\n\t{ \"\\033[18$\", KEYC_F7|KEYC_SHIFT },\n\t{ \"\\033[19$\", KEYC_F8|KEYC_SHIFT },\n\t{ \"\\033[20$\", KEYC_F9|KEYC_SHIFT },\n\t{ \"\\033[21$\", KEYC_F10|KEYC_SHIFT },\n\t{ \"\\033[23$\", KEYC_F11|KEYC_SHIFT },\n\t{ \"\\033[24$\", KEYC_F12|KEYC_SHIFT },\n\t{ \"\\033[2$\", KEYC_IC|KEYC_SHIFT },\n\t{ \"\\033[3$\", KEYC_DC|KEYC_SHIFT },\n\t{ \"\\033[7$\", KEYC_HOME|KEYC_SHIFT },\n\t{ \"\\033[8$\", KEYC_END|KEYC_SHIFT },\n\t{ \"\\033[6$\", KEYC_NPAGE|KEYC_SHIFT },\n\t{ \"\\033[5$\", KEYC_PPAGE|KEYC_SHIFT },\n\n\t{ \"\\033[11@\", KEYC_F1|KEYC_CTRL|KEYC_SHIFT },\n\t{ \"\\033[12@\", KEYC_F2|KEYC_CTRL|KEYC_SHIFT },\n\t{ \"\\033[13@\", KEYC_F3|KEYC_CTRL|KEYC_SHIFT },\n\t{ \"\\033[14@\", KEYC_F4|KEYC_CTRL|KEYC_SHIFT },\n\t{ \"\\033[15@\", KEYC_F5|KEYC_CTRL|KEYC_SHIFT },\n\t{ \"\\033[17@\", KEYC_F6|KEYC_CTRL|KEYC_SHIFT },\n\t{ \"\\033[18@\", KEYC_F7|KEYC_CTRL|KEYC_SHIFT },\n\t{ \"\\033[19@\", KEYC_F8|KEYC_CTRL|KEYC_SHIFT },\n\t{ \"\\033[20@\", KEYC_F9|KEYC_CTRL|KEYC_SHIFT },\n\t{ \"\\033[21@\", KEYC_F10|KEYC_CTRL|KEYC_SHIFT },\n\t{ \"\\033[23@\", KEYC_F11|KEYC_CTRL|KEYC_SHIFT },\n\t{ \"\\033[24@\", KEYC_F12|KEYC_CTRL|KEYC_SHIFT },\n\t{ \"\\033[2@\", KEYC_IC|KEYC_CTRL|KEYC_SHIFT },\n\t{ \"\\033[3@\", KEYC_DC|KEYC_CTRL|KEYC_SHIFT },\n\t{ \"\\033[7@\", KEYC_HOME|KEYC_CTRL|KEYC_SHIFT },\n\t{ \"\\033[8@\", KEYC_END|KEYC_CTRL|KEYC_SHIFT },\n\t{ \"\\033[6@\", KEYC_NPAGE|KEYC_CTRL|KEYC_SHIFT },\n\t{ \"\\033[5@\", KEYC_PPAGE|KEYC_CTRL|KEYC_SHIFT },\n\n\t/* Focus tracking. */\n\t{ \"\\033[I\", KEYC_FOCUS_IN },\n\t{ \"\\033[O\", KEYC_FOCUS_OUT },\n};\n\n/* Default terminfo(5) keys. */\nstruct tty_default_key_code {\n\tenum tty_code_code\tcode;\n\tkey_code\t \tkey;\n};\nconst struct tty_default_key_code tty_default_code_keys[] = {\n\t/* Function keys. */\n\t{ TTYC_KF1, KEYC_F1 },\n\t{ TTYC_KF2, KEYC_F2 },\n\t{ TTYC_KF3, KEYC_F3 },\n\t{ TTYC_KF4, KEYC_F4 },\n\t{ TTYC_KF5, KEYC_F5 },\n\t{ TTYC_KF6, KEYC_F6 },\n\t{ TTYC_KF7, KEYC_F7 },\n\t{ TTYC_KF8, KEYC_F8 },\n\t{ TTYC_KF9, KEYC_F9 },\n\t{ TTYC_KF10, KEYC_F10 },\n\t{ TTYC_KF11, KEYC_F11 },\n\t{ TTYC_KF12, KEYC_F12 },\n\n\t{ TTYC_KF13, KEYC_F1|KEYC_SHIFT },\n\t{ TTYC_KF14, KEYC_F2|KEYC_SHIFT },\n\t{ TTYC_KF15, KEYC_F3|KEYC_SHIFT },\n\t{ TTYC_KF16, KEYC_F4|KEYC_SHIFT },\n\t{ TTYC_KF17, KEYC_F5|KEYC_SHIFT },\n\t{ TTYC_KF18, KEYC_F6|KEYC_SHIFT },\n\t{ TTYC_KF19, KEYC_F7|KEYC_SHIFT },\n\t{ TTYC_KF20, KEYC_F8|KEYC_SHIFT },\n\t{ TTYC_KF21, KEYC_F9|KEYC_SHIFT },\n\t{ TTYC_KF22, KEYC_F10|KEYC_SHIFT },\n\t{ TTYC_KF23, KEYC_F11|KEYC_SHIFT },\n\t{ TTYC_KF24, KEYC_F12|KEYC_SHIFT },\n\n\t{ TTYC_KF25, KEYC_F1|KEYC_CTRL },\n\t{ TTYC_KF26, KEYC_F2|KEYC_CTRL },\n\t{ TTYC_KF27, KEYC_F3|KEYC_CTRL },\n\t{ TTYC_KF28, KEYC_F4|KEYC_CTRL },\n\t{ TTYC_KF29, KEYC_F5|KEYC_CTRL },\n\t{ TTYC_KF30, KEYC_F6|KEYC_CTRL },\n\t{ TTYC_KF31, KEYC_F7|KEYC_CTRL },\n\t{ TTYC_KF32, KEYC_F8|KEYC_CTRL },\n\t{ TTYC_KF33, KEYC_F9|KEYC_CTRL },\n\t{ TTYC_KF34, KEYC_F10|KEYC_CTRL },\n\t{ TTYC_KF35, KEYC_F11|KEYC_CTRL },\n\t{ TTYC_KF36, KEYC_F12|KEYC_CTRL },\n\n\t{ TTYC_KF37, KEYC_F1|KEYC_SHIFT|KEYC_CTRL },\n\t{ TTYC_KF38, KEYC_F2|KEYC_SHIFT|KEYC_CTRL },\n\t{ TTYC_KF39, KEYC_F3|KEYC_SHIFT|KEYC_CTRL },\n\t{ TTYC_KF40, KEYC_F4|KEYC_SHIFT|KEYC_CTRL },\n\t{ TTYC_KF41, KEYC_F5|KEYC_SHIFT|KEYC_CTRL },\n\t{ TTYC_KF42, KEYC_F6|KEYC_SHIFT|KEYC_CTRL },\n\t{ TTYC_KF43, KEYC_F7|KEYC_SHIFT|KEYC_CTRL },\n\t{ TTYC_KF44, KEYC_F8|KEYC_SHIFT|KEYC_CTRL },\n\t{ TTYC_KF45, KEYC_F9|KEYC_SHIFT|KEYC_CTRL },\n\t{ TTYC_KF46, KEYC_F10|KEYC_SHIFT|KEYC_CTRL },\n\t{ TTYC_KF47, KEYC_F11|KEYC_SHIFT|KEYC_CTRL },\n\t{ TTYC_KF48, KEYC_F12|KEYC_SHIFT|KEYC_CTRL },\n\n\t{ TTYC_KF49, KEYC_F1|KEYC_ESCAPE },\n\t{ TTYC_KF50, KEYC_F2|KEYC_ESCAPE },\n\t{ TTYC_KF51, KEYC_F3|KEYC_ESCAPE },\n\t{ TTYC_KF52, KEYC_F4|KEYC_ESCAPE },\n\t{ TTYC_KF53, KEYC_F5|KEYC_ESCAPE },\n\t{ TTYC_KF54, KEYC_F6|KEYC_ESCAPE },\n\t{ TTYC_KF55, KEYC_F7|KEYC_ESCAPE },\n\t{ TTYC_KF56, KEYC_F8|KEYC_ESCAPE },\n\t{ TTYC_KF57, KEYC_F9|KEYC_ESCAPE },\n\t{ TTYC_KF58, KEYC_F10|KEYC_ESCAPE },\n\t{ TTYC_KF59, KEYC_F11|KEYC_ESCAPE },\n\t{ TTYC_KF60, KEYC_F12|KEYC_ESCAPE },\n\n\t{ TTYC_KF61, KEYC_F1|KEYC_ESCAPE|KEYC_SHIFT },\n\t{ TTYC_KF62, KEYC_F2|KEYC_ESCAPE|KEYC_SHIFT },\n\t{ TTYC_KF63, KEYC_F3|KEYC_ESCAPE|KEYC_SHIFT },\n\n\t{ TTYC_KICH1, KEYC_IC },\n\t{ TTYC_KDCH1, KEYC_DC },\n\t{ TTYC_KHOME, KEYC_HOME },\n\t{ TTYC_KEND, KEYC_END },\n\t{ TTYC_KNP, KEYC_NPAGE },\n\t{ TTYC_KPP, KEYC_PPAGE },\n\t{ TTYC_KCBT, KEYC_BTAB },\n\n\t/* Arrow keys from terminfo. */\n\t{ TTYC_KCUU1, KEYC_UP },\n\t{ TTYC_KCUD1, KEYC_DOWN },\n\t{ TTYC_KCUB1, KEYC_LEFT },\n\t{ TTYC_KCUF1, KEYC_RIGHT },\n\n\t/* Key and modifier capabilities. */\n\t{ TTYC_KDC2, KEYC_DC|KEYC_SHIFT },\n\t{ TTYC_KDC3, KEYC_DC|KEYC_ESCAPE },\n\t{ TTYC_KDC4, KEYC_DC|KEYC_SHIFT|KEYC_ESCAPE },\n\t{ TTYC_KDC5, KEYC_DC|KEYC_CTRL },\n\t{ TTYC_KDC6, KEYC_DC|KEYC_SHIFT|KEYC_CTRL },\n\t{ TTYC_KDC7, KEYC_DC|KEYC_ESCAPE|KEYC_CTRL },\n\t{ TTYC_KDN2, KEYC_DOWN|KEYC_SHIFT },\n\t{ TTYC_KDN3, KEYC_DOWN|KEYC_ESCAPE },\n\t{ TTYC_KDN4, KEYC_DOWN|KEYC_SHIFT|KEYC_ESCAPE },\n\t{ TTYC_KDN5, KEYC_DOWN|KEYC_CTRL },\n\t{ TTYC_KDN6, KEYC_DOWN|KEYC_SHIFT|KEYC_CTRL },\n\t{ TTYC_KDN7, KEYC_DOWN|KEYC_ESCAPE|KEYC_CTRL },\n\t{ TTYC_KEND2, KEYC_END|KEYC_SHIFT },\n\t{ TTYC_KEND3, KEYC_END|KEYC_ESCAPE },\n\t{ TTYC_KEND4, KEYC_END|KEYC_SHIFT|KEYC_ESCAPE },\n\t{ TTYC_KEND5, KEYC_END|KEYC_CTRL },\n\t{ TTYC_KEND6, KEYC_END|KEYC_SHIFT|KEYC_CTRL },\n\t{ TTYC_KEND7, KEYC_END|KEYC_ESCAPE|KEYC_CTRL },\n\t{ TTYC_KHOM2, KEYC_HOME|KEYC_SHIFT },\n\t{ TTYC_KHOM3, KEYC_HOME|KEYC_ESCAPE },\n\t{ TTYC_KHOM4, KEYC_HOME|KEYC_SHIFT|KEYC_ESCAPE },\n\t{ TTYC_KHOM5, KEYC_HOME|KEYC_CTRL },\n\t{ TTYC_KHOM6, KEYC_HOME|KEYC_SHIFT|KEYC_CTRL },\n\t{ TTYC_KHOM7, KEYC_HOME|KEYC_ESCAPE|KEYC_CTRL },\n\t{ TTYC_KIC2, KEYC_IC|KEYC_SHIFT },\n\t{ TTYC_KIC3, KEYC_IC|KEYC_ESCAPE },\n\t{ TTYC_KIC4, KEYC_IC|KEYC_SHIFT|KEYC_ESCAPE },\n\t{ TTYC_KIC5, KEYC_IC|KEYC_CTRL },\n\t{ TTYC_KIC6, KEYC_IC|KEYC_SHIFT|KEYC_CTRL },\n\t{ TTYC_KIC7, KEYC_IC|KEYC_ESCAPE|KEYC_CTRL },\n\t{ TTYC_KLFT2, KEYC_LEFT|KEYC_SHIFT },\n\t{ TTYC_KLFT3, KEYC_LEFT|KEYC_ESCAPE },\n\t{ TTYC_KLFT4, KEYC_LEFT|KEYC_SHIFT|KEYC_ESCAPE },\n\t{ TTYC_KLFT5, KEYC_LEFT|KEYC_CTRL },\n\t{ TTYC_KLFT6, KEYC_LEFT|KEYC_SHIFT|KEYC_CTRL },\n\t{ TTYC_KLFT7, KEYC_LEFT|KEYC_ESCAPE|KEYC_CTRL },\n\t{ TTYC_KNXT2, KEYC_NPAGE|KEYC_SHIFT },\n\t{ TTYC_KNXT3, KEYC_NPAGE|KEYC_ESCAPE },\n\t{ TTYC_KNXT4, KEYC_NPAGE|KEYC_SHIFT|KEYC_ESCAPE },\n\t{ TTYC_KNXT5, KEYC_NPAGE|KEYC_CTRL },\n\t{ TTYC_KNXT6, KEYC_NPAGE|KEYC_SHIFT|KEYC_CTRL },\n\t{ TTYC_KNXT7, KEYC_NPAGE|KEYC_ESCAPE|KEYC_CTRL },\n\t{ TTYC_KPRV2, KEYC_PPAGE|KEYC_SHIFT },\n\t{ TTYC_KPRV3, KEYC_PPAGE|KEYC_ESCAPE },\n\t{ TTYC_KPRV4, KEYC_PPAGE|KEYC_SHIFT|KEYC_ESCAPE },\n\t{ TTYC_KPRV5, KEYC_PPAGE|KEYC_CTRL },\n\t{ TTYC_KPRV6, KEYC_PPAGE|KEYC_SHIFT|KEYC_CTRL },\n\t{ TTYC_KPRV7, KEYC_PPAGE|KEYC_ESCAPE|KEYC_CTRL },\n\t{ TTYC_KRIT2, KEYC_RIGHT|KEYC_SHIFT },\n\t{ TTYC_KRIT3, KEYC_RIGHT|KEYC_ESCAPE },\n\t{ TTYC_KRIT4, KEYC_RIGHT|KEYC_SHIFT|KEYC_ESCAPE },\n\t{ TTYC_KRIT5, KEYC_RIGHT|KEYC_CTRL },\n\t{ TTYC_KRIT6, KEYC_RIGHT|KEYC_SHIFT|KEYC_CTRL },\n\t{ TTYC_KRIT7, KEYC_RIGHT|KEYC_ESCAPE|KEYC_CTRL },\n\t{ TTYC_KUP2, KEYC_UP|KEYC_SHIFT },\n\t{ TTYC_KUP3, KEYC_UP|KEYC_ESCAPE },\n\t{ TTYC_KUP4, KEYC_UP|KEYC_SHIFT|KEYC_ESCAPE },\n\t{ TTYC_KUP5, KEYC_UP|KEYC_CTRL },\n\t{ TTYC_KUP6, KEYC_UP|KEYC_SHIFT|KEYC_CTRL },\n\t{ TTYC_KUP7, KEYC_UP|KEYC_ESCAPE|KEYC_CTRL },\n};\n\n/* Add key to tree. */\nvoid\ntty_keys_add(struct tty *tty, const char *s, key_code key)\n{\n\tstruct tty_key\t*tk;\n\tsize_t\t\t size;\n\tconst char     \t*keystr;\n\n\tkeystr = key_string_lookup_key(key);\n\tif ((tk = tty_keys_find(tty, s, strlen(s), &size)) == NULL) {\n\t\tlog_debug(\"new key %s: 0x%llx (%s)\", s, key, keystr);\n\t\ttty_keys_add1(&tty->key_tree, s, key);\n\t} else {\n\t\tlog_debug(\"replacing key %s: 0x%llx (%s)\", s, key, keystr);\n\t\ttk->key = key;\n\t}\n}\n\n/* Add next node to the tree. */\nvoid\ntty_keys_add1(struct tty_key **tkp, const char *s, key_code key)\n{\n\tstruct tty_key\t*tk;\n\n\t/* Allocate a tree entry if there isn't one already. */\n\ttk = *tkp;\n\tif (tk == NULL) {\n\t\ttk = *tkp = xcalloc(1, sizeof *tk);\n\t\ttk->ch = *s;\n\t\ttk->key = KEYC_UNKNOWN;\n\t}\n\n\t/* Find the next entry. */\n\tif (*s == tk->ch) {\n\t\t/* Move forward in string. */\n\t\ts++;\n\n\t\t/* If this is the end of the string, no more is necessary. */\n\t\tif (*s == '\\0') {\n\t\t\ttk->key = key;\n\t\t\treturn;\n\t\t}\n\n\t\t/* Use the child tree for the next character. */\n\t\ttkp = &tk->next;\n\t} else {\n\t\tif (*s < tk->ch)\n\t\t\ttkp = &tk->left;\n\t\telse if (*s > tk->ch)\n\t\t\ttkp = &tk->right;\n\t}\n\n\t/* And recurse to add it. */\n\ttty_keys_add1(tkp, s, key);\n}\n\n/* Initialise a key tree from the table. */\nvoid\ntty_keys_build(struct tty *tty)\n{\n\tconst struct tty_default_key_raw\t*tdkr;\n\tconst struct tty_default_key_code\t*tdkc;\n\tu_int\t\t \t\t\t i;\n\tconst char\t\t\t\t*s;\n\n\tif (tty->key_tree != NULL)\n\t\ttty_keys_free(tty);\n\ttty->key_tree = NULL;\n\n\tfor (i = 0; i < nitems(tty_default_raw_keys); i++) {\n\t\ttdkr = &tty_default_raw_keys[i];\n\n\t\ts = tdkr->string;\n\t\tif (*s != '\\0')\n\t\t\ttty_keys_add(tty, s, tdkr->key);\n\t}\n\tfor (i = 0; i < nitems(tty_default_code_keys); i++) {\n\t\ttdkc = &tty_default_code_keys[i];\n\n\t\ts = tty_term_string(tty->term, tdkc->code);\n\t\tif (*s != '\\0')\n\t\t\ttty_keys_add(tty, s, tdkc->key);\n\n\t}\n}\n\n/* Free the entire key tree. */\nvoid\ntty_keys_free(struct tty *tty)\n{\n\ttty_keys_free1(tty->key_tree);\n}\n\n/* Free a single key. */\nvoid\ntty_keys_free1(struct tty_key *tk)\n{\n\tif (tk->next != NULL)\n\t\ttty_keys_free1(tk->next);\n\tif (tk->left != NULL)\n\t\ttty_keys_free1(tk->left);\n\tif (tk->right != NULL)\n\t\ttty_keys_free1(tk->right);\n\tfree(tk);\n}\n\n/* Lookup a key in the tree. */\nstruct tty_key *\ntty_keys_find(struct tty *tty, const char *buf, size_t len, size_t *size)\n{\n\t*size = 0;\n\treturn (tty_keys_find1(tty->key_tree, buf, len, size));\n}\n\n/* Find the next node. */\nstruct tty_key *\ntty_keys_find1(struct tty_key *tk, const char *buf, size_t len, size_t *size)\n{\n\t/* If the node is NULL, this is the end of the tree. No match. */\n\tif (tk == NULL)\n\t\treturn (NULL);\n\n\t/* Pick the next in the sequence. */\n\tif (tk->ch == *buf) {\n\t\t/* Move forward in the string. */\n\t\tbuf++; len--;\n\t\t(*size)++;\n\n\t\t/* At the end of the string, return the current node. */\n\t\tif (len == 0 || (tk->next == NULL && tk->key != KEYC_UNKNOWN))\n\t\t\treturn (tk);\n\n\t\t/* Move into the next tree for the following character. */\n\t\ttk = tk->next;\n\t} else {\n\t\tif (*buf < tk->ch)\n\t\t\ttk = tk->left;\n\t\telse if (*buf > tk->ch)\n\t\t\ttk = tk->right;\n\t}\n\n\t/* Move to the next in the tree. */\n\treturn (tty_keys_find1(tk, buf, len, size));\n}\n\n/*\n * Process at least one key in the buffer and invoke tty->key_callback. Return\n * 0 if there are no further keys, or 1 if there could be more in the buffer.\n */\nkey_code\ntty_keys_next(struct tty *tty)\n{\n\tstruct tty_key\t\t*tk;\n\tstruct timeval\t\t tv;\n\tconst char\t\t*buf;\n\tsize_t\t\t\t len, size;\n\tcc_t\t\t\t bspace;\n\tint\t\t\t delay, expired = 0;\n\tkey_code\t\t key;\n\tstruct utf8_data\t ud;\n\tenum utf8_state\t\t more;\n\tu_int\t\t\t i;\n\twchar_t\t\t\t wc;\n\n\t/* Get key buffer. */\n\tbuf = EVBUFFER_DATA(tty->event->input);\n\tlen = EVBUFFER_LENGTH(tty->event->input);\n\n\tif (len == 0)\n\t\treturn (0);\n\tlog_debug(\"keys are %zu (%.*s)\", len, (int) len, buf);\n\n\t/* Is this a mouse key press? */\n\tswitch (tty_keys_mouse(tty, buf, len, &size)) {\n\tcase 0:\t\t/* yes */\n\t\tkey = KEYC_MOUSE;\n\t\tgoto complete_key;\n\tcase -1:\t/* no, or not valid */\n\t\tbreak;\n\tcase -2:\t/* yes, but we don't care. */\n\t\tkey = KEYC_MOUSE;\n\t\tgoto discard_key;\n\tcase 1:\t\t/* partial */\n\t\tgoto partial_key;\n\t}\n\n\t/* Look for matching key string and return if found. */\n\ttk = tty_keys_find(tty, buf, len, &size);\n\tif (tk != NULL) {\n\t\tif (tk->next != NULL)\n\t\t\tgoto partial_key;\n\t\tkey = tk->key;\n\t\tgoto complete_key;\n\t}\n\n\t/* Try to parse a key with an xterm-style modifier. */\n\tswitch (xterm_keys_find(buf, len, &size, &key)) {\n\tcase 0:\t\t/* found */\n\t\tgoto complete_key;\n\tcase -1:\t/* not found */\n\t\tbreak;\n\tcase 1:\n\t\tgoto partial_key;\n\t}\n\nfirst_key:\n\t/* Is this a meta key? */\n\tif (len >= 2 && buf[0] == '\\033') {\n\t\tif (buf[1] != '\\033') {\n\t\t\tkey = buf[1] | KEYC_ESCAPE;\n\t\t\tsize = 2;\n\t\t\tgoto complete_key;\n\t\t}\n\n\t\ttk = tty_keys_find(tty, buf + 1, len - 1, &size);\n\t\tif (tk != NULL && (!expired || tk->next == NULL)) {\n\t\t\tsize++;\t/* include escape */\n\t\t\tif (tk->next != NULL)\n\t\t\t\tgoto partial_key;\n\t\t\tkey = tk->key;\n\t\t\tif (key != KEYC_UNKNOWN)\n\t\t\t\tkey |= KEYC_ESCAPE;\n\t\t\tgoto complete_key;\n\t\t}\n\t}\n\n\t/* Is this valid UTF-8? */\n\tif ((more = utf8_open(&ud, (u_char)*buf) == UTF8_MORE)) {\n\t\tsize = ud.size;\n\t\tif (len < size) {\n\t\t\tif (expired)\n\t\t\t\tgoto discard_key;\n\t\t\tgoto partial_key;\n\t\t}\n\t\tfor (i = 1; i < size; i++)\n\t\t\tmore = utf8_append(&ud, (u_char)buf[i]);\n\t\tif (more != UTF8_DONE)\n\t\t\tgoto discard_key;\n\n\t\tif (utf8_combine(&ud, &wc) != UTF8_DONE)\n\t\t\tgoto discard_key;\n\t\tkey = wc;\n\n\t\tlog_debug(\"UTF-8 key %.*s %#llx\", (int)size, buf, key);\n\t\tgoto complete_key;\n\t}\n\n\t/* No key found, take first. */\n\tkey = (u_char)*buf;\n\tsize = 1;\n\n\t/*\n\t * Check for backspace key using termios VERASE - the terminfo\n\t * kbs entry is extremely unreliable, so cannot be safely\n\t * used. termios should have a better idea.\n\t */\n\tbspace = tty->tio.c_cc[VERASE];\n\tif (bspace != _POSIX_VDISABLE && key == bspace)\n\t\tkey = KEYC_BSPACE;\n\n\tgoto complete_key;\n\npartial_key:\n\tlog_debug(\"partial key %.*s\", (int) len, buf);\n\n\t/* If timer is going, check for expiration. */\n\tif (tty->flags & TTY_TIMER) {\n\t\tif (evtimer_initialized(&tty->key_timer) &&\n\t\t    !evtimer_pending(&tty->key_timer, NULL)) {\n\t\t\texpired = 1;\n\t\t\tgoto first_key;\n\t\t}\n\t\treturn (0);\n\t}\n\n\t/* Get the time period. */\n\tdelay = options_get_number(global_options, \"escape-time\");\n\ttv.tv_sec = delay / 1000;\n\ttv.tv_usec = (delay % 1000) * 1000L;\n\n\t/* Start the timer. */\n\tif (event_initialized(&tty->key_timer))\n\t\tevtimer_del(&tty->key_timer);\n\tevtimer_set(&tty->key_timer, tty_keys_callback, tty);\n\tevtimer_add(&tty->key_timer, &tv);\n\n\ttty->flags |= TTY_TIMER;\n\treturn (0);\n\ncomplete_key:\n\tlog_debug(\"complete key %.*s %#llx\", (int)size, buf, key);\n\n\t/* Remove data from buffer. */\n\tevbuffer_drain(tty->event->input, size);\n\n\t/* Remove key timer. */\n\tif (event_initialized(&tty->key_timer))\n\t\tevtimer_del(&tty->key_timer);\n\ttty->flags &= ~TTY_TIMER;\n\n\t/* Check for focus events. */\n\tif (key == KEYC_FOCUS_OUT) {\n\t\ttty->client->flags &= ~CLIENT_FOCUSED;\n\t\treturn (1);\n\t} else if (key == KEYC_FOCUS_IN) {\n\t\ttty->client->flags |= CLIENT_FOCUSED;\n\t\treturn (1);\n\t}\n\n\t/* Fire the key. */\n\tif (key != KEYC_UNKNOWN)\n\t\tserver_client_handle_key(tty->client, key);\n\n\treturn (1);\n\ndiscard_key:\n\tlog_debug(\"discard key %.*s %#llx\", (int)size, buf, key);\n\n\t/* Remove data from buffer. */\n\tevbuffer_drain(tty->event->input, size);\n\n\treturn (1);\n}\n\n/* Key timer callback. */\nvoid\ntty_keys_callback(__unused int fd, __unused short events, void *data)\n{\n\tstruct tty\t*tty = data;\n\n\tif (tty->flags & TTY_TIMER) {\n\t\twhile (tty_keys_next(tty))\n\t\t\t;\n\t}\n}\n\n/*\n * Handle mouse key input. Returns 0 for success, -1 for failure, 1 for partial\n * (probably a mouse sequence but need more data).\n */\nint\ntty_keys_mouse(struct tty *tty, const char *buf, size_t len, size_t *size)\n{\n\tstruct mouse_event\t*m = &tty->mouse;\n\tu_int\t\t\t i, x, y, b, sgr_b;\n\tu_char\t\t\t sgr_type, c;\n\n\t/*\n\t * Standard mouse sequences are \\033[M followed by three characters\n\t * indicating button, X and Y, all based at 32 with 1,1 top-left.\n\t *\n\t * UTF-8 mouse sequences are similar but the three are expressed as\n\t * UTF-8 characters.\n\t *\n\t * SGR extended mouse sequences are \\033[< followed by three numbers in\n\t * decimal and separated by semicolons indicating button, X and Y. A\n\t * trailing 'M' is click or scroll and trailing 'm' release. All are\n\t * based at 0 with 1,1 top-left.\n\t */\n\n\t*size = 0;\n\tx = y = b = sgr_b = 0;\n\tsgr_type = ' ';\n\n\t/* First two bytes are always \\033[. */\n\tif (buf[0] != '\\033')\n\t\treturn (-1);\n\tif (len == 1)\n\t\treturn (1);\n\tif (buf[1] != '[')\n\t\treturn (-1);\n\tif (len == 2)\n\t\treturn (1);\n\n\t/*\n\t * Third byte is M in old standard (and UTF-8 extension which we do not\n\t * support), < in SGR extension.\n\t */\n\tif (buf[2] == 'M') {\n\t\t/* Read the three inputs. */\n\t\t*size = 3;\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tif (len <= *size)\n\t\t\t\treturn (1);\n\t\t\tc = (u_char)buf[(*size)++];\n\t\t\tif (i == 0)\n\t\t\t\tb = c;\n\t\t\telse if (i == 1)\n\t\t\t\tx = c;\n\t\t\telse\n\t\t\t\ty = c;\n\t\t}\n\t\tlog_debug(\"mouse input: %.*s\", (int)*size, buf);\n\n\t\t/* Check and return the mouse input. */\n\t\tif (b < 32)\n\t\t\treturn (-1);\n\t\tb -= 32;\n\t\tif (x >= 33)\n\t\t\tx -= 33;\n\t\telse\n\t\t\tx = 256 - x;\n\t\tif (y >= 33)\n\t\t\ty -= 33;\n\t\telse\n\t\t\ty = 256 - y;\n\t} else if (buf[2] == '<') {\n\t\t/* Read the three inputs. */\n\t\t*size = 3;\n\t\twhile (1) {\n\t\t\tif (len <= *size)\n\t\t\t\treturn (1);\n\t\t\tc = (u_char)buf[(*size)++];\n\t\t\tif (c == ';')\n\t\t\t\tbreak;\n\t\t\tif (c < '0' || c > '9')\n\t\t\t\treturn (-1);\n\t\t\tsgr_b = 10 * sgr_b + (c - '0');\n\t\t}\n\t\twhile (1) {\n\t\t\tif (len <= *size)\n\t\t\t\treturn (1);\n\t\t\tc = (u_char)buf[(*size)++];\n\t\t\tif (c == ';')\n\t\t\t\tbreak;\n\t\t\tif (c < '0' || c > '9')\n\t\t\t\treturn (-1);\n\t\t\tx = 10 * x + (c - '0');\n\t\t}\n\t\twhile (1) {\n\t\t\tif (len <= *size)\n\t\t\t\treturn (1);\n\t\t\tc = (u_char)buf[(*size)++];\n\t\t\tif (c == 'M' || c == 'm')\n\t\t\t\tbreak;\n\t\t\tif (c < '0' || c > '9')\n\t\t\t\treturn (-1);\n\t\t\ty = 10 * y + (c - '0');\n\t\t}\n\t\tlog_debug(\"mouse input (SGR): %.*s\", (int)*size, buf);\n\n\t\t/* Check and return the mouse input. */\n\t\tif (x < 1 || y < 1)\n\t\t\treturn (-1);\n\t\tx--;\n\t\ty--;\n\t\tb = sgr_b;\n\n\t\t/* Type is M for press, m for release. */\n\t\tsgr_type = c;\n\t\tif (sgr_type == 'm')\n\t\t\tb |= 3;\n\n\t\t/*\n\t\t * Some terminals (like PuTTY 0.63) mistakenly send\n\t\t * button-release events for scroll-wheel button-press event.\n\t\t * Discard it before it reaches any program running inside\n\t\t * tmux.\n\t\t */\n\t\tif (sgr_type == 'm' && (sgr_b & 64))\n\t\t    return (-2);\n\t} else\n\t\treturn (-1);\n\n\t/* Fill mouse event. */\n\tm->lx = m->x;\n\tm->x = x;\n\tm->ly = m->y;\n\tm->y = y;\n\tm->lb = m->b;\n\tm->b = b;\n\tm->sgr_type = sgr_type;\n\tm->sgr_b = sgr_b;\n\n\treturn (0);\n}\n"
        },
        {
          "name": "tty-term.c",
          "type": "blob",
          "size": 18.8408203125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2008 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#if defined(HAVE_CURSES_H)\n#include <curses.h>\n#elif defined(HAVE_NCURSES_H)\n#include <ncurses.h>\n#endif\n#include <fnmatch.h>\n#include <stdlib.h>\n#include <string.h>\n#include <term.h>\n\n#include \"tmux.h\"\n\nvoid\t tty_term_override(struct tty_term *, const char *);\nchar\t*tty_term_strip(const char *);\n\nstruct tty_terms tty_terms = LIST_HEAD_INITIALIZER(tty_terms);\n\nenum tty_code_type {\n\tTTYCODE_NONE = 0,\n\tTTYCODE_STRING,\n\tTTYCODE_NUMBER,\n\tTTYCODE_FLAG,\n};\n\nstruct tty_code {\n\tenum tty_code_type\ttype;\n\tunion {\n\t\tchar\t       *string;\n\t\tint\t\tnumber;\n\t\tint\t\tflag;\n\t} value;\n};\n\nstruct tty_term_code_entry {\n\tenum tty_code_type\ttype;\n\tconst char\t       *name;\n};\n\nconst struct tty_term_code_entry tty_term_codes[] = {\n\t[TTYC_ACSC] = { TTYCODE_STRING, \"acsc\" },\n\t[TTYC_AX] = { TTYCODE_FLAG, \"AX\" },\n\t[TTYC_BCE] = { TTYCODE_FLAG, \"bce\" },\n\t[TTYC_BEL] = { TTYCODE_STRING, \"bel\" },\n\t[TTYC_BLINK] = { TTYCODE_STRING, \"blink\" },\n\t[TTYC_BOLD] = { TTYCODE_STRING, \"bold\" },\n\t[TTYC_CIVIS] = { TTYCODE_STRING, \"civis\" },\n\t[TTYC_CLEAR] = { TTYCODE_STRING, \"clear\" },\n\t[TTYC_CNORM] = { TTYCODE_STRING, \"cnorm\" },\n\t[TTYC_COLORS] = { TTYCODE_NUMBER, \"colors\" },\n\t[TTYC_CR] = { TTYCODE_STRING, \"Cr\" },\n\t[TTYC_CS] = { TTYCODE_STRING, \"Cs\" },\n\t[TTYC_CSR] = { TTYCODE_STRING, \"csr\" },\n\t[TTYC_CUB] = { TTYCODE_STRING, \"cub\" },\n\t[TTYC_CUB1] = { TTYCODE_STRING, \"cub1\" },\n\t[TTYC_CUD] = { TTYCODE_STRING, \"cud\" },\n\t[TTYC_CUD1] = { TTYCODE_STRING, \"cud1\" },\n\t[TTYC_CUF] = { TTYCODE_STRING, \"cuf\" },\n\t[TTYC_CUF1] = { TTYCODE_STRING, \"cuf1\" },\n\t[TTYC_CUP] = { TTYCODE_STRING, \"cup\" },\n\t[TTYC_CUU] = { TTYCODE_STRING, \"cuu\" },\n\t[TTYC_CUU1] = { TTYCODE_STRING, \"cuu1\" },\n\t[TTYC_CVVIS] = { TTYCODE_STRING, \"cvvis\" },\n\t[TTYC_DCH] = { TTYCODE_STRING, \"dch\" },\n\t[TTYC_DCH1] = { TTYCODE_STRING, \"dch1\" },\n\t[TTYC_DIM] = { TTYCODE_STRING, \"dim\" },\n\t[TTYC_DL] = { TTYCODE_STRING, \"dl\" },\n\t[TTYC_DL1] = { TTYCODE_STRING, \"dl1\" },\n\t[TTYC_E3] = { TTYCODE_STRING, \"E3\" },\n\t[TTYC_ECH] = { TTYCODE_STRING, \"ech\" },\n\t[TTYC_EL] = { TTYCODE_STRING, \"el\" },\n\t[TTYC_EL1] = { TTYCODE_STRING, \"el1\" },\n\t[TTYC_ENACS] = { TTYCODE_STRING, \"enacs\" },\n\t[TTYC_FSL] = { TTYCODE_STRING, \"fsl\" },\n\t[TTYC_HOME] = { TTYCODE_STRING, \"home\" },\n\t[TTYC_HPA] = { TTYCODE_STRING, \"hpa\" },\n\t[TTYC_ICH] = { TTYCODE_STRING, \"ich\" },\n\t[TTYC_ICH1] = { TTYCODE_STRING, \"ich1\" },\n\t[TTYC_IL] = { TTYCODE_STRING, \"il\" },\n\t[TTYC_IL1] = { TTYCODE_STRING, \"il1\" },\n\t[TTYC_INVIS] = { TTYCODE_STRING, \"invis\" },\n\t[TTYC_IS1] = { TTYCODE_STRING, \"is1\" },\n\t[TTYC_IS2] = { TTYCODE_STRING, \"is2\" },\n\t[TTYC_IS3] = { TTYCODE_STRING, \"is3\" },\n\t[TTYC_KCBT] = { TTYCODE_STRING, \"kcbt\" },\n\t[TTYC_KCUB1] = { TTYCODE_STRING, \"kcub1\" },\n\t[TTYC_KCUD1] = { TTYCODE_STRING, \"kcud1\" },\n\t[TTYC_KCUF1] = { TTYCODE_STRING, \"kcuf1\" },\n\t[TTYC_KCUU1] = { TTYCODE_STRING, \"kcuu1\" },\n\t[TTYC_KDC2] = { TTYCODE_STRING, \"kDC\" },\n\t[TTYC_KDC3] = { TTYCODE_STRING, \"kDC3\" },\n\t[TTYC_KDC4] = { TTYCODE_STRING, \"kDC4\" },\n\t[TTYC_KDC5] = { TTYCODE_STRING, \"kDC5\" },\n\t[TTYC_KDC6] = { TTYCODE_STRING, \"kDC6\" },\n\t[TTYC_KDC7] = { TTYCODE_STRING, \"kDC7\" },\n\t[TTYC_KDCH1] = { TTYCODE_STRING, \"kdch1\" },\n\t[TTYC_KDN2] = { TTYCODE_STRING, \"kDN\" },\n\t[TTYC_KDN3] = { TTYCODE_STRING, \"kDN3\" },\n\t[TTYC_KDN4] = { TTYCODE_STRING, \"kDN4\" },\n\t[TTYC_KDN5] = { TTYCODE_STRING, \"kDN5\" },\n\t[TTYC_KDN6] = { TTYCODE_STRING, \"kDN6\" },\n\t[TTYC_KDN7] = { TTYCODE_STRING, \"kDN7\" },\n\t[TTYC_KEND] = { TTYCODE_STRING, \"kend\" },\n\t[TTYC_KEND2] = { TTYCODE_STRING, \"kEND\" },\n\t[TTYC_KEND3] = { TTYCODE_STRING, \"kEND3\" },\n\t[TTYC_KEND4] = { TTYCODE_STRING, \"kEND4\" },\n\t[TTYC_KEND5] = { TTYCODE_STRING, \"kEND5\" },\n\t[TTYC_KEND6] = { TTYCODE_STRING, \"kEND6\" },\n\t[TTYC_KEND7] = { TTYCODE_STRING, \"kEND7\" },\n\t[TTYC_KF1] = { TTYCODE_STRING, \"kf1\" },\n\t[TTYC_KF10] = { TTYCODE_STRING, \"kf10\" },\n\t[TTYC_KF11] = { TTYCODE_STRING, \"kf11\" },\n\t[TTYC_KF12] = { TTYCODE_STRING, \"kf12\" },\n\t[TTYC_KF13] = { TTYCODE_STRING, \"kf13\" },\n\t[TTYC_KF14] = { TTYCODE_STRING, \"kf14\" },\n\t[TTYC_KF15] = { TTYCODE_STRING, \"kf15\" },\n\t[TTYC_KF16] = { TTYCODE_STRING, \"kf16\" },\n\t[TTYC_KF17] = { TTYCODE_STRING, \"kf17\" },\n\t[TTYC_KF18] = { TTYCODE_STRING, \"kf18\" },\n\t[TTYC_KF19] = { TTYCODE_STRING, \"kf19\" },\n\t[TTYC_KF2] = { TTYCODE_STRING, \"kf2\" },\n\t[TTYC_KF20] = { TTYCODE_STRING, \"kf20\" },\n\t[TTYC_KF21] = { TTYCODE_STRING, \"kf21\" },\n\t[TTYC_KF22] = { TTYCODE_STRING, \"kf22\" },\n\t[TTYC_KF23] = { TTYCODE_STRING, \"kf23\" },\n\t[TTYC_KF24] = { TTYCODE_STRING, \"kf24\" },\n\t[TTYC_KF25] = { TTYCODE_STRING, \"kf25\" },\n\t[TTYC_KF26] = { TTYCODE_STRING, \"kf26\" },\n\t[TTYC_KF27] = { TTYCODE_STRING, \"kf27\" },\n\t[TTYC_KF28] = { TTYCODE_STRING, \"kf28\" },\n\t[TTYC_KF29] = { TTYCODE_STRING, \"kf29\" },\n\t[TTYC_KF3] = { TTYCODE_STRING, \"kf3\" },\n\t[TTYC_KF30] = { TTYCODE_STRING, \"kf30\" },\n\t[TTYC_KF31] = { TTYCODE_STRING, \"kf31\" },\n\t[TTYC_KF32] = { TTYCODE_STRING, \"kf32\" },\n\t[TTYC_KF33] = { TTYCODE_STRING, \"kf33\" },\n\t[TTYC_KF34] = { TTYCODE_STRING, \"kf34\" },\n\t[TTYC_KF35] = { TTYCODE_STRING, \"kf35\" },\n\t[TTYC_KF36] = { TTYCODE_STRING, \"kf36\" },\n\t[TTYC_KF37] = { TTYCODE_STRING, \"kf37\" },\n\t[TTYC_KF38] = { TTYCODE_STRING, \"kf38\" },\n\t[TTYC_KF39] = { TTYCODE_STRING, \"kf39\" },\n\t[TTYC_KF4] = { TTYCODE_STRING, \"kf4\" },\n\t[TTYC_KF40] = { TTYCODE_STRING, \"kf40\" },\n\t[TTYC_KF41] = { TTYCODE_STRING, \"kf41\" },\n\t[TTYC_KF42] = { TTYCODE_STRING, \"kf42\" },\n\t[TTYC_KF43] = { TTYCODE_STRING, \"kf43\" },\n\t[TTYC_KF44] = { TTYCODE_STRING, \"kf44\" },\n\t[TTYC_KF45] = { TTYCODE_STRING, \"kf45\" },\n\t[TTYC_KF46] = { TTYCODE_STRING, \"kf46\" },\n\t[TTYC_KF47] = { TTYCODE_STRING, \"kf47\" },\n\t[TTYC_KF48] = { TTYCODE_STRING, \"kf48\" },\n\t[TTYC_KF49] = { TTYCODE_STRING, \"kf49\" },\n\t[TTYC_KF5] = { TTYCODE_STRING, \"kf5\" },\n\t[TTYC_KF50] = { TTYCODE_STRING, \"kf50\" },\n\t[TTYC_KF51] = { TTYCODE_STRING, \"kf51\" },\n\t[TTYC_KF52] = { TTYCODE_STRING, \"kf52\" },\n\t[TTYC_KF53] = { TTYCODE_STRING, \"kf53\" },\n\t[TTYC_KF54] = { TTYCODE_STRING, \"kf54\" },\n\t[TTYC_KF55] = { TTYCODE_STRING, \"kf55\" },\n\t[TTYC_KF56] = { TTYCODE_STRING, \"kf56\" },\n\t[TTYC_KF57] = { TTYCODE_STRING, \"kf57\" },\n\t[TTYC_KF58] = { TTYCODE_STRING, \"kf58\" },\n\t[TTYC_KF59] = { TTYCODE_STRING, \"kf59\" },\n\t[TTYC_KF6] = { TTYCODE_STRING, \"kf6\" },\n\t[TTYC_KF60] = { TTYCODE_STRING, \"kf60\" },\n\t[TTYC_KF61] = { TTYCODE_STRING, \"kf61\" },\n\t[TTYC_KF62] = { TTYCODE_STRING, \"kf62\" },\n\t[TTYC_KF63] = { TTYCODE_STRING, \"kf63\" },\n\t[TTYC_KF7] = { TTYCODE_STRING, \"kf7\" },\n\t[TTYC_KF8] = { TTYCODE_STRING, \"kf8\" },\n\t[TTYC_KF9] = { TTYCODE_STRING, \"kf9\" },\n\t[TTYC_KHOM2] = { TTYCODE_STRING, \"kHOM\" },\n\t[TTYC_KHOM3] = { TTYCODE_STRING, \"kHOM3\" },\n\t[TTYC_KHOM4] = { TTYCODE_STRING, \"kHOM4\" },\n\t[TTYC_KHOM5] = { TTYCODE_STRING, \"kHOM5\" },\n\t[TTYC_KHOM6] = { TTYCODE_STRING, \"kHOM6\" },\n\t[TTYC_KHOM7] = { TTYCODE_STRING, \"kHOM7\" },\n\t[TTYC_KHOME] = { TTYCODE_STRING, \"khome\" },\n\t[TTYC_KIC2] = { TTYCODE_STRING, \"kIC\" },\n\t[TTYC_KIC3] = { TTYCODE_STRING, \"kIC3\" },\n\t[TTYC_KIC4] = { TTYCODE_STRING, \"kIC4\" },\n\t[TTYC_KIC5] = { TTYCODE_STRING, \"kIC5\" },\n\t[TTYC_KIC6] = { TTYCODE_STRING, \"kIC6\" },\n\t[TTYC_KIC7] = { TTYCODE_STRING, \"kIC7\" },\n\t[TTYC_KICH1] = { TTYCODE_STRING, \"kich1\" },\n\t[TTYC_KLFT2] = { TTYCODE_STRING, \"kLFT\" },\n\t[TTYC_KLFT3] = { TTYCODE_STRING, \"kLFT3\" },\n\t[TTYC_KLFT4] = { TTYCODE_STRING, \"kLFT4\" },\n\t[TTYC_KLFT5] = { TTYCODE_STRING, \"kLFT5\" },\n\t[TTYC_KLFT6] = { TTYCODE_STRING, \"kLFT6\" },\n\t[TTYC_KLFT7] = { TTYCODE_STRING, \"kLFT7\" },\n\t[TTYC_KMOUS] = { TTYCODE_STRING, \"kmous\" },\n\t[TTYC_KNP] = { TTYCODE_STRING, \"knp\" },\n\t[TTYC_KNXT2] = { TTYCODE_STRING, \"kNXT\" },\n\t[TTYC_KNXT3] = { TTYCODE_STRING, \"kNXT3\" },\n\t[TTYC_KNXT4] = { TTYCODE_STRING, \"kNXT4\" },\n\t[TTYC_KNXT5] = { TTYCODE_STRING, \"kNXT5\" },\n\t[TTYC_KNXT6] = { TTYCODE_STRING, \"kNXT6\" },\n\t[TTYC_KNXT7] = { TTYCODE_STRING, \"kNXT7\" },\n\t[TTYC_KPP] = { TTYCODE_STRING, \"kpp\" },\n\t[TTYC_KPRV2] = { TTYCODE_STRING, \"kPRV\" },\n\t[TTYC_KPRV3] = { TTYCODE_STRING, \"kPRV3\" },\n\t[TTYC_KPRV4] = { TTYCODE_STRING, \"kPRV4\" },\n\t[TTYC_KPRV5] = { TTYCODE_STRING, \"kPRV5\" },\n\t[TTYC_KPRV6] = { TTYCODE_STRING, \"kPRV6\" },\n\t[TTYC_KPRV7] = { TTYCODE_STRING, \"kPRV7\" },\n\t[TTYC_KRIT2] = { TTYCODE_STRING, \"kRIT\" },\n\t[TTYC_KRIT3] = { TTYCODE_STRING, \"kRIT3\" },\n\t[TTYC_KRIT4] = { TTYCODE_STRING, \"kRIT4\" },\n\t[TTYC_KRIT5] = { TTYCODE_STRING, \"kRIT5\" },\n\t[TTYC_KRIT6] = { TTYCODE_STRING, \"kRIT6\" },\n\t[TTYC_KRIT7] = { TTYCODE_STRING, \"kRIT7\" },\n\t[TTYC_KUP2] = { TTYCODE_STRING, \"kUP\" },\n\t[TTYC_KUP3] = { TTYCODE_STRING, \"kUP3\" },\n\t[TTYC_KUP4] = { TTYCODE_STRING, \"kUP4\" },\n\t[TTYC_KUP5] = { TTYCODE_STRING, \"kUP5\" },\n\t[TTYC_KUP6] = { TTYCODE_STRING, \"kUP6\" },\n\t[TTYC_KUP7] = { TTYCODE_STRING, \"kUP7\" },\n\t[TTYC_MS] = { TTYCODE_STRING, \"Ms\" },\n\t[TTYC_OP] = { TTYCODE_STRING, \"op\" },\n\t[TTYC_REV] = { TTYCODE_STRING, \"rev\" },\n\t[TTYC_RI] = { TTYCODE_STRING, \"ri\" },\n\t[TTYC_RMACS] = { TTYCODE_STRING, \"rmacs\" },\n\t[TTYC_RMCUP] = { TTYCODE_STRING, \"rmcup\" },\n\t[TTYC_RMKX] = { TTYCODE_STRING, \"rmkx\" },\n\t[TTYC_SE] = { TTYCODE_STRING, \"Se\" },\n\t[TTYC_SETAB] = { TTYCODE_STRING, \"setab\" },\n\t[TTYC_SETAF] = { TTYCODE_STRING, \"setaf\" },\n\t[TTYC_SGR0] = { TTYCODE_STRING, \"sgr0\" },\n\t[TTYC_SITM] = { TTYCODE_STRING, \"sitm\" },\n\t[TTYC_SMACS] = { TTYCODE_STRING, \"smacs\" },\n\t[TTYC_SMCUP] = { TTYCODE_STRING, \"smcup\" },\n\t[TTYC_SMKX] = { TTYCODE_STRING, \"smkx\" },\n\t[TTYC_SMSO] = { TTYCODE_STRING, \"smso\" },\n\t[TTYC_SMUL] = { TTYCODE_STRING, \"smul\" },\n\t[TTYC_SS] = { TTYCODE_STRING, \"Ss\" },\n\t[TTYC_TC] = { TTYCODE_FLAG, \"Tc\" },\n\t[TTYC_TSL] = { TTYCODE_STRING, \"tsl\" },\n\t[TTYC_VPA] = { TTYCODE_STRING, \"vpa\" },\n\t[TTYC_XENL] = { TTYCODE_FLAG, \"xenl\" },\n\t[TTYC_XT] = { TTYCODE_FLAG, \"XT\" },\n};\n\nu_int\ntty_term_ncodes(void)\n{\n\treturn (nitems(tty_term_codes));\n}\n\nchar *\ntty_term_strip(const char *s)\n{\n\tconst char     *ptr;\n\tstatic char\tbuf[BUFSIZ];\n\tsize_t\t\tlen;\n\n\t/* Ignore strings with no padding. */\n\tif (strchr(s, '$') == NULL)\n\t\treturn (xstrdup(s));\n\n\tlen = 0;\n\tfor (ptr = s; *ptr != '\\0'; ptr++) {\n\t\tif (*ptr == '$' && *(ptr + 1) == '<') {\n\t\t\twhile (*ptr != '\\0' && *ptr != '>')\n\t\t\t\tptr++;\n\t\t\tif (*ptr == '>')\n\t\t\t\tptr++;\n\t\t}\n\n\t\tbuf[len++] = *ptr;\n\t\tif (len == (sizeof buf) - 1)\n\t\t\tbreak;\n\t}\n\tbuf[len] = '\\0';\n\n\treturn (xstrdup(buf));\n}\n\nvoid\ntty_term_override(struct tty_term *term, const char *overrides)\n{\n\tconst struct tty_term_code_entry\t*ent;\n\tstruct tty_code\t\t\t\t*code;\n\tchar\t\t\t\t\t*termnext, *termstr;\n\tchar\t\t\t\t\t*entnext, *entstr;\n\tchar\t\t\t\t\t*s, *ptr, *val;\n\tconst char\t\t\t\t*errstr;\n\tu_int\t\t\t\t\t i;\n\tint\t\t\t\t\t n, removeflag;\n\n\ts = xstrdup(overrides);\n\n\ttermnext = s;\n\twhile ((termstr = strsep(&termnext, \",\")) != NULL) {\n\t\tentnext = termstr;\n\n\t\tentstr = strsep(&entnext, \":\");\n\t\tif (entstr == NULL || entnext == NULL)\n\t\t\tcontinue;\n\t\tif (fnmatch(entstr, term->name, 0) != 0)\n\t\t\tcontinue;\n\t\twhile ((entstr = strsep(&entnext, \":\")) != NULL) {\n\t\t\tif (*entstr == '\\0')\n\t\t\t\tcontinue;\n\n\t\t\tval = NULL;\n\t\t\tremoveflag = 0;\n\t\t\tif ((ptr = strchr(entstr, '=')) != NULL) {\n\t\t\t\t*ptr++ = '\\0';\n\t\t\t\tval = xstrdup(ptr);\n\t\t\t\tif (strunvis(val, ptr) == -1) {\n\t\t\t\t\tfree(val);\n\t\t\t\t\tval = xstrdup(ptr);\n\t\t\t\t}\n\t\t\t} else if (entstr[strlen(entstr) - 1] == '@') {\n\t\t\t\tentstr[strlen(entstr) - 1] = '\\0';\n\t\t\t\tremoveflag = 1;\n\t\t\t} else\n\t\t\t\tval = xstrdup(\"\");\n\n\t\t\tlog_debug(\"%s override: %s %s\",\n\t\t\t    term->name, entstr, removeflag ? \"@\" : val);\n\t\t\tfor (i = 0; i < tty_term_ncodes(); i++) {\n\t\t\t\tent = &tty_term_codes[i];\n\t\t\t\tif (strcmp(entstr, ent->name) != 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tcode = &term->codes[i];\n\n\t\t\t\tif (removeflag) {\n\t\t\t\t\tcode->type = TTYCODE_NONE;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tswitch (ent->type) {\n\t\t\t\tcase TTYCODE_NONE:\n\t\t\t\t\tbreak;\n\t\t\t\tcase TTYCODE_STRING:\n\t\t\t\t\tif (code->type == TTYCODE_STRING)\n\t\t\t\t\t\tfree(code->value.string);\n\t\t\t\t\tcode->value.string = xstrdup(val);\n\t\t\t\t\tcode->type = ent->type;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TTYCODE_NUMBER:\n\t\t\t\t\tn = strtonum(val, 0, INT_MAX, &errstr);\n\t\t\t\t\tif (errstr != NULL)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcode->value.number = n;\n\t\t\t\t\tcode->type = ent->type;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TTYCODE_FLAG:\n\t\t\t\t\tcode->value.flag = 1;\n\t\t\t\t\tcode->type = ent->type;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfree(val);\n\t\t}\n\t}\n\n\tfree(s);\n}\n\nstruct tty_term *\ntty_term_find(char *name, int fd, char **cause)\n{\n\tstruct tty_term\t\t\t\t*term;\n\tconst struct tty_term_code_entry\t*ent;\n\tstruct tty_code\t\t\t\t*code;\n\tu_int\t\t\t\t\t i;\n\tint\t\t \t\t\t n, error;\n\tchar\t\t\t\t\t*s;\n\tconst char\t\t\t\t*acs;\n\n\tLIST_FOREACH(term, &tty_terms, entry) {\n\t\tif (strcmp(term->name, name) == 0) {\n\t\t\tterm->references++;\n\t\t\treturn (term);\n\t\t}\n\t}\n\n\tlog_debug(\"new term: %s\", name);\n\tterm = xmalloc(sizeof *term);\n\tterm->name = xstrdup(name);\n\tterm->references = 1;\n\tterm->flags = 0;\n\tterm->codes = xcalloc (tty_term_ncodes(), sizeof *term->codes);\n\tLIST_INSERT_HEAD(&tty_terms, term, entry);\n\n\t/* Set up curses terminal. */\n\tif (setupterm(name, fd, &error) != OK) {\n\t\tswitch (error) {\n\t\tcase 1:\n\t\t\txasprintf(cause, \"can't use hardcopy terminal: %s\",\n\t\t\t    name);\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\txasprintf(cause, \"missing or unsuitable terminal: %s\",\n\t\t\t    name);\n\t\t\tbreak;\n\t\tcase -1:\n\t\t\txasprintf(cause, \"can't find terminfo database\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\txasprintf(cause, \"unknown error\");\n\t\t\tbreak;\n\t\t}\n\t\tgoto error;\n\t}\n\n\t/* Fill in codes. */\n\tfor (i = 0; i < tty_term_ncodes(); i++) {\n\t\tent = &tty_term_codes[i];\n\n\t\tcode = &term->codes[i];\n\t\tcode->type = TTYCODE_NONE;\n\t\tswitch (ent->type) {\n\t\tcase TTYCODE_NONE:\n\t\t\tbreak;\n\t\tcase TTYCODE_STRING:\n\t\t\ts = tigetstr((char *) ent->name);\n\t\t\tif (s == NULL || s == (char *) -1)\n\t\t\t\tbreak;\n\t\t\tcode->type = TTYCODE_STRING;\n\t\t\tcode->value.string = tty_term_strip(s);\n\t\t\tbreak;\n\t\tcase TTYCODE_NUMBER:\n\t\t\tn = tigetnum((char *) ent->name);\n\t\t\tif (n == -1 || n == -2)\n\t\t\t\tbreak;\n\t\t\tcode->type = TTYCODE_NUMBER;\n\t\t\tcode->value.number = n;\n\t\t\tbreak;\n\t\tcase TTYCODE_FLAG:\n\t\t\tn = tigetflag((char *) ent->name);\n\t\t\tif (n == -1)\n\t\t\t\tbreak;\n\t\t\tcode->type = TTYCODE_FLAG;\n\t\t\tcode->value.flag = n;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Apply terminal overrides. */\n\ts = options_get_string(global_options, \"terminal-overrides\");\n\ttty_term_override(term, s);\n\n\t/* Delete curses data. */\n#if !defined(NCURSES_VERSION_MAJOR) || NCURSES_VERSION_MAJOR > 5 || \\\n    (NCURSES_VERSION_MAJOR == 5 && NCURSES_VERSION_MINOR > 6)\n\tdel_curterm(cur_term);\n#endif\n\n\t/* These are always required. */\n\tif (!tty_term_has(term, TTYC_CLEAR)) {\n\t\txasprintf(cause, \"terminal does not support clear\");\n\t\tgoto error;\n\t}\n\tif (!tty_term_has(term, TTYC_CUP)) {\n\t\txasprintf(cause, \"terminal does not support cup\");\n\t\tgoto error;\n\t}\n\n\t/* These can be emulated so one of the two is required. */\n\tif (!tty_term_has(term, TTYC_CUD1) && !tty_term_has(term, TTYC_CUD)) {\n\t\txasprintf(cause, \"terminal does not support cud1 or cud\");\n\t\tgoto error;\n\t}\n\n\t/* Figure out if we have 256. */\n\tif (tty_term_number(term, TTYC_COLORS) == 256)\n\t\tterm->flags |= TERM_256COLOURS;\n\n\t/*\n\t * Terminals without xenl (eat newline glitch) wrap at at $COLUMNS - 1\n\t * rather than $COLUMNS (the cursor can never be beyond $COLUMNS - 1).\n\t *\n\t * This is irritating, most notably because it is impossible to write\n\t * to the very bottom-right of the screen without scrolling.\n\t *\n\t * Flag the terminal here and apply some workarounds in other places to\n\t * do the best possible.\n\t */\n\tif (!tty_term_flag(term, TTYC_XENL))\n\t\tterm->flags |= TERM_EARLYWRAP;\n\n\t/* Generate ACS table. If none is present, use nearest ASCII. */\n\tmemset(term->acs, 0, sizeof term->acs);\n\tif (tty_term_has(term, TTYC_ACSC))\n\t\tacs = tty_term_string(term, TTYC_ACSC);\n\telse\n\t\tacs = \"a#j+k+l+m+n+o-p-q-r-s-t+u+v+w+x|y<z>~.\";\n\tfor (; acs[0] != '\\0' && acs[1] != '\\0'; acs += 2)\n\t\tterm->acs[(u_char) acs[0]][0] = acs[1];\n\n\t/* On terminals with xterm titles (XT), fill in tsl and fsl. */\n\tif (tty_term_flag(term, TTYC_XT) &&\n\t    !tty_term_has(term, TTYC_TSL) &&\n\t    !tty_term_has(term, TTYC_FSL)) {\n\t\tcode = &term->codes[TTYC_TSL];\n\t\tcode->value.string = xstrdup(\"\\033]0;\");\n\t\tcode->type = TTYCODE_STRING;\n\t\tcode = &term->codes[TTYC_FSL];\n\t\tcode->value.string = xstrdup(\"\\007\");\n\t\tcode->type = TTYCODE_STRING;\n\t}\n\n\treturn (term);\n\nerror:\n\ttty_term_free(term);\n\treturn (NULL);\n}\n\nvoid\ntty_term_free(struct tty_term *term)\n{\n\tu_int\ti;\n\n\tif (--term->references != 0)\n\t\treturn;\n\n\tLIST_REMOVE(term, entry);\n\n\tfor (i = 0; i < tty_term_ncodes(); i++) {\n\t\tif (term->codes[i].type == TTYCODE_STRING)\n\t\t\tfree(term->codes[i].value.string);\n\t}\n\tfree(term->codes);\n\n\tfree(term->name);\n\tfree(term);\n}\n\nint\ntty_term_has(struct tty_term *term, enum tty_code_code code)\n{\n\treturn (term->codes[code].type != TTYCODE_NONE);\n}\n\nconst char *\ntty_term_string(struct tty_term *term, enum tty_code_code code)\n{\n\tif (!tty_term_has(term, code))\n\t\treturn (\"\");\n\tif (term->codes[code].type != TTYCODE_STRING)\n\t\tfatalx(\"not a string: %d\", code);\n\treturn (term->codes[code].value.string);\n}\n\nconst char *\ntty_term_string1(struct tty_term *term, enum tty_code_code code, int a)\n{\n\treturn (tparm((char *) tty_term_string(term, code), a, 0, 0, 0, 0, 0, 0, 0, 0));\n}\n\nconst char *\ntty_term_string2(struct tty_term *term, enum tty_code_code code, int a, int b)\n{\n\treturn (tparm((char *) tty_term_string(term, code), a, b, 0, 0, 0, 0, 0, 0, 0));\n}\n\nconst char *\ntty_term_ptr1(struct tty_term *term, enum tty_code_code code, const void *a)\n{\n\treturn (tparm((char *) tty_term_string(term, code), a, 0, 0, 0, 0, 0, 0, 0, 0));\n}\n\nconst char *\ntty_term_ptr2(struct tty_term *term, enum tty_code_code code, const void *a,\n    const void *b)\n{\n\treturn (tparm((char *) tty_term_string(term, code), a, b, 0, 0, 0, 0, 0, 0, 0));\n}\n\nint\ntty_term_number(struct tty_term *term, enum tty_code_code code)\n{\n\tif (!tty_term_has(term, code))\n\t\treturn (0);\n\tif (term->codes[code].type != TTYCODE_NUMBER)\n\t\tfatalx(\"not a number: %d\", code);\n\treturn (term->codes[code].value.number);\n}\n\nint\ntty_term_flag(struct tty_term *term, enum tty_code_code code)\n{\n\tif (!tty_term_has(term, code))\n\t\treturn (0);\n\tif (term->codes[code].type != TTYCODE_FLAG)\n\t\tfatalx(\"not a flag: %d\", code);\n\treturn (term->codes[code].value.flag);\n}\n\nconst char *\ntty_term_describe(struct tty_term *term, enum tty_code_code code)\n{\n\tstatic char\t s[256];\n\tchar\t\t out[128];\n\n\tswitch (term->codes[code].type) {\n\tcase TTYCODE_NONE:\n\t\txsnprintf(s, sizeof s, \"%4u: %s: [missing]\",\n\t\t    code, tty_term_codes[code].name);\n\t\tbreak;\n\tcase TTYCODE_STRING:\n\t\tstrnvis(out, term->codes[code].value.string, sizeof out,\n\t\t    VIS_OCTAL|VIS_TAB|VIS_NL);\n\t\txsnprintf(s, sizeof s, \"%4u: %s: (string) %s\",\n\t\t    code, tty_term_codes[code].name,\n\t\t    out);\n\t\tbreak;\n\tcase TTYCODE_NUMBER:\n\t\txsnprintf(s, sizeof s, \"%4u: %s: (number) %d\",\n\t\t    code, tty_term_codes[code].name,\n\t\t    term->codes[code].value.number);\n\t\tbreak;\n\tcase TTYCODE_FLAG:\n\t\txsnprintf(s, sizeof s, \"%4u: %s: (flag) %s\",\n\t\t    code, tty_term_codes[code].name,\n\t\t    term->codes[code].value.flag ? \"true\" : \"false\");\n\t\tbreak;\n\t}\n\treturn (s);\n}\n"
        },
        {
          "name": "tty.c",
          "type": "blob",
          "size": 43.103515625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/ioctl.h>\n\n#include <netinet/in.h>\n\n#include <errno.h>\n#include <fcntl.h>\n#include <resolv.h>\n#include <stdlib.h>\n#include <string.h>\n#include <termios.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n\nstatic int tty_log_fd = -1;\n\nvoid\ttty_read_callback(struct bufferevent *, void *);\nvoid\ttty_error_callback(struct bufferevent *, short, void *);\n\nstatic int tty_same_fg(const struct grid_cell *, const struct grid_cell *);\nstatic int tty_same_bg(const struct grid_cell *, const struct grid_cell *);\nstatic int tty_same_colours(const struct grid_cell *, const struct grid_cell *);\nstatic int tty_is_fg(const struct grid_cell *, int);\nstatic int tty_is_bg(const struct grid_cell *, int);\n\nvoid\ttty_set_italics(struct tty *);\nint\ttty_try_256(struct tty *, u_char, const char *);\nint\ttty_try_rgb(struct tty *, const struct grid_cell_rgb *, const char *);\n\nvoid\ttty_colours(struct tty *, const struct grid_cell *);\nvoid\ttty_check_fg(struct tty *, struct grid_cell *);\nvoid\ttty_check_bg(struct tty *, struct grid_cell *);\nvoid\ttty_colours_fg(struct tty *, const struct grid_cell *);\nvoid\ttty_colours_bg(struct tty *, const struct grid_cell *);\n\nint\ttty_large_region(struct tty *, const struct tty_ctx *);\nint\ttty_fake_bce(const struct tty *, const struct window_pane *);\nvoid\ttty_redraw_region(struct tty *, const struct tty_ctx *);\nvoid\ttty_emulate_repeat(struct tty *, enum tty_code_code, enum tty_code_code,\n\t    u_int);\nvoid\ttty_repeat_space(struct tty *, u_int);\nvoid\ttty_cell(struct tty *, const struct grid_cell *,\n\t    const struct window_pane *);\nvoid\ttty_default_colours(struct grid_cell *, const struct window_pane *);\n\n#define tty_use_acs(tty) \\\n\t(tty_term_has((tty)->term, TTYC_ACSC) && !((tty)->flags & TTY_UTF8))\n\n#define tty_pane_full_width(tty, ctx) \\\n\t((ctx)->xoff == 0 && screen_size_x((ctx)->wp->screen) >= (tty)->sx)\n\nstatic int\ntty_same_fg(const struct grid_cell *gc1, const struct grid_cell *gc2)\n{\n\tint\tflags1, flags2;\n\n\tflags1 = (gc1->flags & (GRID_FLAG_FG256|GRID_FLAG_FGRGB));\n\tflags2 = (gc2->flags & (GRID_FLAG_FG256|GRID_FLAG_FGRGB));\n\n\tif (flags1 != flags2)\n\t    return (0);\n\n\tif (flags1 & GRID_FLAG_FGRGB) {\n\t\tif (gc1->fg_rgb.r != gc2->fg_rgb.r)\n\t\t\treturn (0);\n\t\tif (gc1->fg_rgb.g != gc2->fg_rgb.g)\n\t\t\treturn (0);\n\t\tif (gc1->fg_rgb.b != gc2->fg_rgb.b)\n\t\t\treturn (0);\n\t\treturn (1);\n\t}\n\treturn (gc1->fg == gc2->fg);\n}\n\nstatic int\ntty_same_bg(const struct grid_cell *gc1, const struct grid_cell *gc2)\n{\n\tint\tflags1, flags2;\n\n\tflags1 = (gc1->flags & (GRID_FLAG_BG256|GRID_FLAG_BGRGB));\n\tflags2 = (gc2->flags & (GRID_FLAG_BG256|GRID_FLAG_BGRGB));\n\n\tif (flags1 != flags2)\n\t    return (0);\n\n\tif (flags1 & GRID_FLAG_BGRGB) {\n\t\tif (gc1->bg_rgb.r != gc2->bg_rgb.r)\n\t\t\treturn (0);\n\t\tif (gc1->bg_rgb.g != gc2->bg_rgb.g)\n\t\t\treturn (0);\n\t\tif (gc1->bg_rgb.b != gc2->bg_rgb.b)\n\t\t\treturn (0);\n\t\treturn (1);\n\t}\n\treturn (gc1->bg == gc2->bg);\n}\n\nstatic int\ntty_same_colours(const struct grid_cell *gc1, const struct grid_cell *gc2)\n{\n\treturn (tty_same_fg(gc1, gc2) && tty_same_bg(gc1, gc2));\n}\n\nstatic int\ntty_is_fg(const struct grid_cell *gc, int c)\n{\n\tif (gc->flags & (GRID_FLAG_FG256|GRID_FLAG_FGRGB))\n\t\treturn (0);\n\treturn (gc->fg == c);\n}\n\nstatic int\ntty_is_bg(const struct grid_cell *gc, int c)\n{\n\tif (gc->flags & (GRID_FLAG_BG256|GRID_FLAG_BGRGB))\n\t\treturn (0);\n\treturn (gc->bg == c);\n}\n\nvoid\ntty_create_log(void)\n{\n\tchar\tname[64];\n\n\txsnprintf(name, sizeof name, \"tmate-out-%ld.log\", (long)getpid());\n\n\ttty_log_fd = open(name, O_WRONLY|O_CREAT|O_TRUNC, 0644);\n\tif (tty_log_fd != -1 && fcntl(tty_log_fd, F_SETFD, FD_CLOEXEC) == -1)\n\t\tfatal(\"fcntl failed\");\n}\n\nint\ntty_init(struct tty *tty, struct client *c, int fd, char *term)\n{\n\tchar\t*path;\n\n\tif (!isatty(fd))\n\t\treturn (-1);\n\n\tmemset(tty, 0, sizeof *tty);\n\n\tif (term == NULL || *term == '\\0')\n\t\ttty->termname = xstrdup(\"unknown\");\n\telse\n\t\ttty->termname = xstrdup(term);\n\ttty->fd = fd;\n\ttty->client = c;\n\n\tif ((path = ttyname(fd)) == NULL)\n\t\treturn (-1);\n\ttty->path = xstrdup(path);\n\ttty->cstyle = 0;\n\ttty->ccolour = xstrdup(\"\");\n\n\ttty->flags = 0;\n\ttty->term_flags = 0;\n\n\treturn (0);\n}\n\nint\ntty_resize(struct tty *tty)\n{\n\tstruct winsize\tws;\n\tu_int\t\tsx, sy;\n\n\tif (ioctl(tty->fd, TIOCGWINSZ, &ws) != -1) {\n\t\tsx = ws.ws_col;\n\t\tif (sx == 0)\n\t\t\tsx = 80;\n\t\tsy = ws.ws_row;\n\t\tif (sy == 0)\n\t\t\tsy = 24;\n\t} else {\n\t\tsx = 80;\n\t\tsy = 24;\n\t}\n\tif (!tty_set_size(tty, sx, sy))\n\t\treturn (0);\n\n\ttty->cx = UINT_MAX;\n\ttty->cy = UINT_MAX;\n\n\ttty->rupper = UINT_MAX;\n\ttty->rlower = UINT_MAX;\n\n\t/*\n\t * If the terminal has been started, reset the actual scroll region and\n\t * cursor position, as this may not have happened.\n\t */\n\tif (tty->flags & TTY_STARTED) {\n\t\ttty_cursor(tty, 0, 0);\n\t\ttty_region(tty, 0, tty->sy - 1);\n\t}\n\n\treturn (1);\n}\n\nint\ntty_set_size(struct tty *tty, u_int sx, u_int sy) {\n\tif (sx == tty->sx && sy == tty->sy)\n\t\treturn (0);\n\ttty->sx = sx;\n\ttty->sy = sy;\n\treturn (1);\n}\n\nint\ntty_open(struct tty *tty, char **cause)\n{\n\ttty->term = tty_term_find(tty->termname, tty->fd, cause);\n\tif (tty->term == NULL) {\n\t\ttty_close(tty);\n\t\treturn (-1);\n\t}\n\ttty->flags |= TTY_OPENED;\n\n\ttty->flags &= ~(TTY_NOCURSOR|TTY_FREEZE|TTY_TIMER);\n\n\ttty->event = bufferevent_new(tty->fd, tty_read_callback, NULL,\n\t    tty_error_callback, tty);\n\n\ttty_start_tty(tty);\n\n\ttty_keys_build(tty);\n\n\treturn (0);\n}\n\nvoid\ntty_read_callback(__unused struct bufferevent *bufev, void *data)\n{\n\tstruct tty\t*tty = data;\n\n\twhile (tty_keys_next(tty))\n\t\t;\n}\n\nvoid\ntty_error_callback(__unused struct bufferevent *bufev, __unused short what,\n    __unused void *data)\n{\n}\n\nvoid\ntty_init_termios(int fd, struct termios *orig_tio, struct bufferevent *bufev)\n{\n\tstruct termios\ttio;\n\n\tif (fd == -1 || tcgetattr(fd, orig_tio) != 0)\n\t\treturn;\n\n\tsetblocking(fd, 0);\n\n\tif (bufev != NULL)\n\t\tbufferevent_enable(bufev, EV_READ|EV_WRITE);\n\n\tmemcpy(&tio, orig_tio, sizeof tio);\n\ttio.c_iflag &= ~(IXON|IXOFF|ICRNL|INLCR|IGNCR|IMAXBEL|ISTRIP);\n\ttio.c_iflag |= IGNBRK;\n\ttio.c_oflag &= ~(OPOST|ONLCR|OCRNL|ONLRET);\n\ttio.c_lflag &= ~(IEXTEN|ICANON|ECHO|ECHOE|ECHONL|ECHOCTL|\n\t    ECHOPRT|ECHOKE|ISIG);\n\ttio.c_cc[VMIN] = 1;\n\ttio.c_cc[VTIME] = 0;\n\tif (tcsetattr(fd, TCSANOW, &tio) == 0)\n\t\ttcflush(fd, TCIOFLUSH);\n}\n\nvoid\ntty_start_tty(struct tty *tty)\n{\n\ttty_init_termios(tty->fd, &tty->tio, tty->event);\n\n\ttty_putcode(tty, TTYC_SMCUP);\n\n\ttty_putcode(tty, TTYC_SGR0);\n\tmemcpy(&tty->cell, &grid_default_cell, sizeof tty->cell);\n\n\ttty_putcode(tty, TTYC_RMKX);\n\tif (tty_use_acs(tty))\n\t\ttty_putcode(tty, TTYC_ENACS);\n\ttty_putcode(tty, TTYC_CLEAR);\n\n\ttty_putcode(tty, TTYC_CNORM);\n\tif (tty_term_has(tty->term, TTYC_KMOUS))\n\t\ttty_puts(tty, \"\\033[?1000l\\033[?1002l\\033[?1006l\\033[?1005l\");\n\n\tif (tty_term_flag(tty->term, TTYC_XT)) {\n\t\tif (options_get_number(global_options, \"focus-events\")) {\n\t\t\ttty->flags |= TTY_FOCUS;\n\t\t\ttty_puts(tty, \"\\033[?1004h\");\n\t\t}\n\t}\n\n\ttty->cx = UINT_MAX;\n\ttty->cy = UINT_MAX;\n\n\ttty->rlower = UINT_MAX;\n\ttty->rupper = UINT_MAX;\n\n\ttty->mode = MODE_CURSOR;\n\n\ttty->flags |= TTY_STARTED;\n\n\ttty_force_cursor_colour(tty, \"\");\n\n\ttty->mouse_drag_flag = 0;\n\ttty->mouse_drag_update = NULL;\n\ttty->mouse_drag_release = NULL;\n}\n\nvoid\ntty_stop_tty(struct tty *tty)\n{\n\tstruct winsize\tws;\n\n\tif (!(tty->flags & TTY_STARTED))\n\t\treturn;\n\ttty->flags &= ~TTY_STARTED;\n\n\tbufferevent_disable(tty->event, EV_READ|EV_WRITE);\n\n\t/*\n\t * Be flexible about error handling and try not kill the server just\n\t * because the fd is invalid. Things like ssh -t can easily leave us\n\t * with a dead tty.\n\t */\n\tif (ioctl(tty->fd, TIOCGWINSZ, &ws) == -1)\n\t\treturn;\n\tif (tcsetattr(tty->fd, TCSANOW, &tty->tio) == -1)\n\t\treturn;\n\n\ttty_raw(tty, tty_term_string2(tty->term, TTYC_CSR, 0, ws.ws_row - 1));\n\tif (tty_use_acs(tty))\n\t\ttty_raw(tty, tty_term_string(tty->term, TTYC_RMACS));\n\ttty_raw(tty, tty_term_string(tty->term, TTYC_SGR0));\n\ttty_raw(tty, tty_term_string(tty->term, TTYC_RMKX));\n\ttty_raw(tty, tty_term_string(tty->term, TTYC_CLEAR));\n\tif (tty_term_has(tty->term, TTYC_SS) && tty->cstyle != 0) {\n\t\tif (tty_term_has(tty->term, TTYC_SE))\n\t\t\ttty_raw(tty, tty_term_string(tty->term, TTYC_SE));\n\t\telse\n\t\t\ttty_raw(tty, tty_term_string1(tty->term, TTYC_SS, 0));\n\t}\n\tif (tty->mode & MODE_BRACKETPASTE)\n\t\ttty_raw(tty, \"\\033[?2004l\");\n\ttty_raw(tty, tty_term_string(tty->term, TTYC_CR));\n\n\ttty_raw(tty, tty_term_string(tty->term, TTYC_CNORM));\n\tif (tty_term_has(tty->term, TTYC_KMOUS))\n\t\ttty_raw(tty, \"\\033[?1000l\\033[?1002l\\033[?1006l\\033[?1005l\");\n\n\tif (tty_term_flag(tty->term, TTYC_XT)) {\n\t\tif (tty->flags & TTY_FOCUS) {\n\t\t\ttty->flags &= ~TTY_FOCUS;\n\t\t\ttty_raw(tty, \"\\033[?1004l\");\n\t\t}\n\t}\n\n\ttty_raw(tty, tty_term_string(tty->term, TTYC_RMCUP));\n\n\tsetblocking(tty->fd, 1);\n}\n\nvoid\ntty_close(struct tty *tty)\n{\n\tif (event_initialized(&tty->key_timer))\n\t\tevtimer_del(&tty->key_timer);\n\ttty_stop_tty(tty);\n\n\tif (tty->flags & TTY_OPENED) {\n\t\tbufferevent_free(tty->event);\n\n\t\ttty_term_free(tty->term);\n\t\ttty_keys_free(tty);\n\n\t\ttty->flags &= ~TTY_OPENED;\n\t}\n\n\tif (tty->fd != -1) {\n\t\tclose(tty->fd);\n\t\ttty->fd = -1;\n\t}\n}\n\nvoid\ntty_free(struct tty *tty)\n{\n\ttty_close(tty);\n\n\tfree(tty->ccolour);\n\tfree(tty->path);\n\tfree(tty->termname);\n}\n\nvoid\ntty_raw(struct tty *tty, const char *s)\n{\n\tssize_t\tn, slen;\n\tu_int\ti;\n\n\tslen = strlen(s);\n\tfor (i = 0; i < 5; i++) {\n\t\tn = write(tty->fd, s, slen);\n\t\tif (n >= 0) {\n\t\t\ts += n;\n\t\t\tslen -= n;\n\t\t\tif (slen == 0)\n\t\t\t\tbreak;\n\t\t} else if (n == -1 && errno != EAGAIN)\n\t\t\tbreak;\n\t\tusleep(100);\n\t}\n}\n\nvoid\ntty_putcode(struct tty *tty, enum tty_code_code code)\n{\n\ttty_puts(tty, tty_term_string(tty->term, code));\n}\n\nvoid\ntty_putcode1(struct tty *tty, enum tty_code_code code, int a)\n{\n\tif (a < 0)\n\t\treturn;\n\ttty_puts(tty, tty_term_string1(tty->term, code, a));\n}\n\nvoid\ntty_putcode2(struct tty *tty, enum tty_code_code code, int a, int b)\n{\n\tif (a < 0 || b < 0)\n\t\treturn;\n\ttty_puts(tty, tty_term_string2(tty->term, code, a, b));\n}\n\nvoid\ntty_putcode_ptr1(struct tty *tty, enum tty_code_code code, const void *a)\n{\n\tif (a != NULL)\n\t\ttty_puts(tty, tty_term_ptr1(tty->term, code, a));\n}\n\nvoid\ntty_putcode_ptr2(struct tty *tty, enum tty_code_code code, const void *a,\n    const void *b)\n{\n\tif (a != NULL && b != NULL)\n\t\ttty_puts(tty, tty_term_ptr2(tty->term, code, a, b));\n}\n\nvoid\ntty_puts(struct tty *tty, const char *s)\n{\n\tif (*s == '\\0')\n\t\treturn;\n\tbufferevent_write(tty->event, s, strlen(s));\n\n\tif (tty_log_fd != -1)\n\t\twrite(tty_log_fd, s, strlen(s));\n}\n\nvoid\ntty_putc(struct tty *tty, u_char ch)\n{\n\tconst char\t*acs;\n\tu_int\t\t sx;\n\n\tif (tty->cell.attr & GRID_ATTR_CHARSET) {\n\t\tacs = tty_acs_get(tty, ch);\n\t\tif (acs != NULL)\n\t\t\tbufferevent_write(tty->event, acs, strlen(acs));\n\t\telse\n\t\t\tbufferevent_write(tty->event, &ch, 1);\n\t} else\n\t\tbufferevent_write(tty->event, &ch, 1);\n\n\tif (ch >= 0x20 && ch != 0x7f) {\n\t\tsx = tty->sx;\n\t\tif (tty->term->flags & TERM_EARLYWRAP)\n\t\t\tsx--;\n\n\t\tif (tty->cx >= sx) {\n\t\t\ttty->cx = 1;\n\t\t\tif (tty->cy != tty->rlower)\n\t\t\t\ttty->cy++;\n\t\t} else\n\t\t\ttty->cx++;\n\t}\n\n\tif (tty_log_fd != -1)\n\t\twrite(tty_log_fd, &ch, 1);\n}\n\nvoid\ntty_putn(struct tty *tty, const void *buf, size_t len, u_int width)\n{\n\tbufferevent_write(tty->event, buf, len);\n\tif (tty_log_fd != -1)\n\t\twrite(tty_log_fd, buf, len);\n\ttty->cx += width;\n}\n\nvoid\ntty_set_italics(struct tty *tty)\n{\n\tconst char\t*s;\n\n\tif (tty_term_has(tty->term, TTYC_SITM)) {\n\t\ts = options_get_string(global_options, \"default-terminal\");\n\t\tif (strcmp(s, \"screen\") != 0 && strncmp(s, \"screen-\", 7) != 0) {\n\t\t\ttty_putcode(tty, TTYC_SITM);\n\t\t\treturn;\n\t\t}\n\t}\n\ttty_putcode(tty, TTYC_SMSO);\n}\n\nvoid\ntty_set_title(struct tty *tty, const char *title)\n{\n\tif (!tty_term_has(tty->term, TTYC_TSL) ||\n\t    !tty_term_has(tty->term, TTYC_FSL))\n\t\treturn;\n\n\ttty_putcode(tty, TTYC_TSL);\n\ttty_puts(tty, title);\n\ttty_putcode(tty, TTYC_FSL);\n}\n\nvoid\ntty_force_cursor_colour(struct tty *tty, const char *ccolour)\n{\n\tif (*ccolour == '\\0')\n\t\ttty_putcode(tty, TTYC_CR);\n\telse\n\t\ttty_putcode_ptr1(tty, TTYC_CS, ccolour);\n\tfree(tty->ccolour);\n\ttty->ccolour = xstrdup(ccolour);\n}\n\nvoid\ntty_update_mode(struct tty *tty, int mode, struct screen *s)\n{\n\tint\tchanged;\n\n\tif (s != NULL && strcmp(s->ccolour, tty->ccolour) != 0)\n\t\ttty_force_cursor_colour(tty, s->ccolour);\n\n\tif (tty->flags & TTY_NOCURSOR)\n\t\tmode &= ~MODE_CURSOR;\n\n\tchanged = mode ^ tty->mode;\n\tif (changed & MODE_BLINKING) {\n\t\tif (tty_term_has(tty->term, TTYC_CVVIS))\n\t\t\ttty_putcode(tty, TTYC_CVVIS);\n\t\telse\n\t\t\ttty_putcode(tty, TTYC_CNORM);\n\t\tchanged |= MODE_CURSOR;\n\t}\n\tif (changed & MODE_CURSOR) {\n\t\tif (mode & MODE_CURSOR)\n\t\t\ttty_putcode(tty, TTYC_CNORM);\n\t\telse\n\t\t\ttty_putcode(tty, TTYC_CIVIS);\n\t}\n\tif (s != NULL && tty->cstyle != s->cstyle) {\n\t\tif (tty_term_has(tty->term, TTYC_SS)) {\n\t\t\tif (s->cstyle == 0 &&\n\t\t\t    tty_term_has(tty->term, TTYC_SE))\n\t\t\t\ttty_putcode(tty, TTYC_SE);\n\t\t\telse\n\t\t\t\ttty_putcode1(tty, TTYC_SS, s->cstyle);\n\t\t}\n\t\ttty->cstyle = s->cstyle;\n\t}\n\tif (changed & ALL_MOUSE_MODES) {\n\t\tif (mode & ALL_MOUSE_MODES) {\n\t\t\t/*\n\t\t\t * Enable the SGR (1006) extension unconditionally, as\n\t\t\t * this is safe from misinterpretation. Do it in this\n\t\t\t * order, because in some terminals it's the last one\n\t\t\t * that takes effect and SGR is the preferred one.\n\t\t\t */\n\t\t\ttty_puts(tty, \"\\033[?1006h\");\n\t\t\tif (mode & MODE_MOUSE_BUTTON)\n\t\t\t\ttty_puts(tty, \"\\033[?1002h\");\n\t\t\telse if (mode & MODE_MOUSE_STANDARD)\n\t\t\t\ttty_puts(tty, \"\\033[?1000h\");\n\t\t} else {\n\t\t\tif (tty->mode & MODE_MOUSE_BUTTON)\n\t\t\t\ttty_puts(tty, \"\\033[?1002l\");\n\t\t\telse if (tty->mode & MODE_MOUSE_STANDARD)\n\t\t\t\ttty_puts(tty, \"\\033[?1000l\");\n\t\t\ttty_puts(tty, \"\\033[?1006l\");\n\t\t}\n\t}\n\tif (changed & MODE_KKEYPAD) {\n\t\tif (mode & MODE_KKEYPAD)\n\t\t\ttty_putcode(tty, TTYC_SMKX);\n\t\telse\n\t\t\ttty_putcode(tty, TTYC_RMKX);\n\t}\n\tif (changed & MODE_BRACKETPASTE) {\n\t\tif (mode & MODE_BRACKETPASTE)\n\t\t\ttty_puts(tty, \"\\033[?2004h\");\n\t\telse\n\t\t\ttty_puts(tty, \"\\033[?2004l\");\n\t}\n\ttty->mode = mode;\n}\n\nvoid\ntty_emulate_repeat(struct tty *tty, enum tty_code_code code,\n    enum tty_code_code code1, u_int n)\n{\n\tif (tty_term_has(tty->term, code))\n\t\ttty_putcode1(tty, code, n);\n\telse {\n\t\twhile (n-- > 0)\n\t\t\ttty_putcode(tty, code1);\n\t}\n}\n\nvoid\ntty_repeat_space(struct tty *tty, u_int n)\n{\n\twhile (n-- > 0)\n\t\ttty_putc(tty, ' ');\n}\n\n/*\n * Is the region large enough to be worth redrawing once later rather than\n * probably several times now? Currently yes if it is more than 50% of the\n * pane.\n */\nint\ntty_large_region(__unused struct tty *tty, const struct tty_ctx *ctx)\n{\n\tstruct window_pane\t*wp = ctx->wp;\n\n\treturn (ctx->orlower - ctx->orupper >= screen_size_y(wp->screen) / 2);\n}\n\n/*\n * Return if BCE is needed but the terminal doesn't have it - it'll need to be\n * emulated.\n */\nint\ntty_fake_bce(const struct tty *tty, const struct window_pane *wp)\n{\n\tstruct grid_cell\tgc;\n\n\tmemcpy(&gc, &grid_default_cell, sizeof gc);\n\ttty_default_colours(&gc, wp);\n\n\tif (gc.bg == 8 && !(gc.flags & GRID_FLAG_BG256))\n\t\treturn (0);\n\treturn (!tty_term_flag(tty->term, TTYC_BCE));\n}\n\n/*\n * Redraw scroll region using data from screen (already updated). Used when\n * CSR not supported, or window is a pane that doesn't take up the full\n * width of the terminal.\n */\nvoid\ntty_redraw_region(struct tty *tty, const struct tty_ctx *ctx)\n{\n\tstruct window_pane\t*wp = ctx->wp;\n\tstruct screen\t\t*s = wp->screen;\n\tu_int\t\t \t i;\n\n\t/*\n\t * If region is large, schedule a window redraw. In most cases this is\n\t * likely to be followed by some more scrolling.\n\t */\n\tif (tty_large_region(tty, ctx)) {\n\t\twp->flags |= PANE_REDRAW;\n\t\treturn;\n\t}\n\n\tif (ctx->ocy < ctx->orupper || ctx->ocy > ctx->orlower) {\n\t\tfor (i = ctx->ocy; i < screen_size_y(s); i++)\n\t\t\ttty_draw_pane(tty, wp, i, ctx->xoff, ctx->yoff);\n\t} else {\n\t\tfor (i = ctx->orupper; i <= ctx->orlower; i++)\n\t\t\ttty_draw_pane(tty, wp, i, ctx->xoff, ctx->yoff);\n\t}\n}\n\nvoid\ntty_draw_pane(struct tty *tty, const struct window_pane *wp, u_int py, u_int ox,\n    u_int oy)\n{\n\ttty_draw_line(tty, wp, wp->screen, py, ox, oy);\n}\n\nvoid\ntty_draw_line(struct tty *tty, const struct window_pane *wp,\n    struct screen *s, u_int py, u_int ox, u_int oy)\n{\n\tstruct grid_cell\t gc;\n\tstruct grid_line\t*gl;\n\tu_int\t\t\t i, sx;\n\tint\t\t\t flags;\n\n\tflags = tty->flags & TTY_NOCURSOR;\n\ttty->flags |= TTY_NOCURSOR;\n\ttty_update_mode(tty, tty->mode, s);\n\n\tsx = screen_size_x(s);\n\tif (sx > s->grid->linedata[s->grid->hsize + py].cellsize)\n\t\tsx = s->grid->linedata[s->grid->hsize + py].cellsize;\n\tif (sx > tty->sx)\n\t\tsx = tty->sx;\n\n\t/*\n\t * Don't move the cursor to the start position if it will wrap there\n\t * itself.\n\t */\n\tgl = NULL;\n\tif (py != 0)\n\t\tgl = &s->grid->linedata[s->grid->hsize + py - 1];\n\tif (oy + py == 0 || gl == NULL || !(gl->flags & GRID_LINE_WRAPPED) ||\n\t    tty->cx < tty->sx || ox != 0 ||\n\t    (oy + py != tty->cy + 1 && tty->cy != s->rlower + oy))\n\t\ttty_cursor(tty, ox, oy + py);\n\n\tfor (i = 0; i < sx; i++) {\n\t\tgrid_view_get_cell(s->grid, i, py, &gc);\n\t\tif (screen_check_selection(s, i, py)) {\n\t\t\tgc.flags &= ~(GRID_FLAG_FG256|GRID_FLAG_BG256);\n\t\t\tgc.flags |= s->sel.cell.flags &\n\t\t\t    (GRID_FLAG_FG256|GRID_FLAG_BG256);\n\t\t}\n\t\ttty_cell(tty, &gc, wp);\n\t}\n\n\tif (sx < tty->sx) {\n\t\ttty_attributes(tty, &grid_default_cell, wp);\n\n\t\ttty_cursor(tty, ox + sx, oy + py);\n\t\tif (sx != screen_size_x(s) &&\n\t\t    ox + screen_size_x(s) >= tty->sx &&\n\t\t    tty_term_has(tty->term, TTYC_EL) &&\n\t\t    !tty_fake_bce(tty, wp))\n\t\t\ttty_putcode(tty, TTYC_EL);\n\t\telse\n\t\t\ttty_repeat_space(tty, screen_size_x(s) - sx);\n\t}\n\n\ttty->flags = (tty->flags & ~TTY_NOCURSOR) | flags;\n\ttty_update_mode(tty, tty->mode, s);\n}\n\nint\ntty_client_ready(struct client *c, struct window_pane *wp)\n{\n\tif (c->session == NULL || c->tty.term == NULL)\n\t\treturn (0);\n\tif (c->flags & CLIENT_SUSPENDED)\n\t\treturn (0);\n\tif (c->tty.flags & TTY_FREEZE)\n\t\treturn (0);\n\tif (c->session->curw->window != wp->window)\n\t\treturn (0);\n\treturn (1);\n}\n\nvoid\ntty_write(void (*cmdfn)(struct tty *, const struct tty_ctx *),\n    struct tty_ctx *ctx)\n{\n\tstruct window_pane\t*wp = ctx->wp;\n\tstruct client\t\t*c;\n\n\t/* wp can be NULL if updating the screen but not the terminal. */\n\tif (wp == NULL)\n\t\treturn;\n\n\tif (wp->window->flags & WINDOW_REDRAW || wp->flags & PANE_REDRAW)\n\t\treturn;\n\tif (!window_pane_visible(wp) || wp->flags & PANE_DROP)\n\t\treturn;\n\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (!tty_client_ready(c, wp))\n\t\t\tcontinue;\n\n\t\tctx->xoff = wp->xoff;\n\t\tctx->yoff = wp->yoff;\n\t\tif (status_at_line(c) == 0)\n\t\t\tctx->yoff++;\n\n\t\tcmdfn(&c->tty, ctx);\n\t}\n}\n\nvoid\ntty_cmd_insertcharacter(struct tty *tty, const struct tty_ctx *ctx)\n{\n\tstruct window_pane\t*wp = ctx->wp;\n\n\tif (!tty_pane_full_width(tty, ctx)) {\n\t\ttty_draw_pane(tty, wp, ctx->ocy, ctx->xoff, ctx->yoff);\n\t\treturn;\n\t}\n\n\ttty_attributes(tty, &grid_default_cell, wp);\n\n\ttty_cursor_pane(tty, ctx, ctx->ocx, ctx->ocy);\n\n\tif (!tty_fake_bce(tty, wp) && (tty_term_has(tty->term, TTYC_ICH) ||\n\t    tty_term_has(tty->term, TTYC_ICH1)))\n\t\ttty_emulate_repeat(tty, TTYC_ICH, TTYC_ICH1, ctx->num);\n\telse\n\t\ttty_draw_pane(tty, wp, ctx->ocy, ctx->xoff, ctx->yoff);\n}\n\nvoid\ntty_cmd_deletecharacter(struct tty *tty, const struct tty_ctx *ctx)\n{\n\tstruct window_pane\t*wp = ctx->wp;\n\n\tif (!tty_pane_full_width(tty, ctx) || tty_fake_bce(tty, wp) ||\n\t    (!tty_term_has(tty->term, TTYC_DCH) &&\n\t    !tty_term_has(tty->term, TTYC_DCH1))) {\n\t\ttty_draw_pane(tty, wp, ctx->ocy, ctx->xoff, ctx->yoff);\n\t\treturn;\n\t}\n\n\ttty_attributes(tty, &grid_default_cell, wp);\n\n\ttty_cursor_pane(tty, ctx, ctx->ocx, ctx->ocy);\n\n\tif (tty_term_has(tty->term, TTYC_DCH) ||\n\t    tty_term_has(tty->term, TTYC_DCH1))\n\t\ttty_emulate_repeat(tty, TTYC_DCH, TTYC_DCH1, ctx->num);\n}\n\nvoid\ntty_cmd_clearcharacter(struct tty *tty, const struct tty_ctx *ctx)\n{\n\tu_int\ti;\n\n\ttty_attributes(tty, &grid_default_cell, ctx->wp);\n\n\ttty_cursor_pane(tty, ctx, ctx->ocx, ctx->ocy);\n\n\tif (tty_term_has(tty->term, TTYC_ECH) && !tty_fake_bce(tty, ctx->wp))\n\t\ttty_putcode1(tty, TTYC_ECH, ctx->num);\n\telse {\n\t\tfor (i = 0; i < ctx->num; i++)\n\t\t\ttty_putc(tty, ' ');\n\t}\n}\n\nvoid\ntty_cmd_insertline(struct tty *tty, const struct tty_ctx *ctx)\n{\n\tif (!tty_pane_full_width(tty, ctx) || tty_fake_bce(tty, ctx->wp) ||\n\t    !tty_term_has(tty->term, TTYC_CSR) ||\n\t    !tty_term_has(tty->term, TTYC_IL1)) {\n\t\ttty_redraw_region(tty, ctx);\n\t\treturn;\n\t}\n\n\ttty_attributes(tty, &grid_default_cell, ctx->wp);\n\n\ttty_region_pane(tty, ctx, ctx->orupper, ctx->orlower);\n\ttty_cursor_pane(tty, ctx, ctx->ocx, ctx->ocy);\n\n\ttty_emulate_repeat(tty, TTYC_IL, TTYC_IL1, ctx->num);\n}\n\nvoid\ntty_cmd_deleteline(struct tty *tty, const struct tty_ctx *ctx)\n{\n\tif (!tty_pane_full_width(tty, ctx) || tty_fake_bce(tty, ctx->wp) ||\n\t    !tty_term_has(tty->term, TTYC_CSR) ||\n\t    !tty_term_has(tty->term, TTYC_DL1)) {\n\t\ttty_redraw_region(tty, ctx);\n\t\treturn;\n\t}\n\n\ttty_attributes(tty, &grid_default_cell, ctx->wp);\n\n\ttty_region_pane(tty, ctx, ctx->orupper, ctx->orlower);\n\ttty_cursor_pane(tty, ctx, ctx->ocx, ctx->ocy);\n\n\ttty_emulate_repeat(tty, TTYC_DL, TTYC_DL1, ctx->num);\n}\n\nvoid\ntty_cmd_clearline(struct tty *tty, const struct tty_ctx *ctx)\n{\n\tstruct window_pane\t*wp = ctx->wp;\n\tstruct screen\t\t*s = wp->screen;\n\n\ttty_attributes(tty, &grid_default_cell, wp);\n\n\ttty_cursor_pane(tty, ctx, 0, ctx->ocy);\n\n\tif (tty_pane_full_width(tty, ctx) && !tty_fake_bce(tty, wp) &&\n\t    tty_term_has(tty->term, TTYC_EL))\n\t\ttty_putcode(tty, TTYC_EL);\n\telse\n\t\ttty_repeat_space(tty, screen_size_x(s));\n}\n\nvoid\ntty_cmd_clearendofline(struct tty *tty, const struct tty_ctx *ctx)\n{\n\tstruct window_pane\t*wp = ctx->wp;\n\tstruct screen\t\t*s = wp->screen;\n\n\ttty_attributes(tty, &grid_default_cell, wp);\n\n\ttty_cursor_pane(tty, ctx, ctx->ocx, ctx->ocy);\n\n\tif (tty_pane_full_width(tty, ctx) &&\n\t    tty_term_has(tty->term, TTYC_EL) && !tty_fake_bce(tty, wp))\n\t\ttty_putcode(tty, TTYC_EL);\n\telse\n\t\ttty_repeat_space(tty, screen_size_x(s) - ctx->ocx);\n}\n\nvoid\ntty_cmd_clearstartofline(struct tty *tty, const struct tty_ctx *ctx)\n{\n\ttty_attributes(tty, &grid_default_cell, ctx->wp);\n\n\tif (ctx->xoff == 0 && tty_term_has(tty->term, TTYC_EL1) &&\n\t    !tty_fake_bce(tty, ctx->wp)) {\n\t\ttty_cursor_pane(tty, ctx, ctx->ocx, ctx->ocy);\n\t\ttty_putcode(tty, TTYC_EL1);\n\t} else {\n\t\ttty_cursor_pane(tty, ctx, 0, ctx->ocy);\n\t\ttty_repeat_space(tty, ctx->ocx + 1);\n\t}\n}\n\nvoid\ntty_cmd_reverseindex(struct tty *tty, const struct tty_ctx *ctx)\n{\n\tif (ctx->ocy != ctx->orupper)\n\t\treturn;\n\n\tif (!tty_pane_full_width(tty, ctx) || tty_fake_bce(tty, ctx->wp) ||\n\t    !tty_term_has(tty->term, TTYC_CSR) ||\n\t    !tty_term_has(tty->term, TTYC_RI)) {\n\t\ttty_redraw_region(tty, ctx);\n\t\treturn;\n\t}\n\n\ttty_attributes(tty, &grid_default_cell, ctx->wp);\n\n\ttty_region_pane(tty, ctx, ctx->orupper, ctx->orlower);\n\ttty_cursor_pane(tty, ctx, ctx->ocx, ctx->orupper);\n\n\ttty_putcode(tty, TTYC_RI);\n}\n\nvoid\ntty_cmd_linefeed(struct tty *tty, const struct tty_ctx *ctx)\n{\n\tstruct window_pane\t*wp = ctx->wp;\n\n\tif (ctx->ocy != ctx->orlower)\n\t\treturn;\n\n\tif (!tty_pane_full_width(tty, ctx) || tty_fake_bce(tty, wp) ||\n\t    !tty_term_has(tty->term, TTYC_CSR)) {\n\t\tif (tty_large_region(tty, ctx))\n\t\t\twp->flags |= PANE_REDRAW;\n\t\telse\n\t\t\ttty_redraw_region(tty, ctx);\n\t\treturn;\n\t}\n\n\t/*\n\t * If this line wrapped naturally (ctx->num is nonzero), don't do\n\t * anything - the cursor can just be moved to the last cell and wrap\n\t * naturally.\n\t */\n\tif (ctx->num && !(tty->term->flags & TERM_EARLYWRAP))\n\t\treturn;\n\n\ttty_attributes(tty, &grid_default_cell, wp);\n\n\ttty_region_pane(tty, ctx, ctx->orupper, ctx->orlower);\n\ttty_cursor_pane(tty, ctx, ctx->ocx, ctx->ocy);\n\n\ttty_putc(tty, '\\n');\n}\n\nvoid\ntty_cmd_clearendofscreen(struct tty *tty, const struct tty_ctx *ctx)\n{\n\tstruct window_pane\t*wp = ctx->wp;\n\tstruct screen\t\t*s = wp->screen;\n\tu_int\t\t \t i, j;\n\n\ttty_attributes(tty, &grid_default_cell, wp);\n\n\ttty_region_pane(tty, ctx, 0, screen_size_y(s) - 1);\n\ttty_cursor_pane(tty, ctx, ctx->ocx, ctx->ocy);\n\n\tif (tty_pane_full_width(tty, ctx) &&\n\t    tty_term_has(tty->term, TTYC_EL) && !tty_fake_bce(tty, wp)) {\n\t\ttty_putcode(tty, TTYC_EL);\n\t\tif (ctx->ocy != screen_size_y(s) - 1) {\n\t\t\ttty_cursor_pane(tty, ctx, 0, ctx->ocy + 1);\n\t\t\tfor (i = ctx->ocy + 1; i < screen_size_y(s); i++) {\n\t\t\t\ttty_putcode(tty, TTYC_EL);\n\t\t\t\tif (i == screen_size_y(s) - 1)\n\t\t\t\t\tcontinue;\n\t\t\t\ttty_emulate_repeat(tty, TTYC_CUD, TTYC_CUD1, 1);\n\t\t\t\ttty->cy++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\ttty_repeat_space(tty, screen_size_x(s) - ctx->ocx);\n\t\tfor (j = ctx->ocy + 1; j < screen_size_y(s); j++) {\n\t\t\ttty_cursor_pane(tty, ctx, 0, j);\n\t\t\ttty_repeat_space(tty, screen_size_x(s));\n\t\t}\n\t}\n}\n\nvoid\ntty_cmd_clearstartofscreen(struct tty *tty, const struct tty_ctx *ctx)\n{\n\tstruct window_pane\t*wp = ctx->wp;\n\tstruct screen\t\t*s = wp->screen;\n\tu_int\t\t \t i, j;\n\n\ttty_attributes(tty, &grid_default_cell, wp);\n\n\ttty_region_pane(tty, ctx, 0, screen_size_y(s) - 1);\n\ttty_cursor_pane(tty, ctx, 0, 0);\n\n\tif (tty_pane_full_width(tty, ctx) &&\n\t    tty_term_has(tty->term, TTYC_EL) && !tty_fake_bce(tty, wp)) {\n\t\tfor (i = 0; i < ctx->ocy; i++) {\n\t\t\ttty_putcode(tty, TTYC_EL);\n\t\t\ttty_emulate_repeat(tty, TTYC_CUD, TTYC_CUD1, 1);\n\t\t\ttty->cy++;\n\t\t}\n\t} else {\n\t\tfor (j = 0; j < ctx->ocy; j++) {\n\t\t\ttty_cursor_pane(tty, ctx, 0, j);\n\t\t\ttty_repeat_space(tty, screen_size_x(s));\n\t\t}\n\t}\n\ttty_repeat_space(tty, ctx->ocx + 1);\n}\n\nvoid\ntty_cmd_clearscreen(struct tty *tty, const struct tty_ctx *ctx)\n{\n\tstruct window_pane\t*wp = ctx->wp;\n\tstruct screen\t\t*s = wp->screen;\n\tu_int\t\t \t i, j;\n\n\ttty_attributes(tty, &grid_default_cell, wp);\n\n\ttty_region_pane(tty, ctx, 0, screen_size_y(s) - 1);\n\ttty_cursor_pane(tty, ctx, 0, 0);\n\n\tif (tty_pane_full_width(tty, ctx) &&\n\t    tty_term_has(tty->term, TTYC_EL) && !tty_fake_bce(tty, wp)) {\n\t\tfor (i = 0; i < screen_size_y(s); i++) {\n\t\t\ttty_putcode(tty, TTYC_EL);\n\t\t\tif (i != screen_size_y(s) - 1) {\n\t\t\t\ttty_emulate_repeat(tty, TTYC_CUD, TTYC_CUD1, 1);\n\t\t\t\ttty->cy++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (j = 0; j < screen_size_y(s); j++) {\n\t\t\ttty_cursor_pane(tty, ctx, 0, j);\n\t\t\ttty_repeat_space(tty, screen_size_x(s));\n\t\t}\n\t}\n}\n\nvoid\ntty_cmd_alignmenttest(struct tty *tty, const struct tty_ctx *ctx)\n{\n\tstruct window_pane\t*wp = ctx->wp;\n\tstruct screen\t\t*s = wp->screen;\n\tu_int\t\t\t i, j;\n\n\ttty_attributes(tty, &grid_default_cell, wp);\n\n\ttty_region_pane(tty, ctx, 0, screen_size_y(s) - 1);\n\n\tfor (j = 0; j < screen_size_y(s); j++) {\n\t\ttty_cursor_pane(tty, ctx, 0, j);\n\t\tfor (i = 0; i < screen_size_x(s); i++)\n\t\t\ttty_putc(tty, 'E');\n\t}\n}\n\nvoid\ntty_cmd_cell(struct tty *tty, const struct tty_ctx *ctx)\n{\n\tstruct window_pane\t*wp = ctx->wp;\n\tstruct screen\t\t*s = wp->screen;\n\tu_int\t\t\t cx;\n\tu_int\t\t\t width;\n\n\ttty_region_pane(tty, ctx, ctx->orupper, ctx->orlower);\n\n\t/* Is the cursor in the very last position? */\n\twidth = ctx->cell->data.width;\n\tif (ctx->ocx > wp->sx - width) {\n\t\tif (ctx->xoff != 0 || wp->sx != tty->sx) {\n\t\t\t/*\n\t\t\t * The pane doesn't fill the entire line, the linefeed\n\t\t\t * will already have happened, so just move the cursor.\n\t\t\t */\n\t\t\tif (ctx->ocy != wp->yoff + wp->screen->rlower)\n\t\t\t\ttty_cursor_pane(tty, ctx, 0, ctx->ocy + 1);\n\t\t\telse\n\t\t\t\ttty_cursor_pane(tty, ctx, 0, ctx->ocy);\n\t\t} else if (tty->cx < tty->sx) {\n\t\t\t/*\n\t\t\t * The cursor isn't in the last position already, so\n\t\t\t * move as far left as possible and redraw the last\n\t\t\t * cell to move into the last position.\n\t\t\t */\n\t\t\tcx = screen_size_x(s) - ctx->last_cell.data.width;\n\t\t\ttty_cursor_pane(tty, ctx, cx, ctx->ocy);\n\t\t\ttty_cell(tty, &ctx->last_cell, wp);\n\t\t}\n\t} else\n\t\ttty_cursor_pane(tty, ctx, ctx->ocx, ctx->ocy);\n\n\ttty_cell(tty, ctx->cell, wp);\n}\n\nvoid\ntty_cmd_utf8character(struct tty *tty, const struct tty_ctx *ctx)\n{\n\tstruct window_pane\t*wp = ctx->wp;\n\n\t/*\n\t * Cannot rely on not being a partial character, so just redraw the\n\t * whole line.\n\t */\n\ttty_draw_pane(tty, wp, ctx->ocy, ctx->xoff, ctx->yoff);\n}\n\nvoid\ntty_cmd_setselection(struct tty *tty, const struct tty_ctx *ctx)\n{\n\tchar\t*buf;\n\tsize_t\t off;\n\n\tif (!tty_term_has(tty->term, TTYC_MS))\n\t\treturn;\n\n\toff = 4 * ((ctx->num + 2) / 3) + 1; /* storage for base64 */\n\tbuf = xmalloc(off);\n\n\tb64_ntop(ctx->ptr, ctx->num, buf, off);\n\ttty_putcode_ptr2(tty, TTYC_MS, \"\", buf);\n\n\tfree(buf);\n}\n\nvoid\ntty_cmd_rawstring(struct tty *tty, const struct tty_ctx *ctx)\n{\n\tu_int\t i;\n\tu_char\t*str = ctx->ptr;\n\n\tfor (i = 0; i < ctx->num; i++)\n\t\ttty_putc(tty, str[i]);\n\n\ttty->cx = tty->cy = UINT_MAX;\n\ttty->rupper = tty->rlower = UINT_MAX;\n\n\ttty_attributes(tty, &grid_default_cell, ctx->wp);\n\ttty_cursor(tty, 0, 0);\n}\n\nvoid\ntty_cell(struct tty *tty, const struct grid_cell *gc,\n    const struct window_pane *wp)\n{\n\tu_int\ti;\n\n\t/* Skip last character if terminal is stupid. */\n\tif (tty->term->flags & TERM_EARLYWRAP &&\n\t    tty->cy == tty->sy - 1 && tty->cx == tty->sx - 1)\n\t\treturn;\n\n\t/* If this is a padding character, do nothing. */\n\tif (gc->flags & GRID_FLAG_PADDING)\n\t\treturn;\n\n\t/* Set the attributes. */\n\ttty_attributes(tty, gc, wp);\n\n\t/* Get the cell and if ASCII write with putc to do ACS translation. */\n\tif (gc->data.size == 1) {\n\t\tif (*gc->data.data < 0x20 || *gc->data.data == 0x7f)\n\t\t\treturn;\n\t\ttty_putc(tty, *gc->data.data);\n\t\treturn;\n\t}\n\n\t/* If not UTF-8, write _. */\n\tif (!(tty->flags & TTY_UTF8)) {\n\t\tfor (i = 0; i < gc->data.width; i++)\n\t\t\ttty_putc(tty, '_');\n\t\treturn;\n\t}\n\n\t/* Write the data. */\n\ttty_putn(tty, gc->data.data, gc->data.size, gc->data.width);\n}\n\nvoid\ntty_reset(struct tty *tty)\n{\n\tstruct grid_cell\t*gc = &tty->cell;\n\n\tif (memcmp(gc, &grid_default_cell, sizeof *gc) == 0)\n\t\treturn;\n\n\tif ((gc->attr & GRID_ATTR_CHARSET) && tty_use_acs(tty))\n\t\ttty_putcode(tty, TTYC_RMACS);\n\ttty_putcode(tty, TTYC_SGR0);\n\tmemcpy(gc, &grid_default_cell, sizeof *gc);\n}\n\n/* Set region inside pane. */\nvoid\ntty_region_pane(struct tty *tty, const struct tty_ctx *ctx, u_int rupper,\n    u_int rlower)\n{\n\ttty_region(tty, ctx->yoff + rupper, ctx->yoff + rlower);\n}\n\n/* Set region at absolute position. */\nvoid\ntty_region(struct tty *tty, u_int rupper, u_int rlower)\n{\n\tif (tty->rlower == rlower && tty->rupper == rupper)\n\t\treturn;\n\tif (!tty_term_has(tty->term, TTYC_CSR))\n\t\treturn;\n\n\ttty->rupper = rupper;\n\ttty->rlower = rlower;\n\n\t/*\n\t * Some terminals (such as PuTTY) do not correctly reset the cursor to\n\t * 0,0 if it is beyond the last column (they do not reset their wrap\n\t * flag so further output causes a line feed). As a workaround, do an\n\t * explicit move to 0 first.\n\t */\n\tif (tty->cx >= tty->sx)\n\t\ttty_cursor(tty, 0, tty->cy);\n\n\ttty_putcode2(tty, TTYC_CSR, tty->rupper, tty->rlower);\n\ttty_cursor(tty, 0, 0);\n}\n\n/* Move cursor inside pane. */\nvoid\ntty_cursor_pane(struct tty *tty, const struct tty_ctx *ctx, u_int cx, u_int cy)\n{\n\ttty_cursor(tty, ctx->xoff + cx, ctx->yoff + cy);\n}\n\n/* Move cursor to absolute position. */\nvoid\ntty_cursor(struct tty *tty, u_int cx, u_int cy)\n{\n\tstruct tty_term\t*term = tty->term;\n\tu_int\t\t thisx, thisy;\n\tint\t\t change;\n\n\tif (cx > tty->sx - 1)\n\t\tcx = tty->sx - 1;\n\n\tthisx = tty->cx;\n\tthisy = tty->cy;\n\n\t/* No change. */\n\tif (cx == thisx && cy == thisy)\n\t\treturn;\n\n\t/* Very end of the line, just use absolute movement. */\n\tif (thisx > tty->sx - 1)\n\t\tgoto absolute;\n\n\t/* Move to home position (0, 0). */\n\tif (cx == 0 && cy == 0 && tty_term_has(term, TTYC_HOME)) {\n\t\ttty_putcode(tty, TTYC_HOME);\n\t\tgoto out;\n\t}\n\n\t/* Zero on the next line. */\n\tif (cx == 0 && cy == thisy + 1 && thisy != tty->rlower) {\n\t\ttty_putc(tty, '\\r');\n\t\ttty_putc(tty, '\\n');\n\t\tgoto out;\n\t}\n\n\t/* Moving column or row. */\n\tif (cy == thisy) {\n\t\t/*\n\t\t * Moving column only, row staying the same.\n\t\t */\n\n\t\t/* To left edge. */\n\t\tif (cx == 0)\t{\n\t\t\ttty_putc(tty, '\\r');\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* One to the left. */\n\t\tif (cx == thisx - 1 && tty_term_has(term, TTYC_CUB1)) {\n\t\t\ttty_putcode(tty, TTYC_CUB1);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* One to the right. */\n\t\tif (cx == thisx + 1 && tty_term_has(term, TTYC_CUF1)) {\n\t\t\ttty_putcode(tty, TTYC_CUF1);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Calculate difference. */\n\t\tchange = thisx - cx;\t/* +ve left, -ve right */\n\n\t\t/*\n\t\t * Use HPA if change is larger than absolute, otherwise move\n\t\t * the cursor with CUB/CUF.\n\t\t */\n\t\tif ((u_int) abs(change) > cx && tty_term_has(term, TTYC_HPA)) {\n\t\t\ttty_putcode1(tty, TTYC_HPA, cx);\n\t\t\tgoto out;\n\t\t} else if (change > 0 && tty_term_has(term, TTYC_CUB)) {\n\t\t\ttty_putcode1(tty, TTYC_CUB, change);\n\t\t\tgoto out;\n\t\t} else if (change < 0 && tty_term_has(term, TTYC_CUF)) {\n\t\t\ttty_putcode1(tty, TTYC_CUF, -change);\n\t\t\tgoto out;\n\t\t}\n\t} else if (cx == thisx) {\n\t\t/*\n\t\t * Moving row only, column staying the same.\n\t\t */\n\n\t\t/* One above. */\n\t\tif (thisy != tty->rupper &&\n\t\t    cy == thisy - 1 && tty_term_has(term, TTYC_CUU1)) {\n\t\t\ttty_putcode(tty, TTYC_CUU1);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* One below. */\n\t\tif (thisy != tty->rlower &&\n\t\t    cy == thisy + 1 && tty_term_has(term, TTYC_CUD1)) {\n\t\t\ttty_putcode(tty, TTYC_CUD1);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Calculate difference. */\n\t\tchange = thisy - cy;\t/* +ve up, -ve down */\n\n\t\t/*\n\t\t * Try to use VPA if change is larger than absolute or if this\n\t\t * change would cross the scroll region, otherwise use CUU/CUD.\n\t\t */\n\t\tif ((u_int) abs(change) > cy ||\n\t\t    (change < 0 && cy - change > tty->rlower) ||\n\t\t    (change > 0 && cy - change < tty->rupper)) {\n\t\t\t    if (tty_term_has(term, TTYC_VPA)) {\n\t\t\t\t    tty_putcode1(tty, TTYC_VPA, cy);\n\t\t\t\t    goto out;\n\t\t\t    }\n\t\t} else if (change > 0 && tty_term_has(term, TTYC_CUU)) {\n\t\t\ttty_putcode1(tty, TTYC_CUU, change);\n\t\t\tgoto out;\n\t\t} else if (change < 0 && tty_term_has(term, TTYC_CUD)) {\n\t\t\ttty_putcode1(tty, TTYC_CUD, -change);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nabsolute:\n\t/* Absolute movement. */\n\ttty_putcode2(tty, TTYC_CUP, cy, cx);\n\nout:\n\ttty->cx = cx;\n\ttty->cy = cy;\n}\n\nvoid\ntty_attributes(struct tty *tty, const struct grid_cell *gc,\n    const struct window_pane *wp)\n{\n\tstruct grid_cell\t*tc = &tty->cell, gc2;\n\tu_char\t\t\t changed;\n\n\tmemcpy(&gc2, gc, sizeof gc2);\n\ttty_default_colours(&gc2, wp);\n\n\t/*\n\t * If no setab, try to use the reverse attribute as a best-effort for a\n\t * non-default background. This is a bit of a hack but it doesn't do\n\t * any serious harm and makes a couple of applications happier.\n\t */\n\tif (!tty_term_has(tty->term, TTYC_SETAB)) {\n\t\tif (gc2.attr & GRID_ATTR_REVERSE) {\n\t\t\tif (gc2.fg != 7 && gc2.fg != 8)\n\t\t\t\tgc2.attr &= ~GRID_ATTR_REVERSE;\n\t\t} else {\n\t\t\tif (gc2.bg != 0 && gc2.bg != 8)\n\t\t\t\tgc2.attr |= GRID_ATTR_REVERSE;\n\t\t}\n\t}\n\n\t/* Fix up the colours if necessary. */\n\ttty_check_fg(tty, &gc2);\n\ttty_check_bg(tty, &gc2);\n\n\t/* If any bits are being cleared, reset everything. */\n\tif (tc->attr & ~gc2.attr)\n\t\ttty_reset(tty);\n\n\t/*\n\t * Set the colours. This may call tty_reset() (so it comes next) and\n\t * may add to (NOT remove) the desired attributes by changing new_attr.\n\t */\n\ttty_colours(tty, &gc2);\n\n\t/* Filter out attribute bits already set. */\n\tchanged = gc2.attr & ~tc->attr;\n\ttc->attr = gc2.attr;\n\n\t/* Set the attributes. */\n\tif (changed & GRID_ATTR_BRIGHT)\n\t\ttty_putcode(tty, TTYC_BOLD);\n\tif (changed & GRID_ATTR_DIM)\n\t\ttty_putcode(tty, TTYC_DIM);\n\tif (changed & GRID_ATTR_ITALICS)\n\t\ttty_set_italics(tty);\n\tif (changed & GRID_ATTR_UNDERSCORE)\n\t\ttty_putcode(tty, TTYC_SMUL);\n\tif (changed & GRID_ATTR_BLINK)\n\t\ttty_putcode(tty, TTYC_BLINK);\n\tif (changed & GRID_ATTR_REVERSE) {\n\t\tif (tty_term_has(tty->term, TTYC_REV))\n\t\t\ttty_putcode(tty, TTYC_REV);\n\t\telse if (tty_term_has(tty->term, TTYC_SMSO))\n\t\t\ttty_putcode(tty, TTYC_SMSO);\n\t}\n\tif (changed & GRID_ATTR_HIDDEN)\n\t\ttty_putcode(tty, TTYC_INVIS);\n\tif ((changed & GRID_ATTR_CHARSET) && tty_use_acs(tty))\n\t\ttty_putcode(tty, TTYC_SMACS);\n}\n\nvoid\ntty_colours(struct tty *tty, const struct grid_cell *gc)\n{\n\tstruct grid_cell\t*tc = &tty->cell;\n\tint\t\t\t have_ax, fg_default, bg_default;\n\n\t/* No changes? Nothing is necessary. */\n\tif (tty_same_colours(gc, tc))\n\t\treturn;\n\n\t/*\n\t * Is either the default colour? This is handled specially because the\n\t * best solution might be to reset both colours to default, in which\n\t * case if only one is default need to fall onward to set the other\n\t * colour.\n\t */\n\tfg_default = tty_is_fg(gc, 8);\n\tbg_default = tty_is_bg(gc, 8);\n\tif (fg_default || bg_default) {\n\t\t/*\n\t\t * If don't have AX but do have op, send sgr0 (op can't\n\t\t * actually be used because it is sometimes the same as sgr0\n\t\t * and sometimes isn't). This resets both colours to default.\n\t\t *\n\t\t * Otherwise, try to set the default colour only as needed.\n\t\t */\n\t\thave_ax = tty_term_flag(tty->term, TTYC_AX);\n\t\tif (!have_ax && tty_term_has(tty->term, TTYC_OP))\n\t\t\ttty_reset(tty);\n\t\telse {\n\t\t\tif (fg_default && !tty_is_fg(tc, 8)) {\n\t\t\t\tif (have_ax)\n\t\t\t\t\ttty_puts(tty, \"\\033[39m\");\n\t\t\t\telse if (!tty_is_fg(tc, 7))\n\t\t\t\t\ttty_putcode1(tty, TTYC_SETAF, 7);\n\t\t\t\ttc->fg = 8;\n\t\t\t\ttc->flags &= ~(GRID_FLAG_FG256|GRID_FLAG_FGRGB);\n\t\t\t}\n\t\t\tif (bg_default && !tty_is_bg(tc, 8)) {\n\t\t\t\tif (have_ax)\n\t\t\t\t\ttty_puts(tty, \"\\033[49m\");\n\t\t\t\telse if (!tty_is_bg(tc, 0))\n\t\t\t\t\ttty_putcode1(tty, TTYC_SETAB, 0);\n\t\t\t\ttc->bg = 8;\n\t\t\t\ttc->flags &= ~(GRID_FLAG_BG256|GRID_FLAG_BGRGB);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Set the foreground colour. */\n\tif (!fg_default && !tty_same_fg(gc, tc))\n\t\ttty_colours_fg(tty, gc);\n\n\t/*\n\t * Set the background colour. This must come after the foreground as\n\t * tty_colour_fg() can call tty_reset().\n\t */\n\tif (!bg_default && !tty_same_bg(gc, tc))\n\t\ttty_colours_bg(tty, gc);\n}\n\nvoid\ntty_check_fg(struct tty *tty, struct grid_cell *gc)\n{\n\tstruct grid_cell_rgb\t*rgb = &gc->fg_rgb;\n\tu_int\t\t\t colours;\n\n\t/* Is this a 24-bit colour? */\n\tif (gc->flags & GRID_FLAG_FGRGB) {\n\t\t/* Not a 24-bit terminal? Translate to 256-colour palette. */\n\t\tif (!tty_term_flag(tty->term, TTYC_TC)) {\n\t\t\tgc->flags &= ~GRID_FLAG_FGRGB;\n\t\t\tgc->flags |= GRID_FLAG_FG256;\n\t\t\tgc->fg = colour_find_rgb(rgb->r, rgb->g, rgb->b);\n\t\t}\n\t\telse\n\t\t\treturn;\n\t}\n\tcolours = tty_term_number(tty->term, TTYC_COLORS);\n\n\t/* Is this a 256-colour colour? */\n\tif (gc->flags & GRID_FLAG_FG256) {\n\t\t/* And not a 256 colour mode? */\n\t\tif (!(tty->term->flags & TERM_256COLOURS) &&\n\t\t    !(tty->term_flags & TERM_256COLOURS)) {\n\t\t\tgc->fg = colour_256to16(gc->fg);\n\t\t\tif (gc->fg & 8) {\n\t\t\t\tgc->fg &= 7;\n\t\t\t\tif (colours >= 16)\n\t\t\t\t\tgc->fg += 90;\n\t\t\t\telse\n\t\t\t\t\tgc->attr |= GRID_ATTR_BRIGHT;\n\t\t\t} else\n\t\t\t\tgc->attr &= ~GRID_ATTR_BRIGHT;\n\t\t\tgc->flags &= ~GRID_FLAG_FG256;\n\t\t}\n\t\treturn;\n\t}\n\n\t/* Is this an aixterm colour? */\n\tif (gc->fg >= 90 && gc->fg <= 97 && colours < 16) {\n\t\tgc->fg -= 90;\n\t\tgc->attr |= GRID_ATTR_BRIGHT;\n\t}\n}\n\nvoid\ntty_check_bg(struct tty *tty, struct grid_cell *gc)\n{\n\tstruct grid_cell_rgb\t*rgb = &gc->bg_rgb;\n\tu_int\t\t\t colours;\n\n\t/* Is this a 24-bit colour? */\n\tif (gc->flags & GRID_FLAG_BGRGB) {\n\t\t/* Not a 24-bit terminal? Translate to 256-colour palette. */\n\t\tif (!tty_term_flag(tty->term, TTYC_TC)) {\n\t\t\tgc->flags &= ~GRID_FLAG_BGRGB;\n\t\t\tgc->flags |= GRID_FLAG_BG256;\n\t\t\tgc->bg = colour_find_rgb(rgb->r, rgb->g, rgb->b);\n\t\t}\n\t\telse\n\t\t\treturn;\n\t}\n\tcolours = tty_term_number(tty->term, TTYC_COLORS);\n\n\t/* Is this a 256-colour colour? */\n\tif (gc->flags & GRID_FLAG_BG256) {\n\t\t/*\n\t\t * And not a 256 colour mode? Translate to 16-colour\n\t\t * palette. Bold background doesn't exist portably, so just\n\t\t * discard the bold bit if set.\n\t\t */\n\t\tif (!(tty->term->flags & TERM_256COLOURS) &&\n\t\t    !(tty->term_flags & TERM_256COLOURS)) {\n\t\t\tgc->bg = colour_256to16(gc->bg);\n\t\t\tif (gc->bg & 8) {\n\t\t\t\tgc->bg &= 7;\n\t\t\t\tif (colours >= 16)\n\t\t\t\t\tgc->fg += 90;\n\t\t\t}\n\t\t\tgc->flags &= ~GRID_FLAG_BG256;\n\t\t}\n\t\treturn;\n\t}\n\n\t/* Is this an aixterm colour? */\n\tif (gc->bg >= 90 && gc->bg <= 97 && colours < 16)\n\t\tgc->bg -= 90;\n}\n\nvoid\ntty_colours_fg(struct tty *tty, const struct grid_cell *gc)\n{\n\tstruct grid_cell\t*tc = &tty->cell;\n\tu_char\t\t\t fg = gc->fg;\n\tchar\t\t\t s[32];\n\n\ttc->flags &= ~(GRID_FLAG_FG256|GRID_FLAG_FGRGB);\n\n\t/* Is this a 24-bit colour? */\n\tif (gc->flags & GRID_FLAG_FGRGB) {\n\t\tif (tty_try_rgb(tty, &gc->fg_rgb, \"38\") == 0)\n\t\t\tgoto save_fg;\n\t\t/* Should not get here, already converted in tty_check_fg. */\n\t\treturn;\n\t}\n\n\t/* Is this a 256-colour colour? */\n\tif (gc->flags & GRID_FLAG_FG256) {\n\t\tif (tty_try_256(tty, fg, \"38\") == 0)\n\t\t\tgoto save_fg;\n\t\t/* Should not get here, already converted in tty_check_fg. */\n\t\treturn;\n\t}\n\n\t/* Is this an aixterm bright colour? */\n\tif (fg >= 90 && fg <= 97) {\n\t\txsnprintf(s, sizeof s, \"\\033[%dm\", fg);\n\t\ttty_puts(tty, s);\n\t\tgoto save_fg;\n\t}\n\n\t/* Otherwise set the foreground colour. */\n\ttty_putcode1(tty, TTYC_SETAF, fg);\n\nsave_fg:\n\t/* Save the new values in the terminal current cell. */\n\tif (gc->flags & GRID_FLAG_FGRGB)\n\t\tmemcpy(&tc->fg_rgb, &gc->fg_rgb, sizeof tc->fg_rgb);\n\telse\n\t\ttc->fg = fg;\n\ttc->flags &= ~(GRID_FLAG_FGRGB|GRID_FLAG_FG256);\n\ttc->flags |= (gc->flags & (GRID_FLAG_FG256|GRID_FLAG_FGRGB));\n}\n\nvoid\ntty_colours_bg(struct tty *tty, const struct grid_cell *gc)\n{\n\tstruct grid_cell\t*tc = &tty->cell;\n\tu_char\t\t\t bg = gc->bg;\n\tchar\t\t\t s[32];\n\n\t/* Is this a 24-bit colour? */\n\tif (gc->flags & GRID_FLAG_BGRGB) {\n\t\tif (tty_try_rgb(tty, &gc->bg_rgb, \"48\") == 0)\n\t\t\tgoto save_bg;\n\t\t/* Should not get here, already converted in tty_check_bg. */\n\t\treturn;\n\t}\n\n\t/* Is this a 256-colour colour? */\n\tif (gc->flags & GRID_FLAG_BG256) {\n\t\tif (tty_try_256(tty, bg, \"48\") == 0)\n\t\t\tgoto save_bg;\n\t\t/* Should not get here, already converted in tty_check_bg. */\n\t\treturn;\n\t}\n\n\t/* Is this an aixterm bright colour? */\n\tif (bg >= 90 && bg <= 97) {\n\t\txsnprintf(s, sizeof s, \"\\033[%dm\", bg + 10);\n\t\ttty_puts(tty, s);\n\t\tgoto save_bg;\n\t}\n\n\t/* Otherwise set the background colour. */\n\ttty_putcode1(tty, TTYC_SETAB, bg);\n\nsave_bg:\n\t/* Save the new values in the terminal current cell. */\n\tif (gc->flags & GRID_FLAG_BGRGB)\n\t\tmemcpy(&tc->bg_rgb, &gc->bg_rgb, sizeof tc->bg_rgb);\n\telse\n\t\ttc->bg = bg;\n\ttc->flags &= ~(GRID_FLAG_BGRGB|GRID_FLAG_BG256);\n\ttc->flags |= (gc->flags & (GRID_FLAG_BG256|GRID_FLAG_BGRGB));\n}\n\nint\ntty_try_256(struct tty *tty, u_char colour, const char *type)\n{\n\tchar\ts[32];\n\n\t/*\n\t * If the user has specified -2 to the client, setaf and setab may not\n\t * work (or they may not want to use them), so send the usual sequence.\n\t */\n\tif (tty->term_flags & TERM_256COLOURS)\n\t\tgoto fallback;\n\n\t/*\n\t * If the terminfo entry has 256 colours and setaf and setab exist,\n\t * assume that they work correctly.\n\t */\n\tif (tty->term->flags & TERM_256COLOURS) {\n\t\tif (*type == '3') {\n\t\t\tif (!tty_term_has(tty->term, TTYC_SETAF))\n\t\t\t\tgoto fallback;\n\t\t\ttty_putcode1(tty, TTYC_SETAF, colour);\n\t\t} else {\n\t\t\tif (!tty_term_has(tty->term, TTYC_SETAB))\n\t\t\t\tgoto fallback;\n\t\t\ttty_putcode1(tty, TTYC_SETAB, colour);\n\t\t}\n\t\treturn (0);\n\t}\n\n\treturn (-1);\n\nfallback:\n\txsnprintf(s, sizeof s, \"\\033[%s;5;%hhum\", type, colour);\n\ttty_puts(tty, s);\n\treturn (0);\n}\n\nint\ntty_try_rgb(struct tty *tty, const struct grid_cell_rgb *rgb, const char *type)\n{\n\tchar\ts[32];\n\n\tif (!tty_term_flag(tty->term, TTYC_TC))\n\t\treturn (-1);\n\n\txsnprintf(s, sizeof s, \"\\033[%s;2;%hhu;%hhu;%hhum\", type, rgb->r,\n\t    rgb->g, rgb->b);\n\ttty_puts(tty, s);\n\treturn (0);\n}\n\nvoid\ntty_default_colours(struct grid_cell *gc, const struct window_pane *wp)\n{\n\tconst struct grid_cell        *agc, *pgc, *wgc;\n\n\tif (wp == NULL)\n\t\treturn;\n\n\tpgc = &wp->colgc;\n\tagc = options_get_style(wp->window->options, \"window-active-style\");\n\twgc = options_get_style(wp->window->options, \"window-style\");\n\n\tif (gc->fg == 8 && !(gc->flags & GRID_FLAG_FG256)) {\n\t\tif (pgc->fg != 8 || (pgc->flags & GRID_FLAG_FG256)) {\n\t\t\tgc->fg = pgc->fg;\n\t\t\tgc->flags |= (pgc->flags & GRID_FLAG_FG256);\n\t\t} else if (wp == wp->window->active &&\n\t\t    (agc->fg != 8 || (agc->flags & GRID_FLAG_FG256))) {\n\t\t\tgc->fg = agc->fg;\n\t\t\tgc->flags |= (agc->flags & GRID_FLAG_FG256);\n\t\t} else {\n\t\t\tgc->fg = wgc->fg;\n\t\t\tgc->flags |= (wgc->flags & GRID_FLAG_FG256);\n\t\t}\n\t}\n\n\tif (gc->bg == 8 && !(gc->flags & GRID_FLAG_BG256)) {\n\t\tif (pgc->bg != 8 || (pgc->flags & GRID_FLAG_BG256)) {\n\t\t\tgc->bg = pgc->bg;\n\t\t\tgc->flags |= (pgc->flags & GRID_FLAG_BG256);\n\t\t} else if (wp == wp->window->active &&\n\t\t    (agc->bg != 8 || (agc->flags & GRID_FLAG_BG256))) {\n\t\t\tgc->bg = agc->bg;\n\t\t\tgc->flags |= (agc->flags & GRID_FLAG_BG256);\n\t\t} else {\n\t\t\tgc->bg = wgc->bg;\n\t\t\tgc->flags |= (wgc->flags & GRID_FLAG_BG256);\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "utf8.c",
          "type": "blob",
          "size": 7.7490234375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2008 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n#include <wchar.h>\n\n#include \"tmux.h\"\n\nstatic int\tutf8_width(wchar_t);\n\n/* Set a single character. */\nvoid\nutf8_set(struct utf8_data *ud, u_char ch)\n{\n\tu_int\ti;\n\n\t*ud->data = ch;\n\tud->have = 1;\n\tud->size = 1;\n\n\tud->width = 1;\n\n\tfor (i = ud->size; i < sizeof ud->data; i++)\n\t\tud->data[i] = '\\0';\n}\n\n/* Copy UTF-8 character. */\nvoid\nutf8_copy(struct utf8_data *to, const struct utf8_data *from)\n{\n\tu_int\ti;\n\n\tmemcpy(to, from, sizeof *to);\n\n\tfor (i = to->size; i < sizeof to->data; i++)\n\t\tto->data[i] = '\\0';\n}\n\n/*\n * Open UTF-8 sequence.\n *\n * 11000010-11011111 C2-DF start of 2-byte sequence\n * 11100000-11101111 E0-EF start of 3-byte sequence\n * 11110000-11110100 F0-F4 start of 4-byte sequence\n */\nenum utf8_state\nutf8_open(struct utf8_data *ud, u_char ch)\n{\n\tmemset(ud, 0, sizeof *ud);\n\tif (ch >= 0xc2 && ch <= 0xdf)\n\t\tud->size = 2;\n\telse if (ch >= 0xe0 && ch <= 0xef)\n\t\tud->size = 3;\n\telse if (ch >= 0xf0 && ch <= 0xf4)\n\t\tud->size = 4;\n\telse\n\t\treturn (UTF8_ERROR);\n\tutf8_append(ud, ch);\n\treturn (UTF8_MORE);\n}\n\n/* Append character to UTF-8, closing if finished. */\nenum utf8_state\nutf8_append(struct utf8_data *ud, u_char ch)\n{\n\twchar_t\twc;\n\tint\twidth;\n\n\tif (ud->have >= ud->size)\n\t\tfatalx(\"UTF-8 character overflow\");\n\tif (ud->size > sizeof ud->data)\n\t\tfatalx(\"UTF-8 character size too large\");\n\n\tif (ud->have != 0 && (ch & 0xc0) != 0x80)\n\t\tud->width = 0xff;\n\n\tud->data[ud->have++] = ch;\n\tif (ud->have != ud->size)\n\t\treturn (UTF8_MORE);\n\n\tif (ud->width == 0xff)\n\t\treturn (UTF8_ERROR);\n\n\tif (utf8_combine(ud, &wc) != UTF8_DONE)\n\t\treturn (UTF8_ERROR);\n\tif ((width = utf8_width(wc)) < 0)\n\t\treturn (UTF8_ERROR);\n\tud->width = width;\n\n\treturn (UTF8_DONE);\n}\n\n/* Get width of Unicode character. */\nstatic int\nutf8_width(wchar_t wc)\n{\n\tint\twidth;\n\n\twidth = wcwidth(wc);\n\tif (width < 0 || width > 0xff)\n\t\treturn (-1);\n\treturn (width);\n}\n\n/* Combine UTF-8 into Unicode. */\nenum utf8_state\nutf8_combine(const struct utf8_data *ud, wchar_t *wc)\n{\n\tswitch (mbtowc(wc, ud->data, ud->size)) {\n\tcase -1:\n\t\tmbtowc(NULL, NULL, MB_CUR_MAX);\n\t\treturn (UTF8_ERROR);\n\tcase 0:\n\t\treturn (UTF8_ERROR);\n\tdefault:\n\t\treturn (UTF8_DONE);\n\t}\n}\n\n/* Split Unicode into UTF-8. */\nenum utf8_state\nutf8_split(wchar_t wc, struct utf8_data *ud)\n{\n\tchar\ts[MB_LEN_MAX];\n\tint\tslen;\n\n\tslen = wctomb(s, wc);\n\tif (slen <= 0 || slen > (int)sizeof ud->data)\n\t\treturn (UTF8_ERROR);\n\n\tmemcpy(ud->data, s, slen);\n\tud->size = slen;\n\n\tud->width = utf8_width(wc);\n\treturn (UTF8_DONE);\n}\n\n/*\n * Encode len characters from src into dst, which is guaranteed to have four\n * bytes available for each character from src (for \\abc or UTF-8) plus space\n * for \\0.\n */\nint\nutf8_strvis(char *dst, const char *src, size_t len, int flag)\n{\n\tstruct utf8_data\t ud;\n\tconst char\t\t*start, *end;\n\tenum utf8_state\t\t more;\n\tsize_t\t\t\t i;\n\n\tstart = dst;\n\tend = src + len;\n\n\twhile (src < end) {\n\t\tif ((more = utf8_open(&ud, *src)) == UTF8_MORE) {\n\t\t\twhile (++src < end && more == UTF8_MORE)\n\t\t\t\tmore = utf8_append(&ud, *src);\n\t\t\tif (more == UTF8_DONE) {\n\t\t\t\t/* UTF-8 character finished. */\n\t\t\t\tfor (i = 0; i < ud.size; i++)\n\t\t\t\t\t*dst++ = ud.data[i];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* Not a complete, valid UTF-8 character. */\n\t\t\tsrc -= ud.have;\n\t\t}\n\t\tif (src < end - 1)\n\t\t\tdst = vis(dst, src[0], flag, src[1]);\n\t\telse if (src < end)\n\t\t\tdst = vis(dst, src[0], flag, '\\0');\n\t\tsrc++;\n\t}\n\n\t*dst = '\\0';\n\treturn (dst - start);\n}\n\n/*\n * Sanitize a string, changing any UTF-8 characters to '_'. Caller should free\n * the returned string. Anything not valid printable ASCII or UTF-8 is\n * stripped.\n */\nchar *\nutf8_sanitize(const char *src)\n{\n\tchar\t\t\t*dst;\n\tsize_t\t\t\t n;\n\tenum utf8_state\t\t more;\n\tstruct utf8_data\t ud;\n\tu_int\t\t\t i;\n\n\tdst = NULL;\n\n\tn = 0;\n\twhile (*src != '\\0') {\n\t\tdst = xreallocarray(dst, n + 1, sizeof *dst);\n\t\tif ((more = utf8_open(&ud, *src)) == UTF8_MORE) {\n\t\t\twhile (*++src != '\\0' && more == UTF8_MORE)\n\t\t\t\tmore = utf8_append(&ud, *src);\n\t\t\tif (more == UTF8_DONE) {\n\t\t\t\tdst = xreallocarray(dst, n + ud.width,\n\t\t\t\t    sizeof *dst);\n\t\t\t\tfor (i = 0; i < ud.width; i++)\n\t\t\t\t\tdst[n++] = '_';\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsrc -= ud.have;\n\t\t}\n\t\tif (*src > 0x1f && *src < 0x7f)\n\t\t\tdst[n++] = *src;\n\t\telse\n\t\t\tdst[n++] = '_';\n\t\tsrc++;\n\t}\n\n\tdst = xreallocarray(dst, n + 1, sizeof *dst);\n\tdst[n] = '\\0';\n\treturn (dst);\n}\n\n/*\n * Convert a string into a buffer of UTF-8 characters. Terminated by size == 0.\n * Caller frees.\n */\nstruct utf8_data *\nutf8_fromcstr(const char *src)\n{\n\tstruct utf8_data\t*dst;\n\tsize_t\t\t\t n;\n\tenum utf8_state\t\t more;\n\n\tdst = NULL;\n\n\tn = 0;\n\twhile (*src != '\\0') {\n\t\tdst = xreallocarray(dst, n + 1, sizeof *dst);\n\t\tif ((more = utf8_open(&dst[n], *src)) == UTF8_MORE) {\n\t\t\twhile (*++src != '\\0' && more == UTF8_MORE)\n\t\t\t\tmore = utf8_append(&dst[n], *src);\n\t\t\tif (more == UTF8_DONE) {\n\t\t\t\tn++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsrc -= dst[n].have;\n\t\t}\n\t\tutf8_set(&dst[n], *src);\n\t\tn++;\n\t\tsrc++;\n\t}\n\n\tdst = xreallocarray(dst, n + 1, sizeof *dst);\n\tdst[n].size = 0;\n\treturn (dst);\n}\n\n/* Convert from a buffer of UTF-8 characters into a string. Caller frees. */\nchar *\nutf8_tocstr(struct utf8_data *src)\n{\n\tchar\t*dst;\n\tsize_t\t n;\n\n\tdst = NULL;\n\n\tn = 0;\n\tfor(; src->size != 0; src++) {\n\t\tdst = xreallocarray(dst, n + src->size, 1);\n\t\tmemcpy(dst + n, src->data, src->size);\n\t\tn += src->size;\n\t}\n\n\tdst = xreallocarray(dst, n + 1, 1);\n\tdst[n] = '\\0';\n\treturn (dst);\n}\n\n/* Get width of UTF-8 string. */\nu_int\nutf8_cstrwidth(const char *s)\n{\n\tstruct utf8_data\ttmp;\n\tu_int\t\t\twidth;\n\tenum utf8_state\t\tmore;\n\n\twidth = 0;\n\twhile (*s != '\\0') {\n\t\tif ((more = utf8_open(&tmp, *s)) == UTF8_MORE) {\n\t\t\twhile (*++s != '\\0' && more == UTF8_MORE)\n\t\t\t\tmore = utf8_append(&tmp, *s);\n\t\t\tif (more == UTF8_DONE) {\n\t\t\t\twidth += tmp.width;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ts -= tmp.have;\n\t\t}\n\t\tif (*s > 0x1f && *s != 0x7f)\n\t\t\twidth++;\n\t\ts++;\n\t}\n\treturn (width);\n}\n\n/* Trim UTF-8 string to width. Caller frees. */\nchar *\nutf8_trimcstr(const char *s, u_int width)\n{\n\tstruct utf8_data\t*tmp, *next;\n\tchar\t\t\t*out;\n\tu_int\t\t\t at;\n\n\ttmp = utf8_fromcstr(s);\n\n\tat = 0;\n\tfor (next = tmp; next->size != 0; next++) {\n\t\tif (at + next->width > width) {\n\t\t\tnext->size = 0;\n\t\t\tbreak;\n\t\t}\n\t\tat += next->width;\n\t}\n\n\tout = utf8_tocstr(tmp);\n\tfree(tmp);\n\treturn (out);\n}\n\n/* Trim UTF-8 string to width. Caller frees. */\nchar *\nutf8_rtrimcstr(const char *s, u_int width)\n{\n\tstruct utf8_data\t*tmp, *next, *end;\n\tchar\t\t\t*out;\n\tu_int\t\t\t at;\n\n\ttmp = utf8_fromcstr(s);\n\n\tfor (end = tmp; end->size != 0; end++)\n\t\t/* nothing */;\n\tif (end == tmp) {\n\t\tfree(tmp);\n\t\treturn (xstrdup(\"\"));\n\t}\n\tnext = end - 1;\n\n\tat = 0;\n\tfor (;;)\n\t{\n\t\tif (at + next->width > width) {\n\t\t\tnext++;\n\t\t\tbreak;\n\t\t}\n\t\tat += next->width;\n\n\t\tif (next == tmp)\n\t\t\tbreak;\n\t\tnext--;\n\t}\n\n\tout = utf8_tocstr(next);\n\tfree(tmp);\n\treturn (out);\n}\n\n/* Pad UTF-8 string to width. Caller frees. */\nchar *\nutf8_padcstr(const char *s, u_int width)\n{\n\tsize_t\t slen;\n\tchar\t*out;\n\tu_int\t  n, i;\n\n\tn = utf8_cstrwidth(s);\n\tif (n >= width)\n\t\treturn (xstrdup(s));\n\n\tslen = strlen(s);\n\tout = xmalloc(slen + 1 + (width - n));\n\tmemcpy(out, s, slen);\n\tfor (i = n; i < width; i++)\n\t\tout[slen++] = ' ';\n\tout[slen] = '\\0';\n\treturn (out);\n}\n"
        },
        {
          "name": "window-choose.c",
          "type": "blob",
          "size": 24.0947265625,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <ctype.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"array.h\"\n#include \"tmux.h\"\n\nstruct screen *window_choose_init(struct window_pane *);\nvoid\twindow_choose_free(struct window_pane *);\nvoid\twindow_choose_resize(struct window_pane *, u_int, u_int);\nvoid\twindow_choose_key(struct window_pane *, struct client *,\n\t    struct session *, key_code, struct mouse_event *);\n\nvoid\twindow_choose_default_callback(struct window_choose_data *);\nstruct window_choose_mode_item *window_choose_get_item(struct window_pane *,\n\t    key_code, struct mouse_event *);\n\nvoid\twindow_choose_fire_callback(struct window_pane *,\n\t    struct window_choose_data *);\nvoid\twindow_choose_redraw_screen(struct window_pane *);\nvoid\twindow_choose_write_line(struct window_pane *,\n\t    struct screen_write_ctx *, u_int);\n\nvoid\twindow_choose_scroll_up(struct window_pane *);\nvoid\twindow_choose_scroll_down(struct window_pane *);\n\nvoid\twindow_choose_collapse(struct window_pane *, struct session *, u_int);\nvoid\twindow_choose_expand(struct window_pane *, struct session *, u_int);\n\nenum window_choose_input_type {\n\tWINDOW_CHOOSE_NORMAL = -1,\n\tWINDOW_CHOOSE_GOTO_ITEM,\n};\n\nconst struct window_mode window_choose_mode = {\n\twindow_choose_init,\n\twindow_choose_free,\n\twindow_choose_resize,\n\twindow_choose_key,\n};\n\nstruct window_choose_mode_item {\n\tstruct window_choose_data\t*wcd;\n\tchar\t\t\t\t*name;\n\tint\t\t\t\t pos;\n\tint\t\t\t\t state;\n#define TREE_EXPANDED 0x1\n};\n\nstruct window_choose_mode_data {\n\tstruct screen\t        screen;\n\n\tstruct mode_key_data\tmdata;\n\n\tARRAY_DECL(, struct window_choose_mode_item) list;\n\tARRAY_DECL(, struct window_choose_mode_item) old_list;\n\tint\t\t\twidth;\n\tu_int\t\t\ttop;\n\tu_int\t\t\tselected;\n\tenum window_choose_input_type input_type;\n\tconst char\t\t*input_prompt;\n\tchar\t\t\t*input_str;\n\n\tvoid \t\t\t(*callbackfn)(struct window_choose_data *);\n};\n\nvoid\twindow_choose_free1(struct window_choose_mode_data *);\nint     window_choose_key_index(struct window_choose_mode_data *, u_int);\nint     window_choose_index_key(struct window_choose_mode_data *, key_code);\nvoid\twindow_choose_prompt_input(enum window_choose_input_type,\n\t    const char *, struct window_pane *, key_code);\nvoid\twindow_choose_reset_top(struct window_pane *, u_int);\n\nvoid\nwindow_choose_add(struct window_pane *wp, struct window_choose_data *wcd)\n{\n\tstruct window_choose_mode_data\t*data = wp->modedata;\n\tstruct window_choose_mode_item\t*item;\n\tchar\t\t\t\t tmp[10];\n\n\tARRAY_EXPAND(&data->list, 1);\n\titem = &ARRAY_LAST(&data->list);\n\n\titem->name = format_expand(wcd->ft, wcd->ft_template);\n\titem->wcd = wcd;\n\titem->pos = ARRAY_LENGTH(&data->list) - 1;\n\titem->state = 0;\n\n\tdata->width = xsnprintf(tmp, sizeof tmp , \"%d\", item->pos);\n}\n\nvoid\nwindow_choose_set_current(struct window_pane *wp, u_int cur)\n{\n\tstruct window_choose_mode_data\t*data = wp->modedata;\n\tstruct screen\t\t\t*s = &data->screen;\n\n\tdata->selected = cur;\n\twindow_choose_reset_top(wp, screen_size_y(s));\n}\n\nvoid\nwindow_choose_reset_top(struct window_pane *wp, u_int sy)\n{\n\tstruct window_choose_mode_data\t*data = wp->modedata;\n\n\tdata->top = 0;\n\tif (data->selected > sy - 1)\n\t\tdata->top = data->selected - (sy - 1);\n\n\twindow_choose_redraw_screen(wp);\n}\n\nvoid\nwindow_choose_ready(struct window_pane *wp, u_int cur,\n    void (*callbackfn)(struct window_choose_data *))\n{\n\tstruct window_choose_mode_data\t*data = wp->modedata;\n\n\tdata->callbackfn = callbackfn;\n\tif (data->callbackfn == NULL)\n\t\tdata->callbackfn = window_choose_default_callback;\n\n\tARRAY_CONCAT(&data->old_list, &data->list);\n\n\twindow_choose_set_current(wp, cur);\n\twindow_choose_collapse_all(wp);\n}\n\nstruct screen *\nwindow_choose_init(struct window_pane *wp)\n{\n\tstruct window_choose_mode_data\t*data;\n\tstruct screen\t\t\t*s;\n\tint\t\t\t\t keys;\n\n\twp->modedata = data = xmalloc(sizeof *data);\n\n\tdata->callbackfn = NULL;\n\tdata->input_type = WINDOW_CHOOSE_NORMAL;\n\tdata->input_str = xstrdup(\"\");\n\tdata->input_prompt = NULL;\n\n\tARRAY_INIT(&data->list);\n\tARRAY_INIT(&data->old_list);\n\tdata->top = 0;\n\n\ts = &data->screen;\n\tscreen_init(s, screen_size_x(&wp->base), screen_size_y(&wp->base), 0);\n\ts->mode &= ~MODE_CURSOR;\n\n\tkeys = options_get_number(wp->window->options, \"mode-keys\");\n\tif (keys == MODEKEY_EMACS)\n\t\tmode_key_init(&data->mdata, &mode_key_tree_emacs_choice);\n\telse\n\t\tmode_key_init(&data->mdata, &mode_key_tree_vi_choice);\n\n\treturn (s);\n}\n\nstruct window_choose_data *\nwindow_choose_data_create(int type, struct client *c, struct session *s)\n{\n\tstruct window_choose_data\t*wcd;\n\n\twcd = xmalloc(sizeof *wcd);\n\twcd->type = type;\n\n\twcd->ft = format_create(NULL, 0);\n\twcd->ft_template = NULL;\n\n\twcd->command = NULL;\n\n\twcd->wl = NULL;\n\twcd->pane_id = -1;\n\twcd->idx = -1;\n\n\twcd->tree_session = NULL;\n\n\twcd->start_client = c;\n\twcd->start_client->references++;\n\twcd->start_session = s;\n\twcd->start_session->references++;\n\n\treturn (wcd);\n}\n\nvoid\nwindow_choose_data_free(struct window_choose_data *wcd)\n{\n\tserver_client_unref(wcd->start_client);\n\tsession_unref(wcd->start_session);\n\n\tif (wcd->tree_session != NULL)\n\t\tsession_unref(wcd->tree_session);\n\n\tfree(wcd->ft_template);\n\tformat_free(wcd->ft);\n\n\tfree(wcd->command);\n\tfree(wcd);\n}\n\nvoid\nwindow_choose_data_run(struct window_choose_data *cdata)\n{\n\tstruct cmd_list\t*cmdlist;\n\tchar\t\t*cause;\n\n\t/*\n\t * The command template will have already been replaced. But if it's\n\t * NULL, bail here.\n\t */\n\tif (cdata->command == NULL)\n\t\treturn;\n\n\tif (cmd_string_parse(cdata->command, &cmdlist, NULL, 0, &cause) != 0) {\n\t\tif (cause != NULL) {\n\t\t\t*cause = toupper((u_char) *cause);\n\t\t\tstatus_message_set(cdata->start_client, \"%s\", cause);\n\t\t\tfree(cause);\n\t\t}\n\t\treturn;\n\t}\n\n\tcmdq_run(cdata->start_client->cmdq, cmdlist, NULL);\n\tcmd_list_free(cmdlist);\n}\n\nvoid\nwindow_choose_default_callback(struct window_choose_data *wcd)\n{\n\tif (wcd == NULL)\n\t\treturn;\n\tif (wcd->start_client->flags & CLIENT_DEAD)\n\t\treturn;\n\n\twindow_choose_data_run(wcd);\n}\n\nvoid\nwindow_choose_free(struct window_pane *wp)\n{\n\tif (wp->modedata != NULL)\n\t\twindow_choose_free1(wp->modedata);\n}\n\nvoid\nwindow_choose_free1(struct window_choose_mode_data *data)\n{\n\tstruct window_choose_mode_item\t*item;\n\tu_int\t\t\t\t i;\n\n\tif (data == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_LENGTH(&data->old_list); i++) {\n\t\titem = &ARRAY_ITEM(&data->old_list, i);\n\t\twindow_choose_data_free(item->wcd);\n\t\tfree(item->name);\n\t}\n\tARRAY_FREE(&data->list);\n\tARRAY_FREE(&data->old_list);\n\tfree(data->input_str);\n\n\tscreen_free(&data->screen);\n\tfree(data);\n}\n\nvoid\nwindow_choose_resize(struct window_pane *wp, u_int sx, u_int sy)\n{\n\tstruct window_choose_mode_data\t*data = wp->modedata;\n\tstruct screen\t\t\t*s = &data->screen;\n\n\twindow_choose_reset_top(wp, sy);\n\tscreen_resize(s, sx, sy, 0);\n\twindow_choose_redraw_screen(wp);\n}\n\nvoid\nwindow_choose_fire_callback(struct window_pane *wp,\n    struct window_choose_data *wcd)\n{\n\tstruct window_choose_mode_data\t*data = wp->modedata;\n\n\twp->modedata = NULL;\n\twindow_pane_reset_mode(wp);\n\n\tdata->callbackfn(wcd);\n\n\twindow_choose_free1(data);\n}\n\nvoid\nwindow_choose_prompt_input(enum window_choose_input_type input_type,\n    const char *prompt, struct window_pane *wp, key_code key)\n{\n\tstruct window_choose_mode_data\t*data = wp->modedata;\n\tsize_t\t\t\t\t input_len;\n\n\tdata->input_type = input_type;\n\tdata->input_prompt = prompt;\n\tinput_len = strlen(data->input_str) + 2;\n\n\tdata->input_str = xrealloc(data->input_str, input_len);\n\tdata->input_str[input_len - 2] = key;\n\tdata->input_str[input_len - 1] = '\\0';\n\n\twindow_choose_redraw_screen(wp);\n}\n\nvoid\nwindow_choose_collapse(struct window_pane *wp, struct session *s, u_int pos)\n{\n\tstruct window_choose_mode_data\t*data = wp->modedata;\n\tstruct window_choose_mode_item\t*item, *chosen;\n\tstruct window_choose_data\t*wcd;\n\tu_int\t\t\t\t i;\n\n\tARRAY_DECL(, struct window_choose_mode_item) list_copy;\n\tARRAY_INIT(&list_copy);\n\n\tchosen = &ARRAY_ITEM(&data->list, pos);\n\tchosen->state &= ~TREE_EXPANDED;\n\n\t/*\n\t * Trying to mangle the &data->list in-place has lots of problems, so\n\t * assign the actual result we want to render and copy the new one over\n\t * the top of it.\n\t */\n\tfor (i = 0; i < ARRAY_LENGTH(&data->list); i++) {\n\t\titem = &ARRAY_ITEM(&data->list, i);\n\t\twcd = item->wcd;\n\n\t\tif (s == wcd->tree_session) {\n\t\t\t/* We only show the session when collapsed. */\n\t\t\tif (wcd->type & TREE_SESSION) {\n\t\t\t\titem->state &= ~TREE_EXPANDED;\n\t\t\t\tARRAY_ADD(&list_copy, *item);\n\n\t\t\t\t/*\n\t\t\t\t * Update the selection to this session item so\n\t\t\t\t * we don't end up highlighting a non-existent\n\t\t\t\t * item.\n\t\t\t\t */\n\t\t\t\tdata->selected = i;\n\t\t\t}\n\t\t} else\n\t\t\tARRAY_ADD(&list_copy, ARRAY_ITEM(&data->list, i));\n\t}\n\n\tif (!ARRAY_EMPTY(&list_copy)) {\n\t\tARRAY_FREE(&data->list);\n\t\tARRAY_CONCAT(&data->list, &list_copy);\n\t\tARRAY_FREE(&list_copy);\n\t}\n}\n\nvoid\nwindow_choose_collapse_all(struct window_pane *wp)\n{\n\tstruct window_choose_mode_data\t*data = wp->modedata;\n\tstruct window_choose_mode_item\t*item;\n\tstruct screen\t\t\t*scr = &data->screen;\n\tstruct session\t\t\t*s, *chosen;\n\tu_int\t\t\t\t i;\n\n\tchosen = ARRAY_ITEM(&data->list, data->selected).wcd->start_session;\n\n\tRB_FOREACH(s, sessions, &sessions)\n\t\twindow_choose_collapse(wp, s, data->selected);\n\n\t/* Reset the selection back to the starting session. */\n\tfor (i = 0; i < ARRAY_LENGTH(&data->list); i++) {\n\t\titem = &ARRAY_ITEM(&data->list, i);\n\n\t\tif (chosen != item->wcd->tree_session)\n\t\t\tcontinue;\n\n\t\tif (item->wcd->type & TREE_SESSION)\n\t\t\tdata->selected = i;\n\t}\n\twindow_choose_reset_top(wp, screen_size_y(scr));\n}\n\nvoid\nwindow_choose_expand_all(struct window_pane *wp)\n{\n\tstruct window_choose_mode_data\t*data = wp->modedata;\n\tstruct window_choose_mode_item\t*item;\n\tstruct screen\t\t\t*scr = &data->screen;\n\tstruct session\t\t\t*s;\n\tu_int\t\t\t\t i;\n\n\tRB_FOREACH(s, sessions, &sessions) {\n\t\tfor (i = 0; i < ARRAY_LENGTH(&data->list); i++) {\n\t\t\titem = &ARRAY_ITEM(&data->list, i);\n\n\t\t\tif (s != item->wcd->tree_session)\n\t\t\t\tcontinue;\n\n\t\t\tif (item->wcd->type & TREE_SESSION)\n\t\t\t\twindow_choose_expand(wp, s, i);\n\t\t}\n\t}\n\n\twindow_choose_reset_top(wp, screen_size_y(scr));\n}\n\nvoid\nwindow_choose_expand(struct window_pane *wp, struct session *s, u_int pos)\n{\n\tstruct window_choose_mode_data\t*data = wp->modedata;\n\tstruct window_choose_mode_item\t*item, *chosen;\n\tstruct window_choose_data\t*wcd;\n\tu_int\t\t\t\t i, items;\n\n\tchosen = &ARRAY_ITEM(&data->list, pos);\n\titems = ARRAY_LENGTH(&data->old_list) - 1;\n\n\t/* It's not possible to expand anything other than sessions. */\n\tif (!(chosen->wcd->type & TREE_SESSION))\n\t\treturn;\n\n\t/* Don't re-expand a session which is already expanded. */\n\tif (chosen->state & TREE_EXPANDED)\n\t\treturn;\n\n\t/* Mark the session entry as expanded. */\n\tchosen->state |= TREE_EXPANDED;\n\n\t/*\n\t * Go back through the original list of all sessions and windows, and\n\t * pull out the windows where the session matches the selection chosen\n\t * to expand.\n\t */\n\tfor (i = items; i > 0; i--) {\n\t\titem = &ARRAY_ITEM(&data->old_list, i);\n\t\titem->state |= TREE_EXPANDED;\n\t\twcd = item->wcd;\n\n\t\tif (s == wcd->tree_session) {\n\t\t\t/*\n\t\t\t * Since the session is already displayed, we only care\n\t\t\t * to add back in window for it.\n\t\t\t */\n\t\t\tif (wcd->type & TREE_WINDOW) {\n\t\t\t\t/*\n\t\t\t\t * If the insertion point for adding the\n\t\t\t\t * windows to the session falls inside the\n\t\t\t\t * range of the list, then we insert these\n\t\t\t\t * entries in order *AFTER* the selected\n\t\t\t\t * session.\n\t\t\t\t */\n\t\t\t\tif (pos < i ) {\n\t\t\t\t\tARRAY_INSERT(&data->list,\n\t\t\t\t\t    pos + 1,\n\t\t\t\t\t    ARRAY_ITEM(&data->old_list,\n\t\t\t\t\t    i));\n\t\t\t\t} else {\n\t\t\t\t\t/* Ran out of room, add to the end. */\n\t\t\t\t\tARRAY_ADD(&data->list,\n\t\t\t\t\t    ARRAY_ITEM(&data->old_list,\n\t\t\t\t\t    i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nstruct window_choose_mode_item *\nwindow_choose_get_item(struct window_pane *wp, key_code key,\n    struct mouse_event *m)\n{\n\tstruct window_choose_mode_data\t*data = wp->modedata;\n\tu_int\t\t\t\t x, y, idx;\n\n\tif (!KEYC_IS_MOUSE(key))\n\t\treturn (&ARRAY_ITEM(&data->list, data->selected));\n\n\tif (cmd_mouse_at(wp, m, &x, &y, 0) != 0)\n\t\treturn (NULL);\n\n\tidx = data->top + y;\n\tif (idx >= ARRAY_LENGTH(&data->list))\n\t\treturn (NULL);\n\treturn (&ARRAY_ITEM(&data->list, idx));\n}\n\nvoid\nwindow_choose_key(struct window_pane *wp, __unused struct client *c,\n    __unused struct session *sess, key_code key, struct mouse_event *m)\n{\n\tstruct window_choose_mode_data\t*data = wp->modedata;\n\tstruct screen\t\t\t*s = &data->screen;\n\tstruct screen_write_ctx\t\t ctx;\n\tstruct window_choose_mode_item\t*item;\n\tsize_t\t\t\t\t input_len;\n\tu_int\t\t\t\t items, n;\n\tint\t\t\t\t idx;\n\n\titems = ARRAY_LENGTH(&data->list);\n\n\tif (data->input_type == WINDOW_CHOOSE_GOTO_ITEM) {\n\t\tswitch (mode_key_lookup(&data->mdata, key, NULL)) {\n\t\tcase MODEKEYCHOICE_CANCEL:\n\t\t\tdata->input_type = WINDOW_CHOOSE_NORMAL;\n\t\t\twindow_choose_redraw_screen(wp);\n\t\t\tbreak;\n\t\tcase MODEKEYCHOICE_CHOOSE:\n\t\t\tn = strtonum(data->input_str, 0, INT_MAX, NULL);\n\t\t\tif (n > items - 1) {\n\t\t\t\tdata->input_type = WINDOW_CHOOSE_NORMAL;\n\t\t\t\twindow_choose_redraw_screen(wp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\titem = &ARRAY_ITEM(&data->list, n);\n\t\t\twindow_choose_fire_callback(wp, item->wcd);\n\t\t\tbreak;\n\t\tcase MODEKEYCHOICE_BACKSPACE:\n\t\t\tinput_len = strlen(data->input_str);\n\t\t\tif (input_len > 0)\n\t\t\t\tdata->input_str[input_len - 1] = '\\0';\n\t\t\twindow_choose_redraw_screen(wp);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (key < '0' || key > '9')\n\t\t\t\tbreak;\n\t\t\twindow_choose_prompt_input(WINDOW_CHOOSE_GOTO_ITEM,\n\t\t\t    \"Goto Item\", wp, key);\n\t\t\tbreak;\n\t\t}\n\t\treturn;\n\t}\n\n\tswitch (mode_key_lookup(&data->mdata, key, NULL)) {\n\tcase MODEKEYCHOICE_CANCEL:\n\t\twindow_choose_fire_callback(wp, NULL);\n\t\tbreak;\n\tcase MODEKEYCHOICE_CHOOSE:\n\t\tif ((item = window_choose_get_item(wp, key, m)) == NULL)\n\t\t\tbreak;\n\t\twindow_choose_fire_callback(wp, item->wcd);\n\t\tbreak;\n\tcase MODEKEYCHOICE_TREE_TOGGLE:\n\t\tif ((item = window_choose_get_item(wp, key, m)) == NULL)\n\t\t\tbreak;\n\t\tif (item->state & TREE_EXPANDED) {\n\t\t\twindow_choose_collapse(wp, item->wcd->tree_session,\n\t\t\t    data->selected);\n\t\t} else {\n\t\t\twindow_choose_expand(wp, item->wcd->tree_session,\n\t\t\t    data->selected);\n\t\t}\n\t\twindow_choose_redraw_screen(wp);\n\t\tbreak;\n\tcase MODEKEYCHOICE_TREE_COLLAPSE:\n\t\tif ((item = window_choose_get_item(wp, key, m)) == NULL)\n\t\t\tbreak;\n\t\tif (item->state & TREE_EXPANDED) {\n\t\t\twindow_choose_collapse(wp, item->wcd->tree_session,\n\t\t\t    data->selected);\n\t\t\twindow_choose_redraw_screen(wp);\n\t\t}\n\t\tbreak;\n\tcase MODEKEYCHOICE_TREE_COLLAPSE_ALL:\n\t\twindow_choose_collapse_all(wp);\n\t\tbreak;\n\tcase MODEKEYCHOICE_TREE_EXPAND:\n\t\tif ((item = window_choose_get_item(wp, key, m)) == NULL)\n\t\t\tbreak;\n\t\tif (!(item->state & TREE_EXPANDED)) {\n\t\t\twindow_choose_expand(wp, item->wcd->tree_session,\n\t\t\t    data->selected);\n\t\t\twindow_choose_redraw_screen(wp);\n\t\t}\n\t\tbreak;\n\tcase MODEKEYCHOICE_TREE_EXPAND_ALL:\n\t\twindow_choose_expand_all(wp);\n\t\tbreak;\n\tcase MODEKEYCHOICE_UP:\n\t\tif (items == 0)\n\t\t\tbreak;\n\t\tif (data->selected == 0) {\n\t\t\tdata->selected = items - 1;\n\t\t\tif (data->selected > screen_size_y(s) - 1)\n\t\t\t\tdata->top = items - screen_size_y(s);\n\t\t\twindow_choose_redraw_screen(wp);\n\t\t\tbreak;\n\t\t}\n\t\tdata->selected--;\n\t\tif (data->selected < data->top)\n\t\t\twindow_choose_scroll_up(wp);\n\t\telse {\n\t\t\tscreen_write_start(&ctx, wp, NULL);\n\t\t\twindow_choose_write_line(wp, &ctx,\n\t\t\t    data->selected - data->top);\n\t\t\twindow_choose_write_line(wp, &ctx,\n\t\t\t    data->selected + 1 - data->top);\n\t\t\tscreen_write_stop(&ctx);\n\t\t}\n\t\tbreak;\n\tcase MODEKEYCHOICE_DOWN:\n\t\tif (items == 0)\n\t\t\tbreak;\n\t\tif (data->selected == items - 1) {\n\t\t\tdata->selected = 0;\n\t\t\tdata->top = 0;\n\t\t\twindow_choose_redraw_screen(wp);\n\t\t\tbreak;\n\t\t}\n\t\tdata->selected++;\n\n\t\tif (data->selected < data->top + screen_size_y(s)) {\n\t\t\tscreen_write_start(&ctx, wp, NULL);\n\t\t\twindow_choose_write_line(wp, &ctx,\n\t\t\t    data->selected - data->top);\n\t\t\twindow_choose_write_line(wp, &ctx,\n\t\t\t    data->selected - 1 - data->top);\n\t\t\tscreen_write_stop(&ctx);\n\t\t} else\n\t\t\twindow_choose_scroll_down(wp);\n\t\tbreak;\n\tcase MODEKEYCHOICE_SCROLLUP:\n\t\tif (items == 0 || data->top == 0)\n\t\t\tbreak;\n\t\tif (data->selected == data->top + screen_size_y(s) - 1) {\n\t\t\tdata->selected--;\n\t\t\twindow_choose_scroll_up(wp);\n\t\t\tscreen_write_start(&ctx, wp, NULL);\n\t\t\twindow_choose_write_line(wp, &ctx,\n\t\t\t    screen_size_y(s) - 1);\n\t\t\tscreen_write_stop(&ctx);\n\t\t} else\n\t\t\twindow_choose_scroll_up(wp);\n\t\tbreak;\n\tcase MODEKEYCHOICE_SCROLLDOWN:\n\t\tif (items == 0 ||\n\t\t    data->top + screen_size_y(&data->screen) >= items)\n\t\t\tbreak;\n\t\tif (data->selected == data->top) {\n\t\t\tdata->selected++;\n\t\t\twindow_choose_scroll_down(wp);\n\t\t\tscreen_write_start(&ctx, wp, NULL);\n\t\t\twindow_choose_write_line(wp, &ctx, 0);\n\t\t\tscreen_write_stop(&ctx);\n\t\t} else\n\t\t\twindow_choose_scroll_down(wp);\n\t\tbreak;\n\tcase MODEKEYCHOICE_PAGEUP:\n\t\tif (data->selected < screen_size_y(s)) {\n\t\t\tdata->selected = 0;\n\t\t\tdata->top = 0;\n\t\t} else {\n\t\t\tdata->selected -= screen_size_y(s);\n\t\t\tif (data->top < screen_size_y(s))\n\t\t\t\tdata->top = 0;\n\t\t\telse\n\t\t\t\tdata->top -= screen_size_y(s);\n\t\t}\n\t\twindow_choose_redraw_screen(wp);\n\t\tbreak;\n\tcase MODEKEYCHOICE_PAGEDOWN:\n\t\tdata->selected += screen_size_y(s);\n\t\tif (data->selected > items - 1)\n\t\t\tdata->selected = items - 1;\n\t\tdata->top += screen_size_y(s);\n\t\tif (screen_size_y(s) < items) {\n\t\t\tif (data->top + screen_size_y(s) > items)\n\t\t\t\tdata->top = items - screen_size_y(s);\n\t\t} else\n\t\t\tdata->top = 0;\n\t\tif (data->selected < data->top)\n\t\t\tdata->top = data->selected;\n\t\twindow_choose_redraw_screen(wp);\n\t\tbreak;\n\tcase MODEKEYCHOICE_BACKSPACE:\n\t\tinput_len = strlen(data->input_str);\n\t\tif (input_len > 0)\n\t\t\tdata->input_str[input_len - 1] = '\\0';\n\t\twindow_choose_redraw_screen(wp);\n\t\tbreak;\n\tcase MODEKEYCHOICE_STARTNUMBERPREFIX:\n\t\tkey &= KEYC_MASK_KEY;\n\t\tif (key < '0' || key > '9')\n\t\t\tbreak;\n\t\twindow_choose_prompt_input(WINDOW_CHOOSE_GOTO_ITEM,\n\t\t    \"Goto Item\", wp, key);\n\t\tbreak;\n\tcase MODEKEYCHOICE_STARTOFLIST:\n\t\tdata->selected = 0;\n\t\tdata->top = 0;\n\t\twindow_choose_redraw_screen(wp);\n\t\tbreak;\n\tcase MODEKEYCHOICE_TOPLINE:\n\t\tdata->selected = data->top;\n\t\twindow_choose_redraw_screen(wp);\n\t\tbreak;\n\tcase MODEKEYCHOICE_BOTTOMLINE:\n\t\tdata->selected = data->top + screen_size_y(s) - 1;\n\t\tif (data->selected > items - 1)\n\t\t\tdata->selected = items - 1;\n\t\twindow_choose_redraw_screen(wp);\n\t\tbreak;\n\tcase MODEKEYCHOICE_ENDOFLIST:\n\t\tdata->selected = items - 1;\n\t\tif (screen_size_y(s) < items)\n\t\t\tdata->top = items - screen_size_y(s);\n\t\telse\n\t\t\tdata->top = 0;\n\t\twindow_choose_redraw_screen(wp);\n\t\tbreak;\n\tdefault:\n\t\tidx = window_choose_index_key(data, key);\n\t\tif (idx < 0 || (u_int) idx >= ARRAY_LENGTH(&data->list))\n\t\t\tbreak;\n\t\tdata->selected = idx;\n\n\t\titem = &ARRAY_ITEM(&data->list, data->selected);\n\t\twindow_choose_fire_callback(wp, item->wcd);\n\t\tbreak;\n\t}\n}\n\nvoid\nwindow_choose_write_line(struct window_pane *wp, struct screen_write_ctx *ctx,\n    u_int py)\n{\n\tstruct window_choose_mode_data\t*data = wp->modedata;\n\tstruct window_choose_mode_item\t*item;\n\tstruct options\t\t\t*oo = wp->window->options;\n\tstruct screen\t\t\t*s = &data->screen;\n\tstruct grid_cell\t\t gc;\n\tsize_t\t\t\t\t last, xoff = 0;\n\tchar\t\t\t\t hdr[32], label[32];\n\tint\t\t\t\t key;\n\n\tif (data->callbackfn == NULL)\n\t\tfatalx(\"called before callback assigned\");\n\n\tlast = screen_size_y(s) - 1;\n\tmemcpy(&gc, &grid_default_cell, sizeof gc);\n\tif (data->selected == data->top + py)\n\t\tstyle_apply(&gc, oo, \"mode-style\");\n\n\tscreen_write_cursormove(ctx, 0, py);\n\tif (data->top + py  < ARRAY_LENGTH(&data->list)) {\n\t\titem = &ARRAY_ITEM(&data->list, data->top + py);\n\t\tif (item->wcd->wl != NULL &&\n\t\t    item->wcd->wl->flags & WINLINK_ALERTFLAGS)\n\t\t\tgc.attr |= GRID_ATTR_BRIGHT;\n\n\t\tkey = window_choose_key_index(data, data->top + py);\n\t\tif (key != -1)\n\t\t\txsnprintf(label, sizeof label, \"(%c)\", key);\n\t\telse\n\t\t\txsnprintf(label, sizeof label, \"(%d)\", item->pos);\n\t\tscreen_write_nputs(ctx, screen_size_x(s) - 1, &gc,\n\t\t    \"%*s %s %s\", data->width + 2, label,\n\t\t    /*\n\t\t     * Add indication to tree if necessary about whether it's\n\t\t     * expanded or not.\n\t\t     */\n\t\t    (item->wcd->type & TREE_SESSION) ?\n\t\t    (item->state & TREE_EXPANDED ? \"-\" : \"+\") : \"\", item->name);\n\t}\n\twhile (s->cx < screen_size_x(s) - 1)\n\t\tscreen_write_putc(ctx, &gc, ' ');\n\n\tif (data->input_type != WINDOW_CHOOSE_NORMAL) {\n\t\tstyle_apply(&gc, oo, \"mode-style\");\n\n\t\txoff = xsnprintf(hdr, sizeof hdr,\n\t\t\t\"%s: %s\", data->input_prompt, data->input_str);\n\t\tscreen_write_cursormove(ctx, 0, last);\n\t\tscreen_write_puts(ctx, &gc, \"%s\", hdr);\n\t\tscreen_write_cursormove(ctx, xoff, py);\n\t\tmemcpy(&gc, &grid_default_cell, sizeof gc);\n\t}\n\n}\n\nint\nwindow_choose_key_index(struct window_choose_mode_data *data, u_int idx)\n{\n\tstatic const char\tkeys[] = \"0123456789\"\n\t                                 \"abcdefghijklmnopqrstuvwxyz\"\n\t                                 \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\tconst char\t       *ptr;\n\tint\t\t\tmkey;\n\n\tfor (ptr = keys; *ptr != '\\0'; ptr++) {\n\t\tmkey = mode_key_lookup(&data->mdata, *ptr, NULL);\n\t\tif (mkey != MODEKEY_NONE && mkey != MODEKEY_OTHER)\n\t\t\tcontinue;\n\t\tif (idx-- == 0)\n\t\t\treturn (*ptr);\n\t}\n\treturn (-1);\n}\n\nint\nwindow_choose_index_key(struct window_choose_mode_data *data, key_code key)\n{\n\tstatic const char\tkeys[] = \"0123456789\"\n\t                                 \"abcdefghijklmnopqrstuvwxyz\"\n\t                                 \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\tconst char\t       *ptr;\n\tint\t\t\tmkey;\n\tu_int\t\t\tidx = 0;\n\n\tfor (ptr = keys; *ptr != '\\0'; ptr++) {\n\t\tmkey = mode_key_lookup(&data->mdata, *ptr, NULL);\n\t\tif (mkey != MODEKEY_NONE && mkey != MODEKEY_OTHER)\n\t\t\tcontinue;\n\t\tif (key == (key_code)*ptr)\n\t\t\treturn (idx);\n\t\tidx++;\n\t}\n\treturn (-1);\n}\n\nvoid\nwindow_choose_redraw_screen(struct window_pane *wp)\n{\n\tstruct window_choose_mode_data\t*data = wp->modedata;\n\tstruct screen\t\t\t*s = &data->screen;\n\tstruct screen_write_ctx\t \t ctx;\n\tu_int\t\t\t\t i;\n\n\tscreen_write_start(&ctx, wp, NULL);\n\tfor (i = 0; i < screen_size_y(s); i++)\n\t\twindow_choose_write_line(wp, &ctx, i);\n\tscreen_write_stop(&ctx);\n}\n\nvoid\nwindow_choose_scroll_up(struct window_pane *wp)\n{\n\tstruct window_choose_mode_data\t*data = wp->modedata;\n\tstruct screen_write_ctx\t\t ctx;\n\n\tif (data->top == 0)\n\t\treturn;\n\tdata->top--;\n\n\tscreen_write_start(&ctx, wp, NULL);\n\tscreen_write_cursormove(&ctx, 0, 0);\n\tscreen_write_insertline(&ctx, 1);\n\twindow_choose_write_line(wp, &ctx, 0);\n\tif (screen_size_y(&data->screen) > 1)\n\t\twindow_choose_write_line(wp, &ctx, 1);\n\tscreen_write_stop(&ctx);\n}\n\nvoid\nwindow_choose_scroll_down(struct window_pane *wp)\n{\n\tstruct window_choose_mode_data\t*data = wp->modedata;\n\tstruct screen\t\t\t*s = &data->screen;\n\tstruct screen_write_ctx\t\t ctx;\n\n\tif (data->top >= ARRAY_LENGTH(&data->list))\n\t\treturn;\n\tdata->top++;\n\n\tscreen_write_start(&ctx, wp, NULL);\n\tscreen_write_cursormove(&ctx, 0, 0);\n\tscreen_write_deleteline(&ctx, 1);\n\twindow_choose_write_line(wp, &ctx, screen_size_y(s) - 1);\n\tif (screen_size_y(&data->screen) > 1)\n\t\twindow_choose_write_line(wp, &ctx, screen_size_y(s) - 2);\n\tscreen_write_stop(&ctx);\n}\n\nstruct window_choose_data *\nwindow_choose_add_session(struct window_pane *wp, struct client *c,\n    struct session *s, const char *template, const char *action, u_int idx)\n{\n\tstruct window_choose_data\t*wcd;\n\n\twcd = window_choose_data_create(TREE_SESSION, c, c->session);\n\twcd->idx = s->id;\n\n\twcd->tree_session = s;\n\twcd->tree_session->references++;\n\n\twcd->ft_template = xstrdup(template);\n\tformat_add(wcd->ft, \"line\", \"%u\", idx);\n\tformat_defaults(wcd->ft, NULL, s, NULL, NULL);\n\n\twcd->command = cmd_template_replace(action, s->name, 1);\n\n\twindow_choose_add(wp, wcd);\n\n\treturn (wcd);\n}\n\nstruct window_choose_data *\nwindow_choose_add_window(struct window_pane *wp, struct client *c,\n    struct session *s, struct winlink *wl, const char *template,\n    const char *action, u_int idx)\n{\n\tstruct window_choose_data\t*wcd;\n\tchar\t\t\t\t*expanded;\n\n\twcd = window_choose_data_create(TREE_WINDOW, c, c->session);\n\twcd->idx = wl->idx;\n\n\twcd->wl = wl;\n\n\twcd->tree_session = s;\n\twcd->tree_session->references++;\n\n\twcd->ft_template = xstrdup(template);\n\tformat_add(wcd->ft, \"line\", \"%u\", idx);\n\tformat_defaults(wcd->ft, NULL, s, wl, NULL);\n\n\txasprintf(&expanded, \"%s:%d\", s->name, wl->idx);\n\twcd->command = cmd_template_replace(action, expanded, 1);\n\tfree(expanded);\n\n\twindow_choose_add(wp, wcd);\n\n\treturn (wcd);\n}\n"
        },
        {
          "name": "window-clock.c",
          "type": "blob",
          "size": 6.3486328125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\n#include \"tmux.h\"\n\nstruct screen *window_clock_init(struct window_pane *);\nvoid\twindow_clock_free(struct window_pane *);\nvoid\twindow_clock_resize(struct window_pane *, u_int, u_int);\nvoid\twindow_clock_key(struct window_pane *, struct client *,\n\t    struct session *, key_code, struct mouse_event *);\n\nvoid\twindow_clock_timer_callback(int, short, void *);\nvoid\twindow_clock_draw_screen(struct window_pane *);\n\nconst struct window_mode window_clock_mode = {\n\twindow_clock_init,\n\twindow_clock_free,\n\twindow_clock_resize,\n\twindow_clock_key,\n};\n\nstruct window_clock_mode_data {\n\tstruct screen\t        screen;\n\ttime_t\t\t\ttim;\n\tstruct event\t\ttimer;\n};\n\nconst char window_clock_table[14][5][5] = {\n\t{ { 1,1,1,1,1 }, /* 0 */\n\t  { 1,0,0,0,1 },\n\t  { 1,0,0,0,1 },\n\t  { 1,0,0,0,1 },\n\t  { 1,1,1,1,1 } },\n\t{ { 0,0,0,0,1 }, /* 1 */\n\t  { 0,0,0,0,1 },\n\t  { 0,0,0,0,1 },\n\t  { 0,0,0,0,1 },\n\t  { 0,0,0,0,1 } },\n\t{ { 1,1,1,1,1 }, /* 2 */\n\t  { 0,0,0,0,1 },\n\t  { 1,1,1,1,1 },\n\t  { 1,0,0,0,0 },\n\t  { 1,1,1,1,1 } },\n\t{ { 1,1,1,1,1 }, /* 3 */\n\t  { 0,0,0,0,1 },\n\t  { 1,1,1,1,1 },\n\t  { 0,0,0,0,1 },\n\t  { 1,1,1,1,1 } },\n\t{ { 1,0,0,0,1 }, /* 4 */\n\t  { 1,0,0,0,1 },\n\t  { 1,1,1,1,1 },\n\t  { 0,0,0,0,1 },\n\t  { 0,0,0,0,1 } },\n\t{ { 1,1,1,1,1 }, /* 5 */\n\t  { 1,0,0,0,0 },\n\t  { 1,1,1,1,1 },\n\t  { 0,0,0,0,1 },\n\t  { 1,1,1,1,1 } },\n\t{ { 1,1,1,1,1 }, /* 6 */\n\t  { 1,0,0,0,0 },\n\t  { 1,1,1,1,1 },\n\t  { 1,0,0,0,1 },\n\t  { 1,1,1,1,1 } },\n\t{ { 1,1,1,1,1 }, /* 7 */\n\t  { 0,0,0,0,1 },\n\t  { 0,0,0,0,1 },\n\t  { 0,0,0,0,1 },\n\t  { 0,0,0,0,1 } },\n\t{ { 1,1,1,1,1 }, /* 8 */\n\t  { 1,0,0,0,1 },\n\t  { 1,1,1,1,1 },\n\t  { 1,0,0,0,1 },\n\t  { 1,1,1,1,1 } },\n\t{ { 1,1,1,1,1 }, /* 9 */\n\t  { 1,0,0,0,1 },\n\t  { 1,1,1,1,1 },\n\t  { 0,0,0,0,1 },\n\t  { 1,1,1,1,1 } },\n\t{ { 0,0,0,0,0 }, /* : */\n\t  { 0,0,1,0,0 },\n\t  { 0,0,0,0,0 },\n\t  { 0,0,1,0,0 },\n\t  { 0,0,0,0,0 } },\n\t{ { 1,1,1,1,1 }, /* A */\n\t  { 1,0,0,0,1 },\n\t  { 1,1,1,1,1 },\n\t  { 1,0,0,0,1 },\n\t  { 1,0,0,0,1 } },\n\t{ { 1,1,1,1,1 }, /* P */\n\t  { 1,0,0,0,1 },\n\t  { 1,1,1,1,1 },\n\t  { 1,0,0,0,0 },\n\t  { 1,0,0,0,0 } },\n\t{ { 1,0,0,0,1 }, /* M */\n\t  { 1,1,0,1,1 },\n\t  { 1,0,1,0,1 },\n\t  { 1,0,0,0,1 },\n\t  { 1,0,0,0,1 } },\n};\n\nvoid\nwindow_clock_timer_callback(__unused int fd, __unused short events, void *arg)\n{\n\tstruct window_pane\t\t*wp = arg;\n\tstruct window_clock_mode_data\t*data = wp->modedata;\n\tstruct tm\t\t\t now, then;\n\ttime_t\t\t\t\t t;\n\tstruct timeval\t\t\t tv = { .tv_sec = 1 };\n\n\tevtimer_del(&data->timer);\n\tevtimer_add(&data->timer, &tv);\n\n\tt = time(NULL);\n\tgmtime_r(&t, &now);\n\tgmtime_r(&data->tim, &then);\n\tif (now.tm_min == then.tm_min)\n\t\treturn;\n\tdata->tim = t;\n\n\twindow_clock_draw_screen(wp);\n\tserver_redraw_window(wp->window);\n}\n\nstruct screen *\nwindow_clock_init(struct window_pane *wp)\n{\n\tstruct window_clock_mode_data\t*data;\n\tstruct screen\t\t\t*s;\n\tstruct timeval\t\t\t tv = { .tv_sec = 1 };\n\n\twp->modedata = data = xmalloc(sizeof *data);\n\tdata->tim = time(NULL);\n\n\tevtimer_set(&data->timer, window_clock_timer_callback, wp);\n\tevtimer_add(&data->timer, &tv);\n\n\ts = &data->screen;\n\tscreen_init(s, screen_size_x(&wp->base), screen_size_y(&wp->base), 0);\n\ts->mode &= ~MODE_CURSOR;\n\n\twindow_clock_draw_screen(wp);\n\n\treturn (s);\n}\n\nvoid\nwindow_clock_free(struct window_pane *wp)\n{\n\tstruct window_clock_mode_data\t*data = wp->modedata;\n\n\tevtimer_del(&data->timer);\n\tscreen_free(&data->screen);\n\tfree(data);\n}\n\nvoid\nwindow_clock_resize(struct window_pane *wp, u_int sx, u_int sy)\n{\n\tstruct window_clock_mode_data\t*data = wp->modedata;\n\tstruct screen\t\t\t*s = &data->screen;\n\n\tscreen_resize(s, sx, sy, 0);\n\twindow_clock_draw_screen(wp);\n}\n\nvoid\nwindow_clock_key(struct window_pane *wp, __unused struct client *c,\n    __unused struct session *sess, __unused key_code key,\n    __unused struct mouse_event *m)\n{\n\twindow_pane_reset_mode(wp);\n}\n\nvoid\nwindow_clock_draw_screen(struct window_pane *wp)\n{\n\tstruct window_clock_mode_data\t*data = wp->modedata;\n\tstruct screen_write_ctx\t \t ctx;\n\tint\t\t\t\t colour, style;\n\tstruct screen\t\t\t*s = &data->screen;\n\tstruct grid_cell\t\t gc;\n\tchar\t\t\t\t tim[64], *ptr;\n\ttime_t\t\t\t\t t;\n\tstruct tm\t\t\t*tm;\n\tu_int\t\t\t\t i, j, x, y, idx;\n\n\tcolour = options_get_number(wp->window->options, \"clock-mode-colour\");\n\tstyle = options_get_number(wp->window->options, \"clock-mode-style\");\n\n\tscreen_write_start(&ctx, NULL, s);\n\n\tt = time(NULL);\n\ttm = localtime(&t);\n\tif (style == 0) {\n\t\tstrftime(tim, sizeof tim, \"%l:%M \", localtime(&t));\n\t\tif (tm->tm_hour >= 12)\n\t\t\tstrlcat(tim, \"PM\", sizeof tim);\n\t\telse\n\t\t\tstrlcat(tim, \"AM\", sizeof tim);\n\t} else\n\t\tstrftime(tim, sizeof tim, \"%H:%M\", tm);\n\n\tscreen_write_clearscreen(&ctx);\n\n\tif (screen_size_x(s) < 6 * strlen(tim) || screen_size_y(s) < 6) {\n\t\tif (screen_size_x(s) >= strlen(tim) && screen_size_y(s) != 0) {\n\t\t\tx = (screen_size_x(s) / 2) - (strlen(tim) / 2);\n\t\t\ty = screen_size_y(s) / 2;\n\t\t\tscreen_write_cursormove(&ctx, x, y);\n\n\t\t\tmemcpy(&gc, &grid_default_cell, sizeof gc);\n\t\t\tcolour_set_fg(&gc, colour);\n\t\t\tscreen_write_puts(&ctx, &gc, \"%s\", tim);\n\t\t}\n\n\t\tscreen_write_stop(&ctx);\n\t\treturn;\n\t}\n\n\tx = (screen_size_x(s) / 2) - 3 * strlen(tim);\n\ty = (screen_size_y(s) / 2) - 3;\n\n\tmemcpy(&gc, &grid_default_cell, sizeof gc);\n\tcolour_set_bg(&gc, colour);\n\tfor (ptr = tim; *ptr != '\\0'; ptr++) {\n\t\tif (*ptr >= '0' && *ptr <= '9')\n\t\t\tidx = *ptr - '0';\n\t\telse if (*ptr == ':')\n\t\t\tidx = 10;\n\t\telse if (*ptr == 'A')\n\t\t\tidx = 11;\n\t\telse if (*ptr == 'P')\n\t\t\tidx = 12;\n\t\telse if (*ptr == 'M')\n\t\t\tidx = 13;\n\t\telse {\n\t\t\tx += 6;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (j = 0; j < 5; j++) {\n\t\t\tfor (i = 0; i < 5; i++) {\n\t\t\t\tscreen_write_cursormove(&ctx, x + i, y + j);\n\t\t\t\tif (window_clock_table[idx][j][i])\n\t\t\t\t\tscreen_write_putc(&ctx, &gc, ' ');\n\t\t\t}\n\t\t}\n\t\tx += 6;\n\t}\n\n\tscreen_write_stop(&ctx);\n}\n"
        },
        {
          "name": "window-copy.c",
          "type": "blob",
          "size": 58.892578125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <ctype.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n#include \"tmate.h\"\n\nstruct screen *window_copy_init(struct window_pane *);\nvoid\twindow_copy_free(struct window_pane *);\nvoid\twindow_copy_pagedown(struct window_pane *);\nvoid\twindow_copy_resize(struct window_pane *, u_int, u_int);\nvoid\twindow_copy_key(struct window_pane *, struct client *, struct session *,\n\t    key_code, struct mouse_event *);\nint\twindow_copy_key_input(struct window_pane *, key_code);\nint\twindow_copy_key_numeric_prefix(struct window_pane *, key_code);\n\nvoid\twindow_copy_redraw_selection(struct window_pane *, u_int);\nvoid\twindow_copy_redraw_lines(struct window_pane *, u_int, u_int);\nvoid\twindow_copy_redraw_screen(struct window_pane *);\nvoid\twindow_copy_write_line(struct window_pane *, struct screen_write_ctx *,\n\t    u_int);\nvoid\twindow_copy_write_lines(struct window_pane *,\n\t    struct screen_write_ctx *, u_int, u_int);\n\nvoid\twindow_copy_scroll_to(struct window_pane *, u_int, u_int);\nint\twindow_copy_search_compare(struct grid *, u_int, u_int, struct grid *,\n\t    u_int, int);\nint\twindow_copy_search_lr(struct grid *, struct grid *, u_int *, u_int,\n\t    u_int, u_int, int);\nint\twindow_copy_search_rl(struct grid *, struct grid *, u_int *, u_int,\n\t    u_int, u_int, int);\nvoid\twindow_copy_search_up(struct window_pane *, const char *);\nvoid\twindow_copy_search_down(struct window_pane *, const char *);\nvoid\twindow_copy_goto_line(struct window_pane *, const char *);\nvoid\twindow_copy_update_cursor(struct window_pane *, u_int, u_int);\nvoid\twindow_copy_start_selection(struct window_pane *);\nint\twindow_copy_update_selection(struct window_pane *, int);\nvoid   *window_copy_get_selection(struct window_pane *, size_t *);\nvoid\twindow_copy_copy_buffer(struct window_pane *, const char *, void *,\n\t    size_t);\nvoid\twindow_copy_copy_pipe(struct window_pane *, struct session *,\n\t    const char *, const char *);\nvoid\twindow_copy_copy_selection(struct window_pane *, const char *);\nvoid\twindow_copy_append_selection(struct window_pane *, const char *);\nvoid\twindow_copy_clear_selection(struct window_pane *);\nvoid\twindow_copy_copy_line(struct window_pane *, char **, size_t *, u_int,\n\t    u_int, u_int);\nint\twindow_copy_in_set(struct window_pane *, u_int, u_int, const char *);\nu_int\twindow_copy_find_length(struct window_pane *, u_int);\nvoid\twindow_copy_cursor_start_of_line(struct window_pane *);\nvoid\twindow_copy_cursor_back_to_indentation(struct window_pane *);\nvoid\twindow_copy_cursor_end_of_line(struct window_pane *);\nvoid\twindow_copy_other_end(struct window_pane *);\nvoid\twindow_copy_cursor_left(struct window_pane *);\nvoid\twindow_copy_cursor_right(struct window_pane *);\nvoid\twindow_copy_cursor_up(struct window_pane *, int);\nvoid\twindow_copy_cursor_down(struct window_pane *, int);\nvoid\twindow_copy_cursor_jump(struct window_pane *);\nvoid\twindow_copy_cursor_jump_back(struct window_pane *);\nvoid\twindow_copy_cursor_jump_to(struct window_pane *, int);\nvoid\twindow_copy_cursor_jump_to_back(struct window_pane *, int);\nvoid\twindow_copy_cursor_next_word(struct window_pane *, const char *);\nvoid\twindow_copy_cursor_next_word_end(struct window_pane *, const char *);\nvoid\twindow_copy_cursor_previous_word(struct window_pane *, const char *);\nvoid\twindow_copy_scroll_up(struct window_pane *, u_int);\nvoid\twindow_copy_scroll_down(struct window_pane *, u_int);\nvoid\twindow_copy_rectangle_toggle(struct window_pane *);\nvoid\twindow_copy_drag_update(struct client *, struct mouse_event *);\nvoid\twindow_copy_drag_release(struct client *, struct mouse_event *);\n\nconst struct window_mode window_copy_mode = {\n\twindow_copy_init,\n\twindow_copy_free,\n\twindow_copy_resize,\n\twindow_copy_key,\n};\n\n#include \"window-copy.h\"\n\nstruct screen *\nwindow_copy_init(struct window_pane *wp)\n{\n\tstruct window_copy_mode_data\t*data;\n\tstruct screen\t\t\t*s;\n\tint\t\t\t\t keys;\n\n\twp->modedata = data = xmalloc(sizeof *data);\n\tdata->oy = 0;\n\tdata->cx = 0;\n\tdata->cy = 0;\n\n\tdata->lastcx = 0;\n\tdata->lastsx = 0;\n\n\tdata->backing_written = 0;\n\n\tdata->rectflag = 0;\n\tdata->scroll_exit = 0;\n\n\tdata->inputtype = WINDOW_COPY_OFF;\n\tdata->inputprompt = NULL;\n\tdata->inputstr = xstrdup(\"\");\n\tdata->numprefix = -1;\n\n\tdata->searchtype = WINDOW_COPY_OFF;\n\tdata->searchstr = NULL;\n\n\tif (wp->fd != -1)\n\t\tbufferevent_disable(wp->event, EV_READ|EV_WRITE);\n\n\tdata->jumptype = WINDOW_COPY_OFF;\n\tdata->jumpchar = '\\0';\n\n\ts = &data->screen;\n\tscreen_init(s, screen_size_x(&wp->base), screen_size_y(&wp->base), 0);\n\n\tkeys = options_get_number(wp->window->options, \"mode-keys\");\n\tif (keys == MODEKEY_EMACS)\n\t\tmode_key_init(&data->mdata, &mode_key_tree_emacs_copy);\n\telse\n\t\tmode_key_init(&data->mdata, &mode_key_tree_vi_copy);\n\ts->sel.modekeys = keys;\n\n\tdata->backing = NULL;\n\n#ifdef TMATE\n\tdata->password_cb = NULL;\n#endif\n\n\treturn (s);\n}\n\nvoid\nwindow_copy_init_from_pane(struct window_pane *wp, int scroll_exit)\n{\n\tstruct window_copy_mode_data\t*data = wp->modedata;\n\tstruct screen\t\t\t*s = &data->screen;\n\tstruct screen_write_ctx\t \t ctx;\n\tu_int\t\t\t\t i;\n\n\tif (wp->mode != &window_copy_mode)\n\t\tfatalx(\"not in copy mode\");\n\n\tdata->backing = &wp->base;\n\tdata->cx = data->backing->cx;\n\tdata->cy = data->backing->cy;\n\tdata->scroll_exit = scroll_exit;\n\n\ts->cx = data->cx;\n\ts->cy = data->cy;\n\n\tscreen_write_start(&ctx, NULL, s);\n\tfor (i = 0; i < screen_size_y(s); i++)\n\t\twindow_copy_write_line(wp, &ctx, i);\n\tscreen_write_cursormove(&ctx, data->cx, data->cy);\n\tscreen_write_stop(&ctx);\n\n#ifdef TMATE\n\ttmate_sync_copy_mode(wp);\n#endif\n}\n\nvoid\nwindow_copy_init_for_output(struct window_pane *wp)\n{\n\tstruct window_copy_mode_data\t*data = wp->modedata;\n\n\tdata->backing = xmalloc(sizeof *data->backing);\n\tscreen_init(data->backing, screen_size_x(&wp->base),\n\t    screen_size_y(&wp->base), UINT_MAX);\n}\n\nvoid\nwindow_copy_free(struct window_pane *wp)\n{\n\tstruct window_copy_mode_data\t*data = wp->modedata;\n\n\tif (wp->fd != -1)\n\t\tbufferevent_enable(wp->event, EV_READ|EV_WRITE);\n\n\tfree(data->searchstr);\n\tfree(data->inputstr);\n\n\tif (data->backing != &wp->base) {\n\t\tscreen_free(data->backing);\n\t\tfree(data->backing);\n\t}\n\tscreen_free(&data->screen);\n\n\tfree(data);\n}\n\nvoid\nwindow_copy_add(struct window_pane *wp, const char *fmt, ...)\n{\n\tva_list\tap;\n\n\tva_start(ap, fmt);\n\twindow_copy_vadd(wp, fmt, ap);\n\tva_end(ap);\n}\n\nvoid\nwindow_copy_vadd(struct window_pane *wp, const char *fmt, va_list ap)\n{\n\tstruct window_copy_mode_data\t*data = wp->modedata;\n\tstruct screen\t\t\t*backing = data->backing;\n\tstruct screen_write_ctx\t \t back_ctx, ctx;\n\tstruct grid_cell\t\t gc;\n\tu_int\t\t\t\t old_hsize, old_cy;\n\n#ifdef TMATE\n\tchar\t\t\t\t*msg;\n#endif\n\n\tif (backing == &wp->base)\n\t\treturn;\n\n\tmemcpy(&gc, &grid_default_cell, sizeof gc);\n\n\told_hsize = screen_hsize(data->backing);\n\tscreen_write_start(&back_ctx, NULL, backing);\n\tif (data->backing_written) {\n\t\t/*\n\t\t * On the second or later line, do a CRLF before writing\n\t\t * (so it's on a new line).\n\t\t */\n\t\tscreen_write_carriagereturn(&back_ctx);\n\t\tscreen_write_linefeed(&back_ctx, 0);\n\t} else\n\t\tdata->backing_written = 1;\n\told_cy = backing->cy;\n#ifdef TMATE\n\txvasprintf(&msg, fmt, ap);\n\tscreen_write_nputs(&back_ctx, 0, &gc, \"%s\", msg);\n\ttmate_write_copy_mode(wp, msg);\n\tfree(msg);\n#else\n\tscreen_write_vnputs(&back_ctx, 0, &gc, fmt, ap);\n#endif\n\tscreen_write_stop(&back_ctx);\n\n\tdata->oy += screen_hsize(data->backing) - old_hsize;\n\n\tscreen_write_start(&ctx, wp, &data->screen);\n\n\t/*\n\t * If the history has changed, draw the top line.\n\t * (If there's any history at all, it has changed.)\n\t */\n\tif (screen_hsize(data->backing))\n\t\twindow_copy_redraw_lines(wp, 0, 1);\n\n\t/* Write the new lines. */\n\twindow_copy_redraw_lines(wp, old_cy, backing->cy - old_cy + 1);\n\n\tscreen_write_stop(&ctx);\n}\n\nvoid\nwindow_copy_pageup(struct window_pane *wp)\n{\n\tstruct window_copy_mode_data\t*data = wp->modedata;\n\tstruct screen\t\t\t*s = &data->screen;\n\tu_int\t\t\t\t n, ox, oy;\n\n\toy = screen_hsize(data->backing) + data->cy - data->oy;\n\tox = window_copy_find_length(wp, oy);\n\n\tif (s->sel.lineflag == LINE_SEL_LEFT_RIGHT && oy == data->sely)\n\t\twindow_copy_other_end(wp);\n\n\tif (data->cx != ox) {\n\t\tdata->lastcx = data->cx;\n\t\tdata->lastsx = ox;\n\t}\n\tdata->cx = data->lastcx;\n\n\tn = 1;\n\tif (screen_size_y(s) > 2)\n\t\tn = screen_size_y(s) - 2;\n\n\tif (data->oy + n > screen_hsize(data->backing))\n\t\tdata->oy = screen_hsize(data->backing);\n\telse\n\t\tdata->oy += n;\n\n\tif (!data->screen.sel.flag || !data->rectflag) {\n\t\tu_int py = screen_hsize(data->backing) + data->cy - data->oy;\n\t\tu_int px = window_copy_find_length(wp, py);\n\t\tif ((data->cx >= data->lastsx && data->cx != px) || data->cx > px)\n\t\t\twindow_copy_cursor_end_of_line(wp);\n\t}\n\n\twindow_copy_update_selection(wp, 1);\n\twindow_copy_redraw_screen(wp);\n}\n\nvoid\nwindow_copy_pagedown(struct window_pane *wp)\n{\n\tstruct window_copy_mode_data\t*data = wp->modedata;\n\tstruct screen\t\t\t*s = &data->screen;\n\tu_int\t\t\t\t n, ox, oy;\n\n\toy = screen_hsize(data->backing) + data->cy - data->oy;\n\tox = window_copy_find_length(wp, oy);\n\n\tif (s->sel.lineflag == LINE_SEL_RIGHT_LEFT && oy == data->sely)\n\t\twindow_copy_other_end(wp);\n\n\tif (data->cx != ox) {\n\t\tdata->lastcx = data->cx;\n\t\tdata->lastsx = ox;\n\t}\n\tdata->cx = data->lastcx;\n\n\tn = 1;\n\tif (screen_size_y(s) > 2)\n\t\tn = screen_size_y(s) - 2;\n\n\tif (data->oy < n)\n\t\tdata->oy = 0;\n\telse\n\t\tdata->oy -= n;\n\n\tif (!data->screen.sel.flag || !data->rectflag) {\n\t\tu_int py = screen_hsize(data->backing) + data->cy - data->oy;\n\t\tu_int px = window_copy_find_length(wp, py);\n\t\tif ((data->cx >= data->lastsx && data->cx != px) || data->cx > px)\n\t\t\twindow_copy_cursor_end_of_line(wp);\n\t}\n\n\tif (data->scroll_exit && data->oy == 0) {\n\t\twindow_pane_reset_mode(wp);\n\t\treturn;\n\t}\n\n\twindow_copy_update_selection(wp, 1);\n\twindow_copy_redraw_screen(wp);\n}\n\nvoid\nwindow_copy_resize(struct window_pane *wp, u_int sx, u_int sy)\n{\n\tstruct window_copy_mode_data\t*data = wp->modedata;\n\tstruct screen\t\t\t*s = &data->screen;\n\tstruct screen_write_ctx\t \t ctx;\n\n\tscreen_resize(s, sx, sy, 1);\n\tif (data->backing != &wp->base)\n\t\tscreen_resize(data->backing, sx, sy, 1);\n\n\tif (data->cy > sy - 1)\n\t\tdata->cy = sy - 1;\n\tif (data->cx > sx)\n\t\tdata->cx = sx;\n\tif (data->oy > screen_hsize(data->backing))\n\t\tdata->oy = screen_hsize(data->backing);\n\n\twindow_copy_clear_selection(wp);\n\n\tscreen_write_start(&ctx, NULL, s);\n\twindow_copy_write_lines(wp, &ctx, 0, screen_size_y(s) - 1);\n\tscreen_write_stop(&ctx);\n\n\twindow_copy_redraw_screen(wp);\n}\n\nstatic void\n__window_copy_key(struct window_pane *wp, struct client *c, struct session *sess,\n    key_code key, struct mouse_event *m)\n{\n\tconst char\t\t\t*word_separators;\n\tstruct window_copy_mode_data\t*data = wp->modedata;\n\tstruct screen\t\t\t*s = &data->screen;\n\tu_int\t\t\t\t n, np;\n\tint\t\t\t\t keys;\n\tenum mode_key_cmd\t\t cmd;\n\tconst char\t\t\t*arg, *ss;\n\n\tnp = 1;\n\tif (data->numprefix > 0)\n\t\tnp = data->numprefix;\n\n\tif (data->inputtype == WINDOW_COPY_JUMPFORWARD ||\n\t    data->inputtype == WINDOW_COPY_JUMPBACK ||\n\t    data->inputtype == WINDOW_COPY_JUMPTOFORWARD ||\n\t    data->inputtype == WINDOW_COPY_JUMPTOBACK) {\n\t\t/* Ignore keys with modifiers. */\n\t\tif ((key & KEYC_MASK_MOD) == 0) {\n\t\t\tdata->jumpchar = key;\n\t\t\tif (data->inputtype == WINDOW_COPY_JUMPFORWARD) {\n\t\t\t\tfor (; np != 0; np--)\n\t\t\t\t\twindow_copy_cursor_jump(wp);\n\t\t\t}\n\t\t\tif (data->inputtype == WINDOW_COPY_JUMPBACK) {\n\t\t\t\tfor (; np != 0; np--)\n\t\t\t\t\twindow_copy_cursor_jump_back(wp);\n\t\t\t}\n\t\t\tif (data->inputtype == WINDOW_COPY_JUMPTOFORWARD) {\n\t\t\t\tfor (; np != 0; np--)\n\t\t\t\t\twindow_copy_cursor_jump_to(wp, 0);\n\t\t\t}\n\t\t\tif (data->inputtype == WINDOW_COPY_JUMPTOBACK) {\n\t\t\t\tfor (; np != 0; np--)\n\t\t\t\t\twindow_copy_cursor_jump_to_back(wp, 0);\n\t\t\t}\n\t\t}\n\t\tdata->jumptype = data->inputtype;\n\t\tdata->inputtype = WINDOW_COPY_OFF;\n\t\twindow_copy_redraw_lines(wp, screen_size_y(s) - 1, 1);\n\t\treturn;\n\t} else if (data->inputtype == WINDOW_COPY_NUMERICPREFIX) {\n\t\tif (window_copy_key_numeric_prefix(wp, key) == 0)\n\t\t\treturn;\n\t\tdata->inputtype = WINDOW_COPY_OFF;\n\t\twindow_copy_redraw_lines(wp, screen_size_y(s) - 1, 1);\n\t} else if (data->inputtype != WINDOW_COPY_OFF) {\n\t\tif (window_copy_key_input(wp, key) != 0)\n\t\t\tgoto input_off;\n\t\treturn;\n\t}\n\n\tcmd = mode_key_lookup(&data->mdata, key, &arg);\n\tif (cmd != MODEKEYCOPY_PREVIOUSPAGE &&\n\t    cmd != MODEKEYCOPY_NEXTPAGE &&\n\t    cmd != MODEKEYCOPY_SCROLLUP &&\n\t    cmd != MODEKEYCOPY_SCROLLDOWN &&\n\t    cmd != MODEKEYCOPY_HALFPAGEUP &&\n\t    cmd != MODEKEYCOPY_HALFPAGEDOWN)\n\t\tdata->scroll_exit = 0;\n\tswitch (cmd) {\n\tcase MODEKEYCOPY_APPENDSELECTION:\n\t\tif (sess != NULL) {\n\t\t\twindow_copy_append_selection(wp, NULL);\n\t\t\tif (arg == NULL) {\n\t\t\t\twindow_pane_reset_mode(wp);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\twindow_copy_clear_selection(wp);\n\t\t\twindow_copy_redraw_screen(wp);\n\t\t}\n\t\tbreak;\n\tcase MODEKEYCOPY_CANCEL:\n\t\twindow_pane_reset_mode(wp);\n\t\treturn;\n\tcase MODEKEYCOPY_OTHEREND:\n\t\tif (np % 2)\n\t\t\twindow_copy_other_end(wp);\n\t\tbreak;\n\tcase MODEKEYCOPY_LEFT:\n\t\tfor (; np != 0; np--)\n\t\t\twindow_copy_cursor_left(wp);\n\t\tbreak;\n\tcase MODEKEYCOPY_RIGHT:\n\t\tfor (; np != 0; np--)\n\t\t\twindow_copy_cursor_right(wp);\n\t\tbreak;\n\tcase MODEKEYCOPY_UP:\n\t\tfor (; np != 0; np--)\n\t\t\twindow_copy_cursor_up(wp, 0);\n\t\tbreak;\n\tcase MODEKEYCOPY_DOWN:\n\t\tfor (; np != 0; np--)\n\t\t\twindow_copy_cursor_down(wp, 0);\n\t\tbreak;\n\tcase MODEKEYCOPY_SCROLLUP:\n\t\tfor (; np != 0; np--)\n\t\t\twindow_copy_cursor_up(wp, 1);\n\t\tbreak;\n\tcase MODEKEYCOPY_SCROLLDOWN:\n\t\tfor (; np != 0; np--)\n\t\t\twindow_copy_cursor_down(wp, 1);\n\t\tif (data->scroll_exit && data->oy == 0) {\n\t\t\twindow_pane_reset_mode(wp);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase MODEKEYCOPY_PREVIOUSPAGE:\n\t\tfor (; np != 0; np--)\n\t\t\twindow_copy_pageup(wp);\n\t\tbreak;\n\tcase MODEKEYCOPY_NEXTPAGE:\n\t\tfor (; np != 0; np--)\n\t\t\twindow_copy_pagedown(wp);\n\t\tbreak;\n\tcase MODEKEYCOPY_HALFPAGEUP:\n\t\tn = screen_size_y(s) / 2;\n\t\tfor (; np != 0; np--) {\n\t\t\tif (data->oy + n > screen_hsize(data->backing))\n\t\t\t\tdata->oy = screen_hsize(data->backing);\n\t\t\telse\n\t\t\t\tdata->oy += n;\n\t\t}\n\t\twindow_copy_update_selection(wp, 1);\n\t\twindow_copy_redraw_screen(wp);\n\t\tbreak;\n\tcase MODEKEYCOPY_HALFPAGEDOWN:\n\t\tn = screen_size_y(s) / 2;\n\t\tfor (; np != 0; np--) {\n\t\t\tif (data->oy < n)\n\t\t\t\tdata->oy = 0;\n\t\t\telse\n\t\t\t\tdata->oy -= n;\n\t\t}\n\t\tif (data->scroll_exit && data->oy == 0) {\n\t\t\twindow_pane_reset_mode(wp);\n\t\t\treturn;\n\t\t}\n\t\twindow_copy_update_selection(wp, 1);\n\t\twindow_copy_redraw_screen(wp);\n\t\tbreak;\n\tcase MODEKEYCOPY_TOPLINE:\n\t\tdata->cx = 0;\n\t\tdata->cy = 0;\n\t\twindow_copy_update_selection(wp, 1);\n\t\twindow_copy_redraw_screen(wp);\n\t\tbreak;\n\tcase MODEKEYCOPY_MIDDLELINE:\n\t\tdata->cx = 0;\n\t\tdata->cy = (screen_size_y(s) - 1) / 2;\n\t\twindow_copy_update_selection(wp, 1);\n\t\twindow_copy_redraw_screen(wp);\n\t\tbreak;\n\tcase MODEKEYCOPY_BOTTOMLINE:\n\t\tdata->cx = 0;\n\t\tdata->cy = screen_size_y(s) - 1;\n\t\twindow_copy_update_selection(wp, 1);\n\t\twindow_copy_redraw_screen(wp);\n\t\tbreak;\n\tcase MODEKEYCOPY_HISTORYTOP:\n\t\tdata->cx = 0;\n\t\tdata->cy = 0;\n\t\tdata->oy = screen_hsize(data->backing);\n\t\twindow_copy_update_selection(wp, 1);\n\t\twindow_copy_redraw_screen(wp);\n\t\tbreak;\n\tcase MODEKEYCOPY_HISTORYBOTTOM:\n\t\tdata->cx = 0;\n\t\tdata->cy = screen_size_y(s) - 1;\n\t\tdata->oy = 0;\n\t\twindow_copy_update_selection(wp, 1);\n\t\twindow_copy_redraw_screen(wp);\n\t\tbreak;\n\tcase MODEKEYCOPY_STARTSELECTION:\n\t\tif (KEYC_IS_MOUSE(key)) {\n\t\t\tif (c != NULL)\n\t\t\t\twindow_copy_start_drag(c, m);\n\t\t} else {\n\t\t\ts->sel.lineflag = LINE_SEL_NONE;\n\t\t\twindow_copy_start_selection(wp);\n\t\t\twindow_copy_redraw_screen(wp);\n\t\t}\n\t\tbreak;\n\tcase MODEKEYCOPY_SELECTLINE:\n\t\ts->sel.lineflag = LINE_SEL_LEFT_RIGHT;\n\t\tdata->rectflag = 0;\n\t\t/* FALLTHROUGH */\n\tcase MODEKEYCOPY_COPYLINE:\n\t\twindow_copy_cursor_start_of_line(wp);\n\t\t/* FALLTHROUGH */\n\tcase MODEKEYCOPY_COPYENDOFLINE:\n\t\twindow_copy_start_selection(wp);\n\t\tfor (; np > 1; np--)\n\t\t\twindow_copy_cursor_down(wp, 0);\n\t\twindow_copy_cursor_end_of_line(wp);\n\t\twindow_copy_redraw_screen(wp);\n\n\t\t/* If a copy command then copy the selection and exit. */\n\t\tif (sess != NULL &&\n\t\t    (cmd == MODEKEYCOPY_COPYLINE ||\n\t\t    cmd == MODEKEYCOPY_COPYENDOFLINE)) {\n\t\t\twindow_copy_copy_selection(wp, NULL);\n\t\t\twindow_pane_reset_mode(wp);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase MODEKEYCOPY_CLEARSELECTION:\n\t\twindow_copy_clear_selection(wp);\n\t\twindow_copy_redraw_screen(wp);\n\t\tbreak;\n\tcase MODEKEYCOPY_COPYPIPE:\n\t\tif (sess != NULL) {\n\t\t\twindow_copy_copy_pipe(wp, sess, NULL, arg);\n\t\t\twindow_pane_reset_mode(wp);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase MODEKEYCOPY_COPYSELECTION:\n\t\tif (sess != NULL) {\n\t\t\twindow_copy_copy_selection(wp, NULL);\n\t\t\tif (arg == NULL) {\n\t\t\t\twindow_pane_reset_mode(wp);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\twindow_copy_clear_selection(wp);\n\t\t\twindow_copy_redraw_screen(wp);\n\t\t}\n\t\tbreak;\n\tcase MODEKEYCOPY_STARTOFLINE:\n\t\twindow_copy_cursor_start_of_line(wp);\n\t\tbreak;\n\tcase MODEKEYCOPY_BACKTOINDENTATION:\n\t\twindow_copy_cursor_back_to_indentation(wp);\n\t\tbreak;\n\tcase MODEKEYCOPY_ENDOFLINE:\n\t\twindow_copy_cursor_end_of_line(wp);\n\t\tbreak;\n\tcase MODEKEYCOPY_NEXTSPACE:\n\t\tfor (; np != 0; np--)\n\t\t\twindow_copy_cursor_next_word(wp, \" \");\n\t\tbreak;\n\tcase MODEKEYCOPY_NEXTSPACEEND:\n\t\tfor (; np != 0; np--)\n\t\t\twindow_copy_cursor_next_word_end(wp, \" \");\n\t\tbreak;\n\tcase MODEKEYCOPY_NEXTWORD:\n\t\tword_separators =\n\t\t    options_get_string(sess->options, \"word-separators\");\n\t\tfor (; np != 0; np--)\n\t\t\twindow_copy_cursor_next_word(wp, word_separators);\n\t\tbreak;\n\tcase MODEKEYCOPY_NEXTWORDEND:\n\t\tword_separators =\n\t\t    options_get_string(sess->options, \"word-separators\");\n\t\tfor (; np != 0; np--)\n\t\t\twindow_copy_cursor_next_word_end(wp, word_separators);\n\t\tbreak;\n\tcase MODEKEYCOPY_PREVIOUSSPACE:\n\t\tfor (; np != 0; np--)\n\t\t\twindow_copy_cursor_previous_word(wp, \" \");\n\t\tbreak;\n\tcase MODEKEYCOPY_PREVIOUSWORD:\n\t\tword_separators =\n\t\t    options_get_string(sess->options, \"word-separators\");\n\t\tfor (; np != 0; np--)\n\t\t\twindow_copy_cursor_previous_word(wp, word_separators);\n\t\tbreak;\n\tcase MODEKEYCOPY_JUMP:\n\t\tdata->inputtype = WINDOW_COPY_JUMPFORWARD;\n\t\tdata->inputprompt = \"Jump Forward\";\n\t\t*data->inputstr = '\\0';\n\t\twindow_copy_redraw_lines(wp, screen_size_y(s) - 1, 1);\n\t\treturn; /* skip numprefix reset */\n\tcase MODEKEYCOPY_JUMPAGAIN:\n\t\tif (data->jumptype == WINDOW_COPY_JUMPFORWARD) {\n\t\t\tfor (; np != 0; np--)\n\t\t\t\twindow_copy_cursor_jump(wp);\n\t\t} else if (data->jumptype == WINDOW_COPY_JUMPBACK) {\n\t\t\tfor (; np != 0; np--)\n\t\t\t\twindow_copy_cursor_jump_back(wp);\n\t\t} else if (data->jumptype == WINDOW_COPY_JUMPTOFORWARD) {\n\t\t\tfor (; np != 0; np--)\n\t\t\t\twindow_copy_cursor_jump_to(wp, 1);\n\t\t} else if (data->jumptype == WINDOW_COPY_JUMPTOBACK) {\n\t\t\tfor (; np != 0; np--)\n\t\t\t\twindow_copy_cursor_jump_to_back(wp, 1);\n\t\t}\n\t\tbreak;\n\tcase MODEKEYCOPY_JUMPREVERSE:\n\t\tif (data->jumptype == WINDOW_COPY_JUMPFORWARD) {\n\t\t\tfor (; np != 0; np--)\n\t\t\t\twindow_copy_cursor_jump_back(wp);\n\t\t} else if (data->jumptype == WINDOW_COPY_JUMPBACK) {\n\t\t\tfor (; np != 0; np--)\n\t\t\t\twindow_copy_cursor_jump(wp);\n\t\t} else if (data->jumptype == WINDOW_COPY_JUMPTOFORWARD) {\n\t\t\tfor (; np != 0; np--)\n\t\t\t\twindow_copy_cursor_jump_to_back(wp, 1);\n\t\t} else if (data->jumptype == WINDOW_COPY_JUMPTOBACK) {\n\t\t\tfor (; np != 0; np--)\n\t\t\t\twindow_copy_cursor_jump_to(wp, 1);\n\t\t}\n\t\tbreak;\n\tcase MODEKEYCOPY_JUMPBACK:\n\t\tdata->inputtype = WINDOW_COPY_JUMPBACK;\n\t\tdata->inputprompt = \"Jump Back\";\n\t\t*data->inputstr = '\\0';\n\t\twindow_copy_redraw_lines(wp, screen_size_y(s) - 1, 1);\n\t\treturn; /* skip numprefix reset */\n\tcase MODEKEYCOPY_JUMPTO:\n\t\tdata->inputtype = WINDOW_COPY_JUMPTOFORWARD;\n\t\tdata->inputprompt = \"Jump To\";\n\t\t*data->inputstr = '\\0';\n\t\twindow_copy_redraw_lines(wp, screen_size_y(s) - 1, 1);\n\t\treturn; /* skip numprefix reset */\n\tcase MODEKEYCOPY_JUMPTOBACK:\n\t\tdata->inputtype = WINDOW_COPY_JUMPTOBACK;\n\t\tdata->inputprompt = \"Jump To Back\";\n\t\t*data->inputstr = '\\0';\n\t\twindow_copy_redraw_lines(wp, screen_size_y(s) - 1, 1);\n\t\treturn; /* skip numprefix reset */\n\tcase MODEKEYCOPY_SEARCHUP:\n\t\tdata->inputtype = WINDOW_COPY_SEARCHUP;\n\t\tdata->inputprompt = \"Search Up\";\n\t\tgoto input_on;\n\tcase MODEKEYCOPY_SEARCHDOWN:\n\t\tdata->inputtype = WINDOW_COPY_SEARCHDOWN;\n\t\tdata->inputprompt = \"Search Down\";\n\t\tgoto input_on;\n\tcase MODEKEYCOPY_SEARCHAGAIN:\n\tcase MODEKEYCOPY_SEARCHREVERSE:\n\t\tswitch (data->searchtype) {\n#ifdef TMATE\n\t\tcase WINDOW_COPY_PASSWORD:\n\t\t\tbreak;\n#endif\n\t\tcase WINDOW_COPY_OFF:\n\t\tcase WINDOW_COPY_GOTOLINE:\n\t\tcase WINDOW_COPY_JUMPFORWARD:\n\t\tcase WINDOW_COPY_JUMPBACK:\n\t\tcase WINDOW_COPY_JUMPTOFORWARD:\n\t\tcase WINDOW_COPY_JUMPTOBACK:\n\t\tcase WINDOW_COPY_NAMEDBUFFER:\n\t\tcase WINDOW_COPY_NUMERICPREFIX:\n\t\tcase WINDOW_COPY_SEARCHUP:\n\t\t\tss = data->searchstr;\n\t\t\tif (cmd == MODEKEYCOPY_SEARCHAGAIN) {\n\t\t\t\tfor (; np != 0; np--)\n\t\t\t\t\twindow_copy_search_up(wp, ss);\n\t\t\t} else {\n\t\t\t\tfor (; np != 0; np--)\n\t\t\t\t\twindow_copy_search_down(wp, ss);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase WINDOW_COPY_SEARCHDOWN:\n\t\t\tss = data->searchstr;\n\t\t\tif (cmd == MODEKEYCOPY_SEARCHAGAIN) {\n\t\t\t\tfor (; np != 0; np--)\n\t\t\t\t\twindow_copy_search_down(wp, ss);\n\t\t\t} else {\n\t\t\t\tfor (; np != 0; np--)\n\t\t\t\t\twindow_copy_search_up(wp, ss);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase MODEKEYCOPY_GOTOLINE:\n\t\tdata->inputtype = WINDOW_COPY_GOTOLINE;\n\t\tdata->inputprompt = \"Goto Line\";\n\t\t*data->inputstr = '\\0';\n\t\tgoto input_on;\n\tcase MODEKEYCOPY_STARTNAMEDBUFFER:\n\t\tdata->inputtype = WINDOW_COPY_NAMEDBUFFER;\n\t\tdata->inputexit = (arg == NULL);\n\t\tdata->inputprompt = \"Buffer\";\n\t\t*data->inputstr = '\\0';\n\t\tgoto input_on;\n\tcase MODEKEYCOPY_STARTNUMBERPREFIX:\n\t\tkey &= KEYC_MASK_KEY;\n\t\tif (key >= '0' && key <= '9') {\n\t\t\tdata->inputtype = WINDOW_COPY_NUMERICPREFIX;\n\t\t\tdata->numprefix = 0;\n\t\t\twindow_copy_key_numeric_prefix(wp, key);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase MODEKEYCOPY_RECTANGLETOGGLE:\n\t\ts->sel.lineflag = LINE_SEL_NONE;\n\t\twindow_copy_rectangle_toggle(wp);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tdata->numprefix = -1;\n\treturn;\n\ninput_on:\n\tkeys = options_get_number(wp->window->options, \"mode-keys\");\n\tif (keys == MODEKEY_EMACS)\n\t\tmode_key_init(&data->mdata, &mode_key_tree_emacs_edit);\n\telse\n\t\tmode_key_init(&data->mdata, &mode_key_tree_vi_edit);\n\n\twindow_copy_redraw_lines(wp, screen_size_y(s) - 1, 1);\n\treturn;\n\ninput_off:\n\tkeys = options_get_number(wp->window->options, \"mode-keys\");\n\tif (keys == MODEKEY_EMACS)\n\t\tmode_key_init(&data->mdata, &mode_key_tree_emacs_copy);\n\telse\n\t\tmode_key_init(&data->mdata, &mode_key_tree_vi_copy);\n\n\tdata->inputtype = WINDOW_COPY_OFF;\n\tdata->inputprompt = NULL;\n\n\twindow_copy_redraw_lines(wp, screen_size_y(s) - 1, 1);\n}\n\nvoid\nwindow_copy_key(struct window_pane *wp, struct client *c, struct session *sess,\n    key_code key, struct mouse_event *m)\n{\n\t__window_copy_key(wp, c, sess, key, m);\n#ifdef TMATE\n\ttmate_sync_copy_mode(wp);\n#endif\n}\n\nint\nwindow_copy_key_input(struct window_pane *wp, key_code key)\n{\n\tstruct window_copy_mode_data\t*data = wp->modedata;\n\tstruct screen\t\t\t*s = &data->screen;\n\tconst char\t\t\t*bufdata;\n\tsize_t\t\t\t\t inputlen, n, bufsize;\n\tint\t\t\t\t np;\n\tstruct paste_buffer\t\t*pb;\n\tu_char\t\t\t\t ch;\n\n\tswitch (mode_key_lookup(&data->mdata, key, NULL)) {\n\tcase MODEKEYEDIT_CANCEL:\n\t\tdata->numprefix = -1;\n\t\treturn (-1);\n\tcase MODEKEYEDIT_BACKSPACE:\n\t\tinputlen = strlen(data->inputstr);\n\t\tif (inputlen > 0)\n\t\t\tdata->inputstr[inputlen - 1] = '\\0';\n\t\tbreak;\n\tcase MODEKEYEDIT_DELETELINE:\n\t\t*data->inputstr = '\\0';\n\t\tbreak;\n\tcase MODEKEYEDIT_PASTE:\n\t\tif ((pb = paste_get_top(NULL)) == NULL)\n\t\t\tbreak;\n\t\tbufdata = paste_buffer_data(pb, &bufsize);\n\t\tfor (n = 0; n < bufsize; n++) {\n\t\t\tch = (u_char)bufdata[n];\n\t\t\tif (ch < 32 || ch == 127)\n\t\t\t\tbreak;\n\t\t}\n\t\tinputlen = strlen(data->inputstr);\n\n\t\tdata->inputstr = xrealloc(data->inputstr, inputlen + n + 1);\n\t\tmemcpy(data->inputstr + inputlen, bufdata, n);\n\t\tdata->inputstr[inputlen + n] = '\\0';\n\t\tbreak;\n\tcase MODEKEYEDIT_ENTER:\n\t\tnp = data->numprefix;\n\t\tif (np <= 0)\n\t\t\tnp = 1;\n\n\t\tswitch (data->inputtype) {\n\t\tcase WINDOW_COPY_OFF:\n\t\tcase WINDOW_COPY_JUMPFORWARD:\n\t\tcase WINDOW_COPY_JUMPBACK:\n\t\tcase WINDOW_COPY_JUMPTOFORWARD:\n\t\tcase WINDOW_COPY_JUMPTOBACK:\n\t\tcase WINDOW_COPY_NUMERICPREFIX:\n\t\t\tbreak;\n\t\tcase WINDOW_COPY_SEARCHUP:\n\t\t\tfor (; np != 0; np--)\n\t\t\t\twindow_copy_search_up(wp, data->inputstr);\n\t\t\tdata->searchtype = data->inputtype;\n\t\t\tdata->searchstr = xstrdup(data->inputstr);\n\t\t\tbreak;\n\t\tcase WINDOW_COPY_SEARCHDOWN:\n\t\t\tfor (; np != 0; np--)\n\t\t\t\twindow_copy_search_down(wp, data->inputstr);\n\t\t\tdata->searchtype = data->inputtype;\n\t\t\tdata->searchstr = xstrdup(data->inputstr);\n\t\t\tbreak;\n\t\tcase WINDOW_COPY_NAMEDBUFFER:\n\t\t\twindow_copy_copy_selection(wp, data->inputstr);\n\t\t\t*data->inputstr = '\\0';\n\t\t\tif (data->inputexit) {\n\t\t\t\twindow_pane_reset_mode(wp);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\twindow_copy_clear_selection(wp);\n\t\t\twindow_copy_redraw_screen(wp);\n\t\t\tbreak;\n\t\tcase WINDOW_COPY_GOTOLINE:\n\t\t\twindow_copy_goto_line(wp, data->inputstr);\n\t\t\t*data->inputstr = '\\0';\n\t\t\tbreak;\n#ifdef TMATE\n\t\tcase WINDOW_COPY_PASSWORD:\n\t\t\tif (data->password_cb) {\n\t\t\t\tdata->password_cb(data->inputstr,\n\t\t\t\t\t\t  data->password_cb_private);\n\t\t\t}\n\t\t\twindow_pane_reset_mode(wp);\n\t\t\treturn 0;\n#endif\n\t\t}\n\t\tdata->numprefix = -1;\n\t\treturn (1);\n\tcase MODEKEY_OTHER:\n\t\tif (key < 32 || key > 126)\n\t\t\tbreak;\n\t\tinputlen = strlen(data->inputstr) + 2;\n\n\t\tdata->inputstr = xrealloc(data->inputstr, inputlen);\n\t\tdata->inputstr[inputlen - 2] = key;\n\t\tdata->inputstr[inputlen - 1] = '\\0';\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\twindow_copy_redraw_lines(wp, screen_size_y(s) - 1, 1);\n\treturn (0);\n}\n\nint\nwindow_copy_key_numeric_prefix(struct window_pane *wp, key_code key)\n{\n\tstruct window_copy_mode_data\t*data = wp->modedata;\n\tstruct screen\t\t\t*s = &data->screen;\n\n\tkey &= KEYC_MASK_KEY;\n\tif (key < '0' || key > '9')\n\t\treturn (1);\n\n\tif (data->numprefix >= 100) \t/* no more than three digits */\n\t\treturn (0);\n\tdata->numprefix = data->numprefix * 10 + key - '0';\n\n\twindow_copy_redraw_lines(wp, screen_size_y(s) - 1, 1);\n\treturn (0);\n}\n\nvoid\nwindow_copy_scroll_to(struct window_pane *wp, u_int px, u_int py)\n{\n\tstruct window_copy_mode_data\t*data = wp->modedata;\n\tstruct grid\t\t\t*gd = data->backing->grid;\n\tu_int\t\t\t\t offset, gap;\n\n\tdata->cx = px;\n\n\tgap = gd->sy / 4;\n\tif (py < gd->sy) {\n\t\toffset = 0;\n\t\tdata->cy = py;\n\t} else if (py > gd->hsize + gd->sy - gap) {\n\t\toffset = gd->hsize;\n\t\tdata->cy = py - gd->hsize;\n\t} else {\n\t\toffset = py + gap - gd->sy;\n\t\tdata->cy = py - offset;\n\t}\n\tdata->oy = gd->hsize - offset;\n\n\twindow_copy_update_selection(wp, 1);\n\twindow_copy_redraw_screen(wp);\n}\n\nint\nwindow_copy_search_compare(struct grid *gd, u_int px, u_int py,\n    struct grid *sgd, u_int spx, int cis)\n{\n\tstruct grid_cell\t gc, sgc;\n\tconst struct utf8_data\t*ud, *sud;\n\n\tgrid_get_cell(gd, px, py, &gc);\n\tud = &gc.data;\n\tgrid_get_cell(sgd, spx, 0, &sgc);\n\tsud = &sgc.data;\n\n\tif (ud->size != sud->size || ud->width != sud->width)\n\t\treturn (0);\n\n\tif (cis && ud->size == 1)\n\t\treturn (tolower(ud->data[0]) == sud->data[0]);\n\n\treturn (memcmp(ud->data, sud->data, ud->size) == 0);\n}\n\nint\nwindow_copy_search_lr(struct grid *gd,\n    struct grid *sgd, u_int *ppx, u_int py, u_int first, u_int last, int cis)\n{\n\tu_int\tax, bx, px;\n\tint\tmatched;\n\n\tfor (ax = first; ax < last; ax++) {\n\t\tif (ax + sgd->sx >= gd->sx)\n\t\t\tbreak;\n\t\tfor (bx = 0; bx < sgd->sx; bx++) {\n\t\t\tpx = ax + bx;\n\t\t\tmatched = window_copy_search_compare(gd, px, py, sgd,\n\t\t\t    bx, cis);\n\t\t\tif (!matched)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (bx == sgd->sx) {\n\t\t\t*ppx = ax;\n\t\t\treturn (1);\n\t\t}\n\t}\n\treturn (0);\n}\n\nint\nwindow_copy_search_rl(struct grid *gd,\n    struct grid *sgd, u_int *ppx, u_int py, u_int first, u_int last, int cis)\n{\n\tu_int\tax, bx, px;\n\tint\tmatched;\n\n\tfor (ax = last + 1; ax > first; ax--) {\n\t\tif (gd->sx - (ax - 1) < sgd->sx)\n\t\t\tcontinue;\n\t\tfor (bx = 0; bx < sgd->sx; bx++) {\n\t\t\tpx = ax - 1 + bx;\n\t\t\tmatched = window_copy_search_compare(gd, px, py, sgd,\n\t\t\t    bx, cis);\n\t\t\tif (!matched)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (bx == sgd->sx) {\n\t\t\t*ppx = ax - 1;\n\t\t\treturn (1);\n\t\t}\n\t}\n\treturn (0);\n}\n\nvoid\nwindow_copy_search_up(struct window_pane *wp, const char *searchstr)\n{\n\tstruct window_copy_mode_data\t*data = wp->modedata;\n\tstruct screen\t\t\t*s = data->backing, ss;\n\tstruct screen_write_ctx\t\t ctx;\n\tstruct grid\t\t\t*gd = s->grid, *sgd;\n\tstruct grid_cell\t \t gc;\n\tsize_t\t\t\t\t searchlen;\n\tu_int\t\t\t\t i, last, fx, fy, px;\n\tint\t\t\t\t n, wrapped, wrapflag, cis;\n\tconst char\t\t\t*ptr;\n\n#ifdef TMATE\n\tif (!searchstr)\n\t\treturn;\n#endif\n\n\tif (*searchstr == '\\0')\n\t\treturn;\n\twrapflag = options_get_number(wp->window->options, \"wrap-search\");\n\tsearchlen = screen_write_strlen(\"%s\", searchstr);\n\n\tscreen_init(&ss, searchlen, 1, 0);\n\tscreen_write_start(&ctx, NULL, &ss);\n\tmemcpy(&gc, &grid_default_cell, sizeof gc);\n\tscreen_write_nputs(&ctx, -1, &gc, \"%s\", searchstr);\n\tscreen_write_stop(&ctx);\n\n\tfx = data->cx;\n\tfy = gd->hsize - data->oy + data->cy;\n\n\tif (fx == 0) {\n\t\tif (fy == 0)\n\t\t\treturn;\n\t\tfx = gd->sx - 1;\n\t\tfy--;\n\t} else\n\t\tfx--;\n\tn = wrapped = 0;\n\n\tcis = 1;\n\tfor (ptr = searchstr; *ptr != '\\0'; ptr++) {\n\t\tif (*ptr != tolower((u_char)*ptr)) {\n\t\t\tcis = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\nretry:\n\tsgd = ss.grid;\n\tfor (i = fy + 1; i > 0; i--) {\n\t\tlast = screen_size_x(s);\n\t\tif (i == fy + 1)\n\t\t\tlast = fx;\n\t\tn = window_copy_search_rl(gd, sgd, &px, i - 1, 0, last, cis);\n\t\tif (n) {\n\t\t\twindow_copy_scroll_to(wp, px, i - 1);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (wrapflag && !n && !wrapped) {\n\t\tfx = gd->sx - 1;\n\t\tfy = gd->hsize + gd->sy - 1;\n\t\twrapped = 1;\n\t\tgoto retry;\n\t}\n\n\tscreen_free(&ss);\n}\n\nvoid\nwindow_copy_search_down(struct window_pane *wp, const char *searchstr)\n{\n\tstruct window_copy_mode_data\t*data = wp->modedata;\n\tstruct screen\t\t\t*s = data->backing, ss;\n\tstruct screen_write_ctx\t\t ctx;\n\tstruct grid\t\t\t*gd = s->grid, *sgd;\n\tstruct grid_cell\t \t gc;\n\tsize_t\t\t\t\t searchlen;\n\tu_int\t\t\t\t i, first, fx, fy, px;\n\tint\t\t\t\t n, wrapped, wrapflag, cis;\n\tconst char\t\t\t*ptr;\n\n#ifdef TMATE\n\tif (!searchstr)\n\t\treturn;\n#endif\n\n\tif (*searchstr == '\\0')\n\t\treturn;\n\twrapflag = options_get_number(wp->window->options, \"wrap-search\");\n\tsearchlen = screen_write_strlen(\"%s\", searchstr);\n\n\tscreen_init(&ss, searchlen, 1, 0);\n\tscreen_write_start(&ctx, NULL, &ss);\n\tmemcpy(&gc, &grid_default_cell, sizeof gc);\n\tscreen_write_nputs(&ctx, -1, &gc, \"%s\", searchstr);\n\tscreen_write_stop(&ctx);\n\n\tfx = data->cx;\n\tfy = gd->hsize - data->oy + data->cy;\n\n\tif (fx == gd->sx - 1) {\n\t\tif (fy == gd->hsize + gd->sy)\n\t\t\treturn;\n\t\tfx = 0;\n\t\tfy++;\n\t} else\n\t\tfx++;\n\tn = wrapped = 0;\n\n\tcis = 1;\n\tfor (ptr = searchstr; *ptr != '\\0'; ptr++) {\n\t\tif (*ptr != tolower((u_char)*ptr)) {\n\t\t\tcis = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\nretry:\n\tsgd = ss.grid;\n\tfor (i = fy + 1; i < gd->hsize + gd->sy + 1; i++) {\n\t\tfirst = 0;\n\t\tif (i == fy + 1)\n\t\t\tfirst = fx;\n\t\tn = window_copy_search_lr(gd, sgd, &px, i - 1, first, gd->sx,\n\t\t    cis);\n\t\tif (n) {\n\t\t\twindow_copy_scroll_to(wp, px, i - 1);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (wrapflag && !n && !wrapped) {\n\t\tfx = 0;\n\t\tfy = 0;\n\t\twrapped = 1;\n\t\tgoto retry;\n\t}\n\n\tscreen_free(&ss);\n}\n\nvoid\nwindow_copy_goto_line(struct window_pane *wp, const char *linestr)\n{\n\tstruct window_copy_mode_data\t*data = wp->modedata;\n\tconst char\t\t\t*errstr;\n\tu_int\t\t\t\t lineno;\n\n\tlineno = strtonum(linestr, 0, screen_hsize(data->backing), &errstr);\n\tif (errstr != NULL)\n\t\treturn;\n\n\tdata->oy = lineno;\n\twindow_copy_update_selection(wp, 1);\n\twindow_copy_redraw_screen(wp);\n}\n\nvoid\nwindow_copy_write_line(struct window_pane *wp, struct screen_write_ctx *ctx,\n    u_int py)\n{\n\tstruct window_copy_mode_data\t*data = wp->modedata;\n\tstruct screen\t\t\t*s = &data->screen;\n\tstruct options\t\t\t*oo = wp->window->options;\n\tstruct grid_cell\t\t gc;\n\tchar\t\t\t\t hdr[512];\n\tsize_t\t\t\t\t last, xoff = 0, size = 0, limit;\n\n\tstyle_apply(&gc, oo, \"mode-style\");\n\n\tlast = screen_size_y(s) - 1;\n\tif (py == 0) {\n#ifdef TMATE\n\t\tif (data->inputtype != WINDOW_COPY_PASSWORD) {\n#endif\n\t\tsize = xsnprintf(hdr, sizeof hdr,\n\t\t    \"[%u/%u]\", data->oy, screen_hsize(data->backing));\n\t\tif (size > screen_size_x(s))\n\t\t\tsize = screen_size_x(s);\n\t\tscreen_write_cursormove(ctx, screen_size_x(s) - size, 0);\n\t\tscreen_write_puts(ctx, &gc, \"%s\", hdr);\n#ifdef TMATE\n\t\t}\n#endif\n\t} else if (py == last && data->inputtype != WINDOW_COPY_OFF) {\n\t\tlimit = sizeof hdr;\n\t\tif (limit > screen_size_x(s) + 1)\n\t\t\tlimit = screen_size_x(s) + 1;\n\t\tif (data->inputtype == WINDOW_COPY_NUMERICPREFIX) {\n\t\t\txoff = size = xsnprintf(hdr, limit,\n\t\t\t    \"Repeat: %d\", data->numprefix);\n\t\t} else {\n#ifdef TMATE\n\t\t\tif (data->inputtype == WINDOW_COPY_PASSWORD) {\n\t\t\t\tint password_len = strlen(data->inputstr);\n\t\t\t\txoff = size = xsnprintf(hdr, sizeof hdr, \"%s: \", data->inputprompt);\n\t\t\t\tmemset(hdr+xoff, '*', password_len);\n\t\t\t\txoff += password_len;\n\t\t\t\tsize += password_len;\n\t\t\t\thdr[xoff] = '\\0';\n\t\t\t}\n\t\t\telse\n#endif\n\t\t\txoff = size = xsnprintf(hdr, limit,\n\t\t\t    \"%s: %s\", data->inputprompt, data->inputstr);\n\t\t}\n\t\tscreen_write_cursormove(ctx, 0, last);\n\t\tscreen_write_puts(ctx, &gc, \"%s\", hdr);\n\t} else\n\t\tsize = 0;\n\n\tif (size < screen_size_x(s)) {\n\t\tscreen_write_cursormove(ctx, xoff, py);\n\t\tscreen_write_copy(ctx, data->backing, xoff,\n\t\t    (screen_hsize(data->backing) - data->oy) + py,\n\t\t    screen_size_x(s) - size, 1);\n\t}\n\n\tif (py == data->cy && data->cx == screen_size_x(s)) {\n\t\tmemcpy(&gc, &grid_default_cell, sizeof gc);\n\t\tscreen_write_cursormove(ctx, screen_size_x(s) - 1, py);\n\t\tscreen_write_putc(ctx, &gc, '$');\n\t}\n}\n\nvoid\nwindow_copy_write_lines(struct window_pane *wp, struct screen_write_ctx *ctx,\n    u_int py, u_int ny)\n{\n\tu_int\tyy;\n\n\tfor (yy = py; yy < py + ny; yy++)\n\t\twindow_copy_write_line(wp, ctx, py);\n}\n\nvoid\nwindow_copy_redraw_selection(struct window_pane *wp, u_int old_y)\n{\n\tstruct window_copy_mode_data\t*data = wp->modedata;\n\tu_int\t\t\t\t new_y, start, end;\n\n\tnew_y = data->cy;\n\tif (old_y <= new_y) {\n\t\tstart = old_y;\n\t\tend = new_y;\n\t} else {\n\t\tstart = new_y;\n\t\tend = old_y;\n\t}\n\twindow_copy_redraw_lines(wp, start, end - start + 1);\n}\n\nvoid\nwindow_copy_redraw_lines(struct window_pane *wp, u_int py, u_int ny)\n{\n\tstruct window_copy_mode_data\t*data = wp->modedata;\n\tstruct screen_write_ctx\t \t ctx;\n\tu_int\t\t\t\t i;\n\n\tscreen_write_start(&ctx, wp, NULL);\n\tfor (i = py; i < py + ny; i++)\n\t\twindow_copy_write_line(wp, &ctx, i);\n\tscreen_write_cursormove(&ctx, data->cx, data->cy);\n\tscreen_write_stop(&ctx);\n}\n\nvoid\nwindow_copy_redraw_screen(struct window_pane *wp)\n{\n\tstruct window_copy_mode_data\t*data = wp->modedata;\n\n\twindow_copy_redraw_lines(wp, 0, screen_size_y(&data->screen));\n}\n\nvoid\nwindow_copy_update_cursor(struct window_pane *wp, u_int cx, u_int cy)\n{\n\tstruct window_copy_mode_data\t*data = wp->modedata;\n\tstruct screen\t\t\t*s = &data->screen;\n\tstruct screen_write_ctx\t\t ctx;\n\tu_int\t\t\t\t old_cx, old_cy;\n\n\told_cx = data->cx; old_cy = data->cy;\n\tdata->cx = cx; data->cy = cy;\n\tif (old_cx == screen_size_x(s))\n\t\twindow_copy_redraw_lines(wp, old_cy, 1);\n\tif (data->cx == screen_size_x(s))\n\t\twindow_copy_redraw_lines(wp, data->cy, 1);\n\telse {\n\t\tscreen_write_start(&ctx, wp, NULL);\n\t\tscreen_write_cursormove(&ctx, data->cx, data->cy);\n\t\tscreen_write_stop(&ctx);\n\t}\n}\n\nvoid\nwindow_copy_start_selection(struct window_pane *wp)\n{\n\tstruct window_copy_mode_data\t*data = wp->modedata;\n\tstruct screen\t\t\t*s = &data->screen;\n\n\tdata->selx = data->cx;\n\tdata->sely = screen_hsize(data->backing) + data->cy - data->oy;\n\n\ts->sel.flag = 1;\n\twindow_copy_update_selection(wp, 1);\n}\n\nint\nwindow_copy_update_selection(struct window_pane *wp, int may_redraw)\n{\n\tstruct window_copy_mode_data\t*data = wp->modedata;\n\tstruct screen\t\t\t*s = &data->screen;\n\tstruct options\t\t\t*oo = wp->window->options;\n\tstruct grid_cell\t\t gc;\n\tu_int\t\t\t\t sx, sy, ty, cy;\n\n\tif (!s->sel.flag && s->sel.lineflag == LINE_SEL_NONE)\n\t\treturn (0);\n\n\t/* Set colours. */\n\tstyle_apply(&gc, oo, \"mode-style\");\n\n\t/* Find top of screen. */\n\tty = screen_hsize(data->backing) - data->oy;\n\n\t/* Adjust the selection. */\n\tsx = data->selx;\n\tsy = data->sely;\n\tif (sy < ty) {\t\t\t\t\t/* above screen */\n\t\tif (!data->rectflag)\n\t\t\tsx = 0;\n\t\tsy = 0;\n\t} else if (sy > ty + screen_size_y(s) - 1) {\t/* below screen */\n\t\tif (!data->rectflag)\n\t\t\tsx = screen_size_x(s) - 1;\n\t\tsy = screen_size_y(s) - 1;\n\t} else\n\t\tsy -= ty;\n\tsy = screen_hsize(s) + sy;\n\n\tscreen_set_selection(s,\n\t    sx, sy, data->cx, screen_hsize(s) + data->cy, data->rectflag, &gc);\n\n\tif (data->rectflag && may_redraw) {\n\t\t/*\n\t\t * Can't rely on the caller to redraw the right lines for\n\t\t * rectangle selection - find the highest line and the number\n\t\t * of lines, and redraw just past that in both directions\n\t\t */\n\t\tcy = data->cy;\n\t\tif (sy < cy)\n\t\t\twindow_copy_redraw_lines(wp, sy, cy - sy + 1);\n\t\telse\n\t\t\twindow_copy_redraw_lines(wp, cy, sy - cy + 1);\n\t}\n\n\treturn (1);\n}\n\nvoid *\nwindow_copy_get_selection(struct window_pane *wp, size_t *len)\n{\n\tstruct window_copy_mode_data\t*data = wp->modedata;\n\tstruct screen\t\t\t*s = &data->screen;\n\tchar\t\t\t\t*buf;\n\tsize_t\t\t\t\t off;\n\tu_int\t\t\t\t i, xx, yy, sx, sy, ex, ey, ey_last;\n\tu_int\t\t\t\t firstsx, lastex, restex, restsx;\n\tint\t\t\t\t keys;\n\n\tif (!s->sel.flag && s->sel.lineflag == LINE_SEL_NONE)\n\t\treturn (NULL);\n\n\tbuf = xmalloc(1);\n\toff = 0;\n\n\t*buf = '\\0';\n\n\t/*\n\t * The selection extends from selx,sely to (adjusted) cx,cy on\n\t * the base screen.\n\t */\n\n\t/* Find start and end. */\n\txx = data->cx;\n\tyy = screen_hsize(data->backing) + data->cy - data->oy;\n\tif (yy < data->sely || (yy == data->sely && xx < data->selx)) {\n\t\tsx = xx; sy = yy;\n\t\tex = data->selx; ey = data->sely;\n\t} else {\n\t\tsx = data->selx; sy = data->sely;\n\t\tex = xx; ey = yy;\n\t}\n\n\t/* Trim ex to end of line. */\n\tey_last = window_copy_find_length(wp, ey);\n\tif (ex > ey_last)\n\t\tex = ey_last;\n\n\t/*\n\t * Deal with rectangle-copy if necessary; four situations: start of\n\t * first line (firstsx), end of last line (lastex), start (restsx) and\n\t * end (restex) of all other lines.\n\t */\n\txx = screen_size_x(s);\n\n\t/*\n\t * Behave according to mode-keys. If it is emacs, copy like emacs,\n\t * keeping the top-left-most character, and dropping the\n\t * bottom-right-most, regardless of copy direction. If it is vi, also\n\t * keep bottom-right-most character.\n\t */\n\tkeys = options_get_number(wp->window->options, \"mode-keys\");\n\tif (data->rectflag) {\n\t\t/*\n\t\t * Need to ignore the column with the cursor in it, which for\n\t\t * rectangular copy means knowing which side the cursor is on.\n\t\t */\n\t\tif (data->selx < data->cx) {\n\t\t\t/* Selection start is on the left. */\n\t\t\tif (keys == MODEKEY_EMACS) {\n\t\t\t\tlastex = data->cx;\n\t\t\t\trestex = data->cx;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlastex = data->cx + 1;\n\t\t\t\trestex = data->cx + 1;\n\t\t\t}\n\t\t\tfirstsx = data->selx;\n\t\t\trestsx = data->selx;\n\t\t} else {\n\t\t\t/* Cursor is on the left. */\n\t\t\tlastex = data->selx + 1;\n\t\t\trestex = data->selx + 1;\n\t\t\tfirstsx = data->cx;\n\t\t\trestsx = data->cx;\n\t\t}\n\t} else {\n\t\tif (keys == MODEKEY_EMACS)\n\t\t\tlastex = ex;\n\t\telse\n\t\t\tlastex = ex + 1;\n\t\trestex = xx;\n\t\tfirstsx = sx;\n\t\trestsx = 0;\n\t}\n\n\t/* Copy the lines. */\n\tfor (i = sy; i <= ey; i++) {\n\t\twindow_copy_copy_line(wp, &buf, &off, i,\n\t\t    (i == sy ? firstsx : restsx),\n\t\t    (i == ey ? lastex : restex));\n\t}\n\n\t/* Don't bother if no data. */\n\tif (off == 0) {\n\t\tfree(buf);\n\t\treturn (NULL);\n\t}\n\tif (keys == MODEKEY_EMACS || lastex <= ey_last)\n\t\toff -= 1; /* remove final \\n (unless at end in vi mode) */\n\t*len = off;\n\treturn (buf);\n}\n\nvoid\nwindow_copy_copy_buffer(struct window_pane *wp, const char *bufname, void *buf,\n    size_t len)\n{\n\tstruct screen_write_ctx\tctx;\n\n\tif (options_get_number(global_options, \"set-clipboard\")) {\n\t\tscreen_write_start(&ctx, wp, NULL);\n\t\tscreen_write_setselection(&ctx, buf, len);\n\t\tscreen_write_stop(&ctx);\n\t}\n\n\tif (paste_set(buf, len, bufname, NULL) != 0)\n\t\tfree(buf);\n}\n\nvoid\nwindow_copy_copy_pipe(struct window_pane *wp, struct session *sess,\n    const char *bufname, const char *arg)\n{\n\tvoid\t\t\t*buf;\n\tsize_t\t\t\t len;\n\tstruct job\t\t*job;\n\tstruct format_tree\t*ft;\n\tchar\t\t\t*expanded;\n\n\tbuf = window_copy_get_selection(wp, &len);\n\tif (buf == NULL)\n\t\treturn;\n\n\tft = format_create(NULL, 0);\n\tformat_defaults(ft, NULL, sess, NULL, wp);\n\texpanded = format_expand(ft, arg);\n\n\tjob = job_run(expanded, sess, NULL, NULL, NULL, NULL);\n\tbufferevent_write(job->event, buf, len);\n\n\tfree(expanded);\n\tformat_free(ft);\n\n\twindow_copy_copy_buffer(wp, bufname, buf, len);\n}\n\nvoid\nwindow_copy_copy_selection(struct window_pane *wp, const char *bufname)\n{\n\tvoid\t*buf;\n\tsize_t\t len;\n\n\tbuf = window_copy_get_selection(wp, &len);\n\tif (buf == NULL)\n\t\treturn;\n\n\twindow_copy_copy_buffer(wp, bufname, buf, len);\n}\n\nvoid\nwindow_copy_append_selection(struct window_pane *wp, const char *bufname)\n{\n\tchar\t\t\t\t*buf;\n\tstruct paste_buffer\t\t*pb;\n\tconst char\t\t\t*bufdata;\n\tsize_t\t\t\t\t len, bufsize;\n\tstruct screen_write_ctx\t\t ctx;\n\n\tbuf = window_copy_get_selection(wp, &len);\n\tif (buf == NULL)\n\t\treturn;\n\n\tif (options_get_number(global_options, \"set-clipboard\")) {\n\t\tscreen_write_start(&ctx, wp, NULL);\n\t\tscreen_write_setselection(&ctx, buf, len);\n\t\tscreen_write_stop(&ctx);\n\t}\n\n\tif (bufname == NULL || *bufname == '\\0')\n\t\tpb = paste_get_top(&bufname);\n\telse\n\t\tpb = paste_get_name(bufname);\n\tif (pb != NULL) {\n\t\tbufdata = paste_buffer_data(pb, &bufsize);\n\t\tbuf = xrealloc(buf, len + bufsize);\n\t\tmemmove(buf + bufsize, buf, len);\n\t\tmemcpy(buf, bufdata, bufsize);\n\t\tlen += bufsize;\n\t}\n\tif (paste_set(buf, len, bufname, NULL) != 0)\n\t\tfree(buf);\n}\n\nvoid\nwindow_copy_copy_line(struct window_pane *wp, char **buf, size_t *off, u_int sy,\n    u_int sx, u_int ex)\n{\n\tstruct window_copy_mode_data\t*data = wp->modedata;\n\tstruct grid\t\t\t*gd = data->backing->grid;\n\tstruct grid_cell\t\t gc;\n\tstruct grid_line\t\t*gl;\n\tstruct utf8_data\t\t ud;\n\tu_int\t\t\t\t i, xx, wrapped = 0;\n\tconst char\t\t\t*s;\n\n\tif (sx > ex)\n\t\treturn;\n\n\t/*\n\t * Work out if the line was wrapped at the screen edge and all of it is\n\t * on screen.\n\t */\n\tgl = &gd->linedata[sy];\n\tif (gl->flags & GRID_LINE_WRAPPED && gl->cellsize <= gd->sx)\n\t\twrapped = 1;\n\n\t/* If the line was wrapped, don't strip spaces (use the full length). */\n\tif (wrapped)\n\t\txx = gl->cellsize;\n\telse\n\t\txx = window_copy_find_length(wp, sy);\n\tif (ex > xx)\n\t\tex = xx;\n\tif (sx > xx)\n\t\tsx = xx;\n\n\tif (sx < ex) {\n\t\tfor (i = sx; i < ex; i++) {\n\t\t\tgrid_get_cell(gd, i, sy, &gc);\n\t\t\tif (gc.flags & GRID_FLAG_PADDING)\n\t\t\t\tcontinue;\n\t\t\tutf8_copy(&ud, &gc.data);\n\t\t\tif (ud.size == 1 && (gc.attr & GRID_ATTR_CHARSET)) {\n\t\t\t\ts = tty_acs_get(NULL, ud.data[0]);\n\t\t\t\tif (s != NULL && strlen(s) <= sizeof ud.data) {\n\t\t\t\t\tud.size = strlen(s);\n\t\t\t\t\tmemcpy(ud.data, s, ud.size);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t*buf = xrealloc(*buf, (*off) + ud.size);\n\t\t\tmemcpy(*buf + *off, ud.data, ud.size);\n\t\t\t*off += ud.size;\n\t\t}\n\t}\n\n\t/* Only add a newline if the line wasn't wrapped. */\n\tif (!wrapped || ex != xx) {\n\t\t*buf = xrealloc(*buf, (*off) + 1);\n\t\t(*buf)[(*off)++] = '\\n';\n\t}\n}\n\nvoid\nwindow_copy_clear_selection(struct window_pane *wp)\n{\n\tstruct window_copy_mode_data   *data = wp->modedata;\n\tu_int\t\t\t\tpx, py;\n\n\tscreen_clear_selection(&data->screen);\n\n\tpy = screen_hsize(data->backing) + data->cy - data->oy;\n\tpx = window_copy_find_length(wp, py);\n\tif (data->cx > px)\n\t\twindow_copy_update_cursor(wp, px, data->cy);\n}\n\nint\nwindow_copy_in_set(struct window_pane *wp, u_int px, u_int py, const char *set)\n{\n\tstruct window_copy_mode_data\t*data = wp->modedata;\n\tstruct grid_cell\t\t gc;\n\tconst struct utf8_data\t\t*ud;\n\n\tgrid_get_cell(data->backing->grid, px, py, &gc);\n\n\tud = &gc.data;\n\tif (ud->size != 1 || (gc.flags & GRID_FLAG_PADDING))\n\t\treturn (0);\n\tif (*ud->data == 0x00 || *ud->data == 0x7f)\n\t\treturn (0);\n\treturn (strchr(set, *ud->data) != NULL);\n}\n\nu_int\nwindow_copy_find_length(struct window_pane *wp, u_int py)\n{\n\tstruct window_copy_mode_data\t*data = wp->modedata;\n\tstruct screen\t\t\t*s = data->backing;\n\tstruct grid_cell\t\t gc;\n\tu_int\t\t\t\t px;\n\n\t/*\n\t * If the pane has been resized, its grid can contain old overlong\n\t * lines. grid_peek_cell does not allow accessing cells beyond the\n\t * width of the grid, and screen_write_copy treats them as spaces, so\n\t * ignore them here too.\n\t */\n\tpx = s->grid->linedata[py].cellsize;\n\tif (px > screen_size_x(s))\n\t\tpx = screen_size_x(s);\n\twhile (px > 0) {\n\t\tgrid_get_cell(s->grid, px - 1, py, &gc);\n\t\tif (gc.data.size != 1 || *gc.data.data != ' ')\n\t\t\tbreak;\n\t\tpx--;\n\t}\n\treturn (px);\n}\n\nvoid\nwindow_copy_cursor_start_of_line(struct window_pane *wp)\n{\n\tstruct window_copy_mode_data\t*data = wp->modedata;\n\tstruct screen\t\t\t*back_s = data->backing;\n\tstruct screen\t\t\t*s = &data->screen;\n\tstruct grid\t\t\t*gd = back_s->grid;\n\tu_int\t\t\t\t py;\n\n\tif (data->cx == 0 && s->sel.lineflag == LINE_SEL_NONE) {\n\t\tpy = screen_hsize(back_s) + data->cy - data->oy;\n\t\twhile (py > 0 &&\n\t\t    gd->linedata[py-1].flags & GRID_LINE_WRAPPED) {\n\t\t\twindow_copy_cursor_up(wp, 0);\n\t\t\tpy = screen_hsize(back_s) + data->cy - data->oy;\n\t\t}\n\t}\n\twindow_copy_update_cursor(wp, 0, data->cy);\n\tif (window_copy_update_selection(wp, 1))\n\t\twindow_copy_redraw_lines(wp, data->cy, 1);\n}\n\nvoid\nwindow_copy_cursor_back_to_indentation(struct window_pane *wp)\n{\n\tstruct window_copy_mode_data\t*data = wp->modedata;\n\tu_int\t\t\t\t px, py, xx;\n\tstruct grid_cell\t\t gc;\n\n\tpx = 0;\n\tpy = screen_hsize(data->backing) + data->cy - data->oy;\n\txx = window_copy_find_length(wp, py);\n\n\twhile (px < xx) {\n\t\tgrid_get_cell(data->backing->grid, px, py, &gc);\n\t\tif (gc.data.size != 1 || *gc.data.data != ' ')\n\t\t\tbreak;\n\t\tpx++;\n\t}\n\n\twindow_copy_update_cursor(wp, px, data->cy);\n\tif (window_copy_update_selection(wp, 1))\n\t\twindow_copy_redraw_lines(wp, data->cy, 1);\n}\n\nvoid\nwindow_copy_cursor_end_of_line(struct window_pane *wp)\n{\n\tstruct window_copy_mode_data\t*data = wp->modedata;\n\tstruct screen\t\t\t*back_s = data->backing;\n\tstruct screen\t\t\t*s = &data->screen;\n\tstruct grid\t\t\t*gd = back_s->grid;\n\tu_int\t\t\t\t px, py;\n\n\tpy = screen_hsize(back_s) + data->cy - data->oy;\n\tpx = window_copy_find_length(wp, py);\n\n\tif (data->cx == px && s->sel.lineflag == LINE_SEL_NONE) {\n\t\tif (data->screen.sel.flag && data->rectflag)\n\t\t\tpx = screen_size_x(back_s);\n\t\tif (gd->linedata[py].flags & GRID_LINE_WRAPPED) {\n\t\t\twhile (py < gd->sy + gd->hsize &&\n\t\t\t    gd->linedata[py].flags & GRID_LINE_WRAPPED) {\n\t\t\t\twindow_copy_cursor_down(wp, 0);\n\t\t\t\tpy = screen_hsize(back_s)\n\t\t\t\t     + data->cy - data->oy;\n\t\t\t}\n\t\t\tpx = window_copy_find_length(wp, py);\n\t\t}\n\t}\n\twindow_copy_update_cursor(wp, px, data->cy);\n\n\tif (window_copy_update_selection(wp, 1))\n\t\twindow_copy_redraw_lines(wp, data->cy, 1);\n}\n\nvoid\nwindow_copy_other_end(struct window_pane *wp)\n{\n\tstruct window_copy_mode_data\t*data = wp->modedata;\n\tstruct screen\t\t\t*s = &data->screen;\n\tu_int\t\t\t\t selx, sely, cx, cy, yy, hsize;\n\n\tif (!s->sel.flag && s->sel.lineflag == LINE_SEL_NONE)\n\t\treturn;\n\n\tif (s->sel.lineflag == LINE_SEL_LEFT_RIGHT)\n\t\ts->sel.lineflag = LINE_SEL_RIGHT_LEFT;\n\telse if (s->sel.lineflag == LINE_SEL_RIGHT_LEFT)\n\t\ts->sel.lineflag = LINE_SEL_LEFT_RIGHT;\n\n\tselx = data->selx;\n\tsely = data->sely;\n\tcx = data->cx;\n\tcy = data->cy;\n\tyy = screen_hsize(data->backing) + data->cy - data->oy;\n\n\tdata->selx = cx;\n\tdata->sely = yy;\n\tdata->cx = selx;\n\n\thsize = screen_hsize(data->backing);\n\tif (sely < hsize - data->oy) {\n\t\tdata->oy = hsize - sely;\n\t\tdata->cy = 0;\n\t} else if (sely > hsize - data->oy + screen_size_y(s)) {\n\t\tdata->oy = hsize - sely + screen_size_y(s) - 1;\n\t\tdata->cy = screen_size_y(s) - 1;\n\t} else\n\t\tdata->cy = cy + sely - yy;\n\n\twindow_copy_redraw_screen(wp);\n}\n\nvoid\nwindow_copy_cursor_left(struct window_pane *wp)\n{\n\tstruct window_copy_mode_data\t*data = wp->modedata;\n\tu_int\t\t\t\t py;\n\n\tpy = screen_hsize(data->backing) + data->cy - data->oy;\n\tif (data->cx == 0 && py > 0) {\n\t\twindow_copy_cursor_up(wp, 0);\n\t\twindow_copy_cursor_end_of_line(wp);\n\t} else if (data->cx > 0) {\n\t\twindow_copy_update_cursor(wp, data->cx - 1, data->cy);\n\t\tif (window_copy_update_selection(wp, 1))\n\t\t\twindow_copy_redraw_lines(wp, data->cy, 1);\n\t}\n}\n\nvoid\nwindow_copy_cursor_right(struct window_pane *wp)\n{\n\tstruct window_copy_mode_data\t*data = wp->modedata;\n\tu_int\t\t\t\t px, py, yy;\n\n\tpy = screen_hsize(data->backing) + data->cy - data->oy;\n\tyy = screen_hsize(data->backing) + screen_size_y(data->backing) - 1;\n\tif (data->screen.sel.flag && data->rectflag)\n\t\tpx = screen_size_x(&data->screen);\n\telse {\n\t\tpx = window_copy_find_length(wp, py);\n\t}\n\n\tif (data->cx >= px && py < yy) {\n\t\twindow_copy_cursor_start_of_line(wp);\n\t\twindow_copy_cursor_down(wp, 0);\n\t} else if (data->cx < px) {\n\t\twindow_copy_update_cursor(wp, data->cx + 1, data->cy);\n\t\tif (window_copy_update_selection(wp, 1))\n\t\t\twindow_copy_redraw_lines(wp, data->cy, 1);\n\t}\n}\n\nvoid\nwindow_copy_cursor_up(struct window_pane *wp, int scroll_only)\n{\n\tstruct window_copy_mode_data\t*data = wp->modedata;\n\tstruct screen\t\t\t*s = &data->screen;\n\tu_int\t\t\t\t ox, oy, px, py;\n\n\toy = screen_hsize(data->backing) + data->cy - data->oy;\n\tox = window_copy_find_length(wp, oy);\n\tif (data->cx != ox) {\n\t\tdata->lastcx = data->cx;\n\t\tdata->lastsx = ox;\n\t}\n\n\tif (s->sel.lineflag == LINE_SEL_LEFT_RIGHT && oy == data->sely)\n\t\twindow_copy_other_end(wp);\n\n\tdata->cx = data->lastcx;\n\tif (scroll_only || data->cy == 0) {\n\t\twindow_copy_scroll_down(wp, 1);\n\t\tif (scroll_only) {\n\t\t\tif (data->cy == screen_size_y(s) - 1)\n\t\t\t\twindow_copy_redraw_lines(wp, data->cy, 1);\n\t\t\telse\n\t\t\t\twindow_copy_redraw_lines(wp, data->cy, 2);\n\t\t}\n\t} else {\n\t\twindow_copy_update_cursor(wp, data->cx, data->cy - 1);\n\t\tif (window_copy_update_selection(wp, 1)) {\n\t\t\tif (data->cy == screen_size_y(s) - 1)\n\t\t\t\twindow_copy_redraw_lines(wp, data->cy, 1);\n\t\t\telse\n\t\t\t\twindow_copy_redraw_lines(wp, data->cy, 2);\n\t\t}\n\t}\n\n\tif (!data->screen.sel.flag || !data->rectflag) {\n\t\tpy = screen_hsize(data->backing) + data->cy - data->oy;\n\t\tpx = window_copy_find_length(wp, py);\n\t\tif ((data->cx >= data->lastsx && data->cx != px) ||\n\t\t    data->cx > px)\n\t\t\twindow_copy_cursor_end_of_line(wp);\n\t}\n\n\tif (s->sel.lineflag == LINE_SEL_LEFT_RIGHT)\n\t\twindow_copy_cursor_end_of_line(wp);\n\telse if (s->sel.lineflag == LINE_SEL_RIGHT_LEFT)\n\t\twindow_copy_cursor_start_of_line(wp);\n}\n\nvoid\nwindow_copy_cursor_down(struct window_pane *wp, int scroll_only)\n{\n\tstruct window_copy_mode_data\t*data = wp->modedata;\n\tstruct screen\t\t\t*s = &data->screen;\n\tu_int\t\t\t\t ox, oy, px, py;\n\n\toy = screen_hsize(data->backing) + data->cy - data->oy;\n\tox = window_copy_find_length(wp, oy);\n\tif (data->cx != ox) {\n\t\tdata->lastcx = data->cx;\n\t\tdata->lastsx = ox;\n\t}\n\n\tif (s->sel.lineflag == LINE_SEL_RIGHT_LEFT && oy == data->sely)\n\t\twindow_copy_other_end(wp);\n\n\tdata->cx = data->lastcx;\n\tif (scroll_only || data->cy == screen_size_y(s) - 1) {\n\t\twindow_copy_scroll_up(wp, 1);\n\t\tif (scroll_only && data->cy > 0)\n\t\t\twindow_copy_redraw_lines(wp, data->cy - 1, 2);\n\t} else {\n\t\twindow_copy_update_cursor(wp, data->cx, data->cy + 1);\n\t\tif (window_copy_update_selection(wp, 1))\n\t\t\twindow_copy_redraw_lines(wp, data->cy - 1, 2);\n\t}\n\n\tif (!data->screen.sel.flag || !data->rectflag) {\n\t\tpy = screen_hsize(data->backing) + data->cy - data->oy;\n\t\tpx = window_copy_find_length(wp, py);\n\t\tif ((data->cx >= data->lastsx && data->cx != px) ||\n\t\t    data->cx > px)\n\t\t\twindow_copy_cursor_end_of_line(wp);\n\t}\n\n\tif (s->sel.lineflag == LINE_SEL_LEFT_RIGHT)\n\t\twindow_copy_cursor_end_of_line(wp);\n\telse if (s->sel.lineflag == LINE_SEL_RIGHT_LEFT)\n\t\twindow_copy_cursor_start_of_line(wp);\n}\n\nvoid\nwindow_copy_cursor_jump(struct window_pane *wp)\n{\n\tstruct window_copy_mode_data\t*data = wp->modedata;\n\tstruct screen\t\t\t*back_s = data->backing;\n\tstruct grid_cell\t\t gc;\n\tu_int\t\t\t\t px, py, xx;\n\n\tpx = data->cx + 1;\n\tpy = screen_hsize(back_s) + data->cy - data->oy;\n\txx = window_copy_find_length(wp, py);\n\n\twhile (px < xx) {\n\t\tgrid_get_cell(back_s->grid, px, py, &gc);\n\t\tif (!(gc.flags & GRID_FLAG_PADDING) &&\n\t\t    gc.data.size == 1 && *gc.data.data == data->jumpchar) {\n\t\t\twindow_copy_update_cursor(wp, px, data->cy);\n\t\t\tif (window_copy_update_selection(wp, 1))\n\t\t\t\twindow_copy_redraw_lines(wp, data->cy, 1);\n\t\t\treturn;\n\t\t}\n\t\tpx++;\n\t}\n}\n\nvoid\nwindow_copy_cursor_jump_back(struct window_pane *wp)\n{\n\tstruct window_copy_mode_data\t*data = wp->modedata;\n\tstruct screen\t\t\t*back_s = data->backing;\n\tstruct grid_cell\t\t gc;\n\tu_int\t\t\t\t px, py;\n\n\tpx = data->cx;\n\tpy = screen_hsize(back_s) + data->cy - data->oy;\n\n\tif (px > 0)\n\t\tpx--;\n\n\tfor (;;) {\n\t\tgrid_get_cell(back_s->grid, px, py, &gc);\n\t\tif (!(gc.flags & GRID_FLAG_PADDING) &&\n\t\t    gc.data.size == 1 && *gc.data.data == data->jumpchar) {\n\t\t\twindow_copy_update_cursor(wp, px, data->cy);\n\t\t\tif (window_copy_update_selection(wp, 1))\n\t\t\t\twindow_copy_redraw_lines(wp, data->cy, 1);\n\t\t\treturn;\n\t\t}\n\t\tif (px == 0)\n\t\t\tbreak;\n\t\tpx--;\n\t}\n}\n\nvoid\nwindow_copy_cursor_jump_to(struct window_pane *wp, int jump_again)\n{\n\tstruct window_copy_mode_data\t*data = wp->modedata;\n\tstruct screen\t\t\t*back_s = data->backing;\n\tstruct grid_cell\t\t gc;\n\tu_int\t\t\t\t px, py, xx;\n\n\tpx = data->cx + 1 + jump_again;\n\tpy = screen_hsize(back_s) + data->cy - data->oy;\n\txx = window_copy_find_length(wp, py);\n\n\twhile (px < xx) {\n\t\tgrid_get_cell(back_s->grid, px, py, &gc);\n\t\tif (!(gc.flags & GRID_FLAG_PADDING) &&\n\t\t    gc.data.size == 1 && *gc.data.data == data->jumpchar) {\n\t\t\twindow_copy_update_cursor(wp, px - 1, data->cy);\n\t\t\tif (window_copy_update_selection(wp, 1))\n\t\t\t\twindow_copy_redraw_lines(wp, data->cy, 1);\n\t\t\treturn;\n\t\t}\n\t\tpx++;\n\t}\n}\n\nvoid\nwindow_copy_cursor_jump_to_back(struct window_pane *wp, int jump_again)\n{\n\tstruct window_copy_mode_data\t*data = wp->modedata;\n\tstruct screen\t\t\t*back_s = data->backing;\n\tstruct grid_cell\t\t gc;\n\tu_int\t\t\t\t px, py;\n\n\tpx = data->cx;\n\tpy = screen_hsize(back_s) + data->cy - data->oy;\n\n\tif (px > 0)\n\t\tpx--;\n\n\tif (jump_again && px > 0)\n\t\tpx--;\n\n\tfor (;;) {\n\t\tgrid_get_cell(back_s->grid, px, py, &gc);\n\t\tif (!(gc.flags & GRID_FLAG_PADDING) &&\n\t\t    gc.data.size == 1 && *gc.data.data == data->jumpchar) {\n\t\t\twindow_copy_update_cursor(wp, px + 1, data->cy);\n\t\t\tif (window_copy_update_selection(wp, 1))\n\t\t\t\twindow_copy_redraw_lines(wp, data->cy, 1);\n\t\t\treturn;\n\t\t}\n\t\tif (px == 0)\n\t\t\tbreak;\n\t\tpx--;\n\t}\n}\n\nvoid\nwindow_copy_cursor_next_word(struct window_pane *wp, const char *separators)\n{\n\tstruct window_copy_mode_data\t*data = wp->modedata;\n\tstruct screen\t\t\t*back_s = data->backing;\n\tu_int\t\t\t\t px, py, xx, yy;\n\tint\t\t\t\t expected = 0;\n\n\tpx = data->cx;\n\tpy = screen_hsize(back_s) + data->cy - data->oy;\n\txx = window_copy_find_length(wp, py);\n\tyy = screen_hsize(back_s) + screen_size_y(back_s) - 1;\n\n\t/*\n\t * First skip past any nonword characters and then any word characters.\n\t *\n\t * expected is initially set to 0 for the former and then 1 for the\n\t * latter.\n\t */\n\tdo {\n\t\twhile (px > xx ||\n\t\t    window_copy_in_set(wp, px, py, separators) == expected) {\n\t\t\t/* Move down if we're past the end of the line. */\n\t\t\tif (px > xx) {\n\t\t\t\tif (py == yy)\n\t\t\t\t\treturn;\n\t\t\t\twindow_copy_cursor_down(wp, 0);\n\t\t\t\tpx = 0;\n\n\t\t\t\tpy = screen_hsize(back_s) + data->cy - data->oy;\n\t\t\t\txx = window_copy_find_length(wp, py);\n\t\t\t} else\n\t\t\t\tpx++;\n\t\t}\n\t\texpected = !expected;\n\t} while (expected == 1);\n\n\twindow_copy_update_cursor(wp, px, data->cy);\n\tif (window_copy_update_selection(wp, 1))\n\t\twindow_copy_redraw_lines(wp, data->cy, 1);\n}\n\nvoid\nwindow_copy_cursor_next_word_end(struct window_pane *wp,\n    const char *separators)\n{\n\tstruct window_copy_mode_data\t*data = wp->modedata;\n\tstruct options\t\t\t*oo = wp->window->options;\n\tstruct screen\t\t\t*back_s = data->backing;\n\tu_int\t\t\t\t px, py, xx, yy;\n\tint\t\t\t\t keys, expected = 1;\n\n\tpx = data->cx;\n\tpy = screen_hsize(back_s) + data->cy - data->oy;\n\txx = window_copy_find_length(wp, py);\n\tyy = screen_hsize(back_s) + screen_size_y(back_s) - 1;\n\n\tkeys = options_get_number(oo, \"mode-keys\");\n\tif (keys == MODEKEY_VI && !window_copy_in_set(wp, px, py, separators))\n\t\tpx++;\n\n\t/*\n\t * First skip past any word characters, then any nonword characters.\n\t *\n\t * expected is initially set to 1 for the former and then 0 for the\n\t * latter.\n\t */\n\tdo {\n\t\twhile (px > xx ||\n\t\t    window_copy_in_set(wp, px, py, separators) == expected) {\n\t\t\t/* Move down if we're past the end of the line. */\n\t\t\tif (px > xx) {\n\t\t\t\tif (py == yy)\n\t\t\t\t\treturn;\n\t\t\t\twindow_copy_cursor_down(wp, 0);\n\t\t\t\tpx = 0;\n\n\t\t\t\tpy = screen_hsize(back_s) + data->cy - data->oy;\n\t\t\t\txx = window_copy_find_length(wp, py);\n\t\t\t} else\n\t\t\t\tpx++;\n\t\t}\n\t\texpected = !expected;\n\t} while (expected == 0);\n\n\tif (keys == MODEKEY_VI && px != 0)\n\t\tpx--;\n\n\twindow_copy_update_cursor(wp, px, data->cy);\n\tif (window_copy_update_selection(wp, 1))\n\t\twindow_copy_redraw_lines(wp, data->cy, 1);\n}\n\n/* Move to the previous place where a word begins. */\nvoid\nwindow_copy_cursor_previous_word(struct window_pane *wp,\n    const char *separators)\n{\n\tstruct window_copy_mode_data\t*data = wp->modedata;\n\tu_int\t\t\t\t px, py;\n\n\tpx = data->cx;\n\tpy = screen_hsize(data->backing) + data->cy - data->oy;\n\n\t/* Move back to the previous word character. */\n\tfor (;;) {\n\t\tif (px > 0) {\n\t\t\tpx--;\n\t\t\tif (!window_copy_in_set(wp, px, py, separators))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (data->cy == 0 &&\n\t\t\t    (screen_hsize(data->backing) == 0 ||\n\t\t\t    data->oy >= screen_hsize(data->backing) - 1))\n\t\t\t\tgoto out;\n\t\t\twindow_copy_cursor_up(wp, 0);\n\n\t\t\tpy = screen_hsize(data->backing) + data->cy - data->oy;\n\t\t\tpx = window_copy_find_length(wp, py);\n\t\t}\n\t}\n\n\t/* Move back to the beginning of this word. */\n\twhile (px > 0 && !window_copy_in_set(wp, px - 1, py, separators))\n\t\tpx--;\n\nout:\n\twindow_copy_update_cursor(wp, px, data->cy);\n\tif (window_copy_update_selection(wp, 1))\n\t\twindow_copy_redraw_lines(wp, data->cy, 1);\n}\n\nvoid\nwindow_copy_scroll_up(struct window_pane *wp, u_int ny)\n{\n\tstruct window_copy_mode_data\t*data = wp->modedata;\n\tstruct screen\t\t\t*s = &data->screen;\n\tstruct screen_write_ctx\t\t ctx;\n\n\tif (data->oy < ny)\n\t\tny = data->oy;\n\tif (ny == 0)\n\t\treturn;\n\tdata->oy -= ny;\n\n\twindow_copy_update_selection(wp, 0);\n\n\tscreen_write_start(&ctx, wp, NULL);\n\tscreen_write_cursormove(&ctx, 0, 0);\n\tscreen_write_deleteline(&ctx, ny);\n\twindow_copy_write_lines(wp, &ctx, screen_size_y(s) - ny, ny);\n\twindow_copy_write_line(wp, &ctx, 0);\n\tif (screen_size_y(s) > 1)\n\t\twindow_copy_write_line(wp, &ctx, 1);\n\tif (screen_size_y(s) > 3)\n\t\twindow_copy_write_line(wp, &ctx, screen_size_y(s) - 2);\n\tif (s->sel.flag && screen_size_y(s) > ny)\n\t\twindow_copy_write_line(wp, &ctx, screen_size_y(s) - ny - 1);\n\tscreen_write_cursormove(&ctx, data->cx, data->cy);\n\tscreen_write_stop(&ctx);\n}\n\nvoid\nwindow_copy_scroll_down(struct window_pane *wp, u_int ny)\n{\n\tstruct window_copy_mode_data\t*data = wp->modedata;\n\tstruct screen\t\t\t*s = &data->screen;\n\tstruct screen_write_ctx\t\t ctx;\n\n\tif (ny > screen_hsize(data->backing))\n\t\treturn;\n\n\tif (data->oy > screen_hsize(data->backing) - ny)\n\t\tny = screen_hsize(data->backing) - data->oy;\n\tif (ny == 0)\n\t\treturn;\n\tdata->oy += ny;\n\n\twindow_copy_update_selection(wp, 0);\n\n\tscreen_write_start(&ctx, wp, NULL);\n\tscreen_write_cursormove(&ctx, 0, 0);\n\tscreen_write_insertline(&ctx, ny);\n\twindow_copy_write_lines(wp, &ctx, 0, ny);\n\tif (s->sel.flag && screen_size_y(s) > ny)\n\t\twindow_copy_write_line(wp, &ctx, ny);\n\telse if (ny == 1) /* nuke position */\n\t\twindow_copy_write_line(wp, &ctx, 1);\n\tscreen_write_cursormove(&ctx, data->cx, data->cy);\n\tscreen_write_stop(&ctx);\n}\n\nint\nwindow_copy_scroll_position(struct window_pane *wp)\n{\n\tstruct window_copy_mode_data\t*data = wp->modedata;\n\n\tif (wp->mode != &window_copy_mode)\n\t\treturn (-1);\n\treturn (data->oy);\n}\n\nvoid\nwindow_copy_rectangle_toggle(struct window_pane *wp)\n{\n\tstruct window_copy_mode_data\t*data = wp->modedata;\n\tu_int\t\t\t\t px, py;\n\n\tdata->rectflag = !data->rectflag;\n\n\tpy = screen_hsize(data->backing) + data->cy - data->oy;\n\tpx = window_copy_find_length(wp, py);\n\tif (data->cx > px)\n\t\twindow_copy_update_cursor(wp, px, data->cy);\n\n\twindow_copy_update_selection(wp, 1);\n\twindow_copy_redraw_screen(wp);\n}\n\nvoid\nwindow_copy_start_drag(struct client *c, struct mouse_event *m)\n{\n\tstruct window_pane\t*wp;\n\tu_int\t\t\t x, y;\n\n\twp = cmd_mouse_pane(m, NULL, NULL);\n\tif (wp == NULL || wp->mode != &window_copy_mode)\n\t\treturn;\n\n\tif (cmd_mouse_at(wp, m, &x, &y, 1) != 0)\n\t\treturn;\n\n\tc->tty.mouse_drag_update = window_copy_drag_update;\n\tc->tty.mouse_drag_release = NULL; /* will fire MouseUp key */\n\n\twindow_copy_update_cursor(wp, x, y);\n\twindow_copy_start_selection(wp);\n\twindow_copy_redraw_screen(wp);\n}\n\nvoid\nwindow_copy_drag_update(__unused struct client *c, struct mouse_event *m)\n{\n\tstruct window_pane\t\t*wp;\n\tstruct window_copy_mode_data\t*data;\n\tu_int\t\t\t\t x, y, old_cy;\n\n\twp = cmd_mouse_pane(m, NULL, NULL);\n\tif (wp == NULL || wp->mode != &window_copy_mode)\n\t\treturn;\n\tdata = wp->modedata;\n\n\tif (cmd_mouse_at(wp, m, &x, &y, 0) != 0)\n\t\treturn;\n\told_cy = data->cy;\n\n\twindow_copy_update_cursor(wp, x, y);\n\tif (window_copy_update_selection(wp, 1))\n\t\twindow_copy_redraw_selection(wp, old_cy);\n}\n"
        },
        {
          "name": "window-copy.h",
          "type": "blob",
          "size": 2.193359375,
          "content": "#ifndef WINDOW_COPY_H\n#define WINDOW_COPY_H\n\n#include \"tmux.h\"\n\nenum window_copy_input_type {\n\tWINDOW_COPY_OFF,\n\tWINDOW_COPY_NAMEDBUFFER,\n\tWINDOW_COPY_NUMERICPREFIX,\n\tWINDOW_COPY_SEARCHUP,\n\tWINDOW_COPY_SEARCHDOWN,\n\tWINDOW_COPY_JUMPFORWARD,\n\tWINDOW_COPY_JUMPBACK,\n\tWINDOW_COPY_JUMPTOFORWARD,\n\tWINDOW_COPY_JUMPTOBACK,\n\tWINDOW_COPY_GOTOLINE,\n#ifdef TMATE\n\tWINDOW_COPY_PASSWORD,\n#endif\n};\n\n/*\n * Copy-mode's visible screen (the \"screen\" field) is filled from one of\n * two sources: the original contents of the pane (used when we\n * actually enter via the \"copy-mode\" command, to copy the contents of\n * the current pane), or else a series of lines containing the output\n * from an output-writing tmux command (such as any of the \"show-*\" or\n * \"list-*\" commands).\n *\n * In either case, the full content of the copy-mode grid is pointed at\n * by the \"backing\" field, and is copied into \"screen\" as needed (that\n * is, when scrolling occurs). When copy-mode is backed by a pane,\n * backing points directly at that pane's screen structure (&wp->base);\n * when backed by a list of output-lines from a command, it points at\n * a newly-allocated screen structure (which is deallocated when the\n * mode ends).\n */\n\n#ifdef TMATE\ntypedef void (*copy_password_callback)(const char *password, void *private);\n#endif\n\nstruct window_copy_mode_data {\n\tstruct screen\t\t screen;\n\n\tstruct screen\t\t*backing;\n\tint\t\t\t backing_written; /* backing display started */\n\n\tstruct mode_key_data\t mdata;\n\n\tu_int\t\t\t oy;\n\n\tu_int\t\t\t selx;\n\tu_int\t\t\t sely;\n\n\tint\t\t\t rectflag;\t/* in rectangle copy mode? */\n\tint\t\t\t scroll_exit;\t/* exit on scroll to end? */\n\n\tu_int\t\t\t cx;\n\tu_int\t\t\t cy;\n\n\tu_int\t\t\t lastcx; /* position in last line w/ content */\n\tu_int\t\t\t lastsx; /* size of last line w/ content */\n\n\tenum window_copy_input_type inputtype;\n\tconst char\t\t*inputprompt;\n\tchar\t\t\t*inputstr;\n\tint\t\t\t inputexit;\n\n\tint\t\t\t numprefix;\n\n\tenum window_copy_input_type searchtype;\n\tchar\t\t\t*searchstr;\n\n\tenum window_copy_input_type jumptype;\n\tchar\t\t\t jumpchar;\n\n#ifdef TMATE\n\tcopy_password_callback\tpassword_cb;\n\tvoid        \t    \t*password_cb_private;\n#endif\n};\n\nextern int window_copy_update_selection(struct window_pane *, int);\nextern void window_copy_redraw_screen(struct window_pane *);\n\n#endif\n"
        },
        {
          "name": "window.c",
          "type": "blob",
          "size": 30.2607421875,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <errno.h>\n#include <fcntl.h>\n#include <fnmatch.h>\n#include <signal.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <termios.h>\n#include <unistd.h>\n\n#include \"tmux.h\"\n#include \"tmate.h\"\n\n/*\n * Each window is attached to a number of panes, each of which is a pty. This\n * file contains code to handle them.\n *\n * A pane has two buffers attached, these are filled and emptied by the main\n * server poll loop. Output data is received from pty's in screen format,\n * translated and returned as a series of escape sequences and strings via\n * input_parse (in input.c). Input data is received as key codes and written\n * directly via input_key.\n *\n * Each pane also has a \"virtual\" screen (screen.c) which contains the current\n * state and is redisplayed when the window is reattached to a client.\n *\n * Windows are stored directly on a global array and wrapped in any number of\n * winlink structs to be linked onto local session RB trees. A reference count\n * is maintained and a window removed from the global list and destroyed when\n * it reaches zero.\n */\n\n/* Global window list. */\nstruct windows windows;\n\n/* Global panes tree. */\nstruct window_pane_tree all_window_panes;\nu_int\tnext_window_pane_id;\nu_int\tnext_window_id;\nu_int\tnext_active_point;\n\nvoid\twindow_pane_timer_callback(int, short, void *);\nvoid\twindow_pane_read_callback(struct bufferevent *, void *);\nvoid\twindow_pane_error_callback(struct bufferevent *, short, void *);\n\nstruct window_pane *window_pane_choose_best(struct window_pane **, u_int);\n\nRB_GENERATE(windows, window, entry, window_cmp);\n\nint\nwindow_cmp(struct window *w1, struct window *w2)\n{\n\treturn (w1->id - w2->id);\n}\n\nRB_GENERATE(winlinks, winlink, entry, winlink_cmp);\n\nint\nwinlink_cmp(struct winlink *wl1, struct winlink *wl2)\n{\n\treturn (wl1->idx - wl2->idx);\n}\n\nRB_GENERATE(window_pane_tree, window_pane, tree_entry, window_pane_cmp);\n\nint\nwindow_pane_cmp(struct window_pane *wp1, struct window_pane *wp2)\n{\n\treturn (wp1->id - wp2->id);\n}\n\nstruct winlink *\nwinlink_find_by_window(struct winlinks *wwl, struct window *w)\n{\n\tstruct winlink\t*wl;\n\n\tRB_FOREACH(wl, winlinks, wwl) {\n\t\tif (wl->window == w)\n\t\t\treturn (wl);\n\t}\n\n\treturn (NULL);\n}\n\nstruct winlink *\nwinlink_find_by_index(struct winlinks *wwl, int idx)\n{\n\tstruct winlink\twl;\n\n\tif (idx < 0)\n\t\tfatalx(\"bad index\");\n\n\twl.idx = idx;\n\treturn (RB_FIND(winlinks, wwl, &wl));\n}\n\nstruct winlink *\nwinlink_find_by_window_id(struct winlinks *wwl, u_int id)\n{\n\tstruct winlink *wl;\n\n\tRB_FOREACH(wl, winlinks, wwl) {\n\t\tif (wl->window->id == id)\n\t\t\treturn (wl);\n\t}\n\treturn (NULL);\n}\n\nint\nwinlink_next_index(struct winlinks *wwl, int idx)\n{\n\tint\ti;\n\n\ti = idx;\n\tdo {\n\t\tif (winlink_find_by_index(wwl, i) == NULL)\n\t\t\treturn (i);\n\t\tif (i == INT_MAX)\n\t\t\ti = 0;\n\t\telse\n\t\t\ti++;\n\t} while (i != idx);\n\treturn (-1);\n}\n\nu_int\nwinlink_count(struct winlinks *wwl)\n{\n\tstruct winlink\t*wl;\n\tu_int\t\t n;\n\n\tn = 0;\n\tRB_FOREACH(wl, winlinks, wwl)\n\t\tn++;\n\n\treturn (n);\n}\n\nstruct winlink *\nwinlink_add(struct winlinks *wwl, int idx)\n{\n\tstruct winlink\t*wl;\n\n\tif (idx < 0) {\n\t\tif ((idx = winlink_next_index(wwl, -idx - 1)) == -1)\n\t\t\treturn (NULL);\n\t} else if (winlink_find_by_index(wwl, idx) != NULL)\n\t\treturn (NULL);\n\n\twl = xcalloc(1, sizeof *wl);\n\twl->idx = idx;\n\tRB_INSERT(winlinks, wwl, wl);\n\n\treturn (wl);\n}\n\nvoid\nwinlink_set_window(struct winlink *wl, struct window *w)\n{\n\twl->window = w;\n\tw->references++;\n}\n\nvoid\nwinlink_remove(struct winlinks *wwl, struct winlink *wl)\n{\n\tstruct window\t*w = wl->window;\n\n\tRB_REMOVE(winlinks, wwl, wl);\n\tfree(wl->status_text);\n\tfree(wl);\n\n\tif (w != NULL)\n\t\twindow_remove_ref(w);\n}\n\nstruct winlink *\nwinlink_next(struct winlink *wl)\n{\n\treturn (RB_NEXT(winlinks, wwl, wl));\n}\n\nstruct winlink *\nwinlink_previous(struct winlink *wl)\n{\n\treturn (RB_PREV(winlinks, wwl, wl));\n}\n\nstruct winlink *\nwinlink_next_by_number(struct winlink *wl, struct session *s, int n)\n{\n\tfor (; n > 0; n--) {\n\t\tif ((wl = RB_NEXT(winlinks, wwl, wl)) == NULL)\n\t\t\twl = RB_MIN(winlinks, &s->windows);\n\t}\n\n\treturn (wl);\n}\n\nstruct winlink *\nwinlink_previous_by_number(struct winlink *wl, struct session *s, int n)\n{\n\tfor (; n > 0; n--) {\n\t\tif ((wl = RB_PREV(winlinks, wwl, wl)) == NULL)\n\t\t\twl = RB_MAX(winlinks, &s->windows);\n\t}\n\n\treturn (wl);\n}\n\nvoid\nwinlink_stack_push(struct winlink_stack *stack, struct winlink *wl)\n{\n\tif (wl == NULL)\n\t\treturn;\n\n\twinlink_stack_remove(stack, wl);\n\tTAILQ_INSERT_HEAD(stack, wl, sentry);\n}\n\nvoid\nwinlink_stack_remove(struct winlink_stack *stack, struct winlink *wl)\n{\n\tstruct winlink\t*wl2;\n\n\tif (wl == NULL)\n\t\treturn;\n\n\tTAILQ_FOREACH(wl2, stack, sentry) {\n\t\tif (wl2 == wl) {\n\t\t\tTAILQ_REMOVE(stack, wl, sentry);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstruct window *\nwindow_find_by_id_str(const char *s)\n{\n\tconst char\t*errstr;\n\tu_int\t\t id;\n\n\tif (*s != '@')\n\t\treturn (NULL);\n\n\tid = strtonum(s + 1, 0, UINT_MAX, &errstr);\n\tif (errstr != NULL)\n\t\treturn (NULL);\n\treturn (window_find_by_id(id));\n}\n\nstruct window *\nwindow_find_by_id(u_int id)\n{\n\tstruct window\tw;\n\n\tw.id = id;\n\treturn (RB_FIND(windows, &windows, &w));\n}\n\nvoid\nwindow_update_activity(struct window *w)\n{\n\tgettimeofday(&w->activity_time, NULL);\n\talerts_queue(w, WINDOW_ACTIVITY);\n}\n\nstruct window *\nwindow_create1(u_int sx, u_int sy)\n{\n\tstruct window\t*w;\n\n\tw = xcalloc(1, sizeof *w);\n\tw->name = NULL;\n\tw->flags = 0;\n\n\tTAILQ_INIT(&w->panes);\n\tw->active = NULL;\n\n#ifdef TMATE\n\tw->tmate_last_sync_active_pane = NULL;\n#endif\n\n\tw->lastlayout = -1;\n\tw->layout_root = NULL;\n\n\tw->sx = sx;\n\tw->sy = sy;\n\n\tw->options = options_create(global_w_options);\n\n\tw->references = 0;\n\n\tw->id = next_window_id++;\n\tRB_INSERT(windows, &windows, w);\n\n\twindow_update_activity(w);\n\n\treturn (w);\n}\n\nstruct window *\nwindow_create(const char *name, int argc, char **argv, const char *path,\n    const char *shell, const char *cwd, struct environ *env,\n    struct termios *tio, u_int sx, u_int sy, u_int hlimit, char **cause)\n{\n\tstruct window\t\t*w;\n\tstruct window_pane\t*wp;\n\n\tw = window_create1(sx, sy);\n\twp = window_add_pane(w, hlimit);\n\tlayout_init(w, wp);\n\n\tif (window_pane_spawn(wp, argc, argv, path, shell, cwd, env, tio,\n\t    cause) != 0) {\n\t\twindow_destroy(w);\n\t\treturn (NULL);\n\t}\n\n\tw->active = TAILQ_FIRST(&w->panes);\n\tif (name != NULL) {\n\t\tw->name = xstrdup(name);\n\t\toptions_set_number(w->options, \"automatic-rename\", 0);\n\t} else\n\t\tw->name = default_window_name(w);\n\n\treturn (w);\n}\n\nvoid\nwindow_destroy(struct window *w)\n{\n\tRB_REMOVE(windows, &windows, w);\n\n\tif (w->layout_root != NULL)\n\t\tlayout_free_cell(w->layout_root);\n\tif (w->saved_layout_root != NULL)\n\t\tlayout_free_cell(w->saved_layout_root);\n\tfree(w->old_layout);\n\n\tif (event_initialized(&w->name_event))\n\t\tevtimer_del(&w->name_event);\n\n\tif (event_initialized(&w->alerts_timer))\n\t\tevtimer_del(&w->alerts_timer);\n\n\toptions_free(w->options);\n\n\twindow_destroy_panes(w);\n\n\tfree(w->name);\n\tfree(w);\n}\n\nvoid\nwindow_remove_ref(struct window *w)\n{\n\tif (w->references == 0)\n\t\tfatal(\"bad reference count\");\n\tw->references--;\n\tif (w->references == 0)\n\t\twindow_destroy(w);\n}\n\nvoid\nwindow_set_name(struct window *w, const char *new_name)\n{\n#ifdef TMATE\n\t/*\n\t * We don't want to sync the layout too much.\n\t * We might want to have some sort of timer for when to\n\t * sync the layout.\n\t */\n\tif (!strcmp(w->name, new_name))\n\t\treturn;\n#endif\n\n\tfree(w->name);\n\tw->name = xstrdup(new_name);\n\tnotify_window_renamed(w);\n#ifdef TMATE\n\ttmate_sync_layout();\n#endif\n}\n\nvoid\nwindow_resize(struct window *w, u_int sx, u_int sy)\n{\n\tw->sx = sx;\n\tw->sy = sy;\n}\n\nint\nwindow_has_pane(struct window *w, struct window_pane *wp)\n{\n\tstruct window_pane\t*wp1;\n\n\tTAILQ_FOREACH(wp1, &w->panes, entry) {\n\t\tif (wp1 == wp)\n\t\t\treturn (1);\n\t}\n\treturn (0);\n}\n\nint\nwindow_set_active_pane(struct window *w, struct window_pane *wp)\n{\n\tif (wp == w->active)\n\t\treturn (0);\n\tw->last = w->active;\n\tw->active = wp;\n\twhile (!window_pane_visible(w->active)) {\n\t\tw->active = TAILQ_PREV(w->active, window_panes, entry);\n\t\tif (w->active == NULL)\n\t\t\tw->active = TAILQ_LAST(&w->panes, window_panes);\n\t\tif (w->active == wp)\n\t\t\treturn (1);\n\t}\n\tw->active->active_point = next_active_point++;\n\tw->active->flags |= PANE_CHANGED;\n\treturn (1);\n}\n\nvoid\nwindow_redraw_active_switch(struct window *w, struct window_pane *wp)\n{\n\tconst struct grid_cell\t*agc, *wgc;\n\n\tif (wp == w->active)\n\t\treturn;\n\n\t/*\n\t * If window-style and window-active-style are the same, we don't need\n\t * to redraw panes when switching active panes. Otherwise, if the\n\t * active or inactive pane do not have a custom style, they will need\n\t * to be redrawn.\n\t */\n\tagc = options_get_style(w->options, \"window-active-style\");\n\twgc = options_get_style(w->options, \"window-style\");\n\tif (style_equal(agc, wgc))\n\t\treturn;\n\tif (style_equal(&grid_default_cell, &w->active->colgc))\n\t\tw->active->flags |= PANE_REDRAW;\n\tif (style_equal(&grid_default_cell, &wp->colgc))\n\t\twp->flags |= PANE_REDRAW;\n}\n\nstruct window_pane *\nwindow_get_active_at(struct window *w, u_int x, u_int y)\n{\n\tstruct window_pane\t*wp;\n\n\tTAILQ_FOREACH(wp, &w->panes, entry) {\n\t\tif (!window_pane_visible(wp))\n\t\t\tcontinue;\n\t\tif (x < wp->xoff || x > wp->xoff + wp->sx)\n\t\t\tcontinue;\n\t\tif (y < wp->yoff || y > wp->yoff + wp->sy)\n\t\t\tcontinue;\n\t\treturn (wp);\n\t}\n\treturn (NULL);\n}\n\nstruct window_pane *\nwindow_find_string(struct window *w, const char *s)\n{\n\tu_int\tx, y;\n\n\tx = w->sx / 2;\n\ty = w->sy / 2;\n\n\tif (strcasecmp(s, \"top\") == 0)\n\t\ty = 0;\n\telse if (strcasecmp(s, \"bottom\") == 0)\n\t\ty = w->sy - 1;\n\telse if (strcasecmp(s, \"left\") == 0)\n\t\tx = 0;\n\telse if (strcasecmp(s, \"right\") == 0)\n\t\tx = w->sx - 1;\n\telse if (strcasecmp(s, \"top-left\") == 0) {\n\t\tx = 0;\n\t\ty = 0;\n\t} else if (strcasecmp(s, \"top-right\") == 0) {\n\t\tx = w->sx - 1;\n\t\ty = 0;\n\t} else if (strcasecmp(s, \"bottom-left\") == 0) {\n\t\tx = 0;\n\t\ty = w->sy - 1;\n\t} else if (strcasecmp(s, \"bottom-right\") == 0) {\n\t\tx = w->sx - 1;\n\t\ty = w->sy - 1;\n\t} else\n\t\treturn (NULL);\n\n\treturn (window_get_active_at(w, x, y));\n}\n\nint\nwindow_zoom(struct window_pane *wp)\n{\n\tstruct window\t\t*w = wp->window;\n\tstruct window_pane\t*wp1;\n\n\tif (w->flags & WINDOW_ZOOMED)\n\t\treturn (-1);\n\n\tif (!window_pane_visible(wp))\n\t\treturn (-1);\n\n\tif (window_count_panes(w) == 1)\n\t\treturn (-1);\n\n\tif (w->active != wp)\n\t\twindow_set_active_pane(w, wp);\n\n\tTAILQ_FOREACH(wp1, &w->panes, entry) {\n\t\twp1->saved_layout_cell = wp1->layout_cell;\n\t\twp1->layout_cell = NULL;\n\t}\n\n\tw->saved_layout_root = w->layout_root;\n\tlayout_init(w, wp);\n\tw->flags |= WINDOW_ZOOMED;\n\tnotify_window_layout_changed(w);\n\n\treturn (0);\n}\n\nint\nwindow_unzoom(struct window *w)\n{\n\tstruct window_pane\t*wp;\n\n\tif (!(w->flags & WINDOW_ZOOMED))\n\t\treturn (-1);\n\n\tw->flags &= ~WINDOW_ZOOMED;\n\tlayout_free(w);\n\tw->layout_root = w->saved_layout_root;\n\tw->saved_layout_root = NULL;\n\n\tTAILQ_FOREACH(wp, &w->panes, entry) {\n\t\twp->layout_cell = wp->saved_layout_cell;\n\t\twp->saved_layout_cell = NULL;\n\t}\n\tlayout_fix_panes(w, w->sx, w->sy);\n\tnotify_window_layout_changed(w);\n\n\treturn (0);\n}\n\nstruct window_pane *\nwindow_add_pane(struct window *w, u_int hlimit)\n{\n\tstruct window_pane\t*wp;\n\n\twp = window_pane_create(w, w->sx, w->sy, hlimit);\n\tif (TAILQ_EMPTY(&w->panes))\n\t\tTAILQ_INSERT_HEAD(&w->panes, wp, entry);\n\telse\n\t\tTAILQ_INSERT_AFTER(&w->panes, w->active, wp, entry);\n\treturn (wp);\n}\n\nvoid\nwindow_lost_pane(struct window *w, struct window_pane *wp)\n{\n\tif (wp == marked_pane.wp)\n\t\tserver_clear_marked();\n\n\tif (wp == w->active) {\n\t\tw->active = w->last;\n\t\tw->last = NULL;\n\t\tif (w->active == NULL) {\n\t\t\tw->active = TAILQ_PREV(wp, window_panes, entry);\n\t\t\tif (w->active == NULL)\n\t\t\t\tw->active = TAILQ_NEXT(wp, entry);\n\t\t}\n\t\tif (w->active != NULL)\n\t\t\tw->active->flags |= PANE_CHANGED;\n\t} else if (wp == w->last)\n\t\tw->last = NULL;\n}\n\nvoid\nwindow_remove_pane(struct window *w, struct window_pane *wp)\n{\n\twindow_lost_pane(w, wp);\n\n\tTAILQ_REMOVE(&w->panes, wp, entry);\n\twindow_pane_destroy(wp);\n}\n\nstruct window_pane *\nwindow_pane_at_index(struct window *w, u_int idx)\n{\n\tstruct window_pane\t*wp;\n\tu_int\t\t\t n;\n\n\tn = options_get_number(w->options, \"pane-base-index\");\n\tTAILQ_FOREACH(wp, &w->panes, entry) {\n\t\tif (n == idx)\n\t\t\treturn (wp);\n\t\tn++;\n\t}\n\treturn (NULL);\n}\n\nstruct window_pane *\nwindow_pane_next_by_number(struct window *w, struct window_pane *wp, u_int n)\n{\n\tfor (; n > 0; n--) {\n\t\tif ((wp = TAILQ_NEXT(wp, entry)) == NULL)\n\t\t\twp = TAILQ_FIRST(&w->panes);\n\t}\n\n\treturn (wp);\n}\n\nstruct window_pane *\nwindow_pane_previous_by_number(struct window *w, struct window_pane *wp,\n    u_int n)\n{\n\tfor (; n > 0; n--) {\n\t\tif ((wp = TAILQ_PREV(wp, window_panes, entry)) == NULL)\n\t\t\twp = TAILQ_LAST(&w->panes, window_panes);\n\t}\n\n\treturn (wp);\n}\n\nint\nwindow_pane_index(struct window_pane *wp, u_int *i)\n{\n\tstruct window_pane\t*wq;\n\tstruct window\t\t*w = wp->window;\n\n\t*i = options_get_number(w->options, \"pane-base-index\");\n\tTAILQ_FOREACH(wq, &w->panes, entry) {\n\t\tif (wp == wq) {\n\t\t\treturn (0);\n\t\t}\n\t\t(*i)++;\n\t}\n\n\treturn (-1);\n}\n\nu_int\nwindow_count_panes(struct window *w)\n{\n\tstruct window_pane\t*wp;\n\tu_int\t\t\t n;\n\n\tn = 0;\n\tTAILQ_FOREACH(wp, &w->panes, entry)\n\t\tn++;\n\treturn (n);\n}\n\nvoid\nwindow_destroy_panes(struct window *w)\n{\n\tstruct window_pane\t*wp;\n\n\twhile (!TAILQ_EMPTY(&w->panes)) {\n\t\twp = TAILQ_FIRST(&w->panes);\n\t\tTAILQ_REMOVE(&w->panes, wp, entry);\n\t\twindow_pane_destroy(wp);\n\t}\n}\n\n/* Retuns the printable flags on a window, empty string if no flags set. */\nchar *\nwindow_printable_flags(struct session *s, struct winlink *wl)\n{\n\tchar\tflags[32];\n\tint\tpos;\n\n\tpos = 0;\n\tif (wl->flags & WINLINK_ACTIVITY)\n\t\tflags[pos++] = '#';\n\tif (wl->flags & WINLINK_BELL)\n\t\tflags[pos++] = '!';\n\tif (wl->flags & WINLINK_SILENCE)\n\t\tflags[pos++] = '~';\n\tif (wl == s->curw)\n\t\tflags[pos++] = '*';\n\tif (wl == TAILQ_FIRST(&s->lastw))\n\t\tflags[pos++] = '-';\n\tif (server_check_marked() && wl == marked_pane.wl)\n\t\tflags[pos++] = 'M';\n\tif (wl->window->flags & WINDOW_ZOOMED)\n\t\tflags[pos++] = 'Z';\n\tflags[pos] = '\\0';\n\treturn (xstrdup(flags));\n}\n\nstruct window_pane *\nwindow_pane_find_by_id_str(const char *s)\n{\n\tconst char\t*errstr;\n\tu_int\t\t id;\n\n\tif (*s != '%')\n\t\treturn (NULL);\n\n\tid = strtonum(s + 1, 0, UINT_MAX, &errstr);\n\tif (errstr != NULL)\n\t\treturn (NULL);\n\treturn (window_pane_find_by_id(id));\n}\n\nstruct window_pane *\nwindow_pane_find_by_id(u_int id)\n{\n\tstruct window_pane\twp;\n\n\twp.id = id;\n\treturn (RB_FIND(window_pane_tree, &all_window_panes, &wp));\n}\n\nstruct window_pane *\nwindow_pane_create(struct window *w, u_int sx, u_int sy, u_int hlimit)\n{\n\tstruct window_pane\t*wp;\n\tchar\t\t\t host[HOST_NAME_MAX + 1];\n\n\twp = xcalloc(1, sizeof *wp);\n\twp->window = w;\n\n\twp->id = next_window_pane_id++;\n\tRB_INSERT(window_pane_tree, &all_window_panes, wp);\n\n\twp->argc = 0;\n\twp->argv = NULL;\n\twp->shell = NULL;\n\twp->cwd = NULL;\n\n\twp->fd = -1;\n\twp->event = NULL;\n\n\twp->mode = NULL;\n\n\twp->layout_cell = NULL;\n\n\twp->xoff = 0;\n\twp->yoff = 0;\n\n\twp->sx = sx;\n\twp->sy = sy;\n\n\twp->pipe_fd = -1;\n\twp->pipe_off = 0;\n\twp->pipe_event = NULL;\n\n#ifdef TMATE\n\twp->tmate_off = 0;\n#endif\n\n\twp->saved_grid = NULL;\n\n\tmemcpy(&wp->colgc, &grid_default_cell, sizeof wp->colgc);\n\n\tscreen_init(&wp->base, sx, sy, hlimit);\n\twp->screen = &wp->base;\n\n\tif (gethostname(host, sizeof host) == 0)\n\t\tscreen_set_title(&wp->base, host);\n\n\tinput_init(wp);\n\n\treturn (wp);\n}\n\nvoid\nwindow_pane_destroy(struct window_pane *wp)\n{\n\twindow_pane_reset_mode(wp);\n\n\tif (event_initialized(&wp->timer))\n\t\tevtimer_del(&wp->timer);\n\n\tif (wp->fd != -1) {\n#ifdef HAVE_UTEMPTER\n\t\tutempter_remove_record(wp->fd);\n#endif\n\t\tbufferevent_free(wp->event);\n\t\tclose(wp->fd);\n\t}\n\n\tinput_free(wp);\n\n\tscreen_free(&wp->base);\n\tif (wp->saved_grid != NULL)\n\t\tgrid_destroy(wp->saved_grid);\n\n\tif (wp->pipe_fd != -1) {\n\t\tbufferevent_free(wp->pipe_event);\n\t\tclose(wp->pipe_fd);\n\t}\n\n\tRB_REMOVE(window_pane_tree, &all_window_panes, wp);\n\n\tfree((void *)wp->cwd);\n\tfree(wp->shell);\n\tcmd_free_argv(wp->argc, wp->argv);\n\tfree(wp);\n}\n\nint\nwindow_pane_spawn(struct window_pane *wp, int argc, char **argv,\n    const char *path, const char *shell, const char *cwd, struct environ *env,\n    struct termios *tio, char **cause)\n{\n\tstruct winsize\t ws;\n\tchar\t\t*argv0, *cmd, **argvp;\n\tconst char\t*ptr, *first, *home;\n\tstruct termios\t tio2;\n#ifdef HAVE_UTEMPTER\n\tchar\t\t s[32];\n#endif\n\tint\t\t i;\n\n\tif (wp->fd != -1) {\n\t\tbufferevent_free(wp->event);\n\t\tclose(wp->fd);\n\t}\n\tif (argc > 0) {\n\t\tcmd_free_argv(wp->argc, wp->argv);\n\t\twp->argc = argc;\n\t\twp->argv = cmd_copy_argv(argc, argv);\n\t}\n\tif (shell != NULL) {\n\t\tfree(wp->shell);\n\t\twp->shell = xstrdup(shell);\n\t}\n\tif (cwd != NULL) {\n\t\tfree((void *)wp->cwd);\n\t\twp->cwd = xstrdup(cwd);\n\t}\n\n\tcmd = cmd_stringify_argv(wp->argc, wp->argv);\n\tlog_debug(\"spawn: %s -- %s\", wp->shell, cmd);\n\tfor (i = 0; i < wp->argc; i++)\n\t\tlog_debug(\"spawn: argv[%d] = %s\", i, wp->argv[i]);\n\n\tmemset(&ws, 0, sizeof ws);\n\tws.ws_col = screen_size_x(&wp->base);\n\tws.ws_row = screen_size_y(&wp->base);\n\n\tswitch (wp->pid = forkpty(&wp->fd, wp->tty, NULL, &ws)) {\n\tcase -1:\n\t\twp->fd = -1;\n\t\txasprintf(cause, \"%s: %s\", cmd, strerror(errno));\n\t\tfree(cmd);\n\t\treturn (-1);\n\tcase 0:\n\t\tif (chdir(wp->cwd) != 0) {\n\t\t\tif ((home = find_home()) == NULL || chdir(home) != 0)\n\t\t\t\tchdir(\"/\");\n\t\t}\n\n\t\tif (tcgetattr(STDIN_FILENO, &tio2) != 0)\n\t\t\tfatal(\"tcgetattr failed\");\n\t\tif (tio != NULL)\n\t\t\tmemcpy(tio2.c_cc, tio->c_cc, sizeof tio2.c_cc);\n\t\ttio2.c_cc[VERASE] = '\\177';\n#ifdef IUTF8\n\t\ttio2.c_iflag |= IUTF8;\n#endif\n\t\tif (tcsetattr(STDIN_FILENO, TCSANOW, &tio2) != 0)\n\t\t\tfatal(\"tcgetattr failed\");\n\n\t\tclosefrom(STDERR_FILENO + 1);\n\n\t\tif (path != NULL)\n\t\t\tenviron_set(env, \"PATH\", \"%s\", path);\n\t\tenviron_set(env, \"TMUX_PANE\", \"%%%u\", wp->id);\n\t\tenviron_push(env);\n\n\t\tclear_signals(1);\n\t\tlog_close();\n\n\t\tsetenv(\"SHELL\", wp->shell, 1);\n\t\tptr = strrchr(wp->shell, '/');\n\n\t\t/*\n\t\t * If given one argument, assume it should be passed to sh -c;\n\t\t * with more than one argument, use execvp(). If there is no\n\t\t * arguments, create a login shell.\n\t\t */\n\t\tif (wp->argc > 0) {\n\t\t\tif (wp->argc != 1) {\n\t\t\t\t/* Copy to ensure argv ends in NULL. */\n\t\t\t\targvp = cmd_copy_argv(wp->argc, wp->argv);\n\t\t\t\texecvp(argvp[0], argvp);\n\t\t\t\tfatal(\"execvp failed\");\n\t\t\t}\n\t\t\tfirst = wp->argv[0];\n\n\t\t\tif (ptr != NULL && *(ptr + 1) != '\\0')\n\t\t\t\txasprintf(&argv0, \"%s\", ptr + 1);\n\t\t\telse\n\t\t\t\txasprintf(&argv0, \"%s\", wp->shell);\n\t\t\texecl(wp->shell, argv0, \"-c\", first, (char *)NULL);\n\t\t\tfatal(\"execl failed\");\n\t\t}\n\t\tif (ptr != NULL && *(ptr + 1) != '\\0')\n\t\t\txasprintf(&argv0, \"-%s\", ptr + 1);\n\t\telse\n\t\t\txasprintf(&argv0, \"-%s\", wp->shell);\n\t\texecl(wp->shell, argv0, (char *)NULL);\n\t\tfatal(\"execl failed\");\n\t}\n\n#ifdef HAVE_UTEMPTER\n\txsnprintf(s, sizeof s, \"tmux(%lu).%%%u\", (long) getpid(), wp->id);\n\tutempter_add_record(wp->fd, s);\n\tkill(getpid(), SIGCHLD);\n#endif\n\n\tsetblocking(wp->fd, 0);\n\n\twp->event = bufferevent_new(wp->fd, window_pane_read_callback, NULL,\n\t    window_pane_error_callback, wp);\n\n\tbufferevent_setwatermark(wp->event, EV_READ, 0, READ_SIZE);\n\tbufferevent_enable(wp->event, EV_READ|EV_WRITE);\n\n\tfree(cmd);\n\treturn (0);\n}\n\nvoid\nwindow_pane_timer_callback(__unused int fd, __unused short events, void *data)\n{\n\twindow_pane_read_callback(NULL, data);\n}\n\nvoid\nwindow_pane_read_callback(__unused struct bufferevent *bufev, void *data)\n{\n\tstruct window_pane\t*wp = data;\n\tstruct evbuffer\t\t*evb = wp->event->input;\n\tchar\t\t\t*new_data;\n\tsize_t\t\t\t new_size, available;\n\tstruct client\t\t*c;\n\tstruct timeval\t\t tv;\n\n\tif (event_initialized(&wp->timer))\n\t\tevtimer_del(&wp->timer);\n\n\tlog_debug(\"%%%u has %zu bytes\", wp->id, EVBUFFER_LENGTH(evb));\n\n\tTAILQ_FOREACH(c, &clients, entry) {\n\t\tif (!tty_client_ready(c, wp))\n\t\t\tcontinue;\n\n\t\tavailable = EVBUFFER_LENGTH(c->tty.event->output);\n\t\tif (available > READ_BACKOFF)\n\t\t\tgoto start_timer;\n\t}\n\n\tnew_size = EVBUFFER_LENGTH(evb) - wp->pipe_off;\n\tif (wp->pipe_fd != -1 && new_size > 0) {\n\t\tnew_data = EVBUFFER_DATA(evb) + wp->pipe_off;\n\t\tbufferevent_write(wp->pipe_event, new_data, new_size);\n\t}\n\n#ifdef TMATE\n\tnew_size = EVBUFFER_LENGTH(wp->event->input) - wp->tmate_off;\n\tnew_data = EVBUFFER_DATA(wp->event->input) + wp->tmate_off;\n\tif (new_size > 0)\n\t\ttmate_pty_data(wp, new_data, new_size);\n#endif\n\n\tinput_parse(wp);\n\n\twp->pipe_off = EVBUFFER_LENGTH(evb);\n#ifdef TMATE\n\twp->tmate_off = EVBUFFER_LENGTH(evb);\n#endif\n\treturn;\n\nstart_timer:\n\tlog_debug(\"%%%u backing off (%s %zu > %d)\", wp->id, c->ttyname,\n\t    available, READ_BACKOFF);\n\n\ttv.tv_sec = 0;\n\ttv.tv_usec = READ_TIME;\n\n\tevtimer_set(&wp->timer, window_pane_timer_callback, wp);\n\tevtimer_add(&wp->timer, &tv);\n}\n\nvoid\nwindow_pane_error_callback(__unused struct bufferevent *bufev,\n    __unused short what, void *data)\n{\n\tstruct window_pane *wp = data;\n\n\tserver_destroy_pane(wp, 1);\n}\n\nvoid\nwindow_pane_resize(struct window_pane *wp, u_int sx, u_int sy)\n{\n\tif (sx == wp->sx && sy == wp->sy)\n\t\treturn;\n\twp->sx = sx;\n\twp->sy = sy;\n\n\tscreen_resize(&wp->base, sx, sy, wp->saved_grid == NULL);\n\tif (wp->mode != NULL)\n\t\twp->mode->resize(wp, sx, sy);\n\n\twp->flags |= PANE_RESIZE;\n}\n\n/*\n * Enter alternative screen mode. A copy of the visible screen is saved and the\n * history is not updated\n */\nvoid\nwindow_pane_alternate_on(struct window_pane *wp, struct grid_cell *gc,\n    int cursor)\n{\n\tstruct screen\t*s = &wp->base;\n\tu_int\t\t sx, sy;\n\n\tif (wp->saved_grid != NULL)\n\t\treturn;\n\tif (!options_get_number(wp->window->options, \"alternate-screen\"))\n\t\treturn;\n\tsx = screen_size_x(s);\n\tsy = screen_size_y(s);\n\n\twp->saved_grid = grid_create(sx, sy, 0);\n\tgrid_duplicate_lines(wp->saved_grid, 0, s->grid, screen_hsize(s), sy);\n\tif (cursor) {\n\t\twp->saved_cx = s->cx;\n\t\twp->saved_cy = s->cy;\n\t}\n\tmemcpy(&wp->saved_cell, gc, sizeof wp->saved_cell);\n\n\tgrid_view_clear(s->grid, 0, 0, sx, sy);\n\n\twp->base.grid->flags &= ~GRID_HISTORY;\n\n\twp->flags |= PANE_REDRAW;\n}\n\n/* Exit alternate screen mode and restore the copied grid. */\nvoid\nwindow_pane_alternate_off(struct window_pane *wp, struct grid_cell *gc,\n    int cursor)\n{\n\tstruct screen\t*s = &wp->base;\n\tu_int\t\t sx, sy;\n\n\tif (wp->saved_grid == NULL)\n\t\treturn;\n\tif (!options_get_number(wp->window->options, \"alternate-screen\"))\n\t\treturn;\n\tsx = screen_size_x(s);\n\tsy = screen_size_y(s);\n\n\t/*\n\t * If the current size is bigger, temporarily resize to the old size\n\t * before copying back.\n\t */\n\tif (sy > wp->saved_grid->sy)\n\t\tscreen_resize(s, sx, wp->saved_grid->sy, 1);\n\n\t/* Restore the grid, cursor position and cell. */\n\tgrid_duplicate_lines(s->grid, screen_hsize(s), wp->saved_grid, 0, sy);\n\tif (cursor)\n\t\ts->cx = wp->saved_cx;\n\tif (s->cx > screen_size_x(s) - 1)\n\t\ts->cx = screen_size_x(s) - 1;\n\tif (cursor)\n\t\ts->cy = wp->saved_cy;\n\tif (s->cy > screen_size_y(s) - 1)\n\t\ts->cy = screen_size_y(s) - 1;\n\tmemcpy(gc, &wp->saved_cell, sizeof *gc);\n\n\t/*\n\t * Turn history back on (so resize can use it) and then resize back to\n\t * the current size.\n\t */\n\twp->base.grid->flags |= GRID_HISTORY;\n\tif (sy > wp->saved_grid->sy || sx != wp->saved_grid->sx)\n\t\tscreen_resize(s, sx, sy, 1);\n\n\tgrid_destroy(wp->saved_grid);\n\twp->saved_grid = NULL;\n\n\twp->flags |= PANE_REDRAW;\n}\n\nint\nwindow_pane_set_mode(struct window_pane *wp, const struct window_mode *mode)\n{\n\tstruct screen\t*s;\n\n\tif (wp->mode != NULL)\n\t\treturn (1);\n\twp->mode = mode;\n\n\tif ((s = wp->mode->init(wp)) != NULL)\n\t\twp->screen = s;\n\twp->flags |= (PANE_REDRAW|PANE_CHANGED);\n\n\tserver_status_window(wp->window);\n\treturn (0);\n}\n\nvoid\nwindow_pane_reset_mode(struct window_pane *wp)\n{\n\tif (wp->mode == NULL)\n\t\treturn;\n\n\twp->mode->free(wp);\n\twp->mode = NULL;\n\n\twp->screen = &wp->base;\n\twp->flags |= (PANE_REDRAW|PANE_CHANGED);\n\n\tserver_status_window(wp->window);\n\n#ifdef TMATE\n\ttmate_sync_copy_mode(wp);\n#endif\n}\n\nvoid\nwindow_pane_key(struct window_pane *wp, struct client *c, struct session *s,\n    key_code key, struct mouse_event *m)\n{\n\tstruct window_pane\t*wp2;\n\n\tif (KEYC_IS_MOUSE(key) && m == NULL)\n\t\treturn;\n\n\tif (wp->mode != NULL) {\n\t\tif (wp->mode->key != NULL)\n\t\t\twp->mode->key(wp, c, s, key, m);\n\t\treturn;\n\t}\n\n\tif (wp->fd == -1 || wp->flags & PANE_INPUTOFF)\n\t\treturn;\n\n\tinput_key(wp, key, m);\n\n\tif (KEYC_IS_MOUSE(key))\n\t\treturn;\n\tif (options_get_number(wp->window->options, \"synchronize-panes\")) {\n\t\tTAILQ_FOREACH(wp2, &wp->window->panes, entry) {\n\t\t\tif (wp2 == wp || wp2->mode != NULL)\n\t\t\t\tcontinue;\n\t\t\tif (wp2->fd == -1 || wp2->flags & PANE_INPUTOFF)\n\t\t\t\tcontinue;\n\t\t\tif (window_pane_visible(wp2))\n\t\t\t\tinput_key(wp2, key, NULL);\n\t\t}\n\t}\n}\n\nint\nwindow_pane_visible(struct window_pane *wp)\n{\n\tstruct window\t*w = wp->window;\n\n\tif (wp->layout_cell == NULL)\n\t\treturn (0);\n\tif (wp->xoff >= w->sx || wp->yoff >= w->sy)\n\t\treturn (0);\n\tif (wp->xoff + wp->sx > w->sx || wp->yoff + wp->sy > w->sy)\n\t\treturn (0);\n\treturn (1);\n}\n\nchar *\nwindow_pane_search(struct window_pane *wp, const char *searchstr,\n    u_int *lineno)\n{\n\tstruct screen\t*s = &wp->base;\n\tchar\t\t*newsearchstr, *line, *msg;\n\tu_int\t \t i;\n\n\tmsg = NULL;\n\txasprintf(&newsearchstr, \"*%s*\", searchstr);\n\n\tfor (i = 0; i < screen_size_y(s); i++) {\n\t\tline = grid_view_string_cells(s->grid, 0, i, screen_size_x(s));\n\t\tif (fnmatch(newsearchstr, line, 0) == 0) {\n\t\t\tmsg = line;\n\t\t\tif (lineno != NULL)\n\t\t\t\t*lineno = i;\n\t\t\tbreak;\n\t\t}\n\t\tfree(line);\n\t}\n\n\tfree(newsearchstr);\n\treturn (msg);\n}\n\n/* Get MRU pane from a list. */\nstruct window_pane *\nwindow_pane_choose_best(struct window_pane **list, u_int size)\n{\n\tstruct window_pane\t*next, *best;\n\tu_int\t\t\t i;\n\n\tif (size == 0)\n\t\treturn (NULL);\n\n\tbest = list[0];\n\tfor (i = 1; i < size; i++) {\n\t\tnext = list[i];\n\t\tif (next->active_point > best->active_point)\n\t\t\tbest = next;\n\t}\n\treturn (best);\n}\n\n/*\n * Find the pane directly above another. We build a list of those adjacent to\n * top edge and then choose the best.\n */\nstruct window_pane *\nwindow_pane_find_up(struct window_pane *wp)\n{\n\tstruct window_pane\t*next, *best, **list;\n\tu_int\t\t\t edge, left, right, end, size;\n\tint\t\t\t found;\n\n\tif (wp == NULL || !window_pane_visible(wp))\n\t\treturn (NULL);\n\n\tlist = NULL;\n\tsize = 0;\n\n\tedge = wp->yoff;\n\tif (edge == 0)\n\t\tedge = wp->window->sy + 1;\n\n\tleft = wp->xoff;\n\tright = wp->xoff + wp->sx;\n\n\tTAILQ_FOREACH(next, &wp->window->panes, entry) {\n\t\tif (next == wp || !window_pane_visible(next))\n\t\t\tcontinue;\n\t\tif (next->yoff + next->sy + 1 != edge)\n\t\t\tcontinue;\n\t\tend = next->xoff + next->sx - 1;\n\n\t\tfound = 0;\n\t\tif (next->xoff < left && end > right)\n\t\t\tfound = 1;\n\t\telse if (next->xoff >= left && next->xoff <= right)\n\t\t\tfound = 1;\n\t\telse if (end >= left && end <= right)\n\t\t\tfound = 1;\n\t\tif (!found)\n\t\t\tcontinue;\n\t\tlist = xreallocarray(list, size + 1, sizeof *list);\n\t\tlist[size++] = next;\n\t}\n\n\tbest = window_pane_choose_best(list, size);\n\tfree(list);\n\treturn (best);\n}\n\n/* Find the pane directly below another. */\nstruct window_pane *\nwindow_pane_find_down(struct window_pane *wp)\n{\n\tstruct window_pane\t*next, *best, **list;\n\tu_int\t\t\t edge, left, right, end, size;\n\tint\t\t\t found;\n\n\tif (wp == NULL || !window_pane_visible(wp))\n\t\treturn (NULL);\n\n\tlist = NULL;\n\tsize = 0;\n\n\tedge = wp->yoff + wp->sy + 1;\n\tif (edge >= wp->window->sy)\n\t\tedge = 0;\n\n\tleft = wp->xoff;\n\tright = wp->xoff + wp->sx;\n\n\tTAILQ_FOREACH(next, &wp->window->panes, entry) {\n\t\tif (next == wp || !window_pane_visible(next))\n\t\t\tcontinue;\n\t\tif (next->yoff != edge)\n\t\t\tcontinue;\n\t\tend = next->xoff + next->sx - 1;\n\n\t\tfound = 0;\n\t\tif (next->xoff < left && end > right)\n\t\t\tfound = 1;\n\t\telse if (next->xoff >= left && next->xoff <= right)\n\t\t\tfound = 1;\n\t\telse if (end >= left && end <= right)\n\t\t\tfound = 1;\n\t\tif (!found)\n\t\t\tcontinue;\n\t\tlist = xreallocarray(list, size + 1, sizeof *list);\n\t\tlist[size++] = next;\n\t}\n\n\tbest = window_pane_choose_best(list, size);\n\tfree(list);\n\treturn (best);\n}\n\n/* Find the pane directly to the left of another. */\nstruct window_pane *\nwindow_pane_find_left(struct window_pane *wp)\n{\n\tstruct window_pane\t*next, *best, **list;\n\tu_int\t\t\t edge, top, bottom, end, size;\n\tint\t\t\t found;\n\n\tif (wp == NULL || !window_pane_visible(wp))\n\t\treturn (NULL);\n\n\tlist = NULL;\n\tsize = 0;\n\n\tedge = wp->xoff;\n\tif (edge == 0)\n\t\tedge = wp->window->sx + 1;\n\n\ttop = wp->yoff;\n\tbottom = wp->yoff + wp->sy;\n\n\tTAILQ_FOREACH(next, &wp->window->panes, entry) {\n\t\tif (next == wp || !window_pane_visible(next))\n\t\t\tcontinue;\n\t\tif (next->xoff + next->sx + 1 != edge)\n\t\t\tcontinue;\n\t\tend = next->yoff + next->sy - 1;\n\n\t\tfound = 0;\n\t\tif (next->yoff < top && end > bottom)\n\t\t\tfound = 1;\n\t\telse if (next->yoff >= top && next->yoff <= bottom)\n\t\t\tfound = 1;\n\t\telse if (end >= top && end <= bottom)\n\t\t\tfound = 1;\n\t\tif (!found)\n\t\t\tcontinue;\n\t\tlist = xreallocarray(list, size + 1, sizeof *list);\n\t\tlist[size++] = next;\n\t}\n\n\tbest = window_pane_choose_best(list, size);\n\tfree(list);\n\treturn (best);\n}\n\n/* Find the pane directly to the right of another. */\nstruct window_pane *\nwindow_pane_find_right(struct window_pane *wp)\n{\n\tstruct window_pane\t*next, *best, **list;\n\tu_int\t\t\t edge, top, bottom, end, size;\n\tint\t\t\t found;\n\n\tif (wp == NULL || !window_pane_visible(wp))\n\t\treturn (NULL);\n\n\tlist = NULL;\n\tsize = 0;\n\n\tedge = wp->xoff + wp->sx + 1;\n\tif (edge >= wp->window->sx)\n\t\tedge = 0;\n\n\ttop = wp->yoff;\n\tbottom = wp->yoff + wp->sy;\n\n\tTAILQ_FOREACH(next, &wp->window->panes, entry) {\n\t\tif (next == wp || !window_pane_visible(next))\n\t\t\tcontinue;\n\t\tif (next->xoff != edge)\n\t\t\tcontinue;\n\t\tend = next->yoff + next->sy - 1;\n\n\t\tfound = 0;\n\t\tif (next->yoff < top && end > bottom)\n\t\t\tfound = 1;\n\t\telse if (next->yoff >= top && next->yoff <= bottom)\n\t\t\tfound = 1;\n\t\telse if (end >= top && end <= bottom)\n\t\t\tfound = 1;\n\t\tif (!found)\n\t\t\tcontinue;\n\t\tlist = xreallocarray(list, size + 1, sizeof *list);\n\t\tlist[size++] = next;\n\t}\n\n\tbest = window_pane_choose_best(list, size);\n\tfree(list);\n\treturn (best);\n}\n\n/* Clear alert flags for a winlink */\nvoid\nwinlink_clear_flags(struct winlink *wl)\n{\n\tstruct session\t*s;\n\tstruct winlink\t*wl_loop;\n\n\tRB_FOREACH(s, sessions, &sessions) {\n\t\tRB_FOREACH(wl_loop, winlinks, &s->windows) {\n\t\t\tif (wl_loop->window != wl->window)\n\t\t\t\tcontinue;\n\t\t\tif ((wl_loop->flags & WINLINK_ALERTFLAGS) == 0)\n\t\t\t\tcontinue;\n\n\t\t\twl_loop->flags &= ~WINLINK_ALERTFLAGS;\n\t\t\twl_loop->window->flags &= ~WINDOW_ALERTFLAGS;\n\t\t\tserver_status_session(s);\n\t\t}\n\t}\n}\n\nint\nwinlink_shuffle_up(struct session *s, struct winlink *wl)\n{\n\tint\t idx, last;\n\n\tidx = wl->idx + 1;\n\n\t/* Find the next free index. */\n\tfor (last = idx; last < INT_MAX; last++) {\n\t\tif (winlink_find_by_index(&s->windows, last) == NULL)\n\t\t\tbreak;\n\t}\n\tif (last == INT_MAX)\n\t\treturn (-1);\n\n\t/* Move everything from last - 1 to idx up a bit. */\n\tfor (; last > idx; last--) {\n\t\twl = winlink_find_by_index(&s->windows, last - 1);\n\t\tserver_link_window(s, wl, s, last, 0, 0, NULL);\n\t\tserver_unlink_window(s, wl);\n\t}\n\n\treturn (idx);\n}\n"
        },
        {
          "name": "xmalloc.c",
          "type": "blob",
          "size": 2.595703125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Author: Tatu Ylonen <ylo@cs.hut.fi>\n * Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland\n *                    All rights reserved\n * Versions of malloc and friends that check their results, and never return\n * failure (they call fatal if they encounter an error).\n *\n * As far as I am concerned, the code I have written for this software\n * can be used freely for any purpose.  Any derived versions of this\n * software must be clearly marked as such, and if the derived work is\n * incompatible with the protocol description in the RFC file, it must be\n * called by a name other than \"ssh\" or \"Secure Shell\".\n */\n\n#include <errno.h>\n#include <limits.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"tmux.h\"\n\nvoid *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: allocating %zu bytes: %s\",\n\t\t    size, strerror(errno));\n\treturn ptr;\n}\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: allocating %zu * %zu bytes: %s\",\n\t\t    nmemb, size, strerror(errno));\n\treturn ptr;\n}\n\nvoid *\nxrealloc(void *ptr, size_t size)\n{\n\treturn xreallocarray(ptr, 1, size);\n}\n\nvoid *\nxreallocarray(void *ptr, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tif (nmemb == 0 || size == 0)\n\t\tfatal(\"xreallocarray: zero size\");\n\tnew_ptr = reallocarray(ptr, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xreallocarray: allocating %zu * %zu bytes: %s\",\n\t\t    nmemb, size, strerror(errno));\n\treturn new_ptr;\n}\n\nchar *\nxstrdup(const char *str)\n{\n\tchar *cp;\n\n\tif ((cp = strdup(str)) == NULL)\n\t\tfatal(\"xstrdup: %s\", strerror(errno));\n\treturn cp;\n}\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = xvasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\treturn i;\n}\n\n__attribute__((__format__(__printf__, 2, 0)))\nint\nxvasprintf(char **ret, const char *fmt, va_list ap)\n{\n\tint i;\n\n\ti = vasprintf(ret, fmt, ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: %s\", strerror(errno));\n\n\treturn i;\n}\n\nint\nxsnprintf(char *str, size_t len, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = xvsnprintf(str, len, fmt, ap);\n\tva_end(ap);\n\n\treturn i;\n}\n\n__attribute__((__format__(__printf__, 3, 0)))\nint\nxvsnprintf(char *str, size_t len, const char *fmt, va_list ap)\n{\n\tint i;\n\n\tif (len > INT_MAX)\n\t\tfatal(\"xsnprintf: len > INT_MAX\");\n\n\ti = vsnprintf(str, len, fmt, ap);\n\n\tif (i < 0 || i >= (int)len)\n\t\tfatal(\"xsnprintf: overflow\");\n\n\treturn i;\n}\n"
        },
        {
          "name": "xmalloc.h",
          "type": "blob",
          "size": 1.4736328125,
          "content": "/* $OpenBSD$ */\n\n/*\n * Author: Tatu Ylonen <ylo@cs.hut.fi>\n * Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland\n *                    All rights reserved\n * Created: Mon Mar 20 22:09:17 1995 ylo\n *\n * Versions of malloc and friends that check their results, and never return\n * failure (they call fatal if they encounter an error).\n *\n * As far as I am concerned, the code I have written for this software\n * can be used freely for any purpose.  Any derived versions of this\n * software must be clearly marked as such, and if the derived work is\n * incompatible with the protocol description in the RFC file, it must be\n * called by a name other than \"ssh\" or \"Secure Shell\".\n */\n\n#ifndef XMALLOC_H\n#define XMALLOC_H\n\n#if !defined(__bounded__)\n# define __bounded__(x, y, z)\n#endif\n\nvoid\t*xmalloc(size_t);\nvoid\t*xcalloc(size_t, size_t);\nvoid\t*xrealloc(void *, size_t);\nvoid\t*xreallocarray(void *, size_t, size_t);\nchar\t*xstrdup(const char *);\nint\t xasprintf(char **, const char *, ...)\n\t\t__attribute__((__format__ (printf, 2, 3)))\n\t\t__attribute__((__nonnull__ (2)));\nint\t xvasprintf(char **, const char *, va_list)\n\t\t__attribute__((__nonnull__ (2)));\nint\t xsnprintf(char *, size_t, const char *, ...)\n\t\t__attribute__((__format__ (printf, 3, 4)))\n\t\t__attribute__((__nonnull__ (3)))\n\t\t__attribute__((__bounded__ (__string__, 1, 2)));\nint\t xvsnprintf(char *, size_t, const char *, va_list)\n\t\t__attribute__((__nonnull__ (3)))\n\t\t__attribute__((__bounded__ (__string__, 1, 2)));\n\n#endif\t/* XMALLOC_H */\n"
        },
        {
          "name": "xterm-keys.c",
          "type": "blob",
          "size": 5.8037109375,
          "content": "/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2009 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <string.h>\n\n#include \"tmux.h\"\n\n/*\n * xterm-style function keys append one of the following values before the last\n * character:\n *\n * 2 Shift\n * 3 Alt\n * 4 Shift + Alt\n * 5 Ctrl\n * 6 Shift + Ctrl\n * 7 Alt + Ctrl\n * 8 Shift + Alt + Ctrl\n *\n * Rather than parsing them, just match against a table.\n *\n * There are three forms for F1-F4 (\\\\033O_P and \\\\033O1;_P and \\\\033[1;_P).\n * We accept any but always output the latter (it comes first in the table).\n */\n\nint\txterm_keys_match(const char *, const char *, size_t, size_t *,\n\t    key_code *);\nint\txterm_keys_modifiers(const char *, size_t, size_t *, key_code *);\n\nstruct xterm_keys_entry {\n\tkey_code\t key;\n\tconst char\t*template;\n};\n\nconst struct xterm_keys_entry xterm_keys_table[] = {\n\t{ KEYC_F1,\t\"\\033[1;_P\" },\n\t{ KEYC_F1,\t\"\\033O1;_P\" },\n\t{ KEYC_F1,\t\"\\033O_P\" },\n\t{ KEYC_F2,\t\"\\033[1;_Q\" },\n\t{ KEYC_F2,\t\"\\033O1;_Q\" },\n\t{ KEYC_F2,\t\"\\033O_Q\" },\n\t{ KEYC_F3,\t\"\\033[1;_R\" },\n\t{ KEYC_F3,\t\"\\033O1;_R\" },\n\t{ KEYC_F3,\t\"\\033O_R\" },\n\t{ KEYC_F4,\t\"\\033[1;_S\" },\n\t{ KEYC_F4,\t\"\\033O1;_S\" },\n\t{ KEYC_F4,\t\"\\033O_S\" },\n\t{ KEYC_F5,\t\"\\033[15;_~\" },\n\t{ KEYC_F6,\t\"\\033[17;_~\" },\n\t{ KEYC_F7,\t\"\\033[18;_~\" },\n\t{ KEYC_F8,\t\"\\033[19;_~\" },\n\t{ KEYC_F9,\t\"\\033[20;_~\" },\n\t{ KEYC_F10,\t\"\\033[21;_~\" },\n\t{ KEYC_F11,\t\"\\033[23;_~\" },\n\t{ KEYC_F12,\t\"\\033[24;_~\" },\n\t{ KEYC_UP,\t\"\\033[1;_A\" },\n\t{ KEYC_DOWN,\t\"\\033[1;_B\" },\n\t{ KEYC_RIGHT,\t\"\\033[1;_C\" },\n\t{ KEYC_LEFT,\t\"\\033[1;_D\" },\n\t{ KEYC_HOME,\t\"\\033[1;_H\" },\n\t{ KEYC_END,\t\"\\033[1;_F\" },\n\t{ KEYC_PPAGE,\t\"\\033[5;_~\" },\n\t{ KEYC_NPAGE,\t\"\\033[6;_~\" },\n\t{ KEYC_IC,\t\"\\033[2;_~\" },\n\t{ KEYC_DC,\t\"\\033[3;_~\" },\n\n\t{ '!',          \"\\033[27;_;33~\" },\n\t{ '#',\t\t\"\\033[27;_;35~\" },\n\t{ '(',\t\t\"\\033[27;_;40~\" },\n\t{ ')',\t\t\"\\033[27;_;41~\" },\n\t{ '+',\t\t\"\\033[27;_;43~\" },\n\t{ ',',\t\t\"\\033[27;_;44~\" },\n\t{ '-',\t\t\"\\033[27;_;45~\" },\n\t{ '.',\t\t\"\\033[27;_;46~\" },\n\t{ '0',\t\t\"\\033[27;_;48~\" },\n\t{ '1',\t\t\"\\033[27;_;49~\" },\n\t{ '2',\t\t\"\\033[27;_;50~\" },\n\t{ '3',\t\t\"\\033[27;_;51~\" },\n\t{ '4',\t\t\"\\033[27;_;52~\" },\n\t{ '5',\t\t\"\\033[27;_;53~\" },\n\t{ '6',\t\t\"\\033[27;_;54~\" },\n\t{ '7',\t\t\"\\033[27;_;55~\" },\n\t{ '8',\t\t\"\\033[27;_;56~\" },\n\t{ '9',\t\t\"\\033[27;_;57~\" },\n\t{ ':',\t\t\"\\033[27;_;58~\" },\n\t{ ';',\t\t\"\\033[27;_;59~\" },\n\t{ '<',\t\t\"\\033[27;_;60~\" },\n\t{ '=',\t\t\"\\033[27;_;61~\" },\n\t{ '>',\t\t\"\\033[27;_;62~\" },\n\t{ '?',\t\t\"\\033[27;_;63~\" },\n\t{ '\\'',\t\t\"\\033[27;_;39~\" },\n\t{ '\\r',\t\t\"\\033[27;_;13~\" },\n\t{ '\\t',\t\t\"\\033[27;_;9~\" },\n};\n\n/*\n * Match key against buffer, treating _ as a wildcard. Return -1 for no match,\n * 0 for match, 1 if the end of the buffer is reached (need more data).\n */\nint\nxterm_keys_match(const char *template, const char *buf, size_t len,\n    size_t *size, key_code *modifiers)\n{\n\tsize_t\tpos;\n\tint\tretval;\n\n\t*modifiers = 0;\n\n\tif (len == 0)\n\t\treturn (0);\n\n\tpos = 0;\n\tdo {\n\t\tif (*template == '_') {\n\t\t\tretval = xterm_keys_modifiers(buf, len, &pos,\n\t\t\t    modifiers);\n\t\t\tif (retval != 0)\n\t\t\t\treturn (retval);\n\t\t\tcontinue;\n\t\t}\n\t\tif (buf[pos] != *template)\n\t\t\treturn (-1);\n\t\tpos++;\n\t} while (*++template != '\\0' && pos != len);\n\n\tif (*template != '\\0')\t/* partial */\n\t\treturn (1);\n\n\t*size = pos;\n\treturn (0);\n}\n\n/* Find modifiers from buffer. */\nint\nxterm_keys_modifiers(const char *buf, size_t len, size_t *pos,\n    key_code *modifiers)\n{\n\tu_int\tflags;\n\n\tif (len - *pos < 2)\n\t\treturn (1);\n\n\tif (buf[*pos] < '0' || buf[*pos] > '9')\n\t\treturn (-1);\n\tflags = buf[(*pos)++] - '0';\n\tif (buf[*pos] >= '0' && buf[*pos] <= '9')\n\t\tflags = (flags * 10) + (buf[(*pos)++] - '0');\n\tflags -= 1;\n\n\t*modifiers = 0;\n\tif (flags & 1)\n\t\t*modifiers |= KEYC_SHIFT;\n\tif (flags & 2)\n\t\t*modifiers |= KEYC_ESCAPE;\n\tif (flags & 4)\n\t\t*modifiers |= KEYC_CTRL;\n\tif (flags & 8)\n\t\t*modifiers |= KEYC_ESCAPE;\n\treturn (0);\n}\n\n/*\n * Lookup key from a buffer against the table. Returns 0 for found (and the\n * key), -1 for not found, 1 for partial match.\n */\nint\nxterm_keys_find(const char *buf, size_t len, size_t *size, key_code *key)\n{\n\tconst struct xterm_keys_entry\t*entry;\n\tu_int\t\t\t\t i;\n\tint\t\t\t\t matched;\n\tkey_code\t\t\t modifiers;\n\n\tfor (i = 0; i < nitems(xterm_keys_table); i++) {\n\t\tentry = &xterm_keys_table[i];\n\n\t\tmatched = xterm_keys_match(entry->template, buf, len, size,\n\t\t    &modifiers);\n\t\tif (matched == -1)\n\t\t\tcontinue;\n\t\tif (matched == 0)\n\t\t\t*key = entry->key | modifiers;\n\t\treturn (matched);\n\t}\n\treturn (-1);\n}\n\n/* Lookup a key number from the table. */\nchar *\nxterm_keys_lookup(key_code key)\n{\n\tconst struct xterm_keys_entry\t*entry;\n\tu_int\t\t\t\t i;\n\tkey_code\t\t\t modifiers;\n\tchar\t\t\t\t*out;\n\n\tmodifiers = 1;\n\tif (key & KEYC_SHIFT)\n\t\tmodifiers += 1;\n\tif (key & KEYC_ESCAPE)\n\t\tmodifiers += 2;\n\tif (key & KEYC_CTRL)\n\t\tmodifiers += 4;\n\n\t/*\n\t * If the key has no modifiers, return NULL and let it fall through to\n\t * the normal lookup.\n\t */\n\tif (modifiers == 1)\n\t\treturn (NULL);\n\n\t/* Otherwise, find the key in the table. */\n\tkey &= ~(KEYC_SHIFT|KEYC_ESCAPE|KEYC_CTRL);\n\tfor (i = 0; i < nitems(xterm_keys_table); i++) {\n\t\tentry = &xterm_keys_table[i];\n\t\tif (key == entry->key)\n\t\t\tbreak;\n\t}\n\tif (i == nitems(xterm_keys_table))\n\t\treturn (NULL);\n\n\t/* Copy the template and replace the modifier. */\n\tout = xstrdup(entry->template);\n\tout[strcspn(out, \"_\")] = '0' + modifiers;\n\treturn (out);\n}\n"
        }
      ]
    }
  ]
}