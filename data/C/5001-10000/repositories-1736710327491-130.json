{
  "metadata": {
    "timestamp": 1736710327491,
    "page": 130,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "rui314/8cc",
      "stars": 6190,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0361328125,
          "content": "*.bin\n*.o\n*.s\n*~\n8cc\nstage?\nutiltest\n"
        },
        {
          "name": "8cc.h",
          "type": "blob",
          "size": 9.02734375,
          "content": "// Copyright 2012 Rui Ueyama. Released under the MIT license.\n\n#ifndef EIGHTCC_H\n#define EIGHTCC_H\n\n#include <assert.h>\n#include <inttypes.h>\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdnoreturn.h>\n#include <time.h>\n\nenum {\n    TIDENT,\n    TKEYWORD,\n    TNUMBER,\n    TCHAR,\n    TSTRING,\n    TEOF,\n    TINVALID,\n    // Only in CPP\n    MIN_CPP_TOKEN,\n    TNEWLINE,\n    TSPACE,\n    TMACRO_PARAM,\n};\n\nenum {\n    ENC_NONE,\n    ENC_CHAR16,\n    ENC_CHAR32,\n    ENC_UTF8,\n    ENC_WCHAR,\n};\n\ntypedef struct Map {\n    struct Map *parent;\n    char **key;\n    void **val;\n    int size;\n    int nelem;\n    int nused;\n} Map;\n\ntypedef struct {\n    void **body;\n    int len;\n    int nalloc;\n} Vector;\n\ntypedef struct {\n    struct Map *map;\n    Vector *key;\n} Dict;\n\ntypedef struct Set {\n    char *v;\n    struct Set *next;\n} Set;\n\ntypedef struct {\n    char *body;\n    int nalloc;\n    int len;\n} Buffer;\n\ntypedef struct {\n    FILE *file;  // stream backed by FILE *\n    char *p;     // stream backed by string\n    char *name;\n    int line;\n    int column;\n    int ntok;     // token counter\n    int last;     // the last character read from file\n    int buf[3];   // push-back buffer for unread operations\n    int buflen;   // push-back buffer size\n    time_t mtime; // last modified time. 0 if string-backed file\n} File;\n\ntypedef struct {\n    int kind;\n    File *file;\n    int line;\n    int column;\n    bool space;   // true if the token has a leading space\n    bool bol;     // true if the token is at the beginning of a line\n    int count;    // token number in a file, counting from 0.\n    Set *hideset; // used by the preprocessor for macro expansion\n    union {\n        // TKEYWORD\n        int id;\n        // TSTRING or TCHAR\n        struct {\n            char *sval;\n            int slen;\n            int c;\n            int enc;\n        };\n        // TMACRO_PARAM\n        struct {\n            bool is_vararg;\n            int position;\n        };\n    };\n} Token;\n\nenum {\n    AST_LITERAL = 256,\n    AST_LVAR,\n    AST_GVAR,\n    AST_TYPEDEF,\n    AST_FUNCALL,\n    AST_FUNCPTR_CALL,\n    AST_FUNCDESG,\n    AST_FUNC,\n    AST_DECL,\n    AST_INIT,\n    AST_CONV,\n    AST_ADDR,\n    AST_DEREF,\n    AST_IF,\n    AST_TERNARY,\n    AST_DEFAULT,\n    AST_RETURN,\n    AST_COMPOUND_STMT,\n    AST_STRUCT_REF,\n    AST_GOTO,\n    AST_COMPUTED_GOTO,\n    AST_LABEL,\n    OP_SIZEOF,\n    OP_CAST,\n    OP_SHR,\n    OP_SHL,\n    OP_A_SHR,\n    OP_A_SHL,\n    OP_PRE_INC,\n    OP_PRE_DEC,\n    OP_POST_INC,\n    OP_POST_DEC,\n    OP_LABEL_ADDR,\n#define op(name, _) name,\n#define keyword(name, x, y) name,\n#include \"keyword.inc\"\n#undef keyword\n#undef op\n};\n\nenum {\n    KIND_VOID,\n    KIND_BOOL,\n    KIND_CHAR,\n    KIND_SHORT,\n    KIND_INT,\n    KIND_LONG,\n    KIND_LLONG,\n    KIND_FLOAT,\n    KIND_DOUBLE,\n    KIND_LDOUBLE,\n    KIND_ARRAY,\n    KIND_ENUM,\n    KIND_PTR,\n    KIND_STRUCT,\n    KIND_FUNC,\n    // used only in parser\n    KIND_STUB,\n};\n\ntypedef struct Type {\n    int kind;\n    int size;\n    int align;\n    bool usig; // true if unsigned\n    bool isstatic;\n    // pointer or array\n    struct Type *ptr;\n    // array length\n    int len;\n    // struct\n    Dict *fields;\n    int offset;\n    bool is_struct; // true if struct, false if union\n    // bitfield\n    int bitoff;\n    int bitsize;\n    // function\n    struct Type *rettype;\n    Vector *params;\n    bool hasva;\n    bool oldstyle;\n} Type;\n\ntypedef struct {\n    char *file;\n    int line;\n} SourceLoc;\n\ntypedef struct Node {\n    int kind;\n    Type *ty;\n    SourceLoc *sourceLoc;\n    union {\n        // Char, int, or long\n        long ival;\n        // Float or double\n        struct {\n            double fval;\n            char *flabel;\n        };\n        // String\n        struct {\n            char *sval;\n            char *slabel;\n        };\n        // Local/global variable\n        struct {\n            char *varname;\n            // local\n            int loff;\n            Vector *lvarinit;\n            // global\n            char *glabel;\n        };\n        // Binary operator\n        struct {\n            struct Node *left;\n            struct Node *right;\n        };\n        // Unary operator\n        struct {\n            struct Node *operand;\n        };\n        // Function call or function declaration\n        struct {\n            char *fname;\n            // Function call\n            Vector *args;\n            struct Type *ftype;\n            // Function pointer or function designator\n            struct Node *fptr;\n            // Function declaration\n            Vector *params;\n            Vector *localvars;\n            struct Node *body;\n        };\n        // Declaration\n        struct {\n            struct Node *declvar;\n            Vector *declinit;\n        };\n        // Initializer\n        struct {\n            struct Node *initval;\n            int initoff;\n            Type *totype;\n        };\n        // If statement or ternary operator\n        struct {\n            struct Node *cond;\n            struct Node *then;\n            struct Node *els;\n        };\n        // Goto and label\n        struct {\n            char *label;\n            char *newlabel;\n        };\n        // Return statement\n        struct Node *retval;\n        // Compound statement\n        Vector *stmts;\n        // Struct reference\n        struct {\n            struct Node *struc;\n            char *field;\n            Type *fieldtype;\n        };\n    };\n} Node;\n\nextern Type *type_void;\nextern Type *type_bool;\nextern Type *type_char;\nextern Type *type_short;\nextern Type *type_int;\nextern Type *type_long;\nextern Type *type_llong;\nextern Type *type_uchar;\nextern Type *type_ushort;\nextern Type *type_uint;\nextern Type *type_ulong;\nextern Type *type_ullong;\nextern Type *type_float;\nextern Type *type_double;\nextern Type *type_ldouble;\n\n#define EMPTY_MAP ((Map){})\n#define EMPTY_VECTOR ((Vector){})\n\n// encoding.c\nBuffer *to_utf16(char *p, int len);\nBuffer *to_utf32(char *p, int len);\nvoid write_utf8(Buffer *b, uint32_t rune);\n\n// buffer.c\nBuffer *make_buffer(void);\nchar *buf_body(Buffer *b);\nint buf_len(Buffer *b);\nvoid buf_write(Buffer *b, char c);\nvoid buf_append(Buffer *b, char *s, int len);\nvoid buf_printf(Buffer *b, char *fmt, ...);\nchar *vformat(char *fmt, va_list ap);\nchar *format(char *fmt, ...);\nchar *quote_cstring(char *p);\nchar *quote_cstring_len(char *p, int len);\nchar *quote_char(char c);\n\n// cpp.c\nvoid read_from_string(char *buf);\nbool is_ident(Token *tok, char *s);\nvoid expect_newline(void);\nvoid add_include_path(char *path);\nvoid init_now(void);\nvoid cpp_init(void);\nToken *peek_token(void);\nToken *read_token(void);\n\n// debug.c\nchar *ty2s(Type *ty);\nchar *node2s(Node *node);\nchar *tok2s(Token *tok);\n\n// dict.c\nDict *make_dict(void);\nvoid *dict_get(Dict *dict, char *key);\nvoid dict_put(Dict *dict, char *key, void *val);\nVector *dict_keys(Dict *dict);\n\n// error.c\nextern bool enable_warning;\nextern bool dumpstack;\nextern bool dumpsource;\nextern bool warning_is_error;\n\n#define STR2(x) #x\n#define STR(x) STR2(x)\n#define error(...)       errorf(__FILE__ \":\" STR(__LINE__), NULL, __VA_ARGS__)\n#define errort(tok, ...) errorf(__FILE__ \":\" STR(__LINE__), token_pos(tok), __VA_ARGS__)\n#define warn(...)        warnf(__FILE__ \":\" STR(__LINE__), NULL, __VA_ARGS__)\n#define warnt(tok, ...)  warnf(__FILE__ \":\" STR(__LINE__), token_pos(tok), __VA_ARGS__)\n\nnoreturn void errorf(char *line, char *pos, char *fmt, ...);\nvoid warnf(char *line, char *pos, char *fmt, ...);\nchar *token_pos(Token *tok);\n\n// file.c\nFile *make_file(FILE *file, char *name);\nFile *make_file_string(char *s);\nint readc(void);\nvoid unreadc(int c);\nFile *current_file(void);\nvoid stream_push(File *file);\nint stream_depth(void);\nchar *input_position(void);\nvoid stream_stash(File *f);\nvoid stream_unstash(void);\n\n// gen.c\nvoid set_output_file(FILE *fp);\nvoid close_output_file(void);\nvoid emit_toplevel(Node *v);\n\n// lex.c\nvoid lex_init(char *filename);\nchar *get_base_file(void);\nvoid skip_cond_incl(void);\nchar *read_header_file_name(bool *std);\nbool is_keyword(Token *tok, int c);\nvoid token_buffer_stash(Vector *buf);\nvoid token_buffer_unstash();\nvoid unget_token(Token *tok);\nToken *lex_string(char *s);\nToken *lex(void);\n\n// map.c\nMap *make_map(void);\nMap *make_map_parent(Map *parent);\nvoid *map_get(Map *m, char *key);\nvoid map_put(Map *m, char *key, void *val);\nvoid map_remove(Map *m, char *key);\nsize_t map_len(Map *m);\n\n// parse.c\nchar *make_tempname(void);\nchar *make_label(void);\nbool is_inttype(Type *ty);\nbool is_flotype(Type *ty);\nvoid *make_pair(void *first, void *second);\nint eval_intexpr(Node *node, Node **addr);\nNode *read_expr(void);\nVector *read_toplevels(void);\nvoid parse_init(void);\nchar *fullpath(char *path);\n\n// set.c\nSet *set_add(Set *s, char *v);\nbool set_has(Set *s, char *v);\nSet *set_union(Set *a, Set *b);\nSet *set_intersection(Set *a, Set *b);\n\n// vector.c\nVector *make_vector(void);\nVector *make_vector1(void *e);\nVector *vec_copy(Vector *src);\nvoid vec_push(Vector *vec, void *elem);\nvoid vec_append(Vector *a, Vector *b);\nvoid *vec_pop(Vector *vec);\nvoid *vec_get(Vector *vec, int index);\nvoid vec_set(Vector *vec, int index, void *val);\nvoid *vec_head(Vector *vec);\nvoid *vec_tail(Vector *vec);\nVector *vec_reverse(Vector *vec);\nvoid *vec_body(Vector *vec);\nint vec_len(Vector *vec);\n\n#endif\n"
        },
        {
          "name": "HACKING.md",
          "type": "blob",
          "size": 1.232421875,
          "content": "I accept small patches, but because this is my hobby project to\nlearn about compilers, it's unlikely to accept large patches.\nThat's in practice not going to be an issue, because\nif you are writing a large patch, that is your hobby project.\nYou want to hack in your forked repository rather than\ntaking time to send pull requests.\n\n# Memory management\n\nNo memory management is a memory management scheme in 8cc.\nMemory regions allocated using malloc are never freed\nuntil the process terminates. That has greatly simplified\nthe code and the APIs because 1) you can write code as if\ngarbage collector were present, and 2) that design\ndecision has eliminated use-after-free bugs entirely.\n\nModern computers have gigs of memory. 8cc consumes\nonly about 100MB to compile 10K lines of C source file.\nCompiler is not a long-running process.\nIt will never run out of memory unless you give an\nunrealistically large source file.\n\nIf we really need to free memory, we could use Boehm garbage\ncollector. I don't see that need at this moment though.\n\n# Backend\n\nBackend is being rewritten. Once it's done, the current backend\ncode will be discarded. The new backend models after the LLVM IR\nbecause the IR looks to be designed well. That's not going to be\nthe same, though."
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0478515625,
          "content": "Copyright (c) 2012 Rui Ueyama <rui314@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 1.5498046875,
          "content": "CFLAGS=-Wall -Wno-strict-aliasing -std=gnu11 -g -I. -O0\nOBJS=cpp.o debug.o dict.o gen.o lex.o vector.o parse.o buffer.o map.o \\\n     error.o path.o file.o set.o encoding.o\nTESTS := $(patsubst %.c,%.bin,$(filter-out test/testmain.c,$(wildcard test/*.c)))\nECC=./8cc\noverride CFLAGS += -DBUILD_DIR='\"$(shell pwd)\"'\n\n8cc: 8cc.h main.o $(OBJS)\n\tcc -o $@ main.o $(OBJS) $(LDFLAGS)\n\n$(OBJS) utiltest.o main.o: 8cc.h keyword.inc\n\nutiltest: 8cc.h utiltest.o $(OBJS)\n\tcc -o $@ utiltest.o $(OBJS) $(LDFLAGS)\n\ntest/%.o: test/%.c $(ECC)\n\t$(ECC) -w -o $@ -c $<\n\ntest/%.bin: test/%.o test/testmain.o\n\tcc -o $@ $< test/testmain.o $(LDFLAGS)\n\nself: 8cc cleanobj\n\t$(MAKE) CC=$(ECC) CFLAGS= 8cc\n\ntest: 8cc $(TESTS)\n\t$(MAKE) CC=$(ECC) CFLAGS= utiltest\n\t./utiltest\n\t./test/ast.sh\n\t./test/negative.py\n\t$(MAKE) runtests\n\nruntests:\n\t@for test in $(TESTS); do  \\\n\t    ./$$test || exit;      \\\n\tdone\n\nstage1:\n\t$(MAKE) cleanobj\n\t[ -f 8cc ] || $(MAKE) 8cc\n\tmv 8cc stage1\n\nstage2: stage1\n\t$(MAKE) cleanobj\n\t$(MAKE) CC=./stage1 ECC=./stage1 CFLAGS= 8cc\n\tmv 8cc stage2\n\nstage3: stage2\n\t$(MAKE) cleanobj\n\t$(MAKE) CC=./stage2 ECC=./stage2 CFLAGS= 8cc\n\tmv 8cc stage3\n\n# Compile and run the tests with the default compiler.\ntesttest:\n\t$(MAKE) clean\n\t$(MAKE) $(TESTS)\n\t$(MAKE) runtests\n\nfulltest: testtest\n\t$(MAKE) stage1\n\t$(MAKE) CC=./stage1 ECC=./stage1 CFLAGS= test\n\t$(MAKE) stage2\n\t$(MAKE) CC=./stage2 ECC=./stage2 CFLAGS= test\n\t$(MAKE) stage3\n\tcmp stage2 stage3\n\nclean: cleanobj\n\trm -f 8cc stage?\n\ncleanobj:\n\trm -f *.o *.s test/*.o test/*.bin utiltest\n\nall: 8cc\n\n.PHONY: clean cleanobj test runtests fulltest self all\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.748046875,
          "content": "8cc C Compiler\n==============\n\nNote: 8cc is no longer an active project. The successor is\n[chibicc](https://github.com/rui314/chibicc).\n\n8cc is a compiler for the C programming language.\nIt's intended to support all C11 language features\nwhile keeping the code as small and simple as possible.\n\nThe compiler is able to compile itself.\nYou can see its code both as an implementation of the C language\nand as an example of what this compiler is able to compile.\n\n8cc's source code is carefully written to be as concise and easy-to-read\nas possible, so that the source code becomes good study material\nto learn about various techniques used in compilers.\nYou may find the lexer, the preprocessor and the parser are\nalready useful to learn how C source code is processed at each stage.\n\nIt's not an optimizing compiler.\nGenerated code is usually 2x or more slower than GCC.\nI plan to implement a reasonable level of optimization in the future.\n\n8cc supports x86-64 Linux only. I have no plan to make it portable until\nI fix all known miscompilations and implement an optimization pass.\nAs of 2015, I'm using Ubuntu 14 as my development platform.\nIt should work on other x86-64 Linux distributions though.\n\nNote: Do not have high expectations on this compiler.\nIf you try to compile a program other than the compiler itself,\nthere's a good chance to see compile errors or miscompilations.\nThis is basically a one-man project, and I have spent only a few\nmonths of my spare time so far.\n\nBuild\n-----\n\nRun make to build:\n\n    make\n\n8cc comes with unit tests. To run the tests, give \"test\" as an argument:\n\n    make test\n\nThe following target builds 8cc three times to verify that\nstage1 compiler can build stage2, and stage2 can build stage3.\nIt then compares stage2 and stage3 binaries byte-by-byte to verify\nthat we reach a fixed point.\n\n    make fulltest\n\nAuthor\n------\n\nRui Ueyama <rui314@gmail.com>\n\n\nLinks for C compiler development\n--------------------------------\n\nBesides popular books about compiler, such as the Dragon Book,\nI found the following books/documents are very useful\nto develop a C compiler.\nNote that the standard draft versions are very close to the ratified versions.\nYou can practically use them as the standard documents.\n\n-   LCC: A Retargetable C Compiler: Design and Implementation\n    http://www.amazon.com/dp/0805316701,\n    https://github.com/drh/lcc\n\n-   TCC: Tiny C Compiler\n    http://bellard.org/tcc/,\n    http://repo.or.cz/w/tinycc.git/tree\n\n-   C99 standard final draft\n    http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf\n\n-   C11 standard final draft\n    http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\n\n-   Dave Prosser's C Preprocessing Algorithm\n    http://www.spinellis.gr/blog/20060626/\n\n-   The x86-64 ABI\n    http://www.x86-64.org/documentation/abi.pdf\n"
        },
        {
          "name": "buffer.c",
          "type": "blob",
          "size": 2.642578125,
          "content": "// Copyright 2012 Rui Ueyama. Released under the MIT license.\n\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"8cc.h\"\n\n#define INIT_SIZE 8\n\nBuffer *make_buffer() {\n    Buffer *r = malloc(sizeof(Buffer));\n    r->body = malloc(INIT_SIZE);\n    r->nalloc = INIT_SIZE;\n    r->len = 0;\n    return r;\n}\n\nstatic void realloc_body(Buffer *b) {\n    int newsize = b->nalloc * 2;\n    char *body = malloc(newsize);\n    memcpy(body, b->body, b->len);\n    b->body = body;\n    b->nalloc = newsize;\n}\n\nchar *buf_body(Buffer *b) {\n    return b->body;\n}\n\nint buf_len(Buffer *b) {\n    return b->len;\n}\n\nvoid buf_write(Buffer *b, char c) {\n    if (b->nalloc == (b->len + 1))\n        realloc_body(b);\n    b->body[b->len++] = c;\n}\n\nvoid buf_append(Buffer *b, char *s, int len) {\n    for (int i = 0; i < len; i++)\n        buf_write(b, s[i]);\n}\n\nvoid buf_printf(Buffer *b, char *fmt, ...) {\n    va_list args;\n    for (;;) {\n        int avail = b->nalloc - b->len;\n        va_start(args, fmt);\n        int written = vsnprintf(b->body + b->len, avail, fmt, args);\n        va_end(args);\n        if (avail <= written) {\n            realloc_body(b);\n            continue;\n        }\n        b->len += written;\n        return;\n    }\n}\n\nchar *vformat(char *fmt, va_list ap) {\n    Buffer *b = make_buffer();\n    va_list aq;\n    for (;;) {\n        int avail = b->nalloc - b->len;\n        va_copy(aq, ap);\n        int written = vsnprintf(b->body + b->len, avail, fmt, aq);\n        va_end(aq);\n        if (avail <= written) {\n            realloc_body(b);\n            continue;\n        }\n        b->len += written;\n        return buf_body(b);\n    }\n}\n\nchar *format(char *fmt, ...) {\n    va_list ap;\n    va_start(ap, fmt);\n    char *r = vformat(fmt, ap);\n    va_end(ap);\n    return r;\n}\n\nstatic char *quote(char c) {\n    switch (c) {\n    case '\"': return \"\\\\\\\"\";\n    case '\\\\': return \"\\\\\\\\\";\n    case '\\b': return \"\\\\b\";\n    case '\\f': return \"\\\\f\";\n    case '\\n': return \"\\\\n\";\n    case '\\r': return \"\\\\r\";\n    case '\\t': return \"\\\\t\";\n    }\n    return NULL;\n}\n\nstatic void print(Buffer *b, char c) {\n    char *q = quote(c);\n    if (q) {\n        buf_printf(b, \"%s\", q);\n    } else if (isprint(c)) {\n        buf_printf(b, \"%c\", c);\n    } else {\n        buf_printf(b, \"\\\\x%02x\", c);\n    }\n}\n\nchar *quote_cstring(char *p) {\n    Buffer *b = make_buffer();\n    while (*p)\n        print(b, *p++);\n    return buf_body(b);\n}\n\nchar *quote_cstring_len(char *p, int len) {\n    Buffer *b = make_buffer();\n    for (int i = 0; i < len; i++)\n        print(b, p[i]);\n    return buf_body(b);\n}\n\nchar *quote_char(char c) {\n    if (c == '\\\\') return \"\\\\\\\\\";\n    if (c == '\\'') return \"\\\\'\";\n    return format(\"%c\", c);\n}\n"
        },
        {
          "name": "cpp.c",
          "type": "blob",
          "size": 28.2646484375,
          "content": "// Copyright 2012 Rui Ueyama. Released under the MIT license.\n\n/*\n * This implements Dave Prosser's C Preprocessing algorithm, described\n * in this document: https://github.com/rui314/8cc/wiki/cpp.algo.pdf\n */\n\n#include <ctype.h>\n#include <libgen.h>\n#include <locale.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n#include \"8cc.h\"\n\nstatic Map *macros = &EMPTY_MAP;\nstatic Map *once = &EMPTY_MAP;\nstatic Map *keywords = &EMPTY_MAP;\nstatic Map *include_guard = &EMPTY_MAP;\nstatic Vector *cond_incl_stack = &EMPTY_VECTOR;\nstatic Vector *std_include_path = &EMPTY_VECTOR;\nstatic struct tm now;\nstatic Token *cpp_token_zero = &(Token){ .kind = TNUMBER, .sval = \"0\" };\nstatic Token *cpp_token_one = &(Token){ .kind = TNUMBER, .sval = \"1\" };\n\ntypedef void SpecialMacroHandler(Token *tok);\ntypedef enum { IN_THEN, IN_ELIF, IN_ELSE } CondInclCtx;\ntypedef enum { MACRO_OBJ, MACRO_FUNC, MACRO_SPECIAL } MacroType;\n\ntypedef struct {\n    CondInclCtx ctx;\n    char *include_guard;\n    File *file;\n    bool wastrue;\n} CondIncl;\n\ntypedef struct {\n    MacroType kind;\n    int nargs;\n    Vector *body;\n    bool is_varg;\n    SpecialMacroHandler *fn;\n} Macro;\n\nstatic Macro *make_obj_macro(Vector *body);\nstatic Macro *make_func_macro(Vector *body, int nargs, bool is_varg);\nstatic Macro *make_special_macro(SpecialMacroHandler *fn);\nstatic void define_obj_macro(char *name, Token *value);\nstatic void read_directive(Token *hash);\nstatic Token *read_expand(void);\n\n/*\n * Constructors\n */\n\nstatic CondIncl *make_cond_incl(bool wastrue) {\n    CondIncl *r = calloc(1, sizeof(CondIncl));\n    r->ctx = IN_THEN;\n    r->wastrue = wastrue;\n    return r;\n}\n\nstatic Macro *make_macro(Macro *tmpl) {\n    Macro *r = malloc(sizeof(Macro));\n    *r = *tmpl;\n    return r;\n}\n\nstatic Macro *make_obj_macro(Vector *body) {\n    return make_macro(&(Macro){ MACRO_OBJ, .body = body });\n}\n\nstatic Macro *make_func_macro(Vector *body, int nargs, bool is_varg) {\n    return make_macro(&(Macro){\n            MACRO_FUNC, .nargs = nargs, .body = body, .is_varg = is_varg });\n}\n\nstatic Macro *make_special_macro(SpecialMacroHandler *fn) {\n    return make_macro(&(Macro){ MACRO_SPECIAL, .fn = fn });\n}\n\nstatic Token *make_macro_token(int position, bool is_vararg) {\n    Token *r = malloc(sizeof(Token));\n    r->kind = TMACRO_PARAM;\n    r->is_vararg = is_vararg;\n    r->hideset = NULL;\n    r->position = position;\n    r->space = false;\n    r->bol = false;\n    return r;\n}\n\nstatic Token *copy_token(Token *tok) {\n    Token *r = malloc(sizeof(Token));\n    *r = *tok;\n    return r;\n}\n\nstatic void expect(char id) {\n    Token *tok = lex();\n    if (!is_keyword(tok, id))\n        errort(tok, \"%c expected, but got %s\", id, tok2s(tok));\n}\n\n/*\n * Utility functions\n */\n\nbool is_ident(Token *tok, char *s) {\n    return tok->kind == TIDENT && !strcmp(tok->sval, s);\n}\n\nstatic bool next(int id) {\n    Token *tok = lex();\n    if (is_keyword(tok, id))\n        return true;\n    unget_token(tok);\n    return false;\n}\n\nstatic void propagate_space(Vector *tokens, Token *tmpl) {\n    if (vec_len(tokens) == 0)\n        return;\n    Token *tok = copy_token(vec_head(tokens));\n    tok->space = tmpl->space;\n    vec_set(tokens, 0, tok);\n}\n\n/*\n * Macro expander\n */\n\nstatic Token *read_ident() {\n    Token *tok = lex();\n    if (tok->kind != TIDENT)\n        errort(tok, \"identifier expected, but got %s\", tok2s(tok));\n    return tok;\n}\n\nvoid expect_newline() {\n    Token *tok = lex();\n    if (tok->kind != TNEWLINE)\n        errort(tok, \"newline expected, but got %s\", tok2s(tok));\n}\n\nstatic Vector *read_one_arg(Token *ident, bool *end, bool readall) {\n    Vector *r = make_vector();\n    int level = 0;\n    for (;;) {\n        Token *tok = lex();\n        if (tok->kind == TEOF)\n            errort(ident, \"unterminated macro argument list\");\n        if (tok->kind == TNEWLINE)\n            continue;\n        if (tok->bol && is_keyword(tok, '#')) {\n            read_directive(tok);\n            continue;\n        }\n        if (level == 0 && is_keyword(tok, ')')) {\n            unget_token(tok);\n            *end = true;\n            return r;\n        }\n        if (level == 0 && is_keyword(tok, ',') && !readall)\n            return r;\n        if (is_keyword(tok, '('))\n            level++;\n        if (is_keyword(tok, ')'))\n            level--;\n        // C11 6.10.3p10: Within the macro argument list,\n        // newline is considered a normal whitespace character.\n        // I don't know why the standard specifies such a minor detail,\n        // but the difference of newline and space is observable\n        // if you stringize tokens using #.\n        if (tok->bol) {\n            tok = copy_token(tok);\n            tok->bol = false;\n            tok->space = true;\n        }\n        vec_push(r, tok);\n    }\n}\n\nstatic Vector *do_read_args(Token *ident, Macro *macro) {\n    Vector *r = make_vector();\n    bool end = false;\n    while (!end) {\n        bool in_ellipsis = (macro->is_varg && vec_len(r) + 1 == macro->nargs);\n        vec_push(r, read_one_arg(ident, &end, in_ellipsis));\n    }\n    if (macro->is_varg && vec_len(r) == macro->nargs - 1)\n        vec_push(r, make_vector());\n    return r;\n}\n\nstatic Vector *read_args(Token *tok, Macro *macro) {\n    if (macro->nargs == 0 && is_keyword(peek_token(), ')')) {\n        // If a macro M has no parameter, argument list of M()\n        // is an empty list. If it has one parameter,\n        // argument list of M() is a list containing an empty list.\n        return make_vector();\n    }\n    Vector *args = do_read_args(tok, macro);\n    if (vec_len(args) != macro->nargs)\n        errort(tok, \"macro argument number does not match\");\n    return args;\n}\n\nstatic Vector *add_hide_set(Vector *tokens, Set *hideset) {\n    Vector *r = make_vector();\n    for (int i = 0; i < vec_len(tokens); i++) {\n        Token *t = copy_token(vec_get(tokens, i));\n        t->hideset = set_union(t->hideset, hideset);\n        vec_push(r, t);\n    }\n    return r;\n}\n\nstatic Token *glue_tokens(Token *t, Token *u) {\n    Buffer *b = make_buffer();\n    buf_printf(b, \"%s\", tok2s(t));\n    buf_printf(b, \"%s\", tok2s(u));\n    Token *r = lex_string(buf_body(b));\n    return r;\n}\n\nstatic void glue_push(Vector *tokens, Token *tok) {\n    Token *last = vec_pop(tokens);\n    vec_push(tokens, glue_tokens(last, tok));\n}\n\nstatic Token *stringize(Token *tmpl, Vector *args) {\n    Buffer *b = make_buffer();\n    for (int i = 0; i < vec_len(args); i++) {\n        Token *tok = vec_get(args, i);\n        if (buf_len(b) && tok->space)\n            buf_printf(b, \" \");\n        buf_printf(b, \"%s\", tok2s(tok));\n    }\n    buf_write(b, '\\0');\n    Token *r = copy_token(tmpl);\n    r->kind = TSTRING;\n    r->sval = buf_body(b);\n    r->slen = buf_len(b);\n    r->enc = ENC_NONE;\n    return r;\n}\n\nstatic Vector *expand_all(Vector *tokens, Token *tmpl) {\n    token_buffer_stash(vec_reverse(tokens));\n    Vector *r = make_vector();\n    for (;;) {\n        Token *tok = read_expand();\n        if (tok->kind == TEOF)\n            break;\n        vec_push(r, tok);\n    }\n    propagate_space(r, tmpl);\n    token_buffer_unstash();\n    return r;\n}\n\nstatic Vector *subst(Macro *macro, Vector *args, Set *hideset) {\n    Vector *r = make_vector();\n    int len = vec_len(macro->body);\n    for (int i = 0; i < len; i++) {\n        Token *t0 = vec_get(macro->body, i);\n        Token *t1 = (i == len - 1) ? NULL : vec_get(macro->body, i + 1);\n        bool t0_param = (t0->kind == TMACRO_PARAM);\n        bool t1_param = (t1 && t1->kind == TMACRO_PARAM);\n\n        if (is_keyword(t0, '#') && t1_param) {\n            vec_push(r, stringize(t0, vec_get(args, t1->position)));\n            i++;\n            continue;\n        }\n        if (is_keyword(t0, KHASHHASH) && t1_param) {\n            Vector *arg = vec_get(args, t1->position);\n            // [GNU] [,##__VA_ARG__] is expanded to the empty token sequence\n            // if __VA_ARG__ is empty. Otherwise it's expanded to\n            // [,<tokens in __VA_ARG__>].\n            if (t1->is_vararg && vec_len(r) > 0 && is_keyword(vec_tail(r), ',')) {\n                if (vec_len(arg) > 0)\n                    vec_append(r, arg);\n                else\n                    vec_pop(r);\n            } else if (vec_len(arg) > 0) {\n                glue_push(r, vec_head(arg));\n                for (int i = 1; i < vec_len(arg); i++)\n                    vec_push(r, vec_get(arg, i));\n            }\n            i++;\n            continue;\n        }\n        if (is_keyword(t0, KHASHHASH) && t1) {\n            hideset = t1->hideset;\n            glue_push(r, t1);\n            i++;\n            continue;\n        }\n        if (t0_param && t1 && is_keyword(t1, KHASHHASH)) {\n            hideset = t1->hideset;\n            Vector *arg = vec_get(args, t0->position);\n            if (vec_len(arg) == 0)\n                i++;\n            else\n                vec_append(r, arg);\n            continue;\n        }\n        if (t0_param) {\n            Vector *arg = vec_get(args, t0->position);\n            vec_append(r, expand_all(arg, t0));\n            continue;\n        }\n        vec_push(r, t0);\n    }\n    return add_hide_set(r, hideset);\n}\n\nstatic void unget_all(Vector *tokens) {\n    for (int i = vec_len(tokens) - 1; i >= 0; i--)\n        unget_token(vec_get(tokens, i));\n}\n\n// This is \"expand\" function in the Dave Prosser's document.\nstatic Token *read_expand_newline() {\n    Token *tok = lex();\n    if (tok->kind != TIDENT)\n        return tok;\n    char *name = tok->sval;\n    Macro *macro = map_get(macros, name);\n    if (!macro || set_has(tok->hideset, name))\n        return tok;\n\n    switch (macro->kind) {\n    case MACRO_OBJ: {\n        Set *hideset = set_add(tok->hideset, name);\n        Vector *tokens = subst(macro, NULL, hideset);\n        propagate_space(tokens, tok);\n        unget_all(tokens);\n        return read_expand();\n    }\n    case MACRO_FUNC: {\n        if (!next('('))\n            return tok;\n        Vector *args = read_args(tok, macro);\n        Token *rparen = peek_token();\n        expect(')');\n        Set *hideset = set_add(set_intersection(tok->hideset, rparen->hideset), name);\n        Vector *tokens = subst(macro, args, hideset);\n        propagate_space(tokens, tok);\n        unget_all(tokens);\n        return read_expand();\n    }\n    case MACRO_SPECIAL:\n        macro->fn(tok);\n        return read_expand();\n    default:\n        error(\"internal error\");\n    }\n}\n\nstatic Token *read_expand() {\n    for (;;) {\n        Token *tok = read_expand_newline();\n        if (tok->kind != TNEWLINE)\n            return tok;\n    }\n}\n\nstatic bool read_funclike_macro_params(Token *name, Map *param) {\n    int pos = 0;\n    for (;;) {\n        Token *tok = lex();\n        if (is_keyword(tok, ')'))\n            return false;\n        if (pos) {\n            if (!is_keyword(tok, ','))\n                errort(tok, \", expected, but got %s\", tok2s(tok));\n            tok = lex();\n        }\n        if (tok->kind == TNEWLINE)\n            errort(name, \"missing ')' in macro parameter list\");\n        if (is_keyword(tok, KELLIPSIS)) {\n            map_put(param, \"__VA_ARGS__\", make_macro_token(pos++, true));\n            expect(')');\n            return true;\n        }\n        if (tok->kind != TIDENT)\n            errort(tok, \"identifier expected, but got %s\", tok2s(tok));\n        char *arg = tok->sval;\n        if (next(KELLIPSIS)) {\n            expect(')');\n            map_put(param, arg, make_macro_token(pos++, true));\n            return true;\n        }\n        map_put(param, arg, make_macro_token(pos++, false));\n    }\n}\n\nstatic void hashhash_check(Vector *v) {\n    if (vec_len(v) == 0)\n        return;\n    if (is_keyword(vec_head(v), KHASHHASH))\n        errort(vec_head(v), \"'##' cannot appear at start of macro expansion\");\n    if (is_keyword(vec_tail(v), KHASHHASH))\n        errort(vec_tail(v), \"'##' cannot appear at end of macro expansion\");\n}\n\nstatic Vector *read_funclike_macro_body(Map *param) {\n    Vector *r = make_vector();\n    for (;;) {\n        Token *tok = lex();\n        if (tok->kind == TNEWLINE)\n            return r;\n        if (tok->kind == TIDENT) {\n            Token *subst = map_get(param, tok->sval);\n            if (subst) {\n                subst = copy_token(subst);\n                subst->space = tok->space;\n                vec_push(r, subst);\n                continue;\n            }\n        }\n        vec_push(r, tok);\n    }\n}\n\nstatic void read_funclike_macro(Token *name) {\n    Map *param = make_map();\n    bool is_varg = read_funclike_macro_params(name, param);\n    Vector *body = read_funclike_macro_body(param);\n    hashhash_check(body);\n    Macro *macro = make_func_macro(body, map_len(param), is_varg);\n    map_put(macros, name->sval, macro);\n}\n\nstatic void read_obj_macro(char *name) {\n    Vector *body = make_vector();\n    for (;;) {\n        Token *tok = lex();\n        if (tok->kind == TNEWLINE)\n            break;\n        vec_push(body, tok);\n    }\n    hashhash_check(body);\n    map_put(macros, name, make_obj_macro(body));\n}\n\n/*\n * #define\n */\n\nstatic void read_define() {\n    Token *name = read_ident();\n    Token *tok = lex();\n    if (is_keyword(tok, '(') && !tok->space) {\n        read_funclike_macro(name);\n        return;\n    }\n    unget_token(tok);\n    read_obj_macro(name->sval);\n}\n\n/*\n * #undef\n */\n\nstatic void read_undef() {\n    Token *name = read_ident();\n    expect_newline();\n    map_remove(macros, name->sval);\n}\n\n/*\n * #if and the like\n */\n\nstatic Token *read_defined_op() {\n    Token *tok = lex();\n    if (is_keyword(tok, '(')) {\n        tok = lex();\n        expect(')');\n    }\n    if (tok->kind != TIDENT)\n        errort(tok, \"identifier expected, but got %s\", tok2s(tok));\n    return map_get(macros, tok->sval) ? cpp_token_one : cpp_token_zero;\n}\n\nstatic Vector *read_intexpr_line() {\n    Vector *r = make_vector();\n    for (;;) {\n        Token *tok = read_expand_newline();\n        if (tok->kind == TNEWLINE)\n            return r;\n        if (is_ident(tok, \"defined\")) {\n            vec_push(r, read_defined_op());\n        } else if (tok->kind == TIDENT) {\n            // C11 6.10.1.4 says that remaining identifiers\n            // should be replaced with pp-number 0.\n            vec_push(r, cpp_token_zero);\n        } else {\n            vec_push(r, tok);\n        }\n    }\n}\n\nstatic bool read_constexpr() {\n    token_buffer_stash(vec_reverse(read_intexpr_line()));\n    Node *expr = read_expr();\n    Token *tok = lex();\n    if (tok->kind != TEOF)\n        errort(tok, \"stray token: %s\", tok2s(tok));\n    token_buffer_unstash();\n    return eval_intexpr(expr, NULL);\n}\n\nstatic void do_read_if(bool istrue) {\n    vec_push(cond_incl_stack, make_cond_incl(istrue));\n    if (!istrue)\n        skip_cond_incl();\n}\n\nstatic void read_if() {\n    do_read_if(read_constexpr());\n}\n\nstatic void read_ifdef() {\n    Token *tok = lex();\n    if (tok->kind != TIDENT)\n        errort(tok, \"identifier expected, but got %s\", tok2s(tok));\n    expect_newline();\n    do_read_if(map_get(macros, tok->sval));\n}\n\nstatic void read_ifndef() {\n    Token *tok = lex();\n    if (tok->kind != TIDENT)\n        errort(tok, \"identifier expected, but got %s\", tok2s(tok));\n    expect_newline();\n    do_read_if(!map_get(macros, tok->sval));\n    if (tok->count == 2) {\n        // \"ifndef\" is the second token in this file.\n        // Prepare to detect an include guard.\n        CondIncl *ci = vec_tail(cond_incl_stack);\n        ci->include_guard = tok->sval;\n        ci->file = tok->file;\n    }\n}\n\nstatic void read_else(Token *hash) {\n    if (vec_len(cond_incl_stack) == 0)\n        errort(hash, \"stray #else\");\n    CondIncl *ci = vec_tail(cond_incl_stack);\n    if (ci->ctx == IN_ELSE)\n        errort(hash, \"#else appears in #else\");\n    expect_newline();\n    ci->ctx = IN_ELSE;\n    ci->include_guard = NULL;\n    if (ci->wastrue)\n        skip_cond_incl();\n}\n\nstatic void read_elif(Token *hash) {\n    if (vec_len(cond_incl_stack) == 0)\n        errort(hash, \"stray #elif\");\n    CondIncl *ci = vec_tail(cond_incl_stack);\n    if (ci->ctx == IN_ELSE)\n        errort(hash, \"#elif after #else\");\n    ci->ctx = IN_ELIF;\n    ci->include_guard = NULL;\n    if (ci->wastrue || !read_constexpr()) {\n        skip_cond_incl();\n        return;\n    }\n    ci->wastrue = true;\n}\n\n// Skips all newlines and returns the first non-newline token.\nstatic Token *skip_newlines() {\n    Token *tok = lex();\n    while (tok->kind == TNEWLINE)\n        tok = lex();\n    unget_token(tok);\n    return tok;\n}\n\nstatic void read_endif(Token *hash) {\n    if (vec_len(cond_incl_stack) == 0)\n        errort(hash, \"stray #endif\");\n    CondIncl *ci = vec_pop(cond_incl_stack);\n    expect_newline();\n\n    // Detect an #ifndef and #endif pair that guards the entire\n    // header file. Remember the macro name guarding the file\n    // so that we can skip the file next time.\n    if (!ci->include_guard || ci->file != hash->file)\n        return;\n    Token *last = skip_newlines();\n    if (ci->file != last->file)\n        map_put(include_guard, ci->file->name, ci->include_guard);\n}\n\n/*\n * #error and #warning\n */\n\nstatic char *read_error_message() {\n    Buffer *b = make_buffer();\n    for (;;) {\n        Token *tok = lex();\n        if (tok->kind == TNEWLINE)\n            return buf_body(b);\n        if (buf_len(b) != 0 && tok->space)\n            buf_write(b, ' ');\n        buf_printf(b, \"%s\", tok2s(tok));\n    }\n}\n\nstatic void read_error(Token *hash) {\n    errort(hash, \"#error: %s\", read_error_message());\n}\n\nstatic void read_warning(Token *hash) {\n    warnt(hash, \"#warning: %s\", read_error_message());\n}\n\n/*\n * #include\n */\n\nstatic char *join_paths(Vector *args) {\n    Buffer *b = make_buffer();\n    for (int i = 0; i < vec_len(args); i++)\n        buf_printf(b, \"%s\", tok2s(vec_get(args, i)));\n    return buf_body(b);\n}\n\nstatic char *read_cpp_header_name(Token *hash, bool *std) {\n    // Try reading a filename using a special tokenizer for #include.\n    char *path = read_header_file_name(std);\n    if (path)\n        return path;\n\n    // If a token following #include does not start with < nor \",\n    // try to read the token as a regular token. Macro-expanded\n    // form may be a valid header file path.\n    Token *tok = read_expand_newline();\n    if (tok->kind == TNEWLINE)\n        errort(hash, \"expected filename, but got newline\");\n    if (tok->kind == TSTRING) {\n        *std = false;\n        return tok->sval;\n    }\n    if (!is_keyword(tok, '<'))\n        errort(tok, \"< expected, but got %s\", tok2s(tok));\n    Vector *tokens = make_vector();\n    for (;;) {\n        Token *tok = read_expand_newline();\n        if (tok->kind == TNEWLINE)\n            errort(hash, \"premature end of header name\");\n        if (is_keyword(tok, '>'))\n            break;\n        vec_push(tokens, tok);\n    }\n    *std = true;\n    return join_paths(tokens);\n}\n\nstatic bool guarded(char *path) {\n    char *guard = map_get(include_guard, path);\n    bool r = (guard && map_get(macros, guard));\n    define_obj_macro(\"__8cc_include_guard\", r ? cpp_token_one : cpp_token_zero);\n    return r;\n}\n\nstatic bool try_include(char *dir, char *filename, bool isimport) {\n    char *path = fullpath(format(\"%s/%s\", dir, filename));\n    if (map_get(once, path))\n        return true;\n    if (guarded(path))\n        return true;\n    FILE *fp = fopen(path, \"r\");\n    if (!fp)\n        return false;\n    if (isimport)\n        map_put(once, path, (void *)1);\n    stream_push(make_file(fp, path));\n    return true;\n}\n\nstatic void read_include(Token *hash, File *file, bool isimport) {\n    bool std;\n    char *filename = read_cpp_header_name(hash, &std);\n    expect_newline();\n    if (filename[0] == '/') {\n        if (try_include(\"/\", filename, isimport))\n            return;\n        goto err;\n    }\n    if (!std) {\n        char *dir = file->name ? dirname(strdup(file->name)) : \".\";\n        if (try_include(dir, filename, isimport))\n            return;\n    }\n    for (int i = 0; i < vec_len(std_include_path); i++)\n        if (try_include(vec_get(std_include_path, i), filename, isimport))\n            return;\n  err:\n    errort(hash, \"cannot find header file: %s\", filename);\n}\n\nstatic void read_include_next(Token *hash, File *file) {\n    // [GNU] #include_next is a directive to include the \"next\" file\n    // from the search path. This feature is used to override a\n    // header file without getting into infinite inclusion loop.\n    // This directive doesn't distinguish <> and \"\".\n    bool std;\n    char *filename = read_cpp_header_name(hash, &std);\n    expect_newline();\n    if (filename[0] == '/') {\n        if (try_include(\"/\", filename, false))\n            return;\n        goto err;\n    }\n    char *cur = fullpath(file->name);\n    int i = 0;\n    for (; i < vec_len(std_include_path); i++) {\n        char *dir = vec_get(std_include_path, i);\n        if (!strcmp(cur, fullpath(format(\"%s/%s\", dir, filename))))\n            break;\n    }\n    for (i++; i < vec_len(std_include_path); i++)\n        if (try_include(vec_get(std_include_path, i), filename, false))\n            return;\n  err:\n    errort(hash, \"cannot find header file: %s\", filename);\n}\n\n/*\n * #pragma\n */\n\nstatic void parse_pragma_operand(Token *tok) {\n    char *s = tok->sval;\n    if (!strcmp(s, \"once\")) {\n        char *path = fullpath(tok->file->name);\n        map_put(once, path, (void *)1);\n    } else if (!strcmp(s, \"enable_warning\")) {\n        enable_warning = true;\n    } else if (!strcmp(s, \"disable_warning\")) {\n        enable_warning = false;\n    } else {\n        errort(tok, \"unknown #pragma: %s\", s);\n    }\n}\n\nstatic void read_pragma() {\n    Token *tok = read_ident();\n    parse_pragma_operand(tok);\n}\n\n/*\n * #line\n */\n\nstatic bool is_digit_sequence(char *p) {\n    for (; *p; p++)\n        if (!isdigit(*p))\n            return false;\n    return true;\n}\n\nstatic void read_line() {\n    Token *tok = read_expand_newline();\n    if (tok->kind != TNUMBER || !is_digit_sequence(tok->sval))\n        errort(tok, \"number expected after #line, but got %s\", tok2s(tok));\n    int line = atoi(tok->sval);\n    tok = read_expand_newline();\n    char *filename = NULL;\n    if (tok->kind == TSTRING) {\n        filename = tok->sval;\n        expect_newline();\n    } else if (tok->kind != TNEWLINE) {\n        errort(tok, \"newline or a source name are expected, but got %s\", tok2s(tok));\n    }\n    File *f = current_file();\n    f->line = line;\n    if (filename)\n        f->name = filename;\n}\n\n// GNU CPP outputs \"# linenum filename flags\" to preserve original\n// source file information. This function reads them. Flags are ignored.\nstatic void read_linemarker(Token *tok) {\n    if (!is_digit_sequence(tok->sval))\n        errort(tok, \"line number expected, but got %s\", tok2s(tok));\n    int line = atoi(tok->sval);\n    tok = lex();\n    if (tok->kind != TSTRING)\n        errort(tok, \"filename expected, but got %s\", tok2s(tok));\n    char *filename = tok->sval;\n    do {\n        tok = lex();\n    } while (tok->kind != TNEWLINE);\n    File *file = current_file();\n    file->line = line;\n    file->name = filename;\n}\n\n/*\n * #-directive\n */\n\nstatic void read_directive(Token *hash) {\n    Token *tok = lex();\n    if (tok->kind == TNEWLINE)\n        return;\n    if (tok->kind == TNUMBER) {\n        read_linemarker(tok);\n        return;\n    }\n    if (tok->kind != TIDENT)\n        goto err;\n    char *s = tok->sval;\n    if (!strcmp(s, \"define\"))            read_define();\n    else if (!strcmp(s, \"elif\"))         read_elif(hash);\n    else if (!strcmp(s, \"else\"))         read_else(hash);\n    else if (!strcmp(s, \"endif\"))        read_endif(hash);\n    else if (!strcmp(s, \"error\"))        read_error(hash);\n    else if (!strcmp(s, \"if\"))           read_if();\n    else if (!strcmp(s, \"ifdef\"))        read_ifdef();\n    else if (!strcmp(s, \"ifndef\"))       read_ifndef();\n    else if (!strcmp(s, \"import\"))       read_include(hash, tok->file, true);\n    else if (!strcmp(s, \"include\"))      read_include(hash, tok->file, false);\n    else if (!strcmp(s, \"include_next\")) read_include_next(hash, tok->file);\n    else if (!strcmp(s, \"line\"))         read_line();\n    else if (!strcmp(s, \"pragma\"))       read_pragma();\n    else if (!strcmp(s, \"undef\"))        read_undef();\n    else if (!strcmp(s, \"warning\"))      read_warning(hash);\n    else goto err;\n    return;\n\n  err:\n    errort(hash, \"unsupported preprocessor directive: %s\", tok2s(tok));\n}\n\n/*\n * Special macros\n */\n\nstatic void make_token_pushback(Token *tmpl, int kind, char *sval) {\n    Token *tok = copy_token(tmpl);\n    tok->kind = kind;\n    tok->sval = sval;\n    tok->slen = strlen(sval) + 1;\n    tok->enc = ENC_NONE;\n    unget_token(tok);\n}\n\nstatic void handle_date_macro(Token *tmpl) {\n    char buf[20];\n    strftime(buf, sizeof(buf), \"%b %e %Y\", &now);\n    make_token_pushback(tmpl, TSTRING, strdup(buf));\n}\n\nstatic void handle_time_macro(Token *tmpl) {\n    char buf[10];\n    strftime(buf, sizeof(buf), \"%T\", &now);\n    make_token_pushback(tmpl, TSTRING, strdup(buf));\n}\n\nstatic void handle_timestamp_macro(Token *tmpl) {\n    // [GNU] __TIMESTAMP__ is expanded to a string that describes the date\n    // and time of the last modification time of the current source file.\n    char buf[30];\n    strftime(buf, sizeof(buf), \"%a %b %e %T %Y\", localtime(&tmpl->file->mtime));\n    make_token_pushback(tmpl, TSTRING, strdup(buf));\n}\n\nstatic void handle_file_macro(Token *tmpl) {\n    make_token_pushback(tmpl, TSTRING, tmpl->file->name);\n}\n\nstatic void handle_line_macro(Token *tmpl) {\n    make_token_pushback(tmpl, TNUMBER, format(\"%d\", tmpl->file->line));\n}\n\nstatic void handle_pragma_macro(Token *tmpl) {\n    expect('(');\n    Token *operand = read_token();\n    if (operand->kind != TSTRING)\n        errort(operand, \"_Pragma takes a string literal, but got %s\", tok2s(operand));\n    expect(')');\n    parse_pragma_operand(operand);\n    make_token_pushback(tmpl, TNUMBER, \"1\");\n}\n\nstatic void handle_base_file_macro(Token *tmpl) {\n    make_token_pushback(tmpl, TSTRING, get_base_file());\n}\n\nstatic void handle_counter_macro(Token *tmpl) {\n    static int counter = 0;\n    make_token_pushback(tmpl, TNUMBER, format(\"%d\", counter++));\n}\n\nstatic void handle_include_level_macro(Token *tmpl) {\n    make_token_pushback(tmpl, TNUMBER, format(\"%d\", stream_depth() - 1));\n}\n\n/*\n * Initializer\n */\n\nvoid add_include_path(char *path) {\n    vec_push(std_include_path, path);\n}\n\nstatic void define_obj_macro(char *name, Token *value) {\n    map_put(macros, name, make_obj_macro(make_vector1(value)));\n}\n\nstatic void define_special_macro(char *name, SpecialMacroHandler *fn) {\n    map_put(macros, name, make_special_macro(fn));\n}\n\nstatic void init_keywords() {\n#define op(id, str)         map_put(keywords, str, (void *)id);\n#define keyword(id, str, _) map_put(keywords, str, (void *)id);\n#include \"keyword.inc\"\n#undef keyword\n#undef op\n}\n\nstatic void init_predefined_macros() {\n    vec_push(std_include_path, BUILD_DIR \"/include\");\n    vec_push(std_include_path, \"/usr/local/lib/8cc/include\");\n    vec_push(std_include_path, \"/usr/local/include\");\n    vec_push(std_include_path, \"/usr/include\");\n    vec_push(std_include_path, \"/usr/include/linux\");\n    vec_push(std_include_path, \"/usr/include/x86_64-linux-gnu\");\n\n    define_special_macro(\"__DATE__\", handle_date_macro);\n    define_special_macro(\"__TIME__\", handle_time_macro);\n    define_special_macro(\"__FILE__\", handle_file_macro);\n    define_special_macro(\"__LINE__\", handle_line_macro);\n    define_special_macro(\"_Pragma\",  handle_pragma_macro);\n    // [GNU] Non-standard macros\n    define_special_macro(\"__BASE_FILE__\", handle_base_file_macro);\n    define_special_macro(\"__COUNTER__\", handle_counter_macro);\n    define_special_macro(\"__INCLUDE_LEVEL__\", handle_include_level_macro);\n    define_special_macro(\"__TIMESTAMP__\", handle_timestamp_macro);\n\n    read_from_string(\"#include <\" BUILD_DIR \"/include/8cc.h>\");\n}\n\nvoid init_now() {\n    time_t timet = time(NULL);\n    localtime_r(&timet, &now);\n}\n\nvoid cpp_init() {\n    setlocale(LC_ALL, \"C\");\n    init_keywords();\n    init_now();\n    init_predefined_macros();\n}\n\n/*\n * Public intefaces\n */\n\nstatic Token *maybe_convert_keyword(Token *tok) {\n    if (tok->kind != TIDENT)\n        return tok;\n    int id = (intptr_t)map_get(keywords, tok->sval);\n    if (!id)\n        return tok;\n    Token *r = copy_token(tok);\n    r->kind = TKEYWORD;\n    r->id = id;\n    return r;\n}\n\n// Reads from a string as if the string is a content of input file.\n// Convenient for evaluating small string snippet contaiing preprocessor macros.\nvoid read_from_string(char *buf) {\n    stream_stash(make_file_string(buf));\n    Vector *toplevels = read_toplevels();\n    for (int i = 0; i < vec_len(toplevels); i++)\n        emit_toplevel(vec_get(toplevels, i));\n    stream_unstash();\n}\n\nToken *peek_token() {\n    Token *r = read_token();\n    unget_token(r);\n    return r;\n}\n\nToken *read_token() {\n    Token *tok;\n    for (;;) {\n        tok = read_expand();\n        if (tok->bol && is_keyword(tok, '#') && tok->hideset == NULL) {\n            read_directive(tok);\n            continue;\n        }\n        assert(tok->kind < MIN_CPP_TOKEN);\n        return maybe_convert_keyword(tok);\n    }\n}\n"
        },
        {
          "name": "debug.c",
          "type": "blob",
          "size": 10.0537109375,
          "content": "// Copyright 2012 Rui Ueyama. Released under the MIT license.\n\n#include \"8cc.h\"\n\nstatic char *decorate_int(char *name, Type *ty) {\n    char *u = (ty->usig) ? \"u\" : \"\";\n    if (ty->bitsize > 0)\n        return format(\"%s%s:%d:%d\", u, name, ty->bitoff, ty->bitoff + ty->bitsize);\n    return format(\"%s%s\", u, name);\n}\n\nstatic char *do_ty2s(Dict *dict, Type *ty) {\n    if (!ty)\n        return \"(nil)\";\n    switch (ty->kind) {\n    case KIND_VOID: return \"void\";\n    case KIND_BOOL: return \"_Bool\";\n    case KIND_CHAR: return decorate_int(\"char\", ty);\n    case KIND_SHORT: return decorate_int(\"short\", ty);\n    case KIND_INT:  return decorate_int(\"int\", ty);\n    case KIND_LONG: return decorate_int(\"long\", ty);\n    case KIND_LLONG: return decorate_int(\"llong\", ty);\n    case KIND_FLOAT: return \"float\";\n    case KIND_DOUBLE: return \"double\";\n    case KIND_LDOUBLE: return \"long double\";\n    case KIND_PTR:\n        return format(\"*%s\", do_ty2s(dict, ty->ptr));\n    case KIND_ARRAY:\n        return format(\"[%d]%s\", ty->len, do_ty2s(dict, ty->ptr));\n    case KIND_STRUCT: {\n        char *kind = ty->is_struct ? \"struct\" : \"union\";\n        if (dict_get(dict, format(\"%p\", ty)))\n            return format(\"(%s)\", kind);\n        dict_put(dict, format(\"%p\", ty), (void *)1);\n        if (ty->fields) {\n            Buffer *b = make_buffer();\n            buf_printf(b, \"(%s\", kind);\n            Vector *keys = dict_keys(ty->fields);\n            for (int i = 0; i < vec_len(keys); i++) {\n                char *key = vec_get(keys, i);\n                Type *fieldtype = dict_get(ty->fields, key);\n                buf_printf(b, \" (%s)\", do_ty2s(dict, fieldtype));\n            }\n            buf_printf(b, \")\");\n            return buf_body(b);\n        }\n    }\n    case KIND_FUNC: {\n        Buffer *b = make_buffer();\n        buf_printf(b, \"(\");\n        if (ty->params) {\n            for (int i = 0; i < vec_len(ty->params); i++) {\n                if (i > 0)\n                    buf_printf(b, \",\");\n                Type *t = vec_get(ty->params, i);\n                buf_printf(b, \"%s\", do_ty2s(dict, t));\n            }\n        }\n        buf_printf(b, \")=>%s\", do_ty2s(dict, ty->rettype));\n        return buf_body(b);\n    }\n    default:\n        return format(\"(Unknown ty: %d)\", ty->kind);\n    }\n}\n\nchar *ty2s(Type *ty) {\n    return do_ty2s(make_dict(), ty);\n}\n\nstatic void uop_to_string(Buffer *b, char *op, Node *node) {\n    buf_printf(b, \"(%s %s)\", op, node2s(node->operand));\n}\n\nstatic void binop_to_string(Buffer *b, char *op, Node *node) {\n    buf_printf(b, \"(%s %s %s)\", op, node2s(node->left), node2s(node->right));\n}\n\nstatic void a2s_declinit(Buffer *b, Vector *initlist) {\n    for (int i = 0; i < vec_len(initlist); i++) {\n        if (i > 0)\n            buf_printf(b, \" \");\n        Node *init = vec_get(initlist, i);\n        buf_printf(b, \"%s\", node2s(init));\n    }\n}\n\nstatic void do_node2s(Buffer *b, Node *node) {\n    if (!node) {\n        buf_printf(b, \"(nil)\");\n        return;\n    }\n    switch (node->kind) {\n    case AST_LITERAL:\n        switch (node->ty->kind) {\n        case KIND_CHAR:\n            if (node->ival == '\\n')      buf_printf(b, \"'\\n'\");\n            else if (node->ival == '\\\\') buf_printf(b, \"'\\\\\\\\'\");\n            else if (node->ival == '\\0') buf_printf(b, \"'\\\\0'\");\n            else buf_printf(b, \"'%c'\", node->ival);\n            break;\n        case KIND_INT:\n            buf_printf(b, \"%d\", node->ival);\n            break;\n        case KIND_LONG:\n            buf_printf(b, \"%ldL\", node->ival);\n            break;\n        case KIND_LLONG:\n            buf_printf(b, \"%lldL\", node->ival);\n            break;\n        case KIND_FLOAT:\n        case KIND_DOUBLE:\n        case KIND_LDOUBLE:\n            buf_printf(b, \"%f\", node->fval);\n            break;\n        case KIND_ARRAY:\n            buf_printf(b, \"\\\"%s\\\"\", quote_cstring(node->sval));\n            break;\n        default:\n            error(\"internal error\");\n        }\n        break;\n    case AST_LABEL:\n        buf_printf(b, \"%s:\", node->label);\n        break;\n    case AST_LVAR:\n        buf_printf(b, \"lv=%s\", node->varname);\n        if (node->lvarinit) {\n            buf_printf(b, \"(\");\n            a2s_declinit(b, node->lvarinit);\n            buf_printf(b, \")\");\n        }\n        break;\n    case AST_GVAR:\n        buf_printf(b, \"gv=%s\", node->varname);\n        break;\n    case AST_FUNCALL:\n    case AST_FUNCPTR_CALL: {\n        buf_printf(b, \"(%s)%s(\", ty2s(node->ty),\n                   node->kind == AST_FUNCALL ? node->fname : node2s(node));\n        for (int i = 0; i < vec_len(node->args); i++) {\n            if (i > 0)\n                buf_printf(b, \",\");\n            buf_printf(b, \"%s\", node2s(vec_get(node->args, i)));\n        }\n        buf_printf(b, \")\");\n        break;\n    }\n    case AST_FUNCDESG: {\n        buf_printf(b, \"(funcdesg %s)\", node->fname);\n        break;\n    }\n    case AST_FUNC: {\n        buf_printf(b, \"(%s)%s(\", ty2s(node->ty), node->fname);\n        for (int i = 0; i < vec_len(node->params); i++) {\n            if (i > 0)\n                buf_printf(b, \",\");\n            Node *param = vec_get(node->params, i);\n            buf_printf(b, \"%s %s\", ty2s(param->ty), node2s(param));\n        }\n        buf_printf(b, \")\");\n        do_node2s(b, node->body);\n        break;\n    }\n    case AST_GOTO:\n        buf_printf(b, \"goto(%s)\", node->label);\n        break;\n    case AST_DECL:\n        buf_printf(b, \"(decl %s %s\",\n                   ty2s(node->declvar->ty),\n                   node->declvar->varname);\n        if (node->declinit) {\n            buf_printf(b, \" \");\n            a2s_declinit(b, node->declinit);\n        }\n        buf_printf(b, \")\");\n        break;\n    case AST_INIT:\n        buf_printf(b, \"%s@%d\", node2s(node->initval), node->initoff, ty2s(node->totype));\n        break;\n    case AST_CONV:\n        buf_printf(b, \"(conv %s=>%s)\", node2s(node->operand), ty2s(node->ty));\n        break;\n    case AST_IF:\n        buf_printf(b, \"(if %s %s\",\n                   node2s(node->cond),\n                   node2s(node->then));\n        if (node->els)\n            buf_printf(b, \" %s\", node2s(node->els));\n        buf_printf(b, \")\");\n        break;\n    case AST_TERNARY:\n        buf_printf(b, \"(? %s %s %s)\",\n                   node2s(node->cond),\n                   node2s(node->then),\n                   node2s(node->els));\n        break;\n    case AST_RETURN:\n        buf_printf(b, \"(return %s)\", node2s(node->retval));\n        break;\n    case AST_COMPOUND_STMT: {\n        buf_printf(b, \"{\");\n        for (int i = 0; i < vec_len(node->stmts); i++) {\n            do_node2s(b, vec_get(node->stmts, i));\n            buf_printf(b, \";\");\n        }\n        buf_printf(b, \"}\");\n        break;\n    }\n    case AST_STRUCT_REF:\n        do_node2s(b, node->struc);\n        buf_printf(b, \".\");\n        buf_printf(b, node->field);\n        break;\n    case AST_ADDR:  uop_to_string(b, \"addr\", node); break;\n    case AST_DEREF: uop_to_string(b, \"deref\", node); break;\n    case OP_SAL:  binop_to_string(b, \"<<\", node); break;\n    case OP_SAR:\n    case OP_SHR:  binop_to_string(b, \">>\", node); break;\n    case OP_GE:  binop_to_string(b, \">=\", node); break;\n    case OP_LE:  binop_to_string(b, \"<=\", node); break;\n    case OP_NE:  binop_to_string(b, \"!=\", node); break;\n    case OP_PRE_INC: uop_to_string(b, \"pre++\", node); break;\n    case OP_PRE_DEC: uop_to_string(b, \"pre--\", node); break;\n    case OP_POST_INC: uop_to_string(b, \"post++\", node); break;\n    case OP_POST_DEC: uop_to_string(b, \"post--\", node); break;\n    case OP_LOGAND: binop_to_string(b, \"and\", node); break;\n    case OP_LOGOR:  binop_to_string(b, \"or\", node); break;\n    case OP_A_ADD:  binop_to_string(b, \"+=\", node); break;\n    case OP_A_SUB:  binop_to_string(b, \"-=\", node); break;\n    case OP_A_MUL:  binop_to_string(b, \"*=\", node); break;\n    case OP_A_DIV:  binop_to_string(b, \"/=\", node); break;\n    case OP_A_MOD:  binop_to_string(b, \"%=\", node); break;\n    case OP_A_AND:  binop_to_string(b, \"&=\", node); break;\n    case OP_A_OR:   binop_to_string(b, \"|=\", node); break;\n    case OP_A_XOR:  binop_to_string(b, \"^=\", node); break;\n    case OP_A_SAL:  binop_to_string(b, \"<<=\", node); break;\n    case OP_A_SAR:\n    case OP_A_SHR:  binop_to_string(b, \">>=\", node); break;\n    case '!': uop_to_string(b, \"!\", node); break;\n    case '&': binop_to_string(b, \"&\", node); break;\n    case '|': binop_to_string(b, \"|\", node); break;\n    case OP_CAST: {\n        buf_printf(b, \"((%s)=>(%s) %s)\",\n                   ty2s(node->operand->ty),\n                   ty2s(node->ty),\n                   node2s(node->operand));\n        break;\n    }\n    case OP_LABEL_ADDR:\n        buf_printf(b, \"&&%s\", node->label);\n        break;\n    default: {\n        char *left = node2s(node->left);\n        char *right = node2s(node->right);\n        if (node->kind == OP_EQ)\n            buf_printf(b, \"(== \");\n        else\n            buf_printf(b, \"(%c \", node->kind);\n        buf_printf(b, \"%s %s)\", left, right);\n    }\n    }\n}\n\nchar *node2s(Node *node) {\n    Buffer *b = make_buffer();\n    do_node2s(b, node);\n    return buf_body(b);\n}\n\nstatic char *encoding_prefix(int enc) {\n    switch (enc) {\n    case ENC_CHAR16: return \"u\";\n    case ENC_CHAR32: return \"U\";\n    case ENC_UTF8:   return \"u8\";\n    case ENC_WCHAR:  return \"L\";\n    }\n    return \"\";\n}\n\nchar *tok2s(Token *tok) {\n    if (!tok)\n        return \"(null)\";\n    switch (tok->kind) {\n    case TIDENT:\n        return tok->sval;\n    case TKEYWORD:\n        switch (tok->id) {\n#define op(id, str)         case id: return str;\n#define keyword(id, str, _) case id: return str;\n#include \"keyword.inc\"\n#undef keyword\n#undef op\n        default: return format(\"%c\", tok->id);\n        }\n    case TCHAR:\n        return format(\"%s'%s'\",\n                      encoding_prefix(tok->enc),\n                      quote_char(tok->c));\n    case TNUMBER:\n        return tok->sval;\n    case TSTRING:\n        return format(\"%s\\\"%s\\\"\",\n                      encoding_prefix(tok->enc),\n                      quote_cstring(tok->sval));\n    case TEOF:\n        return \"(eof)\";\n    case TINVALID:\n        return format(\"%c\", tok->c);\n    case TNEWLINE:\n        return \"(newline)\";\n    case TSPACE:\n        return \"(space)\";\n    case TMACRO_PARAM:\n        return \"(macro-param)\";\n    }\n    error(\"internal error: unknown token kind: %d\", tok->kind);\n}\n"
        },
        {
          "name": "dict.c",
          "type": "blob",
          "size": 0.4677734375,
          "content": "// Copyright 2012 Rui Ueyama. Released under the MIT license.\n\n#include <stdlib.h>\n#include \"8cc.h\"\n\nDict *make_dict() {\n    Dict *r = malloc(sizeof(Dict));\n    r->map = make_map();\n    r->key = make_vector();\n    return r;\n}\n\nvoid *dict_get(Dict *dict, char *key) {\n    return map_get(dict->map, key);\n}\n\nvoid dict_put(Dict *dict, char *key, void *val) {\n    map_put(dict->map, key, val);\n    vec_push(dict->key, key);\n}\n\nVector *dict_keys(Dict *dict) {\n    return dict->key;\n}\n"
        },
        {
          "name": "encoding.c",
          "type": "blob",
          "size": 2.796875,
          "content": "// Copyright 2015 Rui Ueyama. Released under the MIT license.\n\n// This file defines functions to convert UTF-8 strings to UTF-16 or UTF-32.\n//\n// 8cc uses UTF-16 for string literals prefixed with u (char16_t strings).\n// UTF-32 is used for string literals prefixed with L or U\n// (wchar_t or char32_t strings).\n// Unprefixed or u8 strings are supposed to be in UTF-8 endcoding.\n// Source files are supposed to be written in UTF-8.\n\n#include \"8cc.h\"\n\nstatic int count_leading_ones(char c) {\n    for (int i = 7; i >= 0; i--)\n        if ((c & (1 << i)) == 0)\n            return 7 - i;\n    return 8;\n}\n\nstatic int read_rune(uint32_t *r, char *s, char *end) {\n    int len = count_leading_ones(s[0]);\n    if (len == 0) {\n        *r = s[0];\n        return 1;\n    }\n    if (s + len > end)\n        error(\"invalid UTF-8 sequence\");\n    for (int i = 1; i < len; i++)\n        if ((s[i] & 0xC0) != 0x80)\n            error(\"invalid UTF-8 continuation byte\");\n    switch (len) {\n    case 2:\n        *r = ((s[0] & 0x1F) << 6) | (s[1] & 0x3F);\n        return 2;\n    case 3:\n        *r = ((s[0] & 0xF) << 12) | ((s[1] & 0x3F) << 6) | (s[2] & 0x3F);\n        return 3;\n    case 4:\n        *r = ((s[0] & 0x7) << 18) | ((s[1] & 0x3F) << 12) | ((s[2] & 0x3F) << 6) | (s[3] & 0x3F);\n        return 4;\n    }\n    error(\"invalid UTF-8 sequence\");\n}\n\nstatic void write16(Buffer *b, uint16_t x) {\n    buf_write(b, x & 0xFF);\n    buf_write(b, x >> 8);\n}\n\nstatic void write32(Buffer *b, uint32_t x) {\n    write16(b, x & 0xFFFF);\n    write16(b, x >> 16);\n}\n\nBuffer *to_utf16(char *p, int len) {\n    Buffer *b = make_buffer();\n    char *end = p + len;\n    while (p != end) {\n        uint32_t rune;\n        p += read_rune(&rune, p, end);\n        if (rune < 0x10000) {\n            write16(b, rune);\n        } else {\n            write16(b, (rune >> 10) + 0xD7C0);\n            write16(b, (rune & 0x3FF) + 0xDC00);\n        }\n    }\n    return b;\n}\n\nBuffer *to_utf32(char *p, int len) {\n    Buffer *b = make_buffer();\n    char *end = p + len;\n    while (p != end) {\n        uint32_t rune;\n        p += read_rune(&rune, p, end);\n        write32(b, rune);\n    }\n    return b;\n}\n\nvoid write_utf8(Buffer *b, uint32_t rune) {\n    if (rune < 0x80) {\n        buf_write(b, rune);\n        return;\n    }\n    if (rune < 0x800) {\n        buf_write(b, 0xC0 | (rune >> 6));\n        buf_write(b, 0x80 | (rune & 0x3F));\n        return;\n    }\n    if (rune < 0x10000) {\n        buf_write(b, 0xE0 | (rune >> 12));\n        buf_write(b, 0x80 | ((rune >> 6) & 0x3F));\n        buf_write(b, 0x80 | (rune & 0x3F));\n        return;\n    }\n    if (rune < 0x200000) {\n        buf_write(b, 0xF0 | (rune >> 18));\n        buf_write(b, 0x80 | ((rune >> 12) & 0x3F));\n        buf_write(b, 0x80 | ((rune >> 6) & 0x3F));\n        buf_write(b, 0x80 | (rune & 0x3F));\n        return;\n    }\n    error(\"invalid UCS character: \\\\U%08x\", rune);\n}\n"
        },
        {
          "name": "error.c",
          "type": "blob",
          "size": 1.1396484375,
          "content": "// Copyright 2012 Rui Ueyama. Released under the MIT license.\n\n#include <stdarg.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include \"8cc.h\"\n\nbool enable_warning = true;\nbool warning_is_error = false;\n\nstatic void print_error(char *line, char *pos, char *label, char *fmt, va_list args) {\n    fprintf(stderr, isatty(fileno(stderr)) ? \"\\e[1;31m[%s]\\e[0m \" : \"[%s] \", label);\n    fprintf(stderr, \"%s: %s: \", line, pos);\n    vfprintf(stderr, fmt, args);\n    fprintf(stderr, \"\\n\");\n}\n\nvoid errorf(char *line, char *pos, char *fmt, ...) {\n    va_list args;\n    va_start(args, fmt);\n    print_error(line, pos, \"ERROR\", fmt, args);\n    va_end(args);\n    exit(1);\n}\n\nvoid warnf(char *line, char *pos, char *fmt, ...) {\n    if (!enable_warning)\n        return;\n    char *label = warning_is_error ? \"ERROR\" : \"WARN\";\n    va_list args;\n    va_start(args, fmt);\n    print_error(line, pos, label, fmt, args);\n    va_end(args);\n    if (warning_is_error)\n        exit(1);\n}\n\nchar *token_pos(Token *tok) {\n    File *f = tok->file;\n    if (!f)\n        return \"(unknown)\";\n    char *name = f->name ? f->name : \"(unknown)\";\n    return format(\"%s:%d:%d\", name, tok->line, tok->column);\n}\n"
        },
        {
          "name": "file.c",
          "type": "blob",
          "size": 3.50390625,
          "content": "// Copyright 2014 Rui Ueyama. Released under the MIT license.\n\n/*\n * This file provides character input stream for C source code.\n * An input stream is either backed by stdio's FILE * or\n * backed by a string.\n * The following input processing is done at this stage.\n *\n * - C11 5.1.1.2p1: \"\\r\\n\" or \"\\r\" are canonicalized to \"\\n\".\n * - C11 5.1.1.2p2: A sequence of backslash and newline is removed.\n * - EOF not immediately following a newline is converted to\n *   a sequence of newline and EOF. (The C spec requires source\n *   files end in a newline character (5.1.1.2p2). Thus, if all\n *   source files are comforming, this step wouldn't be needed.)\n *\n * Trigraphs are not supported by design.\n */\n\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include \"8cc.h\"\n\nstatic Vector *files = &EMPTY_VECTOR;\nstatic Vector *stashed = &EMPTY_VECTOR;\n\nFile *make_file(FILE *file, char *name) {\n    File *r = calloc(1, sizeof(File));\n    r->file = file;\n    r->name = name;\n    r->line = 1;\n    r->column = 1;\n    struct stat st;\n    if (fstat(fileno(file), &st) == -1)\n        error(\"fstat failed: %s\", strerror(errno));\n    r->mtime = st.st_mtime;\n    return r;\n}\n\nFile *make_file_string(char *s) {\n    File *r = calloc(1, sizeof(File));\n    r->line = 1;\n    r->column = 1;\n    r->p = s;\n    return r;\n}\n\nstatic void close_file(File *f) {\n    if (f->file)\n        fclose(f->file);\n}\n\nstatic int readc_file(File *f) {\n    int c = getc(f->file);\n    if (c == EOF) {\n        c = (f->last == '\\n' || f->last == EOF) ? EOF : '\\n';\n    } else if (c == '\\r') {\n        int c2 = getc(f->file);\n        if (c2 != '\\n')\n            ungetc(c2, f->file);\n        c = '\\n';\n    }\n    f->last = c;\n    return c;\n}\n\nstatic int readc_string(File *f) {\n    int c;\n    if (*f->p == '\\0') {\n        c = (f->last == '\\n' || f->last == EOF) ? EOF : '\\n';\n    } else if (*f->p == '\\r') {\n        f->p++;\n        if (*f->p == '\\n')\n            f->p++;\n        c = '\\n';\n    } else {\n        c = *f->p++;\n    }\n    f->last = c;\n    return c;\n}\n\nstatic int get() {\n    File *f = vec_tail(files);\n    int c;\n    if (f->buflen > 0) {\n        c = f->buf[--f->buflen];\n    } else if (f->file) {\n        c = readc_file(f);\n    } else {\n        c = readc_string(f);\n    }\n    if (c == '\\n') {\n        f->line++;\n        f->column = 1;\n    } else if (c != EOF) {\n        f->column++;\n    }\n    return c;\n}\n\nint readc() {\n    for (;;) {\n        int c = get();\n        if (c == EOF) {\n            if (vec_len(files) == 1)\n                return c;\n            close_file(vec_pop(files));\n            continue;\n        }\n        if (c != '\\\\')\n            return c;\n        int c2 = get();\n        if (c2 == '\\n')\n            continue;\n        unreadc(c2);\n        return c;\n    }\n}\n\nvoid unreadc(int c) {\n    if (c == EOF)\n        return;\n    File *f = vec_tail(files);\n    assert(f->buflen < sizeof(f->buf) / sizeof(f->buf[0]));\n    f->buf[f->buflen++] = c;\n    if (c == '\\n') {\n        f->column = 1;\n        f->line--;\n    } else {\n        f->column--;\n    }\n}\n\nFile *current_file() {\n    return vec_tail(files);\n}\n\nvoid stream_push(File *f) {\n    vec_push(files, f);\n}\n\nint stream_depth() {\n    return vec_len(files);\n}\n\nchar *input_position() {\n    if (vec_len(files) == 0)\n        return \"(unknown)\";\n    File *f = vec_tail(files);\n    return format(\"%s:%d:%d\", f->name, f->line, f->column);\n}\n\nvoid stream_stash(File *f) {\n    vec_push(stashed, files);\n    files = make_vector1(f);\n}\n\nvoid stream_unstash() {\n    files = vec_pop(stashed);\n}\n"
        },
        {
          "name": "gen.c",
          "type": "blob",
          "size": 40.5673828125,
          "content": "// Copyright 2012 Rui Ueyama. Released under the MIT license.\n\n#include <stdarg.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include \"8cc.h\"\n\nbool dumpstack = false;\nbool dumpsource = true;\n\nstatic char *REGS[] = {\"rdi\", \"rsi\", \"rdx\", \"rcx\", \"r8\", \"r9\"};\nstatic char *SREGS[] = {\"dil\", \"sil\", \"dl\", \"cl\", \"r8b\", \"r9b\"};\nstatic char *MREGS[] = {\"edi\", \"esi\", \"edx\", \"ecx\", \"r8d\", \"r9d\"};\nstatic int TAB = 8;\nstatic Vector *functions = &EMPTY_VECTOR;\nstatic int stackpos;\nstatic int numgp;\nstatic int numfp;\nstatic FILE *outputfp;\nstatic Map *source_files = &EMPTY_MAP;\nstatic Map *source_lines = &EMPTY_MAP;\nstatic char *last_loc = \"\";\n\nstatic void emit_addr(Node *node);\nstatic void emit_expr(Node *node);\nstatic void emit_decl_init(Vector *inits, int off, int totalsize);\nstatic void do_emit_data(Vector *inits, int size, int off, int depth);\nstatic void emit_data(Node *v, int off, int depth);\n\n#define REGAREA_SIZE 176\n\n#define emit(...)        emitf(__LINE__, \"\\t\" __VA_ARGS__)\n#define emit_noindent(...)  emitf(__LINE__, __VA_ARGS__)\n\n#ifdef __GNUC__\n#define SAVE                                                            \\\n    int save_hook __attribute__((unused, cleanup(pop_function)));       \\\n    if (dumpstack)                                                      \\\n        vec_push(functions, (void *)__func__);\n\nstatic void pop_function(void *ignore) {\n    if (dumpstack)\n        vec_pop(functions);\n}\n#else\n#define SAVE\n#endif\n\nstatic char *get_caller_list() {\n    Buffer *b = make_buffer();\n    for (int i = 0; i < vec_len(functions); i++) {\n        if (i > 0)\n            buf_printf(b, \" -> \");\n        buf_printf(b, \"%s\", vec_get(functions, i));\n    }\n    buf_write(b, '\\0');\n    return buf_body(b);\n}\n\nvoid set_output_file(FILE *fp) {\n    outputfp = fp;\n}\n\nvoid close_output_file() {\n    fclose(outputfp);\n}\n\nstatic void emitf(int line, char *fmt, ...) {\n    // Replace \"#\" with \"%%\" so that vfprintf prints out \"#\" as \"%\".\n    char buf[256];\n    int i = 0;\n    for (char *p = fmt; *p; p++) {\n        assert(i < sizeof(buf) - 3);\n        if (*p == '#') {\n            buf[i++] = '%';\n            buf[i++] = '%';\n        } else {\n            buf[i++] = *p;\n        }\n    }\n    buf[i] = '\\0';\n\n    va_list args;\n    va_start(args, fmt);\n    int col = vfprintf(outputfp, buf, args);\n    va_end(args);\n\n    if (dumpstack) {\n        for (char *p = fmt; *p; p++)\n            if (*p == '\\t')\n                col += TAB - 1;\n        int space = (28 - col) > 0 ? (30 - col) : 2;\n        fprintf(outputfp, \"%*c %s:%d\", space, '#', get_caller_list(), line);\n    }\n    fprintf(outputfp, \"\\n\");\n}\n\nstatic void emit_nostack(char *fmt, ...) {\n    fprintf(outputfp, \"\\t\");\n    va_list args;\n    va_start(args, fmt);\n    vfprintf(outputfp, fmt, args);\n    va_end(args);\n    fprintf(outputfp, \"\\n\");\n}\n\nstatic char *get_int_reg(Type *ty, char r) {\n    assert(r == 'a' || r == 'c');\n    switch (ty->size) {\n    case 1: return (r == 'a') ? \"al\" : \"cl\";\n    case 2: return (r == 'a') ? \"ax\" : \"cx\";\n    case 4: return (r == 'a') ? \"eax\" : \"ecx\";\n    case 8: return (r == 'a') ? \"rax\" : \"rcx\";\n    default:\n        error(\"Unknown data size: %s: %d\", ty2s(ty), ty->size);\n    }\n}\n\nstatic char *get_load_inst(Type *ty) {\n    switch (ty->size) {\n    case 1: return \"movsbq\";\n    case 2: return \"movswq\";\n    case 4: return \"movslq\";\n    case 8: return \"mov\";\n    default:\n        error(\"Unknown data size: %s: %d\", ty2s(ty), ty->size);\n    }\n}\n\nstatic int align(int n, int m) {\n    int rem = n % m;\n    return (rem == 0) ? n : n - rem + m;\n}\n\nstatic void push_xmm(int reg) {\n    SAVE;\n    emit(\"sub $8, #rsp\");\n    emit(\"movsd #xmm%d, (#rsp)\", reg);\n    stackpos += 8;\n}\n\nstatic void pop_xmm(int reg) {\n    SAVE;\n    emit(\"movsd (#rsp), #xmm%d\", reg);\n    emit(\"add $8, #rsp\");\n    stackpos -= 8;\n    assert(stackpos >= 0);\n}\n\nstatic void push(char *reg) {\n    SAVE;\n    emit(\"push #%s\", reg);\n    stackpos += 8;\n}\n\nstatic void pop(char *reg) {\n    SAVE;\n    emit(\"pop #%s\", reg);\n    stackpos -= 8;\n    assert(stackpos >= 0);\n}\n\nstatic int push_struct(int size) {\n    SAVE;\n    int aligned = align(size, 8);\n    emit(\"sub $%d, #rsp\", aligned);\n    emit(\"mov #rcx, -8(#rsp)\");\n    emit(\"mov #r11, -16(#rsp)\");\n    emit(\"mov #rax, #rcx\");\n    int i = 0;\n    for (; i < size; i += 8) {\n        emit(\"movq %d(#rcx), #r11\", i);\n        emit(\"mov #r11, %d(#rsp)\", i);\n    }\n    for (; i < size; i += 4) {\n        emit(\"movl %d(#rcx), #r11\", i);\n        emit(\"movl #r11d, %d(#rsp)\", i);\n    }\n    for (; i < size; i++) {\n        emit(\"movb %d(#rcx), #r11\", i);\n        emit(\"movb #r11b, %d(#rsp)\", i);\n    }\n    emit(\"mov -8(#rsp), #rcx\");\n    emit(\"mov -16(#rsp), #r11\");\n    stackpos += aligned;\n    return aligned;\n}\n\nstatic void maybe_emit_bitshift_load(Type *ty) {\n    SAVE;\n    if (ty->bitsize <= 0)\n        return;\n    emit(\"shr $%d, #rax\", ty->bitoff);\n    push(\"rcx\");\n    emit(\"mov $0x%lx, #rcx\", (1 << (long)ty->bitsize) - 1);\n    emit(\"and #rcx, #rax\");\n    pop(\"rcx\");\n}\n\nstatic void maybe_emit_bitshift_save(Type *ty, char *addr) {\n    SAVE;\n    if (ty->bitsize <= 0)\n        return;\n    push(\"rcx\");\n    push(\"rdi\");\n    emit(\"mov $0x%lx, #rdi\", (1 << (long)ty->bitsize) - 1);\n    emit(\"and #rdi, #rax\");\n    emit(\"shl $%d, #rax\", ty->bitoff);\n    emit(\"mov %s, #%s\", addr, get_int_reg(ty, 'c'));\n    emit(\"mov $0x%lx, #rdi\", ~(((1 << (long)ty->bitsize) - 1) << ty->bitoff));\n    emit(\"and #rdi, #rcx\");\n    emit(\"or #rcx, #rax\");\n    pop(\"rdi\");\n    pop(\"rcx\");\n}\n\nstatic void emit_gload(Type *ty, char *label, int off) {\n    SAVE;\n    if (ty->kind == KIND_ARRAY) {\n        if (off)\n            emit(\"lea %s+%d(#rip), #rax\", label, off);\n        else\n            emit(\"lea %s(#rip), #rax\", label);\n        return;\n    }\n    char *inst = get_load_inst(ty);\n    emit(\"%s %s+%d(#rip), #rax\", inst, label, off);\n    maybe_emit_bitshift_load(ty);\n}\n\nstatic void emit_intcast(Type *ty) {\n    switch(ty->kind) {\n    case KIND_BOOL:\n    case KIND_CHAR:\n        ty->usig ? emit(\"movzbq #al, #rax\") : emit(\"movsbq #al, #rax\");\n        return;\n    case KIND_SHORT:\n        ty->usig ? emit(\"movzwq #ax, #rax\") : emit(\"movswq #ax, #rax\");\n        return;\n    case KIND_INT:\n        ty->usig ? emit(\"mov #eax, #eax\") : emit(\"cltq\");\n        return;\n    case KIND_LONG:\n    case KIND_LLONG:\n        return;\n    }\n}\n\nstatic void emit_toint(Type *ty) {\n    SAVE;\n    if (ty->kind == KIND_FLOAT)\n        emit(\"cvttss2si #xmm0, #eax\");\n    else if (ty->kind == KIND_DOUBLE)\n        emit(\"cvttsd2si #xmm0, #eax\");\n}\n\nstatic void emit_lload(Type *ty, char *base, int off) {\n    SAVE;\n    if (ty->kind == KIND_ARRAY) {\n        emit(\"lea %d(#%s), #rax\", off, base);\n    } else if (ty->kind == KIND_FLOAT) {\n        emit(\"movss %d(#%s), #xmm0\", off, base);\n    } else if (ty->kind == KIND_DOUBLE || ty->kind == KIND_LDOUBLE) {\n        emit(\"movsd %d(#%s), #xmm0\", off, base);\n    } else {\n        char *inst = get_load_inst(ty);\n        emit(\"%s %d(#%s), #rax\", inst, off, base);\n        maybe_emit_bitshift_load(ty);\n    }\n}\n\nstatic void maybe_convert_bool(Type *ty) {\n    if (ty->kind == KIND_BOOL) {\n        emit(\"test #rax, #rax\");\n        emit(\"setne #al\");\n    }\n}\n\nstatic void emit_gsave(char *varname, Type *ty, int off) {\n    SAVE;\n    assert(ty->kind != KIND_ARRAY);\n    maybe_convert_bool(ty);\n    char *reg = get_int_reg(ty, 'a');\n    char *addr = format(\"%s+%d(%%rip)\", varname, off);\n    maybe_emit_bitshift_save(ty, addr);\n    emit(\"mov #%s, %s\", reg, addr);\n}\n\nstatic void emit_lsave(Type *ty, int off) {\n    SAVE;\n    if (ty->kind == KIND_FLOAT) {\n        emit(\"movss #xmm0, %d(#rbp)\", off);\n    } else if (ty->kind == KIND_DOUBLE) {\n        emit(\"movsd #xmm0, %d(#rbp)\", off);\n    } else {\n        maybe_convert_bool(ty);\n        char *reg = get_int_reg(ty, 'a');\n        char *addr = format(\"%d(%%rbp)\", off);\n        maybe_emit_bitshift_save(ty, addr);\n        emit(\"mov #%s, %s\", reg, addr);\n    }\n}\n\nstatic void do_emit_assign_deref(Type *ty, int off) {\n    SAVE;\n    emit(\"mov (#rsp), #rcx\");\n    char *reg = get_int_reg(ty, 'c');\n    if (off)\n        emit(\"mov #%s, %d(#rax)\", reg, off);\n    else\n        emit(\"mov #%s, (#rax)\", reg);\n    pop(\"rax\");\n}\n\nstatic void emit_assign_deref(Node *var) {\n    SAVE;\n    push(\"rax\");\n    emit_expr(var->operand);\n    do_emit_assign_deref(var->operand->ty->ptr, 0);\n}\n\nstatic void emit_pointer_arith(char kind, Node *left, Node *right) {\n    SAVE;\n    emit_expr(left);\n    push(\"rcx\");\n    push(\"rax\");\n    emit_expr(right);\n    int size = left->ty->ptr->size;\n    if (size > 1)\n        emit(\"imul $%d, #rax\", size);\n    emit(\"mov #rax, #rcx\");\n    pop(\"rax\");\n    switch (kind) {\n    case '+': emit(\"add #rcx, #rax\"); break;\n    case '-': emit(\"sub #rcx, #rax\"); break;\n    default: error(\"invalid operator '%d'\", kind);\n    }\n    pop(\"rcx\");\n}\n\nstatic void emit_zero_filler(int start, int end) {\n    SAVE;\n    for (; start <= end - 4; start += 4)\n        emit(\"movl $0, %d(#rbp)\", start);\n    for (; start < end; start++)\n        emit(\"movb $0, %d(#rbp)\", start);\n}\n\nstatic void ensure_lvar_init(Node *node) {\n    SAVE;\n    assert(node->kind == AST_LVAR);\n    if (node->lvarinit)\n        emit_decl_init(node->lvarinit, node->loff, node->ty->size);\n    node->lvarinit = NULL;\n}\n\nstatic void emit_assign_struct_ref(Node *struc, Type *field, int off) {\n    SAVE;\n    switch (struc->kind) {\n    case AST_LVAR:\n        ensure_lvar_init(struc);\n        emit_lsave(field, struc->loff + field->offset + off);\n        break;\n    case AST_GVAR:\n        emit_gsave(struc->glabel, field, field->offset + off);\n        break;\n    case AST_STRUCT_REF:\n        emit_assign_struct_ref(struc->struc, field, off + struc->ty->offset);\n        break;\n    case AST_DEREF:\n        push(\"rax\");\n        emit_expr(struc->operand);\n        do_emit_assign_deref(field, field->offset + off);\n        break;\n    default:\n        error(\"internal error: %s\", node2s(struc));\n    }\n}\n\nstatic void emit_load_struct_ref(Node *struc, Type *field, int off) {\n    SAVE;\n    switch (struc->kind) {\n    case AST_LVAR:\n        ensure_lvar_init(struc);\n        emit_lload(field, \"rbp\", struc->loff + field->offset + off);\n        break;\n    case AST_GVAR:\n        emit_gload(field, struc->glabel, field->offset + off);\n        break;\n    case AST_STRUCT_REF:\n        emit_load_struct_ref(struc->struc, field, struc->ty->offset + off);\n        break;\n    case AST_DEREF:\n        emit_expr(struc->operand);\n        emit_lload(field, \"rax\", field->offset + off);\n        break;\n    default:\n        error(\"internal error: %s\", node2s(struc));\n    }\n}\n\nstatic void emit_store(Node *var) {\n    SAVE;\n    switch (var->kind) {\n    case AST_DEREF: emit_assign_deref(var); break;\n    case AST_STRUCT_REF: emit_assign_struct_ref(var->struc, var->ty, 0); break;\n    case AST_LVAR:\n        ensure_lvar_init(var);\n        emit_lsave(var->ty, var->loff);\n        break;\n    case AST_GVAR: emit_gsave(var->glabel, var->ty, 0); break;\n    default: error(\"internal error\");\n    }\n}\n\nstatic void emit_to_bool(Type *ty) {\n    SAVE;\n    if (is_flotype(ty)) {\n        push_xmm(1);\n        emit(\"xorpd #xmm1, #xmm1\");\n        emit(\"%s #xmm1, #xmm0\", (ty->kind == KIND_FLOAT) ? \"ucomiss\" : \"ucomisd\");\n        emit(\"setne #al\");\n        pop_xmm(1);\n    } else {\n        emit(\"cmp $0, #rax\");\n        emit(\"setne #al\");\n    }\n    emit(\"movzb #al, #eax\");\n}\n\nstatic void emit_comp(char *inst, char *usiginst, Node *node) {\n    SAVE;\n    if (is_flotype(node->left->ty)) {\n        emit_expr(node->left);\n        push_xmm(0);\n        emit_expr(node->right);\n        pop_xmm(1);\n        if (node->left->ty->kind == KIND_FLOAT)\n            emit(\"ucomiss #xmm0, #xmm1\");\n        else\n            emit(\"ucomisd #xmm0, #xmm1\");\n    } else {\n        emit_expr(node->left);\n        push(\"rax\");\n        emit_expr(node->right);\n        pop(\"rcx\");\n        int kind = node->left->ty->kind;\n        if (kind == KIND_LONG || kind == KIND_LLONG)\n          emit(\"cmp #rax, #rcx\");\n        else\n          emit(\"cmp #eax, #ecx\");\n    }\n    if (is_flotype(node->left->ty) || node->left->ty->usig)\n        emit(\"%s #al\", usiginst);\n    else\n        emit(\"%s #al\", inst);\n    emit(\"movzb #al, #eax\");\n}\n\nstatic void emit_binop_int_arith(Node *node) {\n    SAVE;\n    char *op = NULL;\n    switch (node->kind) {\n    case '+': op = \"add\"; break;\n    case '-': op = \"sub\"; break;\n    case '*': op = \"imul\"; break;\n    case '^': op = \"xor\"; break;\n    case OP_SAL: op = \"sal\"; break;\n    case OP_SAR: op = \"sar\"; break;\n    case OP_SHR: op = \"shr\"; break;\n    case '/': case '%': break;\n    default: error(\"invalid operator '%d'\", node->kind);\n    }\n    emit_expr(node->left);\n    push(\"rax\");\n    emit_expr(node->right);\n    emit(\"mov #rax, #rcx\");\n    pop(\"rax\");\n    if (node->kind == '/' || node->kind == '%') {\n        if (node->ty->usig) {\n          emit(\"xor #edx, #edx\");\n          emit(\"div #rcx\");\n        } else {\n          emit(\"cqto\");\n          emit(\"idiv #rcx\");\n        }\n        if (node->kind == '%')\n            emit(\"mov #edx, #eax\");\n    } else if (node->kind == OP_SAL || node->kind == OP_SAR || node->kind == OP_SHR) {\n        emit(\"%s #cl, #%s\", op, get_int_reg(node->left->ty, 'a'));\n    } else {\n        emit(\"%s #rcx, #rax\", op);\n    }\n}\n\nstatic void emit_binop_float_arith(Node *node) {\n    SAVE;\n    char *op;\n    bool isdouble = (node->ty->kind == KIND_DOUBLE);\n    switch (node->kind) {\n    case '+': op = (isdouble ? \"addsd\" : \"addss\"); break;\n    case '-': op = (isdouble ? \"subsd\" : \"subss\"); break;\n    case '*': op = (isdouble ? \"mulsd\" : \"mulss\"); break;\n    case '/': op = (isdouble ? \"divsd\" : \"divss\"); break;\n    default: error(\"invalid operator '%d'\", node->kind);\n    }\n    emit_expr(node->left);\n    push_xmm(0);\n    emit_expr(node->right);\n    emit(\"%s #xmm0, #xmm1\", (isdouble ? \"movsd\" : \"movss\"));\n    pop_xmm(0);\n    emit(\"%s #xmm1, #xmm0\", op);\n}\n\nstatic void emit_load_convert(Type *to, Type *from) {\n    SAVE;\n    if (is_inttype(from) && to->kind == KIND_FLOAT)\n        emit(\"cvtsi2ss #eax, #xmm0\");\n    else if (is_inttype(from) && to->kind == KIND_DOUBLE)\n        emit(\"cvtsi2sd #eax, #xmm0\");\n    else if (from->kind == KIND_FLOAT && to->kind == KIND_DOUBLE)\n        emit(\"cvtps2pd #xmm0, #xmm0\");\n    else if ((from->kind == KIND_DOUBLE || from->kind == KIND_LDOUBLE) && to->kind == KIND_FLOAT)\n        emit(\"cvtpd2ps #xmm0, #xmm0\");\n    else if (to->kind == KIND_BOOL)\n        emit_to_bool(from);\n    else if (is_inttype(from) && is_inttype(to))\n        emit_intcast(from);\n    else if (is_inttype(to))\n        emit_toint(from);\n}\n\nstatic void emit_ret() {\n    SAVE;\n    emit(\"leave\");\n    emit(\"ret\");\n}\n\nstatic void emit_binop(Node *node) {\n    SAVE;\n    if (node->ty->kind == KIND_PTR) {\n        emit_pointer_arith(node->kind, node->left, node->right);\n        return;\n    }\n    switch (node->kind) {\n    case '<': emit_comp(\"setl\", \"setb\", node); return;\n    case OP_EQ: emit_comp(\"sete\", \"sete\", node); return;\n    case OP_LE: emit_comp(\"setle\", \"setna\", node); return;\n    case OP_NE: emit_comp(\"setne\", \"setne\", node); return;\n    }\n    if (is_inttype(node->ty))\n        emit_binop_int_arith(node);\n    else if (is_flotype(node->ty))\n        emit_binop_float_arith(node);\n    else\n        error(\"internal error: %s\", node2s(node));\n}\n\nstatic void emit_save_literal(Node *node, Type *totype, int off) {\n    switch (totype->kind) {\n    case KIND_BOOL:  emit(\"movb $%d, %d(#rbp)\", !!node->ival, off); break;\n    case KIND_CHAR:  emit(\"movb $%d, %d(#rbp)\", node->ival, off); break;\n    case KIND_SHORT: emit(\"movw $%d, %d(#rbp)\", node->ival, off); break;\n    case KIND_INT:   emit(\"movl $%d, %d(#rbp)\", node->ival, off); break;\n    case KIND_LONG:\n    case KIND_LLONG:\n    case KIND_PTR: {\n        emit(\"movl $%lu, %d(#rbp)\", ((uint64_t)node->ival) & ((1L << 32) - 1), off);\n        emit(\"movl $%lu, %d(#rbp)\", ((uint64_t)node->ival) >> 32, off + 4);\n        break;\n    }\n    case KIND_FLOAT: {\n        float fval = node->fval;\n        emit(\"movl $%u, %d(#rbp)\", *(uint32_t *)&fval, off);\n        break;\n    }\n    case KIND_DOUBLE:\n    case KIND_LDOUBLE: {\n        emit(\"movl $%lu, %d(#rbp)\", *(uint64_t *)&node->fval & ((1L << 32) - 1), off);\n        emit(\"movl $%lu, %d(#rbp)\", *(uint64_t *)&node->fval >> 32, off + 4);\n        break;\n    }\n    default:\n        error(\"internal error: <%s> <%s> <%d>\", node2s(node), ty2s(totype), off);\n    }\n}\n\nstatic void emit_addr(Node *node) {\n    switch (node->kind) {\n    case AST_LVAR:\n        ensure_lvar_init(node);\n        emit(\"lea %d(#rbp), #rax\", node->loff);\n        break;\n    case AST_GVAR:\n        emit(\"lea %s(#rip), #rax\", node->glabel);\n        break;\n    case AST_DEREF:\n        emit_expr(node->operand);\n        break;\n    case AST_STRUCT_REF:\n        emit_addr(node->struc);\n        emit(\"add $%d, #rax\", node->ty->offset);\n        break;\n    case AST_FUNCDESG:\n        emit(\"lea %s(#rip), #rax\", node->fname);\n        break;\n    default:\n        error(\"internal error: %s\", node2s(node));\n    }\n}\n\nstatic void emit_copy_struct(Node *left, Node *right) {\n    push(\"rcx\");\n    push(\"r11\");\n    emit_addr(right);\n    emit(\"mov #rax, #rcx\");\n    emit_addr(left);\n    int i = 0;\n    for (; i < left->ty->size; i += 8) {\n        emit(\"movq %d(#rcx), #r11\", i);\n        emit(\"movq #r11, %d(#rax)\", i);\n    }\n    for (; i < left->ty->size; i += 4) {\n        emit(\"movl %d(#rcx), #r11\", i);\n        emit(\"movl #r11, %d(#rax)\", i);\n    }\n    for (; i < left->ty->size; i++) {\n        emit(\"movb %d(#rcx), #r11\", i);\n        emit(\"movb #r11, %d(#rax)\", i);\n    }\n    pop(\"r11\");\n    pop(\"rcx\");\n}\n\nstatic int cmpinit(const void *x, const void *y) {\n    Node *a = *(Node **)x;\n    Node *b = *(Node **)y;\n    return a->initoff - b->initoff;\n}\n\nstatic void emit_fill_holes(Vector *inits, int off, int totalsize) {\n    // If at least one of the fields in a variable are initialized,\n    // unspecified fields has to be initialized with 0.\n    int len = vec_len(inits);\n    Node **buf = malloc(len * sizeof(Node *));\n    for (int i = 0; i < len; i++)\n        buf[i] = vec_get(inits, i);\n    qsort(buf, len, sizeof(Node *), cmpinit);\n\n    int lastend = 0;\n    for (int i = 0; i < len; i++) {\n        Node *node = buf[i];\n        if (lastend < node->initoff)\n            emit_zero_filler(lastend + off, node->initoff + off);\n        lastend = node->initoff + node->totype->size;\n    }\n    emit_zero_filler(lastend + off, totalsize + off);\n}\n\nstatic void emit_decl_init(Vector *inits, int off, int totalsize) {\n    emit_fill_holes(inits, off, totalsize);\n    for (int i = 0; i < vec_len(inits); i++) {\n        Node *node = vec_get(inits, i);\n        assert(node->kind == AST_INIT);\n        bool isbitfield = (node->totype->bitsize > 0);\n        if (node->initval->kind == AST_LITERAL && !isbitfield) {\n            emit_save_literal(node->initval, node->totype, node->initoff + off);\n        } else {\n            emit_expr(node->initval);\n            emit_lsave(node->totype, node->initoff + off);\n        }\n    }\n}\n\nstatic void emit_pre_inc_dec(Node *node, char *op) {\n    emit_expr(node->operand);\n    emit(\"%s $%d, #rax\", op, node->ty->ptr ? node->ty->ptr->size : 1);\n    emit_store(node->operand);\n}\n\nstatic void emit_post_inc_dec(Node *node, char *op) {\n    SAVE;\n    emit_expr(node->operand);\n    push(\"rax\");\n    emit(\"%s $%d, #rax\", op, node->ty->ptr ? node->ty->ptr->size : 1);\n    emit_store(node->operand);\n    pop(\"rax\");\n}\n\nstatic void set_reg_nums(Vector *args) {\n    numgp = numfp = 0;\n    for (int i = 0; i < vec_len(args); i++) {\n        Node *arg = vec_get(args, i);\n        if (is_flotype(arg->ty))\n            numfp++;\n        else\n            numgp++;\n    }\n}\n\nstatic void emit_je(char *label) {\n    emit(\"test #rax, #rax\");\n    emit(\"je %s\", label);\n}\n\nstatic void emit_label(char *label) {\n    emit(\"%s:\", label);\n}\n\nstatic void emit_jmp(char *label) {\n    emit(\"jmp %s\", label);\n}\n\nstatic void emit_literal(Node *node) {\n    SAVE;\n    switch (node->ty->kind) {\n    case KIND_BOOL:\n    case KIND_CHAR:\n    case KIND_SHORT:\n        emit(\"mov $%u, #rax\", node->ival);\n        break;\n    case KIND_INT:\n        emit(\"mov $%u, #rax\", node->ival);\n        break;\n    case KIND_LONG:\n    case KIND_LLONG: {\n        emit(\"mov $%lu, #rax\", node->ival);\n        break;\n    }\n    case KIND_FLOAT: {\n        if (!node->flabel) {\n            node->flabel = make_label();\n            float fval = node->fval;\n            emit_noindent(\".data\");\n            emit_label(node->flabel);\n            emit(\".long %d\", *(uint32_t *)&fval);\n            emit_noindent(\".text\");\n        }\n        emit(\"movss %s(#rip), #xmm0\", node->flabel);\n        break;\n    }\n    case KIND_DOUBLE:\n    case KIND_LDOUBLE: {\n        if (!node->flabel) {\n            node->flabel = make_label();\n            emit_noindent(\".data\");\n            emit_label(node->flabel);\n            emit(\".quad %lu\", *(uint64_t *)&node->fval);\n            emit_noindent(\".text\");\n        }\n        emit(\"movsd %s(#rip), #xmm0\", node->flabel);\n        break;\n    }\n    case KIND_ARRAY: {\n        if (!node->slabel) {\n            node->slabel = make_label();\n            emit_noindent(\".data\");\n            emit_label(node->slabel);\n            emit(\".string \\\"%s\\\"\", quote_cstring_len(node->sval, node->ty->size - 1));\n            emit_noindent(\".text\");\n        }\n        emit(\"lea %s(#rip), #rax\", node->slabel);\n        break;\n    }\n    default:\n        error(\"internal error\");\n    }\n}\n\nstatic char **split(char *buf) {\n    char *p = buf;\n    int len = 1;\n    while (*p) {\n        if (p[0] == '\\r' && p[1] == '\\n') {\n            len++;\n            p += 2;\n            continue;\n        }\n        if (p[0] == '\\r' || p[0] == '\\n')\n            len++;\n        p++;\n    }\n    p = buf;\n    char **r = malloc(sizeof(char *) * len + 1);\n    int i = 0;\n    while (*p) {\n        if (p[0] == '\\r' && p[1] == '\\n') {\n            p[0] = '\\0';\n            p += 2;\n            r[i++] = p;\n            continue;\n        }\n        if (p[0] == '\\r' || p[0] == '\\n') {\n            p[0] = '\\0';\n            r[i++] = p + 1;\n        }\n        p++;\n    }\n    r[i] = NULL;\n    return r;\n}\n\nstatic char **read_source_file(char *file) {\n    FILE *fp = fopen(file, \"r\");\n    if (!fp)\n        return NULL;\n    struct stat st;\n    fstat(fileno(fp), &st);\n    char *buf = malloc(st.st_size + 1);\n    if (fread(buf, 1, st.st_size, fp) != st.st_size) {\n        fclose(fp);\n        return NULL;\n    }\n    fclose(fp);\n    buf[st.st_size] = '\\0';\n    return split(buf);\n}\n\nstatic void maybe_print_source_line(char *file, int line) {\n    if (!dumpsource)\n        return;\n    char **lines = map_get(source_lines, file);\n    if (!lines) {\n        lines = read_source_file(file);\n        if (!lines)\n            return;\n        map_put(source_lines, file, lines);\n    }\n    int len = 0;\n    for (char **p = lines; *p; p++)\n        len++;\n    emit_nostack(\"# %s\", lines[line - 1]);\n}\n\nstatic void maybe_print_source_loc(Node *node) {\n    if (!node->sourceLoc)\n        return;\n    char *file = node->sourceLoc->file;\n    long fileno = (long)map_get(source_files, file);\n    if (!fileno) {\n        fileno = map_len(source_files) + 1;\n        map_put(source_files, file, (void *)fileno);\n        emit(\".file %ld \\\"%s\\\"\", fileno, quote_cstring(file));\n    }\n    char *loc = format(\".loc %ld %d 0\", fileno, node->sourceLoc->line);\n    if (strcmp(loc, last_loc)) {\n        emit(\"%s\", loc);\n        maybe_print_source_line(file, node->sourceLoc->line);\n    }\n    last_loc = loc;\n}\n\nstatic void emit_lvar(Node *node) {\n    SAVE;\n    ensure_lvar_init(node);\n    emit_lload(node->ty, \"rbp\", node->loff);\n}\n\nstatic void emit_gvar(Node *node) {\n    SAVE;\n    emit_gload(node->ty, node->glabel, 0);\n}\n\nstatic void emit_builtin_return_address(Node *node) {\n    push(\"r11\");\n    assert(vec_len(node->args) == 1);\n    emit_expr(vec_head(node->args));\n    char *loop = make_label();\n    char *end = make_label();\n    emit(\"mov #rbp, #r11\");\n    emit_label(loop);\n    emit(\"test #rax, #rax\");\n    emit(\"jz %s\", end);\n    emit(\"mov (#r11), #r11\");\n    emit(\"sub $1, #rax\");\n    emit_jmp(loop);\n    emit_label(end);\n    emit(\"mov 8(#r11), #rax\");\n    pop(\"r11\");\n}\n\n// Set the register class for parameter passing to RAX.\n// 0 is INTEGER, 1 is SSE, 2 is MEMORY.\nstatic void emit_builtin_reg_class(Node *node) {\n    Node *arg = vec_get(node->args, 0);\n    assert(arg->ty->kind == KIND_PTR);\n    Type *ty = arg->ty->ptr;\n    if (ty->kind == KIND_STRUCT)\n        emit(\"mov $2, #eax\");\n    else if (is_flotype(ty))\n        emit(\"mov $1, #eax\");\n    else\n        emit(\"mov $0, #eax\");\n}\n\nstatic void emit_builtin_va_start(Node *node) {\n    SAVE;\n    assert(vec_len(node->args) == 1);\n    emit_expr(vec_head(node->args));\n    push(\"rcx\");\n    emit(\"movl $%d, (#rax)\", numgp * 8);\n    emit(\"movl $%d, 4(#rax)\", 48 + numfp * 16);\n    emit(\"lea %d(#rbp), #rcx\", -REGAREA_SIZE);\n    emit(\"mov #rcx, 16(#rax)\");\n    pop(\"rcx\");\n}\n\nstatic bool maybe_emit_builtin(Node *node) {\n    SAVE;\n    if (!strcmp(\"__builtin_return_address\", node->fname)) {\n        emit_builtin_return_address(node);\n        return true;\n    }\n    if (!strcmp(\"__builtin_reg_class\", node->fname)) {\n        emit_builtin_reg_class(node);\n        return true;\n    }\n    if (!strcmp(\"__builtin_va_start\", node->fname)) {\n        emit_builtin_va_start(node);\n        return true;\n    }\n    return false;\n}\n\nstatic void classify_args(Vector *ints, Vector *floats, Vector *rest, Vector *args) {\n    SAVE;\n    int ireg = 0, xreg = 0;\n    int imax = 6, xmax = 8;\n    for (int i = 0; i < vec_len(args); i++) {\n        Node *v = vec_get(args, i);\n        if (v->ty->kind == KIND_STRUCT)\n            vec_push(rest, v);\n        else if (is_flotype(v->ty))\n            vec_push((xreg++ < xmax) ? floats : rest, v);\n        else\n            vec_push((ireg++ < imax) ? ints : rest, v);\n    }\n}\n\nstatic void save_arg_regs(int nints, int nfloats) {\n    SAVE;\n    assert(nints <= 6);\n    assert(nfloats <= 8);\n    for (int i = 0; i < nints; i++)\n        push(REGS[i]);\n    for (int i = 1; i < nfloats; i++)\n        push_xmm(i);\n}\n\nstatic void restore_arg_regs(int nints, int nfloats) {\n    SAVE;\n    for (int i = nfloats - 1; i > 0; i--)\n        pop_xmm(i);\n    for (int i = nints - 1; i >= 0; i--)\n        pop(REGS[i]);\n}\n\nstatic int emit_args(Vector *vals) {\n    SAVE;\n    int r = 0;\n    for (int i = 0; i < vec_len(vals); i++) {\n        Node *v = vec_get(vals, i);\n        if (v->ty->kind == KIND_STRUCT) {\n            emit_addr(v);\n            r += push_struct(v->ty->size);\n        } else if (is_flotype(v->ty)) {\n            emit_expr(v);\n            push_xmm(0);\n            r += 8;\n        } else {\n            emit_expr(v);\n            push(\"rax\");\n            r += 8;\n        }\n    }\n    return r;\n}\n\nstatic void pop_int_args(int nints) {\n    SAVE;\n    for (int i = nints - 1; i >= 0; i--)\n        pop(REGS[i]);\n}\n\nstatic void pop_float_args(int nfloats) {\n    SAVE;\n    for (int i = nfloats - 1; i >= 0; i--)\n        pop_xmm(i);\n}\n\nstatic void maybe_booleanize_retval(Type *ty) {\n    if (ty->kind == KIND_BOOL) {\n        emit(\"movzx #al, #rax\");\n    }\n}\n\nstatic void emit_func_call(Node *node) {\n    SAVE;\n    int opos = stackpos;\n    bool isptr = (node->kind == AST_FUNCPTR_CALL);\n    Type *ftype = isptr ? node->fptr->ty->ptr : node->ftype;\n\n    Vector *ints = make_vector();\n    Vector *floats = make_vector();\n    Vector *rest = make_vector();\n    classify_args(ints, floats, rest, node->args);\n    save_arg_regs(vec_len(ints), vec_len(floats));\n\n    bool padding = stackpos % 16;\n    if (padding) {\n        emit(\"sub $8, #rsp\");\n        stackpos += 8;\n    }\n\n    int restsize = emit_args(vec_reverse(rest));\n    if (isptr) {\n        emit_expr(node->fptr);\n        push(\"rax\");\n    }\n    emit_args(ints);\n    emit_args(floats);\n    pop_float_args(vec_len(floats));\n    pop_int_args(vec_len(ints));\n\n    if (isptr) pop(\"r11\");\n    if (ftype->hasva)\n        emit(\"mov $%u, #eax\", vec_len(floats));\n\n    if (isptr)\n        emit(\"call *#r11\");\n    else\n        emit(\"call %s\", node->fname);\n    maybe_booleanize_retval(node->ty);\n    if (restsize > 0) {\n        emit(\"add $%d, #rsp\", restsize);\n        stackpos -= restsize;\n    }\n    if (padding) {\n        emit(\"add $8, #rsp\");\n        stackpos -= 8;\n    }\n    restore_arg_regs(vec_len(ints), vec_len(floats));\n    assert(opos == stackpos);\n}\n\nstatic void emit_decl(Node *node) {\n    SAVE;\n    if (!node->declinit)\n        return;\n    emit_decl_init(node->declinit, node->declvar->loff, node->declvar->ty->size);\n}\n\nstatic void emit_conv(Node *node) {\n    SAVE;\n    emit_expr(node->operand);\n    emit_load_convert(node->ty, node->operand->ty);\n}\n\nstatic void emit_deref(Node *node) {\n    SAVE;\n    emit_expr(node->operand);\n    emit_lload(node->operand->ty->ptr, \"rax\", 0);\n    emit_load_convert(node->ty, node->operand->ty->ptr);\n}\n\nstatic void emit_ternary(Node *node) {\n    SAVE;\n    emit_expr(node->cond);\n    char *ne = make_label();\n    emit_je(ne);\n    if (node->then)\n        emit_expr(node->then);\n    if (node->els) {\n        char *end = make_label();\n        emit_jmp(end);\n        emit_label(ne);\n        emit_expr(node->els);\n        emit_label(end);\n    } else {\n        emit_label(ne);\n    }\n}\n\nstatic void emit_goto(Node *node) {\n    SAVE;\n    assert(node->newlabel);\n    emit_jmp(node->newlabel);\n}\n\nstatic void emit_return(Node *node) {\n    SAVE;\n    if (node->retval) {\n        emit_expr(node->retval);\n        maybe_booleanize_retval(node->retval->ty);\n    }\n    emit_ret();\n}\n\nstatic void emit_compound_stmt(Node *node) {\n    SAVE;\n    for (int i = 0; i < vec_len(node->stmts); i++)\n        emit_expr(vec_get(node->stmts, i));\n}\n\nstatic void emit_logand(Node *node) {\n    SAVE;\n    char *end = make_label();\n    emit_expr(node->left);\n    emit(\"test #rax, #rax\");\n    emit(\"mov $0, #rax\");\n    emit(\"je %s\", end);\n    emit_expr(node->right);\n    emit(\"test #rax, #rax\");\n    emit(\"mov $0, #rax\");\n    emit(\"je %s\", end);\n    emit(\"mov $1, #rax\");\n    emit_label(end);\n}\n\nstatic void emit_logor(Node *node) {\n    SAVE;\n    char *end = make_label();\n    emit_expr(node->left);\n    emit(\"test #rax, #rax\");\n    emit(\"mov $1, #rax\");\n    emit(\"jne %s\", end);\n    emit_expr(node->right);\n    emit(\"test #rax, #rax\");\n    emit(\"mov $1, #rax\");\n    emit(\"jne %s\", end);\n    emit(\"mov $0, #rax\");\n    emit_label(end);\n}\n\nstatic void emit_lognot(Node *node) {\n    SAVE;\n    emit_expr(node->operand);\n    emit(\"cmp $0, #rax\");\n    emit(\"sete #al\");\n    emit(\"movzb #al, #eax\");\n}\n\nstatic void emit_bitand(Node *node) {\n    SAVE;\n    emit_expr(node->left);\n    push(\"rax\");\n    emit_expr(node->right);\n    pop(\"rcx\");\n    emit(\"and #rcx, #rax\");\n}\n\nstatic void emit_bitor(Node *node) {\n    SAVE;\n    emit_expr(node->left);\n    push(\"rax\");\n    emit_expr(node->right);\n    pop(\"rcx\");\n    emit(\"or #rcx, #rax\");\n}\n\nstatic void emit_bitnot(Node *node) {\n    SAVE;\n    emit_expr(node->left);\n    emit(\"not #rax\");\n}\n\nstatic void emit_cast(Node *node) {\n    SAVE;\n    emit_expr(node->operand);\n    emit_load_convert(node->ty, node->operand->ty);\n    return;\n}\n\nstatic void emit_comma(Node *node) {\n    SAVE;\n    emit_expr(node->left);\n    emit_expr(node->right);\n}\n\nstatic void emit_assign(Node *node) {\n    SAVE;\n    if (node->left->ty->kind == KIND_STRUCT &&\n        node->left->ty->size > 8) {\n        emit_copy_struct(node->left, node->right);\n    } else {\n        emit_expr(node->right);\n        emit_load_convert(node->ty, node->right->ty);\n        emit_store(node->left);\n    }\n}\n\nstatic void emit_label_addr(Node *node) {\n    SAVE;\n    emit(\"mov $%s, #rax\", node->newlabel);\n}\n\nstatic void emit_computed_goto(Node *node) {\n    SAVE;\n    emit_expr(node->operand);\n    emit(\"jmp *#rax\");\n}\n\nstatic void emit_expr(Node *node) {\n    SAVE;\n    maybe_print_source_loc(node);\n    switch (node->kind) {\n    case AST_LITERAL: emit_literal(node); return;\n    case AST_LVAR:    emit_lvar(node); return;\n    case AST_GVAR:    emit_gvar(node); return;\n    case AST_FUNCDESG: emit_addr(node); return;\n    case AST_FUNCALL:\n        if (maybe_emit_builtin(node))\n            return;\n        // fall through\n    case AST_FUNCPTR_CALL:\n        emit_func_call(node);\n        return;\n    case AST_DECL:    emit_decl(node); return;\n    case AST_CONV:    emit_conv(node); return;\n    case AST_ADDR:    emit_addr(node->operand); return;\n    case AST_DEREF:   emit_deref(node); return;\n    case AST_IF:\n    case AST_TERNARY:\n        emit_ternary(node);\n        return;\n    case AST_GOTO:    emit_goto(node); return;\n    case AST_LABEL:\n        if (node->newlabel)\n            emit_label(node->newlabel);\n        return;\n    case AST_RETURN:  emit_return(node); return;\n    case AST_COMPOUND_STMT: emit_compound_stmt(node); return;\n    case AST_STRUCT_REF:\n        emit_load_struct_ref(node->struc, node->ty, 0);\n        return;\n    case OP_PRE_INC:   emit_pre_inc_dec(node, \"add\"); return;\n    case OP_PRE_DEC:   emit_pre_inc_dec(node, \"sub\"); return;\n    case OP_POST_INC:  emit_post_inc_dec(node, \"add\"); return;\n    case OP_POST_DEC:  emit_post_inc_dec(node, \"sub\"); return;\n    case '!': emit_lognot(node); return;\n    case '&': emit_bitand(node); return;\n    case '|': emit_bitor(node); return;\n    case '~': emit_bitnot(node); return;\n    case OP_LOGAND: emit_logand(node); return;\n    case OP_LOGOR:  emit_logor(node); return;\n    case OP_CAST:   emit_cast(node); return;\n    case ',': emit_comma(node); return;\n    case '=': emit_assign(node); return;\n    case OP_LABEL_ADDR: emit_label_addr(node); return;\n    case AST_COMPUTED_GOTO: emit_computed_goto(node); return;\n    default:\n        emit_binop(node);\n    }\n}\n\nstatic void emit_zero(int size) {\n    SAVE;\n    for (; size >= 8; size -= 8) emit(\".quad 0\");\n    for (; size >= 4; size -= 4) emit(\".long 0\");\n    for (; size > 0; size--)     emit(\".byte 0\");\n}\n\nstatic void emit_padding(Node *node, int off) {\n    SAVE;\n    int diff = node->initoff - off;\n    assert(diff >= 0);\n    emit_zero(diff);\n}\n\nstatic void emit_data_addr(Node *operand, int depth) {\n    switch (operand->kind) {\n    case AST_LVAR: {\n        char *label = make_label();\n        emit(\".data %d\", depth + 1);\n        emit_label(label);\n        do_emit_data(operand->lvarinit, operand->ty->size, 0, depth + 1);\n        emit(\".data %d\", depth);\n        emit(\".quad %s\", label);\n        return;\n    }\n    case AST_GVAR:\n        emit(\".quad %s\", operand->glabel);\n        return;\n    default:\n        error(\"internal error\");\n    }\n}\n\nstatic void emit_data_charptr(char *s, int depth) {\n    char *label = make_label();\n    emit(\".data %d\", depth + 1);\n    emit_label(label);\n    emit(\".string \\\"%s\\\"\", quote_cstring(s));\n    emit(\".data %d\", depth);\n    emit(\".quad %s\", label);\n}\n\nstatic void emit_data_primtype(Type *ty, Node *val, int depth) {\n    switch (ty->kind) {\n    case KIND_FLOAT: {\n        float f = val->fval;\n        emit(\".long %d\", *(uint32_t *)&f);\n        break;\n    }\n    case KIND_DOUBLE:\n        emit(\".quad %ld\", *(uint64_t *)&val->fval);\n        break;\n    case KIND_BOOL:\n        emit(\".byte %d\", !!eval_intexpr(val, NULL));\n        break;\n    case KIND_CHAR:\n        emit(\".byte %d\", eval_intexpr(val, NULL));\n        break;\n    case KIND_SHORT:\n        emit(\".short %d\", eval_intexpr(val, NULL));\n        break;\n    case KIND_INT:\n        emit(\".long %d\", eval_intexpr(val, NULL));\n        break;\n    case KIND_LONG:\n    case KIND_LLONG:\n    case KIND_PTR:\n        if (val->kind == OP_LABEL_ADDR) {\n            emit(\".quad %s\", val->newlabel);\n            break;\n        }\n        bool is_char_ptr = (val->operand->ty->kind == KIND_ARRAY && val->operand->ty->ptr->kind == KIND_CHAR);\n        if (is_char_ptr) {\n            emit_data_charptr(val->operand->sval, depth);\n        } else if (val->kind == AST_GVAR) {\n            emit(\".quad %s\", val->glabel);\n        } else {\n            Node *base = NULL;\n            int v = eval_intexpr(val, &base);\n            if (base == NULL) {\n                emit(\".quad %u\", v);\n                break;\n            }\n            Type *ty = base->ty;\n            if (base->kind == AST_CONV || base->kind == AST_ADDR)\n                base = base->operand;\n            if (base->kind != AST_GVAR)\n                error(\"global variable expected, but got %s\", node2s(base));\n            assert(ty->ptr);\n            emit(\".quad %s+%u\", base->glabel, v * ty->ptr->size);\n        }\n        break;\n    default:\n        error(\"don't know how to handle\\n  <%s>\\n  <%s>\", ty2s(ty), node2s(val));\n    }\n}\n\nstatic void do_emit_data(Vector *inits, int size, int off, int depth) {\n    SAVE;\n    for (int i = 0; i < vec_len(inits) && 0 < size; i++) {\n        Node *node = vec_get(inits, i);\n        Node *v = node->initval;\n        emit_padding(node, off);\n        if (node->totype->bitsize > 0) {\n            assert(node->totype->bitoff == 0);\n            long data = eval_intexpr(v, NULL);\n            Type *totype = node->totype;\n            for (i++ ; i < vec_len(inits); i++) {\n                node = vec_get(inits, i);\n                if (node->totype->bitsize <= 0) {\n                    break;\n                }\n                v = node->initval;\n                totype = node->totype;\n                data |= ((((long)1 << totype->bitsize) - 1) & eval_intexpr(v, NULL)) << totype->bitoff;\n            }\n            emit_data_primtype(totype, &(Node){ AST_LITERAL, totype, .ival = data }, depth);\n            off += totype->size;\n            size -= totype->size;\n            if (i == vec_len(inits))\n                break;\n        } else {\n            off += node->totype->size;\n            size -= node->totype->size;\n        }\n        if (v->kind == AST_ADDR) {\n            emit_data_addr(v->operand, depth);\n            continue;\n        }\n        if (v->kind == AST_LVAR && v->lvarinit) {\n            do_emit_data(v->lvarinit, v->ty->size, 0, depth);\n            continue;\n        }\n        emit_data_primtype(node->totype, node->initval, depth);\n    }\n    emit_zero(size);\n}\n\nstatic void emit_data(Node *v, int off, int depth) {\n    SAVE;\n    emit(\".data %d\", depth);\n    if (!v->declvar->ty->isstatic)\n        emit_noindent(\".global %s\", v->declvar->glabel);\n    emit_noindent(\"%s:\", v->declvar->glabel);\n    do_emit_data(v->declinit, v->declvar->ty->size, off, depth);\n}\n\nstatic void emit_bss(Node *v) {\n    SAVE;\n    emit(\".data\");\n    if (!v->declvar->ty->isstatic)\n        emit(\".global %s\", v->declvar->glabel);\n    emit(\".lcomm %s, %d\", v->declvar->glabel, v->declvar->ty->size);\n}\n\nstatic void emit_global_var(Node *v) {\n    SAVE;\n    if (v->declinit)\n        emit_data(v, 0, 0);\n    else\n        emit_bss(v);\n}\n\nstatic int emit_regsave_area() {\n    emit(\"sub $%d, #rsp\", REGAREA_SIZE);\n    emit(\"mov #rdi, (#rsp)\");\n    emit(\"mov #rsi, 8(#rsp)\");\n    emit(\"mov #rdx, 16(#rsp)\");\n    emit(\"mov #rcx, 24(#rsp)\");\n    emit(\"mov #r8, 32(#rsp)\");\n    emit(\"mov #r9, 40(#rsp)\");\n    emit(\"movaps #xmm0, 48(#rsp)\");\n    emit(\"movaps #xmm1, 64(#rsp)\");\n    emit(\"movaps #xmm2, 80(#rsp)\");\n    emit(\"movaps #xmm3, 96(#rsp)\");\n    emit(\"movaps #xmm4, 112(#rsp)\");\n    emit(\"movaps #xmm5, 128(#rsp)\");\n    emit(\"movaps #xmm6, 144(#rsp)\");\n    emit(\"movaps #xmm7, 160(#rsp)\");\n    return REGAREA_SIZE;\n}\n\nstatic void push_func_params(Vector *params, int off) {\n    int ireg = 0;\n    int xreg = 0;\n    int arg = 2;\n    for (int i = 0; i < vec_len(params); i++) {\n        Node *v = vec_get(params, i);\n        if (v->ty->kind == KIND_STRUCT) {\n            emit(\"lea %d(#rbp), #rax\", arg * 8);\n            int size = push_struct(v->ty->size);\n            off -= size;\n            arg += size / 8;\n        } else if (is_flotype(v->ty)) {\n            if (xreg >= 8) {\n                emit(\"mov %d(#rbp), #rax\", arg++ * 8);\n                push(\"rax\");\n            } else {\n                push_xmm(xreg++);\n            }\n            off -= 8;\n        } else {\n            if (ireg >= 6) {\n                if (v->ty->kind == KIND_BOOL) {\n                    emit(\"mov %d(#rbp), #al\", arg++ * 8);\n                    emit(\"movzb #al, #eax\");\n                } else {\n                    emit(\"mov %d(#rbp), #rax\", arg++ * 8);\n                }\n                push(\"rax\");\n            } else {\n                if (v->ty->kind == KIND_BOOL)\n                    emit(\"movzb #%s, #%s\", SREGS[ireg], MREGS[ireg]);\n                push(REGS[ireg++]);\n            }\n            off -= 8;\n        }\n        v->loff = off;\n    }\n}\n\nstatic void emit_func_prologue(Node *func) {\n    SAVE;\n    emit(\".text\");\n    if (!func->ty->isstatic)\n        emit_noindent(\".global %s\", func->fname);\n    emit_noindent(\"%s:\", func->fname);\n    emit(\"nop\");\n    push(\"rbp\");\n    emit(\"mov #rsp, #rbp\");\n    int off = 0;\n    if (func->ty->hasva) {\n        set_reg_nums(func->params);\n        off -= emit_regsave_area();\n    }\n    push_func_params(func->params, off);\n    off -= vec_len(func->params) * 8;\n\n    int localarea = 0;\n    for (int i = 0; i < vec_len(func->localvars); i++) {\n        Node *v = vec_get(func->localvars, i);\n        int size = align(v->ty->size, 8);\n        assert(size % 8 == 0);\n        off -= size;\n        v->loff = off;\n        localarea += size;\n    }\n    if (localarea) {\n        emit(\"sub $%d, #rsp\", localarea);\n        stackpos += localarea;\n    }\n}\n\nvoid emit_toplevel(Node *v) {\n    stackpos = 8;\n    if (v->kind == AST_FUNC) {\n        emit_func_prologue(v);\n        emit_expr(v->body);\n        emit_ret();\n    } else if (v->kind == AST_DECL) {\n        emit_global_var(v);\n    } else {\n        error(\"internal error\");\n    }\n}\n"
        },
        {
          "name": "include",
          "type": "tree",
          "content": null
        },
        {
          "name": "keyword.inc",
          "type": "blob",
          "size": 1.8876953125,
          "content": "// Copyright 2012 Rui Ueyama. Released under the MIT license.\n\nop(OP_ARROW, \"->\")\nop(OP_A_ADD, \"+=\")\nop(OP_A_AND, \"&=\")\nop(OP_A_DIV, \"/=\")\nop(OP_A_MOD, \"%=\")\nop(OP_A_MUL, \"*=\")\nop(OP_A_OR, \"|=\")\nop(OP_A_SAL, \"<<=\")\nop(OP_A_SAR, \">>=\")\nop(OP_A_SUB, \"-=\")\nop(OP_A_XOR, \"^=\")\nop(OP_DEC, \"--\")\nop(OP_EQ, \"==\")\nop(OP_GE, \">=\")\nop(OP_INC, \"++\")\nop(OP_LE, \"<=\")\nop(OP_LOGAND, \"&&\")\nop(OP_LOGOR, \"||\")\nop(OP_NE, \"!=\")\nop(OP_SAL, \"<<\")\nop(OP_SAR, \">>\")\n\nkeyword(KALIGNAS, \"_Alignas\", true)\nkeyword(KALIGNOF, \"_Alignof\", false)\nkeyword(KAUTO, \"auto\", true)\nkeyword(KBOOL, \"_Bool\", true)\nkeyword(KBREAK, \"break\", false)\nkeyword(KCASE, \"case\", false)\nkeyword(KCHAR, \"char\", true)\nkeyword(KCOMPLEX, \"_Complex\", true)\nkeyword(KCONST, \"const\", true)\nkeyword(KCONTINUE, \"continue\", false)\nkeyword(KDEFAULT, \"default\", false)\nkeyword(KDO, \"do\", false)\nkeyword(KDOUBLE, \"double\", true)\nkeyword(KELSE, \"else\", false)\nkeyword(KENUM, \"enum\", true)\nkeyword(KEXTERN, \"extern\", true)\nkeyword(KFLOAT, \"float\", true)\nkeyword(KFOR, \"for\", false)\nkeyword(KGENERIC, \"_Generic\", false)\nkeyword(KGOTO, \"goto\", false)\nkeyword(KIF, \"if\", false)\nkeyword(KIMAGINARY, \"_Imaginary\", true)\nkeyword(KINLINE, \"inline\", true)\nkeyword(KINT, \"int\", true)\nkeyword(KLONG, \"long\", true)\nkeyword(KNORETURN, \"_Noreturn\", true)\nkeyword(KREGISTER, \"register\", true)\nkeyword(KRESTRICT, \"restrict\", true)\nkeyword(KRETURN, \"return\", false)\nkeyword(KHASHHASH, \"##\", false)\nkeyword(KSHORT, \"short\", true)\nkeyword(KSIGNED, \"signed\", true)\nkeyword(KSIZEOF, \"sizeof\", false)\nkeyword(KSTATIC, \"static\", true)\nkeyword(KSTATIC_ASSERT, \"_Static_assert\", false)\nkeyword(KSTRUCT, \"struct\", true)\nkeyword(KSWITCH, \"switch\", false)\nkeyword(KELLIPSIS, \"...\", false)\nkeyword(KTYPEDEF, \"typedef\", true)\nkeyword(KTYPEOF, \"typeof\", true)\nkeyword(KUNION, \"union\", true)\nkeyword(KUNSIGNED, \"unsigned\", true)\nkeyword(KVOID, \"void\", true)\nkeyword(KVOLATILE, \"volatile\", true)\nkeyword(KWHILE, \"while\", false)\n"
        },
        {
          "name": "lex.c",
          "type": "blob",
          "size": 17.43359375,
          "content": "// Copyright 2012 Rui Ueyama. Released under the MIT license.\n\n/*\n * Tokenizer\n *\n * This is a translation phase after the phase 1 and 2 in file.c.\n * In this phase, the source code is decomposed into preprocessing tokens.\n *\n * Each comment is treated as if it were a space character.\n * Space characters are removed, but the presence of the characters is\n * recorded to the token that immediately follows the spaces as a boolean flag.\n * Newlines are converted to newline tokens.\n *\n * Note that the pp-token is different from the regular token.\n * A keyword, such as \"if\", is just an identifier at this stage.\n * The definition of the pp-token is usually more relaxed than\n * the regular one. For example, \".32e.\" is a valid pp-number.\n * Pp-tokens are converted to regular tokens by the C preprocesor\n * (and invalid tokens are rejected by that).\n * Some tokens are removed by the preprocessor (e.g. newline).\n * For more information about pp-tokens, see C11 6.4 \"Lexical Elements\".\n */\n\n#include <ctype.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"8cc.h\"\n\nstatic Vector *buffers = &EMPTY_VECTOR;\nstatic Token *space_token = &(Token){ TSPACE };\nstatic Token *newline_token = &(Token){ TNEWLINE };\nstatic Token *eof_token = &(Token){ TEOF };\n\ntypedef struct {\n    int line;\n    int column;\n} Pos;\n\nstatic Pos pos;\n\nstatic char *pos_string(Pos *p) {\n    File *f = current_file();\n    return format(\"%s:%d:%d\", f ? f->name : \"(unknown)\", p->line, p->column);\n}\n\n#define errorp(p, ...) errorf(__FILE__ \":\" STR(__LINE__), pos_string(&p), __VA_ARGS__)\n#define warnp(p, ...)  warnf(__FILE__ \":\" STR(__LINE__), pos_string(&p), __VA_ARGS__)\n\nstatic void skip_block_comment(void);\n\nvoid lex_init(char *filename) {\n    vec_push(buffers, make_vector());\n    if (!strcmp(filename, \"-\")) {\n        stream_push(make_file(stdin, \"-\"));\n        return;\n    }\n    FILE *fp = fopen(filename, \"r\");\n    if (!fp)\n        error(\"Cannot open %s: %s\", filename, strerror(errno));\n    stream_push(make_file(fp, filename));\n}\n\nstatic Pos get_pos(int delta) {\n    File *f = current_file();\n    return (Pos){ f->line, f->column + delta };\n}\n\nstatic void mark() {\n    pos = get_pos(0);\n}\n\nstatic Token *make_token(Token *tmpl) {\n    Token *r = malloc(sizeof(Token));\n    *r = *tmpl;\n    r->hideset = NULL;\n    File *f = current_file();\n    r->file = f;\n    r->line = pos.line;\n    r->column = pos.column;\n    r->count = f->ntok++;\n    return r;\n}\n\nstatic Token *make_ident(char *p) {\n    return make_token(&(Token){ TIDENT, .sval = p });\n}\n\nstatic Token *make_strtok(char *s, int len, int enc) {\n    return make_token(&(Token){ TSTRING, .sval = s, .slen = len, .enc = enc });\n}\n\nstatic Token *make_keyword(int id) {\n    return make_token(&(Token){ TKEYWORD, .id = id });\n}\n\nstatic Token *make_number(char *s) {\n    return make_token(&(Token){ TNUMBER, .sval = s });\n}\n\nstatic Token *make_invalid(char c) {\n    return make_token(&(Token){ TINVALID, .c = c });\n}\n\nstatic Token *make_char(int c, int enc) {\n    return make_token(&(Token){ TCHAR, .c = c, .enc = enc });\n}\n\nstatic bool iswhitespace(int c) {\n    return c == ' ' || c == '\\t' || c == '\\f' || c == '\\v';\n}\n\nstatic int peek() {\n    int r = readc();\n    unreadc(r);\n    return r;\n}\n\nstatic bool next(int expect) {\n    int c = readc();\n    if (c == expect)\n        return true;\n    unreadc(c);\n    return false;\n}\n\nstatic void skip_line() {\n    for (;;) {\n        int c = readc();\n        if (c == EOF)\n            return;\n        if (c == '\\n') {\n            unreadc(c);\n            return;\n        }\n    }\n}\n\nstatic bool do_skip_space() {\n    int c = readc();\n    if (c == EOF)\n        return false;\n    if (iswhitespace(c))\n        return true;\n    if (c == '/') {\n        if (next('*')) {\n            skip_block_comment();\n            return true;\n        }\n        if (next('/')) {\n            skip_line();\n            return true;\n        }\n    }\n    unreadc(c);\n    return false;\n}\n\n// Skips spaces including comments.\n// Returns true if at least one space is skipped.\nstatic bool skip_space() {\n    if (!do_skip_space())\n        return false;\n    while (do_skip_space());\n    return true;\n}\n\nstatic void skip_char() {\n    if (readc() == '\\\\')\n        readc();\n    int c = readc();\n    while (c != EOF && c != '\\'')\n        c = readc();\n}\n\nstatic void skip_string() {\n    for (int c = readc(); c != EOF && c != '\"'; c = readc())\n        if (c == '\\\\')\n            readc();\n}\n\n// Skips a block of code excluded from input by #if, #ifdef and the like.\n// C11 6.10 says that code within #if and #endif needs to be a sequence of\n// valid tokens even if skipped. However, in reality, most compilers don't\n// tokenize nor validate contents. We don't do that, too.\n// This function is to skip code until matching #endif as fast as we can.\nvoid skip_cond_incl() {\n    int nest = 0;\n    for (;;) {\n        bool bol = (current_file()->column == 1);\n        skip_space();\n        int c = readc();\n        if (c == EOF)\n            return;\n        if (c == '\\'') {\n            skip_char();\n            continue;\n        }\n        if (c == '\\\"') {\n            skip_string();\n            continue;\n        }\n        if (c != '#' || !bol)\n            continue;\n        int column = current_file()->column - 1;\n        Token *tok = lex();\n        if (tok->kind != TIDENT)\n            continue;\n        if (!nest && (is_ident(tok, \"else\") || is_ident(tok, \"elif\") || is_ident(tok, \"endif\"))) {\n            unget_token(tok);\n            Token *hash = make_keyword('#');\n            hash->bol = true;\n            hash->column = column;\n            unget_token(hash);\n            return;\n        }\n        if (is_ident(tok, \"if\") || is_ident(tok, \"ifdef\") || is_ident(tok, \"ifndef\"))\n            nest++;\n        else if (nest && is_ident(tok, \"endif\"))\n            nest--;\n        skip_line();\n    }\n}\n\n// Reads a number literal. Lexer's grammar on numbers is not strict.\n// Integers and floating point numbers and different base numbers are not distinguished.\nstatic Token *read_number(char c) {\n    Buffer *b = make_buffer();\n    buf_write(b, c);\n    char last = c;\n    for (;;) {\n        int c = readc();\n        bool flonum = strchr(\"eEpP\", last) && strchr(\"+-\", c);\n        if (!isdigit(c) && !isalpha(c) && c != '.' && !flonum) {\n            unreadc(c);\n            buf_write(b, '\\0');\n            return make_number(buf_body(b));\n        }\n        buf_write(b, c);\n        last = c;\n    }\n}\n\nstatic bool nextoct() {\n    int c = peek();\n    return '0' <= c && c <= '7';\n}\n\n// Reads an octal escape sequence.\nstatic int read_octal_char(int c) {\n    int r = c - '0';\n    if (!nextoct())\n        return r;\n    r = (r << 3) | (readc() - '0');\n    if (!nextoct())\n        return r;\n    return (r << 3) | (readc() - '0');\n}\n\n// Reads a \\x escape sequence.\nstatic int read_hex_char() {\n    Pos p = get_pos(-2);\n    int c = readc();\n    if (!isxdigit(c))\n        errorp(p, \"\\\\x is not followed by a hexadecimal character: %c\", c);\n    int r = 0;\n    for (;; c = readc()) {\n        switch (c) {\n        case '0' ... '9': r = (r << 4) | (c - '0'); continue;\n        case 'a' ... 'f': r = (r << 4) | (c - 'a' + 10); continue;\n        case 'A' ... 'F': r = (r << 4) | (c - 'A' + 10); continue;\n        default: unreadc(c); return r;\n        }\n    }\n}\n\nstatic bool is_valid_ucn(unsigned int c) {\n    // C11 6.4.3p2: U+D800 to U+DFFF are reserved for surrogate pairs.\n    // A codepoint within the range cannot be a valid character.\n    if (0xD800 <= c && c <= 0xDFFF)\n        return false;\n    // It's not allowed to encode ASCII characters using \\U or \\u.\n    // Some characters not in the basic character set (C11 5.2.1p3)\n    // are allowed as exceptions.\n    return 0xA0 <= c || c == '$' || c == '@' || c == '`';\n}\n\n// Reads \\u or \\U escape sequences. len is 4 or 8, respecitvely.\nstatic int read_universal_char(int len) {\n    Pos p = get_pos(-2);\n    unsigned int r = 0;\n    for (int i = 0; i < len; i++) {\n        char c = readc();\n        switch (c) {\n        case '0' ... '9': r = (r << 4) | (c - '0'); continue;\n        case 'a' ... 'f': r = (r << 4) | (c - 'a' + 10); continue;\n        case 'A' ... 'F': r = (r << 4) | (c - 'A' + 10); continue;\n        default: errorp(p, \"invalid universal character: %c\", c);\n        }\n    }\n    if (!is_valid_ucn(r))\n        errorp(p, \"invalid universal character: \\\\%c%0*x\", (len == 4) ? 'u' : 'U', len, r);\n    return r;\n}\n\nstatic int read_escaped_char() {\n    Pos p = get_pos(-1);\n    int c = readc();\n    // This switch-cases is an interesting example of magical aspects\n    // of self-hosting compilers. Here, we teach the compiler about\n    // escaped sequences using escaped sequences themselves.\n    // This is a tautology. The information about their real character\n    // codes is not present in the source code but propagated from\n    // a compiler compiling the source code.\n    // See \"Reflections on Trusting Trust\" by Ken Thompson for more info.\n    // http://cm.bell-labs.com/who/ken/trust.html\n    switch (c) {\n    case '\\'': case '\"': case '?': case '\\\\':\n        return c;\n    case 'a': return '\\a';\n    case 'b': return '\\b';\n    case 'f': return '\\f';\n    case 'n': return '\\n';\n    case 'r': return '\\r';\n    case 't': return '\\t';\n    case 'v': return '\\v';\n    case 'e': return '\\033';  // '\\e' is GNU extension\n    case 'x': return read_hex_char();\n    case 'u': return read_universal_char(4);\n    case 'U': return read_universal_char(8);\n    case '0' ... '7': return read_octal_char(c);\n    }\n    warnp(p, \"unknown escape character: \\\\%c\", c);\n    return c;\n}\n\nstatic Token *read_char(int enc) {\n    int c = readc();\n    int r = (c == '\\\\') ? read_escaped_char() : c;\n    c = readc();\n    if (c != '\\'')\n        errorp(pos, \"unterminated char\");\n    if (enc == ENC_NONE)\n        return make_char((char)r, enc);\n    return make_char(r, enc);\n}\n\n// Reads a string literal.\nstatic Token *read_string(int enc) {\n    Buffer *b = make_buffer();\n    for (;;) {\n        int c = readc();\n        if (c == EOF)\n            errorp(pos, \"unterminated string\");\n        if (c == '\"')\n            break;\n        if (c != '\\\\') {\n            buf_write(b, c);\n            continue;\n        }\n        bool isucs = (peek() == 'u' || peek() == 'U');\n        c = read_escaped_char();\n        if (isucs) {\n            write_utf8(b, c);\n            continue;\n        }\n        buf_write(b, c);\n    }\n    buf_write(b, '\\0');\n    return make_strtok(buf_body(b), buf_len(b), enc);\n}\n\nstatic Token *read_ident(char c) {\n    Buffer *b = make_buffer();\n    buf_write(b, c);\n    for (;;) {\n        c = readc();\n        if (isalnum(c) || (c & 0x80) || c == '_' || c == '$') {\n            buf_write(b, c);\n            continue;\n        }\n        // C11 6.4.2.1: \\u or \\U characters (universal-character-name)\n        // are allowed to be part of identifiers.\n        if (c == '\\\\' && (peek() == 'u' || peek() == 'U')) {\n            write_utf8(b, read_escaped_char());\n            continue;\n        }\n        unreadc(c);\n        buf_write(b, '\\0');\n        return make_ident(buf_body(b));\n    }\n}\n\nstatic void skip_block_comment() {\n    Pos p = get_pos(-2);\n    bool maybe_end = false;\n    for (;;) {\n        int c = readc();\n        if (c == EOF)\n            errorp(p, \"premature end of block comment\");\n        if (c == '/' && maybe_end)\n            return;\n        maybe_end = (c == '*');\n    }\n}\n\n// Reads a digraph starting with '%'. Digraphs are alternative spellings\n// for some punctuation characters. They are useless in ASCII.\n// We implement this just for the standard compliance.\n// See C11 6.4.6p3 for the spec.\nstatic Token *read_hash_digraph() {\n    if (next('>'))\n        return make_keyword('}');\n    if (next(':')) {\n        if (next('%')) {\n            if (next(':'))\n                return make_keyword(KHASHHASH);\n            unreadc('%');\n        }\n        return make_keyword('#');\n    }\n    return NULL;\n}\n\nstatic Token *read_rep(char expect, int t1, int els) {\n    return make_keyword(next(expect) ? t1 : els);\n}\n\nstatic Token *read_rep2(char expect1, int t1, char expect2, int t2, char els) {\n    if (next(expect1))\n        return make_keyword(t1);\n    return make_keyword(next(expect2) ? t2 : els);\n}\n\nstatic Token *do_read_token() {\n    if (skip_space())\n        return space_token;\n    mark();\n    int c = readc();\n    switch (c) {\n    case '\\n': return newline_token;\n    case ':': return make_keyword(next('>') ? ']' : ':');\n    case '#': return make_keyword(next('#') ? KHASHHASH : '#');\n    case '+': return read_rep2('+', OP_INC, '=', OP_A_ADD, '+');\n    case '*': return read_rep('=', OP_A_MUL, '*');\n    case '=': return read_rep('=', OP_EQ, '=');\n    case '!': return read_rep('=', OP_NE, '!');\n    case '&': return read_rep2('&', OP_LOGAND, '=', OP_A_AND, '&');\n    case '|': return read_rep2('|', OP_LOGOR, '=', OP_A_OR, '|');\n    case '^': return read_rep('=', OP_A_XOR, '^');\n    case '\"': return read_string(ENC_NONE);\n    case '\\'': return read_char(ENC_NONE);\n    case '/': return make_keyword(next('=') ? OP_A_DIV : '/');\n    case 'a' ... 't': case 'v' ... 'z': case 'A' ... 'K':\n    case 'M' ... 'T': case 'V' ... 'Z': case '_': case '$':\n    case 0x80 ... 0xFD:\n        return read_ident(c);\n    case '0' ... '9':\n        return read_number(c);\n    case 'L': case 'U': {\n        // Wide/char32_t character/string literal\n        int enc = (c == 'L') ? ENC_WCHAR : ENC_CHAR32;\n        if (next('\"'))  return read_string(enc);\n        if (next('\\'')) return read_char(enc);\n        return read_ident(c);\n    }\n    case 'u':\n        if (next('\"')) return read_string(ENC_CHAR16);\n        if (next('\\'')) return read_char(ENC_CHAR16);\n        // C11 6.4.5: UTF-8 string literal\n        if (next('8')) {\n            if (next('\"'))\n                return read_string(ENC_UTF8);\n            unreadc('8');\n        }\n        return read_ident(c);\n    case '.':\n        if (isdigit(peek()))\n            return read_number(c);\n        if (next('.')) {\n            if (next('.'))\n                return make_keyword(KELLIPSIS);\n            return make_ident(\"..\");\n        }\n        return make_keyword('.');\n    case '(': case ')': case ',': case ';': case '[': case ']': case '{':\n    case '}': case '?': case '~':\n        return make_keyword(c);\n    case '-':\n        if (next('-')) return make_keyword(OP_DEC);\n        if (next('>')) return make_keyword(OP_ARROW);\n        if (next('=')) return make_keyword(OP_A_SUB);\n        return make_keyword('-');\n    case '<':\n        if (next('<')) return read_rep('=', OP_A_SAL, OP_SAL);\n        if (next('=')) return make_keyword(OP_LE);\n        if (next(':')) return make_keyword('[');\n        if (next('%')) return make_keyword('{');\n        return make_keyword('<');\n    case '>':\n        if (next('=')) return make_keyword(OP_GE);\n        if (next('>')) return read_rep('=', OP_A_SAR, OP_SAR);\n        return make_keyword('>');\n    case '%': {\n        Token *tok = read_hash_digraph();\n        if (tok)\n            return tok;\n        return read_rep('=', OP_A_MOD, '%');\n    }\n    case EOF:\n        return eof_token;\n    default: return make_invalid(c);\n    }\n}\n\nstatic bool buffer_empty() {\n    return vec_len(buffers) == 1 && vec_len(vec_head(buffers)) == 0;\n}\n\n// Reads a header file name for #include.\n//\n// Filenames after #include need a special tokenization treatment.\n// A filename string may be quoted by < and > instead of \"\".\n// Even if it's quoted by \"\", it's still different from a regular string token.\n// For example, \\ in this context is not interpreted as a quote.\n// Thus, we cannot use lex() to read a filename.\n//\n// That the C preprocessor requires a special lexer behavior only for\n// #include is a violation of layering. Ideally, the lexer should be\n// agnostic about higher layers status. But we need this for the C grammar.\nchar *read_header_file_name(bool *std) {\n    if (!buffer_empty())\n        return NULL;\n    skip_space();\n    Pos p = get_pos(0);\n    char close;\n    if (next('\"')) {\n        *std = false;\n        close = '\"';\n    } else if (next('<')) {\n        *std = true;\n        close = '>';\n    } else {\n        return NULL;\n    }\n    Buffer *b = make_buffer();\n    while (!next(close)) {\n        int c = readc();\n        if (c == EOF || c == '\\n')\n            errorp(p, \"premature end of header name\");\n        buf_write(b, c);\n    }\n    if (buf_len(b) == 0)\n        errorp(p, \"header name should not be empty\");\n    buf_write(b, '\\0');\n    return buf_body(b);\n}\n\nbool is_keyword(Token *tok, int c) {\n    return (tok->kind == TKEYWORD) && (tok->id == c);\n}\n\n// Temporarily switches the input token stream to given list of tokens,\n// so that you can get the tokens as return values of lex() again.\n// After the tokens are exhausted, EOF is returned from lex() until\n// \"unstash\" is called to restore the original state.\nvoid token_buffer_stash(Vector *buf) {\n    vec_push(buffers, buf);\n}\n\nvoid token_buffer_unstash() {\n    vec_pop(buffers);\n}\n\nvoid unget_token(Token *tok) {\n    if (tok->kind == TEOF)\n        return;\n    Vector *buf = vec_tail(buffers);\n    vec_push(buf, tok);\n}\n\n// Reads a token from a given string.\n// This function temporarily switches the main input stream to\n// a given string and reads one token.\nToken *lex_string(char *s) {\n    stream_stash(make_file_string(s));\n    Token *r = do_read_token();\n    next('\\n');\n    Pos p = get_pos(0);\n    if (peek() != EOF)\n        errorp(p, \"unconsumed input: %s\", s);\n    stream_unstash();\n    return r;\n}\n\nToken *lex() {\n    Vector *buf = vec_tail(buffers);\n    if (vec_len(buf) > 0)\n        return vec_pop(buf);\n    if (vec_len(buffers) > 1)\n        return eof_token;\n    bool bol = (current_file()->column == 1);\n    Token *tok = do_read_token();\n    while (tok->kind == TSPACE) {\n        tok = do_read_token();\n        tok->space = true;\n    }\n    tok->bol = bol;\n    return tok;\n}\n"
        },
        {
          "name": "main.c",
          "type": "blob",
          "size": 5.6943359375,
          "content": "// Copyright 2012 Rui Ueyama. Released under the MIT license.\n\n#include <libgen.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include \"8cc.h\"\n\nstatic char *infile;\nstatic char *outfile;\nstatic char *asmfile;\nstatic bool dumpast;\nstatic bool cpponly;\nstatic bool dumpasm;\nstatic bool dontlink;\nstatic Buffer *cppdefs;\nstatic Vector *tmpfiles = &EMPTY_VECTOR;\n\nstatic void usage(int exitcode) {\n    fprintf(exitcode ? stderr : stdout,\n            \"Usage: 8cc [ -E ][ -a ] [ -h ] <file>\\n\\n\"\n            \"\\n\"\n            \"  -I<path>          add to include path\\n\"\n            \"  -E                print preprocessed source code\\n\"\n            \"  -D name           Predefine name as a macro\\n\"\n            \"  -D name=def\\n\"\n            \"  -S                Stop before assembly (default)\\n\"\n            \"  -c                Do not run linker (default)\\n\"\n            \"  -U name           Undefine name\\n\"\n            \"  -fdump-ast        print AST\\n\"\n            \"  -fdump-stack      Print stacktrace\\n\"\n            \"  -fno-dump-source  Do not emit source code as assembly comment\\n\"\n            \"  -o filename       Output to the specified file\\n\"\n            \"  -g                Do nothing at this moment\\n\"\n            \"  -Wall             Enable all warnings\\n\"\n            \"  -Werror           Make all warnings into errors\\n\"\n            \"  -O<number>        Does nothing at this moment\\n\"\n            \"  -m64              Output 64-bit code (default)\\n\"\n            \"  -w                Disable all warnings\\n\"\n            \"  -h                print this help\\n\"\n            \"\\n\"\n            \"One of -a, -c, -E or -S must be specified.\\n\\n\");\n    exit(exitcode);\n}\n\nstatic void delete_temp_files() {\n    for (int i = 0; i < vec_len(tmpfiles); i++)\n        unlink(vec_get(tmpfiles, i));\n}\n\nstatic char *base(char *path) {\n    return basename(strdup(path));\n}\n\nstatic char *replace_suffix(char *filename, char suffix) {\n    char *r = format(\"%s\", filename);\n    char *p = r + strlen(r) - 1;\n    if (*p != 'c')\n        error(\"filename suffix is not .c\");\n    *p = suffix;\n    return r;\n}\n\nstatic FILE *open_asmfile() {\n    if (dumpasm) {\n        asmfile = outfile ? outfile : replace_suffix(base(infile), 's');\n    } else {\n        asmfile = format(\"/tmp/8ccXXXXXX.s\");\n        if (!mkstemps(asmfile, 2))\n            perror(\"mkstemps\");\n        vec_push(tmpfiles, asmfile);\n    }\n    if (!strcmp(asmfile, \"-\"))\n        return stdout;\n    FILE *fp = fopen(asmfile, \"w\");\n    if (!fp)\n        perror(\"fopen\");\n    return fp;\n}\n\nstatic void parse_warnings_arg(char *s) {\n    if (!strcmp(s, \"error\"))\n        warning_is_error = true;\n    else if (strcmp(s, \"all\"))\n        error(\"unknown -W option: %s\", s);\n}\n\nstatic void parse_f_arg(char *s) {\n    if (!strcmp(s, \"dump-ast\"))\n        dumpast = true;\n    else if (!strcmp(s, \"dump-stack\"))\n        dumpstack = true;\n    else if (!strcmp(s, \"no-dump-source\"))\n        dumpsource = false;\n    else\n        usage(1);\n}\n\nstatic void parse_m_arg(char *s) {\n    if (strcmp(s, \"64\"))\n        error(\"Only 64 is allowed for -m, but got %s\", s);\n}\n\nstatic void parseopt(int argc, char **argv) {\n    cppdefs = make_buffer();\n    for (;;) {\n        int opt = getopt(argc, argv, \"I:ED:O:SU:W:acd:f:gm:o:hw\");\n        if (opt == -1)\n            break;\n        switch (opt) {\n        case 'I': add_include_path(optarg); break;\n        case 'E': cpponly = true; break;\n        case 'D': {\n            char *p = strchr(optarg, '=');\n            if (p)\n                *p = ' ';\n            buf_printf(cppdefs, \"#define %s\\n\", optarg);\n            break;\n        }\n        case 'O': break;\n        case 'S': dumpasm = true; break;\n        case 'U':\n            buf_printf(cppdefs, \"#undef %s\\n\", optarg);\n            break;\n        case 'W': parse_warnings_arg(optarg); break;\n        case 'c': dontlink = true; break;\n        case 'f': parse_f_arg(optarg); break;\n        case 'm': parse_m_arg(optarg); break;\n        case 'g': break;\n        case 'o': outfile = optarg; break;\n        case 'w': enable_warning = false; break;\n        case 'h':\n            usage(0);\n        default:\n            usage(1);\n        }\n    }\n    if (optind != argc - 1)\n        usage(1);\n\n    if (!dumpast && !cpponly && !dumpasm && !dontlink)\n        error(\"One of -a, -c, -E or -S must be specified\");\n    infile = argv[optind];\n}\n\nchar *get_base_file() {\n    return infile;\n}\n\nstatic void preprocess() {\n    for (;;) {\n        Token *tok = read_token();\n        if (tok->kind == TEOF)\n            break;\n        if (tok->bol)\n            printf(\"\\n\");\n        if (tok->space)\n            printf(\" \");\n        printf(\"%s\", tok2s(tok));\n    }\n    printf(\"\\n\");\n    exit(0);\n}\n\nint main(int argc, char **argv) {\n    setbuf(stdout, NULL);\n    if (atexit(delete_temp_files))\n        perror(\"atexit\");\n    parseopt(argc, argv);\n    lex_init(infile);\n    cpp_init();\n    parse_init();\n    set_output_file(open_asmfile());\n    if (buf_len(cppdefs) > 0)\n        read_from_string(buf_body(cppdefs));\n\n    if (cpponly)\n        preprocess();\n\n    Vector *toplevels = read_toplevels();\n    for (int i = 0; i < vec_len(toplevels); i++) {\n        Node *v = vec_get(toplevels, i);\n        if (dumpast)\n            printf(\"%s\", node2s(v));\n        else\n            emit_toplevel(v);\n    }\n\n    close_output_file();\n\n    if (!dumpast && !dumpasm) {\n        if (!outfile)\n            outfile = replace_suffix(base(infile), 'o');\n        pid_t pid = fork();\n        if (pid < 0) perror(\"fork\");\n        if (pid == 0) {\n            execlp(\"as\", \"as\", \"-o\", outfile, \"-c\", asmfile, (char *)NULL);\n            perror(\"execl failed\");\n        }\n        int status;\n        waitpid(pid, &status, 0);\n        if (status < 0)\n            error(\"as failed\");\n    }\n    return 0;\n}\n"
        },
        {
          "name": "map.c",
          "type": "blob",
          "size": 3.0927734375,
          "content": "// Copyright 2014 Rui Ueyama. Released under the MIT license.\n\n// This is an implementation of hash table.\n\n#include <stdlib.h>\n#include <string.h>\n#include \"8cc.h\"\n\n#define INIT_SIZE 16\n#define TOMBSTONE ((void *)-1)\n\nstatic uint32_t hash(char *p) {\n    // FNV hash\n    uint32_t r = 2166136261;\n    for (; *p; p++) {\n        r ^= *p;\n        r *= 16777619;\n    }\n    return r;\n}\n\nstatic Map *do_make_map(Map *parent, int size) {\n    Map *r = malloc(sizeof(Map));\n    r->parent = parent;\n    r->key = calloc(size, sizeof(char *));\n    r->val = calloc(size, sizeof(void *));\n    r->size = size;\n    r->nelem = 0;\n    r->nused = 0;\n    return r;\n}\n\nstatic void maybe_rehash(Map *m) {\n    if (!m->key) {\n        m->key = calloc(INIT_SIZE, sizeof(char *));\n        m->val = calloc(INIT_SIZE, sizeof(void *));\n        m->size = INIT_SIZE;\n        return;\n    }\n    if (m->nused < m->size * 0.7)\n        return;\n    int newsize = (m->nelem < m->size * 0.35) ? m->size : m->size * 2;\n    char **k = calloc(newsize, sizeof(char *));\n    void **v = calloc(newsize, sizeof(void *));\n    int mask = newsize - 1;\n    for (int i = 0; i < m->size; i++) {\n        if (m->key[i] == NULL || m->key[i] == TOMBSTONE)\n            continue;\n        int j = hash(m->key[i]) & mask;\n        for (;; j = (j + 1) & mask) {\n            if (k[j] != NULL)\n                continue;\n            k[j] = m->key[i];\n            v[j] = m->val[i];\n            break;\n        }\n    }\n    m->key = k;\n    m->val = v;\n    m->size = newsize;\n    m->nused = m->nelem;\n}\n\nMap *make_map() {\n    return do_make_map(NULL, INIT_SIZE);\n}\n\nMap *make_map_parent(Map *parent) {\n    return do_make_map(parent, INIT_SIZE);\n}\n\nstatic void *map_get_nostack(Map *m, char *key) {\n    if (!m->key)\n        return NULL;\n    int mask = m->size - 1;\n    int i = hash(key) & mask;\n    for (; m->key[i] != NULL; i = (i + 1) & mask)\n        if (m->key[i] != TOMBSTONE && !strcmp(m->key[i], key))\n            return m->val[i];\n    return NULL;\n}\n\nvoid *map_get(Map *m, char *key) {\n    void *r = map_get_nostack(m, key);\n    if (r)\n        return r;\n    // Map is stackable. If no value is found,\n    // continue searching from the parent.\n    if (m->parent)\n        return map_get(m->parent, key);\n    return NULL;\n}\n\nvoid map_put(Map *m, char *key, void *val) {\n    maybe_rehash(m);\n    int mask = m->size - 1;\n    int i = hash(key) & mask;\n    for (;; i = (i + 1) & mask) {\n        char *k = m->key[i];\n        if (k == NULL || k == TOMBSTONE) {\n            m->key[i] = key;\n            m->val[i] = val;\n            m->nelem++;\n            if (k == NULL)\n                m->nused++;\n            return;\n        }\n        if (!strcmp(k, key)) {\n            m->val[i] = val;\n            return;\n        }\n    }\n}\n\nvoid map_remove(Map *m, char *key) {\n    if (!m->key)\n        return;\n    int mask = m->size - 1;\n    int i = hash(key) & mask;\n    for (; m->key[i] != NULL; i = (i + 1) & mask) {\n        if (m->key[i] == TOMBSTONE || strcmp(m->key[i], key))\n            continue;\n        m->key[i] = TOMBSTONE;\n        m->val[i] = NULL;\n        m->nelem--;\n        return;\n    }\n}\n\nsize_t map_len(Map *m) {\n    return m->nelem;\n}\n"
        },
        {
          "name": "parse.c",
          "type": "blob",
          "size": 80.36328125,
          "content": "// Copyright 2012 Rui Ueyama. Released under the MIT license.\n\n/*\n * Recursive descendent parser for C.\n */\n\n#include <ctype.h>\n#include <errno.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <string.h>\n#include <strings.h>\n#include \"8cc.h\"\n\n// The largest alignment requirement on x86-64. When we are allocating memory\n// for an array whose type is unknown, the array will be aligned to this\n// boundary.\n#define MAX_ALIGN 16\n\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n\n// The last source location we want to point to when we find an error in the\n// source code.\nSourceLoc *source_loc;\n\n// Objects representing various scopes. Did you know C has so many different\n// scopes? You can use the same name for global variable, local variable,\n// struct/union/enum tag, and goto label!\nstatic Map *globalenv = &EMPTY_MAP;\nstatic Map *localenv;\nstatic Map *tags = &EMPTY_MAP;\nstatic Map *labels;\n\nstatic Vector *toplevels;\nstatic Vector *localvars;\nstatic Vector *gotos;\nstatic Vector *cases;\nstatic Type *current_func_type;\n\nstatic char *defaultcase;\nstatic char *lbreak;\nstatic char *lcontinue;\n\n// Objects representing basic types. All variables will be of one of these types\n// or a derived type from one of them. Note that (typename){initializer} is C99\n// feature to write struct literals.\nType *type_void = &(Type){ KIND_VOID, 0, 0, false };\nType *type_bool = &(Type){ KIND_BOOL, 1, 1, true };\nType *type_char = &(Type){ KIND_CHAR, 1, 1, false };\nType *type_short = &(Type){ KIND_SHORT, 2, 2, false };\nType *type_int = &(Type){ KIND_INT, 4, 4, false };\nType *type_long = &(Type){ KIND_LONG, 8, 8, false };\nType *type_llong = &(Type){ KIND_LLONG, 8, 8, false };\nType *type_uchar = &(Type){ KIND_CHAR, 1, 1, true };\nType *type_ushort = &(Type){ KIND_SHORT, 2, 2, true };\nType *type_uint = &(Type){ KIND_INT, 4, 4, true };\nType *type_ulong = &(Type){ KIND_LONG, 8, 8, true };\nType *type_ullong = &(Type){ KIND_LLONG, 8, 8, true };\nType *type_float = &(Type){ KIND_FLOAT, 4, 4, false };\nType *type_double = &(Type){ KIND_DOUBLE, 8, 8, false };\nType *type_ldouble = &(Type){ KIND_LDOUBLE, 8, 8, false };\nType *type_enum = &(Type){ KIND_ENUM, 4, 4, false };\n\nstatic Type* make_ptr_type(Type *ty);\nstatic Type* make_array_type(Type *ty, int size);\nstatic Node *read_compound_stmt(void);\nstatic void read_decl_or_stmt(Vector *list);\nstatic Node *conv(Node *node);\nstatic Node *read_stmt(void);\nstatic bool is_type(Token *tok);\nstatic Node *read_unary_expr(void);\nstatic void read_decl(Vector *toplevel, bool isglobal);\nstatic Type *read_declarator_tail(Type *basetype, Vector *params);\nstatic Type *read_declarator(char **name, Type *basetype, Vector *params, int ctx);\nstatic Type *read_abstract_declarator(Type *basetype);\nstatic Type *read_decl_spec(int *sclass);\nstatic Node *read_struct_field(Node *struc);\nstatic void read_initializer_list(Vector *inits, Type *ty, int off, bool designated);\nstatic Type *read_cast_type(void);\nstatic Vector *read_decl_init(Type *ty);\nstatic Node *read_boolean_expr(void);\nstatic Node *read_expr_opt(void);\nstatic Node *read_conditional_expr(void);\nstatic Node *read_assignment_expr(void);\nstatic Node *read_cast_expr(void);\nstatic Node *read_comma_expr(void);\nstatic Token *get(void);\nstatic Token *peek(void);\n\ntypedef struct {\n    int beg;\n    int end;\n    char *label;\n} Case;\n\nenum {\n    S_TYPEDEF = 1,\n    S_EXTERN,\n    S_STATIC,\n    S_AUTO,\n    S_REGISTER,\n};\n\nenum {\n    DECL_BODY = 1,\n    DECL_PARAM,\n    DECL_PARAM_TYPEONLY,\n    DECL_CAST,\n};\n\n/*\n * Source location\n */\n\nstatic void mark_location() {\n    Token *tok = peek();\n    source_loc = malloc(sizeof(SourceLoc));\n    source_loc->file = tok->file->name;\n    source_loc->line = tok->line;\n}\n\n\n/*\n * Constructors\n */\n\nchar *make_tempname() {\n    static int c = 0;\n    return format(\".T%d\", c++);\n}\n\nchar *make_label() {\n    static int c = 0;\n    return format(\".L%d\", c++);\n}\n\nstatic char *make_static_label(char *name) {\n    static int c = 0;\n    return format(\".S%d.%s\", c++, name);\n}\n\nstatic Case *make_case(int beg, int end, char *label) {\n    Case *r = malloc(sizeof(Case));\n    r->beg = beg;\n    r->end = end;\n    r->label = label;\n    return r;\n}\n\nstatic Map *env() {\n    return localenv ? localenv : globalenv;\n}\n\nstatic Node *make_ast(Node *tmpl) {\n    Node *r = malloc(sizeof(Node));\n    *r = *tmpl;\n    r->sourceLoc = source_loc;\n    return r;\n}\n\nstatic Node *ast_uop(int kind, Type *ty, Node *operand) {\n    return make_ast(&(Node){ kind, ty, .operand = operand });\n}\n\nstatic Node *ast_binop(Type *ty, int kind, Node *left, Node *right) {\n    Node *r = make_ast(&(Node){ kind, ty });\n    r->left = left;\n    r->right = right;\n    return r;\n}\n\nstatic Node *ast_inttype(Type *ty, long val) {\n    return make_ast(&(Node){ AST_LITERAL, ty, .ival = val });\n}\n\nstatic Node *ast_floattype(Type *ty, double val) {\n    return make_ast(&(Node){ AST_LITERAL, ty, .fval = val });\n}\n\nstatic Node *ast_lvar(Type *ty, char *name) {\n    Node *r = make_ast(&(Node){ AST_LVAR, ty, .varname = name });\n    if (localenv)\n        map_put(localenv, name, r);\n    if (localvars)\n        vec_push(localvars, r);\n    return r;\n}\n\nstatic Node *ast_gvar(Type *ty, char *name) {\n    Node *r = make_ast(&(Node){ AST_GVAR, ty, .varname = name, .glabel = name });\n    map_put(globalenv, name, r);\n    return r;\n}\n\nstatic Node *ast_static_lvar(Type *ty, char *name) {\n    Node *r = make_ast(&(Node){\n        .kind = AST_GVAR,\n        .ty = ty,\n        .varname = name,\n        .glabel = make_static_label(name) });\n    assert(localenv);\n    map_put(localenv, name, r);\n    return r;\n}\n\nstatic Node *ast_typedef(Type *ty, char *name) {\n    Node *r = make_ast(&(Node){ AST_TYPEDEF, ty });\n    map_put(env(), name, r);\n    return r;\n}\n\nstatic Node *ast_string(int enc, char *str, int len) {\n    Type *ty;\n    char *body;\n\n    switch (enc) {\n    case ENC_NONE:\n    case ENC_UTF8:\n        ty = make_array_type(type_char, len);\n        body = str;\n        break;\n    case ENC_CHAR16: {\n        Buffer *b = to_utf16(str, len);\n        ty = make_array_type(type_ushort, buf_len(b) / type_ushort->size);\n        body = buf_body(b);\n        break;\n    }\n    case ENC_CHAR32:\n    case ENC_WCHAR: {\n        Buffer *b = to_utf32(str, len);\n        ty = make_array_type(type_uint, buf_len(b) / type_uint->size);\n        body = buf_body(b);\n        break;\n    }\n    }\n    return make_ast(&(Node){ AST_LITERAL, .ty = ty, .sval = body });\n}\n\nstatic Node *ast_funcall(Type *ftype, char *fname, Vector *args) {\n    return make_ast(&(Node){\n        .kind = AST_FUNCALL,\n        .ty = ftype->rettype,\n        .fname = fname,\n        .args = args,\n        .ftype = ftype });\n}\n\nstatic Node *ast_funcdesg(Type *ty, char *fname) {\n    return make_ast(&(Node){ AST_FUNCDESG, ty, .fname = fname });\n}\n\nstatic Node *ast_funcptr_call(Node *fptr, Vector *args) {\n    assert(fptr->ty->kind == KIND_PTR);\n    assert(fptr->ty->ptr->kind == KIND_FUNC);\n    return make_ast(&(Node){\n        .kind = AST_FUNCPTR_CALL,\n        .ty = fptr->ty->ptr->rettype,\n        .fptr = fptr,\n        .args = args });\n}\n\nstatic Node *ast_func(Type *ty, char *fname, Vector *params, Node *body, Vector *localvars) {\n    return make_ast(&(Node){\n        .kind = AST_FUNC,\n        .ty = ty,\n        .fname = fname,\n        .params = params,\n        .localvars = localvars,\n        .body = body});\n}\n\nstatic Node *ast_decl(Node *var, Vector *init) {\n    return make_ast(&(Node){ AST_DECL, .declvar = var, .declinit = init });\n}\n\nstatic Node *ast_init(Node *val, Type *totype, int off) {\n    return make_ast(&(Node){ AST_INIT, .initval = val, .initoff = off, .totype = totype });\n}\n\nstatic Node *ast_conv(Type *totype, Node *val) {\n    return make_ast(&(Node){ AST_CONV, totype, .operand = val });\n}\n\nstatic Node *ast_if(Node *cond, Node *then, Node *els) {\n    return make_ast(&(Node){ AST_IF, .cond = cond, .then = then, .els = els });\n}\n\nstatic Node *ast_ternary(Type *ty, Node *cond, Node *then, Node *els) {\n    return make_ast(&(Node){ AST_TERNARY, ty, .cond = cond, .then = then, .els = els });\n}\n\nstatic Node *ast_return(Node *retval) {\n    return make_ast(&(Node){ AST_RETURN, .retval = retval });\n}\n\nstatic Node *ast_compound_stmt(Vector *stmts) {\n    return make_ast(&(Node){ AST_COMPOUND_STMT, .stmts = stmts });\n}\n\nstatic Node *ast_struct_ref(Type *ty, Node *struc, char *name) {\n    return make_ast(&(Node){ AST_STRUCT_REF, ty, .struc = struc, .field = name });\n}\n\nstatic Node *ast_goto(char *label) {\n    return make_ast(&(Node){ AST_GOTO, .label = label });\n}\n\nstatic Node *ast_jump(char *label) {\n    return make_ast(&(Node){ AST_GOTO, .label = label, .newlabel = label });\n}\n\nstatic Node *ast_computed_goto(Node *expr) {\n    return make_ast(&(Node){ AST_COMPUTED_GOTO, .operand = expr });\n}\n\nstatic Node *ast_label(char *label) {\n    return make_ast(&(Node){ AST_LABEL, .label = label });\n}\n\nstatic Node *ast_dest(char *label) {\n    return make_ast(&(Node){ AST_LABEL, .label = label, .newlabel = label });\n}\n\nstatic Node *ast_label_addr(char *label) {\n    return make_ast(&(Node){ OP_LABEL_ADDR, make_ptr_type(type_void), .label = label });\n}\n\nstatic Type *make_type(Type *tmpl) {\n    Type *r = malloc(sizeof(Type));\n    *r = *tmpl;\n    return r;\n}\n\nstatic Type *copy_type(Type *ty) {\n    Type *r = malloc(sizeof(Type));\n    memcpy(r, ty, sizeof(Type));\n    return r;\n}\n\nstatic Type *make_numtype(int kind, bool usig) {\n    Type *r = calloc(1, sizeof(Type));\n    r->kind = kind;\n    r->usig = usig;\n    if (kind == KIND_VOID)         r->size = r->align = 0;\n    else if (kind == KIND_BOOL)    r->size = r->align = 1;\n    else if (kind == KIND_CHAR)    r->size = r->align = 1;\n    else if (kind == KIND_SHORT)   r->size = r->align = 2;\n    else if (kind == KIND_INT)     r->size = r->align = 4;\n    else if (kind == KIND_LONG)    r->size = r->align = 8;\n    else if (kind == KIND_LLONG)   r->size = r->align = 8;\n    else if (kind == KIND_FLOAT)   r->size = r->align = 4;\n    else if (kind == KIND_DOUBLE)  r->size = r->align = 8;\n    else if (kind == KIND_LDOUBLE) r->size = r->align = 8;\n    else error(\"internal error\");\n    return r;\n}\n\nstatic Type* make_ptr_type(Type *ty) {\n    return make_type(&(Type){ KIND_PTR, .ptr = ty, .size = 8, .align = 8 });\n}\n\nstatic Type* make_array_type(Type *ty, int len) {\n    int size;\n    if (len < 0)\n        size = -1;\n    else\n        size = ty->size * len;\n    return make_type(&(Type){\n        KIND_ARRAY,\n        .ptr = ty,\n        .size = size,\n        .len = len,\n        .align = ty->align });\n}\n\nstatic Type* make_rectype(bool is_struct) {\n    return make_type(&(Type){ KIND_STRUCT, .is_struct = is_struct });\n}\n\nstatic Type* make_func_type(Type *rettype, Vector *paramtypes, bool has_varargs, bool oldstyle) {\n    return make_type(&(Type){\n        KIND_FUNC,\n        .rettype = rettype,\n        .params = paramtypes,\n        .hasva = has_varargs,\n        .oldstyle = oldstyle });\n}\n\nstatic Type *make_stub_type() {\n    return make_type(&(Type){ KIND_STUB });\n}\n\n/*\n * Predicates and kind checking routines\n */\n\nbool is_inttype(Type *ty) {\n    switch (ty->kind) {\n    case KIND_BOOL: case KIND_CHAR: case KIND_SHORT: case KIND_INT:\n    case KIND_LONG: case KIND_LLONG:\n        return true;\n    default:\n        return false;\n    }\n}\n\nbool is_flotype(Type *ty) {\n    switch (ty->kind) {\n    case KIND_FLOAT: case KIND_DOUBLE: case KIND_LDOUBLE:\n        return true;\n    default:\n        return false;\n    }\n}\n\nstatic bool is_arithtype(Type *ty) {\n    return is_inttype(ty) || is_flotype(ty);\n}\n\nstatic bool is_string(Type *ty) {\n    return ty->kind == KIND_ARRAY && ty->ptr->kind == KIND_CHAR;\n}\n\nstatic void ensure_lvalue(Node *node) {\n    switch (node->kind) {\n    case AST_LVAR: case AST_GVAR: case AST_DEREF: case AST_STRUCT_REF:\n        return;\n    default:\n        error(\"lvalue expected, but got %s\", node2s(node));\n    }\n}\n\nstatic void ensure_inttype(Node *node) {\n    if (!is_inttype(node->ty))\n        error(\"integer type expected, but got %s\", node2s(node));\n}\n\nstatic void ensure_arithtype(Node *node) {\n    if (!is_arithtype(node->ty))\n        error(\"arithmetic type expected, but got %s\", node2s(node));\n}\n\nstatic void ensure_not_void(Type *ty) {\n    if (ty->kind == KIND_VOID)\n        error(\"void is not allowed\");\n}\n\nstatic void expect(char id) {\n    Token *tok = get();\n    if (!is_keyword(tok, id))\n        errort(tok, \"'%c' expected, but got %s\", id, tok2s(tok));\n}\n\nstatic Type *copy_incomplete_type(Type *ty) {\n    if (!ty) return NULL;\n    return (ty->len == -1) ? copy_type(ty) : ty;\n}\n\nstatic Type *get_typedef(char *name) {\n    Node *node = map_get(env(), name);\n    return (node && node->kind == AST_TYPEDEF) ? node->ty : NULL;\n}\n\nstatic bool is_type(Token *tok) {\n    if (tok->kind == TIDENT)\n        return get_typedef(tok->sval);\n    if (tok->kind != TKEYWORD)\n        return false;\n    switch (tok->id) {\n#define op(x, y)\n#define keyword(id, _, istype) case id: return istype;\n#include \"keyword.inc\"\n#undef keyword\n#undef op\n    default:\n        return false;\n    }\n}\n\nstatic bool next_token(int kind) {\n    Token *tok = get();\n    if (is_keyword(tok, kind))\n        return true;\n    unget_token(tok);\n    return false;\n}\n\nvoid *make_pair(void *first, void *second) {\n    void **r = malloc(sizeof(void *) * 2);\n    r[0] = first;\n    r[1] = second;\n    return r;\n}\n\n/*\n * Type conversion\n */\n\nstatic Node *conv(Node *node) {\n    if (!node)\n        return NULL;\n    Type *ty = node->ty;\n    switch (ty->kind) {\n    case KIND_ARRAY:\n        // C11 6.3.2.1p3: An array of T is converted to a pointer to T.\n        return ast_uop(AST_CONV, make_ptr_type(ty->ptr), node);\n    case KIND_FUNC:\n        // C11 6.3.2.1p4: A function designator is converted to a pointer to the function.\n        return ast_uop(AST_ADDR, make_ptr_type(ty), node);\n    case KIND_SHORT: case KIND_CHAR: case KIND_BOOL:\n        // C11 6.3.1.1p2: The integer promotions\n        return ast_conv(type_int, node);\n    case KIND_INT:\n        if (ty->bitsize > 0)\n            return ast_conv(type_int, node);\n    }\n    return node;\n}\n\nstatic bool same_arith_type(Type *t, Type *u) {\n    return t->kind == u->kind && t->usig == u->usig;\n}\n\nstatic Node *wrap(Type *t, Node *node) {\n    if (same_arith_type(t, node->ty))\n        return node;\n    return ast_uop(AST_CONV, t, node);\n}\n\n// C11 6.3.1.8: Usual arithmetic conversions\nstatic Type *usual_arith_conv(Type *t, Type *u) {\n    assert(is_arithtype(t));\n    assert(is_arithtype(u));\n    if (t->kind < u->kind) {\n        // Make t the larger type\n        Type *tmp = t;\n        t = u;\n        u = tmp;\n    }\n    if (is_flotype(t))\n        return t;\n    assert(is_inttype(t) && t->size >= type_int->size);\n    assert(is_inttype(u) && u->size >= type_int->size);\n    if (t->size > u->size)\n        return t;\n    assert(t->size == u->size);\n    if (t->usig == u->usig)\n        return t;\n    Type *r = copy_type(t);\n    r->usig = true;\n    return r;\n}\n\nstatic bool valid_pointer_binop(int op) {\n    switch (op) {\n    case '-': case '<': case '>': case OP_EQ:\n    case OP_NE: case OP_GE: case OP_LE:\n        return true;\n    default:\n        return false;\n    }\n}\n\nstatic Node *binop(int op, Node *lhs, Node *rhs) {\n    if (lhs->ty->kind == KIND_PTR && rhs->ty->kind == KIND_PTR) {\n        if (!valid_pointer_binop(op))\n            error(\"invalid pointer arith\");\n        // C11 6.5.6.9: Pointer subtractions have type ptrdiff_t.\n        if (op == '-')\n            return ast_binop(type_long, op, lhs, rhs);\n        // C11 6.5.8.6, 6.5.9.3: Pointer comparisons have type int.\n        return ast_binop(type_int, op, lhs, rhs);\n    }\n    if (lhs->ty->kind == KIND_PTR)\n        return ast_binop(lhs->ty, op, lhs, rhs);\n    if (rhs->ty->kind == KIND_PTR)\n        return ast_binop(rhs->ty, op, rhs, lhs);\n    assert(is_arithtype(lhs->ty));\n    assert(is_arithtype(rhs->ty));\n    Type *r = usual_arith_conv(lhs->ty, rhs->ty);\n    return ast_binop(r, op, wrap(r, lhs), wrap(r, rhs));\n}\n\nstatic bool is_same_struct(Type *a, Type *b) {\n    if (a->kind != b->kind)\n        return false;\n    switch (a->kind) {\n    case KIND_ARRAY:\n        return a->len == b->len &&\n            is_same_struct(a->ptr, b->ptr);\n    case KIND_PTR:\n        return is_same_struct(a->ptr, b->ptr);\n    case KIND_STRUCT: {\n        if (a->is_struct != b->is_struct)\n            return false;\n        Vector *ka = dict_keys(a->fields);\n        Vector *kb = dict_keys(b->fields);\n        if (vec_len(ka) != vec_len(kb))\n            return false;\n        for (int i = 0; i < vec_len(ka); i++)\n            if (!is_same_struct(vec_get(ka, i), vec_get(kb, i)))\n                return false;\n        return true;\n    }\n    default:\n        return true;\n    }\n}\n\nstatic void ensure_assignable(Type *totype, Type *fromtype) {\n    if ((is_arithtype(totype) || totype->kind == KIND_PTR) &&\n        (is_arithtype(fromtype) || fromtype->kind == KIND_PTR))\n        return;\n    if (is_same_struct(totype, fromtype))\n        return;\n    error(\"incompatible kind: <%s> <%s>\", ty2s(totype), ty2s(fromtype));\n}\n\n/*\n * Integer constant expression\n */\n\nstatic int eval_struct_ref(Node *node, int offset) {\n    if (node->kind == AST_STRUCT_REF)\n        return eval_struct_ref(node->struc, node->ty->offset + offset);\n    return eval_intexpr(node, NULL) + offset;\n}\n\nint eval_intexpr(Node *node, Node **addr) {\n    switch (node->kind) {\n    case AST_LITERAL:\n        if (is_inttype(node->ty))\n            return node->ival;\n        error(\"Integer expression expected, but got %s\", node2s(node));\n    case '!': return !eval_intexpr(node->operand, addr);\n    case '~': return ~eval_intexpr(node->operand, addr);\n    case OP_CAST: return eval_intexpr(node->operand, addr);\n    case AST_CONV: return eval_intexpr(node->operand, addr);\n    case AST_ADDR:\n        if (node->operand->kind == AST_STRUCT_REF)\n            return eval_struct_ref(node->operand, 0);\n        // fallthrough\n    case AST_GVAR:\n        if (addr) {\n            *addr = conv(node);\n            return 0;\n        }\n        goto error;\n        goto error;\n    case AST_DEREF:\n        if (node->operand->ty->kind == KIND_PTR)\n            return eval_intexpr(node->operand, addr);\n        goto error;\n    case AST_TERNARY: {\n        long cond = eval_intexpr(node->cond, addr);\n        if (cond)\n            return node->then ? eval_intexpr(node->then, addr) : cond;\n        return eval_intexpr(node->els, addr);\n    }\n#define L (eval_intexpr(node->left, addr))\n#define R (eval_intexpr(node->right, addr))\n    case '+': return L + R;\n    case '-': return L - R;\n    case '*': return L * R;\n    case '/': return L / R;\n    case '<': return L < R;\n    case '^': return L ^ R;\n    case '&': return L & R;\n    case '|': return L | R;\n    case '%': return L % R;\n    case OP_EQ: return L == R;\n    case OP_LE: return L <= R;\n    case OP_NE: return L != R;\n    case OP_SAL: return L << R;\n    case OP_SAR: return L >> R;\n    case OP_SHR: return ((unsigned long)L) >> R;\n    case OP_LOGAND: return L && R;\n    case OP_LOGOR:  return L || R;\n#undef L\n#undef R\n    default:\n    error:\n        error(\"Integer expression expected, but got %s\", node2s(node));\n    }\n}\n\nstatic int read_intexpr() {\n    return eval_intexpr(read_conditional_expr(), NULL);\n}\n\n/*\n * Numeric literal\n */\n\nstatic Type *read_int_suffix(char *s) {\n    if (!strcasecmp(s, \"u\"))\n        return type_uint;\n    if (!strcasecmp(s, \"l\"))\n        return type_long;\n    if (!strcasecmp(s, \"ul\") || !strcasecmp(s, \"lu\"))\n        return type_ulong;\n    if (!strcasecmp(s, \"ll\"))\n        return type_llong;\n    if (!strcasecmp(s, \"ull\") || !strcasecmp(s, \"llu\"))\n        return type_ullong;\n    return NULL;\n}\n\nstatic Node *read_int(Token *tok) {\n    char *s = tok->sval;\n    char *end;\n    long v = !strncasecmp(s, \"0b\", 2)\n        ? strtoul(s + 2, &end, 2) : strtoul(s, &end, 0);\n    Type *ty = read_int_suffix(end);\n    if (ty)\n        return ast_inttype(ty, v);\n    if (*end != '\\0')\n        errort(tok, \"invalid character '%c': %s\", *end, s);\n\n    // C11 6.4.4.1p5: Decimal constant type is int, long, or long long.\n    // In 8cc, long and long long are the same size.\n    bool base10 = (*s != '0');\n    if (base10) {\n        ty = !(v & ~(long)INT_MAX) ? type_int : type_long;\n        return ast_inttype(ty, v);\n    }\n    // Octal or hexadecimal constant type may be unsigned.\n    ty = !(v & ~(unsigned long)INT_MAX) ? type_int\n        : !(v & ~(unsigned long)UINT_MAX) ? type_uint\n        : !(v & ~(unsigned long)LONG_MAX) ? type_long\n        : type_ulong;\n    return ast_inttype(ty, v);\n}\n\nstatic Node *read_float(Token *tok) {\n    char *s = tok->sval;\n    char *end;\n    double v = strtod(s, &end);\n    // C11 6.4.4.2p4: The default type for flonum is double.\n    if (!strcasecmp(end, \"l\"))\n        return ast_floattype(type_ldouble, v);\n    if (!strcasecmp(end, \"f\"))\n        return ast_floattype(type_float, v);\n    if (*end != '\\0')\n        errort(tok, \"invalid character '%c': %s\", *end, s);\n    return ast_floattype(type_double, v);\n}\n\nstatic Node *read_number(Token *tok) {\n    char *s = tok->sval;\n    bool isfloat = strpbrk(s, \".pP\") || (strncasecmp(s, \"0x\", 2) && strpbrk(s, \"eE\"));\n    return isfloat ? read_float(tok) : read_int(tok);\n}\n\n/*\n * Sizeof operator\n */\n\nstatic Type *read_sizeof_operand_sub() {\n    Token *tok = get();\n    if (is_keyword(tok, '(') && is_type(peek())) {\n        Type *r = read_cast_type();\n        expect(')');\n        return r;\n    }\n    unget_token(tok);\n    return read_unary_expr()->ty;\n}\n\nstatic Node *read_sizeof_operand() {\n    Type *ty = read_sizeof_operand_sub();\n    // Sizeof on void or function type is GNU extension\n    int size = (ty->kind == KIND_VOID || ty->kind == KIND_FUNC) ? 1 : ty->size;\n    assert(0 <= size);\n    return ast_inttype(type_ulong, size);\n}\n\n/*\n * Alignof operator\n */\n\nstatic Node *read_alignof_operand() {\n    expect('(');\n    Type *ty = read_cast_type();\n    expect(')');\n    return ast_inttype(type_ulong, ty->align);\n}\n\n/*\n * Function arguments\n */\n\nstatic Vector *read_func_args(Vector *params) {\n    Vector *args = make_vector();\n    int i = 0;\n    for (;;) {\n        if (next_token(')')) break;\n        Node *arg = conv(read_assignment_expr());\n        Type *paramtype;\n        if (i < vec_len(params)) {\n            paramtype = vec_get(params, i++);\n        } else {\n            paramtype = is_flotype(arg->ty) ? type_double :\n                is_inttype(arg->ty) ? type_int :\n                arg->ty;\n        }\n        ensure_assignable(paramtype, arg->ty);\n        if (paramtype->kind != arg->ty->kind)\n            arg = ast_conv(paramtype, arg);\n        vec_push(args, arg);\n        Token *tok = get();\n        if (is_keyword(tok, ')')) break;\n        if (!is_keyword(tok, ','))\n            errort(tok, \"unexpected token: '%s'\", tok2s(tok));\n    }\n    return args;\n}\n\nstatic Node *read_funcall(Node *fp) {\n    if (fp->kind == AST_ADDR && fp->operand->kind == AST_FUNCDESG) {\n        Node *desg = fp->operand;\n        Vector *args = read_func_args(desg->ty->params);\n        return ast_funcall(desg->ty, desg->fname, args);\n    }\n    Vector *args = read_func_args(fp->ty->ptr->params);\n    return ast_funcptr_call(fp, args);\n}\n\n/*\n * _Generic\n */\n\nstatic bool type_compatible(Type *a, Type *b) {\n    if (a->kind == KIND_STRUCT)\n        return is_same_struct(a, b);\n    if (a->kind != b->kind)\n        return false;\n    if (a->ptr && b->ptr)\n        return type_compatible(a->ptr, b->ptr);\n    if (is_arithtype(a) && is_arithtype(b))\n        return same_arith_type(a, b);\n    return true;\n}\n\nstatic Vector *read_generic_list(Node **defaultexpr) {\n    Vector *r = make_vector();\n    for (;;) {\n        if (next_token(')'))\n            return r;\n        Token *tok = peek();\n        if (next_token(KDEFAULT)) {\n            if (*defaultexpr)\n                errort(tok, \"default expression specified twice\");\n            expect(':');\n            *defaultexpr = read_assignment_expr();\n        } else {\n            Type *ty = read_cast_type();\n            expect(':');\n            Node *expr = read_assignment_expr();\n            vec_push(r, make_pair(ty, expr));\n        }\n        next_token(',');\n    }\n}\n\nstatic Node *read_generic() {\n    expect('(');\n    Token *tok = peek();\n    Node *contexpr = read_assignment_expr();\n    expect(',');\n    Node *defaultexpr = NULL;\n    Vector *list = read_generic_list(&defaultexpr);\n    for (int i = 0; i < vec_len(list); i++) {\n        void **pair = vec_get(list, i);\n        Type *ty = pair[0];\n        Node *expr = pair[1];\n        if (type_compatible(contexpr->ty, ty))\n            return expr;\n    }\n   if (!defaultexpr)\n       errort(tok, \"no matching generic selection for %s: %s\", node2s(contexpr), ty2s(contexpr->ty));\n   return defaultexpr;\n}\n\n/*\n * _Static_assert\n */\n\nstatic void read_static_assert() {\n    expect('(');\n    int val = read_intexpr();\n    expect(',');\n    Token *tok = get();\n    if (tok->kind != TSTRING)\n        errort(tok, \"string expected as the second argument for _Static_assert, but got %s\", tok2s(tok));\n    expect(')');\n    expect(';');\n    if (!val)\n        errort(tok, \"_Static_assert failure: %s\", tok->sval);\n}\n\n/*\n * Expression\n */\n\nstatic Node *read_var_or_func(char *name) {\n    Node *v = map_get(env(), name);\n    if (!v) {\n        Token *tok = peek();\n        if (!is_keyword(tok, '('))\n            errort(tok, \"undefined variable: %s\", name);\n        Type *ty = make_func_type(type_int, make_vector(), true, false);\n        warnt(tok, \"assume returning int: %s()\", name);\n        return ast_funcdesg(ty, name);\n    }\n    if (v->ty->kind == KIND_FUNC)\n        return ast_funcdesg(v->ty, name);\n    return v;\n}\n\nstatic int get_compound_assign_op(Token *tok) {\n    if (tok->kind != TKEYWORD)\n        return 0;\n    switch (tok->id) {\n    case OP_A_ADD: return '+';\n    case OP_A_SUB: return '-';\n    case OP_A_MUL: return '*';\n    case OP_A_DIV: return '/';\n    case OP_A_MOD: return '%';\n    case OP_A_AND: return '&';\n    case OP_A_OR:  return '|';\n    case OP_A_XOR: return '^';\n    case OP_A_SAL: return OP_SAL;\n    case OP_A_SAR: return OP_SAR;\n    case OP_A_SHR: return OP_SHR;\n    default: return 0;\n    }\n}\n\nstatic Node *read_stmt_expr() {\n    Node *r = read_compound_stmt();\n    expect(')');\n    Type *rtype = type_void;\n    if (vec_len(r->stmts) > 0) {\n        Node *lastexpr = vec_tail(r->stmts);\n        if (lastexpr->ty)\n            rtype = lastexpr->ty;\n    }\n    r->ty = rtype;\n    return r;\n}\n\nstatic Type *char_type(int enc) {\n    switch (enc) {\n    case ENC_NONE:\n    case ENC_WCHAR:\n        return type_int;\n    case ENC_CHAR16:\n        return type_ushort;\n    case ENC_CHAR32:\n        return type_uint;\n    }\n    error(\"internal error\");\n}\n\nstatic Node *read_primary_expr() {\n    Token *tok = get();\n    if (!tok) return NULL;\n    if (is_keyword(tok, '(')) {\n        if (next_token('{'))\n            return read_stmt_expr();\n        Node *r = read_expr();\n        expect(')');\n        return r;\n    }\n    if (is_keyword(tok, KGENERIC)) {\n        return read_generic();\n    }\n    switch (tok->kind) {\n    case TIDENT:\n        return read_var_or_func(tok->sval);\n    case TNUMBER:\n        return read_number(tok);\n    case TCHAR:\n        return ast_inttype(char_type(tok->enc), tok->c);\n    case TSTRING:\n        return ast_string(tok->enc, tok->sval, tok->slen);\n    case TKEYWORD:\n        unget_token(tok);\n        return NULL;\n    default:\n        error(\"internal error: unknown token kind: %d\", tok->kind);\n    }\n}\n\nstatic Node *read_subscript_expr(Node *node) {\n    Token *tok = peek();\n    Node *sub = read_expr();\n    if (!sub)\n        errort(tok, \"subscription expected\");\n    expect(']');\n    Node *t = binop('+', conv(node), conv(sub));\n    return ast_uop(AST_DEREF, t->ty->ptr, t);\n}\n\nstatic Node *read_postfix_expr_tail(Node *node) {\n    if (!node) return NULL;\n    for (;;) {\n        if (next_token('(')) {\n            Token *tok = peek();\n            node = conv(node);\n            Type *t = node->ty;\n            if (t->kind != KIND_PTR || t->ptr->kind != KIND_FUNC)\n                errort(tok, \"function expected, but got %s\", node2s(node));\n            node = read_funcall(node);\n            continue;\n        }\n        if (next_token('[')) {\n            node = read_subscript_expr(node);\n            continue;\n        }\n        if (next_token('.')) {\n            node = read_struct_field(node);\n            continue;\n        }\n        if (next_token(OP_ARROW)) {\n            if (node->ty->kind != KIND_PTR)\n                error(\"pointer type expected, but got %s %s\",\n                      ty2s(node->ty), node2s(node));\n            node = ast_uop(AST_DEREF, node->ty->ptr, node);\n            node = read_struct_field(node);\n            continue;\n        }\n        Token *tok = peek();\n        if (next_token(OP_INC) || next_token(OP_DEC)) {\n            ensure_lvalue(node);\n            int op = is_keyword(tok, OP_INC) ? OP_POST_INC : OP_POST_DEC;\n            return ast_uop(op, node->ty, node);\n        }\n        return node;\n    }\n}\n\nstatic Node *read_postfix_expr() {\n    Node *node = read_primary_expr();\n    return read_postfix_expr_tail(node);\n}\n\nstatic Node *read_unary_incdec(int op) {\n    Node *operand = read_unary_expr();\n    operand = conv(operand);\n    ensure_lvalue(operand);\n    return ast_uop(op, operand->ty, operand);\n}\n\nstatic Node *read_label_addr(Token *tok) {\n    // [GNU] Labels as values. You can get the address of the a label\n    // with unary \"&&\" operator followed by a label name.\n    Token *tok2 = get();\n    if (tok2->kind != TIDENT)\n        errort(tok, \"label name expected after &&, but got %s\", tok2s(tok2));\n    Node *r = ast_label_addr(tok2->sval);\n    vec_push(gotos, r);\n    return r;\n}\n\nstatic Node *read_unary_addr() {\n    Node *operand = read_cast_expr();\n    if (operand->kind == AST_FUNCDESG)\n        return conv(operand);\n    ensure_lvalue(operand);\n    return ast_uop(AST_ADDR, make_ptr_type(operand->ty), operand);\n}\n\nstatic Node *read_unary_deref(Token *tok) {\n    Node *operand = conv(read_cast_expr());\n    if (operand->ty->kind != KIND_PTR)\n        errort(tok, \"pointer type expected, but got %s\", node2s(operand));\n    if (operand->ty->ptr->kind == KIND_FUNC)\n        return operand;\n    return ast_uop(AST_DEREF, operand->ty->ptr, operand);\n}\n\nstatic Node *read_unary_minus() {\n    Node *expr = read_cast_expr();\n    ensure_arithtype(expr);\n    if (is_inttype(expr->ty))\n        return binop('-', conv(ast_inttype(expr->ty, 0)), conv(expr));\n    return binop('-', ast_floattype(expr->ty, 0), expr);\n}\n\nstatic Node *read_unary_bitnot(Token *tok) {\n    Node *expr = read_cast_expr();\n    expr = conv(expr);\n    if (!is_inttype(expr->ty))\n        errort(tok, \"invalid use of ~: %s\", node2s(expr));\n    return ast_uop('~', expr->ty, expr);\n}\n\nstatic Node *read_unary_lognot() {\n    Node *operand = read_cast_expr();\n    operand = conv(operand);\n    return ast_uop('!', type_int, operand);\n}\n\nstatic Node *read_unary_expr() {\n    Token *tok = get();\n    if (tok->kind == TKEYWORD) {\n        switch (tok->id) {\n        case KSIZEOF: return read_sizeof_operand();\n        case KALIGNOF: return read_alignof_operand();\n        case OP_INC: return read_unary_incdec(OP_PRE_INC);\n        case OP_DEC: return read_unary_incdec(OP_PRE_DEC);\n        case OP_LOGAND: return read_label_addr(tok);\n        case '&': return read_unary_addr();\n        case '*': return read_unary_deref(tok);\n        case '+': return read_cast_expr();\n        case '-': return read_unary_minus();\n        case '~': return read_unary_bitnot(tok);\n        case '!': return read_unary_lognot();\n        }\n    }\n    unget_token(tok);\n    return read_postfix_expr();\n}\n\nstatic Node *read_compound_literal(Type *ty) {\n    char *name = make_label();\n    Vector *init = read_decl_init(ty);\n    Node *r = ast_lvar(ty, name);\n    r->lvarinit = init;\n    return r;\n}\n\nstatic Type *read_cast_type() {\n    return read_abstract_declarator(read_decl_spec(NULL));\n}\n\nstatic Node *read_cast_expr() {\n    Token *tok = get();\n    if (is_keyword(tok, '(') && is_type(peek())) {\n        Type *ty = read_cast_type();\n        expect(')');\n        if (is_keyword(peek(), '{')) {\n            Node *node = read_compound_literal(ty);\n            return read_postfix_expr_tail(node);\n        }\n        return ast_uop(OP_CAST, ty, read_cast_expr());\n    }\n    unget_token(tok);\n    return read_unary_expr();\n}\n\nstatic Node *read_multiplicative_expr() {\n    Node *node = read_cast_expr();\n    for (;;) {\n        if (next_token('*'))      node = binop('*', conv(node), conv(read_cast_expr()));\n        else if (next_token('/')) node = binop('/', conv(node), conv(read_cast_expr()));\n        else if (next_token('%')) node = binop('%', conv(node), conv(read_cast_expr()));\n        else    return node;\n    }\n}\n\nstatic Node *read_additive_expr() {\n    Node *node = read_multiplicative_expr();\n    for (;;) {\n        if      (next_token('+')) node = binop('+', conv(node), conv(read_multiplicative_expr()));\n        else if (next_token('-')) node = binop('-', conv(node), conv(read_multiplicative_expr()));\n        else    return node;\n    }\n}\n\nstatic Node *read_shift_expr() {\n    Node *node = read_additive_expr();\n    for (;;) {\n        int op;\n        if (next_token(OP_SAL))\n            op = OP_SAL;\n        else if (next_token(OP_SAR))\n            op = node->ty->usig ? OP_SHR : OP_SAR;\n        else\n            break;\n        Node *right = read_additive_expr();\n        ensure_inttype(node);\n        ensure_inttype(right);\n        node = ast_binop(node->ty, op, conv(node), conv(right));\n    }\n    return node;\n}\n\nstatic Node *read_relational_expr() {\n    Node *node = read_shift_expr();\n    for (;;) {\n        if      (next_token('<'))   node = binop('<',   conv(node), conv(read_shift_expr()));\n        else if (next_token('>'))   node = binop('<',   conv(read_shift_expr()), conv(node));\n        else if (next_token(OP_LE)) node = binop(OP_LE, conv(node), conv(read_shift_expr()));\n        else if (next_token(OP_GE)) node = binop(OP_LE, conv(read_shift_expr()), conv(node));\n        else    return node;\n        node->ty = type_int;\n    }\n}\n\nstatic Node *read_equality_expr() {\n    Node *node = read_relational_expr();\n    Node *r;\n    if (next_token(OP_EQ)) {\n        r = binop(OP_EQ, conv(node), conv(read_equality_expr()));\n    } else if (next_token(OP_NE)) {\n        r = binop(OP_NE, conv(node), conv(read_equality_expr()));\n    } else {\n        return node;\n    }\n    r->ty = type_int;\n    return r;\n}\n\nstatic Node *read_bitand_expr() {\n    Node *node = read_equality_expr();\n    while (next_token('&'))\n        node = binop('&', conv(node), conv(read_equality_expr()));\n    return node;\n}\n\nstatic Node *read_bitxor_expr() {\n    Node *node = read_bitand_expr();\n    while (next_token('^'))\n        node = binop('^', conv(node), conv(read_bitand_expr()));\n    return node;\n}\n\nstatic Node *read_bitor_expr() {\n    Node *node = read_bitxor_expr();\n    while (next_token('|'))\n        node = binop('|', conv(node), conv(read_bitxor_expr()));\n    return node;\n}\n\nstatic Node *read_logand_expr() {\n    Node *node = read_bitor_expr();\n    while (next_token(OP_LOGAND))\n        node = ast_binop(type_int, OP_LOGAND, node, read_bitor_expr());\n    return node;\n}\n\nstatic Node *read_logor_expr() {\n    Node *node = read_logand_expr();\n    while (next_token(OP_LOGOR))\n        node = ast_binop(type_int, OP_LOGOR, node, read_logand_expr());\n    return node;\n}\n\nstatic Node *do_read_conditional_expr(Node *cond) {\n    Node *then = conv(read_comma_expr());\n    expect(':');\n    Node *els = conv(read_conditional_expr());\n    // [GNU] Omitting the middle operand is allowed.\n    Type *t = then ? then->ty : cond->ty;\n    Type *u = els->ty;\n    // C11 6.5.15p5: if both types are arithemtic type, the result\n    // type is the result of the usual arithmetic conversions.\n    if (is_arithtype(t) && is_arithtype(u)) {\n        Type *r = usual_arith_conv(t, u);\n        return ast_ternary(r, cond, (then ? wrap(r, then) : NULL), wrap(r, els));\n    }\n    return ast_ternary(u, cond, then, els);\n}\n\nstatic Node *read_conditional_expr() {\n    Node *cond = read_logor_expr();\n    if (!next_token('?'))\n        return cond;\n    return do_read_conditional_expr(cond);\n}\n\nstatic Node *read_assignment_expr() {\n    Node *node = read_logor_expr();\n    Token *tok = get();\n    if (!tok)\n        return node;\n    if (is_keyword(tok, '?'))\n        return do_read_conditional_expr(node);\n    int cop = get_compound_assign_op(tok);\n    if (is_keyword(tok, '=') || cop) {\n        Node *value = conv(read_assignment_expr());\n        if (is_keyword(tok, '=') || cop)\n            ensure_lvalue(node);\n        Node *right = cop ? binop(cop, conv(node), value) : value;\n        if (is_arithtype(node->ty) && node->ty->kind != right->ty->kind)\n            right = ast_conv(node->ty, right);\n        return ast_binop(node->ty, '=', node, right);\n    }\n    unget_token(tok);\n    return node;\n}\n\nstatic Node *read_comma_expr() {\n    Node *node = read_assignment_expr();\n    while (next_token(',')) {\n        Node *expr = read_assignment_expr();\n        node = ast_binop(expr->ty, ',', node, expr);\n    }\n    return node;\n}\n\nNode *read_expr() {\n    Token *tok = peek();\n    Node *r = read_comma_expr();\n    if (!r)\n        errort(tok, \"expression expected\");\n    return r;\n}\n\nstatic Node *read_expr_opt() {\n    return read_comma_expr();\n}\n\n/*\n * Struct or union\n */\n\nstatic Node *read_struct_field(Node *struc) {\n    if (struc->ty->kind != KIND_STRUCT)\n        error(\"struct expected, but got %s\", node2s(struc));\n    Token *name = get();\n    if (name->kind != TIDENT)\n        error(\"field name expected, but got %s\", tok2s(name));\n    Type *field = dict_get(struc->ty->fields, name->sval);\n    if (!field)\n        error(\"struct has no such field: %s\", tok2s(name));\n    return ast_struct_ref(field, struc, name->sval);\n}\n\nstatic char *read_rectype_tag() {\n    Token *tok = get();\n    if (tok->kind == TIDENT)\n        return tok->sval;\n    unget_token(tok);\n    return NULL;\n}\n\nstatic int compute_padding(int offset, int align) {\n    return (offset % align == 0) ? 0 : align - offset % align;\n}\n\nstatic void squash_unnamed_struct(Dict *dict, Type *unnamed, int offset) {\n    Vector *keys = dict_keys(unnamed->fields);\n    for (int i = 0; i < vec_len(keys); i++) {\n        char *name = vec_get(keys, i);\n        Type *t = copy_type(dict_get(unnamed->fields, name));\n        t->offset += offset;\n        dict_put(dict, name, t);\n    }\n}\n\nstatic int read_bitsize(char *name, Type *ty) {\n    if (!is_inttype(ty))\n        error(\"non-integer type cannot be a bitfield: %s\", ty2s(ty));\n    Token *tok = peek();\n    int r = read_intexpr();\n    int maxsize = ty->kind == KIND_BOOL ? 1 : ty->size * 8;\n    if (r < 0 || maxsize < r)\n        errort(tok, \"invalid bitfield size for %s: %d\", ty2s(ty), r);\n    if (r == 0 && name != NULL)\n        errort(tok, \"zero-width bitfield needs to be unnamed: %s\", name);\n    return r;\n}\n\nstatic Vector *read_rectype_fields_sub() {\n    Vector *r = make_vector();\n    for (;;) {\n        if (next_token(KSTATIC_ASSERT)) {\n            read_static_assert();\n            continue;\n        }\n        if (!is_type(peek()))\n            break;\n        Type *basetype = read_decl_spec(NULL);\n        if (basetype->kind == KIND_STRUCT && next_token(';')) {\n            vec_push(r, make_pair(NULL, basetype));\n            continue;\n        }\n        for (;;) {\n            char *name = NULL;\n            Type *fieldtype = read_declarator(&name, basetype, NULL, DECL_PARAM_TYPEONLY);\n            ensure_not_void(fieldtype);\n            fieldtype = copy_type(fieldtype);\n            fieldtype->bitsize = next_token(':') ? read_bitsize(name, fieldtype) : -1;\n            vec_push(r, make_pair(name, fieldtype));\n            if (next_token(','))\n                continue;\n            if (is_keyword(peek(), '}'))\n                warnt(peek(), \"missing ';' at the end of field list\");\n            else\n                expect(';');\n            break;\n        }\n    }\n    expect('}');\n    return r;\n}\n\nstatic void fix_rectype_flexible_member(Vector *fields) {\n    for (int i = 0; i < vec_len(fields); i++) {\n        void **pair = vec_get(fields, i);\n        char *name = pair[0];\n        Type *ty = pair[1];\n        if (ty->kind != KIND_ARRAY)\n            continue;\n        if (ty->len == -1) {\n            if (i != vec_len(fields) - 1)\n                error(\"flexible member may only appear as the last member: %s %s\", ty2s(ty), name);\n            if (vec_len(fields) == 1)\n                error(\"flexible member with no other fields: %s %s\", ty2s(ty), name);\n            ty->len = 0;\n            ty->size = 0;\n        }\n    }\n}\n\nstatic void finish_bitfield(int *off, int *bitoff) {\n    *off += (*bitoff + 7) / 8;\n    *bitoff = 0;\n}\n\nstatic Dict *update_struct_offset(int *rsize, int *align, Vector *fields) {\n    int off = 0, bitoff = 0;\n    Dict *r = make_dict();\n    for (int i = 0; i < vec_len(fields); i++) {\n        void **pair = vec_get(fields, i);\n        char *name = pair[0];\n        Type *fieldtype = pair[1];\n        // C11 6.7.2.1p14: Each member is aligned to its natural boundary.\n        // As a result the entire struct is aligned to the largest among its members.\n        // Unnamed fields will never be accessed, so they shouldn't be taken into account\n        // when calculating alignment.\n        if (name)\n            *align = MAX(*align, fieldtype->align);\n\n        if (name == NULL && fieldtype->kind == KIND_STRUCT) {\n            // C11 6.7.2.1p13: Anonymous struct\n            finish_bitfield(&off, &bitoff);\n            off += compute_padding(off, fieldtype->align);\n            squash_unnamed_struct(r, fieldtype, off);\n            off += fieldtype->size;\n            continue;\n        }\n        if (fieldtype->bitsize == 0) {\n            // C11 6.7.2.1p12: The zero-size bit-field indicates the end of the\n            // current run of the bit-fields.\n            finish_bitfield(&off, &bitoff);\n            off += compute_padding(off, fieldtype->align);\n            bitoff = 0;\n            continue;\n        }\n        if (fieldtype->bitsize > 0) {\n            int bit = fieldtype->size * 8;\n            int room = bit - (off * 8 + bitoff) % bit;\n            if (fieldtype->bitsize <= room) {\n                fieldtype->offset = off;\n                fieldtype->bitoff = bitoff;\n            } else {\n                finish_bitfield(&off, &bitoff);\n                off += compute_padding(off, fieldtype->align);\n                fieldtype->offset = off;\n                fieldtype->bitoff = 0;\n            }\n            bitoff += fieldtype->bitsize;\n        } else {\n            finish_bitfield(&off, &bitoff);\n            off += compute_padding(off, fieldtype->align);\n            fieldtype->offset = off;\n            off += fieldtype->size;\n        }\n        if (name)\n            dict_put(r, name, fieldtype);\n    }\n    finish_bitfield(&off, &bitoff);\n    *rsize = off + compute_padding(off, *align);\n    return r;\n}\n\nstatic Dict *update_union_offset(int *rsize, int *align, Vector *fields) {\n    int maxsize = 0;\n    Dict *r = make_dict();\n    for (int i = 0; i < vec_len(fields); i++) {\n        void **pair = vec_get(fields, i);\n        char *name = pair[0];\n        Type *fieldtype = pair[1];\n        maxsize = MAX(maxsize, fieldtype->size);\n        *align = MAX(*align, fieldtype->align);\n        if (name == NULL && fieldtype->kind == KIND_STRUCT) {\n            squash_unnamed_struct(r, fieldtype, 0);\n            continue;\n        }\n        fieldtype->offset = 0;\n        if (fieldtype->bitsize >= 0)\n            fieldtype->bitoff = 0;\n        if (name)\n            dict_put(r, name, fieldtype);\n    }\n    *rsize = maxsize + compute_padding(maxsize, *align);\n    return r;\n}\n\nstatic Dict *read_rectype_fields(int *rsize, int *align, bool is_struct) {\n    if (!next_token('{'))\n        return NULL;\n    Vector *fields = read_rectype_fields_sub();\n    fix_rectype_flexible_member(fields);\n    if (is_struct)\n        return update_struct_offset(rsize, align, fields);\n    return update_union_offset(rsize, align, fields);\n}\n\nstatic Type *read_rectype_def(bool is_struct) {\n    char *tag = read_rectype_tag();\n    Type *r;\n    if (tag) {\n        r = map_get(tags, tag);\n        if (r && (r->kind == KIND_ENUM || r->is_struct != is_struct))\n            error(\"declarations of %s does not match\", tag);\n        if (!r) {\n            r = make_rectype(is_struct);\n            map_put(tags, tag, r);\n        }\n    } else {\n        r = make_rectype(is_struct);\n    }\n    int size = 0, align = 1;\n    Dict *fields = read_rectype_fields(&size, &align, is_struct);\n    r->align = align;\n    if (fields) {\n        r->fields = fields;\n        r->size = size;\n    }\n    return r;\n}\n\nstatic Type *read_struct_def() {\n    return read_rectype_def(true);\n}\n\nstatic Type *read_union_def() {\n    return read_rectype_def(false);\n}\n\n/*\n * Enum\n */\n\nstatic Type *read_enum_def() {\n    char *tag = NULL;\n    Token *tok = get();\n\n    // Enum is handled as a synonym for int. We only check if the enum\n    // is declared.\n    if (tok->kind == TIDENT) {\n        tag = tok->sval;\n        tok = get();\n    }\n    if (tag) {\n        Type *ty = map_get(tags, tag);\n        if (ty && ty->kind != KIND_ENUM)\n            errort(tok, \"declarations of %s does not match\", tag);\n    }\n    if (!is_keyword(tok, '{')) {\n        if (!tag || !map_get(tags, tag))\n            errort(tok, \"enum tag %s is not defined\", tag);\n        unget_token(tok);\n        return type_int;\n    }\n    if (tag)\n        map_put(tags, tag, type_enum);\n\n    int val = 0;\n    for (;;) {\n        tok = get();\n        if (is_keyword(tok, '}'))\n            break;\n        if (tok->kind != TIDENT)\n            errort(tok, \"identifier expected, but got %s\", tok2s(tok));\n        char *name = tok->sval;\n\n        if (next_token('='))\n            val = read_intexpr();\n        Node *constval = ast_inttype(type_int, val++);\n        map_put(env(), name, constval);\n        if (next_token(','))\n            continue;\n        if (next_token('}'))\n            break;\n        errort(peek(), \"',' or '}' expected, but got %s\", tok2s(peek()));\n    }\n    return type_int;\n}\n\n/*\n * Initializer\n */\n\nstatic void assign_string(Vector *inits, Type *ty, char *p, int off) {\n    if (ty->len == -1)\n        ty->len = ty->size = strlen(p) + 1;\n    int i = 0;\n    for (; i < ty->len && *p; i++)\n        vec_push(inits, ast_init(ast_inttype(type_char, *p++), type_char, off + i));\n    for (; i < ty->len; i++)\n        vec_push(inits, ast_init(ast_inttype(type_char, 0), type_char, off + i));\n}\n\nstatic bool maybe_read_brace() {\n    return next_token('{');\n}\n\nstatic void maybe_skip_comma() {\n    next_token(',');\n}\n\nstatic void skip_to_brace() {\n    for (;;) {\n        if (next_token('}'))\n            return;\n        if (next_token('.')) {\n            get();\n            expect('=');\n        }\n        Token *tok = peek();\n        Node *ignore = read_assignment_expr();\n        if (!ignore)\n            return;\n        warnt(tok, \"excessive initializer: %s\", node2s(ignore));\n        maybe_skip_comma();\n    }\n}\n\nstatic void read_initializer_elem(Vector *inits, Type *ty, int off, bool designated) {\n    next_token('=');\n    if (ty->kind == KIND_ARRAY || ty->kind == KIND_STRUCT) {\n        read_initializer_list(inits, ty, off, designated);\n    } else if (next_token('{')) {\n        read_initializer_elem(inits, ty, off, true);\n        expect('}');\n    } else {\n        Node *expr = conv(read_assignment_expr());\n        ensure_assignable(ty, expr->ty);\n        vec_push(inits, ast_init(expr, ty, off));\n    }\n}\n\nstatic int comp_init(const void *p, const void *q) {\n    int x = (*(Node **)p)->initoff;\n    int y = (*(Node **)q)->initoff;\n    if (x < y) return -1;\n    if (x > y) return 1;\n    return 0;\n}\n\nstatic void sort_inits(Vector *inits) {\n    qsort(vec_body(inits), vec_len(inits), sizeof(void *), comp_init);\n}\n\nstatic void read_struct_initializer_sub(Vector *inits, Type *ty, int off, bool designated) {\n    bool has_brace = maybe_read_brace();\n    Vector *keys = dict_keys(ty->fields);\n    int i = 0;\n    for (;;) {\n        Token *tok = get();\n        if (is_keyword(tok, '}')) {\n            if (!has_brace)\n                unget_token(tok);\n            return;\n        }\n        char *fieldname;\n        Type *fieldtype;\n        if ((is_keyword(tok, '.') || is_keyword(tok, '[')) && !has_brace && !designated) {\n            unget_token(tok);\n            return;\n        }\n        if (is_keyword(tok, '.')) {\n            tok = get();\n            if (!tok || tok->kind != TIDENT)\n                errort(tok, \"malformed desginated initializer: %s\", tok2s(tok));\n            fieldname = tok->sval;\n            fieldtype = dict_get(ty->fields, fieldname);\n            if (!fieldtype)\n                errort(tok, \"field does not exist: %s\", tok2s(tok));\n            keys = dict_keys(ty->fields);\n            i = 0;\n            while (i < vec_len(keys)) {\n                char *s = vec_get(keys, i++);\n                if (strcmp(fieldname, s) == 0)\n                    break;\n            }\n            designated = true;\n        } else {\n            unget_token(tok);\n            if (i == vec_len(keys))\n                break;\n            fieldname = vec_get(keys, i++);\n            fieldtype = dict_get(ty->fields, fieldname);\n        }\n        read_initializer_elem(inits, fieldtype, off + fieldtype->offset, designated);\n        maybe_skip_comma();\n        designated = false;\n        if (!ty->is_struct)\n            break;\n    }\n    if (has_brace)\n        skip_to_brace();\n}\n\nstatic void read_struct_initializer(Vector *inits, Type *ty, int off, bool designated) {\n    read_struct_initializer_sub(inits, ty, off, designated);\n    sort_inits(inits);\n}\n\nstatic void read_array_initializer_sub(Vector *inits, Type *ty, int off, bool designated) {\n    bool has_brace = maybe_read_brace();\n    bool flexible = (ty->len <= 0);\n    int elemsize = ty->ptr->size;\n    int i;\n    for (i = 0; flexible || i < ty->len; i++) {\n        Token *tok = get();\n        if (is_keyword(tok, '}')) {\n            if (!has_brace)\n                unget_token(tok);\n            goto finish;\n        }\n        if ((is_keyword(tok, '.') || is_keyword(tok, '[')) && !has_brace && !designated) {\n            unget_token(tok);\n            return;\n        }\n        if (is_keyword(tok, '[')) {\n            Token *tok = peek();\n            int idx = read_intexpr();\n            if (idx < 0 || (!flexible && ty->len <= idx))\n                errort(tok, \"array designator exceeds array bounds: %d\", idx);\n            i = idx;\n            expect(']');\n            designated = true;\n        } else {\n            unget_token(tok);\n        }\n        read_initializer_elem(inits, ty->ptr, off + elemsize * i, designated);\n        maybe_skip_comma();\n        designated = false;\n    }\n    if (has_brace)\n        skip_to_brace();\n finish:\n    if (ty->len < 0) {\n        ty->len = i;\n        ty->size = elemsize * i;\n    }\n}\n\nstatic void read_array_initializer(Vector *inits, Type *ty, int off, bool designated) {\n    read_array_initializer_sub(inits, ty, off, designated);\n    sort_inits(inits);\n}\n\nstatic void read_initializer_list(Vector *inits, Type *ty, int off, bool designated) {\n    Token *tok = get();\n    if (is_string(ty)) {\n        if (tok->kind == TSTRING) {\n            assign_string(inits, ty, tok->sval, off);\n            return;\n        }\n        if (is_keyword(tok, '{') && peek()->kind == TSTRING) {\n            tok = get();\n            assign_string(inits, ty, tok->sval, off);\n            expect('}');\n            return;\n        }\n    }\n    unget_token(tok);\n    if (ty->kind == KIND_ARRAY) {\n        read_array_initializer(inits, ty, off, designated);\n    } else if (ty->kind == KIND_STRUCT) {\n        read_struct_initializer(inits, ty, off, designated);\n    } else {\n        Type *arraytype = make_array_type(ty, 1);\n        read_array_initializer(inits, arraytype, off, designated);\n    }\n}\n\nstatic Vector *read_decl_init(Type *ty) {\n    Vector *r = make_vector();\n    if (is_keyword(peek(), '{') || is_string(ty)) {\n        read_initializer_list(r, ty, 0, false);\n    } else {\n        Node *init = conv(read_assignment_expr());\n        if (is_arithtype(init->ty) && init->ty->kind != ty->kind)\n            init = ast_conv(ty, init);\n        vec_push(r, ast_init(init, ty, 0));\n    }\n    return r;\n}\n\n/*\n * Declarator\n *\n * C's syntax for declaration is not only hard to read for humans but also\n * hard to parse for hand-written parsers. Consider the following two cases:\n *\n *   A: int *x;\n *   B: int *x();\n *\n * A is of type pointer to int, but B is not a pointer type B is of type\n * function returning a pointer to an integer. The meaning of the first half\n * of the declaration (\"int *\" part) is different between them.\n *\n * In 8cc, delcarations are parsed by two functions: read_declarator\n * and read_declarator_tail. The former function parses the first half of a\n * declaration, and the latter parses the (possibly nonexistent) parentheses\n * of a function or an array.\n */\n\nstatic Type *read_func_param(char **name, bool optional) {\n    int sclass = 0;\n    Type *basety = type_int;\n    if (is_type(peek())) {\n        basety = read_decl_spec(&sclass);\n    } else if (optional) {\n        errort(peek(), \"type expected, but got %s\", tok2s(peek()));\n    }\n    Type *ty = read_declarator(name, basety, NULL, optional ? DECL_PARAM_TYPEONLY : DECL_PARAM);\n    // C11 6.7.6.3p7: Array of T is adjusted to pointer to T\n    // in a function parameter list.\n    if (ty->kind == KIND_ARRAY)\n        return make_ptr_type(ty->ptr);\n    // C11 6.7.6.3p8: Function is adjusted to pointer to function\n    // in a function parameter list.\n    if (ty->kind == KIND_FUNC)\n        return make_ptr_type(ty);\n    return ty;\n}\n\n// Reads an ANSI-style prototyped function parameter list.\nstatic void read_declarator_params(Vector *types, Vector *vars, bool *ellipsis) {\n    bool typeonly = !vars;\n    *ellipsis = false;\n    for (;;) {\n        Token *tok = peek();\n        if (next_token(KELLIPSIS)) {\n            if (vec_len(types) == 0)\n                errort(tok, \"at least one parameter is required before \\\"...\\\"\");\n            expect(')');\n            *ellipsis = true;\n            return;\n        }\n        char *name;\n        Type *ty = read_func_param(&name, typeonly);\n        ensure_not_void(ty);\n        vec_push(types, ty);\n        if (!typeonly)\n            vec_push(vars, ast_lvar(ty, name));\n        tok = get();\n        if (is_keyword(tok, ')'))\n            return;\n        if (!is_keyword(tok, ','))\n            errort(tok, \"comma expected, but got %s\", tok2s(tok));\n    }\n}\n\n// Reads a K&R-style un-prototyped function parameter list.\nstatic void read_declarator_params_oldstyle(Vector *vars) {\n    for (;;) {\n        Token *tok = get();\n        if (tok->kind != TIDENT)\n            errort(tok, \"identifier expected, but got %s\", tok2s(tok));\n        vec_push(vars, ast_lvar(type_int, tok->sval));\n        if (next_token(')'))\n            return;\n        if (!next_token(','))\n            errort(tok, \"comma expected, but got %s\", tok2s(get()));\n    }\n}\n\nstatic Type *read_func_param_list(Vector *paramvars, Type *rettype) {\n    // C11 6.7.6.3p10: A parameter list with just \"void\" specifies that\n    // the function has no parameters.\n    Token *tok = get();\n    if (is_keyword(tok, KVOID) && next_token(')'))\n        return make_func_type(rettype, make_vector(), false, false);\n\n    // C11 6.7.6.3p14: K&R-style un-prototyped declaration or\n    // function definition having no parameters.\n    // We return a type representing K&R-style declaration here.\n    // If this is actually part of a declartion, the type will be fixed later.\n    if (is_keyword(tok, ')'))\n        return make_func_type(rettype, make_vector(), true, true);\n    unget_token(tok);\n\n    Token *tok2 = peek();\n    if (next_token(KELLIPSIS))\n        errort(tok2, \"at least one parameter is required before \\\"...\\\"\");\n    if (is_type(peek())) {\n        bool ellipsis;\n        Vector *paramtypes = make_vector();\n        read_declarator_params(paramtypes, paramvars, &ellipsis);\n        return make_func_type(rettype, paramtypes, ellipsis, false);\n    }\n    if (!paramvars)\n        errort(tok, \"invalid function definition\");\n    read_declarator_params_oldstyle(paramvars);\n    Vector *paramtypes = make_vector();\n    for (int i = 0; i < vec_len(paramvars); i++)\n        vec_push(paramtypes, type_int);\n    return make_func_type(rettype, paramtypes, false, true);\n}\n\nstatic Type *read_declarator_array(Type *basety) {\n    int len;\n    if (next_token(']')) {\n        len = -1;\n    } else {\n        len = read_intexpr();\n        expect(']');\n    }\n    Token *tok = peek();\n    Type *t = read_declarator_tail(basety, NULL);\n    if (t->kind == KIND_FUNC)\n        errort(tok, \"array of functions\");\n    return make_array_type(t, len);\n}\n\nstatic Type *read_declarator_func(Type *basety, Vector *param) {\n    if (basety->kind == KIND_FUNC)\n        error(\"function returning a function\");\n    if (basety->kind == KIND_ARRAY)\n        error(\"function returning an array\");\n    return read_func_param_list(param, basety);\n}\n\nstatic Type *read_declarator_tail(Type *basety, Vector *params) {\n    if (next_token('['))\n        return read_declarator_array(basety);\n    if (next_token('('))\n        return read_declarator_func(basety, params);\n    return basety;\n}\n\nstatic void skip_type_qualifiers() {\n    while (next_token(KCONST) || next_token(KVOLATILE) || next_token(KRESTRICT));\n}\n\n// C11 6.7.6: Declarators\nstatic Type *read_declarator(char **rname, Type *basety, Vector *params, int ctx) {\n    if (next_token('(')) {\n        // '(' is either beginning of grouping parentheses or of a function parameter list.\n        // If the next token is a type name, a parameter list must follow.\n        if (is_type(peek()))\n            return read_declarator_func(basety, params);\n        // If not, it's grouping. In that case we have to read from outside.\n        // For example, consider int (*)(), which is \"pointer to function returning int\".\n        // We have only read \"int\" so far. We don't want to pass \"int\" to\n        // a recursive call, or otherwise we would get \"pointer to int\".\n        // Here, we pass a dummy object to get \"pointer to <something>\" first,\n        // continue reading to get \"function returning int\", and then combine them.\n        Type *stub = make_stub_type();\n        Type *t = read_declarator(rname, stub, params, ctx);\n        expect(')');\n        *stub = *read_declarator_tail(basety, params);\n        return t;\n    }\n    if (next_token('*')) {\n        skip_type_qualifiers();\n        return read_declarator(rname, make_ptr_type(basety), params, ctx);\n    }\n    Token *tok = get();\n    if (tok->kind == TIDENT) {\n        if (ctx == DECL_CAST)\n            errort(tok, \"identifier is not expected, but got %s\", tok2s(tok));\n        *rname = tok->sval;\n        return read_declarator_tail(basety, params);\n    }\n    if (ctx == DECL_BODY || ctx == DECL_PARAM)\n        errort(tok, \"identifier, ( or * are expected, but got %s\", tok2s(tok));\n    unget_token(tok);\n    return read_declarator_tail(basety, params);\n}\n\n// C11 6.7.7: Type names\n// read_abstract_declarator reads a type name.\n// A type name is a declaration that omits the identifier.\n// A few examples are int* (pointer to int), int() (function returning int),\n// int*() (function returning pointer to int),\n// or int(*)() (pointer to function returning int). Used for casting.\nstatic Type *read_abstract_declarator(Type *basety) {\n    return read_declarator(NULL, basety, NULL, DECL_CAST);\n}\n\n/*\n * typeof()\n */\n\nstatic Type *read_typeof() {\n    expect('(');\n    Type *r = is_type(peek())\n        ? read_cast_type()\n        : read_comma_expr()->ty;\n    expect(')');\n    return r;\n}\n\n/*\n * Declaration specifier\n */\n\nstatic bool is_poweroftwo(int x) {\n    // If there's only one bit set in x, the value is a power of 2.\n    return (x <= 0) ? false : !(x & (x - 1));\n}\n\nstatic int read_alignas() {\n    // C11 6.7.5. Valid form of _Alignof is either _Alignas(type-name) or\n    // _Alignas(constant-expression).\n    expect('(');\n    int r = is_type(peek())\n        ? read_cast_type()->align\n        : read_intexpr();\n    expect(')');\n    return r;\n}\n\nstatic Type *read_decl_spec(int *rsclass) {\n    int sclass = 0;\n    Token *tok = peek();\n    if (!is_type(tok))\n        errort(tok, \"type name expected, but got %s\", tok2s(tok));\n\n    Type *usertype = NULL;\n    enum { kvoid = 1, kbool, kchar, kint, kfloat, kdouble } kind = 0;\n    enum { kshort = 1, klong, kllong } size = 0;\n    enum { ksigned = 1, kunsigned } sig = 0;\n    int align = -1;\n\n    for (;;) {\n        tok = get();\n        if (tok->kind == EOF)\n            error(\"premature end of input\");\n        if (kind == 0 && tok->kind == TIDENT && !usertype) {\n            Type *def = get_typedef(tok->sval);\n            if (def) {\n                if (usertype) goto err;\n                usertype = def;\n                goto errcheck;\n            }\n        }\n        if (tok->kind != TKEYWORD) {\n            unget_token(tok);\n            break;\n        }\n        switch (tok->id) {\n        case KTYPEDEF:  if (sclass) goto err; sclass = S_TYPEDEF; break;\n        case KEXTERN:   if (sclass) goto err; sclass = S_EXTERN; break;\n        case KSTATIC:   if (sclass) goto err; sclass = S_STATIC; break;\n        case KAUTO:     if (sclass) goto err; sclass = S_AUTO; break;\n        case KREGISTER: if (sclass) goto err; sclass = S_REGISTER; break;\n        case KCONST:    break;\n        case KVOLATILE: break;\n        case KINLINE:   break;\n        case KNORETURN: break;\n        case KVOID:     if (kind) goto err; kind = kvoid; break;\n        case KBOOL:     if (kind) goto err; kind = kbool; break;\n        case KCHAR:     if (kind) goto err; kind = kchar; break;\n        case KINT:      if (kind) goto err; kind = kint; break;\n        case KFLOAT:    if (kind) goto err; kind = kfloat; break;\n        case KDOUBLE:   if (kind) goto err; kind = kdouble; break;\n        case KSIGNED:   if (sig) goto err; sig = ksigned; break;\n        case KUNSIGNED: if (sig) goto err; sig = kunsigned; break;\n        case KSHORT:    if (size) goto err; size = kshort; break;\n        case KSTRUCT:   if (usertype) goto err; usertype = read_struct_def(); break;\n        case KUNION:    if (usertype) goto err; usertype = read_union_def(); break;\n        case KENUM:     if (usertype) goto err; usertype = read_enum_def(); break;\n        case KALIGNAS: {\n            int val = read_alignas();\n            if (val < 0)\n                errort(tok, \"negative alignment: %d\", val);\n            // C11 6.7.5p6: alignas(0) should have no effect.\n            if (val == 0)\n                break;\n            if (align == -1 || val < align)\n                align = val;\n            break;\n        }\n        case KLONG: {\n            if (size == 0) size = klong;\n            else if (size == klong) size = kllong;\n            else goto err;\n            break;\n        }\n        case KTYPEOF: {\n            if (usertype) goto err;\n            usertype = read_typeof();\n            break;\n        }\n        default:\n            unget_token(tok);\n            goto done;\n        }\n      errcheck:\n        if (kind == kbool && (size != 0 && sig != 0))\n            goto err;\n        if (size == kshort && (kind != 0 && kind != kint))\n            goto err;\n        if (size == klong && (kind != 0 && kind != kint && kind != kdouble))\n            goto err;\n        if (sig != 0 && (kind == kvoid || kind == kfloat || kind == kdouble))\n            goto err;\n        if (usertype && (kind != 0 || size != 0 || sig != 0))\n            goto err;\n    }\n done:\n    if (rsclass)\n        *rsclass = sclass;\n    if (usertype)\n        return usertype;\n    if (align != -1 && !is_poweroftwo(align))\n        errort(tok, \"alignment must be power of 2, but got %d\", align);\n    Type *ty;\n    switch (kind) {\n    case kvoid:   ty = type_void; goto end;\n    case kbool:   ty = make_numtype(KIND_BOOL, false); goto end;\n    case kchar:   ty = make_numtype(KIND_CHAR, sig == kunsigned); goto end;\n    case kfloat:  ty = make_numtype(KIND_FLOAT, false); goto end;\n    case kdouble: ty = make_numtype(size == klong ? KIND_LDOUBLE : KIND_DOUBLE, false); goto end;\n    default: break;\n    }\n    switch (size) {\n    case kshort: ty = make_numtype(KIND_SHORT, sig == kunsigned); goto end;\n    case klong:  ty = make_numtype(KIND_LONG, sig == kunsigned); goto end;\n    case kllong: ty = make_numtype(KIND_LLONG, sig == kunsigned); goto end;\n    default:     ty = make_numtype(KIND_INT, sig == kunsigned); goto end;\n    }\n    error(\"internal error: kind: %d, size: %d\", kind, size);\n end:\n    if (align != -1)\n        ty->align = align;\n    return ty;\n err:\n    errort(tok, \"type mismatch: %s\", tok2s(tok));\n}\n\n/*\n * Declaration\n */\n\nstatic void read_static_local_var(Type *ty, char *name) {\n    Node *var = ast_static_lvar(ty, name);\n    Vector *init = NULL;\n    if (next_token('=')) {\n        Map *orig = localenv;\n        localenv = NULL;\n        init = read_decl_init(ty);\n        localenv = orig;\n    }\n    vec_push(toplevels, ast_decl(var, init));\n}\n\nstatic Type *read_decl_spec_opt(int *sclass) {\n    if (is_type(peek()))\n        return read_decl_spec(sclass);\n    warnt(peek(), \"type specifier missing, assuming int\");\n    return type_int;\n}\n\nstatic void read_decl(Vector *block, bool isglobal) {\n    int sclass = 0;\n    Type *basetype = read_decl_spec_opt(&sclass);\n    if (next_token(';'))\n        return;\n    for (;;) {\n        char *name = NULL;\n        Type *ty = read_declarator(&name, copy_incomplete_type(basetype), NULL, DECL_BODY);\n        ty->isstatic = (sclass == S_STATIC);\n        if (sclass == S_TYPEDEF) {\n            ast_typedef(ty, name);\n        } else if (ty->isstatic && !isglobal) {\n            ensure_not_void(ty);\n            read_static_local_var(ty, name);\n        } else {\n            ensure_not_void(ty);\n            Node *var = (isglobal ? ast_gvar : ast_lvar)(ty, name);\n            if (next_token('=')) {\n                vec_push(block, ast_decl(var, read_decl_init(ty)));\n            } else if (sclass != S_EXTERN && ty->kind != KIND_FUNC) {\n                vec_push(block, ast_decl(var, NULL));\n            }\n        }\n        if (next_token(';'))\n            return;\n        if (!next_token(','))\n            errort(peek(), \"';' or ',' are expected, but got %s\", tok2s(peek()));\n    }\n}\n\n/*\n * K&R-style parameter types\n */\n\nstatic Vector *read_oldstyle_param_args() {\n    Map *orig = localenv;\n    localenv = NULL;\n    Vector *r = make_vector();\n    for (;;) {\n        if (is_keyword(peek(), '{'))\n            break;\n        if (!is_type(peek()))\n            errort(peek(), \"K&R-style declarator expected, but got %s\", tok2s(peek()));\n        read_decl(r, false);\n    }\n    localenv = orig;\n    return r;\n}\n\nstatic void update_oldstyle_param_type(Vector *params, Vector *vars) {\n    for (int i = 0; i < vec_len(vars); i++) {\n        Node *decl = vec_get(vars, i);\n        assert(decl->kind == AST_DECL);\n        Node *var = decl->declvar;\n        assert(var->kind == AST_LVAR);\n        for (int j = 0; j < vec_len(params); j++) {\n            Node *param = vec_get(params, j);\n            assert(param->kind == AST_LVAR);\n            if (strcmp(param->varname, var->varname))\n                continue;\n            param->ty = var->ty;\n            goto found;\n        }\n        error(\"missing parameter: %s\", var->varname);\n    found:;\n    }\n}\n\nstatic void read_oldstyle_param_type(Vector *params) {\n    Vector *vars = read_oldstyle_param_args();\n    update_oldstyle_param_type(params, vars);\n}\n\nstatic Vector *param_types(Vector *params) {\n    Vector *r = make_vector();\n    for (int i = 0; i < vec_len(params); i++) {\n        Node *param = vec_get(params, i);\n        vec_push(r, param->ty);\n    }\n    return r;\n}\n\n/*\n * Function definition\n */\n\nstatic Node *read_func_body(Type *functype, char *fname, Vector *params) {\n    localenv = make_map_parent(localenv);\n    localvars = make_vector();\n    current_func_type = functype;\n    Node *funcname = ast_string(ENC_NONE, fname, strlen(fname) + 1);\n    map_put(localenv, \"__func__\", funcname);\n    map_put(localenv, \"__FUNCTION__\", funcname);\n    Node *body = read_compound_stmt();\n    Node *r = ast_func(functype, fname, params, body, localvars);\n    current_func_type = NULL;\n    localenv = NULL;\n    localvars = NULL;\n    return r;\n}\n\nstatic void skip_parentheses(Vector *buf) {\n    for (;;) {\n        Token *tok = get();\n        if (tok->kind == TEOF)\n            error(\"premature end of input\");\n        vec_push(buf, tok);\n        if (is_keyword(tok, ')'))\n            return;\n        if (is_keyword(tok, '('))\n            skip_parentheses(buf);\n    }\n}\n\n// is_funcdef returns true if we are at beginning of a function definition.\n// The basic idea is that if we see '{' or a type keyword after a closing\n// parenthesis of a function parameter list, we were reading a function\n// definition. (Usually '{' comes after a closing parenthesis.\n// A type keyword is allowed for K&R-style function definitions.)\nstatic bool is_funcdef() {\n    Vector *buf = make_vector();\n    bool r = false;\n    for (;;) {\n        Token *tok = get();\n        vec_push(buf, tok);\n        if (tok->kind == TEOF)\n            error(\"premature end of input\");\n        if (is_keyword(tok, ';'))\n            break;\n        if (is_type(tok))\n            continue;\n        if (is_keyword(tok, '(')) {\n            skip_parentheses(buf);\n            continue;\n        }\n        if (tok->kind != TIDENT)\n            continue;\n        if (!is_keyword(peek(), '('))\n            continue;\n        vec_push(buf, get());\n        skip_parentheses(buf);\n        r = (is_keyword(peek(), '{') || is_type(peek()));\n        break;\n    }\n    while (vec_len(buf) > 0)\n        unget_token(vec_pop(buf));\n    return r;\n}\n\nstatic void backfill_labels() {\n    for (int i = 0; i < vec_len(gotos); i++) {\n        Node *src = vec_get(gotos, i);\n        char *label = src->label;\n        Node *dst = map_get(labels, label);\n        if (!dst)\n            error(\"stray %s: %s\", src->kind == AST_GOTO ? \"goto\" : \"unary &&\", label);\n        if (dst->newlabel)\n            src->newlabel = dst->newlabel;\n        else\n            src->newlabel = dst->newlabel = make_label();\n    }\n}\n\nstatic Node *read_funcdef() {\n    int sclass = 0;\n    Type *basetype = read_decl_spec_opt(&sclass);\n    localenv = make_map_parent(globalenv);\n    gotos = make_vector();\n    labels = make_map();\n    char *name;\n    Vector *params = make_vector();\n    Type *functype = read_declarator(&name, basetype, params, DECL_BODY);\n    if (functype->oldstyle) {\n        if (vec_len(params) == 0)\n            functype->hasva = false;\n        read_oldstyle_param_type(params);\n        functype->params = param_types(params);\n    }\n    functype->isstatic = (sclass == S_STATIC);\n    ast_gvar(functype, name);\n    expect('{');\n    Node *r = read_func_body(functype, name, params);\n    backfill_labels();\n    localenv = NULL;\n    return r;\n}\n\n/*\n * If\n */\n\nstatic Node *read_boolean_expr() {\n    Node *cond = read_expr();\n    return is_flotype(cond->ty) ? ast_conv(type_bool, cond) : cond;\n}\n\nstatic Node *read_if_stmt() {\n    expect('(');\n    Node *cond = read_boolean_expr();\n    expect(')');\n    Node *then = read_stmt();\n    if (!next_token(KELSE))\n        return ast_if(cond, then, NULL);\n    Node *els = read_stmt();\n    return ast_if(cond, then, els);\n}\n\n/*\n * For\n */\n\nstatic Node *read_opt_decl_or_stmt() {\n    if (next_token(';'))\n        return NULL;\n    Vector *list = make_vector();\n    read_decl_or_stmt(list);\n    return ast_compound_stmt(list);\n}\n\n#define SET_JUMP_LABELS(cont, brk)              \\\n    char *ocontinue = lcontinue;                \\\n    char *obreak = lbreak;                      \\\n    lcontinue = cont;                           \\\n    lbreak = brk\n\n#define RESTORE_JUMP_LABELS()                   \\\n    lcontinue = ocontinue;                      \\\n    lbreak = obreak\n\nstatic Node *read_for_stmt() {\n    expect('(');\n    char *beg = make_label();\n    char *mid = make_label();\n    char *end = make_label();\n    Map *orig = localenv;\n    localenv = make_map_parent(localenv);\n    Node *init = read_opt_decl_or_stmt();\n    Node *cond = read_expr_opt();\n    if (cond && is_flotype(cond->ty))\n        cond = ast_conv(type_bool, cond);\n    expect(';');\n    Node *step = read_expr_opt();\n    expect(')');\n    SET_JUMP_LABELS(mid, end);\n    Node *body = read_stmt();\n    RESTORE_JUMP_LABELS();\n    localenv = orig;\n\n    Vector *v = make_vector();\n    if (init)\n        vec_push(v, init);\n    vec_push(v, ast_dest(beg));\n    if (cond)\n        vec_push(v, ast_if(cond, NULL, ast_jump(end)));\n    if (body)\n        vec_push(v, body);\n    vec_push(v, ast_dest(mid));\n    if (step)\n        vec_push(v, step);\n    vec_push(v, ast_jump(beg));\n    vec_push(v, ast_dest(end));\n    return ast_compound_stmt(v);\n}\n\n/*\n * While\n */\n\nstatic Node *read_while_stmt() {\n    expect('(');\n    Node *cond = read_boolean_expr();\n    expect(')');\n\n    char *beg = make_label();\n    char *end = make_label();\n    SET_JUMP_LABELS(beg, end);\n    Node *body = read_stmt();\n    RESTORE_JUMP_LABELS();\n\n    Vector *v = make_vector();\n    vec_push(v, ast_dest(beg));\n    vec_push(v, ast_if(cond, body, ast_jump(end)));\n    vec_push(v, ast_jump(beg));\n    vec_push(v, ast_dest(end));\n    return ast_compound_stmt(v);\n}\n\n/*\n * Do\n */\n\nstatic Node *read_do_stmt() {\n    char *beg = make_label();\n    char *end = make_label();\n    SET_JUMP_LABELS(beg, end);\n    Node *body = read_stmt();\n    RESTORE_JUMP_LABELS();\n    Token *tok = get();\n    if (!is_keyword(tok, KWHILE))\n        errort(tok, \"'while' is expected, but got %s\", tok2s(tok));\n    expect('(');\n    Node *cond = read_boolean_expr();\n    expect(')');\n    expect(';');\n\n    Vector *v = make_vector();\n    vec_push(v, ast_dest(beg));\n    if (body)\n        vec_push(v, body);\n    vec_push(v, ast_if(cond, ast_jump(beg), NULL));\n    vec_push(v, ast_dest(end));\n    return ast_compound_stmt(v);\n}\n\n/*\n * Switch\n */\n\nstatic Node *make_switch_jump(Node *var, Case *c) {\n    Node *cond;\n    if (c->beg == c->end) {\n        cond = ast_binop(type_int, OP_EQ, var, ast_inttype(type_int, c->beg));\n    } else {\n        // [GNU] case i ... j is compiled to if (i <= cond && cond <= j) goto <label>.\n        Node *x = ast_binop(type_int, OP_LE, ast_inttype(type_int, c->beg), var);\n        Node *y = ast_binop(type_int, OP_LE, var, ast_inttype(type_int, c->end));\n        cond = ast_binop(type_int, OP_LOGAND, x, y);\n    }\n    return ast_if(cond, ast_jump(c->label), NULL);\n}\n\n// C11 6.8.4.2p3: No two case constant expressions have the same value.\nstatic void check_case_duplicates(Vector *cases) {\n    int len = vec_len(cases);\n    Case *x = vec_get(cases, len - 1);\n    for (int i = 0; i < len - 1; i++) {\n        Case *y = vec_get(cases, i);\n        if (x->end < y->beg || y->end < x->beg)\n            continue;\n        if (x->beg == x->end)\n            error(\"duplicate case value: %d\", x->beg);\n        error(\"duplicate case value: %d ... %d\", x->beg, x->end);\n    }\n}\n\n#define SET_SWITCH_CONTEXT(brk)                 \\\n    Vector *ocases = cases;                     \\\n    char *odefaultcase = defaultcase;           \\\n    char *obreak = lbreak;                      \\\n    cases = make_vector();                      \\\n    defaultcase = NULL;                         \\\n    lbreak = brk\n\n#define RESTORE_SWITCH_CONTEXT()                \\\n    cases = ocases;                             \\\n    defaultcase = odefaultcase;                 \\\n    lbreak = obreak\n\nstatic Node *read_switch_stmt() {\n    expect('(');\n    Node *expr = conv(read_expr());\n    ensure_inttype(expr);\n    expect(')');\n\n    char *end = make_label();\n    SET_SWITCH_CONTEXT(end);\n    Node *body = read_stmt();\n    Vector *v = make_vector();\n    Node *var = ast_lvar(expr->ty, make_tempname());\n    vec_push(v, ast_binop(expr->ty, '=', var, expr));\n    for (int i = 0; i < vec_len(cases); i++)\n        vec_push(v, make_switch_jump(var, vec_get(cases, i)));\n    vec_push(v, ast_jump(defaultcase ? defaultcase : end));\n    if (body)\n        vec_push(v, body);\n    vec_push(v, ast_dest(end));\n    RESTORE_SWITCH_CONTEXT();\n    return ast_compound_stmt(v);\n}\n\nstatic Node *read_label_tail(Node *label) {\n    Node *stmt = read_stmt();\n    Vector *v = make_vector();\n    vec_push(v, label);\n    if (stmt)\n        vec_push(v, stmt);\n    return ast_compound_stmt(v);\n}\n\nstatic Node *read_case_label(Token *tok) {\n    if (!cases)\n        errort(tok, \"stray case label\");\n    char *label = make_label();\n    int beg = read_intexpr();\n    if (next_token(KELLIPSIS)) {\n        int end = read_intexpr();\n        expect(':');\n        if (beg > end)\n            errort(tok, \"case region is not in correct order: %d ... %d\", beg, end);\n        vec_push(cases, make_case(beg, end, label));\n    } else {\n        expect(':');\n        vec_push(cases, make_case(beg, beg, label));\n    }\n    check_case_duplicates(cases);\n    return read_label_tail(ast_dest(label));\n}\n\nstatic Node *read_default_label(Token *tok) {\n    expect(':');\n    if (defaultcase)\n        errort(tok, \"duplicate default\");\n    defaultcase = make_label();\n    return read_label_tail(ast_dest(defaultcase));\n}\n\n/*\n * Jump statements\n */\n\nstatic Node *read_break_stmt(Token *tok) {\n    expect(';');\n    if (!lbreak)\n        errort(tok, \"stray break statement\");\n    return ast_jump(lbreak);\n}\n\nstatic Node *read_continue_stmt(Token *tok) {\n    expect(';');\n    if (!lcontinue)\n        errort(tok, \"stray continue statement\");\n    return ast_jump(lcontinue);\n}\n\nstatic Node *read_return_stmt() {\n    Node *retval = read_expr_opt();\n    expect(';');\n    if (retval)\n        return ast_return(ast_conv(current_func_type->rettype, retval));\n    return ast_return(NULL);\n}\n\nstatic Node *read_goto_stmt() {\n    if (next_token('*')) {\n        // [GNU] computed goto. \"goto *p\" jumps to the address pointed by p.\n        Token *tok = peek();\n        Node *expr = read_cast_expr();\n        if (expr->ty->kind != KIND_PTR)\n            errort(tok, \"pointer expected for computed goto, but got %s\", node2s(expr));\n        return ast_computed_goto(expr);\n    }\n    Token *tok = get();\n    if (!tok || tok->kind != TIDENT)\n        errort(tok, \"identifier expected, but got %s\", tok2s(tok));\n    expect(';');\n    Node *r = ast_goto(tok->sval);\n    vec_push(gotos, r);\n    return r;\n}\n\nstatic Node *read_label(Token *tok) {\n    char *label = tok->sval;\n    if (map_get(labels, label))\n        errort(tok, \"duplicate label: %s\", tok2s(tok));\n    Node *r = ast_label(label);\n    map_put(labels, label, r);\n    return read_label_tail(r);\n}\n\n/*\n * Statement\n */\n\nstatic Node *read_stmt() {\n    Token *tok = get();\n    if (tok->kind == TKEYWORD) {\n        switch (tok->id) {\n        case '{':       return read_compound_stmt();\n        case KIF:       return read_if_stmt();\n        case KFOR:      return read_for_stmt();\n        case KWHILE:    return read_while_stmt();\n        case KDO:       return read_do_stmt();\n        case KRETURN:   return read_return_stmt();\n        case KSWITCH:   return read_switch_stmt();\n        case KCASE:     return read_case_label(tok);\n        case KDEFAULT:  return read_default_label(tok);\n        case KBREAK:    return read_break_stmt(tok);\n        case KCONTINUE: return read_continue_stmt(tok);\n        case KGOTO:     return read_goto_stmt();\n        }\n    }\n    if (tok->kind == TIDENT && next_token(':'))\n        return read_label(tok);\n    unget_token(tok);\n    Node *r = read_expr_opt();\n    expect(';');\n    return r;\n}\n\nstatic Node *read_compound_stmt() {\n    Map *orig = localenv;\n    localenv = make_map_parent(localenv);\n    Vector *list = make_vector();\n    for (;;) {\n        if (next_token('}'))\n            break;\n        read_decl_or_stmt(list);\n    }\n    localenv = orig;\n    return ast_compound_stmt(list);\n}\n\nstatic void read_decl_or_stmt(Vector *list) {\n    Token *tok = peek();\n    if (tok->kind == TEOF)\n        error(\"premature end of input\");\n    mark_location();\n    if (is_type(tok)) {\n        read_decl(list, false);\n    } else if (next_token(KSTATIC_ASSERT)) {\n        read_static_assert();\n    } else {\n        Node *stmt = read_stmt();\n        if (stmt)\n            vec_push(list, stmt);\n    }\n}\n\n/*\n * Compilation unit\n */\n\nVector *read_toplevels() {\n    toplevels = make_vector();\n    for (;;) {\n        if (peek()->kind == TEOF)\n            return toplevels;\n        if (is_funcdef())\n            vec_push(toplevels, read_funcdef());\n        else\n            read_decl(toplevels, true);\n    }\n}\n\n/*\n * Token handling\n */\n\n// C11 5.1.1.2p6 Adjacent string literal tokens are concatenated.\nstatic void concatenate_string(Token *tok) {\n    int enc = tok->enc;\n    Buffer *b = make_buffer();\n    buf_append(b, tok->sval, tok->slen - 1);\n    while (peek()->kind == TSTRING) {\n        Token *tok2 = read_token();\n        buf_append(b, tok2->sval, tok2->slen - 1);\n        int enc2 = tok2->enc;\n        if (enc != ENC_NONE && enc2 != ENC_NONE && enc != enc2)\n            errort(tok2, \"unsupported non-standard concatenation of string literals: %s\", tok2s(tok2));\n        if (enc == ENC_NONE)\n            enc = enc2;\n    }\n    buf_write(b, '\\0');\n    tok->sval = buf_body(b);\n    tok->slen = buf_len(b);\n    tok->enc = enc;\n}\n\nstatic Token *get() {\n    Token *r = read_token();\n    if (r->kind == TINVALID)\n        errort(r, \"stray character in program: '%c'\", r->c);\n    if (r->kind == TSTRING && peek()->kind == TSTRING)\n        concatenate_string(r);\n    return r;\n}\n\nstatic Token *peek() {\n    return peek_token();\n}\n\n/*\n * Initializer\n */\n\nstatic void define_builtin(char *name, Type *rettype, Vector *paramtypes) {\n    ast_gvar(make_func_type(rettype, paramtypes, true, false), name);\n}\n\nvoid parse_init() {\n    Vector *voidptr = make_vector1(make_ptr_type(type_void));\n    Vector *two_voidptrs = make_vector();\n    vec_push(two_voidptrs, make_ptr_type(type_void));\n    vec_push(two_voidptrs, make_ptr_type(type_void));\n    define_builtin(\"__builtin_return_address\", make_ptr_type(type_void), voidptr);\n    define_builtin(\"__builtin_reg_class\", type_int, voidptr);\n    define_builtin(\"__builtin_va_arg\", type_void, two_voidptrs);\n    define_builtin(\"__builtin_va_start\", type_void, voidptr);\n}\n"
        },
        {
          "name": "path.c",
          "type": "blob",
          "size": 1.19140625,
          "content": "// Copyright 2014 Rui Ueyama. Released under the MIT license.\n\n#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <unistd.h>\n#include \"8cc.h\"\n\n// Returns the shortest path for the given full path to a file.\nstatic char *clean(char *p) {\n    assert(*p == '/');\n    char buf[PATH_MAX];\n    char *q = buf;\n    *q++ = '/';\n    for (;;) {\n        if (*p == '/') {\n            p++;\n            continue;\n        }\n        if (!memcmp(\"./\", p, 2)) {\n            p += 2;\n            continue;\n        }\n        if (!memcmp(\"../\", p, 3)) {\n            p += 3;\n            if (q == buf + 1)\n                continue;\n            for (q--; q[-1] != '/'; q--);\n            continue;\n        }\n        while (*p != '/' && *p != '\\0')\n            *q++ = *p++;\n        if (*p == '/') {\n            *q++ = *p++;\n            continue;\n        }\n        *q = '\\0';\n        return strdup(buf);\n    }\n}\n\n// Returns the shortest absolute path for the given path.\nchar *fullpath(char *path) {\n    static char cwd[PATH_MAX];\n    if (path[0] == '/')\n        return clean(path);\n    if (*cwd == '\\0' && !getcwd(cwd, PATH_MAX))\n        error(\"getcwd failed: %s\", strerror(errno));\n    return clean(format(\"%s/%s\", cwd, path));\n}\n"
        },
        {
          "name": "set.c",
          "type": "blob",
          "size": 1.1171875,
          "content": "// Copyright 2014 Rui Ueyama. Released under the MIT license.\n\n// Sets are containers that store unique strings.\n//\n// The data structure is functional. Because no destructive\n// operation is defined, it's guranteed that a set will never\n// change once it's created.\n//\n// A null pointer represents an empty set.\n//\n// Set is designed with simplicity in mind.\n// It should be very fast for small number of items.\n// However, if you plan to add a lot of items to a set,\n// you should consider using Map as a set.\n\n#include <stdlib.h>\n#include <string.h>\n#include \"8cc.h\"\n\nSet *set_add(Set *s, char *v) {\n    Set *r = malloc(sizeof(Set));\n    r->next = s;\n    r->v = v;\n    return r;\n}\n\nbool set_has(Set *s, char *v) {\n    for (; s; s = s->next)\n        if (!strcmp(s->v, v))\n            return true;\n    return false;\n}\n\nSet *set_union(Set *a, Set *b) {\n    Set *r = b;\n    for (; a; a = a->next)\n        if (!set_has(b, a->v))\n            r = set_add(r, a->v);\n    return r;\n}\n\nSet *set_intersection(Set *a, Set *b) {\n    Set *r = NULL;\n    for (; a; a = a->next)\n        if (set_has(b, a->v))\n            r = set_add(r, a->v);\n    return r;\n}\n"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "utiltest.c",
          "type": "blob",
          "size": 5.23046875,
          "content": "// Copyright 2012 Rui Ueyama. Released under the MIT license.\n\n#include <string.h>\n#include \"8cc.h\"\n\nchar *get_base_file(void) { return NULL; }\n\n#define assert_true(expr) assert_true2(__LINE__, #expr, (expr))\n#define assert_null(...) assert_null2(__LINE__, __VA_ARGS__)\n#define assert_string(...) assert_string2(__LINE__, __VA_ARGS__)\n#define assert_int(...) assert_int2(__LINE__, __VA_ARGS__)\n\nstatic void assert_true2(int line, char *expr, int result) {\n    if (!result)\n        error(\"%d: assert_true: %s\", line, expr);\n}\n\nstatic void assert_null2(int line, void *p) {\n    if (p)\n        error(\"%d: Null expected\", line);\n}\n\nstatic void assert_string2(int line, char *s, char *t) {\n    if (strcmp(s, t))\n        error(\"%d: Expected \\\"%s\\\" but got \\\"%s\\\"\", line, s, t);\n}\n\nstatic void assert_int2(int line, long a, long b) {\n    if (a != b)\n        error(\"%d: Expected %ld but got %ld\", line, a, b);\n}\n\nstatic void test_buf() {\n    Buffer *b = make_buffer();\n    buf_write(b, 'a');\n    buf_write(b, 'b');\n    buf_write(b, '\\0');\n    assert_string(\"ab\", buf_body(b));\n\n    Buffer *b2 = make_buffer();\n    buf_write(b2, '.');\n    buf_printf(b2, \"%s\", \"0123456789\");\n    assert_string(\".0123456789\", buf_body(b2));\n}\n\nstatic void test_list() {\n    Vector *list = make_vector();\n    assert_int(0, vec_len(list));\n    vec_push(list, (void *)1);\n    assert_int(1, vec_len(list));\n    vec_push(list, (void *)2);\n    assert_int(2, vec_len(list));\n\n    Vector *copy = vec_copy(list);\n    assert_int(2, vec_len(copy));\n    assert_int(1, (long)vec_get(copy, 0));\n    assert_int(2, (long)vec_get(copy, 1));\n\n    Vector *rev = vec_reverse(list);\n    assert_int(2, vec_len(rev));\n    assert_int(1, (long)vec_pop(rev));\n    assert_int(1, vec_len(rev));\n    assert_int(2, (long)vec_pop(rev));\n    assert_int(0, vec_len(rev));\n\n    Vector *list3 = make_vector();\n    vec_push(list3, (void *)1);\n    assert_int(1, (long)vec_head(list3));\n    assert_int(1, (long)vec_tail(list3));\n    vec_push(list3, (void *)2);\n    assert_int(1, (long)vec_head(list3));\n    assert_int(2, (long)vec_tail(list3));\n\n    Vector *list4 = make_vector();\n    vec_push(list4, (void *)1);\n    vec_push(list4, (void *)2);\n    assert_int(1, (long)vec_get(list4, 0));\n    assert_int(2, (long)vec_get(list4, 1));\n}\n\nstatic void test_map() {\n    Map *m = make_map();\n    assert_null(map_get(m, \"abc\"));\n\n    // Insert 10000 values\n    for (int i = 0; i < 10000; i++) {\n        char *k = format(\"%d\", i);\n        map_put(m, k, (void *)(intptr_t)i);\n        assert_int(i, (int)(intptr_t)map_get(m, k));\n    }\n\n    // Insert again\n    for (int i = 0; i < 1000; i++) {\n        char *k = format(\"%d\", i);\n        map_put(m, k, (void *)(intptr_t)i);\n        assert_int(i, (int)(intptr_t)map_get(m, k));\n    }\n\n    // Remove them\n    for (int i = 0; i < 10000; i++) {\n        char *k = format(\"%d\", i);\n        assert_int(i, (intptr_t)map_get(m, k));\n        map_remove(m, k);\n        assert_null(map_get(m, k));\n    }\n}\n\nstatic void test_map_stack() {\n    Map *m1 = make_map();\n    map_put(m1, \"x\", (void *)1);\n    map_put(m1, \"y\", (void *)2);\n    assert_int(1, (int)(intptr_t)map_get(m1, \"x\"));\n\n    Map *m2 = make_map_parent(m1);\n    assert_int(1, (int)(intptr_t)map_get(m2, \"x\"));\n    map_put(m2, \"x\", (void *)3);\n    assert_int(3, (int)(intptr_t)map_get(m2, \"x\"));\n    assert_int(1, (int)(intptr_t)map_get(m1, \"x\"));\n}\n\nstatic void test_dict() {\n    Dict *dict = make_dict();\n    assert_null(dict_get(dict, \"abc\"));\n    dict_put(dict, \"abc\", (void *)50);\n    dict_put(dict, \"xyz\", (void *)70);\n    assert_int(50, (long)dict_get(dict, \"abc\"));\n    assert_int(70, (long)dict_get(dict, \"xyz\"));\n    assert_int(2, vec_len(dict_keys(dict)));\n}\n\nstatic void test_set() {\n    Set *s = NULL;\n    assert_int(0, set_has(s, \"abc\"));\n    s = set_add(s, \"abc\");\n    s = set_add(s, \"def\");\n    assert_int(1, set_has(s, \"abc\"));\n    assert_int(1, set_has(s, \"def\"));\n    assert_int(0, set_has(s, \"xyz\"));\n    Set *t = NULL;\n    t = set_add(t, \"abc\");\n    t = set_add(t, \"DEF\");\n    assert_int(1, set_has(set_union(s, t), \"abc\"));\n    assert_int(1, set_has(set_union(s, t), \"def\"));\n    assert_int(1, set_has(set_union(s, t), \"DEF\"));\n    assert_int(1, set_has(set_intersection(s, t), \"abc\"));\n    assert_int(0, set_has(set_intersection(s, t), \"def\"));\n    assert_int(0, set_has(set_intersection(s, t), \"DEF\"));\n}\n\nstatic void test_path() {\n    assert_string(\"/abc\", fullpath(\"/abc\"));\n    assert_string(\"/abc/def\", fullpath(\"/abc/def\"));\n    assert_string(\"/abc/def\", fullpath(\"/abc///def\"));\n    assert_string(\"/abc/def\", fullpath(\"//abc///def\"));\n    assert_string(\"/abc/xyz\", fullpath(\"/abc/def/../xyz\"));\n    assert_string(\"/xyz\", fullpath(\"/abc/def/../../../xyz\"));\n    assert_string(\"/xyz\", fullpath(\"/abc/def/../../../../xyz\"));\n}\n\nstatic void test_file() {\n    stream_push(make_file_string(\"abc\"));\n    assert_int('a', readc());\n    assert_int('b', readc());\n    unreadc('b');\n    unreadc('a');\n    assert_int('a', readc());\n    assert_int('b', readc());\n    assert_int('c', readc());\n    assert_int('\\n', readc());\n    unreadc('\\n');\n    assert_int('\\n', readc());\n    assert_true(readc() < 0);\n}\n\nint main(int argc, char **argv) {\n    test_buf();\n    test_list();\n    test_map();\n    test_map_stack();\n    test_dict();\n    test_set();\n    test_path();\n    test_file();\n    printf(\"Passed\\n\");\n    return 0;\n}\n"
        },
        {
          "name": "vector.c",
          "type": "blob",
          "size": 2.310546875,
          "content": "// Copyright 2012 Rui Ueyama. Released under the MIT license.\n\n/*\n * Vectors are containers of void pointers that can change in size.\n */\n\n#include <stdlib.h>\n#include <string.h>\n#include \"8cc.h\"\n\n#define MIN_SIZE 8\n\nstatic int max(int a, int b) {\n    return a > b ? a : b;\n}\n\nstatic int roundup(int n) {\n    if (n == 0)\n        return 0;\n    int r = 1;\n    while (n > r)\n        r *= 2;\n    return r;\n}\n\nstatic Vector *do_make_vector(int size) {\n    Vector *r = malloc(sizeof(Vector));\n    size = roundup(size);\n    if (size > 0)\n        r->body = malloc(sizeof(void *) * size);\n    r->len = 0;\n    r->nalloc = size;\n    return r;\n}\n\nVector *make_vector() {\n    return do_make_vector(0);\n}\n\nstatic void extend(Vector *vec, int delta) {\n    if (vec->len + delta <= vec->nalloc)\n        return;\n    int nelem = max(roundup(vec->len + delta), MIN_SIZE);\n    void *newbody = malloc(sizeof(void *) * nelem);\n    memcpy(newbody, vec->body, sizeof(void *) * vec->len);\n    vec->body = newbody;\n    vec->nalloc = nelem;\n}\n\nVector *make_vector1(void *e) {\n    Vector *r = do_make_vector(0);\n    vec_push(r, e);\n    return r;\n}\n\nVector *vec_copy(Vector *src) {\n    Vector *r = do_make_vector(src->len);\n    memcpy(r->body, src->body, sizeof(void *) * src->len);\n    r->len = src->len;\n    return r;\n}\n\nvoid vec_push(Vector *vec, void *elem) {\n    extend(vec, 1);\n    vec->body[vec->len++] = elem;\n}\n\nvoid vec_append(Vector *a, Vector *b) {\n    extend(a, b->len);\n    memcpy(a->body + a->len, b->body, sizeof(void *) * b->len);\n    a->len += b->len;\n}\n\nvoid *vec_pop(Vector *vec) {\n    assert(vec->len > 0);\n    return vec->body[--vec->len];\n}\n\nvoid *vec_get(Vector *vec, int index) {\n    assert(0 <= index && index < vec->len);\n    return vec->body[index];\n}\n\nvoid vec_set(Vector *vec, int index, void *val) {\n    assert(0 <= index && index < vec->len);\n    vec->body[index] = val;\n}\n\nvoid *vec_head(Vector *vec) {\n    assert(vec->len > 0);\n    return vec->body[0];\n}\n\nvoid *vec_tail(Vector *vec) {\n    assert(vec->len > 0);\n    return vec->body[vec->len - 1];\n}\n\nVector *vec_reverse(Vector *vec) {\n    Vector *r = do_make_vector(vec->len);\n    for (int i = 0; i < vec->len; i++)\n        r->body[i] = vec->body[vec->len - i - 1];\n    r->len = vec->len;\n    return r;\n}\n\nvoid *vec_body(Vector *vec) {\n    return vec->body;\n}\n\nint vec_len(Vector *vec) {\n    return vec->len;\n}\n"
        }
      ]
    }
  ]
}