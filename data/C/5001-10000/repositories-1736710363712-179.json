{
  "metadata": {
    "timestamp": 1736710363712,
    "page": 179,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "AFLplusplus/AFLplusplus",
      "stars": 5395,
      "defaultBranch": "stable",
      "files": [
        {
          "name": ".clang-format",
          "type": "blob",
          "size": 3.916015625,
          "content": "---\nLanguage:        Cpp\n# BasedOnStyle:  Google\nAccessModifierOffset: -1\nAlignAfterOpenBracket: Align\nAlignConsecutiveAssignments: false\nAlignConsecutiveDeclarations: true\nAlignEscapedNewlines: Left\nAlignOperands:   true\nAlignTrailingComments: true\nAllowAllParametersOfDeclarationOnNextLine: true\nAllowShortBlocksOnASingleLine: true\nAllowShortCaseLabelsOnASingleLine: false\nAllowShortFunctionsOnASingleLine: false\nAllowShortIfStatementsOnASingleLine: true\nAllowShortLoopsOnASingleLine: false\nAlwaysBreakAfterDefinitionReturnType: None\nAlwaysBreakAfterReturnType: None\nAlwaysBreakBeforeMultilineStrings: true\nAlwaysBreakTemplateDeclarations: Yes\nBinPackArguments: true\nBinPackParameters: true\nBraceWrapping:   \n  AfterClass:      false\n  AfterControlStatement: false\n  AfterEnum:       false\n  AfterFunction:   false\n  AfterNamespace:  false\n  AfterObjCDeclaration: false\n  AfterStruct:     false\n  AfterUnion:      false\n  AfterExternBlock: false\n  BeforeCatch:     false\n  BeforeElse:      false\n  IndentBraces:    false\n  SplitEmptyFunction: true\n  SplitEmptyRecord: true\n  SplitEmptyNamespace: true\nBreakBeforeBinaryOperators: None\nBreakBeforeBraces: Attach\nBreakBeforeInheritanceComma: false\nBreakInheritanceList: BeforeColon\nBreakBeforeTernaryOperators: true\nBreakConstructorInitializersBeforeComma: false\nBreakConstructorInitializers: BeforeColon\nBreakAfterJavaFieldAnnotations: false\nBreakStringLiterals: true\nColumnLimit:     80\nCommentPragmas:  '^ IWYU pragma:'\nCompactNamespaces: false\nConstructorInitializerAllOnOneLineOrOnePerLine: true\nConstructorInitializerIndentWidth: 4\nContinuationIndentWidth: 4\nCpp11BracedListStyle: true\nDerivePointerAlignment: false\nDisableFormat:   false\nExperimentalAutoDetectBinPacking: false\nFixNamespaceComments: true\nForEachMacros:   \n  - foreach\n  - Q_FOREACH\n  - BOOST_FOREACH\nIncludeBlocks:   Preserve\nIncludeCategories: \n  - Regex:           '^<ext/.*\\.h>'\n    Priority:        2\n  - Regex:           '^<.*\\.h>'\n    Priority:        1\n  - Regex:           '^<.*'\n    Priority:        2\n  - Regex:           '.*'\n    Priority:        3\nIncludeIsMainRegex: '([-_](test|unittest))?$'\nIndentCaseLabels: true\nIndentPPDirectives: BeforeHash\nIndentWidth:     2\nIndentWrappedFunctionNames: false\nJavaScriptQuotes: Leave\nJavaScriptWrapImports: true\nKeepEmptyLinesAtTheStartOfBlocks: false\nMacroBlockBegin: ''\nMacroBlockEnd:   ''\nMaxEmptyLinesToKeep: 1\nNamespaceIndentation: None\nObjCBinPackProtocolList: Never\nObjCBlockIndentWidth: 2\nObjCSpaceAfterProperty: false\nObjCSpaceBeforeProtocolList: true\nPenaltyBreakAssignment: 2\nPenaltyBreakBeforeFirstCallParameter: 1\nPenaltyBreakComment: 300\nPenaltyBreakFirstLessLess: 120\nPenaltyBreakString: 1000\nPenaltyBreakTemplateDeclaration: 10\nPenaltyExcessCharacter: 1000000\nPenaltyReturnTypeOnItsOwnLine: 200\nPointerAlignment: Right\nRawStringFormats: \n  - Language:        Cpp\n    Delimiters:      \n      - cc\n      - CC\n      - cpp\n      - Cpp\n      - CPP\n      - 'c++'\n      - 'C++'\n    CanonicalDelimiter: ''\n    BasedOnStyle:    google\n  - Language:        TextProto\n    Delimiters:      \n      - pb\n      - PB\n      - proto\n      - PROTO\n    EnclosingFunctions: \n      - EqualsProto\n      - EquivToProto\n      - PARSE_PARTIAL_TEXT_PROTO\n      - PARSE_TEST_PROTO\n      - PARSE_TEXT_PROTO\n      - ParseTextOrDie\n      - ParseTextProtoOrDie\n    CanonicalDelimiter: ''\n    BasedOnStyle:    google\nReflowComments:  true\nSortIncludes:    false\nSortUsingDeclarations: true\nSpaceAfterCStyleCast: false\nSpaceAfterTemplateKeyword: true\nSpaceBeforeAssignmentOperators: true\nSpaceBeforeCpp11BracedList: false\nSpaceBeforeCtorInitializerColon: true\nSpaceBeforeInheritanceColon: true\nSpaceBeforeParens: ControlStatements\nSpaceBeforeRangeBasedForLoopColon: true\nSpaceInEmptyParentheses: false\nSpacesBeforeTrailingComments: 2\nSpacesInAngles:  false\nSpacesInContainerLiterals: true\nSpacesInCStyleCastParentheses: false\nSpacesInParentheses: false\nSpacesInSquareBrackets: false\nStandard:        Auto\nTabWidth:        8\nUseTab:          Never\n...\n\n"
        },
        {
          "name": ".custom-format.py",
          "type": "blob",
          "size": 4.5908203125,
          "content": "#!/usr/bin/env python3\n#\n# american fuzzy lop++ - custom code formatter\n# --------------------------------------------\n#\n# Written and maintained by Andrea Fioraldi <andreafioraldi@gmail.com>\n#\n# Copyright 2015, 2016, 2017 Google Inc. All rights reserved.\n# Copyright 2019-2023 AFLplusplus Project. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at:\n#\n#   http://www.apache.org/licenses/LICENSE-2.0\n#\n\nimport subprocess\nimport sys\nimport os\n# import re # TODO: for future use\nimport shutil\nimport importlib.metadata\n\n# string_re = re.compile('(\\\\\"(\\\\\\\\.|[^\"\\\\\\\\])*\\\\\")') # TODO: for future use\n\nCURRENT_LLVM = os.getenv('LLVM_VERSION', 18)\nCLANG_FORMAT_BIN = os.getenv(\"CLANG_FORMAT_BIN\", \"\")\n\n\ndef check_clang_format_pip_version():\n    \"\"\"\n    Check if the correct version of clang-format is installed via pip.\n\n    Returns:\n        bool: True if the correct version of clang-format is installed,\n        False otherwise.\n    \"\"\"\n    # Check if clang-format is installed\n    if importlib.util.find_spec('clang_format'):\n        # Check if the installed version is the expected LLVM version\n        if importlib.metadata.version('clang-format')\\\n                .startswith(str(CURRENT_LLVM)+'.'):\n            return True\n        else:\n            # Return False, because the clang-format version does not match\n            return False\n    else:\n        # If the 'clang_format' package isn't installed, return False\n        return False\n\n\nwith open(\".clang-format\") as f:\n    fmt = f.read()\n\n\nCLANG_FORMAT_PIP = check_clang_format_pip_version()\n\nif shutil.which(CLANG_FORMAT_BIN) is None:\n    CLANG_FORMAT_BIN = f\"clang-format-{CURRENT_LLVM}\"\n\nif shutil.which(CLANG_FORMAT_BIN) is None \\\n        and CLANG_FORMAT_PIP is False:\n    print(f\"[!] clang-format-{CURRENT_LLVM} is needed. Aborted.\")\n    print(f\"Run `pip3 install \\\"clang-format=={CURRENT_LLVM}.*\\\"` \\\nto install via pip.\")\n    exit(1)\n\nif CLANG_FORMAT_PIP:\n    CLANG_FORMAT_BIN = shutil.which(\"clang-format\")\n\nCOLUMN_LIMIT = 80\nfor line in fmt.split(\"\\n\"):\n    line = line.split(\":\")\n    if line[0].strip() == \"ColumnLimit\":\n        COLUMN_LIMIT = int(line[1].strip())\n\n\ndef custom_format(filename):\n    p = subprocess.Popen([CLANG_FORMAT_BIN, filename], stdout=subprocess.PIPE)\n    src, _ = p.communicate()\n    src = str(src, \"utf-8\")\n\n    in_define = False\n    last_line = None\n    out = \"\"\n\n    for line in src.split(\"\\n\"):\n        if line.lstrip().startswith(\"#\"):\n            if line[line.find(\"#\") + 1:].lstrip().startswith(\"define\"):\n                in_define = True\n\n        if (\n                \"/*\" in line\n                and not line.strip().startswith(\"/*\")\n                and line.endswith(\"*/\")\n                and len(line) < (COLUMN_LIMIT - 2)\n        ):\n            cmt_start = line.rfind(\"/*\")\n            line = (\n                    line[:cmt_start]\n                    + \" \" * (COLUMN_LIMIT - 2 - len(line))\n                    + line[cmt_start:]\n            )\n\n        define_padding = 0\n        if last_line is not None and in_define and last_line.endswith(\"\\\\\"):\n            last_line = last_line[:-1]\n            define_padding = max(0, len(last_line[last_line.rfind(\"\\n\") + 1:]))\n\n        if (\n                last_line is not None\n                and last_line.strip().endswith(\"{\")\n                and line.strip() != \"\"\n        ):\n            line = (\" \" * define_padding + \"\\\\\" if in_define else \"\") + \"\\n\" + line\n        elif (\n                last_line is not None\n                and last_line.strip().startswith(\"}\")\n                and line.strip() != \"\"\n        ):\n            line = (\" \" * define_padding + \"\\\\\" if in_define else \"\") + \"\\n\" + line\n        elif (\n                line.strip().startswith(\"}\")\n                and last_line is not None\n                and last_line.strip() != \"\"\n        ):\n            line = (\" \" * define_padding + \"\\\\\" if in_define else \"\") + \"\\n\" + line\n\n        if not line.endswith(\"\\\\\"):\n            in_define = False\n\n        out += line + \"\\n\"\n        last_line = line\n\n    return out\n\n\nargs = sys.argv[1:]\nif len(args) == 0:\n    print(\"Usage: ./format.py [-i] <filename>\")\n    print()\n    print(\" The -i option, if specified, let the script to modify in-place\")\n    print(\" the source files. By default the results are written to stdout.\")\n    print()\n    exit(1)\n\nin_place = False\nif args[0] == \"-i\":\n    in_place = True\n    args = args[1:]\n\nfor filename in args:\n    code = custom_format(filename)\n    if in_place:\n        with open(filename, \"w\") as f:\n            f.write(code)\n    else:\n        print(code)\n"
        },
        {
          "name": ".dockerignore",
          "type": "blob",
          "size": 1.140625,
          "content": "!/coresight_mode\n*.dSYM\n*.o\n*.pyc\n*.so\n.sync_tmp\n.test\n.test2\n.git\n.dockerignore\n.github\nCITATION.cff\nCONTRIBUTING.md\nChangelog.md\nDockerfile\nLICENSE\nTODO.md\nafl-analyze\nafl-analyze.8\nafl-as\nafl-as.8\nafl-clang\nafl-clang-fast\nafl-clang-fast.8\nafl-clang-fast\\+\\+\nafl-clang-fast\\+\\+.8\nafl-clang-lto\nafl-clang-lto.8\nafl-clang-lto\\+\\+\nafl-clang-lto\\+\\+.8\nafl-clang\\+\\+\nafl-cmin.8\nafl-cmin.bash.8\nafl-fuzz\nafl-fuzz.8\nafl-g\\+\\+\nafl-g\\+\\+-fast\nafl-g\\+\\+-fast.8\nafl-gcc\nafl-gcc-fast\nafl-gcc-fast.8\nafl-gcc.8\nafl-gotcpu\nafl-gotcpu.8\nafl-ld\nafl-ld-lto\nafl-plot.8\nafl-qemu-trace\nafl-showmap\nafl-showmap.8\nafl-system-config.8\nafl-tmin\nafl-tmin.8\nafl-whatsup.8\nas\ncore*\nexamples/afl_frida/afl-frida\nexamples/afl_frida/frida-gum-example.c\nexamples/afl_frida/frida-gum.h\nexamples/afl_frida/libtestinstr.so\nexamples/afl_network_proxy/afl-network-client\nexamples/afl_network_proxy/afl-network-server\nin\nld\nout\nqemu_mode/libcompcov/compcovtest\nqemu_mode/qemu-*\ntest/unittests/unit_hash\ntest/unittests/unit_list\ntest/unittests/unit_maybe_alloc\ntest/unittests/unit_preallocable\ntest/unittests/unit_rand\nunicorn_mode/samples/*/\\.test-*\nunicorn_mode/samples/*/output\nunicorn_mode/unicornafl\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 2.0546875,
          "content": "!coresight_mode\n!coresight_mode/coresight-trace\n*.dSYM\n*.o\n*.o.tmp\n*.pyc\n*.so\n*.swp\n.DS_Store\n.sync_tmp\n.test\n.test2\n.vscode\nafl-addseeds.8\nafl-analyze\nafl-analyze.8\nafl-as\nafl-as.8\nafl-c++\nafl-c++.8\nafl-cc\nafl-cc.8\nafl-clang\nafl-clang++\nafl-clang-fast\nafl-clang-fast++\nafl-clang-fast++.8\nafl-clang-fast.8\nafl-clang-lto\nafl-clang-lto++\nafl-clang-lto++.8\nafl-clang-lto.8\nafl-cmin.8\nafl-cmin.bash.8\nafl-cs-proxy\nafl-frida-trace.so\nafl-fuzz\nafl-fuzz.8\nafl-g++\nafl-g++.8\nafl-gcc\nafl-gcc.8\nafl-gcc-fast\nafl-gcc-fast.8\nafl-g++-fast\nafl-g++-fast.8\nafl-gotcpu\nafl-gotcpu.8\nafl-ld\nafl-ld-lto\nafl-lto\nafl-lto++\nafl-lto++.8\nafl-lto.8\nafl-persistent-config.8\nafl-plot.8\nafl-qemu-trace\nafl-showmap\nafl-showmap.8\nafl-system-config.8\nafl-tmin\nafl-tmin.8\nafl-whatsup.8\na.out\nas\ncompile_commands.json\ncore*\nexamples/afl_frida/afl-frida\nexamples/afl_frida/frida-gum-example.c\nexamples/afl_frida/frida-gum.h\nexamples/afl_frida/libtestinstr.so\nexamples/afl_network_proxy/afl-network-client\nexamples/afl_network_proxy/afl-network-server\nexamples/aflpp_driver/libAFLDriver.a\nexamples/aflpp_driver/libAFLQemuDriver.a\ngmon.out\nin\nld\nlibAFLDriver.a\nlibAFLQemuDriver.a\nout\nqemu_mode/libcompcov/compcovtest\nqemu_mode/qemu-*\nqemu_mode/qemuafl\ntest/.afl_performance\ntest-instr\ntest/output\ntest/test-c\ntest/test-cmplog\ntest/test-compcov\ntest/test-instr.ts\ntest/test-persistent\ntest/unittests/unit_hash\ntest/unittests/unit_list\ntest/unittests/unit_maybe_alloc\ntest/unittests/unit_preallocable\ntest/unittests/unit_rand\nunicorn_mode/samples/*/output/\nunicorn_mode/samples/*/\\.test-*\nutils/afl_network_proxy/afl-network-client\nutils/afl_network_proxy/afl-network-server\nutils/afl_proxy/afl-proxy\nutils/bench/hash\nutils/optimin/build\nutils/optimin/optimin\nutils/persistent_mode/persistent_demo\nutils/persistent_mode/persistent_demo_new\nutils/persistent_mode/persistent_demo_new_compat\nutils/persistent_mode/test-instr\nutils/replay_record/persistent_demo_replay\nutils/replay_record/persistent_demo_replay_compat\nutils/replay_record/persistent_demo_replay_argparse\nutils/plot_ui/afl-plot-ui\nvuln_prog\nargv_fuzz_demo\nargv_fuzz_persistent_demo"
        },
        {
          "name": ".gitmodules",
          "type": "blob",
          "size": 1.0390625,
          "content": "[submodule \"unicorn_mode/unicornafl\"]\n\tpath = unicorn_mode/unicornafl\n\turl = https://github.com/AFLplusplus/unicornafl\n[submodule \"custom_mutators/grammar_mutator\"]\n\tpath = custom_mutators/grammar_mutator/grammar_mutator\n\turl = https://github.com/AFLplusplus/Grammar-Mutator\n[submodule \"qemu_mode/qemuafl\"]\n\tpath = qemu_mode/qemuafl\n\turl = https://github.com/AFLplusplus/qemuafl\n[submodule \"custom_mutators/gramatron/json-c\"]\n\tpath = custom_mutators/gramatron/json-c\n\turl = https://github.com/json-c/json-c\n[submodule \"coresight_mode/patchelf\"]\n\tpath = coresight_mode/patchelf\n\turl = https://github.com/NixOS/patchelf.git\n[submodule \"coresight_mode/coresight-trace\"]\n\tpath = coresight_mode/coresight-trace\n\turl = https://github.com/RICSecLab/coresight-trace.git\n[submodule \"nyx_mode/libnyx\"]\n\tpath = nyx_mode/libnyx\n\turl = https://github.com/nyx-fuzz/libnyx.git\n[submodule \"nyx_mode/packer\"]\n\tpath = nyx_mode/packer\n\turl = https://github.com/nyx-fuzz/packer.git\n[submodule \"nyx_mode/QEMU-Nyx\"]\n\tpath = nyx_mode/QEMU-Nyx\n\turl = https://github.com/nyx-fuzz/QEMU-Nyx\n"
        },
        {
          "name": "Android.bp",
          "type": "blob",
          "size": 7.220703125,
          "content": "//\n// NOTE: This file is outdated. None of the AFL++ team uses Android hence\n//       we need users to keep this updated.\n//       In the current state it will likely fail, please send fixes!\n//       Also, this should build frida_mode.\n//\n\n\ncc_defaults {\n  name: \"afl-defaults\",\n\n  local_include_dirs: [\n    \"include\",\n    \"instrumentation\",\n  ],\n\n  cflags: [\n    \"-flto=full\",\n    \"-funroll-loops\",\n    \"-Wno-pointer-sign\",\n    \"-Wno-pointer-arith\",\n    \"-Wno-sign-compare\",\n    \"-Wno-unused-parameter\",\n    \"-Wno-unused-function\",\n    \"-Wno-format\",\n    \"-Wno-user-defined-warnings\",\n    \"-DAFL_LLVM_USE_TRACE_PC=1\",\n    \"-DBIN_PATH=\\\"out/host/linux-x86/bin\\\"\",\n    \"-DDOC_PATH=\\\"out/host/linux-x86/shared/doc/afl\\\"\",\n    \"-D__USE_GNU\",\n    \"-DDEBUG_BUILD\",\n    \"-U_FORTIFY_SOURCE\",\n    \"-ggdb3\",\n    \"-g\",\n    \"-O0\",\n    \"-fno-omit-frame-pointer\",\n    \"-fPIC\",\n  ],\n\n  target: {\n    android_arm64: {\n      cflags: [\n        \"-D__ANDROID__\",\n      ],\n    },\n    android_arm: {\n      cflags: [\n        \"-D__ANDROID__\",\n      ],\n    },\n    android_x86_64: {\n      cflags: [\n        \"-D__ANDROID__\",\n      ],\n    },\n    android_x86: {\n      cflags: [\n        \"-D__ANDROID__\",\n      ],\n    },\n  },\n}\n\ncc_binary {\n  name: \"afl-fuzz\",\n  sanitize: {\n    never: true,\n  },\n  host_supported: true,\n  compile_multilib: \"64\",\n\n  defaults: [\n    \"afl-defaults\",\n  ],\n\n  srcs: [\n    \"src/afl-fuzz*.c\",\n    \"src/afl-common.c\",\n    \"src/afl-forkserver.c\",\n    \"src/afl-sharedmem.c\",\n    \"src/afl-forkserver.c\",\n    \"src/afl-performance.c\",\n  ],\n}\n\ncc_binary {\n  name: \"afl-showmap\",\n  static_executable: true,\n  host_supported: true,\n\n  defaults: [\n    \"afl-defaults\",\n  ],\n\n  srcs: [\n    \"src/afl-showmap.c\",\n    \"src/afl-common.c\",\n    \"src/afl-sharedmem.c\",\n    \"src/afl-forkserver.c\",\n    \"src/afl-performance.c\",\n  ],\n}\n\ncc_binary {\n  name: \"afl-tmin\",\n  static_executable: true,\n  host_supported: true,\n\n  defaults: [\n    \"afl-defaults\",\n  ],\n\n  srcs: [\n    \"src/afl-tmin.c\",\n    \"src/afl-common.c\",\n    \"src/afl-sharedmem.c\",\n    \"src/afl-forkserver.c\",\n    \"src/afl-performance.c\",\n  ],\n}\n\ncc_binary {\n  name: \"afl-analyze\",\n  static_executable: true,\n  host_supported: true,\n\n  defaults: [\n    \"afl-defaults\",\n  ],\n\n  srcs: [\n    \"src/afl-analyze.c\",\n    \"src/afl-common.c\",\n    \"src/afl-sharedmem.c\",\n    \"src/afl-performance.c\",\n  ],\n}\n\ncc_binary {\n  name: \"afl-gotcpu\",\n  static_executable: true,\n  host_supported: true,\n\n  defaults: [\n    \"afl-defaults\",\n  ],\n\n  srcs: [\n    \"src/afl-gotcpu.c\",\n    \"src/afl-common.c\",\n  ],\n}\n\ncc_binary_host {\n  name: \"afl-cc\",\n  static_executable: true,\n\n  defaults: [\n    \"afl-defaults\",\n  ],\n\n  cflags: [\n    \"-DAFL_PATH=\\\"out/host/linux-x86/lib64\\\"\",\n    \"-DAFL_CLANG_FLTO=\\\"-flto=full\\\"\",\n    \"-DUSE_BINDIR=1\",\n    \"-DLLVM_BINDIR=\\\"prebuilts/clang/host/linux-x86/clang-r383902b/bin\\\"\",\n    \"-DLLVM_LIBDIR=\\\"prebuilts/clang/host/linux-x86/clang-r383902b/lib64\\\"\",\n    \"-DCLANGPP_BIN=\\\"prebuilts/clang/host/linux-x86/clang-r383902b/bin/clang++\\\"\",\n    \"-DAFL_REAL_LD=\\\"prebuilts/clang/host/linux-x86/clang-r383902b/bin/ld.lld\\\"\",\n    \"-DLLVM_LTO=1\",\n    \"-DLLVM_MAJOR=11\",\n    \"-DLLVM_MINOR=2\",\n  ],\n\n  srcs: [\n    \"src/afl-cc.c\",\n    \"src/afl-common.c\",\n  ],\n\n  symlinks: [\n    \"afl-clang-fast\",\n    \"afl-clang-fast++\",\n  ],\n}\n\ncc_library_static {\n  name: \"afl-compiler-rt\",\n  compile_multilib: \"64\",\n  vendor_available: true,\n  host_supported: true,\n  recovery_available: true,\n  sdk_version: \"9\",\n\n  apex_available: [\n    \"com.android.adbd\",\n    \"com.android.appsearch\",\n    \"com.android.art\",\n    \"com.android.bluetooth.updatable\",\n    \"com.android.cellbroadcast\",\n    \"com.android.conscrypt\",\n    \"com.android.extservices\",\n    \"com.android.cronet\",\n    \"com.android.neuralnetworks\",\n    \"com.android.media\",\n    \"com.android.media.swcodec\",\n    \"com.android.mediaprovider\",\n    \"com.android.permission\",\n    \"com.android.runtime\",\n    \"com.android.resolv\",\n    \"com.android.tethering\",\n    \"com.android.wifi\",\n    \"com.android.sdkext\",\n    \"com.android.os.statsd\",\n    \"//any\",\n  ],\n\n  defaults: [\n    \"afl-defaults\",\n  ],\n\n  srcs: [\n    \"instrumentation/afl-compiler-rt.o.c\",\n  ],\n}\n\ncc_library_headers {\n  name: \"libafl_headers\",\n  vendor_available: true,\n  host_supported: true,\n\n  export_include_dirs: [\n    \"include\",\n    \"instrumentation\",\n  ],\n}\n\n/*\ncc_prebuilt_library_static {\n  name: \"libfrida-gum\",\n  compile_multilib: \"64\",\n  strip: {\n    none: true,\n  },\n\n  srcs: [\n    \"utils/afl_frida/android/libfrida-gum.a\",\n  ],\n\n  export_include_dirs: [\n    \"utils/afl_frida/android\",\n  ],\n}\n\ncc_library_shared {\n  name: \"libtestinstr\",\n\n  srcs: [\n    \"utils/afl_frida/libtestinstr.c\",\n  ],\n\n  cflags: [\n    \"-O0\",\n    \"-fPIC\",\n  ],\n}\n\ncc_binary {\n  name: \"afl-frida\",\n  compile_multilib: \"64\",\n\n  defaults: [\n    \"afl-defaults\",\n  ],\n\n  cflags: [\n    \"-g\",\n    \"-O0\",\n    \"-Wno-format\",\n    \"-Wno-pointer-sign\",\n    \"-fpermissive\",\n    \"-fPIC\",\n  ],\n\n  static_libs: [\n    \"afl-compiler-rt\",\n    \"libfrida-gum\",\n  ],\n\n  shared_libs: [\n    \"libdl\",\n    \"liblog\",\n  ],\n\n  srcs: [\n    \"utils/afl_frida/afl-frida.c\",\n  ],\n\n  local_include_dirs: [\n    \"utils/afl_frida\",\n    \"utils/afl_frida/android\",\n  ],\n}\n*/\n\ncc_binary {\n  name: \"afl-fuzz-32\",\n  sanitize: {\n    never: true,\n  },\n  host_supported: true,\n  compile_multilib: \"32\",\n\n  defaults: [\n    \"afl-defaults\",\n  ],\n\n  srcs: [\n    \"src/afl-fuzz*.c\",\n    \"src/afl-common.c\",\n    \"src/afl-sharedmem.c\",\n    \"src/afl-forkserver.c\",\n    \"src/afl-performance.c\",\n  ],\n}\n\ncc_binary_host {\n  name: \"afl-cc-32\",\n  compile_multilib: \"32\",\n  static_executable: true,\n\n  defaults: [\n    \"afl-defaults\",\n  ],\n\n  cflags: [\n    \"-DAFL_PATH=\\\"out/host/linux-x86/lib64\\\"\",\n    \"-DAFL_CLANG_FLTO=\\\"-flto=full\\\"\",\n    \"-DUSE_BINDIR=1\",\n    \"-DLLVM_BINDIR=\\\"prebuilts/clang/host/linux-x86/clang-r383902b/bin\\\"\",\n    \"-DLLVM_LIBDIR=\\\"prebuilts/clang/host/linux-x86/clang-r383902b/lib64\\\"\",\n    \"-DCLANGPP_BIN=\\\"prebuilts/clang/host/linux-x86/clang-r383902b/bin/clang++\\\"\",\n    \"-DAFL_REAL_LD=\\\"prebuilts/clang/host/linux-x86/clang-r383902b/bin/ld.lld\\\"\",\n    \"-DLLVM_LTO=1\",\n    \"-DLLVM_MAJOR=11\",\n    \"-DLLVM_MINOR=2\",\n  ],\n\n  srcs: [\n    \"src/afl-cc.c\",\n    \"src/afl-common.c\",\n  ],\n\n  symlinks: [\n    \"afl-clang-fast-32\",\n    \"afl-clang-fast++-32\",\n  ],\n}\n\ncc_library_static {\n  name: \"afl-compiler-rt-32\",\n  compile_multilib: \"32\",\n  vendor_available: true,\n  host_supported: true,\n  recovery_available: true,\n  sdk_version: \"9\",\n\n  apex_available: [\n    \"com.android.adbd\",\n    \"com.android.appsearch\",\n    \"com.android.art\",\n    \"com.android.bluetooth.updatable\",\n    \"com.android.cellbroadcast\",\n    \"com.android.conscrypt\",\n    \"com.android.extservices\",\n    \"com.android.cronet\",\n    \"com.android.neuralnetworks\",\n    \"com.android.media\",\n    \"com.android.media.swcodec\",\n    \"com.android.mediaprovider\",\n    \"com.android.permission\",\n    \"com.android.runtime\",\n    \"com.android.resolv\",\n    \"com.android.tethering\",\n    \"com.android.wifi\",\n    \"com.android.sdkext\",\n    \"com.android.os.statsd\",\n    \"//any\",\n  ],\n\n  defaults: [\n    \"afl-defaults\",\n  ],\n\n  srcs: [\n    \"instrumentation/afl-compiler-rt.o.c\",\n  ],\n}\n\n/*\ncc_prebuilt_library_static {\n  name: \"libfrida-gum-32\",\n  compile_multilib: \"32\",\n  strip: {\n    none: true,\n  },\n\n  srcs: [\n    \"utils/afl_frida/android/arm/libfrida-gum.a\",\n  ],\n\n  export_include_dirs: [\n    \"utils/afl_frida/android/arm\",\n  ],\n}\n*/\n\nsubdirs = [\n  \"custom_mutators\",\n]\n"
        },
        {
          "name": "CITATION.cff",
          "type": "blob",
          "size": 0.673828125,
          "content": "cff-version: 1.2.0\nmessage: \"If you use this software, please cite it as below.\"\nauthors:\n  - given-names: Marc\n    family-names: Heuse\n    email: mh@mh-sec.de\n  - given-names: Heiko\n    family-names: Ei√üfeldt\n    email: heiko.eissfeldt@hexco.de\n  - given-names: Andrea\n    family-names: Fioraldi\n    email: andreafioraldi@gmail.com\n  - given-names: Dominik\n    family-names: Maier\n    email: mail@dmnk.co\ntitle: \"AFL++\"\nversion: 4.00c\ntype: software\ndate-released: 2022-01-26\nurl: \"https://github.com/AFLplusplus/AFLplusplus\"\nkeywords:\n  - fuzzing\n  - fuzzer\n  - fuzz-testing\n  - instrumentation\n  - afl-fuzz\n  - qemu\n  - llvm\n  - unicorn-emulator\n  - security\nlicense: AGPL-3.0-or-later\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 1.998046875,
          "content": "# Contributing to AFL++\n\n## How to submit a pull request\n\nAll contributions (pull requests) must be made against our `dev` branch.\n\nEach modified source file, before merging, must be formatted.\n\n```\nmake code-format\n```\n\nThis should be fine if you modified one of the files already present in the\nproject, or added a file in a directory we already format, otherwise run:\n\n```\n./.custom-format.py -i file-that-you-have-created.c\n```\n\nRegarding the coding style, please follow the AFL style. No camel case at all\nand use AFL's macros wherever possible (e.g., WARNF, FATAL, MAP_SIZE, ...).\n\nRemember that AFL++ has to build and run on many platforms, so generalize your\nMakefiles/GNUmakefile (or your patches to our pre-existing Makefiles) to be as\ngeneric as possible.\n\n## How to contribute to the docs\n\nWe welcome contributions to our docs.\n\nBefore creating a new file, please check if your content matches an existing\nfile in one the following folders:\n\n* [docs/](docs/) (this is where you can find most of our docs content)\n* [frida_mode/](frida_mode/)\n* [instrumentation/](instrumentation/)\n* [nyx_mode/](nyx_mode/)\n* [qemu_mode/](qemu_mode/)\n* [unicorn_mode/](unicorn_mode/)\n\nWhen working on the docs, please keep the following guidelines in mind:\n\n* Edit or create Markdown files and use Markdown markup.\n  * Do: fuzzing_gui_program.md\n  * Don't: fuzzing_gui_program.txt\n* Use underscore in file names.\n  * Do: fuzzing_network_service.md\n  * Don't: fuzzing-network-service.md\n* Use a maximum of 80 characters per line to make reading in a console easier.\n* Make all pull requests against `dev`, see\n  [#how-to-submit-a-pull-request](#how-to-submit-a-pull-request).\n\nAnd finally, here are some best practices for writing docs content:\n\n* Use clear and simple language.\n* Structure your content with headings and paragraphs.\n* Use bulleted lists to present similar content in a way that makes it easy to\n  scan.\n* Use numbered lists for procedures or prioritizing.\n* Link to related content, for example, prerequisites or in-depth discussions.\n"
        },
        {
          "name": "Changelog.md",
          "type": "blob",
          "size": 0.0166015625,
          "content": "docs/Changelog.md"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 4.029296875,
          "content": "#\n# This Dockerfile for AFLplusplus uses Ubuntu 22.04 jammy and\n# installs LLVM 14 for afl-clang-lto support.\n#\n# GCC 11 is used instead of 12 because genhtml for afl-cov doesn't like it.\n#\n\nFROM ubuntu:22.04 AS aflplusplus\nLABEL \"maintainer\"=\"AFL++ team <afl@aflplus.plus>\"\nLABEL \"about\"=\"AFLplusplus container image\"\n\n### Comment out to enable these features\n# Only available on specific ARM64 boards\nENV NO_CORESIGHT=1\n# Possible but unlikely in a docker container\nENV NO_NYX=1\n\n### Only change these if you know what you are doing:\n# Current recommended LLVM version is 16\nENV LLVM_VERSION=16\n# GCC 12 is producing compile errors for some targets so we stay at GCC 11\nENV GCC_VERSION=11\n\n### No changes beyond the point unless you know what you are doing :)\n\nARG DEBIAN_FRONTEND=noninteractive\n\nENV NO_ARCH_OPT=1\nENV IS_DOCKER=1\n\nRUN apt-get update && apt-get full-upgrade -y && \\\n    apt-get install -y --no-install-recommends wget ca-certificates apt-utils && \\\n    rm -rf /var/lib/apt/lists/*\n\nRUN echo \"deb [signed-by=/etc/apt/keyrings/llvm-snapshot.gpg.key] http://apt.llvm.org/jammy/ llvm-toolchain-jammy-${LLVM_VERSION} main\" > /etc/apt/sources.list.d/llvm.list && \\\n    wget -qO /etc/apt/keyrings/llvm-snapshot.gpg.key https://apt.llvm.org/llvm-snapshot.gpg.key\n\nRUN apt-get update && \\\n    apt-get -y install --no-install-recommends \\\n    make cmake automake meson ninja-build bison flex \\\n    git xz-utils bzip2 wget jupp nano bash-completion less vim joe ssh psmisc \\\n    python3 python3-dev python3-pip python-is-python3 \\\n    libtool libtool-bin libglib2.0-dev \\\n    apt-transport-https gnupg dialog \\\n    gnuplot-nox libpixman-1-dev bc \\\n    gcc-${GCC_VERSION} g++-${GCC_VERSION} gcc-${GCC_VERSION}-plugin-dev gdb lcov \\\n    clang-${LLVM_VERSION} clang-tools-${LLVM_VERSION} libc++1-${LLVM_VERSION} \\\n    libc++-${LLVM_VERSION}-dev libc++abi1-${LLVM_VERSION} libc++abi-${LLVM_VERSION}-dev \\\n    libclang1-${LLVM_VERSION} libclang-${LLVM_VERSION}-dev \\\n    libclang-common-${LLVM_VERSION}-dev libclang-rt-${LLVM_VERSION}-dev libclang-cpp${LLVM_VERSION} \\\n    libclang-cpp${LLVM_VERSION}-dev liblld-${LLVM_VERSION} \\\n    liblld-${LLVM_VERSION}-dev liblldb-${LLVM_VERSION} liblldb-${LLVM_VERSION}-dev \\\n    libllvm${LLVM_VERSION} libomp-${LLVM_VERSION}-dev libomp5-${LLVM_VERSION} \\\n    lld-${LLVM_VERSION} lldb-${LLVM_VERSION} llvm-${LLVM_VERSION} \\\n    llvm-${LLVM_VERSION}-dev llvm-${LLVM_VERSION}-runtime llvm-${LLVM_VERSION}-tools \\\n    $([ \"$(dpkg --print-architecture)\" = \"amd64\" ] && echo gcc-${GCC_VERSION}-multilib gcc-multilib) \\\n    $([ \"$(dpkg --print-architecture)\" = \"arm64\" ] && echo libcapstone-dev) && \\\n    rm -rf /var/lib/apt/lists/*\n    # gcc-multilib is only used for -m32 support on x86\n    # libcapstone-dev is used for coresight_mode on arm64\n\nRUN update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-${GCC_VERSION} 0 && \\\n    update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-${GCC_VERSION} 0 && \\\n    update-alternatives --install /usr/bin/clang clang /usr/bin/clang-${LLVM_VERSION} 0 && \\\n    update-alternatives --install /usr/bin/clang++ clang++ /usr/bin/clang++-${LLVM_VERSION} 0\n\nRUN wget -qO- https://sh.rustup.rs | CARGO_HOME=/etc/cargo sh -s -- -y -q --no-modify-path\nENV PATH=$PATH:/etc/cargo/bin\n\nRUN apt clean -y\n\nENV LLVM_CONFIG=llvm-config-${LLVM_VERSION}\nENV AFL_SKIP_CPUFREQ=1\nENV AFL_TRY_AFFINITY=1\nENV AFL_I_DONT_CARE_ABOUT_MISSING_CRASHES=1\n\nRUN git clone --depth=1 https://github.com/vanhauser-thc/afl-cov && \\\n    (cd afl-cov && make install) && rm -rf afl-cov\n\nWORKDIR /AFLplusplus\nCOPY . .\n\nARG CC=gcc-$GCC_VERSION\nARG CXX=g++-$GCC_VERSION\n\n# Used in CI to prevent a 'make clean' which would remove the binaries to be tested\nARG TEST_BUILD\n\nRUN sed -i.bak 's/^\t-/\t/g' GNUmakefile && \\\n    make clean && make distrib && \\\n    ([ \"${TEST_BUILD}\" ] || (make install)) && \\\n    mv GNUmakefile.bak GNUmakefile\n\nRUN echo \"set encoding=utf-8\" > /root/.vimrc && \\\n    echo \". /etc/bash_completion\" >> ~/.bashrc && \\\n    echo 'alias joe=\"joe --wordwrap --joe_state -nobackup\"' >> ~/.bashrc && \\\n    echo \"export PS1='\"'[AFL++ \\h] \\w \\$ '\"'\" >> ~/.bashrc\n"
        },
        {
          "name": "GNUmakefile",
          "type": "blob",
          "size": 39.0537109375,
          "content": "#\n# american fuzzy lop++ - makefile\n# -----------------------------\n#\n# Originally written by Michal Zalewski\n#\n# Copyright 2013, 2014, 2015, 2016, 2017 Google Inc. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at:\n#\n#   https://www.apache.org/licenses/LICENSE-2.0\n#\n\n# For Heiko:\n#TEST_MMAP=1\n# the hash character is treated differently in different make versions\n# so use a variable for '#'\nHASH=\\#\n\nPREFIX      ?= /usr/local\nBIN_PATH     = $(PREFIX)/bin\nHELPER_PATH  = $(PREFIX)/lib/afl\nDOC_PATH     = $(PREFIX)/share/doc/afl\nMISC_PATH    = $(PREFIX)/share/afl\nMAN_PATH     = $(PREFIX)/share/man/man8\nINCLUDE_PATH = $(PREFIX)/include/afl\n\nPROGNAME    = afl\nVERSION     = $(shell grep '^$(HASH)define VERSION ' ../config.h | cut -d '\"' -f2)\n\nPROGS       = afl-fuzz afl-showmap afl-tmin afl-gotcpu afl-analyze\nSH_PROGS    = afl-plot afl-cmin afl-cmin.bash afl-whatsup afl-addseeds afl-system-config afl-persistent-config afl-cc\nHEADERS     = include/afl-fuzz.h include/afl-mutations.h include/afl-persistent-replay.h include/afl-prealloc.h include/afl-record-compat.h include/alloc-inl.h include/android-ashmem.h include/cmplog.h include/common.h include/config.h include/coverage-32.h include/coverage-64.h include/debug.h include/envs.h include/forkserver.h include/hash.h include/list.h include/sharedmem.h include/snapshot-inl.h include/t1ha.h include/t1ha0_ia32aes_b.h include/t1ha_bits.h include/t1ha_selfcheck.h include/types.h include/xxhash.h\nMANPAGES=$(foreach p, $(PROGS) $(SH_PROGS), $(p).8)\nASAN_OPTIONS=detect_leaks=0\n\nSYS = $(shell uname -s)\nARCH = $(shell uname -m)\n\n$(info [*] Compiling AFL++ for OS $(SYS) on ARCH $(ARCH))\n\nifdef NO_SPLICING\n  override CFLAGS_OPT += -DNO_SPLICING\nendif\n\nifdef NO_UTF\n  override CFLAGS_OPT += -DFANCY_BOXES_NO_UTF\nendif\n\nifdef ASAN_BUILD\n  $(info Compiling ASAN version of binaries)\n  override CFLAGS += $(ASAN_CFLAGS)\n  override LDFLAGS += $(ASAN_LDFLAGS)\nendif\nifdef UBSAN_BUILD\n  $(info Compiling UBSAN version of binaries)\n  override CFLAGS += -fsanitize=undefined -fno-omit-frame-pointer\n  override LDFLAGS += -fsanitize=undefined\nendif\nifdef MSAN_BUILD\n  $(info Compiling MSAN version of binaries)\n  CC := clang\n  override CFLAGS += -fsanitize=memory -fno-omit-frame-pointer\n  override LDFLAGS += -fsanitize=memory\nendif\n\nifdef CODE_COVERAGE\n  override CFLAGS += -D__AFL_CODE_COVERAGE=1\nendif\n\nifeq \"$(findstring android, $(shell $(CC) --version 2>/dev/null))\" \"\"\nifeq \"$(shell echo 'int main() {return 0; }' | $(CC) $(CFLAGS) -Werror -x c - -flto=full -o .test 2>/dev/null && echo 1 || echo 0 ; rm -f .test )\" \"1\"\n\tCFLAGS_FLTO ?= -flto=full\nelse\n ifeq \"$(shell echo 'int main() {return 0; }' | $(CC) $(CFLAGS) -Werror -x c - -flto=thin -o .test 2>/dev/null && echo 1 || echo 0 ; rm -f .test )\" \"1\"\n\tCFLAGS_FLTO ?= -flto=thin\n else\n  ifeq \"$(shell echo 'int main() {return 0; }' | $(CC) $(CFLAGS) -Werror -x c - -flto -o .test 2>/dev/null && echo 1 || echo 0 ; rm -f .test )\" \"1\"\n\tCFLAGS_FLTO ?= -flto\n  endif\n endif\nendif\nendif\n\nifdef PERFORMANCE\n  SPECIAL_PERFORMANCE := -D_AFL_SPECIAL_PERFORMANCE\n  ifeq \"$(SYS)\" \"Linux\"\n    ifeq \"$(shell grep avx2 /proc/cpuinfo)\" \"\"\n    else\n  \tSPECIAL_PERFORMANCE += -mavx2 -D_HAVE_AVX2\n    endif\n  endif\n  ifeq \"$(shell echo 'int main() {return 0; }' | $(CC) $(CFLAGS) -Werror -x c - -march=native -o .test 2>/dev/null && echo 1 || echo 0 ; rm -f .test )\" \"1\"\n\tHAVE_MARCHNATIVE = 1\n\tSPECIAL_PERFORMANCE += -march=native\n  endif\n  $(info SPECIAL_PERFORMANCE=$(SPECIAL_PERFORMANCE))\nelse\n  SPECIAL_PERFORMANCE :=\nendif\n\nifneq \"$(SYS)\" \"Darwin\"\n #ifeq \"$(HAVE_MARCHNATIVE)\" \"1\"\n #  SPECIAL_PERFORMANCE += -march=native\n #endif\n #ifndef DEBUG\n #  override CFLAGS_OPT += -D_FORTIFY_SOURCE=1\n #endif\nelse\n  # On some odd MacOS system configurations, the Xcode sdk path is not set correctly\n  SDK_LD = -L$(shell xcrun --show-sdk-path)/usr/lib\n  override LDFLAGS += $(SDK_LD)\nendif\n\nCOMPILER_TYPE=$(shell $(CC) --version|grep \"Free Software Foundation\")\nifneq \"$(COMPILER_TYPE)\" \"\"\n  #$(info gcc is being used)\n  override CFLAGS_OPT += -Wno-format-truncation\nendif\n\nifeq \"$(SYS)\" \"SunOS\"\n  override LDFLAGS = -lkstat -lrt -lsocket -lnsl\nendif\n\nifdef STATIC\n  $(info Compiling static version of binaries, disabling python though)\n  # Disable python for static compilation to simplify things\n  PYTHON_OK = 0\n  PYFLAGS=\n  PYTHON_INCLUDE = /\n\n  override CFLAGS_OPT += -static\n  override LDFLAGS += -lm -lpthread -lz -lutil\nendif\n\nifdef PROFILING\n  $(info Compiling with profiling information, for analysis: gprof ./afl-fuzz gmon.out > prof.txt)\n  override CFLAGS_OPT += -pg -DPROFILING=1\n  override LDFLAGS += -pg\nendif\n\nifdef INTROSPECTION\n  $(info Compiling with introspection documentation)\n  override CFLAGS_OPT += -DINTROSPECTION=1\nendif\n\nifneq \"$(ARCH)\" \"x86_64\"\n ifneq \"$(patsubst i%86,i386,$(ARCH))\" \"i386\"\n  ifneq \"$(ARCH)\" \"amd64\"\n   ifneq \"$(ARCH)\" \"i86pc\"\n\tAFL_NO_X86=1\n   endif\n  endif\n endif\nendif\n\nifdef DEBUG\n  $(info Compiling DEBUG version of binaries)\n  override CFLAGS += -ggdb3 -O0 -Wall -Wextra -Werror $(CFLAGS_OPT)\nelse\n  CFLAGS ?= -O2 $(CFLAGS_OPT) # -funroll-loops is slower on modern compilers\nendif\n\noverride CFLAGS += -g -Wno-pointer-sign -Wno-variadic-macros -Wall -Wextra -Wno-pointer-arith \\\n\t\t\t-fPIC -I include/ -DAFL_PATH=\\\"$(HELPER_PATH)\\\"  \\\n\t\t\t-DBIN_PATH=\\\"$(BIN_PATH)\\\" -DDOC_PATH=\\\"$(DOC_PATH)\\\"\n# -fstack-protector\n\nifeq \"$(SYS)\" \"FreeBSD\"\n  override CFLAGS  += -I /usr/local/include/\n  override LDFLAGS += -L /usr/local/lib/\nendif\n\nifeq \"$(SYS)\" \"DragonFly\"\n  override CFLAGS  += -I /usr/local/include/\n  override LDFLAGS += -L /usr/local/lib/\nendif\n\nifeq \"$(SYS)\" \"OpenBSD\"\n  override CFLAGS  += -I /usr/local/include/ -mno-retpoline\n  override LDFLAGS += -Wl,-z,notext -L /usr/local/lib/\nendif\n\nifeq \"$(SYS)\" \"NetBSD\"\n  override CFLAGS  += -I /usr/pkg/include/\n  override LDFLAGS += -L /usr/pkg/lib/\nendif\n\nifeq \"$(SYS)\" \"Haiku\"\n  SHMAT_OK=0\n  override CFLAGS  += -DUSEMMAP=1 -Wno-error=format\n  override LDFLAGS += -Wno-deprecated-declarations -lgnu -lnetwork\n  #SPECIAL_PERFORMANCE += -DUSEMMAP=1\nendif\n\nAFL_FUZZ_FILES = $(wildcard src/afl-fuzz*.c)\n\nifneq \"$(shell command -v python3m 2>/dev/null)\" \"\"\n  ifneq \"$(shell command -v python3m-config 2>/dev/null)\" \"\"\n    PYTHON_INCLUDE  := $(shell python3m-config --includes)\n    PYTHON_VERSION  := $(strip $(shell python3m --version 2>&1))\n    # Starting with python3.8, we need to pass the `embed` flag. Earlier versions didn't know this flag.\n    ifeq \"$(shell python3m-config --embed --libs 2>/dev/null | grep -q lpython && echo 1 )\" \"1\"\n      PYTHON_LIB      := $(shell python3m-config --libs --embed --ldflags)\n    else\n      PYTHON_LIB      := $(shell python3m-config --ldflags)\n    endif\n  endif\nendif\n\nifeq \"$(PYTHON_INCLUDE)\" \"\"\n  ifneq \"$(shell command -v python3 2>/dev/null)\" \"\"\n    ifneq \"$(shell command -v python3-config 2>/dev/null)\" \"\"\n      PYTHON_INCLUDE  := $(shell python3-config --includes)\n      PYTHON_VERSION  := $(strip $(shell python3 --version 2>&1))\n      # Starting with python3.8, we need to pass the `embed` flag. Earlier versions didn't know this flag.\n      ifeq \"$(shell python3-config --embed --libs 2>/dev/null | grep -q lpython && echo 1 )\" \"1\"\n        PYTHON_LIB      := $(shell python3-config --libs --embed --ldflags)\n      else\n        PYTHON_LIB      := $(shell python3-config --ldflags)\n      endif\n    endif\n  endif\nendif\n\nifeq \"$(PYTHON_INCLUDE)\" \"\"\n  ifneq \"$(shell command -v python 2>/dev/null)\" \"\"\n    ifneq \"$(shell command -v python-config 2>/dev/null)\" \"\"\n      PYTHON_INCLUDE  := $(shell python-config --includes)\n      PYTHON_LIB      := $(shell python-config --ldflags)\n      PYTHON_VERSION  := $(strip $(shell python --version 2>&1))\n    endif\n  endif\nendif\n\n# Old Ubuntu and others dont have python/python3-config so we hardcode 3.7\nifeq \"$(PYTHON_INCLUDE)\" \"\"\n  ifneq \"$(shell command -v python3.7 2>/dev/null)\" \"\"\n    ifneq \"$(shell command -v python3.7-config 2>/dev/null)\" \"\"\n      PYTHON_INCLUDE  := $(shell python3.7-config --includes)\n      PYTHON_LIB      := $(shell python3.7-config --ldflags)\n      PYTHON_VERSION  := $(strip $(shell python3.7 --version 2>&1))\n    endif\n  endif\nendif\n\n# Old Ubuntu and others dont have python/python2-config so we hardcode 2.7\nifeq \"$(PYTHON_INCLUDE)\" \"\"\n  ifneq \"$(shell command -v python2.7 2>/dev/null)\" \"\"\n    ifneq \"$(shell command -v python2.7-config 2>/dev/null)\" \"\"\n      PYTHON_INCLUDE  := $(shell python2.7-config --includes)\n      PYTHON_LIB      := $(shell python2.7-config --ldflags)\n      PYTHON_VERSION  := $(strip $(shell python2.7 --version 2>&1))\n    endif\n  endif\nendif\n\nifdef SOURCE_DATE_EPOCH\n    BUILD_DATE ?= $(shell date -u -d \"@$(SOURCE_DATE_EPOCH)\" \"+%Y-%m-%d\" 2>/dev/null || date -u -r \"$(SOURCE_DATE_EPOCH)\" \"+%Y-%m-%d\" 2>/dev/null || date -u \"+%Y-%m-%d\")\nelse\n    BUILD_DATE ?= $(shell date \"+%Y-%m-%d\")\nendif\n\nifneq \"$(filter Linux GNU%,$(SYS))\" \"\"\n  override LDFLAGS += -ldl -lrt -lm\nendif\n\nifneq \"$(findstring FreeBSD, $(SYS))\" \"\"\n  override CFLAGS  += -pthread\n  override LDFLAGS += -lpthread -lm\nendif\n\nifneq \"$(findstring NetBSD, $(SYS))\" \"\"\n  override CFLAGS  += -pthread\n  override LDFLAGS += -lpthread -lm\nendif\n\nifneq \"$(findstring OpenBSD, $(SYS))\" \"\"\n  override CFLAGS  += -pthread\n  override LDFLAGS += -lpthread -lm\nendif\n\nCOMM_HDR    = include/alloc-inl.h include/config.h include/debug.h include/types.h\n\nifeq \"$(shell echo '$(HASH)include <Python.h>@int main() {return 0; }' | tr @ '\\n' | $(CC) $(CFLAGS) -x c - -o .test $(PYTHON_INCLUDE) $(LDFLAGS) $(PYTHON_LIB) 2>/dev/null && echo 1 || echo 0 ; rm -f .test )\" \"1\"\n\tPYTHON_OK=1\n\tPYFLAGS=-DUSE_PYTHON $(PYTHON_INCLUDE) $(LDFLAGS) $(PYTHON_LIB) -DPYTHON_VERSION=\"\\\"$(PYTHON_VERSION)\\\"\"\nelse\n\tPYTHON_OK=0\n\tPYFLAGS=\nendif\n\nifdef NO_PYTHON\n\tPYTHON_OK=0\n\tPYFLAGS=\nendif\n\nIN_REPO=0\nifeq \"$(shell command -v git >/dev/null && git status >/dev/null 2>&1 && echo 1 || echo 0)\" \"1\"\n  IN_REPO=1\nendif\nifeq \"$(shell command -v svn >/dev/null && svn proplist . 2>/dev/null && echo 1 || echo 0)\" \"1\"\n  IN_REPO=1\nendif\n\nifeq \"$(shell echo 'int main() { return 0;}' | $(CC) $(CFLAGS) -fsanitize=address -x c - -o .test2 2>/dev/null && echo 1 || echo 0 ; rm -f .test2 )\" \"1\"\n\tASAN_CFLAGS=-fsanitize=address -fstack-protector-all -fno-omit-frame-pointer -DASAN_BUILD\n\tASAN_LDFLAGS=-fsanitize=address -fstack-protector-all -fno-omit-frame-pointer\nendif\n\nifeq \"$(shell echo '$(HASH)include <sys/ipc.h>@$(HASH)include <sys/shm.h>@int main() { int _id = shmget(IPC_PRIVATE, 65536, IPC_CREAT | IPC_EXCL | 0600); shmctl(_id, IPC_RMID, 0); return 0;}' | tr @ '\\n' | $(CC) $(CFLAGS) -x c - -o .test2 2>/dev/null && echo 1 || echo 0 ; rm -f .test2 )\" \"1\"\n\tSHMAT_OK=1\nelse\n\tSHMAT_OK=0\n\toverride CFLAGS+=-DUSEMMAP=1\n\tLDFLAGS += -Wno-deprecated-declarations\nendif\n\nifdef TEST_MMAP\n\tSHMAT_OK=0\n\toverride CFLAGS += -DUSEMMAP=1\n\tLDFLAGS += -Wno-deprecated-declarations\nendif\n\n.PHONY: all\nall:\ttest_x86 test_shm test_python ready $(PROGS) llvm gcc_plugin test_build all_done\n\t-$(MAKE) -C utils/aflpp_driver\n\t@echo\n\t@echo\n\t@echo\n\t@echo\n\t@echo Build Summary:\n\t@test -e afl-fuzz && echo \"[+] afl-fuzz and supporting tools successfully built\" || echo \"[-] afl-fuzz could not be built, please set CC to a working compiler\"\n\t@test -e afl-llvm-pass.so && echo \"[+] LLVM basic mode successfully built\" || echo \"[-] LLVM mode could not be built, please install at least llvm-11 and clang-11 or newer, see docs/INSTALL.md\"\n\t@test -e SanitizerCoveragePCGUARD.so && echo \"[+] LLVM mode successfully built\" || echo \"[-] LLVM mode could not be built, please install at least llvm-13 and clang-13 or newer, see docs/INSTALL.md\"\n\t@test -e SanitizerCoverageLTO.so && echo \"[+] LLVM LTO mode successfully built\" || echo \"[-] LLVM LTO mode could not be built, it is optional, if you want it, please install LLVM and LLD 11+. More information at instrumentation/README.lto.md on how to build it\"\nifneq \"$(SYS)\" \"Darwin\"\n\t@test -e afl-gcc-pass.so && echo \"[+] gcc_mode successfully built\" || echo \"[-] gcc_mode could not be built, it is optional, install gcc-VERSION-plugin-dev to enable this\"\nendif\n\t@test -e afl-cc || echo \"[-] AFL++ instrumentation compilers could not be built! Install llvm-VERSION-dev or gcc-VERSION-plugin-dev, see docs/INSTALL.md!\"\n\t@echo\n\n.PHONY: llvm\nllvm:\n\t-$(MAKE) -j$(nproc) -f GNUmakefile.llvm\n\t@test -e afl-cc || { echo \"[-] Compiling afl-cc failed. You seem not to have a working compiler.\" ; exit 1; }\n\n.PHONY: gcc_plugin\ngcc_plugin:\nifneq \"$(SYS)\" \"Darwin\"\n\t-$(MAKE) -f GNUmakefile.gcc_plugin\nendif\n\n.PHONY: man\nman:    $(MANPAGES)\n\n.PHONY: test\ntest:\ttests\n\n.PHONY: tests\ntests:\tsource-only\n\t@cd test ; ./test-all.sh\n\t@rm -f test/errors\n\n.PHONY: performance-tests\nperformance-tests:\tperformance-test\n.PHONY: test-performance\ntest-performance:\tperformance-test\n\n.PHONY: performance-test\nperformance-test:\tsource-only\n\t@cd test ; ./test-performance.sh\n\n\n# hint: make targets are also listed in the top level README.md\n.PHONY: help\nhelp:\n\t@echo \"HELP --- the following make targets exist:\"\n\t@echo \"==========================================\"\n\t@echo \"all: the main AFL++ binaries and llvm/gcc instrumentation\"\n\t@echo \"binary-only: everything for binary-only fuzzing: frida_mode, nyx_mode, qemu_mode, frida_mode, unicorn_mode, coresight_mode, libdislocator, libtokencap\"\n\t@echo \"source-only: everything for source code fuzzing: nyx_mode, libdislocator, libtokencap\"\n\t@echo \"distrib: everything (for both binary-only and source code fuzzing)\"\n\t@echo \"man: creates simple man pages from the help option of the programs\"\n\t@echo \"install: installs everything you have compiled with the build option above\"\n\t@echo \"clean: cleans everything compiled (not downloads when on a checkout)\"\n\t@echo \"deepclean: cleans everything including downloads\"\n\t@echo \"uninstall: uninstall AFL++ from the system\"\n\t@echo \"code-format: format the code, do this before you commit and send a PR please!\"\n\t@echo \"tests: this runs the test framework. It is more catered for the developers, but if you run into problems this helps pinpointing the problem\"\n\t@echo \"unit: perform unit tests (based on cmocka and GNU linker)\"\n\t@echo \"document: creates afl-fuzz-document which will only do one run and save all manipulated inputs into out/queue/mutations\"\n\t@echo \"help: shows these build options :-)\"\n\t@echo \"==========================================\"\n\t@echo \"Recommended: \\\"distrib\\\" or \\\"source-only\\\", then \\\"install\\\"\"\n\t@echo\n\t@echo Known build environment options:\n\t@echo \"==========================================\"\n\t@echo \"PERFORMANCE - compile with performance options that make the binary not transferable to other systems. Recommended!\"\n\t@echo STATIC - compile AFL++ static\n\t@echo \"CODE_COVERAGE - compile the target for code coverage (see docs/instrumentation/README.llvm.md)\"\n\t@echo ASAN_BUILD - compiles AFL++ with memory sanitizer for debug purposes\n\t@echo UBSAN_BUILD - compiles AFL++ tools with undefined behaviour sanitizer for debug purposes\n\t@echo DEBUG - no optimization, -ggdb3, all warnings and -Werror\n\t@echo LLVM_DEBUG - shows llvm deprecation warnings\n\t@echo PROFILING - compile afl-fuzz with profiling information\n\t@echo INTROSPECTION - compile afl-fuzz with mutation introspection\n\t@echo NO_PYTHON - disable python support\n\t@echo NO_SPLICING - disables splicing mutation in afl-fuzz, not recommended for normal fuzzing\n\t@echo \"NO_UTF - do not use UTF-8 for line rendering in status screen (fallback to G1 box drawing, of vanilla AFL)\"\n\t@echo NO_NYX - disable building nyx mode dependencies\n\t@echo \"NO_CORESIGHT - disable building coresight (arm64 only)\"\n\t@echo NO_UNICORN_ARM64 - disable building unicorn on arm64\n\t@echo \"WAFL_MODE - enable for WASM fuzzing with https://github.com/fgsect/WAFL\"\n\t@echo AFL_NO_X86 - if compiling on non-intel/amd platforms\n\t@echo \"LLVM_CONFIG - if your distro doesn't use the standard name for llvm-config (e.g., Debian)\"\n\t@echo \"==========================================\"\n\t@echo e.g.: make LLVM_CONFIG=llvm-config-16\n\n.PHONY: test_x86\nifndef AFL_NO_X86\ntest_x86:\n\t@echo \"[*] Checking for the default compiler cc...\"\n\t@type $(CC) >/dev/null || ( echo; echo \"Oops, looks like there is no compiler '\"$(CC)\"' in your path.\"; echo; echo \"Don't panic! You can restart with '\"$(_)\" CC=<yourCcompiler>'.\"; echo; exit 1 )\n\t@echo \"[*] Testing the PATH environment variable...\"\n\t@test \"$${PATH}\" != \"$${PATH#.:}\" && { echo \"Please remove current directory '.' from PATH to avoid recursion of 'as', thanks!\"; echo; exit 1; } || :\n\t@echo \"[*] Checking for the ability to compile x86 code...\"\n\t@echo 'int main() { __asm__(\"xorb %al, %al\"); }' | $(CC) $(CFLAGS) $(LDFLAGS) -w -x c - -o .test1 || ( echo; echo \"Oops, looks like your compiler can't generate x86 code.\"; echo; echo \"Don't panic! You can use the LLVM or QEMU mode, but see docs/INSTALL first.\"; echo \"(To ignore this error, set AFL_NO_X86=1 and try again.)\"; echo; exit 1 )\n\t@rm -f .test1\nelse\ntest_x86:\n\t@echo \"[!] Note: skipping x86 compilation checks (AFL_NO_X86 set).\"\nendif\n\n.PHONY: test_shm\nifeq \"$(SHMAT_OK)\" \"1\"\ntest_shm:\n\t@echo \"[+] shmat seems to be working.\"\n\t@rm -f .test2\nelse\ntest_shm:\n\t@echo \"[-] shmat seems not to be working, switching to mmap implementation\"\nendif\n\nifeq \"$(shell echo '$(HASH)include <zlib.h>@int main() {return 0; }' | tr @ '\\n' | $(CC) $(CFLAGS) -Werror -x c - -lz -o .test 2>/dev/null && echo 1 || echo 0 ; rm -f .test )\" \"1\"\n  override SPECIAL_PERFORMANCE += -DHAVE_ZLIB\n  override LDFLAGS += -lz\n  $(info [+] ZLIB detected)\nelse\n  $(info [!] Warning: no ZLIB detected)\nendif\n\n.PHONY: test_python\nifeq \"$(PYTHON_OK)\" \"1\"\ntest_python:\n\t@rm -f .test 2> /dev/null\n\t@echo \"[+] $(PYTHON_VERSION) support seems to be working.\"\nelse\ntest_python:\n\t@echo \"[-] You seem to need to install the package python3-dev or python-dev (and perhaps python[3]-apt), but it is optional so we continue\"\nendif\n\n.PHONY: ready\nready:\n\t@echo \"[+] Everything seems to be working, ready to compile. ($(shell $(CC) --version 2>&1|head -n 1))\"\n\nsrc/afl-performance.o : $(COMM_HDR) src/afl-performance.c include/hash.h\n\t$(CC) $(CFLAGS) $(CFLAGS_OPT) $(SPECIAL_PERFORMANCE) -Iinclude -c src/afl-performance.c -o src/afl-performance.o\n\nsrc/afl-common.o : $(COMM_HDR) src/afl-common.c include/common.h\n\t$(CC) $(CFLAGS) $(CFLAGS_FLTO) $(SPECIAL_PERFORMANCE) -c src/afl-common.c -o src/afl-common.o\n\nsrc/afl-forkserver.o : $(COMM_HDR) src/afl-forkserver.c include/forkserver.h\n\t$(CC) $(CFLAGS) $(CFLAGS_FLTO) $(SPECIAL_PERFORMANCE) -c src/afl-forkserver.c -o src/afl-forkserver.o\n\nsrc/afl-sharedmem.o : $(COMM_HDR) src/afl-sharedmem.c include/sharedmem.h\n\t$(CC) $(CFLAGS) $(CFLAGS_FLTO) $(SPECIAL_PERFORMANCE) -c src/afl-sharedmem.c -o src/afl-sharedmem.o\n\nafl-fuzz: $(COMM_HDR) include/afl-fuzz.h $(AFL_FUZZ_FILES) src/afl-common.o src/afl-sharedmem.o src/afl-forkserver.o src/afl-performance.o | test_x86\n\t$(CC) $(CFLAGS) $(COMPILE_STATIC) $(CFLAGS_FLTO) $(SPECIAL_PERFORMANCE) $(AFL_FUZZ_FILES) src/afl-common.o src/afl-sharedmem.o src/afl-forkserver.o src/afl-performance.o -o $@ $(PYFLAGS) $(LDFLAGS) -lm\n\nafl-showmap: src/afl-showmap.c src/afl-common.o src/afl-sharedmem.o src/afl-forkserver.o src/afl-performance.o $(COMM_HDR) | test_x86\n\t$(CC) $(CFLAGS) $(COMPILE_STATIC) $(CFLAGS_FLTO) $(SPECIAL_PERFORMANCE) src/$@.c src/afl-fuzz-mutators.c src/afl-fuzz-python.c src/afl-common.o src/afl-sharedmem.o src/afl-forkserver.o src/afl-performance.o -o $@ $(PYFLAGS) $(LDFLAGS)\n\nafl-tmin: src/afl-tmin.c src/afl-common.o src/afl-sharedmem.o src/afl-forkserver.o src/afl-performance.o $(COMM_HDR) | test_x86\n\t$(CC) $(CFLAGS) $(COMPILE_STATIC) $(CFLAGS_FLTO) $(SPECIAL_PERFORMANCE) src/$@.c src/afl-common.o src/afl-sharedmem.o src/afl-forkserver.o src/afl-performance.o -o $@ $(LDFLAGS)\n\nafl-analyze: src/afl-analyze.c src/afl-common.o src/afl-sharedmem.o src/afl-performance.o src/afl-forkserver.o $(COMM_HDR) | test_x86\n\t$(CC) $(CFLAGS) $(COMPILE_STATIC) $(CFLAGS_FLTO) $(SPECIAL_PERFORMANCE) src/$@.c src/afl-common.o src/afl-sharedmem.o src/afl-performance.o src/afl-forkserver.o -o $@ $(LDFLAGS)\n\nafl-gotcpu: src/afl-gotcpu.c src/afl-common.o $(COMM_HDR) | test_x86\n\t$(CC) $(CFLAGS) $(COMPILE_STATIC) $(CFLAGS_FLTO) $(SPECIAL_PERFORMANCE) src/$@.c src/afl-common.o -o $@ $(LDFLAGS)\n\n.PHONY: document\ndocument:\tafl-fuzz-document\n\n# document all mutations and only do one run (use with only one input file!)\nafl-fuzz-document: $(COMM_HDR) include/afl-fuzz.h $(AFL_FUZZ_FILES) src/afl-common.o src/afl-sharedmem.o src/afl-performance.o | test_x86\n\t$(CC) -D_DEBUG=\\\"1\\\" -D_AFL_DOCUMENT_MUTATIONS $(CFLAGS) $(CFLAGS_FLTO) $(AFL_FUZZ_FILES) src/afl-common.o src/afl-sharedmem.o src/afl-forkserver.c src/afl-performance.o -o afl-fuzz-document $(PYFLAGS) $(LDFLAGS)\n\ntest/unittests/unit_maybe_alloc.o : $(COMM_HDR) include/alloc-inl.h test/unittests/unit_maybe_alloc.c $(AFL_FUZZ_FILES)\n\t@$(CC) $(CFLAGS) $(ASAN_CFLAGS) -c test/unittests/unit_maybe_alloc.c -o test/unittests/unit_maybe_alloc.o\n\nunit_maybe_alloc: test/unittests/unit_maybe_alloc.o\n\t@$(CC) $(CFLAGS) -Wl,--wrap=exit -Wl,--wrap=printf test/unittests/unit_maybe_alloc.o -o test/unittests/unit_maybe_alloc $(LDFLAGS) $(ASAN_LDFLAGS) -lcmocka\n\t./test/unittests/unit_maybe_alloc\n\ntest/unittests/unit_hash.o : $(COMM_HDR) include/alloc-inl.h test/unittests/unit_hash.c $(AFL_FUZZ_FILES) src/afl-performance.o\n\t@$(CC) $(CFLAGS) $(ASAN_CFLAGS) $(SPECIAL_PERFORMANCE) -c test/unittests/unit_hash.c -o test/unittests/unit_hash.o\n\nunit_hash: test/unittests/unit_hash.o src/afl-performance.o\n\t@$(CC) $(CFLAGS) $(SPECIAL_PERFORMANCE) -Wl,--wrap=exit -Wl,--wrap=printf $^ -o test/unittests/unit_hash $(LDFLAGS) $(ASAN_LDFLAGS) -lcmocka\n\t./test/unittests/unit_hash\n\ntest/unittests/unit_rand.o : $(COMM_HDR) include/alloc-inl.h test/unittests/unit_rand.c $(AFL_FUZZ_FILES) src/afl-performance.o\n\t@$(CC) $(CFLAGS) $(ASAN_CFLAGS) $(SPECIAL_PERFORMANCE) -c test/unittests/unit_rand.c -o test/unittests/unit_rand.o\n\nunit_rand: test/unittests/unit_rand.o src/afl-common.o src/afl-performance.o\n\t@$(CC) $(CFLAGS) $(ASAN_CFLAGS) $(SPECIAL_PERFORMANCE) -Wl,--wrap=exit -Wl,--wrap=printf $^ -o test/unittests/unit_rand  $(LDFLAGS) $(ASAN_LDFLAGS) -lcmocka\n\t./test/unittests/unit_rand\n\ntest/unittests/unit_list.o : $(COMM_HDR) include/list.h test/unittests/unit_list.c $(AFL_FUZZ_FILES)\n\t@$(CC) $(CFLAGS) $(ASAN_CFLAGS) -c test/unittests/unit_list.c -o test/unittests/unit_list.o\n\nunit_list: test/unittests/unit_list.o\n\t@$(CC) $(CFLAGS) $(ASAN_CFLAGS) -Wl,--wrap=exit -Wl,--wrap=printf test/unittests/unit_list.o -o test/unittests/unit_list  $(LDFLAGS) $(ASAN_LDFLAGS) -lcmocka\n\t./test/unittests/unit_list\n\ntest/unittests/unit_preallocable.o : $(COMM_HDR) include/alloc-inl.h test/unittests/unit_preallocable.c $(AFL_FUZZ_FILES)\n\t@$(CC) $(CFLAGS) $(ASAN_CFLAGS) -c test/unittests/unit_preallocable.c -o test/unittests/unit_preallocable.o\n\nunit_preallocable: test/unittests/unit_preallocable.o\n\t@$(CC) $(CFLAGS) $(ASAN_CFLAGS) -Wl,--wrap=exit -Wl,--wrap=printf test/unittests/unit_preallocable.o -o test/unittests/unit_preallocable $(LDFLAGS) $(ASAN_LDFLAGS) -lcmocka\n\t./test/unittests/unit_preallocable\n\n.PHONY: unit_clean\nunit_clean:\n\t@rm -f ./test/unittests/unit_preallocable ./test/unittests/unit_list ./test/unittests/unit_maybe_alloc test/unittests/*.o\n\n.PHONY: unit\nifneq \"$(SYS)\" \"Darwin\"\nunit:\tunit_maybe_alloc unit_preallocable unit_list unit_clean unit_rand unit_hash\nelse\nunit:\n\t@echo [-] unit tests are skipped on Darwin \\(lacks GNU linker feature --wrap\\)\nendif\n\n.PHONY: code-format\ncode-format:\n\t./.custom-format.py -i src/*.c\n\t./.custom-format.py -i include/*.h\n\t./.custom-format.py -i instrumentation/*.h\n\t./.custom-format.py -i instrumentation/*.cc\n\t./.custom-format.py -i instrumentation/*.c\n\t./.custom-format.py -i *.h\n\t./.custom-format.py -i *.c\n\t@#./.custom-format.py -i custom_mutators/*/*.c* # destroys libfuzzer :-(\n\t@#./.custom-format.py -i custom_mutators/*/*.h # destroys honggfuzz :-(\n\t./.custom-format.py -i utils/*/*.c*\n\t./.custom-format.py -i utils/*/*.h\n\t./.custom-format.py -i test/*.c\n\t./.custom-format.py -i frida_mode/src/*.c\n\t./.custom-format.py -i frida_mode/include/*.h\n\t-./.custom-format.py -i frida_mode/src/*/*.c\n\t./.custom-format.py -i qemu_mode/libcompcov/*.c\n\t./.custom-format.py -i qemu_mode/libcompcov/*.cc\n\t./.custom-format.py -i qemu_mode/libcompcov/*.h\n\t./.custom-format.py -i qemu_mode/libqasan/*.c\n\t./.custom-format.py -i qemu_mode/libqasan/*.h\n\n\n.PHONY: test_build\nifndef AFL_NO_X86\ntest_build: afl-cc afl-showmap\n\t@echo \"[*] Testing the CC wrapper afl-cc and its instrumentation output...\"\n\t@unset AFL_MAP_SIZE AFL_USE_UBSAN AFL_USE_CFISAN AFL_USE_LSAN AFL_USE_ASAN AFL_USE_MSAN AFL_LLVM_ALLOWLIST AFL_LLVM_DENYLIST; ASAN_OPTIONS=detect_leaks=0 AFL_INST_RATIO=100 AFL_PATH=. ./afl-cc test-instr.c $(LDFLAGS) -o test-instr 2>&1 || (echo \"Oops, afl-cc failed\"; exit 1 )\n\t-ASAN_OPTIONS=detect_leaks=0 ./afl-showmap -q -m none -o .test-instr0 ./test-instr < /dev/null\n\t-echo 1 | ASAN_OPTIONS=detect_leaks=0 ./afl-showmap -m none -q -o .test-instr1 ./test-instr\n\t@rm -f test-instr\n\t@cmp -s .test-instr0 .test-instr1; DR=\"$$?\"; rm -f .test-instr0 .test-instr1; if [ \"$$DR\" = \"0\" ]; then echo; echo \"Oops, the instrumentation of afl-cc does not seem to be behaving correctly!\"; echo; echo \"Please post to https://github.com/AFLplusplus/AFLplusplus/issues to troubleshoot the issue.\"; echo; exit 1; fi\n\t@echo\n\t@echo \"[+] All right, the instrumentation of afl-cc seems to be working!\"\n#\t@echo \"[*] Testing the CC wrapper and its instrumentation output...\"\n#\t@unset AFL_MAP_SIZE AFL_USE_UBSAN AFL_USE_CFISAN AFL_USE_LSAN AFL_USE_ASAN AFL_USE_MSAN; AFL_CC=$(CC) ASAN_OPTIONS=detect_leaks=0 AFL_INST_RATIO=100 AFL_PATH=. ./afl-clang-fast test-instr.c -o test-instr 2>&1 || (echo \"Oops, afl-clang-fast failed\"; exit 1 )\n#\tASAN_OPTIONS=detect_leaks=0 ./afl-showmap -m none -q -o .test-instr0 ./test-instr < /dev/null\n#\techo 1 | ASAN_OPTIONS=detect_leaks=0 ./afl-showmap -m none -q -o .test-instr1 ./test-instr\n#\t@rm -f test-instr\n#\t@cmp -s .test-instr0 .test-instr1; DR=\"$$?\"; rm -f .test-instr0 .test-instr1; if [ \"$$DR\" = \"0\" ]; then echo; echo \"Oops, the instrumentation of afl-clang-fast does not seem to be behaving correctly!\"; \\\n#\t\tgcc -v 2>&1 | grep -q -- --with-as= && ( echo; echo \"Gcc is configured not to use an external assembler with the -B option.\" ) || \\\n#\t\t( echo; echo \"Please post to https://github.com/AFLplusplus/AFLplusplus/issues to troubleshoot the issue.\" ); echo; exit 0; fi\n#\t@echo\n#\t@echo \"[+] All right, the instrumentation of afl-clang-fast seems to be working!\"\nelse\ntest_build: afl-cc afl-showmap\n\t@echo \"[!] Note: skipping build tests (you may need to use LLVM or QEMU mode).\"\nendif\n\n.PHONY: all_done\nall_done: test_build\n\t@test -e afl-cc && echo \"[+] Main compiler 'afl-cc' successfully built!\" || { echo \"[-] Main compiler 'afl-cc' failed to build, set up a working build environment first!\" ; exit 1 ; }\n\t@test -e cmplog-instructions-pass.so && echo \"[+] LLVM mode for 'afl-cc' successfully built!\" || echo \"[-] LLVM mode for 'afl-cc'  failed to build, likely you either don't have llvm installed, or you need to set LLVM_CONFIG, to point to e.g. llvm-config-11. See instrumentation/README.llvm.md how to do this. Highly recommended!\"\n\t@test -e SanitizerCoverageLTO.so && echo \"[+] LLVM LTO mode for 'afl-cc' successfully built!\" || echo \"[-] LLVM LTO mode for 'afl-cc'  failed to build, this would need LLVM 11+, see instrumentation/README.lto.md how to build it\"\n\t@test -e afl-gcc-pass.so && echo \"[+] gcc_plugin for 'afl-cc' successfully built!\" || echo \"[-] gcc_plugin for 'afl-cc'  failed to build, unless you really need it that is fine - or read instrumentation/README.gcc_plugin.md how to build it\"\n\t@test -e afl-cc && echo \"[+] All done! Be sure to review the README.md - it's pretty short and useful.\"\n\t@test -e afl-cc || echo \"[-] ERROR  - neither afl-clang-fast or afl-gcc-fast could be compiled - YOU ARE MISSING PACKAGES! Read docs/INSTALL.md!\"\n\t@if [ \"$(SYS)\" = \"Darwin\" ]; then printf \"\\nWARNING: Fuzzing on MacOS X is slow because of the unusually high overhead of\\nfork() on this OS. Consider using Linux or *BSD for fuzzing software not\\nspecifically for MacOS.\\n\\n\"; fi\n\t@! tty <&1 >/dev/null || printf \"\\033[0;30mNOTE: If you can read this, your terminal probably uses white background.\\nThis will make the UI hard to read. See docs/status_screen.md for advice.\\033[0m\\n\" 2>/dev/null\n\n.NOTPARALLEL: clean all\n\n.PHONY: clean\nclean:\n\trm -rf $(PROGS) afl-fuzz-document as afl-as afl-g++ afl-clang afl-clang++ *.o src/*.o *~ a.out core core.[1-9][0-9]* *.stackdump .test .test1 .test2 test-instr .test-instr0 .test-instr1 afl-cs-proxy afl-qemu-trace afl-gcc-fast afl-g++-fast ld *.so *.8 test/unittests/*.o test/unittests/unit_maybe_alloc test/unittests/preallocable .afl-* afl-gcc afl-g++ afl-clang afl-clang++ test/unittests/unit_hash test/unittests/unit_rand *.dSYM lib*.a\n\t-$(MAKE) -f GNUmakefile.llvm clean\n\t-$(MAKE) -f GNUmakefile.gcc_plugin clean\n\t-$(MAKE) -C utils/libdislocator clean\n\t-$(MAKE) -C utils/libtokencap clean\n\t-$(MAKE) -C utils/aflpp_driver clean\n\t-$(MAKE) -C utils/afl_network_proxy clean\n\t-$(MAKE) -C utils/socket_fuzzing clean\n\t-$(MAKE) -C utils/argv_fuzzing clean\n\t-$(MAKE) -C utils/plot_ui clean\n\t-$(MAKE) -C qemu_mode/unsigaction clean\n\t-$(MAKE) -C qemu_mode/fastexit clean\n\t-$(MAKE) -C qemu_mode/libcompcov clean\n\t-$(MAKE) -C qemu_mode/libqasan clean\n\t-$(MAKE) -C frida_mode clean\n\trm -rf nyx_mode/packer/linux_initramfs/init.cpio.gz nyx_mode/libnyx/libnyx/target/release/* nyx_mode/QEMU-Nyx/x86_64-softmmu/qemu-system-x86_64\nifeq \"$(IN_REPO)\" \"1\"\n\t-test -e coresight_mode/coresight-trace/Makefile && $(MAKE) -C coresight_mode/coresight-trace clean || true\n\t-test -e qemu_mode/qemuafl/Makefile && $(MAKE) -C qemu_mode/qemuafl clean || true\n\t-test -e unicorn_mode/unicornafl/Makefile && $(MAKE) -C unicorn_mode/unicornafl clean || true\n\t-test -e nyx_mode/QEMU-Nyx/Makefile && $(MAKE) -C nyx_mode/QEMU-Nyx clean || true\nelse\n\trm -rf coresight_mode/coresight_trace\n\trm -rf qemu_mode/qemuafl\n\trm -rf unicorn_mode/unicornafl\nendif\n\n.PHONY: deepclean\ndeepclean:\tclean\n\trm -rf coresight_mode/coresight-trace\n\trm -rf unicorn_mode/unicornafl\n\trm -rf qemu_mode/qemuafl\n\trm -rf nyx_mode/libnyx nyx_mode/packer nyx_mode/QEMU-Nyx\nifeq \"$(IN_REPO)\" \"1\"\n\tgit checkout coresight_mode/coresight-trace\n\tgit checkout unicorn_mode/unicornafl\n\tgit checkout qemu_mode/qemuafl\n\tgit checkout nyx_mode/libnyx\n\tgit checkout nyx_mode/packer\n\tgit checkout nyx_mode/QEMU-Nyx\nendif\n\n.PHONY: distrib\ndistrib: all\n\t-$(MAKE) -j$(nproc) -f GNUmakefile.llvm\nifneq \"$(SYS)\" \"Darwin\"\n\t-$(MAKE) -f GNUmakefile.gcc_plugin\n\t-$(MAKE) -C utils/libdislocator\n\t-$(MAKE) -C utils/libtokencap\nendif\n\t-$(MAKE) -C utils/afl_network_proxy\n\t-$(MAKE) -C utils/socket_fuzzing\n\t-$(MAKE) -C utils/argv_fuzzing\n\t# -$(MAKE) -C utils/plot_ui\n\t-$(MAKE) -C frida_mode\nifneq \"$(SYS)\" \"Darwin\"\nifeq \"$(ARCH)\" \"aarch64\"\n  ifndef NO_CORESIGHT\n\t-$(MAKE) -C coresight_mode\n  endif\nendif\nifeq \"$(SYS)\" \"Linux\"\nifndef NO_NYX\n\t-cd nyx_mode && ./build_nyx_support.sh\nendif\nendif\n\t-cd qemu_mode && sh ./build_qemu_support.sh\n  ifeq \"$(ARCH)\" \"aarch64\"\n    ifndef NO_UNICORN_ARM64\n\t-cd unicorn_mode && unset CFLAGS && sh ./build_unicorn_support.sh\n    endif\n  else\n\t-cd unicorn_mode && unset CFLAGS && sh ./build_unicorn_support.sh\n  endif\nendif\n\n.PHONY: binary-only\nbinary-only: test_shm test_python ready $(PROGS)\nifneq \"$(SYS)\" \"Darwin\"\n\t-$(MAKE) -C utils/libdislocator\n\t-$(MAKE) -C utils/libtokencap\nendif\n\t-$(MAKE) -C utils/afl_network_proxy\n\t-$(MAKE) -C utils/socket_fuzzing\n\t-$(MAKE) -C utils/argv_fuzzing\n\t# -$(MAKE) -C utils/plot_ui\n\t-$(MAKE) -C frida_mode\nifneq \"$(SYS)\" \"Darwin\"\nifeq \"$(ARCH)\" \"aarch64\"\n  ifndef NO_CORESIGHT\n\t-$(MAKE) -C coresight_mode\n  endif\nendif\nifeq \"$(SYS)\" \"Linux\"\nifndef NO_NYX\n\t-cd nyx_mode && ./build_nyx_support.sh\nendif\nendif\n\t-cd qemu_mode && sh ./build_qemu_support.sh\n  ifeq \"$(ARCH)\" \"aarch64\"\n    ifndef NO_UNICORN_ARM64\n\t-cd unicorn_mode && unset CFLAGS && sh ./build_unicorn_support.sh\n    endif\n  else\n\t-cd unicorn_mode && unset CFLAGS && sh ./build_unicorn_support.sh\n  endif\nendif\n\t@echo\n\t@echo\n\t@echo Build Summary:\n\t@test -e afl-fuzz && echo \"[+] afl-fuzz and supporting tools successfully built\" || echo \"[-] afl-fuzz could not be built, please set CC to a working compiler\"\nifneq \"$(SYS)\" \"Darwin\"\nifeq \"$(ARCH)\" \"aarch64\"\n  ifndef NO_CORESIGHT\n\t@test -e afl-cs-proxy && echo \"[+] coresight_mode successfully built\" || echo \"[-] coresight_mode could not be built, it is optional and experimental, see coresight_mode/README.md for what is needed\"\n  endif\nendif\nifeq \"$(SYS)\" \"Linux\"\nifndef NO_NYX\n\t@test -e libnyx.so && echo \"[+] nyx_mode successfully built\" || echo \"[-] nyx_mode could not be built, it is optional, see nyx_mode/README.md for what is needed\"\nendif\nendif\n\t@test -e afl-qemu-trace && echo \"[+] qemu_mode successfully built\" || echo \"[-] qemu_mode could not be built, see docs/INSTALL.md for what is needed\"\n  ifeq \"$(ARCH)\" \"aarch64\"\n    ifndef NO_UNICORN_ARM64\n\t@test -e unicorn_mode/unicornafl/build_python/libunicornafl.so && echo \"[+] unicorn_mode successfully built\" || echo \"[-] unicorn_mode could not be built, it is optional, see unicorn_mode/README.md for what is needed\"\n    endif\n  else\n\t@test -e unicorn_mode/unicornafl/build_python/libunicornafl.so && echo \"[+] unicorn_mode successfully built\" || echo \"[-] unicorn_mode could not be built, it is optional, see unicorn_mode/README.md for what is needed\"\n  endif\nendif\n\t@echo\n\n.PHONY: source-only\nsource-only: all\n\t-$(MAKE) -j$(nproc) -f GNUmakefile.llvm\nifneq \"$(SYS)\" \"Darwin\"\n\t-$(MAKE) -f GNUmakefile.gcc_plugin\n\t-$(MAKE) -C utils/libdislocator\n\t-$(MAKE) -C utils/libtokencap\nendif\n\t# -$(MAKE) -C utils/plot_ui\nifeq \"$(SYS)\" \"Linux\"\nifndef NO_NYX\n\t-cd nyx_mode && ./build_nyx_support.sh\nendif\nendif\n\t@echo\n\t@echo\n\t@echo Build Summary:\n\t@test -e afl-fuzz && echo \"[+] afl-fuzz and supporting tools successfully built\" || echo \"[-] afl-fuzz could not be built, please set CC to a working compiler\"\n\t@test -e afl-llvm-pass.so && echo \"[+] LLVM basic mode successfully built\" || echo \"[-] LLVM mode could not be built, please install at least llvm-11 and clang-11 or newer, see docs/INSTALL.md\"\n\t@test -e SanitizerCoveragePCGUARD.so && echo \"[+] LLVM mode successfully built\" || echo \"[-] LLVM mode could not be built, please install at least llvm-13 and clang-13 or newer, see docs/INSTALL.md\"\n\t@test -e SanitizerCoverageLTO.so && echo \"[+] LLVM LTO mode successfully built\" || echo \"[-] LLVM LTO mode could not be built, it is optional, if you want it, please install LLVM 11-14. More information at instrumentation/README.lto.md on how to build it\"\nifneq \"$(SYS)\" \"Darwin\"\n\t@test -e afl-gcc-pass.so && echo \"[+] gcc_mode successfully built\" || echo \"[-] gcc_mode could not be built, it is optional, install gcc-VERSION-plugin-dev to enable this\"\nendif\nifeq \"$(SYS)\" \"Linux\"\nifndef NO_NYX\n\t@test -e libnyx.so && echo \"[+] nyx_mode successfully built\" || echo \"[-] nyx_mode could not be built, it is optional, see nyx_mode/README.md for what is needed\"\nendif\nendif\n\t@echo\n\n%.8:\t%\n\t@echo .TH $* 8 $(BUILD_DATE) \"AFL++\" > $@\n\t@echo .SH NAME >> $@\n\t@echo .B $* >> $@\n\t@echo >> $@\n\t@echo .SH SYNOPSIS >> $@\n\t@./$* -h 2>&1 | head -n 3 | tail -n 1 | sed 's/^\\.\\///' >> $@\n\t@echo >> $@\n\t@echo .SH OPTIONS >> $@\n\t@echo .nf >> $@\n\t@./$* -hh 2>&1 | tail -n +4 >> $@\n\t@echo >> $@\n\t@echo .SH AUTHOR >> $@\n\t@echo \"AFL++ was written by Michal \\\"lcamtuf\\\" Zalewski and is maintained by Marc \\\"van Hauser\\\" Heuse <mh@mh-sec.de>, Dominik Maier <domenukk@gmail.com>, Andrea Fioraldi <andreafioraldi@gmail.com> and Heiko \\\"hexcoder-\\\" Eissfeldt <heiko.eissfeldt@hexco.de>\" >> $@\n\t@echo  The homepage of AFL++ is: https://github.com/AFLplusplus/AFLplusplus >> $@\n\t@echo >> $@\n\t@echo .SH LICENSE >> $@\n\t@echo Apache License Version 2.0, January 2004 >> $@\n\n.PHONY: install\ninstall: all $(MANPAGES)\n\t@install -d -m 755 $${DESTDIR}$(BIN_PATH) $${DESTDIR}$(HELPER_PATH) $${DESTDIR}$(DOC_PATH) $${DESTDIR}$(MISC_PATH)\n\t@rm -f $${DESTDIR}$(BIN_PATH)/afl-plot.sh\n\t@rm -f $${DESTDIR}$(BIN_PATH)/afl-as\n\t@rm -f $${DESTDIR}$(HELPER_PATH)/afl-llvm-rt.o $${DESTDIR}$(HELPER_PATH)/afl-llvm-rt-32.o $${DESTDIR}$(HELPER_PATH)/afl-llvm-rt-64.o $${DESTDIR}$(HELPER_PATH)/afl-gcc-rt.o\n\t@for i in afl-llvm-dict2file.so afl-llvm-lto-instrumentlist.so afl-llvm-pass.so cmplog-instructions-pass.so cmplog-routines-pass.so cmplog-switches-pass.so compare-transform-pass.so libcompcov.so libdislocator.so libnyx.so libqasan.so libtokencap.so SanitizerCoverageLTO.so SanitizerCoveragePCGUARD.so split-compares-pass.so split-switches-pass.so injection-pass.so; do echo rm -fv $${DESTDIR}$(HELPER_PATH)/$${i}; done\n\tinstall -m 755 $(PROGS) $(SH_PROGS) $${DESTDIR}$(BIN_PATH)\n\t@if [ -f afl-qemu-trace ]; then install -m 755 afl-qemu-trace $${DESTDIR}$(BIN_PATH); fi\n\t@if [ -f utils/plot_ui/afl-plot-ui ]; then install -m 755 utils/plot_ui/afl-plot-ui $${DESTDIR}$(BIN_PATH); fi\n\t@if [ -f libdislocator.so ]; then set -e; install -m 755 libdislocator.so $${DESTDIR}$(HELPER_PATH); fi\n\t@if [ -f libtokencap.so ]; then set -e; install -m 755 libtokencap.so $${DESTDIR}$(HELPER_PATH); fi\n\t@if [ -f libcompcov.so ]; then set -e; install -m 755 libcompcov.so $${DESTDIR}$(HELPER_PATH); fi\n\t@if [ -f libqasan.so ]; then set -e; install -m 755 libqasan.so $${DESTDIR}$(HELPER_PATH); fi\n\t@if [ -f afl-fuzz-document ]; then set -e; install -m 755 afl-fuzz-document $${DESTDIR}$(BIN_PATH); fi\n\t@if [ -f socketfuzz32.so -o -f socketfuzz64.so ]; then $(MAKE) -C utils/socket_fuzzing install; fi\n\t@if [ -f argvfuzz32.so -o -f argvfuzz64.so ]; then $(MAKE) -C utils/argv_fuzzing install; fi\n\t@if [ -f afl-frida-trace.so ]; then install -m 755 afl-frida-trace.so $${DESTDIR}$(HELPER_PATH); fi\n\t@if [ -f libnyx.so ]; then install -m 755 libnyx.so $${DESTDIR}$(HELPER_PATH); fi\n\t@if [ -f utils/afl_network_proxy/afl-network-server ]; then $(MAKE) -C utils/afl_network_proxy install; fi\n\t@if [ -f utils/aflpp_driver/libAFLDriver.a ]; then set -e; install -m 644 utils/aflpp_driver/libAFLDriver.a $${DESTDIR}$(HELPER_PATH); fi\n\t@if [ -f utils/aflpp_driver/libAFLQemuDriver.a ]; then set -e; install -m 644 utils/aflpp_driver/libAFLQemuDriver.a $${DESTDIR}$(HELPER_PATH); fi\n\t-$(MAKE) -f GNUmakefile.llvm install\nifneq \"$(SYS)\" \"Darwin\"\n\t-$(MAKE) -f GNUmakefile.gcc_plugin install\nendif\n\tln -sf afl-cc $${DESTDIR}$(BIN_PATH)/afl-gcc\n\tln -sf afl-cc $${DESTDIR}$(BIN_PATH)/afl-g++\n\tln -sf afl-cc $${DESTDIR}$(BIN_PATH)/afl-clang\n\tln -sf afl-cc $${DESTDIR}$(BIN_PATH)/afl-clang++\n\t@mkdir -m 755 -p $${DESTDIR}$(INCLUDE_PATH)\n\tinstall -m 644 $(HEADERS) $${DESTDIR}$(INCLUDE_PATH)\n\t@mkdir -m 0755 -p ${DESTDIR}$(MAN_PATH)\n\tinstall -m0644 *.8 ${DESTDIR}$(MAN_PATH)\n\tinstall -m 644 docs/*.md $${DESTDIR}$(DOC_PATH)\n\tcp -r testcases/ $${DESTDIR}$(MISC_PATH)\n\tcp -r dictionaries/ $${DESTDIR}$(MISC_PATH)\n\tcp injections.dic $${DESTDIR}$(MISC_PATH)\n\n.PHONY: uninstall\nuninstall:\n\t-cd $${DESTDIR}$(BIN_PATH) && rm -f $(PROGS) $(SH_PROGS) afl-cs-proxy afl-qemu-trace afl-plot-ui afl-fuzz-document afl-network-client afl-network-server afl-g* afl-plot.sh afl-ld-lto afl-c* afl-lto*\n\t-cd $${DESTDIR}$(INCLUDE_PATH) && rm -f $(HEADERS:include/%=%)\n\t-cd $${DESTDIR}$(HELPER_PATH) && rm -f afl-g*.*o afl-llvm-*.*o afl-compiler-*.*o libdislocator.so libtokencap.so libcompcov.so libqasan.so afl-frida-trace.so libnyx.so socketfuzz*.so argvfuzz*.so libAFLDriver.a libAFLQemuDriver.a as afl-as SanitizerCoverage*.so compare-transform-pass.so cmplog-*-pass.so split-*-pass.so dynamic_list.txt injections.dic\n\t-rm -rf $${DESTDIR}$(MISC_PATH)/testcases $${DESTDIR}$(MISC_PATH)/dictionaries\n\t-sh -c \"ls docs/*.md | sed 's|^docs/|$${DESTDIR}$(DOC_PATH)/|' | xargs rm -f\"\n\t-cd $${DESTDIR}$(MAN_PATH) && rm -f $(MANPAGES)\n\t-rmdir $${DESTDIR}$(BIN_PATH) 2>/dev/null\n\t-rmdir $${DESTDIR}$(INCLUDE_PATH) 2>/dev/null\n\t-rmdir $${DESTDIR}$(HELPER_PATH) 2>/dev/null\n\t-rmdir $${DESTDIR}$(MISC_PATH) 2>/dev/null\n\t-rmdir $${DESTDIR}$(DOC_PATH) 2>/dev/null\n\t-rmdir $${DESTDIR}$(MAN_PATH) 2>/dev/null\n"
        },
        {
          "name": "GNUmakefile.gcc_plugin",
          "type": "blob",
          "size": 7.869140625,
          "content": "#\n# american fuzzy lop++ - GCC plugin instrumentation\n# -----------------------------------------------\n#\n# Written by Austin Seipp <aseipp@pobox.com> and\n#            Laszlo Szekeres <lszekeres@google.com> and\n#            Michal Zalewski and\n#            Heiko Ei√üfeldt  <heiko@hexco.de>\n#\n# GCC integration design is based on the LLVM design, which comes\n# from Laszlo Szekeres.\n#\n# Copyright 2015 Google Inc. All rights reserved.\n# Copyright 2019-2024 AFLplusplus Project. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at:\n#\n#   https://www.apache.org/licenses/LICENSE-2.0\n#\n#TEST_MMAP=1\nPREFIX      ?= /usr/local\nHELPER_PATH ?= $(PREFIX)/lib/afl\nBIN_PATH    ?= $(PREFIX)/bin\nDOC_PATH    ?= $(PREFIX)/share/doc/afl\nMAN_PATH    ?= $(PREFIX)/share/man/man8\n\nVERSION     = $(shell grep '^$(HASH)define VERSION ' ./config.h | cut -d '\"' -f2)\n\nCFLAGS          ?= -O3 -g -funroll-loops\n# -D_FORTIFY_SOURCE=1\nCFLAGS_SAFE     := -Wall -Iinclude -Wno-pointer-sign \\\n                   -DAFL_PATH=\\\"$(HELPER_PATH)\\\" -DBIN_PATH=\\\"$(BIN_PATH)\\\" \\\n                   -DGCC_VERSION=\\\"$(GCCVER)\\\" -DGCC_BINDIR=\\\"$(GCCBINDIR)\\\" \\\n                   -Wno-unused-function\noverride CFLAGS += $(CFLAGS_SAFE)\n\nCXXFLAGS    ?= -O3 -g -funroll-loops\n# -D_FORTIFY_SOURCE=1\nCXXEFLAGS   := $(CXXFLAGS) $(CPPFLAGS) -Wall -std=c++11\n\nCC          ?= gcc\nCXX         ?= g++\n\nSYS = $(shell uname -s)\n\nifeq \"clang\" \"$(CC)\"\n        CC  = gcc\n        CXX = g++\nendif\n\nifeq \"clang++\" \"$(CXX)\"\n        CC  = gcc\n        CXX = g++\nendif\n\nifeq \"$(findstring Foundation,$(shell $(CC) --version))\" \"\"\n        CC  = gcc\n        CXX = g++\nendif\n\nPLUGIN_BASE = \"$(shell $(CC) -print-file-name=plugin)\"\nPLUGIN_FLAGS = -fPIC -fno-rtti -fno-exceptions -I$(PLUGIN_BASE)/include -I$(PLUGIN_BASE)\nHASH=\\#\n\nGCCVER    = $(shell $(CC) --version 2>/dev/null | awk 'NR == 1 {print $$NF}')\nGCCBINDIR = $(shell dirname `command -v $(CC)` 2>/dev/null )\n\nifeq \"$(shell echo '$(HASH)include <sys/ipc.h>@$(HASH)include <sys/shm.h>@int main() { int _id = shmget(IPC_PRIVATE, 65536, IPC_CREAT | IPC_EXCL | 0600); shmctl(_id, IPC_RMID, 0); return 0;}' | tr @ '\\n' | $(CC) -x c - -o .test2 2>/dev/null && echo 1 || echo 0 ; rm -f .test2 )\" \"1\"\n\tSHMAT_OK=1\nelse\n\tSHMAT_OK=0\n\toverride CFLAGS_SAFE += -DUSEMMAP=1\nendif\n\nifeq \"$(TEST_MMAP)\" \"1\"\n\tSHMAT_OK=0\n\toverride CFLAGS_SAFE += -DUSEMMAP=1\nendif\n\nifneq \"$(SYS)\" \"Haiku\"\nifneq \"$(SYS)\" \"OpenBSD\"\n  \tLDFLAGS += -lrt\nendif\nelse\n\tCFLAGS_SAFE += -DUSEMMAP=1\nendif\n\nifeq \"$(SYS)\" \"OpenBSD\"\n    CC  = egcc\n    CXX = eg++\n    PLUGIN_FLAGS += -I/usr/local/include\nendif\n\nifeq \"$(SYS)\" \"DragonFly\"\n  \tPLUGIN_FLAGS += -I/usr/local/include\nendif\n\nifeq \"$(SYS)\" \"SunOS\"\n  \tPLUGIN_FLAGS += -I/usr/include/gmp\nendif\n\n\nPASSES       = ./afl-gcc-pass.so ./afl-gcc-cmplog-pass.so ./afl-gcc-cmptrs-pass.so\n\nPROGS        = $(PASSES) ./afl-compiler-rt.o ./afl-compiler-rt-32.o ./afl-compiler-rt-64.o\n\n.PHONY: all\nall: test_shm test_deps $(PROGS) test_build all_done\n\n.PHONY: test_shm\nifeq \"$(SHMAT_OK)\" \"1\"\ntest_shm:\n\t@echo \"[+] shmat seems to be working.\"\n\t@rm -f .test2\nelse\ntest_shm:\n\t@echo \"[-] shmat seems not to be working, switching to mmap implementation\"\nendif\n\n.PHONY: test_deps\ntest_deps:\n\t@echo \"[*] Checking for working '$(CC)'...\"\n\t@command -v $(CC) >/dev/null 2>&1 || ( echo \"[-] Oops, can't find '$(CC)'. Make sure that it's in your \\$$PATH (or set \\$$CC and \\$$CXX).\"; exit 1 )\n#\t@echo \"[*] Checking for gcc for plugin support...\"\n#\t@$(CC) -v 2>&1 | grep -q -- --enable-plugin || ( echo \"[-] Oops, this gcc has not been configured with plugin support.\"; exit 1 )\n\t@echo \"[*] Checking for gcc plugin development header files...\"\n\t@test -d `$(CC) -print-file-name=plugin`/include || ( echo \"[-] Oops, can't find gcc header files. Be sure to install 'gcc-X-plugin-dev'.\"; exit 1 )\n\t@echo \"[*] Checking for './afl-showmap'...\"\n\t@test -f ./afl-showmap || ( echo \"[-] Oops, can't find './afl-showmap'. Be sure to compile AFL first.\"; exit 1 )\n\t@echo \"[+] All set and ready to build.\"\n\nafl-common.o: ./src/afl-common.c\n\t$(CC) $(CFLAGS) $(CPPFLAGS) -c $< -o $@ $(LDFLAGS)\n\n./afl-compiler-rt.o: instrumentation/afl-compiler-rt.o.c\n\t$(CC) $(CFLAGS_SAFE) $(CPPFLAGS) -O3 -Wno-unused-result -fPIC -c $< -o $@\n\n./afl-compiler-rt-32.o: instrumentation/afl-compiler-rt.o.c\n\t@printf \"[*] Building 32-bit variant of the runtime (-m32)... \"\n\t@$(CC) $(CFLAGS_SAFE) $(CPPFLAGS) -O3 -Wno-unused-result -m32 -fPIC -c $< -o $@ 2>/dev/null; if [ \"$$?\" = \"0\" ]; then echo \"success!\"; else echo \"failed (that's fine)\"; fi\n\n./afl-compiler-rt-64.o: instrumentation/afl-compiler-rt.o.c\n\t@printf \"[*] Building 64-bit variant of the runtime (-m64)... \"\n\t@$(CC) $(CFLAGS_SAFE) $(CPPFLAGS) -O3 -Wno-unused-result -m64 -fPIC -c $< -o $@ 2>/dev/null; if [ \"$$?\" = \"0\" ]; then echo \"success!\"; else echo \"failed (that's fine)\"; fi\n\n$(PASSES): instrumentation/afl-gcc-common.h\n\n./afl-gcc-pass.so: instrumentation/afl-gcc-pass.so.cc | test_deps\n\t$(CXX) $(CXXEFLAGS) $(PLUGIN_FLAGS) -shared $< -o $@\n\tln -sf afl-cc afl-gcc-fast\n\tln -sf afl-cc afl-g++-fast\n\tln -sf afl-cc.8 afl-gcc-fast.8\n\tln -sf afl-cc.8 afl-g++-fast.8\n\n./afl-gcc-cmplog-pass.so: instrumentation/afl-gcc-cmplog-pass.so.cc | test_deps\n\t$(CXX) $(CXXEFLAGS) $(PLUGIN_FLAGS) -shared $< -o $@\n\n./afl-gcc-cmptrs-pass.so: instrumentation/afl-gcc-cmptrs-pass.so.cc | test_deps\n\t$(CXX) $(CXXEFLAGS) $(PLUGIN_FLAGS) -shared $< -o $@\n\n.PHONY: test_build\ntest_build: $(PROGS)\n\t@echo \"[*] Testing the CC wrapper and instrumentation output...\"\n\tunset AFL_USE_ASAN AFL_USE_MSAN AFL_LLVM_ALLOWLIST AFL_LLVM_DENYLIST; ASAN_OPTIONS=detect_leaks=0 AFL_QUIET=1 AFL_INST_RATIO=100 AFL_PATH=. AFL_CC=$(CC) ./afl-gcc-fast $(CFLAGS) $(CPPFLAGS) ./test-instr.c -o test-instr $(LDFLAGS)\n\tASAN_OPTIONS=detect_leaks=0 ./afl-showmap -m none -q -o .test-instr0 ./test-instr </dev/null\n\techo 1 | ASAN_OPTIONS=detect_leaks=0 ./afl-showmap -m none -q -o .test-instr1 ./test-instr\n\t@rm -f test-instr\n\t@cmp -s .test-instr0 .test-instr1; DR=\"$$?\"; rm -f .test-instr0 .test-instr1; if [ \"$$DR\" = \"0\" ]; then echo; echo \"Oops, the instrumentation does not seem to be behaving correctly!\"; echo; echo \"Please post to https://github.com/AFLplusplus/AFLplusplus/issues to troubleshoot the issue.\"; echo; exit 1; fi\n\t@echo \"[+] All right, the instrumentation seems to be working!\"\n\n.PHONY: all_done\nall_done: test_build\n\t@echo \"[+] All done! You can now use './afl-gcc-fast' to compile programs.\"\n\n.NOTPARALLEL: clean\n\n%.8: %\n\t@echo .TH $* 8 `date \"+%Y-%m-%d\"` \"AFL++\" > ./$@\n\t@echo .SH NAME >> ./$@\n\t@echo .B $* >> ./$@\n\t@echo >> ./$@\n\t@echo .SH SYNOPSIS >> ./$@\n\t@./$* -h 2>&1 | head -n 3 | tail -n 1 | sed 's/^\\.\\///' >> ./$@\n\t@echo >> ./$@\n\t@echo .SH OPTIONS >> ./$@\n\t@echo .nf >> ./$@\n\t@./$* -h 2>&1 | tail -n +4 >> ./$@\n\t@echo >> ./$@\n\t@echo .SH AUTHOR >> ./$@\n\t@echo \"AFL++ was written by Michal \\\"lcamtuf\\\" Zalewski and is maintained by Marc \\\"van Hauser\\\" Heuse <mh@mh-sec.de>, Dominik Maier <domenukk@gmail.com>, Andrea Fioraldi <andreafioraldi@gmail.com> and Heiko \\\"hexcoder-\\\" Eissfeldt <heiko.eissfeldt@hexco.de>\" >> ./$@\n\t@echo  The homepage of AFL++ is: https://github.com/AFLplusplus/AFLplusplus >> ./$@\n\t@echo >> ./$@\n\t@echo .SH LICENSE >> ./$@\n\t@echo Apache License Version 2.0, January 2004 >> ./$@\n\tln -sf afl-cc.8 ./afl-g++-fast.8\n\n.PHONY: install\ninstall: all\n\tln -sf afl-cc $${DESTDIR}$(BIN_PATH)/afl-gcc-fast\n\tln -sf afl-c++ $${DESTDIR}$(BIN_PATH)/afl-g++-fast\n\tln -sf afl-compiler-rt.o $${DESTDIR}$(HELPER_PATH)/afl-gcc-rt.o\n\tinstall -m 755 ./afl-gcc-pass.so $${DESTDIR}$(HELPER_PATH)\n\tinstall -m 755 ./afl-gcc-cmplog-pass.so $${DESTDIR}$(HELPER_PATH)\n\tinstall -m 755 ./afl-gcc-cmptrs-pass.so $${DESTDIR}$(HELPER_PATH)\n\tinstall -m 644 -T instrumentation/README.gcc_plugin.md $${DESTDIR}$(DOC_PATH)/README.gcc_plugin.md\n\n.PHONY: clean\nclean:\n\trm -f *.o *.so *~ a.out core core.[1-9][0-9]* test-instr .test-instr0 .test-instr1 .test2\n\trm -f $(PROGS) afl-common.o ./afl-g++-fast ./afl-g*-fast.8 instrumentation/*.o\n"
        },
        {
          "name": "GNUmakefile.llvm",
          "type": "blob",
          "size": 25.6298828125,
          "content": "# american fuzzy lop++ - LLVM instrumentation\n# -----------------------------------------\n#\n# Written by Laszlo Szekeres <lszekeres@google.com> and\n#            Michal Zalewski\n#\n# LLVM integration design comes from Laszlo Szekeres.\n#\n# Copyright 2015, 2016 Google Inc. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at:\n#\n#   https://www.apache.org/licenses/LICENSE-2.0\n#\n\n# For Heiko:\n#TEST_MMAP=1\nHASH=\\#\n\nPREFIX      ?= /usr/local\nHELPER_PATH ?= $(PREFIX)/lib/afl\nBIN_PATH    ?= $(PREFIX)/bin\nDOC_PATH    ?= $(PREFIX)/share/doc/afl\nMISC_PATH   ?= $(PREFIX)/share/afl\nMAN_PATH    ?= $(PREFIX)/share/man/man8\n\nBUILD_DATE  ?= $(shell date -u -d \"@$(SOURCE_DATE_EPOCH)\" \"+%Y-%m-%d\" 2>/dev/null || date -u -r \"$(SOURCE_DATE_EPOCH)\" \"+%Y-%m-%d\" 2>/dev/null || date -u \"+%Y-%m-%d\")\n\nVERSION     = $(shell grep '^ *$(HASH)define VERSION ' ./config.h | cut -d '\"' -f2)\n\nSYS = $(shell uname -s)\n\noverride LLVM_TOO_NEW_DEFAULT := 19\noverride LLVM_TOO_OLD_DEFAULT := 13\n\nifeq \"$(SYS)\" \"OpenBSD\"\n  LLVM_CONFIG ?= $(BIN_PATH)/llvm-config\n  HAS_OPT = $(shell test -x $(BIN_PATH)/opt && echo 0 || echo 1)\n  ifeq \"$(HAS_OPT)\" \"1\"\n    $(warning llvm_mode needs a complete llvm installation (versions 6.0 up to 13) -> e.g. \"pkg_add llvm-7.0.1p9\")\n  endif\nelse\n  # Small function to use Bash to detect the latest available clang and clang++ binaries, if using them by that name fails\n  override _CLANG_VERSIONS_TO_TEST := $(patsubst %,-%,$(shell seq $(LLVM_TOO_NEW_DEFAULT) -1 $(LLVM_TOO_OLD_DEFAULT)))\n  detect_newest=$(shell for v in \"\" $(_CLANG_VERSIONS_TO_TEST); do test -n \"$$(command -v -- $1$$v)\" && { echo \"$1$$v\"; break; }; done)\n  LLVM_CONFIG ?= $(call detect_newest,llvm-config)\nendif\n\nifneq \"$(LLVM_CONFIG)\" \"\"\n  override LLVM_RAW_VER        := $(shell $(LLVM_CONFIG) --version 2>/dev/null)\n  LLVMVER                      := $(subst svn,,$(subst git,,$(LLVM_RAW_VER)))\n\n  LLVM_BINDIR                  := $(shell $(LLVM_CONFIG) --bindir 2>/dev/null)\n  LLVM_LIBDIR                  := $(shell $(LLVM_CONFIG) --libdir 2>/dev/null)\nendif\n\nifneq \"$(LLVMVER)\" \"\"\n  LLVM_MAJOR                   := $(firstword $(subst ., ,$(LLVMVER)))\n  LLVM_MINOR                   := $(firstword $(subst ., ,$(subst $(LLVM_MAJOR).,,$(LLVMVER))))\n  LLVM_TOO_NEW                 := $(shell test $(LLVM_MAJOR) -gt $(LLVM_TOO_NEW_DEFAULT) && echo 1 || echo 0)\n  LLVM_TOO_OLD                 := $(shell test $(LLVM_MAJOR) -lt $(LLVM_TOO_OLD_DEFAULT) && echo 1 || echo 0)\n  LLVM_NEW_API                 := $(shell test $(LLVM_MAJOR) -ge 10 && echo 1 || echo 0)\n  LLVM_NEWER_API               := $(shell test $(LLVM_MAJOR) -ge 16 && echo 1 || echo 0)\n  LLVM_13_OK                   := $(shell test $(LLVM_MAJOR) -ge 13 && echo 1 || echo 0)\n  LLVM_HAVE_LTO                := $(shell test $(LLVM_MAJOR) -ge 12 && echo 1 || echo 0)\nendif\n\nLLVM_STDCXX                  := gnu++11\nLLVM_LTO                     := 0\nLLVM_UNSUPPORTED             := $(shell echo \"$(LLVMVER)\" | grep -E -q '^[0-2]\\.|^3\\.[0-7]\\.|^2[0-9]\\.' && echo 1 || echo 0)\n# Uncomment to see the values assigned above\n# $(foreach var,_CLANG_VERSIONS_TO_TEST LLVM_CONFIG LLVMVER LLVM_MAJOR LLVM_MINOR LLVM_TOO_NEW LLVM_TOO_OLD LLVM_TOO_NEW_DEFAULT LLVM_TOO_OLD_DEFAULT LLVM_NEW_API LLVM_NEWER_API LLVM_13_OK LLVM_HAVE_LTO LLVM_BINDIR LLVM_LIBDIR LLVM_STDCXX LLVM_APPLE_XCODE LLVM_LTO LLVM_UNSUPPORTED,$(warning $(var) = $($(var))))\n\nifeq \"$(LLVMVER)\" \"\"\n  $(warning [!] llvm_mode needs llvm-config, which was not found. Set LLVM_CONFIG to its path and retry.)\nendif\n\nifeq \"$(LLVM_UNSUPPORTED)\" \"1\"\n  $(error llvm_mode only supports llvm from version 3.8 onwards)\nendif\n\nifeq \"$(LLVM_TOO_NEW)\" \"1\"\n  $(warning you are using an in-development llvm version - this might break llvm_mode!)\nendif\n\nifeq \"$(LLVM_TOO_OLD)\" \"1\"\n  $(warning you are using an outdated LLVM version! Please use at least LLVM 13 or newer!)\n  $(shell sleep 2)\nendif\n\n# No switching the meaning of LLVM_TOO_OLD\nLLVM_TOO_OLD=1\n\nifeq \"$(LLVM_MAJOR)\" \"9\"\n  $(info [+] llvm_mode detected llvm 9, enabling neverZero implementation)\n  LLVM_TOO_OLD=0\nendif\n\nifeq \"$(LLVM_NEW_API)\" \"1\"\n  $(info [+] llvm_mode detected llvm 10+, enabling neverZero implementation and c++14)\n  LLVM_STDCXX = c++14\n  LLVM_TOO_OLD=0\nendif\n\nifeq \"$(LLVM_NEWER_API)\" \"1\"\n  $(info [+] llvm_mode detected llvm 16+, enabling c++17)\n  LLVM_STDCXX = c++17\nendif\n\nifeq \"$(LLVM_HAVE_LTO)\" \"1\"\n  $(info [+] llvm_mode detected llvm 12+, enabling afl-lto LTO implementation)\n  LLVM_LTO = 1\nendif\n\nifeq \"$(LLVM_LTO)\" \"0\"\n  $(info [+] llvm_mode detected llvm < 12, afl-lto LTO will not be build.)\nendif\n\n# We were using llvm-config --bindir to get the location of clang, but\n# this seems to be busted on some distros, so using the one in $PATH is\n# probably better.\n\nCC         = $(LLVM_BINDIR)/clang\nCXX        = $(LLVM_BINDIR)/clang++\n\nLLVM_APPLE_XCODE             := $(shell $(CC) -v 2>&1 | grep -q Apple && echo 1 || echo 0)\nifeq \"$(LLVM_APPLE_XCODE)\" \"1\"\n  $(warning llvm_mode will not compile with Xcode clang...)\nendif\n\n# llvm-config --bindir may not providing a valid path, so ...\nifeq \"$(shell test -e $(CC) || echo 1 )\" \"1\"\n  # however we must ensure that this is not a \"CC=gcc make\"\n  ifeq \"$(shell command -v $(CC) 2> /dev/null)\" \"\"\n    # we do not have a valid CC variable so we try alternatives\n    ifeq \"$(shell test -e '$(BIN_DIR)/clang' && echo 1)\" \"1\"\n      # we found one in the local install directory, lets use these\n      CC         = $(BIN_DIR)/clang\n    else\n      # hope for the best\n      $(warning we have trouble finding clang - llvm-config is not helping us)\n      CC         = clang\n    endif\n  endif\nendif\n# llvm-config --bindir may not providing a valid path, so ...\nifeq \"$(shell test -e $(CXX) || echo 1 )\" \"1\"\n  # however we must ensure that this is not a \"CXX=g++ make\"\n  ifeq \"$(shell command -v $(CXX) 2> /dev/null)\" \"\"\n    # we do not have a valid CXX variable so we try alternatives\n    ifeq \"$(shell test -e '$(BIN_DIR)/clang++' && echo 1)\" \"1\"\n      # we found one in the local install directory, lets use these\n      CXX        = $(BIN_DIR)/clang++\n    else\n      # hope for the best\n      $(warning we have trouble finding clang++ - llvm-config is not helping us)\n      CXX        = clang++\n    endif\n  endif\nendif\n\n# sanity check.\n# Are versions of clang --version and llvm-config --version equal?\nCLANGVER = $(shell $(CC) --version | sed -E -ne '/^.*version\\ ([12]?[0-9]\\.[0-9]\\.[0-9]).*/s//\\1/p')\n\n# I disable this because it does not make sense with what we did before (marc)\n# We did exactly set these 26 lines above with these values, and it would break\n# \"CC=gcc make\" etc. usages\nifeq \"$(findstring clang, $(shell $(CC) --version 2>/dev/null))\" \"\"\n  CC_SAVE := $(LLVM_BINDIR)/clang\nelse\n  CC_SAVE := $(CC)\nendif\nifeq \"$(findstring clang, $(shell $(CXX) --version 2>/dev/null))\" \"\"\n  CXX_SAVE := $(LLVM_BINDIR)/clang++\nelse\n  CXX_SAVE := $(CXX)\nendif\n\nCLANG_BIN := $(CC_SAVE)\nCLANGPP_BIN := $(CXX_SAVE)\n\nifeq \"$(CC_SAVE)\" \"$(LLVM_BINDIR)/clang\"\n  USE_BINDIR = 1\nelse\n  ifeq \"$(CXX_SAVE)\" \"$(LLVM_BINDIR)/clang++\"\n    USE_BINDIR = 1\n  else\n    USE_BINDIR = 0\n  endif\nendif\n\n# On old platform we cannot compile with clang because std++ libraries are too\n# old. For these we need to use gcc/g++, so if we find REAL_CC and REAL_CXX\n# variable we override the compiler variables here\nifneq \"$(REAL_CC)\" \"\"\n  CC  = $(REAL_CC)\nendif\nifneq \"$(REAL_CXX)\" \"\"\n  CXX = $(REAL_CXX)\nendif\n\n#\n# Now it can happen that CC points to clang - but there is no clang on the\n# system. Then we fall back to cc\n#\nifeq \"$(shell command -v $(CC) 2>/dev/null)\" \"\"\n  CC = cc\nendif\nifeq \"$(shell command -v $(CXX) 2>/dev/null)\" \"\"\n  CXX = c++\nendif\n\n\n# After we set CC/CXX we can start makefile magic tests\n\n#ifeq \"$(shell echo 'int main() {return 0; }' | $(CC) -x c - -march=native -o .test 2>/dev/null && echo 1 || echo 0 ; rm -f .test )\" \"1\"\n#\tCFLAGS_OPT = -march=native\n#endif\n\nifeq \"$(shell echo 'int main() {return 0; }' | $(CLANG_BIN) -x c - -flto=full -o .test 2>/dev/null && echo 1 || echo 0 ; rm -f .test )\" \"1\"\n        AFL_CLANG_FLTO ?= -flto=full\nelse\n ifeq \"$(shell echo 'int main() {return 0; }' | $(CLANG_BIN) -x c - -flto=thin -o .test 2>/dev/null && echo 1 || echo 0 ; rm -f .test )\" \"1\"\n        AFL_CLANG_FLTO ?= -flto=thin\n else\n  ifeq \"$(shell echo 'int main() {return 0; }' | $(CLANG_BIN) -x c - -flto -o .test 2>/dev/null && echo 1 || echo 0 ; rm -f .test )\" \"1\"\n        AFL_CLANG_FLTO ?= -flto\n  endif\n endif\nendif\n\nifeq \"$(LLVM_LTO)\" \"1\"\n  ifneq \"$(AFL_CLANG_FLTO)\" \"\"\n    ifeq \"$(AFL_REAL_LD)\" \"\"\n      ifneq \"$(shell readlink $(LLVM_BINDIR)/ld.lld 2>&1)\" \"\"\n        AFL_REAL_LD = $(LLVM_BINDIR)/ld.lld\n      else ifneq \"$(shell command -v ld.lld 2>/dev/null)\" \"\"\n        AFL_REAL_LD = $(shell command -v ld.lld)\n        TMP_LDLDD_VERSION = $(shell $(AFL_REAL_LD) --version | awk '{ print $$2 }')\n        ifeq \"$(LLVMVER)\" \"$(TMP_LDLDD_VERSION)\"\n          $(warning ld.lld found in a weird location ($(AFL_REAL_LD)), but its the same version as LLVM so we will allow it)\n        else\n          $(warning ld.lld found in a weird location ($(AFL_REAL_LD)) and its of a different version than LLMV ($(TMP_LDLDD_VERSION) vs. $(LLVMVER)) - cannot enable LTO mode)\n          AFL_REAL_LD=\n          LLVM_LTO = 0\n        endif\n        undefine TMP_LDLDD_VERSION\n      else\n        $(warning ld.lld not found, cannot enable LTO mode)\n        LLVM_LTO = 0\n      endif\n    endif\n  else\n    $(warning clang option -flto is not working - maybe LLVMgold.so not found - cannot enable LTO mode)\n    LLVM_LTO = 0\n  endif\nendif\n\nAFL_CLANG_FUSELD=\nifeq \"$(LLVM_LTO)\" \"1\"\n  ifeq \"$(shell echo 'int main() {return 0; }' | $(CLANG_BIN) -x c - -fuse-ld=$$(command -v ld) -o .test 2>/dev/null && echo 1 || echo 0 ; rm -f .test )\" \"1\"\n    AFL_CLANG_FUSELD=1\n    ifeq \"$(shell echo 'int main() {return 0; }' | $(CLANG_BIN) -x c - -fuse-ld=ld.lld --ld-path=$(AFL_REAL_LD) -o .test 2>/dev/null && echo 1 || echo 0 ; rm -f .test )\" \"1\"\n      AFL_CLANG_LDPATH=1\n    endif\n  else\n    $(warning -fuse-ld is not working, cannot enable LTO mode)\n    LLVM_LTO = 0\n  endif\nendif\n\nifeq \"$(shell echo 'int main() {return 0; }' | $(CLANG_BIN) -x c - -fdebug-prefix-map=$(CURDIR)=llvm_mode -o .test 2>/dev/null && echo 1 || echo 0 ; rm -f .test )\" \"1\"\n        AFL_CLANG_DEBUG_PREFIX = -fdebug-prefix-map=\"$(CURDIR)=llvm_mode\"\nelse\n        AFL_CLANG_DEBUG_PREFIX =\nendif\n\nCFLAGS          ?= -O3 -funroll-loops -fPIC\n# -D_FORTIFY_SOURCE=1\nCFLAGS_SAFE     := -Wall -g -Wno-cast-qual -Wno-variadic-macros -Wno-pointer-sign \\\n                   -I ./include/ -I ./instrumentation/ \\\n                   -DAFL_PATH=\\\"$(HELPER_PATH)\\\" -DBIN_PATH=\\\"$(BIN_PATH)\\\" \\\n                   -DLLVM_BINDIR=\\\"$(LLVM_BINDIR)\\\" -DVERSION=\\\"$(VERSION)\\\" \\\n                   -DLLVM_LIBDIR=\\\"$(LLVM_LIBDIR)\\\" -DLLVM_VERSION=\\\"$(LLVMVER)\\\" \\\n                   -DAFL_CLANG_FLTO=\\\"$(AFL_CLANG_FLTO)\\\" -DAFL_REAL_LD=\\\"$(AFL_REAL_LD)\\\" \\\n                   -DAFL_CLANG_LDPATH=\\\"$(AFL_CLANG_LDPATH)\\\" -DAFL_CLANG_FUSELD=\\\"$(AFL_CLANG_FUSELD)\\\" \\\n                   -DCLANG_BIN=\\\"$(CLANG_BIN)\\\" -DCLANGPP_BIN=\\\"$(CLANGPP_BIN)\\\" -DUSE_BINDIR=$(USE_BINDIR) \\\n                   -Wno-unused-function $(AFL_CLANG_DEBUG_PREFIX)\nifndef LLVM_DEBUG\n  CFLAGS_SAFE += -Wno-deprecated\nendif\n\nifdef CODE_COVERAGE\n  override CFLAGS_SAFE += -D__AFL_CODE_COVERAGE=1\n  override LDFLAGS += -ldl\nendif\n\noverride CFLAGS += $(CFLAGS_SAFE)\n\nifdef AFL_TRACE_PC\n  $(info Compile option AFL_TRACE_PC is deprecated, just set AFL_LLVM_INSTRUMENT=PCGUARD to activate when compiling targets )\nendif\n\nCXXFLAGS          ?= -O3 -funroll-loops -fPIC\n# -D_FORTIFY_SOURCE=1\noverride CXXFLAGS += -Wall -g -I ./include/ \\\n                     -DVERSION=\\\"$(VERSION)\\\" -Wno-variadic-macros -Wno-deprecated-copy-with-dtor \\\n                     -DLLVM_MINOR=$(LLVM_MINOR) -DLLVM_MAJOR=$(LLVM_MAJOR)\n\nifneq \"$(shell $(LLVM_CONFIG) --includedir) 2> /dev/null\" \"\"\n  CLANG_CFL  = -I$(shell $(LLVM_CONFIG) --includedir)\nendif\nifneq \"$(LLVM_CONFIG)\" \"\"\n  CLANG_CFL += -I$(shell dirname $(LLVM_CONFIG))/../include\nendif\nCLANG_CPPFL  = $$($(LLVM_CONFIG) --cxxflags) -fno-rtti -fno-exceptions -fPIC $(CXXFLAGS) $(CPPFLAGS) -Wno-deprecated-declarations\nCLANG_LFL    = $$($(LLVM_CONFIG) --ldflags) $(LDFLAGS)\n\n# wasm fuzzing: disable thread-local storage and unset LLVM debug flag\nifdef WAFL_MODE\n  $(info Compiling libraries for use with WAVM)\n  CLANG_CPPFL += -DNDEBUG -DNO_TLS\nendif\n\n# User teor2345 reports that this is required to make things work on MacOS X.\nifeq \"$(SYS)\" \"Darwin\"\n  CLANG_LFL += -Wl,-undefined,dynamic_lookup\n  override LLVM_HAVE_LTO := 0\n  override LLVM_LTO := 0\nelse\n  CLANG_CPPFL += -Wl,-znodelete\nendif\n\nifeq \"$(SYS)\" \"OpenBSD\"\n  CLANG_LFL += $(LLVM_LIBDIR)/libLLVM.so\n  CLANG_CPPFL += -mno-retpoline\n  CFLAGS += -mno-retpoline\n  # Needed for unwind symbols\n  LDFLAGS += -lc++abi -lpthread\nendif\n\nifeq \"$(shell echo '$(HASH)include <sys/ipc.h>@$(HASH)include <sys/shm.h>@int main() { int _id = shmget(IPC_PRIVATE, 65536, IPC_CREAT | IPC_EXCL | 0600); shmctl(_id, IPC_RMID, 0); return 0;}' | tr @ '\\n' | $(CC) -x c - -o .test2 2>/dev/null && echo 1 || echo 0 ; rm -f .test2 )\" \"1\"\n        SHMAT_OK=1\nelse\n        SHMAT_OK=0\n        CFLAGS_SAFE += -DUSEMMAP=1\n        LDFLAGS += -Wno-deprecated-declarations\nendif\n\nifeq \"$(TEST_MMAP)\" \"1\"\n        SHMAT_OK=0\n        CFLAGS_SAFE += -DUSEMMAP=1\n        LDFLAGS += -Wno-deprecated-declarations\nendif\n\nPROGS_ALWAYS = ./afl-cc ./afl-compiler-rt.o ./afl-compiler-rt-32.o ./afl-compiler-rt-64.o \nPROGS        = $(PROGS_ALWAYS) ./afl-llvm-pass.so ./SanitizerCoveragePCGUARD.so ./split-compares-pass.so ./split-switches-pass.so ./cmplog-routines-pass.so ./cmplog-instructions-pass.so ./cmplog-switches-pass.so ./afl-llvm-dict2file.so ./compare-transform-pass.so ./afl-ld-lto ./afl-llvm-lto-instrumentlist.so ./SanitizerCoverageLTO.so ./injection-pass.so\n\n# If prerequisites are not given, warn, do not build anything, and exit with code 0\nifeq \"$(LLVMVER)\" \"\"\n  NO_BUILD = 1\nendif\n\nifneq \"$(LLVM_UNSUPPORTED)$(LLVM_APPLE_XCODE)\" \"00\"\n  NO_BUILD = 1\nendif\n\nifeq \"$(NO_BUILD)\" \"1\"\n  TARGETS = test_shm $(PROGS_ALWAYS) afl-cc.8\nelse\n  TARGETS = test_shm test_deps $(PROGS) afl-cc.8 test_build all_done\nendif\n\nLLVM_MIN_4_0_1 = $(shell awk 'function tonum(ver, a) {split(ver,a,\".\"); return a[1]*1000000+a[2]*1000+a[3]} BEGIN { exit tonum(ARGV[1]) >= tonum(ARGV[2]) }' $(LLVMVER) 4.0.1; echo $$?)\n\n.PHONY: all\nall: $(TARGETS)\n\n.PHONY: test_shm\nifeq \"$(SHMAT_OK)\" \"1\"\ntest_shm:\n\t@echo \"[+] shmat seems to be working.\"\n\t@rm -f .test2\nelse\ntest_shm:\n\t@echo \"[-] shmat seems not to be working, switching to mmap implementation\"\nendif\n\n.PHONY: no_build\nno_build:\n\t@printf \"%b\\\\n\" \"\\\\033[0;31mPrerequisites are not met, skipping build llvm_mode\\\\033[0m\"\n\n.PHONY: test_deps\ntest_deps:\n\t@echo \"[*] Checking for working 'llvm-config'...\"\n ifneq \"$(LLVM_APPLE_XCODE)\" \"1\"\n\t@type $(LLVM_CONFIG) >/dev/null 2>&1 || ( echo \"[-] Oops, can't find 'llvm-config'. Install clang or set \\$$LLVM_CONFIG or \\$$PATH beforehand.\"; echo \"    (Sometimes, the binary will be named llvm-config-11 or something like that.)\"; exit 1 )\n endif\n\t@echo \"[*] Checking for working '$(CC)'...\"\n\t@type $(CC) >/dev/null 2>&1 || ( echo \"[-] Oops, can't find '$(CC)'. Make sure that it's in your \\$$PATH (or set \\$$CC and \\$$CXX).\"; exit 1 )\n\t@echo \"[*] Checking for matching versions of '$(CC)' and '$(LLVM_CONFIG)'\"\nifneq \"$(CLANGVER)\" \"$(LLVMVER)\"\n\t@echo \"[!] WARNING: we have llvm-config version $(LLVMVER) and a clang version $(CLANGVER)\"\nelse\n\t@echo \"[*] We have llvm-config version $(LLVMVER) with a clang version $(CLANGVER), good.\"\nendif\n\t@echo \"[*] Checking for './afl-showmap'...\"\n\t@test -f ./afl-showmap || ( echo \"[-] Oops, can't find './afl-showmap'. Be sure to compile AFL first.\"; exit 1 )\n\t@echo \"[+] All set and ready to build.\"\n\ninstrumentation/afl-common.o: ./src/afl-common.c\n\t$(CC) $(CFLAGS) $(CPPFLAGS) -c $< -o $@ $(LDFLAGS)\n\n./afl-cc: src/afl-cc.c instrumentation/afl-common.o\n\t$(CC) $(CLANG_CFL) $(CFLAGS) $(CPPFLAGS) $< instrumentation/afl-common.o -o $@ -DLLVM_MINOR=$(LLVM_MINOR) -DLLVM_MAJOR=$(LLVM_MAJOR) $(LDFLAGS) -DCFLAGS_OPT=\\\"$(CFLAGS_OPT)\\\" -lm\n\t@ln -sf afl-cc ./afl-c++\n\t@ln -sf afl-cc ./afl-gcc\n\t@ln -sf afl-cc ./afl-g++\n\t@ln -sf afl-cc ./afl-clang\n\t@ln -sf afl-cc ./afl-clang++\n\t@ln -sf afl-cc ./afl-clang-fast\n\t@ln -sf afl-cc ./afl-clang-fast++\nifneq \"$(AFL_CLANG_FLTO)\" \"\"\nifeq \"$(LLVM_LTO)\" \"1\"\n\t@ln -sf afl-cc ./afl-clang-lto\n\t@ln -sf afl-cc ./afl-clang-lto++\n\t@ln -sf afl-cc ./afl-lto\n\t@ln -sf afl-cc ./afl-lto++\nendif\nendif\n\ninstrumentation/afl-llvm-common.o: instrumentation/afl-llvm-common.cc instrumentation/afl-llvm-common.h\n\t$(CXX) $(CFLAGS) $(CPPFLAGS) $$($(LLVM_CONFIG) --cxxflags) -fno-rtti -fPIC -std=$(LLVM_STDCXX) -c $< -o $@ \n\n./afl-llvm-pass.so: instrumentation/afl-llvm-pass.so.cc instrumentation/afl-llvm-common.o | test_deps\nifeq \"$(LLVM_MIN_4_0_1)\" \"0\"\n\t$(info [!] N-gram branch coverage instrumentation is not available for llvm version $(LLVMVER))\nendif\n\t$(CXX) $(CLANG_CPPFL) -Wdeprecated -fno-rtti -fPIC -std=$(LLVM_STDCXX) -shared $< -o $@ $(CLANG_LFL) instrumentation/afl-llvm-common.o\n\n./SanitizerCoveragePCGUARD.so: instrumentation/SanitizerCoveragePCGUARD.so.cc instrumentation/afl-llvm-common.o | test_deps\nifeq \"$(LLVM_13_OK)\" \"1\"\n\t-$(CXX) $(CLANG_CPPFL) -fno-rtti -fPIC -std=$(LLVM_STDCXX) -shared $< -o $@ $(CLANG_LFL) -Wno-deprecated-copy-dtor -Wdeprecated instrumentation/afl-llvm-common.o\nendif\n\n./afl-llvm-lto-instrumentlist.so: instrumentation/afl-llvm-lto-instrumentlist.so.cc instrumentation/afl-llvm-common.o\nifeq \"$(LLVM_LTO)\" \"1\"\n\t$(CXX) $(CLANG_CPPFL) -fno-rtti -fPIC -std=$(LLVM_STDCXX) -shared $< -o $@ $(CLANG_LFL) instrumentation/afl-llvm-common.o\nendif\n\n./afl-ld-lto: src/afl-ld-lto.c\nifeq \"$(LLVM_LTO)\" \"1\"\n\t$(CC) $(CFLAGS) $(CPPFLAGS) $< -o $@\nendif\n\n./SanitizerCoverageLTO.so: instrumentation/SanitizerCoverageLTO.so.cc instrumentation/afl-llvm-common.o\nifeq \"$(LLVM_LTO)\" \"1\"\n\t$(CXX) $(CLANG_CPPFL) -Wno-writable-strings -fno-rtti -fPIC -std=$(LLVM_STDCXX) -shared $< -o $@ $(CLANG_LFL) instrumentation/afl-llvm-common.o\n\t$(CLANG_BIN) $(CFLAGS_SAFE) $(CPPFLAGS) -Wno-unused-result -O0 $(AFL_CLANG_FLTO) -fPIC -c instrumentation/afl-llvm-rt-lto.o.c -o ./afl-llvm-rt-lto.o\n\t@$(CLANG_BIN) $(CFLAGS_SAFE) $(CPPFLAGS) -Wno-unused-result -O0 $(AFL_CLANG_FLTO) -m64 -fPIC -c instrumentation/afl-llvm-rt-lto.o.c -o ./afl-llvm-rt-lto-64.o 2>/dev/null; if [ \"$$?\" = \"0\" ]; then : ; fi\n\t@$(CLANG_BIN) $(CFLAGS_SAFE) $(CPPFLAGS) -Wno-unused-result -O0 $(AFL_CLANG_FLTO) -m32 -fPIC -c instrumentation/afl-llvm-rt-lto.o.c -o ./afl-llvm-rt-lto-32.o 2>/dev/null; if [ \"$$?\" = \"0\" ]; then : ; fi\nendif\n\n# laf\n./split-switches-pass.so:\tinstrumentation/split-switches-pass.so.cc instrumentation/afl-llvm-common.o | test_deps\n\t$(CXX) $(CLANG_CPPFL) -shared $< -o $@ $(CLANG_LFL) instrumentation/afl-llvm-common.o\n./compare-transform-pass.so:\tinstrumentation/compare-transform-pass.so.cc instrumentation/afl-llvm-common.o | test_deps\n\t$(CXX) $(CLANG_CPPFL) -shared $< -o $@ $(CLANG_LFL) instrumentation/afl-llvm-common.o\n./split-compares-pass.so:\tinstrumentation/split-compares-pass.so.cc instrumentation/afl-llvm-common.o | test_deps\n\t$(CXX) $(CLANG_CPPFL) -shared $< -o $@ $(CLANG_LFL) instrumentation/afl-llvm-common.o\n# /laf\n\n./cmplog-routines-pass.so:\tinstrumentation/cmplog-routines-pass.cc instrumentation/afl-llvm-common.o | test_deps\n\t$(CXX) $(CLANG_CPPFL) -shared $< -o $@ $(CLANG_LFL) instrumentation/afl-llvm-common.o\n\n./cmplog-instructions-pass.so:\tinstrumentation/cmplog-instructions-pass.cc instrumentation/afl-llvm-common.o | test_deps\n\t$(CXX) $(CLANG_CPPFL) -shared $< -o $@ $(CLANG_LFL) instrumentation/afl-llvm-common.o\n\n./cmplog-switches-pass.so:\tinstrumentation/cmplog-switches-pass.cc instrumentation/afl-llvm-common.o | test_deps\n\t$(CXX) $(CLANG_CPPFL) -shared $< -o $@ $(CLANG_LFL) instrumentation/afl-llvm-common.o\n\nafl-llvm-dict2file.so:\tinstrumentation/afl-llvm-dict2file.so.cc instrumentation/afl-llvm-common.o | test_deps\n\t$(CXX) $(CLANG_CPPFL) -shared $< -o $@ $(CLANG_LFL) instrumentation/afl-llvm-common.o\n\n./injection-pass.so:\tinstrumentation/injection-pass.cc instrumentation/afl-llvm-common.o | test_deps\n\t$(CXX) $(CLANG_CPPFL) -shared $< -o $@ $(CLANG_LFL) instrumentation/afl-llvm-common.o\n\n.PHONY: document\ndocument:\n\t$(CLANG_BIN) -D_AFL_DOCUMENT_MUTATIONS $(CFLAGS_SAFE) $(CPPFLAGS) $(CLANG_CFL) -O3 -Wno-unused-result -fPIC -c instrumentation/afl-compiler-rt.o.c -o ./afl-compiler-rt.o\n\t@$(CLANG_BIN) -D_AFL_DOCUMENT_MUTATIONS $(CFLAGS_SAFE) $(CPPFLAGS) $(CLANG_CFL) -O3 -Wno-unused-result -m32 -fPIC -c instrumentation/afl-compiler-rt.o.c -o ./afl-compiler-rt-32.o 2>/dev/null; if [ \"$$?\" = \"0\" ]; then echo \"success!\"; else echo \"failed (that's fine)\"; fi\n\t@$(CLANG_BIN) -D_AFL_DOCUMENT_MUTATIONS $(CFLAGS_SAFE) $(CPPFLAGS) $(CLANG_CFL) -O3 -Wno-unused-result -m64 -fPIC -c instrumentation/afl-compiler-rt.o.c -o ./afl-compiler-rt-64.o 2>/dev/null; if [ \"$$?\" = \"0\" ]; then echo \"success!\"; else echo \"failed (that's fine)\"; fi\n\n./afl-compiler-rt.o: instrumentation/afl-compiler-rt.o.c\n\t$(CC) $(CLANG_CFL) $(CFLAGS_SAFE) $(CPPFLAGS) -O3 -Wno-unused-result -fPIC -c $< -o $@\n\n./afl-compiler-rt-32.o: instrumentation/afl-compiler-rt.o.c\n\t@printf \"[*] Building 32-bit variant of the runtime (-m32)... \"\n\t@$(CC) $(CLANG_CFL) $(CFLAGS_SAFE) $(CPPFLAGS) -O3 -Wno-unused-result -m32 -fPIC -c $< -o $@ 2>/dev/null; if [ \"$$?\" = \"0\" ]; then echo \"success!\"; else echo \"failed (that's fine)\"; fi\n\n./afl-compiler-rt-64.o: instrumentation/afl-compiler-rt.o.c\n\t@printf \"[*] Building 64-bit variant of the runtime (-m64)... \"\n\t@$(CC) $(CLANG_CFL) $(CFLAGS_SAFE) $(CPPFLAGS) -O3 -Wno-unused-result -m64 -fPIC -c $< -o $@ 2>/dev/null; if [ \"$$?\" = \"0\" ]; then echo \"success!\"; else echo \"failed (that's fine)\"; fi\n\n.PHONY: test_build\ntest_build: $(PROGS)\n\t@echo \"[*] Testing the CC wrapper and instrumentation output...\"\n\tunset AFL_USE_ASAN AFL_USE_MSAN AFL_INST_RATIO AFL_LLVM_ALLOWLIST AFL_LLVM_DENYLIST; ASAN_OPTIONS=detect_leaks=0 AFL_QUIET=1 AFL_PATH=. AFL_LLVM_LAF_ALL=1 ./afl-cc $(CFLAGS) $(CPPFLAGS) ./test-instr.c -o test-instr $(LDFLAGS)\n\tASAN_OPTIONS=detect_leaks=0 ./afl-showmap -m none -q -o .test-instr0 ./test-instr < /dev/null\n\techo 1 | ASAN_OPTIONS=detect_leaks=0 ./afl-showmap -m none -q -o .test-instr1 ./test-instr\n\t@rm -f test-instr\n\t@cmp -s .test-instr0 .test-instr1; DR=\"$$?\"; rm -f .test-instr0 .test-instr1; if [ \"$$DR\" = \"0\" ]; then echo; echo \"Oops, the instrumentation does not seem to be behaving correctly!\"; echo; echo \"Please post to https://github.com/AFLplusplus/AFLplusplus/issues to troubleshoot the issue.\"; echo; exit 1; fi\n\t@echo \"[+] All right, the instrumentation seems to be working!\"\n\n.PHONY: all_done\nall_done: test_build\n\t@echo \"[+] All done! You can now use './afl-cc' to compile programs.\"\n\n.NOTPARALLEL: clean\n\n.PHONY: install\ninstall: all\n\t@install -d -m 755 $${DESTDIR}$(BIN_PATH) $${DESTDIR}$(HELPER_PATH) $${DESTDIR}$(DOC_PATH) $${DESTDIR}$(MISC_PATH)\n\t@if [ -f ./afl-cc ]; then set -e; install -m 755 ./afl-cc $${DESTDIR}$(BIN_PATH); ln -sf afl-cc $${DESTDIR}$(BIN_PATH)/afl-c++; fi\n\t@rm -f $${DESTDIR}$(HELPER_PATH)/afl-llvm-rt*.o $${DESTDIR}$(HELPER_PATH)/afl-gcc-rt*.o\n\t@if [ -f ./afl-compiler-rt.o ]; then set -e; install -m 755 ./afl-compiler-rt.o $${DESTDIR}$(HELPER_PATH); fi\n\t@if [ -f ./afl-lto ]; then set -e; ln -sf afl-cc $${DESTDIR}$(BIN_PATH)/afl-lto; ln -sf afl-cc $${DESTDIR}$(BIN_PATH)/afl-lto++; ln -sf afl-cc $${DESTDIR}$(BIN_PATH)/afl-clang-lto; ln -sf afl-cc $${DESTDIR}$(BIN_PATH)/afl-clang-lto++; install -m 755 ./afl-llvm-rt-lto*.o ./afl-llvm-lto-instrumentlist.so $${DESTDIR}$(HELPER_PATH); fi\n\t@if [ -f ./afl-ld-lto ]; then set -e; install -m 755 ./afl-ld-lto $${DESTDIR}$(BIN_PATH); fi\n\t@if [ -f ./afl-compiler-rt-32.o ]; then set -e; install -m 755 ./afl-compiler-rt-32.o $${DESTDIR}$(HELPER_PATH); fi\n\t@if [ -f ./afl-compiler-rt-64.o ]; then set -e; install -m 755 ./afl-compiler-rt-64.o $${DESTDIR}$(HELPER_PATH); fi\n\t@if [ -f ./compare-transform-pass.so ]; then set -e; install -m 755 ./*.so $${DESTDIR}$(HELPER_PATH); fi\n\t@if [ -f ./compare-transform-pass.so ]; then set -e; ln -sf afl-cc $${DESTDIR}$(BIN_PATH)/afl-clang-fast ; ln -sf ./afl-c++ $${DESTDIR}$(BIN_PATH)/afl-clang-fast++ ; ln -sf afl-cc $${DESTDIR}$(BIN_PATH)/afl-clang ; ln -sf ./afl-c++ $${DESTDIR}$(BIN_PATH)/afl-clang++ ; fi\n\t@if [ -f ./SanitizerCoverageLTO.so ]; then set -e; ln -sf afl-cc $${DESTDIR}$(BIN_PATH)/afl-clang-lto ; ln -sf ./afl-c++ $${DESTDIR}$(BIN_PATH)/afl-clang-lto++ ; fi\n\tset -e; install -m 644 ./dynamic_list.txt $${DESTDIR}$(HELPER_PATH)\n\tinstall -m 644 instrumentation/README.*.md $${DESTDIR}$(DOC_PATH)/\n\n%.8: %\n\t@echo .TH $* 8 $(BUILD_DATE) \"AFL++\" > ./$@\n\t@echo .SH NAME >> ./$@\n\t@printf \"%s\" \".B $* \\- \" >> ./$@\n\t@./$* -h 2>&1 | head -n 1 | sed -e \"s/$$(printf '\\e')[^m]*m//g\" >> ./$@\n\t@echo .B $* >> ./$@\n\t@echo >> ./$@\n\t@echo .SH SYNOPSIS >> ./$@\n\t@./$* -h 2>&1 | head -n 3 | tail -n 1 | sed 's/^\\.\\///' >> ./$@\n\t@echo >> ./$@\n\t@echo .SH OPTIONS >> ./$@\n\t@echo .nf >> ./$@\n\t@./$* -h 2>&1 | tail -n +4 >> ./$@\n\t@echo >> ./$@\n\t@echo .SH AUTHOR >> ./$@\n\t@echo \"AFL++ was written by Michal \\\"lcamtuf\\\" Zalewski and is maintained by Marc \\\"van Hauser\\\" Heuse <mh@mh-sec.de>, Dominik Maier <domenukk@gmail.com>, Andrea Fioraldi <andreafioraldi@gmail.com> and Heiko \\\"hexcoder-\\\" Eissfeldt <heiko.eissfeldt@hexco.de>\" >> ./$@\n\t@echo  The homepage of AFL++ is: https://github.com/AFLplusplus/AFLplusplus >> ./$@\n\t@echo >> ./$@\n\t@echo .SH LICENSE >> ./$@\n\t@echo Apache License Version 2.0, January 2004 >> ./$@\n\t@ln -sf afl-cc.8 ./afl-c++.8\n\t@ln -sf afl-cc.8 ./afl-clang-fast.8\n\t@ln -sf afl-cc.8 ./afl-clang-fast++.8\nifneq \"$(AFL_CLANG_FLTO)\" \"\"\nifeq \"$(LLVM_LTO)\" \"1\"\n\t@ln -sf afl-cc.8 ./afl-clang-lto.8\n\t@ln -sf afl-cc.8 ./afl-clang-lto++.8\n\t@ln -sf afl-cc.8 ./afl-lto.8\n\t@ln -sf afl-cc.8 ./afl-lto++.8\nendif\nendif\n\n.PHONY: clean\nclean:\n\trm -f *.o *.so *~ a.out core core.[1-9][0-9]* .test2 test-instr .test-instr0 .test-instr1 *.dwo\n\trm -f $(PROGS) afl-common.o ./afl-c++ ./afl-lto ./afl-lto++ ./afl-clang-lto* ./afl-clang-fast* ./afl-clang*.8 ./ld ./afl-ld ./afl-compiler-rt*.o ./afl-llvm-rt*.o instrumentation/*.o\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.0908203125,
          "content": "                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright [yyyy] [name of copyright owner]\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.4169921875,
          "content": "all:\n\t@echo trying to use GNU make...\n\t@gmake all || echo please install GNUmake\n\nsource-only:\n\t@gmake source-only\n\nbinary-only:\n\t@gmake binary-only\n\ndistrib:\n\t@gmake distrib\n\nman:\n\t@gmake man\n\ninstall:\n\t@gmake install\n\ndocument:\n\t@gmake document\n\ndeepclean:\n\t@gmake deepclean\n\ncode-format:\n\t@gmake code-format\n\nhelp:\n\t@gmake help\n\ntests:\n\t@gmake tests\n\nunit:\n\t@gmake unit\n\nunit_clean:\n\t@gmake unit_clean\n\nclean:\n\t@gmake clean\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 10.5947265625,
          "content": "# American Fuzzy Lop plus plus (AFL++)\n\n<img align=\"right\" src=\"https://raw.githubusercontent.com/AFLplusplus/Website/main/static/aflpp_bg.svg\" alt=\"AFL++ logo\" width=\"250\" height=\"250\">\n\nRelease version: [4.30c](https://github.com/AFLplusplus/AFLplusplus/releases)\n\nGitHub version: 4.31a\n\nRepository:\n[https://github.com/AFLplusplus/AFLplusplus](https://github.com/AFLplusplus/AFLplusplus)\n\nAFL++ is maintained by:\n\n* Marc \"van Hauser\" Heuse <mh@mh-sec.de>\n* Dominik Maier <mail@dmnk.co>\n* Andrea Fioraldi <andreafioraldi@gmail.com>\n* Heiko \"hexcoder-\" Eissfeldt <heiko.eissfeldt@hexco.de>\n* frida_mode is maintained by @Worksbutnottested\n* Documentation: Jana Aydinbas <jana.aydinbas@gmail.com>\n\nOriginally developed by Michal \"lcamtuf\" Zalewski.\n\nAFL++ is a superior fork to Google's AFL - more speed, more and better\nmutations, more and better instrumentation, custom module support, etc.\n\nYou are free to copy, modify, and distribute AFL++ with attribution under the\nterms of the Apache-2.0 License. See the [LICENSE](LICENSE) for details.\n\n## Getting started\n\nHere is some information to get you started:\n\n* For an overview of the AFL++ documentation and a very helpful graphical guide,\n  please visit [docs/README.md](docs/README.md).\n* To get you started with tutorials, go to\n  [docs/tutorials.md](docs/tutorials.md).\n* For releases, see the\n  [Releases tab](https://github.com/AFLplusplus/AFLplusplus/releases) and\n  [branches](#branches). The best branches to use are, however, `stable` or\n  `dev` - depending on your risk appetite. Also take a look at the list of\n  [important changes in AFL++](docs/important_changes.md) and the list of\n  [features](docs/features.md).\n* If you want to use AFL++ for your academic work, check the\n  [papers page](https://aflplus.plus/papers/) on the website.\n* To cite our work, look at the [Cite](#cite) section.\n* For comparisons, use the fuzzbench `aflplusplus` setup, or use\n  `afl-clang-fast` with `AFL_LLVM_CMPLOG=1`. You can find the `aflplusplus`\n  default configuration on Google's\n  [fuzzbench](https://github.com/google/fuzzbench/tree/master/fuzzers/aflplusplus).\n\n## Building and installing AFL++\n\nTo have AFL++ easily available with everything compiled, pull the image directly\nfrom the Docker Hub (available for both x86_64 and arm64):\n\n```shell\ndocker pull aflplusplus/aflplusplus\ndocker run -ti -v /location/of/your/target:/src aflplusplus/aflplusplus\n```\n\nThis image is automatically published when a push to the stable branch happens\n(see [branches](#branches)). If you use the command above, you will find your\ntarget source code in `/src` in the container.\n\nNote: you can also pull `aflplusplus/aflplusplus:dev` which is the most current\ndevelopment state of AFL++.\n\nTo build AFL++ yourself - *which we recommend* - continue at\n[docs/INSTALL.md](docs/INSTALL.md).\n\n## Quick start: Fuzzing with AFL++\n\n*NOTE: Before you start, please read about the\n[common sense risks of fuzzing](docs/fuzzing_in_depth.md#0-common-sense-risks).*\n\nThis is a quick start for fuzzing targets with the source code available. To\nread about the process in detail, see\n[docs/fuzzing_in_depth.md](docs/fuzzing_in_depth.md).\n\nTo learn about fuzzing other targets, see:\n* Binary-only targets:\n  [docs/fuzzing_binary-only_targets.md](docs/fuzzing_binary-only_targets.md)\n* Network services:\n  [docs/best_practices.md#fuzzing-a-network-service](docs/best_practices.md#fuzzing-a-network-service)\n* GUI programs:\n  [docs/best_practices.md#fuzzing-a-gui-program](docs/best_practices.md#fuzzing-a-gui-program)\n\nStep-by-step quick start:\n\n1. Compile the program or library to be fuzzed using `afl-cc`. A common way to\n   do this would be:\n\n   ```\n   CC=/path/to/afl-cc CXX=/path/to/afl-c++ ./configure --disable-shared\n   make clean all\n   ```\n\n2. Get a small but valid input file that makes sense to the program. When\n   fuzzing verbose syntax (SQL, HTTP, etc.), create a dictionary as described in\n   [dictionaries/README.md](dictionaries/README.md), too.\n\n3. If the program reads from stdin, run `afl-fuzz` like so:\n\n   ```\n   ./afl-fuzz -i seeds_dir -o output_dir -- \\\n   /path/to/tested/program [...program's cmdline...]\n   ```\n\n   To add a dictionary, add `-x /path/to/dictionary.txt` to afl-fuzz.\n\n   If the program takes input from a file, you can put `@@` in the program's\n   command line; AFL++ will put an auto-generated file name in there for you.\n\n4. Investigate anything shown in red in the fuzzer UI by promptly consulting\n   [docs/afl-fuzz_approach.md#understanding-the-status-screen](docs/afl-fuzz_approach.md#understanding-the-status-screen).\n\n5. You will find found crashes and hangs in the subdirectories `crashes/` and\n   `hangs/` in the `-o output_dir` directory. You can replay the crashes by\n   feeding them to the target, e.g. if your target is using stdin:\n\n   ```\n   cat output_dir/crashes/id:000000,* | /path/to/tested/program [...program's cmdline...]\n   ```\n\n   You can generate cores or use gdb directly to follow up the crashes.\n\n6. We cannot stress this enough - if you want to fuzz effectively, read the\n   [docs/fuzzing_in_depth.md](docs/fuzzing_in_depth.md) document!\n\n## Contact\n\nQuestions? Concerns? Bug reports?\n\n* The contributors can be reached via (e.g., by creating an issue):\n  [https://github.com/AFLplusplus/AFLplusplus](https://github.com/AFLplusplus/AFLplusplus).\n* Take a look at our [FAQ](docs/FAQ.md). If you find an interesting or important\n  question missing, submit it via\n  [https://github.com/AFLplusplus/AFLplusplus/discussions](https://github.com/AFLplusplus/AFLplusplus/discussions).\n* Best: join the [Awesome Fuzzing](https://discord.gg/gCraWct) Discord server.\n* There is a (not really used) mailing list for the AFL/AFL++ project\n  ([browse archive](https://groups.google.com/group/afl-users)). To compare\n  notes with other users or to get notified about major new features, send an\n  email to <afl-users+subscribe@googlegroups.com>, but note that this is not\n  managed by us.\n\n## Branches\n\nThe following branches exist:\n\n* [release](https://github.com/AFLplusplus/AFLplusplus/tree/release): the latest\n  release\n* [stable/trunk](https://github.com/AFLplusplus/AFLplusplus/): stable state of\n  AFL++ - it is synced from dev from time to time when we are satisfied with its\n  stability\n* [dev](https://github.com/AFLplusplus/AFLplusplus/tree/dev): development state\n  of AFL++ - bleeding edge and you might catch a checkout which does not compile\n  or has a bug. **We only accept PRs (pull requests) for the 'dev' branch!**\n* (any other): experimental branches to work on specific features or testing new\n  functionality or changes.\n\n## Help wanted\n\nWe have several [ideas](docs/ideas.md) we would like to see in AFL++ to make it\neven better. However, we already work on so many things that we do not have the\ntime for all the big ideas.\n\nThis can be your way to support and contribute to AFL++ - extend it to do\nsomething cool.\n\nFor everyone who wants to contribute (and send pull requests), please read our\n[contributing guidelines](CONTRIBUTING.md) before you submit.\n\n## Special thanks\n\nMany of the improvements to the original AFL and AFL++ wouldn't be possible\nwithout feedback, bug reports, or patches from our contributors.\n\nThank you! (For people sending pull requests - please add yourself to this list\n:-)\n\n<details>\n\n  <summary>List of contributors</summary>\n\n  ```\n    Jann Horn                             Hanno Boeck\n    Felix Groebert                        Jakub Wilk\n    Richard W. M. Jones                   Alexander Cherepanov\n    Tom Ritter                            Hovik Manucharyan\n    Sebastian Roschke                     Eberhard Mattes\n    Padraig Brady                         Ben Laurie\n    @dronesec                             Luca Barbato\n    Tobias Ospelt                         Thomas Jarosch\n    Martin Carpenter                      Mudge Zatko\n    Joe Zbiciak                           Ryan Govostes\n    Michael Rash                          William Robinet\n    Jonathan Gray                         Filipe Cabecinhas\n    Nico Weber                            Jodie Cunningham\n    Andrew Griffiths                      Parker Thompson\n    Jonathan Neuschaefer                  Tyler Nighswander\n    Ben Nagy                              Samir Aguiar\n    Aidan Thornton                        Aleksandar Nikolich\n    Sam Hakim                             Laszlo Szekeres\n    David A. Wheeler                      Turo Lamminen\n    Andreas Stieger                       Richard Godbee\n    Louis Dassy                           teor2345\n    Alex Moneger                          Dmitry Vyukov\n    Keegan McAllister                     Kostya Serebryany\n    Richo Healey                          Martijn Bogaard\n    rc0r                                  Jonathan Foote\n    Christian Holler                      Dominique Pelle\n    Jacek Wielemborek                     Leo Barnes\n    Jeremy Barnes                         Jeff Trull\n    Guillaume Endignoux                   ilovezfs\n    Daniel Godas-Lopez                    Franjo Ivancic\n    Austin Seipp                          Daniel Komaromy\n    Daniel Binderman                      Jonathan Metzman\n    Vegard Nossum                         Jan Kneschke\n    Kurt Roeckx                           Marcel Boehme\n    Van-Thuan Pham                        Abhik Roychoudhury\n    Joshua J. Drake                       Toby Hutton\n    Rene Freingruber                      Sergey Davidoff\n    Sami Liedes                           Craig Young\n    Andrzej Jackowski                     Daniel Hodson\n    Nathan Voss                           Dominik Maier\n    Andrea Biondo                         Vincent Le Garrec\n    Khaled Yakdan                         Kuang-che Wu\n    Josephine Calliotte                   Konrad Welc\n    Thomas Rooijakkers                    David Carlier\n    Ruben ten Hove                        Joey Jiao\n    fuzzah                                @intrigus-lgtm\n    Yaakov Saxon                          Sergej Schumilo\n  ```\n\n</details>\n\n## Cite\n\nIf you use AFL++ in scientific work, consider citing\n[our paper](https://www.usenix.org/conference/woot20/presentation/fioraldi)\npresented at WOOT'20:\n\n    Andrea Fioraldi, Dominik Maier, Heiko Ei√üfeldt, and Marc Heuse. ‚ÄúAFL++: Combining incremental steps of fuzzing research‚Äù. In 14th USENIX Workshop on Offensive Technologies (WOOT 20). USENIX Association, Aug. 2020.\n\n<details>\n\n<summary>BibTeX</summary>\n\n  ```bibtex\n  @inproceedings {AFLplusplus-Woot20,\n  author = {Andrea Fioraldi and Dominik Maier and Heiko Ei{\\ss}feldt and Marc Heuse},\n  title = {{AFL++}: Combining Incremental Steps of Fuzzing Research},\n  booktitle = {14th {USENIX} Workshop on Offensive Technologies ({WOOT} 20)},\n  year = {2020},\n  publisher = {{USENIX} Association},\n  month = aug,\n  }\n  ```\n\n</details>\n"
        },
        {
          "name": "TODO.md",
          "type": "blob",
          "size": 1.7255859375,
          "content": "# TODO list for AFL++\n\n## Must\n\n - ijon support?\n - check for null ptr for xml/curl/g_ string transform functions\n - hardened_usercopy=0 page_alloc.shuffle=0\n - add value_profile but only enable after 15 minutes without finds\n - cmplog max items env?\n - adapt MOpt to new mutation engine\n   - Update afl->pending_not_fuzzed for MOpt\n - cmplog rtn sanity check on fixed length? currently we ignore the length\n - afl-showmap -f support\n - afl-fuzz multicore wrapper script\n - when trimming then perform crash detection\n\n\n## Should\n\n - afl-crash-analysis\n - cmplog: add loop count resolving (byte -> loop cnt change, calc special values)\n - support persistent and deferred fork server in afl-showmap?\n - better autodetection of shifting runtime timeout values\n - afl-plot to support multiple plot_data\n - parallel builds for source-only targets\n - get rid of check_binary, replace with more forkserver communication\n - first fuzzer should be a main automatically? not sure.\n\n## Maybe\n\n - forkserver tells afl-fuzz if cmplog is supported and if so enable\n   it by default, with AFL_CMPLOG_NO=1 (?) set to skip?\n - afl_custom_splice()\n - cmdline option from-to range for mutations\n\n## Further down the road\n\nQEMU mode/FRIDA mode:\n - non colliding instrumentation\n - rename qemu specific envs to AFL_QEMU (AFL_ENTRYPOINT, AFL_CODE_START/END,\n   AFL_COMPCOV_LEVEL?)\n - add AFL_QEMU_EXITPOINT (maybe multiple?)\n\n## Ideas\n\n - LTO/sancov: write current edge to prev_loc and use that information when\n   using cmplog or __sanitizer_cov_trace_cmp*. maybe we can deduct by follow up\n   edge numbers that both following cmp paths have been found and then disable\n   working on this edge id -> cmplog_intelligence branch\n - use cmplog colorization taint result for havoc locations?\n"
        },
        {
          "name": "afl-addseeds",
          "type": "blob",
          "size": 1.5693359375,
          "content": "#!/bin/sh\n\ntest -z \"$1\" -o \"$1\" = \"-h\" -o \"$1\" = \"--help\" && {\n  echo Syntax: afl-addseeds -o afl-out-dir [-i seed_file_or_dir] seed_file_or_seed_dir seed_file_or_seed_dir ...\n  echo\n  echo Options:\n  echo \"  -o afl-out-dir       the output directory being used in the fuzzing campaign\"\n  echo \"  -i seed_file_or_dir  file or directory of files to add\"\n  echo\n  echo Adds new seeds to an existing AFL++ fuzzing campaign.\n  exit 0\n}\n\nfor TOOL in find ls; do\n  X=`which $TOOL`\n  test -n \"$X\" || { echo \"Error: required tool '$TOOL' not found.\"; exit 1; }\ndone\n\nTEST=`printf %06d 123 2>/dev/null`\ntest \"$TEST\" = \"000123\" || { echo \"Error: required tool 'printf' not found.\"; exit 1; }\n\nOUT=\nNEXT=\nfor i in $*; do\n  test -n \"$NEXT\" && { OUT=$i ; NEXT=\"\"; }\n  test \"$i\" = \"-o\" && { NEXT=1; }\ndone\n\ntest -d \"$OUT\" || { echo Error: $OUT is not an existing directory; exit 1; }\nOK=`ls $OUT/*/fuzzer_stats 2>/dev/null`\ntest -n \"$OK\" || { echo \"Error: $OUT is not an 'afl-fuzz -o ... ' output directory\" ; exit 1; }\n\nOUTDIR=$OUT/addseeds/queue\nmkdir -p \"$OUTDIR\" 2>/dev/null\ntest -d \"$OUTDIR\" || { echo Error: could not create $OUTDIR ; exit 1 ; }\n\necho Adding seeds ...\nNEXTID=0\nfor i in $*; do\n  test -z \"$i\" -o \"$i\" = \"$OUT\" -o \"$i\" = \"-i\" -o \"$i\" = \"-o\" || {\n    find \"$i\" -type f | while read FILE; do\n      N=xxx\n      while [ -n \"$N\" ]; do\n        ID=$NEXTID\n        N=`ls \"$OUTDIR/id:$(printf %06d $ID),\"* 2>/dev/null`\n        NEXTID=$(($NEXTID + 1))\n      done\n      FN=`echo \"$FILE\" | sed 's/.*\\///'`\n      cp -v \"$FILE\" \"$OUTDIR/id:$(printf %06d $ID),time:0,execs:0,orig:$FN\"\n    done\n  }\ndone\n\necho Done.\n"
        },
        {
          "name": "afl-cmin",
          "type": "blob",
          "size": 21.693359375,
          "content": "#!/usr/bin/env sh\nSYS=$(uname -s)\ntest \"$SYS\" = \"Darwin\" && {\n  echo Error: afl-cmin does not work on Apple currently. please use afl-cmin.bash instead.\n  exit 1\n}\nexport AFL_QUIET=1\nexport ASAN_OPTIONS=detect_leaks=0\nTHISPATH=`dirname ${0}`\nexport PATH=\"${THISPATH}:$PATH\"\nawk -f - -- ${@+\"$@\"} <<'EOF'\n#!/usr/bin/awk -f\n# awk script to minimize a test corpus of input files\n#\n# based on afl-cmin bash script written by Michal Zalewski\n# rewritten by Heiko Eissfeldt (hexcoder-)\n# tested with:\n#   gnu awk (x86 Linux)\n#   bsd awk (x86 *BSD)\n#   mawk (arm32 raspbian)\n#\n# uses getopt.awk package from Arnold Robbins\n#\n# external tools used by this script:\n# test\n# grep\n# rm\n# mkdir\n# ln\n# cp\n# pwd\n# type\n# cd\n# find\n# stat\n# sort\n# cut\n# and afl-showmap from this project :-)\n\n# getopt.awk --- Do C library getopt(3) function in awk\n\n# External variables:\n#    Optind -- index in ARGV of first nonoption argument\n#    Optarg -- string value of argument to current option\n#    Opterr -- if nonzero, print our own diagnostic\n#    Optopt -- current option letter\n\n# Returns:\n#    -1     at end of options\n#    \"?\"    for unrecognized option\n#    <c>    a character representing the current option\n\n# Private Data:\n#    _opti  -- index in multiflag option, e.g., -abc\n\nfunction getopt(argc, argv, options,    thisopt, i)\n{\n    if (length(options) == 0)    # no options given\n        return -1\n\n    if (argv[Optind] == \"--\") {  # all done\n        Optind++\n        _opti = 0\n        return -1\n    } else if (argv[Optind] !~ /^-[^:\\t ]/) {\n        _opti = 0\n        return -1\n    }\n    if (_opti == 0)\n        _opti = 2\n    thisopt = substr(argv[Optind], _opti, 1)\n    Optopt = thisopt\n    i = index(options, thisopt)\n    if (i == 0) {\n        if (Opterr)\n            printf(\"%c -- invalid option\\n\", thisopt) > \"/dev/stderr\"\n        if (_opti >= length(argv[Optind])) {\n            Optind++\n            _opti = 0\n        } else\n            _opti++\n        return \"?\"\n    }\n    if (substr(options, i + 1, 1) == \":\") {\n        # get option argument\n        if (length(substr(argv[Optind], _opti + 1)) > 0)\n            Optarg = substr(argv[Optind], _opti + 1)\n        else\n            Optarg = argv[++Optind]\n        _opti = 0\n    } else\n        Optarg = \"\"\n    if (_opti == 0 || _opti >= length(argv[Optind])) {\n        Optind++\n        _opti = 0\n    } else\n        _opti++\n    return thisopt\n}\n\nfunction usage() {\n   print \\\n\"afl-cmin [ options ] -- /path/to/target_app [ ... ]\\n\" \\\n\"\\n\" \\\n\"Required parameters:\\n\" \\\n\"  -i dir        - input directory with starting corpus\\n\" \\\n\"  -o dir        - output directory for minimized files\\n\" \\\n\"\\n\" \\\n\"Execution control settings:\\n\" \\\n\"  -T tasks      - how many parallel tasks to run (default: 1, all=nproc)\\n\" \\\n\"  -f file       - location read by the fuzzed program (default: stdin)\\n\" \\\n\"  -m megs       - memory limit for child process (\"mem_limit\" MB)\\n\" \\\n\"  -t msec       - run time limit for child process (default: 5000)\\n\" \\\n\"  -O            - use binary-only instrumentation (FRIDA mode)\\n\" \\\n\"  -Q            - use binary-only instrumentation (QEMU mode)\\n\" \\\n\"  -U            - use unicorn-based instrumentation (unicorn mode)\\n\" \\\n\"  -X            - use Nyx mode\\n\" \\\n\"\\n\" \\\n\"Minimization settings:\\n\" \\\n\"  -A            - allow crashes and timeouts (not recommended)\\n\" \\\n\"  -C            - keep crashing inputs, reject everything else\\n\" \\\n\"  -e            - solve for edge coverage only, ignore hit counts\\n\" \\\n\"\\n\" \\\n\"For additional tips, please consult README.md\\n\" \\\n\"\\n\" \\\n\"Environment variables used:\\n\" \\\n\"AFL_CRASH_EXITCODE: optional child exit code to be interpreted as crash\\n\" \\\n\"AFL_FORKSRV_INIT_TMOUT: time the fuzzer waits for the forkserver to come up\\n\" \\\n\"AFL_KEEP_TRACES: leave the temporary <out_dir>/.traces directory\\n\" \\\n\"AFL_KILL_SIGNAL: Signal delivered to child processes on timeout (default: SIGKILL)\\n\" \\\n\"AFL_FORK_SERVER_KILL_SIGNAL: Signal delivered to fork server processes on\\n\" \\\n\"   termination (default: SIGTERM). If this is not set and AFL_KILL_SIGNAL is\\n\" \\\n\"   set, this will be set to the same value as AFL_KILL_SIGNAL.\\n\" \\\n\"AFL_NO_FORKSRV: run target via execve instead of using the forkserver\\n\" \\\n\"AFL_CMIN_ALLOW_ANY: write tuples for crashing inputs also\\n\" \\\n\"AFL_PATH: path for the afl-showmap binary if not found anywhere in PATH\\n\" \\\n\"AFL_PRINT_FILENAMES: If set, the filename currently processed will be \" \\\n      \"printed to stdout\\n\" \\\n\"AFL_SKIP_BIN_CHECK: skip afl instrumentation checks for target binary\\n\"\n\"AFL_CUSTOM_MUTATOR_LIBRARY: custom mutator library (post_process and send)\\n\"\n\"AFL_PYTHON_MODULE: custom mutator library (post_process and send)\\n\"\n   exit 1\n}\n\nfunction exists_and_is_executable(binarypath) {\n  return 0 == system(\"test -f \"binarypath\" -a -x \"binarypath)\n}\n\nBEGIN {\n  if (0 != system( \"test -t 1\")) {\n    redirected = 1\n  } else {\n    redirected = 0\n  }\n\n  print \"corpus minimization tool for AFL++ (awk version)\\n\"\n\n  # defaults\n  extra_par = \"\"\n  AFL_CMIN_CRASHES_ONLY = \"\"\n  AFL_CMIN_ALLOW_ANY = \"\"\n\n  # process options\n  Opterr = 1    # default is to diagnose\n  Optind = 1    # skip ARGV[0]\n  while ((_go_c = getopt(ARGC, ARGV, \"hi:o:f:m:t:eACOQUXYT:?\")) != -1) {\n    if (_go_c == \"i\") {\n      if (!Optarg) usage()\n      if (in_dir) { print \"Option \"_go_c\" is only allowed once\" > \"/dev/stderr\"}\n      in_dir = Optarg\n      continue\n    } else \n    if (_go_c == \"T\") {\n      if (!Optarg) usage()\n      if (threads) { print \"Option \"_go_c\" is only allowed once\" > \"/dev/stderr\"}\n      threads = Optarg\n      continue\n    } else \n    if (_go_c == \"o\") {\n      if (!Optarg) usage()\n      if (out_dir) { print \"Option \"_go_c\" is only allowed once\" > \"/dev/stderr\"}\n      out_dir = Optarg\n      continue\n    } else \n    if (_go_c == \"f\") {\n      if (!Optarg) usage()\n      if (stdin_file) { print \"Option \"_go_c\" is only allowed once\" > \"/dev/stderr\"}\n      stdin_file = Optarg\n      continue\n    } else \n    if (_go_c == \"m\") {\n      if (!Optarg) usage()\n      if (mem_limit) { print \"Option \"_go_c\" is only allowed once\" > \"/dev/stderr\"}\n      mem_limit = Optarg\n      mem_limit_given = 1\n      continue\n    } else \n    if (_go_c == \"t\") {\n      if (!Optarg) usage()\n      if (timeout) { print \"Option \"_go_c\" is only allowed once\" > \"/dev/stderr\"}\n      timeout = Optarg\n      continue\n    } else \n    if (_go_c == \"C\") {\n      AFL_CMIN_CRASHES_ONLY = \"AFL_CMIN_CRASHES_ONLY=1 \"\n      continue\n    } else \n    if (_go_c == \"A\") {\n      AFL_CMIN_ALLOW_ANY = \"AFL_CMIN_ALLOW_ANY=1 \"\n      continue\n    } else \n    if (_go_c == \"e\") {\n      extra_par = extra_par \" -e\"\n      continue\n    } else \n    if (_go_c == \"O\") {\n      if (frida_mode) { print \"Option \"_go_c\" is only allowed once\" > \"/dev/stderr\"}\n      extra_par = extra_par \" -O\"\n      frida_mode = 1\n      continue\n    } else \n    if (_go_c == \"Q\") {\n      if (qemu_mode) { print \"Option \"_go_c\" is only allowed once\" > \"/dev/stderr\"}\n      extra_par = extra_par \" -Q\"\n      qemu_mode = 1\n      continue\n    } else \n    if (_go_c == \"U\") {\n      if (unicorn_mode) { print \"Option \"_go_c\" is only allowed once\" > \"/dev/stderr\"}\n      extra_par = extra_par \" -U\"\n      unicorn_mode = 1\n      continue\n    } else\n    if (_go_c == \"X\" || _go_c == \"Y\") {\n      if (nyx_mode) { print \"Option \"_go_c\" is only allowed once\" > \"/dev/stderr\"}\n      extra_par = extra_par \" -X\"\n      nyx_mode = 1\n      continue\n    } else \n    if (_go_c == \"?\") {\n      exit 1\n    } else \n      usage()\n  } # while options\n\n  if (!mem_limit) mem_limit = \"none\"\n  if (!timeout) timeout = \"5000\"\n\n  # get program args\n  i = 0\n  prog_args_string = \"\"\n  for (; Optind < ARGC; Optind++) {\n    prog_args[i++] = ARGV[Optind]\n    if (i > 1)\n      prog_args_string = prog_args_string\" '\"ARGV[Optind]\"'\"\n  }\n\n  # sanity checks\n  if (!prog_args[0] || !in_dir || !out_dir) usage()\n\n  target_bin = prog_args[0] \n\n  # Do a sanity check to discourage the use of /tmp, since we can't really\n  # handle this safely from an awk script.\n\n  if (!ENVIRON[\"AFL_ALLOW_TMP\"]) {\n    dirlist[0] = in_dir\n    dirlist[1] = target_bin\n    dirlist[2] = out_dir\n    dirlist[3] = stdin_file\n    \"pwd\" | getline dirlist[4] # current directory\n    for (dirind in dirlist) {\n      dir = dirlist[dirind]\n      if (dir ~ /^(\\/var)?\\/tmp/) {\n        print \"[-] Warning: do not use this script in /tmp or /var/tmp for security reasons.\" > \"/dev/stderr\"\n      }\n    }\n    delete dirlist\n  }\n\n  if (threads && stdin_file) {\n    print \"[-] Error: -T and -f cannot be used together.\" > \"/dev/stderr\"\n    exit 1\n  }\n\n  if (!threads && !stdin_file && !nyx_mode) {\n    print \"[*] Are you aware of the '-T all' parallelize option that improves the speed for large/slow corpuses?\"\n  }\n\n  # If @@ is specified, but there's no -f, let's come up with a temporary input\n  # file name.\n\n  trace_dir = out_dir \"/.traces\"\n\n  if (!stdin_file) {\n    found_atat = 0\n    for (prog_args_ind in prog_args) {\n      if (match(prog_args[prog_args_ind], \"@@\") != 0) {\n        found_atat = 1\n        break\n      }\n    }\n    if (found_atat) {\n      stdin_file = trace_dir \"/.cur_input\"\n    }\n  }\n\n  # Check for obvious errors.\n\n  if (mem_limit && mem_limit != \"none\" && mem_limit < 5) {\n    print \"[-] Error: dangerously low memory limit.\" > \"/dev/stderr\"\n    exit 1\n  }\n\n  if (timeout && timeout != \"none\" && timeout < 10) {\n    print \"[-] Error: dangerously low timeout.\" > \"/dev/stderr\"\n    exit 1\n  }\n\n\n  if (!nyx_mode && target_bin && !exists_and_is_executable(target_bin)) {\n\n    cmd = \"command -v \"target_bin\" 2>/dev/null\"\n    cmd | getline tnew\n    close(cmd)\n    if (!tnew || !exists_and_is_executable(tnew)) {\n      print \"[-] Error: binary '\"target_bin\"' not found or not executable.\" > \"/dev/stderr\"\n      exit 1\n    }\n    target_bin = tnew\n  }\n\n  if (0 == system ( \"grep -aq AFL_DUMP_MAP_SIZE \" target_bin )) {\n    echo \"[!] Trying to obtain the map size of the target ...\"\n    get_map_size = \"AFL_DUMP_MAP_SIZE=1 \" target_bin\n    get_map_size | getline mapsize\n    close(get_map_size)\n    if (mapsize && mapsize > 65535 && mapsize < 100000000) {\n      AFL_MAP_SIZE = \"AFL_MAP_SIZE=\"mapsize\" \"\n      print \"[+] Setting \"AFL_MAP_SIZE\n    }\n  }\n\n  if (!ENVIRON[\"AFL_SKIP_BIN_CHECK\"] && !qemu_mode && !frida_mode && !unicorn_mode && !nyx_mode) {\n    if (0 != system( \"grep -q __AFL_SHM_ID \"target_bin )) {\n      print \"[-] Error: binary '\"target_bin\"' doesn't appear to be instrumented.\" > \"/dev/stderr\"\n      exit 1\n    }\n  }\n\n  if (0 != system( \"test -d \"in_dir )) {\n    print \"[-] Error: directory '\"in_dir\"' not found.\" > \"/dev/stderr\"\n    exit 1\n  }\n\n  #if (0 == system( \"test -d \"in_dir\"/default\" )) {\n  #  in_dir = in_dir \"/default\"\n  #}\n  #\n  #if (0 == system( \"test -d \"in_dir\"/queue\" )) {\n  #  in_dir = in_dir \"/queue\"\n  #}\n\n  system(\"rm -rf \"trace_dir\" 2>/dev/null\");\n  system(\"rm \"out_dir\"/id[:_]* 2>/dev/null\")\n\n  cmd = \"ls \"out_dir\"/* 2>/dev/null | wc -l\"\n  cmd | getline noofentries\n  close(cmd)\n  if (0 == system( \"test -d \"out_dir\" -a \"noofentries\" -gt 0\" )) {\n    print \"[-] Error: directory '\"out_dir\"' exists and is not empty - delete it first.\" > \"/dev/stderr\"\n    exit 1\n  }\n\n  if (threads) {\n    cmd = \"nproc\"\n    cmd | getline nproc\n    close(cmd)\n    if (threads == \"all\") {\n      threads = nproc\n    } else {\n      if (!(threads > 1 && threads <= nproc)) {\n        print \"[-] Error: -T option must be between 1 and \"nproc\" or \\\"all\\\".\" > \"/dev/stderr\"\n        exit 1\n      }\n    }\n  }\n\n  # Check for the more efficient way to copy files...\n  if (0 != system(\"mkdir -p -m 0700 \"trace_dir)) {\n    print \"[-] Error: Cannot create directory \"trace_dir > \"/dev/stderr\"\n    exit 1\n  }\n\n  if (stdin_file) {\n    # truncate input file\n    printf \"\" > stdin_file\n    close(stdin_file)\n  }\n\n  # First we look in PATH\n  if (0 == system(\"command -v afl-showmap >/dev/null 2>&1\")) {\n    cmd = \"command -v afl-showmap 2>/dev/null\"\n    cmd | getline showmap\n    close(cmd)\n  } else {\n    # then we look in the current directory\n    if (0 == system(\"test -x ./afl-showmap\")) {\n      showmap = \"./afl-showmap\"\n    } else {\n      if (ENVIRON[\"AFL_PATH\"]) {\n        showmap = ENVIRON[\"AFL_PATH\"] \"/afl-showmap\"\n      }\n    }\n  }\n\n  if (!showmap || 0 != system(\"test -x \"showmap )) {\n    print \"[-] Error: can't find 'afl-showmap' - please set AFL_PATH.\" > \"/dev/stderr\"\n    exit 1\n  }\n\n  # get list of input filenames sorted by size\n  i = 0\n  # yuck, gnu stat is option incompatible to bsd stat\n  # we use a heuristic to differentiate between\n  # GNU stat and other stats\n  cmd = \"stat --version 2>/dev/null\"\n  cmd | getline statversion\n  close(cmd)\n  if (statversion ~ /GNU coreutils/ || statversion ~ /BusyBox/) {\n    stat_format = \"-c '%s %n'\" # GNU\n  } else {\n    stat_format = \"-f '%z %N'\" # *BSD, MacOS\n  }\n  cmdline = \"(cd \"in_dir\" && find . \\\\( ! -name \\\".*\\\" -a -type d \\\\) -o -type f -exec stat \"stat_format\" \\\\{\\\\} + | sort -k1n -k2r) | grep -Ev '^0'\"\n  #cmdline = \"ls \"in_dir\" | (cd \"in_dir\" && xargs stat \"stat_format\" 2>/dev/null) | sort -k1n -k2r\"\n  #cmdline = \"(cd \"in_dir\" && stat \"stat_format\" *) | sort -k1n -k2r\"\n  #cmdline = \"(cd \"in_dir\" && ls | xargs stat \"stat_format\" ) | sort -k1n -k2r\"\n  while (cmdline | getline) {\n    sub(/^[0-9]+ (\\.\\/)?/,\"\",$0)\n    infilesSmallToBigFull[i] = $0\n    sub(/.*\\//, \"\", $0)\n    infilesSmallToBig[i] = $0\n    infilesSmallToBigMap[infilesSmallToBig[i]] = infilesSmallToBigFull[i]\n    infilesSmallToBigFullMap[infilesSmallToBigFull[i]] = infilesSmallToBig[i]\n    i++\n  }\n  close(cmdline)\n  in_count = i\n\n  first_file = infilesSmallToBigFull[0]\n  \n  #if (0 == system(\"test -d \"\"\\\"\"in_dir\"/\"first_file\"\\\"\")) {\n  #  print \"[-] Error: The input directory is empty or contains subdirectories - please fix.\" > \"/dev/stderr\"\n  #  exit 1\n  #}\n\n  system(\">\\\"\"in_dir\"/.afl-cmin.test\\\"\")\n  if (0 == system(\"ln \\\"\"in_dir\"/.afl-cmin.test\\\" \"trace_dir\"/.link_test\")) {\n    cp_tool = \"ln\"\n  } else {\n    cp_tool = \"cp\"\n  }\n  system(\"rm -f \\\"\"in_dir\"/.afl-cmin.test\\\"\")\n\n  if (!ENVIRON[\"AFL_SKIP_BIN_CHECK\"]) {\n    # Make sure that we can actually get anything out of afl-showmap before we\n    # waste too much time.\n\n    print \"[*] Testing the target binary...\"\n\n    if (!stdin_file) {\n      system(AFL_MAP_SIZE \"AFL_CMIN_ALLOW_ANY=1 \"AFL_CMIN_CRASHES_ONLY\"\\\"\"showmap\"\\\" -m \"mem_limit\" -t \"timeout\" -o \\\"\"trace_dir\"/.run_test\\\" -Z \"extra_par\" -- \\\"\"target_bin\"\\\" \"prog_args_string\" <\\\"\"in_dir\"/\"first_file\"\\\"\")\n    } else {\n      system(\"cp \\\"\"in_dir\"/\"first_file\"\\\" \"stdin_file)\n      system(AFL_MAP_SIZE \"AFL_CMIN_ALLOW_ANY=1 \"AFL_CMIN_CRASHES_ONLY\"\\\"\"showmap\"\\\" -m \"mem_limit\" -t \"timeout\" -o \\\"\"trace_dir\"/.run_test\\\" -Z \"extra_par\" -H \\\"\"stdin_file\"\\\" -- \\\"\"target_bin\"\\\" \"prog_args_string\" </dev/null\")\n    }\n\n    first_count = 0\n\n    runtest = trace_dir\"/.run_test\"\n    while ((getline < runtest) > 0) {\n      ++first_count\n    }\n    close(runtest)\n\n    if (first_count) {\n      print \"[+] OK, \"first_count\" tuples recorded.\"\n    } else {\n      print \"[-] Error: no instrumentation output detected (perhaps crash or timeout).\" > \"/dev/stderr\"\n      if (!ENVIRON[\"AFL_KEEP_TRACES\"]) {\n        system(\"rm -rf \"trace_dir\" 2>/dev/null\")\n      }\n      exit 1\n    }\n  }\n\n  if (in_count < threads) {\n    threads = in_count\n    print \"[!] WARNING: less inputs than threads, reducing threads to \"threads\" and likely the overhead of threading makes things slower...\"\n  }\n\n  # Let's roll!\n\n  #############################\n  # STEP 1: Collecting traces #\n  #############################\n\n  if (threads) {\n\n    inputsperfile = int(in_count / threads)\n    if (in_count % threads) {\n      inputsperfile++;\n    }\n\n    cnt = 0;\n    tmpfile=out_dir \"/.filelist\"\n    for (instance = 1; instance < threads; instance++) {\n      for (i = 0; i < inputsperfile; i++) {\n        print in_dir\"/\"infilesSmallToBigFull[cnt] >> tmpfile\".\"instance\n        cnt++\n      }\n    }\n    for (; cnt < in_count; cnt++) {\n      print in_dir\"/\"infilesSmallToBigFull[cnt] >> tmpfile\".\"threads\n    }\n\n  }\n\n  print \"[*] Obtaining traces for \"in_count\" input files in '\"in_dir\"'.\"\n\n  cur = 0;\n\n  if (threads > 1) {\n\n    print \"[*] Creating \" threads \" parallel tasks with about \" inputsperfile \" items each.\"\n    for (i = 1; i <= threads; i++) {\n\n      if (!stdin_file) {\n#        print \" { \"AFL_MAP_SIZE AFL_CMIN_ALLOW_ANY AFL_CMIN_CRASHES_ONLY\"\\\"\"showmap\"\\\" -m \"mem_limit\" -t \"timeout\" -o \\\"\"trace_dir\"\\\" -Z \"extra_par\" -I \\\"\"tmpfile\".\"i\"\\\" -- \\\"\"target_bin\"\\\" \"prog_args_string\"; > \"tmpfile\".\"i\".done ; } &\"\n        retval = system(\" { \"AFL_MAP_SIZE AFL_CMIN_ALLOW_ANY AFL_CMIN_CRASHES_ONLY\"\\\"\"showmap\"\\\" -m \"mem_limit\" -t \"timeout\" -o \\\"\"trace_dir\"\\\" -Z \"extra_par\" -I \\\"\"tmpfile\".\"i\"\\\" -- \\\"\"target_bin\"\\\" \"prog_args_string\"; > \"tmpfile\".\"i\".done ; } &\")\n      } else {\n        stdin_file=tmpfile\".\"i\".stdin\"\n#        print \" { \"AFL_MAP_SIZE AFL_CMIN_ALLOW_ANY AFL_CMIN_CRASHES_ONLY\"\\\"\"showmap\"\\\" -m \"mem_limit\" -t \"timeout\" -o \\\"\"trace_dir\"\\\" -Z \"extra_par\" -I \\\"\"tmpfile\".\"i\"\\\" -H \\\"\"stdin_file\"\\\" -- \\\"\"target_bin\"\\\" \"prog_args_string\" </dev/null; > \"tmpfile\".\"i\".done ; } &\"\n        retval = system(\" { \"AFL_MAP_SIZE AFL_CMIN_ALLOW_ANY AFL_CMIN_CRASHES_ONLY\"\\\"\"showmap\"\\\" -m \"mem_limit\" -t \"timeout\" -o \\\"\"trace_dir\"\\\" -Z \"extra_par\" -I \\\"\"tmpfile\".\"i\"\\\" -H \\\"\"stdin_file\"\\\" -- \\\"\"target_bin\"\\\" \"prog_args_string\" </dev/null; > \"tmpfile\".\"i\".done ; } &\")\n      }\n    }\n    print \"[*] Waiting for parallel tasks to complete ...\"\n    # wait for all processes to finish\n    ok=0\n    while (ok < threads) {\n      ok=0\n      for (i = 1; i <= threads; i++) {\n        if (system(\"test -f \"tmpfile\".\"i\".done\") == 0) {\n          ok++\n        }\n      }\n    }\n    print \"[*] Done!\"\n    system(\"rm -f \"tmpfile\"*\")\n  } else {\n    if (!stdin_file) {\n      print \"    Processing \"in_count\" files (forkserver mode)...\"\n#      print AFL_CMIN_CRASHES_ONLY\"\\\"\"showmap\"\\\" -m \"mem_limit\" -t \"timeout\" -o \\\"\"trace_dir\"\\\" -Z \"extra_par\" -i \\\"\"in_dir\"\\\" -- \\\"\"target_bin\"\\\" \"prog_args_string\n      retval = system(AFL_MAP_SIZE AFL_CMIN_ALLOW_ANY AFL_CMIN_CRASHES_ONLY\"\\\"\"showmap\"\\\" -m \"mem_limit\" -t \"timeout\" -o \\\"\"trace_dir\"\\\" -Z \"extra_par\" -i \\\"\"in_dir\"\\\" -- \\\"\"target_bin\"\\\" \"prog_args_string)\n    } else {\n      print \"    Processing \"in_count\" files (forkserver mode)...\"\n#    print AFL_CMIN_CRASHES_ONLY\"\\\"\"showmap\"\\\" -m \"mem_limit\" -t \"timeout\" -o \\\"\"trace_dir\"\\\" -Z \"extra_par\" -i \\\"\"in_dir\"\\\" -H \\\"\"stdin_file\"\\\" -- \\\"\"target_bin\"\\\" \"prog_args_string\" </dev/null\"\n      retval = system(AFL_MAP_SIZE AFL_CMIN_ALLOW_ANY AFL_CMIN_CRASHES_ONLY\"\\\"\"showmap\"\\\" -m \"mem_limit\" -t \"timeout\" -o \\\"\"trace_dir\"\\\" -Z \"extra_par\" -i \\\"\"in_dir\"\\\" -H \\\"\"stdin_file\"\\\" -- \\\"\"target_bin\"\\\" \"prog_args_string\" </dev/null\")\n    }\n\n    if (retval && (!AFL_CMIN_CRASHES_ONLY && !AFL_CMIN_ALLOW_ANY)) {\n      print \"[!] Exit code \"retval\" != 0 received from afl-showmap (this means a crashing or timeout input is likely present), terminating...\"\n\n      if (!ENVIRON[\"AFL_KEEP_TRACES\"]) {\n        system(\"rm -rf \"trace_dir\" 2>/dev/null\")\n        system(\"rmdir \"out_dir)\n      }\n      exit retval\n    }\n\n  }\n\n  #######################################################\n  # STEP 2: register smallest input file for each tuple #\n  # STEP 3: copy that file (at most once)               #\n  #######################################################\n\n  print \"[*] Processing traces for input files in '\"in_dir\"'.\"\n\n  cur = 0\n  out_count = 0\n  tuple_count = 0\n\n  # from rare to frequent new tuples\n  # get the best (smallest) file for it\n  # and copy it\n  while (cur < in_count) {\n    fn = infilesSmallToBig[cur]\n    ++cur\n    if (redirected == 0) { printf \"\\r    Processing file \"cur\"/\"in_count }\n    else { print \"    Processing file \"cur\"/\"in_count }\n    # create path for the trace file from afl-showmap\n    tracefile_path = trace_dir\"/\"fn\n    # ensure the file size is not zero\n    cmd = \"du -b \\\"\"tracefile_path\"\\\"\"\n    # \"ls -l \\\"\"tracefile_path\"\\\"\"\n    cmd | getline output\n    close(cmd)\n    split(output, result, \"\\t\")\n    if (result[1] == 0) {\n      print \"[!] WARNING: file \"fn\" is crashing the target, ignoring...\"\n    }\n    # gather all keys, and count them\n    while ((getline line < tracefile_path) > 0) {\n        key = line\n        if (!(key in key_count)) {\n          ++tuple_count\n        }\n        ++key_count[key]\n        if (! (key in best_file)) {\n            # this is the best file for this key\n            best_file[key] = fn\n#printf \"BEST_FILE[%d]=\\\"%s\\\"\\n\",key,fn | \"sort -t'[' -k2 > \"trace_dir\"/.candidate_script\"\n        }\n#printf \"%d %s\\n\",key,fn > trace_dir\"/.candidate_list\"\n    }\n    close(tracefile_path)\n  }\n  print \"\"\n\n  # sort keys\n  sortedKeys = trace_dir\"/.all_uniq\"\n  sortKeysCmd = \"sort -k1n > \"sortedKeys\n  for (key in key_count) {\n     printf \"%7d %s\\n\",key_count[key],key | sortKeysCmd\n  }\n  close(sortKeysCmd)\n\n  # iterate over keys from rare to frequent and\n  # copy best file\n  while ((getline < sortedKeys) > 0) {\n\n    # split\n    nrFields = split($0, field, / +/)\n#print nrFields\" Felder: '\"field[0]\"',  '\"field[1]\"',  '\"field[2]\"',  '\"field[3]\"'\"\n    key = field[nrFields]\n\n    ++tcnt;\n    if (redirected == 0) { printf \"\\r    Processing tuple \"tcnt\"/\"tuple_count\" with count \"key_count[key]\"...\" }\n    else { print \"    Processing tuple \"tcnt\"/\"tuple_count\" with count \"key_count[key]\"...\" }\n\n    if (key in keyAlreadyKnown) {\n      continue\n    }\n\n    fn = best_file[key]\n    # gather all tuples from the best file for this key\n    tracedfn = trace_dir\"/\"fn\n    while ((getline < tracedfn) > 0) {\n      keyAlreadyKnown[$0] = \"\"\n    }\n    close(tracedfn)\n\n    # copy file unless already done\n    if (! (fn in file_already_copied)) {\n      realfile = infilesSmallToBigMap[fn]\n      system(cp_tool\" \\\"\"in_dir\"/\"realfile\"\\\" \\\"\"out_dir\"/\"fn\"\\\"\")\n      file_already_copied[fn] = \"\"\n      ++out_count\n      #printf \"tuple nr %d (%d cnt=%d) -> %s\\n\",tcnt,key,key_count[key],fn > trace_dir\"/.log\"\n    }\n  }\n  close(sortedKeys)\n  print \"\"\n  print \"[+] Found \"tuple_count\" unique tuples across \"in_count\" files.\"\n\n  if (out_count == 1) {\n    print \"[!] WARNING: All test cases had the same traces, check syntax!\"\n  }\n  print \"[+] Narrowed down to \"out_count\" files, saved in '\"out_dir\"'.\"\n\n  if (!ENVIRON[\"AFL_KEEP_TRACES\"]) {\n    system(\"rm -rf \"trace_dir\" 2>/dev/null\")\n  }\n\n  exit 0\n}\nEOF\n"
        },
        {
          "name": "afl-cmin.bash",
          "type": "blob",
          "size": 15.376953125,
          "content": "#!/usr/bin/env bash\n#\n# american fuzzy lop++ - corpus minimization tool\n# ---------------------------------------------\n#\n# Originally written by Michal Zalewski\n#\n# Copyright 2014, 2015 Google Inc. All rights reserved.\n#\n# Copyright 2019-2024 AFLplusplus\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at:\n#\n#   https://www.apache.org/licenses/LICENSE-2.0\n#\n# This tool tries to find the smallest subset of files in the input directory\n# that still trigger the full range of instrumentation data points seen in\n# the starting corpus. This has two uses:\n#\n#   - Screening large corpora of input files before using them as a seed for\n#     afl-fuzz. The tool will remove functionally redundant files and likely\n#     leave you with a much smaller set.\n#\n#     (In this case, you probably also want to consider running afl-tmin on\n#     the individual files later on to reduce their size.)\n#\n#   - Minimizing the corpus generated organically by afl-fuzz, perhaps when\n#     planning to feed it to more resource-intensive tools. The tool achieves\n#     this by removing all entries that used to trigger unique behaviors in the\n#     past, but have been made obsolete by later finds.\n#\n# Note that the tool doesn't modify the files themselves. For that, you want\n# afl-tmin.\n#\n# This script must use bash because other shells may have hardcoded limits on\n# array sizes.\n#\n\necho \"corpus minimization tool for afl-fuzz\"\necho\n\n#########\n# SETUP #\n#########\n\n# Process command-line options...\n\nMEM_LIMIT=none\nTIMEOUT=5000\n\nunset IN_DIR OUT_DIR STDIN_FILE EXTRA_PAR MEM_LIMIT_GIVEN F_ARG \\\n  AFL_CMIN_CRASHES_ONLY AFL_CMIN_ALLOW_ANY QEMU_MODE UNICORN_MODE T_ARG\n\nexport AFL_QUIET=1\n\nwhile getopts \"+i:o:f:m:t:T:eOQUAChXY\" opt; do\n\n  case \"$opt\" in \n\n    \"h\")\n\t;;\n\n    \"i\")\n         IN_DIR=\"$OPTARG\"\n         ;;\n\n    \"o\")\n         OUT_DIR=\"$OPTARG\"\n         ;;\n    \"f\")\n         STDIN_FILE=\"$OPTARG\"\n         F_ARG=1\n         ;;\n    \"m\")\n         MEM_LIMIT=\"$OPTARG\"\n         MEM_LIMIT_GIVEN=1\n         ;;\n    \"t\")\n         TIMEOUT=\"$OPTARG\"\n         ;;\n    \"e\")\n         EXTRA_PAR=\"$EXTRA_PAR -e\"\n         ;;\n    \"A\")\n         export AFL_CMIN_ALLOW_ANY=1\n         ;;\n    \"C\")\n         export AFL_CMIN_CRASHES_ONLY=1\n         ;;\n    \"O\")\n         EXTRA_PAR=\"$EXTRA_PAR -O\"\n         FRIDA_MODE=1\n         ;;         \n    \"Q\")\n         EXTRA_PAR=\"$EXTRA_PAR -Q\"\n         QEMU_MODE=1\n         ;;\n    \"Y\")\n         EXTRA_PAR=\"$EXTRA_PAR -X\"\n         NYX_MODE=1\n         ;;\n    \"X\")\n         EXTRA_PAR=\"$EXTRA_PAR -X\"\n         NYX_MODE=1\n         ;;\n    \"U\")\n         EXTRA_PAR=\"$EXTRA_PAR -U\"\n         UNICORN_MODE=1\n         ;;    \n    \"T\")\n         T_ARG=\"$OPTARG\"\n         ;;\n    \"?\")\n         exit 1\n         ;;\n\n   esac\n\ndone\n\nshift $((OPTIND-1))\n\nTARGET_BIN=\"$1\"\n\nif [ \"$TARGET_BIN\" = \"\" -o \"$IN_DIR\" = \"\" -o \"$OUT_DIR\" = \"\" ]; then\n\n  cat 1>&2 <<_EOF_\nUsage: $0 [ options ] -- /path/to/target_app [ ... ]\n\nRequired parameters:\n\n  -i dir        - input directory with the starting corpus\n  -o dir        - output directory for minimized files\n\nExecution control settings:\n\n  -T tasks      - how many parallel processes to create (default=1, \"all\"=nproc)\n  -f file       - location read by the fuzzed program (default: stdin)\n  -m megs       - memory limit for child process (default=$MEM_LIMIT MB)\n  -t msec       - run time limit for child process (default: 5000ms)\n  -O            - use binary-only instrumentation (FRIDA mode)\n  -Q            - use binary-only instrumentation (QEMU mode)\n  -U            - use unicorn-based instrumentation (Unicorn mode)\n  -X            - use Nyx mode\n  \nMinimization settings:\n\n  -A            - allow crashing and timeout inputs\n  -C            - keep crashing inputs, reject everything else\n  -e            - solve for edge coverage only, ignore hit counts\n\nFor additional tips, please consult README.md.\nThis script cannot read filenames that end with a space ' '.\n\nEnvironment variables used:\nAFL_KEEP_TRACES: leave the temporary <out_dir>\\.traces directory\nAFL_NO_FORKSRV: run target via execve instead of using the forkserver\nAFL_PATH: last resort location to find the afl-showmap binary\nAFL_SKIP_BIN_CHECK: skip check for target binary\nAFL_CUSTOM_MUTATOR_LIBRARY: custom mutator library (post_process and send)\nAFL_PYTHON_MODULE: custom mutator library (post_process and send)\n_EOF_\n  exit 1\nfi\n\n# Do a sanity check to discourage the use of /tmp, since we can't really\n# handle this safely from a shell script.\n\nif [ \"$AFL_ALLOW_TMP\" = \"\" ]; then\n\n  echo \"$IN_DIR\" | grep -qE '^(/var)?/tmp/'\n  T1=\"$?\"\n\n  echo \"$TARGET_BIN\" | grep -qE '^(/var)?/tmp/'\n  T2=\"$?\"\n\n  echo \"$OUT_DIR\" | grep -qE '^(/var)?/tmp/'\n  T3=\"$?\"\n\n  echo \"$STDIN_FILE\" | grep -qE '^(/var)?/tmp/'\n  T4=\"$?\"\n\n  echo \"$PWD\" | grep -qE '^(/var)?/tmp/'\n  T5=\"$?\"\n\n  if [ \"$T1\" = \"0\" -o \"$T2\" = \"0\" -o \"$T3\" = \"0\" -o \"$T4\" = \"0\" -o \"$T5\" = \"0\" ]; then\n    echo \"[-] Warning: do not use this script in /tmp or /var/tmp for security reasons.\" 1>&2\n  fi\n\nfi\n\n# If @@ is specified, but there's no -f, let's come up with a temporary input\n# file name.\n\nTRACE_DIR=\"$OUT_DIR/.traces\"\n\nif [ \"$STDIN_FILE\" = \"\" ]; then\n\n  if echo \"$*\" | grep -qF '@@'; then\n    STDIN_FILE=\"$TRACE_DIR/.cur_input\"\n  fi\n\nfi\n\n# Check for obvious errors.\n\nif [ ! \"$T_ARG\" = \"\" -a -n \"$F_ARG\" -a ! \"$NYX_MODE\" == 1 ]; then\n  echo \"[-] Error: -T and -f can not be used together.\" 1>&2\n  exit 1\nfi\n\nif [ ! \"$MEM_LIMIT\" = \"none\" ]; then\n\n  if [ \"$MEM_LIMIT\" -lt \"5\" ]; then\n    echo \"[-] Error: dangerously low memory limit.\" 1>&2\n    exit 1\n  fi\n\nfi\n\nif [ ! \"$TIMEOUT\" = \"none\" ]; then\n\n  if [ \"$TIMEOUT\" -lt \"10\" ]; then\n    echo \"[-] Error: dangerously low timeout.\" 1>&2\n    exit 1\n  fi\n\nfi\n\nif [ \"$NYX_MODE\" = \"\" ]; then\n  if [ ! -f \"$TARGET_BIN\" -o ! -x \"$TARGET_BIN\" ]; then\n\n    TNEW=\"`which \"$TARGET_BIN\" 2>/dev/null`\"\n\n    if [ ! -f \"$TNEW\" -o ! -x \"$TNEW\" ]; then\n      echo \"[-] Error: binary '$TARGET_BIN' not found or not executable.\" 1>&2\n      exit 1\n    fi\n\n    TARGET_BIN=\"$TNEW\"\n\n  fi\n\nfi\n\ngrep -aq AFL_DUMP_MAP_SIZE \"$TARGET_BIN\" && {\n  echo \"[!] Trying to obtain the map size of the target ...\"\n  MAPSIZE=`AFL_DUMP_MAP_SIZE=1 \"./$TARGET_BIN\" 2>/dev/null`\n  test -n \"$MAPSIZE\" && {\n    export AFL_MAP_SIZE=$MAPSIZE\n    echo \"[+] Setting AFL_MAP_SIZE=$MAPSIZE\"\n  }\n}\n\nif [ \"$AFL_SKIP_BIN_CHECK\" = \"\" -a \"$QEMU_MODE\" = \"\" -a \"$FRIDA_MODE\" = \"\" -a \"$UNICORN_MODE\" = \"\" -a \"$NYX_MODE\" = \"\" ]; then\n\n  if ! grep -qF \"__AFL_SHM_ID\" \"$TARGET_BIN\"; then\n    echo \"[-] Error: binary '$TARGET_BIN' doesn't appear to be instrumented.\" 1>&2\n    exit 1\n  fi\n\nfi\n\nif [ ! -d \"$IN_DIR\" ]; then\n  echo \"[-] Error: directory '$IN_DIR' not found.\" 1>&2\n  exit 1\nfi\n\ntest -d \"$IN_DIR/default\" && IN_DIR=\"$IN_DIR/default\"\ntest -d \"$IN_DIR/queue\" && IN_DIR=\"$IN_DIR/queue\"\n\nfind \"$OUT_DIR\" -name 'id[:_]*' -maxdepth 1 -exec rm -- {} \\; 2>/dev/null\nrm -rf \"$TRACE_DIR\" 2>/dev/null\n\nrmdir \"$OUT_DIR\" 2>/dev/null\n\nif [ -d \"$OUT_DIR\" ]; then\n  echo \"[-] Error: directory '$OUT_DIR' exists and is not empty - delete it first.\" 1>&2\n  exit 1\nfi\n\nmkdir -m 700 -p \"$TRACE_DIR\" || exit 1\n\nif [ ! \"$STDIN_FILE\" = \"\" ]; then\n  rm -f \"$STDIN_FILE\" || exit 1\n  touch \"$STDIN_FILE\" || exit 1\nfi\n\nSHOWMAP=`command -v afl-showmap 2>/dev/null`\n\nif [ -z \"$SHOWMAP\" ]; then\n  TMP=\"${0%/afl-cmin.bash}/afl-showmap\"\n  if [ -x \"$TMP\" ]; then\n    SHOWMAP=$TMP\n  fi\nfi\n\nif [ -z \"$SHOWMAP\" -a -x \"./afl-showmap\" ]; then\n  SHOWMAP=\"./afl-showmap\"\nelse\n  if [ -n \"$AFL_PATH\" ]; then\n    SHOWMAP=\"$AFL_PATH/afl-showmap\"\n  fi\nfi\n\nif [ ! -x \"$SHOWMAP\" ]; then\n  echo \"[-] Error: can't find 'afl-showmap' - please set AFL_PATH.\" 1>&2\n  rm -rf \"$TRACE_DIR\"\n  exit 1\nfi\n\nTHREADS=\nif [ ! \"$T_ARG\" = \"\" ]; then\n  if [ \"$T_ARG\" = \"all\" ]; then\n    THREADS=$(nproc)\n  else\n    if [ \"$T_ARG\" -gt 1 -a \"$T_ARG\" -le \"$(nproc)\" ]; then\n      THREADS=$T_ARG\n    else\n      echo \"[-] Error: -T parameter must between 2 and $(nproc) or \\\"all\\\".\" 1>&2\n    fi\n  fi\nelse\n  if [ -z \"$F_ARG\" ]; then\n    echo \"[*] Are you aware of the '-T all' parallelize option that massively improves the speed?\"\n  fi\nfi\n\nIN_COUNT=$((`ls -- \"$IN_DIR\" 2>/dev/null | wc -l`))\n\nif [ \"$IN_COUNT\" = \"0\" ]; then\n  echo \"[-] Hmm, no inputs in the target directory. Nothing to be done.\"\n  rm -rf \"$TRACE_DIR\"\n  exit 1\nfi\n\necho \"[*] Are you aware that afl-cmin is faster than this afl-cmin.bash script?\"\necho \"[+] Found $IN_COUNT files for minimizing.\"\n\nif [ -n \"$THREADS\" ]; then\n  if [ \"$IN_COUNT\" -lt \"$THREADS\" ]; then\n    THREADS=$IN_COUNT\n    echo \"[!] WARNING: less inputs than threads, reducing threads to $THREADS and likely the overhead of threading makes things slower...\"\n  fi\nfi\n\nFIRST_FILE=`ls \"$IN_DIR\" | head -1`\n\n# Make sure that we're not dealing with a directory.\n\nif [ -d \"$IN_DIR/$FIRST_FILE\" ]; then\n  echo \"[-] Error: The target directory contains subdirectories - please fix.\" 1>&2\n  rm -rf \"$TRACE_DIR\"\n  exit 1\nfi\n\n# Check for the more efficient way to copy files...\n\nif ln \"$IN_DIR/$FIRST_FILE\" \"$TRACE_DIR/.link_test\" 2>/dev/null; then\n  CP_TOOL=ln\nelse\n  CP_TOOL=cp\nfi\n\n# Make sure that we can actually get anything out of afl-showmap before we\n# waste too much time.\n\necho \"[*] Testing the target binary...\"\n\nif [ \"$STDIN_FILE\" = \"\" ]; then\n\n  AFL_CMIN_ALLOW_ANY=1 \"$SHOWMAP\" -m \"$MEM_LIMIT\" -t \"$TIMEOUT\" -o \"$TRACE_DIR/.run_test\" -Z $EXTRA_PAR -- \"$@\" <\"$IN_DIR/$FIRST_FILE\"\n\nelse\n\n  cp \"$IN_DIR/$FIRST_FILE\" \"$STDIN_FILE\"\n  AFL_CMIN_ALLOW_ANY=1 \"$SHOWMAP\" -m \"$MEM_LIMIT\" -t \"$TIMEOUT\" -o \"$TRACE_DIR/.run_test\" -Z $EXTRA_PAR -H \"$STDIN_FILE\" -- \"$@\" </dev/null\n\nfi\n\nFIRST_COUNT=$((`grep -c . \"$TRACE_DIR/.run_test\"`))\n\nif [ \"$FIRST_COUNT\" -gt \"0\" ]; then\n\n  echo \"[+] OK, $FIRST_COUNT tuples recorded.\"\n\nelse\n\n  echo \"[-] Error: no instrumentation output detected (perhaps crash or timeout).\" 1>&2\n  test \"$AFL_KEEP_TRACES\" = \"\" && rm -rf \"$TRACE_DIR\"\n  exit 1\n\nfi\n\nTMPFILE=$OUT_DIR/.list.$$\nif [ ! \"$THREADS\" = \"\" ]; then\n  ls -- \"$IN_DIR\" > $TMPFILE 2>/dev/null\n  IN_COUNT=$(cat $TMPFILE | wc -l)\n  SPLIT=$(($IN_COUNT / $THREADS))\n  if [ \"$(($IN_COUNT % $THREADS))\" -gt 0 ]; then\n    SPLIT=$(($SPLIT + 1))\n  fi\n  echo \"[+] Splitting workload into $THREADS tasks with $SPLIT items on average each.\"\n  split -l $SPLIT $TMPFILE $TMPFILE.\nfi\n\n# Let's roll!\n\n#############################\n# STEP 1: COLLECTING TRACES #\n#############################\n\necho \"[*] Obtaining traces for input files in '$IN_DIR'...\"\n\nif [ \"$THREADS\" = \"\" ]; then\n(\n\n  CUR=0\n\n  if [ \"$STDIN_FILE\" = \"\" ]; then\n\n    ls \"$IN_DIR\" | while read -r fn; do\n\n      if [ -s \"$IN_DIR/$fn\" ]; then\n\n        CUR=$((CUR+1))\n        printf \"\\\\r    Processing file $CUR/$IN_COUNT... \"\n\n        \"$SHOWMAP\" -m \"$MEM_LIMIT\" -t \"$TIMEOUT\" -o \"$TRACE_DIR/$fn\" -Z $EXTRA_PAR -- \"$@\" <\"$IN_DIR/$fn\"\n      \n      fi\n\n    done\n\n  else\n\n    ls \"$IN_DIR\" | while read -r fn; do\n\n      if [ -s \"$IN_DIR/$fn\" ]; then\n\n        CUR=$((CUR+1))\n        printf \"\\\\r    Processing file $CUR/$IN_COUNT... \"\n\n        cp \"$IN_DIR/$fn\" \"$STDIN_FILE\"\n        \"$SHOWMAP\" -m \"$MEM_LIMIT\" -t \"$TIMEOUT\" -o \"$TRACE_DIR/$fn\" -Z $EXTRA_PAR -H \"$STDIN_FILE\" -- \"$@\" </dev/null\n\n      fi\n\n    done\n\n  fi\n\n  echo\n\n)\n\nelse\n\n  PIDS=\n  CNT=0\n  for inputs in $(ls ${TMPFILE}.*); do\n\n(\n\n  if [ \"$STDIN_FILE\" = \"\" ]; then\n\n    cat $inputs | while read -r fn; do\n\n      if [ -s \"$IN_DIR/$fn\" ]; then\n\n        \"$SHOWMAP\" -m \"$MEM_LIMIT\" -t \"$TIMEOUT\" -o \"$TRACE_DIR/$fn\" -Z $EXTRA_PAR -- \"$@\" <\"$IN_DIR/$fn\"\n\n      fi\n\n    done\n\n  else\n\n    if [ -s \"$IN_DIR/$fn\" ]; then\n      STDIN_FILE=\"$inputs.$$\"\n      cat $inputs | while read -r fn; do\n\n        cp \"$IN_DIR/$fn\" \"$STDIN_FILE\"\n        \"$SHOWMAP\" -m \"$MEM_LIMIT\" -t \"$TIMEOUT\" -o \"$TRACE_DIR/$fn\" -Z $EXTRA_PAR -H \"$STDIN_FILE\" -- \"$@\" </dev/null\n\n      done\n\n    fi\n\n  fi\n\n) &\n\n  PIDS=\"$PIDS $!\"\n  done\n\n  echo \"[+] Waiting for running tasks IDs:$PIDS\"\n  wait\n  echo \"[+] all $THREADS running tasks completed.\"\n  rm -f ${TMPFILE}*\n\n  #echo trace dir files: $(ls $TRACE_DIR/*|wc -l)\n\nfi\n\n\n##########################\n# STEP 2: SORTING TUPLES #\n##########################\n\n# With this out of the way, we sort all tuples by popularity across all\n# datasets. The reasoning here is that we won't be able to avoid the files\n# that trigger unique tuples anyway, so we will want to start with them and\n# see what's left.\n\necho \"[*] Sorting trace sets (this may take a while)...\"\n\nls \"$IN_DIR\" | sed \"s#^#$TRACE_DIR/#\" | tr '\\n' '\\0' | xargs -0 -n 1 cat | \\\n  sort | uniq -c | sort -k 1,1 -n >\"$TRACE_DIR/.all_uniq\"\n\nTUPLE_COUNT=$((`grep -c . \"$TRACE_DIR/.all_uniq\"`))\n\necho \"[+] Found $TUPLE_COUNT unique tuples across $IN_COUNT files.\"\n\n#####################################\n# STEP 3: SELECTING CANDIDATE FILES #\n#####################################\n\n# The next step is to find the best candidate for each tuple. The \"best\"\n# part is understood simply as the smallest input that includes a particular\n# tuple in its trace. Empirical evidence suggests that this produces smaller\n# datasets than more involved algorithms that could be still pulled off in\n# a shell script.\n\necho \"[*] Finding best candidates for each tuple...\"\n\nCUR=0\n\nls -rS \"$IN_DIR\" | while read -r fn; do\n\n  CUR=$((CUR+1))\n  printf \"\\\\r    Processing file $CUR/$IN_COUNT... \"\n\n  sed \"s#\\$# $fn#\" \"$TRACE_DIR/$fn\" >>\"$TRACE_DIR/.candidate_list\"\n\n  test -s \"$TRACE_DIR/$fn\" || echo Warning: $fn is ignored because of crashing the target\n\ndone\n\necho\n\n##############################\n# STEP 4: LOADING CANDIDATES #\n##############################\n\n# At this point, we have a file of tuple-file pairs, sorted by file size\n# in ascending order (as a consequence of ls -rS). By doing sort keyed\n# only by tuple (-k 1,1) and configured to output only the first line for\n# every key (-s -u), we end up with the smallest file for each tuple.\n\necho \"[*] Sorting candidate list (be patient)...\"\n\nsort -k1,1 -s -u \"$TRACE_DIR/.candidate_list\" | \\\n  sed 's/^/BEST_FILE[/;s/ /]=\"/;s/$/\"/' >\"$TRACE_DIR/.candidate_script\"\n\nif [ ! -s \"$TRACE_DIR/.candidate_script\" ]; then\n  echo \"[-] Error: no traces obtained from test cases, check syntax!\" 1>&2\n  test \"$AFL_KEEP_TRACES\" = \"\" && rm -rf \"$TRACE_DIR\"\n  exit 1\nfi\n\n# The sed command converted the sorted list to a shell script that populates\n# BEST_FILE[tuple]=\"fname\". Let's load that!\n\n. \"$TRACE_DIR/.candidate_script\"\n\n##########################\n# STEP 5: WRITING OUTPUT #\n##########################\n\n# The final trick is to grab the top pick for each tuple, unless said tuple is\n# already set due to the inclusion of an earlier candidate; and then put all\n# tuples associated with the newly-added file to the \"already have\" list. The\n# loop works from least popular tuples and toward the most common ones.\n\necho \"[*] Processing candidates and writing output files...\"\n\nCUR=0\n\ntouch \"$TRACE_DIR/.already_have\"\n\nwhile read -r cnt tuple; do\n\n  CUR=$((CUR+1))\n  printf \"\\\\r    Processing tuple $CUR/$TUPLE_COUNT with count $cnt... \"\n\n  # If we already have this tuple, skip it.\n\n  grep -q \"^$tuple\\$\" \"$TRACE_DIR/.already_have\" && continue\n\n  FN=${BEST_FILE[tuple]}\n\n#  echo \"tuple nr $CUR ($tuple cnt=$cnt) -> $FN\" >> \"$TRACE_DIR/.log\"\n  $CP_TOOL \"$IN_DIR/$FN\" \"$OUT_DIR/$FN\"\n\n  if [ \"$((CUR % 5))\" = \"0\" ]; then\n    sort -u \"$TRACE_DIR/$FN\" \"$TRACE_DIR/.already_have\" >\"$TRACE_DIR/.tmp\"\n    mv -f \"$TRACE_DIR/.tmp\" \"$TRACE_DIR/.already_have\"\n  else\n    cat \"$TRACE_DIR/$FN\" >>\"$TRACE_DIR/.already_have\"\n  fi\n\ndone <\"$TRACE_DIR/.all_uniq\"\n\necho\n\nOUT_COUNT=`ls -- \"$OUT_DIR\" | wc -l`\n\nif [ \"$OUT_COUNT\" = \"1\" ]; then\n  echo \"[!] WARNING: All test cases had the same traces, check syntax!\"\nfi\n\necho \"[+] Narrowed down to $OUT_COUNT files, saved in '$OUT_DIR'.\"\necho\n\ntest \"$AFL_KEEP_TRACES\" = \"\" && rm -rf \"$TRACE_DIR\"\n\nexit 0\n"
        },
        {
          "name": "afl-persistent-config",
          "type": "blob",
          "size": 4.75,
          "content": "#!/bin/bash\n# written by jhertz\n# \n\ntest \"$1\" = \"-h\" -o \"$1\" = \"-hh\" -o \"$1\" = \"--help\" && {\n  echo 'afl-persistent-config'\n  echo\n  echo $0\n  echo\n  echo afl-persistent-config has no command line options\n  echo\n  echo afl-persistent-config permanently reconfigures the system to a high performance fuzzing state.\n  echo \"WARNING: this reduces the security of the system!\"\n  echo\n  echo Note that there is also afl-system-config which sets additional runtime\n  echo configuration options.\n  exit 0\n}\n\nif [ $# -ne 0 ]; then\n  echo \"ERROR: Unknown option(s): $@\"\n  exit 1\nfi\n\necho\necho \"WARNING: This scripts makes permanent configuration changes to the system to\"\necho \"         increase the performance for fuzzing. As a result, the system also\"\necho \"         becomes less secure against attacks! If you use this script, setup\"\necho \"         strong firewall rules and only make SSH available as a network\"\necho \"         service!\"\necho\necho -n \"Type \\\"YES\\\" to continue: \"\nread ANSWER\nif [[ \"$ANSWER\" != \"YES\" ]]; then\n  echo Input was not YES, aborting ...\n  exit 1\nfi\n\necho\nPLATFORM=`uname -s`\nARCH=`uname -m`\n\n# check that we're on Mac\nif [[ \"$PLATFORM\" = \"Darwin\" ]] ; then\n\n  # check if UID == 0\n  if [[ \"$EUID\" -ne 0 ]]; then\n    echo \"You need to be root to do this. E.g. use \\\"sudo\\\"\"\n    exit 1\n  fi\n\n  # check if SIP is disabled\n  if [[ ! $(csrutil status | grep \"disabled\") ]]; then\n    echo \"SIP needs to be disabled. Restart and press Command-R at reboot, Utilities => Terminal => enter \\\"csrutil disable\\\"\"\n    exit 1\n  fi\n\n  echo \"Checks passed.\"\n\n  echo \"Installing /Library/LaunchDaemons/shm_setup.plist\"\n\n  cat << EOF > /Library/LaunchDaemons/shm_setup.plist\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n  <dict>\n    <key>Label</key>\n    <string>shmemsetup</string>\n    <key>UserName</key>\n    <string>root</string>\n    <key>GroupName</key>\n    <string>wheel</string>\n    <key>ProgramArguments</key>\n    <array>\n      <string>/usr/sbin/sysctl</string>\n      <string>-w</string>\n      <string>kern.sysv.shmmax=524288000</string>\n      <string>kern.sysv.shmmin=1</string>\n      <string>kern.sysv.shmmni=128</string>\n      <string>kern.sysv.shmseg=48</string>\n      <string>kern.sysv.shmall=131072000</string>\n    </array>\n    <key>KeepAlive</key>\n    <false/>\n    <key>RunAtLoad</key>\n    <true/>\n  </dict>\n</plist>\nEOF\n\n  if [[ \"$ARCH\" = \"x86_64\" ]]; then\n    echo \"Disabling ASLR system wide\"\n    nvram boot-args=\"no_aslr=1\"\n  else\n    echo NOTICE: on ARM64 we do not know currently how to disable system wide ASLR, please report if you know how.\n  fi\n\n  echo\n  echo \"Reboot and enjoy your fuzzing\"\n  exit 0\nfi\n\nif [[ \"$PLATFORM\" = \"Linux\" ]] ; then\n\n  # check if UID == 0\n  if [[ \"$EUID\" -ne 0 ]]; then\n    echo \"You need to be root to do this. E.g. use \\\"sudo\\\"\"\n    exit 1\n  fi\n\n  echo \"Checks passed.\"\n\n  test -d /etc/sysctl.d || echo Error: /etc/sysctl.d directory not found, cannot install shmem config\n  test -d /etc/sysctl.d -a '!' -e /etc/sysctl.d/99-fuzzing.conf && {\n    echo \"Installing /etc/sysctl.d/99-fuzzing.conf\"\n    cat << EOF > /etc/sysctl.d/99-fuzzing.conf\nkernel.core_uses_pid=0\nkernel.core_pattern=core\nkernel.randomize_va_space=0\nkernel.sched_child_runs_first=1\nkernel.sched_autogroup_enabled=1\nkernel.sched_migration_cost_ns=50000000\nkernel.sched_latency_ns=250000000\nEOF\n  }\n\n  grub_try_disable_mitigation () {\n    KEY=\"$1\"\n    if ! grep -E \"^$KEY=\" /etc/default/grub | grep -E -q 'noibrs pcid nopti'; then\n      echo \"Configuring performance boot options\"\n      LINE=`grep -E \"^$KEY=\" /etc/default/grub | sed \"s/^$KEY=//\" | tr -d '\"'`\n      OPTIONS=\"$LINE ibpb=off ibrs=off kpti=off l1tf=off spec_rstack_overflow=off mds=off no_stf_barrier noibpb noibrs pcid nopti nospec_store_bypass_disable nospectre_v1 nospectre_v2 pcid=on pti=off spec_store_bypass_disable=off spectre_v2=off stf_barrier=off srbds=off noexec=off noexec32=off tsx=on tsx=on tsx_async_abort=off mitigations=off audit=0 hardened_usercopy=off ssbd=force-off\"\n      echo Setting boot options in /etc/default/grub to $KEY=\\\"$OPTIONS\\\"\n      sed -i \"s|^$KEY=.*|$KEY=\\\"$OPTIONS\\\"|\" /etc/default/grub\n    fi\n  }\n\n\n  if grep -E -q '^GRUB_CMDLINE_LINUX=' /etc/default/grub || grep -E -q '^GRUB_CMDLINE_LINUX_DEFAULT=' /etc/default/grub; then\n    grub_try_disable_mitigation \"GRUB_CMDLINE_LINUX_DEFAULT\"\n    # We also overwrite GRUB_CMDLINE_LINUX because some distributions already overwrite GRUB_CMDLINE_LINUX_DEFAULT\n    grub_try_disable_mitigation \"GRUB_CMDLINE_LINUX\"\n  else\n    echo \"Error: /etc/default/grub with GRUB_CMDLINE_LINUX is not present, cannot set boot options\"\n  fi\n\n  echo\n  echo \"Reboot and enjoy your fuzzing\"\n  exit 0\nfi\n\n\n\necho \"Error: Unknown platform \\\"$PLATFORM\\\", currently supported are Linux and MacOS.\"\nexit 1\n"
        },
        {
          "name": "afl-plot",
          "type": "blob",
          "size": 8.0068359375,
          "content": "#!/bin/sh\n#\n# american fuzzy lop++ - Advanced Persistent Graphing\n# -------------------------------------------------\n#\n# Originally written by Michal Zalewski\n# Based on a design & prototype by Michael Rash.\n#\n# Copyright 2014, 2015 Google Inc. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at:\n#\n#   https://www.apache.org/licenses/LICENSE-2.0\n#\n\nget_abs_path() {\n  echo $(cd \"`dirname \"$1\"`\" && pwd)/\"`basename \"$1\"`\"\n}\n\necho \"progress plotting utility for afl-fuzz by Michal Zalewski\"\necho\n\nGRAPHICAL=\"0\"\n\nif [ \"$1\"  = \"-g\" ] || [ \"$1\" = \"--graphical\" ]; then\nGRAPHICAL=\"1\"\nshift\nfi\n\nif [ \"$#\" != \"2\" ]; then\n\n  cat 1>&2 <<_EOF_\n$0 [ -g | --graphical ] afl_state_dir graph_output_dir\n\nThis program generates gnuplot images from afl-fuzz output data.\n\nUsage:\n\n    afl_state_dir       should point to an existing state directory for any\n                        active or stopped instance of afl-fuzz\n    graph_output_dir    should point to an empty directory where this\n                        tool can write the resulting plots to\n    -g, --graphical     (optional) display the plots in a graphical window\n                        (you should have built afl-plot-ui to use this option)\n\nThe program will put index.html and three PNG images in the output directory;\nyou should be able to view it with any web browser of your choice.\n_EOF_\n\n  exit 1\n\nfi\n\ninputdir=`get_abs_path \"$1\"`\noutputdir=`get_abs_path \"$2\"`\n\n#if [ \"$AFL_ALLOW_TMP\" = \"\" ]; then\n#\n#  echo \"$inputdir\" | grep -qE '^(/var)?/tmp/'\n#  T1=\"$?\"\n#\n#  echo \"$outputdir\" | grep -qE '^(/var)?/tmp/'\n#  T2=\"$?\"\n#\n#  if [ \"$T1\" = \"0\" -o \"$T2\" = \"0\" ]; then\n#\n#    echo \"[-] Error: this script shouldn't be used with shared /tmp directories.\" 1>&2\n#    exit 1\n#\n#  fi\n#\n#fi\n\nif [ ! -f \"$inputdir/plot_data\" ]; then\n\n  if [ -f \"$inputdir/default/plot_data\" ]; then\n\n    echo \"[-] Error: input directory is not valid (missing 'plot_data'), likely you mean $inputdir/default?\" 1>&2\n    exit 1\n\n  else\n\n    echo \"[-] Error: input directory is not valid (missing 'plot_data').\" 1>&2\n    exit 1\n\n  fi\n\nfi\n\nLINES=`cat \"$inputdir/plot_data\" | wc -l`\n\nif [ \"$LINES\" -lt 3 ]; then\n\n  echo \"[-] Error: plot_data carries too little data, let it run longer.\" 1>&2\n  exit 1\n\nfi\n\nBANNER=\"`cat \"$inputdir/fuzzer_stats\" 2> /dev/null | grep '^afl_banner ' | cut -d: -f2- | cut -b2-`\"\n\ntest \"$BANNER\" = \"\" && BANNER=\"(none)\"\n\nGNUPLOT=`command -v gnuplot 2>/dev/null`\n\nif [ \"$GNUPLOT\" = \"\" ]; then\n\n  echo \"[-] Error: can't find 'gnuplot' in your \\$PATH.\" 1>&2\n  exit 1\n\nfi\n\nmkdir \"$outputdir\" 2>/dev/null\n\nif [ ! -d \"$outputdir\" ]; then\n\n  echo \"[-] Error: unable to create the output directory - pick another location.\" 1>&2\n  exit 1\n\nfi\n\nrm -f \"$outputdir/high_freq.png\" \"$outputdir/low_freq.png\" \"$outputdir/exec_speed.png\" \"$outputdir/edges.png\"\nmv -f \"$outputdir/index.html\" \"$outputdir/index.html.orig\" 2>/dev/null\n\nGNUPLOT_SETUP=\"\n#set xdata time\n#set timefmt '%s'\n#set format x \\\"%b %d\\n%H:%M\\\"\nset tics font 'small'\nunset mxtics\nunset mytics\n\nset grid xtics linetype 0 linecolor rgb '#e0e0e0'\nset grid ytics linetype 0 linecolor rgb '#e0e0e0'\nset border linecolor rgb '#50c0f0'\nset tics textcolor rgb '#000000'\nset key outside\n\nset autoscale xfixmin\nset autoscale xfixmax\n\nset xlabel \\\"relative time in seconds\\\" font \\\"small\\\"\n\"\n\nPLOT_HF=\"\nset terminal png truecolor enhanced size 1000,300 butt\nset output '$outputdir/high_freq.png'\n\n$GNUPLOT_SETUP\n\nplot '$inputdir/plot_data' using 1:4 with filledcurve x1 title 'corpus count' linecolor rgb '#000000' fillstyle transparent solid 0.2 noborder, \\\\\n     '' using 1:3 with filledcurve x1 title 'current item' linecolor rgb '#f0f0f0' fillstyle transparent solid 0.5 noborder, \\\\\n     '' using 1:5 with lines title 'pending items' linecolor rgb '#0090ff' linewidth 3, \\\\\n     '' using 1:6 with lines title 'pending favs' linecolor rgb '#c00080' linewidth 3, \\\\\n     '' using 1:2 with lines title 'cycles done' linecolor rgb '#c000f0' linewidth 3\n\"\n\nPLOT_LF=\"\nset terminal png truecolor enhanced size 1000,200 butt\nset output '$outputdir/low_freq.png'\n\n$GNUPLOT_SETUP\n\nplot '$inputdir/plot_data' using 1:8 with filledcurve x1 title '' linecolor rgb '#c00080' fillstyle transparent solid 0.2 noborder, \\\\\n     '' using 1:8 with lines title ' uniq crashes' linecolor rgb '#c00080' linewidth 3, \\\\\n     '' using 1:9 with lines title 'uniq hangs' linecolor rgb '#c000f0' linewidth 3, \\\\\n     '' using 1:10 with lines title 'levels' linecolor rgb '#0090ff' linewidth 3\n\"\n\nPLOT_ES=\"\nset terminal png truecolor enhanced size 1000,200 butt\nset output '$outputdir/exec_speed.png'\n\n$GNUPLOT_SETUP\n\nplot '$inputdir/plot_data' using 1:11 with filledcurve x1 title '' linecolor rgb '#0090ff' fillstyle transparent solid 0.2 noborder, \\\\\n     '$inputdir/plot_data' using 1:11 with lines title '    execs/sec' linecolor rgb '#0090ff' linewidth 3 smooth bezier;\n\"\n\nPLOT_EG=\"\nset terminal png truecolor enhanced size 1000,300 butt\nset output '$outputdir/edges.png'\n\n$GNUPLOT_SETUP\n\nplot '$inputdir/plot_data' using 1:13 with lines title '        edges' linecolor rgb '#0090ff' linewidth 3\n\"\n\nif [ \"$#\" = \"2\" ] && [ \"$GRAPHICAL\" = \"1\" ]; then\n\nafl-plot-ui -h > /dev/null 2>&1\n\nif [ \"$?\" != \"0\" ]; then\n\ncat 1>&2 <<_EOF_\nYou do not seem to have the afl-plot-ui utility installed. If you have installed afl-plot-ui, make sure the afl-plot-ui executable is in your PATH.\nIf you are still facing any problems, please open an issue at https://github.com/AFLplusplus/AFLplusplus/issues.\n\nNo plots have been generated. Please rerun without the \"-g\" or \"--graphical\" flag to generate the plots.\n_EOF_\n\nexit 1\n\nfi\n\nrm -rf \"$outputdir/.tmp\"\nmkdir -p \"$outputdir/.tmp\"\nmkfifo \"$outputdir/.tmp/win_ids\" || exit 1\n\nafl-plot-ui > \"$outputdir/.tmp/win_ids\" &\nW_IDS=$(cat \"$outputdir/.tmp/win_ids\")\n\nrm -rf \"$outputdir/.tmp\"\n\nW_ID1=$(echo \"$W_IDS\" | head -n 1)\nW_ID2=$(echo \"$W_IDS\" | head -n 2 | tail -n 1)\nW_ID3=$(echo \"$W_IDS\" | head -n 3 | tail -n 1)\nW_ID4=$(echo \"$W_IDS\" | tail -n 1)\n\necho \"[*] Generating plots...\"\n\n(\n\ncat << _EOF_\n\n$PLOT_HF\nset term x11 window \"$W_ID3\"\nset output\nreplot\npause mouse close\n\n_EOF_\n\n) | gnuplot 2> /dev/null &\n\n(\n\ncat << _EOF_\n\n$PLOT_LF\nset term x11 window \"$W_ID4\"\nset output\nreplot\npause mouse close\n\n_EOF_\n\n) | gnuplot 2> /dev/null &\n\n(\n\ncat << _EOF_\n\n$PLOT_ES\nset term x11 window \"$W_ID2\"\nset output\nreplot\npause mouse close\n\n_EOF_\n\n) | gnuplot 2> /dev/null &\n\n(\n\ncat << _EOF_\n\n$PLOT_EG\nset term x11 window \"$W_ID1\"\nset output\nreplot\npause mouse close\n\n_EOF_\n\n) | gnuplot 2> /dev/null &\n\nsleep 1\n\nelse\n\necho \"[*] Generating plots...\"\n\n(\n\ncat << _EOF_\n\n$PLOT_HF\n\n$PLOT_LF\n\n$PLOT_ES\n\n$PLOT_EG\n\n_EOF_\n\n) | gnuplot || echo \"Note: if you see errors concerning 'unknown or ambiguous terminal type' then you need to use a gnuplot that has png support compiled in.\"\n\necho \"[?] You can also use -g flag to view the plots in an GUI window, and interact with the plots (if you have built afl-plot-ui). Run \\\"afl-plot -h\\\" to know more.\"\n\nfi\n\nif [ ! -s \"$outputdir/exec_speed.png\" ]; then\n\n  echo \"[-] Error: something went wrong! Perhaps you have an ancient version of gnuplot?\" 1>&2\n  exit 1\n\nfi\n\necho \"[*] Generating index.html...\"\n\ncat >\"$outputdir/index.html\" <<_EOF_\n<table style=\"font-family: 'Trebuchet MS', 'Tahoma', 'Arial', 'Helvetica'\">\n<tr><td style=\"width: 18ex\"><b>Banner:</b></td><td>$BANNER</td></tr>\n<tr><td><b>Directory:</b></td><td>$inputdir</td></tr>\n<tr><td><b>Generated on:</b></td><td>`date`</td></tr>\n</table>\n<p>\n<img src=\"edges.png\" width=1000 height=300>\n<img src=\"high_freq.png\" width=1000 height=300><p>\n<img src=\"low_freq.png\" width=1000 height=200><p>\n<img src=\"exec_speed.png\" width=1000 height=200>\n\n_EOF_\n\n# Make it easy to remotely view results when outputting directly to a directory\n# served by Apache or other HTTP daemon. Since the plots aren't horribly\n# sensitive, this seems like a reasonable trade-off.\n\nchmod 755 \"$outputdir\"\nchmod 644 \"$outputdir/high_freq.png\" \"$outputdir/low_freq.png\" \"$outputdir/exec_speed.png\" \"$outputdir/edges.png\" \"$outputdir/index.html\"\n\necho \"[+] All done - enjoy your charts!\"\n\nexit 0\n"
        },
        {
          "name": "afl-system-config",
          "type": "blob",
          "size": 5.857421875,
          "content": "#!/bin/sh\ntest \"$1\" = \"-h\" -o \"$1\" = \"-hh\" -o \"$1\" = \"--help\" && {\n  echo 'afl-system-config by Marc Heuse <mh@mh-sec.de>'\n  echo\n  echo $0\n  echo\n  echo afl-system-config has no command line options\n  echo\n  echo afl-system-config reconfigures the system to a high performance fuzzing state.\n  echo \"WARNING: this reduces the security of the system!\"\n  echo\n  echo Note that there is also afl-persistent-config which sets additional permanent\n  echo configuration options.\n  exit 0\n}\nif [ $# -ne 0 ]; then\n  echo \"ERROR: Unknown option(s): $@\"\n  exit 1\nfi\n\nDONE=\nPLATFORM=`uname -s`\necho This reconfigures the system to have a better fuzzing performance.\necho \"WARNING: this reduces the security of the system!\"\necho\nif [ '!' \"$EUID\" = 0 ] && [ '!' `id -u` = 0 ] ; then\n\techo \"Warning: you need to be root to run this!\"\n\tsleep 1\n\t# we do not exit as other mechanisms exist that allows to do this than\n\t# being root. let the errors speak for themselves.\nfi\nsleep 1\nif [ \"$PLATFORM\" = \"Linux\" ] ; then\n{\n  sysctl -w kernel.core_uses_pid=0\n  # Arch Linux requires core_pattern to be empty :(\n  test -e /etc/arch-release && sysctl -w kernel.core_pattern=\n  test -e /etc/arch-release || sysctl -w kernel.core_pattern=core\n  sysctl -w kernel.randomize_va_space=0\n  sysctl -w kernel.sched_child_runs_first=1\n  sysctl -w kernel.sched_autogroup_enabled=1\n  sysctl -w kernel.sched_migration_cost_ns=50000000 2>/dev/null\n  sysctl -w kernel.sched_latency_ns=250000000 2>/dev/null\n  echo never > /sys/kernel/mm/transparent_hugepage/enabled\n  test -e /sys/devices/system/cpu/cpufreq/scaling_governor && echo performance | tee /sys/devices/system/cpu/cpufreq/scaling_governor\n  test -e /sys/devices/system/cpu/cpufreq/policy0/scaling_governor && echo performance | tee /sys/devices/system/cpu/cpufreq/policy*/scaling_governor\n  test -e /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor && echo performance | tee /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor\n  test -e /sys/devices/system/cpu/intel_pstate/no_turbo && echo 0 > /sys/devices/system/cpu/intel_pstate/no_turbo\n  test -e /sys/devices/system/cpu/cpufreq/boost && echo 1 > /sys/devices/system/cpu/cpufreq/boost\n  test -e /sys/devices/system/cpu/intel_pstate/max_perf_pct && echo 100 > /sys/devices/system/cpu/intel_pstate/max_perf_pct\n  test -n \"$(which auditctl)\" && auditctl -a never,task >/dev/null 2>&1\n} > /dev/null\n  echo Settings applied.\n  echo\n  dmesg | grep -E -q 'noibrs pcid nopti' || {\n    echo It is recommended to boot the kernel with lots of security off - if you are running a machine that is in a secured network - so set this:\n    echo '  /etc/default/grub:GRUB_CMDLINE_LINUX_DEFAULT=\"ibpb=off ibrs=off kpti=0 l1tf=off mds=off mitigations=off no_stf_barrier noibpb noibrs pcid nopti nospec_store_bypass_disable nospectre_v1 nospectre_v2 pcid=on pti=off spec_store_bypass_disable=off spectre_v2=off stf_barrier=off srbds=off noexec=off noexec32=off tsx=on tsx_async_abort=off arm64.nopauth audit=0 hardened_usercopy=off ssbd=force-off\"'\n    echo\n  }\n  echo If you run fuzzing instances in docker, run them with \\\"--security-opt seccomp=unconfined\\\" for more speed.\n  echo\n  DONE=1\nfi\nif [ \"$PLATFORM\" = \"FreeBSD\" ] ; then\n{\n  sysctl kern.elf32.aslr.enable=0\n  sysctl kern.elf64.aslr.enable=0\n} > /dev/null\n  echo Settings applied.\n  echo\n  cat <<EOF\nIn order to suppress core file generation during fuzzing it is recommended to set\nme:\\\\\n\t:coredumpsize=0:\nin the ~/.login_conf file for the user used for fuzzing.\nEOF\n  echo It is recommended to boot the kernel with lots of security off - if you are running a machine that is in a secured network - so set this:\n  echo '  sysctl hw.ibrs_disable=1'\n  echo 'Setting kern.pmap.pg_ps_enabled=0 into /boot/loader.conf might be helpful too.'\n  echo\n  DONE=1\nfi\nif [ \"$PLATFORM\" = \"OpenBSD\" ] ; then\n  doas sysctl vm.malloc_conf=\n  echo 'Freecheck on allocation in particular can be detrimental to performance.'\n  echo 'Also we might not want necessarily to abort at any allocation failure.'\n  echo 'System security features cannot be disabled on OpenBSD.'\n  echo\n  DONE=1\nfi\nif [ \"$PLATFORM\" = \"DragonFly\" ] ; then\n  #/sbin/sysctl kern.corefile=/dev/null\n  #echo Settings applied.\n  cat <<EOF\nIn order to suppress core file generation during fuzzing it is recommended to set\nme:\\\\\n\t:coredumpsize=0:\nin the ~/.login_conf file for the user used for fuzzing.\nEOF\n  echo\n  DONE=1\nfi\nif [ \"$PLATFORM\" = \"NetBSD\" ] ; then\n{\n  /sbin/sysctl -w security.models.extensions.user_set_cpu_affinity=1\n} > /dev/null\n  echo Settings applied.\n  echo\n  DONE=1\nfi\nif [ \"$PLATFORM\" = \"Darwin\" ] ; then\n  sysctl kern.sysv.shmmax=524288000\n  sysctl kern.sysv.shmmin=1\n  sysctl kern.sysv.shmseg=48\n  sysctl kern.sysv.shmall=131072000\n  echo Settings applied.\n  echo\n  if $(launchctl list 2>/dev/null | grep -q '\\.ReportCrash\\>') ; then\n    echo\n    echo Unloading the default crash reporter\n    SL=/System/Library; PL=com.apple.ReportCrash\n    sudo -u \"$SUDO_USER\" launchctl unload -w ${SL}/LaunchAgents/${PL}.plist\n    launchctl unload -w ${SL}/LaunchDaemons/${PL}.Root.plist\n    echo\n  fi\n  echo It is recommended to disable System Integrity Protection for increased performance.\n  echo See: https://developer.apple.com/documentation/security/disabling_and_enabling_system_integrity_protection\n  echo\n  DONE=1\nfi\nif [ \"$PLATFORM\" = \"Haiku\" ] ; then\n  DEBUG_SERVER_DIR=~/config/settings/system/debug_server\n  [ ! -d ${DEBUG_SERVER_DIR} ] && mkdir -p ${DEBUG_SERVER_DIR}\n  SETTINGS=${DEBUG_SERVER_DIR}/settings\n  [ -r ${SETTINGS} ] && grep -qE \"default_action\\s+kill\" ${SETTINGS} && { echo \"Nothing to do\"; } || { \\\n    echo We change the debug_server default_action from user to silently kill; \\\n    [ ! -r ${SETTINGS} ] && echo \"default_action kill\" >${SETTINGS} || { mv ${SETTINGS} s.tmp; sed -e \"s/default_action\\s\\s*user/default_action kill/\" s.tmp > ${SETTINGS}; rm s.tmp; }; \\\n    echo Settings applied.; echo; \\\n  }\n  DONE=1\nfi\ntest -z \"$DONE\" && echo Error: Unknown platform: $PLATFORM\nexit 0\n"
        },
        {
          "name": "afl-whatsup",
          "type": "blob",
          "size": 11.3349609375,
          "content": "#!/bin/sh\n#\n# american fuzzy lop++ - status check tool\n# ----------------------------------------\n#\n# Originally written by Michal Zalewski\n#\n# Copyright 2015 Google Inc. All rights reserved.\n# Copyright 2019-2024 AFLplusplus Project. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at:\n#\n#   https://www.apache.org/licenses/LICENSE-2.0\n#\n# This tool summarizes the status of any locally-running synchronized\n# instances of afl-fuzz.\n#\n\ntest \"$1\" = \"-h\" -o \"$1\" = \"-hh\" && {\n  echo \"$0 status check tool for afl-fuzz by Michal Zalewski\"\n  echo\n  echo \"Usage: $0 [-s] [-d] afl_output_directory\"\n  echo\n  echo Options:\n  echo \"  -d  -  include dead fuzzer stats\"\n  echo \"  -m  -  just show minimal stats\"\n  echo \"  -n  -  no color output\"\n  echo \"  -s  -  skip details and output summary results only\"\n  echo\n  exit 1\n}\n\nunset MINIMAL_ONLY\nunset NO_COLOR\nunset PROCESS_DEAD\nunset SUMMARY_ONLY\nunset RED\nunset GREEN\nunset YELLOW\nunset BLUE\nunset NC\nunset RESET\n\nif [ -z \"$TERM\" ]; then export TERM=vt220; fi\n\nwhile [ \"$1\" = \"-d\" -o \"$1\" = \"-m\"  -o \"$1\" = \"-n\"  -o \"$1\" = \"-s\" ]; do\n  \n  if [ \"$1\" = \"-d\" ]; then\n    PROCESS_DEAD=1\n  fi\n  \n  if [ \"$1\" = \"-m\" ]; then\n    MINIMAL_ONLY=1\n  fi\n  \n  if [ \"$1\" = \"-n\" ]; then\n    NO_COLOR=1\n  fi\n  \n  if [ \"$1\" = \"-s\" ]; then\n    SUMMARY_ONLY=1\n  fi\n  \n  shift\n  \ndone\n\nDIR=\"$1\"\n\nif [ \"$DIR\" = \"\" -o \"$DIR\" = \"-h\" -o \"$DIR\" = \"--help\" ]; then\n  \n  echo \"$0 status check tool for afl-fuzz by Michal Zalewski\" 1>&2\n  echo 1>&2\n  echo \"Usage: $0 [-d] [-m] [-n] [-s] afl_output_directory\" 1>&2\n  echo 1>&2\n  echo Options: 1>&2\n  echo \"  -d  -  include dead fuzzer stats\" 1>&2\n  echo \"  -m  -  just show minimal stats\" 1>&2\n  echo \"  -n  -  no color output\" 1>&2\n  echo \"  -s  -  skip details and output summary results only\" 1>&2\n  echo 1>&2\n  exit 1\n  \nfi\n\nif [ -z \"$MINIMAL_ONLY\" ]; then\n  echo \"$0 status check tool for afl-fuzz by Michal Zalewski\"\n  echo\nfi\n\ncd \"$DIR\" || exit 1\n\nif [ -d queue ]; then\n  \n  echo \"[-] Error: parameter is an individual output directory, not a sync dir.\" 1>&2\n  exit 1\n  \nfi\n\nBC=`which bc 2>/dev/null`\nFUSER=`which fuser 2>/dev/null`\n\nif [ -z \"$NO_COLOR\" ]; then\n  RED=`tput setaf 9 1 1 2>/dev/null`\n  GREEN=`tput setaf 2 1 1 2>/dev/null`\n  BLUE=`tput setaf 4 1 1 2>/dev/null`\n  YELLOW=`tput setaf 11 1 1 2>/dev/null`\n  NC=`tput sgr0`\n  RESET=\"$NC\"\nfi\n\nPLATFORM=`uname -s`\n#if [ \"$PLATFORM\" = \"Linux\" ] ; then\n#  CUR_TIME=`cat /proc/uptime | awk '{printf \"%.0f\\n\", $1}'`\n#else\n  # This will lead to inacurate results but will prevent the script from breaking on platforms other than Linux\n  CUR_TIME=`date +%s`\n#fi\n\nTMP=`mktemp -t .afl-whatsup-XXXXXXXX` || TMP=`mktemp -p /data/local/tmp .afl-whatsup-XXXXXXXX` || TMP=`mktemp -p /data/local/tmp .afl-whatsup-XXXXXXXX` || exit 1\ntrap \"rm -f $TMP\" 1 2 3 13 15\n\nALIVE_CNT=0\nDEAD_CNT=0\nSTART_CNT=0\n\nTOTAL_TIME=0\nTOTAL_EXECS=0\nTOTAL_EPS=0\nTOTAL_EPLM=0\nTOTAL_CRASHES=0\nTOTAL_HANGS=0\nTOTAL_PFAV=0\nTOTAL_PENDING=0\nTOTAL_COVERAGE=\n\n# Time since last find / crash / hang, formatted as string\nFMT_TIME=\"0 days 0 hours\"\nFMT_FIND=\"${RED}none seen yet${NC}\"\nFMT_CRASH=\"none seen yet\"\nFMT_HANG=\"none seen yet\"\n\nif [ \"$SUMMARY_ONLY\" = \"\" ]; then\n  \n  echo \"Individual fuzzers\"\n  echo \"==================\"\n  echo\n  \nfi\n\nfmt_duration()\n{\n  DUR_STRING=\n  if [ $1 -le 0 ]; then\n    return 1\n  fi\n  \n  local duration=$((CUR_TIME - $1))\n  local days=$((duration / 60 / 60 / 24))\n  local hours=$(((duration / 60 / 60) % 24))\n  local minutes=$(((duration / 60) % 60))\n  local seconds=$((duration % 60))\n  \n  if [ $duration -le 0 ]; then\n    DUR_STRING=\"0 seconds\"\n    elif [ $duration -eq 1 ]; then\n    DUR_STRING=\"1 second\"\n    elif [ $days -gt 0 ]; then\n    DUR_STRING=\"$days days, $hours hours\"\n    elif [ $hours -gt 0 ]; then\n    DUR_STRING=\"$hours hours, $minutes minutes\"\n    elif [ $minutes -gt 0 ]; then\n    DUR_STRING=\"$minutes minutes, $seconds seconds\"\n  else\n    DUR_STRING=\"$seconds seconds\"\n  fi\n}\n\nFIRST=true\nTOTAL_WCOP=\nTOTAL_LAST_FIND=0\n\nfor j in `find . -maxdepth 2 -iname fuzzer_setup | sort`; do\n  \n  DIR=$(dirname \"$j\")\n  i=$DIR/fuzzer_stats\n  \n  if [ -f \"$i\" ]; then\n    \n    IS_STARTING=\n    IS_DEAD=\n    sed 's/^command_line.*$/_skip:1/;s/[ ]*:[ ]*/=\"/;s/$/\"/' \"$i\" >\"$TMP\"\n    . \"$TMP\"\n    DIRECTORY=$DIR\n    DIR=${DIR##*/}\n    RUN_UNIX=$run_time\n    RUN_DAYS=$((RUN_UNIX / 60 / 60 / 24))\n    RUN_HRS=$(((RUN_UNIX / 60 / 60) % 24))\n    COVERAGE=$(echo $bitmap_cvg|tr -d %)\n    if [ -n \"$TOTAL_COVERAGE\" -a -n \"$COVERAGE\" -a -n \"$BC\" ]; then\n      if [ \"$(echo \"$TOTAL_COVERAGE < $COVERAGE\" | bc)\" -eq 1 ]; then\n        TOTAL_COVERAGE=$COVERAGE\n      fi\n    fi\n    if [ -z \"$TOTAL_COVERAGE\" ]; then TOTAL_COVERAGE=$COVERAGE ; fi\n    \n    test -n \"$cycles_wo_finds\" && {\n      test -z \"$FIRST\" && TOTAL_WCOP=\"${TOTAL_WCOP}/\"\n      TOTAL_WCOP=\"${TOTAL_WCOP}${cycles_wo_finds}\"\n      FIRST=\n    }\n    \n    if [ \"$SUMMARY_ONLY\" = \"\" ]; then\n      \n      echo \">>> $afl_banner instance: $DIR ($RUN_DAYS days, $RUN_HRS hrs) fuzzer PID: $fuzzer_pid <<<\"\n      echo\n      \n    fi\n    \n    if ! kill -0 \"$fuzzer_pid\" 2>/dev/null; then\n      \n      if [ -e \"$i\" ] && [ -e \"$j\" ] && [ -n \"$FUSER\" ]; then\n        \n        if [ \"$i\" -ot \"$j\" ]; then\n          \n          # fuzzer_setup is newer than fuzzer_stats, maybe the instance is starting?\n          TMP_PID=`fuser -v \"$DIRECTORY\" 2>&1 | grep afl-fuzz`\n          \n          if [ -n \"$TMP_PID\" ]; then\n            \n            if [ \"$SUMMARY_ONLY\" = \"\" ]; then\n              \n              echo \"  Instance is still starting up, skipping.\"\n              echo\n              \n            fi\n            \n            START_CNT=$((START_CNT + 1))\n            last_find=0\n            IS_STARTING=1\n            \n            if [ \"$PROCESS_DEAD\" = \"\" ]; then\n              \n              continue\n              \n            fi\n            \n          fi\n          \n        fi\n        \n      fi\n      \n      if [ -z \"$IS_STARTING\" ]; then\n        \n        if [ \"$SUMMARY_ONLY\" = \"\" ]; then\n          \n          echo \"  Instance is dead or running remotely, skipping.\"\n          echo\n          \n        fi\n        \n        DEAD_CNT=$((DEAD_CNT + 1))\n        IS_DEAD=1\n        last_find=0\n        \n        if [ \"$PROCESS_DEAD\" = \"\" ]; then\n          \n          continue\n          \n        fi\n        \n      fi\n      \n    fi\n    \n    ALIVE_CNT=$((ALIVE_CNT + 1))\n    \n    EXEC_SEC=0\n    EXEC_MIN=0\n    test -z \"$RUN_UNIX\" -o \"$RUN_UNIX\" = 0 || EXEC_SEC=$((execs_done / RUN_UNIX))\n    PATH_PERC=$((cur_item * 100 / corpus_count))\n\n    test \"$IS_DEAD\" = 1 || EXEC_MIN=$(echo $execs_ps_last_min|sed 's/\\..*//')\n    \n    TOTAL_TIME=$((TOTAL_TIME + RUN_UNIX))\n    TOTAL_EPS=$((TOTAL_EPS + EXEC_SEC))\n    TOTAL_EPLM=$((TOTAL_EPLM + EXEC_MIN))\n    TOTAL_EXECS=$((TOTAL_EXECS + execs_done))\n    TOTAL_CRASHES=$((TOTAL_CRASHES + saved_crashes))\n    TOTAL_HANGS=$((TOTAL_HANGS + saved_hangs))\n    TOTAL_PENDING=$((TOTAL_PENDING + pending_total))\n    TOTAL_PFAV=$((TOTAL_PFAV + pending_favs))\n    \n    if [ \"$last_find\" -gt \"$TOTAL_LAST_FIND\" ]; then\n      TOTAL_LAST_FIND=$last_find\n    fi\n    \n    if [ \"$SUMMARY_ONLY\" = \"\" ]; then\n      \n      # Warnings in red\n      TIMEOUT_PERC=$((exec_timeout * 100 / execs_done))\n      if [ $TIMEOUT_PERC -ge 10 ]; then\n        echo \"  ${RED}timeout_ratio $TIMEOUT_PERC%${NC}\"\n      fi\n      \n      if [ $EXEC_SEC -eq 0 ]; then\n        echo \"  ${YELLOW}no data yet, 0 execs/sec${NC}\"\n        elif [ $EXEC_SEC -lt 100 ]; then\n        echo \"  ${RED}slow execution, $EXEC_SEC execs/sec${NC}\"\n      fi\n      \n      fmt_duration $last_find && FMT_FIND=$DUR_STRING\n      fmt_duration $last_crash && FMT_CRASH=$DUR_STRING\n      fmt_duration $last_hang && FMT_HANG=$DUR_STRING\n      FMT_CWOP=\"not available\"\n      test -n \"$cycles_wo_finds\" && {\n        test \"$cycles_wo_finds\" = 0 && FMT_CWOP=\"$cycles_wo_finds\"\n        test \"$cycles_wo_finds\" -gt 10 && FMT_CWOP=\"${YELLOW}$cycles_wo_finds${NC}\"\n        test \"$cycles_wo_finds\" -gt 50 && FMT_CWOP=\"${RED}$cycles_wo_finds${NC}\"\n      }\n      \n      echo \"  last_find       : $FMT_FIND\"\n      echo \"  last_crash      : $FMT_CRASH\"\n      if [ -z \"$MINIMAL_ONLY\" ]; then\n        echo \"  last_hang       : $FMT_HANG\"\n        echo \"  cycles_wo_finds : $FMT_CWOP\"\n      fi\n      echo \"  coverage        : $COVERAGE%\"\n      \n      if [ -z \"$MINIMAL_ONLY\" ]; then\n        \n        CPU_USAGE=$(ps aux | grep -w $fuzzer_pid | grep -v grep | awk '{print $3}')\n        MEM_USAGE=$(ps aux | grep -w $fuzzer_pid | grep -v grep | awk '{print $4}')\n        \n        echo \"  cpu usage $CPU_USAGE%, memory usage $MEM_USAGE%\"\n        \n      fi\n      \n      echo \"  cycles $((cycles_done + 1)), lifetime speed $EXEC_SEC execs/sec, items $cur_item/$corpus_count (${PATH_PERC}%)\"\n      \n      if [ \"$saved_crashes\" = \"0\" ]; then\n        echo \"  pending $pending_favs/$pending_total, coverage $bitmap_cvg, no crashes yet\"\n      else\n        echo \"  pending $pending_favs/$pending_total, coverage $bitmap_cvg, crashes saved $saved_crashes (!)\"\n      fi\n      \n      echo\n      \n    fi\n\n  else\n\n    if [ ! -e \"$i\" -a -e \"$j\" ]; then\n\n      if [ '!' \"$PROCESS_DEAD\" = \"\" ]; then\n        ALIVE_CNT=$((ALIVE_CNT + 1))\n      fi\n      START_CNT=$((START_CNT + 1))\n      last_find=0\n      IS_STARTING=1\n      \n    fi\n\n  fi\n  \ndone\n\n# Formatting for total time, time since last find, crash, and hang\nfmt_duration $((CUR_TIME - TOTAL_TIME)) && FMT_TIME=$DUR_STRING\n# Formatting for total execution\nFMT_EXECS=\"0 millions\"\nEXECS_MILLION=$((TOTAL_EXECS / 1000 / 1000))\nEXECS_THOUSAND=$((TOTAL_EXECS / 1000 % 1000))\nif [ $EXECS_MILLION -gt 9 ]; then\n  FMT_EXECS=\"$EXECS_MILLION millions\"\n  elif [ $EXECS_MILLION -gt 0 ]; then\n  FMT_EXECS=\"$EXECS_MILLION millions, $EXECS_THOUSAND thousands\"\nelse\n  FMT_EXECS=\"$EXECS_THOUSAND thousands\"\nfi\n\nrm -f \"$TMP\"\n\nTOTAL_DAYS=$((TOTAL_TIME / 60 / 60 / 24))\nTOTAL_HRS=$(((TOTAL_TIME / 60 / 60) % 24))\n\ntest -z \"$TOTAL_WCOP\" && TOTAL_WCOP=\"not available\"\nfmt_duration $TOTAL_LAST_FIND && TOTAL_LAST_FIND=$DUR_STRING\n\ntest \"$TOTAL_TIME\" = \"0\" && TOTAL_TIME=1\n\nif [ \"$PROCESS_DEAD\" = \"\" ]; then\n  \n  TXT=\"excluded from stats\"\n  \nelse\n  \n  TXT=\"included in stats\"\n  ALIVE_CNT=$(($ALIVE_CNT - $DEAD_CNT - $START_CNT))\n  \nfi\n\necho \"Summary stats\"\necho \"=============\"\nif [ -z \"$SUMMARY_ONLY\" -o -z \"$MINIMAL_ONLY\" ]; then\n  echo\nfi\n\necho \"        Fuzzers alive : $ALIVE_CNT\"\n\nif [ ! \"$START_CNT\" = \"0\" ]; then\n  echo \"          Starting up : $START_CNT ($TXT)\"\nfi\n\nif [ ! \"$DEAD_CNT\" = \"0\" ]; then\n  echo \"       Dead or remote : $DEAD_CNT ($TXT)\"\nfi\n\necho \"       Total run time : $FMT_TIME\"\nif [ -z \"$MINIMAL_ONLY\" ]; then\n  echo \"          Total execs : $FMT_EXECS\"\n  echo \"     Cumulative speed : $TOTAL_EPS execs/sec\"\n  if [ \"$ALIVE_CNT\" -gt \"0\" ]; then\n    echo \"  Total average speed : $((TOTAL_EPS / ALIVE_CNT)) execs/sec\"\n  fi\nfi\nif [ \"$ALIVE_CNT\" -gt \"0\" ]; then\n  echo \"Current average speed : $TOTAL_EPLM execs/sec\"\nfi\nif [ -z \"$MINIMAL_ONLY\" ]; then\n  echo \"        Pending items : $TOTAL_PFAV faves, $TOTAL_PENDING total\"\nfi\n\nif [ \"$ALIVE_CNT\" -gt \"1\" -o -n \"$MINIMAL_ONLY\" ]; then\n  if [ \"$ALIVE_CNT\" -gt \"0\" ]; then\n    echo \"   Pending per fuzzer : $((TOTAL_PFAV/ALIVE_CNT)) faves, $((TOTAL_PENDING/ALIVE_CNT)) total (on average)\"\n  fi\nfi\n\necho \"     Coverage reached : ${TOTAL_COVERAGE}%\"\necho \"        Crashes saved : $TOTAL_CRASHES\"\nif [ -z \"$MINIMAL_ONLY\" ]; then\n  echo \"          Hangs saved : $TOTAL_HANGS\"\n  echo \" Cycles without finds : $TOTAL_WCOP\"\nfi\necho \"   Time without finds : $TOTAL_LAST_FIND\"\necho\n\nexit 0\n"
        },
        {
          "name": "afl-wine-trace",
          "type": "blob",
          "size": 3.3427734375,
          "content": "#!/usr/bin/env python3\n\nimport os\nimport sys\nimport pefile\nimport shutil\nimport subprocess\n\nif len(sys.argv) < 2:\n    print(\"[afl-wine-trace] usage: ./afl-wine-trace binary [args...]\\n\")\n    exit(1)\n\nif os.getenv(\"AFL_PATH\"):\n    my_dir = os.getenv(\"AFL_PATH\")\nelse:\n    my_dir = os.path.dirname(os.path.abspath(__file__))\n\nos.environ[\"WINELOADERNOEXEC\"] = \"1\"\n\npe = pefile.PE(sys.argv[1])\n\nif \"AFL_ENTRYPOINT\" not in os.environ:\n    os.environ[\"AFL_ENTRYPOINT\"] = \"0x%x\" % (pe.OPTIONAL_HEADER.ImageBase + pe.OPTIONAL_HEADER.AddressOfEntryPoint)\nif not os.getenv(\"AFL_INST_LIBS\"):\n    if \"AFL_CODE_START\" not in os.environ:\n        os.environ[\"AFL_CODE_START\"] = \"0x%x\" % (pe.OPTIONAL_HEADER.ImageBase + pe.OPTIONAL_HEADER.BaseOfCode)\n    if \"AFL_CODE_END\" not in os.environ:\n        os.environ[\"AFL_CODE_END\"] = \"0x%x\" % (pe.OPTIONAL_HEADER.ImageBase + pe.OPTIONAL_HEADER.BaseOfCode + pe.OPTIONAL_HEADER.SizeOfCode)\n\nif pe.FILE_HEADER.Machine == pefile.MACHINE_TYPE[\"IMAGE_FILE_MACHINE_AMD64\"] or pe.FILE_HEADER.Machine == pefile.MACHINE_TYPE[\"IMAGE_FILE_MACHINE_IA64\"]:\n    os.environ[\"QEMU_SET_ENV\"] = \"LD_PRELOAD=\" + os.path.join(my_dir, \"qemu_mode/unsigaction/unsigaction64.so\") + \",WINEARCH=win64\"\nelse:\n    os.environ[\"QEMU_SET_ENV\"] = \"LD_PRELOAD=\" + os.path.join(my_dir, \"qemu_mode/unsigaction/unsigaction32.so\") + \",WINEARCH=win32\"\n\nif os.getenv(\"WINECOV_QEMU_PATH\"):\n    qemu_path = os.getenv(\"WINECOV_QEMU_PATH\")\nelif os.path.exists(os.path.join(my_dir, \"afl-qemu-trace\")):\n    qemu_path = os.path.join(my_dir, \"afl-qemu-trace\")\nelse:\n    qemu_path = \"qemu-\"\n    if pe.FILE_HEADER.Machine == pefile.MACHINE_TYPE[\"IMAGE_FILE_MACHINE_AMD64\"] or pe.FILE_HEADER.Machine == pefile.MACHINE_TYPE[\"IMAGE_FILE_MACHINE_IA64\"]:\n        qemu_path += \"x86_64\"\n    elif pe.FILE_HEADER.Machine == pefile.MACHINE_TYPE[\"IMAGE_FILE_MACHINE_I386\"]:\n        qemu_path += \"i386\"\n    else:\n        print (\"[afl-wine-trace] unsuppoted architecture\\n\")\n        exit(1)\n    qemu_path = shutil.which(qemu_path)\n\nwine_path = None\nif os.getenv(\"AFL_WINE_PATH\"):\n    wine_path = os.getenv(\"AFL_WINE_PATH\")\nelse:\n    if not wine_path and shutil.which(\"wine\"):\n        wine_path = shutil.which(\"wine\")\n    if not wine_path and os.path.exists(\"/usr/bin/wine\"):\n        wine_path = \"/usr/bin/wine\"\n    if not wine_path and os.path.exists(\"/usr/lib/wine/wine\"):\n        wine_path = \"/usr/lib/wine/wine\"\n    if pe.FILE_HEADER.Machine == pefile.MACHINE_TYPE[\"IMAGE_FILE_MACHINE_AMD64\"] or pe.FILE_HEADER.Machine == pefile.MACHINE_TYPE[\"IMAGE_FILE_MACHINE_IA64\"]:\n        wine_path += \"64\"\n    elif pe.FILE_HEADER.Machine == pefile.MACHINE_TYPE[\"IMAGE_FILE_MACHINE_I386\"]:\n        pass\n    else:\n        print (\"[afl-wine-trace] unsopported architecture\\n\")\n        exit(1)\n\nargv = sys.argv[1:]\nfor i in range(len(argv)):\n    if \".cur_input\" in argv[i]:\n        # Get the Wine translated path using the winepath tool\n        arg_translated = subprocess.run([os.path.join(os.path.dirname(wine_path), \"winepath\"), \"--windows\", argv[i]], universal_newlines=True, stdout=subprocess.PIPE).stdout\n        # Remove the spurious LF at the end of the path\n        if len(arg_translated) > 0 and arg_translated[-1] == '\\n':\n            arg_translated = arg_translated[:-1]\n        argv[i] = arg_translated\n        break\n\nprint(\"[afl-wine-trace] exec:\", \" \".join([qemu_path, wine_path] + argv))\nos.execve(qemu_path, [qemu_path, wine_path] + argv, os.environ)\n"
        },
        {
          "name": "benchmark",
          "type": "tree",
          "content": null
        },
        {
          "name": "config.h",
          "type": "blob",
          "size": 0.015625,
          "content": "include/config.h"
        },
        {
          "name": "coresight_mode",
          "type": "tree",
          "content": null
        },
        {
          "name": "custom_mutators",
          "type": "tree",
          "content": null
        },
        {
          "name": "dictionaries",
          "type": "tree",
          "content": null
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "dynamic_list.txt",
          "type": "blob",
          "size": 1.59765625,
          "content": "{\n  \"__afl_already_initialized_first\";\n  \"__afl_already_initialized_forkserver\";\n  \"__afl_already_initialized_second\";\n  \"__afl_already_initialized_shm\";\n  \"__afl_area_ptr\";\n  \"__afl_auto_early\";\n  \"__afl_auto_first\";\n  \"__afl_auto_init\";\n  \"__afl_auto_second\";\n  \"__afl_connected\";\n  \"__afl_coverage_discard\";\n  \"__afl_coverage_interesting\";\n  \"__afl_coverage_off\";\n  \"__afl_coverage_on\";\n  \"__afl_coverage_skip\";\n  \"__afl_dictionary\";\n  \"__afl_dictionary_len\";\n  \"__afl_final_loc\";\n  \"__afl_fuzz_len\";\n  \"__afl_fuzz_ptr\";\n  \"__afl_manual_init\";\n  \"__afl_map_addr\";\n  \"__afl_persistent_loop\";\n  \"__afl_prev_caller\";\n  \"__afl_prev_ctx\";\n  \"__afl_prev_loc\";\n  \"__afl_selective_coverage\";\n  \"__afl_selective_coverage_start_off\";\n  \"__afl_selective_coverage_temp\";\n  \"__afl_sharedmem_fuzzing\";\n  \"__afl_trace\";\n  \"__cmplog_ins_hook1\";\n  \"__cmplog_ins_hook16\";\n  \"__cmplog_ins_hook2\";\n  \"__cmplog_ins_hook4\";\n  \"__cmplog_ins_hook8\";\n  \"__cmplog_ins_hookN\";\n  \"__cmplog_rtn_gcc_stdstring_cstring\";\n  \"__cmplog_rtn_gcc_stdstring_stdstring\";\n  \"__cmplog_rtn_hook\";\n  \"__cmplog_rtn_llvm_stdstring_cstring\";\n  \"__cmplog_rtn_llvm_stdstring_stdstring\";\n  \"__sanitizer_cov_trace_cmp1\";\n  \"__sanitizer_cov_trace_cmp16\";\n  \"__sanitizer_cov_trace_cmp2\";\n  \"__sanitizer_cov_trace_cmp4\";\n  \"__sanitizer_cov_trace_cmp8\";\n  \"__sanitizer_cov_trace_const_cmp1\";\n  \"__sanitizer_cov_trace_const_cmp16\";\n  \"__sanitizer_cov_trace_const_cmp2\";\n  \"__sanitizer_cov_trace_const_cmp4\";\n  \"__sanitizer_cov_trace_const_cmp8\";\n  \"__sanitizer_cov_trace_pc_guard\";\n  \"__sanitizer_cov_trace_pc_guard_init\";\n  \"__sanitizer_cov_trace_switch\";\n  \"LLVMFuzzerTestOneInput\";\n};\n"
        },
        {
          "name": "frida_mode",
          "type": "tree",
          "content": null
        },
        {
          "name": "include",
          "type": "tree",
          "content": null
        },
        {
          "name": "injections.dic",
          "type": "blob",
          "size": 0.0966796875,
          "content": "\"1'\\\" OR \\\"1\\\"=\\\"1\"\n\"1\\\"' OR '1'='1\"\n\"'\\\"><FUZZ\"\n\"*)(FUZZ=*))(|\"\n\"\\\";FUZZ;\\\"\"\n\"';FUZZ;'\"\n\"$(FUZZ)\"\n"
        },
        {
          "name": "instrumentation",
          "type": "tree",
          "content": null
        },
        {
          "name": "nyx_mode",
          "type": "tree",
          "content": null
        },
        {
          "name": "qemu_mode",
          "type": "tree",
          "content": null
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "test-instr.c",
          "type": "blob",
          "size": 1.6328125,
          "content": "/*\n   american fuzzy lop++ - a trivial program to test the build\n   --------------------------------------------------------\n   Originally written by Michal Zalewski\n   Copyright 2014 Google Inc. All rights reserved.\n   Copyright 2019-2024 AFLplusplus Project. All rights reserved.\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at:\n     https://www.apache.org/licenses/LICENSE-2.0\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\n#ifdef TEST_SHARED_OBJECT\n  #define main main_exported\n#endif\n\nint main(int argc, char **argv) {\n\n  int   fd = 0, cnt;\n  char  buff[8];\n  char *buf = buff;\n\n  // we support command line parameter and stdin\n  if (argc == 2) {\n\n    buf = argv[1];\n\n  } else {\n\n    if (argc >= 3 && strcmp(argv[1], \"-f\") == 0) {\n\n      if ((fd = open(argv[2], O_RDONLY)) < 0) {\n\n        fprintf(stderr, \"Error: unable to open %s\\n\", argv[2]);\n        exit(-1);\n\n      }\n\n    }\n\n    if ((cnt = read(fd, buf, sizeof(buf) - 1)) < 1) {\n\n      printf(\"Hum?\\n\");\n      return 1;\n\n    }\n\n    buf[cnt] = 0;\n\n  }\n\n  if (getenv(\"AFL_DEBUG\")) fprintf(stderr, \"test-instr: %s\\n\", buf);\n\n  // we support three input cases (plus a 4th if stdin is used but there is no\n  // input)\n  switch (buf[0]) {\n\n    case '0':\n      printf(\"Looks like a zero to me!\\n\");\n      break;\n\n    case '1':\n      printf(\"Pretty sure that is a one!\\n\");\n      break;\n\n    default:\n      printf(\"Neither one or zero? How quaint!\\n\");\n      break;\n\n  }\n\n  return 0;\n\n}\n\n"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "testcases",
          "type": "tree",
          "content": null
        },
        {
          "name": "types.h",
          "type": "blob",
          "size": 0.0146484375,
          "content": "include/types.h"
        },
        {
          "name": "unicorn_mode",
          "type": "tree",
          "content": null
        },
        {
          "name": "utils",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}